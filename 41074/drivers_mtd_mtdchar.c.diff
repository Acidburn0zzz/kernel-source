Index: linux-2.6.5/drivers/mtd/mtdchar.c
===================================================================
--- linux-2.6.5.orig/drivers/mtd/mtdchar.c
+++ linux-2.6.5/drivers/mtd/mtdchar.c
@@ -30,6 +30,8 @@ static loff_t mtd_lseek (struct file *fi
 {
 	struct mtd_info *mtd=(struct mtd_info *)file->private_data;
 
+
+	down(&mtd->mutex);
 	switch (orig) {
 	case 0:
 		/* SEEK_SET */
@@ -44,14 +46,16 @@ static loff_t mtd_lseek (struct file *fi
 		file->f_pos =mtd->size + offset;
 		break;
 	default:
+		up(&mtd->mutex);
 		return -EINVAL;
 	}
 
+	/* XXX Should return -EINVAL surely ?? */
 	if (file->f_pos < 0)
 		file->f_pos = 0;
 	else if (file->f_pos >= mtd->size)
 		file->f_pos = mtd->size - 1;
-
+	up(&mtd->mutex);
 	return file->f_pos;
 }
 
@@ -127,11 +131,16 @@ static ssize_t mtd_read(struct file *fil
 	
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
 
-	if (*ppos + count > mtd->size)
+	down(&mtd->mutex);
+	
+	if (count > mtd->size - *ppos)
 		count = mtd->size - *ppos;
 
 	if (!count)
+	{
+		up(&mtd->mutex);
 		return 0;
+	}
 	
 	/* FIXME: Use kiovec in 2.5 to lock down the user's buffers
 	   and pass them directly to the MTD functions */
@@ -143,13 +152,18 @@ static ssize_t mtd_read(struct file *fil
 
 		kbuf=kmalloc(len,GFP_KERNEL);
 		if (!kbuf)
+		{
+			up(&mtd->mutex);
+			/* API error - should return I/O done so far if > 0 */
 			return -ENOMEM;
-		
+		}		
 		ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
 		if (!ret) {
 			*ppos += retlen;
 			if (copy_to_user(buf, kbuf, retlen)) {
 			        kfree(kbuf);
+			        up(&mtd->mutex);
+				/* API error - should return I/O done so far if > 0 */
 				return -EFAULT;
 			}
 			else
@@ -160,12 +174,13 @@ static ssize_t mtd_read(struct file *fil
 		}
 		else {
 			kfree(kbuf);
+			up(&mtd->mutex);
 			return ret;
 		}
 		
 		kfree(kbuf);
 	}
-	
+	up(&mtd->mutex);	
 	return total_retlen;
 } /* mtd_read */
 
@@ -179,15 +194,22 @@ static ssize_t mtd_write(struct file *fi
 	int len;
 
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
-	
-	if (*ppos == mtd->size)
+
+	down(&mtd->mutex);	
+	if (*ppos >= mtd->size)
+	{
+		up(&mtd->mutex);
 		return -ENOSPC;
+	}
 	
-	if (*ppos + count > mtd->size)
+	if (count > mtd->size - *ppos)
 		count = mtd->size - *ppos;
 
 	if (!count)
+	{
+		up(&mtd->mutex);
 		return 0;
+	}
 
 	while (count) {
 		if (count > MAX_KMALLOC_SIZE) 
@@ -197,11 +219,14 @@ static ssize_t mtd_write(struct file *fi
 
 		kbuf=kmalloc(len,GFP_KERNEL);
 		if (!kbuf) {
-			printk("kmalloc is null\n");
+//			printk("kmalloc is null\n");
+			/* API bug should report I/O completed */
+			up(&mtd->mutex);
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(kbuf, buf, len)) {
+			up(&mtd->mutex);
 			kfree(kbuf);
 			return -EFAULT;
 		}
@@ -214,13 +239,15 @@ static ssize_t mtd_write(struct file *fi
 			buf += retlen;
 		}
 		else {
+			up(&mtd->mutex);
 			kfree(kbuf);
+			/* API bug ?? */
 			return ret;
 		}
 		
 		kfree(kbuf);
 	}
-
+	up(&mtd->mutex);
 	return total_retlen;
 } /* mtd_write */
 
