--- linux-2.6.7/arch/cris/arch-v10/drivers/eeprom.c	2004-06-16 21:11:35.000000000 +0100
+++ linux-2.6.7-viroized/arch/cris/arch-v10/drivers/eeprom.c	2004-06-27 21:49:16.036317512 +0100
@@ -95,6 +95,7 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <asm/uaccess.h>
+#include <asm/semaphore.h>
 #include "i2c.h"
 
 #define D(x) 
@@ -137,8 +138,6 @@
   int adapt_state; /* 1 = To high , 0 = Even, -1 = To low */
   
   /* this one is to keep the read/write operations atomic */
-  wait_queue_head_t wait_q;
-  volatile int busy;
   int retry_cnt_addr; /* Used to keep track of number of retries for
                          adaptive timing adjustments */
   int retry_cnt_read;
@@ -164,6 +163,7 @@
 
 /* chip description */
 static struct eeprom_type eeprom;
+static DECLARE_MUTEX(eeprom_mutex);
 
 /* This is the exported file-operations structure for this device. */
 struct file_operations eeprom_fops =
@@ -179,9 +179,6 @@
 
 int __init eeprom_init(void)
 {
-  init_waitqueue_head(&eeprom.wait_q);
-  eeprom.busy = 0;
-
 #ifdef CONFIG_ETRAX_I2C_EEPROM_PROBE
 #define EETEXT "Found"
 #else
@@ -461,43 +458,40 @@
 
 /* Changes the current file position. */
 
+/* XXX - requires a lock as does the read etc side */
+
 static loff_t eeprom_lseek(struct file * file, loff_t offset, int orig)
 {
+  loff_t pos;
 /*
  *  orig 0: position from begning of eeprom
  *  orig 1: relative from current position
  *  orig 2: position from last eeprom address
  */
+  down(&eeprom_lock);
   
   switch (orig)
   {
    case 0:
-     file->f_pos = offset;
+     pos = offset;
      break;
    case 1:
-     file->f_pos += offset;
+     pos = file->f_pos + offset;
      break;
    case 2:
-     file->f_pos = eeprom.size - offset;
+     pos = eeprom.size - offset;
      break;
    default:
      return -EINVAL;
   }
 
   /* truncate position */
-  if (file->f_pos < 0)
-  {
-    file->f_pos = 0;    
-    return(-EOVERFLOW);
-  }
-  
-  if (file->f_pos >= eeprom.size)
+  if (pos < 0 || pos >= eeprom.size)
   {
-    file->f_pos = eeprom.size - 1;
+    up(&eeprom_lock);
     return(-EOVERFLOW);
   }
-
-  return ( file->f_pos );
+  return ( file->f_pos = pos );
 }
 
 /* Reads data from eeprom. */
@@ -517,26 +511,19 @@
 static ssize_t eeprom_read(struct file * file, char * buf, size_t count, loff_t *off)
 {
   int read=0;
-  unsigned long p = file->f_pos;
+  loff_t p = *off;
 
   unsigned char page;
 
-  if(p >= eeprom.size)  /* Address i 0 - (size-1) */
-  {
-    return -EFAULT;
-  }
-  
-  while(eeprom.busy)
-  {
-    interruptible_sleep_on(&eeprom.wait_q);
 
-    /* bail out if we get interrupted */
-    if (signal_pending(current))
-      return -EINTR;
-    
-  }
-  eeprom.busy++;
+  if(down_interruptible(&eeprom_lock))
+  	return -EINTR;
 
+  if(p >= eeprom.size || count > eeprom.size - p)  /* Address i 0 - (size-1) */
+  {
+    up(&eeprom_lock);
+    return -EINVAL;
+  }
   page = (unsigned char) (p >> 8);
   
   if(!eeprom_address(p))
@@ -546,8 +533,7 @@
     i2c_stop();
     
     /* don't forget to wake them up */
-    eeprom.busy--;
-    wake_up_interruptible(&eeprom.wait_q);  
+    up(&eeprom_lock);
     return -EFAULT;
   }
 
@@ -571,11 +557,10 @@
   
   if(read > 0)
   {
-    file->f_pos += read;
+    *off = p + read;
   }
 
-  eeprom.busy--;
-  wake_up_interruptible(&eeprom.wait_q);
+  up(&eeprom_lock);
   return read;
 }
 
@@ -604,19 +589,14 @@
     return -EFAULT;
   }
 
-  while(eeprom.busy)
-  {
-    interruptible_sleep_on(&eeprom.wait_q);
-    /* bail out if we get interrupted */
-    if (signal_pending(current))
-      return -EINTR;
-  }
-  eeprom.busy++;
+  if(down_interruptible(&eeprom_lock))
+  	return -EINTR;
+
   for(i = 0; (i < EEPROM_RETRIES) && (restart > 0); i++)
   {
     restart = 0;
     written = 0;
-    p = file->f_pos;
+    p = *off;
    
     
     while( (written < count) && (p < eeprom.size))
@@ -629,9 +609,8 @@
         i2c_stop();
         
         /* don't forget to wake them up */
-        eeprom.busy--;
-        wake_up_interruptible(&eeprom.wait_q);
-        return -EFAULT;
+        up(&eeprom_lock);
+        return -EIO;
       }
 #ifdef EEPROM_ADAPTIVE_TIMING      
       /* Adaptive algorithm to adjust timing */
@@ -742,12 +721,12 @@
     } /* while */
   } /* for  */
 
-  eeprom.busy--;
-  wake_up_interruptible(&eeprom.wait_q);
-  if (written == 0 && file->f_pos >= eeprom.size){
+  if (written == 0 && p >= eeprom.size){
+    up(&eeprom_lock);
     return -ENOSPC;
   }
-  file->f_pos += written;
+  *off = p;
+  up(&eeprom_lock);
   return written;
 }
 
