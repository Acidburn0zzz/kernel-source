--- linux-2.6.7/drivers/macintosh/ans-lcd.c	2004-06-16 21:10:09.000000000 +0100
+++ linux-2.6.7-viroized/drivers/macintosh/ans-lcd.c	2004-06-27 18:49:16.624077720 +0100
@@ -22,6 +22,7 @@
 static unsigned long anslcd_short_delay = 80;
 static unsigned long anslcd_long_delay = 3280;
 static volatile unsigned char* anslcd_ptr;
+static DECLARE_MUTEX(anslcd_lock);
 
 #undef DEBUG
 
@@ -61,13 +62,15 @@
 
 	if ( verify_area(VERIFY_READ, buf, count) )
 		return -EFAULT;
-	for ( i = *ppos; count > 0; ++i, ++p, --count ) 
+		
+	down(&anslcd_lock);
+	for (; count > 0; ++p, --count ) 
 	{
 		char c;
 		__get_user(c, p);
 		anslcd_write_byte_data( c );
 	}
-	*ppos = i;
+	up(&anslcd_lock);
 	return p - buf;
 }
 
@@ -76,11 +79,14 @@
 				unsigned int cmd, unsigned long arg )
 {
 	char ch, *temp;
-
+	int ret = 0;
+	
 #ifdef DEBUG
 	printk(KERN_DEBUG "LCD: ioctl(%d,%d)\n",cmd,arg);
 #endif
 
+	down(&anslcd_lock);
+	
 	switch ( cmd )
 	{
 	case ANSLCD_CLEAR:
@@ -89,7 +95,7 @@
 		anslcd_write_byte_ctrl ( 0x06 );
 		anslcd_write_byte_ctrl ( 0x01 );
 		anslcd_write_byte_ctrl ( 0x02 );
-		return 0;
+		break;
 	case ANSLCD_SENDCTRL:
 		temp = (char *) arg;
 		__get_user(ch, temp);
@@ -97,20 +103,24 @@
 			anslcd_write_byte_ctrl ( ch );
 			__get_user(ch, temp);
 		}
-		return 0;
+		break;
 	case ANSLCD_SETSHORTDELAY:
 		if (!capable(CAP_SYS_ADMIN))
-			return -EACCES;
-		anslcd_short_delay=arg;
-		return 0;
+			ret = -EACCES;
+		else
+			anslcd_short_delay=arg;
+		break;
 	case ANSLCD_SETLONGDELAY:
 		if (!capable(CAP_SYS_ADMIN))
-			return -EACCES;
-		anslcd_long_delay=arg;
-		return 0;
+			ret = -EACCES;
+		else
+			anslcd_long_delay=arg;
+		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
 	}
+	up(&anslcd_lock);
+	return ret;
 }
 
 static int __pmac
@@ -121,6 +131,7 @@
 
 struct file_operations anslcd_fops = {
 	.write	= anslcd_write,
+	.lseek  = no_llseek,
 	.ioctl	= anslcd_ioctl,
 	.open	= anslcd_open,
 };
@@ -150,9 +161,16 @@
 		return -ENODEV;
 
 	anslcd_ptr = (volatile unsigned char*)ioremap(ANSLCD_ADDR, 0x20);
-	
+	if(anslcd_ptr == NULL)
+		return -ENOMEM;
+		
+	down(&anslcd_lock);	
+	/* Locked so that an opener cannot race the init writes to the
+	   chip after misc_register */
+	   
 	retval = misc_register(&anslcd_dev);
 	if(retval < 0){
+		up(&anslcd_lock);
 		printk(KERN_INFO "LCD: misc_register failed\n");
 		iounmap(anslcd_ptr);
 		return retval;
@@ -170,6 +188,7 @@
 	for(a=0;a<80;a++) {
 		anslcd_write_byte_data(anslcd_logo[a]);
 	}
+	up(&anslcd_lock);
 	return 0;
 }
 
