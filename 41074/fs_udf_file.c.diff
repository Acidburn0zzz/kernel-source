--- linux-2.6.7/fs/udf/file.c	2004-06-16 21:11:36.000000000 +0100
+++ linux-2.6.7-viroized/fs/udf/file.c	2004-06-28 14:39:38.929236944 +0100
@@ -114,15 +114,25 @@
 {
 	ssize_t retval;
 	struct inode *inode = file->f_dentry->d_inode;
-	int err, pos;
+	int err;
+	loff_t pos;
 
 	if (UDF_I_ALLOCTYPE(inode) == ICBTAG_FLAG_AD_IN_ICB)
 	{
+		/* FIXME: locking checks needed */
 		if (file->f_flags & O_APPEND)
 			pos = inode->i_size;
 		else
 			pos = *ppos;
 
+		/* Check limit here, but actual limit is due to variable
+		   types in lower order functions. These probaly need to
+		   be fixed and pushed down the stack */
+		if (pos < 0 || pos + count < pos || pos > 0x7FFFFFFF)
+			return -EFBIG;;
+		if (pos + count > 0x7FFFFFFF)
+			count = 0x7FFFFFFF - pos;
+
 		if (inode->i_sb->s_blocksize < (udf_file_entry_alloc_offset(inode) +
 			pos + count))
 		{
@@ -142,10 +152,10 @@
 		}
 	}
 
-	retval = generic_file_write(file, buf, count, ppos);
-
+	retval = generic_file_write(file, buf, count, &pos);
 	if (retval > 0)
 		mark_inode_dirty(inode);
+	*ppos = pos;
 	return retval;
 }
 
