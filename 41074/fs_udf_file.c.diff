Index: linux-2.6.5/fs/udf/file.c
===================================================================
--- linux-2.6.5.orig/fs/udf/file.c
+++ linux-2.6.5/fs/udf/file.c
@@ -114,15 +114,33 @@ static ssize_t udf_file_write(struct fil
 {
 	ssize_t retval;
 	struct inode *inode = file->f_dentry->d_inode;
-	int err, pos;
+	int err;
+	loff_t pos;
 
 	if (UDF_I_ALLOCTYPE(inode) == ICBTAG_FLAG_AD_IN_ICB)
 	{
+		/* FIXME: locking checks needed */
 		if (file->f_flags & O_APPEND)
 			pos = inode->i_size;
 		else
 			pos = *ppos;
 
+		/* Some checks from generic_file_write_checks that are
+		 * special cased: UDF_I_LENALLOC(inode) is 32-bits, but
+		 * sb->s_max_bytes = MAX_LFS_FILESIZE.
+		 * Additionally, udf_expand_file_adinicb() takes
+		 * 'int newsize', but it's not used anywhere.*/
+		if (pos < 0)
+			return -EINVAL;
+		if (pos >= MAX_NON_LFS) {
+			send_sig(SIGXFSZ, current, 0);
+			return -EFBIG;
+		}
+
+		if (pos + count > MAX_NON_LFS) {
+			count = MAX_NON_LFS - pos;
+		}
+
 		if (inode->i_sb->s_blocksize < (udf_file_entry_alloc_offset(inode) +
 			pos + count))
 		{
@@ -142,10 +160,10 @@ static ssize_t udf_file_write(struct fil
 		}
 	}
 
-	retval = generic_file_write(file, buf, count, ppos);
-
+	retval = generic_file_write(file, buf, count, &pos);
 	if (retval > 0)
 		mark_inode_dirty(inode);
+	*ppos = pos;
 	return retval;
 }
 
