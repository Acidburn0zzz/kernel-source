Index: linux-2.6.5/security/selinux/selinuxfs.c
===================================================================
--- linux-2.6.5.orig/security/selinux/selinuxfs.c
+++ linux-2.6.5/security/selinux/selinuxfs.c
@@ -71,6 +71,7 @@ static ssize_t sel_read_enforce(struct f
 	char *page;
 	ssize_t length;
 	ssize_t end;
+	loff_t pos = *ppos;
 
 	if (count < 0 || count > PAGE_SIZE)
 		return -EINVAL;
@@ -84,13 +85,13 @@ static ssize_t sel_read_enforce(struct f
 		return length;
 	}
 
-	if (*ppos >= length) {
+	if (pos != (unsigned int)pos || pos >= length) {
 		free_page((unsigned long)page);
 		return 0;
 	}
-	if (count + *ppos > length)
-		count = length - *ppos;
-	end = count + *ppos;
+	if (count + pos > length)
+		count = length - pos;
+	end = count + pos;
 	if (copy_to_user(buf, (char *) page + *ppos, count)) {
 		count = -EFAULT;
 		goto out;
@@ -138,6 +139,7 @@ static ssize_t sel_write_enforce(struct 
 		selnl_notify_setenforce(selinux_enforcing);
 	}
 	length = count;
+	*ppos = length;
 out:
 	free_page((unsigned long) page);
 	return length;
@@ -157,6 +159,7 @@ static ssize_t sel_read_policyvers(struc
 	char *page;
 	ssize_t length;
 	ssize_t end;
+	loff_t pos = *ppos;
 
 	if (count < 0 || count > PAGE_SIZE)
 		return -EINVAL;
@@ -170,14 +173,14 @@ static ssize_t sel_read_policyvers(struc
 		return length;
 	}
 
-	if (*ppos >= length) {
+	if (pos < 0 || pos >= length) {
 		free_page((unsigned long)page);
 		return 0;
 	}
-	if (count + *ppos > length)
-		count = length - *ppos;
-	end = count + *ppos;
-	if (copy_to_user(buf, (char *) page + *ppos, count)) {
+	if (count + pos > length)
+		count = length - pos;
+	end = count + pos;
+	if (copy_to_user(buf, (char *) page + pos, count)) {
 		count = -EFAULT;
 		goto out;
 	}
@@ -200,6 +203,7 @@ static ssize_t sel_read_mls(struct file 
 	char *page;
 	ssize_t length;
 	ssize_t end;
+	loff_t pos = *ppos;
 
 	if (count < 0 || count > PAGE_SIZE)
 		return -EINVAL;
@@ -213,14 +217,14 @@ static ssize_t sel_read_mls(struct file 
 		return length;
 	}
 
-	if (*ppos >= length) {
+	if (pos < 0 || pos >= length) {
 		free_page((unsigned long)page);
 		return 0;
 	}
-	if (count + *ppos > length)
-		count = length - *ppos;
-	end = count + *ppos;
-	if (copy_to_user(buf, (char *) page + *ppos, count)) {
+	if (count + pos > length)
+		count = length - pos;
+	end = count + pos;
+	if (copy_to_user(buf, (char *) page + pos, count)) {
 		count = -EFAULT;
 		goto out;
 	}
@@ -315,6 +319,7 @@ static ssize_t sel_write_context(struct 
 		goto out;
 
 	length = count;
+	*ppos = length;
 out:
 	free_page((unsigned long) page);
 	return length;
@@ -395,10 +400,11 @@ static ssize_t TA_write(struct file *fil
 	return rv;
 }
 
-static ssize_t TA_read(struct file *file, char *buf, size_t size, loff_t *pos)
+static ssize_t TA_read(struct file *file, char *buf, size_t size, loff_t *ppos)
 {
 	struct argresp *ar;
 	ssize_t rv = 0;
+	loff_t pos = *ppos;
 
 	if (file->private_data == NULL)
 		rv = TA_write(file, buf, 0, pos);
@@ -408,13 +414,13 @@ static ssize_t TA_read(struct file *file
 	ar = file->private_data;
 	if (!ar)
 		return 0;
-	if (*pos >= ar->size)
+	if (pos < 0 || pos >= ar->size)
 		return 0;
-	if (*pos + size > ar->size)
-		size = ar->size - *pos;
-	if (copy_to_user(buf, ar->data + *pos, size))
+	if (pos + size > ar->size)
+		size = ar->size - pos;
+	if (copy_to_user(buf, ar->data + pos, size))
 		return -EFAULT;
-	*pos += size;
+	*ppos = pos + size;
 	return size;
 }
 
@@ -703,7 +709,8 @@ static ssize_t sel_read_bool(struct file
 	ssize_t ret;
 	int cur_enforcing;
 	struct inode *inode;
-
+	loff_t pos = *ppos;
+	
 	down(&sel_sem);
 
 	ret = -EFAULT;
@@ -736,14 +743,14 @@ static ssize_t sel_read_bool(struct file
 		goto out;
 	}
 
-	if (*ppos >= length) {
+	if (pos < 0 || pos >= length) {
 		ret = 0;
 		goto out;
 	}
-	if (count + *ppos > length)
-		count = length - *ppos;
-	end = count + *ppos;
-	if (copy_to_user(buf, (char *) page + *ppos, count)) {
+	if (count + pos > length)
+		count = length - pos;
+	end = count + pos;
+	if (copy_to_user(buf, (char *) page + pos, count)) {
 		ret = -EFAULT;
 		goto out;
 	}
