Index: linux-2.6.5/drivers/char/generic_nvram.c
===================================================================
--- linux-2.6.5.orig/drivers/char/generic_nvram.c
+++ linux-2.6.5/drivers/char/generic_nvram.c
@@ -22,12 +22,15 @@
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 #include <asm/nvram.h>
+#include <asm/semaphore.h>
 
 #define NVRAM_SIZE	8192
 
+static DECLARE_MUTEX(nvram_sem);
+
 static loff_t nvram_llseek(struct file *file, loff_t offset, int origin)
 {
-	lock_kernel();
+	down(&nvram_sem);
 	switch (origin) {
 	case 1:
 		offset += file->f_pos;
@@ -37,48 +40,57 @@ static loff_t nvram_llseek(struct file *
 		break;
 	}
 	if (offset < 0) {
-		unlock_kernel();
+		up(&nvram_sem);
 		return -EINVAL;
 	}
 	file->f_pos = offset;
-	unlock_kernel();
+	up(&nvram_sem);
 	return file->f_pos;
 }
 
 static ssize_t read_nvram(struct file *file, char __user *buf,
 			  size_t count, loff_t *ppos)
 {
-	unsigned int i;
+	loff_t i;
 	char __user *p = buf;
-
+	
 	if (verify_area(VERIFY_WRITE, buf, count))
 		return -EFAULT;
-	if (*ppos >= NVRAM_SIZE)
-		return 0;
+		
+	down(&nvram_sem);
+	/* If we are already off the end then we report 0 anyway .. */
 	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count)
 		if (__put_user(nvram_read_byte(i), p))
+		{
+			up(&nvram_sem);
 			return -EFAULT;
+		}
 	*ppos = i;
+	up(&nvram_sem);
 	return p - buf;
 }
 
 static ssize_t write_nvram(struct file *file, const char __user *buf,
 			   size_t count, loff_t *ppos)
 {
-	unsigned int i;
+	loff_t i;
 	const char __user *p = buf;
 	char c;
 
 	if (verify_area(VERIFY_READ, buf, count))
 		return -EFAULT;
-	if (*ppos >= NVRAM_SIZE)
-		return 0;
+		
+	down(&nvram_sem);
+	/* if *ppos > end then we return 0 anyway */
 	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count) {
-		if (__get_user(c, p))
+		if (__get_user(c, p)) {
+			up(&nvram_sem);
 			return -EFAULT;
+		}
 		nvram_write_byte(c, i);
 	}
 	*ppos = i;
+	up(&nvram_sem);
 	return p - buf;
 }
 
