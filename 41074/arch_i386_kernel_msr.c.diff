--- linux-2.6.7/arch/i386/kernel/msr.c	2004-06-16 21:11:35.000000000 +0100
+++ linux-2.6.7-viroized/arch/i386/kernel/msr.c	2004-06-27 18:31:39.020857848 +0100
@@ -41,6 +41,8 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+static DECLARE_MUTEX(msr_lock);
+
 /* Note: "err" is handled in a funny way below.  Otherwise one version
    of gcc or another breaks. */
 
@@ -167,7 +169,7 @@
 {
 	loff_t ret = -EINVAL;
 
-	lock_kernel();
+	down(&msr_lock);
 	switch (orig) {
 	case 0:
 		file->f_pos = offset;
@@ -176,8 +178,11 @@
 	case 1:
 		file->f_pos += offset;
 		ret = file->f_pos;
+		break;
+	default:
+		ret = -EINVAL;
 	}
-	unlock_kernel();
+	up(&msr_lock);
 	return ret;
 }
 
@@ -187,23 +192,36 @@
 	u32 __user *tmp = (u32 __user *) buf;
 	u32 data[2];
 	size_t rv;
-	u32 reg = *ppos;
+	u32 reg;
 	int cpu = iminor(file->f_dentry->d_inode);
-	int err;
+	int err = -EINVAL;
 
 	if (count % 8)
 		return -EINVAL;	/* Invalid chunk size */
 
+	down(&msr_lock);
+	if(*ppos > 0xFFFFFFFF)
+		goto error;
+
+	reg = *ppos;
 	for (rv = 0; count; count -= 8) {
 		err = do_rdmsr(cpu, reg, &data[0], &data[1]);
 		if (err)
-			return err;
+			goto error;
 		if (copy_to_user(tmp, &data, 8))
-			return -EFAULT;
+		{
+			err = -EFAULT;
+			goto error;
+		}
 		tmp += 2;
+		/* XXX API - should seek on */
 	}
-
-	return ((char __user *)tmp) - buf;
+	/* Invariant: err = 0 here */
+error:
+	up(&msr_lock);
+	if(tmp != buf)
+		return ((char __user *)tmp) - buf;
+	return err;
 }
 
 static ssize_t msr_write(struct file *file, const char __user *buf,
@@ -212,23 +230,36 @@
 	const u32 __user *tmp = (const u32 __user *)buf;
 	u32 data[2];
 	size_t rv;
-	u32 reg = *ppos;
+	u32 reg;
 	int cpu = iminor(file->f_dentry->d_inode);
-	int err;
+	int err = -EINVAL;
 
 	if (count % 8)
 		return -EINVAL;	/* Invalid chunk size */
 
+	down(&msr_lock);
+	if(*ppos > 0xFFFFFFFF)
+		goto error;
+	reg = *ppos;
+	
 	for (rv = 0; count; count -= 8) {
 		if (copy_from_user(&data, tmp, 8))
-			return -EFAULT;
+		{
+			err = -EFAULT;
+			goto error;
+		}
 		err = do_wrmsr(cpu, reg, data[0], data[1]);
 		if (err)
-			return err;
+			goto error;
 		tmp += 2;
 	}
-
-	return ((char __user *)tmp) - buf;
+	/* Invariant err = 0 here */
+	
+error:
+	up(&msr_lock);
+	if(tmp != buf)
+		return ((char __user *)tmp) - buf;
+	return err;
 }
 
 static int msr_open(struct inode *inode, struct file *file)
