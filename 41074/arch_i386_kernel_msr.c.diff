Index: linux-2.6.5/arch/i386/kernel/msr.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/msr.c
+++ linux-2.6.5/arch/i386/kernel/msr.c
@@ -41,6 +41,8 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+static DECLARE_MUTEX(msr_lock);
+
 /* Note: "err" is handled in a funny way below.  Otherwise one version
    of gcc or another breaks. */
 
@@ -172,17 +174,21 @@ static inline int do_rdmsr(int cpu, u32 
 static loff_t msr_seek(struct file *file, loff_t offset, int orig)
 {
   loff_t ret = -EINVAL;
-  lock_kernel();
+  down(&msr_lock);
   switch (orig) {
   case 0:
-    file->f_pos = offset;
-    ret = file->f_pos;
     break;
   case 1:
-    file->f_pos += offset;
-    ret = file->f_pos;
+    offset += file->f_pos;
+    break;
+  default:
+    ret = -EINVAL;
   }
-  unlock_kernel();
+  if (offset >= 0) {
+    file->f_pos = offset;
+    ret = offset;
+  }
+  up(&msr_lock);
   return ret;
 }
 
@@ -192,23 +198,37 @@ static ssize_t msr_read(struct file * fi
   u32 *tmp = (u32 *)buf;
   u32 data[2];
   size_t rv;
-  u32 reg = *ppos;
+  u32 reg;
   int cpu = iminor(file->f_dentry->d_inode);
-  int err;
+  int err = -EINVAL;
 
   if ( count % 8 )
     return -EINVAL; /* Invalid chunk size */
   
+  down(&msr_lock);
+  if(*ppos > 0xFFFFFFFF)
+    goto error;
+
+  reg = *ppos;
   for ( rv = 0 ; count ; count -= 8 ) {
     err = do_rdmsr(cpu, reg, &data[0], &data[1]);
     if ( err )
-      return err;
+      goto error;
     if ( copy_to_user(tmp,&data,8) )
-      return -EFAULT;
+    {
+      err = -EFAULT;
+      goto error;
+    }
     tmp += 2;
+    /* XXX API - should seek on */
   }
 
-  return ((char *)tmp) - buf;
+  err = 0;
+error:
+  up(&msr_lock);
+  if (tmp != buf)
+    return ((char *)tmp) - buf;
+  return err;
 }
 
 static ssize_t msr_write(struct file * file, const char __user * buf,
@@ -217,23 +237,37 @@ static ssize_t msr_write(struct file * f
   const u32 *tmp = (const u32 *)buf;
   u32 data[2];
   size_t rv;
-  u32 reg = *ppos;
+  u32 reg;
   int cpu = iminor(file->f_dentry->d_inode);
-  int err;
+  int err = -EINVAL;
 
   if ( count % 8 )
     return -EINVAL; /* Invalid chunk size */
   
+  down(&msr_lock);
+  if(*ppos > 0xFFFFFFFF)
+    goto error;
+  reg = *ppos;
+
   for ( rv = 0 ; count ; count -= 8 ) {
     if ( copy_from_user(&data,tmp,8) )
-      return -EFAULT;
+    {
+      err = -EFAULT;
+      goto error;
+    }
     err = do_wrmsr(cpu, reg, data[0], data[1]);
     if ( err )
-      return err;
+      goto error;
     tmp += 2;
   }
 
-  return ((char *)tmp) - buf;
+  err = 0;
+
+error:
+  up(&msr_lock);
+  if(tmp != buf)
+    return ((char *)tmp) - buf;
+  return err;
 }
 
 static int msr_open(struct inode *inode, struct file *file)
