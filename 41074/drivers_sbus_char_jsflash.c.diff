--- linux-2.6.7/drivers/sbus/char/jsflash.c	2004-06-16 21:09:58.000000000 +0100
+++ linux-2.6.7-viroized/drivers/sbus/char/jsflash.c	2004-06-27 23:16:40.109097272 +0100
@@ -46,6 +46,7 @@
 #include <asm/io.h>
 #include <asm/pcic.h>
 #include <asm/oplib.h>
+#include <asm/semaphore.h>
 
 #include <asm/jsflash.h>		/* ioctl arguments. <linux/> ?? */
 #define JSFIDSZ		(sizeof(struct jsflash_ident_arg))
@@ -72,6 +73,7 @@
 #define JSF_PART_BITS	 2	/* 2 bits of minors to cover JSF_NPART */
 #define JSF_PART_MASK	 0x3	/* 2 bits mask */
 
+static DECLARE_MUTEX(jsflash_mutex);
 /*
  * Access functions.
  * We could ioremap(), but it's easier this way.
@@ -229,7 +231,7 @@
 {
 	loff_t ret;
 
-	lock_kernel();
+	down(&jsflash_mutex);
 	switch (orig) {
 		case 0:
 			file->f_pos = offset;
@@ -242,7 +244,7 @@
 		default:
 			ret = -EINVAL;
 	}
-	unlock_kernel();
+	up(&jsflash_mutex);
 	return ret;
 }
 
@@ -252,7 +254,7 @@
 static ssize_t jsf_read(struct file * file, char * buf, 
     size_t togo, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	unsigned long p;
 	char *tmp = buf;
 
 	union byte4 {
@@ -260,9 +262,14 @@
 		unsigned int n;
 	} b;
 
-	if (p < JSF_BASE_ALL || p >= JSF_BASE_TOP) {
+	down(&jsflash_mutex);
+	
+	/* Range check in loff_t, then cut down for use */
+	if (*ppos < JSF_BASE_ALL || *ppos >= JSF_BASE_TOP) {
+		up(&jsflash_mutex);
 		return 0;
 	}
+	p = *ppos;
 
 	if ((p + togo) < p	/* wrap */
 	   || (p + togo) >= JSF_BASE_TOP) {
@@ -283,6 +290,7 @@
 		 * without regard to modversions,
 		 * so we cannot build a module.
 		 */
+		up(&jsflash_mutex);
 		return 0;
 #endif
 	}
@@ -291,7 +299,10 @@
 		togo -= 4;
 		b.n = jsf_inl(p);
 		if (copy_to_user(tmp, b.s, 4))
+		{
+			up(&jsflash_mutex);
 			return -EFAULT;
+		}
 		tmp += 4;
 		p += 4;
 	}
@@ -302,6 +313,7 @@
 	 */
 
 	*ppos = p;
+	up(&jsflash_mutex);
 	return tmp-buf;
 }
 
