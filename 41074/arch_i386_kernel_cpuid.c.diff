Index: linux-2.6.5/arch/i386/kernel/cpuid.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/cpuid.c
+++ linux-2.6.5/arch/i386/kernel/cpuid.c
@@ -42,6 +42,9 @@
 #include <asm/msr.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
+#include <asm/semaphore.h>
+
+static DECLARE_MUTEX(cpuid_lock);
 
 #ifdef CONFIG_SMP
 
@@ -86,24 +89,25 @@ static inline void do_cpuid(int cpu, u32
 
 static loff_t cpuid_seek(struct file *file, loff_t offset, int orig)
 {
-  loff_t ret;
-
-  lock_kernel();
+  loff_t ret = -EINVAL;
 
+  down(&cpuid_lock);
+	
   switch (orig) {
   case 0:
-    file->f_pos = offset;
-    ret = file->f_pos;
     break;
   case 1:
-    file->f_pos += offset;
-    ret = file->f_pos;
+    offset += file->f_pos;
     break;
   default:
-    ret = -EINVAL;
+    goto error;
   }
-
-  unlock_kernel();
+  if (offset >= 0) {
+    file->f_pos = offset;
+    ret = offset;
+  }
+error:
+  up(&cpuid_lock);
   return ret;
 }
 
@@ -113,21 +117,33 @@ static ssize_t cpuid_read(struct file * 
   u32 *tmp = (u32 *)buf;
   u32 data[4];
   size_t rv;
-  u32 reg = *ppos;
+  u32 reg;
   int cpu = iminor(file->f_dentry->d_inode);
+  int err = -EINVAL;
   
   if ( count % 16 )
     return -EINVAL; /* Invalid chunk size */
   
+  down(&cpuid_lock);
+  if(*ppos > 0xFFFFFFFF)
+    goto error;
+  reg = *ppos;
+  err = -EFAULT;
   for ( rv = 0 ; count ; count -= 16 ) {
     do_cpuid(cpu, reg, data);
     if ( copy_to_user(tmp,&data,16) )
-      return -EFAULT;
+      goto error;
     tmp += 4;
     *ppos = reg++;
   }
   
-  return ((char *)tmp) - buf;
+  err = 0;
+
+error:
+  up(&cpuid_lock);
+  if((char *)tmp != buf)
+    return ((char *)tmp) - buf;
+  return err;
 }
 
 static int cpuid_open(struct inode *inode, struct file *file)
