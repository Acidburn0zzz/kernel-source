Subject: [patch] uml make vsyscall page into process page tables.patch
From: Bodo Stroesser
Patch-mainline: 2.6.11-rc1

To make the vsyscall-page available for copy_from_user() and
ptrace(), we should use kernel's "gate-vma" mechanism.
Therefore we need a valid page structure. To have this, one
page (or more) is allocated at boot time, the contents of the
vsyscall-page is copied into this page and the page's pte is
inserted in swapper's pagetables.
Now it will be copied into the pagetables of all processes.

Note: this alone doesn't work, since FIXADDR_USER_START and
      FIXADDR_USER_END are not yet defined correctly. Also
      access_ok_skas() does not yet grant read accesses to
      pages not in the normal user area.

Risks:
Please check the first hunk! I don't know, whether this change is OK.
Maybe fixrange_init() is wrong anyway with 3-level-pagetables?

Here access_ok_skas() and FIXADDR_USER_XXXX are fixed.
Now everything should work fine, while the processes are
running. But if a process crashes, the vsyscall-page will
not be dumped.

Signed-off-by: Bodo Stroesser <bodo.stroesser@fujitsu-siemens.com>
Signed-off-by: Jeff Dike <jdike@addtoit.com>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Acked-by: Gerd Knorr <kraxel@suse.de>
---
 arch/um/kernel/mem.c                       |   25 +++++++++++++++++++++
 arch/um/kernel/skas/include/uaccess-skas.h |    7 +++++
 include/asm-um/fixmap.h                    |    6 ++---
 include/asm-um/pgtable.h                   |    2 +
 4 files changed, 36 insertions(+), 4 deletions(-)

diff -puN arch/um/kernel/mem.c~uml-make-vsyscall-page-into-process-page-tables arch/um/kernel/mem.c
--- 25/arch/um/kernel/mem.c~uml-make-vsyscall-page-into-process-page-tables	Fri Dec  3 13:50:28 2004
+++ 25-akpm/arch/um/kernel/mem.c	Fri Dec  3 13:50:28 2004
@@ -174,6 +174,29 @@ static void init_highmem(void)
 }
 #endif /* CONFIG_HIGHMEM */
 
+static void __init fixaddr_user_init( void)
+{
+	long size = FIXADDR_USER_END - FIXADDR_USER_START;
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *pte;
+	unsigned long paddr, vaddr = FIXADDR_USER_START;
+
+	if (  ! size )
+		return;
+
+	fixrange_init( FIXADDR_USER_START, FIXADDR_USER_END, swapper_pg_dir);
+	paddr = (unsigned long)alloc_bootmem_low_pages( size);
+	memcpy( (void *)paddr, (void *)FIXADDR_USER_START, size);
+	paddr = __pa(paddr);
+	for ( ; size > 0; size-=PAGE_SIZE, vaddr+=PAGE_SIZE, paddr+=PAGE_SIZE) {
+		pgd = swapper_pg_dir + pgd_index(vaddr);
+		pmd = pmd_offset(pgd, vaddr);
+		pte = pte_offset_kernel(pmd, vaddr);
+		pte_set_val( (*pte), paddr, PAGE_READONLY);
+	}
+}
+
 void paging_init(void)
 {
 	unsigned long zones_size[MAX_NR_ZONES], vaddr;
@@ -194,6 +217,8 @@ void paging_init(void)
 	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;
 	fixrange_init(vaddr, FIXADDR_TOP, swapper_pg_dir);
 
+	fixaddr_user_init();
+
 #ifdef CONFIG_HIGHMEM
 	init_highmem();
 #endif
diff -puN arch/um/kernel/skas/include/uaccess-skas.h~uml-make-vsyscall-page-into-process-page-tables arch/um/kernel/skas/include/uaccess-skas.h
--- 25/arch/um/kernel/skas/include/uaccess-skas.h~uml-make-vsyscall-page-into-process-page-tables	Fri Dec  3 13:50:28 2004
+++ 25-akpm/arch/um/kernel/skas/include/uaccess-skas.h	Fri Dec  3 13:50:28 2004
@@ -7,11 +7,16 @@
 #define __SKAS_UACCESS_H
 
 #include "asm/errno.h"
+#include "asm/fixmap.h"
 
 #define access_ok_skas(type, addr, size) \
 	((segment_eq(get_fs(), KERNEL_DS)) || \
 	 (((unsigned long) (addr) < TASK_SIZE) && \
-	  ((unsigned long) (addr) + (size) <= TASK_SIZE)))
+	  ((unsigned long) (addr) + (size) <= TASK_SIZE)) || \
+	 ((type == VERIFY_READ ) && \
+	  (size <= (FIXADDR_USER_END - FIXADDR_USER_START)) && \
+	  ((unsigned long) (addr) >= FIXADDR_USER_START) && \
+	  ((unsigned long) (addr) + (size) <= FIXADDR_USER_END)))
 
 static inline int verify_area_skas(int type, const void * addr,
 				   unsigned long size)
diff -puN include/asm-um/fixmap.h~uml-make-vsyscall-page-into-process-page-tables include/asm-um/fixmap.h
--- 25/include/asm-um/fixmap.h~uml-make-vsyscall-page-into-process-page-tables	Fri Dec  3 13:50:28 2004
+++ 25-akpm/include/asm-um/fixmap.h	Fri Dec  3 13:50:28 2004
@@ -3,6 +3,7 @@
 
 #include <linux/config.h>
 #include <asm/kmap_types.h>
+#include <asm/archparam.h>
 
 /*
  * Here we define all the compile-time 'special' virtual
@@ -34,7 +35,6 @@ enum fixed_addresses {
 	FIX_KMAP_BEGIN,	/* reserved pte's for temporary kernel mappings */
 	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
 #endif
-	FIX_VSYSCALL,
 	__end_of_fixed_addresses
 };
 
@@ -68,8 +68,8 @@ extern unsigned long get_kmem_end(void);
  * This is the range that is readable by user mode, and things
  * acting like user mode such as get_user_pages.
  */
-#define FIXADDR_USER_START	(__fix_to_virt(FIX_VSYSCALL))
-#define FIXADDR_USER_END	(FIXADDR_USER_START + PAGE_SIZE)
+#define FIXADDR_USER_START	VSYSCALL_BASE
+#define FIXADDR_USER_END	VSYSCALL_END
 
 extern void __this_fixmap_does_not_exist(void);
 
diff -puN include/asm-um/pgtable.h~uml-make-vsyscall-page-into-process-page-tables include/asm-um/pgtable.h
--- 25/include/asm-um/pgtable.h~uml-make-vsyscall-page-into-process-page-tables	Fri Dec  3 13:50:28 2004
+++ 25-akpm/include/asm-um/pgtable.h	Fri Dec  3 13:50:28 2004
@@ -355,6 +355,8 @@ extern unsigned long page_to_phys(struct
 
 extern pte_t mk_pte(struct page *page, pgprot_t pgprot);
 
+#define pte_set_val(p, phys, prot) pte_val(p) = (phys | pgprot_val(prot))
+
 static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 {
 	pte_val(pte) = (pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot);
_
