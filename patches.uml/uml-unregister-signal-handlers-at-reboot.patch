Subject: [patch] uml unregister signal handlers at reboot.patch
From: Bodo Stroesser <bstroesser@fujitsu-siemens.com>
Patch-mainline: 2.6.11-rc1

In most cases reboot failed on my system.  After "Restarting system.", UML
exited without further messages.  I found an SIGIO being processed by
sig_handler() resp.  sig_handler_common_skas().  Don't know, why this exits,
maybe the context is no longer valid at this time.  So, I changed the sequence
in the reboot part of main() to stop the timers and disable the fds before
unblocking the signals.  Since this wasn't enough, I also added
set_handler(SIGXXX, SIG_IGN) calls to disable_timer() and
deactivate_all_fds().  Now reboot works fine in SKAS and it still works in TT.

Signed-off-by: Bodo Stroesser <bstroesser@fujitsu-siemens.com>
Signed-off-by: Jeff Dike <jdike@addtoit.com>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Acked-by: Gerd Knorr <kraxel@suse.de>
---
 arch/um/kernel/irq_user.c |    2 ++
 arch/um/kernel/main.c     |   14 ++++++++------
 arch/um/kernel/time.c     |    3 +++
 3 files changed, 13 insertions(+), 6 deletions(-)

diff -puN arch/um/kernel/irq_user.c~uml-unregister-signal-handlers-at-reboot arch/um/kernel/irq_user.c
--- 25/arch/um/kernel/irq_user.c~uml-unregister-signal-handlers-at-reboot	2004-11-28 01:17:29.616586000 -0800
+++ 25-akpm/arch/um/kernel/irq_user.c	2004-11-28 01:17:29.622585088 -0800
@@ -377,6 +377,8 @@ int deactivate_all_fds(void)
 		if(err)
 			return(err);
 	}
+	/* If there is a signal already queued, after unblocking ignore it */
+	set_handler(SIGIO, SIG_IGN, 0, -1);
 
 	return(0);
 }
diff -puN arch/um/kernel/main.c~uml-unregister-signal-handlers-at-reboot arch/um/kernel/main.c
--- 25/arch/um/kernel/main.c~uml-unregister-signal-handlers-at-reboot	2004-11-28 01:17:29.617585848 -0800
+++ 25-akpm/arch/um/kernel/main.c	2004-11-28 01:17:29.623584936 -0800
@@ -155,18 +155,20 @@ int main(int argc, char **argv, char **e
 		int err;
 
 		printf("\n");
-
-		/* Let any pending signals fire, then disable them.  This
-		 * ensures that they won't be delivered after the exec, when
-		 * they are definitely not expected.
-		 */
-		unblock_signals();
+		/* stop timers and set SIG*ALRM to be ignored */
 		disable_timer();
+		/* disable SIGIO for the fds and set SIGIO to be ignored */
 		err = deactivate_all_fds();
 		if(err)
 			printf("deactivate_all_fds failed, errno = %d\n",
 			       -err);
 
+		/* Let any pending signals fire now.  This ensures
+		 * that they won't be delivered after the exec, when
+		 * they are definitely not expected.
+		 */
+		unblock_signals();
+
 		execvp(new_argv[0], new_argv);
 		perror("Failed to exec kernel");
 		ret = 1;
diff -puN arch/um/kernel/time.c~uml-unregister-signal-handlers-at-reboot arch/um/kernel/time.c
--- 25/arch/um/kernel/time.c~uml-unregister-signal-handlers-at-reboot	2004-11-28 01:17:29.619585544 -0800
+++ 25-akpm/arch/um/kernel/time.c	2004-11-28 01:17:29.624584784 -0800
@@ -60,6 +60,9 @@ void disable_timer(void)
 	   (setitimer(ITIMER_REAL, &disable, NULL) < 0))
 		printk("disnable_timer - setitimer failed, errno = %d\n",
 		       errno);
+	/* If there are signals already queued, after unblocking ignore them */
+	set_handler(SIGALRM, SIG_IGN, 0, -1);
+	set_handler(SIGVTALRM, SIG_IGN, 0, -1);
 }
 
 void switch_timers(int to_real)
_
