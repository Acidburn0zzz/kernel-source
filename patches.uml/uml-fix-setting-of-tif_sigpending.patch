Subject: [patch] uml fix setting of tif_sigpending.patch
From: Bodo Stroesser <bstroesser@fujitsu-siemens.com>
Patch-mainline: 2.6.11-rc1

My older patch, that sets TIF_SIGPENDING after an ptrace-interception
in syscall_trace() is wrong.
Some syscalls want to be called without any signal pending. If a signal
is pending on syscall-entry, they immediately return with -ERESTARTNOINTR.
Thus, on return to user, the pending signals can be processed and the
kernel will lower eip by 2 to have the syscall restarted after that.
Since my change sets TIF_SIGPENDING on the entry and exit interception,
stracing such a syscall looped! Try "strace ls" to see what happens.
Fix: set TIF_SIGPENDING on the exit interception only. This avoids the
loop and is enough for security.

Signed-off-by: Bodo Stroesser <bstroesser@fujitsu-siemens.com>
Signed-off-by: Jeff Dike <jdike@addtoit.com>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Acked-by: Gerd Knorr <kraxel@suse.de>
---
 arch/um/kernel/ptrace.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff -puN arch/um/kernel/ptrace.c~uml-fix-setting-of-tif_sigpending arch/um/kernel/ptrace.c
--- 25/arch/um/kernel/ptrace.c~uml-fix-setting-of-tif_sigpending	Fri Dec  3 13:50:37 2004
+++ 25-akpm/arch/um/kernel/ptrace.c	Fri Dec  3 13:50:37 2004
@@ -330,8 +330,8 @@ void syscall_trace(union uml_pt_regs *re
 	tracesysgood = (current->ptrace & PT_TRACESYSGOOD) && !is_singlestep;
 	ptrace_notify(SIGTRAP | (tracesysgood ? 0x80 : 0));
 
-	/* force do_signal() --> is_syscall() */
-	set_thread_flag(TIF_SIGPENDING);
+	if (entryexit) /* force do_signal() --> is_syscall() */
+		set_thread_flag(TIF_SIGPENDING);
 
 	/* this isn't the same as continuing with a signal, but it will do
 	 * for normal use.  strace only continues with a signal if the
_
