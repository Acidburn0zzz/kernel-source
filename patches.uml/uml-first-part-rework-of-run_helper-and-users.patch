Subject: [patch] uml first part rework of run_helper and users.patch
From: Paolo 'Blaisorblade' Giarrusso <blaisorblade_spam@yahoo.it>
Patch-mainline: 2.6.11-rc1

Fixed a file descriptor leak in the network driver when changing an IP
address.

Fixed the error handling in run_helper.

Paolo notes:

Actually, this is part one of the change, the exact one extracted from Jeff
Dike's incrementals tree before 2.6.9-rc big UML merge.

There is some changes must be done, so I'm also sending a second patch with
this one, too.  Separated for tracking purposes.

Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade_spam@yahoo.it>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Acked-by: Gerd Knorr <kraxel@suse.de>
---
 arch/um/drivers/net_user.c |    3 ++-
 arch/um/kernel/helper.c    |   14 +++++---------
 2 files changed, 7 insertions(+), 10 deletions(-)

diff -puN arch/um/drivers/net_user.c~uml-first-part-rework-of-run_helper-and-users arch/um/drivers/net_user.c
--- 25/arch/um/drivers/net_user.c~uml-first-part-rework-of-run_helper-and-users	Tue Nov 30 15:20:32 2004
+++ 25-akpm/arch/um/drivers/net_user.c	Tue Nov 30 15:20:32 2004
@@ -173,8 +173,9 @@ static int change_tramp(char **argv, cha
 	pe_data.stdout = fds[1];
 	pid = run_helper(change_pre_exec, &pe_data, argv, NULL);
 
-	os_close_file(fds[1]);
 	read_output(fds[0], output, output_len);
+	os_close_file(fds[0]);
+	os_close_file(fds[1]);
 
 	CATCH_EINTR(err = waitpid(pid, NULL, 0));
 	return(pid);
diff -puN arch/um/kernel/helper.c~uml-first-part-rework-of-run_helper-and-users arch/um/kernel/helper.c
--- 25/arch/um/kernel/helper.c~uml-first-part-rework-of-run_helper-and-users	Tue Nov 30 15:20:32 2004
+++ 25-akpm/arch/um/kernel/helper.c	Tue Nov 30 15:20:32 2004
@@ -94,24 +94,20 @@ int run_helper(void (*pre_exec)(void *),
 	if(n < 0){
 		printk("run_helper : read on pipe failed, err = %d\n", -n);
 		err = n;
-		goto out_kill;
+		os_kill_process(pid, 1);
 	}
 	else if(n != 0){
 		CATCH_EINTR(n = waitpid(pid, NULL, 0));
 		pid = -errno;
 	}
+	err = pid;
 
-	if(stack_out == NULL) free_stack(stack, 0);
-        else *stack_out = stack;
-	return(pid);
-
- out_kill:
-	os_kill_process(pid, 1);
  out_close:
 	os_close_file(fds[0]);
-	os_close_file(fds[1]);
  out_free:
-	free_stack(stack, 0);
+	if(stack_out == NULL)
+		free_stack(stack, 0);
+        else *stack_out = stack;
 	return(err);
 }
 
_
