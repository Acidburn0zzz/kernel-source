Message-Id: <200409141847.i8EIlZ4W003422@ccure.user-mode-linux.org>
X-Mailer: exmh version 2.4 06/23/2000 with nmh-1.1-RC1
To: akpm@osdl.org
cc: linux-kernel@vger.kernel.org
Subject: [PATCH] UML - Cleaning up
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Date: 	Tue, 14 Sep 2004 14:47:35 -0400
From: Jeff Dike <jdike@addtoit.com>
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: 	linux-kernel@vger.kernel.org
X-Scanned-By: MIMEDefang 2.43
Lines: 358
Xref: bytesex.org mlist.linux-kernel:22591

This patch is a whole lot of "obviously won't break anything" changes, 
including
	renaming the UML console functions more consistently
	notes to myself
	code movement
	making some functions static
	error path cleanup
	printk fixes

Signed-off-by: Jeff Dike <jdike@addtoit.com>
	
Index: uml-2.6.9-rc2/arch/um/drivers/stdio_console.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/drivers/stdio_console.c	2004-09-16 16:10:14.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/drivers/stdio_console.c	2004-09-16 16:58:34.072895933 +0200
@@ -191,7 +191,7 @@ int stdio_init(void)
 
 late_initcall(stdio_init);
 
-static void console_write(struct console *console, const char *string, 
+static void uml_console_write(struct console *console, const char *string, 
 			  unsigned len)
 {
 	struct line *line = &vts[console->index];
@@ -203,22 +203,22 @@ static void console_write(struct console
 		up(&line->sem);
 }
 
-static struct tty_driver *um_console_device(struct console *c, int *index)
+static struct tty_driver *uml_console_device(struct console *c, int *index)
 {
 	*index = c->index;
 	return console_driver;
 }
 
-static int console_setup(struct console *co, char *options)
+static int uml_console_setup(struct console *co, char *options)
 {
 	return(0);
 }
 
 static struct console stdiocons = {
 	name:		"tty",
-	write:		console_write,
-	device:		um_console_device,
-	setup:		console_setup,
+	write:		uml_console_write,
+	device:		uml_console_device,
+	setup:		uml_console_setup,
 	flags:		CON_PRINTBUFFER,
 	index:		-1,
 };
Index: uml-2.6.9-rc2/arch/um/drivers/xterm.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/drivers/xterm.c	2004-09-16 16:10:14.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/drivers/xterm.c	2004-09-16 16:58:26.641111732 +0200
@@ -83,6 +83,7 @@ __uml_setup("xterm=", xterm_setup,
 "    are 'xterm=gnome-terminal,-t,-x'.\n\n"
 );
 
+/* XXX This badly needs some cleaning up in the error paths */
 int xterm_open(int input, int output, int primary, void *d, char **dev_out)
 {
 	struct xterm_chan *data = d;
Index: uml-2.6.9-rc2/arch/um/kernel/process.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/kernel/process.c	2004-09-16 16:13:41.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/kernel/process.c	2004-09-16 16:58:49.077447749 +0200
@@ -139,16 +139,6 @@ int start_fork_tramp(void *thread_arg, u
 	return(arg.pid);
 }
 
-void suspend_new_thread(int fd)
-{
-	char c;
-
-	os_stop_process(os_getpid());
-
-	if(os_read_file(fd, &c, sizeof(c)) != sizeof(c))
-		panic("read failed in suspend_new_thread");
-}
-
 static int ptrace_child(void *arg)
 {
 	int pid = os_getpid();
Index: uml-2.6.9-rc2/arch/um/kernel/sigio_kern.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/kernel/sigio_kern.c	2004-09-16 16:10:14.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/kernel/sigio_kern.c	2004-09-16 16:13:41.000000000 +0200
@@ -16,7 +16,7 @@
 /* Protected by sigio_lock() called from write_sigio_workaround */
 static int sigio_irq_fd = -1;
 
-irqreturn_t sigio_interrupt(int irq, void *data, struct pt_regs *unused)
+static irqreturn_t sigio_interrupt(int irq, void *data, struct pt_regs *unused)
 {
 	read_sigio_fd(sigio_irq_fd);
 	reactivate_fd(sigio_irq_fd, SIGIO_WRITE_IRQ);
@@ -25,10 +25,14 @@ irqreturn_t sigio_interrupt(int irq, voi
 
 int write_sigio_irq(int fd)
 {
-	if(um_request_irq(SIGIO_WRITE_IRQ, fd, IRQ_READ, sigio_interrupt,
+	int err;
+
+	err = um_request_irq(SIGIO_WRITE_IRQ, fd, IRQ_READ, sigio_interrupt,
 			  SA_INTERRUPT | SA_SAMPLE_RANDOM, "write sigio", 
-			  NULL)){
-		printk("write_sigio_irq : um_request_irq failed\n");
+			     NULL);
+	if(err){
+		printk("write_sigio_irq : um_request_irq failed, err = %d\n",
+		       err);
 		return(-1);
 	}
 	sigio_irq_fd = fd;
Index: uml-2.6.9-rc2/arch/um/kernel/skas/process.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/kernel/skas/process.c	2004-09-16 16:13:41.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/kernel/skas/process.c	2004-09-16 16:58:30.538473495 +0200
@@ -375,28 +375,6 @@ void reboot_skas(void)
 	siglongjmp(initial_jmpbuf, 4);
 }
 
-int new_mm(int from)
-{
-	struct proc_mm_op copy;
-	int n, fd = os_open_file("/proc/mm",
-				 of_cloexec(of_write(OPENFLAGS())), 0);
-
-	if(fd < 0)
-		return(fd);
-
-	if(from != -1){
-		copy = ((struct proc_mm_op) { .op 	= MM_COPY_SEGMENTS,
-					      .u 	= 
-					      { .copy_segments	= from } } );
-		n = os_write_file(fd, &copy, sizeof(copy));
-		if(n != sizeof(copy)) 
-			printk("new_mm : /proc/mm copy_segments failed, "
-			       "err = %d\n", -n);
-	}
-
-	return(fd);
-}
-
 void switch_mm_skas(int mm_fd)
 {
 	int err;
Index: uml-2.6.9-rc2/arch/um/kernel/skas/process_kern.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/kernel/skas/process_kern.c	2004-09-16 16:13:40.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/kernel/skas/process_kern.c	2004-09-16 16:13:41.000000000 +0200
@@ -22,6 +22,7 @@
 #include "frame.h"
 #include "kern.h"
 #include "mode.h"
+#include "proc_mm.h"
 
 static atomic_t using_sysemu;
 int sysemu_supported;
@@ -196,6 +197,28 @@ int copy_thread_skas(int nr, unsigned lo
 	return(0);
 }
 
+int new_mm(int from)
+{
+	struct proc_mm_op copy;
+	int n, fd;
+
+	fd = os_open_file("/proc/mm", of_cloexec(of_write(OPENFLAGS())), 0);
+	if(fd < 0)
+		return(fd);
+
+	if(from != -1){
+		copy = ((struct proc_mm_op) { .op 	= MM_COPY_SEGMENTS,
+					      .u 	= 
+					      { .copy_segments	= from } } );
+		n = os_write_file(fd, &copy, sizeof(copy));
+		if(n != sizeof(copy)) 
+			printk("new_mm : /proc/mm copy_segments failed, "
+			       "err = %d\n", -n);
+	}
+
+	return(fd);
+}
+
 void init_idle_skas(void)
 {
 	cpu_tasks[current_thread->cpu].pid = os_getpid();
Index: uml-2.6.9-rc2/arch/um/kernel/tt/process_kern.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/kernel/tt/process_kern.c	2004-09-16 16:13:40.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/kernel/tt/process_kern.c	2004-09-16 16:58:48.058613977 +0200
@@ -128,6 +128,17 @@ void exit_thread_tt(void)
 	os_close_file(current->thread.mode.tt.switch_pipe[1]);
 }
 
+void suspend_new_thread(int fd)
+{
+	int err;
+	char c;
+
+	os_stop_process(os_getpid());
+	err = os_read_file(fd, &c, sizeof(c));
+	if(err != sizeof(c))
+		panic("read failed in suspend_new_thread, err = %d", -err);
+}
+
 void schedule_tail(task_t *prev);
 
 static void new_thread_handler(int sig)
@@ -162,6 +173,12 @@ static void new_thread_handler(int sig)
 	local_irq_enable();
 	if(!run_kernel_thread(fn, arg, &current->thread.exec_buf))
 		do_exit(0);
+	
+	/* XXX No set_user_mode here because a newly execed process will
+	 * immediately segfault on its non-existent IP, coming straight back
+	 * to the signal handler, which will call set_user_mode on its way
+	 * out.  This should probably change since it's confusing.
+	 */
 }
 
 static int new_thread_proc(void *stack)
Index: uml-2.6.9-rc2/arch/um/kernel/tt/tracer.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/kernel/tt/tracer.c	2004-09-16 16:10:14.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/kernel/tt/tracer.c	2004-09-16 16:13:41.000000000 +0200
@@ -330,7 +330,8 @@ int tracer(int (*init_proc)(void *), voi
 					continue;
 				}
 				tracing = 0;
-				if(do_syscall(task, pid)) sig = SIGUSR2;
+				if(do_syscall(task, pid))
+					sig = SIGUSR2;
 				else clear_singlestep(task);
 				break;
 			case SIGPROF:
Index: uml-2.6.9-rc2/arch/um/kernel/umid.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/kernel/umid.c	2004-09-16 16:10:14.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/kernel/umid.c	2004-09-16 16:58:32.311183394 +0200
@@ -43,7 +43,7 @@ static int __init set_umid(char *name, i
 	}
 
 	if(strlen(name) > UMID_LEN - 1)
-		(*printer)("Unique machine name is being truncated to %s "
+		(*printer)("Unique machine name is being truncated to %d "
 			   "characters\n", UMID_LEN);
 	strlcpy(umid, name, sizeof(umid));
 
@@ -199,17 +199,20 @@ int not_dead_yet(char *dir)
 static int __init set_uml_dir(char *name, int *add)
 {
 	if((strlen(name) > 0) && (name[strlen(name) - 1] != '/')){
-		uml_dir = malloc(strlen(name) + 1);
+		uml_dir = malloc(strlen(name) + 2);
 		if(uml_dir == NULL){
 			printf("Failed to malloc uml_dir - error = %d\n",
 			       errno);
 			uml_dir = name;
+			/* Return 0 here because do_initcalls doesn't look at
+			 * the return value.
+			 */
 			return(0);
 		}
 		sprintf(uml_dir, "%s/", name);
 	}
 	else uml_dir = name;
-	return 0;
+	return(0);
 }
 
 static int __init make_uml_dir(void)
Index: uml-2.6.9-rc2/arch/um/kernel/user_util.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/kernel/user_util.c	2004-09-16 16:10:14.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/kernel/user_util.c	2004-09-16 16:58:45.287066176 +0200
@@ -88,11 +88,11 @@ int wait_for_stop(int pid, int sig, int 
 				       errno);
 			}
 			else if(WIFEXITED(status)) 
-				printk("process exited with status %d\n", 
-				       WEXITSTATUS(status));
+				printk("process %d exited with status %d\n", 
+				       pid, WEXITSTATUS(status));
 			else if(WIFSIGNALED(status))
-				printk("process exited with signal %d\n", 
-				       WTERMSIG(status));
+				printk("process %d exited with signal %d\n", 
+				       pid, WTERMSIG(status));
 			else if((WSTOPSIG(status) == SIGVTALRM) ||
 				(WSTOPSIG(status) == SIGALRM) ||
 				(WSTOPSIG(status) == SIGIO) ||
@@ -108,8 +108,8 @@ int wait_for_stop(int pid, int sig, int 
 				ptrace(cont_type, pid, 0, WSTOPSIG(status));
 				continue;
 			}
-			else printk("process stopped with signal %d\n", 
-				    WSTOPSIG(status));
+			else printk("process %d stopped with signal %d\n", 
+				    pid, WSTOPSIG(status));
 			panic("wait_for_stop failed to wait for %d to stop "
 			      "with %d\n", pid, sig);
 		}
Index: uml-2.6.9-rc2/arch/um/os-Linux/file.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/os-Linux/file.c	2004-09-16 16:13:40.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/os-Linux/file.c	2004-09-16 16:13:41.000000000 +0200
@@ -187,7 +187,8 @@ int os_sigio_async(int master, int slave
 
 	if((fcntl(master, F_SETFL, flags | O_NONBLOCK | O_ASYNC) < 0) ||
 	   (fcntl(master, F_SETOWN, os_getpid()) < 0)){
-		printk("fcntl F_SETFL or F_SETOWN failed, errno = %d\n", errno);
+		printk("fcntl F_SETFL or F_SETOWN failed, errno = %d\n", 
+		       errno);
 		return(-errno);
 	}
 
Index: uml-2.6.9-rc2/arch/um/os-Linux/process.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/os-Linux/process.c	2004-09-16 16:10:14.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/os-Linux/process.c	2004-09-16 16:58:48.065612835 +0200
@@ -42,9 +42,9 @@ unsigned long os_process_pc(int pid)
 	}
 	os_close_file(fd);
 	pc = ARBITRARY_ADDR;
-	if(sscanf(buf, "%*d " COMM_SCANF " %*c %*d %*d %*d %*d %*d %*d %*d %*d "
+	if(sscanf(buf, "%*d " COMM_SCANF " %*c %*d %*d %*d %*d %*d %*d %*d "
 		  "%*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d "
-		  "%*d %*d %*d %*d %lu", &pc) != 1){
+		  "%*d %*d %*d %*d %*d %lu", &pc) != 1){
 		printk("os_process_pc - couldn't find pc in '%s'\n", buf);
 	}
 	return(pc);
Index: uml-2.6.9-rc2/arch/um/sys-i386/ptrace_user.c
===================================================================
--- uml-2.6.9-rc2.orig/arch/um/sys-i386/ptrace_user.c	2004-09-16 16:10:14.000000000 +0200
+++ uml-2.6.9-rc2/arch/um/sys-i386/ptrace_user.c	2004-09-16 16:13:41.000000000 +0200
@@ -42,7 +42,8 @@ static void write_debugregs(int pid, uns
 		if(ptrace(PTRACE_POKEUSER, pid, &dummy->u_debugreg[i],
 			  regs[i]) < 0)
 			printk("write_debugregs - ptrace failed on "
-			       "register %d, errno = %d\n", errno);
+			       "register %d, value = 0x%x, errno = %d\n", i, 
+			       regs[i], errno);
 	}
 }
 
