Hopefully correct version this time. In previous version it was possible
to call ->show() on non-initialized gate_vmarea (through m_next()). Just
call build_gate_map() at the beginning of the m_start().

At least now it works:

$ cat /proc/self/maps | tail -1
ffffe000-fffff000 ---p 00000000 00:00 0 

I am not sure that this is best solution, because some utilities seems
to use /proc/*/maps extensively. Probably initialization should be moved
into initcall.

Nikita.
diff -puN fs/proc/task_mmu.c~uml-FIXADDR_USER_START-not-const fs/proc/task_mmu.c
--- limbo/fs/proc/task_mmu.c~uml-FIXADDR_USER_START-not-const	Fri Jan  9 16:05:37 2004
+++ limbo-god/fs/proc/task_mmu.c	Fri Jan  9 16:06:39 2004
@@ -79,17 +79,26 @@ int task_statm(struct mm_struct *mm, int
 #ifdef AT_SYSINFO_EHDR
 
 static struct vm_area_struct gate_vmarea = {
-	/* Do _not_ mark this area as readable, cuz not the entire range may be readable
-	   (e.g., due to execute-only pages or holes) and the tools that read
-	   /proc/PID/maps should read the interesting bits from the gate-DSO file
-	   instead.  */
-	.vm_start = FIXADDR_USER_START,
-	.vm_end = FIXADDR_USER_END
+	/*
+	 * we cannot initialize fields right here, because on some
+	 * architectures (on UML to be precise), FIXADDR_USER_* are not
+	 * constant. See build_gate_map() below.
+	 */
 };
 
 # define gate_map()	&gate_vmarea
+static inline void build_gate_map(void)
+{
+	/* Do _not_ mark this area as readable, cuz not the entire range may
+	   be readable (e.g., due to execute-only pages or holes) and the
+	   tools that read /proc/PID/maps should read the interesting bits
+	   from the gate-DSO file instead.  */
+	gate_vmarea.vm_start = FIXADDR_USER_START;
+	gate_vmarea.vm_end   = FIXADDR_USER_END;
+}
 #else
 # define gate_map()	NULL
+# define build_gate_map()
 #endif
 
 static int show_map(struct seq_file *m, void *v)
@@ -138,6 +147,8 @@ static void *m_start(struct seq_file *m,
 	if (!mm)
 		return NULL;
 
+	build_gate_map();
+
 	down_read(&mm->mmap_sem);
 	map = mm->mmap;
 	while (l-- && map)
