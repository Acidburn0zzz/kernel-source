Index: linux-2.6.1/arch/i386/Kconfig
===================================================================
--- linux-2.6.1.orig/arch/i386/Kconfig	2004-01-12 12:41:26.000000000 +0100
+++ linux-2.6.1/arch/i386/Kconfig	2004-01-12 12:56:04.000000000 +0100
@@ -822,6 +822,15 @@
 
 endmenu
 
+menu "Special options"
+
+config PROC_MM
+	bool "proc/mm support"
+	---help---
+		/proc/mm is used by a User Mode Linux kernel to support SKAS 
+		mode. If you need this, you'll know it.
+
+endmenu
 
 menu "Power management options (ACPI, APM)"
 	depends on !X86_VOYAGER
Index: linux-2.6.1/arch/i386/kernel/ldt.c
===================================================================
--- linux-2.6.1.orig/arch/i386/kernel/ldt.c	2004-01-12 12:41:26.000000000 +0100
+++ linux-2.6.1/arch/i386/kernel/ldt.c	2004-01-12 12:56:04.000000000 +0100
@@ -105,6 +105,20 @@
 	return retval;
 }
 
+int mm_init_new_context(struct mm_struct *old_mm, struct mm_struct *mm)
+{
+	int retval = 0;
+
+	init_MUTEX(&mm->context.sem);
+	mm->context.size = 0;
+	if (old_mm && old_mm->context.size > 0) {
+		down(&old_mm->context.sem);
+		retval = copy_ldt(&mm->context, &old_mm->context);
+		up(&old_mm->context.sem);
+	}
+	return retval;
+}
+
 /*
  * No need to lock the MM as we are the last user
  */
@@ -121,11 +135,11 @@
 	}
 }
 
-static int read_ldt(void __user * ptr, unsigned long bytecount)
+static int read_ldt(struct task_struct *task, void __user * ptr, unsigned long bytecount)
 {
 	int err;
 	unsigned long size;
-	struct mm_struct * mm = current->mm;
+	struct mm_struct * mm = task->mm;
 
 	if (!mm->context.size)
 		return 0;
@@ -169,9 +183,9 @@
 	return err;
 }
 
-static int write_ldt(void __user * ptr, unsigned long bytecount, int oldmode)
+static int write_ldt(struct task_struct *task, void __user * ptr, unsigned long bytecount, int oldmode)
 {
-	struct mm_struct * mm = current->mm;
+	struct mm_struct * mm = task->mm;
 	__u32 entry_1, entry_2, *lp;
 	int error;
 	struct user_desc ldt_info;
@@ -228,23 +242,29 @@
 	return error;
 }
 
-asmlinkage int sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount)
+int modify_ldt(struct task_struct *task, int func, void __user *ptr, unsigned long bytecount)
 {
 	int ret = -ENOSYS;
 
 	switch (func) {
 	case 0:
-		ret = read_ldt(ptr, bytecount);
+		ret = read_ldt(task, ptr, bytecount);
 		break;
 	case 1:
-		ret = write_ldt(ptr, bytecount, 1);
+		ret = write_ldt(task, ptr, bytecount, 1);
 		break;
 	case 2:
 		ret = read_default_ldt(ptr, bytecount);
 		break;
 	case 0x11:
-		ret = write_ldt(ptr, bytecount, 0);
+		ret = write_ldt(task, ptr, bytecount, 0);
 		break;
 	}
 	return ret;
 }
+
+asmlinkage int sys_modify_ldt(int func, void *ptr, unsigned long bytecount)
+{
+	return(modify_ldt(current, func, ptr, bytecount));
+}
+
Index: linux-2.6.1/arch/i386/kernel/ptrace.c
===================================================================
--- linux-2.6.1.orig/arch/i386/kernel/ptrace.c	2004-01-12 12:41:26.000000000 +0100
+++ linux-2.6.1/arch/i386/kernel/ptrace.c	2004-01-12 12:56:04.000000000 +0100
@@ -229,6 +229,11 @@
 	return 0;
 }
 
+extern int modify_ldt(struct task_struct *task, int func, void *ptr, 
+		      unsigned long bytecount);
+
+extern struct mm_struct *proc_mm_get_mm(int fd);
+
 asmlinkage int sys_ptrace(long request, long pid, long addr, long data)
 {
 	struct task_struct *child;
@@ -355,6 +360,52 @@
 		  }
 		  break;
 
+	case PTRACE_FAULTINFO: {
+		struct ptrace_faultinfo fault;
+
+		fault = ((struct ptrace_faultinfo) 
+			{ .is_write	= child->thread.error_code,
+			  .addr		= child->thread.cr2 });
+		ret = copy_to_user((unsigned long *) data, &fault, 
+				   sizeof(fault));
+		if(ret)
+			break;
+		break;
+	}
+	case PTRACE_SIGPENDING:
+		ret = copy_to_user((unsigned long *) data, 
+				   &child->pending.signal,
+				   sizeof(child->pending.signal));
+		break;
+
+	case PTRACE_LDT: {
+		struct ptrace_ldt ldt;
+
+		if(copy_from_user(&ldt, (unsigned long *) data, 
+				  sizeof(ldt))){
+			ret = -EIO;
+			break;
+		}
+		ret = modify_ldt(child, ldt.func, ldt.ptr, ldt.bytecount);
+		break;
+	}
+
+	case PTRACE_SWITCH_MM: {
+		struct mm_struct *old = child->mm;
+		struct mm_struct *new = proc_mm_get_mm(data);
+
+		if(IS_ERR(new)){
+			ret = PTR_ERR(new);
+			break;
+		}
+
+		atomic_inc(&new->mm_users);
+		child->mm = new;
+		child->active_mm = new;
+		mmput(old);
+		ret=0;
+		break;
+	}
 	case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */
 	case PTRACE_CONT: { /* restart after signal. */
 		long tmp;
Index: linux-2.6.1/arch/i386/kernel/sys_i386.c
===================================================================
--- linux-2.6.1.orig/arch/i386/kernel/sys_i386.c	2004-01-12 12:41:26.000000000 +0100
+++ linux-2.6.1/arch/i386/kernel/sys_i386.c	2004-01-12 12:56:04.000000000 +0100
@@ -40,7 +40,7 @@
 }
 
 /* common code for old and new mmaps */
-static inline long do_mmap2(
+long do_mmap2(struct mm_struct *mm,
 	unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
@@ -55,9 +55,9 @@
 			goto out;
 	}
 
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
+	down_write(&mm->mmap_sem);
+	error = do_mmap_pgoff(mm, file, addr, len, prot, flags, pgoff);
+	up_write(&mm->mmap_sem);
 
 	if (file)
 		fput(file);
@@ -69,7 +69,7 @@
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
 {
-	return do_mmap2(addr, len, prot, flags, fd, pgoff);
+	return do_mmap2(current->mm, addr, len, prot, flags, fd, pgoff);
 }
 
 /*
@@ -100,7 +100,7 @@
 	if (a.offset & ~PAGE_MASK)
 		goto out;
 
-	err = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
+	err = do_mmap2(current->mm, a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
 out:
 	return err;
 }
Index: linux-2.6.1/include/asm-i386/processor.h
===================================================================
--- linux-2.6.1.orig/include/asm-i386/processor.h	2004-01-12 12:41:26.000000000 +0100
+++ linux-2.6.1/include/asm-i386/processor.h	2004-01-12 12:56:04.000000000 +0100
@@ -474,6 +474,8 @@
 struct task_struct;
 struct mm_struct;
 
+int mm_init_new_context(struct mm_struct *old_mm, struct mm_struct *mm);
+
 /* Free all resources held by a thread. */
 extern void release_thread(struct task_struct *);
 
Index: linux-2.6.1/include/asm-i386/ptrace.h
===================================================================
--- linux-2.6.1.orig/include/asm-i386/ptrace.h	2004-01-12 12:41:26.000000000 +0100
+++ linux-2.6.1/include/asm-i386/ptrace.h	2004-01-12 12:56:04.000000000 +0100
@@ -41,6 +41,23 @@
 	int  xss;
 };
 
+
+struct ptrace_faultinfo {
+	int is_write;
+	unsigned long addr;
+};
+
+struct ptrace_ldt {
+	int func;
+  	void *ptr;
+	unsigned long bytecount;
+};
+
+#define PTRACE_FAULTINFO 52
+#define PTRACE_SIGPENDING 53
+#define PTRACE_LDT 54
+#define PTRACE_SWITCH_MM 55
+
 /* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
 #define PTRACE_GETREGS            12
 #define PTRACE_SETREGS            13
Index: linux-2.6.1/include/linux/mm.h
===================================================================
--- linux-2.6.1.orig/include/linux/mm.h	2004-01-12 12:41:26.000000000 +0100
+++ linux-2.6.1/include/linux/mm.h	2004-01-12 12:56:04.000000000 +0100
@@ -445,6 +445,9 @@
 int get_user_pages(struct task_struct *tsk, struct mm_struct *mm, unsigned long start,
 		int len, int write, int force, struct page **pages, struct vm_area_struct **vmas);
 
+extern long do_mprotect(struct mm_struct *mm, unsigned long start, 
+			size_t len, unsigned long prot);
+
 int __set_page_dirty_buffers(struct page *page);
 int __set_page_dirty_nobuffers(struct page *page);
 int set_page_dirty_lock(struct page *page);
