Subject: [patch] uml use sysemu_singlestep.patch
From: Jeff Dike <jdike@addtoit.com>
Patch-mainline: 2.6.11-rc1

This implements using the new ptrace option SYSEMU_SINGLESTEP in UML
(advanced sysemu) in SKAS and TT modes.
To have a fast selection of the appropriate ptrace option to use next,
a 2 dimensional arry is used and singlestepping() is modified to return
0,1 or 2:
    0 = don't do singlestepping
    1 = singlestep a syscall
    2 = singlestep a "non syscall" instruction

In do_syscall() writing of the syscall number is supressed, if the
advanced sysemu is in use (that does it itself).

Signed-off-by: Bodo Stroesser <bstroesser@fujitsu-siemens.com>
Signed-off-by: Jeff Dike <jdike@addtoit.com>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Acked-by: Gerd Knorr <kraxel@suse.de>
---
 arch/um/include/ptrace_user.h    |    7 +++++++
 arch/um/kernel/process_kern.c    |    4 ++--
 arch/um/kernel/skas/process.c    |   10 ++++------
 arch/um/kernel/tt/syscall_user.c |    4 ++++
 arch/um/kernel/tt/tracer.c       |   18 +++++++-----------
 5 files changed, 24 insertions(+), 19 deletions(-)

diff -puN arch/um/include/ptrace_user.h~uml-use-sysemu_singlestep arch/um/include/ptrace_user.h
--- 25/arch/um/include/ptrace_user.h~uml-use-sysemu_singlestep	Fri Dec  3 13:50:43 2004
+++ 25-akpm/arch/um/include/ptrace_user.h	Fri Dec  3 13:50:43 2004
@@ -29,4 +29,11 @@ void set_using_sysemu(int value);
 int get_using_sysemu(void);
 extern int sysemu_supported;
 
+#define SELECT_PTRACE_OPERATION(sysemu_mode, singlestep_mode) \
+	(((int[3][3] ) { \
+		{ PTRACE_SYSCALL, PTRACE_SYSCALL, PTRACE_SINGLESTEP }, \
+		{ PTRACE_SYSEMU, PTRACE_SYSEMU, PTRACE_SINGLESTEP }, \
+		{ PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP, PTRACE_SYSEMU_SINGLESTEP }}) \
+		[sysemu_mode][singlestep_mode])
+
 #endif
diff -puN arch/um/kernel/process_kern.c~uml-use-sysemu_singlestep arch/um/kernel/process_kern.c
--- 25/arch/um/kernel/process_kern.c~uml-use-sysemu_singlestep	Fri Dec  3 13:50:43 2004
+++ 25-akpm/arch/um/kernel/process_kern.c	Fri Dec  3 13:50:43 2004
@@ -464,9 +464,9 @@ int singlestepping(void * t)
 		return(0);
 
 	if (task->thread.singlestep_syscall)
-		return(0);
+		return(1);
 
-	return 1;
+	return 2;
 }
 
 /*
diff -puN arch/um/kernel/skas/process.c~uml-use-sysemu_singlestep arch/um/kernel/skas/process.c
--- 25/arch/um/kernel/skas/process.c~uml-use-sysemu_singlestep	Fri Dec  3 13:50:43 2004
+++ 25-akpm/arch/um/kernel/skas/process.c	Fri Dec  3 13:50:43 2004
@@ -140,15 +140,15 @@ void start_userspace(int cpu)
 
 void userspace(union uml_pt_regs *regs)
 {
-	int err, status, op, pt_syscall_parm, pid = userspace_pid[0];
+	int err, status, op, pid = userspace_pid[0];
 	int local_using_sysemu; /*To prevent races if using_sysemu changes under us.*/
 
 	restore_registers(regs);
 		
 	local_using_sysemu = get_using_sysemu();
 
-	pt_syscall_parm = local_using_sysemu ? PTRACE_SYSEMU : PTRACE_SYSCALL;
-	err = ptrace(pt_syscall_parm, pid, 0, 0);
+	op = local_using_sysemu ? PTRACE_SYSEMU : PTRACE_SYSCALL;
+	err = ptrace(op, pid, 0, 0);
 
 	if(err)
 		panic("userspace - PTRACE_%s failed, errno = %d\n",
@@ -196,10 +196,8 @@ void userspace(union uml_pt_regs *regs)
 
 		/*Now we ended the syscall, so re-read local_using_sysemu.*/
 		local_using_sysemu = get_using_sysemu();
-		pt_syscall_parm = local_using_sysemu ? PTRACE_SYSEMU : PTRACE_SYSCALL;
 
-		op = singlestepping(NULL) ? PTRACE_SINGLESTEP :
-			pt_syscall_parm;
+		op = SELECT_PTRACE_OPERATION(local_using_sysemu, singlestepping(NULL));
 
 		err = ptrace(op, pid, 0, 0);
 		if(err)
diff -puN arch/um/kernel/tt/syscall_user.c~uml-use-sysemu_singlestep arch/um/kernel/tt/syscall_user.c
--- 25/arch/um/kernel/tt/syscall_user.c~uml-use-sysemu_singlestep	Fri Dec  3 13:50:43 2004
+++ 25-akpm/arch/um/kernel/tt/syscall_user.c	Fri Dec  3 13:50:43 2004
@@ -62,6 +62,10 @@ void do_syscall(void *task, int pid, int
 	   ((unsigned long *) PT_IP(proc_regs) <= &_etext))
 		tracer_panic("I'm tracing myself and I can't get out");
 
+	/* advanced sysemu mode set syscall number to -1 automatically */
+	if (local_using_sysemu==2)
+		return;
+
 	/* syscall number -1 in sysemu skips syscall restarting in host */
 	if(ptrace(PTRACE_POKEUSER, pid, PT_SYSCALL_NR_OFFSET, 
 		  local_using_sysemu ? -1 : __NR_getpid) < 0)
diff -puN arch/um/kernel/tt/tracer.c~uml-use-sysemu_singlestep arch/um/kernel/tt/tracer.c
--- 25/arch/um/kernel/tt/tracer.c~uml-use-sysemu_singlestep	Fri Dec  3 13:50:43 2004
+++ 25-akpm/arch/um/kernel/tt/tracer.c	Fri Dec  3 13:50:43 2004
@@ -186,7 +186,7 @@ int tracer(int (*init_proc)(void *), voi
 	unsigned long eip = 0;
 	int status, pid = 0, sig = 0, cont_type, tracing = 0, op = 0;
 	int last_index, proc_id = 0, n, err, old_tracing = 0, strace = 0;
-	int pt_syscall_parm, local_using_sysemu = 0;
+	int local_using_sysemu = 0;
 
 	signal(SIGPIPE, SIG_IGN);
 	setup_tracer_winch();
@@ -391,18 +391,14 @@ int tracer(int (*init_proc)(void *), voi
 			}
 
 			local_using_sysemu = get_using_sysemu();
-			pt_syscall_parm = local_using_sysemu ? PTRACE_SYSEMU : PTRACE_SYSCALL;
 
-			if(tracing){
-				if(singlestepping(task))
-					cont_type = PTRACE_SINGLESTEP;
-				else cont_type = pt_syscall_parm;
-			}
-			else cont_type = PTRACE_CONT;
-
-			if((cont_type == PTRACE_CONT) && 
-			   (debugger_pid != -1) && strace)
+			if(tracing)
+				cont_type = SELECT_PTRACE_OPERATION(local_using_sysemu,
+				                                    singlestepping(task));
+			else if((debugger_pid != -1) && strace)
 				cont_type = PTRACE_SYSCALL;
+			else
+				cont_type = PTRACE_CONT;
 
 			if(ptrace(cont_type, pid, 0, sig) != 0){
 				tracer_panic("ptrace failed to continue "
_
