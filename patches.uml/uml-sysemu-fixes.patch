Subject: [patch] uml sysemu fixes.patch
From: Bodo Stroesser <bstroesser@fujitsu-siemens.com>
Patch-mainline: 2.6.11-rc1

Usage of SYSEMU in TT mode is modified, so that always the
same method is used in do_syscall as has been used before in
ptrace(PTRACE_SYSCALL/SYSEMU, ...)

Signed-off-by: Bodo Stroesser <bstroesser@fujitsu-siemens.com>
Signed-off-by: Jeff Dike <jdike@addtoit.com>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Acked-by: Gerd Knorr <kraxel@suse.de>
---
 arch/um/kernel/tt/include/tt.h   |    2 +-
 arch/um/kernel/tt/syscall_user.c |    9 +++------
 arch/um/kernel/tt/tracer.c       |    8 ++++----
 3 files changed, 8 insertions(+), 11 deletions(-)

diff -puN arch/um/kernel/tt/include/tt.h~uml-sysemu-fixes arch/um/kernel/tt/include/tt.h
--- 25/arch/um/kernel/tt/include/tt.h~uml-sysemu-fixes	Fri Dec  3 13:50:39 2004
+++ 25-akpm/arch/um/kernel/tt/include/tt.h	Fri Dec  3 13:50:39 2004
@@ -26,7 +26,7 @@ extern void set_tracing(void *t, int tra
 extern int is_tracing(void *task);
 extern void syscall_handler(int sig, union uml_pt_regs *regs);
 extern void exit_kernel(int pid, void *task);
-extern int do_syscall(void *task, int pid, int local_using_sysemu);
+extern void do_syscall(void *task, int pid, int local_using_sysemu);
 extern void do_sigtrap(void *task);
 extern int is_valid_pid(int pid);
 extern void remap_data(void *segment_start, void *segment_end, int w);
diff -puN arch/um/kernel/tt/syscall_user.c~uml-sysemu-fixes arch/um/kernel/tt/syscall_user.c
--- 25/arch/um/kernel/tt/syscall_user.c~uml-sysemu-fixes	Fri Dec  3 13:50:39 2004
+++ 25-akpm/arch/um/kernel/tt/syscall_user.c	Fri Dec  3 13:50:39 2004
@@ -48,7 +48,7 @@ void do_sigtrap(void *task)
 	UPT_SYSCALL_NR(TASK_REGS(task)) = -1;
 }
 
-int do_syscall(void *task, int pid, int local_using_sysemu)
+void do_syscall(void *task, int pid, int local_using_sysemu)
 {
 	unsigned long proc_regs[FRAME_SIZE];
 
@@ -62,14 +62,11 @@ int do_syscall(void *task, int pid, int 
 	   ((unsigned long *) PT_IP(proc_regs) <= &_etext))
 		tracer_panic("I'm tracing myself and I can't get out");
 
-	if(local_using_sysemu)
-		return(1);
-
+	/* syscall number -1 in sysemu skips syscall restarting in host */
 	if(ptrace(PTRACE_POKEUSER, pid, PT_SYSCALL_NR_OFFSET, 
-		  __NR_getpid) < 0)
+		  local_using_sysemu ? -1 : __NR_getpid) < 0)
 		tracer_panic("do_syscall : Nullifying syscall failed, "
 			     "errno = %d", errno);
-	return(1);
 }
 
 /*
diff -puN arch/um/kernel/tt/tracer.c~uml-sysemu-fixes arch/um/kernel/tt/tracer.c
--- 25/arch/um/kernel/tt/tracer.c~uml-sysemu-fixes	Fri Dec  3 13:50:39 2004
+++ 25-akpm/arch/um/kernel/tt/tracer.c	Fri Dec  3 13:50:39 2004
@@ -186,7 +186,7 @@ int tracer(int (*init_proc)(void *), voi
 	unsigned long eip = 0;
 	int status, pid = 0, sig = 0, cont_type, tracing = 0, op = 0;
 	int last_index, proc_id = 0, n, err, old_tracing = 0, strace = 0;
-	int pt_syscall_parm, local_using_sysemu;
+	int pt_syscall_parm, local_using_sysemu = 0;
 
 	signal(SIGPIPE, SIG_IGN);
 	setup_tracer_winch();
@@ -307,9 +307,6 @@ int tracer(int (*init_proc)(void *), voi
 			if ( tracing )
 				do_sigtrap(task);
 
-			local_using_sysemu = get_using_sysemu();
-			pt_syscall_parm = local_using_sysemu ? PTRACE_SYSEMU : PTRACE_SYSCALL;
-
 			switch(sig){
 			case SIGUSR1:
 				sig = 0;
@@ -393,6 +390,9 @@ int tracer(int (*init_proc)(void *), voi
 				continue;
 			}
 
+			local_using_sysemu = get_using_sysemu();
+			pt_syscall_parm = local_using_sysemu ? PTRACE_SYSEMU : PTRACE_SYSCALL;
+
 			if(tracing){
 				if(singlestepping(task))
 					cont_type = PTRACE_SINGLESTEP;
_
