From: Abhijeet Joglekar <abjoglek@cisco.com>
Subject: libfc: Fix rport recursive lock on rport mutex
References: bnc #459142

I dont like dropping the lock and then grabbing it again.

Is there some other place where after changing the state to NONE and dropping
the lock, and then calling cancel_sync, another thread can change the state
back to NON-NONE? I am not sure - the rport is out of disc list, so no incoming
frame processing should match, existing rport timeout handlers should see
NONE and so should not do anything.

Signed-off-by: Abhijeet Joglekar <abjoglek@cisco.com>
Acked-by: Bernhard Walle <bwalle@suse.de>
---

 drivers/scsi/libfc/fc_rport.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)


diff --git a/drivers/scsi/libfc/fc_rport.c b/drivers/scsi/libfc/fc_rport.c
index 1ed19d3..5e07adf 100644
--- a/drivers/scsi/libfc/fc_rport.c
+++ b/drivers/scsi/libfc/fc_rport.c
@@ -332,8 +332,12 @@ int fc_rport_logoff(struct fc_rport *rport)
 	 */
 	fc_rport_state_enter(rport, RPORT_ST_NONE);
 
+	mutex_unlock(&rdata->rp_mutex);
+
 	cancel_delayed_work_sync(&rdata->retry_work);
 
+	mutex_lock(&rdata->rp_mutex);
+
 	rdata->event = RPORT_EV_STOP;
 	queue_work(rport_event_queue, &rdata->event_work);
 
