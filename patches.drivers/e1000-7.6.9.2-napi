From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] e1000: merge NAPI changes

 This patch merges the NAPI changes into the sourceforge e1000 driver

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

---
 drivers/net/e1000/e1000.h           |    1 
 drivers/net/e1000/e1000_main.c      |   48 ++++++++++++++----------------------
 drivers/net/e1000/kcompat_ethtool.c |    2 -
 3 files changed, 21 insertions(+), 30 deletions(-)

--- a/drivers/net/e1000/e1000.h	2007-11-02 19:06:37.000000000 -0400
+++ b/drivers/net/e1000/e1000.h	2007-11-03 14:33:56.000000000 -0400
@@ -321,6 +321,7 @@ struct e1000_adapter {
 	struct net_device *netdev;
 	struct pci_dev *pdev;
 	struct net_device_stats net_stats;
+	struct napi_struct	napi;
 
 	/* structs defined in e1000_hw.h */
 	struct e1000_hw hw;
--- a/drivers/net/e1000/e1000_main.c	2007-11-02 19:06:37.000000000 -0400
+++ b/drivers/net/e1000/e1000_main.c	2007-11-03 14:42:40.000000000 -0400
@@ -216,7 +216,7 @@ static irqreturn_t e1000_intr_msi(int ir
 static boolean_t e1000_clean_tx_irq(struct e1000_adapter *adapter,
                                     struct e1000_tx_ring *tx_ring);
 #ifdef CONFIG_E1000_NAPI
-static int e1000_clean(struct net_device *poll_dev, int *budget);
+static int e1000_clean(struct napi_struct *napi, int budget);
 static boolean_t e1000_clean_rx_irq(struct e1000_adapter *adapter,
                                     struct e1000_rx_ring *rx_ring,
                                     int *work_done, int work_to_do);
@@ -644,7 +644,7 @@ int e1000_up(struct e1000_adapter *adapt
 	clear_bit(__E1000_DOWN, &adapter->state);
 
 #ifdef CONFIG_E1000_NAPI
-	netif_poll_enable(adapter->netdev);
+	napi_enable(&adapter->napi);
 #endif
 	e1000_irq_enable(adapter);
 
@@ -754,7 +754,7 @@ void e1000_down(struct e1000_adapter *ad
 	msleep(10);
 
 #ifdef CONFIG_E1000_NAPI
-	netif_poll_disable(netdev);
+	napi_disable(&adapter->napi);
 #endif
 	e1000_irq_disable(adapter);
 
@@ -1048,7 +1048,6 @@ static int __devinit e1000_probe(struct 
 	if (!netdev)
 		goto err_alloc_etherdev;
 
-	SET_MODULE_OWNER(netdev);
 	SET_NETDEV_DEV(netdev, &pdev->dev);
 
 	pci_set_drvdata(pdev, netdev);
@@ -1092,8 +1091,7 @@ static int __devinit e1000_probe(struct 
 	netdev->watchdog_timeo = 5 * HZ;
 #endif
 #ifdef CONFIG_E1000_NAPI
-	netdev->poll = &e1000_clean;
-	netdev->weight = 64;
+	netif_napi_add(netdev, &adapter->napi, e1000_clean, 64);
 #endif
 #ifdef NETIF_F_HW_VLAN_TX
 	netdev->vlan_rx_register = e1000_vlan_rx_register;
@@ -1378,7 +1376,7 @@ static int __devinit e1000_probe(struct 
 	netif_carrier_off(netdev);
 	netif_stop_queue(netdev);
 #ifdef CONFIG_E1000_NAPI
-	netif_poll_disable(netdev);
+	napi_disable(&adapter->napi);
 #endif
 
 
@@ -1583,8 +1581,6 @@ static int __devinit e1000_sw_init(struc
 #ifdef CONFIG_E1000_NAPI
 	for (i = 0; i < adapter->num_rx_queues; i++) {
 		adapter->polling_netdev[i].priv = adapter;
-		adapter->polling_netdev[i].poll = &e1000_clean;
-		adapter->polling_netdev[i].weight = 64;
 		dev_hold(&adapter->polling_netdev[i]);
 		set_bit(__LINK_STATE_START, &adapter->polling_netdev[i].state);
 	}
@@ -1860,7 +1856,7 @@ static int e1000_open(struct net_device 
 	clear_bit(__E1000_DOWN, &adapter->state);
 
 #ifdef CONFIG_E1000_NAPI
-	netif_poll_enable(netdev);
+	napi_enable(&adapter->napi);
 #endif
 
 	e1000_irq_enable(adapter);
@@ -4380,12 +4376,12 @@ static irqreturn_t e1000_intr_msi(int ir
 	}
 
 #ifdef CONFIG_E1000_NAPI
-	if (likely(netif_rx_schedule_prep(netdev))) {
+	if (likely(netif_rx_schedule_prep(netdev, &adapter->napi))) {
 		adapter->total_tx_bytes = 0;
 		adapter->total_tx_packets = 0;
 		adapter->total_rx_bytes = 0;
 		adapter->total_rx_packets = 0;
-		__netif_rx_schedule(netdev);
+		__netif_rx_schedule(netdev, &adapter->napi);
 	} else {
 		atomic_dec(&adapter->irq_sem);
 	}
@@ -4483,12 +4479,12 @@ static irqreturn_t e1000_intr(int irq, v
 		E1000_WRITE_REG(hw, E1000_IMC, ~0);
 		E1000_WRITE_FLUSH(hw);
 	}
-	if (likely(netif_rx_schedule_prep(netdev))) {
+	if (likely(netif_rx_schedule_prep(netdev, &adapter->napi))) {
 		adapter->total_tx_bytes = 0;
 		adapter->total_tx_packets = 0;
 		adapter->total_rx_bytes = 0;
 		adapter->total_rx_packets = 0;
-		__netif_rx_schedule(netdev);
+		__netif_rx_schedule(netdev, &adapter->napi);
 	} else {
 		atomic_dec(&adapter->irq_sem);
 	}
@@ -4543,15 +4539,14 @@ static irqreturn_t e1000_intr(int irq, v
  * e1000_clean - NAPI Rx polling callback
  * @adapter: board private structure
  **/
-static int e1000_clean(struct net_device *poll_dev, int *budget)
+static int e1000_clean(struct napi_struct *napi, int budget)
 {
-	struct e1000_adapter *adapter;
-	int work_to_do = min(*budget, poll_dev->quota);
+	struct e1000_adapter *adapter =
+				container_of(napi, struct e1000_adapter, napi);
+	struct net_device *poll_dev = adapter->netdev;
 	int tx_clean_complete = 1, work_done = 0;
 	int i;
 
-	/* Must NOT use netdev_priv macro here. */
-	adapter = poll_dev->priv;
 
 	/* Keep link state information with original netdev */
 	if (!netif_carrier_ok(poll_dev))
@@ -4581,28 +4576,23 @@ static int e1000_clean(struct net_device
 		/* XXX if the number of queues was limited to a power of two
 		 * this would not need a div */
 		adapter->clean_rx(adapter, &adapter->rx_ring[i],
-		                  &work_done,
-		                  work_to_do / adapter->num_rx_queues);
+		                  &work_done, budget / adapter->num_rx_queues);
 	}
-	*budget -= work_done;
-	poll_dev->quota -= work_done;
-
 
 	/* If no Tx and not enough Rx work done, exit the polling mode */
-	if ((tx_clean_complete && (work_done == 0)) ||
+	if ((tx_clean_complete && (work_done < budget)) ||
 	   !netif_running(poll_dev)) {
 quit_polling:
 		if (likely(adapter->itr_setting & 3))
 			e1000_set_itr(adapter);
-		netif_rx_complete(poll_dev);
+		netif_rx_complete(poll_dev, &adapter->napi);
 		if (test_bit(__E1000_DOWN, &adapter->state))
 			atomic_dec(&adapter->irq_sem);
 		else
 			e1000_irq_enable(adapter);
-		return 0;
 	}
 
-	return 1;
+	return work_done;
 }
 
 #endif
@@ -5769,7 +5759,7 @@ static int e1000_ioctl(struct net_device
 #endif
 #ifdef ETHTOOL_OPS_COMPAT
 	case SIOCETHTOOL:
-		return ethtool_ioctl(ifr);
+		return ethtool_ioctl(netdev, ifr);
 #endif
 	default:
 		return -EOPNOTSUPP;
--- a/drivers/net/e1000/kcompat_ethtool.c	2007-11-02 19:06:37.000000000 -0400
+++ b/drivers/net/e1000/kcompat_ethtool.c	2007-11-03 14:40:48.000000000 -0400
@@ -776,7 +776,7 @@ out:
 #define ETHTOOL_OPS_COMPAT
 int ethtool_ioctl(struct ifreq *ifr)
 {
-	struct net_device *dev = __dev_get_by_name(ifr->ifr_name);
+	struct net_device *dev = __dev_get_by_name(&init_net, ifr->ifr_name);
 	void *useraddr = (void *) ifr->ifr_data;
 	u32 ethcmd;
 
