From: Takashi Iwai <tiwai@suse.de>
Subject: [ALSA] hda-intel - Add probe_mask blacklist
Patch-mainline: 
References: 172330

[ALSA] hda-intel - Add probe_mask blacklist

Added the black-list of probe_mask option to set the default value for
known non-working devices.  Currently, Thinkpad *60 and *61 series are set.
I'm afraid more will be added to the list in near future...

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---

---
 sound/pci/hda/hda_intel.c |   33 ++++++++++++++++++++++++++++++++-
 1 file changed, 32 insertions(+), 1 deletion(-)

--- a/sound/pci/hda/hda_intel.c	2007-10-31 17:43:23.000000000 -0400
+++ b/sound/pci/hda/hda_intel.c	2007-10-31 17:44:57.000000000 -0400
@@ -1544,7 +1544,7 @@ static int __devinit check_position_fix(
 	if (fix == POS_FIX_AUTO) {
 		q = snd_pci_quirk_lookup(chip->pci, position_fix_list);
 		if (q) {
-			snd_printdd(KERN_INFO
+			printk(KERN_INFO
 				    "hda_intel: position_fix set to %d "
 				    "for device %04x:%04x\n",
 				    q->value, q->subvendor, q->subdevice);
@@ -1555,6 +1555,36 @@ static int __devinit check_position_fix(
 }
 
 /*
+ * black-lists for probe_mask
+ */
+static struct snd_pci_quirk probe_mask_list[] __devinitdata = {
+	/* Thinkpad often breaks the controller communication when accessing
+	 * to the non-working (or non-existing) modem codec slot.
+	 */
+	SND_PCI_QUIRK(0x1014, 0x05b7, "Thinkpad Z60", 0x01),
+	SND_PCI_QUIRK(0x17aa, 0x2010, "Thinkpad X/T/R60", 0x01),
+	SND_PCI_QUIRK(0x17aa, 0x20ac, "Thinkpad X/T/R61", 0x01),
+	{}
+};
+
+static void __devinit check_probe_mask(struct azx *chip)
+{
+	const struct snd_pci_quirk *q;
+
+	if (probe_mask == -1) {
+		q = snd_pci_quirk_lookup(chip->pci, probe_mask_list);
+		if (q) {
+			printk(KERN_INFO
+			       "hda_intel: probe_mask set to 0x%x "
+			       "for device %04x:%04x\n",
+			       q->value, q->subvendor, q->subdevice);
+			probe_mask = q->value;
+		}
+	}
+}
+
+
+/*
  * constructor
  */
 static int __devinit azx_create(struct snd_card *card, struct pci_dev *pci,
@@ -1589,6 +1619,7 @@ static int __devinit azx_create(struct s
 	chip->msi = enable_msi;
 
 	chip->position_fix = check_position_fix(chip, position_fix);
+	check_probe_mask(chip);
 
 	chip->single_cmd = single_cmd;
 
