From: Jens Axboe <axboe@suse.de>
Subject: Backout the ide softirq handling change
Patch-mainline: 2.6.15-git
References: 

Acked-by: 
Signed-off-by: 

diff --git a/drivers/ide/ide-io.c b/drivers/ide/ide-io.c
index bcbaeb5..8d50df4 100644
--- a/drivers/ide/ide-io.c
+++ b/drivers/ide/ide-io.c
@@ -55,22 +55,9 @@
 #include <asm/io.h>
 #include <asm/bitops.h>
 
-void ide_softirq_done(struct request *rq)
-{
-	request_queue_t *q = rq->q;
-
-	add_disk_randomness(rq->rq_disk);
-	end_that_request_chunk(rq, 1, rq->data_len);
-
-	spin_lock_irq(q->queue_lock);
-	end_that_request_last(rq, 1);
-	spin_unlock_irq(q->queue_lock);
-}
-
 int __ide_end_request(ide_drive_t *drive, struct request *rq, int uptodate,
 		      int nr_sectors)
 {
-	unsigned int nbytes;
 	int ret = 1;
 
 	BUG_ON(!(rq->flags & REQ_STARTED));
@@ -94,27 +81,12 @@ int __ide_end_request(ide_drive_t *drive
 		HWGROUP(drive)->hwif->ide_dma_on(drive);
 	}
 
-	/*
-	 * For partial completions (or non fs/pc requests), use the regular
-	 * direct completion path. Same thing for requests that failed, to
-	 * preserve the ->errors value we use the normal completion path
-	 * for those
-	 */
-	nbytes = nr_sectors << 9;
-	if (!rq->errors && rq_all_done(rq, nbytes)) {
-		rq->data_len = nbytes;
+	if (!end_that_request_first(rq, uptodate, nr_sectors)) {
+		add_disk_randomness(rq->rq_disk);
 		blkdev_dequeue_request(rq);
 		HWGROUP(drive)->rq = NULL;
-		blk_complete_request(rq);
+		end_that_request_last(rq, uptodate);
 		ret = 0;
-	} else {
-		if (!end_that_request_first(rq, uptodate, nr_sectors)) {
-			add_disk_randomness(rq->rq_disk);
-			blkdev_dequeue_request(rq);
-			HWGROUP(drive)->rq = NULL;
-			end_that_request_last(rq, uptodate);
-			ret = 0;
-		}
 	}
 
 	return ret;
diff --git a/drivers/ide/ide-probe.c b/drivers/ide/ide-probe.c
index 7cb2d86..e742554 100644
--- a/drivers/ide/ide-probe.c
+++ b/drivers/ide/ide-probe.c
@@ -1011,8 +1011,6 @@ static int ide_init_queue(ide_drive_t *d
 	blk_queue_max_hw_segments(q, max_sg_entries);
 	blk_queue_max_phys_segments(q, max_sg_entries);
 
-	blk_queue_softirq_done(q, ide_softirq_done);
-
 	/* assign drive queue */
 	drive->queue = q;
 
diff --git a/include/linux/ide.h b/include/linux/ide.h
index 9a8c05d..f2e1b5b 100644
--- a/include/linux/ide.h
+++ b/include/linux/ide.h
@@ -1002,7 +1002,6 @@ extern int noautodma;
 
 extern int ide_end_request (ide_drive_t *drive, int uptodate, int nrsecs);
 extern int __ide_end_request (ide_drive_t *drive, struct request *rq, int uptodate, int nrsecs);
-extern void ide_softirq_done(struct request *rq);
 
 /*
  * This is used on exit from the driver to designate the next irq handler
