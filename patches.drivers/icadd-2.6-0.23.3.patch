diff -urN linux-2.6.0-test9/Documentation/Leedslite-Install linux-2.6.0-test9-icadd-0107/Documentation/Leedslite-Install
--- linux-2.6.0-test9/Documentation/Leedslite-Install	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/Documentation/Leedslite-Install	2004-01-07 11:21:36.000000000 -0600
@@ -0,0 +1,26 @@
+IBM e-business Cryptographic Accelerator, AKA Leedslite
+
+
+Leedslite DD for Linux kernel INSTALL
+
+Building the Device Driver
+
+	The directions in this section will highly depend on someone fluent
+both in building kernels and device drivers.   
+
+	The driver's compilation can be enabled through a config option of
+'CONFIG_ICA_LEEDSLITE'.   You can access this through the xconfig menu's of:
+
+	IBM Crypto Hardware Support -> IBM Leedslite Crypto Accel. (EXPERIMENTAL)
+however, this option depends on CONFIG_EXPERIMENTAL also being enabled.  This
+driver can be compiled either statically in the kernel or as a module. NOTE: Currently, the driver can only be compiled as modules.  Static compilation is not yet supported via the kernel configuration programs.
+
+	After compiling the kernel and rebooting, if you built the support as modules, there are two modules which must be loaded to enable the leedslite card.  Both modules, devica.o and leedslite.o, can be found in '/lib/modules/_kernel_version_/kernel/drivers/ibmcrypto/leedslite'.
+	Once the two modules are loaded, you should run 'cat /proc/devices' to determine the major number assigned to the ICA card.  After this has been determined, run 'mknod /dev/ica c _major_number_ _minor_number_'.  The minor number will almost always be zero.  
+	Note:  No major number has been secured for the driver.  One can 
+either be configured as a module_parm, or this information can be gleaned
+from /dev/devices.
+	Next, you should set the permissions on the card to make it rw by everyone.  Web servers require this.  Run 'chmod 666 /dev/ica' to do this.
+	Lastly, you should test the card.  Run 'cat /dev/ica' to do this.  If you get back a bunch of random characters, then the card is working properly.
+	Again if this adapter becomes widespread, more detailed information
+and/or facilities may be suplied.
diff -urN linux-2.6.0-test9/arch/i386/Kconfig linux-2.6.0-test9-icadd-0107/arch/i386/Kconfig
--- linux-2.6.0-test9/arch/i386/Kconfig	2003-10-25 13:43:01.000000000 -0500
+++ linux-2.6.0-test9-icadd-0107/arch/i386/Kconfig	2004-01-07 11:21:36.000000000 -0600
@@ -1236,6 +1236,8 @@
 
 source "security/Kconfig"
 
+source "drivers/ibmcrypto/Kconfig"
+
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
diff -urN linux-2.6.0-test9/arch/ppc/Kconfig linux-2.6.0-test9-icadd-0107/arch/ppc/Kconfig
--- linux-2.6.0-test9/arch/ppc/Kconfig	2003-10-25 13:44:53.000000000 -0500
+++ linux-2.6.0-test9-icadd-0107/arch/ppc/Kconfig	2004-01-07 11:21:36.000000000 -0600
@@ -1414,4 +1414,6 @@
 
 source "security/Kconfig"
 
+source "drivers/ibmcrypto/Kconfig"
+
 source "crypto/Kconfig"
diff -urN linux-2.6.0-test9/arch/ppc64/Kconfig linux-2.6.0-test9-icadd-0107/arch/ppc64/Kconfig
--- linux-2.6.0-test9/arch/ppc64/Kconfig	2003-10-25 13:43:47.000000000 -0500
+++ linux-2.6.0-test9-icadd-0107/arch/ppc64/Kconfig	2004-01-07 11:21:36.000000000 -0600
@@ -381,6 +381,8 @@
 
 source "security/Kconfig"
 
+source "drivers/ibmcrypto/Kconfig"
+
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
diff -urN linux-2.6.0-test9/drivers/Makefile linux-2.6.0-test9-icadd-0107/drivers/Makefile
--- linux-2.6.0-test9/drivers/Makefile	2003-10-25 13:44:30.000000000 -0500
+++ linux-2.6.0-test9-icadd-0107/drivers/Makefile	2004-01-07 11:21:36.000000000 -0600
@@ -20,6 +20,7 @@
 obj-y				+= base/ block/ misc/ net/ media/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-$(CONFIG_ATM)		+= atm/
+obj-$(CONFIG_IBM_CRYPTO)	+= ibmcrypto/
 obj-$(CONFIG_PPC_PMAC)		+= macintosh/
 obj-$(CONFIG_IDE)		+= ide/
 obj-$(CONFIG_FC4)		+= fc4/
diff -urN linux-2.6.0-test9/drivers/ibmcrypto/Kconfig linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/Kconfig
--- linux-2.6.0-test9/drivers/ibmcrypto/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/Kconfig	2004-01-07 11:21:36.000000000 -0600
@@ -0,0 +1,14 @@
+#
+# Leedslite Cryptographic Hardware Support configuration
+#
+
+menu "IBM Crypto Hardware support"
+
+config IBM_CRYPTO
+	tristate "IBM Crypto Hardware Support"
+
+config ICA_LEEDSLITE
+	tristate "IBM Leedslite Crypto Accel. (EXPERIMENTAL)"
+	depends on EXPERIMENTAL!=n && IBM_CRYPTO!=n
+
+endmenu
diff -urN linux-2.6.0-test9/drivers/ibmcrypto/Makefile linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/Makefile
--- linux-2.6.0-test9/drivers/ibmcrypto/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/Makefile	2004-01-07 11:21:36.000000000 -0600
@@ -0,0 +1,3 @@
+#
+# Makefile for the IBM Leedslite crypto support
+subdir-$(CONFIG_ICA_LEEDSLITE)		+= leedslite
diff -urN linux-2.6.0-test9/drivers/ibmcrypto/leedslite/Makefile linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/Makefile
--- linux-2.6.0-test9/drivers/ibmcrypto/leedslite/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/Makefile	2004-01-07 11:21:36.000000000 -0600
@@ -0,0 +1 @@
+obj-$(CONFIG_ICA_LEEDSLITE)		:= leedslite.o devica.o
diff -urN linux-2.6.0-test9/drivers/ibmcrypto/leedslite/devica.c linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/devica.c
--- linux-2.6.0-test9/drivers/ibmcrypto/leedslite/devica.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/devica.c	2004-01-07 11:21:36.000000000 -0600
@@ -0,0 +1,707 @@
+/* drivers/char/devica.c: An IBM Crypto Adapter Work Distributor for Linux. */
+/* Copyright (c) International Business Machines Corp., 2001 */
+/*
+	Written 2000-2001 by Jon Grimm
+
+	Version history:
+	YYYY Mon DD First Lastname <email@host>
+		Change Description
+    2003 Nov 18 Serge Hallyn <sergeh@us.ibm.com>
+	    Separate 2.4 and 2.6 driver code.
+    2003 Nov 10 Serge Hallyn <sergeh@us.ibm.com>
+    	    Update for 2.6 kernel (with chardev ripped out of devfs)
+    2001 Mar 05 Jon Grimm <jgrimm@us.ibm.com>
+	    Fix multi-thread bug (devica worker interface changed)
+*/
+
+
+#if !defined(__OPTIMIZE__)  ||  !defined(__KERNEL__)
+#warning  You must compile this file with the correct options!
+#warning  See the last lines of the source file.
+#error You must compile this driver with "-O".
+#endif
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/kmod.h>
+#include <linux/list.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+
+#include <linux/icaioctl.h>
+
+/* Includes neccessary for PowerPC64 that provide functionality to 
+   call system ioctls from the device driver
+*/
+#ifdef CONFIG_PPC64
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/file.h>
+#include <asm/ioctls.h>
+#endif
+
+typedef struct devfs_entry *devfs_handle_t;
+
+/* Dynamic ioctl32 compatability, necessary for PPC64 and possibly
+   other 64 bit platforms
+*/
+#ifdef CONFIG_PPC64
+extern int register_ioctl32_conversion(unsigned int cmd,
+                                       int (*handler)(unsigned int,
+                                                      unsigned int,
+                                                      unsigned long,
+                                                      struct file *));
+#define A(__x) ((unsigned long)(__x))
+extern int unregister_ioctl32_conversion(unsigned int cmd);
+#endif
+
+typedef struct ica_worker_wrapper {
+	struct list_head workers;
+	ica_worker_t *worker;
+} ica_worker_wrapper_t;
+
+typedef struct ica_dev {
+	struct list_head workers;
+	unsigned int count;
+} ica_dev_t;
+
+static const char *version =
+"devica.c:v0.23 11/10/03 Jon Grimm (c) IBM Corp.";
+
+static const char *modname_template =
+"ica-slot-%d";
+
+static int driver_major;
+static int maxdevices = 1;
+static int maxmodules = 1;
+
+static ica_dev_t **devices;
+
+/* This function is called on PPC 64 systems after conversions are 
+   made to the structure passed in as arg.  This function calls
+   the device driver ioctl with the new converted arg
+*/
+#ifdef CONFIG_PPC64
+int do_ica_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	struct file * filp;
+	int error = -EBADF;
+	mm_segment_t old_fs = get_fs();
+
+	filp = fget(fd);
+	if (!filp)
+		goto out;
+	error = 0;
+	lock_kernel();
+
+	set_fs(KERNEL_DS);
+	if (filp->f_op && filp->f_op->ioctl) {
+		error = filp->f_op->ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+	}
+
+	set_fs(old_fs);
+	unlock_kernel();
+	fput(filp);
+out:
+	return error;
+}
+#endif
+
+int ica_register_worker(int part, ica_worker_t *worker)
+{
+	ica_dev_t *dev;
+	ica_worker_wrapper_t *wrapper;
+
+	assertk(worker);
+
+	if((part < 0)||(part >= maxdevices)){
+		return -ENODEV;
+	}
+
+	dev = devices[part];
+
+	if(dev == NULL){
+		dev = kmalloc(sizeof(ica_dev_t), GFP_KERNEL);
+      if ( dev == NULL ){
+         assertk(dev);
+         return -ENOMEM;
+      }
+		memset(dev, 0, sizeof(ica_dev_t));
+		INIT_LIST_HEAD(&dev->workers);
+	}
+
+	wrapper = kmalloc(sizeof(ica_worker_wrapper_t), GFP_KERNEL);
+   if (wrapper == NULL) {
+      assertk(wrapper);
+      return -ENOMEM;
+   }
+	memset(wrapper, 0, sizeof(ica_worker_wrapper_t));
+
+	INIT_LIST_HEAD(&wrapper->workers);
+
+	wrapper->worker = worker;
+
+	list_add(&wrapper->workers, &dev->workers);
+
+	dev->count++;
+	devices[part] = dev;
+
+	return 0;
+}
+
+int ica_unregister_worker(int part, ica_worker_t *worker)
+{
+	ica_dev_t *dev;
+	ica_worker_wrapper_t *wrapper;
+	int rc = -1;
+
+	if(part >= maxdevices){
+		return -1;
+	}
+
+	dev = devices[part];
+
+	
+	if(dev){
+		struct list_head *pos;		
+		
+		list_for_each(pos, &dev->workers){
+			wrapper = list_entry(pos, ica_worker_wrapper_t, workers);
+		
+			if(wrapper->worker == worker){
+		        
+				list_del(pos);
+				kfree(pos);
+				dev->count--;
+				rc=0;
+				break;
+			}
+		}
+
+		if(list_empty(&dev->workers)){
+			devices[part] = NULL;
+			kfree(dev);
+		}
+	}
+
+	return rc;
+}
+
+
+
+static ssize_t ica_rng_read(struct file * filp, char * buf, size_t nbytes, loff_t *ppos)
+{
+	ssize_t count = -ENODEV;
+	ica_worker_t *worker = NULL;
+	ica_worker_wrapper_t *wrapper = NULL;
+	ica_dev_t **save = filp->private_data;
+	ica_dev_t *dev = *save;
+	
+	if(dev){
+		if(!list_empty(&dev->workers)){
+			struct list_head *entry;
+			struct ica_operations *fops;
+
+			entry = dev->workers.next;
+
+			// put at end of list
+			list_del(entry);
+			INIT_LIST_HEAD(entry);
+			
+			list_add_tail(entry, &dev->workers);
+			wrapper = list_entry(entry, ica_worker_wrapper_t, workers);
+			
+			worker = wrapper->worker;
+			assertk(worker);
+
+			fops = worker->icaops;
+			
+			assertk(fops);
+			
+			count = fops->read(filp, buf, nbytes, ppos, worker->private_data);
+			
+
+			// put at front of list
+			// note: worker may have unregistered already, so we
+			// might not find it on the list.   On the slim chance that
+			// someone re-registers with the same partition and with the same
+			// pointer, the worst that happens is that we move it to the 
+			// front of the list.
+
+			dev = *save;
+			if(dev){
+				struct list_head *pos;
+
+				list_for_each(pos, &dev->workers){
+					wrapper = list_entry(pos, ica_worker_wrapper_t, workers);
+					if(wrapper->worker == worker){
+						list_del(pos);
+						INIT_LIST_HEAD(pos);
+						list_add(pos, &dev->workers);
+						break;
+					}
+				}
+			}			
+		}
+	}
+
+
+	return count;
+}
+
+
+static int ica_open(struct inode *inode, struct file *filp)
+{
+	int num;
+	int rc = 0;
+
+	num = MINOR(inode->i_rdev);
+
+	if(num >= maxdevices){
+		printk(KERN_ERR "devica: node %d does not exist\n", num);
+		return -ENODEV;
+	}
+	
+	filp->private_data = &devices[num];
+
+
+	return rc;
+}
+
+
+static int ica_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int ica_ioctl_getcount(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	return -ENOTSUPP;
+}
+
+static int ica_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	ssize_t count = -ENODEV;
+	ica_worker_t *worker = NULL;
+	ica_worker_wrapper_t *wrapper = NULL;
+	ica_dev_t **save = filp->private_data;
+	ica_dev_t *dev = *save;
+	
+
+	switch(cmd){
+	case ICASETBIND:
+	case ICAGETBIND:	
+	case ICAGETID:
+	case ICAGETVPD:
+		return -EOPNOTSUPP;
+	case ICAGETCOUNT:
+		return ica_ioctl_getcount(inode, filp, cmd, arg);
+	}
+ 
+   
+	if(dev){
+
+		if(!list_empty(&dev->workers)){
+			struct list_head *entry;
+			struct ica_operations *fops;
+
+			entry = dev->workers.next;
+
+			assertk(entry);
+
+			// put at end of list
+			list_del(entry);
+			INIT_LIST_HEAD(entry);
+
+			list_add_tail(entry, &dev->workers);
+			wrapper = list_entry(entry, ica_worker_wrapper_t, workers);
+			
+			worker = wrapper->worker;
+			assertk(worker);
+
+			fops = worker->icaops;
+			
+			assertk(fops);
+						
+			count = fops->ioctl(inode, filp, cmd, arg, worker->private_data);
+						
+#if 0
+			// put at front of list
+			// note: worker may have unregistered already, so we
+			// might not find it on the list.   On the slim chance that
+			// someone re-registers with the same partition and with the same
+			// pointer, the worst that happens is that we move it to the 
+			// front of the list.
+
+			dev = *save;
+			
+			if(dev){
+				struct list_head *pos;
+
+				list_for_each(pos, &dev->workers){
+					
+					wrapper = list_entry(pos, ica_worker_wrapper_t, workers);
+					if(wrapper->worker == worker){
+						list_del(pos);
+						INIT_LIST_HEAD(pos);
+
+						list_add(pos, &dev->workers);
+						break;
+					}
+				}
+			}
+#endif
+		}
+	}
+
+
+	return count;
+}
+
+
+struct file_operations ica_fops = {
+	owner: THIS_MODULE,
+	open: ica_open,
+	release: ica_release,
+	ioctl: ica_ioctl,
+	read: ica_rng_read,
+};
+
+
+/*
+ * Create [/devfs]/ica
+ *  and
+ * [/devfs]/devica/ica{0,1,...}
+ */
+void  __devinit ica_register_devfs(unsigned int major)
+{
+	int i;
+
+	devfs_mk_cdev(MKDEV(major,0), S_IRUGO | S_IWUGO | S_IFCHR,
+				"ica");
+
+	devfs_mk_dir("devica");
+	for (i=0; i<maxdevices; i++)
+		devfs_mk_cdev(MKDEV(major,i), S_IRUGO | S_IWUGO | S_IFCHR,
+					"devica/ica%d", i);
+}
+
+
+/* On PPC 64 bit machines, currently there is a 64 bit kernel space and
+ * a 32 bit user space.  When a user calls an ioctl that is in the
+ * kernel, any pointers or longs that are passed into the ioctl must 
+ * be converted so they remain 32 bit rather than expanding to 64 bit
+ * values.  This function performs the necessary conversions for each of
+ * commands the LeedsLite card supports.
+*/
+#ifdef CONFIG_PPC64
+static int ica_ioctl32_conversion(unsigned int fd, unsigned int cmd,
+                                unsigned long arg, struct file *filp)
+{
+ 
+        int rc;
+	void *karg;
+
+/* SAB
+ the unions are to allow us to allocate a single location on the stack
+ at the beginning of the function and reference it as the individual
+ ioctls.
+  For every ioctl that is converted, there needs to be a corresponding
+  entery into the ioctls union.
+
+  There is a one to one mapping between the _32 type and the regular
+  type in icaioctl.h.   
+*/
+union {
+           ica_rng_t_32 rng;
+           ica_sha1_t_32 sha1;
+           ica_des_t_32 des;
+           ica_rsa_modexpo_crt_t_32 crt;
+           ica_rsa_modexpo_t_32 mex;
+           ica_desmac_t_32 dmac;
+} parms32;
+
+union {
+           ica_rng_t rng;
+           ica_sha1_t sha1;
+           ica_des_t des;
+           ica_rsa_modexpo_crt_t crt;
+           ica_rsa_modexpo_t mex;
+           ica_desmac_t dmac;
+} parms;
+
+   switch(cmd) {
+        case ICASETBIND:
+        case ICAGETBIND:
+        case ICAGETCOUNT:
+        case ICAGETID:
+	   rc = do_ica_ioctl(fd, cmd, arg);
+	   break;
+        case ICARNG:
+           if (copy_from_user(&parms32.rng, (struct ica_rng_t_32 *)arg,
+sizeof(ica_rng_t_32)))
+                return -EFAULT;
+           parms.rng.buf = (char *)(A(parms32.rng.buf));
+           parms.rng.nbytes = parms32.rng.nbytes;
+           break;
+        case ICATDESMAC:
+        case ICADESMAC:
+           if (copy_from_user(&parms32.dmac, (struct ica_desmac_t_32 *)arg,
+sizeof(ica_desmac_t_32)))
+                return -EFAULT;
+           parms.dmac.inputdata = (unsigned char *)(A(parms32.dmac.inputdata));
+           parms.dmac.inputdatalength = parms32.dmac.inputdatalength;
+           parms.dmac.outputdata = (unsigned char *)(A(parms32.dmac.outputdata));
+           parms.dmac.outputdatalength = parms32.dmac.outputdatalength;
+           parms.dmac.iv = (ica_des_vector_t *)(A(parms32.dmac.iv));
+           parms.dmac.keys = (ica_des_key_t *)(A(parms32.dmac.keys));
+
+	//printk("DEVICA Before do_ica_ioctl: output: %p\n", parms.dmac.outputdata);
+
+	   break;
+        case ICARSAMODMULT:
+        case ICARSAMODEXPO:
+           if (copy_from_user(&parms32.mex, (struct ica_rsa_modexpo_t_32 *)arg, sizeof(ica_rsa_modexpo_t_32)))
+                return -EFAULT;
+           parms.mex.inputdata = (unsigned char *)(A(parms32.mex.inputdata));
+           parms.mex.inputdatalength = parms32.mex.inputdatalength;
+           parms.mex.outputdata = (unsigned char *)(A(parms32.mex.outputdata));
+           parms.mex.outputdatalength = parms32.mex.outputdatalength;
+           parms.mex.b_key = (unsigned char *)(A(parms32.mex.b_key));
+           parms.mex.n_modulus = (unsigned char *)(A(parms32.mex.n_modulus));
+           break;
+        case ICARSACRT:
+           if (copy_from_user(&parms32.crt, (struct ica_rsa_modexpo_crt_t_32 *)arg, sizeof(ica_rsa_modexpo_crt_t_32)))
+                return -EFAULT;
+
+           parms.crt.inputdata = (unsigned char *)(A(parms32.crt.inputdata));
+           parms.crt.inputdatalength = parms32.crt.inputdatalength;
+           parms.crt.outputdata = (unsigned char *)(A(parms32.crt.outputdata));
+           parms.crt.outputdatalength = parms32.crt.outputdatalength;
+           parms.crt.bp_key = (unsigned char *)(A(parms32.crt.bp_key));
+           parms.crt.bq_key = (unsigned char *)(A(parms32.crt.bq_key));
+           parms.crt.np_prime = (unsigned char *)(A(parms32.crt.np_prime));
+           parms.crt.nq_prime = (unsigned char *)(A(parms32.crt.nq_prime));
+           parms.crt.u_mult_inv = (unsigned char *)(A(parms32.crt.u_mult_inv));
+           break;
+        case ICATDES:
+        case ICADES:
+           if (copy_from_user(&parms32.des, (struct ica_des_t_32 *)arg, sizeof(ica_des_t_32)))
+                return -EFAULT;
+
+           parms.des.mode = parms32.des.mode;
+           parms.des.direction = parms32.des.direction;
+           parms.des.inputdatalength = parms32.des.inputdatalength;
+           parms.des.outputdatalength = parms32.des.outputdatalength;
+           parms.des.iv = (ica_des_vector_t *)(A(parms32.des.iv));
+           parms.des.keys = (ica_des_key_t *)(A(parms32.des.keys));
+           parms.des.outputdata = (unsigned char *)(A(parms32.des.outputdata));
+           parms.des.inputdata = (unsigned char *)(A(parms32.des.inputdata));
+           break;
+        case ICASHA1:
+        case ICATDESSHA:
+           if (copy_from_user(&parms32.sha1, (struct ica_sha1_t_32 *)arg,
+sizeof(ica_sha1_t_32)))
+                return -EFAULT;
+
+           parms.sha1.inputdatalength = parms32.sha1.inputdatalength;
+           parms.sha1.outputdata = (ica_sha1_result_t *)(A(parms32.sha1.outputdata));
+           parms.sha1.initialh = (ica_sha1_result_t *)(A(parms32.sha1.initialh));
+           parms.sha1.inputdata = (unsigned char *)(A(parms32.sha1.inputdata));
+           break;
+        default: 
+           rc = -EOPNOTSUPP;
+                break;
+        }
+/* issue the ioctl in one place for those
+ ioctl's which have argument mapping. */
+      karg = &parms.rng; /* need to use an element of the union.  any one will do
+                          since they all occupy the same space in memory*/
+      rc = do_ica_ioctl(fd, cmd, (unsigned long)karg);
+
+     return rc;
+}
+
+/* Register all of the handlers needed for conversion */
+int register_conversion_handlers(void)
+{
+        int err;
+
+        err |= register_ioctl32_conversion(ICASETBIND, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICAGETBIND, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICAGETCOUNT,
+ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICAGETID, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICARSAMODEXPO,
+ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICARSACRT, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICARSAMODMULT,
+ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICADES, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICATDES, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICADESMAC, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICATDESMAC, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICATDESSHA, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICASHA1, ica_ioctl32_conversion);
+        err |= register_ioctl32_conversion(ICARNG, ica_ioctl32_conversion);
+
+        return err;
+}
+
+/* Unregister the conversion handlers.  There is no need to check
+   return codes, all unregister_ioctl32_conversion does it try to 
+   remove the command from a linked list, if is it not there, the
+   error is non-fatal
+*/
+void unregister_conversion_handlers(void)
+{
+        unregister_ioctl32_conversion(ICASETBIND);
+        unregister_ioctl32_conversion(ICAGETBIND);
+        unregister_ioctl32_conversion(ICAGETCOUNT);
+        unregister_ioctl32_conversion(ICAGETID);
+        unregister_ioctl32_conversion(ICARSAMODEXPO);
+        unregister_ioctl32_conversion(ICARSACRT);
+        unregister_ioctl32_conversion(ICARSAMODMULT);
+        unregister_ioctl32_conversion(ICADES);
+        unregister_ioctl32_conversion(ICATDES);
+        unregister_ioctl32_conversion(ICADESMAC);
+        unregister_ioctl32_conversion(ICATDESMAC);
+        unregister_ioctl32_conversion(ICATDESSHA);
+        unregister_ioctl32_conversion(ICASHA1);
+        unregister_ioctl32_conversion(ICARNG);
+
+        return;
+}
+#endif
+
+int __init ica_driver_init(void)
+{
+	int rc;	
+	int i;
+	char modname[100];
+
+	if(maxdevices < 1){
+		printk(KERN_ERR "devica: maxdevices<1\n");
+		maxdevices = 1;
+	}
+
+	if(maxmodules < 1){
+		printk(KERN_ERR "devica: maxmodules<1\n");
+		maxmodules = 1;
+	}
+
+	devices = kmalloc(maxdevices * sizeof(ica_dev_t *), GFP_KERNEL);
+
+	if(!devices){
+		assertk(devices);
+		rc = -ENOMEM;
+		goto err_ica_init;
+	}
+
+	memset(devices, 0, maxdevices * sizeof(ica_dev_t *));
+
+	rc = register_chrdev(driver_major, "ica", &ica_fops);
+
+	if(rc < 0){
+		printk("ica_register_chrdev(ica) returned %d\n", rc);
+		assertk(rc >= 0);
+		goto err_ica_init_register_chrdev;
+	}
+
+	if(driver_major == 0)
+		driver_major = rc;
+
+	ica_register_devfs(driver_major);
+
+	printk(KERN_INFO "%s: Init Success\n", version);
+
+	/* Try to load dependent drivers, if not already loaded */
+	
+	for(i=0; i<maxmodules; i++){		
+		sprintf(modname, modname_template, i);
+		request_module(modname);
+	}  
+// On 64 bit kernels, we need function handlers to convert from 32 bit user
+// space to 64 bit kernel space
+#ifdef CONFIG_PPC64
+        rc = register_conversion_handlers();
+        if (rc != 0){
+                printk(KERN_ERR "Error Registering conversion handlers(%d)\n",
+			rc);
+		goto err_reg_handlers;
+        }
+#endif
+
+	return 0;
+#ifdef CONFIG_PPC64
+ err_reg_handlers:
+	unregister_conversion_handlers();
+#endif
+	unregister_chrdev(driver_major, "ica");
+ err_ica_init_register_chrdev:
+	kfree(devices);
+ err_ica_init:
+	return rc;
+}
+
+static int __init ica_init_module(void)
+{
+	return ica_driver_init();
+}
+
+static void __exit ica_cleanup_module(void)
+{
+	/* Unregister all of the handlers for 32->64 bit conversion */
+#ifdef CONFIG_PPC64
+	unregister_conversion_handlers();
+#endif
+	devfs_remove("ica");
+	devfs_remove("devica");
+
+	unregister_chrdev(driver_major, "ica");
+	kfree(devices);
+}
+
+
+#ifdef MODULE
+
+MODULE_AUTHOR("Jon Grimm <jgrimm@us.ibm.com>");
+MODULE_DESCRIPTION("IBM Crypto Adapter Work Distributor");
+MODULE_PARM(maxdevices, "i");
+MODULE_PARM(maxmodules, "i");
+MODULE_PARM(driver_major, "i");
+
+#endif /* MODULE */
+
+EXPORT_SYMBOL(ica_register_worker);
+EXPORT_SYMBOL(ica_unregister_worker);
+
+module_init(ica_init_module);
+module_exit(ica_cleanup_module);
+
+
+/*
+ * Local variables:
+ *  compile-command: "gcc -g -DMODULE -D__KERNEL__  -Wall -Wstrict-prototypes -O6 -c devica.c `[ -f /usr/include/linux/modversions.h ] && echo -DMODVERSIONS`"
+ *  c-indent-level: 4
+ *  c-basic-offset: 4
+ *  tab-width: 4
+ * End:
+ */
diff -urN linux-2.6.0-test9/drivers/ibmcrypto/leedslite/leedslite.c linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/leedslite.c
--- linux-2.6.0-test9/drivers/ibmcrypto/leedslite/leedslite.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/leedslite.c	2004-01-07 11:22:35.000000000 -0600
@@ -0,0 +1,2733 @@
+/* drivers/char/leedslite.c: An IBM Crypto Adapter driver for Linux. */
+/* Copyright (c) International Business Machines Corp., 2001 */
+/* 
+  NOTICE: Have only developed test on 2.2.18+ or 2.4.0+ kernels.
+
+	Written 2000-2001 by Jon Grimm
+
+	Version history:
+	YYYY Mon DD First Lastname <email@host>
+		Change Description
+    2003 Nov 18 Serge Hallyn <sergeh@us.ibm.com>
+	    Separate 2.4 and 2.6 driver code.
+    2003 Nov 10 Serge Hallyn <sergeh@us.ibm.com>
+    	    Update for 2.6 kernel (with chardev ripped out of devfs)
+    2001 Mar 05 Jon Grimm <jgrimm@us.ibm.com>
+	    Fix multi-thread bug in devica (devica interface changed)
+		Enable REE bits _after_ chip enabled
+		Move signal handling so we complete request if I/O is completed.
+
+*/
+
+
+#if !defined(__OPTIMIZE__)  ||  !defined(__KERNEL__)
+#warning  You must compile this file with the correct options!
+#warning  See the last lines of the source file.
+#error You must compile this driver with "-O".
+#endif
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/kmod.h>
+#include <linux/list.h>
+#include <asm/uaccess.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+
+
+
+
+#include <linux/icaioctl.h>
+#include "leedslite.h"
+
+
+#define DESBUFFER_SIZE 4096
+
+typedef struct rsa_free {
+	struct list_head freelist;
+	int index;
+	wait_queue_head_t wait;
+	leedslite_vfifo_entry_t vfstatus;
+	int status;
+} rsa_free_t;
+
+typedef struct devfs_entry *devfs_handle_t;
+
+typedef struct leedslite_dev {
+   
+	long                      ioaddr;
+	char *                    window1;
+	char *                    window2;
+	int                       irq;
+	struct pci_dev *          pdev;
+
+	
+	wait_queue_head_t         rng_current_wait;
+	atomic_t                  entropy_available;
+
+	struct semaphore          des_wait;
+	wait_queue_head_t         des_current_wait;
+	char *                    desbuffer;  
+	dma_addr_t                des_handle;
+	int                       des_status;
+
+	
+	struct semaphore          rsa_wait;
+	rsa_free_t *              rsa_freelist;
+	struct list_head          rsa_freelist_head;
+	leedslite_rip_entry_t *   rip;
+	leedslite_rop_entry_t *   rop;
+	leedslite_vfifo_entry_t * vfifo; 
+	dma_addr_t                rip_handle;
+	dma_addr_t                rop_handle;
+	dma_addr_t                vfifo_handle;
+	int                       lwp;     
+
+	ica_worker_t              icareg;
+	int                       bind;
+	devfs_handle_t            icahandle;
+	int			  minor;
+	
+	struct list_head          node;
+} leedslite_dev_t;
+
+
+
+typedef struct _camelot_operation {
+	int (*verify)(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg);
+	int (*execute)(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg);
+} camelot_op_t; 
+
+typedef struct _rsa_operation {
+	int (*verify)(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg);
+	int (*execute)(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg, rsa_free_t *entry);
+} rsa_op_t; 
+	
+
+static const char *version =
+"leedslite.c:v0.22 05/27/03 Jon Grimm (c) IBM Corp.";
+
+
+static int driver_major;
+static int devica = 1;          /* register with /dev/ica partition */    
+static int maxdevices = 12;
+static int desbuffersize = 8192;
+static int rsabufs = LEEDSLITE_VFIFO_ENTRIES; 
+static int sam = SAM_MIN;
+static int pmwi = 1;     
+static int error_timeout = LEEDSLITE_ERR_TIMEOUT_MIN;
+
+static leedslite_dev_t **devices;
+
+static struct list_head devicelist;
+
+static int bigendian = 0; /* FLAG to determine if big endian or not */
+
+
+
+/* fcn to determine at runtime the endianess of the platform */
+int
+isbigendian(void) {
+
+#define LE  0x2143 
+#define BE  0x4321
+
+unsigned short *value;
+unsigned char p[2];
+
+p[0] = 0x43;
+p[1] = 0x21;
+value = (unsigned short *)p;
+
+if ( *value == BE )
+    return(1);
+else 
+     return(0);
+
+}
+
+
+static inline int camelot_gcra_enable_rsa(leedslite_dev_t *dev)
+{
+	unsigned int gcra, rcr;
+	unsigned int i;
+
+	gcra = readw(dev->window2+REG_GCR);
+	gcra |= CAM_GCRA_RSA_Enable;
+		
+	writew(gcra, dev->window2+REG_GCR);	
+
+    /* 
+	 * Per engineers poll the safety bit.   Limit the polling
+	 * loop so we don't spin here forever.  Shouldn't happen 
+	 * but I don't like endless loops. 
+	 */
+
+	i=200; 
+	do {
+		udelay(1000);  
+		rcr = readw(dev->window2 + REG_CAM_RCR);
+		i--;
+		
+	} while (!(rcr & CAM_RCR_COMPLETE) && i );
+
+	return (rcr & CAM_RCR_COMPLETE);
+}
+
+static inline void camelot_rscr_enable_ree(leedslite_dev_t *dev, int id)
+{
+	int rscr;
+
+	/* 
+	 * Convert CamelotID to REE bit 
+	 * FYI, id is value 1-5 (as opposed to zero-based index)
+	 */
+
+	id = 1 << (id-1);
+	id <<= 8;  
+
+	/* Turn on the appropriate REE bit */
+
+	rscr = inw(dev->ioaddr + REG_RSCR);
+	rscr |= id;
+	
+	outw(rscr, dev->ioaddr + REG_RSCR);
+}
+
+
+
+
+static inline void camelot_gsra_enable_rng(leedslite_dev_t *dev){
+	int gsra;
+
+	/* Enable RNG Registers */
+
+	gsra = readw(dev->window2 + REG_GSRA);
+	gsra |=  CAM_GSRA_RNG_INT_EN;		
+	
+	/* Set for rng for maximum speed */
+
+	gsra |=  CAM_GSRA_RNGSpd0 | CAM_GSRA_RNGSpd1 | CAM_GSRA_RNGSpd2;  
+	writew(gsra, dev->window2 + REG_GSRA);
+}
+
+static inline void camelot_gsr_enable_des(leedslite_dev_t *dev){
+	int gsr;
+
+	/* Enable SHA registers */
+
+	gsr = readw(dev->window2 + REG_GSR);
+	gsr |= 1<<10;			
+	writew(gsr, dev->window2 + REG_GSR);
+}
+
+static inline void camelot_gsra_enable_sha(leedslite_dev_t *dev){
+	int gsra;
+	int ctrl;
+
+	/* Enable SHA registers */
+
+	gsra = readw(dev->window2 + REG_GSRA);
+	gsra |=  CAM_GSRA_SHA_EN;			
+	writew(gsra, dev->window2 + REG_GSRA);
+
+	/* Prime SHA variables with FIPS-180 values */
+
+	ctrl = SHA_KEY_CONTROL_SET_H | SHA_KEY_CONTROL_SET_K;
+	writew(ctrl, dev->window2 + REG_SHA_KEY_CONTROL);
+}
+
+static inline void camelot_enable_cam1(leedslite_dev_t *dev)
+{
+	
+	camelot_gsr_enable_des(dev);
+	camelot_gsra_enable_sha(dev);   
+
+	/* Clear any pending RNG data 
+	 *    RNG interrupt won't fire if there is already data available
+	 *    Let's clear it here, then we will know our state from here
+     *    on out.
+	 */
+	readl(dev->window2 + REG_RNG);
+	readl(dev->window2 + REG_RNG +4);
+
+	/*
+	 * Make sure the Selected Camelot will start generating random numbers.
+	 * May have already been enabled.   
+	 */
+
+	camelot_gsra_enable_rng(dev);
+}
+
+static inline void camelot_select(leedslite_dev_t *dev, int id)
+{
+	int oscr;
+	
+	oscr = inw(dev->ioaddr+REG_OSCR);
+	oscr &= ~OSCR_CSV;
+	oscr = (id << OSCR_CSV_SHIFT);
+	
+	outw(oscr, dev->ioaddr+REG_OSCR);
+}
+
+static inline void camelot_reset(leedslite_dev_t *dev, int id)
+{
+	unsigned int oscr;
+	
+	/* Select the offending camelot */
+
+	camelot_select(dev, id);
+	
+	/* Go reset the identified Camelot */
+
+	oscr = inw(dev->ioaddr+REG_OSCR);
+	oscr |= 1 << (id-1);
+	outw(oscr, dev->ioaddr+REG_OSCR);
+
+	udelay(1);             // Reset needs min 500 ns delay
+
+	oscr &= ~OSCR_Cam_RST;
+	outw(oscr, dev->ioaddr+REG_OSCR);
+
+	/* Now go turn RSA back on... however beware, the Camelot needs
+	 * a bit of time to initialize...  per the engineers, poll on
+	 * the COMPLETE bit
+	 */
+
+	if (!camelot_gcra_enable_rsa(dev))
+		printk(KERN_ERR "leedslite: unable to reset camelot %d\n", id);
+
+	/* Another safety delay */
+
+	udelay(1000);
+
+	/* Make sure we put back the selected camelot back to 1 */
+	
+	camelot_select(dev, 1);
+
+	/* 
+	 * If this was camelot #1, we also need to go renable rng, 
+	 * des, & sha.
+	 */
+
+	if (id == 1)
+		camelot_enable_cam1(dev);
+	   		
+}
+
+static inline void camelot_des_csr_reset(leedslite_dev_t *dev){
+	int csr;
+
+	csr = readw(dev->window2 + REG_DES_CSR);
+	csr &=  ~CAM_DESCSR_START;
+	writew(0, dev->window2 + REG_DES_CSR);
+}
+
+
+/*
+ * Read operation on rng device. 
+ *    The adapter generates a 64-bit random number upon request.
+ *  
+ *    The code below may look a little odd as my goal is to keep this
+ * as asynchronous as possible.  Instead of clocking the rng generation
+ * by toggling the rng interrupt enable bit, I'll leave it free running
+ * with a new rng being generated any time I read out the previous
+ * rng data.   
+ *    
+ * A thread will atomically check the entropy_available field, if no
+ * entropy is available, it will go to sleep (via 'schedule').  
+ * 'add_wait_queue' will put the entry at the front of the queue. 
+ * 
+ */
+static ssize_t rng_read_worker(struct file * filp, char * buf, size_t nbytes, loff_t *ppos, void *private)
+{
+	DECLARE_WAITQUEUE(current_wait, current);
+	ssize_t count;
+	ssize_t read;
+	ssize_t error = 0;
+	leedslite_dev_t *dev = (leedslite_dev_t *)private;
+	u32 loc_buf[2];
+
+ 	count = 0;
+	
+	//printk("nbytes: %d\nbuf: %p\n", nbytes, buf);
+
+	while(nbytes - count){
+				
+		/* 
+		 * If there is no data already available for us,
+		 * wait until the interrupt handler wakes us up.
+		 *
+		 * Note: we put our selves on the wait_queue and have marked
+		 * ourselves, as sleeping before we check entropy_availalbe.
+		 * 
+		 * If the interrupt handler fires before we check the entropy
+		 * available, the handler will mark us RUNNING and the schedule()
+		 * will do nothing.
+		 *
+		 * Otherwise, we'll go to sleep and the interrupt handler will
+		 * wake us.  
+		 *
+		 */
+		init_waitqueue_entry(&current_wait, current);
+
+		set_current_state(TASK_INTERRUPTIBLE);
+       
+
+		
+#ifdef WQ_FLAG_EXCLUSIVE
+			add_wait_queue_exclusive(&dev->rng_current_wait, &current_wait);
+#else
+			add_wait_queue(&dev->rng_current_wait, &current_wait);
+#endif
+						
+	   
+		if (atomic_read(&dev->entropy_available)){
+			atomic_set(&dev->entropy_available, 0);
+			set_current_state(TASK_RUNNING);
+
+			read = (nbytes-count) > 8 ? 8 : nbytes-count;
+
+                       /* Read out the full 8 bytes of random data that the card
+                        * provides here, in order to trigger it to provide 8 more.
+                        * Then only copy_to_user what we need. Doing a copy_to_user
+                        * directly from the card breaks ppc64. - KEY
+                        */
+                       loc_buf[0] = readl(dev->window2+REG_RNG);
+                       loc_buf[1] = readl(dev->window2+REG_RNG+4);
+
+                       if (copy_to_user(buf+count, loc_buf, read))
+                               error = -EFAULT;
+
+			count+=read;
+			
+			remove_wait_queue(&dev->rng_current_wait, &current_wait);
+			if (error)
+				goto out;
+			
+		} else {
+			
+			schedule();
+			
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&dev->rng_current_wait, &current_wait);
+
+			/*
+			 * If we got interrupted by a signal, remove ourselves from
+			 * all the queues and let the next up task in to stage 2.
+			 */
+
+			if (signal_pending(current)){
+				return -ERESTARTSYS;
+			}
+			
+		} 
+			
+	      		
+   		
+	}
+
+ out:	
+	return count;
+}
+
+static ssize_t rng_read(struct file * filp, char * buf, size_t nbytes, loff_t *ppos)
+{
+	void *private = filp->private_data;	
+
+	return rng_read_worker(filp, buf, nbytes, ppos, private);
+}
+
+
+static struct file_operations ica_fops;
+
+static int ica_open(struct inode *inode, struct file *filp)
+{
+	unsigned slot;
+	int rc;
+	
+	slot = MINOR(inode->i_rdev);
+	
+	if(slot >= maxdevices){
+		assertk(slot < maxdevices);
+		rc =  -ENODEV;
+		goto err_open;
+	}
+
+	
+	filp->private_data = devices[slot];
+
+	if(!filp->private_data){
+		rc = -ENODEV;
+		goto err_open;
+	}
+	
+	
+	assertk(filp->f_op == &ica_fops);
+	
+	return 0;
+
+ err_open:
+	return rc;
+	
+}
+
+
+
+static int ica_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+
+static int ica_ioctl_setbind(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	int bind;
+	int err;
+
+	err = get_user(bind, (int *)arg);	
+
+	if(!err){
+
+		
+		if(bind != dev->bind){
+	   	   
+			if(bind < 0){
+				bind = -1;
+				err = ica_unregister_worker(dev->bind, &dev->icareg);
+			} else {
+				ica_unregister_worker(dev->bind, &dev->icareg);
+				err = ica_register_worker(bind, &dev->icareg);
+				if(err)
+					dev->bind = -1;
+			}
+			if(!err){
+				dev->bind = bind;
+			} 
+		}
+	}
+		
+	return err;
+}
+
+static int ica_ioctl_getbind(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	int err;
+
+	err = put_user(dev->bind, (int *)arg);
+
+	return err;
+}
+
+static int ica_ioctl_getcount(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return 0;
+}
+
+static int ica_ioctl_getid(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return 0;
+}
+
+
+static int des_verify(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg){ 
+	ica_des_t pkt;
+	int keysize;
+	ica_des_vector_t kiv;
+	ica_des_key_t kkeys[3];
+
+	
+	if(copy_from_user(&pkt, (ica_des_t *)arg, sizeof(ica_des_t)))
+		return -EFAULT;  
+
+	if((pkt.inputdatalength > ICA_DES_DATALENGTH_MAX) || (pkt.outputdatalength > ICA_DES_DATALENGTH_MAX))
+		return -EINVAL;
+
+
+	keysize = (cmd == ICATDES) ? sizeof(ica_des_triple_t) : sizeof(ica_des_single_t);
+	
+	if((pkt.mode != DEVICA_MODE_DES_ECB) && (pkt.mode != DEVICA_MODE_DES_CBC)) 
+		return -EINVAL;
+	
+	if((pkt.direction != DEVICA_DIR_DES_ENCRYPT) && (pkt.direction != DEVICA_DIR_DES_DECRYPT))
+		return -EINVAL;
+	
+	if(pkt.outputdatalength < pkt.inputdatalength)
+		return -EINVAL;
+	
+	if((pkt.inputdatalength % ICA_DES_DATALENGTH_MIN) != 0)
+		return -EINVAL;
+
+
+	/* 
+	 * Go ahead and read the iv and key to see if the pointers are good, do
+	 * this by copying to kernel space... the xxx_user macros do all sorts of 
+	 * exception handling magic to return -EFAULT when invalid.   Seems
+	 * easier doing this here than clutter up some of the i/o code. 
+	 */
+	
+	if(copy_from_user(&kiv, pkt.iv, sizeof(ica_des_vector_t)))
+		return -EFAULT;
+	
+
+	if(copy_from_user(kkeys, pkt.keys, keysize))
+		return -EFAULT;
+
+	return 0;
+}
+
+
+#define MAX_BUF_SIZE DESBUFFER_SIZE 
+
+
+static inline void camelot_des_iv_write(leedslite_dev_t *dev, ica_des_vector_t *iv)
+{
+	int i;
+	u32 tmp;
+	
+	//for( i = 0; i < sizeof(ica_des_vector_t); i++)
+	//	writeb((char *)iv[i], dev->window2 + REG_DES_IV + i);
+
+	for( i = 0; i < sizeof(ica_des_vector_t)/sizeof(u32); i++) {
+		//((u32 *)iv)[i] = __cpu_to_le32( ((u32 *)iv)[i] );
+		tmp = __cpu_to_le32( ((u32 *)iv)[i] );
+		//writel((u32 *)iv[i], dev->window2 + REG_DES_IV + (i*sizeof(u32)));
+		writel(tmp, dev->window2 + REG_DES_IV + (i*sizeof(u32)));
+	}
+
+	//memcpy(dev->window2 + REG_DES_IV, iv, sizeof(ica_des_vector_t));
+}
+
+static inline void camelot_des_key_write(leedslite_dev_t *dev, ica_des_key_t *key, int index)
+{
+	int offset, i;
+	u32 tmp;
+
+	offset = REG_DES_KEY_1;
+	offset += index * sizeof(ica_des_key_t);
+	
+	for( i = 0; i < sizeof(ica_des_key_t)/sizeof(u32); i++) {
+		tmp = __cpu_to_le32( ((u32 *)key)[i] );
+		writel(tmp, dev->window2 + offset + (i*sizeof(u32)));
+		//((u32 *)key)[i] = __cpu_to_le32( ((u32 *)key)[i] );
+		//writel((u32 *)key[i], dev->window2 + offset + (i*sizeof(u32)));
+	}
+
+	//for( i = 0; i < sizeof(ica_des_key_t); i++)
+	//	writeb((char *)key[i], dev->window2 + offset + i);
+	//memcpy(dev->window2 + offset, key, sizeof(ica_des_key_t));
+}
+
+static void camelot_setup_key_regs(leedslite_dev_t *dev, unsigned int opcode, ica_des_vector_t *iv, ica_des_key_t *keys)
+{
+
+	/* Write iv out to the Camelot */
+	if(!(opcode & DCR_ECB))
+		camelot_des_iv_write(dev, iv);
+	
+	/* Write keys out to the Camelot */		
+	
+	camelot_des_key_write(dev, &keys[0], 0);
+	
+	if(opcode & DCR_TDES){
+		camelot_des_key_write(dev, &keys[1], 1);
+		camelot_des_key_write(dev, &keys[2], 2);
+	}
+
+}
+
+
+
+static int des_execute_common(leedslite_dev_t *dev, unsigned int opcode, char *input, char *output, int bytesleft, ica_des_vector_t *iv, ica_des_key_t *keys)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned int timeleft;
+	int offset;
+	int transfercount;
+	int command;
+	int setup;
+	int gsr;
+
+	setup = 0;
+	offset = 0;
+
+	/* Clear out the DES start bit, so the IV will be read. */
+
+	camelot_des_csr_reset(dev);
+	
+	/*
+	 * This does an explicit DES enable on the card before we
+	 * issue the card the command. Under stress this bit may
+	 * not be set, which would cause incorrect results.
+	 */
+	gsr = readw(dev->window2 + REG_GSR);
+	gsr |=  CAM_GSR_DES_EN;
+	writew(gsr, dev->window2 + REG_GSR);
+
+		
+	while(bytesleft){	
+
+		/*
+		 * If we got a signal, don't continue on.  
+		 */
+
+		if(signal_pending(current)){
+			//printk(KERN_INFO "got signal des\n");
+			return -ERESTARTSYS;
+		}
+
+		
+		transfercount = (bytesleft >= MAX_BUF_SIZE) ? MAX_BUF_SIZE : bytesleft;
+
+		if(copy_from_user(dev->desbuffer, input+offset, transfercount))
+			return -EFAULT;
+		
+		/* Set up the DES Command Register */
+
+		
+		command = opcode | (_dlen(transfercount) << DCR_DLen_SHIFT);
+		outl(command, dev->ioaddr + REG_DCR);
+		
+		
+		/* 
+		 * Only need to write the keys out once to the Camelot.
+		 * Note: I've already touched the data in the verify routine
+		 * to make sure the pointers are good.
+		 */
+
+		
+		if(!setup){
+			camelot_setup_key_regs(dev, opcode, iv, keys);			
+			setup = 1;
+		}
+
+
+		/* Getting ready for the interrupt handler to wake us.
+		 * Pretend we are sleeping, If interrupt handler fires before
+		 * we actually schedule, the handler will mark us as Running, 
+		 * otherwise, we'll actually sleep at the schedule()
+		 * I'm going to mark this as TASK_UNINTERRUPTIBLE, as we are
+		 * doing DMA; it would not be good for our buffer to go away.
+		 */
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&dev->des_current_wait, &wait);
+
+		
+		/* Setup up the Busmastering channels, the command will start
+		   as soon as the count gets configured on channel 2 */
+  
+		/* DES to PCI Setup */
+
+		outl(dev->des_handle, dev->ioaddr+REG_BMAR3);	
+		outl(transfercount, dev->ioaddr+REG_BMCR3);
+		
+		
+		/* PCI to DES Setup, once the count is fired I/O commences */
+
+		outl(dev->des_handle, dev->ioaddr+REG_BMAR2);
+		outl(transfercount, dev->ioaddr+REG_BMCR2);	
+
+		
+		/* Wait for completion */
+		timeleft = schedule_timeout(HZ * error_timeout);		
+	  
+		
+		remove_wait_queue(&dev->des_current_wait, &wait);
+		
+		/* 
+		 * If we've timed out it is likely we have some hardware 
+		 * problem
+		 */
+
+		if(!timeleft){
+			printk(KERN_ERR "leedslite: des DMA timeout!\n");		
+			return -EIO;
+		}
+
+
+		if(!dev->des_status){
+		    
+			if(copy_to_user(output+offset, dev->desbuffer, transfercount))
+				return -EFAULT;
+			   
+			bytesleft -= transfercount;
+			offset += transfercount;
+		}
+
+	}
+
+	return 0;	
+} 
+
+
+
+
+
+static int des_execute(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg)
+{
+	ica_des_t *pkt;
+	unsigned int opcode;
+
+	pkt = (ica_des_t *)arg;
+
+	opcode = (pkt->direction == DEVICA_DIR_DES_ENCRYPT) ? DCR_Opcode_DES_Enc : DCR_Opcode_DES_Dec;
+	opcode |= (cmd == ICATDES) ? DCR_TDES : 0;
+	opcode |= (pkt->mode == DEVICA_MODE_DES_ECB) ? DCR_ECB : 0;
+
+
+	/*  Call common (to DES/TDES) worker */
+
+	return des_execute_common(dev,
+							  opcode,
+							  pkt->inputdata,
+							  pkt->outputdata,
+							  pkt->inputdatalength,
+							  pkt->iv,
+							  pkt->keys);
+							  							  
+}
+
+camelot_op_t des_op = {
+	des_verify,
+	des_execute
+};
+
+
+static int desmac_verify(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg){ 
+	ica_desmac_t pkt;
+	int keysize;
+	ica_des_vector_t kiv;
+	ica_des_key_t kkeys[3];
+
+	
+	if(copy_from_user(&pkt, (ica_desmac_t *)arg, sizeof(ica_desmac_t)))
+		return -EFAULT;  
+	
+	if((pkt.inputdatalength > ICA_DES_DATALENGTH_MAX) || (pkt.outputdatalength > ICA_DES_DATALENGTH_MAX))
+		return -EINVAL;
+
+	keysize = (cmd == ICATDES) ? sizeof(ica_des_triple_t) : sizeof(ica_des_single_t);
+
+	if(pkt.outputdatalength < pkt.inputdatalength)
+		return -EINVAL;
+
+	if((pkt.inputdatalength % ICA_DES_DATALENGTH_MIN) != 0)
+		return -EINVAL;
+
+	/* 
+	 * Go ahead and read the iv and key to see if the pointers are good, do
+	 * this by copying to kernel space... the xxx_user macros do all sorts of 
+	 * exception handling magic to return -EFAULT when invalid.   Seems
+	 * easier doing this here than clutter up some of the i/o code. 
+	 */
+
+	if(copy_from_user(&kiv, pkt.iv, sizeof(ica_des_vector_t)))
+		return -EFAULT;
+
+	if(copy_from_user(kkeys, pkt.keys, keysize))
+		return -EFAULT;
+
+	return 0;
+}
+
+
+
+
+/* This routine differs from des_execute_common in that the output buffer is only actually read back out after all input data has been processed */
+
+static int desmac_execute_common(leedslite_dev_t *dev, unsigned int opcode, char *input, char *output, int bytesleft, ica_des_vector_t *iv, ica_des_key_t *keys)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned int timeleft;
+	int offset;
+	int transfercount;
+	int command;
+	int setup, i;
+	u32 loc_buf[ICA_DES_DATALENGTH_MIN/sizeof(u32)];
+
+	setup = 0;
+	offset = 0;
+
+	printk("LEEDS DMAC_COMMON: output: %p\n", output);
+
+	/* Clear out the DES start bit, so the IV will be read. */
+
+	camelot_des_csr_reset(dev);
+
+	while(bytesleft){	
+
+		/*
+		 * If we got a signal, don't continue on.   
+		 */
+
+		if(signal_pending(current)){
+			//printk(KERN_INFO "got signal desmac\n");
+			return -ERESTARTSYS;
+		}
+		
+		
+		transfercount = (bytesleft >= MAX_BUF_SIZE) ? MAX_BUF_SIZE : bytesleft;
+
+		if(copy_from_user(dev->desbuffer, input + offset, transfercount))
+			return -EFAULT;
+		
+		/* Set up the DES Command Register */
+
+		command = opcode | (_dlen(transfercount) << DCR_DLen_SHIFT);
+		command |= DCR_INT_back;
+		
+		outl(command, dev->ioaddr + REG_DCR);	
+		
+		/* 
+		 * Only need to write the keys out once to the Camelot.
+		 * Note: I've already touched the data in the verify routine
+		 * to make sure the pointers are good.
+		 */		
+
+		if(!setup){	
+			camelot_setup_key_regs(dev, opcode, iv, keys);			
+			setup = 1;
+		}
+
+
+		/* Getting ready for the interrupt handler to wake us.
+		 * Pretend we are sleeping, If interrupt handler fires before
+		 * we actually schedule, the handler will mark us as Running, 
+		 * otherwise, we'll actually sleep at the schedule()
+		 * I'm going to mark this as TASK_UNINTERRUPTIBLE, as we are
+		 * doing DMA; it would not be good for our buffer to go away.
+		 */
+
+		set_current_state(TASK_UNINTERRUPTIBLE);	
+		add_wait_queue(&dev->des_current_wait, &wait);
+		
+		
+		/* Setup up the Busmastering channels, the command will start
+		   as soon as the count gets configured on channel 2 */
+  
+		/* PCI to DES Setup, once the count is fired I/O commences */
+
+		outl(dev->des_handle, dev->ioaddr+REG_BMAR2);
+		outl(transfercount, dev->ioaddr+REG_BMCR2);	
+
+		
+		/* Wait for completion */
+		timeleft = schedule_timeout(HZ * error_timeout);
+
+
+		remove_wait_queue(&dev->des_current_wait, &wait);		
+
+		/* 
+		 * If we've timed out it is likely we have some hardware 
+		 * problem
+		 */
+
+		if(!timeleft){
+			printk(KERN_ERR "leedslite: desmac DMA timeout!\n");		
+			return -EIO;
+		}
+
+	   
+		bytesleft -= transfercount;
+		offset += transfercount;
+	}
+
+	for(i=0; i < ICA_DES_DATALENGTH_MIN/sizeof(u32); i++) {
+		loc_buf[i] = readl(dev->window2 + REG_DES_OUT + (i*sizeof(u32)));
+		//loc_buf[i] = __le32_to_cpu(loc_buf[i]);
+	}
+
+	if(copy_to_user(output, loc_buf, ICA_DES_DATALENGTH_MIN))
+		return -EFAULT;
+
+	//if(copy_to_user(output, dev->window2+REG_DES_OUT, ICA_DES_DATALENGTH_MIN))
+	//	return -EFAULT;
+
+
+
+	
+	return 0;	
+} 
+
+
+static int desmac_execute(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg)
+{
+	ica_desmac_t *pkt;
+	unsigned int opcode;
+
+	pkt = (ica_desmac_t *)arg;
+
+	opcode = DCR_Opcode_MAC;
+	opcode |= (cmd == ICATDESMAC) ? DCR_TDES : 0;
+
+
+	/*  Call common (to DES/TDES) worker */
+
+	return desmac_execute_common(dev,
+								 opcode,
+								 pkt->inputdata,
+								 pkt->outputdata,
+								 pkt->inputdatalength,
+								 pkt->iv,
+								 pkt->keys);
+							  							  
+}
+
+
+
+camelot_op_t desmac_op = {
+	desmac_verify, 
+	desmac_execute
+}; 
+
+
+
+static int sha1_verify(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg){ 
+	ica_sha1_t pkt;
+
+	if(copy_from_user(&pkt, (ica_sha1_t *)arg, sizeof(ica_sha1_t)))
+		return -EFAULT;   
+	
+	if((pkt.inputdatalength < ICA_SHA_BLOCKLENGTH) || (pkt.inputdatalength > ICA_DES_DATALENGTH_MAX))
+		return -EINVAL;
+
+	if((pkt.inputdatalength % ICA_SHA_BLOCKLENGTH) != 0)
+		return -EINVAL;
+	
+	
+	return 0;
+}
+
+
+static int sha1_execute_common(leedslite_dev_t *dev, unsigned int opcode, char *input, char *output, int bytesleft, char *initialh)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned int timeleft;
+	int offset;
+	int transfercount;
+	int command;
+	int setup, i, gsra;
+	u32 loc_buf[ICA_SHA_DATALENGTH/sizeof(u32)];
+
+	setup = 0;
+	offset = 0;
+
+	/*
+	 * This does an explicit SHA enable on the card before we
+	 * issue the card the command. Under stress this bit may
+	 * not be set, which would cause incorrect results.
+	 */
+	gsra = readw(dev->window2 + REG_GSRA);
+	gsra |=  CAM_GSRA_SHA_EN;
+	writew(gsra, dev->window2 + REG_GSRA);
+
+	
+	while(bytesleft){	
+
+		/*
+		 * If we got a signal, don't continue on.   
+		 */
+
+		if(signal_pending(current)){
+			//printk(KERN_INFO "got signal sha\n");
+			return -ERESTARTSYS;
+		}
+		
+		transfercount = (bytesleft >= MAX_BUF_SIZE) ? MAX_BUF_SIZE : bytesleft;
+
+		//printk("transfercount: %d\n", transfercount);
+
+		if(copy_from_user(dev->desbuffer, input + offset, transfercount))
+			return -EFAULT;
+	   
+#if 0
+                for(i=0;i<transfercount;i++){
+                      printk("%0x ", *(((unsigned char *)dev->desbuffer) + i));
+                 }
+
+                 printk("\n");
+#endif	
+
+		/* Set up the DES Command Regi(ter */
+
+		
+		command = opcode | (_dlen(transfercount) << DCR_DLen_SHIFT);
+		command |= DCR_INT_back;
+
+		/* 
+		 *  Initialize the H Constants, either to FIPS values or to
+		 *  user input data.   User data is useful for chaining together
+		 *  larger requests.   Only need to do this first time through.
+		 */
+
+		if(!setup){
+			setup = 1;
+
+			if(initialh){
+				/* Copy to an intermediate buffer to make ppc64 happy. - KEY */
+				if(copy_from_user(loc_buf, initialh, ICA_SHA_DATALENGTH))
+					return -EFAULT;
+#if 0
+				printk("initialh: ");
+				   for(i=0;i<ICA_SHA_DATALENGTH;i++){
+				      printk("%0x ", *(((unsigned char *)loc_buf) + i));
+				    }
+
+				  printk("\n");
+#endif
+				for( i = 0; i < ICA_SHA_DATALENGTH/sizeof(u32); i++ ) {
+					loc_buf[i] = __cpu_to_le32(loc_buf[i]);
+					writel(loc_buf[i], dev->window2 + REG_SHA_OUT0 + (i*sizeof(u32)));
+				}
+
+				
+
+				//if(copy_from_user(dev->window2+REG_SHA_OUT0, initialh, ICA_SHA_DATALENGTH))
+				//	return -EFAULT;
+			} else {
+				command |= DCR_init_FIPS;
+			}
+		}
+
+		
+		outl(command, dev->ioaddr + REG_DCR);
+		
+
+		
+		/* Getting ready for the interrupt handler to wake us.
+		 * Pretend we are sleeping, If interrupt handler fires before
+		 * we actually schedule, the handler will mark us as Running, 
+		 * otherwise, we'll actually sleep at the schedule()
+		 * I'm going to mark this as TASK_UNINTERRUPTIBLE, as we are
+		 * doing DMA; it would not be good for our buffer to go away.
+		 */
+	
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&dev->des_current_wait, &wait);
+		
+		
+		/* Setup up the Busmastering channels, the command will start
+		   as soon as the count gets configured on channel 2 */
+  
+		/* PCI to DES Setup, once the count is fired I/O commences */
+
+		outl(dev->des_handle, dev->ioaddr+REG_BMAR2);
+		outl(transfercount, dev->ioaddr+REG_BMCR2);	
+		
+		/* Wait for completion */
+		timeleft = schedule_timeout(HZ * error_timeout);
+
+		/* 
+		 * If we've timed out it is likely we have some hardware 
+		 * problem
+		 */
+
+		if(!timeleft){
+			printk(KERN_ERR "leedslite: sha1 DMA timeout!\n");		
+			return -EIO;
+		}		
+
+		remove_wait_queue(&dev->des_current_wait, &wait);		
+	   
+		bytesleft -= transfercount;
+		offset += transfercount;
+	}
+	
+	//printk("loc_buf: ");
+	/* Read into an intermediate buffer to make ppc64 happy. - KEY */
+	for( i = 0; i < ICA_SHA_DATALENGTH/sizeof(u32); i++ ) {
+		loc_buf[i] = readl(dev->window2 + REG_SHA_OUT0 + (i*sizeof(u32)));
+		loc_buf[i] = __le32_to_cpu(loc_buf[i]);
+	}
+#if 0
+         for(i=0;i<ICA_SHA_DATALENGTH;i++){
+               printk("%0x ", *(((unsigned char *)loc_buf) + i));
+          }
+
+        printk("\n");
+#endif
+
+	if(copy_to_user(output, loc_buf, ICA_SHA_DATALENGTH))
+		return -EFAULT;
+
+
+
+	return 0;	
+} 
+
+static int sha1_execute(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg)
+{
+	ica_sha1_t *pkt;
+	unsigned int opcode;
+
+	pkt = (ica_sha1_t *)arg;
+
+	opcode = DCR_Opcode_SHA;
+
+	/*  Call common (to DES/TDES) worker */
+
+	return sha1_execute_common(dev,
+			    			   opcode,
+							   pkt->inputdata,
+							   (char *)pkt->outputdata,
+							   pkt->inputdatalength,
+							   (char *)pkt->initialh);					  
+						  							  
+}
+
+
+
+camelot_op_t sha_op = {
+	sha1_verify, 
+	sha1_execute
+}; 
+
+
+
+
+
+static int camelot_schedule(leedslite_dev_t *dev, unsigned long cmd, unsigned long arg, camelot_op_t *op)
+{
+	int err=0;
+		
+
+	/* 
+	 * Verify IOCTL packet to see if we are even interested in processing it 
+	 *
+	 */
+
+	err = op->verify(dev, cmd, arg);
+	if(err)
+		goto exit_camelot_schedule;
+	
+	
+	/*
+	 * Stage 1: if there is already a process actively
+	 * waiting for the des engine, wait here for our turn.
+	 */
+
+	
+	err = down_interruptible(&dev->des_wait);
+	if(err){
+		if(err == -EINTR)
+			err = -ERESTARTSYS;
+		goto exit_camelot_schedule;
+	}
+
+		
+		
+	/*
+	 * Stage 2:  We now own the DES engine 
+	 */ 
+
+	err = op->execute(dev, cmd, arg);
+       
+	/* Done;  Wake up next process waiting for the camelot */
+	
+	up(&dev->des_wait);
+
+ exit_camelot_schedule:	
+	return err;	
+}
+
+
+static int rsa_execute_common(leedslite_dev_t *dev, unsigned int opcode, rsa_free_t *free, unsigned int length, char *output)
+{
+	unsigned int command;
+	unsigned int timeleft;
+	DECLARE_WAITQUEUE(wait, current);
+	
+
+	do{
+
+		/*
+		 * If we got a signal, don't continue on.   
+		 */
+
+		if(signal_pending(current)){
+			//printk(KERN_INFO "got signal rsa\n");
+			return -ERESTARTSYS;
+		}
+
+
+		/* Fix up RSA command */
+		
+		command = opcode;
+		command |= _mlen(length) << RCR_MLen_SHIFT;
+		command |= free->index << RCR_OpID_SHIFT;
+		
+
+		/* Getting ready for the interrupt handler to wake us.
+		 * Pretend we are sleeping, If interrupt handler fires before
+		 * we actually schedule, the handler will mark us as Running, 
+		 * otherwise, we'll actually sleep at the schedule()
+		 * I'm going to mark this as TASK_UNINTERRUPTIBLE, as we are
+		 * doing DMA; it would not be good for our buffer to go away.
+		 */
+	
+   
+		free->vfstatus = 0;
+		free->status = 0;
+
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&free->wait, &wait);
+		
+		
+		/* Start the command by writing to the RCR, RSA Command Register */
+		outl(command, dev->ioaddr+REG_RCR);	
+
+		/* Wait for completion */		
+		timeleft = schedule_timeout(HZ * error_timeout);
+
+
+		remove_wait_queue(&free->wait, &wait);
+
+		/* 
+		 * If we've timed out it is likely we have some hardware 
+		 * problem
+		 */
+
+		if(!timeleft){
+			printk(KERN_ERR "leedslite: rsa DMA timeout!\n");		
+			return -EIO;
+		}
+
+	
+	    if(free->status == 0){
+						
+			/* On error, the offending Camelot will be removed as a 
+			 * work candidate by having its RSCR REE bit turned off
+			 * A simple testcase is to use modulus = 0.
+			 */
+			if(free->vfstatus & RSA_VF_ERR_MASK){
+				int id;
+				
+				printk(KERN_ERR "leedslite:  vfifo error = %x\n", free->vfstatus);
+				/* Recover the failing Camelot */
+				
+				id = (free->vfstatus & RSA_VF_CamID) >> 6;
+				
+				/* Camlot got turned off, turn it back on */
+			
+				camelot_reset(dev, id);
+				camelot_rscr_enable_ree(dev, id);
+				if(!(free->vfstatus & RSA_VF_AEF))
+					return -EIO;
+			}
+
+		}
+
+
+		if(free->status & (PIR_MI)){
+			return -EIO;
+		}	
+
+	} while(free->status != 0);
+
+
+	/* No errors, so lets copy the result back out */
+
+	
+	if(copy_to_user(output, (char *)&dev->rop[free->index], length))
+		return -EFAULT;
+
+		
+	return 0;	
+} 
+
+static int rsa_modexpo_verify(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg){ 
+	ica_rsa_modexpo_t pkt;
+
+	if(copy_from_user(&pkt, (ica_rsa_modexpo_t *)arg, sizeof(ica_rsa_modexpo_t)))
+		return -EFAULT;   
+   
+
+	if((pkt.inputdatalength < ICA_RSA_DATALENGTH_MIN) || (pkt.inputdatalength > ICA_RSA_DATALENGTH_MAX))
+		return -EINVAL;
+
+	if((pkt.inputdatalength % ICA_RSA_DATALENGTH_MIN) != 0)
+		return -EINVAL;
+	
+	
+	return 0;
+}
+
+static int rsa_modexpo_execute(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg, rsa_free_t *free)
+{
+   	ica_rsa_modexpo_t *pkt;
+	unsigned int opcode;
+	unsigned char *buffer;
+
+	pkt = (ica_rsa_modexpo_t *)arg;
+	
+	opcode = RCR_Opcode_Mod_Expo;
+	
+	buffer = (char *)&dev->rip[free->index];
+	
+
+	/* Setup Data  */
+	if(copy_from_user(buffer, pkt->inputdata, pkt->inputdatalength))
+		return -EFAULT;
+
+	buffer += pkt->inputdatalength;
+
+
+	/* Setup Input Buffer */
+	if(copy_from_user(buffer, pkt->b_key, pkt->inputdatalength))
+		return -EFAULT;
+
+	buffer += pkt->inputdatalength;
+
+	/* Setup Input Buffer */
+	if(copy_from_user(buffer, pkt->n_modulus, pkt->inputdatalength))
+		return -EFAULT;
+
+	/*  Call common to RSA engine worker */
+
+	return rsa_execute_common(dev,
+							  opcode,
+							  free,
+							  pkt->inputdatalength,
+							  pkt->outputdata);
+							  
+
+	return 0;						  							  
+}
+
+rsa_op_t rsa_modexpo_op = {
+	rsa_modexpo_verify, 
+	rsa_modexpo_execute
+}; 
+
+
+static int rsa_modmult_verify(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg){ 
+	ica_rsa_modmult_t pkt;
+
+	if(copy_from_user(&pkt, (ica_rsa_modmult_t *)arg, sizeof(ica_rsa_modmult_t)))
+		return -EFAULT;   
+	
+
+
+	if((pkt.inputdatalength < ICA_RSA_DATALENGTH_MIN) || (pkt.inputdatalength > ICA_RSA_DATALENGTH_MAX))
+		return -EINVAL;
+
+
+	if((pkt.inputdatalength % ICA_RSA_DATALENGTH_MIN) != 0)
+		return -EINVAL;
+	
+	
+	return 0;
+}
+
+static int rsa_modmult_execute(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg, rsa_free_t *free)
+{
+   	ica_rsa_modexpo_t *pkt;
+	unsigned char *buffer;
+
+	pkt = (ica_rsa_modexpo_t *)arg;
+
+	buffer = (char *)&dev->rip[free->index];
+
+	/* Setup Data  */
+	if(copy_from_user(buffer, pkt->inputdata, pkt->inputdatalength))
+		return -EFAULT;
+
+	buffer += pkt->inputdatalength;
+
+	/* Setup Input Buffer */
+	if(copy_from_user(buffer, pkt->b_key, pkt->inputdatalength))
+		return -EFAULT;
+
+	buffer += pkt->inputdatalength;
+
+	/* Setup Input Buffer */
+	if(copy_from_user(buffer, pkt->n_modulus, pkt->inputdatalength))
+		return -EFAULT;
+
+	/*  Call common to RSA engine worker */
+
+	return rsa_execute_common(dev,
+							  RCR_Opcode_Mod_Mult,
+							  free,
+							  pkt->inputdatalength,
+							  pkt->outputdata);
+							  
+
+	return 0;						  							  
+}
+
+rsa_op_t rsa_modmult_op = {
+	rsa_modmult_verify, 
+	rsa_modmult_execute
+}; 
+
+static int rsa_modexpo_crt_verify(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg){ 
+	ica_rsa_modmult_t pkt;
+
+	if(copy_from_user(&pkt, (ica_rsa_modmult_t *)arg, sizeof(ica_rsa_modmult_t)))
+		return -EFAULT;   
+	
+
+	if((pkt.inputdatalength < ICA_RSA_DATALENGTH_MIN) || (pkt.inputdatalength > ICA_RSA_DATALENGTH_MAX))
+		return -EINVAL;
+
+
+	if((pkt.inputdatalength % ICA_RSA_DATALENGTH_MIN) != 0)
+		return -EINVAL;
+	
+	
+	return 0;
+}
+
+static int rsa_modexpo_crt_execute(leedslite_dev_t *dev, unsigned int cmd, unsigned long arg, rsa_free_t *free)
+{
+   	ica_rsa_modexpo_crt_t *pkt;
+	unsigned char *buffer;
+	unsigned int count;
+
+	pkt = (ica_rsa_modexpo_crt_t *)arg;
+
+	buffer = (char *)&dev->rip[free->index];
+
+	/* Setup Data  */
+	if(copy_from_user(buffer, pkt->inputdata, pkt->inputdatalength))
+		return -EFAULT;
+
+	buffer += pkt->inputdatalength;
+
+	count = pkt->inputdatalength / 2;
+
+	/* Setup Bp */
+	if(copy_from_user(buffer, pkt->bp_key, count+8))
+		return -EFAULT;
+
+	buffer += (count+8);
+
+	/* Setup Bq */
+	if(copy_from_user(buffer, pkt->bq_key, count))
+		return -EFAULT;
+
+	buffer += count;
+
+	/* Setup Np */
+	if(copy_from_user(buffer, pkt->np_prime, count+8))
+		return -EFAULT;
+
+	buffer += count+8;
+	
+	/* Setup Nq */
+	if(copy_from_user(buffer, pkt->nq_prime, count))
+		return -EFAULT;
+
+	buffer += count;
+
+	/* Setup U (Multiplicative Inverse) */
+	if(copy_from_user(buffer, pkt->u_mult_inv, count+8))
+		return -EFAULT;
+
+	
+
+	/*  Call common to RSA engine worker */
+
+	return rsa_execute_common(dev,
+							  RCR_Opcode_Mod_Expo_CRT,
+							  free,
+							  pkt->inputdatalength,
+							  pkt->outputdata);
+							  
+
+	return 0;						  							  
+}
+
+rsa_op_t rsa_modexpo_crt_op = {
+	rsa_modexpo_crt_verify, 
+	rsa_modexpo_crt_execute
+}; 
+
+
+static int rsa_schedule(leedslite_dev_t *dev, unsigned long cmd, unsigned long arg, rsa_op_t *op)
+{
+	int err=0;
+	struct list_head  *entry;
+	rsa_free_t        *free;
+		
+
+	/* 
+	 * Verify IOCTL packet to see if we are even interested in processing it 
+	 *
+	 */
+
+	err = op->verify(dev, cmd, arg);
+	if(err)
+		goto exit_rsa_schedule;
+	
+	
+	
+	/*
+	 * Stage 1:  Wait here for a RIP buffer.   We only let 64 tasks in as
+	 * that is the number of buffers we have.
+	 */
+
+	err = down_interruptible(&dev->rsa_wait);
+	if (err) {
+		if(err == -EINTR)
+			err = -ERESTARTSYS;
+		goto exit_rsa_schedule;
+	}
+	
+		
+	/*
+	 * Stage 2:  We should now be able to grab a free buffer; 
+	 */ 
+
+	if(list_empty(&dev->rsa_freelist_head)){
+		// This should never happen but seems like a good check to have
+		printk(KERN_ERR "leedslite:  rsa_free list is empty!\n");
+	}
+	   
+	entry = dev->rsa_freelist_head.next;
+	
+	/* Remove entry and clean it up for reuse */
+
+	list_del(entry);
+	INIT_LIST_HEAD(entry);
+
+	/* Recover the outter struct */
+
+	free = list_entry(entry, rsa_free_t, freelist);  
+
+	/* Go do the operation according to its type */
+
+	err = op->execute(dev, cmd, arg, free);
+       
+	list_add_tail(&free->freelist, &dev->rsa_freelist_head);
+
+	/* Wake up next process waiting for the camelot */
+	
+	up(&dev->rsa_wait);
+	
+
+ exit_rsa_schedule:	
+	return err;	
+}
+
+
+
+static int ica_ioctl_rsa_modexpo(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return rsa_schedule(dev, cmd, arg, &rsa_modexpo_op);
+}
+
+static int ica_ioctl_rsa_modmult(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return rsa_schedule(dev, cmd, arg, &rsa_modmult_op);
+}
+
+static int ica_ioctl_rsa_modexpo_crt(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return rsa_schedule(dev, cmd, arg, &rsa_modexpo_crt_op);
+}
+
+static int ica_ioctl_des(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{   
+	return camelot_schedule(dev, cmd, arg, &des_op);
+}
+
+static int ica_ioctl_tdes(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return camelot_schedule(dev, cmd, arg, &des_op);
+}
+
+static int ica_ioctl_desmac(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return camelot_schedule(dev, cmd, arg, &desmac_op);
+}
+
+static int ica_ioctl_tdesmac(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return camelot_schedule(dev, cmd, arg, &desmac_op);
+}
+
+static int ica_ioctl_sha1(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	return camelot_schedule(dev, cmd, arg, &sha_op);
+}
+
+static int ica_ioctl_rng(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, leedslite_dev_t *dev)
+{
+	int err;
+	char *buf;
+	int nbytes;
+	ica_rng_t *pkt;
+
+	pkt = (ica_rng_t *)arg;
+
+	/* Verify user access to the ioctl pkt */
+
+	err = get_user(nbytes,  (int *)&pkt->nbytes);
+	if(err)
+		goto err_ioctl_rng;
+
+	err = get_user(buf, (char **)&pkt->buf);
+	if(err)
+		goto err_ioctl_rng;
+
+	/* Verify user access to write to the given buffer */
+
+	if(!access_ok(VERIFY_WRITE, buf, nbytes) || (buf == NULL)){
+		err = -EFAULT;
+		goto err_ioctl_rng;
+	}
+
+	
+	/*
+	 * Simply wrapper the rng's read operation
+	 */
+
+	err = rng_read(filp, buf, nbytes, 0);
+	if(err >= 0){
+		err = put_user(err, (int *)&pkt->nbytes);
+	}
+		
+	
+	
+ err_ioctl_rng:
+	return err;
+}
+
+
+
+static int ica_ioctl_worker(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg, void *private)
+{
+	int rc;
+	leedslite_dev_t *dev = (leedslite_dev_t *)private;
+
+
+
+	
+	switch(cmd){
+	case ICASETBIND:
+		rc = ica_ioctl_setbind(inode, filp, cmd, arg, dev);
+		break;
+	case ICAGETBIND:
+		rc = ica_ioctl_getbind(inode, filp, cmd, arg, dev);
+		break;
+	case ICAGETCOUNT:
+		rc = ica_ioctl_getcount(inode, filp, cmd, arg, dev);
+		break;
+	case ICAGETID:
+		rc = ica_ioctl_getid(inode, filp, cmd, arg, dev);
+		break;
+	case ICARSAMODEXPO:
+		rc = ica_ioctl_rsa_modexpo(inode, filp, cmd, arg, dev);
+		break;
+	case ICARSACRT:
+		rc = ica_ioctl_rsa_modexpo_crt(inode, filp, cmd, arg, dev);
+		break;
+	case ICARSAMODMULT:
+		rc = ica_ioctl_rsa_modmult(inode, filp, cmd, arg, dev);
+		break;
+	case ICADES:
+		rc = ica_ioctl_des(inode, filp, cmd, arg, dev);
+		break;
+	case ICATDES:
+		rc = ica_ioctl_tdes(inode, filp, cmd, arg, dev);
+		break;
+	case ICADESMAC:
+		rc = ica_ioctl_desmac(inode, filp, cmd, arg, dev);
+		break;
+	case ICATDESSHA:
+		rc = -EOPNOTSUPP;
+		break;
+	case ICATDESMAC:
+		rc = ica_ioctl_tdesmac(inode, filp, cmd, arg, dev);
+		break;
+	case ICASHA1:
+		rc = ica_ioctl_sha1(inode, filp, cmd, arg, dev);
+		break;
+	case ICARNG:
+		rc = ica_ioctl_rng(inode, filp, cmd, arg, dev);
+		break;
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+   
+	return rc;
+}
+
+
+static int ica_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	void *private  = (leedslite_dev_t *)filp->private_data;
+	
+	return ica_ioctl_worker(inode, filp, cmd, arg, private);
+}
+
+
+
+static struct file_operations ica_fops = {
+	owner: THIS_MODULE,
+	open: ica_open,
+	release: ica_release,
+	read: rng_read,
+	ioctl: ica_ioctl,
+};
+
+
+static struct ica_operations ica_ops = {
+	read: rng_read_worker,
+	ioctl: ica_ioctl_worker,
+};
+
+
+
+
+static inline void leedslite_soft_reset(leedslite_dev_t *dev)
+{
+	outw(SCR_SORST, dev->ioaddr+REG_SCR);
+	udelay(1);             // Reset needs min 500 ns delay
+	outw(0x0000, dev->ioaddr+REG_SCR);
+}
+
+static inline void leedslite_bmcsr_configure(leedslite_dev_t *dev)
+{
+	int bmcsr;
+
+	bmcsr = 
+		BMCSR_flush_DES_to_PCI_FIFO |
+		BMCSR_flush_PCI_to_DES_FIFO |
+		BMCSR_flush_RSA_to_PCI_FIFO |
+		BMCSR_flush_PCI_to_DES_FIFO;
+
+	if(pmwi)
+		bmcsr |= BMCSR_pMWI_EN;
+
+	outl(bmcsr, dev->ioaddr+REG_BMCSR);
+	udelay(1);             // Reset needs min 500 ns delay
+
+	bmcsr = 
+		BMCSR_D_BM_EN |
+		BMCSR_R_BM_EN;
+
+	outl(bmcsr, dev->ioaddr+REG_BMCSR);
+}
+
+
+static void leedslite_abort_des(leedslite_dev_t *dev, int interrupt)
+{
+	/* Abort current DES */
+	dev->des_status=interrupt;
+	wake_up(&dev->des_current_wait);
+}
+
+static void leedslite_abort_rsa(leedslite_dev_t *dev, int interrupt)
+{
+	int i;
+
+	/* Abort current RSA */
+	for(i=0; i<rsabufs; i++){
+		if(waitqueue_active(&dev->rsa_freelist[i].wait)){
+			dev->rsa_freelist[i].status = interrupt;	
+			wake_up(&dev->rsa_freelist[i].wait);
+		}	
+	}
+}
+
+static int leedslite_init(leedslite_dev_t *dev)
+{
+	int i;
+	int oscr;
+
+	leedslite_soft_reset(dev);
+
+	/* 
+	 * Reset software counter for the the RSA LWP 
+     * Do it here so we don't forget anytime we reset 
+	 * the adapter.   This is duplicate, but will not
+	 * hurt anything.   
+	 */
+
+	dev->lwp = 0;
+
+	/* Configure the adapter with our DMA buffers */
+
+	outl(dev->rip_handle, dev->ioaddr + REG_RIBAR); 		
+	outl(dev->rop_handle, dev->ioaddr + REG_ROBAR);
+	outl(dev->vfifo_handle, dev->ioaddr+REG_VF_BAR);
+
+	
+
+	/* Configure BMCSR - Busmaster Control Register 
+	 * Enable:
+	 * D_BM_EN - DES Busmaster Enable
+	 * R_BM_EN - RSA Busmaster Enable
+	 *
+	 */
+
+	leedslite_bmcsr_configure(dev);
+
+
+	
+	
+
+	/*
+	 * Cycle through each of the Camelot, turning on the RSA
+	 * engines as we go.  We'll go through backwards as we want
+	 * to have the 1st engine, selected via CSV from here on out.
+	 */
+
+	for(i = 5; i>0; i--){
+	
+		
+
+		/* Configure OSCR - Overall Setup and Control 
+		 *
+		 * OSCR_ADSM - DES, etc interrupt.  DISABLE this globally, as we'll
+		 * turn on INT_back in each specific command if needed.
+		 *
+		 * OSCR_CSV_* - Select Camelot * for the CSV
+		 *
+		 * OSCR_SAM - Speed Adjusment Mechanism (power consumption/perf.)
+		 */
+	
+		oscr = i << OSCR_CSV_SHIFT;    // select camelot
+		oscr |= sam << OSCR_SAM_SHIFT; // speed adjustment 
+
+		outw(oscr, dev->ioaddr+REG_OSCR);
+
+		camelot_gcra_enable_rsa(dev);
+		
+	}
+
+	/* Configure RSCR - RSA Setup and Control 
+	 *  RSCR_REE - RSA Engine Enable: enable all engines
+	 *  RSCR_RDLE - RSA Dispatch logic enable
+	 */
+	   
+	outw(RSCR_REE|RSCR_RDLE, dev->ioaddr+REG_RSCR);
+
+
+	/* Configure MIER - Merlin Interrupt Register
+	 *   Configure them all, as Merlin interrupts are catestrophic
+	 */
+	outw(MIER_WRC|MIER_RCRO|MIER_WRL|MIER_WDC|MIER_DCRO, dev->ioaddr+REG_MIER);
+
+	/* Configure PIER - PCI (Piuma) Interrupt Enable Register 
+	 *  Enable:
+	 *  MI - Merlin Interrupts
+	 *  BCZ3 - DES to PCI (DES result)
+     *
+	 * Other interrupts are either handled by the adapter or enabled as
+	 * needed
+	 */
+
+	outw(PIER_MI|PIER_BCZ3|PIER_DSM_done|PIER_RNG_done|PIER_RSA_done, dev->ioaddr+REG_PIER);
+
+	/* The first camelot has some extra setup for rng, des, & sha */
+
+	camelot_enable_cam1(dev);
+
+	return 0;
+}
+
+static void leedslite_channel_reset(leedslite_dev_t *dev, int channel)
+{  
+	int fp, ar, cr, bmcsr, zero, i;
+
+	if((channel == 1) || (channel == 3)){
+		fp = (channel == 1) ? REG_RFP : REG_DFP;
+		ar = (channel == 1) ? REG_BMAR1: REG_BMAR3;
+		cr = (channel == 1) ? REG_BMCR1: REG_BMCR3;
+		bmcsr = (channel == 1) ? BMCSR_R_BM_EN: BMCSR_D_BM_EN;
+		zero  = (channel == 1) ? (1<<26) : (1<<24);
+
+		/* Busmaster Error Recovery procedure */
+
+		leedslite_soft_reset(dev);
+
+
+		/* 
+		 * Set to Alternate Operating Mode, so we can talk BM for the 
+         * RSA channel
+		 */
+
+		outw(SCR_AOM,dev->ioaddr+REG_SCR);
+
+		/* Set up to wrapback */
+			
+		outw(RSCR_RFWB, dev->ioaddr + REG_RSCR);
+
+		/* Write 4 DWORD 0s directly the the FIFO */
+		for(i=0; i<4; i++)
+			outl(0, dev->ioaddr+fp);
+		
+		/* Enable the appropriate BM channel only */
+
+		outl(bmcsr, dev->ioaddr+REG_BMCSR);
+
+		/* 
+		 * Set up the Busmaster Registers, once the count
+		 * is set up the bm will commence 
+		 */
+
+		outl(dev->des_handle, dev->ioaddr+ar);	
+		outl(16, dev->ioaddr+cr);
+
+		/* Hang out waiting for the busmaster count is 0 */
+
+		for(i=0; i<10; i++){
+			bmcsr = inl(dev->ioaddr+REG_BMCSR);
+			if(bmcsr & zero)
+				break;
+			printk(KERN_ERR "leedslite:  bm error recovery waiting!\n");
+			udelay(10);            
+		}
+	
+	}
+
+}
+
+static void leedslite_interrupt_pao(leedslite_dev_t *dev, int interrupt)
+{
+	int pier;
+
+	/* 
+	 * I have not found a way to really test this.   For now, 
+	 * I'll assume the abort is Not catastrophic (though it should
+	 * not happen) and just clear the interrupt.   
+	 */
+
+	/*
+	 * JAG - Verify this with the newest spec and database.  
+	 * Worst case, I probably need to reset the card and restart 
+	 * current requests.
+	 */
+
+	printk(KERN_ERR "leedslite: pci abort occurence\n");
+
+
+	/* First, clear the interrupt condition */
+
+	pier = inw(dev->ioaddr + REG_PIER);
+	pier &= ~PIER_PAO;
+	outw(pier, dev->ioaddr + REG_PIER);
+}
+
+static void leedslite_interrupt_mi(leedslite_dev_t *dev, int interrupt)
+{
+	int pier;
+
+	/* 
+	 * This routine can be tested by setting an invalid RSA modulus
+	 * length (e.g. >8).   
+	 */
+
+	printk(KERN_ERR "leedslite: merlin interrupt\n");
+	
+	/* First, clear the interrupt condition */
+
+	pier = inw(dev->ioaddr + REG_PIER);
+	pier &= ~PIER_MI;
+	outw(pier, dev->ioaddr + REG_PIER);
+
+	/* 
+	 * Reinitialize the card, and restart the current requests for this
+	 * card.
+	 */
+
+	leedslite_init(dev);
+	leedslite_abort_des(dev, interrupt);
+	leedslite_abort_rsa(dev, interrupt);
+
+}
+
+static void leedslite_interrupt_beo(leedslite_dev_t *dev, int interrupt)
+{
+	int bmcsr;
+	int channel;
+	
+	/* 
+	 * I've tested this routine on P-Level hardware which had problems
+	 * and generated busmaster errors.   I can't guarantee that the
+	 * routine will fix all beo errors, but the card does seem to 
+	 * come back to life and is usable from then on out after this
+	 * routine.   Busmaster errors in general Should_Not_Happen, but
+	 * this is the procedure as described by the silicon vendor.  
+	 */
+
+	printk(KERN_ERR "leedslite:  busmaster error occurence\n");
+
+    /* 
+	 * If the busmaster error is on channel 1 or 3 (the write channels)
+	 * a specific error recovery procedure must be followed
+	 */
+	
+	bmcsr = inl(dev->ioaddr + REG_BMCSR);
+	channel = (bmcsr & BMCSR_last_BM) >> BMCSR_last_BM_SHIFT;
+	
+	
+	if((channel == 1) || (channel == 3))
+		leedslite_channel_reset(dev, channel);	
+
+	/* Re-initialize the adapter */
+
+	leedslite_init(dev);
+	
+	/* 
+	 * Restart the current requests... don't worry about RNG as it
+	 * is very resilient and a new Int will fire by re-initializing the
+	 * adapter.
+	 */
+
+	leedslite_abort_des(dev, interrupt);
+	leedslite_abort_rsa(dev, interrupt);
+	
+   
+}
+
+
+
+
+static void leedslite_interrupt_des(leedslite_dev_t *dev, int interrupt)
+{
+	
+	dev->des_status=0;
+	wake_up(&dev->des_current_wait);
+}
+
+static void leedslite_interrupt_rng(leedslite_dev_t *dev, int interrupt)
+{
+	atomic_inc(&dev->entropy_available);
+	wake_up_interruptible(&dev->rng_current_wait);	
+}
+
+
+unsigned long long_reverse( unsigned long x)
+{
+if (bigendian) {
+   return (
+	((0x000000FF & x)<<24) |
+	((0x0000FF00 & x)<<8) |
+	((0x00FF0000 & x)>>8) |
+	((0xFF000000 & x)>>24) );
+} else {
+	return(x);
+}
+}
+
+
+static void leedslite_interrupt_rsa(leedslite_dev_t *dev, int interrupt)
+{
+	int lwp, index, opid;
+	leedslite_vfifo_entry_t status;
+	rsa_free_t             *entry;
+
+	/* 
+	 * Determine the number of buffers that have been completed.  
+	 * Based on the previous lwp (last write pointer); 
+	 */
+		
+	lwp = (interrupt & PIR_LWP) >> 2;
+	index = dev->lwp;
+
+		
+	/* 
+	 * For every completed entry, find its buffer and wake up the task
+	 * waiting for it 
+	 */
+	
+	do {
+		
+		if(index >= LEEDSLITE_VFIFO_ENTRIES)
+			index = 0;
+		
+#if 0
+		status = dev->vfifo[index];
+#else
+		status = long_reverse(dev->vfifo[index]);
+#endif
+		if(status & RSA_VF_VEM){
+			dev->vfifo[index]=0;
+			
+			opid  = (status & RSA_VF_RSAopID) >> 9;
+			
+			entry = &dev->rsa_freelist[opid];
+			entry->vfstatus = status;
+			
+			//printk("wakeup index=%x status=%x\n", opid, status);
+			
+			wake_up(&entry->wait);		
+		} else {
+			printk("leedslite:  VEM not set!! vfindex=%x\n", index);
+		}
+			
+	} while (index++ != lwp);
+	
+	/* 
+	 * Keep track where we left off 
+	 */
+
+	dev->lwp = index;	
+}
+
+static irqreturn_t 
+leedslite_interrupt(int irq, void *instance, struct pt_regs *regs)
+{
+	leedslite_dev_t *dev = instance;
+	int interrupt;
+	
+
+	interrupt = inw(dev->ioaddr+REG_PIR);
+	
+
+	/* PCI Abort Occurence */
+
+	if(interrupt & PIR_PAO){
+		leedslite_interrupt_pao(dev, interrupt);
+	}
+
+	/* Merlin Interrupt (Error) */
+
+	if(interrupt & PIR_MI){
+		leedslite_interrupt_mi(dev, interrupt);
+	}
+
+	/* Busmaster Error Occured */
+
+	if(interrupt & PIR_BEO){
+		leedslite_interrupt_beo(dev, interrupt);
+		goto out;
+	}
+
+
+	/* 
+	 * Des Engine completed operation 
+	 *   DSM_done for SHA/DESMAC or
+	 *   BCZ3 for DES with busmastered DMA
+	 */
+	
+	 if(interrupt & (PIR_DSM_done|PIR_BCZ3))
+		 leedslite_interrupt_des(dev, interrupt);
+
+	 /* Random Number Generator data ready */
+
+	 if(interrupt & PIR_RNG_done)
+		 leedslite_interrupt_rng(dev, interrupt);
+	
+	 /* RSA operation(s) completed */
+
+	if(interrupt & PIR_RSA_done) 
+		leedslite_interrupt_rsa(dev, interrupt);
+	
+out:
+	return IRQ_HANDLED;
+}
+
+
+
+
+static int __exit leedslite_shutdown (leedslite_dev_t *dev)
+{
+	return 0;
+}
+
+static int __devinit leedslite_init_one (struct pci_dev *pdev,
+                const struct pci_device_id *ent, leedslite_dev_t **data)
+{
+	leedslite_dev_t *dev;
+	leedslite_dev_t **slot;
+	int i, err, slotnum;
+	
+	/*
+     * This driver supports 'maxdevices'.   We'll map devices to 
+     * nodes by the order that we find them.   If a hole, or slot 
+     * were to open up (by the removal of a device).  We'll map the 
+     * next discovered device back into that slot.   It is possible
+     * that someday we may want to even keep a unique adapter ID.  
+     * However, below works for the foreseeable future.  
+     * 
+	 */
+
+	
+	dev = kmalloc(sizeof(leedslite_dev_t), GFP_KERNEL);
+	if(!dev){
+		printk(KERN_ERR "leedslite_init_one: out of memory\n");
+		err = -ENOMEM;
+		goto err_init_one;
+	}
+	memset(dev, 0, sizeof(leedslite_dev_t));
+	
+	slot = NULL;
+	slotnum = 0;
+
+	for(i=0; i<maxdevices; i++){
+		if(devices[i]== NULL){
+			slot = &devices[i];
+			slotnum = i;
+			break;
+		}
+	}
+
+	if(!slot){
+		printk(KERN_ERR "leedslite_init_one: no more device structures\n");
+		err  = -ENOMEM;
+		goto err_init_one_slot;
+	}
+	
+	*slot = dev;
+	
+	/* 
+	 * Initialize wait queues needed by the various operations 
+	 */
+
+	
+	init_waitqueue_head(&dev->rng_current_wait);
+	
+	sema_init(&dev->des_wait, 1); 
+	init_waitqueue_head(&dev->des_current_wait);
+	
+	
+	sema_init(&dev->rsa_wait, rsabufs); 
+
+
+	/* SAB endian adjustment */
+	bigendian = isbigendian();
+
+
+	/* 
+	 * Start allocating the various DMA buffers used by RSA.   
+	 * rip - RSA Input
+	 * rop - RSA Output
+	 * vfifo - RSA Virtual Fifo (status)
+	 * 
+	 * Note: for DES operations we'll pin down the buffers as needed.
+	 */
+
+	
+	dev->rip = pci_alloc_consistent(pdev, rsabufs * RIP_ENTRY_SIZE, &dev->rip_handle);
+	if(!dev->rip){
+		assertk(dev->rip);
+		err = -ENOMEM;
+		goto err_init_one_rip;
+	}
+	
+	
+	dev->rop = pci_alloc_consistent(pdev, rsabufs * ROP_ENTRY_SIZE, &dev->rop_handle);
+	if(!dev->rop){
+		assertk(dev->rop);		
+		err = -ENOMEM;
+		goto err_init_one_rop;
+	}
+
+
+	dev->vfifo = pci_alloc_consistent(pdev, LEEDSLITE_VFIFO_ENTRIES * VFIFO_ENTRY_SIZE, &dev->vfifo_handle);
+	if(!dev->vfifo){
+		printk(KERN_ERR "leedslite_init_one: unable to allocate vfifo buffer\n");
+		err = -ENOMEM;
+		goto err_init_one_vfifo;
+	}
+
+	dev->desbuffer = pci_alloc_consistent(pdev, desbuffersize, &dev->des_handle);
+	if(!dev->desbuffer){
+		printk(KERN_ERR "leedslite_init_one: unable to allocate vfifo buffer\n");
+		err = -ENOMEM;
+		goto err_init_one_des;
+	}
+
+	/* 
+	 * Intialize the vfifo previous word pointer (pwp).   Allows
+	 * us to keep track of how many vfifo statuses are ready by
+	 * comparing this to the lwp (last word pointer) reported by the
+	 * PIR 
+	 */
+
+	dev->lwp = 0;
+
+	/*
+     * Multiple pending RSA operations can be sent to the adapter.   We
+     * need to be able to tell which RSA data structures are currently in 
+	 * use.   rsa_freelist is used for this purpose. 
+	 */
+
+	dev->rsa_freelist = kmalloc(sizeof(rsa_free_t) * rsabufs, GFP_KERNEL);
+	if(!dev->rsa_freelist){
+		err = -ENOMEM;
+		goto err_init_one_freelist;
+	}
+
+	INIT_LIST_HEAD(&dev->rsa_freelist_head);
+	for(i=0; i<rsabufs; i++){
+		INIT_LIST_HEAD(&dev->rsa_freelist[i].freelist);
+		dev->rsa_freelist[i].index = i;
+		init_waitqueue_head(&dev->rsa_freelist[i].wait);
+		list_add_tail(&dev->rsa_freelist[i].freelist, &dev->rsa_freelist_head);
+	}
+
+	/* 
+	 * Leedslite has 3 PCI I/O resources
+	 *  resource 0 - io port region (various Merlin/Piuma registers)
+	 *  resource 1 - mem-mapped region (SRAM key storage)
+	 *  resource 2 - mem-mapped region (currenly selected Camelot registers)
+	 */
+
+	err = -ENODEV;
+	if (!request_region(pci_resource_start(pdev, 0),
+			pci_resource_len(pdev, 0), "leedslite")) {
+		printk (KERN_ERR "leedslite: cannot reserve I/O ports\n");
+		goto err_init_one_pci_reserve_0;
+	}
+
+	if (!request_mem_region(pci_resource_start(pdev, 1),
+			pci_resource_len(pdev, 1), "leedslite")) {
+		printk (KERN_ERR "leedslite: cannot reserve MMIO region\n");
+		goto err_init_one_pci_reserve_1;
+	}
+
+	if (!request_mem_region(pci_resource_start(pdev, 2),
+			pci_resource_len(pdev, 2), "leedslite")) {
+		printk (KERN_ERR "leedslite: cannot reserve MMIO region\n");
+		goto err_init_one_pci_reserve_2;
+	}
+	
+	if (pci_enable_device(pdev))
+		goto err_init_one_pci_enable;
+
+	dev->irq = pdev->irq;
+	dev->ioaddr = pci_resource_start(pdev, 0);
+	dev->window1 = ioremap(pci_resource_start(pdev, 1), 
+						   pci_resource_len(pdev, 1));
+	if (!dev->window1){
+		printk(KERN_ERR "leedslite: cannot remap window 1\n");
+		goto err_init_one_window1_remap;
+	}
+
+	dev->window2 = ioremap(pci_resource_start(pdev, 2), 
+						   pci_resource_len(pdev, 2));
+	if (!dev->window2){
+		printk(KERN_ERR "leedslite: cannot remap window 2\n");
+		goto err_init_one_window2_remap;
+	}
+	
+	pci_set_master(pdev);
+	
+
+	/* 
+	 * Let's set up the interrupt handler, just in case banging on the ports
+	 * inadvertantly triggers an interrupt.   
+	 */
+	err = request_irq(dev->irq, leedslite_interrupt, SA_SHIRQ, "leedslite", dev);
+	if (err){
+		printk(KERN_ERR "leedslite: unable to request irq\n");
+		goto err_init_one_irq;
+	}
+
+	/* 
+	 * Finally, go set up the adapter.
+	 */
+
+	err = leedslite_init(dev);
+	
+
+	if (err){
+		goto err_init_one_adapter_init;
+	}
+
+	/* 
+	 * Register our entries under /dev/leedslite 
+	 */
+
+	devfs_mk_cdev(MKDEV(driver_major,slotnum), S_IRUGO|S_IWUGO|S_IFCHR,
+		"leedslite/ica%d", slotnum);
+	dev->minor = slotnum;
+
+	/*  
+     * Autoregister with /dev/ica if configured so.   The devica
+	 * driver provides a virtual ica interface to spread the 
+	 * crypto operations across multiple cards.   This is the
+     * default behavior unless the 'devica=0' option is set.
+     */
+
+	if (devica) {
+
+		dev->icareg.icaops = &ica_ops;
+		dev->icareg.private_data = dev;
+		
+		if (ica_register_worker(0, &dev->icareg)){
+			dev->bind = -1;
+		} else {
+			dev->bind = 0;
+		}
+	}
+	
+	dev->pdev = pdev;
+	*data = dev;
+
+	printk(KERN_INFO "%s: Init Success\n", version);
+	
+	return 0;
+ 
+
+ err_init_one_adapter_init:
+	free_irq(dev->irq, dev);
+ err_init_one_irq:
+	iounmap(dev->window2);
+ err_init_one_window2_remap:
+	iounmap(dev->window1);
+ err_init_one_window1_remap:
+ err_init_one_pci_enable:
+	release_mem_region(pci_resource_start(pdev,2), pci_resource_len(pdev,2));
+ err_init_one_pci_reserve_2:
+	release_mem_region(pci_resource_start(pdev,1), pci_resource_len(pdev,1));
+ err_init_one_pci_reserve_1:
+	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
+ err_init_one_pci_reserve_0:
+ err_init_one_freelist:
+	pci_free_consistent(pdev, desbuffersize, dev->desbuffer, dev->des_handle);
+ err_init_one_des:
+	pci_free_consistent(pdev, LEEDSLITE_VFIFO_ENTRIES * VFIFO_ENTRY_SIZE, dev->vfifo, dev->vfifo_handle);
+ err_init_one_vfifo:
+	pci_free_consistent(pdev, rsabufs * ROP_ENTRY_SIZE, dev->rop, dev->rop_handle);
+ err_init_one_rop:
+	pci_free_consistent(pdev, rsabufs * RIP_ENTRY_SIZE, dev->rip, dev->rip_handle); 
+ err_init_one_rip:
+ err_init_one_slot:
+	kfree(dev);
+ err_init_one:
+	return err;
+
+
+}
+
+static int __devinit leedslite_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{ 
+	int rc;
+	leedslite_dev_t *dev;
+
+	rc = leedslite_init_one(pdev, ent, &dev);
+
+	/* This may look highly unusual.. For single source compatibility
+	 * I've added a list to the dev structure and am stringing
+	 * all the devices together so I can duplicate the pci probe/remove
+	 * behavior.   Since the old pci_dev does not have a place to store
+	 * drvdata I'll wrapper the drvdata with a list element.  I can
+	 * retrieve it while calling pci_driver->probe .. 
+	 * See devicacompat.h for magic 
+	 */
+
+	INIT_LIST_HEAD(&dev->node);
+	list_add_tail(&dev->node, &devicelist); 
+
+	pci_set_drvdata(pdev, dev);
+
+	return rc;
+}
+
+
+static void __devexit leedslite_remove_one (struct pci_dev *pdev, leedslite_dev_t *data)
+{  
+	leedslite_dev_t *dev;
+	int rc, i;
+	
+
+	dev = data;
+
+	if (!dev)
+		return;
+
+	rc = ica_unregister_worker(0, &dev->icareg);
+	
+
+	free_irq(dev->irq, dev);
+	leedslite_shutdown(dev);
+	
+	iounmap(dev->window1);
+	iounmap(dev->window2);
+
+	release_mem_region(pci_resource_start(pdev,2), pci_resource_len(pdev,2));
+	release_mem_region(pci_resource_start(pdev,1), pci_resource_len(pdev,1));
+	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
+
+
+	for(i=0; i<maxdevices; i++){
+		if (devices[i] == dev){
+			devices[i] = NULL;
+			break;
+		}
+	}
+	
+	
+	devfs_remove("leedslite/ica%u", dev->minor);
+
+	pci_free_consistent(pdev, desbuffersize, dev->desbuffer, dev->des_handle);
+	pci_free_consistent(pdev, rsabufs * RIP_ENTRY_SIZE, dev->rip, dev->rip_handle);
+	pci_free_consistent(pdev, rsabufs * ROP_ENTRY_SIZE, dev->rop, dev->rop_handle);
+	pci_free_consistent(pdev, LEEDSLITE_VFIFO_ENTRIES * VFIFO_ENTRY_SIZE, dev->vfifo, dev->vfifo_handle);
+	kfree(dev->rsa_freelist);
+
+}
+
+static void __devexit leedslite_remove (struct pci_dev *pdev)
+{
+	leedslite_dev_t *dev;
+	struct list_head *pos;
+
+
+	dev = NULL;
+
+	/* More compatibility magic.. 2.2 does not have drv_data, so
+	 * to emulate the probe/remove when running on 2.2 I'll keep the
+	 * device specific data all linked together... I can go find
+	 * the correct drv_data by comparing the pci_dev.  On 2.4+ I
+	 * would not need to do this, but I might as well keep the 
+	 * code common.   
+	 */
+	
+	list_for_each(pos, &devicelist){
+		dev = list_entry(pos, leedslite_dev_t, node);
+		
+		if (dev->pdev == pdev) {
+			list_del(pos);
+			break;
+		} else {
+			dev = NULL;
+		}
+	}
+    
+	if (dev)
+		leedslite_remove_one(pdev, dev);
+}
+
+
+static struct pci_device_id leedslite_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_LEEDSLITE,
+	  PCI_ANY_ID, PCI_ANY_ID,},
+	{ 0,}
+};
+
+MODULE_DEVICE_TABLE(pci, leedslite_pci_tbl);
+
+
+static struct pci_driver leedslite_driver = { \
+	name:           "leedslite", \
+	id_table:       leedslite_pci_tbl,\
+	probe:          leedslite_probe, \
+	remove:         leedslite_remove, \
+};
+
+
+int __init leedslite_driver_init(void)
+{
+	int rc;
+
+	rc = register_chrdev(driver_major, "leedslite", &ica_fops);
+
+	if (rc < 0) {
+		goto err_init;
+	} 
+
+	if (driver_major == 0) 
+		driver_major = rc;
+
+	devfs_mk_dir("leedslite");
+
+	if (desbuffersize < ICA_DES_DATALENGTH_MIN)
+		desbuffersize = DESBUFFER_SIZE;
+
+	if ((rsabufs <= 0) || (rsabufs > LEEDSLITE_VFIFO_ENTRIES))
+	   rsabufs = LEEDSLITE_VFIFO_ENTRIES;
+	
+	if ((sam < SAM_MIN) || (sam > SAM_MAX))
+		sam = SAM_MIN;
+
+	if (pmwi != 1)
+		pmwi = 0;
+
+	if (error_timeout < LEEDSLITE_ERR_TIMEOUT_MIN)
+		error_timeout = LEEDSLITE_ERR_TIMEOUT_MIN;
+	
+	devices = kmalloc(sizeof(leedslite_dev_t *) * maxdevices, GFP_KERNEL);
+
+	if (!devices){
+		rc = -ENOMEM;
+		goto err_init_mem;
+	}
+
+	memset(devices, 0, sizeof(leedslite_dev_t *) * maxdevices);
+	  
+
+	INIT_LIST_HEAD(&devicelist);
+	
+	rc = pci_module_init(&leedslite_driver);
+	
+	if (rc < 0){
+		goto err_init_pci;
+	}
+	
+	return 0;
+
+ err_init_pci:
+	kfree(devices);
+ err_init_mem:
+ 	devfs_remove("leedslite");
+	unregister_chrdev(driver_major, "leedslite");
+ err_init:
+	return rc;
+}
+
+static int __init leedslite_init_module(void)
+{
+	return leedslite_driver_init();
+}
+
+static void __exit leedslite_cleanup_module(void)
+{
+	pci_unregister_driver(&leedslite_driver);
+	unregister_chrdev(driver_major, "leedslite");
+	kfree(devices);		
+}
+
+
+#ifdef MODULE
+
+MODULE_AUTHOR("Jon Grimm <jgrimm@us.ibm.com>");
+MODULE_DESCRIPTION("IBM Crypto Adapter (Leedslite)");
+MODULE_PARM(maxdevices, "i");
+MODULE_PARM(devica, "i");
+MODULE_PARM(desbuffersize, "i");
+MODULE_PARM(rsabufs, "i");
+MODULE_PARM(sam, "i");
+MODULE_PARM(pmwi, "i");
+MODULE_PARM(driver_major, "i");
+MODULE_PARM(error_timeout, "i");
+
+#endif /* MODULE */
+
+
+module_init(leedslite_init_module);
+module_exit(leedslite_cleanup_module);
+
+
+/*
+ * Local variables:
+ *  compile-command: "gcc -g -DMODULE -D__KERNEL__  -Wall -Wstrict-prototypes -O6 -c leedslite.c `[ -f /usr/include/linux/modversions.h ] && echo -DMODVERSIONS`"
+ *  c-indent-level: 4
+ *  c-basic-offset: 4
+ *  tab-width: 4
+ * End:
+ */
diff -urN linux-2.6.0-test9/drivers/ibmcrypto/leedslite/leedslite.h linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/leedslite.h
--- linux-2.6.0-test9/drivers/ibmcrypto/leedslite/leedslite.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/leedslite.h	2004-01-07 11:21:36.000000000 -0600
@@ -0,0 +1,279 @@
+/* drivers/char/leedslite.h: header for LeedsLite IBM Crypto Adapter driver for Linux. */
+/* Copyright (c) International Business Machines Corp., 2001 */
+
+#ifndef _LEEDSLITE_H_
+#define _LEEDSLITE_H_
+
+#ifndef PCI_VENDOR_ID_IBM
+#define PCI_VENDOR_ID_IBM 0x1014
+#endif
+
+#ifndef PCI_DEVICE_ID_IBM_LEEDSLITE
+#define PCI_DEVICE_ID_IBM_LEEDSLITE 0x01e6
+#endif
+
+
+typedef char leedslite_rip_entry_t[1024];
+typedef char leedslite_rop_entry_t[256];
+typedef u32 leedslite_vfifo_entry_t;
+
+/* Note: VFIFO is always 64 entries! */
+
+#define LEEDSLITE_VFIFO_ENTRIES 64
+#define RIP_ENTRY_SIZE sizeof(leedslite_rip_entry_t)
+#define ROP_ENTRY_SIZE sizeof(leedslite_rop_entry_t) 
+#define VFIFO_ENTRY_SIZE sizeof(leedslite_vfifo_entry_t)
+
+enum leedslite_bar0_registers {
+  REG_BMAR0 = 0x00,
+  REG_BMCR0 = 0x04,
+  REG_BMAR1 = 0x08,
+  REG_BMCR1 = 0x0C,
+  REG_BMAR2 = 0x10,
+  REG_BMCR2 = 0x14,
+  REG_BMAR3 = 0x18,
+  REG_BMCR3 = 0x1C,
+  REG_RFP   = 0x20,
+  REG_DFP   = 0x24,
+  REG_BMCSR = 0x28,
+  REG_PIR = 0x2C,
+  REG_PIER = 0x30,
+  REG_SCR = 0x34,
+  REG_RIBAR = 0x40,
+  REG_ROBAR = 0x44,
+  REG_VF_BAR = 0x48,
+  REG_RCR = 0x4C,
+  REG_RSCR = 0x50,
+  REG_RSR = 0x54,
+  REG_DCR = 0x58,
+  REG_OSCR = 0x5C,
+  REG_MIR = 0x60,
+  REG_MIER = 0x64
+};
+
+enum leedslite_sha_key_control_bits {
+  SHA_KEY_CONTROL_SET_H = 0x0002,
+  SHA_KEY_CONTROL_SET_K = 0x0001
+};
+
+enum leedslite_window2_registers {
+  REG_CAM_RCR   = 0x00000,
+  REG_DES_OUT   = 0x01110,
+  REG_DES_IV    = 0x01118,
+  REG_DES_KEY_1 = 0x01120,
+  REG_DES_KEY_2 = 0x01128,
+  REG_DES_KEY_3 = 0x01130,
+  REG_DES_CSR   = 0x01138,
+  REG_GSR  = 0x1144,
+  REG_GSRA = 0x1146,
+  REG_GCR  = 0x1148,
+  REG_SHA_STATUS = 0x1800,
+  REG_SHA_KEY_CONTROL = 0x1802,
+  REG_SHA_IN1 = 0x1804,
+  REG_SHA_IN2 = 0x1806,
+  REG_SHA_K0 = 0x1808,
+  REG_SHA_K1 = 0x180c,
+  REG_SHA_K2 = 0x1810,
+  REG_SHA_K3 = 0x1814,
+  REG_SHA_OUT0 = 0x1818,
+  REG_SHA_OUT1 = 0x181C,
+  REG_SHA_OUT2 = 0x1820,
+  REG_SHA_OUT3 = 0x1824,
+  REG_SHA_OUT4 = 0x1828,
+  REG_RNG = 0x1c00
+};
+
+enum leedslite_camelot_gcra_bits {
+  CAM_GCRA_RSA_Enable = 0x1000
+};
+
+enum leedslite_camelot_gsr_bits {
+  CAM_GSR_DES_EN = 0x0400
+};
+
+enum leedslite_camelot_gsra_bits {
+  CAM_GSRA_RNGSpd0 = 0x0100,
+  CAM_GSRA_RNGSpd1 = 0x0200,
+  CAM_GSRA_RNGSpd2 = 0x0400,
+  CAM_GSRA_RNG_INT_EN = 0x0800,
+  CAM_GSRA_SHA_EN = 0x1000 
+};
+
+enum leedslite_camelot_descsr {
+  CAM_DESCSR_START = 0x2000
+};
+
+enum leedslite_camelot_rcr_bits {
+  CAM_RCR_COMPLETE = 0x0001
+};
+
+enum leedslite_rcr_bits {
+  RCR_Opcode_Mod_Mult     = 0x20000000,
+  RCR_Opcode_Mod_Expo     = 0x40000000,
+  RCR_Opcode_Mod_Expo_CRT = 0x80000000
+};
+
+enum leedslite_rcr_shift {
+  RCR_MLen_SHIFT = 20,
+  RCR_OpID_SHIFT = 11
+};
+
+
+enum leedslite_rscr_bits {
+  RSCR_Merlin_ID = 0x000f,
+  RSCR_flsh_outFF = 0x0010,
+  RSCR_flsh_inFF = 0x0020,
+  RSCR_SSP = 0x00C0,
+  RSCR_REE = 0x1f00,
+  RSCR_RDLE = 0x4000,
+  RSCR_RFWB = 0x8000
+};
+
+enum leedslite_oscr_bits {
+  OSCR_Cam_RST = 0x001f,
+  OSCR_CSV = 0x00E0,    
+  OSCR_CSV_1 = 0x0020,  // Camelot 1
+  OSCR_CSV_2 = 0x0040,  // Camelot 2 
+  OSCR_CSV_3 = 0x0060,  // Camelot 3
+  OSCR_CSV_4 = 0x0080,  // Camelot 4
+  OSCR_CSV_5 = 0x00A0,  // Camelot 5
+  OSCR_ADSM = 0x0100,   // Always DSM_done Int.
+  OSCR_SAM = 0xFE00     // Speed Adjustment Mechanism
+};
+
+enum leedslite_oscr_shift {
+  OSCR_CSV_SHIFT = 5,
+  OSCR_SAM_SHIFT = 9
+};
+
+enum leedslite_sam_limits {
+  SAM_MIN = 0x00,  // Maximum performance/power
+  SAM_MAX = 0x3f   // Minimum performance/power
+};
+
+enum leedslite_mier_bits {
+  MIER_WRC = 0x0001,
+  MIER_RCRO = 0x0002,
+  MIER_WRL = 0x0004,
+  MIER_WDC = 0x0040,
+  MIER_DCRO = 0x080
+};
+
+
+enum leedslite_pir_bits {
+  PIR_RSA_done = 0x0001, 
+  PIR_BEO = 0x0002,
+  PIR_LWP = 0x00fc,
+  PIR_PAO = 0x0100,
+  PIR_BCZ0 = 0x0200,
+  PIR_BCZ1 = 0x0400,
+  PIR_BCZ2 = 0x0800,
+  PIR_BCZ3 = 0x1000,
+  PIR_DSM_done = 0x2000,
+  PIR_RNG_done = 0x4000,
+  PIR_MI = 0x8000
+};
+
+enum leedslite_pier_bits {
+  PIER_RSA_done = 0x0001, 
+  PIER_BEO = 0x0002,
+  PIER_PAO = 0x0100,
+  PIER_BCZ0 = 0x0200,
+  PIER_BCZ1 = 0x0400,
+  PIER_BCZ2 = 0x0800,
+  PIER_BCZ3 = 0x1000,
+  PIER_DSM_done = 0x2000,
+  PIER_RNG_done = 0x4000,
+  PIER_MI = 0x8000
+};
+
+enum leedslite_scr_bits {
+  SCR_Piuma_ID = 0x000f,
+  SCR_VPDWP = 0x2000,
+  SCR_AOM = 0x4000,
+  SCR_SORST = 0x8000
+};
+
+
+enum leedslite_rsa_vf_bits {
+  RSA_VF_ROC = 0x0001,
+  RSA_VF_RZF = 0x0002,
+  RSA_VF_RCF = 0x0004,
+  RSA_VF_RAF = 0x0008,
+  RSA_VF_CEF = 0x0010,
+  RSA_VF_AEF = 0x0020,
+  RSA_VF_CamID = 0x01C0,
+  RSA_VF_RSAopID = 0x7e00,
+  RSA_VF_VEM = 0x8000,
+  RSA_VF_ERR_MASK = RSA_VF_RZF|RSA_VF_RCF|RSA_VF_RAF|RSA_VF_CEF|RSA_VF_AEF
+};
+
+enum leedslite_bmscr_bits {
+  BMCSR_DES_BM_priority = 0x00000003,
+  BMCSR_DES_BM_priority_equal = 0x00000000,
+  BMCSR_DES_BM_priority_WR = 0x00000002,
+  BMCSR_DES_BM_priority_RD = 0x00000003,
+  BMCSR_RSA_BM_priority = 0x0000000C,
+  BMCSR_RSA_BM_priority_equal = 0x00000000,
+  BMCSR_RSA_BM_priority_WR = 0x00000008,
+  BMCSR_RSA_BM_priority_RD = 0x0000000C,
+  BMCSR_BM_channel_priority = 0x00000030,
+  BMCSR_BM_channel_priority_equal = 0x00000000,
+  BMCSR_BM_channel_priority_WR = 0x00000020,
+  BMCSR_BM_channel_priority_RD = 0x00000030,
+  BMCSR_D_BM_EN = 0x00000040,
+  BMCSR_R_BM_EN = 0x00000080,
+  BMCSR_flush_DES_to_PCI_FIFO = 0x00000400,
+  BMCSR_flush_PCI_to_DES_FIFO = 0x00000800,
+  BMCSR_flush_RSA_to_PCI_FIFO = 0x00001000,
+  BMCSR_flush_PCI_to_RSA_FIFO = 0x00002000,
+  BMCSR_pMWI_EN = 0x00008000,
+  BMCSR_last_BM = 0x00C00000
+};
+
+enum leedslite_bmcsr_shift {
+  BMCSR_last_BM_SHIFT = 22
+};
+
+enum leedslite_dcr_bits {
+  DCR_IVin = 0x00000001,
+  DCR_Kin  = 0x00000002,
+  DCR_K_Index   = 0x000003FC,
+  DCR_INT_back  = 0x00000400,
+  DCR_init_FIPS = 0x00000800,
+  DCR_DLen   = 0x03FFF000,
+  DCR_TDES   = 0x04000000,
+  DCR_ECB    = 0x08000000,
+  DCR_Opcode = 0xF0000000,
+  DCR_Opcode_DES_Enc       = 0x00000000,
+  DCR_Opcode_DES_Dec       = 0x10000000,
+  DCR_Opcode_SHA           = 0x40000000,
+  DCR_Opcode_DESSHA_Enc    = 0x60000000,
+  DCR_Opcode_DESSHA_Dec    = 0x70000000,
+  DCR_Opcode_DES2SHA_1_Enc = 0x80000000,
+  DCR_Opcode_DES2SHA_1_Dec = 0x90000000,
+  DCR_Opcode_DES2SHA_2_Enc = 0xA0000000,
+  DCR_Opcode_DES2SHA_2_Dec = 0xB0000000,
+  DCR_Opcode_MAC           = 0xC0000000  
+};
+
+enum leedslite_dcr_shift {
+  DCR_DLen_SHIFT = 12
+}; 
+
+enum leedslite_err_limits {
+   LEEDSLITE_ERR_TIMEOUT_MIN = 60
+};
+
+static inline int _dlen(int length)
+{
+  return (length / ICA_DES_DATALENGTH_MIN);
+}
+
+static inline int _mlen(int length)
+{
+  return (length / ICA_RSA_DATALENGTH_MIN);
+}
+
+
+#endif /* _LEEDLITE_H_ */
diff -urN linux-2.6.0-test9/drivers/ibmcrypto/leedslite/leedslite.txt linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/leedslite.txt
--- linux-2.6.0-test9/drivers/ibmcrypto/leedslite/leedslite.txt	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/drivers/ibmcrypto/leedslite/leedslite.txt	2004-01-07 11:21:36.000000000 -0600
@@ -0,0 +1,446 @@
+IBM e-business Cryptographic Accelerator, AKA Leedslite
+
+Leedslite DD for Linux kernel README
+Copyright (c) Internation Business Machines Corp., 2001
+Author: Jon Grimm
+
+
+IBM e-business Cryptographic Accelerator (ICA)
+
+	Leedslite was the internal name for the ICA Adapter.  
+	ICA is a PCI based cryptographic accelerator.   The adapter 
+provides the following functionality:
+	RSA - CRT and non-CRT, 256-2048 bit key lengths
+	DES - CBC & ECB Modes
+	TDES (EDE) - CBC & ECB Modes
+	SHA1 - secure hash
+	Random Number Generation
+
+
+	The main controllers are on the ICA adapter are:
+	Merlin - crypto controller
+	Piuma - PCI interface
+	Five UltraCyphers - crypto processors
+
+
+	To program the Leedslite DD the following resources were consulted:
+	Leedslite Adapter Functional Specification
+	IBM UltraCypher Cryptographic Engine Specification  
+	Applied Cryptography, Second Edition, by Bruce Schneier
+
+	The ICA adapter is currently marketed as an Option for the IBM
+	RS/6000 (TM).  
+
+Driver Design
+
+	The Leedslite driver is really divided into two components, devica and 
+leedslite.   Not suprisingly, their respective source code lies in 'devica.c'
+and 'leedslite.c'.  The drivers are compilable statically into the kernel
+or as dynamically loadable kernel modules.
+
+	The leedslite module is the driver for the "physical adapter".   The 
+devica module provides the function of a "virtual adapter" where multiple 
+leedslite physical adapters can hide be hidden.   Work can be distributed
+across the registered leedslite instances by the devica component.    
+
+	NOTE:  Here are some up-front warnings:   This driver has only been
+tested on i386 (32-bit) uni platforms with no DEVFS support.  There has 
+been some limited testing on an 2-way smp box with no apparent I/O problems.  
+Porting to other platforms is greatly desired, but is certainly limited in
+that this is mostly an OEM-able adapter from IBM.   With sufficient interest
+this situation could change. (05/27/2003) -- This has now been tested on
+ppc64 SMP. - Kent Yoder <yoder1@us.ibm.com>
+
+
+Devica Module
+
+	Devica can provide multiple "virtual adapters" though the default 
+configuration is that of a single instance which would deliver work to
+all registered instances of leedslites.
+
+	The registration functions are:
+		ica_register_worker( )
+		ica_unregister_worker( )
+
+	Linux linked lists are used pervasively througout both drivers.   Each
+"virtual adapter" has its own list of workers to distribute work to.  The
+registration functions are used by the leedslite device driver to register
+instances of "physical adapters" for work.
+
+	The work distribution is currently round robin.  A more complex 
+scheduling algorithm (possibly based on run-time statics or other) could 
+be inserted here.
+
+	An interesting feature of devica is that of auto-loading of 
+worker modules.   Upon init, the devica driver will attempt using kmod
+to load worker modules such as leedslite.  'maxmodules' controls the 
+number of aliases that will attempt to load via kmod.  The aliases to be
+loaded are prefixed with 'ica-slot-%d' where '%d' is replaced by the integer 
+0 through maxmodules.   For example, the default 'maxdevices' value is 1; 
+devica will try to load 'ica-slot-0'.   If modules.conf has an entry of:
+
+	'alias ica-slot-0 leedslite'
+
+the leedslite module will get autoloaded.   
+
+
+Devica Module Parms
+
+	maxmodules (default 1): number of worker modules to attempt autoload
+
+	maxdevices (default 1): number of "virtual adapters" to support
+
+	driver_major (default 0): device major number to be used
+
+
+Leedslite Module
+
+	This driver provides the interface to the ICA Adapter 
+functionality.    The driver can be accessed both from an application or
+indirectly via the devica work distributor.   
+
+Initialization
+
+	The module can support up to 'maxdevices' number of adapters.   
+Originally, a driver supporting the PCI bus would need to walk the PCI 
+configuration space itself to find its adapter.   The Linux Kernel now 
+supports services to register callbacks for PCI device discovery.   This 
+is also the interface used by PCI Hotplug.   As the PCI service discover
+PCI functions it will callback to the register driver.  The leedslite
+adapter uses these newer (and preferred services).   In this fashion, the
+driver should be PCI hot-plug compatible (though this has not been tested
+since I do not have a box supporting this).
+
+	Once discovered the driver will allocate memory for data structures, 
+DMA buffers, reset the adapter and initialize the card per the hardware 
+specifications.
+
+
+Binding
+	
+	By default, the driver auto-registers with devica on the first 
+virtual adapter.   The 'devica' parameter can be used to disable the 
+auto-registration.   Once the leedslite driver is loaded there are 'bind'
+and 'unbind' IOCtls which can manipulate this relationship, specifying the 
+"virtual adapter" to bind/unbind with.   It is not required that the 
+leedslite adapter with devica, though the auto-registration is the 
+expected normal configuration.
+
+	This is a good place to discuss MODULE use count.  Typically, one will
+See MOD_INC_USE_COUNT in the 'open' processing and MOD_DEC_USE_COUNT in
+the close processing.   These two macros are used to track the number of
+users of a module to allow its safe removal from the system.   As some
+applications may be accessing the leedslite module via devica, the use count
+macros are used at the beginning and endings of the functional entrypoints,
+as opposed to the open/close processing.  So when a RNG read entrypoint is 
+called, the use count is incremented, upon exit the use count will be 
+decremented.   
+
+RNG Operations
+
+	The random number generation function of the adapter can be accessed
+via the 'read' system call.  
+
+	The card itself generates 8 random bytes per RNG interrupt.   If 
+there are multiple consumers for the RNG data, the leedslite driver will
+service the consumers in a round-robin fashion for each 8 bytes of new RNG
+data.
+
+	The card is programmed in a continuously running mode.  As soon as
+all 8 bytes are read from the card arms itself to generate the next RNG
+interrupt.   Care is taken in the driver to serialize/share data between
+the interrupt handler and the consumer threads through the use of Linux 
+'wait_queues' and atomic operations this can be achieved.  
+
+	Two important variables are:
+
+	rng_current_wait:   This is where tasks wait for rng data to be 
+		available.  The task at the front of this list will 
+		receive the next (up to) 8 bytes of RNG data.
+
+	entropy_available:  This is communicates the presence of RNG data.
+		This is set by the ISR and cleared by the task reading the
+		RNG.   This prevents an accidentally awakened task from
+		reading possibly stale or incorrect RNG data from the card.
+
+	Note: there is currently no 'poll' support, though this should be 
+relatively easy to add.  
+
+
+
+Non-RSA Operations
+
+	The leedslite adapter can perform only 1 non-RSA cryptographic 
+operation at a time.   This includes DES, TDES, SHA, and DESMAC operations.
+    
+	As such the driver needs to serialize and control access to the
+leedslite hardware.    There is a two tier control mechanism based on two 
+variables, des_wait and des_current_wait.
+
+	des_wait:  This is a mutex controlling access to the second tier.  
+		Once past this point, this task has access to adapter.
+
+	des_current_wait:  This is the where the task which currently owns 
+		the access to the adapter waits until the programmed 
+		operation completes and is woken up by the ISR.
+
+
+	The driver currently does double-buffering.   Data is copied to and
+from the 'desbuffer'.   The adapter is programmed with the bus address for
+this buffer.  The size of 'desbuffer' can be tuned via module parameters.
+
+	Each non-RSA operation (SHA, DES, TDES, DESMAC) sets up the the
+leedslite adapter a little bit differently.   
+
+
+RSA Operations
+
+	The ICA Adapter has 5 UltraCypher cryptographic processors.  
+To minimize software overhead, the Leedslite has function to post up to
+64 operations to a ICA Adapter.   The control functions on the card
+manage the busmastering of the requests/data to and from the card.
+
+	Three data structures are used to control this mechanism: the RIP, ROP,
+and VFIFO.   The RIP, or RSA Input Buffer, is used to define the operation 
+to be performed, its data, and its operation parameters.  The ROP, or RSA
+Output Buffer, is used as the destination for the operations output.  The 
+RSA_VF, or RSA Virtual FIFO, structure is used to relay the status for that 
+operation.  The bus addresses for these structures must be programmed into the 
+leedslite adapter upon initialization. 
+
+	The RIP, ROP, and RSA_VF are each 64 entry structures (actually this 
+can be reduced via the 'rsabufs' module parameter if needed).   The index 
+into the RIP and ROP are referred to as the RSAopID.  The RSA_VF is a circular
+buffer.  
+
+	Operationally, to submit a request to the adapter one must:
+
+	1) Locate an unused entry (or wait for one)
+	2) Fill out RIP entry with operation data and parameters
+	3) Submit request to adapter by programming the RSA Command Register
+	4) Wait for completion.  
+	5) If successful return results to requester from the ROP
+
+	The adapter notifies the device driver of an RSA completion through an 
+interrupt that n RSA operations are complete.   The interrupt handler reads
+n entries of the RSA_VF fifo.  Each entry returns the RSAopID of the 
+completed operation, as well as, that specific operations status.
+
+	For a more detailed description of programming the ICA Adapter 
+for RSA operations see the functional specification or refer to the source 
+code.   
+
+	RIP and ROP usage is managed through a list of "free" entries.  This 
+list is labelled 'rsa_freelist_head' and contains entries of 'rsa_free_t' 
+strucutres. One 'rsa_free_t' is allocated for this list for each entry in the 
+RIP/ROP/RSA_VF (typically 64).  Entries are removed from this list for use and
+returned upon completion.  Within the device driver, an 'rsa_free_t' is
+the structure used to track an individual operation, including its status, 
+its index (or RSAopID), and a wait queue to sleep/woken on.
+
+	To locate and unused RIP/ROP entry, one would look to the
+free list.   Additionally, and for simplicity, a semaphore is used to 
+control access to this list.  The semaphore will allow an 'rsabufs' number of
+threads entry to allocate a free entry.  There should not be a case where the
+free list is empty, as the semaphore should control the number of used entries.
+A thread will wait at the semaphore until an entry has been put back on the
+free list. 
+
+     Here are some interesting RSA related fields:
+
+     rsa_wait:  semaphore used for controlling access to free list
+     rsa_freelist: saved allocation handle to memory used for entries
+     rsa_freelist_head: the actual list head for entries
+     rip:   RIP buffer
+     rop:   ROP buffer
+     vfifo: RSA_VF buffer
+     lwp:   last word pointer; last entry used in vfifo
+     
+
+Interrupt Handling
+
+	The leedslite adapter uses an interrupt to notify the host of a variety
+of events, including completion and errors.
+
+	A given interrupt actually returns a number of events.  The interrupt
+handler reads the Piuma Interrupt Register, or PIR, to determine what events
+have occurred on will farm the processing out to approriate functions.   See
+the 'leedslite_interrupt' function for the initial interrupt processing. 
+
+Error Recovery
+
+	Different error recovery mechanisms are needed for a variety of
+situations.  In general, error recovery will occur if possible, however, the
+operation will fail.   The KERN_ERR level klog message will log the error.
+
+	PCI Abort Occurrence, or PAO:  Currently, the driver just clears this
+	condition.
+	
+	Merlin Interrupt, or MI:  This can happen for a variety of reasons.  
+	One of the simplest examples, is that if passing illegal RSA 
+	operands (e.g. RSA modulus length > 8).   The error recovery for
+	this case is quite painful and requires a reset of the card.    
+	Additionally, the driver fails all outstanding requests. 
+
+	Busmaster Error Occurrence:  This should not happen, there is a
+	defined recovery mechanism (though also painful).  The procedure
+	requires a resetting of internal Piuma FIFOs and resetting the 
+	adapter.    There were early adapters which also generated BEO
+	errors, which were not correctable via this mechanism.  This should
+	not be the case for the production hardware.
+	
+	
+
+DMA Timeout
+
+	When working with device drivers, expect hardware failure.   DMA 
+operations are used to move data independently from the host CPU.  Typically, 
+this is to/from memory and peripheral.   Once a DMA operation is set in 
+motion, the memory is off-limits until the operation is complete.  With the 
+Leedslite, the adapter should generate an interrupt to indicates such a 
+completion.  As the driver has no way to interrupt the current operation, 
+the current task wait UNINTERRUPTIBLE.
+
+	However, if the hardware malfunctions, the interrupt may not get
+generated.  The 'error_timeout' specifies how long we are willing to 
+wait before the driver considers the hardware to have malfunctioned and
+assumes the the desbuffer is now safe for reuse.   Additionally, the
+problem will be logged and the current task will return with an error.   
+
+
+
+Teardown
+
+	Teardown very simply reverses the resource allocations used during
+the initialization and operation of the Leedslite device driver.  No 
+attempt is made to put the adapter in any known state, instead this function
+is assumed to occur upon device driver initialization.
+
+
+
+Leedslite Module Parms
+
+	Note:  All values specified as positive integers
+
+	maxdevices (default 12):  maximum number of adapters to support
+
+	devica (default 1): should the driver auto-register with devica
+
+	desbuffersize (default 8192): number of bytes to allocate for DES DMA buffer
+
+	rsabufs (default 64): number of entries allocated for RSA operations up to a maximum of 64
+
+	sam (default 0): Speed Adjustment Mechanism, 0x00-0x3f,  lower number the higher power consumption and performance
+
+	pmwi (default 1):  Enable pseudo-MWI.   Configurable just because it is.
+
+	error_timeout (default 60):  Minutes before a DMA operation is considered completely errant.  This should _not_ happen.   
+
+
+
+Programming with the Leedslite Driver
+
+	I prefer to have device drivers with the simple interfaces, 
+especially in absense of requirements otherwise.  As there were no predefined
+interfaces for the crytographic accelerator, the driver's software interfaces
+often directly expose the Leedslite adatper internals.   Typically an 
+application would not directly use these interfaces, but instead be accessed
+through higher level libraries, such as OpenSSL or PKCS11 implementations.  
+These higher level libraries, would use the low-level software interfaces to
+build build their needed function.  
+
+
+open, close, read
+	Typical filesytem calls are used to access the driver via open/close
+to get access to the device.   The 'read' call will access the RNG read
+function of the device driver.   For example, simple utilities such as 'cat'
+can be used to access the RNG function of the adapter.   
+
+IOCtls (See <linux/icaioctl.h> )
+
+	If enough interest is generated from this driver, detailed 
+programming interfaces may be published.   There are testcases which 
+demonstrate these functions and can be made available upon request.   
+Otherwise, programming an application for this device driver will require 
+access to the Leedslite Functional Specification.  If one actually has a 
+Leedslite adapter, one likely has access to this specification.   Other 
+examples will be viewable from the implementation of the libica library.   
+
+	For RSA operations, all operands must be big-endian and pre-padded to
+'inputdatalength' size.   There are additionally, allowable minimum/maximum
+allowable size.   The limitations basically correspond to those required by
+the adapter itself.   
+
+	For DES operations, 
+
+
+ICASETBIND
+	Bind a physical adapter to a virtual devica adapter.
+ICAGETBIND
+	Determine the virtual adapter a physical adapter is bound to.
+ICARSAMODEXPO
+	Perform RSA (modular exponentiation) operation.  
+ICARSACRT
+	Perform RSA with CRT (Chinese Remainder Theorem) operation.
+ICARSAMODMULT
+	Perform modular multiplication operation
+ICADES
+	Perform DES operation
+ICATDES
+	Perform Triple-DES operation
+ICADESMAC
+	Perform DESMAC (SHA1 digest of DES result) operation.
+ICATDESSHA
+	Perform DES and SHA in parallel operations.  Unsupported.
+ICATDESMAC
+	Perform Triple-DES followed by SHA1 digest operation.
+ICASHA1
+	Perform SHA-1 message digest operation.   
+ICARNG
+	Read bytes from random number generator.
+
+
+Miscellaneous Comments:
+	The current interfaces are 1) synchronous 2) built with applications 
+in mind.   It would be a very interesting task to develop interfaces to
+enhance the driver to support asynchrouns interfaces.   Additionally, there
+are instances, such as IPSEC, that would need much more kernel friendly 
+interfaces.
+
+	The /dev/random could be enhanced with an interface to allow input by
+a truley random number generator such as leedslite, or possibly be enhanced to
+farm out RNG request to sources.   I've toyed with Jeff Garzik's 
+intel-rng-tools, which has a daemon to periodically read RNG data from a 
+device and then send this down to /dev/random as another RNG data source and 
+this seems to work fine for the Leedslite device driver.   
+
+	I've used the devfs interfaces for registering the driver with the
+kernel.   HOWEVER, I've never actually tested this for it to work.   This
+would be fantastic thing to actually try out.   I'm _not_ in favor of 
+writing code that I cannot test.   The rest of the driver has this discipline.
+There will be at least one bug here, but should not be more than one or two 
+days effort assuming one knows how to debug kernel code and can configure
+devfs. 
+
+
+Building the Device Driver
+
+	The directions in this section will highly depend on someone fluent
+both in building kernels and device drivers.   
+
+	The driver's compilation can be enabled through a config option of
+'CONFIG_ICA_LEEDSLITE'.   You can access this through the xconfig menu's of:
+
+	Character devices->IBM Leedslite Crypto Accel (EXPERIMENTAL)
+	
+however, this option depends on CONFIG_EXPERIMENTAL also being enabled.  This
+driver can be compiled either statically in the kernel or as a module.
+
+	Note:  No major number has been secured for the driver.  One can 
+either be configured as a module_parm, or this information can be gleaned
+from /dev/devices.    Device nodes will need to be created for the driver's
+major/minor numbers.   These words should make sense for those interested
+in this driver.
+ 
+	Again if this adapter becomes widespread, more detailed information
+and/or facilities may be suplied.
diff -urN linux-2.6.0-test9/include/linux/icaioctl.h linux-2.6.0-test9-icadd-0107/include/linux/icaioctl.h
--- linux-2.6.0-test9/include/linux/icaioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.0-test9-icadd-0107/include/linux/icaioctl.h	2004-01-07 11:21:36.000000000 -0600
@@ -0,0 +1,219 @@
+/* Copyright (c) International Business Machines Corp., 2001 */
+/*
+ * linux/include/linux/icaioctl.h
+ * 
+ */
+
+
+
+#ifndef _LINUX_ICAIOCTL_H_
+#define _LINUX_ICAIOCTL_H_
+
+enum _sizelimits {
+  ICA_DES_DATALENGTH_MIN = 8,
+  ICA_DES_DATALENGTH_MAX = 32 * 1024 * 1024 - 8,
+  ICA_SHA_DATALENGTH = 20,
+  ICA_SHA_BLOCKLENGTH = 64,
+  ICA_RSA_DATALENGTH_MIN = 256/8,
+  ICA_RSA_DATALENGTH_MAX = 2048/8
+};
+
+
+typedef struct _ica_rng_rec {
+  unsigned int nbytes;
+  char *buf;
+} ica_rng_t;
+
+
+// May have some porting issues here 
+
+typedef struct _ica_rsa_modexpo {
+  char         *inputdata;
+  unsigned int  inputdatalength;
+  char         *outputdata;
+  unsigned int  outputdatalength;
+  char         *b_key;
+  char         *n_modulus;
+} ica_rsa_modexpo_t;
+
+typedef ica_rsa_modexpo_t ica_rsa_modmult_t;
+
+typedef struct _ica_rsa_modexpo_crt {
+  char         *inputdata;
+  unsigned int  inputdatalength;
+  char         *outputdata;
+  unsigned int  outputdatalength;
+  char         *bp_key;
+  char         *bq_key;
+  char         *np_prime;
+  char         *nq_prime;
+  char         *u_mult_inv;
+} ica_rsa_modexpo_crt_t;
+
+typedef unsigned char ica_des_vector_t[8];
+typedef unsigned char ica_des_key_t[8];
+typedef ica_des_key_t ica_des_single_t[1];
+typedef ica_des_single_t ica_des_triple_t[3];
+
+enum _ica_mode_des {
+  DEVICA_MODE_DES_CBC = 0,
+  DEVICA_MODE_DES_ECB = 1
+};
+
+enum _ica_direction_des {
+  DEVICA_DIR_DES_ENCRYPT = 0,
+  DEVICA_DIR_DES_DECRYPT = 1
+};
+
+typedef struct _ica_des {
+  unsigned int      mode;
+  unsigned int      direction;
+  unsigned char    *inputdata;
+  unsigned int      inputdatalength;
+  ica_des_vector_t *iv;
+  ica_des_key_t    *keys;
+  unsigned char    *outputdata;
+  int              outputdatalength;
+} ica_des_t;
+  
+typedef struct _ica_desmac {
+  unsigned char    *inputdata;
+  unsigned int      inputdatalength;
+  ica_des_vector_t *iv;
+  ica_des_key_t    *keys;
+  unsigned char    *outputdata;
+  int              outputdatalength;
+} ica_desmac_t;
+  
+
+typedef unsigned char ica_sha1_result_t[ICA_SHA_DATALENGTH];
+
+
+typedef struct _ica_sha1 {
+  unsigned char     *inputdata;
+  unsigned int       inputdatalength;
+  ica_sha1_result_t *outputdata;
+  ica_sha1_result_t *initialh;
+} ica_sha1_t;
+
+/* The following structs are used by conversion functions
+   on PowerPC 64 bit only.  They should not be used by externel
+   applications.  Should the non PPC specific structs change, these
+   structures may need to change as well.  Also, new conversion
+   routines will need to be added to devica.c to deal with new 
+   structs or structure members.
+*/
+#ifdef CONFIG_PPC64
+typedef struct _ica_rng_rec_32 {
+  unsigned int nbytes;
+  unsigned int buf;
+} ica_rng_t_32;
+
+typedef struct _ica_des_32 {
+  unsigned int   mode;
+  unsigned int   direction;
+  unsigned int    inputdata;
+  unsigned int  inputdatalength;
+  unsigned int     iv;
+  unsigned int      keys;
+  unsigned int      outputdata;
+  unsigned int   outputdatalength;
+} ica_des_t_32;
+
+typedef struct _ica_sha1_32 {
+  unsigned int       inputdata;
+  unsigned int       inputdatalength;
+  unsigned int       outputdata;
+  unsigned int       initialh;
+} ica_sha1_t_32;
+
+typedef struct _ica_desmac_32 {
+  unsigned int    inputdata;
+  unsigned int      inputdatalength;
+  unsigned int     iv;
+  unsigned int     keys;
+  unsigned int     outputdata;
+  int              outputdatalength;
+} ica_desmac_t_32;
+
+typedef struct _ica_rsa_modexpo_crt_32 {
+  unsigned int  inputdata;
+  unsigned int  inputdatalength;
+  unsigned int  outputdata;
+  unsigned int  outputdatalength;
+  unsigned int  bp_key;
+  unsigned int  bq_key;
+  unsigned int  np_prime;
+  unsigned int  nq_prime;
+  unsigned int  u_mult_inv;
+} ica_rsa_modexpo_crt_t_32;
+
+typedef struct _ica_rsa_modexpo_32 {
+  unsigned int  inputdata;
+  unsigned int  inputdatalength;
+  unsigned int  outputdata;
+  unsigned int  outputdatalength;
+  unsigned int  b_key;
+  unsigned int  n_modulus;
+} ica_rsa_modexpo_t_32;
+
+#endif
+
+#define ICA_IOCTL_MAGIC '?'  // NOTE:  Need to allocate from linux folks
+
+/*
+ * Note: Some platforms only use 8 bits to define the parameter size.  As 
+ * the macros in ioctl.h don't seem to mask off offending bits, they look
+ * a little unsafe.  We should probably just not use the parameter size
+ * at all for these ioctls.  I don't know if we'll ever run on any of those
+ * architectures, but seems easier just to not count on this feature.
+ */
+
+#define ICASETBIND     _IOW(ICA_IOCTL_MAGIC, 0x01, int)
+#define ICAGETBIND     _IOR(ICA_IOCTL_MAGIC, 0x02, int)
+#define ICAGETCOUNT    _IOR(ICA_IOCTL_MAGIC, 0x03, int)
+#define ICAGETID       _IOR(ICA_IOCTL_MAGIC, 0x04, int)
+#define ICARSAMODEXPO  _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x05, 0)
+#define ICARSACRT      _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x06, 0) 
+#define ICARSAMODMULT  _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x07, 0)
+#define ICADES         _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x08, 0)
+#define ICADESMAC      _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x09, 0)
+#define ICATDES        _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x0a, 0)
+#define ICATDESSHA     _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x0b, 0)
+#define ICATDESMAC     _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x0c, 0)
+#define ICASHA1        _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x0d, 0)
+#define ICARNG         _IOC(_IOC_READ, ICA_IOCTL_MAGIC, 0x0e, 0)
+#define ICAGETVPD      _IOC(_IOC_READ, ICA_IOCTL_MAGIC, 0x0f, 0)
+
+#ifdef __KERNEL__
+
+#ifndef assertk
+#ifdef NDEBUG
+#  define assertk(expr) do {} while (0)
+#else
+#  define assertk(expr) \
+        if(!(expr)) {                                   \
+        printk( "Assertion failed! %s,%s,%s,line=%d\n", \
+        #expr,__FILE__,__FUNCTION__,__LINE__);          \
+        }
+#endif
+#endif
+
+
+struct ica_operations {
+  ssize_t (*read) (struct file *, char *, size_t, loff_t *, void *);
+  int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long, void *);
+};
+
+typedef struct ica_worker {
+  struct ica_operations *icaops;
+  void * private_data;  
+} ica_worker_t;
+
+
+extern int ica_register_worker(int partitionnum, ica_worker_t *device);
+extern int ica_unregister_worker(int partitionnum, ica_worker_t *device);
+
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_ICAIOCTL_H_ */
