# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
# This patch format is intended for GNU patch command version 2.5 or higher.
# This patch includes the following deltas:
#	           ChangeSet	1.1813  -> 1.1814 
#	     fs/cifs/AUTHORS	1.9     -> 1.10   
#	   fs/cifs/cifssmb.c	1.60    -> 1.61   
#	     fs/cifs/CHANGES	1.82    -> 1.83   
#	   fs/cifs/connect.c	1.83    -> 1.84   
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 04/06/07	stevef@stevef95.austin.ibm.com	1.1814
# Fix race in updating tcpStatus field
# --------------------------------------------
#
Index: linux-2.6.5/fs/cifs/AUTHORS
===================================================================
--- linux-2.6.5.orig/fs/cifs/AUTHORS	2004-06-09 12:29:41.000000000 +0200
+++ linux-2.6.5/fs/cifs/AUTHORS	2004-06-09 12:31:07.000000000 +0200
@@ -32,3 +32,5 @@
 Lars Muller, Urban Widmark, Massimiliano Ferrero, Howard Owen,
 Kieron Briggs and others. 
 
+And thanks to the IBM LTC and Power test teams and SuSE testers for
+finding multiple bugs during excellent stress test runs.
Index: linux-2.6.5/fs/cifs/cifssmb.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifssmb.c	2004-06-09 12:29:41.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifssmb.c	2004-06-09 12:31:07.000000000 +0200
@@ -376,8 +376,11 @@
 			 smb_buffer_response, &length, 0);
 	if (ses->server) {
 		atomic_dec(&ses->server->socketUseCount);
-		if (atomic_read(&ses->server->socketUseCount) == 0)
+		if (atomic_read(&ses->server->socketUseCount) == 0) {
+			spin_lock(&GlobalMid_Lock);
 			ses->server->tcpStatus = CifsExiting;
+			spin_unlock(&GlobalMid_Lock);
+		}
 	}
 	if (pSMB)
 		cifs_buf_release(pSMB);
Index: linux-2.6.5/fs/cifs/connect.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/connect.c	2004-06-09 12:29:41.000000000 +0200
+++ linux-2.6.5/fs/cifs/connect.c	2004-06-09 12:31:07.000000000 +0200
@@ -95,9 +95,15 @@
 	struct cifsTconInfo *tcon;
 	struct mid_q_entry * mid_entry;
 	
-	if(server->tcpStatus == CifsExiting)
+	spin_lock(&GlobalMid_Lock);
+	if(server->tcpStatus == CifsExiting) {
+		/* the demux thread will exit normally 
+		next time through the loop */
+		spin_unlock(&GlobalMid_Lock);
 		return rc;
-	server->tcpStatus = CifsNeedReconnect;
+	} else
+		server->tcpStatus = CifsNeedReconnect;
+	spin_unlock(&GlobalMid_Lock);
 	server->maxBuf = 0;
 
 	cFYI(1, ("Reconnecting tcp session "));
@@ -164,7 +170,10 @@
 			schedule_timeout(3 * HZ);
 		} else {
 			atomic_inc(&tcpSesReconnectCount);
-			server->tcpStatus = CifsGood;
+			spin_lock(&GlobalMid_Lock);
+			if(server->tcpStatus != CifsExiting)
+				server->tcpStatus = CifsGood;
+			spin_unlock(&GlobalMid_Lock);
 			atomic_set(&server->inFlight,0);
 			wake_up(&server->response_q);
 		}
@@ -243,12 +252,14 @@
 				/* some servers kill tcp session rather than returning
 					smb negprot error in which case reconnecting here is
 					not going to help - return error to mount */
+				spin_lock(&GlobalMid_Lock);
 				server->tcpStatus = CifsExiting;
+				spin_unlock(&GlobalMid_Lock);
 				wake_up(&server->response_q);
 				break;
 			}
 
-			cFYI(1,("Reconnecting after unexpected rcvmsg error "));
+			cFYI(1,("Reconnecting after unexpected peek error %d",length));
 			cifs_reconnect(server);
 			csocket = server->ssocket;
 			wake_up(&server->response_q);
@@ -280,7 +291,9 @@
 					/* if nack on negprot (rather than 
 					ret of smb negprot error) reconnecting
 					not going to help, ret error to mount */
+					spin_lock(&GlobalMid_Lock);
 					server->tcpStatus = CifsExiting;
+					spin_unlock(&GlobalMid_Lock);
 					/* wake up thread doing negprot */
 					wake_up(&server->response_q);
 					break;
@@ -391,7 +404,9 @@
 			}
 		}
 	}
+	spin_lock(&GlobalMid_Lock);
 	server->tcpStatus = CifsExiting;
+	spin_unlock(&GlobalMid_Lock);
 	atomic_set(&server->inFlight, 0);
 	/* Although there should not be any requests blocked on 
 	this queue it can not hurt to be paranoid and try to wake up requests
@@ -1226,6 +1241,9 @@
 			init_waitqueue_head(&srvTcp->response_q);
 			init_waitqueue_head(&srvTcp->request_q);
 			INIT_LIST_HEAD(&srvTcp->pending_mid_q);
+			/* at this point we are the only ones with the pointer
+			to the struct since the kernel thread not created yet
+			so no need to spinlock this init of tcpStatus */
 			srvTcp->tcpStatus = CifsNew;
 			init_MUTEX(&srvTcp->tcpSem);
 			kernel_thread((void *)(void *)cifs_demultiplex_thread, srvTcp,
@@ -1342,9 +1360,12 @@
 
 /* on error free sesinfo and tcon struct if needed */
 	if (rc) {
-		if(atomic_read(&srvTcp->socketUseCount) == 0)
-                	srvTcp->tcpStatus = CifsExiting;
-		           /* If find_unc succeeded then rc == 0 so we can not end */
+		if(atomic_read(&srvTcp->socketUseCount) == 0) {
+			spin_lock(&GlobalMid_Lock);
+			srvTcp->tcpStatus = CifsExiting;
+			spin_unlock(&GlobalMid_Lock);
+		}
+		 /* If find_unc succeeded then rc == 0 so we can not end */
 		if (tcon)  /* up here accidently freeing someone elses tcon struct */
 			tconInfoFree(tcon);
 		if (existingCifsSes == 0) {
@@ -2791,7 +2812,7 @@
 	char ntlm_session_key[CIFS_SESSION_KEY_SIZE];
 	int ntlmv2_flag = FALSE;
 
-    /* what if server changes its buffer size after dropping the session? */
+	/* what if server changes its buffer size after dropping the session? */
 	if(pSesInfo->server->maxBuf == 0) /* no need to send on reconnect */ {
 		rc = CIFSSMBNegotiate(xid, pSesInfo);
 		if(rc == -EAGAIN) /* retry only once on 1st time connection */ {
@@ -2799,8 +2820,15 @@
 			if(rc == -EAGAIN) 
 				rc = -EHOSTDOWN;
 		}
-		if(rc == 0)
-			pSesInfo->server->tcpStatus = CifsGood;
+		if(rc == 0) {
+			spin_lock(&GlobalMid_Lock);
+			if(pSesInfo->server->tcpStatus != CifsExiting)
+				pSesInfo->server->tcpStatus = CifsGood;
+			else
+				rc = -EHOSTDOWN;
+			spin_unlock(&GlobalMid_Lock);
+
+		}
 	}
 	if (!rc) {
 		pSesInfo->capabilities = pSesInfo->server->capabilities;
