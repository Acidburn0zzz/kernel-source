diff -u linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134.h linux/drivers/media/video/saa7134/saa7134.h
--- linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134.h	2004-04-04 18:11:12.000000000 +0200
+++ linux/drivers/media/video/saa7134/saa7134.h	2004-04-21 16:54:31.380279456 +0200
@@ -19,7 +19,7 @@
  */
 
 #include <linux/version.h>
-#define SAA7134_VERSION_CODE KERNEL_VERSION(0,2,9)
+#define SAA7134_VERSION_CODE KERNEL_VERSION(0,2,12)
 
 #include <linux/pci.h>
 #include <linux/i2c.h>
@@ -73,8 +73,6 @@
 struct saa7134_tvnorm {
 	char          *name;
 	v4l2_std_id   id;
-	unsigned int  width;
-	unsigned int  height;
 
 	/* video decoder */
 	unsigned int  sync_control;
@@ -154,6 +152,9 @@
 #define SAA7134_BOARD_ECS_TVP3XP_4CB5  31
 #define SAA7134_BOARD_AVACSSMARTTV     32
 #define SAA7134_BOARD_AVERMEDIA_DVD_EZMAKER 33
+#define SAA7134_BOARD_NOVAC_PRIMETV7133 34
+#define SAA7134_BOARD_AVERMEDIA_305    35
+#define SAA7133_BOARD_UPMOST_PURPLE_TV 36
 
 #define SAA7134_INPUT_MAX 8
 
@@ -301,7 +302,8 @@
 	unsigned int               afmt;
 	unsigned int               rate;
 	unsigned int               channels;
-	unsigned int               recording;
+	unsigned int               recording_on;
+	unsigned int               dma_running;
 	unsigned int               blocks;
 	unsigned int               blksize;
 	unsigned int               bufsize;
@@ -394,7 +396,12 @@
 	int                        ctl_mirror;
 	int                        ctl_y_odd;
 	int                        ctl_y_even;
-
+	
+	/* crop */
+	struct v4l2_rect           crop_bounds;
+	struct v4l2_rect           crop_defrect;
+	struct v4l2_rect           crop_current;
+	
 	/* other global state info */
 	unsigned int               automute;
 	struct saa7134_thread      thread;
diff -u linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-core.c linux/drivers/media/video/saa7134/saa7134-core.c
--- linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-core.c	2004-04-04 18:09:56.000000000 +0200
+++ linux/drivers/media/video/saa7134/saa7134-core.c	2004-04-21 16:54:31.453265723 +0200
@@ -101,7 +101,7 @@
 /* debug help functions                                               */
 
 static const char *v4l1_ioctls[] = {
-	"0", "CGAP", "GCHAN", "SCHAN", "GTUNER", "STUNER", "GPICT", "SPICT",
+	"0", "GCAP", "GCHAN", "SCHAN", "GTUNER", "STUNER", "GPICT", "SPICT",
 	"CCAPTURE", "GWIN", "SWIN", "GFBUF", "SFBUF", "KEY", "GFREQ",
 	"SFREQ", "GAUDIO", "SAUDIO", "SYNC", "MCAPTURE", "GMBUF", "GUNIT",
 	"GCAPTURE", "SCAPTURE", "SPLAYMODE", "SWRITEMODE", "GPLAYINFO",
@@ -466,7 +466,7 @@
 	}
 
 	/* audio capture -- dma 3 */
-	if (dev->oss.recording) {
+	if (dev->oss.dma_running) {
 		ctrl |= SAA7134_MAIN_CTRL_TE6;
 		irq  |= SAA7134_IRQ1_INTE_RA3_1 |
 			SAA7134_IRQ1_INTE_RA3_0;
@@ -607,10 +607,18 @@
 	};
 	if (10 == loop) {
 		print_irqstatus(dev,loop,report,status);
-		printk(KERN_WARNING "%s/irq: looping -- clearing enable bits\n",dev->name);
-		/* disable all irqs */
-		saa_writel(SAA7134_IRQ1,0);
-		saa_writel(SAA7134_IRQ2,0);
+		if (report & SAA7134_IRQ_REPORT_PE) {
+			/* disable all parity error */
+			printk(KERN_WARNING "%s/irq: looping -- "
+			       "clearing PE (parity error!) enable bit\n",dev->name);
+			saa_clearl(SAA7134_IRQ2,SAA7134_IRQ2_INTE_PE);
+		} else {
+			/* disable all irqs */
+			printk(KERN_WARNING "%s/irq: looping -- "
+			       "clearing all enable bits\n",dev->name);
+			saa_writel(SAA7134_IRQ1,0);
+			saa_writel(SAA7134_IRQ2,0);
+		}
 	}
 
  out:
diff -u linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-cards.c linux/drivers/media/video/saa7134/saa7134-cards.c
--- linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-cards.c	2004-04-04 18:11:33.000000000 +0200
+++ linux/drivers/media/video/saa7134/saa7134-cards.c	2004-04-21 16:54:31.498257257 +0200
@@ -2,7 +2,7 @@
  * device driver for philips saa7134 based TV cards
  * card-specific stuff.
  *
- * (c) 2001-03 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
+ * (c) 2001-04 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -420,20 +420,14 @@
 			.vmux   = 1,
 			.amux   = TV,
 			.tv     = 1,
-#if 0
 		},{
 			.name   = name_comp1,
 			.vmux   = 0,
 			.amux   = LINE2,
 		},{
-			.name   = name_comp2,
-			.vmux   = 3,
-			.amux   = LINE2,
-		},{
 			.name   = name_svideo,
 			.vmux   = 8,
 			.amux   = LINE2,
-#endif
 		}},
 		.radio = {
 			.name   = name_radio,
@@ -679,7 +673,7 @@
                 }},
         },
 	[SAA7134_BOARD_MD2819] = {
-		.name           = "Medion 2819/ AverMedia M156",
+		.name           = "AverMedia M156 / Medion 2819",
 		.audio_clock    = 0x00187de7,
 		.tuner_type     = TUNER_PHILIPS_FM1216ME_MK3,
 		.need_tda9887   = 1,
@@ -732,13 +726,23 @@
         [SAA7134_BOARD_ASUSTEK_TVFM7133] = {
                 .name           = "ASUS TV-FM 7133",
                 .audio_clock    = 0x00187de7,
-                .tuner_type     = TUNER_PHILIPS_FM1236_MK3,
+		// probably wrong, the 7133 one is the NTSC version ...
+		// .tuner_type     = TUNER_PHILIPS_FM1236_MK3
+                .tuner_type     = TUNER_LG_NTSC_NEW_TAPC,
                 .need_tda9887   = 1,
                 .inputs         = {{
                         .name = name_tv,
                         .vmux = 1,
                         .amux = TV,
                         .tv   = 1,
+		},{
+                        .name = name_comp1,
+                        .vmux = 4,
+                        .amux = LINE2,
+                },{
+                        .name = name_svideo,
+                        .vmux = 6,
+                        .amux = LINE2,
                 }},
                 .radio = {
                         .name = name_radio,
@@ -941,6 +945,72 @@
 			.vmux = 3,
 		}},
 	},
+        [SAA7134_BOARD_NOVAC_PRIMETV7133] = {
+                /* toshii@netbsd.org */
+                .name           = "Noval Prime TV 7133",
+                .audio_clock    = 0x00200000,
+                .tuner_type     = TUNER_ALPS_TSBH1_NTSC,
+                .inputs         = {{
+                        .name = name_comp1,
+                        .vmux = 3,
+                },{
+                        .name = name_tv,
+                        .vmux = 1,
+                        .amux = TV,
+                        .tv   = 1,
+                },{
+                        .name = name_svideo,
+                        .vmux = 8,
+                }},
+        },
+	[SAA7134_BOARD_AVERMEDIA_305] = {
+		.name           = "AverMedia 305",
+		.audio_clock    = 0x00187de7,
+		.tuner_type     = TUNER_PHILIPS_FM1216ME_MK3,
+		.need_tda9887   = 1,
+		.inputs         = {{
+			.name = name_tv,
+			.vmux = 1,
+			.amux = LINE2,
+			.tv   = 1,
+		},{
+			.name = name_comp1,
+			.vmux = 0,
+			.amux = LINE2,
+		},{
+			.name = name_comp2,
+			.vmux = 3,
+			.amux = LINE2,
+		},{
+			.name = name_svideo,
+			.vmux = 8,
+			.amux = LINE2,
+		}},
+		.radio = {
+			 .name = name_radio,
+			 .amux = LINE2,
+		 },
+		.mute = {
+			 .name = name_mute,
+			 .amux = LINE1,
+		},
+	},
+  	[SAA7133_BOARD_UPMOST_PURPLE_TV] = {
+  		.name           = "UPMOST PURPLE TV",
+  		.audio_clock    = 0x00187de7,
+  		.tuner_type     = TUNER_PHILIPS_FM1236_MK3,
+  		.need_tda9887   = 1,
+  		.inputs         = {{
+  			.name = name_tv,
+  			.vmux = 7,
+  			.amux = TV,
+  			.tv   = 1,
+  		},{
+  			.name = name_svideo,
+  			.vmux = 7,
+  			.amux = LINE1,
+  		}},
+          },
 };
 const unsigned int saa7134_bcount = ARRAY_SIZE(saa7134_boards);
 
@@ -1093,12 +1163,11 @@
                 .subdevice    = 0xa70b,
 		.driver_data  = SAA7134_BOARD_MD2819,
 	},{
-		/* AverMedia Studio 305, using AverMedia M156 entry for now */
 		.vendor       = PCI_VENDOR_ID_PHILIPS,
-		.device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
+		.device       = PCI_DEVICE_ID_PHILIPS_SAA7130,
                 .subvendor    = 0x1461, /* Avermedia Technologies Inc */
                 .subdevice    = 0x2115,
-		.driver_data  = SAA7134_BOARD_MD2819,
+		.driver_data  = SAA7134_BOARD_AVERMEDIA_305,
 	},{
 		.vendor       = PCI_VENDOR_ID_PHILIPS,
 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7130,
@@ -1131,7 +1200,13 @@
                 .subdevice    = 0x4cb5,
                 .driver_data  = SAA7134_BOARD_ECS_TVP3XP_4CB5,
         },{
+		.vendor       = PCI_VENDOR_ID_PHILIPS,
+ 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7133,
+                .subvendor    = 0x12ab,
+                .subdevice    = 0x0800,
+ 		.driver_data  = SAA7133_BOARD_UPMOST_PURPLE_TV,
 		
+ 	},{
 		/* --- boards without eeprom + subsystem ID --- */
                 .vendor       = PCI_VENDOR_ID_PHILIPS,
                 .device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
diff -u linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-tvaudio.c linux/drivers/media/video/saa7134/saa7134-tvaudio.c
--- linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-tvaudio.c	2004-04-04 18:09:10.000000000 +0200
+++ linux/drivers/media/video/saa7134/saa7134-tvaudio.c	2004-04-21 16:54:31.584241077 +0200
@@ -60,8 +60,9 @@
 #define print_regb(reg) printk("%s:   reg 0x%03x [%-16s]: 0x%02x\n", \
 		dev->name,(SAA7134_##reg),(#reg),saa_readb((SAA7134_##reg)))
 
-#define SCAN_INITIAL_DELAY  (HZ)
-#define SCAN_SAMPLE_DELAY   (HZ/5)
+#define SCAN_INITIAL_DELAY     (HZ)
+#define SCAN_SAMPLE_DELAY      (HZ/5)
+#define SCAN_SUBCARRIER_DELAY  (HZ*2)
 
 /* ------------------------------------------------------------------ */
 /* saa7134 code                                                       */
@@ -145,7 +146,7 @@
 
 	if (UNSET != audio_clock_override)
 	        clock = audio_clock_override;
-
+	
 	/* init all audio registers */
 	saa_writeb(SAA7134_AUDIO_PLL_CTRL,   0x00);
 	if (need_resched())
@@ -383,6 +384,7 @@
 	case TVAUDIO_FM_K_STEREO:
 	case TVAUDIO_FM_BG_STEREO:
 		idp = (saa_readb(SAA7134_IDENT_SIF) & 0xe0) >> 5;
+		dprintk("getstereo: fm/stereo: idp=0x%x\n",idp);
 		if (0x03 == (idp & 0x03))
 			retval = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;
 		else if (0x05 == (idp & 0x05))
@@ -396,6 +398,7 @@
 	case TVAUDIO_NICAM_FM:
 	case TVAUDIO_NICAM_AM:
 		nicam = saa_readb(SAA7134_NICAM_STATUS);
+		dprintk("getstereo: nicam=0x%x\n",nicam);
 		switch (nicam & 0x0b) {
 		case 0x08:
 			retval = V4L2_TUNER_SUB_MONO;
@@ -465,7 +468,7 @@
 	struct saa7134_dev *dev = data;
 	const int *carr_scan;
 	int carr_vals[4];
-	unsigned int i, audio;
+	unsigned int i, audio, retries;
 	int max1,max2,carrier,rx,mode,lastmode;
 
 	daemonize("%s", dev->name);
@@ -497,22 +500,26 @@
 			carr_scan = carr_secam;
 		saa_writeb(SAA7134_MONITOR_SELECT,0x00);
 		tvaudio_setmode(dev,&tvaudio[0],NULL);
-		for (i = 0; i < MAX_SCAN; i++) {
-			if (!carr_scan[i])
-				continue;
-			carr_vals[i] = tvaudio_checkcarrier(dev,carr_scan[i]);
-			if (dev->thread.scan1 != dev->thread.scan2)
-				goto restart;
-		}
-		for (carrier = 0, max1 = 0, max2 = 0, i = 0; i < MAX_SCAN; i++) {
-			if (!carr_scan[i])
-				continue;
-			if (max1 < carr_vals[i]) {
-				max2 = max1;
-				max1 = carr_vals[i];
-				carrier = carr_scan[i];
-			} else if (max2 < carr_vals[i]) {
-				max2 = carr_vals[i];
+
+		carrier = 0;
+		for (retries = 3; retries > 0 && 0 == carrier; retries--) {
+			for (i = 0; i < MAX_SCAN; i++) {
+				if (!carr_scan[i])
+					continue;
+				carr_vals[i] = tvaudio_checkcarrier(dev,carr_scan[i]);
+				if (dev->thread.scan1 != dev->thread.scan2)
+					goto restart;
+			}
+			for (max1 = 0, max2 = 0, i = 0; i < MAX_SCAN; i++) {
+				if (!carr_scan[i])
+					continue;
+				if (max1 < carr_vals[i]) {
+					max2 = max1;
+					max1 = carr_vals[i];
+					carrier = carr_scan[i];
+				} else if (max2 < carr_vals[i]) {
+					max2 = carr_vals[i];
+				}
 			}
 		}
 
@@ -557,7 +564,7 @@
 			if (UNSET == audio)
 				audio = i;
 			tvaudio_setmode(dev,&tvaudio[i],"trying");
-			if (tvaudio_sleep(dev,HZ*2))
+			if (tvaudio_sleep(dev,SCAN_SUBCARRIER_DELAY))
 				goto restart;
 			if (-1 != tvaudio_getstereo(dev,&tvaudio[i])) {
 				audio = i;
@@ -721,15 +728,20 @@
 static int tvaudio_thread_ddep(void *data)
 {
 	struct saa7134_dev *dev = data;
-	u32 value, norms;
+	u32 value, norms, clock;
 
 	daemonize("%s", dev->name);
 	allow_signal(SIGTERM);
 
+	clock = saa7134_boards[dev->board].audio_clock;
+	if (UNSET != audio_clock_override)
+		clock = audio_clock_override;
+	saa_writel(0x598 >> 2, clock);
+	
 	/* unmute */
 	saa_dsp_writel(dev, 0x474 >> 2, 0x00);
 	saa_dsp_writel(dev, 0x450 >> 2, 0x00);
-
+	
 	for (;;) {
 		tvaudio_sleep(dev,-1);
 		if (dev->thread.shutdown || signal_pending(current))
@@ -768,9 +780,11 @@
 				(norms & 0x40) ? " M"    : "");
 		}
 
-		/* quick & dirty -- to be fixed up later ... */
+		/* kick automatic standard detection */
 		saa_dsp_writel(dev, 0x454 >> 2, 0);
 		saa_dsp_writel(dev, 0x454 >> 2, norms | 0x80);
+
+		/* setup crossbars */
 		saa_dsp_writel(dev, 0x464 >> 2, 0x000000);
 		saa_dsp_writel(dev, 0x470 >> 2, 0x101010);
 
diff -u linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-video.c linux/drivers/media/video/saa7134/saa7134-video.c
--- linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-video.c	2004-04-04 18:09:35.000000000 +0200
+++ linux/drivers/media/video/saa7134/saa7134-video.c	2004-04-21 16:54:31.638230918 +0200
@@ -30,14 +30,17 @@
 
 /* ------------------------------------------------------------------ */
 
-static unsigned int video_debug  = 0;
-static unsigned int gbuffers     = 8;
-static unsigned int gbufsize     = 768*576*4;
-static unsigned int gbufsize_max = 768*576*4;
+static unsigned int video_debug   = 0;
+static unsigned int gbuffers      = 8;
+static unsigned int noninterlaced = 0;
+static unsigned int gbufsize      = 720*576*4;
+static unsigned int gbufsize_max  = 720*576*4;
 MODULE_PARM(video_debug,"i");
 MODULE_PARM_DESC(video_debug,"enable debug messages [video]");
 MODULE_PARM(gbuffers,"i");
 MODULE_PARM_DESC(gbuffers,"number of capture buffers, range 2-32");
+MODULE_PARM(noninterlaced,"i");
+MODULE_PARM_DESC(noninterlaced,"video input is noninterlaced");
 
 #define dprintk(fmt, arg...)	if (video_debug) \
 	printk(KERN_DEBUG "%s/video: " fmt, dev->name , ## arg)
@@ -149,8 +152,6 @@
 	{
 		.name          = "PAL",
 		.id            = V4L2_STD_PAL,
-		.width         = 720,
-		.height        = 576,
 
 		.sync_control  = 0x18,
 		.luma_control  = 0x40,
@@ -169,8 +170,6 @@
 	},{
 		.name          = "NTSC",
 		.id            = V4L2_STD_NTSC,
-		.width         = 720,
-		.height        = 480,
 
 		.sync_control  = 0x59,
 		.luma_control  = 0x40,
@@ -180,17 +179,15 @@
 		.vgate_misc    = 0x18,
 
 		.h_start       = 0,
-		.h_stop        = 719,
+		.h_stop        = 703,
 		.video_v_start = 22,
-		.video_v_stop  = 22+240,
+		.video_v_stop  = 22+239,
 		.vbi_v_start   = 10, /* FIXME */
 		.vbi_v_stop    = 21, /* FIXME */
 		.src_timing    = 1,
 	},{
 		.name          = "SECAM",
 		.id            = V4L2_STD_SECAM,
-		.width         = 720,
-		.height        = 576,
 
 		.sync_control  = 0x18, /* old: 0x58, */
 		.luma_control  = 0x1b,
@@ -209,8 +206,6 @@
 	},{
 		.name          = "PAL-M",
 		.id            = V4L2_STD_PAL_M,
-		.width         = 720,
-		.height        = 480,
 
 		.sync_control  = 0x59,
 		.luma_control  = 0x40,
@@ -229,8 +224,6 @@
 	},{
 		.name          = "PAL-Nc",
 		.id            = V4L2_STD_PAL_Nc,
-		.width         = 720,
-		.height        = 576,
 
 		.sync_control  = 0x18,
 		.luma_control  = 0x40,
@@ -437,15 +430,33 @@
 static void set_tvnorm(struct saa7134_dev *dev, struct saa7134_tvnorm *norm)
 {
 	struct video_channel c;
-	int luma_control,mux;
+	int luma_control,sync_control,mux;
 
 	dprintk("set tv norm = %s\n",norm->name);
 	dev->tvnorm = norm;
 
 	mux = card_in(dev,dev->ctl_input).vmux;
 	luma_control = norm->luma_control;
+	sync_control = norm->sync_control;
+
 	if (mux > 5)
 		luma_control |= 0x80; /* svideo */
+	if (noninterlaced)
+		sync_control |= 0x20;
+
+	/* setup cropping */
+	dev->crop_bounds.left    = norm->h_start;
+	dev->crop_defrect.left   = norm->h_start;
+	dev->crop_bounds.width   = norm->h_stop - norm->h_start +1;
+	dev->crop_defrect.width  = norm->h_stop - norm->h_start +1;
+
+	dev->crop_bounds.top     = (norm->vbi_v_stop+1)*2;
+	dev->crop_defrect.top    = norm->video_v_start*2;
+	dev->crop_bounds.height  = ((norm->id & V4L2_STD_525_60) ? 524 : 624)
+		- dev->crop_bounds.top;
+	dev->crop_defrect.height = (norm->video_v_stop - norm->video_v_start +1)*2;
+
+	dev->crop_current = dev->crop_defrect;
 
 	/* setup video decoder */
 	saa_writeb(SAA7134_INCR_DELAY,            0x08);
@@ -458,7 +469,7 @@
 	saa_writeb(SAA7134_HSYNC_STOP,            0xe0);
 	saa_writeb(SAA7134_SOURCE_TIMING1,        norm->src_timing);
 	
-	saa_writeb(SAA7134_SYNC_CTRL,             norm->sync_control);
+	saa_writeb(SAA7134_SYNC_CTRL,             sync_control);
 	saa_writeb(SAA7134_LUMA_CTRL,             luma_control);
 	saa_writeb(SAA7134_DEC_LUMA_BRIGHT,       dev->ctl_bright);
 	saa_writeb(SAA7134_DEC_LUMA_CONTRAST,     dev->ctl_contrast);
@@ -563,25 +574,30 @@
 static void set_size(struct saa7134_dev *dev, int task,
 		     int width, int height, int interlace)
 {
-	struct saa7134_tvnorm *norm = dev->tvnorm;
 	int prescale,xscale,yscale,y_even,y_odd;
+	int h_start, h_stop, v_start, v_stop;
 	int div = interlace ? 2 : 1;
 
 	/* setup video scaler */
-	saa_writeb(SAA7134_VIDEO_H_START1(task), norm->h_start       &  0xff);
-	saa_writeb(SAA7134_VIDEO_H_START2(task), norm->h_start       >> 8);
-	saa_writeb(SAA7134_VIDEO_H_STOP1(task),  norm->h_stop        &  0xff);
-	saa_writeb(SAA7134_VIDEO_H_STOP2(task),  norm->h_stop        >> 8);
-	saa_writeb(SAA7134_VIDEO_V_START1(task), norm->video_v_start &  0xff);
-	saa_writeb(SAA7134_VIDEO_V_START2(task), norm->video_v_start >> 8);
-	saa_writeb(SAA7134_VIDEO_V_STOP1(task),  norm->video_v_stop  &  0xff);
-	saa_writeb(SAA7134_VIDEO_V_STOP2(task),  norm->video_v_stop  >> 8);
+	h_start = dev->crop_current.left;
+	v_start = dev->crop_current.top/2;
+	h_stop  = (dev->crop_current.left + dev->crop_current.width -1);
+	v_stop  = (dev->crop_current.top + dev->crop_current.height -1)/2;
+	
+	saa_writeb(SAA7134_VIDEO_H_START1(task), h_start &  0xff);
+	saa_writeb(SAA7134_VIDEO_H_START2(task), h_start >> 8);
+	saa_writeb(SAA7134_VIDEO_H_STOP1(task),  h_stop  &  0xff);
+	saa_writeb(SAA7134_VIDEO_H_STOP2(task),  h_stop  >> 8);
+	saa_writeb(SAA7134_VIDEO_V_START1(task), v_start &  0xff);
+	saa_writeb(SAA7134_VIDEO_V_START2(task), v_start >> 8);
+	saa_writeb(SAA7134_VIDEO_V_STOP1(task),  v_stop  &  0xff);
+	saa_writeb(SAA7134_VIDEO_V_STOP2(task),  v_stop  >> 8);
 
-	prescale = norm->width / width;
+	prescale = dev->crop_current.width / width;
 	if (0 == prescale)
 		prescale = 1;
-	xscale = 1024 * norm->width / prescale / width;
-	yscale = 512 * div * norm->height / height;
+	xscale = 1024 * dev->crop_current.width / prescale / width;
+	yscale = 512 * div * dev->crop_current.height / height;
        	dprintk("prescale=%d xscale=%d yscale=%d\n",prescale,xscale,yscale);
 	set_h_prescale(dev,task,prescale);
 	saa_writeb(SAA7134_H_SCALE_INC1(task),      xscale &  0xff);
@@ -708,8 +724,8 @@
 		return -EINVAL;
 
 	field = win->field;
-	maxw  = dev->tvnorm->width;
-	maxh  = dev->tvnorm->height;
+	maxw  = dev->crop_current.width;
+	maxh  = dev->crop_current.height;
 
 	if (V4L2_FIELD_ANY == field) {
                 field = (win->w.height > maxh/2)
@@ -893,10 +909,12 @@
 	/* sanity checks */
 	if (NULL == fh->fmt)
 		return -EINVAL;
-	if (fh->width  < 48 ||
-	    fh->height < 32 ||
-	    fh->width  > dev->tvnorm->width ||
-	    fh->height > dev->tvnorm->height)
+	if (fh->width    < 48 ||
+	    fh->height   < 32 ||
+	    fh->width/4  > dev->crop_current.width  ||
+	    fh->height/4 > dev->crop_current.height ||
+	    fh->width    > dev->crop_bounds.width  ||
+	    fh->height   > dev->crop_bounds.height)
 		return -EINVAL;
 	size = (fh->width * fh->height * fh->fmt->depth) >> 3;
 	if (0 != buf->vb.baddr  &&  buf->vb.bsize < size)
@@ -1176,7 +1194,7 @@
 	fh->radio    = radio;
 	fh->type     = type;
 	fh->fmt      = format_by_fourcc(V4L2_PIX_FMT_BGR24);
-	fh->width    = 768;
+	fh->width    = 720;
 	fh->height   = 576;
 #ifdef VIDIOC_G_PRIORITY
 	v4l2_prio_open(&dev->prio,&fh->prio);
@@ -1393,8 +1411,8 @@
 			return -EINVAL;
 
 		field = f->fmt.pix.field;
-		maxw  = dev->tvnorm->width;
-		maxh  = dev->tvnorm->height;
+		maxw  = min(dev->crop_current.width*4,  dev->crop_bounds.width);
+		maxh  = min(dev->crop_current.height*4, dev->crop_bounds.height);
 		
 		if (V4L2_FIELD_ANY == field) {
 			field = (f->fmt.pix.height > maxh/2)
@@ -1482,7 +1500,6 @@
 		}
 		up(&dev->lock);
 		return 0;
-		break;
 	case V4L2_BUF_TYPE_VBI_CAPTURE:
 		saa7134_vbi_fmt(dev,f);
 		return 0;
@@ -1674,6 +1691,74 @@
 		return 0;
 	}
 
+	case VIDIOC_CROPCAP:
+	{
+		struct v4l2_cropcap *cap = arg;
+
+		if (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+		    cap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)
+			return -EINVAL;
+		cap->bounds  = dev->crop_bounds;
+		cap->defrect = dev->crop_defrect;
+		cap->pixelaspect.numerator   = 1;
+		cap->pixelaspect.denominator = 1;
+		if (dev->tvnorm->id & V4L2_STD_525_60) {
+			cap->pixelaspect.numerator   = 11;
+			cap->pixelaspect.denominator = 10;
+		}
+		if (dev->tvnorm->id & V4L2_STD_625_50) {
+			cap->pixelaspect.numerator   = 54;
+			cap->pixelaspect.denominator = 59;
+		}
+		return 0;
+	}
+
+	case VIDIOC_G_CROP:
+	{
+		struct v4l2_crop * crop = arg;
+		
+		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+		    crop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)
+			return -EINVAL;
+		crop->c = dev->crop_current;
+		return 0;
+	}
+	case VIDIOC_S_CROP:
+	{
+		struct v4l2_crop *crop = arg;
+		struct v4l2_rect *b = &dev->crop_bounds;
+		
+		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+		    crop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)
+			return -EINVAL;
+		if (crop->c.height < 0)
+			return -EINVAL;
+		if (crop->c.width < 0)
+			return -EINVAL;
+
+		if (res_locked(fh->dev,RESOURCE_OVERLAY))
+			return -EBUSY;
+		if (res_locked(fh->dev,RESOURCE_VIDEO))
+			return -EBUSY;
+
+		if (crop->c.top < b->top)
+			crop->c.top = b->top;
+		if (crop->c.top > b->top + b->height)
+			crop->c.top = b->top + b->height;
+		if (crop->c.height > b->top - crop->c.top + b->height)
+			crop->c.height = b->top - crop->c.top + b->height;
+		
+		if (crop->c.left < b->left)
+			crop->c.top = b->left;
+		if (crop->c.left > b->left + b->width)
+			crop->c.top = b->left + b->width;
+		if (crop->c.width > b->left - crop->c.left + b->width)
+			crop->c.width = b->left - crop->c.left + b->width;
+
+		dev->crop_current = crop->c;
+		return 0;
+	}
+
 	/* --- tuner ioctls ------------------------------------------ */
 	case VIDIOC_G_TUNER:
 	{
diff -u linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-oss.c linux/drivers/media/video/saa7134/saa7134-oss.c
--- linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-oss.c	2004-04-04 18:10:20.000000000 +0200
+++ linux/drivers/media/video/saa7134/saa7134-oss.c	2004-04-21 16:54:31.720215491 +0200
@@ -50,7 +50,7 @@
 	if (blksize < 0x100)
 		blksize = 0x100;
 	if (blksize > 0x10000)
-		blksize = 0x100;
+		blksize = 0x10000;
 
 	if (blocks < 2)
 		blocks = 2;
@@ -64,7 +64,7 @@
 	dev->oss.bufsize = blksize * blocks;
 
 	dprintk("buffer config: %d blocks / %d bytes, %d kB total\n",
-		blocks,blksize,blksize * blocks / 1024);
+ 		blocks,blksize,blksize * blocks / 1024);
 	return 0;
 }
 
@@ -92,6 +93,20 @@
 	return 0;
 }
 
+static void dsp_dma_start(struct saa7134_dev *dev)
+{
+	dev->oss.dma_blk     = 0;
+	dev->oss.dma_running = 1;
+	saa7134_set_dmabits(dev);
+}
+
+static void dsp_dma_stop(struct saa7134_dev *dev)
+{
+	dev->oss.dma_blk     = -1;
+	dev->oss.dma_running = 0;
+	saa7134_set_dmabits(dev);
+}
+
 static int dsp_rec_start(struct saa7134_dev *dev)
 {
 	int err, bswap, sign;
@@ -158,7 +173,7 @@
 			fmt |= (2 << 4);
 		if (!sign)
 			fmt |= 0x04;
-		saa_writel(0x588 >> 2, dev->oss.blksize);
+		saa_writel(0x588 >> 2, dev->oss.blksize -4);
 		saa_writel(0x58c >> 2, 0x543210 | (fmt << 24));
 		break;
 	}
@@ -178,10 +193,9 @@
 	saa_writel(SAA7134_RS_CONTROL(6),control);
 	
 	/* start dma */
+	dev->oss.recording_on = 1;
 	spin_lock_irqsave(&dev->slock,flags);
-	dev->oss.recording = 1;
-	dev->oss.dma_blk   = 0;
-	saa7134_set_dmabits(dev);
+	dsp_dma_start(dev);
 	spin_unlock_irqrestore(&dev->slock,flags);
 	return 0;
 
@@ -199,10 +213,9 @@
 	dprintk("rec_stop dma_blk=%d\n",dev->oss.dma_blk);
 
 	/* stop dma */
+	dev->oss.recording_on = 0;
 	spin_lock_irqsave(&dev->slock,flags);
-	dev->oss.dma_blk   = -1;
-	dev->oss.recording = 0;
-	saa7134_set_dmabits(dev);
+	dsp_dma_stop(dev);
 	spin_unlock_irqrestore(&dev->slock,flags);
 
 	/* unlock buffer */
@@ -259,7 +272,7 @@
 	struct saa7134_dev *dev = file->private_data;
 
 	down(&dev->oss.lock);
-	if (dev->oss.recording)
+	if (dev->oss.recording_on)
 		dsp_rec_stop(dev);
 	dsp_buffer_free(dev);
 	dev->oss.users_dsp--;
@@ -274,6 +287,7 @@
 	struct saa7134_dev *dev = file->private_data;
 	DECLARE_WAITQUEUE(wait, current);
 	unsigned int bytes;
+	unsigned long flags;
 	int err,ret = 0;
 
 	add_wait_queue(&dev->oss.wq, &wait);
@@ -281,7 +295,7 @@
 	while (count > 0) {
 		/* wait for data if needed */
 		if (0 == dev->oss.read_count) {
-			if (!dev->oss.recording) {
+			if (!dev->oss.recording_on) {
 				err = dsp_rec_start(dev);
 				if (err < 0) {
 					if (0 == ret)
@@ -289,6 +303,13 @@
 					break;
 				}
 			}
+			if (dev->oss.recording_on &&
+			    !dev->oss.dma_running) {
+				/* recover from overruns */
+				spin_lock_irqsave(&dev->slock,flags);
+				dsp_dma_start(dev);
+				spin_unlock_irqrestore(&dev->slock,flags);
+			}
 			if (file->f_flags & O_NONBLOCK) {
 				if (0 == ret)
 					ret = -EAGAIN;
@@ -365,7 +386,7 @@
 			return -EFAULT;
 		down(&dev->oss.lock);
 		dev->oss.channels = val ? 2 : 1;
-		if (dev->oss.recording) {
+		if (dev->oss.recording_on) {
 			dsp_rec_stop(dev);
 			dsp_rec_start(dev);
 		}
@@ -379,7 +400,7 @@
 			return -EINVAL;
 		down(&dev->oss.lock);
 		dev->oss.channels = val;
-		if (dev->oss.recording) {
+		if (dev->oss.recording_on) {
 			dsp_rec_stop(dev);
 			dsp_rec_start(dev);
 		}
@@ -408,7 +429,7 @@
 		case AFMT_S16_BE:
 			down(&dev->oss.lock);
 			dev->oss.afmt = val;
-			if (dev->oss.recording) {
+			if (dev->oss.recording_on) {
 				dsp_rec_stop(dev);
 				dsp_rec_start(dev);
 			}
@@ -438,7 +459,7 @@
 
         case SNDCTL_DSP_RESET:
 		down(&dev->oss.lock);
-		if (dev->oss.recording)
+		if (dev->oss.recording_on)
 			dsp_rec_stop(dev);
 		up(&dev->oss.lock);
 		return 0;
@@ -448,7 +469,7 @@
         case SNDCTL_DSP_SETFRAGMENT:
 		if (get_user(val, (int*)arg))
 			return -EFAULT;
-		if (dev->oss.recording)
+		if (dev->oss.recording_on)
 			return -EBUSY;
 		dsp_buffer_free(dev);
 		dsp_buffer_conf(dev,1 << (val & 0xffff), (arg >> 16) & 0xffff);
@@ -484,7 +505,7 @@
 
 	if (0 == dev->oss.read_count) {
 		down(&dev->oss.lock);
-		if (!dev->oss.recording)
+		if (!dev->oss.recording_on)
 			dsp_rec_start(dev);
 		up(&dev->oss.lock);
 	} else
@@ -800,7 +821,7 @@
 	if (dev->oss.read_count >= dev->oss.blksize * (dev->oss.blocks-2)) {
 		dprintk("irq: overrun [full=%d/%d]\n",dev->oss.read_count,
 			dev->oss.bufsize);
-		dsp_rec_stop(dev);
+		dsp_dma_stop(dev);
 		goto done;
 	}
 
diff -u linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-input.c linux/drivers/media/video/saa7134/saa7134-input.c
--- linux-2.6.5-$(shell/drivers/media/video/saa7134/saa7134-input.c	2004-04-04 18:11:19.000000000 +0200
+++ linux/drivers/media/video/saa7134/saa7134-input.c	2004-04-21 16:54:31.764207214 +0200
@@ -19,8 +19,8 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/input.h>
 #include <linux/delay.h>
+#include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/input.h>
 
@@ -100,42 +100,42 @@
 	[ 0x23 ] = KEY_STOP,
 };
 
-/* Alfons Geser <a.geser@cox.net> */
+/* Alfons Geser <a.geser@cox.net>
+ * updates from Job D. R. Borges <jobdrb@ig.com.br> */
 static IR_KEYTAB_TYPE eztv_codes[IR_KEYTAB_SIZE] = {
         [ 18 ] = KEY_POWER,
         [  1 ] = KEY_TV,             // DVR
-        [ 21 ] = KEY_VIDEO,          // DVD
+        [ 21 ] = KEY_DVD,            // DVD
         [ 23 ] = KEY_AUDIO,          // music
-
                                      // DVR mode / DVD mode / music mode
 
         [ 27 ] = KEY_MUTE,           // mute
-        [  2 ] = KEY_RESERVED,       // MTS/SAP / audio /autoseek
-        [ 30 ] = KEY_RESERVED,       // closed captioning / subtitle / seek
+        [  2 ] = KEY_LANGUAGE,       // MTS/SAP / audio / autoseek
+        [ 30 ] = KEY_SUBTITLE,       // closed captioning / subtitle / seek
         [ 22 ] = KEY_ZOOM,           // full screen
-        [ 28 ] = KEY_RESERVED,       // video source / eject /delall
-        [ 29 ] = KEY_RESERVED,       // playback / angle /del
+        [ 28 ] = KEY_VIDEO,          // video source / eject / delall
+        [ 29 ] = KEY_RESTART,        // playback / angle / del
         [ 47 ] = KEY_SEARCH,         // scan / menu / playlist
-        [ 48 ] = KEY_RESERVED,       // CH surfing / bookmark / memo
+        [ 48 ] = KEY_CHANNEL,        // CH surfing / bookmark / memo
 
         [ 49 ] = KEY_HELP,           // help
-        [ 50 ] = KEY_RESERVED,       // num/memo
+        [ 50 ] = KEY_MODE,           // num/memo
         [ 51 ] = KEY_ESC,            // cancel
 
 	[ 12 ] = KEY_UP,             // up
 	[ 16 ] = KEY_DOWN,           // down
 	[  8 ] = KEY_LEFT,           // left
 	[  4 ] = KEY_RIGHT,          // right
-	[  3 ] = KEY_ENTER,          // select
+	[  3 ] = KEY_SELECT,         // select
 
 	[ 31 ] = KEY_REWIND,         // rewind
 	[ 32 ] = KEY_PLAYPAUSE,      // play/pause
 	[ 41 ] = KEY_FORWARD,        // forward
-	[ 20 ] = KEY_RESERVED,       // repeat
+	[ 20 ] = KEY_AGAIN,          // repeat
 	[ 43 ] = KEY_RECORD,         // recording
 	[ 44 ] = KEY_STOP,           // stop
 	[ 45 ] = KEY_PLAY,           // play
-	[ 46 ] = KEY_RESERVED,       // snapshot
+	[ 46 ] = KEY_SHUFFLE,        // snapshot / shuffle
 
         [  0 ] = KEY_KP0,
         [  5 ] = KEY_KP1,
@@ -147,7 +147,7 @@
         [ 13 ] = KEY_KP7,
         [ 14 ] = KEY_KP8,
         [ 15 ] = KEY_KP9,
-
+ 
         [ 42 ] = KEY_VOLUMEUP,
         [ 17 ] = KEY_VOLUMEDOWN,
         [ 24 ] = KEY_CHANNELUP,      // CH.tracking up
