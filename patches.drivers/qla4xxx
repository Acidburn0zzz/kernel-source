From: Ravi Anand <ravi.anand@qlogic.com>
Subject: qla4xxx : Driver v5.00.05b4-k
References: 155458 - LTC22173 - LDP 112936

This patch includes the qla4xxx driver v5.00-05b5-k

Acked-by: Hannes Reinecke <hare@suse.de>

diff --git a/Documentation/scsi/LICENSE.qla4xxx b/Documentation/scsi/LICENSE.qla4xxx
new file mode 100644
index 0000000..b12cd7a
--- /dev/null
+++ b/Documentation/scsi/LICENSE.qla4xxx
@@ -0,0 +1,45 @@
+Copyright (c)  2003-2006 QLogic Corporation
+QLogic Linux iSCSI HBA Driver
+
+This program includes a device driver for Linux 2.6 that may be
+distributed with QLogic hardware specific firmware binary file.
+You may modify and redistribute the device driver code under the
+GNU General Public License as published by the Free Software
+Foundation (version 2 or a later version).
+
+You may redistribute the hardware specific firmware binary file
+under the following terms:
+
+	1. Redistribution of source code (only if applicable),
+	   must retain the above copyright notice, this list of
+	   conditions and the following disclaimer.
+
+	2. Redistribution in binary form must reproduce the above
+	   copyright notice, this list of conditions and the
+	   following disclaimer in the documentation and/or other
+	   materials provided with the distribution.
+
+	3. The name of QLogic Corporation may not be used to
+	   endorse or promote products derived from this software
+	   without specific prior written permission
+
+REGARDLESS OF WHAT LICENSING MECHANISM IS USED OR APPLICABLE,
+THIS PROGRAM IS PROVIDED BY QLOGIC CORPORATION "AS IS'' AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+USER ACKNOWLEDGES AND AGREES THAT USE OF THIS PROGRAM WILL NOT
+CREATE OR GIVE GROUNDS FOR A LICENSE BY IMPLICATION, ESTOPPEL, OR
+OTHERWISE IN ANY INTELLECTUAL PROPERTY RIGHTS (PATENT, COPYRIGHT,
+TRADE SECRET, MASK WORK, OR OTHER PROPRIETARY RIGHT) EMBODIED IN
+ANY OTHER QLOGIC HARDWARE OR SOFTWARE EITHER SOLELY OR IN
+COMBINATION WITH THIS PROGRAM.
diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
index 3c606cf..2ca97cf 100644
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -1340,6 +1340,7 @@ config SCSI_QLOGICPTI
 	  module will be called qlogicpti.
 
 source "drivers/scsi/qla2xxx/Kconfig"
+source "drivers/scsi/qla4xxx/Kconfig"
 
 config SCSI_LPFC
 	tristate "Emulex LightPulse Fibre Channel Support"
diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
index 320e765..265628a 100644
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -81,6 +81,7 @@ obj-$(CONFIG_PCMCIA_QLOGIC)	+= qlogicfas
 obj-$(CONFIG_SCSI_QLOGIC_FC)	+= qlogicfc.o 
 obj-$(CONFIG_SCSI_QLOGIC_1280)	+= qla1280.o 
 obj-$(CONFIG_SCSI_QLA_FC)	+= qla2xxx/
+obj-$(CONFIG_SCSI_QLA_ISCSI)	+= qla4xxx/
 obj-$(CONFIG_SCSI_LPFC)		+= lpfc/
 obj-$(CONFIG_SCSI_PAS16)	+= pas16.o
 obj-$(CONFIG_SCSI_SEAGATE)	+= seagate.o
diff --git a/drivers/scsi/qla4xxx/Kconfig b/drivers/scsi/qla4xxx/Kconfig
new file mode 100644
index 0000000..6492798
--- /dev/null
+++ b/drivers/scsi/qla4xxx/Kconfig
@@ -0,0 +1,5 @@
+config SCSI_QLA_ISCSI
+	tristate "QLogic ISP4XXX host adapter family support"
+	depends on PCI && SCSI
+	---help---
+	This driver supports the QLogic 40xx (ISP4XXX) host adapter family.
diff --git a/drivers/scsi/qla4xxx/Makefile b/drivers/scsi/qla4xxx/Makefile
new file mode 100644
index 0000000..86ea37b
--- /dev/null
+++ b/drivers/scsi/qla4xxx/Makefile
@@ -0,0 +1,5 @@
+qla4xxx-y := ql4_os.o ql4_init.o ql4_mbx.o ql4_iocb.o ql4_isr.o \
+		ql4_nvram.o ql4_dbg.o
+
+obj-$(CONFIG_SCSI_QLA_ISCSI) += qla4xxx.o
+
diff --git a/drivers/scsi/qla4xxx/ql4_attr.c b/drivers/scsi/qla4xxx/ql4_attr.c
new file mode 100644
index 0000000..9955d0b
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_attr.c
@@ -0,0 +1,273 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#include "ql4_def.h"
+#include <scsi/scsi_transport_iscsi.h>
+
+/* Host attributes. */
+
+static void qla4xxx_get_initiator_name(struct Scsi_Host *shost)
+{
+	scsi_qla_host_t *ha = to_qla_host(shost);
+
+	/* &ha->iscsi_name[0]; */
+	/*  ha->ip_address[0], ha->ip_address[1], ha->ip_address[2], ha->ip_address[3]) */
+	/* ha->subnet_mask[0], ha->subnet_mask[1], ha->subnet_mask[2], ha->subnet_mask[3]) */
+	/* init_fw_cb->GatewayIPAddr[0],
+			init_fw_cb->GatewayIPAddr[1],
+			init_fw_cb->GatewayIPAddr[2],
+			init_fw_cb->GatewayIPAddr[3]) */
+
+}
+
+static void qla4xxx_get_initiator_alias(struct Scsi_Host *shost)
+{
+	scsi_qla_host_t *ha = to_qla_host(shost);
+}
+
+/* Target attributes. */
+static void qla4xxx_get_isid(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	scsi_qla_host_t *ha = to_qla_host(shost);
+	struct ddb_entry *ddb;
+}
+
+static void qla4xxx_get_tsih(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	scsi_qla_host_t *ha = to_qla_host(shost);
+	struct ddb_entry *ddb = qla4xxx_lookup_ddb_by_fw_index(ha, starget->id);
+}
+
+static void qla4xxx_get_ip_address(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	scsi_qla_host_t *ha = to_qla_host(shost);
+	struct ddb_entry *ddb = qla4xxx_lookup_ddb_by_fw_index(ha, starget->id);
+
+	if (ddb)
+		memcpy(&iscsi_sin_addr(starget), &ddb->ipaddress,
+		    ISCSI_IPADDR_SIZE);
+}
+
+static void qla4xxx_get_port(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	scsi_qla_host_t *ha = to_qla_host(shost);
+	struct ddb_entry *ddb = qla4xxx_lookup_ddb_by_fw_index(ha, starget->id);
+
+	struct sockaddr_in *addr = (struct sockaddr_in *)&ddb->addr;
+	iscsi_port(starget) = addr->sin_port;
+}
+
+static void qla4xxx_get_tpgt(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	scsi_qla_host_t *ha = to_qla_host(shost);
+	struct ddb_entry *ddb = qla4xxx_lookup_ddb_by_fw_index(ha, starget->id);
+
+	iscsi_tpgt(starget) = ddb->portal_group_tag;
+}
+
+static void qla4xxx_get_isid(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	scsi_qla_host_t *ha = to_qla_host(shost);
+	struct ddb_entry *ddb = qla4xxx_lookup_ddb_by_fw_index(ha, starget->id);
+
+	memcpy(iscsi_isid(starget), ddb->isid, sizeof(ddb->isid));
+}
+
+static void qla4xxx_get_initial_r2t(struct scsi_target *starget)
+{
+}
+
+static void qla4xxx_get_immediate_data(struct scsi_target *starget)
+{
+}
+
+static void qla4xxx_get_header_digest(struct scsi_target *starget)
+{
+}
+
+static void qla4xxx_get_data_digest(struct scsi_target *starget)
+{
+}
+
+static void qla4xxx_get_max_burst_len(struct scsi_target *starget)
+{
+}
+
+static void qla4xxx_get_first_burst_len(struct scsi_target *starget)
+{
+}
+
+static void qla4xxx_get_max_recv_data_segment_len(struct scsi_target *starget)
+{
+}
+
+static void qla4xxx_get_starget_loss_tmo(struct scsi_target *starget)
+{
+	struct Scsi_Host *host = dev_to_shost(starget->dev.parent);
+	scsi_qla_host_t *ha = to_qla_host(host);
+
+	iscsi_starget_dev_loss_tmo(starget) = ha->port_down_retry_count + 5;
+}
+
+static void
+qla4xxx_set_starget_loss_tmo(struct scsi_target *starget, uint32_t timeout)
+{
+	struct Scsi_Host *host = dev_to_shost(starget->dev.parent);
+	scsi_qla_host_t *ha = to_qla_host(host);
+
+	if (timeout)
+		ha->port_down_retry_count = timeout;
+	else
+		ha->port_down_retry_count = 1;
+}
+
+static struct fc_function_template qla4xxx_transport_functions = {
+	.get_isid = qla4xxx_get_isid,
+	.show_isid = 1,
+	.get_tsih = qla4xxx_get_tsih,
+	.show_tsih = 1,
+	.get_port = qla4xxx_get_target_port,
+	.show_port = 1,
+	.get_tpgt = qla4xxx_get_tpgt,
+	.show_tpgt = 1,
+	.get_ip_address = qla4xxx_get_target_ip_address,
+	.show_ip_address = 1,
+	.get_initial_r2t = qla4xxx_get_initial_r2t,
+	.show_initial_r2t = 1,
+	.get_immediate_data = qla4xxx_get_immediate_data,
+	.show_immediate_data = 1,
+	.get_header_digest = qla4xxx_get_header_digest,
+	.show_header_digest = 1,
+	.get_data_digest = qla4xxx_get_data_digest,
+	.show_data_digest = 1,
+	.get_max_burst_len = qla4xxx_get_max_burst_len,
+	.show_max_burst_len = 1,
+	.get_first_burst_len = qla4xxx_get_first_burst_len,
+	.show_first_burst_len = 1,
+	.get_max_recv_data_segment_len = qla4xxx_get_max_recv_data_segment_len,
+	.show_max_recv_data_segment_len = 1,
+	.get_target_name = qla4xxx_get_target_name,
+	.show_target_name = 1,
+	.get_target_alias = qla4xxx_get_target_alias,
+	.show_target_alias = 1,
+	.get_initiator_alias = qla4xxx_get_initiator_alias,
+	.show_initiator_alias = 1,
+	.get_initiator_name = qla4xxx_get_initiator_name,
+	.show_initiator_name = 1,
+
+	.get_starget_dev_loss_tmo = qla4xxx_get_starget_loss_tmo,
+	.set_starget_dev_loss_tmo = qla4xxx_set_starget_loss_tmo,
+	.show_starget_dev_loss_tmo = 1,
+
+};
+
+struct scsi_transport_template *qla4xxx_alloc_transport_tmpl(void)
+{
+	return (iscsi_attach_transport(&qla4xxx_transport_functions));
+}
+
+/* SYSFS attributes --------------------------------------------------------- */
+
+static ssize_t
+qla4xxx_sysfs_read_nvram(struct kobject *kobj, char *buf, loff_t off,
+    size_t count)
+{
+	struct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,
+	    struct device, kobj)));
+	uint16_t *witer;
+	unsigned long flags;
+	uint16_t cnt;
+
+	if (!capable(CAP_SYS_ADMIN) || off != 0 || count != sizeof(nvram_t))
+		return 0;
+
+	/* Read NVRAM. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	qla4xxx_lock_nvram_access(ha);
+	witer = (uint16_t *) buf;
+	for (cnt = 0; cnt < count / 2; cnt++) {
+		*witer = cpu_to_le16(qla2x00_get_nvram_word(ha,
+		    cnt + ha->nvram_base));
+		witer++;
+	}
+	qla4xxx_unlock_nvram_access(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return (count);
+}
+
+static ssize_t
+qla4xxx_sysfs_write_nvram(struct kobject *kobj, char *buf, loff_t off,
+    size_t count)
+{
+	struct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,
+	    struct device, kobj)));
+	uint8_t *iter;
+	uint16_t *witer;
+	unsigned long flags;
+	uint16_t cnt;
+	uint8_t chksum;
+
+	if (!capable(CAP_SYS_ADMIN) || off != 0 || count != sizeof(nvram_t))
+		return 0;
+
+	/* Checksum NVRAM. */
+	iter = (uint8_t *) buf;
+	chksum = 0;
+	for (cnt = 0; cnt < count - 1; cnt++)
+		chksum += *iter++;
+	chksum = ~chksum + 1;
+	*iter = chksum;
+
+	/* Write NVRAM. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	qla4xxx_lock_nvram_access(ha);
+	qla4xxx_release_nvram_protection(ha);
+	witer = (uint16_t *) buf;
+	for (cnt = 0; cnt < count / 2; cnt++) {
+		qla4xxx_write_nvram_word(ha, cnt + ha->nvram_base,
+		    cpu_to_le16(*witer));
+		witer++;
+	}
+	qla4xxx_unlock_nvram_access(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return (count);
+}
+
+static struct bin_attribute sysfs_nvram_attr = {
+	.attr = {
+		 .name = "nvram",
+		 .mode = S_IRUSR | S_IWUSR,
+		 .owner = THIS_MODULE,
+		 },
+	.size = sizeof(nvram_t),
+	.read = qla4xxx_sysfs_read_nvram,
+	.write = qla4xxx_sysfs_write_nvram,
+};
+
+void qla4xxx_alloc_sysfs_attr(scsi_qla_host_t * ha)
+{
+	struct Scsi_Host *host = ha->host;
+
+	sysfs_create_bin_file(&host->shost_gendev.kobj, &sysfs_fw_dump_attr);
+	sysfs_create_bin_file(&host->shost_gendev.kobj, &sysfs_nvram_attr);
+}
+
+void qla4xxx_free_sysfs_attr(scsi_qla_host_t * ha)
+{
+	struct Scsi_Host *host = ha->host;
+
+	sysfs_remove_bin_file(&host->shost_gendev.kobj, &sysfs_fw_dump_attr);
+	sysfs_remove_bin_file(&host->shost_gendev.kobj, &sysfs_nvram_attr);
+}
diff --git a/drivers/scsi/qla4xxx/ql4_dbg.c b/drivers/scsi/qla4xxx/ql4_dbg.c
new file mode 100644
index 0000000..2649e49
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_dbg.c
@@ -0,0 +1,211 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#include "ql4_def.h"
+
+/*
+ * qla4xxx_print_srb_cmd
+ *	This routine displays the SRB command
+ */
+static void qla4xxx_print_srb_info(srb_t * srb)
+{
+	printk("%s: srb = 0x%p, flags=0x%02x\n", __func__, srb, srb->flags);
+	printk("%s: cmd = 0x%p, saved_dma_handle = 0x%lx\n",
+	       __func__, srb->cmd, (unsigned long) srb->dma_handle);
+	printk("%s: fw_ddb_index = %d, lun = %d\n",
+	       __func__, srb->fw_ddb_index, srb->cmd->device->lun);
+	printk("%s: iocb_tov = %d\n",
+	       __func__, srb->iocb_tov);
+	printk("%s: cc_stat = 0x%x, r_start = 0x%lx, u_start = 0x%lx\n\n",
+	       __func__, srb->cc_stat, srb->r_start, srb->u_start);
+}
+
+/*
+ * qla4xxx_print_scsi_cmd
+ *	This routine displays the SCSI command
+ */
+void qla4xxx_print_scsi_cmd(struct scsi_cmnd *cmd)
+{
+	int i;
+	printk("SCSI Command = 0x%p, Handle=0x%p\n", cmd, cmd->host_scribble);
+	printk("  b=%d, t=%02xh, l=%02xh, cmd_len = %02xh\n",
+	       cmd->device->channel, cmd->device->id, cmd->device->lun,
+	       cmd->cmd_len);
+	printk("  CDB = ");
+	for (i = 0; i < cmd->cmd_len; i++)
+		printk("%02x ", cmd->cmnd[i]);
+	printk("  seg_cnt = %d\n", cmd->use_sg);
+	printk("  request buffer = 0x%p, request buffer len = 0x%x\n",
+	       cmd->request_buffer, cmd->request_bufflen);
+	if (cmd->use_sg) {
+		struct scatterlist *sg;
+		sg = (struct scatterlist *)cmd->request_buffer;
+		printk("  SG buffer: \n");
+		qla4xxx_dump_buffer((caddr_t) sg,
+				    (cmd->use_sg * sizeof(struct scatterlist)));
+	}
+	printk("  tag = %d, transfersize = 0x%x \n", cmd->tag,
+	       cmd->transfersize);
+	printk("  Pid = %d, SP = 0x%p\n", (int)cmd->pid, CMD_SP(cmd));
+	printk("  underflow size = 0x%x, direction=0x%x\n", cmd->underflow,
+	       cmd->sc_data_direction);
+	printk("  Current time (jiffies) = 0x%lx, "
+	       "timeout expires = 0x%lx\n", jiffies, cmd->eh_timeout.expires);
+	qla4xxx_print_srb_info((srb_t *) CMD_SP(cmd));
+}
+
+void __dump_registers(scsi_qla_host_t * ha)
+{
+	uint8_t i;
+	for (i = 0; i < MBOX_REG_COUNT; i++) {
+		printk(KERN_INFO "0x%02X mailbox[%d]      = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, mailbox[i]), i,
+		       RD_REG_DWORD(&ha->reg->mailbox[i]));
+	}
+	printk(KERN_INFO "0x%02X flash_address   = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, flash_address),
+	       RD_REG_DWORD(&ha->reg->flash_address));
+	printk(KERN_INFO "0x%02X flash_data      = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, flash_data),
+	       RD_REG_DWORD(&ha->reg->flash_data));
+	printk(KERN_INFO "0x%02X ctrl_status     = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, ctrl_status),
+	       RD_REG_DWORD(&ha->reg->ctrl_status));
+	if (IS_QLA4010(ha)) {
+		printk(KERN_INFO "0x%02X nvram           = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u1.isp4010.nvram),
+		       RD_REG_DWORD(&ha->reg->u1.isp4010.nvram));
+	}
+
+	else if (IS_QLA4022(ha)) {
+		printk(KERN_INFO "0x%02X intr_mask       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u1.isp4022.intr_mask),
+		       RD_REG_DWORD(&ha->reg->u1.isp4022.intr_mask));
+		printk(KERN_INFO "0x%02X nvram           = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u1.isp4022.nvram),
+		       RD_REG_DWORD(&ha->reg->u1.isp4022.nvram));
+		printk(KERN_INFO "0x%02X semaphore       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u1.isp4022.semaphore),
+		       RD_REG_DWORD(&ha->reg->u1.isp4022.semaphore));
+	}
+	printk(KERN_INFO "0x%02X req_q_in        = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, req_q_in),
+	       RD_REG_DWORD(&ha->reg->req_q_in));
+	printk(KERN_INFO "0x%02X rsp_q_out       = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, rsp_q_out),
+	       RD_REG_DWORD(&ha->reg->rsp_q_out));
+	if (IS_QLA4010(ha)) {
+		printk(KERN_INFO "0x%02X ext_hw_conf     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.ext_hw_conf),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.ext_hw_conf));
+		printk(KERN_INFO "0x%02X port_ctrl       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.port_ctrl),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_ctrl));
+		printk(KERN_INFO "0x%02X port_status     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.port_status),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_status));
+		printk(KERN_INFO "0x%02X req_q_out       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.req_q_out),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.req_q_out));
+		printk(KERN_INFO "0x%02X gp_out          = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.gp_out),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.gp_out));
+		printk(KERN_INFO "0x%02X gp_in           = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.gp_in),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.gp_in));
+		printk(KERN_INFO "0x%02X port_err_status = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t,
+					  u2.isp4010.port_err_status),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_err_status));
+	}
+
+	else if (IS_QLA4022(ha)) {
+		printk(KERN_INFO "Page 0 Registers:\n");
+		printk(KERN_INFO "0x%02X ext_hw_conf     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t,
+					  u2.isp4022.p0.ext_hw_conf),
+		       RD_REG_DWORD(&ha->reg->u2.isp4022.p0.ext_hw_conf));
+		printk(KERN_INFO "0x%02X port_ctrl       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t,
+					  u2.isp4022.p0.port_ctrl),
+		       RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_ctrl));
+		printk(KERN_INFO "0x%02X port_status     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t,
+					  u2.isp4022.p0.port_status),
+		       RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_status));
+		printk(KERN_INFO "0x%02X gp_out          = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.gp_out),
+		       RD_REG_DWORD(&ha->reg->u2.isp4022.p0.gp_out));
+		printk(KERN_INFO "0x%02X gp_in           = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.gp_in),
+		       RD_REG_DWORD(&ha->reg->u2.isp4022.p0.gp_in));
+		printk(KERN_INFO "0x%02X port_err_status = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t,
+					  u2.isp4022.p0.port_err_status),
+		       RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_err_status));
+		printk(KERN_INFO "Page 1 Registers:\n");
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+			      HOST_MEM_CFG_PAGE &
+			      SET_RMASK(CSR_SCSI_PAGE_SELECT));
+		printk(KERN_INFO "0x%02X req_q_out       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t,
+					  u2.isp4022.p1.req_q_out),
+		       RD_REG_DWORD(&ha->reg->u2.isp4022.p1.req_q_out));
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+			      PORT_CTRL_STAT_PAGE &
+			      SET_RMASK(CSR_SCSI_PAGE_SELECT));
+	}
+}
+
+/*
+ * qla4xxx_dump_registers
+ *	This routine displays ISP registers
+ *
+ * Input:
+ *	ha       - adapter structure pointer
+ *
+ */
+void qla4xxx_dump_mbox_registers(scsi_qla_host_t * ha)
+{
+	unsigned long flags = 0;
+	int i = 0;
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (i = 1; i < MBOX_REG_COUNT; i++)
+		printk(KERN_INFO "  Mailbox[%d] = %08x\n", i,
+		       RD_REG_DWORD(&ha->reg->mailbox[i]));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+void qla4xxx_dump_registers(scsi_qla_host_t * ha)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__dump_registers(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+void qla4xxx_dump_buffer(uint8_t * b, uint32_t size)
+{
+	uint32_t cnt;
+	uint8_t c;
+	printk(" 0   1   2   3   4   5   6   7   8   9  Ah  Bh  Ch  Dh  Eh  "
+	    "Fh\n");
+	printk("------------------------------------------------------------"
+	    "--\n");
+	for (cnt = 0; cnt < size;) {
+		c = *b++;
+		printk("%02x", (uint32_t) c);
+		cnt++;
+		if (!(cnt % 16))
+			printk("\n");
+
+		else
+			printk("  ");
+	}
+	if (cnt % 16)
+		printk("\n");
+}
diff --git a/drivers/scsi/qla4xxx/ql4_dbg.h b/drivers/scsi/qla4xxx/ql4_dbg.h
new file mode 100644
index 0000000..d9a8fa9
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_dbg.h
@@ -0,0 +1,64 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+/*
+ * Driver debug definitions.
+ */
+/* #define QL_DEBUG  */			/* DEBUG messages */
+/* #define QL_DEBUG_LEVEL_3  */		/* Output function tracing */
+/* #define QL_DEBUG_LEVEL_4  */
+/* #define QL_DEBUG_LEVEL_5  */
+/* #define QL_DEBUG_LEVEL_9  */
+
+#define QL_DEBUG_LEVEL_2	/* ALways enable error messagess */
+#if defined(QL_DEBUG)
+#define DEBUG(x)   do {x;} while (0);
+#else
+#define DEBUG(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_2)
+#define DEBUG2(x)      do {if(extended_error_logging == 2) x;} while (0);
+#define DEBUG2_3(x)   do {x;} while (0);
+#else				/*  */
+#define DEBUG2(x)	do {} while (0);
+#endif				/*  */
+
+#if defined(QL_DEBUG_LEVEL_3)
+#define DEBUG3(x)      do {if(extended_error_logging == 3) x;} while (0);
+#else				/*  */
+#define DEBUG3(x)	do {} while (0);
+#if !defined(QL_DEBUG_LEVEL_2)
+#define DEBUG2_3(x)	do {} while (0);
+#endif				/*  */
+#endif				/*  */
+#if defined(QL_DEBUG_LEVEL_4)
+#define DEBUG4(x)	do {x;} while (0);
+#else				/*  */
+#define DEBUG4(x)	do {} while (0);
+#endif				/*  */
+
+#if defined(QL_DEBUG_LEVEL_5)
+#define DEBUG5(x)	do {x;} while (0);
+#else				/*  */
+#define DEBUG5(x)	do {} while (0);
+#endif				/*  */
+
+#if defined(QL_DEBUG_LEVEL_9)
+#define DEBUG9(x)	do {x;} while (0);
+#else				/*  */
+#define DEBUG9(x)	do {} while (0);
+#endif				/*  */
+
+/*
+ *  Debug Print Routines.
+ */
+void qla4xxx_print_scsi_cmd(struct scsi_cmnd *cmd);
+void __dump_registers(scsi_qla_host_t * ha);
+void qla4xxx_dump_mbox_registers(scsi_qla_host_t * ha);
+void qla4xxx_dump_registers(scsi_qla_host_t * ha);
+void qla4xxx_dump_buffer(uint8_t * b, uint32_t size);
diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
new file mode 100644
index 0000000..4d1653c
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -0,0 +1,551 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#ifndef __QL4_DEF_H
+#define __QL4_DEF_H
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/dmapool.h>
+#include <linux/mempool.h>
+#include <linux/spinlock.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_transport.h>
+#include <scsi/scsi_transport_iscsi.h>
+
+/* XXX(dg): move to pci_ids.h */
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP4010
+#define PCI_DEVICE_ID_QLOGIC_ISP4010	0x4010
+#endif
+
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP4022
+#define PCI_DEVICE_ID_QLOGIC_ISP4022	0x4022
+#endif				/*  */
+
+#define IS_QLA4010(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4010)
+#define IS_QLA4022(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4022)
+
+#define QLA_SUCCESS			0
+#define QLA_ERROR			1
+
+/*
+ * Data bit definitions
+ */
+#define BIT_0	0x1
+#define BIT_1	0x2
+#define BIT_2	0x4
+#define BIT_3	0x8
+#define BIT_4	0x10
+#define BIT_5	0x20
+#define BIT_6	0x40
+#define BIT_7	0x80
+#define BIT_8	0x100
+#define BIT_9	0x200
+#define BIT_10	0x400
+#define BIT_11	0x800
+#define BIT_12	0x1000
+#define BIT_13	0x2000
+#define BIT_14	0x4000
+#define BIT_15	0x8000
+#define BIT_16	0x10000
+#define BIT_17	0x20000
+#define BIT_18	0x40000
+#define BIT_19	0x80000
+#define BIT_20	0x100000
+#define BIT_21	0x200000
+#define BIT_22	0x400000
+#define BIT_23	0x800000
+#define BIT_24	0x1000000
+#define BIT_25	0x2000000
+#define BIT_26	0x4000000
+#define BIT_27	0x8000000
+#define BIT_28	0x10000000
+#define BIT_29	0x20000000
+#define BIT_30	0x40000000
+#define BIT_31	0x80000000
+
+/*
+ * Host adapter default definitions
+ ***********************************/
+#define MAX_HBAS			16
+#define MAX_BUSES       		1
+#define MAX_TARGETS     		MAX_PRST_DEV_DB_ENTRIES + MAX_DEV_DB_ENTRIES
+#define MAX_LUNS        		0xffff
+#define MAX_AEN_ENTRIES 		256	/* should be > EXT_DEF_MAX_AEN_QUEUE */
+#define MAX_DDB_ENTRIES 		MAX_PRST_DEV_DB_ENTRIES + MAX_DEV_DB_ENTRIES
+#define MAX_PDU_ENTRIES                 32
+#define INVALID_ENTRY			0xFFFF
+#define MAX_CMDS_TO_RISC		1024
+#define MAX_SRBS			MAX_CMDS_TO_RISC
+#define MBOX_AEN_REG_COUNT		5
+#define MAX_INIT_RETRIES		5
+#define IOCB_HIWAT_CUSHION		16
+
+/*
+ * Buffer sizes
+ */
+#define REQUEST_QUEUE_DEPTH       	MAX_CMDS_TO_RISC
+#define RESPONSE_QUEUE_DEPTH      	64
+#define QUEUE_SIZE			64
+#define DMA_BUFFER_SIZE 		512
+
+/*
+ * Misc
+ */
+#define MAC_ADDR_LEN			6	/* in bytes */
+#define IP_ADDR_LEN			4	/* in bytes */
+#define DRIVER_NAME			"qla4xxx"
+
+#define MAX_LINKED_CMDS_PER_LUN		3
+#define MAX_REQS_SERVICED_PER_INTR	16
+
+#define	ISCSI_IPADDR_SIZE		4	/* IP address size */
+#define	ISCSI_ALIAS_SIZE		32	/* ISCSI Alais name size */
+#define	ISCSI_NAME_SIZE			255	/* ISCSI Name size  - usually a string */
+
+#define SYS_DELAY(x)		do {udelay(x);barrier();} while(0);
+#define QLA4XXX_DELAY(sec)  	do {mdelay(sec * 1000);} while(0);
+#define NVRAM_DELAY() 		do {udelay(500);} while(0);	/* 500 microsecond delay */
+
+#define LSB(x)	((uint8_t)(x))
+#define MSB(x)	((uint8_t)((uint16_t)(x) >> 8))
+#define LSW(x)	((uint16_t)(x))
+#define MSW(x)	((uint16_t)((uint32_t)(x) >> 16))
+#define LSDW(x)	((uint32_t)((uint64_t)(x)))
+#define MSDW(x)	((uint32_t)((((uint64_t)(x)) >> 16) >> 16))
+
+/*
+ * I/O port access macros
+ *************************/
+#define RD_REG_BYTE(addr)		readb(addr)
+#define RD_REG_WORD(addr)		readw(addr)
+#define RD_REG_DWORD(addr)		readl(addr)
+#define RD_REG_WORD_RELAXED(addr)	readw_relaxed(addr)
+#define RD_REG_DWORD_RELAXED(addr)	readl_relaxed(addr)
+#define WRT_REG_BYTE(addr, data)	writeb(data, addr)
+#define WRT_REG_WORD(addr, data)	writew(data, addr)
+#define WRT_REG_DWORD(addr, data)	writel(data, addr)
+
+#define PCI_POSTING(a) (RD_REG_DWORD(a))
+
+#define CMD_SP(Cmnd)	    ((Cmnd)->SCp.ptr)
+
+#include "ql4_fw.h"
+#include "ql4_nvram.h"
+
+/*
+ * Retry & Timeout Values
+ */
+#define MBOX_TOV			60
+#define SOFT_RESET_TOV			30
+#define RESET_INTR_TOV			3
+#define SEMAPHORE_TOV			10
+#define ADAPTER_INIT_TOV		120
+#define ADAPTER_RESET_TOV		180
+#define EXTEND_CMD_TOV			60
+#define WAIT_CMD_TOV			30
+#define EH_WAIT_CMD_TOV			120
+#define FIRMWARE_UP_TOV			60
+#define RESET_FIRMWARE_TOV        	30
+#define LOGOUT_TOV			10
+#define IOCB_TOV_MARGIN			10
+#define RELOGIN_TOV			18
+#define ISNS_DEREG_TOV			5
+
+#define MAX_RESET_HA_RETRIES		2
+
+/*
+ * SCSI Request Block structure  (srb)  that is placed
+ * on cmd->SCp location of every I/O     [We have 22 bytes available]
+ */
+typedef struct _srb_t {
+	struct list_head list;	/* (8)   */
+	struct scsi_qla_host *ha;	/* HA the SP is queued on */
+	struct ddb_entry 	*ddb;
+	uint16_t flags;		/* (1) Status flags. */
+
+#define SRB_DMA_VALID		BIT_3	/* DMA Buffer mapped. */
+
+#define SRB_GOT_SENSE		BIT_4	/* sense data recieved. */
+#define SRB_IOCTL_CMD		BIT_5	/* generated from an IOCTL. */
+#define SRB_BUSY		BIT_7	/* in busy retry state. */
+
+#define SRB_FO_CANCEL		BIT_8	/* don't need to failover. */
+#define SRB_RETRY		BIT_9	/* needs retrying. */
+#define SRB_TAPE		BIT_10	/* FCP2 (Tape) command. */
+	uint8_t state;		/* (1) Status flags. */
+
+#define SRB_NO_QUEUE_STATE	 0	/* Request is in between states */
+#define SRB_FREE_STATE		 1
+#define SRB_ACTIVE_STATE	 3
+#define SRB_ACTIVE_TIMEOUT_STATE 4
+#define SRB_SUSPENDED_STATE  	 7	/* Request in suspended state */
+
+	struct scsi_cmnd *cmd;	/* (4) SCSI command block */
+	dma_addr_t dma_handle;	/* (4) for unmap of single transfers */
+	atomic_t ref_count;	/* reference count for this srb */
+	uint32_t fw_ddb_index;
+	uint8_t err_id;		/* error id */
+#define SRB_ERR_PORT       1	/* Request failed because "port down" */
+#define SRB_ERR_LOOP       2	/* Request failed because "loop down" */
+#define SRB_ERR_DEVICE     3	/* Request failed because "device error" */
+#define SRB_ERR_OTHER      4
+
+	uint16_t reserved;
+	uint16_t iocb_tov;
+	uint16_t iocb_cnt;	/* Number of used iocbs */
+	uint16_t cc_stat;
+	u_long r_start;		/* Time we recieve a cmd from OS */
+	u_long u_start;		/* Time when we handed the cmd to F/W */
+} srb_t;
+
+/* Never set this to Zero */
+#define SUSPEND_SECONDS	6
+#define SUSPEND_RETRIES	1
+
+	/*
+	 * Device Database (DDB) structure
+	 */
+typedef struct ddb_entry {
+	struct list_head list;	/* ddb list */
+	struct scsi_qla_host *ha;
+	struct iscsi_cls_session	*session;
+	atomic_t state;		/* DDB State */
+
+	unsigned long flags;	/* DDB Flags */
+
+	unsigned long dev_scan_wait_to_start_relogin;
+	unsigned long dev_scan_wait_to_complete_relogin;
+
+	uint16_t os_target_id;	/* Target ID */
+	uint16_t fw_ddb_index;	/* DDB firmware index */
+	uint8_t reserved[2];
+	uint32_t fw_ddb_device_state;	/* F/W Device State  -- see ql4_fw.h */
+
+	uint32_t CmdSn;
+	uint16_t target_session_id;
+	uint16_t connection_id;
+	uint16_t exe_throttle;	/* Max mumber of cmds outstanding simultaneously */
+	uint16_t task_mgmt_timeout;	/* Min time for task mgmt cmds to complete */
+	uint16_t default_relogin_timeout;	/*  Max time to wait for relogin to complete */
+	uint16_t tcp_source_port_num;
+	uint32_t default_time2wait;	/* Default Min time between relogins (+aens) */
+
+	atomic_t port_down_timer;	/* Device connection timer */
+	atomic_t retry_relogin_timer;	/* Min Time between relogins (4000 only) */
+	atomic_t relogin_timer;	/* Max Time to wait for relogin to complete */
+	atomic_t relogin_retry_count;	/* Num of times relogin has been retried */
+
+	uint8_t ip_addr[ISCSI_IPADDR_SIZE];
+	uint8_t iscsi_name[ISCSI_NAME_SIZE];	/* 72 x48 */
+	uint8_t iscsi_alias[0x20];
+} ddb_entry_t;
+
+/*
+ * DDB states.
+ */
+#define DDB_STATE_DEAD		0	/* We can no longer talk to this device */
+#define DDB_STATE_ONLINE	1	/* Device ready to accept commands */
+#define DDB_STATE_MISSING	2	/* Device logged off, trying to re-login */
+#define DDB_STATE_TBL(){	  \
+		"DEAD"			, \
+		"ONLINE"		, \
+		"MISSING"		, \
+		NULL			  \
+	}
+
+/*
+ * DDB firmware states.
+ */
+/* defined in ql4_fw.h
+#define DDB_DS_UNASSIGNED                       0x00
+#define DDB_DS_NO_CONNECTION_ACTIVE             0x01
+#define DDB_DS_DISCOVERY                        0x02
+#define DDB_DS_NO_SESSION_ACTIVE                0x03
+#define DDB_DS_SESSION_ACTIVE                   0x04
+#define DDB_DS_LOGGING_OUT                      0x05
+#define DDB_DS_SESSION_FAILED                   0x06
+#define DDB_DS_LOGIN_IN_PROCESS                 0x07
+*/
+
+/*
+ * DDB flags.
+ */
+#define DF_RELOGIN		0	/* Relogin to device */
+#define DF_NO_RELOGIN		1	/* Do not relogin if IOCTL logged it out */
+#define DF_ISNS_DISCOVERED	2	/* Device was discovered via iSNS */
+#define DF_FO_MASKED		3
+#define DF_RESET_NEEDED		4
+#define DF_PERSISTENT_BOUND	5
+#define DF_TAPE_PRESENT		6
+#define DF_CONFIG_DEVICE        7
+#define DF_RESCAN_NEEDED	8
+/*
+ * DDB port type.
+ */
+typedef enum { FCT_UNKNOWN, FCT_BROADCAST, FCT_INITIATOR, FCT_TARGET
+} ddb_port_type_t;
+
+/*
+ * Asynchronous Event Queue structure
+ */
+typedef struct {
+	uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
+} aen_t;
+
+
+/*
+ * ISP Initialization Control Block.
+ * Little endian except where noted.
+ */
+typedef struct {
+	uint16_t firmware_options;
+	uint16_t tcp_options;
+	uint8_t ip_address[IP_ADDR_LEN];
+	uint8_t isns_ip_address[IP_ADDR_LEN];
+	uint16_t isns_server_port_number;
+	uint8_t alias[32];
+	uint8_t name_string[256];
+	uint8_t heartbeat_interval;
+	uint8_t rsvd;
+} init_cb_t;
+
+/*
+ * Linux Host Adapter structure
+ */
+typedef struct scsi_qla_host {
+	/* Linux adapter configuration data */
+	struct Scsi_Host *host;	/* pointer to host data */
+	uint32_t tot_ddbs;
+	unsigned long flags;
+
+#define AF_ONLINE		      0	/* 0x00000001 */
+#define AF_INIT_DONE		      1	/* 0x00000002 */
+#define AF_MBOX_COMMAND 	      2	/* 0x00000004 */
+#define AF_MBOX_COMMAND_DONE 	      3	/* 0x00000008 */
+#define AF_DPC_SCHEDULED	      5	/* 0x00000020 */
+#define AF_INTERRUPTS_ON	      6	/* 0x00000040 Not Used */
+#define AF_GET_CRASH_RECORD	      7	/* 0x00000080 */
+#define AF_LINK_UP		      8	/* 0x00000100 */
+#define AF_TOPCAT_CHIP_PRESENT	      9	/* 0x00000200 */
+#define AF_IRQ_ATTACHED	      	     10	/* 0x00000400 */
+#define AF_64BIT_PCI_ADDR	     11	/* 0x00000800 */
+	unsigned long dpc_flags;
+
+#define DPC_RESET_HA		      1	/* 0x00000002 */
+#define DPC_RETRY_RESET_HA	      2	/* 0x00000004 */
+#define DPC_RELOGIN_DEVICE	      3	/* 0x00000008 */
+#define DPC_RESET_HA_DESTROY_DDB_LIST 4	/* 0x00000010 */
+#define DPC_RESET_HA_INTR	      5	/* 0x00000020 */
+#define DPC_ISNS_RESTART	      7	/* 0x00000080 */
+#define DPC_ISNS_RESTART_COMPLETION   8	/* 0x00000100 */
+#define DPC_AEN			      9	/* 0x00000200 */
+#define DPC_CHECK_LUN			10	/* 0x00000200 */
+#define DPC_WAIT_TO_RELOGIN_DEVICE   11
+#define DPC_GET_DHCP_IP_ADDR	     15	/* 0x00008000 */
+
+	uint16_t        iocb_cnt;
+     	uint16_t        iocb_hiwat;
+
+	/* SRB cache. */
+#define SRB_MIN_REQ	128
+	mempool_t *srb_mempool;
+
+	/* pci information */
+	struct pci_dev *pdev;
+
+	/* isp_reg_t *reg; */
+	isp_reg_t __iomem *reg;	/* Base I/O address */
+	unsigned long pio_address;
+	unsigned long pio_length;
+#define MIN_IOBASE_LEN		0x100
+
+	uint16_t req_q_count;
+	uint8_t marker_needed;
+	uint8_t rsvd1;
+
+	unsigned long host_no;
+	unsigned long instance;
+
+	/* NVRAM registers */
+	eeprom_data_t *nvram;
+	spinlock_t hardware_lock ____cacheline_aligned;
+	spinlock_t list_lock;
+	uint32_t   eeprom_cmd_data;
+
+	/* Counters for general statistics */
+	uint64_t adapter_error_count;
+	uint64_t device_error_count;
+	uint64_t total_io_count;
+	uint64_t total_mbytes_xferred;
+	uint64_t link_failure_count;
+	uint64_t invalid_crc_count;
+	uint32_t spurious_int_count;
+	uint32_t aborted_io_count;
+	uint32_t io_timeout_count;
+	uint32_t mailbox_timeout_count;
+	uint32_t seconds_since_last_intr;
+	uint32_t seconds_since_last_heartbeat;
+	uint32_t mac_index;
+
+	/* Info Needed for Management App */
+	/* --- From GetFwVersion --- */
+	uint32_t firmware_version[2];
+	uint32_t patch_number;
+	uint32_t build_number;
+
+	/* --- From Init_FW --- */
+	/* init_cb_t *init_cb; */
+	uint16_t firmware_options;
+	uint16_t tcp_options;
+	uint8_t ip_address[IP_ADDR_LEN];
+	uint8_t subnet_mask[IP_ADDR_LEN];
+	uint8_t gateway[IP_ADDR_LEN];
+	uint8_t isns_ip_address[IP_ADDR_LEN];
+	uint16_t isns_server_port_number;
+	uint8_t alias[32];
+	uint8_t name_string[256];
+	uint8_t heartbeat_interval;
+	uint8_t rsvd;
+
+	/* --- From FlashSysInfo --- */
+	uint8_t my_mac[MAC_ADDR_LEN];
+	uint8_t serial_number[16];
+
+	/* --- From GetFwState --- */
+	uint32_t firmware_state;
+	uint32_t board_id;
+	uint32_t addl_fw_state;
+
+	/* Linux kernel thread */
+	struct task_struct *dpc_thread;
+	uint8_t dpc_active;	/* DPC routine is active */
+
+	/* Linux timer thread */
+	struct timer_list timer;
+	uint32_t timer_active;
+
+	/* Recovery Timers */
+	uint32_t port_down_retry_count;
+	uint32_t discovery_wait;
+	atomic_t check_relogin_timeouts;
+	uint32_t retry_reset_ha_cnt;
+	uint32_t isp_reset_timer;	/* reset test timer */
+	uint32_t nic_reset_timer;	/* simulated nic reset test timer */
+	int eh_start;
+	struct list_head free_srb_q;
+	uint16_t free_srb_q_count;
+	uint16_t num_srbs_allocated;
+
+	/* Active array */
+	srb_t *active_srb_array[MAX_SRBS];
+	uint16_t current_active_index;
+
+	/* DMA Memory Block */
+	void *queues;
+	dma_addr_t queues_dma;
+	unsigned long queues_len;
+
+#define MEM_ALIGN_VALUE	\
+	    ((max(REQUEST_QUEUE_DEPTH, RESPONSE_QUEUE_DEPTH)) * \
+	     sizeof(QUEUE_ENTRY))
+	/* request and response queue variables */
+	dma_addr_t request_dma;
+	QUEUE_ENTRY *request_ring;
+	QUEUE_ENTRY *request_ptr;
+	dma_addr_t response_dma;
+	QUEUE_ENTRY *response_ring;
+	QUEUE_ENTRY *response_ptr;
+	dma_addr_t shadow_regs_dma;
+	shadow_regs_t *shadow_regs;
+	uint16_t request_in;	/* Current indexes. */
+	uint16_t request_out;
+	uint16_t response_in;
+	uint16_t response_out;
+
+	/* aen queue variables */
+	uint16_t aen_q_count;	/* Number of available aen_q entries */
+	uint16_t aen_in;	/* Current indexes */
+	uint16_t aen_out;
+	aen_t aen_q[MAX_AEN_ENTRIES];
+
+	/* pdu variables */
+	uint16_t pdu_count;	/* Number of available aen_q entries */
+	uint16_t pdu_in;	/* Current indexes */
+	uint16_t pdu_out;
+	uint16_t pdu_active;
+	PDU_ENTRY *free_pdu_top;
+	PDU_ENTRY *free_pdu_bottom;
+	PDU_ENTRY pdu_queue[MAX_PDU_ENTRIES];
+
+	/* This mutex protects several threads to do mailbox commands
+	 * concurrently.
+	 */
+	struct mutex  mbox_sem;
+	wait_queue_head_t mailbox_wait_queue;
+
+	/* temporary mailbox status registers */
+	volatile uint8_t mbox_status_count;
+	volatile uint32_t mbox_status[MBOX_REG_COUNT];
+
+	/* local device database list (contains internal ddb entries) */
+	struct list_head ddb_list;
+
+	/* Map ddb_list entry by FW ddb index */
+	ddb_entry_t *fw_ddb_index_map[MAX_DDB_ENTRIES];
+} scsi_qla_host_t;
+
+#define ADAPTER_UP(ha) ((test_bit(AF_ONLINE, &ha->flags) != 0) && (test_bit(AF_LINK_UP, &ha->flags) != 0))
+typedef struct {
+	uint8_t ha_mac[MAX_HBAS][MAC_ADDR_LEN];
+} mac_cfgs_t;
+
+/*
+ * Other macros
+ */
+#define to_qla_host(x)		((scsi_qla_host_t *) (x)->hostdata)
+#define ql4_printk(level, ha, format, arg...) \
+    dev_printk(level, &((ha)->pdev->dev), format, ## arg)
+
+/*---------------------------------------------------------------------------*/
+
+/* Defines for qla4xxx_initialize_adapter() and qla4xxx_recover_adapter() */
+#define PRESERVE_DDB_LIST	0
+#define REBUILD_DDB_LIST	1
+
+/* Defines for process_aen() */
+#define PROCESS_ALL_AENS	 0
+#define FLUSH_DDB_CHANGED_AENS	 1
+#define RELOGIN_DDB_CHANGED_AENS 2
+
+/* Defines for qla4xxx_take_hw_semaphore */
+#define NO_WAIT		0
+#define WAIT_FOREVER	1
+#define TIMED_WAIT	2
+
+#include "ql4_version.h"
+#include "ql4_settings.h"
+#include "ql4_glbl.h"
+#include "ql4_dbg.h"
+#include "ql4_inline.h"
+
+#endif	/*_QLA4XXX_H */
diff --git a/drivers/scsi/qla4xxx/ql4_fw.h b/drivers/scsi/qla4xxx/ql4_fw.h
new file mode 100644
index 0000000..10f1852
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_fw.h
@@ -0,0 +1,1604 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+#ifndef _QLA4X_FW_H
+#define _QLA4X_FW_H
+
+#define MAX_PRST_DEV_DB_ENTRIES         64
+#define MIN_DISC_DEV_DB_ENTRY           MAX_PRST_DEV_DB_ENTRIES
+#define MAX_DEV_DB_ENTRIES              512
+
+/*************************************************************************
+ *
+ * 		ISP 4010 I/O Register Set Structure and Definitions
+ *
+ *************************************************************************/
+
+typedef struct _PORT_CTRL_STAT_REGS {
+	uint32_t ext_hw_conf;	// 80 x50  R/W
+	uint32_t intChipConfiguration;	// 84 x54   *
+	uint32_t port_ctrl;	// 88 x58   *
+	uint32_t port_status;	// 92 x5c   *
+	uint32_t HostPrimMACHi;	// 96 x60   *
+	uint32_t HostPrimMACLow;	//100 x64   *
+	uint32_t HostSecMACHi;	//104 x68   *
+	uint32_t HostSecMACLow;	//108 x6c   *
+	uint32_t EPPrimMACHi;	//112 x70   *
+	uint32_t EPPrimMACLow;	//116 x74   *
+	uint32_t EPSecMACHi;	//120 x78   *
+	uint32_t EPSecMACLow;	//124 x7c   *
+	uint32_t HostPrimIPHi;	//128 x80   *
+	uint32_t HostPrimIPMidHi;	//132 x84   *
+	uint32_t HostPrimIPMidLow;	//136 x88   *
+	uint32_t HostPrimIPLow;	//140 x8c   *
+	uint32_t HostSecIPHi;	//144 x90   *
+	uint32_t HostSecIPMidHi;	//148 x94   *
+	uint32_t HostSecIPMidLow;	//152 x98   *
+	uint32_t HostSecIPLow;	//156 x9c   *
+	uint32_t EPPrimIPHi;	//160 xa0   *
+	uint32_t EPPrimIPMidHi;	//164 xa4   *
+	uint32_t EPPrimIPMidLow;	//168 xa8   *
+	uint32_t EPPrimIPLow;	//172 xac   *
+	uint32_t EPSecIPHi;	//176 xb0   *
+	uint32_t EPSecIPMidHi;	//180 xb4   *
+	uint32_t EPSecIPMidLow;	//184 xb8   *
+	uint32_t EPSecIPLow;	//188 xbc   *
+	uint32_t IPReassemblyTimeout;	//192 xc0   *
+	uint32_t EthMaxFramePayload;	//196 xc4   *
+	uint32_t TCPMaxWindowSize;	//200 xc8   *
+	uint32_t TCPCurrentTimestampHi;	//204 xcc   *
+	uint32_t TCPCurrentTimestampLow;	//208 xd0   *
+	uint32_t LocalRAMAddress;	//212 xd4   *
+	uint32_t LocalRAMData;	//216 xd8   *
+	uint32_t PCSReserved1;	//220 xdc   *
+	uint32_t gp_out;	//224 xe0   *
+	uint32_t gp_in;		//228 xe4   *
+	uint32_t ProbeMuxAddr;	//232 xe8   *
+	uint32_t ProbeMuxData;	//236 xec   *
+	uint32_t ERMQueueBaseAddr0;	//240 xf0   *
+	uint32_t ERMQueueBaseAddr1;	//244 xf4   *
+	uint32_t MACConfiguration;	//248 xf8   *
+	uint32_t port_err_status;	//252 xfc  COR
+} PORT_CTRL_STAT_REGS, *PPORT_CTRL_STAT_REGS;
+
+typedef struct _HOST_MEM_CFG_REGS {
+	uint32_t NetRequestQueueOut;	// 80 x50   *
+	uint32_t NetRequestQueueOutAddrHi;	// 84 x54   *
+	uint32_t NetRequestQueueOutAddrLow;	// 88 x58   *
+	uint32_t NetRequestQueueBaseAddrHi;	// 92 x5c   *
+	uint32_t NetRequestQueueBaseAddrLow;	// 96 x60   *
+	uint32_t NetRequestQueueLength;	//100 x64   *
+	uint32_t NetResponseQueueIn;	//104 x68   *
+	uint32_t NetResponseQueueInAddrHi;	//108 x6c   *
+	uint32_t NetResponseQueueInAddrLow;	//112 x70   *
+	uint32_t NetResponseQueueBaseAddrHi;	//116 x74   *
+	uint32_t NetResponseQueueBaseAddrLow;	//120 x78   *
+	uint32_t NetResponseQueueLength;	//124 x7c   *
+	uint32_t req_q_out;	//128 x80   *
+	uint32_t RequestQueueOutAddrHi;	//132 x84   *
+	uint32_t RequestQueueOutAddrLow;	//136 x88   *
+	uint32_t RequestQueueBaseAddrHi;	//140 x8c   *
+	uint32_t RequestQueueBaseAddrLow;	//144 x90   *
+	uint32_t RequestQueueLength;	//148 x94   *
+	uint32_t ResponseQueueIn;	//152 x98   *
+	uint32_t ResponseQueueInAddrHi;	//156 x9c   *
+	uint32_t ResponseQueueInAddrLow;	//160 xa0   *
+	uint32_t ResponseQueueBaseAddrHi;	//164 xa4   *
+	uint32_t ResponseQueueBaseAddrLow;	//168 xa8   *
+	uint32_t ResponseQueueLength;	//172 xac   *
+	uint32_t NetRxLargeBufferQueueOut;	//176 xb0   *
+	uint32_t NetRxLargeBufferQueueBaseAddrHi;	//180 xb4   *
+	uint32_t NetRxLargeBufferQueueBaseAddrLow;	//184 xb8   *
+	uint32_t NetRxLargeBufferQueueLength;	//188 xbc   *
+	uint32_t NetRxLargeBufferLength;	//192 xc0   *
+	uint32_t NetRxSmallBufferQueueOut;	//196 xc4   *
+	uint32_t NetRxSmallBufferQueueBaseAddrHi;	//200 xc8   *
+	uint32_t NetRxSmallBufferQueueBaseAddrLow;	//204 xcc   *
+	uint32_t NetRxSmallBufferQueueLength;	//208 xd0   *
+	uint32_t NetRxSmallBufferLength;	//212 xd4   *
+	uint32_t HMCReserved0[10];	//216 xd8   *
+} HOST_MEM_CFG_REGS, *PHOST_MEM_CFG_REGS;
+
+typedef struct _LOCAL_RAM_CFG_REGS {
+	uint32_t BufletSize;	// 80 x50   *
+	uint32_t BufletMaxCount;	// 84 x54   *
+	uint32_t BufletCurrCount;	// 88 x58   *
+	uint32_t BufletPauseThresholdCount;	// 92 x5c   *
+	uint32_t BufletTCPWinThresholdHi;	// 96 x60   *
+	uint32_t BufletTCPWinThresholdLow;	//100 x64   *
+	uint32_t IPHashTableBaseAddr;	//104 x68   *
+	uint32_t IPHashTableSize;	//108 x6c   *
+	uint32_t TCPHashTableBaseAddr;	//112 x70   *
+	uint32_t TCPHashTableSize;	//116 x74   *
+	uint32_t NCBAreaBaseAddr;	//120 x78   *
+	uint32_t NCBMaxCount;	//124 x7c   *
+	uint32_t NCBCurrCount;	//128 x80   *
+	uint32_t DRBAreaBaseAddr;	//132 x84   *
+	uint32_t DRBMaxCount;	//136 x88   *
+	uint32_t DRBCurrCount;	//140 x8c   *
+	uint32_t LRCReserved[28];	//144 x90   *
+} LOCAL_RAM_CFG_REGS, *PLOCAL_RAM_CFG_REGS;
+
+typedef struct _PROT_STAT_REGS {
+	uint32_t MACTxFrameCount;	// 80 x50   R
+	uint32_t MACTxByteCount;	// 84 x54   R
+	uint32_t MACRxFrameCount;	// 88 x58   R
+	uint32_t MACRxByteCount;	// 92 x5c   R
+	uint32_t MACCRCErrCount;	// 96 x60   R
+	uint32_t MACEncErrCount;	//100 x64   R
+	uint32_t MACRxLengthErrCount;	//104 x68   R
+	uint32_t IPTxPacketCount;	//108 x6c   R
+	uint32_t IPTxByteCount;	//112 x70   R
+	uint32_t IPTxFragmentCount;	//116 x74   R
+	uint32_t IPRxPacketCount;	//120 x78   R
+	uint32_t IPRxByteCount;	//124 x7c   R
+	uint32_t IPRxFragmentCount;	//128 x80   R
+	uint32_t IPDatagramReassemblyCount;	//132 x84   R
+	uint32_t IPV6RxPacketCount;	//136 x88   R
+	uint32_t IPErrPacketCount;	//140 x8c   R
+	uint32_t IPReassemblyErrCount;	//144 x90   R
+	uint32_t TCPTxSegmentCount;	//148 x94   R
+	uint32_t TCPTxByteCount;	//152 x98   R
+	uint32_t TCPRxSegmentCount;	//156 x9c   R
+	uint32_t TCPRxByteCount;	//160 xa0   R
+	uint32_t TCPTimerExpCount;	//164 xa4   R
+	uint32_t TCPRxAckCount;	//168 xa8   R
+	uint32_t TCPTxAckCount;	//172 xac   R
+	uint32_t TCPRxErrOOOCount;	//176 xb0   R
+	uint32_t PSReserved0;	//180 xb4   *
+	uint32_t TCPRxWindowProbeUpdateCount;	//184 xb8   R
+	uint32_t ECCErrCorrectionCount;	//188 xbc   R
+	uint32_t PSReserved1[16];	//192 xc0   *
+} PROT_STAT_REGS, *PPROT_STAT_REGS;
+
+#define MBOX_REG_COUNT                          8
+
+// remote register set (access via PCI memory read/write)
+typedef struct isp_reg_t {
+	uint32_t mailbox[MBOX_REG_COUNT];
+
+	uint32_t flash_address;	/* 0x20 */
+	uint32_t flash_data;
+	uint32_t ctrl_status;
+
+	union {
+		struct {
+			uint32_t nvram;
+			uint32_t reserved1[2];	/* 0x30 */
+		} __attribute__ ((packed)) isp4010;
+		struct {
+			uint32_t intr_mask;
+			uint32_t nvram;	/* 0x30 */
+			uint32_t semaphore;
+		} __attribute__ ((packed)) isp4022;
+	} u1;
+
+	uint32_t req_q_in;	/* SCSI Request Queue Producer Index */
+	uint32_t rsp_q_out;	/* SCSI Completion Queue Consumer Index */
+
+	uint32_t reserved2[4];	/* 0x40 */
+
+	union {
+		struct {
+			uint32_t ext_hw_conf;	/* 0x50 */
+			uint32_t flow_ctrl;
+			uint32_t port_ctrl;
+			uint32_t port_status;
+
+			uint32_t reserved3[8];	/* 0x60 */
+
+			uint32_t req_q_out;	/* 0x80 */
+
+			uint32_t reserved4[23];	/* 0x84 */
+
+			uint32_t gp_out;	/* 0xe0 */
+			uint32_t gp_in;
+
+			uint32_t reserved5[5];
+
+			uint32_t port_err_status;	/* 0xfc */
+		} __attribute__ ((packed)) isp4010;
+		struct {
+			union {
+				PORT_CTRL_STAT_REGS p0;
+				HOST_MEM_CFG_REGS p1;
+				LOCAL_RAM_CFG_REGS p2;
+				PROT_STAT_REGS p3;
+				uint32_t r_union[44];
+			};
+
+		} __attribute__ ((packed)) isp4022;
+	} u2;
+} isp_reg_t;			//256 x100
+
+#define ISP_SEMAPHORE(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u1.isp4022.semaphore : \
+	 &ha->reg->u1.isp4010.nvram)
+
+#define ISP_NVRAM(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u1.isp4022.nvram : \
+	 &ha->reg->u1.isp4010.nvram)
+
+#define ISP_EXT_HW_CONF(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.ext_hw_conf : \
+	 &ha->reg->u2.isp4010.ext_hw_conf)
+
+#define ISP_PORT_STATUS(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.port_status : \
+	 &ha->reg->u2.isp4010.port_status)
+
+#define ISP_PORT_CTRL(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.port_ctrl : \
+	 &ha->reg->u2.isp4010.port_ctrl)
+
+#define ISP_REQ_Q_OUT(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p1.req_q_out : \
+	 &ha->reg->u2.isp4010.req_q_out)
+
+#define ISP_PORT_ERROR_STATUS(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.port_err_status : \
+	 &ha->reg->u2.isp4010.port_err_status)
+
+#define ISP_GP_OUT(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.gp_out : \
+	 &ha->reg->u2.isp4010.gp_out)
+
+#define ISP_GP_IN(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.gp_in : \
+	 &ha->reg->u2.isp4010.gp_in)
+
+/* Semaphore Defines for 4010 */
+#define QL4010_DRVR_SEM_BITS    0x00000030
+#define QL4010_GPIO_SEM_BITS    0x000000c0
+#define QL4010_SDRAM_SEM_BITS   0x00000300
+#define QL4010_PHY_SEM_BITS     0x00000c00
+#define QL4010_NVRAM_SEM_BITS   0x00003000
+#define QL4010_FLASH_SEM_BITS   0x0000c000
+
+#define QL4010_DRVR_SEM_MASK    0x00300000
+#define QL4010_GPIO_SEM_MASK    0x00c00000
+#define QL4010_SDRAM_SEM_MASK   0x03000000
+#define QL4010_PHY_SEM_MASK     0x0c000000
+#define	QL4010_NVRAM_SEM_MASK	0x30000000
+#define QL4010_FLASH_SEM_MASK   0xc0000000
+
+/* Semaphore Defines for 4022 */
+#define QL4022_RESOURCE_MASK_BASE_CODE 0x7
+#define QL4022_RESOURCE_BITS_BASE_CODE 0x4
+
+#define QL4022_DRVR_SEM_BITS    (QL4022_RESOURCE_BITS_BASE_CODE << 1)
+#define QL4022_DDR_RAM_SEM_BITS (QL4022_RESOURCE_BITS_BASE_CODE << 4)
+#define QL4022_PHY_GIO_SEM_BITS (QL4022_RESOURCE_BITS_BASE_CODE << 7)
+#define QL4022_NVRAM_SEM_BITS   (QL4022_RESOURCE_BITS_BASE_CODE << 10)
+#define QL4022_FLASH_SEM_BITS   (QL4022_RESOURCE_BITS_BASE_CODE << 13)
+
+#define QL4022_DRVR_SEM_MASK    (QL4022_RESOURCE_MASK_BASE_CODE << (1+16))
+#define QL4022_DDR_RAM_SEM_MASK (QL4022_RESOURCE_MASK_BASE_CODE << (4+16))
+#define QL4022_PHY_GIO_SEM_MASK (QL4022_RESOURCE_MASK_BASE_CODE << (7+16))
+#define QL4022_NVRAM_SEM_MASK   (QL4022_RESOURCE_MASK_BASE_CODE << (10+16))
+#define QL4022_FLASH_SEM_MASK   (QL4022_RESOURCE_MASK_BASE_CODE << (13+16))
+
+#define QL4XXX_LOCK_FLASH(a)    \
+	(IS_QLA4022(a) ? \
+    ql4xxx_sem_spinlock(a, QL4022_FLASH_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 13) : \
+    ql4xxx_sem_spinlock(a, QL4010_FLASH_SEM_MASK, QL4010_FLASH_SEM_BITS) )
+
+#define QL4XXX_LOCK_NVRAM(a)    \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_spinlock(a, QL4022_NVRAM_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 10) : \
+	ql4xxx_sem_spinlock(a, QL4010_NVRAM_SEM_MASK, QL4010_NVRAM_SEM_BITS) )
+
+#define QL4XXX_LOCK_GIO(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_spinlock(a, QL4022_PHY_GIO_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 7) : \
+	ql4xxx_sem_spinlock(a, QL4010_GPIO_SEM_MASK, QL4010_GPIO_SEM_BITS) )
+
+#define QL4XXX_LOCK_PHY(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_spinlock(a, QL4022_PHY_GIO_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 7) : \
+	ql4xxx_sem_spinlock(a, QL4010_PHY_SEM_MASK, QL4010_PHY_SEM_BITS) )
+
+#define QL4XXX_LOCK_DDR_RAM(a)  \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_spinlock(a, QL4022_DDR_RAM_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 4) : \
+	ql4xxx_sem_spinlock(a, QL4010_SDRAM_SEM_MASK, QL4010_SDRAM_SEM_BITS) )
+
+#define QL4XXX_LOCK_DRVR(a)  \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_lock(a, QL4022_DRVR_SEM_MASK, (QL4022_RESOURCE_BITS_BASE_CODE | (a->mac_index)) << 1) : \
+	ql4xxx_sem_lock(a, QL4010_DRVR_SEM_MASK, QL4010_DRVR_SEM_BITS) )
+
+#define QL4XXX_UNLOCK_DRVR(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_DRVR_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_DRVR_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_GIO(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_PHY_GIO_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_GPIO_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_DDR_RAM(a)  \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_DDR_RAM_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_SDRAM_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_PHY(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_PHY_GIO_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_PHY_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_NVRAM(a) \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_NVRAM_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_NVRAM_SEM_MASK) )
+
+#define QL4XXX_UNLOCK_FLASH(a)  \
+	(IS_QLA4022(a) ? \
+	ql4xxx_sem_unlock(a, QL4022_FLASH_SEM_MASK) : \
+	ql4xxx_sem_unlock(a, QL4010_FLASH_SEM_MASK) )
+
+#define QL4XXX_LOCK_DRVR_WAIT(a) \
+{ \
+	int i = 0; \
+	while (1) { \
+		if (QL4XXX_LOCK_DRVR(a) == 0) { \
+			msleep(10); \
+			if (!i) { \
+				DEBUG2(printk("scsi%ld: %s: Waiting for " \
+				    "Global Init Semaphore...n", a->host_no, \
+				    __func__)); \
+				i++; \
+			} \
+		} else { \
+			DEBUG2(printk("scsi%ld: %s: Global Init Semaphore " \
+			    "acquired.n", a->host_no, __func__)); \
+			break; \
+		} \
+	} \
+}
+
+/* Page # defines for 4022 */
+#define PORT_CTRL_STAT_PAGE                     0	/* 4022 */
+#define HOST_MEM_CFG_PAGE                       1	/* 4022 */
+#define LOCAL_RAM_CFG_PAGE                      2	/* 4022 */
+#define PROT_STAT_PAGE                          3	/* 4022 */
+
+/* Register Mask - sets corresponding mask bits in the upper word */
+#define SET_RMASK(val)	((val & 0xffff) | (val << 16))
+#define CLR_RMASK(val)	(0 | (val << 16))
+
+// ctrl_status definitions
+#define CSR_SCSI_PAGE_SELECT                    0x00000003
+#define CSR_SCSI_INTR_ENABLE                    0x00000004	/* 4010 */
+#define CSR_SCSI_RESET_INTR                     0x00000008
+#define CSR_SCSI_COMPLETION_INTR                0x00000010
+#define CSR_SCSI_PROCESSOR_INTR                 0x00000020
+#define CSR_INTR_RISC                           0x00000040
+#define CSR_BOOT_ENABLE                         0x00000080
+#define CSR_NET_PAGE_SELECT                     0x00000300	/* 4010 */
+#define CSR_NET_INTR_ENABLE                     0x00000400	/* 4010 */
+#define CSR_FUNC_NUM                            0x00000700	/* 4022 */
+#define CSR_PCI_FUNC_NUM_MASK                   0x00000300	/* 4022 */
+#define CSR_NET_RESET_INTR                      0x00000800	/* 4010 */
+#define CSR_NET_COMPLETION_INTR                 0x00001000	/* 4010 */
+#define CSR_FORCE_SOFT_RESET                    0x00002000	/* 4022 */
+#define CSR_FATAL_ERROR                         0x00004000
+#define CSR_SOFT_RESET                          0x00008000
+#define ISP_CONTROL_FN_MASK     		CSR_FUNC_NUM
+#define ISP_CONTROL_FN0_NET     		0x0400
+#define ISP_CONTROL_FN0_SCSI    		0x0500
+#define ISP_CONTROL_FN1_NET     		0x0600
+#define ISP_CONTROL_FN1_SCSI    		0x0700
+
+#define INTR_PENDING                            (CSR_SCSI_COMPLETION_INTR | CSR_SCSI_PROCESSOR_INTR | CSR_SCSI_RESET_INTR)
+
+/* ISP InterruptMask definitions */
+#define IMR_SCSI_INTR_ENABLE                    0x00000004	/* 4022 */
+
+/* ISP 4022 nvram definitions */
+#define NVR_WRITE_ENABLE			0x00000010	/* 4022 */
+
+// ISP port_ctrl definitions
+#define PCR_CONFIG_COMPLETE			0x00008000	/* 4022 */
+#define PCR_BIOS_BOOTED_FIRMWARE		0x00008000	/* 4010 */
+#define PCR_ENABLE_SERIAL_DATA			0x00001000	/* 4010 */
+#define PCR_SERIAL_DATA_OUT			0x00000800	/* 4010 */
+#define PCR_ENABLE_SERIAL_CLOCK			0x00000400	/* 4010 */
+#define PCR_SERIAL_CLOCK			0x00000200	/* 4010 */
+
+// ISP port_status definitions
+#define PSR_CONFIG_COMPLETE			0x00000001	/* 4010 */
+#define PSR_INIT_COMPLETE			0x00000200
+
+// ISP Semaphore definitions
+#define SR_FIRWMARE_BOOTED			0x00000001
+
+// ISP General Purpose Output definitions
+#define GPOR_TOPCAT_RESET                  	0x00000004
+
+// shadow registers (DMA'd from HA to system memory.  read only)
+typedef struct {
+	/* SCSI Request Queue Consumer Index */
+	uint32_t req_q_out;	// 0 x0   R
+
+	/* SCSI Completion Queue Producer Index */
+	uint32_t rsp_q_in;	// 4 x4   R
+} shadow_regs_t;		// 8 x8
+
+#define EHWC_PROT_METHOD_NONE                         0
+#define EHWC_PROT_METHOD_BYTE_PARITY                  1
+#define EHWC_PROT_METHOD_ECC                          2
+#define EHWC_SDRAM_BANKS_1                            0
+#define EHWC_SDRAM_BANKS_2                            1
+#define EHWC_SDRAM_WIDTH_8_BIT                        0
+#define EHWC_SDRAM_WIDTH_16_BIT                       1
+#define EHWC_SDRAM_CHIP_SIZE_64MB                     0
+#define EHWC_SDRAM_CHIP_SIZE_128MB                    1
+#define EHWC_SDRAM_CHIP_SIZE_256MB                    2
+#define EHWC_MEM_TYPE_SYNC_FLOWTHROUGH                0
+#define EHWC_MEM_TYPE_SYNC_PIPELINE                   1
+#define EHWC_WRITE_BURST_512                          0
+#define EHWC_WRITE_BURST_1024                         1
+#define EHWC_WRITE_BURST_2048                         2
+#define EHWC_WRITE_BURST_4096                         3
+
+// External hardware configuration register
+typedef union _EXTERNAL_HW_CONFIG_REG {
+	struct {
+		uint32_t bReserved0:1;
+		uint32_t bSDRAMProtectionMethod:2;
+		uint32_t bSDRAMBanks:1;
+		uint32_t bSDRAMChipWidth:1;
+		uint32_t bSDRAMChipSize:2;
+		uint32_t bParityDisable:1;
+		uint32_t bExternalMemoryType:1;
+		uint32_t bFlashBIOSWriteEnable:1;
+		uint32_t bFlashUpperBankSelect:1;
+		uint32_t bWriteBurst:2;
+		uint32_t bReserved1:3;
+		uint32_t bMask:16;
+	};
+	uint32_t Asuint32_t;
+} EXTERNAL_HW_CONFIG_REG, *PEXTERNAL_HW_CONFIG_REG;
+
+/*************************************************************************
+ *
+ *		Mailbox Commands Structures and Definitions
+ *
+ *************************************************************************/
+
+// Mailbox command definitions
+#define MBOX_CMD_LOAD_RISC_RAM_EXT              0x0001
+#define MBOX_CMD_EXECUTE_FW                     0x0002
+#define MBOX_CMD_DUMP_RISC_RAM_EXT              0x0003
+#define MBOX_CMD_WRITE_RISC_RAM_EXT             0x0004
+#define MBOX_CMD_READ_RISC_RAM_EXT              0x0005
+#define MBOX_CMD_REGISTER_TEST                  0x0006
+#define MBOX_CMD_VERIFY_CHECKSUM                0x0007
+#define MBOX_CMD_ABOUT_FW                       0x0009
+#define MBOX_CMD_LOOPBACK_DIAG                  0x000A
+#define MBOX_CMD_PING                           0x000B
+#define MBOX_CMD_CHECKSUM_FW                    0x000E
+#define MBOX_CMD_RESET_FW                       0x0014
+#define MBOX_CMD_ABORT_TASK                     0x0015
+#define MBOX_CMD_LUN_RESET                      0x0016
+#define MBOX_CMD_TARGET_WARM_RESET              0x0017
+#define MBOX_CMD_TARGET_COLD_RESET              0x0018
+#define MBOX_CMD_ABORT_QUEUE                    0x001C
+#define MBOX_CMD_GET_QUEUE_STATUS               0x001D
+#define MBOX_CMD_GET_MANAGEMENT_DATA            0x001E
+#define MBOX_CMD_GET_FW_STATUS                  0x001F
+#define MBOX_CMD_SET_ISNS_SERVICE               0x0021
+#define ISNS_DISABLE                            0
+#define ISNS_ENABLE                             1
+#define ISNS_STATUS                             2
+#define MBOX_CMD_COPY_FLASH                     0x0024
+#define COPY_FLASH_OPTION_PRIM_TO_SEC           0
+#define COPY_FLASH_OPTION_SEC_TO_PRIM           1
+#define MBOX_CMD_WRITE_FLASH                    0x0025
+#define WRITE_FLASH_OPTION_HOLD_DATA            0
+#define WRITE_FLASH_OPTION_COMMIT_DATA          2
+#define WRITE_FLASH_OPTION_FLASH_DATA    	3
+#define MBOX_CMD_READ_FLASH                     0x0026
+#define MBOX_CMD_GET_QUEUE_PARAMS               0x0029
+#define MBOX_CMD_CLEAR_DATABASE_ENTRY           0x0031
+#define MBOX_CMD_SET_QUEUE_PARAMS               0x0039
+#define MBOX_CMD_CONN_CLOSE_SESS_LOGOUT         0x0056
+#define LOGOUT_OPTION_CLOSE_SESSION             0x01
+#define LOGOUT_OPTION_RELOGIN                   0x02
+#define MBOX_CMD_EXECUTE_IOCB_A64		0x005A
+#define MBOX_CMD_INITIALIZE_FIRMWARE            0x0060
+#define MBOX_CMD_GET_INIT_FW_CTRL_BLOCK         0x0061
+#define MBOX_CMD_REQUEST_DATABASE_ENTRY         0x0062
+#define MBOX_CMD_SET_DATABASE_ENTRY             0x0063
+#define MBOX_CMD_GET_DATABASE_ENTRY             0x0064
+#define DDB_DS_UNASSIGNED                       0x00
+#define DDB_DS_NO_CONNECTION_ACTIVE             0x01
+#define DDB_DS_DISCOVERY                        0x02
+#define DDB_DS_NO_SESSION_ACTIVE                0x03
+#define DDB_DS_SESSION_ACTIVE                   0x04
+#define DDB_DS_LOGGING_OUT                      0x05
+#define DDB_DS_SESSION_FAILED                   0x06
+#define DDB_DS_LOGIN_IN_PROCESS                 0x07
+#define DELETEABLE_DDB_DS(ds) ((ds == DDB_DS_UNASSIGNED) || \
+		                               (ds == DDB_DS_NO_CONNECTION_ACTIVE) || \
+					       (ds == DDB_DS_SESSION_FAILED))
+#define MBOX_CMD_CLEAR_ACA                      0x0065
+#define MBOX_CMD_CLEAR_TASK_SET                 0x0067
+#define MBOX_CMD_ABORT_TASK_SET                 0x0068
+#define MBOX_CMD_GET_FW_STATE                   0x0069
+
+/* Mailbox 1 */
+#define FW_STATE_READY                          0x0000
+#define FW_STATE_CONFIG_WAIT                    0x0001
+#define FW_STATE_WAIT_LOGIN                     0x0002
+#define FW_STATE_ERROR                          0x0004
+#define FW_STATE_DHCP_IN_PROGRESS		0x0008
+#define FW_STATE_ISNS_IN_PROGRESS               0x0010
+#define FW_STATE_TOPCAT_INIT_IN_PROGRESS       	0x0040
+
+/* Mailbox 3 */
+#define FW_ADDSTATE_COPPER_MEDIA                0x0000
+#define FW_ADDSTATE_OPTICAL_MEDIA               0x0001
+#define	FW_ADDSTATE_DHCP_ENABLED		0x0002
+#define	FW_ADDSTATE_DHCP_LEASE_ACQUIRED		0x0004
+#define	FW_ADDSTATE_DHCP_LEASE_EXPIRED		0x0008
+#define FW_ADDSTATE_LINK_UP                     0x0010
+#define FW_ADDSTATE_ISNS_SVC_ENABLED            0x0020
+#define FW_ADDSTATE_TOPCAT_NOT_INITIALIZED     	0x0040
+#define MBOX_CMD_GET_INIT_FW_CTRL_BLOCK_DEFAULTS 0x006A
+#define MBOX_CMD_GET_DATABASE_ENTRY_DEFAULTS    0x006B
+#define MBOX_CMD_CONN_OPEN_SESS_LOGIN           0x0074
+#define MBOX_CMD_DIAGNOSTICS_TEST_RESULTS       0x0075	/* 4010 only */
+#define DIAG_TEST_LOCAL_RAM_SIZE		0x0002
+#define DIAG_TEST_LOCAL_RAM_READ_WRITE		0x0003
+#define DIAG_TEST_RISC_RAM			0x0004
+#define DIAG_TEST_NVRAM				0x0005
+#define DIAG_TEST_FLASH_ROM			0x0006
+#define DIAG_TEST_NW_INT_LOOPBACK		0x0007
+#define DIAG_TEST_NW_EXT_LOOPBACK		0x0008
+#define MBOX_CMD_GET_CRASH_RECORD       	0x0076	/* 4010 only */
+#define MBOX_CMD_GET_CONN_EVENT_LOG       	0x0077
+#define MBOX_CMD_RESTORE_FACTORY_DEFAULTS      	0x0087
+#define MBOX_CMD_NOP                            0x00FF
+
+// Mailbox status definitions
+#define MBOX_COMPLETION_STATUS			4
+#define MBOX_STS_BUSY                           0x0007
+#define MBOX_STS_INTERMEDIATE_COMPLETION    	0x1000
+#define MBOX_STS_COMMAND_COMPLETE               0x4000
+#define MBOX_STS_INVALID_COMMAND                0x4001
+#define MBOX_STS_HOST_INTERFACE_ERROR           0x4002
+#define MBOX_STS_TEST_FAILED                    0x4003
+#define MBOX_STS_COMMAND_ERROR                  0x4005
+#define MBOX_STS_COMMAND_PARAMETER_ERROR        0x4006
+#define MBOX_STS_TARGET_MODE_INIT_FAIL          0x4007
+#define MBOX_STS_INITIATOR_MODE_INIT_FAIL       0x4008
+
+#define MBOX_ASYNC_EVENT_STATUS			8
+#define MBOX_ASTS_SYSTEM_ERROR                  0x8002
+#define MBOX_ASTS_REQUEST_TRANSFER_ERROR        0x8003
+#define MBOX_ASTS_RESPONSE_TRANSFER_ERROR       0x8004
+#define MBOX_ASTS_PROTOCOL_STATISTIC_ALARM      0x8005
+#define MBOX_ASTS_SCSI_COMMAND_PDU_REJECTED     0x8006
+#define MBOX_ASTS_LINK_UP  			0x8010
+#define MBOX_ASTS_LINK_DOWN			0x8011
+#define MBOX_ASTS_DATABASE_CHANGED              0x8014
+#define MBOX_ASTS_UNSOLICITED_PDU_RECEIVED      0x8015
+#define MBOX_ASTS_SELF_TEST_FAILED      	0x8016
+#define MBOX_ASTS_LOGIN_FAILED      		0x8017
+#define MBOX_ASTS_DNS      			0x8018
+#define MBOX_ASTS_HEARTBEAT      		0x8019
+#define MBOX_ASTS_NVRAM_INVALID      		0x801A
+#define MBOX_ASTS_MAC_ADDRESS_CHANGED      	0x801B
+#define MBOX_ASTS_IP_ADDRESS_CHANGED      	0x801C
+#define MBOX_ASTS_DHCP_LEASE_EXPIRED      	0x801D
+#define MBOX_ASTS_DHCP_LEASE_ACQUIRED           0x801F
+#define MBOX_ASTS_ISNS_UNSOLICITED_PDU_RECEIVED 0x8021
+#define ISNS_EVENT_DATA_RECEIVED		0x0000
+#define ISNS_EVENT_CONNECTION_OPENED		0x0001
+#define ISNS_EVENT_CONNECTION_FAILED		0x0002
+#define MBOX_ASTS_IPSEC_SYSTEM_FATAL_ERROR	0x8022
+#define MBOX_ASTS_SUBNET_STATE_CHANGE		0x8027
+
+/*************************************************************************/
+
+/* Host Adapter Initialization Control Block (from host) */
+typedef struct _INIT_FW_CTRL_BLK {
+	uint8_t Version;	/* 00 */
+	uint8_t Control;	/* 01 */
+
+	uint16_t FwOptions;	/* 02-03 */
+#define  FWOPT_HEARTBEAT_ENABLE           0x1000
+#define  FWOPT_MARKER_DISABLE             0x0400
+#define  FWOPT_PROTOCOL_STAT_ALARM_ENABLE 0x0200
+#define  FWOPT_TARGET_ACCEPT_AEN_ENABLE   0x0100
+#define  FWOPT_ACCESS_CONTROL_ENABLE      0x0080
+#define  FWOPT_SESSION_MODE               0x0040
+#define  FWOPT_INITIATOR_MODE             0x0020
+#define  FWOPT_TARGET_MODE                0x0010
+#define  FWOPT_FAST_POSTING               0x0008
+#define  FWOPT_AUTO_TARGET_INFO_DISABLE   0x0004
+#define  FWOPT_SENSE_BUFFER_DATA_ENABLE   0x0002
+
+	uint16_t ExecThrottle;	/* 04-05 */
+	uint8_t RetryCount;	/* 06 */
+	uint8_t RetryDelay;	/* 07 */
+	uint16_t MaxEthFrPayloadSize;	/* 08-09 */
+	uint16_t AddFwOptions;	/* 0A-0B */
+#define  ADDFWOPT_AUTOCONNECT_DISABLE     0x0002
+#define  ADDFWOPT_SUSPEND_ON_FW_ERROR     0x0001
+
+	uint8_t HeartbeatInterval;	/* 0C */
+	uint8_t InstanceNumber;	/* 0D */
+	uint16_t RES2;		/* 0E-0F */
+	uint16_t ReqQConsumerIndex;	/* 10-11 */
+	uint16_t ComplQProducerIndex;	/* 12-13 */
+	uint16_t ReqQLen;	/* 14-15 */
+	uint16_t ComplQLen;	/* 16-17 */
+	uint32_t ReqQAddrLo;	/* 18-1B */
+	uint32_t ReqQAddrHi;	/* 1C-1F */
+	uint32_t ComplQAddrLo;	/* 20-23 */
+	uint32_t ComplQAddrHi;	/* 24-27 */
+	uint32_t ShadowRegBufAddrLo;	/* 28-2B */
+	uint32_t ShadowRegBufAddrHi;	/* 2C-2F */
+
+	uint16_t iSCSIOptions;	/* 30-31 */
+#define  IOPT_RCV_ISCSI_MARKER_ENABLE     0x8000
+#define  IOPT_SEND_ISCSI_MARKER_ENABLE    0x4000
+#define  IOPT_HEADER_DIGEST_ENABLE        0x2000
+#define  IOPT_DATA_DIGEST_ENABLE          0x1000
+#define  IOPT_IMMEDIATE_DATA_ENABLE       0x0800
+#define  IOPT_INITIAL_R2T_ENABLE          0x0400
+#define  IOPT_DATA_SEQ_IN_ORDER           0x0200
+#define  IOPT_DATA_PDU_IN_ORDER           0x0100
+#define  IOPT_CHAP_AUTH_ENABLE            0x0080
+#define  IOPT_SNACK_REQ_ENABLE            0x0040
+#define  IOPT_DISCOVERY_LOGOUT_ENABLE     0x0020
+#define  IOPT_BIDIR_CHAP_ENABLE     	     0x0010
+
+	uint16_t TCPOptions;	/* 32-33 */
+#define  TOPT_ISNS_ENABLE		     0x4000
+#define  TOPT_SLP_USE_DA_ENABLE	     0x2000
+#define  TOPT_AUTO_DISCOVERY_ENABLE       0x1000
+#define  TOPT_SLP_UA_ENABLE               0x0800
+#define  TOPT_SLP_SA_ENABLE               0x0400
+#define  TOPT_DHCP_ENABLE                 0x0200
+#define  TOPT_GET_DNS_VIA_DHCP_ENABLE     0x0100
+#define  TOPT_GET_SLP_VIA_DHCP_ENABLE     0x0080
+#define  TOPT_LEARN_ISNS_IP_ADDR_ENABLE   0x0040
+#define  TOPT_NAGLE_DISABLE               0x0020
+#define  TOPT_TIMER_SCALE_MASK            0x000E
+#define  TOPT_TIME_STAMP_ENABLE           0x0001
+
+	uint16_t IPOptions;	/* 34-35 */
+#define  IPOPT_FRAG_DISABLE               0x0010
+#define  IPOPT_PAUSE_FRAME_ENABLE         0x0002
+#define  IPOPT_IP_ADDRESS_VALID           0x0001
+
+	uint16_t MaxPDUSize;	/* 36-37 */
+	uint16_t RcvMarkerInt;	/* 38-39 */
+	uint16_t SndMarkerInt;	/* 3A-3B */
+	uint16_t InitMarkerlessInt;	/* 3C-3D */
+	uint16_t FirstBurstSize;	/* 3E-3F */
+	uint16_t DefaultTime2Wait;	/* 40-41 */
+	uint16_t DefaultTime2Retain;	/* 42-43 */
+	uint16_t MaxOutStndngR2T;	/* 44-45 */
+	uint16_t KeepAliveTimeout;	/* 46-47 */
+	uint16_t PortNumber;	/* 48-49 */
+	uint16_t MaxBurstSize;	/* 4A-4B */
+	uint32_t RES4;		/* 4C-4F */
+	uint8_t IPAddr[4];	/* 50-53 */
+	uint8_t RES5[12];	/* 54-5F */
+	uint8_t SubnetMask[4];	/* 60-63 */
+	uint8_t RES6[12];	/* 64-6F */
+	uint8_t GatewayIPAddr[4];	/* 70-73 */
+	uint8_t RES7[12];	/* 74-7F */
+	uint8_t PriDNSIPAddr[4];	/* 80-83 */
+	uint8_t SecDNSIPAddr[4];	/* 84-87 */
+	uint8_t RES8[8];	/* 88-8F */
+	uint8_t Alias[32];	/* 90-AF */
+	uint8_t TargAddr[8];	/* B0-B7 *///FIXME: Remove??
+	uint8_t CHAPNameSecretsTable[8];	/* B8-BF */
+	uint8_t EthernetMACAddr[6];	/* C0-C5 */
+	uint16_t TargetPortalGroup;	/* C6-C7 */
+	uint8_t SendScale;	/* C8    */
+	uint8_t RecvScale;	/* C9    */
+	uint8_t TypeOfService;	/* CA    */
+	uint8_t Time2Live;	/* CB    */
+	uint16_t VLANPriority;	/* CC-CD */
+	uint16_t Reserved8;	/* CE-CF */
+	uint8_t SecIPAddr[4];	/* D0-D3 */
+	uint8_t Reserved9[12];	/* D4-DF */
+	uint8_t iSNSIPAddr[4];	/* E0-E3 */
+	uint16_t iSNSServerPortNumber;	/* E4-E5 */
+	uint8_t Reserved10[10];	/* E6-EF */
+	uint8_t SLPDAIPAddr[4];	/* F0-F3 */
+	uint8_t Reserved11[12];	/* F4-FF */
+	uint8_t iSCSINameString[256];	/* 100-1FF */
+} INIT_FW_CTRL_BLK;
+
+typedef struct {
+	INIT_FW_CTRL_BLK init_fw_cb;
+	uint32_t Cookie;
+#define INIT_FW_CTRL_BLK_COOKIE 	0x11BEAD5A
+} FLASH_INIT_FW_CTRL_BLK;
+
+/*************************************************************************/
+
+typedef struct _DEV_DB_ENTRY {
+	uint8_t options;	/* 00 */
+#define  DDB_OPT_DISABLE                  0x08	/* do not connect to device */
+#define  DDB_OPT_ACCESSGRANTED            0x04
+#define  DDB_OPT_TARGET                   0x02	/* device is a target */
+#define  DDB_OPT_INITIATOR                0x01	/* device is an initiator */
+
+	uint8_t control;	/* 01 */
+#define  DDB_CTRL_DATABASE_ENTRY_STATE    0xC0
+#define  DDB_CTRL_SESSION_RECOVERY        0x10
+#define  DDB_CTRL_SENDING                 0x08
+#define  DDB_CTRL_XFR_PENDING             0x04
+#define  DDB_CTRL_QUEUE_ABORTED           0x02
+#define  DDB_CTRL_LOGGED_IN               0x01
+
+	uint16_t exeThrottle;	/* 02-03 */
+	uint16_t exeCount;	/* 04-05 */
+	uint8_t retryCount;	/* 06    */
+	uint8_t retryDelay;	/* 07    */
+	uint16_t iSCSIOptions;	/* 08-09 */
+#define DDB_IOPT_RECV_ISCSI_MARKER_ENABLE 0x8000
+#define DDB_IOPT_SEND_ISCSI_MARKER_ENABLE 0x4000
+#define DDB_IOPT_HEADER_DIGEST_ENABLE     0x2000
+#define DDB_IOPT_DATA_DIGEST_ENABLE       0x1000
+#define DDB_IOPT_IMMEDIATE_DATA_ENABLE    0x0800
+#define DDB_IOPT_INITIAL_R2T_ENABLE       0x0400
+#define DDB_IOPT_DATA_SEQUENCE_IN_ORDER   0x0200
+#define DDB_IOPT_DATA_PDU_IN_ORDER        0x0100
+#define DDB_IOPT_CHAP_AUTH_ENABLE         0x0080
+#define DDB_IOPT_BIDIR_CHAP_CHAL_ENABLE   0x0010
+#define DDB_IOPT_RESERVED2                0x007F
+
+	uint16_t TCPOptions;	/* 0A-0B */
+#define DDB_TOPT_NAGLE_DISABLE            0x0020
+#define DDB_TOPT_TIMER_SCALE_MASK         0x000E
+#define DDB_TOPT_TIME_STAMP_ENABLE        0x0001
+
+	uint16_t IPOptions;	/* 0C-0D */
+#define DDB_IPOPT_FRAG_DISABLE     	     0x0002
+#define DDB_IPOPT_IP_ADDRESS_VALID        0x0001
+
+	uint16_t maxPDUSize;	/* 0E-0F */
+	uint16_t rcvMarkerInt;	/* 10-11 */
+	uint16_t sndMarkerInt;	/* 12-13 */
+	uint16_t iSCSIMaxSndDataSegLen;	/* 14-15 */
+	uint16_t firstBurstSize;	/* 16-17 */
+	uint16_t minTime2Wait;	/* 18-19 : RA :default_time2wait */
+	uint16_t maxTime2Retain;	/* 1A-1B */
+	uint16_t maxOutstndngR2T;	/* 1C-1D */
+	uint16_t keepAliveTimeout;	/* 1E-1F */
+	uint8_t ISID[6];	/* 20-25 big-endian, must be converted to little-endian */
+	uint16_t TSID;		/* 26-27 */
+	uint16_t portNumber;	/* 28-29 */
+	uint16_t maxBurstSize;	/* 2A-2B */
+	uint16_t taskMngmntTimeout;	/* 2C-2D */
+	uint16_t reserved1;	/* 2E-2F */
+	uint8_t ipAddr[0x10];	/* 30-3F */
+	uint8_t iSCSIAlias[0x20];	/* 40-5F */
+	uint8_t targetAddr[0x20];	/* 60-7F */
+	uint8_t userID[0x20];	/* 80-9F */
+	uint8_t password[0x20];	/* A0-BF */
+	uint8_t iscsiName[0x100];	/* C0-1BF : xxzzy Make this a pointer to a string so we don't
+					   have to reserve soooo much RAM */
+	uint16_t ddbLink;	/* 1C0-1C1 */
+	uint16_t CHAPTableIndex;	/* 1C2-1C3 */
+	uint16_t TargetPortalGroup;	/* 1C4-1C5 */
+	uint16_t reserved2[2];	/* 1C6-1C7 */
+	uint32_t statSN;	/* 1C8-1CB */
+	uint32_t expStatSN;	/* 1CC-1CF */
+	uint16_t reserved3[0x2C];	/* 1D0-1FB */
+	uint16_t ddbValidCookie;	/* 1FC-1FD */
+	uint16_t ddbValidSize;	/* 1FE-1FF */
+} DEV_DB_ENTRY;
+
+/*************************************************************************/
+
+// Flash definitions
+#define FLASH_FW_IMG_PAGE_SIZE        0x20000
+#define FLASH_FW_IMG_PAGE(addr)       (0xfffe0000 & (addr))
+#define FLASH_STRUCTURE_TYPE_MASK     0x0f000000
+
+#define FLASH_OFFSET_FW_LOADER_IMG    0x00000000
+#define FLASH_OFFSET_SECONDARY_FW_IMG 0x01000000
+#define FLASH_OFFSET_SYS_INFO         0x02000000
+#define FLASH_OFFSET_DRIVER_BLK       0x03000000
+#define FLASH_OFFSET_INIT_FW_CTRL_BLK 0x04000000
+#define FLASH_OFFSET_DEV_DB_AREA      0x05000000
+#define FLASH_OFFSET_CHAP_AREA        0x06000000
+#define FLASH_OFFSET_PRIMARY_FW_IMG   0x07000000
+#define FLASH_READ_RAM_FLAG           0x10000000
+
+#define MAX_FLASH_SZ                  0x400000	/* 4M flash */
+#define FLASH_DEFAULTBLOCKSIZE        0x20000
+#define FLASH_EOF_OFFSET              FLASH_DEFAULTBLOCKSIZE - 8	/* 4 bytes for EOF signature */
+#define FLASH_FILESIZE_OFFSET         FLASH_EOF_OFFSET - 4	/* 4 bytes for file size */
+#define FLASH_CKSUM_OFFSET            FLASH_FILESIZE_OFFSET - 4	/* 4 bytes for chksum protection */
+
+typedef struct _SYS_INFO_PHYS_ADDR {
+	uint8_t address[6];	/* 00-05 */
+	uint8_t filler[2];	/* 06-07 */
+} SYS_INFO_PHYS_ADDR;
+
+typedef struct _FLASH_SYS_INFO {
+	uint32_t cookie;	/* 00-03 */
+	uint32_t physAddrCount;	/* 04-07 */
+	SYS_INFO_PHYS_ADDR physAddr[4];	/* 08-27 */
+	uint8_t vendorId[128];	/* 28-A7 */
+	uint8_t productId[128];	/* A8-127 */
+	uint32_t serialNumber;	/* 128-12B */
+
+	// PCI Configuration values
+	uint32_t pciDeviceVendor;	/* 12C-12F */
+	uint32_t pciDeviceId;	/* 130-133 */
+	uint32_t pciSubsysVendor;	/* 134-137 */
+	uint32_t pciSubsysId;	/* 138-13B */
+
+	// This validates version 1.
+	uint32_t crumbs;	/* 13C-13F */
+
+	uint32_t enterpriseNumber;	/* 140-143 */
+
+	uint32_t mtu;		/* 144-147 */
+	uint32_t reserved0;	/* 148-14b */
+	uint32_t crumbs2;	/* 14c-14f */
+	uint8_t acSerialNumber[16];	/* 150-15f */
+	uint32_t crumbs3;	/* 160-16f */
+
+	// Leave this last in the struct so it is declared invalid if
+	// any new items are added.
+	uint32_t reserved1[39];	/* 170-1ff */
+} FLASH_SYS_INFO, *PFLASH_SYS_INFO;	/* 200 */
+
+typedef struct _FLASH_DRIVER_INFO {
+	uint32_t LinuxDriverCookie;
+#define FLASH_LINUX_DRIVER_COOKIE		0x0A1B2C3D
+	uint8_t Pad[4];
+
+} FLASH_DRIVER_INFO, *PFLASH_DRIVER_INFO;
+
+typedef struct _CHAP_ENTRY {
+	uint16_t link;		//  0 x0
+#define CHAP_FLAG_PEER_NAME		0x40
+#define CHAP_FLAG_LOCAL_NAME    	0x80
+
+	uint8_t flags;		//  2 x2
+#define MIN_CHAP_SECRET_LENGTH  	12
+#define MAX_CHAP_SECRET_LENGTH  	100
+
+	uint8_t secretLength;	//  3 x3
+	uint8_t secret[MAX_CHAP_SECRET_LENGTH];	//  4 x4
+#define MAX_CHAP_CHALLENGE_LENGTH       256
+
+	uint8_t user_name[MAX_CHAP_CHALLENGE_LENGTH];	//104 x68
+	uint16_t reserved;	//360 x168
+#define CHAP_COOKIE                     0x4092
+
+	uint16_t cookie;	//362 x16a
+} CHAP_ENTRY, *PCHAP_ENTRY;	//364 x16c
+
+/*************************************************************************/
+
+typedef struct _CRASH_RECORD {
+	uint16_t fw_major_version;	/* 00 - 01 */
+	uint16_t fw_minor_version;	/* 02 - 03 */
+	uint16_t fw_patch_version;	/* 04 - 05 */
+	uint16_t fw_build_version;	/* 06 - 07 */
+
+	uint8_t build_date[16];	/* 08 - 17 */
+	uint8_t build_time[16];	/* 18 - 27 */
+	uint8_t build_user[16];	/* 28 - 37 */
+	uint8_t card_serial_num[16];	/* 38 - 47 */
+
+	uint32_t time_of_crash_in_secs;	/* 48 - 4B */
+	uint32_t time_of_crash_in_ms;	/* 4C - 4F */
+
+	uint16_t out_RISC_sd_num_frames;	/* 50 - 51 */
+	uint16_t OAP_sd_num_words;	/* 52 - 53 */
+	uint16_t IAP_sd_num_frames;	/* 54 - 55 */
+	uint16_t in_RISC_sd_num_words;	/* 56 - 57 */
+
+	uint8_t reserved1[28];	/* 58 - 7F */
+
+	uint8_t out_RISC_reg_dump[256];	/* 80 -17F */
+	uint8_t in_RISC_reg_dump[256];	/*180 -27F */
+	uint8_t in_out_RISC_stack_dump[0];	/*280 - ??? */
+} CRASH_RECORD, *PCRASH_RECORD;
+
+/*************************************************************************/
+
+#define MAX_CONN_EVENT_LOG_ENTRIES	100
+
+typedef struct _CONN_EVENT_LOG_ENTRY {
+	uint32_t timestamp_sec;	/* 00 - 03 seconds since boot */
+	uint32_t timestamp_ms;	/* 04 - 07 milliseconds since boot */
+	uint16_t device_index;	/* 08 - 09  */
+	uint16_t fw_conn_state;	/* 0A - 0B  */
+	uint8_t event_type;	/* 0C - 0C  */
+	uint8_t error_code;	/* 0D - 0D  */
+	uint16_t error_code_detail;	/* 0E - 0F  */
+	uint8_t num_consecutive_events;	/* 10 - 10  */
+	uint8_t rsvd[3];	/* 11 - 13  */
+} CONN_EVENT_LOG_ENTRY, *PCONN_EVENT_LOG_ENTRY;
+
+/*************************************************************************
+ *
+ *				IOCB Commands Structures and Definitions
+ *
+ *************************************************************************/
+#define IOCB_MAX_CDB_LEN            16	/* Bytes in a CBD */
+#define IOCB_MAX_SENSEDATA_LEN      32	/* Bytes of sense data */
+#define IOCB_MAX_EXT_SENSEDATA_LEN  60	/* Bytes of extended sense data */
+#define IOCB_MAX_DSD_CNT             1	/* DSDs per noncontinuation type IOCB */
+#define IOCB_CONT_MAX_DSD_CNT        5	/* DSDs per Continuation */
+#define CTIO_MAX_SENSEDATA_LEN      24	/* Bytes of sense data in a CTIO */
+
+#define RESERVED_BYTES_MARKER       40	/* Reserved Bytes at end of Marker */
+#define RESERVED_BYTES_INOT         28	/* Reserved Bytes at end of Immediate Notify */
+#define RESERVED_BYTES_NOTACK       28	/* Reserved Bytes at end of Notify Acknowledge */
+#define RESERVED_BYTES_CTIO          2	/* Reserved Bytes in middle of CTIO */
+
+#define MAX_MBX_COUNT               14	/* Maximum number of mailboxes in MBX IOCB */
+
+#define ISCSI_MAX_NAME_BYTECNT      256	/* Bytes in a target name */
+
+#define IOCB_ENTRY_SIZE       	    0x40
+
+/* IOCB header structure */
+typedef struct _HEADER {
+	uint8_t entryType;
+#define ET_STATUS                0x03
+#define ET_MARKER                0x04
+#define ET_CONT_T1               0x0A
+#define ET_INOT                  0x0D
+#define ET_NACK                  0x0E
+#define ET_STATUS_CONTINUATION   0x10
+#define ET_CMND_T4               0x15
+#define ET_ATIO                  0x16
+#define ET_CMND_T3               0x19
+#define ET_CTIO4                 0x1E
+#define ET_CTIO3                 0x1F
+#define ET_PERFORMANCE_STATUS    0x20
+#define ET_MAILBOX_CMD           0x38
+#define ET_MAILBOX_STATUS        0x39
+#define ET_PASSTHRU0             0x3A
+#define ET_PASSTHRU1             0x3B
+#define ET_PASSTHRU_STATUS       0x3C
+#define ET_ASYNCH_MSG            0x3D
+#define ET_CTIO5                 0x3E
+#define ET_CTIO6                 0x3F
+
+	uint8_t entryStatus;
+#define ES_MASK                 0x3E
+#define ES_SUPPRESS_COMPL_INT   0x01
+#define ES_BUSY                 0x02
+#define ES_INVALID_ENTRY_TYPE   0x04
+#define ES_INVALID_ENTRY_PARAM  0x08
+#define ES_INVALID_ENTRY_COUNT  0x10
+#define ES_INVALID_ENTRY_ORDER  0x20
+	uint8_t systemDefined;
+	uint8_t entryCount;
+
+	/* SyetemDefined definition */
+#define SD_PASSTHRU_IOCB        0x01
+} HEADER;
+
+/* Genric queue entry structure*/
+typedef struct QUEUE_ENTRY {
+	uint8_t data[60];
+	uint32_t signature;
+
+} QUEUE_ENTRY;
+
+/* 64 bit addressing segment counts*/
+
+#define COMMAND_SEG_A64             1
+#define CONTINUE_SEG_A64            5
+#define CONTINUE_SEG_A64_MINUS1     4
+
+/* 64 bit addressing segment definition*/
+
+typedef struct DATA_SEG_A64 {
+	struct {
+		uint32_t addrLow;
+		uint32_t addrHigh;
+
+	} base;
+
+	uint32_t count;
+
+} DATA_SEG_A64;
+
+/* Command Type 3 entry structure*/
+
+typedef struct _COMMAND_T3_ENTRY {
+	HEADER hdr;		/* 00-03 */
+
+	uint32_t handle;	/* 04-07 */
+	uint16_t target;	/* 08-09 */
+	uint16_t connection_id;	/* 0A-0B */
+
+	uint8_t control_flags;	/* 0C */
+#define CF_IMMEDIATE		   0x80
+
+	/* data direction  (bits 5-6) */
+#define CF_WRITE                0x20
+#define CF_READ                 0x40
+#define CF_NO_DATA              0x00
+#define CF_DIRECTION_MASK       0x60
+
+	/* misc  (bits 4-3) */
+#define CF_DSD_PTR_ENABLE	   0x10	/* 4010 only */
+#define CF_CMD_PTR_ENABLE	   0x08	/* 4010 only */
+
+	/* task attributes (bits 2-0) */
+#define CF_ACA_QUEUE            0x04
+#define CF_HEAD_TAG             0x03
+#define CF_ORDERED_TAG          0x02
+#define CF_SIMPLE_TAG           0x01
+#define CF_TAG_TYPE_MASK        0x07
+#define CF_ATTRIBUTES_MASK      0x67
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	 */
+	uint8_t state_flags;	/* 0D */
+	uint8_t cmdRefNum;	/* 0E */
+	uint8_t reserved1;	/* 0F */
+	uint8_t cdb[IOCB_MAX_CDB_LEN];	/* 10-1F */
+	struct scsi_lun lun;	/* FCP LUN (BE). */
+	uint32_t cmdSeqNum;	/* 28-2B */
+	uint16_t timeout;	/* 2C-2D */
+	uint16_t dataSegCnt;	/* 2E-2F */
+	uint32_t ttlByteCnt;	/* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+
+} COMMAND_T3_ENTRY;
+
+typedef struct _COMMAND_T4_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t target;	/* 08-09 */
+	uint16_t connection_id;	/* 0A-0B */
+	uint8_t control_flags;	/* 0C */
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	 */
+	uint8_t state_flags;	/* 0D */
+	uint8_t cmdRefNum;	/* 0E */
+	uint8_t reserved1;	/* 0F */
+	uint8_t cdb[IOCB_MAX_CDB_LEN];	/* 10-1F */
+	struct scsi_lun lun;	/* FCP LUN (BE). */
+	uint32_t cmdSeqNum;	/* 28-2B */
+	uint16_t timeout;	/* 2C-2D */
+	uint16_t dataSegCnt;	/* 2E-2F */
+	uint32_t ttlByteCnt;	/* 30-33 */
+
+	/* WE ONLY USE THE ADDRESS FIELD OF THE FOLLOWING STRUCT.
+	   THE COUNT FIELD IS RESERVED */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+} COMMAND_T4_ENTRY;
+
+/* Continuation Type 1 entry structure*/
+typedef struct _CONTINUATION_T1_ENTRY {
+	HEADER hdr;
+
+	DATA_SEG_A64 dataseg[CONTINUE_SEG_A64];
+
+} CONTINUATION_T1_ENTRY;
+
+/* Status Continuation Type entry structure*/
+typedef struct _STATUS_CONTINUATION_ENTRY {
+	HEADER hdr;
+
+	uint8_t extSenseData[IOCB_MAX_EXT_SENSEDATA_LEN];
+
+} STATUS_CONTINUATION_ENTRY;
+
+/* Parameterize for 64 or 32 bits */
+#define COMMAND_SEG     COMMAND_SEG_A64
+#define CONTINUE_SEG    CONTINUE_SEG_A64
+
+#define COMMAND_ENTRY   COMMAND_T3_ENTRY
+#define CONTINUE_ENTRY  CONTINUATION_T1_ENTRY
+
+#define ET_COMMAND      ET_CMND_T3
+#define ET_CONTINUE     ET_CONT_T1
+
+/* Marker entry structure*/
+typedef struct _MARKER_ENTRY {
+	HEADER hdr;		/* 00-03 */
+
+	uint32_t system_defined;	/* 04-07 */
+	uint16_t target;	/* 08-09 */
+	uint16_t modifier;	/* 0A-0B */
+#define MM_LUN_RESET         0
+#define MM_TARGET_WARM_RESET 1
+#define MM_TARGET_COLD_RESET 2
+#define MM_CLEAR_ACA    	3
+#define MM_CLEAR_TASK_SET    4
+#define MM_ABORT_TASK_SET    5
+
+	uint16_t flags;		/* 0C-0D */
+	uint16_t reserved1;	/* 0E-0F */
+	struct scsi_lun lun;	/* FCP LUN (BE). */
+	uint64_t reserved2;	/* 18-1F */
+	uint64_t reserved3;	/* 20-27 */
+	uint64_t reserved4;	/* 28-2F */
+	uint64_t reserved5;	/* 30-37 */
+	uint64_t reserved6;	/* 38-3F */
+} MARKER_ENTRY;
+
+/* Status entry structure*/
+typedef struct _STATUS_ENTRY {
+	HEADER hdr;		/* 00-03 */
+
+	uint32_t handle;	/* 04-07 */
+
+	uint8_t scsiStatus;	/* 08 */
+#define SCSI_STATUS_MASK                  0xFF
+#define SCSI_STATUS                       0xFF
+#define SCSI_GOOD                         0x00
+#define SCSI_CHECK_CONDITION              0x02
+
+	uint8_t iscsiFlags;	/* 09 */
+#define ISCSI_FLAG_RESIDUAL_UNDER         0x02
+#define ISCSI_FLAG_RESIDUAL_OVER          0x04
+#define ISCSI_FLAG_RESIDUAL_UNDER_BIREAD  0x08
+#define ISCSI_FLAG_RESIDUAL_OVER_BIREAD   0x10
+
+	uint8_t iscsiResponse;	/* 0A */
+#define ISCSI_RSP_COMPLETE                    0x00
+#define ISCSI_RSP_TARGET_FAILURE              0x01
+#define ISCSI_RSP_DELIVERY_SUBSYS_FAILURE     0x02
+#define ISCSI_RSP_UNSOLISITED_DATA_REJECT     0x03
+#define ISCSI_RSP_NOT_ENOUGH_UNSOLISITED_DATA 0x04
+#define ISCSI_RSP_CMD_IN_PROGRESS             0x05
+
+	uint8_t completionStatus;	/* 0B */
+#define SCS_COMPLETE                      0x00
+#define SCS_INCOMPLETE                    0x01
+#define SCS_DMA_ERROR                     0x02
+#define SCS_TRANSPORT_ERROR               0x03
+#define SCS_RESET_OCCURRED                0x04
+#define SCS_ABORTED                       0x05
+#define SCS_TIMEOUT                       0x06
+#define SCS_DATA_OVERRUN                  0x07
+#define SCS_DATA_DIRECTION_ERROR          0x08
+#define SCS_DATA_UNDERRUN                 0x15
+#define SCS_QUEUE_FULL                    0x1C
+#define SCS_DEVICE_UNAVAILABLE            0x28
+#define SCS_DEVICE_LOGGED_OUT             0x29
+#define SCS_DEVICE_CONFIG_CHANGED         0x2A
+
+	uint8_t reserved1;	/* 0C */
+
+	/* state_flags MUST be at the same location as state_flags in the
+	   Command_T3/4_Entry */
+	uint8_t state_flags;	/* 0D */
+#define STATE_FLAG_SENT_COMMAND           0x01
+#define STATE_FLAG_TRANSFERRED_DATA       0x02
+#define STATE_FLAG_GOT_STATUS             0x04
+#define STATE_FLAG_LOGOUT_SENT            0x10
+
+	uint16_t senseDataByteCnt;	/* 0E-0F */
+	uint32_t residualByteCnt;	/* 10-13 */
+	uint32_t bidiResidualByteCnt;	/* 14-17 */
+	uint32_t expSeqNum;	/* 18-1B */
+	uint32_t maxCmdSeqNum;	/* 1C-1F */
+	uint8_t senseData[IOCB_MAX_SENSEDATA_LEN];	/* 20-3F */
+
+} STATUS_ENTRY;
+
+/*
+ * Performance Status Entry where up to 30 handles can be posted in a
+ * single IOSB. Handles are of 16 bit value.
+ */
+typedef struct _PERFORMANCE_STATUS_ENTRY {
+	uint8_t entryType;
+	uint8_t entryCount;
+	uint16_t handleCount;
+
+#define MAX_STATUS_HANDLE  30
+	uint16_t handleArray[MAX_STATUS_HANDLE];
+
+} PERFORMANCE_STATUS_ENTRY;
+
+typedef struct _IMMEDIATE_NOTIFY_ENTRY {
+	HEADER hdr;
+	uint32_t handle;
+	uint16_t initiator;
+	uint16_t InitSessionID;
+	uint16_t ConnectionID;
+	uint16_t TargSessionID;
+	uint16_t inotStatus;
+#define INOT_STATUS_ABORT_TASK      0x0020
+#define INOT_STATUS_LOGIN_RECVD     0x0021
+#define INOT_STATUS_LOGOUT_RECVD    0x0022
+#define INOT_STATUS_LOGGED_OUT      0x0029
+#define INOT_STATUS_RESTART_RECVD   0x0030
+#define INOT_STATUS_MSG_RECVD       0x0036
+#define INOT_STATUS_TSK_REASSIGN    0x0037
+
+	uint16_t taskFlags;
+#define TASK_FLAG_CLEAR_ACA         0x4000
+#define TASK_FLAG_COLD_RESET        0x2000
+#define TASK_FLAG_WARM_RESET        0x0800
+#define TASK_FLAG_LUN_RESET         0x1000
+#define TASK_FLAG_CLEAR_TASK_SET    0x0400
+#define TASK_FLAG_ABORT_TASK_SET    0x0200
+
+	uint32_t refTaskTag;
+	struct scsi_lun lun;	/* FCP LUN (BE). */
+	uint32_t inotTaskTag;
+	uint8_t res3[RESERVED_BYTES_INOT];
+} IMMEDIATE_NOTIFY_ENTRY;
+
+typedef struct _NOTIFY_ACK_ENTRY {
+	HEADER hdr;
+	uint32_t handle;
+	uint16_t initiator;
+	uint16_t res1;
+	uint16_t flags;
+	uint8_t responseCode;
+	uint8_t qualifier;
+	uint16_t notAckStatus;
+	uint16_t taskFlags;
+#define NACK_FLAG_RESPONSE_CODE_VALID 0x0010
+
+	uint32_t refTaskTag;
+	struct scsi_lun lun;	/* FCP LUN (BE). */
+	uint32_t inotTaskTag;
+	uint8_t res3[RESERVED_BYTES_NOTACK];
+} NOTIFY_ACK_ENTRY;
+
+typedef struct _ATIO_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t initiator;	/* 08-09 */
+	uint16_t connectionID;	/* 0A-0B */
+	uint32_t taskTag;	/* 0C-0f */
+	uint8_t scsiCDB[IOCB_MAX_CDB_LEN];	/* 10-1F */
+	uint8_t LUN[8];		/* 20-27 */
+	uint8_t cmdRefNum;	/* 28 */
+
+	uint8_t pduType;	/* 29 */
+#define PDU_TYPE_NOPOUT                0x00
+#define PDU_TYPE_SCSI_CMD              0x01
+#define PDU_TYPE_SCSI_TASK_MNGMT_CMD   0x02
+#define PDU_TYPE_LOGIN_CMD             0x03
+#define PDU_TYPE_TEXT_CMD              0x04
+#define PDU_TYPE_SCSI_DATA             0x05
+#define PDU_TYPE_LOGOUT_CMD            0x06
+#define PDU_TYPE_SNACK                 0x10
+
+	uint16_t atioStatus;	/* 2A-2B */
+#define ATIO_CDB_RECVD                 0x003d
+
+	uint16_t reserved1;	/* 2C-2D */
+
+	uint8_t taskCode;	/* 2E */
+#define ATIO_TASK_CODE_UNTAGGED        0x00
+#define ATIO_TASK_CODE_SIMPLE_QUEUE    0x01
+#define ATIO_TASK_CODE_ORDERED_QUEUE   0x02
+#define ATIO_TASK_CODE_HEAD_OF_QUEUE   0x03
+#define ATIO_TASK_CODE_ACA_QUEUE       0x04
+
+	uint8_t reserved2;	/* 2F */
+	uint32_t totalByteCnt;	/* 30-33 */
+	uint32_t cmdSeqNum;	/* 34-37 */
+	uint64_t immDataBufDesc;	/* 38-3F */
+} ATIO_ENTRY;
+
+typedef struct _CTIO3_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t initiator;	/* 08-09 */
+	uint16_t connectionID;	/* 0A-0B */
+	uint32_t taskTag;	/* 0C-0F */
+
+	uint8_t flags;		/* 10 */
+#define CTIO_FLAG_SEND_SCSI_STATUS     0x01
+#define CTIO_FLAG_TERMINATE_COMMAND    0x10
+#define CTIO_FLAG_FAST_POST            0x08
+#define CTIO_FLAG_FINAL_CTIO           0x80
+
+	/*  NOTE:  Our firmware assumes that the CTIO_FLAG_SEND_DATA and
+	   CTIO_FLAG_GET_DATA flags are in the same bit positions
+	   as the R and W bits in SCSI Command PDUs, so their values
+	   should not be changed!
+	 */
+#define CTIO_FLAG_SEND_DATA            0x0040	/* (see note) Read Data Flag, send data to initiator       */
+#define CTIO_FLAG_GET_DATA             0x0020	/* (see note) Write Data Flag, get data from the initiator */
+
+	uint8_t scsiStatus;	/* 11 */
+	uint16_t timeout;	/* 12-13 */
+	uint32_t offset;	/* 14-17 */
+	uint32_t r2tSN;		/* 18-1B */
+	uint32_t expCmdSN;	/* 1C-1F */
+	uint32_t maxCmdSN;	/* 20-23 */
+	uint32_t dataSN;	/* 24-27 */
+	uint32_t residualCount;	/* 28-2B */
+	uint16_t reserved;	/* 2C-2D */
+	uint16_t segmentCnt;	/* 2E-2F */
+	uint32_t totalByteCnt;	/* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+} CTIO3_ENTRY;
+
+typedef struct _CTIO4_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t initiator;	/* 08-09 */
+	uint16_t connectionID;	/* 0A-0B */
+	uint32_t taskTag;	/* 0C-0F */
+	uint8_t flags;		/* 10 */
+	uint8_t scsiStatus;	/* 11 */
+	uint16_t timeout;	/* 12-13 */
+	uint32_t offset;	/* 14-17 */
+	uint32_t r2tSN;		/* 18-1B */
+	uint32_t expCmdSN;	/* 1C-1F */
+	uint32_t maxCmdSN;	/* 20-23 */
+	uint32_t dataSN;	/* 24-27 */
+	uint32_t residualCount;	/* 28-2B */
+	uint16_t reserved;	/* 2C-2D */
+	uint16_t segmentCnt;	/* 2E-2F */
+	uint32_t totalByteCnt;	/* 30-33 */
+	/* WE ONLY USE THE ADDRESS FROM THE FOLLOWING STRUCTURE THE COUNT FIELD IS
+	   RESERVED */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+} CTIO4_ENTRY;
+
+typedef struct _CTIO5_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t initiator;	/* 08-09 */
+	uint16_t connectionID;	/* 0A-0B */
+	uint32_t taskTag;	/* 0C-0F */
+	uint8_t response;	/* 10 */
+	uint8_t scsiStatus;	/* 11 */
+	uint16_t timeout;	/* 12-13 */
+	uint32_t reserved1;	/* 14-17 */
+	uint32_t expR2TSn;	/* 18-1B */
+	uint32_t expCmdSn;	/* 1C-1F */
+	uint32_t MaxCmdSn;	/* 20-23 */
+	uint32_t expDataSn;	/* 24-27 */
+	uint32_t residualCnt;	/* 28-2B */
+	uint32_t bidiResidualCnt;	/* 2C-2F */
+	uint32_t reserved2;	/* 30-33 */
+	DATA_SEG_A64 dataseg[1];	/* 34-3F */
+} CTIO5_ENTRY;
+
+typedef struct _CTIO6_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t initiator;	/* 08-09 */
+	uint16_t connection;	/* 0A-0B */
+	uint32_t taskTag;	/* 0C-0F */
+	uint16_t flags;		/* 10-11 */
+	uint16_t timeout;	/* 12-13 */
+	uint32_t reserved1;	/* 14-17 */
+	uint64_t reserved2;	/* 18-1F */
+	uint64_t reserved3;	/* 20-27 */
+	uint64_t reserved4;	/* 28-2F */
+	uint32_t reserved5;	/* 30-33 */
+	DATA_SEG_A64 dataseg[1];	/* 34-3F */
+} CTIO6_ENTRY;
+
+typedef struct _CTIO_STATUS_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t initiator;	/* 08-09 */
+	uint16_t connectionID;	/* 0A-0B */
+	uint32_t taskTag;	/* 0C-0F */
+	uint16_t status;	/* 10-11 */
+#define CTIO_STATUS_COMPLETE           0x0001
+#define CTIO_STATUS_ABORTED            0x0002
+#define CTIO_STATUS_DMA_ERROR          0x0003
+#define CTIO_STATUS_ERROR              0x0004
+#define CTIO_STATUS_INVALID_TAG        0x0008
+#define CTIO_STATUS_DATA_OVERRUN       0x0009
+#define CTIO_STATUS_CMD_TIMEOUT        0x000B
+#define CTIO_STATUS_PCI_ERROR          0x0010
+#define CTIO_STATUS_DATA_UNDERRUN      0x0015
+#define CTIO_STATUS_TARGET_RESET       0x0017
+#define CTIO_STATUS_NO_CONNECTION      0x0028
+#define CTIO_STATUS_LOGGED_OUT         0x0029
+#define CTIO_STATUS_CONFIG_CHANGED     0x002A
+#define CTIO_STATUS_UNACK_EVENT        0x0035
+#define CTIO_STATUS_INVALID_DATA_XFER  0x0036
+
+	uint16_t timeout;	/* 12-13 */
+	uint32_t reserved1;	/* 14-17 */
+	uint32_t expR2TSN;	/* 18-1B */
+	uint32_t reserved2;	/* 1C-1F */
+	uint32_t reserved3;	/* 20-23 */
+	uint64_t expDataSN;	/* 24-27 */
+	uint32_t residualCount;	/* 28-2B */
+	uint32_t reserved4;	/* 2C-2F */
+	uint64_t reserved5;	/* 30-37 */
+	uint64_t reserved6;	/* 38-3F */
+} CTIO_STATUS_ENTRY;
+
+typedef struct _MAILBOX_ENTRY {
+	HEADER hdr;
+	uint32_t handle;
+	uint32_t mbx[MAX_MBX_COUNT];
+} MAILBOX_ENTRY;
+
+typedef struct MAILBOX_STATUS_ENTRY {
+	HEADER hdr;
+	uint32_t handle;
+	uint32_t mbx[MAX_MBX_COUNT];
+} MAILBOX_STATUS_ENTRY;
+
+typedef struct _PDU_ENTRY {
+	uint8_t *Buff;
+	uint32_t BuffLen;
+	uint32_t SendBuffLen;
+	uint32_t RecvBuffLen;
+	struct _PDU_ENTRY *Next;
+	dma_addr_t DmaBuff;
+} PDU_ENTRY, *PPDU_ENTRY;
+
+typedef struct _PASSTHRU0_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t target;	/* 08-09 */
+	uint16_t connectionID;	/* 0A-0B */
+#define ISNS_DEFAULT_SERVER_CONN_ID     ((uint16_t)0x8000)
+
+	uint16_t controlFlags;	/* 0C-0D */
+#define PT_FLAG_ETHERNET_FRAME   	0x8000
+#define PT_FLAG_ISNS_PDU                0x8000
+#define PT_FLAG_IP_DATAGRAM             0x4000
+#define PT_FLAG_TCP_PACKET              0x2000
+#define PT_FLAG_NETWORK_PDU             (PT_FLAG_ETHERNET_FRAME | PT_FLAG_IP_DATAGRAM | PT_FLAG_TCP_PACKET)
+#define PT_FLAG_iSCSI_PDU               0x1000
+#define PT_FLAG_SEND_BUFFER             0x0200
+#define PT_FLAG_WAIT_4_RESPONSE         0x0100
+#define PT_FLAG_NO_FAST_POST            0x0080
+
+	uint16_t timeout;	/* 0E-0F */
+#define PT_DEFAULT_TIMEOUT              30	// seconds
+
+	DATA_SEG_A64 outDataSeg64;	/* 10-1B */
+	uint32_t res1;		/* 1C-1F */
+	DATA_SEG_A64 inDataSeg64;	/* 20-2B */
+	uint8_t res2[20];	/* 2C-3F */
+} PASSTHRU0_ENTRY;
+
+typedef struct _PASSTHRU1_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t target;	/* 08-09 */
+	uint16_t connectionID;	/* 0A-0B */
+
+	uint16_t controlFlags;	/* 0C-0D */
+#define PT_FLAG_ETHERNET_FRAME         	0x8000
+#define PT_FLAG_IP_DATAGRAM            	0x4000
+#define PT_FLAG_TCP_PACKET             	0x2000
+#define PT_FLAG_iSCSI_PDU              	0x1000
+#define PT_FLAG_SEND_BUFFER            	0x0200
+#define PT_FLAG_WAIT_4_REPONSE         	0x0100
+#define PT_FLAG_NO_FAST_POST           	0x0080
+
+	uint16_t timeout;	/* 0E-0F */
+	DATA_SEG_A64 outDSDList;	/* 10-1B */
+	uint32_t outDSDCnt;	/* 1C-1F */
+	DATA_SEG_A64 inDSDList;	/* 20-2B */
+	uint32_t inDSDCnt;	/* 2C-2F */
+	uint8_t res1;		/* 30-3F */
+
+} PASSTHRU1_ENTRY;
+
+typedef struct _PASSTHRU_STATUS_ENTRY {
+	HEADER hdr;		/* 00-03 */
+	uint32_t handle;	/* 04-07 */
+	uint16_t target;	/* 08-09 */
+	uint16_t connectionID;	/* 0A-0B */
+
+	uint8_t completionStatus;	/* 0C */
+#define PASSTHRU_STATUS_COMPLETE       		0x01
+#define PASSTHRU_STATUS_ERROR          		0x04
+#define PASSTHRU_STATUS_INVALID_DATA_XFER            0x06
+#define PASSTHRU_STATUS_CMD_TIMEOUT    		0x0B
+#define PASSTHRU_STATUS_PCI_ERROR      		0x10
+#define PASSTHRU_STATUS_NO_CONNECTION  		0x28
+
+	uint8_t residualFlags;	/* 0D */
+#define PASSTHRU_STATUS_DATAOUT_OVERRUN              0x01
+#define PASSTHRU_STATUS_DATAOUT_UNDERRUN             0x02
+#define PASSTHRU_STATUS_DATAIN_OVERRUN               0x04
+#define PASSTHRU_STATUS_DATAIN_UNDERRUN              0x08
+
+	uint16_t timeout;	/* 0E-0F */
+	uint16_t portNumber;	/* 10-11 */
+	uint8_t res1[10];	/* 12-1B */
+	uint32_t outResidual;	/* 1C-1F */
+	uint8_t res2[12];	/* 20-2B */
+	uint32_t inResidual;	/* 2C-2F */
+	uint8_t res4[16];	/* 30-3F */
+} PASSTHRU_STATUS_ENTRY;
+
+typedef struct _ASYNCHMSG_ENTRY {
+	HEADER hdr;
+	uint32_t handle;
+	uint16_t target;
+	uint16_t connectionID;
+	struct scsi_lun lun;	/* FCP LUN (BE). */
+	uint16_t iSCSIEvent;
+#define AMSG_iSCSI_EVENT_NO_EVENT                  0x0000
+#define AMSG_iSCSI_EVENT_TARG_RESET                0x0001
+#define AMSG_iSCSI_EVENT_TARGT_LOGOUT              0x0002
+#define AMSG_iSCSI_EVENT_CONNECTION_DROPPED        0x0003
+#define AMSG_ISCSI_EVENT_ALL_CONNECTIONS_DROPPED   0x0004
+
+	uint16_t SCSIEvent;
+#define AMSG_NO_SCSI_EVENT                         0x0000
+#define AMSG_SCSI_EVENT                            0x0001
+
+	uint16_t parameter1;
+	uint16_t parameter2;
+	uint16_t parameter3;
+	uint32_t expCmdSn;
+	uint32_t maxCmdSn;
+	uint16_t senseDataCnt;
+	uint16_t reserved;
+	uint32_t senseData[IOCB_MAX_SENSEDATA_LEN];
+} ASYNCHMSG_ENTRY;
+
+/* Timer entry structure, this is an internal generated structure
+   which causes the QLA4000 initiator to send a NOP-OUT or the
+   QLA4000 target to send a NOP-IN */
+
+typedef struct _TIMER_ENTRY {
+	HEADER hdr;		/* 00-03 */
+
+	uint32_t handle;	/* 04-07 */
+	uint16_t target;	/* 08-09 */
+	uint16_t connection_id;	/* 0A-0B */
+
+	uint8_t control_flags;	/* 0C */
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	 */
+	uint8_t state_flags;	/* 0D */
+	uint8_t cmdRefNum;	/* 0E */
+	uint8_t reserved1;	/* 0F */
+	uint8_t cdb[IOCB_MAX_CDB_LEN];	/* 10-1F */
+	struct scsi_lun lun;	/* FCP LUN (BE). */
+	uint32_t cmdSeqNum;	/* 28-2B */
+	uint16_t timeout;	/* 2C-2D */
+	uint16_t dataSegCnt;	/* 2E-2F */
+	uint32_t ttlByteCnt;	/* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+
+} TIMER_ENTRY;
+
+#endif				/* _QLA4X_FW_H */
diff --git a/drivers/scsi/qla4xxx/ql4_glbl.h b/drivers/scsi/qla4xxx/ql4_glbl.h
new file mode 100644
index 0000000..530a7f6
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_glbl.h
@@ -0,0 +1,140 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#ifndef __QLA4x_GBL_H
+#define	__QLA4x_GBL_H
+
+/*
+ * Defined in ql4_os.c
+ */
+extern void qla4xxx_start_io(scsi_qla_host_t * ha);
+extern srb_t *del_from_active_array(scsi_qla_host_t * ha, uint32_t index);
+extern void qla4xxx_srb_compl(scsi_qla_host_t *, srb_t *);
+extern int qla4xxx_reset_lun(scsi_qla_host_t * ha, ddb_entry_t * ddb_entry,
+				 int);
+extern int qla4xxx_soft_reset(scsi_qla_host_t *);
+extern const char *host_sts_msg[];
+extern void qla4xxx_delete_timer_from_cmd(srb_t * srb);
+extern scsi_qla_host_t *qla4xxx_get_adapter_handle(uint16_t instance);
+extern void qla4xxx_free_ddb_list(scsi_qla_host_t * ha);
+extern void qla4xxx_mark_device_missing(scsi_qla_host_t *, ddb_entry_t *);
+extern int extended_error_logging;
+extern int ql4xdontresethba;
+
+/*
+ * Defined in  ql4_iocb.c
+ */
+extern int qla4xxx_send_marker(scsi_qla_host_t * ha,
+				   ddb_entry_t * ddb_entry, int);
+extern int qla4xxx_send_marker_iocb(scsi_qla_host_t * ha,
+					ddb_entry_t * ddb_entry, int);
+extern int qla4xxx_get_req_pkt(scsi_qla_host_t *, QUEUE_ENTRY **);
+extern PDU_ENTRY *qla4xxx_get_pdu(scsi_qla_host_t *, uint32_t);
+extern void qla4xxx_free_pdu(scsi_qla_host_t *, PDU_ENTRY *);
+extern int qla4xxx_send_passthru0_iocb(scsi_qla_host_t *, uint16_t,
+					   uint16_t, dma_addr_t, uint32_t,
+					   uint32_t, uint16_t, uint32_t);
+
+/*
+ * Defined in  ql4_isr.c
+ */
+extern irqreturn_t qla4xxx_intr_handler(int, void *, struct pt_regs *);
+extern void qla4xxx_interrupt_service_routine(scsi_qla_host_t * ha,
+					      uint32_t intr_status);
+
+/*
+ * Defined in  ql4_init.c
+ */
+extern int qla4xxx_initialize_adapter(scsi_qla_host_t * ha,
+					  uint8_t renew_ddb_list);
+extern ddb_entry_t *qla4xxx_alloc_ddb(scsi_qla_host_t * ha,
+				      uint32_t fw_ddb_index);
+extern int qla4xxx_update_ddb_entry(scsi_qla_host_t * ha,
+					ddb_entry_t * ddb_entry,
+					uint32_t fw_ddb_index);
+extern int qla4xxx_get_fwddb_entry(scsi_qla_host_t * ha,
+				       uint16_t fw_ddb_index,
+				       DEV_DB_ENTRY * fw_ddb_entry,
+				       dma_addr_t fw_ddb_entry_dma,
+				       uint32_t * num_valid_ddb_entries,
+				       uint32_t * next_ddb_index,
+				       uint32_t * fw_ddb_device_state,
+				       uint32_t * time2wait,
+				       uint16_t * tcp_source_port_num,
+				       uint16_t * connection_id);
+extern int qla4xxx_relogin_device(scsi_qla_host_t * ha,
+				      ddb_entry_t * ddb_entry);
+extern int qla4xxx_send_command_to_isp(scsi_qla_host_t *, srb_t *);
+extern int qla4xxx_get_prop_12chars(scsi_qla_host_t * ha, uint8_t * propname,
+				    uint8_t * propval, uint8_t * db);
+extern void qla4xxx_free_ddb(scsi_qla_host_t * ha, ddb_entry_t * ddb_entry);
+extern int qla4xxx_resize_ioctl_dma_buf(scsi_qla_host_t * ha,
+					    uint32_t size);
+extern int qla4xxx_set_ddb_entry(scsi_qla_host_t * ha,
+				     uint16_t fw_ddb_index,
+				     DEV_DB_ENTRY * fw_ddb_entry,
+				     dma_addr_t fw_ddb_entry_dma);
+extern int qla4xxx_conn_open_session_login(scsi_qla_host_t * ha,
+					       uint16_t fw_ddb_index);
+extern int qla4xxx_process_ddb_changed(scsi_qla_host_t * ha,
+					   uint32_t fw_ddb_index,
+					   uint32_t state);
+extern int qla4xxx_init_rings(scsi_qla_host_t * ha);
+extern int qla4xxx_reinitialize_ddb_list(scsi_qla_host_t * ha);
+
+/*
+ * Defined in  ql4_mbx.c
+ */
+extern void qla4xxx_process_aen(scsi_qla_host_t * ha,
+				uint8_t flush_ddb_chg_aens);
+extern int qla4xxx_mailbox_command(scsi_qla_host_t * ha, uint8_t inCount,
+				       uint8_t outCount, uint32_t * mbx_cmd,
+				       uint32_t * mbx_sts);
+extern int qla4xxx_issue_iocb(scsi_qla_host_t * ha, void *buffer,
+				  dma_addr_t phys_addr, size_t size);
+extern int qla4xxx_get_flash(scsi_qla_host_t *, dma_addr_t, uint32_t,
+				 uint32_t);
+extern int qla4xxx_initialize_fw_cb(scsi_qla_host_t *);
+extern int qla4xxx_get_dhcp_ip_address(scsi_qla_host_t *);
+
+extern int qla4xxx_get_firmware_state(scsi_qla_host_t *);
+extern void qla4xxx_get_crash_record(scsi_qla_host_t *);
+extern int qla4xxx_conn_close_sess_logout(scsi_qla_host_t *, uint16_t,
+					      uint16_t, uint16_t);
+extern int qla4xxx_clear_database_entry(scsi_qla_host_t *, uint16_t);
+extern int qla4xxx_get_fw_version(scsi_qla_host_t * ha);
+extern int qla4xxx_get_firmware_status(scsi_qla_host_t * ha);
+extern void qla4xxx_get_conn_event_log(scsi_qla_host_t * ha);
+
+/*
+ * Defined in  ql4_inioct.c
+ */
+extern void qla4xxx_iocb_pass_done(scsi_qla_host_t * ha,
+				   PASSTHRU_STATUS_ENTRY * sts_entry);
+
+/*
+ * Defined in  ql4_xioct.c
+ */
+extern void qla4xxx_scsi_pass_done(struct scsi_cmnd *cmd);
+extern void qla4xxx_ioctl_sem_init(scsi_qla_host_t * ha);
+
+/*
+ * Defined in  ql4_nvram.c
+ */
+extern u16 RD_NVRAM_WORD(scsi_qla_host_t *, int);
+extern int qla4xxx_is_nvram_configuration_valid(scsi_qla_host_t * ha);
+extern int ql4xxx_sem_lock(scsi_qla_host_t * ha, u32 sem_mask, u32 sem_bits);
+extern void ql4xxx_sem_unlock(scsi_qla_host_t * ha, u32 sem_mask);
+extern int ql4xxx_sem_spinlock(scsi_qla_host_t * ha, u32 sem_mask,
+			       u32 sem_bits);
+
+/*
+ * Defined in  ql4_dbg.c
+ */
+extern void qla4xxx_dump_buffer(uint8_t *, uint32_t);
+
+#endif				/* _QLA4x_GBL_H */
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
new file mode 100644
index 0000000..73f6de8
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -0,0 +1,1540 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#include "ql4_def.h"
+
+/*
+*  QLogic ISP4xxx Hardware Support Function Prototypes.
+ */
+extern int ql4xdiscoverywait;
+
+static void
+ql4xxx_set_mac_number(scsi_qla_host_t * ha)
+{
+	uint32_t value;
+	uint8_t func_number;
+	unsigned long flags;
+
+	/* Get the function number */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	value = RD_REG_DWORD(&ha->reg->ctrl_status);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	func_number = (uint8_t) ((value >> 4) & 0x30);
+	switch (value & ISP_CONTROL_FN_MASK) {
+	case ISP_CONTROL_FN0_SCSI:
+		ha->mac_index = 1;
+		break;
+	case ISP_CONTROL_FN1_SCSI:
+		ha->mac_index = 3;
+		break;
+	default:
+		DEBUG2(printk("scsi%ld: %s: Invalid function number, "
+		    "ispControlStatus = 0x%x\n", ha->host_no, __func__, value));
+		break;
+	}
+	DEBUG2(printk("scsi%ld: %s: mac_index %d.\n", ha->host_no, __func__,
+	    ha->mac_index));
+}
+
+/**************************************************************************
+ * qla4xxx_free_ddb
+ *	This routine deallocates and unlinks the specified ddb_entry from the
+ *	adapter's
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_free_ddb(scsi_qla_host_t * ha, struct ddb_entry *ddb_entry)
+{
+	/* Remove device entry from list */
+	list_del_init(&ddb_entry->list);
+
+	/* Remove device pointer from index mapping arrays */
+	ha->fw_ddb_index_map[ddb_entry->fw_ddb_index] =
+	    (ddb_entry_t *) INVALID_ENTRY;
+	ha->tot_ddbs--;
+
+	/* Free memory for device entry */
+	kfree(ddb_entry);
+}
+
+/**************************************************************************
+ * qla4xxx_free_ddb_list
+ *	This routine deallocates and removes all devices on the sppecified
+ *	adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_free_ddb_list(scsi_qla_host_t * ha)
+{
+	struct list_head *ptr;
+	struct ddb_entry *ddb_entry;
+
+	while (!list_empty(&ha->ddb_list)) {
+		/* Remove device entry from head of list */
+		ptr = ha->ddb_list.next;
+		list_del_init(ptr);
+
+		/* Free memory for device entry */
+		ddb_entry = list_entry(ptr, struct ddb_entry, list);
+		qla4xxx_free_ddb(ha, ddb_entry);
+	}
+}
+
+/*
+ * qla4xxx_init_rings
+ *	This routine initializes the internal queues for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *	The QLA4010 requires us to restart the queues at index 0.
+ *	The QLA4000 doesn't care, so just default to QLA4010's requirement.
+ * Returns:
+ *	QLA_SUCCESS - Always return success.
+ */
+int
+qla4xxx_init_rings(scsi_qla_host_t * ha)
+{
+	uint16_t i;
+	unsigned long flags = 0;
+
+	/* Initialize request queue. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	ha->request_out = 0;
+	ha->request_in = 0;
+	ha->request_ptr = &ha->request_ring[ha->request_in];
+	ha->req_q_count = REQUEST_QUEUE_DEPTH;
+
+	/* Initialize response queue. */
+	ha->response_in = 0;
+	ha->response_out = 0;
+	ha->response_ptr = &ha->response_ring[ha->response_out];
+
+	/*
+	 * Initialize DMA Shadow registers.  The firmware is really supposed to
+	 * take care of this, but on some uniprocessor systems, the shadow
+	 * registers aren't cleared-- causing the interrupt_handler to think
+	 * there are responses to be processed when there aren't.
+	 */
+	ha->shadow_regs->req_q_out = __constant_cpu_to_le32(0);
+	ha->shadow_regs->rsp_q_in = __constant_cpu_to_le32(0);
+	wmb();
+
+	WRT_REG_DWORD(&ha->reg->req_q_in, 0);
+	WRT_REG_DWORD(&ha->reg->rsp_q_out, 0);
+	PCI_POSTING(&ha->reg->rsp_q_out);
+
+	/* Initialize active array */
+	for (i = 0; i < MAX_SRBS; i++)
+		ha->active_srb_array[i] = 0;
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return QLA_SUCCESS;
+}
+
+#define qla4xxx_mac_is_equal(mac1, mac2) (memcmp(mac1, mac2, MAC_ADDR_LEN) == 0)
+
+/**************************************************************************
+ * qla4xxx_validate_mac_address
+ *	This routine validates the M.A.C. Address(es) of the adapter
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully validated M.A.C. address
+ *	QLA_ERROR   - Failed to validate M.A.C. address
+ **************************************************************************/
+static int
+qla4xxx_validate_mac_address(scsi_qla_host_t *ha)
+{
+	FLASH_SYS_INFO *sys_info = NULL;
+	dma_addr_t sys_info_dma;
+	int status = QLA_ERROR;
+
+	sys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),
+	    &sys_info_dma, GFP_KERNEL);
+	if (sys_info == NULL) {
+		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
+		    ha->host_no, __func__));
+
+		goto exit_validate_mac_no_free;
+	}
+	memset(sys_info, 0, sizeof(*sys_info));
+
+	/* Get flash sys info */
+	if (qla4xxx_get_flash(ha, sys_info_dma, FLASH_OFFSET_SYS_INFO,
+	    sizeof(*sys_info)) != QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: get_flash FLASH_OFFSET_SYS_INFO "
+		    "failed\n", ha->host_no, __func__));
+
+		goto exit_validate_mac;
+	}
+
+	/* Save M.A.C. address & serial_number */
+	memcpy(ha->my_mac, &sys_info->physAddr[0].address[0],
+	    min(sizeof(ha->my_mac), sizeof(sys_info->physAddr[0].address)));
+	memcpy(ha->serial_number, &sys_info->acSerialNumber,
+	    min(sizeof(ha->serial_number), sizeof(sys_info->acSerialNumber)));
+
+	status = QLA_SUCCESS;
+
+exit_validate_mac:
+	dma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,
+	    sys_info_dma);
+
+exit_validate_mac_no_free:
+	return status;
+}
+
+/*
+ * qla4xxx_init_local_data
+ *	This routine initializes the local data for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized local data
+ *	QLA_ERROR   - Failed to initialize local data
+ */
+static int
+qla4xxx_init_local_data(scsi_qla_host_t *ha)
+{
+	int i;
+
+	/* Initialize passthru PDU list */
+	for (i = 0; i < (MAX_PDU_ENTRIES - 1); i++)
+		ha->pdu_queue[i].Next = &ha->pdu_queue[i + 1];
+	ha->free_pdu_top = &ha->pdu_queue[0];
+	ha->free_pdu_bottom = &ha->pdu_queue[MAX_PDU_ENTRIES - 1];
+	ha->free_pdu_bottom->Next = NULL;
+	ha->pdu_active = 0;
+
+	/* Initilize aen queue */
+	ha->aen_q_count = MAX_AEN_ENTRIES;
+
+	return qla4xxx_get_firmware_status(ha);
+}
+
+static int
+qla4xxx_fw_ready(scsi_qla_host_t * ha)
+{
+	uint32_t timeout_count;
+	int ready = 0;
+
+	DEBUG2(ql4_printk(KERN_INFO, ha, "Waiting for Firmware Ready..\n"));
+	for (timeout_count = ADAPTER_INIT_TOV; timeout_count > 0;
+	     timeout_count--) {
+		if (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))
+			qla4xxx_get_dhcp_ip_address(ha);
+
+		/* Get firmware state. */
+		if (qla4xxx_get_firmware_state(ha) != QLA_SUCCESS) {
+			DEBUG2(printk("scsi%ld: %s: unable to get firmware "
+			    "state\n", ha->host_no, __func__));
+			break;
+
+		}
+
+		if (ha->firmware_state & FW_STATE_ERROR) {
+			DEBUG2(printk("scsi%ld: %s: an unrecoverable error has "
+			    "occurred\n", ha->host_no, __func__));
+			break;
+
+		}
+		if (ha->firmware_state & FW_STATE_CONFIG_WAIT) {
+			/*
+			 * The firmware has not yet been issued an Initialize
+			 * Firmware command, so issue it now.
+			 */
+			if (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR)
+				break;
+
+			/* Go back and test for ready state - no wait. */
+			continue;
+		}
+
+		if (ha->firmware_state == FW_STATE_READY) {
+			DEBUG2(ql4_printk(KERN_INFO, ha, "Firmware Ready..\n"));
+			/* The firmware is ready to process SCSI commands. */
+			DEBUG2(ql4_printk(KERN_INFO, ha,
+			    "scsi%ld: %s: MEDIA TYPE - %s\n", ha->host_no,
+			    __func__, (ha->addl_fw_state &
+			    FW_ADDSTATE_OPTICAL_MEDIA) != 0 ? "OPTICAL" :
+				"COPPER"));
+			DEBUG2(ql4_printk(KERN_INFO, ha,
+			    "scsi%ld: %s: DHCP STATE Enabled " "%s\n",
+			    ha->host_no, __func__, (ha->addl_fw_state &
+			    FW_ADDSTATE_DHCP_ENABLED) != 0 ? "YES" : "NO"));
+			DEBUG2(ql4_printk(KERN_INFO, ha,
+			    "scsi%ld: %s: LINK %s\n", ha->host_no, __func__,
+			    (ha->addl_fw_state & FW_ADDSTATE_LINK_UP) != 0 ?
+			    "UP" : "DOWN"));
+			DEBUG2(ql4_printk(KERN_INFO, ha,
+			    "scsi%ld: %s: iSNS Service " "Started %s\n",
+			    ha->host_no, __func__, (ha->addl_fw_state &
+			    FW_ADDSTATE_ISNS_SVC_ENABLED) != 0 ? "YES" : "NO"));
+
+			ready = 1;
+			break;
+		}
+		DEBUG2(printk("scsi%ld: %s: waiting on fw, state=%x:%x - "
+		    "seconds expired= %d\n", ha->host_no, __func__,
+		    ha->firmware_state, ha->addl_fw_state, timeout_count));
+		msleep(1000);
+	}			/* end of for */
+
+	if (timeout_count <= 0)
+		DEBUG2(printk("scsi%ld: %s: FW Initialization timed out!\n",
+		    ha->host_no, __func__));
+
+	if (ha->firmware_state & FW_STATE_DHCP_IN_PROGRESS)  {
+		DEBUG2(printk("scsi%ld: %s: FW is reporting its waiting to"
+					" grab an IP address from DHCP server\n",
+					      ha->host_no, __func__));
+		ready = 1;
+	}
+
+	return ready;
+}
+
+/*
+ * qla4xxx_init_firmware
+ *	This routine initializes the firmware.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized firmware
+ *	QLA_ERROR   - Failed to initialize firmware
+ */
+static int
+qla4xxx_init_firmware(scsi_qla_host_t * ha)
+{
+	int status = QLA_ERROR;
+
+	ql4_printk(KERN_INFO, ha, "Initializing firmware..\n");
+	if (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR) {
+		DEBUG2(printk("scsi%ld: %s: Failed to initialize firmware "
+		    "control block\n", ha->host_no, __func__));
+		return status;
+	}
+	if (!qla4xxx_fw_ready(ha))
+		return status;
+
+	set_bit(AF_ONLINE, &ha->flags);
+	return qla4xxx_get_firmware_status(ha);
+}
+
+static struct ddb_entry *
+qla4xxx_get_ddb_entry(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	DEV_DB_ENTRY *fw_ddb_entry = NULL;
+	dma_addr_t fw_ddb_entry_dma;
+	struct ddb_entry *ddb_entry = NULL;
+	int found = 0;
+	uint32_t device_state;
+
+	/* Make sure the dma buffer is valid */
+	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
+	    &fw_ddb_entry_dma, GFP_KERNEL);
+	if (fw_ddb_entry == NULL) {
+		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
+		    ha->host_no, __func__));
+		return NULL;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
+	    fw_ddb_entry_dma, NULL, NULL, &device_state, NULL, NULL, NULL) ==
+	    QLA_ERROR) {
+		DEBUG2(printk("scsi%ld: %s: failed get_ddb_entry for "
+		    "fw_ddb_index %d\n", ha->host_no, __func__, fw_ddb_index));
+		return NULL;
+	}
+
+	/* Allocate DDB if not already allocated. */
+	DEBUG2(printk("scsi%ld: %s: Looking for ddb[%d]\n", ha->host_no,
+	    __func__, fw_ddb_index));
+	list_for_each_entry(ddb_entry, &ha->ddb_list, list) {
+		if (memcmp(ddb_entry->iscsi_name, fw_ddb_entry->iscsiName,
+		    ISCSI_NAME_SIZE) == 0) {
+			found++;
+			break;
+		}
+	}
+
+	if (!found) {
+		DEBUG2(printk("scsi%ld: %s: ddb[%d] not found - allocating "
+		    "new ddb\n", ha->host_no, __func__, fw_ddb_index));
+		ddb_entry = qla4xxx_alloc_ddb(ha, fw_ddb_index);
+	}
+
+	/* if not found allocate new ddb */
+	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,
+	    fw_ddb_entry_dma);
+
+	return ddb_entry;
+}
+
+/**************************************************************************
+ * qla4xxx_update_ddb_entry
+ *	This routine updates the driver's internal device database entry
+ *	with information retrieved from the firmware's device database
+ *	entry for the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Output:
+ *	ddb_entry - Structure filled in.
+ *
+ * Remarks:
+ *	The ddb_entry->fw_ddb_index field must be initialized prior to
+ *	calling this routine
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully update ddb_entry
+ *	QLA_ERROR   - Failed to update ddb_entry
+ **************************************************************************/
+int
+qla4xxx_update_ddb_entry(scsi_qla_host_t * ha, struct ddb_entry *ddb_entry,
+    uint32_t fw_ddb_index)
+{
+	DEV_DB_ENTRY *fw_ddb_entry = NULL;
+	dma_addr_t fw_ddb_entry_dma;
+	int status = QLA_ERROR;
+
+	if (ddb_entry == NULL) {
+		DEBUG2(printk("scsi%ld: %s: ddb_entry is NULL\n", ha->host_no,
+		    __func__));
+		goto exit_update_ddb;
+	}
+
+	/* Make sure the dma buffer is valid */
+	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
+	    &fw_ddb_entry_dma, GFP_KERNEL);
+	if (fw_ddb_entry == NULL) {
+		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
+		    ha->host_no, __func__));
+
+		goto exit_update_ddb;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
+	    fw_ddb_entry_dma, NULL, NULL, &ddb_entry->fw_ddb_device_state, NULL,
+	    &ddb_entry->tcp_source_port_num, &ddb_entry->connection_id) ==
+	    QLA_ERROR) {
+		DEBUG2(printk("scsi%ld: %s: failed get_ddb_entry for "
+		    "fw_ddb_index %d\n", ha->host_no, __func__, fw_ddb_index));
+
+		goto exit_update_ddb;
+	}
+
+	status = QLA_SUCCESS;
+	ddb_entry->target_session_id = le16_to_cpu(fw_ddb_entry->TSID);
+	ddb_entry->task_mgmt_timeout =
+	    le16_to_cpu(fw_ddb_entry->taskMngmntTimeout);
+	ddb_entry->CmdSn = 0;
+	ddb_entry->exe_throttle = le16_to_cpu(fw_ddb_entry->exeThrottle);
+	ddb_entry->default_relogin_timeout =
+	    le16_to_cpu(fw_ddb_entry->taskMngmntTimeout);
+	ddb_entry->default_time2wait = le16_to_cpu(fw_ddb_entry->minTime2Wait);
+
+	/* Update index in case it changed */
+	ddb_entry->fw_ddb_index = fw_ddb_index;
+	ha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;
+
+	memcpy(&ddb_entry->iscsi_name[0], &fw_ddb_entry->iscsiName[0],
+	    min(sizeof(ddb_entry->iscsi_name),
+		    sizeof(fw_ddb_entry->iscsiName)));
+	memcpy(&ddb_entry->ip_addr[0], &fw_ddb_entry->ipAddr[0],
+	    min(sizeof(ddb_entry->ip_addr), sizeof(fw_ddb_entry->ipAddr)));
+
+	DEBUG2(printk("scsi%ld: %s: ddb[%d] - State= %x status= %d.\n",
+	    ha->host_no, __func__, fw_ddb_index,
+	    ddb_entry->fw_ddb_device_state, status);)
+
+exit_update_ddb:
+	if (fw_ddb_entry)
+		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
+		    fw_ddb_entry, fw_ddb_entry_dma);
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_alloc_ddb
+ *	This routine allocates a ddb_entry, ititializes some values, and
+ *	inserts it into the ddb list.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *	Pointer to internal device database structure
+ **************************************************************************/
+struct ddb_entry *
+qla4xxx_alloc_ddb(scsi_qla_host_t * ha, uint32_t fw_ddb_index)
+{
+	struct ddb_entry *ddb_entry;
+
+	DEBUG2(printk("scsi%ld: %s: fw_ddb_index [%d]\n", ha->host_no,
+	    __func__, fw_ddb_index));
+
+	ddb_entry = (struct ddb_entry *)kmalloc(sizeof(*ddb_entry), GFP_KERNEL);
+	if (ddb_entry == NULL) {
+		DEBUG2(printk("scsi%ld: %s: Unable to allocate memory "
+		    "to add fw_ddb_index [%d]\n", ha->host_no, __func__,
+		    fw_ddb_index));
+		return ddb_entry;
+	}
+
+	memset(ddb_entry, 0, sizeof(*ddb_entry));
+	ddb_entry->fw_ddb_index = fw_ddb_index;
+	atomic_set(&ddb_entry->port_down_timer, ha->port_down_retry_count);
+	atomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);
+	atomic_set(&ddb_entry->relogin_timer, 0);
+	atomic_set(&ddb_entry->relogin_retry_count, 0);
+	atomic_set(&ddb_entry->state, DDB_STATE_ONLINE);
+	list_add_tail(&ddb_entry->list, &ha->ddb_list);
+	ha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;
+	ha->tot_ddbs++;
+
+	return ddb_entry;
+}
+
+/**************************************************************************
+ * qla4xxx_configure_ddbs
+ *	This routine searches for all valid firmware ddb entries and builds
+ *	an internal ddb list.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *	Ddbs that are considered valid are those with a device state of
+ *	SESSION_ACTIVE.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully built internal ddb list, if targets available
+ *	QLA_ERROR   - Error on a mailbox command
+ **************************************************************************/
+static int
+qla4xxx_build_ddb_list(scsi_qla_host_t *ha)
+{
+	int status = QLA_SUCCESS;
+	uint32_t fw_ddb_index = 0;
+	uint32_t next_fw_ddb_index = 0;
+	uint32_t ddb_state;
+	uint32_t conn_err, err_code;
+	struct ddb_entry *ddb_entry;
+
+	ql4_printk(KERN_INFO, ha, "Initializing DDBs ...\n");
+	for (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES;
+	     fw_ddb_index = next_fw_ddb_index) {
+		/* First, let's see if a device exists here */
+		if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL,
+		    &next_fw_ddb_index, &ddb_state, &conn_err, NULL, NULL) ==
+		    QLA_ERROR) {
+			DEBUG2(printk("scsi%ld: %s: get_ddb_entry, "
+			    "fw_ddb_index %d failed", ha->host_no, __func__,
+			    fw_ddb_index));
+			return QLA_ERROR;
+		}
+
+		DEBUG2(printk("scsi%ld: %s: Getting DDB[%d] ddbstate=0x%x, "
+		    "next_fw_ddb_index=%d.\n", ha->host_no, __func__,
+		    fw_ddb_index, ddb_state, next_fw_ddb_index));
+
+		/* Add DDB to internal our ddb list. */
+		ddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index);
+		if (ddb_entry == NULL) {
+			DEBUG2(printk("scsi%ld: %s: Unable to allocate memory "
+			    "for device at fw_ddb_index %d\n", ha->host_no,
+			    __func__, fw_ddb_index));
+			return QLA_ERROR;
+		}
+		/* Fill in the device structure */
+		if (qla4xxx_update_ddb_entry(ha, ddb_entry, fw_ddb_index) ==
+		    QLA_ERROR) {
+			ha->fw_ddb_index_map[fw_ddb_index] =
+			    (struct ddb_entry *)INVALID_ENTRY;
+
+			//      qla4xxx_free_ddb(ha, ddb_entry);
+			DEBUG2(printk("scsi%ld: %s: update_ddb_entry failed "
+			    "for fw_ddb_index %d.\n", ha->host_no, __func__,
+			    fw_ddb_index));
+			return QLA_ERROR;
+		}
+
+		/* if fw_ddb with session active state found,
+		 * add to ddb_list */
+		DEBUG2(printk("scsi%ld: %s: DDB[%d] added to list\n",
+		    ha->host_no, __func__, fw_ddb_index));
+
+		/* Issue relogin, if necessary. */
+		if (ddb_state == DDB_DS_SESSION_FAILED ||
+		    ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) {
+
+			atomic_set(&ddb_entry->state, DDB_STATE_DEAD);
+
+			/* Try and login to device */
+			DEBUG2(printk("scsi%ld: %s: Login to DDB[%d]\n",
+			    ha->host_no, __func__, fw_ddb_index));
+			err_code = ((conn_err & 0x00ff0000) >> 16);
+			if (err_code == 0x1c || err_code == 0x06) {
+				DEBUG2(printk("scsi%ld: %s send target completed "
+				    "or access denied failure\n",
+				    ha->host_no, __func__));
+			} else {
+				qla4xxx_set_ddb_entry(ha, fw_ddb_index, NULL,
+				    0);
+			}
+		}
+
+		/* We know we've reached the last device when
+		 * next_fw_ddb_index is 0 */
+		if (next_fw_ddb_index == 0)
+			break;
+	}
+
+	ql4_printk(KERN_INFO, ha, "DDB list done..\n");
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_devices_ready
+ *	This routine waits up to ql4xdiscoverywait seconds
+ *	F/W database during driver load time.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully (re)built internal ddb list
+ *	QLA_ERROR   - Failed to (re)build internal ddb list
+ **************************************************************************/
+static int
+qla4xxx_devices_ready(scsi_qla_host_t * ha)
+{
+	int halt_wait;
+	unsigned long discovery_wtime;
+	struct ddb_entry *ddb_entry;
+	uint32_t fw_ddb_index;
+	uint32_t next_fw_ddb_index;
+	uint32_t fw_ddb_device_state;
+	uint32_t conn_err;
+	uint32_t err_code;
+
+	discovery_wtime = jiffies + (ql4xdiscoverywait * HZ);
+
+	DEBUG(printk("Waiting (%d) for devices ...\n", ql4xdiscoverywait));
+	do {
+		/* poll for AEN. */
+		qla4xxx_get_firmware_state(ha);
+		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags)) {
+			/* Set time-between-relogin timer */
+			qla4xxx_process_aen(ha, RELOGIN_DDB_CHANGED_AENS);
+		}
+
+		/* if no relogins active or needed, halt discvery wait */
+		halt_wait = 1;
+
+		/* scan for relogins
+		 * ----------------- */
+		for (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES;
+		    fw_ddb_index = next_fw_ddb_index) {
+			if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0,
+			    NULL, &next_fw_ddb_index, &fw_ddb_device_state,
+			    &conn_err, NULL, NULL) == QLA_ERROR)
+				return QLA_ERROR;
+
+			if (fw_ddb_device_state == DDB_DS_LOGIN_IN_PROCESS)
+				halt_wait = 0;
+
+			if (fw_ddb_device_state == DDB_DS_SESSION_FAILED ||
+			    fw_ddb_device_state ==
+			    DDB_DS_NO_CONNECTION_ACTIVE) {
+
+				/*
+				 * Don't want to do a relogin if connection
+				 * error is 0x1c.
+				 */
+				err_code = ((conn_err & 0x00ff0000) >> 16);
+				if (err_code == 0x1c || err_code == 0x06) {
+					DEBUG2(printk(
+					    "scsi%ld: %s send target completed or "
+					    "access denied failure\n",
+					    ha->host_no, __func__);)
+				} else {
+					/* We either have a device that is in
+					 * the process of relogging in or a
+					 * device that is waiting to be
+					 * relogged in */
+					halt_wait = 0;
+
+					ddb_entry =
+					    qla4xxx_lookup_ddb_by_fw_index(ha,
+						fw_ddb_index);
+					if (ddb_entry == NULL)
+						return QLA_ERROR;
+
+					if (ddb_entry->dev_scan_wait_to_start_relogin != 0
+					    && time_after_eq(jiffies,
+						    ddb_entry->dev_scan_wait_to_start_relogin))
+					{
+						ddb_entry->
+						    dev_scan_wait_to_start_relogin
+						    = 0;
+						qla4xxx_set_ddb_entry(ha,
+						    fw_ddb_index, NULL, 0);
+					}
+				}
+			}
+
+			/* We know we've reached the last device when
+			 * next_fw_ddb_index is 0 */
+			if (next_fw_ddb_index == 0)
+				break;
+		}
+
+		if (halt_wait) {
+			DEBUG2(printk("scsi%ld: %s: Delay halted.  Devices "
+			    "Ready.\n", ha->host_no, __func__));
+			return QLA_SUCCESS;
+		}
+
+		msleep(2000);
+	} while (!time_after_eq(jiffies, discovery_wtime));
+
+	DEBUG3(qla4xxx_get_conn_event_log(ha));
+
+	return (QLA_SUCCESS);
+}
+
+static void
+qla4xxx_flush_AENS(scsi_qla_host_t *ha)
+{
+	unsigned long wtime;
+
+	/* Flush the 0x8014 AEN from the firmware as a result of
+	 * Auto connect. We are basically doing get_firmware_ddb()
+	 * to determine whether we need to log back in or not.
+	 *  Trying to do a set ddb before we have processed 0x8014
+	 *  will result in another set_ddb() for the same ddb. In other
+	 *  words there will be stale entries in the aen_q.
+	 */
+	wtime = jiffies + (2 * HZ);
+	do {
+		if (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS)
+			if (ha->firmware_state & (BIT_2 | BIT_0))
+				return;
+
+		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
+			qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+
+		msleep(1000);
+	} while (!time_after_eq(jiffies, wtime));
+
+}
+
+static int
+qla4xxx_initialize_ddb_list(scsi_qla_host_t *ha)
+{
+	uint16_t fw_ddb_index;
+	int status = QLA_SUCCESS;
+
+	/* free the ddb list if is not empty */
+	if (!list_empty(&ha->ddb_list))
+		qla4xxx_free_ddb_list(ha);
+
+	for (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES; fw_ddb_index++)
+		ha->fw_ddb_index_map[fw_ddb_index] =
+		    (struct ddb_entry *)INVALID_ENTRY;
+
+	ha->tot_ddbs = 0;
+
+	qla4xxx_flush_AENS(ha);
+
+	/*
+	 * First perform device discovery for active
+	 * fw ddb indexes and build
+	 * ddb list.
+	 */
+	if ((status = qla4xxx_build_ddb_list(ha)) == QLA_ERROR)
+		return (status);
+
+	/* Wait for an AEN */
+	qla4xxx_devices_ready(ha);
+
+	/*
+	 * Targets can come online after the inital discovery, so processing
+	 * the aens here will catch them.
+	 */
+	if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
+		qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
+
+	return status;
+}
+
+/*
+ * qla4xxx_update_ddb_list
+ *	This routine obtains device information from the F/W database after
+ *	firmware or adapter resets.  The device table is preserved.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully updated internal ddb list
+ *	QLA_ERROR   - Failed to update internal ddb list
+ */
+int
+qla4xxx_reinitialize_ddb_list(scsi_qla_host_t * ha)
+{
+	int status = QLA_SUCCESS;
+	struct ddb_entry *ddb_entry, *detemp;
+
+	/* Update the device information for all devices. */
+	list_for_each_entry_safe(ddb_entry, detemp, &ha->ddb_list, list) {
+		qla4xxx_update_ddb_entry(ha, ddb_entry,
+		    ddb_entry->fw_ddb_index);
+		if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+			atomic_set(&ddb_entry->state, DDB_STATE_ONLINE);
+			DEBUG2(printk ("scsi%ld: %s: ddb index [%d] marked "
+			    "ONLINE\n", ha->host_no, __func__,
+			    ddb_entry->fw_ddb_index));
+		} else if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)
+			qla4xxx_mark_device_missing(ha, ddb_entry);
+	}
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_relogin_device
+ *	This routine does a session relogin with the specified device.
+ *	The ddb entry must be assigned prior to making this call.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *    QLA_SUCCESS = Successfully relogged in device
+ *    QLA_ERROR   = Failed to relogin device
+ **************************************************************************/
+int
+qla4xxx_relogin_device(scsi_qla_host_t * ha, struct ddb_entry * ddb_entry)
+{
+	uint16_t relogin_timer;
+
+	relogin_timer = max(ddb_entry->default_relogin_timeout,
+	    (uint16_t)RELOGIN_TOV);
+	atomic_set(&ddb_entry->relogin_timer, relogin_timer);
+
+	DEBUG2(printk("scsi%ld: Relogin index [%d]. TOV=%d\n", ha->host_no,
+	    ddb_entry->fw_ddb_index, relogin_timer));
+
+	qla4xxx_set_ddb_entry(ha, ddb_entry->fw_ddb_index, NULL, 0);
+
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4010_topcat_soft_reset
+ *	This routine determines if the QLA4040 TopCat chip is present.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None.
+ **************************************************************************/
+static void
+qla4010_get_topcat_presence(scsi_qla_host_t * ha)
+{
+	unsigned long flags;
+	uint16_t topcat;
+
+	QL4XXX_LOCK_NVRAM(ha);
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	topcat = RD_NVRAM_WORD(ha, offsetof(eeprom_data_t, isp4010.topcat));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if ((topcat & TOPCAT_MASK) == TOPCAT_PRESENT)
+		set_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags);
+	else
+		clear_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags);
+	QL4XXX_UNLOCK_NVRAM(ha);
+}
+
+
+static int
+qla4xxx_config_nvram(scsi_qla_host_t * ha)
+{
+	unsigned long flags;
+	EXTERNAL_HW_CONFIG_REG extHwConfig;
+
+	DEBUG2(printk("scsi%ld: %s: Get EEProm parameters \n", ha->host_no,
+	    __func__));
+	QL4XXX_LOCK_FLASH(ha);
+	QL4XXX_LOCK_NVRAM(ha);
+	/* Get EEPRom Parameters from NVRAM and validate */
+	ql4_printk(KERN_INFO, ha, "Configuring NVRAM ...\n");
+	if (qla4xxx_is_nvram_configuration_valid(ha) == QLA_SUCCESS) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		extHwConfig.Asuint32_t = RD_NVRAM_WORD(ha,
+		    EEPROM_EXT_HW_CONF_OFFSET());
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	} else {
+		/*
+		 * QLogic adapters should always have a valid NVRAM.
+		 * If not valid, do not load.
+		 */
+		ql4_printk(KERN_WARNING, ha,
+		    "scsi%ld: %s: EEProm checksum invalid.  Please update "
+		    "your EEPROM\n", ha->host_no, __func__);
+
+		/* set defaults */
+		if (IS_QLA4010(ha))
+			extHwConfig.Asuint32_t = 0x1912;
+		else if (IS_QLA4022(ha))
+			extHwConfig.Asuint32_t = 0x0023;
+	}
+	DEBUG(printk("scsi%ld: %s: Setting extHwConfig to 0xFFFF%04x\n",
+	    ha->host_no, __func__, extHwConfig.Asuint32_t));
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_DWORD(ISP_EXT_HW_CONF(ha),
+	    ((0xFFFF << 16) | extHwConfig.Asuint32_t));
+	PCI_POSTING(ISP_EXT_HW_CONF(ha));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	QL4XXX_UNLOCK_NVRAM(ha);
+	QL4XXX_UNLOCK_FLASH(ha);
+
+	return 1;
+}
+
+static void
+qla4x00_pci_config(scsi_qla_host_t * ha)
+{
+	uint16_t w, mwi;
+
+	ql4_printk(KERN_INFO, ha, "Configuring PCI space...\n");
+
+	pci_set_master(ha->pdev);
+	mwi = 0;
+	if (pci_set_mwi(ha->pdev))
+		mwi = PCI_COMMAND_INVALIDATE;
+	/*
+	 * We want to respect framework's setting of PCI configuration space
+	 * command register and also want to make sure that all bits of
+	 * interest to us are properly set in command register.
+	 */
+	pci_read_config_word(ha->pdev, PCI_COMMAND, &w);
+	w |= mwi | (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);
+	w &= ~PCI_COMMAND_INTX_DISABLE;
+	pci_write_config_word(ha->pdev, PCI_COMMAND, w);
+}
+
+static int
+qla4xxx_start_firmware_from_flash(scsi_qla_host_t * ha)
+{
+	int status = QLA_ERROR;
+	uint32_t max_wait_time;
+	unsigned long flags;
+	uint32_t mbox_status;
+
+	ql4_printk(KERN_INFO, ha, "Starting firmware ...\n");
+
+	/*
+	 * Start firmware from flash ROM
+	 *
+	 * WORKAROUND: Stuff a non-constant value that the firmware can
+	 * use as a seed for a random number generator in MB7 prior to
+	 * setting BOOT_ENABLE.  Fixes problem where the TCP
+	 * connections use the same TCP ports after each reboot,
+	 * causing some connections to not get re-established.
+	 */
+	DEBUG(printk("scsi%d: %s: Start firmware from flash ROM\n",
+	    ha->host_no, __func__));
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_DWORD(&ha->reg->mailbox[7], jiffies);
+	if (IS_QLA4022(ha))
+		WRT_REG_DWORD(&ha->reg->u1.isp4022.nvram,
+		    SET_RMASK(NVR_WRITE_ENABLE));
+
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_BOOT_ENABLE));
+	PCI_POSTING(&ha->reg->ctrl_status);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Wait for firmware to come UP. */
+	max_wait_time = FIRMWARE_UP_TOV * 4;
+	do {
+		uint32_t ctrl_status;
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+		mbox_status = RD_REG_DWORD(&ha->reg->mailbox[0]);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		if (ctrl_status & SET_RMASK(CSR_SCSI_PROCESSOR_INTR))
+			break;
+		if (mbox_status == MBOX_STS_COMMAND_COMPLETE)
+			break;
+
+		DEBUG2(printk("scsi%ld: %s: Waiting for boot firmware to "
+		    "complete... ctrl_sts=0x%x, remaining=%d\n", ha->host_no,
+		    __func__, ctrl_status, max_wait_time));
+
+		msleep(250);
+	} while ((max_wait_time--));
+
+	if (mbox_status == MBOX_STS_COMMAND_COMPLETE) {
+		DEBUG(printk("scsi%ld: %s: Firmware has started\n",
+		    ha->host_no, __func__));
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+		    SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		status = QLA_SUCCESS;
+	} else {
+		printk(KERN_INFO "scsi%ld: %s: Boot firmware failed "
+		    "-  mbox status 0x%x\n", ha->host_no, __func__,
+		    mbox_status);
+		status = QLA_ERROR;
+	}
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_start_firmware
+ *	This routine performs the neccessary steps to start the firmware for
+ *	the QLA4010 adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully started QLA4xxx firmware
+ *	QLA_ERROR   - Failed to start QLA4xxx firmware
+ **************************************************************************/
+static int
+qla4xxx_start_firmware(scsi_qla_host_t * ha)
+{
+	unsigned long flags = 0;
+	uint32_t mbox_status;
+	int status = QLA_ERROR;
+	int soft_reset = 1;
+	int config_chip = 0;
+
+	if (IS_QLA4010(ha))
+		qla4010_get_topcat_presence(ha);
+
+	if (IS_QLA4022(ha))
+		ql4xxx_set_mac_number(ha);
+
+	QL4XXX_LOCK_DRVR_WAIT(ha);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	DEBUG2(printk("scsi%ld: %s: port_ctrl   = 0x%08X\n", ha->host_no,
+	    __func__, RD_REG_DWORD(ISP_PORT_CTRL(ha))));
+	DEBUG(printk("scsi%ld: %s: port_status = 0x%08X\n", ha->host_no,
+	    __func__, RD_REG_DWORD(ISP_PORT_STATUS(ha))));
+
+	/* Is Hardware already initialized? */
+	if ((RD_REG_DWORD(ISP_PORT_CTRL(ha)) & 0x8000) != 0) {
+		DEBUG(printk("scsi%ld: %s: Hardware has already been "
+		    "initialized\n", ha->host_no, __func__));
+
+		/* Receive firmware boot acknowledgement */
+		mbox_status = RD_REG_DWORD(&ha->reg->mailbox[0]);
+
+		DEBUG2(printk("scsi%ld: %s: H/W Config complete - mbox[0]= "
+		    "0x%x\n", ha->host_no, __func__, mbox_status));
+
+		/* Is firmware already booted? */
+		if (mbox_status == 0) {
+			/* F/W not running, must be config by net driver */
+			config_chip = 1;
+			soft_reset = 0;
+		} else {
+			WRT_REG_DWORD(&ha->reg->ctrl_status,
+			    SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			if (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS) {
+				DEBUG2(printk("scsi%ld: %s: Get firmware "
+				    "state -- state = 0x%x\n", ha->host_no,
+				    __func__, ha->firmware_state));
+				/* F/W is running */
+				if (ha->firmware_state & FW_STATE_CONFIG_WAIT) {
+					DEBUG2(printk("scsi%ld: %s: Firmware "
+					    "in known state -- config and "
+					    "boot, state = 0x%x\n",
+					    ha->host_no, __func__,
+					    ha->firmware_state));
+					config_chip = 1;
+					soft_reset = 0;
+				}
+			} else {
+				DEBUG2(printk("scsi%ld: %s: Firmware in "
+				    "unknown state -- resetting, state = "
+				    "0x%x\n", ha->host_no, __func__,
+				    ha->firmware_state));
+			}
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+		}
+	} else {
+		DEBUG(printk("scsi%ld: %s: H/W initialization hasn't been "
+		    "started - resetting\n", ha->host_no, __func__));
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	DEBUG(printk("scsi%ld: %s: Flags soft_rest=%d, config= %d\n ",
+	    ha->host_no, __func__, soft_reset, config_chip));
+	if (soft_reset) {
+		DEBUG(printk("scsi%ld: %s: Issue Soft Reset\n", ha->host_no,
+		    __func__));
+		status = qla4xxx_soft_reset(ha);
+		if (status == QLA_ERROR) {
+			DEBUG(printk("scsi%d: %s: Soft Reset failed!\n",
+			    ha->host_no, __func__));
+			QL4XXX_UNLOCK_DRVR(ha);
+			return QLA_ERROR;
+		}
+		config_chip = 1;
+
+		/* Reset clears the semaphore, so aquire again */
+		QL4XXX_LOCK_DRVR_WAIT(ha);
+	}
+
+	if (config_chip) {
+		if (qla4xxx_config_nvram(ha))
+			status = qla4xxx_start_firmware_from_flash(ha);
+	}
+
+	QL4XXX_UNLOCK_DRVR(ha);
+	if (status == QLA_SUCCESS) {
+		qla4xxx_get_fw_version(ha);
+		if (test_and_clear_bit(AF_GET_CRASH_RECORD, &ha->flags))
+			qla4xxx_get_crash_record(ha);
+	} else {
+		DEBUG(printk("scsi%ld: %s: Firmware has NOT started\n",
+		    ha->host_no, __func__));
+	}
+	return status;
+}
+
+
+/**************************************************************************
+ * qla4xxx_initialize_adapter
+ *	This routine parforms all of the steps necessary to initialize the
+ *	adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	renew_ddb_list - Indicates what to do with the adapter's ddb list
+ *			after adapter recovery has completed.
+ *			0=preserve ddb list, 1=destroy and rebuild ddb list
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized adapter
+ *	QLA_ERROR   - Failed to initialize adapter
+ **************************************************************************/
+int
+qla4xxx_initialize_adapter(scsi_qla_host_t * ha, uint8_t renew_ddb_list)
+{
+	int status = QLA_ERROR;
+	int8_t ip_address[IP_ADDR_LEN] = {0} ;
+
+	ha->eeprom_cmd_data = 0;
+
+	qla4x00_pci_config(ha);
+
+	qla4xxx_disable_intrs(ha);
+
+	/* Initialize the Host adapter request/response queues and firmware */
+	if (qla4xxx_start_firmware(ha) == QLA_ERROR)
+		return status;
+
+	if (qla4xxx_validate_mac_address(ha) == QLA_ERROR)
+		return status;
+
+	if (qla4xxx_init_local_data(ha) == QLA_ERROR)
+		return status;
+
+	status = qla4xxx_init_firmware(ha);
+	if (status == QLA_ERROR)
+		return status;
+
+	/*
+	 * FW is waiting to get an IP address from DHCP server: Skip building
+	 * the ddb_list and wait for DHCP lease acquired aen to come in
+	 * followed by 0x8014 aen" to trigger the tgt discovery process.
+	 */
+	if (ha->firmware_state & FW_STATE_DHCP_IN_PROGRESS)
+		return status;
+
+	/* Skip device discovery if ip and subnet is zero */
+        if (memcmp(ha->ip_address, ip_address, IP_ADDR_LEN) == 0 ||
+            memcmp(ha->subnet_mask, ip_address, IP_ADDR_LEN) == 0)
+		return status;
+
+	if (renew_ddb_list == PRESERVE_DDB_LIST) {
+		/*
+		 * We want to preserve lun states (i.e. suspended, etc.)
+		 * for recovery initiated by the driver.  So just update
+		 * the device states for the existing ddb_list.
+		 */
+		qla4xxx_reinitialize_ddb_list(ha);
+	} else if (renew_ddb_list == REBUILD_DDB_LIST) {
+		/*
+		 * We want to build the ddb_list from scratch during
+		 * driver initialization and recovery initiated by the
+		 * INT_HBA_RESET IOCTL.
+		 */
+		status = qla4xxx_initialize_ddb_list(ha);
+		if (status == QLA_ERROR) {
+			DEBUG2(printk("%s(%ld) Error occurred during build ddb "
+			    "list\n", __func__, ha->host_no));
+			goto exit_init_hba;
+		}
+
+	}
+	if (!ha->tot_ddbs) {
+		DEBUG2(printk("scsi%ld: Failed to initialize devices or none "
+		    "present in Firmware device database\n", ha->host_no));
+	}
+
+exit_init_hba:
+	return status;
+
+}
+
+/**************************************************************************
+ * qla4xxx_add_device_dynamically
+ *	This routine processes adds a device as a result of an 8014h AEN.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+static void
+qla4xxx_add_device_dynamically(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	struct ddb_entry * ddb_entry;
+
+	/* First allocate a device structure */
+	ddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index);
+	if (ddb_entry == NULL) {
+		DEBUG2(printk(KERN_WARNING
+		    "scsi%ld: Unable to allocate memory to add fw_ddb_index "
+		    "%d\n", ha->host_no, fw_ddb_index));
+	} else if (qla4xxx_update_ddb_entry(ha, ddb_entry, fw_ddb_index) ==
+	    QLA_ERROR) {
+		ha->fw_ddb_index_map[fw_ddb_index] =
+		    (struct ddb_entry *)INVALID_ENTRY;
+		DEBUG2(printk(KERN_WARNING
+		    "scsi%ld: failed to add new device at index [%d]\n"
+		    "Unable to retrieve fw ddb entry\n", ha->host_no,
+		    fw_ddb_index));
+	} else {
+		/* New device. Let's add it to the database */
+		DEBUG2(printk("scsi%ld: %s: new device at index [%d]\n",
+		    ha->host_no, __func__, fw_ddb_index));
+/*FIXME*/
+		/*qla4xxx_config_os(ha);*/
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_process_ddb_changed
+ *	This routine processes a Decive Database Changed AEN Event.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      state - Device state
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully processed ddb_changed aen
+ *	QLA_ERROR   - Failed to process ddb_changed aen
+ **************************************************************************/
+int
+qla4xxx_process_ddb_changed(scsi_qla_host_t * ha, uint32_t fw_ddb_index,
+    uint32_t state)
+{
+	struct ddb_entry * ddb_entry;
+	uint32_t old_fw_ddb_device_state;
+
+	/* check for out of range index */
+	if (fw_ddb_index >= MAX_DDB_ENTRIES)
+		return QLA_ERROR;
+
+	/* Get the corresponging ddb entry */
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	/* Device does not currently exist in our database. */
+	if (ddb_entry == NULL) {
+		if (state == DDB_DS_SESSION_ACTIVE)
+			qla4xxx_add_device_dynamically(ha, fw_ddb_index);
+		return QLA_SUCCESS;
+	}
+
+	/* Device already exists in our database. */
+	old_fw_ddb_device_state = ddb_entry->fw_ddb_device_state;
+	DEBUG2(printk("scsi%ld: %s DDB - old state= 0x%x, new state=0x%x for "
+	    "index [%d]\n", ha->host_no, __func__,
+	    ddb_entry->fw_ddb_device_state, state, fw_ddb_index));
+	if (old_fw_ddb_device_state == state &&
+	    state == DDB_DS_SESSION_ACTIVE) {
+		/* Do nothing, state not changed. */
+		return QLA_SUCCESS;
+	}
+
+	ddb_entry->fw_ddb_device_state = state;
+	/* Device is back online. */
+	if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+		atomic_set(&ddb_entry->port_down_timer,
+		    ha->port_down_retry_count);
+		atomic_set(&ddb_entry->state, DDB_STATE_ONLINE);
+		atomic_set(&ddb_entry->relogin_retry_count, 0);
+		atomic_set(&ddb_entry->relogin_timer, 0);
+		clear_bit(DF_RELOGIN, &ddb_entry->flags);
+		clear_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+		/*
+		 * Change the lun state to READY in case the lun TIMEOUT before
+		 * the device came back.
+		 */
+	} else {
+		/* Device went away, try to relogin. */
+		/* Mark device missing */
+		if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)
+			qla4xxx_mark_device_missing(ha, ddb_entry);
+		/*
+		 * Relogin if device state changed to a not active state.
+		 * However, do not relogin if this aen is a result of an IOCTL
+		 * logout (DF_NO_RELOGIN) or if this is a discovered device.
+		 */
+		if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_FAILED &&
+		    !test_bit(DF_RELOGIN, &ddb_entry->flags) &&
+		    !test_bit(DF_NO_RELOGIN, &ddb_entry->flags) &&
+		    !test_bit(DF_ISNS_DISCOVERED, &ddb_entry->flags)) {
+			/*
+			 * This triggers a relogin.  After the relogin_timer
+			 * expires, the relogin gets scheduled.  We must wait a
+			 * minimum amount of time since receiving an 0x8014 AEN
+			 * with failed device_state or a logout response before
+			 * we can issue another relogin.
+			 */
+			/* Firmware padds this timeout: (time2wait +1).
+			 * Driver retry to login should be longer than F/W.
+			 * Otherwise F/W will fail
+			 * set_ddb() mbx cmd with 0x4005 since it still
+			 * counting down its time2wait.
+			 */
+			atomic_set(&ddb_entry->relogin_timer, 0);
+			atomic_set(&ddb_entry->retry_relogin_timer,
+			    ddb_entry->default_time2wait + 4);
+		}
+	}
+
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_login_device
+ *	This routine is called by the login IOCTL to log in the specified
+ *	device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to login
+ * 	connection_id - Connection ID of the device to login
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully logged in device
+ *	QLA_ERROR   - Failed to login device
+ **************************************************************************/
+int
+qla4xxx_login_device(scsi_qla_host_t * ha, uint16_t fw_ddb_index,
+    uint16_t connection_id)
+{
+	struct ddb_entry * ddb_entry;
+	int status = QLA_ERROR;
+
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry == NULL)
+		goto exit_login_device;
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+	    &ddb_entry->fw_ddb_device_state, NULL, NULL, NULL) == QLA_ERROR)
+		goto exit_login_device;
+
+	if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+		status = QLA_SUCCESS;
+		goto exit_login_device;
+	}
+
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+	    LOGOUT_OPTION_RELOGIN) != QLA_SUCCESS)
+		goto exit_login_device;
+
+	status = QLA_SUCCESS;
+
+exit_login_device:
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_logout_device
+ *	This support routine is called by the logout IOCTL to log out
+ *	the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to logout
+ * 	connection_id - Connection ID of the device to logout
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully logged out device
+ *	QLA_ERROR   - Failed to logout device
+ **************************************************************************/
+int
+qla4xxx_logout_device(scsi_qla_host_t * ha, uint16_t fw_ddb_index,
+    uint16_t connection_id)
+{
+	int status = QLA_ERROR;
+	struct ddb_entry * ddb_entry;
+	uint32_t old_fw_ddb_device_state;
+
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry == NULL)
+		goto exit_logout_device;
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+	    &old_fw_ddb_device_state, NULL, NULL, NULL) != QLA_SUCCESS)
+		goto exit_logout_device;
+
+	set_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+	    LOGOUT_OPTION_CLOSE_SESSION) != QLA_SUCCESS)
+		goto exit_logout_device;
+
+	status = QLA_SUCCESS;
+
+exit_logout_device:
+	return status;
+}
+
+/*
+ * qla4xxx_delete_device
+ *	This routine is called by the logout IOCTL to delete the specified
+ *      device.	 Send the LOGOUT and DELETE_DDB commands for the specified
+ *      target, even if it's not in our internal database.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to delete
+ * 	connection_id - Connection ID of the device to delete
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully deleted device
+ *	QLA_ERROR   - Failed to delete device
+ */
+int
+qla4xxx_delete_device(scsi_qla_host_t * ha, uint16_t fw_ddb_index,
+    uint16_t connection_id)
+{
+	int status = QLA_ERROR;
+	uint32_t fw_ddb_device_state = 0xFFFF;
+	u_long wait_count;
+	struct ddb_entry * ddb_entry;
+
+	/* If the device is in our internal tables, set the NO_RELOGIN bit. */
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry != NULL)
+		set_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+
+	/*
+	 * If the device state is already one that we can delete, bypass the
+	 * logout command.
+	 */
+	qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+	    &fw_ddb_device_state, NULL, NULL, NULL);
+	if (fw_ddb_device_state == DDB_DS_UNASSIGNED ||
+	    fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE ||
+	    fw_ddb_device_state == DDB_DS_SESSION_FAILED)
+		goto delete_ddb;
+
+	/* First logout index */
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+	    LOGOUT_OPTION_CLOSE_SESSION) != QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: LOGOUT_OPTION_CLOSE_SESSION "
+			"failed index [%d]\n", ha->host_no, __func__,
+			fw_ddb_index));
+		goto exit_delete_ddb;
+	}
+
+	/* Wait enough time to complete logout */
+	wait_count = jiffies + LOGOUT_TOV * HZ;
+	while (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+	    &fw_ddb_device_state, NULL, NULL, NULL) == QLA_SUCCESS) {
+		if (time_after_eq(jiffies, wait_count))
+			goto exit_delete_ddb;
+		if (fw_ddb_device_state == DDB_DS_UNASSIGNED ||
+		    fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE ||
+		    fw_ddb_device_state == DDB_DS_SESSION_FAILED)
+			break;
+		udelay(50);
+	}
+
+delete_ddb:
+	/* Now delete index */
+	if (qla4xxx_clear_database_entry(ha, fw_ddb_index) == QLA_SUCCESS) {
+		status = QLA_SUCCESS;
+
+		if (!ddb_entry)
+			goto exit_delete_ddb;
+
+		atomic_set(&ddb_entry->state, DDB_STATE_DEAD);
+		DEBUG(printk("scsi%ld: %s: removing index %d.\n", ha->host_no,
+		    __func__, fw_ddb_index));
+		ha->fw_ddb_index_map[fw_ddb_index] =
+		    (struct ddb_entry *)INVALID_ENTRY;
+	}
+
+exit_delete_ddb:
+	return status;
+
+}
diff --git a/drivers/scsi/qla4xxx/ql4_inline.h b/drivers/scsi/qla4xxx/ql4_inline.h
new file mode 100644
index 0000000..bd4dd42
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_inline.h
@@ -0,0 +1,86 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+/*
+ *
+ * qla4xxx_lookup_ddb_by_fw_index
+ *      This routine locates a device handle given the firmware device
+ *      database index.  If device doesn't exist, returns NULL.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *      Pointer to the corresponding internal device database structure
+ */
+static inline ddb_entry_t *
+qla4xxx_lookup_ddb_by_fw_index(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+        ddb_entry_t *ddb_entry = NULL;
+
+        if ((fw_ddb_index < MAX_DDB_ENTRIES) &&
+            (ha->fw_ddb_index_map[fw_ddb_index] !=
+                (ddb_entry_t *) INVALID_ENTRY)) {
+                ddb_entry = ha->fw_ddb_index_map[fw_ddb_index];
+        }
+
+        DEBUG3(printk("scsi%d: %s: index [%d], ddb_entry = %p\n",
+            ha->host_no, __func__, fw_ddb_index, ddb_entry));
+
+        return ddb_entry;
+}
+
+static inline void
+__qla4xxx_enable_intrs(scsi_qla_host_t *ha)
+{
+	if (IS_QLA4022(ha)) {
+		WRT_REG_DWORD(&ha->reg->u1.isp4022.intr_mask,
+		    SET_RMASK(IMR_SCSI_INTR_ENABLE));
+		PCI_POSTING(&ha->reg->u1.isp4022.intr_mask);
+	} else {
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+		    SET_RMASK(CSR_SCSI_INTR_ENABLE));
+		PCI_POSTING(&ha->reg->ctrl_status);
+	}
+	set_bit(AF_INTERRUPTS_ON, &ha->flags);
+}
+
+static inline void
+__qla4xxx_disable_intrs(scsi_qla_host_t *ha)
+{
+	if (IS_QLA4022(ha)) {
+		WRT_REG_DWORD(&ha->reg->u1.isp4022.intr_mask,
+		    CLR_RMASK(IMR_SCSI_INTR_ENABLE));
+		PCI_POSTING(&ha->reg->u1.isp4022.intr_mask);
+	} else {
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+		    CLR_RMASK(CSR_SCSI_INTR_ENABLE));
+		PCI_POSTING(&ha->reg->ctrl_status);
+	}
+	clear_bit(AF_INTERRUPTS_ON, &ha->flags);
+}
+
+static inline void
+qla4xxx_enable_intrs(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__qla4xxx_enable_intrs(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+static inline void
+qla4xxx_disable_intrs(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__qla4xxx_disable_intrs(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
diff --git a/drivers/scsi/qla4xxx/ql4_iocb.c b/drivers/scsi/qla4xxx/ql4_iocb.c
new file mode 100644
index 0000000..2621011
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_iocb.c
@@ -0,0 +1,537 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#include "ql4_def.h"
+
+#include <scsi/scsi_tcq.h>
+
+/**************************************************************************
+ * qla4xxx_get_req_pkt
+ *	This routine performs the following tasks:
+ *	- returns the current request_in pointer (if queue not full)
+ *	- advances the request_in pointer
+ *	- checks for queue full
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	queue_entry - Pointer to pointer to queue entry structure
+ *
+ * Output:
+ *	queue_entry - Return pointer to next available request packet
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved request packet
+ *	QLA_ERROR   - Failed to retrieve request packet
+ **************************************************************************/
+int
+qla4xxx_get_req_pkt(scsi_qla_host_t *ha, QUEUE_ENTRY **queue_entry)
+{
+	uint16_t request_in;
+	uint8_t status = QLA_SUCCESS;
+
+	*queue_entry = ha->request_ptr;
+
+	/* get the latest request_in and request_out index */
+	request_in = ha->request_in;
+	ha->request_out = (uint16_t) le32_to_cpu(ha->shadow_regs->req_q_out);
+
+	/* Advance request queue pointer and check for queue full */
+	if (request_in == (REQUEST_QUEUE_DEPTH - 1)) {
+		request_in = 0;
+		ha->request_ptr = ha->request_ring;
+	} else {
+		request_in++;
+		ha->request_ptr++;
+	}
+
+	/* request queue is full, try again later */
+	if ((ha->iocb_cnt + 1) >= ha->iocb_hiwat) {
+		/* restore request pointer */
+		ha->request_ptr = *queue_entry;
+		status = QLA_ERROR;
+	} else {
+		ha->request_in = request_in;
+		memset(*queue_entry, 0, sizeof(**queue_entry));
+	}
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_send_marker_iocb
+ *	This routine issues a marker IOCB.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *	lun - SCSI LUN
+ *	marker_type - marker identifier
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully sent marker IOCB
+ *	QLA_ERROR   - Failed to send marker IOCB
+ **************************************************************************/
+int
+qla4xxx_send_marker_iocb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, int lun)
+{
+	MARKER_ENTRY *marker_entry;
+	unsigned long flags = 0;
+	uint8_t status = QLA_SUCCESS;
+
+	/* Acquire hardware specific lock */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Get pointer to the queue entry for the marker */
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &marker_entry) !=
+	    QLA_SUCCESS) {
+		status = QLA_ERROR;
+		goto exit_send_marker;
+	}
+
+	/* Put the marker in the request queue */
+	marker_entry->hdr.entryType = ET_MARKER;
+	marker_entry->hdr.entryCount = 1;
+	marker_entry->target = cpu_to_le16(ddb_entry->fw_ddb_index);
+	marker_entry->modifier = cpu_to_le16(MM_LUN_RESET);
+	int_to_scsilun(lun, &marker_entry->lun);
+	wmb();
+
+	/* Tell ISP it's got a new I/O request */
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+
+exit_send_marker:
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	return status;
+}
+
+PDU_ENTRY *
+qla4xxx_get_pdu(scsi_qla_host_t * ha, uint32_t length)
+{
+	PDU_ENTRY *pdu;
+	PDU_ENTRY *free_pdu_top;
+	PDU_ENTRY *free_pdu_bottom;
+	uint16_t pdu_active;
+
+	if (ha->free_pdu_top == NULL)
+		return NULL;
+
+	/* Save current state */
+	free_pdu_top = ha->free_pdu_top;
+	free_pdu_bottom = ha->free_pdu_bottom;
+	pdu_active = ha->pdu_active + 1;
+
+	/* get next available pdu */
+	pdu = free_pdu_top;
+	free_pdu_top = pdu->Next;
+	if (free_pdu_top == NULL)
+		free_pdu_bottom = NULL;
+
+	/* round up to nearest page */
+	length = (length + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
+
+	/* Allocate pdu buffer PDU */
+	pdu->Buff = dma_alloc_coherent(&ha->pdev->dev, length, &pdu->DmaBuff,
+	    GFP_KERNEL);
+	if (pdu->Buff == NULL)
+		return NULL;
+
+	memset(pdu->Buff, 0, length);
+
+	/* Fill in remainder of PDU */
+	pdu->BuffLen = length;
+	pdu->SendBuffLen = 0;
+	pdu->RecvBuffLen = 0;
+	pdu->Next = NULL;
+	ha->free_pdu_top = free_pdu_top;
+	ha->free_pdu_bottom = free_pdu_bottom;
+	ha->pdu_active = pdu_active;
+	return pdu;
+}
+
+void
+qla4xxx_free_pdu(scsi_qla_host_t * ha, PDU_ENTRY * pdu)
+{
+	if (ha->free_pdu_bottom == NULL) {
+		ha->free_pdu_top = pdu;
+		ha->free_pdu_bottom = pdu;
+	} else {
+		ha->free_pdu_bottom->Next = pdu;
+		ha->free_pdu_bottom = pdu;
+	}
+	dma_free_coherent(&ha->pdev->dev, pdu->BuffLen, pdu->Buff,
+	    pdu->DmaBuff);
+	ha->pdu_active--;
+
+	/* Clear PDU */
+	pdu->Buff = NULL;
+	pdu->BuffLen = 0;
+	pdu->SendBuffLen = 0;
+	pdu->RecvBuffLen = 0;
+	pdu->Next = NULL;
+	pdu->DmaBuff = 0;
+}
+
+/**************************************************************************
+ * qla4xxx_send_passthru0_iocb
+ *	This routine issues a passthru0 IOCB.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks: hardware_lock acquired upon entry, interrupt context
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully sent marker IOCB
+ *	QLA_ERROR   - Failed to send marker IOCB
+ **************************************************************************/
+int
+qla4xxx_send_passthru0_iocb(scsi_qla_host_t * ha, uint16_t fw_ddb_index,
+    uint16_t connection_id, dma_addr_t pdu_dma_data, uint32_t send_len,
+    uint32_t recv_len, uint16_t control_flags, uint32_t handle)
+{
+	PASSTHRU0_ENTRY *passthru_entry;
+	uint8_t status = QLA_SUCCESS;
+
+	/* Get pointer to the queue entry for the marker */
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &passthru_entry) !=
+	    QLA_SUCCESS) {
+		status = QLA_ERROR;
+		goto exit_send_pt0;
+	}
+
+	/* Fill in the request queue */
+	passthru_entry->hdr.entryType = ET_PASSTHRU0;
+	passthru_entry->hdr.entryCount = 1;
+	passthru_entry->handle = cpu_to_le32(handle);
+	passthru_entry->target = cpu_to_le16(fw_ddb_index);
+	passthru_entry->connectionID = cpu_to_le16(connection_id);
+	passthru_entry->timeout = __constant_cpu_to_le16(PT_DEFAULT_TIMEOUT);
+	if (send_len) {
+		control_flags |= PT_FLAG_SEND_BUFFER;
+		passthru_entry->outDataSeg64.base.addrHigh =
+		    cpu_to_le32(MSDW(pdu_dma_data));
+		passthru_entry->outDataSeg64.base.addrLow =
+		    cpu_to_le32(LSDW(pdu_dma_data));
+		passthru_entry->outDataSeg64.count = cpu_to_le32(send_len);
+	}
+	if (recv_len) {
+		passthru_entry->inDataSeg64.base.addrHigh =
+		    cpu_to_le32(MSDW(pdu_dma_data));
+		passthru_entry->inDataSeg64.base.addrLow =
+		    cpu_to_le32(LSDW(pdu_dma_data));
+		passthru_entry->inDataSeg64.count = cpu_to_le32(recv_len);
+	}
+	passthru_entry->controlFlags = cpu_to_le16(control_flags);
+	wmb();
+
+	/* Tell ISP it's got a new I/O request */
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+
+exit_send_pt0:
+	return status;
+}
+
+CONTINUE_ENTRY *
+qla4xxx_alloc_cont_entry(scsi_qla_host_t * ha)
+{
+	CONTINUE_ENTRY *cont_entry;
+
+	cont_entry = (CONTINUE_ENTRY *)ha->request_ptr;
+
+	/* Advance request queue pointer */
+	if (ha->request_in == (REQUEST_QUEUE_DEPTH - 1)) {
+		ha->request_in = 0;
+		ha->request_ptr = ha->request_ring;
+	} else {
+		ha->request_in++;
+		ha->request_ptr++;
+	}
+
+	/* Load packet defaults */
+	cont_entry->hdr.entryType = ET_CONTINUE;
+	cont_entry->hdr.entryCount = 1;
+	cont_entry->hdr.systemDefined = (uint8_t) cpu_to_le16(ha->request_in);
+
+	return cont_entry;
+}
+
+uint16_t
+qla4xxx_calc_request_entries(uint16_t dsds)
+{
+	uint16_t iocbs;
+
+	iocbs = 1;
+	if (dsds > COMMAND_SEG) {
+		iocbs += (dsds - COMMAND_SEG) / CONTINUE_SEG;
+		if ((dsds - COMMAND_SEG) % CONTINUE_SEG)
+			iocbs++;
+	}
+	return iocbs;
+}
+
+void
+qla4xxx_build_scsi_iocbs(srb_t *srb, COMMAND_ENTRY *cmd_entry,
+    uint16_t tot_dsds)
+{
+	scsi_qla_host_t *ha;
+	uint16_t avail_dsds;
+	DATA_SEG_A64 *cur_dsd;
+	struct scsi_cmnd *cmd;
+
+	cmd = srb->cmd;
+	ha = srb->ha;
+
+	if (cmd->request_bufflen == 0 || cmd->sc_data_direction == DMA_NONE) {
+		/* No data being transferred */
+		cmd_entry->ttlByteCnt = __constant_cpu_to_le32(0);
+		return;
+	}
+
+	avail_dsds = COMMAND_SEG;
+	cur_dsd = (DATA_SEG_A64 *) & (cmd_entry->dataseg[0]);
+
+	/* Load data segments */
+	if (cmd->use_sg) {
+		struct scatterlist *cur_seg;
+		struct scatterlist *end_seg;
+
+		cur_seg = (struct scatterlist *)cmd->request_buffer;
+		end_seg = cur_seg + tot_dsds;
+		while (cur_seg < end_seg) {
+			dma_addr_t sle_dma;
+
+			/* Allocate additional continuation packets? */
+			if (avail_dsds == 0) {
+				CONTINUE_ENTRY *cont_entry;
+
+				cont_entry = qla4xxx_alloc_cont_entry(ha);
+				cur_dsd =
+				    (DATA_SEG_A64 *) &cont_entry->dataseg[0];
+				avail_dsds = CONTINUE_SEG;
+			}
+
+			sle_dma = sg_dma_address(cur_seg);
+			cur_dsd->base.addrLow = cpu_to_le32(LSDW(sle_dma));
+			cur_dsd->base.addrHigh = cpu_to_le32(MSDW(sle_dma));
+			cur_dsd->count = cpu_to_le32(sg_dma_len(cur_seg));
+			avail_dsds--;
+
+			cur_dsd++;
+			cur_seg++;
+		}
+	} else {
+		cur_dsd->base.addrLow = cpu_to_le32(LSDW(srb->dma_handle));
+		cur_dsd->base.addrHigh = cpu_to_le32(MSDW(srb->dma_handle));
+		cur_dsd->count = cpu_to_le32(cmd->request_bufflen);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_send_command_to_isp
+ *      This routine is called by qla4xxx_queuecommand to build an ISP
+ *      command and pass it to the ISP for execution.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      srb - pointer to SCSI Request Block to be sent to ISP
+ *
+ * Output:
+ *      None
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully sent command to ISP
+ *      QLA_ERROR   - Failed to send command to ISP
+ **************************************************************************/
+int
+qla4xxx_send_command_to_isp(scsi_qla_host_t *ha, srb_t * srb)
+{
+	struct scsi_cmnd *cmd = srb->cmd;
+	ddb_entry_t *ddb_entry;
+	COMMAND_ENTRY *cmd_entry;
+	struct scatterlist *sg = NULL;
+
+	uint16_t tot_dsds;
+	uint16_t req_cnt;
+
+	unsigned long flags;
+	uint16_t cnt;
+	uint16_t i;
+	uint32_t index;
+	char tag[2];
+
+	/* Get real lun and adapter */
+	ddb_entry = srb->ddb;
+
+	/* Send marker(s) if needed. */
+	if (ha->marker_needed == 1) {
+		if (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun) !=
+		    QLA_SUCCESS) {
+			return QLA_ERROR;
+		}
+		ha->marker_needed = 0;
+	}
+	tot_dsds = 0;
+
+	/* Acquire hardware specific lock */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Check for room in active srb array */
+	index = ha->current_active_index;
+	for (i = 0; i < MAX_SRBS; i++) {
+		index++;
+		if (index == MAX_SRBS)
+			index = 1;
+		if (ha->active_srb_array[index] == 0) {
+			ha->current_active_index = index;
+			break;
+		}
+	}
+	if (i >= MAX_SRBS) {
+		printk(KERN_INFO "scsi%ld: %s: NO more SRB entries used "
+		    "iocbs=%d, \n reqs remaining=%d\n", ha->host_no, __func__,
+		    ha->iocb_cnt, ha->req_q_count);
+		goto queuing_error;
+	}
+
+	/* Calculate the number of request entries needed. */
+	if (cmd->use_sg) {
+		sg = (struct scatterlist *)cmd->request_buffer;
+		tot_dsds = pci_map_sg(ha->pdev, sg, cmd->use_sg,
+				      cmd->sc_data_direction);
+		if (tot_dsds == 0)
+			goto queuing_error;
+	} else if (cmd->request_bufflen) {
+		dma_addr_t      req_dma;
+
+		req_dma = pci_map_single(ha->pdev, cmd->request_buffer,
+		    cmd->request_bufflen, cmd->sc_data_direction);
+		if (dma_mapping_error(req_dma))
+			goto queuing_error;
+
+		srb->dma_handle = req_dma;
+		tot_dsds = 1;
+	}
+	req_cnt = qla4xxx_calc_request_entries(tot_dsds);
+
+	if (ha->req_q_count < (req_cnt + 2)) {
+		cnt = (uint16_t) le32_to_cpu(ha->shadow_regs->req_q_out);
+		if (ha->request_in < cnt)
+			ha->req_q_count = cnt - ha->request_in;
+		else
+			ha->req_q_count = REQUEST_QUEUE_DEPTH -
+			    (ha->request_in - cnt);
+	}
+
+	if (ha->req_q_count < (req_cnt + 2))
+		goto queuing_error;
+
+	/* total iocbs active */
+	if ((ha->iocb_cnt + req_cnt) >= REQUEST_QUEUE_DEPTH)
+		goto queuing_error;
+
+	/* Build command packet */
+	cmd_entry = (COMMAND_ENTRY *) ha->request_ptr;
+	memset(cmd_entry, 0, sizeof(COMMAND_ENTRY));
+	cmd_entry->hdr.entryType = ET_COMMAND;
+	cmd_entry->handle = cpu_to_le32(index);
+	cmd_entry->target = cpu_to_le16(ddb_entry->fw_ddb_index);
+	cmd_entry->connection_id = cpu_to_le16(ddb_entry->connection_id);
+
+	int_to_scsilun(cmd->device->lun, &cmd_entry->lun);
+	cmd_entry->cmdSeqNum = cpu_to_le32(ddb_entry->CmdSn);
+	cmd_entry->ttlByteCnt = cpu_to_le32(cmd->request_bufflen);
+	memcpy(cmd_entry->cdb, cmd->cmnd, cmd->cmd_len);
+	cmd_entry->dataSegCnt = cpu_to_le16(tot_dsds);
+	cmd_entry->hdr.entryCount = req_cnt;
+
+	/* Set data transfer direction control flags
+	 * NOTE: Look at data_direction bits iff there is data to be
+	 *       transferred, as the data direction bit is sometimed filled
+	 *       in when there is no data to be transferred */
+	cmd_entry->control_flags = CF_NO_DATA;
+	if (cmd->request_bufflen) {
+		if (cmd->sc_data_direction == DMA_TO_DEVICE)
+			cmd_entry->control_flags = CF_WRITE;
+		else if (cmd->sc_data_direction == DMA_FROM_DEVICE)
+			cmd_entry->control_flags = CF_READ;
+	}
+
+	/* Set tagged queueing control flags */
+	cmd_entry->control_flags |= CF_SIMPLE_TAG;
+	if (scsi_populate_tag_msg(cmd, tag)) {
+		switch (tag[0]) {
+		case MSG_HEAD_TAG:
+			cmd_entry->control_flags |= CF_HEAD_TAG;
+			break;
+		case MSG_ORDERED_TAG:
+			cmd_entry->control_flags |= CF_ORDERED_TAG;
+			break;
+		}
+	}
+
+	/* Advance request queue pointer */
+	ha->request_in++;
+	if (ha->request_in == REQUEST_QUEUE_DEPTH) {
+		ha->request_in = 0;
+		ha->request_ptr = ha->request_ring;
+	} else {
+		ha->request_ptr++;
+	}
+
+	qla4xxx_build_scsi_iocbs(srb, cmd_entry, tot_dsds);
+	wmb();
+
+	/*
+	 * Check to see if adapter is online before placing request on
+	 * request queue.  If a reset occurs and a request is in the queue,
+	 * the firmware will still attempt to process the request, retrieving
+	 * garbage for pointers.
+	 */
+	if (!test_bit(AF_ONLINE, &ha->flags)) {
+		DEBUG2(printk("scsi%ld: %s: Adapter OFFLINE! "
+				      "Do not issue command.\n",
+                                      ha->host_no, __func__));
+		goto queuing_error;
+	}
+
+	/* put command in active array */
+	ha->active_srb_array[index] = srb;
+	srb->cmd->host_scribble = (unsigned char *)(unsigned long)index;
+
+	/* update counters */
+	srb->state = SRB_ACTIVE_STATE;
+	srb->flags |= SRB_DMA_VALID;
+
+	/* Track IOCB used */
+	ha->iocb_cnt += req_cnt;
+	srb->iocb_cnt = req_cnt;
+	ha->req_q_count -= req_cnt;
+
+	/* Debug print statements */
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return QLA_SUCCESS;
+
+queuing_error:
+	if (cmd->use_sg && tot_dsds) {
+		sg = (struct scatterlist *) cmd->request_buffer;
+		pci_unmap_sg(ha->pdev, sg, cmd->use_sg, cmd->sc_data_direction);
+	} else if (tot_dsds) {
+		pci_unmap_single(ha->pdev, srb->dma_handle,
+		    cmd->request_bufflen, cmd->sc_data_direction);
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return QLA_ERROR;
+}
diff --git a/drivers/scsi/qla4xxx/ql4_isr.c b/drivers/scsi/qla4xxx/ql4_isr.c
new file mode 100644
index 0000000..4a7b199
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_isr.c
@@ -0,0 +1,821 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#include "ql4_def.h"
+
+/**
+ * qla2x00_process_completed_request() - Process a Fast Post response.
+ * @ha: SCSI driver HA context
+ * @index: SRB index
+ */
+static void
+qla4xxx_process_completed_request(struct scsi_qla_host *ha, uint32_t index)
+{
+	srb_t *srb;
+
+	srb = del_from_active_array(ha, index);
+	if (srb) {
+		/* Save ISP completion status */
+		srb->cmd->result = DID_OK << 16;
+		qla4xxx_srb_compl(ha, srb);
+	} else {
+		DEBUG2(printk("scsi%ld: Invalid ISP SCSI completion handle = "
+		    "%d\n", ha->host_no, index));
+		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_status_entry
+ *	This routine processes Status IOCBs
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      sts_entry - Pointer to status entry structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static void
+qla4xxx_status_entry(scsi_qla_host_t *ha, STATUS_ENTRY *sts_entry)
+{
+	uint8_t scsi_status;
+	struct scsi_cmnd *cmd;
+	srb_t *srb;
+	ddb_entry_t *ddb_entry;
+	uint32_t residual;
+	uint16_t sensebytecnt;
+
+	if (sts_entry->completionStatus == SCS_COMPLETE &&
+	    sts_entry->scsiStatus == 0) {
+		qla4xxx_process_completed_request(ha,
+		    le32_to_cpu(sts_entry->handle));
+		return;
+	}
+
+	srb = del_from_active_array(ha, le32_to_cpu(sts_entry->handle));
+	if (!srb) {
+		/* FIXMEdg: Don't we need to reset ISP in this case??? */
+		DEBUG2(printk(KERN_WARNING "scsi%ld: %s: Status Entry invalid "
+		    "handle 0x%x, sp=%p. This cmd may have already been "
+		    "completed.\n", ha->host_no, __func__,
+		    le32_to_cpu(sts_entry->handle), srb));
+	}
+
+	cmd = srb->cmd;
+	if (cmd == NULL) {
+		DEBUG2(printk("scsi%ld: %s: Command already returned back to "
+		    "OS pkt->handle=%d srb=%p srb->state:%d\n", ha->host_no,
+		    __func__, sts_entry->handle, srb, srb->state));
+		ql4_printk(KERN_WARNING, ha,
+		    "Command is NULL: already returned to OS (srb=%p)\n", srb);
+		return;
+	}
+
+	ddb_entry = srb->ddb;
+	if (ddb_entry == NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+		goto status_entry_exit;
+	}
+
+	residual = le32_to_cpu(sts_entry->residualByteCnt);
+
+	/* Translate ISP error to a Linux SCSI error. */
+	scsi_status = sts_entry->scsiStatus;
+	switch (sts_entry->completionStatus) {
+	case SCS_COMPLETE:
+		if (scsi_status == 0) {
+			cmd->result = DID_OK << 16;
+			break;
+		}
+
+		if (sts_entry->iscsiFlags &
+		    (ISCSI_FLAG_RESIDUAL_OVER|ISCSI_FLAG_RESIDUAL_UNDER))
+			cmd->resid = residual;
+
+		cmd->result = DID_OK << 16 | scsi_status;
+
+		if (scsi_status != SCSI_CHECK_CONDITION)
+			break;
+
+		/* Copy Sense Data into sense buffer. */
+		memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+
+		sensebytecnt = le16_to_cpu(sts_entry->senseDataByteCnt);
+		if (sensebytecnt == 0)
+			break;
+
+		memcpy(cmd->sense_buffer, sts_entry->senseData,
+		    min(sensebytecnt, (uint16_t) sizeof(cmd->sense_buffer)));
+
+		DEBUG2(printk("scsi%ld:%d:%d:%d: %s: sense key = %x, "
+		    "ASC/ASCQ = %02x/%02x\n", ha->host_no,
+		    cmd->device->channel, cmd->device->id, cmd->device->lun,
+		    __func__, sts_entry->senseData[2] & 0x0f,
+		    sts_entry->senseData[12], sts_entry->senseData[13]));
+
+		srb->flags |= SRB_GOT_SENSE;
+		break;
+
+	case SCS_INCOMPLETE:
+		/* Always set the status to DID_ERROR, since
+		 * all conditions result in that status anyway */
+		cmd->result = DID_ERROR << 16;
+		break;
+
+	case SCS_RESET_OCCURRED:
+		DEBUG2(printk("scsi%ld:%d:%d:%d: %s: Device RESET occurred\n",
+		    ha->host_no, cmd->device->channel, cmd->device->id,
+		    cmd->device->lun, __func__));
+
+		cmd->result = DID_RESET << 16;
+		break;
+
+	case SCS_ABORTED:
+		DEBUG2(printk("scsi%ld:%d:%d:%d: %s: Abort occurred\n",
+		    ha->host_no, cmd->device->channel, cmd->device->id,
+		    cmd->device->lun, __func__));
+
+		cmd->result = DID_RESET << 16;
+		break;
+
+	case SCS_TIMEOUT:
+		DEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: Timeout\n",
+		    ha->host_no, cmd->device->channel, cmd->device->id,
+		    cmd->device->lun));
+
+		cmd->result = DID_BUS_BUSY << 16;
+
+		/*
+		 * Mark device missing so that we won't continue to send
+		 * I/O to this device.  We should get a ddb state change
+		 * AEN soon.
+		 */
+		if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)
+			qla4xxx_mark_device_missing(ha, ddb_entry);
+		break;
+
+	case SCS_DATA_UNDERRUN:
+	case SCS_DATA_OVERRUN:
+		if (sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_OVER) {
+			DEBUG2(printk("scsi%ld:%d:%d:%d: %s: " "Data overrun, "
+			    "residual = 0x%x\n", ha->host_no,
+			    cmd->device->channel, cmd->device->id,
+			    cmd->device->lun, __func__, residual));
+
+			cmd->result = DID_ERROR << 16;
+			break;
+		}
+
+		if ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_UNDER) == 0) {
+			/*
+			 * Firmware detected a SCSI transport underrun condition
+			 */
+			cmd->resid = residual;
+			DEBUG2(printk("scsi%ld:%d:%d:%d: %s: UNDERRUN status "
+			    "detected, xferlen = 0x%x, residual = 0x%x\n",
+			    ha->host_no, cmd->device->channel, cmd->device->id,
+			    cmd->device->lun, __func__, cmd->request_bufflen,
+			    residual));
+		}
+
+		/*
+		 * If there is scsi_status, it takes precedense over
+		 * underflow condition.
+		 */
+		if (scsi_status != 0) {
+			cmd->result = DID_OK << 16 | scsi_status;
+
+			if (scsi_status != SCSI_CHECK_CONDITION)
+				break;
+
+			/* Copy Sense Data into sense buffer. */
+			memset(cmd->sense_buffer, 0,
+			    sizeof(cmd->sense_buffer));
+
+			sensebytecnt = le16_to_cpu(sts_entry->senseDataByteCnt);
+			if (sensebytecnt == 0)
+				break;
+
+			memcpy(cmd->sense_buffer, sts_entry->senseData,
+			    min(sensebytecnt,
+				    (uint16_t) sizeof(cmd->sense_buffer)));
+
+			DEBUG2(printk("scsi%ld:%d:%d:%d: %s: sense key = %x, "
+			    "ASC/ASCQ = %02x/%02x\n", ha->host_no,
+			    cmd->device->channel, cmd->device->id,
+			    cmd->device->lun, __func__,
+			    sts_entry->senseData[2] & 0x0f,
+			    sts_entry->senseData[12],
+			    sts_entry->senseData[13]));
+		} else {
+			/*
+			 * If RISC reports underrun and target does not
+			 * report it then we must have a lost frame, so
+			 * tell upper layer to retry it by reporting a
+			 * bus busy.
+			 */
+			if ((sts_entry->iscsiFlags &
+			    ISCSI_FLAG_RESIDUAL_UNDER) == 0) {
+				cmd->result = DID_BUS_BUSY << 16;
+			} else if ((cmd->request_bufflen - residual) <
+				   cmd->underflow) {
+				/*
+				 * Handle mid-layer underflow???
+				 *
+				 * For kernels less than 2.4, the driver must
+				 * return an error if an underflow is detected.
+				 * For kernels equal-to and above 2.4, the
+				 * mid-layer will appearantly handle the
+				 * underflow by detecting the residual count --
+				 * unfortunately, we do not see where this is
+				 * actually being done.  In the interim, we
+				 * will return DID_ERROR.
+				 */
+				DEBUG2(printk("scsi%ld:%d:%d:%d: %s: "
+				    "Mid-layer Data underrun, xferlen = 0x%x, "
+				    "residual = 0x%x\n", ha->host_no,
+				    cmd->device->channel, cmd->device->id,
+				    cmd->device->lun, __func__,
+				    cmd->request_bufflen, residual));
+
+				cmd->result = DID_ERROR << 16;
+			} else {
+				cmd->result = DID_OK << 16;
+			}
+		}
+		break;
+
+	case SCS_DEVICE_LOGGED_OUT:
+	case SCS_DEVICE_UNAVAILABLE:
+		/*
+		 * Mark device missing so that we won't continue to
+		 * send I/O to this device.  We should get a ddb
+		 * state change AEN soon.
+		 */
+		if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)
+			qla4xxx_mark_device_missing(ha, ddb_entry);
+
+		if ((srb->flags & SRB_TAPE) || atomic_read(&ddb_entry->state) ==
+		    DDB_STATE_MISSING)
+			cmd->result = DID_NO_CONNECT << 16;
+		else
+			cmd->result = DID_ERROR << 16;
+		break;
+
+	case SCS_QUEUE_FULL:
+		/*
+		 * SCSI Mid-Layer handles device queue full
+		 */
+		cmd->result = DID_OK << 16 | sts_entry->scsiStatus;
+		DEBUG2(printk("scsi%ld:%d:%d: %s: QUEUE FULL detected "
+		    "compl=%02x, scsi=%02x, state=%02x, iFlags=%02x, "
+		    "iResp=%02x\n", ha->host_no, cmd->device->id,
+		    cmd->device->lun, __func__, sts_entry->completionStatus,
+		    sts_entry->scsiStatus, sts_entry->state_flags,
+		    sts_entry->iscsiFlags, sts_entry->iscsiResponse));
+		break;
+
+	default:
+		cmd->result = DID_ERROR << 16;
+		break;
+	}
+
+status_entry_exit:
+
+	/* complete the request */
+	srb->cc_stat = sts_entry->completionStatus;
+	qla4xxx_srb_compl(ha, srb);
+}
+
+/**************************************************************************
+ * qla4xxx_process_response_queue
+ *	This routine handles the Response Queue Completion.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	hardware_lock locked upon entry
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully processed response queue
+ *	QLA_ERROR   - Failed to process response queue
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static void
+qla4xxx_process_response_queue(scsi_qla_host_t * ha)
+{
+	uint32_t count = 0;
+	srb_t *srb = 0;
+	STATUS_ENTRY *sts_entry;
+
+	/* Process all responses from response queue */
+	while ((ha->response_in =
+	    (uint16_t)le32_to_cpu(ha->shadow_regs->rsp_q_in)) !=
+		ha->response_out) {
+		sts_entry = (STATUS_ENTRY *) ha->response_ptr;
+		count++;
+
+		/* Advance pointers for next entry */
+		if (ha->response_out == (RESPONSE_QUEUE_DEPTH - 1)) {
+			ha->response_out = 0;
+			ha->response_ptr = ha->response_ring;
+		} else {
+			ha->response_out++;
+			ha->response_ptr++;
+		}
+
+		/* process entry */
+		switch (sts_entry->hdr.entryType) {
+		case ET_STATUS:
+			/*
+			 * Common status - Single completion posted in single
+			 * IOSB.
+			 */
+			qla4xxx_status_entry(ha, sts_entry);
+			break;
+
+		case ET_STATUS_CONTINUATION:
+			/* Just throw away the status continuation entries */
+			DEBUG2(printk("scsi%ld: %s: Status Continuation entry "
+			    "- ignoring\n", ha->host_no, __func__));
+			break;
+
+		case ET_COMMAND:
+			/* ISP device queue is full. Command not accepted by
+			 * ISP.  Queue command for later */
+
+			srb = del_from_active_array(ha,
+			    le32_to_cpu(sts_entry->handle));
+			if (srb == NULL)
+				goto exit_prq_invalid_handle;
+
+			DEBUG2(printk("scsi%ld: %s: FW device queue full, "
+			    "srb %p\n", ha->host_no, __func__, srb));
+
+			/* ETRY normally by sending it back with DID_BUS_BUSY */
+			srb->cmd->result = DID_BUS_BUSY << 16;
+			qla4xxx_srb_compl(ha, srb);
+			break;
+
+		case ET_CONTINUE:
+			/* Just throw away the continuation entries */
+			DEBUG2(printk("scsi%ld: %s: Continuation entry - "
+			    "ignoring\n", ha->host_no, __func__));
+			break;
+
+		default:
+			/*
+			 * Invalid entry in response queue, reset RISC
+			 * firmware.
+			 */
+			DEBUG2(printk("scsi%ld: %s: Invalid entry %x in "
+			    "response queue \n", ha->host_no, __func__,
+			    sts_entry->hdr.entryType));
+			goto exit_prq_error;
+		}
+	}
+
+	/*
+	 * Done with responses, update the ISP For QLA4010, this also clears
+	 * the interrupt.
+	 */
+	WRT_REG_DWORD(&ha->reg->rsp_q_out, ha->response_out);
+	PCI_POSTING(&ha->reg->rsp_q_out);
+
+	return;
+
+exit_prq_invalid_handle:
+	DEBUG2(printk("scsi%ld: %s: Invalid handle(srb)=%p type=%x IOCS=%x\n",
+	    ha->host_no, __func__, srb, sts_entry->hdr.entryType,
+	    sts_entry->completionStatus));
+
+exit_prq_error:
+	WRT_REG_DWORD(&ha->reg->rsp_q_out, ha->response_out);
+	PCI_POSTING(&ha->reg->rsp_q_out);
+
+	set_bit(DPC_RESET_HA, &ha->dpc_flags);
+}
+
+/**************************************************************************
+ * qla4xxx_isr_decode_mailbox
+ *	This routine decodes the mailbox status during the ISR.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	mailbox_status - Mailbox status.
+ *
+ * Remarks:
+ *      hardware_lock locked upon entry
+ *
+ * Returns:
+ *	None.
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static void
+qla4xxx_isr_decode_mailbox(scsi_qla_host_t * ha, uint32_t mbox_status)
+{
+	int i;
+
+	if ((mbox_status == MBOX_STS_BUSY) ||
+	    (mbox_status == MBOX_STS_INTERMEDIATE_COMPLETION) ||
+	    (mbox_status >> 12 == MBOX_COMPLETION_STATUS)) {
+		ha->mbox_status[0] = mbox_status;
+
+		if (test_bit(AF_MBOX_COMMAND, &ha->flags)) {
+			/*
+			 * Copy all mailbox registers to a temporary
+			 * location and set mailbox command done flag
+			 */
+			for (i = 1; i < ha->mbox_status_count; i++)
+				ha->mbox_status[i] =
+				    RD_REG_DWORD(&ha->reg->mailbox[i]);
+
+			set_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+			wake_up(&ha->mailbox_wait_queue);
+		}
+	} else if (mbox_status >> 12 == MBOX_ASYNC_EVENT_STATUS) {
+		/* Immediately process the AENs that don't require much work.
+		 * Only queue the database_changed AENs */
+		switch (mbox_status) {
+		case MBOX_ASTS_SYSTEM_ERROR:
+			/* Log Mailbox registers */
+			if (ql4xdontresethba) {
+				DEBUG2(printk("%s:Dont Reset HBA\n", __func__));
+			} else {
+				set_bit(AF_GET_CRASH_RECORD, &ha->flags);
+				set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			}
+			break;
+
+		case MBOX_ASTS_REQUEST_TRANSFER_ERROR:
+		case MBOX_ASTS_RESPONSE_TRANSFER_ERROR:
+		case MBOX_ASTS_NVRAM_INVALID:
+		case MBOX_ASTS_IP_ADDRESS_CHANGED:
+		case MBOX_ASTS_DHCP_LEASE_EXPIRED:
+			DEBUG2(printk("scsi%ld: AEN %04x, ERROR Status, "
+			    "Reset HA\n", ha->host_no, mbox_status));
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			break;
+
+		case MBOX_ASTS_LINK_UP:
+			DEBUG2(printk("scsi%ld: AEN %04x Adapter LINK UP\n",
+			    ha->host_no, mbox_status));
+			set_bit(AF_LINK_UP, &ha->flags);
+			break;
+
+		case MBOX_ASTS_LINK_DOWN:
+			DEBUG2(printk("scsi%ld: AEN %04x Adapter LINK DOWN\n",
+			    ha->host_no, mbox_status));
+			clear_bit(AF_LINK_UP, &ha->flags);
+			break;
+
+		case MBOX_ASTS_HEARTBEAT:
+			ha->seconds_since_last_heartbeat = 0;
+			break;
+
+		case MBOX_ASTS_DHCP_LEASE_ACQUIRED:
+			DEBUG2(printk("scsi%ld: AEN %04x DHCP LEASE "
+			    "ACQUIRED\n", ha->host_no, mbox_status));
+			set_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags);
+			break;
+
+		case MBOX_ASTS_PROTOCOL_STATISTIC_ALARM:
+		case MBOX_ASTS_SCSI_COMMAND_PDU_REJECTED: /* Target mode only */
+		case MBOX_ASTS_UNSOLICITED_PDU_RECEIVED:  /* Connection mode */
+		case MBOX_ASTS_IPSEC_SYSTEM_FATAL_ERROR:
+		case MBOX_ASTS_SUBNET_STATE_CHANGE:
+			/* No action */
+			DEBUG2(printk("scsi%ld: AEN %04x\n", ha->host_no,
+			    mbox_status));
+			break;
+
+		case MBOX_ASTS_MAC_ADDRESS_CHANGED:
+		case MBOX_ASTS_DNS:
+			/* No action */
+			DEBUG2(printk(KERN_INFO "scsi%ld: AEN %04x, "
+			    "mbox_sts[1]=%04x, mbox_sts[2]=%04x\n",
+			    ha->host_no, mbox_status,
+			    RD_REG_DWORD(&ha->reg->mailbox[1]),
+			    RD_REG_DWORD(&ha->reg->mailbox[2])));
+			break;
+
+		case MBOX_ASTS_SELF_TEST_FAILED:
+		case MBOX_ASTS_LOGIN_FAILED:
+			/* No action */
+			DEBUG2(printk("scsi%ld: AEN %04x, mbox_sts[1]=%04x, "
+			    "mbox_sts[2]=%04x, mbox_sts[3]=%04x\n",
+			    ha->host_no, mbox_status,
+			    RD_REG_DWORD(&ha->reg->mailbox[1]),
+			    RD_REG_DWORD(&ha->reg->mailbox[2]),
+			    RD_REG_DWORD(&ha->reg->mailbox[3])));
+			break;
+
+		case MBOX_ASTS_DATABASE_CHANGED:
+			/* Queue AEN information and process it in the DPC
+			 * routine */
+			if (ha->aen_q_count > 0) {
+				/* advance pointer */
+				if (ha->aen_in == (MAX_AEN_ENTRIES - 1))
+					ha->aen_in = 0;
+				else
+					ha->aen_in++;
+
+				/* decrement available counter */
+				ha->aen_q_count--;
+
+				for (i = 1; i < MBOX_AEN_REG_COUNT; i++)
+					ha->aen_q[ha->aen_in].mbox_sts[i] =
+					    RD_REG_DWORD(&ha->reg->mailbox[i]);
+
+				ha->aen_q[ha->aen_in].mbox_sts[0] = mbox_status;
+
+				/* print debug message */
+				DEBUG2(printk("scsi%ld: AEN[%d] %04x queued"
+				    " mb1:0x%x mb2:0x%x mb3:0x%x mb4:0x%x\n",
+				    ha->host_no, ha->aen_in, mbox_status,
+				    ha->aen_q[ha->aen_in].mbox_sts[1],
+				    ha->aen_q[ha->aen_in].mbox_sts[2],
+				    ha->aen_q[ha->aen_in].mbox_sts[3],
+				    ha->aen_q[ha->aen_in].  mbox_sts[4]));
+
+				    /* The DPC routine will process the aen */
+				    set_bit(DPC_AEN, &ha->dpc_flags);
+			} else {
+				DEBUG2(printk("scsi%ld: %s: aen %04x, queue "
+				    "overflowed!  AEN LOST!!\n", ha->host_no,
+				    __func__, mbox_status));
+
+				DEBUG2(printk("scsi%ld: DUMP AEN QUEUE\n",
+				    ha->host_no));
+
+				for (i = 0; i < MAX_AEN_ENTRIES; i++) {
+					DEBUG2(printk("AEN[%d] %04x %04x %04x "
+					    "%04x\n", i,
+					    ha->aen_q[i].mbox_sts[0],
+					    ha->aen_q[i].mbox_sts[1],
+					    ha->aen_q[i].mbox_sts[2],
+					    ha->aen_q[i].mbox_sts[3]));
+				}
+			}
+			break;
+
+		default:
+			DEBUG2(printk(KERN_WARNING
+			    "scsi%ld: AEN %04x UNKNOWN\n", ha->host_no,
+			    mbox_status));
+			break;
+		}
+	} else {
+		DEBUG2(printk("scsi%ld: Unknown mailbox status %08X\n",
+		    ha->host_no, mbox_status));
+
+		ha->mbox_status[0] = mbox_status;
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_interrupt_service_routine
+ *	This routine services the interrupt
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *      hardware_lock locked upon entry
+ *
+ * Returns:
+ *      QLA_SUCCESS - success, An interrupt was found and processed
+ *	QLA_ERROR - failure, The adapter was not interrupting
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_interrupt_service_routine(scsi_qla_host_t * ha, uint32_t intr_status)
+{
+	/* Process response queue interrupt. */
+	if (intr_status & CSR_SCSI_COMPLETION_INTR)
+		qla4xxx_process_response_queue(ha);
+
+	/* Process mailbox/asynch event  interrupt.*/
+	if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
+		qla4xxx_isr_decode_mailbox(ha,
+		    RD_REG_DWORD(&ha->reg->mailbox[0]));
+
+		/* Clear Mailbox Interrupt */
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+		    SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_intr_handler
+ *	This routine handles the H/W interrupt
+ *
+ * Input:
+ *	irq - Unused
+ *	dev_id - Pointer to host adapter structure
+ *	regs - Unused
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+irqreturn_t
+qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	scsi_qla_host_t *ha;
+	uint32_t intr_status;
+	unsigned long flags = 0;
+	uint8_t reqs_count = 0;
+
+	ha = (scsi_qla_host_t *) dev_id;
+	if (!ha) {
+		DEBUG2(printk(KERN_INFO
+		    "qla4xxx: Interrupt with NULL host ptr\n"));
+		return IRQ_NONE;
+	}
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/*
+	 * Repeatedly service interrupts up to a maximum of
+	 * MAX_REQS_SERVICED_PER_INTR
+	 */
+	while (1) {
+		/*
+		 * Read interrupt status
+		 */
+		if (le32_to_cpu(ha->shadow_regs->rsp_q_in) !=
+		    ha->response_out)
+			intr_status = CSR_SCSI_COMPLETION_INTR;
+		else
+			intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+
+		if ((intr_status &
+		    (CSR_SCSI_RESET_INTR|CSR_FATAL_ERROR|INTR_PENDING)) == 0) {
+			if (reqs_count == 0)
+				ha->spurious_int_count++;
+			break;
+		}
+
+		if (intr_status & CSR_FATAL_ERROR) {
+			DEBUG2(printk(KERN_INFO "scsi%ld: Fatal Error, "
+			    "Status 0x%04x\n", ha->host_no,
+			    RD_REG_DWORD(ISP_PORT_ERROR_STATUS (ha))));
+
+			/* Issue Soft Reset to clear this error condition.
+			 * This will prevent the RISC from repeatedly
+			 * interrupting the driver; thus, allowing the DPC to
+			 * get scheduled to continue error recovery.
+			 * NOTE: Disabling RISC interrupts does not work in
+			 * this case, as CSR_FATAL_ERROR overrides
+			 * CSR_SCSI_INTR_ENABLE */
+			if ((RD_REG_DWORD(&ha->reg->ctrl_status) &
+			    CSR_SCSI_RESET_INTR) == 0) {
+				WRT_REG_DWORD(&ha->reg->ctrl_status,
+				    SET_RMASK(CSR_SOFT_RESET));
+				PCI_POSTING(&ha->reg->ctrl_status);
+			}
+
+			WRT_REG_DWORD(&ha->reg->ctrl_status,
+			    SET_RMASK(CSR_FATAL_ERROR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+
+			__qla4xxx_disable_intrs(ha);
+
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+
+			break;
+		} else if (intr_status & CSR_SCSI_RESET_INTR) {
+			clear_bit(AF_ONLINE, &ha->flags);
+			__qla4xxx_disable_intrs(ha);
+
+			WRT_REG_DWORD(&ha->reg->ctrl_status,
+			    SET_RMASK(CSR_SCSI_RESET_INTR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+
+			set_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);
+
+			break;
+		} else if (intr_status & INTR_PENDING) {
+			qla4xxx_interrupt_service_routine(ha, intr_status);
+			ha->total_io_count++;
+			if (++reqs_count == MAX_REQS_SERVICED_PER_INTR) {
+				break;
+			}
+			intr_status = 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/**************************************************************************
+ * qla4xxx_process_aen
+ *	This routine processes Asynchronous Events received from the firmware.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	process_aen -
+ *      	PROCESS_ALL_AENS	 0
+ *      	FLUSH_DDB_CHANGED_AENS	 1
+ *      	RELOGIN_DDB_CHANGED_AENS 2
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_process_aen(scsi_qla_host_t * ha, uint8_t process_aen)
+{
+	uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
+	aen_t *aen;
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	while (ha->aen_out != ha->aen_in) {
+		/* Advance pointers for next entry */
+		if (ha->aen_out == (MAX_AEN_ENTRIES - 1))
+			ha->aen_out = 0;
+		else
+			ha->aen_out++;
+
+		ha->aen_q_count++;
+		aen = &ha->aen_q[ha->aen_out];
+
+		/* copy aen information to local structure */
+		for (i = 0; i < MBOX_AEN_REG_COUNT; i++)
+			mbox_sts[i] = aen->mbox_sts[i];
+
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		DEBUG(printk("scsi%ld: AEN[%d] %04x, index [%d] state=%04x "
+		    "mod=%x conerr=%08x \n", ha->host_no, ha->aen_out,
+		    mbox_sts[0], mbox_sts[2], mbox_sts[3], mbox_sts[1],
+		    mbox_sts[4]));
+
+		switch (mbox_sts[0]) {
+		case MBOX_ASTS_DATABASE_CHANGED:
+			if (process_aen == FLUSH_DDB_CHANGED_AENS) {
+				DEBUG2(printk("scsi%ld: AEN[%d] %04x, index "
+				    "[%d] state=%04x FLUSHED!\n", ha->host_no,
+				    ha->aen_out, mbox_sts[0], mbox_sts[2],
+				    mbox_sts[3]));
+				break;
+			} else if (process_aen == RELOGIN_DDB_CHANGED_AENS) {
+				/* for use during init time, we only want to
+				 * relogin non-active ddbs */
+				ddb_entry_t *ddb_entry;
+
+				ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha,
+				    mbox_sts[2]);
+				if (!ddb_entry)
+					break;
+
+				ddb_entry->dev_scan_wait_to_complete_relogin =0;
+				ddb_entry->dev_scan_wait_to_start_relogin =
+				    jiffies + ((ddb_entry->default_time2wait +
+					4) * HZ);
+
+				DEBUG2(printk("scsi%ld: ddb index [%d] initate "
+				    "RELOGIN after %d seconds\n", ha->host_no,
+				    ddb_entry->fw_ddb_index,
+				    ddb_entry->default_time2wait + 4));
+				break;
+			}
+
+			if (mbox_sts[1] == 0) {	/* Global DB change. */
+				qla4xxx_reinitialize_ddb_list(ha);
+			} else if (mbox_sts[1] == 1) {	/* Specific device. */
+				qla4xxx_process_ddb_changed(ha, mbox_sts[2],
+				    mbox_sts[3]);
+			}
+			break;
+		}
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+}
diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
new file mode 100644
index 0000000..3b81468
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -0,0 +1,924 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#include "ql4_def.h"
+
+/*
+ * externals
+ */
+extern int ql4xportdownretrycount;
+extern int ql4xdiscoverywait;
+extern int qla4xxx_eh_wait_for_active_target_commands(scsi_qla_host_t *, int,
+    int lun);
+
+/**************************************************************************
+ * qla4xxx_mailbox_command
+ *	This routine sssue mailbox commands and waits for completion.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	inCount	 - number of mailbox registers to load.
+ *      outCount - number of mailbox registers to return.
+ *      mbx_cmd  - data pointer for mailbox in registers.
+ *      mbx_sts  - data pointer for mailbox out registers.
+ *
+ * Output:
+ *      mbx_sts - returned mailbox out data.
+ *
+ * Remarks:
+ *	If outCount is 0, this routine completes successfully WITHOUT waiting
+ *	for the mailbox command to complete.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Mailbox command completed successfully
+ *	QLA_ERROR   - Mailbox command competed in error.
+ **************************************************************************/
+int
+qla4xxx_mailbox_command(scsi_qla_host_t * ha, uint8_t inCount,
+    uint8_t outCount, uint32_t * mbx_cmd, uint32_t * mbx_sts)
+{
+	int status = QLA_ERROR;
+	uint8_t i;
+	u_long wait_count;
+	uint32_t intr_status;
+	unsigned long flags = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	mutex_lock(&ha->mbox_sem);
+
+	/* Mailbox code active */
+	set_bit(AF_MBOX_COMMAND, &ha->flags);
+
+	/* Make sure that pointers are valid */
+	if (!mbx_cmd || !mbx_sts) {
+		DEBUG2(printk("scsi%ld: %s: Invalid mbx_cmd or mbx_sts "
+		    "pointer\n", ha->host_no, __func__));
+		goto mbox_exit;
+	}
+
+	/* To prevent overwriting mailbox registers for a command that has
+	 * not yet been serviced, check to see if a previously issued
+	 * mailbox command is interrupting.
+	 * -----------------------------------------------------------------
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
+		/* Service existing interrupt */
+		qla4xxx_interrupt_service_routine(ha, intr_status);
+		clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+	}
+
+	/* Send the mailbox command to the firmware */
+	ha->mbox_status_count = outCount;
+	for (i = 0; i < outCount; i++)
+		ha->mbox_status[i] = 0;
+
+	/* Load all mailbox registers, except mailbox 0. */
+	for (i = 1; i < inCount; i++)
+		WRT_REG_DWORD(&ha->reg->mailbox[i], mbx_cmd[i]);
+
+	/* Wakeup firmware  */
+	WRT_REG_DWORD(&ha->reg->mailbox[0], mbx_cmd[0]);
+	PCI_POSTING(&ha->reg->mailbox[0]);
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_INTR_RISC));
+	PCI_POSTING(&ha->reg->ctrl_status);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Wait for completion */
+	add_wait_queue(&ha->mailbox_wait_queue, &wait);
+
+	/*
+	 * If we don't want status, don't wait for the mailbox command to
+	 * complete.  For example, MBOX_CMD_RESET_FW doesn't return status,
+	 * you must poll the inbound Interrupt Mask for completion.
+	 */
+	if (outCount == 0) {
+		status = QLA_SUCCESS;
+		remove_wait_queue(&ha->mailbox_wait_queue, &wait);
+		goto mbox_exit;
+	}
+
+	/* Wait for command to complete */
+	wait_count = jiffies + MBOX_TOV * HZ;
+	while (test_bit(AF_MBOX_COMMAND_DONE, &ha->flags) == 0) {
+		if (time_after_eq(jiffies, wait_count))
+			break;
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+		if (intr_status & INTR_PENDING) {
+			/*
+			 * Service the interrupt.
+			 * The ISR will save the mailbox status registers
+			 * to a temporary storage location in the adapter
+			 * structure.
+			 */
+			ha->mbox_status_count = outCount;
+			qla4xxx_interrupt_service_routine(ha, intr_status);
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		mdelay(10);
+	}
+	remove_wait_queue(&ha->mailbox_wait_queue, &wait);
+
+	/* Check for mailbox timeout. */
+	if (!test_bit(AF_MBOX_COMMAND_DONE, &ha->flags)) {
+		DEBUG2(printk("scsi%ld: Mailbox Cmd 0x%08X timed out ...,"
+		    " Scheduling Adapter Reset\n", ha->host_no, mbx_cmd[0]));
+		ha->mailbox_timeout_count++;
+		mbx_sts[0] = (-1);
+		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		goto mbox_exit;
+	}
+
+	/*
+	 * Copy the mailbox out registers to the caller's mailbox in/out
+	 * structure.
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (i = 0; i < outCount; i++)
+		mbx_sts[i] = ha->mbox_status[i];
+
+	/* Set return status and error flags (if applicable). */
+	switch (ha->mbox_status[0]) {
+	case MBOX_STS_COMMAND_COMPLETE:
+		status = QLA_SUCCESS;
+		break;
+
+	case MBOX_STS_INTERMEDIATE_COMPLETION:
+		status = QLA_SUCCESS;
+		break;
+
+	case MBOX_STS_BUSY:
+		DEBUG2( printk("scsi%ld: %s: Cmd = %08X, ISP BUSY\n",
+		    ha->host_no, __func__, mbx_cmd[0]));
+		ha->mailbox_timeout_count++;
+		break;
+
+	default:
+		DEBUG2(printk("scsi%ld: %s: **** FAILED, cmd = %08X, "
+		    "sts = %08X ****\n", ha->host_no, __func__, mbx_cmd[0],
+		    mbx_sts[0]));
+		break;
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+mbox_exit:
+	clear_bit(AF_MBOX_COMMAND, &ha->flags);
+	clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+	mutex_unlock(&ha->mbox_sem);
+
+	return status;
+}
+
+
+/*
+ * qla4xxx_issue_iocb
+ *	Issue IOCB using mailbox command
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	buffer = buffer pointer.
+ *	phys_addr = physical address of buffer.
+ *	size = size of buffer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ */
+int
+qla4xxx_issue_iocb(scsi_qla_host_t * ha, void *buffer, dma_addr_t phys_addr,
+    size_t size)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	int status;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_EXECUTE_IOCB_A64;
+	mbox_cmd[1] = 0;
+	mbox_cmd[2] = LSDW(phys_addr);
+	mbox_cmd[3] = MSDW(phys_addr);
+	status = qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]);
+	return status;
+}
+
+int
+qla4xxx_conn_close_sess_logout(scsi_qla_host_t * ha, uint16_t fw_ddb_index,
+    uint16_t connection_id, uint16_t option)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;
+	mbox_cmd[1] = fw_ddb_index;
+	mbox_cmd[2] = connection_id;
+	mbox_cmd[3] = LOGOUT_OPTION_RELOGIN;
+	if (qla4xxx_mailbox_command(ha, 4, 2, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_CONN_CLOSE_SESS_LOGOUT "
+		    "option %04x failed sts %04X %04X", ha->host_no, __func__,
+		    option, mbox_sts[0], mbox_sts[1]));
+		if (mbox_sts[0] == 0x4005)
+			DEBUG2(printk("%s reason %04X\n", __func__,
+			    mbox_sts[1]));
+	}
+	return QLA_SUCCESS;
+}
+
+int
+qla4xxx_clear_database_entry(scsi_qla_host_t * ha, uint16_t fw_ddb_index)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CLEAR_DATABASE_ENTRY;
+	mbox_cmd[1] = fw_ddb_index;
+	if (qla4xxx_mailbox_command(ha, 2, 5, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		return QLA_ERROR;
+	}
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_initialize_fw_cb
+ *	This routine initializes the firmware control block for the
+ *	specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized firmware ctrl block
+ *	QLA_ERROR   - Failed to initialize firmware ctrl block
+ **************************************************************************/
+int
+qla4xxx_initialize_fw_cb(scsi_qla_host_t * ha)
+{
+	INIT_FW_CTRL_BLK *init_fw_cb;
+	dma_addr_t init_fw_cb_dma;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	int status = QLA_ERROR;
+
+	init_fw_cb = dma_alloc_coherent(&ha->pdev->dev,
+	    sizeof(INIT_FW_CTRL_BLK), &init_fw_cb_dma, GFP_KERNEL);
+	if (init_fw_cb == NULL) {
+		DEBUG2(printk("scsi%ld: %s: Unable to alloc init_cb\n",
+		    ha->host_no, __func__));
+		    return 10;
+	}
+	memset(init_fw_cb, 0, sizeof(INIT_FW_CTRL_BLK));
+
+	/* Get Initialize Firmware Control Block. */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(init_fw_cb_dma);
+	mbox_cmd[3] = MSDW(init_fw_cb_dma);
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		dma_free_coherent(&ha->pdev->dev, sizeof(INIT_FW_CTRL_BLK),
+		    init_fw_cb, init_fw_cb_dma);
+		return status;
+	}
+
+	/* Initialize request and response queues. */
+	qla4xxx_init_rings(ha);
+
+	/* Fill in the request and response queue information. */
+	init_fw_cb->ReqQConsumerIndex = cpu_to_le16(ha->request_out);
+	init_fw_cb->ComplQProducerIndex = cpu_to_le16(ha->response_in);
+	init_fw_cb->ReqQLen = __constant_cpu_to_le16(REQUEST_QUEUE_DEPTH);
+	init_fw_cb->ComplQLen = __constant_cpu_to_le16(RESPONSE_QUEUE_DEPTH);
+	init_fw_cb->ReqQAddrLo = cpu_to_le32(LSDW(ha->request_dma));
+	init_fw_cb->ReqQAddrHi = cpu_to_le32(MSDW(ha->request_dma));
+	init_fw_cb->ComplQAddrLo = cpu_to_le32(LSDW(ha->response_dma));
+	init_fw_cb->ComplQAddrHi = cpu_to_le32(MSDW(ha->response_dma));
+	init_fw_cb->ShadowRegBufAddrLo = cpu_to_le32(LSDW(ha->shadow_regs_dma));
+	init_fw_cb->ShadowRegBufAddrHi = cpu_to_le32(MSDW(ha->shadow_regs_dma));
+
+	/* Set up required options. */
+	init_fw_cb->FwOptions |=
+	    __constant_cpu_to_le16(FWOPT_SESSION_MODE | FWOPT_INITIATOR_MODE);
+	init_fw_cb->FwOptions &= __constant_cpu_to_le16(~FWOPT_TARGET_MODE);
+
+	/* Save some info in adapter structure. */
+	ha->firmware_options = le16_to_cpu(init_fw_cb->FwOptions);
+	ha->tcp_options = le16_to_cpu(init_fw_cb->TCPOptions);
+	ha->heartbeat_interval = init_fw_cb->HeartbeatInterval;
+	ha->isns_server_port_number =
+	    le16_to_cpu(init_fw_cb->iSNSServerPortNumber);
+	memcpy(ha->ip_address, init_fw_cb->IPAddr,
+	    min(sizeof(ha->ip_address), sizeof(init_fw_cb->IPAddr)));
+	memcpy(ha->subnet_mask, init_fw_cb->SubnetMask,
+	    min(sizeof(ha->subnet_mask), sizeof(init_fw_cb->SubnetMask)));
+	memcpy(ha->gateway, init_fw_cb->GatewayIPAddr,
+	    min(sizeof(ha->gateway), sizeof(init_fw_cb->GatewayIPAddr)));
+	memcpy(ha->isns_ip_address, init_fw_cb->iSNSIPAddr,
+	    min(sizeof(ha->isns_ip_address), sizeof(init_fw_cb->iSNSIPAddr)));
+	memcpy(ha->name_string, init_fw_cb->iSCSINameString,
+	    min(sizeof(ha->name_string), sizeof(init_fw_cb->iSCSINameString)));
+	memcpy(ha->alias, init_fw_cb->Alias,
+	    min(sizeof(ha->alias), sizeof(init_fw_cb->Alias)));
+
+	/* Save Command Line Paramater info */
+	ha->port_down_retry_count = le16_to_cpu(init_fw_cb->KeepAliveTimeout);
+	ha->discovery_wait = ql4xdiscoverywait;
+
+	/* Send Initialize Firmware Control Block. */
+	mbox_cmd[0] = MBOX_CMD_INITIALIZE_FIRMWARE;
+	mbox_cmd[1] = 0;
+	mbox_cmd[2] = LSDW(init_fw_cb_dma);
+	mbox_cmd[3] = MSDW(init_fw_cb_dma);
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_SUCCESS) {
+		status = QLA_SUCCESS;
+	} else {
+		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_INITIALIZE_FIRMWARE "
+		    "failed w/ status %04X\n", ha->host_no, __func__,
+		    mbox_sts[0]));
+	}
+	dma_free_coherent(&ha->pdev->dev, sizeof(INIT_FW_CTRL_BLK), init_fw_cb,
+	    init_fw_cb_dma);
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_get_dhcp_ip_address
+ *	This routine retrieves the IP Address obtained via DHCP for the
+ *	specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully obtained DHCP IP Address
+ *	QLA_ERROR   - Failed to obtained
+ **************************************************************************/
+int
+qla4xxx_get_dhcp_ip_address(scsi_qla_host_t * ha)
+{
+	INIT_FW_CTRL_BLK *init_fw_cb;
+	dma_addr_t init_fw_cb_dma;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	init_fw_cb = dma_alloc_coherent(&ha->pdev->dev,
+	    sizeof(INIT_FW_CTRL_BLK), &init_fw_cb_dma, GFP_KERNEL);
+	if (init_fw_cb == NULL) {
+		printk("scsi%ld: %s: Unable to alloc init_cb\n", ha->host_no,
+		    __func__);
+		return 10;
+	}
+
+	/* Get Initialize Firmware Control Block. */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	memset(init_fw_cb, 0, sizeof(INIT_FW_CTRL_BLK));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(init_fw_cb_dma);
+	mbox_cmd[3] = MSDW(init_fw_cb_dma);
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: Failed to get init_fw_ctrl_blk\n",
+		    ha->host_no, __func__));
+		dma_free_coherent(&ha->pdev->dev, sizeof(INIT_FW_CTRL_BLK),
+		    init_fw_cb, init_fw_cb_dma);
+		return QLA_ERROR;
+	}
+
+	/* Save IP Address. */
+	memcpy(ha->ip_address, init_fw_cb->IPAddr,
+	    min(sizeof(ha->ip_address), sizeof(init_fw_cb->IPAddr)));
+	memcpy(ha->subnet_mask, init_fw_cb->SubnetMask,
+	    min(sizeof(ha->subnet_mask), sizeof(init_fw_cb->SubnetMask)));
+	memcpy(ha->gateway, init_fw_cb->GatewayIPAddr,
+	    min(sizeof(ha->gateway), sizeof(init_fw_cb->GatewayIPAddr)));
+
+	dma_free_coherent(&ha->pdev->dev, sizeof(INIT_FW_CTRL_BLK), init_fw_cb,
+	    init_fw_cb_dma);
+
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_get_firmware_state
+ *	This routine retrieves the firmware state for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved firmware state
+ *	QLA_ERROR   - Failed to retrieve firmware state
+ **************************************************************************/
+int
+qla4xxx_get_firmware_state(scsi_qla_host_t * ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	/* Get firmware version */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_FW_STATE;
+	if (qla4xxx_mailbox_command(ha, 1, 4, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_FW_STATE failed w/ "
+		    "status %04X\n", ha->host_no, __func__, mbox_sts[0]));
+		return QLA_ERROR;
+	}
+	ha->firmware_state = mbox_sts[1];
+	ha->board_id = mbox_sts[2];
+	ha->addl_fw_state = mbox_sts[3];
+	DEBUG2(printk("scsi%ld: %s firmware_state=0x%x\n",
+		      ha->host_no, __func__, ha->firmware_state);)
+
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_get_firmware_status
+ *	This routine retrieves the firmware status for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved firmware status
+ *	QLA_ERROR   - Failed to retrieve firmware status
+ **************************************************************************/
+int
+qla4xxx_get_firmware_status(scsi_qla_host_t * ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	/* Get firmware version */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_FW_STATUS;
+	if (qla4xxx_mailbox_command(ha, 1, 3, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_FW_STATUS failed w/ "
+		    "status %04X\n", ha->host_no, __func__, mbox_sts[0]));
+		return QLA_ERROR;
+	}
+
+	/* High-water mark of IOCBs */
+	ha->iocb_hiwat = mbox_sts[2];
+	if (ha->iocb_hiwat > IOCB_HIWAT_CUSHION)
+		ha->iocb_hiwat -= IOCB_HIWAT_CUSHION;
+	else
+		ql4_printk(KERN_INFO, ha, "WARNING!!!  You have less than %d "
+		    "firmare IOCBs available (%d).\n", IOCB_HIWAT_CUSHION,
+		    ha->iocb_hiwat);
+
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_get_fwddb_entry
+ *	This routine retrieves the firmware's device database entry.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      fw_ddb_entry - Pointer to firmware's device database entry structure
+ *      num_valid_ddb_entries - Pointer to number of valid ddb entries
+ *      next_ddb_index - Pointer to next valid device database index
+ *      fw_ddb_device_state - Pointer to device state
+ *
+ * Output:
+ *      fw_ddb_entry - Fills in structure if pointer is supplied
+ *      num_valid_ddb_entries - Fills in if pointer is supplied
+ *      next_ddb_index - Fills in if pointer is supplied
+ *      fw_ddb_device_state - Fills in if pointer is supplied
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved ddb info from firmware
+ *	QLA_ERROR   - Failed to retrieve ddb info from firmware
+ **************************************************************************/
+int
+qla4xxx_get_fwddb_entry(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+    DEV_DB_ENTRY *fw_ddb_entry, dma_addr_t fw_ddb_entry_dma,
+    uint32_t *num_valid_ddb_entries, uint32_t *next_ddb_index,
+    uint32_t *fw_ddb_device_state, uint32_t *conn_err_detail,
+    uint16_t *tcp_source_port_num, uint16_t *connection_id)
+{
+	int status = QLA_ERROR;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	/* Make sure the device index is valid */
+	if (fw_ddb_index >= MAX_DDB_ENTRIES) {
+		DEBUG2(printk("scsi%ld: %s: index [%d] out of range.\n",
+		    ha->host_no, __func__, fw_ddb_index));
+		goto exit_get_fwddb;
+	}
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t) fw_ddb_index;
+	mbox_cmd[2] = LSDW(fw_ddb_entry_dma);
+	mbox_cmd[3] = MSDW(fw_ddb_entry_dma);
+	if (qla4xxx_mailbox_command(ha, 4, 7, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_DATABASE_ENTRY failed "
+		    "with status 0x%04X\n", ha->host_no, __func__,
+		    mbox_sts[0]));
+		goto exit_get_fwddb;
+	}
+	if (fw_ddb_index != mbox_sts[1]) {
+		DEBUG2(printk("scsi%ld: %s: index mismatch [%d] != [%d].\n",
+		    ha->host_no, __func__, fw_ddb_index, mbox_sts[1]));
+		goto exit_get_fwddb;
+	}
+	if (fw_ddb_entry) {
+		ql4_printk(KERN_INFO, ha, "DDB[%d] MB0 %04x Tot %d Next %d "
+		    "State %04x ConnErr %08x %d.%d.%d.%d:%04d \"%s\"\n",
+		    fw_ddb_index, mbox_sts[0], mbox_sts[2], mbox_sts[3],
+		    mbox_sts[4], mbox_sts[5], fw_ddb_entry->ipAddr[0],
+		    fw_ddb_entry->ipAddr[1], fw_ddb_entry->ipAddr[2],
+		    fw_ddb_entry->ipAddr[3],
+		    le16_to_cpu(fw_ddb_entry->portNumber),
+		    fw_ddb_entry->iscsiName);
+	}
+	if (num_valid_ddb_entries)
+		*num_valid_ddb_entries = mbox_sts[2];
+	if (next_ddb_index)
+		*next_ddb_index = mbox_sts[3];
+	if (fw_ddb_device_state)
+		*fw_ddb_device_state = mbox_sts[4];
+
+	/*
+	 * RA: This mailbox has been changed to pass connection error and
+	 * details.  Its true for ISP4010 as per Version E - Not sure when it
+	 * was changed.  Get the time2wait from the fw_dd_entry field :
+	 * default_time2wait which we call it as minTime2Wait DEV_DB_ENTRY
+	 * struct.
+	 */
+	if (conn_err_detail)
+		*conn_err_detail = mbox_sts[5];
+	if (tcp_source_port_num)
+		*tcp_source_port_num = (uint16_t) mbox_sts[6] >> 16;
+	if (connection_id)
+		*connection_id = (uint16_t) mbox_sts[6] & 0x00FF;
+	status = QLA_SUCCESS;
+
+exit_get_fwddb:
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_set_fwddb_entry
+ *	This routine initializes or updates the adapter's device database
+ *	entry for the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      fw_ddb_entry - Pointer to firmware's device database entry
+ *		       structure, or NULL.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	This routine also triggers a login for the specified device.
+ *	Therefore, it may also be used as a secondary login routine when
+ *	a NULL pointer is specified for the fw_ddb_entry.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully set ddb_entry in firmware
+ *	QLA_ERROR   - Failed to set ddb_entry in firmware
+ **************************************************************************/
+int
+qla4xxx_set_ddb_entry(scsi_qla_host_t * ha, uint16_t fw_ddb_index,
+    DEV_DB_ENTRY * fw_ddb_entry, dma_addr_t fw_ddb_entry_dma)
+{
+	int status = QLA_ERROR;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	/* Do not wait for completion. The firmware will send us an
+	 * ASTS_DATABASE_CHANGED (0x8014) to notify us of the login status.
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t) fw_ddb_index;
+	mbox_cmd[2] = LSDW(fw_ddb_entry_dma);
+	mbox_cmd[3] = MSDW(fw_ddb_entry_dma);
+	status = qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]);
+	return status;
+}
+
+int
+qla4xxx_conn_open_session_login(scsi_qla_host_t * ha, uint16_t fw_ddb_index)
+{
+	int status = QLA_ERROR;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	/* Do not wait for completion. The firmware will send us an
+	 * ASTS_DATABASE_CHANGED (0x8014) to notify us of the login status.
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CONN_OPEN_SESS_LOGIN;
+	mbox_cmd[1] = (uint32_t) fw_ddb_index;
+	mbox_cmd[2] = 0;
+	mbox_cmd[3] = 0;
+	mbox_cmd[4] = 0;
+	status = qla4xxx_mailbox_command(ha, 4, 0, &mbox_cmd[0], &mbox_sts[0]);
+	DEBUG2(printk("%s fw_ddb_index=%d status=%d mbx0_1=0x%x :0x%x\n",
+	    __func__, fw_ddb_index, status, mbox_sts[0], mbox_sts[1]);)
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_get_crash_record
+ *	This routine retrieves a crash record from the QLA4010 after an
+ *	8002h aen.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_get_crash_record(scsi_qla_host_t * ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	CRASH_RECORD *crash_record = NULL;
+	dma_addr_t crash_record_dma = 0;
+	uint32_t crash_record_size = 0;
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_cmd));
+
+	/* Get size of crash record. */
+	mbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;
+	if (qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: ERROR: Unable to retrieve size!\n",
+		    ha->host_no, __func__));
+		goto exit_get_crash_record;
+	}
+	crash_record_size = mbox_sts[4];
+	if (crash_record_size == 0) {
+		DEBUG2(printk("scsi%ld: %s: ERROR: Crash record size is 0!\n",
+		    ha->host_no, __func__));
+		goto exit_get_crash_record;
+	}
+
+	/* Alloc Memory for Crash Record. */
+	crash_record = dma_alloc_coherent(&ha->pdev->dev, crash_record_size,
+	    &crash_record_dma, GFP_KERNEL);
+	if (crash_record == NULL)
+		goto exit_get_crash_record;
+
+	/* Get Crash Record. */
+	mbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;
+	mbox_cmd[2] = LSDW(crash_record_dma);
+	mbox_cmd[3] = MSDW(crash_record_dma);
+	mbox_cmd[4] = crash_record_size;
+	if (qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS)
+		goto exit_get_crash_record;
+
+	/* Dump Crash Record. */
+
+exit_get_crash_record:
+	if (crash_record)
+		dma_free_coherent(&ha->pdev->dev, crash_record_size,
+		    crash_record, crash_record_dma);
+}
+
+/**************************************************************************
+ * qla4xxx_get_conn_event_log
+ *	This routine retrieves the connection event log
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_get_conn_event_log(scsi_qla_host_t * ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	CONN_EVENT_LOG_ENTRY *event_log = NULL;
+	dma_addr_t event_log_dma = 0;
+	uint32_t event_log_size = 0;
+	uint32_t num_valid_entries;
+	uint32_t      oldest_entry = 0;
+	uint32_t	max_event_log_entries;
+	uint8_t         i;
+
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_cmd));
+
+	/* Get size of crash record. */
+	mbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS)
+		goto exit_get_event_log;
+
+	event_log_size = mbox_sts[4];
+	if (event_log_size == 0)
+		goto exit_get_event_log;
+
+	/* Alloc Memory for Crash Record. */
+	event_log = dma_alloc_coherent(&ha->pdev->dev, event_log_size,
+	    &event_log_dma, GFP_KERNEL);
+	if (event_log == NULL)
+		goto exit_get_event_log;
+
+	/* Get Crash Record. */
+	mbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;
+	mbox_cmd[2] = LSDW(event_log_dma);
+	mbox_cmd[3] = MSDW(event_log_dma);
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: ERROR: Unable to retrieve event "
+		    "log!\n", ha->host_no, __func__));
+		goto exit_get_event_log;
+	}
+
+	/* Dump Event Log. */
+	num_valid_entries = mbox_sts[1];
+
+	max_event_log_entries = event_log_size / sizeof(CONN_EVENT_LOG_ENTRY);
+
+	if (num_valid_entries > max_event_log_entries)
+		oldest_entry = num_valid_entries % max_event_log_entries;
+
+	DEBUG3(printk("scsi%ld: Connection Event Log Dump (%d entries):\n",
+ 			      ha->host_no, num_valid_entries));
+
+ 	if (extended_error_logging == 3) {
+		if (oldest_entry == 0) {
+			/* Circular Buffer has not wrapped around */
+ 		for (i=0; i < num_valid_entries; i++) {
+				qla4xxx_dump_buffer((uint8_t *)event_log+
+						    (i*sizeof(*event_log)),
+						    sizeof(*event_log));
+			}
+		}
+		else {
+			/* Circular Buffer has wrapped around - display accordingly*/
+			for (i=oldest_entry; i < max_event_log_entries; i++) {
+				qla4xxx_dump_buffer((uint8_t *)event_log+
+						    (i*sizeof(*event_log)),
+						    sizeof(*event_log));
+			}
+			for (i=0; i < oldest_entry; i++) {
+				qla4xxx_dump_buffer((uint8_t *)event_log+
+						    (i*sizeof(*event_log)),
+						    sizeof(*event_log));
+			}
+ 		}
+ 	}
+
+exit_get_event_log:
+	if (event_log)
+		dma_free_coherent(&ha->pdev->dev, event_log_size, event_log,
+		    event_log_dma);
+}
+
+/**************************************************************************
+ * qla4xxx_reset_lun
+ *	This routine performs a LUN RESET on the specified target/lun.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *	lun_entry - Pointer to lun entry structure
+ *
+ * Remarks:
+ *	The caller must ensure that the ddb_entry and lun_entry pointers
+ *	are valid before calling this routine.
+ *
+ * Returns:
+ *	QLA_SUCCESS - lun reset completed successfully
+ *	QLA_ERROR   - lun reset failed
+ **************************************************************************/
+int
+qla4xxx_reset_lun(scsi_qla_host_t * ha, ddb_entry_t * ddb_entry, int lun)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	int status = QLA_SUCCESS;
+
+	DEBUG2(printk("scsi%ld:%d:%d: lun reset issued\n", ha->host_no,
+	    ddb_entry->os_target_id, lun));
+
+	/*
+	 * Send lun reset command to ISP, so that the ISP will return all
+	 * outstanding requests with RESET status
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_LUN_RESET;
+	mbox_cmd[1] = ddb_entry->fw_ddb_index;
+	mbox_cmd[2] = lun << 8;
+	mbox_cmd[5] = 0x01;	/* Immediate Command Enable */
+	qla4xxx_mailbox_command(ha, 6, 1, &mbox_cmd[0], &mbox_sts[0]);
+	if (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE &&
+	    mbox_sts[0] != MBOX_STS_COMMAND_ERROR)
+		status = QLA_ERROR;
+
+	return status;
+}
+
+
+int
+qla4xxx_get_flash(scsi_qla_host_t * ha, dma_addr_t dma_addr, uint32_t offset,
+    uint32_t len)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(dma_addr);
+	mbox_cmd[2] = MSDW(dma_addr);
+	mbox_cmd[3] = offset;
+	mbox_cmd[4] = len;
+	if (qla4xxx_mailbox_command(ha, 5, 2, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_READ_FLASH, failed w/ "
+		    "status %04X %04X, offset %08x, len %08x\n", ha->host_no,
+		    __func__, mbox_sts[0], mbox_sts[1], offset, len));
+		return QLA_ERROR;
+	}
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_get_fw_version
+ *	This routine retrieves the firmware version for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	In QLA4010, mailboxes 2 & 3 may hold an address for data.  Make sure
+ *	that we write 0 to those mailboxes, if unused.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved firmware version
+ *	QLA_ERROR   - Failed to retrieve firmware version
+ **************************************************************************/
+int
+qla4xxx_get_fw_version(scsi_qla_host_t * ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	/* Get firmware version. */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_ABOUT_FW;
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_ABOUT_FW failed w/ "
+		    "status %04X\n", ha->host_no, __func__, mbox_sts[0]));
+		return QLA_ERROR;
+	}
+
+	/* Save firmware version information. */
+	ha->firmware_version[0] = mbox_sts[1];
+	ha->firmware_version[1] = mbox_sts[2];
+	ha->patch_number = mbox_sts[3];
+	ha->build_number = mbox_sts[4];
+
+	return QLA_SUCCESS;
+}
diff --git a/drivers/scsi/qla4xxx/ql4_nvram.c b/drivers/scsi/qla4xxx/ql4_nvram.c
new file mode 100644
index 0000000..e28678d
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_nvram.c
@@ -0,0 +1,220 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#include "ql4_def.h"
+
+#define EEPROM_SIZE(ha) \
+    (IS_QLA4022(ha) ? FM93C86A_SIZE_16 : FM93C66A_SIZE_16)
+#define EEPROM_NO_ADDR_BITS(ha) \
+    (IS_QLA4022(ha) ? FM93C86A_NO_ADDR_BITS_16 : FM93C56A_NO_ADDR_BITS_16)
+#define EEPROM_NO_DATA_BITS(ha) FM93C56A_DATA_BITS_16
+
+static int
+FM93C56A_Select(scsi_qla_host_t * ha)
+{
+	DEBUG5(printk(KERN_ERR "FM93C56A_Select:\n"));
+
+	ha->eeprom_cmd_data = AUBURN_EEPROM_CS_1 | 0x000f0000;
+	WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data);
+	PCI_POSTING(ISP_NVRAM(ha));
+	return 1;
+}
+
+static int
+FM93C56A_Cmd(scsi_qla_host_t * ha, int cmd, int addr)
+{
+	int i;
+	int mask;
+	int dataBit;
+	int previousBit;
+
+	/* Clock in a zero, then do the start bit. */
+	WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1);
+	WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1 |
+	    AUBURN_EEPROM_CLK_RISE);
+	WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1 |
+	    AUBURN_EEPROM_CLK_FALL);
+	PCI_POSTING(ISP_NVRAM(ha));
+	mask = 1 << (FM93C56A_CMD_BITS - 1);
+
+	/* Force the previous data bit to be different. */
+	previousBit = 0xffff;
+	for (i = 0; i < FM93C56A_CMD_BITS; i++) {
+		dataBit =
+		    (cmd & mask) ? AUBURN_EEPROM_DO_1 : AUBURN_EEPROM_DO_0;
+		if (previousBit != dataBit) {
+
+			/*
+			 * If the bit changed, then change the DO state to
+			 * match.
+			 */
+			WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | dataBit);
+			previousBit = dataBit;
+		}
+		WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | dataBit |
+		    AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | dataBit |
+		    AUBURN_EEPROM_CLK_FALL);
+		PCI_POSTING(ISP_NVRAM(ha));
+		cmd = cmd << 1;
+	}
+	mask = 1 << (EEPROM_NO_ADDR_BITS(ha) - 1);
+
+	/* Force the previous data bit to be different. */
+	previousBit = 0xffff;
+	for (i = 0; i < EEPROM_NO_ADDR_BITS(ha); i++) {
+		dataBit = addr & mask ? AUBURN_EEPROM_DO_1 : AUBURN_EEPROM_DO_0;
+		if (previousBit != dataBit) {
+			/*
+			 * If the bit changed, then change the DO state to
+			 * match.
+			 */
+			WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | dataBit);
+			previousBit = dataBit;
+		}
+		WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | dataBit |
+		    AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data | dataBit |
+		    AUBURN_EEPROM_CLK_FALL);
+		PCI_POSTING(ISP_NVRAM(ha));
+		addr = addr << 1;
+	}
+	return 1;
+}
+
+static int
+FM93C56A_Deselect(scsi_qla_host_t * ha)
+{
+	ha->eeprom_cmd_data = AUBURN_EEPROM_CS_0 | 0x000f0000;
+	WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data);
+	PCI_POSTING(ISP_NVRAM(ha));
+	return 1;
+}
+
+static int
+FM93C56A_DataIn(scsi_qla_host_t * ha, unsigned short *value)
+{
+	int i;
+	int data = 0;
+	int dataBit;
+
+	/* Read the data bits
+	 * The first bit is a dummy.  Clock right over it. */
+	for (i = 0; i < EEPROM_NO_DATA_BITS(ha); i++) {
+		WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data |
+		    AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), ha->eeprom_cmd_data |
+		    AUBURN_EEPROM_CLK_FALL);
+		dataBit =
+		    (RD_REG_DWORD(ISP_NVRAM(ha)) & AUBURN_EEPROM_DI_1) ? 1 : 0;
+		data = (data << 1) | dataBit;
+	}
+
+	*value = data;
+	return 1;
+}
+
+static int
+EEPROM_ReadWord(int eepromAddr, u16 * value, scsi_qla_host_t * ha)
+{
+	FM93C56A_Select(ha);
+	FM93C56A_Cmd(ha, FM93C56A_READ, eepromAddr);
+	FM93C56A_DataIn(ha, value);
+	FM93C56A_Deselect(ha);
+	return 1;
+}
+
+/* Hardware_lock must be set before calling */
+u16
+RD_NVRAM_WORD(scsi_qla_host_t * ha, int offset)
+{
+	u16 val;
+
+	/* NOTE: NVRAM uses half-word addresses */
+	EEPROM_ReadWord(offset, &val, ha);
+	return val;
+}
+
+int
+qla4xxx_is_nvram_configuration_valid(scsi_qla_host_t * ha)
+{
+	int status = QLA_ERROR;
+	uint16_t checksum = 0;
+	uint32_t index;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (index = 0; index < EEPROM_SIZE(ha); index++)
+		checksum += RD_NVRAM_WORD(ha, index);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (checksum == 0)
+		status = QLA_SUCCESS;
+
+	return status;
+}
+
+/*************************************************************************
+ *
+ *			Hardware Semaphore routines
+ *
+ *************************************************************************/
+int
+ql4xxx_sem_spinlock(scsi_qla_host_t * ha, u32 sem_mask, u32 sem_bits)
+{
+	uint32_t value;
+	unsigned long flags;
+
+	DEBUG2(printk("scsi%ld : Trying to get SEM lock - mask= 0x%x, code = "
+	    "0x%x\n", ha->host_no, sem_mask, sem_bits));
+	while (1) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(ISP_SEMAPHORE(ha), (sem_mask | sem_bits));
+		value = RD_REG_DWORD(ISP_SEMAPHORE(ha));
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		if ((value & (sem_mask >> 16)) == sem_bits) {
+			DEBUG2(printk("scsi%ld : Got SEM LOCK - mask= 0x%x, "
+			    "code = 0x%x\n", ha->host_no, sem_mask, sem_bits));
+			break;
+		}
+		msleep(100);
+	}
+	return 1;
+}
+
+void
+ql4xxx_sem_unlock(scsi_qla_host_t * ha, u32 sem_mask)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_DWORD(ISP_SEMAPHORE(ha), sem_mask);
+	PCI_POSTING(ISP_SEMAPHORE(ha));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	DEBUG2(printk("scsi%ld : UNLOCK SEM - mask= 0x%x\n", ha->host_no,
+	    sem_mask));
+}
+
+int
+ql4xxx_sem_lock(scsi_qla_host_t * ha, u32 sem_mask, u32 sem_bits)
+{
+	uint32_t value;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_DWORD(ISP_SEMAPHORE(ha), (sem_mask | sem_bits));
+	value = RD_REG_DWORD(ISP_SEMAPHORE(ha));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	if ((value & (sem_mask >> 16)) == sem_bits) {
+		DEBUG2(printk("scsi%ld : Got SEM LOCK - mask= 0x%x, code = "
+		    "0x%x, sema code=0x%x\n", ha->host_no, sem_mask, sem_bits,
+		    value));
+		return 1;
+	}
+	return 0;
+}
diff --git a/drivers/scsi/qla4xxx/ql4_nvram.h b/drivers/scsi/qla4xxx/ql4_nvram.h
new file mode 100644
index 0000000..9799ada
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_nvram.h
@@ -0,0 +1,286 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#ifndef _QL2XNVRM_H_
+#define _QL2XNVRM_H_
+
+//
+// AM29LV Flash definitions
+//
+#define  FM93C56A_SIZE_8      0x100
+#define  FM93C56A_SIZE_16     0x80
+#define  FM93C66A_SIZE_8      0x200
+#define  FM93C66A_SIZE_16     0x100	/* 4010 */
+#define  FM93C86A_SIZE_16     0x400	/* 4022 */
+
+#define  FM93C56A_START       0x1
+
+// Commands
+#define  FM93C56A_READ        0x2
+#define  FM93C56A_WEN         0x0
+#define  FM93C56A_WRITE       0x1
+#define  FM93C56A_WRITE_ALL   0x0
+#define  FM93C56A_WDS         0x0
+#define  FM93C56A_ERASE       0x3
+#define  FM93C56A_ERASE_ALL   0x0
+
+// Command Extentions
+#define  FM93C56A_WEN_EXT        0x3
+#define  FM93C56A_WRITE_ALL_EXT  0x1
+#define  FM93C56A_WDS_EXT        0x0
+#define  FM93C56A_ERASE_ALL_EXT  0x2
+
+// Address Bits
+#define  FM93C56A_NO_ADDR_BITS_16   8	/* 4010 */
+#define  FM93C56A_NO_ADDR_BITS_8    9	/* 4010 */
+#define  FM93C86A_NO_ADDR_BITS_16   10	/* 4022 */
+
+// Data Bits
+#define  FM93C56A_DATA_BITS_16   16
+#define  FM93C56A_DATA_BITS_8    8
+
+// Special Bits
+#define  FM93C56A_READ_DUMMY_BITS   1
+#define  FM93C56A_READY             0
+#define  FM93C56A_BUSY              1
+#define  FM93C56A_CMD_BITS          2
+
+// Auburn Bits
+#define  AUBURN_EEPROM_DI           0x8
+#define  AUBURN_EEPROM_DI_0         0x0
+#define  AUBURN_EEPROM_DI_1         0x8
+#define  AUBURN_EEPROM_DO           0x4
+#define  AUBURN_EEPROM_DO_0         0x0
+#define  AUBURN_EEPROM_DO_1         0x4
+#define  AUBURN_EEPROM_CS           0x2
+#define  AUBURN_EEPROM_CS_0         0x0
+#define  AUBURN_EEPROM_CS_1         0x2
+#define  AUBURN_EEPROM_CLK_RISE     0x1
+#define  AUBURN_EEPROM_CLK_FALL     0x0
+
+//
+// EEPROM format
+//
+typedef struct _BIOS_PARAMS {
+	uint16_t SpinUpDelay:1;
+	uint16_t BIOSDisable:1;
+	uint16_t MMAPEnable:1;
+	uint16_t BootEnable:1;
+	uint16_t Reserved0:12;
+	uint8_t bootID0:7;
+	uint8_t bootID0Valid:1;
+	uint8_t bootLUN0[8];
+	uint8_t bootID1:7;
+	uint8_t bootID1Valid:1;
+	uint8_t bootLUN1[8];
+	uint16_t MaxLunsPerTarget;
+	uint8_t Reserved1[10];
+} BIOS_PARAMS, *PBIOS_PARAMS;
+typedef struct _EEPROM_PORT_CFG {
+
+	// MTU MAC 0
+	u16 etherMtu_mac;
+
+	// Flow Control MAC 0
+	u16 pauseThreshold_mac;
+	u16 resumeThreshold_mac;
+	u16 reserved[13];
+} EEPROM_PORT_CFG, *PEEPROM_PORT_CFG;
+typedef struct _EEPROM_FUNCTION_CFG {
+	u8 reserved[30];
+
+	// MAC ADDR
+	u8 macAddress[6];
+	u8 macAddressSecondary[6];
+	u16 subsysVendorId;
+	u16 subsysDeviceId;
+} EEPROM_FUNCTION_CFG;
+typedef struct {
+	union {
+		struct {	/* isp4010 */
+			u8 asic_id[4];	// x00
+			u8 version;	// x04
+			u8 reserved;	// x05
+			u16 board_id;	// x06
+#  define   EEPROM_BOARDID_ELDORADO    1
+#  define   EEPROM_BOARDID_PLACER      2
+
+#  define EEPROM_SERIAL_NUM_SIZE       16
+			u8 serial_number[EEPROM_SERIAL_NUM_SIZE];	// x08
+
+			// ExtHwConfig:
+			// Offset = 24bytes
+			//
+			// | SSRAM Size|     |ST|PD|SDRAM SZ| W| B| SP  |  |
+			// |15|14|13|12|11|10| 9| 8 | 7| 6| 5| 4| 3| 2| 1| 0|
+			// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+			u16 ext_hw_conf;	// x18
+			u8 mac0[6];	// x1A
+			u8 mac1[6];	// x20
+			u8 mac2[6];	// x26
+			u8 mac3[6];	// x2C
+			u16 etherMtu;	// x32
+			u16 macConfig;	// x34
+#define  MAC_CONFIG_ENABLE_ANEG     0x0001
+#define  MAC_CONFIG_ENABLE_PAUSE    0x0002
+			u16 phyConfig;	// x36
+#define  PHY_CONFIG_PHY_ADDR_MASK             0x1f
+#define  PHY_CONFIG_ENABLE_FW_MANAGEMENT_MASK 0x20
+			u16 topcat;	// x38
+#define TOPCAT_PRESENT		0x0100
+#define TOPCAT_MASK		0xFF00
+
+#  define EEPROM_UNUSED_1_SIZE   2
+			u8 unused_1[EEPROM_UNUSED_1_SIZE];	// x3A
+			u16 bufletSize;	// x3C
+			u16 bufletCount;	// x3E
+			u16 bufletPauseThreshold;	// x40
+			u16 tcpWindowThreshold50;	// x42
+			u16 tcpWindowThreshold25;	// x44
+			u16 tcpWindowThreshold0;	// x46
+			u16 ipHashTableBaseHi;	// x48
+			u16 ipHashTableBaseLo;	// x4A
+			u16 ipHashTableSize;	// x4C
+			u16 tcpHashTableBaseHi;	// x4E
+			u16 tcpHashTableBaseLo;	// x50
+			u16 tcpHashTableSize;	// x52
+			u16 ncbTableBaseHi;	// x54
+			u16 ncbTableBaseLo;	// x56
+			u16 ncbTableSize;	// x58
+			u16 drbTableBaseHi;	// x5A
+			u16 drbTableBaseLo;	// x5C
+			u16 drbTableSize;	// x5E
+
+#  define EEPROM_UNUSED_2_SIZE   4
+			u8 unused_2[EEPROM_UNUSED_2_SIZE];	// x60
+			u16 ipReassemblyTimeout;	// x64
+			u16 tcpMaxWindowSizeHi;	// x66
+			u16 tcpMaxWindowSizeLo;	// x68
+			u32 net_ip_addr0;	// x6A /* Added for TOE functionality. */
+			u32 net_ip_addr1;	// x6E
+			u32 scsi_ip_addr0;	// x72
+			u32 scsi_ip_addr1;	// x76
+#  define EEPROM_UNUSED_3_SIZE   128	/* changed from 144 to account for ip addresses */
+			u8 unused_3[EEPROM_UNUSED_3_SIZE];	// x7A
+			u16 subsysVendorId_f0;	// xFA
+			u16 subsysDeviceId_f0;	// xFC
+
+			// Address = 0x7F
+#  define FM93C56A_SIGNATURE  0x9356
+#  define FM93C66A_SIGNATURE  0x9366
+			u16 signature;	// xFE
+
+#  define EEPROM_UNUSED_4_SIZE   250
+			u8 unused_4[EEPROM_UNUSED_4_SIZE];	// x100
+			u16 subsysVendorId_f1;	// x1FA
+			u16 subsysDeviceId_f1;	// x1FC
+			u16 checksum;	// x1FE
+		} __attribute__ ((packed)) isp4010;
+		struct {	/* isp4022 */
+			u8 asicId[4];	// x00
+			u8 version;	// x04
+			u8 reserved_5;	// x05
+			u16 boardId;	// x06
+			u8 boardIdStr[16];	// x08
+			u8 serialNumber[16];	// x18
+
+			// External Hardware Configuration
+			u16 ext_hw_conf;	// x28
+
+			// MAC 0 CONFIGURATION
+			EEPROM_PORT_CFG macCfg_port0;	// x2A
+
+			// MAC 1 CONFIGURATION
+			EEPROM_PORT_CFG macCfg_port1;	// x4A
+
+			// DDR SDRAM Configuration
+			u16 bufletSize;	// x6A
+			u16 bufletCount;	// x6C
+			u16 tcpWindowThreshold50;	// x6E
+			u16 tcpWindowThreshold25;	// x70
+			u16 tcpWindowThreshold0;	// x72
+			u16 ipHashTableBaseHi;	// x74
+			u16 ipHashTableBaseLo;	// x76
+			u16 ipHashTableSize;	// x78
+			u16 tcpHashTableBaseHi;	// x7A
+			u16 tcpHashTableBaseLo;	// x7C
+			u16 tcpHashTableSize;	// x7E
+			u16 ncbTableBaseHi;	// x80
+			u16 ncbTableBaseLo;	// x82
+			u16 ncbTableSize;	// x84
+			u16 drbTableBaseHi;	// x86
+			u16 drbTableBaseLo;	// x88
+			u16 drbTableSize;	// x8A
+			u16 reserved_142[4];	// x8C
+
+			// TCP/IP Parameters
+			u16 ipReassemblyTimeout;	// x94
+			u16 tcpMaxWindowSize;	// x96
+			u16 ipSecurity;	// x98
+			u8 reserved_156[294];	// x9A
+			u16 qDebug[8];	// QLOGIC USE ONLY   x1C0
+			EEPROM_FUNCTION_CFG funcCfg_fn0;	// x1D0
+			u16 reserved_510;	// x1FE
+
+			// Address = 512
+			u8 oemSpace[432];	// x200
+			BIOS_PARAMS sBIOSParams_fn1;	// x3B0
+			EEPROM_FUNCTION_CFG funcCfg_fn1;	// x3D0
+			u16 reserved_1022;	// x3FE
+
+			// Address = 1024
+			u8 reserved_1024[464];	// x400
+			EEPROM_FUNCTION_CFG funcCfg_fn2;	// x5D0
+			u16 reserved_1534;	// x5FE
+
+			// Address = 1536
+			u8 reserved_1536[432];	// x600
+			BIOS_PARAMS sBIOSParams_fn3;	// x7B0
+			EEPROM_FUNCTION_CFG funcCfg_fn3;	// x7D0
+			u16 checksum;	// x7FE
+		} __attribute__ ((packed)) isp4022;
+	};
+} eeprom_data_t;
+
+#define EEPROM_EXT_HW_CONF_OFFSET() \
+    (IS_QLA4022(ha) ? \
+     offsetof(eeprom_data_t, isp4022.ext_hw_conf) / 2 : \
+     offsetof(eeprom_data_t, isp4010.ext_hw_conf) / 2)
+/*************************************************************************
+ *
+ *			Hardware Semaphore
+ *
+ *************************************************************************/
+#if 0
+//
+// Semaphore register definitions
+//
+#define SEM_AVAILABLE        	0x00
+#define SEM_OWNER_FIRMWARE   	0x01
+#define SEM_OWNER_STORAGE    	0x02
+#define SEM_OWNER_NETWORK    	0x03
+
+//
+// Private Semaphore definitions
+//
+typedef enum { SEM_HW_LOCK, SEM_GPO, SEM_SDRAM_INIT, SEM_PHY_GBIC, SEM_NVRAM, SEM_FLASH, SEM_COUNT	// Not a real semaphore, just indicates how many there are
+} ISP4XXX_SEMAPHORE;
+typedef struct {
+	uint32_t semId;
+	uint32_t semShift;
+} isp4xxxSemInfo_t;
+
+#define SEM_MASK  0x3
+
+/* Wait flag defines -- specifies type of wait to acquire semaphore */
+#define SEM_FLG_NO_WAIT		0
+#define SEM_FLG_WAIT_FOREVER	1
+#define SEM_FLG_TIMED_WAIT	2
+
+#endif				/*  */
+
+#endif				// _QL2XNVRM_H_
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
new file mode 100644
index 0000000..0e87a0f
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -0,0 +1,1963 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#include "ql4_def.h"
+
+#include <linux/moduleparam.h>
+
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsicam.h>
+
+/*
+ * Driver version
+ */
+char qla4xxx_version_str[40];
+
+/*
+ * SRB allocation cache
+ */
+kmem_cache_t *srb_cachep;
+
+/*
+ * Module parameter information and variables
+ */
+int ql4xdiscoverywait = 60;
+module_param(ql4xdiscoverywait, int, S_IRUGO | S_IRUSR);
+MODULE_PARM_DESC(ql4xdiscoverywait, "Discovery wait time");
+int ql4xdontresethba = 0;
+module_param(ql4xdontresethba, int, S_IRUGO | S_IRUSR);
+MODULE_PARM_DESC(ql4xdontresethba,
+		 "Dont reset the HBA when the driver gets 0x8002 AEN "
+		 " default it will reset hba :0"
+		 " set to 1 to avoid resetting HBA");
+
+int extended_error_logging = 0;	/* 0 = off, 1 = log errors */
+module_param(extended_error_logging, int, S_IRUGO | S_IRUSR);
+MODULE_PARM_DESC(extended_error_logging,
+		 "Option to enable extended error logging, "
+		 "Default is 0 - no logging, 1 - debug " "logging");
+
+/*
+ * SCSI host template entry points
+ */
+
+static int qla4xxx_mem_alloc(scsi_qla_host_t * ha);
+static void qla4xxx_mem_free(scsi_qla_host_t * ha);
+static void qla4xxx_timer(scsi_qla_host_t *ha);
+static int qla4xxx_do_dpc(void *data);
+static void qla4xxx_flush_active_srbs(scsi_qla_host_t * ha);
+int qla4xxx_reset_target(scsi_qla_host_t * ha, ddb_entry_t * ddb_entry);
+int qla4xxx_recover_adapter(scsi_qla_host_t * ha, uint8_t renew_ddb_list);
+void qla4xxx_config_dma_addressing(scsi_qla_host_t * ha);
+
+static int qla4xxx_iospace_config(scsi_qla_host_t * ha);
+static void qla4xxx_free_adapter(scsi_qla_host_t * ha);
+static int
+qla4xxx_conn_get_param(struct iscsi_cls_conn *cls_conn,
+		     enum iscsi_param param, uint32_t *value);
+static int
+qla4xxx_session_get_param(struct iscsi_cls_session *cls_session,
+			enum iscsi_param param, uint32_t *value);
+
+/*
+ * SCSI host template entry points
+ */
+static int qla4xxx_queuecommand(struct scsi_cmnd *cmd,
+    void (*done) (struct scsi_cmnd *));
+static int qla4xxx_eh_abort(struct scsi_cmnd *cmd);
+static int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd);
+static int qla4xxx_eh_bus_reset(struct scsi_cmnd *cmd);
+static int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd);
+static int qla4xxx_slave_alloc(struct scsi_device *device);
+static int qla4xxx_slave_configure(struct scsi_device *device);
+static void qla4xxx_slave_destroy(struct scsi_device *device);
+
+static struct scsi_host_template qla4xxx_driver_template = {
+	.module			= THIS_MODULE,
+	.name			= "qla4xxx",
+	.queuecommand		= qla4xxx_queuecommand,
+
+	.eh_abort_handler	= qla4xxx_eh_abort,
+	.eh_device_reset_handler = qla4xxx_eh_device_reset,
+	.eh_bus_reset_handler	= qla4xxx_eh_bus_reset,
+	.eh_host_reset_handler	= qla4xxx_eh_host_reset,
+
+	.slave_configure	= qla4xxx_slave_configure,
+	.slave_alloc		= qla4xxx_slave_alloc,
+	.slave_destroy		= qla4xxx_slave_destroy,
+
+	.this_id		= -1,
+	.cmd_per_lun		= 3,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.sg_tablesize		= SG_ALL,
+
+	.max_sectors		= 0xFFFF,
+};
+
+static struct iscsi_transport qla4xxx_iscsi_transport_functions = {
+        .owner                  = THIS_MODULE,
+        .name                   = "qla4xxx",
+        .caps                   = 0,
+        .host_template          = &qla4xxx_driver_template,
+        .hostdata_size          = 0,
+        .conndata_size          = 0,
+        .max_conn               = 1,
+        .max_cmd_len            = IOCB_MAX_CDB_LEN,
+	.get_conn_param		= qla4xxx_conn_get_param,
+	.get_session_param	= qla4xxx_session_get_param,
+};
+
+static struct scsi_transport_template *qla4xxx_transport_template = NULL;
+
+static int
+qla4xxx_conn_get_param(struct iscsi_cls_conn *cls_conn,
+		     enum iscsi_param param, uint32_t *value)
+{
+	*value = 0;
+	return ISCSI_ERR_PARAM_NOT_FOUND;
+}
+
+static int
+qla4xxx_session_get_param(struct iscsi_cls_session *cls_session,
+			enum iscsi_param param, uint32_t *value)
+{
+	*value = 0;
+	return ISCSI_ERR_PARAM_NOT_FOUND;
+}
+
+/*
+ * Timer routines
+ */
+
+static void
+qla4xxx_start_timer(scsi_qla_host_t * ha, void *func, unsigned long interval)
+{
+	DEBUG(printk("scsi: %s: Starting timer thread for adapter %d\n",
+	    __func__, ha->instance));
+	init_timer(&ha->timer);
+	ha->timer.expires = jiffies + interval * HZ;
+	ha->timer.data = (unsigned long)ha;
+	ha->timer.function = (void (*)(unsigned long))func;
+	add_timer(&ha->timer);
+	ha->timer_active = 1;
+}
+
+static void
+qla4xxx_stop_timer(scsi_qla_host_t * ha)
+{
+	del_timer_sync(&ha->timer);
+	ha->timer_active = 0;
+}
+
+/**************************************************************************
+ * qla4xxx_mark_device_missing
+ *	This routine marks a device missing and resets the relogin retry count.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *	None
+ *
+ **************************************************************************/
+void
+qla4xxx_mark_device_missing(scsi_qla_host_t * ha, ddb_entry_t * ddb_entry)
+{
+	atomic_set(&ddb_entry->state, DDB_STATE_MISSING);
+	DEBUG3(printk("scsi%d:%d:%d: index [%d] marked MISSING\n",
+	    ha->host_no, ddb_entry->bus, ddb_entry->target,
+	    ddb_entry->fw_ddb_index));
+}
+
+static inline srb_t *
+qla4xxx_get_new_srb(scsi_qla_host_t *ha, struct ddb_entry *ddb_entry,
+    struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+{
+	srb_t *srb;
+
+	srb = mempool_alloc(ha->srb_mempool, GFP_ATOMIC);
+	if (!srb)
+		return srb;
+
+	atomic_set(&srb->ref_count, 1);
+	srb->ha = ha;
+	srb->ddb = ddb_entry;
+	srb->cmd = cmd;
+	srb->flags = 0;
+	CMD_SP(cmd) = (void *)srb;
+	cmd->scsi_done = done;
+
+	return srb;
+}
+
+static void
+qla4xxx_srb_free_dma(scsi_qla_host_t *ha, srb_t *srb)
+{
+	struct scsi_cmnd *cmd = srb->cmd;
+
+	if (srb->flags & SRB_DMA_VALID) {
+		if (cmd->use_sg) {
+			dma_unmap_sg(&ha->pdev->dev, cmd->request_buffer,
+			    cmd->use_sg, cmd->sc_data_direction);
+		} else if (cmd->request_bufflen) {
+			dma_unmap_single(&ha->pdev->dev, srb->dma_handle,
+			    cmd->request_bufflen, cmd->sc_data_direction);
+		}
+		srb->flags &= ~SRB_DMA_VALID;
+	}
+	CMD_SP(cmd) = NULL;
+}
+
+void
+qla4xxx_srb_compl(scsi_qla_host_t *ha, srb_t *srb)
+{
+	struct scsi_cmnd *cmd = srb->cmd;
+
+	qla4xxx_srb_free_dma(ha, srb);
+
+	mempool_free(srb, ha->srb_mempool);
+
+	cmd->scsi_done(cmd);
+}
+
+/**************************************************************************
+ * qla4xxx_queuecommand
+ *      This routine is invoked by Linux to send a SCSI command to the driver.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *      done_fn - Function that the driver calls to notify the SCSI mid-layer
+ *                that the command has been processed.
+ *
+ * Remarks:
+ *    The mid-level driver tries to ensure that queuecommand never gets
+ *    invoked concurrently with itself or the interrupt handler (although
+ *    the interrupt handler may call this routine as part of request-
+ *    completion handling).   Unfortunely, it sometimes calls the scheduler
+ *    in interrupt context which is a big NO! NO!.
+ *
+ * Returns:
+ *      None
+ **************************************************************************/
+static int
+qla4xxx_queuecommand(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+{
+	scsi_qla_host_t *ha = to_qla_host(cmd->device->host);
+	struct ddb_entry *ddb_entry = (struct ddb_entry *)cmd->device->hostdata;
+	srb_t *srb;
+	int rval;
+
+	if (!ddb_entry) {
+		cmd->result = DID_NO_CONNECT << 16;
+		goto qc_fail_command;
+	}
+
+	if (atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE) {
+		if (atomic_read(&ddb_entry->state) == DDB_STATE_DEAD) {
+			cmd->result = DID_NO_CONNECT << 16;
+			goto qc_fail_command;
+		}
+		goto qc_host_busy;
+	}
+
+	spin_unlock_irq(ha->host->host_lock);
+
+	srb = qla4xxx_get_new_srb(ha, ddb_entry, cmd, done);
+	if (!srb)
+		goto qc_host_busy_lock;
+
+	rval = qla4xxx_send_command_to_isp(ha, srb);
+	if (rval != QLA_SUCCESS)
+		goto qc_host_busy_free_sp;
+
+	spin_lock_irq(ha->host->host_lock);
+	return 0;
+
+qc_host_busy_free_sp:
+	qla4xxx_srb_free_dma(ha, srb);
+        mempool_free(srb, ha->srb_mempool);
+
+qc_host_busy_lock:
+	spin_lock_irq(ha->host->host_lock);
+
+qc_host_busy:
+	return SCSI_MLQUEUE_HOST_BUSY;
+
+qc_fail_command:
+	done(cmd);
+
+	return 0;
+}
+
+/**************************************************************************
+ * qla4xxx_probe_adapter
+ *    This routine will probe for Qlogic 4010 iSCSI host adapters.
+ *    It returns the number of host adapters of a particular
+ *    type that were found.  It also initializes all data necessary for
+ *    the driver.  It is passed-in the host number, so that it
+ *    knows where its first entry is in the scsi_hosts[] array.
+ *
+ * Input:
+ *
+ * Returns:
+ **************************************************************************/
+static int __devinit
+qla4xxx_probe_adapter(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int ret = -ENODEV, status;
+	struct Scsi_Host *host;
+	scsi_qla_host_t *ha;
+	uint8_t init_retry_count = 0;
+	struct ddb_entry *ddb_entry, *ddbtemp;
+
+	if (pci_enable_device(pdev))
+		return -1;
+
+	host = scsi_host_alloc(&qla4xxx_driver_template,
+	    sizeof(scsi_qla_host_t));
+	if (host == NULL) {
+		printk(KERN_WARNING
+		       "qla4xxx: Couldn't allocate host from scsi layer!\n");
+		goto probe_disable_device;
+	}
+
+	/* Clear our data area */
+	ha = (scsi_qla_host_t *) host->hostdata;
+	memset(ha, 0, sizeof(scsi_qla_host_t));
+
+	/* Save the information from PCI BIOS.  */
+	ha->pdev = pdev;
+	ha->host = host;
+	ha->host_no = host->host_no;
+
+	/* Configure PCI I/O space. */
+	ret = qla4xxx_iospace_config(ha);
+	if (ret)
+		goto probe_failed;
+
+	ql4_printk(KERN_INFO, ha,
+	    "Found an ISP%04x, irq %d, iobase 0x%p\n", pdev->device, pdev->irq,
+	    ha->reg);
+
+	qla4xxx_config_dma_addressing(ha);
+
+	/* Initialize lists and spinlocks. */
+	INIT_LIST_HEAD(&ha->ddb_list);
+	INIT_LIST_HEAD(&ha->free_srb_q);
+
+	mutex_init(&ha->mbox_sem);
+	init_waitqueue_head(&ha->mailbox_wait_queue);
+
+	spin_lock_init(&ha->hardware_lock);
+	spin_lock_init(&ha->list_lock);
+
+	/* Allocate dma buffers */
+	if (qla4xxx_mem_alloc(ha)) {
+		ql4_printk(KERN_WARNING, ha,
+		    "[ERROR] Failed to allocate memory for adapter\n");
+
+		ret = -ENOMEM;
+		goto probe_disable_device;
+	}
+
+	/*
+	 * Initialize the Host adapter request/response queues and
+	 * firmware
+	 * NOTE: interrupts enabled upon successful completion
+	 */
+	status = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
+	while (status == QLA_ERROR && init_retry_count++ < MAX_INIT_RETRIES) {
+		DEBUG2(printk("scsi: %s: retrying adapter initialization "
+		    "(%d)\n", __func__, init_retry_count));
+		qla4xxx_soft_reset(ha);
+		status = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
+	}
+	if (status == QLA_ERROR) {
+		ql4_printk(KERN_WARNING, ha, "Failed to initialize adapter\n");
+
+		ret = -ENODEV;
+		goto probe_failed;
+	}
+
+	host->cmd_per_lun = 3;
+	host->max_channel = 0;
+	host->max_lun = MAX_LUNS - 1;
+	host->max_id = MAX_TARGETS;
+	host->unique_id = ha->instance;
+	host->max_cmd_len = IOCB_MAX_CDB_LEN;
+	host->can_queue = REQUEST_QUEUE_DEPTH + 128;
+	host->transportt = qla4xxx_transport_template;
+
+	/* Startup the kernel thread for this host adapter. */
+	DEBUG2(printk("scsi: %s: Starting kernel thread for "
+		      "qla4xxx_dpc\n", __func__));
+	ha->dpc_thread = kthread_create(qla4xxx_do_dpc, ha, "qla4xxx_%d_dpc",
+	    ha->host_no);
+	if (IS_ERR(ha->dpc_thread)) {
+		ql4_printk(KERN_WARNING, ha, "Unable to start DPC thread!\n");
+
+		ret = PTR_ERR(ha->dpc_thread);
+		goto probe_failed;
+	}
+
+	ret = request_irq(pdev->irq, qla4xxx_intr_handler,
+	    SA_INTERRUPT|SA_SHIRQ, "qla4xxx", ha);
+	if (ret) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Failed to reserve interrupt %d already in use.\n",
+		    pdev->irq);
+		goto probe_failed;
+	}
+	set_bit(AF_IRQ_ATTACHED, &ha->flags);
+	host->irq = pdev->irq;
+	DEBUG(printk("scsi%d: irq %d attached\n", ha->host_no, ha->pdev->irq));
+
+	qla4xxx_enable_intrs(ha);
+
+	/* Start timer thread. */
+	qla4xxx_start_timer(ha, qla4xxx_timer, 1);
+
+	set_bit(AF_INIT_DONE, &ha->flags);
+
+	pci_set_drvdata(pdev, ha);
+
+	ret = scsi_add_host(host, &pdev->dev);
+	if (ret)
+		goto probe_failed;
+
+/*FIXME*/
+/*	qla4x00_alloc_sysfs_attr(ha); */
+
+	printk(KERN_INFO
+	    " QLogic iSCSI HBA Driver version: %s\n"
+	    "  QLogic ISP%04x @ %s, host#=%ld, fw=%02d.%02d.%02d.%02d\n",
+	    qla4xxx_version_str, ha->pdev->device, pci_name(ha->pdev),
+	    ha->host_no, ha->firmware_version[0], ha->firmware_version[1],
+	    ha->patch_number, ha->build_number);
+
+	/* Update transport device information for all devices. */
+	list_for_each_entry_safe(ddb_entry, ddbtemp, &ha->ddb_list, list) {
+		if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+			if( (ddb_entry->session = iscsi_create_session(host,
+				&qla4xxx_iscsi_transport_functions,0)) != NULL ) {
+				ddb_entry->session->dd_data = ddb_entry;
+				iscsi_create_conn(ddb_entry->session, 0);
+			}
+		}
+	}
+
+	scsi_scan_host(host);
+
+	return 0;
+
+probe_failed:
+	qla4xxx_free_adapter(ha);
+
+probe_disable_device:
+	pci_disable_device(pdev);
+
+	return ret;
+}
+
+/**************************************************************************
+ * qla4xxx_remove_adapter
+ *
+ * Input:
+ *	pci_dev - PCI device pointer
+ *
+ * Returns:
+ **************************************************************************/
+static void __devexit
+qla4xxx_remove_adapter(struct pci_dev *pdev)
+{
+	scsi_qla_host_t *ha;
+
+	ha = pci_get_drvdata(pdev);
+
+	scsi_remove_host(ha->host);
+
+	qla4xxx_free_adapter(ha);
+
+	scsi_host_put(ha->host);
+
+	pci_set_drvdata(pdev, NULL);
+}
+
+/**************************************************************************
+ * qla4xxx_free_adapter
+ *
+ * Input:
+ *	pci_dev - PCI device pointer
+ *
+ * Returns:
+ **************************************************************************/
+static void
+qla4xxx_free_adapter(scsi_qla_host_t * ha)
+{
+
+	if (test_bit(AF_INTERRUPTS_ON, &ha->flags)) {
+		/* Turn-off interrupts on the card. */
+		qla4xxx_disable_intrs(ha);
+	}
+
+	/* Kill the kernel thread for this host */
+	if (ha->dpc_thread) {
+		struct task_struct *t = ha->dpc_thread;
+
+		/*
+		 * qla4xxx_wake_dpc checks for ->dpc_thread so we need to zero
+		 * it out.
+		 */
+		ha->dpc_thread = NULL;
+		kthread_stop(t);
+	}
+
+	/* Issue Soft Reset to put firmware in unknown state */
+	qla4xxx_soft_reset(ha);
+
+	/* Remove timer thread, if present */
+	if (ha->timer_active)
+		qla4xxx_stop_timer(ha);
+
+	/* free extra memory */
+	qla4xxx_mem_free(ha);
+
+	/* Detach interrupts */
+	if (test_and_clear_bit(AF_IRQ_ATTACHED, &ha->flags))
+		free_irq(ha->pdev->irq, ha);
+
+	pci_disable_device(ha->pdev);
+
+}
+
+/**************************************************************************
+ * qla4xxx_iospace_config
+ *    This routine
+ *
+ * Input:
+ *
+ * Returns:
+ **************************************************************************/
+static int
+qla4xxx_iospace_config(scsi_qla_host_t * ha)
+{
+	unsigned long pio, pio_len, pio_flags;
+	unsigned long mmio, mmio_len, mmio_flags;
+
+	pio = pci_resource_start(ha->pdev, 0);
+	pio_len = pci_resource_len(ha->pdev, 0);
+	pio_flags = pci_resource_flags(ha->pdev, 0);
+	if (pio_flags & IORESOURCE_IO) {
+		if (pio_len < MIN_IOBASE_LEN) {
+			ql4_printk(KERN_WARNING, ha,
+			    "Invalid PCI I/O region size (%s)...\n",
+			    pci_name(ha->pdev));
+			pio = 0;
+		}
+	} else {
+		ql4_printk(KERN_WARNING, ha,
+		    "region #0 not a PIO resource (%s)...\n",
+		    pci_name(ha->pdev));
+		pio = 0;
+	}
+
+	/* Use MMIO operations for all accesses. */
+	mmio = pci_resource_start(ha->pdev, 1);
+	mmio_len = pci_resource_len(ha->pdev, 1);
+	mmio_flags = pci_resource_flags(ha->pdev, 1);
+
+	if (!(mmio_flags & IORESOURCE_MEM)) {
+		ql4_printk(KERN_ERR, ha,
+		    "region #0 not an MMIO resource (%s), aborting\n",
+		    pci_name(ha->pdev));
+		goto iospace_error_exit;
+	}
+	if (mmio_len < MIN_IOBASE_LEN) {
+		ql4_printk(KERN_ERR, ha,
+		    "Invalid PCI mem region size (%s), aborting\n",
+		    pci_name(ha->pdev));
+		goto iospace_error_exit;
+	}
+
+	if (pci_request_regions(ha->pdev, DRIVER_NAME)) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Failed to reserve PIO/MMIO regions (%s)\n",
+		    pci_name(ha->pdev));
+
+		goto iospace_error_exit;
+	}
+
+	ha->pio_address = pio;
+	ha->pio_length = pio_len;
+	ha->reg = ioremap(mmio, MIN_IOBASE_LEN);
+	if (!ha->reg) {
+		ql4_printk(KERN_ERR, ha,
+		    "cannot remap MMIO (%s), aborting\n", pci_name(ha->pdev));
+
+		goto iospace_error_exit;
+	}
+
+	return 0;
+
+iospace_error_exit:
+	return -ENOMEM;
+}
+
+/**
+ * qla4xxx_config_dma_addressing() - Configure OS DMA addressing method.
+ * @ha: HA context
+ *
+ * At exit, the @ha's flags.enable_64bit_addressing set to indicated
+ * supported addressing method.
+ */
+void
+qla4xxx_config_dma_addressing(scsi_qla_host_t * ha)
+{
+	int retval;
+
+	/* Update our PCI device dma_mask for full 64 bit mask */
+	if (pci_set_dma_mask(ha->pdev, DMA_64BIT_MASK) == 0) {
+		if (pci_set_consistent_dma_mask(ha->pdev, DMA_64BIT_MASK)) {
+			ql4_printk(KERN_DEBUG, ha,
+			    "Failed to set 64 bit PCI consistent mask; "
+			    "using 32 bit.\n");
+			retval = pci_set_consistent_dma_mask(ha->pdev, DMA_32BIT_MASK);
+		}
+	} else
+		retval = pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK);
+}
+
+/**************************************************************************
+ * qla4xxx_mem_alloc
+ *      This routine allocates memory use by the adapter.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully allocated adapter memory
+ *      QLA_ERROR   - Failed to allocate adapter memory
+ *
+ **************************************************************************/
+static int
+qla4xxx_mem_alloc(scsi_qla_host_t * ha)
+{
+	unsigned long align;
+
+	/* Allocate contiguous block of DMA memory for queues. */
+	ha->queues_len = ((REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE) + sizeof(shadow_regs_t) +
+	    MEM_ALIGN_VALUE + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
+	ha->queues = dma_alloc_coherent(&ha->pdev->dev, ha->queues_len,
+	    &ha->queues_dma, GFP_KERNEL);
+	if (ha->queues == NULL) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - queues.\n");
+
+		goto mem_alloc_error_exit;
+	}
+	memset(ha->queues, 0, ha->queues_len);
+
+	/*
+	 * As per RISC alignment requirements -- the bus-address must be a
+	 * multiple of the request-ring size (in bytes).
+	 */
+	align = 0;
+	if ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1))
+		align = MEM_ALIGN_VALUE -
+		    ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1));
+
+	/* Update request and response queue pointers. */
+	ha->request_dma = ha->queues_dma + align;
+	ha->request_ring = (QUEUE_ENTRY *) (ha->queues + align);
+	ha->response_dma = ha->queues_dma + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE);
+	ha->response_ring = (QUEUE_ENTRY *) (ha->queues + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE));
+	ha->shadow_regs_dma = ha->queues_dma + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE);
+	ha->shadow_regs = (shadow_regs_t *) (ha->queues + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE));
+
+	/* Allocate memory for srb pool. */
+	ha->srb_mempool = mempool_create(SRB_MIN_REQ, mempool_alloc_slab,
+	    mempool_free_slab, srb_cachep);
+	if (ha->srb_mempool == NULL) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - SRB Pool.\n");
+
+		goto mem_alloc_error_exit;
+	}
+
+	return QLA_SUCCESS;
+
+mem_alloc_error_exit:
+	qla4xxx_mem_free(ha);
+	return QLA_ERROR;
+}
+
+/**************************************************************************
+ * qla4xxx_mem_free
+ *      This routine frees adapter allocated memory
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ **************************************************************************/
+static void
+qla4xxx_mem_free(scsi_qla_host_t * ha)
+{
+	if (ha->queues)
+		dma_free_coherent(&ha->pdev->dev, ha->queues_len, ha->queues,
+		    ha->queues_dma);
+
+	ha->queues_len = 0;
+	ha->queues = NULL;
+	ha->queues_dma = 0;
+	ha->request_ring = NULL;
+	ha->request_dma = 0;
+	ha->response_ring = NULL;
+	ha->response_dma = 0;
+	ha->shadow_regs = NULL;
+	ha->shadow_regs_dma = 0;
+
+	/* Free srb pool. */
+	if (ha->srb_mempool)
+		mempool_destroy(ha->srb_mempool);
+
+	ha->srb_mempool = NULL;
+
+	/* Free ddb list. */
+	if (!list_empty(&ha->ddb_list))
+		qla4xxx_free_ddb_list(ha);
+
+	/* release io space registers  */
+	if (ha->reg)
+		iounmap(ha->reg);
+	pci_release_regions(ha->pdev);
+}
+
+static int
+qla4xxx_slave_alloc(struct scsi_device *sdev)
+{
+	struct ddb_entry *ddb;
+	scsi_qla_host_t *ha = to_qla_host(sdev->host);
+
+	ddb = qla4xxx_lookup_ddb_by_fw_index(ha, sdev->id);
+	if (!ddb)
+		return -ENXIO;
+
+	sdev->hostdata = ddb;
+	return 0;
+}
+
+static void
+qla4xxx_slave_destroy(struct scsi_device *sdev)
+{
+	sdev->hostdata = NULL;
+}
+
+static int
+qla4xxx_slave_configure(struct scsi_device *sdev)
+{
+	if (sdev->tagged_supported)
+		scsi_activate_tcq(sdev, 32);
+	else
+		scsi_deactivate_tcq(sdev, 32);
+
+	//iscsi_port
+
+	return 0;
+}
+
+/**************************************************************************
+ * del_from_active_array
+ *      This routine removes and returns the srb at the specified index
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      index - index into to the active_array
+ *
+ * Returns:
+ *      Pointer to corresponding SCSI Request Block
+ **************************************************************************/
+srb_t *
+del_from_active_array(scsi_qla_host_t * ha, uint32_t index)
+{
+	srb_t *srb = NULL;
+
+	/* validate handle and remove from active array */
+	if (index >= MAX_SRBS)
+		return srb;
+
+	srb = ha->active_srb_array[index];
+	ha->active_srb_array[index] = 0;
+	if (!srb)
+		return srb;
+
+	/* update counters */
+	if (srb->flags & SRB_DMA_VALID) {
+		ha->req_q_count += srb->iocb_cnt;
+		ha->iocb_cnt -= srb->iocb_cnt;
+		if (srb->cmd)
+			srb->cmd->host_scribble = NULL;
+	}
+	return srb;
+}
+
+/**************************************************************************
+ * qla4xxx_timer
+ *      This routine is scheduled to be invoked every second to search for
+ *      work to do.
+ *
+ * Input:
+ *      p - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ **************************************************************************/
+void
+qla4xxx_timer(scsi_qla_host_t *ha)
+{
+	ddb_entry_t *ddb_entry, *dtemp;
+	int start_dpc = 0;
+
+	/* Search for relogin's to time-out and port down retry. */
+	list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list) {
+		/*
+		 * First check to see if the device has exhausted the port
+		 * down retry count.
+		 */
+		if (atomic_read(&ddb_entry->state) == DDB_STATE_MISSING) {
+			if (atomic_read(&ddb_entry->port_down_timer) == 0)
+				continue;
+
+			if (atomic_dec_and_test(&ddb_entry->port_down_timer)) {
+				DEBUG2(printk("scsi%ld: %s: index [%d] port "
+				    "down retry count of (%d) secs exhausted, "
+				    "marking device DEAD.\n", ha->host_no,
+				    __func__, ddb_entry->fw_ddb_index,
+				    ha->port_down_retry_count));
+
+				    atomic_set(&ddb_entry->state,
+					DDB_STATE_DEAD);
+
+				DEBUG2(printk("scsi%ld: %s: index [%d] marked "
+				    "DEAD\n", ha->host_no, __func__,
+				    ddb_entry->fw_ddb_index));
+				start_dpc++;
+			}
+		}
+
+		/* Count down time between sending relogins */
+		if (ADAPTER_UP(ha) &&
+		    !test_bit(DF_RELOGIN, &ddb_entry->flags) &&
+		    atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE) {
+			if (atomic_read(&ddb_entry->retry_relogin_timer) !=
+			    INVALID_ENTRY) {
+				if (atomic_read(&ddb_entry->retry_relogin_timer)
+				    == 0) {
+					atomic_set(
+					    &ddb_entry->retry_relogin_timer,
+					    INVALID_ENTRY);
+					set_bit(DPC_RELOGIN_DEVICE,
+					    &ha->dpc_flags);
+					set_bit(DF_RELOGIN, &ddb_entry->flags);
+					DEBUG2(printk("scsi%ld: %s: index [%d] "
+					    "login device\n", ha->host_no,
+					    __func__, ddb_entry->fw_ddb_index));
+				} else
+					atomic_dec(
+					    &ddb_entry->retry_relogin_timer);
+			}
+		}
+
+		/* Wait for relogin to timeout */
+		if (atomic_read(&ddb_entry->relogin_timer) &&
+		    (atomic_dec_and_test(&ddb_entry->relogin_timer) != 0)) {
+			/*
+			 * If the relogin times out and the device is
+			 * still NOT ONLINE then try and relogin again.
+			 */
+			if (atomic_read(&ddb_entry->state) !=
+			    DDB_STATE_ONLINE &&
+			    ddb_entry->fw_ddb_device_state ==
+			    DDB_DS_SESSION_FAILED) {
+				/* Reset retry relogin timer */
+				atomic_inc(&ddb_entry->relogin_retry_count);
+				DEBUG2(printk("scsi%ld: index[%d] relogin "
+				    "timed out-retrying relogin (%d)\n",
+				    ha->host_no, ddb_entry->fw_ddb_index,
+				    atomic_read(
+					    &ddb_entry->relogin_retry_count)));
+				start_dpc++;
+				DEBUG(printk("scsi%ld:%d:%d: index [%d] "
+				    "initate relogin after %d seconds\n",
+				    ha->host_no, ddb_entry->bus,
+				    ddb_entry->target, ddb_entry->fw_ddb_index,
+				    ddb_entry->default_time2wait + 4));
+
+				atomic_set(&ddb_entry->retry_relogin_timer,
+				    ddb_entry->default_time2wait + 4);
+			}
+		}
+	}
+
+	/* Check for heartbeat interval. */
+	if (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE &&
+	    ha->heartbeat_interval != 0) {
+		ha->seconds_since_last_heartbeat++;
+		if (ha->seconds_since_last_heartbeat >
+		    ha->heartbeat_interval + 2)
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+	}
+
+
+	/* Wakeup the dpc routine for this adapter, if needed. */
+	if ((start_dpc ||
+	     test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
+	     test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||
+	     test_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||
+	     test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags) ||
+	     test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
+	     test_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags) ||
+	     test_bit(DPC_AEN, &ha->dpc_flags)) &&
+	    !test_bit(AF_DPC_SCHEDULED, &ha->flags) &&
+	     ha->dpc_thread) {
+		DEBUG2(printk("scsi%ld: %s: scheduling dpc routine - dpc flags "
+		    "= 0x%lx\n", ha->host_no, __func__, ha->dpc_flags));
+		set_bit(AF_DPC_SCHEDULED, &ha->flags);
+		wake_up_process(ha->dpc_thread);
+	}
+
+	/* Reschedule timer thread to call us back in one second */
+	mod_timer(&ha->timer, jiffies + HZ);
+
+	DEBUG2(ha->seconds_since_last_intr++;)
+}
+
+
+/**************************************************************************
+ * qla4xxx_do_dpc
+ *      This routine is a task that is schedule by the interrupt handler
+ *      to perform the background processing for interrupts.  We put it
+ *      on a task queue that is consumed whenever the scheduler runs; that's
+ *      so you can do anything (i.e. put the process to sleep etc).  In fact,
+ *      the mid-level tries to sleep when it reaches the driver threshold
+ *      "host->can_queue". This can cause a panic if we were in our interrupt
+ *      code.
+ *
+ * Input:
+ *      p - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ **************************************************************************/
+static int qla4xxx_do_dpc(void *data)
+{
+	scsi_qla_host_t *ha = (scsi_qla_host_t *) data;
+	ddb_entry_t *ddb_entry, *dtemp;
+
+	set_user_nice(current, -20);
+
+	while (!kthread_should_stop()) {
+		DEBUG2(printk("scsi%ld: %s: DPC handler sleeping.\n",
+		    ha->host_no, __func__));
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule();
+		__set_current_state(TASK_RUNNING);
+
+		DEBUG2(printk("scsi%ld: %s: DPC handler waking up.\n",
+		    ha->host_no, __func__));
+
+		DEBUG2(printk("scsi%ld: %s: ha->flags = 0x%08lx\n", ha->host_no,
+		    __func__, ha->flags));
+		DEBUG2(printk("scsi%ld: %s: ha->dpc_flags = 0x%08lx\n",
+		    ha->host_no, __func__, ha->dpc_flags));
+
+		/* Initialization not yet finished. Don't do anything yet. */
+		if (!test_bit(AF_INIT_DONE, &ha->flags))
+			continue;
+
+		ha->dpc_active = 1;
+		clear_bit(AF_DPC_SCHEDULED, &ha->flags);
+
+		if (ADAPTER_UP(ha) ||
+		    test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
+		    test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
+		    test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags)) {
+			if (test_bit(DPC_RESET_HA_DESTROY_DDB_LIST,
+			    &ha->dpc_flags))
+				/*
+				 * dg 09/23 Never initialize ddb list
+				 * once we up and running
+				 * qla4xxx_recover_adapter(ha,
+				 *    REBUILD_DDB_LIST);
+				 */
+				qla4xxx_recover_adapter(ha,
+				    PRESERVE_DDB_LIST);
+
+			if (test_bit(DPC_RESET_HA, &ha->dpc_flags))
+				qla4xxx_recover_adapter(ha,
+				    PRESERVE_DDB_LIST);
+
+			if (test_and_clear_bit(DPC_RESET_HA_INTR,
+			    &ha->dpc_flags)) {
+				uint8_t wait_time = RESET_INTR_TOV;
+				unsigned long flags = 0;
+
+				qla4xxx_flush_active_srbs(ha);
+
+				spin_lock_irqsave(&ha->hardware_lock,
+				    flags);
+				while ((RD_REG_DWORD(
+					&ha->reg->ctrl_status) &
+					(CSR_SOFT_RESET|
+					 CSR_FORCE_SOFT_RESET)) != 0) {
+					if (--wait_time == 0)
+						break;
+
+					spin_unlock_irqrestore(
+					    &ha->hardware_lock, flags);
+
+					msleep(1000);
+
+					spin_lock_irqsave(
+					    &ha->hardware_lock, flags);
+				}
+				spin_unlock_irqrestore(
+				    &ha->hardware_lock, flags);
+
+				if (wait_time == 0)
+					DEBUG2(printk(
+					    "scsi%ld: %s: SR|FSR bit "
+					    "not cleared-- resetting\n",
+					    ha->host_no, __func__));
+			}
+		}
+
+		/* ---- process AEN? --- */
+		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
+			qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
+
+		/* ---- Get DHCP IP Address? --- */
+		if (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))
+			qla4xxx_get_dhcp_ip_address(ha);
+
+		/* ---- relogin device? --- */
+		if (ADAPTER_UP(ha) &&
+		    test_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {
+			list_for_each_entry_safe(ddb_entry, dtemp,
+			    &ha->ddb_list, list) {
+				if (test_and_clear_bit(DF_RELOGIN,
+				    &ddb_entry->flags) &&
+				    atomic_read(&ddb_entry->state) !=
+				    DDB_STATE_ONLINE) {
+					qla4xxx_relogin_device(ha, ddb_entry);
+				}
+				/* If mbx cmd times out there is no point
+				 * in continuing further.
+				 * With large no of targets this can hang
+				 * the system.
+				 */		
+				if (test_bit(DPC_RESET_HA, &ha->dpc_flags)) {
+					printk(KERN_WARNING "scsi%ld: %s: "
+					       "need to reset hba\n",
+					       ha->host_no, __func__);
+					break;
+				}	
+			}
+		}
+
+		ha->dpc_active = 0;
+	}
+
+	/* Make sure that nobody tries to wake us up again. */
+	ha->dpc_active = 0;
+
+	return 0;
+}
+
+/**************************************************************************
+ * qla4010_soft_reset
+ *      This routine performs a SOFT RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ **************************************************************************/
+int
+qla4010_soft_reset(scsi_qla_host_t * ha)
+{
+	uint32_t max_wait_time;
+	unsigned long flags = 0;
+	int status = QLA_ERROR;
+	uint32_t ctrl_status;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/*
+	 * If the SCSI Reset Interrupt bit is set, clear it.
+	 * Otherwise, the Soft Reset won't work.
+	 */
+	ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if ((ctrl_status & CSR_SCSI_RESET_INTR) != 0)
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+			      SET_RMASK(CSR_SCSI_RESET_INTR));
+
+	/* Issue Soft Reset */
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SOFT_RESET));
+	PCI_POSTING(&ha->reg->ctrl_status);
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Wait until the Network Reset Intr bit is cleared */
+	max_wait_time = RESET_INTR_TOV;
+	do {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		if ((ctrl_status & CSR_NET_RESET_INTR) == 0)
+			break;
+
+		msleep(1000);
+	} while ((--max_wait_time));
+
+	if ((ctrl_status & CSR_NET_RESET_INTR) != 0) {
+		DEBUG2(printk(KERN_WARNING
+		    "scsi%ld: Network Reset Intr not cleared by Network "
+		    "function, clearing it now!\n", ha->host_no));
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+			      SET_RMASK(CSR_NET_RESET_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+
+	/* Wait until the firmware tells us the Soft Reset is done */
+	max_wait_time = SOFT_RESET_TOV;
+	do {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		if ((ctrl_status & CSR_SOFT_RESET) == 0) {
+			status = QLA_SUCCESS;
+			break;
+		}
+
+		msleep(1000);
+	} while ((--max_wait_time));
+
+	/*
+	 * Also, make sure that the SCSI Reset Interrupt bit has been cleared
+	 * after the soft reset has taken place.
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if ((ctrl_status & CSR_SCSI_RESET_INTR) != 0) {
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+			      SET_RMASK(CSR_SCSI_RESET_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* If soft reset fails then most probably the bios on other
+	 * function is also enabled.
+	 * Since the initialization is sequential the other fn
+	 * wont be able to acknowledge the soft reset.
+	 * Issue a force soft reset to workaround this scenario.
+	 */
+	if (max_wait_time == 0) {
+		/* Issue Force Soft Reset */
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+			      SET_RMASK(CSR_FORCE_SOFT_RESET));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		/* Wait until the firmware tells us the Soft Reset is done */
+		max_wait_time = SOFT_RESET_TOV;
+		do {
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+			if ((ctrl_status & CSR_FORCE_SOFT_RESET) == 0) {
+				status = QLA_SUCCESS;
+				break;
+			}
+
+			msleep(1000);
+		} while ((--max_wait_time));
+	}
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_topcat_reset
+ *      This routine performs a HARD RESET of the TopCat chip.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ **************************************************************************/
+int
+qla4xxx_topcat_reset(scsi_qla_host_t * ha)
+{
+	unsigned long flags;
+
+	QL4XXX_LOCK_NVRAM(ha);
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_DWORD(ISP_GP_OUT(ha), SET_RMASK(GPOR_TOPCAT_RESET));
+	PCI_POSTING(ISP_GP_OUT(ha));
+	do {
+		mdelay(1);
+	} while (0);
+	WRT_REG_DWORD(ISP_GP_OUT(ha), CLR_RMASK(GPOR_TOPCAT_RESET));
+	PCI_POSTING(ISP_GP_OUT(ha));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	do {
+		mdelay(2523);
+	} while (0);
+	QL4XXX_UNLOCK_NVRAM(ha);
+	return (QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_soft_reset
+ *      This routine performs a SOFT RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ **************************************************************************/
+int
+qla4xxx_soft_reset(scsi_qla_host_t * ha)
+{
+
+	DEBUG2(printk(KERN_WARNING "scsi%ld: %s: chip reset!\n", ha->host_no,
+	    __func__));
+	if (test_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags)) {
+		int status = QLA_ERROR;
+
+		if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+			if (qla4xxx_topcat_reset(ha) == QLA_SUCCESS) {
+				if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+					status = QLA_SUCCESS;
+				}
+			}
+		}
+		return (status);
+	} else
+		return qla4010_soft_reset(ha);
+}
+
+/**************************************************************************
+ * qla4xxx_hard_reset
+ *      This routine performs a HARD RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ **************************************************************************/
+int
+qla4xxx_hard_reset(scsi_qla_host_t * ha)
+{
+	/* The QLA4010 really doesn't have an equivalent to a hard reset */
+	qla4xxx_flush_active_srbs(ha);
+	if (test_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags)) {
+		int status = QLA_ERROR;
+
+		if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+			if (qla4xxx_topcat_reset(ha) == QLA_SUCCESS) {
+				if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+					status = QLA_SUCCESS;
+				}
+			}
+		}
+		return status;
+	} else
+		return qla4010_soft_reset(ha);
+}
+
+/**************************************************************************
+ * qla4xxx_cmd_wait
+ *      This routine stalls the driver until all outstanding commands are
+ *      returned.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *       Caller must release the Hardware Lock prior to calling this routine.
+ *
+ * Returns:
+ *      QLA_SUCCESS - All outstanding commands completed
+ *      QLA_ERROR   - All outstanding commands did not complete
+ **************************************************************************/
+static int
+qla4xxx_cmd_wait(scsi_qla_host_t * ha)
+{
+	uint32_t index = 0;
+	int stat = QLA_SUCCESS;
+	unsigned long flags;
+	int wait_cnt = WAIT_CMD_TOV;	/*
+					 * Initialized for 30 seconds as we
+					 * expect all commands to retuned
+					 * ASAP.
+					 */
+
+	while (wait_cnt) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		/* Find a command that hasn't completed. */
+		for (index = 1; index < MAX_SRBS; index++) {
+			if (ha->active_srb_array[index] != NULL)
+				break;
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		/* If No Commands are pending, wait is complete */
+		if (index == MAX_SRBS) {
+			break;
+		}
+
+		/* If we timed out on waiting for commands to come back
+		 * return ERROR.
+		 */
+		wait_cnt--;
+		if (wait_cnt == 0)
+			stat = QLA_ERROR;
+		else {
+			msleep(1000);
+		}
+	}			/* End of While (wait_cnt) */
+
+	return (stat);
+}
+
+/**************************************************************************
+ * qla4xxx_recover_adapter
+ *      This routine recovers that adapter from a fatal state.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      renew_ddb_list - Indicates what to do with the adapter's ddb list
+ *                      after adapter recovery has completed.
+ *                      0=preserve ddb list, 1=destroy and rebuild ddb list
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully recovered adapter
+ *      QLA_ERROR   - Failed to recover adapter
+ **************************************************************************/
+int
+qla4xxx_recover_adapter(scsi_qla_host_t * ha, uint8_t renew_ddb_list)
+{
+	int status = QLA_SUCCESS;
+
+	/* Stall incoming I/O until we are done */
+	clear_bit(AF_ONLINE, &ha->flags);
+	DEBUG2(printk("scsi%ld: %s calling qla4xxx_cmd_wait\n", ha->host_no,
+	    __func__));
+
+	/* Wait for outstanding commands to complete.
+	 * Stalls the driver for max 30 secs
+	 */
+	status = qla4xxx_cmd_wait(ha);
+
+	qla4xxx_disable_intrs(ha);
+
+	/* Flush any pending ddb changed AENs */
+	qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+
+	/* Reset the firmware.  If successful, function
+	 * returns with ISP interrupts enabled.
+	 */
+	if (status == QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s - Performing soft reset..\n",
+		    ha->host_no, __func__));
+		status = qla4xxx_soft_reset(ha);
+	}
+	/* FIXMEkaren: Do we want to keep interrupts enabled and process
+	   AENs after soft reset */
+
+	/* If firmware (SOFT) reset failed, or if all outstanding
+	 * commands have not returned, then do a HARD reset.
+	 */
+	if (status == QLA_ERROR) {
+		DEBUG2(printk("scsi%ld: %s - Performing hard reset..\n",
+		    ha->host_no, __func__));
+		status = qla4xxx_hard_reset(ha);
+	}
+
+	/* Flush any pending ddb changed AENs */
+	qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+
+	/* Re-initialize firmware. If successful, function returns
+	 * with ISP interrupts enabled */
+	if (status == QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s - Initializing adapter..\n",
+		    ha->host_no, __func__));
+
+		/* If successful, AF_ONLINE flag set in
+		 * qla4xxx_initialize_adapter */
+		status = qla4xxx_initialize_adapter(ha, renew_ddb_list);
+	}
+
+	/* Failed adapter initialization?
+	 * Retry reset_ha only if invoked via DPC (DPC_RESET_HA) */
+	if ((test_bit(AF_ONLINE, &ha->flags) == 0) &&
+	    (test_bit(DPC_RESET_HA, &ha->dpc_flags))) {
+		/* Adapter initialization failed, see if we can retry
+		 * resetting the ha */
+		if (!test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags)) {
+			ha->retry_reset_ha_cnt = MAX_RESET_HA_RETRIES;
+			DEBUG2(printk("scsi%ld: recover adapter - retrying "
+			    "(%d) more times\n", ha->host_no,
+			    ha->retry_reset_ha_cnt));
+			set_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+			status = QLA_ERROR;
+		} else {
+			if (ha->retry_reset_ha_cnt > 0) {
+				/* Schedule another Reset HA--DPC will retry */
+				ha->retry_reset_ha_cnt--;
+				DEBUG2(printk("scsi%ld: recover adapter - "
+				    "retry remaining %d\n", ha->host_no,
+				    ha->retry_reset_ha_cnt));
+				status = QLA_ERROR;
+			}
+
+			if (ha->retry_reset_ha_cnt == 0) {
+				/* Recover adapter retries have been exhausted.
+				 * Adapter DEAD */
+				DEBUG2(printk("scsi%ld: recover adapter "
+				    "failed - board disabled\n", ha->host_no));
+				qla4xxx_flush_active_srbs(ha);
+				clear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST,
+					  &ha->dpc_flags);
+				status = QLA_ERROR;
+			}
+		}
+	} else {
+		clear_bit(DPC_RESET_HA, &ha->dpc_flags);
+		clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags);
+		clear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+	}
+
+	ha->adapter_error_count++;
+
+	if (status == QLA_SUCCESS)
+		qla4xxx_enable_intrs(ha);
+
+	DEBUG2(printk("scsi%ld: recover adapter .. DONE\n", ha->host_no));
+	return (status);
+}
+
+
+/**************************************************************************
+ * qla4xxx_eh_wait_on_command
+ *      This routine waits for the command to be returned by the Firmware
+ *      for some max time.
+ *
+ * Input:
+ *    ha = actual ha whose done queue will contain the command
+ *            returned by firmware.
+ *    cmd = Scsi Command to wait on.
+ *
+ * Returns:
+ *    Not Found : 0
+ *    Found : 1
+ **************************************************************************/
+static int
+qla4xxx_eh_wait_on_command(scsi_qla_host_t * ha, struct scsi_cmnd *cmd)
+{
+	int done = 0;
+	srb_t *rp;
+	uint32_t max_wait_time = EH_WAIT_CMD_TOV;
+
+	do {
+		/* Checking to see if its returned to OS */
+		rp = (srb_t *) CMD_SP(cmd);
+		if (rp == NULL) {
+			done++;
+			break;
+		}
+
+		msleep(2000);
+	} while (max_wait_time--);
+
+	return done;
+}
+
+/**************************************************************************
+ * qla4xxx_wait_for_hba_online
+ *      This routine
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Remarks:
+ *
+ * Returns:
+ *      SUCCESS - Adapter is ONLINE
+ *      FAILED  - Adapter is DEAD
+ **************************************************************************/
+int qla4xxx_wait_for_hba_online(scsi_qla_host_t * ha)
+{
+	unsigned long wait_online;
+
+	wait_online = jiffies + (30 * HZ);
+	while (time_before(jiffies, wait_online)) {
+		if (ADAPTER_UP(ha))
+			return QLA_SUCCESS;
+
+		if (!ADAPTER_UP(ha) && (ha->retry_reset_ha_cnt == 0)) {
+			return QLA_ERROR;
+		}
+		msleep(2000);
+	}
+
+	return QLA_ERROR;
+}
+
+/**************************************************************************
+ * qla4xxx_eh_abort
+ *      This routine aborts commands that currently held in the adapter's
+ *      internal queues.  Commands that are active are NOT aborted.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Remarks:
+ *      Aborts get translated to "device resets" by the scsi switch
+ *      which will return a RESET status and not ABORT. Since the
+ *      mid-level is expecting an ABORT status during an abort(),
+ *      we always elevate to device reset.
+ *
+ * Returns:
+ *      SUCCESS - Successfully aborted non-active command
+ *      FAILED  - Command not found, or command currently active
+ **************************************************************************/
+static int
+qla4xxx_eh_abort(struct scsi_cmnd *cmd)
+{
+	if (!CMD_SP(cmd))
+		return FAILED;
+
+	/*
+	 * Aborts get translated to "device resets" by some scsi switches which
+	 * will return a RESET status and not ABORT. Since the mid-level is
+	 * expecting an ABORT status during an abort(), we always elevate to
+	 * device reset.
+	 */
+	return FAILED;
+}
+
+/**************************************************************************
+ * qla4xxx_eh_wait_for_active_target_commands
+ *      This routine
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      target - SCSI target ID
+ *
+ * Returns:
+ *      0 - All pending commands returned
+ *      non-zero - All pending commands did not return
+ **************************************************************************/
+int
+qla4xxx_eh_wait_for_active_target_commands(scsi_qla_host_t * ha, int t, int l)
+{
+	int cnt;
+	int status;
+	srb_t *sp;
+	struct scsi_cmnd *cmd;
+
+	/*
+	 * Waiting for all commands for the designated target in the active
+	 * array
+	 */
+	status = 0;
+	for (cnt = 1; cnt < MAX_SRBS; cnt++) {
+		spin_lock(&ha->hardware_lock);
+		sp = ha->active_srb_array[cnt];
+		if (sp) {
+			cmd = sp->cmd;
+			spin_unlock(&ha->hardware_lock);
+			if (cmd->device->id == t && cmd->device->lun == l) {
+				if (!qla4xxx_eh_wait_on_command(ha, cmd)) {
+					status++;
+					break;
+				}
+			}
+		} else {
+			spin_unlock(&ha->hardware_lock);
+		}
+	}
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_eh_device_reset
+ *      This routine is called by the Linux OS to reset all luns on the
+ * 	specified target.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Output:
+ *      None
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      SUCCESS - Successfully reset target/lun
+ *      FAILED  - Failed to reset target/lun
+ **************************************************************************/
+static int
+qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)
+{
+	scsi_qla_host_t *ha = to_qla_host(cmd->device->host);
+	struct ddb_entry *ddb_entry = (struct ddb_entry *)cmd->device->hostdata;
+	srb_t *sp;
+	int ret = FAILED, stat;
+
+	sp = (srb_t *) CMD_SP(cmd);
+	if (!sp || !ddb_entry)
+		return ret;
+
+	ql4_printk(KERN_INFO, ha,
+	    "scsi%ld:%d:%d:%d: DEVICE RESET ISSUED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	DEBUG2(printk(KERN_INFO
+	    "scsi%ld: DEVICE_RESET cmd=%p jiffies = 0x%lx, timeout=%x, "
+	    "dpc_flags=%lx, status=%x allowed=%d\n", ha->host_no,
+	    cmd, jiffies, cmd->timeout_per_command / HZ, ha->dpc_flags,
+	    cmd->result, cmd->allowed));
+
+	/* FIXme: wait for hba to go online */
+	stat = qla4xxx_reset_lun(ha, ddb_entry, cmd->device->lun);
+	if (stat != QLA_SUCCESS) {
+		ql4_printk(KERN_INFO, ha, "DEVICE RESET FAILED. %d\n", stat);
+
+		goto eh_dev_reset_done;
+	}
+
+	/* Send marker. */
+	ha->marker_needed = 1;
+
+	/*
+	 * If we are coming down the EH path, wait for all commands to complete
+	 * for the device.
+	 */
+	if (cmd->device->host->shost_state == SHOST_RECOVERY) {
+		if (qla4xxx_eh_wait_for_active_target_commands(ha,
+		    cmd->device->id, cmd->device->lun)) {
+			ql4_printk(KERN_INFO, ha,
+			    "DEVICE RESET FAILED - waiting for commands.\n");
+			goto eh_dev_reset_done;
+		}
+	}
+
+	ql4_printk(KERN_INFO, ha,
+	    "scsi(%ld:%d:%d:%d): DEVICE RESET SUCCEEDED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	ret = SUCCESS;
+
+eh_dev_reset_done:
+
+	return ret;
+}
+
+/**************************************************************************
+ * qla4xxx_eh_bus_reset
+ *      This routine is called by the Linux OS to reset the specified
+ *      adapter/bus.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Returns:
+ *      SUCCESS - Successfully reset adapter/bus
+ *      FAILED  - Failed to reset adapter/bus
+ *
+ **************************************************************************/
+static int
+qla4xxx_eh_bus_reset(struct scsi_cmnd *cmd)
+{
+	int status = QLA_SUCCESS;
+	int return_status = FAILED;
+	scsi_qla_host_t *ha = to_qla_host(cmd->device->host);
+	struct ddb_entry *ddb_entry = (struct ddb_entry *)cmd->device->hostdata;
+	ddb_entry_t *dtemp;
+
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	ql4_printk(KERN_INFO, ha,
+	    "scsi(%ld:%d:%d:%d): BUS RESET ISSUED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld:%d: %s: Unable to reset bus.  Adapter "
+		    "DEAD.\n", ha->host_no, cmd->device->channel, __func__));
+
+		return FAILED;
+	}
+
+	/* Attempt to reset all valid targets with outstanding commands */
+	list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list) {
+		/* Issue a reset */
+		status |= qla4xxx_reset_target(ha, ddb_entry);
+	}
+
+	/*
+	 * Status is QLA_SUCCESS if target resets for ALL devices completed
+	 * successfully.  Otherwise the status is QLA_ERROR.
+	 */
+	if (status == QLA_SUCCESS)
+		return_status = SUCCESS;
+
+	ql4_printk(KERN_INFO, ha, "BUS RESET %s.\n",
+	    return_status == FAILED ? "FAILED" : "SUCCEDED");
+
+	return return_status;
+}
+
+/**************************************************************************
+ * qla4xxx_reset_target
+ *      This routine issues either a warm or cold target reset to the
+ *      specified device.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      ddb_entry - Pointer to device database entry
+ *
+ * Remarks:
+ *      The caller must ensure that the ddb_entry pointer is valid before
+ *      calling this routine.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset target
+ *      QLA_ERROR   - Failed to reset target
+ **************************************************************************/
+int
+qla4xxx_reset_target(scsi_qla_host_t * ha, ddb_entry_t * ddb_entry)
+{
+	int status = QLA_SUCCESS;
+#if 0
+	uint8_t stat;
+
+	/* Reset all LUNs on this target */
+	list_for_each_entry(fclun, &fcport->fcluns, list) {
+		stat = qla4xxx_reset_lun(ha, ddb_entry, fclun);
+		if (stat == QLA_SUCCESS) {
+			/* Send marker. */
+			ha->marker_needed = 1;
+
+			/*
+			 * Waiting for all active commands to complete for the
+			 * device.
+			 */
+			status |=
+			    qla4xxx_eh_wait_for_active_target_commands(ha,
+								       ddb_entry->
+								       target,
+								       fclun->
+								       lun);
+		} else {
+			status |= QLA_ERROR;
+		}
+	}
+#endif
+
+	if (status == QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld:%d: device reset SUCCEEDED.\n",
+		    ha->host_no, ddb_entry->os_target_id));
+	} else {
+		DEBUG2(printk("scsi%ld:%d: device reset FAILED.\n",
+		    ha->host_no, ddb_entry->os_target_id));
+
+		status = QLA_ERROR;
+	}
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_flush_active_srbs
+ *      This routine is called just prior to a HARD RESET to return all
+ *      outstanding commands back to the Operating System.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *      Caller should make sure that the following locks are released
+ *      before this calling routine:
+ *              Hardware lock, and io_request_lock.
+ *
+ * Returns:
+ *      None
+ **************************************************************************/
+static void
+qla4xxx_flush_active_srbs(scsi_qla_host_t * ha)
+{
+	srb_t *srb;
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (i = 1; i < MAX_SRBS; i++) {
+		if ((srb = ha->active_srb_array[i]) != NULL) {
+			del_from_active_array(ha, i);
+			srb->cmd->result = DID_RESET << 16;
+			qla4xxx_srb_compl(ha, srb);
+		}
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+}
+
+/**************************************************************************
+ * qla4xxx_eh_host_reset
+ *      This routine is invoked by the Linux kernel to perform fatal error
+ *      recovery on the specified adapter.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Returns:
+ *      SUCCESS - Successfully recovered host adapter
+ *      FAILED  - Failed to recover host adapter
+ **************************************************************************/
+static int
+qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)
+{
+	int return_status = FAILED;
+	scsi_qla_host_t *ha;
+
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	ql4_printk(KERN_INFO, ha,
+	    "scsi(%ld:%d:%d:%d): ADAPTER RESET ISSUED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld:%d: %s: Unable to reset host.  Adapter "
+		    "DEAD.\n", ha->host_no, cmd->device->channel, __func__));
+
+		return FAILED;
+	}
+
+	if (qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST) == QLA_SUCCESS) {
+		return_status = SUCCESS;
+	}
+
+	ql4_printk(KERN_INFO, ha, "HOST RESET %s.\n",
+	    return_status == FAILED ? "FAILED" : "SUCCEDED");
+
+	return return_status;
+}
+
+
+static struct pci_device_id qla4xxx_pci_tbl[] = {
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP4010,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP4022,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+	},
+	{0, 0},
+};
+MODULE_DEVICE_TABLE(pci, qla4xxx_pci_tbl);
+
+struct pci_driver qla4xxx_pci_driver = {
+	.name		= DRIVER_NAME,
+	.id_table	= qla4xxx_pci_tbl,
+	.probe		= qla4xxx_probe_adapter,
+	.remove		= qla4xxx_remove_adapter,
+};
+
+static int __init
+qla4xxx_module_init(void)
+{
+	int ret;
+
+	/* Allocate cache for SRBs. */
+	srb_cachep = kmem_cache_create("qla4xxx_srbs", sizeof(srb_t), 0,
+	    SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (srb_cachep == NULL) {
+		printk(KERN_ERR
+		    "qla4xxx: Unable to allocate SRB cache...Failing load!\n");
+		return -ENOMEM;
+	}
+
+	/* Derive version string. */
+	strcpy(qla4xxx_version_str, QLA4XXX_DRIVER_VERSION);
+	if (extended_error_logging)
+		strcat(qla4xxx_version_str, "-debug");
+
+	qla4xxx_transport_template =
+		iscsi_register_transport(&qla4xxx_iscsi_transport_functions);
+	if (!qla4xxx_transport_template)
+		return -ENODEV;
+
+	printk(KERN_INFO "QLogic iSCSI HBA Driver\n");
+	ret = pci_module_init(&qla4xxx_pci_driver);
+	if (ret) {
+		kmem_cache_destroy(srb_cachep);
+		iscsi_unregister_transport(&qla4xxx_iscsi_transport_functions);
+	}
+
+	return ret;
+}
+
+static void __exit
+qla4xxx_module_exit(void)
+{
+	pci_unregister_driver(&qla4xxx_pci_driver);
+	kmem_cache_destroy(srb_cachep);
+	iscsi_unregister_transport(&qla4xxx_iscsi_transport_functions);
+}
+
+module_init(qla4xxx_module_init);
+module_exit(qla4xxx_module_exit);
+
+MODULE_AUTHOR("QLogic Corporation");
+MODULE_DESCRIPTION("QLogic iSCSI HBA Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(QLA4XXX_DRIVER_VERSION);
diff --git a/drivers/scsi/qla4xxx/ql4_settings.h b/drivers/scsi/qla4xxx/ql4_settings.h
new file mode 100644
index 0000000..94a51db
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_settings.h
@@ -0,0 +1,11 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+/*
+ * Compile time Options:
+ *     0 - Disable and 1 - Enable
+ */
diff --git a/drivers/scsi/qla4xxx/ql4_version.h b/drivers/scsi/qla4xxx/ql4_version.h
new file mode 100644
index 0000000..c9326b4
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_version.h
@@ -0,0 +1,13 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#define QLA4XXX_DRIVER_VERSION      "5.00.05b5-k"
+
+#define QL4_DRIVER_MAJOR_VER	5
+#define QL4_DRIVER_MINOR_VER	0
+#define QL4_DRIVER_PATCH_VER	5
+#define QL4_DRIVER_BETA_VER	5
