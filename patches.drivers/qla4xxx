From: david.wagner@enigma.qlogic.com
Subject: add qlogic qla4xxx driver version v5.00.01b10
Patch-mainline: No
References: none

add qlogic qla4xxx driver version v5.00.01b10

Acked-by: mantel@suse.de

diff -urNp linux-2.6.5/drivers/scsi/Kconfig linux-2.6.5.SUSE/drivers/scsi/Kconfig
--- linux-2.6.5/drivers/scsi/Kconfig	2004-11-02 14:46:01.499703104 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/Kconfig	2004-11-02 14:51:15.310996536 +0100
@@ -1280,6 +1280,8 @@ config SCSI_QLOGICPTI
 
 source "drivers/scsi/qla2xxx/Kconfig"
 
+source "drivers/scsi/qla4xxx/Kconfig"
+
 config SCSI_SEAGATE
 	tristate "Seagate ST-02 and Future Domain TMC-8xx SCSI support"
 	depends on X86 && ISA && SCSI && BROKEN
diff -urNp linux-2.6.5/drivers/scsi/Makefile linux-2.6.5.SUSE/drivers/scsi/Makefile
--- linux-2.6.5/drivers/scsi/Makefile	2004-11-02 14:46:00.565845072 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/Makefile	2004-11-02 14:50:55.981935000 +0100
@@ -80,6 +80,7 @@ obj-$(CONFIG_SCSI_QLOGIC_ISP)	+= qlogici
 obj-$(CONFIG_SCSI_QLOGIC_FC)	+= qlogicfc.o 
 obj-$(CONFIG_SCSI_QLOGIC_1280)	+= qla1280.o 
 obj-$(CONFIG_SCSI_QLA2XXX)	+= qla2xxx/
+obj-$(CONFIG_SCSI_QLA4XXX)	+= qla4xxx/
 obj-$(CONFIG_SCSI_PAS16)	+= pas16.o
 obj-$(CONFIG_SCSI_SEAGATE)	+= seagate.o
 obj-$(CONFIG_SCSI_FD_8xx)	+= seagate.o
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/Kconfig linux-2.6.5.SUSE/drivers/scsi/qla4xxx/Kconfig
--- linux-2.6.5/drivers/scsi/qla4xxx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/Kconfig	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,14 @@
+config SCSI_QLA4XXX
+	tristate "QLogic ISP4XXX host adapter family support"
+        depends on PCI && SCSI
+	---help---
+	This driver supports the QLogic 40xx (ISP4XXX) host adapter family.
+
+config SCSI_QLA4XXX_FAILOVER
+	bool "QLogic ISP4xxx Driver-level Failover support"
+	depends on SCSI_QLA4XXX
+	---help---
+	Compile the driver with failover support.  Please review the driver
+	documentation for further information on supported hosts and storage
+	types.
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/Makefile linux-2.6.5.SUSE/drivers/scsi/qla4xxx/Makefile
--- linux-2.6.5/drivers/scsi/qla4xxx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/Makefile	2004-11-02 14:49:25.174739792 +0100
@@ -0,0 +1,13 @@
+EXTRA_CFLAGS += -DCONFIG_SCSI_QLA4XXX -DCONFIG_SCSI_QLA4XXX_MODULE
+
+EXTRA_CFLAGS += -DCONFIG_SCSI_QLA4XXX_FAILOVER
+
+qla4xxx-y = ql4_os.o ql4_init.o ql4_mbx.o ql4_iocb.o ql4_isr.o ql4_isns.o \
+		ql4_nvram.o ql4_dbg.o
+
+qla4xxx-$(CONFIG_SCSI_QLA4XXX_FAILOVER) += ql4_cfg.o ql4_cfgln.o ql4_fo.o \
+		ql4_foio.o ql4_foioctl.o ql4_foln.o ql4_xioct.o ql4_inioct.o \
+		ql4_32ioctl.o
+#		ql4_foio.o ql4_foln.o
+
+obj-$(CONFIG_SCSI_QLA4XXX) += qla4xxx.o
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_32ioctl.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_32ioctl.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_32ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_32ioctl.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,168 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+#include <linux/config.h>
+#include "ql4_def.h"
+
+#if defined QLA_CONFIG_COMPAT
+
+#include <linux/file.h>
+
+
+/* fs/ioctl.c */
+extern asmlinkage long sys_ioctl(unsigned int fd, unsigned int cmd, void *);
+
+extern int register_ioctl32_conversion(unsigned int cmd,
+    int (*handler)(unsigned int, unsigned int, unsigned long, struct file *));
+extern int unregister_ioctl32_conversion(unsigned int cmd);
+
+
+int
+qla4xxx_ioctl32(unsigned int fd, unsigned int cmd, unsigned long arg,
+    struct file *pfile)
+{
+	return (sys_ioctl(fd, cmd, (void *)arg));
+}
+
+inline int
+apidev_reg_increasing_idx(uint16_t low_idx, uint16_t high_idx)
+{
+	int	err = 0;
+	int	i;
+	unsigned int cmd;
+
+	for (i = low_idx; i <= high_idx; i++) {
+		cmd = (unsigned int)QL_IOCTL_CMD(i);
+		err = register_ioctl32_conversion(cmd, qla4xxx_ioctl32);
+		if (err) {
+			QL4PRINT(QLP2|QLP4,
+			    printk(
+			    "%s: error registering cmd %x. err=%d.\n",
+			    __func__, cmd, err));
+
+			break;
+		}
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: registered cmd %x.\n", __func__, cmd));
+	}
+
+	return (err);
+}
+
+inline int
+apidev_unreg_increasing_idx(uint16_t low_idx, uint16_t high_idx)
+{
+	int	err = 0;
+	int	i;
+	unsigned int cmd;
+
+	for (i = low_idx; i <= high_idx; i++) {
+		cmd = (unsigned int)QL_IOCTL_CMD(i);
+		err = unregister_ioctl32_conversion(cmd);
+		if (err) {
+			QL4PRINT(QLP2|QLP4,
+			    printk(
+			    "%s: error unregistering cmd %x. err=%d.\n",
+			    __func__, cmd, err));
+			break;
+		}
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: unregistered cmd %x.\n", __func__, cmd));
+	}
+
+	return (err);
+}
+
+inline void
+ql4_apidev_init_32ioctl(void)
+{
+	int	err;
+
+	ENTER(__func__);
+
+	QL4PRINT(QLP2|QLP4,
+	    printk("%s: going to register ioctl32 cmds.\n",
+	    __func__));
+
+	/* regular external ioctl codes */
+	err = apidev_reg_increasing_idx(EXT_DEF_REG_CC_START_IDX,
+	    EXT_DEF_REG_CC_END_IDX);
+	if (!err) {
+		/* regular internal ioctl codes */
+		err = apidev_reg_increasing_idx(EXT_DEF_INT_CC_START_IDX,
+		    EXT_DEF_INT_CC_END_IDX);
+	}
+	if (!err) {
+		/* LN Drvr specific codes are defined in decreasing order */
+		err = apidev_reg_increasing_idx(EXT_DEF_DRV_SPC_CC_END_IDX,
+		    EXT_DEF_DRV_SPC_CC_START_IDX);
+	}
+	if (!err) {
+		/* QL NFO specific codes */
+		err = apidev_reg_increasing_idx(EXT_DEF_NFO_CC_START_IDX,
+		    EXT_DEF_NFO_CC_END_IDX);
+	}
+	if (err) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: register failed.\n",
+		    __func__));
+	}
+
+	LEAVE(__func__);
+}
+
+inline void
+ql4_apidev_cleanup_32ioctl(void)
+{
+	int	err;
+
+	ENTER(__func__);
+
+	QL4PRINT(QLP2|QLP4,
+	    printk("%s: going to unregister ioctl32 cmds.\n",
+	    __func__));
+
+	/* regular external ioctl codes */
+	err = apidev_unreg_increasing_idx(EXT_DEF_REG_CC_START_IDX,
+	    EXT_DEF_REG_CC_END_IDX);
+	if (!err) {
+		/* regular internal ioctl codes */
+		err = apidev_unreg_increasing_idx(EXT_DEF_INT_CC_START_IDX,
+		    EXT_DEF_INT_CC_END_IDX);
+	}
+	if (!err) {
+		/* LN Drvr specific codes are defined in decreasing order */
+		err = apidev_unreg_increasing_idx(EXT_DEF_DRV_SPC_CC_END_IDX,
+		    EXT_DEF_DRV_SPC_CC_START_IDX);
+	}
+	if (!err) {
+		/* QL FO specific codes */
+		err = apidev_unreg_increasing_idx(EXT_DEF_NFO_CC_START_IDX,
+		    EXT_DEF_NFO_CC_END_IDX);
+	}
+
+	if (err) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: unregister failed.\n",
+		    __func__));
+	}
+
+	LEAVE(__func__);
+}
+
+#endif /* QLA_CONFIG_COMPAT */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_32ioctl.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_32ioctl.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_32ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_32ioctl.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,28 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+#ifndef _QL4_32IOCTL_H_
+#define _QL4_32IOCTL_H_
+
+extern void
+ql4_apidev_init_32ioctl(void);
+
+extern inline void
+ql4_apidev_cleanup_32ioctl(void);
+
+#endif /* _QL4_32IOCTL_H_ */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_cfg.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_cfg.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_cfg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_cfg.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,3541 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2003-2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/*
+ * QLogic ISP4xxx Multi-path LUN Support Driver
+ *
+ */
+
+#include "ql4_def.h"
+#include "ql4_cfg.h"
+
+#include "qlfo.h"
+#include "qlfolimits.h"
+/*
+#include "ql4_foln.h"
+*/
+#include "ql4_glbl.h"
+
+/*
+ *  Local Function Prototypes.
+ */
+
+static uint32_t qla4xxx_add_iscsiname_to_mp_dev(mp_device_t *, uint8_t *, uint8_t *);
+
+static mp_device_t * qla4xxx_allocate_mp_dev(uint8_t *, uint8_t *);
+static mp_path_t * qla4xxx_allocate_path(mp_host_t *, uint16_t, fc_port_t *,
+    uint16_t);
+static mp_path_list_t * qla4xxx_allocate_path_list(void);
+
+static mp_host_t * qla4xxx_find_host_by_iscsiname(uint8_t *);
+
+static mp_path_t * qla4xxx_find_or_allocate_path(mp_host_t *, mp_device_t *,
+    uint16_t, uint16_t, fc_port_t *);
+
+static uint32_t qla4xxx_cfg_register_failover_lun(mp_device_t *,srb_t *,
+    fc_lun_t *);
+static uint32_t qla4xxx_send_failover_notify(mp_device_t *, uint8_t,
+    mp_path_t *, mp_path_t *);
+static mp_path_t * qla4xxx_select_next_path(mp_host_t *, mp_device_t *,
+    uint8_t, srb_t *);
+
+static uint8_t qla4xxx_update_mp_host(mp_host_t  *);
+static uint32_t qla4xxx_update_mp_tree (void);
+
+static fc_lun_t *qla4xxx_find_matching_lun(uint8_t , mp_device_t *, mp_path_t *);
+static mp_path_t *qla4xxx_find_path_by_id(mp_device_t *, uint8_t);
+static mp_device_t *qla4xxx_find_mp_dev_by_iscsiname(mp_host_t *, uint8_t *,
+    uint16_t *);
+
+static mp_path_t *qla4xxx_get_visible_path(mp_device_t *dp);
+static void qla4xxx_map_os_targets(mp_host_t *);
+static void qla4xxx_map_os_luns(mp_host_t *, mp_device_t *, uint16_t);
+static uint8_t qla4xxx_map_a_oslun(mp_host_t *, mp_device_t *, uint16_t, uint16_t);
+
+static uint8_t qla4xxx_is_name_zero(uint8_t *);
+static void qla4xxx_add_path(mp_path_list_t *, mp_path_t *);
+static void qla4xxx_failback_single_lun(mp_device_t *, uint8_t, uint8_t);
+static void qla4xxx_failback_luns(mp_host_t *);
+static void qla4xxx_setup_new_path(mp_device_t *, mp_path_t *, fc_port_t *);
+int  qla4xxx_get_wwuln_from_device(mp_host_t *, fc_lun_t *, char	*, int);
+static mp_lun_t  * qla4xxx_find_matching_lunid(char	*);
+static fc_lun_t  * qla4xxx_find_matching_lun_by_num(uint16_t , mp_device_t *,
+	mp_path_t *);
+static int qla4xxx_configure_cfg_device(fc_port_t	*);
+static mp_lun_t *
+qla4xxx_find_or_allocate_lun(mp_host_t *, uint16_t ,
+    fc_port_t *, fc_lun_t *);
+static void qla4xxx_add_lun( mp_device_t *, mp_lun_t *);
+static mp_port_t	*
+qla4xxx_find_or_allocate_port(mp_host_t *, mp_lun_t *, 
+	mp_path_t *);
+static mp_port_t	*
+qla4xxx_find_port_by_name(mp_lun_t *, mp_path_t *);
+static struct _mp_path *
+qla4xxx_find_first_active_path(mp_device_t *, mp_lun_t *);
+#if 0
+static int
+qla4xxx_is_pathid_in_port(mp_port_t *, uint8_t );
+#endif
+
+static mp_device_t  *
+qla4xxx_find_mp_dev_by_id(mp_host_t *host, uint16_t id );
+
+#define qla4xxx_is_name_equal(N1,N2) \
+	((memcmp((N1),(N2),ISCSI_NAME_SIZE)==0?1:0))
+/*
+ * Global data items
+ */
+mp_host_t  *mp_hosts_base = NULL;
+DECLARE_MUTEX(mp_hosts_lock);
+int   mp_config_required = 0;
+static int mp_num_hosts;
+static int mp_initialized;
+
+/*
+ * ENTRY ROUTINES
+ */
+
+ /*
+ *  Borrowed from scsi_scan.c 
+ */
+int16_t
+qla4xxx_cfg_lookup_device(unsigned char *response_data)
+{
+	int i = 0;
+	unsigned char *pnt;
+	DEBUG3(printk(KERN_INFO "Entering %s\n", __func__);)
+	for (i = 0; 1; i++) {
+		if (cfg_device_list[i].vendor == NULL)
+			return -1;
+		pnt = &response_data[8];
+		while (*pnt && *pnt == ' ')
+			pnt++;
+		if (memcmp(cfg_device_list[i].vendor, pnt,
+		    strlen(cfg_device_list[i].vendor)))
+			continue;
+		pnt = &response_data[16];
+		while (*pnt && *pnt == ' ')
+			pnt++;
+		if (memcmp(cfg_device_list[i].model, pnt,
+		    strlen(cfg_device_list[i].model)))
+			continue;
+		return i;
+	}
+	return -1;
+}
+
+
+void
+qla4xxx_set_device_flags(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	if (fcport->cfg_id == -1)
+		return;
+
+	fcport->flags &= ~(FCF_XP_DEVICE|FCF_MSA_DEVICE|FCF_EVA_DEVICE);
+	if ((cfg_device_list[fcport->cfg_id].flags & 1)) {
+		printk(KERN_INFO
+		    "scsi(%d) :Loop id 0x%04x is an XP device\n", ha->host_no,
+		    fcport->loop_id);
+		fcport->flags |= FCF_XP_DEVICE;
+	} else if ((cfg_device_list[fcport->cfg_id].flags & 2)) {
+		printk(KERN_INFO
+		    "scsi(%d) :Loop id 0x%04x is a MSA1000 device\n",
+		    ha->host_no, fcport->loop_id);
+		fcport->flags |= FCF_MSA_DEVICE;
+		fcport->flags |= FCF_FAILBACK_DISABLE;
+	} else if ((cfg_device_list[fcport->cfg_id].flags & 4)) {
+		printk(KERN_INFO
+		    "scsi(%d) :Loop id 0x%04x is a EVA device\n", ha->host_no,
+		    fcport->loop_id);
+		fcport->flags |= FCF_EVA_DEVICE;
+		fcport->flags |= FCF_FAILBACK_DISABLE;
+	} 
+	if ((cfg_device_list[fcport->cfg_id].flags & 8)) {
+		printk(KERN_INFO
+		    "scsi(%d) :Loop id 0x%04x has FAILOVERS disabled.\n",
+		    ha->host_no, fcport->loop_id);
+		fcport->flags |= FCF_FAILOVER_DISABLE;
+	}
+}
+
+
+static int
+qla4xxx_configure_cfg_device(fc_port_t *fcport)
+{
+	int id = fcport->cfg_id;
+
+	DEBUG3(printk("Entering %s - id= %d\n", __func__, fcport->cfg_id));
+
+	if (fcport->cfg_id == -1)
+		return 0;
+
+	/* Set any notify options */
+	if (cfg_device_list[id].notify_type != FO_NOTIFY_TYPE_NONE) {
+		fcport->notify_type = cfg_device_list[id].notify_type;
+	}   
+
+	DEBUG2(printk("%s - Configuring device \n", __func__)); 
+
+	/* Disable failover capability if needed  and return */
+	fcport->fo_combine = cfg_device_list[id].fo_combine;
+	DEBUG2(printk("Exiting %s - id= %d\n", __func__, fcport->cfg_id));
+
+	return 1;
+}
+
+/*
+ * qla4xxx_cfg_init
+ *      Initialize configuration structures to handle an instance of
+ *      an HBA, QLA4xxx0 card.
+ *
+ * Input:
+ *      ha = adapter state pointer.
+ *
+ * Returns:
+ *      qla4xxx local function return status code.
+ *
+ * Context:
+ *      Kernel context.
+ */
+int
+qla4xxx_cfg_init(scsi_qla_host_t *ha)
+{
+	int	rval;
+
+	ENTER("qla4xxx_cfg_init");
+	set_bit(CFG_ACTIVE, &ha->cfg_flags);
+	mp_initialized = 1; 
+	/* First HBA, initialize the failover global properties */
+	qla4xxx_fo_init_params(ha);
+
+        down(&mp_hosts_lock);
+	/*
+	 * If the user specified a device configuration then it is use as the
+	 * configuration. Otherwise, we wait for path discovery.
+	 */
+	if (mp_config_required)
+		qla4xxx_cfg_build_path_tree(ha);
+	rval = qla4xxx_cfg_path_discovery(ha);
+        up(&mp_hosts_lock);
+	clear_bit(CFG_ACTIVE, &ha->cfg_flags);
+
+	LEAVE("qla4xxx_cfg_init");
+	return rval;
+}
+
+/*
+ * qla4xxx_cfg_path_discovery
+ *      Discover the path configuration from the device configuration
+ *      for the specified host adapter and build the path search tree.
+ *      This function is called after the lower level driver has
+ *      completed its port and lun discovery.
+ *
+ * Input:
+ *      ha = adapter state pointer.
+ *
+ * Returns:
+ *      qla4xxx local function return status code.
+ *
+ * Context:
+ *      Kernel context.
+ */
+int
+qla4xxx_cfg_path_discovery(scsi_qla_host_t *ha)
+{
+	int		rval = QLA_SUCCESS;
+	mp_host_t	*host;
+	uint8_t		*name;
+
+	ENTER("qla4xxx_cfg_path_discovery");
+
+	name = 	&ha->name_string[0];
+
+	set_bit(CFG_ACTIVE, &ha->cfg_flags);
+	/* Initialize the path tree for this adapter */
+	host = qla4xxx_find_host_by_iscsiname(name);
+	if (mp_config_required) {
+		if (host == NULL ) {
+			DEBUG4(printk("cfg_path_discovery: host not found, "
+				"port name = "
+				"%02x%02x%02x%02x%02x%02x%02x%02x\n",
+				name[0], name[1], name[2], name[3],
+				name[4], name[5], name[6], name[7]);)
+			rval = QLA_ERROR;
+		} else if (ha->instance != host->instance) {
+			DEBUG4(printk("cfg_path_discovery: host instance "
+				"don't match - instance=%ld.\n",
+				ha->instance);)
+			rval = QLA_ERROR;
+		}
+	} else if (host == NULL) {
+		/* New host adapter so allocate it */
+		DEBUG3(printk("%s: found new ha inst %ld. alloc host.\n",
+		    __func__, ha->instance);)
+		if ( (host = qla4xxx_alloc_host(ha)) == NULL ) {
+			printk(KERN_INFO
+				"qla4xxx(%d): Couldn't allocate "
+				"host - ha = %p.\n",
+				(int)ha->instance, ha);
+			rval = QLA_ERROR;
+		}
+	}
+
+	/* Fill in information about host */
+	if (host != NULL ) {
+		host->flags |= MP_HOST_FLAG_NEEDS_UPDATE;
+		host->flags |= MP_HOST_FLAG_LUN_FO_ENABLED;
+		host->fcports = &ha->fcports;
+
+		/* Check if multipath is enabled */
+		DEBUG3(printk("%s: updating mp host for ha inst %ld.\n",
+		    __func__, ha->instance);)
+		if (!qla4xxx_update_mp_host(host)) {
+			rval = QLA_ERROR;
+		}
+		host->flags &= ~MP_HOST_FLAG_LUN_FO_ENABLED;
+	}
+
+	if (rval != QLA_SUCCESS) {
+		/* EMPTY */
+		DEBUG4(printk("qla4xxx_path_discovery: Exiting FAILED\n");)
+	} else {
+		LEAVE("qla4xxx_cfg_path_discovery");
+	}
+	clear_bit(CFG_ACTIVE, &ha->cfg_flags);
+
+	return rval;
+}
+
+/*
+ * qla4xxx_cfg_event_notifiy
+ *      Callback for host driver to notify us of configuration changes.
+ *
+ * Input:
+ *      ha = adapter state pointer.
+ *      i_type = event type
+ *
+ * Returns:
+ *
+ * Context:
+ *      Kernel context.
+ */
+int
+qla4xxx_cfg_event_notify(scsi_qla_host_t *ha, uint32_t i_type)
+{
+	mp_host_t	*host;			/* host adapter pointer */
+
+	ENTER("qla4xxx_cfg_event_notify");
+
+	set_bit(CFG_ACTIVE, &ha->cfg_flags);
+	switch (i_type) {
+		case MP_NOTIFY_RESET_DETECTED:
+			DEBUG(printk("scsi%ld: MP_NOTIFY_RESET_DETECTED "
+					"- no action\n",
+					ha->host_no);)
+				break;
+		case MP_NOTIFY_PWR_LOSS:
+			DEBUG(printk("scsi%ld: MP_NOTIFY_PWR_LOSS - "
+					"update tree\n",
+					ha->host_no);)
+			/*
+			 * Update our path tree in case we are
+			 * losing the adapter
+			 */
+			down(&mp_hosts_lock);
+			qla4xxx_update_mp_tree();
+			up(&mp_hosts_lock);
+			/* Free our resources for adapter */
+			break;
+		case MP_NOTIFY_LOOP_UP:
+			DEBUG(printk("scsi%ld: MP_NOTIFY_LOOP_UP - "
+					"update host tree\n",
+					ha->host_no);)
+			/* Adapter is back up with new configuration */
+			if ((host = qla4xxx_cfg_find_host(ha)) != NULL) {
+				host->flags |= MP_HOST_FLAG_NEEDS_UPDATE;
+				host->fcports = &ha->fcports;
+				set_bit(CFG_FAILOVER, &ha->cfg_flags);
+				down(&mp_hosts_lock);
+				qla4xxx_update_mp_tree();
+				up(&mp_hosts_lock);
+				clear_bit(CFG_FAILOVER, &ha->cfg_flags);
+			}
+			break;
+		case MP_NOTIFY_LOOP_DOWN:
+		case MP_NOTIFY_BUS_RESET:
+			DEBUG(printk("scsi%ld: MP_NOTIFY_OTHERS - "
+					"no action\n",
+					ha->host_no);)
+			break;
+		default:
+			break;
+
+	}
+	clear_bit(CFG_ACTIVE, &ha->cfg_flags);
+
+	LEAVE("qla4xxx_cfg_event_notify");
+
+	return QLA_SUCCESS;
+}
+
+int
+qla4xxx_cfg_remap(scsi_qla_host_t *halist)
+{
+	scsi_qla_host_t *ha;
+
+	mp_initialized = 1; 
+	read_lock(&qla4xxx_hostlist_lock);
+	list_for_each_entry(ha, &qla4xxx_hostlist, list) {
+		DEBUG2(printk("Entering %s ...\n",__func__);)
+		/* Find the host that was specified */
+		set_bit(CFG_FAILOVER, &ha->cfg_flags);
+		qla4xxx_cfg_path_discovery(ha);
+		clear_bit(CFG_FAILOVER, &ha->cfg_flags);
+	}
+	read_unlock(&qla4xxx_hostlist_lock);
+	mp_initialized = 0; 
+	DEBUG2(printk("Exiting %s ...\n",__func__);)
+
+	return QLA_SUCCESS;
+}
+
+/*
+ *  qla4xxx_allocate_mp_port
+ *      Allocate an fc_mp_port, clear the memory, and log a system
+ *      error if the allocation fails. After fc_mp_port is allocated
+ *
+ */
+static mp_port_t *
+qla4xxx_allocate_mp_port(uint8_t *iscsiname)
+{
+	mp_port_t   *port;
+	int	i;
+
+	DEBUG3(printk("%s: entered.\n", __func__);)
+
+	port = kmalloc(sizeof(mp_port_t), GFP_KERNEL);
+	if (!port)
+		return NULL;
+	memset(port, 0, sizeof(*port));
+
+	DEBUG(printk("%s: mp_port_t allocated at %p\n",
+		    __func__, port);)
+
+	/*
+	 * Since this is the first port, it goes at
+	 * index zero.
+	 */
+	if (iscsiname)
+	{
+		DEBUG3(printk("%s: copying port name =%s\n",
+		    __func__, iscsiname);)
+		memcpy(&port->iscsiname[0], iscsiname, ISCSI_NAME_SIZE);
+	}
+	for ( i = 0 ;i <  MAX_HOSTS; i++ ) {
+		port->path_list[i] = PATH_INDEX_INVALID;
+	}
+	port->fo_cnt = 0;
+		
+
+	DEBUG3(printk("%s: exiting.\n", __func__);)
+
+	return port;
+}
+
+static mp_port_t	*
+qla4xxx_find_port_by_name(mp_lun_t *mplun, 
+	mp_path_t *path)
+{
+	mp_port_t	*port = NULL;
+	mp_port_t	*temp_port;
+	struct list_head *list, *temp;
+
+	list_for_each_safe(list, temp, &mplun->ports_list) {
+		temp_port = list_entry(list, mp_port_t, list);
+		if ( memcmp(temp_port->iscsiname, path->iscsiname, ISCSI_NAME_SIZE) == 0 ) {
+			port = temp_port;
+			break;
+		}
+	}
+	return port;
+}
+
+
+static mp_port_t	*
+qla4xxx_find_or_allocate_port(mp_host_t *host, mp_lun_t *mplun, 
+	mp_path_t *path)
+{
+	mp_port_t	*port = NULL;
+	struct list_head *list, *temp;
+	unsigned long	instance = host->instance;
+
+	if( instance == MAX_HOSTS - 1) {
+		printk(KERN_INFO "%s: Fail no room\n", __func__);
+		return NULL;
+	}
+
+	if ( mplun == NULL ) {
+		return NULL;
+	}
+
+	list_for_each_safe(list, temp, &mplun->ports_list) {
+		port = list_entry(list, mp_port_t, list);
+		if ( memcmp(port->iscsiname, path->iscsiname, ISCSI_NAME_SIZE) == 0 ) {
+			if ( port->path_list[instance] == PATH_INDEX_INVALID ) {
+			   DEBUG(printk("scsi%ld %s: Found matching mp port %02x%02x%02x"
+			    "%02x%02x%02x%02x%02x.\n",
+			    instance, __func__, port->iscsiname[0], port->iscsiname[1],
+			    port->iscsiname[2], port->iscsiname[3], 
+			    port->iscsiname[4], port->iscsiname[5], 
+			    port->iscsiname[6], port->iscsiname[7]);)
+				port->path_list[instance] = path->id;
+				port->hba_list[instance] = host->ha;
+				port->cnt++;
+				DEBUG(printk("%s: adding iscsiname - port[%d] = "
+			    "%p at index = %d with path id %d\n",
+			    __func__, (int)instance ,port, 
+				(int)instance, path->id);)
+			}
+			return port;
+		}
+	}
+	port = qla4xxx_allocate_mp_port(path->iscsiname);
+	if( port ) {
+		port->cnt++;
+		DEBUG(printk("%s: allocate and adding iscsiname - port[%d] = "
+			    "%p at index = %d with path id %d\n",
+			    __func__, (int)instance, port, 
+				(int)instance, path->id);)
+		port->path_list[instance] = path->id;
+		port->hba_list[instance] = host->ha;
+		/* add port to list */
+		list_add_tail(&port->list,&mplun->ports_list );
+	}
+	return port;
+}
+
+
+/*
+ * qla4xxx_cfg_failover_port
+ *      Failover all the luns on the specified target to 
+ *		the new path.
+ *
+ * Inputs:
+ *      ha = pointer to host adapter
+ *      fp - pointer to new fc_lun (failover lun)
+ *      tgt - pointer to target
+ *
+ * Returns:
+ *      
+ */
+static fc_lun_t *
+qla4xxx_cfg_failover_port( mp_host_t *host, mp_device_t *dp,
+	mp_path_t *new_path, fc_port_t *old_fcport, srb_t *sp)
+{
+#if 0
+	uint8_t		l;
+	fc_port_t	*fcport;
+	fc_lun_t	*fclun;
+	fc_lun_t	*new_fclun = NULL;
+	os_lun_t 	 *up;
+	mp_path_t	*vis_path;
+	mp_host_t 	*vis_host;
+
+	fcport = new_path->port;
+#if MSA1000_SUPPORTED
+	if( !qla4xxx_test_active_port(fcport) )  {
+		DEBUG2(printk("%s(%ld): %s - port not ACTIVE "
+		"to failover: port = %p, loop id= 0x%x\n",
+		__func__,
+		host->ha->host_no, __func__, fcport, fcport->loop_id);)
+		return new_fclun;
+	}
+#endif
+
+	/* Log the failover to console */
+	printk(KERN_INFO
+		"qla4xxx%d: FAILOVER all LUNS on device %d to WWPN "
+		"%02x%02x%02x%02x%02x%02x%02x%02x -> "
+		"%02x%02x%02x%02x%02x%02x%02x%02x, reason=0x%x\n",
+		(int) host->instance,
+		(int) dp->dev_id,
+		old_fcport->iscsi_name[0], old_fcport->iscsi_name[1],
+		old_fcport->iscsi_name[2], old_fcport->iscsi_name[3],
+		old_fcport->iscsi_name[4], old_fcport->iscsi_name[5],
+		old_fcport->iscsi_name[6], old_fcport->iscsi_name[7],
+		fcport->iscsi_name[0], fcport->iscsi_name[1],
+		fcport->iscsi_name[2], fcport->iscsi_name[3],
+		fcport->iscsi_name[4], fcport->iscsi_name[5],
+		fcport->iscsi_name[6], fcport->iscsi_name[7], sp->err_id );
+		 printk(KERN_INFO
+		"qla4xxx: FROM HBA %d to HBA %d\n",
+		(int)old_fcport->ha->instance,
+		(int)fcport->ha->instance);
+
+	/* we failover all the luns on this port */
+	list_for_each_entry(fclun, &fcport->fcluns, list) {
+		l = fclun->lun;
+		if( (fclun->flags & FLF_VISIBLE_LUN) ) {  
+			continue;
+		}
+		dp->path_list->current_path[l] = new_path->id;
+		if ((vis_path =
+		    qla4xxx_get_visible_path(dp)) == NULL ) {
+			printk(KERN_INFO
+		    "qla4xxx(%d): No visible "
+			    "path for target %d, "
+			    "dp = %p\n",
+			    (int)host->instance,
+		    dp->dev_id, dp);
+		    continue;
+		}
+
+		vis_host = vis_path->host;
+		up = (os_lun_t *) GET_LU_Q(vis_host->ha, 
+		    dp->dev_id, l);
+		if (up == NULL ) {
+		DEBUG2(printk("%s: instance %d: No lun queue"
+		    "for target %d, lun %d.. \n",
+			__func__,(int)vis_host->instance,dp->dev_id,l);)
+			continue;
+		}
+
+		up->fclun = fclun;
+		fclun->fcport->cur_path = new_path->id;
+
+		DEBUG2(printk("%s: instance %d: Mapping target %d:0x%x,"
+		    "lun %d to path id %d\n",
+			__func__,(int)vis_host->instance,dp->dev_id,
+			fclun->fcport->loop_id, l,
+		    fclun->fcport->cur_path);)
+
+			/* issue reset to data luns only */
+			if( fclun->device_type == TYPE_DISK) {
+				new_fclun = fclun;
+				/* send a reset lun command as well */
+			printk(KERN_INFO 
+			    "scsi(%ld:0x%x:%d) sending reset lun \n",
+					fcport->ha->host_no,
+					fcport->loop_id, l);
+				qla4xxx_reset_lun(fcport->ha,
+		  			fcport->ddbptr,
+		  			fclun);
+			}
+		}
+	return new_fclun;
+#else
+	return 0;
+#endif
+}
+
+/*
+ * qla4xxx_cfg_failover
+ *      A problem has been detected with the current path for this
+ *      lun.  Select the next available path as the current path
+ *      for this device.
+ *
+ * Inputs:
+ *      ha = pointer to host adapter
+ *      fp - pointer to failed fc_lun (failback lun)
+ *      tgt - pointer to target
+ *
+ * Returns:
+ *      pointer to new fc_lun_t, or NULL if failover fails.
+ */
+fc_lun_t *
+qla4xxx_cfg_failover(scsi_qla_host_t *ha, fc_lun_t *fp,
+    os_tgt_t *tgt, srb_t *sp)
+{
+	mp_host_t	*host;			/* host adapter pointer */
+	mp_device_t	*dp;			/* virtual device pointer */
+	mp_path_t	*new_path;		/* new path pointer */
+	fc_lun_t	*new_fp = NULL;
+	fc_port_t	*fcport, *new_fcport;
+
+	ENTER("qla4xxx_cfg_failover");
+	DEBUG2(printk("%s entered\n",__func__);)
+
+	set_bit(CFG_ACTIVE, &ha->cfg_flags);
+	if ((host = qla4xxx_cfg_find_host(ha)) != NULL) {
+		if ((dp = qla4xxx_find_mp_dev_by_id(
+		    host, tgt->id)) != NULL ) {
+
+			DEBUG3(printk("qla4xxx_cfg_failover: dp = %p\n", dp);)
+			/*
+			 * Point at the next path in the path list if there is
+			 * one, and if it hasn't already been failed over by
+			 * another I/O. If there is only one path continuer
+			 * to point at it.
+			 */
+			new_path = qla4xxx_select_next_path(host, dp, 
+				fp->lun, sp);
+			if( new_path == NULL )
+				goto cfg_failover_done;
+			new_fp = qla4xxx_find_matching_lun(fp->lun, 
+					dp, new_path);
+			if( new_fp == NULL )
+				goto cfg_failover_done;
+			DEBUG2(printk("cfg_failover: new path=%p, new pathid=%d"
+					" new fp lun= %p\n",
+				new_path, new_path->id, new_fp);)
+
+			fcport = fp->fcport;
+			if( (fcport->flags & FCF_MSA_DEVICE) ) {
+				/* 
+				 * "select next path" has already 
+				 * send out the switch path notify 
+				 * command, so inactive old path 
+				 */
+       				fcport->flags &= ~(FCF_MSA_PORT_ACTIVE);
+				if( qla4xxx_cfg_failover_port( host, dp, 
+						new_path, fcport, sp) == NULL ) {
+					printk(KERN_INFO
+						"scsi(%d): Fail to failover device "
+						" - fcport = %p\n",
+						host->ha->host_no, fcport);
+					goto cfg_failover_done;
+				}
+			} else if( (fcport->flags & FCF_EVA_DEVICE) ) { 
+				new_fcport = new_path->port;
+				if ( qla4xxx_test_active_lun( 
+					new_fcport, new_fp ) ) {
+					qla4xxx_cfg_register_failover_lun(dp, 
+						sp, new_fp);
+				 	 /* send a reset lun command as well */
+				 	 printk(KERN_INFO 
+			    	 	 "scsi(%d:0x%x:%d) sending"
+					 "reset lun \n",
+					 new_fcport->ha->host_no,
+					 new_fcport->loop_id, new_fp->lun);
+					 qla4xxx_reset_lun(new_fcport->ha,
+		  				 new_fcport->ddbptr,
+		  				 new_fp);
+				} else {
+					DEBUG2(printk(
+						"scsi(%d): %s Fail to failover lun "
+						"old fclun= %p, new fclun= %p\n",
+						host->ha->host_no,
+						 __func__,fp, new_fp);)
+					goto cfg_failover_done;
+				}
+			} else { /*default */
+				new_fp = qla4xxx_find_matching_lun(fp->lun, dp,
+				    new_path);
+				qla4xxx_cfg_register_failover_lun(dp, sp,
+				    new_fp);
+			}
+
+		} else {
+			printk(KERN_INFO
+				"qla4xxx(%d): Couldn't find device "
+				"to failover: dp = %p\n",
+				host->instance, dp);
+		}
+	}
+
+cfg_failover_done:
+	clear_bit(CFG_ACTIVE, &ha->cfg_flags);
+
+	LEAVE("qla4xxx_cfg_failover");
+
+	return new_fp;
+}
+
+/*
+ * IOCTL support -- moved to ql4_foioctl.c
+ */
+
+/*
+ * MP SUPPORT ROUTINES
+ */
+
+/*
+ * qla4xxx_add_mp_host
+ *	Add the specified host the host list.
+ *
+ * Input:
+ *	node_name = pointer to node name
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ */
+mp_host_t *
+qla4xxx_add_mp_host(uint8_t *iscsi_name)
+{
+	mp_host_t   *host, *temp;
+
+	host = kmalloc(sizeof(mp_host_t), GFP_KERNEL);
+	if (!host)
+		return NULL;
+	memset(host, 0, sizeof(*host));
+	memcpy(host->iscsiname, iscsi_name, ISCSI_NAME_SIZE);
+	host->next = NULL;
+
+	/* add to list */
+	if (mp_hosts_base == NULL) {
+		mp_hosts_base = host;
+	} else {
+		temp = mp_hosts_base;
+		while (temp->next != NULL)
+			temp = temp->next;
+		temp->next = host;
+	}
+
+	mp_num_hosts++;
+	return host;
+}
+
+/*
+ * qla4xxx_alloc_host
+ *      Allocate and initialize an mp host structure.
+ *
+ * Input:
+ *      ha = pointer to base driver's adapter structure.
+ *
+ * Returns:
+ *      Pointer to host structure or null on error.
+ *
+ * Context:
+ *      Kernel context.
+ */
+mp_host_t   *
+qla4xxx_alloc_host(scsi_qla_host_t *ha)
+{
+	mp_host_t	*host, *temp;
+	uint8_t		*name;
+
+	name = &ha->name_string[0];
+
+	ENTER("qla4xxx_alloc_host");
+
+	host = kmalloc(sizeof(mp_host_t), GFP_KERNEL);
+	if (!host)
+		return NULL;
+
+	memset(host, 0, sizeof(*host));
+	host->ha = ha;
+	memcpy(host->iscsiname, name, ISCSI_NAME_SIZE);
+	host->next = NULL;
+	host->flags = MP_HOST_FLAG_NEEDS_UPDATE;
+	host->instance = ha->instance;
+
+	if (qla4xxx_fo_enabled(host->ha, host->instance)) {
+		host->flags |= MP_HOST_FLAG_FO_ENABLED;
+		DEBUG4(printk("%s: Failover enabled.\n",
+		    __func__);)
+	} else {
+		/* EMPTY */
+		DEBUG4(printk("%s: Failover disabled.\n",
+		    __func__);)
+	}
+	/* add to list */
+	if (mp_hosts_base == NULL) {
+		mp_hosts_base = host;
+	} else {
+		temp = mp_hosts_base;
+		while (temp->next != NULL)
+			temp = temp->next;
+		temp->next = host;
+	}
+	mp_num_hosts++;
+
+	DEBUG4(printk("%s: Alloc host @ %p\n", __func__, host);)
+	return host;
+}
+
+/*
+ * qla4xxx_add_iscsiname_to_mp_dev
+ *      Add the specific port name to the list of port names for a
+ *      multi-path device.
+ *
+ * Input:
+ *      dp = pointer ti virtual device
+ *      iscsiname = Port name to add to device
+ *      nodename = Node name to add to device
+ *
+ * Returns:
+ *      qla4xxx local function return status code.
+ *
+ * Context:
+ *      Kernel context.
+ */
+static uint32_t
+qla4xxx_add_iscsiname_to_mp_dev(mp_device_t *dp, uint8_t *iscsiname, uint8_t *nodename)
+{
+	uint16_t	index;
+	uint32_t	rval = QLA_SUCCESS;
+
+	ENTER("qla4xxx_add_iscsiname_to_mp_dev");
+
+	/* Look for an empty slot and add the specified iscsiname.   */
+	for (index = 0; index < MAX_NUMBER_PATHS; index++) {
+		if (qla4xxx_is_name_zero(&dp->iscsinames[index][0])) {
+			DEBUG4(printk("%s: adding iscsiname to dp = "
+			    "%p at index = %d\n",
+			    __func__, dp, index);)
+			memcpy(&dp->iscsinames[index][0], iscsiname, ISCSI_NAME_SIZE);
+			break;
+		}
+	}
+	if (index == MAX_NUMBER_PATHS) {
+		rval = QLA_ERROR;
+		DEBUG4(printk("%s: Fail no room\n", __func__);)
+	} else {
+		/* EMPTY */
+		DEBUG4(printk("%s: Exit OK\n", __func__);)
+	}
+
+	LEAVE("qla4xxx_add_iscsiname_to_mp_dev");
+
+	return rval;
+}
+
+
+/*
+ *  qla4xxx_allocate_mp_dev
+ *      Allocate an fc_mp_dev, clear the memory, and log a system
+ *      error if the allocation fails. After fc_mp_dev is allocated
+ *
+ *  Inputs:
+ *      nodename  = pointer to nodename of new device
+ *      iscsiname  = pointer to iscsiname of new device
+ *
+ *  Returns:
+ *      Pointer to new mp_device_t, or NULL if the allocation fails.
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_device_t *
+qla4xxx_allocate_mp_dev(uint8_t  *devname, uint8_t *iscsiname)
+{
+	mp_device_t   *dp;            /* Virtual device pointer */
+
+	ENTER("qla4xxx_allocate_mp_dev");
+	DEBUG3(printk("%s: entered.\n", __func__);)
+
+	dp = kmalloc(sizeof(mp_device_t), GFP_KERNEL);
+	if (!dp) {
+		DEBUG4(printk("%s: Allocate failed.\n", __func__);)
+		return NULL;
+	}
+	memset(dp, 0, sizeof(*dp));
+
+	DEBUG3(printk("%s: mp_device_t allocated at %p\n", __func__, dp);)
+
+	/*
+	 * Copy node name into the mp_device_t.
+	 */
+	if (devname) {
+		DEBUG2(printk("%s: copying dev name={%s} \n",
+		    __func__, devname);)
+		memcpy(dp->devname, devname, ISCSI_NAME_SIZE);
+	}
+
+	/*
+	 * Since this is the first port, it goes at
+	 * index zero.
+	 */
+	if (iscsiname)
+	{
+		DEBUG3(printk("%s: copying port name (%s) "
+		    ".\n",
+		    __func__, iscsiname); )
+		memcpy(&dp->iscsinames[0][0], iscsiname, ISCSI_NAME_SIZE);
+	}
+
+	/* Allocate an PATH_LIST for the fc_mp_dev. */
+	if ((dp->path_list = qla4xxx_allocate_path_list()) == NULL) {
+		DEBUG4(printk("%s: allocate path_list Failed.\n",
+		    __func__);)
+		kfree(dp);
+		dp = NULL;
+	} else {
+		DEBUG4(printk("%s: mp_path_list_t allocated at %p\n",
+		    __func__, dp->path_list);)
+		/* EMPTY */
+		DEBUG4(printk("qla4xxx_allocate_mp_dev: Exit Okay\n");)
+	}
+
+	DEBUG3(printk("%s: exiting.\n", __func__);)
+	LEAVE("qla4xxx_allocate_mp_dev");
+
+	return dp;
+}
+
+/*
+ *  qla4xxx_allocate_path
+ *      Allocate a PATH.
+ *
+ *  Inputs:
+ *     host   Host adapter for the device.
+ *     path_id  path number
+ *     port   port for device.
+ *      dev_id  device number
+ *
+ *  Returns:
+ *      Pointer to new PATH, or NULL if the allocation failed.
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_path_t *
+qla4xxx_allocate_path(mp_host_t *host, uint16_t path_id,
+    fc_port_t *port, uint16_t dev_id)
+{
+	mp_path_t	*path;
+	uint16_t	lun;
+
+	ENTER("qla4xxx_allocate_path");
+
+	path = kmalloc(sizeof(mp_path_t), GFP_KERNEL);
+	if (!path) {
+		DEBUG4(printk("%s: Failed\n", __func__);)
+		return 0;
+	}
+	memset(path, 0, sizeof(*path));
+
+	DEBUG3(printk("%s(%ld): allocated path %p at path id %d.\n",
+	    __func__, host->ha->host_no, path, path_id);)
+
+	/* Copy the supplied information into the MP_PATH.  */
+	path->host = host;
+
+	DEBUG3(printk("%s(%ld): assigned port pointer %p "
+		    "to path id %d.\n",
+	    __func__, host->ha->host_no, port, path_id);)
+	path->port = port;
+
+	path->id   = path_id;
+	port->cur_path = path->id;
+	path->mp_byte  = port->mp_byte;
+	path->next  = NULL;
+	memcpy(path->iscsiname, port->iscsi_name, ISCSI_NAME_SIZE);
+
+	for (lun = 0; lun < MAX_LUNS; lun++) {
+		path->lun_data.data[lun] |= LUN_DATA_ENABLED;
+	}
+
+	return path;
+}
+
+
+/*
+ *  qla4xxx_allocate_path_list
+ *      Allocate a PATH_LIST
+ *
+ *  Input:
+ * 		None
+ *
+ *  Returns:
+ *      Pointer to new PATH_LIST, or NULL if the allocation fails.
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_path_list_t *
+qla4xxx_allocate_path_list( void )
+{
+	mp_path_list_t	*path_list;
+	uint16_t		i;
+	uint8_t			l;
+
+	path_list = kmalloc(sizeof(mp_path_list_t), GFP_KERNEL);
+	if (!path_list) {
+		DEBUG4(printk("%s: Alloc pool failed for MP_PATH_LIST.\n",
+		    __func__);)
+		return NULL;
+	}
+	memset(path_list, 0, sizeof(*path_list));
+
+	DEBUG4(printk("%s: allocated at %p\n", __func__, path_list);)
+
+	path_list->visible = PATH_INDEX_INVALID;
+	/* Initialized current path */
+	for (i = 0; i < MAX_LUNS_PER_DEVICE; i++) {
+		l = (uint8_t)(i & 0xFF);
+		path_list->current_path[l] = PATH_INDEX_INVALID;
+	}
+	path_list->last = NULL;
+
+	return path_list;
+}
+
+/*
+ *  qla4xxx_cfg_find_host
+ *      Look through the existing multipath tree, and find
+ *      a host adapter to match the specified ha.
+ *
+ *  Input:
+ *      ha = pointer to host adapter
+ *
+ *  Return:
+ *      Pointer to new host, or NULL if no match found.
+ *
+ * Context:
+ *      Kernel context.
+ */
+mp_host_t *
+qla4xxx_cfg_find_host(scsi_qla_host_t *ha)
+{
+	mp_host_t     *host = NULL;	/* Host found and null if not */
+	mp_host_t     *tmp_host;
+
+	ENTER("qla4xxx_cfg_find_host");
+
+	for (tmp_host = mp_hosts_base; (tmp_host); tmp_host = tmp_host->next) {
+		if (tmp_host->ha == ha) {
+			host = tmp_host;
+			DEBUG3(printk("%s: Found host =%p, instance %d\n",
+			    __func__, host, host->instance);)
+			break;
+		}
+	}
+
+	LEAVE("qla4xxx_cfg_find_host");
+
+	return host;
+}
+
+/*
+ *  qla4xxx_find_host_by_iscsiname
+ *      Look through the existing multipath tree, and find
+ *      a host adapter to match the specified iscsiname.
+ *
+ *  Input:
+ *      name = iscsiname to match.
+ *
+ *  Return:
+ *      Pointer to new host, or NULL if no match found.
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_host_t *
+qla4xxx_find_host_by_iscsiname(uint8_t *name)
+{
+	mp_host_t     *host;		/* Host found and null if not */
+
+	for (host = mp_hosts_base; (host); host = host->next) {
+		if (memcmp(host->iscsiname, name, ISCSI_NAME_SIZE) == 0)
+			break;
+	}
+	return host;
+}
+
+
+/*
+ * qla4xxx_find_matching_lunid
+ *      Find the lun in the lun list that matches the
+ *  specified wwu lun number.
+ *
+ * Input:
+ *      buf  = buffer that contains the wwuln
+ *      host = host to search for lun
+ *
+ * Returns:
+ *      NULL or pointer to lun
+ *
+ * Context:
+ *      Kernel context.
+ * (dg)
+ */
+static mp_lun_t  *
+qla4xxx_find_matching_lunid(char	*buf)
+{
+	int		devid = 0;
+	mp_host_t	*temp_host;  /* temporary pointer */
+	mp_device_t	*temp_dp;  /* temporary pointer */
+	mp_lun_t *lun;
+
+	ENTER(__func__);
+
+	for (temp_host = mp_hosts_base; (temp_host);
+	    temp_host = temp_host->next) {
+		for (devid = 0; devid < MAX_MP_DEVICES; devid++) {
+			temp_dp = temp_host->mp_devs[devid];
+
+			if (temp_dp == NULL)
+				continue;
+
+			for( lun = temp_dp->luns; lun != NULL ; 
+					lun = lun->next ) {
+
+				if (lun->siz > WWLUN_SIZE )
+					lun->siz = WWLUN_SIZE;
+
+				if (memcmp(lun->wwuln, buf, lun->siz) == 0)
+					return lun;
+			}
+		}
+	}
+	return NULL;
+
+}
+
+/*
+ *  qla4xxx_combine_by_lunid
+ *      Look through the existing multipath control tree, and find
+ *      an mp_lun_t with the supplied world-wide lun number.  If
+ *      one cannot be found, allocate one.
+ *
+ *  Input:
+ *      host      Adapter to add device to.
+ *      dev_id    Index of device on adapter.
+ *      port      port database information.
+ *
+ *  Returns:
+ *      Pointer to new mp_device_t, or NULL if the allocation fails.
+ *
+ *  Side Effects:
+ *      If the MP HOST does not already point to the mp_device_t,
+ *      a pointer is added at the proper port offset.
+ *
+ * Context:
+ *      Kernel context.
+ */
+int
+qla4xxx_combine_by_lunid( void *vhost, uint16_t dev_id, 
+	fc_port_t *fcport, uint16_t pathid) 
+{
+	mp_host_t	*host = (mp_host_t *) vhost; 
+	int fail = 0;
+	mp_path_t 	*path;
+	mp_device_t *dp = NULL;
+	fc_lun_t	*fclun;
+	mp_lun_t  *lun;
+	mp_port_t	*port;
+	int		l;
+
+	ENTER("qla4xxx_combine_by_lunid");
+	//printk("Entering %s\n", __func__); 
+
+	/* 
+	 * Currently mp_config_required is not process by this routine
+	 * because we create common nodename for the gui, so we can use 
+	 * the normal common namename processing.
+	 */
+#if MSA1000_SUPPORTED
+	if (mp_initialized && fcport->flags & FCF_MSA_DEVICE) {
+		 qla4xxx_test_active_port(fcport); 
+	}
+#endif
+	list_for_each_entry(fclun, &fcport->fcluns, list) {
+		lun = qla4xxx_find_or_allocate_lun(host, dev_id,
+		    fcport, fclun);
+
+		if (lun == NULL) {
+			fail++;
+			continue;
+		}
+		/*
+ 		* Find the path in the current path list, or allocate
+ 		* a new one and put it in the list if it doesn't exist.
+ 		*/
+		dp = lun->dp;
+		if (fclun->mplun == NULL )
+			fclun->mplun = lun; 
+		path = qla4xxx_find_or_allocate_path(host, dp,
+		    dp->dev_id, pathid, fcport);
+		if (path == NULL || dp == NULL) {
+			fail++;
+			continue;
+		}
+
+		/* set the lun active flag */
+		if (mp_initialized && fcport->flags & FCF_EVA_DEVICE) { 
+		     qla4xxx_test_active_lun( 
+			path->port, fclun );
+		}
+
+		/* Add fclun to path list */
+		if (lun->paths[path->id] == NULL) {
+			lun->paths[path->id] = fclun;
+			DEBUG2(printk("Updated path[%d]= %p for lun %p\n",
+				path->id, fclun, lun);)
+			lun->path_cnt++;
+		}
+			
+		/* 
+		 * if we have a visible lun then make
+		 * the target visible as well 
+		 */
+		l = lun->number;
+		if( (fclun->flags & FLF_VISIBLE_LUN)  ) {  
+			if (dp->path_list->visible ==
+			    PATH_INDEX_INVALID) {
+				dp->path_list->visible = path->id;
+				DEBUG2(printk("%s: dp %p setting "
+				    "visible id to %d\n",
+				    __func__,dp,path->id );)
+			}  
+			dp->path_list->current_path[l] = path->id;
+			path->lun_data.data[l] |=
+			    LUN_DATA_PREFERRED_PATH;
+
+			DEBUG2(printk("%s: Found a controller path 0x%x "
+			    "- lun %d\n", __func__, path->id,l);)
+		} else if (mp_initialized) {
+   			/*
+			 * Whenever a port or lun is "active" then
+			 * force it to be a preferred path.
+    			 */
+   			if (qla4xxx_find_first_active_path(dp, lun) 
+				== path ){
+   				dp->path_list->current_path[l] =
+				    path->id;
+				path->lun_data.data[l] |=
+				    LUN_DATA_PREFERRED_PATH;
+				DEBUG2(printk(
+				"%s: Found preferred lun at loopid=0x%02x, lun=%d, pathid=%d\n",
+	    			__func__, fcport->loop_id, l, path->id);)
+			}
+		}
+
+		/* if (port->flags & FCF_CONFIG)
+		path->config = 1;  */
+
+		port = qla4xxx_find_or_allocate_port(host, lun, path);
+		if (port == NULL) {
+			fail++;
+			continue;
+		}
+	}
+
+	if (fail)
+		return 0;		
+	return 1;		
+}
+	
+/*
+ *  qla4xxx_find_or_allocate_path
+ *      Look through the path list for the supplied device, and either
+ *      find the supplied adapter (path) for the adapter, or create
+ *      a new one and add it to the path list.
+ *
+ *  Input:
+ *      host      Adapter (path) for the device.
+ *      dp       Device and path list for the device.
+ *      dev_id    Index of device on adapter.
+ *      port     Device data from port database.
+ *
+ *  Returns:
+ *      Pointer to new PATH, or NULL if the allocation fails.
+ *
+ *  Side Effects:
+ *      1. If the PATH_LIST does not already point to the PATH,
+ *         a new PATH is added to the PATH_LIST.
+ *      2. If the new path is found to be a second visible path, it is
+ *         marked as hidden, and the device database is updated to be
+ *         hidden as well, to keep the miniport synchronized.
+ *
+ * Context:
+ *      Kernel context.
+ */
+/* ARGSUSED */
+static mp_path_t *
+qla4xxx_find_or_allocate_path(mp_host_t *host, mp_device_t *dp,
+    uint16_t dev_id, uint16_t pathid, fc_port_t *port)
+{
+	mp_path_list_t	*path_list = dp->path_list;
+	mp_path_t		*path;
+	uint8_t			id;
+
+
+	ENTER("qla4xxx_find_or_allocate_path");
+
+	DEBUG4(printk("%s: host =%p, port =%p, dp=%p, dev id = %d\n",
+	    __func__, host, port, dp, dev_id);)
+	/*
+	 * Loop through each known path in the path list.  Look for
+	 * a PATH that matches both the adapter and the port name.
+	 */
+	path = qla4xxx_find_path_by_name(host, path_list, port->iscsi_name);
+
+
+	if (path != NULL ) {
+		DEBUG3(printk("%s: Found an existing "
+		    "path %p-  host %p inst=%d, port =%p, path id = %d\n",
+		    __func__, path, host, host->instance, path->port,
+		    path->id);)
+		DEBUG3(printk("%s: Luns for path_id %d, instance %d\n",
+		    __func__, path->id, host->instance);)
+		DEBUG3(qla4xxx_dump_buffer(
+		    (char *)&path->lun_data.data[0], 64);)
+
+		/* If we found an existing path, look for any changes to it. */
+		if (path->port == NULL) {
+			DEBUG3(printk("%s: update path %p w/ port %p, path id="
+			    "%d, path mp_byte=0x%x port mp_byte=0x%x.\n",
+			    __func__, path, port, path->id,
+			    path->mp_byte, port->mp_byte);)
+			path->port = port;
+			port->mp_byte = path->mp_byte;
+		} else {
+			DEBUG3(printk("%s: update path %p port %p path id %d, "
+			    "path mp_byte=0x%x port mp_byte=0x%x.\n",
+			    __func__, path, path->port, path->id,
+			    path->mp_byte, port->mp_byte);)
+
+			if ((path->mp_byte & MP_MASK_HIDDEN) &&
+			    !(port->mp_byte & MP_MASK_HIDDEN)) {
+
+				DEBUG3(printk("%s: Adapter(%p) "
+				    "Device (%p) Path (%d) "
+				    "has become visible.\n",
+				    __func__, host, dp, path->id);)
+
+				path->mp_byte &= ~MP_MASK_HIDDEN;
+			}
+
+			if (!(path->mp_byte & MP_MASK_HIDDEN) &&
+			    (port->mp_byte & MP_MASK_HIDDEN)) {
+
+				DEBUG3(printk("%s(%ld): Adapter(%p) "
+				    "Device (%p) Path (%d) "
+				    "has become hidden.\n",
+				    __func__, host->ha->host_no, host,
+				    dp, path->id);)
+
+				path->mp_byte |= MP_MASK_HIDDEN;
+			}
+		}
+
+	} else {
+		/*
+		 * If we couldn't find an existing path, and there is still
+		 * room to add one, allocate one and put it in the list.
+		 */
+		if (path_list->path_cnt < MAX_PATHS_PER_DEVICE &&
+			path_list->path_cnt < qla_fo_params.MaxPathsPerDevice) {
+
+			if (port->flags & FCF_CONFIG) {
+				/* Use id specified in config file. */
+				id = pathid;
+				DEBUG3(printk("%s(%ld): using path id %d from "
+				    "config file.\n",
+				    __func__, host->ha->host_no, id);)
+			} else {
+				/* Assign one. */
+				id = path_list->path_cnt;
+				DEBUG3(printk(
+				    "%s(%ld): assigning path id %d.\n",
+				    __func__, host->ha->host_no, id);)
+			}
+
+			/* Update port with bitmask info */
+			path = qla4xxx_allocate_path(host, id, port, dev_id);
+			if (path) {
+#if defined(QL_DEBUG_LEVEL_3)
+				printk("%s: allocated new path %p, adding path "
+				    "id %d, mp_byte=0x%x\n", __func__, path,
+				    id, path->mp_byte);
+				if (path->port)
+					printk("port=%p-"
+					   "%02x%02x%02x%02x%02x%02x%02x%02x\n",
+					   path->port,
+					   path->port->iscsi_name[0],
+					   path->port->iscsi_name[1],
+					   path->port->iscsi_name[2],
+					   path->port->iscsi_name[3],
+					   path->port->iscsi_name[4],
+					   path->port->iscsi_name[5],
+					   path->port->iscsi_name[6],
+					   path->port->iscsi_name[7]);
+#endif
+				qla4xxx_add_path(path_list, path);
+
+				/*
+				 * Reconcile the new path against the existing
+				 * ones.
+				 */
+				qla4xxx_setup_new_path(dp, path, port);
+			}
+		} else {
+			/* EMPTY */
+			DEBUG4(printk("%s: Err exit, no space to add path.\n",
+			    __func__);)
+		}
+
+	}
+
+	LEAVE("qla4xxx_find_or_allocate_path");
+
+	return path;
+}
+
+/*
+ *  qla4xxx_find_or_allocate_lun
+ *      Look through the existing multipath control tree, and find
+ *      an mp_lun_t with the supplied world-wide lun number.  If
+ *      one cannot be found, allocate one.
+ *
+ *  Input:
+ *      host      Adapter (lun) for the device.
+ *      fclun     Lun data from port database.
+ *
+ *  Returns:
+ *      Pointer to new LUN, or NULL if the allocation fails.
+ *
+ *  Side Effects:
+ *      1. If the LUN_LIST does not already point to the LUN,
+ *         a new LUN is added to the LUN_LIST.
+ *      2. If the DEVICE_LIST does not already point to the DEVICE,
+ *         a new DEVICE is added to the DEVICE_LIST.
+ *
+ * Context:
+ *      Kernel context.
+ */
+/* ARGSUSED */
+static mp_lun_t *
+qla4xxx_find_or_allocate_lun(mp_host_t *host, uint16_t dev_id,
+    fc_port_t *port, fc_lun_t *fclun)
+{
+	mp_lun_t		*lun = NULL;
+	mp_device_t		*dp = NULL;
+#if 0
+	mp_device_t		*temp_dp = NULL;
+#endif
+	uint16_t		len;
+	uint16_t		idx;
+	uint16_t		new_id = dev_id;
+	char			wwulnbuf[WWLUN_SIZE];
+	int			new_dev = 0;
+	int			i;
+
+
+	ENTER("qla4xxx_find_or_allocate_lun");
+	DEBUG(printk("Entering %s\n", __func__);)
+
+	if( fclun == NULL )
+		return NULL;
+
+	DEBUG2(printk("%s: "
+		    " lun num=%d fclun %p mplun %p hba inst=%d, port =%p, dev id = %d\n",
+		    __func__, fclun->lun, fclun, fclun->mplun, host->instance, port,
+		    dev_id);)
+	/* 
+	 * Perform inquiry page 83 to get the wwuln or 
+	 * use what was specified by the user.
+	 */
+	if ( (port->flags & FCF_CONFIG) ) {
+			if( (len = fclun->mplen) != 0 ) 
+				memcpy(wwulnbuf, fclun->mpbuf, len); 
+	} else {
+		len = qla4xxx_get_wwuln_from_device(host, fclun, 
+			&wwulnbuf[0], WWLUN_SIZE); 
+		/* if fail to do the inq then exit */
+		if( len == 0 ) {
+			return lun;
+		}
+	}
+
+	if( len != 0 )
+		lun = qla4xxx_find_matching_lunid(wwulnbuf);
+
+	/* 
+	 * If this is a visible "controller" lun and
+	 * it is already exists on somewhere world wide
+ 	 * then allocate a new device, so it can be 
+	 * exported it to the OS.
+	 */
+	if( (fclun->flags & FLF_VISIBLE_LUN) &&
+		lun != NULL ) {
+		if( fclun->mplun ==  NULL ) {
+			lun = NULL;
+			new_dev++;
+		DEBUG2(printk("%s: Creating visible lun "
+		    "lun %p num %d fclun %p mplun %p inst=%d, port =%p, dev id = %d\n",
+		    __func__, lun, fclun->lun, fclun, fclun->mplun, host->instance, port,
+		    dev_id);)
+		} else {
+			lun = fclun->mplun;
+			return lun;
+		}
+	} 
+
+	if (lun != NULL ) {
+		DEBUG2(printk("%s: Found an existing "
+		    "lun %p num %d fclun %p host %p inst=%d, port =%p, dev id = %d\n",
+		    __func__, lun, fclun->lun, fclun, host, host->instance, port,
+		    dev_id);)
+		if( (dp = lun->dp ) == NULL ) {
+			printk("NO dp pointer in alloacted lun\n");
+			return NULL;
+		}
+		if( qla4xxx_is_iscsiname_in_device(dp,
+		    		 port->iscsi_name) ) {
+
+				DEBUG2(printk("%s: Found iscsiname (%s)"
+			    " match in mp_dev[%d] = %p\n",
+			    __func__,
+			    port->iscsi_name,
+			    dp->dev_id, dp);)
+			if(host->mp_devs[dp->dev_id] == NULL ) {
+				host->mp_devs[dp->dev_id] = dp;
+				dp->use_cnt++;
+			}	
+		} else {
+			DEBUG(printk("%s(%ld): MP_DEV no-match on iscsiname. adding new port - "
+		    	"dev_id %d. "
+		    	"iscsi_name (%s)\n",
+		    	__func__, host->ha->host_no, dev_id,
+			port->iscsi_name);)
+
+			qla4xxx_add_iscsiname_to_mp_dev(dp,
+		    	port->iscsi_name, NULL);
+
+			DEBUG2(printk("%s(%d): (1) Added iscsiname and mp_dev[%d] update"
+		    	" with dp %p\n ",
+		    	__func__, host->ha->host_no, dp->dev_id, dp);)
+			if(host->mp_devs[dp->dev_id] == NULL ) {
+				host->mp_devs[dp->dev_id] = dp;
+				dp->use_cnt++; 
+			}	
+		} 
+	} else {
+		DEBUG2(printk("%s: MP_lun %d not found "
+		    "for fclun %p inst=%d, port =%p, dev id = %d\n",
+		    __func__, fclun->lun, fclun, host->instance, port,
+		    dev_id);)
+				
+			if( (dp = qla4xxx_find_mp_dev_by_iscsiname(host,
+			    	port->iscsi_name, &idx)) == NULL || new_dev ) {
+				DEBUG2(printk("%s(%d): No match for WWPN. Creating new mpdev \n"
+		    	"iscsi_name (%s)\n",
+		    	__func__, host->ha->host_no, 
+		    	port->iscsi_name );)
+			dp = qla4xxx_allocate_mp_dev(port->iscsi_name, port->iscsi_name);
+			/* find a good index */
+			for( i = dev_id; i < MAX_MP_DEVICES; i++ )
+				if(host->mp_devs[i] == NULL ) {
+					new_id = i;
+					break;
+				}
+			} else if( dp !=  NULL ) { /* found dp */
+				new_id = dp->dev_id;
+			}
+			
+			if( dp !=  NULL ) {
+			DEBUG2(printk("%s(%d): (2) mp_dev[%d] update"
+		    	" with dp %p\n ",
+		    	__func__, host->ha->host_no, new_id, dp);)
+				host->mp_devs[new_id] = dp;
+				dp->dev_id = new_id;
+				dp->use_cnt++;
+				lun = kmalloc(sizeof(mp_lun_t), GFP_KERNEL);
+				if (lun != NULL) {
+					memset(lun, 0, sizeof(*lun));
+					DEBUG(printk("Added lun %p to dp %p lun number %d\n",
+					lun, dp, fclun->lun);)
+					DEBUG(qla4xxx_dump_buffer(wwulnbuf, len);)
+					memcpy(lun->wwuln, wwulnbuf, len);
+					lun->siz = len;
+					lun->number = fclun->lun;
+					lun->dp = dp;
+					qla4xxx_add_lun(dp, lun);
+					INIT_LIST_HEAD(&lun->ports_list);
+				}
+			}
+			else
+				printk(KERN_WARNING
+			    	"qla4xxx: Couldn't get memory for dp. \n");
+	}
+
+	DEBUG(printk("Exiting %s\n", __func__);)
+	LEAVE("qla4xxx_find_or_allocate_lun");
+
+	return lun;
+}
+
+
+static uint32_t
+qla4xxx_cfg_register_failover_lun(mp_device_t *dp, srb_t *sp, fc_lun_t *new_lp)
+{
+	uint32_t	status = QLA_SUCCESS;
+	os_tgt_t	*tq;
+	os_lun_t	*lq;
+	fc_lun_t 	*old_lp;
+
+	DEBUG2(printk(KERN_INFO "%s: NEW fclun = %p, sp = %p\n",
+	    __func__, new_lp, sp);)
+
+	/*
+	 * Fix lun descriptors to point to new fclun which is a new fcport.
+	 */
+	if (new_lp == NULL) {
+		DEBUG2(printk(KERN_INFO "%s: Failed new lun %p\n",
+		    __func__, new_lp);)
+		return QLA_ERROR;
+	}
+
+	tq = sp->tgt_queue;
+	lq = sp->lun_queue;
+	if (tq == NULL) {
+		DEBUG2(printk(KERN_INFO "%s: Failed to get old tq %p\n",
+		    __func__, tq);)
+		return QLA_ERROR;
+	}
+	if (lq == NULL) {
+		DEBUG2(printk(KERN_INFO "%s: Failed to get old lq %p\n",
+		    __func__, lq);)
+		return QLA_ERROR;
+	}
+	old_lp = lq->fclun;
+	lq->fclun = new_lp;
+
+	/* Log the failover to console */
+	printk(KERN_INFO
+	    "qla4xxx: FAILOVER device %d from\n", dp->dev_id);
+	printk(KERN_INFO
+	    "  [%s] -> [%s]\n", old_lp->fcport->iscsi_name,
+	    new_lp->fcport->iscsi_name);
+	printk(KERN_INFO
+	    "  TGT %02x LUN %02x, reason=0x%x\n",
+	    tq->id, new_lp->lun, sp->err_id);
+	printk(KERN_INFO
+	    "  FROM HBA %d to HBA %d\n", (int)old_lp->fcport->ha->instance,
+	    (int)new_lp->fcport->ha->instance);
+
+	DEBUG3(printk("%s: NEW fclun = %p , port =%p, "
+	    "loop_id =0x%x, instance %ld\n",
+	    __func__,
+	    new_lp, new_lp->fcport,
+	    new_lp->fcport->loop_id,
+	    new_lp->fcport->ha->instance);)
+
+	return status;
+}
+
+
+/*
+ * qla4xxx_send_failover_notify
+ *      A failover operation has just been done from an old path
+ *      index to a new index.  Call lower level driver
+ *      to perform the failover notification.
+ *
+ * Inputs:
+ *      device           Device being failed over.
+ *      lun                LUN being failed over.
+ *      newpath           path that was failed over too.
+ *      oldpath           path that was failed over from.
+ *
+ * Return:
+ *      Local function status code.
+ *
+ * Context:
+ *      Kernel context.
+ */
+/* ARGSUSED */
+static uint32_t
+qla4xxx_send_failover_notify(mp_device_t *dp,
+    uint8_t lun, mp_path_t *newpath, mp_path_t *oldpath)
+{
+	fc_lun_t	*old_lp, *new_lp;
+	uint32_t	status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_send_failover_notify");
+
+	if ((old_lp = qla4xxx_find_matching_lun(lun, dp, oldpath)) == NULL) {
+		DEBUG2(printk(KERN_INFO "%s: Failed to get old lun %p, %d\n",
+		    __func__, old_lp,lun);)
+		return QLA_ERROR;
+	}
+	if ((new_lp = qla4xxx_find_matching_lun(lun, dp, newpath)) == NULL) {
+		DEBUG2(printk(KERN_INFO "%s: Failed to get new lun %p,%d\n",
+		    __func__, new_lp,lun);)
+		return QLA_ERROR;
+	}
+
+	/*
+	 * If the target is the same target, but a new HBA has been selected,
+	 * send a third party logout if required.
+	 */
+	if ((qla_fo_params.FailoverNotifyType &
+			 FO_NOTIFY_TYPE_LOGOUT_OR_LUN_RESET ||
+			qla_fo_params.FailoverNotifyType &
+			 FO_NOTIFY_TYPE_LOGOUT_OR_CDB) &&
+			qla4xxx_is_name_equal(
+				oldpath->iscsiname, newpath->iscsiname)) {
+
+		status =  qla4xxx_send_fo_notification(old_lp, new_lp);
+		if (status == QLA_SUCCESS) {
+			/* EMPTY */
+			DEBUG4(printk("%s: Logout succeded\n",
+			    __func__);)
+		} else {
+			/* EMPTY */
+			DEBUG4(printk("%s: Logout Failed\n",
+			    __func__);)
+		}
+	} else if ((qla_fo_params.FailoverNotifyType &
+			 FO_NOTIFY_TYPE_LUN_RESET) ||
+			(qla_fo_params.FailoverNotifyType &
+			 FO_NOTIFY_TYPE_LOGOUT_OR_LUN_RESET)) {
+
+		/*
+		 * If desired, send a LUN reset as the
+		 * failover notification type.
+		 */
+		if (newpath->lun_data.data[lun] & LUN_DATA_ENABLED) {
+			status = qla4xxx_send_fo_notification(old_lp, new_lp);
+			if (status == QLA_SUCCESS) {
+				/* EMPTY */
+				DEBUG4(printk("%s: LUN reset succeeded.\n",
+				    __func__);)
+			} else {
+				/* EMPTY */
+				DEBUG4(printk("%s: Failed reset LUN.\n",
+				    __func__);)
+			}
+		}
+
+	} else if (qla_fo_params.FailoverNotifyType == FO_NOTIFY_TYPE_CDB ||
+			qla_fo_params.FailoverNotifyType ==
+			FO_NOTIFY_TYPE_LOGOUT_OR_CDB) {
+
+		if (newpath->lun_data.data[lun] & LUN_DATA_ENABLED) {
+			status = qla4xxx_send_fo_notification(old_lp, new_lp);
+			if (status == QLA_SUCCESS) {
+				/* EMPTY */
+				DEBUG4(printk("%s: Send CDB succeeded.\n",
+				    __func__);)
+			} else {
+				/* EMPTY */
+				DEBUG4(printk("%s: Send CDB Error "
+				    "lun=(%d).\n", __func__, lun);)
+			}
+		}
+	} else if (qla_fo_params.FailoverNotifyType == FO_NOTIFY_TYPE_SPINUP ||
+			old_lp->fcport->notify_type == FO_NOTIFY_TYPE_SPINUP ){
+
+			status = qla4xxx_send_fo_notification(old_lp, new_lp);
+			if (status == QLA_SUCCESS) {
+				/* EMPTY */
+				DEBUG(printk("%s: Send CDB succeeded.\n",
+				    __func__);)
+			} else {
+				/* EMPTY */
+				DEBUG(printk("%s: Send CDB Error "
+				    "lun=(%d).\n", __func__, lun);)
+			}
+	} else {
+		/* EMPTY */
+		DEBUG4(printk("%s: failover disabled or no notify routine "
+		    "defined.\n", __func__);)
+	}
+
+	return status;
+}
+
+static mp_path_t *
+qla4xxx_find_host_from_port(mp_device_t *dp, 
+		mp_host_t *host,
+		mp_port_t *port )
+{
+	unsigned long	instance;
+	uint8_t 	id;
+	int		i;
+	mp_path_t	*path = NULL;
+
+	/* get next host instance */
+	instance = host->instance;
+	for(i = 0 ; i < port->cnt ; i++ ) {
+		instance = instance + 1;
+		DEBUG3(printk("%s: Finding new instance %d, max %d, cnt %d\n",
+			__func__, (int)instance, port->cnt, i);)
+		/* Handle wrap-around */
+		if( instance == port->cnt )
+			instance = 0;
+		if( port->hba_list[instance] == NULL )
+			continue;
+		if( port->hba_list[instance] != host->ha )
+			break;
+	}
+	/* Found a different hba then return the path to it */
+	if ( i != port->cnt ) {
+		id = port->path_list[instance];
+		DEBUG2(printk("%s: Changing to new host - pathid=%d\n",
+			__func__, id);)
+		path = qla4xxx_find_path_by_id(dp, id);
+	}
+	return( path );
+}
+
+/*
+ * Find_best_port
+ * This routine tries to locate the best port to the target that 
+ * doesn't require issuing a target notify command. 
+ */
+/* ARGSUSED */
+static mp_path_t *
+qla4xxx_find_best_port(mp_device_t *dp, 
+		mp_path_t *orig_path,
+		mp_port_t *port,
+		fc_lun_t *fclun )
+{
+	mp_path_t	*path = NULL;
+	mp_path_t	*new_path;
+	mp_port_t	*temp_port;
+	int		i, found;
+	fc_lun_t 	*new_fp;
+	struct list_head *list, *temp;
+	mp_lun_t *mplun = (mp_lun_t *)fclun->mplun; 
+	unsigned long	instance;
+	uint16_t	id;
+
+	found = 0;
+	list_for_each_safe(list, temp, &mplun->ports_list) {
+		temp_port = list_entry(list, mp_port_t, list);
+		if ( port == temp_port ) {
+			continue;
+		}
+		/* Search for an active matching lun on any HBA,
+		   but starting with the orig HBA */
+		instance = orig_path->host->instance;
+		for(i = 0 ; i < temp_port->cnt ; instance++) {
+			if( instance == MAX_HOSTS )
+				instance = 0;
+			id = temp_port->path_list[instance];
+			DEBUG(printk(
+			"qla%d %s: i=%d, Checking temp port=%p, pathid=%d\n",
+				(int)instance,__func__, i, temp_port, id);)
+			if (id == PATH_INDEX_INVALID)
+				continue;
+			i++; /* found a valid hba entry */
+			new_fp = mplun->paths[id];
+			DEBUG(printk(
+			"qla%d %s: Checking fclun %p, for pathid=%d\n",
+				(int)instance,__func__, new_fp, id);)
+			if( new_fp == NULL ) 
+				continue;
+			new_path = qla4xxx_find_path_by_id(dp, id);
+			if( new_path != NULL ) {
+			DEBUG(printk(
+			"qla%d %s: Found new path new_fp=%p, "
+			"path=%p, flags=0x%x\n",
+				(int)new_path->host->instance,__func__, new_fp, 
+				new_path, new_path->port->flags);)
+
+
+			if (atomic_read(&new_path->port->state) ==
+			    FCS_DEVICE_DEAD) {
+				DEBUG2(printk("qla(%d) %s - Port (0x%04x) "
+				    "DEAD.\n", (int)new_path->host->instance,
+				    __func__, new_path->port->loop_id));
+				continue;
+			}
+
+			/* Is this path on an active controller? */
+			if( (new_path->port->flags & FCF_EVA_DEVICE)  &&
+	   			!(new_fp->flags & FLF_ACTIVE_LUN) ){
+			 DEBUG2(printk("qla(%d) %s - EVA Port (0x%04x) INACTIVE.\n",
+			(int)new_path->host->instance, __func__,
+			new_path->port->loop_id);)
+				continue;
+			}
+
+			if( (new_path->port->flags & FCF_MSA_DEVICE)  &&
+       			   !(new_path->port->flags & FCF_MSA_PORT_ACTIVE) ) {
+			 DEBUG2(printk("qla(%d) %s - MSA Port (0x%04x) INACTIVE.\n",
+			(int)new_path->host->instance, __func__,
+			new_path->port->loop_id);)
+				continue;
+			}
+
+			/* found a good path */
+			DEBUG2(printk(
+			"qla%d %s: *** Changing from port %p to new port %p - pathid=%d\n",
+				(int)instance,__func__, port, temp_port, new_path->id); )
+			 return( new_path );
+			}
+		}
+	}
+
+	return( path );
+}
+
+void
+qla4xxx_find_all_active_ports(srb_t *sp) 
+{
+	scsi_qla_host_t *ha;
+	fc_port_t *fcport;
+	fc_lun_t *fclun;
+	uint16_t lun;
+
+	DEBUG2(printk(KERN_INFO
+	    "%s: Scanning for active ports...\n", __func__);)
+
+	lun = sp->lun_queue->fclun->lun;
+
+	read_lock(&qla4xxx_hostlist_lock);
+	list_for_each_entry(ha, &qla4xxx_hostlist, list) {
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if (fcport->port_type != FCT_TARGET)
+				continue;
+
+			if (fcport->flags & (FCF_EVA_DEVICE | FCF_MSA_DEVICE)) {
+				list_for_each_entry(fclun, &fcport->fcluns,
+				    list) {
+					if (fclun->flags & FLF_VISIBLE_LUN)
+						continue;
+					if (lun != fclun->lun)
+						continue;
+
+					qla4xxx_test_active_lun(fcport, fclun);
+				}
+			}
+#if MSA1000_SUPPORTED
+			if ((fcport->flags & FCF_MSA_DEVICE))
+				qla4xxx_test_active_port(fcport);
+#endif
+		}
+	}
+	read_unlock(&qla4xxx_hostlist_lock);
+
+	DEBUG2(printk(KERN_INFO
+	    "%s: Done Scanning ports...\n", __func__);)
+}
+
+/*
+ * qla4xxx_smart_failover
+ *      This routine tries to be smart about how it selects the 
+ *	next path. It selects the next path base on whether the
+ *	loop went down or the port went down. If the loop went
+ *	down it will select the next HBA. Otherwise, it will select
+ *	the next port. 
+ *
+ * Inputs:
+ *      device           Device being failed over.
+ *      sp               Request that initiated failover.
+ *      orig_path           path that was failed over from.
+ *
+ * Return:
+ *      next path	next path to use. 
+ *	flag 		1 - Don't send notify command 
+ *	 		0 - Send notify command 
+ *
+ * Context:
+ *      Kernel context.
+ */
+/* ARGSUSED */
+static mp_path_t *
+qla4xxx_smart_path(mp_device_t *dp, 
+	mp_path_t *orig_path, srb_t *sp, int *flag )
+{
+	mp_path_t	*path = NULL;
+	fc_lun_t *fclun;
+	mp_port_t *port;
+	mp_host_t *host= orig_path->host;
+		
+	DEBUG2(printk("Entering %s - sp err = %d, instance =%d\n", 
+		__func__, sp->err_id, (int)host->instance);)
+
+	qla4xxx_find_all_active_ports(sp);
+ 
+	if( sp != NULL ) {
+		fclun = sp->lun_queue->fclun;
+		if( fclun == NULL ) {
+			printk( KERN_INFO
+			"scsi%d %s: couldn't find fclun %p pathid=%d\n",
+				(int)host->instance,__func__, fclun, orig_path->id);
+			return( orig_path->next );
+		}
+		port = qla4xxx_find_port_by_name( 
+			(mp_lun_t *)fclun->mplun, orig_path);
+		if( port == NULL ) {
+			printk( KERN_INFO
+			"scsi%d %s: couldn't find MP port %p pathid=%d\n",
+				(int)host->instance,__func__, port, orig_path->id);
+			return( orig_path->next );
+		} 
+
+		/* Change to next HOST if loop went down */
+		if( sp->err_id == SRB_ERR_LOOP )  {
+			path = qla4xxx_find_host_from_port(dp, 
+					host, port );
+			if( path != NULL ) {
+				port->fo_cnt++;
+				*flag = 1;
+		  		/* if we used all the hbas then 
+			   	try and get another port */ 
+		  		if( port->fo_cnt > port->cnt ) {
+					port->fo_cnt = 0;
+					*flag = 0;
+					path = 
+					  qla4xxx_find_best_port(dp, 
+						orig_path, port, fclun );
+					if( path )
+						*flag = 1;
+		   		}
+			}
+		} else {
+			path = qla4xxx_find_best_port(dp, 
+				orig_path, port, fclun );
+			if( path )
+				*flag = 1;
+		}
+	}
+	/* Default path is next path*/
+	if (path == NULL) 
+		path = orig_path->next;
+
+	DEBUG3(printk("Exiting %s\n", __func__);)
+	return path;
+}
+
+/*
+ *  qla4xxx_select_next_path
+ *      A problem has been detected with the current path for this
+ *      device.  Try to select the next available path as the current
+ *      path for this device.  If there are no more paths, the same
+ *      path will still be selected.
+ *
+ *  Inputs:
+ *      dp           pointer of device structure.
+ *      lun                LUN to failover.
+ *
+ *  Return Value:
+ *      	new path or same path
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_path_t *
+qla4xxx_select_next_path(mp_host_t *host, mp_device_t *dp, uint8_t lun,
+	srb_t *sp)
+{
+	mp_path_t	*path = NULL;
+	mp_path_list_t	*path_list;
+	mp_path_t	*orig_path;
+	int		id;
+	uint32_t	status;
+	mp_host_t *new_host;
+	int	skip_notify= 0;
+#if 0
+	fc_lun_t	*new_fp = NULL;
+#endif
+	
+
+	ENTER("qla4xxx_select_next_path:");
+
+	path_list = dp->path_list;
+	if (path_list == NULL)
+		return NULL;
+
+	/* Get current path */
+	id = path_list->current_path[lun];
+
+	/* Get path for current path id  */
+	if ((orig_path = qla4xxx_find_path_by_id(dp, id)) != NULL) {
+		/* select next path */
+       		if (orig_path->port && (orig_path->port->flags &
+		    (FCF_MSA_DEVICE|FCF_EVA_DEVICE))) {
+			path = qla4xxx_smart_path(dp, orig_path, sp,
+			    &skip_notify); 
+		} else
+			path = orig_path->next;
+
+		new_host = path->host;
+
+		/* FIXME may need to check for HBA being reset */
+		DEBUG2(printk("%s: orig path = %p new path = %p " 
+		    "curr idx = %d, new idx = %d\n",
+		    __func__, orig_path, path, orig_path->id, path->id);)
+		DEBUG3(printk("  FAILOVER: device name: %s\n",
+		    dp->devname);)
+		DEBUG3(printk(" Original  - host name: %s\n",
+		    orig_path->host->iscsi_name);)
+		DEBUG3(printk("   path name: %s\n",
+		    orig_path->port->iscsi_name);)
+		DEBUG3(printk(" New  - host name: %s\n",
+		    new_host->iscsi_name);)
+		DEBUG3(printk("   path name: %s\n",
+		    path->port->iscsi_name);)
+
+		path_list->current_path[lun] = path->id;
+		/* If we selected a new path, do failover notification. */
+		if ( (path != orig_path) && !skip_notify ) {
+			status = qla4xxx_send_failover_notify(
+					dp, lun, path, orig_path);
+
+			/*
+			 * Currently we ignore the returned status from
+			 * the notify. however, if failover notify fails
+			 */
+		}
+	}
+
+	LEAVE("qla4xxx_select_next_path:");
+
+	return  path ;
+}
+
+
+
+/*
+ *  qla4xxx_update_mp_host
+ *      Update the multipath control information from the port
+ *      database for that adapter.
+ *
+ *  Input:
+ *      host      Adapter to update. Devices that are new are
+ *                      known to be attached to this adapter.
+ *
+ *  Returns:
+ *      1 if updated successfully; 0 if error.
+ *
+ */
+static uint8_t
+qla4xxx_update_mp_host(mp_host_t  *host)
+{
+	uint8_t		success = 1;
+	uint16_t	dev_id;
+	fc_port_t 	*fcport;
+	scsi_qla_host_t *ha = host->ha;
+
+	ENTER("qla4xxx_update_mp_host");
+
+	/*
+	 * We make sure each port is attached to some virtual device.
+	 */
+	dev_id = 0;
+	fcport = NULL;
+ 	list_for_each_entry(fcport, &ha->fcports, list) {
+		if (fcport->port_type != FCT_TARGET)
+			continue;
+
+		DEBUG2(printk("%s(%d): checking fcport list. update port "
+		    "%p-%02x%02x%02x%02x%02x%02x%02x%02x dev_id %d "
+		    "to ha inst %d.\n",
+		    __func__, ha->host_no,
+		    fcport,
+		    fcport->iscsi_name[0], fcport->iscsi_name[1],
+		    fcport->iscsi_name[2], fcport->iscsi_name[3],
+		    fcport->iscsi_name[4], fcport->iscsi_name[5],
+		    fcport->iscsi_name[6], fcport->iscsi_name[7],
+		    dev_id, ha->instance);)
+
+		qla4xxx_configure_cfg_device(fcport);
+		success |= qla4xxx_update_mp_device(host, fcport, dev_id, 0);
+		dev_id++;
+	}
+	if (success) {
+		DEBUG2(printk(KERN_INFO "%s: Exit OK\n", __func__);)
+		qla4xxx_map_os_targets(host);
+	} else {
+		/* EMPTY */
+		DEBUG2(printk(KERN_INFO "%s: Exit FAILED\n", __func__);)
+	}
+
+	DEBUG2(printk("%s: inst %d exiting.\n", __func__, ha->instance);)
+	LEAVE("qla4xxx_update_mp_host");
+
+	return success;
+}
+
+/*
+ *  qla4xxx_update_mp_device
+ *      Update the multipath control information from the port
+ *      database for that adapter.
+ *
+ *  Inputs:
+ *		host   Host adapter structure
+ *      port   Device to add to the path tree.
+ *		dev_id  Device id
+ *
+ *  Synchronization:
+ *      The Adapter Lock should have already been acquired
+ *      before calling this routine.
+ *
+ *  Return
+ *      1 if updated successfully; 0 if error.
+ *
+ */
+uint8_t
+qla4xxx_update_mp_device(mp_host_t *host,
+    fc_port_t *port, uint16_t dev_id, uint16_t pathid)
+{
+	uint8_t		success = 1;
+
+	ENTER("qla4xxx_update_mp_device");
+
+	DEBUG3(printk("%s(%ld): entered. host %p inst=%d," 
+	    "port iscsi_name=%s, dev id = %d\n",
+	    __func__, host->ha->host_no, host, host->instance,
+	    port->iscsi_name,
+	    dev_id);)
+
+	if (!qla4xxx_is_name_zero(port->iscsi_name)) {
+		if( port->fo_combine ) {
+			return( port->fo_combine(host, dev_id, port, pathid) );
+		} else 
+			success = qla4xxx_combine_by_lunid( host, dev_id, port, pathid ); 
+
+	} else {
+		/* EMPTY */
+		DEBUG4(printk("%s: Failed iscsiname empty.\n",
+		    __func__);)
+	}
+
+	DEBUG3(printk("%s(%ld): exiting.\n",
+	    __func__, host->ha->host_no);)
+	LEAVE("qla4xxx_update_mp_device");
+
+	return success;
+}
+
+/*
+ * qla4xxx_update_mp_tree
+ *      Get port information from each adapter, and build or rebuild
+ *      the multipath control tree from this data.  This is called
+ *      from init and during port database notification.
+ *
+ * Input:
+ *      None
+ *
+ * Return:
+ *      Local function return code.
+ *
+ */
+static uint32_t
+qla4xxx_update_mp_tree(void)
+{
+	mp_host_t	*host;
+	uint32_t	rval = QLA_SUCCESS;
+
+	ENTER("qla4xxx_update_mp_tree:");
+
+	/* Loop through each adapter and see what needs updating. */
+	for (host = mp_hosts_base; (host) ; host = host->next) {
+
+		DEBUG4(printk("%s: hba(%d) flags (%x)\n",
+		    __func__, host->instance, host->flags);)
+		/* Clear the countdown; it may be reset in the update. */
+		host->relogin_countdown = 0;
+
+		/* Override the NEEDS_UPDATE flag if disabled. */
+		if (host->flags & MP_HOST_FLAG_DISABLE ||
+		    list_empty(host->fcports))
+			host->flags &= ~MP_HOST_FLAG_NEEDS_UPDATE;
+
+		if (host->flags & MP_HOST_FLAG_NEEDS_UPDATE) {
+
+			/*
+			 * Perform the actual updates.  If this succeeds, clear
+			 * the flag that an update is needed, and failback all
+			 * devices that are visible on this path to use this
+			 * path.  If the update fails, leave set the flag that
+			 * an update is needed, and it will be picked back up
+			 * during the next timer routine.
+			 */
+			if (qla4xxx_update_mp_host(host)) {
+				host->flags &= ~MP_HOST_FLAG_NEEDS_UPDATE;
+
+				qla4xxx_failback_luns(host);
+			} else
+				rval = QLA_ERROR;
+
+		}
+
+	}
+
+	if (rval != QLA_SUCCESS) {
+		/* EMPTY */
+		DEBUG4(printk("%s: Exit FAILED.\n", __func__);)
+
+	} else {
+		/* EMPTY */
+		DEBUG4(printk("%s: Exit OK.\n", __func__);)
+	}
+	return rval;
+}
+
+
+
+/*
+ * qla4xxx_find_matching_lun_by_num
+ *      Find the lun in the path that matches the
+ *  specified lun number.
+ *
+ * Input:
+ *      lun  = lun number
+ *      newpath = path to search for lun
+ *
+ * Returns:
+ *      NULL or pointer to lun
+ *
+ * Context:
+ *      Kernel context.
+ * (dg)
+ */
+static fc_lun_t  *
+qla4xxx_find_matching_lun_by_num(uint16_t lun_no, mp_device_t *dp,
+	mp_path_t *newpath)
+{
+	int found;
+	fc_lun_t *lp = NULL;	/* lun ptr */
+	fc_port_t *fcport;		/* port ptr */
+	mp_lun_t  *lun;
+
+	/* Use the lun list if we have one */	
+	if( dp->luns ) {
+		for (lun = dp->luns; lun != NULL ; lun = lun->next) {
+			if( lun_no == lun->number ) {
+				lp = lun->paths[newpath->id];
+				break;
+			}
+		}
+	} else {
+	if ((fcport = newpath->port) != NULL) {
+			found = 0;
+			list_for_each_entry(lp, &fcport->fcluns, list) {
+				if (lun_no == lp->lun) {
+					found++;
+				break;
+			}
+		}
+			if (!found)
+				lp = NULL;
+		}
+	}
+	return lp;
+}
+
+static fc_lun_t  *
+qla4xxx_find_matching_lun(uint8_t lun, mp_device_t *dp, 
+	mp_path_t *newpath)
+{
+	fc_lun_t *lp;
+
+	lp = qla4xxx_find_matching_lun_by_num(lun, dp, newpath);
+
+	return lp;
+}
+
+/*
+ * qla4xxx_find_path_by_name
+ *      Find the path specified iscsiname from the pathlist
+ *
+ * Input:
+ *      host = host adapter pointer.
+ * 	pathlist =  multi-path path list
+ *      iscsiname  	iscsiname to search for
+ *
+ * Returns:
+ * pointer to the path or NULL
+ *
+ * Context:
+ *      Kernel context.
+ */
+mp_path_t *
+qla4xxx_find_path_by_name(mp_host_t *host, mp_path_list_t *plp,
+    uint8_t *iscsiname)
+{
+	mp_path_t  *path = NULL;		/* match if not NULL */
+	mp_path_t  *tmp_path;
+	int cnt;
+
+	if ((tmp_path = plp->last) != NULL) {
+		for (cnt = 0; (tmp_path) && cnt < plp->path_cnt; cnt++) {
+			if (tmp_path->host == host &&
+				qla4xxx_is_name_equal(
+					tmp_path->iscsiname, iscsiname)) {
+
+				path = tmp_path;
+				break;
+			}
+			tmp_path = tmp_path->next;
+		}
+	}
+	return path ;
+}
+
+/*
+ * qla4xxx_find_path_by_id
+ *      Find the path for the specified path id.
+ *
+ * Input:
+ * 	dp 		multi-path device
+ * 	id 		path id
+ *
+ * Returns:
+ *      pointer to the path or NULL
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_path_t *
+qla4xxx_find_path_by_id(mp_device_t *dp, uint8_t id)
+{
+	mp_path_t  *path = NULL;
+	mp_path_t  *tmp_path;
+	mp_path_list_t		*path_list;
+	int cnt;
+
+	path_list = dp->path_list;
+	tmp_path = path_list->last;
+	for (cnt = 0; (tmp_path) && cnt < path_list->path_cnt; cnt++) {
+		if (tmp_path->id == id) {
+			path = tmp_path;
+			break;
+		}
+		tmp_path = tmp_path->next;
+	}
+	return path ;
+}
+
+/*
+ * qla4xxx_find_mp_dev_by_id
+ *      Find the mp_dev for the specified target id.
+ *
+ * Input:
+ *      host = host adapter pointer.
+ *      tgt  = Target id
+ *
+ * Returns:
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_device_t  *
+qla4xxx_find_mp_dev_by_id(mp_host_t *host, uint16_t id )
+{
+	if (id < MAX_MP_DEVICES)
+		return host->mp_devs[id];
+	else
+		return NULL;
+}
+
+/*
+ * qla4xxx_find_mp_dev_by_iscsiname
+ *      Find the mp_dev for the specified target name.
+ *
+ * Input:
+ *      host = host adapter pointer.
+ *      name  = port name
+ *
+ * Returns:
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_device_t  *
+qla4xxx_find_mp_dev_by_iscsiname(mp_host_t *host, uint8_t *name, uint16_t *pidx)
+{
+	int		id;
+	mp_device_t	*dp = NULL;
+
+	DEBUG3(printk("%s: entered.\n", __func__);)
+
+	for (id= 0; id < MAX_MP_DEVICES; id++) {
+		if ((dp = host->mp_devs[id] ) == NULL)
+			continue;
+
+		if (qla4xxx_is_iscsiname_in_device(dp, name)) {
+			DEBUG3(printk("%s: Found matching device @ index %d:\n",
+			    __func__, id);)
+			*pidx = id;
+			return dp;
+		}
+	}
+
+	DEBUG3(printk("%s: exiting.\n", __func__);)
+ 
+ 	return NULL;
+ }
+
+/*
+ * qla4xxx_get_visible_path
+ * Find the the visible path for the specified device.
+ *
+ * Input:
+ *      dp = device pointer
+ *
+ * Returns:
+ *      NULL or path
+ *
+ * Context:
+ *      Kernel context.
+ */
+static mp_path_t *
+qla4xxx_get_visible_path(mp_device_t *dp)
+{
+	uint16_t	id;
+	mp_path_list_t	*path_list;
+	mp_path_t	*path;
+
+	path_list = dp->path_list;
+	/* if we don't have a visible path skip it */
+	if ((id = path_list->visible) == PATH_INDEX_INVALID) {
+		return NULL;
+	}
+
+	if ((path = qla4xxx_find_path_by_id(dp,id))== NULL)
+		return NULL;
+
+	return path ;
+}
+
+/*
+ * qla4xxx_map_os_targets
+ * Allocate the luns and setup the OS target.
+ *
+ * Input:
+ *      host = host adapter pointer.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ */
+static void
+qla4xxx_map_os_targets(mp_host_t *host)
+{
+	scsi_qla_host_t *ha = host->ha;
+	mp_path_t	*path;
+	mp_device_t 	*dp;
+	os_tgt_t	*tgt;
+	int		t;
+
+	ENTER("qla4xxx_map_os_targets ");
+
+	for (t = 0; t < MAX_TARGETS; t++ ) {
+		dp = host->mp_devs[t];
+		if (dp != NULL) {
+			DEBUG2(printk("%s: (%d) found a dp=%p, "
+			    "host=%p, ha=%p\n",
+			    __func__, t, dp, host,ha);)
+
+			if ((path = qla4xxx_get_visible_path(dp)) == NULL) {
+				DEBUG2( printk(KERN_INFO
+				    "qla_cfg(%d): No visible path "
+				    "for target %d, dp = %p\n",
+				    host->instance, t, dp); )
+				continue;
+			}
+
+			/* if not the visible path skip it */
+			if (path->host == host) {
+				if (TGT_Q(ha, t) == NULL) {
+					/* XXX need to check for NULL */
+					tgt = qla4xxx_tgt_alloc(ha, t);
+					memcpy(tgt->iscsi_name,dp->devname,
+					    ISCSI_NAME_SIZE);
+					tgt->fcport = path->port;
+				}
+				if (path->port)
+					path->port->os_target_id = t;
+
+				DEBUG3(printk("%s(%ld): host instance =%d, "
+				    "device= %p, tgt=%d has VISIBLE path,"
+				    "path id=%d\n",
+				    __func__, ha->host_no,
+				    host->instance,
+				    dp, t, path->id);)
+			} else {
+			/* EMPTY */
+				DEBUG3(printk("%s(%ld): host instance =%d, "
+				    "device= %p, tgt=%d has HIDDEN "
+				    "path, path id=%d\n",
+				    __func__, ha->host_no,
+				    host->instance, dp, t, 
+					path->id); )
+				continue;
+			}
+			qla4xxx_map_os_luns(host, dp, t);
+		} else {
+			if ((tgt= TGT_Q(ha,t)) != NULL) {
+				qla4xxx_tgt_free(ha,t);
+			}
+		}
+	}
+
+	LEAVE("qla4xxx_map_os_targets ");
+}
+
+static void
+qla4xxx_map_or_failover_oslun(mp_host_t *host, mp_device_t *dp, 
+	uint16_t t, uint16_t lun_no)
+{
+	int	i;
+
+	/* 
+	 * if this is initization time and we couldn't map the
+	 * lun then try and find a usable path.
+	 */
+	if ( qla4xxx_map_a_oslun(host, dp, t, lun_no) &&
+		(host->flags & MP_HOST_FLAG_LUN_FO_ENABLED) ){
+		/* find a path for us to use */
+		for ( i = 0; i < dp->path_list->path_cnt; i++ ){
+			qla4xxx_select_next_path(host, dp, lun_no, NULL);
+			if( !qla4xxx_map_a_oslun(host, dp, t, lun_no))
+				break;
+		}
+	}
+}
+
+/*
+ * qla4xxx_map_os_luns
+ *      Allocate the luns for the OS target.
+ *
+ * Input:
+ *      dp = pointer to device
+ *      t  = OS target number.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla4xxx_map_os_luns(mp_host_t *host, mp_device_t *dp, uint16_t t)
+{
+	uint16_t lun_no;
+	mp_lun_t	*lun;
+	os_lun_t *up;
+
+	DEBUG3(printk("Entering %s..\n",__func__);)
+
+	/* if we are using lun binding then scan for the discovered luns */
+	if( dp->luns ) {
+		for (lun = dp->luns; lun != NULL ; lun = lun->next) {
+			lun_no = lun->number;
+			DEBUG2(printk("%s: instance %d: Mapping target %d, lun %d..\n",
+				__func__,host->instance,t,lun->number);)
+			qla4xxx_map_or_failover_oslun(host, dp, 
+				t, lun_no);
+			up = (os_lun_t *) GET_LU_Q(host->ha, t, lun_no);
+			if (up == NULL || up->fclun == NULL) {
+			DEBUG2(printk("%s: instance %d: No FCLUN for target %d, lun %d.. \n",
+				__func__,host->instance,t,lun->number);)
+				continue;
+			}
+			if (up->fclun->fcport == NULL) {
+			DEBUG2(printk("%s: instance %d: No FCPORT for target %d, lun %d.. \n",
+				__func__,host->instance,t,lun->number);)
+				continue;
+			}
+			DEBUG2(printk("%s: instance %d: Mapping target %d, lun %d.. to path id %d\n",
+				__func__,host->instance,t,lun->number,
+			    up->fclun->fcport->cur_path);)
+		}
+	} else {
+		for (lun_no = 0; lun_no < MAX_LUNS; lun_no++ ) {
+			qla4xxx_map_or_failover_oslun(host, dp, 
+				t, lun_no);
+		}
+	}
+	DEBUG3(printk("Exiting %s..\n",__func__);)
+}
+
+/*
+ * qla4xxx_map_a_osluns
+ *      Map the OS lun to the current path
+ *
+ * Input:
+ *      host = pointer to host
+ *      dp = pointer to device
+ *      lun  = OS lun number.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *	Kernel context.
+ */
+
+static uint8_t
+qla4xxx_map_a_oslun(mp_host_t *host, mp_device_t *dp, uint16_t t, uint16_t lun)
+{
+	fc_port_t	*fcport;
+	fc_lun_t	*fclun;
+	os_lun_t	*lq;
+	uint16_t	id;
+	mp_path_t	*path, *vis_path;
+	mp_host_t 	*vis_host;
+	uint8_t		status = 0;
+
+	if ((id = dp->path_list->current_path[lun]) != PATH_INDEX_INVALID) {
+		DEBUG3(printk( "qla4xxx(%d): Current path for lun %d is path id %d\n",
+		    host->instance,
+		    lun, id);)
+		path = qla4xxx_find_path_by_id(dp,id);
+		if (path) {
+			fcport = path->port;
+			if (fcport) {
+
+			 	fcport->cur_path = id;
+				fclun = qla4xxx_find_matching_lun(lun,dp,path);
+		DEBUG3(printk( "qla4xxx(%d): found fclun %p, path id = %d\n", host->instance,fclun,id);)
+
+				/* Always map all luns if they are enabled */
+				if (fclun &&
+					(path->lun_data.data[lun] &
+					 LUN_DATA_ENABLED) ) {
+		DEBUG(printk( "qla4xxx(%d): Current path for lun %d/%p is path id %d\n",
+		    host->instance,
+		    lun, fclun, id);)
+		DEBUG3(printk( "qla4xxx(%d): Lun is enable \n", host->instance);)
+
+					/*
+					 * Mapped lun on the visible path
+					 */
+					if ((vis_path =
+					    qla4xxx_get_visible_path(dp)) ==
+					    NULL ) {
+
+						printk(KERN_INFO
+						    "qla4xxx(%d): No visible "
+						    "path for target %d, "
+						    "dp = %p\n",
+						    host->instance,
+						    t, dp);
+
+						return 0;
+					}
+					vis_host = vis_path->host;
+
+					/* ra 11/30/01 */
+					/*
+					 * Always alloc LUN 0 so kernel
+					 * will scan past LUN 0.
+					 */
+#if 0
+					if (lun != 0 &&
+					    (EXT_IS_LUN_BIT_SET(
+						&(fcport->lun_mask), lun))) {
+
+						/* mask this LUN */
+						return 0;
+					}
+#endif
+
+					if ((lq = qla4xxx_lun_alloc(
+							vis_host->ha,
+							t, lun)) != NULL) {
+
+						lq->fclun = fclun;
+					}
+		DEBUG(printk( "qla4xxx(%d): lun allocated %p for lun %d\n",
+			 host->instance,lq,lun);)
+				}
+			}
+			else
+				status = 1;
+		}
+	}
+	return status;
+}
+
+/*
+ * qla4xxx_is_name_zero
+ *
+ * Input:
+ *      name = Pointer to WW name to check
+ *
+ * Returns:
+ *      1 if name is 0 else 0
+ *
+ * Context:
+ *      Kernel context.
+ */
+static uint8_t
+qla4xxx_is_name_zero(uint8_t *nn)
+{
+	int cnt;
+
+	/* Check for zero node name */
+	for (cnt = 0; cnt < ISCSI_NAME_SIZE ; cnt++, nn++) {
+		if (*nn != 0)
+			break;
+	}
+	/* if zero return 1 */
+	if (cnt == ISCSI_NAME_SIZE)
+		return 1;
+	else
+		return 0;
+}
+
+/*
+ * qla4xxx_add_path
+ * Add a path to the pathlist
+ *
+ * Input:
+ * pathlist -- path list of paths
+ * path -- path to be added to list
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ */
+static void
+qla4xxx_add_path( mp_path_list_t *pathlist, mp_path_t *path )
+{
+	mp_path_t *last = pathlist->last;
+
+	ENTER("qla4xxx_add_path");
+	DEBUG3(printk("%s: entered for path id %d.\n",
+	    __func__, path->id);)
+
+	DEBUG3(printk("%s: pathlist =%p, path =%p, cnt = %d\n",
+	    __func__, pathlist, path, pathlist->path_cnt);)
+	if (last == NULL) {
+		last = path;
+	} else {
+		path->next = last->next;
+	}
+
+	last->next = path;
+	pathlist->last = path;
+	pathlist->path_cnt++;
+
+	DEBUG3(printk("%s: exiting. path cnt=%d.\n",
+	    __func__, pathlist->path_cnt);)
+	LEAVE("qla4xxx_add_path");
+}
+
+static void
+qla4xxx_add_lun( mp_device_t *dp, mp_lun_t *lun)
+{
+	mp_lun_t 	*cur_lun;
+
+	ENTER("qla4xxx_add_lun");
+
+	/* Insert new entry into the list of luns */
+	lun->next = NULL;
+
+	cur_lun = dp->luns;
+	if( cur_lun == NULL ) {
+		dp->luns = lun;
+	} else {
+		/* add to tail of list */
+		while( cur_lun->next != NULL )
+			cur_lun = cur_lun->next;
+
+		cur_lun->next = lun;
+	}
+	LEAVE("qla4xxx_add_lun");
+}
+
+/*
+ * qla4xxx_is_iscsiname_in_device
+ *	Search for the specified "iscsiname" in the device list.
+ *
+ * Input:
+ *	dp = device pointer
+ *	iscsiname = iscsiname to searched for in device
+ *
+ * Returns:
+ *      qla4xxx local function return status code.
+ *
+ * Context:
+ *      Kernel context.
+ */
+int
+qla4xxx_is_iscsiname_in_device(mp_device_t *dp, uint8_t *iscsiname)
+{
+	int idx;
+
+	for (idx = 0; idx < MAX_PATHS_PER_DEVICE; idx++) {
+		if (memcmp(&dp->iscsinames[idx][0], iscsiname, ISCSI_NAME_SIZE) == 0)
+			return 1;
+	}
+	return 0;
+}
+
+
+/*
+ *  qla4xxx_set_lun_data_from_bitmask
+ *      Set or clear the LUN_DATA_ENABLED bits in the LUN_DATA from
+ *      a LUN bitmask provided from the miniport driver.
+ *
+ *  Inputs:
+ *      lun_data = Extended LUN_DATA buffer to set.
+ *      lun_mask = Pointer to lun bit mask union.
+ *
+ *  Return Value: none.
+ */
+void
+qla4xxx_set_lun_data_from_bitmask(mp_lun_data_t *lun_data,
+    lun_bit_mask_t *lun_mask)
+{
+	int16_t	lun;
+
+	ENTER("qla4xxx_set_lun_data_from_bitmask");
+
+	for (lun = 0; lun < MAX_LUNS; lun++) {
+		/* our bit mask is inverted */
+#if 0
+		if (!(EXT_IS_LUN_BIT_SET(lun_mask,lun)))
+			lun_data->data[lun] |= LUN_DATA_ENABLED;
+		else
+			lun_data->data[lun] &= ~LUN_DATA_ENABLED;
+#else
+		lun_data->data[lun] |= LUN_DATA_ENABLED;
+#endif
+
+		DEBUG5(printk("%s: lun data[%d] = 0x%x\n",
+		    __func__, lun, lun_data->data[lun]);)
+	}
+
+	LEAVE("qla4xxx_set_lun_data_from_bitmask");
+
+	return;
+}
+
+static void
+qla4xxx_failback_single_lun(mp_device_t *dp, uint8_t lun, uint8_t new)
+{
+	mp_path_list_t   *pathlist;
+	mp_path_t        *new_path, *old_path;
+	uint8_t 	old;
+	mp_host_t  *host;
+	os_lun_t *lq;
+	mp_path_t	*vis_path;
+	mp_host_t 	*vis_host;
+
+	/* Failback and update statistics. */
+	if ((pathlist = dp->path_list) == NULL)
+		return;
+
+	old = pathlist->current_path[lun];
+	pathlist->current_path[lun] = new;
+
+	if ((new_path = qla4xxx_find_path_by_id(dp, new)) == NULL)
+		return;
+	if ((old_path = qla4xxx_find_path_by_id(dp, old)) == NULL)
+		return;
+
+	/* An fclun should exist for the failbacked lun */
+	if (qla4xxx_find_matching_lun(lun, dp, new_path) == NULL)
+		return;
+	if (qla4xxx_find_matching_lun(lun, dp, old_path) == NULL)
+		return;
+
+	/* Log to console and to event log. */
+	printk(KERN_INFO
+		"qla4xxx: FAILBACK device %d -> "
+		"[%s] LUN %02x\n",
+		dp->dev_id, dp->devname, lun);
+
+	printk(KERN_INFO
+		"qla4xxx: FROM HBA %d to HBA %d \n",
+		old_path->host->instance,
+		new_path->host->instance);
+
+
+	/* Send a failover notification. */
+	qla4xxx_send_failover_notify(dp, lun, new_path, old_path);
+
+	host = 	new_path->host;
+
+	/* remap the lun */
+	qla4xxx_map_a_oslun(host, dp, dp->dev_id, lun);
+
+	/* 7/16
+	 * Reset counts on the visible path
+	 */
+	if ((vis_path = qla4xxx_get_visible_path(dp)) == NULL) {
+		printk(KERN_INFO
+			"qla4xxx(%d): No visible path for "
+			"target %d, dp = %p\n",
+			host->instance,
+			dp->dev_id, dp);
+		return;
+	}
+
+	vis_host = vis_path->host;
+	if ((lq = qla4xxx_lun_alloc(vis_host->ha, dp->dev_id, lun)) != NULL) {
+		qla4xxx_delay_lun(vis_host->ha, lq, ql4xrecoveryTime);
+		qla4xxx_flush_failover_q(vis_host->ha, lq);
+		qla4xxx_reset_lun_fo_counts(vis_host->ha, lq);
+	}
+}
+
+#if 0
+static void
+qla4xxx_failback_single_lun(mp_device_t *dp, uint8_t lun, uint8_t new)
+{
+	mp_path_list_t   *pathlist;
+	mp_path_t        *new_path, *old_path;
+	uint8_t 	old;
+	mp_host_t  *new_host;
+	os_lun_t *lq;
+	mp_path_t	*vis_path;
+	mp_host_t 	*vis_host;
+	int		status;
+
+	/* Failback and update statistics. */
+	if ((pathlist = dp->path_list) == NULL)
+		return;
+
+	old = pathlist->current_path[lun];
+	/* pathlist->current_path[lun] = new; */
+
+	if ((new_path = qla4xxx_find_path_by_id(dp, new)) == NULL)
+		return;
+	if ((old_path = qla4xxx_find_path_by_id(dp, old)) == NULL)
+		return;
+
+	/* An fclun should exist for the failbacked lun */
+	if (qla4xxx_find_matching_lun(lun, dp, new_path) == NULL)
+		return;
+	if (qla4xxx_find_matching_lun(lun, dp, old_path) == NULL)
+		return;
+
+	if ((vis_path = qla4xxx_get_visible_path(dp)) == NULL) {
+		printk(KERN_INFO
+			"No visible path for "
+			"target %d, dp = %p\n",
+			dp->dev_id, dp);
+		return;
+	}
+	vis_host = vis_path->host;
+	/* Schedule the recovery before we move the luns */
+	if( (lq = (os_lun_t *) 
+		LUN_Q(vis_host->ha, dp->dev_id, lun)) == NULL ) {
+		printk(KERN_INFO
+			"qla4xxx(%d): No visible lun for "
+			"target %d, dp = %p, lun=%d\n",
+			vis_host->instance,
+			dp->dev_id, dp, lun);
+		return;
+  	}
+
+	qla4xxx_delay_lun(vis_host->ha, lq, ql4xrecoveryTime);
+
+	/* Log to console and to event log. */
+	printk(KERN_INFO
+		"qla4xxx: FAILBACK device %d -> "
+		"%02x%02x%02x%02x%02x%02x%02x%02x LUN %02x\n",
+		dp->dev_id,
+		dp->devname[0], dp->devname[1],
+		dp->devname[2], dp->devname[3],
+		dp->devname[4], dp->devname[5],
+		dp->devname[6], dp->devname[7],
+		lun);
+
+	printk(KERN_INFO
+		"qla4xxx: FROM HBA %d to HBA %d \n",
+		old_path->host->instance,
+		new_path->host->instance);
+
+
+	/* Send a failover notification. */
+	status = qla4xxx_send_failover_notify(dp, lun, 
+			new_path, old_path);
+
+	new_host = 	new_path->host;
+
+	/* remap the lun */
+	if (status == QLA_SUCCESS ) {
+		pathlist->current_path[lun] = new;
+		qla4xxx_map_a_oslun(new_host, dp, dp->dev_id, lun);
+		qla4xxx_flush_failover_q(vis_host->ha, lq);
+		qla4xxx_reset_lun_fo_counts(vis_host->ha, lq);
+	}
+}
+#endif
+
+/*
+*  qla4xxx_failback_luns
+*      This routine looks through the devices on an adapter, and
+*      for each device that has this adapter as the visible path,
+*      it forces that path to be the current path.  This allows us
+*      to keep some semblance of static load balancing even after
+*      an adapter goes away and comes back.
+*
+*  Arguments:
+*      host          Adapter that has just come back online.
+*
+*  Return:
+*	None.
+*/
+static void
+qla4xxx_failback_luns( mp_host_t  *host)
+{
+	uint16_t          dev_no;
+	uint8_t           l;
+	uint16_t          lun;
+	int i;
+	mp_device_t      *dp;
+	mp_path_list_t   *path_list;
+	mp_path_t        *path;
+	fc_lun_t	*new_fp;
+
+	ENTER("qla4xxx_failback_luns");
+
+	for (dev_no = 0; dev_no < MAX_MP_DEVICES; dev_no++) {
+		dp = host->mp_devs[dev_no];
+
+		if (dp == NULL)
+			continue;
+
+		path_list = dp->path_list;
+		for (path = path_list->last, i= 0;
+			i < path_list->path_cnt;
+			i++, path = path->next) {
+
+			if (path->host != host )
+				continue;
+
+			if (path->port == NULL)
+				continue;
+
+			if (atomic_read(&path->port->state) == FCS_DEVICE_DEAD)
+				continue;
+
+		        if ((path->port->flags & FCF_FAILBACK_DISABLE))
+				continue;
+
+			/* 
+			 * Failback all the paths for this host,
+			 * the luns could be preferred across all paths 
+			 */
+			DEBUG4(printk("%s(%d): Lun Data for device %p, "
+			    "dev id=%d, path id=%d\n",
+			    __func__, host->instance, dp, dp->dev_id,
+			    path->id);)
+			DEBUG4(qla4xxx_dump_buffer(
+			    (char *)&path->lun_data.data[0], 64);)
+			DEBUG4(printk("%s(%d): Perferrred Path data:\n",
+			    __func__, host->instance);)
+			DEBUG4(qla4xxx_dump_buffer(
+			    (char *)&path_list->current_path[0], 64);)
+
+			for (lun = 0; lun < MAX_LUNS_PER_DEVICE; lun++) {
+				l = (uint8_t)(lun & 0xFF);
+
+				/*
+				 * if this is the preferred lun and not
+				 * the current path then failback lun.
+				 */
+				DEBUG4(printk("%s: target=%d, cur path id =%d, "
+				    "lun data[%d] = %d)\n",
+				    __func__, dp->dev_id, path->id,
+				    lun, path->lun_data.data[lun]);)
+
+				if ((path->lun_data.data[l] &
+						LUN_DATA_PREFERRED_PATH) &&
+					/* !path->relogin && */
+					path_list->current_path[l] !=
+						path->id) {
+					/* No point in failing back a
+					   disconnected lun */
+					new_fp = qla4xxx_find_matching_lun(
+							l, dp, path);
+
+					if (new_fp == NULL)
+						continue;
+					/* Skip a disconect lun */
+					if (new_fp->device_type & 0x20)
+						continue;
+
+					qla4xxx_failback_single_lun(
+							dp, l, path->id);
+				}
+			}
+		}
+
+	}
+
+	LEAVE("qla4xxx_failback_luns");
+
+	return;
+}
+
+static struct _mp_path *
+qla4xxx_find_first_active_path( mp_device_t *dp, mp_lun_t *lun)
+{
+	mp_path_t *path= NULL;
+	mp_path_list_t  *plp = dp->path_list;
+	mp_path_t  *tmp_path;
+	fc_port_t 	*fcport;
+	fc_lun_t 	*fclun;
+	int cnt;
+
+	if ((tmp_path = plp->last) != NULL) {
+		tmp_path = tmp_path->next;
+		for (cnt = 0; (tmp_path) && cnt < plp->path_cnt;
+		    tmp_path = tmp_path->next, cnt++) {
+			fcport = tmp_path->port;
+			if (fcport != NULL) {
+				if ((fcport->flags & FCF_EVA_DEVICE)) { 
+					fclun = lun->paths[tmp_path->id];
+					if (fclun == NULL)
+						continue;
+					if (fclun->flags & FLF_ACTIVE_LUN) {
+						path = tmp_path;
+						break;
+					}
+				} else {
+					if ((fcport->flags &
+					    FCF_MSA_PORT_ACTIVE)) {
+						path = tmp_path;
+						break;
+					}
+				}
+			}
+		}
+	}
+	return path;
+}
+
+/*
+ *  qla4xxx_setup_new_path
+ *      Checks the path against the existing paths to see if there
+ *      are any incompatibilities.  It then checks and sets up the
+ *      current path indices.
+ *
+ *  Inputs:
+ *      dp   =  pointer to device
+ *      path = new path
+ *
+ *  Returns:
+ *      None
+ */
+static void
+qla4xxx_setup_new_path( mp_device_t *dp, mp_path_t *path, fc_port_t *fcport)
+{
+	mp_path_list_t  *path_list = dp->path_list;
+	mp_path_t       *tmp_path, *first_path;
+	mp_host_t       *first_host;
+	mp_host_t       *tmp_host;
+
+	uint16_t	lun;
+	uint8_t		l;
+	int		i;
+
+	ENTER("qla4xxx_setup_new_path");
+	DEBUG(printk("qla4xxx_setup_new_path: path %p path id %d, fcport = %p\n", 
+		path, path->id, path->port);)
+
+	/* If this is a visible path, and there is not already a
+	 * visible path, save it as the visible path.  If there
+	 * is already a visible path, log an error and make this
+	 * path invisible.
+	 */
+	if (!(path->mp_byte & (MP_MASK_HIDDEN | MP_MASK_UNCONFIGURED))) {
+
+		/* No known visible path */
+		if (path_list->visible == PATH_INDEX_INVALID) {
+			DEBUG3(printk("%s: No know visible path - make this "
+			    "path visible\n",
+			    __func__);)
+				
+			path_list->visible = path->id;
+			path->mp_byte &= ~MP_MASK_HIDDEN;
+		} else {
+			DEBUG3(printk("%s: Second visible path found- make "
+			    "this one hidden\n",
+			    __func__);)
+
+			path->mp_byte |= MP_MASK_HIDDEN;
+		}
+		if (path->port)
+			path->port->mp_byte = path->mp_byte;
+	}
+
+	/*
+	 * If this is not the first path added, and the setting for
+	 * MaxLunsPerTarget does not match that of the first path
+	 * then disable qla_cfg for all adapters.
+	 */
+	first_path = qla4xxx_find_path_by_id(dp, 0);
+
+	if (first_path != NULL) {
+		first_host = first_path->host;
+		if ((path->id != 0) &&
+			(first_host->MaxLunsPerTarget !=
+			 path->host->MaxLunsPerTarget)) {
+
+			for (tmp_path = path_list->last, i = 0;
+				(tmp_path) && i <= path->id; i++) {
+
+				tmp_host = tmp_path->host;
+				if (!(tmp_host->flags &
+						MP_HOST_FLAG_DISABLE)) {
+
+					DEBUG4(printk("%s: 2nd visible "
+					    "path (%p)\n",
+					    __func__, tmp_host);)
+
+					tmp_host->flags |= MP_HOST_FLAG_DISABLE;
+				}
+			}
+		}
+	}
+
+	if (!(fcport->flags & (FCF_MSA_DEVICE | FCF_EVA_DEVICE))) { 
+		/*
+		 * For each LUN, evaluate whether the new path that is added is
+		 * better than the existing path.  If it is, make it the
+		 * current path for the LUN.
+		 */
+		for (lun = 0; lun < MAX_LUNS_PER_DEVICE; lun++) {
+			l = (uint8_t)(lun & 0xFF);
+
+			/*
+			 * If this is the first path added, it is the only
+			 * available path, so make it the current path.
+			 */
+			DEBUG4(printk("%s: lun_data 0x%x, LUN %d\n",
+			    __func__, path->lun_data.data[l], lun);)
+
+			if (first_path == path) {
+				path_list->current_path[l] = 0;
+				path->lun_data.data[l] |=
+				    LUN_DATA_PREFERRED_PATH;
+			} else if (path->lun_data.data[l] &
+			    LUN_DATA_PREFERRED_PATH) {
+				/*
+				 * If this is not the first path added, if this
+				 * is the preferred path, so make it the
+				 * current path.
+				 */
+				path_list->current_path[l] = path->id;
+			}
+		}
+	}
+
+	LEAVE("qla4xxx_setup_new_path");
+
+	return;
+}
+
+/*
+ * qla4xxx_cfg_mem_free
+ *     Free all configuration structures.
+ *
+ * Input:
+ *      ha = adapter state pointer.
+ *
+ * Context:
+ *      Kernel context.
+ */
+void
+qla4xxx_cfg_mem_free(scsi_qla_host_t *ha)
+{
+	mp_lun_t        *cur_lun;
+	mp_lun_t        *tmp_lun; 
+	mp_device_t *dp;
+	mp_path_list_t  *path_list;
+	mp_path_t       *tmp_path, *path;
+	mp_host_t       *host, *temp;
+	mp_port_t	*temp_port;
+	struct list_head *list, *temp_list;
+	int	id, cnt;
+
+	if ((host = qla4xxx_cfg_find_host(ha)) != NULL) {
+		if( mp_num_hosts == 0 )
+			return;
+
+		for (id= 0; id < MAX_MP_DEVICES; id++) {
+			if ((dp = host->mp_devs[id]) == NULL)
+				continue;
+			if ((path_list = dp->path_list) == NULL)
+				continue;
+			if ((tmp_path = path_list->last) == NULL)
+				continue;
+			for (cnt = 0; cnt < path_list->path_cnt; cnt++) {
+				path = tmp_path;
+				tmp_path = tmp_path->next;
+				DEBUG(printk(KERN_INFO
+						"host%d - Removing path[%d] "
+						"= %p\n",
+						host->instance,
+						cnt, path);)
+				kfree(path);
+			}
+			kfree(path_list);
+			host->mp_devs[id] = NULL;
+			/* remove dp from other hosts */
+			for (temp = mp_hosts_base; (temp); temp = temp->next) {
+				if (temp->mp_devs[id] == dp) {
+					DEBUG(printk(KERN_INFO
+						"host%d - Removing host[%d] = "
+						"%p\n",
+						host->instance,
+						temp->instance,temp);)
+					temp->mp_devs[id] = NULL;
+				}
+			}
+			/* Free all the lun struc's attached 
+			 * to this mp_device */
+			for ( cur_lun = dp->luns; (cur_lun); 
+					cur_lun = cur_lun->next) {
+				DEBUG(printk(KERN_INFO
+						"host%d - Removing lun:%p "
+						"attached to device:%p\n",
+						host->instance,
+						cur_lun,dp);)
+				list_for_each_safe(list, temp_list, 
+					&cur_lun->ports_list) {
+		
+					temp_port = list_entry(list, mp_port_t, list);
+					list_del_init(&temp_port->list);
+				
+					DEBUG(printk(KERN_INFO
+						"host%d - Removing port:%p "
+						"attached to lun:%p\n",
+						host->instance, temp_port,
+						cur_lun);)
+	
+				}
+				tmp_lun = cur_lun;
+				kfree(tmp_lun);
+			}
+			kfree(dp);
+		}
+
+		/* remove this host from host list */
+		temp = mp_hosts_base;
+		if (temp != NULL) {
+			/* Remove from top of queue */
+			if (temp == host) {
+				mp_hosts_base = host->next;
+			} else {
+				/*
+				 * Remove from middle of queue
+				 * or bottom of queue
+				 */
+				for (temp = mp_hosts_base;
+						temp != NULL;
+						temp = temp->next) {
+
+					if (temp->next == host) {
+						temp->next = host->next;
+						break;
+					}
+				}
+			}
+		}
+		kfree(host);
+		mp_num_hosts--;
+	}
+}
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_cfg.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_cfg.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_cfg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_cfg.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,236 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2003-2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/*
+ * QLogic ISP4xxx Multi-path LUN Support
+ * Multi-path include file.
+ */
+
+#if !defined(_QLA_CFG_H)
+#define	_QLA_CFG_H
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+/*
+ * Failover definitions
+ */
+#define FAILOVER_TYPE_COUNT		4
+#define MP_NOTIFY_RESET_DETECTED	1
+#define MP_NOTIFY_PWR_LOSS		2
+#define MP_NOTIFY_LOOP_UP		3
+#define MP_NOTIFY_LOOP_DOWN		4
+#define MP_NOTIFY_BUS_RESET		5
+#define FAILOVER_TYPE_ERROR_RETRY	1
+#define MAX_NUMBER_PATHS		FO_MAX_PATHS
+#define PORT_NAME_SIZE			WWN_SIZE
+#define FAILOVER_NOTIFY_STATUS_ERROR	QLA_SUCCESS
+#define FAILOVER_NOTIFY_STATUS_SUCCESS  QLA_SUCCESS
+#define FAILOVER_NOTIFY_CDB_LENGTH_MAX	FO_NOTIFY_CDB_LENGTH_MAX
+#define MAX_TARGETS_PER_DEVICE		SDM_DEF_MAX_TARGETS_PER_DEVICE
+
+/*
+ * Limits definitions.
+ */
+#define MAX_LUNS_PER_DEVICE	MAX_LUNS	/* Maximum # of luns */
+#define MAX_MP_DEVICES		MAX_TARGETS	/* Maximum # of virtual devs */
+#define MAX_PATHS_PER_DEVICE	8		/* Maximum # of paths */
+#if !defined(MAX_LUNS)
+#define	MAX_LUNS		256
+#endif
+#define MAX_HOSTS		MAX_HBAS
+
+/* Async notification types */
+#define NOTIFY_EVENT_LINK_DOWN      1		/* Link went down */
+#define NOTIFY_EVENT_LINK_UP        2		/* Link is back up */
+#define NOTIFY_EVENT_RESET_DETECTED 3		/* Reset detected */
+
+#define VITAL_PRODUCT_DATA_SIZE		32 		/* 32 */
+#define INQ_EVPD_SET	1
+#define INQ_DEV_IDEN_PAGE  0x83  	
+#define WWLUN_SIZE	VITAL_PRODUCT_DATA_SIZE
+
+/* MACROS */
+#if 0
+#define qla4xxx_is_portname_equal(N1,N2) \
+	((memcmp((N1),(N2),WWN_SIZE)==0?TRUE:FALSE))
+#define qla4xxx_is_nodename_equal(N1,N2) \
+	((memcmp((N1),(N2),WWN_SIZE)==0?TRUE:FALSE))
+#endif
+
+/*
+ * Per-multipath driver parameters
+ */
+typedef struct _mp_lun_data {
+	uint8_t 	data[MAX_LUNS];
+#define LUN_DATA_ENABLED		BIT_7
+#define LUN_DATA_PREFERRED_PATH		BIT_6
+}
+mp_lun_data_t;
+
+
+#define PATH_INDEX_INVALID		0xff
+
+/*
+ * Per-device collection of all paths.
+ */
+typedef struct _mp_path_list {
+	struct _mp_path *last;		/* ptrs to end of circular list of paths */
+	uint8_t		path_cnt;	/* number of paths */
+	uint8_t		visible;	/* visible path */
+	uint16_t	reserved1;	/* Memory alignment */
+	uint32_t	reserved2;	/* Memory alignment */
+	uint8_t		current_path[ MAX_LUNS_PER_DEVICE ]; /* current path for a given lun */
+	uint16_t	failover_cnt[ FAILOVER_TYPE_COUNT ];
+}
+mp_path_list_t;
+
+/*
+ * Definitions for failover notify SRBs.  These SRBs contain failover notify
+ * CDBs to notify a target that a failover has occurred.
+ *
+ */
+typedef struct _failover_notify_srb {
+	srb_t		*srb;
+	uint16_t	status;
+	uint16_t	reserved;
+}
+failover_notify_srb_t;
+
+typedef struct _mp_lun {
+   	struct _mp_lun   	*next;
+	struct _mp_device	*dp; 			/* Multipath device */
+	int			number;			/* actual lun number */
+	fc_lun_t	*paths[MAX_PATHS_PER_DEVICE];	/* list of fcluns */
+	struct list_head	ports_list;
+	int			path_cnt;		/* Must be > 1 for fo device  */
+	int			siz;			/* Size of wwuln  */
+	uint8_t		wwuln[WWLUN_SIZE];/* lun id from inquiry page 83. */
+}
+mp_lun_t;
+
+typedef struct _mp_port {
+    	struct list_head   list;
+	uint8_t		iscsiname[ISCSI_NAME_SIZE];
+	uint8_t		path_list[ MAX_HOSTS ]; /* path index for a given HBA */
+	scsi_qla_host_t	*hba_list[ MAX_HOSTS ];
+	int		cnt;
+	int		fo_cnt;
+	ulong 	total_blks;	/* blocks transferred on this port */
+}
+mp_port_t;
+
+/*
+ * Per-device multipath control data.
+ */
+typedef struct _mp_device {
+	mp_path_list_t	*path_list;		/* Path list for device.  */
+	int				dev_id;
+	int			use_cnt;	/* number of users */
+    	struct _mp_lun   *luns;			/* list of luns */
+	uint8_t         devname[ISCSI_NAME_SIZE];	/* World-wide node name for device. */
+
+	uint8_t         iscsinames[MAX_PATHS_PER_DEVICE][ISCSI_NAME_SIZE];
+}
+mp_device_t;
+
+/*
+ * Per-adapter multipath Host
+ */
+typedef struct _mp_host {
+	struct _mp_host	*next;	/* ptr to next host adapter in list */
+	scsi_qla_host_t	*ha;	/* ptr to lower-level driver adapter struct */
+	int		instance;	/* OS instance number */
+	struct list_head *fcports;	/* Port chain for this adapter */
+	mp_device_t	*mp_devs[MAX_MP_DEVICES]; /* Multipath devices */
+
+	uint32_t	flags;
+#define MP_HOST_FLAG_NEEDS_UPDATE  BIT_0  /* Need to update device data. */
+#define MP_HOST_FLAG_FO_ENABLED	   BIT_1  /* Failover enabled for this host */
+#define MP_HOST_FLAG_DISABLE	   BIT_2  /* Bypass qla_cfg. */
+#define MP_HOST_FLAG_LUN_FO_ENABLED   BIT_3  /* lun Failover enabled */
+
+	uint8_t     iscsiname[ISCSI_NAME_SIZE];	/* World-wide node name for device. */
+	uint16_t	MaxLunsPerTarget;
+
+	uint16_t	relogin_countdown;
+}
+mp_host_t;
+
+/*
+ * Describes path a single.
+ */
+typedef struct _mp_path {
+	struct _mp_path	*next;			/* next path in list  */
+	struct _mp_host	*host;			/* Pointer to adapter */
+	fc_port_t	*port;			/* FC port info  */
+	uint16_t	id;			/* Path id (index) */
+	uint16_t	flags;
+	uint8_t		mp_byte;		/* Multipath control byte */
+#define MP_MASK_HIDDEN		0x80
+#define MP_MASK_UNCONFIGURED	0x40
+#define MP_MASK_OVERRIDE	0x10		/* MC_MASK_SEPARATE_TARGETS */
+#define MP_MASK_PRIORITY	0x07
+
+	uint8_t		relogin;		/* Need to relogin to port */
+	uint8_t		config;			/* User configured path	*/
+	uint8_t		reserved[3];
+	mp_lun_data_t	lun_data;		/* Lun data information */
+	uint8_t     iscsiname[ISCSI_NAME_SIZE];	/* World-wide node name for device. */
+}
+mp_path_t;
+
+/*
+ * Failover notification requests from host driver.
+ */
+typedef struct failover_notify_entry {
+	struct scsi_address		*os_addr;
+}
+failover_notify_t;
+
+#if 0
+/* ** NEW simified version of T3 ** */
+typedef struct {
+	uint8_t entry_type;
+	uint8_t entry_status;
+	uint8_t system_defined;
+	uint8_t entry_count;
+
+	uint32_t  handle;
+	uint16_t  target;
+	uint16_t  connection_id;
+
+	uint8_t   control_flags;
+	uint8_t   state_flags;	
+	uint8_t   cmd_ref_num;	
+	uint8_t   reserved1;	
+	uint8_t   scsi_cdb[IOCB_MAX_CDB_LEN];
+	uint8_t   lun[8];
+	uint32_t  cmd_seq_num;	  
+	uint16_t  timeout;	 
+	uint16_t  desg_count;	
+	uint32_t  byte_count;
+	uint32_t dseg_0_address[2];
+	uint32_t dseg_0_length;
+} cmd_entry_t;
+#endif
+
+#endif /* _QLA_CFG_H */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_cfgln.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_cfgln.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_cfgln.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_cfgln.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,571 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.4.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/*
+ * QLogic ISP4xxx Multi-path LUN Support Driver 
+ * Linux specific functions
+ *
+ */
+
+// #include "ql4_os.h"
+#include "ql4_def.h"
+/*
+#include "ql4_foln.h"
+*/
+
+#define MAX_SEARCH_STR_SIZE	512
+
+/*
+ * qla4xxx_set_lun_data_from_config
+ * Set lun_data byte from the configuration parameters.
+ *
+ * Input:
+ * host -- pointer to host adapter structure.
+ * port -- pointer to port
+ * tgt  -- target number
+ * dev_no  -- device number
+ */
+void
+qla4xxx_set_lun_data_from_config(mp_host_t *host, fc_port_t *port,
+    uint16_t tgt, uint16_t dev_no)
+{
+#if 0
+	char		*propbuf;  /* As big as largest search string */
+	int		rval;
+	int16_t		lun, l;
+	scsi_qla_host_t *ha = host->ha;
+	mp_device_t	*dp;
+	lun_bit_mask_t	*plun_mask;
+	lun_bit_mask_t  *mask_ptr;
+	mp_path_list_t	*pathlist;
+
+	mp_path_t *path;
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&propbuf,
+	    MAX_SEARCH_STR_SIZE)) {
+		/* not enough memory */
+		DEBUG9_10(printk("%s(%ld): inst=%ld scrap not big enough. "
+		    "propbuf requested=%d.\n",
+		    __func__, ha->host_no, ha->instance,
+		    MAX_SEARCH_STR_SIZE);)
+		return;
+	}
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&plun_mask,
+	    sizeof(lun_bit_mask_t))) {
+		/* not enough memory */
+		DEBUG9_10(printk("%s(%ld): inst=%ld scrap not big enough. "
+		    "lun_mask requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(lun_bit_mask_t));)
+		qla4xxx_free_ioctl_scrap_mem(ha);
+		return;
+	}
+	mask_ptr = plun_mask;
+
+	dp = host->mp_devs[tgt];
+	if (dp == NULL) {
+		printk("qla4xxx_set_lun_data_from_config: Target %d "
+		    "not found for hba %d\n",tgt, host->instance);
+		qla4xxx_free_ioctl_scrap_mem(ha);
+		return;
+	}
+	if ( (pathlist = dp->path_list) == NULL ) {
+		printk("qla4xxx_set_lun_data_from_config: path list "
+		    "not found for target %d\n", tgt);
+		qla4xxx_free_ioctl_scrap_mem(ha);
+		return;
+	}
+
+	if ((path = qla4xxx_find_path_by_name(host, pathlist,
+	    port->port_name)) == NULL ) {
+		printk("qla4xxx_set_lun_data_from_config: No path found "
+		    "for target %d\n", tgt);
+		qla4xxx_free_ioctl_scrap_mem(ha);
+		return;
+	}
+
+	/* Get "target-N-device-N-preferred" as a 256 bit lun_mask*/
+	sprintf(propbuf, "scsi-qla%ld-tgt-%d-di-%d-preferred", ha->instance,
+	    tgt, dev_no);
+	DEBUG3(printk("build_tree: %s\n",propbuf);)
+
+	rval = qla4xxx_get_prop_xstr(ha, propbuf,
+	    (uint8_t *)(plun_mask), sizeof(lun_bit_mask_t));
+
+	if (rval == -1) {
+		/* EMPTY */
+		DEBUG2(printk("%s(%ld): no preferred mask entry found for "
+		    "path id %d on port %02x%02x%02x%02x%02x%02x%02x%02x.\n",
+		    __func__, ha->host_no, path->id,
+		    path->portname[0], path->portname[1],
+		    path->portname[2], path->portname[3],
+		    path->portname[4], path->portname[5],
+		    path->portname[6], path->portname[7]);)
+	} else {
+		if (rval != sizeof(lun_bit_mask_t)) {
+			/* EMPTY */
+			printk("qla4xxx_set_lun_data_from_config: "
+			    "Preferred mask len %d is incorrect.\n", rval);
+		}
+
+		DEBUG3(printk("%s(%ld): reading Preferred Mask for path id %d "
+		    "on port %02x%02x%02x%02x%02x%02x%02x%02x:\n",
+		    __func__, ha->host_no, path->id,
+		    path->portname[0], path->portname[1],
+		    path->portname[2], path->portname[3],
+		    path->portname[4], path->portname[5],
+		    path->portname[6], path->portname[7]);)
+		DEBUG3(qla4xxx_dump_buffer((char *)plun_mask,
+		    sizeof(lun_bit_mask_t));)
+
+		for (lun = MAX_LUNS-1, l =0; lun >= 0; lun--, l++ ) {
+			if (EXT_IS_LUN_BIT_SET(mask_ptr, lun)) {
+				path->lun_data.data[l] |=
+				    LUN_DATA_PREFERRED_PATH;
+				pathlist->current_path[l] = path->id;
+			} else {
+				path->lun_data.data[l] &=
+				    ~LUN_DATA_PREFERRED_PATH;
+			}
+		}
+
+	}
+
+	/* Get "target-N-device-N-lun-disable" as a 256 bit lun_mask*/
+	sprintf(propbuf, "scsi-qla%ld-tgt-%d-di-%d-lun-disabled", ha->instance,
+	    tgt, dev_no);
+	DEBUG3(printk("build_tree: %s\n",propbuf);)
+
+	rval = qla4xxx_get_prop_xstr(ha, propbuf,
+	    (uint8_t *)plun_mask, sizeof(lun_bit_mask_t));
+	if (rval == -1) {
+		/* default: all luns enabled */
+		DEBUG3(printk("%s(%ld): no entry found for path id %d. "
+		    "Assume all LUNs enabled on port %02x%02x%02x%02x%02x%"
+		    "02x%02x%02x.\n",
+		    __func__, ha->host_no, path->id,
+		    path->portname[0], path->portname[1],
+		    path->portname[2], path->portname[3],
+		    path->portname[4], path->portname[5],
+		    path->portname[6], path->portname[7]);)
+
+		for (lun = 0; lun < MAX_LUNS; lun++) {
+			path->lun_data.data[lun] |= LUN_DATA_ENABLED;
+		}
+	} else {
+		if (rval != sizeof(lun_bit_mask_t)) {
+			printk("qla4xxx_set_lun_data_from_config: Enable "
+			    "mask has wrong size %d != %ld\n",
+			    rval, (ulong)sizeof(lun_bit_mask_t));
+		} else {
+			for (lun = MAX_LUNS-1, l =0; lun >= 0; lun--, l++) {
+				/* our bit mask is inverted */
+				if (!EXT_IS_LUN_BIT_SET(mask_ptr,lun))
+					path->lun_data.data[l] |=
+					    LUN_DATA_ENABLED;
+				else
+					path->lun_data.data[l] &=
+					    ~LUN_DATA_ENABLED;
+			}
+			DEBUG3(printk("%s(%ld): got lun mask for path id %d "
+			    "port %02x%02x%02x%02x%02x%02x%02x%02x:\n",
+			    __func__, ha->host_no, path->id,
+			    path->portname[0], path->portname[1],
+			    path->portname[2], path->portname[3],
+			    path->portname[4], path->portname[5],
+			    path->portname[6], path->portname[7]);)
+			DEBUG3(qla4xxx_dump_buffer(
+			    (uint8_t *)&path->lun_data.data[0], 64);)
+		}
+	}
+
+	DEBUG3(printk("qla4xxx_set_lun_data_from_config: Luns data for "
+	    "device %p, instance %d, path id=%d\n",
+	    dp,host->instance,path->id);)
+	DEBUG3(qla4xxx_dump_buffer((char *)&path->lun_data.data[0], 64);)
+
+	qla4xxx_free_ioctl_scrap_mem(ha);
+	LEAVE("qla4xxx_set_lun_data_from_config");
+#endif
+}
+
+
+
+/*
+ * qla4xxx_cfg_build_path_tree
+ *	Find all path properties and build a path tree. The
+ *  resulting tree has no actual port assigned to it
+ *  until the port discovery is done by the lower level.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+void
+qla4xxx_cfg_build_path_tree(scsi_qla_host_t *ha)
+{
+#if 0
+	char		*propbuf;
+	uint8_t		node_name[WWN_SIZE];
+	uint8_t		port_name[WWN_SIZE];
+	fc_port_t	*port;
+	uint16_t	dev_no = 0, tgt;
+	int		instance, rval;
+	mp_host_t	*host = NULL;
+	uint8_t		*name;
+	int		done;
+	uint8_t         control_byte;
+
+
+	ENTER("qla4xxx_cfg_build_path_tree");
+
+	printk(KERN_INFO
+	    "qla02%d: ConfigRequired is set. \n", (int)ha->instance);
+	DEBUG(printk("qla4xxx_cfg_build_path_tree: hba =%d",
+	    (int)ha->instance);)
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&propbuf,
+	    MAX_SEARCH_STR_SIZE)) {
+		/* not enough memory */
+		DEBUG9_10(printk("%s(%ld): inst=%ld scrap not big enough. "
+		    "propbuf requested=%d.\n",
+		    __func__, ha->host_no, ha->instance,
+		    MAX_SEARCH_STR_SIZE);)
+		return;
+	}
+
+	/* Look for adapter nodename in properties */
+	sprintf(propbuf, "scsi-qla%ld-adapter-port", ha->instance);
+	DEBUG(printk("build_tree: %s\n",propbuf);)
+
+	rval = qla4xxx_get_prop_xstr(ha, propbuf, port_name, WWN_SIZE);
+	if (rval != WWN_SIZE) {
+		qla4xxx_free_ioctl_scrap_mem(ha);
+		return;
+	}
+
+	/* Does nodename match the host adapter nodename? */
+	name = 	&ha->init_cb->port_name[0];
+	if (!qla4xxx_is_nodename_equal(name, port_name)) {
+		printk(KERN_INFO
+		    "scsi(%d): Adapter nodenames don't match - ha = %p.\n",
+		    (int)ha->instance,ha);
+		DEBUG(printk("qla(%d): Adapter nodenames don't match - "
+		    "ha=%p. port name=%02x%02x%02x%02x%02x%02x%02x%02x\n",
+		    (int)ha->instance,ha,
+		    name[0], name[1], name[2], name[3],
+		    name[4], name[5], name[6], name[7]);)
+
+		qla4xxx_free_ioctl_scrap_mem(ha);
+		return;
+	}
+
+	DEBUG(printk("%s: found entry for adapter port %02x%02x%02x%02x"
+	    "%02x%02x%02x%02x.\n",
+	    __func__,
+	    port_name[0], port_name[1], port_name[2],
+	    port_name[3], port_name[4], port_name[5],
+	    port_name[6], port_name[7]);)
+
+	instance = ha->instance;
+	if ((host = qla4xxx_alloc_host(ha)) == NULL) {
+		printk(KERN_INFO
+		    "scsi(%d): Couldn't allocate host - ha = %p.\n",
+		    (int)instance,ha);
+	} else {
+		/* create a dummy port */
+		port = kmalloc(sizeof(fc_port_t), GFP_KERNEL);
+		if (port == NULL) {
+			printk(KERN_INFO
+			    "scsi(%d): Couldn't allocate port.\n",
+			    (int)instance);
+			DEBUG(printk("qla(%d): Couldn't allocate port.\n",
+			    (int)host->instance);)
+			/* remove host */
+			qla4xxx_free_ioctl_scrap_mem(ha);
+			return;
+		}
+
+		done = 0;
+
+		/* For each target on the host bus adapter */
+		for (tgt = 0; tgt < MAX_MP_DEVICES &&
+		    !done; tgt++) {
+
+			/* get all paths for this target */
+			for (dev_no = 0; dev_no < MAX_PATHS_PER_DEVICE &&
+			    !done ; dev_no++) {
+
+				/*
+				 * O(N*M) scan, should ideally check if there
+				 * are any tgt entries present, if not, then
+				 * continue.
+				 *
+				 *   sprintf(propbuf,
+				 * 		"scsi-qla%d-tgt-%d-",
+				 *		instance, tgt);
+				 *   if (strstr(ha->cmdline, propbuf) == NULL)
+				 *	continue;
+				 *
+				 */
+				memset(port, 0, sizeof (fc_port_t));
+
+				/*
+				 * Get "target-N-device-N-node" is a 16-chars
+				 * number
+				 */
+				sprintf(propbuf,
+				    "scsi-qla%ld-tgt-%d-di-%d-node",
+				    ha->instance, tgt, dev_no);
+
+				rval = qla4xxx_get_prop_xstr(ha, propbuf,
+				    node_name, WWN_SIZE);
+				if (rval != WWN_SIZE)
+					/* di values may not be contiguous for
+					 * override case.
+					 */
+					continue;
+
+				DEBUG(printk("build_tree: %s\n",propbuf);)
+				memcpy(port->node_name, node_name, WWN_SIZE);
+
+				/*
+				 * Get "target-N-device-N-port" is a 16-chars
+				 * number
+				 */
+				sprintf(propbuf,
+				    "scsi-qla%ld-tgt-%d-di-%d-port",
+				    ha->instance, tgt, dev_no);
+
+				rval = qla4xxx_get_prop_xstr(ha, propbuf,
+				    port_name, WWN_SIZE);
+				if (rval != WWN_SIZE)
+					continue;
+
+				DEBUG(printk("build_tree: %s\n",propbuf);)
+				memcpy(port->node_name, node_name, WWN_SIZE);
+				memcpy(port->port_name, port_name, WWN_SIZE);
+				port->flags |= FCF_CONFIG;
+
+				/*
+				 * Get "target-N-device-N-control" if property 
+				 * is present then all luns are visible.
+				 */
+				sprintf(propbuf,
+				    "scsi-qla%ld-tgt-%d-di-%d-control",
+				    ha->instance, tgt, dev_no);
+				rval = qla4xxx_get_prop_xstr(ha, propbuf,
+				    (uint8_t *)(&control_byte),
+				    sizeof(control_byte));
+				if (rval == -1) {
+					/* error getting string. go to next. */
+					DEBUG2(printk(
+					    "%s: string parsing failed.\n",
+					    __func__);)
+					continue;
+				}
+
+				DEBUG3(printk("build_tree: %s\n",propbuf);)
+
+				DEBUG(printk("build_tree: control byte 0x%x\n",
+				    control_byte);)
+
+				port->mp_byte = control_byte;
+				DEBUG(printk("%s(%ld): calling update_mp_device"
+				    " for host %p port %p-%02x%02x%02x%02x%02x"
+				    "%02x%02x%02x tgt=%d mpbyte=%02x.\n",
+				    __func__, ha->host_no, host, port,
+				    port->port_name[0], port->port_name[1],
+				    port->port_name[2], port->port_name[3],
+				    port->port_name[4], port->port_name[5],
+				    port->port_name[6], port->port_name[7],
+				    tgt, port->mp_byte);)
+
+				qla4xxx_update_mp_device(host, port, tgt,
+				    dev_no);
+
+				/* free any mplun info */
+
+				qla4xxx_set_lun_data_from_config(host,
+				    port, tgt, dev_no);
+			}
+		}
+		kfree(port);
+	}
+
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	LEAVE("qla4xxx_cfg_build_path_tree");
+	DEBUG(printk("Leaving: qla4xxx_cfg_build_path_tree\n");)
+#endif
+}
+
+/*
+ * qla4xxx_cfg_display_devices
+ *      This routine will the node names of the different devices found
+ *      after port inquiry.
+ *
+ * Input:
+ *
+ * Returns:
+ *      None.
+ */
+void
+qla4xxx_cfg_display_devices(int flag)
+{
+	mp_host_t     *host;
+	int     id;
+	mp_device_t	*dp;
+	mp_path_t  *path;
+	mp_path_list_t	*path_list;
+	int cnt, i, dev_no;
+	int instance;
+#if 0
+	int	mask_set;
+	uint8_t	l;
+#endif
+	mp_lun_t	*lun;
+	unsigned char 	tmp_buf[32];
+
+	for (host = mp_hosts_base; (host); host = host->next) {
+
+		instance = (int) host->instance;
+		/* Display the node name for adapter */
+		printk(KERN_INFO
+			"scsi-qla%d-adapter-port="
+			"%s\\;\n",
+			instance,
+			host->iscsiname);
+
+		for (id = 0; id < MAX_MP_DEVICES; id++) {
+			if( (dp = host->mp_devs[id] ) == NULL )
+				continue;
+
+			path_list = dp->path_list;
+
+
+			if( (path = path_list->last) != NULL ) {
+				/* Print out device port names */
+				path = path->next; /* first path */
+				for (dev_no = 0,  cnt = 0;
+					cnt < path_list->path_cnt;
+					path = path->next, cnt++) {
+
+					/* skip others if not our host */
+					if (host != path->host)
+						continue;
+					printk(KERN_INFO
+						"scsi-qla%d-tgt-%d-di-%d-name="
+						"%s\\;\n",
+						instance, id, path->id,
+						dp->devname);
+
+					/* port_name */
+					printk(KERN_INFO
+						"scsi-qla%d-tgt-%d-di-%d-port="
+						"%s\\;\n",
+						instance, id, path->id,
+						path->iscsiname);
+
+					/* control byte */
+					printk(KERN_INFO
+						"scsi-qla%d-tgt-%d-di-%d-"
+						"control=%02x\\;\n",
+						instance, id, path->id,
+						path->mp_byte);
+
+					/*
+					 * Build preferred bit mask for this
+					 * path */
+#if 0
+					memset(&lun_mask, 0, sizeof(lun_mask));
+					mask_set = 0;
+					for (i = 0; i < MAX_LUNS; i++) {
+						l = (uint8_t)(i & 0xFF);
+						if (path_list->current_path[l] == path->id ) {
+							lun_mask |= (lun_mask << l);
+							mask_set++;
+						}
+					}
+					if (mask_set) {
+						printk(KERN_INFO
+							"scsi-qla%d-tgt-%d-di-%d-preferred=%08x%08x%08x%08x%08x%08x%08x%08x\\;\n",
+							instance,  id, path->id,
+							*((uint32_t *) &lun_mask.mask[28]),
+							*((uint32_t *) &lun_mask.mask[24]),
+							*((uint32_t *) &lun_mask.mask[20]),
+							*((uint32_t *) &lun_mask.mask[16]),
+							*((uint32_t *) &lun_mask.mask[12]),
+							*((uint32_t *) &lun_mask.mask[8]),
+							*((uint32_t *) &lun_mask.mask[4]),
+							*((uint32_t *) &lun_mask.mask[0]) );
+					}
+					/*
+					 * Build disable bit mask for this path
+					 */
+					mask_set = 0;
+					for (i = 0; i < MAX_LUNS; i++) {
+						l = (uint8_t)(i & 0xFF);
+						if (!(path->lun_data.data[l] &
+							LUN_DATA_ENABLED) ) {
+
+							mask_set++;
+						}
+					}
+					if (mask_set) {
+						printk(KERN_INFO
+							"scsi-qla%d-tgt-%d-di-%d-lun-disable=%08x%08x%08x%08x%08x%08x%08x%08x\\;\n",
+							instance,  id, path->id,
+							*((uint32_t *) &lun_mask.mask[28]),
+							*((uint32_t *) &lun_mask.mask[24]),
+							*((uint32_t *) &lun_mask.mask[20]),
+							*((uint32_t *) &lun_mask.mask[16]),
+							*((uint32_t *) &lun_mask.mask[12]),
+							*((uint32_t *) &lun_mask.mask[8]),
+							*((uint32_t *) &lun_mask.mask[4]),
+							*((uint32_t *) &lun_mask.mask[0]) );
+					}
+#endif
+					/* display lun wwuln */
+					if( flag )
+					for (lun = dp->luns; lun != NULL ; lun = lun->next) {
+						printk(KERN_INFO
+							"scsi-qla%d-tgt-%d-di-%d-lun-%d-lunid=",
+							instance,  id, path->id, lun->number);
+						for (i = 0 ; i < lun->siz ;
+							       	i++) {
+							sprintf(tmp_buf+i,
+								"%02x", 
+							  lun->wwuln[i]);
+						}
+						printk(KERN_INFO "%s:%02d;\n",
+							tmp_buf,lun->siz); 
+					}
+					dev_no++;
+				}
+
+			}
+		}
+	}
+}
+
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_dbg.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_dbg.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_dbg.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,689 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	qla4xxx_get_debug_level
+ *	qla4xxx_set_debug_level
+ *	printchar
+ *	qla4xxx_dump_bytes
+ *	qla4xxx_dump_words
+ *	qla4xxx_dump_dwords
+ *	qla4xxx_print_scsi_cmd
+ *	qla4xxx_print_srb_info
+ *	qla4xxx_print_iocb_passthru
+ *	__dump_dwords
+ *	__dump_words
+ *	__dump_registers
+ *	qla4xxx_dump_registers
+ *	__dump_mailbox_registers
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+//#define QLP1	0x00000002  // Unrecoverable error messages
+//#define QLP2	0x00000004  // Unexpected completion path error messages
+//#define QLP3	0x00000008  // Function trace messages
+//#define QLP4	0x00000010  // IOCTL trace messages
+//#define QLP5	0x00000020  // I/O & Request/Response queue trace messages
+//#define QLP6	0x00000040  // Watchdog messages (current state)
+//#define QLP7	0x00000080  // Initialization
+//#define QLP8	0x00000100  // Internal command queue traces
+//#define QLP9	0x00000200  // Unused
+//#define QLP10	0x00000400  // Extra Debug messages (dump buffers)
+//#define QLP11	0x00000800  // Mailbox & ISR Details
+//#define QLP12	0x00001000  // Enter/Leave routine messages
+//#define QLP13 0x00002000  // Display data for Inquiry, TUR, ReqSense, RptLuns
+//#define QLP14 0x00004000
+//#define QLP15 0x00008000  // Display jiffies for IOCTL calls
+//#define QLP16 0x00010000  // Extended proc print statements (srb info)
+//#define QLP17 0x00020000  // Display NVRAM Accesses
+//#define QLP18 0x00040000  // unused
+//#define QLP19	0x00080000  // PDU info
+//#define QLP20 0x00100000  // iSNS info
+//#define QLP24 0x01000000  // Scatter/Gather info
+
+uint32_t ql_dbg_level = QLP1;
+
+/**************************************************************************
+ * qla4xxx_get_debug_level
+ *	This routine retrieves the driver's debug print level.
+ *
+ * Input:
+ *	dbg_level - driver's debug print level
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS - always
+ **************************************************************************/
+uint8_t
+qla4xxx_get_debug_level(uint32_t *dbg_level)
+{
+	*dbg_level = ql_dbg_level;
+	barrier();
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_set_debug_level
+ *	This routine sets the driver's debug print level.
+ *
+ * Input:
+ *	dbg_level - driver's debug print level
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS - always
+ **************************************************************************/
+uint8_t
+qla4xxx_set_debug_level(uint32_t dbg_level)
+{
+	ql_dbg_level = dbg_level;
+	barrier();
+	return(QLA_SUCCESS);
+}
+
+/****************************************************************************/
+/*                      Debug Print Routines                          	    */
+/****************************************************************************/
+
+void printchar(char ch)
+{
+	if (ch>=32)
+		printk("%c", ch);
+	else
+		printk(".");
+}
+
+/**************************************************************************
+ * qla4xxx_dump_bytes
+ *	This routine displays bytes in hex format
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	buffer   - data buffer to display
+ *	size     - number of bytes to display
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_dump_bytes(uint32_t dbg_mask, void *buffer, uint32_t size)
+{
+	uint32_t i;
+	uint8_t  *data = (uint8_t *)buffer;
+
+	if ((ql_dbg_level & dbg_mask) != 0) {
+		//printk("        0  1  2  3  4  5  6  7 -  8  9  A  B  C  D  E  F\n");
+		//printk("---------------------------------------------------------\n");
+
+		for (i = 0; i < size; i++, data++) {
+			if (i % 0x10 == 0) {
+				printk("%04X:  %02X", i, *data);
+			}
+			else if (i % 0x10 == 0x08) {
+				printk(" - %02X", *data);
+			}
+			else if (i % 0x10 == 0xF) {
+				printk(" %02X:  ", *data);
+				printchar(*(data-15));
+				printchar(*(data-14));
+				printchar(*(data-13));
+				printchar(*(data-12));
+				printchar(*(data-11));
+				printchar(*(data-10));
+				printchar(*(data-9));
+				printchar(*(data-8));
+				printchar(*(data-7));
+				printchar(*(data-6));
+				printchar(*(data-5));
+				printchar(*(data-4));
+				printchar(*(data-3));
+				printchar(*(data-2));
+				printchar(*(data-1));
+				printchar(*data);
+				printk("\n");
+			}
+			else {
+				printk(" %02X", *data);
+			}
+		}
+
+		if ((i != 0) && (i % 0x10)) {
+			printk("\n");
+		}
+		printk("\n");
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_dump_words
+ *	This routine displays words in hex format
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	buffer   - data buffer to display
+ *	size     - number of bytes to display
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_dump_words(uint32_t dbg_mask, void *buffer, uint32_t size)
+{
+	if ((ql_dbg_level & dbg_mask) != 0)
+		__dump_words(buffer, size);
+}
+
+/**************************************************************************
+ * qla4xxx_dump_dwords
+ *	This routine displays double words in hex format
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	buffer   - data buffer to display
+ *	size     - number of bytes to display
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_dump_dwords(uint32_t dbg_mask, void *buffer, uint32_t size)
+{
+	if ((ql_dbg_level & dbg_mask) != 0)
+		__dump_dwords(buffer, size);
+}
+
+/**************************************************************************
+ * qla4xxx_print_scsi_cmd
+ *	This routine displays the SCSI command
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	cmd      - pointer to Linux kernel command structure
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_print_scsi_cmd(uint32_t dbg_mask, struct scsi_cmnd *cmd)
+{
+	if ((ql_dbg_level & dbg_mask) != 0) {
+		int   i;
+
+		printk("SCSI Command = 0x%p, Handle=0x%p\n",
+		       cmd, cmd->host_scribble);
+
+		printk("  b=%d, t=%02xh, l=%02xh, cmd_len = %02xh\n",
+		       cmd->device->channel, cmd->device->id, cmd->device->lun,
+		       cmd->cmd_len);
+
+		printk("  CDB = ");
+		for (i = 0; i < cmd->cmd_len; i++)
+			printk("%02x ", cmd->cmnd[i]);
+
+		printk("  seg_cnt = %d\n",cmd->use_sg);
+		printk("  request buffer = 0x%p, request buffer len = 0x%x\n",
+		       cmd->request_buffer,cmd->request_bufflen);
+
+		if (cmd->use_sg) {
+			struct scatterlist *sg;
+			sg = (struct scatterlist *) cmd->request_buffer;
+			printk("  SG buffer: \n");
+			qla4xxx_dump_bytes(dbg_mask, (caddr_t)sg,
+					   (cmd->use_sg *
+					    sizeof(struct scatterlist)));
+		}
+
+		printk("  tag = %d, transfersize = 0x%x \n",
+		       cmd->tag, cmd->transfersize);
+
+		printk("  Pid = %d, SP = 0x%p\n", (int)cmd->pid, CMD_SP(cmd));
+		printk("  underflow size = 0x%x, direction=0x%x\n",
+		       cmd->underflow, cmd->sc_data_direction);
+
+		printk("  Current time (jiffies) = 0x%lx, "
+		       "timeout expires = 0x%lx\n",
+		       jiffies, cmd->eh_timeout.expires);
+	}
+}
+
+void
+qla4xxx_dump_command(scsi_qla_host_t *ha, struct scsi_cmnd *cmd )
+{
+	if (host_byte(cmd->result) == DID_OK) {
+		switch (cmd->cmnd[0]) {
+		case TEST_UNIT_READY:
+			QL4PRINT(QLP13,
+				 printk("scsi%d:%d:%d:%d: %s: "
+					"TEST_UNIT_READY "
+					"status = 0x%x\n",
+					ha->host_no, cmd->device->channel,
+					cmd->device->id, cmd->device->lun,
+					__func__, cmd->result & 0xff));
+
+			if (driver_byte(cmd->result) & DRIVER_SENSE) {
+				QL4PRINT(QLP13,
+					 printk("REQUEST_SENSE data:  "
+						"(MAX 0x20 bytes displayed)\n"));
+
+				qla4xxx_dump_bytes(QLP13, cmd->sense_buffer,
+						   MIN(0x20, sizeof(cmd->sense_buffer)));
+			}
+			break;
+		case INQUIRY:
+			QL4PRINT(QLP13, printk("scsi%d:%d:%d:%d: %s: "
+					       "INQUIRY data: "
+					       "(MAX 0x30 bytes displayed)\n",
+					       ha->host_no,
+					       cmd->device->channel,
+					       cmd->device->id,
+					       cmd->device->lun, __func__));
+
+			qla4xxx_dump_bytes(QLP13, cmd->request_buffer,
+					   MIN(0x30, cmd->request_bufflen));
+
+			if (strncmp(cmd->request_buffer,
+				    "\7f\00\00\00\7f\00\00\00", 8) == 0) {
+				QL4PRINT(QLP2,
+					 printk("scsi%d:%d:%d:%d: %s: "
+						"Device not present.  "
+						"Possible connection "
+						"problem with iSCSI router\n",
+						ha->host_no,
+						cmd->device->channel,
+						cmd->device->id,
+						cmd->device->lun, __func__));
+			}
+			break;
+		case REQUEST_SENSE:
+			QL4PRINT(QLP13,
+				 printk("scsi%d:%d:%d:%d: %s: REQUEST_SENSE "
+					"data:  (MAX 0x20 bytes displayed)\n",
+					ha->host_no, cmd->device->channel,
+					cmd->device->id, cmd->device->lun, __func__));
+
+			qla4xxx_dump_bytes(QLP13, cmd->request_buffer,
+					   MIN(0x20, cmd->request_bufflen));
+			break;
+		case REPORT_LUNS:
+			QL4PRINT(QLP13,
+				 printk("scsi%d:%d:%d:%d: %s: "
+					"REPORT_LUNS data: "
+					"(MAX 0x40 bytes displayed)\n",
+					ha->host_no, cmd->device->channel,
+					cmd->device->id, cmd->device->lun,
+					__func__));
+
+			qla4xxx_dump_bytes(QLP13, cmd->request_buffer,
+					   MIN(0x40, cmd->request_bufflen));
+			break;
+		}
+
+	}
+
+}
+
+/**************************************************************************
+ * qla4xxx_print_srb_info
+ *	This routine displays the srb structure
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	srb      - pointer to srb structure
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_print_srb_info(uint32_t dbg_mask, srb_t *srb)
+{
+	if ((ql_dbg_level & dbg_mask) != 0) {
+		printk("%s: srb = 0x%p, flags=0x%02x\n",
+		       __func__, srb, srb->flags);
+		printk("%s: entry_count = 0x%02x, active_array_index=0x%04x\n",
+		       __func__, srb->entry_count, srb->active_array_index);
+		printk("%s: cmd = 0x%p, saved_dma_handle = 0x%x\n",
+		       __func__, srb->cmd, (uint32_t) srb->saved_dma_handle);
+		printk("%s: fw_ddb_index = %d, lun = %d\n",
+		       __func__, srb->fw_ddb_index, srb->lun);
+		printk("%s: os_tov = %d, iocb_tov = %d\n",
+		       __func__, srb->os_tov, srb->iocb_tov);
+		printk("%s: cc_stat = 0x%x, r_start = 0x%lx, u_start = 0x%lx\n\n",
+		       __func__, srb->cc_stat, srb->r_start, srb->u_start);
+	}
+}
+
+void
+qla4xxx_print_iocb_passthru(uint32_t dbg_mask, scsi_qla_host_t *ha, INT_IOCB_PASSTHRU *iocb)
+{
+	if ((ql_dbg_level & dbg_mask) != 0) {
+		printk("SendDMAOffset=0x%x, RspDMAOffset=0x%x\n",
+		       iocb->SendDMAOffset, iocb->RspDMAOffset);
+		printk("IOCBCmdBuffer:\n");
+		qla4xxx_dump_bytes(dbg_mask, iocb->IOCBCmdBuffer, sizeof(iocb->IOCBCmdBuffer));
+		printk("IOCBStatusBuffer:\n");
+		qla4xxx_dump_bytes(dbg_mask, iocb->IOCBStatusBuffer, sizeof(iocb->IOCBStatusBuffer));
+		printk("SendData:  (SendData %p, Len=%d)\n", iocb->SendData, iocb->SendDataLen);
+		qla4xxx_dump_bytes(dbg_mask, iocb->SendData, iocb->SendDataLen);
+		printk("RspData:  (RspData %p, Len=%d)\n", iocb->RspData, iocb->RspDataLen);
+		qla4xxx_dump_bytes(dbg_mask, iocb->RspData, iocb->RspDataLen);
+	}
+}
+
+/* hardware_lock taken */
+void
+__dump_dwords(void *buffer, uint32_t size)
+{
+	uint32_t *data = (uint32_t *)buffer;
+	uint32_t i;
+
+	for (i = 0; i < size; i+=4, data++) {
+		if (i % 0x10 == 0) {
+			printk("%04X:  %08X", i, *data);
+		}
+		else if (i % 0x10 == 0x08) {
+			printk(" - %08X", *data);
+		}
+		else if (i % 0x10 == 0x0C) {
+			printk(" %08X\n", *data);
+		}
+		else {
+			printk(" %08X", *data);
+		}
+	}
+	if ((i != 0) && (i % 0x10 != 0)) {
+		printk("\n");
+	}
+}
+
+/* hardware_lock taken */
+void
+__dump_words(void *buffer, uint32_t size)
+{
+	uint16_t *data = (uint16_t *)buffer;
+	uint32_t i;
+
+	for (i = 0; i < size; i+=2, data++) {
+		if (i % 0x10 == 0) {
+			printk(KERN_INFO "%04X:  %04X", i, *data);
+		}
+		else if (i % 0x10 == 0x08) {
+			printk(KERN_INFO " - %04X", *data);
+		}
+		else if (i % 0x10 == 0x0E) {
+			uint8_t *bdata = (uint8_t *) data;
+			printk(KERN_INFO " %04X:  ", *data);
+			printchar(*(bdata-13));
+			printchar(*(bdata-14));
+			printchar(*(bdata-11));
+			printchar(*(bdata-12));
+			printchar(*(bdata-9));
+			printchar(*(bdata-10));
+			printchar(*(bdata-7));
+			printchar(*(bdata-8));
+			printchar(*(bdata-5));
+			printchar(*(bdata-6));
+			printchar(*(bdata-3));
+			printchar(*(bdata-4));
+			printchar(*(bdata-1));
+			printchar(*(bdata-2));
+			printchar(*(bdata+1));
+			printchar(*(bdata));
+			printk("\n");
+		}
+		else {
+			printk(KERN_INFO " %04X", *data);
+		}
+	}
+	if ((i != 0) && (i % 0x10 != 0)) {
+		printk(KERN_INFO "\n");
+	}
+}
+
+/* hardware_lock taken */
+void
+__dump_registers(uint32_t dbg_mask, scsi_qla_host_t *ha)
+{
+	uint8_t  i;
+
+	if ((ql_dbg_level & dbg_mask) == 0)
+		return;
+
+
+	for (i=0; i<MBOX_REG_COUNT; i++) {
+		printk(KERN_INFO "0x%02X mailbox[%d]     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, mailbox[i]), i,
+		       RD_REG_DWORD(&ha->reg->mailbox[i]));
+	}
+	printk(KERN_INFO "0x%02X flash_address   = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, flash_address),
+	       RD_REG_DWORD(&ha->reg->flash_address));
+
+	printk(KERN_INFO "0x%02X flash_data      = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, flash_data),
+	       RD_REG_DWORD(&ha->reg->flash_data));
+
+	printk(KERN_INFO "0x%02X ctrl_status     = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, ctrl_status),
+	       RD_REG_DWORD(&ha->reg->ctrl_status));
+
+	if (IS_QLA4010(ha)) {
+
+		printk(KERN_INFO "0x%02X nvram           = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u1.isp4010.nvram),
+		       RD_REG_DWORD(&ha->reg->u1.isp4010.nvram));
+	}
+	else if (IS_QLA4022(ha)) {
+
+		     printk(KERN_INFO "0x%02X intr_mask  = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u1.isp4022.intr_mask),
+			    RD_REG_DWORD(&ha->reg->u1.isp4022.intr_mask));
+
+		     printk(KERN_INFO "0x%02X nvram      = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u1.isp4022.nvram),
+			    RD_REG_DWORD(&ha->reg->u1.isp4022.nvram));
+
+		     printk(KERN_INFO "0x%02X semaphore  = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u1.isp4022.semaphore),
+			    RD_REG_DWORD(&ha->reg->u1.isp4022.semaphore));
+	}
+
+	printk(KERN_INFO "0x%02X req_q_in        = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, req_q_in),
+	       RD_REG_DWORD(&ha->reg->req_q_in));
+
+	printk(KERN_INFO "0x%02X rsp_q_out       = 0x%08X\n",
+	       (uint8_t) offsetof(isp_reg_t, rsp_q_out),
+	       RD_REG_DWORD(&ha->reg->rsp_q_out));
+
+	if (IS_QLA4010(ha)) {
+
+		printk(KERN_INFO "0x%02X ext_hw_conf     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.ext_hw_conf),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.ext_hw_conf));
+
+		printk(KERN_INFO "0x%02X port_ctrl       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.port_ctrl),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_ctrl));
+
+		printk(KERN_INFO "0x%02X port_status     = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.port_status),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_status));
+
+		printk(KERN_INFO "0x%02X req_q_out       = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.req_q_out),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.req_q_out));
+
+		printk(KERN_INFO "0x%02X gp_out          = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.gp_out),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.gp_out));
+
+		printk(KERN_INFO "0x%02X gp_in           = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.gp_in),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.gp_in));
+
+		printk(KERN_INFO "0x%02X port_err_status = 0x%08X\n",
+		       (uint8_t) offsetof(isp_reg_t, u2.isp4010.port_err_status),
+		       RD_REG_DWORD(&ha->reg->u2.isp4010.port_err_status));
+	}
+	else if (IS_QLA4022(ha)) {
+
+		     printk(KERN_INFO "Page 0 Registers:\n");
+		
+		     printk(KERN_INFO "0x%02X ext_hw_conf     = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.ext_hw_conf),
+			    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.ext_hw_conf));
+
+		     printk(KERN_INFO "0x%02X port_ctrl       = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.port_ctrl),
+			    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_ctrl));
+
+		     printk(KERN_INFO "0x%02X port_status     = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.port_status),
+			    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_status));
+
+		     printk(KERN_INFO "0x%02X gp_out          = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.gp_out),
+			    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.gp_out));
+
+		     printk(KERN_INFO "0x%02X gp_in           = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.gp_in),
+			    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.gp_in));
+
+		     printk(KERN_INFO "0x%02X port_err_status = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p0.port_err_status),
+			    RD_REG_DWORD(&ha->reg->u2.isp4022.p0.port_err_status));
+		
+		     printk(KERN_INFO "Page 1 Registers:\n");
+		
+		     WRT_REG_DWORD(&ha->reg->ctrl_status, HOST_MEM_CFG_PAGE &
+				   SET_RMASK(CSR_SCSI_PAGE_SELECT));
+
+		     printk(KERN_INFO "0x%02X req_q_out       = 0x%08X\n",
+			    (uint8_t) offsetof(isp_reg_t, u2.isp4022.p1.req_q_out),
+			    RD_REG_DWORD(&ha->reg->u2.isp4022.p1.req_q_out));
+
+		     WRT_REG_DWORD(&ha->reg->ctrl_status, PORT_CTRL_STAT_PAGE &
+				   SET_RMASK(CSR_SCSI_PAGE_SELECT));
+
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_dump_registers
+ *	This routine displays ISP registers
+ *
+ * Input:
+ *	dbg_mask - this call's debug print mask
+ *	ha       - adapter structure pointer
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ **************************************************************************/
+void
+qla4xxx_dump_registers(uint32_t dbg_mask, scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__dump_registers(dbg_mask, ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+void
+__dump_mailbox_registers(uint32_t dbg_mask, scsi_qla_host_t *ha)
+{
+	int i =  0;
+
+	if ((ql_dbg_level & dbg_mask) == 0)
+		return;
+
+	for (i = 1; i < MBOX_REG_COUNT; i++)
+		printk(KERN_INFO "  Mailbox[%d] = %08x\n", i,
+			RD_REG_DWORD(&ha->reg->mailbox[i]));
+}
+
+void
+qla4xxx_dump_buffer(uint8_t * b, uint32_t size)
+{
+	uint32_t cnt;
+	uint8_t c;
+
+	printk(" 0   1   2   3   4   5   6   7   8   9  "
+	    "Ah  Bh  Ch  Dh  Eh  Fh\n");
+	printk("----------------------------------------"
+	    "----------------------\n");
+
+	for (cnt = 0; cnt < size;) {
+		c = *b++;
+		printk("%02x",(uint32_t) c);
+		cnt++;
+		if (!(cnt % 16))
+			printk("\n");
+		else
+			printk("  ");
+	}
+	if (cnt % 16)
+		printk("\n");
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_dbg.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_dbg.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_dbg.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,138 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *
+ ****************************************************************************/
+
+/*
+ * Driver debug definitions.
+ */
+#define QLP1    0x00000002  // Unrecoverable error messages
+#define QLP2    0x00000004  // Unexpected completion path error messages
+#define QLP3    0x00000008  // Function trace messages
+#define QLP4    0x00000010  // IOCTL trace messages
+#define QLP5    0x00000020  // I/O & Request/Response queue trace messages
+#define QLP6    0x00000040  // Watchdog messages (current state)
+#define QLP7    0x00000080  // Initialization
+#define QLP8    0x00000100  // Internal command queue traces
+#define QLP9    0x00000200  // Unused
+#define QLP10   0x00000400  // Extra Debug messages (dump buffers)
+#define QLP11   0x00000800  // Mailbox & ISR Details
+#define QLP12   0x00001000  // Enter/Leave routine messages
+#define QLP13   0x00002000  // Display data for Inquiry, TUR, ReqSense, RptLuns
+#define QLP14   0x00004000  // Temporary
+#define QLP15   0x00008000  // Display jiffies for IOCTL calls
+#define QLP16   0x00010000  // Extended proc print statements (srb info)
+#define QLP17   0x00020000  // Display NVRAM Accesses
+#define QLP18   0x00040000  // unused
+#define QLP19	0x00080000  // PDU info
+#define QLP20   0x00100000  // iSNS info
+#define QLP24   0x01000000  // Scatter/Gather info
+
+extern uint32_t ql_dbg_level;
+
+/*
+ *  Debug Print Routine Prototypes.
+ */
+#define QL4PRINT(m,x) do {if(((m) & ql_dbg_level) != 0) (x);} while(0);
+#define ENTER(x) do {QL4PRINT(QLP12, printk("qla4xxx: Entering %s()\n", x));} while(0);
+#define LEAVE(x) do {QL4PRINT(QLP12, printk("qla4xxx: Leaving  %s()\n", x));} while(0);
+
+uint8_t qla4xxx_get_debug_level(uint32_t *dbg_level);
+uint8_t qla4xxx_set_debug_level(uint32_t dbg_level);
+
+void     qla4xxx_dump_bytes(uint32_t, void *, uint32_t);
+void     qla4xxx_dump_words(uint32_t, void *, uint32_t);
+void     qla4xxx_dump_dwords(uint32_t, void *, uint32_t);
+void     qla4xxx_print_scsi_cmd(uint32_t dbg_mask, struct scsi_cmnd *cmd);
+void     qla4xxx_print_srb_info(uint32_t dbg_mask, srb_t *srb);
+void     qla4xxx_print_iocb_passthru(uint32_t dbg_mask, scsi_qla_host_t *ha, INT_IOCB_PASSTHRU *iocb);
+
+/*
+ * Driver debug definitions.
+ */
+/* #define QL_DEBUG_LEVEL_1  */	/* Output register accesses to COM1 */
+/* #define QL_DEBUG_LEVEL_2  */ /* Output error msgs to COM1 */
+
+/* #define QL_DEBUG_LEVEL_3  */	/* Output function trace msgs to COM1 */
+
+// #define DEBUG(x)       do {x;} while (0);
+#define DEBUG(x)	do {} while (0);
+
+#if defined(QL_DEBUG_LEVEL_2)
+#define DEBUG2(x)       do {x;} while (0);
+#define DEBUG2_3(x)     do {x;} while (0);
+#else
+#define DEBUG2(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_3)
+#define DEBUG3(x)	do {x;} while (0);
+#else
+#define DEBUG3(x)	do {} while (0);
+  #if !defined(QL_DEBUG_LEVEL_2)
+  #define DEBUG2_3(x)	do {} while (0);
+  #endif
+#endif
+#if defined(QL_DEBUG_LEVEL_4)
+#define DEBUG4(x)	do {x;} while (0);
+#else
+#define DEBUG4(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_5)
+#define DEBUG5(x)	do {x;} while (0);
+#else
+#define DEBUG5(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_9)
+#define DEBUG9(x)	do {x;} while (0);
+#else
+#define DEBUG9(x)	do {} while (0);
+#endif
+
+void     __dump_dwords(void *, uint32_t);
+void     __dump_words(void *, uint32_t);
+void     __dump_mailbox_registers(uint32_t, scsi_qla_host_t *ha);
+void     __dump_registers(uint32_t, scsi_qla_host_t *ha);
+void     qla4xxx_dump_registers(uint32_t, scsi_qla_host_t *ha);
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_def.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_def.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_def.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_def.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,1074 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP4xxx iSCSI driver
+* Copyright (C) 2004 Qlogic Corporation
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+**
+******************************************************************************/
+
+#ifndef __QL4_DEF_H
+#define __QL4_DEF_H
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/dmapool.h>
+#include <linux/mempool.h>
+#include <linux/spinlock.h>
+#include <linux/completion.h>
+#include <asm/semaphore.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_cmnd.h>
+
+/* XXX(dg): move to pci_ids.h */
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP4000
+#define PCI_DEVICE_ID_QLOGIC_ISP4000	0x4000
+#endif
+
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP4010
+#define PCI_DEVICE_ID_QLOGIC_ISP4010	0x4010
+#endif
+
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP4022
+#define PCI_DEVICE_ID_QLOGIC_ISP4022	0x4022
+#endif
+
+#if defined(CONFIG_SCSI_QLA4XXX) || defined(CONFIG_SCSI_QLA4XXX_MODULE)
+#define IS_QLA4010(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4010)
+#define IS_QLA4022(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4022)
+#else
+#error CONFIG_SCSI_QLA4XXX must be defined for compilation.  Fix your Makefile
+#define IS_QLA4010(ha)	0
+#define IS_QLA4022(ha)	0
+#endif
+
+#if defined(CONFIG_COMPAT) && !defined(CONFIG_IA64)
+#define QLA_CONFIG_COMPAT
+#endif
+
+/*
+ * This file set some defines that are required to compile the
+ * command source for 4000 module
+ *----------------------------------------------------------------------------*/
+#define QLA4010
+#define QLA4XXX_BOARD_ID		0x4010
+#define QLA4XXX_BOARD_ID_STRING		"4010"
+#define QLA4XXX_BOARD_NAME_STRING	"QLA4010"
+#define QLA4XXX_BOARD_PORTS		1
+#define QLA4XXX_PROC_NAME		"qla4010"
+
+#define MEMORY_MAPPED_IO		1 /* 1=Memory Mapped (preferred),
+					   * 0=I/O Mapped */
+
+#define LINESIZE		256
+#define MIN(x,y)		((x)<(y)?(x):(y))
+#define MAX(x,y)		((x)>(y)?(x):(y))
+
+/*
+ * Return status codes for internal routines
+ ********************************************/
+#define QLA_SUCCESS			0
+#define QLA_ERROR			1
+
+/*
+ * Data bit definitions
+ */
+#define BIT_0	0x1
+#define BIT_1	0x2
+#define BIT_2	0x4
+#define BIT_3	0x8
+#define BIT_4	0x10
+#define BIT_5	0x20
+#define BIT_6	0x40
+#define BIT_7	0x80
+#define BIT_8	0x100
+#define BIT_9	0x200
+#define BIT_10	0x400
+#define BIT_11	0x800
+#define BIT_12	0x1000
+#define BIT_13	0x2000
+#define BIT_14	0x4000
+#define BIT_15	0x8000
+#define BIT_16	0x10000
+#define BIT_17	0x20000
+#define BIT_18	0x40000
+#define BIT_19	0x80000
+#define BIT_20	0x100000
+#define BIT_21	0x200000
+#define BIT_22	0x400000
+#define BIT_23	0x800000
+#define BIT_24	0x1000000
+#define BIT_25	0x2000000
+#define BIT_26	0x4000000
+#define BIT_27	0x8000000
+#define BIT_28	0x10000000
+#define BIT_29	0x20000000
+#define BIT_30	0x40000000
+#define BIT_31	0x80000000
+
+/*
+ * Host adapter default definitions
+ ***********************************/
+#define MAX_HBAS			16
+#define MAX_BUSES       		1
+#define MAX_TARGETS     		MAX_PRST_DEV_DB_ENTRIES + MAX_DEV_DB_ENTRIES
+#define MAX_LUNS        		256
+#define MAX_AEN_ENTRIES 		256 /* should be > EXT_DEF_MAX_AEN_QUEUE */
+#define MAX_DDB_ENTRIES 		MAX_PRST_DEV_DB_ENTRIES + MAX_DEV_DB_ENTRIES
+#define MAX_PDU_ENTRIES                 32
+#define INVALID_ENTRY			0xFFFF
+#define MAX_CMDS_TO_RISC		1024
+#define MAX_SRBS			MAX_CMDS_TO_RISC
+#define MBOX_AEN_REG_COUNT		4
+#define MAX_INIT_RETRIES		2
+
+/*
+ * Buffer sizes
+ ***************/
+#define REQUEST_QUEUE_DEPTH       	MAX_CMDS_TO_RISC
+#define RESPONSE_QUEUE_DEPTH      	64
+#define QUEUE_SIZE			64
+#define DMA_BUFFER_SIZE 		512
+
+/*
+ * Misc
+ *******/
+#define MAC_ADDR_LEN			6 /* in bytes */
+#define IP_ADDR_LEN			4 /* in bytes */
+#define DRIVER_NAME			"qla4xxx"
+
+#define MAX_LINKED_CMDS_PER_LUN		3
+#define MAX_REQS_SERVICED_PER_INTR	16
+
+
+/* Number of seconds to subtract for internal command timer */
+#define QLA_CMD_TIMER_DELTA             2
+
+
+#define	ISCSI_IPADDR_SIZE		4	/* IP address size */
+#define	ISCSI_ALIAS_SIZE		32	/* ISCSI Alais name size */
+#define	ISCSI_NAME_SIZE			255	/* ISCSI Name size  - usually a string */
+
+#define SYS_DELAY(x)		do {udelay(x);barrier();} while(0);
+#define QLA4XXX_DELAY(sec)  	do {mdelay(sec * 1000);} while(0);
+#define NVRAM_DELAY() 		do {udelay(500);} while(0); /* 500 microsecond delay */
+
+/* delay 30 seconds */
+#define RESET_DELAY()		do {int delay; for(delay=30; delay!=0; delay--) \
+				{current->state = TASK_UNINTERRUPTIBLE; \
+				schedule_timeout(1 * HZ);}} while(0);
+
+#define TOPCAT_RESET_DELAY()	do {udelay(1);} while(0);
+#define TOPCAT_POST_RESET_DELAY() do {udelay(523);} while(0);
+
+
+#define LSB(x)	((uint8_t)(x))
+#define MSB(x)	((uint8_t)((uint16_t)(x) >> 8))
+#define LSW(x)	((uint16_t)(x))
+#define MSW(x)	((uint16_t)((uint32_t)(x) >> 16))
+#define LSDW(x)	((uint32_t)((uint64_t)(x)))
+#define MSDW(x)	((uint32_t)((((uint64_t)(x)) >> 16) >> 16))
+
+#define IPAddrIsZero( _X1_ )   ((_X1_)[0] == 0 && \
+                                (_X1_)[1] == 0 && \
+                                (_X1_)[2] == 0 && \
+                                (_X1_)[3] == 0)
+
+#define IPAddrIsEqual(_X1_, _X2_) ((_X1_)[0] == (_X2_)[0] && \
+                                   (_X1_)[1] == (_X2_)[1] && \
+                                   (_X1_)[2] == (_X2_)[2] && \
+                                   (_X1_)[3] == (_X2_)[3])
+
+#define IPAddr2Uint32(_X1_,_X2_) { \
+                                  *_X2_ = 0; \
+				  *_X2_ |= _X1_[3] << 24; \
+				  *_X2_ |= _X1_[2] << 16; \
+				  *_X2_ |= _X1_[1] << 8;  \
+				  *_X2_ |= _X1_[0];}
+
+/*
+ * I/O port access macros
+ *************************/
+#if MEMORY_MAPPED_IO
+#   define RD_REG_BYTE(addr)	     readb(addr)
+#   define RD_REG_WORD(addr)         readw(addr)
+#   define RD_REG_DWORD(addr)        readl(addr)
+#   define WRT_REG_BYTE(addr, data)  writeb(data, addr)
+#   define WRT_REG_WORD(addr, data)  writew(data, addr)
+#   define WRT_REG_DWORD(addr, data) writel(data, addr)
+#else
+#   define RD_REG_BYTE(addr)	     (inb((u_long)addr))
+#   define RD_REG_WORD(addr)         (inw((u_long)addr))
+#   define RD_REG_DWORD(addr)        (inl((u_long)addr))
+#   define WRT_REG_BYTE(addr, data)  (outb(data,(u_long)addr))
+#   define WRT_REG_WORD(addr, data)  (outw((data),(u_long)addr))
+#   define WRT_REG_DWORD(addr, data) (outl((data),(u_long)addr))
+#endif
+
+#define PCI_POSTING(a) (RD_REG_DWORD(a))
+
+#include "ql4_os.h"
+#include "ql4_fw.h"
+#include "ql4_nvram.h"
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * Retry & Timeout Values
+ *************************/
+#define MBOX_TOV			30
+#define SOFT_RESET_TOV			30
+#define RESET_INTR_TOV			3
+#define SEMAPHORE_TOV			10
+#define ADAPTER_INIT_TOV		120
+#define ADAPTER_RESET_TOV		180
+#define INTERNAL_PASSTHRU__TOV		60
+#define EXTEND_CMD_TOV			60
+#define WAIT_CMD_TOV			30
+#define EH_WAIT_CMD_TOV			120
+#define FIRMWARE_UP_TOV			60
+#define RESET_FIRMWARE_TOV        	30
+#define LOGOUT_TOV			10
+#define IOCB_TOV_MARGIN			10
+#define RELOGIN_TOV			18
+#define ISNS_DEREG_TOV			5
+
+#define MAX_RESET_HA_RETRIES		2
+
+/*---------------------------------------------------------------------------*/
+/*
+ * SCSI Request Block structure  (srb)  that is placed
+ * on cmd->SCp location of every I/O     [We have 22 bytes available]
+ */
+typedef struct _srb_t {
+	struct list_head   list_entry;		/* (8)   */
+	struct scsi_qla_host *ha;		/* HA the SP is queued on */
+
+	uint16_t     flags;		/* (1) Status flags. */
+	#define SRB_TIMEOUT		BIT_0	/* timed out. */
+	#define SRB_ABORT_PENDING	BIT_1	/* abort sent to device. */
+	#define SRB_ABORTED		BIT_2	/* aborted command already. */
+	#define SRB_DMA_VALID		BIT_3	/* DMA Buffer mapped. */
+	#define SRB_GOT_SENSE		BIT_4	/* sense data recieved. */
+	#define SRB_IOCTL_CMD		BIT_5	/* generated from an IOCTL. */
+	#define SRB_INTERNAL_CMD	BIT_6	/* generated internally. */
+	#define SRB_BUSY		BIT_7	/* in busy retry state. */
+	#define SRB_FO_CANCEL		BIT_8	/* don't need to failover. */
+	#define SRB_RETRY		BIT_9	/* needs retrying. */
+	#define SRB_TAPE		BIT_10	/* FCP2 (Tape) command. */
+	#define SRB_FAILOVER		BIT_11	/* being failed-over. */
+	#define SRB_UNCONFIGURED	BIT_12
+
+
+	uint8_t     state;		/* (1) Status flags. */
+	#define SRB_NO_QUEUE_STATE	 0	/* Request is in between states */
+	#define SRB_FREE_STATE		 1
+	#define SRB_PENDING_STATE	 2
+	#define SRB_ACTIVE_STATE	 3
+	#define SRB_ACTIVE_TIMEOUT_STATE 4
+	#define SRB_RETRY_STATE	 	 5
+	#define SRB_DONE_STATE	 	 6
+	#define SRB_SUSPENDED_STATE  	 7    /* Request in suspended state */
+	#define SRB_FAILOVER_STATE 	 8    /* Request in Failover Queue */
+
+	#define SRB_STATE_TBL()	  	  \
+	{	    			  \
+            "NO_QUEUE"	        	, \
+            "FREE"		        , \
+            "PENDING"	        	, \
+	    "ACTIVE"	        	, \
+	    "ACTIVE_TIMEOUT"        	, \
+	    "RETRY"	        	, \
+	    "DONE"	        	, \
+	    "SUSPENDED"	        	, \
+	    "FAILOVER"	        	, \
+	    NULL			  \
+	}
+
+	uint8_t     entry_count;		/* (1) number of request queue
+						 *     entries used */
+	uint16_t    reserved2;
+	uint16_t    active_array_index;
+
+	struct scsi_cmnd  *cmd;			/* (4) SCSI command block */
+	dma_addr_t  saved_dma_handle;		/* (4) for unmap of single transfers */
+	atomic_t    ref_count;			/* reference count for this srb */
+	uint32_t    fw_ddb_index;
+	/* Target/LUN queue pointers. */
+	struct os_tgt *tgt_queue;	/* ptr to visible ha's target */
+	struct os_lun *lun_queue;	/* ptr to visible ha's lun */
+	struct fc_lun *fclun;		/* FC LUN context pointer. */
+	/* Raw completion info for use by failover ? */
+	uint8_t fo_retry_cnt;			/* Retry count this request */
+	uint8_t err_id;		/* error id */
+	#define SRB_ERR_PORT       1    /* Request failed because "port down" */
+	#define SRB_ERR_LOOP       2    /* Request failed because "loop down" */
+	#define SRB_ERR_DEVICE     3    /* Request failed because "device error" */
+	#define SRB_ERR_OTHER      4
+
+	uint32_t    lun;
+	struct      timer_list   timer;		 /* used to timeout command */
+	uint16_t    os_tov;
+	uint16_t    iocb_tov;
+	uint16_t    iocb_cnt;
+	uint16_t    cc_stat;
+	u_long      r_start;	      /* Time we recieve a cmd from OS*/
+	u_long      u_start;	      /* Time when we handed the cmd to F/W */
+} srb_t;
+
+/*
+ * SCSI Target Queue structure
+ */
+typedef struct os_tgt {
+	struct os_lun		*olun[MAX_LUNS];	 /* LUN context pointer. */
+	struct scsi_qla_host	*ha;
+	uint32_t		down_timer;
+	struct fc_port		*fcport;		/* Current fcport for this target */
+	unsigned long		flags;
+	uint8_t			port_down_retry_count;
+	uint8_t			id;
+
+	/* Persistent binding information */
+	uint16_t		ddb_index;
+	uint8_t			iscsi_name[ISCSI_NAME_SIZE];
+	//uint8_t	 	ip_addr[ISCSI_IPADDR_SIZE];
+	//uint8_t	 	alias[ISCSI_ALIAS_SIZE];
+	uint8_t			*name;
+} os_tgt_t;
+
+/*
+ * SCSI Target Queue flags
+ */
+#define TQF_ONLINE		0		/* Device online to OS. */
+#define TQF_SUSPENDED		1
+#define TQF_RETRY_CMDS		2
+
+/*
+ * LUN structure
+ */
+typedef struct os_lun {
+	struct fc_lun *fclun;		/* FC LUN context pointer. */
+	struct list_head list_entry;	/* 16 x10 For suspended lun list */
+	spinlock_t lun_lock;		/* 24 x18 For suspended lun list */
+	unsigned long           flags;
+	#define LS_LUN_DELAYED		0
+
+	uint8_t lun_state;		/* 00 x00 */
+	#define LS_LUN_READY		0   /* LUN is ready to accept commands */
+	#define LS_LUN_SUSPENDED	1   /* LUN is suspended */
+	#define LS_LUN_RETRY		2   /* LUN is retrying commands */
+	#define LS_LUN_TIMEOUT		3   /*  */
+	#define LUN_STATE_TBL()		  \
+	{				  \
+		"READY"			, \
+		"SUSPENDED"		, \
+		"RETRY"			, \
+		"TIMEOUT"		, \
+		NULL			  \
+	}
+
+	uint8_t out_count;		/* 01 x01 Number of outstanding commands */
+	uint8_t lun;			/* 02 x02 Lun number */
+
+	uint8_t retry_count;		/* 03 x03 Number of times lun is suspended */
+	uint8_t max_retry_count;	/* 04 x04 Max number of times lun can be */
+					/*        suspended before returning commands */
+	uint8_t reserved[3];		/* 05 x05 */
+	uint32_t tot_io_count;		/* 08 x08 Total num outstanding I/Os */
+	atomic_t suspend_timer;		/* 12 x0c Timer for suspending lun */
+	//struct list_head list_entry;	/* 16 x10 List structure for suspended lun list */
+	//spinlock_t lun_lock;		/* 24 x18 Spinlock for suspended lun list */
+} os_lun_t;
+
+/* Never set this to Zero */
+#define SUSPEND_SECONDS	6		
+#define SUSPEND_RETRIES	1
+
+/* LUN BitMask structure definition, array of 32bit words,
+ * 1 bit per lun.  When bit == 1, the lun is masked.
+ * Most significant bit of mask[0] is lun 0, bit 24 is lun 7.
+ */
+typedef struct lun_bit_mask {
+	/* Must allocate at least enough bits to accomodate all LUNs */
+#if ((MAX_LUNS & 0x7) == 0)
+	UINT8   mask[MAX_LUNS >> 3];
+#else
+	uint8_t mask[(MAX_LUNS + 8) >> 3];
+#endif
+} lun_bit_mask_t;
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * Device Database (DDB) structure
+ */
+
+typedef struct ddb_entry {
+	struct list_head   list_entry;	/* 00 x00 */
+	uint16_t bus;			/* 08 x08 SCSI bus number */
+	uint16_t target;		/* 10 x0a SCSI target ID */
+	struct fc_port          *fcport;
+	uint16_t fw_ddb_index;		/* 12 x0c DDB index from firmware's DEV_DB structure */
+	uint16_t out_count;		/* 14 x0e Number of active commands */
+
+	uint8_t  num_valid_luns;	/* 16 x10 Number of valid luns */
+	uint8_t  reserved[3];		/* 17 x11 */
+
+	/* refer to MBOX_CMD_GET_DATABASE_ENTRY for fw_ddb_fw_ddb_device_state definitions   */
+	uint32_t fw_ddb_device_state;		/* 20 x14 Device State */
+	#define DDB_STATE_TBL(){	\
+                "UNASSIGNED",           \
+		"NO_CONNECTION_ACTIVE", \
+		"DISCOVERY",            \
+		"NO_SESSION_ACTIVE",    \
+		"SESSION_ACTIVE",       \
+		"LOGGING_OUT",          \
+		"SESSION_FAILED",       \
+		NULL                    \
+	}
+	uint32_t CmdSn;			/* 24 x18 */
+	uint16_t target_session_id;	/* 28 x1c */
+	uint16_t connection_id;		/* 30 x1e */
+	uint16_t exe_throttle;		/* 32 x20 Max mumber of cmds outstanding simultaneously */
+	uint16_t task_mgmt_timeout;		/* 34 x22 Min time for task mgmt cmds to complete */
+	uint16_t default_relogin_timeout;	 /*36 x24 Max time to wait for relogin to complete */
+	uint16_t tcp_source_port_num;		/* 38 x26 */
+	uint32_t default_time2wait;		/* 40 x28 Default Min time between relogins (+aens) */
+	atomic_t port_down_timer;		/* 44 x2c Device down time */
+	atomic_t retry_relogin_timer;		/* 48 x30 Min Time between relogins (4000 only)*/
+	atomic_t relogin_timer;		/* 52 x34 Max Time to wait for relogin to complete */
+	atomic_t relogin_retry_count;		/* 56 x38 Num of times relogin has been retried */
+	atomic_t state;			/* 60 x3c Device State*/
+	#define DEV_STATE_DEAD		0 /* We can no longer talk to this device */
+	#define DEV_STATE_ONLINE	1 /* Device ready to accept commands */
+	#define DEV_STATE_MISSING	2 /* Device logged off, trying to re-login */
+	#define DEV_STATE_TBL(){	  \
+		"DEAD"			, \
+		"ONLINE"		, \
+		"MISSING"		, \
+		NULL			  \
+	}
+	unsigned long flags;			/* 64 x40 */
+	#define DF_RELOGIN		0  /* Relogin to device */
+	#define DF_NO_RELOGIN		1  /* Do not relogin if IOCTL logged it out */
+	#define DF_ISNS_DISCOVERED	2  /* Device was discovered via iSNS */
+
+	uint8_t  ip_addr[ISCSI_IPADDR_SIZE];
+	// uint8_t  ip_addr[4];		 /* 68 x44 */
+	uint8_t  iscsi_name[ISCSI_NAME_SIZE];	 /* 72 x48 */
+	// uint8_t  iscsi_name[0x100];	 /* 72 x48 */
+	// lun_entry_t *lun_table[MAX_LUNS];/*328 x148 */
+} ddb_entry_t;				 /*840 x348 */
+
+/*
+ * Fibre channel port type.
+ */
+typedef enum {
+	FCT_UNKNOWN,
+	FCT_RSCN,
+	FCT_SWITCH,
+	FCT_BROADCAST,
+	FCT_INITIATOR,
+	FCT_TARGET
+} fc_port_type_t;
+
+/*
+ * Fibre channel port structure.
+ */
+typedef struct fc_port {
+	struct list_head list;
+	struct list_head fcluns;
+
+	struct scsi_qla_host *ha;
+	struct scsi_qla_host *vis_ha;		/* only used when suspending lun */
+	ddb_entry_t     *ddbptr;
+
+	uint8_t  *iscsi_name;
+	// uint8_t  ip_addr[ISCSI_IPADDR_SIZE];
+	fc_port_type_t port_type;
+
+	atomic_t state;
+	uint32_t flags;
+
+	os_tgt_t *tgt_queue;
+	uint16_t os_target_id;
+	uint8_t device_type;
+	uint8_t unused;
+
+	uint8_t mp_byte;		/* multi-path byte (not used) */
+	uint8_t cur_path;		/* current path id */
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	int16_t cfg_id;			/* index into cfg device table */
+	uint16_t notify_type;
+	int (*fo_combine)(void *, uint16_t, struct fc_port *, uint16_t);
+	int (*fo_detect)(void);
+	int (*fo_notify)(void);
+	int (*fo_select)(void);
+#endif
+
+	lun_bit_mask_t lun_mask;
+	int loop_id;
+} fc_port_t;
+
+
+/*
+ * Fibre channel port/lun states.
+ */
+#define FCS_UNCONFIGURED	1
+#define FCS_DEVICE_DEAD		2
+#define FCS_DEVICE_LOST		3
+#define FCS_ONLINE		4
+#define FCS_NOT_SUPPORTED	5
+#define FCS_FAILOVER		6
+#define FCS_FAILOVER_FAILED	7
+
+/*
+ * FC port flags.
+ */
+#define FCF_FABRIC_DEVICE	BIT_0
+#define	FCF_INITIATOR_DEVICE	BIT_1
+#define FCF_FO_MASKED		BIT_2
+#define FCF_FAILOVER_NEEDED	BIT_3
+#define FCF_RESET_NEEDED	BIT_4
+#define FCF_PERSISTENT_BOUND	BIT_5
+#define FCF_TAPE_PRESENT	BIT_6
+#define FCF_XP_DEVICE            BIT_7
+#define FCF_CONFIG_DEVICE        BIT_8
+#define FCF_MSA_DEVICE            BIT_9
+#define FCF_MSA_PORT_ACTIVE     BIT_10
+#define FCF_LOGIN_NEEDED		BIT_12
+#define FCF_EVA_DEVICE            BIT_13
+
+#define FCF_RLC_SUPPORT		BIT_14
+#define FCF_CONFIG		BIT_15	/* Needed? */
+#define FCF_RESCAN_NEEDED	BIT_16
+#define FCF_FAILBACK_DISABLE	BIT_17
+#define FCF_FAILOVER_DISABLE	BIT_18
+
+#define	FCF_VSA			BIT_19
+#define	FCF_HD_DEVICE		BIT_20
+
+/* No loop ID flag. */
+//#define FC_NO_LOOP_ID		0x1000
+
+/*
+ * Fibre channel LUN structure.
+ */
+typedef struct fc_lun {
+	struct list_head list;
+
+	fc_port_t *fcport;
+	uint16_t lun;
+	atomic_t state;
+	uint8_t device_type;
+	uint8_t flags;
+	#define	FLF_VISIBLE_LUN		BIT_0
+	#define	FLF_ACTIVE_LUN		BIT_1
+	#define	FLF_UNCONFIGURED	BIT_2
+
+	uint8_t lun_state;		/* 00 x00 */
+	#define LS_LUN_RESET_MARKER_NEEDED 4   /* LUN Reset marker needed */
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	void *mplun;
+	void *mpbuf;		/* ptr to buffer use by multi-path driver */
+	int mplen;
+	uint8_t max_path_retries;
+#endif
+} fc_lun_t, lun_entry_t;
+
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * Asynchronous Event Queue structure
+ */
+typedef struct {
+	uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
+}aen_t;
+
+
+/*
+ * NOTE: This structure definition really belongs in the ql4isns.h file,
+ *       but it's easier to compile when the structure is defined here.
+ */
+typedef struct _ATTRIBUTE_LIST {
+	uint32_t isns_tag;
+	#define ISNS_ATTR_TYPE_EMPTY      1   // Used for delimiter attr. & operating attr. for query.
+	#define ISNS_ATTR_TYPE_STRING     2   // UTF-8 encoded string
+	#define ISNS_ATTR_TYPE_ULONG      3
+	#define ISNS_ATTR_TYPE_ADDRESS    4   // 128-bit IPv6
+	uint8_t type;
+	uint32_t data;
+} ATTRIBUTE_LIST;
+
+typedef struct hba_ioctl{
+
+	/* This semaphore protects several threads to do ioctl commands
+	 * concurrently.
+	 *-------------------------------------------------------------------*/
+	struct semaphore  ioctl_sem;
+
+	/* Passthru cmd/completion */
+	struct semaphore	ioctl_cmpl_sem;
+	struct timer_list	ioctl_cmpl_timer;
+	uint32_t		ioctl_tov;
+	struct scsi_cmnd	*ioctl_err_cmd;
+	uint8_t			ioctl_scsi_pass_in_progress;
+	uint8_t			ioctl_iocb_pass_in_progress;
+
+	/* AEN queue */
+	void		*aen_tracking_queue;/* points to async events buffer */
+	uint8_t		aen_q_head;	/* index to the current head of q */
+	uint8_t		aen_q_tail;	/* index to the current tail of q */
+
+	/* Misc. */
+	uint32_t	flags;
+#define	IOCTL_OPEN			BIT_0
+#define	IOCTL_AEN_TRACKING_ENABLE	BIT_1
+    	uint8_t		*scrap_mem;	/* per ha scrap buf for ioctl usage */
+	uint32_t	scrap_mem_size; /* total size */
+	uint32_t	scrap_mem_used; /* portion used */
+
+} hba_ioctl_context;
+
+/*
+ * Linux Host Adapter structure
+ */
+typedef struct scsi_qla_host {
+	struct list_head list;
+
+	/* Linux adapter configuration data */
+	struct Scsi_Host *host;		    /* pointer to host data */
+	struct scsi_qla_host *next;
+
+	uint32_t        tot_ddbs;
+
+	unsigned long   flags;
+	#define AF_ONLINE		      0 /* 0x00000001 */
+	#define AF_INIT_DONE		      1 /* 0x00000002 */
+	#define AF_MBOX_COMMAND 	      2 /* 0x00000004 */
+	#define AF_MBOX_COMMAND_DONE 	      3 /* 0x00000008 */
+	#define AF_DPC_SCHEDULED	      5 /* 0x00000020 */
+	#define AF_INTERRUPTS_ON	      6 /* 0x00000040 Not Used */
+	#define AF_GET_CRASH_RECORD	      7 /* 0x00000080 */
+	#define AF_LINK_UP		      8 /* 0x00000100 */
+	#define AF_TOPCAT_CHIP_PRESENT	      9 /* 0x00000200 */
+	#define AF_IRQ_ATTACHED	      	     10 /* 0x00000400 */
+	#define AF_64BIT_PCI_ADDR	     11 /* 0x00000800 */
+
+	unsigned long   dpc_flags;
+	#define DPC_RESET_HA		      1 /* 0x00000002 */
+	#define DPC_RETRY_RESET_HA	      2 /* 0x00000004 */
+	#define DPC_RELOGIN_DEVICE	      3 /* 0x00000008 */
+	#define DPC_RESET_HA_DESTROY_DDB_LIST 4 /* 0x00000010 */
+	#define DPC_RESET_HA_INTR	      5 /* 0x00000020 */
+	#define DPC_IOCTL_ERROR_RECOVERY      6 /* 0x00000040 */
+	#define DPC_ISNS_RESTART	      7 /* 0x00000080 */
+	#define DPC_ISNS_RESTART_COMPLETION   8 /* 0x00000100 */
+	#define DPC_AEN			      9 /* 0x00000200 */
+
+	/* Failover flags */
+	#define	DPC_FAILOVER_EVENT_NEEDED    10
+	#define	DPC_FAILOVER_EVENT	     11
+	#define	DPC_FAILOVER_NEEDED   	     12
+
+	#define DPC_WAIT_TO_RELOGIN_DEVICE   13
+
+	uint16_t        iocb_cnt;
+	uint16_t        iocb_hiwat;
+
+	u_long          i_start;	/* jiffies at start of IOCTL */
+	u_long          i_end;		/* jiffies at end of IOCTL */
+	u_long          f_start;	/* jiffies at sending cmd to f/w */
+	u_long          f_end;		/* jiffies at receiving cmd from f/w */
+
+	/* pci information */
+	struct pci_dev  *pdev;
+	struct qla_board_info *brd_info;
+	unsigned long   pci_resource_flags;
+
+	uint8_t         marker_needed;
+	uint8_t         rsvd1;
+
+	/* adapter instance w.r.t. all scsi hosts in OS */
+	uint16_t        host_no;
+
+	/* adapter instance w.r.t. this driver */
+	uint16_t        instance;
+
+	void            *virt_mmapbase;
+
+	uint32_t        function_number;
+
+	/* ISP registers, Base Memory-mapped I/O address */
+	isp_reg_t       *reg;
+
+	// temp only
+	unsigned long io_addr;
+	unsigned long mem_addr;
+	unsigned long io_len;
+	unsigned long mem_len;
+	unsigned int irq;		 /* IRQ for adapter            */
+
+	/* NVRAM registers */
+	eeprom_data_t     *nvram;
+
+	/* Counters for general statistics */
+	uint64_t        adapter_error_count;
+	uint64_t        device_error_count;
+	uint64_t        total_io_count;
+	uint64_t        total_mbytes_xferred;
+	uint64_t        isr_count;	    /* Interrupt count */
+	uint64_t        link_failure_count;
+	uint64_t        invalid_crc_count;
+
+	uint32_t        spurious_int_count;
+	uint32_t        aborted_io_count;
+	uint32_t        io_timeout_count;
+	uint32_t        mailbox_timeout_count;
+	uint32_t        seconds_since_last_intr;
+	uint32_t        seconds_since_last_heartbeat;
+
+	/* Info Needed for Management App */
+	/* --- From GetFwVersion --- */
+	uint32_t        firmware_version[2];
+	uint32_t        patch_number;
+	uint32_t        build_number;
+	/* --- From Init_FW --- */
+	uint16_t        firmware_options;
+	uint16_t        tcp_options;
+	uint8_t         ip_address[IP_ADDR_LEN];
+	uint8_t         isns_ip_address[IP_ADDR_LEN];
+	uint16_t        isns_server_port_number;
+	uint8_t         alias[32];
+	uint8_t         name_string[256];
+	uint8_t         heartbeat_interval;
+	uint8_t         rsvd;
+	/* --- From FlashSysInfo --- */
+	uint8_t         my_mac[MAC_ADDR_LEN];
+	uint8_t         serial_number[16];
+	/* --- From GetFwState --- */
+	uint32_t        firmware_state;
+	uint32_t        board_id;
+	uint32_t        addl_fw_state;
+
+	/* FIXME: Define an iscsi structure for this stuf and point to it*/
+	/* - this helps to keep the HA small for performance */
+	/* iSNS information */
+	unsigned long   isns_flags;
+	#define ISNS_FLAG_ISNS_ENABLED_IN_ISP   0  /* 0x00000001 */
+	#define ISNS_FLAG_ISNS_SRV_ENABLED   	1  /* 0x00000002 */
+	#define ISNS_FLAG_ISNS_SRV_REGISTERED   2  /* 0x00000004 */
+	#define ISNS_FLAG_ISNS_SCN_REGISTERED   4  /* 0x00000010 */
+	#define ISNS_FLAG_QUERY_SINGLE_OBJECT   5  /* 0x00000020 */
+	#define ISNS_FLAG_SCN_IN_PROGRESS       6  /* 0x00000040 */
+	#define ISNS_FLAG_SCN_RESTART           7  /* 0x00000080 */
+	#define ISNS_FLAG_REREGISTER            28 /* 0x10000000 */
+	#define ISNS_FLAG_RESTART_SERVICE       31 /* 0x80000000 */
+
+	uint16_t        isns_connection_id;
+	uint16_t        isns_scn_conn_id;
+	uint16_t        isns_esi_conn_id;
+	uint16_t        isns_nsh_conn_id;
+	uint16_t        isns_remote_port_num;
+	uint16_t        isns_scn_port_num;
+	uint16_t        isns_esi_port_num;
+	uint16_t        isns_nsh_port_num;
+	uint8_t         isns_entity_id[256];
+
+	atomic_t        isns_restart_timer;
+	uint16_t        isns_transaction_id;
+	uint16_t        isns_num_discovered_targets;
+
+	ATTRIBUTE_LIST  isns_reg_attr_list[13];
+	ATTRIBUTE_LIST  isns_dereg_attr_list[7];
+	ATTRIBUTE_LIST  isns_scn_reg_attr_list[5];
+	ATTRIBUTE_LIST  isns_scn_dereg_attr_list[3];
+	ATTRIBUTE_LIST  isns_dev_get_next_attr_list[5];
+	ATTRIBUTE_LIST  isns_dev_attr_qry_attr_list[13];
+
+	/* Linux kernel thread */
+	pid_t                   dpc_pid;
+	int                     dpc_should_die;
+	struct completion       dpc_inited;
+	struct completion       dpc_exited;
+	struct semaphore        *dpc_wait;
+	uint8_t dpc_active;		     /* DPC routine is active */
+
+	/* Linux timer thread */
+	struct timer_list timer;
+	uint32_t        timer_active;
+
+	/* Recovery Timers */
+	uint32_t        port_down_retry_count;
+	uint32_t        discovery_wait;
+	atomic_t        check_relogin_timeouts;
+	uint32_t        retry_reset_ha_cnt;
+	uint32_t        isp_reset_timer;	 /* reset test timer */
+
+	int             eh_start;		/* To wake up the mid layer error
+						 * handler thread */
+
+	/* This spinlock must be held with irqs disabled in order to access
+	 * the pending, retry and free srb queues.
+	 *
+	 * The list_lock spinlock is of lower priority than the io_request
+	 * lock.
+	 *-------------------------------------------------------------------*/
+	spinlock_t      list_lock  ____cacheline_aligned;
+
+	/* internal srb queues */
+	struct          list_head failover_queue;	      /* failover list link. */
+
+	struct          list_head pending_srb_q;		/* pending queue */
+	struct          list_head retry_srb_q;
+	struct          list_head free_srb_q;
+	uint16_t        pending_srb_q_count;
+	uint16_t        retry_srb_q_count;
+	uint16_t        free_srb_q_count;
+	uint16_t        failover_cnt;
+	uint16_t        num_srbs_allocated;
+
+	/* This spinlock must be held with irqs disabled in order to access
+	 * the done srb queue and suspended_lun	queue.
+	 *
+	 * The adapter_lock spinlock is of lower priority than the
+	 * io_request lock.
+	 *------------------------------------------------------------------*/
+	spinlock_t      adapter_lock;
+
+	/* Done queue
+	 * In order to avoid deadlocks with the list_lock,
+	 * place all srbs to be returned to OS on this list.
+	 * After the list_lock is released, return all of
+	 * these commands to the OS */
+
+	struct list_head done_srb_q;
+	uint16_t         done_srb_q_count;
+
+	/* Suspended LUN queue (uses adapter_lock) */
+	struct list_head suspended_lun_q;
+	uint32_t         suspended_lun_q_count;
+
+
+	/* This spinlock is used to protect "io transactions", you must	
+	 * aquire it before doing any IO to the card, eg with RD_REG*() and
+	 * WRT_REG*() for the duration of your entire command transaction.
+	 * It is also used to protect the active_srb_array.
+	 *
+	 * The hardware_lock spinlock is of lower priority than the
+	 * io request lock.
+	 *-------------------------------------------------------------------*/
+	//spinlock_t         hardware_lock  ____cacheline_aligned;
+	spinlock_t         hardware_lock;
+
+	/* Active array */
+	srb_t           *active_srb_array[MAX_SRBS];
+	uint16_t        active_srb_count;
+	uint16_t        current_active_index;
+
+	int             mem_err;
+
+	/* DMA Memory Block */
+	void            *queues;
+	dma_addr_t      queues_dma;
+	unsigned long   queues_len;
+#define MEM_ALIGN_VALUE	\
+	((MAX(REQUEST_QUEUE_DEPTH, RESPONSE_QUEUE_DEPTH)) * \
+	 sizeof(QUEUE_ENTRY))
+
+	/* request and response queue variables */
+	dma_addr_t      request_dma;
+	QUEUE_ENTRY     *request_ring;
+	QUEUE_ENTRY     *request_ptr;
+
+	dma_addr_t      response_dma;
+	QUEUE_ENTRY     *response_ring;
+	QUEUE_ENTRY     *response_ptr;
+
+	dma_addr_t      shadow_regs_dma;
+	shadow_regs_t   *shadow_regs;
+
+	uint16_t        request_in;		/* Current indexes. */
+	uint16_t        request_out;
+	uint16_t        response_in;
+	uint16_t        response_out;
+
+	uint16_t        req_q_count;		/* Number of available entries. */
+	/* aen queue variables */
+	uint16_t        aen_q_count;		/* Number of available aen_q entries */
+	uint16_t        aen_in;		/* Current indexes */
+	uint16_t        aen_out;
+	aen_t           aen_q[MAX_AEN_ENTRIES];
+
+	/* pdu variables */
+	uint16_t        pdu_count;		/* Number of available aen_q entries */
+	uint16_t        pdu_in;		/* Current indexes */
+	uint16_t        pdu_out;
+	PDU_ENTRY       *pdu_buffsv;
+	dma_addr_t      pdu_buffsp;
+	unsigned long   pdu_buff_size;
+
+	PDU_ENTRY       *free_pdu_top;
+	PDU_ENTRY       *free_pdu_bottom;
+	uint16_t        pdu_active;
+	PDU_ENTRY       pdu_queue[MAX_PDU_ENTRIES];
+	uint8_t         pdu_buf_used[MAX_PDU_ENTRIES];
+
+	/* This semaphore protects several threads to do mailbox commands
+	 * concurrently.
+	 *-------------------------------------------------------------------*/
+	struct semaphore  mbox_sem;
+	wait_queue_head_t mailbox_wait_queue;
+
+	/* temporary mailbox status registers */
+	volatile uint8_t  mbox_status_count;
+	volatile uint32_t mbox_status[MBOX_REG_COUNT];
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	hba_ioctl_context	*ioctl;
+	void      *ioctl_dma_bufv;
+	dma_addr_t ioctl_dma_bufp;
+	uint32_t   ioctl_dma_buf_len;
+#endif
+
+	ISNS_DISCOVERED_TARGET *isns_disc_tgt_databasev;
+	dma_addr_t      isns_disc_tgt_databasep;
+	uint32_t        isns_disc_tgt_database_size;
+
+	/* local device database list (contains internal ddb entries)*/
+	struct list_head ddb_list;
+	/* Fibre Channel Device List. */
+	struct list_head        fcports;
+
+	/* Map ddb_list entry by SCSI target id */
+	// ddb_entry_t *target_map[MAX_TARGETS];
+	/* OS target queue pointers. */
+	os_tgt_t        *otgt[MAX_TARGETS+1];
+	os_tgt_t        temp_tgt;
+	os_lun_t        temp_lun;
+
+	/* Map ddb_list entry by FW ddb index */
+	ddb_entry_t     *fw_ddb_index_map[MAX_DDB_ENTRIES];
+
+	uint32_t failover_type;
+	uint32_t failback_delay;
+	unsigned long   cfg_flags;
+	#define	CFG_ACTIVE	0	/* CFG during a failover, event update, or ioctl */
+	#define	CFG_FAILOVER	1	
+
+	/* Adapter I/O statistics for failover */
+	uint64_t        IosRequested;
+	uint64_t        BytesRequested;
+	uint64_t        IosExecuted;
+	uint64_t        BytesExecuted;
+
+	/*
+	 * There are several Scsi_Host members that are RHEL3 specific
+	 * yet depend on the SCSI_HAS_HOST_LOCK define for visibility.
+	 * Unfortuantely, it seems several RH kernels have the define
+	 * set, but do not have a host_lock member.
+	 *
+	 * Use the SH_HAS_HOST_LOCK define determined during driver
+	 * compilation rather than SCSI_HAS_HOST_LOCK.
+	 */
+
+	/* Scsi midlayer lock */
+	#if defined(SH_HAS_HOST_LOCK)
+	spinlock_t      host_lock ____cacheline_aligned;
+	#endif
+}scsi_qla_host_t;
+
+#define ADAPTER_UP(ha) ((test_bit(AF_ONLINE, &ha->flags) != 0) && (test_bit(AF_LINK_UP, &ha->flags) != 0))
+
+typedef struct {
+	uint8_t ha_mac[MAX_HBAS][MAC_ADDR_LEN];
+} mac_cfgs_t;
+
+/*
+ * Other macros
+ */
+#define TGT_Q(ha, t) (ha->otgt[t])
+#define LUN_Q(ha, t, l)	(TGT_Q(ha, t)->olun[l])
+#define GET_LU_Q(ha, t, l) ((TGT_Q(ha,t) != NULL)? TGT_Q(ha, t)->olun[l] : NULL)
+
+#define to_qla_host(x)		((scsi_qla_host_t *) (x)->hostdata)
+
+#define ql4_printk(level, ha, format, arg...) \
+	dev_printk(level , &((ha)->pdev->dev) , format , ## arg)
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Defines for qla4xxx_initialize_adapter() and qla4xxx_recover_adapter() */
+#define PRESERVE_DDB_LIST	0
+#define REBUILD_DDB_LIST	1
+
+/* Defines for process_aen() */
+#define PROCESS_ALL_AENS	0
+#define FLUSH_DDB_CHANGED_AENS	1
+
+/* Defines for qla4xxx_take_hw_semaphore */
+#define NO_WAIT		0
+#define WAIT_FOREVER	1
+#define TIMED_WAIT	2
+
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+#include "qlisioct.h"
+#include "qlinioct.h"
+#include "qlnfo.h"
+#include "ql4_cfg.h"
+#include "ql4_foln.h"
+#endif
+#include "ql4_version.h"
+#include "ql4_settings.h"
+#include "ql4_glbl.h"
+#include "ql4_dbg.h"
+#include "ql4_inline.h"
+#include "ql4_listops.h"
+#include "ql4_isns.h"
+
+
+#endif /*_QLA4XXX_H */
+
+/*
+ * Overrides for Emacs so that we get a uniform tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_fo.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_fo.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_fo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_fo.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,577 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP4xxx device driver for Linux 2.6.x
+* Copyright (C) 2003-2004 QLogic Corporation
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+******************************************************************************
+* Failover include file
+******************************************************************************/
+
+// #include "ql4_os.h"
+#include "ql4_def.h"
+
+#include "qlfo.h"
+#include "qlfolimits.h"
+
+
+/*
+ * Global variables
+ */
+SysFoParams_t qla_fo_params;
+
+/*
+ * Local routines
+ */
+static uint8_t qla4xxx_fo_count_retries(scsi_qla_host_t *ha, srb_t *sp);
+
+/*
+ * qla4xxx_reset_lun_fo_counts
+ *	Reset failover retry counts
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Interrupt context.
+ */
+void
+qla4xxx_reset_lun_fo_counts(scsi_qla_host_t *ha, os_lun_t *lq)
+{
+	srb_t           *tsp;
+	os_lun_t        *orig_lq;
+	struct list_head *list;
+	unsigned long   flags ;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	/*
+	 * the pending queue.
+	 */
+	list_for_each(list,&ha->pending_srb_q)
+	{
+		tsp = list_entry(list, srb_t, list_entry);
+		orig_lq = tsp->lun_queue;
+		if (orig_lq == lq)
+			tsp->fo_retry_cnt = 0;
+	}
+	/*
+	 * the retry queue.
+	 */
+	list_for_each(list,&ha->retry_srb_q)
+	{
+		tsp = list_entry(list, srb_t, list_entry);
+		orig_lq = tsp->lun_queue;
+		if (orig_lq == lq)
+			tsp->fo_retry_cnt = 0;
+	}
+
+	/*
+	 * the done queue.
+	 */
+	list_for_each(list, &ha->done_srb_q)
+	{
+		tsp = list_entry(list, srb_t, list_entry);
+		orig_lq = tsp->lun_queue;
+		if (orig_lq == lq)
+			tsp->fo_retry_cnt = 0;
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+
+#if 0
+void qla4xxx_find_all_active_ports(srb_t *sp)
+{
+	scsi_qla_host_t *ha = qla4xxx_hostlist;
+	fc_port_t *fcport;
+	fc_lun_t        *fclun;
+	fc_lun_t        *orig_fclun;
+
+	DEBUG2(printk(KERN_INFO "%s: Scanning for active ports... %d\n",
+		      __func__, sp->lun_queue->fclun->lun);)
+	orig_fclun = sp->lun_queue->fclun;
+	for (; (ha != NULL); ha=ha->next) {
+		list_for_each_entry(fcport, &ha->fcports, list)
+		{
+			if (fcport->port_type != FCT_TARGET)
+				continue;
+			if ((fcport->flags & (FCF_EVA_DEVICE|FCF_MSA_DEVICE))) {
+				list_for_each_entry(fclun, &fcport->fcluns, list)
+				{
+					if (fclun->flags & FCF_VISIBLE_LUN)
+						continue;
+					if (orig_fclun->lun != fclun->lun)
+						continue;
+					qla4xxx_test_active_lun(fcport,fclun);
+				}
+			}
+#if MSA1000_SUPPORTED
+			if ((fcport->flags & FCF_MSA_DEVICE))
+				qla4xxx_test_active_port(fcport);
+#endif
+		}
+	}
+	DEBUG2(printk(KERN_INFO "%s: Scanning ports...Done\n",
+		      __func__);)
+}
+#endif
+
+/*
+ * qla4xxx_fo_count_retries
+ *	Increment the retry counter for the command.
+ *      Set or reset the SRB_RETRY flag.
+ *
+ * Input:
+ *	sp = Pointer to command.
+ *
+ * Returns:
+ *	1 -- retry
+ * 	0 -- don't retry
+ *
+ * Context:
+ *	Kernel context.
+ */
+static uint8_t
+qla4xxx_fo_count_retries(scsi_qla_host_t *ha, srb_t *sp)
+{
+	uint8_t		retry = 1;
+	os_lun_t	*lq;
+	os_tgt_t	*tq;
+	scsi_qla_host_t	*vis_ha;
+
+	DEBUG9(printk("%s: entered.\n", __func__);)
+
+	if (++sp->fo_retry_cnt >  qla_fo_params.MaxRetriesPerIo) {
+		/* no more failovers for this request */
+		retry = 0;
+		sp->fo_retry_cnt = 0;
+		printk(KERN_INFO
+		    "qla4xxx: no more failovers for request - pid= %ld\n",
+		    sp->cmd->serial_number);
+	} else {
+		/*
+		 * We haven't exceeded the max retries for this request, check
+		 * max retries this path
+		 */
+		if ((sp->fo_retry_cnt % qla_fo_params.MaxRetriesPerPath) == 0) {
+			DEBUG2(printk("qla4xxx_fo_count_retries: FAILOVER - "
+			    "queuing ha=%d, sp=%p, pid =%ld, "
+			    "fo retry= %d \n",
+			    ha->host_no,
+			    sp, sp->cmd->serial_number,
+			    sp->fo_retry_cnt);)
+
+			/*
+			 * Note: we don't want it to timeout, so it is
+			 * recycling on the retry queue and the fialover queue.
+			 */
+			lq = sp->lun_queue;
+			tq = sp->tgt_queue;
+			// set_bit(LUN_MPIO_BUSY, &lq->q_flag);
+
+			/*
+			 * ??? We can get a path error on any ha, but always
+			 * queue failover on originating ha. This will allow us
+			 * to syncronized the requests for a given lun.
+			 */
+			/* Now queue it on to be failover */
+			sp->ha = ha;
+			/* we can only failover using the visible HA */
+		 	vis_ha =
+			    (scsi_qla_host_t *)sp->cmd->device->host->hostdata;
+			add_to_failover_queue(vis_ha,sp);
+		}
+	}
+
+	DEBUG9(printk("%s: exiting. retry = %d.\n", __func__, retry);)
+
+	return retry ;
+}
+
+int
+qla4xxx_fo_check_device(scsi_qla_host_t *ha, srb_t *sp)
+{
+	int		retry = 0;
+	os_lun_t	*lq;
+	struct scsi_cmnd 	 *cp;
+	fc_port_t 	 *fcport;
+	
+	if ( !(sp->flags & SRB_GOT_SENSE) )
+		return retry;
+
+	cp = sp->cmd;
+	lq = sp->lun_queue;
+	fcport = lq->fclun->fcport;
+	switch (cp->sense_buffer[2] & 0xf) {
+	case NOT_READY:
+		if (fcport->flags & (FCF_MSA_DEVICE | FCF_EVA_DEVICE)) {
+			/*
+			 * if we can't access port 
+			 */
+			if ((cp->sense_buffer[12] == 0x4 &&
+			    (cp->sense_buffer[13] == 0x0 ||
+			     cp->sense_buffer[13] == 0x3 ||
+			     cp->sense_buffer[13] == 0x2))) {
+				sp->err_id = SRB_ERR_DEVICE;
+				return 1;
+			}
+		} 
+		break;
+
+	case UNIT_ATTENTION:
+		if (fcport->flags & FCF_EVA_DEVICE) {
+			if ((cp->sense_buffer[12] == 0xa &&
+			    cp->sense_buffer[13] == 0x8)) {
+				sp->err_id = SRB_ERR_DEVICE;
+				return 1;
+			}
+			if ((cp->sense_buffer[12] == 0xa &&
+			    cp->sense_buffer[13] == 0x9)) {
+				/* failback lun */
+			}
+		} 
+		break;
+
+	}
+
+	return (retry);
+}
+
+/*
+ * qla4xxx_fo_check
+ *	This function is called from the done routine to see if
+ *  the SRB requires a failover.
+ *
+ *	This function examines the available os returned status and
+ *  if meets condition, the command(srb) is placed ont the failover
+ *  queue for processing.
+ *
+ * Input:
+ *	sp  = Pointer to the SCSI Request Block
+ *
+ * Output:
+ *      sp->flags SRB_RETRY bit id command is to
+ *      be retried otherwise bit is reset.
+ *
+ * Returns:
+ *      None.
+ *
+ * Context:
+ *	Kernel/Interrupt context.
+ */
+uint8_t
+qla4xxx_fo_check(scsi_qla_host_t *ha, srb_t *sp)
+{
+	uint8_t		retry = 0;
+	int host_status;
+#ifdef QL_DEBUG_LEVEL_2
+	static char *reason[] = {
+		"DID_OK",
+		"DID_NO_CONNECT",
+		"DID_BUS_BUSY",
+		"DID_TIME_OUT",
+		"DID_BAD_TARGET",
+		"DID_ABORT",
+		"DID_PARITY",
+		"DID_ERROR",
+		"DID_RESET",
+		"DID_BAD_INTR"
+	};
+#endif
+
+	DEBUG9(printk("%s: entered.\n", __func__);)
+
+	/* we failover on selction timeouts only */
+	host_status = host_byte(sp->cmd->result);
+	if( host_status == DID_NO_CONNECT ||
+		qla4xxx_fo_check_device(ha, sp) ) {
+			
+		if (qla4xxx_fo_count_retries(ha, sp)) {
+			/* Force a retry  on this request, it will
+			 * cause the LINUX timer to get reset, while we
+			 * we are processing the failover.
+			 */
+			sp->cmd->result = DID_BUS_BUSY << 16;
+			retry = 1;
+		}
+		DEBUG2(printk("qla4xxx_fo_check: pid= %ld sp %p/%d/%d retry count=%d, "
+		    "retry flag = %d, host status (%s)\n",
+		    sp->cmd->serial_number, sp, sp->state, sp->err_id, sp->fo_retry_cnt, retry,
+		    reason[host_status]);)
+	}
+
+	DEBUG9(printk("%s: exiting. retry = %d.\n", __func__, retry);)
+
+	return retry;
+}
+
+/*
+ * qla4xxx_fo_path_change
+ *	This function is called from configuration mgr to notify
+ *	of a path change.
+ *
+ * Input:
+ *      type    = Failover notify type, FO_NOTIFY_LUN_RESET or FO_NOTIFY_LOGOUT
+ *      newlunp = Pointer to the fc_lun struct for current path.
+ *      oldlunp = Pointer to fc_lun struct for previous path.
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ */
+uint32_t
+qla4xxx_fo_path_change(uint32_t type, fc_lun_t *newlunp, fc_lun_t *oldlunp)
+{
+	uint32_t	ret = QLA_SUCCESS;
+
+	newlunp->max_path_retries = 0;
+	return ret;
+}
+
+#if 0
+/*
+ * qla4xxx_fo_get_params
+ *	Process an ioctl request to get system wide failover parameters.
+ *
+ * Input:
+ *	pp = Pointer to FO_PARAMS structure.
+ *
+ * Returns:
+ *	EXT_STATUS code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static uint32_t
+qla4xxx_fo_get_params(PFO_PARAMS pp)
+{
+	DEBUG9(printk("%s: entered.\n", __func__);)
+
+	pp->MaxPathsPerDevice = qla_fo_params.MaxPathsPerDevice;
+	pp->MaxRetriesPerPath = qla_fo_params.MaxRetriesPerPath;
+	pp->MaxRetriesPerIo = qla_fo_params.MaxRetriesPerIo;
+	pp->Flags = qla_fo_params.Flags;
+	pp->FailoverNotifyType = qla_fo_params.FailoverNotifyType;
+	pp->FailoverNotifyCdbLength = qla_fo_params.FailoverNotifyCdbLength;
+	memset(pp->FailoverNotifyCdb, 0, sizeof(pp->FailoverNotifyCdb));
+	memcpy(pp->FailoverNotifyCdb,
+	    &qla_fo_params.FailoverNotifyCdb[0], sizeof(pp->FailoverNotifyCdb));
+
+	DEBUG9(printk("%s: exiting.\n", __func__);)
+
+	return EXT_STATUS_OK;
+}
+
+/*
+ * qla4xxx_fo_set_params
+ *	Process an ioctl request to set system wide failover parameters.
+ *
+ * Input:
+ *	pp = Pointer to FO_PARAMS structure.
+ *
+ * Returns:
+ *	EXT_STATUS code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static uint32_t
+qla4xxx_fo_set_params(PFO_PARAMS pp)
+{
+	DEBUG9(printk("%s: entered.\n", __func__);)
+
+	/* Check values for defined MIN and MAX */
+	if ((pp->MaxPathsPerDevice > SDM_DEF_MAX_PATHS_PER_DEVICE) ||
+	    (pp->MaxRetriesPerPath < FO_MAX_RETRIES_PER_PATH_MIN) ||
+	    (pp->MaxRetriesPerPath > FO_MAX_RETRIES_PER_PATH_MAX) ||
+	    (pp->MaxRetriesPerIo < FO_MAX_RETRIES_PER_IO_MIN) ||
+	    (pp->MaxRetriesPerPath > FO_MAX_RETRIES_PER_IO_MAX)) {
+		DEBUG2(printk("%s: got invalid params.\n", __func__);)
+		return EXT_STATUS_INVALID_PARAM;
+	}
+
+	/* Update the global structure. */
+	qla_fo_params.MaxPathsPerDevice = pp->MaxPathsPerDevice;
+	qla_fo_params.MaxRetriesPerPath = pp->MaxRetriesPerPath;
+	qla_fo_params.MaxRetriesPerIo = pp->MaxRetriesPerIo;
+	qla_fo_params.Flags = pp->Flags;
+	qla_fo_params.FailoverNotifyType = pp->FailoverNotifyType;
+	qla_fo_params.FailoverNotifyCdbLength = pp->FailoverNotifyCdbLength;
+	if (pp->FailoverNotifyType & FO_NOTIFY_TYPE_CDB) {
+		if (pp->FailoverNotifyCdbLength >
+		    sizeof(qla_fo_params.FailoverNotifyCdb)) {
+			DEBUG2(printk("%s: got invalid cdb length.\n",
+			    __func__);)
+			return EXT_STATUS_INVALID_PARAM;
+		}
+
+		memcpy(qla_fo_params.FailoverNotifyCdb,
+		    pp->FailoverNotifyCdb,
+		    sizeof(qla_fo_params.FailoverNotifyCdb));
+	}
+
+	DEBUG9(printk("%s: exiting.\n", __func__);)
+
+	return EXT_STATUS_OK;
+}
+#endif
+
+
+/*
+ * qla4xxx_fo_init_params
+ *	Gets driver configuration file failover properties to initalize
+ *	the global failover parameters structure.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+void
+qla4xxx_fo_init_params(scsi_qla_host_t *ha)
+{
+	DEBUG3(printk("%s: entered.\n", __func__);)
+
+	/* For parameters that are not completely implemented yet, */
+
+	memset(&qla_fo_params, 0, sizeof(qla_fo_params));
+
+	if(MaxPathsPerDevice) {
+		qla_fo_params.MaxPathsPerDevice = MaxPathsPerDevice;
+	} else
+		qla_fo_params.MaxPathsPerDevice =FO_MAX_PATHS_PER_DEVICE_DEF ;
+	if(MaxRetriesPerPath) {
+		qla_fo_params.MaxRetriesPerPath = MaxRetriesPerPath;
+	} else
+		qla_fo_params.MaxRetriesPerPath =FO_MAX_RETRIES_PER_PATH_DEF;
+	if(MaxRetriesPerIo) {
+		qla_fo_params.MaxRetriesPerIo =MaxRetriesPerIo;
+	} else
+		qla_fo_params.MaxRetriesPerIo =FO_MAX_RETRIES_PER_IO_DEF;
+
+	qla_fo_params.Flags =  0;
+	qla_fo_params.FailoverNotifyType = FO_NOTIFY_TYPE_NONE;
+	
+	/* Set it to whatever user specified on the cmdline */
+	if (qlFailoverNotifyType != FO_NOTIFY_TYPE_NONE)
+		qla_fo_params.FailoverNotifyType = qlFailoverNotifyType;
+	
+
+	DEBUG3(printk("%s: exiting.\n", __func__);)
+}
+
+
+/*
+ * qla2100_fo_enabled
+ *      Reads and validates the failover enabled property.
+ *
+ * Input:
+ *      ha = adapter state pointer.
+ *      instance = HBA number.
+ *
+ * Returns:
+ *      1 when failover is authorized else 0
+ *
+ * Context:
+ *      Kernel context.
+ */
+uint8_t
+qla4xxx_fo_enabled(scsi_qla_host_t *ha, int instance)
+{
+	return qla4xxx_failover_enabled(ha);
+}
+
+/*
+ * qla4xxx_send_fo_notification
+ *      Sends failover notification if needed.  Change the fc_lun pointer
+ *      in the old path lun queue.
+ *
+ * Input:
+ *      old_lp = Pointer to old fc_lun.
+ *      new_lp = Pointer to new fc_lun.
+ *
+ * Returns:
+ *      Local function status code.
+ *
+ * Context:
+ *      Kernel context.
+ */
+uint32_t
+qla4xxx_send_fo_notification(fc_lun_t *old_lp, fc_lun_t *new_lp)
+{
+	int		rval = QLA_SUCCESS;
+#if 0
+	scsi_qla_host_t	*old_ha = old_lp->fcport->ha;
+	inq_cmd_rsp_t	*pkt;
+	uint16_t	loop_id, lun;
+	dma_addr_t	phys_address;
+#endif
+
+
+	ENTER("qla4xxx_send_fo_notification");
+	DEBUG3(printk("%s: entered.\n", __func__);)
+
+#if 0
+	if( new_lp->fcport == NULL ){
+		DEBUG2(printk("qla4xxx_send_fo_notification: No "
+			    "new fcport for lun pointer\n");)
+		return QLA_ERROR;
+	}
+	loop_id = new_lp->fcport->loop_id;
+	lun = new_lp->lun;
+
+	if (qla_fo_params.FailoverNotifyType == FO_NOTIFY_TYPE_LUN_RESET) {
+		rval = qla4xxx_lun_reset(old_ha, loop_id, lun);
+		if (rval == QLA_SUCCESS) {
+			DEBUG4(printk("qla4xxx_send_fo_notification: LUN "
+			    "reset succeded\n");)
+		} else {
+			DEBUG4(printk("qla4xxx_send_fo_notification: LUN "
+			    "reset failed\n");)
+		}
+
+	}
+	if ( (qla_fo_params.FailoverNotifyType ==
+	     FO_NOTIFY_TYPE_LOGOUT_OR_LUN_RESET) ||
+	    (qla_fo_params.FailoverNotifyType ==
+	     FO_NOTIFY_TYPE_LOGOUT_OR_CDB) )  {
+
+		rval = qla4xxx_fabric_logout(old_ha, loop_id);
+		if (rval == QLA_SUCCESS) {
+			DEBUG4(printk("qla4xxx_send_fo_failover_notify: "
+			    "logout succeded\n");)
+		} else {
+			DEBUG4(printk("qla4xxx_send_fo_failover_notify: "
+			    "logout failed\n");)
+		}
+
+	}
+
+	if (qla_fo_params.FailoverNotifyType == FO_NOTIFY_TYPE_SPINUP ||
+		new_lp->fcport->notify_type == FO_NOTIFY_TYPE_SPINUP ) {
+		rval = qla4xxx_spinup(new_lp->fcport->ha, new_lp->fcport, 
+			new_lp->lun); 
+	}
+
+	if (qla_fo_params.FailoverNotifyType == FO_NOTIFY_TYPE_CDB) {
+	}
+#endif
+
+	DEBUG3(printk("%s: exiting. rval = %d.\n", __func__, rval);)
+
+	return rval;
+}
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_fo.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_fo.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_fo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_fo.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,46 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2003-2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/*
+ * QLogic ISP4xxx Failover Header 
+ *
+ */
+#ifndef _QLA_FO_H
+#define _QLA_FO_H
+
+/*
+         * This structure definition is for a scsi I/O request NOT subject to
+         * failover re-routing.  It is for the use of configuration operations
+         * and diagnostics functions as definted in ExIoct.h
+         */
+        typedef struct scsi_cdb_request {
+                struct adapter_state		*ha;
+                uint16_t	target;
+                uint16_t	lun;
+                uint8_t		*cdb_ptr;	/* Pointer to cdb to be sent */
+                uint8_t		cdb_len;	/* cdb length */
+                uint8_t		direction;	/* Direction of I/O for buffer */
+                uint8_t		scb_len;	/* Scsi completion block length */
+                uint8_t		*scb_ptr;	/* Scsi completion block pointer */
+                uint8_t		*buf_ptr;	/* Pointer to I/O buffer */
+                uint16_t	buf_len;	/* Buffer size */
+        }
+        SCSI_REQ_t, *SCSI_REQ_p;
+
+#endif	/* ifndef _QLA_FO_H */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_foio.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_foio.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_foio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_foio.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,1120 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP4xxx device driver for Linux 2.6.x
+* Copyright (C) 2003-2004 QLogic Corporation
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+******************************************************************************/
+
+/****************************************
+ *	Issues requests for failover module
+ ****************************************/
+ 
+// #include "qla_os.h"
+#include "ql4_def.h"
+
+// #include "qlfo.h"
+/*
+#include "qlfolimits.h"
+#include "ql4_foln.h"
+*/
+
+/*
+ *  Function Prototypes.
+ */
+
+int qla4xxx_issue_scsi_inquiry(scsi_qla_host_t *ha, 
+	fc_port_t *fcport, fc_lun_t *fclun );
+int qla4xxx_test_active_lun(fc_port_t *fcport, fc_lun_t *fclun);
+int qla4xxx_get_wwuln_from_device(mp_host_t *host, fc_lun_t *fclun, 
+	char	*evpd_buf, int wwlun_size);
+fc_lun_t * qla4xxx_cfg_lun(scsi_qla_host_t *ha, fc_port_t *fcport, uint16_t lun,
+                inq_cmd_rsp_t *inq, dma_addr_t inq_dma);
+void
+qla4xxx_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport);
+static int
+qla4xxx_inquiry(scsi_qla_host_t *ha,
+    fc_port_t *fcport, uint16_t lun, inq_cmd_rsp_t *inq, dma_addr_t inq_dma);
+int qla4xxx_rpt_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport,
+    inq_cmd_rsp_t *inq, dma_addr_t inq_dma);
+static int qla4xxx_report_lun(scsi_qla_host_t *ha, fc_port_t *fcport,
+		   rpt_lun_cmd_rsp_t *rlc, dma_addr_t rlc_dma);
+	
+int
+qla4xxx_spinup(scsi_qla_host_t *ha, fc_port_t *fcport, uint16_t lun); 
+				
+/*
+ * qla4xxx_get_wwuln_from_device
+ *	Issue SCSI inquiry page code 0x83 command for LUN WWLUN_NAME.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fcport = FC port structure pointer.
+ *
+ * Return:
+ *	0  - Failed to get the lun_wwlun_name
+ *      Otherwise : wwlun_size
+ *
+ * Context:
+ *	Kernel context.
+ */
+
+int
+qla4xxx_get_wwuln_from_device(mp_host_t *host, fc_lun_t *fclun, 
+	char	*evpd_buf, int wwlun_size)
+{
+
+	evpd_inq_cmd_rsp_t	*pkt;
+	int		rval, rval1; 
+	dma_addr_t	phys_address = 0;
+	int		retries;
+	uint8_t	comp_status;
+	uint8_t	scsi_status;
+	uint8_t	iscsi_flags;
+	scsi_qla_host_t *ha;
+	ddb_entry_t	*ddb_entry = fclun->fcport->ddbptr;
+
+	ENTER(__func__);
+	//printk("%s entered\n",__func__);
+
+	rval = 0; /* failure */
+
+	if (atomic_read(&fclun->fcport->state) == FCS_DEVICE_DEAD){
+		DEBUG(printk("%s leaving: Port is marked DEAD\n",__func__);)
+		return rval;
+	}
+
+	memset(evpd_buf, 0 ,wwlun_size);
+	ha = host->ha;
+	pkt = pci_alloc_consistent(ha->pdev,
+	    sizeof(evpd_inq_cmd_rsp_t), &phys_address);
+
+	if (pkt == NULL) {
+		printk(KERN_WARNING
+		    "scsi(%d): Memory Allocation failed - INQ\n",
+		    ha->host_no);
+		ha->mem_err++;
+		return rval;
+	}
+
+	for (retries = 3; retries; retries--) {
+		memset(pkt, 0, sizeof(evpd_inq_cmd_rsp_t));
+		pkt->p.cmd.hdr.entryType = ET_COMMAND;
+		pkt->p.cmd.hdr.entryCount = 1;
+		
+		pkt->p.cmd.lun[1]  = LSB(cpu_to_le16(fclun->lun)); /*SAMII compliant lun*/
+		pkt->p.cmd.lun[2]  = MSB(cpu_to_le16(fclun->lun));
+		pkt->p.cmd.target = cpu_to_le16(ddb_entry->fw_ddb_index);
+		pkt->p.cmd.control_flags =(CF_READ | CF_SIMPLE_TAG);
+		pkt->p.cmd.cdb[0] = INQUIRY;
+		pkt->p.cmd.cdb[1] = INQ_EVPD_SET;
+		pkt->p.cmd.cdb[2] = INQ_DEV_IDEN_PAGE; 
+		pkt->p.cmd.cdb[4] = VITAL_PRODUCT_DATA_SIZE;
+		pkt->p.cmd.dataSegCnt = __constant_cpu_to_le16(1);
+		pkt->p.cmd.timeout = __constant_cpu_to_le16(10);
+		pkt->p.cmd.ttlByteCnt =
+		    __constant_cpu_to_le32(VITAL_PRODUCT_DATA_SIZE);
+		pkt->p.cmd.dataseg[0].base.addrLow = cpu_to_le32(
+		    LSDW(phys_address + sizeof(STATUS_ENTRY)));
+		pkt->p.cmd.dataseg[0].base.addrHigh = cpu_to_le32(
+		    MSDW(phys_address + sizeof(STATUS_ENTRY)));
+		pkt->p.cmd.dataseg[0].count =
+		    __constant_cpu_to_le32(VITAL_PRODUCT_DATA_SIZE);
+		/* If in connection mode, bump sequence number */
+		if ((ha->firmware_options & FWOPT_SESSION_MODE) != 0) {
+		 	ddb_entry->CmdSn++;
+		}
+		pkt->p.cmd.cmdSeqNum = cpu_to_le32(ddb_entry->CmdSn);	
+
+		rval1 = qla4xxx_issue_iocb(ha, pkt,
+			    phys_address, sizeof(evpd_inq_cmd_rsp_t));
+
+		comp_status = pkt->p.rsp.completionStatus;
+		scsi_status = pkt->p.rsp.scsiStatus;
+		iscsi_flags = pkt->p.rsp.iscsiFlags;
+
+		DEBUG2(printk("%s: lun (%d) inquiry page 0x83- "
+		    " comp status 0x%x, "
+		    "scsi status 0x%x, iscsi flags=0x%x, rval=%d\n"
+		    ,__func__,
+		    fclun->lun, comp_status, scsi_status, iscsi_flags,
+		    rval1);)
+		DEBUG2(printk("pkt resp len %d, bidi len %d \n",
+			pkt->p.rsp.residualByteCnt,
+			pkt->p.rsp.bidiResidualByteCnt);)
+
+
+		if (rval1 != QLA_SUCCESS || comp_status != SCS_COMPLETE ||
+		    scsi_status & SCSISTAT_CHECK_CONDITION) {
+
+			if (scsi_status & SCSISTAT_CHECK_CONDITION) {
+				DEBUG2(printk("scsi(%d): INQ "
+				    "SCSISTAT_CHECK_CONDITION Sense Data "
+				    "%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				    ha->host_no,
+				    pkt->p.rsp.senseData[0],
+				    pkt->p.rsp.senseData[1],
+				    pkt->p.rsp.senseData[2],
+				    pkt->p.rsp.senseData[3],
+				    pkt->p.rsp.senseData[4],
+				    pkt->p.rsp.senseData[5],
+				    pkt->p.rsp.senseData[6],
+				    pkt->p.rsp.senseData[7]));
+			}
+
+			/* Device underrun, treat as OK. */
+			if (rval1 == QLA_SUCCESS &&
+			    comp_status == SCS_DATA_UNDERRUN &&
+			    iscsi_flags & ISCSI_FLAG_RESIDUAL_UNDER) {
+
+				/* rval1 = QLA_SUCCESS; */
+				break;
+			}
+		} else {
+			rval1 = QLA_SUCCESS;
+			break;
+		}
+	} 
+
+	if (rval1 == QLA_SUCCESS &&
+	    pkt->inq[1] == INQ_DEV_IDEN_PAGE ) {
+
+		if( pkt->inq[7] <= WWLUN_SIZE ){
+			memcpy(evpd_buf,&pkt->inq[8], pkt->inq[7]);
+			rval = pkt->inq[7] ; /* lun wwlun_size */
+			DEBUG2(printk("%s : Lun(%d)  WWLUN size %d\n",__func__,
+			    fclun->lun,pkt->inq[7]);)
+		} else {
+			memcpy(evpd_buf,&pkt->inq[8], WWLUN_SIZE);
+			rval = WWLUN_SIZE;
+			printk(KERN_INFO "%s : Lun(%d)  WWLUN may "
+			    "not be complete, Buffer too small" 
+			    " need: %d provided: %d\n",__func__,
+			    fclun->lun,pkt->inq[7],WWLUN_SIZE);
+		}
+		DEBUG2(qla4xxx_dump_buffer(evpd_buf, rval);)
+	} else {
+		if (scsi_status & SCSISTAT_CHECK_CONDITION) {
+			/*
+			 * ILLEGAL REQUEST - 0x05
+			 * INVALID FIELD IN CDB - 24 : 00
+			 */
+			if(pkt->p.rsp.senseData[2] == 0x05 && 
+			    pkt->p.rsp.senseData[12] == 0x24 &&
+			    pkt->p.rsp.senseData[13] == 0x00 ) {
+
+				DEBUG2(printk(KERN_INFO "%s Lun(%d) does not"
+				    " support Inquiry Page Code-0x83\n",					
+				    __func__,fclun->lun);)
+			} else {
+				DEBUG2(printk(KERN_INFO "%s Lun(%d) does not"
+				    " support Inquiry Page Code-0x83\n",	
+				    __func__,fclun->lun);)
+				DEBUG2(printk( KERN_INFO "Unhandled check " 
+				    "condition sense_data[2]=0x%x"  		
+				    " sense_data[12]=0x%x "
+				    "sense_data[13]=0x%x\n",
+				    pkt->p.rsp.senseData[2],
+				    pkt->p.rsp.senseData[12],
+				    pkt->p.rsp.senseData[13]);)
+			
+			}
+
+		} else {
+			/* Unable to issue Inquiry Page 0x83 */
+			DEBUG2(printk(KERN_INFO
+			    "%s Failed to issue Inquiry Page 0x83 -- lun (%d) "
+			    "cs=0x%x ss=0x%x, rval=%d\n",
+			    __func__, fclun->lun, comp_status, scsi_status,
+			    rval);)
+		}
+		rval = 0 ;
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(evpd_inq_cmd_rsp_t), 
+	    			pkt, phys_address);
+
+	//printk("%s exit\n",__func__);
+	LEAVE(__func__);
+
+	return rval;
+}
+
+/*
+ * qla4xxx_inquiry
+ *	Issue SCSI inquiry command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fcport = FC port structure pointer.
+ *
+ * Return:
+ *	0  - Success
+ *  BIT_0 - error
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla4xxx_inquiry(scsi_qla_host_t *ha, fc_port_t *fcport,
+		uint16_t lun, inq_cmd_rsp_t *inq, dma_addr_t inq_dma)
+{
+	int rval, rval1;
+	uint16_t retries;
+	uint8_t comp_status;
+	uint8_t scsi_status;
+	uint8_t iscsi_flags;
+	ddb_entry_t *ddb_entry = fcport->ddbptr;
+
+	rval = QLA_ERROR;
+
+	for (retries = 3; retries; retries--) {
+		memset(inq, 0, sizeof(inq_cmd_rsp_t));
+		inq->p.cmd.hdr.entryType = ET_COMMAND;
+		
+		/* rlc->p.cmd.handle = 1; */
+		/* 8 byte lun number */
+		inq->p.cmd.lun[1]            = LSB(cpu_to_le16(lun)); /*SAMII compliant lun*/
+		inq->p.cmd.lun[2]            = MSB(cpu_to_le16(lun));
+		inq->p.cmd.hdr.entryCount = 1;
+		inq->p.cmd.target = cpu_to_le16(ddb_entry->fw_ddb_index);
+		inq->p.cmd.control_flags =(CF_READ | CF_SIMPLE_TAG);
+		inq->p.cmd.cdb[0] = INQUIRY;
+		inq->p.cmd.cdb[4] = INQ_DATA_SIZE;
+		inq->p.cmd.dataSegCnt = __constant_cpu_to_le16(1);
+		inq->p.cmd.timeout = __constant_cpu_to_le16(10);
+		inq->p.cmd.ttlByteCnt =
+		    __constant_cpu_to_le32(INQ_DATA_SIZE);
+		inq->p.cmd.dataseg[0].base.addrLow = cpu_to_le32(
+		    LSDW(inq_dma + sizeof(STATUS_ENTRY)));
+		inq->p.cmd.dataseg[0].base.addrHigh = cpu_to_le32(
+		    MSDW(inq_dma + sizeof(STATUS_ENTRY)));
+		inq->p.cmd.dataseg[0].count =
+		    __constant_cpu_to_le32(INQ_DATA_SIZE);
+		/*  rlc->p.cmd.lun[8];	 always lun 0 */
+		/* If in connection mode, bump sequence number */
+		if ((ha->firmware_options & FWOPT_SESSION_MODE) != 0) {
+		 	ddb_entry->CmdSn++;
+		}
+		inq->p.cmd.cmdSeqNum = cpu_to_le32(ddb_entry->CmdSn);	
+		
+		DEBUG2(printk("scsi(%d): Lun Inquiry - fcport=[%04x/%p],"
+		    " lun (%d)\n",
+		    ha->host_no, fcport->loop_id, fcport, lun));
+
+		rval1 = qla4xxx_issue_iocb(ha, inq, inq_dma,
+		    sizeof(inq_cmd_rsp_t));
+
+		comp_status = inq->p.rsp.completionStatus;
+		scsi_status = inq->p.rsp.scsiStatus;
+		iscsi_flags = inq->p.rsp.iscsiFlags;
+
+		DEBUG2(printk("scsi(%d): lun (%d) inquiry - "
+		    "inq[0]= 0x%x, comp status 0x%x, scsi status 0x%x, "
+		    "rval=%d\n",
+		    ha->host_no, lun, inq->inq[0], comp_status, scsi_status,
+		    rval1));
+
+		if (rval1 != QLA_SUCCESS || comp_status != SCS_COMPLETE ||
+		    scsi_status & SCSISTAT_CHECK_CONDITION) {
+
+			DEBUG2(printk("scsi(%d): INQ failed to issue iocb! "
+			    "fcport=[%04x/%p] rval=%x cs=%x ss=%x\n",
+			    ha->host_no, fcport->loop_id, fcport, rval1,
+			    comp_status, scsi_status));
+
+
+			if (scsi_status & SCSISTAT_CHECK_CONDITION) {
+				DEBUG2(printk("scsi(%d): INQ "
+				    "SCSISTAT_CHECK_CONDITION Sense Data "
+				    "%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				    ha->host_no,
+				    inq->p.rsp.senseData[0],
+				    inq->p.rsp.senseData[1],
+				    inq->p.rsp.senseData[2],
+				    inq->p.rsp.senseData[3],
+				    inq->p.rsp.senseData[4],
+				    inq->p.rsp.senseData[5],
+				    inq->p.rsp.senseData[6],
+				    inq->p.rsp.senseData[7]));
+			}
+
+			/* Device underrun, treat as OK. */
+			if (rval1 == QLA_SUCCESS &&
+			    comp_status == SCS_DATA_UNDERRUN &&
+			    iscsi_flags & ISCSI_FLAG_RESIDUAL_UNDER) {
+
+				rval = QLA_SUCCESS;
+				break;
+			}
+		} else {
+			rval = QLA_SUCCESS;
+			break;
+		}
+	}
+
+	return (rval);
+}
+
+int
+qla4xxx_issue_scsi_inquiry(scsi_qla_host_t *ha, 
+	fc_port_t *fcport, fc_lun_t *fclun )
+{
+	inq_cmd_rsp_t	*pkt;
+	dma_addr_t	phys_address = 0;
+	int		ret = 0;
+	
+	pkt = pci_alloc_consistent(ha->pdev,
+	    sizeof(inq_cmd_rsp_t), &phys_address);
+
+	if (pkt == NULL) {
+		printk(KERN_WARNING
+		    "scsi(%d): Memory Allocation failed - INQ\n", ha->host_no);
+		ha->mem_err++;
+		return BIT_0;
+	}
+
+	if ( qla4xxx_inquiry(ha, fcport,
+		fclun->lun, pkt, phys_address) != QLA_SUCCESS) {
+			 
+		DEBUG2(printk("%s: Failed lun inquiry - "
+			"inq[0]= 0x%x, "
+			"\n",
+			__func__,pkt->inq[0]);)
+		ret = 1;
+	} else {
+		fclun->device_type = pkt->inq[0];
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(inq_cmd_rsp_t), pkt, phys_address);
+
+	return (ret);
+}
+
+int
+qla4xxx_test_active_lun(fc_port_t *fcport, fc_lun_t *fclun) 
+{
+	tur_cmd_rsp_t	*pkt;
+	int		rval = 0 ; 
+	dma_addr_t	phys_address = 0;
+	int		retry;
+	uint8_t	comp_status;
+	uint8_t	scsi_status;
+	uint8_t iscsi_flags;
+	ddb_entry_t	*ddb_entry = fcport->ddbptr;
+	scsi_qla_host_t *ha;
+	uint16_t	lun = 0;
+
+	ENTER(__func__);
+
+
+	ha = fcport->ha;
+	if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD){
+		DEBUG2(printk("scsi(%d) %s leaving: Port loop_id 0x%02x is marked DEAD\n",
+			ha->host_no,__func__,fcport->loop_id);)
+		return rval;
+	}
+	
+	if ( fclun == NULL ){
+		DEBUG2(printk("scsi(%d) %s Bad fclun ptr on entry.\n",
+			ha->host_no,__func__);)
+		return rval;
+	}
+	
+	lun = fclun->lun;
+
+	pkt = pci_alloc_consistent(ha->pdev,
+	    sizeof(tur_cmd_rsp_t), &phys_address);
+
+	if (pkt == NULL) {
+		printk(KERN_WARNING
+		    "scsi(%d): Memory Allocation failed - TUR\n",
+		    ha->host_no);
+		ha->mem_err++;
+		return rval;
+	}
+
+	retry = 4;
+	do {
+		memset(pkt, 0, sizeof(tur_cmd_rsp_t));
+		pkt->p.cmd.hdr.entryType = ET_COMMAND;
+		/* 8 byte lun number */
+		pkt->p.cmd.lun[1]            = LSB(cpu_to_le16(lun)); /*SAMII compliant lun*/
+		pkt->p.cmd.lun[2]            = MSB(cpu_to_le16(lun));
+		
+		/* rlc->p.cmd.handle = 1; */
+		pkt->p.cmd.hdr.entryCount = 1;
+		pkt->p.cmd.target = cpu_to_le16(ddb_entry->fw_ddb_index);
+		pkt->p.cmd.control_flags = (CF_NO_DATA | CF_SIMPLE_TAG);
+		pkt->p.cmd.cdb[0] = TEST_UNIT_READY;
+		pkt->p.cmd.dataSegCnt = __constant_cpu_to_le16(0);
+		pkt->p.cmd.timeout = __constant_cpu_to_le16(10);
+		pkt->p.cmd.ttlByteCnt = __constant_cpu_to_le32(0);
+		/* If in connection mode, bump sequence number */
+		if ((ha->firmware_options & FWOPT_SESSION_MODE) != 0)
+		 	ddb_entry->CmdSn++;
+		pkt->p.cmd.cmdSeqNum = cpu_to_le32(ddb_entry->CmdSn);	
+
+		rval = qla4xxx_issue_iocb(ha, pkt, phys_address,
+		    sizeof(tur_cmd_rsp_t));
+			
+		comp_status = pkt->p.rsp.completionStatus;
+		scsi_status = pkt->p.rsp.scsiStatus;
+		iscsi_flags = pkt->p.rsp.iscsiFlags;
+
+#if 0
+
+		if (rval != QLA_SUCCESS || comp_status != SCS_COMPLETE ||
+		    (scsi_status & SCSISTAT_CHECK_CONDITION) ) {
+			/* Device underrun, treat as OK. */
+			if (rval == QLA_SUCCESS &&
+			    comp_status == SCS_DATA_UNDERRUN &&
+			    iscsi_flags & ISCSI_FLAG_RESIDUAL_UNDER) {
+				rval = QLA_SUCCESS;
+				break;
+			}
+		}
+#endif
+		
+		/* Port Logged Out, so don't retry */
+		if (comp_status ==  SCS_DEVICE_LOGGED_OUT ||
+		    comp_status ==  SCS_INCOMPLETE ||
+		    comp_status ==  SCS_DEVICE_UNAVAILABLE ||
+		    comp_status ==  SCS_DEVICE_CONFIG_CHANGED )
+			break;
+
+		DEBUG(printk("scsi(%ld:%04x:%d) %s: TEST UNIT READY - comp "
+		    "status 0x%x, scsi status 0x%x, rval=%d\n", ha->host_no,
+		    fcport->loop_id, lun,__func__, comp_status, scsi_status,
+		    rval));
+
+		if ((scsi_status & SCSISTAT_CHECK_CONDITION)) {
+			DEBUG2(printk("%s: check status bytes = "
+			    "0x%02x 0x%02x 0x%02x\n", __func__,
+			    pkt->p.rsp.senseData[2],
+			    pkt->p.rsp.senseData[12],
+			    pkt->p.rsp.senseData[13]));
+
+			if (pkt->p.rsp.senseData[2] == NOT_READY && 
+			    pkt->p.rsp.senseData[12] == 0x4 &&
+			    pkt->p.rsp.senseData[13] == 0x2) 
+				break;
+		}
+	} while ((rval != QLA_SUCCESS || comp_status != SCS_COMPLETE ||
+	    (scsi_status & SCSISTAT_CHECK_CONDITION)) && retry--);
+
+	if (rval == QLA_SUCCESS &&
+	    (!((scsi_status & SCSISTAT_CHECK_CONDITION) &&
+		(pkt->p.rsp.senseData[2] == NOT_READY &&
+		    pkt->p.rsp.senseData[12] == 0x4 &&
+		    pkt->p.rsp.senseData[13] == 0x2)) &&
+	     comp_status == SCS_COMPLETE)) {
+		
+		DEBUG2(printk("scsi(%d) %s - Lun (0x%02x:%d) set to ACTIVE.\n",
+		    ha->host_no, __func__, fcport->loop_id, lun));
+
+		/* We found an active path */
+		fclun->flags |= FLF_ACTIVE_LUN;
+		rval = 1;
+	} else {
+		DEBUG2(printk("scsi(%d) %s - Lun (0x%02x:%d) set to "
+		    "INACTIVE.\n", ha->host_no, __func__,
+		    fcport->loop_id, lun));
+		/* fcport->flags &= ~(FCF_MSA_PORT_ACTIVE); */
+		fclun->flags &= ~(FLF_ACTIVE_LUN);
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(tur_cmd_rsp_t), pkt, phys_address);
+
+	LEAVE(__func__);
+
+	return rval;
+}
+
+#if MSA1000_SUPPORTED
+static fc_lun_t *
+qla4xxx_find_data_lun(fc_port_t *fcport) 
+{
+	scsi_qla_host_t *ha;
+	fc_lun_t	*fclun, *ret_fclun;
+
+	ha = fcport->ha;
+	ret_fclun = NULL;
+
+	/* Go thur all luns and find a good data lun */
+	list_for_each_entry(fclun, &fcport->fcluns, list) {
+		fclun->flags &= ~FLF_VISIBLE_LUN;
+		if (fclun->device_type == 0xff)
+			qla4xxx_issue_scsi_inquiry(ha, fcport, fclun);
+		if (fclun->device_type == 0xc)
+			fclun->flags |= FLF_VISIBLE_LUN;
+		else if (fclun->device_type == TYPE_DISK) {
+			ret_fclun = fclun;
+		}
+	}
+	return (ret_fclun);
+}
+
+/*
+ * qla4xxx_test_active_port
+ *	Determines if the port is in active or standby mode. First, we
+ *	need to locate a storage lun then do a TUR on it. 
+ *
+ * Input:
+ *	fcport = port structure pointer.
+ *	
+ *
+ * Return:
+ *	0  - Standby or error
+ *  1 - Active
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla4xxx_test_active_port(fc_port_t *fcport) 
+{
+	tur_cmd_rsp_t	*pkt;
+	int		rval = 0 ; 
+	dma_addr_t	phys_address = 0;
+	int		retry;
+	uint16_t	comp_status;
+	uint16_t	scsi_status;
+	scsi_qla_host_t *ha;
+	uint16_t	lun = 0;
+	fc_lun_t	*fclun;
+
+	ENTER(__func__);
+
+	ha = fcport->ha;
+	if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD) {
+		DEBUG2(printk("scsi(%ld) %s leaving: Port 0x%02x is marked "
+		    "DEAD\n", ha->host_no,__func__,fcport->loop_id);)
+		return rval;
+	}
+
+	if ((fclun = qla4xxx_find_data_lun(fcport)) == NULL) {
+		DEBUG2(printk(KERN_INFO "%s leaving: Couldn't find data lun\n",
+		    __func__);)
+		return rval;
+	} 
+	lun = fclun->lun;
+
+	pkt = pci_alloc_consistent(ha->pdev, sizeof(tur_cmd_rsp_t),
+	    &phys_address);
+
+	if (pkt == NULL) {
+		printk(KERN_WARNING
+		    "scsi(%ld): Memory Allocation failed - TUR\n",
+		    ha->host_no);
+		ha->mem_err++;
+		return rval;
+	}
+
+	retry = 4;
+	do {
+		memset(pkt, 0, sizeof(tur_cmd_rsp_t));
+		//pkt->p.cmd.entry_type = COMMAND_A64_TYPE;
+		//pkt->p.cmd.entry_count = 1;
+		//pkt->p.cmd.lun = cpu_to_le16(lun);
+		// SET_TARGET_ID(ha, pkt->p.cmd.target, fcport->loop_id);
+		pkt->p.cmd.hdr.entryType = ET_COMMAND;
+		/* 8 byte lun number */
+		pkt->p.cmd.lun[1]            = LSB(cpu_to_le16(lun)); /*SAMII compliant lun*/
+		pkt->p.cmd.lun[2]            = MSB(cpu_to_le16(lun));
+		pkt->p.cmd.target = cpu_to_le16(ddb_entry->fw_ddb_index);
+
+		pkt->p.cmd.control_flags = CF_SIMPLE_TAG;
+		pkt->p.cmd.scsi_cdb[0] = TEST_UNIT_READY;
+
+		pkt->p.cmd.dataSegCnt = __constant_cpu_to_le16(0);
+		pkt->p.cmd.timeout = __constant_cpu_to_le16(10);
+		pkt->p.cmd.ttlByteCnt = __constant_cpu_to_le32(0);
+
+		rval = qla4xxx_issue_iocb(ha, pkt, phys_address,
+		    sizeof(tur_cmd_rsp_t));
+
+		comp_status = le16_to_cpu(pkt->p.rsp.comp_status);
+		scsi_status = le16_to_cpu(pkt->p.rsp.scsi_status);
+
+ 		/* Port Logged Out, so don't retry */
+		if (comp_status == CS_PORT_LOGGED_OUT ||
+		    comp_status == CS_PORT_CONFIG_CHG ||
+		    comp_status == CS_PORT_BUSY ||
+		    comp_status == CS_INCOMPLETE ||
+		    comp_status == CS_PORT_UNAVAILABLE)
+			break;
+
+		DEBUG(printk("scsi(%ld:%04x:%d) %s: TEST UNIT READY - comp "
+		    "status 0x%x, scsi status 0x%x, rval=%d\n", ha->host_no,
+		    fcport->loop_id, lun,__func__, comp_status, scsi_status,
+		    rval));
+		if ((scsi_status & SS_CHECK_CONDITION)) {
+			DEBUG2(printk("%s: check status bytes = "
+			    "0x%02x 0x%02x 0x%02x\n", __func__,
+			    pkt->p.rsp.req_sense_data[2],
+			    pkt->p.rsp.req_sense_data[12],
+			    pkt->p.rsp.req_sense_data[13]));
+
+			if (pkt->p.rsp.req_sense_data[2] == NOT_READY &&
+			    pkt->p.rsp.req_sense_data[12] == 0x4 &&
+			    pkt->p.rsp.req_sense_data[13] == 0x2)
+				break;
+		}
+	} while ((rval != QLA_SUCCESS || comp_status != CS_COMPLETE ||
+	    (scsi_status & SS_CHECK_CONDITION)) && retry--);
+
+	if (rval == QLA_SUCCESS &&
+	    (!((scsi_status & SS_CHECK_CONDITION) &&
+		(pkt->p.rsp.req_sense_data[2] == NOT_READY &&
+		    pkt->p.rsp.req_sense_data[12] == 0x4 &&
+		    pkt->p.rsp.req_sense_data[13] == 0x2 ) ) &&
+	     comp_status == CS_COMPLETE)) {
+		DEBUG2(printk("scsi(%ld) %s - Port (0x%04x) set to ACTIVE.\n",
+		    ha->host_no, __func__, fcport->loop_id));
+		/* We found an active path */
+       		fcport->flags |= FCF_MSA_PORT_ACTIVE;
+		rval = 1;
+	} else {
+		DEBUG2(printk("scsi(%ld) %s - Port (0x%04x) set to INACTIVE.\n",
+		    ha->host_no, __func__, fcport->loop_id));
+       		fcport->flags &= ~(FCF_MSA_PORT_ACTIVE);
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(tur_cmd_rsp_t), pkt, phys_address);
+
+	LEAVE(__func__);
+
+	return rval;
+}
+#endif
+/*
+ * qla4xxx_cfg_lun
+ *	Configures LUN into fcport LUN list.
+ *
+ * Input:
+ *	fcport:		FC port structure pointer.
+ *	lun:		LUN number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+fc_lun_t *
+qla4xxx_cfg_lun(scsi_qla_host_t *ha, fc_port_t *fcport, uint16_t lun,
+                inq_cmd_rsp_t *inq, dma_addr_t inq_dma)
+{
+	fc_lun_t *fclun;
+
+	/* Bypass LUNs that failed. */
+	if (qla4xxx_failover_enabled(ha)) {
+	if (qla4xxx_inquiry(ha, fcport, lun, inq, inq_dma) != QLA_SUCCESS) {
+		DEBUG2(printk("scsi(%d): Failed inquiry - loop id=0x%04x "
+		    "lun=%d\n", ha->host_no, fcport->loop_id, lun));
+
+		return (NULL);
+	}
+	}
+
+	switch (inq->inq[0]) {
+	case TYPE_DISK:
+	case TYPE_PROCESSOR:
+	case TYPE_WORM:
+	case TYPE_ROM:
+	case TYPE_SCANNER:
+	case TYPE_MOD:
+	case TYPE_MEDIUM_CHANGER:
+	case TYPE_ENCLOSURE:
+	case 0x20:
+	case 0x0C:
+		break;
+	case TYPE_TAPE:
+		fcport->flags |= FCF_TAPE_PRESENT;
+		break;
+	default:
+		DEBUG2(printk("scsi(%d): Unsupported lun type -- "
+		    "loop id=0x%04x lun=%d type=%x\n",
+		    ha->host_no, fcport->loop_id, lun, inq->inq[0]));
+		return (NULL);
+	}
+
+	fcport->device_type = inq->inq[0];
+	
+	/* Does this port require special failover handling? */
+	if (qla4xxx_failover_enabled(ha)) {
+		fcport->cfg_id = qla4xxx_cfg_lookup_device(&inq->inq[0]);
+		qla4xxx_set_device_flags(ha, fcport);
+	}
+	fclun = qla4xxx_add_fclun(fcport, lun);
+
+	if (fclun != NULL) {
+		atomic_set(&fcport->state, FCS_ONLINE);
+	}
+
+	return (fclun);
+}
+
+/*
+ * qla4xxx_lun_discovery
+ *	Issue SCSI inquiry command for LUN discovery.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+void
+qla4xxx_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	inq_cmd_rsp_t	*inq;
+	dma_addr_t	inq_dma;
+	uint16_t	lun;
+
+	inq = pci_alloc_consistent(ha->pdev, sizeof(inq_cmd_rsp_t), &inq_dma);
+	if (inq == NULL) {
+		printk(KERN_WARNING
+		    "Memory Allocation failed - INQ\n");
+		return;
+	}
+
+	/* If report LUN works, exit. */
+	if (qla4xxx_rpt_lun_discovery(ha, fcport, inq, inq_dma) !=
+	    QLA_SUCCESS) {
+		for (lun = 0; lun < MAX_LUNS; lun++) {
+			/* Configure LUN. */
+			qla4xxx_cfg_lun(ha, fcport, lun, inq, inq_dma);
+		}
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(inq_cmd_rsp_t), inq, inq_dma);
+}
+
+/*
+ * qla4xxx_rpt_lun_discovery
+ *	Issue SCSI report LUN command for LUN discovery.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla4xxx_rpt_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport,
+    inq_cmd_rsp_t *inq, dma_addr_t inq_dma)
+{
+	int			rval;
+	uint32_t		len, cnt;
+	uint16_t		lun;
+	rpt_lun_cmd_rsp_t	*rlc;
+	dma_addr_t		rlc_dma;
+
+	/* Assume a failed status */
+	rval = QLA_ERROR;
+
+	/* No point in continuing if the device doesn't support RLC */
+	if ((fcport->flags & FCF_RLC_SUPPORT) == 0)
+		return (rval);
+
+	rlc = pci_alloc_consistent(ha->pdev, sizeof(rpt_lun_cmd_rsp_t),
+	    &rlc_dma);
+	if (rlc == NULL) {
+		printk(KERN_WARNING
+			"Memory Allocation failed - RLC");
+		return QLA_ERROR;
+	}
+	rval = qla4xxx_report_lun(ha, fcport, rlc, rlc_dma);
+	if (rval != QLA_SUCCESS) {
+		pci_free_consistent(ha->pdev, sizeof(rpt_lun_cmd_rsp_t), rlc,
+		    rlc_dma);
+		return (rval);
+	}
+
+	/* Always add a fc_lun_t structure for lun 0 -- mid-layer requirement */
+	qla4xxx_add_fclun(fcport, 0);
+
+	/* Configure LUN list. */
+	len = be32_to_cpu(rlc->list.hdr.len);
+	len /= 8;
+	for (cnt = 0; cnt < len; cnt++) {
+		lun = CHAR_TO_SHORT(rlc->list.lst[cnt].lsb,
+		    rlc->list.lst[cnt].msb.b);
+
+		DEBUG2(printk("scsi(%d): RLC lun = (%d)\n", ha->host_no, lun));
+
+		/* We only support 0 through MAX_LUNS-1 range */
+		if (lun < MAX_LUNS) {
+			qla4xxx_cfg_lun(ha, fcport, lun, inq, inq_dma);
+		}
+	}
+		atomic_set(&fcport->state, FCS_ONLINE);
+
+	pci_free_consistent(ha->pdev, sizeof(rpt_lun_cmd_rsp_t), rlc, rlc_dma);
+
+	return (rval);
+}
+
+/*
+ * qla4xxx_report_lun
+ *	Issue SCSI report LUN command.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *	mem:		pointer to dma memory object for report LUN IOCB
+ *			packet.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla4xxx_report_lun(scsi_qla_host_t *ha, fc_port_t *fcport,
+		   rpt_lun_cmd_rsp_t *rlc, dma_addr_t rlc_dma)
+{
+	int rval;
+	uint16_t retries;
+	uint8_t comp_status;
+	uint8_t scsi_status;
+	uint8_t iscsi_flags;
+	ddb_entry_t	*ddb_entry = fcport->ddbptr;
+
+	rval = QLA_ERROR;
+
+	for (retries = 3; retries; retries--) {
+		memset(rlc, 0, sizeof(rpt_lun_cmd_rsp_t));
+		rlc->p.cmd.hdr.entryType = ET_COMMAND;
+		
+		/* rlc->p.cmd.handle = 1; */
+		rlc->p.cmd.hdr.entryCount = 1;
+		rlc->p.cmd.target = cpu_to_le16(ddb_entry->fw_ddb_index);
+		rlc->p.cmd.control_flags = (CF_READ | CF_SIMPLE_TAG);
+		rlc->p.cmd.cdb[0] = REPORT_LUNS;
+		rlc->p.cmd.cdb[8] = MSB(sizeof(rpt_lun_lst_t));
+		rlc->p.cmd.cdb[9] = LSB(sizeof(rpt_lun_lst_t));
+		rlc->p.cmd.dataSegCnt = __constant_cpu_to_le16(1);
+		rlc->p.cmd.timeout = __constant_cpu_to_le16(10);
+		rlc->p.cmd.ttlByteCnt =
+		    __constant_cpu_to_le32(sizeof(rpt_lun_lst_t));
+		rlc->p.cmd.dataseg[0].base.addrLow = cpu_to_le32(
+		    LSDW(rlc_dma + sizeof(STATUS_ENTRY)));
+		rlc->p.cmd.dataseg[0].base.addrHigh = cpu_to_le32(
+		    MSDW(rlc_dma + sizeof(STATUS_ENTRY)));
+		rlc->p.cmd.dataseg[0].count =
+		    __constant_cpu_to_le32(sizeof(rpt_lun_lst_t));
+		/*  rlc->p.cmd.lun[8];	 always lun 0 */
+		/* If in connection mode, bump sequence number */
+		if ((ha->firmware_options & FWOPT_SESSION_MODE) != 0)
+		 	ddb_entry->CmdSn++;
+		rlc->p.cmd.cmdSeqNum = cpu_to_le32(ddb_entry->CmdSn);	
+
+		rval = qla4xxx_issue_iocb(ha, rlc, rlc_dma,
+		    sizeof(rpt_lun_cmd_rsp_t));
+			
+		comp_status = rlc->p.rsp.completionStatus;
+		scsi_status = rlc->p.rsp.scsiStatus;
+		iscsi_flags = rlc->p.rsp.iscsiFlags;
+
+		if (rval != QLA_SUCCESS ||
+		    comp_status != SCS_COMPLETE ||
+		    scsi_status & SCSISTAT_CHECK_CONDITION) {
+
+			/* Device underrun, treat as OK. */
+			if (rval == QLA_SUCCESS &&
+			    comp_status == SCS_DATA_UNDERRUN &&
+			    iscsi_flags & ISCSI_FLAG_RESIDUAL_UNDER) {
+
+				rval = QLA_SUCCESS;
+				break;
+			}
+
+			DEBUG2(printk("scsi(%d): RLC failed to issue iocb! "
+			    "fcport=[%04x/%p] rval=%x cs=%x ss=%x\n",
+			    ha->host_no, fcport->loop_id, fcport, rval,
+			    comp_status, scsi_status));
+
+			rval = QLA_ERROR;
+			if (scsi_status & SCSISTAT_CHECK_CONDITION) {
+				DEBUG2(printk("scsi(%d): RLC "
+				    "SCSISTAT_CHECK_CONDITION Sense Data "
+				    "%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				    ha->host_no,
+				    rlc->p.rsp.senseData[0],
+				    rlc->p.rsp.senseData[1],
+				    rlc->p.rsp.senseData[2],
+				    rlc->p.rsp.senseData[3],
+				    rlc->p.rsp.senseData[4],
+				    rlc->p.rsp.senseData[5],
+				    rlc->p.rsp.senseData[6],
+				    rlc->p.rsp.senseData[7]));
+				if (rlc->p.rsp.senseData[2] ==
+				    ILLEGAL_REQUEST) {
+					fcport->flags &= ~(FCF_RLC_SUPPORT);
+					break;
+				}
+			}
+		} else {
+			break;
+		}
+	}
+
+	return (rval);
+}
+
+#if MSA1000_SUPPORTED
+static int
+qla4xxx_spinup(scsi_qla_host_t *ha, fc_port_t *fcport, uint16_t lun) 
+{
+	inq_cmd_rsp_t	*pkt;
+	int		rval = QLA_SUCCESS;
+	int		count, retry;
+	dma_addr_t	phys_address = 0;
+	uint16_t	comp_status = CS_COMPLETE;
+	uint16_t	scsi_status = 0;
+
+	ENTER(__func__);
+
+	pkt = pci_alloc_consistent(ha->pdev,
+	    sizeof(inq_cmd_rsp_t), &phys_address);
+
+	if (pkt == NULL) {
+		printk(KERN_WARNING
+		    "scsi(%ld): Memory Allocation failed - INQ\n",
+		    ha->host_no);
+		return( QLA_FUNCTION_FAILED);
+	}
+
+	count = 5; 
+	retry = 5;
+	if (atomic_read(&fcport->state) != FCS_ONLINE) {
+		DEBUG2(printk("scsi(%ld) %s leaving: Port 0x%02x is not ONLINE\n",
+			ha->host_no,__func__,fcport->loop_id);)
+		rval =  QLA_FUNCTION_FAILED;
+	}
+	else do {
+		/* issue spinup */
+		memset(pkt, 0, sizeof(inq_cmd_rsp_t));
+		pkt->p.cmd.entry_type = COMMAND_A64_TYPE;
+		pkt->p.cmd.entry_count = 1;
+		/* 8 byte lun number */
+		inq->p.cmd.lun[1]            = LSB(cpu_to_le16(lun)); /*SAMII compliant lun*/
+		inq->p.cmd.lun[2]            = MSB(cpu_to_le16(lun));
+		SET_TARGET_ID(ha, pkt->p.cmd.target, fcport->loop_id);
+		/* no direction for this command */
+		pkt->p.cmd.control_flags =
+		    __constant_cpu_to_le16(CF_SIMPLE_TAG);
+		pkt->p.cmd.scsi_cdb[0] = START_STOP;
+		pkt->p.cmd.scsi_cdb[4] = 1;	/* start spin cycle */
+		pkt->p.cmd.dseg_count = __constant_cpu_to_le16(0);
+		pkt->p.cmd.timeout = __constant_cpu_to_le16(20);
+		pkt->p.cmd.byte_count = __constant_cpu_to_le32(0);
+
+		rval = qla4xxx_issue_iocb(ha, pkt,
+		    phys_address, sizeof(inq_cmd_rsp_t));
+
+		comp_status = le16_to_cpu(pkt->p.rsp.comp_status);
+		scsi_status = le16_to_cpu(pkt->p.rsp.scsi_status);
+
+ 		/* Port Logged Out, so don't retry */
+		if( 	comp_status == CS_PORT_LOGGED_OUT  ||
+			comp_status == CS_PORT_CONFIG_CHG ||
+			comp_status == CS_PORT_BUSY ||
+			comp_status == CS_INCOMPLETE ||
+			comp_status == CS_PORT_UNAVAILABLE ) {
+			break;
+		}
+
+		if ( (scsi_status & SS_CHECK_CONDITION) ) {
+			DEBUG2(printk("%s(%ld): SS_CHECK_CONDITION "
+			    "Sense Data "
+			    "%02x %02x %02x %02x "
+			    "%02x %02x %02x %02x\n",
+			    __func__,
+			    ha->host_no,
+			    pkt->p.rsp.req_sense_data[0],
+			    pkt->p.rsp.req_sense_data[1],
+			    pkt->p.rsp.req_sense_data[2],
+			    pkt->p.rsp.req_sense_data[3],
+			    pkt->p.rsp.req_sense_data[4],
+			    pkt->p.rsp.req_sense_data[5],
+			    pkt->p.rsp.req_sense_data[6],
+			    pkt->p.rsp.req_sense_data[7]);)
+				if (pkt->p.rsp.req_sense_data[2] ==
+				    NOT_READY  &&
+				    (pkt->p.rsp.req_sense_data[12] == 4 ) &&
+				    (pkt->p.rsp.req_sense_data[13] == 3 ) ) {
+
+					current->state = TASK_UNINTERRUPTIBLE;
+					schedule_timeout(HZ);
+					printk(".");
+					count--;
+				} else
+					retry--;
+		}
+
+		printk(KERN_INFO 
+			"qla_fo(%ld): Sending Start - count %d, retry=%d"
+		    "comp status 0x%x, "
+		    "scsi status 0x%x, rval=%d\n",
+				ha->host_no,
+		    count,
+		    retry,
+		    comp_status,
+		    scsi_status, 
+		    rval);
+
+		if ((rval != QLA_SUCCESS) || (comp_status != CS_COMPLETE))
+			retry--;
+
+	} while ( count && retry  &&
+		 (rval != QLA_SUCCESS ||
+		  comp_status != CS_COMPLETE ||
+		(scsi_status & SS_CHECK_CONDITION)));
+
+
+	if (rval != QLA_SUCCESS ||
+	    comp_status != CS_COMPLETE ||
+	    (scsi_status & SS_CHECK_CONDITION)) {
+
+		DEBUG(printk("qla_fo(%ld): Failed spinup - "
+		    "comp status 0x%x, "
+		    "scsi status 0x%x. loop_id=%d\n",
+				ha->host_no,
+		    comp_status,
+		    scsi_status, 
+		    fcport->loop_id);)
+				rval =  QLA_FUNCTION_FAILED;
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(inq_cmd_rsp_t),
+	    pkt, phys_address);
+
+
+	LEAVE(__func__);
+
+	return( rval );
+
+}
+#endif
+
+
+
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_foioctl.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_foioctl.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_foioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_foioctl.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,273 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP4xxx device driver for Linux 2.6.x
+* Copyright (C) 2004 QLogic Corporation
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+******************************************************************************
+* Failover include file
+******************************************************************************/
+
+#include "ql4_def.h"
+
+#include <linux/blkdev.h>
+#include <asm/uaccess.h>
+
+#include "qlnfo.h"
+#include "ql4_ioctl.h"
+
+/*
+ * Global variables
+ */
+
+/*
+ * Support routines
+ */
+
+/*
+ * qla4xxx_get_hba
+ *	Searches the hba structure chain for the requested instance
+ *      aquires the mutex and returns a pointer to the hba structure.
+ *
+ * Input:
+ *	inst = adapter instance number.
+ *
+ * Returns:
+ *	Return value is a pointer to the adapter structure or
+ *      NULL if instance not found.
+ *
+ * Context:
+ *	Kernel context.
+ */
+scsi_qla_host_t *
+qla4xxx_get_hba(unsigned long instance)
+{
+	int	found;
+	scsi_qla_host_t *ha;
+
+	ha = NULL;
+	found = 0;
+	read_lock(&qla4xxx_hostlist_lock);
+	list_for_each_entry(ha, &qla4xxx_hostlist, list) {
+		if (ha->instance == instance) {
+			found++;
+			break;
+		}
+	}
+	read_unlock(&qla4xxx_hostlist_lock);
+
+	return (found ? ha : NULL);
+}
+
+/*
+ * qla4xxx_nfo_ioctl
+ *	Provides functions for failover ioctl() calls.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	ioctl_code = ioctl function to perform
+ *	arg = Address of application EXT_IOCTL_NFO cmd data
+ *	mode = flags
+ *
+ * Returns:
+ *	Return value is the ioctl rval_p return value.
+ *	0 = success
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla4xxx_nfo_ioctl(struct scsi_device *dev, int cmd, void *arg)
+{
+	char		*ptemp;
+	int		status = 0;
+	int		tmp_stat = 0;
+	EXT_IOCTL_NFO	*pioctl = NULL;
+	scsi_qla_host_t *ha = NULL;
+
+
+	ENTER(__func__);
+
+	/*
+	 * Check to see if we can access the ioctl command structure
+	 */
+	if (!access_ok(VERIFY_WRITE, arg, sizeof(EXT_IOCTL_NFO))) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: NULL EXT_IOCTL_NFO buffer\n",
+		    __func__));
+
+		status = (-EFAULT);
+		goto exit_qla4nfo_ioctl;
+	}
+
+	/* Allocate ioctl structure buffer to support multiple concurrent
+	 * entries. NO static structures allowed.
+	 */
+	pioctl = QL_KMEM_ZALLOC(sizeof(EXT_IOCTL_NFO));
+	if (pioctl == NULL) {
+		/* error */
+		printk(KERN_WARNING
+		    "qla4xxx: ERROR in main nfo ioctl buffer allocation.\n");
+		status = (-ENOMEM);
+		goto exit_qla4nfo_ioctl;
+	}
+
+	/*
+	 * Copy the ioctl command structure from user space to local structure
+	 */
+	status = copy_from_user((uint8_t *)pioctl, arg, sizeof(EXT_IOCTL_NFO));
+	if (status) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi: %s: EXT_IOCTL_NFO copy error.\n",
+		    __func__));
+
+		goto exit_qla4nfo_ioctl;
+	}
+	QL4PRINT(QLP4|QLP10, printk("EXT_IOCTL_NFO structure: \n"));
+	qla4xxx_dump_dwords(QLP4|QLP10, pioctl, sizeof(*pioctl));
+
+        /* check signature of this ioctl */
+        ptemp = (uint8_t *)pioctl->Signature;
+
+	if (memcmp(ptemp, NFO_DEF_SIGNATURE, NFO_DEF_SIGNATURE_SIZE) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: signature did not match. "
+		    "cmd=%x arg=%p.\n", __func__, cmd, arg));
+		pioctl->Status = EXT_STATUS_INVALID_PARAM;
+		status = copy_to_user(arg, (void *)pioctl,
+		    sizeof(EXT_IOCTL_NFO));
+
+		goto exit_qla4nfo_ioctl;
+	}
+
+	/* check version of this ioctl */
+	if (pioctl->Version > NFO_VERSION) {
+		printk(KERN_WARNING
+		    "ql4xxx: ioctl interface version not supported = %d.\n",
+		    pioctl->Version);
+
+		pioctl->Status = EXT_STATUS_UNSUPPORTED_VERSION;
+		status = copy_to_user(arg, (void *)pioctl,
+		    sizeof(EXT_IOCTL_NFO));
+		goto exit_qla4nfo_ioctl;
+	}
+
+	if (!((ulong)pioctl->VendorSpecificData & EXT_DEF_USE_HBASELECT)) {
+		/* we don't support api that are too old */
+		QL4PRINT(QLP2|QLP4,
+		    printk(
+		    "%s: got setinstance cmd w/o HbaSelect. Return error.\n",
+		    __func__));
+		pioctl->Status = EXT_STATUS_INVALID_PARAM;
+		status = copy_to_user(arg, (void *)pioctl,
+		    sizeof(EXT_IOCTL_NFO));
+		goto exit_qla4nfo_ioctl;
+	}
+
+	/*
+	 * Get the adapter handle for the corresponding adapter instance
+	 */
+	ha = qla4xxx_get_adapter_handle(pioctl->HbaSelect);
+	if (ha == NULL) {
+		QL4PRINT(QLP2,
+		    printk("%s: NULL EXT_IOCTL_NFO buffer\n",
+		    __func__));
+
+		pioctl->Status = EXT_STATUS_DEV_NOT_FOUND;
+		status = copy_to_user(arg, (void *)pioctl,
+		    sizeof(EXT_IOCTL_NFO));
+		goto exit_qla4nfo_ioctl;
+	}
+
+	QL4PRINT(QLP4, printk("scsi%d: ioctl+ (%s)\n", ha->host_no,
+	    IOCTL_TBL_STR(cmd, pioctl->SubCode)));
+
+	down(&ha->ioctl->ioctl_sem);
+
+	/*
+	 * If the DPC is active, wait for it to complete before proceeding
+	 */
+	while (ha->dpc_active) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1*HZ);
+	}
+
+	ha->i_start = jiffies;
+	ha->i_end = 0;
+	ha->f_start = 0;
+	ha->f_end = 0;
+
+	/*
+	 * Issue the ioctl command
+	 */
+	switch (cmd) {
+#if 0
+	case EXT_CC_TRANSPORT_INFO:
+	case EXT_CC_GET_FOM_PROP:
+	case EXT_CC_GET_HBA_INFO:
+	case EXT_CC_GET_DPG_PROP:
+	case EXT_CC_GET_DPG_PATH_INFO:
+	case EXT_CC_SET_DPG_PATH_INFO:
+	case EXT_CC_GET_LB_INFO:
+	case EXT_CC_GET_LB_POLICY:
+	case EXT_CC_SET_LB_POLICY:
+	case EXT_CC_GET_DPG_STATS:
+	case EXT_CC_CLEAR_DPG_ERR_STATS:
+	case EXT_CC_CLEAR_DPG_IO_STATS:
+	case EXT_CC_CLEAR_DPG_FO_STATS:
+	case EXT_CC_GET_PATHS_FOR_ALL:
+	case EXT_CC_MOVE_PATH:
+	case EXT_CC_VERIFY_PATH:
+	case EXT_CC_GET_EVENT_LIST:
+	case EXT_CC_ENABLE_FOM:
+	case EXT_CC_DISABLE_FOM:
+	case EXT_CC_GET_STORAGE_LIST:
+		status = xx();
+		break;
+#endif
+	default:
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unsupported command code (%X)\n",
+		    ha->host_no, __func__, cmd));
+
+		pioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+	}
+
+	/*
+	 * Copy the updated ioctl structure back to the user
+	 */
+	tmp_stat = copy_to_user(arg, (void *)pioctl, sizeof(EXT_IOCTL_NFO));
+	if (status == 0)
+		status = tmp_stat;
+
+	ha->i_end = jiffies;
+
+	up(&ha->ioctl->ioctl_sem);
+
+	QL4PRINT(QLP4, printk("scsi%d: ioctl- (%s) "
+	    "i_start=%lx, f_start=%lx, f_end=%lx, i_end=%lx\n",
+	    ha->host_no, IOCTL_TBL_STR(cmd, pioctl->SubCode),
+	    ha->i_start, ha->f_start, ha->f_end, ha->i_end));
+
+exit_qla4nfo_ioctl:
+
+	if (pioctl)
+		QL_KMEM_FREE(pioctl);
+
+	LEAVE(__func__);
+
+	return (status);
+}
+
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_foln.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_foln.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_foln.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_foln.c	2004-10-13 22:54:43.000000000 +0200
@@ -0,0 +1,607 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP4xxx device driver for Linux 2.6.x
+* Copyright (C) 2003-2004 QLogic Corporation
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/moduleparam.h>
+//#include <linux/vmalloc.h>
+//#include <linux/smp_lock.h>
+//#include <linux/delay.h>
+
+//#include "qla_os.h"
+#include "ql4_def.h"
+
+#include "qlfo.h"
+#include "qlfolimits.h"
+/*
+#include "ql4_foln.h"
+*/
+
+int ql4xfailover = 0;
+module_param(ql4xfailover, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xfailover,
+		"Driver failover support: 0 to disable; 1 to enable.");
+
+int ql4xrecoveryTime = MAX_RECOVERYTIME;
+module_param_named(recoveryTime, ql4xrecoveryTime, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(recoveryTime,
+		"Recovery time in seconds before a target device is sent I/O "
+		"after a failback is performed.");
+
+int ql4xfailbackTime = MAX_FAILBACKTIME;
+module_param_named(failbackTime, ql4xfailbackTime, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(failbackTime,
+		"Delay in seconds before a failback is performed.");
+
+int MaxPathsPerDevice = 0;
+module_param(MaxPathsPerDevice, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(MaxPathsPerDevice,
+		"Maximum number of paths to a device.  Default 8.");
+
+int MaxRetriesPerPath = 0;
+module_param(MaxRetriesPerPath, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(MaxRetriesPerPath,
+		"How many retries to perform on the current path before "
+		"failing over to the next path in the path list.");
+
+int MaxRetriesPerIo = 0;
+module_param(MaxRetriesPerIo, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(MaxRetriesPerIo,
+		"How many total retries to do before failing the command and "
+		"returning to the OS with a DID_NO_CONNECT status.");
+
+int qlFailoverNotifyType = 0;
+module_param(qlFailoverNotifyType, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(qlFailoverNotifyType,
+		"Failover notification mechanism to use when a failover or "
+		"failback occurs.");
+		
+struct cfg_device_info cfg_device_list[] = {
+
+	{"IBM","DS300", 0x10, FO_NOTIFY_TYPE_NONE,   
+		qla4xxx_combine_by_lunid, NULL, NULL, NULL },
+	{"IBM","DS400",0x10, FO_NOTIFY_TYPE_NONE,   
+		qla4xxx_combine_by_lunid, NULL, NULL, NULL },
+
+	/*
+	 * Must be at end of list...
+	 */
+	{NULL, NULL }
+};
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+/*
+ *  qla4xxx_flush_failover_queue
+ *	Return cmds of a "specific" LUN from the failover queue with
+ *      DID_BUS_BUSY status.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *      q  = lun queue.
+ *
+ * Context:
+ *	Interrupt context.
+ */
+void
+qla4xxx_flush_failover_q(scsi_qla_host_t *ha, os_lun_t *q)
+{
+	srb_t  *sp;
+	struct list_head *list, *temp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	list_for_each_safe(list, temp, &ha->failover_queue){
+		sp = list_entry(list, srb_t, list_entry);
+		/*
+		 * If request originated from the same lun_q then delete it
+		 * from the failover queue
+		 */
+		if (q == sp->lun_queue) {
+			/* Remove srb from failover queue. */
+			__del_from_failover_queue(ha,sp);
+			sp->cmd->result = DID_BUS_BUSY << 16;
+			sp->cmd->host_scribble = (unsigned char *) NULL;
+			__add_to_done_srb_q(ha,sp);
+		}
+	}		     /* list_for_each_safe() */
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+#endif
+
+/*
+ * qla4xxx_check_for_devices_online
+ *
+ *	Check fcport state of all devices to make sure online.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Return:
+ *	None.
+ *
+ * Context:
+ */
+static uint8_t
+qla4xxx_check_for_devices_online(scsi_qla_host_t *ha) 
+{
+	fc_port_t	*fcport;
+
+
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		if(fcport->port_type != FCT_TARGET)
+			continue;
+
+		if ((atomic_read(&fcport->state) == FCS_ONLINE) ||
+		    (atomic_read(&fcport->state) == FCS_DEVICE_DEAD) ||
+		    fcport->flags & FCF_FAILBACK_DISABLE)
+			continue;
+
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ *  qla4xxx_failover_cleanup
+ *	Cleanup queues after a failover.
+ *
+ * Input:
+ *	sp = command pointer
+ *
+ * Context:
+ *	Interrupt context.
+ */
+static void
+qla4xxx_failover_cleanup(srb_t *sp) 
+{
+	sp->cmd->result = DID_BUS_BUSY << 16;
+	sp->cmd->host_scribble = (unsigned char *) NULL;
+
+	/* turn-off all failover flags */
+	sp->flags = sp->flags & ~(SRB_RETRY|SRB_FAILOVER|SRB_FO_CANCEL);
+}
+
+int
+qla4xxx_suspend_failover_targets(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+	struct list_head *list, *temp;
+	srb_t *sp;
+	int count;
+	os_tgt_t *tq;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	count = ha->failover_cnt;
+	list_for_each_safe(list, temp, &ha->failover_queue) {
+		sp = list_entry(ha->failover_queue.next, srb_t, list_entry);
+		tq = sp->tgt_queue;
+		if (!(test_bit(TQF_SUSPENDED, &tq->flags)))
+			set_bit(TQF_SUSPENDED, &tq->flags);
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	return count;
+}
+
+srb_t *
+qla4xxx_failover_next_request(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+	srb_t       *sp = NULL;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	if (!list_empty(&ha->failover_queue)) {
+		sp = list_entry(ha->failover_queue.next, srb_t, list_entry);
+		__del_from_failover_queue(ha, sp);
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+	return( sp );
+}
+static void qla4xxx_resume_failover_targets(scsi_qla_host_t *ha)
+{
+	uint32_t    t, l;
+	os_tgt_t        *tq;
+	os_lun_t        *lq;
+
+	for (t = 0; t < ha->host->max_id; t++) {
+		if ((tq = ha->otgt[t]) == NULL)
+			continue;
+		if (test_and_clear_bit(TQF_SUSPENDED, &tq->flags)) {
+			/* EMPTY */
+			DEBUG2(printk("%s(): remove suspend for "
+				      "target %d\n",
+				      __func__,
+				      t);)
+		}
+		for (l = 0; l < MAX_LUNS; l++) {
+			if ((lq = (os_lun_t *) tq->olun[l]) == NULL)
+				continue;
+
+#if 0
+			if (test_and_clear_bit(LUN_MPIO_BUSY, &lq->q_flag)) {
+				/* EMPTY */
+				DEBUG2(printk("%s(): remove suspend for "
+					      "lun %d\n",
+					      __func__,
+					      lq->fclun->lun);)
+			}
+#endif
+		}
+	}
+
+}
+
+
+#if 0
+/*
+ *  qla4xxx_process_failover
+ *	Process any command on the failover queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Interrupt context.
+ */
+static void
+qla4xxx_process_failover(scsi_qla_host_t *ha)
+{
+
+	srb_t       *sp;
+	fc_port_t *fcport;
+	scsi_qla_host_t *vis_ha = ha;
+	int      count, i;
+	os_tgt_t        *tq;
+	os_lun_t        *lq;
+
+	DEBUG2(printk(KERN_INFO "scsi%d: %s: active=%ld, retry=%d, "
+		      "done=%ld, failover=%d commands.\n",
+		      ha->host_no,
+		      __func__,
+		      ha->num_srbs_allocated,
+		      ha->retry_srb_q_count,
+		      ha->done_srb_q_count,
+		      ha->failover_cnt);)
+
+
+	/* Prevent acceptance of new I/O requests for failover target. */
+	count = qla4xxx_suspend_failover_targets(ha);
+
+	/*
+	 * Process all the commands in the failover queue. Attempt to failover
+	 * then either complete the command as is or requeue for retry.
+	 */
+	for (i = 0; i < count ; i++) {
+		sp = qla4xxx_failover_next_request(ha);
+		if (sp == NULL)
+			break;
+		qla4xxx_extend_timeout(sp->cmd, 360);
+		if (i == 0) {
+			vis_ha = (scsi_qla_host_t *)sp->cmd->device->host->hostdata;
+		}
+		tq = sp->tgt_queue;
+		lq = sp->lun_queue;
+		fcport = lq->fclun->fcport;
+		DEBUG3(printk("%s(): pid %ld retrycnt=%d,"
+			      "fcport =%p, state=0x%x, \nloop state=0x%x"
+			      " fclun=%p, lq fclun=%p, lq=%p, lun=%d\n",
+			      __func__,
+			      sp->cmd->serial_number,
+			      sp->cmd->retries,
+			      fcport,
+			      atomic_read(&fcport->state),
+			      atomic_read(&ha->loop_state),
+			      sp->fclun, lq->fclun, lq, lq->fclun->lun);)
+		if (sp->err_id == SRB_ERR_DEVICE &&
+		    sp->fclun == lq->fclun &&
+		    atomic_read(&fcport->state) == FCS_ONLINE) {
+			if (!(qla4xxx_test_active_lun(fcport, sp->fclun))) {
+				DEBUG3(printk("scsi%d: %s: Detected INACTIVE Port 0x%02x \n",
+					      ha->host_no,__func__,fcport->loop_id);)
+				sp->err_id = SRB_ERR_OTHER;
+				sp->cmd->sense_buffer[2] = 0;
+				sp->cmd->result = DID_BUS_BUSY << 16;
+			}
+		}
+		if ((sp->flags & SRB_GOT_SENSE )) {
+			sp->flags &= ~SRB_GOT_SENSE;
+			sp->cmd->sense_buffer[0] = 0;
+			sp->cmd->result = DID_BUS_BUSY << 16;
+			sp->cmd->host_scribble = (unsigned char *) NULL;
+		}
+		/*** Select an alternate path ***/
+		/*
+		 * If the path has already been change by a previous request
+		 * sp->fclun != lq->fclun
+		 */
+		if (sp->fclun != lq->fclun ||
+		    ( sp->err_id != SRB_ERR_OTHER &&
+#if 0
+		      atomic_read(&fcport->ha->loop_state)
+		      != LOOP_DEAD &&
+#endif
+		      atomic_read(&fcport->state) != FCS_DEVICE_DEAD)) {
+
+			qla4xxx_failover_cleanup(sp);
+		}
+		else if (qla4xxx_cfg_failover(ha, lq->fclun,
+					      tq, sp) == NULL) {
+			/*
+			 * We ran out of paths, so just retry the status which
+			 * is already set in the cmd. We want to serialize the
+			 * failovers, so we make them go thur visible HBA.
+			 */
+			printk(KERN_INFO
+			       "%s(): Ran out of paths - pid %ld - retrying\n",
+			       __func__,
+			       sp->cmd->serial_number);
+		}
+		else {
+			qla4xxx_failover_cleanup(sp);
+
+		}
+		add_to_done_queue(ha, sp);
+	}
+
+	qla4xxx_resume_failover_targets(vis_ha);
+
+	qla4xxx_restart_queues(ha, 0);
+
+	DEBUG2(printk("%s() - done\n", __func__);)
+}
+#endif
+
+/*
+ *  qla4xxx_process_failover
+ *	Process any command on the failover queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Interrupt context.
+ */
+static void
+qla4xxx_process_failover(scsi_qla_host_t *ha) 
+{
+
+	os_tgt_t	*tq;
+	os_lun_t	*lq;
+	srb_t       *sp;
+	fc_port_t *fcport;
+	scsi_qla_host_t *vis_ha = ha;
+	int count, i;
+
+	DEBUG2(printk(KERN_INFO "scsi%d: %s: active=%d, retry=%d, "
+		      "done=%d, failover=%d commands.\n",
+		      ha->host_no,
+		      __func__,
+		      ha->active_srb_count,
+		      ha->retry_srb_q_count,
+		      ha->done_srb_q_count,
+		      ha->failover_cnt);)
+
+	/* Prevent acceptance of new I/O requests for failover target. */
+	count = qla4xxx_suspend_failover_targets(ha);
+
+	/*
+	 * Process all the commands in the failover queue. Attempt to failover
+	 * then either complete the command as is or requeue for retry.
+	 */
+	for (i = 0; i < count ; i++) {
+		sp = qla4xxx_failover_next_request(ha);
+		if (!sp)
+			break;
+
+		qla4xxx_extend_timeout(sp->cmd, 360);
+		if (i == 0)
+			vis_ha =
+			    (scsi_qla_host_t *)sp->cmd->device->host->hostdata;
+
+		tq = sp->tgt_queue;
+		lq = sp->lun_queue;
+		fcport = lq->fclun->fcport;
+
+		DEBUG2(printk("%s(): pid %ld retrycnt=%d, fcport =%p, "
+		    "state=0x%x, \nha flags=0x%lx fclun=%p, lq fclun=%p, "
+		    "lq=%p, lun=%d\n", __func__, sp->cmd->serial_number,
+		    sp->cmd->retries, fcport, atomic_read(&fcport->state),
+		    ha->flags, sp->fclun, lq->fclun, lq,
+		    lq->fclun->lun));
+		if (sp->err_id == SRB_ERR_DEVICE && sp->fclun == lq->fclun &&
+		    atomic_read(&fcport->state) == FCS_ONLINE) {
+			if (!(qla4xxx_test_active_lun(fcport, sp->fclun))) { 
+				DEBUG2(printk("scsi(%d) %s Detected INACTIVE "
+				    "Port 0x%02x \n", ha->host_no, __func__,
+				    fcport->loop_id));
+				sp->err_id = SRB_ERR_OTHER;
+				sp->cmd->sense_buffer[2] = 0;
+				sp->cmd->result = DID_BUS_BUSY << 16;
+			}	
+		}
+		if ((sp->flags & SRB_GOT_SENSE)) {
+		 	 sp->flags &= ~SRB_GOT_SENSE;
+		 	 sp->cmd->sense_buffer[0] = 0;
+		 	 sp->cmd->result = DID_BUS_BUSY << 16;
+		 	 sp->cmd->host_scribble = (unsigned char *) NULL;
+		}
+
+		/*** Select an alternate path ***/
+		/* 
+		 * If the path has already been change by a previous request
+		 * sp->fclun != lq->fclun
+		 */
+		if (sp->fclun != lq->fclun || (sp->err_id != SRB_ERR_OTHER &&
+		    atomic_read(&fcport->state) != FCS_DEVICE_DEAD)) {
+			qla4xxx_failover_cleanup(sp);
+		} else if (qla4xxx_cfg_failover(ha,
+		    lq->fclun, tq, sp) == NULL) {
+			/*
+			 * We ran out of paths, so just retry the status which
+			 * is already set in the cmd. We want to serialize the 
+			 * failovers, so we make them go thur visible HBA.
+			 */
+			printk(KERN_INFO
+			    "%s(): Ran out of paths - pid %ld - retrying\n",
+			    __func__, sp->cmd->serial_number);
+		} else {
+			qla4xxx_failover_cleanup(sp);
+
+		}
+		add_to_done_srb_q(ha, sp);
+	}
+
+	qla4xxx_resume_failover_targets(vis_ha);
+#if 0
+	for (t = 0; t < vis_ha->max_targets; t++) {
+		if ((tq = vis_ha->otgt[t]) == NULL)
+			continue;
+		if (test_and_clear_bit(TQF_SUSPENDED, &tq->flags)) {
+			/* EMPTY */
+			DEBUG2(printk("%s(): remove suspend for target %d\n",
+			    __func__, t));
+		}
+		for (l = 0; l < vis_ha->max_luns; l++) {
+			if ((lq = (os_lun_t *) tq->olun[l]) == NULL)
+				continue;
+
+			if( test_and_clear_bit(LUN_MPIO_BUSY, &lq->q_flag) ) {
+				/* EMPTY */
+				DEBUG(printk("%s(): remove suspend for "
+				    "lun %d\n", __func__, lq->fclun->lun));
+			}
+		}
+	}
+#endif
+	// qla4xxx_restart_queues(ha, 0);
+
+	DEBUG2(printk("%s() - done", __func__));
+}
+
+int
+qla4xxx_search_failover_queue(scsi_qla_host_t *ha, struct scsi_cmnd *cmd)
+{
+	struct list_head *list, *temp;
+	unsigned long flags;
+	srb_t *sp;
+
+	DEBUG3(printk("qla4xxx_eh_abort: searching sp %p in "
+				"failover queue.\n", sp);)
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	list_for_each_safe(list, temp, &ha->failover_queue) {
+		sp = list_entry(list, srb_t, list_entry);
+
+		if (cmd == sp->cmd)
+			goto found;
+
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	return 0;
+
+ found:
+	/* Remove srb from failover queue. */
+	__del_from_failover_queue(ha, sp);
+	cmd->result = DID_ABORT << 16;
+	__add_to_done_srb_q(ha, sp);
+
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+	return 1;
+}
+
+/*
+ * If we are not processing a ioctl or one of
+ * the ports are still MISSING or need a resync
+ * then process the failover event.
+ */  
+void
+qla4xxx_process_failover_event(scsi_qla_host_t *ha)
+{
+	if (test_bit(CFG_ACTIVE, &ha->cfg_flags))
+		return;
+	if (qla4xxx_check_for_devices_online(ha)) {
+		if (test_and_clear_bit(DPC_FAILOVER_EVENT, &ha->dpc_flags)) {
+			// if (ha->flags.online)
+		    	if (ADAPTER_UP(ha)) 
+				qla4xxx_cfg_event_notify(ha, ha->failover_type);
+		}
+	}
+
+	/*
+	 * Get any requests from failover queue
+	 */
+	if (test_and_clear_bit(DPC_FAILOVER_NEEDED, &ha->dpc_flags))
+		qla4xxx_process_failover(ha);
+}
+
+int
+qla4xxx_do_fo_check(scsi_qla_host_t *ha, srb_t *sp, scsi_qla_host_t *vis_ha)
+{
+	/*
+	 * This routine checks for DID_NO_CONNECT to decide
+	 * whether to failover to another path or not. We only
+	 * failover on that status.
+	 */
+	if (sp->lun_queue->fclun->fcport->flags & FCF_FAILOVER_DISABLE)
+		return 0;
+
+	if (sp->lun_queue->fclun->flags & FLF_VISIBLE_LUN)
+		return 0;
+
+	if (!qla4xxx_fo_check(ha, sp))
+		return 0;
+
+	if ((sp->state != SRB_FAILOVER_STATE)) {
+		/*
+		 * Retry the command on this path
+		 * several times before selecting a new
+		 * path.
+		 */
+		add_to_pending_srb_q_head(vis_ha, sp);
+		qla4xxx_start_io(vis_ha);
+	} else
+		qla4xxx_extend_timeout(sp->cmd, EXTEND_CMD_TIMEOUT);
+
+	return 1;
+}
+
+void
+qla4xxx_start_all_adapters(scsi_qla_host_t *ha)
+{
+	struct list_head *hal;
+	scsi_qla_host_t *vis_ha;
+
+	/* Try and start all visible adapters */
+	read_lock(&qla4xxx_hostlist_lock);
+	list_for_each(hal, &qla4xxx_hostlist) {
+		vis_ha = list_entry(hal, scsi_qla_host_t, list);
+
+		if (!list_empty(&vis_ha->pending_srb_q))
+			qla4xxx_start_io(vis_ha);
+
+		DEBUG2(printk("host(%d):Commands busy=%d "
+				"failed=%d\neh_active=%d\n ",
+				vis_ha->host_no,
+				vis_ha->host->host_busy,
+				vis_ha->host->host_failed,
+				vis_ha->host->eh_active);)	
+	}
+	read_unlock(&qla4xxx_hostlist_lock);
+}
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_foln.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_foln.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_foln.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_foln.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,236 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2003-2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+#ifndef __QLA_FOLN_H
+#define	__QLA_FOLN_H
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+
+// #include "exioct.h"
+#include "ql4_fo.h"
+#include "ql4_cfg.h"
+#include "ql4_fw.h"
+
+/*
+ * Inquiry command structure.
+ */
+#define	INQ_DATA_SIZE	36
+
+typedef struct {
+	union {
+		COMMAND_T3_ENTRY cmd;
+		STATUS_ENTRY rsp;
+	} p;
+	uint8_t inq[INQ_DATA_SIZE];
+} inq_cmd_rsp_t;
+
+/*
+ * Report LUN command structure.
+ */
+#define RPT_LUN_SCSI_OPCODE	0xA0
+#define CHAR_TO_SHORT(a, b)	(uint16_t)((uint8_t)b << 8 | (uint8_t)a)
+
+typedef struct {
+	uint32_t	len;
+	uint32_t	rsrv;
+} rpt_hdr_t;
+
+typedef struct {
+	struct {
+		uint8_t		b : 6;
+		uint8_t		address_method : 2;
+	} msb;
+	uint8_t		lsb;
+	uint8_t		unused[6];
+} rpt_lun_t;
+
+typedef struct {
+	rpt_hdr_t	hdr;
+	rpt_lun_t	lst[MAX_LUNS];
+} rpt_lun_lst_t;
+
+typedef struct {
+	union {
+		COMMAND_T3_ENTRY cmd;
+		STATUS_ENTRY rsp;
+	} p;
+	rpt_lun_lst_t list;
+} rpt_lun_cmd_rsp_t;
+
+
+/* 
+ * Device configuration table
+ *
+ * This table provides a library of information about the device
+ */
+struct cfg_device_info {
+	const char *vendor;
+	const char *model;
+	const int  flags;	/* bit 0 (0x1) -- translate the real 
+				   WWNN to the common WWNN for the target AND
+				   XP_DEVICE */
+				/* bit 1 (0x2) -- MSA 1000  */
+				/* bit 2 (0x4) -- EVA  */
+				/* bit 3 (0x8) -- DISABLE FAILOVER  */
+	const int  notify_type;	/* support the different types: 1 - 4 */
+	int	( *fo_combine)(void *,
+		 uint16_t, fc_port_t *, uint16_t );
+	int	( *fo_detect)(void);
+	int	( *fo_notify)(void);
+	int	( *fo_select)(void);
+};
+
+
+typedef struct {
+	union {
+		COMMAND_T3_ENTRY cmd;
+		STATUS_ENTRY rsp;
+	} p;
+	uint8_t inq[VITAL_PRODUCT_DATA_SIZE];
+} evpd_inq_cmd_rsp_t;
+
+typedef struct {
+	union {
+		COMMAND_T3_ENTRY cmd;
+		STATUS_ENTRY rsp;
+	} p;
+} tur_cmd_rsp_t;
+
+
+#define SDM_DEF_MAX_DEVICES		16
+#define SDM_DEF_MAX_PATHS_PER_TARGET	4
+#define SDM_DEF_MAX_TARGETS_PER_DEVICE	4
+#define SDM_DEF_MAX_PATHS_PER_DEVICE (SDM_DEF_MAX_PATHS_PER_TARGET * SDM_DEF_MAX_TARGETS_PER_DEVICE)
+
+#define FO_MAX_LUNS_PER_DEVICE	MAX_LUNS_OS
+#define FO_MAX_PATHS (SDM_DEF_MAX_PATHS_PER_DEVICE * SDM_DEF_MAX_DEVICES)
+#define FO_MAX_ADAPTERS		32
+#define FO_ADAPTER_ALL		0xFF
+#define FO_DEF_WWN_SIZE             8
+#define FO_MAX_GEN_INFO_STRING_LEN  32
+
+/*
+ * Global Data in qla_fo.c source file.
+ */
+
+/*
+ * Global Function Prototypes in qla_fo.c source file.
+ */
+extern scsi_qla_host_t *qla4xxx_get_hba(unsigned long);
+extern uint32_t qla4xxx_send_fo_notification(fc_lun_t *fclun_p, fc_lun_t *olun_p);
+extern void qla4xxx_fo_init_params(scsi_qla_host_t *ha);
+extern uint8_t qla4xxx_fo_enabled(scsi_qla_host_t *ha, int instance);
+//extern int qla4xxx_fo_ioctl(scsi_qla_host_t *, int, EXT_IOCTL *, int);
+
+/*
+ * Global Data in qla_cfg.c source file.
+ */
+extern mp_host_t *mp_hosts_base;
+extern int mp_config_required;
+
+/*
+ * Global Function Prototypes in qla_cfg.c source file.
+ */
+
+extern mp_host_t *qla4xxx_cfg_find_host(scsi_qla_host_t *);
+extern int qla4xxx_is_iscsiname_in_device(mp_device_t *, uint8_t *);
+extern int qla4xxx_cfg_path_discovery(scsi_qla_host_t *);
+extern int qla4xxx_cfg_event_notify(scsi_qla_host_t *, uint32_t);
+extern fc_lun_t *qla4xxx_cfg_failover(scsi_qla_host_t *, fc_lun_t *,
+    os_tgt_t *, srb_t *);
+extern void qla4xxx_fo_properties(scsi_qla_host_t *);
+extern mp_host_t *qla4xxx_add_mp_host(uint8_t *);
+extern mp_host_t *qla4xxx_alloc_host(scsi_qla_host_t *);
+extern uint8_t qla4xxx_fo_check(scsi_qla_host_t *ha, srb_t *);
+extern mp_path_t *qla4xxx_find_path_by_name(mp_host_t *, mp_path_list_t *,
+    uint8_t *);
+
+extern int __qla4xxx_is_fcport_in_config(scsi_qla_host_t *, fc_port_t *);
+extern int qla4xxx_cfg_init(scsi_qla_host_t *);
+extern void qla4xxx_cfg_mem_free(scsi_qla_host_t *);
+
+extern int qla4xxx_cfg_remap(scsi_qla_host_t *);
+extern void qla4xxx_set_device_flags(scsi_qla_host_t *, fc_port_t *);
+
+extern int16_t qla4xxx_cfg_lookup_device(unsigned char *);
+extern int qla4xxx_combine_by_lunid(void *, uint16_t, fc_port_t *, uint16_t); 
+extern int qla4xxx_export_target(void *, uint16_t, fc_port_t *, uint16_t); 
+
+extern int qla4xxx_test_active_lun(fc_port_t *, fc_lun_t *);
+extern int qla4xxx_test_active_port(fc_port_t *);
+
+extern int qla4xxx_is_fcport_in_foconfig(scsi_qla_host_t *, fc_port_t *);
+
+/*
+ * Global Function Prototypes in qla_cfgln.c source file.
+ */
+extern void qla4xxx_cfg_build_path_tree( scsi_qla_host_t *ha);
+extern uint8_t qla4xxx_update_mp_device(mp_host_t *,
+    fc_port_t  *, uint16_t, uint16_t);
+extern void qla4xxx_cfg_display_devices(int);
+
+
+/*
+ * Global Function Prototypes in qla_foln.c source file.
+ */
+extern int qla4xxx_search_failover_queue(scsi_qla_host_t *, struct scsi_cmnd *);
+extern void qla4xxx_process_failover_event(scsi_qla_host_t *);
+extern int qla4xxx_do_fo_check(scsi_qla_host_t *, srb_t *, scsi_qla_host_t *);
+extern void qla4xxx_start_all_adapters(scsi_qla_host_t *);
+
+extern int ql4xfailover;
+extern int ql4xrecoveryTime;
+extern int ql4xfailbackTime;
+
+extern int MaxPathsPerDevice;
+extern int MaxRetriesPerPath;
+extern int MaxRetriesPerIo;
+extern int qlFailoverNotifyType;
+
+extern struct cfg_device_info cfg_device_list[];
+
+#define qla4xxx_failover_enabled(ha)				(ql4xfailover)
+
+#else
+
+#define qla4xxx_is_fcport_in_foconfig(ha, fcport)		(0)
+#define qla4xxx_fo_missing_port_summary(ha, e, s, m, c, r)	(0)
+/* qla4xxx_cfg_init() is declared int but the retval isn't checked.. */
+#define qla4xxx_cfg_init(ha)					do { } while (0)
+#define qla4xxx_cfg_mem_free(ha)				do { } while (0)
+#define qla4xxx_cfg_display_devices()				do { } while (0)
+#define qla4xxx_process_failover_event(ha)			do { } while (0)
+#define qla4xxx_start_all_adapters(ha)				do { } while (0)
+#define qla4xxx_search_failover_queue(ha, cmd)			(0)
+#define qla4xxx_do_fo_check(ha, sp, vis_ha)			(0)
+#define qla4xxx_failover_enabled(ha)				(0)
+#endif /* CONFIG_SCSI_QLA2XXX_FAILOVER */
+
+static __inline int
+qla4xxx_is_fcport_in_config(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	if (qla4xxx_failover_enabled(ha))
+		return qla4xxx_is_fcport_in_foconfig(ha, fcport);
+	else if (fcport->flags & FCF_PERSISTENT_BOUND)
+		return 1;
+	return 0;
+}
+
+
+#endif /* __QLA_FOLN_H */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_fw.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_fw.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_fw.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_fw.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,1566 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+/*
+ * This file defines mailbox structures and definitions for the QLA4xxx
+ *  iSCSI HBA firmware.
+ */
+
+#ifndef _QLA4X_FW_H
+#define _QLA4X_FW_H
+
+#ifndef INT8
+#define INT8 __s8
+#endif
+#ifndef INT16
+#define INT16 __s16
+#endif
+#ifndef INT32
+#define INT32 __s32
+#endif
+#ifndef UINT8
+#define UINT8 __u8
+#endif
+#ifndef UINT16
+#define UINT16 __u16
+#endif
+#ifndef UINT32
+#define UINT32 __u32
+#endif
+#ifndef UINT64
+#define UINT64 __u64
+#endif
+
+
+#define QLA4XXX_VENDOR_ID   	0x1077
+#define QLA4000_DEVICE_ID  	0x4000
+#define QLA4010_DEVICE_ID  	0x4010
+
+#define QLA4040_SSDID_NIC  	0x011D	/* Uses QLA4010 PCI Device ID */
+#define QLA4040_SSDID_ISCSI  	0x011E
+#define QLA4040C_SSDID_NIC  	0x011F
+#define QLA4040C_SSDID_ISCSI  	0x0120
+
+#define MAX_PRST_DEV_DB_ENTRIES         64
+#define MIN_DISC_DEV_DB_ENTRY           MAX_PRST_DEV_DB_ENTRIES
+#define MAX_DEV_DB_ENTRIES              512
+#define MAX_ISNS_DISCOVERED_TARGETS     MAX_DEV_DB_ENTRIES
+
+// ISP Maximum number of DSD per command
+#define DSD_MAX                                 1024
+
+// FW check
+#define FW_UP(reg,stat)                         (((stat = RD_REG_DWORD(reg->mailbox[0])) != 0) && (stat != 0x0007))
+
+#define INVALID_REGISTER 			((UINT32)-1)
+
+#define ISP4010_NET_FUNCTION                            0
+#define ISP4010_ISCSI_FUNCTION                          1
+
+
+/*************************************************************************
+ *
+ * 		ISP 4010 I/O Register Set Structure and Definitions
+ *
+ *************************************************************************/
+
+typedef struct _PORT_CTRL_STAT_REGS {
+	UINT32  ext_hw_conf;      	// 80 x50  R/W
+	UINT32  intChipConfiguration;	       // 84 x54   *
+	UINT32  port_ctrl;		       // 88 x58   *
+	UINT32  port_status;		       // 92 x5c   *
+	UINT32  HostPrimMACHi;		       // 96 x60   *
+	UINT32  HostPrimMACLow;		       //100 x64   *
+	UINT32  HostSecMACHi;		       //104 x68   *
+	UINT32  HostSecMACLow;		       //108 x6c   *
+	UINT32  EPPrimMACHi;		       //112 x70   *
+	UINT32  EPPrimMACLow;		       //116 x74   *
+	UINT32  EPSecMACHi;		       //120 x78   *
+	UINT32  EPSecMACLow;		       //124 x7c   *
+	UINT32  HostPrimIPHi;		       //128 x80   *
+	UINT32  HostPrimIPMidHi;	       //132 x84   *
+	UINT32  HostPrimIPMidLow;	       //136 x88   *
+	UINT32  HostPrimIPLow;		       //140 x8c   *
+	UINT32  HostSecIPHi;		       //144 x90   *
+	UINT32  HostSecIPMidHi;		       //148 x94   *
+	UINT32  HostSecIPMidLow;	       //152 x98   *
+	UINT32  HostSecIPLow;		       //156 x9c   *
+	UINT32  EPPrimIPHi;		       //160 xa0   *
+	UINT32  EPPrimIPMidHi;		       //164 xa4   *
+	UINT32  EPPrimIPMidLow;		       //168 xa8   *
+	UINT32  EPPrimIPLow;		       //172 xac   *
+	UINT32  EPSecIPHi;		       //176 xb0   *
+	UINT32  EPSecIPMidHi;		       //180 xb4   *
+	UINT32  EPSecIPMidLow;		       //184 xb8   *
+	UINT32  EPSecIPLow;		       //188 xbc   *
+	UINT32  IPReassemblyTimeout;	       //192 xc0   *
+	UINT32  EthMaxFramePayload;	       //196 xc4   *
+	UINT32  TCPMaxWindowSize;	       //200 xc8   *
+	UINT32  TCPCurrentTimestampHi;	       //204 xcc   *
+	UINT32  TCPCurrentTimestampLow;	       //208 xd0   *
+	UINT32  LocalRAMAddress;	       //212 xd4   *
+	UINT32  LocalRAMData;		       //216 xd8   *
+	UINT32  PCSReserved1;		       //220 xdc   *
+	UINT32  gp_out;	       //224 xe0   *
+	UINT32  gp_in;	       //228 xe4   *
+	UINT32  ProbeMuxAddr;		       //232 xe8   *
+	UINT32  ProbeMuxData;		       //236 xec   *
+	UINT32  ERMQueueBaseAddr0;	       //240 xf0   *
+	UINT32  ERMQueueBaseAddr1;	       //244 xf4   *
+	UINT32  MACConfiguration;	       //248 xf8   *
+	UINT32  port_err_status;	       //252 xfc  COR
+} PORT_CTRL_STAT_REGS, *PPORT_CTRL_STAT_REGS;
+
+typedef struct _HOST_MEM_CFG_REGS {
+	UINT32  NetRequestQueueOut;	       // 80 x50   *
+	UINT32  NetRequestQueueOutAddrHi;      // 84 x54   *
+	UINT32  NetRequestQueueOutAddrLow;     // 88 x58   *
+	UINT32  NetRequestQueueBaseAddrHi;     // 92 x5c   *
+	UINT32  NetRequestQueueBaseAddrLow;    // 96 x60   *
+	UINT32  NetRequestQueueLength;	       //100 x64   *
+	UINT32  NetResponseQueueIn;	       //104 x68   *
+	UINT32  NetResponseQueueInAddrHi;      //108 x6c   *
+	UINT32  NetResponseQueueInAddrLow;     //112 x70   *
+	UINT32  NetResponseQueueBaseAddrHi;    //116 x74   *
+	UINT32  NetResponseQueueBaseAddrLow;   //120 x78   *
+	UINT32  NetResponseQueueLength;	       //124 x7c   *
+	UINT32  req_q_out;	       	       //128 x80   *
+	UINT32  RequestQueueOutAddrHi;	       //132 x84   *
+	UINT32  RequestQueueOutAddrLow;	       //136 x88   *
+	UINT32  RequestQueueBaseAddrHi;	       //140 x8c   *
+	UINT32  RequestQueueBaseAddrLow;       //144 x90   *
+	UINT32  RequestQueueLength;	       //148 x94   *
+	UINT32  ResponseQueueIn;	       //152 x98   *
+	UINT32  ResponseQueueInAddrHi;	       //156 x9c   *
+	UINT32  ResponseQueueInAddrLow;	       //160 xa0   *
+	UINT32  ResponseQueueBaseAddrHi;       //164 xa4   *
+	UINT32  ResponseQueueBaseAddrLow;      //168 xa8   *
+	UINT32  ResponseQueueLength;	       //172 xac   *
+	UINT32  NetRxLargeBufferQueueOut;      //176 xb0   *
+	UINT32  NetRxLargeBufferQueueBaseAddrHi;   //180 xb4   *
+	UINT32  NetRxLargeBufferQueueBaseAddrLow;  //184 xb8   *
+	UINT32  NetRxLargeBufferQueueLength;   //188 xbc   *
+	UINT32  NetRxLargeBufferLength;	       //192 xc0   *
+	UINT32  NetRxSmallBufferQueueOut;      //196 xc4   *
+	UINT32  NetRxSmallBufferQueueBaseAddrHi;   //200 xc8   *
+	UINT32  NetRxSmallBufferQueueBaseAddrLow;  //204 xcc   *
+	UINT32  NetRxSmallBufferQueueLength;   //208 xd0   *
+	UINT32  NetRxSmallBufferLength;	       //212 xd4   *
+	UINT32  HMCReserved0[10];	       //216 xd8   *
+} HOST_MEM_CFG_REGS, *PHOST_MEM_CFG_REGS;
+
+typedef struct _LOCAL_RAM_CFG_REGS {
+	UINT32  BufletSize;		       // 80 x50   *
+	UINT32  BufletMaxCount;		       // 84 x54   *
+	UINT32  BufletCurrCount;	       // 88 x58   *
+	UINT32  BufletPauseThresholdCount;     // 92 x5c   *
+	UINT32  BufletTCPWinThresholdHi;       // 96 x60   *
+	UINT32  BufletTCPWinThresholdLow;      //100 x64   *
+	UINT32  IPHashTableBaseAddr;	       //104 x68   *
+	UINT32  IPHashTableSize;	       //108 x6c   *
+	UINT32  TCPHashTableBaseAddr;	       //112 x70   *
+	UINT32  TCPHashTableSize;	       //116 x74   *
+	UINT32  NCBAreaBaseAddr;	       //120 x78   *
+	UINT32  NCBMaxCount;		       //124 x7c   *
+	UINT32  NCBCurrCount;		       //128 x80   *
+	UINT32  DRBAreaBaseAddr;	       //132 x84   *
+	UINT32  DRBMaxCount;		       //136 x88   *
+	UINT32  DRBCurrCount;		       //140 x8c   *
+	UINT32  LRCReserved[28];	       //144 x90   *
+} LOCAL_RAM_CFG_REGS, *PLOCAL_RAM_CFG_REGS;
+
+typedef struct _PROT_STAT_REGS {
+	UINT32  MACTxFrameCount;	       // 80 x50   R
+	UINT32  MACTxByteCount;		       // 84 x54   R
+	UINT32  MACRxFrameCount;	       // 88 x58   R
+	UINT32  MACRxByteCount;		       // 92 x5c   R
+	UINT32  MACCRCErrCount;		       // 96 x60   R
+	UINT32  MACEncErrCount;		       //100 x64   R
+	UINT32  MACRxLengthErrCount;	       //104 x68   R
+	UINT32  IPTxPacketCount;	       //108 x6c   R
+	UINT32  IPTxByteCount;		       //112 x70   R
+	UINT32  IPTxFragmentCount;	       //116 x74   R
+	UINT32  IPRxPacketCount;	       //120 x78   R
+	UINT32  IPRxByteCount;		       //124 x7c   R
+	UINT32  IPRxFragmentCount;	       //128 x80   R
+	UINT32  IPDatagramReassemblyCount;     //132 x84   R
+	UINT32  IPV6RxPacketCount;	       //136 x88   R
+	UINT32  IPErrPacketCount;	       //140 x8c   R
+	UINT32  IPReassemblyErrCount;	       //144 x90   R
+	UINT32  TCPTxSegmentCount;	       //148 x94   R
+	UINT32  TCPTxByteCount;		       //152 x98   R
+	UINT32  TCPRxSegmentCount;	       //156 x9c   R
+	UINT32  TCPRxByteCount;		       //160 xa0   R
+	UINT32  TCPTimerExpCount;	       //164 xa4   R
+	UINT32  TCPRxAckCount;		       //168 xa8   R
+	UINT32  TCPTxAckCount;		       //172 xac   R
+	UINT32  TCPRxErrOOOCount;	       //176 xb0   R
+	UINT32  PSReserved0;		       //180 xb4   *
+	UINT32  TCPRxWindowProbeUpdateCount;   //184 xb8   R
+	UINT32  ECCErrCorrectionCount;	       //188 xbc   R
+	UINT32  PSReserved1[16];	       //192 xc0   *
+} PROT_STAT_REGS, *PPROT_STAT_REGS;
+
+#define MBOX_REG_COUNT                          8
+
+// remote register set (access via PCI memory read/write)
+typedef struct isp_reg_t {
+	uint32_t mailbox[MBOX_REG_COUNT];
+
+	uint32_t flash_address;				/* 0x20 */
+	uint32_t flash_data;
+	uint32_t ctrl_status;
+
+	union {
+		struct {
+			uint32_t nvram;
+			uint32_t reserved1[2];		/* 0x30 */
+		} __attribute__((packed)) isp4010;
+		struct {
+			uint32_t intr_mask;
+			uint32_t nvram;			/* 0x30 */
+			uint32_t semaphore;
+		} __attribute__((packed)) isp4022;
+	} u1;
+
+	
+	uint32_t req_q_in;  /* SCSI Request Queue Producer Index */
+	uint32_t rsp_q_out; /* SCSI Completion Queue Consumer Index */
+
+	uint32_t reserved2[4];				/* 0x40 */
+
+	union {
+		struct {
+			uint32_t ext_hw_conf;		/* 0x50 */
+			uint32_t flow_ctrl;
+			uint32_t port_ctrl;
+			uint32_t port_status;
+
+			uint32_t reserved3[8];		/* 0x60 */
+
+			uint32_t req_q_out;		/* 0x80 */
+
+			uint32_t reserved4[23];		/* 0x84 */
+
+			uint32_t gp_out;		/* 0xe0 */
+			uint32_t gp_in;
+
+			uint32_t reserved5[5];
+
+			uint32_t port_err_status;	/* 0xfc */
+		} __attribute__((packed)) isp4010;
+		struct {
+			union {
+				PORT_CTRL_STAT_REGS p0;
+				HOST_MEM_CFG_REGS   p1;
+				LOCAL_RAM_CFG_REGS  p2;
+				PROT_STAT_REGS	    p3;
+				uint32_t  r_union[44];
+			};
+
+		} __attribute__((packed)) isp4022;
+	} u2;
+} isp_reg_t;			//256 x100
+
+#define ISP_NVRAM(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u1.isp4022.nvram : \
+	 &ha->reg->u1.isp4010.nvram)
+
+#define ISP_EXT_HW_CONF(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.ext_hw_conf : \
+	 &ha->reg->u2.isp4010.ext_hw_conf)
+
+#define ISP_PORT_STATUS(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.port_status : \
+	 &ha->reg->u2.isp4010.port_status)
+
+#define ISP_REQ_Q_OUT(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p1.req_q_out : \
+	 &ha->reg->u2.isp4010.req_q_out)
+
+#define ISP_PORT_ERROR_STATUS(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.port_err_status : \
+	 &ha->reg->u2.isp4010.port_err_status)
+
+#define ISP_GP_OUT(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.gp_out : \
+	 &ha->reg->u2.isp4010.gp_out)
+
+#define ISP_GP_IN(ha) \
+	(IS_QLA4022(ha) ? \
+	 &ha->reg->u2.isp4022.p0.gp_in : \
+	 &ha->reg->u2.isp4010.gp_in)
+
+/* Page # defines for 4022 */
+#define PORT_CTRL_STAT_PAGE                     0 /* 4022 */
+#define HOST_MEM_CFG_PAGE                       1 /* 4022 */
+#define LOCAL_RAM_CFG_PAGE                      2 /* 4022 */
+#define PROT_STAT_PAGE                          3 /* 4022 */
+
+/* Register Mask - sets corresponding mask bits in the upper word */
+#define SET_RMASK(val)	((val & 0xffff) | (val << 16))
+#define CLR_RMASK(val)	(0 | (val << 16))
+
+// ctrl_status definitions
+#define CSR_SCSI_PAGE_SELECT                    0x00000003
+#define CSR_SCSI_INTR_ENABLE                    0x00000004 /* 4010 */
+#define CSR_SCSI_RESET_INTR                     0x00000008
+#define CSR_SCSI_COMPLETION_INTR                0x00000010
+#define CSR_SCSI_PROCESSOR_INTR                 0x00000020
+#define CSR_INTR_RISC                           0x00000040
+#define CSR_BOOT_ENABLE                         0x00000080
+#define CSR_NET_PAGE_SELECT                     0x00000300 /* 4010 */
+#define CSR_NET_INTR_ENABLE                     0x00000400 /* 4010 */
+#define CSR_FUNC_NUM                            0x00000700 /* 4022 */
+#define CSR_PCI_FUNC_NUM_MASK                   0x00000300 /* 4022 */
+#define CSR_NET_RESET_INTR                      0x00000800 /* 4010 */
+#define CSR_NET_COMPLETION_INTR                 0x00001000 /* 4010 */
+#define CSR_FORCE_SOFT_RESET                    0x00002000 /* 4022 */
+#define CSR_FATAL_ERROR                         0x00004000
+#define CSR_SOFT_RESET                          0x00008000
+
+#define INTR_PENDING                            (CSR_SCSI_COMPLETION_INTR | CSR_SCSI_PROCESSOR_INTR | CSR_SCSI_RESET_INTR)
+
+/* ISP InterruptMask definitions */
+#define IMR_SCSI_INTR_ENABLE                    0x00000004  /* 4022 */
+
+// ISP port_ctrl definitions
+#define PCR_CONFIG_COMPLETE			0x00008000  /* 4022 */
+#define PCR_BIOS_BOOTED_FIRMWARE		0x00008000  /* 4010 */
+#define PCR_ENABLE_SERIAL_DATA			0x00001000  /* 4010 */
+#define PCR_SERIAL_DATA_OUT			0x00000800  /* 4010 */
+#define PCR_ENABLE_SERIAL_CLOCK			0x00000400  /* 4010 */
+#define PCR_SERIAL_CLOCK			0x00000200  /* 4010 */
+
+// ISP port_status definitions
+#define PSR_CONFIG_COMPLETE			0x00000001  /* 4010 */
+#define PSR_INIT_COMPLETE			0x00000200
+
+// ISP Semaphore definitions
+#define SR_FIRWMARE_BOOTED			0x00000001
+
+// ISP General Purpose Output definitions
+#define GPOR_TOPCAT_RESET                  	0x00000004
+
+// shadow registers (DMA'd from HA to system memory.  read only)
+typedef struct {
+	/* SCSI Request Queue Consumer Index */
+	UINT32   req_q_out;	// 0 x0   R
+
+	/* SCSI Completion Queue Producer Index */
+	UINT32   rsp_q_in;	// 4 x4   R
+} shadow_regs_t;		// 8 x8
+
+#define EHWC_PROT_METHOD_NONE                         0
+#define EHWC_PROT_METHOD_BYTE_PARITY                  1
+#define EHWC_PROT_METHOD_ECC                          2
+#define EHWC_SDRAM_BANKS_1                            0
+#define EHWC_SDRAM_BANKS_2                            1
+#define EHWC_SDRAM_WIDTH_8_BIT                        0
+#define EHWC_SDRAM_WIDTH_16_BIT                       1
+#define EHWC_SDRAM_CHIP_SIZE_64MB                     0
+#define EHWC_SDRAM_CHIP_SIZE_128MB                    1
+#define EHWC_SDRAM_CHIP_SIZE_256MB                    2
+#define EHWC_MEM_TYPE_SYNC_FLOWTHROUGH                0
+#define EHWC_MEM_TYPE_SYNC_PIPELINE                   1
+#define EHWC_WRITE_BURST_512                          0
+#define EHWC_WRITE_BURST_1024                         1
+#define EHWC_WRITE_BURST_2048                         2
+#define EHWC_WRITE_BURST_4096                         3
+
+// External hardware configuration register
+typedef union _EXTERNAL_HW_CONFIG_REG {
+	struct {
+		UINT32  bReserved0                :1;
+		UINT32  bSDRAMProtectionMethod    :2;
+		UINT32  bSDRAMBanks               :1;
+		UINT32  bSDRAMChipWidth           :1;
+		UINT32  bSDRAMChipSize            :2;
+		UINT32  bParityDisable            :1;
+		UINT32  bExternalMemoryType       :1;
+		UINT32  bFlashBIOSWriteEnable     :1;
+		UINT32  bFlashUpperBankSelect     :1;
+		UINT32  bWriteBurst               :2;
+		UINT32  bReserved1                :3;
+		UINT32  bMask                     :16;
+	};
+	UINT32   AsUINT32;
+} EXTERNAL_HW_CONFIG_REG, *PEXTERNAL_HW_CONFIG_REG;
+
+/*************************************************************************
+ *
+ *		Mailbox Commands Structures and Definitions
+ *
+ *************************************************************************/
+
+// Mailbox command definitions
+#define MBOX_CMD_LOAD_RISC_RAM_EXT              0x0001
+#define MBOX_CMD_EXECUTE_FW                     0x0002
+#define MBOX_CMD_DUMP_RISC_RAM_EXT              0x0003
+#define MBOX_CMD_WRITE_RISC_RAM_EXT             0x0004
+#define MBOX_CMD_READ_RISC_RAM_EXT              0x0005
+#define MBOX_CMD_REGISTER_TEST                  0x0006
+#define MBOX_CMD_VERIFY_CHECKSUM                0x0007
+#define MBOX_CMD_ABOUT_FW                       0x0009
+#define MBOX_CMD_LOOPBACK_DIAG                  0x000A
+#define MBOX_CMD_PING                           0x000B
+#define MBOX_CMD_CHECKSUM_FW                    0x000E
+#define MBOX_CMD_RESET_FW                       0x0014
+#define MBOX_CMD_ABORT_TASK                     0x0015
+#define MBOX_CMD_LUN_RESET                      0x0016
+#define MBOX_CMD_TARGET_WARM_RESET              0x0017
+#define MBOX_CMD_TARGET_COLD_RESET              0x0018
+#define MBOX_CMD_ABORT_QUEUE                    0x001C
+#define MBOX_CMD_GET_QUEUE_STATUS               0x001D
+#define MBOX_CMD_GET_MANAGEMENT_DATA            0x001E
+#define MBOX_CMD_GET_FW_STATUS                  0x001F
+#define MBOX_CMD_SET_ISNS_SERVICE               0x0021
+		#define ISNS_DISABLE                            0
+		#define ISNS_ENABLE                             1
+		#define ISNS_STATUS                             2
+#define MBOX_CMD_COPY_FLASH                     0x0024
+		#define COPY_FLASH_OPTION_PRIM_TO_SEC           0
+		#define COPY_FLASH_OPTION_SEC_TO_PRIM           1
+#define MBOX_CMD_WRITE_FLASH                    0x0025
+		#define WRITE_FLASH_OPTION_HOLD_DATA            0
+		#define WRITE_FLASH_OPTION_COMMIT_DATA          2
+		#define WRITE_FLASH_OPTION_FLASH_DATA    	3
+#define MBOX_CMD_READ_FLASH                     0x0026
+#define MBOX_CMD_GET_QUEUE_PARAMS               0x0029
+#define MBOX_CMD_CLEAR_DATABASE_ENTRY           0x0031
+#define MBOX_CMD_SET_QUEUE_PARAMS               0x0039
+#define MBOX_CMD_CONN_CLOSE_SESS_LOGOUT         0x0056
+		#define LOGOUT_OPTION_CLOSE_SESSION             0x01
+		#define LOGOUT_OPTION_RELOGIN                   0x02
+#define MBOX_CMD_EXECUTE_IOCB_A64		0x005A
+#define MBOX_CMD_INITIALIZE_FIRMWARE            0x0060
+#define MBOX_CMD_GET_INIT_FW_CTRL_BLOCK         0x0061
+#define MBOX_CMD_REQUEST_DATABASE_ENTRY         0x0062
+#define MBOX_CMD_SET_DATABASE_ENTRY             0x0063					
+#define MBOX_CMD_GET_DATABASE_ENTRY             0x0064
+		#define DDB_DS_UNASSIGNED                       0x00
+		#define DDB_DS_NO_CONNECTION_ACTIVE             0x01
+		#define DDB_DS_DISCOVERY                        0x02
+		#define DDB_DS_NO_SESSION_ACTIVE                0x03
+		#define DDB_DS_SESSION_ACTIVE                   0x04
+		#define DDB_DS_LOGGING_OUT                      0x05
+		#define DDB_DS_SESSION_FAILED                   0x06
+		#define DDB_DS_LOGIN_IN_PROCESS                 0x07
+		#define DELETEABLE_DDB_DS(ds) ((ds == DDB_DS_UNASSIGNED) || \
+		                               (ds == DDB_DS_NO_CONNECTION_ACTIVE) || \
+					       (ds == DDB_DS_SESSION_FAILED))
+#define MBOX_CMD_CLEAR_ACA                      0x0065
+#define MBOX_CMD_CLEAR_TASK_SET                 0x0067
+#define MBOX_CMD_ABORT_TASK_SET                 0x0068
+#define MBOX_CMD_GET_FW_STATE                   0x0069
+
+/* Mailbox 1 */
+		#define FW_STATE_READY                          0x0000
+		#define FW_STATE_CONFIG_WAIT                    0x0001
+		#define FW_STATE_WAIT_LOGIN                     0x0002
+		#define FW_STATE_ERROR                          0x0004
+		#define FW_STATE_DHCP_IN_PROGRESS		0x0008
+		#define FW_STATE_ISNS_IN_PROGRESS               0x0010
+		#define FW_STATE_TOPCAT_INIT_IN_PROGRESS       	0x0040
+
+/* Mailbox 3 */
+		#define FW_ADDSTATE_COPPER_MEDIA                0x0000
+		#define FW_ADDSTATE_OPTICAL_MEDIA               0x0001
+		#define	FW_ADDSTATE_DHCP_ENABLED		0x0002
+		#define	FW_ADDSTATE_DHCP_LEASE_ACQUIRED		0x0004
+		#define	FW_ADDSTATE_DHCP_LEASE_EXPIRED		0x0008
+		#define FW_ADDSTATE_LINK_UP                     0x0010
+		#define FW_ADDSTATE_ISNS_SVC_ENABLED            0x0020
+		#define FW_ADDSTATE_TOPCAT_NOT_INITIALIZED     	0x0040
+#define MBOX_CMD_GET_INIT_FW_CTRL_BLOCK_DEFAULTS 0x006A
+#define MBOX_CMD_GET_DATABASE_ENTRY_DEFAULTS    0x006B
+#define MBOX_CMD_CONN_OPEN_SESS_LOGIN           0x0074
+#define MBOX_CMD_DIAGNOSTICS_TEST_RESULTS       0x0075	/* 4010 only */
+		#define DIAG_TEST_LOCAL_RAM_SIZE		0x0002
+		#define DIAG_TEST_LOCAL_RAM_READ_WRITE		0x0003
+		#define DIAG_TEST_RISC_RAM			0x0004
+		#define DIAG_TEST_NVRAM				0x0005
+		#define DIAG_TEST_FLASH_ROM			0x0006
+		#define DIAG_TEST_NW_INT_LOOPBACK		0x0007
+		#define DIAG_TEST_NW_EXT_LOOPBACK		0x0008
+#define MBOX_CMD_GET_CRASH_RECORD       	0x0076	/* 4010 only */
+#define MBOX_CMD_NOP                            0x00FF
+
+// Mailbox status definitions
+#define MBOX_COMPLETION_STATUS			4
+#define MBOX_STS_BUSY                           0x0007
+#define MBOX_STS_INTERMEDIATE_COMPLETION    	0x1000
+#define MBOX_STS_COMMAND_COMPLETE               0x4000
+#define MBOX_STS_INVALID_COMMAND                0x4001
+#define MBOX_STS_HOST_INTERFACE_ERROR           0x4002
+#define MBOX_STS_TEST_FAILED                    0x4003
+#define MBOX_STS_COMMAND_ERROR                  0x4005
+#define MBOX_STS_COMMAND_PARAMETER_ERROR        0x4006
+#define MBOX_STS_TARGET_MODE_INIT_FAIL          0x4007
+#define MBOX_STS_INITIATOR_MODE_INIT_FAIL       0x4008
+
+#define MBOX_ASYNC_EVENT_STATUS			8
+#define MBOX_ASTS_SYSTEM_ERROR                  0x8002
+#define MBOX_ASTS_REQUEST_TRANSFER_ERROR        0x8003
+#define MBOX_ASTS_RESPONSE_TRANSFER_ERROR       0x8004
+#define MBOX_ASTS_PROTOCOL_STATISTIC_ALARM      0x8005
+#define MBOX_ASTS_SCSI_COMMAND_PDU_REJECTED     0x8006
+#define MBOX_ASTS_LINK_UP  			0x8010
+#define MBOX_ASTS_LINK_DOWN			0x8011
+#define MBOX_ASTS_DATABASE_CHANGED              0x8014
+#define MBOX_ASTS_UNSOLICITED_PDU_RECEIVED      0x8015
+#define MBOX_ASTS_SELF_TEST_FAILED      	0x8016
+#define MBOX_ASTS_LOGIN_FAILED      		0x8017
+#define MBOX_ASTS_DNS      			0x8018
+#define MBOX_ASTS_HEARTBEAT      		0x8019
+#define MBOX_ASTS_NVRAM_INVALID      		0x801A
+#define MBOX_ASTS_MAC_ADDRESS_CHANGED      	0x801B
+#define MBOX_ASTS_IP_ADDRESS_CHANGED      	0x801C
+#define MBOX_ASTS_DHCP_LEASE_EXPIRED      	0x801D
+#define MBOX_ASTS_DHCP_LEASE_ACQUIRED           0x801F
+#define MBOX_ASTS_ISNS_UNSOLICITED_PDU_RECEIVED 0x8021
+		#define ISNS_EVENT_DATA_RECEIVED		0x0000
+		#define ISNS_EVENT_CONNECTION_OPENED		0x0001
+		#define ISNS_EVENT_CONNECTION_FAILED		0x0002
+#define MBOX_ASTS_IPSEC_SYSTEM_FATAL_ERROR	0x8022
+
+
+/*************************************************************************/
+
+/* Host Adapter Initialization Control Block (from host) */
+typedef struct _INIT_FW_CTRL_BLK {
+	UINT8   Version;			/* 00 */
+	UINT8   Control;			/* 01 */
+
+	UINT16  FwOptions;			/* 02-03 */
+   #define  FWOPT_HEARTBEAT_ENABLE           0x1000
+   #define  FWOPT_MARKER_DISABLE             0x0400
+   #define  FWOPT_PROTOCOL_STAT_ALARM_ENABLE 0x0200
+   #define  FWOPT_TARGET_ACCEPT_AEN_ENABLE   0x0100
+   #define  FWOPT_ACCESS_CONTROL_ENABLE      0x0080
+   #define  FWOPT_SESSION_MODE               0x0040
+   #define  FWOPT_INITIATOR_MODE             0x0020
+   #define  FWOPT_TARGET_MODE                0x0010
+   #define  FWOPT_FAST_POSTING               0x0008
+   #define  FWOPT_AUTO_TARGET_INFO_DISABLE   0x0004
+   #define  FWOPT_SENSE_BUFFER_DATA_ENABLE   0x0002
+
+	UINT16  ExecThrottle;			/* 04-05 */
+	UINT8   RetryCount;			/* 06 */
+	UINT8   RetryDelay;			/* 07 */
+	UINT16  MaxEthFrPayloadSize;		/* 08-09 */
+	UINT16  AddFwOptions;			/* 0A-0B */
+   #define  ADDFWOPT_AUTOCONNECT_DISABLE     0x0002
+   #define  ADDFWOPT_SUSPEND_ON_FW_ERROR     0x0001
+
+	UINT8   HeartbeatInterval;		/* 0C */
+	UINT8   InstanceNumber;			/* 0D */
+	UINT16  RES2;				/* 0E-0F */
+	UINT16  ReqQConsumerIndex;		/* 10-11 */
+	UINT16  ComplQProducerIndex;		/* 12-13 */
+	UINT16  ReqQLen;			/* 14-15 */
+	UINT16  ComplQLen;			/* 16-17 */
+	UINT32  ReqQAddrLo;			/* 18-1B */
+	UINT32  ReqQAddrHi;			/* 1C-1F */
+	UINT32  ComplQAddrLo;			/* 20-23 */
+	UINT32  ComplQAddrHi;			/* 24-27 */
+	UINT32  ShadowRegBufAddrLo;		/* 28-2B */
+	UINT32  ShadowRegBufAddrHi;		/* 2C-2F */
+
+	UINT16  iSCSIOptions;			/* 30-31 */
+   #define  IOPT_RCV_ISCSI_MARKER_ENABLE     0x8000
+   #define  IOPT_SEND_ISCSI_MARKER_ENABLE    0x4000
+   #define  IOPT_HEADER_DIGEST_ENABLE        0x2000
+   #define  IOPT_DATA_DIGEST_ENABLE          0x1000
+   #define  IOPT_IMMEDIATE_DATA_ENABLE       0x0800
+   #define  IOPT_INITIAL_R2T_ENABLE          0x0400
+   #define  IOPT_DATA_SEQ_IN_ORDER           0x0200
+   #define  IOPT_DATA_PDU_IN_ORDER           0x0100
+   #define  IOPT_CHAP_AUTH_ENABLE            0x0080
+   #define  IOPT_SNACK_REQ_ENABLE            0x0040
+   #define  IOPT_DISCOVERY_LOGOUT_ENABLE     0x0020
+   #define  IOPT_BIDIR_CHAP_ENABLE     	     0x0010
+
+	UINT16  TCPOptions;			/* 32-33 */
+   #define  TOPT_ISNS_ENABLE		     0x4000
+   #define  TOPT_SLP_USE_DA_ENABLE	     0x2000
+   #define  TOPT_AUTO_DISCOVERY_ENABLE       0x1000
+   #define  TOPT_SLP_UA_ENABLE               0x0800
+   #define  TOPT_SLP_SA_ENABLE               0x0400
+   #define  TOPT_DHCP_ENABLE                 0x0200
+   #define  TOPT_GET_DNS_VIA_DHCP_ENABLE     0x0100
+   #define  TOPT_GET_SLP_VIA_DHCP_ENABLE     0x0080
+   #define  TOPT_LEARN_ISNS_IP_ADDR_ENABLE   0x0040
+   #define  TOPT_NAGLE_DISABLE               0x0020
+   #define  TOPT_TIMER_SCALE_MASK            0x000E
+   #define  TOPT_TIME_STAMP_ENABLE           0x0001
+
+	UINT16  IPOptions;			/* 34-35 */
+   #define  IPOPT_FRAG_DISABLE               0x0010
+   #define  IPOPT_PAUSE_FRAME_ENABLE         0x0002
+   #define  IPOPT_IP_ADDRESS_VALID           0x0001
+
+	UINT16  MaxPDUSize;			/* 36-37 */
+	UINT16  RcvMarkerInt;			/* 38-39 */
+	UINT16  SndMarkerInt;			/* 3A-3B */
+	UINT16  InitMarkerlessInt;		/* 3C-3D */ //FIXME: Reserved in spec, but IOCTL struct uses it
+	UINT16  FirstBurstSize;			/* 3E-3F */
+	UINT16  DefaultTime2Wait;		/* 40-41 */
+	UINT16  DefaultTime2Retain;		/* 42-43 */
+	UINT16  MaxOutStndngR2T;		/* 44-45 */
+	UINT16  KeepAliveTimeout;		/* 46-47 */
+	UINT16  PortNumber;			/* 48-49 */
+	UINT16  MaxBurstSize;			/* 4A-4B */
+	UINT32  RES4;				/* 4C-4F */
+	UINT8   IPAddr[4];			/* 50-53 */
+	UINT8   RES5[12];			/* 54-5F */
+	UINT8   SubnetMask[4];			/* 60-63 */
+	UINT8   RES6[12];			/* 64-6F */
+	UINT8   GatewayIPAddr[4];		/* 70-73 */
+	UINT8   RES7[12];			/* 74-7F */
+	UINT8   PriDNSIPAddr[4];		/* 80-83 */
+	UINT8   SecDNSIPAddr[4];		/* 84-87 */
+	UINT8   RES8[8];			/* 88-8F */
+	UINT8   Alias[32];			/* 90-AF */
+	UINT8   TargAddr[8];			/* B0-B7 */ //FIXME: Remove??
+	UINT8   CHAPNameSecretsTable[8];	/* B8-BF */
+	UINT8   EthernetMACAddr[6];		/* C0-C5 */
+	UINT16  TargetPortalGroup;		/* C6-C7 */
+	UINT8   SendScale;			/* C8    */
+	UINT8   RecvScale;			/* C9    */
+	UINT8   TypeOfService;			/* CA    */
+	UINT8   Time2Live;			/* CB    */
+	UINT16  VLANPriority;			/* CC-CD */
+	UINT16  Reserved8;			/* CE-CF */
+	UINT8   SecIPAddr[4];			/* D0-D3 */
+	UINT8   Reserved9[12];			/* D4-DF */
+	UINT8   iSNSIPAddr[4];			/* E0-E3 */
+	UINT16  iSNSServerPortNumber;		/* E4-E5 */
+	UINT8   Reserved10[10];			/* E6-EF */
+	UINT8   SLPDAIPAddr[4];			/* F0-F3 */
+	UINT8   Reserved11[12];			/* F4-FF */
+	UINT8   iSCSINameString[256];		/* 100-1FF */
+} INIT_FW_CTRL_BLK;
+
+typedef struct {
+	INIT_FW_CTRL_BLK init_fw_cb;
+	UINT32       Cookie;
+	#define INIT_FW_CTRL_BLK_COOKIE 	0x11BEAD5A
+} FLASH_INIT_FW_CTRL_BLK;
+
+/*************************************************************************/
+
+typedef struct _DEV_DB_ENTRY {
+	UINT8  options;	      /* 00 */
+   #define  DDB_OPT_DISABLE                  0x08  /* do not connect to device */
+   #define  DDB_OPT_ACCESSGRANTED            0x04
+   #define  DDB_OPT_TARGET                   0x02  /* device is a target */
+   #define  DDB_OPT_INITIATOR                0x01  /* device is an initiator */
+
+	UINT8  control;	      /* 01 */
+   #define  DDB_CTRL_DATABASE_ENTRY_STATE    0xC0
+   #define  DDB_CTRL_SESSION_RECOVERY        0x10
+   #define  DDB_CTRL_SENDING                 0x08
+   #define  DDB_CTRL_XFR_PENDING             0x04
+   #define  DDB_CTRL_QUEUE_ABORTED           0x02
+   #define  DDB_CTRL_LOGGED_IN               0x01
+
+	UINT16 exeThrottle;   /* 02-03 */
+	UINT16 exeCount;      /* 04-05 */
+	UINT8  retryCount;    /* 06    */
+	UINT8  retryDelay;    /* 07    */
+	UINT16 iSCSIOptions;  /* 08-09 */
+   #define DDB_IOPT_RECV_ISCSI_MARKER_ENABLE 0x8000
+   #define DDB_IOPT_SEND_ISCSI_MARKER_ENABLE 0x4000
+   #define DDB_IOPT_HEADER_DIGEST_ENABLE     0x2000
+   #define DDB_IOPT_DATA_DIGEST_ENABLE       0x1000
+   #define DDB_IOPT_IMMEDIATE_DATA_ENABLE    0x0800
+   #define DDB_IOPT_INITIAL_R2T_ENABLE       0x0400
+   #define DDB_IOPT_DATA_SEQUENCE_IN_ORDER   0x0200
+   #define DDB_IOPT_DATA_PDU_IN_ORDER        0x0100
+   #define DDB_IOPT_CHAP_AUTH_ENABLE         0x0080
+   #define DDB_IOPT_BIDIR_CHAP_CHAL_ENABLE   0x0010
+   #define DDB_IOPT_RESERVED2                0x007F
+
+	UINT16 TCPOptions;    /* 0A-0B */
+   #define DDB_TOPT_NAGLE_DISABLE            0x0020
+   #define DDB_TOPT_TIMER_SCALE_MASK         0x000E
+   #define DDB_TOPT_TIME_STAMP_ENABLE        0x0001
+
+	UINT16 IPOptions;     /* 0C-0D */
+   #define DDB_IPOPT_FRAG_DISABLE     	     0x0002
+   #define DDB_IPOPT_IP_ADDRESS_VALID        0x0001
+
+	UINT16 maxPDUSize;    /* 0E-0F */
+	UINT16 rcvMarkerInt;  /* 10-11 */
+	UINT16 sndMarkerInt;  /* 12-13 */
+	UINT16 iSCSIMaxSndDataSegLen;  /* 14-15 */
+	UINT16 firstBurstSize;	   /* 16-17 */
+	UINT16 minTime2Wait; /* 18-19 */
+	UINT16 maxTime2Retain; /* 1A-1B */
+	UINT16 maxOutstndngR2T;	   /* 1C-1D */
+	UINT16 keepAliveTimeout;   /* 1E-1F */
+	UINT8 ISID[6];	      /* 20-25 big-endian, must be converted to little-endian */
+	UINT16 TSID;	      /* 26-27 */
+	UINT16 portNumber;    /* 28-29 */
+	UINT16 maxBurstSize;  /* 2A-2B */
+	UINT16 taskMngmntTimeout;  /* 2C-2D */
+	UINT16 reserved1;     /* 2E-2F */
+	UINT8  ipAddr[0x10];  /* 30-3F */
+	UINT8  iSCSIAlias[0x20];   /* 40-5F */
+	UINT8  targetAddr[0x20];   /* 60-7F */
+	UINT8  userID[0x20];  /* 80-9F */
+	UINT8  password[0x20];	   /* A0-BF */
+	UINT8  iscsiName[0x100];   /* C0-1BF : xxzzy Make this a pointer to a string so we don't
+						     have to reserve soooo much RAM */
+	UINT16 ddbLink;	      /* 1C0-1C1 */
+	UINT16 CHAPTableIndex;	   /* 1C2-1C3 */
+	UINT16 TargetPortalGroup;  /* 1C4-1C5 */
+	UINT16 reserved2[2];		/* 1C6-1C7 */
+	UINT32 statSN;			/* 1C8-1CB */
+	UINT32 expStatSN;		/* 1CC-1CF */
+	UINT16 reserved3[0x2C];		/* 1D0-1FB */
+	UINT16 ddbValidCookie;		/* 1FC-1FD */
+	UINT16 ddbValidSize;		/* 1FE-1FF */
+} DEV_DB_ENTRY;
+
+
+/*************************************************************************/
+
+// Flash definitions
+#define FLASH_FW_IMG_PAGE_SIZE        0x20000
+#define FLASH_FW_IMG_PAGE(addr)       (0xfffe0000 & (addr))
+#define FLASH_STRUCTURE_TYPE_MASK     0x0f000000
+
+#define FLASH_OFFSET_FW_LOADER_IMG    0x00000000
+#define FLASH_OFFSET_SECONDARY_FW_IMG 0x01000000
+#define FLASH_OFFSET_SYS_INFO         0x02000000
+#define FLASH_OFFSET_DRIVER_BLK       0x03000000
+#define FLASH_OFFSET_INIT_FW_CTRL_BLK 0x04000000
+#define FLASH_OFFSET_DEV_DB_AREA      0x05000000
+#define FLASH_OFFSET_CHAP_AREA        0x06000000
+#define FLASH_OFFSET_PRIMARY_FW_IMG   0x07000000
+#define FLASH_READ_RAM_FLAG           0x10000000
+
+#define MAX_FLASH_SZ                  0x400000    /* 4M flash */
+#define FLASH_DEFAULTBLOCKSIZE        0x20000
+#define FLASH_EOF_OFFSET              FLASH_DEFAULTBLOCKSIZE - 8 /* 4 bytes for EOF signature */
+#define FLASH_FILESIZE_OFFSET         FLASH_EOF_OFFSET - 4       /* 4 bytes for file size */
+#define FLASH_CKSUM_OFFSET            FLASH_FILESIZE_OFFSET - 4  /* 4 bytes for chksum protection */
+
+typedef struct _SYS_INFO_PHYS_ADDR {
+	UINT8            address[6];		/* 00-05 */
+	UINT8            filler[2];		/* 06-07 */
+} SYS_INFO_PHYS_ADDR;
+
+typedef struct _FLASH_SYS_INFO {
+	UINT32           cookie;		/* 00-03 */
+	UINT32           physAddrCount;		/* 04-07 */
+	SYS_INFO_PHYS_ADDR physAddr[4];		/* 08-27 */
+	UINT8            vendorId[128];		/* 28-A7 */
+	UINT8            productId[128];	/* A8-127 */
+	UINT32           serialNumber;		/* 128-12B */
+
+	// PCI Configuration values
+	UINT32           pciDeviceVendor;	/* 12C-12F */
+	UINT32           pciDeviceId;		/* 130-133 */
+	UINT32           pciSubsysVendor;	/* 134-137 */
+	UINT32           pciSubsysId;		/* 138-13B */
+
+	// This validates version 1.
+	UINT32           crumbs;		/* 13C-13F */
+
+	UINT32           enterpriseNumber;	/* 140-143 */
+
+	UINT32           mtu;			/* 144-147 */
+	UINT32           reserved0;		/* 148-14b */
+	UINT32           crumbs2;		/* 14c-14f */
+	UINT8            acSerialNumber[16];	/* 150-15f */
+	UINT32           crumbs3;		/* 160-16f */
+
+	// Leave this last in the struct so it is declared invalid if
+	// any new items are added.
+	UINT32           reserved1[39];		/* 170-1ff */
+} FLASH_SYS_INFO, *PFLASH_SYS_INFO;		/* 200 */
+
+typedef struct _FLASH_DRIVER_INFO {
+	UINT32          LinuxDriverCookie;
+	#define FLASH_LINUX_DRIVER_COOKIE		0x0A1B2C3D
+	UINT8       Pad[4];
+
+} FLASH_DRIVER_INFO, *PFLASH_DRIVER_INFO;
+
+typedef struct _CHAP_ENTRY {
+	UINT16 link;				  //  0 x0
+   #define CHAP_FLAG_PEER_NAME		0x40
+   #define CHAP_FLAG_LOCAL_NAME    	0x80
+
+	UINT8 flags;				 //  2 x2
+   #define MIN_CHAP_SECRET_LENGTH  	12
+   #define MAX_CHAP_SECRET_LENGTH  	100
+
+	UINT8 secretLength;			 //  3 x3
+	UINT8 secret[MAX_CHAP_SECRET_LENGTH];	 //  4 x4
+   #define MAX_CHAP_CHALLENGE_LENGTH       256
+
+	UINT8 user_name[MAX_CHAP_CHALLENGE_LENGTH];   //104 x68
+	UINT16 reserved;			 //360 x168
+   #define CHAP_COOKIE                     0x4092
+
+	UINT16 cookie;				 //362 x16a
+} CHAP_ENTRY, *PCHAP_ENTRY;			      //364 x16c
+
+
+/*************************************************************************/
+
+typedef struct _CRASH_RECORD {
+	UINT16  fw_major_version;	/* 00 - 01 */
+	UINT16  fw_minor_version;	/* 02 - 03 */
+	UINT16  fw_patch_version;	/* 04 - 05 */
+	UINT16  fw_build_version;	/* 06 - 07 */
+
+	UINT8   build_date[16];		/* 08 - 17 */
+	UINT8   build_time[16];		/* 18 - 27 */
+	UINT8   build_user[16];		/* 28 - 37 */
+	UINT8   card_serial_num[16];	/* 38 - 47 */
+
+	UINT32  time_of_crash_in_secs;	/* 48 - 4B */
+	UINT32  time_of_crash_in_ms;	/* 4C - 4F */
+
+	UINT16  out_RISC_sd_num_frames;	/* 50 - 51 */
+	UINT16  OAP_sd_num_words;	/* 52 - 53 */
+	UINT16  IAP_sd_num_frames;	/* 54 - 55 */
+	UINT16  in_RISC_sd_num_words;	/* 56 - 57 */
+
+	UINT8   reserved1[28];		/* 58 - 7F */
+
+	UINT8   out_RISC_reg_dump[256];	/* 80 -17F */
+	UINT8   in_RISC_reg_dump[256];	/*180 -27F */
+	UINT8   in_out_RISC_stack_dump[0]; /*280 - ??? */
+} CRASH_RECORD, *PCRASH_RECORD;
+
+
+
+/*************************************************************************
+ *
+ *				IOCB Commands Structures and Definitions
+ *
+ *************************************************************************/
+#define IOCB_MAX_CDB_LEN            16  /* Bytes in a CBD */
+#define IOCB_MAX_SENSEDATA_LEN      32  /* Bytes of sense data */
+#define IOCB_MAX_EXT_SENSEDATA_LEN  60  /* Bytes of extended sense data */
+#define IOCB_MAX_DSD_CNT             1  /* DSDs per noncontinuation type IOCB */
+#define IOCB_CONT_MAX_DSD_CNT        5  /* DSDs per Continuation */
+#define CTIO_MAX_SENSEDATA_LEN      24  /* Bytes of sense data in a CTIO*/
+
+#define RESERVED_BYTES_MARKER       40  /* Reserved Bytes at end of Marker */
+#define RESERVED_BYTES_INOT         28  /* Reserved Bytes at end of Immediate Notify */
+#define RESERVED_BYTES_NOTACK       28  /* Reserved Bytes at end of Notify Acknowledge */
+#define RESERVED_BYTES_CTIO          2  /* Reserved Bytes in middle of CTIO */
+
+#define MAX_MBX_COUNT               14  /* Maximum number of mailboxes in MBX IOCB */
+
+#define ISCSI_MAX_NAME_BYTECNT      256  /* Bytes in a target name */
+
+#define IOCB_ENTRY_SIZE       	    0x40
+
+
+/* IOCB header structure */
+typedef struct _HEADER {
+	UINT8 entryType;
+   #define ET_STATUS                0x03
+   #define ET_MARKER                0x04
+   #define ET_CONT_T1               0x0A
+   #define ET_INOT                  0x0D
+   #define ET_NACK                  0x0E
+   #define ET_STATUS_CONTINUATION   0x10
+   #define ET_CMND_T4               0x15
+   #define ET_ATIO                  0x16
+   #define ET_CMND_T3               0x19
+   #define ET_CTIO4                 0x1E
+   #define ET_CTIO3                 0x1F
+   #define ET_PERFORMANCE_STATUS    0x20
+   #define ET_MAILBOX_CMD           0x38
+   #define ET_MAILBOX_STATUS        0x39
+   #define ET_PASSTHRU0             0x3A
+   #define ET_PASSTHRU1             0x3B
+   #define ET_PASSTHRU_STATUS       0x3C
+   #define ET_ASYNCH_MSG            0x3D
+   #define ET_CTIO5                 0x3E
+   #define ET_CTIO6                 0x3F
+
+	UINT8 entryStatus;
+    #define ES_MASK                 0x3E
+    #define ES_SUPPRESS_COMPL_INT   0x01
+    #define ES_BUSY                 0x02
+    #define ES_INVALID_ENTRY_TYPE   0x04
+    #define ES_INVALID_ENTRY_PARAM  0x08
+    #define ES_INVALID_ENTRY_COUNT  0x10
+    #define ES_INVALID_ENTRY_ORDER  0x20
+	UINT8 systemDefined;
+	UINT8 entryCount;
+
+	/* SyetemDefined definition */
+    #define SD_PASSTHRU_IOCB        0x01
+} HEADER ;
+
+/* Genric queue entry structure*/
+typedef struct QUEUE_ENTRY {
+	UINT8  data[60];
+	UINT32 signature;
+
+} QUEUE_ENTRY;
+
+
+/* 64 bit addressing segment counts*/
+
+#define COMMAND_SEG_A64             1
+#define CONTINUE_SEG_A64            5
+#define CONTINUE_SEG_A64_MINUS1     4
+
+/* 64 bit addressing segment definition*/
+
+typedef struct DATA_SEG_A64 {
+	struct {
+		UINT32 addrLow;
+		UINT32 addrHigh;
+
+	} base;
+
+	UINT32 count;
+
+} DATA_SEG_A64;
+
+/* Command Type 3 entry structure*/
+
+typedef struct _COMMAND_T3_ENTRY {
+	HEADER  hdr;		   /* 00-03 */
+
+	UINT32  handle;		   /* 04-07 */
+	UINT16  target;		   /* 08-09 */
+	UINT16  connection_id;	   /* 0A-0B */
+
+	UINT8   control_flags;	   /* 0C */
+   #define CF_IMMEDIATE		   0x80
+
+	/* data direction  (bits 5-6)*/
+   #define CF_WRITE                0x20
+   #define CF_READ                 0x40
+   #define CF_NO_DATA              0x00
+   #define CF_DIRECTION_MASK       0x60
+
+	/* misc  (bits 4-3)*/
+   #define CF_DSD_PTR_ENABLE	   0x10	   /* 4010 only */
+   #define CF_CMD_PTR_ENABLE	   0x08    /* 4010 only */
+
+	/* task attributes (bits 2-0) */
+   #define CF_ACA_QUEUE            0x04
+   #define CF_HEAD_TAG             0x03
+   #define CF_ORDERED_TAG          0x02
+   #define CF_SIMPLE_TAG           0x01
+   #define CF_TAG_TYPE_MASK        0x07
+   #define CF_ATTRIBUTES_MASK      0x67
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	*/
+	UINT8   state_flags;	   /* 0D */
+	UINT8   cmdRefNum;	   /* 0E */
+	UINT8   reserved1;	   /* 0F */
+	UINT8   cdb[IOCB_MAX_CDB_LEN];	/* 10-1F */
+	UINT8   lun[8];		   /* 20-27 */
+	UINT32  cmdSeqNum;	   /* 28-2B */
+	UINT16  timeout;	   /* 2C-2D */
+	UINT16  dataSegCnt;	   /* 2E-2F */
+	UINT32  ttlByteCnt;	   /* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+
+} COMMAND_T3_ENTRY;
+
+typedef struct _COMMAND_T4_ENTRY {
+	HEADER  hdr;		  /* 00-03 */
+	UINT32  handle;		  /* 04-07 */
+	UINT16  target;		  /* 08-09 */
+	UINT16  connection_id;	  /* 0A-0B */
+	UINT8   control_flags;	  /* 0C */
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	*/
+	UINT8   state_flags;	  /* 0D */
+	UINT8   cmdRefNum;	  /* 0E */
+	UINT8   reserved1;	  /* 0F */
+	UINT8   cdb[IOCB_MAX_CDB_LEN]; /* 10-1F */
+	UINT8   lun[8];		  /* 20-27 */
+	UINT32  cmdSeqNum;	  /* 28-2B */
+	UINT16  timeout;	  /* 2C-2D */
+	UINT16  dataSegCnt;	  /* 2E-2F */
+	UINT32  ttlByteCnt;	  /* 30-33 */
+
+	/* WE ONLY USE THE ADDRESS FIELD OF THE FOLLOWING STRUCT.
+	   THE COUNT FIELD IS RESERVED */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+} COMMAND_T4_ENTRY;
+
+/* Continuation Type 1 entry structure*/
+typedef struct _CONTINUATION_T1_ENTRY {
+	HEADER  hdr;
+
+	DATA_SEG_A64 dataseg[CONTINUE_SEG_A64];
+
+}CONTINUATION_T1_ENTRY;
+
+/* Status Continuation Type entry structure*/
+typedef struct _STATUS_CONTINUATION_ENTRY {
+	HEADER  hdr;
+
+	UINT8 extSenseData[IOCB_MAX_EXT_SENSEDATA_LEN];
+
+}STATUS_CONTINUATION_ENTRY;
+
+/* Parameterize for 64 or 32 bits */
+    #define COMMAND_SEG     COMMAND_SEG_A64
+    #define CONTINUE_SEG    CONTINUE_SEG_A64
+
+    #define COMMAND_ENTRY   COMMAND_T3_ENTRY
+    #define CONTINUE_ENTRY  CONTINUATION_T1_ENTRY
+
+    #define ET_COMMAND      ET_CMND_T3
+    #define ET_CONTINUE     ET_CONT_T1
+
+
+
+/* Marker entry structure*/
+typedef struct _MARKER_ENTRY {
+	HEADER  hdr;		/* 00-03 */
+
+	UINT32  system_defined;	/* 04-07 */
+	UINT16  target;		/* 08-09 */
+	UINT16  modifier;	/* 0A-0B */
+   #define MM_LUN_RESET         1
+   #define MM_TARGET_WARM_RESET 0
+   #define MM_TARGET_COLD_RESET 2
+   #define MM_CLEAR_TASK_SET    0
+   #define MM_ABORT_TASK_SET    0
+
+	UINT16  flags;		/* 0C-0D */
+	UINT16  reserved1;	/* 0E-0F */
+	UINT8   lun[8];		/* 10-17 */
+	UINT64  reserved2;	/* 18-1F */
+	UINT64  reserved3;	/* 20-27 */
+	UINT64  reserved4;	/* 28-2F */
+	UINT64  reserved5;	/* 30-37 */
+	UINT64  reserved6;	/* 38-3F */
+}MARKER_ENTRY;
+
+/* Status entry structure*/
+typedef struct _STATUS_ENTRY {
+	HEADER  hdr;			     /* 00-03 */
+
+	UINT32  handle;			     /* 04-07 */
+
+	UINT8   scsiStatus;		     /* 08 */
+   #define SCSI_STATUS_MASK                  0xFF
+   #define SCSI_STATUS                       0xFF
+   #define SCSI_GOOD                         0x00
+
+	UINT8   iscsiFlags;		     /* 09 */
+   #define ISCSI_FLAG_RESIDUAL_UNDER         0x02
+   #define ISCSI_FLAG_RESIDUAL_OVER          0x04
+   #define ISCSI_FLAG_RESIDUAL_UNDER_BIREAD  0x08
+   #define ISCSI_FLAG_RESIDUAL_OVER_BIREAD   0x10
+
+	UINT8   iscsiResponse;		     /* 0A */
+   #define ISCSI_RSP_COMPLETE                    0x00
+   #define ISCSI_RSP_TARGET_FAILURE              0x01
+   #define ISCSI_RSP_DELIVERY_SUBSYS_FAILURE     0x02
+   #define ISCSI_RSP_UNSOLISITED_DATA_REJECT     0x03
+   #define ISCSI_RSP_NOT_ENOUGH_UNSOLISITED_DATA 0x04
+   #define ISCSI_RSP_CMD_IN_PROGRESS             0x05
+
+	UINT8   completionStatus;	     /* 0B */
+   #define SCS_COMPLETE                      0x00
+   #define SCS_INCOMPLETE                    0x01
+   #define SCS_DMA_ERROR                     0x02
+   #define SCS_TRANSPORT_ERROR               0x03
+   #define SCS_RESET_OCCURRED                0x04
+   #define SCS_ABORTED                       0x05
+   #define SCS_TIMEOUT                       0x06
+   #define SCS_DATA_OVERRUN                  0x07
+   #define SCS_DATA_DIRECTION_ERROR          0x08
+   #define SCS_DATA_UNDERRUN                 0x15
+   #define SCS_QUEUE_FULL                    0x1C
+   #define SCS_DEVICE_UNAVAILABLE            0x28
+   #define SCS_DEVICE_LOGGED_OUT             0x29
+   #define SCS_DEVICE_CONFIG_CHANGED         0x2A
+
+	UINT8   reserved1;		     /* 0C */
+
+	/* state_flags MUST be at the same location as state_flags in the
+	   Command_T3/4_Entry */
+	UINT8   state_flags;		     /* 0D */
+   #define STATE_FLAG_SENT_COMMAND           0x01
+   #define STATE_FLAG_TRANSFERRED_DATA       0x02
+   #define STATE_FLAG_GOT_STATUS             0x04
+   #define STATE_FLAG_LOGOUT_SENT            0x10
+
+	UINT16  senseDataByteCnt;	     /* 0E-0F */
+	UINT32  residualByteCnt;	     /* 10-13 */
+	UINT32  bidiResidualByteCnt;	     /* 14-17 */
+	UINT32  expSeqNum;		     /* 18-1B */
+	UINT32  maxCmdSeqNum;		     /* 1C-1F */
+	UINT8   senseData[IOCB_MAX_SENSEDATA_LEN]; /* 20-3F */
+
+}STATUS_ENTRY;
+
+/*
+ * Performance Status Entry where up to 30 handles can be posted in a
+ * single IOSB. Handles are of 16 bit value.
+ */
+typedef struct  _PERFORMANCE_STATUS_ENTRY {
+	UINT8  entryType;
+	UINT8  entryCount;
+	UINT16 handleCount;
+
+   #define MAX_STATUS_HANDLE  30
+	UINT16 handleArray[ MAX_STATUS_HANDLE ];
+
+} PERFORMANCE_STATUS_ENTRY;
+
+
+typedef struct _IMMEDIATE_NOTIFY_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT16  initiator;
+	UINT16  InitSessionID;
+	UINT16  ConnectionID;
+	UINT16  TargSessionID;
+	UINT16  inotStatus;
+   #define INOT_STATUS_ABORT_TASK      0x0020
+   #define INOT_STATUS_LOGIN_RECVD     0x0021
+   #define INOT_STATUS_LOGOUT_RECVD    0x0022
+   #define INOT_STATUS_LOGGED_OUT      0x0029
+   #define INOT_STATUS_RESTART_RECVD   0x0030
+   #define INOT_STATUS_MSG_RECVD       0x0036
+   #define INOT_STATUS_TSK_REASSIGN    0x0037
+
+	UINT16  taskFlags;
+   #define TASK_FLAG_CLEAR_ACA         0x4000
+   #define TASK_FLAG_COLD_RESET        0x2000
+   #define TASK_FLAG_WARM_RESET        0x0800
+   #define TASK_FLAG_LUN_RESET         0x1000
+   #define TASK_FLAG_CLEAR_TASK_SET    0x0400
+   #define TASK_FLAG_ABORT_TASK_SET    0x0200
+
+
+	UINT32  refTaskTag;
+	UINT8   lun[8];
+	UINT32  inotTaskTag;
+	UINT8   res3[RESERVED_BYTES_INOT];
+} IMMEDIATE_NOTIFY_ENTRY ;
+
+typedef struct _NOTIFY_ACK_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT16  initiator;
+	UINT16  res1;
+	UINT16  flags;
+	UINT8        responseCode;
+	UINT8        qualifier;
+	UINT16  notAckStatus;
+	UINT16  taskFlags;
+   #define NACK_FLAG_RESPONSE_CODE_VALID 0x0010
+
+	UINT32  refTaskTag;
+	UINT8   lun[8];
+	UINT32  inotTaskTag;
+	UINT8   res3[RESERVED_BYTES_NOTACK];
+} NOTIFY_ACK_ENTRY ;
+
+typedef struct _ATIO_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0f */
+	UINT8   scsiCDB[IOCB_MAX_CDB_LEN];     /* 10-1F */
+	UINT8   LUN[8];			  /* 20-27 */
+	UINT8   cmdRefNum;		  /* 28 */
+
+	UINT8   pduType;		  /* 29 */
+   #define PDU_TYPE_NOPOUT                0x00
+   #define PDU_TYPE_SCSI_CMD              0x01
+   #define PDU_TYPE_SCSI_TASK_MNGMT_CMD   0x02
+   #define PDU_TYPE_LOGIN_CMD             0x03
+   #define PDU_TYPE_TEXT_CMD              0x04
+   #define PDU_TYPE_SCSI_DATA             0x05
+   #define PDU_TYPE_LOGOUT_CMD            0x06
+   #define PDU_TYPE_SNACK                 0x10
+
+	UINT16  atioStatus;		  /* 2A-2B */
+   #define ATIO_CDB_RECVD                 0x003d
+
+	UINT16  reserved1;		  /* 2C-2D */
+
+	UINT8   taskCode;		  /* 2E */
+   #define ATIO_TASK_CODE_UNTAGGED        0x00
+   #define ATIO_TASK_CODE_SIMPLE_QUEUE    0x01
+   #define ATIO_TASK_CODE_ORDERED_QUEUE   0x02
+   #define ATIO_TASK_CODE_HEAD_OF_QUEUE   0x03
+   #define ATIO_TASK_CODE_ACA_QUEUE       0x04
+
+	UINT8   reserved2;		  /* 2F */
+	UINT32  totalByteCnt;		  /* 30-33 */
+	UINT32  cmdSeqNum;		  /* 34-37 */
+	UINT64  immDataBufDesc;		  /* 38-3F */
+} ATIO_ENTRY ;
+
+typedef struct _CTIO3_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+
+	UINT8   flags;			  /* 10 */
+   #define CTIO_FLAG_SEND_SCSI_STATUS     0x01
+   #define CTIO_FLAG_TERMINATE_COMMAND    0x10
+   #define CTIO_FLAG_FAST_POST            0x08
+   #define CTIO_FLAG_FINAL_CTIO           0x80
+
+	/*  NOTE:  Our firmware assumes that the CTIO_FLAG_SEND_DATA and
+		   CTIO_FLAG_GET_DATA flags are in the same bit positions
+		   as the R and W bits in SCSI Command PDUs, so their values
+		   should not be changed!
+	 */
+   #define CTIO_FLAG_SEND_DATA            0x0040   /* (see note) Read Data Flag, send data to initiator       */
+   #define CTIO_FLAG_GET_DATA             0x0020   /* (see note) Write Data Flag, get data from the initiator */
+
+	UINT8   scsiStatus;		  /* 11 */
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  offset;			  /* 14-17 */
+	UINT32  r2tSN;			  /* 18-1B */
+	UINT32  expCmdSN;		  /* 1C-1F */
+	UINT32  maxCmdSN;		  /* 20-23 */
+	UINT32  dataSN;			  /* 24-27 */
+	UINT32  residualCount;		  /* 28-2B */
+	UINT16  reserved;		  /* 2C-2D */
+	UINT16  segmentCnt;		  /* 2E-2F */
+	UINT32  totalByteCnt;		  /* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64]; /* 34-3F */
+} CTIO3_ENTRY ;
+
+typedef struct _CTIO4_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+	UINT8   flags;			  /* 10 */
+	UINT8   scsiStatus;		  /* 11 */
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  offset;			  /* 14-17 */
+	UINT32  r2tSN;			  /* 18-1B */
+	UINT32  expCmdSN;		  /* 1C-1F */
+	UINT32  maxCmdSN;		  /* 20-23 */
+	UINT32  dataSN;			  /* 24-27 */
+	UINT32  residualCount;		  /* 28-2B */
+	UINT16  reserved;		  /* 2C-2D */
+	UINT16  segmentCnt;		  /* 2E-2F */
+	UINT32  totalByteCnt;		  /* 30-33 */
+	/* WE ONLY USE THE ADDRESS FROM THE FOLLOWING STRUCTURE THE COUNT FIELD IS
+	   RESERVED */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64]; /* 34-3F */
+} CTIO4_ENTRY ;
+
+typedef struct _CTIO5_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+	UINT8   response;		  /* 10 */
+	UINT8   scsiStatus;		  /* 11 */
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  reserved1;		  /* 14-17 */
+	UINT32  expR2TSn;		  /* 18-1B */
+	UINT32  expCmdSn;		  /* 1C-1F */
+	UINT32  MaxCmdSn;		  /* 20-23 */
+	UINT32  expDataSn;		  /* 24-27 */
+	UINT32  residualCnt;		  /* 28-2B */
+	UINT32  bidiResidualCnt;	  /* 2C-2F */
+	UINT32  reserved2;		  /* 30-33 */
+	DATA_SEG_A64 dataseg[1];	  /* 34-3F */
+} CTIO5_ENTRY ;
+
+typedef struct _CTIO6_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connection;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+	UINT16  flags;			  /* 10-11 */
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  reserved1;		  /* 14-17 */
+	UINT64  reserved2;		  /* 18-1F */
+	UINT64  reserved3;		  /* 20-27 */
+	UINT64  reserved4;		  /* 28-2F */
+	UINT32  reserved5;		  /* 30-33 */
+	DATA_SEG_A64 dataseg[1];	  /* 34-3F */
+} CTIO6_ENTRY ;
+
+typedef struct _CTIO_STATUS_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  initiator;		  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	UINT32  taskTag;		  /* 0C-0F */
+	UINT16  status;			  /* 10-11 */
+   #define CTIO_STATUS_COMPLETE           0x0001
+   #define CTIO_STATUS_ABORTED            0x0002
+   #define CTIO_STATUS_DMA_ERROR          0x0003
+   #define CTIO_STATUS_ERROR              0x0004
+   #define CTIO_STATUS_INVALID_TAG        0x0008
+   #define CTIO_STATUS_DATA_OVERRUN       0x0009
+   #define CTIO_STATUS_CMD_TIMEOUT        0x000B
+   #define CTIO_STATUS_PCI_ERROR          0x0010
+   #define CTIO_STATUS_DATA_UNDERRUN      0x0015
+   #define CTIO_STATUS_TARGET_RESET       0x0017
+   #define CTIO_STATUS_NO_CONNECTION      0x0028
+   #define CTIO_STATUS_LOGGED_OUT         0x0029
+   #define CTIO_STATUS_CONFIG_CHANGED     0x002A
+   #define CTIO_STATUS_UNACK_EVENT        0x0035
+   #define CTIO_STATUS_INVALID_DATA_XFER  0x0036
+
+	UINT16  timeout;		  /* 12-13 */
+	UINT32  reserved1;		  /* 14-17 */
+	UINT32  expR2TSN;		  /* 18-1B */
+	UINT32  reserved2;		  /* 1C-1F */
+	UINT32  reserved3;		  /* 20-23 */
+	UINT64  expDataSN;		  /* 24-27 */
+	UINT32  residualCount;		  /* 28-2B */
+	UINT32  reserved4;		  /* 2C-2F */
+	UINT64  reserved5;		  /* 30-37 */
+	UINT64  reserved6;		  /* 38-3F */
+} CTIO_STATUS_ENTRY ;
+
+typedef struct _MAILBOX_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT32  mbx[MAX_MBX_COUNT];
+} MAILBOX_ENTRY ;
+
+typedef struct MAILBOX_STATUS_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT32  mbx[MAX_MBX_COUNT];
+} MAILBOX_STATUS_ENTRY ;
+
+
+typedef struct _PDU_ENTRY {
+	UINT8       *Buff;
+	UINT32       BuffLen;
+	UINT32       SendBuffLen;
+	UINT32       RecvBuffLen;
+	struct _PDU_ENTRY *Next;
+} PDU_ENTRY, *PPDU_ENTRY;
+
+typedef struct _ISNS_DISCOVERED_TARGET_PORTAL {
+	UINT8       IPAddr[4];
+	UINT16      PortNumber;
+	UINT16      Reserved;
+} ISNS_DISCOVERED_TARGET_PORTAL, *PISNS_DISCOVERED_TARGET_PORTAL;
+
+typedef struct _ISNS_DISCOVERED_TARGET {
+	UINT32      NumPortals;		  /*  00-03 */
+#define ISNS_MAX_PORTALS 4
+	ISNS_DISCOVERED_TARGET_PORTAL Portal[ISNS_MAX_PORTALS];	/* 04-23 */
+	UINT32      DDID;		  /*  24-27 */
+	UINT8       NameString[256];	  /*  28-127 */
+	UINT8       Alias[32];		  /* 128-147 */
+//    UINT32 SecurityBitmap
+} ISNS_DISCOVERED_TARGET, *PISNS_DISCOVERED_TARGET;
+
+
+typedef struct _PASSTHRU0_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  target;			  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+	#define ISNS_DEFAULT_SERVER_CONN_ID     ((uint16_t)0x8000)
+
+	UINT16  controlFlags;		  /* 0C-0D */
+	#define PT_FLAG_ETHERNET_FRAME   	0x8000
+	#define PT_FLAG_ISNS_PDU                0x8000
+	#define PT_FLAG_IP_DATAGRAM             0x4000
+	#define PT_FLAG_TCP_PACKET              0x2000
+	#define PT_FLAG_NETWORK_PDU             (PT_FLAG_ETHERNET_FRAME | PT_FLAG_IP_DATAGRAM | PT_FLAG_TCP_PACKET)
+	#define PT_FLAG_iSCSI_PDU               0x1000
+	#define PT_FLAG_SEND_BUFFER             0x0200
+	#define PT_FLAG_WAIT_4_RESPONSE         0x0100
+	#define PT_FLAG_NO_FAST_POST            0x0080
+
+	UINT16  timeout;		  /* 0E-0F */
+	#define PT_DEFAULT_TIMEOUT              30   // seconds
+
+	DATA_SEG_A64 outDataSeg64;	  /* 10-1B */
+	UINT32  res1;			  /* 1C-1F */
+	DATA_SEG_A64 inDataSeg64;	  /* 20-2B */
+	UINT8   res2[20];		  /* 2C-3F */
+} PASSTHRU0_ENTRY ;
+
+typedef struct _PASSTHRU1_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  target;			  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+
+	UINT16  controlFlags;		  /* 0C-0D */
+   #define PT_FLAG_ETHERNET_FRAME         	0x8000
+   #define PT_FLAG_IP_DATAGRAM            	0x4000
+   #define PT_FLAG_TCP_PACKET             	0x2000
+   #define PT_FLAG_iSCSI_PDU              	0x1000
+   #define PT_FLAG_SEND_BUFFER            	0x0200
+   #define PT_FLAG_WAIT_4_REPONSE         	0x0100
+   #define PT_FLAG_NO_FAST_POST           	0x0080
+
+	UINT16  timeout;		  /* 0E-0F */
+	DATA_SEG_A64 outDSDList;	  /* 10-1B */
+	UINT32  outDSDCnt;		  /* 1C-1F */
+	DATA_SEG_A64 inDSDList;		  /* 20-2B */
+	UINT32  inDSDCnt;		  /* 2C-2F */
+	UINT8  res1;			  /* 30-3F */
+
+} PASSTHRU1_ENTRY ;
+
+typedef struct _PASSTHRU_STATUS_ENTRY {
+	HEADER  hdr;			  /* 00-03 */
+	UINT32  handle;			  /* 04-07 */
+	UINT16  target;			  /* 08-09 */
+	UINT16  connectionID;		  /* 0A-0B */
+
+	UINT8   completionStatus;	  /* 0C */
+   #define PASSTHRU_STATUS_COMPLETE       		0x01
+   #define PASSTHRU_STATUS_ERROR          		0x04
+   #define PASSTHRU_STATUS_INVALID_DATA_XFER            0x06
+   #define PASSTHRU_STATUS_CMD_TIMEOUT    		0x0B
+   #define PASSTHRU_STATUS_PCI_ERROR      		0x10
+   #define PASSTHRU_STATUS_NO_CONNECTION  		0x28
+
+	UINT8   residualFlags;		  /* 0D */
+   #define PASSTHRU_STATUS_DATAOUT_OVERRUN              0x01
+   #define PASSTHRU_STATUS_DATAOUT_UNDERRUN             0x02
+   #define PASSTHRU_STATUS_DATAIN_OVERRUN               0x04
+   #define PASSTHRU_STATUS_DATAIN_UNDERRUN              0x08
+
+	UINT16  timeout;		  /* 0E-0F */
+	UINT16  portNumber;		  /* 10-11 */
+	UINT8   res1[10];		  /* 12-1B */
+	UINT32  outResidual;		  /* 1C-1F */
+	UINT8   res2[12];		  /* 20-2B */
+	UINT32  inResidual;		  /* 2C-2F */
+	UINT8   res4[16];		  /* 30-3F */
+} PASSTHRU_STATUS_ENTRY ;
+
+typedef struct _ASYNCHMSG_ENTRY {
+	HEADER  hdr;
+	UINT32  handle;
+	UINT16  target;
+	UINT16  connectionID;
+	UINT8   lun[8];
+	UINT16  iSCSIEvent;
+   #define AMSG_iSCSI_EVENT_NO_EVENT                  0x0000
+   #define AMSG_iSCSI_EVENT_TARG_RESET                0x0001
+   #define AMSG_iSCSI_EVENT_TARGT_LOGOUT              0x0002
+   #define AMSG_iSCSI_EVENT_CONNECTION_DROPPED        0x0003
+   #define AMSG_ISCSI_EVENT_ALL_CONNECTIONS_DROPPED   0x0004
+
+	UINT16  SCSIEvent;
+   #define AMSG_NO_SCSI_EVENT                         0x0000
+   #define AMSG_SCSI_EVENT                            0x0001
+
+	UINT16  parameter1;
+	UINT16  parameter2;
+	UINT16  parameter3;
+	UINT32  expCmdSn;
+	UINT32  maxCmdSn;
+	UINT16  senseDataCnt;
+	UINT16  reserved;
+	UINT32  senseData[IOCB_MAX_SENSEDATA_LEN];
+} ASYNCHMSG_ENTRY ;
+
+/* Timer entry structure, this is an internal generated structure
+   which causes the QLA4000 initiator to send a NOP-OUT or the
+   QLA4000 target to send a NOP-IN */
+
+typedef struct _TIMER_ENTRY {
+	HEADER  hdr;		   /* 00-03 */
+
+	UINT32  handle;		   /* 04-07 */
+	UINT16  target;		   /* 08-09 */
+	UINT16  connection_id;	   /* 0A-0B */
+
+	UINT8   control_flags;	   /* 0C */
+
+	/* STATE FLAGS FIELD IS A PLACE HOLDER. THE FW WILL SET BITS IN THIS FIELD
+	   AS THE COMMAND IS PROCESSED. WHEN THE IOCB IS CHANGED TO AN IOSB THIS
+	   FIELD WILL HAVE THE STATE FLAGS SET PROPERLY.
+	*/
+	UINT8   state_flags;	   /* 0D */
+	UINT8   cmdRefNum;	   /* 0E */
+	UINT8   reserved1;	   /* 0F */
+	UINT8   cdb[IOCB_MAX_CDB_LEN];	   /* 10-1F */
+	UINT8   lun[8];		   /* 20-27 */
+	UINT32  cmdSeqNum;	   /* 28-2B */
+	UINT16  timeout;	   /* 2C-2D */
+	UINT16  dataSegCnt;	   /* 2E-2F */
+	UINT32  ttlByteCnt;	   /* 30-33 */
+	DATA_SEG_A64 dataseg[COMMAND_SEG_A64];	/* 34-3F */
+
+} TIMER_ENTRY;
+
+
+#endif /* _QLA4X_FW_H */
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_glbl.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_glbl.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_glbl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_glbl.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ * Global include file.
+ ****************************************************************************/
+#ifndef __QLA4x_GBL_H
+#define	__QLA4x_GBL_H
+
+#include <linux/interrupt.h>
+
+/*
+ * Defined in ql4_os.c
+ */
+
+extern void qla4xxx_start_io(scsi_qla_host_t *ha);
+extern srb_t *del_from_active_array(scsi_qla_host_t *ha, uint32_t index);
+extern uint8_t qla4xxx_complete_request(scsi_qla_host_t *ha, srb_t *srb);
+extern uint8_t qla4xxx_reset_lun(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, lun_entry_t *lun_entry);
+extern uint8_t qla4xxx_soft_reset(scsi_qla_host_t *);
+extern const char *host_sts_msg[];
+extern void qla4xxx_delete_timer_from_cmd(srb_t *srb);
+extern scsi_qla_host_t *qla4xxx_get_adapter_handle(uint16_t instance);
+extern uint32_t qla4xxx_get_hba_count(void);
+extern void qla4xxx_free_ddb_list(scsi_qla_host_t *ha);
+
+extern void qla4xxx_tgt_free(scsi_qla_host_t *ha, uint16_t t);
+extern os_tgt_t *qla4xxx_tgt_alloc(scsi_qla_host_t *, uint16_t);
+extern os_lun_t * qla4xxx_lun_alloc(scsi_qla_host_t *, uint16_t, uint16_t);
+extern void qla4xxx_extend_timeout(struct scsi_cmnd *cmd, int timeout);
+extern int qla4xxx_done(scsi_qla_host_t *old_ha);
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+extern struct list_head qla4xxx_hostlist;
+extern rwlock_t qla4xxx_hostlist_lock;
+
+extern void qla4xxx_flush_failover_q(scsi_qla_host_t *, os_lun_t *);
+#endif
+/*
+ * Defined in  ql4_iocb.c
+ */
+extern uint8_t qla4xxx_send_marker(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, lun_entry_t *lun_entry);
+extern uint8_t qla4xxx_send_marker_iocb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, lun_entry_t *lun_entry);
+
+extern uint8_t qla4xxx_get_req_pkt(scsi_qla_host_t *, QUEUE_ENTRY **);
+
+extern PDU_ENTRY *qla4xxx_get_pdu(scsi_qla_host_t *, uint32_t);
+extern void qla4xxx_free_pdu(scsi_qla_host_t *, PDU_ENTRY *);
+extern uint8_t qla4xxx_send_passthru0_iocb(scsi_qla_host_t *, uint16_t,
+    uint16_t, uint8_t *, uint32_t, uint32_t, uint16_t, uint32_t);
+
+/*
+ * Defined in  ql4_isr.c
+ */
+
+extern irqreturn_t qla4xxx_intr_handler(int, void *, struct pt_regs *);
+extern void qla4xxx_interrupt_service_routine(scsi_qla_host_t *ha, uint32_t  intr_status);
+extern void __qla4xxx_suspend_lun(scsi_qla_host_t *ha, srb_t *srb, os_lun_t *lun_entry, uint16_t time,
+		    uint16_t retries, int delay);
+
+
+/*
+ * Defined in  ql4_init.c
+ */
+extern uint8_t qla4xxx_initialize_adapter(scsi_qla_host_t *ha, uint8_t renew_ddb_list);
+
+extern ddb_entry_t *qla4xxx_alloc_ddb(scsi_qla_host_t *ha, uint32_t fw_ddb_index);
+extern uint8_t qla4xxx_update_ddb_entry(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+extern uint8_t qla4xxx_get_fwddb_entry(scsi_qla_host_t *ha, uint16_t fw_ddb_index, DEV_DB_ENTRY *fw_ddb_entry, dma_addr_t fw_ddb_entry_dma, uint32_t *num_valid_ddb_entries, uint32_t *next_ddb_index, uint32_t *fw_ddb_device_state, uint32_t *time2wait, uint16_t *tcp_source_port_num, uint16_t *connection_id);
+extern uint8_t qla4xxx_relogin_device(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+extern uint8_t qla4xxx_send_command_to_isp(scsi_qla_host_t *, srb_t *);
+extern int qla4xxx_get_prop_12chars(scsi_qla_host_t *ha, uint8_t *propname, uint8_t *propval, uint8_t *db);
+extern void qla4xxx_free_ddb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+extern uint8_t qla4xxx_resize_ioctl_dma_buf(scsi_qla_host_t *ha, uint32_t size);
+extern uint8_t qla4xxx_set_ddb_entry(scsi_qla_host_t *ha, uint16_t fw_ddb_index, DEV_DB_ENTRY *fw_ddb_entry, dma_addr_t fw_ddb_entry_dma);
+extern uint8_t qla4xxx_process_ddb_changed(scsi_qla_host_t *ha, uint32_t fw_ddb_index, uint32_t state);
+extern uint8_t qla4xxx_init_rings(scsi_qla_host_t *ha);
+extern uint8_t qla4xxx_reinitialize_ddb_list(scsi_qla_host_t *ha);
+extern fc_lun_t * qla4xxx_add_fclun(fc_port_t *fcport, uint16_t lun);
+extern os_lun_t *
+qla4xxx_fclun_bind(scsi_qla_host_t *ha, fc_port_t *fcport, fc_lun_t *fclun);
+extern void qla4xxx_flush_all_srbs(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry, os_lun_t *lun_entry);
+
+
+/*
+ * Defined in  ql4_mbx.c
+ */
+extern void qla4xxx_process_aen(scsi_qla_host_t *ha, uint8_t flush_ddb_chg_aens);
+extern uint8_t qla4xxx_mailbox_command(scsi_qla_host_t *ha, uint8_t inCount, uint8_t outCount, uint32_t *mbx_cmd, uint32_t *mbx_sts);
+extern uint8_t qla4xxx_issue_iocb(scsi_qla_host_t *ha, void*  buffer, dma_addr_t phys_addr, size_t size);
+
+extern uint8_t qla4xxx_isns_enable(scsi_qla_host_t *, uint32_t, uint16_t);
+extern uint8_t qla4xxx_isns_disable(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_get_flash(scsi_qla_host_t *, dma_addr_t, uint32_t,
+    uint32_t);
+
+extern uint8_t qla4xxx_initialize_fw_cb(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_get_firmware_state(scsi_qla_host_t *);
+
+extern void qla4xxx_get_crash_record(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_conn_close_sess_logout(scsi_qla_host_t *, uint16_t,
+    uint16_t, uint16_t);
+
+extern uint8_t qla4xxx_clear_database_entry(scsi_qla_host_t *, uint16_t);
+
+extern uint8_t qla4xxx_get_fw_version(scsi_qla_host_t *ha);
+
+/*
+ * Defined in  ql4_inioct.c
+ */
+extern void qla4xxx_iocb_pass_done(scsi_qla_host_t *ha, PASSTHRU_STATUS_ENTRY *sts_entry);
+
+/*
+ * Defined in  ql4_xioct.c
+ */
+extern void qla4xxx_scsi_pass_done(struct scsi_cmnd *cmd);
+extern void qla4xxx_ioctl_sem_init (scsi_qla_host_t *ha);
+
+
+/*
+ * Defined in  ql4_isns.c
+ */
+extern uint8_t qla4xxx_isns_process_response(scsi_qla_host_t *ha, PASSTHRU_STATUS_ENTRY *sts_entry);
+
+extern uint8_t
+qla4xxx_isns_restart_service_completion(scsi_qla_host_t *ha,
+					uint32_t isns_ip_addr,
+					uint16_t isns_server_port_num);
+extern uint8_t qla4xxx_isns_restart_service(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_isns_init_attributes(scsi_qla_host_t *);
+
+extern uint8_t qla4xxx_isns_reenable(scsi_qla_host_t *, uint32_t, uint16_t);
+
+extern void qla4xxx_isns_enable_callback(scsi_qla_host_t *, uint32_t, uint32_t,
+    uint32_t, uint32_t);
+extern uint8_t qla4xxx_isns_get_server_request(scsi_qla_host_t *, uint32_t,
+    uint16_t);
+
+/*
+ * Defined in  ql4_nvram.c
+ */
+
+extern u16 RD_NVRAM_WORD(scsi_qla_host_t *, int);
+extern uint8_t qla4xxx_is_NVRAM_configuration_valid(scsi_qla_host_t *ha);
+extern void qla4xxx_clear_hw_semaphore(scsi_qla_host_t *ha, uint32_t sem);
+extern uint8_t qla4xxx_take_hw_semaphore(scsi_qla_host_t *ha, uint32_t sem, uint8_t wait_flag);
+
+/*
+ * Defined in  ql4_dbg.c
+ */
+extern void qla4xxx_dump_buffer(uint8_t *, uint32_t);
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+/*
+ * Defined in  ql4_fo.c
+ */
+extern void
+qla4xxx_reset_lun_fo_counts(scsi_qla_host_t *ha, os_lun_t *lq);
+
+/*
+ * Defined in  ql4_foio.c
+ */
+extern void qla4xxx_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport);
+
+/*
+ * Defined in  ql4_foln.c
+ */
+extern void qla4xxx_flush_failover_q(scsi_qla_host_t *ha, os_lun_t *q);
+
+extern int qla4xxx_issue_scsi_inquiry(scsi_qla_host_t *ha,
+	fc_port_t *fcport, fc_lun_t *fclun );
+extern int qla4xxx_test_active_lun(fc_port_t *fcport, fc_lun_t *fclun);
+extern int qla4xxx_get_wwuln_from_device(mp_host_t *host, fc_lun_t *fclun,
+	char	*evpd_buf, int wwlun_size);
+extern fc_lun_t * qla4xxx_cfg_lun(scsi_qla_host_t *ha, fc_port_t *fcport,
+    uint16_t lun, inq_cmd_rsp_t *inq, dma_addr_t inq_dma);
+extern void
+qla4xxx_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport);
+extern int qla4xxx_rpt_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport,
+    inq_cmd_rsp_t *inq, dma_addr_t inq_dma);
+extern int
+qla4xxx_spinup(scsi_qla_host_t *ha, fc_port_t *fcport, uint16_t lun);
+#endif				
+#endif /* _QLA4x_GBL_H */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_inioct.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_inioct.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_inioct.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_inioct.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,1743 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	qla4intioctl_logout_iscsi
+ *	qla4intioctl_ping
+ *	__xlate_sys_info
+ *	__xlate_driver_info
+ *	__xlate_init_fw_ctrl_blk
+ *	__xlate_dev_db
+ *	__xlate_chap
+ *	qla4intioctl_get_flash
+ *	qla4intioctl_get_driver_debug_level
+ *	qla4intioctl_get_host_no
+ *	qla4intioctl_get_data
+ *	qla4intioctl_set_flash
+ *	qla4intioctl_set_driver_debug_level
+ *	qla4intioctl_set_data
+ *	qla4intioctl_hba_reset
+ *	qla4intioctl_copy_fw_flash
+ *	qla4xxx_iocb_pass_done
+ *	qla4intioctl_iocb_passthru
+ ****************************************************************************/
+#include "ql4_def.h"
+#include "ql4_ioctl.h"
+
+
+// KRH: (BEGIN) Define these locally, for now
+/*
+ * Sub codes for Get Data.
+ * Use in combination with INT_GET_DATA as the ioctl code
+ */
+#define INT_SC_GET_DRIVER_DEBUG_LEVEL   2
+#define INT_SC_GET_HOST_NO 		3
+
+/*
+ * Sub codes for Set Data.
+ * Use in combination with INT_SET_DATA as the ioctl code
+ */
+#define INT_SC_SET_DRIVER_DEBUG_LEVEL	2
+
+/*
+ * Sub codes for Reset
+ * Use in combination with INT_CC_HBA_RESET as the ioctl code
+ */
+#define INT_SC_HBA_RESET			0
+#define INT_SC_FIRMWARE_RESET			1
+#define INT_SC_TARGET_WARM_RESET		2
+#define INT_SC_LUN_RESET			3
+//KRH: (END)
+
+/* Defines for byte-order translation direction */
+#define GET_DATA	0
+#define SET_DATA	1
+
+ioctl_tbl_row_t IOCTL_SCMD_IGET_DATA_TBL[] =
+{
+	{INT_SC_GET_FLASH, "INT_SC_GET_FLASH"},
+	{INT_SC_GET_DRIVER_DEBUG_LEVEL, "INT_SC_GET_DRIVER_DEBUG_LEVEL"},
+	{INT_SC_GET_HOST_NO, "INT_SC_GET_HOST_NO"},
+	{0, "UNKNOWN"}
+};
+
+ioctl_tbl_row_t IOCTL_SCMD_ISET_DATA_TBL[] =
+{
+	{INT_SC_SET_FLASH, "INT_SC_SET_FLASH"},
+	{INT_SC_SET_DRIVER_DEBUG_LEVEL, "INT_SC_SET_DRIVER_DEBUG_LEVEL"},
+	{0, "UNKNOWN"}
+};
+
+
+/**************************************************************************
+ * qla4intioctl_logout_iscsi
+ *	This routine requests that the specified device either login or
+ *	logout, depending on the option specified.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4intioctl_logout_iscsi(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	INT_LOGOUT_ISCSI logout;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (ioctl->RequestLen > sizeof(INT_LOGOUT_ISCSI)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_logout;
+	}
+
+	/* --- Copy logout structure from user space --- */
+	if ((status = copy_from_user((void *)&logout,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), sizeof(INT_LOGOUT_ISCSI))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data from "
+		    "user's memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_logout;
+	}
+
+	/* --- Execute command --- */
+	if (logout.Options == INT_DEF_CLOSE_SESSION) {
+		if (qla4xxx_logout_device(ha, logout.TargetID,
+		    logout.ConnectionID) == QLA_SUCCESS) {
+			QL4PRINT(QLP4,
+			    printk("scsi%d: %s: CLOSE_SESSION SUCCEEDED!, "
+			    "target %d\n", ha->host_no, __func__,
+			    logout.TargetID));
+
+			ioctl->Status = EXT_STATUS_OK;
+		} else {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: CLOSE_SESSION FAILED!, "
+			    "target %d\n", ha->host_no, __func__,
+			    logout.TargetID));
+
+			ioctl->Status = EXT_STATUS_ERR;
+		}
+
+	} else if (logout.Options == INT_DEF_RELOGIN_CONNECTION) {
+		if (qla4xxx_login_device(ha, logout.TargetID,
+		    logout.ConnectionID) == QLA_SUCCESS) {
+			QL4PRINT(QLP4,
+			    printk("scsi%d: %s: RELOGIN_CONNECTION "
+			    "SUCCEEDED!, target %d\n",
+			    ha->host_no, __func__, logout.TargetID));
+
+			ioctl->Status = EXT_STATUS_OK;
+		} else {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: RELOGIN_CONNECTION "
+			    "FAILED!, target %d\n",
+			    ha->host_no, __func__, logout.TargetID));
+
+			ioctl->Status = EXT_STATUS_ERR;
+		}
+
+	} else if (logout.Options == INT_DEF_DELETE_DDB) {
+		if (qla4xxx_delete_device(ha, logout.TargetID,
+		    logout.ConnectionID) == QLA_SUCCESS) {
+			QL4PRINT(QLP4,
+			    printk("scsi%d: %s: DELETE_DDB "
+			    "SUCCEEDED!, target %d\n",
+			    ha->host_no, __func__, logout.TargetID));
+
+			ioctl->Status = EXT_STATUS_OK;
+		} else {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: DELETE_DDB FAILED!, "
+			    "target %d\n",
+			    ha->host_no, __func__, logout.TargetID));
+
+			ioctl->Status = EXT_STATUS_ERR;
+		}
+	}
+
+exit_logout:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4intioctl_ping
+ *	This routine requests that the HBA PING the specified IP Address.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4intioctl_ping(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	INT_PING	ping;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	/*
+	 * Copy user's data to local buffer
+	 */
+	if ((status = copy_from_user((uint8_t *)&ping,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), sizeof(ping))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data from "
+		    "user's memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_ping;
+	}
+
+	/*
+	 * Debug Print Statement
+	 */
+	if (ping.IPAddr.Type == EXT_DEF_TYPE_ISCSI_IP) {
+		QL4PRINT(QLP4,
+		    printk("scsi%d: %s: %d.%d.%d.%d\n",
+		    ha->host_no, __func__,
+		    ping.IPAddr.IPAddress[0],
+		    ping.IPAddr.IPAddress[1],
+		    ping.IPAddr.IPAddress[2],
+		    ping.IPAddr.IPAddress[3]));
+	} else {
+		QL4PRINT(QLP4,
+		    printk("scsi%d: %s: %d.%d.%d.%d. %d.%d.%d.%d. "
+		    "%d.%d.%d.%d. %d.%d.%d.%d\n",
+		    ha->host_no, __func__,
+		    ping.IPAddr.IPAddress[0], ping.IPAddr.IPAddress[1],
+		    ping.IPAddr.IPAddress[2], ping.IPAddr.IPAddress[3],
+		    ping.IPAddr.IPAddress[4], ping.IPAddr.IPAddress[5],
+		    ping.IPAddr.IPAddress[6], ping.IPAddr.IPAddress[7],
+		    ping.IPAddr.IPAddress[8], ping.IPAddr.IPAddress[9],
+		    ping.IPAddr.IPAddress[10], ping.IPAddr.IPAddress[11],
+		    ping.IPAddr.IPAddress[12], ping.IPAddr.IPAddress[13],
+		    ping.IPAddr.IPAddress[14], ping.IPAddr.IPAddress[15]));
+	}
+
+	/*
+	 * Issue Mailbox Command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_PING;
+	mbox_cmd[1] = ping.PacketCount;
+	memcpy(&mbox_cmd[2], &ping.IPAddr.IPAddress, EXT_DEF_IP_ADDR_SIZE);
+
+	if (qla4xxx_mailbox_command(ha, 6, 1, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_ping;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+exit_ping:
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+#if BYTE_ORDER_SUPPORT_ENABLED
+static void
+__xlate_sys_info(FLASH_SYS_INFO *from, FLASH_SYS_INFO *to,
+    uint8_t direction)
+{
+	switch (direction) {
+	case GET_DATA:
+		from->cookie            = le32_to_cpu(to->cookie);
+		from->physAddrCount     = le32_to_cpu(to->physAddrCount);
+		memcpy(from->physAddr,  to->physAddr, sizeof(from->physAddr));
+		memcpy(from->vendorId,  to->vendorId, sizeof(from->vendorId));
+		memcpy(from->productId, to->productId, sizeof(from->productId));
+		from->serialNumber      = le32_to_cpu(to->serialNumber);
+		from->pciDeviceVendor   = le32_to_cpu(to->pciDeviceVendor);
+		from->pciDeviceId       = le32_to_cpu(to->pciDeviceId);
+		from->pciSubsysVendor   = le32_to_cpu(to->pciSubsysVendor);
+		from->pciSubsysId       = le32_to_cpu(to->pciSubsysId);
+		from->crumbs            = le32_to_cpu(to->crumbs);
+		from->enterpriseNumber  = le32_to_cpu(to->enterpriseNumber);
+		from->mtu               = le32_to_cpu(to->mtu);
+		from->reserved0         = le32_to_cpu(to->reserved0);
+		from->crumbs2           = le32_to_cpu(to->crumbs2);
+		memcpy(from->acSerialNumber, to->acSerialNumber,
+		    sizeof(from->acSerialNumber));
+		from->crumbs3           = le32_to_cpu(to->crumbs3);
+		memcpy(from->reserved1, to->reserved1, sizeof(from->reserved1));
+		break;
+
+	case SET_DATA:
+		from->cookie            = cpu_to_le32(to->cookie);
+		from->physAddrCount     = cpu_to_le32(to->physAddrCount);
+		memcpy(from->physAddr,  to->physAddr, sizeof(from->physAddr));
+		memcpy(from->vendorId,  to->vendorId, sizeof(from->vendorId));
+		memcpy(from->productId, to->productId, sizeof(from->productId));
+		from->serialNumber      = cpu_to_le32(to->serialNumber);
+		from->pciDeviceVendor   = cpu_to_le32(to->pciDeviceVendor);
+		from->pciDeviceId       = cpu_to_le32(to->pciDeviceId);
+		from->pciSubsysVendor   = cpu_to_le32(to->pciSubsysVendor);
+		from->pciSubsysId       = cpu_to_le32(to->pciSubsysId);
+		from->crumbs            = cpu_to_le32(to->crumbs);
+		from->enterpriseNumber  = cpu_to_le32(to->enterpriseNumber);
+		from->mtu               = cpu_to_le32(to->mtu);
+		from->reserved0         = cpu_to_le32(to->reserved0);
+		from->crumbs2           = cpu_to_le32(to->crumbs2);
+		memcpy(from->acSerialNumber, to->acSerialNumber,
+		    sizeof(from->acSerialNumber));
+		from->crumbs3           = cpu_to_le32(to->crumbs3);
+		memcpy(from->reserved1, to->reserved1, sizeof(from->reserved1));
+		break;
+	}
+}
+
+static void
+__xlate_driver_info(INT_FLASH_DRIVER_PARAM *from,
+    INT_FLASH_DRIVER_PARAM *to, uint8_t direction)
+{
+	switch (direction) {
+	case GET_DATA:
+		from->DiscoveryTimeOut = le16_to_cpu(to->DiscoveryTimeOut);
+		from->PortDownTimeout = le16_to_cpu(to->PortDownTimeout);
+		memcpy(from->Reserved, to->Reserved, sizeof(from->Reserved));
+		break;
+
+	case SET_DATA:
+		from->DiscoveryTimeOut = cpu_to_le32(to->DiscoveryTimeOut);
+		from->PortDownTimeout = cpu_to_le32(to->PortDownTimeout);
+		memcpy(from->Reserved, to->Reserved, sizeof(from->Reserved));
+		break;
+	}
+}
+
+static void
+__xlate_init_fw_ctrl_blk(INIT_FW_CTRL_BLK *from,
+    INIT_FW_CTRL_BLK *to, uint8_t direction)
+{
+	switch (direction) {
+	case GET_DATA:
+		from->Version           = to->Version;
+		from->Control           = to->Control;
+		from->FwOptions         = le16_to_cpu(to->FwOptions);
+		from->ExecThrottle      = le16_to_cpu(to->ExecThrottle);
+		from->RetryCount        = to->RetryCount;
+		from->RetryDelay        = to->RetryDelay;
+		from->MaxEthFrPayloadSize = le16_to_cpu(to->MaxEthFrPayloadSize);
+		from->AddFwOptions      = le16_to_cpu(to->AddFwOptions);
+		from->HeartbeatInterval = to->HeartbeatInterval;
+		from->InstanceNumber    = to->InstanceNumber;
+		from->RES2              = le16_to_cpu(to->RES2);
+		from->ReqQConsumerIndex = le16_to_cpu(to->ReqQConsumerIndex);
+		from->ComplQProducerIndex = le16_to_cpu(to->ComplQProducerIndex);
+		from->ReqQLen           = le16_to_cpu(to->ReqQLen);
+		from->ComplQLen         = le16_to_cpu(to->ComplQLen);
+		from->ReqQAddrLo        = le32_to_cpu(to->ReqQAddrLo);
+		from->ReqQAddrHi        = le32_to_cpu(to->ReqQAddrHi);
+		from->ComplQAddrLo      = le32_to_cpu(to->ComplQAddrLo);
+		from->ComplQAddrHi      = le32_to_cpu(to->ComplQAddrHi);
+		from->ShadowRegBufAddrLo= le32_to_cpu(to->ShadowRegBufAddrLo);
+		from->ShadowRegBufAddrHi= le32_to_cpu(to->ShadowRegBufAddrHi);
+		from->iSCSIOptions      = le16_to_cpu(to->iSCSIOptions);
+		from->TCPOptions        = le16_to_cpu(to->TCPOptions);
+		from->IPOptions         = le16_to_cpu(to->IPOptions);
+		from->MaxPDUSize        = le16_to_cpu(to->MaxPDUSize);
+		from->RcvMarkerInt      = le16_to_cpu(to->RcvMarkerInt);
+		from->SndMarkerInt      = le16_to_cpu(to->SndMarkerInt);
+		from->InitMarkerlessInt = le16_to_cpu(to->InitMarkerlessInt);
+		from->FirstBurstSize    = le16_to_cpu(to->FirstBurstSize);
+		from->DefaultTime2Wait  = le16_to_cpu(to->DefaultTime2Wait);
+		from->DefaultTime2Retain= le16_to_cpu(to->DefaultTime2Retain);
+		from->MaxOutStndngR2T   = le16_to_cpu(to->MaxOutStndngR2T);
+		from->KeepAliveTimeout  = le16_to_cpu(to->KeepAliveTimeout);
+		from->PortNumber        = le16_to_cpu(to->PortNumber);
+		from->MaxBurstSize      = le16_to_cpu(to->MaxBurstSize);
+		from->RES4              = le32_to_cpu(to->RES4);
+		memcpy(from->IPAddr, to->IPAddr, sizeof(from->IPAddr));
+		memcpy(from->RES5, to->RES5, sizeof(from->RES5));
+		memcpy(from->SubnetMask, to->SubnetMask,
+		    sizeof(from->SubnetMask));
+		memcpy(from->RES6, to->RES6, sizeof(from->RES6));
+		memcpy(from->GatewayIPAddr, to->GatewayIPAddr,
+		    sizeof(from->GatewayIPAddr));
+		memcpy(from->RES7, to->RES7, sizeof(from->RES7));
+		memcpy(from->PriDNSIPAddr, to->PriDNSIPAddr,
+		    sizeof(from->PriDNSIPAddr));
+		memcpy(from->SecDNSIPAddr, to->SecDNSIPAddr,
+		    sizeof(from->SecDNSIPAddr));
+		memcpy(from->RES8, to->RES8, sizeof(from->RES8));
+		memcpy(from->Alias, to->Alias, sizeof(from->Alias));
+		memcpy(from->TargAddr, to->TargAddr, sizeof(from->TargAddr));
+		memcpy(from->CHAPNameSecretsTable, to->CHAPNameSecretsTable,
+		    sizeof(from->CHAPNameSecretsTable));
+		memcpy(from->EthernetMACAddr, to->EthernetMACAddr,
+		    sizeof(from->EthernetMACAddr));
+		from->TargetPortalGroup = le16_to_cpu(to->TargetPortalGroup);
+		from->SendScale         = to->SendScale;
+		from->RecvScale         = to->RecvScale;
+		from->TypeOfService     = to->TypeOfService;
+		from->Time2Live         = to->Time2Live;
+		from->VLANPriority      = le16_to_cpu(to->VLANPriority);
+		from->Reserved8         = le16_to_cpu(to->Reserved8);
+		memcpy(from->SecIPAddr, to->SecIPAddr, sizeof(from->SecIPAddr));
+		memcpy(from->Reserved9, to->Reserved9, sizeof(from->Reserved9));
+		memcpy(from->iSNSIPAddr, to->iSNSIPAddr,
+		    sizeof(from->iSNSIPAddr));
+		memcpy(from->Reserved10, to->Reserved10,
+		    sizeof(from->Reserved10));
+		from->iSNSClientPortNumber =
+		    le16_to_cpu(to->iSNSClientPortNumber);
+		from->iSNSServerPortNumber =
+		    le16_to_cpu(to->iSNSServerPortNumber);
+		from->iSNSSCNPortNumber = le16_to_cpu(to->iSNSSCNPortNumber);
+		from->iSNSESIPortNumber = le16_to_cpu(to->iSNSESIPortNumber);
+		memcpy(from->SLPDAIPAddr, to->SLPDAIPAddr,
+		    sizeof(from->SLPDAIPAddr));
+		memcpy(from->Reserved11, to->Reserved11,
+		    sizeof(from->Reserved11));
+		memcpy(from->iSCSINameString, to->iSCSINameString,
+		    sizeof(from->iSCSINameString));
+		break;
+
+	case SET_DATA:
+		from->Version           = to->Version;
+		from->Control           = to->Control;
+		from->FwOptions         = cpu_to_le16(to->FwOptions);
+		from->ExecThrottle      = cpu_to_le16(to->ExecThrottle);
+		from->RetryCount        = to->RetryCount;
+		from->RetryDelay        = to->RetryDelay;
+		from->MaxEthFrPayloadSize = cpu_to_le16(to->MaxEthFrPayloadSize);
+		from->AddFwOptions      = cpu_to_le16(to->AddFwOptions);
+		from->HeartbeatInterval = to->HeartbeatInterval;
+		from->InstanceNumber    = to->InstanceNumber;
+		from->RES2              = cpu_to_le16(to->RES2);
+		from->ReqQConsumerIndex = cpu_to_le16(to->ReqQConsumerIndex);
+		from->ComplQProducerIndex = cpu_to_le16(to->ComplQProducerIndex);
+		from->ReqQLen           = cpu_to_le16(to->ReqQLen);
+		from->ComplQLen         = cpu_to_le16(to->ComplQLen);
+		from->ReqQAddrLo        = cpu_to_le32(to->ReqQAddrLo);
+		from->ReqQAddrHi        = cpu_to_le32(to->ReqQAddrHi);
+		from->ComplQAddrLo      = cpu_to_le32(to->ComplQAddrLo);
+		from->ComplQAddrHi      = cpu_to_le32(to->ComplQAddrHi);
+		from->ShadowRegBufAddrLo= cpu_to_le32(to->ShadowRegBufAddrLo);
+		from->ShadowRegBufAddrHi= cpu_to_le32(to->ShadowRegBufAddrHi);
+		from->iSCSIOptions      = cpu_to_le16(to->iSCSIOptions);
+		from->TCPOptions        = cpu_to_le16(to->TCPOptions);
+		from->IPOptions         = cpu_to_le16(to->IPOptions);
+		from->MaxPDUSize        = cpu_to_le16(to->MaxPDUSize);
+		from->RcvMarkerInt      = cpu_to_le16(to->RcvMarkerInt);
+		from->SndMarkerInt      = cpu_to_le16(to->SndMarkerInt);
+		from->InitMarkerlessInt = cpu_to_le16(to->InitMarkerlessInt);
+		from->FirstBurstSize    = cpu_to_le16(to->FirstBurstSize);
+		from->DefaultTime2Wait  = cpu_to_le16(to->DefaultTime2Wait);
+		from->DefaultTime2Retain= cpu_to_le16(to->DefaultTime2Retain);
+		from->MaxOutStndngR2T   = cpu_to_le16(to->MaxOutStndngR2T);
+		from->KeepAliveTimeout  = cpu_to_le16(to->KeepAliveTimeout);
+		from->PortNumber        = cpu_to_le16(to->PortNumber);
+		from->MaxBurstSize      = cpu_to_le16(to->MaxBurstSize);
+		from->RES4              = cpu_to_le32(to->RES4);
+		memcpy(from->IPAddr, to->IPAddr, sizeof(from->IPAddr));
+		memcpy(from->RES5, to->RES5, sizeof(from->RES5));
+		memcpy(from->SubnetMask, to->SubnetMask,
+		    sizeof(from->SubnetMask));
+		memcpy(from->RES6, to->RES6, sizeof(from->RES6));
+		memcpy(from->GatewayIPAddr, to->GatewayIPAddr,
+		    sizeof(from->GatewayIPAddr));
+		memcpy(from->RES7, to->RES7, sizeof(from->RES7));
+		memcpy(from->PriDNSIPAddr, to->PriDNSIPAddr,
+		    sizeof(from->PriDNSIPAddr));
+		memcpy(from->SecDNSIPAddr, to->SecDNSIPAddr,
+		    sizeof(from->SecDNSIPAddr));
+		memcpy(from->RES8, to->RES8, sizeof(from->RES8));
+		memcpy(from->Alias, to->Alias, sizeof(from->Alias));
+		memcpy(from->TargAddr, to->TargAddr, sizeof(from->TargAddr));
+		memcpy(from->CHAPNameSecretsTable, to->CHAPNameSecretsTable,
+		    sizeof(from->CHAPNameSecretsTable));
+		memcpy(from->EthernetMACAddr, to->EthernetMACAddr,
+		    sizeof(from->EthernetMACAddr));
+		from->TargetPortalGroup = cpu_to_le16(to->TargetPortalGroup);
+		from->SendScale         = to->SendScale;
+		from->RecvScale         = to->RecvScale;
+		from->TypeOfService     = to->TypeOfService;
+		from->Time2Live         = to->Time2Live;
+		from->VLANPriority      = cpu_to_le16(to->VLANPriority);
+		from->Reserved8         = cpu_to_le16(to->Reserved8);
+		memcpy(from->SecIPAddr, to->SecIPAddr, sizeof(from->SecIPAddr));
+		memcpy(from->Reserved9, to->Reserved9, sizeof(from->Reserved9));
+		memcpy(from->iSNSIPAddr, to->iSNSIPAddr,
+		    sizeof(from->iSNSIPAddr));
+		memcpy(from->Reserved10, to->Reserved10,
+		    sizeof(from->Reserved10));
+		from->iSNSClientPortNumber =
+		    cpu_to_le16(to->iSNSClientPortNumber);
+		from->iSNSServerPortNumber =
+		    cpu_to_le16(to->iSNSServerPortNumber);
+		from->iSNSSCNPortNumber = cpu_to_le16(to->iSNSSCNPortNumber);
+		from->iSNSESIPortNumber = cpu_to_le16(to->iSNSESIPortNumber);
+		memcpy(from->SLPDAIPAddr, to->SLPDAIPAddr,
+		    sizeof(from->SLPDAIPAddr));
+		memcpy(from->Reserved11, to->Reserved11,
+		    sizeof(from->Reserved11));
+		memcpy(from->iSCSINameString, to->iSCSINameString,
+		    sizeof(from->iSCSINameString));
+		break;
+	}
+}
+
+static void
+__xlate_dev_db(DEV_DB_ENTRY *from, DEV_DB_ENTRY *to,
+    uint8_t direction)
+{
+	switch (direction) {
+	case GET_DATA:
+		from->options           = to->options;
+		from->control           = to->control;
+		from->exeThrottle       = le16_to_cpu(to->exeThrottle);
+		from->exeCount          = le16_to_cpu(to->exeCount);
+		from->retryCount        = to->retryCount;
+		from->retryDelay        = to->retryDelay;
+		from->iSCSIOptions      = le16_to_cpu(to->iSCSIOptions);
+		from->TCPOptions        = le16_to_cpu(to->TCPOptions);
+		from->IPOptions         = le16_to_cpu(to->IPOptions);
+		from->maxPDUSize        = le16_to_cpu(to->maxPDUSize);
+		from->rcvMarkerInt      = le16_to_cpu(to->rcvMarkerInt);
+		from->sndMarkerInt      = le16_to_cpu(to->sndMarkerInt);
+		from->iSCSIMaxSndDataSegLen =
+		    le16_to_cpu(to->iSCSIMaxSndDataSegLen);
+		from->firstBurstSize    = le16_to_cpu(to->firstBurstSize);
+		from->minTime2Wait      = le16_to_cpu(to->minTime2Wait);
+		from->maxTime2Retain    = le16_to_cpu(to->maxTime2Retain);
+		from->maxOutstndngR2T   = le16_to_cpu(to->maxOutstndngR2T);
+		from->keepAliveTimeout  = le16_to_cpu(to->keepAliveTimeout);
+		memcpy(from->ISID, to->ISID, sizeof(from->ISID));
+		from->TSID              = le16_to_cpu(to->TSID);
+		from->portNumber        = le16_to_cpu(to->portNumber);
+		from->maxBurstSize      = le16_to_cpu(to->maxBurstSize);
+		from->taskMngmntTimeout = le16_to_cpu(to->taskMngmntTimeout);
+		from->reserved1         = le16_to_cpu(to->reserved1);
+		memcpy(from->ipAddr, to->ipAddr, sizeof(from->ipAddr));
+		memcpy(from->iSCSIAlias, to->iSCSIAlias,
+		    sizeof(from->iSCSIAlias));
+		memcpy(from->targetAddr, to->targetAddr,
+		    sizeof(from->targetAddr));
+		memcpy(from->userID, to->userID, sizeof(from->userID));
+		memcpy(from->password, to->password, sizeof(from->password));
+		memcpy(from->iscsiName, to->iscsiName, sizeof(from->iscsiName));
+		from->ddbLink           = le16_to_cpu(to->ddbLink);
+		from->CHAPTableIndex    = le16_to_cpu(to->CHAPTableIndex);
+		memcpy(from->reserved2, to->reserved2, sizeof(from->reserved2));
+		from->Cookie            = le16_to_cpu(to->Cookie);
+		break;
+
+	case SET_DATA:
+		from->options           = to->options;
+		from->control           = to->control;
+		from->exeThrottle       = cpu_to_le16(to->exeThrottle);
+		from->exeCount          = cpu_to_le16(to->exeCount);
+		from->retryCount        = to->retryCount;
+		from->retryDelay        = to->retryDelay;
+		from->iSCSIOptions      = cpu_to_le16(to->iSCSIOptions);
+		from->TCPOptions        = cpu_to_le16(to->TCPOptions);
+		from->IPOptions         = cpu_to_le16(to->IPOptions);
+		from->maxPDUSize        = cpu_to_le16(to->maxPDUSize);
+		from->rcvMarkerInt      = cpu_to_le16(to->rcvMarkerInt);
+		from->sndMarkerInt      = cpu_to_le16(to->sndMarkerInt);
+		from->iSCSIMaxSndDataSegLen =
+		    cpu_to_le16(to->iSCSIMaxSndDataSegLen);
+		from->firstBurstSize    = cpu_to_le16(to->firstBurstSize);
+		from->minTime2Wait      = cpu_to_le16(to->minTime2Wait);
+		from->maxTime2Retain    = cpu_to_le16(to->maxTime2Retain);
+		from->maxOutstndngR2T   = cpu_to_le16(to->maxOutstndngR2T);
+		from->keepAliveTimeout  = cpu_to_le16(to->keepAliveTimeout);
+		memcpy(from->ISID, to->ISID, sizeof(from->ISID));
+		from->TSID              = cpu_to_le16(to->TSID);
+		from->portNumber        = cpu_to_le16(to->portNumber);
+		from->maxBurstSize      = cpu_to_le16(to->maxBurstSize);
+		from->taskMngmntTimeout = cpu_to_le16(to->taskMngmntTimeout);
+		from->reserved1         = cpu_to_le16(to->reserved1);
+		memcpy(from->ipAddr, to->ipAddr, sizeof(from->ipAddr));
+		memcpy(from->iSCSIAlias, to->iSCSIAlias,
+		    sizeof(from->iSCSIAlias));
+		memcpy(from->targetAddr, to->targetAddr,
+		    sizeof(from->targetAddr));
+		memcpy(from->userID, to->userID, sizeof(from->userID));
+		memcpy(from->password, to->password, sizeof(from->password));
+		memcpy(from->iscsiName, to->iscsiName, sizeof(from->iscsiName));
+		from->ddbLink           = cpu_to_le16(to->ddbLink);
+		from->CHAPTableIndex    = cpu_to_le16(to->CHAPTableIndex);
+		memcpy(from->reserved2, to->reserved2, sizeof(from->reserved2));
+		from->Cookie            = cpu_to_le16(to->Cookie);
+		break;
+	}
+}
+
+static void
+__xlate_chap(CHAP_ENTRY *from, CHAP_ENTRY *to, uint8_t direction)
+{
+	switch (direction) {
+	case GET_DATA:
+		from->link              = le16_to_cpu(to->link);
+		from->flags             = to->flags;
+		from->secretLength      = to->secretLength;
+		memcpy(from->secret, to->secret, sizeof(from->secret));
+		memcpy(from->user_name, to->user_name, sizeof(from->user_name));
+		from->reserved          = le16_to_cpu(to->reserved);
+		from->cookie            = le16_to_cpu(to->cookie);
+		break;
+
+	case SET_DATA:
+		from->link              = cpu_to_le16(to->link);
+		from->flags             = to->flags;
+		from->secretLength      = to->secretLength;
+		memcpy(from->secret, to->secret, sizeof(from->secret));
+		memcpy(from->user_name, to->user_name, sizeof(from->user_name));
+		from->reserved          = cpu_to_le16(to->reserved);
+		from->cookie            = cpu_to_le16(to->cookie);
+		break;
+	}
+}
+#endif
+
+/**************************************************************************
+ * qla4intioctl_get_flash
+ *	This routine reads the requested area of FLASH.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4intioctl_get_flash(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	void		*local_dma_bufv = NULL;
+	dma_addr_t	local_dma_bufp;
+	INT_ACCESS_FLASH *paccess_flash = NULL;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	/*
+	 * Allocate local flash buffer
+	 */
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&paccess_flash,
+	    sizeof(INT_ACCESS_FLASH))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(INT_ACCESS_FLASH)));
+		goto exit_get_flash;
+	}
+
+	/*
+	 * Copy user's data to local flash buffer
+	 */
+	if ((status = copy_from_user((uint8_t *)paccess_flash,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), sizeof(INT_ACCESS_FLASH))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_flash;
+	}
+
+	/*
+	 * Allocate DMA memory
+	 */
+	local_dma_bufv = pci_alloc_consistent(ha->pdev, paccess_flash->DataLen,
+	    &local_dma_bufp);
+	if (local_dma_bufv == NULL) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to allocate dma memory\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		goto exit_get_flash;
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: offset=%08x, len=%08x\n",
+	    ha->host_no, __func__,
+	    paccess_flash->DataOffset, paccess_flash->DataLen));
+
+	/*
+	 * Issue Mailbox Command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(local_dma_bufp);
+	mbox_cmd[2] = MSDW(local_dma_bufp);
+	mbox_cmd[3] = paccess_flash->DataOffset;
+	mbox_cmd[4] = paccess_flash->DataLen;
+
+	if (qla4xxx_mailbox_command(ha, 5, 2, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_flash;
+	}
+
+	//FIXME: For byte-order support, this entire structure must be translated
+#if BYTE_ORDER_SUPPORT_ENABLED
+	/*
+	 * Copy data from DMA buffer into access_flash->FlashData buffer
+	 * (in the process, translating for byte-order support, if necessary)
+	 */
+	switch (paccess_flash->DataOffset & INT_ISCSI_PAGE_MASK) {
+	case INT_ISCSI_FW_IMAGE2_FLASH_OFFSET:
+	case INT_ISCSI_FW_IMAGE1_FLASH_OFFSET:
+		break;
+	case INT_ISCSI_SYSINFO_FLASH_OFFSET:
+		__xlate_sys_info((FLASH_SYS_INFO *) local_dma_bufv,
+		    (FLASH_SYS_INFO *) &paccess_flash->FlashData[0],
+		    ioctl->SubCode);
+		break;
+	case INT_ISCSI_DRIVER_FLASH_OFFSET:
+		__xlate_driver_info((INT_FLASH_DRIVER_PARAM *) local_dma_bufv,
+		    (INT_FLASH_DRIVER_PARAM *) &paccess_flash->FlashData[0],
+		    ioctl->SubCode);
+		break;
+	case INT_ISCSI_INITFW_FLASH_OFFSET:
+		__xlate_init_fw_ctrl_blk((INIT_FW_CTRL_BLK *) local_dma_bufv,
+		    (INIT_FW_CTRL_BLK *) &paccess_flash->FlashData[0],
+		    ioctl->SubCode);
+		break;
+	case INT_ISCSI_DDB_FLASH_OFFSET:
+		__xlate_dev_db((DEV_DB_ENTRY *)local_dma_bufv,
+		    (DEV_DB_ENTRY *) &paccess_flash->FlashData[0],
+		    ioctl->SubCode);
+		break;
+	case INT_ISCSI_CHAP_FLASH_OFFSET:
+		__xlate_chap((CHAP_ENTRY *) local_dma_bufv,
+		    (CHAP_ENTRY *) &paccess_flash->FlashData[0],
+		    ioctl->SubCode);
+		break;
+	}
+#else
+	memcpy(&paccess_flash->FlashData[0], local_dma_bufv,
+	    MIN(paccess_flash->DataLen, sizeof(paccess_flash->FlashData)));
+
+#endif
+
+	/*
+	 * Copy local DMA buffer to user's response data area
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    paccess_flash, sizeof(*paccess_flash))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_flash;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+	ioctl->ResponseLen = paccess_flash->DataLen;
+
+	QL4PRINT(QLP4|QLP10,
+	    printk("INT_ACCESS_FLASH buffer (1st 60h bytes only):\n"));
+	qla4xxx_dump_bytes(QLP4|QLP10, paccess_flash, 0x60);
+
+exit_get_flash:
+
+	if (local_dma_bufv)
+		pci_free_consistent(ha->pdev,
+		    paccess_flash->DataLen, local_dma_bufv, local_dma_bufp);
+
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4intioctl_get_driver_debug_level
+ *	This routine retrieves the driver's debug print level.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4intioctl_get_driver_debug_level(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	uint32_t dbg_level;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_debug_level(&dbg_level) == QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to set debug level, "
+		    "debug driver not loaded!\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		goto exit_get_driver_debug_level;
+	}
+
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    &dbg_level, sizeof(dbg_level))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: failed to copy data\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_driver_debug_level;
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: debug level is %04x\n",
+	    ha->host_no, __func__, dbg_level));
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_get_driver_debug_level:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4intioctl_get_host_no
+ *	This routine retrieves the host number for the specified adapter
+ *	instance.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4intioctl_get_host_no(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    &(ha->host_no), sizeof(ha->host_no))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: failed to copy data\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	} else {
+		ioctl->Status = EXT_STATUS_OK;
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4intioctl_get_data
+ *	This routine calls get data IOCTLs based on the IOCTL Sub Code.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *    	-EINVAL     = if the command is invalid
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4intioctl_get_data(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int	status = 0;
+
+	switch (ioctl->SubCode) {
+	case INT_SC_GET_FLASH:
+		status = qla4intioctl_get_flash(ha, ioctl);
+		break;
+	case INT_SC_GET_DRIVER_DEBUG_LEVEL:
+		status = qla4intioctl_get_driver_debug_level(ha, ioctl);
+		break;
+	case INT_SC_GET_HOST_NO:
+		status = qla4intioctl_get_host_no(ha, ioctl);
+		break;
+	default:
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unsupported internal get data "
+		    "sub-command code (%X)\n",
+		    ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		break;
+	}
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4intioctl_set_flash
+ *	This routine writes the requested area of FLASH.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4intioctl_set_flash(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	INT_ACCESS_FLASH *paccess_flash;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	/*
+	 * Allocate local flash buffer
+	 */
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&paccess_flash,
+	    sizeof(INT_ACCESS_FLASH))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(INT_ACCESS_FLASH)));
+		goto exit_set_flash;
+	}
+
+	/*
+	 * Copy user's data to local DMA buffer
+	 */
+	if ((status = copy_from_user((uint8_t *)paccess_flash,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), sizeof(INT_ACCESS_FLASH))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_flash;
+	}
+
+	/*
+	 * Resizr IOCTL DMA memory, if necesary
+	 */
+	if ((paccess_flash->DataLen != 0) &&
+	    (ha->ioctl_dma_buf_len < paccess_flash->DataLen)) {
+		if (qla4xxx_resize_ioctl_dma_buf(ha, paccess_flash->DataLen) !=
+		    QLA_SUCCESS) {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: unable to allocate memory "
+			    "for dma buffer.\n",
+			    ha->host_no, __func__));
+			ioctl->Status = EXT_STATUS_NO_MEMORY;
+			goto exit_set_flash;
+		}
+	}
+
+	//FIXME: For byte-order support, this entire structure must be translated
+#if BYTE_ORDER_SUPPORT_ENABLED
+	/*
+	 * Copy data from DMA buffer into access_flash->FlashData buffer
+	 * (in the process, translating for byte-order support, if necessary)
+	 */
+	switch (paccess_flash->DataOffset & INT_ISCSI_PAGE_MASK) {
+	case INT_ISCSI_FW_IMAGE2_FLASH_OFFSET:
+	case INT_ISCSI_FW_IMAGE1_FLASH_OFFSET:
+		break;
+	case INT_ISCSI_SYSINFO_FLASH_OFFSET:
+		__xlate_sys_info((FLASH_SYS_INFO *)&paccess_flash->FlashData[0],
+		    (FLASH_SYS_INFO *) ha->ioctl_dma_bufv, SET_DATA);
+		break;
+	case INT_ISCSI_DRIVER_FLASH_OFFSET:
+		__xlate_driver_info(
+		    (INT_FLASH_DRIVER_PARAM *) &paccess_flash->FlashData[0],
+		    (INT_FLASH_DRIVER_PARAM *) ha->ioctl_dma_bufv,
+		    SET_DATA);
+		break;
+	case INT_ISCSI_INITFW_FLASH_OFFSET:
+		__xlate_init_fw_ctrl_blk(
+		    (INIT_FW_CTRL_BLK *) &paccess_flash->FlashData[0],
+		    (INIT_FW_CTRL_BLK *) ha->ioctl_dma_bufv, SET_DATA);
+		break;
+	case INT_ISCSI_DDB_FLASH_OFFSET:
+		__xlate_dev_db((DEV_DB_ENTRY *) &paccess_flash->FlashData[0],
+		    (DEV_DB_ENTRY *) ha->ioctl_dma_bufv, SET_DATA);
+		break;
+	case INT_ISCSI_CHAP_FLASH_OFFSET:
+		__xlate_chap((CHAP_ENTRY *) &paccess_flash->FlashData[0],
+		    (CHAP_ENTRY *) ha->ioctl_dma_bufv, SET_DATA);
+		break;
+	}
+#else
+	memcpy(ha->ioctl_dma_bufv, &paccess_flash->FlashData[0],
+	    MIN(ha->ioctl_dma_buf_len, sizeof(paccess_flash->FlashData)));
+
+#endif
+
+	/*
+	 * Issue Mailbox Command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_WRITE_FLASH;
+	mbox_cmd[1] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[2] = MSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = paccess_flash->DataOffset;
+	mbox_cmd[4] = paccess_flash->DataLen;
+	mbox_cmd[5] = paccess_flash->Options;
+
+	if (qla4xxx_mailbox_command(ha, 6, 2, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		ioctl->VendorSpecificStatus[0] = mbox_sts[1];
+		goto exit_set_flash;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+	ioctl->ResponseLen = paccess_flash->DataLen;
+	QL4PRINT(QLP4|QLP10,
+	    printk("scsi%d): INT_ACCESS_FLASH buffer (1st 60h bytes only:\n",
+	    ha->host_no));
+	qla4xxx_dump_bytes(QLP4|QLP10, ha->ioctl_dma_bufv, 0x60);
+
+exit_set_flash:
+	/*
+	 * Free Memory
+	 */
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4intioctl_set_driver_debug_level
+ *	This routine sets the driver's debug print level.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4intioctl_set_driver_debug_level(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	uint32_t dbg_level;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if ((status = copy_from_user(&dbg_level,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), sizeof(dbg_level))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: failed to copy data\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_driver_debug_level;
+	}
+
+	if (qla4xxx_set_debug_level(dbg_level) == QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to set debug level, "
+		    "debug driver not loaded!\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		goto exit_set_driver_debug_level;
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: debug level set to 0x%04X\n",
+	    ha->host_no, __func__, dbg_level));
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_set_driver_debug_level:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4intioctl_set_data
+ *	This routine calls set data IOCTLs based on the IOCTL Sub Code.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *    	-EINVAL     = if the command is invalid
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4intioctl_set_data(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int	status = 0;
+
+	switch (ioctl->SubCode) {
+	case INT_SC_SET_FLASH:
+		status = qla4intioctl_set_flash(ha, ioctl);
+		break;
+	case INT_SC_SET_DRIVER_DEBUG_LEVEL:
+		status = qla4intioctl_set_driver_debug_level(ha, ioctl);
+		break;
+	default:
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: unsupported internal set data "
+				"sub-command code (%X)\n",
+				ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		break;
+	}
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4intioctl_hba_reset
+ *	This routine resets the specified HBA.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4intioctl_hba_reset(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	uint8_t		status = 0;
+	u_long		wait_count;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	switch (ioctl->SubCode) {
+	case INT_SC_HBA_RESET:
+	case INT_SC_FIRMWARE_RESET:
+		set_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags);
+
+		/* Wait a fixed amount of time for reset to complete */
+		wait_count = jiffies + ADAPTER_RESET_TOV * HZ;
+		while (test_bit(DPC_RESET_HA_DESTROY_DDB_LIST,
+		    &ha->dpc_flags) != 0) {
+			if (wait_count <= jiffies)
+				break;
+
+			/* wait for 1 second */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1*HZ);
+		}
+
+		if (test_bit(AF_ONLINE, &ha->flags)) {
+			QL4PRINT(QLP4, printk("scsi%d: %s: Succeeded\n",
+			    ha->host_no, __func__));
+			ioctl->Status = EXT_STATUS_OK;
+		} else {
+			QL4PRINT(QLP2|QLP4, printk("scsi%d: %s: FAILED\n",
+			    ha->host_no, __func__));
+			ioctl->Status = EXT_STATUS_ERR;
+		}
+
+		break;
+
+	case INT_SC_TARGET_WARM_RESET:
+	case INT_SC_LUN_RESET:
+	default:
+		QL4PRINT(QLP2|QLP4, printk("scsi%d: %s: not supported.\n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		break;
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4intioctl_copy_fw_flash
+ *	This routine requests copying the FW image in FLASH from primary-to-
+ *	secondary or secondary-to-primary.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4intioctl_copy_fw_flash(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	INT_COPY_FW_FLASH copy_flash;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if ((status = copy_from_user((uint8_t *)&copy_flash,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), ioctl->RequestLen)) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_copy_flash;
+	}
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_COPY_FLASH;
+	mbox_cmd[1] = copy_flash.Options;
+
+	if (qla4xxx_mailbox_command(ha, 2, 2, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP4|QLP10,
+		    printk("scsi%d: %s: Succeeded\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_OK;
+	} else {
+		QL4PRINT(QLP4|QLP10,
+		    printk("scsi%d: %s: FAILED\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		ioctl->VendorSpecificStatus[0] = mbox_sts[1];
+	}
+
+exit_copy_flash:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_iocb_pass_done
+ *	This routine resets the ioctl progress flag and wakes up the ioctl
+ * 	completion semaphore.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *   	sts_entry - pointer to passthru status buffer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_iocb_pass_done(scsi_qla_host_t *ha, PASSTHRU_STATUS_ENTRY *sts_entry)
+{
+	INT_IOCB_PASSTHRU *iocb;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	/* --- Copy passthru status buffer to iocb passthru buffer ---*/
+	iocb = (INT_IOCB_PASSTHRU *)(ulong)le32_to_cpu(sts_entry->handle);
+	memcpy(iocb->IOCBStatusBuffer, sts_entry,
+	    MIN(sizeof(iocb->IOCBStatusBuffer), sizeof(*sts_entry)));
+
+	/* --- Reset IOCTL flags and wakeup semaphore.
+	 *     But first check to see if IOCTL has already
+	 *     timed out because we don't want to get the
+	 *     up/down semaphore counters off.             --- */
+	if (ha->ioctl->ioctl_iocb_pass_in_progress == 1) {
+		ha->ioctl->ioctl_iocb_pass_in_progress = 0;
+		ha->ioctl->ioctl_tov = 0;
+
+		QL4PRINT(QLP4|QLP10,
+		    printk("%s: UP count=%d\n", __func__,
+		    atomic_read(&ha->ioctl->ioctl_cmpl_sem.count)));
+		up(&ha->ioctl->ioctl_cmpl_sem);
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return;
+}
+
+/**************************************************************************
+ * qla4intioctl_iocb_passthru
+ *	This routine
+ *	
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4intioctl_iocb_passthru(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	INT_IOCB_PASSTHRU	*iocb;
+	INT_IOCB_PASSTHRU	*iocb_dma;
+	PASSTHRU0_ENTRY		*passthru_entry;
+	unsigned long		flags;
+	DATA_SEG_A64		*data_seg;
+
+
+	ENTER("qla4intioctl_iocb_passthru");
+	QL4PRINT(QLP3, printk("scsi%d: %s:\n", ha->host_no, __func__));
+
+	/* --- Use internal DMA buffer for iocb structure --- */
+
+	if (ha->ioctl_dma_buf_len < sizeof(*iocb))
+		qla4xxx_resize_ioctl_dma_buf(ha, sizeof(*iocb));
+
+	if (!ha->ioctl_dma_bufv || ha->ioctl_dma_buf_len < sizeof(*iocb)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: dma buffer inaccessible.\n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_iocb_passthru;
+	}
+
+	iocb = (INT_IOCB_PASSTHRU *) ha->ioctl_dma_bufv;
+	iocb_dma = (INT_IOCB_PASSTHRU *)(unsigned long)ha->ioctl_dma_bufp;
+
+	/* --- Copy IOCB_PASSTHRU structure from user space --- */
+	if ((status = copy_from_user((uint8_t *)iocb,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), ioctl->RequestLen)) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_iocb_passthru;
+	}
+
+
+	/* --- Get pointer to the passthru queue entry --- */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &passthru_entry) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: request queue full, try again later\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_HBA_QUEUE_FULL;
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		goto exit_iocb_passthru;
+	}
+
+	/* --- Fill in passthru queue entry --- */
+	if (iocb->SendDMAOffset) {
+		data_seg = (DATA_SEG_A64 *)(iocb->IOCBCmdBuffer +
+		    iocb->SendDMAOffset);
+		data_seg->base.addrHigh =
+		    cpu_to_le32(MSDW((ulong)&iocb_dma->SendData[0]));
+		data_seg->base.addrLow =
+		    cpu_to_le32(LSDW((ulong)&iocb_dma->SendData[0]));
+	}
+
+	if (iocb->RspDMAOffset) {
+		data_seg =
+		    (DATA_SEG_A64 *)(iocb->IOCBCmdBuffer + iocb->RspDMAOffset);
+		data_seg->base.addrHigh =
+		    cpu_to_le32(MSDW((ulong)&iocb_dma->RspData[0]));
+		data_seg->base.addrLow =
+		    cpu_to_le32(LSDW((ulong)&iocb_dma->RspData[0]));
+	}
+
+	memcpy(passthru_entry, iocb->IOCBCmdBuffer,
+	    MIN(sizeof(*passthru_entry), sizeof(iocb->IOCBCmdBuffer)));
+	passthru_entry->handle = (uint32_t) (unsigned long) iocb;
+	passthru_entry->hdr.systemDefined = SD_PASSTHRU_IOCB;
+
+	if (passthru_entry->hdr.entryType != ET_PASSTHRU0)
+		passthru_entry->timeout = MBOX_TOV;
+
+	QL4PRINT(QLP4|QLP10,
+	    printk(KERN_INFO
+	    "scsi%d: Passthru0 IOCB type %x count %x In (%x) %p\n",
+	    ha->host_no, passthru_entry->hdr.entryType,
+	    passthru_entry->hdr.entryCount, ha->request_in, passthru_entry));
+
+	QL4PRINT(QLP4|QLP10,
+	    printk(KERN_INFO "scsi%d: Dump Passthru entry %p: \n",
+	    ha->host_no, passthru_entry));
+	qla4xxx_dump_bytes(QLP4|QLP10, passthru_entry, sizeof(*passthru_entry));
+
+	/* ---- Prepare for receiving completion ---- */
+	ha->ioctl->ioctl_iocb_pass_in_progress = 1;
+	ha->ioctl->ioctl_tov = passthru_entry->timeout * HZ;
+	qla4xxx_ioctl_sem_init(ha);
+
+	/* ---- Send command to adapter ---- */
+	ha->ioctl->ioctl_cmpl_timer.expires = jiffies + ha->ioctl->ioctl_tov;
+	add_timer(&ha->ioctl->ioctl_cmpl_timer);
+
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	QL4PRINT(QLP4|QLP10, printk("%s: DOWN count=%d\n",
+	    __func__, atomic_read(&ha->ioctl->ioctl_cmpl_sem.count)));
+
+	down(&ha->ioctl->ioctl_cmpl_sem);
+
+	/*******************************************************
+	 *						       *
+	 *             Passthru Completion                     *
+	 *						       *
+	 *******************************************************/
+	del_timer(&ha->ioctl->ioctl_cmpl_timer);
+
+	/* ---- Check for timeout --- */
+	if (ha->ioctl->ioctl_iocb_pass_in_progress == 1) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: ERROR = command timeout.\n",
+		    ha->host_no, __func__));
+
+		ha->ioctl->ioctl_iocb_pass_in_progress = 0;
+		ioctl->Status = EXT_STATUS_ERR;
+		goto exit_iocb_passthru;
+	}
+
+	/* ---- Copy IOCB Passthru structure with updated status buffer
+	 *      to user space ---- */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    iocb, sizeof(INT_IOCB_PASSTHRU))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy passthru struct "
+		    "to user's memory area.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_iocb_passthru;
+	}
+
+	QL4PRINT(QLP4|QLP10, printk("Dump iocb structure (OUT)\n"));
+	qla4xxx_print_iocb_passthru(QLP4|QLP10, ha, iocb);
+
+	QL4PRINT(QLP4, printk("scsi%d: %s: Succeeded\n",
+	    ha->host_no, __func__));
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_iocb_passthru:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_resize_ioctl_dma_buf
+ *	This routine deallocates the dma_buf of the previous size and re-
+ *	allocates the dma_buf with the given size.
+ *
+ * Input:
+ *	ha      - Pointer to host adapter structure
+ *	size    - Size of dma buffer to allocate
+ *
+ * Output:
+ *	dma_buf - virt_addr, phys_addr, and buf_len values filled in
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully re-allocates memory
+ *	QLA_ERROR   - Failed to re-allocate memory
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_resize_ioctl_dma_buf(scsi_qla_host_t *ha, uint32_t size)
+{
+	uint8_t status = 0;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (ha->ioctl_dma_buf_len) {
+		QL4PRINT(QLP3|QLP4,
+		    printk("scsi%d: %s: deallocate old dma_buf, size=0x%x\n",
+		    ha->host_no, __func__, ha->ioctl_dma_buf_len));
+		pci_free_consistent(ha->pdev, ha->ioctl_dma_buf_len,
+		    ha->ioctl_dma_bufv, ha->ioctl_dma_bufp);
+		ha->ioctl_dma_buf_len = 0;
+		ha->ioctl_dma_bufv = 0;
+		ha->ioctl_dma_bufp = 0;
+	}
+
+	QL4PRINT(QLP3|QLP4,
+	    printk("scsi%d: %s: allocate new ioctl_dma_buf, size=0x%x\n",
+	    ha->host_no, __func__, size));
+	
+	ha->ioctl_dma_bufv = pci_alloc_consistent(ha->pdev, size,
+	    &ha->ioctl_dma_bufp);
+	if (ha->ioctl_dma_bufv == NULL) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: ERROR allocating new ioctl_dma_buf, "
+		    "size=0x%x\n", ha->host_no, __func__, size));
+	} else {
+		ha->ioctl_dma_buf_len = size;
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_init.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_init.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_init.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,2938 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *      qla4xxx_alloc_dma_memory
+ *      qla4xxx_free_dma_memory
+ *      qla4xxx_free_lun
+ *      qla4xxx_free_ddb
+ *      qla4xxx_free_ddb_list
+ *      qla4xxx_init_rings
+ *      qla4xxx_validate_mac_address
+ *	qla4xxx_init_local_data
+ *      qla4xxx_init_firmware
+ *      qla4xxx_send_internal_scsi_passthru
+ *      qla4xxx_send_inquiry_cmd
+ *      qla4xxx_send_report_luns_cmd
+ *	qla4xxx_is_discovered_target
+ *      qla4xxx_update_ddb_entry
+ *      qla4xxx_alloc_lun
+ *      qla4xxx_discover_target_luns
+ *      qla4xxx_map_targets_to_ddbs
+ *      qla4xxx_alloc_ddb
+ *      qla4xxx_build_ddb_list
+ *      qla4xxx_initialize_ddb_list
+ *      qla4xxx_reinitialize_ddb_list
+ *      qla4xxx_relogin_device
+ *	qla4xxx_get_topcat_presence
+ *	qla4xxx_start_firmware
+ *      qla4xxx_initialize_adapter
+ *      qla4xxx_find_propname
+ *      qla4xxx_get_prop_12chars
+ *	qla4xxx_add_device_dynamically
+ *	qla4xxx_process_ddb_changed
+ *	qla4xxx_login_device
+ *	qla4xxx_logout_device
+ *	qla4xxx_flush_all_srbs
+ *	qla4xxx_delete_device
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+#include <linux/delay.h>
+
+/*
+ *  External Function Prototypes.
+ */
+extern int ql4xdiscoverywait;
+extern char *ql4xdevconf;
+
+/*
+ * Local routines
+ */
+static fc_port_t *
+qla4xxx_find_or_alloc_fcport(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+static void qla4xxx_config_os(scsi_qla_host_t *ha);
+static uint16_t
+qla4xxx_fcport_bind(scsi_qla_host_t *ha, fc_port_t *fcport);
+os_lun_t *
+qla4xxx_fclun_bind(scsi_qla_host_t *ha, fc_port_t *fcport, fc_lun_t *fclun);
+os_tgt_t *
+qla4xxx_tgt_alloc(scsi_qla_host_t *ha, uint16_t tgt);
+void
+qla4xxx_tgt_free(scsi_qla_host_t *ha, uint16_t tgt);
+os_lun_t *
+qla4xxx_lun_alloc(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun);
+static void
+qla4xxx_lun_free(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun);
+fc_lun_t *
+qla4xxx_add_fclun(fc_port_t *fcport, uint16_t lun);
+static ddb_entry_t *
+qla4xxx_get_ddb_entry(scsi_qla_host_t *ha, uint32_t fw_ddb_index);
+
+/**
+ * qla4xxx_alloc_fcport() - Allocate a generic fcport.
+ * @ha: HA context
+ * @flags: allocation flags
+ *
+ * Returns a pointer to the allocated fcport, or NULL, if none available.
+ */
+static fc_port_t *
+qla4xxx_alloc_fcport(scsi_qla_host_t *ha, int flags)
+{
+	fc_port_t *fcport;
+
+	fcport = kmalloc(sizeof(fc_port_t), flags);
+	if (fcport == NULL)
+		return(fcport);
+
+	/* Setup fcport template structure. */
+	memset(fcport, 0, sizeof (fc_port_t));
+	fcport->ha = ha;
+	fcport->port_type = FCT_UNKNOWN;
+	atomic_set(&fcport->state, FCS_DEVICE_DEAD);
+	fcport->flags = FCF_RLC_SUPPORT;
+	INIT_LIST_HEAD(&fcport->fcluns);
+
+	return(fcport);
+}
+
+/*
+* qla4xxx_init_tgt_map
+*      Initializes target map.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Output:
+*      TGT_Q initialized
+*/
+static void
+qla4xxx_init_tgt_map(scsi_qla_host_t *ha)
+{
+	uint32_t t;
+
+	ENTER(__func__);
+
+	for (t = 0; t < MAX_TARGETS; t++)
+		TGT_Q(ha, t) = (os_tgt_t *) NULL;
+
+	LEAVE(__func__);
+}
+
+
+
+
+/*
+ * qla4xxx_update_fcport
+ *	Updates device on list.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fcport = port structure pointer.
+ *
+ * Return:
+ *	0  - Success
+ *  BIT_0 - error
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla4xxx_update_fcport(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+#if 0
+	uint16_t        index;
+	unsigned long flags;
+	srb_t *sp;
+#endif
+
+	if (fcport == NULL)
+		return;
+
+	ENTER(__func__);
+	fcport->ha = ha;
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	fcport->flags &= ~(FCF_FAILOVER_NEEDED);
+#endif
+	/* XXX need to get this info from option field of DDB entry */ 
+	fcport->port_type = FCT_TARGET;
+	fcport->iscsi_name = fcport->ddbptr->iscsi_name;
+
+	/*
+	 * Check for outstanding cmd on tape Bypass LUN discovery if active
+	 * command on tape.
+	 */
+#if 0
+	if (fcport->flags & FCF_TAPE_PRESENT) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		for (index = 1; index < MAX_OUTSTANDING_COMMANDS; index++) {
+			if ((sp = ha->outstanding_cmds[index]) != 0) {
+				if (sp->fclun->fcport == fcport) {
+					atomic_set(&fcport->state, FCS_ONLINE);
+					spin_unlock_irqrestore(
+							      &ha->hardware_lock, flags);
+					return;
+				}
+			}
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+#endif
+
+	/* Do LUN discovery. */
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	qla4xxx_lun_discovery(ha, fcport);
+#endif
+
+	/* Always set online */
+	atomic_set(&fcport->state, FCS_ONLINE);
+	LEAVE(__func__);
+}
+
+
+
+/*
+ * qla4xxx_add_fclun
+ *	Adds LUN to database
+ *
+ * Input:
+ *	fcport:		FC port structure pointer.
+ *	lun:		LUN number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+fc_lun_t *
+qla4xxx_add_fclun(fc_port_t *fcport, uint16_t lun)
+{
+	int             found;
+	fc_lun_t        *fclun;
+
+	if (fcport == NULL) {
+		DEBUG2(printk("scsi: Unable to add lun to NULL port\n"));
+		return(NULL);
+	}
+
+	/* Allocate LUN if not already allocated. */
+	found = 0;
+	list_for_each_entry(fclun, &fcport->fcluns, list) {
+		if (fclun->lun == lun) {
+			found++;
+			break;
+		}
+	}
+	if (found) {
+		return(fclun);
+	}
+
+	fclun = kmalloc(sizeof(fc_lun_t), GFP_ATOMIC);
+	if (fclun == NULL) {
+		printk(KERN_WARNING
+		       "%s(): Memory Allocation failed - FCLUN\n",
+		       __func__);
+		return(NULL);
+	}
+
+	/* Setup LUN structure. */
+	memset(fclun, 0, sizeof(fc_lun_t));
+	fclun->lun = lun;
+	fclun->fcport = fcport;
+	fclun->device_type = fcport->device_type;
+	// atomic_set(&fcport->state, FCS_UNCONFIGURED);
+
+	list_add_tail(&fclun->list, &fcport->fcluns);
+
+	return(fclun);
+}
+
+
+
+
+/*
+ * qla4xxx_config_os
+ *	Setup OS target and LUN structures.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla4xxx_config_os(scsi_qla_host_t *ha)
+{
+	fc_port_t       *fcport;
+	fc_lun_t        *fclun;
+	os_tgt_t        *tq;
+	uint16_t        tgt;
+
+
+	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+		if ((tq = TGT_Q(ha, tgt)) == NULL)
+			continue;
+
+		tq->flags &= ~TQF_ONLINE;
+	}
+
+	list_for_each_entry(fcport, &ha->fcports, list)
+	{
+		if (atomic_read(&fcport->state) != FCS_ONLINE) {
+			fcport->os_target_id = MAX_TARGETS;
+			continue;
+		}
+
+		/* Bind FC port to OS target number. */
+		if (qla4xxx_fcport_bind(ha, fcport) == MAX_TARGETS) {
+			continue;
+		}
+
+		/* Bind FC LUN to OS LUN number. */
+		list_for_each_entry(fclun, &fcport->fcluns, list)
+		{
+			qla4xxx_fclun_bind(ha, fcport, fclun);
+		}
+	}
+}
+
+/*
+ * qla4xxx_fcport_bind
+ *	Locates a target number for FC port.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	fcport = FC port structure pointer.
+ *
+ * Returns:
+ *	target number
+ *
+ * Context:
+ *	Kernel context.
+ */
+static uint16_t
+qla4xxx_fcport_bind(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	uint16_t        tgt;
+	os_tgt_t        *tq = NULL;
+
+	if (fcport->ddbptr == NULL)
+		return (MAX_TARGETS);
+		
+	/* Check for persistent binding. */
+	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+		if ((tq = TGT_Q(ha, tgt)) == NULL)
+			continue;
+
+		if (memcmp(fcport->ddbptr->iscsi_name, tq->iscsi_name,
+			    ISCSI_NAME_SIZE) == 0) {
+				break;	
+		}
+	}
+	/* TODO: honor the ConfigRequired flag */
+	if (tgt == MAX_TARGETS) {
+	/* Check if targetID 0 available. */
+	tgt = 0;
+
+		/* Check if targetID 0 available. */
+	if (TGT_Q(ha, tgt) != NULL) {
+		/* Locate first free target for device. */
+		for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+			if (TGT_Q(ha, tgt) == NULL) {
+				break;
+			}
+		}
+	}
+	if (tgt != MAX_TARGETS) {
+		if ((tq = qla4xxx_tgt_alloc(ha, tgt)) != NULL) {
+				memcpy(tq->iscsi_name, fcport->ddbptr->iscsi_name,
+			    	ISCSI_NAME_SIZE);
+			}
+		}
+	}
+
+	/* Reset target numbers incase it changed. */
+	fcport->os_target_id = tgt;
+	if (tgt != MAX_TARGETS && tq != NULL) {
+		DEBUG3(printk("scsi(%d): Assigning target ID=%02d @ %p to "
+		    "loop id=0x%04x, port state=0x%x, port down retry=%d\n",
+		    ha->host_no, tgt, tq, fcport->loop_id,
+		    atomic_read(&fcport->state),
+		    atomic_read(&fcport->ddbptr->port_down_timer)));
+
+		fcport->tgt_queue = tq;
+		fcport->flags |= FCF_PERSISTENT_BOUND;
+		tq->fcport = fcport;
+		tq->flags |= TQF_ONLINE;
+		tq->id = tgt;
+	}
+
+	if (tgt == MAX_TARGETS) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "Unable to bind fcport, loop_id=%x\n", fcport->loop_id));
+	}
+
+	return(tgt);
+}
+
+/*
+ * qla4xxx_fclun_bind
+ *	Binds all FC device LUNS to OS LUNS.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *
+ * Returns:
+ *	target number
+ *
+ * Context:
+ *	Kernel context.
+ */
+os_lun_t *
+qla4xxx_fclun_bind(scsi_qla_host_t *ha, fc_port_t *fcport, fc_lun_t *fclun)
+{
+	os_lun_t        *lq;
+	uint16_t        tgt;
+	uint16_t        lun;
+
+	tgt = fcport->os_target_id;
+	lun = fclun->lun;
+
+	/* Allocate LUNs */
+	if (lun >= MAX_LUNS) {
+		DEBUG2(printk("scsi%d: Unable to bind lun, invalid "
+			      "lun=(%x).\n", ha->host_no, lun));
+		return(NULL);
+	}
+
+	if ((lq = qla4xxx_lun_alloc(ha, tgt, lun)) == NULL) {
+		printk(KERN_WARNING "Unable to bind fclun, lun=%x\n",
+		       lun);
+		return(NULL);
+	}
+
+	lq->fclun = fclun;
+
+	return(lq);
+}
+
+/*
+ * qla4xxx_tgt_alloc
+ *	Allocate and pre-initialize target queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Returns:
+ *	NULL = failure
+ *
+ * Context:
+ *	Kernel context.
+ */
+os_tgt_t *
+qla4xxx_tgt_alloc(scsi_qla_host_t *ha, uint16_t tgt)
+{
+	os_tgt_t        *tq;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS) {
+		DEBUG2(printk("scsi%d: Unable to allocate target, invalid "
+			      "target number %d.\n", ha->host_no, tgt));
+		return(NULL);
+	}
+
+	tq = TGT_Q(ha, tgt);
+	if (tq == NULL) {
+		tq = kmalloc(sizeof(os_tgt_t), GFP_ATOMIC);
+		if (tq != NULL) {
+			DEBUG3(printk("scsi%d: Alloc Target %d @ %p\n",
+				      ha->host_no, tgt, tq));
+
+			memset(tq, 0, sizeof(os_tgt_t));
+			tq->ha = ha;
+
+			TGT_Q(ha, tgt) = tq;
+		}
+	}
+	if (tq != NULL) {
+		tq->port_down_retry_count = ha->port_down_retry_count;
+	}
+	else {
+		printk(KERN_WARNING "Unable to allocate target.\n");
+	}
+
+	return(tq);
+}
+
+/*
+ * qla4xxx_tgt_free
+ *	Frees target and LUN queues.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+void
+qla4xxx_tgt_free(scsi_qla_host_t *ha, uint16_t tgt)
+{
+	os_tgt_t        *tq;
+	uint16_t        lun;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS) {
+		DEBUG2(printk("scsi%d: Unable to de-allocate target, "
+			      "invalid target number %d.\n", ha->host_no, tgt));
+
+		return;
+	}
+
+	tq = TGT_Q(ha, tgt);
+	if (tq != NULL) {
+		TGT_Q(ha, tgt) = NULL;
+
+		/* Free LUN structures. */
+		for (lun = 0; lun < MAX_LUNS; lun++)
+			qla4xxx_lun_free(ha, tgt, lun);
+
+		kfree(tq);
+	}
+
+	return;
+}
+
+/*
+ * qla4xxx_lun_alloc
+ *	Allocate and initialize LUN queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *	l = LUN number.
+ *
+ * Returns:
+ *	NULL = failure
+ *
+ * Context:
+ *	Kernel context.
+ */
+os_lun_t *
+qla4xxx_lun_alloc(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun)
+{
+	os_lun_t        *lq;
+
+	/*
+	 * If SCSI addressing OK, allocate LUN queue.
+	 */
+	if (lun >= MAX_LUNS || TGT_Q(ha, tgt) == NULL) {
+		DEBUG2(printk("scsi%d: Unable to allocate lun, invalid "
+			      "parameter.\n", ha->host_no));
+
+		return(NULL);
+	}
+
+	lq = LUN_Q(ha, tgt, lun);
+	if (lq == NULL) {
+		lq = kmalloc(sizeof(os_lun_t), GFP_ATOMIC);
+		if (lq != NULL) {
+			DEBUG3(printk("scsi%d: Alloc Lun %d @ tgt %d.\n",
+				      ha->host_no, lun, tgt));
+
+			memset(lq, 0, sizeof (os_lun_t));
+			LUN_Q(ha, tgt, lun) = lq;
+
+			/*
+			 * The following lun queue initialization code
+			 * must be duplicated in alloc_ioctl_mem function
+			 * for ioctl_lq.
+			 */
+			lq->lun_state = LS_LUN_READY;
+			spin_lock_init(&lq->lun_lock);
+		}
+	}
+
+	if (lq == NULL) {
+		printk(KERN_WARNING "Unable to allocate lun.\n");
+	}
+
+	return(lq);
+}
+
+/*
+ * qla4xxx_lun_free
+ *	Frees LUN queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla4xxx_lun_free(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun)
+{
+	os_lun_t        *lq;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS || lun >= MAX_LUNS) {
+		DEBUG2(printk("scsi%d: Unable to deallocate lun, invalid "
+			      "parameter.\n", ha->host_no));
+
+		return;
+	}
+
+	if (TGT_Q(ha, tgt) != NULL && (lq = LUN_Q(ha, tgt, lun)) != NULL) {
+		LUN_Q(ha, tgt, lun) = NULL;
+		kfree(lq);
+	}
+
+	return;
+}
+
+/**************************************************************************
+ * qla4xxx_free_ddb
+ *	This routine deallocates and unlinks the specified ddb_entry from the
+ *	adapter's
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_free_ddb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	fc_port_t       *fcport;
+
+	ENTER("qla4xxx_free_ddb");
+
+	/* Remove device entry from list */
+	list_del_init(&ddb_entry->list_entry);
+
+	/* Remove device pointer from index mapping arrays */
+	ha->fw_ddb_index_map[ddb_entry->fw_ddb_index] = (ddb_entry_t *) INVALID_ENTRY;
+	//if (ddb_entry->target < MAX_DDB_ENTRIES)
+	//ha->target_map[ddb_entry->target] = (ddb_entry_t *) INVALID_ENTRY;
+	ha->tot_ddbs--;
+
+	fcport = ddb_entry->fcport;
+	if (fcport) {
+		atomic_set(&fcport->state, FCS_DEVICE_DEAD);
+		fcport->ddbptr = NULL;
+	}
+	/* Free memory allocated for all luns */
+	//for (lun = 0; lun < MAX_LUNS; lun++)
+	//if (ddb_entry->lun_table[lun])
+	//qla4xxx_free_lun(ddb_entry, lun);
+
+	/* Free memory for device entry */
+	kfree(ddb_entry);
+	LEAVE("qla4xxx_free_ddb");
+}
+
+/**************************************************************************
+ * qla4xxx_free_ddb_list
+ *	This routine deallocates and removes all devices on the sppecified
+ *	adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_free_ddb_list(scsi_qla_host_t *ha)
+{
+	struct list_head *ptr;
+	ddb_entry_t *ddb_entry;
+	fc_port_t       *fcport;
+
+	ENTER("qla4xxx_free_ddb_list");
+
+	while (!list_empty(&ha->ddb_list)) {
+		/* Remove device entry from head of list */
+		ptr = ha->ddb_list.next;
+		list_del_init(ptr);
+
+		/* Free memory for device entry */
+		ddb_entry = list_entry(ptr, ddb_entry_t, list_entry);
+		if (ddb_entry) {
+			fcport = ddb_entry->fcport;
+			if (fcport) {
+				atomic_set(&fcport->state, FCS_DEVICE_DEAD);
+				fcport->ddbptr = NULL;
+			}
+			kfree(ddb_entry);
+		}
+	}
+
+	LEAVE("qla4xxx_free_ddb_list");
+}
+
+/**************************************************************************
+ * qla4xxx_init_rings
+ *	This routine initializes the internal queues for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *	The QLA4010 requires us to restart the queues at index 0.
+ *	The QLA4000 doesn't care, so just default to QLA4010's requirement.
+ * Returns:
+ *	QLA_SUCCESS - Always return success.
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_init_rings(scsi_qla_host_t *ha)
+{
+	uint16_t    i;
+	unsigned long flags = 0;
+
+	ENTER("qla4xxx_init_rings");
+
+	/* Initialize request queue. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	ha->request_out = 0;
+	ha->request_in = 0;
+	ha->request_ptr = &ha->request_ring[ha->request_in];
+	ha->req_q_count = REQUEST_QUEUE_DEPTH;
+
+	/* Initialize response queue. */
+	ha->response_in = 0;
+	ha->response_out = 0;
+	ha->response_ptr = &ha->response_ring[ha->response_out];
+
+	QL4PRINT(QLP7, printk("scsi%d: %s response_ptr=%p\n", ha->host_no,
+	    __func__, ha->response_ptr));
+
+	/*
+	 * Initialize DMA Shadow registers.  The firmware is really supposed to
+	 * take care of this, but on some uniprocessor systems, the shadow
+	 * registers aren't cleared-- causing the interrupt_handler to think
+	 * there are responses to be processed when there aren't.
+	 */
+	ha->shadow_regs->req_q_out = __constant_cpu_to_le32(0);
+	ha->shadow_regs->rsp_q_in = __constant_cpu_to_le32(0);
+	wmb();
+
+	WRT_REG_DWORD(&ha->reg->req_q_in, 0);
+	WRT_REG_DWORD(&ha->reg->rsp_q_out, 0);
+	PCI_POSTING(&ha->reg->rsp_q_out);
+
+	/* Initialize active array */
+	for (i = 0; i < MAX_SRBS; i++)
+		ha->active_srb_array[i] = 0;
+	ha->active_srb_count = 0;
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_init_rings");
+
+	return (QLA_SUCCESS);
+}
+
+
+#define qla4xxx_mac_is_equal(mac1, mac2) (memcmp(mac1, mac2, MAC_ADDR_LEN) == 0)
+
+/**************************************************************************
+ * qla4xxx_validate_mac_address
+ *	This routine validates the M.A.C. Address(es) of the adapter
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully validated M.A.C. address
+ *	QLA_ERROR   - Failed to validate M.A.C. address
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_validate_mac_address(scsi_qla_host_t *ha)
+{
+	FLASH_SYS_INFO *sys_info = NULL;
+	dma_addr_t sys_info_dma;
+	uint8_t status = QLA_ERROR;
+
+	ENTER("qla4xxx_validate_mac_address");
+	sys_info = (FLASH_SYS_INFO *) pci_alloc_consistent(ha->pdev,
+	    sizeof(*sys_info), &sys_info_dma);
+	if (sys_info == NULL) {			
+		QL4PRINT(QLP2, printk("scsi%d: %s: Unable to allocate dma "
+		    "buffer.\n", ha->host_no, __func__));
+		goto exit_validate_mac;
+	}
+	memset(sys_info, 0, sizeof(*sys_info));
+
+	/* Get flash sys info */
+	if (qla4xxx_get_flash(ha, sys_info_dma, FLASH_OFFSET_SYS_INFO,
+	    sizeof(*sys_info)) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: get_flash "
+		    "FLASH_OFFSET_SYS_INFO failed\n", ha->host_no, __func__));
+		goto exit_validate_mac;
+	}
+
+	/* Save M.A.C. address & serial_number */
+	memcpy(ha->my_mac, &sys_info->physAddr[0].address[0],
+	    MIN(sizeof(ha->my_mac), sizeof(sys_info->physAddr[0].address)));
+	memcpy(ha->serial_number, &sys_info->acSerialNumber,
+	    MIN(sizeof(ha->serial_number), sizeof(sys_info->acSerialNumber)));
+
+	/* Display Debug Print Info */
+	QL4PRINT(QLP10, printk("scsi%d: Flash Sys Info\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP10, sys_info, sizeof(*sys_info));
+
+	/*
+	 * If configuration information was specified on the command line,
+	 * validate the mac address here.
+	 */
+	if (ql4xdevconf) {
+		char *propbuf;
+		uint8_t cfg_mac[MAC_ADDR_LEN];
+
+		propbuf = kmalloc(LINESIZE, GFP_ATOMIC);
+		if (propbuf == NULL) {			
+			QL4PRINT(QLP2, printk("scsi%d: %s: Unable to "
+			    "allocate memory.\n", ha->host_no, __func__));
+			goto exit_validate_mac;
+		}
+		
+		/* Get mac address from configuration file. */
+		sprintf(propbuf, "scsi-qla%d-mac", ha->instance);
+		qla4xxx_get_prop_12chars(ha, propbuf, &cfg_mac[0], ql4xdevconf);
+
+		if (qla4xxx_mac_is_equal(&ha->my_mac, cfg_mac)) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: This is a "
+			    "registered adapter.\n", ha->host_no, __func__));
+			status = QLA_SUCCESS;
+		} else {
+			QL4PRINT(QLP7, printk("scsi%d: %s: This is NOT a "
+			    "registered adapter.\n", ha->host_no, __func__));
+		}
+		kfree(propbuf);
+	} else {
+		status = QLA_SUCCESS;
+	}
+
+exit_validate_mac:
+	if (sys_info)
+		pci_free_consistent(ha->pdev, sizeof(*sys_info), sys_info,
+		    sys_info_dma);
+
+	LEAVE("qla4xxx_validate_mac_address");
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_init_local_data
+ *	This routine initializes the local data for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized local data
+ *	QLA_ERROR   - Failed to initialize local data
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_init_local_data(scsi_qla_host_t *ha)
+{
+	int i;
+
+	/* Initialize passthru PDU list */
+	memset(ha->pdu_buf_used, 0, sizeof(ha->pdu_buf_used));
+	memset(ha->pdu_buffsv, 0, sizeof(ha->pdu_buff_size));
+	for (i = 0; i < (MAX_PDU_ENTRIES - 1); i++) {
+		ha->pdu_queue[i].Next = &ha->pdu_queue[i+1];
+	}
+	ha->free_pdu_top = &ha->pdu_queue[0];
+	ha->free_pdu_bottom = &ha->pdu_queue[MAX_PDU_ENTRIES - 1];
+	ha->free_pdu_bottom->Next = NULL;
+	ha->pdu_active = 0;
+
+	/* Initilize aen queue */
+	ha->aen_q_count = MAX_AEN_ENTRIES;
+
+	/* Initialize local iSNS data */
+	qla4xxx_isns_init_attributes(ha);
+	ha->isns_flags = 0;
+	atomic_set(&ha->isns_restart_timer, 0);
+	ha->isns_connection_id = 0;
+	ha->isns_remote_port_num = 0;
+	ha->isns_scn_port_num = 0;
+	ha->isns_esi_port_num = 0;
+	ha->isns_nsh_port_num = 0;
+	memset(ha->isns_entity_id, 0, sizeof(ha->isns_entity_id));
+	ha->isns_num_discovered_targets = 0;
+
+	return (QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_init_firmware
+ *	This routine initializes the firmware.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized firmware
+ *	QLA_ERROR   - Failed to initialize firmware
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_init_firmware(scsi_qla_host_t *ha)
+{
+	uint8_t  status = QLA_ERROR;
+	uint32_t timeout_count;
+
+	ENTER("qla4xxx_init_firmware");
+
+	if (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR) {
+		LEAVE("qla4xxx_init_firmware");
+		return (QLA_ERROR);
+	}
+
+	/* If iSNS is enabled, start the iSNS service now. */
+	if ((ha->tcp_options & TOPT_ISNS_ENABLE) &&
+	    !IPAddrIsZero(ha->isns_ip_address)) {
+		uint32_t ip_addr = 0;
+
+		IPAddr2Uint32(ha->isns_ip_address, &ip_addr);
+		qla4xxx_isns_reenable(ha, ip_addr, ha->isns_server_port_number);
+	}
+
+	for (timeout_count = ADAPTER_INIT_TOV; timeout_count > 0;
+	    timeout_count--) {
+		/* Get firmware state. */
+		if (qla4xxx_get_firmware_state(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: unable to get "
+			    "firmware state\n", ha->host_no, __func__));
+			LEAVE("qla4xxx_init_firmware");
+
+			return (QLA_ERROR);
+		}
+
+		if (ha->firmware_state & FW_STATE_ERROR) {
+			QL4PRINT(QLP1, printk("scsi%d: %s: an unrecoverable "
+			    "error has occurred\n", ha->host_no, __func__));
+			LEAVE("qla4xxx_init_firmware");
+
+			return (QLA_ERROR);
+		}
+		if (ha->firmware_state & FW_STATE_CONFIG_WAIT) {
+			/*
+			 * The firmware has not yet been issued an Initialize
+			 * Firmware command, so issue it now.
+			 */
+			if (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR) {
+				LEAVE("qla4xxx_init_firmware");
+				return (status);
+			}
+
+			/* Go back and test for ready state - no wait. */
+			continue;
+		}
+
+		if (ha->firmware_state & FW_STATE_WAIT_LOGIN) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: waiting for "
+			    "firmware to initialize\n", ha->host_no, __func__));
+		}
+
+		if (ha->firmware_state & FW_STATE_DHCP_IN_PROGRESS) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: DHCP in progress\n",
+			    ha->host_no, __func__));
+		}
+
+		if (ha->firmware_state == FW_STATE_READY) {
+			/* The firmware is ready to process SCSI commands. */
+			QL4PRINT(QLP7, printk("scsi%d: %s: FW STATE - READY\n",
+			    ha->host_no, __func__));
+			QL4PRINT(QLP7, printk("scsi%d: %s: MEDIA TYPE - %s\n",
+			    ha->host_no, __func__,
+			    ((ha->addl_fw_state & FW_ADDSTATE_OPTICAL_MEDIA) !=
+			    0) ? "OPTICAL" : "COPPER"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: DHCP STATE Enabled "
+			    "%s\n", ha->host_no, __func__,
+			    ((ha->addl_fw_state & FW_ADDSTATE_DHCP_ENABLED) !=
+				0) ? "YES" : "NO"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: DHCP STATE Lease "
+			    "Acquired  %s\n", ha->host_no, __func__,
+			    ((ha->addl_fw_state &
+				FW_ADDSTATE_DHCP_LEASE_ACQUIRED) != 0) ?
+				    "YES" : "NO"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: DHCP STATE Lease "
+			    "Expired  %s\n", ha->host_no, __func__,
+			    ((ha->addl_fw_state &
+				FW_ADDSTATE_DHCP_LEASE_EXPIRED) != 0) ?
+				    "YES" : "NO"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: LINK  %s\n",
+			    ha->host_no, __func__,
+			    ((ha->addl_fw_state & FW_ADDSTATE_LINK_UP) != 0) ?
+				    "UP" : "DOWN"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: iSNS Service "
+			    "Started  %s\n", ha->host_no, __func__,
+			    ((ha->addl_fw_state &
+				FW_ADDSTATE_ISNS_SVC_ENABLED) != 0) ?
+				    "YES" : "NO"));
+			QL4PRINT(QLP7, printk("scsi%d: %s: QLA4040 TopCat "
+			    "Initialized  %s\n", ha->host_no, __func__,
+			    ((ha->addl_fw_state &
+				FW_ADDSTATE_TOPCAT_NOT_INITIALIZED) == 0) ?
+				    "YES" : "NO"));
+
+			goto exit_init_fw;
+		}
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: (%x/%x) delay 1 sec, time "
+		    "remaining %d\n", ha->host_no, __func__, ha->firmware_state,
+		    ha->addl_fw_state, timeout_count));
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 * HZ);
+	} /* for */
+
+	QL4PRINT(QLP2, printk("scsi%d: %s: FW Initialization timed out!\n",
+	    ha->host_no, __func__));
+
+exit_init_fw:
+	set_bit(AF_ONLINE, &ha->flags);
+	LEAVE("qla4xxx_init_firmware");
+
+	return (QLA_SUCCESS);
+}
+
+#if 0
+static void
+qla4xxx_map_lun( scsi_qla_host_t *ha,
+		 uint16_t target, uint16_t lun, fc_lun_t *fclun )
+{
+	os_tgt_t        *tq;
+	os_lun_t        *lq;
+
+	tq =  &ha->temp_tgt;
+	lq =  &ha->temp_lun;
+	TGT_Q(ha,target) = tq;
+	LUN_Q(ha,target,lun) = lq;
+	lq->fclun = fclun;
+
+	QL4PRINT(QLP3, printk("scsi%d: %s: TGT %d, LUN %d\n", ha->host_no, __func__, tq->id, lq->lun));
+}
+
+static void
+qla4xxx_unmap_lun( scsi_qla_host_t *ha,
+		   uint16_t target, uint16_t lun )
+{
+
+	if (LUN_Q(ha,target,lun) != NULL) {
+		LUN_Q(ha,target,lun) = NULL;
+		// qla4xxx_free_lun(ha,target );		
+	}
+	if (TGT_Q(ha,target) != NULL) {
+
+		TGT_Q(ha,target) = NULL;
+	}
+	QL4PRINT(QLP3, printk("scsi%d: %s: TGT %d, LUN %d\n", ha->host_no, __func__, target, lun));
+}
+#endif
+
+/**************************************************************************
+ * qla4xxx_is_discovered_target
+ *	This routine locates a device handle given iSNS information.
+ *	If device doesn't exist, returns NULL.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      ip_addr - Pointer to IP address
+ *      alias - Pointer to iSCSI alias
+ *
+ * Returns:
+ *	Pointer to the corresponding internal device database structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline uint8_t
+qla4xxx_is_discovered_target(scsi_qla_host_t *ha,
+			     uint8_t *ip_addr,
+			     uint8_t *alias,
+			     uint8_t *name_str)
+{
+	ISNS_DISCOVERED_TARGET *discovered_target = NULL;
+	int i,j;
+
+	for (i=0; i < ha->isns_num_discovered_targets; i++) {
+		discovered_target = &ha->isns_disc_tgt_databasev[i];
+
+		for (j = 0; j < discovered_target->NumPortals; j++) {
+			if (memcmp(discovered_target->Portal[j].IPAddr, ip_addr,
+				MIN(sizeof(discovered_target->Portal[j].IPAddr),
+				sizeof(*ip_addr)) == 0) &&
+			    memcmp(discovered_target->Alias, alias,
+				MIN(sizeof(discovered_target->Alias),
+				sizeof(*alias)) == 0) &&
+			    memcmp(discovered_target->NameString, name_str,
+				MIN(sizeof(discovered_target->Alias),
+				sizeof(*name_str)) == 0)) {
+
+				return (QLA_SUCCESS);
+			}
+		}
+	}
+
+	return (QLA_ERROR);
+}
+
+static ddb_entry_t *
+qla4xxx_get_ddb_entry(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	DEV_DB_ENTRY *fw_ddb_entry = NULL;
+	dma_addr_t   fw_ddb_entry_dma;
+	ddb_entry_t	*ddb_entry = NULL;
+	int		found = 0;
+
+	ENTER(__func__);
+
+	/* Make sure the dma buffer is valid */
+	fw_ddb_entry = pci_alloc_consistent(ha->pdev, sizeof(*fw_ddb_entry),
+	    &fw_ddb_entry_dma);
+	if (fw_ddb_entry == NULL) {
+		DEBUG2(printk("scsi%d: %s: Unable to allocate dma "
+		    "buffer.\n", ha->host_no, __func__));
+
+		return NULL;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
+	    fw_ddb_entry_dma, NULL, NULL, NULL, NULL, NULL,
+	    NULL) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: failed get_ddb_entry for "
+		    "fw_ddb_index %d\n", ha->host_no, __func__, fw_ddb_index));
+		return NULL;
+	}
+
+	/* Allocate DDB if not already allocated. */
+	DEBUG2(printk("scsi%d: %s: Looking for ddb match [%d]\n", ha->host_no,
+		    __func__, fw_ddb_index));
+	list_for_each_entry(ddb_entry, &ha->ddb_list, list_entry) {
+	   	if (memcmp(ddb_entry->iscsi_name, fw_ddb_entry->iscsiName,
+	   			    ISCSI_NAME_SIZE) == 0) {
+			found++; 
+	   		break;
+	   	}
+	}
+
+	if( !found ) {
+	DEBUG2(printk("scsi%d: %s: ddb match [%d] not found - allocating new ddb\n", ha->host_no,
+		    __func__, fw_ddb_index));
+		ddb_entry = qla4xxx_alloc_ddb(ha, fw_ddb_index);
+	}
+	
+	/* if not found allocate new ddb */
+
+	if (fw_ddb_entry)
+		pci_free_consistent(ha->pdev, sizeof(*fw_ddb_entry),
+		    fw_ddb_entry, fw_ddb_entry_dma);
+
+	return ddb_entry;
+}
+
+/**************************************************************************
+ * qla4xxx_update_ddb_entry
+ *	This routine updates the driver's internal device database entry
+ *	with information retrieved from the firmware's device database
+ *	entry for the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Output:
+ *	ddb_entry - Structure filled in.
+ *
+ * Remarks:
+ *	The ddb_entry->fw_ddb_index field must be initialized prior to
+ *	calling this routine
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully update ddb_entry
+ *	QLA_ERROR   - Failed to update ddb_entry
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_update_ddb_entry(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	DEV_DB_ENTRY *fw_ddb_entry = NULL;
+	dma_addr_t   fw_ddb_entry_dma;
+	uint32_t     fw_ddb_index;
+	uint8_t      status = QLA_ERROR;
+
+	ENTER("qla4xxx_update_ddb_entry");
+
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ddb_entry is NULL\n",
+				      ha->host_no, __func__));
+		goto exit_update_ddb;
+	}
+
+	/* Make sure the dma buffer is valid */
+	fw_ddb_entry = pci_alloc_consistent(ha->pdev, sizeof(*fw_ddb_entry),
+	    &fw_ddb_entry_dma);
+	if (fw_ddb_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Unable to allocate dma "
+		    "buffer.\n", ha->host_no, __func__));
+
+		goto exit_update_ddb;
+	}
+
+	fw_ddb_index = ddb_entry->fw_ddb_index;
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
+	    fw_ddb_entry_dma, NULL, NULL, &ddb_entry->fw_ddb_device_state,
+	    &ddb_entry->default_time2wait, &ddb_entry->tcp_source_port_num,
+	    &ddb_entry->connection_id) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: failed get_ddb_entry for "
+		    "fw_ddb_index %d\n", ha->host_no, __func__, fw_ddb_index));
+
+		goto exit_update_ddb;
+	}
+
+	status = QLA_SUCCESS;
+	switch (ddb_entry->fw_ddb_device_state) {
+	case DDB_DS_SESSION_ACTIVE:
+		ddb_entry->target_session_id = le16_to_cpu(fw_ddb_entry->TSID);
+		ddb_entry->task_mgmt_timeout =
+		    le16_to_cpu(fw_ddb_entry->taskMngmntTimeout);
+		ddb_entry->CmdSn = 0;
+		ddb_entry->exe_throttle =
+		    le16_to_cpu(fw_ddb_entry->exeThrottle);
+		ddb_entry->default_relogin_timeout =
+		    le16_to_cpu(fw_ddb_entry->taskMngmntTimeout);
+
+		memcpy(&ddb_entry->iscsi_name[0], &fw_ddb_entry->iscsiName[0],
+		    MIN(sizeof(ddb_entry->iscsi_name),
+		    sizeof(fw_ddb_entry->iscsiName)));
+		memcpy(&ddb_entry->ip_addr[0], &fw_ddb_entry->ipAddr[0],
+		    MIN(sizeof(ddb_entry->ip_addr),
+		    sizeof(fw_ddb_entry->ipAddr)));
+
+		if (qla4xxx_is_discovered_target(ha, fw_ddb_entry->ipAddr,
+		    fw_ddb_entry->iSCSIAlias, fw_ddb_entry->iscsiName) ==
+		    QLA_SUCCESS) {
+			set_bit(DF_ISNS_DISCOVERED, &ddb_entry->flags);
+		}
+
+		//QL4PRINT(QLP7, printk("scsi%d: %s: index [%d] \"%s\"\n",
+		//		      ha->host_no, __func__,
+		//		      fw_ddb_index,
+		//		      ddb_state_msg[ddb_entry->fw_ddb_device_state]));
+		break;
+
+	case DDB_DS_NO_CONNECTION_ACTIVE:
+	case DDB_DS_NO_SESSION_ACTIVE:
+	case DDB_DS_SESSION_FAILED:
+		ddb_entry->target_session_id = 0;
+		ddb_entry->task_mgmt_timeout = 0;
+		ddb_entry->connection_id = 0;
+		ddb_entry->CmdSn = 0;
+		ddb_entry->exe_throttle = 0;
+		ddb_entry->default_time2wait = 0;
+
+		//QL4PRINT(QLP7, printk("scsi%d: %s: index [%d] \"%s\"\n",
+		//		      ha->host_no, __func__,
+		//		      fw_ddb_index,
+		//		      ddb_state_msg[ddb_entry->fw_ddb_device_state]));
+		break;
+
+	case DDB_DS_UNASSIGNED:
+	case DDB_DS_DISCOVERY:
+	case DDB_DS_LOGGING_OUT:
+		//QL4PRINT(QLP7, printk("scsi%d: %s: index [%d] \"%s\"\n",
+		//		      ha->host_no, __func__,
+		//		      fw_ddb_index,
+		//		      ddb_state_msg[ddb_entry->fw_ddb_device_state]));
+		break;
+
+		//default:
+		//QL4PRINT(QLP7, printk("scsi%d: %s: index [%d] State %x. "
+		//		      "Illegal state\n",
+		//		      ha->host_no, __func__,
+		//		      fw_ddb_index,
+		//		      ddb_entry->fw_ddb_device_state));
+
+	}
+
+	DEBUG2(printk("scsi%d: %s: index [%d] State %x. state\n",
+    		ha->host_no, __func__, fw_ddb_index, ddb_entry->fw_ddb_device_state);)
+
+exit_update_ddb:
+	if (fw_ddb_entry)
+		pci_free_consistent(ha->pdev, sizeof(*fw_ddb_entry),
+		    fw_ddb_entry, fw_ddb_entry_dma);
+
+	LEAVE("qla4xxx_update_ddb_entry");
+
+	return (status);
+}
+
+
+static  void
+qla4xxx_configure_fcports(scsi_qla_host_t *ha)
+{
+	fc_port_t       *fcport;
+
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		qla4xxx_update_fcport(ha, fcport);
+	}
+}
+
+static fc_port_t *
+qla4xxx_find_or_alloc_fcport(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	fc_port_t       *fcport;
+	int     found;
+
+	ENTER(__func__);
+	/* Check for matching device in port list. */
+	found = 0;
+	fcport = NULL;
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		//if (memcmp(new_fcport->port_name, fcport->port_name,
+		//WWN_SIZE) == 0)
+		if (fcport->ddbptr == ddb_entry) {
+			fcport->flags &= ~(FCF_PERSISTENT_BOUND);
+			found++;
+			break;
+		}
+	}
+
+	if (!found) {
+		/* Allocate a new replacement fcport. */
+		fcport = qla4xxx_alloc_fcport(ha, GFP_KERNEL);
+		if (fcport != NULL) {
+			/* New device, add to fcports list. */
+			list_add_tail(&fcport->list, &ha->fcports);
+			fcport->ddbptr = ddb_entry;
+		}
+		// new_fcport->flags &= ~FCF_FABRIC_DEVICE;
+	}
+
+	// qla4xxx_update_fcport(ha, fcport);
+	LEAVE(__func__);
+
+	return (fcport);
+}
+
+
+/**************************************************************************
+ * qla4xxx_alloc_ddb
+ *	This routine allocates a ddb_entry, ititializes some values, and
+ *	inserts it into the ddb list.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *	Pointer to internal device database structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+ddb_entry_t *
+qla4xxx_alloc_ddb(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	ddb_entry_t *ddb_entry;
+
+	QL4PRINT(QLP12, printk("scsi%d: %s: fw_ddb_index [%d]\n", ha->host_no,
+	    __func__, fw_ddb_index));
+
+	ddb_entry = (ddb_entry_t *) kmalloc(sizeof(*ddb_entry), GFP_KERNEL);
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Unable to allocate memory "
+		    "to add fw_ddb_index [%d]\n", ha->host_no, __func__,
+		    fw_ddb_index));
+	} else {
+		memset(ddb_entry, 0, sizeof(*ddb_entry));
+		ddb_entry->fw_ddb_index = fw_ddb_index;
+		atomic_set(&ddb_entry->port_down_timer,
+		    ha->port_down_retry_count);
+		atomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);
+		atomic_set(&ddb_entry->relogin_timer, 0);
+		atomic_set(&ddb_entry->relogin_retry_count, 0);
+		atomic_set(&ddb_entry->state, DEV_STATE_ONLINE);
+		list_add_tail(&ddb_entry->list_entry, &ha->ddb_list);
+		ha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;
+		ha->tot_ddbs++;
+		ddb_entry->fcport = qla4xxx_find_or_alloc_fcport(ha, ddb_entry);
+	}
+	return (ddb_entry);
+}
+
+/**************************************************************************
+ * qla4xxx_build_ddb_list
+ *	This routine searches for all valid firmware ddb entries and builds
+ *	an internal ddb list.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *	Ddbs that are considered valid are those with a device state of
+ *	SESSION_ACTIVE.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully built internal ddb list
+ *	QLA_ERROR   - Failed to build internal ddb list
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_build_ddb_list(scsi_qla_host_t *ha)
+{
+	uint8_t         status = QLA_ERROR;
+	uint32_t        fw_ddb_index = 0;
+	uint32_t        next_fw_ddb_index = 0;
+	uint32_t        ddb_state;
+	ddb_entry_t     *ddb_entry;
+
+	ENTER("qla4xxx_build_ddb_list");
+
+	for (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES;
+	    fw_ddb_index = next_fw_ddb_index) {
+		/* First, let's see if a device exists here */
+		if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL,
+		    &next_fw_ddb_index, &ddb_state, NULL, NULL, NULL) ==
+		    QLA_ERROR) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: get_ddb_entry, "
+			    "fw_ddb_index %d failed", ha->host_no, __func__,
+			    fw_ddb_index));
+			goto exit_build_ddb_list;
+		}
+
+		/* If the device is logged in (SESSION_ACTIVE) then
+		 * add it to internal our ddb list. */
+		if (ddb_state == DDB_DS_SESSION_ACTIVE) {
+			/* Allocate a device structure */
+			ddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index);
+			if (ddb_entry == NULL) {
+				QL4PRINT(QLP2, printk("scsi%d: %s: Unable to "
+				    "allocate memory for device at "
+				    "fw_ddb_index %d\n", ha->host_no, __func__,
+				    fw_ddb_index));
+				goto exit_build_ddb_list;
+			}
+
+			/* Fill in the device structure */
+			if (qla4xxx_update_ddb_entry(ha, ddb_entry) ==
+			    QLA_ERROR) {
+				ha->fw_ddb_index_map[fw_ddb_index] = 
+		    			(ddb_entry_t *) INVALID_ENTRY;
+			//	qla4xxx_free_ddb(ha, ddb_entry);
+				QL4PRINT(QLP2, printk("scsi%d: %s: "
+				    "update_ddb_index, fw_ddb_index %d "
+				    "failed\n", ha->host_no, __func__,
+				    fw_ddb_index));
+				goto exit_build_ddb_list;
+			}
+
+			/* if fw_ddb with session active state found,
+			 * add to ddb_list */
+			QL4PRINT(QLP7, printk("scsi%d: %s: fw_ddb index [%d] "
+			    "added to ddb list\n", ha->host_no, __func__,
+			    fw_ddb_index));
+		} else if (ddb_state == DDB_DS_SESSION_FAILED) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: Attempt to login "
+			    "index [%d]\n", ha->host_no, __func__,
+			    fw_ddb_index));
+			qla4xxx_set_ddb_entry(ha, fw_ddb_index, NULL, 0);
+		}
+
+		/* We know we've reached the last device when
+		 * next_fw_ddb_index is 0 */
+		if (next_fw_ddb_index == 0)
+			break;
+	}
+
+	/* tot_ddbs updated in alloc/free_ddb routines */
+	if (ha->tot_ddbs)
+		status = QLA_SUCCESS;
+
+exit_build_ddb_list:
+	LEAVE("qla4xxx_build_ddb_list");
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_fw_ready
+ *	This routine obtains device information from the F/W database during
+ *	driver load time.  The device table is rebuilt from scratch.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully (re)built internal ddb list
+ *	QLA_ERROR   - Failed to (re)build internal ddb list
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+
+static int
+qla4xxx_fw_ready(scsi_qla_host_t *ha)
+{
+	int	rval = QLA_ERROR;
+	int	rval1;
+	unsigned long	wtime;
+
+	//wtime = jiffies + (ql4xdiscoverywait * HZ);
+	wtime = jiffies + (30 * HZ);
+		
+	DEBUG3(printk("Waiting for discovered devices ...\n"));
+	do {
+		rval1 = qla4xxx_get_firmware_state(ha);
+		if (rval1 == QLA_SUCCESS) {
+			DEBUG3(printk("fw state=0x%x, curr time=%lx\n",
+			    ha->firmware_state,jiffies);)
+
+			/* ready? */
+			if (!(ha->firmware_state & (BIT_3|BIT_2|BIT_1|BIT_0))) {
+				if (test_bit(DPC_AEN, &ha->dpc_flags)) {
+					rval = QLA_SUCCESS;
+					DEBUG3(printk("Done...\n"));
+					break;
+				}
+			}
+			/* error */
+			if (ha->firmware_state & (BIT_2|BIT_0))
+				break;
+			/* in process */
+		}
+		if (rval == QLA_SUCCESS)
+			break;
+
+		/* delay */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ / 2);
+	} while (!time_after_eq(jiffies,wtime));
+
+	return (rval);
+}
+
+static uint8_t
+qla4xxx_initialize_ddb_list(scsi_qla_host_t *ha)
+{
+	uint16_t fw_ddb_index;
+	uint8_t status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_initialize_ddb_list");
+
+	/* Reinitialize suspended lun queue. */
+	INIT_LIST_HEAD(&ha->suspended_lun_q);
+	ha->suspended_lun_q_count = 0;
+
+	/* free the ddb list if is not empty */
+	if (!list_empty(&ha->ddb_list))
+		qla4xxx_free_ddb_list(ha);
+
+	/* Initialize internal DDB list and mappingss */
+	qla4xxx_init_tgt_map(ha);
+
+	for (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES; fw_ddb_index++)
+		ha->fw_ddb_index_map[fw_ddb_index] =
+		    (ddb_entry_t *) INVALID_ENTRY;
+
+	ha->tot_ddbs = 0;
+
+	QL4PRINT(QLP7, printk(KERN_INFO "scsi%d: Delay while targets are "
+	    "being discovered.\n", ha->host_no));
+	qla4xxx_fw_ready(ha);
+
+	/*
+	 * First perform device discovery for active fw ddb indexes and build
+	 * ddb list.
+	 */
+	qla4xxx_build_ddb_list(ha);
+
+	/*
+	 * Here we map a SCSI target to a fw_ddb_index and discover all
+	 * possible luns.
+	 */
+	qla4xxx_configure_fcports(ha);
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	if (!qla4xxx_failover_enabled())
+		qla4xxx_config_os(ha);
+#else
+	qla4xxx_config_os(ha);
+#endif
+
+	/*
+	 * Targets can come online after the inital discovery, so processing
+	 * the aens here will catch them.
+	 */
+	if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
+		qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
+
+	if (!ha->tot_ddbs)
+		status = QLA_ERROR;
+
+	LEAVE("qla4xxx_initialize_ddb_list");
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_reinitialize_ddb_list
+ *	This routine obtains device information from the F/W database after
+ *	firmware or adapter resets.  The device table is preserved.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully updated internal ddb list
+ *	QLA_ERROR   - Failed to update internal ddb list
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_reinitialize_ddb_list(scsi_qla_host_t *ha)
+{
+	uint8_t         status = QLA_SUCCESS;
+	ddb_entry_t *ddb_entry, *detemp;
+
+	ENTER("qla4xxx_reinitialize_ddb_list");
+
+	/* Update the device information for all devices. */
+	list_for_each_entry_safe(ddb_entry, detemp, &ha->ddb_list, list_entry) {
+		qla4xxx_update_ddb_entry(ha, ddb_entry);
+		if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+			atomic_set(&ddb_entry->state, DEV_STATE_ONLINE);
+			// DG XXX
+			//atomic_set(&ddb_entry->fcport->state, FCS_ONLINE);
+			qla4xxx_update_fcport(ha, ddb_entry->fcport);
+
+			QL4PRINT(QLP3|QLP7, printk(KERN_INFO
+			    "scsi%d:%d:%d: %s: index [%d] marked ONLINE\n",
+			    ha->host_no, ddb_entry->bus, ddb_entry->target,
+			    __func__, ddb_entry->fw_ddb_index));
+		} else if (atomic_read(&ddb_entry->state) == DEV_STATE_ONLINE)
+			qla4xxx_mark_device_missing(ha, ddb_entry);
+	}
+
+	LEAVE("qla4xxx_reinitialize_ddb_list");
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_relogin_device
+ *	This routine does a session relogin with the specified device.
+ *	The ddb entry must be assigned prior to making this call.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *    QLA_SUCCESS = Successfully relogged in device
+ *    QLA_ERROR   = Failed to relogin device
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_relogin_device(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	uint16_t relogin_timer;
+
+	ENTER("qla4xxx_relogin_device");
+
+	relogin_timer = MAX(ddb_entry->default_relogin_timeout, RELOGIN_TOV);
+	atomic_set(&ddb_entry->relogin_timer, relogin_timer);
+
+	QL4PRINT(QLP3, printk(KERN_WARNING
+	    "scsi%d:%d:%d: Relogin index [%d]. TOV=%d\n", ha->host_no,
+	    ddb_entry->bus, ddb_entry->target, ddb_entry->fw_ddb_index,
+	    relogin_timer));
+
+	qla4xxx_set_ddb_entry(ha, ddb_entry->fw_ddb_index, NULL, 0);
+
+	LEAVE("qla4xxx_relogin_device");
+
+	return (QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4010_topcat_soft_reset
+ *	This routine determines if the QLA4040 TopCat chip is present.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None.
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static void
+qla4010_get_topcat_presence(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+	uint16_t topcat;
+
+	if (qla4xxx_take_hw_semaphore(ha, SEM_NVRAM, SEM_FLG_TIMED_WAIT) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "scsi%d: %s: Unable to take SEM_NVRAM semaphore\n",
+		    ha->host_no, __func__));
+		return;
+	}
+//XXX DG fixme please!
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	set_bit(DPC_FAILOVER_EVENT_NEEDED, &ha->dpc_flags);
+	ha->failover_type = MP_NOTIFY_LOOP_UP;
+#endif
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	topcat = RD_NVRAM_WORD(ha, EEPROM_EXT_HW_CONF_OFFSET());
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	
+	if ((topcat & TOPCAT_MASK) == TOPCAT_PRESENT)
+		set_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags);
+	else
+		clear_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags);
+
+	qla4xxx_clear_hw_semaphore(ha, SEM_NVRAM);
+}
+
+/**************************************************************************
+ * qla4xxx_start_firmware
+ *	This routine performs the neccessary steps to start the firmware for
+ *	the QLA4010 adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully started QLA4010 firmware
+ *	QLA_ERROR   - Failed to start QLA4010 firmware
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_start_firmware(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+	uint32_t mbox_status;
+	uint8_t status = QLA_ERROR;
+	uint8_t soft_reset = 0;
+	uint8_t boot_firmware = 0;
+	uint8_t configure_hardware = 0;
+
+	ENTER("qla4xxx_start_firmware");
+
+	if (IS_QLA4010(ha))
+                qla4010_get_topcat_presence(ha);
+
+	/* Is Hardware already initialized? */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	if ((RD_REG_DWORD(ISP_PORT_STATUS(ha)) & PSR_INIT_COMPLETE) != 0) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Hardware has already been "
+		    "initialized\n", ha->host_no, __func__));
+
+		/* Is firmware already booted? */
+		if (IS_QLA4022(ha)) {
+			if ((RD_REG_DWORD(&ha->reg->u1.isp4022.semaphore) &
+			    SR_FIRWMARE_BOOTED) != 0) {
+				QL4PRINT(QLP7, printk("scsi%d: %s: Firmware "
+				    "has already been booted\n", ha->host_no,
+				    __func__));
+
+				/* Receive firmware boot acknowledgement */
+				mbox_status =
+				    RD_REG_DWORD(&ha->reg->mailbox[0]);
+				if (mbox_status == MBOX_STS_COMMAND_COMPLETE) {
+					/* Acknowledge interrupt */
+					WRT_REG_DWORD(&ha->reg->ctrl_status,
+					    SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+					PCI_POSTING(&ha->reg->ctrl_status);
+
+					spin_unlock_irqrestore(
+					    &ha->hardware_lock, flags);
+					qla4xxx_get_fw_version(ha);
+
+					return QLA_SUCCESS;
+				} else {
+					QL4PRINT(QLP7, printk("scsi%d: %s: "
+					    "ERROR: Hardware initialized but "
+					    "firmware not successfully "
+					    "booted\n", ha->host_no, __func__));
+
+					boot_firmware = 1;
+				}
+			} else {
+				QL4PRINT(QLP7, printk("scsi%d: %s: Firmware "
+				    "has NOT already been booted\n",
+				    ha->host_no, __func__));
+
+				boot_firmware = 1;
+			}
+		}
+		//XXX Why are we not checking for !boot_firmware?
+		//if (!boot_firmware) {
+			/* Did BIOS initialize hardware? */
+			/*
+			 * If the BIOS is loaded then the firmware is already
+			 * initialized.  Reinitializing it without first
+			 * performing a reset is a NO-NO.  We need to check
+			 * here if the BIOS is loaded (i.e.
+			 * FW_STATE_CONFIG_WAIT == 0).  If so, force a soft
+			 * reset.
+			 */   
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			if (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS) {
+				if (!(ha->firmware_state &
+				    FW_STATE_CONFIG_WAIT)) {
+					QL4PRINT(QLP7, printk("scsi%d: %s: "
+					    "Firmware has been initialized by "
+					    "BIOS -- RESET\n", ha->host_no,
+					    __func__));
+
+					soft_reset = 1;
+
+					qla4xxx_process_aen(ha,
+					    FLUSH_DDB_CHANGED_AENS);
+				}
+			} else {
+				QL4PRINT(QLP2, printk("scsi%d: %s: Error "
+				    "detecting if firmware has already been "
+				    "initialized by BIOS -- RESET\n",
+				    ha->host_no, __func__));
+
+				soft_reset = 1;
+			}
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+		//}
+	} else {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Hardware has NOT already "
+		    "been initialized\n", ha->host_no, __func__));
+
+		configure_hardware = 1;
+		boot_firmware = 1;
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (soft_reset) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Issue Soft Reset\n",
+		    ha->host_no, __func__));
+
+		status = qla4xxx_soft_reset(ha);
+
+		if (qla4xxx_take_hw_semaphore(ha, SEM_DRIVER, TIMED_WAIT) !=
+		    QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk(KERN_WARNING
+			    "scsi%d: %s: Unable to take SEM_DRIVER semaphore "
+			    "(2)\n", ha->host_no, __func__));
+
+			return QLA_ERROR;
+		}
+
+		if (status == QLA_ERROR) {
+			QL4PRINT(QLP3|QLP7, printk("scsi%d: %s: Soft Reset "
+			    "failed!\n", ha->host_no, __func__));
+
+			qla4xxx_clear_hw_semaphore(ha, SEM_DRIVER);
+
+			return status;
+		}
+
+		configure_hardware = 1;
+		boot_firmware = 1;
+	}
+
+	if (configure_hardware) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Set up Hardware "
+		    "Configuration Register\n", ha->host_no, __func__));
+
+		if (qla4xxx_take_hw_semaphore(ha, SEM_FLASH, TIMED_WAIT) !=
+		    QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk(KERN_WARNING
+			    "scsi%d: %s: Unable to take SEM_FLASH semaphore\n",
+			    ha->host_no, __func__));
+
+			return QLA_ERROR;
+		}
+		if (qla4xxx_take_hw_semaphore(ha, SEM_NVRAM, TIMED_WAIT) !=
+		    QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk(KERN_WARNING
+			    "scsi%d: %s: Unable to take SEM_NVRAM semaphore\n",
+			    ha->host_no, __func__));
+
+			qla4xxx_clear_hw_semaphore(ha, SEM_FLASH);
+
+			return QLA_ERROR;
+		}
+
+printk("scsi%d: %s: about to NVRAM config\n", ha->host_no, __func__);
+		if (qla4xxx_is_NVRAM_configuration_valid(ha) == QLA_SUCCESS) {
+			EXTERNAL_HW_CONFIG_REG	extHwConfig;
+			
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			extHwConfig.AsUINT32 = RD_NVRAM_WORD(ha,
+			    EEPROM_EXT_HW_CONF_OFFSET());
+			
+			QL4PRINT(QLP7, printk("scsi%d: %s: Setting extHwConfig "
+			    "to 0xFFFF%04x\n", ha->host_no, __func__,
+			    extHwConfig.AsUINT32));
+
+			WRT_REG_DWORD(ISP_NVRAM(ha),
+			    ((0xFFFF << 16) | extHwConfig.AsUINT32));
+			PCI_POSTING(ISP_NVRAM(ha));
+
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+			qla4xxx_clear_hw_semaphore(ha, SEM_NVRAM);
+			qla4xxx_clear_hw_semaphore(ha, SEM_FLASH);
+
+			status = QLA_SUCCESS;
+		} else {
+			/*
+			 * QLogic adapters should always have a valid NVRAM.
+			 * If not valid, do not load.
+			 */
+			QL4PRINT(QLP7, printk("scsi%d: %s: EEProm checksum "
+			    "invalid.  Please update your EEPROM\n",
+			    ha->host_no, __func__));
+
+			qla4xxx_clear_hw_semaphore(ha, SEM_NVRAM);
+			qla4xxx_clear_hw_semaphore(ha, SEM_FLASH);
+
+			return QLA_ERROR;
+		}
+	}
+
+	if (boot_firmware) {
+		uint32_t	max_wait_time;
+
+		/*
+		 * Start firmware from flash ROM
+		 *
+		 * WORKAROUND: Stuff a non-constant value that the firmware can
+		 * use as a seed for a random number generator in MB7 prior to
+		 * setting BOOT_ENABLE.  Fixes problem where the TCP
+		 * connections use the same TCP ports after each reboot,
+		 * causing some connections to not get re-established.
+		 */
+		QL4PRINT(QLP7, printk("scsi%d: %s: Start firmware from flash "
+		    "ROM\n", ha->host_no, __func__));
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(&ha->reg->mailbox[7], jiffies);
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+		    SET_RMASK(CSR_BOOT_ENABLE));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		/* Wait for firmware to come UP. */
+		max_wait_time = FIRMWARE_UP_TOV;
+		do {
+			uint32_t ctrl_status;
+
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+			if (ctrl_status & SET_RMASK(CSR_SCSI_PROCESSOR_INTR))
+				break;
+					
+			QL4PRINT(QLP7, printk("scsi%d: %s: Waiting for "
+			    "firmware to come up... ctrl_sts=0x%x, "
+			    "remaining=%d\n", ha->host_no, __func__,
+			    ctrl_status, max_wait_time));
+
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1 * HZ);
+		} while ((max_wait_time--));
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		mbox_status = RD_REG_DWORD(&ha->reg->mailbox[0]);
+		if (mbox_status == MBOX_STS_COMMAND_COMPLETE) {
+			QL4PRINT(QLP7, printk("scsi%d: %s: Firmware has "
+			    "started\n", ha->host_no, __func__));
+
+			if (IS_QLA4010(ha)) {
+				ha->firmware_version[0] =
+				    RD_REG_DWORD(&ha->reg->mailbox[1]);
+				ha->firmware_version[1] =
+				    RD_REG_DWORD(&ha->reg->mailbox[2]);
+				ha->patch_number =
+				    RD_REG_DWORD(&ha->reg->mailbox[3]);
+				ha->build_number =
+				    RD_REG_DWORD(&ha->reg->mailbox[4]);
+
+				QL4PRINT(QLP7, printk("scsi%d: FW Version "
+				    "%02d.%02d Patch %02d Build %02d\n",
+				    ha->host_no, ha->firmware_version[0],
+				    ha->firmware_version[1], ha->patch_number,
+				    ha->build_number));
+			}
+
+			WRT_REG_DWORD(&ha->reg->ctrl_status,
+			    SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+			status = QLA_SUCCESS;
+		} else {
+			QL4PRINT(QLP2, printk("scsi%d: %s: Self Test failed "
+			    "with status 0x%x\n", ha->host_no, __func__,
+			    mbox_status));
+
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+			status = QLA_ERROR;
+		}
+	}
+
+	if (status == QLA_SUCCESS) {
+		if (test_and_clear_bit(AF_GET_CRASH_RECORD, &ha->flags))
+			qla4xxx_get_crash_record(ha);
+	} else {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Firmware has NOT started\n",
+		    ha->host_no, __func__));
+
+		qla4xxx_dump_registers(QLP7, ha);
+	}
+
+	LEAVE("qla4xxx_start_firmware");
+	return status;
+}
+
+static void
+qla2x00_pci_config(scsi_qla_host_t *ha)
+{
+	uint16_t        w, mwi;
+
+	ql4_printk(KERN_INFO, ha, "Configuring PCI space...\n");
+
+	pci_set_master(ha->pdev);
+	mwi = 0;
+	if (pci_set_mwi(ha->pdev))
+		mwi = PCI_COMMAND_INVALIDATE;
+
+	/*
+	 * We want to respect framework's setting of PCI configuration space
+	 * command register and also want to make sure that all bits of
+	 * interest to us are properly set in command register.
+	 */
+	pci_read_config_word(ha->pdev, PCI_COMMAND, &w);
+	w |= mwi | (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);
+	w &= ~PCI_COMMAND_INTX_DISABLE;
+	pci_write_config_word(ha->pdev, PCI_COMMAND, w);
+}	
+
+/**************************************************************************
+ * qla4xxx_initialize_adapter
+ *	This routine parforms all of the steps necessary to initialize the
+ *	adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	renew_ddb_list - Indicates what to do with the adapter's ddb list
+ *			after adapter recovery has completed.
+ *			0=preserve ddb list, 1=destroy and rebuild ddb list
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized adapter
+ *	QLA_ERROR   - Failed to initialize adapter
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+
+uint8_t
+qla4xxx_initialize_adapter(scsi_qla_host_t *ha, uint8_t renew_ddb_list)
+{
+	uint8_t      status;
+
+	ENTER("qla4xxx_initialize_adapter");
+
+	qla2x00_pci_config(ha);
+
+	/* Initialize the Host adapter request/response queues and firmware */
+	if ((status = qla4xxx_start_firmware(ha)) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(KERN_INFO
+		    "scsi%d: Failed to start QLA4010 firmware\n", ha->host_no));
+	} else if ((status = qla4xxx_validate_mac_address(ha)) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "scsi%d: Failed to validate mac address\n", ha->host_no));
+	} else if ((status = qla4xxx_init_local_data(ha)) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "scsi%d: Failed to initialize local data\n", ha->host_no));
+	} else if ((status = qla4xxx_init_firmware(ha)) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "scsi%d: Failed to initialize firmware\n", ha->host_no));
+	} else {
+		if (renew_ddb_list == PRESERVE_DDB_LIST) {
+			/*
+			 * We want to preserve lun states (i.e. suspended, etc.)
+			 * for recovery initiated by the driver.  So just update
+			 * the device states for the existing ddb_list
+			 */
+			qla4xxx_reinitialize_ddb_list(ha);
+		}
+		else if (renew_ddb_list == REBUILD_DDB_LIST) {
+			/*
+			 * We want to build the ddb_list from scratch during
+			 * driver initialization and recovery initiated by the
+			 * INT_HBA_RESET IOCTL.
+			 */
+			qla4xxx_initialize_ddb_list(ha);
+		}
+
+		if (test_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags)) {
+			u_long wait_cnt = jiffies + ql4xdiscoverywait * HZ;
+
+			if (!test_bit(ISNS_FLAG_ISNS_SRV_ENABLED,
+			    &ha->isns_flags)) {
+				QL4PRINT(QLP7, printk(KERN_INFO
+				    "scsi%d: Delay up to %d seconds while "
+				    "targets are being discovered.\n",
+				    ha->host_no, ql4xdiscoverywait));
+
+				while (wait_cnt > jiffies){
+					if (test_bit(ISNS_FLAG_ISNS_SRV_ENABLED,
+					    &ha->isns_flags))
+						break;
+					QL4PRINT(QLP7, printk("."));
+					set_current_state(TASK_UNINTERRUPTIBLE);
+					schedule_timeout(1 * HZ);
+				}
+			}
+
+			if (!test_bit(ISNS_FLAG_ISNS_SRV_ENABLED,
+			    &ha->isns_flags)) {
+				QL4PRINT(QLP2, printk(KERN_WARNING
+				    "scsi%d: iSNS service failed to start\n",
+				    ha->host_no));
+			}
+		}
+
+		if (!ha->tot_ddbs)
+			QL4PRINT(QLP2, printk(KERN_WARNING
+			    "scsi%d: Failed to initialize devices\n",
+			    ha->host_no));
+	}
+
+	LEAVE("qla4xxx_initialize_adapter");
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_find_propname
+ *	Get property in database.
+ *
+ * Input:
+ *	ha = adapter structure pointer.
+ *      db = pointer to database
+ *      propstr = pointer to dest array for string
+ *	propname = name of property to search for.
+ *	siz = size of property
+ *
+ * Returns:
+ *	0 = no property
+ *      size = index of property
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_find_propname(scsi_qla_host_t *ha,
+		      char *propname, char *propstr,
+		      char *db, int siz)
+{
+	char    *cp;
+
+	/* find the specified string */
+	if (db) {
+		/* find the property name */
+		if ((cp = strstr(db,propname)) != NULL) {
+			while ((*cp)  && *cp != '=')
+				cp++;
+			if (*cp) {
+				strncpy(propstr, cp, siz+1);
+				propstr[siz+1] = '\0';
+				QL4PRINT(QLP7, printk("scsi%d: %s: found "
+						      "property = {%s}\n",
+						      ha->host_no, __func__,
+						      propstr));
+				return(siz);	       /* match */
+			}
+		}
+	}
+
+	return(0);
+}
+
+
+/**************************************************************************
+ * qla4xxx_get_prop_12chars
+ *	Get a 6-byte property value for the specified property name by
+ *      converting from the property string found in the configuration file.
+ *      The resulting converted value is in big endian format (MSB at byte0).
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	propname = property name pointer.
+ *	propval  = pointer to location for the converted property val.
+ *      db = pointer to database
+ *
+ * Returns:
+ *	0 = value returned successfully.
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4xxx_get_prop_12chars(scsi_qla_host_t *ha, uint8_t *propname,
+			 uint8_t *propval, uint8_t *db)
+{
+	char            *propstr;
+	int             i, k;
+	int             rval;
+	uint8_t         nval;
+	uint8_t         *pchar;
+	uint8_t         *ret_byte;
+	uint8_t         *tmp_byte;
+	uint8_t         *retval = (uint8_t*)propval;
+	uint8_t         tmpval[6] = {0, 0, 0, 0, 0, 0};
+	uint16_t        max_byte_cnt = 6;	  /* 12 chars = 6 bytes */
+	uint16_t        max_strlen = 12;
+	static char     buf[LINESIZE];
+
+	rval = qla4xxx_find_propname(ha, propname, buf, db, max_strlen);
+
+	propstr = &buf[0];
+	if (*propstr == '=')
+		propstr++;	     /* ignore equal sign */
+
+	if (rval == 0) {
+		return(1);
+	}
+
+	/* Convert string to numbers. */
+	pchar = (uint8_t *)propstr;
+	tmp_byte = (uint8_t *)tmpval;
+
+	rval = 0;
+	for (i = 0; i < max_strlen; i++) {
+		/*
+		 * Check for invalid character, two at a time,
+		 * then convert them starting with first byte.
+		 */
+
+		if ((pchar[i] >= '0') && (pchar[i] <= '9')) {
+			nval = pchar[i] - '0';
+		}
+		else if ((pchar[i] >= 'A') && (pchar[i] <= 'F')) {
+			nval = pchar[i] - 'A' + 10;
+		}
+		else if ((pchar[i] >= 'a') && (pchar[i] <= 'f')) {
+			nval = pchar[i] - 'a' + 10;
+		}
+		else {
+			/* invalid character */
+			rval = 1;
+			break;
+		}
+
+		if (i & 0x01) {
+			*tmp_byte = *tmp_byte | nval;
+			tmp_byte++;
+		}
+		else {
+			*tmp_byte = *tmp_byte | nval << 4;
+		}
+	}
+
+	if (rval != 0) {
+		/* Encountered invalid character. */
+		return(rval);
+	}
+
+	/* Copy over the converted value. */
+	ret_byte = retval;
+	tmp_byte = tmpval;
+
+	i = max_byte_cnt;
+	k = 0;
+	while (i--) {
+		*ret_byte++ = *tmp_byte++;
+	}
+
+	/* big endian retval[0]; */
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_add_device_dynamically
+ *	This routine processes adds a device as a result of an 8014h AEN.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_add_device_dynamically(scsi_qla_host_t *ha,
+			       uint32_t fw_ddb_index)
+{
+	ddb_entry_t *ddb_entry;
+
+	ENTER("qla4xxx_add_device_dynamically");
+
+	/* First allocate a device structure */
+	ddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index);
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "scsi%d: Unable to allocate memory to add fw_ddb_index "
+		    "%d\n", ha->host_no, fw_ddb_index));
+	} else if (qla4xxx_update_ddb_entry(ha, ddb_entry) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "scsi%d: failed to add new device at index [%d]\n"
+		    "Unable to retrieve fw ddb entry\n", ha->host_no,
+		    fw_ddb_index));
+	} else {
+		/* New device. Let's add it to the database */
+		QL4PRINT(QLP7, printk("scsi%d: %s: new device at index [%d]\n",
+		    ha->host_no, __func__, fw_ddb_index));
+
+		qla4xxx_update_fcport(ha, ddb_entry->fcport);
+		qla4xxx_config_os(ha);
+	}
+
+	LEAVE("qla4xxx_add_device_dynamically");
+}
+
+
+/**************************************************************************
+ * qla4xxx_process_ddb_changed
+ *	This routine processes a Decive Database Changed AEN Event.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      state - Device state
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully processed ddb_changed aen
+ *	QLA_ERROR   - Failed to process ddb_changed aen
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_process_ddb_changed(scsi_qla_host_t *ha, uint32_t fw_ddb_index,
+    uint32_t state)
+{
+	ddb_entry_t *ddb_entry;
+	uint32_t    old_fw_ddb_device_state;
+
+	ENTER(__func__);
+
+	/* check for out of range index */
+	if (fw_ddb_index >= MAX_DDB_ENTRIES) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: device index [%d] out of "
+		    "range\n", ha->host_no, __func__, fw_ddb_index));
+
+		LEAVE(__func__);
+		return (QLA_ERROR);
+	}
+
+	/* Get the corresponging ddb entry */
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+
+	/* Device does not currently exist in our database. */
+	if (ddb_entry == NULL) {
+		if (state == DDB_DS_SESSION_ACTIVE) {
+			qla4xxx_add_device_dynamically(ha, fw_ddb_index);
+		}
+//FIXME: Is this really necessary?
+#if 0
+		else if (state == DDB_DS_SESSION_FAILED ) {
+			ddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index);
+			if( ddb_entry ) {
+		       	    atomic_set(&ddb_entry->retry_relogin_timer,
+			    ddb_entry->default_time2wait);
+			    qla4xxx_mark_device_missing(ha, ddb_entry);
+			}
+		}
+#endif
+		LEAVE(__func__);
+
+		return (QLA_SUCCESS);
+	}
+
+	/* Device already exists in our database. */
+	old_fw_ddb_device_state = ddb_entry->fw_ddb_device_state;
+	DEBUG2(printk("scsi%d: %s DDB - old fw state= 0x%x, "
+		"new fw state=0x%x for index [%d]\n",
+		ha->host_no, __func__, ddb_entry->fw_ddb_device_state,
+		state,
+		fw_ddb_index));
+	if (old_fw_ddb_device_state == state) {
+		/* Do nothing, state not changed. */
+		LEAVE(__func__);
+
+		return (QLA_SUCCESS);
+	}
+
+//FIXME: Is this really necessary?
+#if 0
+	if (qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index, NULL, 0, NULL,
+	    NULL, &ddb_entry->fw_ddb_device_state, NULL, NULL, NULL) ==
+	    QLA_ERROR) {
+		#if 0
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: unable to retrieve "
+				"fw_ddb_device_state for index [%d]\n",
+				ha->host_no, __func__, fw_ddb_index));
+
+		LEAVE(__func__);
+		return(QLA_ERROR);
+		#else
+		ddb_entry->fw_ddb_device_state = state;
+		#endif
+	}
+	
+	DEBUG2(printk("scsi%d: %s DDB after query - old fw state= 0x%x, "
+		"new fw state=0x%x for index [%d]\n",
+		ha->host_no, __func__, ddb_entry->fw_ddb_device_state,
+		state,
+		fw_ddb_index));
+#else
+	ddb_entry->fw_ddb_device_state = state;
+#endif
+	/* Device is back online. */
+	if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+		atomic_set(&ddb_entry->port_down_timer,
+		    ha->port_down_retry_count);
+		atomic_set(&ddb_entry->state, DEV_STATE_ONLINE);
+		atomic_set(&ddb_entry->relogin_retry_count, 0);
+		atomic_set(&ddb_entry->relogin_timer, 0);
+		clear_bit(DF_RELOGIN, &ddb_entry->flags);
+		clear_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+		qla4xxx_update_fcport(ha, ddb_entry->fcport);
+
+/* XXX FIXUP LUN_READY/SUSPEND code -- dg */
+		/*
+		 * Change the lun state to READY in case the lun TIMEOUT before
+		 * the device came back.
+		 */
+		if (ddb_entry->fcport->vis_ha) {
+			int t, l;
+			unsigned long cpu_flags;
+			os_lun_t *lq;
+			scsi_qla_host_t *os_ha;
+
+			os_ha = ddb_entry->fcport->vis_ha;
+			for (t = 0; t < MAX_TARGETS; t++) {
+				for (l = 0; l < MAX_LUNS; l++) {
+					if (!(lq = GET_LU_Q(os_ha, t, l)))
+						continue;
+
+					spin_lock_irqsave(&lq->lun_lock,
+						cpu_flags);
+					lq->lun_state = LS_LUN_READY;
+					ddb_entry->fcport->vis_ha = NULL;
+					spin_unlock_irqrestore(&lq->lun_lock,
+				    		cpu_flags);
+
+				}
+			}
+		}
+
+		// DG XXX
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+		set_bit(DPC_FAILOVER_EVENT_NEEDED, &ha->dpc_flags);
+		ha->failover_type = MP_NOTIFY_LOOP_UP;
+#endif
+	} else {		
+		/* Device went away, try to relogin. */
+		/* Mark device missing */
+		if (atomic_read(&ddb_entry->state) == DEV_STATE_ONLINE)
+			qla4xxx_mark_device_missing(ha, ddb_entry);
+
+		/*
+		 * Relogin if device state changed to a not active state.
+		 * However, do not relogin if this aen is a result of an IOCTL
+		 * logout (DF_NO_RELOGIN) or if this is a discovered device.
+		 */
+		if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_FAILED &&
+		    (!test_bit(DF_RELOGIN, &ddb_entry->flags)) &&
+		    (!test_bit(DF_NO_RELOGIN, &ddb_entry->flags)) &&
+		    (!test_bit(DF_ISNS_DISCOVERED, &ddb_entry->flags))) {
+			QL4PRINT(QLP3, printk("scsi%d:%d:%d: index [%d] "
+			    "initate relogin after %d seconds\n", ha->host_no,
+			    ddb_entry->bus, ddb_entry->target,
+			    ddb_entry->fw_ddb_index,
+			    ddb_entry->default_time2wait));
+
+#ifndef CONFIG_SCSI_QLA4XXX_FAILOVER
+			// DG XXX
+			qla4xxx_update_fcport(ha, ddb_entry->fcport);
+#endif
+
+			/*
+			 * This triggers a relogin.  After the relogin_timer
+			 * expires, the relogin gets scheduled.  We must wait a
+			 * minimum amount of time since receiving an 0x8014 AEN
+			 * with failed device_state or a logout response before
+			 * we can issue another relogin.
+			 */
+			atomic_set(&ddb_entry->retry_relogin_timer,
+			    ddb_entry->default_time2wait);
+		}
+	}
+
+	LEAVE(__func__);
+
+	return (QLA_SUCCESS);
+}
+
+
+/**************************************************************************
+ * qla4xxx_login_device
+ *	This routine is called by the login IOCTL to log in the specified
+ *	device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to login
+ * 	connection_id - Connection ID of the device to login
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully logged in device
+ *	QLA_ERROR   - Failed to login device
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_login_device(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+    uint16_t connection_id)
+{
+	ddb_entry_t *ddb_entry;
+	uint8_t status = QLA_ERROR;
+
+	ENTER("qla4xxx_login_device");
+
+	QL4PRINT(QLP3, printk("scsi%d: %s: Login index [%d]\n", ha->host_no,
+	    __func__, fw_ddb_index));
+
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid index [%d]\n",
+		    ha->host_no, __func__, fw_ddb_index));
+		goto exit_login_device;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+	    &ddb_entry->fw_ddb_device_state, NULL, NULL, NULL) == QLA_ERROR) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: 1st get ddb entry failed\n",
+		    ha->host_no, __func__));
+		goto exit_login_device;
+	}
+
+	if (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {
+		QL4PRINT(QLP3, printk("scsi%d: %s: login successful for index "
+		    "[%d]\n", ha->host_no, __func__, ddb_entry->fw_ddb_index));
+
+		status = QLA_SUCCESS;
+
+		goto exit_login_device;
+	}
+
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+	    LOGOUT_OPTION_RELOGIN) != QLA_SUCCESS) {
+		goto exit_login_device;
+	}
+
+	status = QLA_SUCCESS;
+
+exit_login_device:
+	LEAVE("qla4xxx_login_device");
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_logout_device
+ *	This support routine is called by the logout IOCTL to log out
+ *	the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to logout
+ * 	connection_id - Connection ID of the device to logout
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully logged out device
+ *	QLA_ERROR   - Failed to logout device
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_logout_device(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+    uint16_t connection_id)
+{
+	uint8_t     status = QLA_ERROR;
+	ddb_entry_t *ddb_entry;
+	uint32_t    old_fw_ddb_device_state;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered. index=%d.\n",
+	    ha->host_no, __func__, ha->instance, fw_ddb_index));
+
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: Invalid index [%d]\n",
+		    ha->host_no, __func__, fw_ddb_index));
+		goto exit_logout_device;
+	}
+
+	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+	    &old_fw_ddb_device_state, NULL, NULL, NULL) != QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: get_ddb_entry failed\n",
+		    ha->host_no, __func__));
+		goto exit_logout_device;
+	}
+
+	set_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+	    LOGOUT_OPTION_CLOSE_SESSION) != QLA_SUCCESS) {
+		goto exit_logout_device;
+	}
+
+	status = QLA_SUCCESS;
+
+exit_logout_device:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return (status);
+}
+
+void
+qla4xxx_flush_all_srbs(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry,
+    os_lun_t *lun_entry)
+{
+	int         i;
+	unsigned long flags;
+	srb_t       *srb, *stemp;
+
+	if (lun_entry == NULL || ddb_entry == NULL)
+		return;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	/* free pending commands */
+	list_for_each_entry_safe(srb, stemp, &ha->pending_srb_q, list_entry) {
+		QL4PRINT(QLP3, printk("scsi%d:%d:%d:%d: %s: found srb %p in "
+		    "pending_q\n", ha->host_no, ddb_entry->bus,
+		    ddb_entry->target, lun_entry->lun, __func__, srb));
+
+		if (srb->lun_queue != lun_entry)
+			continue;
+
+		QL4PRINT(QLP3, printk("scsi%d:%d:%d:%d: %s: flushing srb %p "
+		    "from pending_q\n", ha->host_no, ddb_entry->bus,
+		    ddb_entry->target, lun_entry->lun, __func__, srb));
+
+		__del_from_pending_srb_q(ha, srb);
+		srb->cmd->result = DID_NO_CONNECT << 16;
+		__add_to_done_srb_q(ha, srb);
+	}
+
+	/* free retry commands */
+	list_for_each_entry_safe(srb, stemp, &ha->retry_srb_q, list_entry) {
+		QL4PRINT(QLP3, printk("scsi%d:%d:%d:%d: %s: found srb %p in "
+		    "retry_q\n", ha->host_no, ddb_entry->bus,
+		    ddb_entry->target, lun_entry->lun, __func__, srb));
+
+		if (srb->lun_queue != lun_entry)
+			continue;
+
+		QL4PRINT(QLP3, printk("scsi%d:%d:%d:%d: %s: flushing srb %p "
+		    "from retry_q\n", ha->host_no, ddb_entry->bus,
+		    ddb_entry->target, lun_entry->lun, __func__, srb));
+
+		__del_from_retry_srb_q(ha, srb);
+		srb->cmd->result = DID_NO_CONNECT << 16;
+		__add_to_done_srb_q(ha, srb);
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	/* free active commands */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	if (lun_entry->out_count != 0) {
+		for (i = 1; i < MAX_SRBS; i++) {
+			srb = ha->active_srb_array[i];
+			if (!srb)
+				continue;
+
+			QL4PRINT(QLP3, printk("scsi%d:%d:%d:%d: %s: found srb "
+			    "%p in active_q\n", ha->host_no, ddb_entry->bus,
+			    ddb_entry->target, lun_entry->lun, __func__, srb));
+
+			if (srb->lun_queue != lun_entry)
+				continue;
+
+			QL4PRINT(QLP3, printk("scsi%d:%d:%d:%d: %s: flushing "
+			    "srb %p from active_q\n", ha->host_no,
+			    ddb_entry->bus, ddb_entry->target, lun_entry->lun,
+			    __func__, srb));
+			del_from_active_array(ha, i);
+			srb->cmd->result = DID_NO_CONNECT << 16;
+			add_to_done_srb_q(ha,srb);
+		}
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Free Failover commands */
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	qla4xxx_flush_failover_q(ha, lun_entry);
+#endif
+
+	/* Send all srbs back to OS */
+	if (!list_empty(&ha->done_srb_q)) {
+		while ((srb = del_from_done_srb_q_head(ha)) != NULL)
+			qla4xxx_complete_request(ha, srb);
+	}
+}
+
+
+/**************************************************************************
+ * qla4xxx_delete_device
+ *	This routine is called by the logout IOCTL to delete the specified
+ *      device.	 Send the LOGOUT and DELETE_DDB commands for the specified
+ *      target, even if it's not in our internal database.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ * 	fw_ddb_index - Index of the device to delete
+ * 	connection_id - Connection ID of the device to delete
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully deleted device
+ *	QLA_ERROR   - Failed to delete device
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_delete_device(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+    uint16_t connection_id)
+{
+	uint8_t     status = QLA_ERROR;
+	uint32_t    fw_ddb_device_state = 0xFFFF;
+	u_long     wait_count;
+	ddb_entry_t *ddb_entry;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered. index=%d.\n",
+	    ha->host_no, __func__, ha->instance, fw_ddb_index));
+
+	/* If the device is in our internal tables, set the NO_RELOGIN bit. */
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);
+	if (ddb_entry != NULL) {
+		QL4PRINT(QLP4,
+		    printk("scsi%d:%d:%d: %s:  setting NO_RELOGIN flag\n",
+		    ha->host_no, ddb_entry->bus, ddb_entry->target, __func__));
+
+		set_bit(DF_NO_RELOGIN, &ddb_entry->flags);
+	}
+
+	/*
+	 * If the device state is already one that we can delete, bypass the
+	 * logout command.
+	 */
+	qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+	    &fw_ddb_device_state, NULL, NULL, NULL);
+	if (fw_ddb_device_state == DDB_DS_UNASSIGNED ||
+	    fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE ||
+	    fw_ddb_device_state == DDB_DS_SESSION_FAILED)
+		goto delete_ddb;
+
+	/* First logout index */
+	if (qla4xxx_conn_close_sess_logout(ha, fw_ddb_index, connection_id,
+	    LOGOUT_OPTION_CLOSE_SESSION) != QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: LOGOUT_OPTION_CLOSE_SESSION "
+		    "failed index [%d]\n", ha->host_no, __func__,
+		    fw_ddb_index));
+		goto exit_delete_ddb;
+	}
+
+	/* Wait enough time to complete logout */
+	wait_count = jiffies + LOGOUT_TOV * HZ;
+	while (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, NULL, 0, NULL, NULL,
+	    &fw_ddb_device_state, NULL, NULL, NULL) == QLA_SUCCESS) {
+		if (wait_count <= jiffies)
+			goto exit_delete_ddb;
+
+		if (fw_ddb_device_state == DDB_DS_UNASSIGNED ||
+                    fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE ||
+                    fw_ddb_device_state == DDB_DS_SESSION_FAILED)
+			break;
+
+		udelay(50);
+	}
+
+delete_ddb:
+	/* Now delete index */
+	if (qla4xxx_clear_database_entry(ha, fw_ddb_index) == QLA_SUCCESS) {
+		uint16_t lun;
+		os_lun_t *lun_entry;
+		os_tgt_t *tgt_entry;
+
+		status = QLA_SUCCESS;
+		if (!ddb_entry)
+			goto exit_delete_ddb;
+
+		atomic_set(&ddb_entry->state, DEV_STATE_DEAD);
+		atomic_set(&ddb_entry->fcport->state, FCS_DEVICE_DEAD);
+/* XXX FIXUP LUN_READY/SUSPEND code -- dg */
+		tgt_entry = qla4xxx_lookup_target_by_fcport(ha,
+		    ddb_entry->fcport);
+		if (tgt_entry) {
+			for (lun = 0; lun < MAX_LUNS; lun++) {
+				lun_entry = tgt_entry->olun[lun];
+				if (lun_entry != NULL) {
+					unsigned long cpu_flags;
+
+					spin_lock_irqsave(&lun_entry->lun_lock,
+					    cpu_flags);
+
+					QL4PRINT(QLP4, printk(
+					    "scsi%d:%d:%d:%d: %s: flushing "
+					    "srbs, pendq_cnt=%d, retryq_cnt="
+					    "%d, activeq_cnt=%d\n", ha->host_no,
+					    ddb_entry->bus, tgt_entry->id, lun,
+					    __func__, ha->pending_srb_q_count,
+					    ha->retry_srb_q_count,
+					    ha->active_srb_count));
+
+					qla4xxx_flush_all_srbs(ha, ddb_entry,
+					    lun_entry);
+					if (lun_entry->lun_state ==
+					    LS_LUN_SUSPENDED) {
+						lun_entry->lun_state =
+						    LS_LUN_READY;
+					}
+
+					spin_unlock_irqrestore(
+					    &lun_entry->lun_lock, cpu_flags);
+				}
+			}
+		}
+		ha->fw_ddb_index_map[fw_ddb_index] = 
+		    (ddb_entry_t *) INVALID_ENTRY;
+		// qla4xxx_free_ddb(ha, ddb_entry);
+	}
+
+exit_delete_ddb:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return (status);
+}
+
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_inline.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_inline.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_inline.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_inline.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,276 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *
+ ****************************************************************************/
+
+/**************************************************************************
+ * qla4xxx_lookup_lun_handle
+ *	This routine locates a lun handle given the device handle and lun
+ *	number.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *	lun - SCSI LUN
+ *
+ * Returns:
+ *	Pointer to corresponding lun_entry structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline os_lun_t *
+qla4xxx_lookup_lun_handle(scsi_qla_host_t *ha, os_tgt_t *tq, uint16_t lun)
+{
+	os_lun_t *lq = NULL;
+
+	if (tq && lun < MAX_LUNS)
+		lq = tq->olun[lun];
+	 
+	QL4PRINT(QLP3, printk("scsi%d: %s: lun %d, lun_entry = %p\n",
+	    ha->host_no, __func__, lun, lq));
+
+	return lq;
+}
+
+/**************************************************************************
+ * qla4xxx_lookup_target_by_SCSIID
+ *	This routine locates a target handle given the SCSI bus and
+ *	target IDs.  If device doesn't exist, returns NULL.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	bus - SCSI bus number
+ *	target - SCSI target ID.
+ *
+ * Returns:
+ *	Pointer to the corresponding internal device database structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline os_tgt_t *
+qla4xxx_lookup_target_by_SCSIID(scsi_qla_host_t *ha, uint32_t bus,
+    uint32_t target)
+{
+	os_tgt_t *tq = NULL;
+
+	if (target < MAX_TARGETS)
+		tq = TGT_Q(ha, target);
+
+	QL4PRINT(QLP3, printk("scsi%d: %s: b%d:t%d, tgt = %p\n",
+	    ha->host_no, __func__, bus, target, tq));
+
+	return tq;
+}
+
+/**************************************************************************
+ * qla4xxx_lookup_target_by_fcport
+ *	This routine locates a target handle given the fcport
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	fcport - port handle
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline os_tgt_t *
+qla4xxx_lookup_target_by_fcport(scsi_qla_host_t *ha, fc_port_t  *fcport)
+{
+	int t;
+	os_tgt_t *tq = NULL;
+
+	for (t = 0; t < MAX_TARGETS; t++) {
+		if ((tq = TGT_Q(ha, t)) == NULL)
+			continue;
+
+		if (fcport == tq->fcport)
+			break;
+	}
+
+	return tq;
+}
+
+
+/**************************************************************************
+ * qla4xxx_lookup_ddb_by_fw_index
+ *	This routine locates a device handle given the firmware device
+ *	database index.  If device doesn't exist, returns NULL.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *
+ * Returns:
+ *	Pointer to the corresponding internal device database structure
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline ddb_entry_t *
+qla4xxx_lookup_ddb_by_fw_index(scsi_qla_host_t *ha, uint32_t fw_ddb_index)
+{
+	ddb_entry_t *ddb_entry = NULL;
+
+	if ((fw_ddb_index < MAX_DDB_ENTRIES) &&
+	    (ha->fw_ddb_index_map[fw_ddb_index] !=
+		(ddb_entry_t *) INVALID_ENTRY)) {
+		ddb_entry = ha->fw_ddb_index_map[fw_ddb_index];
+	}
+
+	QL4PRINT(QLP3, printk("scsi%d: %s: index [%d], ddb_entry = %p\n",
+	    ha->host_no, __func__, fw_ddb_index, ddb_entry));
+
+	return ddb_entry;
+}
+
+/**************************************************************************
+ * qla4xxx_mark_device_missing
+ *	This routine marks a device missing and resets the relogin retry count.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static inline void
+qla4xxx_mark_device_missing(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry)
+{
+	atomic_set(&ddb_entry->state, DEV_STATE_MISSING);
+	if (ddb_entry->fcport != NULL)
+		atomic_set(&ddb_entry->fcport->state, FCS_DEVICE_LOST);
+
+	QL4PRINT(QLP3, printk(KERN_INFO "scsi%d:%d:%d: index [%d] marked "
+	    "MISSING\n", ha->host_no, ddb_entry->bus, ddb_entry->target,
+	    ddb_entry->fw_ddb_index));
+}
+
+/**************************************************************************
+ * qla4xxx_enable_intrs
+ *	This routine enables the PCI interrupt request by clearing the
+ *	appropriate bit.
+ *
+ * qla4xxx_disable_intrs
+ *	This routine disables the PCI interrupt request by setting the
+ *	appropriate bit.
+ *
+ * Remarks:
+ *	The hardware_lock must be unlocked upon entry.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel/Interrupt context.
+ **************************************************************************/
+static inline void __qla4xxx_enable_intrs(scsi_qla_host_t *ha)
+{
+	ENTER("qla4xxx_enable_intrs");
+	set_bit(AF_INTERRUPTS_ON, &ha->flags);
+
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_INTR_ENABLE));
+	PCI_POSTING(&ha->reg->ctrl_status);
+	QL4PRINT(QLP7, printk("scsi%d: %s: intSET_RMASK = %08x\n",
+			      ha->host_no, __func__,
+			      RD_REG_DWORD(&ha->reg->ctrl_status)));
+	LEAVE("qla4xxx_enable_intrs");
+}
+
+static inline void __qla4xxx_disable_intrs(scsi_qla_host_t *ha)
+{
+
+	ENTER("qla4xxx_disable_intrs");
+	clear_bit(AF_INTERRUPTS_ON, &ha->flags);
+	
+	WRT_REG_DWORD(&ha->reg->ctrl_status, CLR_RMASK(CSR_SCSI_INTR_ENABLE));
+	PCI_POSTING(&ha->reg->ctrl_status);
+	QL4PRINT(QLP7, printk("scsi%d: %s: intSET_RMASK = %08x\n",
+			      ha->host_no, __func__,
+			      RD_REG_DWORD(&ha->reg->ctrl_status)));
+	LEAVE("qla4xxx_disable_intrs");
+}
+static inline void qla4xxx_enable_intrs(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__qla4xxx_enable_intrs(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+static inline void qla4xxx_disable_intrs(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	__qla4xxx_disable_intrs(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+static __inline__ void
+qla4xxx_suspend_lun(scsi_qla_host_t *, srb_t *sp, os_lun_t *, int, int);
+static __inline__ void
+qla4xxx_delay_lun(scsi_qla_host_t *, os_lun_t *, int);
+
+static __inline__ void
+qla4xxx_suspend_lun(scsi_qla_host_t *ha, srb_t *sp, os_lun_t *lq, int time, int count)
+{
+	return (__qla4xxx_suspend_lun(ha, sp, lq, time, count, 0));
+}
+
+static __inline__ void
+qla4xxx_delay_lun(scsi_qla_host_t *ha, os_lun_t *lq, int time)
+{
+	return (__qla4xxx_suspend_lun(ha, NULL, lq, time, 1, 1));
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_iocb.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_iocb.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_iocb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_iocb.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,420 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *      qla4xxx_get_req_pkt
+ *      qla4xxx_send_marker_iocb
+ *	qla4xxx_get_pdu
+ *	qla4xxx_free_pdu
+ *	qla4xxx_send_passthru0_iocb
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+/**************************************************************************
+ * qla4xxx_get_req_pkt
+ *	This routine performs the following tasks:
+ *	- returns the current request_in pointer (if queue not full)
+ *	- advances the request_in pointer
+ *	- checks for queue full
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	queue_entry - Pointer to pointer to queue entry structure
+ *
+ * Output:
+ *	queue_entry - Return pointer to next available request packet
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved request packet
+ *	QLA_ERROR   - Failed to retrieve request packet
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_req_pkt(scsi_qla_host_t *ha, QUEUE_ENTRY **queue_entry)
+{
+	uint16_t  request_in;
+	uint8_t   status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_get_req_pkt");
+
+	*queue_entry = ha->request_ptr;
+
+	/* get the latest request_in and request_out index */
+	request_in = ha->request_in;
+	ha->request_out =
+	    (uint16_t) le32_to_cpu(ha->shadow_regs->req_q_out);
+
+	/* Advance request queue pointer and check for queue full */
+	if (request_in == (REQUEST_QUEUE_DEPTH - 1)) {
+		request_in = 0;
+		ha->request_ptr = ha->request_ring;
+		QL4PRINT(QLP10, printk("scsi%d: %s: wraparound -- new "
+		    "request_in = %04x, new request_ptr = %p\n", ha->host_no,
+		    __func__, request_in, ha->request_ptr));
+	} else {
+		request_in++;
+		ha->request_ptr++;
+		QL4PRINT(QLP10, printk("scsi%d: %s: new request_in = %04x, new "
+		    "request_ptr = %p\n", ha->host_no, __func__, request_in,
+		    ha->request_ptr));
+	}
+
+	/* request queue is full, try again later */
+	if ((ha->iocb_cnt + 1) >= ha->iocb_hiwat) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: request queue is full, "
+		    "iocb_cnt=%d, iocb_hiwat=%d\n", ha->host_no, __func__,
+		    ha->iocb_cnt, ha->iocb_hiwat));
+
+		/* restore request pointer */
+		ha->request_ptr = *queue_entry;
+		QL4PRINT(QLP2, printk("scsi%d: %s: restore request_ptr = %p, "
+		    "request_in = %04x, request_out = %04x\n", ha->host_no,
+		    __func__, ha->request_ptr, ha->request_in,
+		    ha->request_out));
+		status = QLA_ERROR;
+	} else {
+		ha->request_in = request_in;
+		memset(*queue_entry, 0, sizeof(**queue_entry));
+	}
+
+	LEAVE("qla4xxx_get_req_pkt");
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_send_marker_iocb
+ *	This routine issues a marker IOCB.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *	lun - SCSI LUN
+ *	marker_type - marker identifier
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully sent marker IOCB
+ *	QLA_ERROR   - Failed to send marker IOCB
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_send_marker_iocb(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry,
+    fc_lun_t *lun_entry)
+{
+	MARKER_ENTRY *marker_entry;
+	unsigned long flags = 0;
+	uint8_t       status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_send_marker_iocb");
+
+	/* Acquire hardware specific lock */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Get pointer to the queue entry for the marker */
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &marker_entry)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: request queue full, try "
+		    "again later\n", ha->host_no, __func__));
+
+		status = QLA_ERROR;
+		goto exit_send_marker;
+	}
+
+	/* Put the marker in the request queue */
+	marker_entry->hdr.entryType = ET_MARKER;
+	marker_entry->hdr.entryCount = 1;
+	marker_entry->target = cpu_to_le16(ddb_entry->fw_ddb_index);
+	marker_entry->modifier = cpu_to_le16(MM_LUN_RESET);
+	marker_entry->lun[1] = LSB(lun_entry->lun);	 /*SAMII compliant lun*/
+	marker_entry->lun[2] = MSB(lun_entry->lun);
+	wmb();
+
+	QL4PRINT(QLP3, printk(KERN_INFO
+	    "scsi%d:%d:%d:%d: LUN_RESET Marker sent\n", ha->host_no,
+	    ddb_entry->bus, ddb_entry->target, lun_entry->lun));
+
+	/* Tell ISP it's got a new I/O request */
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+
+exit_send_marker:
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_send_marker_iocb");
+
+	return (status);
+}
+
+PDU_ENTRY *
+qla4xxx_get_pdu(scsi_qla_host_t *ha, uint32_t length)
+{
+	PDU_ENTRY       *pdu;
+	PDU_ENTRY       *free_pdu_top;
+	PDU_ENTRY       *free_pdu_bottom;
+	uint16_t        pdu_active;
+
+	uint16_t        i, j;
+	uint16_t        num_pages;
+	uint16_t        first_page;
+	uint16_t        free_pages;
+	uint8_t         pages_available;
+
+	if (ha->free_pdu_top == NULL) {
+		QL4PRINT(QLP2|QLP19,
+			 printk("scsi%d: %s: Out of PDUs!\n",
+				ha->host_no, __func__));
+		return(NULL);
+	}
+
+	/* Save current state */
+	free_pdu_top    = ha->free_pdu_top;
+	free_pdu_bottom = ha->free_pdu_bottom;
+
+	pdu = free_pdu_top;
+	free_pdu_top = pdu->Next;
+
+	if (free_pdu_top == NULL)
+		free_pdu_bottom = NULL;
+
+	pdu_active = ha->pdu_active + 1;
+
+	QL4PRINT(QLP19,
+		 printk("scsi%d: %s: Get PDU queue SUCCEEDED!  "
+			"Top %p Bot %p PDU %p Active %d\n",
+			ha->host_no, __func__,
+			free_pdu_top, free_pdu_bottom, pdu, pdu_active));
+
+	length = (length + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+	num_pages = (uint16_t) (length / PAGE_SIZE);
+	free_pages = 0;
+	first_page = (uint16_t) (-1);
+	pages_available = 0;
+
+	/* Try to allocate contiguous free pages */
+	for (i=0; i+num_pages <= MAX_PDU_ENTRIES; i++) {
+		if (!ha->pdu_buf_used[i]) {
+			first_page = i;
+			pages_available = 1;
+			for (j=i+1; j<num_pages; j++) {
+				if (ha->pdu_buf_used[j]) {
+					first_page = (uint16_t) (-1);
+					pages_available = 0;
+					i = j;
+					break;
+				}
+			}
+			if (pages_available)
+				break;
+		}
+	}
+	if (!pages_available) {
+		QL4PRINT(QLP2|QLP19,
+			 printk("scsi%d: %s: No contiguous pages available! "
+				"Top %p Bot %p PDU %p Active %d\n",
+				ha->host_no, __func__,
+				free_pdu_top, free_pdu_bottom, pdu, pdu_active));
+		return(NULL);
+	}
+
+	for (i=0; i<num_pages; i++)
+		ha->pdu_buf_used[first_page+i] = 1;
+
+	ha->free_pdu_top = free_pdu_top;
+	ha->free_pdu_bottom = free_pdu_bottom;
+	ha->pdu_active = pdu_active;
+
+	/* Fill in PDU */
+	pdu->Buff = (uint8_t *) (&(ha->pdu_buffsv) + (first_page * PAGE_SIZE));
+	pdu->BuffLen = length;
+	pdu->SendBuffLen = 0;
+	pdu->RecvBuffLen = 0;
+	pdu->Next = NULL;
+
+	QL4PRINT(QLP19,
+		 printk("scsi%d: %s: Get PDU buffers SUCCEEDED!  "
+			"Top %p Bot %p PDU %p Buf %p Length %x Active %d\n",
+			ha->host_no, __func__, free_pdu_top, free_pdu_bottom,
+			pdu, pdu->Buff, pdu->BuffLen, pdu_active));
+	return(pdu);
+}
+
+void qla4xxx_free_pdu(scsi_qla_host_t *ha, PDU_ENTRY *pdu)
+{
+	uint16_t first_page;
+	uint16_t num_pages;
+	uint16_t i;
+
+	if (ha->free_pdu_bottom == NULL) {
+		ha->free_pdu_top = pdu;
+		ha->free_pdu_bottom = pdu;
+	}
+	else {
+		ha->free_pdu_bottom->Next = pdu;
+		ha->free_pdu_bottom = pdu;
+	}
+
+	/* Free buffer resources */
+	first_page = (unsigned long) pdu->Buff - ((unsigned long) &ha->pdu_buffsv / PAGE_SIZE);
+	num_pages = (uint16_t) (pdu->BuffLen / PAGE_SIZE);
+	for (i=0; i<num_pages; i++)
+		ha->pdu_buf_used[first_page+i] = 0;
+	ha->pdu_active--;
+
+	QL4PRINT(QLP19,
+		 printk("scsi%d: %s: Top %p Bot %p PDU %p Buf %p Length %x Active %d\n",
+			ha->host_no, __func__, ha->free_pdu_top, ha->free_pdu_bottom,
+			pdu, pdu->Buff, pdu->BuffLen, ha->pdu_active));
+
+	/* Clear PDU */
+	pdu->Buff = NULL;
+	pdu->BuffLen = 0;
+	pdu->SendBuffLen = 0;
+	pdu->RecvBuffLen = 0;
+	pdu->Next = NULL;
+}
+
+/**************************************************************************
+ * qla4xxx_send_passthru0_iocb
+ *	This routine issues a passthru0 IOCB.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks: hardware_lock acquired upon entry, interrupt context
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully sent marker IOCB
+ *	QLA_ERROR   - Failed to send marker IOCB
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_send_passthru0_iocb(scsi_qla_host_t *ha,
+			    uint16_t fw_ddb_index,
+			    uint16_t connection_id,
+			    uint8_t *pdu_data,
+			    uint32_t send_len,
+			    uint32_t recv_len,
+			    uint16_t control_flags,
+			    uint32_t handle)
+{
+	PASSTHRU0_ENTRY *passthru_entry;
+	uint8_t         status = QLA_SUCCESS;
+	dma_addr_t      pdu_dma_data;
+
+	ENTER("qla4xxx_send_passthru0_iocb");
+
+	if (send_len) {
+		QL4PRINT(QLP19, printk("PDU (0x%p) ->\n", pdu_data));
+		qla4xxx_dump_bytes(QLP19, pdu_data, send_len);
+	}
+
+	/* Get pointer to the queue entry for the marker */
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &passthru_entry)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP5|QLP2|QLP19,
+			 printk("scsi%d: %s: request queue full, try again later\n",
+				ha->host_no, __func__));
+
+		status = QLA_ERROR;
+		goto exit_send_pt0;
+	}
+
+	/* Fill in the request queue */
+	passthru_entry->hdr.entryType  = ET_PASSTHRU0;
+	passthru_entry->hdr.entryCount = 1;
+	passthru_entry->handle         = cpu_to_le32(handle);
+	passthru_entry->target         = cpu_to_le16(fw_ddb_index);
+	passthru_entry->connectionID   = cpu_to_le16(connection_id);
+	passthru_entry->timeout        = __constant_cpu_to_le16(PT_DEFAULT_TIMEOUT);
+
+	pdu_dma_data = ha->pdu_buffsp;
+	
+	/* FIXMEdg: What is this ????  */
+	pdu_dma_data += ((unsigned long) pdu_data - ha->pdu_buffsp);
+
+	if (send_len) {
+		control_flags |= PT_FLAG_SEND_BUFFER;
+		passthru_entry->outDataSeg64.base.addrHigh  =
+		cpu_to_le32(MSDW(pdu_dma_data));
+		passthru_entry->outDataSeg64.base.addrLow   =
+		cpu_to_le32(LSDW(pdu_dma_data));
+		passthru_entry->outDataSeg64.count          =
+		cpu_to_le32(send_len);
+		QL4PRINT(QLP19,
+			 printk("scsi%d: %s: sending 0x%X bytes, "
+				"pdu_dma_data = %lx\n",
+				ha->host_no, __func__, send_len,
+				(unsigned long)pdu_dma_data));
+	}
+
+	if (recv_len) {
+		passthru_entry->inDataSeg64.base.addrHigh = cpu_to_le32(MSDW(pdu_dma_data));
+		passthru_entry->inDataSeg64.base.addrLow  = cpu_to_le32(LSDW(pdu_dma_data));
+		passthru_entry->inDataSeg64.count         = cpu_to_le32(recv_len);
+		QL4PRINT(QLP19, printk("scsi%d: %s: receiving  0x%X bytes, pdu_dma_data = %lx\n",
+				       ha->host_no, __func__, recv_len, (unsigned long)pdu_dma_data));
+	}
+
+	passthru_entry->controlFlags   = cpu_to_le16(control_flags);
+
+	wmb();
+
+	QL4PRINT(QLP19, printk(KERN_INFO "scsi%d: Passthru0 IOCB type %x count %x In (%x) %p\n",
+			       ha->host_no, passthru_entry->hdr.entryType,
+			       passthru_entry->hdr.entryCount, ha->request_in, passthru_entry));
+	qla4xxx_dump_bytes(QLP10, passthru_entry, sizeof(*passthru_entry));
+
+
+	/* Tell ISP it's got a new I/O request */
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+
+	exit_send_pt0:
+	LEAVE("qla4xxx_send_passthru0_iocb");
+	return(status);
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_ioctl.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_ioctl.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_ioctl.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,102 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+#ifndef _QL4_IOCTL_H_
+#define _QL4_IOCTL_H_
+
+#include <linux/blkdev.h>
+#include <asm/uaccess.h>
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct {
+	int cmd;
+	char *s;
+} ioctl_tbl_row_t;
+
+#define	QL_KMEM_ZALLOC(siz)	ql4_kzmalloc((siz), GFP_ATOMIC)
+#define	QL_KMEM_FREE(ptr)	kfree((ptr))
+
+/* Defines for Passthru */
+#define IOCTL_INVALID_STATUS			0xffff
+#define IOCTL_PASSTHRU_TOV			30
+
+/*
+ * extern from ql4_xioctl.c
+ */
+extern void *
+Q64BIT_TO_PTR(uint64_t);
+
+extern void *
+ql4_kzmalloc(int, int);
+
+extern char *
+IOCTL_TBL_STR(int, int);
+
+extern int
+qla4xxx_alloc_ioctl_mem(scsi_qla_host_t *);
+
+extern void
+qla4xxx_free_ioctl_mem(scsi_qla_host_t *);
+
+extern int
+qla4xxx_get_ioctl_scrap_mem(scsi_qla_host_t *, void **, uint32_t);
+
+extern void
+qla4xxx_free_ioctl_scrap_mem(scsi_qla_host_t *);
+
+/*
+ * from ql4_inioct.c
+ */
+extern ioctl_tbl_row_t IOCTL_SCMD_IGET_DATA_TBL[];
+extern ioctl_tbl_row_t IOCTL_SCMD_ISET_DATA_TBL[];
+
+extern int
+qla4intioctl_logout_iscsi(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_copy_fw_flash(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_iocb_passthru(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_ping(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_get_data(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_set_data(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+extern int
+qla4intioctl_hba_reset(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+/*
+ * from ql4_init.c
+ */
+extern uint8_t
+qla4xxx_logout_device(scsi_qla_host_t *, uint16_t, uint16_t);
+
+extern uint8_t
+qla4xxx_login_device(scsi_qla_host_t *, uint16_t, uint16_t);
+
+extern uint8_t
+qla4xxx_delete_device(scsi_qla_host_t *, uint16_t, uint16_t);
+
+#endif
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_isns.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_isns.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_isns.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_isns.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,2610 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	qla4xxx_strtolower
+ *	qla4xxx_isns_build_entity_id
+ *	qla4xxx_isns_reenable
+ *	qla4xxx_isns_enable_callback
+ *	qla4xxx_isns_restart_service
+ *	qla4xxx_isns_restart_service_completion
+ *	qla4xxx_isns_init_isns_reg_attr_list
+ *	qla4xxx_isns_init_isns_dereg_attr_list
+ *	qla4xxx_isns_init_isns_scn_reg_attr_list
+ *	qla4xxx_isns_init_isns_scn_dereg_attr_list
+ *	qla4xxx_isns_init_isns_dev_get_next_attr_list
+ *	qla4xxx_isns_init_isns_dev_attr_qry_attr_list
+ *	qla4xxx_isns_init_attributes
+ *	qla4xxx_isns_append_attribute
+ *	qla4xxx_isns_build_iocb_handle
+ *	qla4xxx_isns_get_server_request
+ *	qla4xxx_isns_build_scn_registration_packet
+ *	qla4xxx_isns_build_scn_deregistration_packet
+ *	qla4xxx_isns_build_registration_packet
+ *	qla4xxx_isns_build_deregistration_packet
+ *	qla4xxx_isns_build_request_packet
+ *	qla4xxx_isns_build_server_request_response_packet
+ *	qla4xxx_isns_build_dev_get_next_packet
+ *	qla4xxx_isns_build_dev_attr_qry_packet
+ *	qla4xxx_isns_parse_get_next_response
+ *	qla4xxx_isns_parse_query_response
+ *	qla4xxx_isns_process_response
+ *	qla4xxx_isns_reassemble_pdu
+ *	qla4xxx_isns_scn
+ *	qla4xxx_isns_esi
+ *	qla4xxx_isns_server_request_error
+ *	qla4xxx_isns_parse_and_dispatch_server_request
+ *	qla4xxx_isns_parse_and_dispatch_server_response
+ *	qla4xxx_isns_dev_attr_reg
+ *	qla4xxx_isns_dev_attr_reg_rsp
+ *	qla4xxx_isns_scn_reg
+ *	qla4xxx_isns_scn_reg_rsp
+ *	qla4xxx_isns_dev_attr_qry
+ *	qla4xxx_isns_dev_attr_qry_rsp
+ *	qla4xxx_isns_dev_get_next
+ *	qla4xxx_isns_dev_get_next_rsp
+ *	qla4xxx_isns_dev_dereg
+ *	qla4xxx_isns_dev_dereg_rsp
+ *	qla4xxx_isns_scn_dereg
+ *	qla4xxx_isns_scn_dereg_rsp
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+void     qla4xxx_isns_enable_callback(scsi_qla_host_t *, uint32_t, uint32_t, uint32_t, uint32_t);
+uint8_t  qla4xxx_isns_restart_service(scsi_qla_host_t *);
+uint32_t qla4xxx_isns_build_iocb_handle(scsi_qla_host_t *, uint32_t, PDU_ENTRY *);
+uint8_t  qla4xxx_isns_get_server_request(scsi_qla_host_t *, uint32_t, uint16_t);
+uint8_t  qla4xxx_isns_reassemble_pdu(scsi_qla_host_t *, uint8_t *, uint32_t *);
+uint8_t  qla4xxx_isns_parse_and_dispatch_server_request(scsi_qla_host_t *, uint8_t *, uint32_t, uint16_t);
+uint8_t  qla4xxx_isns_parse_and_dispatch_server_response(scsi_qla_host_t *, uint8_t *, uint32_t);
+uint8_t  qla4xxx_isns_build_scn_registration_packet(scsi_qla_host_t *ha,
+							   uint8_t *buffer,
+							   uint32_t buffer_size,
+							   uint32_t *packet_size);
+uint8_t  qla4xxx_isns_build_scn_deregistration_packet(scsi_qla_host_t *ha,
+							     uint8_t *buffer,
+							     uint32_t buffer_size,
+							     uint32_t *packet_size);
+uint8_t  qla4xxx_isns_build_registration_packet(scsi_qla_host_t *ha,
+						       uint8_t *buff,
+						       uint32_t buff_size,
+						       uint8_t *isns_entity_id,
+						       uint8_t *ip_addr,
+						       uint32_t port_number,
+						       uint32_t scn_port,
+						       uint32_t esi_port,
+						       uint8_t *local_alias,
+						       uint32_t *packet_size);
+uint8_t  qla4xxx_isns_build_deregistration_packet(scsi_qla_host_t *ha,
+							 uint8_t *buff,
+							 uint32_t buff_size,
+							 uint8_t *isns_entity_id,
+							 uint8_t *ip_addr,
+							 uint32_t port_number,
+							 uint32_t *packet_size);
+uint8_t  qla4xxx_isns_build_request_packet(scsi_qla_host_t *ha,
+						  uint8_t *buff,
+						  uint32_t buff_size,
+						  uint16_t function_id,
+						  uint16_t tx_id,
+						  uint8_t  use_replace_flag,
+						  ATTRIBUTE_LIST *attr_list,
+						  uint32_t *packet_size);
+uint8_t  qla4xxx_isns_append_attribute(scsi_qla_host_t *ha,
+					      uint8_t **buffer,
+					      uint8_t *buffer_end,
+					      ATTRIBUTE_LIST *attr_list);
+uint8_t  qla4xxx_isns_dev_attr_reg(scsi_qla_host_t *);
+
+uint8_t  qla4xxx_isns_dev_attr_reg_rsp(scsi_qla_host_t *ha,
+					      uint8_t *buffer,
+					      uint32_t buffer_size);
+uint8_t  qla4xxx_isns_dev_attr_qry_rsp(scsi_qla_host_t *ha,
+					      uint8_t *buffer,
+					      uint32_t buffer_size);
+uint8_t  qla4xxx_isns_dev_get_next_rsp(scsi_qla_host_t *ha,
+					      uint8_t *buffer,
+					      uint32_t buffer_size);
+uint8_t  qla4xxx_isns_dev_dereg_rsp(scsi_qla_host_t *ha,
+					   uint8_t *buffer,
+					   uint32_t buffer_size);
+uint8_t  qla4xxx_isns_scn_reg_rsp(scsi_qla_host_t *ha,
+					 uint8_t *buffer,
+					 uint32_t buffer_size);
+uint8_t  qla4xxx_isns_scn_dereg_rsp(scsi_qla_host_t *ha,
+					   uint8_t *buffer,
+					   uint32_t buffer_size);
+
+uint8_t  qla4xxx_isns_scn_dereg(scsi_qla_host_t *);
+uint8_t  qla4xxx_isns_scn_reg(scsi_qla_host_t *ha);
+uint8_t  qla4xxx_isns_dev_get_next (scsi_qla_host_t *ha,
+					   uint8_t *last_iscsi_name);
+
+
+const char *isns_error_code_msg[] = ISNS_ERROR_CODE_TBL();
+
+static void
+qla4xxx_strtolower(uint8_t *str)
+{
+	uint8_t *tmp;
+	for (tmp = str; *tmp != '\0'; tmp++) {
+		if (*tmp >= 'A' && *tmp <= 'Z')
+			*tmp += 'a' - 'A';
+	}
+}
+
+void
+qla4xxx_isns_build_entity_id(scsi_qla_host_t *ha)
+{
+	sprintf(ha->isns_entity_id, "eid:qlogic:qla4010-%s", ha->serial_number);
+	qla4xxx_strtolower(ha->isns_entity_id);
+}
+
+uint8_t
+qla4xxx_isns_reenable(scsi_qla_host_t *ha,
+		      uint32_t isns_ip_addr,
+		      uint16_t isns_server_port_num)
+{
+	set_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags);
+	ISNS_CLEAR_FLAGS(ha);
+
+	if (qla4xxx_isns_enable(ha, isns_ip_addr, isns_server_port_num)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Failed!\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+/* interrupt context, hardware lock set */
+void
+qla4xxx_isns_enable_callback(scsi_qla_host_t *ha,
+			     uint32_t svr,
+			     uint32_t scn,
+			     uint32_t esi,
+			     uint32_t nsh)
+{
+	ha->isns_connection_id   = (uint16_t) svr & 0x0000FFFF;
+	ha->isns_scn_conn_id     = (uint16_t) scn & 0x0000FFFF;
+	ha->isns_esi_conn_id     = (uint16_t) esi & 0x0000FFFF;
+	ha->isns_nsh_conn_id     = (uint16_t) nsh & 0x0000FFFF;
+
+	ha->isns_remote_port_num = (uint16_t) (svr >> 16);
+	ha->isns_scn_port_num    = (uint16_t) (scn >> 16);
+	ha->isns_esi_port_num    = (uint16_t) (esi >> 16);
+	ha->isns_nsh_port_num    = (uint16_t) (nsh >> 16);
+
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: iSNS Server TCP Connect succeeded %d\n",
+			ha->host_no, __func__, svr));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: Remote iSNS Server %d ConnID %x\n",
+			ha->host_no, __func__,
+			ha->isns_remote_port_num,
+			ha->isns_connection_id));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: Local  SCN  Listen %d ConnID %x\n",
+			ha->host_no, __func__,
+			ha->isns_scn_port_num,
+			ha->isns_scn_conn_id));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: Local  ESI  Listen %d ConnID %x\n",
+			ha->host_no, __func__,
+			ha->isns_esi_port_num,
+			ha->isns_esi_conn_id));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s: Local  HSN  Listen %d ConnID %x\n",
+			ha->host_no, __func__,
+			ha->isns_nsh_port_num,
+			ha->isns_nsh_conn_id));
+
+	if (ha->isns_connection_id == (uint16_t)-1) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: iSNS server refused connection\n",
+				ha->host_no, __func__));
+
+		qla4xxx_isns_restart_service(ha);
+		return;
+	}
+
+	set_bit(ISNS_FLAG_ISNS_SRV_ENABLED, &ha->isns_flags);
+
+	if (test_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags)) {
+		if (qla4xxx_isns_scn_dereg(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: qla4xxx_isns_scn_dereg failed!\n",
+					ha->host_no, __func__));
+			return;
+		}
+	}
+	else {
+		if (qla4xxx_isns_dev_attr_reg(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: qla4xxx_isns_dev_attr_reg failed!\n",
+					ha->host_no, __func__));
+			return;
+		}
+	}
+}
+
+
+uint8_t
+qla4xxx_isns_restart_service(scsi_qla_host_t *ha)
+{
+	qla4xxx_isns_disable(ha);
+	set_bit(ISNS_FLAG_RESTART_SERVICE, &ha->isns_flags);
+	ISNS_CLEAR_FLAGS(ha);
+
+	/* Set timer for restart to complete */
+	atomic_set(&ha->isns_restart_timer, ISNS_RESTART_TOV);
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_restart_service_completion(scsi_qla_host_t *ha,
+					uint32_t isns_ip_addr,
+					uint16_t isns_server_port_num)
+{
+	QL4PRINT(QLP20, printk("scsi%d: %s: isns_ip_addr %08x\n",
+			       ha->host_no, __func__, isns_ip_addr));
+
+	if (qla4xxx_isns_enable(ha, isns_ip_addr, isns_server_port_num)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: failed!\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+	else {
+		set_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags);
+		ISNS_CLEAR_FLAGS(ha);
+		return(QLA_SUCCESS);
+	}
+}
+
+
+static void
+qla4xxx_isns_init_isns_reg_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_reg_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},
+		// Entity ID.
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,   0},
+		// Operating attributes to register
+		{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},
+		{ ISNS_ATTR_TAG_ENTITY_PROTOCOL,   ISNS_ATTR_TYPE_ULONG,   DWSWAP(ENTITY_PROTOCOL_ISCSI)},
+		{ ISNS_ATTR_TAG_PORTAL_IP_ADDRESS, ISNS_ATTR_TYPE_ADDRESS, -1},
+		{ ISNS_ATTR_TAG_PORTAL_PORT,       ISNS_ATTR_TYPE_ULONG,   -1},
+		{ ISNS_ATTR_TAG_SCN_PORT,          ISNS_ATTR_TYPE_ULONG,   -1},
+		{ ISNS_ATTR_TAG_ESI_PORT,          ISNS_ATTR_TYPE_ULONG,   -1},
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_ULONG,   DWSWAP(ISCSI_NODE_TYPE_INITIATOR)},
+		{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_STRING,  -1},		// Friendly machine name?
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_reg_attr_list,          isns_reg_attr_list,          sizeof(isns_reg_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_dereg_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_dereg_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		// No key attribute for DevDereg
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,    0},
+		// Operating attributes
+		{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},		// FQDN
+#if 0
+		{ ISNS_ATTR_TAG_PORTAL_IP_ADDRESS, ISNS_ATTR_TYPE_ADDRESS, -1},
+		{ ISNS_ATTR_TAG_PORTAL_PORT,       ISNS_ATTR_TYPE_ULONG,   -1},
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+#endif
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_dereg_attr_list,        isns_dereg_attr_list,        sizeof(isns_dereg_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_scn_reg_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_scn_reg_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		// Key attributes
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+		// Required delimiter to indicate division between key and operating attrs.
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,   0},
+		// Operating attributes
+		{ ISNS_ATTR_TAG_ISCSI_SCN_BITMAP,  ISNS_ATTR_TYPE_ULONG,   DWSWAP(ISCSI_SCN_OBJECT_UPDATED |
+										  ISCSI_SCN_OBJECT_ADDED |
+										  ISCSI_SCN_OBJECT_REMOVED |
+										  ISCSI_SCN_TARGET_AND_SELF_INFO_ONLY)},
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_scn_reg_attr_list,      isns_scn_reg_attr_list,      sizeof(isns_scn_reg_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_scn_dereg_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_scn_dereg_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+		// Key attributes
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_scn_dereg_attr_list,    isns_scn_dereg_attr_list,    sizeof(isns_scn_dereg_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_dev_get_next_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_dev_get_next_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+		// Key attributes
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, -1},
+		// Required delimiter to indicate division between key and operating attrs.
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+		// Operating attributes (attributes of object matching key attribute to return)
+		{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_ULONG,  DWSWAP(ISCSI_NODE_TYPE_TARGET)},
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_dev_get_next_attr_list, isns_dev_get_next_attr_list, sizeof(isns_dev_get_next_attr_list));
+}
+
+static void
+qla4xxx_isns_init_isns_dev_attr_qry_attr_list(scsi_qla_host_t *ha)
+{
+	ATTRIBUTE_LIST isns_dev_attr_qry_attr_list[] = {
+		// Source attribute
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+		// Key attributes
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, -1},
+		// Required delimiter to indicate division between key and operating attrs.
+		{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+		// Operating attributes (attributes of objects matching key attributes to return)
+		{ ISNS_ATTR_TAG_ENTITY_PROTOCOL,   ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_EMPTY,  0},	// Friendly name
+		{ ISNS_ATTR_TAG_PORTAL_SYMBOLIC_NAME, ISNS_ATTR_TYPE_EMPTY, 0},
+		{ ISNS_ATTR_TAG_PORTAL_IP_ADDRESS, ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_PORTAL_PORT,       ISNS_ATTR_TYPE_EMPTY,  0},
+		{ ISNS_ATTR_TAG_PORTAL_SECURITY_BITMAP, ISNS_ATTR_TYPE_EMPTY, 0},
+		{ ISNS_ATTR_TAG_DD_ID,             ISNS_ATTR_TYPE_EMPTY,  0},
+
+		{ 0, 0, 0}		// Terminating NULL entry
+	};
+
+	memcpy(ha->isns_dev_attr_qry_attr_list, isns_dev_attr_qry_attr_list, sizeof(isns_dev_attr_qry_attr_list));
+}
+
+uint8_t
+qla4xxx_isns_init_attributes (scsi_qla_host_t *ha)
+{
+	/* Separate these calls to minimize stack usage */
+
+	qla4xxx_isns_init_isns_reg_attr_list(ha);
+	qla4xxx_isns_init_isns_dereg_attr_list(ha);
+	qla4xxx_isns_init_isns_scn_reg_attr_list(ha);
+	qla4xxx_isns_init_isns_scn_dereg_attr_list(ha);
+	qla4xxx_isns_init_isns_dev_get_next_attr_list(ha);
+	qla4xxx_isns_init_isns_dev_attr_qry_attr_list(ha);
+
+#if 0
+	{
+		ATTRIBUTE_LIST asRegUpdateAddObjectsAttrList[] = {
+			// Source attribute
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			// We are adding objects to an Entity so specify the Entity as the Key
+			{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING, -1},	// FQDN
+			{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+			// Operating attributes to register
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_ULONG,  DWSWAP(ISCSI_NODE_TYPE_INITIATOR)},
+			{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_STRING, -1},	    // Friendly machine name?
+
+			{ 0, 0, 0}	// Terminating NULL entry
+		};
+
+		ATTRIBUTE_LIST asRegUpdateNodeAttrList[] = {
+			// Source attribute
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			// We updating attributes of a Node so specify the Node as the Key
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+			// Operating attributes to update
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_STRING, -1},	    // Friendly machine name?
+
+			{ 0, 0, 0}	// Terminating NULL entry
+		};
+
+		ATTRIBUTE_LIST asRegReplaceNodeAttrList[] = {
+			// Source attribute
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			// We updating attributes of a Node so specify the Node as the Key
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,  0},
+			// Operating attributes to update
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING, (unsigned long) ha->name_string},
+			{ ISNS_ATTR_TAG_ISCSI_NODE_TYPE,   ISNS_ATTR_TYPE_ULONG,  DWSWAP(ISCSI_NODE_TYPE_INITIATOR)},
+			{ ISNS_ATTR_TAG_ISCSI_ALIAS,       ISNS_ATTR_TYPE_STRING, -1},	    // Friendly machine name?
+
+			{ 0, 0, 0}	// Terminating NULL entry
+		};
+
+		ATTRIBUTE_LIST asRegUpdateEntityAttrList[] = {
+			// Source attribute
+			{ ISNS_ATTR_TAG_ISCSI_NAME,        ISNS_ATTR_TYPE_STRING,  (unsigned long) ha->name_string},
+			// We updating attributes of an Entity so specify the Entity as the Key
+			{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},	 // FQDN
+			{ ISNS_ATTR_TAG_DELIMITER,         ISNS_ATTR_TYPE_EMPTY,   0},
+			// Operating attributes to update
+			{ ISNS_ATTR_TAG_ENTITY_IDENTIFIER, ISNS_ATTR_TYPE_STRING,  -1},	 // FQDN
+			{ ISNS_ATTR_TAG_MGMT_IP_ADDRESS,   ISNS_ATTR_TYPE_ADDRESS, -1},
+
+			{ 0, 0, 0}	// Terminating NULL entry
+		};
+
+		memcpy(ha->asRegUpdateAddObjectsAttrList, asRegUpdateAddObjectsAttrList, sizeof(asRegUpdateAddObjectsAttrList));
+		memcpy(ha->asRegUpdateNodeAttrList,       asRegUpdateNodeAttrList,       sizeof(asRegUpdateNodeAttrList));
+		memcpy(ha->asRegReplaceNodeAttrList,      asRegReplaceNodeAttrList,      sizeof(asRegReplaceNodeAttrList));
+		memcpy(ha->asRegUpdateEntityAttrList,     asRegUpdateEntityAttrList,     sizeof(asRegUpdateEntityAttrList));
+	}
+#endif
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_append_attribute(scsi_qla_host_t *ha,
+			      uint8_t **buffer,
+			      uint8_t *buffer_end,
+			      ATTRIBUTE_LIST *attribute)
+{
+
+	ISNS_ATTRIBUTE *isns_attr;
+	uint32_t data_len;
+	uint8_t *local;
+
+	isns_attr =  (ISNS_ATTRIBUTE *) *buffer;
+
+	switch (attribute->type) {
+	case ISNS_ATTR_TYPE_EMPTY:
+		data_len = 0;
+		if ((isns_attr->value + data_len) > buffer_end) {
+			return(QLA_ERROR);
+		}
+		isns_attr->tag = attribute->isns_tag;
+		isns_attr->length = data_len;
+		break;
+
+	case ISNS_ATTR_TYPE_STRING:
+		/*
+		 * Length must include NULL terminator.
+		 * Note also that all iSNS strings must be UTF-8 encoded.
+		 * You should encode your strings for UTF-8 before registering
+		 * them with the iSNS server.
+		 */
+		data_len = strlen ((uint8_t *) (unsigned long) attribute->data) + sizeof(uint8_t);
+		if (data_len % 4) {
+			data_len += (4 - (data_len % 4)); // Pad to 4 byte boundary.
+		}
+		if ((isns_attr->value + data_len) > buffer_end) {
+			return(QLA_ERROR);
+		}
+		isns_attr->tag = attribute->isns_tag;
+		isns_attr->length = data_len;
+		memset(isns_attr->value, 0, data_len);
+		strcpy (&isns_attr->value[0], (uint8_t *) (unsigned long) attribute->data);
+		break;
+
+	case ISNS_ATTR_TYPE_ULONG:
+		data_len = sizeof(uint32_t);
+		if ((isns_attr->value + data_len) > buffer_end) {
+			return(QLA_ERROR);
+		}
+		isns_attr->tag = attribute->isns_tag;
+		isns_attr->length = data_len;
+		*(uint32_t *) isns_attr->value = (uint32_t) attribute->data;
+		break;
+
+	case ISNS_ATTR_TYPE_ADDRESS:
+		local = (uint8_t *) (unsigned long) attribute->data;
+		data_len = 16;	     // Size of an IPv6 address
+		if ((isns_attr->value + data_len) > buffer_end) {
+			return(QLA_ERROR);
+		}
+		isns_attr->tag = attribute->isns_tag;
+		isns_attr->length = data_len;
+		// WARNING: This doesn't handle IPv6 addresses.
+		memset(isns_attr->value, 0, 16);
+		isns_attr->value[12] = local[0];
+		isns_attr->value[13] = local[1];
+		isns_attr->value[14] = local[2];
+		isns_attr->value[15] = local[3];
+		break;
+
+	default:
+		return(QLA_ERROR);
+
+	}
+
+	*buffer = isns_attr->value + isns_attr->length;
+
+	// Swap Tag and Length values.
+
+	isns_attr->tag = DWSWAP(isns_attr->tag);
+	isns_attr->length = DWSWAP(isns_attr->length);
+
+	return(QLA_SUCCESS);
+}
+
+
+uint32_t
+qla4xxx_isns_build_iocb_handle(scsi_qla_host_t *ha,
+			       uint32_t type,
+			       PDU_ENTRY *pdu_entry)
+{
+	uint32_t handle;
+
+	handle = (IOCB_ISNS_PT_PDU_TYPE(type) |
+		  (((uint8_t *)pdu_entry - (uint8_t *)ha->pdu_queue)
+		   / sizeof(PDU_ENTRY)));
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: type %x PDU %p = handle %x\n",
+			       ha->host_no, __func__,
+			       type, pdu_entry, handle));
+	return(handle);
+}
+
+/*
+ * Remarks:
+ *      hardware_lock locked upon entry
+ */
+uint8_t
+qla4xxx_isns_get_server_request(scsi_qla_host_t *ha,
+				uint32_t pdu_buff_len,
+				uint16_t connection_id)
+{
+	PDU_ENTRY *pdu_entry;
+
+	pdu_entry = qla4xxx_get_pdu(ha, MAX(pdu_buff_len, PAGE_SIZE));
+	if (pdu_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = 0;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX, connection_id,
+					pdu_entry->Buff, pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, /*ISNS_REQ_RSP_PDU*/ISNS_ASYNCH_REQ_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: send_passthru_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_build_scn_registration_packet(scsi_qla_host_t *ha,
+					   uint8_t *buffer,
+					   uint32_t buffer_size,
+					   uint32_t *packet_size)
+{
+	/*
+	 * Fill in all of the run time requested data in the attribute array
+	 * then call iSNSBuildRequestPacket to do the actual work.
+	 */
+
+	return(qla4xxx_isns_build_request_packet(ha, buffer, buffer_size,
+						 ISNS_FCID_SCNReg,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_scn_reg_attr_list,
+						 packet_size));
+}
+
+
+uint8_t
+qla4xxx_isns_build_scn_deregistration_packet(scsi_qla_host_t *ha,
+					     uint8_t *buffer,
+					     uint32_t buffer_size,
+					     uint32_t *packet_size)
+{
+	/*
+	 * Fill in all of the run time requested data in the attribute array
+	 * then call iSNSBuildRequestPacket to do the actual work.
+	 */
+
+	return(qla4xxx_isns_build_request_packet(ha, buffer, buffer_size,
+						 ISNS_FCID_SCNDereg,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_scn_dereg_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_build_registration_packet(scsi_qla_host_t *ha,
+				       uint8_t *buff,
+				       uint32_t buff_size,
+				       uint8_t *isns_entity_id,
+				       uint8_t *ip_addr,
+				       uint32_t port_number,
+				       uint32_t scn_port,
+				       uint32_t esi_port,
+				       uint8_t *local_alias,
+				       uint32_t *packet_size)
+{
+	/*
+	 * Fill in all of the run time requested data in the attribute array,
+	 * then call build_request_packet to do the actual work.
+	 */
+	ha->isns_reg_attr_list[1].data = (uint32_t)(unsigned long) isns_entity_id;
+	ha->isns_reg_attr_list[3].data = (uint32_t)(unsigned long) isns_entity_id;
+	ha->isns_reg_attr_list[5].data = (uint32_t)(unsigned long) ip_addr;
+	ha->isns_reg_attr_list[6].data = DWSWAP(port_number);
+	ha->isns_reg_attr_list[7].data = DWSWAP(scn_port);
+	ha->isns_reg_attr_list[8].data = DWSWAP(esi_port);
+	if (local_alias && local_alias[0]) {
+		ha->isns_reg_attr_list[11].data = (uint32_t) (unsigned long) local_alias;
+	}
+	else {
+		ha->isns_reg_attr_list[11].data = (uint32_t) "<No alias specified>";
+	}
+
+	return(qla4xxx_isns_build_request_packet(ha, buff, buff_size,
+						 ISNS_FCID_DevAttrReg,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_reg_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_build_deregistration_packet(scsi_qla_host_t *ha,
+					 uint8_t *buff,
+					 uint32_t buff_size,
+					 uint8_t *isns_entity_id,
+					 uint8_t *ip_addr,
+					 uint32_t port_number,
+					 uint32_t *packet_size)
+{
+	/*
+	 * Fill in all of the run time requested data in the attribute array,
+	 * then call build_request_packet to do the actual work.
+	 */
+	ha->isns_dereg_attr_list[2].data = (uint32_t) (unsigned long) isns_entity_id;
+	#if 0
+	ha->isns_dereg_attr_list[3].data = (uint32_t) (unsigned long) ip_addr;
+	ha->isns_dereg_attr_list[4].data = (uint32_t) DWSWAP(WSWAP(port_number));
+	#endif
+
+	return(qla4xxx_isns_build_request_packet(ha, buff, buff_size,
+						 ISNS_FCID_DevDereg,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_dereg_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_build_request_packet(scsi_qla_host_t *ha,
+				  uint8_t *buffer,
+				  uint32_t buffer_size,
+				  uint16_t function_id,
+				  uint16_t tx_id,
+				  uint8_t  use_replace_flag,
+				  ATTRIBUTE_LIST *attr_list,
+				  uint32_t *packet_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	uint8_t  *ptr;
+	uint8_t  *buffer_end;
+	uint8_t  *payload_start;
+	uint32_t i;
+	uint8_t  success;
+
+	/*
+	 * Ensure that the buffer size is at a minimum sufficient to hold the
+	 * message header plus at least one attribute.
+	 */
+	if (buffer_size < (sizeof(*isns_message) + sizeof(*attr_list))) {
+		QL4PRINT(QLP12, printk("scsi%d: %s: Insufficient buffer size %d, need %d\n",
+				       ha->host_no, __func__, buffer_size,
+				       (unsigned int) (sizeof(*isns_message) + sizeof(*attr_list))));
+
+		return(QLA_ERROR);
+	}
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	buffer_end = (uint8_t *) ((unsigned long) buffer + buffer_size);
+
+	/* Initialize message header contents */
+	isns_message->isnsp_version = WSWAP(ISNSP_VERSION);
+	isns_message->function_id   = WSWAP(function_id);
+	isns_message->flags         = WSWAP(ISNSP_CLIENT_SENDER |
+					    ISNSP_FIRST_PDU |
+					    ISNSP_LAST_PDU);
+	if (use_replace_flag)
+		isns_message->flags |= WSWAP(ISNSP_REPLACE_FLAG);
+	isns_message->transaction_id = WSWAP(tx_id);
+	isns_message->sequence_id    = 0; // First and only packet in this message
+
+	ptr = payload_start = &isns_message->payload[0];
+
+	/*
+	 * Now that most of the message header has been initialized (we'll fill in
+	 * the size when we're finished), let's append the desired attributes
+	 * to the request packet.
+	 */
+	success = 1;
+	for (i = 0; attr_list[i].type && success; i++) {
+		success = (qla4xxx_isns_append_attribute (ha, &ptr, buffer_end,
+							  &attr_list[i])
+			   == QLA_SUCCESS);
+	}
+
+	if (!success) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Ran out of buffer space\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	/*
+	 * We've successfully finished building the request packet.
+	 * Set the size field.
+	 */
+	isns_message->pdu_length = WSWAP((uint32_t) (unsigned long) ptr - (uint32_t) (unsigned long) payload_start);
+
+	*packet_size = (uint32_t) ((uint32_t) (unsigned long) ptr - (uint32_t) (unsigned long) buffer);
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_build_server_request_response_packet(scsi_qla_host_t *ha,
+						  uint8_t * buffer,
+						  uint32_t buffer_size,
+						  uint16_t function_id,
+						  uint32_t error_code,
+						  uint16_t transaction_id,
+						  uint32_t *packet_size)
+{
+	ISNSP_MESSAGE_HEADER * isns_message;
+	ISNSP_RESPONSE_HEADER * isns_response;
+	uint8_t *ptr;
+	uint8_t *buffer_end;
+	uint8_t *payload_start;
+
+	// Ensure that the buffer size is at a minimum sufficient to hold the
+	// message headers.
+
+	if (buffer_size < (sizeof(ISNSP_MESSAGE_HEADER) + sizeof(ISNSP_RESPONSE_HEADER))) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Insufficient buffer size %x\n",
+				      ha->host_no, __func__, buffer_size));
+		return(QLA_ERROR);
+	}
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+	payload_start = ( uint8_t *) isns_response;
+	buffer_end = ( uint8_t *) (buffer + buffer_size);
+
+	// Initialize message header contents.
+
+	isns_message->isnsp_version = WSWAP(ISNSP_VERSION);
+	isns_message->function_id = function_id;
+	isns_message->flags = WSWAP(ISNSP_CLIENT_SENDER |
+				    ISNSP_FIRST_PDU |
+				    ISNSP_LAST_PDU);
+	isns_message->transaction_id = transaction_id;
+	isns_message->sequence_id = 0;	 // First and only packet in this message
+
+	isns_response->error_code = DWSWAP(error_code);
+
+	ptr = isns_response->attributes;
+
+	// We've successfully finished building the request packet.
+	// Set the size field.
+
+	//QLASSERT (!((ptr - payload_start) % 4));
+
+	isns_message->pdu_length = WSWAP((uint32_t) (unsigned long) ptr - (uint32_t) (unsigned long) payload_start);
+
+	*packet_size = (uint32_t) (unsigned long) ptr - (uint32_t) (unsigned long) buffer;
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_build_dev_get_next_packet (scsi_qla_host_t *ha,
+					uint8_t * buffer,
+					uint32_t buffer_size,
+					uint8_t * last_iscsi_name,
+					uint32_t *packet_size)
+{
+	// Fill in all of the run time requested data in the attribute array
+	// then call qla4xxx_isns_build_request_packet to do the actual work.
+
+	if (last_iscsi_name && last_iscsi_name[0]) {
+		ha->isns_dev_get_next_attr_list[1].type = ISNS_ATTR_TYPE_STRING;
+		ha->isns_dev_get_next_attr_list[1].data = (uint32_t) (unsigned long) last_iscsi_name;
+	}
+	else {
+		ha->isns_dev_get_next_attr_list[1].type = ISNS_ATTR_TYPE_EMPTY;
+		ha->isns_dev_get_next_attr_list[1].data = 0;
+	}
+
+	return(qla4xxx_isns_build_request_packet(ha, buffer, buffer_size,
+						 ISNS_FCID_DevGetNext,
+						 ha->isns_transaction_id,
+						 0,
+						 ha->isns_dev_get_next_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_build_dev_attr_qry_packet (scsi_qla_host_t *ha,
+					uint8_t *buffer,
+					uint32_t buffer_size,
+					uint8_t *object_iscsi_name,
+					uint32_t *packet_size)
+{
+	// Fill in all of the run time requested data in the attribute array
+	// then call qla4xxx_isns_build_request_packet to do the actual work.
+
+	ha->isns_dev_attr_qry_attr_list[1].data = (uint32_t) (unsigned long) object_iscsi_name;
+
+	return(qla4xxx_isns_build_request_packet(ha, buffer, buffer_size,
+						 ISNS_FCID_DevAttrQry,
+						 ha->isns_transaction_id, 0,
+						 ha->isns_dev_attr_qry_attr_list,
+						 packet_size));
+}
+
+uint8_t
+qla4xxx_isns_parse_get_next_response(scsi_qla_host_t *ha,
+				     uint8_t *buffer,
+				     uint32_t buffer_size,
+				     uint32_t *isns_error,
+				     uint8_t *last_iscsi_name,
+				     uint32_t last_iscsi_name_size,
+				     uint8_t *IsTarget)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	ISNS_ATTRIBUTE *isns_attr;
+	uint8_t *buffer_end;
+
+	*IsTarget = 0;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	buffer_end = ( uint8_t *) (( uint8_t *) isns_message->payload +
+				   WSWAP(isns_message->pdu_length));
+
+	// Validate pdu_length specified in the iSNS message header.
+
+	if (((uint32_t) (unsigned long) buffer_end - (uint32_t) (unsigned long) buffer) > buffer_size) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid length field in iSNS response from iSNS server\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// It is safe to assume from this point on that the pdu_length value
+	// (and thus our idea about the end of the buffer) is valid.
+
+	// Ensure that we have the correct function_id.
+
+	if (isns_message->function_id != WSWAP(ISNS_FCID_DevGetNextRsp)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid Function ID (0x%04x) "
+				      "in iSNS response from iSNS server\n",
+				      ha->host_no, __func__,
+				      WSWAP(isns_message->function_id)));
+		return(QLA_ERROR);
+	}
+
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+
+	*isns_error = DWSWAP(isns_response->error_code);
+	if (*isns_error) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: iSNS Error code: %d\n",
+				      ha->host_no, __func__, *isns_error));
+
+		if (*isns_error == ISNS_ERR_NO_SUCH_ENTRY) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: No more targets.\n",
+					      ha->host_no, __func__));
+		}
+		else {
+			QL4PRINT(QLP2, printk("scsi%d: %s: Get Next failed. Error code %x\n",
+					      ha->host_no, __func__, *isns_error));
+		}
+		return(QLA_ERROR);
+	}
+
+	isns_attr = (ISNS_ATTRIBUTE *) isns_response->attributes;
+
+	// Save the returned key attribute for the next DevGetNext request.
+
+	if (VALIDATE_ATTR(isns_attr, buffer_end) && isns_attr->tag ==
+	    DWSWAP(ISNS_ATTR_TAG_ISCSI_NAME)) {
+		strncpy(last_iscsi_name, isns_attr->value, last_iscsi_name_size);
+	}
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Bad Key attribute in DevGetNextRsp\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// Point to next attribute.
+
+	isns_attr = NEXT_ATTR(isns_attr);
+
+	if (VALIDATE_ATTR(isns_attr, buffer_end) && isns_attr->tag
+	    == DWSWAP(ISNS_ATTR_TAG_DELIMITER)) {
+		;	// Do nothing.
+	}
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: No delimiter in DevGetNextRsp\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	*IsTarget = 1;  //FIXME
+
+	// Point to next attribute.
+
+	isns_attr = NEXT_ATTR(isns_attr);
+
+	if (VALIDATE_ATTR(isns_attr, buffer_end) && isns_attr->tag ==
+	    DWSWAP(ISNS_ATTR_TAG_ISCSI_NODE_TYPE)) {
+		if (DWSWAP(*(uint32_t *) isns_attr->value) & ISCSI_NODE_TYPE_TARGET) {
+			*IsTarget = 1;
+		}
+	}
+	#if 0
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Bad operating attr in DevGetNextRsp\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+	#endif
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_parse_query_response (scsi_qla_host_t *ha,
+				   uint8_t *buffer,
+				   uint32_t buffer_size,
+				   uint32_t *isns_error,
+				   ISNS_DISCOVERED_TARGET *isns_discovered_target,
+				   uint8_t *IsTarget,
+				   uint8_t *last_iscsi_name)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	ISNS_ATTRIBUTE *isns_attr;
+	uint8_t *buffer_end;
+	uint8_t *tmpptr;
+	uint16_t wTmp;
+	uint32_t ulTmp;
+	uint32_t i;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	buffer_end = isns_message->payload + WSWAP(isns_message->pdu_length);
+
+	// Validate pdu_length specified in the iSNS message header.
+
+	if (((uint32_t) (unsigned long) buffer_end - (uint32_t) (unsigned long) buffer) > buffer_size) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid length field in iSNS response from iSNS server\n", ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// It is safe to assume from this point on that the pdu_length value
+	// (and thus our idea about the end of the buffer) is valid.
+
+	// Ensure that we have the correct function_id.
+
+	if (isns_message->function_id != WSWAP(ISNS_FCID_DevAttrQryRsp)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid Function ID %04x in iSNS response\n",
+				      ha->host_no, __func__,
+				      WSWAP(isns_message->function_id)));
+		return(QLA_ERROR);
+	}
+
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+
+	QL4PRINT(QLP20, printk("-----------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s: DevAttrQry response from iSNS server:\n",
+			       ha->host_no, __func__));
+
+	*isns_error = DWSWAP(isns_response->error_code);
+	if (isns_response->error_code) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: iSNS Query failed.  error_code %x.\n",
+				      ha->host_no, __func__, *isns_error));
+		return(QLA_ERROR);
+	}
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: Attributes:\n", ha->host_no, __func__));
+
+	isns_attr = (ISNS_ATTRIBUTE *) isns_response->attributes;
+
+	// Skip key and delimiter attributes.
+
+	while (VALIDATE_ATTR(isns_attr, buffer_end) && isns_attr->tag !=
+	       DWSWAP(ISNS_ATTR_TAG_DELIMITER)) {
+		// Point to next attribute.
+		if (DWSWAP(isns_attr->tag) == ISNS_ATTR_TAG_ISCSI_NAME) {
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: MsgTag iSCSI Name: \"%s\"\n",
+					       ha->host_no, __func__, isns_attr->value));
+			if (strlen (isns_attr->value) > 256)
+				return(QLA_ERROR);
+			strcpy (last_iscsi_name, (uint8_t *) isns_attr->value);
+		}
+		isns_attr = NEXT_ATTR(isns_attr);
+	}
+
+	if (!VALIDATE_ATTR(isns_attr, buffer_end) || isns_attr->tag !=
+	    DWSWAP(ISNS_ATTR_TAG_DELIMITER)) {
+		// There was no delimiter attribute in the response.
+		return(QLA_ERROR);
+	}
+
+	// Skip delimiter attribute.
+	isns_attr = NEXT_ATTR(isns_attr);
+
+	while (VALIDATE_ATTR(isns_attr, buffer_end)) {
+		// We only need to parse for the operating attributes that we
+		// requested in the DevAttrQuery.
+
+		switch (DWSWAP(isns_attr->tag)) {
+		case ISNS_ATTR_TAG_ENTITY_PROTOCOL:
+			if (DWSWAP(*(uint32_t *) isns_attr->value) != ENTITY_PROTOCOL_ISCSI) {
+				QL4PRINT(QLP2, printk("scsi%d: %s: Entity does not support iSCSI protocol\n", ha->host_no, __func__));
+			}
+			break;
+
+		case ISNS_ATTR_TAG_ISCSI_NODE_TYPE:
+			switch (DWSWAP(*(uint32_t *) isns_attr->value)) {
+			case ISCSI_NODE_TYPE_TARGET:
+				QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI node type Target\n", ha->host_no, __func__));
+				*IsTarget = 1;
+				break;
+			case ISCSI_NODE_TYPE_INITIATOR:
+				QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI node type Initiator\n", ha->host_no, __func__));
+				*IsTarget = 0;
+				break;
+			case ISCSI_NODE_TYPE_CONTROL:
+				QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI node type Control\n", ha->host_no, __func__));
+				*IsTarget = 0;
+				break;
+			default:
+				QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI node type unknown\n", ha->host_no, __func__));
+				*IsTarget = 0;
+				break;
+			}
+			break;
+
+		case ISNS_ATTR_TAG_MGMT_IP_ADDRESS:
+			// WARNING: This doesn't handle IPv6 addresses.
+			tmpptr = isns_attr->value;
+			for (i = 0; i < 8; i++) {
+				if (tmpptr[i])
+					return(QLA_ERROR);
+			}
+
+			for (i = 8; i < 12; i++) {
+				if (tmpptr[i] != 0 && tmpptr[i] != 0xFF)
+					return(QLA_ERROR);
+			}
+
+			QL4PRINT(QLP20, printk("scsi%d: %s: Management IP address: %u.%u.%u.%u\n",
+					       ha->host_no, __func__, tmpptr[12],
+					       tmpptr[13], tmpptr[14], tmpptr[15]));
+			break;
+
+		case ISNS_ATTR_TAG_PORTAL_IP_ADDRESS:
+			// WARNING: This doesn't handle IPv6 addresses.
+			tmpptr = isns_attr->value;
+			for (i = 0; i < 8; i++) {
+				if (tmpptr[i])
+					return(QLA_ERROR);
+			}
+
+			for (i = 8; i < 12; i++) {
+				if (tmpptr[i] != 0 && tmpptr[i] != 0xFF)
+					return(QLA_ERROR);
+			}
+
+			QL4PRINT(QLP20, printk("scsi%d: %s: Portal IP address: %u.%u.%u.%u\n",
+					       ha->host_no, __func__, tmpptr[12],
+					       tmpptr[13], tmpptr[14], tmpptr[15]));
+
+			if (isns_discovered_target->NumPortals >= ISNS_MAX_PORTALS)
+				break;
+			memcpy(isns_discovered_target->Portal[isns_discovered_target->NumPortals].IPAddr,
+			       &tmpptr[12], 4);
+			break;
+
+		case ISNS_ATTR_TAG_PORTAL_PORT:
+			wTmp = (uint16_t) (DWSWAP(*(uint32_t *) isns_attr->value));
+			QL4PRINT(QLP20, printk("scsi%d: %s: Portal port: %u\n",
+					       ha->host_no, __func__, DWSWAP(*(uint32_t *) isns_attr->value)));
+			if (isns_discovered_target->NumPortals >= ISNS_MAX_PORTALS)
+				break;
+			isns_discovered_target->Portal[isns_discovered_target->NumPortals].PortNumber = wTmp;
+			isns_discovered_target->NumPortals++;
+			break;
+
+		case ISNS_ATTR_TAG_PORTAL_SYMBOLIC_NAME:
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: Portal Symbolic Name: \"%s\"\n",
+					       ha->host_no, __func__, isns_attr->value));
+#if 0
+			if (isns_discovered_target->NumPortals >= ISNS_MAX_PORTALS)
+				break;
+			qlstrncpy(isns_discovered_target->Portal[isns_discovered_target->NumPortals].SymbolicName,
+				  (uint8_t *) isns_attr->value, 32);
+			isns_discovered_target->Portal[isns_discovered_target->NumPortals].SymbolicName[31] = 0;
+#endif
+			break;
+
+		case ISNS_ATTR_TAG_SCN_PORT:
+			QL4PRINT(QLP20, printk("scsi%d: %s: SCN port: %u\n",
+					       ha->host_no, __func__,
+					       DWSWAP(*(uint32_t *) isns_attr->value)));
+			break;
+
+		case ISNS_ATTR_TAG_ESI_PORT:
+			QL4PRINT(QLP20, printk("scsi%d: %s: ESI port: %u\n",
+					       ha->host_no, __func__,
+					       DWSWAP(*(uint32_t *) isns_attr->value)));
+			break;
+
+		case ISNS_ATTR_TAG_ESI_INTERVAL:
+			QL4PRINT(QLP20, printk("scsi%d: %s: ESI Interval: %u\n",
+					       ha->host_no, __func__,
+					       DWSWAP(*(uint32_t *) isns_attr->value)));
+			break;
+
+		case ISNS_ATTR_TAG_REGISTRATION_PERIOD:
+			QL4PRINT(QLP20, printk("scsi%d: %s: Entity Registration Period: %u\n",
+					       ha->host_no, __func__,
+					       DWSWAP(*(uint32_t *) isns_attr->value)));
+			break;
+
+		case ISNS_ATTR_TAG_PORTAL_SECURITY_BITMAP:
+			ulTmp = DWSWAP(*(uint32_t *) isns_attr->value);
+
+			QL4PRINT(QLP20, printk("scsi%d: %s: Portal Security Bitmap:\n", ha->host_no, __func__));
+			if (ulTmp & ISNS_SECURITY_BITMAP_VALID) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_BITMAP_VALID\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_IKE_IPSEC_ENABLED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_IKE_IPSEC_ENABLED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_MAIN_MODE_ENABLED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_MAIN_MODE_ENABLED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_AGGRESSIVE_MODE_ENABLED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_AGGRESSIVE_MODE_ENABLED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_PFS_ENABLED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_PFS_ENABLED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_TRANSPORT_MODE_PREFERRED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_TRANSPORT_MODE_PREFERRED\n", ha->host_no, __func__));
+			}
+			if (ulTmp & ISNS_SECURITY_TUNNEL_MODE_PREFERRED) {
+				QL4PRINT(QLP20, printk("scsi%d: %s:\tISNS_SECURITY_TUNNEL_MODE_PREFERRED\n", ha->host_no, __func__));
+			}
+			// isns_discovered_target->SecurityBitmap = ulTmp;
+			break;
+
+		case ISNS_ATTR_TAG_ENTITY_IDENTIFIER:
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: Entity Identifier: \"%s\"\n",
+					       ha->host_no, __func__, isns_attr->value));
+			break;
+
+		case ISNS_ATTR_TAG_ISCSI_NAME:
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: iSCSI Name: \"%s\"\n",
+					       ha->host_no, __func__, isns_attr->value));
+			if (strlen (isns_attr->value) > 256)
+				return(QLA_ERROR);
+			strcpy (isns_discovered_target->NameString, ( uint8_t *) isns_attr->value);
+			break;
+
+		case ISNS_ATTR_TAG_ISCSI_ALIAS:
+			// Note that this string is in UTF-8 format.  In production code,
+			// it would be necessary to convert from UTF-8 before using the
+			// string.
+			QL4PRINT(QLP20, printk("scsi%d: %s: Alias: \"%s\"\n",
+					       ha->host_no, __func__, isns_attr->value));
+			if (strlen (isns_attr->value) <= 32)
+				strcpy (isns_discovered_target->Alias, ( uint8_t *) isns_attr->value);
+			break;
+
+		case ISNS_ATTR_TAG_DD_ID:
+			ulTmp = DWSWAP(*(uint32_t *) isns_attr->value);
+			QL4PRINT(QLP20, printk("scsi%d: %s: DD ID: %u\n",
+					       ha->host_no, __func__,
+					       DWSWAP(*(uint32_t *) isns_attr->value)));
+			isns_discovered_target->DDID = ulTmp;
+			break;
+
+		default:
+			//QLASSERT (0);
+			break;
+		}
+
+		// Point to next attribute.
+
+		isns_attr = NEXT_ATTR(isns_attr);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_process_response(scsi_qla_host_t *ha, PASSTHRU_STATUS_ENTRY *sts_entry)
+{
+	PDU_ENTRY *pdu_entry = (PDU_ENTRY *) &ha->pdu_queue[IOCB_ISNS_PT_PDU_INDEX(sts_entry->handle)];
+	uint32_t pdu_type = IOCB_ISNS_PT_PDU_TYPE(sts_entry->handle);
+	uint8_t status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_passthru_status_entry");
+
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s isns_flags 0x%lx to=0x%x "
+			"IOCS=0x%02x OutResidual/Len=0x%x/0x%x "
+			"InResidual/Len=0x%x/0x%x\n",
+			ha->host_no, __func__,
+			ha->isns_flags,
+			sts_entry->timeout,
+			sts_entry->completionStatus,
+			sts_entry->outResidual,
+			pdu_entry->SendBuffLen,
+			sts_entry->inResidual,
+			pdu_entry->RecvBuffLen));
+
+	if (pdu_entry->RecvBuffLen - sts_entry->inResidual) {
+		QL4PRINT(QLP19, printk("PDU (0x%p) <-\n", pdu_entry->Buff));
+		qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, (pdu_entry->RecvBuffLen - sts_entry->inResidual));
+	}
+
+
+	if (sts_entry->completionStatus != PASSTHRU_STATUS_COMPLETE) {
+
+		qla4xxx_free_pdu(ha, pdu_entry);
+		set_bit(DPC_ISNS_RESTART, &ha->dpc_flags);
+		goto exit_pt_sts;
+	}
+
+	switch (pdu_type) {
+	case ISNS_ASYNCH_RSP_PDU:
+		qla4xxx_free_pdu(ha, pdu_entry);
+		break;
+
+	case ISNS_ASYNCH_REQ_PDU:
+		pdu_entry->RecvBuffLen -= sts_entry->inResidual;
+
+		QL4PRINT(QLP19, printk("scsi%d: %s ISNS_ASYNCH_REQ_PDU  PDU Buff=%p, PDU RecvLen=0x%X\n",
+				       ha->host_no, __func__, pdu_entry->Buff, pdu_entry->RecvBuffLen));
+
+		if (qla4xxx_isns_reassemble_pdu(ha, pdu_entry->Buff,
+						&pdu_entry->RecvBuffLen)
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s ISNS_ASYNCH_REQ_PDU "
+					"reassemble_pdu failed!\n",
+					ha->host_no, __func__));
+			goto exit_pt_sts;
+		}
+
+		if (qla4xxx_isns_parse_and_dispatch_server_request(ha,
+								   pdu_entry->Buff,
+								   pdu_entry->RecvBuffLen,
+								   sts_entry->connectionID)
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s ISNS_ASYNCH_REQ_PDU "
+					"parse_and_dispatch_server_request failed!\n",
+					ha->host_no, __func__));
+		}
+		qla4xxx_free_pdu(ha, pdu_entry);
+		break;
+
+	case ISNS_REQ_RSP_PDU:
+		pdu_entry->RecvBuffLen -= sts_entry->inResidual;
+
+		QL4PRINT(QLP19, printk("scsi%d: %s ISNS_REQ_RSP_PDU  PDU Buff=%p, PDU RecvLen=0x%X\n",
+				       ha->host_no, __func__, pdu_entry->Buff, pdu_entry->RecvBuffLen));
+
+
+		if (qla4xxx_isns_reassemble_pdu(ha, pdu_entry->Buff,
+						&pdu_entry->RecvBuffLen)
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s ISNS_REQ_RSP_PDU "
+					"reassemble_pdu failed!\n",
+					ha->host_no, __func__));
+			goto exit_pt_sts;
+		}
+
+		if (qla4xxx_isns_parse_and_dispatch_server_response(ha,
+								    pdu_entry->Buff,
+								    pdu_entry->RecvBuffLen)
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s ISNS_REQ_RSP_PDU "
+					"parse_and_dispatch_server_response failed!\n",
+					ha->host_no, __func__));
+		}
+		qla4xxx_free_pdu(ha, pdu_entry);
+		break;
+	default:
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s iSNS handle 0x%x invalid\n",
+				ha->host_no, __func__, sts_entry->handle));
+		status = QLA_ERROR;
+		break;
+	}
+
+	exit_pt_sts:
+	LEAVE("qla4xxx_passthru_status_entry");
+	return(status);
+}
+
+uint8_t
+qla4xxx_isns_reassemble_pdu(scsi_qla_host_t *ha, uint8_t *buffer, uint32_t *buffer_size)
+{
+	uint16_t copy_size = 0;
+	uint32_t new_pdu_length = 0;
+	uint32_t bytes_remaining;
+	uint32_t pdu_size;
+	uint8_t *dest_ptr = NULL;
+	uint8_t *src_ptr = NULL;
+	ISNSP_MESSAGE_HEADER *isns_message;
+	uint32_t i;
+
+	// We have read all the PDU's for this message.  Now reassemble them
+	// into a single PDU.
+	if (buffer == NULL || buffer_size == 0) {
+		return(QLA_ERROR);
+	}
+
+	if (*buffer_size == 0) {
+		QL4PRINT(QLP2,
+			 printk(KERN_WARNING "scsi%d: %s: Length 0.  "
+				"Nothing to reassemble\n",
+				ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	new_pdu_length = 0;
+	bytes_remaining = *buffer_size;
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+
+
+	// First, calculate the size of the payload for the collapsed PDU
+	do {
+		if (bytes_remaining < sizeof(ISNSP_MESSAGE_HEADER)) {
+			QL4PRINT(QLP2,
+				 printk(KERN_WARNING "scsi%d: %s: Length 0.  "
+					"bytes_remaining < "
+					"sizeof(ISNSP_MESSAGE_HEADER).  "
+					"BytesRemaining %x, discard PDU\n",
+					ha->host_no, __func__,
+					bytes_remaining));
+			*buffer_size = 0;
+			return(QLA_ERROR);
+		}
+		else if (isns_message->isnsp_version != WSWAP(ISNSP_VERSION)) {
+			QL4PRINT(QLP2,
+				 printk(KERN_WARNING "scsi%d: %s: Bad Version "
+					"number in iSNS Message Header "
+					"(%04x, expecting %04x), discard PDU\n",
+					ha->host_no, __func__,
+					isns_message->isnsp_version,
+					WSWAP(ISNSP_VERSION)));
+			*buffer_size = 0;
+			return(QLA_ERROR);
+		}
+		else if (bytes_remaining < sizeof(ISNSP_MESSAGE_HEADER) + WSWAP(isns_message->pdu_length)) {
+			QL4PRINT(QLP2,
+				 printk(KERN_WARNING "scsi%d: %s: Short PDU "
+					"in sequence. BytesRemaining %x, "
+					"discard PDU\n",
+					ha->host_no, __func__,
+					bytes_remaining));
+			*buffer_size = 0;
+			return(QLA_ERROR);
+		}
+
+		if (bytes_remaining == sizeof(ISNSP_MESSAGE_HEADER) + WSWAP(isns_message->pdu_length)) {
+			if (!(WSWAP(isns_message->flags) & ISNSP_LAST_PDU)) {
+				QL4PRINT(QLP2,
+					 printk(KERN_WARNING "scsi%d: %s: "
+						"Last PDU Flag not set at end "
+						"of sequence. discard PDU\n",
+						ha->host_no, __func__));
+				*buffer_size = 0;
+				return(QLA_ERROR);
+			}
+		}
+
+		new_pdu_length += WSWAP(isns_message->pdu_length);
+		pdu_size = sizeof(ISNSP_MESSAGE_HEADER) + WSWAP(isns_message->pdu_length);
+		isns_message = (ISNSP_MESSAGE_HEADER *) ((uint8_t *) isns_message + pdu_size);
+		bytes_remaining = bytes_remaining > pdu_size ? bytes_remaining - pdu_size : 0;
+	}
+	while (bytes_remaining);
+
+	dest_ptr = buffer;
+	bytes_remaining = *buffer_size;
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	i = 0;
+	QL4PRINT(QLP19, printk("scsi%d: %s: PDU%d=%p payloadLength=%04x\n",
+			       ha->host_no, __func__, i, dest_ptr,
+			       WSWAP(isns_message->pdu_length)));
+
+	while (bytes_remaining) {
+		// If this is the first PDU perform no copy,
+		// otherwise copy just the payload.
+
+		if (dest_ptr != buffer) {
+			i++;
+			copy_size = WSWAP(isns_message->pdu_length);
+			src_ptr = (uint8_t *) isns_message->payload;
+			QL4PRINT(QLP19,
+				 printk("scsi%d: %s: PDU%d %p <= %p (%04x)\n",
+					ha->host_no, __func__, i, dest_ptr,
+					src_ptr, copy_size));
+			memcpy(dest_ptr, src_ptr, copy_size);
+			dest_ptr += copy_size;
+		}
+		pdu_size = sizeof(ISNSP_MESSAGE_HEADER) + WSWAP(isns_message->pdu_length);
+		isns_message = (ISNSP_MESSAGE_HEADER *) ((uint8_t *) isns_message + pdu_size);
+		bytes_remaining = bytes_remaining > pdu_size ? bytes_remaining - pdu_size : 0;
+	}
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+
+	// Update pdu_length field in reassembled PDU to reflect actual
+	// combined PDU payload length.
+	isns_message->pdu_length = WSWAP(new_pdu_length);
+
+	// Also set LAST_PDU flag in reassembled PDU
+	isns_message->flags |= WSWAP(ISNSP_LAST_PDU);
+
+	// Return number of bytes in buffer to caller.
+	*buffer_size = new_pdu_length + sizeof(ISNSP_MESSAGE_HEADER);
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn (scsi_qla_host_t *ha,
+		  uint8_t * req_buffer,
+		  uint32_t req_buffer_size,
+		  uint16_t ConnectionId)
+{
+	ISNSP_MESSAGE_HEADER * isns_req_message;
+	ISNSP_MESSAGE_HEADER * isns_rsp_message;
+	ISNSP_RESPONSE_HEADER * isns_response;
+	PDU_ENTRY * pdu_entry;
+	ISNS_ATTRIBUTE * attr;
+	uint8_t * req_buffer_end;
+	uint8_t * rsp_buffer_end;
+	uint8_t * payload_start;
+	uint8_t * ptr;
+	uint32_t packet_size;
+	uint32_t copy_size;
+
+	isns_req_message = (ISNSP_MESSAGE_HEADER *) req_buffer;
+
+	if ((pdu_entry = qla4xxx_get_pdu (ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// First, setup the response packet.
+	if (qla4xxx_isns_build_server_request_response_packet(ha,
+							      pdu_entry->Buff,
+							      pdu_entry->BuffLen,
+							      isns_req_message->function_id | WSWAP(0x8000),
+							      ISNS_ERR_SUCCESS,
+							      isns_req_message->transaction_id,
+							      &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: qla4xxx_isns_build_server_request_response_packet failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	isns_rsp_message = (ISNSP_MESSAGE_HEADER *) pdu_entry->Buff;
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_rsp_message->payload;
+	payload_start = (uint8_t *) isns_response;
+	rsp_buffer_end = (uint8_t *) (pdu_entry->Buff + pdu_entry->BuffLen);
+
+	ptr = isns_response->attributes;
+
+	req_buffer_end = (uint8_t *) ((uint8_t *) isns_req_message->payload +
+				      WSWAP(isns_req_message->pdu_length));
+
+	// Point to the source attribute in the request.  We need to return only
+	// this attribute in the SCN Response.
+	attr = (ISNS_ATTRIBUTE *) isns_req_message->payload;
+	if (!VALIDATE_ATTR(attr, req_buffer_end)) {
+		isns_response->error_code = DWSWAP(ISNS_ERR_MSG_FORMAT);
+		QL4PRINT(QLP2, printk("scsi%d: %s: Malformed packet\n",
+				      ha->host_no, __func__));
+	}
+
+	// Validate that this is an iSCSI Name attribute.
+	if (attr->tag != DWSWAP(ISNS_ATTR_TAG_ISCSI_NAME)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Did not find iSCSN Name attribute\n",
+				      ha->host_no, __func__));
+	}
+
+	// Copy source attribute to return buffer.
+	copy_size = sizeof(ISNS_ATTRIBUTE) + DWSWAP(attr->length);
+
+	if (ptr + copy_size < rsp_buffer_end) {
+		// Attribute will fit in the response buffer.  Go ahead
+		// and copy it.
+		memcpy(ptr, attr, copy_size);
+		ptr += copy_size;
+	}
+	else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Insufficient buffer size\n",
+				      ha->host_no, __func__));
+	}
+
+	// We've successfully finished building the response packet.
+	// Set the size field.
+
+	//QLASSERT (!((ptr - payload_start) % 4));
+
+	isns_rsp_message->pdu_length = WSWAP((uint32_t) (unsigned long) ptr - (uint32_t) (unsigned long) payload_start);
+
+	packet_size = (uint32_t) (unsigned long) ptr - (uint32_t) (unsigned long) pdu_entry->Buff;
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = 0;
+
+	QL4PRINT(QLP10, printk("scsi%d: %s: Dump Send Buff %p %x\n",
+			       ha->host_no, __func__, pdu_entry->Buff,
+			       pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes (QLP10, pdu_entry->Buff, pdu_entry->SendBuffLen);
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s:                            sending  %d SCNRsp\n",
+			       ha->host_no, __func__,
+			       WSWAP(isns_rsp_message->transaction_id)));
+
+	if (qla4xxx_send_passthru0_iocb (ha, ISNS_DEVICE_INDEX, ConnectionId,
+					 pdu_entry->Buff,
+					 pdu_entry->SendBuffLen,
+					 pdu_entry->RecvBuffLen,
+					 PT_FLAG_ISNS_PDU,
+					 qla4xxx_isns_build_iocb_handle(ha, ISNS_ASYNCH_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	if (test_bit(ISNS_FLAG_SCN_IN_PROGRESS, &ha->isns_flags)) {
+		set_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+	}
+	else {
+		set_bit(ISNS_FLAG_SCN_IN_PROGRESS, &ha->isns_flags);
+		clear_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+		ha->isns_num_discovered_targets = 0;
+		if (qla4xxx_isns_dev_get_next (ha, NULL) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+					      ha->host_no, __func__));
+			ISNS_CLEAR_FLAGS(ha);
+		}
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_esi (scsi_qla_host_t *ha,
+		  uint8_t *req_buffer,
+		  uint32_t req_buffer_size,
+		  uint16_t ConnectionId)
+{
+	ISNSP_MESSAGE_HEADER *isns_req_message;
+	ISNSP_MESSAGE_HEADER *isns_rsp_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	PDU_ENTRY * pdu_entry;
+	ISNS_ATTRIBUTE *attr;
+	uint8_t * req_buffer_end;
+	uint8_t * rsp_buffer_end;
+	uint8_t * payload_start;
+	uint8_t * ptr;
+	uint32_t packet_size;
+	uint32_t copy_size;
+
+	isns_req_message = (ISNSP_MESSAGE_HEADER *) req_buffer;
+
+	if ((pdu_entry = qla4xxx_get_pdu (ha, req_buffer_size + sizeof(uint32_t))) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	// First, setup the response packet.
+	if (qla4xxx_isns_build_server_request_response_packet(ha,
+							      pdu_entry->Buff,
+							      pdu_entry->BuffLen,
+							      isns_req_message->function_id | WSWAP(0x8000),
+							      ISNS_ERR_SUCCESS,
+							      isns_req_message->transaction_id,
+							      &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_isns_build_server_request_response_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	isns_rsp_message = (ISNSP_MESSAGE_HEADER *) pdu_entry->Buff;
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_rsp_message->payload;
+	payload_start = ( uint8_t *) isns_response;
+	rsp_buffer_end = ( uint8_t *) (pdu_entry->Buff + pdu_entry->BuffLen);
+
+	ptr = isns_response->attributes;
+
+	req_buffer_end = ( uint8_t *) (( uint8_t *) isns_req_message->payload +
+				       WSWAP(isns_req_message->pdu_length));
+
+	// Point to the source attribute in the request.  We need to return
+	// all attributes in the ESI Response.
+	attr = (ISNS_ATTRIBUTE *) isns_req_message->payload;
+
+	// Copy source attributes to return buffer.
+	copy_size = req_buffer_end - ( uint8_t *) attr;
+
+	if (ptr + copy_size < rsp_buffer_end) {
+		// Attributes will fit in the response buffer.  Go ahead
+		// and copy them.
+		memcpy(ptr, attr, copy_size);
+		ptr += copy_size;
+	}
+	else {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Insufficient buffer size\n",
+				ha->host_no, __func__));
+	}
+
+	// We've successfully finished building the response packet.
+	// Set the size field.
+
+	//QLASSERT (!((ptr - payload_start) % 4));
+
+	isns_rsp_message->pdu_length = WSWAP((uint32_t) (unsigned long) ptr - (uint32_t) (unsigned long) payload_start);
+
+	packet_size = (uint32_t) (unsigned long) ptr - (uint32_t) (unsigned long) pdu_entry->Buff;
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = 0;
+
+	QL4PRINT(QLP10, printk("scsi%d: %s: Dump Send Buff %p %x\n",
+			       ha->host_no, __func__, pdu_entry->Buff,
+			       pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes (QLP10, pdu_entry->Buff, pdu_entry->SendBuffLen);
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s:                            sending  %d ESIRsp\n",
+			ha->host_no, __func__,
+			WSWAP(isns_rsp_message->transaction_id)));
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX,
+					ConnectionId,
+					pdu_entry->Buff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU,
+					qla4xxx_isns_build_iocb_handle (ha, ISNS_ASYNCH_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+
+uint8_t
+qla4xxx_isns_server_request_error(scsi_qla_host_t *ha,
+				  uint8_t *buffer,
+				  uint32_t buffer_size,
+				  uint16_t connection_id,
+				  uint32_t error_code)
+{
+	PDU_ENTRY *pdu_entry;
+	ISNSP_MESSAGE_HEADER *isns_message;
+	uint16_t function_id;
+	uint32_t packet_size;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	function_id = WSWAP(isns_message->function_id);
+
+	// Return "Message Format Error"
+	if ((pdu_entry = qla4xxx_get_pdu(ha, sizeof(ISNSP_MESSAGE_HEADER) +
+					 sizeof(uint32_t))) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_server_request_response_packet(ha, pdu_entry->Buff, pdu_entry->BuffLen,
+							      isns_message->function_id | WSWAP(0x8000),
+							      error_code, isns_message->transaction_id,
+							      &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_isns_build_server_request_response_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = 0;
+	QL4PRINT(QLP10, printk("scsi%d: %s: Dump Send Buff %p %x\n",
+			       ha->host_no, __func__, pdu_entry->Buff,
+			       pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP10, pdu_entry->Buff, pdu_entry->SendBuffLen);
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX, connection_id,
+					pdu_entry->Buff, pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen, PT_FLAG_ISNS_PDU,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_ASYNCH_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n, ha->host_no, __func__",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	return(QLA_SUCCESS);
+}
+
+
+uint8_t
+qla4xxx_isns_parse_and_dispatch_server_request(scsi_qla_host_t *ha,
+					       uint8_t *buffer,
+					       uint32_t buffer_size,
+					       uint16_t connection_id)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	uint16_t function_id;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	function_id = WSWAP(isns_message->function_id);
+
+	// Validate pdu_length specified in the iSNS message header.
+	if ((uint32_t) (offsetof (ISNSP_MESSAGE_HEADER, payload) +
+			WSWAP(isns_message->pdu_length)) > buffer_size) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid message size %u %u\n",
+				      ha->host_no, __func__,
+				      (uint32_t) (offsetof(ISNSP_MESSAGE_HEADER, payload) +
+						  WSWAP(isns_message->pdu_length)),
+				      buffer_size));
+
+		if (function_id <= ISNS_FCID_ESI) {
+			return(qla4xxx_isns_server_request_error(ha, buffer, buffer_size, connection_id, ISNS_ERR_MSG_FORMAT));
+		}
+		return(QLA_ERROR);
+	}
+
+	// It is safe to assume from this point on that the pdu_length value
+	// (and thus our idea about the end of the buffer) is valid.
+
+	switch (function_id) {
+	case ISNS_FCID_SCN:
+		QL4PRINT(QLP2, printk("scsi%d: %s:  received %d SCN\n",
+				      ha->host_no, __func__,
+				      WSWAP(isns_message->transaction_id)));
+		return(qla4xxx_isns_scn(ha, buffer, buffer_size, connection_id));
+		break;
+
+	case ISNS_FCID_ESI:
+		QL4PRINT(QLP2, printk("scsi%d: %s:  received %d ESI\n",
+				      ha->host_no, __func__,
+				      WSWAP(isns_message->transaction_id)));
+		return(qla4xxx_isns_esi(ha, buffer, buffer_size, connection_id));
+		break;
+
+	default:
+		QL4PRINT(QLP2, printk("scsi%d: %s:  received %d Unknown iSNS ServerRequest %x\n",
+				      ha->host_no, __func__,
+				      WSWAP(isns_message->transaction_id), function_id));
+		if (function_id <= ISNS_FCID_ESI) {
+			// Return "Message Not Supported"
+			return(qla4xxx_isns_server_request_error (ha,
+								  buffer,
+								  buffer_size,
+								  connection_id,
+								  ISNS_ERR_MSG_NOT_SUPPORTED));
+		}
+		return(QLA_ERROR);
+		break;
+	}
+	return(QLA_SUCCESS);
+
+
+}
+
+uint8_t
+qla4xxx_isns_parse_and_dispatch_server_response(scsi_qla_host_t *ha,
+						uint8_t *buffer,
+						uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+	ISNS_ATTRIBUTE *isns_attr;
+	uint16_t function_id;
+	uint8_t *buffer_end;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	buffer_end = (uint8_t *) ((uint8_t *) isns_message->payload + WSWAP(isns_message->pdu_length));
+
+	isns_attr = (ISNS_ATTRIBUTE *) isns_message->payload;
+
+	/* Validate pdu_length specified in the iSNS message header. */
+	if (((uint32_t *) buffer_end - (uint32_t *) buffer) > buffer_size) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Invalid message size %u %u\n",
+				ha->host_no, __func__,
+				(unsigned int) ((uint32_t *) buffer_end - (uint32_t *) buffer),
+				buffer_size));
+		return(QLA_ERROR);
+	}
+
+	/*
+	 * It is safe to assume from this point on that the pdu_length value
+	 * (and thus our idea about the end of the buffer) is valid.
+	 */
+	if (WSWAP(isns_message->transaction_id) > ha->isns_transaction_id) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid message transaction ID recv %x exp %x\n",
+				      ha->host_no, __func__,
+				      WSWAP(isns_message->transaction_id),
+				      ha->isns_transaction_id));
+		qla4xxx_dump_bytes(QLP2, buffer, buffer_size);
+
+		set_bit(DPC_ISNS_RESTART, &ha->dpc_flags);
+		return(QLA_ERROR);
+	}
+
+	function_id = WSWAP(isns_message->function_id);
+
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+
+	//QL4PRINT(QLP20, printk("---------------------------\n"));
+	//QL4PRINT(QLP20, printk("scsi%d: %s: received function_id %x\n",
+	//		       ha->host_no, __func__, function_id));
+
+	switch (function_id) {
+	case ISNS_FCID_DevAttrRegRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d DevAttrRegRsp\n",
+				       ha->host_no, __func__,
+				       WSWAP(isns_message->transaction_id)));
+		return(qla4xxx_isns_dev_attr_reg_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_DevAttrQryRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d DevAttrQryRsp\n",
+				       ha->host_no, __func__,
+				       WSWAP(isns_message->transaction_id)));
+		return(qla4xxx_isns_dev_attr_qry_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_DevGetNextRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d DevGetNextRsp\n",
+				       ha->host_no, __func__,
+				       WSWAP(isns_message->transaction_id)));
+		return(qla4xxx_isns_dev_get_next_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_DevDeregRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d DevDeregRsp\n",
+				       ha->host_no, __func__,
+				       WSWAP(isns_message->transaction_id)));
+		return(qla4xxx_isns_dev_dereg_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_SCNRegRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d SCNRegRsp\n",
+				       ha->host_no, __func__,
+				       WSWAP(isns_message->transaction_id)));
+		return(qla4xxx_isns_scn_reg_rsp(ha, buffer, buffer_size));
+
+	case ISNS_FCID_SCNDeregRsp:
+		QL4PRINT(QLP20, printk("scsi%d: %s: received %d SCNDeregRsp\n",
+				       ha->host_no, __func__,
+				       WSWAP(isns_message->transaction_id)));
+		return(qla4xxx_isns_scn_dereg_rsp(ha, buffer, buffer_size));
+
+	default:
+		QL4PRINT(QLP2, printk("scsi%d: %s: Received %d Unknown iSNS function_id %x\n",
+				      ha->host_no, __func__,
+				      WSWAP(isns_message->transaction_id), function_id));
+		break;
+	}
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_attr_reg(scsi_qla_host_t *ha)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t  packet_size;
+
+	pdu_entry = qla4xxx_get_pdu(ha, PAGE_SIZE);
+	if (pdu_entry == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: get pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_registration_packet(ha, pdu_entry->Buff,
+						   pdu_entry->BuffLen,
+						   ha->isns_entity_id,
+						   ha->ip_address,
+						   ha->isns_remote_port_num,
+						   ha->isns_scn_port_num,
+						   ha->isns_esi_port_num,
+						   ha->alias, &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: "
+				"qla4xxx_isns_build_registration_packet failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP19, printk("scsi%d: Dump Send Buff 0x%p 0x%x\n",
+			       ha->host_no, pdu_entry->Buff, pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP19, pdu_entry->Buff, pdu_entry->SendBuffLen);
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s:                    sending %d DevAttrReg\n",
+			       ha->host_no, __func__, ha->isns_transaction_id));
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: Registering iSNS . . .\n", ha->host_no, __func__));
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					pdu_entry->Buff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU|PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: "
+				"qla4xxx_send_passthru0_iocb failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_attr_reg_rsp(scsi_qla_host_t *ha,
+			      uint8_t *buffer,
+			      uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+
+	if (isns_response->error_code) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: iSNS DevAttrReg failed, "
+				      "error code (%x) \"%s\"\n",
+				      ha->host_no, __func__,
+				      DWSWAP(isns_response->error_code),
+				      isns_error_code_msg[DWSWAP(isns_response->error_code)]));
+		clear_bit(ISNS_FLAG_ISNS_SRV_REGISTERED, &ha->isns_flags);
+		return(QLA_ERROR);
+	}
+
+	set_bit(ISNS_FLAG_ISNS_SRV_REGISTERED, &ha->isns_flags);
+	if (qla4xxx_isns_scn_reg(ha) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_scn_reg failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn_reg(scsi_qla_host_t *ha)
+{
+	PDU_ENTRY *isns_pdu_entry;
+	uint32_t packet_size;
+
+	if ((isns_pdu_entry = qla4xxx_get_pdu (ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_scn_registration_packet(ha, isns_pdu_entry->Buff,
+						       isns_pdu_entry->BuffLen,
+						       &packet_size) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_build_scn_registration_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, isns_pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	isns_pdu_entry->SendBuffLen = packet_size;
+	isns_pdu_entry->RecvBuffLen = isns_pdu_entry->BuffLen;
+	QL4PRINT(QLP10, printk("scsi%d: %s: Dump Send Buff %p %x\n",
+			       ha->host_no, __func__,
+			       isns_pdu_entry->Buff, isns_pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP10, isns_pdu_entry->Buff, isns_pdu_entry->SendBuffLen);
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d :%s:                        sending  %d SCNReg\n",
+			       ha->host_no, __func__, ha->isns_transaction_id));
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					isns_pdu_entry->Buff,
+					isns_pdu_entry->SendBuffLen,
+					isns_pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_REQ_RSP_PDU, isns_pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, isns_pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn_reg_rsp(scsi_qla_host_t *ha,
+			 uint8_t *buffer,
+			 uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+
+	if (isns_response->error_code) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: iSNS SCNReg failed, error code %x\n",
+				ha->host_no, __func__,
+				DWSWAP(isns_response->error_code)));
+		clear_bit(ISNS_FLAG_ISNS_SCN_REGISTERED, &ha->isns_flags);
+		return(QLA_ERROR);
+	}
+
+	set_bit(ISNS_FLAG_ISNS_SCN_REGISTERED, &ha->isns_flags);
+
+	ha->isns_num_discovered_targets = 0;
+	if (qla4xxx_isns_dev_get_next(ha, NULL) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+				      ha->host_no, __func__));
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_attr_qry(scsi_qla_host_t *ha,
+			  uint8_t *last_iscsi_name)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t packet_size;
+
+	if ((pdu_entry = qla4xxx_get_pdu(ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_dev_attr_qry_packet(ha, pdu_entry->Buff,
+						   pdu_entry->BuffLen,
+						   last_iscsi_name,
+						   &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s:  qla4xxx_isns_build_dev_attr_qry_packet failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP10, printk("scsi%d: %s: Dump Send Buff %p %x\n",
+			       ha->host_no, __func__, pdu_entry->Buff,
+			       pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes (QLP10, pdu_entry->Buff, pdu_entry->SendBuffLen);
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s:                     sending  %d DevAttrQry\n",
+			ha->host_no, __func__, ha->isns_transaction_id));
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					pdu_entry->Buff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle (ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_attr_qry_rsp(scsi_qla_host_t *ha,
+			      uint8_t *buffer,
+			      uint32_t buffer_size)
+{
+	uint8_t *last_iscsi_name = NULL;
+	ISNS_DISCOVERED_TARGET *discovered_target = NULL;
+	uint32_t isns_error;
+	int i;
+	uint8_t bIsTarget = 1;
+	uint8_t bFound = 0;
+	uint8_t status = QLA_SUCCESS;
+
+	if (test_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags)) {
+		clear_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+		ha->isns_num_discovered_targets = 0;
+		if (qla4xxx_isns_dev_get_next(ha, NULL) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+					      ha->host_no, __func__));
+			goto exit_qry_rsp_clear_flags;
+		}
+		goto exit_qry_rsp;
+	}
+
+	last_iscsi_name = kmalloc(256, GFP_ATOMIC);
+	discovered_target = kmalloc(sizeof(*discovered_target), GFP_ATOMIC);
+	if (!last_iscsi_name || !discovered_target) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: failed to allocate memory\n",
+				      ha->host_no, __func__));
+		status = QLA_ERROR;
+		goto exit_qry_rsp;
+	}
+
+	memset(last_iscsi_name, 0, 256);
+	memset(discovered_target, 0, sizeof(ISNS_DISCOVERED_TARGET));
+	if (qla4xxx_isns_parse_query_response(ha, buffer, buffer_size,
+					      &isns_error,
+					      discovered_target,
+					      &bIsTarget,
+					      last_iscsi_name)
+	    == QLA_SUCCESS) {
+		if (bIsTarget &&
+		    discovered_target->NameString[0] &&
+		    discovered_target->NumPortals) {
+			for (i = 0; i < ha->isns_num_discovered_targets; i++) {
+				if (!strcmp(discovered_target->NameString,
+					    ha->isns_disc_tgt_databasev[i].NameString)) {
+					QL4PRINT(QLP2, printk("scsi%d: %s: found at index %x\n",
+							      ha->host_no, __func__, i));
+					memcpy(&ha->isns_disc_tgt_databasev[i],
+					       discovered_target,
+					       sizeof(ISNS_DISCOVERED_TARGET));
+					ha->isns_disc_tgt_databasev[i] = *discovered_target;
+					bFound = 1;
+					break;
+				}
+			}
+			if (!bFound && i < MAX_ISNS_DISCOVERED_TARGETS) {
+				QL4PRINT(QLP20,
+					 printk("scsi%d: %s: not already present, "
+						"put in index %x\n",
+						ha->host_no, __func__, i));
+				memcpy(&ha->isns_disc_tgt_databasev[i],
+				       discovered_target,
+				       sizeof(ISNS_DISCOVERED_TARGET));
+				ha->isns_num_discovered_targets++;
+			}
+		}
+	}
+
+	if (test_bit(ISNS_FLAG_QUERY_SINGLE_OBJECT, &ha->isns_flags)) {
+		goto exit_qry_rsp_clear_flags;
+	}
+	else if (last_iscsi_name[0] == 0) {
+		goto exit_qry_rsp_clear_flags;
+	}
+	else {
+		if (qla4xxx_isns_dev_get_next (ha, last_iscsi_name) != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: "
+					"qla4xxx_isns_dev_get_next failed\n",
+					ha->host_no, __func__));
+			goto exit_qry_rsp_clear_flags;
+		}
+	}
+
+	goto exit_qry_rsp;
+
+	exit_qry_rsp_clear_flags:
+	ISNS_CLEAR_FLAGS(ha);
+
+	exit_qry_rsp:
+	if (last_iscsi_name) kfree(last_iscsi_name);
+	if (discovered_target) kfree (discovered_target);
+	return(status);
+}
+
+uint8_t
+qla4xxx_isns_dev_get_next(scsi_qla_host_t *ha,
+			  uint8_t *last_iscsi_name)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t packet_size;
+
+	if ((pdu_entry = qla4xxx_get_pdu(ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_dev_get_next_packet (ha, pdu_entry->Buff,
+						    pdu_entry->BuffLen,
+						    last_iscsi_name,
+						    &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_isns_build_dev_get_next_packet failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP10, printk("scsi%d: %s: Dump Send Buff %p %x\n",
+			       ha->host_no, __func__, pdu_entry->Buff,
+			       pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes (QLP10, pdu_entry->Buff, pdu_entry->SendBuffLen);
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s:                     sending  %d DevGetNext\n",
+			       ha->host_no, __func__, ha->isns_transaction_id));
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					pdu_entry->Buff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_get_next_rsp(scsi_qla_host_t *ha,
+			      uint8_t *buffer,
+			      uint32_t buffer_size)
+{
+	uint32_t isns_error = 0;
+	uint8_t bIsTarget;
+	static uint8_t last_iscsi_name[256];
+
+	if (test_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags)) {
+		clear_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+		ha->isns_num_discovered_targets = 0;
+		if (qla4xxx_isns_dev_get_next(ha, NULL) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+					      ha->host_no, __func__));
+			goto exit_get_next_rsp;
+		}
+		return(QLA_SUCCESS);
+	}
+
+	if (qla4xxx_isns_parse_get_next_response(ha, buffer, buffer_size,
+						 &isns_error, &last_iscsi_name[0],
+						 sizeof(last_iscsi_name) - 1,
+						 &bIsTarget)
+	    != QLA_SUCCESS) {
+		if (isns_error != ISNS_ERR_NO_SUCH_ENTRY) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_parse_get_next_response failed\n",
+					      ha->host_no, __func__));
+		}
+		goto exit_get_next_rsp;
+	}
+
+    #if 1
+	if (bIsTarget) {
+		if (qla4xxx_isns_dev_attr_qry(ha, &last_iscsi_name[0]) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_attr_qry failed\n",
+					      ha->host_no, __func__));
+			goto exit_get_next_rsp;
+		}
+	}
+	else {
+		if (qla4xxx_isns_dev_get_next(ha, &last_iscsi_name[0]) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_get_next failed\n",
+					      ha->host_no, __func__));
+			goto exit_get_next_rsp;
+		}
+	}
+    #else
+	if (qla4xxx_isns_dev_attr_qry(ha, &last_iscsi_name[0]) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_attr_qry failed\n",
+				      ha->host_no, __func__));
+		goto exit_get_next_rsp;
+	}
+    #endif
+
+	return(QLA_SUCCESS);
+
+	exit_get_next_rsp:
+	clear_bit(ISNS_FLAG_SCN_IN_PROGRESS, &ha->isns_flags);
+	clear_bit(ISNS_FLAG_SCN_RESTART, &ha->isns_flags);
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_dev_dereg(scsi_qla_host_t *ha)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t packet_size;
+
+	if ((pdu_entry = qla4xxx_get_pdu (ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n",
+				      ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_deregistration_packet(ha, pdu_entry->Buff,
+						     pdu_entry->BuffLen,
+						     ha->isns_entity_id,
+						     ha->isns_ip_address,
+						     ha->isns_server_port_number,
+						     &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s:  QLiSNSBuildDeregistrationPacket failed\n",
+				ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+
+	QL4PRINT(QLP10, printk("scsi%d: %s: Dump Send Buff %p %x\n",
+			       ha->host_no, __func__, pdu_entry->Buff,
+			       pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes(QLP10, pdu_entry->Buff, pdu_entry->SendBuffLen);
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20,
+		 printk("scsi%d: %s:                       sending  %d DevDereg\n",
+			ha->host_no, __func__, ha->isns_transaction_id));
+
+	if (qla4xxx_send_passthru0_iocb(ha, ISNS_DEVICE_INDEX,
+					ISNS_DEFAULT_SERVER_CONN_ID,
+					pdu_entry->Buff,
+					pdu_entry->SendBuffLen,
+					pdu_entry->RecvBuffLen,
+					PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					qla4xxx_isns_build_iocb_handle(ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n",
+				      ha->host_no, __func__));
+		qla4xxx_free_pdu(ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+
+uint8_t
+qla4xxx_isns_dev_dereg_rsp(scsi_qla_host_t *ha,
+			   uint8_t *buffer,
+			   uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER * isns_message;
+	ISNSP_RESPONSE_HEADER * isns_response;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+
+	clear_bit(ISNS_FLAG_ISNS_SRV_REGISTERED, &ha->isns_flags);
+
+	if (isns_response->error_code) {
+		QL4PRINT(QLP10, printk("scsi%d: %s: iSNS SCNDereg rsp code %x\n",
+				       ha->host_no, __func__,
+				       DWSWAP(isns_response->error_code)));
+	}
+
+	if (test_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags)) {
+		clear_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags);
+
+		if (qla4xxx_isns_dev_attr_reg(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: qla4xxx_isns_dev_attr_reg failed\n",
+					      ha->host_no, __func__));
+			return(QLA_ERROR);
+		}
+	}
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn_dereg(scsi_qla_host_t *ha)
+{
+	PDU_ENTRY *pdu_entry;
+	uint32_t packet_size;
+
+	if ((pdu_entry = qla4xxx_get_pdu(ha, PAGE_SIZE)) == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_get_pdu failed\n", ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_isns_build_scn_deregistration_packet(ha, pdu_entry->Buff,
+							 pdu_entry->BuffLen,
+							 &packet_size)
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  QLiSNSBuildSCNDeregistrationPacket failed\n", ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+
+	pdu_entry->SendBuffLen = packet_size;
+	pdu_entry->RecvBuffLen = pdu_entry->BuffLen;
+	QL4PRINT(QLP10, printk("scsi%d: %s: Dump Send Buff %p %x\n",
+			       ha->host_no, __func__, pdu_entry->Buff,
+			       pdu_entry->SendBuffLen));
+	qla4xxx_dump_bytes (QLP10, pdu_entry->Buff, pdu_entry->SendBuffLen);
+	QL4PRINT(QLP20, printk("---------------------------\n"));
+	QL4PRINT(QLP20, printk("scsi%d: %s:                       sending  %d SCNDereg\n", ha->host_no, __func__, ha->isns_transaction_id));
+	if (qla4xxx_send_passthru0_iocb (ha, ISNS_DEVICE_INDEX,
+					 ISNS_DEFAULT_SERVER_CONN_ID,
+					 pdu_entry->Buff,
+					 pdu_entry->SendBuffLen,
+					 pdu_entry->RecvBuffLen,
+					 PT_FLAG_ISNS_PDU | PT_FLAG_WAIT_4_RESPONSE,
+					 qla4xxx_isns_build_iocb_handle (ha, ISNS_REQ_RSP_PDU, pdu_entry))
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s:  qla4xxx_send_passthru0_iocb failed\n", ha->host_no, __func__));
+		qla4xxx_free_pdu (ha, pdu_entry);
+		return(QLA_ERROR);
+	}
+	ha->isns_transaction_id++;
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_scn_dereg_rsp(scsi_qla_host_t *ha,
+			   uint8_t *buffer,
+			   uint32_t buffer_size)
+{
+	ISNSP_MESSAGE_HEADER *isns_message;
+	ISNSP_RESPONSE_HEADER *isns_response;
+
+	isns_message = (ISNSP_MESSAGE_HEADER *) buffer;
+	isns_response = (ISNSP_RESPONSE_HEADER *) isns_message->payload;
+
+	clear_bit(ISNS_FLAG_ISNS_SCN_REGISTERED, &ha->isns_flags);
+
+	if (isns_response->error_code) {
+		QL4PRINT(QLP10, printk("scsi%d: %s: iSNS SCNDereg rsp code %x\n",
+				       ha->host_no, __func__,
+				       DWSWAP(isns_response->error_code)));
+	}
+
+	if (test_bit(ISNS_FLAG_REREGISTER, &ha->isns_flags)) {
+		if (qla4xxx_isns_dev_dereg(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: QLiSNSDevDereg failed\n",
+					      ha->host_no, __func__));
+			return(QLA_ERROR);
+		}
+	}
+	return(QLA_SUCCESS);
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_isns.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_isns.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_isns.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_isns.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,373 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+#define ISNSP_VERSION           0x0001  // Current iSNS version as defined by
+// the latest spec that we support
+
+/* Swap Macros
+ *
+ * These are designed to be used on constants (such as the function codes
+ * below) such that the swapping is done by the compiler at compile time
+ * and not at run time.  Of course, they should also work on variables
+ * in which case the swapping will occur at run time.
+ */
+#define WSWAP(x) (uint16_t)(((((uint16_t)x)<<8)&0xFF00) | \
+                            ((((uint16_t)x)>>8)&0x00FF))
+#define DWSWAP(x) (uint32_t)(((((uint32_t)x)<<24)&0xFF000000) | \
+		             ((((uint32_t)x)<<8)&0x00FF0000) |  \
+		             ((((uint32_t)x)>>8)&0x0000FF00) |  \
+		             ((((uint32_t)x)>>24)&0x000000FF))
+
+/*
+ * Timeout Values
+ *******************/
+#define ISNS_RESTART_TOV	5
+
+#define IOCB_ISNS_PT_PDU_TYPE(x)                      ((x) & 0x0F000000)
+#define IOCB_ISNS_PT_PDU_INDEX(x)                     ((x) & (MAX_PDU_ENTRIES-1))
+
+#define ISNS_ASYNCH_REQ_PDU                           0x01000000
+#define ISNS_ASYNCH_RSP_PDU                           0x02000000
+#define ISNS_REQ_RSP_PDU                              0x03000000
+
+
+// Fake device indexes.  Used internally by the driver for indexing to other than a DDB entry
+#define ISNS_DEVICE_INDEX                             MAX_DEV_DB_ENTRIES + 0
+
+#define ISNS_CLEAR_FLAGS(ha) do {clear_bit(ISNS_FLAG_SCN_IN_PROGRESS |    \
+                                       ISNS_FLAG_SCN_RESTART | 	      \
+				       ISNS_FLAG_QUERY_SINGLE_OBJECT, \
+				       &ha->isns_flags);} while(0);
+
+
+
+// iSNS Message Function ID codes
+
+#define ISNS_FCID_DevAttrReg      0x0001      // Device Attribute Registration Request
+#define ISNS_FCID_DevAttrQry      0x0002      // Device Attribute Query Request
+#define ISNS_FCID_DevGetNext      0x0003      // Device Get Next Request
+#define ISNS_FCID_DevDereg        0x0004      // Device Deregister Request
+#define ISNS_FCID_SCNReg          0x0005      // SCN Register Request
+#define ISNS_FCID_SCNDereg        0x0006      // SCN Deregister Request
+#define ISNS_FCID_SCNEvent        0x0007      // SCN Event
+#define ISNS_FCID_SCN             0x0008      // State Change Notification
+#define ISNS_FCID_DDReg           0x0009      // DD Register
+#define ISNS_FCID_DDDereg         0x000A      // DD Deregister
+#define ISNS_FCID_DDSReg          0x000B      // DDS Register
+#define ISNS_FCID_DDSDereg        0x000C      // DDS Deregister
+#define ISNS_FCID_ESI             0x000D      // Entity Status Inquiry
+#define ISNS_FCID_Heartbeat       0x000E      // Name Service Heartbeat
+//NOT USED              0x000F-0x0010
+#define ISNS_FCID_RqstDomId       0x0011      // Request FC_DOMAIN_ID
+#define ISNS_FCID_RlseDomId       0x0012      // Release FC_DOMAIN_ID
+#define ISNS_FCID_GetDomId        0x0013      // Get FC_DOMAIN_IDs
+//RESERVED              0x0014-0x00FF
+//Vendor Specific       0x0100-0x01FF
+//RESERVED              0x0200-0x8000
+
+
+// iSNS Response Message Function ID codes
+
+#define ISNS_FCID_DevAttrRegRsp   0x8001      // Device Attribute Registration Response
+#define ISNS_FCID_DevAttrQryRsp   0x8002      // Device Attribute Query Response
+#define ISNS_FCID_DevGetNextRsp   0x8003      // Device Get Next Response
+#define ISNS_FCID_DevDeregRsp     0x8004      // Deregister Device Response
+#define ISNS_FCID_SCNRegRsp       0x8005      // SCN Register Response
+#define ISNS_FCID_SCNDeregRsp     0x8006      // SCN Deregister Response
+#define ISNS_FCID_SCNEventRsp     0x8007      // SCN Event Response
+#define ISNS_FCID_SCNRsp          0x8008      // SCN Response
+#define ISNS_FCID_DDRegRsp        0x8009      // DD Register Response
+#define ISNS_FCID_DDDeregRsp      0x800A      // DD Deregister Response
+#define ISNS_FCID_DDSRegRsp       0x800B      // DDS Register Response
+#define ISNS_FCID_DDSDeregRsp     0x800C      // DDS Deregister Response
+#define ISNS_FCID_ESIRsp          0x800D      // Entity Status Inquiry Response
+//NOT USED              0x800E-0x8010
+#define ISNS_FCID_RqstDomIdRsp    0x8011      // Request FC_DOMAIN_ID Response
+#define ISNS_FCID_RlseDomIdRsp    0x8012      // Release FC_DOMAIN_ID Response
+#define ISNS_FCID_GetDomIdRsp     0x8013      // Get FC_DOMAIN_IDs Response
+//RESERVED              0x8014-0x80FF
+//Vendor Specific       0x8100-0x81FF
+//RESERVED              0x8200-0xFFFF
+
+
+// iSNS Error Codes
+
+#define ISNS_ERR_SUCCESS                    0   // Successful
+#define ISNS_ERR_UNKNOWN                    1   // Unknown Error
+#define ISNS_ERR_MSG_FORMAT                 2   // Message Format Error
+#define ISNS_ERR_INVALID_REG                3   // Invalid Registration
+//RESERVED                                  4
+#define ISNS_ERR_INVALID_QUERY              5   // Invalid Query
+#define ISNS_ERR_SOURCE_UNKNOWN             6   // Source Unknown
+#define ISNS_ERR_SOURCE_ABSENT              7   // Source Absent
+#define ISNS_ERR_SOURCE_UNAUTHORIZED        8   // Source Unauthorized
+#define ISNS_ERR_NO_SUCH_ENTRY              9   // No Such Entry
+#define ISNS_ERR_VER_NOT_SUPPORTED          10  // Version Not Supported
+#define ISNS_ERR_INTERNAL_ERROR             11  // Internal Error
+#define ISNS_ERR_BUSY                       12  // Busy
+#define ISNS_ERR_OPT_NOT_UNDERSTOOD         13  // Option Not Understood
+#define ISNS_ERR_INVALID_UPDATE             14  // Invalid Update
+#define ISNS_ERR_MSG_NOT_SUPPORTED          15  // Message (FUNCTION_ID) Not Supported
+#define ISNS_ERR_SCN_EVENT_REJECTED         16  // SCN Event Rejected
+#define ISNS_ERR_SCN_REG_REJECTED           17  // SCN Registration Rejected
+#define ISNS_ERR_ATTR_NOT_IMPLEMENTED       18  // Attribute Not Implemented
+#define ISNS_ERR_FC_DOMAIN_ID_NOT_AVAIL     19  // FC_DOMAIN_ID Not Available
+#define ISNS_ERR_FC_DOMAIN_ID_NOT_ALLOC     20  // FC_DOMAIN_ID Not Allocated
+#define ISNS_ERR_ESI_NOT_AVAILABLE          21  // ESI Not Available
+#define ISNS_ERR_INVALID_DEREG              22  // Invalid Deregistration
+#define ISNS_ERR_REG_FEATURES_NOT_SUPPORTED 23  // Registration Features Not Supported
+
+#define ISNS_ERROR_CODE_TBL()	{  \
+	"SUCCESSFUL"	        		, \
+	"UNKNOWN ERROR"	        		, \
+	"MESSAGE FORMAT ERROR"	        	, \
+	"INVALID REGISTRATION"	        	, \
+	"RESERVED"	        		, \
+	"INVALID QUERY"	        		, \
+	"SOURCE UNKNOWN"	        	, \
+	"SOURCE ABSENT"	        		, \
+	"SOURCE UNAUTHORIZED"	        	, \
+	"NO SUCH ENTRY"	        		, \
+	"VERSION NOT SUPPORTED"	        	, \
+	"INTERNAL ERROR"	        	, \
+	"BUSY"	        			, \
+	"OPTION NOT UNDERSTOOD"	        	, \
+	"INVALID UPDATE"	        	, \
+	"MESSAGE (FUNCTION_ID) NOT SUPPORTED"	, \
+	"SCN EVENT REJECTED"	        	, \
+	"SCN REGISTRATION REJECTED"	        , \
+	"ATTRIBUTE NOT IMPLEMENTED"	        , \
+	"FC_DOMAIN_ID NOT AVAILABLE"	        , \
+	"FC_DOMAIN_ID NOT ALLOCATED"	        , \
+	"ESI NOT AVAILABLE"	        	, \
+	"INVALID DEREGISTRATION"	        , \
+	"REGISTRATION FEATURES NOT SUPPORTED"	, \
+	NULL			  \
+}
+
+
+// iSNS Protocol Structures
+
+typedef struct {
+	uint16_t isnsp_version;
+	uint16_t function_id;
+	uint16_t pdu_length;   // Length of the payload (does not include header)
+	uint16_t flags;
+	uint16_t transaction_id;
+	uint16_t sequence_id;
+	uint8_t payload[0];   // Variable payload data
+} ISNSP_MESSAGE_HEADER, *PISNSP_MESSAGE_HEADER;
+
+typedef struct {
+	uint32_t error_code;
+	uint8_t attributes[0];
+} ISNSP_RESPONSE_HEADER, *PISNSP_RESPONSE_HEADER;
+
+
+// iSNS Message Flags Definitions
+
+#define ISNSP_CLIENT_SENDER         0x8000
+#define ISNSP_SERVER_SENDER         0x4000
+#define ISNSP_AUTH_BLOCK_PRESENT    0x2000
+#define ISNSP_REPLACE_FLAG          0x1000
+#define ISNSP_LAST_PDU              0x0800
+#define ISNSP_FIRST_PDU             0x0400
+
+#define ISNSP_VALID_FLAGS_MASK  (ISNSP_CLIENT_SENDER | \
+                                 ISNSP_SERVER_SENDER | \
+                                 ISNSP_AUTH_BLOCK_PRESENT | \
+                                 ISNSP_REPLACE_FLAG | \
+                                 ISNSP_LAST_PDU | \
+                                 ISNSP_FIRST_PDU)
+
+
+// iSNS Attribute Structure
+
+typedef struct {
+	uint32_t tag;
+	uint32_t length;
+	uint8_t value[0];     // Variable length data
+} ISNS_ATTRIBUTE, *PISNS_ATTRIBUTE;
+
+
+
+
+// The following macro assumes that the attribute is wholly contained within
+// the buffer in question and is valid (see VALIDATE_ATTR below).
+
+#define NEXT_ATTR(pattr)    \
+    (PISNS_ATTRIBUTE)(pattr->value + DWSWAP(pattr->length))
+
+static inline uint8_t
+VALIDATE_ATTR(PISNS_ATTRIBUTE PAttr, uint8_t *buffer_end)
+{
+	// Ensure that the Length field of the current attribute is contained
+	// within the buffer before trying to read it, and then be sure that
+	// the entire attribute is contained within the buffer.
+
+	if ((((unsigned long)&PAttr->length + sizeof(PAttr->length)) <= (unsigned long)buffer_end) &&
+	    (unsigned long)NEXT_ATTR(PAttr) <= (unsigned long)buffer_end) {
+//printk("%s: end attr_len = 0x%x, end_buf = 0x%x\n", __func__,
+//       (unsigned long)&PAttr->length + sizeof(PAttr->length),
+//       (unsigned long)buffer_end);
+
+		return(1);
+	}
+
+	return(0);
+}
+
+
+// iSNS-defined Attribute Tags
+
+#define ISNS_ATTR_TAG_DELIMITER                     0
+#define ISNS_ATTR_TAG_ENTITY_IDENTIFIER             1
+#define ISNS_ATTR_TAG_ENTITY_PROTOCOL               2
+#define ISNS_ATTR_TAG_MGMT_IP_ADDRESS               3
+#define ISNS_ATTR_TAG_TIMESTAMP                     4
+#define ISNS_ATTR_TAG_PROTOCOL_VERSION_RANGE        5
+#define ISNS_ATTR_TAG_REGISTRATION_PERIOD           6
+#define ISNS_ATTR_TAG_ENTITY_INDEX                  7
+#define ISNS_ATTR_TAG_ENTITY_NEXT_INDEX             8
+#define ISNS_ATTR_TAG_ENTITY_ISAKMP_PHASE_1         11
+#define ISNS_ATTR_TAG_ENTITY_CERTIFICATE            12
+#define ISNS_ATTR_TAG_PORTAL_IP_ADDRESS             16
+#define ISNS_ATTR_TAG_PORTAL_PORT                   17
+#define ISNS_ATTR_TAG_PORTAL_SYMBOLIC_NAME          18
+#define ISNS_ATTR_TAG_ESI_INTERVAL                  19
+#define ISNS_ATTR_TAG_ESI_PORT                      20
+#define ISNS_ATTR_TAG_PORTAL_GROUP                  21
+#define ISNS_ATTR_TAG_PORTAL_INDEX                  22
+#define ISNS_ATTR_TAG_SCN_PORT                      23
+#define ISNS_ATTR_TAG_PORTAL_NEXT_INDEX             24
+#define ISNS_ATTR_TAG_PORTAL_SECURITY_BITMAP        27
+#define ISNS_ATTR_TAG_PORTAL_ISAKMP_PHASE_1         28
+#define ISNS_ATTR_TAG_PORTAL_ISAKMP_PHASE_2         29
+#define ISNS_ATTR_TAG_PORTAL_CERTIFICATE            31
+#define ISNS_ATTR_TAG_ISCSI_NAME                    32
+#define ISNS_ATTR_TAG_ISCSI_NODE_TYPE               33
+#define ISNS_ATTR_TAG_ISCSI_ALIAS                   34
+#define ISNS_ATTR_TAG_ISCSI_SCN_BITMAP              35
+#define ISNS_ATTR_TAG_ISCSI_NODE_INDEX              36
+#define ISNS_ATTR_TAG_WWNN_TOKEN                    37
+#define ISNS_ATTR_TAG_ISCSI_NODE_NEXT_INDEX         38
+#define ISNS_ATTR_TAG_ISCSI_AUTH_METHOD             42
+#define ISNS_ATTR_TAG_ISCSI_NODE_CERTIFICATE        43
+#define ISNS_ATTR_TAG_PG_TAG                        48
+#define ISNS_ATTR_TAG_PG_ISCSI_NAME                 49
+#define ISNS_ATTR_TAG_PG_PORTAL_IP_ADDRESS          50
+#define ISNS_ATTR_TAG_PG_PORTAL_PORT                51
+#define ISNS_ATTR_TAG_PG_INDEX                      52
+#define ISNS_ATTR_TAG_PG_NEXT_INDEX                 53
+#define ISNS_ATTR_TAG_FC_PORT_NAME_WWPN             64
+#define ISNS_ATTR_TAG_PORT_ID                       65
+#define ISNS_ATTR_TAG_FC_PORT_TYPE                  66
+#define ISNS_ATTR_TAG_SYMBOLIC_PORT_NAME            67
+#define ISNS_ATTR_TAG_FABRIC_PORT_NAME              68
+#define ISNS_ATTR_TAG_HARD_ADDRESS                  69
+#define ISNS_ATTR_TAG_PORT_IP_ADDRESS               70
+#define ISNS_ATTR_TAG_CLASS_OF_SERVICE              71
+#define ISNS_ATTR_TAG_FC4_TYPES                     72
+#define ISNS_ATTR_TAG_FC4_DESCRIPTOR                73
+#define ISNS_ATTR_TAG_FC4_FEATURES                  74
+#define ISNS_ATTR_TAG_IFCP_SCN_BITMAP               75
+#define ISNS_ATTR_TAG_PORT_ROLE                     76
+#define ISNS_ATTR_TAG_PERMANENT_PORT_NAME           77
+#define ISNS_ATTR_TAG_PORT_CERTIFICATE              83
+#define ISNS_ATTR_TAG_FC4_TYPE_CODE                 95
+#define ISNS_ATTR_TAG_FC_NODE_NAME_WWNN             96
+#define ISNS_ATTR_TAG_SYMBOLIC_NODE_NAME            97
+#define ISNS_ATTR_TAG_NODE_IP_ADDRESS               98
+#define ISNS_ATTR_TAG_NODE_IPA                      99
+#define ISNS_ATTR_TAG_NODE_CERTIFICATE              100
+#define ISNS_ATTR_TAG_PROXY_ISCSI_NAME              101
+#define ISNS_ATTR_TAG_SWITCH_NAME                   128
+#define ISNS_ATTR_TAG_PREFERRED_ID                  129
+#define ISNS_ATTR_TAG_ASSIGNED_ID                   130
+#define ISNS_ATTR_TAG_VIRTUAL_FABRIC_ID             131
+#define ISNS_ATTR_TAG_VENDOR_OUI                    256
+//Vendor-specific iSNS Server                       257-384
+//Vendor-specific Entity                            385-512
+//Vendor-specific Portal                            513-640
+//Vendor-specific iSCSI Node                        641-768
+//Vendor-specific FC Port Name                      769-896
+//Vendor-specific FC Node Name                      897-1024
+//Vendor-specific DDS                               1025-1280
+//Vendor-Specific DD                                1281-1536
+//Vendor-specific (other)                           1237-2048
+#define ISNS_ATTR_TAG_DD_SET_ID                     2049
+#define ISNS_ATTR_TAG_DD_SET_SYMBOLIC_NAME          2050
+#define ISNS_ATTR_TAG_DD_SET_STATUS                 2051
+#define ISNS_ATTR_TAG_DD_SET_NEXT_ID                2052
+#define ISNS_ATTR_TAG_DD_ID                         2065
+#define ISNS_ATTR_TAG_DD_SYMBOLIC_NAME              2066
+#define ISNS_ATTR_TAG_DD_MEMBER_ISCSI_INDEX         2067
+#define ISNS_ATTR_TAG_DD_MEMBER_ISCSI_NAME          2068
+#define ISNS_ATTR_TAG_DD_MEMBER_IFCP_NODE           2069
+#define ISNS_ATTR_TAG_DD_MEMBER_PORTAL_INDEX        2070
+#define ISNS_ATTR_TAG_DD_MEMBER_PORTAL_IP_ADDRESS   2071
+#define ISNS_ATTR_TAG_DD_MEMBER_PORTAL_PORT         2072
+#define ISNS_ATTR_TAG_DD_FEATURES                   2078
+#define ISNS_ATTR_TAG_DD_ID_NEXT_ID                 2079
+
+
+// Definitions used for Entity Protocol
+
+#define ENTITY_PROTOCOL_NEUTRAL                 1
+#define ENTITY_PROTOCOL_ISCSI                   2
+#define ENTITY_PROTOCOL_IFCP                    3
+
+
+// Definitions used for iSCSI Node Type
+
+#define ISCSI_NODE_TYPE_TARGET                  0x00000001
+#define ISCSI_NODE_TYPE_INITIATOR               0x00000002
+#define ISCSI_NODE_TYPE_CONTROL                 0x00000004
+
+
+// Definitions used for iSCSI Node SCN Bitmap
+
+#define ISCSI_SCN_DD_DDS_MEMBER_ADDED           0x00000001  // Management SCN only
+#define ISCSI_SCN_DD_DDS_MEMBER_REMOVED         0x00000002  // Management SCN only
+#define ISCSI_SCN_OBJECT_UPDATED                0x00000004
+#define ISCSI_SCN_OBJECT_ADDED                  0x00000008
+#define ISCSI_SCN_OBJECT_REMOVED                0x00000010
+#define ISCSI_SCN_MANAGEMENT_SCN                0x00000020
+#define ISCSI_SCN_TARGET_AND_SELF_INFO_ONLY     0x00000040
+#define ISCSI_SCN_INITIATOR_AND_SELF_INFO_ONLY  0x00000080
+
+#define ISCSI_SCN_OBJECT_MASK                   (ISCSI_SCN_OBJECT_UPDATED |     \
+                                                 ISCSI_SCN_OBJECT_ADDED |       \
+                                                 ISCSI_SCN_OBJECT_REMOVED)
+
+
+// Definitions used for iSCSI Security Bitmap
+
+#define ISNS_SECURITY_BITMAP_VALID              0x00000001
+#define ISNS_SECURITY_IKE_IPSEC_ENABLED         0x00000002
+#define ISNS_SECURITY_MAIN_MODE_ENABLED         0x00000004
+#define ISNS_SECURITY_AGGRESSIVE_MODE_ENABLED   0x00000008
+#define ISNS_SECURITY_PFS_ENABLED               0x00000010
+#define ISNS_SECURITY_TRANSPORT_MODE_PREFERRED  0x00000020
+#define ISNS_SECURITY_TUNNEL_MODE_PREFERRED     0x00000040
+
+
+// Definitions used for Portal Port
+
+#define PORTAL_PORT_NUMBER_MASK                 0x0000FFFF
+#define PORTAL_PORT_TYPE_UDP                    0x00010000
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_isr.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_isr.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_isr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_isr.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,1427 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *      qla4xxx_suspend_lun
+ *      qla4xxx_check_sense
+ *      qla4xxx_status_entry
+ *      qla4xxx_process_response_queue
+ *	qla4xxx_isr_decode_mailbox
+ *      qla4xxx_interrupt_service_routine
+ *      qla4xxx_intr_handler
+ *	qla4xxx_ok2relogin
+ *	qla4xxx_process_aen
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+static void
+qla4xxx_process_completed_request(struct scsi_qla_host *ha, uint32_t index);
+
+/*
+ * String messages for various state values (used for print statements)
+ *---------------------------------------------------------------------------*/
+const char *host_sts_msg[] = HOST_STS_TBL();
+
+
+/**************************************************************************
+ * qla4xxx_suspend_lun
+ *	This routine suspends the lun queue for the specified lun and places
+ *	all requests for this lun onto the retry queue for a specified
+ *	amount of time.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	srb - Pointer to SCSI Request Block
+ *	lun_entry - lun structure
+ *	time - Number of seconds to suspend queue
+ *	retries - Max retry count for this lun
+ *  	delay = non-zero, if lun should be delayed rather than suspended
+ *
+ * Remarks:
+ *	The suspend queue algorithm is provided as a method to keep commands
+ *	within the driver while a device is attempting to recover from certain
+ *	failures.  By keeping the commands within the driver, it prevents the
+ *	kernel's retries from being exhausted so quickly and minimizes failures
+ *	at the application level.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+void
+__qla4xxx_suspend_lun(scsi_qla_host_t *ha,
+		    srb_t *srb,
+		    os_lun_t *lun_entry,
+		    uint16_t time,
+		    uint16_t retries, int delay)
+{
+	unsigned long flags;
+	uint8_t status = 0 ;
+	srb_t *sp, *stemp;
+
+	ENTER("qla4xxx_suspend_lun");
+
+	if (lun_entry == NULL)
+		return;
+
+	spin_lock_irqsave(&lun_entry->lun_lock, flags);
+
+	if (lun_entry->lun_state == LS_LUN_READY ||
+	    lun_entry->lun_state == LS_LUN_RETRY) {
+		if (lun_entry->lun_state == LS_LUN_READY) {
+			lun_entry->max_retry_count = retries;
+			lun_entry->retry_count = 0;
+		}
+
+		/* Set the suspend time */
+		atomic_set(&lun_entry->suspend_timer, time);
+		QL4PRINT(QLP3,
+			 printk("scsi%d: %s lun %d retry count = %d\n",
+				ha->host_no, __func__, lun_entry->lun,
+				lun_entry->retry_count));
+
+		/* now suspend the lun */
+		lun_entry->lun_state = LS_LUN_SUSPENDED;
+		lun_entry->fclun->fcport->vis_ha = ha;
+		if (delay) {
+			set_bit(LS_LUN_DELAYED, &lun_entry->flags);
+		}
+		status = 1;
+
+	}
+	spin_unlock_irqrestore(&lun_entry->lun_lock, flags);
+
+	/*
+	 * Remove all pending commands from request queue
+	 * and put them in the retry queue.
+	 */
+	if (status) {
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_entry_safe(sp, stemp, &ha->pending_srb_q,
+		    list_entry) {
+			if (sp->lun_queue != lun_entry)
+				continue;
+
+			__del_from_pending_srb_q(ha, sp);
+
+			if (retries > sp->cmd->allowed)
+				sp->cmd->allowed = retries;
+			__add_to_retry_srb_q(ha,sp);
+
+		}
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+	}
+	if( srb )
+		add_to_retry_srb_q(ha,srb);
+
+	LEAVE("qla4xxx_suspend_lun");
+}
+
+/**************************************************************************
+ * qla4xxx_check_and_copy_sense
+ *	This routine processes Status IOCBs
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      sts_entry - Pointer to status entry structure
+ *	srb - Pointer to internal SCSI request block structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - We want the caller to complete the command
+ *	QLA_ERROR - We do not want the caller to complete the request
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_check_and_copy_sense(scsi_qla_host_t *ha, STATUS_ENTRY *sts_entry, srb_t *srb)
+{
+	struct scsi_cmnd *cmd = srb->cmd;
+	scsi_qla_host_t *osha;
+	uint16_t        sensebytecnt;
+	os_lun_t *lun_entry = srb->lun_queue;
+	osha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+	fc_port_t *fcport;
+
+	/* FIXMEdg: Always clear buffer */
+	memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+
+	sensebytecnt = le16_to_cpu(sts_entry->senseDataByteCnt);
+	if (sensebytecnt == 0)
+		return(QLA_SUCCESS);
+
+	/* always perform the copy to cmd fields */
+	CMD_ACTUAL_SNSLEN(cmd) = sensebytecnt;
+
+	memcpy(cmd->sense_buffer,
+	       sts_entry->senseData,
+	       MIN(sensebytecnt, sizeof(cmd->sense_buffer)));
+
+	if (!(srb->flags & (SRB_IOCTL_CMD | SRB_TAPE)))
+		return(QLA_SUCCESS);
+
+	/* check for vaild sense data */
+	if ((sts_entry->senseData[0] & 0x70) != 0x70)
+		return(QLA_SUCCESS);
+
+	QL4PRINT(QLP2,
+		 printk("scsi%d:%d:%d:%d: %s: "
+			"sense key = "
+			"%x, ASC/ASCQ = %02x/%02x\n",
+			ha->host_no, cmd->device->channel,
+			cmd->device->id, cmd->device->lun, __func__,
+			sts_entry->senseData[2] & 0x0f,
+			sts_entry->senseData[12],
+			sts_entry->senseData[13]));
+
+	srb->flags |= SRB_GOT_SENSE;
+
+	switch (sts_entry->senseData[2] & 0x0f) {
+	case RECOVERED_ERROR:
+		cmd->result = DID_OK << 16;
+		cmd->sense_buffer[0] = 0;
+		break;
+
+	case NOT_READY:
+	case HARDWARE_ERROR:
+		fcport = lun_entry->fclun->fcport;
+
+		/*
+		 * Suspend the lun only for hard disk device type.
+		 */
+		if (test_bit(AF_INIT_DONE, &ha->flags) &&
+		    lun_entry != NULL &&
+		    (fcport->flags & FCF_TAPE_PRESENT) == 0 &&
+		    lun_entry->lun_state != LS_LUN_TIMEOUT) {
+			/*
+			 * If target is in process of being ready then suspend
+			 * lun for 6 secs and retry all the commands.
+			 */
+			if (sts_entry->senseData[12] == 0x4 &&
+			    sts_entry->senseData[13] == 0x1) {
+				/* To give the lun more time to become ready,
+				 * suspend lun then retry command */
+				qla4xxx_suspend_lun(osha, srb, lun_entry,
+						    SUSPEND_SECONDS,
+						    SUSPEND_RETRIES);
+				return(QLA_ERROR);
+			}
+			else if (sts_entry->senseData[12] == 0x8 &&
+				 sts_entry->senseData[13] == 0x0) {
+				/* To give the lun more time to become ready,
+				 * suspend lun then retry command */
+				qla4xxx_suspend_lun(osha, srb, lun_entry,
+						    SUSPEND_SECONDS,
+						    (ha->port_down_retry_count /
+						     SUSPEND_SECONDS)) ;
+				return(QLA_ERROR);
+			}
+		}
+		break;
+	}
+
+	return(QLA_SUCCESS);
+}
+
+
+/**************************************************************************
+ * qla4xxx_status_entry
+ *	This routine processes Status IOCBs
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      sts_entry - Pointer to status entry structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static void
+qla4xxx_status_entry(scsi_qla_host_t *ha, STATUS_ENTRY *sts_entry)
+{
+	srb_t *srb;
+	uint8_t scsi_status;
+
+	ENTER("qla4xxx_status_entry");
+
+	/* FIXMEdg: Fast path completion. */
+	if (sts_entry->completionStatus == SCS_COMPLETE &&
+	    sts_entry->scsiStatus == 0) {
+		qla4xxx_process_completed_request(ha, le32_to_cpu(sts_entry->handle));
+
+		return;
+	}
+
+	srb = del_from_active_array(ha, le32_to_cpu(sts_entry->handle));
+	if (srb) {
+		struct scsi_cmnd *cmd = srb->cmd;
+		uint32_t residual = le32_to_cpu(sts_entry->residualByteCnt);
+		ddb_entry_t *ddb_entry = srb->fclun->fcport->ddbptr;
+
+		/* FIXMEdg: MISSING cmd and lun pointer checks */
+		if (cmd == NULL) {
+			DEBUG2(printk("scsi(%d): Command already returned back to OS "
+				      "pkt->handle=%d srb=%p srb->state:%d\n",
+				      ha->host_no, sts_entry->handle, srb, srb->state));
+			printk(KERN_WARNING
+			       "Command is NULL: already returned to OS (srb=%p)\n", srb);
+
+			return;
+		}
+
+		// if (CMD_SP(cmd) == NULL)
+		// return;
+		if (srb->lun_queue == NULL) {
+			DEBUG2(printk("scsi(%d): Status Entry invalid lun pointer.\n",
+				      ha->host_no));
+			/* FIXMEdg: Don't we need to reset ISP in this case??? */
+		}
+
+		if (ddb_entry == NULL) {
+			cmd->result = DID_NO_CONNECT << 16;
+			goto status_entry_exit;
+		}
+		/*
+		 * Translate ISP error to a Linux SCSI error
+		 */
+		scsi_status = sts_entry->scsiStatus;
+
+		switch (sts_entry->completionStatus) {
+		case SCS_COMPLETE:
+
+			if (scsi_status == 0) {
+				cmd->result = DID_OK << 16;
+				break;
+			}
+
+			if (sts_entry->iscsiFlags & ( ISCSI_FLAG_RESIDUAL_OVER | ISCSI_FLAG_RESIDUAL_UNDER)) {
+				cmd->resid = residual;
+				// CMD_RESID_LEN(cmd) = residual;
+			}
+
+			if (scsi_status == SCSISTAT_BUSY) {
+				cmd->result = DID_BUS_BUSY << 16 | scsi_status;
+				break;
+			}
+
+			if (scsi_status != SCSISTAT_CHECK_CONDITION)
+				break;
+
+			/* Check for sense errors */
+			if (qla4xxx_check_and_copy_sense(ha, sts_entry ,srb) == QLA_ERROR) {
+				LEAVE("qla4xxx_status_entry");
+				return;	 /* DO NOT complete request */
+			}
+
+			break;
+
+		case SCS_INCOMPLETE:
+			QL4PRINT(QLP2,
+				 printk("%s: %d:%d:%d:%d: Incomplete, "
+					"state=0x%02x\n", __func__,
+					ha->host_no, cmd->device->channel,
+					cmd->device->id, cmd->device->lun,
+					sts_entry->state_flags));
+
+			/* Always set the status to DID_ERROR, since
+			 * all conditions result in that status anyway */
+			cmd->result = DID_ERROR << 16;
+			break;
+
+		case SCS_RESET_OCCURRED:
+			QL4PRINT(QLP2|QLP3, printk("scsi%d:%d:%d:%d: %s: "
+						   "Device RESET occurred\n",
+						   ha->host_no,
+						   cmd->device->channel,
+						   cmd->device->id,
+						   cmd->device->lun,
+						   __func__));
+
+			/* FIXME: Should we requeue RESET status ??? */
+			// cmd->result = DID_RESET << 16;
+			if (srb->flags & (SRB_IOCTL_CMD | SRB_TAPE)) {
+				cmd->result = DID_RESET << 16;
+			}
+			else {
+				qla4xxx_extend_timeout(cmd, EXTEND_CMD_TOV);
+				add_to_retry_srb_q(ha, srb);
+				return;
+			}
+
+			break;
+
+		case SCS_ABORTED:
+			QL4PRINT(QLP2|QLP3, printk("scsi%d:%d:%d:%d: %s: "
+						   "Abort occurred\n",
+						   ha->host_no,
+						   cmd->device->channel,
+						   cmd->device->id,
+						   cmd->device->lun,
+						   __func__));
+
+			cmd->result = DID_ABORT << 16;
+			// ha->aborted_io_count++;
+			break;
+
+		case SCS_TIMEOUT:
+			QL4PRINT(QLP2, printk(KERN_INFO "scsi%d:%d:%d:%d: "
+					      "Timeout\n",
+					      ha->host_no, cmd->device->channel,
+					      cmd->device->id,
+					      cmd->device->lun));
+
+			/* F/W logout the connection when this occurs */
+			cmd->result = DID_BUS_BUSY << 16;
+
+			/*
+			 * Mark device missing so that we won't continue to send
+			 * I/O to this device.  We should get a ddb state change
+			 * AEN soon.
+			 */
+			if ((atomic_read(&ddb_entry->state) == DEV_STATE_ONLINE))
+				qla4xxx_mark_device_missing(ha, ddb_entry);
+			break;
+
+		case SCS_DATA_UNDERRUN:
+		case SCS_DATA_OVERRUN:
+			if ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_OVER) != 0) {
+				QL4PRINT(QLP2,
+					 printk("scsi%d:%d:%d:%d: %s: "
+						"Data overrun, "
+						"residual = 0x%x\n",
+						ha->host_no,
+						cmd->device->channel,
+						cmd->device->id,
+						cmd->device->lun,
+						__func__, residual));
+
+				QL4PRINT(QLP10,
+					 printk("scsi%d: %s: "
+						"response packet data\n",
+						ha->host_no, __func__));
+				qla4xxx_dump_bytes(QLP10, sts_entry,
+						   (sizeof(*sts_entry) *
+						    sts_entry->hdr.entryCount));
+
+				cmd->result = DID_ERROR << 16;
+				break;
+			}
+
+
+			if ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_UNDER) == 0) {
+				cmd->resid = residual;
+				// CMD_RESID_LEN(cmd) = residual;
+				QL4PRINT(QLP2,
+					 printk("scsi%d:%d:%d:%d: %s: "
+						"UNDERRUN status detected, "
+						"xferlen = 0x%x, "
+						"residual = 0x%x\n",
+						ha->host_no,
+						cmd->device->channel,
+						cmd->device->id,
+						cmd->device->lun,
+						__func__, cmd->request_bufflen,
+						residual));
+			}
+
+			/*
+			 * If there is scsi_status, it takes precedense over
+			 * underflow condition.
+			 */
+			if (scsi_status != 0) {
+				if (scsi_status == SCSISTAT_BUSY) {
+					cmd->result = DID_BUS_BUSY << 16 | scsi_status;
+					break;
+				}
+				cmd->result = DID_OK << 16 | scsi_status;
+
+				if (scsi_status != SCSISTAT_CHECK_CONDITION)
+					break;
+
+				/* Check for sense errors */
+				if (qla4xxx_check_and_copy_sense(ha, sts_entry ,srb) == QLA_ERROR) {
+					LEAVE("qla4xxx_status_entry");
+					return;	 /* DO NOT complete request */
+				}
+			}
+			else {
+				/*
+				 * If RISC reports underrun and target does not
+				 * report it then we must have a lost frame, so
+				 * tell upper layer to retry it by reporting a
+				 * bus busy.
+				 */
+				if ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_UNDER) == 0) {
+					QL4PRINT(QLP2,
+						 printk(KERN_INFO "scsi%d:%d:%d:%d: "
+							"%s: Dropped frame(s) "
+							"detected (%x of %x bytes)..."
+							" retrying command.\n",
+							ha->host_no,
+							cmd->device->channel,
+							cmd->device->id,
+							cmd->device->lun,
+							__func__,
+							residual,
+							cmd->request_bufflen));
+
+					cmd->result = DID_BUS_BUSY << 16;
+				}
+				else if ((cmd->request_bufflen - residual) < cmd->underflow) {
+					/*
+					 * Handle mid-layer underflow???
+					 *
+					 * For kernels less than 2.4, the driver must
+					 * return an error if an underflow is detected.
+					 * For kernels equal-to and above 2.4, the
+					 * mid-layer will appearantly handle the
+					 * underflow by detecting the residual count --
+					 * unfortunately, we do not see where this is
+					 * actually being done.  In the interim, we
+					 * will return DID_ERROR.
+					 */
+					QL4PRINT(QLP2,
+						 printk("scsi%d:%d:%d:%d: %s: "
+							"Mid-layer Data underrun, "
+							"xferlen = 0x%x, "
+							"residual = 0x%x\n",
+							ha->host_no,
+							cmd->device->channel,
+							cmd->device->id,
+							cmd->device->lun,
+							__func__, cmd->request_bufflen,
+							residual));
+
+					cmd->result = DID_ERROR << 16;
+					CMD_RESID_LEN(cmd) = residual;
+				}
+				else {
+					cmd->result = DID_OK << 16;
+				}
+			}
+			break;
+
+		case SCS_DEVICE_LOGGED_OUT:
+		case SCS_DEVICE_UNAVAILABLE:
+			/*
+			 * Mark device missing so that we won't continue to
+			 * send I/O to this device.  We should get a ddb
+			 * state change AEN soon.
+			 */
+
+			if ((atomic_read(&ddb_entry->state) == DEV_STATE_ONLINE))
+				qla4xxx_mark_device_missing(ha, ddb_entry);
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+			if ((srb->flags & SRB_TAPE) ||
+			    (atomic_read(&ddb_entry->fcport->state) == FCS_DEVICE_DEAD)) {
+				cmd->result = DID_NO_CONNECT << 16;
+				// add_to_done_srb_q(ha, srb);
+			}
+			else {
+				cmd->result = DID_ERROR << 16;
+				qla4xxx_extend_timeout(cmd, EXTEND_CMD_TOV);
+				add_to_retry_srb_q(ha, srb);
+				return;	 /* DO NOT complete request */
+			}
+#else
+			cmd->result = DID_ERROR << 16;
+#endif
+
+			break;
+
+		case SCS_QUEUE_FULL:
+			/* FIXME: Midlevel doesn't handle this too well, so get logic
+			from fibre */
+			/*
+			 * SCSI Mid-Layer handles device queue full
+			 */
+			cmd->result = DID_OK << 16 | sts_entry->scsiStatus;
+			QL4PRINT(QLP2,
+				 printk("scsi%d:%d:%d: %s: QUEUE FULL detected "
+					"compl=%02x, scsi=%02x, state=%02x, "
+					"iFlags=%02x, iResp=%02x\n",
+					ha->host_no, cmd->device->id,
+					cmd->device->lun,
+					__func__, sts_entry->completionStatus,
+					sts_entry->scsiStatus,
+					sts_entry->state_flags,
+					sts_entry->iscsiFlags,
+					sts_entry->iscsiResponse));
+			break;
+
+		case SCS_DMA_ERROR:
+		case SCS_TRANSPORT_ERROR:
+		case SCS_DATA_DIRECTION_ERROR:
+		case SCS_DEVICE_CONFIG_CHANGED:
+		default:
+			cmd->result = DID_ERROR << 16;
+			break;
+		}
+
+		status_entry_exit:
+
+
+#if REMOVE_IT
+		/* Check for errors */
+		if (qla4xxx_check_sense(ha, sts_entry ,srb) == QLA_ERROR) {
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: %s: "
+					"check sense error\n",
+					ha->host_no, __func__));
+			LEAVE("qla4xxx_status_entry");
+			return;	 /* DO NOT complete request */
+		}
+#endif
+
+		/* fill in info for passthru command */
+		CMD_SCSI_STATUS(cmd)    = sts_entry->scsiStatus;
+		/* FIXME: Add SRB flag to test for IOCTL and add tape checking logic */
+		if ((unsigned long)CMD_PASSTHRU_TYPE(cmd) == 1) {
+			CMD_COMPL_STATUS(cmd)   = sts_entry->completionStatus;
+			CMD_ISCSI_RESPONSE(cmd) = sts_entry->iscsiResponse;
+			CMD_STATE_FLAGS(cmd)    = sts_entry->state_flags;
+			CMD_HOST_STATUS(cmd)    = host_byte(cmd->result);
+		}
+
+		/* complete the request */
+		srb->cc_stat   = sts_entry->completionStatus;
+
+		/* FIXMEdg: Always put request in done_q */
+		// qla4xxx_complete_request(ha, srb);
+		add_to_done_srb_q(ha, srb);
+	}
+	else {
+		/* FIXMEdg: Don't we need to reset ISP in this case??? */
+		QL4PRINT(QLP2,
+			 printk(KERN_WARNING "scsi%d: Status Entry invalid "
+				"handle 0x%x, sp=%p. "
+				"This cmd may have already been completed.\n",
+				ha->host_no, le32_to_cpu(sts_entry->handle),
+				srb));
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: sts_entry 0x%p\n",
+				      ha->host_no, __func__, sts_entry));
+		qla4xxx_dump_bytes(QLP2, sts_entry, sizeof(*sts_entry));
+	}
+
+	LEAVE("qla4xxx_status_entry");
+}
+
+/**
+ * qla2x00_process_completed_request() - Process a Fast Post response.
+ * @ha: SCSI driver HA context
+ * @index: SRB index
+ */
+static void
+qla4xxx_process_completed_request(struct scsi_qla_host *ha, uint32_t index)
+{
+	srb_t *srb;
+
+	srb = del_from_active_array(ha, index);
+
+	if (srb) {
+		// CMD_COMPL_STATUS(sp->cmd) = 0L;
+		// CMD_SCSI_STATUS(sp->cmd) = 0L;
+
+		/* Save ISP completion status */
+		srb->cmd->result = DID_OK << 16;
+		srb->fo_retry_cnt = 0;
+		add_to_done_srb_q(ha, srb);
+	}
+	else {
+		DEBUG2(printk("scsi(%d): Invalid ISP SCSI completion handle = %d\n",
+			      ha->host_no, index));
+		QL4PRINT(QLP2, printk("scsi%d: %s: Invalid handle(srb)=%p "
+				      "handle = 0x%x\n", ha->host_no, __func__,
+				      srb, index));
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: schedule DPC to restart ha %d\n",
+				      ha->host_no, __func__, ha->instance));
+
+		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_process_response_queue
+ *	This routine handles the Response Queue Completion.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	hardware_lock locked upon entry
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully processed response queue
+ *	QLA_ERROR   - Failed to process response queue
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static uint32_t
+qla4xxx_process_response_queue(scsi_qla_host_t *ha)
+{
+	uint32_t count = 0;
+	srb_t    *srb = 0;
+	STATUS_ENTRY *sts_entry;
+
+	ENTER("qla4xxx_process_response_queue");
+	QL4PRINT(QLP12, printk("scsi%d: %s entered signature=0x%x\n",
+			       ha->host_no, __func__,
+			       ha->response_ptr->signature));
+
+	/* Process all responses from response queue */
+	while ((ha->response_in = (uint16_t)
+	    le32_to_cpu(ha->shadow_regs->rsp_q_in)) != ha->response_out) {
+		sts_entry = (STATUS_ENTRY *) ha->response_ptr;
+		QL4PRINT(QLP5,
+			 printk("scsi%d: %s: RespPtr %p, type %x\n",
+				ha->host_no, __func__,
+				ha->response_ptr,
+				sts_entry->hdr.entryType));
+		QL4PRINT(QLP5,
+			 printk("scsi%d: %s: Resp out %x, in %x, Req in\n",
+				ha->host_no, __func__,
+				ha->response_out, ha->response_in));
+
+		QL4PRINT(QLP10, printk("scsi%d: %s: sts_entry 0x%p\n",
+				       ha->host_no, __func__, sts_entry));
+		qla4xxx_dump_bytes(QLP10, sts_entry, sizeof(*sts_entry));
+
+		count++;
+
+		/* Advance pointers for next entry */
+		if (ha->response_out == (RESPONSE_QUEUE_DEPTH - 1)) {
+			ha->response_out = 0;
+			ha->response_ptr = ha->response_ring;
+		}
+		else {
+			ha->response_out++;
+			ha->response_ptr++;
+		}
+
+		/* process entry */
+		switch (sts_entry->hdr.entryType) {
+		case ET_STATUS:
+			/* Common status - Single completion posted in single
+			 * IOSB */
+			// ha->f_end = jiffies;
+
+			qla4xxx_status_entry(ha, sts_entry);
+			break;
+		case ET_PASSTHRU_STATUS:
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+			/* FIXME: DG XXX We should be using callbacks here */
+			/* if (sts_entry->hdr.systemDefined == SD_PASSTHRU_IOCB)
+				qla4xxx_iocb_pass_done(ha, (PASSTHRU_STATUS_ENTRY *) sts_entry);
+			else */
+				qla4xxx_isns_process_response(ha, (PASSTHRU_STATUS_ENTRY *) sts_entry);
+#else
+			qla4xxx_isns_process_response(ha,
+			    (PASSTHRU_STATUS_ENTRY *) sts_entry);
+#endif
+			break;
+
+/* FIXMEdg: Cut and paste from fibre code */
+		case ET_STATUS_CONTINUATION:
+			/* Just throw away the status continuation entries */
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: Status Continuation entry "
+					"- ignoring\n", ha->host_no, __func__));
+			break;
+
+		case ET_COMMAND:
+			/* ISP device queue is full. Command not accepted by
+			 * ISP.  Queue command for later */
+
+			srb = del_from_active_array(ha, le32_to_cpu(sts_entry->handle));
+			if (srb == NULL)
+				goto exit_prq_invalid_handle;
+
+			QL4PRINT(QLP2, printk("scsi%d: %s: FW device queue full, "
+					      "srb %p, put pending_srb_q\n",
+					      ha->host_no, __func__, srb));
+
+			/* Let's RETRY normally by sending it back with DID_BUS_BUSY */
+			srb->cmd->result = DID_BUS_BUSY << 16;
+			qla4xxx_complete_request(ha, srb);
+			break;
+
+		case ET_CONTINUE:
+			/* Just throw away the continuation entries */
+			QL4PRINT(QLP2, printk("scsi%d: %s: Continuation entry - "
+					      "ignoring\n",
+					      ha->host_no, __func__));
+			break;
+
+		default:
+			/* Invalid entry in response queue, reset RISC
+			 * firmware */
+			QL4PRINT(QLP2, printk("scsi%d: %s: Invalid entry %x "
+					      "in response queue \n",
+					      ha->host_no, __func__,
+					      sts_entry->hdr.entryType));
+
+			QL4PRINT(QLP10, printk("scsi%d: %s: Dumping Response Entry "
+					       "%p:%x out %x in%x\n",
+					       ha->host_no, __func__,
+					       sts_entry,
+					       le32_to_cpu(((QUEUE_ENTRY*)sts_entry)->
+							   signature),
+					       ha->response_out,
+					       ha->response_in));
+
+			qla4xxx_dump_bytes(QLP10, sts_entry,
+					   sizeof(*sts_entry));
+			goto exit_prq_error;
+		}
+	}
+
+	if (ha->response_out == ha->response_in) {
+		QL4PRINT(QLP5,
+			 printk("scsi%d: %s: Response count %x out %x "
+				"in %x, next %p:%x.  Finished!\n",
+				ha->host_no, __func__, count,
+				ha->response_out, ha->response_in,
+				ha->request_ptr,
+				ha->response_ptr->signature));
+	}
+
+	/* Done with responses, update the ISP
+	 * For QLA4010, this also clears the interrupt.
+	 */
+	WRT_REG_DWORD(&ha->reg->rsp_q_out, ha->response_out);
+	PCI_POSTING(&ha->reg->rsp_q_out);
+
+	LEAVE("qla4xxx_process_response_queue");
+	return(QLA_SUCCESS);
+
+	exit_prq_invalid_handle:
+	QL4PRINT(QLP2, printk("scsi%d: %s: Invalid handle(srb)=%p type=%x "
+			      "IOCS=%x\n", ha->host_no, __func__,
+			      srb, sts_entry->hdr.entryType,
+			      sts_entry->completionStatus));
+
+	exit_prq_error:
+	WRT_REG_DWORD(ISP_REQ_Q_OUT(ha), ha->response_out);
+	PCI_POSTING(ISP_REQ_Q_OUT(ha));
+
+	QL4PRINT(QLP2, printk("scsi%d: %s: schedule DPC to restart ha %d\n",
+			      ha->host_no, __func__, ha->instance));
+
+	set_bit(DPC_RESET_HA, &ha->dpc_flags);
+
+	LEAVE("qla4xxx_process_response_queue");
+	return(QLA_ERROR);
+}
+
+/**************************************************************************
+ * qla4xxx_isr_decode_mailbox
+ *	This routine decodes the mailbox status during the ISR.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	mailbox_status - Mailbox status.
+ *
+ * Remarks:
+ *      hardware_lock locked upon entry
+ *
+ * Returns:
+ *	None.
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+static void
+qla4xxx_isr_decode_mailbox(scsi_qla_host_t *ha, uint32_t  mbox_status)
+{
+	/* used for MBOX_ASTS_ISNS_UNSOLICITED_PDU_RECEIVED */
+	static uint32_t   mbox_sts[MBOX_REG_COUNT];
+
+	if ((mbox_status == MBOX_STS_BUSY) ||
+	    (mbox_status == MBOX_STS_INTERMEDIATE_COMPLETION) ||
+	    (mbox_status >>12 == MBOX_COMPLETION_STATUS)) {
+		ha->mbox_status[0] = mbox_status;
+
+		if (test_bit(AF_MBOX_COMMAND, &ha->flags)) {
+			/*
+			 * Copy all mailbox registers to a temporary
+			 * location and set mailbox command done flag
+			 */
+			uint8_t i;
+
+			for (i = 1; i < ha->mbox_status_count; i++) {
+				ha->mbox_status[i] =
+				    RD_REG_DWORD(&ha->reg->mailbox[i]);
+			}
+
+			QL4PRINT(QLP11,
+				 printk("scsi%d: %s: mailbox cmd done!\n",
+					ha->host_no, __func__));
+
+			ha->f_end = jiffies;
+			set_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+			wake_up(&ha->mailbox_wait_queue);
+		}
+		#if 0
+		else {
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: ERROR: Receiving mailbox "
+					"status %08X when no mailbox command "
+					"active.\n",
+					ha->host_no, mbox_status));
+
+			__dump_registers(ha);
+		}
+		#endif
+	}
+	else if (mbox_status >> 12 == MBOX_ASYNC_EVENT_STATUS) {
+		/* Immediately process the AENs that don't require much work.
+		 * Only queue the database_changed AENs */
+		switch (mbox_status) {
+		case MBOX_ASTS_SYSTEM_ERROR:
+			/* Log Mailbox registers */
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO
+					"scsi%d: aen %04x, System Error, "
+					"Dump Mailboxes\n",
+					ha->host_no, mbox_status));
+			__dump_mailbox_registers(QLP2, ha);
+			set_bit(AF_GET_CRASH_RECORD, &ha->flags);
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			break;
+
+		case MBOX_ASTS_REQUEST_TRANSFER_ERROR:
+		case MBOX_ASTS_RESPONSE_TRANSFER_ERROR:
+		case MBOX_ASTS_NVRAM_INVALID:
+		case MBOX_ASTS_IP_ADDRESS_CHANGED:
+		case MBOX_ASTS_DHCP_LEASE_EXPIRED:
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: aen %04x, "
+					"ERROR Status, Reset HA\n",
+					ha->host_no, mbox_status));
+
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			break;
+
+		case MBOX_ASTS_LINK_UP:
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: aen %04x "
+					"Adapter LINK UP\n",
+					ha->host_no, mbox_status));
+			set_bit(AF_LINK_UP, &ha->flags);
+			break;
+
+		case MBOX_ASTS_LINK_DOWN:
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: aen %04x "
+					"Adapter LINK DOWN\n",
+					ha->host_no, mbox_status));
+			clear_bit(AF_LINK_UP, &ha->flags);
+			break;
+
+		case MBOX_ASTS_HEARTBEAT:
+			QL4PRINT(QLP7,
+				 printk(KERN_INFO "scsi%d: aen %04x "
+					"HEARTBEAT\n",
+					ha->host_no, mbox_status));
+			ha->seconds_since_last_heartbeat = 0;
+			break;
+
+		case MBOX_ASTS_DHCP_LEASE_ACQUIRED:
+			QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: aen %04x DHCP LEASE ACQUIRED\n",
+					      ha->host_no, mbox_status));
+
+			/* Reset to get devices, etc. */   //FIXME: Test this!!!!
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			break;
+
+		case MBOX_ASTS_PROTOCOL_STATISTIC_ALARM:
+		case MBOX_ASTS_SCSI_COMMAND_PDU_REJECTED:	  /* Target mode only */
+		case MBOX_ASTS_UNSOLICITED_PDU_RECEIVED:	  /* connection mode only */
+		case MBOX_ASTS_IPSEC_SYSTEM_FATAL_ERROR:
+			/* No action */
+			QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: aen %04x\n",
+					      ha->host_no, mbox_status));
+			break;
+
+		case MBOX_ASTS_MAC_ADDRESS_CHANGED:
+		case MBOX_ASTS_DNS:
+			/* No action */
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: aen %04x, "
+					"mbox_sts[1]=%04x, "
+					"mbox_sts[2]=%04x\n",
+					ha->host_no, mbox_status,
+					RD_REG_DWORD(&ha->reg->mailbox[1]),
+					RD_REG_DWORD(&ha->reg->mailbox[2])));
+			break;
+
+		case MBOX_ASTS_SELF_TEST_FAILED:
+		case MBOX_ASTS_LOGIN_FAILED:
+			/* No action */
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: aen %04x, "
+					"mbox_sts[1]=%04x, "
+					"mbox_sts[2]=%04x, mbox_sts[3]=%04x\n",
+					ha->host_no, mbox_status,
+					RD_REG_DWORD(&ha->reg->mailbox[1]),
+					RD_REG_DWORD(&ha->reg->mailbox[2]),
+					RD_REG_DWORD(&ha->reg->mailbox[3])));
+			break;
+
+		case MBOX_ASTS_DATABASE_CHANGED:
+			/* Queue AEN information and process it in the DPC
+			 * routine */
+			if (ha->aen_q_count > 0) {
+				int i;
+
+				/* advance pointer */
+				if (ha->aen_in == (MAX_AEN_ENTRIES - 1))
+					ha->aen_in = 0;
+				else
+					ha->aen_in++;
+
+				/* decrement available counter */
+				ha->aen_q_count--;
+
+				for (i = 1; i < MBOX_AEN_REG_COUNT; i++) {
+					ha->aen_q[ha->aen_in].mbox_sts[i] =
+					    RD_REG_DWORD(&ha->reg->mailbox[i]);
+				}
+				ha->aen_q[ha->aen_in].mbox_sts[0] = mbox_status;
+
+				/* print debug message */
+				QL4PRINT(QLP7,
+					 printk("scsi%d: aen[%d] %04x queued!\n",
+						ha->host_no, ha->aen_in,
+						mbox_status));
+
+				/* The DPC routine will process the aen */
+				set_bit(DPC_AEN, &ha->dpc_flags);
+			}
+			else {
+				int i;
+
+				QL4PRINT(QLP2,
+					 printk("scsi%d: %s: aen %04x, queue "
+						"overflowed!  AEN LOST!!\n",
+						ha->host_no, __func__,
+						mbox_status));
+
+				QL4PRINT(QLP2,
+					 printk(KERN_WARNING "scsi%d: "
+						"DUMP AEN QUEUE\n",
+						ha->host_no));
+
+				for (i=0; i < MAX_AEN_ENTRIES; i++) {
+					QL4PRINT(QLP2,
+						 printk(KERN_WARNING "aen[%d] %04x %04x %04x %04x\n",
+							i,
+							ha->aen_q[i].mbox_sts[0],
+							ha->aen_q[i].mbox_sts[1],
+							ha->aen_q[i].mbox_sts[2],
+							ha->aen_q[i].mbox_sts[3]));
+				}
+			}
+			break;
+
+		case MBOX_ASTS_ISNS_UNSOLICITED_PDU_RECEIVED:
+			memset(&mbox_sts, 0, sizeof(mbox_sts));
+			mbox_sts[0] = mbox_status;
+			mbox_sts[1] = RD_REG_DWORD(&ha->reg->mailbox[1]);
+			mbox_sts[2] = RD_REG_DWORD(&ha->reg->mailbox[2]);
+			mbox_sts[3] = RD_REG_DWORD(&ha->reg->mailbox[3]);
+			mbox_sts[4] = RD_REG_DWORD(&ha->reg->mailbox[4]);
+			mbox_sts[5] = RD_REG_DWORD(&ha->reg->mailbox[5]);
+
+			if (mbox_sts[1] == ISNS_EVENT_DATA_RECEIVED) {
+				QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: aen %04x, mbox_sts[1]=%04x, "
+						      "mbox_sts[2]=%04x, mbox_sts[3]=%04x, mbox_sts[4]=%04x\n",
+						      ha->host_no, mbox_status, mbox_sts[1],
+						      mbox_sts[2], mbox_sts[3], mbox_sts[4]));
+
+				if (qla4xxx_isns_get_server_request(ha,
+								    mbox_sts[3],
+								    mbox_sts[2])
+				    != QLA_SUCCESS) {
+					QL4PRINT(QLP2,
+						 printk("scsi%d: %s: aen %04x, "
+							"isns_get_server_request FAILED!!\n",
+							ha->host_no, __func__, mbox_status));
+				}
+			}
+			else if (mbox_sts[1] == ISNS_EVENT_CONNECTION_OPENED) {
+				QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: aen %04x, iSNS Service "
+						      "Connection Opened!\n"
+						      "mbox_sts[2]=%08x, mbox_sts[3]=%08x, "
+						      "mbox_sts[4]=%08x, mbox_sts[5]=%08x\n",
+						      ha->host_no, mbox_status, mbox_sts[2],
+						      mbox_sts[3], mbox_sts[4], mbox_sts[5]));
+
+				qla4xxx_isns_enable_callback(ha,
+							     mbox_sts[2],
+							     mbox_sts[3],
+							     mbox_sts[4],
+							     mbox_sts[5]);
+			}
+			else if (mbox_sts[1] == ISNS_EVENT_CONNECTION_FAILED) {
+				QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: aen %04x, iSNS Service"
+						      " Connection FAILED! reason %04x\n",
+						      ha->host_no, mbox_status, mbox_sts[2]));
+			}
+			break;
+		default:
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: aen %04x UNKNOWN\n",
+					ha->host_no, mbox_status));
+		}
+	}
+	else {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "scsi%d: Unknown mailbox status %08X\n",
+				ha->host_no, mbox_status));
+
+		ha->mbox_status[0] = mbox_status;
+		__dump_registers(QLP2, ha);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_interrupt_service_routine
+ *	This routine services the interrupt
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *      hardware_lock locked upon entry
+ *
+ * Returns:
+ *      QLA_SUCCESS - success, An interrupt was found and processed
+ *	QLA_ERROR - failure, The adapter was not interrupting
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_interrupt_service_routine(scsi_qla_host_t *ha, uint32_t intr_status)
+{
+	ENTER("qla4xxx_interrupt_service_routine");
+
+	QL4PRINT(QLP11, printk("scsi%d: %s: intr_status = %X\n",
+			       ha->host_no, __func__, intr_status));
+
+	// if (intr_status == INVALID_REGISTER) {
+	// QL4PRINT(QLP2,
+	// printk("scsi%d: %s: Unrecognized intr_status %x.\n",
+	// ha->host_no, __func__, intr_status));
+	// LEAVE("qla4xxx_interrupt_service_routine");
+	// }
+
+	// ha->seconds_since_last_intr = 0;
+
+
+	/*
+	 * Process response queue interrupt.
+	 */
+	if (intr_status & CSR_SCSI_COMPLETION_INTR) {
+		qla4xxx_process_response_queue(ha);
+	}
+
+	/*
+	 * Process mailbox/asynch event  interrupt.
+	 */
+	if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
+		uint32_t mbox_status = RD_REG_DWORD(&ha->reg->mailbox[0]);
+		qla4xxx_isr_decode_mailbox(ha, mbox_status);
+
+		/* Clear Mailbox Interrupt */
+		WRT_REG_DWORD(&ha->reg->ctrl_status,
+		    SET_RMASK(CSR_SCSI_PROCESSOR_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+
+	}
+
+
+	LEAVE("qla4xxx_interrupt_service_routine");
+}
+
+/**************************************************************************
+ * qla4xxx_intr_handler
+ *	This routine handles the H/W interrupt
+ *
+ * Input:
+ *	irq - Unused
+ *	dev_id - Pointer to host adapter structure
+ *	regs - Unused
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+irqreturn_t
+qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	scsi_qla_host_t *ha;
+	uint32_t intr_status;
+	unsigned long flags = 0;
+	uint8_t reqs_count = 0;
+
+	ENTER("qla4xxx_intr_handler");
+	ha = (scsi_qla_host_t *) dev_id;
+	if (!ha) {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "qla4xxx: Interrupt with NULL host ptr\n"));
+		return IRQ_NONE;
+	}
+
+	ha->isr_count++;
+
+	/*
+	 * Check for pending interrupts
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/*
+	 * Repeatedly service interrupts up to a maximum of
+	 * MAX_REQS_SERVICED_PER_INTR
+	 */
+	while (1) {
+		/*
+		 * Read interrupt status
+		 */
+		if (le32_to_cpu(ha->shadow_regs->rsp_q_in) !=
+		    ha->response_out) {
+			intr_status = CSR_SCSI_COMPLETION_INTR;
+		}
+		else {
+			intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+		}
+
+		if ((intr_status & (CSR_SCSI_RESET_INTR|CSR_FATAL_ERROR|INTR_PENDING)) == 0) {
+			if (reqs_count == 0)
+				ha->spurious_int_count++;
+			break;
+		}
+
+		/*
+		 * Service interrupt
+		 */
+		if (intr_status & CSR_SCSI_RESET_INTR) {
+			QL4PRINT(QLP3,
+				 printk(KERN_INFO "scsi%d: Soft Reset requested by "
+					"Network function or RISC\n", ha->host_no));
+
+			clear_bit(AF_ONLINE, &ha->flags);
+			__qla4xxx_disable_intrs(ha);
+
+			QL4PRINT(QLP3,
+				 printk(KERN_INFO "scsi%d: Clear SCSI Reset Interrupt\n",
+					ha->host_no));
+			WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_RESET_INTR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+
+			set_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);
+
+			break;
+		}
+		else if (intr_status & CSR_FATAL_ERROR) {
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: Fatal Error, "
+					"Status 0x%04x\n", ha->host_no,
+					RD_REG_DWORD(ISP_PORT_ERROR_STATUS(ha))));
+
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: Dump Registers:\n", ha->host_no));
+			__dump_registers(QLP2, ha);
+
+			/* Issue Soft Reset to clear this error condition.
+			 * This will prevent the RISC from repeatedly
+			 * interrupting the driver; thus, allowing the DPC to
+			 * get scheduled to continue error recovery.
+			 * NOTE: Disabling RISC interrupts does not work in
+			 * this case, as CSR_FATAL_ERROR overrides
+			 * CSR_SCSI_INTR_ENABLE */
+			if ((RD_REG_DWORD(&ha->reg->ctrl_status) & CSR_SCSI_RESET_INTR) == 0) {
+				QL4PRINT(QLP2,
+					 printk(KERN_INFO "scsi%d: Issue soft reset\n",
+						ha->host_no));
+				WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SOFT_RESET));
+				PCI_POSTING(&ha->reg->ctrl_status);
+			}
+
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: Acknowledge fatal error\n",
+					ha->host_no));
+			WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_FATAL_ERROR));
+			PCI_POSTING(&ha->reg->ctrl_status);
+
+			__qla4xxx_disable_intrs(ha);
+
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+
+			break;
+		}
+		else if (intr_status & INTR_PENDING) {
+			qla4xxx_interrupt_service_routine(ha, intr_status);
+			ha->total_io_count++;
+			if (++reqs_count == MAX_REQS_SERVICED_PER_INTR) {
+				QL4PRINT(QLP11,
+					 printk("scsi%d: %s: exiting, %d "
+						"requests serviced\n",
+						ha->host_no, __func__,
+						reqs_count));
+				break;
+			}
+			intr_status = 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	qla4xxx_start_io(ha);
+
+// DG XXX
+	if (!list_empty(&ha->done_srb_q))
+		qla4xxx_done(ha);
+
+	LEAVE("qla4xxx_intr_handler");
+
+	return IRQ_HANDLED;
+}
+
+/**************************************************************************
+ * qla4xxx_process_aen
+ *	This routine processes Asynchronous Events received from the firmware.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	flush_ddb_chg_aens - 1 = Ignore ddb changed aens
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_process_aen(scsi_qla_host_t *ha, uint8_t flush_ddb_chg_aens)
+{
+	uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
+	aen_t   *aen;
+	int     i;
+	unsigned long flags;
+
+	ENTER("qla4xxx_process_aen");
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	while (ha->aen_out != ha->aen_in) {
+
+		/* Advance pointers for next entry */
+		if (ha->aen_out == (MAX_AEN_ENTRIES - 1))
+			ha->aen_out = 0;
+		else
+			ha->aen_out++;
+
+		ha->aen_q_count++;
+		aen = &ha->aen_q[ha->aen_out];
+
+		/* copy aen information to local structure */
+		for (i=0; i < MBOX_AEN_REG_COUNT; i++)
+			mbox_sts[i] = aen->mbox_sts[i];
+
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		DEBUG2(printk("scsi%d: %s aen[%d] mb0(evt)=%04x mb1(mod)=%04x "
+		    "mb2(idx)=%d mb3(state)=%04x mb4(cerror)=%04x\n",
+		    ha->host_no, __func__, ha->aen_out, mbox_sts[0],
+		    mbox_sts[1], mbox_sts[2], mbox_sts[3], mbox_sts[4]);)
+		switch (mbox_sts[0]) {
+		case MBOX_ASTS_DATABASE_CHANGED:
+			if (flush_ddb_chg_aens) {
+				QL4PRINT(QLP2, printk(KERN_INFO
+				    "scsi%d: aen[%d] %04x, index [%d] "
+				    "state=%04x IGNORED!\n", ha->host_no,
+				    ha->aen_out, mbox_sts[0], mbox_sts[2],
+				    mbox_sts[3]));
+				break;
+			}
+
+			QL4PRINT(QLP2|QLP7, printk(KERN_INFO
+			    "scsi%d: aen[%d] %04x, index [%d] state=%04x\n",
+			    ha->host_no, ha->aen_out, mbox_sts[0], mbox_sts[2],
+			    mbox_sts[3]));
+
+			if (mbox_sts[1] == 0) {		/* Global DB change. */
+				QL4PRINT(QLP2|QLP7, printk("scsi%d: %s: "
+				    "global database changed aen\n",
+				    ha->host_no, __func__));
+				qla4xxx_reinitialize_ddb_list(ha);
+			} else if (mbox_sts[1] == 1) {	/* Specific device. */
+				qla4xxx_process_ddb_changed(ha, mbox_sts[2],
+				    mbox_sts[3]);
+			} else {
+				QL4PRINT(QLP2|QLP7, printk("scsi%d: %s: "
+				    "invalid database changed aen modifier, "
+				    "mbox_sts[1]=%04x\n", ha->host_no,
+				    __func__, mbox_sts[1]));
+			}
+			break;
+		}
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_process_aen");
+}
+
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_listops.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_listops.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_listops.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_listops.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,372 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.4.x
+ * Copyright (C) 2004 Qlogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/* Management functions for various lists */
+
+/*************************************/
+
+static inline void
+__add_to_pending_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_add_tail(&srb->list_entry, &ha->pending_srb_q);
+	srb->state = SRB_PENDING_STATE;
+	ha->pending_srb_q_count++;
+}
+
+static inline void
+__add_to_pending_srb_q_head(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_add(&srb->list_entry, &ha->pending_srb_q);
+	srb->state = SRB_PENDING_STATE;
+	ha->pending_srb_q_count++;
+}
+
+static inline void
+__del_from_pending_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_del_init(&srb->list_entry);
+	srb->state = SRB_NO_QUEUE_STATE;
+	ha->pending_srb_q_count--;
+}
+
+/*************************************/
+
+static inline void
+__add_to_retry_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_add_tail(&srb->list_entry, &ha->retry_srb_q);
+	srb->state = SRB_RETRY_STATE;
+	ha->retry_srb_q_count++;
+	srb->ha = ha;
+}
+
+static inline void
+__del_from_retry_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_del_init(&srb->list_entry);
+	srb->state = SRB_NO_QUEUE_STATE;
+	ha->retry_srb_q_count--;
+}
+
+/*************************************/
+
+static inline void
+__add_to_done_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_add_tail(&srb->list_entry, &ha->done_srb_q);
+	srb->state = SRB_DONE_STATE;
+	ha->done_srb_q_count++;
+	srb->ha = ha;
+}
+
+static inline void
+__del_from_done_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_del_init(&srb->list_entry);
+	srb->state = SRB_NO_QUEUE_STATE;
+	ha->done_srb_q_count--;
+}
+
+static inline srb_t *__del_from_done_srb_q_head(scsi_qla_host_t *ha)
+{
+	struct list_head *ptr;
+	srb_t *srb = NULL;
+
+	if (!list_empty(&ha->done_srb_q)) {
+		/* Remove list entry from head of queue */
+		ptr = ha->done_srb_q.next;
+		list_del_init(ptr);
+
+		/* Return pointer to srb structure */
+		srb = list_entry(ptr, srb_t, list_entry);
+		srb->state = SRB_NO_QUEUE_STATE;
+		ha->done_srb_q_count--;
+	}
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+
+	return(srb);
+}
+
+/*************************************/
+
+static inline void
+__add_to_free_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+
+	//memset(srb, 0, sizeof(srb_t));
+	list_add_tail(&srb->list_entry, &ha->free_srb_q);
+	ha->free_srb_q_count++;
+	srb->state = SRB_FREE_STATE;
+}
+
+static inline void __del_from_free_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+	list_del_init(&srb->list_entry);
+	srb->state = SRB_NO_QUEUE_STATE;
+	ha->free_srb_q_count--;
+}
+
+static inline srb_t *__del_from_free_srb_q_head(scsi_qla_host_t *ha)
+{
+	struct list_head *ptr;
+	srb_t *srb = NULL;
+
+	if (!list_empty(&ha->free_srb_q)) {
+		/* Remove list entry from head of queue */
+		ptr = ha->free_srb_q.next;
+		list_del_init(ptr);
+
+		/* Return pointer to srb structure */
+		srb = list_entry(ptr, srb_t, list_entry);
+		memset(srb, 0, sizeof(*srb));
+		srb->state = SRB_NO_QUEUE_STATE;
+		ha->free_srb_q_count--;
+	}
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, srb = %p\n",
+			      ha->host_no, __func__, ha->instance, srb));
+
+	return(srb);
+}
+
+/*************************************/
+
+static inline void
+__add_to_suspended_lun_q(scsi_qla_host_t *ha, os_lun_t *lun)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, lun = %d\n",
+			      ha->host_no, __func__, ha->instance, lun->lun));
+	list_add_tail(&lun->list_entry, &ha->suspended_lun_q);
+	ha->suspended_lun_q_count++;
+}
+
+static inline void
+__del_from_suspended_lun_q(scsi_qla_host_t *ha, os_lun_t *lun)
+{
+	QL4PRINT(QLP8, printk("scsi%d: %s: ha %d, lun = %d\n",
+			      ha->host_no, __func__, ha->instance, lun->lun));
+	list_del_init(&lun->list_entry);
+	ha->suspended_lun_q_count--;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+static inline void
+add_to_pending_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__add_to_pending_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void
+add_to_pending_srb_q_head(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__add_to_pending_srb_q_head(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void
+del_from_pending_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__del_from_pending_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+/*************************************/
+
+static inline void
+add_to_retry_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__add_to_retry_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void
+del_from_retry_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__del_from_retry_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+/*************************************/
+
+static inline void
+add_to_done_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	// spin_lock_irqsave(&ha->adapter_lock, flags);
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__add_to_done_srb_q(ha ,srb);
+	// spin_unlock_irqrestore(&ha->adapter_lock, flags);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void
+del_from_done_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	// spin_lock_irqsave(&ha->adapter_lock, flags);
+	__del_from_done_srb_q(ha ,srb);
+	// spin_unlock_irqrestore(&ha->adapter_lock, flags);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline srb_t *
+del_from_done_srb_q_head(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+	srb_t *srb;
+
+	// spin_lock_irqsave(&ha->adapter_lock, flags);
+	spin_lock_irqsave(&ha->list_lock, flags);
+	srb = __del_from_done_srb_q_head(ha);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+	// spin_unlock_irqrestore(&ha->adapter_lock, flags);
+	return(srb);
+}
+
+/*************************************/
+
+static inline void
+add_to_free_srb_q(scsi_qla_host_t *ha, srb_t *srb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	memset(srb, 0, sizeof(*srb));
+	__add_to_free_srb_q(ha ,srb);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline srb_t *
+del_from_free_srb_q_head(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+	srb_t *srb;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	srb = __del_from_free_srb_q_head(ha);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	if (srb) {
+		#ifdef DEBUG
+		if (atomic_read(&srb->ref_count) != 0) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: WARNING: "
+					      "ref_count not zero.\n",
+					      ha->host_no, __func__));
+		}
+		#endif
+
+		atomic_set(&srb->ref_count, 1);
+	}
+	return(srb);
+}
+
+/*************************************/
+
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+/*
+ * Failover Stuff.
+ */
+static inline void
+__add_to_failover_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+	/*
+	if( sp->state != SRB_NO_QUEUE_STATE &&
+		sp->state != SRB_ACTIVE_STATE)
+		BUG();
+	*/
+
+	list_add_tail(&sp->list_entry,&ha->failover_queue);
+	ha->failover_cnt++;
+	sp->state = SRB_FAILOVER_STATE;
+	sp->ha = ha;
+}
+
+static inline void add_to_failover_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+
+	__add_to_failover_queue(ha,sp);
+
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+static inline void __del_from_failover_queue(struct scsi_qla_host * ha, srb_t *
+					     sp)
+{
+	ha->failover_cnt--;
+	list_del_init(&sp->list_entry);
+	sp->state = SRB_NO_QUEUE_STATE;
+}
+
+static inline void del_from_failover_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+
+	__del_from_failover_queue(ha,sp);
+
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+#endif
+
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_mbx.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_mbx.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_mbx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_mbx.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,1328 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	qla4xxx_mailbox_command
+ *	qla4xxx_mbx_test
+ *	qla4xxx_send_noop
+ *	qla4xxx_conn_close_sess_logout
+ *	qla4xxx_clear_database_entry
+ *	qla4xxx_initialize_fw_cb
+ *	qla4xxx_get_fw_version
+ *	qla4xxx_get_firmware_state
+ *	qla4xxx_get_fwddb_entry
+ *	qla4xxx_set_ddb_entry
+ *	qla4xxx_get_crash_record
+ *	qla4xxx_reset_lun
+ *	qla4xxx_isns_enable
+ *	qla4xxx_isns_disable
+ *	qla4xxx_isns_status
+ *	qla4xxx_get_flash
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+#include <linux/delay.h>
+
+extern int ql4xportdownretrycount;  //FIXME: Find some way to Remove
+extern int ql4xdiscoverywait;
+extern void qla4xxx_isns_build_entity_id(scsi_qla_host_t *ha);
+extern int qla4xxx_eh_wait_for_active_target_commands(scsi_qla_host_t *ha, int target, int lun);
+
+/**************************************************************************
+ * qla4xxx_mailbox_command
+ *	This routine sssue mailbox commands and waits for completion.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	inCount	 - number of mailbox registers to load.
+ *      outCount - number of mailbox registers to return.
+ *      mbx_cmd  - data pointer for mailbox in registers.
+ *      mbx_sts  - data pointer for mailbox out registers.
+ *
+ * Output:
+ *      mbx_sts - returned mailbox out data.
+ *
+ * Remarks:
+ *	If outCount is 0, this routine completes successfully WITHOUT waiting
+ *	for the mailbox command to complete.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Mailbox command completed successfully
+ *	QLA_ERROR   - Mailbox command competed in error.
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_mailbox_command(scsi_qla_host_t *ha,
+			uint8_t inCount,
+			uint8_t outCount,
+			uint32_t *mbx_cmd,
+			uint32_t *mbx_sts)
+{
+	uint8_t      status = QLA_ERROR;
+	uint8_t      i;
+	u_long     wait_count;
+	uint32_t     intr_status;
+	unsigned long flags = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+
+	ENTER("qla4xxx_mailbox_command");
+
+	down(&ha->mbox_sem);
+
+
+	set_bit(AF_MBOX_COMMAND, &ha->flags);
+
+
+	/* Make sure that pointers are valid */
+	if (!mbx_cmd || !mbx_sts) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Invalid mbx_cmd or mbx_sts pointer\n",
+				ha->host_no, __func__));
+
+		goto mbox_exit;
+	}
+
+	/* To prevent overwriting mailbox registers for a command that has
+	 * not yet been serviced, check to see if a previously issued
+	 * mailbox command is interrupting.
+	 * -----------------------------------------------------------------
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Trying to execute a mailbox request, "
+				"while another one is interrupting\n"
+				"Service existing interrupt first\n",
+				ha->host_no, __func__));
+
+		/* Service existing interrupt */
+		qla4xxx_interrupt_service_routine(ha, intr_status);
+	}
+
+
+	/* Send the mailbox command to the firmware
+	 * ----------------------------------------
+	 */
+	ha->f_start = jiffies;
+	ha->mbox_status_count = outCount;
+	for (i=0; i < outCount; i++) {
+		ha->mbox_status[i] = 0;
+	}
+
+	for (i=0; i<inCount; i++) {
+		QL4PRINT(QLP11, printk("scsi%d: %s: Mailbox In[%d]  0x%08X\n",
+				       ha->host_no, __func__, i, mbx_cmd[i]));
+	}
+
+	/* Load all mailbox registers, except mailbox 0.*/
+	for (i = 1; i < inCount; i++) {
+		WRT_REG_DWORD(&ha->reg->mailbox[i], mbx_cmd[i]);
+	}
+
+	/* Write Mailbox 0 to alert the firmware that the mailbox registers
+	 * contain a command to be processed.  NOTE: We could be interrupted
+	 * here if system interrupts are enabled */
+	WRT_REG_DWORD(&ha->reg->mailbox[0], mbx_cmd[0]);
+	PCI_POSTING(&ha->reg->mailbox[0]);
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_INTR_RISC));
+	PCI_POSTING(&ha->reg->ctrl_status);
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(&ha->mailbox_wait_queue,&wait);
+
+	/*
+	 * If we don't want status, don't wait for the mailbox command to
+	 * complete.  For example, MBOX_CMD_RESET_FW doesn't return status,
+	 * you must poll the inbound Interrupt Mask for completion.
+	 */
+	if (outCount == 0) {
+		status = QLA_SUCCESS;
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&ha->mailbox_wait_queue,&wait);
+		ha->f_end = jiffies;
+		goto mbox_exit;
+	}
+
+	/*
+	 * Wait for command to complete
+	 * -----------------------------
+	 */
+	wait_count = jiffies + MBOX_TOV * HZ;
+
+	while (test_bit(AF_MBOX_COMMAND_DONE, &ha->flags) == 0) {
+		if (wait_count <= jiffies)
+			break;
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+
+		intr_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+
+		QL4PRINT(QLP11, printk("scsi%d: %s: INTR_STATUS = 0x%X\n",
+				       ha->host_no, __func__, intr_status));
+
+		if (intr_status & INTR_PENDING) {
+			/*
+			 * Service the interrupt.
+			 * The ISR will save the mailbox status registers
+			 * to a temporary storage location in the adapter
+			 * structure.
+			 */
+			ha->mbox_status_count = outCount;
+			qla4xxx_interrupt_service_routine(ha, intr_status);
+			// DG XXX
+			if (!list_empty(&ha->done_srb_q))
+				qla4xxx_done(ha);
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		/*
+		 * Delay for 10 microseconds
+		 * NOTE: Interrupt_handler may be called here,
+		 *       if interrupts are enabled
+		 */
+		udelay(10);
+	} /* wait loop */
+
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&ha->mailbox_wait_queue,&wait);
+
+	/*
+	 * Check for mailbox timeout
+	 */
+	if (!test_bit(AF_MBOX_COMMAND_DONE, &ha->flags)) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: Mailbox Cmd 0x%08X timed out ...,"
+				" Scheduling Adapter Reset\n",
+				ha->host_no, mbx_cmd[0]));
+
+		ha->mailbox_timeout_count++;
+		mbx_sts[0] = (-1);
+
+		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		goto mbox_exit;
+	}
+
+	QL4PRINT(QLP11,
+		 printk("scsi%d: %s: mailbox cmd done!\n",
+			ha->host_no, __func__));
+
+	/*
+	 * Copy the mailbox out registers to the caller's mailbox in/out
+	 * structure.
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (i=0; i < outCount; i++) {
+		mbx_sts[i] = ha->mbox_status[i];
+		QL4PRINT(QLP11,
+			 printk("scsi%d: %s: Mailbox Status[%d]  0x%08X\n",
+				ha->host_no, __func__, i, mbx_sts[i]));
+	}
+
+	/*
+	 * Set return status and error flags (if applicable)
+	 */
+	switch (ha->mbox_status[0]) {
+	
+	case MBOX_STS_COMMAND_COMPLETE:
+		status = QLA_SUCCESS;
+		break;
+
+	case MBOX_STS_INTERMEDIATE_COMPLETION:
+		status = QLA_SUCCESS;
+		QL4PRINT(QLP5,
+			 printk("scsi%d: %s: Cmd = %08X, Intermediate completion\n",
+				ha->host_no, __func__, mbx_cmd[0]));
+		break;
+
+	case MBOX_STS_BUSY:
+		QL4PRINT(QLP2, printk("scsi%d: %s: Cmd = %08X, ISP BUSY\n",
+				      ha->host_no, __func__, mbx_cmd[0]));
+
+		ha->mailbox_timeout_count++;
+		break;
+
+	case MBOX_STS_INVALID_COMMAND:
+	case MBOX_STS_HOST_INTERFACE_ERROR:
+	case MBOX_STS_TEST_FAILED:
+	case MBOX_STS_COMMAND_ERROR:
+	case MBOX_STS_COMMAND_PARAMETER_ERROR:
+	default:
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: **** FAILED, cmd = %08X, "
+				"sts = %08X ****\n",
+				ha->host_no, __func__, mbx_cmd[0], mbx_sts[0]));
+
+
+		__dump_registers(QLP2, ha);
+		break;
+	} /* switch mbox status */
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	mbox_exit:
+	clear_bit(AF_MBOX_COMMAND, &ha->flags);
+	clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+	LEAVE("qla4xxx_mailbox_command");
+	up(&ha->mbox_sem);
+
+	return(status);
+}
+
+
+#if 0
+uint8_t qla4xxx_send_noop(scsi_qla_host_t *ha)
+{
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_NOP;
+
+	if (qla4xxx_mailbox_command(ha, 1, 1, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: NOP failed\n", ha->host_no));
+		return(QLA_ERROR);
+	}
+	else {
+		QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: NOP succeded\n", ha->host_no));
+		return(QLA_SUCCESS);
+	}
+}
+
+uint8_t qla4xxx_mbx_test(scsi_qla_host_t *ha)
+{
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+	int i;
+	uint8_t status;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_REGISTER_TEST;
+	mbox_cmd[1] = 0x11111111;
+	mbox_cmd[2] = 0x22222222;
+	mbox_cmd[3] = 0x33333333;
+	mbox_cmd[4] = 0x44444444;
+	mbox_cmd[5] = 0x55555555;
+	mbox_cmd[6] = 0x66666666;
+	mbox_cmd[7] = 0x77777777;
+
+	if (qla4xxx_mailbox_command(ha, 8, 8, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: REGISTER_TEST failed, mbox_sts = 0x%x\n",
+				      ha->host_no, mbox_sts[0]));
+		return(QLA_ERROR);
+	}
+
+	if (mbox_sts[1] != 0x11111111 ||
+	    mbox_sts[2] != 0x22222222 ||
+	    mbox_sts[3] != 0x33333333 ||
+	    mbox_sts[4] != 0x44444444 ||
+	    mbox_sts[5] != 0x55555555 ||
+	    mbox_sts[6] != 0x66666666 ||
+	    mbox_sts[7] != 0x77777777) {
+		QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: REGISTER_TEST failed\n", ha->host_no));
+		status = QLA_ERROR;
+
+	}
+	else {
+		QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: REGISTER_TEST succeded\n", ha->host_no));
+		status = QLA_SUCCESS;
+	}
+
+	for (i = 0; i < 8; i++) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: MBX%d = 0x%x\n",
+				      ha->host_no, __func__, i, mbox_cmd[i]));
+	}
+	return(status);
+}
+#endif
+
+/*
+ * qla4xxx_issue_iocb
+ *	Issue IOCB using mailbox command
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	buffer = buffer pointer.
+ *	phys_addr = physical address of buffer.
+ *	size = size of buffer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+uint8_t
+qla4xxx_issue_iocb(scsi_qla_host_t *ha, void*  buffer,
+		   dma_addr_t phys_addr, size_t size)
+{
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+	uint8_t	   status;
+
+	ENTER("qla4xxx_issue_iocb: started");
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_EXECUTE_IOCB_A64;
+	mbox_cmd[1] = 0;
+	mbox_cmd[2] = LSDW(phys_addr);
+	mbox_cmd[3] = MSDW(phys_addr);
+	status = qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]);
+
+	if (status != QLA_SUCCESS) {
+		/*EMPTY*/
+		QL4PRINT(QLP2, printk("qla4xxx_issue_iocb(%d): failed statis 0x%x",
+		    ha->host_no, status));
+	} else {
+		/*EMPTY*/
+		LEAVE("qla4xxx_issue_iocb: exiting normally");
+	}
+
+	return status;
+}
+
+uint8_t
+qla4xxx_conn_close_sess_logout(scsi_qla_host_t *ha, uint16_t fw_ddb_index,
+			       uint16_t connection_id, uint16_t option)
+{
+	uint32_t    mbox_cmd[MBOX_REG_COUNT];
+	uint32_t    mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;
+	mbox_cmd[1] = fw_ddb_index;
+	mbox_cmd[2] = connection_id;
+	mbox_cmd[3] = LOGOUT_OPTION_RELOGIN;
+
+	if (qla4xxx_mailbox_command(ha, 4, 2, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_CONN_CLOSE_SESS_LOGOUT "
+				"option %04x failed sts %04X %04X",
+				ha->host_no, __func__, option,
+				mbox_sts[0], mbox_sts[1]));
+
+		if (mbox_sts[0] == 0x4005) {
+			QL4PRINT(QLP2, printk(", reason %04X\n", mbox_sts[1]));
+		}
+		else {
+			QL4PRINT(QLP2, printk("\n"));
+		}
+	}
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_clear_database_entry(scsi_qla_host_t *ha, uint16_t fw_ddb_index)
+{
+	uint32_t    mbox_cmd[MBOX_REG_COUNT];
+	uint32_t    mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CLEAR_DATABASE_ENTRY;
+	mbox_cmd[1] = fw_ddb_index;
+
+	if (qla4xxx_mailbox_command(ha, 2, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_CLEAR_DATABASE_ENTRY "
+				"failed sts %04X index [%d], state %04x\n",
+				ha->host_no, __func__, mbox_sts[0], fw_ddb_index, mbox_sts[4]));
+		return(QLA_ERROR);
+	}
+
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_initialize_fw_cb
+ *	This routine initializes the firmware control block for the
+ *	specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully initialized firmware ctrl block
+ *	QLA_ERROR   - Failed to initialize firmware ctrl block
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_initialize_fw_cb(scsi_qla_host_t *ha)
+{
+	INIT_FW_CTRL_BLK  *init_fw_cb;
+	dma_addr_t	  init_fw_cb_dma;
+	uint32_t   mbox_cmd[MBOX_REG_COUNT];
+	uint32_t   mbox_sts[MBOX_REG_COUNT];
+	uint8_t    status = QLA_ERROR;
+
+	ENTER("qla4xxx_initialize_fw_cb");
+
+	init_fw_cb = pci_alloc_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK),
+	  &init_fw_cb_dma);
+	if (init_fw_cb == NULL) {
+		printk("scsi%d: %s: Unable to alloc init_cb\n", ha->host_no,
+		    __func__);
+		return 10;
+	}
+	memset(init_fw_cb, 0, sizeof(INIT_FW_CTRL_BLK));
+
+	/*
+	 * Get Initialize Firmware Control Block
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(init_fw_cb_dma);
+	mbox_cmd[3] = MSDW(init_fw_cb_dma);
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: Failed to get init_fw_ctrl_blk\n",
+				ha->host_no, __func__));
+		LEAVE("qla4xxx_initialize_fw_cb");
+		pci_free_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK),
+		    init_fw_cb, init_fw_cb_dma);
+		return (status);
+	}
+
+	QL4PRINT(QLP10, printk("scsi%d: Init Fw Ctrl Blk\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP10, init_fw_cb, sizeof(INIT_FW_CTRL_BLK));
+
+	/*
+	 * Initialize request and response queues
+	 */
+	qla4xxx_init_rings(ha);
+
+	/*
+	 * Fill in the request and response queue information
+	 */
+	init_fw_cb->ReqQConsumerIndex = cpu_to_le16(ha->request_out);
+	init_fw_cb->ComplQProducerIndex = cpu_to_le16(ha->response_in);
+	init_fw_cb->ReqQLen = __constant_cpu_to_le16(REQUEST_QUEUE_DEPTH);
+	init_fw_cb->ComplQLen = __constant_cpu_to_le16(RESPONSE_QUEUE_DEPTH);
+	init_fw_cb->ReqQAddrLo = cpu_to_le32(LSDW(ha->request_dma));
+	init_fw_cb->ReqQAddrHi = cpu_to_le32(MSDW(ha->request_dma));
+	init_fw_cb->ComplQAddrLo = cpu_to_le32(LSDW(ha->response_dma));
+	init_fw_cb->ComplQAddrHi = cpu_to_le32(MSDW(ha->response_dma));
+	init_fw_cb->ShadowRegBufAddrLo = cpu_to_le32(LSDW(ha->shadow_regs_dma));
+	init_fw_cb->ShadowRegBufAddrHi = cpu_to_le32(MSDW(ha->shadow_regs_dma));
+
+	/*
+	 * Set up required options
+	 */
+	init_fw_cb->FwOptions |=
+	    __constant_cpu_to_le16(FWOPT_SESSION_MODE | FWOPT_INITIATOR_MODE);
+	init_fw_cb->FwOptions &= __constant_cpu_to_le16(~FWOPT_TARGET_MODE);
+
+	/*
+	 * Save some info in adapter structure
+	 */
+	ha->firmware_options = le16_to_cpu(init_fw_cb->FwOptions);
+	ha->tcp_options = le16_to_cpu(init_fw_cb->TCPOptions);
+	ha->heartbeat_interval = init_fw_cb->HeartbeatInterval;
+	ha->isns_server_port_number =
+	    le16_to_cpu(init_fw_cb->iSNSServerPortNumber);
+
+	memcpy(ha->ip_address, init_fw_cb->IPAddr,
+	    MIN(sizeof(ha->ip_address), sizeof(init_fw_cb->IPAddr)));
+	memcpy(ha->isns_ip_address, init_fw_cb->iSNSIPAddr,
+	    MIN(sizeof(ha->isns_ip_address), sizeof(init_fw_cb->iSNSIPAddr)));
+	memcpy(ha->name_string, init_fw_cb->iSCSINameString,
+	    MIN(sizeof(ha->name_string), sizeof(init_fw_cb->iSCSINameString)));
+	memcpy(ha->alias, init_fw_cb->Alias,
+	    MIN(sizeof(ha->alias), sizeof(init_fw_cb->Alias)));
+
+	/* Save Command Line Paramater info */
+	ha->port_down_retry_count = ql4xportdownretrycount;
+	ha->discovery_wait = ql4xdiscoverywait;
+
+	/* High-water mark of IOCBs */
+	ha->iocb_hiwat = MAX_SRBS-2;
+
+	/*
+	 * Send Initialize Firmware Control Block
+	 */
+	QL4PRINT(QLP7, printk("scsi%d: %s: init_fw cmd sent\n", ha->host_no,
+	    __func__));
+
+	mbox_cmd[0] = MBOX_CMD_INITIALIZE_FIRMWARE;
+	mbox_cmd[1] = 0;
+	mbox_cmd[2] = LSDW(init_fw_cb_dma);
+	mbox_cmd[3] = MSDW(init_fw_cb_dma);
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0])
+	    == QLA_SUCCESS) {
+		QL4PRINT(QLP7, printk("scsi%d: Init Fw Ctrl Blk\n",
+		    ha->host_no));
+		qla4xxx_dump_bytes(QLP7, init_fw_cb, sizeof(INIT_FW_CTRL_BLK));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "IP Address            %d.%d.%d.%d\n", ha->host_no,
+		    __func__, ha->ip_address[0], ha->ip_address[1],
+		    ha->ip_address[2], ha->ip_address[3]));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Subnet Mask           %d.%d.%d.%d\n", ha->host_no,
+		    __func__, init_fw_cb->SubnetMask[0],
+		    init_fw_cb->SubnetMask[1], init_fw_cb->SubnetMask[2],
+		    init_fw_cb->SubnetMask[3]));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Default Gateway       %d.%d.%d.%d\n", ha->host_no,
+		    __func__, init_fw_cb->GatewayIPAddr[0],
+		    init_fw_cb->GatewayIPAddr[1], init_fw_cb->GatewayIPAddr[2],
+		    init_fw_cb->GatewayIPAddr[3]));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Auto-Negotiate        %s\n", ha->host_no, __func__,
+		    ((le16_to_cpu(init_fw_cb->AddFwOptions) & 0x10) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "SLP Use DA Enable     %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_SLP_USE_DA_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "SLP UA Enable         %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_SLP_UA_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "DHCP Enable           %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_DHCP_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "DNS via DHCP Enable   %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_GET_DNS_VIA_DHCP_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "SLP via DHCP Enable   %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_GET_SLP_VIA_DHCP_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Auto Discovery Enable %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_AUTO_DISCOVERY_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7|QLP20, printk("scsi%d: %s: "
+		    "iSNS Enable           %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_ISNS_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		QL4PRINT(QLP7|QLP20, printk("scsi%d: %s: "
+		    "Learn iSNS IP Addr Enable %s\n", ha->host_no, __func__,
+		    ((ha->tcp_options & TOPT_LEARN_ISNS_IP_ADDR_ENABLE) != 0)
+		    ? "ON" : "OFF"));
+		if (ha->tcp_options & TOPT_ISNS_ENABLE) {
+			set_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags);
+
+			QL4PRINT(QLP7|QLP20, printk("scsi%d: %s: "
+			    "iSNS IP Address           %d.%d.%d.%d\n",
+			    ha->host_no, __func__, ha->isns_ip_address[0],
+			    ha->isns_ip_address[1], ha->isns_ip_address[2],
+			    ha->isns_ip_address[3]));
+			QL4PRINT(QLP7|QLP20, printk("scsi%d: %s: "
+			    "iSNS Server Port Number   %d\n", ha->host_no,
+			    __func__, ha->isns_server_port_number));
+		}
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: "
+		    "Heartbeat Enable      %s\n", ha->host_no, __func__,
+		    ((ha->firmware_options & FWOPT_HEARTBEAT_ENABLE) != 0) ?
+		    "ON" : "OFF"));
+		if (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE)
+			QL4PRINT(QLP7, printk("scsi%d: %s: "
+			    "Heartbeat Interval    %d\n", ha->host_no, __func__,
+			    ha->heartbeat_interval));
+
+		status = QLA_SUCCESS;
+	} else {
+		QL4PRINT(QLP2, printk("scsi%d: %s: "
+		    "MBOX_CMD_INITIALIZE_FIRMWARE failed w/ status %04X\n",
+		    ha->host_no, __func__, mbox_sts[0]));
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(INIT_FW_CTRL_BLK), init_fw_cb,
+	    init_fw_cb_dma);
+
+	LEAVE("qla4xxx_initialize_fw_cb");
+
+	return status;
+}
+
+/**************************************************************************
+ * qla4xxx_get_firmware_state
+ *	This routine retrieves the firmware state for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved firmware state
+ *	QLA_ERROR   - Failed to retrieve firmware state
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_firmware_state(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	ENTER("qla4xxx_get_firmware_state");
+
+	/* Get firmware version */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_FW_STATE;
+	if (qla4xxx_mailbox_command(ha, 1, 4, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_GET_FW_STATE failed w/ "
+				"status %04X\n",
+				ha->host_no, __func__, mbox_sts[0]));
+		return(QLA_ERROR);
+	}
+
+	ha->firmware_state = mbox_sts[1];
+	ha->board_id       = mbox_sts[2];
+	ha->addl_fw_state  = mbox_sts[3];
+	LEAVE("qla4xxx_get_firmware_state");
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_get_fwddb_entry
+ *	This routine retrieves the firmware's device database entry.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      fw_ddb_entry - Pointer to firmware's device database entry structure
+ *      num_valid_ddb_entries - Pointer to number of valid ddb entries
+ *      next_ddb_index - Pointer to next valid device database index
+ *      fw_ddb_device_state - Pointer to device state
+ *
+ * Output:
+ *      fw_ddb_entry - Fills in structure if pointer is supplied
+ *      num_valid_ddb_entries - Fills in if pointer is supplied
+ *      next_ddb_index - Fills in if pointer is supplied
+ *      fw_ddb_device_state - Fills in if pointer is supplied
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved ddb info from firmware
+ *	QLA_ERROR   - Failed to retrieve ddb info from firmware
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_fwddb_entry(scsi_qla_host_t *ha,
+		      uint16_t        fw_ddb_index,
+		      DEV_DB_ENTRY    *fw_ddb_entry,
+		      dma_addr_t      fw_ddb_entry_dma,
+		      uint32_t        *num_valid_ddb_entries,
+		      uint32_t        *next_ddb_index,
+		      uint32_t        *fw_ddb_device_state,
+		      uint32_t        *time2wait,
+		      uint16_t        *tcp_source_port_num,
+		      uint16_t        *connection_id)
+{
+	uint8_t         status = QLA_ERROR;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	ENTER("qla4xxx_fwget_ddb_entry");
+
+	/* Make sure the device index is valid */
+	if (fw_ddb_index >= MAX_DDB_ENTRIES) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: index [%d] out of range.\n",
+				ha->host_no, __func__, fw_ddb_index));
+		goto exit_get_fwddb;
+	}
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t) fw_ddb_index;
+	mbox_cmd[2] = LSDW(fw_ddb_entry_dma);
+	mbox_cmd[3] = MSDW(fw_ddb_entry_dma);
+
+	if (qla4xxx_mailbox_command(ha, 4, 7, &mbox_cmd[0], &mbox_sts[0])
+	    == QLA_ERROR) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_GET_DATABASE_ENTRY failed "
+				"with status 0x%04X\n",
+				ha->host_no, __func__, mbox_sts[0]));
+		goto exit_get_fwddb;
+	}
+
+	if (fw_ddb_index != mbox_sts[1]) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: index mismatch [%d] != [%d].\n",
+				ha->host_no, __func__, fw_ddb_index,
+				mbox_sts[1]));
+		goto exit_get_fwddb;
+	}
+
+	if (fw_ddb_entry) {
+		QL4PRINT(QLP10, printk("scsi%d: fw_ddb_entry = %p\n", ha->host_no, fw_ddb_entry));
+		qla4xxx_dump_bytes(QLP10, fw_ddb_entry, sizeof(*fw_ddb_entry));
+
+		QL4PRINT(QLP7,
+			 printk("scsi%d: %s: index [%d] MB0 %04x Tot %d Next %d "
+				"State %04x %d.%d.%d.%d:%04d \"%s\"\n",
+				ha->host_no, __func__, fw_ddb_index,
+				mbox_sts[0], mbox_sts[2], mbox_sts[3], mbox_sts[4],
+				fw_ddb_entry->ipAddr[0],
+				fw_ddb_entry->ipAddr[1],
+				fw_ddb_entry->ipAddr[2],
+				fw_ddb_entry->ipAddr[3],
+				le16_to_cpu(fw_ddb_entry->portNumber),
+				fw_ddb_entry->iscsiName));
+	}
+
+	if (num_valid_ddb_entries)
+		*num_valid_ddb_entries = mbox_sts[2];
+
+	if (next_ddb_index)
+		*next_ddb_index = mbox_sts[3];
+
+	if (fw_ddb_device_state)
+		*fw_ddb_device_state = mbox_sts[4];
+
+	if (time2wait)
+		*time2wait = mbox_sts[5];
+
+	if (tcp_source_port_num)
+		*tcp_source_port_num = (uint16_t) mbox_sts[6] >> 16;
+
+	if (connection_id)
+		*connection_id = (uint16_t) mbox_sts[6] & 0x00FF;
+
+	status = QLA_SUCCESS;
+
+	exit_get_fwddb:
+
+	LEAVE("qla4xxx_get_fwddb_entry");
+	return(status);
+}
+
+
+/**************************************************************************
+ * qla4xxx_set_fwddb_entry
+ *	This routine initializes or updates the adapter's device database
+ *	entry for the specified device.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *      fw_ddb_index - Firmware's device database index
+ *      fw_ddb_entry - Pointer to firmware's device database entry
+ *		       structure, or NULL.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	This routine also triggers a login for the specified device.
+ *	Therefore, it may also be used as a secondary login routine when
+ *	a NULL pointer is specified for the fw_ddb_entry.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully set ddb_entry in firmware
+ *	QLA_ERROR   - Failed to set ddb_entry in firmware
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_set_ddb_entry(scsi_qla_host_t *ha,
+		      uint16_t        fw_ddb_index,
+		      DEV_DB_ENTRY    *fw_ddb_entry,
+		      dma_addr_t      fw_ddb_entry_dma)
+{
+	uint8_t         status = QLA_ERROR;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	ENTER("qla4xxx_set_fwddb_entry");
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: index [%d]\n",
+			      ha->host_no, __func__, fw_ddb_index));
+
+	/* Do not wait for completion. The firmware will send us an
+	 * ASTS_DATABASE_CHANGED (0x8014) to notify us of the login status.
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t) fw_ddb_index;
+	mbox_cmd[2] = LSDW(fw_ddb_entry_dma);
+	mbox_cmd[3] = MSDW(fw_ddb_entry_dma);
+
+	if (qla4xxx_mailbox_command(ha, 4, 0, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		status = QLA_ERROR;
+	}
+	else {
+		status = QLA_SUCCESS;
+	}
+
+	LEAVE("qla4xxx_set_fwddb_entry");
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_get_crash_record
+ *	This routine retrieves a crash record from the QLA4010 after an
+ *	8002h aen.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_get_crash_record(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	CRASH_RECORD    *crash_record = NULL;
+	dma_addr_t      crash_record_dma = 0;
+	uint32_t        crash_record_size = 0;
+
+	ENTER("qla4xxx_get_crash_record");
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_cmd));
+
+	/*
+	 * Get size of crash record
+	 */
+	mbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;
+
+	if (qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to retrieve size!\n",
+				      ha->host_no, __func__));
+		goto exit_get_crash_record;
+	}
+
+	crash_record_size = mbox_sts[4];
+	if (crash_record_size == 0) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Crash record size is 0!\n",
+				      ha->host_no, __func__));
+		goto exit_get_crash_record;
+	}
+
+	/*
+	 * Alloc Memory for Crash Record
+	 */
+	crash_record = (CRASH_RECORD *) pci_alloc_consistent(ha->pdev,
+						crash_record_size,
+						&crash_record_dma);
+
+	if (crash_record == NULL){
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to allocate "
+				      " memory (%d bytes) for crash record!\n",
+				      ha->host_no, __func__, crash_record_size));
+		goto exit_get_crash_record;
+	}
+
+	/*
+	 * Get Crash Record
+	 */
+	mbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;
+	mbox_cmd[2] = LSDW(crash_record_dma);
+	mbox_cmd[3] = MSDW(crash_record_dma);
+	mbox_cmd[4] = crash_record_size;
+
+	if (qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: Unable to retrieve crash"
+				      " record!\n", ha->host_no, __func__));
+		goto exit_get_crash_record;
+	}
+
+	/*
+	 * Dump Crash Record
+	 */
+	QL4PRINT(QLP1, printk(KERN_INFO "scsi%d: Crash Record Dump:\n",
+			      ha->host_no));
+	QL4PRINT( QLP1,
+		  printk(KERN_INFO "Firmware Version: %02d.%02d.%02d.%02d\n",
+			 crash_record->fw_major_version,
+			 crash_record->fw_minor_version,
+			 crash_record->fw_patch_version,
+			 crash_record->fw_build_version));
+	QL4PRINT(QLP1, printk(KERN_INFO "Build Date: %s\n",
+			      crash_record->build_date));
+	QL4PRINT(QLP1, printk(KERN_INFO "Build Time: %s\n",
+			      crash_record->build_time));
+	QL4PRINT(QLP1, printk(KERN_INFO "Build User: %s\n",
+			      crash_record->build_user));
+	QL4PRINT(QLP1, printk(KERN_INFO "Card Serial #: %s\n",
+			      crash_record->card_serial_num));
+	QL4PRINT(QLP1,
+		 printk(KERN_INFO "Time of Crash (in seconds): %d (0x%x)\n",
+			crash_record->time_of_crash_in_secs,
+			crash_record->time_of_crash_in_secs));
+	QL4PRINT(QLP1,
+		 printk(KERN_INFO "Time of Crash (in milliseconds): "
+			"%d (0x%x)\n",
+			crash_record->time_of_crash_in_ms,
+			crash_record->time_of_crash_in_ms));
+	QL4PRINT(QLP1,
+		 printk(KERN_INFO "# frames in OUT RISC processor stack dump: "
+			"%d (0x%x)\n",
+			crash_record->out_RISC_sd_num_frames,
+			crash_record->out_RISC_sd_num_frames));
+	QL4PRINT(QLP1,
+		 printk(KERN_INFO "# words in OAP stack dump: %d (0x%x)\n",
+			crash_record->OAP_sd_num_words,
+			crash_record->OAP_sd_num_words));
+	QL4PRINT(QLP1,
+		 printk(KERN_INFO "# frames in IAP stack dump: %d (0x%x)\n",
+			crash_record->IAP_sd_num_frames,
+			crash_record->IAP_sd_num_frames));
+	QL4PRINT(QLP1,
+		 printk(KERN_INFO "# words in IN RISC processor stack dump: "
+			"%d (0x%x)\n",
+			crash_record->in_RISC_sd_num_words,
+			crash_record->in_RISC_sd_num_words));
+	QL4PRINT(QLP1,
+		 printk(KERN_INFO "\nOUT RISC processor register dump:\n"));
+	qla4xxx_dump_dwords(QLP1, &crash_record->out_RISC_reg_dump,
+			    sizeof(crash_record->out_RISC_reg_dump));
+	QL4PRINT(QLP1,
+		 printk(KERN_INFO "\nIN RISC processor register dump:\n"));
+	qla4xxx_dump_dwords(QLP1, &crash_record->in_RISC_reg_dump,
+			    sizeof(crash_record->in_RISC_reg_dump));
+	QL4PRINT(QLP1, printk(KERN_INFO "\nOUT RISC processor stack dump:\n"));
+	qla4xxx_dump_dwords(QLP1, &crash_record->in_out_RISC_stack_dump,
+			    crash_record->OAP_sd_num_words);
+	QL4PRINT(QLP1, printk(KERN_INFO "\nIN RISC processor stack dump:\n"));
+	qla4xxx_dump_dwords(QLP1, &crash_record->in_out_RISC_stack_dump[0] +
+			    crash_record->OAP_sd_num_words,
+			    crash_record->in_RISC_sd_num_words);
+
+
+	exit_get_crash_record:
+	if (crash_record)
+		pci_free_consistent(ha->pdev,
+				    crash_record_size,
+				    crash_record,
+				    crash_record_dma);
+	LEAVE("qla4xxx_get_crash_record");
+}
+
+/**************************************************************************
+ * qla4xxx_reset_lun
+ *	This routine performs a LUN RESET on the specified target/lun.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	ddb_entry - Pointer to device database entry
+ *	lun_entry - Pointer to lun entry structure
+ *
+ * Remarks:
+ *	The caller must ensure that the ddb_entry and lun_entry pointers
+ *	are valid before calling this routine.
+ *
+ * Returns:
+ *	QLA_SUCCESS - lun reset completed successfully
+ *	QLA_ERROR   - lun reset failed
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_reset_lun(scsi_qla_host_t *ha,
+		  ddb_entry_t *ddb_entry,
+		  fc_lun_t *lun_entry)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	uint8_t target = ddb_entry->target;
+	uint8_t lun = lun_entry->lun;
+	uint8_t status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_reset_lun");
+
+	spin_unlock_irq(ha->host->host_lock);
+
+	QL4PRINT(QLP2, printk(KERN_INFO
+	    "scsi%d:%d:%d:%d: lun reset issued\n", ha->host_no, ddb_entry->bus,
+	    target, lun));
+
+	/*
+	 * Send lun reset command to ISP, so that the ISP will return all
+	 * outstanding requests with RESET status
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_LUN_RESET;
+	mbox_cmd[1] = ddb_entry->fw_ddb_index;
+	mbox_cmd[2] = lun << 8;
+	mbox_cmd[5] = 0x01; /* Immediate Command Enable */
+
+	qla4xxx_mailbox_command(ha, 6, 1, &mbox_cmd[0], &mbox_sts[0]);
+	if ((mbox_sts[0] == MBOX_STS_COMMAND_COMPLETE) ||
+	    (mbox_sts[0] == MBOX_STS_COMMAND_ERROR)) {
+		QL4PRINT(QLP2, printk(KERN_INFO
+		    "scsi%d:%d:%d:%d: lun reset SUCCEEDED\n", ha->host_no,
+		    ddb_entry->bus, target, lun));
+	} else {
+		QL4PRINT(QLP2, printk(KERN_INFO
+		    "scsi%d:%d:%d:%d: lun reset FAILED w/ status %04x\n",
+		    ha->host_no, ddb_entry->bus, target, lun, mbox_sts[0]));
+
+		status = QLA_ERROR;
+	}
+
+	spin_lock_irq(ha->host->host_lock);
+
+	LEAVE("qla4xxx_reset_lun");
+
+	return (status);
+}
+
+uint8_t
+qla4xxx_isns_enable(scsi_qla_host_t *ha,
+		    uint32_t isns_ip_addr,
+		    uint16_t isns_server_port_num)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: isns_ip_addr %08x\n",
+			       ha->host_no, __func__, isns_ip_addr));
+
+	qla4xxx_isns_build_entity_id(ha);
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_ISNS_SERVICE;
+	mbox_cmd[1] = ISNS_ENABLE;
+	mbox_cmd[2] = isns_ip_addr;
+	mbox_cmd[3] = isns_server_port_num;
+
+	if (qla4xxx_mailbox_command(ha, 4, 6, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_SET_ISNS_SERVICE failed "
+				"w/ status %04X %04X\n",
+				ha->host_no, __func__, mbox_sts[0], mbox_sts[1]));
+		return(QLA_ERROR);
+	}
+
+	QL4PRINT(QLP7|QLP20, printk(KERN_INFO "scsi%d: Start iSNS Service "
+				    "%d.%d.%d.%d Port %04d . . .\n", ha->host_no,
+				    (isns_ip_addr & 0x000000FF),
+				    (isns_ip_addr & 0x0000FF00) >> 8,
+				    (isns_ip_addr & 0x00FF0000) >> 16,
+				    (isns_ip_addr & 0xFF000000) >> 24,
+				    isns_server_port_num));
+
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_disable(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	if (test_bit(ISNS_FLAG_ISNS_SRV_ENABLED, &ha->isns_flags)) {
+		memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+		memset(&mbox_sts, 0, sizeof(mbox_sts));
+		mbox_cmd[0] = MBOX_CMD_SET_ISNS_SERVICE;
+		mbox_cmd[1] = ISNS_DISABLE;
+
+		if (qla4xxx_mailbox_command(ha, 2, 2, &mbox_cmd[0], &mbox_sts[0])
+		    != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+				 printk("scsi%d: %s: MBOX_CMD_SET_ISNS_SERVICE failed "
+					"w/ status %04X %04X\n",
+					ha->host_no, __func__, mbox_sts[0], mbox_sts[1]));
+			return(QLA_ERROR);
+		}
+	}
+
+	clear_bit(ISNS_FLAG_ISNS_SRV_ENABLED, &ha->isns_flags);
+	ISNS_CLEAR_FLAGS(ha);
+
+	ha->isns_connection_id   = 0;
+	//ha->isns_scn_conn_id     = 0;
+	//ha->isns_esi_conn_id     = 0;
+	//ha->isns_nsh_conn_id     = 0;
+
+	ha->isns_remote_port_num = 0;
+	ha->isns_scn_port_num    = 0;
+	ha->isns_esi_port_num    = 0;
+	ha->isns_nsh_port_num    = 0;
+
+	ha->isns_num_discovered_targets = 0;
+	memset(ha->isns_entity_id, 0, sizeof(ha->isns_entity_id));
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_isns_status(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_ISNS_SERVICE;
+	mbox_cmd[1] = ISNS_STATUS;
+
+	if (qla4xxx_mailbox_command(ha, 2, 2, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: MBOX_CMD_SET_ISNS_SERVICE failed "
+				"w/ status %04X %04X\n",
+				ha->host_no, __func__, mbox_sts[0], mbox_sts[1]));
+		return(QLA_ERROR);
+	}
+
+	QL4PRINT(QLP20, printk("scsi%d: %s: = %s\n",
+			       ha->host_no, __func__,
+			       ((mbox_sts[1] & 1) == 0) ? "DISABLED" : "ENABLED"));
+	return(QLA_SUCCESS);
+}
+
+uint8_t
+qla4xxx_get_flash(scsi_qla_host_t *ha, dma_addr_t dma_addr, uint32_t offset, uint32_t len)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(dma_addr);
+	mbox_cmd[2] = MSDW(dma_addr);
+	mbox_cmd[3] = offset;
+	mbox_cmd[4] = len;
+
+	if (qla4xxx_mailbox_command(ha, 5, 2, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: MBOX_CMD_READ_FLASH, failed w/ "
+				      "status %04X %04X, offset %08x, len %08x\n",
+				      ha->host_no, __func__, mbox_sts[0], mbox_sts[1],
+				      offset, len));
+		return(QLA_ERROR);
+	}
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_get_fw_version
+ *	This routine retrieves the firmware version for the specified adapter.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *
+ * Output:
+ *	None
+ *
+ * Remarks:
+ *	In QLA4010, mailboxes 2 & 3 may hold an address for data.  Make sure
+ *	that we write 0 to those mailboxes, if unused.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully retrieved firmware version
+ *	QLA_ERROR   - Failed to retrieve firmware version
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_get_fw_version(scsi_qla_host_t *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	/*
+	 * Get firmware version
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_ABOUT_FW;
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0])
+	    != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: MBOX_CMD_ABOUT_FW failed w/ "
+				      "status %04X\n",
+				      ha->host_no, __func__, mbox_sts[0]));
+		return(QLA_ERROR);
+	}
+
+	/*
+	 * Save firmware version information
+	 */
+	ha->firmware_version[0] = mbox_sts[1];
+	ha->firmware_version[1] = mbox_sts[2];
+	ha->patch_number        = mbox_sts[3];
+	ha->build_number        = mbox_sts[4];
+
+	QL4PRINT(QLP7, printk("scsi%d: FW Version %02d.%02d Patch %02d Build %02d\n",
+			      ha->host_no, ha->firmware_version[0], ha->firmware_version[1],
+			      ha->patch_number, ha->build_number));
+
+	return(QLA_SUCCESS);
+}
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_nvram.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_nvram.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_nvram.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_nvram.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,312 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic qla4xxx driver for Linux 2.4.x
+ * Copyright (C) 2004 Qlogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	FM93C56A_Select
+ *	FM93C56A_Cmd
+ *	FM93C56A_Deselect
+ *	FM93C56A_DataIn
+ *	EEPROM_ReadWord
+ *	RD_NVRAM_WORD
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+int   eepromSize  = EEPROM_SIZE;
+int   addrBits    = EEPROM_NO_ADDR_BITS;
+int   dataBits    = EEPROM_NO_DATA_BITS;
+int   eepromCmdData = 0;
+
+
+static int FM93C56A_Select(scsi_qla_host_t *ha)
+{
+	QL4PRINT(QLP17, printk(KERN_ERR "FM93C56A_Select:\n"));
+	eepromCmdData = AUBURN_EEPROM_CS_1 | 0x000f0000;
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData);
+	PCI_POSTING(ISP_NVRAM(ha));
+	return(1);
+}
+
+static int FM93C56A_Cmd(scsi_qla_host_t *ha, int cmd, int addr)
+{
+	int   i;
+	int   mask;
+	int   dataBit;
+	int   previousBit;
+
+	QL4PRINT(QLP17, printk(KERN_ERR "FM93C56A_Cmd(%d, 0x%x)\n", cmd, addr));
+
+	// Clock in a zero, then do the start bit
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_DO_1);
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_DO_1 | AUBURN_EEPROM_CLK_RISE);
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_DO_1 | AUBURN_EEPROM_CLK_FALL);
+	PCI_POSTING(ISP_NVRAM(ha));
+
+	mask = 1 << (FM93C56A_CMD_BITS-1);
+	// Force the previous data bit to be different
+	previousBit = 0xffff;
+	for (i = 0; i < FM93C56A_CMD_BITS; i++) {
+		dataBit = (cmd & mask) ? AUBURN_EEPROM_DO_1 : AUBURN_EEPROM_DO_0;
+		if (previousBit != dataBit) {
+			// If the bit changed, then change the DO state to match
+			WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit);
+			previousBit = dataBit;
+		}
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit | AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit | AUBURN_EEPROM_CLK_FALL);
+		PCI_POSTING(ISP_NVRAM(ha));
+		cmd = cmd << 1;
+	}
+
+	mask = 1 << (addrBits-1);
+	// Force the previous data bit to be different
+	previousBit = 0xffff;
+	for (i = 0; i < addrBits; i++) {
+		dataBit = (addr & mask) ? AUBURN_EEPROM_DO_1 : AUBURN_EEPROM_DO_0;
+		if (previousBit != dataBit) {
+			// If the bit changed, then change the DO state to match
+			WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit);
+			previousBit = dataBit;
+		}
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit | AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | dataBit | AUBURN_EEPROM_CLK_FALL);
+		PCI_POSTING(ISP_NVRAM(ha));
+		addr = addr << 1;
+	}
+	return(1);
+}
+
+static int FM93C56A_Deselect(scsi_qla_host_t *ha)
+{
+	QL4PRINT(QLP17, printk(KERN_ERR "FM93C56A_Deselect:\n"));
+	eepromCmdData = AUBURN_EEPROM_CS_0 | 0x000f0000 ;
+	WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData);
+	PCI_POSTING(ISP_NVRAM(ha));
+	return(1);
+}
+
+static int FM93C56A_DataIn(scsi_qla_host_t *ha, unsigned short *value)
+{
+	int   i;
+	int   data = 0;
+	int   dataBit;
+
+	// Read the data bits
+	// The first bit is a dummy.  Clock right over it.
+	for (i = 0; i < dataBits; i++) {
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_CLK_RISE);
+		WRT_REG_DWORD(ISP_NVRAM(ha), eepromCmdData | AUBURN_EEPROM_CLK_FALL);
+		dataBit = (RD_REG_DWORD(ISP_NVRAM(ha)) & AUBURN_EEPROM_DI_1) ? 1 : 0;
+		data = (data << 1) | dataBit;
+	}
+	*value = data;
+	QL4PRINT(QLP17, printk(KERN_ERR "FM93C56A_DataIn(0x%x)\n", *value));
+	return(1);
+}
+
+static int
+EEPROM_ReadWord(int eepromAddr, u16 *value, scsi_qla_host_t *ha)
+{
+	QL4PRINT(QLP17, printk(KERN_ERR "EEPROM_Reg addr %p\n", ISP_NVRAM(ha)));
+	QL4PRINT(QLP17, printk(KERN_ERR "EEPROM_ReadWord(0x%x)\n", eepromAddr));
+
+	FM93C56A_Select(ha);
+	FM93C56A_Cmd(ha, FM93C56A_READ, eepromAddr);
+	FM93C56A_DataIn(ha, value);
+	FM93C56A_Deselect(ha);
+	QL4PRINT(QLP17, printk(KERN_ERR "EEPROM_ReadWord(0x%x, %d)\n",
+			       eepromAddr, *value));
+	return(1);
+}
+
+/* Hardware_lock must be set before calling */
+u16
+RD_NVRAM_WORD(scsi_qla_host_t *ha, int offset)
+{
+	u16 val;
+	/* NOTE: NVRAM uses half-word addresses */
+	EEPROM_ReadWord(offset, &val, ha);
+	return(val);
+}
+
+uint8_t
+qla4xxx_is_NVRAM_configuration_valid(scsi_qla_host_t *ha)
+{
+	uint16_t checksum = 0;
+	uint32_t index;
+	unsigned long flags;
+	uint8_t status = QLA_ERROR;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (index = 0;	index < EEPROM_SIZE; index++) {
+		checksum += RD_NVRAM_WORD(ha, index);
+	} 
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (checksum == 0)
+		status = QLA_SUCCESS;
+
+	return (status);
+}
+
+/*************************************************************************
+ *
+ *			Hardware Semaphore
+ *
+ *************************************************************************/
+
+isp4xxxSemInfo_t semInfo4010[] = {
+	{ SEM_HW_LOCK,     4}
+	, { SEM_GPO,         6}
+	, { SEM_SDRAM_INIT,  8}
+	, { SEM_PHY_GBIC,   10}
+	, { SEM_NVRAM,      12}
+	, { SEM_FLASH,      14}
+};
+
+isp4xxxSemInfo_t semInfo4022[] = {
+        { SEM_DRIVER,        1}
+        , { SEM_DRAM,  	     4}
+	, { SEM_GPO,         7}
+	, { SEM_PHY_GBIC,    7}
+	, { SEM_NVRAM,      10}
+	, { SEM_FLASH,      13}
+};
+
+static uint32_t SEM_READ(scsi_qla_host_t *ha, uint32_t semId)
+{
+	if (IS_QLA4022(ha))
+		return ((RD_REG_DWORD(ISP_NVRAM(ha)) >> semInfo4022[semId].semShift) & SEM_MASK);
+	else
+		return ((RD_REG_DWORD(ISP_NVRAM(ha)) >> semInfo4010[semId].semShift) & SEM_MASK);
+
+}
+
+
+static void SEM_WRITE(scsi_qla_host_t *ha, uint32_t semId, uint8_t owner)
+{
+	if (IS_QLA4022(ha))
+		WRT_REG_DWORD(ISP_NVRAM(ha), (SEM_MASK << 16 << semInfo4022[semId].semShift) | (owner << semInfo4022[semId].semShift));
+	else
+		WRT_REG_DWORD(ISP_NVRAM(ha), (SEM_MASK << 16 << semInfo4010[semId].semShift) | (owner << semInfo4010[semId].semShift));
+}
+
+/**************************************************************************
+ * qla4xxx_take_hw_semaphore
+ *	This routine acquires the specified semaphore for the iSCSI
+ *	storage driver.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	sem - Indicates which semaphore.
+ *	wait_flag - specifies type of wait to acquire semaphore
+ *		    SEM_FLG_WAIT_FOREVER = wait indefinitely
+ *		    SEM_FLG_TIMED_WAIT = wait for a specified amout of time
+ *	            SEM_FLG_NO_WAIT = try once to acquire semaphore
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully acquired semaphore
+ *	QLA_ERROR   - Failed to acquire semaphore
+ *
+ * Context:
+ *	?? context.
+ **************************************************************************/
+uint8_t
+qla4xxx_take_hw_semaphore(scsi_qla_host_t *ha, uint32_t sem, uint8_t wait_flag)
+{
+	uint32_t wait_time = SEMAPHORE_TOV;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	for (SEM_WRITE(ha, sem, SEM_OWNER_STORAGE);
+	     (SEM_READ(ha, sem) != SEM_OWNER_STORAGE) && (wait_time--);
+	     (SEM_WRITE(ha, sem, SEM_OWNER_STORAGE), PCI_POSTING(ISP_NVRAM(ha)))) {
+		if (wait_flag == SEM_FLG_NO_WAIT) {
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			return(QLA_ERROR);
+		}
+
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1 * HZ);
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+	}
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (wait_time)
+		return(QLA_SUCCESS);
+	else
+		return(QLA_ERROR);
+}
+
+/**************************************************************************
+ * qla4xxx_clear_hw_semaphore
+ *	This routine restores the specified semaphore to the available
+ *	state.
+ *
+ * Input:
+ * 	ha - Pointer to host adapter structure.
+ *	sem - Indicates which semaphore.
+ *
+ * Returns:
+ *	QLA_SUCCESS - Successfully restored semaphore
+ *	QLA_ERROR   - Failed to restore semaphore
+ *
+ * Context:
+ *	?? context.
+ **************************************************************************/
+void
+qla4xxx_clear_hw_semaphore(scsi_qla_host_t *ha, uint32_t sem)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	if (SEM_READ(ha, sem) == SEM_OWNER_STORAGE) {
+		SEM_WRITE(ha, sem, SEM_AVAILABLE);
+		PCI_POSTING(ISP_NVRAM(ha));
+	}	
+	
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+
+
+/*
+ * Overrides for Emacs so that we get a uniform tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_nvram.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_nvram.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_nvram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_nvram.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,383 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+/*
+ * Module Name: ql4nvrm.h
+ */
+
+
+#ifndef _QL2XNVRM_H_
+#define _QL2XNVRM_H_
+
+
+//
+// AM29LV Flash definitions
+//
+#define  FM93C56A_SIZE_8      0x100
+#define  FM93C56A_SIZE_16     0x80
+#define  FM93C66A_SIZE_8      0x200
+#define  FM93C66A_SIZE_16     0x100
+#define  FM93C86A_SIZE_16     0x400
+	
+#ifdef QLA4022
+#define  EEPROM_SIZE          FM93C86A_SIZE_16
+#else
+#define  EEPROM_SIZE          FM93C66A_SIZE_16
+#endif
+
+#define  FM93C56A_START       0x1
+
+// Commands
+#define  FM93C56A_READ        0x2
+#define  FM93C56A_WEN         0x0
+#define  FM93C56A_WRITE       0x1
+#define  FM93C56A_WRITE_ALL   0x0
+#define  FM93C56A_WDS         0x0
+#define  FM93C56A_ERASE       0x3
+#define  FM93C56A_ERASE_ALL   0x0
+
+// Command Extentions
+#define  FM93C56A_WEN_EXT        0x3
+#define  FM93C56A_WRITE_ALL_EXT  0x1
+#define  FM93C56A_WDS_EXT        0x0
+#define  FM93C56A_ERASE_ALL_EXT  0x2
+
+// Address Bits
+#define  FM93C56A_NO_ADDR_BITS_16   8
+#define  FM93C56A_NO_ADDR_BITS_8    9
+#define  FM93C86A_NO_ADDR_BITS_16   10
+
+#ifdef QLA4022
+#define  EEPROM_NO_ADDR_BITS  FM93C86A_NO_ADDR_BITS_16
+#else
+#define  EEPROM_NO_ADDR_BITS  FM93C56A_NO_ADDR_BITS_16
+#endif
+
+
+// Data Bits
+#define  FM93C56A_DATA_BITS_16   16
+#define  FM93C56A_DATA_BITS_8    8
+
+#define  EEPROM_NO_DATA_BITS  FM93C56A_DATA_BITS_16
+	
+// Special Bits
+#define  FM93C56A_READ_DUMMY_BITS   1
+#define  FM93C56A_READY             0
+#define  FM93C56A_BUSY              1
+#define  FM93C56A_CMD_BITS          2
+
+// Auburn Bits
+#define  AUBURN_EEPROM_DI           0x8
+#define  AUBURN_EEPROM_DI_0         0x0
+#define  AUBURN_EEPROM_DI_1         0x8
+#define  AUBURN_EEPROM_DO           0x4
+#define  AUBURN_EEPROM_DO_0         0x0
+#define  AUBURN_EEPROM_DO_1         0x4
+#define  AUBURN_EEPROM_CS           0x2
+#define  AUBURN_EEPROM_CS_0         0x0
+#define  AUBURN_EEPROM_CS_1         0x2
+#define  AUBURN_EEPROM_CLK_RISE     0x1
+#define  AUBURN_EEPROM_CLK_FALL     0x0
+
+
+//
+// EEPROM format
+//
+typedef struct _BIOS_PARAMS
+{
+    UINT16  SpinUpDelay                  :1;
+    UINT16  BIOSDisable                  :1;
+    UINT16  MMAPEnable                   :1;
+    UINT16  BootEnable                   :1;
+    UINT16  Reserved0                    :12;
+
+    UINT8   bootID0                      :7;
+    UINT8   bootID0Valid                 :1;
+
+    UINT8   bootLUN0[8];
+
+    UINT8   bootID1                      :7;
+    UINT8   bootID1Valid                 :1;
+
+    UINT8   bootLUN1[8];
+
+    UINT16  MaxLunsPerTarget;
+    UINT8   Reserved1[10];
+} BIOS_PARAMS, *PBIOS_PARAMS;
+
+typedef struct _EEPROM_PORT_CFG
+{
+   // MTU MAC 0
+   u16               etherMtu_mac;
+
+   // Flow Control MAC 0
+   u16               pauseThreshold_mac;
+   u16               resumeThreshold_mac;
+   u16               reserved[13];
+} EEPROM_PORT_CFG, *PEEPROM_PORT_CFG;
+
+typedef struct _EEPROM_FUNCTION_CFG
+{
+   u8                reserved[30];
+
+   // MAC ADDR
+   u8                macAddress[6];
+   u8                macAddressSecondary[6];
+
+   u16               subsysVendorId;
+   u16               subsysDeviceId;
+} EEPROM_FUNCTION_CFG;
+
+typedef struct {
+	union {
+		struct { /* isp4010 */
+			u8    asic_id[4];				// x00
+			u8    version;					// x04
+			u8    reserved;					// x05
+
+			u16   board_id;					// x06
+		     #  define   EEPROM_BOARDID_ELDORADO    1
+		     #  define   EEPROM_BOARDID_PLACER      2
+
+		     #  define EEPROM_SERIAL_NUM_SIZE       16
+			u8    serial_number[EEPROM_SERIAL_NUM_SIZE];	// x08
+
+		     // ExtHwConfig:
+		     // Offset = 24bytes
+		     //
+		     // | SSRAM Size|     |ST|PD|SDRAM SZ| W| B| SP  |  |
+		     // |15|14|13|12|11|10| 9| 8 | 7| 6| 5| 4| 3| 2| 1| 0|
+		     // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+			u16   ext_hw_conf;				// x18
+
+			u8    mac0[6];					// x1A
+			u8    mac1[6];					// x20
+			u8    mac2[6];					// x26
+			u8    mac3[6];					// x2C
+	
+			u16   etherMtu;					// x32
+			u16   macConfig;				// x34
+		     #define  MAC_CONFIG_ENABLE_ANEG     0x0001
+		     #define  MAC_CONFIG_ENABLE_PAUSE    0x0002
+
+			u16   phyConfig;				// x36
+		     #define  PHY_CONFIG_PHY_ADDR_MASK             0x1f
+		     #define  PHY_CONFIG_ENABLE_FW_MANAGEMENT_MASK 0x20
+
+		        u16   topcat;					// x38
+		     #define TOPCAT_PRESENT		0x0100
+		     #define TOPCAT_MASK		0xFF00
+
+		     #  define EEPROM_UNUSED_1_SIZE   2
+			u8    unused_1[EEPROM_UNUSED_1_SIZE];		// x3A
+
+			u16   bufletSize;				// x3C
+			u16   bufletCount;				// x3E
+			u16   bufletPauseThreshold;			// x40
+			u16   tcpWindowThreshold50;			// x42
+			u16   tcpWindowThreshold25;			// x44
+			u16   tcpWindowThreshold0;			// x46
+			u16   ipHashTableBaseHi;			// x48
+			u16   ipHashTableBaseLo;			// x4A
+			u16   ipHashTableSize;				// x4C
+			u16   tcpHashTableBaseHi;			// x4E
+			u16   tcpHashTableBaseLo;			// x50
+			u16   tcpHashTableSize;				// x52
+			u16   ncbTableBaseHi;                        	// x54
+			u16   ncbTableBaseLo;                        	// x56
+			u16   ncbTableSize;                          	// x58
+			u16   drbTableBaseHi;                        	// x5A
+			u16   drbTableBaseLo;                        	// x5C
+			u16   drbTableSize;                          	// x5E
+
+		     #  define EEPROM_UNUSED_2_SIZE   4
+			u8    unused_2[EEPROM_UNUSED_2_SIZE];        	// x60
+
+			u16   ipReassemblyTimeout;                   	// x64
+			u16   tcpMaxWindowSizeHi;                    	// x66
+			u16   tcpMaxWindowSizeLo;                    	// x68
+
+			u32   net_ip_addr0 ;	               		// x6A /* Added for TOE functionality. */
+			u32   net_ip_addr1 ;	                        // x6E
+			u32   scsi_ip_addr0 ;	                	// x72
+			u32   scsi_ip_addr1 ;	                	// x76
+		     #  define EEPROM_UNUSED_3_SIZE   128	/* changed from 144 to account for ip addresses */
+			u8    unused_3[EEPROM_UNUSED_3_SIZE];        	// x7A
+
+			u16   subsysVendorId_f0;                     	// xFA
+			u16   subsysDeviceId_f0;                     	// xFC
+
+			// Address = 0x7F
+		     #  define FM93C56A_SIGNATURE  0x9356
+		     #  define FM93C66A_SIGNATURE  0x9366
+			u16   signature;                             	// xFE
+
+		     #  define EEPROM_UNUSED_4_SIZE   250
+			u8    unused_4[EEPROM_UNUSED_4_SIZE];        	// x100
+
+			u16   subsysVendorId_f1;                     	// x1FA
+			u16   subsysDeviceId_f1;                     	// x1FC
+
+			u16   checksum;                              	// x1FE
+		} __attribute__((packed)) isp4010;
+
+		struct { /* isp4022 */
+			u8                asicId[4];                    // x00
+			u8                version;                      // x04
+			u8                reserved_5;                   // x05
+
+			u16               boardId;                      // x06
+			u8                boardIdStr[16];               // x08
+			u8                serialNumber[16];             // x18
+
+			// External Hardware Configuration
+			u16               ext_hw_conf;                  // x28
+
+			// MAC 0 CONFIGURATION
+			EEPROM_PORT_CFG macCfg_port0;                   // x2A
+
+			// MAC 1 CONFIGURATION
+			EEPROM_PORT_CFG macCfg_port1;                   // x4A
+
+			// DDR SDRAM Configuration
+			u16               bufletSize;                   // x6A
+			u16               bufletCount;                  // x6C
+			u16               tcpWindowThreshold50;		// x6E
+			u16               tcpWindowThreshold25;         // x70
+			u16               tcpWindowThreshold0;          // x72
+			u16               ipHashTableBaseHi;            // x74
+			u16               ipHashTableBaseLo;            // x76
+			u16               ipHashTableSize;              // x78
+			u16               tcpHashTableBaseHi;           // x7A
+			u16               tcpHashTableBaseLo;           // x7C
+			u16               tcpHashTableSize;             // x7E
+			u16               ncbTableBaseHi;               // x80
+			u16               ncbTableBaseLo;               // x82
+			u16               ncbTableSize;                 // x84
+			u16               drbTableBaseHi;               // x86
+			u16               drbTableBaseLo;               // x88
+			u16               drbTableSize;                 // x8A
+			u16               reserved_142[4];              // x8C
+
+			// TCP/IP Parameters
+			u16               ipReassemblyTimeout;          // x94
+			u16               tcpMaxWindowSize;             // x96
+			u16               ipSecurity;                   // x98
+
+			u8                reserved_156[294];            // x9A
+			u16               qDebug[8];  // QLOGIC USE ONLY   x1C0
+
+			EEPROM_FUNCTION_CFG  funcCfg_fn0;               // x1D0
+			u16               reserved_510;                 // x1FE
+
+			// Address = 512
+			u8                oemSpace[432];                // x200
+
+			BIOS_PARAMS          sBIOSParams_fn1;           // x3B0
+			EEPROM_FUNCTION_CFG  funcCfg_fn1;               // x3D0
+			u16               reserved_1022;                // x3FE
+
+			// Address = 1024
+			u8                reserved_1024[464];           // x400
+			EEPROM_FUNCTION_CFG  funcCfg_fn2;               // x5D0
+
+			u16               reserved_1534;                // x5FE
+
+			// Address = 1536
+			u8                reserved_1536[432];           // x600
+			BIOS_PARAMS          sBIOSParams_fn3;           // x7B0
+			EEPROM_FUNCTION_CFG  funcCfg_fn3;               // x7D0
+
+			u16               checksum;                     // x7FE
+		} __attribute__((packed)) isp4022;
+	};
+
+} eeprom_data_t;
+
+#define EEPROM_EXT_HW_CONF_OFFSET() \
+	(IS_QLA4022(ha) ? \
+	 offsetof(eeprom_data_t, isp4022.ext_hw_conf) / 2 : \
+	 offsetof(eeprom_data_t, isp4010.ext_hw_conf) / 2)
+
+
+/*************************************************************************
+ *
+ *			Hardware Semaphore
+ *
+ *************************************************************************/
+//
+// Semaphore register definitions
+//
+#define SEM_AVAILABLE        	0x00
+#define SEM_OWNER_FIRMWARE   	0x01
+#define SEM_OWNER_STORAGE    	0x02
+#define SEM_OWNER_NETWORK    	0x03
+
+
+//
+// Private Semaphore definitions
+//
+typedef enum
+{
+	SEM_DRIVER
+	, SEM_GPO
+	, SEM_SDRAM_INIT
+	, SEM_DRAM
+	, SEM_PHY_GBIC
+	, SEM_NVRAM
+	, SEM_FLASH
+	, SEM_HW_LOCK
+
+	, SEM_COUNT // Not a real semaphore, just indicates how many there are
+} ISP4XXX_SEMAPHORE;
+
+typedef struct {
+	UINT32   semId;
+	UINT32   semShift;
+} isp4xxxSemInfo_t;
+
+
+#define SEM_MASK  0x3
+
+/* Wait flag defines -- specifies type of wait to acquire semaphore */
+#define SEM_FLG_NO_WAIT		0
+#define SEM_FLG_WAIT_FOREVER	1
+#define SEM_FLG_TIMED_WAIT	2
+
+
+
+#endif // _QL2XNVRM_H_
+
+/*
+ * Overrides for Emacs so that we get a uniform tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_os.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_os.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_os.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_os.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,5228 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *      qla4xxx_get_hba_count
+ *      pci_set_dma_mask
+ *      qla4xxx_config_dma_addressing
+ *      qla4xxx_detect
+ *      qla4xxx_display_config
+ *      qla4xxx_alloc_srb_pool
+ *      qla4xxx_free_srb_pool
+ *      qla4xxx_mem_alloc
+ *      qla4xxx_mem_free
+ *      qla4xxx_register_resources
+ *      qla4xxx_set_info
+ *      copy_mem_info
+ *      copy_info
+ *      qla4xxx_proc_dump_srb_info
+ *      qla4xxx_proc_dump_discovered_devices
+ *      qla4xxx_proc_dump_scanned_devices
+ *      qla4xxx_proc_info
+ *      qla4xxx_get_adapter_handle
+ *      qla4xxx_release
+ *      add_to_active_array
+ *      del_from_active_array
+ *      qla4xxx_normalize_dma_addr
+ *      qla4xxx_alloc_cont_entry
+ *      qla4xxx_send_command_to_isp
+ *      qla4xxx_complete_request
+ *      qla4xxx_queuecommand
+ *      qla4xxx_extend_timeout
+ *      qla4xxx_start_io
+ *      qla4xxx_os_cmd_timeout
+ *      qla4xxx_add_timer_to_cmd
+ *      qla4xxx_delete_timer_from_cmd
+ *      qla4xxx_timer
+ *      qla4xxx_ioctl_error_recovery
+ *      qla4xxx_do_dpc
+ *      qla4xxx_panic
+ *      qla4xxx_eh_wait_on_command
+ *      WAIT_FOR_ADAPTER_UP
+ *      qla4xxx_eh_abort
+ *      qla4010_soft_reset
+ *      qla4xxx_topcat_reset
+ *      qla4xxx_soft_reset
+ *      qla4xxx_hard_reset
+ *      qla4xxx_cmd_wait
+ *      qla4xxx_recover_adapter
+ *      qla4xxx_eh_wait_for_active_target_commands
+ *      qla4xxx_eh_device_reset
+ *      qla4xxx_eh_bus_reset
+ *      qla4xxx_reset_target
+ *      qla4xxx_flush_active_srbs
+ *      qla4xxx_eh_host_reset
+ *      apidev_open
+ *      apidev_close
+ *      apidev_ioctl
+ *      apidev_init
+ *      apidev_cleanup
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+#include <linux/version.h>
+#include <linux/moduleparam.h>
+#include <linux/vmalloc.h>
+#include <linux/smp_lock.h>
+#include <linux/delay.h>
+
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsicam.h>
+
+/*
+ * List of host adapters
+ *---------------------------------------------------------------------------*/
+/*
+ * True list of host adapters.  Available for use after qla4xxx_detect has completed
+ */
+struct list_head qla4xxx_hostlist = LIST_HEAD_INIT(qla4xxx_hostlist);
+rwlock_t qla4xxx_hostlist_lock = RW_LOCK_UNLOCKED;
+
+int qla4xxx_hba_count = 0;
+
+/*
+ * Command line options
+ *---------------------------------------------------------------------------*/
+/*
+ * Just in case someone uses commas to separate items on the insmod
+ * command line, we define a dummy buffer here to avoid having insmod
+ * write wild stuff into our code segment
+ */
+
+int ql4xdiscoverywait=15;
+module_param(ql4xdiscoverywait, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xdiscoverywait,
+		 "Discovery wait time");
+
+int ql4xportdownretrycount= 60;
+module_param(ql4xportdownretrycount, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xportdownretrycount,
+		 "Port down retry count");
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+int ql4xcmdretrycount = 30;
+#else
+int ql4xcmdretrycount = 20;
+#endif
+module_param(ql4xcmdretrycount, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xcmdretrycount,
+		 "Maximum number of mid-layer retries allowed for a command.  "
+		 "Default value in non-failover mode is 20, "
+		 "in failover mode, 30.");
+
+int ql4xmaxqdepth = 2;
+module_param(ql4xmaxqdepth, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xmaxqdepth,
+		 "Maximum queue depth to report for target devices.");
+
+int ql4xcmdtimeout = 5;
+module_param(ql4xcmdtimeout, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(ql4xcmdtimeout,
+		 "Command timeout");
+
+int extended_error_logging = 0;	/* 0 = off, 1 = log errors, 2 = debug logging */
+module_param(extended_error_logging, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(extended_error_logging,
+		 "Option to enable extended error logging, "
+		 "Default is 0 - no logging. 1 - log errors. 2 - debug "
+		 "logging");
+
+int displayConfig = 0;
+module_param(displayConfig, int, S_IRUGO|S_IRUSR);
+MODULE_PARM_DESC(displayConfig,
+		 "If 1 then display the configuration used in "
+		 "/etc/modules.conf.");
+
+char *ql4xdevconf = NULL;
+
+MODULE_AUTHOR("QLogic Corporation");
+MODULE_DESCRIPTION("QLogic ISP4XXX iSCSI Host Bus Adapter driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Proc info processing
+ *---------------------------------------------------------------------------*/
+struct info_str {
+	char    *buffer;
+	int     length;
+	off_t   offset;
+	int     pos;
+};
+
+/*
+ * String messages for various state values (used for print statements)
+ *---------------------------------------------------------------------------*/
+const char *ddb_state_msg[] = DDB_STATE_TBL();
+const char *srb_state_msg[] = SRB_STATE_TBL();
+#if 0
+const char *dev_state_msg[] = DEV_STATE_TBL();
+const char *lun_state_msg[] = LUN_STATE_TBL();
+const char *adapter_state_msg[] = ADAPTER_STATE_TBL();
+#endif
+
+/*
+ * extern from ql4_xioctl.c
+ */
+extern int
+qla4xxx_ioctl_init(void);
+extern int
+qla4xxx_ioctl_exit(void);
+extern int
+qla4xxx_alloc_ioctl_mem(scsi_qla_host_t *);
+extern void
+qla4xxx_free_ioctl_mem(scsi_qla_host_t *);
+
+
+static uint8_t qla4xxx_mem_alloc(scsi_qla_host_t *ha);
+static void qla4xxx_mem_free(scsi_qla_host_t *ha);
+void qla4xxx_timer(unsigned long p);
+static int qla4xxx_do_dpc(void *data);
+void qla4xxx_display_config(void);
+void qla4xxx_add_timer_to_cmd(srb_t *srb, int timeout);
+static void qla4xxx_flush_active_srbs(scsi_qla_host_t *ha);
+uint8_t qla4xxx_reset_target(scsi_qla_host_t *ha, ddb_entry_t *ddb_entry);
+uint8_t qla4xxx_recover_adapter(scsi_qla_host_t *ha, uint8_t renew_ddb_list);
+inline uint32_t qla4xxx_normalize_dma_addr(dma_addr_t *e_addr,  uint32_t *e_len, dma_addr_t *ne_addr, uint32_t *ne_len);
+inline uint8_t qla4xxx_alloc_cont_entry(scsi_qla_host_t *ha, DATA_SEG_A64 **cur_dsd, uint16_t *avail_dsds);
+void qla4xxx_config_dma_addressing(scsi_qla_host_t *ha);
+
+static void qla4xxx_free_other_mem(scsi_qla_host_t *ha);
+static int qla4xxx_iospace_config(scsi_qla_host_t *ha);
+extern fc_lun_t * qla4xxx_add_fclun(fc_port_t *fcport, uint16_t lun);
+
+
+/*
+ * PCI driver interface definitions
+ *---------------------------------------------------------------------------*/
+static struct pci_device_id qla4010_pci_tbl[] __devinitdata =
+{
+	{QLA4XXX_VENDOR_ID, QLA4010_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, qla4010_pci_tbl);
+
+static int __devinit qla4xxx_probe_adapter(struct pci_dev *, const struct pci_device_id *);
+static void __devexit qla4xxx_remove_adapter(struct pci_dev *);
+static void qla4xxx_free_adapter(scsi_qla_host_t *ha);
+
+struct pci_driver qla4xxx_pci_driver = {
+	.name           = DRIVER_NAME,
+	.id_table       = qla4010_pci_tbl,
+	.probe          = qla4xxx_probe_adapter,
+	.remove         = qla4xxx_remove_adapter,
+};
+
+int qla4xxx_proc_info(struct Scsi_Host *, char *, char **, off_t, int, int);
+int qla4xxx_queuecommand(struct scsi_cmnd *cmd, void (*done_fn)(struct scsi_cmnd *));
+int qla4xxx_eh_abort(struct scsi_cmnd *cmd);
+int qla4xxx_eh_bus_reset(struct scsi_cmnd *cmd);
+int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd);
+int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd);
+int qla4xxx_slave_configure(struct scsi_device * device);
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+extern int qla4xxx_ioctl(struct scsi_device *dev, int cmd, void *arg);
+#endif
+
+static struct scsi_host_template qla4xxx_driver_template = {
+	.module			= THIS_MODULE,
+	.name			= "qla4xxx",
+	.proc_name		= "qla4xxx",
+	.proc_info		= qla4xxx_proc_info,
+	.queuecommand		= qla4xxx_queuecommand,
+
+	.eh_abort_handler	= qla4xxx_eh_abort,
+	.eh_device_reset_handler = qla4xxx_eh_device_reset,
+	.eh_bus_reset_handler	= qla4xxx_eh_bus_reset,
+	.eh_host_reset_handler	= qla4xxx_eh_host_reset,
+
+	.slave_configure	= qla4xxx_slave_configure,
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	.ioctl			= qla4xxx_ioctl,
+#endif
+	.this_id		= -1,
+	.cmd_per_lun		= 3,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.sg_tablesize		= SG_ALL,
+};
+
+/**************************************************************************
+ * qla4xxx_set_info
+ *      This routine set parameters for the driver from the /proc filesystem.
+ *
+ * Input:
+ *      Unused
+ *
+ * Returns:
+ *      -ENOSYS - no-op
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_set_info(char *buffer, int length, struct Scsi_Host *HBAptr)
+{
+#if 0
+        uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	if (length < 13 || strncmp("scsi-qla", buffer, 8))
+		goto out;
+
+	/*
+	 * Usage: echo "scsi-qlascan " > /proc/scsi/<driver-name>/<adapter-id>
+	 *
+	 * <driver-name> can be either one : qla2100/qla2200/qla2300	
+	 *
+	 * Ex:- For qla2300 driver: 
+	 *	echo "scsi-qlascan " > /proc/scsi/qla2300/<adapter-id>
+	 *
+	 * <adapter-id> is the instance number of the HBA.
+	 *
+	 * Scan for all luns on all ports. 
+	 */
+	if (!strncmp("ping", buffer + 8, 4)) {
+		printk("scsi-qla%ld: Pinging ..  \n",
+		    HBAptr->ha->host_no);
+	}
+
+	/*
+	    * Issue Mailbox Command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_PING;
+	mbox_cmd[1] = 20;
+	mbox_cmd[2] = (192 << 0) | (168 << 8) | (4 << 16) | (54 << 24);
+	if (qla4xxx_mailbox_command(to_qla_host(host), 3, 1,
+	    &mbox_cmd[0], &mbox_sts[0])
+	    == QLA_ERROR) {
+		printk("scsi%d: %s: unable to ping IP address\n",
+		    to_qla_host(host)->host_no, __func__);
+	} else
+		printk("scsi%d: %s: ping IP address OK!\n",
+		    to_qla_host(host)->host_no, __func__);
+out:
+#endif
+	return(-ENOSYS);  /* Currently this is a no-op */
+}
+
+
+/**************************************************************************
+ * qla4xxx_module_init
+ *    Module initialization.
+ **************************************************************************/
+static int __init
+qla4xxx_module_init(void)
+{
+	printk(KERN_INFO
+	    "QLogic iSCSI HBA Driver (%p)\n", qla4xxx_set_info);
+
+#if ISP_RESET_TEST
+	printk(KERN_INFO "qla4xxx: Adapter Reset Test Enabled!  "
+	       "Adapter Resets will be issued every 3 minutes!\n");
+#endif
+
+	switch (extended_error_logging) {
+	case 0:
+		// Default set in ql4print.c file
+		break;
+	case 1:
+		ql_dbg_level = QLP1|QLP2;
+		printk("qla4xxx: Extended Error Logging ENABLED\n");
+		break;
+	case 2:
+		ql_dbg_level = QLP1|QLP2|QLP4|QLP7|QLP12;
+		printk("qla4xxx: Debug Error Logging ENABLED\n");
+		break;
+	}
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	qla4xxx_ioctl_init();
+#endif
+
+	return pci_module_init(&qla4xxx_pci_driver);
+}
+
+/**************************************************************************
+ * qla4xxx_module_exit
+ *    Module cleanup.
+ **************************************************************************/
+static void __exit
+qla4xxx_module_exit(void)
+{
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	qla4xxx_ioctl_exit();
+#endif
+	pci_unregister_driver(&qla4xxx_pci_driver);
+}
+module_init(qla4xxx_module_init);
+module_exit(qla4xxx_module_exit);
+
+
+/**************************************************************************
+ * qla4xxx_probe_adapter
+ *    This routine will probe for Qlogic 4010 iSCSI host adapters.
+ *    It returns the number of host adapters of a particular
+ *    type that were found.  It also initializes all data necessary for
+ *    the driver.  It is passed-in the host number, so that it
+ *    knows where its first entry is in the scsi_hosts[] array.
+ *
+ * Input:
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int __devinit
+qla4xxx_probe_adapter(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct Scsi_Host *host;
+	scsi_qla_host_t *ha;
+	uint8_t status;
+	uint8_t init_retry_count = 0;
+
+	ENTER(__func__);
+
+	if (pci_enable_device(pdev))
+		return -1;
+
+	host = scsi_host_alloc(&qla4xxx_driver_template,
+	    sizeof(scsi_qla_host_t));
+	if (host == NULL) {
+		printk(KERN_WARNING
+		    "qla4xxx: Couldn't allocate host from scsi layer!\n");
+		goto probe_disable_device;
+	}
+
+	/* Clear our data area */
+	ha = (scsi_qla_host_t *)host->hostdata;
+	memset(ha, 0, sizeof(scsi_qla_host_t));
+
+	/* Save the information from PCI BIOS.  */
+	ha->pdev = pdev;
+	ha->host = host;
+	ha->host_no = host->host_no;
+	ha->instance = qla4xxx_hba_count;
+
+	/* Configure PCI I/O space. */
+	if (qla4xxx_iospace_config(ha) != QLA_SUCCESS)
+		goto probe_failed;
+
+	host->irq = pdev->irq;
+
+        ql4_printk(KERN_INFO, ha,
+	    "Found an ISP%04x, irq %d, iobase 0x%p\n", pdev->device, host->irq,
+	    ha->reg);
+
+	/* Configure OS DMA addressing method. */
+	qla4xxx_config_dma_addressing(ha);
+
+	/* Initialize lists and spinlocks. */
+	INIT_LIST_HEAD(&ha->ddb_list);
+	INIT_LIST_HEAD(&ha->pending_srb_q);
+	INIT_LIST_HEAD(&ha->retry_srb_q);
+	INIT_LIST_HEAD(&ha->done_srb_q);
+	INIT_LIST_HEAD(&ha->suspended_lun_q);
+	INIT_LIST_HEAD(&ha->free_srb_q);
+	INIT_LIST_HEAD(&ha->fcports);
+
+	init_MUTEX(&ha->mbox_sem);
+	init_waitqueue_head(&ha->mailbox_wait_queue);
+
+	spin_lock_init(&ha->hardware_lock);
+	spin_lock_init(&ha->adapter_lock);
+	spin_lock_init(&ha->list_lock);
+
+	ha->dpc_pid = -1;
+	init_completion(&ha->dpc_inited);
+	init_completion(&ha->dpc_exited);
+
+	/* Verify iSCSI PCI Funcion Number */
+	if (IS_QLA4010(ha)) {
+		ha->function_number = ISP4010_ISCSI_FUNCTION;
+	} else if (IS_QLA4022(ha)) {
+		spin_lock_irq(&ha->hardware_lock);
+		ha->function_number = (RD_REG_DWORD(&ha->reg->ctrl_status) &
+		    CSR_PCI_FUNC_NUM_MASK) >> 8;
+		spin_unlock_irq(&ha->hardware_lock);
+	}
+	if (PCI_FUNC(pdev->devfn) != ha->function_number) {
+		ql4_printk(KERN_WARNING, ha, "HA function number (0x%x) does "
+		    "not match PCI function number (0x%x)\n",
+		    ha->function_number, PCI_FUNC(pdev->devfn));
+
+		goto probe_failed;
+	}
+
+	/*
+	 * Allocate memory for dma buffers
+	 */
+	if (qla4xxx_mem_alloc(ha) == QLA_ERROR) {
+		ql4_printk(KERN_WARNING, ha,
+		    "[ERROR] Failed to allocate memory for adapter\n");
+
+		goto probe_failed;
+	}
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	INIT_LIST_HEAD(&ha->failover_queue);
+	init_MUTEX(&ha->ioctl->ioctl_sem);
+	init_MUTEX_LOCKED(&ha->ioctl->ioctl_cmpl_sem);
+#endif
+
+	/*
+	 * Initialize the Host adapter request/response queues and
+	 * firmware
+	 * NOTE: interrupts enabled upon successful completion
+	 */
+	status = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
+	while ((status == QLA_ERROR) &&
+	       test_bit(DPC_RESET_HA, &ha->dpc_flags) &&
+	       (init_retry_count++ < MAX_INIT_RETRIES)) {
+		QL4PRINT(QLP2, printk("scsi: %s: retrying adapter "
+		    "initialization (%d)\n", __func__, init_retry_count));
+
+		qla4xxx_soft_reset(ha);
+		status = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
+	}
+
+	if (status == QLA_ERROR) {
+		ql4_printk(KERN_WARNING, ha,"Failed to initialize adapter\n");
+
+		QL4PRINT(QLP2, printk(KERN_INFO
+		    "scsi: Failed to initialize adapter\n"));
+
+		goto probe_failed;
+	}
+
+	host->cmd_per_lun = 3;
+	host->io_port = ha->io_addr;
+	host->max_channel = QLA4XXX_BOARD_PORTS-1;
+	host->max_lun = MAX_LUNS-1;
+	host->max_id = MAX_TARGETS;
+	host->unique_id = ha->instance;
+	host->max_cmd_len = IOCB_MAX_CDB_LEN;
+	//FIXME	KH: What does 128 represent.  We shouldn't use hard-coded values.
+	host->can_queue = REQUEST_QUEUE_DEPTH + 128;
+
+	/* Startup the kernel thread for this host adapter. */
+	QL4PRINT(QLP7, printk("scsi: %s: Starting kernel thread for "
+	    "qla4xxx_dpc\n", __func__));
+	ha->dpc_should_die = 0;
+	ha->dpc_pid = kernel_thread(qla4xxx_do_dpc, ha, 0);
+	if (ha->dpc_pid < 0) {
+		ql4_printk(KERN_WARNING, ha, "Unable to start DPC thread!\n");
+
+		goto probe_failed;
+	}
+	wait_for_completion(&ha->dpc_inited);
+
+	/* Install the interrupt handler with the new ha */
+	if (request_irq(ha->pdev->irq, qla4xxx_intr_handler,
+	    SA_INTERRUPT|SA_SHIRQ, "qla4xxx", ha)) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Failed to reserve interrupt %d already in use.\n",
+		    host->irq);
+
+		goto probe_failed;
+	}
+	set_bit(AF_IRQ_ATTACHED, &ha->flags);
+	QL4PRINT(QLP7, printk("scsi%d: irq %d attached\n", ha->host_no,
+	    ha->pdev->irq));
+	qla4xxx_enable_intrs(ha);
+
+	/* Start timer thread. */
+	QL4PRINT(QLP7, printk("scsi: %s: Starting timer thread for adapter "
+	    "%d\n", __func__, ha->instance));
+	init_timer(&ha->timer);
+	ha->timer.expires = jiffies + HZ;
+	ha->timer.data = (unsigned long)ha;
+	ha->timer.function = (void (*)(unsigned long))qla4xxx_timer;
+	add_timer(&ha->timer);
+	ha->timer_active = 1;
+
+	/* Insert new entry into the list of adapters. */
+	write_lock(&qla4xxx_hostlist_lock);
+	list_add_tail(&ha->list, &qla4xxx_hostlist);
+	write_unlock(&qla4xxx_hostlist_lock);
+
+	//if (displayConfig)
+		qla4xxx_display_config();
+
+	set_bit(AF_INIT_DONE, &ha->flags);
+	qla4xxx_hba_count++;
+
+	pci_set_drvdata(pdev, ha);
+
+	if (scsi_add_host(host, &pdev->dev))
+		goto probe_failed;
+
+#ifdef	CONFIG_SCSI_QLA2XXX_FAILOVER
+	/*
+ 	 * if failover is enabled
+	 */
+	if (qla4xxx_failover_enabled(ha)) {
+		qla4xxx_cfg_init(ha);
+	}
+
+	printk(KERN_INFO
+	    " QLogic iSCSI HBA Driver version: %s-fo %c\n"
+	    "  QLogic ISP%04x @ %s hdma%c, host#=%d, fw=%02d.%02d.%02d.%02d\n",
+	    QLA4XXX_DRIVER_VERSION, 
+	    (qla4xxx_failover_enabled(ha)) ? '+': '-',
+	    ha->pdev->device, pci_name(ha->pdev),
+	    test_bit(AF_64BIT_PCI_ADDR, &ha->flags) ? '+': '-', ha->host_no,
+	    ha->firmware_version[0], ha->firmware_version[1], 
+	    ha->patch_number, ha->build_number);
+#else
+	printk(KERN_INFO
+	    " QLogic iSCSI HBA Driver version: %s\n"
+	    "  QLogic ISP%04x @ %s hdma%c, host#=%d, fw=%02d.%02d.%02d.%02d\n",
+	    QLA4XXX_DRIVER_VERSION, 
+	    ha->pdev->device, pci_name(ha->pdev),
+	    test_bit(AF_64BIT_PCI_ADDR, &ha->flags) ? '+': '-', ha->host_no,
+	    ha->firmware_version[0], ha->firmware_version[1], 
+	    ha->patch_number, ha->build_number);
+#endif
+	scsi_scan_host(host);
+
+	return 0;
+
+probe_failed:
+	qla4xxx_free_adapter(ha);
+
+probe_disable_device:
+	pci_disable_device(pdev);
+
+	return -1;
+}
+
+/**************************************************************************
+ * qla4xxx_remove_adapter
+ *
+ * Input:
+ *	pci_dev - PCI device pointer
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static void __devexit
+qla4xxx_remove_adapter(struct pci_dev *pdev)
+{
+	scsi_qla_host_t *ha;
+
+	ha = pci_get_drvdata(pdev);
+
+	write_lock(&qla4xxx_hostlist_lock);
+	list_del_init(&ha->list);
+	write_unlock(&qla4xxx_hostlist_lock);
+
+	scsi_remove_host(ha->host);
+
+	qla4xxx_free_adapter(ha);
+
+	scsi_host_put(ha->host);
+
+	pci_set_drvdata(pdev, NULL);
+}
+
+static void
+qla4xxx_free_adapter(scsi_qla_host_t *ha)
+{
+	int ret;
+	unsigned long flags;
+
+	ENTER(__func__);
+
+#if 0
+	/* Deregister with the iSNS Server */
+	if (test_bit(ISNS_FLAG_ISNS_SRV_REGISTERED, &ha->isns_flags)) {
+		u_long wait_cnt;
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: deregister iSNS\n",
+				      ha->host_no, __func__));
+		qla4xxx_isns_scn_dereg(ha);	      //FIXME: KRH
+		qla4xxx_isns_dev_dereg(ha);	      //FIXME: KRH
+
+		wait_cnt = jiffies + ISNS_DEREG_TOV * HZ;
+		while (wait_cnt > jiffies) {
+			if (test_bit(ISNS_FLAG_ISNS_SRV_REGISTERED,
+				     &ha->isns_flags) == 0)
+				break;
+			QL4PRINT(QLP7, printk("."));
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1 * HZ);
+		}
+	}
+#endif
+
+	if (test_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags)) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Stop iSNS service\n",
+		    ha->host_no, __func__));
+		qla4xxx_isns_disable(ha);
+	}
+
+	if (test_bit(AF_INTERRUPTS_ON, &ha->flags)) {
+		/* Turn-off interrupts on the card. */
+		qla4xxx_disable_intrs(ha);
+	}
+
+	/* Issue Soft Reset to put firmware in unknown state */
+	QL4PRINT(QLP7, printk("scsi%d: %s: Soft Reset\n", ha->host_no,
+	    __func__));
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SOFT_RESET));
+	PCI_POSTING(&ha->reg->ctrl_status);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Remove timer thread, if present */
+	if (ha->timer_active) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: Removing timer thread for "
+		    "adapter %d\n", ha->host_no, __func__, ha->instance));
+
+		del_timer_sync(&ha->timer);
+		ha->timer_active = 0;
+	}
+
+	/* Kill the kernel thread for this host */
+	if (ha->dpc_pid >= 0) {
+		ha->dpc_should_die = 1;
+		wmb();
+		ret = kill_proc(ha->dpc_pid, SIGHUP, 1);
+		if (ret) {
+			ql4_printk(KERN_ERR, ha,
+			    "Unable to signal DPC thread -- (%d)\n", ret);
+			
+			/* TODO: SOMETHING MORE??? */
+		} else
+			wait_for_completion(&ha->dpc_exited);
+	}
+
+	/* free extra memory */
+	qla4xxx_mem_free(ha);
+
+	/* Detach interrupts */
+	if (test_and_clear_bit(AF_IRQ_ATTACHED, &ha->flags))
+		free_irq(ha->pdev->irq, ha);
+
+	/* Free I/O Region */
+	if (ha->io_addr) {
+		release_region(ha->io_addr, ha->io_len);
+		ha->io_addr = 0;
+	}
+
+	pci_disable_device(ha->pdev);
+
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+ * qla4xxx_iospace_config
+ *    This routine
+ *
+ * Input:
+ *
+ * Returns:
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4xxx_iospace_config(scsi_qla_host_t *ha)
+{
+	int bar;
+
+	/* Search for I/O register. */
+	for (bar = 0; bar <= 5; bar++) {
+		unsigned long pci_base_address;
+
+		pci_base_address = pci_resource_start(ha->pdev, bar);
+		ha->pci_resource_flags = pci_resource_flags(ha->pdev, bar);
+
+#if MEMORY_MAPPED_IO
+		if (ha->pci_resource_flags & IORESOURCE_MEM) {
+			QL4PRINT(QLP7, printk("scsi%d: Assigned to Memory I/O "
+			    "0x%lx in PCI BAR%d\n", ha->host_no,
+			    pci_base_address, bar));
+
+			ha->mem_addr = pci_base_address;
+			ha->mem_len = pci_resource_len(ha->pdev, bar);
+			break;
+		}
+#else
+		if (ha->pci_resource_flags IORESOURCE_IO) {
+			QL4PRINT(QLP7, printk("scsi%d: Assigned to I/O Port "
+			    "0x%lx in PCI BAR%d\n", ha->host_no,
+			    pci_base_address, bar));
+
+			ha->io_addr = pci_base_address;
+			ha->io_len = pci_resource_len(ha->pdev, bar);
+			break;
+		}
+#endif
+	}
+
+	/* Map the Memory I/O register. */
+	if (ha->mem_addr) {
+		unsigned long  page_offset, base;
+
+		if (!request_mem_region(ha->mem_addr, ha->mem_len,
+		    DRIVER_NAME)) {
+			printk(KERN_WARNING
+			    "Could not allocate IO Memory space %lx len %ld.\n",
+			    ha->mem_addr, ha->mem_len);
+			return -1;
+		}
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: base memory address = "
+		    "0x%lx\n", ha->host_no, __func__, ha->mem_addr));
+
+		/* Find proper memory chunk for memory map I/O reg. */
+		base = ha->mem_addr & PAGE_MASK;
+		page_offset = ha->mem_addr - base;
+
+		/* Get virtual address for I/O registers. */
+		ha->virt_mmapbase = ioremap(base, page_offset +
+		    sizeof(*ha->reg));
+		if (ha->virt_mmapbase == NULL) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: I/O Remap Failed\n",
+			    ha->host_no, __func__));
+			return -1;
+		}
+
+		QL4PRINT(QLP7, printk("scsi%d: %s: virt memory_mapped_address "
+		    "= 0x%p\n", ha->host_no, __func__, ha->virt_mmapbase));
+
+		ha->reg = (isp_reg_t *)(ha->virt_mmapbase + page_offset);
+		QL4PRINT(QLP7, printk("scsi%d: %s: registers = 0x%p\n",
+		    ha->host_no, __func__, ha->reg));
+	}
+
+	if (ha->io_addr) {
+		if (!request_region(ha->io_addr, ha->io_len, DRIVER_NAME)) {
+			printk(KERN_WARNING
+			    "Could not allocate IO space %lx len %ld.\n",
+			    ha->io_addr, ha->io_len);
+
+			return -1;
+		}
+	}
+
+	return QLA_SUCCESS;
+}
+
+/**************************************************************************
+ * qla4xxx_display_config
+ *      This routine  displays the configuration information to be used in
+ *      modules.conf.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Output:
+ *      None
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+void
+qla4xxx_display_config(void)
+{
+	scsi_qla_host_t *ha, *htemp;
+
+	read_lock(&qla4xxx_hostlist_lock);
+	list_for_each_entry_safe(ha, htemp, &qla4xxx_hostlist, list) {
+		/* Display the M.A.C. Address for adapter */
+		printk(KERN_INFO
+		    "scsi-qla%d-mac=%02x%02x%02x%02x%02x%02x\\;\n",
+		    ha->instance,
+		    ha->my_mac[0], ha->my_mac[1], ha->my_mac[2],
+		    ha->my_mac[3], ha->my_mac[4], ha->my_mac[5]);
+	}
+	read_unlock(&qla4xxx_hostlist_lock);
+}
+
+/**************************************************************************
+ * qla4xxx_get_hba_count
+ *      This routine returns the number of host adapters present.
+ *
+ * Input:
+ *      None
+ *
+ * Returns:
+ *    qla4xxx_hba_count - Number of host adapters present.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint32_t
+qla4xxx_get_hba_count(void)
+{
+	return(qla4xxx_hba_count);
+}
+
+
+
+/****************************************************************************/
+/*  LINUX -  Loadable Module Functions.                                     */
+/****************************************************************************/
+
+/**
+ * qla4xxx_config_dma_addressing() - Configure OS DMA addressing method.
+ * @ha: HA context
+ *
+ * At exit, the @ha's flags.enable_64bit_addressing set to indicated
+ * supported addressing method.
+ */
+void
+qla4xxx_config_dma_addressing(scsi_qla_host_t *ha)
+{
+	/* Assume 32bit DMA address. */
+	clear_bit(AF_64BIT_PCI_ADDR, &ha->flags);
+
+	/*
+	 * Given the two variants pci_set_dma_mask(), allow the compiler to
+	 * assist in setting the proper dma mask.
+	 */
+	if (sizeof(dma_addr_t) > 4) {
+		/* Update our PCI device dma_mask for full 64 bit mask */
+		if (pci_set_dma_mask(ha->pdev, DMA_64BIT_MASK) == 0) {
+			set_bit(AF_64BIT_PCI_ADDR, &ha->flags);
+
+			if (pci_set_consistent_dma_mask(ha->pdev,
+			    DMA_64BIT_MASK)) {
+				ql4_printk(KERN_DEBUG, ha,
+				    "Failed to set 64 bit PCI consistent mask; "
+				    "using 32 bit.\n");
+
+				pci_set_consistent_dma_mask(ha->pdev,
+				    DMA_32BIT_MASK);
+			}
+		} else {
+			ql4_printk(KERN_DEBUG, ha,
+			    "Failed to set 64 bit PCI DMA mask, falling back "
+			    "to 32 bit MASK.\n");
+
+			pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK);
+		}
+	} else {
+		pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_alloc_srb_pool
+ *      This routine is called during driver initialization to allocate
+ *      memory for the local srb pool.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully allocated srbs
+ *      QLA_ERROR   - Failed to allocate any srbs
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_alloc_srb_pool(scsi_qla_host_t *ha)
+{
+	srb_t *srb;
+	int i;
+	uint8_t status = QLA_ERROR;
+	unsigned long flags;
+
+	ENTER("qla4xxx_alloc_srb_pool");
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	ha->num_srbs_allocated = 0;
+	ha->free_srb_q_count = 0; /* incremented in add_to_free_srb_q routine */
+
+	/*
+	 * NOTE: Need to allocate each SRB separately, as Kernel 2.4.4 seems to
+	 * have an error when allocating a large amount of memory.
+	 */
+	for (i=0; i < MAX_SRBS; i++) {
+		srb = (srb_t *) kmalloc(sizeof(srb_t), GFP_KERNEL);
+		if (srb == NULL) {
+			QL4PRINT(QLP2, printk(KERN_INFO
+			    "scsi%d: %s: failed to allocate memory, count = "
+			    "%d\n", ha->host_no, __func__, i));
+		} else {
+			ha->num_srbs_allocated++;
+			memset(srb, 0, sizeof(srb_t));
+			atomic_set(&srb->ref_count, 0);
+			__add_to_free_srb_q(ha, srb);
+		}
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	if (ha->free_srb_q_count)
+		status = QLA_SUCCESS;
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: Allocated %d SRB(s)\n",
+	    ha->host_no, __func__, ha->free_srb_q_count));
+
+	LEAVE("qla4xxx_alloc_srb_pool");
+
+	return (status);
+}
+
+/**************************************************************************
+ * qla4xxx_free_srb_pool
+ *      This routine is called during driver unload to deallocate the srb
+ *      pool.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_free_srb_pool(scsi_qla_host_t *ha)
+{
+	srb_t *srb, *stemp;
+	int cnt_free_srbs = 0;
+	unsigned long flags;
+
+	ENTER("qla4xxx_free_srb_pool");
+	spin_lock_irqsave(&ha->list_lock, flags);
+	list_for_each_entry_safe(srb, stemp, &ha->free_srb_q, list_entry) {
+		__del_from_free_srb_q(ha, srb);
+		kfree(srb);
+		cnt_free_srbs++;
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	if (cnt_free_srbs != ha->num_srbs_allocated) {
+		QL4PRINT(QLP2, printk(KERN_WARNING
+		    "scsi%d: Did not free all srbs, Free'd srb count = %d, "
+		    "Alloc'd srb count %d\n", ha->host_no, cnt_free_srbs,
+		    ha->num_srbs_allocated));
+	}
+
+	LEAVE("qla4xxx_free_srb_pool");
+}
+
+/**************************************************************************
+ * qla4xxx_mem_alloc
+ *      This routine allocates memory use by the adapter.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully allocated adapter memory
+ *      QLA_ERROR   - Failed to allocate adapter memory
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_mem_alloc(scsi_qla_host_t *ha)
+{
+	unsigned long	align;
+
+	ENTER("qla4xxx_mem_alloc");
+
+	/* Allocate contiguous block of DMA memory for queues. */
+	ha->queues_len = ((REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE) + sizeof(shadow_regs_t) +
+	    MEM_ALIGN_VALUE + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
+	ha->queues = pci_alloc_consistent(ha->pdev, ha->queues_len,
+	    &ha->queues_dma);
+	if (ha->queues == NULL) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - queues.\n");
+
+		goto mem_alloc_error_exit;
+	}
+	memset(ha->queues, 0, ha->queues_len);
+
+	/*
+	 * As per RISC alignment requirements -- the bus-address must be a
+	 * multiple of the request-ring size (in bytes).
+	 */
+	align = 0;
+	if ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1)) {
+		align = MEM_ALIGN_VALUE -
+		    ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1));
+	}
+
+	/* Update request and response queue pointers. */
+	ha->request_dma = ha->queues_dma + align;
+	ha->request_ring = (QUEUE_ENTRY *)(ha->queues + align);
+	ha->response_dma = ha->queues_dma + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE);
+	ha->response_ring = (QUEUE_ENTRY *)(ha->queues + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE));
+	ha->shadow_regs_dma = ha->queues_dma + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE);
+	ha->shadow_regs = (shadow_regs_t *)(ha->queues + align +
+	    (REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
+	    (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE));
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: queues 0x%lx (%p) %lx\n",
+	    ha->host_no, __func__, (unsigned long)ha->queues_dma,
+	    ha->queues, ha->queues_len));
+	QL4PRINT(QLP7, printk("scsi%d: %s: request ring 0x%lx (%p)\n",
+	    ha->host_no, __func__, (unsigned long)ha->request_dma,
+	    ha->request_ring));
+	QL4PRINT(QLP7, printk("scsi%d: %s: response ring 0x%lx (%p)\n",
+	    ha->host_no, __func__, (unsigned long)ha->response_dma,
+	    ha->response_ring));
+	QL4PRINT(QLP7, printk("scsi%d: %s: shadow regs 0x%lx (%p)\n",
+	    ha->host_no, __func__, (unsigned long)ha->shadow_regs_dma,
+	    ha->shadow_regs));
+
+	/* Allocate PDU Buffers
+	 * -------------------- */
+	ha->pdu_buff_size = MAX_PDU_ENTRIES*PAGE_SIZE;
+	ha->pdu_buffsv = pci_alloc_consistent(ha->pdev, ha->pdu_buff_size,
+	    &ha->pdu_buffsp);
+	if (ha->pdu_buffsv == NULL) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - PDU buffers.\n");
+
+		goto mem_alloc_error_exit;
+	}
+	memset(ha->pdu_buffsv, 0, MAX_PDU_ENTRIES*PAGE_SIZE);
+	ha->free_pdu_top = ha->pdu_buffsv;
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: PDU buffers 0x%lx (%p)\n",
+	    ha->host_no, __func__, (unsigned long)ha->pdu_buffsp,
+	    ha->pdu_buffsv));
+
+	/* Allocate iSNS Discovered Target Database
+	 * ---------------------------------------- */
+	ha->isns_disc_tgt_database_size = sizeof(ISNS_DISCOVERED_TARGET) *
+	    MAX_ISNS_DISCOVERED_TARGETS;
+	ha->isns_disc_tgt_databasev = pci_alloc_consistent(ha->pdev,
+	    ha->isns_disc_tgt_database_size, &ha->isns_disc_tgt_databasep);
+	if (ha->isns_disc_tgt_databasev == NULL) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - iSNS DB.\n");
+
+		goto mem_alloc_error_exit;
+	}
+	memset(ha->isns_disc_tgt_databasev, 0, ha->isns_disc_tgt_database_size);
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: iSNS DB 0x%ld (%p)\n", ha->host_no,
+	    __func__, (unsigned long)ha->isns_disc_tgt_databasep,
+	    ha->isns_disc_tgt_databasev));
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	if (qla4xxx_alloc_ioctl_mem(ha) != QLA_SUCCESS) {
+		ql4_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - IOCTL DMA buffer.\n");
+
+		goto mem_alloc_error_exit;
+	}
+#endif
+
+	/*
+	 * Allocate memory for srb pool
+	 *-----------------------------*/
+	if (qla4xxx_alloc_srb_pool(ha) == QLA_ERROR)
+		goto mem_alloc_error_exit;
+
+	LEAVE("qla4xxx_mem_alloc");
+
+	return (QLA_SUCCESS);
+
+mem_alloc_error_exit:
+	qla4xxx_mem_free(ha);
+	LEAVE("qla4xxx_mem_alloc");
+	return (QLA_ERROR);
+}
+
+/**************************************************************************
+ * qla4xxx_mem_free
+ *      This routine frees adapter allocated memory
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_mem_free(scsi_qla_host_t *ha)
+{
+	ENTER("qla4xxx_mem_free");
+
+	if (ha->queues) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free queues.\n", ha->host_no,
+		    __func__));
+
+		pci_free_consistent(ha->pdev, ha->queues_len, ha->queues,
+		    ha->queues_dma);
+	}
+	ha->queues_len = 0;
+	ha->queues = NULL;
+	ha->queues_dma = 0;
+	ha->request_ring = NULL;
+	ha->request_dma = 0;
+	ha->response_ring = NULL;
+	ha->response_dma = 0;
+	ha->shadow_regs = NULL;
+	ha->shadow_regs_dma = 0;
+
+	if (ha->pdu_buffsv) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free PDU buffers.\n",
+		    ha->host_no, __func__));
+
+		pci_free_consistent(ha->pdev, ha->pdu_buff_size,
+		    ha->pdu_buffsv, ha->pdu_buffsp);
+	}
+	ha->pdu_buffsv = 0;
+	ha->pdu_buffsp = 0;
+
+	if (ha->isns_disc_tgt_databasev) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free iSNS DB.\n",
+		    ha->host_no, __func__));
+
+		pci_free_consistent(ha->pdev, ha->isns_disc_tgt_database_size,
+		    ha->isns_disc_tgt_databasev, ha->isns_disc_tgt_databasep);
+	}
+	ha->isns_disc_tgt_database_size = 0;
+	ha->isns_disc_tgt_databasev = 0;
+	ha->isns_disc_tgt_databasep = 0;
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	qla4xxx_free_ioctl_mem(ha);
+#endif
+
+	/* Free srb pool */
+	if (ha->num_srbs_allocated) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free srb pool\n",
+		    ha->host_no, __func__));
+
+		qla4xxx_free_srb_pool(ha);
+	}
+
+	/* Free ddb list */
+	if (!list_empty(&ha->ddb_list)) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: free ddb list\n",
+		    ha->host_no, __func__));
+
+		qla4xxx_free_ddb_list(ha);
+	}
+
+	/* Unmap Memory Mapped I/O region */
+	if (ha->virt_mmapbase) {
+		QL4PRINT(QLP7, printk("scsi%d: %s: unmap mem io region\n",
+		    ha->host_no, __func__));
+
+		iounmap(ha->virt_mmapbase);
+		ha->virt_mmapbase = NULL;
+	}
+
+	if (ha->mem_addr)
+		release_mem_region(ha->mem_addr, ha->mem_len);
+	ha->mem_addr = 0;
+
+	qla4xxx_free_other_mem(ha);
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	if (qla4xxx_failover_enabled(ha))
+		qla4xxx_cfg_mem_free(ha);
+#endif
+
+	LEAVE("qla4xxx_mem_free");
+}
+
+
+/**************************************************************************
+* qla2xxx_slave_configure
+*
+* Description:
+**************************************************************************/
+int
+qla4xxx_slave_configure(struct scsi_device *sdev)
+{
+	scsi_qla_host_t *ha = to_qla_host(sdev->host);
+	int queue_depth;
+	os_tgt_t     *tgt_entry;
+	os_lun_t     *lun_entry;
+
+	queue_depth = 32;
+
+	/* Enable TCQ. */
+	if (sdev->tagged_supported) {
+		if (ql4xmaxqdepth != 0 && ql4xmaxqdepth <= 0xffffU)
+			queue_depth = ql4xmaxqdepth;
+
+		ql4xmaxqdepth = queue_depth;
+
+		scsi_activate_tcq(sdev, queue_depth);
+
+		ql4_printk(KERN_INFO, ha,
+		    "scsi(%d:%d:%d:%d): Enabled tagged queuing, queue "
+		    "depth %d.\n", sdev->host->host_no, sdev->channel,
+		    sdev->id, sdev->lun, sdev->queue_depth);
+	} else {
+		 scsi_adjust_queue_depth(sdev, 0 /* TCQ off */,
+		     sdev->host->hostt->cmd_per_lun /* 3 */);
+	}
+
+	/* Save misc. information. */
+	tgt_entry = qla4xxx_lookup_target_by_SCSIID(ha, sdev->channel,
+	    sdev->id);
+	if (tgt_entry != NULL) {
+		lun_entry = qla4xxx_lookup_lun_handle(ha, tgt_entry,
+		    sdev->lun);
+	        if (lun_entry != NULL) {
+			if (sdev->type == TYPE_TAPE) {
+				tgt_entry->fcport->flags |= FCF_TAPE_PRESENT;
+				lun_entry->fclun->flags |= FCF_TAPE_PRESENT;
+			}
+		}
+	}
+
+	return (0);
+}
+
+
+/*
+ * The following support functions are adopted to handle
+ * the re-entrant qla4xxx_proc_info correctly.
+ */
+static void
+copy_mem_info(struct info_str *info, char *data, int len)
+{
+	if (info->pos + len > info->offset + info->length)
+		len = info->offset + info->length - info->pos;
+
+	if (info->pos + len < info->offset) {
+		info->pos += len;
+		return;
+	}
+
+	if (info->pos < info->offset) {
+		off_t partial;
+
+		partial = info->offset - info->pos;
+		data += partial;
+		info->pos += partial;
+		len  -= partial;
+	}
+
+	if (len > 0) {
+		memcpy(info->buffer, data, len);
+		info->pos += len;
+		info->buffer += len;
+	}
+}
+
+static int
+copy_info(struct info_str *info, char *fmt, ...)
+{
+	va_list args;
+	static char buf[256];
+	int len;
+
+	va_start(args, fmt);
+	len = vsprintf(buf, fmt, args);
+	va_end(args);
+
+	copy_mem_info(info, buf, len);
+
+	return(len);
+}
+
+/**************************************************************************
+ * qla4xxx_proc_dump_srb_info
+ *      This routine displays srb information in the proc buffer.
+ *
+ * Input:
+ *      len - length of proc buffer prior to this function's execution.
+ *      srb - Pointer to srb to display.
+ *
+ * Remarks:
+ *      This routine is dependent on the DISPLAY_SRBS_IN_PROC #define being
+ *      set to 1.
+ *
+ * Returns:
+ *      len - length of proc buffer after this function's execution.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+inline void
+qla4xxx_proc_dump_srb_info(scsi_qla_host_t *ha, struct info_str *info, srb_t *srb)
+{
+	ddb_entry_t *ddb_entry;
+	os_lun_t *lun_entry;
+
+	ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, srb->fw_ddb_index);
+	lun_entry = srb->lun_queue;
+
+	copy_info(info, "srb %p", srb);
+
+	if (ddb_entry && lun_entry && srb->cmd) {
+		struct scsi_cmnd *cmd = srb->cmd;
+		//int i;
+
+		copy_info(info, ", b%d,t%d,l%d, SS=%d, DS=%d, LS=%d, "
+			  "r_start=%ld, u_start=%ld",
+			  cmd->device->channel, cmd->device->id,
+			  cmd->device->lun,
+			  srb->state,
+			  atomic_read(&ddb_entry->state),
+			  lun_entry->lun_state,
+			  srb->r_start,srb->u_start);
+
+		//copy_info(info, ", cdb=");
+		//for (i=0; i<cmd->cmd_len; i++)
+		//        copy_info(info, "%02X ", cmd->cmnd[i]);
+	}
+
+	copy_info(info, "\n");
+}
+
+/**************************************************************************
+ * qla4xxx_proc_dump_discovered_devices
+ *      This routine displays information for discovered devices in the proc
+ *      buffer.
+ *
+ * Input:
+ *      info - length of proc buffer prior to this function's execution.
+ *
+ * Remarks:
+ *      This routine is dependent on the DISPLAY_SRBS_IN_PROC #define being
+ *      set to 1.
+ *
+ * Returns:
+ *      info - length of proc buffer after this function's execution.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+inline void
+qla4xxx_proc_dump_discovered_devices(scsi_qla_host_t *ha, struct info_str *info)
+{
+	int i,j;
+
+	ENTER(__func__);
+
+	copy_info(info, "SCSI discovered device Information:\n");
+	copy_info(info, "Index: DID: NameString: Alias:\n");
+
+	for (i=0; i < ha->isns_num_discovered_targets; i++) {
+		ISNS_DISCOVERED_TARGET *isns_tgt =
+		&ha->isns_disc_tgt_databasev[i];
+
+		copy_info(info, "%2d: %4d:   %s: %s\n",
+			  i,
+			  isns_tgt->DDID,
+			  isns_tgt->NameString,
+			  isns_tgt->Alias);
+
+		for (j = 0; j < isns_tgt->NumPortals; j++) {
+			ISNS_DISCOVERED_TARGET_PORTAL *isns_portal =
+			&isns_tgt->Portal[j];
+
+			copy_info(info, "            Port %d: IP %d.%d.%d.%d\n",
+				  isns_portal->PortNumber,
+				  isns_portal->IPAddr[0],
+				  isns_portal->IPAddr[1],
+				  isns_portal->IPAddr[2],
+				  isns_portal->IPAddr[3]);
+		}
+	}
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+ * qla4xxx_proc_dump_scanned_devices
+ *      This routine displays information for scanned devices in the proc
+ *      buffer.
+ *
+ * Input:
+ *      info - length of proc buffer prior to this function's execution.
+ *
+ * Remarks:
+ *      This routine is dependent on the DISPLAY_SRBS_IN_PROC #define being
+ *      set to 1.
+ *
+ * Returns:
+ *      info - length of proc buffer after this function's execution.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+inline void
+qla4xxx_proc_dump_scanned_devices(scsi_qla_host_t *ha, struct info_str *info)
+{
+	os_lun_t        *up;
+	os_tgt_t	*tq;
+	ddb_entry_t     *ddb_entry;
+	fc_port_t	*fcport;
+	int             t, l, i;
+
+	ENTER(__func__);
+	/* 2.25 node/port display to proc */
+	/* Display the node name for adapter */
+	copy_info(info, "\nSCSI Device Information:\n");
+	copy_info(info,
+	    "scsi-qla%d-adapter-port=%s;\n",
+	    (int)ha->instance, ha->name_string);
+
+	for (t = 0; t < MAX_TARGETS; t++) {
+		if ((tq = TGT_Q(ha, t)) == NULL)
+			continue;
+		copy_info(info,
+		"scsi-qla%d-target-%d=%s;\n",
+		(int)ha->instance, t, tq->iscsi_name);
+	}
+
+	/* Print out device port names */
+	copy_info(info, "\nISCSI Port Information:\n");
+	i = 0;
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		if(fcport->port_type != FCT_TARGET)
+			continue;
+
+		ddb_entry = fcport->ddbptr;
+			
+		copy_info(info,
+	    	"scsi-qla%d-port-%d=\"%s\":%d.%d.%d.%d:0x%04x;\n",
+	    	(int)ha->instance, i, fcport->iscsi_name,
+			ddb_entry->ip_addr[0],
+			ddb_entry->ip_addr[1],
+			ddb_entry->ip_addr[2],
+			ddb_entry->ip_addr[3],
+			ddb_entry->fw_ddb_index);
+		i++;
+	} 
+
+	
+	//copy_info(info, "SCSI scanned device Information:\n");
+	copy_info(info, "\nSCSI LUN Information:\n");
+	copy_info(info, " (T : L) * - indicates lun is not registered with the OS.\n");
+
+	/* scan for all equipment stats */
+	for (t = 0; t < ha->host->max_id; t++) {
+		/* scan all luns */
+		for (l = 0; l < ha->host->max_lun; l++) {
+			up = (os_lun_t *) GET_LU_Q(ha, t, l);
+
+			if (up == NULL) {
+				continue;
+			}
+			if (up->fclun == NULL) {
+				continue;
+			}
+
+			if (up->fclun->fcport == NULL) {
+				continue;
+			}
+
+			ddb_entry = up->fclun->fcport->ddbptr;
+			copy_info(info,
+				  "(%2d:%2d): Total reqs %ld,",
+				  t,l,up->tot_io_count);
+
+			copy_info(info,
+				  " Active reqs %ld,",
+				  up->out_count);
+
+			copy_info(info, "states= %d:%d:%d ",
+				  atomic_read(&ddb_entry->state),
+				  up->lun_state,
+				  ddb_entry->fw_ddb_device_state);
+
+			if (up->tot_io_count < 4) {
+				copy_info(info,
+					  " flags 0x%lx*,",
+					  ddb_entry->flags);
+			}
+			else {
+				copy_info(info,
+					  " flags 0x%lx,",
+					  ddb_entry->flags);
+			}
+
+			copy_info(info,
+				  " %d:%d:%02x %02x",
+				  up->fclun->fcport->ha->instance,
+				  up->fclun->fcport->cur_path,
+				  ddb_entry->fw_ddb_index,
+				  up->fclun->device_type);
+
+			copy_info(info, "\n");
+
+			if (info->pos >= info->offset + info->length) {
+				/* No need to continue */
+				return;
+			}
+		}
+
+		if (info->pos >= info->offset + info->length) {
+			/* No need to continue */
+			break;
+		}
+	}
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+ * qla4xxx_proc_info
+ *      This routine return information to handle /proc support for the driver
+ *
+ * Input:
+ * Output:
+ *      inout  - Decides on the direction of the dataflow and the meaning of
+ *               the variables.
+ *      buffer - If inout==0 data is being written to it else read from
+ *               it (ptrs to a page buffer).
+ *      *start - If inout==0 start of the valid data in the buffer.
+ *      offset - If inout==0 offset from the beginning of the imaginary
+ *               file from which we start writing into the buffer.
+ *      length - If inout==0 max number of bytes to be written into the
+ *               buffer else number of bytes in the buffer.
+ *      hostno - Host number
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      Size of proc buffer.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
+    off_t offset, int length, int inout)
+{
+	int             retval = -EINVAL;
+	scsi_qla_host_t *ha = NULL;
+	struct info_str info;
+	unsigned long   flags;
+	srb_t *srb, *stemp;
+
+	QL4PRINT(QLP16, printk("scsi%d: Entering %s: buff_in=%p, "
+			       "offset=0x%lx, length=0x%x\n",
+			       shost->host_no, __func__, buffer, offset,
+			       length));
+
+	ha = (scsi_qla_host_t *) shost->hostdata;
+
+	if (inout) {
+		/* Has data been written to the file? */
+		QL4PRINT(QLP3, printk("scsi%d: %s: has data been written "
+				      "to the file. \n",
+				      ha->host_no, __func__));
+		return(qla4xxx_set_info(buffer, length, ha->host));
+	}
+
+	if (start) {
+		*start = buffer;
+	}
+
+	info.buffer = buffer;
+	info.length = length;
+	info.offset = offset;
+	info.pos    = 0;
+
+	/* start building the print buffer */
+	copy_info(&info, "QLogic iSCSI Adapter for ISP %s:\n",
+		  QLA4XXX_BOARD_ID_STRING);
+	copy_info(&info, "Driver version %s\n", QLA4XXX_DRIVER_VERSION);
+	copy_info(&info, "Code starts at address = %p\n", qla4xxx_set_info);
+	copy_info(&info, "Firmware version %2d.%02d.%02d.%02d\n",
+		  ha->firmware_version[0], ha->firmware_version[1],
+		  ha->patch_number, ha->build_number);
+	copy_info(&info, "SCSI Host Adapter Information: %s\n",
+		  QLA4XXX_BOARD_NAME_STRING);
+
+#if 0
+	copy_info(&info, "MEDIA TYPE - %s\n",
+	    ((ha->addl_fw_state & FW_ADDSTATE_OPTICAL_MEDIA) !=
+	    0) ? "OPTICAL" : "COPPER");
+#endif
+
+	if (ha->mem_addr)
+		copy_info(&info, "Memory I/O = 0x%lx\n", ha->mem_addr);
+	else
+		copy_info(&info, "I/O Port = 0x%lx\n", ha->io_addr);
+
+	copy_info(&info, "IP Address = %d.%d.%d.%d\n",
+		  ha->ip_address[0], ha->ip_address[1],
+		  ha->ip_address[2], ha->ip_address[3]);
+
+	if (ha->tcp_options & TOPT_ISNS_ENABLE) {
+		copy_info(&info, "iSNS IP Address = %d.%d.%d.%d\n",
+			  ha->isns_ip_address[0], ha->isns_ip_address[1],
+			  ha->isns_ip_address[2], ha->isns_ip_address[3]);
+		copy_info(&info, "iSNS Server Port# = %d\n",
+			  ha->isns_server_port_number);
+	}
+//FIXME: print both BUS (%llx) and virtual address (%p).
+#if 0
+	copy_info(&info, "ReqQ DMA= 0x%lx, virt= 0x%p, depth= 0x%x\n",
+		  (unsigned long)ha->request_dma, ha->request_ring, REQUEST_QUEUE_DEPTH);
+	copy_info(&info, "ComplQ DMA= 0x%lx, virt= 0x%p, depth= 0x%x\n",
+		  (unsigned long)ha->response_dma, ha->response_ring, RESPONSE_QUEUE_DEPTH);
+	copy_info(&info, "Shadow Regs DMA= 0x%lx, virt= 0x%p, size (bytes) = 0x%x\n",
+		  (unsigned long)ha->shadow_regs_dma, ha->shadow_regs, sizeof(shadow_regs_t));
+	copy_info(&info, "PDU Buffer Addr= 0x%x, size (bytes) = 0x%x\n",
+		  ha->pdu_buffsv, ha->pdu_buff_size);
+					
+	copy_info(&info, "Discovered Target Database Addr = 0x%x, size (bytes) = 0x%x\n",
+		  ha->isns_disc_tgt_databasev,
+		  sizeof(ha->isns_disc_tgt_databasev));
+#endif
+	copy_info(&info, "Number of free request entries  = %d of %d\n",
+		  ha->req_q_count, REQUEST_QUEUE_DEPTH);
+	copy_info(&info, "Number of free aen entries    = %d of %d\n",
+		  ha->aen_q_count, MAX_AEN_ENTRIES);
+	copy_info(&info, "Number of Mailbox Timeouts = %d\n",
+		  ha->mailbox_timeout_count);
+#if 0
+	copy_info(&info, "Total H/W int = 0x%lx\n",
+		  (unsigned long)ha->isr_count);
+	copy_info(&info, "Total RISC int = 0x%lx\n",
+		  (unsigned long)ha->total_io_count);
+	copy_info(&info, "Number of Spurious interrupts = %d\n",
+		  ha->spurious_int_count);
+	copy_info(&info, "Seconds since last Interrupt = %d\n",
+		  ha->seconds_since_last_intr);
+#endif
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	copy_info(&info, "Interrupt Status = %d\n",
+		  RD_REG_DWORD(&ha->reg->ctrl_status));
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	
+	copy_info(&info, "ReqQptr=%p, ReqIn=%d, ReqOut=%d\n",
+		  ha->request_ptr, ha->request_in, ha->request_out);
+	copy_info(&info, "Device queue depth = 0x%x\n",
+		  (ql4xmaxqdepth == 0) ? 16 : ql4xmaxqdepth);
+	copy_info(&info, "Adapter flags = 0x%x, DPC flags = 0x%x\n",
+		  ha->flags, ha->dpc_flags);
+	copy_info(&info, "Number of commands in pending_srb_q = %d\n",
+		  ha->pending_srb_q_count);
+
+	if (((ql_dbg_level & QLP16) != 0) && (ha->pending_srb_q_count)) {
+		copy_info(&info, "\nDump pending_srb_q:\n");
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_entry_safe(srb, stemp, &ha->pending_srb_q,
+		    list_entry)
+			qla4xxx_proc_dump_srb_info(ha, &info, srb);
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		copy_info(&info, "\n");
+	}
+
+	copy_info(&info, "Number of commands in retry_srb_q = %d\n",
+		  ha->retry_srb_q_count);
+
+	if (((ql_dbg_level & QLP16) != 0) && (ha->retry_srb_q_count)) {
+		copy_info(&info, "\nDump retry_srb_q:\n");
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_entry_safe(srb, stemp, &ha->retry_srb_q,
+		    list_entry)
+			qla4xxx_proc_dump_srb_info(ha, &info, srb);
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		copy_info(&info, "\n");
+	}
+
+	copy_info(&info, "Number of commands in done_srb_q = %d\n",
+		  ha->done_srb_q_count);
+
+	if (((ql_dbg_level & QLP16) != 0) && (ha->done_srb_q_count)) {
+		copy_info(&info, "\nDump done_srb_q:\n");
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_entry_safe(srb, stemp, &ha->done_srb_q,
+		    list_entry)
+			qla4xxx_proc_dump_srb_info(ha, &info, srb);
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		copy_info(&info, "\n");
+	}
+
+	if (qla4xxx_failover_enabled(ha)) {
+		copy_info(&info,
+		    "Number of reqs in failover_q= %d\n",
+		    ha->failover_cnt);
+	}
+	
+	copy_info(&info, "Dpc flags = 0x%lx\n", ha->dpc_flags);
+
+	copy_info(&info, "Number of active commands = %d\n",
+		  ha->active_srb_count);
+
+	if (((ql_dbg_level & QLP16) != 0) && (ha->active_srb_count)) {
+		int i;
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		copy_info(&info, "\nDump active commands:\n");
+		for (i = 1; i < MAX_SRBS; i++) {
+			srb_t *srb = ha->active_srb_array[i];
+			if (srb)
+				qla4xxx_proc_dump_srb_info(ha, &info, srb);
+		}
+		copy_info(&info, "\n");
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+
+	copy_info(&info, "Total number of IOCBs (used/max) "
+		  "= (%d/%d)\n", ha->iocb_cnt, ha->iocb_hiwat);
+	copy_info(&info, "Number of free srbs    = %d of %d\n",
+		  ha->free_srb_q_count, ha->num_srbs_allocated);
+	copy_info(&info, "\n");
+
+	qla4xxx_proc_dump_scanned_devices(ha, &info);
+	copy_info(&info, "\n");
+
+	if (test_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags))
+		qla4xxx_proc_dump_discovered_devices(ha, &info);
+
+	copy_info(&info, "\0");
+
+	retval = info.pos > info.offset ? info.pos - info.offset : 0;
+
+	QL4PRINT(QLP16, printk("scsi%d: Exiting %s: info.pos=%d, "
+			       "offset=0x%lx, length=0x%x\n",
+			       ha->host_no, __func__, info.pos, offset, length));
+
+	return(retval);
+}
+
+//XXX failover only
+/**************************************************************************
+ * qla4xxx_get_adapter_handle
+ *      This routine returns the adapter handle that corresponds to the
+ *      specified instance number.
+ *
+ * Input:
+ *      instance - Instance number of the desired host adapter.
+ *
+ * Returns:
+ *      Pointer to host adapter structure
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+scsi_qla_host_t *
+qla4xxx_get_adapter_handle(uint16_t instance)
+{
+	scsi_qla_host_t *ha, *htemp;
+
+	read_lock(&qla4xxx_hostlist_lock);
+	list_for_each_entry_safe(ha, htemp, &qla4xxx_hostlist, list) {
+		if (ha->instance != instance)
+			continue;
+
+		QL4PRINT(QLP3, printk("scsi%d: %s: handle (%p) for instance "
+		    "%d\n", ha->host_no, __func__, ha, instance));
+
+		read_unlock(&qla4xxx_hostlist_lock);
+		
+		return (ha);
+	}
+	read_unlock(&qla4xxx_hostlist_lock);
+
+	QL4PRINT(QLP2, printk("scsi: %s: instance %d not found\n", __func__,
+	    instance));
+
+	return NULL;
+}
+
+/**************************************************************************
+ * add_to_active_array
+ *      This routine adds an srb to the active array at the specified index.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      index - index into to the active_array
+ *      srb - Pointer to SCSI Request Block
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+void
+add_to_active_array(scsi_qla_host_t *ha, uint32_t index, srb_t *srb)
+{
+	ddb_entry_t *ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, srb->fw_ddb_index);
+	os_lun_t *lun_entry = srb->lun_queue;
+
+	/* put command in active array */
+	ha->active_srb_array[index] = srb;
+	srb->cmd->host_scribble = (unsigned char *)(unsigned long)index;
+
+	/* update counters */
+	ha->active_srb_count++;
+	ha->req_q_count -= srb->entry_count;
+	if (ddb_entry) ddb_entry->out_count++;
+	if (lun_entry) {
+		lun_entry->out_count++;
+		lun_entry->tot_io_count++;
+	}
+	srb->active_array_index = index;
+	srb->state = SRB_ACTIVE_STATE;
+}
+
+/**************************************************************************
+ * del_from_active_array
+ *      This routine removes and returns the srb at the specified index
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      index - index into to the active_array
+ *
+ * Returns:
+ *      Pointer to corresponding SCSI Request Block
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+srb_t *
+del_from_active_array(scsi_qla_host_t *ha, uint32_t index)
+{
+	srb_t *srb = NULL;
+
+	/* validate handle and remove from active array */
+	if (index < MAX_SRBS) {
+		srb = ha->active_srb_array[index];
+		ha->active_srb_array[index] = 0;
+
+		if (srb) {
+			// ddb_entry_t *ddb_entry =
+			// qla4xxx_lookup_ddb_by_fw_index(ha,
+			// srb->fw_ddb_index);
+			os_lun_t *lun_entry = srb->lun_queue;
+
+			/* update counters */
+			ha->req_q_count += srb->entry_count;
+			ha->iocb_cnt -= srb->iocb_cnt;
+			if (ha->active_srb_count)
+				ha->active_srb_count--;
+			// if (ddb_entry) ddb_entry->out_count--;
+			if (lun_entry)
+				lun_entry->out_count--;
+			/* FIXMEdg: Is this needed ???? */
+			srb->active_array_index = INVALID_ENTRY;
+			if (srb->cmd)
+				srb->cmd->host_scribble = NULL;
+		}
+		else
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: %s: array_index=%d "
+					"already completed.\n",
+					ha->host_no, __func__, index));
+	}
+	else
+		QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: %s: array_index=%d "
+				      "exceeded max index of %d\n",
+				      ha->host_no, __func__, index, MAX_SRBS));
+
+	return(srb);
+}
+
+inline uint8_t
+qla4xxx_alloc_cont_entry(scsi_qla_host_t *ha,
+			 DATA_SEG_A64 **cur_dsd,
+			 uint16_t *avail_dsds)
+{
+	CONTINUE_ENTRY *cont_entry;
+	ENTER("qla4xxx_alloc_cont_entry");
+
+	/* Get request queue entry and adjust ring index. */
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &cont_entry) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Unable to allocate "
+				      "continuation packet\n",
+				      ha->host_no, __func__));
+
+		LEAVE("qla4xxx_alloc_cont_entry");
+		return(QLA_ERROR);
+	}
+
+	cont_entry->hdr.entryType = ET_CONTINUE;
+	cont_entry->hdr.entryCount = 1;
+	cont_entry->hdr.systemDefined =
+	(uint8_t) cpu_to_le16(ha->request_in);
+	*cur_dsd = (DATA_SEG_A64 *) &cont_entry->dataseg[0];
+	*avail_dsds = CONTINUE_SEG;
+
+	LEAVE("qla4xxx_alloc_cont_entry");
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4xxx_send_command_to_isp
+ *      This routine is called by qla4xxx_queuecommand to build an ISP
+ *      command and pass it to the ISP for execution.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      srb - pointer to SCSI Request Block to be sent to ISP
+ *
+ * Output:
+ *      None
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully sent command to ISP
+ *      QLA_ERROR   - Failed to send command to ISP
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_send_command_to_isp(scsi_qla_host_t *os_ha, srb_t *srb)
+{
+	struct scsi_cmnd     *cmd = srb->cmd;
+	ddb_entry_t   *ddb_entry;
+	os_lun_t   *lun_entry;
+	COMMAND_ENTRY *cmd_entry;
+	uint16_t      saved_request_in;
+	QUEUE_ENTRY   *saved_request_ptr;
+
+	uint16_t avail_dsds;
+	DATA_SEG_A64 *cur_dsd;
+	uint16_t      tot_dsds;	/* number of data segments */
+				/* (sg entries, if sg request) */
+
+	uint8_t       tot_iocbs;/* number of request queue entries */
+				/* (commamd + continue) */
+	unsigned long flags;
+	uint16_t      i;
+	uint32_t      index;
+	uint8_t       found = 0;
+	fc_lun_t                *fclun;
+	scsi_qla_host_t *ha;
+	char		tag[2];
+
+	ENTER("qla4xxx_send_command_to_isp");
+
+	/* Get real lun and adapter */
+	fclun = srb->lun_queue->fclun;
+	ha = fclun->fcport->ha;
+
+	/* FIXME: Where are we checking the iocb count? The f/w can only accept
+	 * a max number of IOCB and mailbox commands.
+	 */
+	cmd = srb->cmd;
+	ddb_entry = fclun->fcport->ddbptr;
+	lun_entry = srb->lun_queue;
+
+	/* Send marker(s) if needed. */
+	if (ha->marker_needed == 1) {
+		if (qla4xxx_send_marker_iocb(ha, ddb_entry, fclun) !=
+		    QLA_SUCCESS) {
+			return(QLA_ERROR);
+		}
+	}
+	ha->marker_needed = 0;
+
+	/* Acquire hardware specific lock */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Save some variables to undo things if an error occurs */
+	saved_request_in  = ha->request_in;
+	saved_request_ptr = ha->request_ptr;
+
+	tot_dsds = 0;
+	tot_iocbs = 1;
+	avail_dsds = COMMAND_SEG;
+
+	/* Get request queue entry and adjust ring index. */
+	if (qla4xxx_get_req_pkt(ha, (QUEUE_ENTRY **) &cmd_entry) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d:%d:%d:%d: %s: request queue is "
+		    "full, try again later\n", ha->host_no,
+		    cmd->device->channel, cmd->device->id, cmd->device->lun,
+		    __func__));
+
+		goto exit_send_cmd;
+	}
+
+	/* Check for room in active srb array */
+	index = ha->current_active_index;
+	for (i = 0; i < MAX_SRBS; i++) {
+		index++;
+		if (index == MAX_SRBS)
+			index = 1;
+		if (ha->active_srb_array[index] == 0) {
+			found = 1;
+			ha->current_active_index = index;
+			break;
+		}
+	}
+	if (!found) {
+		QL4PRINT(QLP2, printk("scsi%d:%d:%d:%d: %s: no room in active "
+		    "array, try again later\n", ha->host_no,
+		    cmd->device->channel, cmd->device->id, cmd->device->lun,
+		    __func__));
+
+		goto exit_send_cmd_return_request;
+	}
+
+	/* Build command entry packet to send to ISP. */
+	/* If in connection mode, bump sequence number */
+	if ((ha->firmware_options & FWOPT_SESSION_MODE) != 0)
+		ddb_entry->CmdSn++;
+
+	cmd_entry->hdr.entryType = ET_COMMAND;
+	cmd_entry->handle = cpu_to_le32(index);
+	cmd_entry->target = cpu_to_le16(ddb_entry->fw_ddb_index);
+	cmd_entry->connection_id = cpu_to_le16(ddb_entry->connection_id);
+	cmd_entry->lun[1] = LSB(cmd->device->lun);	/* SAMII compliant. */
+	cmd_entry->lun[2] = MSB(cmd->device->lun);
+	cmd_entry->cmdSeqNum = cpu_to_le32(ddb_entry->CmdSn);
+	cmd_entry->ttlByteCnt = cpu_to_le32(cmd->request_bufflen);
+	memcpy(cmd_entry->cdb, cmd->cmnd, MIN(MAX_COMMAND_SIZE, cmd->cmd_len));
+
+	/* Set firmware timeout to [target_mgmt_timeout + IOCB_TOV_MARGIN]
+	 * seconds less than OS timeout.
+	 * We want the firmware to time out the command first */
+	cmd_entry->timeout = (cmd->timeout_per_command / HZ);
+	if (cmd_entry->timeout > ddb_entry->task_mgmt_timeout + IOCB_TOV_MARGIN)
+		cmd_entry->timeout -=
+		    (ddb_entry->task_mgmt_timeout + IOCB_TOV_MARGIN);
+	cmd_entry->timeout = cpu_to_le16(cmd_entry->timeout);
+
+	srb->iocb_tov = cmd_entry->timeout;
+	srb->os_tov = cmd->timeout_per_command / HZ;
+
+	QL4PRINT(QLP10, printk("scsi%d:%d:%d:%d: %s: timeout set to %d "
+	    "seconds, \n", ha->host_no, cmd->device->channel, cmd->device->id,
+	    cmd->device->lun, __func__, cmd_entry->timeout));
+
+	/* Set data transfer direction control flags
+	 * NOTE: Look at data_direction bits iff there is data to be
+	 *       transferred, as the data direction bit is sometimed filled
+	 *       in when there is no data to be transferred */
+	cmd_entry->control_flags = CF_NO_DATA;
+	if (cmd->request_bufflen) {
+		if (cmd->sc_data_direction == DMA_TO_DEVICE)
+			cmd_entry->control_flags = CF_WRITE;
+		else if (cmd->sc_data_direction == DMA_FROM_DEVICE)
+			cmd_entry->control_flags = CF_READ;
+	}
+
+	/* Set tagged queueing control flags */
+	cmd_entry->control_flags |= CF_SIMPLE_TAG;
+	if (scsi_populate_tag_msg(cmd, tag)) {
+		switch (tag[0]) {
+		case MSG_HEAD_TAG:
+			cmd_entry->control_flags |= CF_HEAD_TAG;
+			break;
+		case MSG_ORDERED_TAG:
+			cmd_entry->control_flags |= CF_ORDERED_TAG;
+			break;
+		}
+	}
+
+	/* Set data segments and byte counts */
+	cur_dsd = (DATA_SEG_A64 *) &(cmd_entry->dataseg[0]);
+	if (cmd->request_bufflen == 0 ||
+	    cmd->sc_data_direction == DMA_NONE) {
+		/* No data being transferred */
+		QL4PRINT(QLP5, printk("scsi%d:%d:%d:%d: %s: No data xfer\n",
+		    ha->host_no, cmd->device->channel, cmd->device->id,
+		    cmd->device->lun, __func__));
+
+		tot_dsds = 0;
+		cmd_entry->ttlByteCnt = __constant_cpu_to_le32(0);
+	} else if (cmd->use_sg) {
+		struct  scatterlist *cur_seg;
+		struct  scatterlist *end_seg;
+		int     nseg;
+
+		/* Data transfer with Scatter/Gather
+		 *
+		 * We must build an SG list in adapter format, as the kernel's
+		 * SG list cannot be used directly because of data field size
+		 * (__alpha__) differences and the kernel SG list uses virtual
+		 * addresses where we need physical addresses.
+		 */
+		cur_seg = (struct scatterlist *) cmd->request_buffer;
+		nseg = pci_map_sg(ha->pdev, cur_seg, cmd->use_sg,
+		    cmd->sc_data_direction);
+		if (nseg == 0)
+			goto exit_send_cmd;
+		end_seg = cur_seg + nseg;
+
+		while (cur_seg < end_seg) {
+			dma_addr_t sle_dma;
+
+			/* Allocate additional continuation packets? */
+			if (avail_dsds == 0) {
+				tot_iocbs++;
+				if (qla4xxx_alloc_cont_entry(ha, &cur_dsd,
+				    &avail_dsds) == QLA_ERROR) {
+					QL4PRINT(QLP2,
+					    printk("scsi%d:%d:%d:%d: %s: "
+						    "request queue full, "
+						    "unmap sg, try again "
+						    "later\n", ha->host_no,
+						    cmd->device->channel,
+						    cmd->device->id,
+						    cmd->device->lun,
+						    __func__));
+
+					goto exit_send_cmd_return_dma;
+				}
+			}
+
+			sle_dma = sg_dma_address(cur_seg);
+			cur_dsd->base.addrLow = cpu_to_le32(LSDW(sle_dma));
+			cur_dsd->base.addrHigh = cpu_to_le32(MSDW(sle_dma));
+			cur_dsd->count = cpu_to_le32(sg_dma_len(cur_seg));
+			tot_dsds++;
+			avail_dsds--;
+
+			QL4PRINT(QLP5|QLP24, printk("scsi%d:%d:%d:%d: %s: S/G "
+			    "DSD %p phys_addr=%x:%08x, len=0x%x, tot_dsd=0x%x, "
+			    "avail_dsd=0x%x\n", ha->host_no,
+			    cmd->device->channel, cmd->device->id,
+			    cmd->device->lun, __func__, cur_dsd,
+			    cur_dsd->base.addrHigh, cur_dsd->base.addrLow,
+			    cur_dsd->count, tot_dsds, avail_dsds));
+
+			cur_dsd++;
+			cur_seg++;
+		}
+	} else {
+		/* Data transfer without SG entries. */
+		dma_addr_t	req_dma;
+		struct page	*page;
+		unsigned long	offset;
+
+		page = virt_to_page(cmd->request_buffer);
+		offset = ((unsigned long) cmd->request_buffer & ~PAGE_MASK);
+		req_dma = pci_map_page(ha->pdev, page, offset,
+		    cmd->request_bufflen, cmd->sc_data_direction);
+		srb->saved_dma_handle = req_dma;
+		if (!srb->saved_dma_handle) {
+			QL4PRINT(QLP2, printk("scsi%d:%d:%d:%d: %s: pci "
+			    "mapping failed!, try again later\n", ha->host_no,
+			    cmd->device->channel, cmd->device->id,
+			    cmd->device->lun, __func__));
+
+			goto exit_send_cmd_return_dma;
+		}
+
+		cur_dsd->base.addrLow = cpu_to_le32(LSDW(req_dma));
+		cur_dsd->base.addrHigh = cpu_to_le32(MSDW(req_dma));
+		cur_dsd->count = cpu_to_le32(cmd->request_bufflen);
+		tot_dsds++;
+		avail_dsds--;
+
+		QL4PRINT(QLP5, printk("scsi%d:%d:%d:%d: %s: No S/G transfer, "
+		    "DSD=%p cmd=%p dma_addr=%x:%08x, len=%x, tot_dsd=0x%x, "
+		    "avail_dsd=0x%x\n", ha->host_no, cmd->device->channel,
+		    cmd->device->id, cmd->device->lun, __func__, cur_dsd, cmd,
+		    cur_dsd->base.addrHigh, cur_dsd->base.addrLow,
+		    cur_dsd->count, tot_dsds, avail_dsds));
+
+		cur_dsd++;
+	}
+
+	cmd_entry->dataSegCnt = cpu_to_le16(tot_dsds);
+	cmd_entry->hdr.entryCount = srb->entry_count = tot_iocbs;
+	wmb();
+
+	/* put command in active array */
+	ha->active_srb_array[index] = srb;
+	srb->cmd->host_scribble = (unsigned char *)(unsigned long)index;
+
+	/* update counters */
+	ha->active_srb_count++;
+	ha->req_q_count -= srb->entry_count;
+	ddb_entry->out_count++;
+	lun_entry->out_count++;
+	lun_entry->tot_io_count++;
+	srb->active_array_index = index;
+	srb->state = SRB_ACTIVE_STATE;
+	srb->flags |= SRB_DMA_VALID;
+
+	/* Track IOCB used */
+	ha->iocb_cnt += tot_iocbs;
+	srb->iocb_cnt = tot_iocbs;
+
+	/* Debug print statements */
+#ifdef QL_DEBUG_LEVEL_3
+	QL4PRINT(QLP14, printk("scsi%d:%d:%d:%d: %s: CDB = ", ha->host_no,
+	    cmd->device->channel, cmd->device->target, cmd->device->lun,
+	    __func__));
+	for (i = 0; i < cmd->cmd_len; i++)
+		QL4PRINT(QLP14, printk("%02x ", cmd->cmnd[i]));
+	QL4PRINT(QLP14, printk("\n"));
+
+	QL4PRINT(QLP5, printk("scsi%d: %s: srb=%p, srb->index=0x%x, "
+			      "cmd_entry->handle=0x%x "
+			      "tot_dsds=%d, tot_iocbs=%d\n",
+			      ha->host_no, __func__, srb,
+			      srb->active_array_index,
+			      cmd_entry->handle,
+			      tot_dsds, tot_iocbs));
+
+	QL4PRINT(QLP10|QLP24, printk("scsi%d: %s: cmd_entry 0x%p\n",
+				     ha->host_no, __func__, cmd_entry));
+	qla4xxx_dump_bytes(QLP10|QLP24, cmd_entry, sizeof(*cmd_entry));
+
+	for (i=1; i<=tot_iocbs-1; i++) {
+		CONTINUE_ENTRY *cont_entry = (CONTINUE_ENTRY *) cmd_entry+i;
+		QL4PRINT(QLP10|QLP24,
+			 printk("\nscsi%d: %s: cont_entry 0x%p\n",
+				ha->host_no, __func__, cont_entry));
+		qla4xxx_dump_bytes(QLP10|QLP24,
+				   cont_entry, sizeof(*cont_entry));
+	}
+
+	/* Tell ISP that there's a new request */
+	QL4PRINT(QLP5, printk("scsi%d: %s: RequestQueueIn %x\n",
+			      ha->host_no, __func__, ha->request_in));
+#endif
+
+	srb->u_start = jiffies;
+	ha->f_start = srb->u_start;
+	WRT_REG_DWORD(&ha->reg->req_q_in, ha->request_in);
+	PCI_POSTING(&ha->reg->req_q_in);
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_send_command_to_isp");
+
+	return(QLA_SUCCESS);
+
+exit_send_cmd_return_dma:
+	/* Unmap srb dma buffer */
+	pci_unmap_sg(ha->pdev, (struct scatterlist *)cmd->request_buffer,
+	    cmd->use_sg, cmd->sc_data_direction);
+
+exit_send_cmd_return_request:
+	/* restore request queue in pointers */
+	ha->request_in = saved_request_in;
+	ha->request_ptr = saved_request_ptr;
+
+exit_send_cmd:
+	/* Release hardware specific lock */
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE("qla4xxx_send_command_to_isp");
+
+	return(QLA_ERROR);
+}
+
+static inline void
+qla4xxx_delete_from_done_queue(scsi_qla_host_t *dest_ha, srb_t *sp)
+{
+	/* remove command from done list */
+	list_del_init(&sp->list_entry);
+	sp->state = SRB_NO_QUEUE_STATE;
+
+	if (sp->flags & SRB_DMA_VALID) {
+		sp->flags &= ~SRB_DMA_VALID;
+
+		/* Release memory used for this I/O */
+		if (sp->cmd->use_sg) {
+			pci_unmap_sg(dest_ha->pdev, sp->cmd->request_buffer,
+			    sp->cmd->use_sg, sp->cmd->sc_data_direction);
+		} else if (sp->cmd->request_bufflen) {
+			pci_unmap_page(dest_ha->pdev, sp->saved_dma_handle,
+			    sp->cmd->request_bufflen,
+			    sp->cmd->sc_data_direction);
+		}
+	}
+}
+
+/**************************************************************************
+* qla4xxx_done
+*      Process completed commands.
+*
+* Input:
+*      old_ha           = adapter block pointer.
+*
+* Returns:
+* int
+**************************************************************************/
+int
+qla4xxx_done(scsi_qla_host_t *old_ha)
+{
+	os_lun_t        *lq;
+	struct scsi_cmnd       *cmd;
+	unsigned long   flags = 0;
+	scsi_qla_host_t *ha;
+	scsi_qla_host_t *vis_ha;
+	int             cnt;
+	srb_t           *srb, *stemp;
+	struct  list_head local_sp_list;
+
+	ENTER(__func__);
+
+	cnt = 0;
+
+	INIT_LIST_HEAD(&local_sp_list);
+
+	/*
+	 * Get into local queue such that we do not wind up calling done queue
+	 * takslet for the same IOs from DPC or any other place.
+	 */
+	spin_lock_irqsave(&old_ha->list_lock,flags);
+	list_splice_init(&old_ha->done_srb_q, &local_sp_list);
+	spin_unlock_irqrestore(&old_ha->list_lock, flags);
+
+	list_for_each_entry_safe(srb, stemp, &local_sp_list, list_entry) {
+		old_ha->done_srb_q_count--;
+		srb->state = SRB_NO_QUEUE_STATE;
+		list_del_init(&srb->list_entry);
+
+		cnt++;
+
+		cmd = srb->cmd;
+		if (cmd == NULL) {
+#if  0
+			panic("qla4xxx_done: SP %p already freed - %s %d.\n",
+			      srb, __FILE__,__LINE__);
+#else
+			continue;
+#endif
+		}
+
+		vis_ha = (scsi_qla_host_t *)cmd->device->host->hostdata;
+		lq = srb->lun_queue;
+		ha = srb->ha;
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+		if (!(srb->flags & (SRB_TAPE)) &&
+		    qla4xxx_failover_enabled(ha)) {
+			/*
+			 * This routine checks for DID_NO_CONNECT to decide
+			 * whether to failover to another path or not. We only
+			 * failover on selection timeout(DID_NO_CONNECT) status.
+			 */
+			if (!(lq->fclun->fcport->flags &
+			    FCF_FAILOVER_DISABLE) &&
+			    !(lq->fclun->flags & FLF_VISIBLE_LUN) &&
+			    qla4xxx_fo_check(ha,srb)) {
+				if ((srb->state != SRB_FAILOVER_STATE)) {
+					/*
+					 * Retry the command on this path
+					 * several times before selecting a new
+					 * path.
+					 */
+					add_to_pending_srb_q_head(vis_ha, srb);
+					qla4xxx_start_io(vis_ha);
+				}
+				else {
+					/* we failover this path */
+					qla4xxx_extend_timeout(srb->cmd,
+							       EXTEND_CMD_TOV);
+				}
+				continue;
+			}
+
+		}
+#endif
+		qla4xxx_complete_request(vis_ha, srb);
+
+	} /* end of while */
+
+	LEAVE(__func__);
+
+	return(cnt);
+}
+
+/**************************************************************************
+ * qla4xxx_complete_request
+ *      This routine returns a command to the caller via the done_fn
+ *      specified in the cmd structure.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      srb - Pointer to SCSI Request Block
+ *
+ * Remarks:
+ *    The srb pointer should be guaranteed to be nonzero before calling
+ *    this function.  The caller should also ensure that the list_lock is
+ *    released before calling this function.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully completed request
+ *      QLA_ERROR   - Failed to complete request
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+uint8_t
+qla4xxx_complete_request(scsi_qla_host_t *ha, srb_t *srb)
+{
+	uint8_t status = QLA_ERROR;
+	struct scsi_cmnd *cmd;
+	unsigned long flags;
+
+	//ENTER("qla4xxx_complete_request");
+	/* Make sure the cmd pointer is valid */
+	if (srb == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: ERROR: NULL srb \n",
+				      ha->host_no, __func__));
+		goto exit_complete_request;
+	}
+	/* FIXMEdg: Why do we need this check?? */
+	if ((srb->flags & SRB_FREE_STATE) == 0)
+		qla4xxx_delete_timer_from_cmd(srb);
+
+	cmd = srb->cmd;
+	if (cmd == NULL) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: ERROR: NULL cmd pointer in "
+				"srb=%p\n", ha->host_no, __func__, srb));
+
+		goto exit_complete_request;
+	}
+
+	/* FIXMEdg:  */
+	/*  Let abort handler know we are completing the command */
+	CMD_SP(cmd) = NULL;
+
+	/* Release memory used for this I/O */
+	if ((srb->flags & SRB_DMA_VALID) != 0) {
+		srb->flags &= ~SRB_DMA_VALID;
+
+		/* Release memory used for this I/O */
+		if (cmd->use_sg) {
+			QL4PRINT(QLP5,
+				 printk("scsi%d: %s: S/G unmap_sg cmd=%p\n",
+					ha->host_no, __func__, cmd));
+
+			pci_unmap_sg(ha->pdev,
+				     cmd->request_buffer,
+				     cmd->use_sg,
+				     cmd->sc_data_direction);
+		}
+		else if (cmd->request_bufflen) {
+			QL4PRINT(QLP5,
+				 printk("scsi%d: %s: No S/G unmap_single "
+					"cmd=%p saved_dma_handle=%x\n",
+					ha->host_no, __func__, cmd,
+					(uint32_t) srb->saved_dma_handle));
+
+			pci_unmap_page(ha->pdev,
+				       srb->saved_dma_handle,
+				       cmd->request_bufflen,
+				       srb->cmd->sc_data_direction);
+		}
+
+		ha->total_mbytes_xferred += cmd->request_bufflen / 1024;
+	}
+
+	if (host_byte(cmd->result) == DID_OK) {
+		if (!(srb->flags & SRB_GOT_SENSE)) {
+			os_lun_t *lun_entry = srb->lun_queue;
+
+			if (lun_entry) {
+				/*
+				 * If lun was not ready (suspended or timeout)
+				 * then change state to "READY".
+				 */
+				spin_lock_irqsave(&lun_entry->lun_lock, flags);
+				if (lun_entry->lun_state != LS_LUN_READY) {
+					lun_entry->lun_state = LS_LUN_READY;
+				}
+				spin_unlock_irqrestore(&lun_entry->lun_lock, flags);
+			}
+		}
+	}
+
+	#ifdef DEBUG
+	/* debug prints */
+	// qla4xxx_dump_command(ha, cmd);
+
+	#endif
+
+	/*
+	 * WORKAROUND
+	 * A backdoor device-reset (via eh_resets) requires different
+	 * error handling.  This code differentiates between normal
+	 * error handling and the backdoor method
+	 */
+	if (host_byte(cmd->result) == DID_RESET) {
+		#define EH_ACTIVE 1
+		if (ha->host->eh_active != EH_ACTIVE)
+			srb->cmd->result = DID_BUS_BUSY << 16;
+	}
+
+#ifdef QL_DEBUG_LEVEL_3
+	if (cmd->result & 0xff) {
+		QL4PRINT(QLP13,
+			 printk("REQUEST_SENSE data:  "
+				"(MAX 0x20 bytes displayed)\n"));
+
+		qla4xxx_dump_bytes(QLP13, cmd->sense_buffer,
+				   MIN(0x20, sizeof(cmd->sense_buffer)));
+	}
+
+	if (host_byte(cmd->result) == DID_RESET ||
+	    host_byte(cmd->result) == DID_BUS_BUSY ||
+	    host_byte(cmd->result) == DID_ABORT ||
+	    host_byte(cmd->result) == DID_ERROR) {
+		QL4PRINT(QLP2,
+			 printk("scsi%d:%d:%d:%d: %s: cmd=%p sp=%p "
+				"didstat=%X comp=%x scsistat=(%x), "
+				"host_failed=%d, to=%ds\n",
+				ha->host_no, cmd->device->channel, cmd->device->target,
+				cmd->lun, __func__, cmd, srb,
+				host_byte(cmd->result), srb->cc_stat,
+				CMD_SCSI_STATUS(cmd) & 0xff,
+				cmd->host->host_failed, cmd->timeout_per_command/HZ));
+	}
+#endif
+
+	/* Call the mid-level driver interrupt handler */
+	srb->cmd = NULL;
+	add_to_free_srb_q(ha, srb);
+
+	QL4PRINT(QLP5, printk("scsi%d: %s: request completed w/ result "
+			      "hoststat=%X scsistat=(%x)\n",
+			      ha->host_no, __func__,
+			      host_byte(cmd->result),
+			      CMD_SCSI_STATUS(cmd) & 0xff));
+
+
+	// CMD_SP(cmd) = NULL;
+	(*(cmd)->scsi_done)(cmd);
+
+	exit_complete_request:
+	//LEAVE("qla4xxx_complete_request");
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_queuecommand
+ *      This routine is invoked by Linux to send a SCSI command to the driver.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *      done_fn - Function that the driver calls to notify the SCSI mid-layer
+ *                that the command has been processed.
+ *
+ * Remarks:
+ *    The mid-level driver tries to ensure that queuecommand never gets
+ *    invoked concurrently with itself or the interrupt handler (although
+ *    the interrupt handler may call this routine as part of request-
+ *    completion handling).   Unfortunely, it sometimes calls the scheduler
+ *    in interrupt context which is a big NO! NO!.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_queuecommand(struct scsi_cmnd *cmd, void (*done_fn)(struct scsi_cmnd *))
+{
+	scsi_qla_host_t *ha;
+	ddb_entry_t     *ddb_entry;
+	os_lun_t     *lun_entry;
+	os_tgt_t     *tgt_entry;
+	uint32_t        b, t, l;
+	int             return_status = 0;
+	srb_t           *srb;
+	fc_port_t       *fcport;
+	fc_lun_t       *fclun;
+
+	b = cmd->device->channel;
+	t = cmd->device->id;
+	l = cmd->device->lun;
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	spin_unlock_irq(ha->host->host_lock);
+
+	/*
+	 * Retrieve srb from pool.  If no srb available, Notify the OS to queue
+	 * commands in the OS.  The OS will not attempt to queue more commands
+	 * until a command is returned to the OS.
+	 */
+	srb = del_from_free_srb_q_head(ha);
+	if (srb == NULL) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: srb not available, retry "
+		    "later\n", ha->host_no, __func__));
+
+		return_status = 1;
+
+		spin_lock_irq(ha->host->host_lock);
+
+		return (return_status);
+	}
+
+	/* Link the srb with cmd */
+	CMD_SP(cmd) = (char *)srb;
+	cmd->scsi_done = done_fn;
+	srb->cmd = cmd;
+	srb->r_start = jiffies;	/*Time we recieved the I/O*/
+	srb->flags = 0;
+
+	srb->fo_retry_cnt = 0;
+
+	srb->err_id = 0;
+	if ((cmd->timeout_per_command/HZ) > QLA_CMD_TIMER_DELTA)
+		qla4xxx_add_timer_to_cmd(srb, (cmd->timeout_per_command / HZ) -
+		    QLA_CMD_TIMER_DELTA);
+	else
+		qla4xxx_add_timer_to_cmd(srb, (cmd->timeout_per_command / HZ));
+
+	/* Extend the command timeout value because the iscsi enviornment
+	 * command needs more time to complete.  Otherwise, commands start
+	 * timing out frequently causing device resets.
+	 */
+	qla4xxx_extend_timeout(srb->cmd, (ql4xcmdtimeout-1)*EXTEND_CMD_TOV);
+
+	/* retrieve device and lun handles */
+	tgt_entry = qla4xxx_lookup_target_by_SCSIID(ha, b, t);
+	if (tgt_entry ==  NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+		goto exit_qc_call_done;
+	}
+	
+	lun_entry = qla4xxx_lookup_lun_handle(ha, tgt_entry, l);
+	if (lun_entry == NULL) {
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+		if (qla4xxx_failover_enabled(ha) ||
+			tgt_entry->fcport == NULL ) {
+			cmd->result = DID_NO_CONNECT << 16;
+			goto exit_qc_call_done;
+		}
+#else
+		if (tgt_entry->fcport == NULL) {
+			cmd->result = DID_NO_CONNECT << 16;
+			goto exit_qc_call_done;
+		}
+#endif
+		/*
+		 * Allocate a LUN queue for this request if we haven't
+		 * already did it on a previous command.
+		 */
+		fcport = tgt_entry->fcport;
+		fclun = qla4xxx_add_fclun(fcport, l);
+		if (fclun == NULL) {
+			DEBUG2(printk("%s: Can't get FCLUN queue.\n",
+			    __func__);)
+			cmd->result = DID_ERROR << 16;
+			goto exit_qc_call_done;
+		}
+		
+		/* Assume this type right now and fixup after command completes */
+		fclun->device_type = TYPE_DISK;
+		lun_entry = qla4xxx_fclun_bind(ha, fcport, fclun);
+	}
+
+	/* failover */
+	srb->tgt_queue = tgt_entry;
+	srb->lun_queue = lun_entry;
+	srb->fclun = lun_entry->fclun;
+	if (lun_entry->fclun == NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+//XXX
+printk("scsi%d: sp=%ld -- lq=%p lq->fclun == NULL\n",
+    ha->host_no, srb->cmd->serial_number, lun_entry);
+		goto exit_qc_call_done;
+	}
+	fcport = lun_entry->fclun->fcport;
+	if (fcport ==  NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+//XXX
+printk("scsi%d: sp=%ld -- lq=%p lq->fclun=%p lq->fclun->fcport == NULL\n",
+    ha->host_no, srb->cmd->serial_number, lun_entry, lun_entry->fclun);
+		goto exit_qc_call_done;
+	}
+
+	ddb_entry = fcport->ddbptr;
+	if (ddb_entry ==  NULL) {
+		cmd->result = DID_NO_CONNECT << 16;
+//XXX
+printk("scsi%d: sp=%ld -- ddbe=%p fcport->ddbptr == NULL\n",
+    ha->host_no, srb->cmd->serial_number, ddb_entry);
+		goto exit_qc_call_done;
+	}
+	srb->ha = fcport->ha;
+
+	/* Only modify the allowed count if the target is a *non* tape device */
+	if ((fcport->flags & FCF_TAPE_PRESENT) == 0 &&
+	    cmd->allowed < ql4xcmdretrycount)
+		cmd->allowed = ql4xcmdretrycount;
+	
+	/* Final pre-check :
+	 *	Either PORT_DOWN_TIMER OR LINK_DOWN_TIMER Expired.
+	 */
+	if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD) {
+		/*
+		 * Add the command to the done-queue for later failover
+		 * processing.
+		 */
+		if (!test_bit(AF_LINK_UP, &fcport->ha->flags))
+			srb->err_id = SRB_ERR_LOOP;
+		else
+			srb->err_id = SRB_ERR_PORT;
+//XXX
+printk("scsi%d: sp=%ld -- errid=%d fcport=%p fcport is dead\n",
+    ha->host_no, srb->cmd->serial_number, srb->err_id, fcport);
+		cmd->result = DID_NO_CONNECT << 16;
+		add_to_done_srb_q(ha, srb);
+		qla4xxx_done(ha);
+		spin_lock_irq(ha->host->host_lock);
+		return 0;
+	}
+
+
+	/* Prepare the srb with ddb index */
+	// srb->fw_ddb_index = fcport->ddbptr->fw_ddb_index;
+	// srb->lun = l;
+
+	/* FIXME: Add target suspended logic here and Device dead exit */
+
+	/* Print debug information */
+	QL4PRINT(QLP5, printk("scsi%d: %s: b%d, t%d ,l%d, ",
+			      ha->host_no, __func__, b, t, l));
+	QL4PRINT(QLP5, printk("cdb = "));
+	QL4PRINT(QLP5, printk("%02X %02X %02X %02X %02X %02X %02X %02X "
+			      "%02X %02X\n",
+			      cmd->cmnd[0], cmd->cmnd[1], cmd->cmnd[2],
+			      cmd->cmnd[3], cmd->cmnd[4], cmd->cmnd[5],
+			      cmd->cmnd[6], cmd->cmnd[7], cmd->cmnd[8],
+			      cmd->cmnd[9]));
+
+	QL4PRINT(QLP5, printk("scsi%d: %s: device state = 0x%x\n",
+			      ha->host_no, __func__,
+			      atomic_read(&ddb_entry->state)));
+
+        if (tgt_entry && test_bit(TQF_SUSPENDED, &tgt_entry->flags) &&
+	    (srb->flags & SRB_TAPE) == 0) {
+		/* If target suspended put incoming I/O in retry_q. */
+		qla4xxx_extend_timeout(srb->cmd, 10);
+		add_to_retry_srb_q(ha, srb);
+	} else
+		add_to_pending_srb_q(ha, srb);
+
+	/* FIXME: Add affinity changes here */
+	qla4xxx_start_io(ha);
+
+	spin_lock_irq(ha->host->host_lock);
+	return(return_status);
+
+exit_qc_call_done:
+	qla4xxx_complete_request(ha, srb);
+
+	spin_lock_irq(ha->host->host_lock);
+	return(return_status);
+}
+
+/**************************************************************************
+ * qla4xxx_extend_timeout
+ *      This routine will extend the timeout to the specified value.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *      timeout - Amount of time to extend the OS timeout
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_extend_timeout(struct scsi_cmnd *cmd, int timeout)
+{
+	srb_t *srb = (srb_t *) CMD_SP(cmd);
+	u_long our_jiffies = (timeout * HZ) + jiffies;
+
+	if (cmd->eh_timeout.function) {
+		mod_timer(&cmd->eh_timeout,our_jiffies);
+	}
+	if (srb->timer.function != NULL) {
+		/*
+		 * Our internal timer should timeout before the midlayer has a
+		 * chance begin the abort process
+		 */
+		mod_timer(&srb->timer,
+			  our_jiffies - (QLA_CMD_TIMER_DELTA * HZ));
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_start_io
+ *      This routine retrieves and processes next request from the pending
+ *      queue.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_start_io(scsi_qla_host_t *ha)
+{
+	ddb_entry_t     *ddb_entry;
+	os_lun_t     *lun_entry;
+	srb_t           *srb;
+	fc_port_t               *fcport;
+	unsigned long   flags;
+
+	ENTER("qla4xxx_start_io");
+	spin_lock_irqsave(&ha->list_lock, flags);
+	while (!list_empty(&ha->pending_srb_q)) {
+		srb = list_entry(ha->pending_srb_q.next, srb_t, list_entry);
+
+
+		__del_from_pending_srb_q(ha, srb);
+
+		lun_entry = srb->lun_queue;
+		fcport = lun_entry->fclun->fcport;
+		ddb_entry = fcport->ddbptr;
+
+		/* If device is dead or has gone away,
+		 * send request back to OS */
+		/* FIXME: What about testing the AF_LINK_UP status for the LINK ??? */
+		if ((atomic_read(&ddb_entry->state) == DEV_STATE_DEAD)) {
+			if (!test_bit(AF_LINK_UP, &fcport->ha->flags))
+				srb->err_id = SRB_ERR_LOOP;
+			else
+				srb->err_id = SRB_ERR_PORT;
+
+			DEBUG2(printk("scsi%d: Port dead, err_id=%d, sp=%ld - "
+			    "retry_q\n", fcport->ha->host_no,srb->err_id,
+			    srb->cmd->serial_number));
+
+			srb->cmd->result = DID_NO_CONNECT << 16;
+			__add_to_done_srb_q(ha, srb);
+			continue;
+		}
+
+		/*
+		 * If the device is missing or the adapter is OFFLINE,
+		 * put the request on the retry queue.
+		 */
+		if (atomic_read(&ddb_entry->state) == DEV_STATE_MISSING ||
+		    !ADAPTER_UP(fcport->ha)) {
+			DEBUG2(printk("scsi%d: Port missing or adapter down"
+			    "-ddb state=0x%x, hba flags=0x%lx, sp=%ld - "
+			    "retry_q\n", fcport->ha->host_no,
+			    atomic_read(&ddb_entry->state),
+			    fcport->ha->flags, srb->cmd->serial_number));
+
+			qla4xxx_extend_timeout(srb->cmd, EXTEND_CMD_TOV);
+			__add_to_retry_srb_q(ha, srb);
+			continue;
+		}
+
+		if (!(srb->flags & SRB_TAPE) &&
+		    (test_bit(CFG_FAILOVER, &fcport->ha->cfg_flags) ||
+		     (srb->flags & SRB_FAILOVER))) {
+			DEBUG2(printk("scsi%d: Failover flag set - sp=%ld"
+			    "cfg flags=0x%lx - retry_q\n",
+			    fcport->ha->host_no, srb->cmd->serial_number,
+			    fcport->ha->cfg_flags ));
+
+			qla4xxx_extend_timeout(srb->cmd, EXTEND_CMD_TOV);
+			__add_to_retry_srb_q(ha, srb);
+			continue;
+		}
+
+		/*
+		 * If this request's lun is suspended then put the request on
+		 * the  scsi_retry queue.
+		 */
+		if (lun_entry->lun_state == LS_LUN_SUSPENDED) {
+			DEBUG2(printk("scsi%d: Lun suspended - sp=%ld - "
+			    "retry_q\n", fcport->ha->host_no,
+			    srb->cmd->serial_number));
+
+			__add_to_retry_srb_q(ha, srb);
+			continue;
+		}
+
+
+		/* Release target queue lock */
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		if (qla4xxx_send_command_to_isp(ha, srb) != QLA_SUCCESS) {
+			/*
+			 * Unable to send command to the ISP at this time.
+			 * Notify the OS to queue commands in the OS.  The OS
+			 * will not attempt to queue more commands until a
+			 * command is returned to the OS.
+			 */
+			QL4PRINT(QLP2, printk("scsi%d: %s: unable to send cmd "
+			    "to ISP, retry later\n", ha->host_no, __func__));
+
+			add_to_pending_srb_q_head(ha, srb);
+			goto  exit_start_io;
+		}
+		spin_lock_irqsave(&ha->list_lock, flags);
+
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+exit_start_io:
+	LEAVE("qla4xxx_start_io");
+}
+
+/**************************************************************************
+ * qla4xxx_os_cmd_timeout
+ *
+ * Description:
+ *       Handles the command if it times out in any state.
+ *
+ * Input:
+ *     sp - pointer to validate
+ *
+ * Returns:
+ * None.
+ * Note:Need to add the support for if( sp->state == SRB_FAILOVER_STATE).
+ **************************************************************************/
+void
+qla4xxx_os_cmd_timeout(srb_t *sp)
+{
+	int t, l;
+	int processed;
+	scsi_qla_host_t *vis_ha, *dest_ha;
+	struct scsi_cmnd *cmd;
+	ulong      flags;
+	ulong      cpu_flags;
+	fc_port_t       *fcport;
+
+	cmd = sp->cmd;
+	vis_ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	DEBUG3(printk("cmd_timeout: Entering sp->state = %x\n", sp->state);)
+
+	t = cmd->device->id;
+	l = cmd->device->lun;
+	fcport = sp->fclun->fcport;
+	dest_ha = sp->ha;
+
+	/*
+	 * If IO is found either in retry Queue
+	 *    OR in Lun Queue
+	 * Return this IO back to host
+	 */
+	spin_lock_irqsave(&vis_ha->list_lock, flags);
+	processed = 0;
+	if (sp->state == SRB_PENDING_STATE) {
+		__del_from_pending_srb_q(vis_ha, sp);
+		DEBUG2(printk(KERN_INFO "scsi%d: Found in Pending queue "
+			      "pid %ld, State = %x., "
+			      "fcport state=%d jiffies=%lx\n",
+			      vis_ha->host_no,
+			      sp->cmd->serial_number, sp->state,
+			      atomic_read(&fcport->state),
+			      jiffies);)
+
+		/*
+		 * If FC_DEVICE is marked as dead return the cmd with
+		 * DID_NO_CONNECT status.  Otherwise set the host_byte to
+		 * DID_BUS_BUSY to let the OS  retry this cmd.
+		 */
+		if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD) {
+			cmd->result = DID_NO_CONNECT << 16;
+			if (!test_bit(AF_LINK_UP, &fcport->ha->flags))
+				sp->err_id = SRB_ERR_LOOP;
+			else
+				sp->err_id = SRB_ERR_PORT;
+		}
+		else {
+			cmd->result = DID_BUS_BUSY << 16;
+		}
+		__add_to_done_srb_q(vis_ha, sp);
+		processed++;
+	}
+	spin_unlock_irqrestore(&vis_ha->list_lock, flags);
+	if (processed) {
+		qla4xxx_done(vis_ha);
+		return;
+	}
+
+	spin_lock_irqsave(&dest_ha->list_lock, flags);
+	if ((sp->state == SRB_RETRY_STATE)  ||
+	    /* (sp->state == SRB_SCSI_RETRY_STATE)  || */
+	    (sp->state == SRB_FAILOVER_STATE)) {
+
+		DEBUG2(printk(KERN_INFO "scsi%d: Found in (Scsi) Retry queue or "
+			      "failover Q pid %ld, State = %x., "
+			      "fcport state=%d jiffies=%lx retried=%d\n",
+			      dest_ha->host_no,
+			      sp->cmd->serial_number, sp->state,
+			      atomic_read(&fcport->state),
+			      jiffies, sp->cmd->retries);)
+
+		if ((sp->state == SRB_RETRY_STATE)) {
+			__del_from_retry_srb_q(dest_ha, sp);
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+		}
+		else if ((sp->state == SRB_FAILOVER_STATE)) {
+			__del_from_failover_queue(dest_ha, sp);
+#endif
+		}
+
+		/*
+		 * If FC_DEVICE is marked as dead return the cmd with
+		 * DID_NO_CONNECT status.  Otherwise set the host_byte to
+		 * DID_BUS_BUSY to let the OS  retry this cmd.
+		 */
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+		if (qla4xxx_failover_enabled(dest_ha)) {
+			cmd->result = DID_BUS_BUSY << 16;
+		}
+		else
+#endif
+		{
+			if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD) {
+				qla4xxx_extend_timeout(cmd, EXTEND_CMD_TOV);
+				cmd->result = DID_NO_CONNECT << 16;
+				if (!test_bit(AF_LINK_UP, &fcport->ha->flags))
+					sp->err_id = SRB_ERR_LOOP;
+				else
+					sp->err_id = SRB_ERR_PORT;
+			}
+			else {
+				cmd->result = DID_BUS_BUSY << 16;
+			}
+		}
+
+		__add_to_done_srb_q(dest_ha, sp);
+		processed++;
+	}
+	spin_unlock_irqrestore(&dest_ha->list_lock, flags);
+	if (processed) {
+		qla4xxx_done(dest_ha);
+		return;
+	}
+
+	spin_lock_irqsave(&dest_ha->list_lock, cpu_flags);
+	if (sp->state == SRB_DONE_STATE) {
+		/* IO in done_q  -- leave it */
+		DEBUG2(printk("scsi%d: Found in Done queue pid %ld sp=%p.\n",
+			      dest_ha->host_no, sp->cmd->serial_number, sp);)
+	}
+	else if (sp->state == SRB_SUSPENDED_STATE) {
+		DEBUG2(printk("scsi%d: Found SP %p in suspended state  "
+			      "- pid %ld:\n",
+			      dest_ha->host_no,sp,
+			      sp->cmd->serial_number);)
+	}
+	else if (sp->state == SRB_ACTIVE_STATE) {
+		/*
+		 * IO is with ISP find the command in our active list.
+		 */
+		spin_unlock_irqrestore(&dest_ha->list_lock, cpu_flags);	/* 01/03 */
+		spin_lock_irqsave(&dest_ha->hardware_lock, flags);
+		if (sp == dest_ha->active_srb_array
+		    [(unsigned long)sp->cmd->host_scribble]) {
+
+			if (sp->flags & SRB_TAPE) {
+				/*
+				 * We cannot allow the midlayer error handler
+				 * to wakeup and begin the abort process.
+				 * Extend the timer so that the firmware can
+				 * properly return the IOCB.
+				 */
+				DEBUG2(printk("cmd_timeout: Extending timeout "
+					      "of FCP2 tape command!\n"));
+				qla4xxx_extend_timeout(sp->cmd,
+						       EXTEND_CMD_TOV);
+			}
+
+			sp->state = SRB_ACTIVE_TIMEOUT_STATE;
+			spin_unlock_irqrestore(&dest_ha->hardware_lock, flags);
+		}
+		else {
+			spin_unlock_irqrestore(&dest_ha->hardware_lock, flags);
+			printk(KERN_INFO
+			       "qla_cmd_timeout: State indicates it is with "
+			       "ISP, But not in active array\n");
+		}
+		spin_lock_irqsave(&dest_ha->list_lock, cpu_flags);	/* 01/03 */
+	}
+	else if (sp->state == SRB_ACTIVE_TIMEOUT_STATE) {
+		/* double timeout */
+	}
+	else {
+		/* EMPTY */
+		DEBUG3(printk("cmd_timeout%ld: LOST command state = "
+			      "0x%x, sp=%p\n",
+			      vis_ha->host_no, sp->state,sp);)
+
+		printk(KERN_INFO
+		       "cmd_timeout: LOST command state = 0x%x\n", sp->state);
+	}
+	spin_unlock_irqrestore(&dest_ha->list_lock, cpu_flags);
+
+	DEBUG3(printk("cmd_timeout: Leaving\n");)
+}
+
+
+/**************************************************************************
+ * qla4xxx_add_timer_to_cmd
+ *      This routine creates a timer for the specified command. The timeout
+ *      is usually the command time from kernel minus 2 secs.
+ *
+ * Input:
+ *      srb - Pointer to SCSI Request Block
+ *      timeout - Number of seconds to extend command timeout.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+void
+qla4xxx_add_timer_to_cmd(srb_t *srb, int timeout)
+{
+	init_timer(&srb->timer);
+	srb->timer.expires = jiffies + timeout * HZ;
+	srb->timer.data = (unsigned long) srb;
+	srb->timer.function = (void (*) (unsigned long))qla4xxx_os_cmd_timeout;
+	add_timer(&srb->timer);
+	QL4PRINT(QLP3, printk("%s: srb %p, timeout %d\n",
+			      __func__, srb, timeout));
+}
+
+/**************************************************************************
+ * qla4xxx_delete_timer_from_cmd
+ *      This routine deletes the timer for the specified command.
+ *
+ * Input:
+ *      srb - Pointer to SCSI Request Block
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel/Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_delete_timer_from_cmd(srb_t *srb )
+{
+	if (srb->timer.function != NULL) {
+		del_timer(&srb->timer);
+		srb->timer.function =  NULL;
+		srb->timer.data = (unsigned long) NULL;
+		QL4PRINT(QLP3, printk("%s: srb %p\n", __func__, srb));
+	}
+}
+
+
+/****************************************************************************/
+/*                        Interrupt Service Routine.                        */
+/****************************************************************************/
+
+/**************************************************************************
+ * qla4xxx_timer
+ *      This routine is scheduled to be invoked every second to search for
+ *      work to do.
+ *
+ * Input:
+ *      p - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_timer(unsigned long p)
+{
+	scsi_qla_host_t *ha = (scsi_qla_host_t *) p;
+	ddb_entry_t *ddb_entry, *dtemp;
+	int             start_dpc = 0;
+	os_lun_t *lun_entry;
+	os_tgt_t *tq;
+	int             t, l;
+
+#if ISP_RESET_TEST
+	if (ha->isp_reset_timer++ == (60 *3)) {
+		printk("scsi%d: %s going to schedule BIG HAMMER\n",
+		       ha->host_no, __func__);
+
+		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		ha->isp_reset_timer = 0;
+	}
+#endif
+
+	QL4PRINT(QLP6, printk("scsi%d: %s: A%d=%d/%d [%lx,%lx,%lx] <%d,%d> "
+	    "{%d,%d,%d,%d} %d\n", ha->host_no, __func__, ha->instance,
+	    ha->spurious_int_count, (uint32_t)ha->isr_count, ha->flags,
+	    ha->dpc_flags, ha->isns_flags, ha->aborted_io_count,
+	    ha->mailbox_timeout_count, MAX_AEN_ENTRIES-ha->aen_q_count,
+	    ha->pending_srb_q_count, ha->retry_srb_q_count,
+	    ha->active_srb_count, ha->seconds_since_last_intr));
+
+	/* Do we need to process the retry queue? */
+	if (!list_empty(&ha->retry_srb_q)) {
+		start_dpc++;
+	}
+
+#ifdef CONFIG_SCSI_QLA2XXX_FAILOVER
+	/*
+	 * We try and failover any request in the failover
+	 * queue every second.
+	 */
+	if (!list_empty(&ha->failover_queue)) {
+		set_bit(DPC_FAILOVER_NEEDED, &ha->dpc_flags);
+		start_dpc++;
+	}
+#endif
+
+	/* LUN suspension */
+	for (t = 0; t < MAX_TARGETS; t++) {
+		if ((tq = ha->otgt[t]) == NULL)
+			continue;
+
+		for (l = 0; l < MAX_LUNS ; l++) {
+			unsigned long cpu_flags;
+
+			if ((lun_entry = (os_lun_t *) tq->olun[l]) == NULL)
+				continue;
+
+			spin_lock_irqsave(&lun_entry->lun_lock, cpu_flags);
+			if (lun_entry->lun_state != LS_LUN_SUSPENDED ||
+			    !atomic_read(&lun_entry->suspend_timer)) {
+				spin_unlock_irqrestore(&lun_entry->lun_lock,
+				    cpu_flags);
+				continue;
+			}
+
+			QL4PRINT(QLP2, printk("scsi%d: %s: processing "
+			    "suspend_lun_q lun=%d suspend_timer=%d "
+			    "retry_count=%d\n", ha->host_no, __func__,
+			    lun_entry->lun,
+			    atomic_read(&lun_entry->suspend_timer),
+			    lun_entry->retry_count));
+
+			if (!atomic_dec_and_test(&lun_entry->suspend_timer)) {
+				spin_unlock_irqrestore(&lun_entry->lun_lock,
+				    cpu_flags);
+				continue;
+			}
+
+			if (test_and_clear_bit(LS_LUN_DELAYED,
+			    &lun_entry->flags)) {
+				lun_entry->lun_state = LS_LUN_READY;
+			} else {
+				lun_entry->retry_count++;
+				if (lun_entry->retry_count ==
+				    lun_entry->max_retry_count) {
+					QL4PRINT(QLP2, printk("scsi%d: %s: LUN "
+					    "%d TIMEOUT RETRY_CNT:%d\n",
+					    ha->host_no, __func__,
+					    lun_entry->lun,
+					    lun_entry->retry_count));
+
+					lun_entry->lun_state = LS_LUN_TIMEOUT;
+				} else {
+					QL4PRINT(QLP2, printk("scsi%d: %s: LUN "
+					    "%d RETRY\n", ha->host_no, __func__,
+					    lun_entry->lun));
+
+					lun_entry->lun_state = LS_LUN_RETRY;
+				}
+			}
+			spin_unlock_irqrestore(&lun_entry->lun_lock, cpu_flags);
+		}
+	}
+
+	/*
+	 * Search for relogin's to time-out and port down retry.
+	 */
+	list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list_entry) {
+		/* First check to see if the device has exhausted the
+		 * port down retry count */
+		if (atomic_read(&ddb_entry->state) == DEV_STATE_MISSING) {
+			if (atomic_read(&ddb_entry->port_down_timer) == 0)
+				continue;
+
+			if (atomic_dec_and_test(&ddb_entry->port_down_timer)) {
+				DEBUG2(printk("scsi%d: %s: index [%d] "
+				    "port down retry count of (%d) secs "
+				    "exhausted, marking device DEAD.\n",
+				    ha->host_no, __func__,
+				    ddb_entry->fw_ddb_index,
+				    ha->port_down_retry_count);)
+
+				atomic_set(&ddb_entry->state, DEV_STATE_DEAD);
+				if (ddb_entry->fcport)
+					atomic_set(&ddb_entry->fcport->state,
+					    FCS_DEVICE_DEAD);
+
+				DEBUG2(printk(KERN_INFO "scsi%d:%d:%d: "
+				    "%s: index [%d] marked DEAD\n", ha->host_no,
+				    ddb_entry->bus, ddb_entry->target, __func__,
+				    ddb_entry->fw_ddb_index);)
+			}
+		}
+
+
+		/* Count down time between sending relogins */
+		if (ADAPTER_UP(ha) && (!test_bit(DF_RELOGIN, &ddb_entry->flags) &&
+		    (atomic_read(&ddb_entry->state) != DEV_STATE_ONLINE))) {
+			if (atomic_read(&ddb_entry->retry_relogin_timer) !=
+			    INVALID_ENTRY) {
+				if (atomic_read(&ddb_entry->retry_relogin_timer) == 0) {
+					atomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);
+					set_bit(DPC_RELOGIN_DEVICE,
+					    &ha->dpc_flags);
+					set_bit(DF_RELOGIN,
+					    &ddb_entry->flags);
+					DEBUG2(printk(KERN_INFO "scsi%d:%d:%d: "
+				    "%s: index [%d] login device\n", ha->host_no,
+				    ddb_entry->bus, ddb_entry->target, __func__,
+				    ddb_entry->fw_ddb_index);)
+				} else
+					atomic_dec(&ddb_entry->retry_relogin_timer);
+			}
+		}
+
+		/* Wait for relogin to timeout */
+		if (atomic_read(&ddb_entry->relogin_timer)  &&
+		    (atomic_dec_and_test(&ddb_entry->relogin_timer) != 0)) {
+			/*
+			 * If the relogin times out and the device is
+			 * still NOT ONLINE then try and relogin again.
+			 */
+			if (atomic_read(&ddb_entry->state) !=
+			    DEV_STATE_ONLINE &&
+			    ddb_entry->fw_ddb_device_state ==
+			    DDB_DS_SESSION_FAILED) {
+				/* Reset login timer */
+				atomic_inc(&ddb_entry->relogin_retry_count);
+				QL4PRINT(QLP2, printk(KERN_INFO
+				    "scsi%d:%d:%d: index[%d] relogin timed "
+				    "out-retrying relogin (%d)\n", ha->host_no,
+				    ddb_entry->bus, ddb_entry->target,
+				    ddb_entry->fw_ddb_index,
+				    atomic_read(&ddb_entry->relogin_retry_count)));
+				start_dpc++;
+				QL4PRINT(QLP3, printk(KERN_INFO
+				    "scsi%d:%d:%d: index [%d] initate relogin "
+				    "after %d seconds\n", ha->host_no,
+				    ddb_entry->bus, ddb_entry->target,
+				    ddb_entry->fw_ddb_index,
+				    ddb_entry->default_time2wait));
+
+				atomic_set(&ddb_entry->retry_relogin_timer,
+				    ddb_entry->default_time2wait);
+
+			}
+		}
+	}
+
+	if (!list_empty(&ha->done_srb_q)) {
+		start_dpc++;
+	}
+
+#if EH_WAKEUP_WORKAROUND
+	/*
+	 * Check for kernel wakeup error
+	 */
+	if (ha->host->in_recovery &&
+	    (HOST_BUSY(ha) == ha->host->host_failed) &&
+	    !ha->host->eh_active) {
+		if ((ha->eh_start++) == 60) {
+			if (ha->host->eh_wait)
+				up(ha->host->eh_wait);
+			ha->eh_start=0;
+
+			QL4PRINT(QLP2, printk(KERN_INFO "scsi%d: !!! Waking up error "
+					      "handler for scsi layer\n", ha->host_no));
+		}
+	}
+#endif /* EH_WAKEUP_WORKAROUND */
+
+	/*
+	 * Check for heartbeat interval
+	 */
+	if ((ha->firmware_options & FWOPT_HEARTBEAT_ENABLE) &&
+	    (ha->heartbeat_interval != 0)) {
+		ha->seconds_since_last_heartbeat ++;
+
+		if (ha->seconds_since_last_heartbeat >
+		    ha->heartbeat_interval+2) {
+			QL4PRINT(QLP2, printk(KERN_INFO
+			    "scsi%d: Heartbeat not received for %d seconds. "
+			    "HeartbeatInterval = %d seconds. Scheduling SOFT "
+			    "RESET.\n", ha->host_no,
+			    ha->seconds_since_last_heartbeat,
+			    ha->heartbeat_interval));
+
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		}
+	}
+
+	/*
+	 * Check for iSNS actions
+	 */
+	if (test_bit(ISNS_FLAG_RESTART_SERVICE, &ha->isns_flags)) {
+		if (atomic_read(&ha->isns_restart_timer)) {
+			if (!atomic_dec_and_test(&ha->isns_restart_timer) &&
+			    test_bit(ISNS_FLAG_ISNS_SRV_ENABLED,
+				    &ha->isns_flags) &&
+			    !IPAddrIsZero(ha->isns_ip_address) &&
+			    ha->isns_server_port_number) {
+				set_bit(DPC_ISNS_RESTART_COMPLETION,
+				    &ha->dpc_flags);
+			}
+		} else
+			clear_bit(ISNS_FLAG_RESTART_SERVICE, &ha->isns_flags);
+	}
+
+	if (test_bit(DPC_FAILOVER_EVENT_NEEDED, &ha->dpc_flags)) {
+		if (ha->failback_delay)  {
+			ha->failback_delay--;
+			if (ha->failback_delay == 0)  {
+				set_bit(DPC_FAILOVER_EVENT, &ha->dpc_flags);
+				clear_bit(DPC_FAILOVER_EVENT_NEEDED,
+				    &ha->dpc_flags);
+			}
+		} else {
+			set_bit(DPC_FAILOVER_EVENT, &ha->dpc_flags);
+			clear_bit(DPC_FAILOVER_EVENT_NEEDED, &ha->dpc_flags);
+		}
+	}
+
+	/* Wakeup the dpc routine for this adapter, if needed */
+	if ((start_dpc ||
+	     test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
+	     test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||
+	     test_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||
+
+	     test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags) ||
+	     test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
+	     test_bit(DPC_IOCTL_ERROR_RECOVERY, &ha->dpc_flags) ||
+	     test_bit(DPC_ISNS_RESTART, &ha->dpc_flags) ||
+	     test_bit(DPC_ISNS_RESTART_COMPLETION, &ha->dpc_flags) ||
+	     test_bit(DPC_FAILOVER_EVENT, &ha->dpc_flags) ||
+	     test_bit(DPC_FAILOVER_NEEDED, &ha->dpc_flags) ||
+	     test_bit(DPC_AEN, &ha->dpc_flags)) &&
+	    !test_bit(AF_DPC_SCHEDULED, &ha->flags) &&
+	    !ha->dpc_active && ha->dpc_wait) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: scheduling dpc routine\n",
+		    ha->host_no, __func__));
+		set_bit(AF_DPC_SCHEDULED, &ha->flags);
+		up(ha->dpc_wait);
+	}
+
+	/* Reschedule timer thread to call us back in one second */
+	mod_timer(&ha->timer, jiffies + HZ);
+
+	ha->seconds_since_last_intr ++;
+}
+
+void
+qla4xxx_ioctl_error_recovery(scsi_qla_host_t *ha)
+{
+	int return_status;
+	unsigned long flags;
+
+	QL4PRINT(QLP2, printk(KERN_INFO
+	    "scsi%d: %s: issuing device reset\n", ha->host_no, __func__));
+	if (!ha->ioctl->ioctl_err_cmd) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: should not occur\n",
+		    ha->host_no, __func__));
+		return;
+	}
+
+	spin_lock_irqsave(ha->host->host_lock, flags);
+
+	return_status = qla4xxx_eh_device_reset(ha->ioctl->ioctl_err_cmd);
+	if (return_status != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: elevation to host_reset\n",
+		    ha->host_no, __func__));
+		return_status = qla4xxx_eh_host_reset(ha->ioctl->ioctl_err_cmd);
+		QL4PRINT(QLP2, printk("scsi%d: %s: return_status=%x\n",
+		    ha->host_no, __func__, return_status));
+	}
+	ha->ioctl->ioctl_err_cmd = NULL ;
+
+	spin_unlock_irqrestore(ha->host->host_lock, flags);
+}
+
+
+/**************************************************************************
+ * qla4xxx_do_dpc
+ *      This routine is a task that is schedule by the interrupt handler
+ *      to perform the background processing for interrupts.  We put it
+ *      on a task queue that is consumed whenever the scheduler runs; that's
+ *      so you can do anything (i.e. put the process to sleep etc).  In fact,
+ *      the mid-level tries to sleep when it reaches the driver threshold
+ *      "host->can_queue". This can cause a panic if we were in our interrupt
+ *      code.
+ *
+ * Input:
+ *      p - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static int
+qla4xxx_do_dpc(void *data)
+{
+	DECLARE_MUTEX_LOCKED(sem);
+	scsi_qla_host_t *ha = (scsi_qla_host_t *) data;
+	ddb_entry_t *ddb_entry, *dtemp;
+	fc_port_t       *fcport;
+
+	ENTER("qla4xxx_do_dpc");
+
+	lock_kernel();
+
+	daemonize("qla4xxx_%d_dpc", ha->host_no);
+	allow_signal(SIGHUP);
+
+	ha->dpc_wait = &sem;
+
+	set_user_nice(current, -20);
+
+	unlock_kernel();
+
+	complete(&ha->dpc_inited);
+
+	while (1) {
+		QL4PRINT(QLP2|QLP12, printk("scsi%d: %s: DPC handler sleeping "
+		    "*****************\n", ha->host_no, __func__));
+
+		if (down_interruptible(&sem))
+			break;
+
+		if (ha->dpc_should_die)
+			break;
+
+		QL4PRINT(QLP2|QLP12, printk("scsi%d: %s: DPC handler waking up "
+		    "****************\n", ha->host_no, __func__));
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: ha->flags = 0x%08lx\n",
+		    ha->host_no, __func__, ha->flags));
+
+		QL4PRINT(QLP2, printk("scsi%d: %s: ha->dpc_flags = 0x%08lx\n",
+		    ha->host_no, __func__, ha->dpc_flags));
+
+		/* Initialization not yet finished. Don't do anything yet. */
+		if (!test_bit(AF_INIT_DONE, &ha->flags) || ha->dpc_active)
+			continue;
+
+		ha->dpc_active = 1;
+		clear_bit(AF_DPC_SCHEDULED, &ha->flags);
+
+		/* FIXMEdg: */
+		if (!list_empty(&ha->done_srb_q))
+			qla4xxx_done(ha);
+
+
+		/* ---- return cmds on retry_q? --- */
+		QL4PRINT(QLP3, printk("scsi%d: %s: Do we need to return cmds "
+		    "on the retry_q?\n", ha->host_no, __func__));
+
+		if (!list_empty(&ha->retry_srb_q)) {
+			srb_t    *srb, *stemp;
+			unsigned long flags;
+
+			spin_lock_irqsave(&ha->list_lock, flags);
+
+			QL4PRINT(QLP2, printk("scsi%d: %s: found %d srbs in "
+			    "retry_srb_q \n", ha->host_no, __func__,
+			    ha->retry_srb_q_count));
+
+			list_for_each_entry_safe(srb, stemp, &ha->retry_srb_q,
+			    list_entry) {
+				ddb_entry_t *ddb_entry;
+				os_lun_t *lun_entry;
+
+				lun_entry = srb->lun_queue;
+				if (lun_entry && lun_entry->lun_state ==
+				    LS_LUN_SUSPENDED)
+					continue;
+				fcport = lun_entry->fclun->fcport;
+				ddb_entry = fcport->ddbptr;
+
+				if (ddb_entry &&
+				    atomic_read(&ddb_entry->state) ==
+				    DEV_STATE_DEAD) {
+					QL4PRINT(QLP2,
+						 printk("scsi%d: %s: found srb %p "
+							"in retry_srb_q, "
+							"Device DEAD, returning\n",
+							ha->host_no, __func__,
+							srb));
+
+					__del_from_retry_srb_q(ha, srb);
+					srb->cmd->result = DID_NO_CONNECT << 16;
+					__add_to_done_srb_q(ha,srb);
+				}
+
+				/*
+				 * Send requests to OS when device goes ONLINE
+				 * so that the OS will retry them via I/O thread.
+				 * We don't want to issue I/O via recovery thread.
+				 */
+				if (ADAPTER_UP(ha) &&
+				    (atomic_read(&ddb_entry->state)
+				     == DEV_STATE_ONLINE)) {
+					QL4PRINT(QLP2,
+						 printk("scsi%d: %s: found srb %p "
+							"in retry_srb_q, "
+							"Device ONLINE, returning\n",
+							ha->host_no, __func__,
+							srb));
+
+					__del_from_retry_srb_q(ha, srb);
+					srb->cmd->result = DID_BUS_BUSY << 16;
+					__add_to_done_srb_q(ha,srb);
+				}
+			}
+			spin_unlock_irqrestore(&ha->list_lock, flags);
+
+			/* FIXMEdg: */
+			if (!list_empty(&ha->done_srb_q))
+				qla4xxx_done(ha);
+
+		}
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+		if (qla4xxx_failover_enabled(ha))
+			qla4xxx_process_failover_event(ha);
+#endif
+		/*
+		 * Determine what action is necessary
+		 */
+
+		/* ---- recover adapter? --- */
+		QL4PRINT(QLP3, printk("scsi%d: %s: Do we need to "
+				      "recover the adapter?\n",
+				      ha->host_no, __func__));
+
+		if (ADAPTER_UP(ha) ||
+		    (test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) &&
+			test_bit(DPC_RESET_HA, &ha->dpc_flags)) ||
+		    test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
+		    test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags)) {
+			if (test_bit(DPC_RESET_HA_DESTROY_DDB_LIST,
+			    &ha->dpc_flags))
+				/* dg 09/23 Never initialize ddb list once we up and running 
+					qla4xxx_recover_adapter(ha, REBUILD_DDB_LIST); */
+				qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST);
+			
+			if (test_bit(DPC_RESET_HA, &ha->dpc_flags))
+				qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST);
+			
+			if (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {
+				uint8_t wait_time = RESET_INTR_TOV;
+				unsigned long flags = 0;
+
+				qla4xxx_flush_active_srbs(ha);
+
+				spin_lock_irqsave(&ha->hardware_lock, flags);
+				while ((RD_REG_DWORD(ISP_PORT_STATUS(ha)) &
+				    PSR_INIT_COMPLETE) == 0) {
+					if (wait_time-- == 0)
+						break;
+
+					spin_unlock_irqrestore(
+					    &ha->hardware_lock, flags);
+
+					set_current_state(TASK_UNINTERRUPTIBLE);
+					schedule_timeout(1 * HZ);
+
+					spin_lock_irqsave(&ha->hardware_lock,
+					    flags);
+				}
+				spin_unlock_irqrestore(&ha->hardware_lock,
+				    flags);
+
+				if (wait_time == 0)
+					QL4PRINT(QLP2,
+						 printk("scsi%d: %s: IC bit not set\n",
+							ha->host_no, __func__));
+
+				qla4xxx_initialize_adapter(
+							  ha,
+							  PRESERVE_DDB_LIST);
+				clear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);
+			}
+
+
+		}
+
+		/* ---- process AEN? --- */
+		DEBUG3(printk("scsi%d: %s: Do we need to "
+				      "process an AEN?\n",
+				      ha->host_no, __func__));
+
+		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
+			qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
+
+		/* ---- relogin device? --- */
+		DEBUG3(printk("scsi%d: %s: Do we need to "
+				      "relogin a device?\n",
+				      ha->host_no, __func__));
+
+		if (ADAPTER_UP(ha) &&
+		    test_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {
+			list_for_each_entry_safe(ddb_entry, dtemp,
+			    &ha->ddb_list, list_entry) {
+				if (test_and_clear_bit(DF_RELOGIN,
+				    &ddb_entry->flags) &&
+				    atomic_read(&ddb_entry->state) != DEV_STATE_ONLINE) {
+					qla4xxx_relogin_device(ha, ddb_entry);
+				}
+			}
+		}
+
+		/* ---- restart iSNS server? --- */
+		QL4PRINT(QLP3, printk("scsi%d: %s: Do we need to "
+				      "restart the iSNS server?\n",
+				      ha->host_no, __func__));
+
+		if (ADAPTER_UP(ha) &&
+		    test_and_clear_bit(DPC_ISNS_RESTART, &ha->dpc_flags)) {
+			qla4xxx_isns_restart_service(ha);
+		}
+
+		if (ADAPTER_UP(ha) &&
+		    test_and_clear_bit(DPC_ISNS_RESTART_COMPLETION, &ha->dpc_flags)) {
+			uint32_t ip_addr = 0;
+			IPAddr2Uint32(ha->isns_ip_address, &ip_addr);
+
+			if (qla4xxx_isns_restart_service_completion(ha,
+								    ip_addr,
+								    ha->isns_server_port_number)
+			    != QLA_SUCCESS) {
+				QL4PRINT(QLP2|QLP6,
+					 printk(KERN_WARNING "scsi%d: %s: "
+						"restart service failed\n",
+						ha->host_no, __func__));
+			}
+		}
+
+		if (test_and_clear_bit(DPC_IOCTL_ERROR_RECOVERY, &ha->dpc_flags)) {
+			qla4xxx_ioctl_error_recovery(ha);
+		}
+
+		ha->dpc_active = 0;
+	}
+
+	QL4PRINT(QLP7, printk("scsi%d: %s: Wake up, we're leaving\n",
+			      ha->host_no, __func__));
+
+	/*
+	* Make sure that nobody tries to wake us up again.
+	*/
+	ha->dpc_wait = NULL;
+	ha->dpc_active = 0;
+
+	complete_and_exit(&ha->dpc_exited, 0);
+}
+
+/**************************************************************************
+ * qla4xxx_eh_wait_on_command
+ *      This routine waits for the command to be returned by the Firmware
+ *      for some max time.
+ *
+ * Input:
+ *    ha = actual ha whose done queue will contain the command
+ *            returned by firmware.
+ *    cmd = Scsi Command to wait on.
+ *
+ * Returns:
+ *    Not Found : 0
+ *    Found : 1
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static int
+qla4xxx_eh_wait_on_command(scsi_qla_host_t *ha, struct scsi_cmnd *cmd){
+
+	int             done = 0;
+	srb_t           *rp;
+	uint32_t        max_wait_time = EH_WAIT_CMD_TOV;
+
+	ENTER("qla4xxx_eh_wait_on_command");
+
+	do {
+		/*Checking to see if its returned to OS */
+		rp = (srb_t *) CMD_SP(cmd);
+		if (rp == NULL) {
+			done++;
+			break;
+		}
+
+		spin_unlock_irq(ha->host->host_lock);
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(2*HZ);
+
+		while ((rp = del_from_done_srb_q_head(ha)) != NULL)
+			qla4xxx_complete_request(ha, rp);
+
+		spin_lock_irq(ha->host->host_lock);
+	} while ((max_wait_time--));
+
+	if (done)
+		QL4PRINT(QLP2, printk("scsi%d: %s: found cmd=%p.\n",
+				      ha->host_no, __func__, cmd));
+
+	LEAVE("qla4xxx_eh_wait_on_command");
+
+	return(done);
+}
+
+/**************************************************************************
+ * WAIT_FOR_ADAPTER_UP
+ *      This routine
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure
+ *
+ * Remarks:
+ *
+ * Returns:
+ *      SUCCESS - Adapter is ONLINE
+ *      FAILED  - Adapter is DEAD
+ *
+ * Context:
+ *      Kernel context.  Assume io_request_lock LOCKED upon entry
+ **************************************************************************/
+inline uint8_t
+WAIT_FOR_ADAPTER_UP(scsi_qla_host_t *ha){
+	while (1) {
+		if (ADAPTER_UP(ha))
+			return(QLA_SUCCESS);
+
+		if (!ADAPTER_UP(ha) &&
+		    (ha->retry_reset_ha_cnt == 0)) {
+			QL4PRINT(QLP2, printk("scsi%d: %s: adapter down, retry_reset_ha_cnt = %d\n",
+					      ha->host_no, __func__, ha->retry_reset_ha_cnt));
+			return(QLA_ERROR);
+		}
+
+		spin_unlock_irq(ha->host->host_lock);
+
+		QL4PRINT(QLP3, printk("scsi%d: %s: adapter down, retry_reset_ha_cnt = %d, delay 2 sec.\n",
+				      ha->host_no, __func__, ha->retry_reset_ha_cnt));
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(2*HZ);
+
+		spin_lock_irq(ha->host->host_lock);
+	}
+}
+
+/**************************************************************************
+ * qla4xxx_eh_abort
+ *      This routine aborts commands that currently held in the adapter's
+ *      internal queues.  Commands that are active are NOT aborted.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Remarks:
+ *      Aborts get translated to "device resets" by the scsi switch
+ *      which will return a RESET status and not ABORT. Since the
+ *      mid-level is expecting an ABORT status during an abort(),
+ *      we always elevate to device reset.
+ *
+ * Returns:
+ *      SUCCESS - Successfully aborted non-active command
+ *      FAILED  - Command not found, or command currently active
+ *
+ * Context:
+ *      Kernel context.  io_request_lock LOCKED
+ **************************************************************************/
+int
+qla4xxx_eh_abort(struct scsi_cmnd *cmd)
+{
+	int return_status = FAILED;
+	scsi_qla_host_t *ha, *vis_ha;
+	srb_t *srb, *stemp;
+	unsigned long flags;
+
+	ENTER("qla4xxx_eh_abort");
+
+	vis_ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+	srb = (srb_t *) CMD_SP(cmd);
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	if (qla4xxx_failover_enabled(vis_ha))
+		ha = (scsi_qla_host_t *)srb->ha;
+	else
+		ha = vis_ha;
+#else
+	ha = vis_ha;
+#endif
+
+	if (!srb) {
+		/* Srb invalid, for some reason, possibly already returned
+		 * to the OS */
+		QL4PRINT(QLP2, printk("scsi%d:%d:%d: %s: NULL srb %p, "
+				      "cmd %p may have already been returned to OS.\n",
+				      ha->host_no, cmd->device->channel,
+				      cmd->device->id, __func__, srb, cmd));
+
+		return_status = SUCCESS;
+		return(return_status);
+	}
+
+	ha->aborted_io_count++;
+
+	/* Print statements
+	 * ---------------- */
+	QL4PRINT(QLP2,
+		 printk(KERN_INFO "scsi%d:%d:%d:%d: abort srb=%p, cmd=%p, state=%s, "
+			"r_start=%ld , u_start=%ld\n",
+			ha->host_no, cmd->device->channel, cmd->device->id,
+			cmd->device->lun,
+			srb, cmd, srb_state_msg[srb->state],srb->r_start,srb->u_start));
+
+	qla4xxx_dump_dwords(QLP10, srb, sizeof(*srb));
+
+	/* If srb found in done_q, return the cmd with ABORTED status */
+	spin_lock_irqsave(&ha->adapter_lock, flags);
+	list_for_each_entry_safe(srb, stemp, &ha->done_srb_q, list_entry) {
+		if (srb->cmd != cmd)
+			continue;
+
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: srb %p found on done queue\n",
+				ha->host_no, __func__, srb));
+
+		cmd->result = DID_ABORT << 16;
+
+		spin_unlock_irqrestore(&ha->adapter_lock, flags);
+
+		spin_unlock_irq(ha->host->host_lock);
+		while ((srb = del_from_done_srb_q_head(ha)) != NULL)
+			qla4xxx_complete_request(ha, srb);
+		spin_lock_irq(ha->host->host_lock);
+
+		return_status = SUCCESS;
+		goto exit_abort;
+	}
+	spin_unlock_irqrestore(&ha->adapter_lock, flags);
+
+	/* If srb found in pending_srb_q, return  the cmd with ABORTED status */
+	spin_lock_irqsave(&ha->list_lock, flags);
+	list_for_each_entry_safe(srb, stemp, &ha->pending_srb_q, list_entry) {
+		if (srb->cmd != cmd)
+			continue;
+
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: srb %p found on pending queue\n",
+				ha->host_no, __func__, srb));
+
+		__del_from_pending_srb_q(ha, srb);
+		cmd->result = DID_ABORT << 16;
+
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		qla4xxx_complete_request(ha, srb);
+
+		return_status = SUCCESS;
+		goto exit_abort;
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	/* If srb found in retry_srb_q, return it with ABORTED status */
+	spin_lock_irqsave(&ha->list_lock, flags);
+	list_for_each_entry_safe(srb, stemp, &ha->retry_srb_q, list_entry) {
+		if (srb->cmd != cmd)
+			continue;
+
+		QL4PRINT(QLP2,
+			 printk("scsi%d: %s: srb %p found on retry queue\n",
+				ha->host_no, __func__, srb));
+
+		__del_from_retry_srb_q(ha, srb);
+		cmd->result = DID_ABORT << 16;
+
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		spin_unlock_irq(ha->host->host_lock);
+		qla4xxx_complete_request(ha, srb);
+		spin_lock_irq(ha->host->host_lock);
+		return_status = SUCCESS;
+		goto exit_abort;
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+#ifdef CONFIG_SCSI_QLA4XXX_FAILOVER
+	if (qla4xxx_failover_enabled(vis_ha)) {
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_entry_safe(srb, stemp, &ha->failover_queue,
+		    list_entry) {
+			if (cmd != srb->cmd)
+				continue;
+
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: %s: srb %p found on retry queue\n",
+					ha->host_no, __func__, srb));
+
+			/* Remove srb from failover queue. */
+			__del_from_failover_queue(ha, srb);
+			srb->cmd->result = DID_ABORT << 16;
+
+			spin_unlock_irqrestore(&ha->list_lock, flags);
+			spin_unlock_irq(ha->host->host_lock);
+			qla4xxx_complete_request(ha, srb);
+			spin_lock_irq(ha->host->host_lock);
+			return_status = SUCCESS;
+			goto exit_abort;
+		}
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+	}
+#endif
+	/*
+	 * Aborts get translated to "device resets" by the scsi switch
+	 * which will return a RESET status and not ABORT. Since the
+	 * mid-level is expecting an ABORT status during an abort(),
+	 * we always elevate to device reset.
+	 */
+	return_status = FAILED;
+
+exit_abort:
+	QL4PRINT(QLP2, printk("scsi%d: %s: return with status = %x\n",
+			      ha->host_no, __func__, return_status));
+	LEAVE("qla4xxx_eh_abort");
+
+	return(return_status);
+}
+
+/**************************************************************************
+ * qla4010_soft_reset
+ *      This routine performs a SOFT RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4010_soft_reset(scsi_qla_host_t *ha){
+	uint32_t  max_wait_time;
+	unsigned long flags = 0;
+	uint8_t status = QLA_ERROR;
+	uint16_t ctrl_status;
+
+	ENTER(__func__);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/*
+	 * If the SCSI Reset Interrupt bit is set, clear it.
+	 * Otherwise, the Soft Reset won't work.
+	 */
+	ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if ((ctrl_status & CSR_SCSI_RESET_INTR) != 0)
+		WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_RESET_INTR));
+
+	/* Issue Soft Reset */
+	WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SOFT_RESET));
+	PCI_POSTING(&ha->reg->ctrl_status);
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Wait until the Network Reset Intr bit is cleared */
+	max_wait_time = RESET_INTR_TOV;
+	do {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		ctrl_status = RD_REG_WORD(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		if ((ctrl_status & CSR_NET_RESET_INTR) == 0)
+			break;
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 * HZ);
+	} while ((max_wait_time--));
+
+	if ((ctrl_status & CSR_NET_RESET_INTR) != 0) {
+		QL4PRINT(QLP2,
+			 printk(KERN_WARNING "scsi%d: Network Reset Intr not cleared "
+				"by Network function, clearing it now!\n", ha->host_no));
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_NET_RESET_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+
+	/* Wait until the firmware tells us the Soft Reset is done */
+	max_wait_time = SOFT_RESET_TOV;
+	do {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		ctrl_status = RD_REG_WORD(&ha->reg->ctrl_status);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		if ((ctrl_status & CSR_SOFT_RESET) == 0) {
+			status = QLA_SUCCESS;
+			break;
+		}
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 * HZ);
+	} while ((max_wait_time--));
+
+	/*
+	 * Also, make sure that the SCSI Reset Interrupt bit has been cleared
+	 * after the soft reset has taken place.
+	 */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	ctrl_status = RD_REG_DWORD(&ha->reg->ctrl_status);
+	if ((ctrl_status & CSR_SCSI_RESET_INTR) != 0) {
+		WRT_REG_DWORD(&ha->reg->ctrl_status, SET_RMASK(CSR_SCSI_RESET_INTR));
+		PCI_POSTING(&ha->reg->ctrl_status);
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE(__func__);
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_topcat_reset
+ *      This routine performs a HARD RESET of the TopCat chip.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_topcat_reset(scsi_qla_host_t *ha){
+	unsigned long flags;
+
+	QL4PRINT(QLP2, printk(KERN_WARNING "scsi%d: %s: TopCat chip reset!\n",
+			      ha->host_no, __func__));
+
+	if (qla4xxx_take_hw_semaphore(ha, SEM_NVRAM, SEM_FLG_TIMED_WAIT) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk(KERN_WARNING "scsi%d: %s: Unable to take SEM_NVRAM "
+				      "semaphore\n", ha->host_no, __func__));
+		return(QLA_ERROR);
+	}
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	WRT_REG_DWORD(ISP_GP_OUT(ha), SET_RMASK(GPOR_TOPCAT_RESET));
+	PCI_POSTING(ISP_GP_OUT(ha));
+	TOPCAT_RESET_DELAY();
+	WRT_REG_DWORD(ISP_GP_OUT(ha), CLR_RMASK(GPOR_TOPCAT_RESET));
+	PCI_POSTING(ISP_GP_OUT(ha));
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	TOPCAT_POST_RESET_DELAY();
+
+	qla4xxx_clear_hw_semaphore(ha, SEM_NVRAM);
+	return(QLA_SUCCESS);
+}
+
+
+/**************************************************************************
+ * qla4xxx_soft_reset
+ *      This routine performs a SOFT RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_soft_reset(scsi_qla_host_t *ha){
+	if (test_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags)) {
+		uint8_t status = QLA_ERROR;
+
+		if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+			if (qla4xxx_topcat_reset(ha) == QLA_SUCCESS) {
+				if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+					status = QLA_SUCCESS;
+				}
+			}
+		}
+		return(status);
+	}
+	else
+		return(qla4010_soft_reset(ha));
+}
+
+/**************************************************************************
+ * qla4xxx_hard_reset
+ *      This routine performs a HARD RESET.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset the firmware
+ *      QLA_ERROR   - Failed to reset the firmware
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+inline uint8_t
+qla4xxx_hard_reset(scsi_qla_host_t *ha){
+	/* The QLA4010 really doesn't have an equivalent to a hard reset */
+	qla4xxx_flush_active_srbs(ha);
+	if (test_bit(AF_TOPCAT_CHIP_PRESENT, &ha->flags)) {
+		uint8_t status = QLA_ERROR;
+
+		if (qla4010_soft_reset(ha)  == QLA_SUCCESS) {
+			if (qla4xxx_topcat_reset(ha)  == QLA_SUCCESS) {
+				if (qla4010_soft_reset(ha) == QLA_SUCCESS) {
+					status = QLA_SUCCESS;
+				}
+			}
+		}
+		return(status);
+	}
+	else
+		return(qla4010_soft_reset(ha));
+}
+
+/**************************************************************************
+ * qla4xxx_cmd_wait
+ *      This routine stalls the driver until all outstanding commands are
+ *      returned.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *       Caller must release the Hardware Lock prior to calling this routine.
+ *
+ * Returns:
+ *      QLA_SUCCESS - All outstanding commands completed
+ *      QLA_ERROR   - All outstanding commands did not complete
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static uint8_t
+qla4xxx_cmd_wait(scsi_qla_host_t *ha){
+	uint32_t index = 0;
+	uint8_t stat = QLA_SUCCESS;
+	int wait_cnt = WAIT_CMD_TOV;			/* Initialized for 30 seconds as we expect all
+						 commands to retuned ASAP.*/
+	unsigned long flags;
+
+	ENTER("qla4xxx_cmd_wait: started\n");
+
+	while (wait_cnt) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		/* Find a command that hasn't completed. */
+		for (index = 1; index < MAX_SRBS; index++) {
+			if (ha->active_srb_array[index] != NULL)
+				break;
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		/* If No Commands are pending, wait is complete */
+		if (index == MAX_SRBS) {
+			break;
+		}
+
+		/* If we timed out on waiting for commands to come back
+		 * return ERROR.
+		 */
+		wait_cnt--;
+		if (wait_cnt == 0)
+			stat =  QLA_ERROR;
+		else {
+			/* sleep a second */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1 * HZ);
+		}
+	}		     /* End of While (wait_cnt) */
+
+	QL4PRINT(QLP2,printk("(%d): %s: Done waiting on commands - array_index=%d\n",
+			     ha->host_no, __func__, index));
+
+	LEAVE("qla4xxx_cmd_wait");
+
+	return(stat);
+}
+
+/**************************************************************************
+ * qla4xxx_recover_adapter
+ *      This routine recovers that adapter from a fatal state.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      renew_ddb_list - Indicates what to do with the adapter's ddb list
+ *                      after adapter recovery has completed.
+ *                      0=preserve ddb list, 1=destroy and rebuild ddb list
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully recovered adapter
+ *      QLA_ERROR   - Failed to recover adapter
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t
+qla4xxx_recover_adapter(scsi_qla_host_t *ha, uint8_t renew_ddb_list){
+	uint8_t status = QLA_SUCCESS;
+
+	ENTER("qla4xxx_recover_adapter");
+
+	QL4PRINT(QLP2,
+		 printk(KERN_INFO "scsi%d: recover adapter (begin)\n",
+			ha->host_no));
+
+	/* Stall incoming I/O until we are done */
+	clear_bit(AF_ONLINE, &ha->flags);
+	QL4PRINT(QLP2, printk("scsi%d: %s calling qla4xxx_cmd_wait\n",
+			      ha->host_no, __func__));
+
+	/* Wait for outstanding commands to complete.
+	 * Stalls the driver for max 30 secs
+	 */
+	status = qla4xxx_cmd_wait(ha);
+
+	qla4xxx_disable_intrs(ha);
+
+	/* Flush any pending ddb changed AENs */
+	if (renew_ddb_list == 1) {
+		qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+	}
+
+	/* Reset the firmware.  If successful, function
+	 * returns with ISP interrupts enabled.
+	 */
+	if (status == QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "scsi%d: %s - Performing soft reset..\n",
+				ha->host_no,__func__));
+		status = qla4xxx_soft_reset(ha);
+	}
+	/* FIXMEkaren: Do we want to keep interrupts enabled and process
+	 AENs after soft reset */
+
+	/* If firmware (SOFT) reset failed, or if all outstanding
+	 * commands have not returned, then do a HARD reset.
+	 */
+	if (status == QLA_ERROR) {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "scsi%d: %s - Performing hard reset..\n",
+				ha->host_no,__func__));
+		status = qla4xxx_hard_reset(ha);
+	}
+
+	/* Flush any pending ddb changed AENs */
+	if (renew_ddb_list == 1) {
+		qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+	}
+
+	/* Re-initialize firmware. If successful, function returns
+	 * with ISP interrupts enabled */
+	if (status == QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "scsi%d: %s - Initializing adapter..\n",
+				ha->host_no, __func__));
+
+		/* If successful, AF_ONLINE flag set in
+		 * qla4xxx_initialize_adapter */
+		status = qla4xxx_initialize_adapter(ha, renew_ddb_list);
+	}
+
+	/* Failed adapter initialization?
+	 * Retry reset_ha only if invoked via DPC (DPC_RESET_HA) */
+	if ((test_bit(AF_ONLINE, &ha->flags) == 0) &&
+	    (test_bit(DPC_RESET_HA, &ha->dpc_flags))) {
+		/* Adapter initialization failed, see if we can retry
+		 * resetting the ha */
+		if (!test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags)) {
+			ha->retry_reset_ha_cnt = MAX_RESET_HA_RETRIES;
+			QL4PRINT(QLP2,
+				 printk(KERN_INFO "scsi%d: recover adapter - "
+					"retrying (%d) more times\n",
+					ha->host_no, ha->retry_reset_ha_cnt));
+			set_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+			status = QLA_ERROR;
+		}
+		else {
+			if (ha->retry_reset_ha_cnt > 0) {
+				/* Schedule another Reset HA -- DPC will retry */
+				ha->retry_reset_ha_cnt--;
+				QL4PRINT(QLP2,
+					 printk(KERN_INFO
+						"scsi%d: recover adapter - "
+						"retry remaining %d\n", ha->host_no,
+						ha->retry_reset_ha_cnt));
+				status = QLA_ERROR;
+			}
+
+			if (ha->retry_reset_ha_cnt == 0) {
+				/* Recover adapter retries have been exhausted.
+				 * Adapter DEAD */
+				QL4PRINT(QLP2,
+					 printk(KERN_INFO
+						"scsi%d: recover adapter failed - "
+						"board disabled\n", ha->host_no));
+				qla4xxx_flush_active_srbs(ha);
+				clear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags);
+				status = QLA_SUCCESS;
+			}
+		}
+	}
+	else {
+		clear_bit(DPC_RESET_HA, &ha->dpc_flags);
+		clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags);
+		clear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
+	}
+
+	ha->adapter_error_count++;
+	QL4PRINT(QLP2,
+		 printk(KERN_INFO "scsi%d: recover adapter (end)\n", ha->host_no));
+	LEAVE("qla4xxx_recover_adapter");
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_eh_wait_for_active_target_commands
+ *      This routine
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      target - SCSI target ID
+ *
+ * Returns:
+ *      0 - All pending commands returned
+ *      non-zero - All pending commands did not return
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+qla4xxx_eh_wait_for_active_target_commands(scsi_qla_host_t *ha, int target, int lun){
+	int     cnt;
+	int     status;
+	unsigned long   flags;
+	srb_t           *sp;
+	struct scsi_cmnd       *cmd;
+
+	status = 0;
+	ENTER("qla4xxx_eh_wait_for_active_target_commands");
+	/*
+	 * Waiting for all commands for the designated target in the active
+	 * array
+	 */
+	for (cnt = 1; cnt < MAX_SRBS; cnt++) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		sp = ha->active_srb_array[cnt];
+		if (sp) {
+			cmd = sp->cmd;
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			if (cmd->device->id == target &&
+			    cmd->device->lun == lun) {
+
+				if (!qla4xxx_eh_wait_on_command(ha, cmd)) {
+					status++;
+					break;
+				}
+			}
+		}
+		else {
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		}
+	}
+	QL4PRINT(QLP2,
+		 printk(KERN_INFO "scsi%d: %s return_status=%d\n", ha->host_no, __func__, status));
+	LEAVE("qla4xxx_eh_wait_for_active_target_commands");
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_eh_device_reset
+ *      This routine is called by the Linux OS to reset all luns on the
+ * 	specified target.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Output:
+ *      None
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      SUCCESS - Successfully reset target/lun
+ *      FAILED  - Failed to reset target/lun
+ *
+ * Context:
+ *      Kernel context.  io_request_lock LOCKED
+ **************************************************************************/
+int
+qla4xxx_eh_device_reset(struct scsi_cmnd *cmd){
+	int ret_status = FAILED;
+	scsi_qla_host_t *ha;
+	os_lun_t     *lun_entry;
+	os_tgt_t         *tgt_entry;
+	fc_lun_t        *fclun;
+
+	ENTER("qla4xxx_eh_device_reset");
+
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	QL4PRINT(QLP2,
+		 printk(KERN_INFO "scsi%d:%d:%d:%d: device reset\n",
+			ha->host_no, cmd->device->channel, cmd->device->id,
+			cmd->device->lun));
+
+	// qla4xxx_extend_timeout(cmd, (ql4xcmdtimeout-1)*EXTEND_CMD_TOV);
+
+	/* retrieve device and lun handles */
+	tgt_entry = qla4xxx_lookup_target_by_SCSIID(ha, cmd->device->channel,
+	    cmd->device->id);
+	if (tgt_entry) {
+		/*
+		 * If we are coming in from the back-door, stall I/O until
+		 * complete.
+		 */
+		if (!cmd->device->host->eh_active)
+			set_bit(TQF_SUSPENDED, &tgt_entry->flags);
+		
+		lun_entry = qla4xxx_lookup_lun_handle(ha, tgt_entry,
+		    cmd->device->lun);
+		if (lun_entry) {
+			if ((fclun = lun_entry->fclun) != NULL) {
+				if (qla4xxx_reset_lun(ha, fclun->fcport->ddbptr, fclun)
+				    == QLA_SUCCESS) {
+					/* Send marker to unlock queues on next command */
+					ha->marker_needed =1;
+
+					/* Waiting for all active commands to complete for the device */
+					spin_lock_irq(ha->host->host_lock);
+					if (qla4xxx_eh_wait_for_active_target_commands(ha,
+					    cmd->device->id,
+					    cmd->device->lun) == 0)
+						ret_status = SUCCESS;
+					spin_unlock_irq(ha->host->host_lock);
+				}
+			}
+		}
+		if (!cmd->device->host->eh_active)
+			clear_bit(TQF_SUSPENDED, &tgt_entry->flags);
+	}
+
+
+	QL4PRINT(QLP2, printk("scsi%d: %s: return with status = %x\n",
+			      ha->host_no, __func__, ret_status));
+	LEAVE("qla4xxx_eh_device_reset");
+	return(ret_status);
+}
+
+/**************************************************************************
+ * qla4xxx_eh_bus_reset
+ *      This routine is called by the Linux OS to reset the specified
+ *      adapter/bus.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Returns:
+ *      SUCCESS - Successfully reset adapter/bus
+ *      FAILED  - Failed to reset adapter/bus
+ *
+ * Context:
+ *      Kernel context.  io_request_lock LOCKED
+ **************************************************************************/
+int
+qla4xxx_eh_bus_reset(struct scsi_cmnd *cmd){
+	uint8_t status = QLA_SUCCESS;
+	int     ret_status;
+	scsi_qla_host_t *ha;
+	ddb_entry_t *ddb_entry, *dtemp;
+
+	ENTER("qla4xxx_eh_bus_reset");
+
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+	QL4PRINT(QLP2,
+		 printk(KERN_INFO "scsi%d:%d: bus reset\n", ha->host_no,
+			 cmd->device->channel));
+
+	/* Attempt to reset all valid targets with outstanding commands */
+	list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list_entry) {
+		if (WAIT_FOR_ADAPTER_UP(ha) != QLA_SUCCESS) {
+			QL4PRINT(QLP2, printk("scsi%d:%d: %s: Unable to reset "
+			    "bus.  Adapter DEAD.\n", ha->host_no,
+			    cmd->device->channel, __func__));
+
+			ret_status = FAILED;
+			goto exit_bus_rst;
+		}
+
+		QL4PRINT(QLP5, printk("scsi%d: %s: reset target b%d, t%x, "
+		    "index [%d]\n", ha->host_no, __func__, ddb_entry->bus,
+		    ddb_entry->target, ddb_entry->fw_ddb_index));
+
+		/* Issue a reset */
+		status |= qla4xxx_reset_target(ha, ddb_entry);
+	}
+
+	/*
+	 * Status is QLA_SUCCESS if target resets for ALL devices completed
+	 * successfully.  Otherwise the status is QLA_ERROR.
+	 */
+	if (status == QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "scsi%d:%d: bus reset SUCCEEDED\n",
+				ha->host_no, cmd->device->channel));
+
+		/* restore debug level */
+		ret_status = SUCCESS;
+	}
+	else {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "scsi%d:%d: bus reset FAILED\n",
+				ha->host_no, cmd->device->channel));
+		ret_status = FAILED;
+	}
+
+	exit_bus_rst:
+	QL4PRINT(QLP2, printk("scsi%d: %s: return with status = %x\n",
+			      ha->host_no, __func__, ret_status));
+	LEAVE("qla4xxx_eh_bus_reset");
+	return(ret_status);
+}
+
+/**************************************************************************
+ * qla4xxx_reset_target
+ *      This routine issues either a warm or cold target reset to the
+ *      specified device.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *      ddb_entry - Pointer to device database entry
+ *
+ * Remarks:
+ *      The caller must ensure that the ddb_entry pointer is valid before
+ *      calling this routine.
+ *
+ * Returns:
+ *      QLA_SUCCESS - Successfully reset target
+ *      QLA_ERROR   - Failed to reset target
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+uint8_t qla4xxx_reset_target(scsi_qla_host_t *ha,
+			     ddb_entry_t *ddb_entry){
+	uint8_t status = QLA_SUCCESS;
+	fc_lun_t *fclun;
+	fc_port_t *fcport;
+
+	/* Reset all LUNs on this target */
+	fcport = ddb_entry->fcport;
+	list_for_each_entry(fclun, &fcport->fcluns, list){
+		if (qla4xxx_reset_lun(ha, ddb_entry, fclun) == QLA_SUCCESS) {
+			/* Send marker to unlock queues on next command */
+			ha->marker_needed =1;
+
+			/* Waiting for all active commands to complete for the device */
+			spin_lock_irq(ha->host->host_lock);
+			status |= qla4xxx_eh_wait_for_active_target_commands(ha, ddb_entry->target, fclun->lun);
+			spin_unlock_irq(ha->host->host_lock);
+		}
+		else {
+			status |= QLA_ERROR;
+		}
+	}
+
+	if (status == QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "scsi%d:%d:%d: device reset SUCCEEDED\n",
+				ha->host_no, ddb_entry->bus, fcport->os_target_id));
+	}
+	else {
+		QL4PRINT(QLP2,
+			 printk(KERN_INFO "scsi%d:%d:%d: device reset FAILED\n",
+				ha->host_no, ddb_entry->bus, fcport->os_target_id));
+		status = QLA_ERROR;
+	}
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4xxx_flush_active_srbs
+ *      This routine is called just prior to a HARD RESET to return all
+ *      outstanding commands back to the Operating System.
+ *
+ * Input:
+ *      ha - Pointer to host adapter structure.
+ *
+ * Remarks:
+ *      Caller should make sure that the following locks are released
+ *      before this calling routine:
+ *              Hardware lock, io_request_lock, adapter_lock, and lun_lock.
+ *
+ * Returns:
+ *      None
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_flush_active_srbs(scsi_qla_host_t *ha){
+	srb_t    *srb;
+	int      i;
+	unsigned long flags;
+
+	ENTER("qla4xxx_flush_active_srbs");
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (i = 1; i < MAX_SRBS; i++) {
+		if ((srb = ha->active_srb_array[i]) != NULL) {
+			QL4PRINT(QLP5,
+				 printk("scsi%d: %s: found srb %p in active array, "
+					"returning\n", ha->host_no, __func__, srb));
+			del_from_active_array(ha, i);
+			srb->cmd->result =  DID_RESET  <<  16;
+			add_to_done_srb_q(ha,srb);
+		}
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	// if (!list_empty(&ha->done_srb_q)) {
+	// while ((srb = del_from_done_srb_q_head(ha)) != NULL)
+	// qla4xxx_complete_request(ha, srb);
+	// }
+
+	LEAVE("qla4xxx_flush_active_srbs");
+}
+
+/**************************************************************************
+ * qla4xxx_eh_host_reset
+ *      This routine is invoked by the Linux kernel to perform fatal error
+ *      recovery on the specified adapter.
+ *
+ * Input:
+ *      cmd - Pointer to Linux's SCSI command structure
+ *
+ * Returns:
+ *      SUCCESS - Successfully recovered host adapter
+ *      FAILED  - Failed to recover host adapter
+ *
+ * Context:
+ *      Kernel context.  io_request_lock LOCKED
+ **************************************************************************/
+int
+qla4xxx_eh_host_reset(struct scsi_cmnd *cmd){
+	int ret_status;
+	scsi_qla_host_t *ha;
+	ENTER("qla4xxx_eh_host_reset");
+
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+	QL4PRINT(QLP2,
+		 printk(KERN_INFO "scsi%d: - host reset\n", ha->host_no));
+
+	if (WAIT_FOR_ADAPTER_UP(ha) != QLA_SUCCESS) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: Unable to reset host.  "
+				      "Adapter DEAD.\n",
+				      ha->host_no, __func__));
+
+		ret_status = FAILED;
+		goto exit_host_rst;
+	}
+
+	spin_unlock_irq(ha->host->host_lock);
+	if (qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST)
+	    == QLA_SUCCESS) {
+		ret_status = SUCCESS;
+	}
+	else {
+		ret_status = FAILED;
+	}
+	spin_lock_irq(ha->host->host_lock);
+
+exit_host_rst:
+	QL4PRINT(QLP2, printk("scsi%d: %s: return with status = %x\n",
+			      ha->host_no, __func__, ret_status));
+
+	LEAVE("qla4xxx_eh_host_reset");
+
+	return(ret_status);
+}
+
+/*
+* qla4xxx_free_other_mem
+*      Frees all adapter allocated memory.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+static void
+qla4xxx_free_other_mem(scsi_qla_host_t *ha)
+{
+	uint32_t        t;
+	fc_port_t       *fcport, *fptemp;
+	fc_lun_t        *fclun, *fltemp;
+
+	if (ha == NULL) {
+		/* error */
+		DEBUG2(printk("%s(): ERROR invalid ha pointer.\n", __func__));
+		return;
+	}
+
+	/* Free the target and lun queues */
+	for (t = 0; t < MAX_TARGETS; t++) {
+		qla4xxx_tgt_free(ha, t);
+	}
+
+	/* Free fcport and fcluns */
+	list_for_each_entry_safe(fcport, fptemp, &ha->fcports, list) {
+		list_for_each_entry_safe(fclun, fltemp, &fcport->fcluns, list) {
+			list_del_init(&fclun->list);
+			kfree(fclun);
+		}
+		list_del_init(&fcport->list);
+		kfree(fcport);
+	}
+	INIT_LIST_HEAD(&ha->fcports);
+}
+
+
+#if 0
+
+/**************************************************************************
+* qla4xxx_get_line
+*       Copy a substring from the specified string. The substring
+*       consists of any number of chars seperated by white spaces
+*       (i.e. spaces) and ending with a newline '\n' or a semicolon ';'.
+*
+* Enter:
+*       str - orig string
+*       line - substring
+*
+* Returns:
+*       cp - pointer to next string, or
+*       null - End of string
+*
+* Context:
+*       Kernel context.
+*************************************************************/
+static char *
+qla4xxx_get_line(char *str, char *line)
+{
+	register        char    *cp = str;
+	register        char    *sp = line;
+
+	/* skip preceeding spaces */
+	while (*cp && *cp == ' ')
+		++cp;
+	while ((*cp) && *cp != '\n' && *cp != ';')   /* end of line */
+		*sp++ = *cp++;
+
+	*sp = '\0';
+
+	QL4PRINT(QLP7, printk("%s: %s\n", __func__, line));
+
+	if ((*cp)) {
+		cp++;
+		return(cp);
+	}
+
+	return(NULL);
+}
+
+/**************************************************************************
+ * qla4xxx_get_tokens
+ *      This routine retrieves a token from the command line.
+ *
+ * Input:
+ *      line - Pointer to command line
+ *      argv - Pointer to arguements
+ *      str -  Pointer to starting point of symbol
+ *
+ * Output:
+ *      count - Number of tokens retrieved
+ *
+ * Remarks:
+ *      None
+ *
+ * Returns:
+ *      Pointer to command Line after token is retrieved.
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static int
+qla4xxx_get_tokens(char *line, char **argv, int maxargs )
+{
+	register        char    *cp = line;
+	int     count = 0;
+
+	while (*cp && count < maxargs) {
+		/* skip preceeding spaces */
+		while ((*cp) && *cp == ' ')
+			++cp;
+		/* symbol starts here */
+		argv[count++] = cp;
+		/* skip symbols */
+		while ((*cp) && !(*cp == ' ' || *cp == ';' || *cp == ':'))
+			cp++;
+		/* replace comma or space with a null */
+		if ((*cp) && (*cp ==' ' ) && argv[count-1] != cp)
+			*cp++ = '\0';
+	}
+	return(count);
+}
+
+/*
+ * Create character driver "HbaApiDev" w dynamically allocated major number
+ * and create "/proc/scsi/<QLA4XXX_PROC_NAME>/HbaApiNode" as the device
+ * node associated with the major number.
+ */
+#define APIDEV_NODE  "HbaApiNode"
+#define APIDEV_NAME  "HbaApiDev"
+
+static int apidev_major = 0;
+static struct Scsi_Host *apidev_host = 0;
+
+int apidev_cleanup(void);
+int apidev_init(struct Scsi_Host *host);
+
+/**************************************************************************
+ * apidev_open
+ *      This routine is invoked just prior to every IOCTL call.  We only
+ *      display debug information.
+ *
+ * Input:
+ *      Unused
+ *
+ * Returns:
+ *      0 - Always returns successful
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static int
+apidev_open(struct inode *inode, struct file *file){
+	QL4PRINT(QLP4, printk("scsi: apidev_open MAJOR number = %d, "
+			      "MINOR number = %d\n",
+			      MAJOR (inode->i_rdev),
+			      MINOR (inode->i_rdev)));
+	return(0);
+}
+
+/**************************************************************************
+ * apidev_close
+ *      This routine is invoked just after every IOCTL call.  We only
+ *      display debug information.
+ *
+ * Input:
+ *      Unused
+ *
+ * Returns:
+ *      0 - Always returns successful
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static int
+apidev_close(struct inode *inode, struct file *file){
+	QL4PRINT(QLP4, printk("scsi: apidev_close\n"));
+	return(0);
+}
+
+/**************************************************************************
+ * apidev_ioctl
+ *      This routine is invoked whenever an ioctl call is made.  It in turn
+ *      calls the IOCTL function for this driver.
+ *
+ * Input:
+ *      inode - unused
+ *      fp    - unused
+ *      cmd - internal or external ioctl command code
+ *      arg - pointer to ioctl structure
+ *
+ * Output:
+ *      None
+ *
+ * Returns:
+ *       QLA_SUCCESS - IOCTL completed successfully
+ *       QLA_ERROR   - IOCTL completed in error
+ *      -EFAULT      - if the arg pointer is NULL
+ *      -EINVAL      - if the command is invalid
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+static int
+apidev_ioctl(struct inode *inode, struct file *fp,
+	     unsigned int cmd, unsigned long arg){
+	static struct scsi_device fake_scsi_device;
+	fake_scsi_device.host = apidev_host;
+	return(qla4xxx_ioctl(&fake_scsi_device, (int)cmd, (void*)arg));
+}
+
+static struct file_operations
+apidev_fops = {
+	ioctl:    apidev_ioctl,
+	open:     apidev_open,
+	release:  apidev_close
+};
+
+/**************************************************************************
+ * apidev_init
+ *      This routine creates a proc file for IOCTL interface.
+ *
+ * Input:
+ *      None
+ *
+ * Output:
+ *      apidev_host - Updated with desired host number.
+ *      apidev_major - Registered.
+ *
+ * Remarks:
+ *      Create character driver "HbaApiDev" w dynamically allocated major
+ *      number and create "/proc/scsi/qla4xxx/HbaApiNode" as
+ *      the device node associated with the major number.
+ *
+ * Returns:
+ *      0 - Always returns successful
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+apidev_init(struct Scsi_Host *host){
+	if (apidev_host) return(0);
+
+	if (0 > (apidev_major = register_chrdev(0, APIDEV_NAME, &apidev_fops))) {
+		QL4PRINT(QLP4|QLP7,
+			 printk("scsi: apidev_init: rc=%d\n",
+				apidev_major));
+		return(apidev_major);
+	}
+
+	apidev_host = host;
+	QL4PRINT(QLP4|QLP7,
+		 printk("scsi: Created /proc/scsi/qla4xxx/%s major=%d\n",
+			APIDEV_NODE, apidev_major));
+
+	proc_mknod(APIDEV_NODE,
+		   0600+S_IFCHR,
+		   host->hostt->proc_dir,
+		   (kdev_t)MKDEV(apidev_major,0));
+
+	return(0);
+}
+
+/**************************************************************************
+ * apidev_cleanup
+ *      This routine removes the proc file for the IOCTL interface
+ *
+ * Input:
+ *      None
+ *
+ * Output:
+ *      apidev_host - Cleared.
+ *      apidev_major - Unregistered.
+ *
+ * Returns:
+ *      0 - Always returns successful
+ *
+ * Context:
+ *      Kernel context.
+ **************************************************************************/
+int
+apidev_cleanup(void){
+	if (!apidev_host) return(0);
+	unregister_chrdev(apidev_major,APIDEV_NAME);
+
+	QL4PRINT(QLP4|QLP7, printk("scsi: apidev_cleanup\n"));
+	remove_proc_entry(APIDEV_NODE,apidev_host->hostt->proc_dir);
+	apidev_host = 0;
+	return(0);
+}
+#endif
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
+
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_os.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_os.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_os.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_os.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,136 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ****************************************************************************/
+#ifndef _QL4_OS_H_
+#define _QL4_OS_H_
+
+#define __KERNEL_SYSCALLS__
+#define SHUTDOWN_SIGS	(sigmask(SIGHUP))
+
+
+#define HOST_STS_TBL(){		  \
+	"DID_OK",                 \
+	"DID_NO_CONNECT",         \
+	"DID_BUS_BUSY",           \
+	"DID_TIME_OUT",           \
+	"DID_BAD_TARGET",         \
+	"DID_ABORT",              \
+	"DID_PARITY",             \
+	"DID_ERROR",              \
+	"DID_RESET",              \
+	"DID_BAD_INTR",           \
+	NULL			  \
+}
+
+/*---------------------------------------------------------------------------*/
+
+/* We use the Scsi_Pointer structure that's included with each command
+ * SCSI_Cmnd as a scratchpad for our SRB.
+ */
+#define CMD_SP(Cmnd)	    ((Cmnd)->SCp.ptr)
+
+/* Additional fields used by ioctl passthru */
+#define CMD_PASSTHRU_TYPE(Cmnd) (((Cmnd)->SCp.buffer))
+#define CMD_COMPL_STATUS(Cmnd)  ((Cmnd)->SCp.this_residual)
+#define CMD_RESID_LEN(Cmnd)     ((Cmnd)->SCp.buffers_residual)
+#define CMD_SCSI_STATUS(Cmnd)   ((Cmnd)->SCp.Status)
+#define CMD_ACTUAL_SNSLEN(Cmnd) ((Cmnd)->SCp.have_data_in)
+#define CMD_HOST_STATUS(Cmnd)   ((Cmnd)->SCp.Message)
+#define CMD_ISCSI_RESPONSE(Cmnd)((Cmnd)->SCp.sent_command)
+#define CMD_STATE_FLAGS(Cmnd)   ((Cmnd)->SCp.phase)
+
+
+/*
+ * SCSI definitions not defined in Linux's scsi.h
+ */
+
+/* The SCSISTAT values are defined in scsi.h,
+ * but the values are shifted by one bit.
+ * We re-define them here without bit shifting
+ * to minimize confusion */
+#define SCSISTAT_GOOD			0x00
+#define SCSISTAT_CHECK_CONDITION	0x02
+#define SCSISTAT_CONDITION_GOOD		0x04
+#define SCSISTAT_BUSY			0x08
+#define SCSISTAT_INTERMEDIATE_GOOD  	0x10
+#define SCSISTAT_INTERMEDIATE_C_GOOD  	0x14
+#define SCSISTAT_RESERVATION_CONFLICT 	0x18
+#define SCSISTAT_COMMAND_TERMINATED   	0x22
+#define SCSISTAT_QUEUE_FULL           	0x28
+
+
+/* SAM-II compliant lun structure */
+typedef struct {
+	uint8_t bus_identifier:6;
+	uint8_t address_method:2;
+
+	uint8_t single_level_lun;
+	uint16_t second_level_lun;
+	uint16_t third_level_lun;
+	uint16_t fourth_level_lun;
+} single_level_lun_t;
+
+typedef struct {
+	uint32_t lun_list_length;
+	uint8_t reserved[4];
+	single_level_lun_t lun[MAX_LUNS];
+} report_luns_t;
+
+
+
+
+/*
+ * Declarations for load module
+ *
+ * Scsi_Host_template (see drivers/scsi/hosts.h)
+ * Device driver Interfaces to mid-level SCSI driver.
+ */
+
+#if 0
+
+//FIXME: Add above, then test
+TEMPLATE_HIGHMEM_IO                                             \
+TEMPLATE_CAN_DMA_32                                             \
+TEMPLATE_SINGLE_SG_OK                                           \
+TEMPLATE_CAN_DO_VARYIO                                          \
+TEMPLATE_VARY_IO                                                \
+
+#endif
+
+#endif  /* _QL4_OS_H_ */
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_settings.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_settings.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_settings.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_settings.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,84 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *
+ ****************************************************************************/
+
+/*
+ * Compile time Options:
+ *            0 - Disable and 1 - Enable
+ ****************************************/
+
+/*
+ * The following compile time options are temporary,
+ * used for debug purposes only.
+ ****************************************/
+#define ISP_RESET_TEST		0 /* Issues BIG HAMMER (reset) every 3 minutes */
+#define BYTE_ORDER_SUPPORT_ENABLED 0 /* In the process of translating IOCTL structures */
+
+/*
+ * Under heavy I/O on SMP systems (8-way and IA64) with many command
+ * timeouts, the scsi mid-layer will sometimes not wake-up the
+ * error-handling thread when an error-condition occurs.
+ *
+ * This workaround, if enabled, will wakeup the error-handler if it is
+ * stuck in this condition for sixty seconds.
+ ****************************************/
+#define EH_WAKEUP_WORKAROUND		0
+#if SH_HAS_ATOMIC_HOST_BUSY  /* defined in makefile */
+#define HOST_BUSY(ha)	atomic_read(&ha->host->host_busy)
+#else
+#define HOST_BUSY(ha)	ha->host->host_busy
+#endif
+
+
+/*
+ * Compile time Options:
+ *     0 - Disable and 1 - Enable
+ */
+#define DEBUG_QLA4xx		0	/* For Debug of qla4xxx */
+
+/* Failover options */
+#define MAX_RECOVERYTIME	10	/*
+					 * Max suspend time for a lun recovery
+					 * time
+					 */
+#define MAX_FAILBACKTIME	5	/* Max suspend time before fail back */
+
+#define EXTEND_CMD_TIMEOUT	60
+#if 0
+/* 
+ * When a lun is suspended for the "Not Ready" condition then it will suspend
+ * the lun for increments of 6 sec delays.  SUSPEND_COUNT is that count.
+ */
+#define SUSPEND_COUNT		10	/* 6 secs * 10 retries = 60 secs */
+
+/*
+ * Defines the time in seconds that the driver extends the command timeout to
+ * get around the problem where the mid-layer only allows 5 retries for
+ * commands that return BUS_BUSY
+ */
+
+#define MAX_RETRIES_OF_ISP_ABORT	5
+
+//#include "ql4_version.h"
+#endif
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_version.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_version.h
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_version.h	2004-10-13 22:53:24.000000000 +0200
@@ -0,0 +1,24 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ ****************************************************************************/
+
+#define QLA4XXX_DRIVER_VERSION      "5.00.01b10"
+
+#define QL4_DRIVER_MAJOR_VER	5
+#define QL4_DRIVER_MINOR_VER	0
+#define QL4_DRIVER_PATCH_VER	1
+#define QL4_DRIVER_BETA_VER	10
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/ql4_xioct.c linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_xioct.c
--- linux-2.6.5/drivers/scsi/qla4xxx/ql4_xioct.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/ql4_xioct.c	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,4423 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE                                     *
+ *                                                                            *
+ * QLogic ISP4xxx device driver for Linux 2.4.x                               *
+ * Copyright (C) 2004 Qlogic Corporation                                      *
+ * (www.qlogic.com)                                                           *
+ *                                                                            *
+ * This program is free software; you can redistribute it and/or modify it    *
+ * under the terms of the GNU General Public License as published by the      *
+ * Free Software Foundation; either version 2, or (at your option) any        *
+ * later version.                                                             *
+ *                                                                            *
+ * This program is distributed in the hope that it will be useful, but        *
+ * WITHOUT ANY WARRANTY; without even the implied warranty of                 *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *
+ * General Public License for more details.                                   *
+ *                                                                            *
+ ******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ *	qla4extioctl_query_hba_iscsi_node
+ *	qla4extioctl_query_hba_iscsi_portal
+ *	qla4extioctl_query_disc_iscsi_node
+ *	qla4extioctl_query_disc_iscsi_portal
+ *	qla4extioctl_query_driver
+ *	qla4extioctl_query_fw
+ *	qla4extioctl_query_chip
+ *	qla4extioctl_query
+ *	qla4extioctl_reg_aen
+ *	qla4extioctl_get_aen
+ *	qla4extioctl_get_statistics_gen
+ *	qla4extioctl_get_statistics_iscsi
+ *	qla4extioctl_get_device_entry_iscsi
+ *	qla4extioctl_get_init_fw_iscsi
+ *	qla4extioctl_get_isns_server
+ *	qla4extioctl_get_isns_disc_targets
+ *	qla4extioctl_get_data
+ *	qla4extioctl_rst_statistics_gen
+ *	qla4extioctl_rst_statistics_iscsi
+ *	qla4extioctl_set_device_entry_iscsi
+ *	qla4extioctl_set_init_fw_iscsi
+ *	qla4extioctl_set_isns_server
+ *	qla4extioctl_set_data
+ *	qla4xxx_ioctl_sleep_done
+ *	qla4xxx_ioctl_sem_init
+ *	qla4xxx_scsi_pass_done
+ *	qla4extioctl_scsi_passthru
+ *	qla4extioctl_iscsi_passthru
+ *	qla4extioctl_get_hbacnt
+ *	qla4xxx_ioctl
+ ****************************************************************************/
+
+#include "ql4_def.h"
+
+#include "ql4_ioctl.h"
+#include "qlinioct.h"
+#if defined(QLA_CONFIG_COMPAT)
+#include "ql4_32ioctl.h"
+#endif
+
+#define QLA_IOCTL_SCRAP_SIZE		17000 /* scrap memory for local use. */
+#define STATIC
+
+/*
+ * Externs from ql4_inioct.c
+ */
+extern int qla4intioctl_logout_iscsi(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+extern int qla4intioctl_ping(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+extern int qla4intioctl_get_data(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+extern int qla4intioctl_set_data(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+extern int qla4intioctl_hba_reset(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+extern int qla4intioctl_copy_fw_flash(scsi_qla_host_t *, EXT_IOCTL_ISCSI *);
+
+/*
+ * extern from ql4_nfoioctl.c
+ */
+extern int qla4xxx_nfo_ioctl(struct scsi_device *, int, void *);
+
+/* local function prototypes */
+int
+qla4xxx_ioctl(struct scsi_device *, int, void *);
+
+/*
+ * ioctl initialization
+ */
+static struct class_simple *apidev_class;
+static int apidev_major;
+
+static int 
+apidev_ioctl(struct inode *inode, struct file *fp, unsigned int cmd,
+    unsigned long arg) 
+{
+	return (qla4xxx_ioctl(NULL, (int)cmd, (void*)arg));
+}
+
+static struct file_operations apidev_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = apidev_ioctl,
+};
+
+void *
+ql4_kzmalloc(int siz, int code)
+{
+	void *		bp;
+
+	if ((bp = kmalloc(siz, code)) != NULL) {
+		memset(bp, 0, siz);
+	}
+
+	return (bp);
+}
+
+
+/*
+ * qla4xxx_alloc_ioctl_mem
+ *	Allocates memory needed by IOCTL code.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *
+ * Returns:
+ *	ql4xxx local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla4xxx_alloc_ioctl_mem(scsi_qla_host_t *ha)
+{
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	/* Allocate IOCTL DMA Buffer
+	 * ------------------------- */
+	ha->ioctl_dma_buf_len = DMA_BUFFER_SIZE;
+	ha->ioctl_dma_bufv = pci_alloc_consistent(ha->pdev,
+	    ha->ioctl_dma_buf_len, &ha->ioctl_dma_bufp);
+	if (ha->ioctl_dma_bufv == NULL) {
+		printk(KERN_WARNING
+		    "qla4xxx(%d): Memory Allocation failed - "
+		    "IOCTL DMA buffer.\n", ha->host_no);
+
+		return QLA_ERROR;
+	}
+
+	memset(ha->ioctl_dma_bufv, 0, ha->ioctl_dma_buf_len);
+	QL4PRINT(QLP4|QLP7,
+	    printk("scsi%d: %s: IOCTL DMAv = 0x%p\n",
+	    ha->host_no, __func__, ha->ioctl_dma_bufv));
+	QL4PRINT(QLP4|QLP7,
+	    printk("scsi%d: %s: IOCTL DMAp = 0x%lx\n",
+	    ha->host_no, __func__, (unsigned long)ha->ioctl_dma_bufp));
+
+	/* Allocate context memory buffer */
+	ha->ioctl = QL_KMEM_ZALLOC(sizeof(hba_ioctl_context));
+	if (ha->ioctl == NULL) {
+		/* error */
+		printk(KERN_WARNING
+		    "ql4xxx(%d): ERROR in ioctl context allocation.\n",
+		    ha->host_no);
+		return QLA_ERROR;
+	}
+
+	/* Allocate AEN tracking buffer */
+	ha->ioctl->aen_tracking_queue =
+	    QL_KMEM_ZALLOC(EXT_DEF_MAX_AEN_QUEUE * sizeof(EXT_ASYNC_EVENT));
+	if (ha->ioctl->aen_tracking_queue == NULL) {
+		printk(KERN_WARNING
+		    "ql4xxx(%d): ERROR in ioctl aen_queue allocation.\n",
+		    ha->host_no);
+		return QLA_ERROR;
+	}
+
+	/* Pick the largest size we'll need per ha of all ioctl cmds.
+	 * Use this size when freeing.
+	 */
+	ha->ioctl->scrap_mem = QL_KMEM_ZALLOC(QLA_IOCTL_SCRAP_SIZE);
+	if (ha->ioctl->scrap_mem == NULL) {
+		printk(KERN_WARNING
+		    "ql4xxx(%d): ERROR in ioctl scrap_mem allocation.\n",
+		    ha->host_no);
+		return QLA_ERROR;
+	}
+	ha->ioctl->scrap_mem_size = QLA_IOCTL_SCRAP_SIZE;
+	ha->ioctl->scrap_mem_used = 0;
+
+	QL4PRINT(QLP4|QLP7,
+	    printk("scsi(%d): %s: scrap_mem_size=%d.\n",
+	    ha->host_no, __func__, ha->ioctl->scrap_mem_size));
+
+	QL4PRINT(QLP4,
+	    printk("scsi(%d): %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	LEAVE(__func__);
+	return QLA_SUCCESS;
+}
+
+/*
+ * qla4xxx_free_ioctl_mem
+ *	Frees memory used by IOCTL code for the specified ha.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+void
+qla4xxx_free_ioctl_mem(scsi_qla_host_t *ha)
+{
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (ha->ioctl != NULL) {
+
+		if (ha->ioctl->scrap_mem != NULL) {
+			/* The size here must match up to what we
+			 * allocated before.
+			 */
+			QL_KMEM_FREE(ha->ioctl->scrap_mem);
+			ha->ioctl->scrap_mem = NULL;
+			ha->ioctl->scrap_mem_size = 0;
+		}
+
+		if (ha->ioctl->aen_tracking_queue != NULL) {
+			QL_KMEM_FREE(ha->ioctl->aen_tracking_queue);
+			ha->ioctl->aen_tracking_queue = NULL;
+		}
+
+		QL_KMEM_FREE(ha->ioctl);
+		ha->ioctl = NULL;
+	}
+
+	if (ha->ioctl_dma_bufv) {
+		QL4PRINT(QLP4|QLP7,
+		    printk("scsi%d: %s: freeing IOCTL DMA Buffers\n",
+		    ha->host_no, __func__));
+		pci_free_consistent(ha->pdev, ha->ioctl_dma_buf_len,
+		    ha->ioctl_dma_bufv, ha->ioctl_dma_bufp);
+	}
+	ha->ioctl_dma_buf_len = 0;
+	ha->ioctl_dma_bufv = 0;
+	ha->ioctl_dma_bufp = 0;
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+}
+
+/*
+ * qla4xxx_get_ioctl_scrap_mem
+ *	Returns pointer to memory of the specified size from the scrap buffer.
+ *	This can be called multiple times before the free call as long
+ *	as the memory is to be used by the same ioctl command and
+ *	there's still memory left in the scrap buffer.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	ppmem = pointer to return a buffer pointer.
+ *	size = size of buffer to return.
+ *
+ * Returns:
+ *	ql4xxx local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla4xxx_get_ioctl_scrap_mem(scsi_qla_host_t *ha, void **ppmem, uint32_t size)
+{
+	int		ret = QLA_SUCCESS;
+	uint32_t	free_mem;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	free_mem = ha->ioctl->scrap_mem_size - ha->ioctl->scrap_mem_used;
+
+	if (free_mem >= size) {
+		*ppmem = ha->ioctl->scrap_mem + ha->ioctl->scrap_mem_used;
+		ha->ioctl->scrap_mem_used += size;
+	} else {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi(%d): %s: no more scrap memory.\n",
+		    ha->host_no, __func__));
+
+		ret = QLA_ERROR;
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return (ret);
+}
+
+/*
+ * qla4xxx_free_ioctl_scrap_mem
+ *	Makes the entire scrap buffer free for use.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *
+ * Returns:
+ *	ql4xxx local function return status code.
+ *
+ */
+void
+qla4xxx_free_ioctl_scrap_mem(scsi_qla_host_t *ha)
+{
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	memset(ha->ioctl->scrap_mem, 0, ha->ioctl->scrap_mem_size);
+	ha->ioctl->scrap_mem_used = 0;
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+}
+
+int
+qla4xxx_ioctl_init(void)
+{
+	void * tmp;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi: %s: entered.\n",
+	    __func__));
+
+	apidev_class = class_simple_create(THIS_MODULE, "qla4xxx");
+	if (IS_ERR(apidev_class)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(): Unable to sysfs class for qla4xxx.\n",
+		    __func__));
+
+		apidev_class = NULL;
+		return 1;
+	}
+	QL4PRINT(QLP4,
+	    printk("scsi: %s: apidev_class=%p.\n",
+	    __func__, apidev_class));
+
+	apidev_major = register_chrdev(0, "qla4xxx", &apidev_fops);
+	if (apidev_major < 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(): Unable to register CHAR device (%d)\n",
+		    __func__, apidev_major));
+
+		class_simple_destroy(apidev_class);
+		apidev_class = NULL;
+
+		return apidev_major;
+	}
+	QL4PRINT(QLP4,
+	    printk("scsi: %s: apidev_major=%d.\n",
+	    __func__, apidev_major));
+
+	tmp = class_simple_device_add(apidev_class, MKDEV(apidev_major, 0),
+	    NULL, "qla4xxx");
+	QL4PRINT(QLP4,
+	    printk("scsi: %s: tmp=%p.\n",
+	    __func__, tmp));
+
+#if defined(QLA_CONFIG_COMPAT)
+	ql4_apidev_init_32ioctl();
+#endif
+
+	QL4PRINT(QLP4,
+	    printk("scsi: %s: exiting.\n",
+	    __func__));
+	LEAVE(__func__);
+
+	return 0;
+}
+
+int
+qla4xxx_ioctl_exit(void)
+{
+	ENTER(__func__);
+
+	if (!apidev_class)
+		return 1;
+
+#if defined(QLA_CONFIG_COMPAT)
+	ql4_apidev_cleanup_32ioctl();
+#endif
+
+	class_simple_device_remove(MKDEV(apidev_major, 0));
+
+	unregister_chrdev(apidev_major, "qla4xxx");
+
+	class_simple_destroy(apidev_class);
+
+	apidev_class = NULL;
+
+	LEAVE(__func__);
+
+	return 0;
+}
+
+/*
+ * ioctl support functions
+ */
+
+void *
+Q64BIT_TO_PTR(uint64_t buf_addr)
+{
+#if defined(QLA_CONFIG_COMPAT) || !defined(CONFIG_64BIT)
+	union ql_doublelong {
+		struct {
+			uint32_t        lsl;
+			uint32_t        msl;
+		} longs;
+		uint64_t        dl;
+	};
+
+	union ql_doublelong tmpval;
+
+	tmpval.dl = buf_addr;
+#if defined(QLA_CONFIG_COMPAT)
+	return((void *)(uint64_t)(tmpval.longs.lsl));
+#else
+	return((void *)(tmpval.longs.lsl));
+#endif
+#else
+	return((void *)buf_addr);
+#endif
+}
+
+/**************************************************************************
+ * qla4extioctl_query_hba_iscsi_node
+ *	This routine retrieves the HBA node properties
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_query_hba_iscsi_node(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_HBA_ISCSI_NODE	*phba_node = NULL;
+	INIT_FW_CTRL_BLK	*init_fw_cb;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&phba_node,
+	    sizeof(EXT_HBA_ISCSI_NODE))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_HBA_ISCSI_NODE)));
+		goto exit_query_hba_node;
+	}
+
+	if (!ha->ioctl_dma_bufv || !ha->ioctl_dma_bufp || !ioctl->ResponseAdr) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: memory allocation problem\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		goto exit_query_hba_node;
+	}
+
+	if (ioctl->ResponseLen < sizeof(EXT_HBA_ISCSI_NODE) ||
+	    ha->ioctl_dma_buf_len < sizeof(*init_fw_cb)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_hba_node;
+	}
+
+	/*
+	 * Send mailbox command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = MSDW(ha->ioctl_dma_bufp);
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+
+		goto exit_query_hba_node;
+	}
+
+	/*
+	 * Transfer data from Fw's DEV_DB_ENTRY buffer to IOCTL's
+	 * EXT_HBA_ISCSI_NODE buffer
+	 */
+	init_fw_cb = (INIT_FW_CTRL_BLK *) ha->ioctl_dma_bufv;
+
+	memset(phba_node, 0, sizeof(EXT_HBA_ISCSI_NODE));
+	phba_node->PortNumber = le16_to_cpu(init_fw_cb->PortNumber);
+	phba_node->NodeInfo.PortalCount = 1;
+
+	memcpy(phba_node->NodeInfo.IPAddr.IPAddress, init_fw_cb->IPAddr,
+	    sizeof(phba_node->NodeInfo.IPAddr.IPAddress));
+	memcpy(phba_node->NodeInfo.iSCSIName, init_fw_cb->iSCSINameString,
+	    sizeof(phba_node->NodeInfo.iSCSIName));
+	memcpy(phba_node->NodeInfo.Alias, init_fw_cb->Alias,
+	    sizeof(phba_node->NodeInfo.Alias));
+
+	sprintf(phba_node->DeviceName, "/proc/scsi/qla4xxx/%d",
+	    ha->host_no);
+
+	/*
+	 * Copy the IOCTL EXT_HBA_ISCSI_NODE buffer to the user's data space
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr), phba_node,
+	    ioctl->ResponseLen)) != 0) {
+		QL4PRINT(QLP2|QLP4, printk("scsi%d: %s: copy failed\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_query_hba_node;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_query_hba_node:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_query_hba_iscsi_portal
+ *	This routine retrieves the HBA iSCSI portal properties
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_query_hba_iscsi_portal(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	EXT_HBA_ISCSI_PORTAL *phba_portal;
+	FLASH_SYS_INFO *sys_info;
+	uint32_t num_valid_ddb_entries;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (!ioctl->ResponseAdr) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: no response buffer found.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		goto exit_query_hba_portal;
+	}
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&phba_portal,
+	    sizeof(EXT_HBA_ISCSI_PORTAL))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_HBA_ISCSI_PORTAL)));
+		goto exit_query_hba_portal;
+	}
+
+	if (ioctl->ResponseLen < sizeof(*phba_portal)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_hba_portal;
+	}
+
+	/*
+	 * Fill in EXT_HBA_ISCSI_PORTAL buffer
+	 */
+	memset(phba_portal, 0, sizeof(EXT_HBA_ISCSI_PORTAL));
+
+	strcpy(phba_portal->DriverVersion, QLA4XXX_DRIVER_VERSION);
+	sprintf(phba_portal->FWVersion, "%02d.%02d Patch %02d Build %02d",
+		ha->firmware_version[0], ha->firmware_version[1],
+		ha->patch_number, ha->build_number);
+
+	/* ----- Get firmware state information ---- */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_FW_STATE;
+	if (qla4xxx_mailbox_command(ha, 1, 4, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4, printk("scsi%d: %s: MBOX_CMD_GET_FW_STATE "
+		    "failed w/ status %04X\n",
+		    ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+/* RLU: mailbox values should be stored in VendorSpecificStatus */
+		goto exit_query_hba_portal;
+	}
+
+	switch (mbox_sts[1]) {
+	case FW_STATE_READY:
+		phba_portal->State = EXT_DEF_CARD_STATE_READY;
+		break;
+	case FW_STATE_CONFIG_WAIT:
+		phba_portal->State = EXT_DEF_CARD_STATE_CONFIG_WAIT;
+		break;
+	case FW_STATE_WAIT_LOGIN:
+		phba_portal->State = EXT_DEF_CARD_STATE_LOGIN;
+		break;
+	case FW_STATE_ERROR:
+		phba_portal->State = EXT_DEF_CARD_STATE_ERROR;
+		break;
+	}
+
+	switch (mbox_sts[3] & 0x0001) {
+	case FW_ADDSTATE_COPPER_MEDIA:
+		phba_portal->Type = EXT_DEF_TYPE_COPPER;
+		break;
+	case FW_ADDSTATE_OPTICAL_MEDIA:
+		phba_portal->Type = EXT_DEF_TYPE_OPTICAL;
+		break;
+	}
+
+	/* ----- Get ddb entry information ---- */
+	if (qla4xxx_get_fwddb_entry(ha, 0, NULL, 0, &num_valid_ddb_entries,
+	    NULL, NULL, NULL, NULL, NULL) == QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: qla4xxx_get_ddb_entry failed!\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->RequestLen = 0;
+		ioctl->DetailStatus = ioctl->Instance;
+
+		goto exit_query_hba_portal;
+	}
+
+	phba_portal->DiscTargetCount = (uint16_t) num_valid_ddb_entries;
+
+	/* ----- Get flash sys info information ---- */
+	sys_info = (FLASH_SYS_INFO *) ha->ioctl_dma_bufv;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[2] = MSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = INT_ISCSI_SYSINFO_FLASH_OFFSET;
+	mbox_cmd[4] = sizeof(*sys_info);
+
+	if (qla4xxx_mailbox_command(ha, 5, 2, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: MBOX_CMD_READ_FLASH failed w/ "
+		    "status %04X\n",
+		    ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+/* RLU: mailbox values should be stored in VendorSpecificStatus */
+
+		goto exit_query_hba_portal;
+	}
+
+	phba_portal->SerialNum = le32_to_cpu(sys_info->serialNumber);
+	memcpy(phba_portal->IPAddr.IPAddress, ha->ip_address,
+	    MIN(sizeof(phba_portal->IPAddr.IPAddress), sizeof(ha->ip_address)));
+	memcpy(phba_portal->MacAddr, sys_info->physAddr[0].address,
+	    sizeof(phba_portal->MacAddr));
+	memcpy(phba_portal->Manufacturer, sys_info->vendorId,
+	    sizeof(phba_portal->Manufacturer));
+	memcpy(phba_portal->Model, sys_info->productId,
+	    sizeof(phba_portal->Model));
+
+	/*memcpy(phba_portal->OptRomVersion, ?,
+		sizeof(phba_portal->OptRomVersion)); */
+
+	/*
+	 * Copy the IOCTL EXT_HBA_ISCSI_PORTAL buffer to the user's data space
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    phba_portal, ioctl->ResponseLen)) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_query_hba_portal;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_query_hba_portal:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_query_disc_iscsi_node
+ *	This routine retrieves the properties of the attached devices
+ *	registered as iSCSI nodes discovered by the HBA driver.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_query_disc_iscsi_node(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	DEV_DB_ENTRY *fw_ddb_entry = (DEV_DB_ENTRY *) ha->ioctl_dma_bufv;
+	EXT_DISC_ISCSI_NODE *pdisc_node;
+	ddb_entry_t *ddb_entry;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (ioctl->ResponseLen < sizeof(EXT_DISC_ISCSI_NODE)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: response buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_disc_node;
+	}
+
+	if (ha->ioctl_dma_buf_len < sizeof(DEV_DB_ENTRY)) {
+		if (qla4xxx_resize_ioctl_dma_buf(ha, sizeof(DEV_DB_ENTRY)) !=
+		    QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+			    printk("scsi%d: %s: unable to allocate memory "
+			    "for dma buffer.\n",
+			    ha->host_no, __func__));
+			ioctl->Status = EXT_STATUS_NO_MEMORY;
+			goto exit_disc_node;
+		}
+	}
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pdisc_node,
+	    sizeof(EXT_DISC_ISCSI_NODE))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_DISC_ISCSI_NODE)));
+		goto exit_disc_node;
+	}
+
+	/* ----- get device database entry info from firmware ---- */
+	if (qla4xxx_get_fwddb_entry(ha, ioctl->Instance, fw_ddb_entry,
+	    ha->ioctl_dma_bufp, NULL, NULL, NULL, NULL, NULL, NULL) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: failed to get DEV_DB_ENTRY "
+		    "info.\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->RequestLen = 0;
+		ioctl->DetailStatus = ioctl->Instance;
+
+		goto exit_disc_node;
+	}
+
+	/* --- Transfer data from Fw's DEV_DB_ENTRY buffer to
+	*      IOCTL's EXT_DISC_ISCSI_PORTAL buffer --- */
+	memset(pdisc_node, 0, sizeof(EXT_DISC_ISCSI_NODE));
+	pdisc_node->NodeInfo.PortalCount = 1;
+	pdisc_node->NodeInfo.IPAddr.Type = EXT_DEF_TYPE_ISCSI_IP;
+	memcpy(pdisc_node->NodeInfo.IPAddr.IPAddress, fw_ddb_entry->ipAddr,
+	    MIN(sizeof(pdisc_node->NodeInfo.IPAddr.IPAddress),
+	    sizeof(fw_ddb_entry->ipAddr)));
+	strncpy(pdisc_node->NodeInfo.Alias, fw_ddb_entry->iSCSIAlias,
+	    MIN(sizeof(pdisc_node->NodeInfo.Alias),
+	    sizeof(fw_ddb_entry->iSCSIAlias)));
+	strncpy(pdisc_node->NodeInfo.iSCSIName, fw_ddb_entry->iscsiName,
+	    MIN(sizeof(pdisc_node->NodeInfo.iSCSIName),
+	    sizeof(fw_ddb_entry->iscsiName)));
+
+	if ((ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, ioctl->Instance))==
+	    NULL) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: device index [%d] not logged in. "
+		    "Dummy target info returned.\n",
+		    ha->host_no, __func__, ioctl->Instance));
+
+		pdisc_node->SessionID       = 0xDEAD;
+		pdisc_node->ConnectionID    = 0xDEAD;
+		pdisc_node->PortalGroupID   = 0xDEAD;
+		pdisc_node->ScsiAddr.Bus    = 0xFF;
+		pdisc_node->ScsiAddr.Target = 0xFF;
+		pdisc_node->ScsiAddr.Lun    = 0xFF;
+	}
+	else {
+		pdisc_node->SessionID       = ddb_entry->target_session_id;
+		pdisc_node->ConnectionID    = ddb_entry->connection_id;
+		pdisc_node->PortalGroupID   = 0;
+		pdisc_node->ScsiAddr.Bus    = ddb_entry->bus;
+		pdisc_node->ScsiAddr.Target = ddb_entry->target;
+		pdisc_node->ScsiAddr.Lun    = 0;
+	}
+
+	/* --- Copy Results to user space --- */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    pdisc_node, sizeof(EXT_DISC_ISCSI_NODE))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: copy error to user space.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_disc_node;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_disc_node:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_query_disc_iscsi_portal
+ *	This routine retrieves the properties of the iSCSI portal
+ *	discovered by the HBA driver.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_query_disc_iscsi_portal(scsi_qla_host_t *ha,
+    EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	DEV_DB_ENTRY *fw_ddb_entry = (DEV_DB_ENTRY *) ha->ioctl_dma_bufv;
+	EXT_DISC_ISCSI_PORTAL *pdisc_portal;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pdisc_portal,
+	    sizeof(EXT_DISC_ISCSI_PORTAL))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_DISC_ISCSI_PORTAL)));
+		goto exit_disc_portal;
+	}
+
+	if (ioctl->ResponseLen < sizeof(EXT_DISC_ISCSI_PORTAL)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: response buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_disc_portal;
+	}
+
+	if (ha->ioctl_dma_buf_len < sizeof(DEV_DB_ENTRY)) {
+		if (qla4xxx_resize_ioctl_dma_buf(ha, sizeof(DEV_DB_ENTRY)) !=
+		    QLA_SUCCESS) {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: unable to allocate memory "
+			    "for dma buffer.\n",
+			    ha->host_no, __func__));
+
+			ioctl->Status = EXT_STATUS_NO_MEMORY;
+			goto exit_disc_portal;
+		}
+	}
+
+	/* ----- get device database entry info from firmware ---- */
+	if (qla4xxx_get_fwddb_entry(ha, ioctl->Instance, fw_ddb_entry,
+	    ha->ioctl_dma_bufp, NULL, NULL, NULL, NULL, NULL, NULL) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: failed to get DEV_DB_ENTRY info.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->RequestLen = 0;
+		ioctl->DetailStatus = ioctl->Instance;
+		goto exit_disc_portal;
+	}
+
+	/* --- Transfer data from Fw's DEV_DB_ENTRY buffer to IOCTL's
+	*      EXT_DISC_ISCSI_PORTAL buffer --- */
+	memset(pdisc_portal, 0, sizeof(EXT_DISC_ISCSI_PORTAL));
+	memcpy(pdisc_portal->IPAddr.IPAddress, fw_ddb_entry->ipAddr,
+	    MIN(sizeof(pdisc_portal->IPAddr.IPAddress),
+	    sizeof(fw_ddb_entry->ipAddr)));
+
+	pdisc_portal->PortNumber = le16_to_cpu(fw_ddb_entry->portNumber);
+	pdisc_portal->IPAddr.Type = EXT_DEF_TYPE_ISCSI_IP;
+	pdisc_portal->NodeCount = 0;
+
+	strncpy(pdisc_portal->HostName, fw_ddb_entry->iscsiName,
+	    MIN(sizeof(pdisc_portal->HostName),
+	    sizeof(fw_ddb_entry->iscsiName)));
+
+	/* --- Copy Results to user space --- */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	     pdisc_portal, sizeof(EXT_DISC_ISCSI_PORTAL))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: copy error to user space.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_disc_portal;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_disc_portal:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_query_driver
+ *	This routine retrieves the driver properties.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_query_driver(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	EXT_DRIVER_INFO *pdinfo;
+	int status = 0;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pdinfo,
+	    sizeof(EXT_DRIVER_INFO))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_DRIVER_INFO)));
+		goto exit_query_driver;
+	}
+
+	if (ioctl->ResponseLen < sizeof(EXT_DRIVER_INFO)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: response buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_driver;
+	}
+
+	memset(pdinfo, 0, sizeof(EXT_DRIVER_INFO));
+	memcpy(pdinfo->Version, QLA4XXX_DRIVER_VERSION,
+	       sizeof(QLA4XXX_DRIVER_VERSION));
+
+	pdinfo->NumOfBus        = EXT_DEF_MAX_HBA;
+	pdinfo->TargetsPerBus   = EXT_DEF_MAX_TARGET;
+	pdinfo->LunPerTarget    = EXT_DEF_MAX_LUN;
+	pdinfo->LunPerTargetOS  = EXT_DEF_MAX_BUS;
+
+	if (sizeof(dma_addr_t) > 4)
+		pdinfo->DmaBitAddresses = 1;  /* 64-bit */
+	else
+		pdinfo->DmaBitAddresses = 0;  /* 32-bit */
+
+	if (ha->mem_addr)
+		pdinfo->IoMapType       = 1;
+	else
+		pdinfo->IoMapType       = 0;
+
+	//FIXME: Incomplete
+	//pdinfo->MaxTransferLen  = ?;
+	//pdinfo->MaxDataSegments = ?;
+	//pdinfo->Attrib          = ?;
+	//pdinfo->InternalFlags   = ?;
+
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr), pdinfo,
+	    sizeof(EXT_DRIVER_INFO))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi(%d): %s: error copy to response buffer.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_query_driver;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_query_driver:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_query_fw
+ *	This routine retrieves the firmware properties.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_query_fw(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	EXT_FW_INFO *pfw_info;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	int status = 0;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pfw_info,
+	    sizeof(EXT_FW_INFO))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_FW_INFO)));
+		goto exit_query_fw;
+	}
+
+	if (ioctl->ResponseLen < sizeof(EXT_FW_INFO)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: response buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_fw;
+	}
+
+	/* Fill in structure */
+	memset(pfw_info, 0, sizeof(EXT_FW_INFO));
+
+	/* ----- Get firmware version information ---- */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_ABOUT_FW;
+
+	/*
+	 * NOTE: In QLA4010, mailboxes 2 & 3 may hold an address for data.
+	 * Make sure that we write 0 to those mailboxes, if unused.
+	 */
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: MBOX_CMD_ABOUT_FW failed w/ "
+		    "status %04X\n",
+		    ha->host_no, __func__, mbox_sts[0]));
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+/* RLU: mailbox values should be stored in VendorSpecificStatus */
+		goto exit_query_fw;
+	}
+
+	sprintf(pfw_info->Version, "FW Version %d.%d Patch %d Build %d",
+	    mbox_sts[1], mbox_sts[2], mbox_sts[3], mbox_sts[4]);
+
+	/* Copy info to caller */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr), pfw_info,
+	    sizeof(EXT_FW_INFO))) != 0) {
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi(%d): %s: response copy error.\n",
+		    ha->host_no, __func__));
+
+		goto exit_query_fw;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_query_fw:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_query_chip
+ *	This routine retrieves the chip properties.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_query_chip(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_CHIP_INFO	*pchip_info;
+	FLASH_SYS_INFO	*sys_info;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pchip_info,
+	    sizeof(EXT_CHIP_INFO))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_CHIP_INFO)));
+		goto exit_query_chip;
+	}
+
+	if (!ioctl->ResponseAdr || ioctl->ResponseLen < sizeof(EXT_CHIP_INFO)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: response buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_chip;
+	}
+
+	/* Fill in structure */
+	memset(pchip_info, 0, sizeof(EXT_CHIP_INFO));
+
+	/* ----- Get flash sys info information ---- */
+	sys_info = (FLASH_SYS_INFO *) ha->ioctl_dma_bufv;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[2] = MSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = INT_ISCSI_SYSINFO_FLASH_OFFSET;
+	mbox_cmd[4] = sizeof(*sys_info);
+
+	if (qla4xxx_mailbox_command(ha, 5, 2, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: MBOX_CMD_READ_FLASH failed "
+		    "w/ status %04X\n",
+		    ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+/* RLU: mailbox values should be stored in VendorSpecificStatus */
+		goto exit_query_chip;
+	}
+
+	pchip_info->VendorId    = le32_to_cpu(sys_info->pciDeviceVendor);
+	pchip_info->DeviceId    = le32_to_cpu(sys_info->pciDeviceId);
+	pchip_info->SubVendorId = le32_to_cpu(sys_info->pciSubsysVendor);
+	pchip_info->SubSystemId = le32_to_cpu(sys_info->pciSubsysId);
+
+	/* ----- Get firmware state information ---- */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_FW_STATE;
+	if (qla4xxx_mailbox_command(ha, 1, 4, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: MBOX_CMD_GET_FW_STATE failed "
+		    "w/ status %04X\n",
+		    ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+/* RLU: mailbox values should be stored in VendorSpecificStatus */
+		goto exit_query_chip;
+	}
+
+	pchip_info->BoardID     = mbox_sts[2];
+
+	/* Copy info to caller */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    pchip_info, sizeof(EXT_CHIP_INFO))) != 0) {
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi(%d): %s: response copy error.\n",
+		    ha->host_no, __func__));
+
+		goto exit_query_chip;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_query_chip:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_query
+ *	This routine calls query IOCTLs based on the IOCTL Sub Code.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *    	-EINVAL     = if the command is invalid
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_query(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	switch (ioctl->SubCode) {
+	case EXT_SC_QUERY_HBA_ISCSI_NODE:
+		return(qla4extioctl_query_hba_iscsi_node(ha, ioctl));
+
+	case EXT_SC_QUERY_HBA_ISCSI_PORTAL:
+		return(qla4extioctl_query_hba_iscsi_portal(ha, ioctl));
+
+	case EXT_SC_QUERY_DISC_ISCSI_NODE:
+		return(qla4extioctl_query_disc_iscsi_node(ha, ioctl));
+
+	case EXT_SC_QUERY_DISC_ISCSI_PORTAL:
+		return(qla4extioctl_query_disc_iscsi_portal(ha, ioctl));
+
+	case EXT_SC_QUERY_DRIVER:
+		return(qla4extioctl_query_driver(ha, ioctl));
+
+	case EXT_SC_QUERY_FW:
+		return(qla4extioctl_query_fw(ha, ioctl));
+
+	case EXT_SC_QUERY_CHIP:
+		return(qla4extioctl_query_chip(ha, ioctl));
+
+	default:
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: unsupported query sub-command "
+		    "code (%x)\n",
+		    ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		return(0);
+	}
+}
+
+/**************************************************************************
+ * qla4extioctl_reg_aen
+ *	This routine enables/disables storing of asynchronous events
+ *	from the ISP into the driver's internal buffer.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_reg_aen(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+
+	ENTER(__func__);
+
+	ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: UNSUPPORTED\n", ha->host_no, __func__));
+
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_get_aen
+ *	This routine retrieves the contents of the driver's internal
+ *	asynchronous event tracking queue.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_aen(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+
+	ENTER("qla4extioctl_get_aen");
+
+	ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: UNSUPPORTED\n", ha->host_no, __func__));
+
+	LEAVE("qla4extioctl_get_aen");
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_get_statistics_gen
+ *	This routine retrieves the HBA general statistical information.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_statistics_gen(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	EXT_HBA_PORT_STAT_GEN	*pstat_gen;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pstat_gen,
+	    sizeof(EXT_HBA_PORT_STAT_GEN))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_HBA_PORT_STAT_GEN)));
+		goto exit_get_stat_gen;
+	}
+
+	if (ioctl->ResponseLen < sizeof(EXT_HBA_PORT_STAT_GEN)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_get_stat_gen;
+	}
+
+	/*
+	 * Fill in the data
+	 */
+	memset(pstat_gen, 0, sizeof(EXT_HBA_PORT_STAT_GEN));
+	pstat_gen->HBAPortErrorCount     = ha->adapter_error_count;
+	pstat_gen->DevicePortErrorCount  = ha->device_error_count;
+	pstat_gen->IoCount               = ha->total_io_count;
+	pstat_gen->MBytesCount           = ha->total_mbytes_xferred;
+	pstat_gen->InterruptCount        = ha->isr_count;
+	pstat_gen->LinkFailureCount      = ha->link_failure_count;
+	pstat_gen->InvalidCrcCount       = ha->invalid_crc_count;
+
+	/*
+	 * Copy the IOCTL EXT_HBA_PORT_STAT_GEN buffer to the user's data space
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr), pstat_gen,
+	    ioctl->ResponseLen)) != 0) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_stat_gen;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_get_stat_gen:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_get_statistics_iscsi
+ *	This routine retrieves the HBA iSCSI statistical information.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_statistics_iscsi(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	EXT_HBA_PORT_STAT_ISCSI* pstat_local;
+	EXT_HBA_PORT_STAT_ISCSI* pstat_user;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	pstat_user = kmalloc(sizeof(EXT_HBA_PORT_STAT_ISCSI), GFP_ATOMIC);
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pstat_user,
+	    sizeof(EXT_HBA_PORT_STAT_ISCSI))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_HBA_PORT_STAT_ISCSI)));
+		goto exit_get_stats_iscsi;
+	}
+
+	if (!ioctl->ResponseAdr || !ioctl->ResponseLen) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: invalid parameter\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_stats_iscsi;
+	}
+
+	if (ioctl->ResponseLen < sizeof(EXT_HBA_PORT_STAT_ISCSI)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: RespLen too small (0x%x),  "
+		    "need (0x%x).\n",
+		    ha->host_no, __func__, ioctl->ResponseLen,
+		    (unsigned int) sizeof(EXT_HBA_PORT_STAT_ISCSI)));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_get_stats_iscsi;
+	}
+
+	if ((ha->ioctl_dma_buf_len < sizeof(EXT_HBA_PORT_STAT_ISCSI)) &&
+	    (qla4xxx_resize_ioctl_dma_buf(ha, sizeof(EXT_HBA_PORT_STAT_ISCSI))
+	     != QLA_SUCCESS)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: unable to allocate memory "
+		    "for dma buffer.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		goto exit_get_stats_iscsi;
+	}
+
+	/*
+	 * Make the mailbox call
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_MANAGEMENT_DATA;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = MSDW(ha->ioctl_dma_bufp);
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: get mngmt data for index [%d] failed "
+		    "w/ mailbox ststus 0x%x\n",
+		    ha->host_no, __func__, ioctl->Instance, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_stats_iscsi;
+	}
+
+	pstat_local = (EXT_HBA_PORT_STAT_ISCSI *) ha->ioctl_dma_bufv;
+	memset(pstat_user, 0, sizeof(EXT_HBA_PORT_STAT_ISCSI));
+	pstat_user->MACTxFramesCount          =
+	    le64_to_cpu(pstat_local->MACTxFramesCount);
+	pstat_user->MACTxBytesCount           =
+	    le64_to_cpu(pstat_local->MACTxBytesCount);
+	pstat_user->MACRxFramesCount          =
+	    le64_to_cpu(pstat_local->MACRxFramesCount);
+	pstat_user->MACRxBytesCount           =
+	    le64_to_cpu(pstat_local->MACRxBytesCount);
+	pstat_user->MACCRCErrorCount          =
+	    le64_to_cpu(pstat_local->MACCRCErrorCount);
+	pstat_user->MACEncodingErrorCount     =
+	    le64_to_cpu(pstat_local->MACEncodingErrorCount);
+	pstat_user->IPTxPacketsCount          =
+	    le64_to_cpu(pstat_local->IPTxPacketsCount);
+	pstat_user->IPTxBytesCount            =
+	    le64_to_cpu(pstat_local->IPTxBytesCount);
+	pstat_user->IPTxFragmentsCount        =
+	    le64_to_cpu(pstat_local->IPTxFragmentsCount);
+	pstat_user->IPRxPacketsCount          =
+	    le64_to_cpu(pstat_local->IPRxPacketsCount);
+	pstat_user->IPRxBytesCount            =
+	    le64_to_cpu(pstat_local->IPRxBytesCount);
+	pstat_user->IPRxFragmentsCount        =
+	    le64_to_cpu(pstat_local->IPRxFragmentsCount);
+	pstat_user->IPDatagramReassemblyCount =
+	    le64_to_cpu(pstat_local->IPDatagramReassemblyCount);
+	pstat_user->IPv6RxPacketsCount        =
+	    le64_to_cpu(pstat_local->IPv6RxPacketsCount);
+	pstat_user->IPRxPacketErrorCount      =
+	    le64_to_cpu(pstat_local->IPRxPacketErrorCount);
+	pstat_user->IPReassemblyErrorCount    =
+	    le64_to_cpu(pstat_local->IPReassemblyErrorCount);
+	pstat_user->TCPTxSegmentsCount        =
+	    le64_to_cpu(pstat_local->TCPTxSegmentsCount);
+	pstat_user->TCPTxBytesCount           =
+	    le64_to_cpu(pstat_local->TCPTxBytesCount);
+	pstat_user->TCPRxSegmentsCount        =
+	    le64_to_cpu(pstat_local->TCPRxSegmentsCount);
+	pstat_user->TCPRxBytesCount           =
+	    le64_to_cpu(pstat_local->TCPRxBytesCount);
+	pstat_user->TCPTimerExpiredCount      =
+	    le64_to_cpu(pstat_local->TCPTimerExpiredCount);
+	pstat_user->TCPRxACKCount             =
+	    le64_to_cpu(pstat_local->TCPRxACKCount);
+	pstat_user->TCPTxACKCount             =
+	    le64_to_cpu(pstat_local->TCPTxACKCount);
+	pstat_user->TCPRxErrorSegmentCount    =
+	    le64_to_cpu(pstat_local->TCPRxErrorSegmentCount);
+	pstat_user->TCPWindowProbeUpdateCount =
+	    le64_to_cpu(pstat_local->TCPWindowProbeUpdateCount);
+	pstat_user->iSCSITxPDUCount           =
+	    le64_to_cpu(pstat_local->iSCSITxPDUCount);
+	pstat_user->iSCSITxBytesCount         =
+	    le64_to_cpu(pstat_local->iSCSITxBytesCount);
+	pstat_user->iSCSIRxPDUCount           =
+	    le64_to_cpu(pstat_local->iSCSIRxPDUCount);
+	pstat_user->iSCSIRxBytesCount         =
+	    le64_to_cpu(pstat_local->iSCSIRxBytesCount);
+	pstat_user->iSCSICompleteIOsCount     =
+	    le64_to_cpu(pstat_local->iSCSICompleteIOsCount);
+	pstat_user->iSCSIUnexpectedIORxCount  =
+	    le64_to_cpu(pstat_local->iSCSIUnexpectedIORxCount);
+	pstat_user->iSCSIFormatErrorCount     =
+	    le64_to_cpu(pstat_local->iSCSIFormatErrorCount);
+	pstat_user->iSCSIHeaderDigestCount    =
+	    le64_to_cpu(pstat_local->iSCSIHeaderDigestCount);
+	pstat_user->iSCSIDataDigestErrorCount =
+	    le64_to_cpu(pstat_local->iSCSIDataDigestErrorCount);
+	pstat_user->iSCSISeqErrorCount        =
+	    le64_to_cpu(pstat_local->iSCSISeqErrorCount);
+
+	/*
+	 * Copy the data from the dma buffer to the user's data space
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    pstat_user, ioctl->ResponseLen)) != 0) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_stats_iscsi;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_get_stats_iscsi:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_get_device_entry_iscsi
+ *	This routine retrieves the database entry for the specified device.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_device_entry_iscsi(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	DEV_DB_ENTRY	*pfw_ddb_entry;
+	EXT_DEVICE_ENTRY_ISCSI	*pdev_entry;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pdev_entry,
+	    sizeof(EXT_DEVICE_ENTRY_ISCSI))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_DEVICE_ENTRY_ISCSI)));
+		goto exit_get_dev_entry;
+	}
+
+	if (ha->ioctl_dma_buf_len < sizeof(DEV_DB_ENTRY)) {
+		if (qla4xxx_resize_ioctl_dma_buf(ha, sizeof(DEV_DB_ENTRY)) !=
+		    QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+			    printk("scsi%d: %s: unable to allocate memory "
+			    "for dma buffer.\n",
+			    ha->host_no, __func__));
+			ioctl->Status = EXT_STATUS_NO_MEMORY;
+			goto exit_get_dev_entry;
+		}
+	}
+
+	if (ioctl->ResponseLen < sizeof(EXT_DEVICE_ENTRY_ISCSI)) { 
+		QL4PRINT(QLP2, printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_get_dev_entry;
+	}
+
+	/*
+	 * Make the mailbox call
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	memset(pdev_entry, 0, sizeof(EXT_DEVICE_ENTRY_ISCSI));
+
+	if (ioctl->SubCode == EXT_SC_GET_DEVICE_ENTRY_ISCSI)
+		mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;
+	else
+		mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY_DEFAULTS;
+
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = MSDW(ha->ioctl_dma_bufp);
+
+	if (qla4xxx_mailbox_command(ha, 4, 5, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: get ddb entry for index [%d] failed "
+		    "w/ mailbox ststus 0x%x\n",
+		    ha->host_no, __func__, ioctl->Instance, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_dev_entry;
+	}
+
+	/*
+	 * Transfer data from Fw's DEV_DB_ENTRY buffer to IOCTL's
+	 * EXT_DEVICE_ENTRY_ISCSI buffer
+	 */
+	pfw_ddb_entry = ha->ioctl_dma_bufv;
+
+	pdev_entry->NumValid     = mbox_sts[2];
+	pdev_entry->NextValid    = mbox_sts[3];
+	pdev_entry->DeviceState  = mbox_sts[4];
+	pdev_entry->Options      = pfw_ddb_entry->options;
+	pdev_entry->Control      = pfw_ddb_entry->control;
+	pdev_entry->TargetSessID = le16_to_cpu(pfw_ddb_entry->TSID);
+	memcpy(pdev_entry->InitiatorSessID, pfw_ddb_entry->ISID,
+	    sizeof(pfw_ddb_entry->ISID));
+
+	pdev_entry->DeviceInfo.DeviceType = le16_to_cpu(EXT_DEF_ISCSI_REMOTE);
+	pdev_entry->DeviceInfo.ExeThrottle =
+	    le16_to_cpu(pfw_ddb_entry->exeThrottle);
+	pdev_entry->DeviceInfo.InitMarkerlessInt =
+	    le16_to_cpu(pfw_ddb_entry->iSCSIMaxSndDataSegLen);
+	pdev_entry->DeviceInfo.RetryCount = pfw_ddb_entry->retryCount;
+	pdev_entry->DeviceInfo.RetryDelay = pfw_ddb_entry->retryDelay;
+	pdev_entry->DeviceInfo.iSCSIOptions =
+	    le16_to_cpu(pfw_ddb_entry->iSCSIOptions);
+	pdev_entry->DeviceInfo.TCPOptions =
+	    le16_to_cpu(pfw_ddb_entry->TCPOptions);
+	pdev_entry->DeviceInfo.IPOptions =
+	    le16_to_cpu(pfw_ddb_entry->IPOptions);
+	pdev_entry->DeviceInfo.MaxPDUSize =
+	    le16_to_cpu(pfw_ddb_entry->maxPDUSize);
+	pdev_entry->DeviceInfo.FirstBurstSize =
+	    le16_to_cpu(pfw_ddb_entry->firstBurstSize);
+	pdev_entry->DeviceInfo.LogoutMinTime =
+	    le16_to_cpu(pfw_ddb_entry->minTime2Wait);
+	pdev_entry->DeviceInfo.LogoutMaxTime =
+	    le16_to_cpu(pfw_ddb_entry->maxTime2Retain);
+	pdev_entry->DeviceInfo.MaxOutstandingR2T =
+	    le16_to_cpu(pfw_ddb_entry->maxOutstndngR2T);
+	pdev_entry->DeviceInfo.KeepAliveTimeout =
+	    le16_to_cpu(pfw_ddb_entry->keepAliveTimeout);
+	pdev_entry->DeviceInfo.PortNumber =
+	    le16_to_cpu(pfw_ddb_entry->portNumber);
+	pdev_entry->DeviceInfo.MaxBurstSize =
+	    le16_to_cpu(pfw_ddb_entry->maxBurstSize);
+	pdev_entry->DeviceInfo.TaskMgmtTimeout =
+	    le16_to_cpu(pfw_ddb_entry->taskMngmntTimeout);
+	pdev_entry->EntryInfo.PortalCount = mbox_sts[2];
+	pdev_entry->ExeCount = le16_to_cpu(pfw_ddb_entry->exeCount);
+	pdev_entry->DDBLink = le16_to_cpu(pfw_ddb_entry->ddbLink);
+
+	memcpy(pdev_entry->UserID, pfw_ddb_entry->userID,
+	    sizeof(pdev_entry->UserID));
+	memcpy(pdev_entry->Password, pfw_ddb_entry->password,
+	    sizeof(pdev_entry->Password));
+
+	memcpy(pdev_entry->DeviceInfo.TargetAddr, pfw_ddb_entry->targetAddr,
+	    sizeof(pdev_entry->DeviceInfo.TargetAddr));
+	memcpy(pdev_entry->EntryInfo.IPAddr.IPAddress, pfw_ddb_entry->ipAddr,
+	    sizeof(pdev_entry->EntryInfo.IPAddr.IPAddress));
+	memcpy(pdev_entry->EntryInfo.iSCSIName, pfw_ddb_entry->iscsiName,
+	    sizeof(pdev_entry->EntryInfo.iSCSIName));
+	memcpy(pdev_entry->EntryInfo.Alias, pfw_ddb_entry->iSCSIAlias,
+	    sizeof(pdev_entry->EntryInfo.Alias));
+
+	QL4PRINT(QLP10|QLP4,
+	    printk("scsi%d: DEV_DB_ENTRY structure:\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP10|QLP4,
+	    pfw_ddb_entry, sizeof(DEV_DB_ENTRY));
+	QL4PRINT(QLP10|QLP4,
+	    printk("scsi%d: EXT_DEVICE_ENTRY_ISCSI structure:\n",
+	    ha->host_no));
+	qla4xxx_dump_bytes(QLP10|QLP4,
+	    pdev_entry, sizeof(EXT_DEVICE_ENTRY_ISCSI));
+
+	/*
+	 * Copy the IOCTL EXT_DEVICE_ENTRY_ISCSI buffer to the user's data space
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    pdev_entry, ioctl->ResponseLen)) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_dev_entry;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_get_dev_entry:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+
+/**************************************************************************
+ * qla4extioctl_get_init_fw_iscsi
+ *	This routine retrieves the initialize firmware control block for
+ *	the specified HBA.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_init_fw_iscsi(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_INIT_FW_ISCSI *pinit_fw;
+	INIT_FW_CTRL_BLK  *pinit_fw_cb;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pinit_fw,
+	    sizeof(EXT_INIT_FW_ISCSI))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_INIT_FW_ISCSI)));
+		goto exit_get_init_fw;
+	}
+
+	if (!ha->ioctl_dma_bufv || !ha->ioctl_dma_bufp ||
+	    (ha->ioctl_dma_buf_len < sizeof(INIT_FW_CTRL_BLK)) ||
+	    (ioctl->ResponseLen < sizeof(EXT_INIT_FW_ISCSI))) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: response buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_get_init_fw;
+	}
+
+	/*
+	 * Send mailbox command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	switch (ioctl->SubCode) {
+	case EXT_SC_GET_INIT_FW_ISCSI:
+		mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+		break;
+	case EXT_SC_GET_INIT_FW_DEFAULTS_ISCSI:
+		mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK_DEFAULTS;
+		break;
+	default:
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: invalid subcode (0x%04X) speficied\n",
+		    ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_init_fw;
+	}
+
+	mbox_cmd[1] = 0;
+	mbox_cmd[2] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = MSDW(ha->ioctl_dma_bufp);
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_init_fw;
+	}
+
+	/*
+	 * Transfer Data from DMA buffer to Local buffer
+	 */
+	pinit_fw_cb = (INIT_FW_CTRL_BLK *)ha->ioctl_dma_bufv;
+	memset(pinit_fw, 0, sizeof(EXT_INIT_FW_ISCSI));
+
+	pinit_fw->Version         = pinit_fw_cb->Version;
+	pinit_fw->FWOptions       = le16_to_cpu(pinit_fw_cb->FwOptions);
+	pinit_fw->AddFWOptions    = le16_to_cpu(pinit_fw_cb->AddFwOptions);
+	//FIXME: pinit_fw->WakeupThreshold = le16_to_cpu(pinit_fw_cb->WakeupThreshold);
+	memcpy(&pinit_fw->IPAddr.IPAddress, &pinit_fw_cb->IPAddr,
+	    MIN(sizeof(pinit_fw->IPAddr.IPAddress),
+	    sizeof(pinit_fw_cb->IPAddr)));
+	memcpy(&pinit_fw->SubnetMask.IPAddress, &pinit_fw_cb->SubnetMask,
+	    MIN(sizeof(pinit_fw->SubnetMask.IPAddress),
+	    sizeof(pinit_fw_cb->SubnetMask)));
+	memcpy(&pinit_fw->Gateway.IPAddress, &pinit_fw_cb->GatewayIPAddr,
+	    MIN(sizeof(pinit_fw->Gateway.IPAddress),
+	    sizeof(pinit_fw_cb->GatewayIPAddr)));
+	memcpy(&pinit_fw->DNSConfig.IPAddr.IPAddress,
+	    &pinit_fw_cb->PriDNSIPAddr,
+	    MIN(sizeof(pinit_fw->DNSConfig.IPAddr.IPAddress),
+	    sizeof(pinit_fw_cb->PriDNSIPAddr)));
+	memcpy(&pinit_fw->Alias, &pinit_fw_cb->Alias,
+	    MIN(sizeof(pinit_fw->Alias), sizeof(pinit_fw_cb->Alias)));
+	memcpy(&pinit_fw->iSCSIName, &pinit_fw_cb->iSCSINameString,
+	    MIN(sizeof(pinit_fw->iSCSIName),
+	    sizeof(pinit_fw_cb->iSCSINameString)));
+
+	pinit_fw->DeviceInfo.DeviceType = le16_to_cpu(EXT_DEF_ISCSI_LOCAL);
+	pinit_fw->DeviceInfo.ExeThrottle =
+	    le16_to_cpu(pinit_fw_cb->ExecThrottle);
+	pinit_fw->DeviceInfo.InitMarkerlessInt =
+	    le16_to_cpu(pinit_fw_cb->InitMarkerlessInt);
+	pinit_fw->DeviceInfo.RetryCount = pinit_fw_cb->RetryCount;
+	pinit_fw->DeviceInfo.RetryDelay = pinit_fw_cb->RetryDelay;
+	pinit_fw->DeviceInfo.iSCSIOptions =
+	    le16_to_cpu(pinit_fw_cb->iSCSIOptions);
+	pinit_fw->DeviceInfo.TCPOptions = le16_to_cpu(pinit_fw_cb->TCPOptions);
+	pinit_fw->DeviceInfo.IPOptions = le16_to_cpu(pinit_fw_cb->IPOptions);
+	pinit_fw->DeviceInfo.MaxPDUSize = le16_to_cpu(pinit_fw_cb->MaxPDUSize);
+	pinit_fw->DeviceInfo.FirstBurstSize =
+	    le16_to_cpu(pinit_fw_cb->FirstBurstSize);
+	pinit_fw->DeviceInfo.LogoutMinTime =
+	    le16_to_cpu(pinit_fw_cb->DefaultTime2Wait);
+	pinit_fw->DeviceInfo.LogoutMaxTime =
+	    le16_to_cpu(pinit_fw_cb->DefaultTime2Retain);
+	pinit_fw->DeviceInfo.LogoutMaxTime =
+	    le16_to_cpu(pinit_fw_cb->DefaultTime2Retain);
+	pinit_fw->DeviceInfo.MaxOutstandingR2T =
+	    le16_to_cpu(pinit_fw_cb->MaxOutStndngR2T);
+	pinit_fw->DeviceInfo.KeepAliveTimeout =
+	    le16_to_cpu(pinit_fw_cb->KeepAliveTimeout);
+	pinit_fw->DeviceInfo.PortNumber = le16_to_cpu(pinit_fw_cb->PortNumber);
+	pinit_fw->DeviceInfo.MaxBurstSize =
+	    le16_to_cpu(pinit_fw_cb->MaxBurstSize);
+	//pinit_fw->DeviceInfo.TaskMgmtTimeout   = pinit_fw_cb->T;
+	memcpy(&pinit_fw->DeviceInfo.TargetAddr, &pinit_fw_cb->TargAddr,
+	    EXT_DEF_ISCSI_TADDR_SIZE);
+
+	/*
+	 * Copy the local data to the user's buffer
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr), pinit_fw,
+	    sizeof(EXT_INIT_FW_ISCSI))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_init_fw;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	QL4PRINT(QLP10|QLP4,
+	    printk("scsi%d: EXT_INIT_FW_ISCSI structure:\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP10|QLP4, pinit_fw, sizeof(EXT_INIT_FW_ISCSI));
+
+exit_get_init_fw:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_get_isns_server
+ *	This routine retrieves the iSNS server information.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_isns_server(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_ISNS_SERVER *pisns_server;
+	FLASH_INIT_FW_CTRL_BLK *pflash_init_fw_cb = NULL;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pisns_server,
+	    sizeof(EXT_ISNS_SERVER))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_ISNS_SERVER)));
+		goto exit_get_isns_server;
+	}
+
+	if (ioctl->ResponseLen < sizeof(EXT_ISNS_SERVER)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: response buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		ioctl->ResponseLen = 0;
+		goto exit_get_isns_server;
+	}
+
+	if (!ha->ioctl_dma_bufv || !ha->ioctl_dma_bufp ||
+	    (ha->ioctl_dma_buf_len < sizeof(FLASH_INIT_FW_CTRL_BLK))) {
+		if (qla4xxx_resize_ioctl_dma_buf(ha,
+		    sizeof(FLASH_INIT_FW_CTRL_BLK)) != QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+			    printk("scsi%d: %s: unable to allocate memory "
+			    "for dma buffer.\n",
+			    ha->host_no, __func__));
+
+			ioctl->Status = EXT_STATUS_NO_MEMORY;
+			ioctl->ResponseLen = 0;
+			goto exit_get_isns_server;
+		}
+	}
+
+	/*
+	 * First get Flash Initialize Firmware Control Block, so as not to
+	 * destroy unaffected data
+	 *----------------------------------------------------------------*/
+	pflash_init_fw_cb = (FLASH_INIT_FW_CTRL_BLK *)ha->ioctl_dma_bufv;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[2] = MSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = INT_ISCSI_INITFW_FLASH_OFFSET;
+	mbox_cmd[4] = sizeof(FLASH_INIT_FW_CTRL_BLK);
+
+	if (qla4xxx_mailbox_command(ha, 5, 2, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: READ_FLASH command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		ioctl->ResponseLen = 0;
+		goto exit_get_isns_server;
+	}
+
+	QL4PRINT(QLP4, printk("scsi%d: %s: READ_FLASH command successful \n",
+	    ha->host_no, __func__));
+
+	/*
+	 * Copy iSNS Server info to the isns_server structure
+	 *---------------------------------------------------*/
+	memset(pisns_server, 0, sizeof(EXT_ISNS_SERVER));
+	pisns_server->PerformiSNSDiscovery =
+	    (pflash_init_fw_cb->init_fw_cb.TCPOptions & TOPT_ISNS_ENABLE) ? 1:0;
+	pisns_server->AutomaticiSNSDiscovery =
+	    (pflash_init_fw_cb->init_fw_cb.TCPOptions &
+	    TOPT_LEARN_ISNS_IP_ADDR_ENABLE) ? 1 : 0;
+	pisns_server->PortNumber =
+	    pflash_init_fw_cb->init_fw_cb.iSNSServerPortNumber;
+	pisns_server->IPAddr.Type = EXT_DEF_TYPE_ISCSI_IP;
+	memcpy(pisns_server->IPAddr.IPAddress,
+	       pflash_init_fw_cb->init_fw_cb.iSNSIPAddr,
+	       MIN(sizeof(pisns_server->IPAddr.IPAddress),
+		   sizeof(pflash_init_fw_cb->init_fw_cb.iSNSIPAddr)));
+	memcpy(pisns_server->InitiatorName,
+	       pflash_init_fw_cb->init_fw_cb.iSCSINameString,
+	       MIN(sizeof(pisns_server->InitiatorName),
+		   sizeof(pflash_init_fw_cb->init_fw_cb.iSCSINameString)));
+
+#if 1
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_ISNS_SERVICE;
+	mbox_cmd[1] = ISNS_STATUS;
+	if (qla4xxx_mailbox_command(ha, 2, 2, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: GET ISNS SERVICE STATUS cmnd failed \n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		ioctl->ResponseLen = 0;
+		goto exit_get_isns_server;
+	}
+
+	QL4PRINT(QLP4|QLP20,
+	    printk("scsi%d: %s: GET ISNS SERVICE STATUS = 0x%04x \"%s\"\n",
+	    ha->host_no, __func__, mbox_sts[1],
+	    ((mbox_sts[1] & 1) == 0) ? "DISABLED" : "ENABLED"));
+#endif
+
+	/*
+	 * Copy the local data to the user's buffer
+	 *-----------------------------------------*/
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    pisns_server, sizeof(EXT_ISNS_SERVER))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_isns_server;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+	ioctl->ResponseLen = sizeof(EXT_ISNS_SERVER);
+	ioctl->DetailStatus = 0;
+
+	QL4PRINT(QLP4|QLP10,
+	    printk("scsi%d: EXT_ISNS_SERVER structure:\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP4|QLP10,
+	    pisns_server, sizeof(EXT_ISNS_SERVER));
+
+exit_get_isns_server:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_get_isns_disc_targets
+ *	This routine retrieves the targets discovered via iSNS.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_isns_disc_targets(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status   = 0;
+	uint32_t	isns_disc_tgt_index_start;
+	uint32_t	i, j;
+	EXT_ISNS_DISCOVERED_TARGETS *pisns_disc_tgts = NULL;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (ioctl->ResponseLen < sizeof(EXT_ISNS_DISCOVERED_TARGETS)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: response buffer "
+		    "too small.  RspLen=0x%x, need 0x%x\n",
+		    ha->host_no, __func__, ioctl->ResponseLen,
+		    (unsigned int) sizeof(EXT_ISNS_DISCOVERED_TARGETS)));
+		ioctl->ResponseLen = 0;
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		ioctl->DetailStatus = sizeof(EXT_ISNS_DISCOVERED_TARGETS);
+		goto exit_get_isns_disc_tgts;
+	}
+
+	if (!ha->ioctl_dma_bufv ||
+	    ((ioctl->ResponseLen > ha->ioctl_dma_buf_len) &&
+	    qla4xxx_resize_ioctl_dma_buf(ha,
+	    sizeof(EXT_ISNS_DISCOVERED_TARGETS)) != QLA_SUCCESS)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: unable to allocate memory "
+		    "for dma buffer.\n",
+		    ha->host_no, __func__));
+		ioctl->ResponseLen = 0;
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		goto exit_get_isns_disc_tgts;
+	}
+
+	/*
+	 * Copy the IOCTL EXT_ISNS_DISCOVERED_TARGETS buffer from the user's
+	 * data space
+	 */
+	pisns_disc_tgts = (EXT_ISNS_DISCOVERED_TARGETS *) ha->ioctl_dma_bufv;
+	if (copy_from_user((uint8_t *)pisns_disc_tgts,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), ioctl->RequestLen) != 0) {
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->ResponseLen = 0;
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_isns_disc_tgts;
+	}
+
+	isns_disc_tgt_index_start =
+	    pisns_disc_tgts->iSNSDiscoveredTargetIndexStart;
+	memset(pisns_disc_tgts, 0, sizeof(EXT_ISNS_DISCOVERED_TARGETS));
+	pisns_disc_tgts->iSNSDiscoveredTargetIndexStart =
+	    isns_disc_tgt_index_start;
+
+	/*
+	 * Transfer Data from Local buffer to DMA buffer
+	 */
+	if (isns_disc_tgt_index_start < ha->isns_num_discovered_targets) {
+		EXT_ISNS_DISCOVERED_TARGET *isns_disc_tgt;
+		ISNS_DISCOVERED_TARGET *isns_local_disc_target;
+
+		for (i = isns_disc_tgt_index_start;
+		    i < ha->isns_num_discovered_targets &&
+		    pisns_disc_tgts->NumiSNSDiscoveredTargets <
+		    EXT_DEF_NUM_ISNS_DISCOVERED_TARGETS;
+		    i++) {
+			isns_disc_tgt = (EXT_ISNS_DISCOVERED_TARGET *)
+			    &pisns_disc_tgts->iSNSDiscoveredTargets[
+			    pisns_disc_tgts->NumiSNSDiscoveredTargets];
+			isns_local_disc_target = (ISNS_DISCOVERED_TARGET *)
+			    &ha->isns_disc_tgt_databasev[i];
+
+			isns_disc_tgt->NumPortals =
+			    isns_local_disc_target->NumPortals;
+
+			for (j = 0; j < isns_disc_tgt->NumPortals; j++) {
+				memcpy(isns_disc_tgt->Portal[j].IPAddr.
+				    IPAddress,
+				    isns_local_disc_target->Portal[j].IPAddr,
+				    MIN(sizeof(isns_disc_tgt->Portal[j].IPAddr.
+				    IPAddress),
+				    sizeof(isns_local_disc_target->Portal[j].
+				    IPAddr)));
+				isns_disc_tgt->Portal[j].IPAddr.Type =
+				    EXT_DEF_TYPE_ISCSI_IP;
+				isns_disc_tgt->Portal[j].PortNumber =
+				    isns_local_disc_target->Portal[j].
+				    PortNumber;
+			}
+
+			isns_disc_tgt->DDID = isns_local_disc_target->DDID;
+
+			memcpy(isns_disc_tgt->NameString,
+			    isns_local_disc_target->NameString,
+			    MIN(sizeof(isns_disc_tgt->NameString),
+			    sizeof(isns_local_disc_target->NameString)));
+			memcpy(isns_disc_tgt->Alias,
+			    isns_local_disc_target->Alias,
+			    MIN(sizeof(isns_disc_tgt->Alias),
+			    sizeof(isns_local_disc_target->Alias)));
+
+			pisns_disc_tgts->NumiSNSDiscoveredTargets++;
+		}
+	}
+
+	/*
+	 * Copy the data to the user's buffer
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    pisns_disc_tgts, sizeof(EXT_ISNS_DISCOVERED_TARGETS))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_isns_disc_tgts;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	QL4PRINT(QLP4|QLP10,
+	    printk("scsi%d: EXT_INIT_FW_ISCSI structure:\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP4|QLP10,
+	    pisns_disc_tgts, sizeof(EXT_ISNS_DISCOVERED_TARGETS));
+
+exit_get_isns_disc_tgts:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_get_data
+ *	This routine calls get data IOCTLs based on the IOCTL Sub Code.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *    	-EINVAL     = if the command is invalid
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_data(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	switch (ioctl->SubCode) {
+	case EXT_SC_GET_STATISTICS_GEN:
+		return(qla4extioctl_get_statistics_gen(ha, ioctl));
+
+	case EXT_SC_GET_STATISTICS_ISCSI:
+		return(qla4extioctl_get_statistics_iscsi(ha, ioctl));
+
+	case EXT_SC_GET_DEVICE_ENTRY_ISCSI:
+	case EXT_SC_GET_DEVICE_ENTRY_DEFAULTS_ISCSI:
+		return(qla4extioctl_get_device_entry_iscsi(ha, ioctl));
+
+	case EXT_SC_GET_INIT_FW_ISCSI:
+	case EXT_SC_GET_INIT_FW_DEFAULTS_ISCSI:
+		return(qla4extioctl_get_init_fw_iscsi(ha, ioctl));
+
+	case EXT_SC_GET_ISNS_SERVER:
+		return(qla4extioctl_get_isns_server(ha, ioctl));
+
+	case EXT_SC_GET_ISNS_DISCOVERED_TARGETS:
+		return(qla4extioctl_get_isns_disc_targets(ha, ioctl));
+
+	default:
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unsupported external get "
+		    "data sub-command code (%X)\n",
+		    ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		return(0);
+	}
+}
+
+/**************************************************************************
+ * qla4extioctl_rst_statistics_gen
+ *	This routine clears the HBA general statistical information.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_rst_statistics_gen(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	/*
+	 * Reset the general statistics fields
+	 */
+	ha->adapter_error_count = 0;
+	ha->device_error_count = 0;
+	ha->total_io_count = 0;
+	ha->total_mbytes_xferred = 0;
+	ha->isr_count = 0;
+	ha->link_failure_count = 0;
+	ha->invalid_crc_count = 0;
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4extioctl_rst_statistics_iscsi
+ *	This routine clears the HBA iSCSI statistical information.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_rst_statistics_iscsi(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	/*
+	 * Make the mailbox call
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_MANAGEMENT_DATA;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = 0;
+	mbox_cmd[3] = 0;
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]) !=
+	    QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: get mngmt data for index [%d] failed! "
+		    "w/ mailbox ststus 0x%x\n",
+		    ha->host_no, __func__, ioctl->Instance, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+
+		return(0);
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(QLA_SUCCESS);
+}
+
+/**************************************************************************
+ * qla4extioctl_set_device_entry_iscsi
+ *	This routine configures a device with specific database entry data.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_set_device_entry_iscsi(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	DEV_DB_ENTRY	*pfw_ddb_entry;
+	EXT_DEVICE_ENTRY_ISCSI *pdev_entry;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pdev_entry,
+	    sizeof(EXT_DEVICE_ENTRY_ISCSI))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_DEVICE_ENTRY_ISCSI)));
+		goto exit_set_dev_entry;
+	}
+
+	if (!ha->ioctl_dma_bufv || !ha->ioctl_dma_bufp || !ioctl->RequestAdr) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: memory allocation problem\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		goto exit_set_dev_entry;
+	}
+
+	if (ha->ioctl_dma_buf_len < sizeof(DEV_DB_ENTRY)) {
+		if (qla4xxx_resize_ioctl_dma_buf(ha, sizeof(DEV_DB_ENTRY)) !=
+		    QLA_SUCCESS) {
+			QL4PRINT(QLP2,
+			    printk("scsi%d: %s: unable to allocate memory "
+			    "for dma buffer.\n",
+			    ha->host_no, __func__));
+			ioctl->Status = EXT_STATUS_NO_MEMORY;
+			goto exit_set_dev_entry;
+		}
+	}
+
+	if (ioctl->RequestLen < sizeof(EXT_DEVICE_ENTRY_ISCSI)) {
+		QL4PRINT(QLP2, printk("scsi%d: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_set_dev_entry;
+	}
+
+	/*
+	 * Copy the IOCTL EXT_DEVICE_ENTRY_ISCSI buffer from the user's
+	 * data space
+	 */
+	if ((status = copy_from_user((uint8_t *)pdev_entry,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), ioctl->RequestLen)) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_dev_entry;
+	}
+
+	/*
+	 * Transfer data from IOCTL's EXT_DEVICE_ENTRY_ISCSI buffer to
+	 * Fw's DEV_DB_ENTRY buffer
+	 */
+	pfw_ddb_entry = ha->ioctl_dma_bufv;
+	memset(pfw_ddb_entry, 0, sizeof(DEV_DB_ENTRY));
+
+	pfw_ddb_entry->options          = pdev_entry->Options;
+	pfw_ddb_entry->control          = pdev_entry->Control;
+	pfw_ddb_entry->TSID             = cpu_to_le16(pdev_entry->TargetSessID);
+	pfw_ddb_entry->exeCount         = cpu_to_le16(pdev_entry->ExeCount);
+	pfw_ddb_entry->ddbLink          = cpu_to_le16(pdev_entry->DDBLink);
+	memcpy(pfw_ddb_entry->ISID, pdev_entry->InitiatorSessID,
+	    sizeof(pdev_entry->InitiatorSessID));
+	memcpy(pfw_ddb_entry->userID, pdev_entry->UserID,
+	    sizeof(pdev_entry->UserID));
+	memcpy(pfw_ddb_entry->password, pdev_entry->Password,
+	    sizeof(pdev_entry->Password));
+
+	pfw_ddb_entry->exeThrottle =
+	    cpu_to_le16(pdev_entry->DeviceInfo.ExeThrottle);
+	pfw_ddb_entry->iSCSIMaxSndDataSegLen =
+	    cpu_to_le16(pdev_entry->DeviceInfo.InitMarkerlessInt);
+	pfw_ddb_entry->retryCount =
+	    pdev_entry->DeviceInfo.RetryCount;
+	pfw_ddb_entry->retryDelay = pdev_entry->DeviceInfo.RetryDelay;
+	pfw_ddb_entry->iSCSIOptions =
+	    cpu_to_le16(pdev_entry->DeviceInfo.iSCSIOptions);
+	pfw_ddb_entry->TCPOptions =
+	    cpu_to_le16(pdev_entry->DeviceInfo.TCPOptions);
+	pfw_ddb_entry->IPOptions =
+	    cpu_to_le16(pdev_entry->DeviceInfo.IPOptions);
+	pfw_ddb_entry->maxPDUSize =
+	    cpu_to_le16(pdev_entry->DeviceInfo.MaxPDUSize);
+	pfw_ddb_entry->firstBurstSize =
+	    cpu_to_le16(pdev_entry->DeviceInfo.FirstBurstSize);
+	pfw_ddb_entry->minTime2Wait =
+	    cpu_to_le16(pdev_entry->DeviceInfo.LogoutMinTime);
+	pfw_ddb_entry->maxTime2Retain =
+	    cpu_to_le16(pdev_entry->DeviceInfo.LogoutMaxTime);
+	pfw_ddb_entry->maxOutstndngR2T =
+	    cpu_to_le16(pdev_entry->DeviceInfo.MaxOutstandingR2T);
+	pfw_ddb_entry->keepAliveTimeout =
+	    cpu_to_le16(pdev_entry->DeviceInfo.KeepAliveTimeout);
+	pfw_ddb_entry->portNumber =
+	    cpu_to_le16(pdev_entry->DeviceInfo.PortNumber);
+	pfw_ddb_entry->maxBurstSize =
+	    cpu_to_le16(pdev_entry->DeviceInfo.MaxBurstSize);
+	pfw_ddb_entry->taskMngmntTimeout =
+	    cpu_to_le16(pdev_entry->DeviceInfo.TaskMgmtTimeout);
+	memcpy(pfw_ddb_entry->targetAddr, pdev_entry->DeviceInfo.TargetAddr,
+	    sizeof(pdev_entry->DeviceInfo.TargetAddr));
+
+	memcpy(pfw_ddb_entry->ipAddr, pdev_entry->EntryInfo.IPAddr.IPAddress,
+	    sizeof(pdev_entry->EntryInfo.IPAddr.IPAddress));
+	memcpy(pfw_ddb_entry->iscsiName, pdev_entry->EntryInfo.iSCSIName,
+	    sizeof(pdev_entry->EntryInfo.iSCSIName));
+	memcpy(pfw_ddb_entry->iSCSIAlias, pdev_entry->EntryInfo.Alias,
+	    sizeof(pdev_entry->EntryInfo.Alias));
+
+	/*
+	 * Make the IOCTL call
+	 */
+	if (qla4xxx_set_ddb_entry(ha, ioctl->Instance, pfw_ddb_entry,
+	    ha->ioctl_dma_bufp) != QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: SET DDB Entry failed\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		goto exit_set_dev_entry;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_set_dev_entry:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_set_init_fw_iscsi
+ *	This routine configures a device with specific data entry data.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_set_init_fw_iscsi(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	EXT_INIT_FW_ISCSI *pinit_fw;
+	INIT_FW_CTRL_BLK  *pinit_fw_cb;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pinit_fw,
+	    sizeof(EXT_INIT_FW_ISCSI))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_INIT_FW_ISCSI)));
+		goto exit_set_init_fw;
+	}
+
+	if (!ha->ioctl_dma_bufv || !ha->ioctl_dma_bufp ||
+	    (ha->ioctl_dma_buf_len < sizeof(INIT_FW_CTRL_BLK)) ||
+	    (ioctl->RequestLen < sizeof(EXT_INIT_FW_ISCSI))) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: requst buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_set_init_fw;
+	}
+
+	/*
+	 * Copy the data from the user's buffer
+	 */
+	if ((status = copy_from_user((uint8_t *)pinit_fw,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), sizeof(EXT_INIT_FW_ISCSI))) != 
+	    0) {
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_init_fw;
+	}
+
+	/*
+	 * First get Initialize Firmware Control Block, so as not to
+	 * destroy unaffected data
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = MSDW(ha->ioctl_dma_bufp);
+
+	if (qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4, printk("scsi%d: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_set_init_fw;
+	}
+
+	/*
+	 * Transfer Data from Local buffer to DMA buffer
+	 */
+	pinit_fw_cb = (INIT_FW_CTRL_BLK *)ha->ioctl_dma_bufv;
+
+	pinit_fw_cb->Version         = pinit_fw->Version;
+	pinit_fw_cb->FwOptions       = cpu_to_le16(pinit_fw->FWOptions);
+	pinit_fw_cb->AddFwOptions    = cpu_to_le16(pinit_fw->AddFWOptions);
+	//FIXME: pinit_fw_cb->WakeupThreshold = cpu_to_le16(pinit_fw->WakeupThreshold);
+	memcpy(pinit_fw_cb->IPAddr, pinit_fw->IPAddr.IPAddress,
+	    MIN(sizeof(pinit_fw_cb->IPAddr),
+	    sizeof(pinit_fw->IPAddr.IPAddress)));
+	memcpy(pinit_fw_cb->SubnetMask, pinit_fw->SubnetMask.IPAddress,
+	    MIN(sizeof(pinit_fw_cb->SubnetMask),
+	    sizeof(pinit_fw->SubnetMask.IPAddress)));
+	memcpy(pinit_fw_cb->GatewayIPAddr, pinit_fw->Gateway.IPAddress,
+	    MIN(sizeof(pinit_fw_cb->GatewayIPAddr),
+	    sizeof(pinit_fw->Gateway.IPAddress)));
+	memcpy(pinit_fw_cb->PriDNSIPAddr, pinit_fw->DNSConfig.IPAddr.IPAddress,
+	    MIN(sizeof(pinit_fw_cb->PriDNSIPAddr),
+	    sizeof(pinit_fw->DNSConfig.IPAddr.IPAddress)));
+	memcpy(pinit_fw_cb->Alias, pinit_fw->Alias,
+	    MIN(sizeof(pinit_fw_cb->Alias), sizeof(pinit_fw->Alias)));
+	memcpy(pinit_fw_cb->iSCSINameString, pinit_fw->iSCSIName,
+	    MIN(sizeof(pinit_fw_cb->iSCSINameString),
+	    sizeof(pinit_fw->iSCSIName)));
+
+	pinit_fw_cb->ExecThrottle =
+	    cpu_to_le16(pinit_fw->DeviceInfo.ExeThrottle);
+	pinit_fw_cb->InitMarkerlessInt =
+	    cpu_to_le16(pinit_fw->DeviceInfo.InitMarkerlessInt);
+	pinit_fw_cb->RetryCount = pinit_fw->DeviceInfo.RetryCount;
+	pinit_fw_cb->RetryDelay = pinit_fw->DeviceInfo.RetryDelay;
+	pinit_fw_cb->iSCSIOptions =
+	    cpu_to_le16(pinit_fw->DeviceInfo.iSCSIOptions);
+	pinit_fw_cb->TCPOptions = cpu_to_le16(pinit_fw->DeviceInfo.TCPOptions);
+	pinit_fw_cb->IPOptions = cpu_to_le16(pinit_fw->DeviceInfo.IPOptions);
+	pinit_fw_cb->MaxPDUSize = cpu_to_le16(pinit_fw->DeviceInfo.MaxPDUSize);
+	pinit_fw_cb->FirstBurstSize =
+	    cpu_to_le16(pinit_fw->DeviceInfo.FirstBurstSize);
+	pinit_fw_cb->DefaultTime2Wait =
+	    cpu_to_le16(pinit_fw->DeviceInfo.LogoutMinTime);
+	pinit_fw_cb->DefaultTime2Retain =
+	    cpu_to_le16(pinit_fw->DeviceInfo.LogoutMaxTime);
+	pinit_fw_cb->MaxOutStndngR2T =
+	    cpu_to_le16(pinit_fw->DeviceInfo.MaxOutstandingR2T);
+	pinit_fw_cb->KeepAliveTimeout =
+	    cpu_to_le16(pinit_fw->DeviceInfo.KeepAliveTimeout);
+	pinit_fw_cb->PortNumber = cpu_to_le16(pinit_fw->DeviceInfo.PortNumber);
+	pinit_fw_cb->MaxBurstSize =
+	    cpu_to_le16(pinit_fw->DeviceInfo.MaxBurstSize);
+	//pinit_fw_cb->?                = pinit_fw->DeviceInfo.TaskMgmtTimeout;
+	memcpy(pinit_fw_cb->TargAddr, pinit_fw->DeviceInfo.TargetAddr,
+	    EXT_DEF_ISCSI_TADDR_SIZE);
+
+	/*
+	 * Send mailbox command
+	 */
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_INITIALIZE_FIRMWARE;
+	mbox_cmd[2] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = MSDW(ha->ioctl_dma_bufp);
+
+	if ((status = qla4xxx_mailbox_command(ha, 4, 1, &mbox_cmd[0],
+	    &mbox_sts[0])) == QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4, printk("scsi%d: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_set_init_fw;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	QL4PRINT(QLP4|QLP10,
+	    printk("scsi%d: EXT_INIT_FW_ISCSI structure:\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP4|QLP10, pinit_fw, sizeof(EXT_INIT_FW_ISCSI));
+
+exit_set_init_fw:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_set_isns_server
+ *	This routine retrieves the targets discovered via iSNS.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_set_isns_server(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_ISNS_SERVER *pisns_server;
+	FLASH_INIT_FW_CTRL_BLK *pflash_init_fw_cb = NULL;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pisns_server,
+	    sizeof(EXT_ISNS_SERVER))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_ISNS_SERVER)));
+		goto exit_set_isns_svr;
+	}
+
+	if (ioctl->RequestLen < sizeof(*pisns_server)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: requst buffer too small (%d/%xh)\n",
+		    ha->host_no, __func__, ioctl->RequestLen,
+		    ioctl->RequestLen));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		ioctl->ResponseLen = 0;
+		goto exit_set_isns_svr;
+	}
+
+	if (!ha->ioctl_dma_bufv || !ha->ioctl_dma_bufp ||
+	    (ha->ioctl_dma_buf_len < sizeof(FLASH_INIT_FW_CTRL_BLK))) {
+		if (qla4xxx_resize_ioctl_dma_buf(ha,
+		    sizeof(DEV_DB_ENTRY)) != QLA_SUCCESS) {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: unable to allocate memory "
+			    "for dma buffer.\n",
+			    ha->host_no, __func__));
+
+			ioctl->Status = EXT_STATUS_NO_MEMORY;
+			ioctl->ResponseLen = 0;
+			goto exit_set_isns_svr;
+		}
+	}
+
+	/*
+	 * Copy iSNS Server info from the user's buffer
+	 *---------------------------------------------*/
+	if ((status = copy_from_user((uint8_t *)pisns_server,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr), sizeof(EXT_ISNS_SERVER))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		ioctl->ResponseLen = 0;
+		goto exit_set_isns_svr;
+	}
+
+	QL4PRINT(QLP4|QLP10,
+	    printk("scsi%d: EXT_ISNS_SERVER structure:\n", ha->host_no));
+	qla4xxx_dump_bytes(QLP4|QLP10, pisns_server, sizeof(EXT_ISNS_SERVER));
+
+	/*
+	 * First get Flash Initialize Firmware Control Block, so as not to
+	 * destroy unaffected data
+	 *----------------------------------------------------------------*/
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[2] = MSDW(ha->ioctl_dma_bufp);
+	mbox_cmd[3] = INT_ISCSI_INITFW_FLASH_OFFSET;
+	mbox_cmd[4] = sizeof(FLASH_INIT_FW_CTRL_BLK);
+
+	if (qla4xxx_mailbox_command(ha, 5, 2, &mbox_cmd[0], &mbox_sts[0]) ==
+	    QLA_ERROR) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: READ_FLASH command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		ioctl->ResponseLen = 0;
+		goto exit_set_isns_svr;
+	}
+
+	QL4PRINT(QLP4, printk("scsi%d: %s: READ_FLASH command successful \n",
+	    ha->host_no, __func__));
+
+	/*
+	 * Copy iSNS Server info to the flash_init_fw_cb
+	 *----------------------------------------------*/
+	pflash_init_fw_cb = (FLASH_INIT_FW_CTRL_BLK *)ha->ioctl_dma_bufv;
+
+	if (pisns_server->PerformiSNSDiscovery) {
+		if (pisns_server->AutomaticiSNSDiscovery) {
+			pflash_init_fw_cb->init_fw_cb.TCPOptions |=
+			    TOPT_LEARN_ISNS_IP_ADDR_ENABLE;
+			memset(pflash_init_fw_cb->init_fw_cb.iSNSIPAddr, 0,
+			       sizeof(pflash_init_fw_cb->init_fw_cb.iSNSIPAddr));
+		} else {
+			pflash_init_fw_cb->init_fw_cb.TCPOptions &=
+			    ~TOPT_LEARN_ISNS_IP_ADDR_ENABLE;
+			memcpy(pflash_init_fw_cb->init_fw_cb.iSNSIPAddr,
+			    pisns_server->IPAddr.IPAddress,
+			    MIN(sizeof(pflash_init_fw_cb->init_fw_cb.iSNSIPAddr),
+			    sizeof(pisns_server->IPAddr.IPAddress)));
+		}
+
+		pflash_init_fw_cb->init_fw_cb.iSNSServerPortNumber =
+		    (pisns_server->PortNumber) ?  pisns_server->PortNumber :
+		    EXT_DEF_ISNS_WELL_KNOWN_PORT;
+		pflash_init_fw_cb->init_fw_cb.TCPOptions |= TOPT_ISNS_ENABLE;
+
+	} else {
+		pflash_init_fw_cb->init_fw_cb.TCPOptions &= ~TOPT_ISNS_ENABLE;
+		memset(pflash_init_fw_cb->init_fw_cb.iSNSIPAddr, 0,
+		       sizeof(pflash_init_fw_cb->init_fw_cb.iSNSIPAddr));
+		pflash_init_fw_cb->init_fw_cb.iSNSServerPortNumber = 0;
+	}
+
+	QL4PRINT(QLP4, printk("scsi%d: %s: IPAddr %d.%d.%d.%d Port# %04d\n",
+	    ha->host_no, __func__,
+	    pflash_init_fw_cb->init_fw_cb.iSNSIPAddr[0],
+	    pflash_init_fw_cb->init_fw_cb.iSNSIPAddr[1],
+	    pflash_init_fw_cb->init_fw_cb.iSNSIPAddr[2],
+	    pflash_init_fw_cb->init_fw_cb.iSNSIPAddr[3],
+	    pflash_init_fw_cb->init_fw_cb.iSNSServerPortNumber));
+
+	/*
+	 * If the internal iSNS info is different from the flash_init_fw_cb,
+	 * flash it now.
+	 *------------------------------------------------------------------*/
+	if (((ha->tcp_options & TOPT_LEARN_ISNS_IP_ADDR_ENABLE) !=
+	    (pflash_init_fw_cb->init_fw_cb.TCPOptions &
+	    TOPT_LEARN_ISNS_IP_ADDR_ENABLE)) ||
+	    (!IPAddrIsEqual(ha->isns_ip_address,
+	    pflash_init_fw_cb->init_fw_cb.iSNSIPAddr)) ||
+	    (ha->isns_server_port_number !=
+	    pflash_init_fw_cb->init_fw_cb.iSNSServerPortNumber)) {
+		memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+		memset(&mbox_sts, 0, sizeof(mbox_sts));
+		mbox_cmd[0] = MBOX_CMD_WRITE_FLASH;
+		mbox_cmd[1] = LSDW(ha->ioctl_dma_bufp);
+		mbox_cmd[2] = MSDW(ha->ioctl_dma_bufp);
+		mbox_cmd[3] = INT_ISCSI_INITFW_FLASH_OFFSET;
+		mbox_cmd[4] = sizeof(*pflash_init_fw_cb);
+		mbox_cmd[5] = WRITE_FLASH_OPTION_COMMIT_DATA;
+
+		if (qla4xxx_mailbox_command(ha, 6, 2, &mbox_cmd[0],
+		    &mbox_sts[0]) == QLA_ERROR) {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: WRITE_FLASH command failed \n",
+			    ha->host_no, __func__));
+
+			ioctl->Status = EXT_STATUS_ERR;
+			ioctl->DetailStatus = mbox_sts[0];
+			ioctl->ResponseLen = 0;
+			goto exit_set_isns_svr;
+		}
+
+		QL4PRINT(QLP4,
+		    printk("scsi%d: %s: WRITE_FLASH command successful \n",
+				ha->host_no, __func__));
+		QL4PRINT(QLP4,
+		    printk("scsi%d: Init Fw Ctrl Blk\n", ha->host_no));
+		qla4xxx_dump_bytes(QLP4, pflash_init_fw_cb,
+		    sizeof(FLASH_INIT_FW_CTRL_BLK));
+
+		/*
+		 * Update internal iSNS info
+		 */
+		if (pisns_server->AutomaticiSNSDiscovery)
+			ha->tcp_options |= TOPT_LEARN_ISNS_IP_ADDR_ENABLE;
+		else
+			ha->tcp_options	&= ~TOPT_LEARN_ISNS_IP_ADDR_ENABLE;
+
+		memcpy(ha->isns_ip_address,
+		       pflash_init_fw_cb->init_fw_cb.iSNSIPAddr,
+		       MIN(sizeof(ha->isns_ip_address),
+		sizeof(pflash_init_fw_cb->init_fw_cb.iSNSIPAddr)));
+
+		ha->isns_server_port_number =
+		pflash_init_fw_cb->init_fw_cb.iSNSServerPortNumber;
+	}
+
+	/*
+	 * Start or Stop iSNS Service accordingly, if needed.
+	 *---------------------------------------------------*/
+	//FIXME:
+	if (test_bit(ISNS_FLAG_ISNS_ENABLED_IN_ISP, &ha->isns_flags)) {
+		if (!IPAddrIsZero(ha->isns_ip_address) &&
+		    ha->isns_server_port_number &&
+		    (ha->tcp_options & TOPT_LEARN_ISNS_IP_ADDR_ENABLE) == 0) {
+			uint32_t ip_addr;
+			IPAddr2Uint32(ha->isns_ip_address, &ip_addr);
+
+			status = qla4xxx_isns_reenable(ha, ip_addr,
+			    ha->isns_server_port_number);
+
+			if (status == QLA_ERROR) {
+				QL4PRINT(QLP4, printk(
+				    "scsi%d: qla4xxx_isns_reenable failed!\n",
+				    ha->host_no));
+				ioctl->Status = EXT_STATUS_ERR;
+				ioctl->DetailStatus = 0;
+				ioctl->ResponseLen = 0;
+				goto exit_set_isns_svr;
+			}
+		} else if (test_bit(ISNS_FLAG_ISNS_SRV_ENABLED, 
+		    &ha->isns_flags) && IPAddrIsZero(ha->isns_ip_address)) {
+			qla4xxx_isns_disable(ha);
+		}
+	}
+
+	/*
+	 * Complete IOCTL successfully
+	 *----------------------------*/
+	ioctl->Status = EXT_STATUS_OK;
+	ioctl->DetailStatus = 0;
+	ioctl->ResponseLen = 0;
+
+exit_set_isns_svr:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_set_data
+ *	This routine calls set data IOCTLs based on the IOCTL Sub Code.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *    	-EINVAL     = if the command is invalid
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int qla4extioctl_set_data(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	switch (ioctl->SubCode) {
+	case EXT_SC_RST_STATISTICS_GEN:
+		return(qla4extioctl_rst_statistics_gen(ha, ioctl));
+
+	case EXT_SC_RST_STATISTICS_ISCSI:
+		return(qla4extioctl_rst_statistics_iscsi(ha, ioctl));
+
+	case EXT_SC_SET_DEVICE_ENTRY_ISCSI:
+		return(qla4extioctl_set_device_entry_iscsi(ha, ioctl));
+
+	case EXT_SC_SET_INIT_FW_ISCSI:
+		return(qla4extioctl_set_init_fw_iscsi(ha, ioctl));
+
+	case EXT_SC_SET_ISNS_SERVER:
+		return(qla4extioctl_set_isns_server(ha, ioctl));
+
+	default:
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unsupported set data sub-command "
+		    "code (%X)\n",
+		    ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		return(0);
+	}
+	return(0);
+}
+
+/**************************************************************************
+ * qla4xxx_ioctl_sleep_done
+ *	This routine is the callback function to wakeup ioctl completion
+ *	semaphore for the ioctl request that is waiting.
+ *
+ * Input:
+ *   	sem - pointer to the ioctl completion semaphore.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static void
+qla4xxx_ioctl_sleep_done (struct semaphore * sem)
+{
+	ENTER(__func__);
+
+	if (sem != NULL) {
+		QL4PRINT(QLP4, printk("%s: wake up sem.\n", __func__));
+		QL4PRINT(QLP10, printk("%s: UP count=%d\n", __func__,
+		    atomic_read(&sem->count)));
+		up(sem);
+	}
+
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+ * qla4xxx_ioctl_sem_init
+ *	This routine initializes the ioctl timer and semaphore used to wait
+ *	for passthru completion.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+void
+qla4xxx_ioctl_sem_init (scsi_qla_host_t *ha)
+{
+	init_timer(&(ha->ioctl->ioctl_cmpl_timer));
+	ha->ioctl->ioctl_cmpl_timer.data = (ulong)&ha->ioctl->ioctl_cmpl_sem;
+	ha->ioctl->ioctl_cmpl_timer.function =
+	    (void (*)(ulong))qla4xxx_ioctl_sleep_done;
+}
+
+/**************************************************************************
+ * qla4xxx_scsi_pass_done
+ *	This routine resets the ioctl progress flag and wakes up the ioctl
+ * 	completion semaphore.
+ *
+ * Input:
+ *   	cmd - pointer to the passthru Scsi cmd structure which has completed.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	None
+ *
+ * Context:
+ *	Interrupt context.
+ **************************************************************************/
+void
+qla4xxx_scsi_pass_done(struct scsi_cmnd *cmd)
+{
+	scsi_qla_host_t *ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	ENTER(__func__);
+
+	/* First check to see if the command has previously timed-out
+	 * because we don't want to get the up/down semaphore counters off.
+	 */
+	if (ha->ioctl->ioctl_scsi_pass_in_progress == 1) {
+		ha->ioctl->ioctl_scsi_pass_in_progress = 0;
+		ha->ioctl->ioctl_tov = 0;
+		ha->ioctl->ioctl_err_cmd = NULL;
+
+		up(&ha->ioctl->ioctl_cmpl_sem);
+	}
+
+	LEAVE(__func__);
+
+	return;
+}
+
+/**************************************************************************
+ * qla4extioctl_scsi_passthru
+ *	This routine
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Map of DMA Buffer:
+ *    +-------------------------+
+ *    | EXT_SCSI_PASSTHRU_ISCSI |
+ *    +-------------------------+
+ *    | [SCSI READ|WRITE data]  |
+ *    +-------------------------+
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_scsi_passthru(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	ddb_entry_t		*ddb_entry;
+	int			i;
+	EXT_SCSI_PASSTHRU_ISCSI *pscsi_pass;
+	struct scsi_device	*pscsi_device;
+	struct scsi_cmnd	*pscsi_cmd;
+	srb_t			*srb;
+	uint32_t		dma_buf_len;
+	os_tgt_t		*tgt_entry;
+	os_lun_t		*lun_entry;
+	fc_port_t		*fcport;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (!ADAPTER_UP(ha)) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: command not pocessed, "
+		    "adapter link down.\n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_HBA_NOT_READY;
+		return(QLA_ERROR);
+	}
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pscsi_cmd,
+	    sizeof(struct scsi_cmnd))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(struct scsi_cmnd)));
+		goto error_exit_scsi_pass;
+	}
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pscsi_device,
+	    sizeof(struct scsi_device))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(struct scsi_device)));
+		goto error_exit_scsi_pass;
+	}
+
+	if (qla4xxx_get_ioctl_scrap_mem(ha, (void **)&pscsi_pass,
+	    sizeof(EXT_SCSI_PASSTHRU_ISCSI))) {
+		/* not enough memory */
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s(%d): inst=%d scrap not big enough. "
+		    "size requested=%ld.\n",
+		    __func__, ha->host_no, ha->instance,
+		    (ulong)sizeof(EXT_SCSI_PASSTHRU_ISCSI)));
+		goto error_exit_scsi_pass;
+	}
+
+	memset(pscsi_device, 0, sizeof(struct scsi_device));
+	memset(pscsi_pass, 0, sizeof(EXT_SCSI_PASSTHRU_ISCSI));
+	memset(pscsi_cmd, 0, sizeof(struct scsi_cmnd));
+	pscsi_cmd->device = pscsi_device;
+
+	/* ---- Get passthru structure from user space ---- */
+	if ((status = copy_from_user((uint8_t *)pscsi_pass,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr),
+	    sizeof(EXT_SCSI_PASSTHRU_ISCSI))) != 0) {
+		QL4PRINT(QLP2,
+		    printk("scsi%d: %s: unable to copy passthru struct "
+		    "from user's memory area.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto error_exit_scsi_pass;
+	}
+
+	QL4PRINT(QLP4|QLP10,
+	    printk("scsi%d: %s: incoming  EXT_SCSI_PASSTHRU_ISCSI structure:\n",
+	    ha->host_no, __func__));
+	qla4xxx_dump_bytes(QLP4|QLP10,
+	    pscsi_pass, sizeof(EXT_SCSI_PASSTHRU_ISCSI));
+
+	/* ---- Make sure device exists ---- */
+	tgt_entry = qla4xxx_lookup_target_by_SCSIID(ha, pscsi_pass->Addr.Bus,
+	    pscsi_pass->Addr.Target);
+	if (tgt_entry ==  NULL) {
+		goto error_exit_scsi_pass;
+	}
+
+	lun_entry = qla4xxx_lookup_lun_handle(ha, tgt_entry,
+	    pscsi_pass->Addr.Lun);
+	if (lun_entry ==  NULL) {
+		goto error_exit_scsi_pass;
+	}
+
+	fcport = lun_entry->fclun->fcport;
+	if (fcport ==  NULL) {
+		goto error_exit_scsi_pass;
+	}
+
+	ddb_entry = fcport->ddbptr;
+
+	if (ddb_entry == NULL) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: invalid device (b%d,t%d) specified.\n",
+		    ha->host_no, __func__,
+		    pscsi_pass->Addr.Bus, pscsi_pass->Addr.Target));
+
+		ioctl->Status = EXT_STATUS_DEV_NOT_FOUND;
+		goto error_exit_scsi_pass;
+	}
+
+	/* ---- Make sure device is in an active state ---- */
+	if (ddb_entry->fw_ddb_device_state != DDB_DS_SESSION_ACTIVE) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: device (b%d,t%d) not in active state\n",
+		    ha->host_no, __func__,
+		    pscsi_pass->Addr.Bus, pscsi_pass->Addr.Target));
+
+		ioctl->Status = EXT_STATUS_DEVICE_NOT_READY;
+		goto error_exit_scsi_pass;
+	}
+
+	/* ---- Retrieve srb from pool ---- */
+	srb = del_from_free_srb_q_head(ha);
+	if (srb == NULL) {
+		QL4PRINT(QLP2|QLP4, printk("scsi%d: %s: srb not available\n",
+		    ha->host_no, __func__));
+		goto error_exit_scsi_pass;
+	}
+
+	/* ---- Allocate larger DMA buffer, if neccessary ---- */
+	dma_buf_len = MAX(ioctl->ResponseLen - sizeof(EXT_SCSI_PASSTHRU_ISCSI),
+	    ioctl->RequestLen - sizeof(EXT_SCSI_PASSTHRU_ISCSI));
+
+	if (ha->ioctl_dma_buf_len < dma_buf_len &&
+	    qla4xxx_resize_ioctl_dma_buf(ha, dma_buf_len) != QLA_SUCCESS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: ERROR cannot allocate requested "
+		    "DMA buffer size 0x%x.\n",
+		    ha->host_no, __func__, dma_buf_len));
+
+		ioctl->Status = EXT_STATUS_NO_MEMORY;
+		goto error_exit_scsi_pass;
+	}
+
+	memset(ha->ioctl_dma_bufv, 0, ha->ioctl_dma_buf_len);
+
+	/* ---- Fill in the SCSI command structure ---- */
+	pscsi_cmd->device->channel = pscsi_pass->Addr.Bus;
+	pscsi_cmd->device->id = pscsi_pass->Addr.Target;
+	pscsi_cmd->device->lun = pscsi_pass->Addr.Lun;
+	pscsi_cmd->device = pscsi_device;
+	pscsi_cmd->device->host = ha->host;
+	pscsi_cmd->request_buffer = ha->ioctl_dma_bufv;
+	pscsi_cmd->scsi_done = qla4xxx_scsi_pass_done;
+	pscsi_cmd->timeout_per_command = IOCTL_PASSTHRU_TOV * HZ;
+
+	CMD_SP(pscsi_cmd) = (char *) srb;
+	srb->cmd = pscsi_cmd;
+	srb->fw_ddb_index = ddb_entry->fw_ddb_index;
+	srb->lun = pscsi_cmd->device->lun;
+	srb->flags |= SRB_IOCTL_CMD;
+
+	if (pscsi_pass->CdbLength == 6 || pscsi_pass->CdbLength == 10 ||
+	    pscsi_pass->CdbLength == 12 || pscsi_pass->CdbLength == 16) {
+		pscsi_cmd->cmd_len = pscsi_pass->CdbLength;
+	} else {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: Unsupported CDB length 0x%x \n",
+		    ha->host_no, __func__, pscsi_cmd->cmd_len));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto error_exit_scsi_pass;
+	}
+
+	if (pscsi_pass->Direction == EXT_DEF_SCSI_PASSTHRU_DATA_IN) {
+		pscsi_cmd->sc_data_direction = DMA_FROM_DEVICE;
+		pscsi_cmd->request_bufflen = ioctl->ResponseLen -
+		    sizeof(EXT_SCSI_PASSTHRU_ISCSI);
+
+	} else if (pscsi_pass->Direction ==  EXT_DEF_SCSI_PASSTHRU_DATA_OUT) {
+		pscsi_cmd->sc_data_direction = DMA_TO_DEVICE;
+		pscsi_cmd->request_bufflen = ioctl->RequestLen -
+		    sizeof(EXT_SCSI_PASSTHRU_ISCSI);
+
+		/* Sending user data from ioctl->ResponseAddr to SCSI
+		 * command buffer
+		 */
+		if ((status = copy_from_user((uint8_t *)pscsi_cmd->
+		    request_buffer, Q64BIT_TO_PTR(ioctl->RequestAdr) +
+		    sizeof(EXT_SCSI_PASSTHRU_ISCSI),
+		    pscsi_cmd->request_bufflen)) != 0) {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: unable to copy write buffer "
+			    "from user's memory area.\n",
+			    ha->host_no, __func__));
+
+			ioctl->Status = EXT_STATUS_COPY_ERR;
+			goto error_exit_scsi_pass;
+		}
+	} else {
+		pscsi_cmd->sc_data_direction = DMA_NONE;
+		pscsi_cmd->request_buffer  = 0;
+		pscsi_cmd->request_bufflen = 0;
+	}
+
+	memcpy(pscsi_cmd->cmnd, pscsi_pass->Cdb, pscsi_cmd->cmd_len);
+	memcpy(pscsi_cmd->data_cmnd, pscsi_pass->Cdb, pscsi_cmd->cmd_len);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d:%d:%d:%d: %s: CDB = ",
+	    ha->host_no, pscsi_cmd->device->channel, pscsi_cmd->device->id,
+	    pscsi_cmd->device->lun, __func__));
+
+	for (i = 0; i < pscsi_cmd->cmd_len; i++)
+		QL4PRINT(QLP4, printk("%02X ", pscsi_cmd->cmnd[i]));
+
+	QL4PRINT(QLP4, printk("\n"));
+
+
+	/* ---- prepare for receiving completion ---- */
+	ha->ioctl->ioctl_scsi_pass_in_progress = 1;
+	ha->ioctl->ioctl_tov = pscsi_cmd->timeout_per_command;
+
+	qla4xxx_ioctl_sem_init(ha);
+	CMD_COMPL_STATUS(pscsi_cmd)  = IOCTL_INVALID_STATUS;
+	CMD_PASSTHRU_TYPE(pscsi_cmd) = (void *)1;
+
+	/* ---- send command to adapter ---- */
+	QL4PRINT(QLP4, printk("scsi%d:%d:%d:%d: %s: sending command.\n",
+	    ha->host_no, pscsi_cmd->device->channel, pscsi_cmd->device->id,
+	    pscsi_cmd->device->lun, __func__));
+
+	ha->ioctl->ioctl_cmpl_timer.expires = jiffies + ha->ioctl->ioctl_tov;
+	add_timer(&ha->ioctl->ioctl_cmpl_timer);
+
+	if (qla4xxx_send_command_to_isp(ha, srb) != QLA_SUCCESS) {
+		add_to_free_srb_q(ha, srb);
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: error sending cmd to isp\n",
+		    ha->host_no, __func__));
+		del_timer(&ha->ioctl->ioctl_cmpl_timer);
+		ioctl->Status = EXT_STATUS_DEV_NOT_FOUND;
+		goto error_exit_scsi_pass;
+	}
+
+	down(&ha->ioctl->ioctl_cmpl_sem);
+
+	/*******************************************************
+	 *						       *
+	 *             Passthru Completion                     *
+	 *						       *
+	 *******************************************************/
+	del_timer(&ha->ioctl->ioctl_cmpl_timer);
+
+	/* ---- check for timeout --- */
+	if (ha->ioctl->ioctl_scsi_pass_in_progress == 1) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: ERROR = command timeout.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+
+		if ((srb != NULL) && (srb->active_array_index < MAX_SRBS)) {
+			u_long wait_cnt = WAIT_CMD_TOV;
+
+			if ((srb->flags & SRB_FREE_STATE) == 0)
+				qla4xxx_delete_timer_from_cmd(srb);
+
+			/* Wait for command to get out of active state */
+			wait_cnt = jiffies + WAIT_CMD_TOV * HZ;
+			while (wait_cnt > jiffies){
+				if (srb->flags != SRB_ACTIVE_STATE)
+					break;
+
+				QL4PRINT(QLP7, printk("."));
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				schedule_timeout(1 * HZ);
+			}
+		}
+
+		ha->ioctl->ioctl_scsi_pass_in_progress = 0;
+		goto error_exit_scsi_pass;
+	}
+
+	/* --- Return info from status entry --- */
+	ioctl->DetailStatus = CMD_SCSI_STATUS(pscsi_cmd);
+	pscsi_pass->Reserved[0] = (uint8_t) CMD_SCSI_STATUS(pscsi_cmd);
+	pscsi_pass->Reserved[1] = (uint8_t) CMD_COMPL_STATUS(pscsi_cmd);
+	pscsi_pass->Reserved[2] = (uint8_t) CMD_ACTUAL_SNSLEN(pscsi_cmd);
+	pscsi_pass->Reserved[3] = (uint8_t) CMD_HOST_STATUS(pscsi_cmd);
+	pscsi_pass->Reserved[6] = (uint8_t) CMD_ISCSI_RESPONSE(pscsi_cmd);
+	pscsi_pass->Reserved[7] = (uint8_t) CMD_STATE_FLAGS(pscsi_cmd);
+
+	if (CMD_ACTUAL_SNSLEN(pscsi_cmd)) {
+		memcpy(pscsi_pass->SenseData, pscsi_cmd->sense_buffer,
+		    MIN(CMD_ACTUAL_SNSLEN(pscsi_cmd),
+		    sizeof(pscsi_pass->SenseData)));
+	}
+
+	/* ---- check for command completion --- */
+	if (CMD_COMPL_STATUS(pscsi_cmd) == IOCTL_INVALID_STATUS) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d:%d:%d:%d: %s: ERROR = "
+		    "command not completed.\n",
+		    ha->host_no, pscsi_cmd->device->channel,
+		    pscsi_cmd->device->id,
+		    pscsi_cmd->device->lun, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		goto error_exit_scsi_pass;
+
+	} else if (CMD_HOST_STATUS(pscsi_cmd) == DID_OK) {
+
+		ioctl->Status = EXT_STATUS_OK;
+
+	} else if (CMD_COMPL_STATUS(pscsi_cmd) == SCS_DATA_UNDERRUN) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: Data underrun.  Resid = 0x%x\n",
+		    ha->host_no, __func__, CMD_RESID_LEN(pscsi_cmd)));
+
+		ioctl->Status = EXT_STATUS_DATA_UNDERRUN;
+		pscsi_pass->Reserved[4] = MSB(CMD_RESID_LEN(pscsi_cmd));
+		pscsi_pass->Reserved[5] = LSB(CMD_RESID_LEN(pscsi_cmd));
+
+	} else if (CMD_COMPL_STATUS(pscsi_cmd) == SCS_DATA_OVERRUN) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: Data overrun.  Resid = 0x%x\n",
+		    ha->host_no, __func__, CMD_RESID_LEN(pscsi_cmd)));
+
+		ioctl->Status = EXT_STATUS_DATA_OVERRUN;
+		pscsi_pass->Reserved[4] = MSB(CMD_RESID_LEN(pscsi_cmd));
+		pscsi_pass->Reserved[5] = LSB(CMD_RESID_LEN(pscsi_cmd));
+
+	} else {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: Command completed in ERROR. "
+		    "cs=%04x, ss=%-4x\n", ha->host_no, __func__,
+		    CMD_COMPL_STATUS(pscsi_cmd), CMD_SCSI_STATUS(pscsi_cmd)));
+
+		if (CMD_SCSI_STATUS(pscsi_cmd) != SCSI_GOOD) {
+			ioctl->Status = EXT_STATUS_SCSI_STATUS;
+		} else {
+			ioctl->Status = EXT_STATUS_ERR;
+		}
+	}
+
+	/* ---- Copy SCSI Passthru structure with updated sense buffer
+	 *      to user space ----
+	 */
+	if (copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr), pscsi_pass,
+	    sizeof(EXT_SCSI_PASSTHRU_ISCSI)) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unable to copy passthru struct "
+		    "to user's memory area.\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto error_exit_scsi_pass;
+	}
+
+	QL4PRINT(QLP4|QLP10,
+	    printk("scsi%d: %s: outgoing EXT_SCSI_PASSTHRU_ISCSI structure:\n",
+	    ha->host_no, __func__));
+	qla4xxx_dump_bytes(QLP4|QLP10,
+	    Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    sizeof(EXT_SCSI_PASSTHRU_ISCSI));
+
+	/* ---- Copy SCSI READ data from SCSI command buffer
+	*       to user space ---- */
+	if (pscsi_pass->Direction == EXT_DEF_SCSI_PASSTHRU_DATA_IN) {
+		void    *xfer_ptr = Q64BIT_TO_PTR(ioctl->ResponseAdr) +
+				    sizeof(EXT_SCSI_PASSTHRU_ISCSI);
+		uint32_t xfer_len = ioctl->ResponseLen -
+				    sizeof(EXT_SCSI_PASSTHRU_ISCSI);
+
+
+		/* Update ResponseLen if a data underrun occurred */
+		if (CMD_COMPL_STATUS(pscsi_cmd) == SCS_DATA_UNDERRUN &&
+		    CMD_RESID_LEN(pscsi_cmd)) {
+			xfer_len -= CMD_RESID_LEN(pscsi_cmd);
+		}
+
+		if ((status = copy_to_user(xfer_ptr, pscsi_cmd->request_buffer,
+		    xfer_len)) != 0) {
+			QL4PRINT(QLP2|QLP4,
+			    printk("scsi%d: %s: unable to copy READ data "
+			    "to user's memory area.\n",
+			    ha->host_no, __func__));
+
+			ioctl->Status = EXT_STATUS_COPY_ERR;
+			goto error_exit_scsi_pass;
+		}
+
+		QL4PRINT(QLP4|QLP10,
+		    printk("scsi%d: %s: outgoing READ data:  (0x%p)\n",
+		    ha->host_no, __func__, xfer_ptr));
+
+		qla4xxx_dump_bytes(QLP4|QLP10, xfer_ptr, xfer_len);
+	}
+
+	goto exit_scsi_pass;
+
+error_exit_scsi_pass:
+	ioctl->ResponseLen = 0;
+
+exit_scsi_pass:
+	qla4xxx_free_ioctl_scrap_mem(ha);
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_iscsi_passthru
+ *	This routine sends iSCSI pass-through to destination.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_iscsi_passthru(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+	QL4PRINT(QLP4, printk("scsi%d: %s: UNSUPPORTED\n",
+	    ha->host_no, __func__));
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/**************************************************************************
+ * qla4extioctl_get_hbacnt
+ *	This routine retrieves the number of supported HBAs found.
+ *
+ * Input:
+ *	ha    = adapter structure pointer.
+ *	ioctl = IOCTL structure pointer.
+ *
+ * Output:
+ *	None
+ *
+ * Returns:
+ *	QLA_SUCCESS = success
+ *	QLA_ERROR   = error
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+static int
+qla4extioctl_get_hbacnt(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	EXT_HBA_COUNT	hba_cnt;
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	hba_cnt.HbaCnt = qla4xxx_get_hba_count();
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr),
+	    &hba_cnt, sizeof(hba_cnt))) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: failed to copy data\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_hbacnt;
+	}
+
+	QL4PRINT(QLP4, printk("scsi%d: %s: hbacnt is %d\n",
+	    ha->host_no, __func__, hba_cnt.HbaCnt));
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_get_hbacnt:
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+STATIC int
+qla4extioctl_get_hostno(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d entered.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	ioctl->HbaSelect = ha->host_no;
+	ioctl->Status = EXT_STATUS_OK;
+
+	QL4PRINT(QLP4, printk("scsi%d: %s: instance is %d\n",
+	    ha->host_no, __func__, ha->instance));
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+STATIC int
+qla4extioctl_driver_specific(scsi_qla_host_t *ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	EXT_LN_DRIVER_DATA      data;
+
+
+	ENTER(__func__);
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+
+	if (ioctl->ResponseLen < sizeof(EXT_LN_DRIVER_DATA)) {
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: ERROR ResponseLen too small.\n",
+		    __func__));
+
+		goto exit_driver_specific;
+	}
+
+	data.DrvVer.Major = QL4_DRIVER_MAJOR_VER;
+	data.DrvVer.Minor = QL4_DRIVER_MINOR_VER;
+	data.DrvVer.Patch = QL4_DRIVER_PATCH_VER;
+	data.DrvVer.Beta  = QL4_DRIVER_BETA_VER;
+	/* RLU: set this flag when code is added.
+	data.Flags = EXT_DEF_NGFO_CAPABLE;
+	 */
+	if (IS_QLA4010(ha))
+		data.AdapterModel = EXT_DEF_QLA4010_DRIVER;
+	else if (IS_QLA4022(ha))
+		data.AdapterModel = EXT_DEF_QLA4022_DRIVER;
+
+	status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr), &data,
+	    sizeof(EXT_LN_DRIVER_DATA));
+
+	if (status) {
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: ERROR copy resp buf\n", __func__));
+	}
+
+exit_driver_specific:
+
+	QL4PRINT(QLP4,
+	    printk("scsi%d: %s: inst %d exiting.\n",
+	    ha->host_no, __func__, ha->instance));
+	LEAVE(__func__);
+
+	return(status);
+}
+
+ioctl_tbl_row_t IOCTL_CMD_TBL[] =
+{
+	{EXT_CC_QUERY, "EXT_CC_QUERY"},
+	{EXT_CC_REG_AEN, "EXT_CC_REG_AEN"},
+	{EXT_CC_GET_AEN, "EXT_CC_GET_AEN"},
+	{EXT_CC_GET_DATA, "EXT_CC_GET_DATA"},
+	{EXT_CC_SET_DATA, "EXT_CC_SET_DATA"},
+	{EXT_CC_SEND_SCSI_PASSTHRU, "EXT_CC_SEND_SCSI_PASSTHRU"},
+	{EXT_CC_SEND_ISCSI_PASSTHRU, "EXT_CC_SEND_ISCSI_PASSTHRU"},
+	{INT_CC_LOGOUT_ISCSI, "INT_CC_LOGOUT_ISCSI"},
+	{EXT_CC_GET_HBACNT, "EXT_CC_GET_HBACNT"},
+	{INT_CC_DIAG_PING, "INT_CC_DIAG_PING"},
+	{INT_CC_GET_DATA, "INT_CC_GET_DATA"},
+	{INT_CC_SET_DATA, "INT_CC_SET_DATA"},
+	{INT_CC_HBA_RESET, "INT_CC_HBA_RESET"},
+	{INT_CC_COPY_FW_FLASH, "INT_CC_COPY_FW_FLASH"},
+	{INT_CC_IOCB_PASSTHRU, "INT_CC_IOCB_PASSTHRU"},
+	{0, "UNKNOWN"}
+};
+
+ioctl_tbl_row_t IOCTL_SCMD_QUERY_TBL[] =
+{
+	{EXT_SC_QUERY_HBA_ISCSI_NODE, "EXT_SC_QUERY_HBA_ISCSI_NODE"},
+	{EXT_SC_QUERY_HBA_ISCSI_PORTAL, "EXT_SC_QUERY_HBA_ISCSI_PORTAL"},
+	{EXT_SC_QUERY_DISC_ISCSI_NODE, "EXT_SC_QUERY_DISC_ISCSI_NODE"},
+	{EXT_SC_QUERY_DISC_ISCSI_PORTAL, "EXT_SC_QUERY_DISC_ISCSI_PORTAL"},
+	{EXT_SC_QUERY_DRIVER, "EXT_SC_QUERY_DRIVER"},
+	{EXT_SC_QUERY_FW, "EXT_SC_QUERY_FW"},
+	{EXT_SC_QUERY_CHIP, "EXT_SC_QUERY_CHIP"},
+	{0, "UNKNOWN"}
+};
+
+ioctl_tbl_row_t IOCTL_SCMD_EGET_DATA_TBL[] =
+{
+	{EXT_SC_GET_STATISTICS_ISCSI, "EXT_SC_GET_STATISTICS_ISCSI"},
+	{EXT_SC_GET_DEVICE_ENTRY_ISCSI, "EXT_SC_GET_DEVICE_ENTRY_ISCSI"},
+	{EXT_SC_GET_DEVICE_ENTRY_DEFAULTS_ISCSI, "EXT_SC_GET_DEVICE_ENTRY_DEFAULTS_ISCSI"},
+	{EXT_SC_GET_INIT_FW_ISCSI, "EXT_SC_GET_INIT_FW_ISCSI"},
+	{EXT_SC_GET_INIT_FW_DEFAULTS_ISCSI, "EXT_SC_GET_INIT_FW_DEFAULTS_ISCSI"},
+	{EXT_SC_GET_ISNS_SERVER, "EXT_SC_GET_ISNS_SERVER"},
+	{EXT_SC_GET_ISNS_DISCOVERED_TARGETS, "EXT_SC_GET_ISNS_DISCOVERED_TARGETS"},
+	{0, "UNKNOWN"}
+};
+
+ioctl_tbl_row_t IOCTL_SCMD_ESET_DATA_TBL[] =
+{
+	{EXT_SC_RST_STATISTICS_GEN, "EXT_SC_RST_STATISTICS_GEN"},
+	{EXT_SC_RST_STATISTICS_ISCSI, "EXT_SC_RST_STATISTICS_ISCSI"},
+	{EXT_SC_SET_DEVICE_ENTRY_ISCSI, "EXT_SC_SET_DEVICE_ENTRY_ISCSI"},
+	{EXT_SC_SET_INIT_FW_ISCSI, "EXT_SC_SET_INIT_FW_ISCSI"},
+	{EXT_SC_SET_ISNS_SERVER, "EXT_SC_SET_ISNS_SERVER"},
+	{0, "UNKNOWN"}
+};
+
+char *IOCTL_TBL_STR(int cc, int sc)
+{
+	ioctl_tbl_row_t *r;
+	int cmd;
+
+	switch (cc) {
+	case EXT_CC_QUERY:
+		r = IOCTL_SCMD_QUERY_TBL;
+		cmd = sc;
+		break;
+	case EXT_CC_GET_DATA:
+		r = IOCTL_SCMD_EGET_DATA_TBL;
+		cmd = sc;
+		break;
+	case EXT_CC_SET_DATA:
+		r = IOCTL_SCMD_ESET_DATA_TBL;
+		cmd = sc;
+		break;
+	case INT_CC_GET_DATA:
+		r = IOCTL_SCMD_IGET_DATA_TBL;
+		cmd = sc;
+		break;
+	case INT_CC_SET_DATA:
+		r = IOCTL_SCMD_ISET_DATA_TBL;
+		cmd = sc;
+		break;
+
+	default:
+		r = IOCTL_CMD_TBL;
+		cmd = cc;
+		break;
+	}
+
+	while (r->cmd != 0) {
+		if (r->cmd == cmd) break;
+		r++;
+	}
+	return(r->s);
+
+}
+
+/**************************************************************************
+ * qla4xxx_ioctl
+ * 	This the main entry point for all ioctl requests
+ *
+ * Input:
+ *	dev - pointer to SCSI device structure
+ *	cmd - internal or external ioctl command code
+ *	arg - pointer to the main ioctl structure
+ *
+ *	Instance field in ioctl structure - to determine which device to
+ *	perform ioctl
+ *	HbaSelect field in ioctl structure - to determine which adapter to
+ *	perform ioctl
+ *
+ * Output:
+ *	The resulting data/status is returned via the main ioctl structure.
+ *
+ *	When Status field in ioctl structure is valid for normal command errors
+ * 	this function returns 0 (QLA_SUCCESS).
+ *
+ *      All other return values indicate ioctl/system specific error which
+ *	prevented the actual ioctl command from completing.
+ *
+ * Returns:
+ *	 QLA_SUCCESS - command completed successfully, either with or without
+ *			errors in the Status field of the main ioctl structure
+ *    	-EFAULT      - arg pointer is NULL or memory access error
+ *    	-EINVAL      - command is invalid
+ *    	-ENOMEM      - memory allocation failed
+ *
+ * Context:
+ *	Kernel context.
+ **************************************************************************/
+int
+qla4xxx_ioctl(struct scsi_device *dev, int cmd, void *arg)
+{
+	EXT_IOCTL_ISCSI *pioctl = NULL;
+	scsi_qla_host_t *ha = NULL;
+	int status = 0;	/* ioctl status; errno value when function returns */
+	int tmp_stat;
+
+	ENTER(__func__);
+
+	/* Catch any non-exioct ioctls */
+	if (_IOC_TYPE(cmd) != QLMULTIPATH_MAGIC) {
+		printk(KERN_WARNING
+		    "qla4xxx: invalid ioctl magic number received.\n");
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi(): %s: invalid magic number received.\n",
+		    __func__));
+
+		status = (-EINVAL);
+		goto exit_qla4xxx_ioctl;
+	}
+
+	QL4PRINT(QLP4,
+	    printk("scsi(): %s: received cmd %x.\n",
+	    __func__, cmd));
+
+	switch (cmd) {
+		/* All NFO functions go here */
+	case EXT_CC_TRANSPORT_INFO:
+	case EXT_CC_GET_FOM_PROP:
+	case EXT_CC_GET_HBA_INFO:
+	case EXT_CC_GET_DPG_PROP:
+	case EXT_CC_GET_DPG_PATH_INFO:
+	case EXT_CC_SET_DPG_PATH_INFO:
+	case EXT_CC_GET_LB_INFO:
+	case EXT_CC_GET_LB_POLICY:
+	case EXT_CC_SET_LB_POLICY:
+	case EXT_CC_GET_DPG_STATS:
+	case EXT_CC_CLEAR_DPG_ERR_STATS:
+	case EXT_CC_CLEAR_DPG_IO_STATS:
+	case EXT_CC_CLEAR_DPG_FO_STATS:
+	case EXT_CC_GET_PATHS_FOR_ALL:
+	case EXT_CC_MOVE_PATH:
+	case EXT_CC_VERIFY_PATH:
+	case EXT_CC_GET_EVENT_LIST:
+	case EXT_CC_ENABLE_FOM:
+	case EXT_CC_DISABLE_FOM:
+	case EXT_CC_GET_STORAGE_LIST:
+		status = qla4xxx_nfo_ioctl(dev, cmd, arg);
+		goto exit_qla4xxx_ioctl;
+	}
+
+	/* Allocate ioctl structure buffer to support multiple concurrent
+	 * entries. NO static structures allowed.
+	 */
+	pioctl = QL_KMEM_ZALLOC(sizeof(EXT_IOCTL_ISCSI));
+	if (pioctl == NULL) {
+		/* error */
+		printk(KERN_WARNING
+		    "qla4xxx: ERROR in main ioctl buffer allocation.\n");
+		status = (-ENOMEM);
+		goto exit_qla4xxx_ioctl;
+	}
+
+	/*
+	 * Check to see if we can access the ioctl command structure
+	 */
+	if (!access_ok(VERIFY_WRITE, arg, sizeof(EXT_IOCTL_ISCSI))) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: EXT_IOCTL_ISCSI access error.\n",
+		    __func__));
+
+		status = (-EFAULT);
+		goto exit_qla4xxx_ioctl;
+	}
+
+	/*
+	 * Copy the ioctl command structure from user space to local structure
+	 */
+	if ((status = copy_from_user((uint8_t *)pioctl, arg,
+	    sizeof(EXT_IOCTL_ISCSI)))) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: EXT_IOCTL_ISCSI copy error.\n",
+		    __func__));
+
+		goto exit_qla4xxx_ioctl;
+	}
+
+	QL4PRINT(QLP4|QLP10, printk("EXT_IOCTL_ISCSI structure dump: \n"));
+	qla4xxx_dump_dwords(QLP4|QLP10, pioctl, sizeof(*pioctl));
+
+        /* check signature of this ioctl */
+	if (memcmp(pioctl->Signature, EXT_DEF_REGULAR_SIGNATURE,
+	    sizeof(EXT_DEF_REGULAR_SIGNATURE)) != 0) {
+		QL4PRINT(QLP2|QLP4,
+		    printk("%s: signature did not match. "
+		    "received cmd=%x arg=%p signature=%s.\n",
+		    __func__, cmd, arg, pioctl->Signature));
+		pioctl->Status = EXT_STATUS_INVALID_PARAM;
+		status = copy_to_user(arg, (void *)pioctl,
+		    sizeof(EXT_IOCTL_ISCSI));
+
+		goto exit_qla4xxx_ioctl;
+	}
+
+        /* check version of this ioctl */
+        if (pioctl->Version > EXT_VERSION) {
+                printk(KERN_WARNING
+                    "ql4xxx: ioctl interface version not supported = %d.\n",
+                    pioctl->Version);
+
+		pioctl->Status = EXT_STATUS_UNSUPPORTED_VERSION;
+		status = copy_to_user(arg, (void *)pioctl,
+		    sizeof(EXT_IOCTL_ISCSI));
+		goto exit_qla4xxx_ioctl;
+        }
+
+	/*
+	 * Get the adapter handle for the corresponding adapter instance
+	 */
+	ha = qla4xxx_get_adapter_handle(pioctl->HbaSelect);
+	if (ha == NULL) {
+		QL4PRINT(QLP2,
+		    printk("%s: NULL EXT_IOCTL_ISCSI buffer\n",
+		    __func__));
+
+		pioctl->Status = EXT_STATUS_DEV_NOT_FOUND;
+		status = copy_to_user(arg, (void *)pioctl,
+		    sizeof(EXT_IOCTL_ISCSI));
+		goto exit_qla4xxx_ioctl;
+	}
+
+	QL4PRINT(QLP4, printk("scsi%d: ioctl+ (%s)\n", ha->host_no,
+	    IOCTL_TBL_STR(cmd, pioctl->SubCode)));
+
+	down(&ha->ioctl->ioctl_sem);
+
+	/*
+	 * If the DPC is active, wait for it to complete before proceeding
+	 */
+	while (ha->dpc_active) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1*HZ);
+	}
+
+	ha->i_start = jiffies;
+	ha->i_end = 0;
+	ha->f_start = 0;
+	ha->f_end = 0;
+
+	/*
+	 * Issue the ioctl command
+	 */
+	switch (cmd) {
+	case EXT_CC_QUERY:
+		status = qla4extioctl_query(ha, pioctl);
+		break;
+
+	case EXT_CC_REG_AEN:
+		status = qla4extioctl_reg_aen(ha, pioctl);
+		break;
+
+	case EXT_CC_GET_AEN:
+		status = qla4extioctl_get_aen(ha, pioctl);
+		break;
+
+	case EXT_CC_GET_DATA:
+		status = qla4extioctl_get_data(ha, pioctl);
+		break;
+
+	case EXT_CC_SET_DATA:
+		status = qla4extioctl_set_data(ha, pioctl);
+		break;
+
+	case EXT_CC_SEND_SCSI_PASSTHRU:
+		status = qla4extioctl_scsi_passthru(ha, pioctl);
+		break;
+
+	case EXT_CC_SEND_ISCSI_PASSTHRU:
+		status = qla4extioctl_iscsi_passthru(ha, pioctl);
+		break;
+
+	case INT_CC_LOGOUT_ISCSI:
+		status = qla4intioctl_logout_iscsi(ha, pioctl);
+		break;
+
+	case EXT_CC_GET_HBACNT:
+		status = qla4extioctl_get_hbacnt(ha, pioctl);
+		break;
+
+	case EXT_CC_GET_HOST_NO:
+		status = qla4extioctl_get_hostno(ha, pioctl);
+		break;
+
+	case EXT_CC_DRIVER_SPECIFIC:
+		status = qla4extioctl_driver_specific(ha, pioctl);
+		break;
+
+	case INT_CC_DIAG_PING:
+		status = qla4intioctl_ping(ha, pioctl);
+		break;
+
+	case INT_CC_GET_DATA:
+		status = qla4intioctl_get_data(ha, pioctl);
+		break;
+
+	case INT_CC_SET_DATA:
+		status = qla4intioctl_set_data(ha, pioctl);
+		break;
+
+	case INT_CC_HBA_RESET:
+		status = qla4intioctl_hba_reset(ha, pioctl);
+		break;
+
+	case INT_CC_COPY_FW_FLASH:
+		status = qla4intioctl_copy_fw_flash(ha, pioctl);
+		break;
+
+	case INT_CC_IOCB_PASSTHRU:
+		status = qla4intioctl_iocb_passthru(ha, pioctl);
+		break;
+
+	default:
+		QL4PRINT(QLP2|QLP4,
+		    printk("scsi%d: %s: unsupported command code (%x)\n",
+		    ha->host_no, __func__, cmd));
+
+		pioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+	}
+
+	/*
+	 * Copy the updated ioctl structure back to the user
+	 */
+	tmp_stat = copy_to_user(arg, (void *)pioctl, sizeof(EXT_IOCTL_ISCSI));
+	if (status == 0) {
+		status = tmp_stat;
+	}
+
+	ha->i_end = jiffies;
+
+	up(&ha->ioctl->ioctl_sem);
+
+	QL4PRINT(QLP15, printk("scsi%d: ioctl- (%s) "
+	    "i_start=%lx, f_start=%lx, f_end=%lx, i_end=%lx\n",
+	    ha->host_no, IOCTL_TBL_STR(cmd, pioctl->SubCode),
+	    ha->i_start, ha->f_start, ha->f_end, ha->i_end));
+
+exit_qla4xxx_ioctl:
+
+	if (pioctl)
+		QL_KMEM_FREE(pioctl);
+
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlfo.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlfo.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlfo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlfo.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,145 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2003-2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/*
+ * San/Device Management Failover Ioctl Header
+ * File is created to adhere to Solaris requirement using 8-space tabs.
+ *
+ * !!!!! PLEASE DO NOT REMOVE THE TABS !!!!!
+ * !!!!! PLEASE NO SINGLE LINE COMMENTS: // !!!!!
+ * !!!!! PLEASE NO MORE THAN 80 CHARS PER LINE !!!!!
+ *
+ * Revision History:
+ *
+ * Rev. 0.00	August 8, 2000
+ * WTR	- Created.
+ *
+ * Rev. 0.01	August 8, 2000
+ * WTR	- Made size of HbaInstance fields consistant as UINT8.
+ *        Made command codes as 300 upward to be consistant with definitions
+ *        in ExIoct.h.
+ * Rev. 0.01	October 3, 2000
+ * TLE  - Exclusion of ExIoct.h
+ *
+ * Rev. 0.01	October 6, 2000
+ * TLE  - Made size of HbaInstance fields UINT8
+ *
+ * Rev. 0.01	October 10, 2000
+ * TLE  - Add _FO_DRIVER_VERSION data structure
+ */
+
+
+
+#ifndef _FO_H
+#define _FO_H
+
+/*
+ * ***********************************************************************
+ * X OS type definitions
+ * ***********************************************************************
+ */
+#ifdef _MSC_VER						/* NT */
+
+#pragma pack(1)
+#include "qlfont.h"
+
+#elif defined(linux)					/* Linux */
+
+#include "qlfoln.h"
+
+#elif defined(sun) || defined(__sun)			/* Solaris */
+
+#include "qlfoso.h"
+
+#endif
+
+#define SDM_DEF_MAX_DEVICES		16
+#define SDM_DEF_MAX_PATHS_PER_TARGET	4
+#define SDM_DEF_MAX_TARGETS_PER_DEVICE	4
+#define SDM_DEF_MAX_PATHS_PER_DEVICE (SDM_DEF_MAX_PATHS_PER_TARGET * SDM_DEF_MAX_TARGETS_PER_DEVICE)
+
+#define FO_MAX_LUNS_PER_DEVICE	MAX_LUNS_OS
+#define FO_MAX_PATHS (SDM_DEF_MAX_PATHS_PER_DEVICE * SDM_DEF_MAX_DEVICES)
+#define FO_MAX_ADAPTERS		32
+#define FO_ADAPTER_ALL		0xFF
+#define FO_DEF_WWN_SIZE             8
+#define FO_MAX_GEN_INFO_STRING_LEN  32
+
+#if 0	/* defined in qlfolimits.h */
+#define FO_NOTIFY_TYPE_NONE                   0
+#define FO_NOTIFY_TYPE_LUN_RESET              1
+#define FO_NOTIFY_TYPE_CDB                    2
+#define FO_NOTIFY_TYPE_LOGOUT_OR_LUN_RESET    3
+#define FO_NOTIFY_TYPE_LOGOUT_OR_CDB          4
+#define FO_NOTIFY_TYPE_SPINUP          	      5
+
+#define FO_NOTIFY_TYPE_MIN                FO_NOTIFY_TYPE_NONE
+#define FO_NOTIFY_TYPE_MAX                FO_NOTIFY_TYPE_LOGOUT_OR_CDB
+#define FO_NOTIFY_TYPE_DEF                FO_NOTIFY_TYPE_SPINUP
+
+#define FO_NOTIFY_CDB_LENGTH_MIN              6
+#define FO_NOTIFY_CDB_LENGTH_MAX             16
+#endif
+
+/*
+ * IOCTL Commands
+ */
+
+/* Systemwide failover parameters. */
+
+typedef struct _FO_PARAMS
+{
+        UINT32      InspectionInterval;     /* Timer interval to check for failover.*/
+        UINT8       MaxPathsPerDevice;	    /* Max paths to any single device. */
+        UINT8       MaxRetriesPerPath;	    /* Max retries on a path before */
+
+        /* Failover. */
+        UINT8       MaxRetriesPerIo;	    /* Max retries per i/o request. */
+        UINT8       Reserved1;
+        UINT32      Flags;			        /* Control flags. */
+        UINT8       DeviceErrorThreshold;   /* Max device errors. */
+        UINT8       DeviceTimeoutThreshold; /* Max device timeouts.*/
+        UINT8       FrameErrorThreshold;    /* Max frame errors.*/
+        UINT8       LinkErrorThreshold;     /* Max link errors.*/
+        UINT32      Reserved2[4];           /* Spares.*/
+
+        /* Load balancing parameters.*/
+
+        UINT8       RollingAverageIntervals;/* Intervals to sum for rolling average.*/
+        UINT8       MaxDevicesToMigrate;    /* Max devices to migrate in any interval.*/
+        UINT8       BalanceMethod;          /* Method to use for load balancing.*/
+        UINT8       Reserved3;              /* Memory alignment.*/
+
+        UINT16      LoadShareMinPercentage; /* Load balancing parameter.*/
+        UINT16      LoadShareMaxPercentage; /* Load balancing parameter.*/
+
+        /* Failover notify parameters. */
+
+        UINT8       FailoverNotifyType;	/* Type of notification. */
+        UINT8       FailoverNotifyCdbLength;/* Length of notification CDB. */
+        UINT16      Reserved4;
+        UINT8       FailoverNotifyCdb[16];	/* CDB if notification by CDB. */
+        UINT32      Reserved5;
+
+}
+FO_PARAMS, *PFO_PARAMS, SysFoParams_t, *SysFoParams_p;
+
+extern SysFoParams_t qla_fo_params;
+
+#endif	/* ifndef _FO_H */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlfolimits.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlfolimits.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlfolimits.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlfolimits.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,93 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.4.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/*
+ *  Minimums, maximums, defaults, and other definitions for MC_PARAMS.
+ */
+
+#define FO_INSPECTION_INTERVAL_MIN                     0
+#define FO_INSPECTION_INTERVAL_MAX               1000000
+#define FO_INSPECTION_INTERVAL_DEF                   600
+
+#define FO_MAX_PATHS_PER_DEVICE_MIN                    1
+#define FO_MAX_PATHS_PER_DEVICE_MAX                    8
+#define FO_MAX_PATHS_PER_DEVICE_DEF                    8
+
+#define FO_MAX_RETRIES_PER_PATH_MIN                    1
+#define FO_MAX_RETRIES_PER_PATH_MAX                    8
+#define FO_MAX_RETRIES_PER_PATH_DEF                    3
+
+#define FO_MAX_RETRIES_PER_IO_MIN          ((FO_MAX_PATHS_PER_DEVICE_MIN * FO_MAX_RETRIES_PER_PATH_MIN) + 1)
+#define FO_MAX_RETRIES_PER_IO_MAX          ((FO_MAX_PATHS_PER_DEVICE_MAX * FO_MAX_RETRIES_PER_PATH_MAX) + 1)
+#define FO_MAX_RETRIES_PER_IO_DEF          ((FO_MAX_PATHS_PER_DEVICE_DEF * FO_MAX_RETRIES_PER_PATH_DEF) + 1)
+
+#define FO_DEVICE_ERROR_THRESHOLD_MIN                  1
+#define FO_DEVICE_ERROR_THRESHOLD_MAX                255
+#define FO_DEVICE_ERROR_THRESHOLD_DEF                  4
+
+#define FO_DEVICE_TIMEOUT_THRESHOLD_MIN                1
+#define FO_DEVICE_TIMEOUT_THRESHOLD_MAX              255
+#define FO_DEVICE_TIMEOUT_THRESHOLD_DEF                4
+
+#define FO_FRAME_ERROR_THRESHOLD_MIN                   1
+#define FO_FRAME_ERROR_THRESHOLD_MAX                 255
+#define FO_FRAME_ERROR_THRESHOLD_DEF                   4
+
+#define FO_LINK_ERROR_THRESHOLD_MIN                    1
+#define FO_LINK_ERROR_THRESHOLD_MAX                  255
+#define FO_LINK_ERROR_THRESHOLD_DEF                    4
+
+#define FO_ROLLING_AVERAGE_INTERVALS_MIN               1
+#define FO_ROLLING_AVERAGE_INTERVALS_MAX              10
+#define FO_ROLLING_AVERAGE_INTERVALS_DEF               1
+
+#define FO_MAX_DEVICES_TO_MIGRATE_MIN                  0
+#define FO_MAX_DEVICES_TO_MIGRATE_MAX                255
+#define FO_MAX_DEVICES_TO_MIGRATE_DEF                  4
+
+#define FO_BALANCE_METHOD_NONE                         0
+#define FO_BALANCE_METHOD_IOS                          1
+#define FO_BALANCE_METHOD_MBS                          2
+
+#define FO_BALANCE_METHOD_MIN                      FO_BALANCE_METHOD_NONE
+#define FO_BALANCE_METHOD_MAX                      FO_BALANCE_METHOD_MBS
+#define FO_BALANCE_METHOD_DEF                      FO_BALANCE_METHOD_IOS
+
+#define FO_LOAD_SHARE_MIN_PERCENTAGE_MIN              25
+#define FO_LOAD_SHARE_MIN_PERCENTAGE_MAX              99
+#define FO_LOAD_SHARE_MIN_PERCENTAGE_DEF              75
+
+#define FO_LOAD_SHARE_MAX_PERCENTAGE_MIN             101
+#define FO_LOAD_SHARE_MAX_PERCENTAGE_MAX             500
+#define FO_LOAD_SHARE_MAX_PERCENTAGE_DEF             150
+
+#define FO_NOTIFY_TYPE_NONE                   0
+#define FO_NOTIFY_TYPE_LUN_RESET              1
+#define FO_NOTIFY_TYPE_CDB                    2
+#define FO_NOTIFY_TYPE_LOGOUT_OR_LUN_RESET    3
+#define FO_NOTIFY_TYPE_LOGOUT_OR_CDB          4
+#define FO_NOTIFY_TYPE_SPINUP		      5
+
+#define FO_NOTIFY_TYPE_MIN                FO_NOTIFY_TYPE_NONE
+#define FO_NOTIFY_TYPE_MAX                FO_NOTIFY_TYPE_LOGOUT_OR_CDB
+#define FO_NOTIFY_TYPE_DEF                FO_NOTIFY_TYPE_NONE
+
+#define FO_NOTIFY_CDB_LENGTH_MIN              6
+#define FO_NOTIFY_CDB_LENGTH_MAX             16
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlfoln.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlfoln.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlfoln.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlfoln.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.4.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+
+/*************************************************************
+ * Failover ioctl command codes range from 0xc0 to 0xdf.
+ * The foioctl command code end index must be updated whenever
+ * adding new commands. 
+ *************************************************************/
+#define FO_CC_START_IDX 	0xc8	/* foioctl cmd start index */
+
+#define FO_CC_GET_PARAMS_OS             \
+    QL_IOCTL_CMD(0xc8)
+#define FO_CC_SET_PARAMS_OS             \
+    QL_IOCTL_CMD(0xc9)
+#define FO_CC_GET_PATHS_OS              \
+    QL_IOCTL_CMD(0xca)
+#define FO_CC_SET_CURRENT_PATH_OS       \
+    QL_IOCTL_CMD(0xcb)
+#define FO_CC_GET_HBA_STAT_OS           \
+    QL_IOCTL_CMD(0xcc)
+#define FO_CC_RESET_HBA_STAT_OS         \
+    QL_IOCTL_CMD(0xcd)
+#define FO_CC_GET_LUN_DATA_OS           \
+    QL_IOCTL_CMD(0xce)
+#define FO_CC_SET_LUN_DATA_OS           \
+    QL_IOCTL_CMD(0xcf)
+#define FO_CC_GET_TARGET_DATA_OS        \
+    QL_IOCTL_CMD(0xd0)
+#define FO_CC_SET_TARGET_DATA_OS        \
+    QL_IOCTL_CMD(0xd1)
+#define FO_CC_GET_FO_DRIVER_VERSION_OS  \
+    QL_IOCTL_CMD(0xd2)
+
+#define FO_CC_END_IDX 	0xd2	/* foioctl cmd end index */
+
+
+#define BOOLEAN uint8_t
+#define MAX_LUNS_OS	256
+
+/* Driver attributes bits */
+#define DRVR_FO_ENABLED		0x1	/* bit 0 */
+
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlinioct.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlinioct.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlinioct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlinioct.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,433 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+#ifndef _QLINIOCT_H_
+#define _QLINIOCT_H_
+
+#include "qlisioln.h"
+
+/*
+   Ioctl
+*/
+
+/*
+  General
+*/
+
+/*
+ * Command Codes definitions
+ */
+#define INT_CC_GET_DATA			EXT_CC_RESERVED0A_OS
+#define INT_CC_SET_DATA			EXT_CC_RESERVED0B_OS
+#define INT_CC_DIAG_PING		EXT_CC_RESERVED0C_OS
+#define INT_CC_ISCSI_LOOPBACK		EXT_CC_RESERVED0D_OS
+#define INT_CC_HBA_RESET		EXT_CC_RESERVED0E_OS
+#define INT_CC_COPY_FW_FLASH		EXT_CC_RESERVED0F_OS
+#define INT_CC_LOGOUT_ISCSI		EXT_CC_RESERVED0G_OS
+#define INT_CC_FW_PASSTHRU		EXT_CC_RESERVED0H_OS
+#define INT_CC_IOCB_PASSTHRU		EXT_CC_RESERVED0I_OS
+
+/*
+ * Sub codes for Get Data.
+ * Use in combination with INT_GET_DATA as the ioctl code
+ */
+#define INT_SC_GET_FLASH			1
+
+/*
+ * Sub codes for Set Data.
+ * Use in combination with INT_SET_DATA as the ioctl code
+ */
+#define INT_SC_SET_FLASH			1
+
+#define INT_DEF_DNS_ENABLE                  0x0100
+
+/*
+ * ***********************************************************************
+ * INIT_FW_ISCSI_ALL
+ * ***********************************************************************
+ */
+typedef struct _INT_INIT_FW_ISCSI_ALL {
+	UINT8   Version;					/* 1   */
+	UINT8   Reserved0;					/* 1   */
+	UINT16  FWOptions;					/* 2   */
+	UINT16  exeThrottle;					/* 2   */
+	UINT8   retryCount;					/* 1   */
+	UINT8   retryDelay;					/* 1   */
+	UINT16  EthernetMTU;					/* 2   */
+	UINT16  addFWOptions;					/* 2   */
+	UINT8   HeartBeat;					/* 1   */
+	UINT8   Reserved1;					/* 1   */
+	UINT16  Reserved2;					/* 2   */
+	UINT16  ReqQOutPtr;					/* 2   */
+	UINT16  RespQInPtr;					/* 2   */
+	UINT16  ReqQLen;					/* 2   */
+	UINT16  RespQLen;					/* 2   */
+	UINT32  ReqQAddr[2];					/* 8   */
+	UINT32  RespQAddr[2];					/* 8   */
+	UINT32  IntRegBufAddr[2];				/* 8   */
+	UINT16  iSCSIOptions;					/* 2   */
+	UINT16  TCPOptions;					/* 2   */
+	UINT16  IPOptions;					/* 2   */
+	UINT16  MaxRxDataSegmentLen;				/* 2   */
+	UINT16  recvMarkerInt;					/* 2   */
+	UINT16  sendMarkerInt;					/* 2   */
+	UINT16  Reserved3;					/* 2   */
+	UINT16  firstBurstSize;					/* 2   */
+	UINT16  DefaultTime2Wait;				/* 2   */
+	UINT16  DefaultTime2Retain;				/* 2   */
+	UINT16  maxOutstandingR2T;				/* 2   */
+	UINT16  keepAliveTimeout;				/* 2   */
+	UINT16  portNumber;					/* 2   */
+	UINT16  maxBurstSize;					/* 2   */
+	UINT32  Reserved4;					/* 4   */
+	UINT8   IPAddr[16];					/* 16  */
+	UINT8   SubnetMask[16];					/* 16  */
+	UINT8   IPGateway[16];					/* 16  */
+	UINT8   DNSsvrIP[4];					/* 4  */
+	UINT8   DNSsecSvrIP[4];					/* 4  */
+	UINT8   Reserved5[8];					/* 8    */
+	UINT8   Alias[EXT_DEF_ISCSI_ALIAS_LEN];			/* 32  */
+	UINT32  targetAddr0;					/* 4   */
+	UINT32  targetAddr1;					/* 4   */
+	UINT32  CHAPTableAddr0;					/* 4   */
+	UINT32  CHAPTableAddr1;					/* 4   */
+	UINT8   EthernetMACAddr[6];				/* 6   */
+	UINT16  TargetPortalGrp;				/* 2   */
+	UINT8   SendScale;					/* 1   */
+	UINT8   RecvScale;					/* 1   */
+	UINT8   TypeOfService;					/* 1   */
+	UINT8   Time2Live;					/* 1   */
+	UINT16  VLANPriority;					/* 2   */
+	UINT16  Reserved6;					/* 2   */
+	UINT8   SecondaryIPAddr[16];				/* 16  */
+	UINT8   iSNSServerAdr[4];				/* 4    */
+	UINT16  iSNSServerPort;					/* 2    */
+	UINT8   Reserved7[10];					/* 10  */
+	UINT8   SLPDAAddr[16];					/* 16  */
+	UINT8   iSCSIName[EXT_DEF_ISCSI_NAME_LEN];		/* 256 */
+} INT_INIT_FW_ISCSI_ALL, *PINT_INIT_FW_ISCSI_ALL;		/* 512 */
+
+/*
+ * ***********************************************************************
+ * INT_DEVICE_ENTRY_ISCSI_ALL
+ * ***********************************************************************
+ */
+typedef struct _INT_DEVICE_ENTRY_ISCSI_ALL {
+	UINT8   Options;					/* 1 */
+	UINT8   Control;					/* 1 */
+	UINT16  exeThrottle;					/* 2 */
+	UINT16  exeCount;					/* 2 */
+	UINT8   retryCount;					/* 1 */
+	UINT8   retryDelay;					/* 1 */
+	UINT16  iSCSIOptions;					/* 2 */
+	UINT16  TCPOptions;					/* 2 */
+	UINT16  IPOptions;					/* 2 */
+	UINT16  MaxRxDataSegmentLen;				/* 2 */
+	UINT16  RecvMarkerInterval;				/* 2 */
+	UINT16  SendMarkerInterval;				/* 2 */
+	UINT16  MaxTxDataSegmentLen;				/* 2 */
+	UINT16  firstBurstSize;					/* 2 */
+	UINT16  DefaultTime2Wait;				/* 2 */
+	UINT16  DefaultTime2Retain;				/* 2 */
+	UINT16  maxOutstandingR2T;				/* 2 */
+	UINT16  keepAliveTimeout;				/* 2 */
+	UINT8   InitiatorSessID[EXT_DEF_ISCSI_ISID_SIZE];	/* 6 */
+	UINT16  TargetSessID;					/* 2 */
+	UINT16  portNumber;					/* 2 */
+	UINT16  maxBurstSize;					/* 2 */
+	UINT16  taskMngmntTimeout;				/* 2 */
+	UINT16  Reserved0;					/* 2 */
+	UINT8   IPAddress[16];					/* 16  */
+	UINT8   Alias[EXT_DEF_ISCSI_ALIAS_LEN];			/* 32  */
+	UINT8   targetAddr[EXT_DEF_ISCSI_TADDR_SIZE];		/* 32  */
+	/* need to find new definition XXX */
+	UINT8   res[64];
+	UINT8   iSCSIName[EXT_DEF_ISCSI_NAME_LEN];		/* 256 */
+	UINT16  ddbLink;					/* 2   */
+	UINT16  chapTableIndex;					/* 2   */
+	UINT16  targetPortalGrp;				/* 2   */
+	UINT16  Reserved1;					/* 2   */
+	UINT32  statSN;						/* 4 */
+	UINT32  expStatSN;					/* 4 */
+} INT_DEVICE_ENTRY_ISCSI_ALL, *PINT_DEVICE_ENTRY_ISCSI_ALL;	/* 464 */
+
+/*
+ * ****************************************************************************
+ * INT_DEVDDB_ENTRY
+ * ****************************************************************************
+ */
+
+typedef struct _FLASH_DEVDB_ENTRY {
+	INT_DEVICE_ENTRY_ISCSI_ALL      entryData;		/* 0-1C7   */
+	UINT8                           RES0[0x2C];		/* 1C8-1FB */
+	UINT16                          ddbValidCookie;		/* 1FC-1FD */
+	UINT16                          ddbValidSize;		/* 1FE-1FF */
+} FLASH_DEVDB_ENTRY, *PFLASH_DEVDB_ENTRY;
+
+/*
+ * ****************************************************************************
+ * INT_FLASH_INITFW
+ * ****************************************************************************
+ */
+
+typedef struct _FLASH_INITFW {
+	INT_INIT_FW_ISCSI_ALL   initFWData;
+	UINT32                  validCookie;
+} FLASH_INITFW, *PFLASH_INITFW;
+
+
+/*
+ * ***********************************************************************
+ * INT_ACCESS_FLASH
+ * ***********************************************************************
+ */
+
+#define INT_DEF_AREA_TYPE_FW_IMAGE1		0x01
+#define INT_DEF_AREA_TYPE_FW_IMAGE2		0x02
+#define INT_DEF_AREA_TYPE_DRIVER		0x03
+#define INT_DEF_AREA_TYPE_DDB			0x04
+#define INT_DEF_AREA_TYPE_INIT_FW		0x05
+#define INT_DEF_AREA_TYPE_SYS_INFO		0x06
+
+#define INT_DEF_FLASH_BLK_SIZE			0x4000
+#define INT_DEF_FLASH_PHYS_BLK_SIZE		0x20000
+
+#define INT_ISCSI_FW_IMAGE2_FLASH_OFFSET	0x01000000
+#define INT_ISCSI_SYSINFO_FLASH_OFFSET		0x02000000
+#define INT_ISCSI_DRIVER_FLASH_OFFSET		0x03000000
+#define INT_ISCSI_INITFW_FLASH_OFFSET		0x04000000
+#define INT_ISCSI_DDB_FLASH_OFFSET		0x05000000
+#define INT_ISCSI_CHAP_FLASH_OFFSET		0x06000000
+#define INT_ISCSI_FW_IMAGE1_FLASH_OFFSET	0x07000000
+#define INT_ISCSI_BIOS_FLASH_OFFSET		0x0d000000
+#define INT_ISCSI_OFFSET_MASK			0x00FFFFFF
+#define INT_ISCSI_PAGE_MASK			0x0F000000
+
+#define INT_ISCSI_ACCESS_FLASH			0x00000000
+#define INT_ISCSI_ACCESS_RAM			0x10000000
+#define INT_ISCSI_ACCESS_MASK			0xF0000000
+
+/* WRITE_FLASH option definitions */
+#define INT_WRITE_FLASH_OPT_HOLD		0 /* Write data to FLASH but
+						     do not Commit */
+#define INT_WRITE_FLASH_OPT_CLEAR_REMAINING	1 /* Write data to FLASH but
+						     do not Commit any data
+						     not written before
+						     commit will be cleared
+						     (set to 0xFF)	*/
+#define INT_WRITE_FLASH_OPT_COMMIT_DATA		2 /* Commit (Burn) data to
+						     FLASH */
+
+
+typedef struct _INT_ACCESS_FLASH {
+	UINT32  AreaType;					/* 4   */
+	UINT32  DataLen;					/* 4   */
+	UINT32  DataOffset;					/* 4   */
+	UINT8   FlashData[INT_DEF_FLASH_BLK_SIZE];		/* 0x4000 */
+	UINT32  Options;					/* 4   */
+} INT_ACCESS_FLASH, *PINT_ACCESS_FLASH;				/* 0x4010 */
+
+/*
+ * ****************************************************************************
+ * INT_FLASH_DRIVER_PARAM
+ * ****************************************************************************
+ */
+
+typedef struct _INT_FLASH_DRIVER_PARAM {
+	UINT16  DiscoveryTimeOut;				/* 2   */
+	UINT16  PortDownTimeout;				/* 2   */
+	UINT32  Reserved[32];					/* 128 */
+} INT_FLASH_DRIVER_PARAM, *PINT_FLASH_DRIVER_PARAM;		/* 132 */
+
+
+#define VALID_FLASH_INITFW		0x11BEAD5A
+
+#define FLASH_ISCSI_MAX_DDBS		64
+#define FLASH_DDB_VALID_COOKIE		0x9034 /* this value indicates this
+						  entry in flash is valid */
+#define FLASH_DDB_INVALID_COOKIE	0x0    /* this value is used to set
+						  the entry to invalid    */
+
+/*
+ * ****************************************************************************
+ * INT_HBA_SYS_INFO
+ * ****************************************************************************
+ */
+
+typedef struct _INT_HBA_SYS_INFO {
+	UINT32  cookie;						/* 4   */
+	UINT32  physAddrCount;					/* 4   */
+	UINT8   macAddr0[6];					/* 6   */
+	UINT8   reserved0[2];					/* 2   */
+	UINT8   macAddr1[6];					/* 6   */
+	UINT8   reserved1[2];					/* 2   */
+	UINT8   macAddr2[6];					/* 6   */
+	UINT8   reserved2[2];					/* 2   */
+	UINT8   macAddr3[6];					/* 6   */
+	UINT8   reserved3[2];					/* 2   */
+	UINT8   vendorId[128];					/* 128 */
+	UINT8   productId[128];					/* 128 */
+	UINT32  serialNumber;					/* 4   */
+	UINT32  pciDeviceVendor;				/* 4   */
+	UINT32  pciDeviceId;					/* 4   */
+	UINT32  pciSubsysVendor;				/* 4   */
+	UINT32  pciSubsysId;					/* 4   */
+	UINT32  crumbs;						/* 4   */
+	UINT32  enterpriseNumber;				/* 4   */
+	UINT32  crumbs2;					/* 4   */
+} INT_HBA_SYS_INFO, *PINT_HBA_SYS_INFO;				/* 328 */
+
+/*
+ * ****************************************************************************
+ * INT_FW_DW_HDR
+ * ****************************************************************************
+ */
+
+/* File header for FW */
+typedef struct _INT_FW_DL_HDR {
+	UINT32  Size;		/* download size, excluding DL_HDR & EXT_HDR*/
+	UINT32  Checksum;	/* Checksum of download file, excluding DL_HDR
+				   & EXT_HDR */
+	UINT32  HdrChecksum;	/* Checksum of header area should be zero */
+	UINT32  Flags;		/* See Flags bits defined above */
+	UINT32  Cookie;		/* Target specific identifier */
+	UINT32  Target;		/* Target specific identifier */
+	UINT32  Reserved0;	/* Reserved */
+	UINT32  Reserved1;	/* Reserved */
+	UINT8   Copyright[64];	/* Copyright */
+	UINT8   Version[32];	/* Version String */
+} INT_FW_DL_HDR, *PINT_FW_DL_HDR;
+
+/* File header for BIOS */
+typedef struct _INT_BIOS_HDR {
+	UINT8   BIOSidCode55;
+	UINT8   BIOSidCodeAA;
+	UINT8   reserved[52];
+	UINT8   BIOSminorVer;
+	UINT8   BIOSmajorVer;
+} INT_BIOS_HDR, *PINT_BIOS_HDR;
+
+typedef struct _INT_SDMBIOS_NVRAM {
+	UINT16  Flags;
+	UINT8   PriID;
+	UINT64  PriLUN;
+	UINT8   SecID;
+	UINT64  SecLUN;
+} INT_SDMBIOS_NVRAM, *PINT_SDMBIOS_NVRAM;
+
+/*
+ * ****************************************************************************
+ * INT_HBA_RESET
+ * ****************************************************************************
+ */
+
+typedef struct _INT_HBA_RESET {
+	UINT32  Reserved[2];					/* 8  */
+} INT_HBA_RESET, *PINT_HBA_RESET;				/* 8  */
+
+/*
+ * ****************************************************************************
+ * INT_COPY_FW_FLASH
+ * ****************************************************************************
+ */
+
+typedef struct _INT_COPY_FW_FLASH {
+	UINT32  Options;					/* 4  */
+} INT_COPY_FW_FLASH, *PINT_COPY_FW_FLASH;			/* 4  */
+
+#define INT_COPY_FLASH_PRIMARY_TO_SECONDARY	0
+#define INT_COPY_FLASH_SECONDARY_TO_PRIMARY	1
+
+/*
+ * ****************************************************************************
+ * INT_LOGOUT_ISCSI
+ * ****************************************************************************
+ */
+
+/* Logout Options */
+
+#define INT_DEF_CLOSE_SESSION			0x0001
+#define INT_DEF_RELOGIN_CONNECTION		0x0002
+#define INT_DEF_DELETE_DDB		      	0x0004
+#define INT_DEF_REINDEX_DDB		      	0x0008
+
+typedef struct _INT_LOGOUT_ISCSI {
+	UINT16    TargetID;					/* 2   */
+	UINT16    ConnectionID;					/* 2   */
+	UINT16    Options;					/* 2   */
+	UINT32    NewTargetID;					/* 4   */
+} INT_LOGOUT_ISCSI, *PINT_LOGOUT_ISCSI;				/* 10  */
+
+/*
+ * ****************************************************************************
+ * INT_PING
+ * ****************************************************************************
+ */
+
+typedef struct _INT_PING {
+	EXT_ISCSI_IP_ADDR       IPAddr;				/* 20  */
+	UINT16                  PacketCount;			/* 2   */
+	UINT16                  Reserved;			/* 2   */
+} INT_PING, *PINT_PING;						/* 24  */
+
+/*
+ * ****************************************************************************
+ * INT_IOCB_PASSTHRU
+ * ****************************************************************************
+ */
+
+#define INT_DEF_IOCB_BUF_SIZE			64
+#define INT_DEF_IOCB_DATA_SIZE			1500
+
+typedef struct _INT_IOCB_PASSTHRU {
+	UINT32    SendDMAOffset;				/* 4    */
+	UINT32    RspDMAOffset;					/* 4    */
+	UINT8     IOCBCmdBuffer[INT_DEF_IOCB_BUF_SIZE];		/* 64   */
+	UINT8     IOCBStatusBuffer[INT_DEF_IOCB_BUF_SIZE];	/* 64   */
+	UINT32    SendDataLen;					/* 4    */
+	UINT8     SendData[INT_DEF_IOCB_DATA_SIZE];		/* 1500 */
+	UINT32    RspDataLen;					/* 4    */
+	UINT8     RspData[INT_DEF_IOCB_DATA_SIZE];		/* 1500 */
+	UINT32    Reserved;					/* 4    */
+} INT_IOCB_PASSTHRU, *PINT_IOCB_PASSTHRU;			/* 3148 */
+
+
+/*
+ * ****************************************************************************
+ * INT_CC_FW_PASSTHRU
+ * ****************************************************************************
+ */
+
+/* FW PASSTHRU Defines */
+#define INT_DEF_FW_PASSHTRU_BLK_SIZE		0x4000
+
+#define INT_DEF_DATA_TYPE_CHAP_TABLE		0x0001
+#define INT_DEF_DATA_TYPE_DDB			0x0002
+#define INT_DEF_DATA_TYPE_INITFW		0x0003
+#define INT_DEF_DATA_TYPE_FW_IMAGE		0x0004
+
+#define INT_DEF_DATA_LOCATION_HBA_FLASH		0x0001
+#define INT_DEF_DATA_LOCATION_HBA_RAM		0x0002
+
+#define INT_DEF_DATA_READ			0x0001
+#define INT_DEF_DATA_WRITE			0x0002
+
+#define INT_DEF_DATA_INIT			0x0001
+#define INT_DEF_DATA_COMMIT			0x0002
+
+#endif /* _QLINIOCT_H_ */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlisioct.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlisioct.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlisioct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlisioct.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,732 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+/*
+ * File Name: qlisioct.h
+ *
+ */
+#ifndef _QLISIOCT_H
+#define _QLISIOCT_H
+
+/*
+ * NOTE: the following version defines must be updated each time the
+ *	 changes made may affect the backward compatibility of the
+ *	 input/output relations of the IOCTL functions.
+ */
+#define EXT_VERSION				6
+
+/*
+ * OS independent General definitions
+ */
+#define EXT_DEF_SIGNATURE_SIZE			8
+#define EXT_DEF_SERIAL_NUM_SIZE			4
+#define EXT_DEF_MAX_STR_SIZE			128
+
+#define EXT_DEF_ADDR_MODE_32			1
+#define EXT_DEF_ADDR_MODE_64			2
+
+/*
+ * ****************************************************************************
+ * OS type definitions
+ * ****************************************************************************
+ */
+#ifdef _MSC_VER					/* NT */
+
+#include "qlisiont.h"
+
+#elif defined(linux)				/* Linux */
+
+#include "qlisioln.h"
+
+#elif defined(sun) || defined(__sun)		/* Solaris */
+
+#include "qlisioso.h"
+
+#endif
+
+/*
+ * ****************************************************************************
+ * OS dependent General configuration defines
+ * ****************************************************************************
+ */
+#define EXT_DEF_MAX_HBA				EXT_DEF_MAX_HBA_OS
+#define EXT_DEF_MAX_BUS				EXT_DEF_MAX_BUS_OS
+#define EXT_DEF_MAX_TARGET			EXT_DEF_MAX_TARGET_OS
+#define EXT_DEF_MAX_LUN				EXT_DEF_MAX_LUN_OS
+
+/*
+ * Addressing mode used by the user application
+ */
+#define EXT_ADDR_MODE				EXT_ADDR_MODE_OS
+
+/*
+ * Command Codes definitions
+ */
+#define EXT_CC_QUERY			EXT_CC_QUERY_OS
+#define EXT_CC_REG_AEN			EXT_CC_REG_AEN_OS
+#define EXT_CC_GET_AEN			EXT_CC_GET_AEN_OS
+#define EXT_CC_GET_DATA			EXT_CC_GET_DATA_OS
+#define EXT_CC_SET_DATA			EXT_CC_SET_DATA_OS
+#define EXT_CC_SEND_SCSI_PASSTHRU	EXT_CC_SEND_SCSI_PASSTHRU_OS
+#define EXT_CC_SEND_ISCSI_PASSTHRU	EXT_CC_SEND_ISCSI_PASSTHRU_OS
+
+/*
+ * ****************************************************************************
+ * EXT_IOCTL_ISCSI
+ * ****************************************************************************
+ */
+/*
+ * Status.  These macros are being used for setting Status field in
+ * EXT_IOCTL_ISCSI structure.
+ */
+#define EXT_STATUS_OK				0
+#define EXT_STATUS_ERR				1
+#define EXT_STATUS_BUSY				2
+#define EXT_STATUS_PENDING			3
+#define EXT_STATUS_SUSPENDED			4
+#define EXT_STATUS_RETRY_PENDING		5
+#define EXT_STATUS_INVALID_PARAM		6
+#define EXT_STATUS_DATA_OVERRUN			7
+#define EXT_STATUS_DATA_UNDERRUN		8
+#define EXT_STATUS_DEV_NOT_FOUND		9
+#define EXT_STATUS_COPY_ERR			10
+#define EXT_STATUS_MAILBOX			11
+#define EXT_STATUS_UNSUPPORTED_SUBCODE		12
+#define EXT_STATUS_UNSUPPORTED_VERSION		13
+#define EXT_STATUS_MS_NO_RESPONSE		14
+#define EXT_STATUS_SCSI_STATUS			15
+#define EXT_STATUS_BUFFER_TOO_SMALL		16
+#define EXT_STATUS_NO_MEMORY			17
+#define EXT_STATUS_UNKNOWN			18
+#define EXT_STATUS_UNKNOWN_DSTATUS		19
+#define EXT_STATUS_INVALID_REQUEST		20
+#define EXT_STATUS_DEVICE_NOT_READY		21
+#define EXT_STATUS_DEVICE_OFFLINE		22
+#define EXT_STATUS_HBA_NOT_READY		23
+#define EXT_STATUS_HBA_QUEUE_FULL		24
+
+/*
+ * Detail Status contains the SCSI bus status codes.
+ */
+#define EXT_DSTATUS_GOOD			0x00
+#define EXT_DSTATUS_CHECK_CONDITION		0x02
+#define EXT_DSTATUS_CONDITION_MET		0x04
+#define EXT_DSTATUS_BUSY			0x08
+#define EXT_DSTATUS_INTERMEDIATE		0x10
+#define EXT_DSTATUS_INTERMEDIATE_COND_MET	0x14
+#define EXT_DSTATUS_RESERVATION_CONFLICT	0x18
+#define EXT_DSTATUS_COMMAND_TERMINATED		0x22
+#define EXT_DSTATUS_QUEUE_FULL			0x28
+
+/*
+ * Detail Status contains one of the following codes
+ * when Status = EXT_STATUS_INVALID_PARAM or
+ *	       = EXT_STATUS_DEV_NOT_FOUND
+ */
+#define EXT_DSTATUS_NOADNL_INFO			0x00
+#define EXT_DSTATUS_HBA_INST			0x01
+#define EXT_DSTATUS_TARGET			0x02
+#define EXT_DSTATUS_LUN				0x03
+#define EXT_DSTATUS_REQUEST_LEN			0x04
+#define EXT_DSTATUS_PATH_INDEX			0x05
+
+/*
+ * FLASH error status
+*/
+#define EXT_FLASH_NO_INFO			0x00
+#define EXT_FLASH_NO_MEMORY			0x0a
+#define EXT_FLASH_FW_IMAGE_INVALID		0x0b
+#define EXT_FLASH_NO_BKUP_FW_IMAGE		0x0c
+#define EXT_FLASH_ERROR_ACCESSING_FLASH		0x0d
+
+/*
+ * EXT_IOCTL_ISCSI SubCode definition.
+ * These macros are being used for setting SubCode field in EXT_IOCTL_ISCSI
+ * structure.
+ */
+
+/*
+ * Sub codes for Query.
+ * Uses in combination with EXT_QUERY as the ioctl code.
+ */
+#define EXT_SC_QUERY_HBA_ISCSI_NODE		1
+#define EXT_SC_QUERY_HBA_ISCSI_PORTAL		2
+#define EXT_SC_QUERY_DISC_ISCSI_NODE		3
+#define EXT_SC_QUERY_DISC_ISCSI_PORTAL		4
+#define EXT_SC_QUERY_DISC_LUN			5
+#define EXT_SC_QUERY_DRIVER			6
+#define EXT_SC_QUERY_FW				7
+#define EXT_SC_QUERY_CHIP			8
+
+/*
+ * Sub codes for Get Data.
+ * Use in combination with EXT_GET_DATA as the ioctl code
+ */
+#define EXT_SC_GET_STATISTICS_GEN		1
+#define EXT_SC_GET_STATISTICS_ISCSI		2
+#define EXT_SC_GET_DEVICE_ENTRY_ISCSI		3
+#define EXT_SC_GET_INIT_FW_ISCSI		4
+#define EXT_SC_GET_INIT_FW_DEFAULTS_ISCSI	5
+#define EXT_SC_GET_DEVICE_ENTRY_DEFAULTS_ISCSI	6
+#define EXT_SC_GET_ISNS_SERVER			7
+#define EXT_SC_GET_ISNS_DISCOVERED_TARGETS	8
+
+/*
+ * Sub codes for Set Data.
+ * Use in combination with EXT_SET_DATA as the ioctl code
+ */
+#define EXT_SC_RST_STATISTICS_GEN		1
+#define EXT_SC_RST_STATISTICS_ISCSI		2
+#define EXT_SC_SET_DEVICE_ENTRY_ISCSI		3
+#define EXT_SC_SET_INIT_FW_ISCSI		4
+#define EXT_SC_SET_ISNS_SERVER			5
+
+/*
+ * Defines for VendorSpecificStatus
+ */
+#define VENDOR_SPECIFIC_STATUS_MB_STATUS_INDEX		0 /* [0-4]  mbSts */
+#define VENDOR_SPECIFIC_STATUS_MB_COMMAND_INDEX		5 /* [5-10] mbCmd */
+#define VENDOR_SPECIFIC_STATUS_IOSB_COMPLETION_INDEX	0
+#define VENDOR_SPECIFIC_STATUS_SCSI_STATUS_INDEX	1
+
+
+typedef struct _EXT_IOCTL_ISCSI {
+	UINT8	Signature[EXT_DEF_SIGNATURE_SIZE];	/* 8   */
+	UINT16	AddrMode;				/* 2   */
+	UINT16	Version;				/* 2   */
+	UINT16	SubCode;				/* 2   */
+	UINT16	Instance;				/* 2   */
+	UINT32	Status;					/* 4   */
+	UINT32	DetailStatus;				/* 4   */
+	UINT32	Reserved1;				/* 4   */
+	UINT32	RequestLen;				/* 4   */
+	UINT32	ResponseLen;				/* 4   */
+	UINT64	RequestAdr;				/* 8   */
+	UINT64	ResponseAdr;				/* 8   */
+	UINT16	HbaSelect;				/* 2   */
+	UINT32	VendorSpecificStatus[11];		/* 44  */
+	UINT64	Signature2;				/* 8   */
+} EXT_IOCTL_ISCSI, *PEXT_IOCTL_ISCSI;			/* 106 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISCSI_DEVICE
+ * ****************************************************************************
+ */
+/* Device Type */
+#define EXT_DEF_ISCSI_REMOTE			0x02
+#define EXT_DEF_ISCSI_LOCAL			0x01
+
+#define EXT_ISCSI_ENABLE_DHCP			0x01
+
+#define EXT_DEF_ISCSI_TADDR_SIZE		32
+
+typedef struct _EXT_ISCSI_DEVICE {
+	UINT16	DeviceType;				/* 2   */
+	UINT16	ExeThrottle;				/* 2   */
+	UINT16	InitMarkerlessInt;			/* 2   */
+	UINT8	RetryCount;				/* 1   */
+	UINT8	RetryDelay;				/* 1   */
+	UINT16	iSCSIOptions;				/* 2   */
+	UINT16	TCPOptions;				/* 2   */
+	UINT16	IPOptions;				/* 2   */
+	UINT16	MaxPDUSize;				/* 2   */
+	UINT16	FirstBurstSize;				/* 2   */
+	UINT16	LogoutMinTime;				/* 2   */
+	UINT16	LogoutMaxTime;				/* 2   */
+	UINT16	MaxOutstandingR2T;			/* 2   */
+	UINT16	KeepAliveTimeout;			/* 2   */
+	UINT16	PortNumber;				/* 2   */
+	UINT16	MaxBurstSize;				/* 2   */
+	UINT16	TaskMgmtTimeout;			/* 2   */
+	UINT8	TargetAddr[EXT_DEF_ISCSI_TADDR_SIZE];	/* 32  */
+} EXT_ISCSI_DEVICE, *PEXT_ISCSI_DEVICE;		/* 64  */
+
+/*
+ * ****************************************************************************
+ * EXT_ISCSI_IP_ADDR
+ * ****************************************************************************
+ */
+#define EXT_DEF_IP_ADDR_SIZE			16
+#define EXT_DEF_TYPE_ISCSI_IP			0
+#define EXT_DEF_TYPE_ISCSI_IPV6			1
+
+typedef struct _EXT_ISCSI_IP_ADDR {
+	UINT8	IPAddress[EXT_DEF_IP_ADDR_SIZE];	/* 16  */
+	UINT16	Type;					/* 2   */
+	UINT16	Reserved;				/* 2   */
+} EXT_ISCSI_IP_ADDR, *PEXT_ISCSI_IP_ADDR;		/* 20  */
+
+/*
+ * ****************************************************************************
+ * EXT_NODE_INFO_ISCSI
+ * ****************************************************************************
+ */
+#define EXT_DEF_ISCSI_NAME_LEN			256
+#define EXT_DEF_ISCSI_ALIAS_LEN			32
+
+typedef struct _EXT_NODE_INFO_ISCSI {
+	EXT_ISCSI_IP_ADDR IPAddr;			/* 20  */
+	UINT8	iSCSIName[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */
+	UINT8	Alias[EXT_DEF_ISCSI_ALIAS_LEN];		/* 32  */
+	UINT16	PortalCount;				/* 2   */
+	UINT8	Reserved[10];				/* 10  */
+} EXT_NODE_INFO_ISCSI, *PEXT_NODE_INFO_ISCSI;		/* 320 */
+
+/*
+ * ****************************************************************************
+ * EXT_SCSI_ADDR_ISCSI
+ * ****************************************************************************
+ */
+typedef struct _EXT_SCSI_ADDR_ISCSI {
+	UINT16	Bus;					/* 2   */
+	UINT16	Target;					/* 2   */
+	UINT16	Lun;					/* 2   */
+	UINT16	Padding[5];				/* 10  */
+} EXT_SCSI_ADDR_ISCSI, *PEXT_SCSI_ADDR_ISCSI;		/* 16  */
+
+/*
+ * ****************************************************************************
+ * EXT_ASYNC_EVENT
+ * ****************************************************************************
+ */
+
+/* Asynchronous Event Codes */
+#define EXT_DEF_LINK_UP				0x8011
+#define EXT_DEF_LINK_DOWN			0x8012
+#define EXT_DEF_DEVICE_UPDATE			0x8014
+#define EXT_DEF_STATS_ALARM			0x8020
+
+/* Required # of entries in the queue buffer allocated. */
+#define EXT_DEF_MAX_AEN_QUEUE			EXT_DEF_MAX_AEN_QUEUE_OS
+#define EXT_DEF_MAX_AEN_PAYLOAD			7
+
+typedef struct _EXT_ASYNC_EVENT {
+	UINT32	AsyncEventCode;				/* 4   */
+	UINT32	Payload[EXT_DEF_MAX_AEN_PAYLOAD];	/* 28  */
+} EXT_ASYNC_EVENT, *PEXT_ASYNC_EVENT;			/* 32  */
+
+/*
+ * ****************************************************************************
+ * EXT_CHIP_INFO
+ * ****************************************************************************
+ */
+typedef struct _EXT_CHIP_INFO {
+	UINT16	VendorId;				/* 2   */
+	UINT16	DeviceId;				/* 2   */
+	UINT16	SubVendorId;				/* 2   */
+	UINT16	SubSystemId;				/* 2   */
+	UINT16	BoardID;				/* 2   */
+	UINT16	Reserved[35];				/* 70  */
+} EXT_CHIP_INFO, *PEXT_CHIP_INFO;			/* 80  */
+
+/*
+ * ****************************************************************************
+ * EXT_DEVICE_ENTRY_ISCSI
+ * ****************************************************************************
+ */
+/* Options */
+#define EXT_DEF_ISCSI_GRANT_ACCESS		0x04
+#define EXT_DEF_ISCSI_TARGET_DEVICE		0x02
+#define EXT_DEF_ISCSI_INITIATOR_DEVICE		0x01
+
+/* Control */
+#define EXT_DEF_SESS_RECVRY_IN_PROCESS		0x10
+#define EXT_DEF_ISCSI_TRANSMITTING		0x08
+#define EXT_DEF_ISCSI_TX_LINKED			0x04
+#define EXT_DEF_ISCSI_QUEUE_ABORTED		0x02
+#define EXT_DEF_ISCSI_TX_LOGGED_IN		0x01
+
+/* DeviceState */
+#define EXT_DEF_DEV_STATE_UNASSIGNED		0x00
+#define EXT_DEF_DEV_STATE_NO_CONNECTION_ACTIVE	0x01
+#define EXT_DEF_DEV_STATE_DISCOVERY		0x02
+#define EXT_DEF_DEV_STATE_NO_SESSION_ACTIVE	0x03
+#define EXT_DEF_DEV_STATE_SESSION_ACTIVE	0x04
+#define EXT_DEF_DEV_STATE_LOGGING_OUT		0x05
+#define EXT_DEF_DEV_STATE_SESSION_FAILED	0x06
+#define EXT_DEF_DEV_STATE_OPENING		0x07
+
+#define EXT_DEF_ISCSI_ISID_SIZE			6
+#define EXT_DEF_ISCSI_USER_ID_SIZE		32
+#define EXT_DEF_ISCSI_PASSWORD_SIZE		32
+
+typedef struct _EXT_DEVICE_ENTRY_ISCSI {
+	UINT8	Options;				/* 1   */
+	UINT8	Control;				/* 1   */
+	UINT8	InitiatorSessID[EXT_DEF_ISCSI_ISID_SIZE];	/* 6   */
+	UINT16	TargetSessID;				/* 2   */
+	UINT32	ReservedFlags;				/* 4   */
+	UINT8	UserID[EXT_DEF_ISCSI_USER_ID_SIZE];	/* 32  */
+	UINT8	Password[EXT_DEF_ISCSI_PASSWORD_SIZE];	/* 32  */
+	EXT_ISCSI_DEVICE	DeviceInfo;		/* 64  */
+	EXT_NODE_INFO_ISCSI	EntryInfo;		/* 320 */
+	UINT16	ExeCount;				/* 2   */
+	UINT32	NumValid;				/* 4   */
+	UINT32	NextValid;				/* 4   */
+	UINT32	DeviceState;				/* 4   */
+	UINT16	DDBLink;				/* 2   */
+	UINT16	Reserved[17];				/* 34  */
+} EXT_DEVICE_ENTRY_ISCSI, *PEXT_DEVICE_ENTRY_ISCSI;	/* 512 */
+
+/*
+ * ****************************************************************************
+ * EXT_DEST_ADDR_ISCSI
+ * ****************************************************************************
+ */
+typedef struct _EXT_DEST_ADDR_ISCSI {
+	UINT8	iSCSINameStr[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */
+	UINT16	SessionID;				/* 2   */
+	UINT16	ConnectionID;				/* 2   */
+	UINT16	PortNumber;				/* 2   */
+	UINT16	Reserved[3];				/* 6   */
+} EXT_DEST_ADDR_ISCSI, *PEXT_DEST_ADDR_ISCSI;		/* 268 */
+
+/*
+ * ****************************************************************************
+ * EXT_DISC_ISCSI_PORTAL
+ * ****************************************************************************
+ */
+typedef struct _EXT_DISC_ISCSI_PORTAL {
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20  */
+	UINT16	NodeCount;				/* 2   */
+	UINT8	HostName[EXT_DEF_MAX_STR_SIZE];		/* 128 */
+	UINT16	PortNumber;				/* 2   */
+	UINT16	Reserved;				/* 2   */
+} EXT_DISC_ISCSI_PORTAL, *PEXT_DISC_ISCSI_PORTAL;	/* 154 */
+
+/*
+ * ****************************************************************************
+ * EXT_DISC_ISCSI_NODE
+ * ****************************************************************************
+ */
+typedef struct _EXT_DISC_ISCSI_NODE {
+	UINT16	SessionID;				/* 2   */
+	UINT16	ConnectionID;				/* 2   */
+	UINT16	PortalGroupID;				/* 2   */
+	EXT_NODE_INFO_ISCSI	NodeInfo;		/* 320 */
+	EXT_SCSI_ADDR_ISCSI	ScsiAddr;		/* 16  */
+	UINT16	Reserved;				/* 2   */
+} EXT_DISC_ISCSI_NODE, *PEXT_DISC_ISCSI_NODE;		/* 344 */
+
+/*
+ * ****************************************************************************
+ * EXT_DNS
+ * ****************************************************************************
+ */
+typedef struct _EXT_DNS {
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20  */
+	UINT8	Reserved[132];				/* 132 */
+} EXT_DNS, *PEXT_DNS;					/* 152 */
+
+/*
+ * ****************************************************************************
+ * EXT_DRIVER_INFO
+ * ****************************************************************************
+ */
+typedef struct _EXT_DRIVER_INFO {
+	UINT8	Version[EXT_DEF_MAX_STR_SIZE];		/* 128 */
+	UINT16	NumOfBus;				/* 2   */
+	UINT16	TargetsPerBus;				/* 2   */
+	UINT16	LunPerTarget;				/* 2   */
+	UINT16	LunPerTargetOS;				/* 2   */
+	UINT32	MaxTransferLen;				/* 4   */
+	UINT32	MaxDataSegments;			/* 4   */
+	UINT16	DmaBitAddresses;			/* 2   */
+	UINT16	IoMapType;				/* 2   */
+	UINT32	Attrib;					/* 4   */
+	UINT32	InternalFlags[4];			/* 16  */
+	UINT32	Reserved[8];				/* 32  */
+} EXT_DRIVER_INFO, *PEXT_DRIVER_INFO;			/* 200 */
+
+/*
+ * ****************************************************************************
+ * EXT_FW_INFO
+ * ****************************************************************************
+ */
+typedef struct _EXT_FW_INFO {
+	UINT8	Version[EXT_DEF_MAX_STR_SIZE];		/* 128 */
+	UINT32	Attrib;					/* 4   */
+	UINT32	Reserved[8];				/* 32  */
+} EXT_FW_INFO, *PEXT_FW_INFO;				/* 164 */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_ISCSI_NODE
+ * ****************************************************************************
+ */
+typedef struct _EXT_HBA_ISCSI_NODE {
+	UINT8	DeviceName[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT16	PortNumber;				/* 2   */
+	EXT_NODE_INFO_ISCSI	NodeInfo;		/* 320 */
+	UINT16	Reserved;				/* 2   */
+} EXT_HBA_ISCSI_NODE, *PEXT_HBA_ISCSI_NODE;		/* 452 */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_ISCSI_PORTAL
+ * ****************************************************************************
+ */
+#define EXT_DEF_MAC_ADDR_SIZE			6
+
+/* State */
+#define EXT_DEF_CARD_STATE_READY		1
+#define EXT_DEF_CARD_STATE_CONFIG_WAIT		2
+#define EXT_DEF_CARD_STATE_LOGIN		3
+#define EXT_DEF_CARD_STATE_ERROR		4
+
+/* Type */
+#define EXT_DEF_TYPE_COPPER			1
+#define EXT_DEF_TYPE_OPTICAL			2
+
+#define EXT_DEF_SERIAL_NUM_SIZE			4
+
+typedef struct _EXT_HBA_ISCSI_PORTAL {
+	EXT_ISCSI_IP_ADDR IPAddr;			/* 20  */
+	UINT8	MacAddr[EXT_DEF_MAC_ADDR_SIZE];		/* 6   */
+	UINT8	Padding[2];				/* 2   */
+	UINT32	SerialNum;				/* 4   */
+	UINT8	Manufacturer[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT8	Model[EXT_DEF_MAX_STR_SIZE];		/* 128 */
+	UINT8	DriverVersion[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT8	FWVersion[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT8	OptRomVersion[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT16	State;					/* 2   */
+	UINT16	Type;					/* 2   */
+	UINT32	DriverAttr;				/* 4   */
+	UINT32	FWAttr;					/* 4   */
+	UINT16	DiscTargetCount;			/* 2   */
+	UINT32	Reserved;				/* 4   */
+} EXT_HBA_ISCSI_PORTAL, *PEXT_HBA_ISCSI_PORTAL;	/* 686 */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_PORT_STAT_GEN
+ * ****************************************************************************
+ */
+typedef struct _EXT_HBA_PORT_STAT_GEN {
+	UINT64	HBAPortErrorCount;			/* 8   */
+	UINT64	DevicePortErrorCount;			/* 8   */
+	UINT64	IoCount;				/* 8   */
+	UINT64	MBytesCount;				/* 8   */
+	UINT64	InterruptCount;				/* 8   */
+	UINT64	LinkFailureCount;			/* 8   */
+	UINT64	InvalidCrcCount;			/* 8   */
+	UINT32	Reserved[2];				/* 8   */
+} EXT_HBA_PORT_STAT_GEN, *PEXT_HBA_PORT_STAT_GEN;	/* 64  */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_PORT_STAT_ISCSI
+ * ****************************************************************************
+ */
+typedef struct _EXT_HBA_PORT_STAT_ISCSI {
+	UINT64	MACTxFramesCount;			/* 8   */
+	UINT64	MACTxBytesCount;			/* 8   */
+	UINT64	MACRxFramesCount;			/* 8   */
+	UINT64	MACRxBytesCount;			/* 8   */
+	UINT64	MACCRCErrorCount;			/* 8   */
+	UINT64	MACEncodingErrorCount;			/* 8   */
+	UINT64	IPTxPacketsCount;			/* 8   */
+	UINT64	IPTxBytesCount;				/* 8   */
+	UINT64	IPTxFragmentsCount;			/* 8   */
+	UINT64	IPRxPacketsCount;			/* 8   */
+	UINT64	IPRxBytesCount;				/* 8   */
+	UINT64	IPRxFragmentsCount;			/* 8   */
+	UINT64	IPDatagramReassemblyCount;		/* 8   */
+	UINT64	IPv6RxPacketsCount;			/* 8   */
+	UINT64	IPRxPacketErrorCount;			/* 8   */
+	UINT64	IPReassemblyErrorCount;			/* 8   */
+	UINT64	TCPTxSegmentsCount;			/* 8   */
+	UINT64	TCPTxBytesCount;			/* 8   */
+	UINT64	TCPRxSegmentsCount;			/* 8   */
+	UINT64	TCPRxBytesCount;			/* 8   */
+	UINT64	TCPTimerExpiredCount;			/* 8   */
+	UINT64	TCPRxACKCount;				/* 8   */
+	UINT64	TCPTxACKCount;				/* 8   */
+	UINT64	TCPRxErrorSegmentCount;			/* 8   */
+	UINT64	TCPWindowProbeUpdateCount;		/* 8   */
+	UINT64	iSCSITxPDUCount;			/* 8   */
+	UINT64	iSCSITxBytesCount;			/* 8   */
+	UINT64	iSCSIRxPDUCount;			/* 8   */
+	UINT64	iSCSIRxBytesCount;			/* 8   */
+	UINT64	iSCSICompleteIOsCount;			/* 8   */
+	UINT64	iSCSIUnexpectedIORxCount;		/* 8   */
+	UINT64	iSCSIFormatErrorCount;			/* 8   */
+	UINT64	iSCSIHeaderDigestCount;			/* 8   */
+	UINT64	iSCSIDataDigestErrorCount;		/* 8   */
+	UINT64	iSCSISeqErrorCount;			/* 8   */
+	UINT32	Reserved[2];				/* 8   */
+} EXT_HBA_PORT_STAT_ISCSI, *PEXT_HBA_PORT_STAT_ISCSI;	/* 272 */
+
+/*
+ * ****************************************************************************
+ * EXT_INIT_FW_ISCSI
+ * ****************************************************************************
+ */
+#define EXT_DEF_FW_MARKER_DISABLE		0x0400
+#define EXT_DEF_FW_ACCESS_CONTROL_ENABLE	0x0080
+#define EXT_DEF_FW_SESSION_MODE_ENABLE		0x0040
+#define EXT_DEF_FW_INITIATOR_MODE_ENABLE	0x0020
+#define EXT_DEF_FW_TARGET_MODE_ENABLE		0x0010
+#define EXT_DEF_FW_FAST_STATUS_ENABLE		0x0008
+#define EXT_DEF_FW_DMA_INT_ENABLE		0x0004
+#define EXT_DEF_FW_SENSE_BUFF_DESC_ENABLE	0x0002
+
+typedef struct _EXT_INIT_FW_ISCSI {
+	UINT8	Reserved1;				/* 1   */
+	UINT8	Version;				/* 1   */
+	UINT16	FWOptions;				/* 2   */
+	UINT16	AddFWOptions;				/* 2   */
+	UINT16	WakeupThreshold;			/* 2   */
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20  */
+	EXT_ISCSI_IP_ADDR	SubnetMask;		/* 20  */
+	EXT_ISCSI_IP_ADDR	Gateway;		/* 20  */
+	EXT_DNS	DNSConfig;				/* 152 */
+	UINT8	Alias[EXT_DEF_ISCSI_ALIAS_LEN];		/* 32  */
+	UINT8	iSCSIName[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */
+	EXT_ISCSI_DEVICE	DeviceInfo;		/* 64  */
+	UINT8	Reserved[4];				/* 4   */
+} EXT_INIT_FW_ISCSI , *PEXT_INIT_FW_ISCSI;		/* 576 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISCSI_PASSTHRU
+ * ****************************************************************************
+ */
+#define EXT_DEF_ISCSI_PASSTHRU_PDU_LENGTH	64
+
+#define EXT_DEF_ISCSI_PASSTHRU_DATA_IN		1
+#define EXT_DEF_ISCSI_PASSTHRU_DATA_OUT	2
+
+typedef struct _EXT_ISCSI_PASSTHRU {
+	EXT_DEST_ADDR_ISCSI Addr;			/* 268 */
+	UINT16	Direction;				/* 2   */
+	UINT32	PduInLength;				/* 4   */
+	UINT8	PduIn[EXT_DEF_ISCSI_PASSTHRU_PDU_LENGTH];	/* 64  */
+	UINT32	PduOutLength;				/* 4   */
+	UINT8	PduOut[EXT_DEF_ISCSI_PASSTHRU_PDU_LENGTH];	/* 64  */
+	UINT32	Flags;					/* 4   */
+	UINT32	Reserved;				/* 4   */
+} EXT_ISCSI_PASSTHRU, *PEXT_ISCSI_PASSTHRU;		/* 282 */
+
+/*
+ * ****************************************************************************
+ * EXT_REG_AEN_ISCSI
+ * ****************************************************************************
+ */
+#define EXT_DEF_ENABLE_STATS_AEN		0x00000002
+#define EXT_DEF_ENABLE_DDB_CHANGED_AEN		0x00000001
+
+typedef struct _EXT_REG_AEN_ISCSI {
+	UINT32	Enable;					/* 4   */
+	UINT32	Reserved[3];				/* 12  */
+} EXT_REG_AEN_ISCSI, *PEXT_REG_AEN_ISCSI;		/* 16  */
+
+/*
+ * ****************************************************************************
+ * EXT_SCSI_PASSTHRU_ISCSI
+ * ****************************************************************************
+ */
+#define EXT_DEF_SCSI_PASSTHRU_CDB_LENGTH	16
+
+#define EXT_DEF_SCSI_PASSTHRU_DATA_IN		1
+#define EXT_DEF_SCSI_PASSTHRU_DATA_OUT		2
+
+#define EXT_DEF_SCSI_SENSE_DATA_SIZE		256
+
+typedef struct _EXT_SCSI_PASSTHRU_ISCSI {
+	EXT_SCSI_ADDR_ISCSI Addr;			/* 16  */
+	UINT8	Direction;				/* 1   */
+	UINT8	CdbLength;				/* 1   */
+	UINT8	Cdb[EXT_DEF_SCSI_PASSTHRU_CDB_LENGTH];	/* 16  */
+	UINT8	Reserved[16];				/* 16  */
+	UINT8	SenseData[EXT_DEF_SCSI_SENSE_DATA_SIZE];/* 256 */
+} EXT_SCSI_PASSTHRU_ISCSI, *PEXT_SCSI_PASSTHRU_ISCSI;	/* 306 */
+
+
+/*
+ * ****************************************************************************
+ * EXT_ISNS_SERVER
+ * ****************************************************************************
+ */
+
+#define EXT_DEF_ISNS_WELL_KNOWN_PORT		3205
+
+typedef struct _EXT_ISNS_SERVER {
+	UINT8	PerformiSNSDiscovery;			/* 1 */
+	UINT8	AutomaticiSNSDiscovery;			/* 1 */	
+	UINT8	Reserved1[2];				/* 2 */
+	EXT_ISCSI_IP_ADDR	IPAddr;		/* 20 */
+	UINT16	PortNumber;				/* 2 */
+	UINT16	Reserved2;				/* 2 */
+	UINT8	InitiatorName[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */		
+	UINT32	Reserved3;				/* 4   */
+} EXT_ISNS_SERVER, *PEXT_ISNS_SERVER;			/* 288 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISNS_DISCOVERED_TARGET_PORTAL
+ * ****************************************************************************
+ */
+
+typedef struct _EXT_ISNS_DISCOVERED_TARGET_PORTAL
+{
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20 */
+	UINT16	PortNumber;				/* 2 */
+	UINT16	Reserved;				/* 2 */
+} EXT_ISNS_DISCOVERED_TARGET_PORTAL, *PEXT_ISNS_DISCOVERED_TARGET_PORTAL;
+							/* 24 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISNS_DISCOVERED_TARGET
+ * ****************************************************************************
+ */
+
+#define EXT_DEF_ISNS_MAX_PORTALS		4
+
+typedef struct _EXT_ISNS_DISCOVERED_TARGET
+{
+	UINT32	NumPortals;				/* 4 */
+	EXT_ISNS_DISCOVERED_TARGET_PORTAL Portal[EXT_DEF_ISNS_MAX_PORTALS];	/* 96 */
+	UINT32	DDID;					/* 4 */
+	UINT8	NameString[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */
+	UINT8	Alias[EXT_DEF_ISCSI_ALIAS_LEN];		/* 32 */
+} EXT_ISNS_DISCOVERED_TARGET, *PEXT_ISNS_DISCOVERED_TARGET;	/* 392 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISNS_DISCOVERED_TARGETS
+ * ****************************************************************************
+ */
+
+#define EXT_DEF_NUM_ISNS_DISCOVERED_TARGETS	32
+
+typedef struct _EXT_ISNS_DISCOVERED_TARGETS
+{
+	UINT32  iSNSDiscoveredTargetIndexStart;		/* 4 */
+	UINT32	NumiSNSDiscoveredTargets;		/* 4 */
+	EXT_ISNS_DISCOVERED_TARGET
+		iSNSDiscoveredTargets[EXT_DEF_NUM_ISNS_DISCOVERED_TARGETS];
+							/* 12544 */	
+} EXT_ISNS_DISCOVERED_TARGETS, *PEXT_ISNS_DISCOVERED_TARGETS;
+							/* 12548 */
+
+
+#endif /* _QLISIOCT_H */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlisioln.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlisioln.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlisioln.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlisioln.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,233 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+#ifndef _QLISIOLN_H_
+#define _QLISIOLN_H_
+
+#include <linux/ioctl.h>
+
+#ifdef APILIB
+#include <stdint.h>
+#include <linux/types.h>
+#endif
+
+#ifndef INT8
+#define	INT8	int8_t
+#endif
+#ifndef INT16
+#define	INT16	int16_t
+#endif
+#ifndef INT32
+#define	INT32	int32_t
+#endif
+#ifndef UINT8
+#define	UINT8	uint8_t
+#endif
+#ifndef UINT16
+#define	UINT16	uint16_t
+#endif
+#ifndef UINT32
+#define	UINT32	uint32_t
+#endif
+
+#ifndef UINT64
+#define UINT64  unsigned long long
+#endif
+
+#ifndef BOOLEAN
+#define BOOLEAN uint8_t
+#endif
+
+
+#if BITS_PER_LONG <= 32
+#define EXT_ADDR_MODE_OS  EXT_DEF_ADDR_MODE_32
+#else
+#define EXT_ADDR_MODE_OS  EXT_DEF_ADDR_MODE_64
+#endif
+
+
+#define QLMULTIPATH_MAGIC 'z'
+
+#define _QLBUILD   /* for qlisioct.h to enable include of qinsdmgt.h */
+
+
+
+/* max index values */
+#define	EXT_DEF_MAX_HBA_OS		63	/* 0 - 0x3F */
+#define EXT_DEF_MAX_HBAS		64
+
+#define	EXT_DEF_MAX_BUS_OS		1
+
+#define	EXT_DEF_MAX_TARGET_OS		255	/* 0 - 0xFF */
+#define EXT_DEF_MAX_TARGETS		256
+
+#define	EXT_DEF_MAX_LUN_OS		255	/* 0 - 0xFF */
+#define EXT_DEF_MAX_LUNS		256
+
+#define EXT_DEF_MAX_AEN_QUEUE_OS        64
+
+#define EXT_DEF_USE_HBASELECT		0x02	/* bit 1: HbaSelect field is
+						 * used to specify destination
+						 * HBA of each command.
+						 * SetInstance cmd is now
+						 * issued only once during
+						 * API initialization.
+						 */
+
+
+#define EXT_DEF_REGULAR_SIGNATURE	"QLOGIC"
+
+
+/*************************************************************/
+/*                       Command codes                       */
+/*-----------------------------------------------------------*/
+/* Correctly defined to work on both 32bit and 64bit kernels */
+/*************************************************************/
+#define	QL_IOCTL_BASE(idx)	\
+    _IOWR(QLMULTIPATH_MAGIC, idx, EXT_IOCTL_ISCSI)
+
+#define	QL_IOCTL_CMD(idx)	QL_IOCTL_BASE(idx)
+
+
+/***********************************
+ * These are regular command codes 
+ * idx range from 0x00 to 0x2f
+ ***********************************/
+#define EXT_DEF_REG_CC_START_IDX	0x00
+
+#define EXT_CC_QUERY_OS				/* QUERY */	\
+    QL_IOCTL_CMD(0x00)
+	
+#define EXT_CC_REG_AEN_OS			/* REG_AEN */ \
+    QL_IOCTL_CMD(0x01)
+
+#define EXT_CC_GET_AEN_OS			/* GET_AEN */ \
+    QL_IOCTL_CMD(0x02)
+
+#define EXT_CC_GET_DATA_OS			/* GET_DATA */ \
+    QL_IOCTL_CMD(0x03)
+
+#define EXT_CC_SET_DATA_OS			/* SET_DATA */ \
+    QL_IOCTL_CMD(0x04)
+	
+#define EXT_CC_SEND_SCSI_PASSTHRU_OS		/* SCSI_PASSTHRU */ \
+    QL_IOCTL_CMD(0x05)
+
+#define EXT_CC_SEND_ISCSI_PASSTHRU_OS		/* ISCSI_PASSTHRU */ \
+    QL_IOCTL_CMD(0x06)
+
+#define EXT_DEF_REG_CC_END_IDX		0x06
+
+/***********************************
+ * Internal command codes 
+ * idx range from 0x10 to 0x2f
+ ***********************************/
+#define EXT_DEF_INT_CC_START_IDX	0x10
+
+#define EXT_CC_RESERVED0A_OS					\
+    QL_IOCTL_CMD(0x10)
+#define EXT_CC_RESERVED0B_OS					\
+    QL_IOCTL_CMD(0x11)
+#define EXT_CC_RESERVED0C_OS					\
+    QL_IOCTL_CMD(0x12)
+#define EXT_CC_RESERVED0D_OS					\
+    QL_IOCTL_CMD(0x13)
+#define EXT_CC_RESERVED0E_OS					\
+    QL_IOCTL_CMD(0x14)
+#define EXT_CC_RESERVED0F_OS					\
+    QL_IOCTL_CMD(0x15)
+#define EXT_CC_RESERVED0G_OS					\
+    QL_IOCTL_CMD(0x16)
+#define EXT_CC_RESERVED0H_OS					\
+    QL_IOCTL_CMD(0x17)
+#define EXT_CC_RESERVED0I_OS					\
+    QL_IOCTL_CMD(0x18)
+
+#define EXT_DEF_INT_CC_END_IDX		0x18
+
+/***********************************
+ * NextGen Failover ioctl command
+ * codes range from 0x37 to 0x4f.
+ * See qlnfoln.h
+ ***********************************/
+
+/***********************************
+ * These are a Linux driver specific
+ * commands.
+ * idx range from highest value 0xff
+ * and in decreasing order.
+ ***********************************/
+#define EXT_DEF_DRV_SPC_CC_START_IDX	0xff
+
+#define EXT_CC_GET_HBACNT			/* GET_HBACNT */ \
+    QL_IOCTL_CMD(0xff)
+
+#define EXT_CC_GET_HOST_NO			/* SET_INSTANCE */ \
+    QL_IOCTL_CMD(0xfe)
+
+#define EXT_CC_DRIVER_SPECIFIC			/* DRIVER_SPECIFIC */ \
+    QL_IOCTL_CMD(0xfc)
+
+
+#define EXT_DEF_DRV_SPC_CC_END_IDX	0xfc
+
+/******************************/
+/* Response struct definition */
+/******************************/
+
+/*
+ * HBA Count
+ */
+typedef struct _EXT_HBA_COUNT {
+	UINT16	HbaCnt;				/* 2 */
+} EXT_HBA_COUNT, *PEXT_HBA_COUNT;		/* 2 */
+
+/*
+ * Driver Specific
+ */
+typedef struct _EXT_LN_DRV_VERSION {
+	UINT8   Major;
+	UINT8   Minor;
+	UINT8   Patch;
+	UINT8   Beta;
+	UINT8   Reserved[4];
+} EXT_LN_DRV_VERSION;				/* 8 */
+
+typedef struct _EXT_LN_DRIVER_DATA {
+	EXT_LN_DRV_VERSION	DrvVer;		/* 8 */
+	UINT32	Flags;				/* 4 */
+	UINT32	AdapterModel;			/* 4 */
+	UINT32	Reserved[12];			/* 48 */
+} EXT_LN_DRIVER_DATA, *PEXT_LN_DRIVER_DATA;	/* 64 */
+
+/* Bit defines for the Flags field */
+#define EXT_DEF_NGFO_CAPABLE		0x0001	/* bit 0 */
+
+/* Bit defines for the AdapterModel field */
+/* bit 0 to bit 7 are used by FC driver. when adding new bit
+ * definitions they must be unique among all supported drivers
+ */
+#define EXT_DEF_QLA4010_DRIVER		0x0100	/* bit 8 */
+#define EXT_DEF_QLA4022_DRIVER		0x0200	/* bit 9 */
+
+#define EXT_DEF_QLA4XXX_DRIVER				\
+    (EXT_DEF_QLA4010_DRIVER | EXT_DEF_QLA4022_DRIVER)
+
+
+
+#endif //_QLISIOLN_H_
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlnfo.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlnfo.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlnfo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlnfo.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,605 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+/*
+ * File Name: qlnfo.h
+ *
+ * Revision History:
+ *
+ */
+
+#ifndef	_QLNFO_H
+#define	_QLNFO_H
+
+#include "qlud.h"
+
+/*
+ * NOTE: the following version defines must be updated each time the
+ *	 changes made may affect the backward compatibility of the
+ *	 input/output relations
+ */
+#define	NFO_VERSION             1
+#define	NFO_VERSION_STR         "1.0"
+
+/*
+ * ***********************************************************************
+ * Data type definitions
+ * ***********************************************************************
+ */
+#ifdef _MSC_VER
+
+#include "ntddscsi.h"
+#include "qlnfowin.h"
+
+/*
+ * ***********************************************************************
+ * OS dependent General configuration defines
+ * ***********************************************************************
+ */
+
+#elif defined(linux)                 /* Linux */
+
+#elif defined(sun) || defined(__sun) /* Solaris */
+
+#endif
+
+/*
+ * ***********************************************************************
+ * Generic definitions
+ * ***********************************************************************
+ */
+#define	NFO_DEF_SIGNATURE_SIZE		8
+#define	NFO_DEF_SIGNATURE		"QLGCNFO"
+
+/* Constants */
+#define NFO_DEF_UNSUPPORTED		0xFFFFFFFF
+#define NFO_DEF_STR_NAME_SIZE_32	32
+#define NFO_DEF_STR_NAME_SIZE_64	64
+#define NFO_DEF_STR_NAME_SIZE_128	128
+#define NFO_DEF_STR_NAME_SIZE_256	256
+#define NFO_DEF_STR_NAME_SIZE_512	512
+#define NFO_DEF_INQ_VENDOR_ID_SIZE	8
+#define NFO_DEF_INQ_PROD_ID_SIZE	16
+#define NFO_DEF_INQ_PROD_VER_SIZE	4
+#define NFO_DEF_INQ_LUID_SIZE		16
+#define NFO_DEF_INQ_SERIAL_NO_SIZE	16
+#define NFO_DEF_PATH_ALL		NFO_DEF_UNSUPPORTED /* All paths */
+
+/* Device transport protocol */
+#define NFO_TRANSPORT_FC		1
+#define NFO_TRANSPORT_ISCSI		2
+#define NFO_TRANSPORT_NO_SUP		NFO_TRANSPORT_ISCSI	/* No supported */
+#define NFO_TRANSPORT_UNKNOWN		NFO_DEF_UNSUPPORTED
+
+/* Unique identification */
+#define NFO_FC_WWN_SIZE			8
+#define NFO_FC_PID_SIZE			4
+#define NFO_IS_NAME_SIZE		256
+#define NFO_IS_IP_ADDR_SIZE		16
+#define NFO_IS_IP_ADDR_TYPE4		4
+#define NFO_IS_IP_ADDR_TYPE6		6
+
+/* API_INFO */
+#define NFO_AI_MAXFOM_NO_LIMIT		NFO_DEF_UNSUPPORTED /* No limit */
+
+/* FOM_PROP */
+#define NFO_FP_FLG_HBA			1	/* FO implemented in HBA driver */
+#define NFO_FP_FLG_DISABLE		2	/* FOM disabled */
+#define NFO_FP_FLG_SUP_LB		16	/* Support load balancing */
+#define NFO_FP_FLG_SUP_PATH_ORDER	32	/* Support path ordering */
+#define NFO_FP_FLG_SUP_PATH_WEIGH	64	/* Support path weigh */
+#define NFO_FOM_PROP_NO_SUP		1	/* Settable property supported no */
+
+/* PATH_INFO */
+#define NFO_PI_PREFERRED		1	/* Preferred path bit */
+#define NFO_PATH_PROP_NO_SUP		0	/* Settable property supported no */
+
+/* LB_POLICY */
+#define NFO_LB_UNKNOWN			NFO_DEF_UNSUPPORTED
+#define NFO_LB_FAILOVER_ONLY		1
+#define NFO_LB_ROUND_ROBIN		2
+#define NFO_LB_ROUND_ROBIN_SUBSET	3
+#define NFO_LB_DYN_LEAST_QUEUE_DEPTH	4
+#define NFO_LB_WEIGHTED_PATHS		5
+#define NFO_LB_LEAST_BLOCKS		6
+#define NFO_LB_VENDOR_SPECIFIC		7
+#define NFO_LB_STATIC			8
+
+/* SPC3 Asymmetric access state */
+#define NFO_AAS_ACTIVE_OPT   	0
+#define NFO_AAS_ACTIVE_NONOPT 	1
+#define NFO_AAS_STANDBY		2
+#define NFO_AAS_UNAVAIL		3
+#define NFO_AAS_RESERVED	4
+#define NFO_AAS_ILL_REQ		15
+
+/* Device state */
+#define NFO_DS_ACTIVE   	1
+#define NFO_DS_PASSIVE 		2
+#define NFO_DS_FAILED		3
+#define NFO_DS_PENDING_REMOVE	4
+#define NFO_DS_REMOVED		5
+#define NFO_DS_UNAVAILABLE 	6
+#define NFO_DS_TRANSITIONING 	7
+#define NFO_DS_RESERVED		8
+
+/* Fog state */
+#define NFO_FOG_NORMAL   	1
+#define NFO_FOG_PENDING 	2
+#define NFO_FOG_FAILBACK	3
+#define NFO_FOG_FAILOVER	4
+
+/* Return status */
+#define NFO_STS_BASE			0x90000000
+#define NFO_STS_OK			(NFO_STS_BASE + 0)
+#define NFO_STS_INV_HNDL		(NFO_STS_BASE + 1)
+#define NFO_STS_INV_INSTN		(NFO_STS_BASE + 2)
+#define NFO_STS_UNDERRUN		(NFO_STS_BASE + 3)
+#define NFO_STS_EXISTED			(NFO_STS_BASE + 4)
+#define NFO_STS_NOT_PRESENT		(NFO_STS_BASE + 5)
+#define NFO_STS_FAIL                   	(NFO_STS_BASE + 6)
+#define NFO_STS_NOT_YET_IMPLEMENTED	(NFO_STS_BASE + 7)
+#define NFO_STS_UNSUP			(NFO_STS_BASE + 8)	/* Not supported */
+#define NFO_STS_INV_INSTANCE		(NFO_STS_BASE + 9)	/* Invalid instance */
+#define NFO_STS_REBOOT_NEEDED		(NFO_STS_BASE + 10)	/* Reboot needed */
+#define NFO_STS_INV_PATH		(NFO_STS_BASE + 11)	/* Invalid path */
+#define NFO_STS_INV_PARAM		(NFO_STS_BASE + 19)
+#define NFO_STS_INV_PARAM0		(NFO_STS_BASE + 20)
+#define NFO_STS_INV_PARAM1		(NFO_STS_BASE + 21)
+#define NFO_STS_INV_PARAM2		(NFO_STS_BASE + 22)
+#define NFO_STS_INV_PARAM3		(NFO_STS_BASE + 23)
+#define NFO_STS_INV_PARAM4		(NFO_STS_BASE + 24)
+#define NFO_STS_INV_PARAM5		(NFO_STS_BASE + 25)
+#define NFO_STS_INV_PARAM6		(NFO_STS_BASE + 26)
+#define NFO_STS_INV_PARAM7		(NFO_STS_BASE + 27)
+#define NFO_STS_INV_PARAM8		(NFO_STS_BASE + 28)
+#define NFO_STS_INV_PARAM9		(NFO_STS_BASE + 29)
+#define NFO_STS_CFG_CHANGED		(NFO_STS_BASE + 50)
+#define NFO_STS_FOM_ENABLED		(NFO_STS_BASE + 51)
+#define NFO_STS_FOM_DISABLED		(NFO_STS_BASE + 52)
+#define NFO_STS_FOM_ADDED		(NFO_STS_BASE + 53)
+#define NFO_STS_FOM_REMOVED		(NFO_STS_BASE + 54)
+#define NFO_STS_HBA_ADDED		(NFO_STS_BASE + 55)
+#define NFO_STS_HBA_REMOVED		(NFO_STS_BASE + 56)
+#define NFO_STS_PATH_ADDED		(NFO_STS_BASE + 57)
+#define NFO_STS_PATH_REMOVED		(NFO_STS_BASE + 58)
+#define NFO_STS_DEV_ADDED		(NFO_STS_BASE + 59)
+#define NFO_STS_DEV_REMOVED		(NFO_STS_BASE + 60)
+
+/* Event Codes */
+#define NFO_ES_INFO		0x60000000
+#define NFO_ES_WARN		0xA0000000
+#define NFO_ES_ERR		0xE0000000
+#define NFO_EF_FOM		0x00010000
+#define NFO_EF_HBA		0x00020000
+#define NFO_EF_DPG		0x00030000
+#define NFO_EF_PATH		0x00040000
+#define NFO_EVT_FOM_ENABLED	(NFO_ES_INFO | NFO_EF_FOM  | 1)	/* FOM enable */
+#define NFO_EVT_FOM_DISABLED	(NFO_ES_INFO | NFO_EF_FOM  | 2)	/* FOM disable */
+#define NFO_EVT_FOM_ADDED	(NFO_ES_INFO | NFO_EF_FOM  | 3)	/* FOM  add */
+#define NFO_EVT_FOM_REMOVED	(NFO_ES_INFO | NFO_EF_FOM  | 4)	/* FOM  del */
+#define NFO_EVT_HBA_ADDED	(NFO_ES_INFO | NFO_EF_HBA  | 5)	/* HBA  add */
+#define NFO_EVT_HBA_REMOVED	(NFO_ES_INFO | NFO_EF_HBA  | 6)	/* HBA  del */
+#define NFO_EVT_PATH_ADDED	(NFO_ES_INFO | NFO_EF_PATH | 7)	/* Path add */
+#define NFO_EVT_PATH_REMOVED	(NFO_ES_INFO | NFO_EF_PATH | 8)	/* Path del */
+#define NFO_EVT_DEV_ADDED	(NFO_ES_INFO | NFO_EF_PATH | 9)	/* Dev  add */
+#define NFO_EVT_DEV_REMOVED	(NFO_ES_INFO | NFO_EF_PATH | 10)	/* Dev  del */
+#define NFO_EVT_PATH_FAILOVER	(NFO_ES_INFO | NFO_EF_PATH | 11)	/* Path failover */
+#define NFO_EVT_PATH_FAILBACK	(NFO_ES_INFO | NFO_EF_PATH | 12)	/* Path failback */
+#define NFO_EVT_ER_THOLD	(NFO_ES_INFO | NFO_EF_DPG  | 13)	/* Err threshold */
+#define NFO_EVT_FO_THOLD	(NFO_ES_INFO | NFO_EF_DPG  | 14)	/* Fo  threshold */
+#define NFO_MAX_EVENT		(NFO_EVT_END)
+
+#define NFO_EVENT_CB             UD_H
+/*
+ * ***********************************************************************
+ * Common header struct definitions
+ * ***********************************************************************
+ */
+typedef struct _NFO_API_INFO
+{
+	UD_UI4	Version;
+	UD_UI4	MaxFOM;
+	UD_UI4	Reserved[8];
+} NFO_API_INFO, *PNFO_API_INFO;
+
+typedef struct _NFO_PROP_ENTRY
+{
+	UD_UI4	Current;
+	UD_UI4	Min;
+	UD_UI4	Def;
+	UD_UI4	Max;
+	UD_UI1	Name[NFO_DEF_STR_NAME_SIZE_32];
+	UD_UI4	Reserved[8];
+} NFO_PROP_ENTRY, *PNFO_PROP_ENTRY;
+
+typedef struct _NFO_PROP_LIST
+{
+	UD_UI4   Size;
+	UD_UI4   Count;
+	NFO_PROP_ENTRY   Entry[1];
+} NFO_PROP_LIST, *PNFO_PROP_LIST;
+
+typedef struct _NFO_FOM_PROP
+{
+	UD_UI4	Version;
+	UD_UI4	Flag;
+	UD_UI1	Name[NFO_DEF_STR_NAME_SIZE_32];
+	UD_UI4 	HbaCount;
+	UD_UI4 	DpgCount;
+	UD_UI4	SupportedTargetCount;
+	UD_UI4	CurrentTargetCount;
+	UD_UI4	MaxPath;
+	UD_UI4	Reserved[8];
+	NFO_PROP_LIST	PropList;
+} NFO_FOM_PROP, *PNFO_FOM_PROP;
+
+typedef struct _NFO_FC_UID
+{
+	UD_UI1	Wwpn[NFO_FC_WWN_SIZE];
+	UD_UI1	Wwnn[NFO_FC_WWN_SIZE];
+	UD_UI1	Pid[NFO_FC_PID_SIZE];
+	UD_UI4	Reserved[8];
+} NFO_FC_UID, *PNFO_FC_UID;
+
+typedef struct _NFO_IS_UID
+{
+	UD_UI4	IpType;
+	UD_UI1	Ip[NFO_IS_IP_ADDR_SIZE];
+	UD_UI1	Name[NFO_IS_NAME_SIZE];
+	UD_UI4	Reserved[8];
+} NFO_IS_UID, *PNFO_IS_UID;
+
+typedef struct _NFO_TRANSPORT
+{
+	UD_UI4	Value;
+	UD_UI1	Name[NFO_IS_NAME_SIZE];
+	UD_UI4	Reserved[8];
+} NFO_TRANSPORT, *PNFO_TRANSPORT;
+
+typedef struct _NFO_TRANSPORT_LIST
+{
+	UD_UI4   Size;
+	UD_UI4   Count;
+	NFO_TRANSPORT	Entry[1];
+} NFO_TRANSPORT_LIST, *PNFO_TRANSPORT_LIST;
+
+typedef struct _NFO_HBA_INFO
+{
+	UD_UI4	Number;
+	UD_UI4	Transport;
+	UD_UI1	Name[NFO_DEF_STR_NAME_SIZE_64];
+	union
+	{
+		NFO_FC_UID	FcUid;
+		NFO_IS_UID	IsUid;
+	} Uid;
+	UD_UI4	Reserved[8];
+} NFO_HBA_INFO, *PNFO_HBA_INFO;
+
+typedef struct _NFO_HBA_INFO_LIST
+{
+	UD_UI4 		Size;
+	UD_UI4 		Count;
+	NFO_HBA_INFO	Entry[1];
+} NFO_HBA_INFO_LIST, *PNFO_HBA_INFO_LIST;
+
+typedef struct _NFO_SCSI_ADDR
+{
+	UD_UI4    	Number;
+	UD_UI4    	Bus;
+	UD_UI4    	Target;
+	UD_UI4     	Lun;
+} NFO_SCSI_ADDR, *PNFO_SCSI_ADDR;
+
+typedef struct _NFO_DEV_INFO
+{
+	UD_UI1	Name[NFO_DEF_STR_NAME_SIZE_64];
+	UD_UI1	VendorId[NFO_DEF_INQ_VENDOR_ID_SIZE];
+	UD_UI1	ProductId[NFO_DEF_INQ_PROD_ID_SIZE];
+	UD_UI1 	ProductVersion[NFO_DEF_INQ_PROD_VER_SIZE];
+	UD_UI1 	Luid[NFO_DEF_INQ_LUID_SIZE];
+	UD_UI4 	Transport;
+	union
+	{
+		NFO_FC_UID	FcUid;
+		NFO_IS_UID	IsUid;
+	} Uid;
+	UD_UI4	Reserved[8];
+} NFO_DEV_INFO, *PNFO_DEV_INFO;
+
+typedef struct _LB_POLICY
+{
+	UD_UI4	Value;
+	UD_UI1	Name[NFO_DEF_STR_NAME_SIZE_32];
+	UD_UI4	Reserved[8];
+} NFO_LB_POLICY, *PNFO_LB_POLICY;
+
+typedef struct _LB_POLICY_LIST
+{
+	UD_UI4     Size;
+	UD_UI1     Count;
+	NFO_LB_POLICY Entry[1];
+} NFO_LB_POLICY_LIST, *PNFO_LB_POLICY_LIST;
+
+typedef struct _LB_POLICY_INFO
+{
+	NFO_LB_POLICY_LIST Supported;
+	UD_UI4	Current;
+	UD_UI4	ActivePathCount;
+	UD_UI4	Reserved[8];
+} NFO_LB_POLICY_INFO, *PNFO_LB_POLICY_INFO;
+
+typedef struct _DPG_PROP
+{
+	UD_UI1		Name[NFO_DEF_STR_NAME_SIZE_64];
+	NFO_DEV_INFO 	DevInfo;
+	UD_UI4		PathCount;
+	NFO_LB_POLICY  	LbPolicy;    
+	UD_UI4		Reserved[8];
+} NFO_DPG_PROP, *PNFO_DPG_PROP;
+
+typedef struct _NFO_DPG_PROP_LIST
+{
+	UD_UI4 		Size;
+	UD_UI4 		Count;
+	NFO_DPG_PROP	Entry[1];
+} NFO_DPG_PROP_LIST, *PNFO_DPG_PROP_LIST;
+
+typedef struct _NFO_PATH_INFO
+{
+	NFO_SCSI_ADDR 	ScsiAddr;
+	UD_UI1		Name[NFO_DEF_STR_NAME_SIZE_64];
+	UD_UI4  	Status;
+	UD_UI4 		Flag;
+	UD_UI4 		RelTgtPortId;
+	UD_UI4 		TgtPortGrp;
+	UD_UI4		Reserved[8];
+	NFO_PROP_LIST	PropList;
+} NFO_PATH_INFO, *PNFO_PATH_INFO;
+
+typedef struct _NFO_IO_STAT
+{
+	UD_UI8	NoRead;
+	UD_UI8	NoWrite;
+	UD_UI8	MBRead;
+	UD_UI8	MBWritten;
+	UD_UI4	Reserved[8];
+} NFO_IO_STAT, *PNFO_IO_STAT;
+
+typedef struct _NFO_PATH_STAT
+{
+	UD_UI8	NoFailover;
+	UD_UI8	NoFailback;
+	UD_UI4	Reserved[8];
+} NFO_PATH_STAT, *PNFO_PATH_STAT;
+
+typedef struct _NFO_ER_STAT
+{
+	UD_UI8	NoReadRetry;
+	UD_UI8	NoWriteRetry;
+	UD_UI8	NoReadFailure;
+	UD_UI8	NoWriteFailure;
+	UD_UI8	NoFailover;
+	UD_UI4	Reserved[8];
+} NFO_ER_STAT, *PNFO_ER_STAT;
+
+typedef struct _NFO_ADP_STAT
+{
+	NFO_IO_STAT	IoStat;
+	NFO_ER_STAT	ErStat;
+	NFO_PATH_STAT	PathStat;
+	UD_UI4		Reserved[8];
+} NFO_ADP_STAT, *PNFO_ADP_STAT;
+
+typedef struct _NFO_STORAGE
+{
+	UD_UI1	Name[NFO_DEF_STR_NAME_SIZE_32];
+	UD_UI4	Type;
+	UD_UI4	ControlFlag;
+	UD_UI4	DefaultLB;
+	UD_UI4	Reserved[8];
+} NFO_STORAGE, *PNFO_STORAGE;
+
+
+typedef struct _NFO_STORAGE_LIST
+{
+	UD_UI4 		Size;
+	UD_UI4		Count;
+	NFO_STORAGE 	SupportList[1];
+} NFO_STORAGE_LIST, *PNFO_STORAGE_LIST;
+
+typedef struct _NFO_PATH
+{
+	UD_UI8		PathUid;
+	UD_UI4		Fom;
+	NFO_PATH_INFO	PathInfo;
+	UD_UI4		DPathStatus;
+	UD_UI4		HbaInstance;
+	UD_UI4		DpgInstance;
+	UD_UI4		StorageInstance;
+	NFO_HBA_INFO	HbaInfo;
+	NFO_DPG_PROP	DpgProp;
+	NFO_STORAGE	Storage;
+	UD_UI4		Reserved[8];
+} NFO_PATH, *PNFO_PATH;
+
+typedef struct _NFO_PATH_INFO_LIST
+{
+	UD_UI4 		Size;
+	UD_UI4 		Count;
+	NFO_PATH_INFO	Entry[1];
+} NFO_PATH_INFO_LIST, *PNFO_PATH_INFO_LIST;
+
+typedef struct _NFO_PATH_LIST
+{
+	UD_UI4		Size;
+	UD_UI4		Count;
+	NFO_PATH	Path[1];
+} NFO_PATH_LIST, *PNFO_PATH_LIST;
+
+typedef struct _NFO_EVENT_CB_ENTRY
+{
+	UD_UI4		Id;
+	NFO_EVENT_CB	Callback;
+	UD_UI4		Context;
+	UD_UI4		Reserved[8];
+} NFO_EVENT_CB_ENTRY, *PNFO_EVENT_CB_ENTRY;
+
+typedef struct _NFO_EVENT_CB_LIST
+{
+	UD_UI4			Size;
+	UD_UI4			Count;
+	NFO_EVENT_CB_ENTRY	Entry[1];
+} NFO_EVENT_CB_LIST, *PNFO_EVENT_CB_LIST;
+
+typedef struct _NFO_EVT_FOM
+{
+	UD_UI4	Instance;
+	UD_H	Handle;
+	UD_UI8	Timestamp;
+	UD_UI4	Reason;
+	UD_UI4	Reserved[8];
+} NFO_EVT_FOM, *PNFO_EVT_FOM;
+
+typedef struct _NFO_EVT_HBA
+{
+	UD_UI4	Instance;
+	UD_H	Handle;
+	UD_UI8	Timestamp;
+	UD_UI4	Reason;
+	UD_UI4	Reserved[8];
+} NFO_EVT_HBA, *PNFO_EVT_HBA;
+
+typedef struct _NFO_EVT_PATH
+{
+	UD_UI4	Instance;
+	UD_H	Handle;
+	UD_UI8	Timestamp;
+	UD_UI4	Reason;
+	UD_UI4	Reserved[8];
+} NFO_EVT_PATH, *PNFO_EVT_PATH;
+
+typedef struct _NFO_EVT_DEV
+{
+	UD_UI4	Instance;
+	UD_H	Handle;
+	UD_UI8	Timestamp;
+	UD_UI4	Reason;
+	UD_UI4	Reserved[8];
+} NFO_EVT_DEV, *PNFO_EVT_DEV;
+
+typedef struct _NFO_EVT
+{
+	UD_UI4		Code;
+	union
+	{
+		NFO_EVT_FOM	Fom;
+		NFO_EVT_HBA	HBA;
+		NFO_EVT_PATH	Path;
+		NFO_EVT_DEV	Dev;
+		UD_UI4		Data[1];
+	} Data;
+} NFO_EVT, *PNFO_EVT;
+
+/*
+ * ***********************************************************************
+ * Function prototypes
+ * ***********************************************************************
+ */
+UD_UI4 NfoGetApiInfo              (PNFO_API_INFO pApiInfo);
+UD_UI4 NfoGetFomCount             (PUD_UI4  pFomCount);
+UD_UI4 NfoOpenFom                 (UD_UI4 Instance, PUD_H pFomHandle);
+UD_UI4 NfoCloseFom                (UD_H FomHandle);
+UD_UI4 NfoGetTransportInfo        (UD_H FomHandle, UD_UI4 BufSize, PNFO_TRANSPORT_LIST pTransport);
+UD_UI4 NfoGetFomProperty          (UD_H FomHandle, PNFO_FOM_PROP pProp);
+UD_UI4 NfoSetFomProperty          (UD_H FomHandle, UD_UI4 BufSize, PNFO_PROP_LIST pPropList);
+UD_UI4 NfoGetHbaInfo              (UD_H FomHandle, UD_UI4 HbaInstance, PNFO_HBA_INFO pInfo);
+UD_UI4 NfoGetHbaInfoAll           (UD_H FomHandle, UD_UI4 HbaInstance, UD_UI4 BufSize, PNFO_HBA_INFO_LIST pHbaInfoList);
+UD_UI4 NfoGetDpgProperty          (UD_H FomHandle, UD_UI4 DpgInstance, PNFO_DPG_PROP pDpgProp);
+UD_UI4 NfoGetDpgPropertyAll       (UD_H FomHandle, UD_UI4 Instance, UD_UI4 BufSize, PNFO_DPG_PROP_LIST pDpgPropList);
+UD_UI4 NfoGetDpgPathInfo          (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 PathNo, PNFO_PATH_INFO pPathInfo);
+UD_UI4 NfoGetDpgPathInfoAll       (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 Instance, UD_UI4 BufSize, PNFO_PATH_INFO_LIST pPathInfoList);
+UD_UI4 NfoSetDpgPathInfo          (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 PathNo, PNFO_PATH_INFO pPathInfo);
+UD_UI4 NfoSetDpgPathInfoAll       (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 Instance, UD_UI4 BufSize, PNFO_PATH_INFO_LIST pPathInfoList);
+UD_UI4 NfoGetLBInfo               (UD_H FomHandle, UD_UI4 BufSize, PNFO_LB_POLICY_LIST pLb);
+UD_UI4 NfoGetLBPolicy             (UD_H FomHandle, UD_UI4 DpgInstance, PUD_UI4 pLbPolicy);
+UD_UI4 NfoSetLBPolicy             (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 LbPolicy);
+UD_UI4 NfoGetDpgStatistics        (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 PathNo, PNFO_ADP_STAT pAdpStat);
+UD_UI4 NfoClearDpgErrStatistics   (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 PathNo);
+UD_UI4 NfoClearDpgIoStatistics    (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 PathNo);
+UD_UI4 NfoClearDpgFoStatistics    (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 PathNo, PNFO_PATH_STAT pFoStat);
+UD_UI4 NfoMovePath                (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 PathNo);
+UD_UI4 NfoVerifyPath              (UD_H FomHandle, UD_UI4 DpgInstance, UD_UI4 PathNo);
+UD_UI4 NfoGetEventList            (UD_H FomHandle, UD_UI4 BufSize, PNFO_EVENT_CB_LIST pEventCbList);
+UD_UI4 NfoRegisterEventCallback   (UD_H FomHandle, UD_UI4 BufSize, PNFO_EVENT_CB_LIST pEventCbList);
+UD_UI4 NfoDeregisterEventCallback (UD_H FomHandle, UD_UI4 BufSize, PNFO_EVENT_CB_LIST pEventCbList);
+UD_UI4 NfoEnableFom               (UD_H FomHandle);
+UD_UI4 NfoDisableFom              (UD_H FomHandle);
+UD_UI4 NfoGetSupportedStorageList (UD_H FomHandle, UD_UI4 BufSize, PNFO_STORAGE_LIST pStorageList);
+UD_UI4 NfoGetPathAll              (UD_H FomHandle, UD_UI4 Index, UD_UI4 BufSize, PNFO_PATH_LIST pPathList);
+
+#if 0
+/* Example tables */
+/* Example transport protocol table */
+NFO_TRANSPORT_LIST TransportTbl =
+{
+	sizeof(NFO_TRANSPORT) * NFO_TRANSPORT_NO_SUP + 1,
+	NFO_TRANSPORT_NO_SUP + 1,
+	{ NFO_TRANSPORT_FC, "Fibre Channel" },
+	{ NFO_TRANSPORT_IS, "iScsi" },
+	{ NFO_TRANSPORT_UNKNWON, "Unknown" },
+};
+
+/* Example property table */
+NFO_PROP_LIST FomPropTbl =
+{
+	sizeof(NFO_PROP) * NFO_FOM_PROP_NO_SUP,
+	NFO_FOM_PROP_NO_SUP,
+	{ 3, 1, 3, 10, "Io Retry Count" },
+};
+
+/* Example path property table */
+NFO_PROP_LIST FomPropTbl =
+{
+	sizeof(NFO_PROP) * NFO_PATH_PROP_NO_SUP,
+	NFO_PATH_PROP_NO_SUP,
+	{ 1, 1, 1, 32, "Order" },
+	{ 1, 1, 1, 10, "Weight" },
+};
+
+/* Example policy table for Active/Active model, can have one for each DPG */
+NFO_LB_POLICY_LIST LbPolicyAATbl =
+{
+	sizeof(NFO_LB_POLICY) * 5,
+	5,
+	{ NFO_LB_FAILOVER_ONLY,         "Failover only" },
+	{ NFO_LB_ROUND_ROBIN,           "Round Robin" },
+	{ NFO_LB_DYN_LEAST_QUEUE_DEPTH, "IO Bandpass" },
+	{ NFO_LB_LEAST_BLOCKS,          "MB Bandpass" },
+	{ NFO_LB_STATIC,                "Static" },
+};
+#endif
+
+
+#if defined(linux)                 /* Linux */
+#include "qlnfoln.h"
+#endif
+
+
+#endif /* _QLNFO_H */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlnfoln.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlnfoln.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlnfoln.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlnfoln.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,92 @@
+/*****************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic device driver for Linux 2.4.x+
+* Copyright (C) 2004 QLogic Corporation
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+****************************************************************************/
+#ifndef _QLNFOLN_H_
+#define _QLNFOLN_H_
+
+/********************************************************
+ * NextGen Failover ioctl command codes range from 0x37
+ * to 0x4f.  See qlnfoln.h
+ ********************************************************/
+#define EXT_DEF_NFO_CC_START_IDX	0x37	/* NFO cmd start index */
+
+#define EXT_CC_TRANSPORT_INFO					\
+    QL_IOCTL_CMD(0x37)
+#define EXT_CC_GET_FOM_PROP					\
+    QL_IOCTL_CMD(0x38)
+#define EXT_CC_GET_HBA_INFO					\
+    QL_IOCTL_CMD(0x39)
+#define EXT_CC_GET_DPG_PROP					\
+    QL_IOCTL_CMD(0x3a)
+#define EXT_CC_GET_DPG_PATH_INFO					\
+    QL_IOCTL_CMD(0x3b)
+#define EXT_CC_SET_DPG_PATH_INFO					\
+    QL_IOCTL_CMD(0x3c)
+#define EXT_CC_GET_LB_INFO					\
+    QL_IOCTL_CMD(0x3d)
+#define EXT_CC_GET_LB_POLICY					\
+    QL_IOCTL_CMD(0x3e)
+#define EXT_CC_SET_LB_POLICY					\
+    QL_IOCTL_CMD(0x3f)
+#define EXT_CC_GET_DPG_STATS					\
+    QL_IOCTL_CMD(0x40)
+#define EXT_CC_CLEAR_DPG_ERR_STATS				\
+    QL_IOCTL_CMD(0x41)
+#define EXT_CC_CLEAR_DPG_IO_STATS					\
+    QL_IOCTL_CMD(0x42)
+#define EXT_CC_CLEAR_DPG_FO_STATS					\
+    QL_IOCTL_CMD(0x43)
+#define EXT_CC_GET_PATHS_FOR_ALL					\
+    QL_IOCTL_CMD(0x44)
+#define EXT_CC_MOVE_PATH						\
+    QL_IOCTL_CMD(0x45)
+#define EXT_CC_VERIFY_PATH					\
+    QL_IOCTL_CMD(0x46)
+#define EXT_CC_GET_EVENT_LIST					\
+    QL_IOCTL_CMD(0x47)
+#define EXT_CC_ENABLE_FOM						\
+    QL_IOCTL_CMD(0x48)
+#define EXT_CC_DISABLE_FOM					\
+    QL_IOCTL_CMD(0x49)
+#define EXT_CC_GET_STORAGE_LIST					\
+    QL_IOCTL_CMD(0x4a)
+
+#define EXT_DEF_NFO_CC_END_IDX	0x4a	/* NFO cmd end index */
+
+
+typedef struct _EXT_IOCTL_NFO {
+	UINT8	Signature[NFO_DEF_SIGNATURE_SIZE];	/* 8   */
+	UINT16	AddrMode;				/* 2   */
+	UINT16	Version;				/* 2   */
+	UINT16	SubCode;				/* 2   */
+	UINT16	Instance;				/* 2   */
+	UINT32	Status; 				/* 4   */
+	UINT32	DetailStatus;				/* 4   */
+	UINT32	Reserved1;				/* 4   */
+	UINT32	RequestLen;				/* 4   */
+	UINT32	ResponseLen;				/* 4   */
+	UINT64	RequestAdr;				/* 8   */
+	UINT64	ResponseAdr;				/* 8   */
+	UINT16	HbaSelect;				/* 2   */
+	UINT32	VendorSpecificStatus[11];		/* 44  */
+	UINT8	VendorSpecificData[8];			/* 8  */
+	UINT32	Reserved2[8];				/* 32  */
+} EXT_IOCTL_NFO, *PEXT_IOCTL_NFO;			/* 138 */
+
+
+#endif  /* _QLNFOLN_H_ */
+
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/qlud.h linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlud.h
--- linux-2.6.5/drivers/scsi/qla4xxx/qlud.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/qlud.h	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,95 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP4xxx device driver for Linux 2.6.x
+ * Copyright (C) 2004 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+/*
+ * File Name: qlud.h
+ *
+ * Revision History:
+ *
+ */
+
+#ifndef	_QLUD_H
+#define	_QLUD_H
+
+/*
+ * NOTE: the following version defines must be updated each time the
+ *	 changes made may affect the backward compatibility of the
+ *	 input/output relations
+ */
+#define	UD_VERSION             1
+#define	UD_VERSION_STR         "1.0"
+
+/*
+ * ***********************************************************************
+ * Data type definitions
+ * ***********************************************************************
+ */
+#ifdef _MSC_VER
+
+#define	UD_BOOL	BOOLEAN
+#define	UD_UI1	UCHAR
+#define	UD_UI2	USHORT
+#define	UD_UI4	ULONG
+#define	UD_UI8	ULONGLONG
+#define	UD_I1	CHAR
+#define	UD_I2	SHORT
+#define	UD_I4	LONG
+#define	UD_I8	LONGLONG
+#define UD_V	VOID
+#define	UD_PV	PVOID
+#define	PUD_UI1	PUCHAR
+#define	PUD_UI2	PUSHORT
+#define	PUD_UI4	PULONG
+#define	PUD_I1	PCHAR
+#define	PUD_I2	PSHORT
+#define	PUD_I4	PLONG
+#define UD_H	PVOID
+
+#define PUD_H	UD_H*
+
+#elif defined(linux)                 /* Linux */
+
+#ifdef APILIB
+#include <stdint.h>
+#endif
+
+#define	UD_BOOL	uint8_t
+#define	UD_UI1	uint8_t
+#define	UD_UI2	uint16_t
+#define	UD_UI4	uint32_t
+#define	UD_UI8	uint64_t
+#define	UD_I1	int8_t
+#define	UD_I2	int16_t
+#define	UD_I4	int32_t
+#define	UD_I8	int64_t
+#define UD_V	void
+#define	UD_PV	void *
+#define	PUD_UI1	uint8_t *
+#define	PUD_UI2	uint16_t *
+#define	PUD_UI4	uint32_t *
+#define	PUD_I1	int8_t *
+#define	PUD_I2	int16_t *
+#define	PUD_I4	int32_t *
+#define UD_H	int
+#define PUD_H	int *
+
+#elif defined(sun) || defined(__sun) /* Solaris */
+
+#endif
+
+#endif /* _QLUD_H */
diff -urNp linux-2.6.5/drivers/scsi/qla4xxx/README.qla4xxx linux-2.6.5.SUSE/drivers/scsi/qla4xxx/README.qla4xxx
--- linux-2.6.5/drivers/scsi/qla4xxx/README.qla4xxx	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/qla4xxx/README.qla4xxx	2004-10-13 22:52:17.000000000 +0200
@@ -0,0 +1,173 @@
+                   QLogic iSCSI Driver for Kernel 2.6.x
+
+Products supported: QLA4010
+
+09/30/2004
+
+
+
+Contents
+--------
+
+1. OS Support
+
+2. Supported Features
+
+3. Release History
+
+4. Saving the Driver Source to Diskette
+
+5. Installing the driver
+
+   5.1  Building the driver from the Source
+   5.2  Load the Driver Manually using INSMOD or MODPROBE
+   5.3  Making a RAMDISK Image to Load the Driver
+
+6. Contacting QLogic
+
+
+**********************************************************************
+
+
+1. OS Support
+-------------
+
+This driver works with Linux kernel 2.6.x distributions. 
+
+
+**********************************************************************
+
+
+2. Supported Features
+---------------------
+
+* Supports Failover
+
+
+**********************************************************************
+
+
+3. Release History
+------------------
+
+Please refer to Release Notes (release.txt).
+
+
+**********************************************************************
+
+
+4. Saving the Driver Source to Diskette
+---------------------------------------
+1. Download the failover or non-failover
+   qla4xxx-src-vx.yy.tar.[bz2|gz] file from QLogic's website.
+
+2. If prompted "What would you like to do with this file?" choose 
+   "Save this file to disk."
+
+3. Insert a blank diskette and download to the diskette directly.
+
+
+**********************************************************************
+
+
+5. Installing the driver
+------------------------
+As of this writing, only a pre-release of SLES9 was available for
+BETA testing.  As such, the following directions will work on a SLES9
+system.  Other distributions may require a different set of steps.
+
+5.1  Building a Driver from the Source Code 
+-------------------------------------------
+
+From the source code, you can build a qla4xxx.ko for your host system, 
+and load the driver manually or automatically using a RAMDISK image during
+system boot time.
+
+1. Extract the kernel-headers and kernel-sources RPM files from the 
+   SLES 9 installation CDs.
+       
+2. Using the diskette you created in Section 4, copy the
+   qla4xxx-src-vx.yy-*.tar.gz file to /qla4xxx. Follow these steps from
+   the "/" (root) directory:
+
+       # mkdir qla4xxx
+       # cd qla4xxx
+       # mount /mnt/floppy
+       # cp /mnt/floppy/*.[bz2|gz] . (the period at the end is required)
+       # tar -xvzf *.tar.gz. If bz2, then use tar -xvfj qla4xxx*.tar.bz2
+       
+
+3. Build the Driver modules from the source code by typing:
+
+       #[ql4xxx-*] make -C /usr/src/linux O=/usr/src/linux-obj/i386/smp M=$PWD modules
+	
+4. To load the driver manually, see section 5.2. To make a RAMDISK
+   image to load the driver during system boot time, see section 5.3.
+
+
+5.2  Load the Driver Manually using INSMOD or MODPROBE 
+------------------------------------------------------
+
+Before loading the driver manually, first build the driver binary from
+the driver source files as described in sections 5.1.
+
+- To load the driver directly from the local build directory, type
+  the following:
+
+       # insmod ./qla4xxx.ko
+
+- To load the driver using modprobe:
+
+       1. Install the modules by typing:
+
+	  # make -C /usr/src/linux O=/usr/src/linux-obj/i386/smp M=$PWD modules_install
+
+       2. Type the following to load the Driver:
+
+          # modprobe qla4xxx
+
+
+5.3  Making a RAMDISK Image to Load the Driver
+----------------------------------------------
+
+1. Build the Driver binary files (see 5.1).
+
+2. Install the modules by typing:
+
+	# make -C /usr/src/linux O=/usr/src/linux-obj/i386/smp M=$PWD modules_install
+
+3. Add the appropriate module binary name to the INITRD_MODULES
+line in /etc/sysconfig/kernel:
+
+       INITRD_MODULES="aic79xx reiserfs qla4xxx"
+
+4. Type the following command:
+
+	# /sbin/mk_initrd
+
+   For GRUB:
+
+	Add "initrd=/boot/<RAMDISK file name>" in 
+	/etc/grub.conf under one of the kernel entries 
+	to use the RAMDISK image.
+
+ 
+**********************************************************************
+
+6. Contacting QLogic 
+---------------------
+
+Please visit QLogic's website (www.qlogic.com). On this site you will
+find product information, our latest drivers, and links for technical
+assistance if needed.
+
+
+======================================================================
+
+
+    Copyright (c) 2004 QLogic Corporation. All rights reserved 
+    worldwide. 
+
+
+
+

