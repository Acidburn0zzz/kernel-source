diff -urNp linux-2.6.5/drivers/net/Kconfig linux-2.6.5.SUSE/drivers/net/Kconfig
--- linux-2.6.5/drivers/net/Kconfig	2004-04-19 12:00:56.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/Kconfig	2004-04-19 12:01:13.000000000 +0200
@@ -1906,6 +1906,82 @@ config E1000_NAPI
 	bool "Use Rx Polling (NAPI)"
 	depends on E1000
 
+config E100_INTEL
+	tristate "Intel(R) PRO/100+ support (Intel driver)"
+	depends on NET_PCI && PCI
+	select MII
+	---help---
+	  This driver supports Intel(R) PRO/100 family of adapters, which 
+	  includes:
+
+	  Controller  Adapter Name                       Board IDs
+	  ----------  ------------                       ---------
+
+	  82558       PRO/100+ PCI Adapter               668081-xxx, 
+	  689661-xxx
+	  82558       PRO/100+ Management Adapter        691334-xxx, 
+	  701738-xxx,
+	  721383-xxx
+	  82558       PRO/100+ Dual Port Server Adapter  714303-xxx, 
+	  711269-xxx, 
+	  A28276-xxx
+	  82558       PRO/100+ PCI Server Adapter        710550-xxx
+	  82550       PRO/100 S Server Adapter           752438-xxx
+	  82559                                          A56831-xxx, 
+	  A10563-xxx,
+	  A12171-xxx, 
+	  A12321-xxx, 
+	  A12320-xxx, 
+	  A12170-xxx
+	  748568-xxx
+	  748565-xxx
+	  82550       PRO/100 S Desktop Adapter          751767-xxx
+	  82559                                          748592-xxx, 
+	  A12167-xxx, 
+	  A12318-xxx, 
+	  A12317-xxx, 
+	  A12165-xxx,
+	  748569-xxx 
+	  82559       PRO/100+ Server Adapter            729757-xxx
+	  82559       PRO/100 S Management Adapter       748566-xxx, 
+	  748564-xxx
+	  82550       PRO/100 S Dual Port Server Adapter A56831-xxx
+	  82551       PRO/100 M Desktop Adapter          A80897-xxx
+	  PRO/100 S Advanced Management Adapter 
+	  747842-xxx, 
+	  745171-xxx
+	  CNR         PRO/100 VE Desktop Adapter         A10386-xxx, 
+	  A10725-xxx, 
+	  A23801-xxx, 
+	  A19716-xxx
+	  PRO/100 VM Desktop Adapter         A14323-xxx, 
+	  A19725-xxx, 
+	  A23801-xxx, 
+	  A22220-xxx, 
+	  A23796-xxx
+
+
+	  To verify that your adapter is supported, find the board ID number 
+	  on the adapter. Look for a label that has a barcode and a number 
+	  in the format 123456-001 (six digits hyphen three digits). Match 
+	  this to the list of numbers above.
+
+	  For more information on how to identify your adapter, go to the 
+	  Adapter & Driver ID Guide at:
+
+	  http://support.intel.com/support/network/adapter/pro100/21397.htm
+
+	  For the latest Intel PRO/100 network driver for Linux, see:
+
+	  http://appsr.intel.com/scripts-df/support_intel.asp
+
+	  More specific information on configuring the driver is in 
+	  <file:Documentation/networking/e100.txt>.
+
+	  To compile this driver as a module, choose M here and read
+	  <file:Documentation/networking/net-modules.txt>.  The module
+	  will be called e100-intel.
+
 config MYRI_SBUS
 	tristate "MyriCOM Gigabit Ethernet support"
 	depends on SBUS
diff -urNp linux-2.6.5/drivers/net/Makefile linux-2.6.5.SUSE/drivers/net/Makefile
--- linux-2.6.5/drivers/net/Makefile	2004-04-19 12:00:56.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/Makefile	2004-04-19 12:02:16.000000000 +0200
@@ -9,6 +9,7 @@ ifeq ($(CONFIG_ISDN_PPP),y)
 endif
 
 obj-$(CONFIG_E1000) += e1000/
+obj-$(CONFIG_E100_INTEL) += e100-intel/
 obj-$(CONFIG_NET_BROADCOM) += bcm/
 obj-$(CONFIG_NET_BCM44) += bcm44/
 obj-$(CONFIG_IXGB) += ixgb/
diff -urNp linux-2.6.5/drivers/net/e100-intel/Makefile linux-2.6.5.SUSE/drivers/net/e100-intel/Makefile
--- linux-2.6.5/drivers/net/e100-intel/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/Makefile	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,36 @@
+################################################################################
+#
+# 
+# Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it 
+# under the terms of the GNU General Public License as published by the Free 
+# Software Foundation; either version 2 of the License, or (at your option) 
+# any later version.
+# 
+# This program is distributed in the hope that it will be useful, but WITHOUT 
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+# more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 59 
+# Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+# 
+# The full GNU General Public License is included in this distribution in the
+# file called LICENSE.
+# 
+# Contact Information:
+# Linux NICS <linux.nics@intel.com>
+# Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+#
+################################################################################
+
+#
+# Makefile for the Intel(R) PRO/1000 ethernet driver
+#
+
+obj-$(CONFIG_E100_INTEL) += e100-intel.o
+
+e100-intel-objs := e100_config.o e100_eeprom.o e100_kcompat.o e100_main.o \
+	     e100_phy.o e100_test.o
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100.h linux-2.6.5.SUSE/drivers/net/e100-intel/e100.h
--- linux-2.6.5/drivers/net/e100-intel/e100.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100.h	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,1045 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+#ifndef _E100_INC_
+#define _E100_INC_
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/wait.h>
+#include <linux/reboot.h>
+#include <asm/io.h>
+#include <asm/unaligned.h>
+#include <asm/processor.h>
+#ifdef SIOCETHTOOL
+#include <linux/ethtool.h>
+#include <linux/inetdevice.h>
+#endif
+#include <linux/bitops.h>
+
+#include <linux/if.h>
+#include <asm/uaccess.h>
+#include <linux/ip.h>
+#ifdef NETIF_F_HW_VLAN_TX
+#include <linux/if_vlan.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,5)
+#include <linux/mii.h>
+#endif
+
+/* 
+ * e100_kcompat.h should be the last header file included in e100.h.
+ */ 
+#include "e100_kcompat.h"
+
+#define E100_CABLE_UNKNOWN	0
+#define E100_CABLE_OK		1		
+#define E100_CABLE_OPEN_NEAR	2	/* Open Circuit Near End  */
+#define E100_CABLE_OPEN_FAR	3	/* Open Circuit Far End   */
+#define E100_CABLE_SHORT_NEAR	4	/* Short Circuit Near End */
+#define E100_CABLE_SHORT_FAR	5	/* Short Circuit Far End  */
+
+#ifdef	ETHTOOL_GREGS
+#define E100_REGS_LEN 2
+#endif
+/*
+ *  Configure parameters for buffers per controller.
+ *  If the machine this is being used on is a faster machine (i.e. > 150MHz)
+ *  and running on a 10MBS network then more queueing of data occurs. This
+ *  may indicate the some of the numbers below should be adjusted.  Here are
+ *  some typical numbers:
+ *                             MAX_TCB 64
+ *                             MAX_RFD 64
+ *  The default numbers give work well on most systems tests so no real
+ *  adjustments really need to take place.  Also, if the machine is connected
+ *  to a 100MBS network the numbers described above can be lowered from the
+ *  defaults as considerably less data will be queued.
+ */
+
+#define TX_FRAME_CNT   8	/* consecutive transmit frames per interrupt */
+/* TX_FRAME_CNT must be less than MAX_TCB    */
+
+#define E100_DEFAULT_TCB   64
+#define E100_MIN_TCB       2*TX_FRAME_CNT + 3	/* make room for at least 2 interrupts */
+#define E100_MAX_TCB       1024
+
+#define E100_DEFAULT_RFD   64
+#define E100_MIN_RFD       8
+#define E100_MAX_RFD       1024
+
+#define E100_DEFAULT_XSUM         true
+#define E100_DEFAULT_BER          ZLOCK_MAX_ERRORS
+#define E100_DEFAULT_SPEED_DUPLEX 0
+#define E100_DEFAULT_FC           0
+#define E100_DEFAULT_IFS          true
+#define E100_DEFAULT_UCODE        true
+
+#define TX_THRSHLD     8
+
+/* IFS parameters */
+#define MIN_NUMBER_OF_TRANSMITS_100 1000
+#define MIN_NUMBER_OF_TRANSMITS_10  100
+
+#define E100_MAX_NIC 16
+
+#define E100_MAX_SCB_WAIT	100	/* Max udelays in wait_scb */
+#define E100_MAX_CU_IDLE_WAIT	50	/* Max udelays in wait_cus_idle */
+
+/* HWI feature related constant */
+#define HWI_REGISTER_GRANULARITY        80	/* register granularity = 80 Cm */
+#define HWI_NEAR_END_BOUNDARY           1000	/* Near end is defined as < 10 meters */
+
+/* CPUSAVER_BUNDLE_MAX: Sets the maximum number of frames that will be bundled.
+ * In some situations, such as the TCP windowing algorithm, it may be
+ * better to limit the growth of the bundle size than let it go as
+ * high as it can, because that could cause too much added latency.
+ * The default is six, because this is the number of packets in the
+ * default TCP window size.  A value of 1 would make CPUSaver indicate
+ * an interrupt for every frame received.  If you do not want to put
+ * a limit on the bundle size, set this value to xFFFF.
+ */
+#define E100_DEFAULT_CPUSAVER_BUNDLE_MAX	6
+#define E100_DEFAULT_CPUSAVER_INTERRUPT_DELAY	0x600
+#define E100_DEFAULT_BUNDLE_SMALL_FR		false
+
+/* end of configurables */
+
+/* ====================================================================== */
+/*                                hw                                      */
+/* ====================================================================== */
+
+/* timeout for command completion */
+#define E100_CMD_WAIT   100	/* iterations */
+
+struct driver_stats {
+	struct net_device_stats net_stats;
+
+	unsigned long tx_late_col;
+	unsigned long tx_ok_defrd;
+	unsigned long tx_one_retry;
+	unsigned long tx_mt_one_retry;
+	unsigned long rcv_cdt_frames;
+	unsigned long xmt_fc_pkts;
+	unsigned long rcv_fc_pkts;
+	unsigned long rcv_fc_unsupported;
+	unsigned long xmt_tco_pkts;
+	unsigned long rcv_tco_pkts;
+	unsigned long rx_intr_pkts;
+};
+
+/* TODO: kill me when we can do C99 */
+#define false		(0)
+#define true		(1)
+
+/* Changed for 82558 and 82559 enhancements */
+/* defines for 82558/9 flow control CSR values */
+#define DFLT_FC_THLD       0x00	/* Rx FIFO threshold of 0.5KB free  */
+#define DFLT_FC_CMD        0x00	/* FC Command in CSR */
+
+/* ====================================================================== */
+/*                              equates                                   */
+/* ====================================================================== */
+
+/*
+ * These are general purpose defines 
+ */
+
+/* Bit Mask definitions */
+#define BIT_0       0x0001
+#define BIT_1       0x0002
+#define BIT_2       0x0004
+#define BIT_3       0x0008
+#define BIT_4       0x0010
+#define BIT_5       0x0020
+#define BIT_6       0x0040
+#define BIT_7       0x0080
+#define BIT_8       0x0100
+#define BIT_9       0x0200
+#define BIT_10      0x0400
+#define BIT_11      0x0800
+#define BIT_12      0x1000
+#define BIT_13      0x2000
+#define BIT_14      0x4000
+#define BIT_15      0x8000
+#define BIT_28      0x10000000
+
+#define BIT_0_2     0x0007
+#define BIT_0_3     0x000F
+#define BIT_0_4     0x001F
+#define BIT_0_5     0x003F
+#define BIT_0_6     0x007F
+#define BIT_0_7     0x00FF
+#define BIT_0_8     0x01FF
+#define BIT_0_13    0x3FFF
+#define BIT_0_15    0xFFFF
+#define BIT_1_2     0x0006
+#define BIT_1_3     0x000E
+#define BIT_2_5     0x003C
+#define BIT_3_4     0x0018
+#define BIT_4_5     0x0030
+#define BIT_4_6     0x0070
+#define BIT_4_7     0x00F0
+#define BIT_5_7     0x00E0
+#define BIT_5_12    0x1FE0
+#define BIT_5_15    0xFFE0
+#define BIT_6_7     0x00c0
+#define BIT_7_11    0x0F80
+#define BIT_8_10    0x0700
+#define BIT_9_13    0x3E00
+#define BIT_12_15   0xF000
+#define BIT_8_15    0xFF00
+
+#define BIT_16_20   0x001F0000
+#define BIT_21_25   0x03E00000
+#define BIT_26_27   0x0C000000
+
+/* Transmit Threshold related constants */
+#define DEFAULT_TX_PER_UNDERRUN         20000
+
+#define MAX_MULTICAST_ADDRS             64
+#define MAX_FILTER                      16
+
+#define FULL_DUPLEX      2
+#define HALF_DUPLEX      1
+
+/*
+ * These defines are specific to the 82557 
+ */
+
+/* E100 PORT functions -- lower 4 bits */
+#define PORT_SOFTWARE_RESET         0
+#define PORT_SELFTEST               1
+#define PORT_SELECTIVE_RESET        2
+#define PORT_DUMP                   3
+
+/* SCB Status Word bit definitions */
+/* Interrupt status/ack fields */
+/* ER and FCP interrupts for 82558 masks  */
+#define SCB_STATUS_ACK_MASK        BIT_8_15	/* Status Mask */
+#define SCB_STATUS_ACK_CX          BIT_15	/* CU Completed Action Cmd */
+#define SCB_STATUS_ACK_FR          BIT_14	/* RU Received A Frame */
+#define SCB_STATUS_ACK_CNA         BIT_13	/* CU Became Inactive (IDLE) */
+#define SCB_STATUS_ACK_RNR         BIT_12	/* RU Became Not Ready */
+#define SCB_STATUS_ACK_MDI         BIT_11	/* MDI read or write done */
+#define SCB_STATUS_ACK_SWI         BIT_10	/* S/W generated interrupt */
+#define SCB_STATUS_ACK_ER          BIT_9	/* Early Receive */
+#define SCB_STATUS_ACK_FCP         BIT_8	/* Flow Control Pause */
+
+/*- CUS Fields */
+#define SCB_CUS_MASK            (BIT_6 | BIT_7)	/* CUS 2-bit Mask */
+#define SCB_CUS_IDLE            0	/* CU Idle */
+#define SCB_CUS_SUSPEND         BIT_6	/* CU Suspended */
+#define SCB_CUS_ACTIVE          BIT_7	/* CU Active */
+
+/*- RUS Fields */
+#define SCB_RUS_IDLE            0	/* RU Idle */
+#define SCB_RUS_MASK            BIT_2_5	/* RUS 3-bit Mask */
+#define SCB_RUS_SUSPEND         BIT_2	/* RU Suspended */
+#define SCB_RUS_NO_RESOURCES    BIT_3	/* RU Out Of Resources */
+#define SCB_RUS_READY           BIT_4	/* RU Ready */
+#define SCB_RUS_SUSP_NO_RBDS    (BIT_2 | BIT_5)	/* RU No More RBDs */
+#define SCB_RUS_NO_RBDS         (BIT_3 | BIT_5)	/* RU No More RBDs */
+#define SCB_RUS_READY_NO_RBDS   (BIT_4 | BIT_5)	/* RU Ready, No RBDs */
+
+/* SCB Command Word bit definitions */
+/*- CUC fields */
+/* Changing mask to 4 bits */
+#define SCB_CUC_MASK            BIT_4_7	/* CUC 4-bit Mask */
+#define SCB_CUC_NOOP            0
+#define SCB_CUC_START           BIT_4	/* CU Start */
+#define SCB_CUC_RESUME          BIT_5	/* CU Resume */
+#define SCB_CUC_UNKNOWN         BIT_7	/* CU unknown command */
+/* Changed for 82558 enhancements */
+#define SCB_CUC_STATIC_RESUME   (BIT_5 | BIT_7)	/* 82558/9 Static Resume */
+#define SCB_CUC_DUMP_ADDR       BIT_6	/* CU Dump Counters Address */
+#define SCB_CUC_DUMP_STAT       (BIT_4 | BIT_6)	/* CU Dump stat. counters */
+#define SCB_CUC_LOAD_BASE       (BIT_5 | BIT_6)	/* Load the CU base */
+/* Below was defined as BIT_4_7 */
+#define SCB_CUC_DUMP_RST_STAT   BIT_4_6	/* CU Dump & reset statistics cntrs */
+
+/*- RUC fields */
+#define SCB_RUC_MASK            BIT_0_2	/* RUC 3-bit Mask */
+#define SCB_RUC_START           BIT_0	/* RU Start */
+#define SCB_RUC_RESUME          BIT_1	/* RU Resume */
+#define SCB_RUC_ABORT           BIT_2	/* RU Abort */
+#define SCB_RUC_LOAD_HDS        (BIT_0 | BIT_2)	/* Load RFD Header Data Size */
+#define SCB_RUC_LOAD_BASE       (BIT_1 | BIT_2)	/* Load the RU base */
+#define SCB_RUC_RBD_RESUME      BIT_0_2	/* RBD resume */
+
+/* Interrupt fields (assuming byte addressing) */
+#define SCB_INT_MASK            BIT_0	/* Mask interrupts */
+#define SCB_SOFT_INT            BIT_1	/* Generate a S/W interrupt */
+/*  Specific Interrupt Mask Bits (upper byte of SCB Command word) */
+#define SCB_FCP_INT_MASK        BIT_2	/* Flow Control Pause */
+#define SCB_ER_INT_MASK         BIT_3	/* Early Receive */
+#define SCB_RNR_INT_MASK        BIT_4	/* RU Not Ready */
+#define SCB_CNA_INT_MASK        BIT_5	/* CU Not Active */
+#define SCB_FR_INT_MASK         BIT_6	/* Frame Received */
+#define SCB_CX_INT_MASK         BIT_7	/* CU eXecution w/ I-bit done */
+#define SCB_BACHELOR_INT_MASK   BIT_2_7	/* 82558 interrupt mask bits */
+
+#define SCB_GCR2_EEPROM_ACCESS_SEMAPHORE BIT_7
+
+/* EEPROM bit definitions */
+/*- EEPROM control register bits */
+#define EEPROM_FLAG_ASF  0x8000
+#define EEPROM_FLAG_GCL  0x4000
+
+#define EN_TRNF          0x10	/* Enable turnoff */
+#define EEDO             0x08	/* EEPROM data out */
+#define EEDI             0x04	/* EEPROM data in (set for writing data) */
+#define EECS             0x02	/* EEPROM chip select (1=hi, 0=lo) */
+#define EESK             0x01	/* EEPROM shift clock (1=hi, 0=lo) */
+
+/*- EEPROM opcodes */
+#define EEPROM_READ_OPCODE          06
+#define EEPROM_WRITE_OPCODE         05
+#define EEPROM_ERASE_OPCODE         07
+#define EEPROM_EWEN_OPCODE          19	/* Erase/write enable */
+#define EEPROM_EWDS_OPCODE          16	/* Erase/write disable */
+
+/*- EEPROM data locations */
+#define EEPROM_NODE_ADDRESS_BYTE_0      0
+#define EEPROM_COMPATIBILITY_WORD       3
+#define EEPROM_PWA_NO                   8
+#define EEPROM_ID_WORD			0x0A
+#define EEPROM_CONFIG_ASF		0x0D
+#define EEPROM_SMBUS_ADDR		0x90
+
+#define EEPROM_SUM                      0xbaba
+
+// Zero Locking Algorithm definitions:
+#define ZLOCK_ZERO_MASK		0x00F0
+#define ZLOCK_MAX_READS		50	
+#define ZLOCK_SET_ZERO		0x2010
+#define ZLOCK_MAX_SLEEP		300 * HZ	
+#define ZLOCK_MAX_ERRORS	300
+
+/* E100 Action Commands */
+#define CB_IA_ADDRESS           1
+#define CB_CONFIGURE            2
+#define CB_MULTICAST            3
+#define CB_TRANSMIT             4
+#define CB_LOAD_MICROCODE       5
+#define CB_LOAD_FILTER		8
+#define CB_MAX_NONTX_CMD        9
+#define CB_IPCB_TRANSMIT        9
+
+/* Pre-defined Filter Bits */
+#define CB_FILTER_EL            0x80000000
+#define CB_FILTER_FIX           0x40000000
+#define CB_FILTER_ARP           0x08000000
+#define CB_FILTER_IA_MATCH      0x02000000
+
+/* Command Block (CB) Field Definitions */
+/*- CB Command Word */
+#define CB_EL_BIT           BIT_15	/* CB EL Bit */
+#define CB_S_BIT            BIT_14	/* CB Suspend Bit */
+#define CB_I_BIT            BIT_13	/* CB Interrupt Bit */
+#define CB_TX_SF_BIT        BIT_3	/* TX CB Flexible Mode */
+#define CB_CMD_MASK         BIT_0_3	/* CB 4-bit CMD Mask */
+#define CB_CID_DEFAULT      (0x1f << 8)	/* CB 5-bit CID (max value) */
+
+/*- CB Status Word */
+#define CB_STATUS_MASK          BIT_12_15	/* CB Status Mask (4-bits) */
+#define CB_STATUS_COMPLETE      BIT_15	/* CB Complete Bit */
+#define CB_STATUS_OK            BIT_13	/* CB OK Bit */
+#define CB_STATUS_VLAN          BIT_12 /* CB Valn detected Bit */
+#define CB_STATUS_FAIL          BIT_11	/* CB Fail (F) Bit */
+
+/*misc command bits */
+#define CB_TX_EOF_BIT           BIT_15	/* TX CB/TBD EOF Bit */
+
+/* Config params */
+#define CB_CFIG_BYTE_COUNT          22	/* 22 config bytes */
+#define CB_CFIG_D102_BYTE_COUNT    10
+
+/* Receive Frame Descriptor Fields */
+
+/*- RFD Status Bits */
+#define RFD_RECEIVE_COLLISION   BIT_0	/* Collision detected on Receive */
+#define RFD_IA_MATCH            BIT_1	/* Indv Address Match Bit */
+#define RFD_RX_ERR              BIT_4	/* RX_ERR pin on Phy was set */
+#define RFD_FRAME_TOO_SHORT     BIT_7	/* Receive Frame Short */
+#define RFD_DMA_OVERRUN         BIT_8	/* Receive DMA Overrun */
+#define RFD_NO_RESOURCES        BIT_9	/* No Buffer Space */
+#define RFD_ALIGNMENT_ERROR     BIT_10	/* Alignment Error */
+#define RFD_CRC_ERROR           BIT_11	/* CRC Error */
+#define RFD_STATUS_OK           BIT_13	/* RFD OK Bit */
+#define RFD_STATUS_COMPLETE     BIT_15	/* RFD Complete Bit */
+
+/*- RFD Command Bits*/
+#define RFD_EL_BIT      BIT_15	/* RFD EL Bit */
+#define RFD_S_BIT       BIT_14	/* RFD Suspend Bit */
+#define RFD_H_BIT       BIT_4	/* Header RFD Bit */
+#define RFD_SF_BIT      BIT_3	/* RFD Flexible Mode */
+
+/*- RFD misc bits*/
+#define RFD_EOF_BIT         BIT_15	/* RFD End-Of-Frame Bit */
+#define RFD_F_BIT           BIT_14	/* RFD Buffer Fetch Bit */
+#define RFD_ACT_COUNT_MASK  BIT_0_13	/* RFD Actual Count Mask */
+
+/* Receive Buffer Descriptor Fields*/
+#define RBD_EOF_BIT             BIT_15	/* RBD End-Of-Frame Bit */
+#define RBD_F_BIT               BIT_14	/* RBD Buffer Fetch Bit */
+#define RBD_ACT_COUNT_MASK      BIT_0_13	/* RBD Actual Count Mask */
+
+#define SIZE_FIELD_MASK     BIT_0_13	/* Size of the associated buffer */
+#define RBD_EL_BIT          BIT_15	/* RBD EL Bit */
+
+/* Self Test Results*/
+#define CB_SELFTEST_FAIL_BIT        BIT_12
+#define CB_SELFTEST_DIAG_BIT        BIT_5
+#define CB_SELFTEST_REGISTER_BIT    BIT_3
+#define CB_SELFTEST_ROM_BIT         BIT_2
+
+#define CB_SELFTEST_ERROR_MASK ( \
+                CB_SELFTEST_FAIL_BIT | CB_SELFTEST_DIAG_BIT | \
+                CB_SELFTEST_REGISTER_BIT | CB_SELFTEST_ROM_BIT)
+
+/* adapter vendor & device ids */
+#define PCI_OHIO_BOARD   0x10f0	/* subdevice ID, Ohio dual port nic */
+
+/* Values for PCI_REV_ID_REGISTER values */
+#define D101A4_REV_ID      4	/* 82558 A4 stepping */
+#define D101B0_REV_ID      5	/* 82558 B0 stepping */
+#define D101MA_REV_ID      8	/* 82559 A0 stepping */
+#define D101S_REV_ID      9	/* 82559S A-step */
+#define D102_REV_ID      12
+#define D102C_REV_ID     13	/* 82550 step C */
+#define D102E_REV_ID     15
+#define D102E_A1_REV_ID  16
+
+/* ############Start of 82555 specific defines################## */
+
+#define PHY_82555_LED_SWITCH_CONTROL    	0x1b	/* 82555 led switch control register */
+
+/* 82555 led switch control reg. opcodes */
+#define PHY_82555_LED_NORMAL_CONTROL    0	// control back to the 8255X
+#define PHY_82555_LED_DRIVER_CONTROL    BIT_2	// the driver is in control
+#define PHY_82555_LED_OFF               BIT_2	// activity LED is off
+#define PHY_82555_LED_ON_559           (BIT_0 | BIT_2)	// activity LED is on for 559 and later
+#define PHY_82555_LED_ON_PRE_559       (BIT_0 | BIT_1 | BIT_2)	// activity LED is on for 558 and before
+
+// Describe the state of the phy led.
+// needed for the function : 'e100_blink_timer'
+enum led_state_e {
+	LED_OFF = 0,
+	LED_ON,
+};
+
+/* ############End of 82555 specific defines##################### */
+
+#define RFD_PARSE_BIT			BIT_3
+#define RFD_TCP_PACKET			0x00
+#define RFD_UDP_PACKET			0x01
+#define TCPUDP_CHECKSUM_BIT_VALID	BIT_4
+#define TCPUDP_CHECKSUM_VALID		BIT_5
+#define CHECKSUM_PROTOCOL_MASK		0x03
+
+#define VLAN_SIZE   4
+#define CHKSUM_SIZE 2
+#define RFD_DATA_SIZE (ETH_FRAME_LEN + CHKSUM_SIZE + VLAN_SIZE)
+
+/* Bits for bdp->flags */
+#define DF_LINK_FC_CAP     0x00000001	/* Link is flow control capable */
+#define DF_CSUM_OFFLOAD    0x00000002
+#define DF_UCODE_LOADED    0x00000004
+#define USE_IPCB           0x00000008	/* set if using ipcb for transmits */
+#define IS_BACHELOR        0x00000010	/* set if 82558 or newer board */
+#define IS_ICH             0x00000020
+#define DF_SPEED_FORCED    0x00000040	/* set if speed is forced */
+#define LED_IS_ON	   0x00000080	/* LED is turned ON by the driver */
+#define DF_LINK_FC_TX_ONLY 0x00000100	/* Received PAUSE frames are honored*/
+
+typedef struct net_device_stats net_dev_stats_t;
+
+/* needed macros */
+/* These macros use the bdp pointer. If you use them it better be defined */
+#define PREV_TCB_USED(X)  ((X).tail ? (X).tail - 1 : bdp->params.TxDescriptors - 1)
+#define NEXT_TCB_TOUSE(X) ((((X) + 1) >= bdp->params.TxDescriptors) ? 0 : (X) + 1)
+#define TCB_TO_USE(X)     ((X).tail)
+#define TCBS_AVAIL(X)     (NEXT_TCB_TOUSE( NEXT_TCB_TOUSE((X).tail)) != (X).head)
+
+#define RFD_POINTER(skb,bdp)      ((rfd_t *) (((unsigned char *)((skb)->data))-((bdp)->rfd_size)))
+#define SKB_RFD_STATUS(skb,bdp)   ((RFD_POINTER((skb),(bdp)))->rfd_header.cb_status)
+
+/* ====================================================================== */
+/*                              82557                                     */
+/* ====================================================================== */
+
+/* Changed for 82558 enhancement */
+typedef struct _d101_scb_ext_t {
+	u32 scb_rx_dma_cnt;	/* Rx DMA byte count */
+	u8 scb_early_rx_int;	/* Early Rx DMA byte count */
+	u8 scb_fc_thld;	/* Flow Control threshold */
+	u8 scb_fc_xon_xoff;	/* Flow Control XON/XOFF values */
+	u8 scb_pmdr;	/* Power Mgmt. Driver Reg */
+} d101_scb_ext __attribute__ ((__packed__));
+
+/* Changed for 82559 enhancement */
+typedef struct _d101m_scb_ext_t {
+	u32 scb_rx_dma_cnt;	/* Rx DMA byte count */
+	u8 scb_early_rx_int;	/* Early Rx DMA byte count */
+	u8 scb_fc_thld;	/* Flow Control threshold */
+	u8 scb_fc_xon_xoff;	/* Flow Control XON/XOFF values */
+	u8 scb_pmdr;	/* Power Mgmt. Driver Reg */
+	u8 scb_gen_ctrl;	/* General Control */
+	u8 scb_gen_stat;	/* General Status */
+	u16 scb_reserved;	/* Reserved */
+	u32 scb_function_event;	/* Cardbus Function Event */
+	u32 scb_function_event_mask;	/* Cardbus Function Mask */
+	u32 scb_function_present_state;	/* Cardbus Function state */
+	u32 scb_force_event;	/* Cardbus Force Event */
+} d101m_scb_ext __attribute__ ((__packed__));
+
+/* Changed for 82550 enhancement */
+typedef struct _d102_scb_ext_t {
+	u32 scb_rx_dma_cnt;	/* Rx DMA byte count */
+	u8 scb_early_rx_int;	/* Early Rx DMA byte count */
+	u8 scb_fc_thld;	/* Flow Control threshold */
+	u8 scb_fc_xon_xoff;	/* Flow Control XON/XOFF values */
+	u8 scb_pmdr;	/* Power Mgmt. Driver Reg */
+	u8 scb_gen_ctrl;	/* General Control */
+	u8 scb_gen_stat;	/* General Status */
+	u8 scb_gen_ctrl2;
+	u8 scb_reserved;	/* Reserved */
+	u32 scb_scheduling_reg;
+	u32 scb_reserved2;
+	u32 scb_function_event;	/* Cardbus Function Event */
+	u32 scb_function_event_mask;	/* Cardbus Function Mask */
+	u32 scb_function_present_state;	/* Cardbus Function state */
+	u32 scb_force_event;	/* Cardbus Force Event */
+} d102_scb_ext __attribute__ ((__packed__));
+
+/*
+ * 82557 status control block. this will be memory mapped & will hang of the
+ * the bdp, which hangs of the bdp. This is the brain of it.
+ */
+typedef struct _scb_t {
+	u16 scb_status;	/* SCB Status register */
+	u8 scb_cmd_low;	/* SCB Command register (low byte) */
+	u8 scb_cmd_hi;	/* SCB Command register (high byte) */
+	u32 scb_gen_ptr;	/* SCB General pointer */
+	u32 scb_port;	/* PORT register */
+	u16 scb_flsh_cntrl;	/* Flash Control register */
+	u16 scb_eprm_cntrl;	/* EEPROM control register */
+	u32 scb_mdi_cntrl;	/* MDI Control Register */
+	/* Changed for 82558 enhancement */
+	union {
+		u32 scb_rx_dma_cnt;	/* Rx DMA byte count */
+		d101_scb_ext d101_scb;	/* 82558/9 specific fields */
+		d101m_scb_ext d101m_scb;	/* 82559 specific fields */
+		d102_scb_ext d102_scb;
+	} scb_ext;
+} scb_t __attribute__ ((__packed__));
+
+/* Self test
+ * This is used to dump results of the self test 
+ */
+typedef struct _self_test_t {
+	u32 st_sign;	/* Self Test Signature */
+	u32 st_result;	/* Self Test Results */
+} self_test_t __attribute__ ((__packed__));
+
+/* 
+ *  Statistical Counters 
+ */
+/* 82557 counters */
+typedef struct _basic_cntr_t {
+	u32 xmt_gd_frames;	/* Good frames transmitted */
+	u32 xmt_max_coll;	/* Fatal frames -- had max collisions */
+	u32 xmt_late_coll;	/* Fatal frames -- had a late coll. */
+	u32 xmt_uruns;	/* Xmit underruns (fatal or re-transmit) */
+	u32 xmt_lost_crs;	/* Frames transmitted without CRS */
+	u32 xmt_deferred;	/* Deferred transmits */
+	u32 xmt_sngl_coll;	/* Transmits that had 1 and only 1 coll. */
+	u32 xmt_mlt_coll;	/* Transmits that had multiple coll. */
+	u32 xmt_ttl_coll;	/* Transmits that had 1+ collisions. */
+	u32 rcv_gd_frames;	/* Good frames received */
+	u32 rcv_crc_errs;	/* Aligned frames that had a CRC error */
+	u32 rcv_algn_errs;	/* Receives that had alignment errors */
+	u32 rcv_rsrc_err;	/* Good frame dropped cuz no resources */
+	u32 rcv_oruns;	/* Overrun errors - bus was busy */
+	u32 rcv_err_coll;	/* Received frms. that encountered coll. */
+	u32 rcv_shrt_frames;	/* Received frames that were to short */
+} basic_cntr_t;
+
+/* 82558 extended statistic counters */
+typedef struct _ext_cntr_t {
+	u32 xmt_fc_frames;
+	u32 rcv_fc_frames;
+	u32 rcv_fc_unsupported;
+} ext_cntr_t;
+
+/* 82559 TCO statistic counters */
+typedef struct _tco_cntr_t {
+	u16 xmt_tco_frames;
+	u16 rcv_tco_frames;
+} tco_cntr_t;
+
+/* Structures to access thet physical dump area */
+/* Use one of these types, according to the statisitcal counters mode,
+   to cast the pointer to the physical dump area and access the cmd_complete
+   DWORD. */
+
+/* 557-mode : only basic counters + cmd_complete */
+typedef struct _err_cntr_557_t {
+	basic_cntr_t basic_stats;
+	u32 cmd_complete;
+} err_cntr_557_t;
+
+/* 558-mode : basic + extended counters + cmd_complete */
+typedef struct _err_cntr_558_t {
+	basic_cntr_t basic_stats;
+	ext_cntr_t extended_stats;
+	u32 cmd_complete;
+} err_cntr_558_t;
+
+/* 559-mode : basic + extended + TCO counters + cmd_complete */
+typedef struct _err_cntr_559_t {
+	basic_cntr_t basic_stats;
+	ext_cntr_t extended_stats;
+	tco_cntr_t tco_stats;
+	u32 cmd_complete;
+} err_cntr_559_t;
+
+/* This typedef defines the struct needed to hold the largest number of counters */
+typedef err_cntr_559_t max_counters_t;
+
+/* Different statistical-counters mode the controller may be in */
+typedef enum _stat_mode_t {
+	E100_BASIC_STATS = 0,	/* 82557 stats : 16 counters / 16 dw */
+	E100_EXTENDED_STATS,	/* 82558 stats : 19 counters / 19 dw */
+	E100_TCO_STATS		/* 82559 stats : 21 counters / 20 dw */
+} stat_mode_t;
+
+/* dump statistical counters complete codes */
+#define DUMP_STAT_COMPLETED	0xA005
+#define DUMP_RST_STAT_COMPLETED	0xA007
+
+/* Command Block (CB) Generic Header Structure*/
+typedef struct _cb_header_t {
+	u16 cb_status;	/* Command Block Status */
+	u16 cb_cmd;	/* Command Block Command */
+	u32 cb_lnk_ptr;	/* Link To Next CB */
+} cb_header_t __attribute__ ((__packed__));
+
+//* Individual Address Command Block (IA_CB)*/
+typedef struct _ia_cb_t {
+	cb_header_t ia_cb_hdr;
+	u8 ia_addr[ETH_ALEN];
+} ia_cb_t __attribute__ ((__packed__));
+
+/* Configure Command Block (CONFIG_CB)*/
+typedef struct _config_cb_t {
+	cb_header_t cfg_cbhdr;
+	u8 cfg_byte[CB_CFIG_BYTE_COUNT + CB_CFIG_D102_BYTE_COUNT];
+} config_cb_t __attribute__ ((__packed__));
+
+/* MultiCast Command Block (MULTICAST_CB)*/
+typedef struct _multicast_cb_t {
+	cb_header_t mc_cbhdr;
+	u16 mc_count;	/* Number of multicast addresses */
+	u8 mc_addr[(ETH_ALEN * MAX_MULTICAST_ADDRS)];
+} mltcst_cb_t __attribute__ ((__packed__));
+
+#define UCODE_MAX_DWORDS	134
+/* Load Microcode Command Block (LOAD_UCODE_CB)*/
+typedef struct _load_ucode_cb_t {
+	cb_header_t load_ucode_cbhdr;
+	u32 ucode_dword[UCODE_MAX_DWORDS];
+} load_ucode_cb_t __attribute__ ((__packed__));
+
+/* Load Programmable Filter Data*/
+typedef struct _filter_cb_t {
+	cb_header_t filter_cb_hdr;
+	u32 filter_data[MAX_FILTER];
+} filter_cb_t __attribute__ ((__packed__));
+
+/* NON_TRANSMIT_CB -- Generic Non-Transmit Command Block 
+ */
+typedef struct _nxmit_cb_t {
+	union {
+		config_cb_t config;
+		ia_cb_t setup;
+		load_ucode_cb_t load_ucode;
+		mltcst_cb_t multicast;
+		filter_cb_t filter;
+	} ntcb;
+} nxmit_cb_t __attribute__ ((__packed__));
+
+/*Block for queuing for postponed execution of the non-transmit commands*/
+typedef struct _nxmit_cb_entry_t {
+	struct list_head list_elem;
+	nxmit_cb_t *non_tx_cmd;
+	dma_addr_t dma_addr;
+	unsigned long expiration_time;
+} nxmit_cb_entry_t;
+
+/* States for postponed non tx commands execution */
+typedef enum _non_tx_cmd_state_t {
+	E100_NON_TX_IDLE = 0,	/* No queued NON-TX commands */
+	E100_WAIT_TX_FINISH,	/* Wait for completion of the TX activities */
+	E100_WAIT_NON_TX_FINISH	/* Wait for completion of the non TX command */
+} non_tx_cmd_state_t;
+
+/* some defines for the ipcb */
+#define IPCB_IP_CHECKSUM_ENABLE 	BIT_4
+#define IPCB_TCPUDP_CHECKSUM_ENABLE	BIT_5
+#define IPCB_TCP_PACKET 		BIT_6
+#define IPCB_LARGESEND_ENABLE 		BIT_7
+#define IPCB_HARDWAREPARSING_ENABLE	BIT_0
+#define IPCB_INSERTVLAN_ENABLE 		BIT_1
+#define IPCB_IP_ACTIVATION_DEFAULT      IPCB_HARDWAREPARSING_ENABLE
+
+/* Transmit Buffer Descriptor (TBD)*/
+typedef struct _tbd_t {
+	u32 tbd_buf_addr;	/* Physical Transmit Buffer Address */
+	u16 tbd_buf_cnt;	/* Actual Count Of Bytes */
+	u16 padd;
+} tbd_t __attribute__ ((__packed__));
+
+/* d102 specific fields */
+typedef struct _tcb_ipcb_t {
+	u16 schedule_low;
+	u8 ip_schedule;
+	u8 ip_activation_high;
+	u16 vlan;
+	u8 ip_header_offset;
+	u8 tcp_header_offset;
+	union {
+		u32 sec_rec_phys_addr;
+		u32 tbd_zero_address;
+	} tbd_sec_addr;
+	union {
+		u16 sec_rec_size;
+		u16 tbd_zero_size;
+	} tbd_sec_size;
+	u16 total_tcp_payload;
+} tcb_ipcb_t __attribute__ ((__packed__));
+
+#ifdef MAX_SKB_FRAGS
+#define E100_TBD_ARRAY_SIZE (2+MAX_SKB_FRAGS)
+#else
+#define E100_TBD_ARRAY_SIZE 2
+#endif /*MAX_SKB_FRAGS */
+
+/* Transmit Command Block (TCB)*/
+struct _tcb_t {
+	cb_header_t tcb_hdr;
+	u32 tcb_tbd_ptr;	/* TBD address */
+	u16 tcb_cnt;	/* Data Bytes In TCB past header */
+	u8 tcb_thrshld;	/* TX Threshold for FIFO Extender */
+	u8 tcb_tbd_num;
+
+	union {
+		tcb_ipcb_t ipcb;	/* d102 ipcb fields */
+		tbd_t tbd_array[E100_TBD_ARRAY_SIZE];
+	} tcbu;
+
+	/* From here onward we can dump anything we want as long as the
+	 * size of the total structure is a multiple of a paragraph
+	 * boundary ( i.e. -16 bit aligned ).
+	 */
+	tbd_t *tbd_ptr;
+
+#ifdef MAX_SKB_FRAGS
+	u32 tcb_tbd_dflt_ptr;	/* TBD address for non-segmented packet */
+	u32 tcb_tbd_expand_ptr;	/* TBD address for segmented packet */
+#endif				/*MAX_SKB_FRAGS */
+
+	struct sk_buff *tcb_skb;	/* the associated socket buffer */
+	dma_addr_t tcb_phys;	/* phys addr of the TCB */
+} __attribute__ ((__packed__));
+
+#ifndef _TCB_T_
+#define _TCB_T_
+typedef struct _tcb_t tcb_t;
+#endif
+
+/* Receive Frame Descriptor (RFD) - will be using the simple model*/
+struct _rfd_t {
+	/* 8255x */
+	cb_header_t rfd_header;
+	u32 rfd_rbd_ptr;	/* Receive Buffer Descriptor Addr */
+	u16 rfd_act_cnt;	/* Number Of Bytes Received */
+	u16 rfd_sz;	/* Number Of Bytes In RFD */
+	/* D102 aka Gamla */
+	u16 vlanid;
+	u8 rcvparserstatus;
+	u8 reserved;
+	u16 securitystatus;
+	u8 checksumstatus;
+	u8 zerocopystatus;
+	u8 pad[8];	/* data should be 16 byte aligned */
+	u8 data[RFD_DATA_SIZE];
+
+} __attribute__ ((__packed__));
+
+#ifndef _RFD_T_
+#define _RFD_T_
+typedef struct _rfd_t rfd_t;
+#endif
+
+/* Receive Buffer Descriptor (RBD)*/
+typedef struct _rbd_t {
+	u16 rbd_act_cnt;	/* Number Of Bytes Received */
+	u16 rbd_filler;
+	u32 rbd_lnk_addr;	/* Link To Next RBD */
+	u32 rbd_rcb_addr;	/* Receive Buffer Address */
+	u16 rbd_sz;	/* Receive Buffer Size */
+	u16 rbd_filler1;
+} rbd_t __attribute__ ((__packed__));
+
+/*
+ * This structure is used to maintain a FIFO access to a resource that is 
+ * maintained as a circular queue. The resource to be maintained is pointed
+ * to by the "data" field in the structure below. In this driver the TCBs', 
+ * TBDs' & RFDs' are maintained  as a circular queue & are managed thru this
+ * structure.
+ */
+typedef struct _buf_pool_t {
+	unsigned int head;	/* index to first used resource */
+	unsigned int tail;	/* index to last used resource */
+	void *data;		/* points to resource pool */
+} buf_pool_t;
+
+/*Rx skb holding structure*/
+struct rx_list_elem {
+	struct list_head list_elem;
+	dma_addr_t dma_addr;
+	struct sk_buff *skb;
+};
+
+enum next_cu_cmd_e { RESUME_NO_WAIT = 0, RESUME_WAIT, START_WAIT };
+enum zlock_state_e { ZLOCK_INITIAL, ZLOCK_READING, ZLOCK_SLEEPING };
+enum tx_queue_stop_type { LONG_STOP = 0, SHORT_STOP };
+
+/* 64 bit aligned size */
+#define E100_SIZE_64A(X) ((sizeof(X) + 7) & ~0x7)
+
+typedef struct _bd_dma_able_t {
+	char selftest[E100_SIZE_64A(self_test_t)];
+	char stats_counters[E100_SIZE_64A(max_counters_t)];
+} bd_dma_able_t;
+
+/* bit masks for bool parameters */
+#define PRM_XSUMRX       0x00000001
+#define PRM_UCODE        0x00000002
+#define PRM_FC           0x00000004
+#define PRM_IFS          0x00000008
+#define PRM_BUNDLE_SMALL 0x00000010
+
+struct cfg_params {
+	int e100_speed_duplex;
+	int RxDescriptors;
+	int TxDescriptors;
+	int IntDelay;
+	int BundleMax;
+	int ber;
+	u32 b_params;
+};
+#ifdef ETHTOOL_TEST 
+struct ethtool_lpbk_data{
+        dma_addr_t dma_handle;
+        tcb_t *tcb;
+        rfd_t *rfd;
+
+};
+#endif
+
+struct e100_private {
+#ifdef NETIF_F_HW_VLAN_TX
+	struct vlan_group *vlgrp;
+#endif
+	u32 flags;		/* board management flags */
+	u32 tx_per_underrun;	/* number of good tx frames per underrun */
+	unsigned int tx_count;	/* count of tx frames, so we can request an interrupt */
+	u8 tx_thld;		/* stores transmit threshold */
+	u16 eeprom_size;
+	u32 pwa_no;		/* PWA: xxxxxx-0xx */
+	u8 perm_node_address[ETH_ALEN];
+	struct list_head active_rx_list;	/* list of rx buffers */
+	struct list_head rx_struct_pool;	/* pool of rx buffer struct headers */
+	u16 rfd_size;			/* size of the adapter's RFD struct */
+	int skb_req;			/* number of skbs neede by the adapter */
+	u8 intr_mask;			/* mask for interrupt status */
+
+	void *dma_able;			/* dma allocated structs */
+	dma_addr_t dma_able_phys;
+	self_test_t *selftest;		/* pointer to self test area */
+	dma_addr_t selftest_phys;	/* phys addr of selftest */
+	max_counters_t *stats_counters;	/* pointer to stats table */
+	dma_addr_t stat_cnt_phys;	/* phys addr of stat counter area */
+
+	stat_mode_t stat_mode;	/* statistics mode: extended, TCO, basic */
+	scb_t *scb;		/* memory mapped ptr to 82557 scb */
+
+	tcb_t *last_tcb;	/* pointer to last tcb sent */
+	buf_pool_t tcb_pool;	/* adapter's TCB array */
+	dma_addr_t tcb_phys;	/* phys addr of start of TCBs */
+
+	u16 cur_line_speed;
+	u16 cur_dplx_mode;
+
+	struct net_device *device;
+	struct pci_dev *pdev;
+	struct driver_stats drv_stats;
+
+	u8 rev_id;		/* adapter PCI revision ID */
+
+	unsigned int phy_addr;	/* address of PHY component */
+	unsigned int PhyId;	/* ID of PHY component */
+	unsigned int PhyState;	/* state for the fix squelch algorithm */
+	unsigned int PhyDelay;	/* delay for the fix squelch algorithm */
+
+	/* Lock defintions for the driver */
+	spinlock_t bd_lock;		/* board lock */
+	spinlock_t bd_non_tx_lock;	/* Non transmit command lock  */
+	spinlock_t config_lock;		/* config block lock */
+	spinlock_t mdi_access_lock;	/* mdi lock */
+
+	struct timer_list watchdog_timer;	/* watchdog timer id */
+
+	/* non-tx commands parameters */
+	struct timer_list nontx_timer_id;	/* non-tx timer id */
+	struct list_head non_tx_cmd_list;
+	non_tx_cmd_state_t non_tx_command_state;
+	nxmit_cb_entry_t *same_cmd_entry[CB_MAX_NONTX_CMD];
+
+	enum next_cu_cmd_e next_cu_cmd;
+
+	/* Zero Locking Algorithm data members */
+	enum zlock_state_e zlock_state;
+	u8 zlock_read_data[16];	/* number of times each value 0-15 was read */
+	u16 zlock_read_cnt;	/* counts number of reads */
+	ulong zlock_sleep_cnt;	/* keeps track of "sleep" time */
+
+	u8 config[CB_CFIG_BYTE_COUNT + CB_CFIG_D102_BYTE_COUNT];
+
+	/* IFS params */
+	u8 ifs_state;
+	u8 ifs_value;
+
+	struct cfg_params params;	/* adapter's command line parameters */
+
+	u32 speed_duplex_caps;	/* adapter's speed/duplex capabilities */
+
+	/* WOL params for ethtool */
+	u32 wolsupported;
+	u32 wolopts;
+	u16 ip_lbytes;
+#ifdef ETHTOOL_TEST 
+	struct ethtool_lpbk_data loopback;
+#endif
+#ifdef ETHTOOL_PHYS_ID
+	struct timer_list blink_timer;	/* led blink timer id */
+#endif
+
+#ifdef CONFIG_PM
+	u32 pci_state[16];
+#endif
+#ifdef E100_CU_DEBUG	
+	u8 last_cmd;
+	u8 last_sub_cmd;
+#endif	
+};
+
+#define E100_AUTONEG        0
+#define E100_SPEED_10_HALF  1
+#define E100_SPEED_10_FULL  2
+#define E100_SPEED_100_HALF 3
+#define E100_SPEED_100_FULL 4
+
+/********* function prototypes *************/
+extern int e100_open(struct net_device *);
+extern int e100_close(struct net_device *);
+extern void e100_isolate_driver(struct e100_private *bdp);
+extern unsigned char e100_hw_init(struct e100_private *);
+extern void e100_sw_reset(struct e100_private *bdp, u32 reset_cmd);
+extern u8 e100_start_cu(struct e100_private *bdp, tcb_t *tcb);
+extern void e100_free_non_tx_cmd(struct e100_private *bdp,
+				 nxmit_cb_entry_t *non_tx_cmd);
+extern nxmit_cb_entry_t *e100_alloc_non_tx_cmd(struct e100_private *bdp);
+extern unsigned char e100_exec_non_cu_cmd(struct e100_private *bdp,
+					  nxmit_cb_entry_t *cmd);
+extern unsigned char e100_selftest(struct e100_private *bdp, u32 *st_timeout,
+				   u32 *st_result);
+extern unsigned char e100_get_link_state(struct e100_private *bdp);
+extern unsigned char e100_wait_scb(struct e100_private *bdp);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20)
+#ifndef yield /* RH 2.4.18-3 has yield, which is not defined in standard Linux */
+#define yield()					\
+        do {					\
+                current->policy |= SCHED_YIELD;	\
+                schedule();			\
+        } while (0)                                     
+#endif
+#endif
+
+extern void e100_deisolate_driver(struct e100_private *bdp, u8 full_reset);
+extern unsigned char e100_configure_device(struct e100_private *bdp);
+#ifdef E100_CU_DEBUG
+extern unsigned char e100_cu_unknown_state(struct e100_private *bdp);
+#endif
+
+#ifdef ETHTOOL_TEST
+
+#define ROM_TEST_FAIL		0x01
+#define REGISTER_TEST_FAIL	0x02
+#define SELF_TEST_FAIL		0x04
+#define TEST_TIMEOUT		0x08
+
+enum test_offsets {
+	test_link,
+	test_eeprom,
+	test_self_test,
+	test_loopback_mac,
+	test_loopback_phy,
+	cable_diag,
+	max_test_res,  /* must be last */
+};
+#endif
+
+#endif
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_config.c linux-2.6.5.SUSE/drivers/net/e100-intel/e100_config.c
--- linux-2.6.5/drivers/net/e100-intel/e100_config.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_config.c	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,639 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  e100_config.c                                         *
+*                                                                     *
+* Abstract:     Functions for configuring the network adapter.        *
+*                                                                     *
+* Environment:  This file is intended to be specific to the Linux     *
+*               operating system.                                     *
+*                                                                     *
+**********************************************************************/
+#include "e100_config.h"
+
+static void e100_config_long_rx(struct e100_private *bdp, unsigned char enable);
+
+static const u8 def_config[] = {
+	CB_CFIG_BYTE_COUNT,
+	0x08, 0x00, 0x00, 0x00, 0x00, 0x32, 0x07, 0x01,
+	0x00, 0x2e, 0x00, 0x60, 0x00, 0xf2, 0xc8, 0x00,
+	0x40, 0xf2, 0x80, 0x3f, 0x05
+};
+
+/**
+ * e100_config_init_82557 - config the 82557 adapter
+ * @bdp: atapter's private data struct
+ *
+ * This routine will initialize the 82557 configure block.
+ * All other init functions will only set values that are
+ * different from the 82557 default.
+ */
+void
+e100_config_init_82557(struct e100_private *bdp)
+{
+	/* initialize config block */
+	memcpy(bdp->config, def_config, sizeof (def_config));
+	bdp->config[0] = CB_CFIG_BYTE_COUNT;	/* just in case */
+
+	e100_config_ifs(bdp);
+
+	/*
+	 * Enable extended statistical counters (82558 and up) and TCO counters
+	 * (82559 and up) and set the statistical counters' mode in bdp 
+	 *  
+	 *  stat. mode      |    TCO stat. bit (2)  |  Extended stat. bit (5)
+	 * ------------------------------------------------------------------
+	 *  Basic (557)     |       0               |         1
+	 * ------------------------------------------------------------------
+	 *  Extended (558)  |       0               |         0
+	 * ------------------------------------------------------------------
+	 *  TCO (559)       |       1               |         1
+	 * ------------------------------------------------------------------
+	 *  Reserved        |       1               |         0
+	 * ------------------------------------------------------------------
+	 */
+	bdp->config[6] &= ~CB_CFIG_TCO_STAT;
+	bdp->config[6] |= CB_CFIG_EXT_STAT_DIS;
+	bdp->stat_mode = E100_BASIC_STATS;
+
+	/* Setup for MII or 503 operation.  The CRS+CDT bit should only be set */
+	/* when operating in 503 mode. */
+	if (bdp->phy_addr == 32) {
+		bdp->config[8] &= ~CB_CFIG_503_MII;
+		bdp->config[15] |= CB_CFIG_CRS_OR_CDT;
+	} else {
+		bdp->config[8] |= CB_CFIG_503_MII;
+		bdp->config[15] &= ~CB_CFIG_CRS_OR_CDT;
+	}
+
+	e100_config_fc(bdp);
+	e100_config_force_dplx(bdp);
+	e100_config_promisc(bdp, false);
+	e100_config_mulcast_enbl(bdp, false);
+}
+
+static void
+e100_config_init_82558(struct e100_private *bdp)
+{
+	/* MWI enable. This should be turned on only if the adapter is a 82558/9
+	 * and if the PCI command reg. has enabled the MWI bit. */
+	bdp->config[3] |= CB_CFIG_MWI_EN;
+
+	bdp->config[6] &= ~CB_CFIG_EXT_TCB_DIS;
+
+	if (bdp->rev_id >= D101MA_REV_ID) {
+		/* this is 82559 and up - enable TCO counters */
+		bdp->config[6] |= CB_CFIG_TCO_STAT;
+		bdp->config[6] |= CB_CFIG_EXT_STAT_DIS;
+		bdp->stat_mode = E100_TCO_STATS;
+
+		if ((bdp->rev_id < D102_REV_ID) &&
+		    (bdp->params.b_params & PRM_XSUMRX) &&
+		    (bdp->pdev->device != 0x1209)) {
+
+			bdp->flags |= DF_CSUM_OFFLOAD;
+			bdp->config[9] |= 1;
+		}
+	} else {
+		/* this is 82558 */
+		bdp->config[6] &= ~CB_CFIG_TCO_STAT;
+		bdp->config[6] &= ~CB_CFIG_EXT_STAT_DIS;
+		bdp->stat_mode = E100_EXTENDED_STATS;
+	}
+
+	e100_config_long_rx(bdp, true);
+}
+
+static void
+e100_config_init_82550(struct e100_private *bdp)
+{
+	/* The D102 chip allows for 32 config bytes.  This value is
+	 * supposed to be in Byte 0.  Just add the extra bytes to
+	 * what was already setup in the block. */
+	bdp->config[0] += CB_CFIG_D102_BYTE_COUNT;
+
+	/* now we need to enable the extended RFD.  When this is
+	 * enabled, the immediated receive data buffer starts at offset
+	 * 32 from the RFD base address, instead of at offset 16. */
+	bdp->config[7] |= CB_CFIG_EXTENDED_RFD;
+
+	/* put the chip into D102 receive mode.  This is necessary
+	 * for any parsing and offloading features. */
+	bdp->config[22] = CB_CFIG_RECEIVE_GAMLA_MODE;
+
+	/* set the flag if checksum offloading was enabled */
+	if (bdp->params.b_params & PRM_XSUMRX) {
+		bdp->flags |= DF_CSUM_OFFLOAD;
+	}
+}
+
+/* Initialize the adapter's configure block */
+void
+e100_config_init(struct e100_private *bdp)
+{
+	e100_config_init_82557(bdp);
+
+	if (bdp->flags & IS_BACHELOR)
+		e100_config_init_82558(bdp);
+
+	if (bdp->rev_id >= D102_REV_ID)
+		e100_config_init_82550(bdp);
+}
+
+/**
+ * e100_force_config - force a configure command
+ * @bdp: atapter's private data struct
+ *
+ * This routine will force a configure command to the adapter.
+ * The command will be executed in polled mode as interrupts
+ * are _disabled_ at this time.
+ *
+ * Returns:
+ *      true: if the configure command was successfully issued and completed
+ *      false: otherwise
+ */
+unsigned char
+e100_force_config(struct e100_private *bdp)
+{
+	spin_lock_bh(&(bdp->config_lock));
+
+	bdp->config[0] = CB_CFIG_BYTE_COUNT;
+	if (bdp->rev_id >= D102_REV_ID) {
+		/* The D102 chip allows for 32 config bytes.  This value is
+		   supposed to be in Byte 0.  Just add the extra bytes to
+		   what was already setup in the block. */
+		bdp->config[0] += CB_CFIG_D102_BYTE_COUNT;
+	}
+
+	spin_unlock_bh(&(bdp->config_lock));
+
+	// although we call config outside the lock, there is no
+	// race condition because config byte count has maximum value
+	return e100_config(bdp);
+}
+
+/**
+ * e100_config - issue a configure command
+ * @bdp: atapter's private data struct
+ *
+ * This routine will issue a configure command to the 82557.
+ * This command will be executed in polled mode as interrupts
+ * are _disabled_ at this time.
+ *
+ * Returns:
+ *      true: if the configure command was successfully issued and completed
+ *      false: otherwise
+ */
+unsigned char
+e100_config(struct e100_private *bdp)
+{
+	cb_header_t *pntcb_hdr;
+	unsigned char res = true;
+	nxmit_cb_entry_t *cmd;
+
+	if (bdp->config[0] == 0) {
+		goto exit;
+	}
+
+	if ((cmd = e100_alloc_non_tx_cmd(bdp)) == NULL) {
+		res = false;
+		goto exit;
+	}
+
+	pntcb_hdr = (cb_header_t *) cmd->non_tx_cmd;
+	pntcb_hdr->cb_cmd = __constant_cpu_to_le16(CB_CONFIGURE);
+
+	spin_lock_bh(&bdp->config_lock);
+
+	if (bdp->config[0] < CB_CFIG_MIN_PARAMS) {
+		bdp->config[0] = CB_CFIG_MIN_PARAMS;
+	}
+
+	/* Copy the device's config block to the device's memory */
+	memcpy(cmd->non_tx_cmd->ntcb.config.cfg_byte, bdp->config,
+	       bdp->config[0]);
+	/* reset number of bytes to config next time */
+	bdp->config[0] = 0;
+
+	spin_unlock_bh(&bdp->config_lock);
+
+	res = e100_exec_non_cu_cmd(bdp, cmd);
+
+exit:
+	if (netif_running(bdp->device))
+		netif_wake_queue(bdp->device);
+	return res;
+}
+
+/**
+ * e100_config_fc - config flow-control state
+ * @bdp: adapter's private data struct
+ *
+ * This routine will enable or disable flow control support in the adapter's
+ * config block. Flow control will be enable only if requested using the command
+ * line option, and if the link is flow-contorl capable (both us and the link
+ * partner). But, if link partner is capable of autoneg, but not capable of
+ * flow control, received PAUSE	frames are still honored.
+ */
+void
+e100_config_fc(struct e100_private *bdp)
+{
+	unsigned char enable = false;
+	/* 82557 doesn't support fc. Don't touch this option */
+	if (!(bdp->flags & IS_BACHELOR))
+		return;
+
+	/* Enable fc if requested and if the link supports it */
+	if ((bdp->params.b_params & PRM_FC) && (bdp->flags & 
+		(DF_LINK_FC_CAP | DF_LINK_FC_TX_ONLY))) {
+		enable = true;
+	}
+
+	spin_lock_bh(&(bdp->config_lock));
+
+	if (enable) {
+		if (bdp->flags & DF_LINK_FC_TX_ONLY) {
+			/* If link partner is capable of autoneg, but  */
+			/* not capable of flow control, Received PAUSE */
+			/* frames are still honored, i.e.,             */
+			/* transmitted frames would be paused by       */
+			/* incoming PAUSE frames                       */
+			bdp->config[16] = DFLT_NO_FC_DELAY_LSB;
+			bdp->config[17] = DFLT_NO_FC_DELAY_MSB;
+			bdp->config[19] &= ~(CB_CFIG_FC_RESTOP | CB_CFIG_FC_RESTART);
+			bdp->config[19] |= CB_CFIG_FC_REJECT;
+			bdp->config[19] &= ~CB_CFIG_TX_FC_DIS;
+		} else {
+			bdp->config[16] = DFLT_FC_DELAY_LSB;
+			bdp->config[17] = DFLT_FC_DELAY_MSB;
+			bdp->config[19] |= CB_CFIG_FC_OPTS;
+			bdp->config[19] &= ~CB_CFIG_TX_FC_DIS;
+		}
+	} else {
+		bdp->config[16] = DFLT_NO_FC_DELAY_LSB;
+		bdp->config[17] = DFLT_NO_FC_DELAY_MSB;
+		bdp->config[19] &= ~CB_CFIG_FC_OPTS;
+		bdp->config[19] |= CB_CFIG_TX_FC_DIS;
+	}
+	E100_CONFIG(bdp, 19);
+	spin_unlock_bh(&(bdp->config_lock));
+
+	return;
+}
+
+/**
+ * e100_config_promisc - configure promiscuous mode
+ * @bdp: atapter's private data struct
+ * @enable: should we enable this option or not
+ *
+ * This routine will enable or disable promiscuous mode
+ * in the adapter's config block.
+ */
+void
+e100_config_promisc(struct e100_private *bdp, unsigned char enable)
+{
+	spin_lock_bh(&(bdp->config_lock));
+
+	/* if in promiscuous mode, save bad frames */
+	if (enable) {
+
+		if (!(bdp->config[6] & CB_CFIG_SAVE_BAD_FRAMES)) {
+			bdp->config[6] |= CB_CFIG_SAVE_BAD_FRAMES;
+			E100_CONFIG(bdp, 6);
+		}
+
+		if (bdp->config[7] & (u8) BIT_0) {
+			bdp->config[7] &= (u8) (~BIT_0);
+			E100_CONFIG(bdp, 7);
+		}
+
+		if (!(bdp->config[15] & CB_CFIG_PROMISCUOUS)) {
+			bdp->config[15] |= CB_CFIG_PROMISCUOUS;
+			E100_CONFIG(bdp, 15);
+		}
+
+	} else {		/* not in promiscuous mode */
+
+		if (bdp->config[6] & CB_CFIG_SAVE_BAD_FRAMES) {
+			bdp->config[6] &= ~CB_CFIG_SAVE_BAD_FRAMES;
+			E100_CONFIG(bdp, 6);
+		}
+
+		if (!(bdp->config[7] & (u8) BIT_0)) {
+			bdp->config[7] |= (u8) (BIT_0);
+			E100_CONFIG(bdp, 7);
+		}
+
+		if (bdp->config[15] & CB_CFIG_PROMISCUOUS) {
+			bdp->config[15] &= ~CB_CFIG_PROMISCUOUS;
+			E100_CONFIG(bdp, 15);
+		}
+	}
+
+	spin_unlock_bh(&(bdp->config_lock));
+}
+
+/**
+ * e100_config_mulcast_enbl - configure allmulti mode
+ * @bdp: atapter's private data struct
+ * @enable: should we enable this option or not
+ *
+ * This routine will enable or disable reception of all multicast packets
+ * in the adapter's config block.
+ */
+void
+e100_config_mulcast_enbl(struct e100_private *bdp, unsigned char enable)
+{
+	spin_lock_bh(&(bdp->config_lock));
+
+	/* this flag is used to enable receiving all multicast packet */
+	if (enable) {
+		if (!(bdp->config[21] & CB_CFIG_MULTICAST_ALL)) {
+			bdp->config[21] |= CB_CFIG_MULTICAST_ALL;
+			E100_CONFIG(bdp, 21);
+		}
+
+	} else {
+		if (bdp->config[21] & CB_CFIG_MULTICAST_ALL) {
+			bdp->config[21] &= ~CB_CFIG_MULTICAST_ALL;
+			E100_CONFIG(bdp, 21);
+		}
+	}
+
+	spin_unlock_bh(&(bdp->config_lock));
+}
+
+/**
+ * e100_config_ifs - configure the IFS parameter
+ * @bdp: atapter's private data struct
+ *
+ * This routine will configure the adaptive IFS value
+ * in the adapter's config block. IFS values are only
+ * relevant in half duplex, so set to 0 in full duplex.
+ */
+void
+e100_config_ifs(struct e100_private *bdp)
+{
+	u8 value = 0;
+
+	spin_lock_bh(&(bdp->config_lock));
+
+	/* IFS value is only needed to be specified at half-duplex mode */
+	if (bdp->cur_dplx_mode == HALF_DUPLEX) {
+		value = (u8) bdp->ifs_value;
+	}
+
+	if (bdp->config[2] != value) {
+		bdp->config[2] = value;
+		E100_CONFIG(bdp, 2);
+	}
+
+	spin_unlock_bh(&(bdp->config_lock));
+}
+
+/**
+ * e100_config_force_dplx - configure the forced full duplex mode
+ * @bdp: atapter's private data struct
+ *
+ * This routine will enable or disable force full duplex
+ * in the adapter's config block. If the PHY is 503, and
+ * the duplex is full, consider the adapter forced.
+ */
+void
+e100_config_force_dplx(struct e100_private *bdp)
+{
+	spin_lock_bh(&(bdp->config_lock));
+
+	/* We must force full duplex on if we are using PHY 0, and we are */
+	/* supposed to run in FDX mode. We do this because the e100 has only */
+	/* one FDX# input pin, and that pin will be connected to PHY 1. */
+	/* Changed the 'if' condition below to fix performance problem * at 10
+	 * full. The Phy was getting forced to full duplex while the MAC * was
+	 * not, because the cur_dplx_mode was not being set to 2 by SetupPhy. *
+	 * This is how the condition was, initially. * This has been changed so
+	 * that the MAC gets forced to full duplex * simply if the user has
+	 * forced full duplex. * * if (( bdp->phy_addr == 0 ) && (
+	 * bdp->cur_dplx_mode == 2 )) */
+	/* The rest of the fix is in the PhyDetect code. */
+	if ((bdp->params.e100_speed_duplex == E100_SPEED_10_FULL) ||
+	    (bdp->params.e100_speed_duplex == E100_SPEED_100_FULL) ||
+	    ((bdp->phy_addr == 32) && (bdp->cur_dplx_mode == FULL_DUPLEX))) {
+		if (!(bdp->config[19] & (u8) CB_CFIG_FORCE_FDX)) {
+			bdp->config[19] |= (u8) CB_CFIG_FORCE_FDX;
+			E100_CONFIG(bdp, 19);
+		}
+
+	} else {
+		if (bdp->config[19] & (u8) CB_CFIG_FORCE_FDX) {
+			bdp->config[19] &= (u8) (~CB_CFIG_FORCE_FDX);
+			E100_CONFIG(bdp, 19);
+		}
+	}
+
+	spin_unlock_bh(&(bdp->config_lock));
+}
+
+/**
+ * e100_config_long_rx
+ * @bdp: atapter's private data struct
+ * @enable: should we enable this option or not
+ *
+ * This routine will enable or disable reception of larger packets.
+ * This is needed by VLAN implementations.
+ */
+static void
+e100_config_long_rx(struct e100_private *bdp, unsigned char enable)
+{
+	if (enable) {
+		if (!(bdp->config[18] & CB_CFIG_LONG_RX_OK)) {
+			bdp->config[18] |= CB_CFIG_LONG_RX_OK;
+			E100_CONFIG(bdp, 18);
+		}
+
+	} else {
+		if ((bdp->config[18] & CB_CFIG_LONG_RX_OK)) {
+			bdp->config[18] &= ~CB_CFIG_LONG_RX_OK;
+			E100_CONFIG(bdp, 18);
+		}
+	}
+}
+
+/**
+ * e100_config_wol
+ * @bdp: atapter's private data struct
+ *
+ * This sets configuration options for PHY and Magic Packet WoL 
+ */
+void
+e100_config_wol(struct e100_private *bdp)
+{
+	spin_lock_bh(&(bdp->config_lock));
+
+	if (bdp->wolopts & WAKE_PHY) {
+		bdp->config[9] |= CB_LINK_STATUS_WOL;
+	}
+	else {
+		/* Disable PHY WoL */
+		bdp->config[9] &= ~CB_LINK_STATUS_WOL;
+	}
+
+	if (bdp->wolopts & WAKE_MAGIC) {
+		bdp->config[19] &= ~CB_DISABLE_MAGPAK_WAKE;
+	}
+	else {
+		/* Disable Magic Packet WoL */
+		bdp->config[19] |= CB_DISABLE_MAGPAK_WAKE;
+	}
+
+	E100_CONFIG(bdp, 19);
+	spin_unlock_bh(&(bdp->config_lock));
+}
+
+void
+e100_config_vlan_drop(struct e100_private *bdp, unsigned char enable)
+{
+	spin_lock_bh(&(bdp->config_lock));
+	if (enable) {
+		if (!(bdp->config[22] & CB_CFIG_VLAN_DROP_ENABLE)) {
+			bdp->config[22] |= CB_CFIG_VLAN_DROP_ENABLE;
+			E100_CONFIG(bdp, 22);
+		}
+
+	} else {
+		if ((bdp->config[22] & CB_CFIG_VLAN_DROP_ENABLE)) {
+			bdp->config[22] &= ~CB_CFIG_VLAN_DROP_ENABLE;
+			E100_CONFIG(bdp, 22);
+		}
+	}
+	spin_unlock_bh(&(bdp->config_lock));
+}
+
+/**
+ * e100_config_loopback_mode
+ * @bdp: atapter's private data struct
+ * @mode: loopback mode(phy/mac/none)
+ *
+ */
+unsigned char
+e100_config_loopback_mode(struct e100_private *bdp, u8 mode)
+{
+	unsigned char bc_changed = false;
+	u8 config_byte;
+
+	spin_lock_bh(&(bdp->config_lock));
+
+	switch (mode) {
+	case NO_LOOPBACK:
+		config_byte = CB_CFIG_LOOPBACK_NORMAL;
+		break;
+	case MAC_LOOPBACK:
+		config_byte = CB_CFIG_LOOPBACK_INTERNAL;
+		break;
+	case PHY_LOOPBACK:
+		config_byte = CB_CFIG_LOOPBACK_EXTERNAL;
+		break;
+	default:
+		printk(KERN_NOTICE "e100: e100_config_loopback_mode: "
+		       "Invalid argument 'mode': %d\n", mode);
+		goto exit;
+	}
+
+	if ((bdp->config[10] & CB_CFIG_LOOPBACK_MODE) != config_byte) {
+
+		bdp->config[10] &= (~CB_CFIG_LOOPBACK_MODE);
+		bdp->config[10] |= config_byte;
+		E100_CONFIG(bdp, 10);
+		bc_changed = true;
+	}
+
+exit:
+	spin_unlock_bh(&(bdp->config_lock));
+	return bc_changed;
+}
+unsigned char
+e100_config_tcb_ext_enable(struct e100_private *bdp, unsigned char enable)
+{
+        unsigned char bc_changed = false;
+ 
+        spin_lock_bh(&(bdp->config_lock));
+ 
+        if (enable) {
+                if (bdp->config[6] & CB_CFIG_EXT_TCB_DIS) {
+ 
+                        bdp->config[6] &= (~CB_CFIG_EXT_TCB_DIS);
+                        E100_CONFIG(bdp, 6);
+                        bc_changed = true;
+                }
+ 
+        } else {
+                if (!(bdp->config[6] & CB_CFIG_EXT_TCB_DIS)) {
+ 
+                        bdp->config[6] |= CB_CFIG_EXT_TCB_DIS;
+                        E100_CONFIG(bdp, 6);
+                        bc_changed = true;
+                }
+        }
+        spin_unlock_bh(&(bdp->config_lock));
+ 
+        return bc_changed;
+}
+unsigned char
+e100_config_dynamic_tbd(struct e100_private *bdp, unsigned char enable)
+{
+        unsigned char bc_changed = false;
+ 
+        spin_lock_bh(&(bdp->config_lock));
+ 
+        if (enable) {
+                if (!(bdp->config[7] & CB_CFIG_DYNTBD_EN)) {
+ 
+                        bdp->config[7] |= CB_CFIG_DYNTBD_EN;
+                        E100_CONFIG(bdp, 7);
+                        bc_changed = true;
+                }
+ 
+        } else {
+                if (bdp->config[7] & CB_CFIG_DYNTBD_EN) {
+ 
+                        bdp->config[7] &= (~CB_CFIG_DYNTBD_EN);
+                        E100_CONFIG(bdp, 7);
+                        bc_changed = true;
+                }
+        }
+        spin_unlock_bh(&(bdp->config_lock));
+ 
+        return bc_changed;
+}
+
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_config.h linux-2.6.5.SUSE/drivers/net/e100-intel/e100_config.h
--- linux-2.6.5/drivers/net/e100-intel/e100_config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_config.h	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,168 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+#ifndef _E100_CONFIG_INC_
+#define _E100_CONFIG_INC_
+
+#include "e100.h"
+
+#define E100_CONFIG(bdp, X) ((bdp)->config[0] = max_t(u8, (bdp)->config[0], (X)+1))
+
+#define CB_CFIG_MIN_PARAMS         8
+
+/* byte 0 bit definitions*/
+#define CB_CFIG_BYTE_COUNT_MASK     BIT_0_5	/* Byte count occupies bit 5-0 */
+
+/* byte 1 bit definitions*/
+#define CB_CFIG_RXFIFO_LIMIT_MASK   BIT_0_4	/* RxFifo limit mask */
+#define CB_CFIG_TXFIFO_LIMIT_MASK   BIT_4_7	/* TxFifo limit mask */
+
+/* byte 2 bit definitions -- ADAPTIVE_IFS*/
+
+/* word 3 bit definitions -- RESERVED*/
+/* Changed for 82558 enhancements */
+/* byte 3 bit definitions */
+#define CB_CFIG_MWI_EN      BIT_0	/* Enable MWI on PCI bus */
+#define CB_CFIG_TYPE_EN     BIT_1	/* Type Enable */
+#define CB_CFIG_READAL_EN   BIT_2	/* Enable Read Align */
+#define CB_CFIG_TERMCL_EN   BIT_3	/* Cache line write  */
+
+/* byte 4 bit definitions*/
+#define CB_CFIG_RX_MIN_DMA_MASK     BIT_0_6	/* Rx minimum DMA count mask */
+
+/* byte 5 bit definitions*/
+#define CB_CFIG_TX_MIN_DMA_MASK BIT_0_6	/* Tx minimum DMA count mask */
+#define CB_CFIG_DMBC_EN         BIT_7	/* Enable Tx/Rx min. DMA counts */
+
+/* Changed for 82558 enhancements */
+/* byte 6 bit definitions*/
+#define CB_CFIG_LATE_SCB           BIT_0	/* Update SCB After New Tx Start */
+#define CB_CFIG_DIRECT_DMA_DIS     BIT_1	/* Direct DMA mode */
+#define CB_CFIG_TNO_INT            BIT_2	/* Tx Not OK Interrupt */
+#define CB_CFIG_TCO_STAT           BIT_2	/* TCO statistics in 559 and above */
+#define CB_CFIG_CI_INT             BIT_3	/* Command Complete Interrupt */
+#define CB_CFIG_EXT_TCB_DIS        BIT_4	/* Extended TCB */
+#define CB_CFIG_EXT_STAT_DIS       BIT_5	/* Extended Stats */
+#define CB_CFIG_SAVE_BAD_FRAMES    BIT_7	/* Save Bad Frames Enabled */
+
+/* byte 7 bit definitions*/
+#define CB_CFIG_DISC_SHORT_FRAMES   BIT_0	/* Discard Short Frames */
+#define CB_CFIG_DYNTBD_EN           BIT_7	/* Enable dynamic TBD */
+/* Enable extended RFD's on D102 */
+#define CB_CFIG_EXTENDED_RFD        BIT_5
+
+/* byte 8 bit definitions*/
+#define CB_CFIG_503_MII             BIT_0	/* 503 vs. MII mode */
+
+/* byte 9 bit definitions -- pre-defined all zeros*/
+#define CB_LINK_STATUS_WOL	BIT_5
+
+/* byte 10 bit definitions*/
+#define CB_CFIG_NO_SRCADR       BIT_3	/* No Source Address Insertion */
+#define CB_CFIG_PREAMBLE_LEN    BIT_4_5	/* Preamble Length */
+#define CB_CFIG_LOOPBACK_MODE   BIT_6_7	/* Loopback Mode */
+#define CB_CFIG_LOOPBACK_NORMAL 0
+#define CB_CFIG_LOOPBACK_INTERNAL BIT_6
+#define CB_CFIG_LOOPBACK_EXTERNAL BIT_6_7
+
+/* byte 11 bit definitions*/
+#define CB_CFIG_LINEAR_PRIORITY     BIT_0_2	/* Linear Priority */
+
+/* byte 12 bit definitions*/
+#define CB_CFIG_LINEAR_PRI_MODE     BIT_0	/* Linear Priority mode */
+#define CB_CFIG_IFS_MASK            BIT_4_7	/* Interframe Spacing mask */
+
+/* byte 13 bit definitions -- pre-defined all zeros*/
+
+/* byte 14 bit definitions -- pre-defined 0xf2*/
+
+/* byte 15 bit definitions*/
+#define CB_CFIG_PROMISCUOUS         BIT_0	/* Promiscuous Mode Enable */
+#define CB_CFIG_BROADCAST_DIS       BIT_1	/* Broadcast Mode Disable */
+#define CB_CFIG_CRS_OR_CDT          BIT_7	/* CRS Or CDT */
+
+/* byte 16 bit definitions -- pre-defined all zeros*/
+#define DFLT_FC_DELAY_LSB  0x1f	/* Delay for outgoing Pause frames */
+#define DFLT_NO_FC_DELAY_LSB  0x00	/* no flow control default value */
+
+/* byte 17 bit definitions -- pre-defined 0x40*/
+#define DFLT_FC_DELAY_MSB  0x01	/* Delay for outgoing Pause frames */
+#define DFLT_NO_FC_DELAY_MSB  0x40	/* no flow control default value */
+
+/* byte 18 bit definitions*/
+#define CB_CFIG_STRIPPING           BIT_0	/* Padding Disabled */
+#define CB_CFIG_PADDING             BIT_1	/* Padding Disabled */
+#define CB_CFIG_CRC_IN_MEM          BIT_2	/* Transfer CRC To Memory */
+
+/* byte 19 bit definitions*/
+#define CB_CFIG_TX_ADDR_WAKE        BIT_0	/* Address Wakeup */
+#define CB_DISABLE_MAGPAK_WAKE      BIT_1	/* Magic Packet Wakeup disable */
+/* Changed TX_FC_EN to TX_FC_DIS because 0 enables, 1 disables. Jul 8, 1999 */
+#define CB_CFIG_TX_FC_DIS           BIT_2	/* Tx Flow Control Disable */
+#define CB_CFIG_FC_RESTOP           BIT_3	/* Rx Flow Control Restop */
+#define CB_CFIG_FC_RESTART          BIT_4	/* Rx Flow Control Restart */
+#define CB_CFIG_FC_REJECT           BIT_5	/* Rx Flow Control Restart */
+#define CB_CFIG_FC_OPTS (CB_CFIG_FC_RESTOP | CB_CFIG_FC_RESTART | CB_CFIG_FC_REJECT)
+
+/* end 82558/9 specifics */
+
+#define CB_CFIG_FORCE_FDX           BIT_6	/* Force Full Duplex */
+#define CB_CFIG_FDX_ENABLE          BIT_7	/* Full Duplex Enabled */
+
+/* byte 20 bit definitions*/
+#define CB_CFIG_MULTI_IA            BIT_6	/* Multiple IA Addr */
+
+/* byte 21 bit definitions*/
+#define CB_CFIG_MULTICAST_ALL       BIT_3	/* Multicast All */
+
+/* byte 22 bit defines */
+#define CB_CFIG_RECEIVE_GAMLA_MODE  BIT_0	/* D102 receive mode */
+#define CB_CFIG_VLAN_DROP_ENABLE    BIT_1	/* vlan stripping */
+
+#define CB_CFIG_LONG_RX_OK	    BIT_3
+
+#define NO_LOOPBACK	0	
+#define MAC_LOOPBACK	0x01
+#define PHY_LOOPBACK	0x02
+
+/* function prototypes */
+extern void e100_config_init(struct e100_private *bdp);
+extern void e100_config_init_82557(struct e100_private *bdp);
+extern unsigned char e100_force_config(struct e100_private *bdp);
+extern unsigned char e100_config(struct e100_private *bdp);
+extern void e100_config_fc(struct e100_private *bdp);
+extern void e100_config_promisc(struct e100_private *bdp, unsigned char enable);
+extern void e100_config_brdcast_dsbl(struct e100_private *bdp);
+extern void e100_config_mulcast_enbl(struct e100_private *bdp,
+				     unsigned char enable);
+extern void e100_config_ifs(struct e100_private *bdp);
+extern void e100_config_force_dplx(struct e100_private *bdp);
+extern u8 e100_config_loopback_mode(struct e100_private *bdp, u8 mode);
+extern u8 e100_config_dynamic_tbd(struct e100_private *bdp, u8 enable);
+extern u8 e100_config_tcb_ext_enable(struct e100_private *bdp, u8 enable);
+extern void e100_config_vlan_drop(struct e100_private *bdp, unsigned char enable);
+#endif /* _E100_CONFIG_INC_ */
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_eeprom.c linux-2.6.5.SUSE/drivers/net/e100-intel/e100_eeprom.c
--- linux-2.6.5/drivers/net/e100-intel/e100_eeprom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_eeprom.c	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,565 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  e100_eeprom.c                                         *
+*                                                                     *
+* Abstract:     This module contains routines to read and write to a  *
+*               serial EEPROM                                         *
+*                                                                     *
+* Environment:  This file is intended to be specific to the Linux     *
+*               operating system.                                     *
+*                                                                     *
+**********************************************************************/
+#include "e100.h"
+
+#define CSR_EEPROM_CONTROL_FIELD(bdp) ((bdp)->scb->scb_eprm_cntrl)
+
+#define CSR_GENERAL_CONTROL2_FIELD(bdp) \
+	           ((bdp)->scb->scb_ext.d102_scb.scb_gen_ctrl2)
+
+#define EEPROM_STALL_TIME	4
+#define EEPROM_CHECKSUM		((u16) 0xBABA)
+#define EEPROM_MAX_WORD_SIZE	256
+
+void e100_eeprom_cleanup(struct e100_private *adapter);
+u16 e100_eeprom_calculate_chksum(struct e100_private *adapter);
+static void e100_eeprom_write_word(struct e100_private *adapter, u16 reg,
+				   u16 data);
+void e100_eeprom_write_block(struct e100_private *adapter, u16 start, u16 *data,
+			     u16 size);
+u16 e100_eeprom_size(struct e100_private *adapter);
+u16 e100_eeprom_read(struct e100_private *adapter, u16 reg);
+
+static void shift_out_bits(struct e100_private *adapter, u16 data, u16 count);
+static u16 shift_in_bits(struct e100_private *adapter);
+static void raise_clock(struct e100_private *adapter, u16 *x);
+static void lower_clock(struct e100_private *adapter, u16 *x);
+static u16 eeprom_wait_cmd_done(struct e100_private *adapter);
+static void eeprom_stand_by(struct e100_private *adapter);
+
+//----------------------------------------------------------------------------------------
+// Procedure:   eeprom_set_semaphore
+//
+// Description: This function set (write 1) Gamla EEPROM semaphore bit (bit 23 word 0x1C in the CSR).
+//
+// Arguments:
+//      Adapter                 - Adapter context
+//
+// Returns:  true if success
+//           else return false 
+//
+//----------------------------------------------------------------------------------------
+
+inline u8
+eeprom_set_semaphore(struct e100_private *adapter)
+{
+	u16 data = 0;
+	unsigned long expiration_time = jiffies + HZ / 100 + 1;
+
+	do {
+		// Get current value of General Control 2
+		data = readb(&CSR_GENERAL_CONTROL2_FIELD(adapter));
+
+		// Set bit 23 word 0x1C in the CSR.
+		data |= SCB_GCR2_EEPROM_ACCESS_SEMAPHORE;
+		writeb(data, &CSR_GENERAL_CONTROL2_FIELD(adapter));
+
+		// Check to see if this bit set or not.
+		data = readb(&CSR_GENERAL_CONTROL2_FIELD(adapter));
+
+		if (data & SCB_GCR2_EEPROM_ACCESS_SEMAPHORE) {
+			return true;
+		}
+
+		if (time_before(jiffies, expiration_time))
+			yield();
+		else
+			return false;
+
+	} while (true);
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   eeprom_reset_semaphore
+//
+// Description: This function reset (write 0) Gamla EEPROM semaphore bit 
+//              (bit 23 word 0x1C in the CSR).
+//
+// Arguments:  struct e100_private * adapter - Adapter context
+//----------------------------------------------------------------------------------------
+
+inline void
+eeprom_reset_semaphore(struct e100_private *adapter)
+{
+	u16 data = 0;
+
+	data = readb(&CSR_GENERAL_CONTROL2_FIELD(adapter));
+	data &= ~(SCB_GCR2_EEPROM_ACCESS_SEMAPHORE);
+	writeb(data, &CSR_GENERAL_CONTROL2_FIELD(adapter));
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   e100_eeprom_size
+//
+// Description: This routine determines the size of the EEPROM.  This value should be
+//              checked for validity - ie. is it too big or too small.  The size returned
+//              is then passed to the read/write functions.
+//
+// Returns:
+//      Size of the eeprom, or zero if an error occurred
+//----------------------------------------------------------------------------------------
+u16
+e100_eeprom_size(struct e100_private *adapter)
+{
+	u16 x, size = 1;	// must be one to accumulate a product
+
+	// if we've already stored this data, read from memory
+	if (adapter->eeprom_size) {
+		return adapter->eeprom_size;
+	}
+	// otherwise, read from the eeprom
+	// Set EEPROM semaphore.
+	if (adapter->rev_id >= D102_REV_ID) {
+		if (!eeprom_set_semaphore(adapter))
+			return 0;
+	}
+	// enable the eeprom by setting EECS.
+	x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+	x &= ~(EEDI | EEDO | EESK);
+	x |= EECS;
+	writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+
+	// write the read opcode
+	shift_out_bits(adapter, EEPROM_READ_OPCODE, 3);
+
+	// experiment to discover the size of the eeprom.  request register zero
+	// and wait for the eeprom to tell us it has accepted the entire address.
+	x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+	do {
+		size *= 2;	// each bit of address doubles eeprom size
+		x |= EEDO;	// set bit to detect "dummy zero"
+		x &= ~EEDI;	// address consists of all zeros
+
+		writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+		readw(&(adapter->scb->scb_status));
+		udelay(EEPROM_STALL_TIME);
+		raise_clock(adapter, &x);
+		lower_clock(adapter, &x);
+
+		// check for "dummy zero"
+		x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+		if (size > EEPROM_MAX_WORD_SIZE) {
+			size = 0;
+			break;
+		}
+	} while (x & EEDO);
+
+	// read in the value requested
+	(void) shift_in_bits(adapter);
+	e100_eeprom_cleanup(adapter);
+
+	// Clear EEPROM Semaphore.
+	if (adapter->rev_id >= D102_REV_ID) {
+		eeprom_reset_semaphore(adapter);
+	}
+
+	return size;
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   eeprom_address_size
+//
+// Description: determines the number of bits in an address for the eeprom acceptable
+//              values are 64, 128, and 256
+// Arguments: size of the eeprom
+// Returns: bits in an address for that size eeprom
+//----------------------------------------------------------------------------------------
+
+static inline int
+eeprom_address_size(u16 size)
+{
+	int isize = size;
+	
+	return (ffs(isize) - 1);
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   e100_eeprom_read
+//
+// Description: This routine serially reads one word out of the EEPROM.
+//
+// Arguments:
+//      adapter - our adapter context
+//      reg - EEPROM word to read.
+//
+// Returns:
+//      Contents of EEPROM word (reg).
+//----------------------------------------------------------------------------------------
+
+u16
+e100_eeprom_read(struct e100_private *adapter, u16 reg)
+{
+	u16 x, data, bits;
+
+	// Set EEPROM semaphore.
+	if (adapter->rev_id >= D102_REV_ID) {
+		if (!eeprom_set_semaphore(adapter))
+			return 0;
+	}
+	// eeprom size is initialized to zero
+	if (!adapter->eeprom_size)
+		adapter->eeprom_size = e100_eeprom_size(adapter);
+
+	bits = eeprom_address_size(adapter->eeprom_size);
+
+	// select EEPROM, reset bits, set EECS
+	x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+
+	x &= ~(EEDI | EEDO | EESK);
+	x |= EECS;
+	writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+
+	// write the read opcode and register number in that order
+	// The opcode is 3bits in length, reg is 'bits' bits long
+	shift_out_bits(adapter, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(adapter, reg, bits);
+
+	// Now read the data (16 bits) in from the selected EEPROM word
+	data = shift_in_bits(adapter);
+
+	e100_eeprom_cleanup(adapter);
+
+	// Clear EEPROM Semaphore.
+	if (adapter->rev_id >= D102_REV_ID) {
+		eeprom_reset_semaphore(adapter);
+	}
+
+	return data;
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   shift_out_bits
+//
+// Description: This routine shifts data bits out to the EEPROM.
+//
+// Arguments:
+//      data - data to send to the EEPROM.
+//      count - number of data bits to shift out.
+//
+// Returns: (none)
+//----------------------------------------------------------------------------------------
+
+static void
+shift_out_bits(struct e100_private *adapter, u16 data, u16 count)
+{
+	u16 x, mask;
+
+	mask = 1 << (count - 1);
+	x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+	x &= ~(EEDO | EEDI);
+
+	do {
+		x &= ~EEDI;
+		if (data & mask)
+			x |= EEDI;
+
+		writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+		readw(&(adapter->scb->scb_status)); /* flush command to card */
+		udelay(EEPROM_STALL_TIME);
+		raise_clock(adapter, &x);
+		lower_clock(adapter, &x);
+		mask = mask >> 1;
+	} while (mask);
+
+	x &= ~EEDI;
+	writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   raise_clock
+//
+// Description: This routine raises the EEPROM's clock input (EESK)
+//
+// Arguments:
+//      x - Ptr to the EEPROM control register's current value
+//
+// Returns: (none)
+//----------------------------------------------------------------------------------------
+
+void
+raise_clock(struct e100_private *adapter, u16 *x)
+{
+	*x = *x | EESK;
+	writew(*x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+	readw(&(adapter->scb->scb_status)); /* flush command to card */
+	udelay(EEPROM_STALL_TIME);
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   lower_clock
+//
+// Description: This routine lower's the EEPROM's clock input (EESK)
+//
+// Arguments:
+//      x - Ptr to the EEPROM control register's current value
+//
+// Returns: (none)
+//----------------------------------------------------------------------------------------
+
+void
+lower_clock(struct e100_private *adapter, u16 *x)
+{
+	*x = *x & ~EESK;
+	writew(*x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+	readw(&(adapter->scb->scb_status)); /* flush command to card */
+	udelay(EEPROM_STALL_TIME);
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   shift_in_bits
+//
+// Description: This routine shifts data bits in from the EEPROM.
+//
+// Arguments:
+//
+// Returns:
+//      The contents of that particular EEPROM word
+//----------------------------------------------------------------------------------------
+
+static u16
+shift_in_bits(struct e100_private *adapter)
+{
+	u16 x, d, i;
+
+	x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+	x &= ~(EEDO | EEDI);
+	d = 0;
+
+	for (i = 0; i < 16; i++) {
+		d <<= 1;
+		raise_clock(adapter, &x);
+
+		x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+
+		x &= ~EEDI;
+		if (x & EEDO)
+			d |= 1;
+
+		lower_clock(adapter, &x);
+	}
+
+	return d;
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   e100_eeprom_cleanup
+//
+// Description: This routine returns the EEPROM to an idle state
+//----------------------------------------------------------------------------------------
+
+void
+e100_eeprom_cleanup(struct e100_private *adapter)
+{
+	u16 x;
+
+	x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+
+	x &= ~(EECS | EEDI);
+	writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+
+	raise_clock(adapter, &x);
+	lower_clock(adapter, &x);
+}
+
+//**********************************************************************************
+// Procedure:   e100_eeprom_update_chksum
+//
+// Description: Calculates the checksum and writes it to the EEProm. 
+//              It calculates the checksum accroding to the formula: 
+//                              Checksum = 0xBABA - (sum of first 63 words).
+//
+//-----------------------------------------------------------------------------------
+u16
+e100_eeprom_calculate_chksum(struct e100_private *adapter)
+{
+	u16 idx, xsum_index, checksum = 0;
+
+	// eeprom size is initialized to zero
+	if (!adapter->eeprom_size)
+		adapter->eeprom_size = e100_eeprom_size(adapter);
+
+	xsum_index = adapter->eeprom_size - 1;
+	for (idx = 0; idx < xsum_index; idx++)
+		checksum += e100_eeprom_read(adapter, idx);
+
+	checksum = EEPROM_CHECKSUM - checksum;
+	return checksum;
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   e100_eeprom_write_word
+//
+// Description: This routine writes a word to a specific EEPROM location without.
+//              taking EEPROM semaphore and updating checksum. 
+//              Use e100_eeprom_write_block for the EEPROM update
+// Arguments: reg - The EEPROM word that we are going to write to.
+//            data - The data (word) that we are going to write to the EEPROM.
+//----------------------------------------------------------------------------------------
+static void
+e100_eeprom_write_word(struct e100_private *adapter, u16 reg, u16 data)
+{
+	u16 x;
+	u16 bits;
+
+	bits = eeprom_address_size(adapter->eeprom_size);
+
+	/* select EEPROM, mask off ASIC and reset bits, set EECS */
+	x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+	x &= ~(EEDI | EEDO | EESK);
+	writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+	readw(&(adapter->scb->scb_status)); /* flush command to card */
+	udelay(EEPROM_STALL_TIME);
+	x |= EECS;
+	writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+
+	shift_out_bits(adapter, EEPROM_EWEN_OPCODE, 5);
+	shift_out_bits(adapter, reg, (u16) (bits - 2));
+	if (!eeprom_wait_cmd_done(adapter))
+		return;
+
+	/* write the new word to the EEPROM & send the write opcode the EEPORM */
+	shift_out_bits(adapter, EEPROM_WRITE_OPCODE, 3);
+
+	/* select which word in the EEPROM that we are writing to */
+	shift_out_bits(adapter, reg, bits);
+
+	/* write the data to the selected EEPROM word */
+	shift_out_bits(adapter, data, 16);
+	if (!eeprom_wait_cmd_done(adapter))
+		return;
+
+	shift_out_bits(adapter, EEPROM_EWDS_OPCODE, 5);
+	shift_out_bits(adapter, reg, (u16) (bits - 2));
+	if (!eeprom_wait_cmd_done(adapter))
+		return;
+
+	e100_eeprom_cleanup(adapter);
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   e100_eeprom_write_block
+//
+// Description: This routine writes a block of words starting from specified EEPROM 
+//              location and updates checksum
+// Arguments: reg - The EEPROM word that we are going to write to.
+//            data - The data (word) that we are going to write to the EEPROM.
+//----------------------------------------------------------------------------------------
+void
+e100_eeprom_write_block(struct e100_private *adapter, u16 start, u16 *data,
+			u16 size)
+{
+	u16 checksum;
+	u16 i;
+
+	if (!adapter->eeprom_size)
+		adapter->eeprom_size = e100_eeprom_size(adapter);
+
+	// Set EEPROM semaphore.
+	if (adapter->rev_id >= D102_REV_ID) {
+		if (!eeprom_set_semaphore(adapter))
+			return;
+	}
+
+	for (i = 0; i < size; i++) {
+		e100_eeprom_write_word(adapter, start + i, data[i]);
+	}
+	//Update checksum
+	checksum = e100_eeprom_calculate_chksum(adapter);
+	e100_eeprom_write_word(adapter, (adapter->eeprom_size - 1), checksum);
+
+	// Clear EEPROM Semaphore.
+	if (adapter->rev_id >= D102_REV_ID) {
+		eeprom_reset_semaphore(adapter);
+	}
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   eeprom_wait_cmd_done
+//
+// Description: This routine waits for the the EEPROM to finish its command.  
+//                              Specifically, it waits for EEDO (data out) to go high.
+// Returns:     true - If the command finished
+//              false - If the command never finished (EEDO stayed low)
+//----------------------------------------------------------------------------------------
+static u16
+eeprom_wait_cmd_done(struct e100_private *adapter)
+{
+	u16 x;
+	unsigned long expiration_time = jiffies + HZ / 100 + 1;
+
+	eeprom_stand_by(adapter);
+
+	do {
+		rmb();
+		x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+		if (x & EEDO)
+			return true;
+		if (time_before(jiffies, expiration_time))
+			yield();
+		else
+			return false;
+	} while (true);
+}
+
+//----------------------------------------------------------------------------------------
+// Procedure:   eeprom_stand_by
+//
+// Description: This routine lowers the EEPROM chip select (EECS) for a few microseconds.
+//----------------------------------------------------------------------------------------
+static void
+eeprom_stand_by(struct e100_private *adapter)
+{
+	u16 x;
+
+	x = readw(&CSR_EEPROM_CONTROL_FIELD(adapter));
+	x &= ~(EECS | EESK);
+	writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+	readw(&(adapter->scb->scb_status)); /* flush command to card */
+	udelay(EEPROM_STALL_TIME);
+	x |= EECS;
+	writew(x, &CSR_EEPROM_CONTROL_FIELD(adapter));
+	readw(&(adapter->scb->scb_status)); /* flush command to card */
+	udelay(EEPROM_STALL_TIME);
+}
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_kcompat.c linux-2.6.5.SUSE/drivers/net/e100-intel/e100_kcompat.c
--- linux-2.6.5/drivers/net/e100-intel/e100_kcompat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_kcompat.c	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,97 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+#include "e100_kcompat.h"
+
+/******************************************************************
+ *#################################################################
+ *#
+ *# Kernels before 2.4.3
+ *#
+ *#################################################################
+ ******************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3)
+
+void
+e100_pci_release_regions(struct pci_dev *pdev)
+{
+	release_region(pci_resource_start(pdev, 1), pci_resource_len(pdev, 1));
+
+	release_mem_region(pci_resource_start(pdev, 0),
+			   pci_resource_len(pdev, 0));
+}
+
+int __devinit
+e100_pci_request_regions(struct pci_dev *pdev, char *res_name)
+{
+	unsigned long io_len = pci_resource_len(pdev, 1);
+	unsigned long base_addr;
+
+	base_addr = pci_resource_start(pdev, 1);
+
+	if (!request_region(base_addr, io_len, res_name)) {
+		printk(KERN_ERR "%s: Failed to reserve I/O region\n", res_name);
+		goto err;
+	}
+
+	if (!request_mem_region(pci_resource_start(pdev, 0),
+				pci_resource_len(pdev, 0), res_name)) {
+		printk(KERN_ERR
+		       "%s: Failed to reserve memory region\n", res_name);
+		goto err_io;
+	}
+
+	return 0;
+
+err_io:
+	release_region(base_addr, io_len);
+
+err:
+	return -EBUSY;
+}
+
+int _kc_is_valid_ether_addr(u8 *addr)
+{
+	const char zaddr[6] = {0,};
+
+	return !(addr[0]&1) && memcmp( addr, zaddr, 6);
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) */
+
+/*****************************************************************************/
+/* 2.4.6 => 2.4.3 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) )
+int _kc_pci_set_power_state(struct pci_dev *dev, int state)
+{ return 0; }
+int _kc_pci_save_state(struct pci_dev *dev, u32 *buffer)
+{ return 0; }
+int _kc_pci_restore_state(struct pci_dev *pdev, u32 *buffer)
+{ return 0; }
+int _kc_pci_enable_wake(struct pci_dev *pdev, u32 state, int enable)
+{ return 0; }
+#endif
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_kcompat.h linux-2.6.5.SUSE/drivers/net/e100-intel/e100_kcompat.h
--- linux-2.6.5/drivers/net/e100-intel/e100_kcompat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_kcompat.h	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,570 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+/* Macros to make drivers compatible with 2.4 Linux kernels
+ *
+ * In order to make a single network driver work with all 2.4 kernels
+ * these compatibility macros can be used.
+ * They are backwards compatible implementations of the latest APIs.
+ * The idea is that these macros will let you use the newest driver with old
+ * kernels, but can be removed when working with the latest and greatest.
+ */
+
+#ifndef __E100_KCOMPAT_H__
+#define __E100_KCOMPAT_H__
+
+#include <linux/version.h>
+#include <linux/types.h>
+
+/******************************************************************
+ *#################################################################
+ *#
+ *# General definitions, not related to a specific kernel version.
+ *#
+ *#################################################################
+ ******************************************************************/
+#ifndef __init
+#define __init
+#endif
+
+#ifndef __devinit
+#define __devinit
+#endif
+
+#ifndef __exit
+#define __exit
+#endif
+
+#ifndef __devexit
+#define __devexit
+#endif
+
+#ifndef __devinitdata
+#define __devinitdata
+#endif
+
+#ifndef __devexit_p
+#define __devexit_p(x) x
+#endif
+
+#ifndef MODULE_LICENSE
+#define MODULE_LICENSE(license)
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)
+#endif
+
+#ifndef IRQ_HANDLED
+#define irqreturn_t void
+#define IRQ_HANDLED
+#define IRQ_NONE
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(x)	kfree(x)
+#endif
+
+#ifndef MOD_INC_USE_COUNT
+#define MOD_INC_USE_COUNT do {} while (0)
+#endif
+
+#ifndef MOD_DEC_USE_COUNT
+#define MOD_DEC_USE_COUNT do {} while (0)
+#endif
+
+#ifdef HAVE_POLL_CONTROLLER
+#define CONFIG_NET_POLL_CONTROLLER
+#endif
+
+#ifndef min_t
+#define min_t(type,x,y) \
+        ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+#endif
+
+#ifndef max_t
+#define max_t(type,x,y) \
+        ({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
+#endif
+
+#ifndef cpu_relax
+#define cpu_relax() do {} while (0)
+#endif
+
+#ifndef ETHTOOL_GWOL
+/* Wake-On-Lan options. */
+#define WAKE_PHY                (1 << 0)
+#define WAKE_UCAST              (1 << 1)
+#define WAKE_ARP                (1 << 4)
+#define WAKE_MAGIC              (1 << 5)
+#endif
+
+/* Installations with ethtool version < 1.6 */
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK		0x0000000a /* Get link status */
+#endif
+#ifndef ETH_TEST_FL_OFFLINE
+#define ETH_TEST_FL_OFFLINE	(1 << 0)
+#endif
+#ifndef ETH_TEST_FL_FAILED
+#define ETH_TEST_FL_FAILED	(1 << 1)
+#endif
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST		0x0000001a /* execute NIC self-test, priv. */
+#endif
+#undef ethtool_test
+#define ethtool_test _kc_ethtool_test
+/* for requesting NIC test and getting results*/
+struct _kc_ethtool_test {
+	u32	cmd;		/* ETHTOOL_TEST */
+	u32	flags;		/* ETH_TEST_FL_xxx */
+	u32	reserved;
+	u32	len;		/* result length, in number of u64 elements */
+	u64	data[0];
+};
+#ifndef ETH_GSTRING_LEN
+#define ETH_GSTRING_LEN         32
+#endif
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS	0x0000001b /* get specified string set */
+#endif
+#undef ethtool_gstrings
+#define ethtool_gstrings _kc_ethtool_gstrings
+/* for passing string sets for data tagging */
+struct _kc_ethtool_gstrings {
+	u32	cmd;		/* ETHTOOL_GSTRINGS */
+	u32	string_set;	/* string set id e.c. ETH_SS_TEST, etc*/
+	u32	len;		/* number of strings in the string set */
+	u8	data[0];
+};
+#ifndef ETH_SS_TEST
+#define ETH_SS_TEST		0
+#endif
+#ifndef ETH_SS_STATS
+#define ETH_SS_STATS		1
+#endif
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS		0x0000001d /* get NIC-specific statistics */
+#endif
+#undef ethtool_stats
+#define ethtool_stats _kc_ethtool_stats
+/* for dumping NIC-specific statistics */
+struct _kc_ethtool_stats {
+	u32	cmd;		/* ETHTOOL_GSTATS */
+	u32	n_stats;	/* number of u64's being returned */
+	u64	data[0];
+};
+#ifndef ETHTOOL_BUSINFO_LEN
+#define ETHTOOL_BUSINFO_LEN	32
+#endif
+#undef ethtool_drvinfo
+#define ethtool_drvinfo k_ethtool_drvinfo
+struct k_ethtool_drvinfo {
+	u32	cmd;
+	char	driver[32];	/* driver short name, "tulip", "eepro100" */
+	char	version[32];	/* driver version string */
+	char	fw_version[32];	/* firmware version string, if applicable */
+	char	bus_info[ETHTOOL_BUSINFO_LEN];	/* Bus info for this IF. */
+				/* For PCI devices, use pci_dev->slot_name. */
+	char	reserved1[32];
+	char	reserved2[16];
+	u32	n_stats;	/* number of u64's from ETHTOOL_GSTATS */
+	u32	testinfo_len;
+	u32	eedump_len;	/* Size of data from ETHTOOL_GEEPROM (bytes) */
+	u32	regdump_len;	/* Size of data from ETHTOOL_GREGS (bytes) */
+};
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM 0xb
+#define ETHTOOL_SEEPROM 0xc
+#undef ETHTOOL_GREGS
+struct ethtool_eeprom {
+	u32	cmd;
+	u32	magic;
+	u32	offset;
+	u32	len;
+	u8	data[0];
+};
+#endif /* ETHTOOL_GEEPROM */
+
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID 0x1c
+#undef ethtool_value
+#define ethtool_value k_ethtool_value
+struct k_ethtool_value {
+	u32     cmd;
+	u32     data;
+};
+#endif /* ETHTOOL_PHYS_ID */ 
+
+/******************************************************************
+ *#################################################################
+ *#
+ *# Kernels before 2.4.3
+ *#
+ *#################################################################
+ ******************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3)
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+
+#ifndef pci_request_regions
+#define pci_request_regions e100_pci_request_regions
+extern int e100_pci_request_regions(struct pci_dev *pdev, char *res_name);
+#endif
+
+#ifndef pci_release_regions
+#define pci_release_regions e100_pci_release_regions
+extern void e100_pci_release_regions(struct pci_dev *pdev);
+#endif
+
+#ifndef is_valid_ether_addr
+#define is_valid_ether_addr _kc_is_valid_ether_addr
+extern int _kc_is_valid_ether_addr(u8 *addr);
+#endif 
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) */
+
+/******************************************************************
+ *#################################################################
+ *#
+ *# Kernels before 2.4.4
+ *#
+ *#################################################################
+ ******************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+
+#define pci_disable_device(dev) do{} while(0)
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4) */
+
+/******************************************************************
+ *#################################################################
+ *#
+ *# Kernels before 2.4.5
+ *#
+ *#################################################################
+ ******************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5)
+
+#define skb_linearize(skb, gfp_mask) ({     \
+    struct sk_buff *tmp_skb;                \
+    tmp_skb = skb;                          \
+    skb = skb_copy(tmp_skb, gfp_mask);      \
+    dev_kfree_skb_any(tmp_skb); })
+
+/* MII constants */
+
+/* MDI register set*/
+#ifndef MII_BMCR
+#define MII_BMCR		0x00	/* MDI control register */
+#endif
+#ifndef MII_BMSR
+#define MII_BMSR		0x01	/* MDI Status regiser */
+#endif
+#ifndef MII_PHYSID1
+#define MII_PHYSID1		0x02	/* Phy indentification reg (word 1) */
+#endif
+#ifndef MII_PHYSID2
+#define MII_PHYSID2		0x03	/* Phy indentification reg (word 2) */
+#endif
+#ifndef MII_ADVERTISE
+#define MII_ADVERTISE		0x04	/* Auto-negotiation advertisement */
+#endif
+#ifndef MII_LPA
+#define MII_LPA			0x05	/* Auto-negotiation link partner ability */
+#endif
+#ifndef MII_EXPANSION
+#define MII_EXPANSION		0x06	/* Auto-negotiation expansion */
+#endif
+#ifndef MII_NCONFIG
+#define MII_NCONFIG		0x1c	/* Network interface config   (MDI/MDIX) */
+#endif
+
+/* MDI Control register bit definitions*/
+#ifndef BMCR_RESV
+#define BMCR_RESV		0x007f	/* Unused...                   */
+#endif
+#ifndef BMCR_CTST
+#define BMCR_CTST	        0x0080	/* Collision test              */
+#endif
+#ifndef BMCR_FULLDPLX
+#define BMCR_FULLDPLX		0x0100	/* Full duplex                 */
+#endif
+#ifndef BMCR_ANRESTART
+#define BMCR_ANRESTART		0x0200	/* Auto negotiation restart    */
+#endif
+#ifndef BMCR_ISOLATE
+#define BMCR_ISOLATE		0x0400	/* Disconnect DP83840 from MII */
+#endif
+#ifndef BMCR_PDOWN
+#define BMCR_PDOWN		0x0800	/* Powerdown the DP83840       */
+#endif
+#ifndef BMCR_ANENABLE
+#define BMCR_ANENABLE		0x1000	/* Enable auto negotiation     */
+#endif
+#ifndef BMCR_SPEED100
+#define BMCR_SPEED100		0x2000	/* Select 100Mbps              */
+#endif
+#ifndef BMCR_LOOPBACK
+#define BMCR_LOOPBACK		0x4000	/* TXD loopback bits           */
+#endif
+#ifndef BMCR_RESET
+#define BMCR_RESET		0x8000	/* Reset the DP83840           */
+#endif
+
+/* MDI Status register bit definitions*/
+#ifndef BMSR_ERCAP
+#define BMSR_ERCAP		0x0001	/* Ext-reg capability          */
+#endif
+#ifndef BMSR_JCD
+#define BMSR_JCD		0x0002	/* Jabber detected             */
+#endif
+#ifndef BMSR_LSTATUS
+#define BMSR_LSTATUS		0x0004	/* Link status                 */
+#endif
+#ifndef BMSR_ANEGCAPABLE
+#define BMSR_ANEGCAPABLE	0x0008	/* Able to do auto-negotiation */
+#endif
+#ifndef BMSR_RFAULT
+#define BMSR_RFAULT		0x0010	/* Remote fault detected       */
+#endif
+#ifndef BMSR_ANEGCOMPLETE
+#define BMSR_ANEGCOMPLETE	0x0020	/* Auto-negotiation complete   */
+#endif
+#ifndef BMSR_RESV
+#define BMSR_RESV		0x07c0	/* Unused...                   */
+#endif
+#ifndef BMSR_10HALF
+#define BMSR_10HALF		0x0800	/* Can do 10mbps, half-duplex  */
+#endif
+#ifndef BMSR_10FULL
+#define BMSR_10FULL		0x1000	/* Can do 10mbps, full-duplex  */
+#endif
+#ifndef BMSR_100HALF
+#define BMSR_100HALF		0x2000	/* Can do 100mbps, half-duplex */
+#endif
+#ifndef BMSR_100FULL
+#define BMSR_100FULL		0x4000	/* Can do 100mbps, full-duplex */
+#endif
+#ifndef BMSR_100BASE4
+#define BMSR_100BASE4		0x8000	/* Can do 100mbps, 4k packets  */
+#endif
+
+/* Auto-Negotiation advertisement register bit definitions*/
+#ifndef ADVERTISE_10HALF
+#define ADVERTISE_10HALF	0x0020	/* Try for 10mbps half-duplex  */
+#endif
+#ifndef ADVERTISE_10FULL
+#define ADVERTISE_10FULL	0x0040	/* Try for 10mbps full-duplex  */
+#endif
+#ifndef ADVERTISE_100HALF
+#define ADVERTISE_100HALF	0x0080	/* Try for 100mbps half-duplex */
+#endif
+#ifndef ADVERTISE_100FULL
+#define ADVERTISE_100FULL	0x0100	/* Try for 100mbps full-duplex */
+#endif
+#ifndef ADVERTISE_100BASE4
+#define ADVERTISE_100BASE4	0x0200	/* Try for 100mbps 4k packets  */
+#endif
+
+/* Auto-Negotiation expansion register bit definitions*/
+#ifndef EXPANSION_NWAY 
+#define EXPANSION_NWAY		0x0001	/* Can do N-way auto-nego      */
+#endif
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,7)
+
+#ifdef SIOCGMIIPHY
+#undef SIOCGMIIPHY
+#endif
+#define SIOCGMIIPHY     SIOCDEVPRIVATE
+
+#ifdef SIOCGMIIREG
+#undef SIOCGMIIREG
+#endif
+#define SIOCGMIIREG     (SIOCDEVPRIVATE+1)
+
+#ifdef SIOCSMIIREG
+#undef SIOCSMIIREG
+#endif
+#define SIOCSMIIREG     (SIOCDEVPRIVATE+2)
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,7) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6)
+
+#include <linux/types.h>
+#include <linux/pci.h>
+
+/* Power Management */
+#define PMCSR		0xe0
+#define PM_ENABLE_BIT	0x0100
+#define PM_CLEAR_BIT	0x8000
+#define PM_STATE_MASK	0xFFFC
+#define PM_STATE_D1	0x0001
+
+static inline int
+pci_enable_wake(struct pci_dev *dev, u32 state, int enable)
+{
+	u16 p_state;
+
+	pci_read_config_word(dev, PMCSR, &p_state);
+	pci_write_config_word(dev, PMCSR, p_state | PM_CLEAR_BIT);
+
+	if (enable == 0) {
+		p_state &= ~PM_ENABLE_BIT;
+	} else {
+		p_state |= PM_ENABLE_BIT;
+	}
+	p_state &= PM_STATE_MASK;
+	p_state |= state;
+
+	pci_write_config_word(dev, PMCSR, p_state);
+
+	return 0;
+}
+
+struct mii_ioctl_data {
+	u16             phy_id;
+	u16             reg_num;
+	u16             val_in;
+	u16             val_out;
+};
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) )
+#ifndef pci_set_power_state
+#define pci_set_power_state _kc_pci_set_power_state
+extern int _kc_pci_set_power_state(struct pci_dev *dev, int state);
+#endif
+#ifndef pci_save_state
+#define pci_save_state _kc_pci_save_state
+extern int _kc_pci_save_state(struct pci_dev *dev, u32 *buffer);
+#endif
+#ifndef pci_restore_state
+#define pci_restore_state _kc_pci_restore_state
+extern int _kc_pci_restore_state(struct pci_dev *pdev, u32 *buffer);
+#endif
+/* PCI PM entry point syntax changed, so don't support suspend/resume */
+#undef CONFIG_PM
+#endif
+
+#ifndef pci_for_each_dev
+#define pci_for_each_dev(dev) for(dev = pci_devices; dev; dev = dev->next)
+#endif
+
+/* 2.4.20 => 2.4.18 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20) )
+
+#ifndef ETHTOOL_GRINGPARAM
+#define ETHTOOL_GRINGPARAM	0x00000010 /* Get ring parameters */
+#endif
+#ifndef ETHTOOL_SRINGPARAM
+#define ETHTOOL_SRINGPARAM	0x00000011 /* Set ring parameters, priv. */
+#endif
+#ifndef ETHTOOL_GPAUSEPARAM
+#define ETHTOOL_GPAUSEPARAM	0x00000012 /* Get pause parameters */
+#endif
+#ifndef ETHTOOL_SPAUSEPARAM
+#define ETHTOOL_SPAUSEPARAM	0x00000013 /* Set pause parameters, priv. */
+#endif
+#ifndef ETHTOOL_GRXCSUM
+#define ETHTOOL_GRXCSUM		0x00000014 /* Get RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SRXCSUM
+#define ETHTOOL_SRXCSUM		0x00000015 /* Set RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GTXCSUM
+#define ETHTOOL_GTXCSUM		0x00000016 /* Get TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STXCSUM
+#define ETHTOOL_STXCSUM		0x00000017 /* Set TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GSG
+#define ETHTOOL_GSG		0x00000018 /* Get scatter-gather enable
+					    * (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SSG
+#define ETHTOOL_SSG		0x00000019 /* Set scatter-gather enable
+					    * (ethtool_value), priv. */
+#endif
+
+#undef ethtool_ringparam
+#define ethtool_ringparam _kc_ethtool_ringparam
+struct _kc_ethtool_ringparam {
+	u32	cmd;	/* ETHTOOL_{G,S}RINGPARAM */
+
+	/* Read only attributes.  These indicate the maximum number
+	 * of pending RX/TX ring entries the driver will allow the
+	 * user to set.
+	 */
+	u32	rx_max_pending;
+	u32	rx_mini_max_pending;
+	u32	rx_jumbo_max_pending;
+	u32	tx_max_pending;
+
+	/* Values changeable by the user.  The valid values are
+	 * in the range 1 to the "*_max_pending" counterpart above.
+	 */
+	u32	rx_pending;
+	u32	rx_mini_pending;
+	u32	rx_jumbo_pending;
+	u32	tx_pending;
+};
+
+#undef ethtool_pauseparam
+#define ethtool_pauseparam _kc_ethtool_pauseparam
+/* for configuring link flow control parameters */
+struct _kc_ethtool_pauseparam {
+	u32	cmd;	/* ETHTOOL_{G,S}PAUSEPARAM */
+
+	/* If the link is being auto-negotiated (via ethtool_cmd.autoneg
+	 * being true) the user may set 'autonet' here non-zero to have the
+	 * pause parameters be auto-negotiated too.  In such a case, the
+	 * {rx,tx}_pause values below determine what capabilities are
+	 * advertised.
+	 *
+	 * If 'autoneg' is zero or the link is not being auto-negotiated,
+	 * then {rx,tx}_pause force the driver to use/not-use pause
+	 * flow control.
+	 */
+	u32	autoneg;
+	u32	rx_pause;
+	u32	tx_pause;
+};
+
+#endif /* 2.4.20 => 2.4.18 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22) )
+#define pci_name(x)	((x)->slot_name)
+#endif
+
+#endif /* __E100_KCOMPAT_H__ */
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_main.c linux-2.6.5.SUSE/drivers/net/e100-intel/e100_main.c
--- linux-2.6.5/drivers/net/e100-intel/e100_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_main.c	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,4610 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  e100_main.c                                           *
+*                                                                     *
+* Abstract:     Functions for the driver entry points like load,      *
+*               unload, open and close. All board specific calls made *
+*               by the network interface section of the driver.       *
+*                                                                     *
+* Environment:  This file is intended to be specific to the Linux     *
+*               operating system.                                     *
+*                                                                     *
+**********************************************************************/
+
+/* Change Log
+ * 
+ * 2.3.40       2/13/04
+ * o Updated microcode for D102 rev 15 and rev 16 to include fix
+ *   for TCO issue.  NFS packets would be misinterpreted as TCO packets
+ *   and incorrectly routed to the BMC over SMBus.  The microcode fix
+ *   checks the fragmented IP bit in the NFS/UDP header to distinguish
+ *   between NFS and TCO.
+ * o Bug fix: don't strip MAC header count from Rx byte count.
+ *   Ben Greear (greear@candeltech.com).
+ *
+ * 2.3.38	12/14/03
+ * o Added netpoll support.
+ * o Added ICH6 device ID support
+ * o Moved to 2.6 APIs: pci_name() and free_netdev().
+ * o Removed some __devinit from some functions that shouldn't be marked
+ *   as such (Anton Blanchard [anton@samba.org]).
+ * 
+ * 2.3.33       10/21/03
+ */
+ 
+#undef __NO_VERSION__
+ 
+#include <linux/config.h>
+#include <net/checksum.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include "e100.h"
+#include "e100_ucode.h"
+#include "e100_config.h"
+#include "e100_phy.h"
+
+#ifdef E100_IA64_DMA_FIX
+#if !(defined __ia64__)
+#undef E100_IA64_DMA_FIX
+#endif
+#endif
+
+extern void e100_force_speed_duplex_to_phy(struct e100_private *bdp);
+
+#ifdef	ETHTOOL_GSTATS
+static char e100_gstrings_stats[][ETH_GSTRING_LEN] = {
+	"rx_packets", "tx_packets", "rx_bytes", "tx_bytes", "rx_errors",
+	"tx_errors", "rx_dropped", "tx_dropped", "multicast", "collisions",
+	"rx_length_errors", "rx_over_errors", "rx_crc_errors",
+	"rx_frame_errors", "rx_fifo_errors", "rx_missed_errors",
+	"tx_aborted_errors", "tx_carrier_errors", "tx_fifo_errors",
+	"tx_heartbeat_errors", "tx_window_errors",
+	/* device-specific stats */
+	"tx_late_collision_errors", "tx_deferred", 
+	"tx_single_collisions", "tx_multi_collisions", 
+	"rx_collision_detected_errors", "tx_flow_control_pause",
+	"rx_flow_control_pause", "rx_flow_control_unsupported",
+	"tx_tco_packets", "rx_tco_packets",
+};
+#define E100_NET_STATS_LEN	21
+#define E100_STATS_LEN	sizeof(e100_gstrings_stats) / ETH_GSTRING_LEN
+#endif	/* ETHTOOL_GSTATS */
+
+#ifdef SIOCETHTOOL
+static int e100_do_ethtool_ioctl(struct net_device *, struct ifreq *);
+static void e100_get_speed_duplex_caps(struct e100_private *);
+static int e100_ethtool_get_settings(struct net_device *, struct ifreq *);
+static int e100_ethtool_set_settings(struct net_device *, struct ifreq *);
+
+#ifdef ETHTOOL_GDRVINFO
+static int e100_ethtool_get_drvinfo(struct net_device *, struct ifreq *);
+#endif
+#ifdef ETHTOOL_GEEPROM
+static int e100_ethtool_eeprom(struct net_device *, struct ifreq *);
+
+#define E100_EEPROM_MAGIC 0x1234
+#endif
+#ifdef ETHTOOL_GLINK
+static int e100_ethtool_glink(struct net_device *, struct ifreq *);
+#endif
+#ifdef  ETHTOOL_GEEPROM  /* GREGS broken in earlier ethtool.h */
+#ifdef ETHTOOL_GREGS
+static int e100_ethtool_gregs(struct net_device *, struct ifreq *);
+#endif
+#endif
+#ifdef ETHTOOL_NWAY_RST
+static int e100_ethtool_nway_rst(struct net_device *, struct ifreq *);
+#endif
+#ifdef ETHTOOL_GWOL
+static int e100_ethtool_wol(struct net_device *, struct ifreq *);
+#endif
+#ifdef CONFIG_PM
+static unsigned char e100_setup_filter(struct e100_private *bdp);
+static void e100_do_wol(struct pci_dev *pcid, struct e100_private *bdp);
+#endif
+#ifdef ETHTOOL_SWOL
+static u16 e100_get_ip_lbytes(struct net_device *dev);
+#endif
+extern void e100_config_wol(struct e100_private *bdp);
+#ifdef ETHTOOL_TEST
+extern u32 e100_run_diag(struct net_device *dev, u64 *test_info, u32 flags);
+static int e100_ethtool_test(struct net_device *, struct ifreq *);
+#endif
+#ifdef ETHTOOL_GSTRINGS
+static int e100_ethtool_gstrings(struct net_device *, struct ifreq *);
+static char test_strings[][ETH_GSTRING_LEN] = {
+	"Link test     (on/offline)",
+	"Eeprom test   (on/offline)",
+	"Self test        (offline)",
+	"Mac loopback     (offline)",
+	"Phy loopback     (offline)",
+	"Cable diagnostic (offline)"
+};
+
+#endif
+#ifdef	ETHTOOL_PHYS_ID
+static int e100_ethtool_led_blink(struct net_device *, struct ifreq *);
+#endif
+#endif /*SIOCETHTOOL */
+
+#ifdef SIOCGMIIPHY
+static int e100_mii_ioctl(struct net_device *, struct ifreq *, int);
+#endif
+
+static unsigned char e100_delayed_exec_non_cu_cmd(struct e100_private *,
+						  nxmit_cb_entry_t *);
+static void e100_free_nontx_list(struct e100_private *);
+static void e100_non_tx_background(unsigned long);
+static inline void e100_tx_skb_free(struct e100_private *bdp, tcb_t *tcb);
+/* Global Data structures and variables */
+char e100_copyright[] __devinitdata = "Copyright (c) 2004 Intel Corporation";
+char e100_driver_version[]="2.3.40";
+const char *e100_full_driver_name = "Intel(R) PRO/100 Network Driver";
+char e100_short_driver_name[] = "e100";
+static int e100nics = 0;
+#ifdef NETIF_F_HW_VLAN_TX
+static void e100_vlan_rx_register(struct net_device *netdev, struct vlan_group
+		*grp);
+static void e100_vlan_rx_add_vid(struct net_device *netdev, u16 vid);
+static void e100_vlan_rx_kill_vid(struct net_device *netdev, u16 vid);
+#endif
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/* for netdump / net console */
+static void e100_netpoll (struct net_device *dev);
+#endif
+
+#ifdef CONFIG_PM
+static int e100_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
+static int e100_suspend(struct pci_dev *pcid, u32 state);
+static int e100_resume(struct pci_dev *pcid);
+static unsigned char e100_asf_enabled(struct e100_private *bdp);
+struct notifier_block e100_notifier_reboot = {
+        .notifier_call  = e100_notify_reboot,
+        .next           = NULL,
+        .priority       = 0
+};
+#endif
+
+/*********************************************************************/
+/*! This is a GCC extension to ANSI C.
+ *  See the item "Labeled Elements in Initializers" in the section
+ *  "Extensions to the C Language Family" of the GCC documentation.
+ *********************************************************************/
+#define E100_PARAM_INIT { [0 ... E100_MAX_NIC] = -1 }
+
+/* All parameters are treated the same, as an integer array of values.
+ * This macro just reduces the need to repeat the same declaration code
+ * over and over (plus this helps to avoid typo bugs).
+ */
+#define E100_PARAM(X, S)                                        \
+        static const int X[E100_MAX_NIC + 1] = E100_PARAM_INIT; \
+        MODULE_PARM(X, "1-" __MODULE_STRING(E100_MAX_NIC) "i"); \
+        MODULE_PARM_DESC(X, S);
+
+/* ====================================================================== */
+static u8 e100_D101M_checksum(struct e100_private *, struct sk_buff *);
+static u8 e100_D102_check_checksum(rfd_t *);
+static int e100_ioctl(struct net_device *, struct ifreq *, int);
+static int e100_change_mtu(struct net_device *, int);
+static int e100_xmit_frame(struct sk_buff *, struct net_device *);
+static unsigned char e100_init(struct e100_private *);
+static int e100_set_mac(struct net_device *, void *);
+struct net_device_stats *e100_get_stats(struct net_device *);
+
+static irqreturn_t e100intr(int, void *, struct pt_regs *);
+static void e100_print_brd_conf(struct e100_private *);
+static void e100_set_multi(struct net_device *);
+
+static u8 e100_pci_setup(struct pci_dev *, struct e100_private *);
+static u8 e100_sw_init(struct e100_private *);
+static void e100_tco_workaround(struct e100_private *);
+static unsigned char e100_alloc_space(struct e100_private *);
+static void e100_dealloc_space(struct e100_private *);
+static int e100_alloc_tcb_pool(struct e100_private *);
+static void e100_setup_tcb_pool(tcb_t *, unsigned int, struct e100_private *);
+static void e100_free_tcb_pool(struct e100_private *);
+static int e100_alloc_rfd_pool(struct e100_private *);
+static void e100_free_rfd_pool(struct e100_private *);
+
+static void e100_rd_eaddr(struct e100_private *);
+static void e100_rd_pwa_no(struct e100_private *);
+extern u16 e100_eeprom_read(struct e100_private *, u16);
+extern void e100_eeprom_write_block(struct e100_private *, u16, u16 *, u16);
+extern u16 e100_eeprom_size(struct e100_private *);
+u16 e100_eeprom_calculate_chksum(struct e100_private *adapter);
+
+static unsigned char e100_clr_cntrs(struct e100_private *);
+static unsigned char e100_load_microcode(struct e100_private *);
+static unsigned char e100_setup_iaaddr(struct e100_private *, u8 *);
+static unsigned char e100_update_stats(struct e100_private *bdp);
+
+static void e100_start_ru(struct e100_private *);
+static void e100_dump_stats_cntrs(struct e100_private *);
+
+static void e100_check_options(int board, struct e100_private *bdp);
+static void e100_set_int_option(int *, int, int, int, int, char *);
+static void e100_set_bool_option(struct e100_private *bdp, int, u32, int,
+				 char *);
+unsigned char e100_wait_exec_cmplx(struct e100_private *, u32, u8, u8);
+void e100_exec_cmplx(struct e100_private *, u32, u8);
+
+/**
+ * e100_get_rx_struct - retrieve cell to hold skb buff from the pool
+ * @bdp: atapter's private data struct
+ *
+ * Returns the new cell to hold sk_buff or %NULL.
+ */
+static inline struct rx_list_elem *
+e100_get_rx_struct(struct e100_private *bdp)
+{
+	struct rx_list_elem *rx_struct = NULL;
+
+	if (!list_empty(&(bdp->rx_struct_pool))) {
+		rx_struct = list_entry(bdp->rx_struct_pool.next,
+				       struct rx_list_elem, list_elem);
+		list_del(&(rx_struct->list_elem));
+	}
+
+	return rx_struct;
+}
+
+/**
+ * e100_alloc_skb - allocate an skb for the adapter
+ * @bdp: atapter's private data struct
+ *
+ * Allocates skb with enough room for rfd, and data, and reserve non-data space.
+ * Returns the new cell with sk_buff or %NULL.
+ */
+static inline struct rx_list_elem *
+e100_alloc_skb(struct e100_private *bdp)
+{
+	struct sk_buff *new_skb;
+	u32 skb_size = sizeof (rfd_t);
+	struct rx_list_elem *rx_struct;
+
+#ifdef E100_IA64_DMA_FIX
+	new_skb =
+		(struct sk_buff *) __dev_alloc_skb(skb_size,
+						   GFP_ATOMIC | GFP_DMA);
+	if (new_skb == NULL) {
+
+		new_skb = (struct sk_buff *) dev_alloc_skb(skb_size);
+	}
+#else
+	new_skb = (struct sk_buff *) dev_alloc_skb(skb_size);
+#endif
+	if (new_skb) {
+		/* The IP data should be 
+		   DWORD aligned. since the ethernet header is 14 bytes long, 
+		   we need to reserve 2 extra bytes so that the TCP/IP headers
+		   will be DWORD aligned. */
+		skb_reserve(new_skb, 2);
+		if ((rx_struct = e100_get_rx_struct(bdp)) == NULL)
+			goto err;
+		rx_struct->skb = new_skb;
+		rx_struct->dma_addr = pci_map_single(bdp->pdev, new_skb->data,
+						     sizeof (rfd_t),
+						     PCI_DMA_FROMDEVICE);
+		if (!rx_struct->dma_addr)
+			goto err;
+		skb_reserve(new_skb, bdp->rfd_size);
+		return rx_struct;
+	} else {
+		return NULL;
+	}
+
+err:
+	dev_kfree_skb_irq(new_skb);
+	return NULL;
+}
+
+/**
+ * e100_add_skb_to_end - add an skb to the end of our rfd list
+ * @bdp: atapter's private data struct
+ * @rx_struct: rx_list_elem with the new skb
+ *
+ * Adds a newly allocated skb to the end of our rfd list.
+ */
+inline void
+e100_add_skb_to_end(struct e100_private *bdp, struct rx_list_elem *rx_struct)
+{
+	rfd_t *rfdn;		/* The new rfd */
+	rfd_t *rfd;		/* The old rfd */
+	struct rx_list_elem *rx_struct_last;
+
+	(rx_struct->skb)->dev = bdp->device;
+	rfdn = RFD_POINTER(rx_struct->skb, bdp);
+	rfdn->rfd_header.cb_status = 0;
+	rfdn->rfd_header.cb_cmd = __constant_cpu_to_le16(RFD_EL_BIT);
+	rfdn->rfd_act_cnt = 0;
+	rfdn->rfd_sz = __constant_cpu_to_le16(RFD_DATA_SIZE);
+
+	pci_dma_sync_single(bdp->pdev, rx_struct->dma_addr, bdp->rfd_size,
+			    PCI_DMA_TODEVICE);
+
+	if (!list_empty(&(bdp->active_rx_list))) {
+		rx_struct_last = list_entry(bdp->active_rx_list.prev,
+					    struct rx_list_elem, list_elem);
+		rfd = RFD_POINTER(rx_struct_last->skb, bdp);
+		pci_dma_sync_single(bdp->pdev, rx_struct_last->dma_addr,
+				    4, PCI_DMA_FROMDEVICE);
+		put_unaligned(cpu_to_le32(rx_struct->dma_addr),
+			      ((u32 *) (&(rfd->rfd_header.cb_lnk_ptr))));
+
+		pci_dma_sync_single(bdp->pdev, rx_struct_last->dma_addr,
+				    8, PCI_DMA_TODEVICE);
+		rfd->rfd_header.cb_cmd &=
+			__constant_cpu_to_le16((u16) ~RFD_EL_BIT);
+
+		pci_dma_sync_single(bdp->pdev, rx_struct_last->dma_addr,
+				    4, PCI_DMA_TODEVICE);
+	}
+
+	list_add_tail(&(rx_struct->list_elem), &(bdp->active_rx_list));
+}
+
+static inline void
+e100_alloc_skbs(struct e100_private *bdp)
+{
+	for (; bdp->skb_req > 0; bdp->skb_req--) {
+		struct rx_list_elem *rx_struct;
+
+		if ((rx_struct = e100_alloc_skb(bdp)) == NULL)
+			return;
+
+		e100_add_skb_to_end(bdp, rx_struct);
+	}
+}
+
+void e100_tx_srv(struct e100_private *);
+u32 e100_rx_srv(struct e100_private *);
+
+void e100_watchdog(struct net_device *);
+void e100_refresh_txthld(struct e100_private *);
+void e100_manage_adaptive_ifs(struct e100_private *);
+void e100_clear_pools(struct e100_private *);
+static void e100_clear_structs(struct net_device *);
+static inline tcb_t *e100_prepare_xmit_buff(struct e100_private *,
+					    struct sk_buff *);
+static void e100_set_multi_exec(struct net_device *dev);
+
+MODULE_AUTHOR("Intel Corporation, <linux.nics@intel.com>");
+MODULE_DESCRIPTION("Intel(R) PRO/100 Network Driver");
+MODULE_LICENSE("GPL");
+
+E100_PARAM(TxDescriptors, "Number of transmit descriptors");
+E100_PARAM(RxDescriptors, "Number of receive descriptors");
+E100_PARAM(XsumRX, "Disable or enable Receive Checksum offload");
+E100_PARAM(e100_speed_duplex, "Speed and Duplex settings");
+E100_PARAM(ucode, "Disable or enable microcode loading");
+E100_PARAM(ber, "Value for the BER correction algorithm");
+E100_PARAM(flow_control, "Disable or enable Ethernet PAUSE frames processing");
+E100_PARAM(IntDelay, "Value for CPU saver's interrupt delay");
+E100_PARAM(BundleSmallFr, "Disable or enable interrupt bundling of small frames");
+E100_PARAM(BundleMax, "Maximum number for CPU saver's packet bundling");
+E100_PARAM(IFS, "Disable or enable the adaptive IFS algorithm");
+
+/**
+ * e100_exec_cmd - issue a comand
+ * @bdp: atapter's private data struct
+ * @scb_cmd_low: the command that is to be issued
+ *
+ * This general routine will issue a command to the e100.
+ */
+static inline void
+e100_exec_cmd(struct e100_private *bdp, u8 cmd_low)
+{
+	writeb(cmd_low, &(bdp->scb->scb_cmd_low));
+	readw(&(bdp->scb->scb_status));	/* flushes last write, read-safe */
+}
+
+/**
+ * e100_wait_scb - wait for SCB to clear
+ * @bdp: atapter's private data struct
+ *
+ * This routine checks to see if the e100 has accepted a command.
+ * It does so by checking the command field in the SCB, which will
+ * be zeroed by the e100 upon accepting a command.  The loop waits
+ * for up to 1 millisecond for command acceptance.
+ *
+ * Returns:
+ *      true if the SCB cleared within 1 millisecond.
+ *      false if it didn't clear within 1 millisecond
+ */
+unsigned char
+e100_wait_scb(struct e100_private *bdp)
+{
+	int i;
+
+	/* loop on the scb for a few times */
+	for (i = 0; i < 100; i++) {
+		if (!readb(&bdp->scb->scb_cmd_low))
+			return true;
+		cpu_relax();
+	}
+
+	/* it didn't work. do it the slow way using udelay()s */
+	for (i = 0; i < E100_MAX_SCB_WAIT; i++) {
+		if (!readb(&bdp->scb->scb_cmd_low))
+			return true;
+		cpu_relax();
+		udelay(1);
+	}
+
+	return false;
+}
+
+/**
+ * e100_wait_exec_simple - issue a command
+ * @bdp: atapter's private data struct
+ * @scb_cmd_low: the command that is to be issued
+ *
+ * This general routine will issue a command to the e100 after waiting for
+ * the previous command to finish.
+ *
+ * Returns:
+ *      true if the command was issued to the chip successfully
+ *      false if the command was not issued to the chip
+ */
+inline unsigned char
+e100_wait_exec_simple(struct e100_private *bdp, u8 scb_cmd_low)
+{
+	if (!e100_wait_scb(bdp)) {
+		printk(KERN_DEBUG "e100: %s: e100_wait_exec_simple: failed\n",
+		       bdp->device->name);
+#ifdef E100_CU_DEBUG		
+		printk(KERN_ERR "e100: %s: Last command (%x/%x) "
+			"timeout\n", bdp->device->name, 
+			bdp->last_cmd, bdp->last_sub_cmd);
+		printk(KERN_ERR "e100: %s: Current simple command (%x) "
+			"can't be executed\n", 
+			bdp->device->name, scb_cmd_low);
+#endif		
+		return false;
+	}
+	e100_exec_cmd(bdp, scb_cmd_low);
+#ifdef E100_CU_DEBUG	
+	bdp->last_cmd = scb_cmd_low;
+	bdp->last_sub_cmd = 0;
+#endif	
+	return true;
+}
+
+void
+e100_exec_cmplx(struct e100_private *bdp, u32 phys_addr, u8 cmd)
+{
+	writel(phys_addr, &(bdp->scb->scb_gen_ptr));
+	readw(&(bdp->scb->scb_status));	/* flushes last write, read-safe */
+	e100_exec_cmd(bdp, cmd);
+}
+
+unsigned char
+e100_wait_exec_cmplx(struct e100_private *bdp, u32 phys_addr, u8 cmd, u8 sub_cmd)
+{
+	if (!e100_wait_scb(bdp)) {
+#ifdef E100_CU_DEBUG		
+		printk(KERN_ERR "e100: %s: Last command (%x/%x) "
+			"timeout\n", bdp->device->name, 
+			bdp->last_cmd, bdp->last_sub_cmd);
+		printk(KERN_ERR "e100: %s: Current complex command "
+			"(%x/%x) can't be executed\n", 
+			bdp->device->name, cmd, sub_cmd);
+#endif		
+		return false;
+	}
+	e100_exec_cmplx(bdp, phys_addr, cmd);
+#ifdef E100_CU_DEBUG	
+	bdp->last_cmd = cmd;
+	bdp->last_sub_cmd = sub_cmd;
+#endif	
+	return true;
+}
+
+inline u8
+e100_wait_cus_idle(struct e100_private *bdp)
+{
+	int i;
+
+	/* loop on the scb for a few times */
+	for (i = 0; i < 100; i++) {
+		if (((readw(&(bdp->scb->scb_status)) & SCB_CUS_MASK) !=
+		     SCB_CUS_ACTIVE)) {
+			return true;
+		}
+		cpu_relax();
+	}
+
+	for (i = 0; i < E100_MAX_CU_IDLE_WAIT; i++) {
+		if (((readw(&(bdp->scb->scb_status)) & SCB_CUS_MASK) !=
+		     SCB_CUS_ACTIVE)) {
+			return true;
+		}
+		cpu_relax();
+		udelay(1);
+	}
+
+	return false;
+}
+
+/**
+ * e100_disable_clear_intr - disable and clear/ack interrupts
+ * @bdp: atapter's private data struct
+ *
+ * This routine disables interrupts at the hardware, by setting
+ * the M (mask) bit in the adapter's CSR SCB command word.
+ * It also clear/ack interrupts.
+ */
+static inline void
+e100_disable_clear_intr(struct e100_private *bdp)
+{
+	u16 intr_status;
+	/* Disable interrupts on our PCI board by setting the mask bit */
+	writeb(SCB_INT_MASK, &bdp->scb->scb_cmd_hi);
+	intr_status = readw(&bdp->scb->scb_status);
+	/* ack and clear intrs */
+	writew(intr_status, &bdp->scb->scb_status);
+	readw(&bdp->scb->scb_status);
+}
+
+/**
+ * e100_set_intr_mask - set interrupts
+ * @bdp: atapter's private data struct
+ *
+ * This routine sets interrupts at the hardware, by resetting
+ * the M (mask) bit in the adapter's CSR SCB command word
+ */
+static inline void
+e100_set_intr_mask(struct e100_private *bdp)
+{
+	writeb(bdp->intr_mask, &bdp->scb->scb_cmd_hi);
+	readw(&(bdp->scb->scb_status)); /* flushes last write, read-safe */
+}
+
+static inline void
+e100_trigger_SWI(struct e100_private *bdp)
+{
+	/* Trigger interrupt on our PCI board by asserting SWI bit */
+	writeb(SCB_SOFT_INT, &bdp->scb->scb_cmd_hi);
+	readw(&(bdp->scb->scb_status));	/* flushes last write, read-safe */
+}
+
+static int __devinit
+e100_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
+{
+	static int first_time = true;
+	struct net_device *dev = NULL;
+	struct e100_private *bdp = NULL;
+	int rc = 0;
+	u16 cal_checksum, read_checksum;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+	dev = init_etherdev(NULL, sizeof (struct e100_private));
+#else
+	dev = alloc_etherdev(sizeof (struct e100_private));
+#endif
+	if (dev == NULL) {
+		printk(KERN_ERR "e100: Not able to alloc etherdev struct\n");
+		rc = -ENODEV;
+		goto out;
+	}
+
+	SET_MODULE_OWNER(dev);
+
+	if (first_time) {
+		first_time = false;
+        	printk(KERN_NOTICE "%s - version %s\n",
+	               e100_full_driver_name, e100_driver_version);
+		printk(KERN_NOTICE "%s\n", e100_copyright);
+		printk(KERN_NOTICE "\n");
+	}
+
+	bdp = dev->priv;
+	bdp->pdev = pcid;
+	bdp->device = dev;
+
+	pci_set_drvdata(pcid, dev);
+	SET_NETDEV_DEV(dev, &pcid->dev);
+
+	bdp->flags = 0;
+	bdp->ifs_state = 0;
+	bdp->ifs_value = 0;
+	bdp->scb = 0;
+
+	init_timer(&bdp->nontx_timer_id);
+	bdp->nontx_timer_id.data = (unsigned long) bdp;
+	bdp->nontx_timer_id.function = (void *) &e100_non_tx_background;
+	INIT_LIST_HEAD(&(bdp->non_tx_cmd_list));
+	bdp->non_tx_command_state = E100_NON_TX_IDLE;
+
+	init_timer(&bdp->watchdog_timer);
+	bdp->watchdog_timer.data = (unsigned long) dev;
+	bdp->watchdog_timer.function = (void *) &e100_watchdog;
+
+	if ((rc = e100_pci_setup(pcid, bdp)) != 0) {
+		goto err_dev;
+	}
+
+	if ((rc = e100_alloc_space(bdp)) != 0) {
+		goto err_pci;
+	}
+
+	if (((bdp->pdev->device > 0x1030)
+	       && (bdp->pdev->device < 0x103F))
+	    || ((bdp->pdev->device >= 0x1050)
+	       && (bdp->pdev->device <= 0x1057))
+	    || ((bdp->pdev->device >= 0x1064)
+	       && (bdp->pdev->device <= 0x106B))
+	    || (bdp->pdev->device == 0x2449)
+	    || (bdp->pdev->device == 0x2459)
+	    || (bdp->pdev->device == 0x245D)) {
+		bdp->rev_id = D101MA_REV_ID;	/* workaround for ICH3 */
+		bdp->flags |= IS_ICH;
+	}
+
+	if (bdp->rev_id == 0xff)
+		bdp->rev_id = 1;
+
+	if ((u8) bdp->rev_id >= D101A4_REV_ID)
+		bdp->flags |= IS_BACHELOR;
+
+	if ((u8) bdp->rev_id >= D102_REV_ID) {
+		bdp->flags |= USE_IPCB;
+		bdp->rfd_size = 32;
+	} else {
+		bdp->rfd_size = 16;
+	}
+
+#ifdef NETIF_F_HW_VLAN_TX
+	dev->vlan_rx_register = e100_vlan_rx_register;
+	dev->vlan_rx_add_vid = e100_vlan_rx_add_vid;
+	dev->vlan_rx_kill_vid = e100_vlan_rx_kill_vid;
+#endif
+	dev->irq = pcid->irq;
+	dev->open = &e100_open;
+	dev->hard_start_xmit = &e100_xmit_frame;
+	dev->stop = &e100_close;
+	dev->change_mtu = &e100_change_mtu;
+	dev->get_stats = &e100_get_stats;
+	dev->set_multicast_list = &e100_set_multi;
+	dev->set_mac_address = &e100_set_mac;
+	dev->do_ioctl = &e100_ioctl;
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = e100_netpoll;
+#endif
+
+#ifdef MAX_SKB_FRAGS
+	if (bdp->flags & USE_IPCB)
+#ifdef NETIF_F_HW_VLAN_TX
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM |
+			NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+#else
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM;
+#endif /* NETIF_F_HW_VLAN_TX */
+#endif /* MAX_SKB_FRAGS */
+		
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4)
+	if ((rc = register_netdev(dev)) != 0) {
+		goto err_dealloc;
+	}
+#endif
+
+	e100_check_options(e100nics, bdp);
+
+	if (!e100_init(bdp)) {
+		printk(KERN_ERR "e100: Failed to initialize, instance #%d\n",
+		       e100nics);
+		rc = -ENODEV;
+		goto err_unregister_netdev;
+	}
+
+	/* Check if checksum is valid */
+	cal_checksum = e100_eeprom_calculate_chksum(bdp);
+	read_checksum = e100_eeprom_read(bdp, (bdp->eeprom_size - 1));
+	if (cal_checksum != read_checksum) {
+                printk(KERN_ERR "e100: Corrupted EEPROM on instance #%d\n",
+		       e100nics);
+                rc = -ENODEV;
+                goto err_unregister_netdev;
+	}
+	
+	e100nics++;
+
+#ifdef SIOCETHTOOL
+	e100_get_speed_duplex_caps(bdp);
+#endif /*SIOCETHTOOL */
+
+	printk(KERN_NOTICE
+	       "e100: %s: %s\n", 
+	       bdp->device->name, "Intel(R) PRO/100 Network Connection");
+	e100_print_brd_conf(bdp);
+
+	bdp->wolsupported = 0;
+	bdp->wolopts = 0;
+	if (bdp->rev_id >= D101A4_REV_ID)
+		bdp->wolsupported = WAKE_PHY | WAKE_MAGIC;
+	if (bdp->rev_id >= D101MA_REV_ID)
+		bdp->wolsupported |= WAKE_UCAST | WAKE_ARP;
+	
+	/* Check if WoL is enabled on EEPROM */
+	if (e100_eeprom_read(bdp, EEPROM_ID_WORD) & BIT_5) {
+		/* Magic Packet WoL is enabled on device by default */
+		/* if EEPROM WoL bit is TRUE                        */
+		bdp->wolopts = WAKE_MAGIC;
+	}
+
+#ifdef STB_WA
+	if (bdp->rev_id >= D101MA_REV_ID) {
+		u16 id_reg;
+
+		id_reg = e100_eeprom_read(bdp, EEPROM_ID_WORD);
+
+		if (id_reg & (0x02)) {
+			id_reg &= ((u16) (~0x02));
+			e100_eeprom_write_block(bdp, EEPROM_ID_WORD,
+						&id_reg, 1);
+			printk(KERN_NOTICE
+			       "e100: %s Changed the eeprom values\n", 
+			       dev->name);
+			printk(KERN_NOTICE
+			       "e100: for sane operation, "
+			       "a reboot is required\n");
+		}
+	}
+#endif
+	printk(KERN_NOTICE "\n");
+
+	goto out;
+
+err_unregister_netdev:
+	unregister_netdev(dev);
+err_dealloc:
+	e100_dealloc_space(bdp);
+err_pci:
+	iounmap(bdp->scb);
+	pci_release_regions(pcid);
+	pci_disable_device(pcid);
+err_dev:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+	unregister_netdev(dev);
+#endif
+	pci_set_drvdata(pcid, NULL);
+	free_netdev(dev);
+out:
+	return rc;
+}
+
+/**
+ * e100_clear_structs - free resources
+ * @dev: adapter's net_device struct
+ *
+ * Free all device specific structs, unmap i/o address, etc.
+ */
+static void __devexit
+e100_clear_structs(struct net_device *dev)
+{
+	struct e100_private *bdp = dev->priv;
+
+	iounmap(bdp->scb);
+	pci_release_regions(bdp->pdev);
+	pci_disable_device(bdp->pdev);
+
+	e100_dealloc_space(bdp);
+	pci_set_drvdata(bdp->pdev, NULL);
+	free_netdev(dev);
+}
+
+static void __devexit
+e100_remove1(struct pci_dev *pcid)
+{
+	struct net_device *dev;
+	struct e100_private *bdp;
+
+	if (!(dev = (struct net_device *) pci_get_drvdata(pcid)))
+		return;
+
+	bdp = dev->priv;
+
+	unregister_netdev(dev);
+
+	e100_sw_reset(bdp, PORT_SELECTIVE_RESET);
+
+	if (bdp->non_tx_command_state != E100_NON_TX_IDLE) {
+		del_timer_sync(&bdp->nontx_timer_id);
+		e100_free_nontx_list(bdp);
+		bdp->non_tx_command_state = E100_NON_TX_IDLE;
+	}
+
+	e100_clear_structs(dev);
+
+	--e100nics;
+}
+
+static struct pci_device_id e100_id_table[] = {
+	{0x8086, 0x1229, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x2449, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1059, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1209, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+  	{0x8086, 0x1029, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1030, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },	
+	{0x8086, 0x1031, PCI_ANY_ID, PCI_ANY_ID, 0, 0, }, 
+	{0x8086, 0x1032, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1033, PCI_ANY_ID, PCI_ANY_ID, 0, 0, }, 
+	{0x8086, 0x1034, PCI_ANY_ID, PCI_ANY_ID, 0, 0, }, 
+	{0x8086, 0x1038, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1039, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x103A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x103B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x103C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x103D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x103E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1051, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1053, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1054, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1064, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1065, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1066, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1067, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1068, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x1069, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x106A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x106B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x2459, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0x8086, 0x245D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{0,} /* This has to be the last entry*/
+};
+MODULE_DEVICE_TABLE(pci, e100_id_table);
+
+static struct pci_driver e100_driver = {
+	.name         = "e100",
+	.id_table     = e100_id_table,
+	.probe        = e100_found1,
+	.remove       = __devexit_p(e100_remove1),
+#ifdef CONFIG_PM
+	.suspend      = e100_suspend,
+	.resume       = e100_resume,
+#endif
+};
+#ifdef E100_IA64_DMA_FIX
+static int non_DMA32_memory_present;
+#endif
+
+static int __init
+e100_init_module(void)
+{
+	int ret;
+#ifdef E100_IA64_DMA_FIX
+	struct sysinfo si;
+
+	si_meminfo(&si);
+	if (si.totalram >= (0x100000000UL) / PAGE_SIZE) {
+		non_DMA32_memory_present = 1;
+	} else {
+		non_DMA32_memory_present = 0;
+	}
+#endif
+        ret = pci_module_init(&e100_driver);
+
+	if(ret >= 0) {
+#ifdef CONFIG_PM
+		register_reboot_notifier(&e100_notifier_reboot);
+#endif 
+	}
+
+	return ret;
+}
+
+static void __exit
+e100_cleanup_module(void)
+{
+#ifdef CONFIG_PM	
+	unregister_reboot_notifier(&e100_notifier_reboot);
+#endif 
+
+	pci_unregister_driver(&e100_driver);
+}
+
+module_init(e100_init_module);
+module_exit(e100_cleanup_module);
+
+/**
+ * e100_check_options - check command line options
+ * @board: board number
+ * @bdp: atapter's private data struct
+ *
+ * This routine does range checking on command-line options
+ */
+void __devinit
+e100_check_options(int board, struct e100_private *bdp)
+{
+	if (board >= E100_MAX_NIC) {
+		printk(KERN_NOTICE 
+		       "e100: No configuration available for board #%d\n",
+		       board);
+		printk(KERN_NOTICE "e100: Using defaults for all values\n");
+		board = E100_MAX_NIC;
+	}
+
+	e100_set_int_option(&(bdp->params.TxDescriptors), TxDescriptors[board],
+			    E100_MIN_TCB, E100_MAX_TCB, E100_DEFAULT_TCB,
+			    "TxDescriptor count");
+
+	e100_set_int_option(&(bdp->params.RxDescriptors), RxDescriptors[board],
+			    E100_MIN_RFD, E100_MAX_RFD, E100_DEFAULT_RFD,
+			    "RxDescriptor count");
+
+	e100_set_int_option(&(bdp->params.e100_speed_duplex),
+			    e100_speed_duplex[board], 0, 4,
+			    E100_DEFAULT_SPEED_DUPLEX, "speed/duplex mode");
+
+	e100_set_int_option(&(bdp->params.ber), ber[board], 0, ZLOCK_MAX_ERRORS,
+			    E100_DEFAULT_BER, "Bit Error Rate count");
+
+	e100_set_bool_option(bdp, XsumRX[board], PRM_XSUMRX, E100_DEFAULT_XSUM,
+			     "XsumRX value");
+
+	/* Default ucode value depended on controller revision */
+	if (bdp->rev_id >= D101MA_REV_ID) {
+		e100_set_bool_option(bdp, ucode[board], PRM_UCODE,
+				     E100_DEFAULT_UCODE, "ucode value");
+	} else {
+		e100_set_bool_option(bdp, ucode[board], PRM_UCODE, false,
+				     "ucode value");
+	}
+
+	e100_set_bool_option(bdp, flow_control[board], PRM_FC, E100_DEFAULT_FC,
+			     "flow control value");
+
+	e100_set_bool_option(bdp, IFS[board], PRM_IFS, E100_DEFAULT_IFS,
+			     "IFS value");
+
+	e100_set_bool_option(bdp, BundleSmallFr[board], PRM_BUNDLE_SMALL,
+			     E100_DEFAULT_BUNDLE_SMALL_FR,
+			     "CPU saver bundle small frames value");
+
+	e100_set_int_option(&(bdp->params.IntDelay), IntDelay[board], 0x0,
+			    0xFFFF, E100_DEFAULT_CPUSAVER_INTERRUPT_DELAY,
+			    "CPU saver interrupt delay value");
+
+	e100_set_int_option(&(bdp->params.BundleMax), BundleMax[board], 0x1,
+			    0xFFFF, E100_DEFAULT_CPUSAVER_BUNDLE_MAX,
+			    "CPU saver bundle max value");
+
+}
+
+/**
+ * e100_set_int_option - check and set an integer option
+ * @option: a pointer to the relevant option field
+ * @val: the value specified
+ * @min: the minimum valid value
+ * @max: the maximum valid value
+ * @default_val: the default value
+ * @name: the name of the option
+ *
+ * This routine does range checking on a command-line option.
+ * If the option's value is '-1' use the specified default.
+ * Otherwise, if the value is invalid, change it to the default.
+ */
+void __devinit
+e100_set_int_option(int *option, int val, int min, int max, int default_val,
+		    char *name)
+{
+	if (val == -1) {	/* no value specified. use default */
+		*option = default_val;
+
+	} else if ((val < min) || (val > max)) {
+		printk(KERN_NOTICE
+		       "e100: Invalid %s specified (%i). "
+		       "Valid range is %i-%i\n",
+		       name, val, min, max);
+		printk(KERN_NOTICE "e100: Using default %s of %i\n", name,
+		       default_val);
+		*option = default_val;
+	} else {
+		printk(KERN_INFO "e100: Using specified %s of %i\n", name, val);
+		*option = val;
+	}
+}
+
+/**
+ * e100_set_bool_option - check and set a boolean option
+ * @bdp: atapter's private data struct
+ * @val: the value specified
+ * @mask: the mask for the relevant option
+ * @default_val: the default value
+ * @name: the name of the option
+ *
+ * This routine checks a boolean command-line option.
+ * If the option's value is '-1' use the specified default.
+ * Otherwise, if the value is invalid (not 0 or 1), 
+ * change it to the default.
+ */
+void __devinit
+e100_set_bool_option(struct e100_private *bdp, int val, u32 mask,
+		     int default_val, char *name)
+{
+	if (val == -1) {
+		if (default_val)
+			bdp->params.b_params |= mask;
+
+	} else if ((val != true) && (val != false)) {
+		printk(KERN_NOTICE
+		       "e100: Invalid %s specified (%i). "
+		       "Valid values are %i/%i\n",
+		       name, val, false, true);
+		printk(KERN_NOTICE "e100: Using default %s of %i\n", name,
+		       default_val);
+
+		if (default_val)
+			bdp->params.b_params |= mask;
+	} else {
+		printk(KERN_INFO "e100: Using specified %s of %i\n", name, val);
+		if (val)
+			bdp->params.b_params |= mask;
+	}
+}
+
+int
+e100_open(struct net_device *dev)
+{
+	struct e100_private *bdp;
+	int rc = 0;
+
+	bdp = dev->priv;
+
+	/* setup the tcb pool */
+	if (!e100_alloc_tcb_pool(bdp)) {
+		rc = -ENOMEM;
+		goto err_exit;
+	}
+	bdp->last_tcb = NULL;
+
+	bdp->tcb_pool.head = 0;
+	bdp->tcb_pool.tail = 1;	
+
+	e100_setup_tcb_pool((tcb_t *) bdp->tcb_pool.data,
+			    bdp->params.TxDescriptors, bdp);
+
+	if (!e100_alloc_rfd_pool(bdp)) {
+		rc = -ENOMEM;
+		goto err_exit;
+	}
+
+	if (!e100_wait_exec_cmplx(bdp, 0, SCB_CUC_LOAD_BASE, 0)) {
+		rc = -EAGAIN;
+		goto err_exit;
+	}
+
+	if (!e100_wait_exec_cmplx(bdp, 0, SCB_RUC_LOAD_BASE, 0)) {
+		rc = -EAGAIN;
+		goto err_exit;
+	}
+
+	mod_timer(&(bdp->watchdog_timer), jiffies + (2 * HZ));
+
+	if (dev->flags & IFF_UP)
+		/* Otherwise process may sleep forever */
+		netif_wake_queue(dev);
+	else
+		netif_start_queue(dev);
+
+	e100_start_ru(bdp);
+	if ((rc = request_irq(dev->irq, &e100intr, SA_SHIRQ,
+			      dev->name, dev)) != 0) {
+		del_timer_sync(&bdp->watchdog_timer);
+		goto err_exit;
+	}
+	bdp->intr_mask = 0;
+	e100_set_intr_mask(bdp);
+
+	e100_force_config(bdp);
+
+	goto exit;
+
+err_exit:
+	e100_clear_pools(bdp);
+exit:
+	return rc;
+}
+
+int
+e100_close(struct net_device *dev)
+{
+	struct e100_private *bdp = dev->priv;
+
+	e100_disable_clear_intr(bdp);
+	free_irq(dev->irq, dev);
+	bdp->intr_mask = SCB_INT_MASK;
+	e100_isolate_driver(bdp);
+
+	netif_carrier_off(bdp->device);
+	bdp->cur_line_speed = 0;
+	bdp->cur_dplx_mode = 0;
+	e100_clear_pools(bdp);
+
+	return 0;
+}
+
+static int
+e100_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if ((new_mtu < 68) || (new_mtu > (ETH_DATA_LEN + VLAN_SIZE)))
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+static int
+e100_xmit_frame(struct sk_buff *skb, struct net_device *dev)
+{
+	int rc = 0;
+	int notify_stop = false;
+	struct e100_private *bdp = dev->priv;
+
+	if (!spin_trylock(&bdp->bd_non_tx_lock)) {
+		notify_stop = true;
+		rc = 1;
+		goto exit2;
+	}
+
+	/* tcb list may be empty temporarily during releasing resources */
+	if (!TCBS_AVAIL(bdp->tcb_pool) || (bdp->tcb_phys == 0) ||
+	    (bdp->non_tx_command_state != E100_NON_TX_IDLE)) {
+		notify_stop = true;
+		rc = 1;
+		goto exit1;
+	}
+#ifdef E100_IA64_DMA_FIX
+	if ((u64) skb->head >= (PAGE_OFFSET + 0x100000000UL))
+		skb_linearize(skb, GFP_ATOMIC | GFP_DMA);
+#endif
+
+	bdp->drv_stats.net_stats.tx_bytes += skb->len;
+
+	e100_prepare_xmit_buff(bdp, skb);
+
+	dev->trans_start = jiffies;
+
+exit1:
+	spin_unlock(&bdp->bd_non_tx_lock);
+exit2:
+	if (notify_stop) {
+		netif_stop_queue(dev);
+	}
+
+	return rc;
+}
+
+/**
+ * e100_get_stats - get driver statistics
+ * @dev: adapter's net_device struct
+ *
+ * This routine is called when the OS wants the adapter's stats returned.
+ * It returns the address of the net_device_stats stucture for the device.
+ * If the statistics are currently being updated, then they might be incorrect
+ * for a short while. However, since this cannot actually cause damage, no
+ * locking is used.
+ */
+struct net_device_stats *
+e100_get_stats(struct net_device *dev)
+{
+	struct e100_private *bdp = dev->priv;
+
+	bdp->drv_stats.net_stats.tx_errors =
+		bdp->drv_stats.net_stats.tx_carrier_errors +
+		bdp->drv_stats.net_stats.tx_aborted_errors;
+
+	bdp->drv_stats.net_stats.rx_errors =
+		bdp->drv_stats.net_stats.rx_crc_errors +
+		bdp->drv_stats.net_stats.rx_frame_errors +
+		bdp->drv_stats.net_stats.rx_length_errors +
+		bdp->drv_stats.rcv_cdt_frames;
+
+	return &(bdp->drv_stats.net_stats);
+}
+
+/**
+ * e100_set_mac - set the MAC address
+ * @dev: adapter's net_device struct
+ * @addr: the new address
+ *
+ * This routine sets the ethernet address of the board
+ * Returns:
+ * 0  - if successful
+ * -1 - otherwise
+ */
+static int
+e100_set_mac(struct net_device *dev, void *addr)
+{
+	struct e100_private *bdp;
+	int rc = -1;
+	struct sockaddr *p_sockaddr = (struct sockaddr *) addr;
+
+	if (!is_valid_ether_addr(p_sockaddr->sa_data))
+		return -EADDRNOTAVAIL;
+	bdp = dev->priv;
+
+	if (e100_setup_iaaddr(bdp, (u8 *) (p_sockaddr->sa_data))) {
+		memcpy(&(dev->dev_addr[0]), p_sockaddr->sa_data, ETH_ALEN);
+		rc = 0;
+	}
+
+	return rc;
+}
+
+static void
+e100_set_multi_exec(struct net_device *dev)
+{
+	struct e100_private *bdp = dev->priv;
+	mltcst_cb_t *mcast_buff;
+	cb_header_t *cb_hdr;
+	struct dev_mc_list *mc_list;
+	unsigned int i;
+	nxmit_cb_entry_t *cmd = e100_alloc_non_tx_cmd(bdp);
+
+	if (cmd != NULL) {
+		mcast_buff = &((cmd->non_tx_cmd)->ntcb.multicast);
+		cb_hdr = &((cmd->non_tx_cmd)->ntcb.multicast.mc_cbhdr);
+	} else {
+		return;
+	}
+
+	/* initialize the multi cast command */
+	cb_hdr->cb_cmd = __constant_cpu_to_le16(CB_MULTICAST);
+
+	/* now fill in the rest of the multicast command */
+	*(u16 *) (&(mcast_buff->mc_count)) = cpu_to_le16(dev->mc_count * 6);
+	for (i = 0, mc_list = dev->mc_list;
+	     (i < dev->mc_count) && (i < MAX_MULTICAST_ADDRS);
+	     i++, mc_list = mc_list->next) {
+		/* copy into the command */
+		memcpy(&(mcast_buff->mc_addr[i * ETH_ALEN]),
+		       (u8 *) &(mc_list->dmi_addr), ETH_ALEN);
+	}
+
+	if (!e100_exec_non_cu_cmd(bdp, cmd)) {
+		printk(KERN_WARNING "e100: %s: Multicast setup failed\n", 
+		       dev->name);
+	}
+}
+
+/**
+ * e100_set_multi - set multicast status
+ * @dev: adapter's net_device struct
+ *
+ * This routine is called to add or remove multicast addresses, and/or to
+ * change the adapter's promiscuous state.
+ */
+static void
+e100_set_multi(struct net_device *dev)
+{
+	struct e100_private *bdp = dev->priv;
+	unsigned char promisc_enbl;
+	unsigned char mulcast_enbl;
+
+	promisc_enbl = ((dev->flags & IFF_PROMISC) == IFF_PROMISC);
+	mulcast_enbl = ((dev->flags & IFF_ALLMULTI) ||
+			(dev->mc_count > MAX_MULTICAST_ADDRS));
+
+	e100_config_promisc(bdp, promisc_enbl);
+	e100_config_mulcast_enbl(bdp, mulcast_enbl);
+
+	/* reconfigure the chip if something has changed in its config space */
+	e100_config(bdp);
+
+	if (promisc_enbl || mulcast_enbl) {
+		return;	/* no need for Multicast Cmd */
+	}
+
+	/* get the multicast CB */
+	e100_set_multi_exec(dev);
+}
+
+static int
+e100_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+
+	switch (cmd) {
+
+#ifdef SIOCETHTOOL
+	case SIOCETHTOOL:
+		return e100_do_ethtool_ioctl(dev, ifr);
+		break;
+#endif /*SIOCETHTOOL */
+
+#ifdef SIOCGMIIPHY
+	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
+	case SIOCGMIIREG:	/* Read MII PHY register. */
+	case SIOCSMIIREG:	/* Write to MII PHY register. */
+		return e100_mii_ioctl(dev, ifr, cmd);
+		break;
+#endif /* SIOCGMIIPHY */
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+
+}
+
+/**
+ * e100init - initialize the adapter
+ * @bdp: atapter's private data struct
+ *
+ * This routine is called when this driver is loaded. This is the initialization
+ * routine which allocates memory, configures the adapter and determines the
+ * system resources.
+ *
+ * Returns:
+ *      true: if successful
+ *      false: otherwise
+ */
+static unsigned char __devinit
+e100_init(struct e100_private *bdp)
+{
+	u32 st_timeout = 0;
+	u32 st_result = 0;
+	e100_sw_init(bdp);
+
+	if (!e100_selftest(bdp, &st_timeout, &st_result)) {
+        	if (st_timeout) {
+			printk(KERN_ERR "e100: selftest timeout\n");
+		} else {
+			printk(KERN_ERR "e100: selftest failed. Results: %x\n",
+					st_result);
+		}
+		return false;
+	}
+	else
+		printk(KERN_DEBUG "e100: selftest OK.\n");
+
+	/* read the MAC address from the eprom */
+	e100_rd_eaddr(bdp);
+	if (!is_valid_ether_addr(bdp->device->dev_addr)) {
+		printk(KERN_ERR "e100: Invalid Ethernet address\n");
+		return false;
+	}
+	/* read NIC's part number */
+	e100_rd_pwa_no(bdp);
+
+	if (!e100_hw_init(bdp))
+		return false;
+	/* Interrupts are enabled after device reset */
+	e100_disable_clear_intr(bdp);
+
+	return true;
+}
+
+/**
+ * e100_sw_init - initialize software structs
+ * @bdp: atapter's private data struct
+ * 
+ * This routine initializes all software structures. Sets up the
+ * circular structures for the RFD's & TCB's. Allocates the per board
+ * structure for storing adapter information. The CSR is also memory 
+ * mapped in this routine.
+ *
+ * Returns :
+ *      true: if S/W was successfully initialized
+ *      false: otherwise
+ */
+static unsigned char __devinit
+e100_sw_init(struct e100_private *bdp)
+{
+	bdp->next_cu_cmd = START_WAIT;	// init the next cu state
+
+	/* 
+	 * Set the value for # of good xmits per underrun. the value assigned
+	 * here is an intelligent  suggested default. Nothing magical about it.
+	 */
+	bdp->tx_per_underrun = DEFAULT_TX_PER_UNDERRUN;
+
+	/* get the default transmit threshold value */
+	bdp->tx_thld = TX_THRSHLD;
+
+	/* get the EPROM size */
+	bdp->eeprom_size = e100_eeprom_size(bdp);
+
+	/* Initialize our spinlocks */
+	spin_lock_init(&(bdp->bd_lock));
+	spin_lock_init(&(bdp->bd_non_tx_lock));
+	spin_lock_init(&(bdp->config_lock));
+	spin_lock_init(&(bdp->mdi_access_lock));
+	/* Initialize configuration data */
+	e100_config_init(bdp);
+
+	return 1;
+}
+
+static void
+e100_tco_workaround(struct e100_private *bdp)
+{
+	int i;
+
+	/* Do software reset */
+	e100_sw_reset(bdp, PORT_SOFTWARE_RESET);
+
+	/* Do a dummy LOAD CU BASE command. */
+	/* This gets us out of pre-driver to post-driver. */
+	e100_exec_cmplx(bdp, 0, SCB_CUC_LOAD_BASE);
+
+	/* Wait 20 msec for reset to take effect */
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ / 50 + 1);
+
+	/* disable interrupts since they are enabled */
+	/* after device reset                        */
+	e100_disable_clear_intr(bdp);
+
+	/* Wait for command to be cleared up to 1 sec */
+	for (i=0; i<100; i++) {
+		if (!readb(&bdp->scb->scb_cmd_low))
+			break;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ / 100 + 1);
+	}
+
+	/* Wait for TCO request bit in PMDR register to be clear */
+	for (i=0; i<50; i++) {
+		if (!(readb(&bdp->scb->scb_ext.d101m_scb.scb_pmdr) & BIT_1))
+			break;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ / 100 + 1);
+	}
+}
+
+/**
+ * e100_hw_init - initialized tthe hardware
+ * @bdp: atapter's private data struct
+ *
+ * This routine performs a reset on the adapter, and configures the adapter.
+ * This includes configuring the 82557 LAN controller, validating and setting
+ * the node address, detecting and configuring the Phy chip on the adapter,
+ * and initializing all of the on chip counters.
+ *
+ * Returns:
+ *      true - If the adapter was initialized
+ *      false - If the adapter failed initialization
+ */
+unsigned char
+e100_hw_init(struct e100_private *bdp)
+{
+	if (!e100_phy_init(bdp))
+		goto err;
+
+	e100_sw_reset(bdp, PORT_SELECTIVE_RESET);
+
+	/* Only 82559 or above needs TCO workaround */
+	if (bdp->rev_id >= D101MA_REV_ID)
+		e100_tco_workaround(bdp);
+
+	/* Load the CU BASE (set to 0, because we use linear mode) */
+	if (!e100_wait_exec_cmplx(bdp, 0, SCB_CUC_LOAD_BASE, 0))
+		goto err;
+
+	if (!e100_wait_exec_cmplx(bdp, 0, SCB_RUC_LOAD_BASE, 0))
+		goto err;
+
+	/* Load interrupt microcode  */
+	if (e100_load_microcode(bdp)) {
+		bdp->flags |= DF_UCODE_LOADED;
+	}
+
+	if ((u8) bdp->rev_id < D101A4_REV_ID)
+		e100_config_init_82557(bdp);
+		
+	if (!e100_config(bdp))
+		goto err;
+
+	if (!e100_setup_iaaddr(bdp, bdp->device->dev_addr))
+		goto err;
+
+	/* Clear the internal counters */
+	if (!e100_clr_cntrs(bdp))
+		goto err;
+
+	/* Change for 82558 enhancement */
+	/* If 82558/9 and if the user has enabled flow control, set up the
+	 * Flow Control Reg. in the CSR */
+	if ((bdp->flags & IS_BACHELOR)
+	    && (bdp->params.b_params & PRM_FC)) {
+		writeb(DFLT_FC_THLD, &bdp->scb->scb_ext.d101_scb.scb_fc_thld);
+		writeb(DFLT_FC_CMD,
+		       &bdp->scb->scb_ext.d101_scb.scb_fc_xon_xoff);
+	}
+
+	return true;
+err:
+	printk(KERN_ERR "e100: hw init failed\n");
+	return false;
+}
+
+/**
+ * e100_setup_tcb_pool - setup TCB circular list
+ * @head: Pointer to head of the allocated TCBs
+ * @qlen: Number of elements in the queue
+ * @bdp: atapter's private data struct
+ * 
+ * This routine arranges the contigiously allocated TCB's in a circular list.
+ * Also does the one time initialization of the TCBs.
+ */
+static void
+e100_setup_tcb_pool(tcb_t *head, unsigned int qlen, struct e100_private *bdp)
+{
+	int ele_no;
+	tcb_t *pcurr_tcb;	/* point to current tcb */
+	u32 next_phys;		/* the next phys addr */
+	u16 txcommand = CB_S_BIT | CB_TX_SF_BIT;
+
+	bdp->tx_count = 0;
+	if (bdp->flags & USE_IPCB) {
+		txcommand |= CB_IPCB_TRANSMIT | CB_CID_DEFAULT;
+	} else if (bdp->flags & IS_BACHELOR) {
+		txcommand |= CB_TRANSMIT | CB_CID_DEFAULT;
+	} else {
+		txcommand |= CB_TRANSMIT;
+	}
+
+	for (ele_no = 0, next_phys = bdp->tcb_phys, pcurr_tcb = head;
+	     ele_no < qlen; ele_no++, pcurr_tcb++) {
+
+		/* set the phys addr for this TCB, next_phys has not incr. yet */
+		pcurr_tcb->tcb_phys = next_phys;
+		next_phys += sizeof (tcb_t);
+
+		/* set the link to next tcb */
+		if (ele_no == (qlen - 1))
+			pcurr_tcb->tcb_hdr.cb_lnk_ptr =
+				cpu_to_le32(bdp->tcb_phys);
+		else
+			pcurr_tcb->tcb_hdr.cb_lnk_ptr = cpu_to_le32(next_phys);
+
+		pcurr_tcb->tcb_hdr.cb_status = 0;
+		pcurr_tcb->tcb_hdr.cb_cmd = cpu_to_le16(txcommand);
+		pcurr_tcb->tcb_cnt = 0;	
+		pcurr_tcb->tcb_thrshld = bdp->tx_thld;	
+		if (ele_no < 2) {
+			pcurr_tcb->tcb_hdr.cb_status =
+				cpu_to_le16(CB_STATUS_COMPLETE);
+		}
+		pcurr_tcb->tcb_tbd_num = 1;
+
+		if (bdp->flags & IS_BACHELOR) {
+			pcurr_tcb->tcb_tbd_ptr =
+				__constant_cpu_to_le32(0xFFFFFFFF);
+		} else {
+			pcurr_tcb->tcb_tbd_ptr =
+				cpu_to_le32(pcurr_tcb->tcb_phys + 0x10);
+		}
+
+#ifdef MAX_SKB_FRAGS
+		if (bdp->flags & IS_BACHELOR) {
+			pcurr_tcb->tcb_tbd_expand_ptr =
+				cpu_to_le32(pcurr_tcb->tcb_phys + 0x20);
+		} else {
+			pcurr_tcb->tcb_tbd_expand_ptr =
+				cpu_to_le32(pcurr_tcb->tcb_phys + 0x10);
+		}
+		pcurr_tcb->tcb_tbd_dflt_ptr = pcurr_tcb->tcb_tbd_ptr;
+#endif
+
+		if (bdp->flags & USE_IPCB) {
+			pcurr_tcb->tbd_ptr = &(pcurr_tcb->tcbu.tbd_array[1]);
+			pcurr_tcb->tcbu.ipcb.ip_activation_high =
+				IPCB_IP_ACTIVATION_DEFAULT;
+			pcurr_tcb->tcbu.ipcb.vlan = 0;
+		} else {
+			pcurr_tcb->tbd_ptr = &(pcurr_tcb->tcbu.tbd_array[0]);
+		}
+
+		pcurr_tcb->tcb_skb = NULL;
+	}
+
+	wmb();
+}
+
+/***************************************************************************/
+/***************************************************************************/
+/*       Memory Management Routines                                        */
+/***************************************************************************/
+
+/**
+ * e100_alloc_space - allocate private driver data
+ * @bdp: atapter's private data struct
+ *
+ * This routine allocates memory for the driver. Memory allocated is for the
+ * selftest and statistics structures.
+ *
+ * Returns:
+ *      0: if the operation was successful
+ *      %-ENOMEM: if memory allocation failed
+ */
+unsigned char __devinit
+e100_alloc_space(struct e100_private *bdp)
+{
+	unsigned long off;
+
+	/* allocate all the dma-able structures in one call:
+	 * selftest results, adapter stats, and non-tx cb commands */
+	if (!(bdp->dma_able =
+	      pci_alloc_consistent(bdp->pdev, sizeof (bd_dma_able_t),
+				   &(bdp->dma_able_phys)))) {
+		goto err;
+	}
+
+	/* now assign the various pointers into the struct we've just allocated */
+	off = offsetof(bd_dma_able_t, selftest);
+
+	bdp->selftest = (self_test_t *) (bdp->dma_able + off);
+	bdp->selftest_phys = bdp->dma_able_phys + off;
+
+	off = offsetof(bd_dma_able_t, stats_counters);
+
+	bdp->stats_counters = (max_counters_t *) (bdp->dma_able + off);
+	bdp->stat_cnt_phys = bdp->dma_able_phys + off;
+
+	return 0;
+
+err:
+	printk(KERN_ERR
+	       "e100: Failed to allocate memory\n");
+	return -ENOMEM;
+}
+
+/**
+ * e100_alloc_tcb_pool - allocate TCB circular list
+ * @bdp: atapter's private data struct
+ *
+ * This routine allocates memory for the circular list of transmit descriptors.
+ *
+ * Returns:
+ *       0: if allocation has failed.
+ *       1: Otherwise. 
+ */
+int
+e100_alloc_tcb_pool(struct e100_private *bdp)
+{
+	int stcb = sizeof (tcb_t) * bdp->params.TxDescriptors;
+
+	/* allocate space for the TCBs */
+	if (!(bdp->tcb_pool.data =
+	      pci_alloc_consistent(bdp->pdev, stcb, &bdp->tcb_phys)))
+		return 0;
+
+	memset(bdp->tcb_pool.data, 0x00, stcb);
+
+	return 1;
+}
+
+void
+e100_free_tcb_pool(struct e100_private *bdp)
+{
+	tcb_t *tcb;
+	int i;
+	/* Return tx skbs */ 
+	for (i = 0; i < bdp->params.TxDescriptors; i++) {
+	  	tcb = bdp->tcb_pool.data;
+		tcb += bdp->tcb_pool.head;
+  		e100_tx_skb_free(bdp, tcb);
+		if (NEXT_TCB_TOUSE(bdp->tcb_pool.head) == bdp->tcb_pool.tail)
+		  	break;
+		bdp->tcb_pool.head = NEXT_TCB_TOUSE(bdp->tcb_pool.head);
+	}
+	pci_free_consistent(bdp->pdev,
+			    sizeof (tcb_t) * bdp->params.TxDescriptors,
+			    bdp->tcb_pool.data, bdp->tcb_phys);
+	bdp->tcb_pool.head = 0;
+	bdp->tcb_pool.tail = 1;	
+	bdp->tcb_phys = 0;
+}
+
+static void
+e100_dealloc_space(struct e100_private *bdp)
+{
+	if (bdp->dma_able) {
+		pci_free_consistent(bdp->pdev, sizeof (bd_dma_able_t),
+				    bdp->dma_able, bdp->dma_able_phys);
+	}
+
+	bdp->selftest_phys = 0;
+	bdp->stat_cnt_phys = 0;
+	bdp->dma_able_phys = 0;
+	bdp->dma_able = 0;
+}
+
+static void
+e100_free_rfd_pool(struct e100_private *bdp)
+{
+	struct rx_list_elem *rx_struct;
+
+	while (!list_empty(&(bdp->active_rx_list))) {
+
+		rx_struct = list_entry(bdp->active_rx_list.next,
+				       struct rx_list_elem, list_elem);
+		list_del(&(rx_struct->list_elem));
+		pci_unmap_single(bdp->pdev, rx_struct->dma_addr,
+				 sizeof (rfd_t), PCI_DMA_TODEVICE);
+		dev_kfree_skb(rx_struct->skb);
+		kfree(rx_struct);
+	}
+
+	while (!list_empty(&(bdp->rx_struct_pool))) {
+		rx_struct = list_entry(bdp->rx_struct_pool.next,
+				       struct rx_list_elem, list_elem);
+		list_del(&(rx_struct->list_elem));
+		kfree(rx_struct);
+	}
+}
+
+/**
+ * e100_alloc_rfd_pool - allocate RFDs
+ * @bdp: atapter's private data struct
+ *
+ * Allocates initial pool of skb which holds both rfd and data,
+ * and return a pointer to the head of the list
+ */
+static int
+e100_alloc_rfd_pool(struct e100_private *bdp)
+{
+	struct rx_list_elem *rx_struct;
+	int i;
+
+	INIT_LIST_HEAD(&(bdp->active_rx_list));
+	INIT_LIST_HEAD(&(bdp->rx_struct_pool));
+	bdp->skb_req = bdp->params.RxDescriptors;
+	for (i = 0; i < bdp->skb_req; i++) {
+		rx_struct = kmalloc(sizeof (struct rx_list_elem), GFP_ATOMIC);
+		list_add(&(rx_struct->list_elem), &(bdp->rx_struct_pool));
+	}
+	e100_alloc_skbs(bdp);
+	return !list_empty(&(bdp->active_rx_list));
+
+}
+
+void
+e100_clear_pools(struct e100_private *bdp)
+{
+	bdp->last_tcb = NULL;
+	e100_free_rfd_pool(bdp);
+	e100_free_tcb_pool(bdp);
+}
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*      Run Time Functions                                                   */
+/*****************************************************************************/
+
+/**
+ * e100_watchdog
+ * @dev: adapter's net_device struct
+ *
+ * This routine runs every 2 seconds and updates our statitics and link state,
+ * and refreshs txthld value.
+ */
+void
+e100_watchdog(struct net_device *dev)
+{
+	struct e100_private *bdp = dev->priv;
+
+#ifdef E100_CU_DEBUG
+	if (e100_cu_unknown_state(bdp)) {
+		printk(KERN_ERR "e100: %s: CU unknown state in e100_watchdog\n",
+			dev->name);
+	}
+#endif	
+	if (!netif_running(dev)) {
+		return;
+	}
+
+	/* check if link state has changed */
+	if (e100_phy_check(bdp)) {
+		if (netif_carrier_ok(dev)) {
+			printk(KERN_ERR
+			       "e100: %s NIC Link is Up %d Mbps %s duplex\n",
+			       bdp->device->name, bdp->cur_line_speed,
+			       (bdp->cur_dplx_mode == HALF_DUPLEX) ?
+			       "Half" : "Full");
+
+			e100_config_fc(bdp);
+			e100_config(bdp);  
+
+		} else {
+			printk(KERN_ERR "e100: %s NIC Link is Down\n",
+			       bdp->device->name);
+		}
+	}
+
+	// toggle the tx queue according to link status
+	// this also resolves a race condition between tx & non-cu cmd flows
+	if (netif_carrier_ok(dev)) {
+		if (netif_running(dev))
+			netif_wake_queue(dev);
+	} else {
+		if (netif_running(dev))
+			netif_stop_queue(dev);
+		/* When changing to non-autoneg, device may lose  */
+		/* link with some switches. e100 will try to      */
+		/* revover link by sending command to PHY layer   */
+		if (bdp->params.e100_speed_duplex != E100_AUTONEG)
+			e100_force_speed_duplex_to_phy(bdp);
+	}
+
+	rmb();
+
+	if (e100_update_stats(bdp)) {
+
+		/* Check if a change in the IFS parameter is needed,
+		   and configure the device accordingly */
+		if (bdp->params.b_params & PRM_IFS)
+			e100_manage_adaptive_ifs(bdp);
+
+		/* Now adjust our dynamic tx threshold value */
+		e100_refresh_txthld(bdp);
+
+		/* Now if we are on a 557 and we havn't received any frames then we
+		 * should issue a multicast command to reset the RU */
+		if (bdp->rev_id < D101A4_REV_ID) {
+			if (!(bdp->stats_counters->basic_stats.rcv_gd_frames)) {
+				e100_set_multi(dev);
+			}
+		}
+	}
+	/* Issue command to dump statistics from device.        */
+	/* Check for command completion on next watchdog timer. */
+	e100_dump_stats_cntrs(bdp);
+
+	wmb();
+
+	/* relaunch watchdog timer in 2 sec */
+	mod_timer(&(bdp->watchdog_timer), jiffies + (2 * HZ));
+
+	if (list_empty(&bdp->active_rx_list))
+		e100_trigger_SWI(bdp);
+}
+
+/**
+ * e100_manage_adaptive_ifs
+ * @bdp: atapter's private data struct
+ *
+ * This routine manages the adaptive Inter-Frame Spacing algorithm
+ * using a state machine.
+ */
+void
+e100_manage_adaptive_ifs(struct e100_private *bdp)
+{
+	static u16 state_table[9][4] = {	// rows are states
+		{2, 0, 0, 0},	// state0   // column0: next state if increasing
+		{2, 0, 5, 30},	// state1   // column1: next state if decreasing
+		{5, 1, 5, 30},	// state2   // column2: IFS value for 100 mbit
+		{5, 3, 0, 0},	// state3   // column3: IFS value for 10 mbit
+		{5, 3, 10, 60},	// state4
+		{8, 4, 10, 60},	// state5
+		{8, 6, 0, 0},	// state6
+		{8, 6, 20, 60},	// state7
+		{8, 7, 20, 60}	// state8
+	};
+
+	u32 transmits =
+		le32_to_cpu(bdp->stats_counters->basic_stats.xmt_gd_frames);
+	u32 collisions =
+		le32_to_cpu(bdp->stats_counters->basic_stats.xmt_ttl_coll);
+	u32 state = bdp->ifs_state;
+	u32 old_value = bdp->ifs_value;
+	int next_col;
+	u32 min_transmits;
+
+	if (bdp->cur_dplx_mode == FULL_DUPLEX) {
+		bdp->ifs_state = 0;
+		bdp->ifs_value = 0;
+
+	} else {		/* Half Duplex */
+		/* Set speed specific parameters */
+		if (bdp->cur_line_speed == 100) {
+			next_col = 2;
+			min_transmits = MIN_NUMBER_OF_TRANSMITS_100;
+
+		} else {	/* 10 Mbps */
+			next_col = 3;
+			min_transmits = MIN_NUMBER_OF_TRANSMITS_10;
+		}
+
+		if ((transmits / 32 < collisions)
+		    && (transmits > min_transmits)) {
+			state = state_table[state][0];	/* increment */
+
+		} else if (transmits < min_transmits) {
+			state = state_table[state][1];	/* decrement */
+		}
+
+		bdp->ifs_value = state_table[state][next_col];
+		bdp->ifs_state = state;
+	}
+
+	/* If the IFS value has changed, configure the device */
+	if (bdp->ifs_value != old_value) {
+		e100_config_ifs(bdp);
+		e100_config(bdp);
+	}
+}
+
+/**
+ * e100intr - interrupt handler
+ * @irq: the IRQ number
+ * @dev_inst: the net_device struct
+ * @regs: registers (unused)
+ *
+ * This routine is the ISR for the e100 board. It services
+ * the RX & TX queues & starts the RU if it has stopped due
+ * to no resources.
+ */
+irqreturn_t
+e100intr(int irq, void *dev_inst, struct pt_regs *regs)
+{
+	struct net_device *dev;
+	struct e100_private *bdp;
+	u16 intr_status;
+
+	dev = dev_inst;
+	bdp = dev->priv;
+
+	intr_status = readw(&bdp->scb->scb_status);
+	/* If not my interrupt, just return */
+	if (!(intr_status & SCB_STATUS_ACK_MASK) || (intr_status == 0xffff)) {
+		return IRQ_NONE;
+	}
+
+	/* disable and ack intr */
+	e100_disable_clear_intr(bdp);
+
+	/* the device is closed, don't continue or else bad things may happen. */
+	if (!netif_running(dev)) {
+		e100_set_intr_mask(bdp);
+		return IRQ_NONE;
+	}
+
+	/* SWI intr (triggered by watchdog) is signal to allocate new skb buffers */
+	if (intr_status & SCB_STATUS_ACK_SWI) {
+		e100_alloc_skbs(bdp);
+	}
+
+	/* do recv work if any */
+	if (intr_status &
+	    (SCB_STATUS_ACK_FR | SCB_STATUS_ACK_RNR | SCB_STATUS_ACK_SWI)) 
+		bdp->drv_stats.rx_intr_pkts += e100_rx_srv(bdp);
+
+	/* clean up after tx'ed packets */
+	if (intr_status & (SCB_STATUS_ACK_CNA | SCB_STATUS_ACK_CX))
+		e100_tx_srv(bdp);
+
+	e100_set_intr_mask(bdp);
+	return IRQ_HANDLED;
+}
+
+/**
+ * e100_tx_skb_free - free TX skbs resources
+ * @bdp: atapter's private data struct
+ * @tcb: associated tcb of the freed skb
+ *
+ * This routine frees resources of TX skbs.
+ */
+static inline void
+e100_tx_skb_free(struct e100_private *bdp, tcb_t *tcb)
+{
+	if (tcb->tcb_skb) {
+#ifdef MAX_SKB_FRAGS
+		int i;
+		tbd_t *tbd_arr = tcb->tbd_ptr;
+		int frags = skb_shinfo(tcb->tcb_skb)->nr_frags;
+
+		for (i = 0; i <= frags; i++, tbd_arr++) {
+			pci_unmap_single(bdp->pdev,
+					 le32_to_cpu(tbd_arr->tbd_buf_addr),
+					 le16_to_cpu(tbd_arr->tbd_buf_cnt),
+					 PCI_DMA_TODEVICE);
+		}
+#else
+		pci_unmap_single(bdp->pdev,
+				 le32_to_cpu((tcb->tbd_ptr)->tbd_buf_addr),
+				 tcb->tcb_skb->len, PCI_DMA_TODEVICE);
+#endif
+		dev_kfree_skb_irq(tcb->tcb_skb);
+		tcb->tcb_skb = NULL;
+	}
+}
+
+/**
+ * e100_tx_srv - service TX queues
+ * @bdp: atapter's private data struct
+ *
+ * This routine services the TX queues. It reclaims the TCB's & TBD's & other
+ * resources used during the transmit of this buffer. It is called from the ISR.
+ * We don't need a tx_lock since we always access buffers which were already
+ * prepared.
+ */
+void
+e100_tx_srv(struct e100_private *bdp)
+{
+	tcb_t *tcb;
+	int i;
+
+	/* go over at most TxDescriptors buffers */
+	for (i = 0; i < bdp->params.TxDescriptors; i++) {
+		tcb = bdp->tcb_pool.data;
+		tcb += bdp->tcb_pool.head;
+
+		rmb();
+
+		/* if the buffer at 'head' is not complete, break */
+		if (!(tcb->tcb_hdr.cb_status &
+		      __constant_cpu_to_le16(CB_STATUS_COMPLETE)))
+			break;
+
+		/* service next buffer, clear the out of resource condition */
+		e100_tx_skb_free(bdp, tcb);
+
+		if (netif_running(bdp->device))
+			netif_wake_queue(bdp->device);
+
+		/* if we've caught up with 'tail', break */
+		if (NEXT_TCB_TOUSE(bdp->tcb_pool.head) == bdp->tcb_pool.tail) {
+			break;
+		}
+
+		bdp->tcb_pool.head = NEXT_TCB_TOUSE(bdp->tcb_pool.head);
+	}
+}
+
+/**
+ * e100_rx_srv - service RX queue
+ * @bdp: atapter's private data struct
+ * @max_number_of_rfds: max number of RFDs to process
+ * @rx_congestion: flag pointer, to inform the calling function of congestion.
+ *
+ * This routine processes the RX interrupt & services the RX queues.
+ * For each successful RFD, it allocates a new msg block, links that
+ * into the RFD list, and sends the old msg upstream.
+ * The new RFD is then put at the end of the free list of RFD's.
+ * It returns the number of serviced RFDs.
+ */
+u32
+e100_rx_srv(struct e100_private *bdp)
+{
+	rfd_t *rfd;		/* new rfd, received rfd */
+	int i;
+	u16 rfd_status;
+	struct sk_buff *skb;
+	struct net_device *dev;
+	unsigned int data_sz;
+	struct rx_list_elem *rx_struct;
+	u32 rfd_cnt = 0;
+
+	dev = bdp->device;
+
+	/* current design of rx is as following:
+	 * 1. socket buffer (skb) used to pass network packet to upper layer
+	 * 2. all HW host memory structures (like RFDs, RBDs and data buffers)
+	 *    are placed in a skb's data room
+	 * 3. when rx process is complete, we change skb internal pointers to exclude
+	 *    from data area all unrelated things (RFD, RDB) and to leave
+	 *    just rx'ed packet netto
+	 * 4. for each skb passed to upper layer, new one is allocated instead.
+	 * 5. if no skb left, in 2 sec another atempt to allocate skbs will be made
+	 *    (watchdog trigger SWI intr and isr should allocate new skbs)
+	 */
+	for (i = 0; i < bdp->params.RxDescriptors; i++) {
+		if (list_empty(&(bdp->active_rx_list))) {
+			break;
+		}
+
+		rx_struct = list_entry(bdp->active_rx_list.next,
+				       struct rx_list_elem, list_elem);
+		skb = rx_struct->skb;
+
+		rfd = RFD_POINTER(skb, bdp);	/* locate RFD within skb */
+
+		// sync only the RFD header
+		pci_dma_sync_single(bdp->pdev, rx_struct->dma_addr,
+				    bdp->rfd_size, PCI_DMA_FROMDEVICE);
+		rfd_status = le16_to_cpu(rfd->rfd_header.cb_status);	/* get RFD's status */
+		if (!(rfd_status & RFD_STATUS_COMPLETE))	/* does not contains data yet - exit */
+			break;
+
+		/* to allow manipulation with current skb we need to unlink it */
+		list_del(&(rx_struct->list_elem));
+
+		/* do not free & unmap badly received packet.
+		 * move it to the end of skb list for reuse */
+		if (!(rfd_status & RFD_STATUS_OK)) {
+			e100_add_skb_to_end(bdp, rx_struct);
+			continue;
+		}
+
+		data_sz = min_t(u16, (le16_to_cpu(rfd->rfd_act_cnt) & 0x3fff),
+				(sizeof (rfd_t) - bdp->rfd_size));
+
+		/* now sync all the data */
+		pci_dma_sync_single(bdp->pdev, rx_struct->dma_addr,
+				    (data_sz + bdp->rfd_size),
+				    PCI_DMA_FROMDEVICE);
+
+		pci_unmap_single(bdp->pdev, rx_struct->dma_addr,
+				 sizeof (rfd_t), PCI_DMA_FROMDEVICE);
+
+		list_add(&(rx_struct->list_elem), &(bdp->rx_struct_pool));
+
+		/* end of dma access to rfd */
+		bdp->skb_req++;	/* incr number of requested skbs */
+		e100_alloc_skbs(bdp);	/* and get them */
+
+		/* set packet size, excluding checksum (2 last bytes) if it is present */
+		if ((bdp->flags & DF_CSUM_OFFLOAD)
+		    && (bdp->rev_id < D102_REV_ID))
+			skb_put(skb, (int) data_sz - 2);
+		else
+			skb_put(skb, (int) data_sz);
+
+		bdp->drv_stats.net_stats.rx_bytes += skb->len;
+
+		/* set the protocol */
+		skb->protocol = eth_type_trans(skb, dev);
+
+		/* set the checksum info */
+		if (bdp->flags & DF_CSUM_OFFLOAD) {
+			if (bdp->rev_id >= D102_REV_ID) {
+				skb->ip_summed = e100_D102_check_checksum(rfd);
+			} else {
+				skb->ip_summed = e100_D101M_checksum(bdp, skb);
+			}
+		} else {
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+#ifdef E100_IA64_DMA_FIX
+		//Free low-memory skb buffer without passing it up to the IP stack
+		if (non_DMA32_memory_present) {
+			skb_linearize(skb, GFP_ATOMIC);
+		}
+#endif
+
+#ifdef NETIF_F_HW_VLAN_TX
+		if(bdp->vlgrp && (rfd_status & CB_STATUS_VLAN)) {
+			vlan_hwaccel_rx(skb, bdp->vlgrp, be16_to_cpu(rfd->vlanid));
+		} else {
+			netif_rx(skb);
+		}
+#else
+		netif_rx(skb);
+#endif
+		dev->last_rx = jiffies;
+		
+		rfd_cnt++;
+	}			/* end of rfd loop */
+
+	/* restart the RU if it has stopped */
+	if ((readw(&bdp->scb->scb_status) & SCB_RUS_MASK) != SCB_RUS_READY) {
+		e100_start_ru(bdp);
+	}
+
+	return rfd_cnt;
+}
+
+void
+e100_refresh_txthld(struct e100_private *bdp)
+{
+	basic_cntr_t *pstat = &(bdp->stats_counters->basic_stats);
+
+	/* as long as tx_per_underrun is not 0, we can go about dynamically *
+	 * adjusting the xmit threshold. we stop doing that & resort to defaults
+	 * * once the adjustments become meaningless. the value is adjusted by *
+	 * dumping the error counters & checking the # of xmit underrun errors *
+	 * we've had. */
+	if (bdp->tx_per_underrun) {
+		/* We are going to last values dumped from the dump statistics
+		 * command */
+		if (le32_to_cpu(pstat->xmt_gd_frames)) {
+			if (le32_to_cpu(pstat->xmt_uruns)) {
+				/* 
+				 * if we have had more than one underrun per "DEFAULT #
+				 * OF XMITS ALLOWED PER UNDERRUN" good xmits, raise the
+				 * THRESHOLD.
+				 */
+				if ((le32_to_cpu(pstat->xmt_gd_frames) /
+				     le32_to_cpu(pstat->xmt_uruns)) <
+				    bdp->tx_per_underrun) {
+					bdp->tx_thld += 3;
+				}
+			}
+
+			/* 
+			 * if we've had less than one underrun per the DEFAULT number of
+			 * of good xmits allowed, lower the THOLD but not less than 0 
+			 */
+			if (le32_to_cpu(pstat->xmt_gd_frames) >
+			    bdp->tx_per_underrun) {
+				bdp->tx_thld--;
+
+				if (bdp->tx_thld < 6)
+					bdp->tx_thld = 6;
+
+			}
+		}
+
+		/* end good xmits */
+		/* 
+		 * * if our adjustments are becoming unresonable, stop adjusting &
+		 * resort * to defaults & pray. A THOLD value > 190 means that the
+		 * adapter will * wait for 190*8=1520 bytes in TX FIFO before it
+		 * starts xmit. Since * MTU is 1514, it doesn't make any sense for
+		 * further increase. */
+		if (bdp->tx_thld >= 190) {
+			bdp->tx_per_underrun = 0;
+			bdp->tx_thld = 189;
+		}
+	}			/* end underrun check */
+}
+
+/**
+ * e100_prepare_xmit_buff - prepare a buffer for transmission
+ * @bdp: atapter's private data struct
+ * @skb: skb to send
+ *
+ * This routine prepare a buffer for transmission. It checks
+ * the message length for the appropiate size. It picks up a
+ * free tcb from the TCB pool and sets up the corresponding
+ * TBD's. If the number of fragments are more than the number
+ * of TBD/TCB it copies all the fragments in a coalesce buffer.
+ * It returns a pointer to the prepared TCB.
+ */
+static inline tcb_t *
+e100_prepare_xmit_buff(struct e100_private *bdp, struct sk_buff *skb)
+{
+	tcb_t *tcb, *prev_tcb;
+
+	tcb = bdp->tcb_pool.data;
+	tcb += TCB_TO_USE(bdp->tcb_pool);
+
+	if (bdp->flags & USE_IPCB) {
+		tcb->tcbu.ipcb.ip_activation_high = IPCB_IP_ACTIVATION_DEFAULT;
+		tcb->tcbu.ipcb.ip_schedule &= ~IPCB_TCP_PACKET;
+		tcb->tcbu.ipcb.ip_schedule &= ~IPCB_TCPUDP_CHECKSUM_ENABLE;
+	}
+
+#ifdef NETIF_F_HW_VLAN_TX
+	if(bdp->vlgrp && vlan_tx_tag_present(skb)) {
+		(tcb->tcbu).ipcb.ip_activation_high |= IPCB_INSERTVLAN_ENABLE;
+		(tcb->tcbu).ipcb.vlan = cpu_to_be16(vlan_tx_tag_get(skb));
+	}
+#endif
+	
+	tcb->tcb_hdr.cb_status = 0;
+	tcb->tcb_thrshld = bdp->tx_thld;
+	tcb->tcb_hdr.cb_cmd |= __constant_cpu_to_le16(CB_S_BIT);
+
+	/* Set I (Interrupt) bit on every (TX_FRAME_CNT)th packet */
+	if (!(++bdp->tx_count % TX_FRAME_CNT))
+		tcb->tcb_hdr.cb_cmd |= __constant_cpu_to_le16(CB_I_BIT);
+	else
+		/* Clear I bit on other packets */
+		tcb->tcb_hdr.cb_cmd &= ~__constant_cpu_to_le16(CB_I_BIT);
+
+	tcb->tcb_skb = skb;
+
+#ifdef MAX_SKB_FRAGS
+	if (skb->ip_summed == CHECKSUM_HW) {
+		const struct iphdr *ip = skb->nh.iph;
+
+		if ((ip->protocol == IPPROTO_TCP) ||
+		    (ip->protocol == IPPROTO_UDP)) {
+
+			tcb->tcbu.ipcb.ip_activation_high |=
+				IPCB_HARDWAREPARSING_ENABLE;
+			tcb->tcbu.ipcb.ip_schedule |=
+				IPCB_TCPUDP_CHECKSUM_ENABLE;
+
+			if (ip->protocol == IPPROTO_TCP)
+				tcb->tcbu.ipcb.ip_schedule |= IPCB_TCP_PACKET;
+		}
+	}
+
+	if (!skb_shinfo(skb)->nr_frags) {
+		(tcb->tbd_ptr)->tbd_buf_addr =
+			cpu_to_le32(pci_map_single(bdp->pdev, skb->data,
+						   skb->len, PCI_DMA_TODEVICE));
+		(tcb->tbd_ptr)->tbd_buf_cnt = cpu_to_le16(skb->len);
+		tcb->tcb_tbd_num = 1;
+		tcb->tcb_tbd_ptr = tcb->tcb_tbd_dflt_ptr;
+	} else {
+		int i;
+		void *addr;
+		tbd_t *tbd_arr_ptr = &(tcb->tbd_ptr[1]);
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[0];
+
+		(tcb->tbd_ptr)->tbd_buf_addr =
+			cpu_to_le32(pci_map_single(bdp->pdev, skb->data,
+						   skb_headlen(skb),
+						   PCI_DMA_TODEVICE));
+		(tcb->tbd_ptr)->tbd_buf_cnt =
+			cpu_to_le16(skb_headlen(skb));
+
+		for (i = 0; i < skb_shinfo(skb)->nr_frags;
+		     i++, tbd_arr_ptr++, frag++) {
+
+			addr = ((void *) page_address(frag->page) +
+				frag->page_offset);
+
+			tbd_arr_ptr->tbd_buf_addr =
+				cpu_to_le32(pci_map_single(bdp->pdev,
+							   addr, frag->size,
+							   PCI_DMA_TODEVICE));
+			tbd_arr_ptr->tbd_buf_cnt = cpu_to_le16(frag->size);
+		}
+		tcb->tcb_tbd_num = skb_shinfo(skb)->nr_frags + 1;
+		tcb->tcb_tbd_ptr = tcb->tcb_tbd_expand_ptr;
+	}
+#else
+	(tcb->tbd_ptr)->tbd_buf_addr =
+		cpu_to_le32(pci_map_single(bdp->pdev, skb->data,
+					   skb->len, PCI_DMA_TODEVICE));
+	(tcb->tbd_ptr)->tbd_buf_cnt = cpu_to_le16(skb->len);
+#endif
+
+	/* clear the S-BIT on the previous tcb */
+	prev_tcb = bdp->tcb_pool.data;
+	prev_tcb += PREV_TCB_USED(bdp->tcb_pool);
+	prev_tcb->tcb_hdr.cb_cmd &= __constant_cpu_to_le16((u16) ~CB_S_BIT);
+
+	bdp->tcb_pool.tail = NEXT_TCB_TOUSE(bdp->tcb_pool.tail);
+
+	wmb();
+
+	e100_start_cu(bdp, tcb);
+
+	return tcb;
+}
+
+/* Changed for 82558 enhancement */
+/**
+ * e100_start_cu - start the adapter's CU
+ * @bdp: atapter's private data struct
+ * @tcb: TCB to be transmitted
+ *
+ * This routine issues a CU Start or CU Resume command to the 82558/9.
+ * This routine was added because the prepare_ext_xmit_buff takes advantage
+ * of the 82558/9's Dynamic TBD chaining feature and has to start the CU as
+ * soon as the first TBD is ready. 
+ *
+ * e100_start_cu must be called while holding the tx_lock ! 
+ */
+u8
+e100_start_cu(struct e100_private *bdp, tcb_t *tcb)
+{
+	unsigned long lock_flag;
+	u8 ret = true;
+
+	spin_lock_irqsave(&(bdp->bd_lock), lock_flag);
+	switch (bdp->next_cu_cmd) {
+	case RESUME_NO_WAIT:
+		/*last cu command was a CU_RESMUE if this is a 558 or newer we don't need to
+		 * wait for command word to clear, we reach here only if we are bachlor
+		 */
+		e100_exec_cmd(bdp, SCB_CUC_RESUME);
+		break;
+
+	case RESUME_WAIT:
+		if ((bdp->flags & IS_ICH) &&
+		    (bdp->cur_line_speed == 10) &&
+		    (bdp->cur_dplx_mode == HALF_DUPLEX)) {
+			e100_wait_exec_simple(bdp, SCB_CUC_NOOP);
+			udelay(1);
+		}
+		if ((e100_wait_exec_simple(bdp, SCB_CUC_RESUME)) &&
+		    (bdp->flags & IS_BACHELOR) && (!(bdp->flags & IS_ICH))) {
+			bdp->next_cu_cmd = RESUME_NO_WAIT;
+		}
+		break;
+
+	case START_WAIT:
+		// The last command was a non_tx CU command
+		if (!e100_wait_cus_idle(bdp))
+			printk(KERN_DEBUG
+			       "e100: %s: cu_start: timeout waiting for cu\n",
+			       bdp->device->name);
+		if (!e100_wait_exec_cmplx(bdp, (u32) (tcb->tcb_phys),
+					  SCB_CUC_START, CB_TRANSMIT)) {
+			printk(KERN_DEBUG
+			       "e100: %s: cu_start: timeout waiting for scb\n",
+			       bdp->device->name);
+			e100_exec_cmplx(bdp, (u32) (tcb->tcb_phys),
+					SCB_CUC_START);
+			ret = false;
+		}
+
+		bdp->next_cu_cmd = RESUME_WAIT;
+
+		break;
+	}
+
+	/* save the last tcb */
+	bdp->last_tcb = tcb;
+
+	spin_unlock_irqrestore(&(bdp->bd_lock), lock_flag);
+	return ret;
+}
+
+/* ====================================================================== */
+/* hw                                                                     */
+/* ====================================================================== */
+
+/**
+ * e100_selftest - perform H/W self test
+ * @bdp: atapter's private data struct
+ * @st_timeout: address to return timeout value, if fails
+ * @st_result: address to return selftest result, if fails
+ *
+ * This routine will issue PORT Self-test command to test the e100.
+ * The self-test will fail if the adapter's master-enable bit is not
+ * set in the PCI Command Register, or if the adapter is not seated
+ * in a PCI master-enabled slot. we also disable interrupts when the
+ * command is completed.
+ *
+ * Returns:
+ *      true: if adapter passes self_test
+ *      false: otherwise
+ */
+unsigned char
+e100_selftest(struct e100_private *bdp, u32 *st_timeout, u32 *st_result)
+{
+	u32 selftest_cmd;
+
+	/* initialize the nic state before running test */
+	e100_sw_reset(bdp, PORT_SOFTWARE_RESET);
+	/* Setup the address of the self_test area */
+	selftest_cmd = bdp->selftest_phys;
+
+	/* Setup SELF TEST Command Code in D3 - D0 */
+	selftest_cmd |= PORT_SELFTEST;
+
+	/* Initialize the self-test signature and results DWORDS */
+	bdp->selftest->st_sign = 0;
+	bdp->selftest->st_result = 0xffffffff;
+
+	/* Do the port command */
+	writel(selftest_cmd, &bdp->scb->scb_port);
+	readw(&(bdp->scb->scb_status));	/* flushes last write, read-safe */
+
+	/* Wait at least 10 milliseconds for the self-test to complete */
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ / 100 + 1);
+
+	/* disable interrupts since they are enabled */
+	/* after device reset during selftest        */
+	e100_disable_clear_intr(bdp);
+
+	/* if The First Self Test DWORD Still Zero, We've timed out. If the
+	 * second DWORD is not zero then we have an error. */
+	if ((bdp->selftest->st_sign == 0) || (bdp->selftest->st_result != 0)) {
+
+		if (st_timeout)
+			*st_timeout = !(le32_to_cpu(bdp->selftest->st_sign));
+
+		if (st_result)
+			*st_result = le32_to_cpu(bdp->selftest->st_result);
+
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ * e100_setup_iaaddr - issue IA setup sommand
+ * @bdp: atapter's private data struct
+ * @eaddr: new ethernet address
+ *
+ * This routine will issue the IA setup command. This command
+ * will notify the 82557 (e100) of what its individual (node)
+ * address is. This command will be executed in polled mode.
+ *
+ * Returns:
+ *      true: if the IA setup command was successfully issued and completed
+ *      false: otherwise
+ */
+unsigned char
+e100_setup_iaaddr(struct e100_private *bdp, u8 *eaddr)
+{
+	unsigned int i;
+	cb_header_t *ntcb_hdr;
+	unsigned char res;
+	nxmit_cb_entry_t *cmd;
+
+	if ((cmd = e100_alloc_non_tx_cmd(bdp)) == NULL) {
+		res = false;
+		goto exit;
+	}
+
+	ntcb_hdr = (cb_header_t *) cmd->non_tx_cmd;
+	ntcb_hdr->cb_cmd = __constant_cpu_to_le16(CB_IA_ADDRESS);
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		(cmd->non_tx_cmd)->ntcb.setup.ia_addr[i] = eaddr[i];
+	}
+
+	res = e100_exec_non_cu_cmd(bdp, cmd);
+	if (!res)
+		printk(KERN_WARNING "e100: %s: IA setup failed\n", 
+		       bdp->device->name);
+
+exit:
+	return res;
+}
+
+/**
+ * e100_start_ru - start the RU if needed
+ * @bdp: atapter's private data struct
+ *
+ * This routine checks the status of the 82557's receive unit(RU),
+ * and starts the RU if it was not already active.  However,
+ * before restarting the RU, the driver gives the RU the buffers
+ * it freed up during the servicing of the ISR. If there are
+ * no free buffers to give to the RU, (i.e. we have reached a
+ * no resource condition) the RU will not be started till the
+ * next ISR.
+ */
+void
+e100_start_ru(struct e100_private *bdp)
+{
+	struct rx_list_elem *rx_struct = NULL;
+	int buffer_found = 0;
+	struct list_head *entry_ptr;
+
+	list_for_each(entry_ptr, &(bdp->active_rx_list)) {
+		rx_struct =
+			list_entry(entry_ptr, struct rx_list_elem, list_elem);
+		pci_dma_sync_single(bdp->pdev, rx_struct->dma_addr,
+				    bdp->rfd_size, PCI_DMA_FROMDEVICE);
+		if (!((SKB_RFD_STATUS(rx_struct->skb, bdp) &
+		       __constant_cpu_to_le16(RFD_STATUS_COMPLETE)))) {
+			buffer_found = 1;
+			break;
+		}
+	}
+
+	/* No available buffers */
+	if (!buffer_found) {
+		return;
+	}
+
+	spin_lock(&bdp->bd_lock);
+
+	if (!e100_wait_exec_cmplx(bdp, rx_struct->dma_addr, SCB_RUC_START, 0)) {
+		printk(KERN_DEBUG
+		       "e100: %s: start_ru: wait_scb failed\n", 
+		       bdp->device->name);
+		e100_exec_cmplx(bdp, rx_struct->dma_addr, SCB_RUC_START);
+	}
+	if (bdp->next_cu_cmd == RESUME_NO_WAIT) {
+		bdp->next_cu_cmd = RESUME_WAIT;
+	}
+	spin_unlock(&bdp->bd_lock);
+}
+
+/**
+ * e100_cmd_complete_location
+ * @bdp: atapter's private data struct
+ *
+ * This routine returns a pointer to the location of the command-complete
+ * DWord in the dump statistical counters area, according to the statistical
+ * counters mode (557 - basic, 558 - extended, or 559 - TCO mode).
+ * See e100_config_init() for the setting of the statistical counters mode.
+ */
+static u32 *
+e100_cmd_complete_location(struct e100_private *bdp)
+{
+	u32 *cmd_complete;
+	max_counters_t *stats = bdp->stats_counters;
+
+	switch (bdp->stat_mode) {
+	case E100_EXTENDED_STATS:
+		cmd_complete =
+			(u32 *) &(((err_cntr_558_t *) (stats))->cmd_complete);
+		break;
+
+	case E100_TCO_STATS:
+		cmd_complete =
+			(u32 *) &(((err_cntr_559_t *) (stats))->cmd_complete);
+		break;
+
+	case E100_BASIC_STATS:
+	default:		
+		cmd_complete =
+			(u32 *) &(((err_cntr_557_t *) (stats))->cmd_complete);
+		break;
+	}
+
+	return cmd_complete;
+}
+
+/**
+ * e100_clr_cntrs - clear statistics counters
+ * @bdp: atapter's private data struct
+ *
+ * This routine will clear the adapter error statistic counters.
+ *
+ * Returns:
+ *      true: if successfully cleared stat counters
+ *      false: otherwise
+ */
+static unsigned char
+e100_clr_cntrs(struct e100_private *bdp)
+{
+	volatile u32 *pcmd_complete;
+
+	/* clear the dump counter complete word */
+	pcmd_complete = e100_cmd_complete_location(bdp);
+	*pcmd_complete = 0;
+	wmb();
+
+	if (!e100_wait_exec_cmplx(bdp, bdp->stat_cnt_phys, SCB_CUC_DUMP_ADDR, 0))
+		return false;
+
+	/* wait 10 microseconds for the command to complete */
+	udelay(10);
+
+	if (!e100_wait_exec_simple(bdp, SCB_CUC_DUMP_RST_STAT))
+		return false;
+
+	if (bdp->next_cu_cmd == RESUME_NO_WAIT) {
+		bdp->next_cu_cmd = RESUME_WAIT;
+	}
+
+	return true;
+}
+
+static unsigned char
+e100_update_stats(struct e100_private *bdp)
+{
+	u32 *pcmd_complete;
+	basic_cntr_t *pstat = &(bdp->stats_counters->basic_stats);
+
+	// check if last dump command completed
+	pcmd_complete = e100_cmd_complete_location(bdp);
+	if (*pcmd_complete != le32_to_cpu(DUMP_RST_STAT_COMPLETED) &&
+	    *pcmd_complete != le32_to_cpu(DUMP_STAT_COMPLETED)) {
+		*pcmd_complete = 0;
+		return false;
+	}
+
+	/* increment the statistics */
+	bdp->drv_stats.net_stats.rx_packets +=
+		le32_to_cpu(pstat->rcv_gd_frames);
+	bdp->drv_stats.net_stats.tx_packets +=
+		le32_to_cpu(pstat->xmt_gd_frames);
+	bdp->drv_stats.net_stats.rx_dropped += le32_to_cpu(pstat->rcv_rsrc_err);
+	bdp->drv_stats.net_stats.collisions += le32_to_cpu(pstat->xmt_ttl_coll);
+	bdp->drv_stats.net_stats.rx_length_errors +=
+		le32_to_cpu(pstat->rcv_shrt_frames);
+	bdp->drv_stats.net_stats.rx_over_errors +=
+		le32_to_cpu(pstat->rcv_rsrc_err);
+	bdp->drv_stats.net_stats.rx_crc_errors +=
+		le32_to_cpu(pstat->rcv_crc_errs);
+	bdp->drv_stats.net_stats.rx_frame_errors +=
+		le32_to_cpu(pstat->rcv_algn_errs);
+	bdp->drv_stats.net_stats.rx_fifo_errors +=
+		le32_to_cpu(pstat->rcv_oruns);
+	bdp->drv_stats.net_stats.tx_aborted_errors +=
+		le32_to_cpu(pstat->xmt_max_coll);
+	bdp->drv_stats.net_stats.tx_carrier_errors +=
+		le32_to_cpu(pstat->xmt_lost_crs);
+	bdp->drv_stats.net_stats.tx_fifo_errors +=
+		le32_to_cpu(pstat->xmt_uruns);
+
+	bdp->drv_stats.tx_late_col += le32_to_cpu(pstat->xmt_late_coll);
+	bdp->drv_stats.tx_ok_defrd += le32_to_cpu(pstat->xmt_deferred);
+	bdp->drv_stats.tx_one_retry += le32_to_cpu(pstat->xmt_sngl_coll);
+	bdp->drv_stats.tx_mt_one_retry += le32_to_cpu(pstat->xmt_mlt_coll);
+	bdp->drv_stats.rcv_cdt_frames += le32_to_cpu(pstat->rcv_err_coll);
+
+	if (bdp->stat_mode != E100_BASIC_STATS) {
+		ext_cntr_t *pex_stat = &bdp->stats_counters->extended_stats;
+
+		bdp->drv_stats.xmt_fc_pkts +=
+			le32_to_cpu(pex_stat->xmt_fc_frames);
+		bdp->drv_stats.rcv_fc_pkts +=
+			le32_to_cpu(pex_stat->rcv_fc_frames);
+		bdp->drv_stats.rcv_fc_unsupported +=
+			le32_to_cpu(pex_stat->rcv_fc_unsupported);
+	}
+
+	if (bdp->stat_mode == E100_TCO_STATS) {
+		tco_cntr_t *ptco_stat = &bdp->stats_counters->tco_stats;
+
+		bdp->drv_stats.xmt_tco_pkts +=
+			le16_to_cpu(ptco_stat->xmt_tco_frames);
+		bdp->drv_stats.rcv_tco_pkts +=
+			le16_to_cpu(ptco_stat->rcv_tco_frames);
+	}
+
+	*pcmd_complete = 0;
+	return true;
+}
+
+/**
+ * e100_dump_stat_cntrs
+ * @bdp: atapter's private data struct
+ *
+ * This routine will dump the board statistical counters without waiting
+ * for stat_dump to complete. Any access to this stats should verify the completion
+ * of the command
+ */
+void
+e100_dump_stats_cntrs(struct e100_private *bdp)
+{
+	unsigned long lock_flag_bd;
+
+	spin_lock_irqsave(&(bdp->bd_lock), lock_flag_bd);
+
+	/* dump h/w stats counters */
+	if (e100_wait_exec_simple(bdp, SCB_CUC_DUMP_RST_STAT)) {
+		if (bdp->next_cu_cmd == RESUME_NO_WAIT) {
+			bdp->next_cu_cmd = RESUME_WAIT;
+		}
+	}
+
+	spin_unlock_irqrestore(&(bdp->bd_lock), lock_flag_bd);
+}
+
+/**
+ * e100_exec_non_cu_cmd
+ * @bdp: atapter's private data struct
+ * @command: the non-cu command to execute
+ *
+ * This routine will submit a command block to be executed,
+ */
+unsigned char
+e100_exec_non_cu_cmd(struct e100_private *bdp, nxmit_cb_entry_t *command)
+{
+	cb_header_t *ntcb_hdr;
+	unsigned long lock_flag;
+	unsigned long expiration_time;
+	unsigned char rc = true;
+	u8 sub_cmd;
+
+	ntcb_hdr = (cb_header_t *) command->non_tx_cmd;	/* get hdr of non tcb cmd */
+	sub_cmd = cpu_to_le16(ntcb_hdr->cb_cmd);
+
+	/* Set the Command Block to be the last command block */
+	ntcb_hdr->cb_cmd |= __constant_cpu_to_le16(CB_EL_BIT);
+	ntcb_hdr->cb_status = 0;
+	ntcb_hdr->cb_lnk_ptr = 0;
+
+	wmb();
+	if (in_interrupt())
+		return e100_delayed_exec_non_cu_cmd(bdp, command);
+
+	if (netif_running(bdp->device) && netif_carrier_ok(bdp->device))
+		return e100_delayed_exec_non_cu_cmd(bdp, command);
+
+	spin_lock_bh(&(bdp->bd_non_tx_lock));
+
+	if (bdp->non_tx_command_state != E100_NON_TX_IDLE) {
+		goto delayed_exec;
+	}
+
+	if (bdp->last_tcb) {
+		rmb();
+		if ((bdp->last_tcb->tcb_hdr.cb_status &
+		     __constant_cpu_to_le16(CB_STATUS_COMPLETE)) == 0)
+			goto delayed_exec;
+	}
+
+	if ((readw(&bdp->scb->scb_status) & SCB_CUS_MASK) == SCB_CUS_ACTIVE) {
+		goto delayed_exec;
+	}
+
+	spin_lock_irqsave(&bdp->bd_lock, lock_flag);
+
+	if (!e100_wait_exec_cmplx(bdp, command->dma_addr, SCB_CUC_START, sub_cmd)) {
+		spin_unlock_irqrestore(&(bdp->bd_lock), lock_flag);
+		rc = false;
+		goto exit;
+	}
+
+	bdp->next_cu_cmd = START_WAIT;
+	spin_unlock_irqrestore(&(bdp->bd_lock), lock_flag);
+
+	/* now wait for completion of non-cu CB up to 20 msec */
+	expiration_time = jiffies + HZ / 50 + 1;
+	rmb();
+	while (!(ntcb_hdr->cb_status &
+		     __constant_cpu_to_le16(CB_STATUS_COMPLETE))) {
+
+		if (time_before(jiffies, expiration_time)) {
+			spin_unlock_bh(&(bdp->bd_non_tx_lock));
+			yield();
+			spin_lock_bh(&(bdp->bd_non_tx_lock));
+		} else {
+#ifdef E100_CU_DEBUG			
+			printk(KERN_ERR "e100: %s: non-TX command (%x) "
+				"timeout\n", bdp->device->name, sub_cmd);
+#endif			
+			rc = false;
+			goto exit;
+		}
+		rmb();
+	}
+
+exit:
+	e100_free_non_tx_cmd(bdp, command);
+
+	if (netif_running(bdp->device))
+		netif_wake_queue(bdp->device);
+
+	spin_unlock_bh(&(bdp->bd_non_tx_lock));
+	return rc;
+
+delayed_exec:
+	spin_unlock_bh(&(bdp->bd_non_tx_lock));
+	return e100_delayed_exec_non_cu_cmd(bdp, command);
+}
+
+/**
+ * e100_sw_reset
+ * @bdp: atapter's private data struct
+ * @reset_cmd: s/w reset or selective reset
+ *
+ * This routine will issue a software reset to the adapter. It 
+ * will also disable interrupts, as the are enabled after reset.
+ */
+void
+e100_sw_reset(struct e100_private *bdp, u32 reset_cmd)
+{
+	/* Do  a selective reset first to avoid a potential PCI hang */
+	writel(PORT_SELECTIVE_RESET, &bdp->scb->scb_port);
+	readw(&(bdp->scb->scb_status));	/* flushes last write, read-safe */
+
+	/* wait for the reset to take effect */
+	udelay(20);
+	if (reset_cmd == PORT_SOFTWARE_RESET) {
+		writel(PORT_SOFTWARE_RESET, &bdp->scb->scb_port);
+
+		/* wait 20 micro seconds for the reset to take effect */
+		udelay(20);
+	}
+
+	/* Mask off our interrupt line -- it is unmasked after reset */
+	e100_disable_clear_intr(bdp);
+#ifdef E100_CU_DEBUG	
+	bdp->last_cmd = 0;
+	bdp->last_sub_cmd = 0;
+#endif	
+}
+
+/**
+ * e100_load_microcode - Download microsocde to controller.
+ * @bdp: atapter's private data struct
+ *
+ * This routine downloads microcode on to the controller. This
+ * microcode is available for the 82558/9, 82550. Currently the
+ * microcode handles interrupt bundling and TCO workaround.
+ *
+ * Returns:
+ *      true: if successfull
+ *      false: otherwise
+ */
+static unsigned char
+e100_load_microcode(struct e100_private *bdp)
+{
+	static struct {
+		u8 rev_id;
+		u32 ucode[UCODE_MAX_DWORDS + 1];
+		int timer_dword;
+		int bundle_dword;
+		int min_size_dword;
+	} ucode_opts[] = {
+		{ D101A4_REV_ID,
+		  D101_A_RCVBUNDLE_UCODE,
+		  D101_CPUSAVER_TIMER_DWORD,
+		  D101_CPUSAVER_BUNDLE_DWORD,
+		  D101_CPUSAVER_MIN_SIZE_DWORD },
+		{ D101B0_REV_ID,
+		  D101_B0_RCVBUNDLE_UCODE,
+		  D101_CPUSAVER_TIMER_DWORD,
+		  D101_CPUSAVER_BUNDLE_DWORD,
+		  D101_CPUSAVER_MIN_SIZE_DWORD },
+		{ D101MA_REV_ID,
+		  D101M_B_RCVBUNDLE_UCODE,
+		  D101M_CPUSAVER_TIMER_DWORD,
+		  D101M_CPUSAVER_BUNDLE_DWORD,
+		  D101M_CPUSAVER_MIN_SIZE_DWORD },
+		{ D101S_REV_ID,
+		  D101S_RCVBUNDLE_UCODE,
+		  D101S_CPUSAVER_TIMER_DWORD,
+		  D101S_CPUSAVER_BUNDLE_DWORD,
+		  D101S_CPUSAVER_MIN_SIZE_DWORD },
+		{ D102_REV_ID,
+		  D102_B_RCVBUNDLE_UCODE,
+		  D102_B_CPUSAVER_TIMER_DWORD,
+		  D102_B_CPUSAVER_BUNDLE_DWORD,
+		  D102_B_CPUSAVER_MIN_SIZE_DWORD },
+		{ D102C_REV_ID,
+		  D102_C_RCVBUNDLE_UCODE,
+		  D102_C_CPUSAVER_TIMER_DWORD,
+		  D102_C_CPUSAVER_BUNDLE_DWORD,
+		  D102_C_CPUSAVER_MIN_SIZE_DWORD },
+		{ D102E_REV_ID,
+		  D102_E_RCVBUNDLE_UCODE,
+		  D102_E_CPUSAVER_TIMER_DWORD,
+		  D102_E_CPUSAVER_BUNDLE_DWORD,
+		  D102_E_CPUSAVER_MIN_SIZE_DWORD },
+		{ D102E_A1_REV_ID,
+		  D102_E_RCVBUNDLE_UCODE,
+		  D102_E_CPUSAVER_TIMER_DWORD,
+		  D102_E_CPUSAVER_BUNDLE_DWORD,
+		  D102_E_CPUSAVER_MIN_SIZE_DWORD },
+		{ 0, {0}, 0, 0, 0}
+	}, *opts;
+
+	opts = ucode_opts;
+
+	/* User turned ucode loading off */
+	if (!(bdp->params.b_params & PRM_UCODE))
+		return false;
+
+	/* These controllers do not need ucode */
+	if (bdp->flags & IS_ICH)
+		return false;
+
+	/* Search for ucode match against h/w rev_id */
+	while (opts->rev_id) {
+		if (bdp->rev_id == opts->rev_id) {
+			int i;
+			u32 *ucode_dword;
+			load_ucode_cb_t *ucode_cmd_ptr;
+			nxmit_cb_entry_t *cmd = e100_alloc_non_tx_cmd(bdp);
+
+			if (cmd != NULL) {
+				ucode_cmd_ptr =
+					(load_ucode_cb_t *) cmd->non_tx_cmd;
+				ucode_dword = ucode_cmd_ptr->ucode_dword;
+			} else {
+				return false;
+			}
+
+			memcpy(ucode_dword, opts->ucode, sizeof (opts->ucode));
+
+			/* Insert user-tunable settings */
+			ucode_dword[opts->timer_dword] &= 0xFFFF0000;
+			ucode_dword[opts->timer_dword] |=
+				(u16) bdp->params.IntDelay;
+			ucode_dword[opts->bundle_dword] &= 0xFFFF0000;
+			ucode_dword[opts->bundle_dword] |=
+				(u16) bdp->params.BundleMax;
+			ucode_dword[opts->min_size_dword] &= 0xFFFF0000;
+			ucode_dword[opts->min_size_dword] |=
+				(bdp->params.b_params & PRM_BUNDLE_SMALL) ?
+				0xFFFF : 0xFF80;
+
+			for (i = 0; i < UCODE_MAX_DWORDS; i++)
+				cpu_to_le32s(&(ucode_dword[i]));
+
+			ucode_cmd_ptr->load_ucode_cbhdr.cb_cmd =
+				__constant_cpu_to_le16(CB_LOAD_MICROCODE);
+
+			return e100_exec_non_cu_cmd(bdp, cmd);
+		}
+		opts++;
+	}
+
+	return false;
+}
+
+/***************************************************************************/
+/***************************************************************************/
+/*       EEPROM  Functions                                                 */
+/***************************************************************************/
+
+/* Read PWA (printed wired assembly) number */
+void __devinit
+e100_rd_pwa_no(struct e100_private *bdp)
+{
+	bdp->pwa_no = e100_eeprom_read(bdp, EEPROM_PWA_NO);
+	bdp->pwa_no <<= 16;
+	bdp->pwa_no |= e100_eeprom_read(bdp, EEPROM_PWA_NO + 1);
+}
+
+/* Read the permanent ethernet address from the eprom. */
+void __devinit
+e100_rd_eaddr(struct e100_private *bdp)
+{
+	int i;
+	u16 eeprom_word;
+
+	for (i = 0; i < 6; i += 2) {
+		eeprom_word =
+			e100_eeprom_read(bdp,
+					 EEPROM_NODE_ADDRESS_BYTE_0 + (i / 2));
+
+		bdp->device->dev_addr[i] =
+			bdp->perm_node_address[i] = (u8) eeprom_word;
+		bdp->device->dev_addr[i + 1] =
+			bdp->perm_node_address[i + 1] = (u8) (eeprom_word >> 8);
+	}
+}
+
+/* Check the D102 RFD flags to see if the checksum passed */
+static unsigned char
+e100_D102_check_checksum(rfd_t *rfd)
+{
+	if (((le16_to_cpu(rfd->rfd_header.cb_status)) & RFD_PARSE_BIT)
+	    && (((rfd->rcvparserstatus & CHECKSUM_PROTOCOL_MASK) ==
+		 RFD_TCP_PACKET)
+		|| ((rfd->rcvparserstatus & CHECKSUM_PROTOCOL_MASK) ==
+		    RFD_UDP_PACKET))
+	    && (rfd->checksumstatus & TCPUDP_CHECKSUM_BIT_VALID)
+	    && (rfd->checksumstatus & TCPUDP_CHECKSUM_VALID)) {
+		return CHECKSUM_UNNECESSARY;
+	}
+	return CHECKSUM_NONE;
+}
+
+/**
+ * e100_D101M_checksum
+ * @bdp: atapter's private data struct
+ * @skb: skb received
+ *
+ * Sets the skb->csum value from D101 csum found at the end of the Rx frame. The
+ * D101M sums all words in frame excluding the ethernet II header (14 bytes) so
+ * in case the packet is ethernet II and the protocol is IP, all is need is to
+ * assign this value to skb->csum.
+ */
+static unsigned char
+e100_D101M_checksum(struct e100_private *bdp, struct sk_buff *skb)
+{
+	unsigned short proto = (skb->protocol);
+
+	if (proto == __constant_htons(ETH_P_IP)) {
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+		/* if the frame is layer 2 padded don't set the csum
+		 * starting from 2.4.4, this is done by the ip_rcv routine */
+		{
+			struct iphdr *iph = (struct iphdr *) skb->data;
+
+			if (ntohs(iph->tot_len) < skb->len) {
+				return CHECKSUM_NONE;
+			}
+		}
+#endif
+
+		skb->csum = get_unaligned((u16 *) (skb->tail));
+		return CHECKSUM_HW;
+	}
+	return CHECKSUM_NONE;
+}
+
+/***************************************************************************/
+/***************************************************************************/
+/***************************************************************************/
+/***************************************************************************/
+/*       Auxilary Functions                                                */
+/***************************************************************************/
+
+/* Print the board's configuration */
+void __devinit
+e100_print_brd_conf(struct e100_private *bdp)
+{
+	/* Print the string if checksum Offloading was enabled */
+	if (bdp->flags & DF_CSUM_OFFLOAD)
+		printk(KERN_NOTICE "  Hardware receive checksums enabled\n");
+	else {
+		if (bdp->rev_id >= D101MA_REV_ID) 
+			printk(KERN_NOTICE "  Hardware receive checksums disabled\n");
+	}
+
+	if ((bdp->flags & DF_UCODE_LOADED))
+		printk(KERN_NOTICE "  cpu cycle saver enabled\n");
+}
+
+/**
+ * e100_pci_setup - setup the adapter's PCI information
+ * @pcid: adapter's pci_dev struct
+ * @bdp: atapter's private data struct
+ *
+ * This routine sets up all PCI information for the adapter. It enables the bus
+ * master bit (some BIOS don't do this), requests memory ans I/O regions, and
+ * calls ioremap() on the adapter's memory region.
+ *
+ * Returns:
+ *      true: if successfull
+ *      false: otherwise
+ */
+static unsigned char __devinit
+e100_pci_setup(struct pci_dev *pcid, struct e100_private *bdp)
+{
+	struct net_device *dev = bdp->device;
+	int rc = 0;
+
+	if ((rc = pci_enable_device(pcid)) != 0) {
+		goto err;
+	}
+
+	/* dev and ven ID have already been checked so it is our device */
+	pci_read_config_byte(pcid, PCI_REVISION_ID, (u8 *) &(bdp->rev_id));
+
+	/* address #0 is a memory region */
+	dev->mem_start = pci_resource_start(pcid, 0);
+	dev->mem_end = dev->mem_start + sizeof (scb_t);
+
+	/* address #1 is a IO region */
+	dev->base_addr = pci_resource_start(pcid, 1);
+
+	if ((rc = pci_request_regions(pcid, e100_short_driver_name)) != 0) {
+		goto err_disable;
+	}
+
+	pci_enable_wake(pcid, 0, 0);
+
+	/* if Bus Mastering is off, turn it on! */
+	pci_set_master(pcid);
+
+	/* address #0 is a memory mapping */
+	bdp->scb = (scb_t *) ioremap_nocache(dev->mem_start, sizeof (scb_t));
+
+	if (!bdp->scb) {
+		printk(KERN_ERR "e100: %s: Failed to map PCI address 0x%lX\n",
+		       dev->name, pci_resource_start(pcid, 0));
+		rc = -ENOMEM;
+		goto err_region;
+	}
+
+	return 0;
+
+err_region:
+	pci_release_regions(pcid);
+err_disable:
+	pci_disable_device(pcid);
+err:
+	return rc;
+}
+
+void
+e100_isolate_driver(struct e100_private *bdp)
+{
+
+	/* Check if interface is up                              */
+	/* NOTE: Can't use netif_running(bdp->device) because    */
+	/* dev_close clears __LINK_STATE_START before calling    */
+	/* e100_close (aka dev->stop)                            */
+	if (bdp->device->flags & IFF_UP) {
+		e100_disable_clear_intr(bdp);
+		del_timer_sync(&bdp->watchdog_timer);
+		netif_carrier_off(bdp->device);
+		netif_stop_queue(bdp->device); 
+		bdp->last_tcb = NULL;
+	} 
+	e100_sw_reset(bdp, PORT_SELECTIVE_RESET);
+}
+
+static void
+e100_tcb_add_C_bit(struct e100_private *bdp)
+{
+	tcb_t *tcb = (tcb_t *) bdp->tcb_pool.data;
+	int i;
+
+	for (i = 0; i < bdp->params.TxDescriptors; i++, tcb++) {
+		tcb->tcb_hdr.cb_status |= cpu_to_le16(CB_STATUS_COMPLETE);
+	}
+}
+
+/* 
+ * Procedure:   e100_configure_device
+ *
+ * Description: This routine will configure device
+ *
+ * Arguments:
+ *      bdp - Ptr to this card's e100_bdconfig structure
+ *
+ * Returns:
+ *        true upon success
+ *        false upon failure
+ */
+unsigned char
+e100_configure_device(struct e100_private *bdp)
+{
+	/*load CU & RU base */
+	if (!e100_wait_exec_cmplx(bdp, 0, SCB_CUC_LOAD_BASE, 0))
+		return false;
+
+	if (e100_load_microcode(bdp))
+		bdp->flags |= DF_UCODE_LOADED;
+
+	if (!e100_wait_exec_cmplx(bdp, 0, SCB_RUC_LOAD_BASE, 0))
+		return false;
+
+	/* Issue the load dump counters address command */
+	if (!e100_wait_exec_cmplx(bdp, bdp->stat_cnt_phys, SCB_CUC_DUMP_ADDR, 0))
+		return false;
+
+	if (!e100_setup_iaaddr(bdp, bdp->device->dev_addr)) {
+		printk(KERN_ERR "e100: e100_configure_device: "
+			"setup iaaddr failed\n");
+		return false;
+	}
+
+	e100_set_multi_exec(bdp->device);
+
+	/* Change for 82558 enhancement                                */
+	/* If 82558/9 and if the user has enabled flow control, set up */
+	/* flow Control Reg. in the CSR                                */
+	if ((bdp->flags & IS_BACHELOR)
+	    && (bdp->params.b_params & PRM_FC)) {
+		writeb(DFLT_FC_THLD,
+			&bdp->scb->scb_ext.d101_scb.scb_fc_thld);
+		writeb(DFLT_FC_CMD,
+			&bdp->scb->scb_ext.d101_scb.scb_fc_xon_xoff);
+	}
+
+	e100_force_config(bdp);
+
+	return true;
+}
+
+void
+e100_deisolate_driver(struct e100_private *bdp, u8 full_reset)
+{
+	u32 cmd = full_reset ? PORT_SOFTWARE_RESET : PORT_SELECTIVE_RESET;
+	e100_sw_reset(bdp, cmd);
+	if (cmd == PORT_SOFTWARE_RESET) {
+		if (!e100_configure_device(bdp))
+			printk(KERN_ERR "e100: e100_deisolate_driver:" 
+		       		" device configuration failed\n");
+	} 
+
+	if (netif_running(bdp->device)) {
+
+		bdp->next_cu_cmd = START_WAIT;
+		bdp->last_tcb = NULL;
+
+		e100_start_ru(bdp);
+
+		/* relaunch watchdog timer in 2 sec */
+		mod_timer(&(bdp->watchdog_timer), jiffies + (2 * HZ));
+
+		// we must clear tcbs since we may have lost Tx intrrupt
+		// or have unsent frames on the tcb chain
+		e100_tcb_add_C_bit(bdp);
+		e100_tx_srv(bdp);
+		netif_wake_queue(bdp->device);
+		e100_set_intr_mask(bdp);
+	}
+}
+
+#ifdef SIOCETHTOOL
+static int
+e100_do_ethtool_ioctl(struct net_device *dev, struct ifreq *ifr)
+{
+	struct ethtool_cmd ecmd;
+	int rc = -EOPNOTSUPP;
+
+	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof (ecmd.cmd)))
+		return -EFAULT;
+
+	switch (ecmd.cmd) {
+	case ETHTOOL_GSET:
+		rc = e100_ethtool_get_settings(dev, ifr);
+		break;
+	case ETHTOOL_SSET:
+		rc = e100_ethtool_set_settings(dev, ifr);
+		break;
+#ifdef ETHTOOL_GDRVINFO
+	case ETHTOOL_GDRVINFO:
+		rc = e100_ethtool_get_drvinfo(dev, ifr);
+		break;
+#endif
+#ifdef  ETHTOOL_GEEPROM  /* GREGS broken in earlier ethtool.h */
+#ifdef  ETHTOOL_GREGS
+	case ETHTOOL_GREGS:
+		rc = e100_ethtool_gregs(dev, ifr);
+		break;
+#endif
+#endif
+#ifdef ETHTOOL_NWAY_RST
+	case ETHTOOL_NWAY_RST:
+		rc = e100_ethtool_nway_rst(dev, ifr);
+		break;
+#endif
+#ifdef ETHTOOL_GLINK
+	case ETHTOOL_GLINK:
+		rc = e100_ethtool_glink(dev, ifr);
+		break;
+#endif
+#ifdef ETHTOOL_GEEPROM
+	case ETHTOOL_GEEPROM:
+	case ETHTOOL_SEEPROM:
+		rc = e100_ethtool_eeprom(dev, ifr);
+		break;
+#endif
+#ifdef	ETHTOOL_GSTATS
+	case ETHTOOL_GSTATS: {
+		struct {
+			struct ethtool_stats cmd;
+			uint64_t data[E100_STATS_LEN];
+		} stats = { {ETHTOOL_GSTATS, E100_STATS_LEN} };
+		struct e100_private *bdp = dev->priv;
+		void *addr = ifr->ifr_data;
+		int i;
+
+		for(i = 0; i < E100_NET_STATS_LEN; i++)
+			stats.data[i] =
+				((unsigned long *)&bdp->drv_stats.net_stats)[i];
+		stats.data[i++] = bdp->drv_stats.tx_late_col;
+		stats.data[i++] = bdp->drv_stats.tx_ok_defrd;
+		stats.data[i++] = bdp->drv_stats.tx_one_retry;
+		stats.data[i++] = bdp->drv_stats.tx_mt_one_retry;
+		stats.data[i++] = bdp->drv_stats.rcv_cdt_frames;
+		stats.data[i++] = bdp->drv_stats.xmt_fc_pkts;
+		stats.data[i++] = bdp->drv_stats.rcv_fc_pkts;
+		stats.data[i++] = bdp->drv_stats.rcv_fc_unsupported;
+		stats.data[i++] = bdp->drv_stats.xmt_tco_pkts;
+		stats.data[i++] = bdp->drv_stats.rcv_tco_pkts;
+		if(copy_to_user(addr, &stats, sizeof(stats)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GSTATS */
+#ifdef ETHTOOL_GWOL
+	case ETHTOOL_GWOL:
+	case ETHTOOL_SWOL:
+		rc = e100_ethtool_wol(dev, ifr);
+		break;
+#endif		
+#ifdef ETHTOOL_TEST
+	case ETHTOOL_TEST:
+		rc = e100_ethtool_test(dev, ifr);
+		break;
+#endif
+#ifdef ETHTOOL_GSTRINGS
+	case ETHTOOL_GSTRINGS:
+		rc = e100_ethtool_gstrings(dev,ifr);
+		break;
+#endif
+#ifdef	ETHTOOL_PHYS_ID
+	case ETHTOOL_PHYS_ID:
+		rc = e100_ethtool_led_blink(dev,ifr);
+		break;
+#endif
+#ifdef	ETHTOOL_GRINGPARAM
+	case ETHTOOL_GRINGPARAM: {
+		struct ethtool_ringparam ering;
+		struct e100_private *bdp = dev->priv;
+		memset((void *) &ering, 0, sizeof(ering));
+		ering.rx_max_pending = E100_MAX_RFD;
+		ering.tx_max_pending = E100_MAX_TCB;
+		ering.rx_pending = bdp->params.RxDescriptors;
+		ering.tx_pending = bdp->params.TxDescriptors;
+		rc = copy_to_user(ifr->ifr_data, &ering, sizeof(ering))
+			? -EFAULT : 0;
+		return rc;
+	}
+#endif
+#ifdef	ETHTOOL_SRINGPARAM
+	case ETHTOOL_SRINGPARAM: {
+		struct ethtool_ringparam ering;
+		struct e100_private *bdp = dev->priv;
+		if (copy_from_user(&ering, ifr->ifr_data, sizeof(ering)))
+			return -EFAULT;
+		if (ering.rx_pending > E100_MAX_RFD 
+		    || ering.rx_pending < E100_MIN_RFD)
+			return -EINVAL;
+		if (ering.tx_pending > E100_MAX_TCB 
+		    || ering.tx_pending < E100_MIN_TCB)
+			return -EINVAL;
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			/* Use new values to open interface */
+			bdp->params.RxDescriptors = ering.rx_pending;
+			bdp->params.TxDescriptors = ering.tx_pending;
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
+		else {
+			bdp->params.RxDescriptors = ering.rx_pending;
+			bdp->params.TxDescriptors = ering.tx_pending;
+		}
+		return 0;
+	}
+#endif
+#ifdef	ETHTOOL_GPAUSEPARAM
+	case ETHTOOL_GPAUSEPARAM: {
+		struct ethtool_pauseparam epause;
+		struct e100_private *bdp = dev->priv;
+		memset((void *) &epause, 0, sizeof(epause));
+		if ((bdp->flags & IS_BACHELOR)
+		    && (bdp->params.b_params & PRM_FC)) {
+			epause.autoneg = 1;
+			if (bdp->flags && DF_LINK_FC_CAP) {
+				epause.rx_pause = 1;
+				epause.tx_pause = 1;
+			}
+			if (bdp->flags && DF_LINK_FC_TX_ONLY)
+				epause.tx_pause = 1;
+		}
+		rc = copy_to_user(ifr->ifr_data, &epause, sizeof(epause))
+			? -EFAULT : 0;
+		return rc;
+	}
+#endif
+#ifdef	ETHTOOL_SPAUSEPARAM
+	case ETHTOOL_SPAUSEPARAM: {
+		struct ethtool_pauseparam epause;
+		struct e100_private *bdp = dev->priv;
+		if (!(bdp->flags & IS_BACHELOR))
+			return -EINVAL;
+		if (copy_from_user(&epause, ifr->ifr_data, sizeof(epause)))
+			return -EFAULT;
+		if (epause.autoneg == 1)
+			bdp->params.b_params |= PRM_FC;
+		else
+			bdp->params.b_params &= ~PRM_FC;
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
+		return 0;
+	}
+#endif
+#ifdef	ETHTOOL_GRXCSUM
+	case ETHTOOL_GRXCSUM:
+	case ETHTOOL_GTXCSUM:
+	case ETHTOOL_GSG:
+	{	struct ethtool_value eval;
+		struct e100_private *bdp = dev->priv;
+		memset((void *) &eval, 0, sizeof(eval));
+		if ((ecmd.cmd == ETHTOOL_GRXCSUM) 
+		    && (bdp->params.b_params & PRM_XSUMRX))
+			eval.data = 1;
+		else
+			eval.data = 0;
+		rc = copy_to_user(ifr->ifr_data, &eval, sizeof(eval))
+			? -EFAULT : 0;
+		return rc;
+	}
+#endif
+#ifdef	ETHTOOL_SRXCSUM
+	case ETHTOOL_SRXCSUM:
+	case ETHTOOL_STXCSUM:
+	case ETHTOOL_SSG:
+	{	struct ethtool_value eval;
+		struct e100_private *bdp = dev->priv;
+		if (copy_from_user(&eval, ifr->ifr_data, sizeof(eval)))
+			return -EFAULT;
+		if (ecmd.cmd == ETHTOOL_SRXCSUM) {
+			if (eval.data == 1) { 
+				if (bdp->rev_id >= D101MA_REV_ID)
+					bdp->params.b_params |= PRM_XSUMRX;
+				else
+					return -EINVAL;
+			} else {
+				if (bdp->rev_id >= D101MA_REV_ID)
+					bdp->params.b_params &= ~PRM_XSUMRX;
+				else
+					return 0;
+			}
+		} else {
+			if (eval.data == 1)
+				return -EINVAL;
+			else
+				return 0;
+		}
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
+		return 0;
+	}
+#endif
+	default:
+		break;
+	}			//switch
+	return rc;
+}
+
+static int
+e100_ethtool_get_settings(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+	struct ethtool_cmd ecmd;
+	u16 advert = 0;
+
+	memset((void *) &ecmd, 0, sizeof (ecmd));
+
+	bdp = dev->priv;
+
+	ecmd.supported = bdp->speed_duplex_caps;
+
+	ecmd.port =
+		(bdp->speed_duplex_caps & SUPPORTED_TP) ? PORT_TP : PORT_FIBRE;
+	ecmd.transceiver = XCVR_INTERNAL;
+	ecmd.phy_address = bdp->phy_addr;
+
+	if (netif_carrier_ok(bdp->device)) {
+		ecmd.speed = bdp->cur_line_speed;
+		ecmd.duplex =
+			(bdp->cur_dplx_mode == HALF_DUPLEX) ? DUPLEX_HALF : DUPLEX_FULL;
+	}
+	else {
+		ecmd.speed = -1;
+		ecmd.duplex = -1;
+	}
+
+	ecmd.advertising = ADVERTISED_TP;
+
+	if (bdp->params.e100_speed_duplex == E100_AUTONEG) {
+		ecmd.autoneg = AUTONEG_ENABLE;
+		ecmd.advertising |= ADVERTISED_Autoneg;
+	} else {
+		ecmd.autoneg = AUTONEG_DISABLE;
+	}
+
+	if (bdp->speed_duplex_caps & SUPPORTED_MII) {
+		e100_mdi_read(bdp, MII_ADVERTISE, bdp->phy_addr, &advert);
+
+		if (advert & ADVERTISE_10HALF)
+			ecmd.advertising |= ADVERTISED_10baseT_Half;
+		if (advert & ADVERTISE_10FULL)
+			ecmd.advertising |= ADVERTISED_10baseT_Full;
+		if (advert & ADVERTISE_100HALF)
+			ecmd.advertising |= ADVERTISED_100baseT_Half;
+		if (advert & ADVERTISE_100FULL)
+			ecmd.advertising |= ADVERTISED_100baseT_Full;
+	} else {
+		ecmd.autoneg = AUTONEG_DISABLE;
+		ecmd.advertising &= ~ADVERTISED_Autoneg;
+	}
+
+	if (copy_to_user(ifr->ifr_data, &ecmd, sizeof (ecmd)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int
+e100_ethtool_set_settings(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+	int e100_new_speed_duplex;
+	int ethtool_new_speed_duplex;
+	struct ethtool_cmd ecmd;
+
+	bdp = dev->priv;
+	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof (ecmd))) {
+		return -EFAULT;
+	}
+
+	if ((ecmd.autoneg == AUTONEG_ENABLE)
+	    && (bdp->speed_duplex_caps & SUPPORTED_Autoneg)) {
+		bdp->params.e100_speed_duplex = E100_AUTONEG;
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
+	} else {
+		if (ecmd.speed == SPEED_10) {
+			if (ecmd.duplex == DUPLEX_HALF) {
+				e100_new_speed_duplex =
+					E100_SPEED_10_HALF;
+				ethtool_new_speed_duplex =
+					SUPPORTED_10baseT_Half;
+			} else { 
+				e100_new_speed_duplex =
+					E100_SPEED_10_FULL;
+				ethtool_new_speed_duplex =
+					SUPPORTED_10baseT_Full;
+			} 
+		} else { 
+			if (ecmd.duplex == DUPLEX_HALF) {
+				e100_new_speed_duplex =
+					E100_SPEED_100_HALF;
+				ethtool_new_speed_duplex =
+					SUPPORTED_100baseT_Half;
+			} else { 
+				e100_new_speed_duplex =
+					E100_SPEED_100_FULL;
+				ethtool_new_speed_duplex =
+					SUPPORTED_100baseT_Full;
+			} 
+		}
+
+		if (bdp->speed_duplex_caps & ethtool_new_speed_duplex) {
+			bdp->params.e100_speed_duplex =
+				e100_new_speed_duplex;
+			if (netif_running(dev)) {
+				spin_lock_bh(&dev->xmit_lock);
+				e100_close(dev);
+				spin_unlock_bh(&dev->xmit_lock);
+				e100_hw_init(bdp);
+				e100_open(dev);
+			}
+		} else {
+			return -EOPNOTSUPP;
+		} 
+	}
+
+	return 0;
+}
+
+#ifdef ETHTOOL_GLINK
+static int
+e100_ethtool_glink(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+	struct ethtool_value info;
+
+	memset((void *) &info, 0, sizeof (info));
+
+	bdp = dev->priv;
+	info.cmd = ETHTOOL_GLINK;
+
+	/* Consider both PHY link and netif_running */
+	info.data = e100_update_link_state(bdp);
+
+	if (copy_to_user(ifr->ifr_data, &info, sizeof (info)))
+		return -EFAULT;
+
+	return 0;
+}
+#endif
+
+#ifdef ETHTOOL_TEST
+static int
+e100_ethtool_test(struct net_device *dev, struct ifreq *ifr)
+{
+	struct ethtool_test *info;
+	int rc = -EFAULT;
+
+	info = kmalloc(sizeof(*info) + max_test_res * sizeof(u64),
+		       GFP_ATOMIC);
+
+	if (!info)
+		return -ENOMEM;
+
+	memset((void *) info, 0, sizeof(*info) +
+				 max_test_res * sizeof(u64));
+
+	if (copy_from_user(info, ifr->ifr_data, sizeof(*info)))
+		goto exit;
+
+	info->flags = e100_run_diag(dev, info->data, info->flags);
+
+	if (!copy_to_user(ifr->ifr_data, info,
+			 sizeof(*info) + max_test_res * sizeof(u64)))
+		rc = 0;
+exit:
+	kfree(info);
+	return rc;
+}
+#endif
+
+#ifdef  ETHTOOL_GEEPROM  /* GREGS broken in earlier ethtool.h */
+#ifdef ETHTOOL_GREGS
+static int
+e100_ethtool_gregs(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+	u32 regs_buff[E100_REGS_LEN];
+	struct ethtool_regs regs = {ETHTOOL_GREGS};
+	void *addr = ifr->ifr_data;
+	u16 mdi_reg;
+
+	bdp = dev->priv;
+
+	if(copy_from_user(&regs, addr, sizeof(regs)))
+		return -EFAULT;
+
+	regs.version = (1 << 24) | bdp->rev_id;
+	regs_buff[0] = readb(&(bdp->scb->scb_cmd_hi)) << 24 |
+		readb(&(bdp->scb->scb_cmd_low)) << 16 |
+		readw(&(bdp->scb->scb_status));
+	e100_mdi_read(bdp, MII_NCONFIG, bdp->phy_addr, &mdi_reg);
+	regs_buff[1] = mdi_reg;
+
+	if(copy_to_user(addr, &regs, sizeof(regs)))
+		return -EFAULT;
+
+	addr += offsetof(struct ethtool_regs, data);
+	if(copy_to_user(addr, regs_buff, regs.len))
+		return -EFAULT;
+
+	return 0;
+}
+#endif
+#endif
+
+#ifdef ETHTOOL_NWAY_RST
+static int
+e100_ethtool_nway_rst(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+
+	bdp = dev->priv;
+
+	if ((bdp->speed_duplex_caps & SUPPORTED_Autoneg) &&
+	    (bdp->params.e100_speed_duplex == E100_AUTONEG)) {
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
+	} else {
+		return -EFAULT;
+	}
+	return 0;
+}
+#endif
+
+#ifdef ETHTOOL_GDRVINFO
+static int
+e100_ethtool_get_drvinfo(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+	struct ethtool_drvinfo info;
+
+	memset((void *) &info, 0, sizeof (info));
+
+	bdp = dev->priv;
+
+	strncpy(info.driver, e100_short_driver_name, sizeof (info.driver) - 1);
+	strncpy(info.version, e100_driver_version, sizeof (info.version) - 1);
+	strncpy(info.fw_version, "N/A",
+		sizeof (info.fw_version) - 1);
+	strncpy(info.bus_info, pci_name(bdp->pdev),
+		sizeof (info.bus_info) - 1);
+#ifdef	ETHTOOL_GSTATS
+	info.n_stats = E100_STATS_LEN;
+#endif	/* ETHTOOL_GSTATS */
+#ifdef	ETHTOOL_GREGS
+	info.regdump_len  = E100_REGS_LEN * sizeof(u32);
+#endif	/* ETHTOOL_GREGS */
+#ifdef ETHTOOL_GEEPROM
+	info.eedump_len = (bdp->eeprom_size << 1);	
+#endif
+#ifdef ETHTOOL_TEST
+	info.testinfo_len = max_test_res;
+#endif
+	if (copy_to_user(ifr->ifr_data, &info, sizeof (info)))
+		return -EFAULT;
+
+	return 0;
+}
+#endif //ETHTOOL_GDRVINFO
+
+#ifdef ETHTOOL_GEEPROM
+static int
+e100_ethtool_eeprom(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+	struct ethtool_eeprom ecmd;
+	u16 eeprom_data[256];
+	u16 *usr_eeprom_ptr;
+	u16 first_word, last_word;
+	int i, max_len;
+	void *ptr;
+	u8 *eeprom_data_bytes = (u8 *)eeprom_data;
+
+	bdp = dev->priv;
+
+	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof (ecmd)))
+		return -EFAULT;
+
+	usr_eeprom_ptr =
+		(u16 *) (ifr->ifr_data + offsetof(struct ethtool_eeprom, data));
+
+        max_len = bdp->eeprom_size * 2;
+        
+        if (ecmd.offset > ecmd.offset + ecmd.len)
+        	return -EINVAL;
+        	
+	if ((ecmd.offset + ecmd.len) > max_len)
+		ecmd.len = (max_len - ecmd.offset);
+
+	first_word = ecmd.offset >> 1;
+	last_word = (ecmd.offset + ecmd.len - 1) >> 1;
+		
+	if (first_word >= bdp->eeprom_size)
+		return -EFAULT;
+
+	if (ecmd.cmd == ETHTOOL_GEEPROM) {
+        	for(i = 0; i <= (last_word - first_word); i++)
+			eeprom_data[i] = e100_eeprom_read(bdp, first_word + i);
+
+		ecmd.magic = E100_EEPROM_MAGIC;
+
+		if (copy_to_user(ifr->ifr_data, &ecmd, sizeof (ecmd)))
+			return -EFAULT;
+
+		if(ecmd.offset & 1)
+			eeprom_data_bytes++;
+		if (copy_to_user(usr_eeprom_ptr, eeprom_data_bytes, ecmd.len))
+			return -EFAULT;
+	} else {
+		if (ecmd.magic != E100_EEPROM_MAGIC)
+			return -EFAULT;
+
+		ptr = (void *)eeprom_data;
+        	if(ecmd.offset & 1) {
+                	/* need modification of first changed EEPROM word */
+                	/* only the second byte of the word is being modified */
+			eeprom_data[0] = e100_eeprom_read(bdp, first_word);
+                	ptr++;
+        	}
+        	if((ecmd.offset + ecmd.len) & 1) {
+	                /* need modification of last changed EEPROM word */
+	                /* only the first byte of the word is being modified */
+			eeprom_data[last_word - first_word] = 
+				e100_eeprom_read(bdp, last_word);
+		}
+        	if(copy_from_user(ptr, usr_eeprom_ptr, ecmd.len))
+	                return -EFAULT;
+
+		e100_eeprom_write_block(bdp, first_word, eeprom_data,
+					last_word - first_word + 1);
+
+		if (copy_to_user(ifr->ifr_data, &ecmd, sizeof (ecmd)))
+			return -EFAULT;
+	}
+	return 0;
+}
+#endif
+
+#ifdef ETHTOOL_PHYS_ID
+#define E100_BLINK_INTERVAL	(HZ/4)
+/**
+ * e100_led_control
+ * @bdp: atapter's private data struct
+ * @led_mdi_op: led operation
+ *
+ * Software control over adapter's led. The possible operations are:
+ * TURN LED OFF, TURN LED ON and RETURN LED CONTROL TO HARDWARE.
+ */
+static void
+e100_led_control(struct e100_private *bdp, u16 led_mdi_op)
+{
+	e100_mdi_write(bdp, PHY_82555_LED_SWITCH_CONTROL,
+		       bdp->phy_addr, led_mdi_op);
+
+}
+/**
+ * e100_led_blink_callback
+ * @data: pointer to atapter's private data struct
+ *
+ * Blink timer callback function. Toggles ON/OFF led status bit and calls
+ * led hardware access function. 
+ */
+static void
+e100_led_blink_callback(unsigned long data)
+{
+	struct e100_private *bdp = (struct e100_private *) data;
+
+	if(bdp->flags & LED_IS_ON) {
+		bdp->flags &= ~LED_IS_ON;
+		e100_led_control(bdp, PHY_82555_LED_OFF);
+	} else {
+		bdp->flags |= LED_IS_ON;
+		if (bdp->rev_id >= D101MA_REV_ID)
+			e100_led_control(bdp, PHY_82555_LED_ON_559);
+		else
+			e100_led_control(bdp, PHY_82555_LED_ON_PRE_559);
+	}
+
+	mod_timer(&bdp->blink_timer, jiffies + E100_BLINK_INTERVAL);
+}
+/**
+ * e100_ethtool_led_blink
+ * @dev: pointer to atapter's net_device struct
+ * @ifr: pointer to ioctl request structure
+ *
+ * Blink led ioctl handler. Initialtes blink timer and sleeps until
+ * blink period expires. Than it kills timer and returns. The led control
+ * is returned back to hardware when blink timer is killed.
+ */
+static int
+e100_ethtool_led_blink(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+	struct ethtool_value ecmd;
+
+	bdp = dev->priv;
+
+	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof (ecmd)))
+		return -EFAULT;
+
+	if(!bdp->blink_timer.function) {
+		init_timer(&bdp->blink_timer);
+		bdp->blink_timer.function = e100_led_blink_callback;
+		bdp->blink_timer.data = (unsigned long) bdp;
+	}
+
+	mod_timer(&bdp->blink_timer, jiffies);
+
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	if ((!ecmd.data) || (ecmd.data > (u32)(MAX_SCHEDULE_TIMEOUT / HZ)))
+		ecmd.data = (u32)(MAX_SCHEDULE_TIMEOUT / HZ);
+
+	schedule_timeout(ecmd.data * HZ);
+
+	del_timer_sync(&bdp->blink_timer);
+
+	e100_led_control(bdp, PHY_82555_LED_NORMAL_CONTROL);
+
+	return 0;
+}
+#endif
+
+static inline int __devinit
+e100_10BaseT_adapter(struct e100_private *bdp)
+{
+	return ((bdp->pdev->device == 0x1229) &&
+		(bdp->pdev->subsystem_vendor == 0x8086) &&
+		(bdp->pdev->subsystem_device == 0x0003));
+}
+
+static void __devinit
+e100_get_speed_duplex_caps(struct e100_private *bdp)
+{
+	u16 status;
+
+	e100_mdi_read(bdp, MII_BMSR, bdp->phy_addr, &status);
+
+	bdp->speed_duplex_caps = 0;
+
+	bdp->speed_duplex_caps |=
+		(status & BMSR_ANEGCAPABLE) ? SUPPORTED_Autoneg : 0;
+
+	bdp->speed_duplex_caps |=
+		(status & BMSR_10HALF) ? SUPPORTED_10baseT_Half : 0;
+
+	bdp->speed_duplex_caps |=
+		(status & BMSR_10FULL) ? SUPPORTED_10baseT_Full : 0;
+
+	bdp->speed_duplex_caps |=
+		(status & BMSR_100HALF) ? SUPPORTED_100baseT_Half : 0;
+
+	bdp->speed_duplex_caps |=
+		(status & BMSR_100FULL) ? SUPPORTED_100baseT_Full : 0;
+
+	if (IS_NC3133(bdp))
+		bdp->speed_duplex_caps =
+			(SUPPORTED_FIBRE | SUPPORTED_100baseT_Full);
+	else
+		bdp->speed_duplex_caps |= SUPPORTED_TP;
+
+	if ((status == 0xFFFF) && e100_10BaseT_adapter(bdp)) {
+		bdp->speed_duplex_caps =
+			(SUPPORTED_10baseT_Half | SUPPORTED_TP);
+	} else {
+		bdp->speed_duplex_caps |= SUPPORTED_MII;
+	}
+
+}
+
+#ifdef CONFIG_PM
+static unsigned char
+e100_setup_filter(struct e100_private *bdp)
+{
+	cb_header_t *ntcb_hdr;
+	unsigned char res = false;
+	nxmit_cb_entry_t *cmd;
+
+	if ((cmd = e100_alloc_non_tx_cmd(bdp)) == NULL) {
+		goto exit;
+	}
+
+	ntcb_hdr = (cb_header_t *) cmd->non_tx_cmd;
+	ntcb_hdr->cb_cmd = __constant_cpu_to_le16(CB_LOAD_FILTER);
+
+	/* Set EL and FIX bit */
+	(cmd->non_tx_cmd)->ntcb.filter.filter_data[0] =
+		__constant_cpu_to_le32(CB_FILTER_EL | CB_FILTER_FIX);
+
+	if (bdp->wolopts & WAKE_UCAST) {
+		(cmd->non_tx_cmd)->ntcb.filter.filter_data[0] |=
+			__constant_cpu_to_le32(CB_FILTER_IA_MATCH);
+	}
+
+	if (bdp->wolopts & WAKE_ARP) {
+		/* Setup ARP bit and lower IP parts */
+		/* bdp->ip_lbytes contains 2 lower bytes of IP address in network byte order */
+		(cmd->non_tx_cmd)->ntcb.filter.filter_data[0] |=
+			cpu_to_le32(CB_FILTER_ARP | bdp->ip_lbytes);
+	}
+
+	res = e100_exec_non_cu_cmd(bdp, cmd);
+	if (!res)
+		printk(KERN_WARNING "e100: %s: Filter setup failed\n",
+		       bdp->device->name);
+
+exit:
+	return res;
+
+}
+
+static void
+e100_do_wol(struct pci_dev *pcid, struct e100_private *bdp)
+{
+	e100_config_wol(bdp);
+
+	if (e100_config(bdp)) {
+		if (bdp->wolopts & (WAKE_UCAST | WAKE_ARP))
+			if (!e100_setup_filter(bdp))
+				printk(KERN_ERR
+				       "e100: WOL options failed\n");
+	} else {
+		printk(KERN_ERR "e100: config WOL failed\n");
+	}
+}
+#endif
+
+#ifdef ETHTOOL_SWOL
+static u16
+e100_get_ip_lbytes(struct net_device *dev)
+{
+	struct in_ifaddr *ifa;
+	struct in_device *in_dev;
+	u32 res = 0;
+
+	in_dev = (struct in_device *) dev->ip_ptr;
+	/* Check if any in_device bound to interface */
+	if (in_dev) {
+		/* Check if any IP address is bound to interface */
+		if ((ifa = in_dev->ifa_list) != NULL) {
+			res = __constant_ntohl(ifa->ifa_address);
+			res = __constant_htons(res & 0x0000ffff);
+		}
+	}
+	return res;
+}
+#endif
+
+#ifdef ETHTOOL_GWOL	
+static int
+e100_ethtool_wol(struct net_device *dev, struct ifreq *ifr)
+{
+	struct e100_private *bdp;
+	struct ethtool_wolinfo wolinfo;
+	int res = 0;
+
+	bdp = dev->priv;
+
+	if (copy_from_user(&wolinfo, ifr->ifr_data, sizeof (wolinfo))) {
+		return -EFAULT;
+	}
+
+	switch (wolinfo.cmd) {
+	case ETHTOOL_GWOL:
+		wolinfo.supported = bdp->wolsupported;
+		wolinfo.wolopts = bdp->wolopts;
+		if (copy_to_user(ifr->ifr_data, &wolinfo, sizeof (wolinfo)))
+			res = -EFAULT;
+		break;
+#ifdef ETHTOOL_SWOL	
+	case ETHTOOL_SWOL:
+		/* If ALL requests are supported or request is DISABLE wol */
+		if (((wolinfo.wolopts & bdp->wolsupported) == wolinfo.wolopts)
+		    || (wolinfo.wolopts == 0)) {
+			bdp->wolopts = wolinfo.wolopts;
+		} else {
+			res = -EOPNOTSUPP;
+		}
+		if (wolinfo.wolopts & WAKE_ARP)
+			bdp->ip_lbytes = e100_get_ip_lbytes(dev);
+		break;
+#endif
+	default:
+		break;
+	}
+	return res;
+}
+#endif
+
+#ifdef ETHTOOL_GSTRINGS
+static int e100_ethtool_gstrings(struct net_device *dev, struct ifreq *ifr)
+{
+	struct ethtool_gstrings info;
+	char *strings = NULL;
+	char *usr_strings;
+	int i;
+
+	memset((void *) &info, 0, sizeof(info));
+
+	usr_strings = (u8 *) (ifr->ifr_data + 
+			      offsetof(struct ethtool_gstrings, data));
+
+	if (copy_from_user(&info, ifr->ifr_data, sizeof (info)))
+		return -EFAULT;
+
+	switch (info.string_set) {
+	case ETH_SS_TEST: {
+		int ret = 0;
+		if (info.len > max_test_res)
+			info.len = max_test_res;
+		strings = kmalloc(info.len * ETH_GSTRING_LEN, GFP_ATOMIC);
+		if (!strings)
+			return -ENOMEM;
+		memset(strings, 0, info.len * ETH_GSTRING_LEN);
+
+		for (i = 0; i < info.len; i++) {
+			sprintf(strings + i * ETH_GSTRING_LEN, "%s",
+				test_strings[i]);
+		}
+		if (copy_to_user(ifr->ifr_data, &info, sizeof (info)))
+			ret = -EFAULT;
+		if (copy_to_user(usr_strings, strings, info.len * ETH_GSTRING_LEN))
+			ret = -EFAULT;
+		kfree(strings);
+		return ret;
+	}
+#ifdef	ETHTOOL_GSTATS
+	case ETH_SS_STATS: {
+		char *strings = NULL;
+		void *addr = ifr->ifr_data;
+		info.len = E100_STATS_LEN;
+		strings = *e100_gstrings_stats;
+		if(copy_to_user(ifr->ifr_data, &info, sizeof(info)))
+			return -EFAULT;
+		addr += offsetof(struct ethtool_gstrings, data);
+		if(copy_to_user(addr, strings,
+		   info.len * ETH_GSTRING_LEN))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GSTATS */
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+#endif
+#endif /*SIOCETHTOOL */
+
+#ifdef SIOCGMIIPHY
+static int
+e100_mii_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct e100_private *bdp;
+	struct mii_ioctl_data *data_ptr =
+		(struct mii_ioctl_data *) &(ifr->ifr_data);
+
+	bdp = dev->priv;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:
+		data_ptr->phy_id = bdp->phy_addr & 0x1f;
+		break;
+
+	case SIOCGMIIREG:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		e100_mdi_read(bdp, data_ptr->reg_num & 0x1f, bdp->phy_addr,
+			      &(data_ptr->val_out));
+		break;
+
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		/* If reg = 0 && change speed/duplex */
+		if (data_ptr->reg_num == 0 && 
+			(data_ptr->val_in == (BMCR_ANENABLE | BMCR_ANRESTART) /* restart cmd */
+			|| data_ptr->val_in == (BMCR_RESET) /* reset cmd */ 
+			|| data_ptr->val_in & (BMCR_SPEED100 | BMCR_FULLDPLX) 
+			|| data_ptr->val_in == 0)) {
+				if (data_ptr->val_in == (BMCR_ANENABLE | BMCR_ANRESTART)
+					|| data_ptr->val_in == (BMCR_RESET))
+					bdp->params.e100_speed_duplex = E100_AUTONEG;
+				else if (data_ptr->val_in == (BMCR_SPEED100 | BMCR_FULLDPLX))
+					bdp->params.e100_speed_duplex = E100_SPEED_100_FULL;
+				else if (data_ptr->val_in == (BMCR_SPEED100))
+					bdp->params.e100_speed_duplex = E100_SPEED_100_HALF;
+				else if (data_ptr->val_in == (BMCR_FULLDPLX))
+					bdp->params.e100_speed_duplex = E100_SPEED_10_FULL;
+				else
+					bdp->params.e100_speed_duplex = E100_SPEED_10_HALF;
+				if (netif_running(dev)) {
+					spin_lock_bh(&dev->xmit_lock);
+					e100_close(dev);
+					spin_unlock_bh(&dev->xmit_lock);
+					e100_hw_init(bdp);
+					e100_open(dev);
+				}
+		}
+		else 
+			/* Only allows changing speed/duplex */
+			return -EINVAL;
+		
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+#endif /* SIOCGMIIPHY */
+
+nxmit_cb_entry_t *
+e100_alloc_non_tx_cmd(struct e100_private *bdp)
+{
+	nxmit_cb_entry_t *non_tx_cmd_elem;
+
+	if (!(non_tx_cmd_elem = (nxmit_cb_entry_t *)
+	      kmalloc(sizeof (nxmit_cb_entry_t), GFP_ATOMIC))) {
+		return NULL;
+	}
+	non_tx_cmd_elem->non_tx_cmd =
+		pci_alloc_consistent(bdp->pdev, sizeof (nxmit_cb_t),
+				     &(non_tx_cmd_elem->dma_addr));
+	if (non_tx_cmd_elem->non_tx_cmd == NULL) {
+		kfree(non_tx_cmd_elem);
+		return NULL;
+	}
+	return non_tx_cmd_elem;
+}
+
+void
+e100_free_non_tx_cmd(struct e100_private *bdp,
+		     nxmit_cb_entry_t *non_tx_cmd_elem)
+{
+	pci_free_consistent(bdp->pdev, sizeof (nxmit_cb_t),
+			    non_tx_cmd_elem->non_tx_cmd,
+			    non_tx_cmd_elem->dma_addr);
+	kfree(non_tx_cmd_elem);
+}
+
+static void
+e100_free_nontx_list(struct e100_private *bdp)
+{
+	nxmit_cb_entry_t *command;
+	int i;
+
+	while (!list_empty(&bdp->non_tx_cmd_list)) {
+		command = list_entry(bdp->non_tx_cmd_list.next,
+				     nxmit_cb_entry_t, list_elem);
+		list_del(&(command->list_elem));
+		e100_free_non_tx_cmd(bdp, command);
+	}
+
+	for (i = 0; i < CB_MAX_NONTX_CMD; i++) {
+		bdp->same_cmd_entry[i] = NULL;
+	}
+}
+
+static unsigned char
+e100_delayed_exec_non_cu_cmd(struct e100_private *bdp,
+			     nxmit_cb_entry_t *command)
+{
+	nxmit_cb_entry_t *same_command;
+	cb_header_t *ntcb_hdr;
+	u16 cmd;
+
+	ntcb_hdr = (cb_header_t *) command->non_tx_cmd;
+
+	cmd = CB_CMD_MASK & le16_to_cpu(ntcb_hdr->cb_cmd);
+
+	spin_lock_bh(&(bdp->bd_non_tx_lock));
+
+	same_command = bdp->same_cmd_entry[cmd];
+
+	if (same_command != NULL) {
+		memcpy((void *) (same_command->non_tx_cmd),
+		       (void *) (command->non_tx_cmd), sizeof (nxmit_cb_t));
+		e100_free_non_tx_cmd(bdp, command);
+	} else {
+		list_add_tail(&(command->list_elem), &(bdp->non_tx_cmd_list));
+		bdp->same_cmd_entry[cmd] = command;
+	}
+
+	if (bdp->non_tx_command_state == E100_NON_TX_IDLE) {
+		bdp->non_tx_command_state = E100_WAIT_TX_FINISH;
+		mod_timer(&(bdp->nontx_timer_id), jiffies + 1);
+	}
+
+	spin_unlock_bh(&(bdp->bd_non_tx_lock));
+	return true;
+}
+
+static void
+e100_non_tx_background(unsigned long ptr)
+{
+	struct e100_private *bdp = (struct e100_private *) ptr;
+	nxmit_cb_entry_t *active_command;
+	int restart = true;
+	cb_header_t *non_tx_cmd;
+	u8 sub_cmd;
+
+	spin_lock_bh(&(bdp->bd_non_tx_lock));
+
+	switch (bdp->non_tx_command_state) {
+	case E100_WAIT_TX_FINISH:
+		if (bdp->last_tcb != NULL) {
+			rmb();
+			if ((bdp->last_tcb->tcb_hdr.cb_status &
+			     __constant_cpu_to_le16(CB_STATUS_COMPLETE)) == 0)
+				goto exit;
+		}
+		if ((readw(&bdp->scb->scb_status) & SCB_CUS_MASK) ==
+		    SCB_CUS_ACTIVE) {
+			goto exit;
+		}
+		break;
+
+	case E100_WAIT_NON_TX_FINISH:
+		active_command = list_entry(bdp->non_tx_cmd_list.next,
+					    nxmit_cb_entry_t, list_elem);
+		rmb();
+
+		if (((((cb_header_t *) (active_command->non_tx_cmd))->cb_status
+		      & __constant_cpu_to_le16(CB_STATUS_COMPLETE)) == 0)
+		    && time_before(jiffies, active_command->expiration_time)) {
+			goto exit;
+		} else {
+			non_tx_cmd = (cb_header_t *) active_command->non_tx_cmd;
+			sub_cmd = CB_CMD_MASK & le16_to_cpu(non_tx_cmd->cb_cmd);
+#ifdef E100_CU_DEBUG			
+			if (!(non_tx_cmd->cb_status 
+			    & __constant_cpu_to_le16(CB_STATUS_COMPLETE)))
+				printk(KERN_ERR "e100: %s: Queued "
+					"command (%x) timeout\n", 
+					bdp->device->name, sub_cmd);
+#endif			
+			list_del(&(active_command->list_elem));
+			e100_free_non_tx_cmd(bdp, active_command);
+		}
+		break;
+
+	default:
+		break;
+	}			//switch
+
+	if (list_empty(&bdp->non_tx_cmd_list)) {
+		bdp->non_tx_command_state = E100_NON_TX_IDLE;
+		spin_lock_irq(&(bdp->bd_lock));
+		bdp->next_cu_cmd = START_WAIT;
+		spin_unlock_irq(&(bdp->bd_lock));
+		restart = false;
+		goto exit;
+	} else {
+		u16 cmd_type;
+
+		bdp->non_tx_command_state = E100_WAIT_NON_TX_FINISH;
+		active_command = list_entry(bdp->non_tx_cmd_list.next,
+					    nxmit_cb_entry_t, list_elem);
+		sub_cmd = ((cb_header_t *) active_command->non_tx_cmd)->cb_cmd;
+		spin_lock_irq(&(bdp->bd_lock));
+		e100_wait_exec_cmplx(bdp, active_command->dma_addr,
+				     SCB_CUC_START, sub_cmd);
+		spin_unlock_irq(&(bdp->bd_lock));
+		active_command->expiration_time = jiffies + HZ;
+		cmd_type = CB_CMD_MASK &
+			le16_to_cpu(((cb_header_t *)
+				     (active_command->non_tx_cmd))->cb_cmd);
+		bdp->same_cmd_entry[cmd_type] = NULL;
+	}
+
+exit:
+	if (restart) {
+		mod_timer(&(bdp->nontx_timer_id), jiffies + 1);
+	} else {
+		if (netif_running(bdp->device))
+			netif_wake_queue(bdp->device);
+	}
+	spin_unlock_bh(&(bdp->bd_non_tx_lock));
+}
+
+#ifdef NETIF_F_HW_VLAN_TX
+static void
+e100_vlan_rx_register(struct net_device *netdev, struct vlan_group *grp)
+{
+	struct e100_private *bdp = netdev->priv;
+
+	e100_disable_clear_intr(bdp);
+	bdp->vlgrp = grp;
+
+	if(grp) {
+		/* enable VLAN tag insert/strip */
+		e100_config_vlan_drop(bdp, true);
+
+	} else {
+		/* disable VLAN tag insert/strip */
+		e100_config_vlan_drop(bdp, false);
+	}
+
+	e100_config(bdp);
+	e100_set_intr_mask(bdp);
+}
+
+static void
+e100_vlan_rx_add_vid(struct net_device *netdev, u16 vid)
+{
+	/* We don't do Vlan filtering */
+	return;
+}
+
+static void
+e100_vlan_rx_kill_vid(struct net_device *netdev, u16 vid)
+{
+	struct e100_private *bdp = netdev->priv;
+
+	if(bdp->vlgrp)
+		bdp->vlgrp->vlan_devices[vid] = NULL;
+	/* We don't do Vlan filtering */
+	return;
+}
+#endif /* NETIF_F_HW_VLAN_TX */
+
+#ifdef CONFIG_PM
+static int
+e100_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
+{
+        struct pci_dev *pdev = NULL;
+	
+        switch(event) {
+        case SYS_DOWN:
+        case SYS_HALT:
+        case SYS_POWER_OFF:
+		while ((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
+                        if(pci_dev_driver(pdev) == &e100_driver) {
+				/* If net_device struct is allocated? */
+                                if (pci_get_drvdata(pdev))
+					e100_suspend(pdev, 3);
+
+			}
+		}
+        }
+        return NOTIFY_DONE;
+}
+
+static int
+e100_suspend(struct pci_dev *pcid, u32 state)
+{
+	struct net_device *netdev = pci_get_drvdata(pcid);
+	struct e100_private *bdp = netdev->priv;
+
+	e100_isolate_driver(bdp);
+	pci_save_state(pcid, bdp->pci_state);
+
+	/* Enable or disable WoL */
+	e100_do_wol(pcid, bdp);
+	
+	/* If wol is enabled */
+	if (bdp->wolopts || e100_asf_enabled(bdp)) {
+		pci_enable_wake(pcid, 3, 1);	/* Enable PME for power state D3 */
+		pci_set_power_state(pcid, 3);	/* Set power state to D3.        */
+	} else {
+		/* Disable bus mastering */
+		pci_disable_device(pcid);
+		pci_set_power_state(pcid, state);
+	}
+	return 0;
+}
+
+static int
+e100_resume(struct pci_dev *pcid)
+{
+	struct net_device *netdev = pci_get_drvdata(pcid);
+	struct e100_private *bdp = netdev->priv;
+
+	pci_set_power_state(pcid, 0);
+	pci_enable_wake(pcid, 0, 0);	/* Clear PME status and disable PME */
+	pci_restore_state(pcid, bdp->pci_state);
+
+	/* Also do device full reset because device was in D3 state */
+	e100_deisolate_driver(bdp, true);
+
+	return 0;
+}
+
+/**
+ * e100_asf_enabled - checks if ASF is configured on the current adaper
+ *                    by reading registers 0xD and 0x90 in the EEPROM 
+ * @bdp: atapter's private data struct
+ *
+ * Returns: true if ASF is enabled
+ */
+static unsigned char
+e100_asf_enabled(struct e100_private *bdp)
+{
+	u16 asf_reg;
+	u16 smbus_addr_reg;
+	if ((bdp->pdev->device >= 0x1050) && (bdp->pdev->device <= 0x1055)) {
+		asf_reg = e100_eeprom_read(bdp, EEPROM_CONFIG_ASF);
+		if ((asf_reg & EEPROM_FLAG_ASF)
+		    && !(asf_reg & EEPROM_FLAG_GCL)) {
+			smbus_addr_reg = 
+				e100_eeprom_read(bdp, EEPROM_SMBUS_ADDR);
+			if ((smbus_addr_reg & 0xFF) != 0xFE) 
+				return true;
+		}
+	}
+	return false;
+}
+#endif /* CONFIG_PM */
+
+#ifdef E100_CU_DEBUG
+unsigned char
+e100_cu_unknown_state(struct e100_private *bdp)
+{
+	u8 scb_cmd_low;
+	u16 scb_status;
+	scb_cmd_low = bdp->scb->scb_cmd_low;
+	scb_status = le16_to_cpu(bdp->scb->scb_status);
+	/* If CU is active and executing unknown cmd */
+	if (scb_status & SCB_CUS_ACTIVE && scb_cmd_low & SCB_CUC_UNKNOWN)
+		return true;
+	else
+		return false;
+}
+#endif
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+
+static void e100_netpoll (struct net_device *dev)
+{
+	struct e100_private *adapter = dev->priv;
+	disable_irq(adapter->pdev->irq);
+	e100intr (adapter->pdev->irq, dev, NULL);
+	enable_irq(adapter->pdev->irq);
+}
+#endif
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_phy.c linux-2.6.5.SUSE/drivers/net/e100-intel/e100_phy.c
--- linux-2.6.5/drivers/net/e100-intel/e100_phy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_phy.c	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,1163 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+#include "e100_phy.h"
+
+void e100_handle_zlock(struct e100_private *bdp);
+
+/* 
+ * Procedure:	e100_mdi_write
+ *
+ * Description: This routine will write a value to the specified MII register
+ *		of an external MDI compliant device (e.g. PHY 100).  The
+ *		command will execute in polled mode.
+ *
+ * Arguments:
+ *	bdp - Ptr to this card's e100_bdconfig structure
+ *	reg_addr - The MII register that we are writing to
+ *	phy_addr - The MDI address of the Phy component.
+ *	data - The value that we are writing to the MII register.
+ *
+ * Returns:
+ *	NOTHING
+ */
+int
+e100_mdi_write(struct e100_private *bdp, u32 reg_addr, u32 phy_addr, u16 data)
+{
+	int e100_retry;
+	u32 temp_val;
+	unsigned int mdi_cntrl;
+
+	spin_lock_bh(&bdp->mdi_access_lock);
+	temp_val = (((u32) data) | (reg_addr << 16) |
+		    (phy_addr << 21) | (MDI_WRITE << 26));
+	writel(temp_val, &bdp->scb->scb_mdi_cntrl);
+	readw(&bdp->scb->scb_status);
+
+	/* wait 20usec before checking status */
+	udelay(20);
+
+	/* poll for the mdi write to complete */
+	e100_retry = E100_CMD_WAIT;
+	while ((!((mdi_cntrl = readl(&bdp->scb->scb_mdi_cntrl)) & MDI_PHY_READY)) && (e100_retry)) {
+
+		udelay(20);
+		e100_retry--;
+	}
+	spin_unlock_bh(&bdp->mdi_access_lock);
+	if (mdi_cntrl & MDI_PHY_READY) 
+		return 0;
+	else {
+		printk(KERN_ERR "e100: MDI write timeout\n");
+		return 1;
+	}
+}
+
+/* 
+ * Procedure:	e100_mdi_read
+ *
+ * Description: This routine will read a value from the specified MII register
+ *		of an external MDI compliant device (e.g. PHY 100), and return
+ *		it to the calling routine.  The command will execute in polled
+ *		mode.
+ *
+ * Arguments:
+ *	bdp - Ptr to this card's e100_bdconfig structure
+ *	reg_addr - The MII register that we are reading from
+ *	phy_addr - The MDI address of the Phy component.
+ *
+ * Results:
+ *	data - The value that we read from the MII register.
+ *
+ * Returns:
+ *	NOTHING
+ */
+int
+e100_mdi_read(struct e100_private *bdp, u32 reg_addr, u32 phy_addr, u16 *data)
+{
+	int e100_retry;
+	u32 temp_val;
+	unsigned int mdi_cntrl;
+
+	spin_lock_bh(&bdp->mdi_access_lock);
+	/* Issue the read command to the MDI control register. */
+	temp_val = ((reg_addr << 16) | (phy_addr << 21) | (MDI_READ << 26));
+	writel(temp_val, &bdp->scb->scb_mdi_cntrl);
+	readw(&bdp->scb->scb_status);
+
+	/* wait 20usec before checking status */
+	udelay(20);
+
+	/* poll for the mdi read to complete */
+	e100_retry = E100_CMD_WAIT;
+	while ((!((mdi_cntrl = readl(&bdp->scb->scb_mdi_cntrl)) & MDI_PHY_READY)) && (e100_retry)) {
+
+		udelay(20);
+		e100_retry--;
+	}
+
+	spin_unlock_bh(&bdp->mdi_access_lock);
+	if (mdi_cntrl & MDI_PHY_READY) {
+		/* return the lower word */
+		*data = (u16) mdi_cntrl;
+		return 0;
+	}
+	else {
+		printk(KERN_ERR "e100: MDI read timeout\n");
+		return 1;
+	}
+}
+
+static unsigned char
+e100_phy_valid(struct e100_private *bdp, unsigned int phy_address)
+{
+	u16 ctrl_reg, stat_reg;
+
+	/* Read the MDI control register */
+	e100_mdi_read(bdp, MII_BMCR, phy_address, &ctrl_reg);
+
+	/* Read the status register twice, bacause of sticky bits */
+	e100_mdi_read(bdp, MII_BMSR, phy_address, &stat_reg);
+	e100_mdi_read(bdp, MII_BMSR, phy_address, &stat_reg);
+
+	if ((ctrl_reg == 0xffff) || ((stat_reg == 0) && (ctrl_reg == 0)))
+		return false;
+
+	return true;
+}
+
+static void
+e100_phy_address_detect(struct e100_private *bdp)
+{
+	unsigned int addr;
+	unsigned char valid_phy_found = false;
+
+	if (IS_NC3133(bdp)) {
+		bdp->phy_addr = 0;
+		return;
+	}
+
+	if (e100_phy_valid(bdp, PHY_DEFAULT_ADDRESS)) {
+		bdp->phy_addr = PHY_DEFAULT_ADDRESS;
+		valid_phy_found = true;
+
+	} else {
+		for (addr = MIN_PHY_ADDR; addr <= MAX_PHY_ADDR; addr++) {
+			if (e100_phy_valid(bdp, addr)) {
+				bdp->phy_addr = addr;
+				valid_phy_found = true;
+				break;
+			}
+		}
+	}
+
+	if (!valid_phy_found) {
+		bdp->phy_addr = PHY_ADDRESS_503;
+	}
+}
+
+static void
+e100_phy_id_detect(struct e100_private *bdp)
+{
+	u16 low_id_reg, high_id_reg;
+
+	if (bdp->phy_addr == PHY_ADDRESS_503) {
+		bdp->PhyId = PHY_503;
+		return;
+	}
+	if (!(bdp->flags & IS_ICH)) {
+		if (bdp->rev_id >= D102_REV_ID) {
+			bdp->PhyId = PHY_82562ET;
+			return;
+		}
+	}
+
+	/* Read phy id from the MII register */
+	e100_mdi_read(bdp, MII_PHYSID1, bdp->phy_addr, &low_id_reg);
+	e100_mdi_read(bdp, MII_PHYSID2, bdp->phy_addr, &high_id_reg);
+
+	bdp->PhyId = ((unsigned int) low_id_reg |
+		      ((unsigned int) high_id_reg << 16));
+}
+
+static void
+e100_phy_isolate(struct e100_private *bdp)
+{
+	unsigned int phy_address;
+	u16 ctrl_reg;
+
+	/* Go over all phy addresses. Deisolate the selected one, and isolate
+	 * all the rest */
+	for (phy_address = 0; phy_address <= MAX_PHY_ADDR; phy_address++) {
+		if (phy_address != bdp->phy_addr) {
+			e100_mdi_write(bdp, MII_BMCR, phy_address,
+				       BMCR_ISOLATE);
+
+		} else {
+			e100_mdi_read(bdp, MII_BMCR, bdp->phy_addr, &ctrl_reg);
+			ctrl_reg &= ~BMCR_ISOLATE;
+			e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr, ctrl_reg);
+		}
+
+		udelay(100);
+	}
+}
+
+static unsigned char
+e100_phy_specific_setup(struct e100_private *bdp)
+{
+	u16 misc_reg;
+
+	if (bdp->phy_addr == PHY_ADDRESS_503) {
+		switch (bdp->params.e100_speed_duplex) {
+		case E100_AUTONEG:
+			/* The adapter can't autoneg. so set to 10/HALF */
+			printk(KERN_INFO
+			       "e100: 503 serial component detected which "
+			       "cannot autonegotiate\n");
+			printk(KERN_INFO
+			       "e100: speed/duplex forced to "
+			       "10Mbps / Half duplex\n");
+			bdp->params.e100_speed_duplex = E100_SPEED_10_HALF;
+			break;
+
+		case E100_SPEED_100_HALF:
+		case E100_SPEED_100_FULL:
+			printk(KERN_ERR
+			       "e100: 503 serial component detected "
+			       "which does not support 100Mbps\n");
+			printk(KERN_ERR
+			       "e100: Change the forced speed/duplex "
+			       "to a supported setting\n");
+			return false;
+		}
+
+		return true;
+	}
+
+	if (IS_NC3133(bdp)) {
+		u16 int_reg;
+
+		/* enable 100BASE fiber interface */
+		e100_mdi_write(bdp, MDI_NC3133_CONFIG_REG, bdp->phy_addr,
+			       MDI_NC3133_100FX_ENABLE);
+
+		if ((bdp->params.e100_speed_duplex != E100_AUTONEG) &&
+		    (bdp->params.e100_speed_duplex != E100_SPEED_100_FULL)) {
+			/* just inform user about 100 full */
+			printk(KERN_ERR "e100: NC3133 NIC can only run "
+			       "at 100Mbps full duplex\n");
+		}
+
+		bdp->params.e100_speed_duplex = E100_SPEED_100_FULL;
+
+		/* enable interrupts */
+		e100_mdi_read(bdp, MDI_NC3133_INT_ENABLE_REG,
+			      bdp->phy_addr, &int_reg);
+		int_reg |= MDI_NC3133_INT_ENABLE;
+		e100_mdi_write(bdp, MDI_NC3133_INT_ENABLE_REG,
+			       bdp->phy_addr, int_reg);
+	}
+
+	/* Handle the National TX */
+	if ((bdp->PhyId & PHY_MODEL_REV_ID_MASK) == PHY_NSC_TX) {
+		e100_mdi_read(bdp, NSC_CONG_CONTROL_REG,
+			      bdp->phy_addr, &misc_reg);
+
+		misc_reg |= NSC_TX_CONG_TXREADY;
+
+		/* disable the congestion control bit in the National Phy */
+		misc_reg &= ~NSC_TX_CONG_ENABLE;
+
+		e100_mdi_write(bdp, NSC_CONG_CONTROL_REG,
+			       bdp->phy_addr, misc_reg);
+	}
+
+	return true;
+}
+
+/* 
+ * Procedure:	e100_phy_fix_squelch
+ *
+ * Description:
+ *	Help find link on certain rare scenarios.
+ *	NOTE: This routine must be called once per watchdog,
+ *	      and *after* setting the current link state.
+ *
+ * Arguments:
+ *	bdp - Ptr to this card's e100_bdconfig structure
+ *
+ * Returns:
+ *	NOTHING
+ */
+static void
+e100_phy_fix_squelch(struct e100_private *bdp)
+{
+	if ((bdp->PhyId != PHY_82555_TX) || (bdp->flags & DF_SPEED_FORCED))
+		return;
+
+	if (netif_carrier_ok(bdp->device)) {
+		switch (bdp->PhyState) {
+		case 0:
+			break;
+		case 1:
+			e100_mdi_write(bdp, PHY_82555_SPECIAL_CONTROL,
+				       bdp->phy_addr, 0x0000);
+			break;
+		case 2:
+			e100_mdi_write(bdp, PHY_82555_MDI_EQUALIZER_CSR,
+				       bdp->phy_addr, 0x3000);
+			break;
+		}
+		bdp->PhyState = 0;
+		bdp->PhyDelay = 0;
+
+	} else if (!bdp->PhyDelay--) {
+		switch (bdp->PhyState) {
+		case 0:
+			e100_mdi_write(bdp, PHY_82555_SPECIAL_CONTROL,
+				       bdp->phy_addr, EXTENDED_SQUELCH_BIT);
+			bdp->PhyState = 1;
+			break;
+		case 1:
+			e100_mdi_write(bdp, PHY_82555_SPECIAL_CONTROL,
+				       bdp->phy_addr, 0x0000);
+			e100_mdi_write(bdp, PHY_82555_MDI_EQUALIZER_CSR,
+				       bdp->phy_addr, 0x2010);
+			bdp->PhyState = 2;
+			break;
+		case 2:
+			e100_mdi_write(bdp, PHY_82555_MDI_EQUALIZER_CSR,
+				       bdp->phy_addr, 0x3000);
+			bdp->PhyState = 0;
+			break;
+		}
+
+		e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr,
+			       BMCR_ANENABLE | BMCR_ANRESTART);
+		bdp->PhyDelay = 3;
+	}
+}
+
+/* 
+ * Procedure:	e100_fix_polarity
+ *
+ * Description:
+ *	Fix for 82555 auto-polarity toggle problem. With a short cable 
+ *	connecting an 82555 with an 840A link partner, if the medium is noisy,
+ *	the 82555 sometime thinks that the polarity might be wrong and so 
+ *	toggles polarity. This happens repeatedly and results in a high bit 
+ *	error rate.
+ *	NOTE: This happens only at 10 Mbps
+ *
+ * Arguments:
+ *	bdp - Ptr to this card's e100_bdconfig structure
+ *
+ * Returns:
+ *	NOTHING
+ */
+static void
+e100_fix_polarity(struct e100_private *bdp)
+{
+	u16 status;
+	u16 errors;
+	u16 misc_reg;
+	int speed;
+
+	if ((bdp->PhyId != PHY_82555_TX) && (bdp->PhyId != PHY_82562ET) &&
+	    (bdp->PhyId != PHY_82562EM))
+		return;
+
+	/* If the user wants auto-polarity disabled, do only that and nothing *
+	 * else. * e100_autopolarity == 0 means disable --- we do just the
+	 * disabling * e100_autopolarity == 1 means enable  --- we do nothing at
+	 * all * e100_autopolarity >= 2 means we do the workaround code. */
+	/* Change for 82558 enhancement */
+	switch (E100_AUTOPOLARITY) {
+	case 0:
+		e100_mdi_read(bdp, PHY_82555_SPECIAL_CONTROL,
+			      bdp->phy_addr, &misc_reg);
+		e100_mdi_write(bdp, PHY_82555_SPECIAL_CONTROL, bdp->phy_addr,
+			       (u16) (misc_reg | DISABLE_AUTO_POLARITY));
+		break;
+
+	case 1:
+		e100_mdi_read(bdp, PHY_82555_SPECIAL_CONTROL,
+			      bdp->phy_addr, &misc_reg);
+		e100_mdi_write(bdp, PHY_82555_SPECIAL_CONTROL, bdp->phy_addr,
+			       (u16) (misc_reg & ~DISABLE_AUTO_POLARITY));
+		break;
+
+	case 2:
+		/* we do this only if link is up */
+		if (!netif_carrier_ok(bdp->device)) {
+			break;
+		}
+
+		e100_mdi_read(bdp, PHY_82555_CSR, bdp->phy_addr, &status);
+		speed = (status & PHY_82555_SPEED_BIT) ? 100 : 10;
+
+		/* we need to do this only if speed is 10 */
+		if (speed != 10) {
+			break;
+		}
+
+		/* see if we have any end of frame errors */
+		e100_mdi_read(bdp, PHY_82555_EOF_COUNTER,
+			      bdp->phy_addr, &errors);
+
+		/* if non-zero, wait for 100 ms before reading again */
+		if (errors) {
+			udelay(200);
+			e100_mdi_read(bdp, PHY_82555_EOF_COUNTER,
+				      bdp->phy_addr, &errors);
+
+			/* if non-zero again, we disable polarity */
+			if (errors) {
+				e100_mdi_read(bdp, PHY_82555_SPECIAL_CONTROL,
+					      bdp->phy_addr, &misc_reg);
+				e100_mdi_write(bdp, PHY_82555_SPECIAL_CONTROL,
+					       bdp->phy_addr,
+					       (u16) (misc_reg |
+						      DISABLE_AUTO_POLARITY));
+			}
+		}
+
+		if (!errors) {
+			/* it is safe to read the polarity now */
+			e100_mdi_read(bdp, PHY_82555_CSR,
+				      bdp->phy_addr, &status);
+
+			/* if polarity is normal, disable polarity */
+			if (!(status & PHY_82555_POLARITY_BIT)) {
+				e100_mdi_read(bdp, PHY_82555_SPECIAL_CONTROL,
+					      bdp->phy_addr, &misc_reg);
+				e100_mdi_write(bdp, PHY_82555_SPECIAL_CONTROL,
+					       bdp->phy_addr,
+					       (u16) (misc_reg |
+						      DISABLE_AUTO_POLARITY));
+			}
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+/* 
+ * Procedure:	e100_find_speed_duplex
+ *
+ * Description: This routine will figure out what line speed and duplex mode
+ *		the PHY is currently using.
+ *
+ * Arguments:
+ *	bdp - Ptr to this card's e100_bdconfig structure
+ *
+ * Returns:
+ *	NOTHING
+ */
+static void
+e100_find_speed_duplex(struct e100_private *bdp)
+{
+	unsigned int PhyId;
+	u16 stat_reg, misc_reg;
+	u16 ad_reg, lp_ad_reg;
+
+	PhyId = bdp->PhyId & PHY_MODEL_REV_ID_MASK;
+
+	/* First we should check to see if we have link */
+	/* If we don't have a link no reason to print a speed and duplex */
+	if (!e100_update_link_state(bdp)) {
+		bdp->cur_line_speed = 0;
+		bdp->cur_dplx_mode = 0;
+		return;
+	}
+
+	/* On the 82559 and later controllers, speed/duplex is part of the *
+	 * SCB. So, we save an mdi_read and get these from the SCB. * */
+	if (bdp->rev_id >= D101MA_REV_ID) {
+		/* Read speed */
+		if (readb(&bdp->scb->scb_ext.d101m_scb.scb_gen_stat) & BIT_1)
+			bdp->cur_line_speed = 100;
+		else
+			bdp->cur_line_speed = 10;
+
+		/* Read duplex */
+		if (readb(&bdp->scb->scb_ext.d101m_scb.scb_gen_stat) & BIT_2)
+			bdp->cur_dplx_mode = FULL_DUPLEX;
+		else
+			bdp->cur_dplx_mode = HALF_DUPLEX;
+
+		return;
+	}
+
+	/* If this is a Phy 100, then read bits 1 and 0 of extended register 0,
+	 * to get the current speed and duplex settings. */
+	if ((PhyId == PHY_100_A) || (PhyId == PHY_100_C) ||
+	    (PhyId == PHY_82555_TX)) {
+
+		/* Read Phy 100 extended register 0 */
+		e100_mdi_read(bdp, EXTENDED_REG_0, bdp->phy_addr, &misc_reg);
+
+		/* Get current speed setting */
+		if (misc_reg & PHY_100_ER0_SPEED_INDIC)
+			bdp->cur_line_speed = 100;
+		else
+			bdp->cur_line_speed = 10;
+
+		/* Get current duplex setting -- FDX enabled if bit is set */
+		if (misc_reg & PHY_100_ER0_FDX_INDIC)
+			bdp->cur_dplx_mode = FULL_DUPLEX;
+		else
+			bdp->cur_dplx_mode = HALF_DUPLEX;
+
+		return;
+	}
+
+	/* See if link partner is capable of Auto-Negotiation (bit 0, reg 6) */
+	e100_mdi_read(bdp, MII_EXPANSION, bdp->phy_addr, &misc_reg);
+
+	/* See if Auto-Negotiation was complete (bit 5, reg 1) */
+	e100_mdi_read(bdp, MII_BMSR, bdp->phy_addr, &stat_reg);
+
+	/* If a True NWAY connection was made, then we can detect speed/dplx
+	 * by ANDing our adapter's advertised abilities with our link partner's
+	 * advertised ablilities, and then assuming that the highest common
+	 * denominator was chosed by NWAY. */
+	if ((misc_reg & EXPANSION_NWAY) && (stat_reg & BMSR_ANEGCOMPLETE)) {
+
+		/* Read our advertisement register */
+		e100_mdi_read(bdp, MII_ADVERTISE, bdp->phy_addr, &ad_reg);
+
+		/* Read our link partner's advertisement register */
+		e100_mdi_read(bdp, MII_LPA, bdp->phy_addr, &lp_ad_reg);
+
+		/* AND the two advertisement registers together, and get rid
+		 * of any extraneous bits. */
+		ad_reg &= (lp_ad_reg & NWAY_LP_ABILITY);
+
+		/* Get speed setting */
+		if (ad_reg &
+		    (ADVERTISE_100HALF | ADVERTISE_100FULL |
+		     ADVERTISE_100BASE4))
+
+			bdp->cur_line_speed = 100;
+		else
+			bdp->cur_line_speed = 10;
+
+		/* Get duplex setting -- use priority resolution algorithm */
+		if (ad_reg & ADVERTISE_100BASE4) {
+			bdp->cur_dplx_mode = HALF_DUPLEX;
+		} else if (ad_reg & ADVERTISE_100FULL) {
+			bdp->cur_dplx_mode = FULL_DUPLEX;
+		} else if (ad_reg & ADVERTISE_100HALF) {
+			bdp->cur_dplx_mode = HALF_DUPLEX;
+		} else if (ad_reg & ADVERTISE_10FULL) {
+			bdp->cur_dplx_mode = FULL_DUPLEX;
+		} else {
+			bdp->cur_dplx_mode = HALF_DUPLEX;
+		}
+
+		return;
+	}
+
+	/* If we are connected to a dumb (non-NWAY) repeater or hub, and the
+	 * line speed was determined automatically by parallel detection, then
+	 * we have no way of knowing exactly what speed the PHY is set to
+	 * unless that PHY has a propietary register which indicates speed in
+	 * this situation. The NSC TX PHY does have such a register. Also,
+	 * since NWAY didn't establish the connection, the duplex setting
+	 * should HALF duplex. */
+	bdp->cur_dplx_mode = HALF_DUPLEX;
+
+	if (PhyId == PHY_NSC_TX) {
+		/* Read register 25 to get the SPEED_10 bit */
+		e100_mdi_read(bdp, NSC_SPEED_IND_REG, bdp->phy_addr, &misc_reg);
+
+		/* If bit 6 was set then we're at 10Mbps */
+		if (misc_reg & NSC_TX_SPD_INDC_SPEED)
+			bdp->cur_line_speed = 10;
+		else
+			bdp->cur_line_speed = 100;
+
+	} else {
+		/* If we don't know the line speed, default to 10Mbps */
+		bdp->cur_line_speed = 10;
+	}
+}
+
+/* 
+ * Procedure: e100_force_speed_duplex
+ *
+ * Description: This routine forces line speed and duplex mode of the
+ * adapter based on the values the user has set in e100.c.
+ *
+ * Arguments:  bdp - Pointer to the e100_private structure for the board
+ *
+ * Returns: void
+ *
+ */
+void
+e100_force_speed_duplex(struct e100_private *bdp)
+{
+	u16 control;
+	unsigned long expires;
+
+	bdp->flags |= DF_SPEED_FORCED;
+
+	e100_mdi_read(bdp, MII_BMCR, bdp->phy_addr, &control);
+	control &= ~BMCR_ANENABLE;
+	control &= ~BMCR_LOOPBACK;
+
+	switch (bdp->params.e100_speed_duplex) {
+	case E100_SPEED_10_HALF:
+		control &= ~BMCR_SPEED100;
+		control &= ~BMCR_FULLDPLX;
+		bdp->cur_line_speed = 10;
+		bdp->cur_dplx_mode = HALF_DUPLEX;
+		break;
+
+	case E100_SPEED_10_FULL:
+		control &= ~BMCR_SPEED100;
+		control |= BMCR_FULLDPLX;
+		bdp->cur_line_speed = 10;
+		bdp->cur_dplx_mode = FULL_DUPLEX;
+		break;
+
+	case E100_SPEED_100_HALF:
+		control |= BMCR_SPEED100;
+		control &= ~BMCR_FULLDPLX;
+		bdp->cur_line_speed = 100;
+		bdp->cur_dplx_mode = HALF_DUPLEX;
+		break;
+
+	case E100_SPEED_100_FULL:
+		control |= BMCR_SPEED100;
+		control |= BMCR_FULLDPLX;
+		bdp->cur_line_speed = 100;
+		bdp->cur_dplx_mode = FULL_DUPLEX;
+		break;
+	}
+
+	e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr, control);
+
+	/* loop must run at least once */
+	expires = jiffies + 2 * HZ;
+	do {
+		if (e100_update_link_state(bdp) || 
+		    time_after(jiffies, expires)) {
+			break;
+		} else {
+			yield();
+		}
+
+	} while (true);
+}
+
+void
+e100_force_speed_duplex_to_phy(struct e100_private *bdp)
+{
+	u16 control;
+
+	e100_mdi_read(bdp, MII_BMCR, bdp->phy_addr, &control);
+	control &= ~BMCR_ANENABLE;
+	control &= ~BMCR_LOOPBACK;
+
+	switch (bdp->params.e100_speed_duplex) {
+	case E100_SPEED_10_HALF:
+		control &= ~BMCR_SPEED100;
+		control &= ~BMCR_FULLDPLX;
+		break;
+
+	case E100_SPEED_10_FULL:
+		control &= ~BMCR_SPEED100;
+		control |= BMCR_FULLDPLX;
+		break;
+
+	case E100_SPEED_100_HALF:
+		control |= BMCR_SPEED100;
+		control &= ~BMCR_FULLDPLX;
+		break;
+
+	case E100_SPEED_100_FULL:
+		control |= BMCR_SPEED100;
+		control |= BMCR_FULLDPLX;
+		break;
+	}
+
+	/* Send speed/duplex command to PHY layer. */
+	e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr, control);
+}
+
+/* 
+ * Procedure: e100_set_fc
+ *
+ * Description: Checks the link's capability for flow control.
+ * 
+ * Arguments:  bdp - Pointer to the e100_private structure for the board
+ *		    
+ * Returns: void
+ *
+ */
+static void
+e100_set_fc(struct e100_private *bdp)
+{
+	u16 ad_reg;
+	u16 lp_ad_reg;
+	u16 exp_reg;
+
+	/* no flow control for 82557, forced links or half duplex */
+	if (!netif_carrier_ok(bdp->device) || (bdp->flags & DF_SPEED_FORCED) ||
+	    (bdp->cur_dplx_mode == HALF_DUPLEX) ||
+	    !(bdp->flags & IS_BACHELOR)) {
+
+		bdp->flags &= ~DF_LINK_FC_CAP;
+		return;
+	}
+
+	/* See if link partner is capable of Auto-Negotiation (bit 0, reg 6) */
+	e100_mdi_read(bdp, MII_EXPANSION, bdp->phy_addr, &exp_reg);
+
+	if (exp_reg & EXPANSION_NWAY) {
+		/* Read our advertisement register */
+		e100_mdi_read(bdp, MII_ADVERTISE, bdp->phy_addr, &ad_reg);
+
+		/* Read our link partner's advertisement register */
+		e100_mdi_read(bdp, MII_LPA, bdp->phy_addr, &lp_ad_reg);
+
+		ad_reg &= lp_ad_reg;	/* AND the 2 ad registers */
+
+		if (ad_reg & NWAY_AD_FC_SUPPORTED)
+			bdp->flags |= DF_LINK_FC_CAP;
+		else
+			/* If link partner is capable of autoneg, but  */
+			/* not capable of flow control, Received PAUSE */
+			/* frames are still honored, i.e.,             */
+		        /* transmitted frames would be paused */
+			/* by incoming PAUSE frames           */
+			bdp->flags |= DF_LINK_FC_TX_ONLY;
+
+	} else {
+		bdp->flags &= ~DF_LINK_FC_CAP;
+	}
+}
+
+/* 
+ * Procedure: e100_phy_check
+ * 
+ * Arguments:  bdp - Pointer to the e100_private structure for the board
+ *
+ * Returns: true if link state was changed
+ *	   false otherwise
+ *
+ */
+unsigned char
+e100_phy_check(struct e100_private *bdp)
+{
+	unsigned char old_link;
+	unsigned char changed = false;
+
+	old_link = netif_carrier_ok(bdp->device) ? 1 : 0;
+	e100_find_speed_duplex(bdp);
+
+	if (!old_link && netif_carrier_ok(bdp->device)) {
+		e100_set_fc(bdp);
+		changed = true;
+	}
+
+	if (old_link && !netif_carrier_ok(bdp->device)) {
+		/* reset the zero lock state */
+		bdp->zlock_state = ZLOCK_INITIAL;
+
+		// set auto lock for phy auto-negotiation on link up
+		if ((bdp->PhyId & PHY_MODEL_REV_ID_MASK) == PHY_82555_TX)
+			e100_mdi_write(bdp, PHY_82555_MDI_EQUALIZER_CSR,
+				       bdp->phy_addr, 0);
+		changed = true;
+	}
+
+	e100_phy_fix_squelch(bdp);
+	e100_handle_zlock(bdp);
+
+	return changed;
+}
+
+/* 
+ * Procedure:	e100_auto_neg
+ *
+ * Description: This routine will start autonegotiation and wait
+ *		     for it to complete
+ *
+ * Arguments:
+ *	bdp		- pointer to this card's e100_bdconfig structure
+ *	force_restart	- defines if autoneg should be restarted even if it
+ *			has been completed before
+ * Returns:
+ *	NOTHING
+ */
+static void
+e100_auto_neg(struct e100_private *bdp, unsigned char force_restart)
+{
+	u16 stat_reg;
+	unsigned long expires;
+
+	bdp->flags &= ~DF_SPEED_FORCED;
+
+	e100_mdi_read(bdp, MII_BMSR, bdp->phy_addr, &stat_reg);
+	e100_mdi_read(bdp, MII_BMSR, bdp->phy_addr, &stat_reg);
+
+	/* if we are capable of performing autoneg then we restart if needed */
+	if ((stat_reg != 0xFFFF) && (stat_reg & BMSR_ANEGCAPABLE)) {
+
+		if ((!force_restart) &&
+		    (stat_reg & BMSR_ANEGCOMPLETE)) {
+			goto exit;
+		}
+
+		e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr,
+			       BMCR_ANENABLE | BMCR_ANRESTART);
+
+		/* wait for autoneg to complete (up to 3 seconds) */
+		expires = jiffies + HZ * 3;
+		do {
+			/* now re-read the value. Sticky so read twice */
+			e100_mdi_read(bdp, MII_BMSR, bdp->phy_addr, &stat_reg);
+			e100_mdi_read(bdp, MII_BMSR, bdp->phy_addr, &stat_reg);
+
+			if ((stat_reg & BMSR_ANEGCOMPLETE) ||
+			    time_after(jiffies, expires) ) {
+				goto exit;
+			} else {
+				yield();
+			}
+		} while (true);
+	}
+
+exit:
+	e100_find_speed_duplex(bdp);
+}
+
+void
+e100_phy_set_speed_duplex(struct e100_private *bdp, unsigned char force_restart)
+{
+	if (bdp->params.e100_speed_duplex == E100_AUTONEG) {
+        	if (bdp->rev_id >= D102_REV_ID) 
+			/* Enable MDI/MDI-X auto switching */
+                	e100_mdi_write(bdp, MII_NCONFIG, bdp->phy_addr,
+		                       MDI_MDIX_AUTO_SWITCH_ENABLE);
+		e100_auto_neg(bdp, force_restart);
+
+	} else {
+        	if (bdp->rev_id >= D102_REV_ID) 
+			/* Disable MDI/MDI-X auto switching */
+                	e100_mdi_write(bdp, MII_NCONFIG, bdp->phy_addr,
+		                       MDI_MDIX_RESET_ALL_MASK);
+		e100_force_speed_duplex(bdp);
+	}
+
+	e100_set_fc(bdp);
+}
+
+void
+e100_phy_autoneg(struct e100_private *bdp)
+{
+	u16 ctrl_reg;
+
+	ctrl_reg = BMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET;
+
+	e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr, ctrl_reg);
+
+	udelay(100);
+}
+
+void
+e100_phy_set_loopback(struct e100_private *bdp)
+{
+	u16 ctrl_reg;
+	ctrl_reg = BMCR_LOOPBACK;
+	e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr, ctrl_reg);
+		udelay(100);
+}
+	
+void
+e100_phy_reset(struct e100_private *bdp)
+{
+	u16 ctrl_reg;
+	ctrl_reg = BMCR_RESET;
+	e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr, ctrl_reg);
+	/* ieee 802.3 : The reset process shall be completed       */
+	/* within 0.5 seconds from the settting of PHY reset bit.  */
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ / 2);
+}
+
+unsigned char
+e100_phy_init(struct e100_private *bdp)
+{
+	e100_phy_reset(bdp);
+	e100_phy_address_detect(bdp);
+	e100_phy_isolate(bdp);
+	e100_phy_id_detect(bdp);
+
+	if (!e100_phy_specific_setup(bdp))
+		return false;
+
+	bdp->PhyState = 0;
+	bdp->PhyDelay = 0;
+	bdp->zlock_state = ZLOCK_INITIAL;
+
+	e100_phy_set_speed_duplex(bdp, false);
+	e100_fix_polarity(bdp);
+
+	return true;
+}
+
+/* 
+ * Procedure: e100_get_link_state
+ * 
+ * Description: This routine checks the link status of the adapter
+ *
+ * Arguments:  bdp - Pointer to the e100_private structure for the board
+ *		    
+ *
+ * Returns: true - If a link is found
+ *		false - If there is no link
+ *
+ */
+unsigned char
+e100_get_link_state(struct e100_private *bdp)
+{
+	unsigned char link = false;
+	u16 status;
+
+	/* Check link status */
+	/* If the controller is a 82559 or later one, link status is available
+	 * from the CSR. This avoids the mdi_read. */
+	if (bdp->rev_id >= D101MA_REV_ID) {
+		if (readb(&bdp->scb->scb_ext.d101m_scb.scb_gen_stat) & BIT_0) {
+			link = true;
+		} else {
+			link = false;
+		}
+
+	} else {
+		/* Read the status register twice because of sticky bits */
+		e100_mdi_read(bdp, MII_BMSR, bdp->phy_addr, &status);
+		e100_mdi_read(bdp, MII_BMSR, bdp->phy_addr, &status);
+
+		if (status & BMSR_LSTATUS) {
+			link = true;
+		} else {
+			link = false;
+		}
+	}
+
+	return link;
+}
+
+/* 
+ * Procedure: e100_update_link_state
+ * 
+ * Description: This routine updates the link status of the adapter,
+ * 		also considering netif_running
+ *
+ * Arguments:  bdp - Pointer to the e100_private structure for the board
+ *		    
+ *
+ * Returns: true - If a link is found
+ *		false - If there is no link
+ *
+ */
+unsigned char
+e100_update_link_state(struct e100_private *bdp)
+{
+	unsigned char link;
+
+	/* Logical AND PHY link & netif_running */
+	link = e100_get_link_state(bdp) && netif_running(bdp->device);
+
+	if (link) {
+		if (!netif_carrier_ok(bdp->device))
+			netif_carrier_on(bdp->device);
+	} else {
+		if (netif_carrier_ok(bdp->device))
+			netif_carrier_off(bdp->device);
+	}
+
+	return link;
+}
+
+/**************************************************************************\
+ **
+ ** PROC NAME:     e100_handle_zlock
+ **    This function manages a state machine that controls
+ **    the driver's zero locking algorithm.
+ **    This function is called by e100_watchdog() every ~2 second.
+ ** States:
+ **    The current link handling state is stored in 
+ **    bdp->zlock_state, and is one of:
+ **    ZLOCK_INITIAL, ZLOCK_READING, ZLOCK_SLEEPING
+ **    Detailed description of the states and the transitions
+ **    between states is found below.
+ **    Note that any time the link is down / there is a reset
+ **    state will be changed outside this function to ZLOCK_INITIAL
+ ** Algorithm:
+ **    1. If link is up & 100 Mbps continue else stay in #1:
+ **    2. Set 'auto lock'
+ **    3. Read & Store 100 times 'Zero' locked in 1 sec interval
+ **    4. If max zero read >= 0xB continue else goto 1
+ **    5. Set most popular 'Zero' read in #3
+ **    6. Sleep 5 minutes
+ **    7. Read number of errors, if it is > 300 goto 2 else goto 6
+ ** Data Structures (in DRIVER_DATA):
+ **    zlock_state           - current state of the algorithm
+ **    zlock_read_cnt        - counts number of reads (up to 100)
+ **    zlock_read_data[i]    - counts number of times 'Zero' read was i, 0 <= i <= 15
+ **    zlock_sleep_cnt       - keeps track of "sleep" time (up to 300 secs = 5 minutes)
+ **                                
+ ** Parameters:    DRIVER_DATA    *bdp
+ **
+ **                bdp  - Pointer to HSM's adapter data space
+ **
+ ** Return Value:  NONE
+ **
+ ** See Also:      e100_watchdog()
+ **
+ \**************************************************************************/
+void
+e100_handle_zlock(struct e100_private *bdp)
+{
+	u16 pos;
+	u16 eq_reg;
+	u16 err_cnt;
+	u8 mpz;			/* Most Popular Zero */
+
+	switch (bdp->zlock_state) {
+	case ZLOCK_INITIAL:
+
+		if (((u8) bdp->rev_id <= D102_REV_ID) ||
+		    !(bdp->cur_line_speed == 100) ||
+		    !netif_carrier_ok(bdp->device)) {
+			break;
+		}
+
+		/* initialize hw and sw and start reading */
+		e100_mdi_write(bdp, PHY_82555_MDI_EQUALIZER_CSR,
+			       bdp->phy_addr, 0);
+		/* reset read counters: */
+		bdp->zlock_read_cnt = 0;
+		for (pos = 0; pos < 16; pos++)
+			bdp->zlock_read_data[pos] = 0;
+		/* start reading in the next call back: */
+		bdp->zlock_state = ZLOCK_READING;
+
+		/* FALL THROUGH !! */
+
+	case ZLOCK_READING:
+		/* state: reading (100 times) zero locked in 1 sec interval
+		 * prev states: ZLOCK_INITIAL
+		 * next states: ZLOCK_INITIAL, ZLOCK_SLEEPING */
+
+		e100_mdi_read(bdp, PHY_82555_MDI_EQUALIZER_CSR,
+			      bdp->phy_addr, &eq_reg);
+		pos = (eq_reg & ZLOCK_ZERO_MASK) >> 4;
+		bdp->zlock_read_data[pos]++;
+		bdp->zlock_read_cnt++;
+
+		if (bdp->zlock_read_cnt == ZLOCK_MAX_READS) {
+			/* check if we read a 'Zero' value of 0xB or greater */
+			if ((bdp->zlock_read_data[0xB]) ||
+			    (bdp->zlock_read_data[0xC]) ||
+			    (bdp->zlock_read_data[0xD]) ||
+			    (bdp->zlock_read_data[0xE]) ||
+			    (bdp->zlock_read_data[0xF])) {
+
+				/* we've read 'Zero' value of 0xB or greater,
+				 * find most popular 'Zero' value and lock it */
+				mpz = 0;
+				/* this loop finds the most popular 'Zero': */
+				for (pos = 1; pos < 16; pos++) {
+					if (bdp->zlock_read_data[pos] >
+					    bdp->zlock_read_data[mpz])
+
+						mpz = pos;
+				}
+				/* now lock the most popular 'Zero': */
+				eq_reg = (ZLOCK_SET_ZERO | mpz);
+				e100_mdi_write(bdp,
+					       PHY_82555_MDI_EQUALIZER_CSR,
+					       bdp->phy_addr, eq_reg);
+
+				/* sleep for 5 minutes: */
+				bdp->zlock_sleep_cnt = jiffies;
+				bdp->zlock_state = ZLOCK_SLEEPING;
+				/* we will be reading the # of errors after 5
+				 * minutes, so we need to reset the error
+				 * counters - these registers are self clearing
+				 * on read, so read them */
+				e100_mdi_read(bdp, PHY_82555_SYMBOL_ERR,
+					      bdp->phy_addr, &err_cnt);
+
+			} else {
+				/* we did not read a 'Zero' value of 0xB or
+				 * above. go back to the start */
+				bdp->zlock_state = ZLOCK_INITIAL;
+			}
+
+		}
+		break;
+
+	case ZLOCK_SLEEPING:
+		/* state: sleeping for 5 minutes
+		 * prev states: ZLOCK_READING
+		 * next states: ZLOCK_READING, ZLOCK_SLEEPING */
+
+		/* if 5 minutes have passed: */
+		if ((jiffies - bdp->zlock_sleep_cnt) >= ZLOCK_MAX_SLEEP) {
+			/* read and sum up the number of errors:  */
+			e100_mdi_read(bdp, PHY_82555_SYMBOL_ERR,
+				      bdp->phy_addr, &err_cnt);
+			/* if we've more than 300 errors (this number was
+			 * calculated according to the spec max allowed errors
+			 * (80 errors per 1 million frames) for 5 minutes in
+			 * 100 Mbps (or the user specified max BER number) */
+			if (err_cnt > bdp->params.ber) {
+				/* start again in the next callback: */
+				bdp->zlock_state = ZLOCK_INITIAL;
+			} else {
+				/* we don't have more errors than allowed,
+				 * sleep for 5 minutes */
+				bdp->zlock_sleep_cnt = jiffies;
+			}
+		}
+		break;
+
+	default:
+		break;
+	}
+}
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_phy.h linux-2.6.5.SUSE/drivers/net/e100-intel/e100_phy.h
--- linux-2.6.5/drivers/net/e100-intel/e100_phy.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_phy.h	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,158 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+#ifndef _E100_PHY_INC_
+#define _E100_PHY_INC_
+
+#include "e100.h"
+
+/*
+ * Auto-polarity enable/disable
+ * e100_autopolarity = 0 => disable auto-polarity
+ * e100_autopolarity = 1 => enable auto-polarity
+ * e100_autopolarity = 2 => let software determine
+ */
+#define E100_AUTOPOLARITY 2
+
+#define IS_NC3133(bdp) (((bdp)->pdev->subsystem_vendor == 0x0E11) && \
+                        ((bdp)->pdev->subsystem_device == 0xB0E1))
+
+#define PHY_503                 0
+#define PHY_100_A               0x000003E0
+#define PHY_100_C               0x035002A8
+#define PHY_NSC_TX              0x5c002000
+#define PHY_82562ET             0x033002A8
+#define PHY_82562EM             0x032002A8
+#define PHY_82562EH             0x017002A8
+#define PHY_82555_TX            0x015002a8	/* added this for 82555 */
+#define PHY_OTHER               0xFFFF
+#define MAX_PHY_ADDR            31
+#define MIN_PHY_ADDR            0
+
+#define PHY_MODEL_REV_ID_MASK   0xFFF0FFFF
+
+#define PHY_DEFAULT_ADDRESS 1
+#define PHY_ADDRESS_503 32
+
+/* MDI Control register bit definitions */
+#define MDI_PHY_READY	    BIT_28	/* PHY is ready for next MDI cycle */
+
+#define MDI_NC3133_CONFIG_REG           0x19
+#define MDI_NC3133_100FX_ENABLE         BIT_2
+#define MDI_NC3133_INT_ENABLE_REG       0x17
+#define MDI_NC3133_INT_ENABLE           BIT_1
+
+/* MDI Control register opcode definitions */
+#define MDI_WRITE 1		/* Phy Write */
+#define MDI_READ  2		/* Phy read */
+
+/* MDI register set*/
+#define AUTO_NEG_NEXT_PAGE_REG	    0x07	/* Auto-negotiation next page xmit */
+#define EXTENDED_REG_0		    0x10	/* Extended reg 0 (Phy 100 modes) */
+#define EXTENDED_REG_1		    0x14	/* Extended reg 1 (Phy 100 error indications) */
+#define NSC_CONG_CONTROL_REG	    0x17	/* National (TX) congestion control */
+#define NSC_SPEED_IND_REG	    0x19	/* National (TX) speed indication */
+
+#define HWI_CONTROL_REG             0x1D	/* HWI Control register */
+/* MDI/MDI-X Control Register bit definitions */
+#define MDI_MDIX_RES_TIMER          BIT_0_3	/* minimum slot time for resolution timer */
+#define MDI_MDIX_CONFIG_IS_OK       BIT_4	/* 1 = resolution algorithm completes OK */
+#define MDI_MDIX_STATUS             BIT_5	/* 1 = MDIX (croos over), 0 = MDI (straight through) */
+#define MDI_MDIX_SWITCH             BIT_6	/* 1 = Forces to MDIX, 0 = Forces to MDI */
+#define MDI_MDIX_AUTO_SWITCH_ENABLE BIT_7	/* 1 = MDI/MDI-X feature enabled */
+#define MDI_MDIX_CONCT_CONFIG       BIT_8	/* Sets the MDI/MDI-X connectivity configuration (test prupose only) */
+#define MDI_MDIX_CONCT_TEST_ENABLE  BIT_9	/* 1 = Enables connectivity testing */
+#define MDI_MDIX_RESET_ALL_MASK     0x0000
+
+/* HWI Control Register bit definitions */
+#define HWI_TEST_DISTANCE           BIT_0_8	/* distance to cable problem */
+#define HWI_TEST_HIGHZ_PROBLEM      BIT_9	/* 1 = Open Circuit */
+#define HWI_TEST_LOWZ_PROBLEM       BIT_10	/* 1 = Short Circuit */
+#define HWI_TEST_RESERVED           (BIT_11 | BIT_12)	/* reserved */
+#define HWI_TEST_EXECUTE            BIT_13	/* 1 = Execute the HWI test on the PHY */
+#define HWI_TEST_ABILITY            BIT_14	/* 1 = test passed */
+#define HWI_TEST_ENABLE             BIT_15	/* 1 = Enables the HWI feature */
+#define HWI_RESET_ALL_MASK          0x0000
+
+/* ############Start of 82555 specific defines################## */
+
+/* Intel 82555 specific registers */
+#define PHY_82555_CSR		    0x10	/* 82555 CSR */
+#define PHY_82555_SPECIAL_CONTROL   0x11	/* 82555 special control register */
+
+#define PHY_82555_RCV_ERR	    0x15	/* 82555 100BaseTx Receive Error
+						 * Frame Counter */
+#define PHY_82555_SYMBOL_ERR	    0x16	/* 82555 RCV Symbol Error Counter */
+#define PHY_82555_PREM_EOF_ERR	    0x17	/* 82555 100BaseTx RCV Premature End
+						 * of Frame Error Counter */
+#define PHY_82555_EOF_COUNTER	    0x18	/* 82555 end of frame error counter */
+#define PHY_82555_MDI_EQUALIZER_CSR 0x1a	/* 82555 specific equalizer reg. */
+
+/* 82555 CSR bits */
+#define PHY_82555_SPEED_BIT    BIT_1
+#define PHY_82555_POLARITY_BIT BIT_8
+
+/* 82555 equalizer reg. opcodes */
+#define ENABLE_ZERO_FORCING  0x2010	/* write to ASD conf. reg. 0 */
+#define DISABLE_ZERO_FORCING 0x2000	/* write to ASD conf. reg. 0 */
+
+/* 82555 special control reg. opcodes */
+#define DISABLE_AUTO_POLARITY 0x0010
+#define EXTENDED_SQUELCH_BIT  BIT_2
+
+/* ############End of 82555 specific defines##################### */
+
+/* Auto-Negotiation advertisement register bit definitions*/
+#define NWAY_AD_FC_SUPPORTED    0x0400	/* Flow Control supported */
+
+/* Auto-Negotiation link partner ability register bit definitions*/
+#define NWAY_LP_ABILITY	        0x07e0	/* technologies supported */
+
+/* PHY 100 Extended Register 0 bit definitions*/
+#define PHY_100_ER0_FDX_INDIC	BIT_0	/* 1 = FDX, 0 = half duplex */
+#define PHY_100_ER0_SPEED_INDIC BIT_1	/* 1 = 100Mbps, 0= 10Mbps */
+
+/* National Semiconductor TX phy congestion control register bit definitions*/
+#define NSC_TX_CONG_TXREADY  BIT_10	/* Makes TxReady an input */
+#define NSC_TX_CONG_ENABLE   BIT_8	/* Enables congestion control */
+
+/* National Semiconductor TX phy speed indication register bit definitions*/
+#define NSC_TX_SPD_INDC_SPEED BIT_6	/* 0 = 100Mbps, 1=10Mbps */
+
+/************* function prototypes ************/
+extern unsigned char e100_phy_init(struct e100_private *bdp);
+extern unsigned char e100_update_link_state(struct e100_private *bdp);
+extern unsigned char e100_phy_check(struct e100_private *bdp);
+extern void e100_phy_set_speed_duplex(struct e100_private *bdp,
+				      unsigned char force_restart);
+extern void e100_phy_autoneg(struct e100_private *bdp);
+extern void e100_phy_reset(struct e100_private *bdp);
+extern void e100_phy_set_loopback(struct e100_private *bdp);
+extern int e100_mdi_write(struct e100_private *, u32, u32, u16);
+extern int e100_mdi_read(struct e100_private *, u32, u32, u16 *);
+
+#endif
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_test.c linux-2.6.5.SUSE/drivers/net/e100-intel/e100_test.c
--- linux-2.6.5/drivers/net/e100-intel/e100_test.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_test.c	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,503 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+#include "e100_phy.h"
+#include "e100_config.h"
+#ifdef ETHTOOL_TEST
+
+extern u16 e100_eeprom_read(struct e100_private *, u16);
+extern int e100_wait_exec_cmplx(struct e100_private *, u32,u8, u8);
+extern void e100_phy_reset(struct e100_private *bdp);
+extern void e100_phy_autoneg(struct e100_private *bdp);
+extern void e100_phy_set_loopback(struct e100_private *bdp);
+extern void e100_force_speed_duplex(struct e100_private *bdp);
+
+static u8 e100_diag_selftest(struct net_device *);
+static u8 e100_diag_eeprom(struct net_device *);
+static u8 e100_diag_loopback(struct net_device *);
+
+static u8 e100_diag_one_loopback (struct net_device *, u8);
+static u8 e100_diag_rcv_loopback_pkt(struct e100_private *);
+static void e100_diag_config_loopback(struct e100_private *, u8, u8, u8 *,u8 *);
+static u8 e100_diag_loopback_alloc(struct e100_private *);
+static void e100_diag_loopback_cu_ru_exec(struct e100_private *);
+static u8 e100_diag_check_pkt(u8 *);
+static void e100_diag_loopback_free(struct e100_private *);
+static int e100_cable_diag(struct e100_private *bdp);
+
+#define LB_PACKET_SIZE 1500
+
+/**
+ * e100_run_diag - main test execution handler - checks mask of requests and calls the diag routines  
+ * @dev: atapter's net device data struct
+ * @test_info: array with test request mask also used to store test results
+ *
+ * RETURNS: updated flags field of struct ethtool_test
+ */
+u32
+e100_run_diag(struct net_device *dev, u64 *test_info, u32 flags)
+{
+	struct e100_private* bdp = dev->priv;
+	u8 test_result = 0;
+
+	if (!e100_get_link_state(bdp)) {
+		test_result = ETH_TEST_FL_FAILED;
+		test_info[test_link] = true;
+	}
+	if (!e100_diag_eeprom(dev)) {
+		test_result = ETH_TEST_FL_FAILED;
+		test_info[test_eeprom] = true;
+	}
+	if (flags & ETH_TEST_FL_OFFLINE) {
+		u8 fail_mask;
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+		}
+		if (e100_diag_selftest(dev)) {
+			test_result = ETH_TEST_FL_FAILED;
+			test_info[test_self_test] = true;
+		}
+
+		fail_mask = e100_diag_loopback(dev);
+		if (fail_mask) {
+			test_result = ETH_TEST_FL_FAILED;
+			if (fail_mask & PHY_LOOPBACK)
+				test_info[test_loopback_phy] = true;
+			if (fail_mask & MAC_LOOPBACK)
+				test_info[test_loopback_mac] = true;
+		}
+
+		test_info[cable_diag] = e100_cable_diag(bdp);
+		/* Need hw init regardless of netif_running */
+		e100_hw_init(bdp);
+		if (netif_running(dev)) {
+			e100_open(dev);
+		}
+	}
+	else {
+		test_info[test_self_test] = false;
+		test_info[test_loopback_phy] = false;
+		test_info[test_loopback_mac] = false;
+		test_info[cable_diag] = false;
+	}
+
+	return flags | test_result;
+}
+
+/**
+ * e100_diag_selftest - run hardware selftest 
+ * @dev: atapter's net device data struct
+ */
+static u8
+e100_diag_selftest(struct net_device *dev)
+{
+	struct e100_private *bdp = dev->priv;
+	u32 st_timeout, st_result;
+	u8 retval = 0;
+
+	if (!e100_selftest(bdp, &st_timeout, &st_result)) {
+		if (!st_timeout) {
+			if (st_result & CB_SELFTEST_REGISTER_BIT)
+				retval |= REGISTER_TEST_FAIL;
+			if (st_result & CB_SELFTEST_DIAG_BIT)
+				retval |= SELF_TEST_FAIL;
+			if (st_result & CB_SELFTEST_ROM_BIT)
+				retval |= ROM_TEST_FAIL;
+		} else {
+            		retval = TEST_TIMEOUT;
+		}
+	}
+
+	return retval;
+}
+
+/**
+ * e100_diag_eeprom - validate eeprom checksum correctness
+ * @dev: atapter's net device data struct
+ *
+ */
+static u8
+e100_diag_eeprom (struct net_device *dev)
+{
+	struct e100_private *bdp = dev->priv;
+	u16 i, eeprom_sum, eeprom_actual_csm;
+
+	for (i = 0, eeprom_sum = 0; i < (bdp->eeprom_size - 1); i++) {
+		eeprom_sum += e100_eeprom_read(bdp, i);
+	}
+
+	eeprom_actual_csm = e100_eeprom_read(bdp, bdp->eeprom_size - 1);
+
+	if (eeprom_actual_csm == (u16)(EEPROM_SUM - eeprom_sum)) {
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ * e100_diag_loopback - performs loopback test  
+ * @dev: atapter's net device data struct
+ */
+static u8
+e100_diag_loopback (struct net_device *dev)
+{
+	u8 rc = 0;
+
+	printk(KERN_DEBUG "%s: PHY loopback test starts\n", dev->name);
+	e100_hw_init(dev->priv);
+	if (!e100_diag_one_loopback(dev, PHY_LOOPBACK)) {
+		rc |= PHY_LOOPBACK;
+	}
+	printk(KERN_DEBUG "%s: PHY loopback test ends\n", dev->name);
+
+	printk(KERN_DEBUG "%s: MAC loopback test starts\n", dev->name);
+	e100_hw_init(dev->priv);
+	if (!e100_diag_one_loopback(dev, MAC_LOOPBACK)) {
+		rc |= MAC_LOOPBACK;
+	}
+	printk(KERN_DEBUG "%s: MAC loopback test ends\n", dev->name);
+
+	return rc;
+}
+
+/**
+ * e100_diag_loopback - performs loopback test  
+ * @dev: atapter's net device data struct
+ * @mode: lopback test type
+ */
+static u8
+e100_diag_one_loopback (struct net_device *dev, u8 mode)
+{
+        struct e100_private *bdp = dev->priv;
+        u8 res = false;
+   	u8 saved_dynamic_tbd = false;
+   	u8 saved_extended_tcb = false;
+
+	if (!e100_diag_loopback_alloc(bdp))
+		return false;
+
+	/* change the config block to standard tcb and the correct loopback */
+        e100_diag_config_loopback(bdp, true, mode,
+				  &saved_extended_tcb, &saved_dynamic_tbd);
+
+	e100_diag_loopback_cu_ru_exec(bdp);
+
+        if (e100_diag_rcv_loopback_pkt(bdp)) {
+		res = true;
+	}
+
+        e100_diag_loopback_free(bdp);
+
+        /* change the config block to previous tcb mode and the no loopback */
+        e100_diag_config_loopback(bdp, false, mode,
+				  &saved_extended_tcb, &saved_dynamic_tbd);
+	return res;
+}
+
+/**
+ * e100_diag_config_loopback - setup/clear loopback before/after lpbk test
+ * @bdp: atapter's private data struct
+ * @set_loopback: true if the function is called to set lb
+ * @loopback_mode: the loopback mode(MAC or PHY)
+ * @tcb_extended: true if need to set extended tcb mode after clean loopback
+ * @dynamic_tbd: true if needed to set dynamic tbd mode after clean loopback
+ *
+ */
+void
+e100_diag_config_loopback(struct e100_private* bdp,
+			  u8 set_loopback,
+			  u8 loopback_mode,
+			  u8* tcb_extended,
+			  u8* dynamic_tbd)
+{
+	/* if set_loopback == true - we want to clear tcb_extended/dynamic_tbd.
+	 * the previous values are saved in the params tcb_extended/dynamic_tbd
+	 * if set_loopback == false - we want to restore previous value.
+	 */
+	if (set_loopback || (*tcb_extended))
+		  *tcb_extended = e100_config_tcb_ext_enable(bdp,*tcb_extended);
+
+	if (set_loopback || (*dynamic_tbd))
+		 *dynamic_tbd = e100_config_dynamic_tbd(bdp,*dynamic_tbd);
+
+	if (set_loopback) {
+		/* ICH PHY loopback is broken */
+		if (bdp->flags & IS_ICH && loopback_mode == PHY_LOOPBACK)
+			loopback_mode = MAC_LOOPBACK;
+		/* Configure loopback on MAC */
+		e100_config_loopback_mode(bdp,loopback_mode);
+	} else {
+		e100_config_loopback_mode(bdp,NO_LOOPBACK);
+	}
+
+	e100_config(bdp);
+
+	if (loopback_mode == PHY_LOOPBACK) {
+		if (set_loopback)
+                        /* Set PHY loopback mode */
+                        e100_phy_set_loopback(bdp);
+		else
+			/* Reset PHY loopback mode */
+			e100_phy_reset(bdp);	
+		/* Wait for PHY state change */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+                schedule_timeout(HZ);
+	} else { /* For MAC loopback wait 500 msec to take effect */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ / 2);
+	}
+}
+  
+/**
+ * e100_diag_loopback_alloc - alloc & initate tcb and rfd for the loopback
+ * @bdp: atapter's private data struct
+ *
+ */
+static u8
+e100_diag_loopback_alloc(struct e100_private *bdp)
+{
+	dma_addr_t dma_handle;
+	tcb_t *tcb;
+	rfd_t *rfd;
+	tbd_t *tbd;
+
+	/* tcb, tbd and transmit buffer are allocated */
+	tcb = pci_alloc_consistent(bdp->pdev,
+				   (sizeof (tcb_t) + sizeof (tbd_t) +
+				    LB_PACKET_SIZE),
+				   &dma_handle);
+        if (tcb == NULL)
+		return false;
+
+	memset(tcb, 0x00, sizeof (tcb_t) + sizeof (tbd_t) + LB_PACKET_SIZE);
+	tcb->tcb_phys = dma_handle;
+	tcb->tcb_hdr.cb_status = 0;
+	tcb->tcb_hdr.cb_cmd =
+		cpu_to_le16(CB_EL_BIT | CB_TRANSMIT | CB_TX_SF_BIT);
+	/* Next command is null */
+	tcb->tcb_hdr.cb_lnk_ptr = cpu_to_le32(0xffffffff);
+	tcb->tcb_cnt = 0;
+	tcb->tcb_thrshld = bdp->tx_thld;
+	tcb->tcb_tbd_num = 1;
+	/* Set up tcb tbd pointer */
+	tcb->tcb_tbd_ptr = cpu_to_le32(tcb->tcb_phys + sizeof (tcb_t));
+	tbd = (tbd_t *) ((u8 *) tcb + sizeof (tcb_t));
+	/* Set up tbd transmit buffer */
+	tbd->tbd_buf_addr =
+		cpu_to_le32(le32_to_cpu(tcb->tcb_tbd_ptr) + sizeof (tbd_t));
+	tbd->tbd_buf_cnt = __constant_cpu_to_le16(1024);
+	/* The value of first 512 bytes is FF */
+	memset((void *) ((u8 *) tbd + sizeof (tbd_t)), 0xFF, 512);
+	/* The value of second 512 bytes is BA */
+	memset((void *) ((u8 *) tbd + sizeof (tbd_t) + 512), 0xBA, 512);
+	wmb();
+	rfd = pci_alloc_consistent(bdp->pdev, sizeof (rfd_t), &dma_handle);
+
+	if (rfd == NULL) {
+		pci_free_consistent(bdp->pdev,
+				    sizeof (tcb_t) + sizeof (tbd_t) +
+				    LB_PACKET_SIZE, tcb, tcb->tcb_phys);
+		return false;
+	}
+
+	memset(rfd, 0x00, sizeof (rfd_t));
+
+	/* init all fields in rfd */
+	rfd->rfd_header.cb_cmd = cpu_to_le16(RFD_EL_BIT);
+	rfd->rfd_sz = cpu_to_le16(ETH_FRAME_LEN + CHKSUM_SIZE);
+	/* dma_handle is physical address of rfd */
+	bdp->loopback.dma_handle = dma_handle;
+	bdp->loopback.tcb = tcb;
+	bdp->loopback.rfd = rfd;
+	wmb();
+	return true;
+}
+
+/**
+ * e100_diag_loopback_cu_ru_exec - activates cu and ru to send & receive the pkt
+ * @bdp: atapter's private data struct
+ *
+ */
+static void
+e100_diag_loopback_cu_ru_exec(struct e100_private *bdp)
+{
+	/*load CU & RU base */ 
+	if(!e100_wait_exec_cmplx(bdp, bdp->loopback.dma_handle, SCB_RUC_START, 0))
+		printk(KERN_ERR "e100: SCB_RUC_START failed!\n");
+
+	bdp->next_cu_cmd = START_WAIT;
+	e100_start_cu(bdp, bdp->loopback.tcb);
+	bdp->last_tcb = NULL;
+	rmb();
+}
+/**
+ * e100_diag_check_pkt - checks if a given packet is a loopback packet
+ * @bdp: atapter's private data struct
+ *
+ * Returns true if OK false otherwise.
+ */
+static u8
+e100_diag_check_pkt(u8 *datap)
+{
+	int i;
+	for (i = 0; i<512; i++) {
+		if( !((*datap)==0xFF && (*(datap + 512) == 0xBA)) ) {
+			printk (KERN_ERR "e100: check loopback packet failed at: %x\n", i);
+			return false;
+			}
+	}
+	printk (KERN_DEBUG "e100: Check received loopback packet OK\n");
+	return true;
+}
+
+/**
+ * e100_diag_rcv_loopback_pkt - waits for receive and checks lpbk packet
+ * @bdp: atapter's private data struct
+ *
+ * Returns true if OK false otherwise.
+ */
+static u8
+e100_diag_rcv_loopback_pkt(struct e100_private* bdp) 
+{    
+	rfd_t *rfdp;
+	u16 rfd_status;
+	unsigned long expires = jiffies + HZ * 2;
+
+        rfdp =bdp->loopback.rfd;
+
+        rfd_status = le16_to_cpu(rfdp->rfd_header.cb_status);
+
+        while (!(rfd_status & RFD_STATUS_COMPLETE)) { 
+		if (time_before(jiffies, expires)) {
+			yield();
+			rmb();
+			rfd_status = le16_to_cpu(rfdp->rfd_header.cb_status);
+		} else {
+			break;
+		}
+        }
+
+        if (rfd_status & RFD_STATUS_COMPLETE) {
+		printk(KERN_DEBUG "e100: Loopback packet received\n");
+                return e100_diag_check_pkt(((u8 *)rfdp+bdp->rfd_size));
+	}
+	else {
+		printk(KERN_ERR "e100: Loopback packet not received\n");
+		return false;
+	}
+}
+
+/**
+ * e100_diag_loopback_free - free data allocated for loopback pkt send/receive
+ * @bdp: atapter's private data struct
+ *
+ */
+static void
+e100_diag_loopback_free (struct e100_private *bdp)
+{
+        pci_free_consistent(bdp->pdev,
+			    sizeof(tcb_t) + sizeof(tbd_t) + LB_PACKET_SIZE,
+			    bdp->loopback.tcb, bdp->loopback.tcb->tcb_phys);
+
+        pci_free_consistent(bdp->pdev, sizeof(rfd_t), bdp->loopback.rfd,
+			    bdp->loopback.dma_handle);
+}
+
+#endif
+
+static int
+e100_cable_diag(struct e100_private *bdp)
+{	
+	int saved_open_circut = 0xffff;
+	int saved_short_circut = 0xffff;
+	int saved_distance = 0xffff;
+	int saved_same = 0;
+	int cable_status = E100_CABLE_UNKNOWN;
+	int i;
+	
+	/* If we have link, */	
+	if (e100_get_link_state(bdp))
+		return E100_CABLE_OK;
+	
+	if (bdp->rev_id < D102_REV_ID)
+		return E100_CABLE_UNKNOWN;
+
+	/* Disable MDI/MDI-X auto switching */
+        e100_mdi_write(bdp, MII_NCONFIG, bdp->phy_addr,
+		MDI_MDIX_RESET_ALL_MASK);
+	/* Set to 100 Full as required by cable test */
+	e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr,
+		BMCR_SPEED100 | BMCR_FULLDPLX);
+
+	/* Test up to 100 times */
+	for (i = 0; i < 100; i++) {
+		u16 ctrl_reg;
+		int distance, open_circut, short_circut, near_end;
+
+		/* Enable and execute cable test */
+		e100_mdi_write(bdp, HWI_CONTROL_REG, bdp->phy_addr,
+			(HWI_TEST_ENABLE | HWI_TEST_EXECUTE));
+		/* Wait for cable test finished */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/100 + 1);
+		/* Read results */
+		e100_mdi_read(bdp, HWI_CONTROL_REG, bdp->phy_addr, &ctrl_reg);
+		distance = ctrl_reg & HWI_TEST_DISTANCE;
+		open_circut = ctrl_reg & HWI_TEST_HIGHZ_PROBLEM;
+		short_circut = ctrl_reg & HWI_TEST_LOWZ_PROBLEM;
+
+		if ((distance == saved_distance) &&
+	    	    (open_circut == saved_open_circut) &&
+	    	    (short_circut == saved_short_circut)) 
+			saved_same++;
+		else {
+			saved_same = 0;
+			saved_distance = distance;
+			saved_open_circut = open_circut;
+			saved_short_circut = short_circut;
+		}
+		/* If results are the same 3 times */
+		if (saved_same == 3) {
+			near_end = ((distance * HWI_REGISTER_GRANULARITY) <
+			       HWI_NEAR_END_BOUNDARY);
+			if (open_circut)
+				cable_status = (near_end) ? 
+					E100_CABLE_OPEN_NEAR : E100_CABLE_OPEN_FAR;
+			if (short_circut)
+				cable_status = (near_end) ?
+					E100_CABLE_SHORT_NEAR : E100_CABLE_SHORT_FAR;
+			break;
+		}
+	}
+	/* Reset cable test */
+        e100_mdi_write(bdp, HWI_CONTROL_REG, bdp->phy_addr,					       HWI_RESET_ALL_MASK);
+	return cable_status;
+}
+
diff -urNp linux-2.6.5/drivers/net/e100-intel/e100_ucode.h linux-2.6.5.SUSE/drivers/net/e100-intel/e100_ucode.h
--- linux-2.6.5/drivers/net/e100-intel/e100_ucode.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e100-intel/e100_ucode.h	2004-04-19 12:01:13.000000000 +0200
@@ -0,0 +1,384 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+*******************************************************************************/
+
+#ifndef _E100_UCODE_H_
+#define _E100_UCODE_H_
+
+/*
+e100_ucode.h
+
+This file contains the loadable micro code arrays to implement receive 
+bundling on the D101 A-step, D101 B-step, D101M (B-step only), D101S, 
+D102 B-step, D102 B-step with TCO work around and D102 C-step.
+
+Each controller has its own specific micro code array.  The array for one 
+controller is totally incompatible with any other controller, and if used 
+will most likely cause the controller to lock up and stop responding to 
+the driver.  Each micro code array has its own parameter offsets (described 
+below), and they each have their own version number.
+*/
+
+/*************************************************************************
+*  CPUSaver parameters
+*
+*  All CPUSaver parameters are 16-bit literals that are part of a
+*  "move immediate value" instruction.  By changing the value of
+*  the literal in the instruction before the code is loaded, the
+*  driver can change algorithm.
+*
+*  CPUSAVER_DWORD - This is the location of the instruction that loads
+*    the dead-man timer with its inital value.  By writing a 16-bit
+*    value to the low word of this instruction, the driver can change
+*    the timer value.  The current default is either x600 or x800;
+*    experiments show that the value probably should stay within the
+*    range of x200 - x1000.
+*
+*  CPUSAVER_BUNDLE_MAX_DWORD - This is the location of the instruction
+*    that sets the maximum number of frames that will be bundled.  In
+*    some situations, such as the TCP windowing algorithm, it may be
+*    better to limit the growth of the bundle size than let it go as
+*    high as it can, because that could cause too much added latency.
+*    The default is six, because this is the number of packets in the
+*    default TCP window size.  A value of 1 would make CPUSaver indicate
+*    an interrupt for every frame received.  If you do not want to put
+*    a limit on the bundle size, set this value to xFFFF.
+*
+*  CPUSAVER_MIN_SIZE_DWORD - This is the location of the instruction
+*    that contains a bit-mask describing the minimum size frame that
+*    will be bundled.  The default masks the lower 7 bits, which means
+*    that any frame less than 128 bytes in length will not be bundled,
+*    but will instead immediately generate an interrupt.  This does
+*    not affect the current bundle in any way.  Any frame that is 128
+*    bytes or large will be bundled normally.  This feature is meant
+*    to provide immediate indication of ACK frames in a TCP environment.
+*    Customers were seeing poor performance when a machine with CPUSaver
+*    enabled was sending but not receiving.  The delay introduced when
+*    the ACKs were received was enough to reduce total throughput, because
+*    the sender would sit idle until the ACK was finally seen.
+*
+*    The current default is 0xFF80, which masks out the lower 7 bits.
+*    This means that any frame which is x7F (127) bytes or smaller
+*    will cause an immediate interrupt.  Because this value must be a 
+*    bit mask, there are only a few valid values that can be used.  To
+*    turn this feature off, the driver can write the value xFFFF to the
+*    lower word of this instruction (in the same way that the other
+*    parameters are used).  Likewise, a value of 0xF800 (2047) would
+*    cause an interrupt to be generated for every frame, because all
+*    standard Ethernet frames are <= 2047 bytes in length.
+*************************************************************************/
+
+#ifndef UCODE_MAX_DWORDS
+#define UCODE_MAX_DWORDS	134
+#endif
+
+/********************************************************/
+/*  CPUSaver micro code for the D101A                   */
+/********************************************************/
+
+/*  Version 2.0  */
+
+/*  This value is the same for both A and B step of 558.  */
+
+#define D101_CPUSAVER_TIMER_DWORD		72
+#define D101_CPUSAVER_BUNDLE_DWORD		UCODE_MAX_DWORDS
+#define D101_CPUSAVER_MIN_SIZE_DWORD		UCODE_MAX_DWORDS
+
+#define     D101_A_RCVBUNDLE_UCODE \
+{\
+0x03B301BB, 0x0046FFFF, 0xFFFFFFFF, 0x051DFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
+0x000C0001, 0x00101212, 0x000C0008, 0x003801BC, \
+0x00000000, 0x00124818, 0x000C1000, 0x00220809, \
+0x00010200, 0x00124818, 0x000CFFFC, 0x003803B5, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x0010009C, 0x0024B81D, 0x00130836, 0x000C0001, \
+0x0026081C, 0x0020C81B, 0x00130824, 0x00222819, \
+0x00101213, 0x00041000, 0x003A03B3, 0x00010200, \
+0x00101B13, 0x00238081, 0x00213049, 0x0038003B, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x0010009C, 0x0024B83E, 0x00130826, 0x000C0001, \
+0x0026083B, 0x00010200, 0x00134824, 0x000C0001, \
+0x00101213, 0x00041000, 0x0038051E, 0x00101313, \
+0x00010400, 0x00380521, 0x00050600, 0x00100824, \
+0x00101310, 0x00041000, 0x00080600, 0x00101B10, \
+0x0038051E, 0x00000000, 0x00000000, 0x00000000  \
+}
+
+/********************************************************/
+/*  CPUSaver micro code for the D101B                   */
+/********************************************************/
+
+/*  Version 2.0  */
+
+#define     D101_B0_RCVBUNDLE_UCODE \
+{\
+0x03B401BC, 0x0047FFFF, 0xFFFFFFFF, 0x051EFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
+0x000C0001, 0x00101B92, 0x000C0008, 0x003801BD, \
+0x00000000, 0x00124818, 0x000C1000, 0x00220809, \
+0x00010200, 0x00124818, 0x000CFFFC, 0x003803B6, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x0010009C, 0x0024B81D, 0x0013082F, 0x000C0001, \
+0x0026081C, 0x0020C81B, 0x00130837, 0x00222819, \
+0x00101B93, 0x00041000, 0x003A03B4, 0x00010200, \
+0x00101793, 0x00238082, 0x0021304A, 0x0038003C, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x0010009C, 0x0024B83E, 0x00130826, 0x000C0001, \
+0x0026083B, 0x00010200, 0x00134837, 0x000C0001, \
+0x00101B93, 0x00041000, 0x0038051F, 0x00101313, \
+0x00010400, 0x00380522, 0x00050600, 0x00100837, \
+0x00101310, 0x00041000, 0x00080600, 0x00101790, \
+0x0038051F, 0x00000000, 0x00000000, 0x00000000  \
+}
+
+/********************************************************/
+/*  CPUSaver micro code for the D101M (B-step only)     */
+/********************************************************/
+
+/*  Version 2.10.1  */
+
+/*  Parameter values for the D101M B-step  */
+#define D101M_CPUSAVER_TIMER_DWORD		78
+#define D101M_CPUSAVER_BUNDLE_DWORD		65
+#define D101M_CPUSAVER_MIN_SIZE_DWORD		126
+
+#define D101M_B_RCVBUNDLE_UCODE \
+{\
+0x00550215, 0xFFFF0437, 0xFFFFFFFF, 0x06A70789, 0xFFFFFFFF, 0x0558FFFF, \
+0x000C0001, 0x00101312, 0x000C0008, 0x00380216, \
+0x0010009C, 0x00204056, 0x002380CC, 0x00380056, \
+0x0010009C, 0x00244C0B, 0x00000800, 0x00124818, \
+0x00380438, 0x00000000, 0x00140000, 0x00380555, \
+0x00308000, 0x00100662, 0x00100561, 0x000E0408, \
+0x00134861, 0x000C0002, 0x00103093, 0x00308000, \
+0x00100624, 0x00100561, 0x000E0408, 0x00100861, \
+0x000C007E, 0x00222C21, 0x000C0002, 0x00103093, \
+0x00380C7A, 0x00080000, 0x00103090, 0x00380C7A, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x0010009C, 0x00244C2D, 0x00010004, 0x00041000, \
+0x003A0437, 0x00044010, 0x0038078A, 0x00000000, \
+0x00100099, 0x00206C7A, 0x0010009C, 0x00244C48, \
+0x00130824, 0x000C0001, 0x00101213, 0x00260C75, \
+0x00041000, 0x00010004, 0x00130826, 0x000C0006, \
+0x002206A8, 0x0013C926, 0x00101313, 0x003806A8, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00080600, 0x00101B10, 0x00050004, 0x00100826, \
+0x00101210, 0x00380C34, 0x00000000, 0x00000000, \
+0x0021155B, 0x00100099, 0x00206559, 0x0010009C, \
+0x00244559, 0x00130836, 0x000C0000, 0x00220C62, \
+0x000C0001, 0x00101B13, 0x00229C0E, 0x00210C0E, \
+0x00226C0E, 0x00216C0E, 0x0022FC0E, 0x00215C0E, \
+0x00214C0E, 0x00380555, 0x00010004, 0x00041000, \
+0x00278C67, 0x00040800, 0x00018100, 0x003A0437, \
+0x00130826, 0x000C0001, 0x00220559, 0x00101313, \
+0x00380559, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00130831, 0x0010090B, 0x00124813, \
+0x000CFF80, 0x002606AB, 0x00041000, 0x00010004, \
+0x003806A8, 0x00000000, 0x00000000, 0x00000000, \
+}
+
+/********************************************************/
+/*  CPUSaver micro code for the D101S                   */
+/********************************************************/
+
+/*  Version 1.20.1  */
+
+/*  Parameter values for the D101S  */
+#define D101S_CPUSAVER_TIMER_DWORD		78
+#define D101S_CPUSAVER_BUNDLE_DWORD		67
+#define D101S_CPUSAVER_MIN_SIZE_DWORD		128
+
+#define D101S_RCVBUNDLE_UCODE \
+{\
+0x00550242, 0xFFFF047E, 0xFFFFFFFF, 0x06FF0818, 0xFFFFFFFF, 0x05A6FFFF, \
+0x000C0001, 0x00101312, 0x000C0008, 0x00380243, \
+0x0010009C, 0x00204056, 0x002380D0, 0x00380056, \
+0x0010009C, 0x00244F8B, 0x00000800, 0x00124818, \
+0x0038047F, 0x00000000, 0x00140000, 0x003805A3, \
+0x00308000, 0x00100610, 0x00100561, 0x000E0408, \
+0x00134861, 0x000C0002, 0x00103093, 0x00308000, \
+0x00100624, 0x00100561, 0x000E0408, 0x00100861, \
+0x000C007E, 0x00222FA1, 0x000C0002, 0x00103093, \
+0x00380F90, 0x00080000, 0x00103090, 0x00380F90, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x0010009C, 0x00244FAD, 0x00010004, 0x00041000, \
+0x003A047E, 0x00044010, 0x00380819, 0x00000000, \
+0x00100099, 0x00206FFD, 0x0010009A, 0x0020AFFD, \
+0x0010009C, 0x00244FC8, 0x00130824, 0x000C0001, \
+0x00101213, 0x00260FF7, 0x00041000, 0x00010004, \
+0x00130826, 0x000C0006, 0x00220700, 0x0013C926, \
+0x00101313, 0x00380700, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00080600, 0x00101B10, 0x00050004, 0x00100826, \
+0x00101210, 0x00380FB6, 0x00000000, 0x00000000, \
+0x002115A9, 0x00100099, 0x002065A7, 0x0010009A, \
+0x0020A5A7, 0x0010009C, 0x002445A7, 0x00130836, \
+0x000C0000, 0x00220FE4, 0x000C0001, 0x00101B13, \
+0x00229F8E, 0x00210F8E, 0x00226F8E, 0x00216F8E, \
+0x0022FF8E, 0x00215F8E, 0x00214F8E, 0x003805A3, \
+0x00010004, 0x00041000, 0x00278FE9, 0x00040800, \
+0x00018100, 0x003A047E, 0x00130826, 0x000C0001, \
+0x002205A7, 0x00101313, 0x003805A7, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00130831, \
+0x0010090B, 0x00124813, 0x000CFF80, 0x00260703, \
+0x00041000, 0x00010004, 0x00380700  \
+}
+
+/********************************************************/
+/*  CPUSaver micro code for the D102 B-step             */
+/********************************************************/
+
+/*  Version 2.0  */
+/*  Parameter values for the D102 B-step  */
+#define D102_B_CPUSAVER_TIMER_DWORD		82
+#define D102_B_CPUSAVER_BUNDLE_DWORD		106
+#define D102_B_CPUSAVER_MIN_SIZE_DWORD		70
+
+#define     D102_B_RCVBUNDLE_UCODE \
+{\
+0x006F0276, 0x0EF71FFF, 0x0ED30F86, 0x0D250ED9, 0x1FFF1FFF, 0x1FFF04D2, \
+0x00300001, 0x0140D871, 0x00300008, 0x00E00277, \
+0x01406C57, 0x00816073, 0x008700FA, 0x00E00070, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x01406CBA, 0x00807F9A, 0x00901F9A, 0x0024FFFF, \
+0x014B6F6F, 0x0030FFFE, 0x01407172, 0x01496FBA, \
+0x014B6F72, 0x00308000, 0x01406C52, 0x00912EFC, \
+0x00E00EF8, 0x00000000, 0x00000000, 0x00000000, \
+0x00906F8C, 0x00900F8C, 0x00E00F87, 0x00000000, \
+0x00906ED8, 0x01406C55, 0x00E00ED4, 0x00000000, \
+0x01406C51, 0x0080DFC2, 0x01406C52, 0x00815FC2, \
+0x01406C57, 0x00917FCC, 0x00E01FDD, 0x00000000, \
+0x00822D30, 0x01406C51, 0x0080CD26, 0x01406C52, \
+0x00814D26, 0x01406C57, 0x00916D26, 0x014C6FD7, \
+0x00300000, 0x00841FD2, 0x00300001, 0x0140D772, \
+0x00E012B3, 0x014C6F91, 0x0150710B, 0x01496F72, \
+0x0030FF80, 0x00940EDD, 0x00102000, 0x00038400, \
+0x00E00EDA, 0x00000000, 0x00000000, 0x00000000, \
+0x01406C57, 0x00917FE9, 0x00001000, 0x00E01FE9, \
+0x00200600, 0x0140D76F, 0x00138400, 0x01406FD8, \
+0x0140D96F, 0x00E01FDD, 0x00038400, 0x00102000, \
+0x00971FD7, 0x00101000, 0x00050200, 0x00E804D2, \
+0x014C6FD8, 0x00300001, 0x00840D26, 0x0140D872, \
+0x00E00D26, 0x014C6FD9, 0x00300001, 0x0140D972, \
+0x00941FBD, 0x00102000, 0x00038400, 0x014C6FD8, \
+0x00300006, 0x00840EDA, 0x014F71D8, 0x0140D872, \
+0x00E00EDA, 0x01496F50, 0x00E004D3, 0x00000000, \
+}
+
+/********************************************************/
+/*  Micro code for the D102 C-step                      */
+/********************************************************/
+
+/*  Parameter values for the D102 C-step  */
+#define D102_C_CPUSAVER_TIMER_DWORD		46
+#define D102_C_CPUSAVER_BUNDLE_DWORD		74
+#define D102_C_CPUSAVER_MIN_SIZE_DWORD		54
+
+#define     D102_C_RCVBUNDLE_UCODE \
+{ \
+0x00700279, 0x0E6604E2, 0x02BF0CAE, 0x1508150C, 0x15190E5B, 0x0E840F13, \
+0x00E014D8, 0x00000000, 0x00000000, 0x00000000, \
+0x00E014DC, 0x00000000, 0x00000000, 0x00000000, \
+0x00E014F4, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00E014E0, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00E014E7, 0x00000000, 0x00000000, 0x00000000, \
+0x00141000, 0x015D6F0D, 0x00E002C0, 0x00000000, \
+0x00200600, 0x00E0150D, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x0030FF80, 0x00940E6A, 0x00038200, 0x00102000, \
+0x00E00E67, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00906E65, 0x00800E60, 0x00E00E5D, 0x00000000, \
+0x00300006, 0x00E0151A, 0x00000000, 0x00000000, \
+0x00906F19, 0x00900F19, 0x00E00F14, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x01406CBA, 0x00807FDA, 0x00901FDA, 0x0024FFFF, \
+0x014B6F6F, 0x0030FFFE, 0x01407172, 0x01496FBA, \
+0x014B6F72, 0x00308000, 0x01406C52, 0x00912E89, \
+0x00E00E85, 0x00000000, 0x00000000, 0x00000000  \
+}
+
+/********************************************************/
+/*  Micro code for the D102 E-step                      */
+/********************************************************/
+
+/*  Parameter values for the D102 E-step  */
+#define D102_E_CPUSAVER_TIMER_DWORD		42
+#define D102_E_CPUSAVER_BUNDLE_DWORD		54
+#define D102_E_CPUSAVER_MIN_SIZE_DWORD		46
+
+#define     D102_E_RCVBUNDLE_UCODE \
+{\
+0x007D028F, 0x0E4204F9, 0x14ED0C85, 0x14FA14E9, 0x0EF70E36, 0x1FFF1FFF, \
+0x00E014B9, 0x00000000, 0x00000000, 0x00000000, \
+0x00E014BD, 0x00000000, 0x00000000, 0x00000000, \
+0x00E014D5, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00E014C1, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00E014C8, 0x00000000, 0x00000000, 0x00000000, \
+0x00200600, 0x00E014EE, 0x00000000, 0x00000000, \
+0x0030FF80, 0x00940E46, 0x00038200, 0x00102000, \
+0x00E00E43, 0x00000000, 0x00000000, 0x00000000, \
+0x00300006, 0x00E014FB, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00906E41, 0x00800E3C, 0x00E00E39, 0x00000000, \
+0x00906EFD, 0x00900EFD, 0x00E00EF8, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+0x00000000, 0x00000000, 0x00000000, 0x00000000, \
+}
+
+#endif /* _E100_UCODE_H_ */
