From: Egbert Eich <eich@suse.de>
Subject: DRI: Support 32bit ioctls
References: 72943

Index: drivers/char/drm/Makefile
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/Makefile,v
retrieving revision 1.1.1.3
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.3 Makefile
--- linux/drivers/char/drm/Makefile	14 Mar 2005 10:18:13 -0000	1.1.1.3
+++ drivers/char/drm/Makefile	15 Mar 2005 18:02:51 -0000
@@ -2,6 +2,13 @@
 # Makefile for the drm device driver.  This driver provides support for the
 # Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
 
+ifneq (,$(MACHINE))
+MACHINE := $(ARCH)
+endif
+ifneq (,findstring x86_64,$(MACHINE))
+DO_IOCTL32 := y
+endif
+
 drm-objs    :=	drm_auth.o drm_bufs.o drm_context.o drm_dma.o drm_drawable.o \
 		drm_drv.o drm_fops.o drm_init.o drm_ioctl.o drm_irq.o \
 		drm_lock.o drm_memory.o drm_proc.o drm_stub.o drm_vm.o \
@@ -10,15 +17,26 @@
 
 gamma-objs  := gamma_drv.o gamma_dma.o
 tdfx-objs   := tdfx_drv.o
-r128-objs   := r128_drv.o r128_cce.o r128_state.o r128_irq.o
-mga-objs    := mga_drv.o mga_dma.o mga_state.o mga_warp.o mga_irq.o
+r128-objs   := r128_drv.o r128_cce.o r128_state.o r128_irq.o r128_ioctl32.o
+mga-objs    := mga_drv.o mga_dma.o mga_state.o mga_warp.o mga_irq.o mga_ioctl32.o
 i810-objs   := i810_drv.o i810_dma.o
 i830-objs   := i830_drv.o i830_dma.o i830_irq.o
 i915-objs   := i915_drv.o i915_dma.o i915_irq.o i915_mem.o
-radeon-objs := radeon_drv.o radeon_cp.o radeon_state.o radeon_mem.o radeon_irq.o
+radeon-objs := radeon_drv.o radeon_cp.o radeon_state.o radeon_mem.o radeon_irq.o radeon_ioctl32.o
 ffb-objs    := ffb_drv.o ffb_context.o
 sis-objs    := sis_drv.o sis_ds.o sis_mm.o
 via-objs    := via_irq.o via_drv.o via_ds.o via_map.o via_mm.o via_dma.o via_verifier.o
+ioctl32-objs := drm_ioctl32.c
+
+#CONFIG_DRM_IOCTL32 = m
+CONFIG_DRM = m
+
+ifeq ($(DO_IOCTL32),y)
+r128-objs += r128_ioctl32.o
+radeon-objs += radeon_ioctl32.o
+mga-objs += mga_ioctl32.o
+CONFIG_DRM_IOCTL32 = $(CONFIG_DRM)
+endif
 
 obj-$(CONFIG_DRM)	+= drm.o
 obj-$(CONFIG_DRM_GAMMA) += gamma.o
@@ -32,4 +50,4 @@
 obj-$(CONFIG_DRM_FFB)   += ffb.o
 obj-$(CONFIG_DRM_SIS)   += sis.o
 obj-$(CONFIG_DRM_VIA)   += via.o
-
+obj-$(CONFIG_DRM_IOCTL32) += drm_ioctl32.o
Index: drivers/char/drm/drm.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm.h,v
retrieving revision 1.1.1.1
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.1 drm.h
--- linux/drivers/char/drm/drm.h	20 Nov 2004 10:55:18 -0000	1.1.1.1
+++ drivers/char/drm/drm.h	15 Mar 2005 18:02:51 -0000
@@ -227,7 +227,7 @@
 
 typedef struct drm_ctx_priv_map {
 	unsigned int	ctx_id;  /**< Context requesting private mapping */
-	void		*handle; /**< Handle of map */
+	unsigned long		handle; /**< Handle of map */
 } drm_ctx_priv_map_t;
 
 
@@ -242,12 +242,16 @@
 	unsigned long	size;	 /**< Requested physical size (bytes) */
 	drm_map_type_t	type;	 /**< Type of memory to map */
 	drm_map_flags_t flags;	 /**< Flags */
-	void		*handle; /**< User-space: "Handle" to pass to mmap() */
+	unsigned long   pub_handle; /**< User-space: "Handle" to pass to mmap() */
 				 /**< Kernel-space: kernel-virtual address */
 	int		mtrr;	 /**< MTRR slot used */
 				 /*   Private data */
 } drm_map_t;
 
+typedef struct drm_map_priv {
+    struct drm_map pub;
+    void *handle;
+} drm_map_priv_t;
 
 /**
  * DRM_IOCTL_GET_CLIENT ioctl argument type.
Index: drivers/char/drm/drmP.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drmP.h,v
retrieving revision 1.1.1.6
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.6 drmP.h
--- linux/drivers/char/drm/drmP.h	14 Mar 2005 10:18:13 -0000	1.1.1.6
+++ drivers/char/drm/drmP.h	15 Mar 2005 18:02:51 -0000
@@ -526,10 +526,10 @@
  */
 typedef struct drm_map_list {
 	struct list_head	head;	/**< list head */
-	drm_map_t		*map;	/**< mapping */
+	drm_map_priv_t		*map;	/**< mapping */
 } drm_map_list_t;
 
-typedef drm_map_t drm_local_map_t;
+typedef drm_map_priv_t drm_local_map_t;
 
 /**
  * Context handle list
@@ -563,6 +563,8 @@
 	int (*postcleanup)(struct drm_device *);
 	int (*presetup)(struct drm_device *);
 	int (*postsetup)(struct drm_device *);
+        int (*register_ioctl32)( void );
+        void (*unregister_ioctl32)( void );
  	int (*dma_ioctl)( DRM_IOCTL_ARGS );
 	int (*open_helper)(struct drm_device *, drm_file_t *);
 	void (*free_filp_priv)(struct drm_device *, drm_file_t *);
@@ -581,7 +583,7 @@
  	void (*irq_postinstall)(struct drm_device *dev);
  	void (*irq_uninstall)(struct drm_device *dev);
 	void (*reclaim_buffers)(struct drm_device *dev, struct file *filp);
-	unsigned long (*get_map_ofs)(drm_map_t *map);
+	unsigned long (*get_map_ofs)(drm_map_priv_t *map);
 	unsigned long (*get_reg_ofs)(struct drm_device *dev);
 	void (*set_version)(struct drm_device *dev, drm_set_version_t *sv);
  	int (*version)(drm_version_t *version);
@@ -646,7 +648,7 @@
 	int		  ctx_count;	/**< Number of context handles */
 	struct semaphore  ctxlist_sem;	/**< For ctxlist */
 
-	drm_map_t	  **context_sareas; /**< per-context SAREA's */
+	drm_map_priv_t	  **context_sareas; /**< per-context SAREA's */
 	int		  max_context;
 
 	drm_vma_entry_t	  *vmalist;	/**< List of vmas (for debugging) */
@@ -1007,29 +1009,29 @@
 
 
 /* Inline replacements for DRM_IOREMAP macros */
-static __inline__ void drm_core_ioremap(struct drm_map *map, struct drm_device *dev)
+static __inline__ void drm_core_ioremap(struct drm_map_priv *map, struct drm_device *dev)
 {
-	map->handle = drm_ioremap( map->offset, map->size, dev );
+	map->handle = drm_ioremap( map->pub.offset, map->pub.size, dev );
 }
 
-static __inline__ void drm_core_ioremap_nocache(struct drm_map *map, struct drm_device *dev)
+static __inline__ void drm_core_ioremap_nocache(struct drm_map_priv *map, struct drm_device *dev)
 {
-	map->handle = drm_ioremap_nocache(map->offset, map->size, dev);
+	map->handle = drm_ioremap_nocache(map->pub.offset, map->pub.size, dev);
 }
 
-static __inline__ void drm_core_ioremapfree(struct drm_map *map, struct drm_device *dev)
+static __inline__ void drm_core_ioremapfree(struct drm_map_priv *map, struct drm_device *dev)
 {
-	if ( map->handle && map->size )
-		drm_ioremapfree( map->handle, map->size, dev );
+	if ( map->handle && map->pub.size )
+		drm_ioremapfree( map->handle, map->pub.size, dev );
 }
 
-static __inline__ struct drm_map *drm_core_findmap(struct drm_device *dev, unsigned long offset)
+static __inline__ struct drm_map_priv *drm_core_findmap(struct drm_device *dev, unsigned long offset)
 {
 	struct list_head *_list;
 	list_for_each( _list, &dev->maplist->head ) {
 		drm_map_list_t *_entry = list_entry( _list, drm_map_list_t, head );
 		if ( _entry->map &&
-		     _entry->map->offset == offset ) {
+		     _entry->map->pub.pub_handle == offset ) {
 			return _entry->map;
 		}
 	}
@@ -1059,7 +1061,7 @@
 
 /*@}*/
 
-extern unsigned long drm_core_get_map_ofs(drm_map_t *map);
+extern unsigned long drm_core_get_map_ofs(drm_map_priv_t *map);
 extern unsigned long drm_core_get_reg_ofs(struct drm_device *dev);
 
 #endif /* __KERNEL__ */
Index: drivers/char/drm/drm_bufs.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_bufs.c,v
retrieving revision 1.1.1.1
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.1 drm_bufs.c
--- linux/drivers/char/drm/drm_bufs.c	11 Jan 2005 10:26:56 -0000	1.1.1.1
+++ drivers/char/drm/drm_bufs.c	15 Mar 2005 18:02:52 -0000
@@ -36,6 +36,41 @@
 #include <linux/vmalloc.h>
 #include "drmP.h"
 
+#ifdef _LP64
+static __inline__ unsigned int HandleID(void *handle, drm_device_t *dev) 
+{
+    unsigned long lhandle;
+    unsigned int hash;
+    struct list_head *list;
+    drm_map_list_t *r_list = NULL;
+   
+    lhandle = (unsigned long)handle;
+    hash = (unsigned int)(((lhandle >> 32) 
+			   + (lhandle >> 16) 
+			   + lhandle) & 0xffff0000);
+    while (1) {
+	if (hash == 0) hash = (1 << 16);
+
+	list = &dev->maplist->head;
+	list_for_each(list, &dev->maplist->head) {
+	    r_list = list_entry(list, drm_map_list_t, head);
+
+	    if(r_list->map && r_list->map->pub.pub_handle
+	       && r_list->map->pub.pub_handle == hash)
+		break;
+	}
+
+	if(list == (&dev->maplist->head))
+	    return hash;
+
+	hash += (1 << 16);
+    }
+}
+#else
+# define HandleID(x,dev) (unsigned int)(x)
+#endif
+
+
 /**
  * Compute size order.  Returns the exponent of the smaller power of two which
  * is greater or equal to given number.
@@ -78,7 +113,7 @@
 {
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->dev;
-	drm_map_t *map;
+	drm_map_priv_t *map;
 	drm_map_t __user *argp = (void __user *)arg;
 	drm_map_list_t *list;
 
@@ -88,7 +123,7 @@
 	if ( !map )
 		return -ENOMEM;
 
-	if ( copy_from_user( map, argp, sizeof(*map) ) ) {
+	if ( copy_from_user( map, argp, sizeof(drm_map_t) ) ) {
 		drm_free( map, sizeof(*map), DRM_MEM_MAPS );
 		return -EFAULT;
 	}
@@ -97,54 +132,54 @@
 	 * book keeping information about shared memory to allow for removal
 	 * when processes fork.
 	 */
-	if ( (map->flags & _DRM_REMOVABLE) && map->type != _DRM_SHM ) {
+	if ( (map->pub.flags & _DRM_REMOVABLE) && map->pub.type != _DRM_SHM ) {
 		drm_free( map, sizeof(*map), DRM_MEM_MAPS );
 		return -EINVAL;
 	}
 	DRM_DEBUG( "offset = 0x%08lx, size = 0x%08lx, type = %d\n",
-		   map->offset, map->size, map->type );
-	if ( (map->offset & (~PAGE_MASK)) || (map->size & (~PAGE_MASK)) ) {
+		   map->pub.offset, map->pub.size, map->pub.type );
+	if ( (map->pub.offset & (~PAGE_MASK)) || (map->pub.size & (~PAGE_MASK)) ) {
 		drm_free( map, sizeof(*map), DRM_MEM_MAPS );
 		return -EINVAL;
 	}
-	map->mtrr   = -1;
+	map->pub.mtrr   = -1;
 	map->handle = NULL;
 
-	switch ( map->type ) {
+	switch ( map->pub.type ) {
 	case _DRM_REGISTERS:
 	case _DRM_FRAME_BUFFER:
 #if !defined(__sparc__) && !defined(__alpha__) && !defined(__ia64__)
-		if ( map->offset + map->size < map->offset ||
-		     map->offset < virt_to_phys(high_memory) ) {
+		if ( map->pub.offset + map->pub.size < map->pub.offset ||
+		     map->pub.offset < virt_to_phys(high_memory) ) {
 			drm_free( map, sizeof(*map), DRM_MEM_MAPS );
 			return -EINVAL;
 		}
 #endif
 #ifdef __alpha__
-		map->offset += dev->hose->mem_space->start;
+		map->pub.offset += dev->hose->mem_space->start;
 #endif
 		if (drm_core_has_MTRR(dev)) {
-			if ( map->type == _DRM_FRAME_BUFFER ||
-			     (map->flags & _DRM_WRITE_COMBINING) ) {
-				map->mtrr = mtrr_add( map->offset, map->size,
+			if ( map->pub.type == _DRM_FRAME_BUFFER ||
+			     (map->pub.flags & _DRM_WRITE_COMBINING) ) {
+				map->pub.mtrr = mtrr_add( map->pub.offset, map->pub.size,
 						      MTRR_TYPE_WRCOMB, 1 );
 			}
 		}
-		if (map->type == _DRM_REGISTERS)
-			map->handle = drm_ioremap( map->offset, map->size,
+		if (map->pub.type == _DRM_REGISTERS)
+			map->handle = drm_ioremap( map->pub.offset, map->pub.size,
 						    dev );
 		break;
 
 	case _DRM_SHM:
-		map->handle = vmalloc_32(map->size);
+		map->handle = vmalloc(map->pub.size);
 		DRM_DEBUG( "%lu %d %p\n",
-			   map->size, drm_order( map->size ), map->handle );
+			   map->pub.size, drm_order( map->pub.size ), map->handle );
 		if ( !map->handle ) {
 			drm_free( map, sizeof(*map), DRM_MEM_MAPS );
 			return -ENOMEM;
 		}
-		map->offset = (unsigned long)map->handle;
-		if ( map->flags & _DRM_CONTAINS_LOCK ) {
+		map->pub.offset = (unsigned long)map->handle;
+		if ( map->pub.flags & _DRM_CONTAINS_LOCK ) {
 			/* Prevent a 2nd X Server from creating a 2nd lock */
 			if (dev->lock.hw_lock != NULL) {
 				vfree( map->handle );
@@ -158,10 +193,10 @@
 	case _DRM_AGP:
 		if (drm_core_has_AGP(dev)) {
 #ifdef __alpha__
-			map->offset += dev->hose->mem_space->start;
+			map->pub.offset += dev->hose->mem_space->start;
 #endif
-			map->offset += dev->agp->base;
-			map->mtrr   = dev->agp->agp_mtrr; /* for getmap */
+			map->pub.offset += dev->agp->base;
+			map->pub.mtrr   = dev->agp->agp_mtrr; /* for getmap */
 		}
 		break;
 	case _DRM_SCATTER_GATHER:
@@ -169,7 +204,7 @@
 			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -EINVAL;
 		}
-		map->offset += dev->sg->handle;
+		map->pub.offset += (unsigned long)dev->sg->virtual;
 		break;
 
 	default:
@@ -189,12 +224,16 @@
 	list_add(&list->head, &dev->maplist->head);
  	up(&dev->struct_sem);
 
-	if ( copy_to_user( argp, map, sizeof(*map) ) )
+	map->pub.pub_handle = HandleID(map->handle, dev);
+	DRM_DEBUG( "HandleID = 0x%lx addr = %p offset = 0x%lx\n",
+		  map->pub.pub_handle,map->handle,map->pub.offset);
+	
+	if ( copy_to_user( argp, map, sizeof(drm_map_t) ) )
 		return -EFAULT;
-	if ( map->type != _DRM_SHM ) {
-		if ( copy_to_user( &argp->handle,
-				   &map->offset,
-				   sizeof(map->offset) ) )
+	if ( map->pub.type != _DRM_SHM ) {
+		if ( copy_to_user( &argp->pub_handle,
+				   &map->pub.pub_handle,
+				   sizeof(map->pub.pub_handle) ) )
 			return -EFAULT;
 	}
 	return 0;
@@ -225,7 +264,7 @@
 	struct list_head *list;
 	drm_map_list_t *r_list = NULL;
 	drm_vma_entry_t *pt, *prev;
-	drm_map_t *map;
+	drm_map_priv_t *map;
 	drm_map_t request;
 	int found_maps = 0;
 
@@ -240,8 +279,8 @@
 		r_list = list_entry(list, drm_map_list_t, head);
 
 		if(r_list->map &&
-		   r_list->map->handle == request.handle &&
-		   r_list->map->flags & _DRM_REMOVABLE) break;
+		   r_list->map->pub.pub_handle == request.pub_handle &&
+		   r_list->map->pub.flags & _DRM_REMOVABLE) break;
 	}
 
 	/* List has wrapped around to the head pointer, or its empty we didn't
@@ -260,19 +299,19 @@
 	}
 
 	if(!found_maps) {
-		switch (map->type) {
+		switch (map->pub.type) {
 		case _DRM_REGISTERS:
 		case _DRM_FRAME_BUFFER:
 		  if (drm_core_has_MTRR(dev)) {
-				if (map->mtrr >= 0) {
+				if (map->pub.mtrr >= 0) {
 					int retcode;
-					retcode = mtrr_del(map->mtrr,
-							   map->offset,
-							   map->size);
+					retcode = mtrr_del(map->pub.mtrr,
+							   map->pub.offset,
+							   map->pub.size);
 					DRM_DEBUG("mtrr_del = %d\n", retcode);
 				}
 			}
-			drm_ioremapfree(map->handle, map->size, dev);
+			drm_ioremapfree(map->handle, map->pub.size, dev);
 			break;
 		case _DRM_SHM:
 			vfree(map->handle);
@@ -837,7 +876,8 @@
 
 		buf->offset  = (dma->byte_count + offset);
 		buf->bus_address = agp_offset + offset;
-		buf->address = (void *)(agp_offset + offset + dev->sg->handle);
+		buf->address = (void *)(agp_offset + offset 
+					+ (unsigned long)dev->sg->virtual);
 		buf->next    = NULL;
 		buf->waiting = 0;
 		buf->pending = 0;
@@ -1187,7 +1227,7 @@
 	if ( request.count >= dma->buf_count ) {
 		if ((drm_core_has_AGP(dev) && (dma->flags & _DRM_DMA_USE_AGP)) ||
 		    (drm_core_check_feature(dev, DRIVER_SG) && (dma->flags & _DRM_DMA_USE_SG)) ) {
-			drm_map_t *map = dev->agp_buffer_map;
+			drm_map_priv_t *map = dev->agp_buffer_map;
 
 			if ( !map ) {
 				retcode = -EINVAL;
@@ -1199,10 +1239,10 @@
 #else
 			down_write( &current->mm->mmap_sem );
 #endif
-			virtual = do_mmap( filp, 0, map->size,
+			virtual = do_mmap( filp, 0, map->pub.size,
 					   PROT_READ | PROT_WRITE,
 					   MAP_SHARED,
-					   (unsigned long)map->offset );
+					   (unsigned long)map->pub.pub_handle );
 #if LINUX_VERSION_CODE <= 0x020402
 			up( &current->mm->mmap_sem );
 #else
Index: drivers/char/drm/drm_context.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_context.c,v
retrieving revision 1.1.1.1
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.1 drm_context.c
--- linux/drivers/char/drm/drm_context.c	11 Jan 2005 10:26:56 -0000	1.1.1.1
+++ drivers/char/drm/drm_context.c	15 Mar 2005 18:02:52 -0000
@@ -98,7 +98,7 @@
 		if((bit+1) > dev->max_context) {
 			dev->max_context = (bit+1);
 			if(dev->context_sareas) {
-				drm_map_t **ctx_sareas;
+				drm_map_priv_t **ctx_sareas;
 
 				ctx_sareas = drm_realloc(dev->context_sareas,
 						(dev->max_context - 1) * 
@@ -211,7 +211,7 @@
 	drm_device_t	*dev	= priv->dev;
 	drm_ctx_priv_map_t __user *argp = (void __user *)arg;
 	drm_ctx_priv_map_t request;
-	drm_map_t *map;
+	drm_map_priv_t *map;
 
 	if (copy_from_user(&request, argp, sizeof(request)))
 		return -EFAULT;
@@ -225,7 +225,7 @@
 	map = dev->context_sareas[request.ctx_id];
 	up(&dev->struct_sem);
 
-	request.handle = map->handle;
+	request.handle = map->pub.pub_handle;
 	if (copy_to_user(argp, &request, sizeof(request)))
 		return -EFAULT;
 	return 0;
@@ -249,7 +249,7 @@
 	drm_file_t	*priv	= filp->private_data;
 	drm_device_t	*dev	= priv->dev;
 	drm_ctx_priv_map_t request;
-	drm_map_t *map = NULL;
+	drm_map_priv_t *map = NULL;
 	drm_map_list_t *r_list = NULL;
 	struct list_head *list;
 
@@ -262,7 +262,7 @@
 	list_for_each(list, &dev->maplist->head) {
 		r_list = list_entry(list, drm_map_list_t, head);
 		if(r_list->map &&
-		   r_list->map->handle == request.handle)
+		   r_list->map->pub.pub_handle == request.handle)
 			goto found;
 	}
 bad:
Index: drivers/char/drm/drm_drv.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_drv.c,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 drm_drv.c
--- linux/drivers/char/drm/drm_drv.c	14 Mar 2005 10:18:13 -0000	1.1.1.2
+++ drivers/char/drm/drm_drv.c	15 Mar 2005 18:02:52 -0000
@@ -133,7 +133,7 @@
 int drm_takedown( drm_device_t *dev )
 {
 	drm_magic_entry_t *pt, *next;
-	drm_map_t *map;
+	drm_map_priv_t *map;
 	drm_map_list_t *r_list;
 	struct list_head *list, *list_next;
 	drm_vma_entry_t *vma, *vma_next;
@@ -205,19 +205,19 @@
 			r_list = (drm_map_list_t *)list;
 
 			if ( ( map = r_list->map ) ) {
-				switch ( map->type ) {
+				switch ( map->pub.type ) {
 				case _DRM_REGISTERS:
 				case _DRM_FRAME_BUFFER:
 					if (drm_core_has_MTRR(dev)) {
-						if ( map->mtrr >= 0 ) {
+						if ( map->pub.mtrr >= 0 ) {
 							int retcode;
-							retcode = mtrr_del( map->mtrr,
-									    map->offset,
-									    map->size );
+							retcode = mtrr_del( map->pub.mtrr,
+									    map->pub.offset,
+									    map->pub.size );
 							DRM_DEBUG( "mtrr_del=%d\n", retcode );
 						}
 					}
-					drm_ioremapfree( map->handle, map->size, dev );
+					drm_ioremapfree( map->handle, map->pub.size, dev );
 					break;
 				case _DRM_SHM:
 					vfree(map->handle);
@@ -310,6 +310,9 @@
 			drm_probe(pdev, pid, driver);
 		}
 	}
+	if (driver->register_ioctl32)
+	driver->register_ioctl32();
+
 	return 0;
 }
 EXPORT_SYMBOL(drm_init);
@@ -348,6 +351,9 @@
 		dev->agp = NULL;
 	}
 
+	if (dev->driver->unregister_ioctl32)
+	    dev->driver->unregister_ioctl32();
+
 	if (dev->driver->postcleanup)
 		dev->driver->postcleanup(dev);
 	
Index: drivers/char/drm/drm_ioctl.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_ioctl.c,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 drm_ioctl.c
--- linux/drivers/char/drm/drm_ioctl.c	14 Mar 2005 10:18:13 -0000	1.1.1.2
+++ drivers/char/drm/drm_ioctl.c	15 Mar 2005 18:02:52 -0000
@@ -175,7 +175,7 @@
 	drm_file_t   *priv = filp->private_data;
 	drm_device_t *dev  = priv->dev;
 	drm_map_t    __user *argp = (void __user *)arg;
-	drm_map_t    map;
+	drm_map_priv_t    map;
 	drm_map_list_t *r_list = NULL;
 	struct list_head *list;
 	int          idx;
@@ -183,7 +183,7 @@
 
 	if (copy_from_user(&map, argp, sizeof(map)))
 		return -EFAULT;
-	idx = map.offset;
+	idx = map.pub.offset;
 
 	down(&dev->struct_sem);
 	if (idx < 0) {
@@ -204,12 +204,12 @@
 		return -EINVAL;
 	}
 
-	map.offset = r_list->map->offset;
-	map.size   = r_list->map->size;
-	map.type   = r_list->map->type;
-	map.flags  = r_list->map->flags;
-	map.handle = r_list->map->handle;
-	map.mtrr   = r_list->map->mtrr;
+	map.pub.offset = r_list->map->pub.offset;
+	map.pub.size   = r_list->map->pub.size;
+	map.pub.type   = r_list->map->pub.type;
+	map.pub.flags  = r_list->map->pub.flags;
+	map.pub.pub_handle = r_list->map->pub.pub_handle;
+	map.pub.mtrr   = r_list->map->pub.mtrr;
 	up(&dev->struct_sem);
 
 	if (copy_to_user(argp, &map, sizeof(map))) return -EFAULT;
Index: drivers/char/drm/drm_ioctl32.c
===================================================================
RCS file: drivers/char/drm/drm_ioctl32.c
diff -N drivers/char/drm/drm_ioctl32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ drivers/char/drm/drm_ioctl32.c	15 Mar 2005 18:02:52 -0000
@@ -0,0 +1,1109 @@
+/*
+ * Copyright 2003, 2004, Egbert Eich
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * EGBERT EICH BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CON-
+ * NECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Egbert Eich shall not
+ * be used in advertising or otherwise to promote the sale, use or other deal-
+ *ings in this Software without prior written authorization from Egbert Eich.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#if 0
+#include <linux/wrapper.h>
+#else
+#include <linux/syscalls.h>
+#endif
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+
+#ifdef __x86_64__
+
+#include <asm/ioctl32.h>
+#include "drm.h"
+#define IOCTL32_PRIVATE
+#include "drm_ioctl32.h"
+
+
+MODULE_AUTHOR( "Egbert Eich, eich@suse.de" );
+MODULE_DESCRIPTION( "DRM ioctl32 translations" );
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL and additional rights");
+#endif
+
+#define DRM_IOCTL_VERSION_32		DRM_IOWR(0x00, drm32_version_t)
+#define DRM_IOCTL_GET_UNIQUE_32		DRM_IOWR(0x01, drm32_unique_t)
+#define DRM_IOCTL_GET_MAP_32            DRM_IOWR(0x04, drm32_map_t)
+#define DRM_IOCTL_GET_CLIENT_32         DRM_IOWR(0x05, drm32_client_t)
+#define DRM_IOCTL_GET_STATS_32          DRM_IOR( 0x06, drm32_stats_t)
+#define DRM_IOCTL_SET_UNIQUE_32		DRM_IOW( 0x10, drm32_unique_t)
+#define DRM_IOCTL_ADD_MAP_32		DRM_IOWR(0x15, drm32_map_t)
+#define DRM_IOCTL_ADD_BUFS_32		DRM_IOWR(0x16, drm32_buf_desc_t)
+#define DRM_IOCTL_MARK_BUFS_32		DRM_IOW( 0x17, drm32_buf_desc_t)
+#define DRM_IOCTL_INFO_BUFS_32		DRM_IOWR(0x18, drm32_buf_info_t)
+#define DRM_IOCTL_MAP_BUFS_32		DRM_IOWR(0x19, drm32_buf_map_t)
+#define DRM_IOCTL_FREE_BUFS_32		DRM_IOW( 0x1a, drm32_buf_free_t)
+#define DRM_IOCTL_RM_MAP_32		DRM_IOW( 0x1b, drm32_map_t)
+#if 0
+#define DRM_IOCTL_SET_SAREA_CTX_32	DRM_IOW( 0x1c, drm32_ctx_priv_map_t)
+#define DRM_IOCTL_GET_SAREA_CTX_32 	DRM_IOWR(0x1d, drm32_ctx_priv_map_t)
+#endif
+#define DRM_IOCTL_RES_CTX_32		DRM_IOWR(0x26, drm32_ctx_res_t)
+#define DRM_IOCTL_DMA_32		DRM_IOWR(0x29, drm32_dma_t)
+#define DRM_IOCTL_AGP_ENABLE_32		DRM_IOW( 0x32, drm32_agp_mode_t)
+#define DRM_IOCTL_AGP_INFO_32		DRM_IOR( 0x33, drm32_agp_info_t)
+#define DRM_IOCTL_AGP_ALLOC_32		DRM_IOWR(0x34, drm32_agp_buffer_t)
+#define DRM_IOCTL_AGP_FREE_32		DRM_IOW( 0x35, drm32_agp_buffer_t)
+#define DRM_IOCTL_AGP_BIND_32		DRM_IOW( 0x36, drm32_agp_binding_t)
+#define DRM_IOCTL_AGP_UNBIND_32		DRM_IOW( 0x37, drm32_agp_binding_t)
+#define DRM_IOCTL_SG_ALLOC_32		DRM_IOW( 0x38, drm32_scatter_gather_t)
+#define DRM_IOCTL_SG_FREE_32		DRM_IOW( 0x39, drm32_scatter_gather_t)
+#define DRM_IOCTL_WAIT_VBLANK_32	DRM_IOWR(0x3a, drm32_wait_vblank_t)
+
+typedef struct drm32_version {  /* OK */
+	int            version_major;	  /* Major version		   */
+	int            version_minor;	  /* Minor version	           */
+	int            version_patchlevel;/* Patch level		   */
+	unsigned int   name_len;	  /* Length of name buffer         */
+	u32    name;		          /* Name of driver		   */
+	unsigned int   date_len;	  /* Length of date buffer	   */
+	u32    date;		          /* User-space buffer to hold date*/
+	unsigned int   desc_len;          /* Length of desc buffer	   */
+	u32    desc;		          /* User-space buffer to hold desc*/
+} drm32_version_t;
+
+typedef struct drm32_unique {  /* OK */
+	unsigned int   unique_len;/* Length of unique			    */
+	u32    unique;		  /* Unique name for driver instantiation   */
+} drm32_unique_t;
+
+typedef struct drm32_client {
+	int		idx;	/* Which client desired?                    */
+	int		auth;	/* Is client authenticated?                 */
+/*?*/	unsigned int	pid;	/* Process id                               */
+/*?*/	unsigned int	uid;	/* User id                                  */
+/*?*/	unsigned int	magic;	/* Magic                                    */
+/*?*/	unsigned int	iocs;	/* Ioctl count                              */
+} drm32_client_t;
+
+#if 0
+typedef struct drm32_ctx_priv_map {
+	unsigned int	ctx_id;  /* Context requesting private mapping */
+/*?*/	u32		handle;  /* Handle of map */
+} drm32_ctx_priv_map_t;
+#endif
+
+typedef struct drm32_buf_desc { /* OK */
+	int	      count;	 /* Number of buffers of this size	     */
+	int	      size;	 /* Size in bytes			     */
+	int	      low_mark;	 /* Low water mark			     */
+	int	      high_mark; /* High water mark			     */
+	int	      flags;
+/*?*/	unsigned int agp_start; /* Start address of where the agp buffers
+				  * are in the agp aperture */
+} drm32_buf_desc_t;
+
+typedef struct drm32_buf_info { /* OK */
+	int	       count;	/* Entries in list			     */
+  	u32            list;
+} drm32_buf_info_t;
+
+typedef struct drm32_buf_pub { /* OK (see drm32_buf_map) */
+	int		  idx;	       /* Index into master buflist	     */
+	int		  total;       /* Buffer size			     */
+	int		  used;	       /* Amount of buffer in use (for DMA)  */
+  	u32		  address;     /* Address of buffer		     */
+} drm32_buf_pub_t;
+
+typedef struct drm32_buf_map { /*OK (if do_mmap works correctly) */
+	int	      count;	/* Length of buflist			    */
+  	u32	      virtual;	/* Mmaped area in user-virtual		    */
+  	u32           list;	/* Buffer information			    */
+} drm32_buf_map_t;
+
+typedef struct drm32_buf_free { /* OK (see above) */
+	int	       count;
+  	u32	       list;
+} drm32_buf_free_t;
+
+typedef struct drm32_stats {
+/*?*/	unsigned int count;
+	struct {
+		unsigned int   value;
+		drm_stat_type_t type;
+	} data[15];
+} drm32_stats_t;
+
+typedef struct drm32_map {
+/*?*/	unsigned int	offset;	 /* Requested physical address (0 for SARA)*/
+/*?*/	unsigned int	size;	 /* Requested physical size (bytes)	    */
+	drm_map_type_t	type;	 /* Type of memory to map		    */
+	drm_map_flags_t flags;	 /* Flags				    */
+        unsigned long	pub_handle; /* User-space: "Handle" to pass to mmap    */
+	int		mtrr;	 /* MTRR slot used			    */
+				 /* Private data			    */
+} drm32_map_t;
+
+typedef struct drm32_ctx_res { /* OK */
+	int		count;
+  	u32		contexts;
+} drm32_ctx_res_t;
+
+typedef struct drm32_dma { /* should be OK */
+				/* Indices here refer to the offset into
+				   buflist in drm_buf_get_t.  */
+	int		context;	  /* Context handle		    */
+	int		send_count;	  /* Number of buffers to send	    */
+  	u32		send_indices;	  /* List of handles to buffers	    */
+  	u32		send_sizes;	  /* Lengths of data to send	    */
+	drm_dma_flags_t flags;		  /* Flags			    */
+	int		request_count;	  /* Number of buffers requested    */
+	int		request_size;	  /* Desired size for buffers	    */
+  	u32		request_indices; /* Buffer information		    */
+  	u32		request_sizes;
+	int		granted_count;	  /* Number of buffers granted	    */
+} drm32_dma_t;
+
+typedef struct drm32_agp_buffer {
+/*?*/	int	 size;
+/*?*/	int	 handle;
+/*?*/	int	 type; 
+/*?*/   int      physical; 
+} drm32_agp_buffer_t;
+
+typedef struct drm32_agp_info {
+	int            agp_version_major;
+	int            agp_version_minor;
+/*?*/	unsigned int   mode;
+/*?*/	unsigned int   aperture_base;  /* physical address */
+/*?*/	unsigned int   aperture_size;  /* bytes */
+/*?*/	unsigned int   memory_allowed; /* bytes */
+/*?*/	unsigned int   memory_used;
+
+				/* PCI information */
+	unsigned short id_vendor;
+	unsigned short id_device;
+} drm32_agp_info_t;
+
+typedef struct drm32_agp_mode {
+/*?*/	unsigned int mode;
+} drm32_agp_mode_t;
+
+typedef struct drm32_agp_binding {
+/*?*/	unsigned int handle;   /* From drm_agp_buffer */
+/*?*/	unsigned int offset;	/* In bytes -- will round to page boundary */
+} drm32_agp_binding_t;
+
+typedef struct drm32_scatter_gather {
+/*?*/	unsigned int size;	/* In bytes -- will round to page boundary */
+/*?*/	unsigned int handle;	/* Used for mapping / unmapping */
+} drm32_scatter_gather_t;
+
+struct drm32_wait_vblank_request {
+        drm_vblank_seq_type_t type;
+        unsigned int sequence;
+        unsigned int signal;
+};
+
+struct drm32_wait_vblank_reply {
+        drm_vblank_seq_type_t type;
+        unsigned int sequence;
+        int tval_sec;
+        int tval_usec;
+};
+
+typedef union drm32_wait_vblank {
+        struct drm32_wait_vblank_request request;
+        struct drm32_wait_vblank_reply reply;
+} drm32_wait_vblank_t;
+
+static void drm_unregister_ioctl32(void);
+
+static int    ioctl_conversions_successful = 0;
+
+static int
+drm_version_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_version_t *arg32 = (drm32_version_t *) arg;
+    drm_version_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("drm_version_32_64");
+    GET_USER(version_major);
+    GET_USER(version_minor);
+    GET_USER(version_patchlevel);
+    GET_USER(name_len);
+    GET_USER_P(name);
+    GET_USER(date_len);
+    GET_USER_P(date);
+    GET_USER(desc_len);
+    GET_USER_P(desc);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    if (err) return err;
+    
+    PUT_USER(version_major);
+    PUT_USER(version_minor);
+    PUT_USER(version_patchlevel);
+    PUT_USER(name_len);
+//  PUT_USER(name);
+    PUT_USER(date_len);
+//  PUT_USER(date);
+    PUT_USER(desc_len);
+//  PUT_USER(desc);
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_unique_wr_32_64(unsigned int fd, unsigned cmd, 
+		    unsigned long arg, struct file *file)
+{
+    drm32_unique_t *arg32 = (drm32_unique_t *) arg;
+    drm_unique_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("drm_unique_wr_32_64");
+    GET_USER(unique_len);
+    GET_USER_P(unique);
+    
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    if (err) return err;
+    
+    PUT_USER(unique_len);
+//  PUT_USER(unique);
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_unique_w_32_64(unsigned int fd, unsigned int cmd, 
+		   unsigned long arg, struct file *file)
+{
+    drm32_unique_t *arg32 = (drm32_unique_t *) arg;
+    drm_unique_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("drm_unique_w_32_64");
+    GET_USER(unique_len);
+    GET_USER_P(unique);
+    
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    DEBUG("done");
+    return err;
+}
+
+static int
+drm_map_rw_32_64(unsigned int fd, unsigned int cmd, 
+		 unsigned long arg, struct file *file)
+{
+    drm32_map_t *arg32 = (drm32_map_t *) arg;
+    drm_map_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+//  u64 dummy;
+
+    DEBUG("drm_map_rw_32_64");
+    GET_USER(offset);
+    GET_USER(size);
+    GET_USER(type);
+    GET_USER(flags);
+//  GET_USER(pub_handle);
+    GET_USER(mtrr);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+
+    if (err) return err;
+    
+    ASSERT32(offset);
+    PUT_USER(offset);
+    ASSERT32(size);
+    PUT_USER(size);
+    PUT_USER(type);
+    PUT_USER(flags);
+    PUT_USER(pub_handle);
+    PUT_USER(mtrr);
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_map_w_32_64(unsigned int fd, unsigned int cmd, 
+		unsigned long arg, struct file *file)
+{
+    drm32_map_t *arg32 = (drm32_map_t *) arg;
+    drm_map_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+//  u64 dummy;
+    
+    DEBUG("drm_map_w_32_64");
+    GET_USER(offset);
+    GET_USER(size);
+    GET_USER(type);
+    GET_USER(flags);
+//  GET_USER_P(handle);
+    GET_USER(mtrr);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    DEBUG("done");
+    return err;
+}
+
+static int
+drm_client_32_64(unsigned int fd, unsigned int cmd, 
+		 unsigned long arg, struct file *file)
+{
+    drm32_client_t *arg32 = (drm32_client_t *) arg;
+    drm_client_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_client_32_64");
+    GET_USER(idx);
+//  GET_USER(auth);
+//  GET_USER(pid);
+//  GET_USER(uid);
+//  GET_USER(magic);
+//  GET_USER(iocs);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    if (err) return err;
+    
+//  PUT_USER(idx);
+    PUT_USER(auth);
+    ASSERT32(pid);
+    PUT_USER(pid);
+    ASSERT32(uid);
+    PUT_USER(uid);
+    ASSERT32(magic);
+    PUT_USER(magic);
+    ASSERT32(iocs);
+    PUT_USER(iocs);
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_stats_32_64(unsigned int fd, unsigned int cmd, 
+		unsigned long arg, struct file *file)
+{
+    drm32_stats_t *arg32 = (drm32_stats_t *) arg;
+    drm_stats_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    int i;
+
+    DEBUG("drm_stats_32_64");
+    SYS_IOCTL;    
+    if (err) return err;
+    
+    PUT_USER(count);
+    for (i = 0; i < arg64.count; i ++) {
+	PUT_USER(data[i].value);
+	PUT_USER(data[i].type);
+    }
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+#if 0
+static int
+drm_ctx_priv_map_wr_32_64(unsigned int fd, unsigned int cmd, 
+			  unsigned long arg, struct file *file)
+{
+    drm32_ctx_priv_map_t *arg32 = (drm32_ctx_priv_map_t *) arg;
+    drm_ctx_priv_map_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("drm_ctx_priv_map_wr_32_64");
+    GET_USER(ctx_id);
+//    GET_USER_P(handle);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    if (err) return err;
+    
+//    PUT_USER(ctx_id);
+    PUT_USER_P(handle);
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_ctx_priv_map_w_32_64(unsigned int fd, unsigned int cmd, 
+			 unsigned long arg, struct file *file)
+{
+    drm32_ctx_priv_map_t *arg32 = (drm32_ctx_priv_map_t *) arg;
+    drm_ctx_priv_map_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("drm_ctx_priv_map_w_32_64");
+    GET_USER(ctx_id);
+    GET_USER_P(handle);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+
+    DEBUG("done");
+    return err;
+}
+#endif
+
+static int
+drm_ctx_res_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_ctx_res_t *arg32 = (drm32_ctx_res_t *) arg;
+    drm_ctx_res_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("drm_ctx_res_32_64");
+    GET_USER(count);
+    GET_USER_P(contexts);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    if (err) return err;
+    
+    PUT_USER(count);
+//    PUT_USER(contexts);
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+
+static int
+drm_dma_32_64(unsigned int fd, unsigned int cmd, 
+	      unsigned long arg, struct file *file)
+{
+    drm32_dma_t *arg32 = (drm32_dma_t *) arg;
+    drm_dma_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+    
+    DEBUG("drm_dma_32_64");
+    GET_USER(context);
+    GET_USER(send_count);
+    GET_USER_P(send_indices);
+    GET_USER_P(send_sizes);
+    GET_USER(flags);
+    GET_USER(request_count);
+    GET_USER(request_size);
+    GET_USER_P(request_indices);
+    GET_USER_P(request_sizes);
+    GET_USER(granted_count);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    if (err) return err;
+    
+    PUT_USER(context);
+    PUT_USER(send_count);
+//  PUT_USER(send_indices);
+//  PUT_USER(send_sizes);
+    PUT_USER(flags);
+    PUT_USER(request_count);
+    PUT_USER(request_size);
+//    PUT_USER(request_indices);
+//    PUT_USER(request_sizes);
+    PUT_USER(granted_count);
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_buf_desc_wr_32_64(unsigned int fd, unsigned int cmd, 
+		      unsigned long arg, struct file *file)
+{
+    drm32_buf_desc_t *arg32 = (drm32_buf_desc_t *) arg;
+    drm_buf_desc_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_buf_desc_wr_32_64");
+    GET_USER(count);
+    GET_USER(size);
+    GET_USER(low_mark);
+    GET_USER(high_mark);
+    GET_USER(flags);
+    GET_USER(agp_start);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    if (err) return err;
+    
+    PUT_USER(count);
+    PUT_USER(size);
+//   PUT_USER(low_mark);
+//   PUT_USER(high_mark);
+//   PUT_USER(flags);
+//   PUT_USER(agp_start);
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_buf_desc_w_32_64(unsigned int fd, unsigned int cmd,
+		     unsigned long arg, struct file *file)
+{
+    drm32_buf_desc_t *arg32 = (drm32_buf_desc_t *) arg;
+    drm_buf_desc_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_buf_desc_w_32_64");
+    GET_USER(count);
+    GET_USER(size);
+    GET_USER(low_mark);
+    GET_USER(high_mark);
+    GET_USER(flags);
+    GET_USER(agp_start);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+
+    DEBUG("done");
+    return err;
+}
+
+static int
+drm_buf_info_32_64(unsigned int fd, unsigned int cmd, 
+		   unsigned long arg, struct file *file)
+{
+    drm32_buf_info_t *arg32 = (drm32_buf_info_t *) arg;
+    drm_buf_info_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    drm32_buf_desc_t *list32 = (drm32_buf_desc_t*)(u64)arg32->list;
+    drm_buf_desc_t *list64;
+    int i;
+    
+    DEBUG("drm_buf_info_32_64");
+    list64 = K_ALLOC(arg32->count * sizeof (drm_buf_desc_t));
+    if (!list64) return -EFAULT;
+    
+    GET_USER(count);
+    arg64.list = list64;
+    
+    for (i = 0 ; i < arg32->count; i ++) {
+	err |= get_user(list64[i].count,&list32[i].count);
+	err |= get_user(list64[i].size,&list32[i].size);
+	err |= get_user(list64[i].high_mark,&list32[i].low_mark);
+	err |= get_user(list64[i].flags,&list32[i].flags);
+	err |= get_user(list64[i].agp_start,&list32[i].agp_start);
+    }
+    
+    if (err) {
+	K_FREE(list64);
+	return -EFAULT;
+    }
+    
+    SYS_IOCTL;    
+    if (err) {
+	K_FREE(list64);
+	return err;
+    }
+    
+    
+    for (i = 0 ; i < arg32->count; i ++) {
+	err |= put_user(list64[i].count,&list32[i].count);
+	err |= put_user(list64[i].size,&list32[i].size);
+	err |= put_user(list64[i].low_mark,&list32[i].low_mark);
+	err |= put_user(list64[i].high_mark,&list32[i].high_mark);
+	err |= put_user(list64[i].flags,&list32[i].flags);
+//	err |= put_user(list64[i].agp_start,&list32[i].agp_start);
+    }
+    PUT_USER(count);
+
+    K_FREE(list64);
+
+    DEBUG("done");
+    return err ? -EFAULT : 0;
+}
+
+
+static int
+drm_buf_map_32_64(unsigned int fd, unsigned cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_buf_map_t *arg32 = (drm32_buf_map_t *) arg;
+    drm_buf_map_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    drm32_buf_pub_t *list32 = (drm32_buf_pub_t*)(unsigned long)arg32->list;
+    drm_buf_pub_t *list64;
+    int count, i;
+    u64 dummy;
+    
+    DEBUG("drm_buf_map_32_64");
+    list64 = K_ALLOC(arg32->count * sizeof (drm_buf_pub_t));
+    if (!list64) return -EFAULT;
+    
+    GET_USER(count);
+    GET_USER_P(virtual);
+    arg64.list = list64;
+#if 0
+    for (i = 0 ; i < arg32->count; i ++) {
+	err |= get_user(list64[i].idx,&list32[i].idx);
+	err |= get_user(list64[i].total,&list32[i].total);
+	err |= get_user(list64[i].used,&list32[i].used);
+	err |= get_user(dummy,&list32[i].address);
+	list64[i].address = (void *)dummy;
+    }
+#endif
+    if (err) {
+	K_FREE(list64);
+	return -EFAULT;
+    }
+    
+    SYS_IOCTL;    
+    if (err) {
+	K_FREE(list64);
+	return err;
+    }
+    
+    count = arg32->count < arg64.count ? arg32->count : arg64.count;
+    PUT_USER(count);
+    PUT_USER_P(virtual);
+
+    for (i = 0 ; i < count; i ++) {
+	err |= put_user(list64[i].idx,&list32[i].idx);
+	err |= put_user(list64[i].total,&list32[i].total);
+	err |= put_user(list64[i].used,&list32[i].used);
+	dummy = (u64)list64[i].address;
+	err |= put_user((u32)dummy,&list32[i].address);
+    }
+    K_FREE(list64);
+
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_buf_free_w_32_64(unsigned int fd, unsigned int cmd, 
+		     unsigned long arg, struct file *file)
+{
+    drm32_buf_free_t *arg32 = (drm32_buf_free_t *) arg;
+    drm_buf_free_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    int i;
+    int *list32 = (int *)(unsigned long)arg32->list;
+
+    DEBUG("drm_buf_free_w_32_64");
+    GET_USER(count);
+    for (i = 0; i < arg32->count; i++)
+	err |= get_user(arg64.list[i],&list32[i]);
+	
+    
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+
+    DEBUG("done");
+    return err;
+}
+
+static int
+drm_agp_info_32_64(unsigned int fd, unsigned int cmd, 
+		      unsigned long arg, struct file *file)
+{
+    drm32_agp_info_t *arg32 = (drm32_agp_info_t *) arg;
+    drm_agp_info_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_agp_info_32_64");
+    
+    SYS_IOCTL;    
+    if (err) return err;
+    
+    PUT_USER(agp_version_major);
+    PUT_USER(agp_version_minor);
+    PUT_USER(mode);
+    ASSERT32(aperture_base);
+    PUT_USER(aperture_base);
+    ASSERT32(aperture_size);
+    PUT_USER(aperture_size);
+    ASSERT32(memory_allowed);
+    PUT_USER(memory_allowed);
+    ASSERT32(memory_used);
+    PUT_USER(memory_used);
+    PUT_USER(id_vendor);
+    PUT_USER(id_device);
+
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_agp_buffer_w_32_64(unsigned int fd, unsigned int cmd, 
+		      unsigned long arg, struct file *file)
+{
+    drm32_agp_buffer_t *arg32 = (drm32_agp_buffer_t *) arg;
+    drm_agp_buffer_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_agp_buffer_w_32_64");
+    GET_USER(handle);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    return err;
+}
+
+static int
+drm_agp_buffer_32_64(unsigned int fd, unsigned int cmd, 
+		      unsigned long arg, struct file *file)
+{
+    drm32_agp_buffer_t *arg32 = (drm32_agp_buffer_t *) arg;
+    drm_agp_buffer_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_agp_buffer_32_64");
+    GET_USER(size);
+    GET_USER(handle);
+    GET_USER(type);
+    GET_USER(physical);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    if (err) return err;
+    
+    ASSERT32(size);
+    PUT_USER(size);
+    ASSERT32(handle);
+    PUT_USER(handle);
+    ASSERT32(type);
+    PUT_USER(type);
+//    PUT_USER(physical);
+
+    return err ? -EFAULT : 0;
+}
+
+static int
+drm_agp_mode_w_32_64(unsigned int fd, unsigned int cmd, 
+		      unsigned long arg, struct file *file)
+{
+    drm32_agp_mode_t *arg32 = (drm32_agp_mode_t *) arg;
+    drm_agp_mode_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_agp_mode_w_32_64");
+    GET_USER(mode);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+
+    return err;
+}
+
+static int
+drm_agp_binding_w_32_64(unsigned int fd, unsigned int cmd, 
+		      unsigned long arg, struct file *file)
+{
+    drm32_agp_binding_t *arg32 = (drm32_agp_binding_t *) arg;
+    drm_agp_binding_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_agp_binding_w_32_64");
+    GET_USER(handle);
+    GET_USER(offset);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+
+    return err;
+}
+
+static int
+drm32_scatter_gather_w_32_64(unsigned int fd, unsigned int cmd, 
+		      unsigned long arg, struct file *file)
+{
+    drm32_scatter_gather_t *arg32 = (drm32_scatter_gather_t *) arg;
+    drm_scatter_gather_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_agp_scatter_gather_w_32_64");
+
+    GET_USER(size);
+    GET_USER(handle);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+
+    return err;
+}
+
+static int
+drm32_wait_vblank_rw_32_64(unsigned int fd, unsigned int cmd, 
+		      unsigned long arg, struct file *file)
+{
+    drm32_wait_vblank_t *arg32 = (drm32_wait_vblank_t *) arg;
+    drm_wait_vblank_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("drm_agp_scatter_gather_rw_32_64");
+
+    err |= get_user(arg64.request.type,&arg32->request.type);
+    err |= get_user(arg64.request.sequence,&arg32->request.sequence);
+    err |= get_user(arg64.request.signal,&arg32->request.signal);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+
+    err |= put_user(arg64.reply.type,&arg32->reply.type);
+    err |= put_user(arg64.reply.sequence,&arg32->reply.sequence);
+    ASSERT32(reply.tval_sec);
+    err |= put_user(arg64.reply.tval_sec,&arg32->reply.tval_sec);
+    ASSERT32(reply.tval_usec);
+    err |= put_user(arg64.reply.tval_usec,&arg32->reply.tval_usec);
+
+    return err ? -EFAULT : 0;
+}
+
+int
+drm32_default_handler(unsigned int fd, unsigned int cmd, 
+		     unsigned long arg, struct file *file)
+{
+    return SYS_IOCTL_FUNC(fd,cmd,arg);
+}
+
+
+static int
+drm_register_ioctl32(void)
+{
+    int err;
+    REG_IOCTL32(DRM_IOCTL_VERSION_32,drm_version_32_64);
+    REG_IOCTL32(DRM_IOCTL_GET_UNIQUE_32,drm_unique_wr_32_64);
+    REG_IOCTL32(DRM_IOCTL_GET_MAP_32,drm_map_rw_32_64);
+    REG_IOCTL32(DRM_IOCTL_GET_CLIENT_32,drm_client_32_64);
+    REG_IOCTL32(DRM_IOCTL_GET_STATS_32,drm_stats_32_64);
+    REG_IOCTL32(DRM_IOCTL_SET_UNIQUE_32,drm_unique_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_ADD_MAP_32,drm_map_rw_32_64);
+    REG_IOCTL32(DRM_IOCTL_ADD_BUFS_32,drm_buf_desc_wr_32_64);
+    REG_IOCTL32(DRM_IOCTL_MARK_BUFS_32,drm_buf_desc_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_INFO_BUFS_32,drm_buf_info_32_64);
+    REG_IOCTL32(DRM_IOCTL_MAP_BUFS_32,drm_buf_map_32_64);
+    REG_IOCTL32(DRM_IOCTL_FREE_BUFS_32,drm_buf_free_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_RM_MAP_32,drm_map_w_32_64);
+#if 0
+    REG_IOCTL32(DRM_IOCTL_SET_SAREA_CTX_32,drm_ctx_priv_map_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_GET_SAREA_CTX_32,drm_ctx_priv_map_wr_32_64);
+#endif
+    REG_IOCTL32(DRM_IOCTL_RES_CTX_32,drm_ctx_res_32_64)
+    REG_IOCTL32(DRM_IOCTL_DMA_32,drm_dma_32_64);
+    REG_IOCTL32(DRM_IOCTL_AGP_ENABLE_32,drm_agp_mode_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_AGP_INFO_32,drm_agp_info_32_64);
+    REG_IOCTL32(DRM_IOCTL_AGP_ALLOC_32,drm_agp_buffer_32_64);
+    REG_IOCTL32(DRM_IOCTL_AGP_FREE_32,drm_agp_buffer_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_AGP_BIND_32,drm_agp_binding_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_AGP_UNBIND_32,drm_agp_binding_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_SG_ALLOC_32,drm32_scatter_gather_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_SG_FREE_32,drm32_scatter_gather_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_WAIT_VBLANK_32,drm32_wait_vblank_rw_32_64);
+    REG_IOCTL32(DRM_IOCTL_GET_MAGIC,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_IRQ_BUSID,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_SET_VERSION,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_AUTH_MAGIC,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_BLOCK,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_UNBLOCK,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_CONTROL,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_SET_SAREA_CTX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_GET_SAREA_CTX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_ADD_CTX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RM_CTX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_MOD_CTX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_GET_CTX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_SWITCH_CTX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_NEW_CTX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_ADD_DRAW,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RM_DRAW,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_LOCK,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_UNLOCK,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_FINISH,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_AGP_ACQUIRE,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_AGP_RELEASE,drm32_default_handler);
+
+    ioctl_conversions_successful = 1;
+    
+    return 0;
+ failed:
+    return -1;
+}
+
+
+static void
+drm_unregister_ioctl32(void)
+{
+    UNREG_IOCTL32(DRM_IOCTL_VERSION_32);
+    UNREG_IOCTL32(DRM_IOCTL_GET_UNIQUE_32);
+    UNREG_IOCTL32(DRM_IOCTL_GET_CLIENT_32);
+#if 0
+    UNREG_IOCTL32(DRM_IOCTL_SET_SAREA_CTX_32);
+    UNREG_IOCTL32(DRM_IOCTL_GET_SAREA_CTX_32);
+#endif
+    UNREG_IOCTL32(DRM_IOCTL_RES_CTX_32);
+    UNREG_IOCTL32(DRM_IOCTL_DMA_32);
+    
+    UNREG_IOCTL32(DRM_IOCTL_INFO_BUFS_32);
+    UNREG_IOCTL32(DRM_IOCTL_MAP_BUFS_32);
+    UNREG_IOCTL32(DRM_IOCTL_FREE_BUFS_32);
+
+    UNREG_IOCTL32(DRM_IOCTL_GET_MAP_32);
+    UNREG_IOCTL32(DRM_IOCTL_GET_STATS_32);
+    UNREG_IOCTL32(DRM_IOCTL_SET_UNIQUE_32);
+    UNREG_IOCTL32(DRM_IOCTL_ADD_MAP_32);
+    UNREG_IOCTL32(DRM_IOCTL_RM_MAP_32);
+    UNREG_IOCTL32(DRM_IOCTL_ADD_BUFS_32);
+    UNREG_IOCTL32(DRM_IOCTL_MARK_BUFS_32);
+    UNREG_IOCTL32(DRM_IOCTL_AGP_ALLOC_32);
+    UNREG_IOCTL32(DRM_IOCTL_AGP_FREE_32);
+    UNREG_IOCTL32(DRM_IOCTL_AGP_INFO_32);
+    UNREG_IOCTL32(DRM_IOCTL_AGP_ENABLE_32);
+    UNREG_IOCTL32(DRM_IOCTL_AGP_BIND_32);
+    UNREG_IOCTL32(DRM_IOCTL_AGP_UNBIND_32);
+    UNREG_IOCTL32(DRM_IOCTL_SG_ALLOC_32);
+    UNREG_IOCTL32(DRM_IOCTL_SG_FREE_32);
+    UNREG_IOCTL32(DRM_IOCTL_WAIT_VBLANK_32);
+
+    UNREG_IOCTL32(DRM_IOCTL_SET_SAREA_CTX);
+    UNREG_IOCTL32(DRM_IOCTL_GET_SAREA_CTX);
+    UNREG_IOCTL32(DRM_IOCTL_GET_MAGIC);
+    UNREG_IOCTL32(DRM_IOCTL_IRQ_BUSID);
+    UNREG_IOCTL32(DRM_IOCTL_SET_VERSION);
+    UNREG_IOCTL32(DRM_IOCTL_BLOCK);
+    UNREG_IOCTL32(DRM_IOCTL_UNBLOCK);
+    UNREG_IOCTL32(DRM_IOCTL_AUTH_MAGIC);
+    UNREG_IOCTL32(DRM_IOCTL_ADD_CTX);
+    UNREG_IOCTL32(DRM_IOCTL_RM_CTX);
+    UNREG_IOCTL32(DRM_IOCTL_MOD_CTX);
+    UNREG_IOCTL32(DRM_IOCTL_GET_CTX);
+    UNREG_IOCTL32(DRM_IOCTL_SWITCH_CTX);
+    UNREG_IOCTL32(DRM_IOCTL_NEW_CTX);
+    UNREG_IOCTL32(DRM_IOCTL_ADD_DRAW);
+    UNREG_IOCTL32(DRM_IOCTL_RM_DRAW);
+    UNREG_IOCTL32(DRM_IOCTL_LOCK);
+    UNREG_IOCTL32(DRM_IOCTL_UNLOCK);
+    UNREG_IOCTL32(DRM_IOCTL_FINISH);
+    UNREG_IOCTL32(DRM_IOCTL_CONTROL);
+    UNREG_IOCTL32(DRM_IOCTL_AGP_ACQUIRE);
+    UNREG_IOCTL32(DRM_IOCTL_AGP_RELEASE);
+}
+
+int
+drm32_register(void)
+{
+    if (ioctl_conversions_successful == 0)
+	return 0;
+#if 0 && defined(MODULE)
+    MOD_INC_USE_COUNT;
+#endif
+	return 1;
+}
+
+void
+drm32_unregister(void)
+{
+#if 0 && defined(MODULE)
+    if (ioctl_conversions_successful == 0)
+	return;
+    MOD_DEC_USE_COUNT;
+#endif
+	return;
+}
+
+static int
+__init drm32_init( void )
+{
+    return drm_register_ioctl32();
+}
+
+static void
+__exit drm32_cleanup (void)
+{
+    drm_unregister_ioctl32();
+}
+
+
+module_init(drm32_init);
+module_exit(drm32_cleanup);
+
+EXPORT_SYMBOL(drm32_register);
+EXPORT_SYMBOL(drm32_unregister);
+EXPORT_SYMBOL(drm32_default_handler);
+
+#endif
Index: drivers/char/drm/drm_ioctl32.h
===================================================================
RCS file: drivers/char/drm/drm_ioctl32.h
diff -N drivers/char/drm/drm_ioctl32.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ drivers/char/drm/drm_ioctl32.h	15 Mar 2005 18:02:52 -0000
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2003, 2004, Egbert Eich
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * EGBERT EICH BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CON-
+ * NECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Egbert Eich shall not
+ * be used in advertising or otherwise to promote the sale, use or other deal-
+ *ings in this Software without prior written authorization from Egbert Eich.
+ *
+ */
+#ifndef _DRM_IOCTL32_H
+# define _DRM_IOCTL32_H
+
+# ifdef IOCTL32_PRIVATE
+
+#define DEBUG(x) /**/ /* printk(KERN_DEBUG"%s\n",x) */
+
+#define SYS_IOCTL_FUNC sys_ioctl
+
+#  define GET_USER_ARGS(x32,x64,elem) err |= get_user(x64.elem,&x32->elem)
+#  define PUT_USER_ARGS(x32,x64,elem) err |= put_user(x64.elem,&x32->elem)
+#  define GET_USER(elem) GET_USER_ARGS(arg32,arg64,elem)
+#  define PUT_USER(elem) PUT_USER_ARGS(arg32,arg64,elem)
+#  define GET_USER_P_ARGS(x32,x64,elem) do { \
+    err |= get_user(dummy,&x32->elem); \
+    x64.elem = (void *) dummy; \
+} while (0);
+#  define PUT_USER_P_ARGS(x32,x64,elem) do { \
+    dummy = (u64) x64.elem; \
+    err |= put_user((u32)dummy,&x32->elem); \
+} while (0);
+
+#  define GET_USER_P(elem) GET_USER_P_ARGS(arg32,arg64,elem)
+#  define PUT_USER_P(elem) PUT_USER_P_ARGS(arg32,arg64,elem)
+
+#  define SYS_IOCTL do { \
+    old_fs = get_fs(); \
+    set_fs(KERNEL_DS); \
+    DEBUG("SYS_IOCTL_FUNC called"); \
+    err = SYS_IOCTL_FUNC(fd,cmd,(unsigned long)&arg64); \
+    DEBUG("SYS_IOCTL_FUNC done"); \
+    set_fs(old_fs); \
+    } while (0);
+
+#  define REG_IOCTL32(nr,c_func) \
+  err = register_ioctl32_conversion(nr,c_func); \
+  if (err)  goto failed; 
+
+#  define UNREG_IOCTL32(nr) \
+  unregister_ioctl32_conversion(nr);
+
+#  define K_ALLOC(x) kmalloc(x,GFP_KERNEL)
+#  define K_FREE(x)  kfree(x)
+
+#  define ASSERT32(x) do { \
+      if (arg64.x & 0xFFFFFFFF00000000) \
+           printk(KERN_WARNING "ioctl32: var " #x " is > 32bit in ioctl(0x%x)\n",cmd); \
+   } while (0)
+
+extern int drm32_default_handler(unsigned int fd, unsigned int cmd, 
+			       unsigned long arg, struct file *file);
+
+# endif
+
+extern int drm32_register(void);
+extern void drm32_unregister(void);
+
+#endif
Index: drivers/char/drm/drm_memory.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_memory.h,v
retrieving revision 1.1.1.3
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.3 drm_memory.h
--- linux/drivers/char/drm/drm_memory.h	14 Mar 2005 10:18:13 -0000	1.1.1.3
+++ drivers/char/drm/drm_memory.h	15 Mar 2005 18:02:52 -0000
@@ -60,19 +60,19 @@
 /*
  * Find the drm_map that covers the range [offset, offset+size).
  */
-static inline drm_map_t *
+static inline drm_map_priv_t *
 drm_lookup_map (unsigned long offset, unsigned long size, drm_device_t *dev)
 {
 	struct list_head *list;
 	drm_map_list_t *r_list;
-	drm_map_t *map;
+	drm_map_priv_t *map;
 
 	list_for_each(list, &dev->maplist->head) {
 		r_list = (drm_map_list_t *) list;
 		map = r_list->map;
 		if (!map)
 			continue;
-		if (map->offset <= offset && (offset + size) <= (map->offset + map->size))
+		if (map->pub.offset <= offset && (offset + size) <= (map->pub.offset + map->pub.size))
 			return map;
 	}
 	return NULL;
@@ -130,7 +130,7 @@
 
 #else /* __OS_HAS_AGP */
 
-static inline drm_map_t *drm_lookup_map(unsigned long offset, unsigned long size, drm_device_t *dev)
+static inline drm_map_pub_t *drm_lookup_map(unsigned long offset, unsigned long size, drm_device_t *dev)
 {
   return NULL;
 }
@@ -150,9 +150,9 @@
 static inline void *drm_ioremap(unsigned long offset, unsigned long size, drm_device_t *dev)
 {
 	if (drm_core_has_AGP(dev) && dev->agp && dev->agp->cant_use_aperture) {
-		drm_map_t *map = drm_lookup_map(offset, size, dev);
+		drm_map_priv_t *map = drm_lookup_map(offset, size, dev);
 
-		if (map && map->type == _DRM_AGP)
+		if (map && map->pub.type == _DRM_AGP)
 			return agp_remap(offset, size, dev);
 	}
 	return ioremap(offset, size);
@@ -162,9 +162,9 @@
 					drm_device_t *dev)
 {
 	if (drm_core_has_AGP(dev) && dev->agp && dev->agp->cant_use_aperture) {
-		drm_map_t *map = drm_lookup_map(offset, size, dev);
+		drm_map_priv_t *map = drm_lookup_map(offset, size, dev);
 
-		if (map && map->type == _DRM_AGP)
+		if (map && map->pub.type == _DRM_AGP)
 			return agp_remap(offset, size, dev);
 	}
 	return ioremap_nocache(offset, size);
@@ -181,11 +181,11 @@
 	    && ((unsigned long) pt >= VMALLOC_START && (unsigned long) pt < VMALLOC_END))
 	{
 		unsigned long offset;
-		drm_map_t *map;
+		drm_map_priv_t *map;
 
 		offset = drm_follow_page(pt) | ((unsigned long) pt & ~PAGE_MASK);
 		map = drm_lookup_map(offset, size, dev);
-		if (map && map->type == _DRM_AGP) {
+		if (map && map->pub.type == _DRM_AGP) {
 			vunmap(pt);
 			return;
 		}
Index: drivers/char/drm/drm_os_linux.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_os_linux.h,v
retrieving revision 1.1.1.6
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.6 drm_os_linux.h
--- linux/drivers/char/drm/drm_os_linux.h	14 Mar 2005 10:18:13 -0000	1.1.1.6
+++ drivers/char/drm/drm_os_linux.h	15 Mar 2005 18:02:52 -0000
@@ -109,8 +109,8 @@
 	drm_map_list_t *entry;						 \
 	list_for_each_entry( entry, &dev->maplist->head, head ) {	 \
 		if ( entry->map &&					 \
-		     entry->map->type == _DRM_SHM &&			 \
-		     (entry->map->flags & _DRM_CONTAINS_LOCK) ) {	 \
+		     entry->map->pub.type == _DRM_SHM &&		 \
+		     (entry->map->pub.flags & _DRM_CONTAINS_LOCK) ) {	 \
 			dev_priv->sarea = entry->map;			 \
  			break;						 \
  		}							 \
Index: drivers/char/drm/drm_proc.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_proc.c,v
retrieving revision 1.1.1.1
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.1 drm_proc.c
--- linux/drivers/char/drm/drm_proc.c	11 Jan 2005 10:26:56 -0000	1.1.1.1
+++ drivers/char/drm/drm_proc.c	15 Mar 2005 18:02:52 -0000
@@ -204,7 +204,7 @@
 {
 	drm_device_t *dev = (drm_device_t *)data;
 	int          len  = 0;
-	drm_map_t    *map;
+	drm_map_priv_t    *map;
 	drm_map_list_t *r_list;
 	struct list_head *list;
 
@@ -230,19 +230,19 @@
 		r_list = list_entry(list, drm_map_list_t, head);
 		map = r_list->map;
 		if(!map) continue;
-		if (map->type < 0 || map->type > 4) type = "??";
-		else				    type = types[map->type];
+		if (map->pub.type < 0 || map->pub.type > 4) type = "??";
+		else				    type = types[map->pub.type];
 		DRM_PROC_PRINT("%4d 0x%08lx 0x%08lx %4.4s  0x%02x 0x%08lx ",
 			       i,
-			       map->offset,
-			       map->size,
+			       map->pub.offset,
+			       map->pub.size,
 			       type,
-			       map->flags,
+			       map->pub.flags,
 			       (unsigned long)map->handle);
-		if (map->mtrr < 0) {
+		if (map->pub.mtrr < 0) {
 			DRM_PROC_PRINT("none\n");
 		} else {
-			DRM_PROC_PRINT("%4d\n", map->mtrr);
+			DRM_PROC_PRINT("%4d\n", map->pub.mtrr);
 		}
 		i++;
 	}
Index: drivers/char/drm/drm_scatter.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_scatter.c,v
retrieving revision 1.1.1.1
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.1 drm_scatter.c
--- linux/drivers/char/drm/drm_scatter.c	11 Jan 2005 10:26:56 -0000	1.1.1.1
+++ drivers/char/drm/drm_scatter.c	15 Mar 2005 18:02:52 -0000
@@ -61,6 +61,12 @@
 		   DRM_MEM_SGLISTS );
 }
 
+#ifdef _LP64
+# define ScatterHandle(x) (unsigned int)((x >> 32) + (x & ((1L << 32) - 1)))
+#else
+# define ScatterHandle(x) (unsigned int)(x)
+#endif
+
 int drm_sg_alloc( struct inode *inode, struct file *filp,
 		   unsigned int cmd, unsigned long arg )
 {
@@ -114,7 +120,7 @@
 	}
 	memset( (void *)entry->busaddr, 0, pages * sizeof(*entry->busaddr) );
 
-	entry->virtual = vmalloc_32( pages << PAGE_SHIFT );
+	entry->virtual = vmalloc( pages << PAGE_SHIFT );
 	if ( !entry->virtual ) {
 		drm_free( entry->busaddr,
 			   entry->pages * sizeof(*entry->busaddr),
@@ -133,12 +139,12 @@
 	 */
 	memset( entry->virtual, 0, pages << PAGE_SHIFT );
 
-	entry->handle = (unsigned long)entry->virtual;
+	entry->handle = ScatterHandle((unsigned long)entry->virtual);
 
 	DRM_DEBUG( "sg alloc handle  = %08lx\n", entry->handle );
 	DRM_DEBUG( "sg alloc virtual = %p\n", entry->virtual );
 
-	for ( i = entry->handle, j = 0 ; j < pages ; i += PAGE_SIZE, j++ ) {
+	for ( i = (unsigned long)entry->virtual, j = 0 ; j < pages ; i += PAGE_SIZE, j++ ) {
 		entry->pagelist[j] = vmalloc_to_page((void *)i);
 		if (!entry->pagelist[j])
 			goto failed;
Index: drivers/char/drm/drm_vm.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/drm_vm.c,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 drm_vm.c
--- linux/drivers/char/drm/drm_vm.c	14 Mar 2005 10:18:13 -0000	1.1.1.2
+++ drivers/char/drm/drm_vm.c	15 Mar 2005 18:02:52 -0000
@@ -55,7 +55,7 @@
 {
 	drm_file_t *priv  = vma->vm_file->private_data;
 	drm_device_t *dev = priv->dev;
-	drm_map_t *map    = NULL;
+	drm_map_priv_t *map    = NULL;
 	drm_map_list_t  *r_list;
 	struct list_head *list;
 
@@ -71,12 +71,12 @@
 		r_list = list_entry(list, drm_map_list_t, head);
 		map = r_list->map;
 		if (!map) continue;
-		if (map->offset == VM_OFFSET(vma)) break;
+		if (map->pub.pub_handle == VM_OFFSET(vma)) break;
 	}
 
-	if (map && map->type == _DRM_AGP) {
+	if (map && map->pub.type == _DRM_AGP) {
 		unsigned long offset = address - vma->vm_start;
-		unsigned long baddr = VM_OFFSET(vma) + offset;
+		unsigned long baddr = map->pub.offset + offset;
 		struct drm_agp_mem *agpmem;
 		struct page *page;
 
@@ -135,7 +135,7 @@
 static __inline__ struct page *drm_do_vm_shm_nopage(struct vm_area_struct *vma,
 						     unsigned long address)
 {
-	drm_map_t	 *map	 = (drm_map_t *)vma->vm_private_data;
+	drm_map_priv_t	 *map	 = (drm_map_priv_t *)vma->vm_private_data;
 	unsigned long	 offset;
 	unsigned long	 i;
 	struct page	 *page;
@@ -168,7 +168,7 @@
 	drm_file_t	*priv	= vma->vm_file->private_data;
 	drm_device_t	*dev	= priv->dev;
 	drm_vma_entry_t *pt, *prev, *next;
-	drm_map_t *map;
+	drm_map_priv_t *map;
 	drm_map_list_t *r_list;
 	struct list_head *list;
 	int found_maps = 0;
@@ -196,7 +196,7 @@
 	}
 	/* We were the only map that was found */
 	if(found_maps == 1 &&
-	   map->flags & _DRM_REMOVABLE) {
+	   map->pub.flags & _DRM_REMOVABLE) {
 		/* Check to see if we are in the maplist, if we are not, then
 		 * we delete this mappings information.
 		 */
@@ -208,17 +208,17 @@
 		}
 
 		if(!found_maps) {
-			switch (map->type) {
+			switch (map->pub.type) {
 			case _DRM_REGISTERS:
 			case _DRM_FRAME_BUFFER:
-				if (drm_core_has_MTRR(dev) && map->mtrr >= 0) {
+				if (drm_core_has_MTRR(dev) && map->pub.mtrr >= 0) {
 					int retcode;
-					retcode = mtrr_del(map->mtrr,
-							   map->offset,
-							   map->size);
+					retcode = mtrr_del(map->pub.mtrr,
+							   map->pub.offset,
+							   map->pub.size);
 					DRM_DEBUG("mtrr_del = %d\n", retcode);
 				}
-				drm_ioremapfree(map->handle, map->size, dev);
+				drm_ioremapfree(map->handle, map->pub.size, dev);
 				break;
 			case _DRM_SHM:
 				vfree(map->handle);
@@ -279,7 +279,7 @@
 static __inline__ struct page *drm_do_vm_sg_nopage(struct vm_area_struct *vma,
 						    unsigned long address)
 {
-	drm_map_t        *map    = (drm_map_t *)vma->vm_private_data;
+	drm_map_priv_t        *map    = (drm_map_priv_t *)vma->vm_private_data;
 	drm_file_t *priv = vma->vm_file->private_data;
 	drm_device_t *dev = priv->dev;
 	drm_sg_mem_t *entry = dev->sg;
@@ -294,7 +294,7 @@
 
 
 	offset = address - vma->vm_start;
-	map_offset = map->offset - dev->sg->handle;
+	map_offset = map->pub.offset - (unsigned long)dev->sg->virtual;
 	page_offset = (offset >> PAGE_SHIFT) + (map_offset >> PAGE_SHIFT);
 	page = entry->pagelist[page_offset];
 	get_page(page);
@@ -496,9 +496,9 @@
 	return 0;
 }
 
-unsigned long drm_core_get_map_ofs(drm_map_t *map)
+unsigned long drm_core_get_map_ofs(drm_map_priv_t *map)
 {
-	return map->offset;
+	return map->pub.offset;
 }
 EXPORT_SYMBOL(drm_core_get_map_ofs);
 
@@ -529,9 +529,9 @@
 {
 	drm_file_t	*priv	= filp->private_data;
 	drm_device_t	*dev	= priv->dev;
-	drm_map_t	*map	= NULL;
+	drm_map_priv_t	*map	= NULL;
 	drm_map_list_t  *r_list;
-	unsigned long   offset  = 0;
+	unsigned long   vm_offset = 0, offset  = 0;
 	struct list_head *list;
 
 	DRM_DEBUG("start = 0x%lx, end = 0x%lx, offset = 0x%lx\n",
@@ -558,22 +558,20 @@
 				   for performance, even if the list was a
 				   bit longer. */
 	list_for_each(list, &dev->maplist->head) {
-		unsigned long off;
 
 		r_list = list_entry(list, drm_map_list_t, head);
 		map = r_list->map;
 		if (!map) continue;
-		off = dev->driver->get_map_ofs(map);
-		if (off == VM_OFFSET(vma)) break;
+		if (map->pub.pub_handle == VM_OFFSET(vma)) break;
 	}
 
-	if (!map || ((map->flags&_DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN)))
+	if (!map || ((map->pub.flags&_DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN)))
 		return -EPERM;
 
 				/* Check for valid size. */
-	if (map->size != vma->vm_end - vma->vm_start) return -EINVAL;
+	if (map->pub.size != vma->vm_end - vma->vm_start) return -EINVAL;
 
-	if (!capable(CAP_SYS_ADMIN) && (map->flags & _DRM_READ_ONLY)) {
+	if (!capable(CAP_SYS_ADMIN) && (map->pub.flags & _DRM_READ_ONLY)) {
 		vma->vm_flags &= ~(VM_WRITE | VM_MAYWRITE);
 #if defined(__i386__) || defined(__x86_64__)
 		pgprot_val(vma->vm_page_prot) &= ~_PAGE_RW;
@@ -586,7 +584,9 @@
 #endif
 	}
 
-	switch (map->type) {
+	/* fetch real vm_offset from map structure */
+	vm_offset = dev->driver->get_map_ofs(map);
+	switch (map->pub.type) {
         case _DRM_AGP:
 	  if (drm_core_has_AGP(dev) && dev->agp->cant_use_aperture) {
                 /*
@@ -603,9 +603,9 @@
                 /* fall through to _DRM_FRAME_BUFFER... */        
 	case _DRM_FRAME_BUFFER:
 	case _DRM_REGISTERS:
-		if (VM_OFFSET(vma) >= __pa(high_memory)) {
+		if (vm_offset >= __pa(high_memory)) {
 #if defined(__i386__) || defined(__x86_64__)
-			if (boot_cpu_data.x86 > 3 && map->type != _DRM_AGP) {
+			if (boot_cpu_data.x86 > 3 && map->pub.type != _DRM_AGP) {
 				pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
 				pgprot_val(vma->vm_page_prot) &= ~_PAGE_PWT;
 			}
Index: drivers/char/drm/ffb_drv.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/ffb_drv.c,v
retrieving revision 1.1.1.5
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.5 ffb_drv.c
--- linux/drivers/char/drm/ffb_drv.c	11 Jan 2005 10:26:56 -0000	1.1.1.5
+++ drivers/char/drm/ffb_drv.c	15 Mar 2005 18:02:52 -0000
@@ -140,13 +140,13 @@
 	return 0;
 }
 
-static drm_map_t *ffb_find_map(struct file *filp, unsigned long off)
+static drm_map_priv_t *ffb_find_map(struct file *filp, unsigned long off)
 {
 	drm_file_t	*priv	= filp->private_data;
 	drm_device_t	*dev;
 	drm_map_list_t  *r_list;
 	struct list_head *list;
-	drm_map_t	*map;
+	drm_map_priv_t	*map;
 
 	if (!priv || (dev = priv->dev) == NULL)
 		return NULL;
@@ -172,7 +172,7 @@
 				    unsigned long pgoff,
 				    unsigned long flags)
 {
-	drm_map_t *map = ffb_find_map(filp, pgoff << PAGE_SHIFT);
+	drm_map_priv_t *map = ffb_find_map(filp, pgoff << PAGE_SHIFT);
 	unsigned long addr = -ENOMEM;
 
 	if (!map)
@@ -277,7 +277,7 @@
 	wake_up_interruptible(&dev->lock.lock_queue);
 }
 
-static unsigned long ffb_driver_get_map_ofs(drm_map_t *map)
+static unsigned long ffb_driver_get_map_ofs(drm_map_priv_t *map)
 {
 	return (map->offset & 0xffffffff);
 }
Index: drivers/char/drm/gamma_dma.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/gamma_dma.c,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 gamma_dma.c
--- linux/drivers/char/drm/gamma_dma.c	11 Jan 2005 10:26:56 -0000	1.1.1.2
+++ drivers/char/drm/gamma_dma.c	15 Mar 2005 18:02:52 -0000
@@ -805,7 +805,7 @@
 	drm_device_t	*dev	= priv->dev;
 	drm_ctx_priv_map_t __user *argp = (void __user *)arg;
 	drm_ctx_priv_map_t request;
-	drm_map_t *map;
+	drm_map_priv_t *map;
 
 	if (copy_from_user(&request, argp, sizeof(request)))
 		return -EFAULT;
@@ -819,7 +819,7 @@
 	map = dev->context_sareas[request.ctx_id];
 	up(&dev->struct_sem);
 
-	request.handle = map->handle;
+	request.handle = map->pub.pub_handle;
 	if (copy_to_user(argp, &request, sizeof(request)))
 		return -EFAULT;
 	return 0;
@@ -831,7 +831,7 @@
 	drm_file_t	*priv	= filp->private_data;
 	drm_device_t	*dev	= priv->dev;
 	drm_ctx_priv_map_t request;
-	drm_map_t *map = NULL;
+	drm_map_priv_t *map = NULL;
 	drm_map_list_t *r_list;
 	struct list_head *list;
 
@@ -845,7 +845,7 @@
 	list_for_each(list, &dev->maplist->head) {
 		r_list = list_entry(list, drm_map_list_t, head);
 		if(r_list->map &&
-		   r_list->map->handle == request.handle) break;
+		   r_list->map->pub.pub_handle == request.handle) break;
 	}
 	if (list == &(dev->maplist->head)) {
 		up(&dev->struct_sem);
Index: drivers/char/drm/gamma_drv.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/gamma_drv.h,v
retrieving revision 1.1.1.1
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.1 gamma_drv.h
--- linux/drivers/char/drm/gamma_drv.h	20 Nov 2004 10:55:18 -0000	1.1.1.1
+++ drivers/char/drm/gamma_drv.h	15 Mar 2005 18:02:52 -0000
@@ -34,11 +34,11 @@
 
 typedef struct drm_gamma_private {
 	drm_gamma_sarea_t *sarea_priv;
-	drm_map_t *sarea;
-	drm_map_t *mmio0;
-	drm_map_t *mmio1;
-	drm_map_t *mmio2;
-	drm_map_t *mmio3;
+	drm_map_priv_t *sarea;
+	drm_map_priv_t *mmio0;
+	drm_map_priv_t *mmio1;
+	drm_map_priv_t *mmio2;
+	drm_map_priv_t *mmio3;
 	int num_rast;
 } drm_gamma_private_t;
 
Index: drivers/char/drm/i810_drv.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/i810_drv.h,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 i810_drv.h
--- linux/drivers/char/drm/i810_drv.h	11 Jan 2005 10:26:56 -0000	1.1.1.2
+++ drivers/char/drm/i810_drv.h	15 Mar 2005 18:02:52 -0000
@@ -75,8 +75,8 @@
 } drm_i810_ring_buffer_t;
 
 typedef struct drm_i810_private {
-	drm_map_t *sarea_map;
-	drm_map_t *mmio_map;
+	drm_map_priv_t *sarea_map;
+	drm_map_priv_t *mmio_map;
 
 	drm_i810_sarea_t *sarea_priv;
    	drm_i810_ring_buffer_t ring;
Index: drivers/char/drm/i915_dma.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/i915_dma.c,v
retrieving revision 1.1.1.6
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.6 i915_dma.c
--- linux/drivers/char/drm/i915_dma.c	14 Mar 2005 10:18:14 -0000	1.1.1.6
+++ drivers/char/drm/i915_dma.c	15 Mar 2005 18:02:52 -0000
@@ -138,11 +138,11 @@
 	dev_priv->ring.Size = init->ring_size;
 	dev_priv->ring.tail_mask = dev_priv->ring.Size - 1;
 
-	dev_priv->ring.map.offset = init->ring_start;
-	dev_priv->ring.map.size = init->ring_size;
-	dev_priv->ring.map.type = 0;
-	dev_priv->ring.map.flags = 0;
-	dev_priv->ring.map.mtrr = 0;
+	dev_priv->ring.map.pub.offset = init->ring_start;
+	dev_priv->ring.map.pub.size = init->ring_size;
+	dev_priv->ring.map.pub.type = 0;
+	dev_priv->ring.map.pub.flags = 0;
+	dev_priv->ring.map.pub.mtrr = 0;
 
 	drm_core_ioremap( &dev_priv->ring.map, dev );
 
Index: drivers/char/drm/mga_dma.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/mga_dma.c,v
retrieving revision 1.1.1.5
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.5 mga_dma.c
--- linux/drivers/char/drm/mga_dma.c	11 Jan 2005 10:26:56 -0000	1.1.1.5
+++ drivers/char/drm/mga_dma.c	15 Mar 2005 18:02:52 -0000
@@ -173,7 +173,7 @@
 		return;
 	}
 
-	tail = primary->tail + dev_priv->primary->offset;
+	tail = primary->tail + dev_priv->primary->pub.offset;
 
 	/* We need to pad the stream between flushes, as the card
 	 * actually (partially?) reads the first of these commands.
@@ -198,8 +198,8 @@
 		primary->space = head - tail;
 	}
 
-	DRM_DEBUG( "   head = 0x%06lx\n", head - dev_priv->primary->offset );
-	DRM_DEBUG( "   tail = 0x%06lx\n", tail - dev_priv->primary->offset );
+	DRM_DEBUG( "   head = 0x%06lx\n", head - dev_priv->primary->pub.offset );
+	DRM_DEBUG( "   tail = 0x%06lx\n", tail - dev_priv->primary->pub.offset );
 	DRM_DEBUG( "  space = 0x%06x\n", primary->space );
 
 	mga_flush_write_combine();
@@ -224,7 +224,7 @@
 
 	ADVANCE_DMA();
 
-	tail = primary->tail + dev_priv->primary->offset;
+	tail = primary->tail + dev_priv->primary->pub.offset;
 
 	primary->tail = 0;
 	primary->last_flush = 0;
@@ -232,14 +232,14 @@
 
 	head = MGA_READ( MGA_PRIMADDRESS );
 
-	if ( head == dev_priv->primary->offset ) {
+	if ( head == dev_priv->primary->pub.offset ) {
 		primary->space = primary->size;
 	} else {
-		primary->space = head - dev_priv->primary->offset;
+		primary->space = head - dev_priv->primary->pub.offset;
 	}
 
 	DRM_DEBUG( "   head = 0x%06lx\n",
-		  head - dev_priv->primary->offset );
+		  head - dev_priv->primary->pub.offset );
 	DRM_DEBUG( "   tail = 0x%06x\n", primary->tail );
 	DRM_DEBUG( "   wrap = %d\n", primary->last_wrap );
 	DRM_DEBUG( "  space = 0x%06x\n", primary->space );
@@ -255,7 +255,7 @@
 {
 	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
 	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
-	u32 head = dev_priv->primary->offset;
+	u32 head = dev_priv->primary->pub.offset;
 	DRM_DEBUG( "\n" );
 
 	sarea_priv->last_wrap++;
@@ -286,13 +286,13 @@
 	DRM_INFO( "current dispatch: last=0x%x done=0x%x\n",
 		  dev_priv->sarea_priv->last_dispatch,
 		  (unsigned int)(MGA_READ( MGA_PRIMADDRESS ) -
-				 dev_priv->primary->offset) );
+				 dev_priv->primary->pub.offset) );
 	DRM_INFO( "current freelist:\n" );
 
 	for ( entry = dev_priv->head->next ; entry ; entry = entry->next ) {
 		DRM_INFO( "   %p   idx=%2d  age=0x%x 0x%06lx\n",
 			  entry, entry->buf->idx, entry->age.head,
-			  entry->age.head - dev_priv->primary->offset );
+			  entry->age.head - dev_priv->primary->pub.offset );
 	}
 	DRM_INFO( "\n" );
 }
@@ -396,10 +396,10 @@
 
 	DRM_DEBUG( "   tail=0x%06lx %d\n",
 		   tail->age.head ?
-		   tail->age.head - dev_priv->primary->offset : 0,
+		   tail->age.head - dev_priv->primary->pub.offset : 0,
 		   tail->age.wrap );
 	DRM_DEBUG( "   head=0x%06lx %d\n",
-		   head - dev_priv->primary->offset, wrap );
+		   head - dev_priv->primary->pub.offset, wrap );
 
 	if ( TEST_AGE( &tail->age, head, wrap ) ) {
 		prev = dev_priv->tail->prev;
@@ -423,7 +423,7 @@
 
 	DRM_DEBUG( "age=0x%06lx wrap=%d\n",
 		   buf_priv->list_entry->age.head -
-		   dev_priv->primary->offset,
+		   dev_priv->primary->pub.offset,
 		   buf_priv->list_entry->age.wrap );
 
 	entry = buf_priv->list_entry;
@@ -583,7 +583,7 @@
 	/* Init the primary DMA registers.
 	 */
 	MGA_WRITE( MGA_PRIMADDRESS,
-		   dev_priv->primary->offset | MGA_DMA_GENERAL );
+		   dev_priv->primary->pub.offset | MGA_DMA_GENERAL );
 #if 0
 	MGA_WRITE( MGA_PRIMPTR,
 		   virt_to_bus((void *)dev_priv->prim.status) |
@@ -593,8 +593,8 @@
 
 	dev_priv->prim.start = (u8 *)dev_priv->primary->handle;
 	dev_priv->prim.end = ((u8 *)dev_priv->primary->handle
-			      + dev_priv->primary->size);
-	dev_priv->prim.size = dev_priv->primary->size;
+			      + dev_priv->primary->pub.size);
+	dev_priv->prim.size = dev_priv->primary->pub.size;
 
 	dev_priv->prim.tail = 0;
 	dev_priv->prim.space = dev_priv->prim.size;
@@ -605,7 +605,7 @@
 
 	dev_priv->prim.high_mark = 256 * DMA_BLOCK_SIZE;
 
-	dev_priv->prim.status[0] = dev_priv->primary->offset;
+	dev_priv->prim.status[0] = dev_priv->primary->pub.offset;
 	dev_priv->prim.status[1] = 0;
 
 	dev_priv->sarea_priv->last_wrap = 0;
Index: drivers/char/drm/mga_drv.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/mga_drv.c,v
retrieving revision 1.1.1.6
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.6 mga_drv.c
--- linux/drivers/char/drm/mga_drv.c	14 Mar 2005 10:18:13 -0000	1.1.1.6
+++ drivers/char/drm/mga_drv.c	15 Mar 2005 18:02:52 -0000
@@ -90,6 +90,10 @@
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.postinit = postinit,
+#ifdef __x86_64__
+	.register_ioctl32 = mga_register_ioctl32,
+	.unregister_ioctl32 = mga_unregister_ioctl32,
+#endif
 	.version = version,
 	.ioctls = mga_ioctls,
 	.dma_ioctl = mga_dma_buffers,
Index: drivers/char/drm/mga_drv.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/mga_drv.h,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 mga_drv.h
--- linux/drivers/char/drm/mga_drv.h	11 Jan 2005 10:26:56 -0000	1.1.1.2
+++ drivers/char/drm/mga_drv.h	15 Mar 2005 18:02:52 -0000
@@ -112,6 +112,10 @@
 	drm_local_map_t *agp_textures;
 } drm_mga_private_t;
 
+				/* mga_ioctl32.c */
+extern int mga_register_ioctl32( void );
+extern void mga_unregister_ioctl32( void );
+
 				/* mga_dma.c */
 extern int mga_dma_init( DRM_IOCTL_ARGS );
 extern int mga_dma_flush( DRM_IOCTL_ARGS );
@@ -275,11 +279,11 @@
 #define FLUSH_DMA()							\
 do {									\
 	if ( 0 ) {							\
-		DRM_INFO( "%s:\n", __FUNCTION__ );				\
+		DRM_INFO( "%s:\n", __FUNCTION__ );			\
 		DRM_INFO( "   tail=0x%06x head=0x%06lx\n",		\
 			  dev_priv->prim.tail,				\
 			  MGA_READ( MGA_PRIMADDRESS ) -			\
-			  dev_priv->primary->offset );			\
+			  dev_priv->primary->pub.offset );		\
 	}								\
 	if ( !test_bit( 0, &dev_priv->prim.wrapped ) ) {		\
 		if ( dev_priv->prim.space <				\
@@ -334,7 +338,7 @@
 	drm_mga_freelist_t *entry = (buf_priv)->list_entry;		\
 	if ( (buf_priv)->dispatched ) {					\
 		entry->age.head = (dev_priv->prim.tail +		\
-				   dev_priv->primary->offset);		\
+				   dev_priv->primary->pub.offset);	\
 		entry->age.wrap = dev_priv->sarea_priv->last_wrap;	\
 	} else {							\
 		entry->age.head = 0;					\
Index: drivers/char/drm/mga_ioctl32.c
===================================================================
RCS file: drivers/char/drm/mga_ioctl32.c
diff -N drivers/char/drm/mga_ioctl32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ drivers/char/drm/mga_ioctl32.c	15 Mar 2005 18:02:52 -0000
@@ -0,0 +1,189 @@
+/*
+ * Copyright 2003, 2004, Egbert Eich
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * EGBERT EICH BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CON-
+ * NECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Egbert Eich shall not
+ * be used in advertising or otherwise to promote the sale, use or other deal-
+ *ings in this Software without prior written authorization from Egbert Eich.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#if 0
+#include <linux/wrapper.h>
+#else
+#include <linux/syscalls.h>
+#endif
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+
+#ifdef __x86_64__
+
+#include <asm/ioctl32.h>
+#include "drm.h"
+#include "mga_drm.h"
+#define IOCTL32_PRIVATE
+#include "drm_ioctl32.h"
+
+
+typedef struct drm32_mga_init {
+	int func;
+   	u32 sarea_priv_offset;
+	int chipset;
+   	int sgram;
+	unsigned int maccess;
+   	unsigned int fb_cpp;
+	unsigned int front_offset, front_pitch;
+   	unsigned int back_offset, back_pitch;
+   	unsigned int depth_cpp;
+   	unsigned int depth_offset, depth_pitch;
+   	unsigned int texture_offset[MGA_NR_TEX_HEAPS];
+   	unsigned int texture_size[MGA_NR_TEX_HEAPS];
+	u32 fb_offset;
+	u32 mmio_offset;
+	u32 status_offset;
+	u32 warp_offset;
+	u32 primary_offset;
+	u32 buffers_offset;
+} drm32_mga_init_t;
+
+typedef struct drm32_mga_getpram {
+    int param;
+    u32 value;
+} drm32_mga_getparam_t;
+
+#define DRM_IOCTL_MGA_INIT32		DRM_IOW( 0x40, drm32_mga_init_t)
+#define DRM_IOCTL_MGA_GETPARAM32        DRM_IOWR(0x49, drm32_mga_getparam_t)
+
+void mga_unregister_ioctl32(void);
+
+static int
+mga_init_w_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_mga_init_t *arg32 = (drm32_mga_init_t *) arg;
+    drm_mga_init_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    int i;
+
+    DEBUG("mga_init_w_32_64");
+    GET_USER(func);
+    GET_USER(sarea_priv_offset);
+    GET_USER(chipset);
+    GET_USER(sgram);
+    GET_USER(maccess);
+    GET_USER(fb_cpp);
+    GET_USER(front_offset);
+    GET_USER(front_pitch);
+    GET_USER(back_offset);
+    GET_USER(back_pitch);
+    GET_USER(depth_cpp);
+    GET_USER(depth_offset);
+    GET_USER(depth_pitch);
+
+    for (i = 0; i < MGA_NR_TEX_HEAPS; i++) {
+	GET_USER(texture_offset[i]);
+	GET_USER(texture_size[i]);
+    }
+
+    GET_USER(fb_offset);
+    GET_USER(mmio_offset);
+    GET_USER(status_offset);
+    GET_USER(warp_offset);
+    GET_USER(primary_offset);
+    GET_USER(buffers_offset);
+    
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+mga_getparam_wr_32_64(unsigned int fd, unsigned int cmd,
+	unsigned long arg, struct file *file)
+{
+    drm32_mga_getparam_t *arg32 = (drm32_mga_getparam_t *) arg;
+    drm_mga_getparam_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+    
+    DEBUG("mga_getparam_wr_32_64");
+    GET_USER(param);
+    GET_USER_P(value);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    DEBUG("done");
+
+    return err;
+}
+
+int
+mga_register_ioctl32(void)
+{
+    int err;
+
+    if (!drm32_register()) return -1;
+    REG_IOCTL32(DRM_IOCTL_MGA_INIT32,mga_init_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_MGA_GETPARAM32,mga_getparam_wr_32_64);
+    
+    REG_IOCTL32(DRM_IOCTL_MGA_FLUSH,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_MGA_RESET,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_MGA_SWAP,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_MGA_CLEAR,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_MGA_VERTEX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_MGA_INDICES,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_MGA_ILOAD,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_MGA_BLIT,drm32_default_handler);
+    
+    return 0;
+ failed:
+    mga_unregister_ioctl32();
+    return -1;
+}
+
+void
+mga_unregister_ioctl32(void)
+{
+    UNREG_IOCTL32(DRM_IOCTL_MGA_INIT32);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_GETPARAM32);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_FLUSH);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_RESET);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_RESET);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_SWAP);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_CLEAR);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_VERTEX);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_INDICES);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_INDICES);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_ILOAD);
+    UNREG_IOCTL32(DRM_IOCTL_MGA_BLIT);
+
+    drm32_unregister();
+}
+
+#endif
Index: drivers/char/drm/mga_warp.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/mga_warp.c,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 mga_warp.c
--- linux/drivers/char/drm/mga_warp.c	11 Jan 2005 10:26:56 -0000	1.1.1.2
+++ drivers/char/drm/mga_warp.c	15 Mar 2005 18:02:52 -0000
@@ -98,13 +98,13 @@
 static int mga_warp_install_g400_microcode( drm_mga_private_t *dev_priv )
 {
 	unsigned char *vcbase = dev_priv->warp->handle;
-	unsigned long pcbase = dev_priv->warp->offset;
+	unsigned long pcbase = dev_priv->warp->pub.offset;
 	unsigned int size;
 
 	size = mga_warp_g400_microcode_size( dev_priv );
-	if ( size > dev_priv->warp->size ) {
+	if ( size > dev_priv->warp->pub.size ) {
 		DRM_ERROR( "microcode too large! (%u > %lu)\n",
-			   size, dev_priv->warp->size );
+			   size, dev_priv->warp->pub.size );
 		return DRM_ERR(ENOMEM);
 	}
 
@@ -135,13 +135,13 @@
 static int mga_warp_install_g200_microcode( drm_mga_private_t *dev_priv )
 {
 	unsigned char *vcbase = dev_priv->warp->handle;
-	unsigned long pcbase = dev_priv->warp->offset;
+	unsigned long pcbase = dev_priv->warp->pub.offset;
 	unsigned int size;
 
 	size = mga_warp_g200_microcode_size( dev_priv );
-	if ( size > dev_priv->warp->size ) {
+	if ( size > dev_priv->warp->pub.size ) {
 		DRM_ERROR( "microcode too large! (%u > %lu)\n",
-			   size, dev_priv->warp->size );
+			   size, dev_priv->warp->pub.size );
 		return DRM_ERR(ENOMEM);
 	}
 
Index: drivers/char/drm/r128_cce.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/r128_cce.c,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 r128_cce.c
--- linux/drivers/char/drm/r128_cce.c	11 Jan 2005 10:26:56 -0000	1.1.1.2
+++ drivers/char/drm/r128_cce.c	15 Mar 2005 18:02:52 -0000
@@ -323,10 +323,11 @@
 	 */
 #if __OS_HAS_AGP
 	if ( !dev_priv->is_pci )
-		ring_start = dev_priv->cce_ring->offset - dev->agp->base;
+		ring_start = dev_priv->cce_ring->pub.offset - dev->agp->base;
 	else
 #endif
-		ring_start = dev_priv->cce_ring->offset - dev->sg->handle;
+		ring_start = dev_priv->cce_ring->pub.offset 
+		    - (unsigned long)dev->sg->virtual;
 
 	R128_WRITE( R128_PM4_BUFFER_OFFSET, ring_start | R128_AGP_OFFSET );
 
@@ -526,10 +527,10 @@
 #endif
 	{
 		dev_priv->cce_ring->handle =
-			(void *)dev_priv->cce_ring->offset;
+			(void *)dev_priv->cce_ring->pub.offset;
 		dev_priv->ring_rptr->handle =
-			(void *)dev_priv->ring_rptr->offset;
-		dev->agp_buffer_map->handle = (void *)dev->agp_buffer_map->offset;
+			(void *)dev_priv->ring_rptr->pub.offset;
+		dev->agp_buffer_map->handle = (void *)dev->agp_buffer_map->pub.offset;
 	}
 
 #if __OS_HAS_AGP
@@ -537,7 +538,7 @@
 		dev_priv->cce_buffers_offset = dev->agp->base;
 	else
 #endif
-		dev_priv->cce_buffers_offset = dev->sg->handle;
+		dev_priv->cce_buffers_offset = (unsigned long)dev->sg->virtual;
 
 	dev_priv->ring.start = (u32 *)dev_priv->cce_ring->handle;
 	dev_priv->ring.end = ((u32 *)dev_priv->cce_ring->handle
Index: drivers/char/drm/r128_drv.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/r128_drv.c,v
retrieving revision 1.1.1.6
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.6 r128_drv.c
--- linux/drivers/char/drm/r128_drv.c	14 Mar 2005 10:18:14 -0000	1.1.1.6
+++ drivers/char/drm/r128_drv.c	15 Mar 2005 18:02:52 -0000
@@ -85,6 +85,10 @@
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.postinit = postinit,
+#ifdef __x86_64__
+	.register_ioctl32 = r128_register_ioctl32,
+	.unregister_ioctl32 = r128_unregister_ioctl32,
+#endif
 	.version = version,
 	.ioctls = r128_ioctls,
 	.dma_ioctl = r128_cce_buffers,
Index: drivers/char/drm/r128_drv.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/r128_drv.h,v
retrieving revision 1.1.1.3
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.3 r128_drv.h
--- linux/drivers/char/drm/r128_drv.h	14 Mar 2005 10:18:14 -0000	1.1.1.3
+++ drivers/char/drm/r128_drv.h	15 Mar 2005 18:02:52 -0000
@@ -130,6 +130,10 @@
    	drm_r128_freelist_t *list_entry;
 } drm_r128_buf_priv_t;
 
+				/* r128_ioctl32.c */
+extern int r128_register_ioctl32( void );
+extern void r128_unregister_ioctl32( void );
+
 				/* r128_cce.c */
 extern int r128_cce_init( DRM_IOCTL_ARGS );
 extern int r128_cce_start( DRM_IOCTL_ARGS );
Index: drivers/char/drm/r128_ioctl32.c
===================================================================
RCS file: drivers/char/drm/r128_ioctl32.c
diff -N drivers/char/drm/r128_ioctl32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ drivers/char/drm/r128_ioctl32.c	15 Mar 2005 18:02:52 -0000
@@ -0,0 +1,265 @@
+/*
+ * Copyright 2003, 2004, Egbert Eich
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * EGBERT EICH BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CON-
+ * NECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Egbert Eich shall not
+ * be used in advertising or otherwise to promote the sale, use or other deal-
+ *ings in this Software without prior written authorization from Egbert Eich.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#if 0
+#include <linux/wrapper.h>
+#else
+#include <linux/syscalls.h>
+#endif
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+
+#ifdef __x86_64__
+
+#include <asm/ioctl32.h>
+#include "drm.h"
+#include "r128_drm.h"
+#define IOCTL32_PRIVATE
+#include "drm_ioctl32.h"
+
+#define DRM_IOCTL_R128_INIT32		DRM_IOW( 0x40, drm32_r128_init_t)
+#define DRM_IOCTL_R128_DEPTH32		DRM_IOW( 0x4c, drm32_r128_depth_t)
+#define DRM_IOCTL_R128_STIPPLE32	DRM_IOW( 0x4d, drm32_r128_stipple_t)
+#define DRM_IOCTL_R128_GETPARAM32	DRM_IOW( 0x52, drm32_r128_getparam_t)
+
+typedef struct drm32_r128_init {
+	int func;
+	unsigned int sarea_priv_offset;
+	int is_pci;
+	int cce_mode;
+	int cce_secure;
+	int ring_size;
+	int usec_timeout;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+	unsigned int span_offset;
+
+	unsigned int fb_offset;
+	unsigned int mmio_offset;
+	unsigned int ring_offset;
+	unsigned int ring_rptr_offset;
+	unsigned int buffers_offset;
+	unsigned int agp_textures_offset;
+} drm32_r128_init_t;
+
+typedef struct drm32_r128_depth {
+	int func;
+	int n;
+	u32 x;
+	u32 y;
+	u32 buffer;
+	u32 mask;
+} drm32_r128_depth_t;
+
+typedef struct drm32_r128_stipple {
+	u32 mask;
+} drm32_r128_stipple_t;
+
+typedef struct drm32_r128_getparam {
+	int param;
+	u32 value;
+} drm32_r128_getparam_t;
+
+static int
+drm_128_init_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_r128_init_t *arg32 = (drm32_r128_init_t *) arg;
+    drm_r128_init_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("r128_init_32_64");
+
+    GET_USER(func);
+    GET_USER(sarea_priv_offset);
+    GET_USER(is_pci);
+    GET_USER(cce_mode);
+    GET_USER(cce_secure);
+    GET_USER(ring_size);
+    GET_USER(usec_timeout);
+    GET_USER(fb_bpp);
+    GET_USER(front_offset);
+    GET_USER(front_pitch);
+    GET_USER(back_offset);
+    GET_USER(back_pitch);
+    GET_USER(depth_bpp);
+    GET_USER(depth_offset);
+    GET_USER(depth_pitch);
+    GET_USER(span_offset);
+    GET_USER(fb_offset);
+    GET_USER(mmio_offset);
+    GET_USER(ring_offset);
+    GET_USER(ring_rptr_offset);
+    GET_USER(buffers_offset);
+    GET_USER(agp_textures_offset);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_128_depth_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_r128_depth_t *arg32 = (drm32_r128_depth_t *) arg;
+    drm_r128_depth_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("r128_depth_32_64");
+
+    GET_USER(func);
+    GET_USER(n);
+    GET_USER_P(x);
+    GET_USER_P(y);
+    GET_USER_P(buffer);
+    GET_USER_P(mask);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_128_stipple_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_r128_stipple_t *arg32 = (drm32_r128_stipple_t *) arg;
+    drm_r128_stipple_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("r128_stipple_32_64");
+
+    GET_USER_P(mask);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_128_getparam_32_64(unsigned int fd, unsigned int cmd,
+	unsigned long arg, struct file *file)
+{
+    drm32_r128_getparam_t *arg32 = (drm32_r128_getparam_t *) arg;
+    drm_r128_getparam_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+    
+    DEBUG("r128_getparam_wr_32_64");
+    GET_USER(param);
+    GET_USER_P(value);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;    
+    DEBUG("done");
+
+    return err;
+}
+
+
+void
+r128_unregister_ioctl32(void);
+
+int
+r128_register_ioctl32(void)
+{
+    int err;
+
+    if (!drm32_register()) return -1;
+    REG_IOCTL32(DRM_IOCTL_R128_INIT32, drm_128_init_32_64);
+    REG_IOCTL32(DRM_IOCTL_R128_DEPTH32, drm_128_depth_32_64);
+    REG_IOCTL32(DRM_IOCTL_R128_STIPPLE32, drm_128_stipple_32_64);
+    REG_IOCTL32(DRM_IOCTL_R128_GETPARAM32, drm_128_getparam_32_64);
+
+    REG_IOCTL32(DRM_IOCTL_R128_CCE_START, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_CCE_STOP, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_CCE_RESET, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_CCE_IDLE, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_RESET, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_SWAP, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_CLEAR, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_VERTEX, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_INDICES, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_BLIT, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_INDIRECT, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_FULLSCREEN, drm32_default_handler);
+//    REG_IOCTL32(DRM_IOCTL_R128_CLEAR2, drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_R128_FLIP, drm32_default_handler);
+
+    return 0;
+ failed:
+    r128_unregister_ioctl32();
+    return -1;
+}
+
+void
+r128_unregister_ioctl32(void)
+{
+    UNREG_IOCTL32(DRM_IOCTL_R128_INIT32);
+    UNREG_IOCTL32(DRM_IOCTL_R128_DEPTH32);
+    UNREG_IOCTL32(DRM_IOCTL_R128_STIPPLE32);
+    UNREG_IOCTL32(DRM_IOCTL_R128_GETPARAM);
+
+    UNREG_IOCTL32(DRM_IOCTL_R128_CCE_START);
+    UNREG_IOCTL32(DRM_IOCTL_R128_CCE_STOP);
+    UNREG_IOCTL32(DRM_IOCTL_R128_CCE_RESET);
+    UNREG_IOCTL32(DRM_IOCTL_R128_CCE_IDLE);
+    UNREG_IOCTL32(DRM_IOCTL_R128_RESET);
+    UNREG_IOCTL32(DRM_IOCTL_R128_SWAP);
+    UNREG_IOCTL32(DRM_IOCTL_R128_CLEAR);
+    UNREG_IOCTL32(DRM_IOCTL_R128_VERTEX);
+    UNREG_IOCTL32(DRM_IOCTL_R128_INDICES);
+    UNREG_IOCTL32(DRM_IOCTL_R128_BLIT);
+    UNREG_IOCTL32(DRM_IOCTL_R128_INDIRECT);
+    UNREG_IOCTL32(DRM_IOCTL_R128_FULLSCREEN);
+//    UNREG_IOCTL32(DRM_IOCTL_R128_CLEAR2);
+    UNREG_IOCTL32(DRM_IOCTL_R128_FLIP);
+
+    drm32_unregister();
+}
+
+#endif
Index: drivers/char/drm/r128_state.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/r128_state.c,v
retrieving revision 1.1.1.3
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.3 r128_state.c
--- linux/drivers/char/drm/r128_state.c	14 Mar 2005 10:18:13 -0000	1.1.1.3
+++ drivers/char/drm/r128_state.c	15 Mar 2005 18:02:52 -0000
@@ -733,7 +733,7 @@
 	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	int format = sarea_priv->vc_format;
-	int offset = dev->agp_buffer_map->offset - dev_priv->cce_buffers_offset;
+	int offset = dev->agp_buffer_map->pub.offset - dev_priv->cce_buffers_offset;
 	int prim = buf_priv->prim;
 	u32 *data;
 	int dwords;
Index: drivers/char/drm/radeon_cp.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/radeon_cp.c,v
retrieving revision 1.1.1.3
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.3 radeon_cp.c
--- linux/drivers/char/drm/radeon_cp.c	14 Mar 2005 10:18:14 -0000	1.1.1.3
+++ drivers/char/drm/radeon_cp.c	15 Mar 2005 18:02:52 -0000
@@ -1128,16 +1128,17 @@
 				 dev_priv->gart_size) & 0xffff0000) |
 			       (dev_priv->gart_vm_start >> 16)) );
 
-		ring_start = (dev_priv->cp_ring->offset
+		ring_start = (dev_priv->cp_ring->pub.offset
 			      - dev->agp->base
 			      + dev_priv->gart_vm_start);
        } else
 #endif
-		ring_start = (dev_priv->cp_ring->offset
-			      - dev->sg->handle
+		ring_start = (dev_priv->cp_ring->pub.offset
+			      - (unsigned long)dev->sg->virtual
 			      + dev_priv->gart_vm_start);
 
 	RADEON_WRITE( RADEON_CP_RB_BASE, ring_start );
+	RADEON_READ( RADEON_CP_RB_WPTR_DELAY ); /* read back to propagate */
 
 	/* Set the write pointer delay */
 	RADEON_WRITE( RADEON_CP_RB_WPTR_DELAY, 0 );
@@ -1151,7 +1152,7 @@
 #if __OS_HAS_AGP
 	if ( !dev_priv->is_pci ) {
 		RADEON_WRITE( RADEON_CP_RB_RPTR_ADDR,
-			      dev_priv->ring_rptr->offset
+			      dev_priv->ring_rptr->pub.offset
 			      - dev->agp->base
 			      + dev_priv->gart_vm_start);
 	} else
@@ -1160,14 +1161,15 @@
 		drm_sg_mem_t *entry = dev->sg;
 		unsigned long tmp_ofs, page_ofs;
 
-		tmp_ofs = dev_priv->ring_rptr->offset - dev->sg->handle;
+		tmp_ofs = dev_priv->ring_rptr->pub.offset 
+		    - (unsigned long)dev->sg->virtual;
 		page_ofs = tmp_ofs >> PAGE_SHIFT;
 
 		RADEON_WRITE( RADEON_CP_RB_RPTR_ADDR,
 			     entry->busaddr[page_ofs]);
 		DRM_DEBUG( "ring rptr: offset=0x%08lx handle=0x%08lx\n",
 			   (unsigned long) entry->busaddr[page_ofs],
-			   entry->handle + tmp_ofs );
+			   (unsigned long)entry->virtual + tmp_ofs );
 	}
 
 	/* Initialize the scratch register pointer.  This will cause
@@ -1445,10 +1447,10 @@
 #endif
 	{
 		dev_priv->cp_ring->handle =
-			(void *)dev_priv->cp_ring->offset;
+			(void *)dev_priv->cp_ring->pub.offset;
 		dev_priv->ring_rptr->handle =
-			(void *)dev_priv->ring_rptr->offset;
-		dev->agp_buffer_map->handle = (void *)dev->agp_buffer_map->offset;
+			(void *)dev_priv->ring_rptr->pub.offset;
+		dev->agp_buffer_map->handle = (void *)dev->agp_buffer_map->pub.offset;
 
 		DRM_DEBUG( "dev_priv->cp_ring->handle %p\n",
 			   dev_priv->cp_ring->handle );
@@ -1480,13 +1482,13 @@
 
 #if __OS_HAS_AGP
 	if ( !dev_priv->is_pci )
-		dev_priv->gart_buffers_offset = (dev->agp_buffer_map->offset
+		dev_priv->gart_buffers_offset = (dev->agp_buffer_map->pub.offset
 						- dev->agp->base
 						+ dev_priv->gart_vm_start);
 	else
 #endif
-		dev_priv->gart_buffers_offset = (dev->agp_buffer_map->offset
-						- dev->sg->handle
+		dev_priv->gart_buffers_offset = (dev->agp_buffer_map->pub.offset
+						- (unsigned long)dev->sg->virtual
 						+ dev_priv->gart_vm_start);
 
 	DRM_DEBUG( "dev_priv->gart_size %d\n",
Index: drivers/char/drm/radeon_drv.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/radeon_drv.c,v
retrieving revision 1.1.1.6
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.6 radeon_drv.c
--- linux/drivers/char/drm/radeon_drv.c	14 Mar 2005 10:18:13 -0000	1.1.1.6
+++ drivers/char/drm/radeon_drv.c	15 Mar 2005 18:02:52 -0000
@@ -89,6 +89,10 @@
 	.reclaim_buffers = drm_core_reclaim_buffers,
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
+#ifdef __x86_64__
+	.register_ioctl32 = radeon_register_ioctl32,
+	.unregister_ioctl32 = radeon_unregister_ioctl32,
+#endif
 	.postinit = postinit,
 	.version = version,
 	.ioctls = radeon_ioctls,
Index: drivers/char/drm/radeon_drv.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/radeon_drv.h,v
retrieving revision 1.1.1.3
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.3 radeon_drv.h
--- linux/drivers/char/drm/radeon_drv.h	14 Mar 2005 10:18:13 -0000	1.1.1.3
+++ drivers/char/drm/radeon_drv.h	15 Mar 2005 18:02:52 -0000
@@ -267,6 +267,10 @@
 	u32 age;
 } drm_radeon_buf_priv_t;
 
+				/* radeon_ioctl32.c */
+extern int radeon_register_ioctl32( void );
+extern void radeon_unregister_ioctl32( void );
+
 				/* radeon_cp.c */
 extern int radeon_cp_init( DRM_IOCTL_ARGS );
 extern int radeon_cp_start( DRM_IOCTL_ARGS );
Index: drivers/char/drm/radeon_ioctl32.c
===================================================================
RCS file: drivers/char/drm/radeon_ioctl32.c
diff -N drivers/char/drm/radeon_ioctl32.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ drivers/char/drm/radeon_ioctl32.c	15 Mar 2005 18:02:52 -0000
@@ -0,0 +1,486 @@
+/*
+ * Copyright 2003, 2004, Egbert Eich
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * EGBERT EICH BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CON-
+ * NECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Egbert Eich shall not
+ * be used in advertising or otherwise to promote the sale, use or other deal-
+ *ings in this Software without prior written authorization from Egbert Eich.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#if 0
+#include <linux/wrapper.h>
+#else
+#include <linux/syscalls.h>
+#endif
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+
+#ifdef __x86_64__
+
+#include <asm/ioctl32.h>
+#include "drm.h"
+#include "radeon_drm.h"
+#define IOCTL32_PRIVATE
+#include "drm_ioctl32.h"
+
+
+
+typedef struct drm32_radeon_clear {
+	unsigned int flags;
+	unsigned int clear_color;
+	unsigned int clear_depth;
+	unsigned int color_mask;
+	unsigned int depth_mask;
+        u32 depth_boxes; /* drm_radeon_clear_rect_t * */
+} drm32_radeon_clear_t;
+
+typedef struct drm32_radeon_stipple {
+        u32 mask; /* unsigned int * */
+} drm32_radeon_stipple_t;
+
+typedef struct drm32_radeon_tex_image {
+	unsigned int x, y;		/* Blit coordinates */
+	unsigned int width, height;
+	u32 data;  /* const void * */
+} drm32_radeon_tex_image_t;
+
+typedef struct drm32_radeon_texture {
+	int offset;
+	int pitch;
+	int format;
+	int width;			/* Texture image coordinates */
+	int height;
+	u32 image;  /* drm_radeon_tex_image_t * */
+} drm32_radeon_texture_t;
+
+typedef struct drm32_radeon_vertex2 {
+    int idx;
+    int discard;
+    int nr_states;
+    u32 state; /* drm_radeon_state_t */
+    int nr_prims;
+    u32 prim;  /* drm_radeon_prim_t */
+} drm32_radeon_vertex2_t;
+
+typedef struct drm32_radeon_init {
+    int func;
+    unsigned int sarea_priv_offset;
+    int is_pci;
+    int cp_mode;
+    int gart_size;
+    int ring_size;
+    int usec_timeout;
+    unsigned int fb_bpp;
+    unsigned int front_offset, front_pitch;
+    unsigned int back_offset, back_pitch;
+    unsigned int depth_bpp;
+    unsigned int depth_offset, depth_pitch;
+
+    u32 fb_offset;
+    u32 mmio_offset;
+    u32 ring_offset;
+    u32 ring_rptr_offset;
+    u32 buffers_offset;
+    u32 gart_textures_offset;
+} drm32_radeon_init_t;
+
+typedef struct drm32_radeon_getparam {
+	int param;
+	u32 value;
+} drm32_radeon_getparam_t;
+
+typedef struct drm32_radeon_mem_alloc {
+	int region;
+	int alignment;
+	int size;
+	u32 region_offset;	/* offset from start of fb or agp */
+} drm32_radeon_mem_alloc_t;
+
+typedef struct drm32_radeon_irq_emit {
+	u32 irq_seq;
+} drm32_radeon_irq_emit_t;
+
+typedef struct drm32_radeon_cmd_buffer {
+	int bufsz;
+	u32 buf;
+	int nbox;
+	u32 boxes;
+} drm32_radeon_cmd_buffer_t;
+
+typedef struct drm32_radeon_setparam {
+	unsigned int param;
+	int64_t      value;
+} __attribute__((packed)) drm32_radeon_setparam_t;
+
+
+#define DRM_IOCTL_RADEON_CLEAR32	DRM_IOW( 0x48, drm32_radeon_clear_t)
+#define DRM_IOCTL_RADEON_STIPPLE32	DRM_IOW( 0x4c, drm32_radeon_stipple_t)
+#define DRM_IOCTL_RADEON_TEXTURE32	DRM_IOWR(0x4e, drm32_radeon_texture_t)
+#define DRM_IOCTL_RADEON_VERTEX232	DRM_IOW( 0x4f, drm32_radeon_vertex2_t)
+#define DRM_IOCTL_RADEON_CP_INIT32	DRM_IOW( 0x40, drm32_radeon_init_t)
+#define DRM_IOCTL_RADEON_ALLOC32        DRM_IOWR(0x53, drm32_radeon_mem_alloc_t)
+#define DRM_IOCTL_RADEON_IRQ_EMIT32     DRM_IOWR(0x56, drm32_radeon_irq_emit_t)
+#define DRM_IOCTL_RADEON_GETPARAM32     DRM_IOWR(0x51, drm32_radeon_getparam_t)
+#define DRM_IOCTL_RADEON_CMDBUF32       DRM_IOW(0x50, drm32_radeon_cmd_buffer_t)
+#define DRM_IOCTL_RADEON_SETPARAM32     DRM_IOW(0x59, drm32_radeon_setparam_t)
+
+
+void radeon_unregister_ioctl32(void);
+
+static int
+drm_clear_w_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_clear_t *arg32 = (drm32_radeon_clear_t *) arg;
+    drm_radeon_clear_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("drm_clear_w_32_64");
+    GET_USER(flags);
+    GET_USER(clear_color);
+    GET_USER(clear_depth);
+    GET_USER(color_mask);
+    GET_USER(depth_mask);
+    GET_USER_P(depth_boxes);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_stipple_w_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_stipple_t *arg32 = (drm32_radeon_stipple_t *) arg;
+    drm_radeon_stipple_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("drm_stipple_w_32_64");
+    GET_USER_P(mask);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_texture_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_texture_t *arg32 = (drm32_radeon_texture_t *) arg;
+    drm_radeon_texture_t arg64;
+    drm32_radeon_tex_image_t *image32;
+    drm_radeon_tex_image_t image64;
+    mm_segment_t old_fs;
+    int err = 0, err_tmp = 0;
+    u64 dummy;
+
+    DEBUG("drm_texture_32_64");
+    GET_USER(offset);
+    GET_USER(pitch);
+    GET_USER(format);
+    GET_USER(width);
+    GET_USER(height);
+    image32 = (drm32_radeon_tex_image_t *)(unsigned long)(arg32->image);
+    arg64.image = &image64;
+    err |= get_user(image64.x,&image32->x);
+    err |= get_user(image64.y,&image32->y);
+    err |= get_user(image64.width,&image32->width);
+    err |= get_user(image64.height,&image32->height);
+    err |= get_user(dummy,&image32->data);
+    image64.data = (void *)dummy;
+    
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    err_tmp = err;
+    err = 0;
+
+    PUT_USER(offset);
+    PUT_USER(pitch);
+    PUT_USER(format);
+    PUT_USER(width);
+    PUT_USER(height);
+    err |= put_user(image64.x,&image32->x);
+    err |= put_user(image64.y,&image32->y);
+    err |= put_user(image64.width,&image32->width);
+    err |= put_user(image64.height,&image32->height);
+    dummy = (u64)image64.data;
+
+    err |= put_user((u32)dummy,&image32->data);
+    return err ? -EFAULT : err_tmp;
+}
+
+static int
+drm_vertex2_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_vertex2_t *arg32 = (drm32_radeon_vertex2_t *) arg;
+    drm_radeon_vertex2_t arg64;
+    mm_segment_t old_fs;
+    u64 dummy;
+    int err = 0;
+    
+    DEBUG("drm_vertex2_32_64");
+
+    GET_USER(idx);
+    GET_USER(discard);
+    GET_USER(nr_states);
+    GET_USER_P(state);
+    GET_USER(nr_prims);
+    GET_USER_P(prim);
+
+    if (err) 
+	return -EFAULT;
+    
+    SYS_IOCTL;
+
+    return err;
+}
+
+static int
+drm_radeon_init_w_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_init_t *arg32 = (drm32_radeon_init_t *) arg;
+    drm_radeon_init_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("radeon_init_w_32_64");
+
+    GET_USER(func);
+    GET_USER(sarea_priv_offset);
+    GET_USER(is_pci);
+    GET_USER(cp_mode);
+    GET_USER(gart_size);
+    GET_USER(ring_size);
+    GET_USER(usec_timeout);
+    GET_USER(fb_bpp);
+    GET_USER(front_offset);
+    GET_USER(front_pitch);
+    GET_USER(back_offset);
+    GET_USER(back_pitch);
+    GET_USER(depth_bpp);
+    GET_USER(depth_offset);
+    GET_USER(depth_pitch);
+    GET_USER(fb_offset);
+    GET_USER(mmio_offset);
+    GET_USER(ring_offset);
+    GET_USER(ring_rptr_offset);
+    GET_USER(buffers_offset);
+    GET_USER(gart_textures_offset);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_radeon_cmd_buffer_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_cmd_buffer_t *arg32 = (drm32_radeon_cmd_buffer_t *) arg;
+    drm_radeon_cmd_buffer_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("radeon_cmd_buffer_32_64");
+
+    GET_USER(bufsz);
+    GET_USER_P(buf);
+    GET_USER(nbox);
+    GET_USER_P(boxes);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_radeon_mem_alloc_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_mem_alloc_t *arg32 = (drm32_radeon_mem_alloc_t *) arg;
+    drm_radeon_mem_alloc_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("radeon_alloc_32_64");
+
+    GET_USER(region);
+    GET_USER(alignment);
+    GET_USER(size);
+    GET_USER_P(region_offset);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_radeon_irq_emit_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_irq_emit_t *arg32 = (drm32_radeon_irq_emit_t *) arg;
+    drm_radeon_irq_emit_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("radeon_irq_emit_32_64");
+
+    GET_USER_P(irq_seq);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_radeon_getparam_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_getparam_t *arg32 = (drm32_radeon_getparam_t *) arg;
+    drm_radeon_getparam_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+    u64 dummy;
+
+    DEBUG("radeon_getpram_32_64");
+
+    GET_USER(param);
+    GET_USER_P(value);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+static int
+drm_radeon_setparam_32_64(unsigned int fd, unsigned int cmd, 
+		  unsigned long arg, struct file *file)
+{
+    drm32_radeon_setparam_t *arg32 = (drm32_radeon_setparam_t *) arg;
+    drm_radeon_setparam_t arg64;
+    mm_segment_t old_fs;
+    int err = 0;
+
+    DEBUG("radeon_setparam_32_64");
+
+    GET_USER(param);
+    GET_USER(value);
+
+    if (err) return -EFAULT;
+    
+    SYS_IOCTL;
+    return err;
+}
+
+int
+radeon_register_ioctl32(void)
+{
+    int err;
+
+    if (!drm32_register()) return -1;
+    REG_IOCTL32(DRM_IOCTL_RADEON_CLEAR32,drm_clear_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_STIPPLE32,drm_stipple_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_TEXTURE32,drm_texture_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_VERTEX232,drm_vertex2_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_CP_INIT32,drm_radeon_init_w_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_ALLOC32,drm_radeon_mem_alloc_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_IRQ_EMIT32,drm_radeon_irq_emit_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_GETPARAM32,drm_radeon_getparam_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_CMDBUF32,drm_radeon_cmd_buffer_32_64);
+    REG_IOCTL32(DRM_IOCTL_RADEON_SETPARAM32,drm_radeon_setparam_32_64);
+
+    REG_IOCTL32(DRM_IOCTL_RADEON_CP_START,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_CP_STOP,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_CP_RESET,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_CP_IDLE,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_RESET,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_FULLSCREEN,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_SWAP,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_VERTEX,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_INDICES,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_INDIRECT,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_FLIP,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_FREE,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_IRQ_WAIT,drm32_default_handler);
+    REG_IOCTL32(DRM_IOCTL_RADEON_CP_RESUME,drm32_default_handler);
+    return 0;
+ failed:
+    radeon_unregister_ioctl32();
+    return -1;
+}
+
+void
+radeon_unregister_ioctl32(void)
+{
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_CLEAR32);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_STIPPLE32);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_TEXTURE32);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_VERTEX232);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_CP_INIT32);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_ALLOC32);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_IRQ_EMIT32);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_GETPARAM32);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_CMDBUF32);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_SETPARAM32);
+
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_CP_START);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_CP_STOP);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_CP_RESET);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_CP_IDLE);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_RESET);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_FULLSCREEN);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_SWAP);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_VERTEX);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_INDICES);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_INDIRECT);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_FLIP);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_FREE);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_IRQ_WAIT);
+    UNREG_IOCTL32(DRM_IOCTL_RADEON_CP_RESUME);
+
+    drm32_unregister();
+}
+
+#endif
Index: drivers/char/drm/radeon_irq.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/radeon_irq.c,v
retrieving revision 1.1.1.2
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.2 radeon_irq.c
--- linux/drivers/char/drm/radeon_irq.c	11 Jan 2005 10:26:56 -0000	1.1.1.2
+++ drivers/char/drm/radeon_irq.c	15 Mar 2005 18:02:52 -0000
@@ -63,8 +63,9 @@
 	/* Only consider the bits we're interested in - others could be used
 	 * outside the DRM
 	 */
-	stat = RADEON_READ(RADEON_GEN_INT_STATUS)
-	     & (RADEON_SW_INT_TEST | RADEON_CRTC_VBLANK_STAT);
+	stat = RADEON_READ(RADEON_GEN_INT_STATUS) 
+	        & (RADEON_SW_INT_TEST | RADEON_CRTC_VBLANK_STAT);
+
 	if (!stat)
 		return IRQ_NONE;
 
Index: drivers/char/drm/via_drv.h
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/via_drv.h,v
retrieving revision 1.1.1.1
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.1 via_drv.h
--- linux/drivers/char/drm/via_drv.h	14 Mar 2005 10:18:13 -0000	1.1.1.1
+++ drivers/char/drm/via_drv.h	15 Mar 2005 18:02:52 -0000
@@ -40,15 +40,15 @@
 #define VIA_FIRE_BUF_SIZE  2048
 
 typedef struct drm_via_ring_buffer {
-	drm_map_t map;
+	drm_map_priv_t map;
 	char *virtual_start;
 } drm_via_ring_buffer_t;
 
 typedef struct drm_via_private {
 	drm_via_sarea_t *sarea_priv;
-	drm_map_t *sarea;
-	drm_map_t *fb;
-	drm_map_t *mmio;
+	drm_map_priv_t *sarea;
+	drm_map_priv_t *fb;
+	drm_map_priv_t *mmio;
 	unsigned long agpAddr;
 	wait_queue_head_t decoder_queue[VIA_NR_XVMC_LOCKS];
 	char *dma_ptr;
Index: drivers/char/drm/via_verifier.c
===================================================================
RCS file: /work/kernelcvs/linux/drivers/char/drm/via_verifier.c,v
retrieving revision 1.1.1.1
diff -I$XFree86.*$ -I$Id.*$ -I$Header.*$ -I$Date.*$ -I$Revision.*$ -I$Author.*$ -I$Source.*$ -u -r1.1.1.1 via_verifier.c
--- linux/drivers/char/drm/via_verifier.c	14 Mar 2005 10:18:13 -0000	1.1.1.1
+++ drivers/char/drm/via_verifier.c	15 Mar 2005 18:02:52 -0000
@@ -258,13 +258,13 @@
  * Partially stolen from drm_memory.h
  */
 
-static __inline__ drm_map_t *
+static __inline__ drm_map_priv_t *
 via_drm_lookup_agp_map (drm_via_state_t *seq, unsigned long offset, unsigned long size, 
 			drm_device_t *dev)
 {
 	struct list_head *list;
 	drm_map_list_t *r_list;
-	drm_map_t *map = seq->map_cache;
+	drm_map_priv_t *map = seq->map_cache;
 
 	if (map && map->offset <= offset && (offset + size) <= (map->offset + map->size)) {
 		return map;
--- linux/drivers/char/drm/drm_vm.c	2005-03-15 21:41:17.000000000 +0100
+++ drivers/char/drm/drm_vm.c	2005-03-15 21:43:40.000000000 +0100
@@ -626,26 +626,26 @@
 		offset = dev->driver->get_reg_ofs(dev);
 #ifdef __sparc__
 		if (io_remap_page_range(DRM_RPR_ARG(vma) vma->vm_start,
-					VM_OFFSET(vma) + offset,
+					vm_offset + offset,
 					vma->vm_end - vma->vm_start,
 					vma->vm_page_prot, 0))
 #elif defined(CONFIG_XEN)
 		if (io_remap_page_range(vma, vma->vm_start,
-					VM_OFFSET(vma) + offset,
+					vm_offset + offset,
 					vma->vm_end - vma->vm_start,
 					vma->vm_page_prot))
 			
 #else
 		if (remap_pfn_range(DRM_RPR_ARG(vma) vma->vm_start,
-				     (VM_OFFSET(vma) + offset) >> PAGE_SHIFT,
+				     (vm_offset + offset) >> PAGE_SHIFT,
 				     vma->vm_end - vma->vm_start,
 				     vma->vm_page_prot))
 #endif
 				return -EAGAIN;
 		DRM_DEBUG("   Type = %d; start = 0x%lx, end = 0x%lx,"
 			  " offset = 0x%lx\n",
-			  map->type,
-			  vma->vm_start, vma->vm_end, VM_OFFSET(vma) + offset);
+			  map->pub.type,
+			  vma->vm_start, vma->vm_end, vm_offset + offset);
 		vma->vm_ops = &drm_vm_ops;
 		break;
 	case _DRM_SHM:
