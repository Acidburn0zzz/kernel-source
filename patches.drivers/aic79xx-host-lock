From: Hannes Reinecke <hare@suse.de>
Subject: Install hangs during hardware detection
References: 148061

Attempting to Install SLES 10.1 Beta 3 x86 64 bit on a dual processor machine
with the Adaptec aic79XX driver we hang during hardware detection at the very
beginning of the install.

Currently the driver totally ignores the mid-level host_lock; this the
midlayer is not being informed if the drive is able to respond to
commands. This might lead to command overruns and subsequent errors.

This patch switches the internal ahd_lock() / ahd_unlock() function to
use the mid-layer host_lock, this synchronizing both.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/aic7xxx/aic79xx_osm.c b/drivers/scsi/aic7xxx/aic79xx_osm.c
index 13b7ac2..b467dd3 100644
--- a/drivers/scsi/aic7xxx/aic79xx_osm.c
+++ b/drivers/scsi/aic7xxx/aic79xx_osm.c
@@ -334,7 +334,7 @@ uint32_t aic79xx_slowcrc;
  */
 static char *aic79xx = NULL;
 
-MODULE_AUTHOR("Maintainer: Luben Tuikov <luben_tuikov@adaptec.com>");
+MODULE_AUTHOR("Maintainer: Justin T. Gibbs <gibbs@scsiguy.com>");
 MODULE_DESCRIPTION("Adaptec Aic790X U320 SCSI Host Bus Adapter driver");
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_VERSION(AIC79XX_DRIVER_VERSION);
@@ -481,7 +481,6 @@ ahd_linux_target_alloc(struct scsi_targe
 {
 	struct	ahd_softc *ahd =
 		*((struct ahd_softc **)dev_to_shost(&starget->dev)->hostdata);
-	unsigned long flags;
 	struct scsi_target **ahd_targp = ahd_linux_target_in_softc(starget);
 	struct ahd_linux_target *targ = scsi_transport_target_data(starget);
 	struct ahd_devinfo devinfo;
@@ -489,8 +488,6 @@ ahd_linux_target_alloc(struct scsi_targe
 	struct ahd_tmode_tstate *tstate;
 	char channel = starget->channel + 'A';
 
-	ahd_lock(ahd, &flags);
-
 	BUG_ON(*ahd_targp != NULL);
 
 	*ahd_targp = starget;
@@ -512,7 +509,6 @@ ahd_linux_target_alloc(struct scsi_targe
 			 AHD_TRANS_GOAL, /*paused*/FALSE);
 	ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
 		      AHD_TRANS_GOAL, /*paused*/FALSE);
-	ahd_unlock(ahd, &flags);
 
 	return 0;
 }
@@ -1460,9 +1456,6 @@ ahd_linux_run_command(struct ahd_softc *
 	struct	 ahd_tmode_tstate *tstate;
 	u_int	 col_idx;
 	uint16_t mask;
-	unsigned long flags;
-
-	ahd_lock(ahd, &flags);
 
 	/*
 	 * Get an scb to use.
@@ -1478,7 +1471,6 @@ ahd_linux_run_command(struct ahd_softc *
 	}
 	if ((scb = ahd_get_scb(ahd, col_idx)) == NULL) {
 		ahd->flags |= AHD_RESOURCE_SHORTAGE;
-		ahd_unlock(ahd, &flags);
 		return SCSI_MLQUEUE_HOST_BUSY;
 	}
 
@@ -1604,8 +1596,6 @@ ahd_linux_run_command(struct ahd_softc *
 	scb->flags |= SCB_ACTIVE;
 	ahd_queue_scb(ahd, scb);
 
-	ahd_unlock(ahd, &flags);
-
 	return 0;
 }
 
diff --git a/drivers/scsi/aic7xxx/aic79xx_osm.h b/drivers/scsi/aic7xxx/aic79xx_osm.h
index 2b83316..e987fd6 100644
--- a/drivers/scsi/aic7xxx/aic79xx_osm.h
+++ b/drivers/scsi/aic7xxx/aic79xx_osm.h
@@ -380,7 +380,6 @@ struct ahd_platform_data {
 	 */
 	struct scsi_target *starget[AHD_NUM_TARGETS]; 
 
-	spinlock_t		 spin_lock;
 	struct completion	*eh_done;
 	struct Scsi_Host        *host;		/* pointer to scsi host */
 #define AHD_LINUX_NOIRQ	((uint32_t)~0)
@@ -522,19 +521,18 @@ void	ahd_format_transinfo(struct info_st
 static __inline void
 ahd_lockinit(struct ahd_softc *ahd)
 {
-	spin_lock_init(&ahd->platform_data->spin_lock);
 }
 
 static __inline void
 ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
 {
-	spin_lock_irqsave(&ahd->platform_data->spin_lock, *flags);
+	spin_lock_irqsave(ahd->platform_data->host->host_lock, *flags);
 }
 
 static __inline void
 ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
 {
-	spin_unlock_irqrestore(&ahd->platform_data->spin_lock, *flags);
+	spin_unlock_irqrestore(ahd->platform_data->host->host_lock, *flags);
 }
 
 /******************************* PCI Definitions ******************************/
