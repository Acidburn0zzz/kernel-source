diff -urNp linux-2.6.5/drivers/net/e1000/Makefile linux-2.6.5.SUSE/drivers/net/e1000/Makefile
--- linux-2.6.5/drivers/net/e1000/Makefile	2004-04-04 05:36:15.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/e1000/Makefile	2004-04-19 11:31:20.000000000 +0200
@@ -32,4 +32,4 @@
 
 obj-$(CONFIG_E1000) += e1000.o
 
-e1000-objs := e1000_main.o e1000_hw.o e1000_ethtool.o e1000_param.o
+e1000-objs := e1000_main.o e1000_hw.o e1000_ethtool.o e1000_param.o kcompat.o
diff -urNp linux-2.6.5/drivers/net/e1000/e1000.h linux-2.6.5.SUSE/drivers/net/e1000/e1000.h
--- linux-2.6.5/drivers/net/e1000/e1000.h	2004-04-04 05:36:14.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/e1000/e1000.h	2004-03-11 17:51:53.000000000 +0100
@@ -66,10 +66,15 @@
 #ifdef NETIF_F_TSO
 #include <net/checksum.h>
 #endif
-#include <linux/workqueue.h>
+#ifdef SIOCGMIIPHY
 #include <linux/mii.h>
+#endif
+#ifdef SIOCETHTOOL
 #include <linux/ethtool.h>
+#endif
+#ifdef NETIF_F_HW_VLAN_TX
 #include <linux/if_vlan.h>
+#endif
 
 #define BAR_0		0
 #define BAR_1		1
@@ -77,6 +82,7 @@
 #define PCI_DMA_64BIT	0xffffffffffffffffULL
 #define PCI_DMA_32BIT	0x00000000ffffffffULL
 
+#include "kcompat.h"
 
 struct e1000_adapter;
 
@@ -184,7 +190,9 @@ struct e1000_adapter {
 	struct timer_list tx_fifo_stall_timer;
 	struct timer_list watchdog_timer;
 	struct timer_list phy_info_timer;
+#ifdef NETIF_F_HW_VLAN_TX
 	struct vlan_group *vlgrp;
+#endif
 	uint32_t bd_number;
 	uint32_t rx_buffer_len;
 	uint32_t part_num;
@@ -197,8 +205,10 @@ struct e1000_adapter {
 	struct work_struct tx_timeout_task;
     	uint8_t fc_autoneg;
 
+#ifdef ETHTOOL_PHYS_ID
 	struct timer_list blink_timer;
 	unsigned long led_status;
+#endif
 
 	/* TX */
 	struct e1000_desc_ring tx_ring;
@@ -240,10 +250,24 @@ struct e1000_adapter {
 	struct e1000_phy_info phy_info;
 	struct e1000_phy_stats phy_stats;
 
+#ifdef ETHTOOL_TEST
 	uint32_t test_icr;
 	struct e1000_desc_ring test_tx_ring;
 	struct e1000_desc_ring test_rx_ring;
+#endif
 
+#ifdef E1000_COUNT_ICR
+	uint64_t icr_txdw;
+	uint64_t icr_txqe;
+	uint64_t icr_lsc;
+	uint64_t icr_rxseq;
+	uint64_t icr_rxdmt;
+	uint64_t icr_rxo;
+	uint64_t icr_rxt;
+	uint64_t icr_mdac;
+	uint64_t icr_rxcfg;
+	uint64_t icr_gpi;
+#endif
 
 	uint32_t pci_state[16];
 };
diff -urNp linux-2.6.5/drivers/net/e1000/e1000_ethtool.c linux-2.6.5.SUSE/drivers/net/e1000/e1000_ethtool.c
--- linux-2.6.5/drivers/net/e1000/e1000_ethtool.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/e1000/e1000_ethtool.c	2004-03-11 17:51:53.000000000 +0100
@@ -30,6 +30,7 @@
 
 #include "e1000.h"
 
+#ifdef	SIOCETHTOOL
 #include <asm/uaccess.h>
 
 extern char e1000_driver_name[];
@@ -45,6 +46,10 @@ extern void e1000_free_rx_resources(stru
 extern void e1000_free_tx_resources(struct e1000_adapter *adapter);
 extern void e1000_update_stats(struct e1000_adapter *adapter);
 
+#ifndef ETH_GSTRING_LEN
+#define ETH_GSTRING_LEN 32
+#endif
+#ifdef	ETHTOOL_GSTATS
 struct e1000_stats {
 	char stat_string[ETH_GSTRING_LEN];
 	int sizeof_stat;
@@ -93,12 +98,15 @@ static struct e1000_stats e1000_gstrings
 };
 #define E1000_STATS_LEN	\
 	sizeof(e1000_gstrings_stats) / sizeof(struct e1000_stats)
+#endif	/* ETHTOOL_GSTATS */
+#ifdef	ETHTOOL_TEST
 static char e1000_gstrings_test[][ETH_GSTRING_LEN] = {
 	"Register test  (offline)", "Eeprom test    (offline)",
 	"Interrupt test (offline)", "Loopback test  (offline)",
 	"Link test   (on/offline)"
 };
 #define E1000_TEST_LEN sizeof(e1000_gstrings_test) / ETH_GSTRING_LEN
+#endif	/* ETHTOOL_TEST */
 
 static void
 e1000_ethtool_gset(struct e1000_adapter *adapter, struct ethtool_cmd *ecmd)
@@ -195,6 +203,7 @@ e1000_ethtool_sset(struct e1000_adapter 
 	return 0;
 }
 
+#ifdef	ETHTOOL_GPAUSEPARAM
 static int
 e1000_ethtool_gpause(struct e1000_adapter *adapter,
                      struct ethtool_pauseparam *epause)
@@ -215,7 +224,9 @@ e1000_ethtool_gpause(struct e1000_adapte
 	
 	return 0;
 }
+#endif /* ETHTOOL_GPAUSEPARAM */
 
+#ifdef	ETHTOOL_SPAUSEPARAM
 static int
 e1000_ethtool_spause(struct e1000_adapter *adapter,
                      struct ethtool_pauseparam *epause)
@@ -247,7 +258,9 @@ e1000_ethtool_spause(struct e1000_adapte
 	
 	return 0;
 }
+#endif /* ETHTOOL_SPAUSEPARAM */
 
+#ifdef	ETHTOOL_GDRVINFO
 static void
 e1000_ethtool_gdrvinfo(struct e1000_adapter *adapter,
                        struct ethtool_drvinfo *drvinfo)
@@ -256,13 +269,26 @@ e1000_ethtool_gdrvinfo(struct e1000_adap
 	strncpy(drvinfo->version, e1000_driver_version, 32);
 	strncpy(drvinfo->fw_version, "N/A", 32);
 	strncpy(drvinfo->bus_info, pci_name(adapter->pdev), 32);
+#ifdef	ETHTOOL_GSTATS
 	drvinfo->n_stats = E1000_STATS_LEN;
+#endif	/* ETHTOOL_GSTATS */
+#ifdef	ETHTOOL_TEST
 	drvinfo->testinfo_len = E1000_TEST_LEN;
+#endif	/* ETHTOOL_TEST */
+#ifdef	ETHTOOL_GEEPROM  /* GREGS broken in earlier ethtool.h */
+#ifdef	ETHTOOL_GREGS
 #define E1000_REGS_LEN 32
 	drvinfo->regdump_len  = E1000_REGS_LEN * sizeof(uint32_t);
+#endif	/* ETHTOOL_GREGS */
+#endif	/* ETHTOOL_GEEPROM */
+#ifdef	ETHTOOL_GEEPROM
 	drvinfo->eedump_len = adapter->hw.eeprom.word_size * 2;
+#endif	/* ETHTOOL_GEEPROM */
 }
+#endif	/* ETHTOOL_GDRVINFO */
 
+#ifdef	ETHTOOL_GEEPROM  /* GREGS broken in earlier ethtool.h */
+#ifdef  ETHTOOL_GREGS
 static void
 e1000_ethtool_gregs(struct e1000_adapter *adapter,
                     struct ethtool_regs *regs, uint32_t *regs_buff)
@@ -345,7 +371,10 @@ e1000_ethtool_gregs(struct e1000_adapter
 
 	return;
 }
+#endif  /* ETHTOOL_GREGS */
+#endif	/* ETHTOOL_GEEPROM */
 
+#ifdef	ETHTOOL_GEEPROM
 static int
 e1000_ethtool_geeprom(struct e1000_adapter *adapter,
                       struct ethtool_eeprom *eeprom, uint16_t *eeprom_buff)
@@ -353,6 +382,7 @@ e1000_ethtool_geeprom(struct e1000_adapt
 	struct e1000_hw *hw = &adapter->hw;
 	int first_word, last_word;
 	int ret_val = 0;
+	uint16_t i;
 
 	if(eeprom->len == 0) {
 		ret_val = -EINVAL;
@@ -377,16 +407,22 @@ e1000_ethtool_geeprom(struct e1000_adapt
 					    last_word - first_word + 1,
 					    eeprom_buff);
 	else {
-		uint16_t i;
 		for (i = 0; i < last_word - first_word + 1; i++)
 			if((ret_val = e1000_read_eeprom(hw, first_word + i, 1,
 							&eeprom_buff[i])))
 				break;
 	}
+
+	/* Device's eeprom is always little-endian, word addressable */
+	for (i = 0; i < last_word - first_word + 1; i++)
+		le16_to_cpus(&eeprom_buff[i]);
+
 geeprom_error:
 	return ret_val;
 }
+#endif	/* ETHTOOL_GEEPROM */
 
+#ifdef	ETHTOOL_SEEPROM
 static int
 e1000_ethtool_seeprom(struct e1000_adapter *adapter,
                       struct ethtool_eeprom *eeprom, void *user_data)
@@ -395,6 +431,7 @@ e1000_ethtool_seeprom(struct e1000_adapt
 	uint16_t *eeprom_buff;
 	void *ptr;
 	int max_len, first_word, last_word, ret_val = 0;
+	uint16_t i;
 
 	if(eeprom->len == 0)
 		return -EOPNOTSUPP;
@@ -428,11 +465,19 @@ e1000_ethtool_seeprom(struct e1000_adapt
 		ret_val = e1000_read_eeprom(hw, last_word, 1,
 		                  &eeprom_buff[last_word - first_word]);
 	}
+
+	/* Device's eeprom is always little-endian, word addressable */
+	for (i = 0; i < last_word - first_word + 1; i++)
+		le16_to_cpus(&eeprom_buff[i]);
+
 	if((ret_val != 0) || copy_from_user(ptr, user_data, eeprom->len)) {
 		ret_val = -EFAULT;
 		goto seeprom_error;
 	}
 
+	for (i = 0; i < last_word - first_word + 1; i++)
+		eeprom_buff[i] = cpu_to_le16(eeprom_buff[i]);
+
 	ret_val = e1000_write_eeprom(hw, first_word,
 				     last_word - first_word + 1, eeprom_buff);
 
@@ -444,7 +489,9 @@ seeprom_error:
 	kfree(eeprom_buff);
 	return ret_val;
 }
+#endif	/* ETHTOOL_SEEPROM */
 
+#ifdef	ETHTOOL_GRINGPARAM
 static int
 e1000_ethtool_gring(struct e1000_adapter *adapter,
                     struct ethtool_ringparam *ring)
@@ -466,6 +513,8 @@ e1000_ethtool_gring(struct e1000_adapter
 
 	return 0;
 }
+#endif /* ETHTOOL_GRINGPARAM */
+#ifdef	ETHTOOL_SRINGPARAM
 static int 
 e1000_ethtool_sring(struct e1000_adapter *adapter,
                     struct ethtool_ringparam *ring)
@@ -474,12 +523,14 @@ e1000_ethtool_sring(struct e1000_adapter
 	e1000_mac_type mac_type = adapter->hw.mac_type;
 	struct e1000_desc_ring *txdr = &adapter->tx_ring;
 	struct e1000_desc_ring *rxdr = &adapter->rx_ring;
+	struct e1000_desc_ring tx_old, tx_new;
+	struct e1000_desc_ring rx_old, rx_new;
 
-	if(netif_running(adapter->netdev)) {
+	tx_old = adapter->tx_ring;
+	rx_old = adapter->rx_ring;
+	
+	if(netif_running(adapter->netdev))
 		e1000_down(adapter);
-		e1000_free_rx_resources(adapter);
-		e1000_free_tx_resources(adapter);
-	}
 
 	rxdr->count = max(ring->rx_pending,(uint32_t)E1000_MIN_RXD);
 	rxdr->count = min(rxdr->count,(uint32_t)(mac_type < e1000_82544 ?
@@ -492,24 +543,38 @@ e1000_ethtool_sring(struct e1000_adapter
 	E1000_ROUNDUP(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE); 
 
 	if(netif_running(adapter->netdev)) {
+		/* try to get new resources before deleting old */
 		if((err = e1000_setup_rx_resources(adapter)))
 			goto err_setup_rx;
 		if((err = e1000_setup_tx_resources(adapter)))
 			goto err_setup_tx;
+
+		/* save the new, restore the old in order to free it,
+		 * then restore the new back again */	
+	
+		rx_new = adapter->rx_ring;
+		tx_new = adapter->tx_ring;
+		adapter->rx_ring = rx_old;
+		adapter->tx_ring = tx_old;
+		e1000_free_rx_resources(adapter);
+		e1000_free_tx_resources(adapter);
+		adapter->rx_ring = rx_new;
+		adapter->tx_ring = tx_new;
 		if((err = e1000_up(adapter)))
-			goto err_up;
+			return err;
 	}
-
 	return 0;
-err_up:
-	e1000_free_tx_resources(adapter);
 err_setup_tx:
 	e1000_free_rx_resources(adapter);
 err_setup_rx:
-	e1000_reset(adapter);
+	adapter->rx_ring = rx_old;
+	adapter->tx_ring = tx_old;
+	e1000_up(adapter);
 	return err;
 }
+#endif /* ETHTOOL_SRINGPARAM */
 
+#ifdef	ETHTOOL_TEST
 #define REG_PATTERN_TEST(R, M, W)                                              \
 {                                                                              \
 	uint32_t pat, value;                                                   \
@@ -974,7 +1039,7 @@ e1000_nonintegrated_phy_loopback(struct 
 	e1000_write_phy_reg(&adapter->hw, PHY_CTRL, 0x8100);
 
 	/* Wait for reset to complete. */
-	udelay(500);
+	usec_delay(500);
 
 	/* Have to setup TX_CLK and TX_CRS after software reset */
 	e1000_phy_reset_clk_and_crs(adapter);
@@ -1053,7 +1118,7 @@ e1000_integrated_phy_loopback(struct e10
 	if(adapter->hw.phy_type == e1000_phy_m88)
 		e1000_phy_disable_receiver(adapter);
 
-	udelay(500);
+	usec_delay(500);
 
 	return 0;
 }
@@ -1191,16 +1256,16 @@ e1000_run_loopback_test(struct e1000_ada
 
 	for(i = 0; i < 64; i++) {
 		e1000_create_lbtest_frame(txdr->buffer_info[i].skb, 1024);
-		pci_dma_sync_single_for_device(pdev, txdr->buffer_info[i].dma,
-					       txdr->buffer_info[i].length,
-					       PCI_DMA_TODEVICE);
+		pci_dma_sync_single(pdev, txdr->buffer_info[i].dma,
+				    txdr->buffer_info[i].length,
+				    PCI_DMA_TODEVICE);
 	}
 	E1000_WRITE_REG(&adapter->hw, TDT, i);
 
 	msec_delay(200);
 
-	pci_dma_sync_single_for_cpu(pdev, rxdr->buffer_info[0].dma,
-				    rxdr->buffer_info[0].length, PCI_DMA_FROMDEVICE);
+	pci_dma_sync_single(pdev, rxdr->buffer_info[0].dma,
+			    rxdr->buffer_info[0].length, PCI_DMA_FROMDEVICE);
 
 	return e1000_check_lbtest_frame(rxdr->buffer_info[0].skb, 1024);
 }
@@ -1279,7 +1344,9 @@ e1000_ethtool_test(struct e1000_adapter 
 	}
 	return 0;
 }
+#endif	/* ETHTOOL_TEST */
 
+#ifdef	ETHTOOL_GWOL
 static void
 e1000_ethtool_gwol(struct e1000_adapter *adapter, struct ethtool_wolinfo *wol)
 {
@@ -1320,7 +1387,9 @@ e1000_ethtool_gwol(struct e1000_adapter 
 		return;
 	}
 }
+#endif	/* ETHTOOL_GWOL */
 
+#ifdef	ETHTOOL_SWOL
 static int
 e1000_ethtool_swol(struct e1000_adapter *adapter, struct ethtool_wolinfo *wol)
 {
@@ -1358,7 +1427,9 @@ e1000_ethtool_swol(struct e1000_adapter 
 
 	return 0;
 }
+#endif	/* ETHTOOL_SWOL */
 
+#ifdef	ETHTOOL_PHYS_ID
 
 /* toggle LED 4 times per second = 2 "blinks" per second */
 #define E1000_ID_INTERVAL	(HZ/4)
@@ -1404,6 +1475,7 @@ e1000_ethtool_led_blink(struct e1000_ada
 
 	return 0;
 }
+#endif	/* ETHTOOL_PHYS_ID */
 
 int
 e1000_ethtool_ioctl(struct net_device *netdev, struct ifreq *ifr)
@@ -1429,6 +1501,7 @@ e1000_ethtool_ioctl(struct net_device *n
 			return -EFAULT;
 		return e1000_ethtool_sset(adapter, &ecmd);
 	}
+#ifdef	ETHTOOL_GDRVINFO
 	case ETHTOOL_GDRVINFO: {
 		struct ethtool_drvinfo drvinfo = {ETHTOOL_GDRVINFO};
 		e1000_ethtool_gdrvinfo(adapter, &drvinfo);
@@ -1436,6 +1509,8 @@ e1000_ethtool_ioctl(struct net_device *n
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GDRVINFO */
+#ifdef	ETHTOOL_GSTRINGS
 	case ETHTOOL_GSTRINGS: {
 		struct ethtool_gstrings gstrings = { ETHTOOL_GSTRINGS };
 		char *strings = NULL;
@@ -1444,6 +1519,7 @@ e1000_ethtool_ioctl(struct net_device *n
 		if(copy_from_user(&gstrings, addr, sizeof(gstrings)))
 			return -EFAULT;
 		switch(gstrings.string_set) {
+#ifdef	ETHTOOL_TEST
 		case ETH_SS_TEST:
 			gstrings.len = E1000_TEST_LEN;
 			strings = kmalloc(E1000_TEST_LEN * ETH_GSTRING_LEN,
@@ -1453,6 +1529,8 @@ e1000_ethtool_ioctl(struct net_device *n
 			memcpy(strings, e1000_gstrings_test, E1000_TEST_LEN *
 			       ETH_GSTRING_LEN);
 			break;
+#endif	/* ETHTOOL_TEST */
+#ifdef	ETHTOOL_GSTATS
 		case ETH_SS_STATS: {
 			int i;
 			gstrings.len = E1000_STATS_LEN;
@@ -1467,6 +1545,7 @@ e1000_ethtool_ioctl(struct net_device *n
 			}
 			break;
 		}
+#endif	/* ETHTOOL_GSTATS */
 		default:
 			return -EOPNOTSUPP;
 		}
@@ -1480,6 +1559,9 @@ e1000_ethtool_ioctl(struct net_device *n
 		kfree(strings);
 		return err;
 	}
+#endif	/* ETHTOOL_GSTRINGS */
+#ifdef	ETHTOOL_GEEPROM  /* GREGS broken in earlier ethtool.h */
+#ifdef  ETHTOOL_GREGS
 	case ETHTOOL_GREGS: {
 		struct ethtool_regs regs = {ETHTOOL_GREGS};
 		uint32_t regs_buff[E1000_REGS_LEN];
@@ -1496,6 +1578,9 @@ e1000_ethtool_ioctl(struct net_device *n
 
 		return 0;
 	}
+#endif  /* ETHTOOL_GREGS */
+#endif  /* ETHTOOL_GEEPROM */
+#ifdef	ETHTOOL_NWAY_RST
 	case ETHTOOL_NWAY_RST: {
 		if(netif_running(netdev)) {
 			e1000_down(adapter);
@@ -1503,12 +1588,16 @@ e1000_ethtool_ioctl(struct net_device *n
 		}
 		return 0;
 	}
+#endif	/* ETHTOOL_NWAY_RST */
+#ifdef	ETHTOOL_PHYS_ID
 	case ETHTOOL_PHYS_ID: {
 		struct ethtool_value id;
 		if(copy_from_user(&id, addr, sizeof(id)))
 			return -EFAULT;
 		return e1000_ethtool_led_blink(adapter, &id);
 	}
+#endif	/* ETHTOOL_PHYS_ID */
+#ifdef	ETHTOOL_GLINK
 	case ETHTOOL_GLINK: {
 		struct ethtool_value link = {ETHTOOL_GLINK};
 		link.data = netif_carrier_ok(netdev);
@@ -1516,6 +1605,8 @@ e1000_ethtool_ioctl(struct net_device *n
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GLINK */
+#ifdef	ETHTOOL_GWOL
 	case ETHTOOL_GWOL: {
 		struct ethtool_wolinfo wol = {ETHTOOL_GWOL};
 		e1000_ethtool_gwol(adapter, &wol);
@@ -1523,12 +1614,16 @@ e1000_ethtool_ioctl(struct net_device *n
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GWOL */
+#ifdef	ETHTOOL_SWOL
 	case ETHTOOL_SWOL: {
 		struct ethtool_wolinfo wol;
 		if(copy_from_user(&wol, addr, sizeof(wol)) != 0)
 			return -EFAULT;
 		return e1000_ethtool_swol(adapter, &wol);
 	}
+#endif	/* ETHTOOL_SWOL */
+#ifdef	ETHTOOL_GEEPROM
 	case ETHTOOL_GEEPROM: {
 		struct ethtool_eeprom eeprom = {ETHTOOL_GEEPROM};
 		struct e1000_hw *hw = &adapter->hw;
@@ -1563,6 +1658,8 @@ err_geeprom_ioctl:
 		kfree(eeprom_buff);
 		return err;
 	}
+#endif	/* ETHTOOL_GEEPROM */
+#ifdef	ETHTOOL_SEEPROM
 	case ETHTOOL_SEEPROM: {
 		struct ethtool_eeprom eeprom;
 
@@ -1572,6 +1669,8 @@ err_geeprom_ioctl:
 		addr += offsetof(struct ethtool_eeprom, data);
 		return e1000_ethtool_seeprom(adapter, &eeprom, addr);
 	}
+#endif	/* ETHTOOL_SEEPROM */
+#ifdef	ETHTOOL_GRINGPARAM
 	case ETHTOOL_GRINGPARAM: {
 		struct ethtool_ringparam ering = {ETHTOOL_GRINGPARAM};
 		e1000_ethtool_gring(adapter, &ering);
@@ -1579,12 +1678,16 @@ err_geeprom_ioctl:
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GRINGPARAM */
+#ifdef	ETHTOOL_SRINGPARAM
 	case ETHTOOL_SRINGPARAM: {
 		struct ethtool_ringparam ering;
 		if(copy_from_user(&ering, addr, sizeof(ering)))
 			return -EFAULT;
 		return e1000_ethtool_sring(adapter, &ering);
 	}
+#endif	/* ETHTOOL_SRINGPARAM */
+#ifdef	ETHTOOL_GPAUSEPARAM
 	case ETHTOOL_GPAUSEPARAM: {
 		struct ethtool_pauseparam epause = {ETHTOOL_GPAUSEPARAM};
 		e1000_ethtool_gpause(adapter, &epause);
@@ -1592,12 +1695,16 @@ err_geeprom_ioctl:
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GPAUSEPARAM */
+#ifdef	ETHTOOL_SPAUSEPARAM
 	case ETHTOOL_SPAUSEPARAM: {
 		struct ethtool_pauseparam epause;
 		if(copy_from_user(&epause, addr, sizeof(epause)))
 			return -EFAULT;
 		return e1000_ethtool_spause(adapter, &epause);
 	}
+#endif	/* ETHTOOL_SPAUSEPARAM */
+#ifdef	ETHTOOL_GSTATS
 	case ETHTOOL_GSTATS: {
 		struct {
 			struct ethtool_stats eth_stats;
@@ -1617,6 +1724,8 @@ err_geeprom_ioctl:
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GSTATS */
+#ifdef	ETHTOOL_TEST
 	case ETHTOOL_TEST: {
 		struct {
 			struct ethtool_test eth_test;
@@ -1637,6 +1746,8 @@ err_geeprom_ioctl:
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_TEST */
+#ifdef	ETHTOOL_GRXCSUM
 	case ETHTOOL_GRXCSUM: {
 		struct ethtool_value edata = { ETHTOOL_GRXCSUM };
 
@@ -1645,6 +1756,8 @@ err_geeprom_ioctl:
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GRXCSUM */
+#ifdef	ETHTOOL_SRXCSUM
 	case ETHTOOL_SRXCSUM: {
 		struct ethtool_value edata;
 
@@ -1658,6 +1771,8 @@ err_geeprom_ioctl:
 			e1000_reset(adapter);
 		return 0;
 	}
+#endif	/* ETHTOOL_SRXCSUM */
+#ifdef	ETHTOOL_GTXCSUM
 	case ETHTOOL_GTXCSUM: {
 		struct ethtool_value edata = { ETHTOOL_GTXCSUM };
 
@@ -1667,6 +1782,8 @@ err_geeprom_ioctl:
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GTXCSUM */
+#ifdef	ETHTOOL_STXCSUM
 	case ETHTOOL_STXCSUM: {
 		struct ethtool_value edata;
 
@@ -1686,6 +1803,8 @@ err_geeprom_ioctl:
 
 		return 0;
 	}
+#endif	/* ETHTOOL_STXCSUM */
+#ifdef	ETHTOOL_GSG
 	case ETHTOOL_GSG: {
 		struct ethtool_value edata = { ETHTOOL_GSG };
 
@@ -1695,6 +1814,8 @@ err_geeprom_ioctl:
 			return -EFAULT;
 		return 0;
 	}
+#endif	/* ETHTOOL_GSG */
+#ifdef	ETHTOOL_SSG
 	case ETHTOOL_SSG: {
 		struct ethtool_value edata;
 
@@ -1708,7 +1829,9 @@ err_geeprom_ioctl:
 
 		return 0;
 	}
+#endif	/* ETHTOOL_SSG */
 #ifdef NETIF_F_TSO
+#ifdef ETHTOOL_GTSO
 	case ETHTOOL_GTSO: {
 		struct ethtool_value edata = { ETHTOOL_GTSO };
 
@@ -1717,6 +1840,8 @@ err_geeprom_ioctl:
 			return -EFAULT;
 		return 0;
 	}
+#endif /* ETHTOOL_GTSO */
+#ifdef ETHTOOL_STSO
 	case ETHTOOL_STSO: {
 		struct ethtool_value edata;
 
@@ -1737,10 +1862,12 @@ err_geeprom_ioctl:
 
 		return 0;
 	}
+#endif /* ETHTOOL_STSO */
 #endif
 	default:
 		return -EOPNOTSUPP;
 	}
 }
 
+#endif	/* SIOCETHTOOL */
 
diff -urNp linux-2.6.5/drivers/net/e1000/e1000_hw.c linux-2.6.5.SUSE/drivers/net/e1000/e1000_hw.c
--- linux-2.6.5/drivers/net/e1000/e1000_hw.c	2004-04-04 05:38:21.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/e1000/e1000_hw.c	2004-03-11 17:51:53.000000000 +0100
@@ -65,6 +65,7 @@ static void e1000_release_eeprom(struct 
 static void e1000_standby_eeprom(struct e1000_hw *hw);
 static int32_t e1000_id_led_init(struct e1000_hw * hw);
 static int32_t e1000_set_vco_speed(struct e1000_hw *hw);
+static int32_t e1000_set_phy_mode(struct e1000_hw *hw);
 
 /* IGP cable length table */
 static const
@@ -394,7 +395,7 @@ e1000_reset_hw(struct e1000_hw *hw)
         case e1000_82543:
         case e1000_82544:
             /* Wait for reset to complete */
-            udelay(10);
+            usec_delay(10);
             ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
             ctrl_ext |= E1000_CTRL_EXT_EE_RST;
             E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
@@ -469,11 +470,11 @@ e1000_init_hw(struct e1000_hw *hw)
     uint16_t pcix_stat_hi_word;
     uint16_t cmd_mmrbc;
     uint16_t stat_mmrbc;
-
     DEBUGFUNC("e1000_init_hw");
 
     /* Initialize Identification LED */
-    if((ret_val = e1000_id_led_init(hw))) {
+    ret_val = e1000_id_led_init(hw);
+    if(ret_val) {
         DEBUGOUT("Error Initializing Identification LED\n");
         return ret_val;
     }
@@ -594,16 +595,16 @@ e1000_adjust_serdes_amplitude(struct e10
         return E1000_SUCCESS;
     }
 
-    if ((ret_val = e1000_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1,
-                                     &eeprom_data))) {
+    ret_val = e1000_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1, &eeprom_data);
+    if (ret_val) {
         return ret_val;
     }
 
     if(eeprom_data != EEPROM_RESERVED_WORD) {
         /* Adjust SERDES output amplitude only. */
         eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK; 
-        if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL,
-                                          eeprom_data)))
+        ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL, eeprom_data);
+        if(ret_val)
             return ret_val;
     }
 
@@ -752,14 +753,16 @@ e1000_setup_fiber_serdes_link(struct e10
     if(hw->media_type == e1000_media_type_fiber)
         signal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
 
-    if((ret_val = e1000_adjust_serdes_amplitude(hw)))
+    ret_val = e1000_adjust_serdes_amplitude(hw);
+    if(ret_val)
         return ret_val;
 
     /* Take the link out of reset */
     ctrl &= ~(E1000_CTRL_LRST);
 
     /* Adjust VCO speed to improve BER performance */
-    if((ret_val = e1000_set_vco_speed(hw)))
+    ret_val = e1000_set_vco_speed(hw);
+    if(ret_val)
         return ret_val;
 
     e1000_config_collision_dist(hw);
@@ -846,7 +849,8 @@ e1000_setup_fiber_serdes_link(struct e10
              * we detect a signal. This will allow us to communicate with
              * non-autonegotiating link partners.
              */
-            if((ret_val = e1000_check_for_link(hw))) {
+            ret_val = e1000_check_for_link(hw);
+            if(ret_val) {
                 DEBUGOUT("Error while checking for link\n");
                 return ret_val;
             }
@@ -893,12 +897,18 @@ e1000_setup_copper_link(struct e1000_hw 
     }
 
     /* Make sure we have a valid PHY */
-    if((ret_val = e1000_detect_gig_phy(hw))) {
+    ret_val = e1000_detect_gig_phy(hw);
+    if(ret_val) {
         DEBUGOUT("Error, did not detect valid phy.\n");
         return ret_val;
     }
     DEBUGOUT1("Phy ID = %x \n", hw->phy_id);
 
+    /* Set PHY to class A mode (if necessary) */
+    ret_val = e1000_set_phy_mode(hw);
+    if(ret_val)
+        return ret_val;
+
     if(hw->mac_type <= e1000_82543 ||
        hw->mac_type == e1000_82541 || hw->mac_type == e1000_82547 ||
        hw->mac_type == e1000_82541_rev_2 || hw->mac_type == e1000_82547_rev_2)
@@ -907,7 +917,8 @@ e1000_setup_copper_link(struct e1000_hw 
     if(!hw->phy_reset_disable) {
         if (hw->phy_type == e1000_phy_igp) {
 
-            if((ret_val = e1000_phy_reset(hw))) {
+            ret_val = e1000_phy_reset(hw);
+            if(ret_val) {
                 DEBUGOUT("Error Resetting the PHY\n");
                 return ret_val;
             }
@@ -922,14 +933,16 @@ e1000_setup_copper_link(struct e1000_hw 
             E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
 
             /* disable lplu d3 during driver init */
-            if((ret_val = e1000_set_d3_lplu_state(hw, FALSE))) {
+            ret_val = e1000_set_d3_lplu_state(hw, FALSE);
+            if(ret_val) {
                 DEBUGOUT("Error Disabling LPLU D3\n");
                 return ret_val;
             }
 
             /* Configure mdi-mdix settings */
-            if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
-                                             &phy_data)))
+            ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
+                                         &phy_data);
+            if(ret_val)
                 return ret_val;
 
             if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
@@ -956,8 +969,9 @@ e1000_setup_copper_link(struct e1000_hw 
                     break;
                 }
             }
-            if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
-                                              phy_data)))
+            ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
+                                          phy_data);
+            if(ret_val)
                 return ret_val;
 
             /* set auto-master slave resolution settings */
@@ -975,27 +989,28 @@ e1000_setup_copper_link(struct e1000_hw 
                  * resolution as hardware default. */
                 if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
                     /* Disable SmartSpeed */
-                    if((ret_val = e1000_read_phy_reg(hw,
-                                                    IGP01E1000_PHY_PORT_CONFIG,
-                                                    &phy_data)))
+                    ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
+                                                 &phy_data);
+                    if(ret_val)
                         return ret_val;
                     phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
-                    if((ret_val = e1000_write_phy_reg(hw,
-                                                     IGP01E1000_PHY_PORT_CONFIG,
-                                                     phy_data)))
+                    ret_val = e1000_write_phy_reg(hw,
+                                                  IGP01E1000_PHY_PORT_CONFIG,
+                                                  phy_data);
+                    if(ret_val)
                         return ret_val;
                     /* Set auto Master/Slave resolution process */
-                    if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL,
-                                                     &phy_data)))
+                    ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
+                    if(ret_val)
                         return ret_val;
                     phy_data &= ~CR_1000T_MS_ENABLE;
-                    if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,
-                                                      phy_data)))
+                    ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
+                    if(ret_val)
                         return ret_val;
                 }
 
-                if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL,
-                                                 &phy_data)))
+                ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
+                if(ret_val)
                     return ret_val;
 
                 /* load defaults for future use */
@@ -1018,14 +1033,15 @@ e1000_setup_copper_link(struct e1000_hw 
                 default:
                     break;
                 }
-                if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,
-                                                  phy_data)))
+                ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
+                if(ret_val)
                     return ret_val;
             }
         } else {
             /* Enable CRS on TX. This must be set for half-duplex operation. */
-            if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
-                                             &phy_data)))
+            ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
+                                         &phy_data);
+            if(ret_val)
                 return ret_val;
 
             phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
@@ -1064,15 +1080,17 @@ e1000_setup_copper_link(struct e1000_hw 
             phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
             if(hw->disable_polarity_correction == 1)
                 phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
-            if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
-                                              phy_data)))
+            ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
+                                          phy_data);
+            if(ret_val)
                 return ret_val;
 
             /* Force TX_CLK in the Extended PHY Specific Control Register
              * to 25MHz clock.
              */
-            if((ret_val = e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
-                                             &phy_data)))
+            ret_val = e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+                                         &phy_data);
+            if(ret_val)
                 return ret_val;
 
             phy_data |= M88E1000_EPSCR_TX_CLK_25;
@@ -1083,14 +1101,15 @@ e1000_setup_copper_link(struct e1000_hw 
                               M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
                 phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
                              M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
-                if((ret_val = e1000_write_phy_reg(hw,
-                                                  M88E1000_EXT_PHY_SPEC_CTRL,
-                                                  phy_data)))
+                ret_val = e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+                                              phy_data);
+                if(ret_val)
                     return ret_val;
             }
 
             /* SW Reset the PHY so all changes take effect */
-            if((ret_val = e1000_phy_reset(hw))) {
+            ret_val = e1000_phy_reset(hw);
+            if(ret_val) {
                 DEBUGOUT("Error Resetting the PHY\n");
                 return ret_val;
             }
@@ -1124,7 +1143,8 @@ e1000_setup_copper_link(struct e1000_hw 
                 hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
 
             DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
-            if((ret_val = e1000_phy_setup_autoneg(hw))) {
+            ret_val = e1000_phy_setup_autoneg(hw);
+            if(ret_val) {
                 DEBUGOUT("Error Setting up Auto-Negotiation\n");
                 return ret_val;
             }
@@ -1133,18 +1153,21 @@ e1000_setup_copper_link(struct e1000_hw 
             /* Restart auto-negotiation by setting the Auto Neg Enable bit and
              * the Auto Neg Restart bit in the PHY control register.
              */
-            if((ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data)))
+            ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
+            if(ret_val)
                 return ret_val;
 
             phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
-            if((ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data)))
+            ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);
+            if(ret_val)
                 return ret_val;
 
             /* Does the user want to wait for Auto-Neg to complete here, or
              * check at a later time (for example, callback routine).
              */
             if(hw->wait_autoneg_complete) {
-                if((ret_val = e1000_wait_autoneg(hw))) {
+                ret_val = e1000_wait_autoneg(hw);
+                if(ret_val) {
                     DEBUGOUT("Error while waiting for autoneg to complete\n");
                     return ret_val;
                 }
@@ -1152,7 +1175,8 @@ e1000_setup_copper_link(struct e1000_hw 
             hw->get_link_status = TRUE;
         } else {
             DEBUGOUT("Forcing speed and duplex\n");
-            if((ret_val = e1000_phy_force_speed_duplex(hw))) {
+            ret_val = e1000_phy_force_speed_duplex(hw);
+            if(ret_val) {
                 DEBUGOUT("Error Forcing Speed and Duplex\n");
                 return ret_val;
             }
@@ -1163,9 +1187,11 @@ e1000_setup_copper_link(struct e1000_hw 
      * valid.
      */
     for(i = 0; i < 10; i++) {
-        if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
+        if(ret_val)
             return ret_val;
-        if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
+        if(ret_val)
             return ret_val;
 
         if(phy_data & MII_SR_LINK_STATUS) {
@@ -1180,19 +1206,22 @@ e1000_setup_copper_link(struct e1000_hw 
             if(hw->mac_type >= e1000_82544) {
                 e1000_config_collision_dist(hw);
             } else {
-                if((ret_val = e1000_config_mac_to_phy(hw))) {
+                ret_val = e1000_config_mac_to_phy(hw);
+                if(ret_val) {
                     DEBUGOUT("Error configuring MAC to PHY settings\n");
                     return ret_val;
                 }
             }
-            if((ret_val = e1000_config_fc_after_link_up(hw))) {
+            ret_val = e1000_config_fc_after_link_up(hw);
+            if(ret_val) {
                 DEBUGOUT("Error Configuring Flow Control\n");
                 return ret_val;
             }
             DEBUGOUT("Valid link established!!!\n");
 
             if(hw->phy_type == e1000_phy_igp) {
-                if((ret_val = e1000_config_dsp_after_link_change(hw, TRUE))) {
+                ret_val = e1000_config_dsp_after_link_change(hw, TRUE);
+                if(ret_val) {
                     DEBUGOUT("Error Configuring DSP after link up\n");
                     return ret_val;
                 }
@@ -1200,7 +1229,7 @@ e1000_setup_copper_link(struct e1000_hw 
             DEBUGOUT("Valid link established!!!\n");
             return E1000_SUCCESS;
         }
-        udelay(10);
+        usec_delay(10);
     }
 
     DEBUGOUT("Unable to establish link!!!\n");
@@ -1222,12 +1251,13 @@ e1000_phy_setup_autoneg(struct e1000_hw 
     DEBUGFUNC("e1000_phy_setup_autoneg");
 
     /* Read the MII Auto-Neg Advertisement Register (Address 4). */
-    if((ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,
-                                     &mii_autoneg_adv_reg)))
+    ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);
+    if(ret_val)
         return ret_val;
 
     /* Read the MII 1000Base-T Control Register (Address 9). */
-    if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg)))
+    ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
+    if(ret_val)
         return ret_val;
 
     /* Need to parse both autoneg_advertised and fc and set up
@@ -1334,13 +1364,14 @@ e1000_phy_setup_autoneg(struct e1000_hw 
         return -E1000_ERR_CONFIG;
     }
 
-    if((ret_val = e1000_write_phy_reg(hw, PHY_AUTONEG_ADV,
-                                      mii_autoneg_adv_reg)))
+    ret_val = e1000_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);
+    if(ret_val)
         return ret_val;
 
     DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
 
-    if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg)))
+    ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg);
+    if(ret_val)
         return ret_val;
 
     return E1000_SUCCESS;
@@ -1379,7 +1410,8 @@ e1000_phy_force_speed_duplex(struct e100
     ctrl &= ~E1000_CTRL_ASDE;
 
     /* Read the MII Control Register. */
-    if((ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg)))
+    ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg);
+    if(ret_val)
         return ret_val;
 
     /* We need to disable autoneg in order to force link and duplex. */
@@ -1426,16 +1458,16 @@ e1000_phy_force_speed_duplex(struct e100
     E1000_WRITE_REG(hw, CTRL, ctrl);
 
     if (hw->phy_type == e1000_phy_m88) {
-        if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+        if(ret_val)
             return ret_val;
 
         /* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI
          * forced whenever speed are duplex are forced.
          */
         phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
-        if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
-                                          phy_data)))
+        ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
+        if(ret_val)
             return ret_val;
 
         DEBUGOUT1("M88E1000 PSCR: %x \n", phy_data);
@@ -1446,23 +1478,24 @@ e1000_phy_force_speed_duplex(struct e100
         /* Clear Auto-Crossover to force MDI manually.  IGP requires MDI
          * forced whenever speed or duplex are forced.
          */
-        if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
+        if(ret_val)
             return ret_val;
 
         phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
         phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
 
-        if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
-                                          phy_data)))
+        ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);
+        if(ret_val)
             return ret_val;
     }
 
     /* Write back the modified PHY MII control register. */
-    if((ret_val = e1000_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg)))
+    ret_val = e1000_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg);
+    if(ret_val)
         return ret_val;
 
-    udelay(1);
+    usec_delay(1);
 
     /* The wait_autoneg_complete flag may be a little misleading here.
      * Since we are forcing speed and duplex, Auto-Neg is not enabled.
@@ -1481,10 +1514,12 @@ e1000_phy_force_speed_duplex(struct e100
             /* Read the MII Status Register and wait for Auto-Neg Complete bit
              * to be set.
              */
-            if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+            ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
+            if(ret_val)
                 return ret_val;
 
-            if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+            ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
+            if(ret_val)
                 return ret_val;
 
             if(mii_status_reg & MII_SR_LINK_STATUS) break;
@@ -1492,7 +1527,8 @@ e1000_phy_force_speed_duplex(struct e100
         }
         if((i == 0) && (hw->phy_type == e1000_phy_m88)) {
             /* We didn't get link.  Reset the DSP and wait again for link. */
-            if((ret_val = e1000_phy_reset_dsp(hw))) {
+            ret_val = e1000_phy_reset_dsp(hw);
+            if(ret_val) {
                 DEBUGOUT("Error Resetting PHY DSP\n");
                 return ret_val;
             }
@@ -1504,10 +1540,12 @@ e1000_phy_force_speed_duplex(struct e100
             /* Read the MII Status Register and wait for Auto-Neg Complete bit
              * to be set.
              */
-            if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+            ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
+            if(ret_val)
                 return ret_val;
 
-            if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+            ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
+            if(ret_val)
                 return ret_val;
         }
     }
@@ -1517,46 +1555,26 @@ e1000_phy_force_speed_duplex(struct e100
          * Extended PHY Specific Control Register to 25MHz clock.  This value
          * defaults back to a 2.5MHz clock when the PHY is reset.
          */
-        if((ret_val = e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data);
+        if(ret_val)
             return ret_val;
 
         phy_data |= M88E1000_EPSCR_TX_CLK_25;
-        if((ret_val = e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
-                                          phy_data)))
+        ret_val = e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
+        if(ret_val)
             return ret_val;
 
         /* In addition, because of the s/w reset above, we need to enable CRS on
          * TX.  This must be set for both full and half duplex operation.
          */
-        if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+        if(ret_val)
             return ret_val;
 
         phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
-        if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
-                                          phy_data)))
+        ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
+        if(ret_val)
             return ret_val;
-
-        /* Polarity reversal workaround for forced 10F/10H links. */
-        if(hw->mac_type <= e1000_82544 &&
-           (hw->forced_speed_duplex == e1000_10_full ||
-            hw->forced_speed_duplex == e1000_10_half)) {
-            if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
-                                              0x0019)))
-                return ret_val;
-            if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,
-                                              0x8F0F)))
-                return ret_val;
-            /* IEEE requirement is 150ms */
-            msec_delay(200);
-            if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
-                                              0x0019)))
-                return ret_val;
-            if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,
-                                              0x8F00)))
-                return ret_val;
-        }
     }
     return E1000_SUCCESS;
 }
@@ -1614,8 +1632,9 @@ e1000_config_mac_to_phy(struct e1000_hw 
      * registers depending on negotiated values.
      */
     if (hw->phy_type == e1000_phy_igp) {
-        if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
+                                     &phy_data);
+        if(ret_val)
             return ret_val;
 
         if(phy_data & IGP01E1000_PSSR_FULL_DUPLEX) ctrl |= E1000_CTRL_FD;
@@ -1633,8 +1652,9 @@ e1000_config_mac_to_phy(struct e1000_hw 
                 IGP01E1000_PSSR_SPEED_100MBPS)
             ctrl |= E1000_CTRL_SPD_100;
     } else {
-        if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
+                                     &phy_data);
+        if(ret_val)
             return ret_val;
 
         if(phy_data & M88E1000_PSSR_DPLX) ctrl |= E1000_CTRL_FD;
@@ -1752,7 +1772,8 @@ e1000_config_fc_after_link_up(struct e10
     if(((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed)) ||
        ((hw->media_type == e1000_media_type_internal_serdes) && (hw->autoneg_failed)) ||
        ((hw->media_type == e1000_media_type_copper) && (!hw->autoneg))) {
-        if((ret_val = e1000_force_mac_fc(hw))) {
+        ret_val = e1000_force_mac_fc(hw);
+        if(ret_val) {
             DEBUGOUT("Error forcing flow control settings\n");
             return ret_val;
         }
@@ -1768,9 +1789,11 @@ e1000_config_fc_after_link_up(struct e10
          * has completed.  We read this twice because this reg has
          * some "sticky" (latched) bits.
          */
-        if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+        ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
+        if(ret_val)
             return ret_val;
-        if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+        ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
+        if(ret_val)
             return ret_val;
 
         if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
@@ -1780,11 +1803,13 @@ e1000_config_fc_after_link_up(struct e10
              * Register (Address 5) to determine how flow control was
              * negotiated.
              */
-            if((ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,
-                                             &mii_nway_adv_reg)))
+            ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,
+                                         &mii_nway_adv_reg);
+            if(ret_val)
                 return ret_val;
-            if((ret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,
-                                             &mii_nway_lp_ability_reg)))
+            ret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,
+                                         &mii_nway_lp_ability_reg);
+            if(ret_val)
                 return ret_val;
 
             /* Two bits in the Auto Negotiation Advertisement Register
@@ -1901,7 +1926,8 @@ e1000_config_fc_after_link_up(struct e10
              * negotiated to HALF DUPLEX, flow control should not be
              * enabled per IEEE 802.3 spec.
              */
-            if((ret_val = e1000_get_speed_and_duplex(hw, &speed, &duplex))) {
+            ret_val = e1000_get_speed_and_duplex(hw, &speed, &duplex);
+            if(ret_val) {
                 DEBUGOUT("Error getting link speed and duplex\n");
                 return ret_val;
             }
@@ -1912,7 +1938,8 @@ e1000_config_fc_after_link_up(struct e10
             /* Now we call a subroutine to actually force the MAC
              * controller to use the correct flow control settings.
              */
-            if((ret_val = e1000_force_mac_fc(hw))) {
+            ret_val = e1000_force_mac_fc(hw);
+            if(ret_val) {
                 DEBUGOUT("Error forcing flow control settings\n");
                 return ret_val;
             }
@@ -1966,9 +1993,11 @@ e1000_check_for_link(struct e1000_hw *hw
          * of the PHY.
          * Read the register twice since the link bit is sticky.
          */
-        if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
+        if(ret_val)
             return ret_val;
-        if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
+        if(ret_val)
             return ret_val;
 
         if(phy_data & MII_SR_LINK_STATUS) {
@@ -2002,7 +2031,8 @@ e1000_check_for_link(struct e1000_hw *hw
         if(hw->mac_type >= e1000_82544)
             e1000_config_collision_dist(hw);
         else {
-            if((ret_val = e1000_config_mac_to_phy(hw))) {
+            ret_val = e1000_config_mac_to_phy(hw);
+            if(ret_val) {
                 DEBUGOUT("Error configuring MAC to PHY settings\n");
                 return ret_val;
             }
@@ -2012,7 +2042,8 @@ e1000_check_for_link(struct e1000_hw *hw
          * need to restore the desired flow control settings because we may
          * have had to re-autoneg with a different link partner.
          */
-        if((ret_val = e1000_config_fc_after_link_up(hw))) {
+        ret_val = e1000_config_fc_after_link_up(hw);
+        if(ret_val) {
             DEBUGOUT("Error configuring flow control\n");
             return ret_val;
         }
@@ -2080,7 +2111,8 @@ e1000_check_for_link(struct e1000_hw *hw
         E1000_WRITE_REG(hw, CTRL, ctrl);
 
         /* Configure Flow Control after forcing link up. */
-        if((ret_val = e1000_config_fc_after_link_up(hw))) {
+        ret_val = e1000_config_fc_after_link_up(hw);
+        if(ret_val) {
             DEBUGOUT("Error configuring flow control\n");
             return ret_val;
         }
@@ -2106,7 +2138,7 @@ e1000_check_for_link(struct e1000_hw *hw
     else if((hw->media_type == e1000_media_type_internal_serdes) &&
             !(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
         /* SYNCH bit and IV bit are sticky. */
-        udelay(10);
+        usec_delay(10);
         if(E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
             if(!(rxcw & E1000_RXCW_IV)) {
                 hw->serdes_link_down = FALSE;
@@ -2173,13 +2205,15 @@ e1000_get_speed_and_duplex(struct e1000_
      * match the duplex in the link partner's capabilities.
      */
     if(hw->phy_type == e1000_phy_igp && hw->speed_downgraded) {
-        if((ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data);
+        if(ret_val)
             return ret_val;
 
         if(!(phy_data & NWAY_ER_LP_NWAY_CAPS))
             *duplex = HALF_DUPLEX;
         else {
-            if((ret_val == e1000_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data)))
+            ret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data);
+            if(ret_val)
                 return ret_val;
             if((*speed == SPEED_100 && !(phy_data & NWAY_LPAR_100TX_FD_CAPS)) ||
                (*speed == SPEED_10 && !(phy_data & NWAY_LPAR_10T_FD_CAPS)))
@@ -2210,9 +2244,11 @@ e1000_wait_autoneg(struct e1000_hw *hw)
         /* Read the MII Status Register and wait for Auto-Neg
          * Complete bit to be set.
          */
-        if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
+        if(ret_val)
             return ret_val;
-        if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
+        if(ret_val)
             return ret_val;
         if(phy_data & MII_SR_AUTONEG_COMPLETE) {
             return E1000_SUCCESS;
@@ -2237,7 +2273,7 @@ e1000_raise_mdi_clk(struct e1000_hw *hw,
      */
     E1000_WRITE_REG(hw, CTRL, (*ctrl | E1000_CTRL_MDC));
     E1000_WRITE_FLUSH(hw);
-    udelay(10);
+    usec_delay(10);
 }
 
 /******************************************************************************
@@ -2255,7 +2291,7 @@ e1000_lower_mdi_clk(struct e1000_hw *hw,
      */
     E1000_WRITE_REG(hw, CTRL, (*ctrl & ~E1000_CTRL_MDC));
     E1000_WRITE_FLUSH(hw);
-    udelay(10);
+    usec_delay(10);
 }
 
 /******************************************************************************
@@ -2299,7 +2335,7 @@ e1000_shift_out_mdi_bits(struct e1000_hw
         E1000_WRITE_REG(hw, CTRL, ctrl);
         E1000_WRITE_FLUSH(hw);
 
-        udelay(10);
+        usec_delay(10);
 
         e1000_raise_mdi_clk(hw, &ctrl);
         e1000_lower_mdi_clk(hw, &ctrl);
@@ -2377,8 +2413,9 @@ e1000_read_phy_reg(struct e1000_hw *hw,
 
     if(hw->phy_type == e1000_phy_igp &&
        (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
-        if((ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
-                                             (uint16_t)reg_addr)))
+        ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
+                                         (uint16_t)reg_addr);
+        if(ret_val)
             return ret_val;
     }
 
@@ -2417,7 +2454,7 @@ e1000_read_phy_reg_ex(struct e1000_hw *h
 
         /* Poll the ready bit to see if the MDI read completed */
         for(i = 0; i < 64; i++) {
-            udelay(50);
+            usec_delay(50);
             mdic = E1000_READ_REG(hw, MDIC);
             if(mdic & E1000_MDIC_READY) break;
         }
@@ -2480,8 +2517,9 @@ e1000_write_phy_reg(struct e1000_hw *hw,
 
     if(hw->phy_type == e1000_phy_igp &&
        (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
-        if((ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
-                                             (uint16_t)reg_addr)))
+        ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
+                                         (uint16_t)reg_addr);
+        if(ret_val)
             return ret_val;
     }
 
@@ -2521,7 +2559,7 @@ e1000_write_phy_reg_ex(struct e1000_hw *
 
         /* Poll the ready bit to see if the MDI read completed */
         for(i = 0; i < 640; i++) {
-            udelay(5);
+            usec_delay(5);
             mdic = E1000_READ_REG(hw, MDIC);
             if(mdic & E1000_MDIC_READY) break;
         }
@@ -2593,7 +2631,7 @@ e1000_phy_hw_reset(struct e1000_hw *hw)
         E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
         E1000_WRITE_FLUSH(hw);
     }
-    udelay(150);
+    usec_delay(150);
 
     if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
         /* Configure activity LED after PHY reset */
@@ -2620,14 +2658,16 @@ e1000_phy_reset(struct e1000_hw *hw)
     DEBUGFUNC("e1000_phy_reset");
 
     if(hw->mac_type != e1000_82541_rev_2) {
-        if((ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
+        if(ret_val)
             return ret_val;
 
         phy_data |= MII_CR_RESET;
-        if((ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data)))
+        ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);
+        if(ret_val)
             return ret_val;
 
-        udelay(1);
+        usec_delay(1);
     } else e1000_phy_hw_reset(hw);
 
     if(hw->phy_type == e1000_phy_igp)
@@ -2651,12 +2691,14 @@ e1000_detect_gig_phy(struct e1000_hw *hw
     DEBUGFUNC("e1000_detect_gig_phy");
 
     /* Read the PHY ID Registers to identify which PHY is onboard. */
-    if((ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high)))
+    ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);
+    if(ret_val)
         return ret_val;
 
     hw->phy_id = (uint32_t) (phy_id_high << 16);
-    udelay(20);
-    if((ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low)))
+    usec_delay(20);
+    ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);
+    if(ret_val)
         return ret_val;
 
     hw->phy_id |= (uint32_t) (phy_id_low & PHY_REVISION_MASK);
@@ -2708,9 +2750,12 @@ e1000_phy_reset_dsp(struct e1000_hw *hw)
     DEBUGFUNC("e1000_phy_reset_dsp");
 
     do {
-        if((ret_val = e1000_write_phy_reg(hw, 29, 0x001d))) break;
-        if((ret_val = e1000_write_phy_reg(hw, 30, 0x00c1))) break;
-        if((ret_val = e1000_write_phy_reg(hw, 30, 0x0000))) break;
+        ret_val = e1000_write_phy_reg(hw, 29, 0x001d);
+        if(ret_val) break;
+        ret_val = e1000_write_phy_reg(hw, 30, 0x00c1);
+        if(ret_val) break;
+        ret_val = e1000_write_phy_reg(hw, 30, 0x0000);
+        if(ret_val) break;
         ret_val = E1000_SUCCESS;
     } while(0);
 
@@ -2743,13 +2788,14 @@ e1000_phy_igp_get_info(struct e1000_hw *
     phy_info->polarity_correction = e1000_polarity_reversal_enabled;
 
     /* Check polarity status */
-    if((ret_val = e1000_check_polarity(hw, &polarity)))
+    ret_val = e1000_check_polarity(hw, &polarity);
+    if(ret_val)
         return ret_val;
 
     phy_info->cable_polarity = polarity;
 
-    if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
-                                     &phy_data)))
+    ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data);
+    if(ret_val)
         return ret_val;
 
     phy_info->mdix_mode = (phy_data & IGP01E1000_PSSR_MDIX) >>
@@ -2758,7 +2804,8 @@ e1000_phy_igp_get_info(struct e1000_hw *
     if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
        IGP01E1000_PSSR_SPEED_1000MBPS) {
         /* Local/Remote Receiver Information are only valid at 1000 Mbps */
-        if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
+        if(ret_val)
             return ret_val;
 
         phy_info->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS) >>
@@ -2767,7 +2814,8 @@ e1000_phy_igp_get_info(struct e1000_hw *
                               SR_1000T_REMOTE_RX_STATUS_SHIFT;
 
         /* Get cable length */
-        if((ret_val = e1000_get_cable_length(hw, &min_length, &max_length)))
+        ret_val = e1000_get_cable_length(hw, &min_length, &max_length);
+        if(ret_val)
             return ret_val;
 
         /* transalte to old method */
@@ -2807,7 +2855,8 @@ e1000_phy_m88_get_info(struct e1000_hw *
      * and it stored in the hw->speed_downgraded parameter. */
     phy_info->downshift = hw->speed_downgraded;
 
-    if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data)))
+    ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+    if(ret_val)
         return ret_val;
 
     phy_info->extended_10bt_distance =
@@ -2818,12 +2867,14 @@ e1000_phy_m88_get_info(struct e1000_hw *
         M88E1000_PSCR_POLARITY_REVERSAL_SHIFT;
 
     /* Check polarity status */
-    if((ret_val = e1000_check_polarity(hw, &polarity)))
+    ret_val = e1000_check_polarity(hw, &polarity);
+    if(ret_val)
         return ret_val;
 
     phy_info->cable_polarity = polarity;
 
-    if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data)))
+    ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+    if(ret_val)
         return ret_val;
 
     phy_info->mdix_mode = (phy_data & M88E1000_PSSR_MDIX) >>
@@ -2836,7 +2887,8 @@ e1000_phy_m88_get_info(struct e1000_hw *
         phy_info->cable_length = ((phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
                                   M88E1000_PSSR_CABLE_LENGTH_SHIFT);
 
-        if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
+        if(ret_val)
             return ret_val;
 
         phy_info->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS) >>
@@ -2878,10 +2930,12 @@ e1000_phy_get_info(struct e1000_hw *hw,
         return -E1000_ERR_CONFIG;
     }
 
-    if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+    ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
+    if(ret_val)
         return ret_val;
 
-    if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+    ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
+    if(ret_val)
         return ret_val;
 
     if((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
@@ -3042,7 +3096,7 @@ e1000_raise_ee_clk(struct e1000_hw *hw,
     *eecd = *eecd | E1000_EECD_SK;
     E1000_WRITE_REG(hw, EECD, *eecd);
     E1000_WRITE_FLUSH(hw);
-    udelay(hw->eeprom.delay_usec);
+    usec_delay(hw->eeprom.delay_usec);
 }
 
 /******************************************************************************
@@ -3061,7 +3115,7 @@ e1000_lower_ee_clk(struct e1000_hw *hw,
     *eecd = *eecd & ~E1000_EECD_SK;
     E1000_WRITE_REG(hw, EECD, *eecd);
     E1000_WRITE_FLUSH(hw);
-    udelay(hw->eeprom.delay_usec);
+    usec_delay(hw->eeprom.delay_usec);
 }
 
 /******************************************************************************
@@ -3105,7 +3159,7 @@ e1000_shift_out_ee_bits(struct e1000_hw 
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
 
-        udelay(eeprom->delay_usec);
+        usec_delay(eeprom->delay_usec);
 
         e1000_raise_ee_clk(hw, &eecd);
         e1000_lower_ee_clk(hw, &eecd);
@@ -3186,7 +3240,7 @@ e1000_acquire_eeprom(struct e1000_hw *hw
         while((!(eecd & E1000_EECD_GNT)) &&
               (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
             i++;
-            udelay(5);
+            usec_delay(5);
             eecd = E1000_READ_REG(hw, EECD);
         }
         if(!(eecd & E1000_EECD_GNT)) {
@@ -3211,7 +3265,7 @@ e1000_acquire_eeprom(struct e1000_hw *hw
         /* Clear SK and CS */
         eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
         E1000_WRITE_REG(hw, EECD, eecd);
-        udelay(1);
+        usec_delay(1);
     }
 
     return E1000_SUCCESS;
@@ -3234,35 +3288,35 @@ e1000_standby_eeprom(struct e1000_hw *hw
         eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
-        udelay(eeprom->delay_usec);
+        usec_delay(eeprom->delay_usec);
 
         /* Clock high */
         eecd |= E1000_EECD_SK;
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
-        udelay(eeprom->delay_usec);
+        usec_delay(eeprom->delay_usec);
 
         /* Select EEPROM */
         eecd |= E1000_EECD_CS;
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
-        udelay(eeprom->delay_usec);
+        usec_delay(eeprom->delay_usec);
 
         /* Clock low */
         eecd &= ~E1000_EECD_SK;
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
-        udelay(eeprom->delay_usec);
+        usec_delay(eeprom->delay_usec);
     } else if(eeprom->type == e1000_eeprom_spi) {
         /* Toggle CS to flush commands */
         eecd |= E1000_EECD_CS;
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
-        udelay(eeprom->delay_usec);
+        usec_delay(eeprom->delay_usec);
         eecd &= ~E1000_EECD_CS;
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
-        udelay(eeprom->delay_usec);
+        usec_delay(eeprom->delay_usec);
     }
 }
 
@@ -3286,7 +3340,7 @@ e1000_release_eeprom(struct e1000_hw *hw
 
         E1000_WRITE_REG(hw, EECD, eecd);
 
-        udelay(hw->eeprom.delay_usec);
+        usec_delay(hw->eeprom.delay_usec);
     } else if(hw->eeprom.type == e1000_eeprom_microwire) {
         /* cleanup eeprom */
 
@@ -3299,13 +3353,13 @@ e1000_release_eeprom(struct e1000_hw *hw
         eecd |= E1000_EECD_SK;
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
-        udelay(hw->eeprom.delay_usec);
+        usec_delay(hw->eeprom.delay_usec);
 
         /* Falling edge of clock */
         eecd &= ~E1000_EECD_SK;
         E1000_WRITE_REG(hw, EECD, eecd);
         E1000_WRITE_FLUSH(hw);
-        udelay(hw->eeprom.delay_usec);
+        usec_delay(hw->eeprom.delay_usec);
     }
 
     /* Stop requesting EEPROM access */
@@ -3341,9 +3395,10 @@ e1000_spi_eeprom_ready(struct e1000_hw *
         if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
             break;
 
-        udelay(5);
+        usec_delay(5);
         retry_count += 5;
 
+        e1000_standby_eeprom(hw);
     } while(retry_count < EEPROM_MAX_RETRY_SPI);
 
     /* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
@@ -3675,7 +3730,7 @@ e1000_write_eeprom_microwire(struct e100
         for(i = 0; i < 200; i++) {
             eecd = E1000_READ_REG(hw, EECD);
             if(eecd & E1000_EECD_DO) break;
-            udelay(50);
+            usec_delay(50);
         }
         if(i == 200) {
             DEBUGOUT("EEPROM Write did not complete\n");
@@ -4112,12 +4167,14 @@ e1000_setup_led(struct e1000_hw *hw)
     case e1000_82541_rev_2:
     case e1000_82547_rev_2:
         /* Turn off PHY Smart Power Down (if enabled) */
-        if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO,
-                                         &hw->phy_spd_default)))
-            return ret_val;
-        if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
-                                          (uint16_t)(hw->phy_spd_default &
-                                          ~IGP01E1000_GMII_SPD))))
+        ret_val = e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO,
+                                     &hw->phy_spd_default);
+        if(ret_val)
+            return ret_val;
+        ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
+                                      (uint16_t)(hw->phy_spd_default &
+                                      ~IGP01E1000_GMII_SPD));
+        if(ret_val)
             return ret_val;
         /* Fall Through */
     default:
@@ -4164,8 +4221,9 @@ e1000_cleanup_led(struct e1000_hw *hw)
     case e1000_82541_rev_2:
     case e1000_82547_rev_2:
         /* Turn on PHY Smart Power Down (if previously enabled) */
-        if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
-                                          hw->phy_spd_default)))
+        ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
+                                      hw->phy_spd_default);
+        if(ret_val)
             return ret_val;
         /* Fall Through */
     default:
@@ -4612,8 +4670,9 @@ e1000_get_cable_length(struct e1000_hw *
 
     /* Use old method for Phy older than IGP */
     if(hw->phy_type == e1000_phy_m88) {
-        if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
+                                     &phy_data);
+        if(ret_val)
             return ret_val;
 
         /* Convert the enum value to ranged values */
@@ -4652,7 +4711,8 @@ e1000_get_cable_length(struct e1000_hw *
         /* Read the AGC registers for all channels */
         for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
 
-            if((ret_val = e1000_read_phy_reg(hw, agc_reg_array[i], &phy_data)))
+            ret_val = e1000_read_phy_reg(hw, agc_reg_array[i], &phy_data);
+            if(ret_val)
                 return ret_val;
 
             cur_agc = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;
@@ -4719,15 +4779,17 @@ e1000_check_polarity(struct e1000_hw *hw
 
     if(hw->phy_type == e1000_phy_m88) {
         /* return the Polarity bit in the Status register. */
-        if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
+                                     &phy_data);
+        if(ret_val)
             return ret_val;
         *polarity = (phy_data & M88E1000_PSSR_REV_POLARITY) >>
                     M88E1000_PSSR_REV_POLARITY_SHIFT;
     } else if(hw->phy_type == e1000_phy_igp) {
         /* Read the Status register to check the speed */
-        if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
+                                     &phy_data);
+        if(ret_val)
             return ret_val;
 
         /* If speed is 1000 Mbps, must read the IGP01E1000_PHY_PCS_INIT_REG to
@@ -4736,8 +4798,9 @@ e1000_check_polarity(struct e1000_hw *hw
            IGP01E1000_PSSR_SPEED_1000MBPS) {
 
             /* Read the GIG initialization PCS register (0x00B4) */
-            if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG,
-                                             &phy_data)))
+            ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG,
+                                         &phy_data);
+            if(ret_val)
                 return ret_val;
 
             /* Check the polarity bits */
@@ -4775,15 +4838,17 @@ e1000_check_downshift(struct e1000_hw *h
     DEBUGFUNC("e1000_check_downshift");
 
     if(hw->phy_type == e1000_phy_igp) {
-        if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,
+                                     &phy_data);
+        if(ret_val)
             return ret_val;
 
         hw->speed_downgraded = (phy_data & IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;
     }
     else if(hw->phy_type == e1000_phy_m88) {
-        if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
+                                     &phy_data);
+        if(ret_val)
             return ret_val;
 
         hw->speed_downgraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>
@@ -4823,7 +4888,8 @@ e1000_config_dsp_after_link_change(struc
         return E1000_SUCCESS;
 
     if(link_up) {
-        if((ret_val = e1000_get_speed_and_duplex(hw, &speed, &duplex))) {
+        ret_val = e1000_get_speed_and_duplex(hw, &speed, &duplex);
+        if(ret_val) {
             DEBUGOUT("Error getting link speed and duplex\n");
             return ret_val;
         }
@@ -4836,14 +4902,16 @@ e1000_config_dsp_after_link_change(struc
                 min_length >= e1000_igp_cable_length_50) {
 
                 for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
-                    if((ret_val = e1000_read_phy_reg(hw, dsp_reg_array[i],
-                                                     &phy_data)))
+                    ret_val = e1000_read_phy_reg(hw, dsp_reg_array[i],
+                                                 &phy_data);
+                    if(ret_val)
                         return ret_val;
 
                     phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
 
-                    if((ret_val = e1000_write_phy_reg(hw, dsp_reg_array[i],
-                                                      phy_data)))
+                    ret_val = e1000_write_phy_reg(hw, dsp_reg_array[i],
+                                                  phy_data);
+                    if(ret_val)
                         return ret_val;
                 }
                 hw->dsp_config_state = e1000_dsp_config_activated;
@@ -4856,23 +4924,26 @@ e1000_config_dsp_after_link_change(struc
                 uint32_t idle_errs = 0;
 
                 /* clear previous idle error counts */
-                if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS,
-                                                 &phy_data)))
+                ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS,
+                                             &phy_data);
+                if(ret_val)
                     return ret_val;
 
                 for(i = 0; i < ffe_idle_err_timeout; i++) {
-                    udelay(1000);
-                    if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS,
-                                                     &phy_data)))
+                    usec_delay(1000);
+                    ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS,
+                                                 &phy_data);
+                    if(ret_val)
                         return ret_val;
 
                     idle_errs += (phy_data & SR_1000T_IDLE_ERROR_CNT);
                     if(idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
                         hw->ffe_config_state = e1000_ffe_config_active;
 
-                        if((ret_val = e1000_write_phy_reg(hw,
+                        ret_val = e1000_write_phy_reg(hw,
                                     IGP01E1000_PHY_DSP_FFE,
-                                    IGP01E1000_PHY_DSP_FFE_CM_CP)))
+                                    IGP01E1000_PHY_DSP_FFE_CM_CP);
+                        if(ret_val)
                             return ret_val;
                         break;
                     }
@@ -4884,47 +4955,91 @@ e1000_config_dsp_after_link_change(struc
         }
     } else {
         if(hw->dsp_config_state == e1000_dsp_config_activated) {
-            if((ret_val = e1000_write_phy_reg(hw, 0x0000,
-                IGP01E1000_IEEE_FORCE_GIGA)))
+            ret_val = e1000_write_phy_reg(hw, 0x0000,
+                                          IGP01E1000_IEEE_FORCE_GIGA);
+            if(ret_val)
                 return ret_val;
             for(i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
-                if((ret_val = e1000_read_phy_reg(hw, dsp_reg_array[i],
-                                                 &phy_data)))
+                ret_val = e1000_read_phy_reg(hw, dsp_reg_array[i], &phy_data);
+                if(ret_val)
                     return ret_val;
 
                 phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
                 phy_data |=  IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;
 
-                if((ret_val = e1000_write_phy_reg(hw,dsp_reg_array[i],
-                                                  phy_data)))
+                ret_val = e1000_write_phy_reg(hw,dsp_reg_array[i], phy_data);
+                if(ret_val)
                     return ret_val;
             }
 
-            if((ret_val = e1000_write_phy_reg(hw, 0x0000,
-                                              IGP01E1000_IEEE_RESTART_AUTONEG)))
+            ret_val = e1000_write_phy_reg(hw, 0x0000,
+                                          IGP01E1000_IEEE_RESTART_AUTONEG);
+            if(ret_val)
                 return ret_val;
 
             hw->dsp_config_state = e1000_dsp_config_enabled;
         }
 
         if(hw->ffe_config_state == e1000_ffe_config_active) {
-            if((ret_val = e1000_write_phy_reg(hw, 0x0000,
-                                              IGP01E1000_IEEE_FORCE_GIGA)))
+            ret_val = e1000_write_phy_reg(hw, 0x0000,
+                                          IGP01E1000_IEEE_FORCE_GIGA);
+            if(ret_val)
                 return ret_val;
-            if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,
-                                              IGP01E1000_PHY_DSP_FFE_DEFAULT)))
+            ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,
+                                          IGP01E1000_PHY_DSP_FFE_DEFAULT);
+            if(ret_val)
                 return ret_val;
 
-            if((ret_val = e1000_write_phy_reg(hw, 0x0000,
-                                              IGP01E1000_IEEE_RESTART_AUTONEG)))
+            ret_val = e1000_write_phy_reg(hw, 0x0000,
+                                          IGP01E1000_IEEE_RESTART_AUTONEG);
+            if(ret_val)
                 return ret_val;
-        hw->ffe_config_state = e1000_ffe_config_enabled;
+            hw->ffe_config_state = e1000_ffe_config_enabled;
         }
     }
     return E1000_SUCCESS;
 }
 
 /*****************************************************************************
+ * Set PHY to class A mode
+ * Assumes the following operations will follow to enable the new class mode.
+ *  1. Do a PHY soft reset
+ *  2. Restart auto-negotiation or force link.
+ *
+ * hw - Struct containing variables accessed by shared code
+ ****************************************************************************/
+static int32_t
+e1000_set_phy_mode(struct e1000_hw *hw)
+{
+    int32_t ret_val;
+    uint16_t eeprom_data;
+
+    DEBUGFUNC("e1000_set_phy_mode");
+
+    if((hw->mac_type == e1000_82545_rev_3) &&
+       (hw->media_type == e1000_media_type_copper)) {
+        ret_val = e1000_read_eeprom(hw, EEPROM_PHY_CLASS_WORD, 1, &eeprom_data);
+        if(ret_val) {
+            return ret_val;
+        }
+
+        if((eeprom_data != EEPROM_RESERVED_WORD) &&
+           (eeprom_data & EEPROM_PHY_CLASS_A)) {
+            ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x000B);
+            if(ret_val)
+                return ret_val;
+            ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0x8104);
+            if(ret_val)
+                return ret_val;
+
+            hw->phy_reset_disable = FALSE;
+        }
+    }
+
+    return E1000_SUCCESS;
+}
+
+/*****************************************************************************
  *
  * This function sets the lplu state according to the active flag.  When
  * activating lplu this function also disables smart speed and vise versa.
@@ -4953,25 +5068,27 @@ e1000_set_d3_lplu_state(struct e1000_hw 
     /* During driver activity LPLU should not be used or it will attain link
      * from the lowest speeds starting from 10Mbps. The capability is used for
      * Dx transitions and states */
-    if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data)))
+    ret_val = e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data);
+    if(ret_val)
         return ret_val;
 
     if(!active) {
         phy_data &= ~IGP01E1000_GMII_FLEX_SPD;
-        if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data)))
+        ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data);
+        if(ret_val)
             return ret_val;
 
         /* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during
          * Dx states where the power conservation is most important.  During
          * driver activity we should enable SmartSpeed, so performance is
          * maintained. */
-        if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, &phy_data);
+        if(ret_val)
             return ret_val;
 
         phy_data |= IGP01E1000_PSCFR_SMART_SPEED;
-        if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
-                                          phy_data)))
+        ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, phy_data);
+        if(ret_val)
             return ret_val;
 
     } else if((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT) ||
@@ -4979,17 +5096,18 @@ e1000_set_d3_lplu_state(struct e1000_hw 
               (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_100_ALL)) {
 
         phy_data |= IGP01E1000_GMII_FLEX_SPD;
-        if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data)))
+        ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO, phy_data);
+        if(ret_val)
             return ret_val;
 
         /* When LPLU is enabled we should disable SmartSpeed */
-        if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
-                                         &phy_data)))
+        ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, &phy_data);
+        if(ret_val)
             return ret_val;
 
         phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
-        if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
-                                          phy_data)))
+        ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG, phy_data);
+        if(ret_val)
             return ret_val;
 
     }
@@ -5020,34 +5138,40 @@ e1000_set_vco_speed(struct e1000_hw *hw)
 
     /* Set PHY register 30, page 5, bit 8 to 0 */
 
-    if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
-                                     &default_page)))
+    ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, &default_page);
+    if(ret_val)
         return ret_val;
 
-    if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005)))
+    ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005);
+    if(ret_val)
         return ret_val;
 
-    if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data)))
+    ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
+    if(ret_val)
         return ret_val;
 
     phy_data &= ~M88E1000_PHY_VCO_REG_BIT8;
-    if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data)))
+    ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
+    if(ret_val)
         return ret_val;
 
     /* Set PHY register 30, page 4, bit 11 to 1 */
 
-    if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004)))
+    ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004);
+    if(ret_val)
         return ret_val;
 
-    if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data)))
+    ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
+    if(ret_val)
         return ret_val;
 
     phy_data |= M88E1000_PHY_VCO_REG_BIT11;
-    if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data)))
+    ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
+    if(ret_val)
         return ret_val;
 
-    if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
-                                      default_page)))
+    ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, default_page);
+    if(ret_val)
         return ret_val;
 
     return E1000_SUCCESS;
diff -urNp linux-2.6.5/drivers/net/e1000/e1000_hw.h linux-2.6.5.SUSE/drivers/net/e1000/e1000_hw.h
--- linux-2.6.5/drivers/net/e1000/e1000_hw.h	2004-04-04 05:38:10.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/e1000/e1000_hw.h	2004-03-11 17:51:53.000000000 +0100
@@ -369,6 +369,9 @@ int32_t e1000_set_d3_lplu_state(struct e
 
 #define E1000_82542_2_0_REV_ID 2
 #define E1000_82542_2_1_REV_ID 3
+#define E1000_REVISION_0       0
+#define E1000_REVISION_1       1
+#define E1000_REVISION_2       2
 
 #define SPEED_10    10
 #define SPEED_100   100
@@ -763,6 +766,7 @@ struct e1000_ffvt_entry {
 #define E1000_WUPL     0x05900  /* Wakeup Packet Length - RW */
 #define E1000_WUPM     0x05A00  /* Wakeup Packet Memory - RO A */
 #define E1000_FFLT     0x05F00  /* Flexible Filter Length Table - RW Array */
+#define E1000_HOST_IF  0x08800  /* Host Interface */
 #define E1000_FFMT     0x09000  /* Flexible Filter Mask Table - RW Array */
 #define E1000_FFVT     0x09800  /* Flexible Filter Value Table - RW Array */
 
@@ -899,6 +903,7 @@ struct e1000_ffvt_entry {
 #define E1000_82542_TDFT     0x08018
 #define E1000_82542_FFMT     E1000_FFMT
 #define E1000_82542_FFVT     E1000_FFVT
+#define E1000_82542_HOST_IF  E1000_HOST_IF
 
 /* Statistics counters collected by the MAC */
 struct e1000_hw_stats {
@@ -1434,6 +1439,10 @@ struct e1000_hw {
 #define E1000_MANC_TCO_RESET     0x00010000 /* TCO Reset Occurred */
 #define E1000_MANC_RCV_TCO_EN    0x00020000 /* Receive TCO Packets Enabled */
 #define E1000_MANC_REPORT_STATUS 0x00040000 /* Status Reporting Enabled */
+#define E1000_MANC_EN_MAC_ADDR_FILTER   0x00100000 /* Enable MAC address
+                                                    * filtering */
+#define E1000_MANC_EN_MNG2HOST   0x00200000 /* Enable MNG packets to host
+                                             * memory */
 #define E1000_MANC_SMB_REQ       0x01000000 /* SMBus Request */
 #define E1000_MANC_SMB_GNT       0x02000000 /* SMBus Grant */
 #define E1000_MANC_SMB_CLK_IN    0x04000000 /* SMBus Clock In */
@@ -1480,6 +1489,7 @@ struct e1000_hw {
 #define EEPROM_COMPAT                 0x0003
 #define EEPROM_ID_LED_SETTINGS        0x0004
 #define EEPROM_SERDES_AMPLITUDE       0x0006 /* For SERDES output amplitude adjustment. */
+#define EEPROM_PHY_CLASS_WORD         0x0007
 #define EEPROM_INIT_CONTROL1_REG      0x000A
 #define EEPROM_INIT_CONTROL2_REG      0x000F
 #define EEPROM_INIT_CONTROL3_PORT_B   0x0014
@@ -1513,6 +1523,9 @@ struct e1000_hw {
 /* Mask bits for SERDES amplitude adjustment in Word 6 of the EEPROM */
 #define EEPROM_SERDES_AMPLITUDE_MASK  0x000F
 
+/* Mask bit for PHY class in Word 7 of the EEPROM */
+#define EEPROM_PHY_CLASS_A   0x8000
+
 /* Mask bits for fields in Word 0x0a of the EEPROM */
 #define EEPROM_WORD0A_ILOS   0x0010
 #define EEPROM_WORD0A_SWDPIO 0x01E0
diff -urNp linux-2.6.5/drivers/net/e1000/e1000_main.c linux-2.6.5.SUSE/drivers/net/e1000/e1000_main.c
--- linux-2.6.5/drivers/net/e1000/e1000_main.c	2004-04-04 05:36:56.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/e1000/e1000_main.c	2004-03-11 17:51:53.000000000 +0100
@@ -30,7 +30,33 @@
 
 /* Change Log
  *
- * 5.2.30.1	1/29/03
+ * 5.2.39	3/12/04
+ *   o Added support to read/write eeprom data in proper order.
+ *     By default device eeprom is always little-endian, word
+ *     addressable 
+ *   o Disable TSO as the default for the driver until hangs
+ *     reported against non-IA acrhs can be root-caused.
+ *   o Back out the CSA fix for 82547 as it continues to cause
+ *     systems lock-ups with production systems.
+ *   o Fixed FC high/low water mark values to actually be in the
+ *     range of the Rx FIFO area.  It was a math error.
+ *     [Dainis Jonitis (dainis_jonitis@exigengroup.lv)]
+ *   o Handle failure to get new resources when doing ethtool
+ *     ring paramater changes.  Previously, driver would free old,
+ *     but fails to allocate new, causing problems.  Now, driver 
+ *     allocates new, and if sucessful, frees old.
+ *   o Changed collision threshold from 16 to 15 to comply with IEEE
+ *     spec.
+ *   o Toggle chip-select when checking ready status on SPI eeproms.
+ *   o Put PHY into class A mode to pass IEEE tests on some designs.
+ *     Designs with EEPROM word 0x7, bit 15 set will have their PHYs
+ *     set to class A mode, rather than the default class AB.
+ *   o Handle failures of register_netdev.  Stephen Hemminger
+ *     [shemminger@osdl.org].
+ *   o updated README & MAN pages, number of Transmit/Receive
+ *     descriptors may be denied depending on system resources.
+ *
+ * 5.2.30	1/14/03
  *   o Set VLAN filtering to IEEE 802.1Q after reset so we don't break
  *     SoL connections that use VLANs.
  *   o Allow 1000/Full setting for AutoNeg param for Fiber connections
@@ -45,30 +71,11 @@
  *   o Added ethtool RINGPARAM support.
  *
  * 5.2.22	10/15/03
- *   o Bug fix: SERDES devices might be connected to a back-plane
- *     switch that doesn't support auto-neg, so add the capability
- *     to force 1000/Full.  Also, since forcing 1000/Full, sample
- *     RxSynchronize bit to detect link state.
- *   o Bug fix: Flow control settings for hi/lo watermark didn't
- *     consider changes in the Rx FIFO size, which could occur with
- *     Jumbo Frames or with the reduced FIFO in 82547.
- *   o Better propagation of error codes. [Janice Girouard 
- *     (janiceg@us.ibm.com)].
- *   o Bug fix: hang under heavy Tx stress when running out of Tx
- *     descriptors; wasn't clearing context descriptor when backing
- *     out of send because of no-resource condition.
- *   o Bug fix: check netif_running in dev->poll so we don't have to
- *     hang in dev->close until all polls are finished.  [Robert
- *     Ollson (robert.olsson@data.slu.se)].
- *   o Revert TxDescriptor ring size back to 256 since change to 1024
- *     wasn't accepted into the kernel.
- *
- * 5.2.16	8/8/03
  */
 
 char e1000_driver_name[] = "e1000";
 char e1000_driver_string[] = "Intel(R) PRO/1000 Network Driver";
-char e1000_driver_version[] = "5.2.30.1-k2";
+char e1000_driver_version[] = "5.2.39";
 char e1000_copyright[] = "Copyright (c) 1999-2004 Intel Corporation.";
 
 /* e1000_pci_tbl - PCI Device ID Table
@@ -161,8 +168,10 @@ static boolean_t e1000_clean_rx_irq(stru
 #endif
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter);
 static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
+#ifdef SIOCGMIIPHY
 static int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,
 			   int cmd);
+#endif
 static void e1000_enter_82542_rst(struct e1000_adapter *adapter);
 static void e1000_leave_82542_rst(struct e1000_adapter *adapter);
 static inline void e1000_rx_checksum(struct e1000_adapter *adapter,
@@ -174,10 +183,12 @@ static void e1000_smartspeed(struct e100
 static inline int e1000_82547_fifo_workaround(struct e1000_adapter *adapter,
 					      struct sk_buff *skb);
 
+#ifdef NETIF_F_HW_VLAN_TX
 static void e1000_vlan_rx_register(struct net_device *netdev, struct vlan_group *grp);
 static void e1000_vlan_rx_add_vid(struct net_device *netdev, uint16_t vid);
 static void e1000_vlan_rx_kill_vid(struct net_device *netdev, uint16_t vid);
 static void e1000_restore_vlan(struct e1000_adapter *adapter);
+#endif
 
 static int e1000_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
 static int e1000_suspend(struct pci_dev *pdev, uint32_t state);
@@ -269,7 +280,9 @@ e1000_up(struct e1000_adapter *adapter)
 
 	e1000_set_multi(netdev);
 
+#ifdef NETIF_F_HW_VLAN_TX
 	e1000_restore_vlan(adapter);
+#endif
 
 	e1000_configure_tx(adapter);
 	e1000_setup_rctl(adapter);
@@ -439,15 +452,19 @@ e1000_probe(struct pci_dev *pdev,
 	netdev->set_mac_address = &e1000_set_mac;
 	netdev->change_mtu = &e1000_change_mtu;
 	netdev->do_ioctl = &e1000_ioctl;
+#ifdef HAVE_TX_TIMEOUT
 	netdev->tx_timeout = &e1000_tx_timeout;
 	netdev->watchdog_timeo = 5 * HZ;
+#endif
 #ifdef CONFIG_E1000_NAPI
 	netdev->poll = &e1000_clean;
 	netdev->weight = 64;
 #endif
+#ifdef NETIF_F_HW_VLAN_TX
 	netdev->vlan_rx_register = e1000_vlan_rx_register;
 	netdev->vlan_rx_add_vid = e1000_vlan_rx_add_vid;
 	netdev->vlan_rx_kill_vid = e1000_vlan_rx_kill_vid;
+#endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	netdev->poll_controller = e1000_netpoll;
 #endif
@@ -463,12 +480,17 @@ e1000_probe(struct pci_dev *pdev,
 	if((err = e1000_sw_init(adapter)))
 		goto err_sw_init;
 
+#ifdef MAX_SKB_FRAGS
 	if(adapter->hw.mac_type >= e1000_82543) {
+#ifdef NETIF_F_HW_VLAN_TX
 		netdev->features = NETIF_F_SG |
 				   NETIF_F_HW_CSUM |
 				   NETIF_F_HW_VLAN_TX |
 				   NETIF_F_HW_VLAN_RX |
 				   NETIF_F_HW_VLAN_FILTER;
+#else
+		netdev->features = NETIF_F_SG | NETIF_F_HW_CSUM;
+#endif
 	} else {
 		netdev->features = NETIF_F_SG;
 	}
@@ -486,6 +508,7 @@ e1000_probe(struct pci_dev *pdev,
 
 	if(pci_using_dac)
 		netdev->features |= NETIF_F_HIGHDMA;
+#endif
 
 	/* before reading the EEPROM, reset the controller to 
 	 * put the device in a known good starting state */
@@ -1560,12 +1583,15 @@ e1000_tx_map(struct e1000_adapter *adapt
 	struct e1000_buffer *buffer_info;
 	unsigned int len = skb->len, max_per_txd = E1000_MAX_DATA_PER_TXD;
 	unsigned int offset = 0, size, count = 0, i;
+#ifdef MAX_SKB_FRAGS
 #ifdef NETIF_F_TSO
 	unsigned int mss;
 #endif
 	unsigned int nr_frags;
 	unsigned int f;
+#endif
 
+#ifdef MAX_SKB_FRAGS
 #ifdef NETIF_F_TSO
 	mss = skb_shinfo(skb)->tso_size;
 	/* The controller does a simple calculation to 
@@ -1579,6 +1605,7 @@ e1000_tx_map(struct e1000_adapter *adapt
 #endif
 	nr_frags = skb_shinfo(skb)->nr_frags;
 	len -= skb->data_len;
+#endif
 
 	i = tx_ring->next_to_use;
 
@@ -1612,6 +1639,7 @@ e1000_tx_map(struct e1000_adapter *adapt
 		if(++i == tx_ring->count) i = 0;
 	}
 
+#ifdef MAX_SKB_FRAGS
 	for(f = 0; f < nr_frags; f++) {
 		struct skb_frag_struct *frag;
 
@@ -1651,6 +1679,7 @@ e1000_tx_map(struct e1000_adapter *adapt
 			if(++i == tx_ring->count) i = 0;
 		}
 	}
+#endif
 
 	if(E1000_DESC_UNUSED(&adapter->tx_ring) < count + 2) {
 
@@ -1661,7 +1690,7 @@ e1000_tx_map(struct e1000_adapter *adapt
 		 * we mapped the skb, but because of all the workarounds
 		 * (above), it's too difficult to predict how many we're
 		 * going to need.*/
-		i = adapter->tx_ring.next_to_use;
+		i = tx_ring->next_to_use;
 
 		if(i == first) {
 			/* Cleanup after e1000_tx_[csum|tso] scribbling
@@ -1686,7 +1715,7 @@ e1000_tx_map(struct e1000_adapter *adapt
 			if(++i == tx_ring->count) i = 0;
 		}
 
-		adapter->tx_ring.next_to_use = first;
+		tx_ring->next_to_use = first;
 
 		return 0;
 	}
@@ -1694,7 +1723,7 @@ e1000_tx_map(struct e1000_adapter *adapt
 	i = (i == 0) ? tx_ring->count - 1 : i - 1;
 	tx_ring->buffer_info[i].skb = skb;
 	tx_ring->buffer_info[first].next_to_watch = i;
-
+	
 	return count;
 }
 
@@ -1810,10 +1839,12 @@ e1000_xmit_frame(struct sk_buff *skb, st
 		}
 	}
 
+#ifdef NETIF_F_HW_VLAN_TX
 	if(adapter->vlgrp && vlan_tx_tag_present(skb)) {
 		tx_flags |= E1000_TX_FLAGS_VLAN;
 		tx_flags |= (vlan_tx_tag_get(skb) << E1000_TX_FLAGS_VLAN_SHIFT);
 	}
+#endif
 
 	first = adapter->tx_ring.next_to_use;
 	
@@ -2138,6 +2169,27 @@ e1000_intr(int irq, void *data, struct p
 		   !e1000_clean_tx_irq(adapter))
 			break;
 #endif
+#ifdef E1000_COUNT_ICR
+	adapter->icr_txdw += icr & 0x01;
+	icr >>= 1;
+	adapter->icr_txqe += icr & 0x01;
+	icr >>= 1;
+	adapter->icr_lsc += icr & 0x01;
+	icr >>= 1;
+	adapter->icr_rxseq += icr & 0x01;
+	icr >>= 1;
+	adapter->icr_rxdmt += icr & 0x01;
+	icr >>= 2;
+	adapter->icr_rxo += icr & 0x01;
+	icr >>= 1;
+	adapter->icr_rxt += icr & 0x01;
+	icr >>= 2;
+	adapter->icr_mdac += icr & 0x01;
+	icr >>= 1;
+	adapter->icr_rxcfg += icr & 0x01;
+	icr >>= 1;
+	adapter->icr_gpi += icr & 0x01;
+#endif
 
 	return IRQ_HANDLED;
 }
@@ -2338,6 +2390,7 @@ e1000_clean_rx_irq(struct e1000_adapter 
 
 		skb->protocol = eth_type_trans(skb, netdev);
 #ifdef CONFIG_E1000_NAPI
+#ifdef NETIF_F_HW_VLAN_TX
 		if(adapter->vlgrp && (rx_desc->status & E1000_RXD_STAT_VP)) {
 			vlan_hwaccel_receive_skb(skb, adapter->vlgrp,
 				le16_to_cpu(rx_desc->special &
@@ -2345,7 +2398,11 @@ e1000_clean_rx_irq(struct e1000_adapter 
 		} else {
 			netif_receive_skb(skb);
 		}
+#else
+		netif_receive_skb(skb);
+#endif
 #else /* CONFIG_E1000_NAPI */
+#ifdef NETIF_F_HW_VLAN_TX
 		if(adapter->vlgrp && (rx_desc->status & E1000_RXD_STAT_VP)) {
 			vlan_hwaccel_rx(skb, adapter->vlgrp,
 				le16_to_cpu(rx_desc->special &
@@ -2353,6 +2410,9 @@ e1000_clean_rx_irq(struct e1000_adapter 
 		} else {
 			netif_rx(skb);
 		}
+#else
+		netif_rx(skb);
+#endif
 #endif /* CONFIG_E1000_NAPI */
 		netdev->last_rx = jiffies;
 
@@ -2502,17 +2562,22 @@ static int
 e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
 {
 	switch (cmd) {
+#ifdef SIOCGMIIPHY
 	case SIOCGMIIPHY:
 	case SIOCGMIIREG:
 	case SIOCSMIIREG:
 		return e1000_mii_ioctl(netdev, ifr, cmd);
+#endif
+#ifdef SIOCETHTOOL
 	case SIOCETHTOOL:
 		return e1000_ethtool_ioctl(netdev, ifr);
+#endif
 	default:
 		return -EOPNOTSUPP;
 	}
 }
 
+#ifdef SIOCGMIIPHY
 /**
  * e1000_mii_ioctl -
  * @netdev:
@@ -2592,6 +2657,7 @@ e1000_mii_ioctl(struct net_device *netde
 	}
 	return E1000_SUCCESS;
 }
+#endif
 
 /**
  * e1000_rx_checksum - Receive Checksum Offload for 82543
@@ -2633,7 +2699,13 @@ e1000_pci_set_mwi(struct e1000_hw *hw)
 {
 	struct e1000_adapter *adapter = hw->back;
 
+#ifdef HAVE_PCI_SET_MWI
 	pci_set_mwi(adapter->pdev);
+#else
+	pci_write_config_word(adapter->pdev, PCI_COMMAND,
+			      adapter->hw.pci_cmd_word |
+			      PCI_COMMAND_INVALIDATE);
+#endif
 }
 
 void
@@ -2641,7 +2713,13 @@ e1000_pci_clear_mwi(struct e1000_hw *hw)
 {
 	struct e1000_adapter *adapter = hw->back;
 
+#ifdef HAVE_PCI_SET_MWI
 	pci_clear_mwi(adapter->pdev);
+#else
+	pci_write_config_word(adapter->pdev, PCI_COMMAND,
+			      adapter->hw.pci_cmd_word &
+			      ~PCI_COMMAND_INVALIDATE);
+#endif
 }
 
 void
@@ -2672,6 +2750,7 @@ e1000_io_write(struct e1000_hw *hw, unsi
 	outl(value, port);
 }
 
+#ifdef NETIF_F_HW_VLAN_TX
 static void
 e1000_vlan_rx_register(struct net_device *netdev, struct vlan_group *grp)
 {
@@ -2760,6 +2839,7 @@ e1000_restore_vlan(struct e1000_adapter 
 		}
 	}
 }
+#endif
 
 int
 e1000_set_spd_dplx(struct e1000_adapter *adapter, uint16_t spddplx)
diff -urNp linux-2.6.5/drivers/net/e1000/e1000_osdep.h linux-2.6.5.SUSE/drivers/net/e1000/e1000_osdep.h
--- linux-2.6.5/drivers/net/e1000/e1000_osdep.h	2004-04-04 05:36:45.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/e1000/e1000_osdep.h	2004-03-11 17:51:53.000000000 +0100
@@ -40,7 +40,9 @@
 #include <asm/io.h>
 #include <linux/interrupt.h>
 #include <linux/sched.h>
+#include "kcompat.h"
 
+#define usec_delay(x) udelay(x)
 #ifndef msec_delay
 #define msec_delay(x)	do { if(in_interrupt()) { \
 				/* Don't mdelay in interrupt context! */ \
diff -urNp linux-2.6.5/drivers/net/e1000/e1000_param.c linux-2.6.5.SUSE/drivers/net/e1000/e1000_param.c
--- linux-2.6.5/drivers/net/e1000/e1000_param.c	2004-04-04 05:37:37.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/net/e1000/e1000_param.c	2004-03-11 17:51:53.000000000 +0100
@@ -107,7 +107,7 @@ E1000_PARAM(Duplex, "Duplex setting");
 
 /* Auto-negotiation Advertisement Override
  *
- * Valid Range: 0x01-0x0F, 0x20-0x2F
+ * Valid Range: 0x01-0x0F, 0x20-0x2F (copper); 0x20 (fiber)
  *
  * The AutoNeg value is a bit mask describing which speed and duplex
  * combinations should be advertised during auto-negotiation.
@@ -117,7 +117,7 @@ E1000_PARAM(Duplex, "Duplex setting");
  * Speed (Mbps)  N/A   N/A   1000   N/A    100   100   10     10
  * Duplex                    Full          Full  Half  Full   Half
  *
- * Default Value: 0x2F
+ * Default Value: 0x2F (copper); 0x20 (fiber)
  */
 
 E1000_PARAM(AutoNeg, "Advertised auto-negotiation setting");
diff -urNp linux-2.6.5/drivers/net/e1000/kcompat.c linux-2.6.5.SUSE/drivers/net/e1000/kcompat.c
--- linux-2.6.5/drivers/net/e1000/kcompat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e1000/kcompat.c	2004-03-11 17:51:53.000000000 +0100
@@ -0,0 +1,170 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+#include "kcompat.h"
+
+/*****************************************************************************/
+/* 2.4.13 => 2.4.3 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,13) )
+
+/**************************************/
+/* PCI DMA MAPPING */
+
+#if defined(CONFIG_HIGHMEM)
+
+#ifndef PCI_DRAM_OFFSET
+#define PCI_DRAM_OFFSET 0
+#endif
+
+u64 _kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset, size_t size, int direction)
+{
+	return (((u64)(page - mem_map) << PAGE_SHIFT) + offset + PCI_DRAM_OFFSET);
+}
+
+#else /* CONFIG_HIGHMEM */
+
+u64 _kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset, size_t size, int direction)
+{
+	return pci_map_single(dev, (void *)page_address(page) + offset, size, direction);
+}
+
+#endif /* CONFIG_HIGHMEM */
+
+void _kc_pci_unmap_page(struct pci_dev *dev, u64 dma_addr, size_t size, int direction)
+{
+	return pci_unmap_single(dev, dma_addr, size, direction);
+}
+
+#endif /* 2.4.13 => 2.4.3 */
+
+
+/*****************************************************************************/
+/* 2.4.3 => 2.4.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) )
+
+/**************************************/
+/* PCI DRIVER API */
+
+int _kc_pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask)
+{
+	if(!pci_dma_supported(dev, mask))
+		return -EIO;
+	dev->dma_mask = mask;
+	return 0;
+}
+
+int _kc_pci_request_regions(struct pci_dev *dev, char *res_name)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		if (pci_resource_len(dev, i) == 0)
+			continue;
+
+		if (pci_resource_flags(dev, i) & IORESOURCE_IO) {
+			if (!request_region(pci_resource_start(dev, i), pci_resource_len(dev, i), res_name)) {
+				pci_release_regions(dev);
+				return -EBUSY;
+			}
+		} else if (pci_resource_flags(dev, i) & IORESOURCE_MEM) {
+			if (!request_mem_region(pci_resource_start(dev, i), pci_resource_len(dev, i), res_name)) {
+				pci_release_regions(dev);
+				return -EBUSY;
+			}
+		}
+	}
+	return 0;
+}
+
+void _kc_pci_release_regions(struct pci_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		if (pci_resource_len(dev, i) == 0)
+			continue;
+
+		if (pci_resource_flags(dev, i) & IORESOURCE_IO)
+			release_region(pci_resource_start(dev, i), pci_resource_len(dev, i));
+
+		else if (pci_resource_flags(dev, i) & IORESOURCE_MEM)
+			release_mem_region(pci_resource_start(dev, i), pci_resource_len(dev, i));
+	}
+}
+
+/**************************************/
+/* NETWORK DRIVER API */
+
+struct net_device * _kc_alloc_etherdev(int sizeof_priv)
+{
+	struct net_device *dev;
+	int alloc_size;
+
+	alloc_size = sizeof (*dev) + sizeof_priv + IFNAMSIZ + 31;
+
+	dev = kmalloc(alloc_size, GFP_KERNEL);
+
+	if (!dev) return NULL;
+
+	memset(dev, 0, alloc_size);
+
+	if (sizeof_priv)
+		dev->priv = (void *) (((unsigned long)(dev + 1) + 31) & ~31);
+
+	dev->name[0] = '\0';
+
+	ether_setup(dev);
+
+	return dev;
+}
+
+int _kc_is_valid_ether_addr(u8 *addr)
+{
+	const char zaddr[6] = {0,};
+
+	return !(addr[0]&1) && memcmp( addr, zaddr, 6);
+}
+
+#endif /* 2.4.3 => 2.4.0 */
+
+
+/*****************************************************************************/
+/* 2.4.6 => 2.4.3 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) )
+
+int _kc_pci_set_power_state(struct pci_dev *dev, int state)
+{ return 0; }
+int _kc_pci_save_state(struct pci_dev *dev, u32 *buffer)
+{ return 0; }
+int _kc_pci_restore_state(struct pci_dev *pdev, u32 *buffer)
+{ return 0; }
+int _kc_pci_enable_wake(struct pci_dev *pdev, u32 state, int enable)
+{ return 0; }
+
+#endif /* 2.4.6 => 2.4.3 */
+
diff -urNp linux-2.6.5/drivers/net/e1000/kcompat.h linux-2.6.5.SUSE/drivers/net/e1000/kcompat.h
--- linux-2.6.5/drivers/net/e1000/kcompat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/net/e1000/kcompat.h	2004-03-11 17:51:53.000000000 +0100
@@ -0,0 +1,330 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+#ifndef _KCOMPAT_H_
+#define _KCOMPAT_H_
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+
+#ifndef IRQ_HANDLED
+#define irqreturn_t void
+#define IRQ_HANDLED
+#define IRQ_NONE
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(x)	kfree(x)
+#endif
+
+#ifdef HAVE_POLL_CONTROLLER
+#define CONFIG_NET_POLL_CONTROLLER
+#endif
+
+#ifdef E1000_NAPI
+#undef CONFIG_E1000_NAPI
+#define CONFIG_E1000_NAPI
+#endif
+
+#ifdef E1000_NO_NAPI
+#undef CONFIG_E1000_NAPI
+#endif
+
+/*****************************************************************************/
+#ifndef unlikely
+#define unlikely(_x) _x
+#define likely(_x) _x
+#endif
+/*****************************************************************************/
+
+/*****************************************************************************/
+/* Installations with ethtool version without eeprom, adapter id, or statistics
+ * support */
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS 0x1d
+#undef ethtool_drvinfo
+#define ethtool_drvinfo k_ethtool_drvinfo
+struct k_ethtool_drvinfo {
+	uint32_t cmd;
+	char	 driver[32];
+	char	 version[32];
+	char	 fw_version[32];
+	char	 bus_info[32];
+	char	 reserved1[32];
+	char	 reserved2[16];
+	uint32_t n_stats;
+	uint32_t testinfo_len;
+	uint32_t eedump_len;
+	uint32_t regdump_len;
+};
+
+struct ethtool_stats {
+	uint32_t cmd;
+	uint32_t n_stats;
+	uint64_t data[0];
+};
+
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID 0x1c
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS 0x1b
+enum ethtool_stringset {
+	ETH_SS_TEST             = 0,
+	ETH_SS_STATS,
+};
+struct ethtool_gstrings {
+	u32     cmd;            /* ETHTOOL_GSTRINGS */
+	u32     string_set;     /* string set id e.c. ETH_SS_TEST, etc*/
+	u32     len;            /* number of strings in the string set */
+	u8      data[0];
+};
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST 0x1a
+enum ethtool_test_flags {
+	ETH_TEST_FL_OFFLINE	= (1 << 0),
+	ETH_TEST_FL_FAILED	= (1 << 1),
+};
+struct ethtool_test {
+	uint32_t cmd;
+	uint32_t flags;
+	uint32_t reserved;
+	uint32_t len;
+	uint64_t data[0];
+};
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM 0xb
+#undef ETHTOOL_GREGS
+struct ethtool_eeprom {
+	uint32_t cmd;
+	uint32_t magic;
+	uint32_t offset;
+	uint32_t len;
+	uint8_t	 data[0];
+};
+
+struct ethtool_value {
+	uint32_t cmd;
+	uint32_t data;
+};
+
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK 0xa
+#endif /* Ethtool version without link support */
+#endif /* Ethtool version without eeprom support */
+#endif /* Ethtool version without test support */
+#endif /* Ethtool version without strings support */
+#endif /* Ethtool version wihtout adapter id support */
+#endif /* Ethtool version without statistics support */
+
+/*****************************************************************************/
+/* 2.4.3 => 2.4.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) )
+
+/**************************************/
+/* PCI DRIVER API */
+
+#ifndef pci_set_dma_mask
+#define pci_set_dma_mask _kc_pci_set_dma_mask
+extern int _kc_pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask);
+#endif
+
+#ifndef pci_request_regions
+#define pci_request_regions _kc_pci_request_regions
+extern int _kc_pci_request_regions(struct pci_dev *pdev, char *res_name);
+#endif
+
+#ifndef pci_release_regions
+#define pci_release_regions _kc_pci_release_regions
+extern void _kc_pci_release_regions(struct pci_dev *pdev);
+#endif
+
+/**************************************/
+/* NETWORK DRIVER API */
+
+#ifndef alloc_etherdev
+#define alloc_etherdev _kc_alloc_etherdev
+extern struct net_device * _kc_alloc_etherdev(int sizeof_priv);
+#endif
+
+#ifndef is_valid_ether_addr
+#define is_valid_ether_addr _kc_is_valid_ether_addr
+extern int _kc_is_valid_ether_addr(u8 *addr);
+#endif
+
+/**************************************/
+/* MISCELLANEOUS */
+
+#ifndef INIT_TQUEUE
+#define INIT_TQUEUE(_tq, _routine, _data)		\
+	do {						\
+		INIT_LIST_HEAD(&(_tq)->list);		\
+		(_tq)->sync = 0;			\
+		(_tq)->routine = _routine;		\
+		(_tq)->data = _data;			\
+	} while(0)
+#endif
+
+#endif /* 2.4.3 => 2.4.0 */
+
+/*****************************************************************************/
+/* 2.4.6 => 2.4.3 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) )
+
+#ifndef pci_set_power_state
+#define pci_set_power_state _kc_pci_set_power_state
+extern int _kc_pci_set_power_state(struct pci_dev *dev, int state);
+#endif
+
+#ifndef pci_save_state
+#define pci_save_state _kc_pci_save_state
+extern int _kc_pci_save_state(struct pci_dev *dev, u32 *buffer);
+#endif
+
+#ifndef pci_restore_state
+#define pci_restore_state _kc_pci_restore_state
+extern int _kc_pci_restore_state(struct pci_dev *pdev, u32 *buffer);
+#endif
+
+#ifndef pci_enable_wake
+#define pci_enable_wake _kc_pci_enable_wake
+extern int _kc_pci_enable_wake(struct pci_dev *pdev, u32 state, int enable);
+#endif
+
+/* PCI PM entry point syntax changed, so don't support suspend/resume */
+#undef CONFIG_PM
+
+#endif /* 2.4.6 => 2.4.3 */
+
+/*****************************************************************************/
+/* 2.4.10 => 2.4.6 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10) )
+
+/**************************************/
+/* MODULE API */
+
+#ifndef MODULE_LICENSE
+	#define MODULE_LICENSE(X)
+#endif
+
+/**************************************/
+/* OTHER */
+
+#undef min
+#define min(x,y) ({ \
+	const typeof(x) _x = (x);	\
+	const typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x < _y ? _x : _y; })
+
+#undef max
+#define max(x,y) ({ \
+	const typeof(x) _x = (x);	\
+	const typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x > _y ? _x : _y; })
+
+#endif /* 2.4.10 -> 2.4.6 */
+
+
+/*****************************************************************************/
+/* 2.4.13 => 2.4.10 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,13) )
+
+/**************************************/
+/* PCI DMA MAPPING */
+
+#ifndef virt_to_page
+	#define virt_to_page(v) (mem_map + (virt_to_phys(v) >> PAGE_SHIFT))
+#endif
+
+#ifndef pci_map_page
+#define pci_map_page _kc_pci_map_page
+extern u64 _kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset, size_t size, int direction);
+#endif
+
+#ifndef pci_unmap_page
+#define pci_unmap_page _kc_pci_unmap_page
+extern void _kc_pci_unmap_page(struct pci_dev *dev, u64 dma_addr, size_t size, int direction);
+#endif
+
+/* pci_set_dma_mask takes dma_addr_t, which is only 32-bits prior to 2.4.13 */
+
+#undef PCI_DMA_32BIT
+#define PCI_DMA_32BIT	0xffffffff
+#undef PCI_DMA_64BIT
+#define PCI_DMA_64BIT	0xffffffff
+
+#endif /* 2.4.13 => 2.4.10 */
+
+/*****************************************************************************/
+/* 2.4.17 => 2.4.12 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,17) )
+
+#ifndef __devexit_p
+	#define __devexit_p(x) &(x)
+#endif
+
+#endif /* 2.4.17 => 2.4.13 */
+
+/*****************************************************************************/
+/* 2.4.22 => 2.4.17 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22) )
+#define pci_name(x)	((x)->slot_name)
+#endif
+
+/*****************************************************************************/
+/* 2.5.28 => 2.4.22 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,5,28) )
+
+static inline void _kc_synchronize_irq() { synchronize_irq(); }
+#undef synchronize_irq
+#define synchronize_irq(X) _kc_synchronize_irq()
+
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#define INIT_WORK INIT_TQUEUE
+#define schedule_work schedule_task
+
+#endif /* 2.5.28 => 2.4.17 */
+
+#endif /* _KCOMPAT_H_ */
+
