From: Robert Love <robert.w.love@intel.com>
Subject: use an operations structure for rport callbacks
References: bnc #459142

This was called out for the disc callbacks in review
comments when submitting to linux-scsi. It needed to be
fixed for the rport callbacks too.

This patch also fixes some spacing in the fc_rport
structure definition as well as renaming the fc_lport_rport_event()
function to fc_lport_rport_callback() to more clearly
identify what it's doing.

Signed-off-by: Robert Love <robert.w.love@intel.com>
Acked-by: Bernhard Walle <bwalle@suse.de>
---

 drivers/scsi/libfc/fc_disc.c  |   18 +++++++++-----
 drivers/scsi/libfc/fc_lport.c |   16 ++++++++-----
 drivers/scsi/libfc/fc_rport.c |   19 +++++++--------
 include/scsi/libfc.h          |   51 ++++++++++++++++++++++--------------------
 4 files changed, 57 insertions(+), 47 deletions(-)


--- a/drivers/scsi/libfc/fc_disc.c
+++ b/drivers/scsi/libfc/fc_disc.c
@@ -154,7 +154,7 @@ void fc_disc_stop_rports(struct fc_disc
 }
 
 /**
- * fc_disc_rport_event - Event handler for rport events
+ * fc_disc_rport_callback - Event handler for rport events
  * @lport: The lport which is receiving the event
  * @rport: The rport which the event has occured on
  * @event: The event that occured
@@ -162,9 +162,9 @@ void fc_disc_stop_rports(struct fc_disc
  * Locking Note: The rport lock should not be held when calling
  *		 this function.
  */
-static void fc_disc_rport_event(struct fc_lport *lport,
-				struct fc_rport *rport,
-				enum fc_lport_event event)
+static void fc_disc_rport_callback(struct fc_lport *lport,
+				   struct fc_rport *rport,
+				   enum fc_rport_event event)
 {
 	struct fc_rport_libfc_priv *rdata = rport->dd_data;
 	struct fc_disc *disc = lport->disc;
@@ -420,6 +420,10 @@ static void fc_disc_start(void (*disc_ca
 	mutex_unlock(&disc->disc_mutex);
 }
 
+static struct fc_rport_operations fc_disc_rport_ops = {
+	.event_callback = fc_disc_rport_callback,
+};
+
 /**
  * fc_disc_new_target - Handle new target found by discovery
  * @lport: FC local port
@@ -475,7 +479,7 @@ static int fc_disc_new_target(struct fc_
 		}
 		if (rport) {
 			rp = rport->dd_data;
-			rp->event_callback = fc_disc_rport_event;
+			rp->ops = &fc_disc_rport_ops;
 			rp->rp_state = RPORT_ST_INIT;
 			lport->tt.rport_login(rport);
 		}
@@ -658,7 +662,7 @@ static int fc_disc_gpn_ft_parse(struct f
 			rport = fc_rport_rogue_create(&dp);
 			if (rport) {
 				rdata = rport->dd_data;
-				rdata->event_callback = fc_disc_rport_event;
+				rdata->ops = &fc_disc_rport_ops;
 				rdata->local_port = lport;
 				lport->tt.rport_login(rport);
 			} else
@@ -812,7 +816,7 @@ static void fc_disc_single(struct fc_dis
 	new_rport = fc_rport_rogue_create(dp);
 	if (new_rport) {
 		rdata = new_rport->dd_data;
-		rdata->event_callback = fc_disc_rport_event;
+		rdata->ops = &fc_disc_rport_ops;
 		kfree(dp);
 		lport->tt.rport_login(new_rport);
 	}
--- a/drivers/scsi/libfc/fc_lport.c
+++ b/drivers/scsi/libfc/fc_lport.c
@@ -38,7 +38,7 @@
  * hold the rport's mutex, but not the other way around.
  *
  * The only complication to this rule is the callbacks from the rport to
- * the lport's event_callback function. When rports become READY they make
+ * the lport's rport_callback function. When rports become READY they make
  * a callback to the lport so that it can track them. In the case of the
  * directory server that callback might cause the lport to change its
  * state, implying that the lport mutex would need to be held. This problem
@@ -125,7 +125,7 @@ static int fc_frame_drop(struct fc_lport
 }
 
 /**
- * fc_lport_rport_event - Event handler for rport events
+ * fc_lport_rport_callback - Event handler for rport events
  * @lport: The lport which is receiving the event
  * @rport: The rport which the event has occured on
  * @event: The event that occured
@@ -133,9 +133,9 @@ static int fc_frame_drop(struct fc_lport
  * Locking Note: The rport lock should not be held when calling
  *		 this function.
  */
-static void fc_lport_rport_event(struct fc_lport *lport,
-				 struct fc_rport *rport,
-				 enum fc_lport_event event)
+static void fc_lport_rport_callback(struct fc_lport *lport,
+				    struct fc_rport *rport,
+				    enum fc_rport_event event)
 {
 	FC_DEBUG_LPORT("Received a %d event for port (%6x)\n", event,
 		       rport->port_id);
@@ -1265,6 +1265,10 @@ static void fc_lport_enter_rpn_id(struct
 		fc_lport_error(lport, fp);
 }
 
+static struct fc_rport_operations fc_lport_rport_ops = {
+	.event_callback = fc_lport_rport_callback,
+};
+
 /**
  * fc_rport_enter_dns - Create a rport to the name server
  * @lport: Fibre Channel local port requesting a rport for the name server
@@ -1294,7 +1298,7 @@ static void fc_lport_enter_dns(struct fc
 		goto err;
 
 	rdata = rport->dd_data;
-	rdata->event_callback = fc_lport_rport_event;
+	rdata->ops = &fc_lport_rport_ops;
 	lport->tt.rport_login(rport);
 	return;
 
--- a/drivers/scsi/libfc/fc_rport.c
+++ b/drivers/scsi/libfc/fc_rport.c
@@ -125,7 +125,7 @@ struct fc_rport *fc_rport_rogue_create(s
 	rdata->rp_state = RPORT_ST_INIT;
 	rdata->event = RPORT_EV_NONE;
 	rdata->flags = FC_RP_FLAGS_REC_SUPPORTED;
-	rdata->event_callback = NULL;
+	rdata->ops = NULL;
 	rdata->e_d_tov = dp->lp->e_d_tov;
 	rdata->r_a_tov = dp->lp->r_a_tov;
 	INIT_DELAYED_WORK(&rdata->retry_work, fc_rport_timeout);
@@ -216,16 +216,15 @@ static void fc_rport_work(struct work_st
 {
 	struct fc_rport_libfc_priv *rdata =
 		container_of(work, struct fc_rport_libfc_priv, event_work);
-	enum fc_lport_event event;
+	enum fc_rport_event event;
 	enum fc_rport_trans_state trans_state;
 	struct fc_lport *lport = rdata->local_port;
-	void (*event_callback)(struct fc_lport *, struct fc_rport *,
-			       enum fc_lport_event);
+	struct fc_rport_operations *rport_ops;
 	struct fc_rport *rport = PRIV_TO_RPORT(rdata);
 
 	mutex_lock(&rdata->rp_mutex);
 	event = rdata->event;
-	event_callback = rdata->event_callback;
+	rport_ops = rdata->ops;
 
 	if (event == RPORT_EV_CREATED) {
 		struct fc_rport *new_rport;
@@ -250,7 +249,7 @@ static void fc_rport_work(struct work_st
 			new_rdata = new_rport->dd_data;
 			new_rdata->e_d_tov = rdata->e_d_tov;
 			new_rdata->r_a_tov = rdata->r_a_tov;
-			new_rdata->event_callback = rdata->event_callback;
+			new_rdata->ops = rdata->ops;
 			new_rdata->local_port = rdata->local_port;
 			new_rdata->flags = FC_RP_FLAGS_REC_SUPPORTED;
 			new_rdata->trans_state = FC_PORTSTATE_REAL;
@@ -269,15 +268,15 @@ static void fc_rport_work(struct work_st
 		fc_rport_rogue_destroy(rport);
 		rport = new_rport;
 		rdata = new_rport->dd_data;
-		if (event_callback)
-			event_callback(lport, rport, event);
+		if (rport_ops->event_callback)
+			rport_ops->event_callback(lport, rport, event);
 	} else if ((event == RPORT_EV_FAILED) ||
 		   (event == RPORT_EV_LOGO) ||
 		   (event == RPORT_EV_STOP)) {
 		trans_state = rdata->trans_state;
 		mutex_unlock(&rdata->rp_mutex);
-		if (event_callback)
-			event_callback(lport, rport, event);
+		if (rport_ops->event_callback)
+			rport_ops->event_callback(lport, rport, event);
 		if (trans_state == FC_PORTSTATE_ROGUE)
 			fc_rport_rogue_destroy(rport);
 		else
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -89,14 +89,6 @@ enum fc_disc_event {
 	DISC_EV_FAILED
 };
 
-enum fc_lport_event {
-	RPORT_EV_NONE = 0,
-	RPORT_EV_CREATED,
-	RPORT_EV_FAILED,
-	RPORT_EV_STOP,
-	RPORT_EV_LOGO
-};
-
 enum fc_rport_state {
 	RPORT_ST_NONE = 0,
 	RPORT_ST_INIT,		/* initialized */
@@ -126,6 +118,19 @@ struct fc_disc_port {
 	struct work_struct	    rport_work;
 };
 
+enum fc_rport_event {
+	RPORT_EV_NONE = 0,
+	RPORT_EV_CREATED,
+	RPORT_EV_FAILED,
+	RPORT_EV_STOP,
+	RPORT_EV_LOGO
+};
+
+struct fc_rport_operations {
+	void (*event_callback)(struct fc_lport *, struct fc_rport *,
+			       enum fc_rport_event);
+};
+
 /**
  * struct fc_rport_libfc_priv - libfc internal information about a remote port
  * @local_port: Fibre Channel host port instance
@@ -140,24 +145,22 @@ struct fc_disc_port {
  * @event_callback: Callback for rport READY, FAILED or LOGO
  */
 struct fc_rport_libfc_priv {
-	struct fc_lport		*local_port;
-	enum fc_rport_state rp_state;
-	u16			flags;
+	struct fc_lport		   *local_port;
+	enum fc_rport_state        rp_state;
+	u16			   flags;
 	#define FC_RP_FLAGS_REC_SUPPORTED	(1 << 0)
 	#define FC_RP_FLAGS_RETRY		(1 << 1)
-	u16		max_seq;
-	unsigned int	retries;
-	unsigned int	e_d_tov;
-	unsigned int	r_a_tov;
-	enum fc_rport_trans_state trans_state;
-	struct mutex    rp_mutex;
-	struct delayed_work	retry_work;
-	enum fc_lport_event     event;
-	void (*event_callback)(struct fc_lport *,
-			       struct fc_rport *,
-			       enum fc_lport_event);
-	struct list_head         peers;
-	struct work_struct       event_work;
+	u16		           max_seq;
+	unsigned int	           retries;
+	unsigned int	           e_d_tov;
+	unsigned int	           r_a_tov;
+	enum fc_rport_trans_state  trans_state;
+	struct mutex               rp_mutex;
+	struct delayed_work	   retry_work;
+	enum fc_rport_event        event;
+	struct fc_rport_operations *ops;
+	struct list_head           peers;
+	struct work_struct         event_work;
 };
 
 #define PRIV_TO_RPORT(x)						\
