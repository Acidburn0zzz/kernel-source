From: Takashi Iwai <tiwai@suse.de>
Subject: Fix SPDIF I/O on HDA codecs
Patch-mainline: not yet
References: 

Fix SPDIF I/O on HDA codecs.

Signed-off-by: Takashi Iwai <tiwai@suse.de>


diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.10/sound/pci/hda/hda_codec.c linux/sound/pci/hda/hda_codec.c
--- linux-2.6.10/sound/pci/hda/hda_codec.c	2005-02-24 17:26:05.000000000 +0100
+++ linux/sound/pci/hda/hda_codec.c	2005-02-22 18:16:49.000000000 +0100
@@ -992,7 +992,7 @@ static snd_kcontrol_new_t dig_mixes[] = 
 };
 
 /**
- * snd_hda_create_spdif_out_ctls - create SPDIF-related controls
+ * snd_hda_create_spdif_out_ctls - create Output SPDIF-related controls
  * @codec: the HDA codec
  * @nid: audio out widget NID
  *
@@ -1018,6 +1018,98 @@ int snd_hda_create_spdif_out_ctls(struct
 	return 0;
 }
 
+/*
+ * SPDIF input
+ */
+
+#define snd_hda_spdif_in_switch_info	snd_hda_spdif_out_switch_info
+
+static int snd_hda_spdif_in_switch_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] = codec->spdif_in_enable;
+	return 0;
+}
+
+static int snd_hda_spdif_in_switch_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	hda_nid_t nid = kcontrol->private_value;
+	unsigned int val = !!ucontrol->value.integer.value[0];
+	int change;
+
+	down(&codec->spdif_mutex);
+	change = codec->spdif_in_enable != val;
+	if (change || codec->in_resume) {
+		codec->spdif_in_enable = val;
+		snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_DIGI_CONVERT_1, val);
+	}
+	up(&codec->spdif_mutex);
+	return change;
+}
+
+static int snd_hda_spdif_in_status_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	hda_nid_t nid = kcontrol->private_value;
+	unsigned short val;
+	unsigned int sbits;
+
+	val = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_DIGI_CONVERT, 0);
+	sbits = convert_to_spdif_status(val);
+	ucontrol->value.iec958.status[0] = sbits;
+	ucontrol->value.iec958.status[1] = sbits >> 8;
+	ucontrol->value.iec958.status[2] = sbits >> 16;
+	ucontrol->value.iec958.status[3] = sbits >> 24;
+	return 0;
+}
+
+static snd_kcontrol_new_t dig_in_ctls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH),
+		.info = snd_hda_spdif_in_switch_info,
+		.get = snd_hda_spdif_in_switch_get,
+		.put = snd_hda_spdif_in_switch_put,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = SNDRV_CTL_NAME_IEC958("",CAPTURE,DEFAULT),
+		.info = snd_hda_spdif_mask_info,
+		.get = snd_hda_spdif_in_status_get,
+	},
+	{ } /* end */
+};
+
+/**
+ * snd_hda_create_spdif_in_ctls - create Input SPDIF-related controls
+ * @codec: the HDA codec
+ * @nid: audio in widget NID
+ *
+ * Creates controls related with the SPDIF input.
+ * Called from each patch supporting the SPDIF in.
+ *
+ * Returns 0 if successful, or a negative error code.
+ */
+int snd_hda_create_spdif_in_ctls(struct hda_codec *codec, hda_nid_t nid)
+{
+	int err;
+	snd_kcontrol_t *kctl;
+	snd_kcontrol_new_t *dig_mix;
+
+	for (dig_mix = dig_in_ctls; dig_mix->name; dig_mix++) {
+		kctl = snd_ctl_new1(dig_mix, codec);
+		kctl->private_value = nid;
+		if ((err = snd_ctl_add(codec->bus->card, kctl)) < 0)
+			return err;
+	}
+	codec->spdif_in_enable = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_DIGI_CONVERT, 0) & 1;
+	return 0;
+}
+
+
 /**
  * snd_hda_build_controls - build mixer controls
  * @bus: the BUS
@@ -1704,13 +1796,22 @@ int snd_hda_resume_ctls(struct hda_codec
 }
 
 /**
- * snd_hda_resume_spdi_out - resume the digital I/O
+ * snd_hda_resume_spdif_out - resume the digital out
  * @codec: the HDA codec
  */
 int snd_hda_resume_spdif_out(struct hda_codec *codec)
 {
 	return snd_hda_resume_ctls(codec, dig_mixes);
 }
+
+/**
+ * snd_hda_resume_spdif_in - resume the digital in
+ * @codec: the HDA codec
+ */
+int snd_hda_resume_spdif_in(struct hda_codec *codec)
+{
+	return snd_hda_resume_ctls(codec, dig_in_ctls);
+}
 #endif
 
 /*
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.10/sound/pci/hda/hda_codec.h linux/sound/pci/hda/hda_codec.h
--- linux-2.6.10/sound/pci/hda/hda_codec.h	2005-02-24 17:26:05.000000000 +0100
+++ linux/sound/pci/hda/hda_codec.h	2005-02-22 18:16:49.000000000 +0100
@@ -531,6 +531,7 @@ struct hda_codec {
 	struct semaphore spdif_mutex;
 	unsigned int spdif_status;	/* IEC958 status bits */
 	unsigned short spdif_ctls;	/* SPDIF control bits */
+	unsigned int spdif_in_enable;	/* SPDIF input enable? */
 };
 
 /* direction */
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.10/sound/pci/hda/hda_local.h linux/sound/pci/hda/hda_local.h
--- linux-2.6.10/sound/pci/hda/hda_local.h	2005-02-24 17:26:05.000000000 +0100
+++ linux/sound/pci/hda/hda_local.h	2005-02-22 18:08:47.000000000 +0100
@@ -60,6 +60,7 @@ int snd_hda_mixer_amp_switch_get(snd_kco
 int snd_hda_mixer_amp_switch_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol);
 
 int snd_hda_create_spdif_out_ctls(struct hda_codec *codec, hda_nid_t nid);
+int snd_hda_create_spdif_in_ctls(struct hda_codec *codec, hda_nid_t nid);
 
 /*
  * input MUX helper
@@ -138,6 +139,7 @@ int snd_hda_add_new_ctls(struct hda_code
 #ifdef CONFIG_PM
 int snd_hda_resume_ctls(struct hda_codec *codec, snd_kcontrol_new_t *knew);
 int snd_hda_resume_spdif_out(struct hda_codec *codec);
+int snd_hda_resume_spdif_in(struct hda_codec *codec);
 #endif
 
 /*
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.10/sound/pci/hda/patch_cmedia.c linux/sound/pci/hda/patch_cmedia.c
--- linux-2.6.10/sound/pci/hda/patch_cmedia.c	2005-02-24 17:26:05.000000000 +0100
+++ linux/sound/pci/hda/patch_cmedia.c	2005-02-22 18:08:47.000000000 +0100
@@ -335,11 +335,15 @@ static int cmi9880_build_controls(struct
 			return err;
 	}
 	if (spec->multiout.dig_out_nid) {
-		err = snd_hda_create_spdif_out_ctls(codec, CMI_DIG_OUT_NID);
+		err = snd_hda_create_spdif_out_ctls(codec, spec->multiout.dig_out_nid);
+		if (err < 0)
+			return err;
+	}
+	if (spec->dig_in_nid) {
+		err = snd_hda_create_spdif_in_ctls(codec, spec->dig_in_nid);
 		if (err < 0)
 			return err;
 	}
-	/* TODO: digital-in */
 	return 0;
 }
 
@@ -367,6 +371,8 @@ static int cmi9880_resume(struct hda_cod
 		snd_hda_resume_ctls(codec, cmi9880_ch_mode_mixer);
 	if (spec->multiout.dig_out_nid)
 		snd_hda_resume_spdif_out(codec);
+	if (spec->dig_in_nid)
+		snd_hda_resume_spdif_in(codec);
 
 	return 0;
 }
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.10/sound/pci/hda/patch_realtek.c linux/sound/pci/hda/patch_realtek.c
--- linux-2.6.10/sound/pci/hda/patch_realtek.c	2005-02-24 17:26:05.000000000 +0100
+++ linux/sound/pci/hda/patch_realtek.c	2005-02-22 18:08:47.000000000 +0100
@@ -493,6 +493,11 @@ static int alc_build_controls(struct hda
 		if (err < 0)
 			return err;
 	}
+	if (spec->dig_in_nid) {
+		err = snd_hda_create_spdif_in_ctls(codec, spec->dig_in_nid);
+		if (err < 0)
+			return err;
+	}
 	return 0;
 }
 
@@ -735,6 +740,8 @@ static int alc_resume(struct hda_codec *
 	}
 	if (spec->multiout.dig_out_nid)
 		snd_hda_resume_spdif_out(codec);
+	if (spec->dig_in_nid)
+		snd_hda_resume_spdif_in(codec);
 
 	return 0;
 }
@@ -1432,7 +1439,8 @@ static int patch_alc882(struct hda_codec
 	spec->num_mixers++;
 
 	spec->multiout.dig_out_nid = ALC880_DIGOUT_NID;
+	spec->dig_in_nid = ALC880_DIGIN_NID;
 	spec->front_panel = 1;
 	spec->init_verbs = alc882_init_verbs;
 	spec->channel_mode = alc882_ch_modes;
