diff -Nur cifs-1.12/fs/cifs/CHANGES cifs-1.13a/fs/cifs/CHANGES
--- cifs-1.12/fs/cifs/CHANGES	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/CHANGES	2004-05-02 18:37:41.000000000 +0200
@@ -1,3 +1,10 @@
+Version 1.13
+------------
+Fix open of files in which O_CREATE can cause the mode to change in
+some cases. Fix case in which retry of write overlaps file close.
+Fix PPC64 build error.  Reduce excessive stack usage in smb password
+hashing. Fix overwrite of Linux user's view of file mode to Windows servers.
+
 Version 1.12
 ------------
 Fixes for large file copy, signal handling, socket retry, buffer
diff -Nur cifs-1.12/fs/cifs/cifsfs.c cifs-1.13a/fs/cifs/cifsfs.c
--- cifs-1.12/fs/cifs/cifsfs.c	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/cifsfs.c	2004-05-02 18:37:41.000000000 +0200
@@ -774,6 +774,7 @@
 MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");
 MODULE_LICENSE("GPL");		/* combination of LGPL + GPL source behaves as GPL */
 MODULE_DESCRIPTION
-    ("VFS to access servers complying with the SNIA CIFS Specification e.g. Samba and Windows Revision: 1.11");
+    ("VFS to access servers complying with the SNIA CIFS Specification e.g. Samba and Windows");
+MODULE_VERSION(CIFS_VERSION);
 module_init(init_cifs)
 module_exit(exit_cifs)
diff -Nur cifs-1.12/fs/cifs/cifsfs.h cifs-1.13a/fs/cifs/cifsfs.h
--- cifs-1.12/fs/cifs/cifsfs.h	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/cifsfs.h	2004-05-02 18:37:41.000000000 +0200
@@ -93,4 +93,5 @@
 			 size_t, int);
 extern ssize_t	cifs_getxattr(struct dentry *, const char *, void *, size_t);
 extern ssize_t	cifs_listxattr(struct dentry *, char *, size_t);
-#endif				/* _CIFSSMB_H */
+#define CIFS_VERSION   "1.13"
+#endif				/* _CIFSFS_H */
diff -Nur cifs-1.12/fs/cifs/cifspdu.h cifs-1.13a/fs/cifs/cifspdu.h
--- cifs-1.12/fs/cifs/cifspdu.h	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/cifspdu.h	2004-05-02 18:37:42.000000000 +0200
@@ -641,6 +641,9 @@
 #define OPLOCK_BATCH	 2
 #define OPLOCK_READ	 3  /* level 2 oplock */
 
+/* open response for CreateAction shifted left */
+#define CIFS_CREATE_ACTION 0x20000 /* file created */
+
 typedef struct smb_com_open_rsp {
 	struct smb_hdr hdr;	/* wct = 34 BB */
 	__u8 AndXCommand;
diff -Nur cifs-1.12/fs/cifs/cifssmb.c cifs-1.13a/fs/cifs/cifssmb.c
--- cifs-1.12/fs/cifs/cifssmb.c	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/cifssmb.c	2004-05-02 18:37:42.000000000 +0200
@@ -446,8 +446,8 @@
 
 	if (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {
 		name_len = cifs_strtoUCS((wchar_t *) pSMB->DirName, dirName, 530
-					 /* find define for this maxpathcomponent */
-					 , nls_codepage);
+				/* find define for this maxpathcomponent */
+				, nls_codepage);
 		name_len++;	/* trailing null */
 		name_len *= 2;
 	} else {		/* BB improve the check for buffer overruns BB */
@@ -594,7 +594,10 @@
 	} else {
 		*pOplock = pSMBr->OplockLevel;	/* one byte no need to le_to_cpu */
 		*netfid = pSMBr->Fid;	/* cifs fid stays in le */
-		/* Do we care about the CreateAction in any cases? */
+		/* Let caller know file was created so we can set the mode. */
+		/* Do we care about the CreateAction in any other cases? */
+		if(cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)
+			*pOplock |= CIFS_CREATE_ACTION; 
 		if(pfile_info) {
 		    memcpy((char *)pfile_info,(char *)&pSMBr->CreationTime,
 			36 /* CreationTime to Attributes */);
@@ -2467,7 +2470,8 @@
 	int bytes_returned = 0;
 	__u32 tmp;
 
-	cFYI(1, ("SetFileSize (via SetFileInfo) %lld",size));
+	cFYI(1, ("SetFileSize (via SetFileInfo) %lld",
+			(long long)size));
 	rc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,
 		      (void **) &pSMBr);
 	if (rc)
diff -Nur cifs-1.12/fs/cifs/connect.c cifs-1.13a/fs/cifs/connect.c
--- cifs-1.12/fs/cifs/connect.c	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/connect.c	2004-05-02 18:37:42.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/ipv6.h>
 #include <linux/pagemap.h>
 #include <linux/ctype.h>
+#include <linux/utsname.h>
 #include <asm/uaccess.h>
 #include <asm/processor.h>
 #include "cifspdu.h"
@@ -255,7 +256,7 @@
 		pdu_length = 4 + ntohl(smb_buffer->smb_buf_length);
 		/* Ony read pdu_length after below checks for too short (due
 		   to e.g. int overflow) and too long ie beyond end of buf */
-		cFYI(1, ("Peek length rcvd: %d with smb length: %d", length, pdu_length));
+		cFYI(1, ("Peek length rcvd: 0x%x beginning 0x%x)", length, pdu_length));
 
 		temp = (char *) smb_buffer;
 		if (length > 3) {
@@ -973,6 +974,8 @@
 			rfc1002mangle(ses_init_buf->trailer.session_req.called_name,
 				DEFAULT_CIFS_CALLED_NAME,16);
 			ses_init_buf->trailer.session_req.calling_len = 32;
+			/* calling name ends in null (byte 16) from old smb
+			convention. */
 			if(netbios_name && (netbios_name[0] !=0)) {
 				rfc1002mangle(ses_init_buf->trailer.session_req.calling_name,
 					netbios_name,16);
@@ -982,7 +985,6 @@
 			}
 			ses_init_buf->trailer.session_req.scope1 = 0;
 			ses_init_buf->trailer.session_req.scope2 = 0;
-		/* BB fixme ensure calling space padded w/null terminate*/
 			smb_buf = (struct smb_hdr *)ses_init_buf;
 			/* sizeof RFC1002_SESSION_REQUEST with no scope */
 			smb_buf->smb_buf_length = 0x81000044;
diff -Nur cifs-1.12/fs/cifs/dir.c cifs-1.13a/fs/cifs/dir.c
--- cifs-1.12/fs/cifs/dir.c	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/dir.c	2004-05-02 18:37:42.000000000 +0200
@@ -179,14 +179,31 @@
 	if (rc) {
 		cFYI(1, ("cifs_create returned 0x%x ", rc));
 	} else {
-	/* BB for case of overwriting existing file can we use the inode that was
-		 passed in rather than creating new one?? */
+		/* If Open reported that we actually created a file
+		then we now have to set the mode if possible */
+		if ((cifs_sb->tcon->ses->capabilities & CAP_UNIX) &&
+			(oplock & CIFS_CREATE_ACTION))
+			CIFSSMBUnixSetPerms(xid, pTcon, full_path, mode,
+					(__u64)-1,
+					(__u64)-1,
+					0 /* dev */,
+					cifs_sb->local_nls);
+		else {
+			/* BB implement via Windows security descriptors */
+			/* eg CIFSSMBWinSetPerms(xid,pTcon,full_path,mode,-1,-1,local_nls);*/
+			/* could set r/o dos attribute if mode & 0222 == 0 */
+		}
+
+	/* BB server might mask mode so we have to query for Unix case*/
 		if (pTcon->ses->capabilities & CAP_UNIX)
 			rc = cifs_get_inode_info_unix(&newinode, full_path,
-						      inode->i_sb);
-		else
+						 inode->i_sb);
+		else {
 			rc = cifs_get_inode_info(&newinode, full_path,
 						 buf, inode->i_sb);
+			if(newinode)
+				newinode->i_mode = mode;
+		}
 
 		if (rc != 0) {
 			cFYI(1,("Create worked but get_inode_info failed with rc = %d",
@@ -198,21 +215,7 @@
 		if((nd->flags & LOOKUP_OPEN) == FALSE) {
 			/* mknod case - do not leave file open */
 			CIFSSMBClose(xid, pTcon, fileHandle);
-			if(newinode)
-				newinode->i_mode = mode;
-			if (cifs_sb->tcon->ses->capabilities & CAP_UNIX)
-				CIFSSMBUnixSetPerms(xid, pTcon, full_path, mode,
-						(__u64)-1,
-						(__u64)-1,
-						0 /* dev */,
-						cifs_sb->local_nls);
-			else { /* BB implement via Windows security descriptors */
-                        /* eg CIFSSMBWinSetPerms(xid,pTcon,full_path,mode,-1,-1,local_nls);*/
-                        /* in the meantime could set r/o dos attribute when perms are eg:
-                                        mode & 0222 == 0 */
-			}
 		} else if(newinode) {
-			newinode->i_mode = mode;
 			pCifsFile = (struct cifsFileInfo *)
 			   kmalloc(sizeof (struct cifsFileInfo), GFP_KERNEL);
 		
@@ -231,26 +234,15 @@
 				pCifsInode = CIFS_I(newinode);
 				if(pCifsInode) {
 					list_add(&pCifsFile->flist,&pCifsInode->openFileList);
-					if(oplock == OPLOCK_EXCLUSIVE) {
+					if((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
 						pCifsInode->clientCanCacheAll = TRUE;
 						pCifsInode->clientCanCacheRead = TRUE;
 						cFYI(1,("Exclusive Oplock granted on inode %p",newinode));
-					} else if(oplock == OPLOCK_READ)
+					} else if((oplock & 0xF) == OPLOCK_READ)
 						pCifsInode->clientCanCacheRead = TRUE;
 				}
 				write_unlock(&GlobalSMBSeslock);
-				if (cifs_sb->tcon->ses->capabilities & CAP_UNIX)                
-					CIFSSMBUnixSetPerms(xid, pTcon, full_path, inode->i_mode,
-						(__u64)-1, 
-						(__u64)-1,
-						0 /* dev */,
-						cifs_sb->local_nls);
-				else { /* BB implement via Windows security descriptors */
-			/* eg CIFSSMBWinSetPerms(xid,pTcon,full_path,mode,-1,-1,local_nls);*/
-			/* in the meantime could set r/o dos attribute when perms are eg:
-					mode & 0222 == 0 */
-				}
-			}			
+			}
 		}
 	} 
 
diff -Nur cifs-1.12/fs/cifs/file.c cifs-1.13a/fs/cifs/file.c
--- cifs-1.12/fs/cifs/file.c	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/file.c	2004-05-02 18:37:42.000000000 +0200
@@ -62,8 +62,8 @@
 		read_lock(&GlobalSMBSeslock);
 		list_for_each(tmp, &pCifsInode->openFileList) {            
 			pCifsFile = list_entry(tmp,struct cifsFileInfo, flist);           
-			if((pCifsFile->pfile == NULL)&& (pCifsFile->pid = current->pid)){		
-			/* set mode ?? */
+			if((pCifsFile->pfile == NULL)&& (pCifsFile->pid = current->pid)){
+			/* mode set in cifs_create */
 				pCifsFile->pfile = file; /* needed for writepage */
 				file->private_data = pCifsFile;
 				break;
@@ -205,17 +205,17 @@
 					rc = cifs_get_inode_info(&file->f_dentry->d_inode,
 						full_path, buf, inode->i_sb);
 
-				if(oplock == OPLOCK_EXCLUSIVE) {
+				if((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
 					pCifsInode->clientCanCacheAll = TRUE;
 					pCifsInode->clientCanCacheRead = TRUE;
 					cFYI(1,("Exclusive Oplock granted on inode %p",file->f_dentry->d_inode));
-				} else if(oplock == OPLOCK_READ)
+				} else if((oplock & 0xF) == OPLOCK_READ)
 					pCifsInode->clientCanCacheRead = TRUE;
 			} else {
 				write_unlock(&GlobalSMBSeslock);
 				write_unlock(&file->f_owner.lock);
 			}
-			if(file->f_flags & O_CREAT) {           
+			if(oplock & CIFS_CREATE_ACTION) {           
 				/* time to set mode which we can not set earlier due
 				 to problems creating new read-only files */
 				if (cifs_sb->tcon->ses->capabilities & CAP_UNIX)                
@@ -336,11 +336,11 @@
 				rc = cifs_get_inode_info(&inode,
 						full_path, buf, inode->i_sb);
 
-			if(oplock == OPLOCK_EXCLUSIVE) {
+			if((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
 				pCifsInode->clientCanCacheAll =  TRUE;
 				pCifsInode->clientCanCacheRead = TRUE;
 				cFYI(1,("Exclusive Oplock granted on inode %p",file->f_dentry->d_inode));
-			} else if(oplock == OPLOCK_READ) {
+			} else if((oplock & 0xF) == OPLOCK_READ) {
 				pCifsInode->clientCanCacheRead = TRUE;
 				pCifsInode->clientCanCacheAll =  FALSE;
 			} else {
@@ -561,6 +561,10 @@
 	}
 	open_file = (struct cifsFileInfo *) file->private_data;
 
+	if(file->f_dentry->d_inode == NULL) {
+		FreeXid(xid);
+		return -EBADF;
+	}
 
 	if (*poffset > file->f_dentry->d_inode->i_size)
 		long_op = 2;  /* writes past end of file can take a long time */
@@ -571,7 +575,16 @@
 	     total_written += bytes_written) {
 		rc = -EAGAIN;
 		while(rc == -EAGAIN) {
+			if(file->private_data == NULL) {
+				/* file has been closed on us */
+				FreeXid(xid);
+				return total_written;
+			}
 			if ((open_file->invalidHandle) && (!open_file->closePend)) {
+				if((file->f_dentry == NULL) || (file->f_dentry->d_inode == NULL)) {
+					FreeXid(xid);
+					return total_written;
+				}
 				rc = cifs_reopen_file(file->f_dentry->d_inode,file);
 				if(rc != 0)
 					break;
@@ -594,13 +607,19 @@
 			*poffset += bytes_written;
 		long_op = FALSE; /* subsequent writes fast - 15 seconds is plenty */
 	}
-	file->f_dentry->d_inode->i_ctime = file->f_dentry->d_inode->i_mtime =
-		CURRENT_TIME;
-	if (bytes_written > 0) {
-		if (*poffset > file->f_dentry->d_inode->i_size)
-			i_size_write(file->f_dentry->d_inode, *poffset);
+
+	/* since the write may have blocked check these pointers again */
+	if(file->f_dentry) {
+		if(file->f_dentry->d_inode) {
+			file->f_dentry->d_inode->i_ctime = file->f_dentry->d_inode->i_mtime =
+				CURRENT_TIME;
+			if (bytes_written > 0) {
+				if (*poffset > file->f_dentry->d_inode->i_size)
+					i_size_write(file->f_dentry->d_inode, *poffset);
+			}
+			mark_inode_dirty_sync(file->f_dentry->d_inode);
+		}
 	}
-	mark_inode_dirty_sync(file->f_dentry->d_inode);
 	FreeXid(xid);
 	return total_written;
 }
@@ -1165,7 +1184,6 @@
 	pfindData->EndOfFile = le64_to_cpu(pfindData->EndOfFile);
 	cifsInfo->cifsAttrs = pfindData->ExtFileAttributes;
 	cifsInfo->time = jiffies;
-	atomic_inc(&cifsInfo->inUse);	/* inc on every refresh of inode info */
 
 	/* Linux can not store file creation time unfortunately so ignore it */
 	tmp_inode->i_atime =
@@ -1178,10 +1196,12 @@
 	/* 2767 perms - indicate mandatory locking */
 		/* BB fill in uid and gid here? with help from winbind? 
 			or retrieve from NTFS stream extended attribute */
-	tmp_inode->i_uid = cifs_sb->mnt_uid;
-	tmp_inode->i_gid = cifs_sb->mnt_gid;
-	/* set default mode. will override for dirs below */
-	tmp_inode->i_mode = cifs_sb->mnt_file_mode;
+	if(atomic_read(&cifsInfo->inUse) == 0) {
+		tmp_inode->i_uid = cifs_sb->mnt_uid;
+		tmp_inode->i_gid = cifs_sb->mnt_gid;
+		/* set default mode. will override for dirs below */
+		tmp_inode->i_mode = cifs_sb->mnt_file_mode;
+	}
 
 	cFYI(0,
 	     ("CIFS FFIRST: Attributes came in as 0x%x",
@@ -1193,7 +1213,9 @@
 	} else if (pfindData->ExtFileAttributes & ATTR_DIRECTORY) {
 		*pobject_type = DT_DIR;
 		/* override default perms since we do not lock dirs */
-		tmp_inode->i_mode = cifs_sb->mnt_dir_mode;
+		if(atomic_read(&cifsInfo->inUse) == 0) {
+			tmp_inode->i_mode = cifs_sb->mnt_dir_mode;
+		}
 		tmp_inode->i_mode |= S_IFDIR;
 	} else {
 		*pobject_type = DT_REG;
@@ -1204,6 +1226,10 @@
 	}/* could add code here - to validate if device or weird share type? */
 
 	/* can not fill in nlink here as in qpathinfo version and Unx search */
+	if(atomic_read(&cifsInfo->inUse) == 0) {
+		atomic_set(&cifsInfo->inUse,1);
+	}
+
 	i_size_write(tmp_inode,pfindData->EndOfFile);
 	tmp_inode->i_blocks =
 		(tmp_inode->i_blksize - 1 + pfindData->AllocationSize) >> tmp_inode->i_blkbits;
@@ -1853,15 +1879,18 @@
 							file->f_pos++;
 						}
 					}
-					pfindData = (FILE_DIRECTORY_INFO *) ((char *) pfindData + le32_to_cpu(pfindData->NextEntryOffset));	/* works also for Unix find struct since this is the first field of both */
-					/* BB also should check to make sure that pointer is not beyond the end of the SMB */
+					pfindData = (FILE_DIRECTORY_INFO *) ((char *) pfindData + 
+						le32_to_cpu(pfindData->NextEntryOffset));
+	/* works also for Unix find struct since first field of both */
+	/* BB also should check to ensure pointer not beyond end of SMB */
 				} /* end for loop */
 				if (findNextParms.EndofSearch != 0) {
 					cifsFile->endOfSearch = TRUE;
 				}
 			} else {
 				cifsFile->endOfSearch = TRUE;
-				rc = 0;	/* unless parent directory disappeared - do not return error here (eg Access Denied or no more files) */
+				rc = 0;	/* unless parent directory disappeared - do not
+				return error here (eg Access Denied or no more files) */
 			}
 		}
 	} /* end switch */
diff -Nur cifs-1.12/fs/cifs/inode.c cifs-1.13a/fs/cifs/inode.c
--- cifs-1.12/fs/cifs/inode.c	2004-04-29 06:49:22.000000000 +0200
+++ cifs-1.13a/fs/cifs/inode.c	2004-05-02 18:37:42.000000000 +0200
@@ -94,7 +94,7 @@
 		cFYI(1, (" Old time %ld ", cifsInfo->time));
 		cifsInfo->time = jiffies;
 		cFYI(1, (" New time %ld ", cifsInfo->time));
-		atomic_inc(&cifsInfo->inUse);	/* inc on every refresh of inode */
+		atomic_set(&cifsInfo->inUse,1);	/* ok to set on every refresh of inode */
 
 		inode->i_atime =
 		    cifs_NTtimeToUnix(le64_to_cpu(findData.LastAccessTime));
@@ -238,7 +238,6 @@
 		cFYI(1, (" Old time %ld ", cifsInfo->time));
 		cifsInfo->time = jiffies;
 		cFYI(1, (" New time %ld ", cifsInfo->time));
-		atomic_inc(&cifsInfo->inUse);	/* inc on every refresh of inode */
 
 /* blksize needs to be multiple of two. So safer to default to blksize
         and blkbits set in superblock so 2**blkbits and blksize will match */
@@ -256,7 +255,9 @@
 		     (" Attributes came in as 0x%x ", pfindData->Attributes));
 
 		/* set default mode. will override for dirs below */
-		inode->i_mode = cifs_sb->mnt_file_mode;
+		if(atomic_read(&cifsInfo->inUse) == 0)
+			/* new inode, can safely set these fields */
+			inode->i_mode = cifs_sb->mnt_file_mode;
 
 		if (pfindData->Attributes & ATTR_REPARSE) {
 	/* Can IFLNK be set as it basically is on windows with IFREG or IFDIR? */
@@ -281,8 +282,13 @@
 
 		/* BB fill in uid and gid here? with help from winbind? 
 			or retrieve from NTFS stream extended attribute */
-		inode->i_uid = cifs_sb->mnt_uid;
-		inode->i_gid = cifs_sb->mnt_gid;
+		if(atomic_read(&cifsInfo->inUse) == 0) {
+			inode->i_uid = cifs_sb->mnt_uid;
+			inode->i_gid = cifs_sb->mnt_gid;
+			/* set so we do not keep refreshing these fields with
+			bad data after user has changed them in memory */
+			atomic_set(&cifsInfo->inUse,1);
+		}
 		
 		if (S_ISREG(inode->i_mode)) {
 			cFYI(1, (" File inode "));
diff -Nur cifs-1.12/fs/cifs/smbdes.c cifs-1.13a/fs/cifs/smbdes.c
--- cifs-1.12/fs/cifs/smbdes.c	2004-04-29 06:49:23.000000000 +0200
+++ cifs-1.13a/fs/cifs/smbdes.c	2004-05-02 18:37:42.000000000 +0200
@@ -6,7 +6,7 @@
    SMB authentication protocol
 
    Copyright (C) Andrew Tridgell 1998
-   Modified by Steve French (sfrench@us.ibm.com) 2002,2003
+   Modified by Steve French (sfrench@us.ibm.com) 2002,2004
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -44,7 +44,7 @@
    should confirm it for yourself (and maybe let me know if you come
    up with a different answer to the one above)
 */
-
+#include <linux/slab.h>
 #define uchar unsigned char
 
 static uchar perm1[56] = { 57, 49, 41, 33, 25, 17, 9,
@@ -191,14 +191,23 @@
 dohash(char *out, char *in, char *key, int forw)
 {
 	int i, j, k;
-	char pk1[56];
+	char *pk1;
 	char c[28];
 	char d[28];
-	char cd[56];
+	char *cd;
 	char ki[16][48];
-	char pd1[64];
+	char *pd1;
 	char l[32], r[32];
-	char rl[64];
+	char *rl;
+
+	/* Have to reduce stack usage */
+	pk1 = kmalloc(56+56+64+64,GFP_KERNEL);
+	if(pk1 == NULL)
+		return;
+
+	cd = pk1 + 56;
+	pd1= cd  + 56;
+	rl = pd1 + 64;
 
 	permute(pk1, key, perm1, 56);
 
@@ -223,12 +232,22 @@
 	}
 
 	for (i = 0; i < 16; i++) {
-		char er[48];
-		char erk[48];
+		char *er;  /* er[48]  */
+		char *erk; /* erk[48] */
 		char b[8][6];
-		char cb[32];
-		char pcb[32];
-		char r2[32];
+		char *cb;  /* cb[32]  */
+		char *pcb; /* pcb[32] */
+		char *r2;  /* r2[32]  */
+
+		er = kmalloc(48+48+32+32+32, GFP_KERNEL);
+		if(er == NULL) {
+			kfree(pk1);
+			return;
+		}
+		erk = er+48;
+		cb  = erk+48;
+		pcb = cb+32;
+		r2  = pcb+32;
 
 		permute(er, r, perm4, 48);
 
@@ -262,11 +281,14 @@
 
 		for (j = 0; j < 32; j++)
 			r[j] = r2[j];
+
+		kfree(er);
 	}
 
 	concat(rl, r, l, 32, 32);
 
 	permute(out, rl, perm6, 64);
+	kfree(pk1);
 }
 
 static void
@@ -291,11 +313,18 @@
 smbhash(unsigned char *out, unsigned char *in, unsigned char *key, int forw)
 {
 	int i;
-	char outb[64];
-	char inb[64];
-	char keyb[64];
+	char *outb; /* outb[64] */
+	char *inb;  /* inb[64]  */
+	char *keyb; /* keyb[64] */
 	unsigned char key2[8];
 
+	outb = kmalloc(64 * 3,GFP_KERNEL);
+	if(outb == NULL)
+		return;
+
+	inb  = outb + 64;
+	keyb = inb +  64;
+
 	str_to_key(key, key2);
 
 	for (i = 0; i < 64; i++) {
@@ -314,6 +343,7 @@
 		if (outb[i])
 			out[i / 8] |= (1 << (7 - (i % 8)));
 	}
+	kfree(outb);
 }
 
 void
