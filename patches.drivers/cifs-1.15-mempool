
This patch is part of linux-cifs-1.15. It fixes a deadlock in low
memory situations; inside a CIFS call the network layer would have
tried to free some memory by writing out some pages via CIFS.


--- linux-2.6.5/fs/cifs/cifsfs.c	2004-05-17 19:49:35.000000000 +0200
+++ linux-cifs-1.15-suse/fs/cifs/cifsfs.c	2004-05-18 05:46:44.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/list.h>
 #include <linux/seq_file.h>
 #include <linux/vfs.h>
+#include <linux/mempool.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE
@@ -39,7 +40,9 @@
 #include "cifs_debug.h"
 #include "cifs_fs_sb.h"
 #include <linux/mm.h>
-#define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of all SMB PDUs */
+#define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
+/* BB when mempool_resize is added back in, we will resize pool on new mount */
+#define CIFS_MIN_RCV_POOL 11 /* enough for progress to five servers */
 
 #ifdef CIFS_QUOTA
 static struct quotactl_ops cifs_quotactl_ops;
@@ -209,9 +212,11 @@
 }
 
 static kmem_cache_t *cifs_inode_cachep;
-kmem_cache_t *cifs_req_cachep;
-kmem_cache_t *cifs_mid_cachep;
+static kmem_cache_t *cifs_req_cachep;
+static kmem_cache_t *cifs_mid_cachep;
 kmem_cache_t *cifs_oplock_cachep;
+mempool_t *cifs_req_poolp;
+mempool_t *cifs_mid_poolp;
 
 static struct inode *
 cifs_alloc_inode(struct super_block *sb)
@@ -593,12 +598,23 @@
 	if (cifs_req_cachep == NULL)
 		return -ENOMEM;
 
+	cifs_req_poolp = mempool_create(CIFS_MIN_RCV_POOL,
+					mempool_alloc_slab,
+					mempool_free_slab,
+					cifs_req_cachep);
+
+	if(cifs_req_poolp == NULL) {
+		kmem_cache_destroy(cifs_req_cachep);
+		return -ENOMEM;
+	}
+
 	return 0;
 }
 
 static void
 cifs_destroy_request_bufs(void)
 {
+	mempool_destroy(cifs_req_poolp);
 	if (kmem_cache_destroy(cifs_req_cachep))
 		printk(KERN_WARNING
 		       "cifs_destroy_request_cache: error not all structures were freed\n");
@@ -612,11 +628,22 @@
 				SLAB_HWCACHE_ALIGN, NULL, NULL);
 	if (cifs_mid_cachep == NULL)
 		return -ENOMEM;
+
+	cifs_mid_poolp = mempool_create(3 /* a reasonable min simultan opers */,
+					mempool_alloc_slab,
+					mempool_free_slab,
+					cifs_mid_cachep);
+	if(cifs_mid_poolp == NULL) {
+		kmem_cache_destroy(cifs_mid_cachep);
+		return -ENOMEM;
+	}
+
 	cifs_oplock_cachep = kmem_cache_create("cifs_oplock_structs",
 				sizeof (struct oplock_q_entry), 0,
 				SLAB_HWCACHE_ALIGN, NULL, NULL);
 	if (cifs_oplock_cachep == NULL) {
 		kmem_cache_destroy(cifs_mid_cachep);
+		mempool_destroy(cifs_mid_poolp);
 		return -ENOMEM;
 	}
 
@@ -626,9 +653,11 @@
 static void
 cifs_destroy_mids(void)
 {
+	mempool_destroy(cifs_mid_poolp);
 	if (kmem_cache_destroy(cifs_mid_cachep))
 		printk(KERN_WARNING
 		       "cifs_destroy_mids: error not all structures were freed\n");
+
 	if (kmem_cache_destroy(cifs_oplock_cachep))
 		printk(KERN_WARNING
 		       "error not all oplock structures were freed\n");
diff -ur ./misc.c linux-cifs-1.15-suse/fs/cifs/misc.c
--- linux-2.6.5/fs/cifs/misc.c	2004-05-17 19:49:35.000000000 +0200
+++ linux-cifs-1.15-suse/fs/cifs/misc.c	2004-05-18 05:46:44.000000000 +0200
@@ -21,6 +21,7 @@
 
 #include <linux/slab.h>
 #include <linux/ctype.h>
+#include <linux/mempool.h>
 #include "cifspdu.h"
 #include "cifsglob.h"
 #include "cifsproto.h"
@@ -28,7 +29,7 @@
 #include "smberr.h"
 #include "nterr.h"
 
-extern kmem_cache_t *cifs_req_cachep;
+extern mempool_t *cifs_req_poolp;
 extern struct task_struct * oplockThread;
 
 __u16 GlobalMid;		/* multiplex id - rotating counter */
@@ -153,7 +154,7 @@
    albeit slightly larger than necessary and maxbuffersize 
    defaults to this and can not be bigger */
 	ret_buf =
-	    (struct smb_hdr *) kmem_cache_alloc(cifs_req_cachep, SLAB_KERNEL | SLAB_NOFS);
+	    (struct smb_hdr *) mempool_alloc(cifs_req_poolp, SLAB_KERNEL | SLAB_NOFS);
 
 	/* clear the first few header bytes */
 	if (ret_buf) {
@@ -172,7 +173,7 @@
 		cFYI(1, ("Null buffer passed to cifs_buf_release"));
 		return;
 	}
-	kmem_cache_free(cifs_req_cachep, buf_to_free);
+	mempool_free(buf_to_free,cifs_req_poolp);
 
 	atomic_dec(&bufAllocCount);
 	return;
diff -ur ./transport.c linux-cifs-1.15-suse/fs/cifs/transport.c
--- linux-2.6.5/fs/cifs/transport.c	2004-05-17 19:49:35.000000000 +0200
+++ linux-cifs-1.15-suse/fs/cifs/transport.c	2004-05-18 05:46:44.000000000 +0200
@@ -25,12 +25,13 @@
 #include <linux/net.h>
 #include <asm/uaccess.h>
 #include <asm/processor.h>
+#include <linux/mempool.h>
 #include "cifspdu.h"
 #include "cifsglob.h"
 #include "cifsproto.h"
 #include "cifs_debug.h"
   
-extern kmem_cache_t *cifs_mid_cachep;
+extern mempool_t *cifs_mid_poolp;
 extern kmem_cache_t *cifs_oplock_cachep;
 
 struct mid_q_entry *
@@ -47,8 +48,7 @@
 		return NULL;
 	}
 	
-	temp = (struct mid_q_entry *) kmem_cache_alloc(cifs_mid_cachep,
-						       SLAB_KERNEL);
+	temp = (struct mid_q_entry *) mempool_alloc(cifs_mid_poolp,SLAB_KERNEL | SLAB_NOFS);
 	if (temp == NULL)
 		return temp;
 	else {
@@ -79,7 +79,7 @@
 	atomic_dec(&midCount);
 	spin_unlock(&GlobalMid_Lock);
 	cifs_buf_release(midEntry->resp_buf);
-	kmem_cache_free(cifs_mid_cachep, midEntry);
+	mempool_free(midEntry, cifs_mid_poolp);
 }
 
 struct oplock_q_entry *
