From 79452f0a28aa5a40522c487b42a5fc423647ad98 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Wed, 22 Jul 2009 12:51:51 +0200
Subject: ALSA: pcm - Fix regressions with VMware
Patch-mainline: 2.6.31-rc5
References: 

VMware tends to report PCM positions and period updates at utterly
wrong timing.  This screws up the recent PCM core code that tries
to correct the position based on the irq timing.

Now, when a backward irq position is detected, skip the update
instead of rebasing.  (This is almost the old behavior before
2.6.30.)

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/core/pcm_lib.c |   11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -244,18 +244,27 @@
 			delta = new_hw_ptr - hw_ptr_interrupt;
 	}
 	if (delta < 0) {
-		delta += runtime->buffer_size;
+		if (runtime->periods == 1)
+			delta += runtime->buffer_size;
 		if (delta < 0) {
 			hw_ptr_error(substream, 
 				     "Unexpected hw_pointer value "
 				     "(stream=%i, pos=%ld, intr_ptr=%ld)\n",
 				     substream->stream, (long)pos,
 				     (long)hw_ptr_interrupt);
+#if 1
+			/* simply skipping the hwptr update seems more
+			 * robust in some cases, e.g. on VMware with
+			 * inaccurate timer source
+			 */
+			return 0; /* skip this update */
+#else
 			/* rebase to interrupt position */
 			hw_base = new_hw_ptr = hw_ptr_interrupt;
 			/* align hw_base to buffer_size */
 			hw_base -= hw_base % runtime->buffer_size;
 			delta = 0;
+#endif
 		} else {
 			hw_base += runtime->buffer_size;
 			if (hw_base >= runtime->boundary)
