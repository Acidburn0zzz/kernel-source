Subject: display last accessed sysfs file on kernel panic message
From: Andrew Morton <akpm@osdl.org>
Patch-mainline: never

Display the most-recently-opened sysfs file's name when oopsing.

From: Adrian Bunk <bunk@stusta.de>

  Build fix

From: Greg Kroah-Hartman <gregkh@suse.de>

  Modified to make the api call cleaner, and available to all arches if
  need be.  Also added it to x86-64's crash dump message.


Signed-off-by: Adrian Bunk <bunk@stusta.de>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 arch/x86/kernel/traps_32.c |    1 +
 arch/x86/kernel/traps_64.c |    1 +
 fs/sysfs/file.c            |   14 ++++++++++++++
 fs/sysfs/mount.c           |    2 +-
 include/linux/sysfs.h      |    7 +++++++
 5 files changed, 24 insertions(+), 1 deletion(-)

--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -394,6 +394,7 @@
 #endif
 	printk("\n");
 
+	sysfs_printk_last_file();
 	if (notify_die(DIE_OOPS, str, regs, err,
 				current->thread.trap_no, SIGSEGV) !=
 			NOTIFY_STOP) {
--- a/arch/x86/kernel/traps_64.c
+++ b/arch/x86/kernel/traps_64.c
@@ -573,6 +573,7 @@
 	printk("DEBUG_PAGEALLOC");
 #endif
 	printk("\n");
+	sysfs_printk_last_file();
 	if (notify_die(DIE_OOPS, str, regs, err, current->thread.trap_no, SIGSEGV) == NOTIFY_STOP)
 		return 1;
 	show_registers(regs);
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -14,6 +14,7 @@
 #include <linux/kobject.h>
 #include <linux/kallsyms.h>
 #include <linux/namei.h>
+#include <linux/limits.h>
 #include <linux/poll.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
@@ -21,6 +22,9 @@
 
 #include "sysfs.h"
 
+/* used in crash dumps to help with debugging */
+static char last_sysfs_file[PATH_MAX];
+
 /*
  * There's one sysfs_buffer for each open file and one
  * sysfs_open_dirent for each sysfs_dirent with one or more open
@@ -326,6 +330,11 @@
 	struct sysfs_buffer *buffer;
 	struct sysfs_ops *ops;
 	int error = -EACCES;
+	char *p;
+
+	p = d_path(&file->f_path, last_sysfs_file, sizeof(last_sysfs_file));
+	if (p)
+		memmove(last_sysfs_file, p, strlen(p) + 1);
 
 	/* need attr_sd for attr and ops, its parent for kobj */
 	if (!sysfs_get_active_two(attr_sd))
@@ -388,6 +397,11 @@
 	return error;
 }
 
+void sysfs_printk_last_file(void)
+{
+	printk(KERN_EMERG "last sysfs file: %s\n", last_sysfs_file);
+}
+
 static int sysfs_release(struct inode *inode, struct file *filp)
 {
 	struct sysfs_dirent *sd = filp->f_path.dentry->d_fsdata;
--- a/fs/sysfs/mount.c
+++ b/fs/sysfs/mount.c
@@ -22,7 +22,7 @@
 /* Random magic number */
 #define SYSFS_MAGIC 0x62656572
 
-static struct vfsmount *sysfs_mount;
+struct vfsmount *sysfs_mount;
 struct super_block * sysfs_sb = NULL;
 struct kmem_cache *sysfs_dir_cachep;
 
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -116,6 +116,8 @@
 
 extern int __must_check sysfs_init(void);
 
+void sysfs_printk_last_file(void);
+
 #else /* CONFIG_SYSFS */
 
 static inline int sysfs_schedule_callback(struct kobject *kobj,
@@ -218,6 +220,11 @@
 	return 0;
 }
 
+static inline void sysfs_printk_last_file(void)
+{
+	;
+}
+
 #endif /* CONFIG_SYSFS */
 
 #endif /* _SYSFS_H_ */
