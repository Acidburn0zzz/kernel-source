Index: linux-2.6.5/fs/cifs/cifs_debug.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifs_debug.c	2004-05-27 10:43:38.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifs_debug.c	2004-05-27 10:45:13.000000000 +0200
@@ -74,7 +74,7 @@
 		    "---------------------------------------------------\n");
 	buf += length;
 
-	length = sprintf(buf, "Servers: \n");
+	length = sprintf(buf, "Servers:\n");
 	buf += length;
 
 	i = 0;
@@ -89,8 +89,10 @@
 				ses->serverOS, ses->serverNOS, ses->capabilities,ses->status,ses->server->tcpStatus);
 		buf += length;
 		if(ses->server) {
-			buf += sprintf(buf, "\n\tLocal Users To Same Server: %d SecMode: 0x%x",
-				atomic_read(&ses->server->socketUseCount),ses->server->secMode);
+			buf += sprintf(buf, "\n\tLocal Users To Same Server: %d SecMode: 0x%x Req Active: %d",
+				atomic_read(&ses->server->socketUseCount),
+				ses->server->secMode,
+				atomic_read(&ses->server->inFlight));
 			
 			/* length = sprintf(buf, "\nMIDs: \n");
 			buf += length;
@@ -113,7 +115,7 @@
 	sprintf(buf, "\n");
 	buf++;
 
-	length = sprintf(buf, "\nShares: \n");
+	length = sprintf(buf, "\nShares:\n");
 	buf += length;
 
 	i = 0;
Index: linux-2.6.5/fs/cifs/cifsglob.h
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifsglob.h	2004-05-27 10:43:38.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifsglob.h	2004-05-27 10:45:13.000000000 +0200
@@ -110,7 +110,8 @@
 		struct sockaddr_in sockAddr;
 		struct sockaddr_in6 sockAddr6;
 	} addr;
-	wait_queue_head_t response_q;
+	wait_queue_head_t response_q; 
+	wait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/
 	struct list_head pending_mid_q;
 	void *Server_NlsInfo;	/* BB - placeholder for future NLS info  */
 	unsigned short server_codepage;	/* codepage for the server    */
@@ -119,7 +120,8 @@
 	char versionMajor;
 	char versionMinor;
 	int svlocal:1;		/* local server or remote */
-	atomic_t socketUseCount;	/* indicates if the server has any open cifs sessions */
+	atomic_t socketUseCount; /* number of open cifs sessions on socket */
+	atomic_t inFlight;  /* number of requests on the wire to server */
 	enum statusEnum tcpStatus; /* what we think the status is */
 	struct semaphore tcpSem;
 	struct task_struct *tsk;
@@ -163,7 +165,7 @@
 	struct semaphore sesSem;
 	struct cifsUidInfo *uidInfo;	/* pointer to user info */
 	struct TCP_Server_Info *server;	/* pointer to server info */
-	atomic_t inUse;		/* # of CURRENT users of this ses */
+	atomic_t inUse; /* # of mounts (tree connections) on this ses */
 	enum statusEnum status;
 	__u32 sequence_number;  /* needed for CIFS PDU signature */
 	__u16 ipc_tid;		/* special tid for connection to IPC share */
Index: linux-2.6.5/fs/cifs/cifssmb.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifssmb.c	2004-05-27 10:44:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifssmb.c	2004-05-27 10:45:13.000000000 +0200
@@ -739,7 +739,7 @@
 	rc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,
 			 (struct smb_hdr *) pSMBr, &bytes_returned, long_op);
 	if (rc) {
-		cERROR(1, ("Send error in write = %d", rc));
+		cFYI(1, ("Send error in write = %d", rc));
 		*nbytes = 0;
 	} else
 		*nbytes = le16_to_cpu(pSMBr->Count);
@@ -803,7 +803,7 @@
 			 (struct smb_hdr *) pSMBr, &bytes_returned, timeout);
 
 	if (rc) {
-		cERROR(1, ("Send error in Lock = %d", rc));
+		cFYI(1, ("Send error in Lock = %d", rc));
 	}
 	if (pSMB)
 		cifs_buf_release(pSMB);
@@ -2291,6 +2291,11 @@
 			    (FILE_SYSTEM_ATTRIBUTE_INFO
 			     *) (((char *) &pSMBr->hdr.Protocol) +
 				 pSMBr->DataOffset);
+			response_data->Attributes = le32_to_cpu(response_data->Attributes);
+			response_data->MaxPathNameComponentLength = 
+				le32_to_cpu(response_data->MaxPathNameComponentLength);
+			response_data->FileSystemNameLen = 
+				le32_to_cpu(response_data->FileSystemNameLen);
 			memcpy(&tcon->fsAttrInfo, response_data,
 			       sizeof (FILE_SYSTEM_ATTRIBUTE_INFO));
 		}
@@ -2360,6 +2365,10 @@
 			    (FILE_SYSTEM_DEVICE_INFO
 			     *) (((char *) &pSMBr->hdr.Protocol) +
 				 pSMBr->DataOffset);
+			response_data->DeviceType = 
+				le32_to_cpu(response_data->DeviceType);
+			response_data->DeviceCharacteristics = 
+				le32_to_cpu(response_data->DeviceCharacteristics);
 			memcpy(&tcon->fsDevInfo, response_data,
 			       sizeof (FILE_SYSTEM_DEVICE_INFO));
 		}
@@ -2370,7 +2379,6 @@
 	if (rc == -EAGAIN)
 		goto QFSDeviceRetry;
 
-
 	return rc;
 }
 
@@ -2428,6 +2436,12 @@
 			    (FILE_SYSTEM_UNIX_INFO
 			     *) (((char *) &pSMBr->hdr.Protocol) +
 				 pSMBr->DataOffset);
+			response_data->MajorVersionNumber =
+				le16_to_cpu(response_data->MajorVersionNumber);
+			response_data->MinorVersionNumber =
+				le16_to_cpu(response_data->MinorVersionNumber);
+			response_data->Capability =
+				le64_to_cpu(response_data->Capability);
 			memcpy(&tcon->fsUnixInfo, response_data,
 			       sizeof (FILE_SYSTEM_UNIX_INFO));
 		}
Index: linux-2.6.5/fs/cifs/connect.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/connect.c	2004-05-27 10:44:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/connect.c	2004-05-27 10:45:13.000000000 +0200
@@ -165,6 +165,7 @@
 		} else {
 			atomic_inc(&tcpSesReconnectCount);
 			server->tcpStatus = CifsGood;
+			atomic_set(&server->inFlight,0);
 			wake_up(&server->response_q);
 		}
 	}
@@ -390,8 +391,14 @@
 			}
 		}
 	}
-   
 	server->tcpStatus = CifsExiting;
+	atomic_set(&server->inFlight, 0);
+	/* Although there should not be any requests blocked on 
+	this queue it can not hurt to be paranoid and try to wake up requests
+	that may haven been blocked when more than 50 at time were on the wire 
+	to the same server - they now will see the session is in exit state
+	and get out of SendReceive.  */
+	wake_up_all(&server->request_q);   
 	server->tsk = NULL;
 	if(server->ssocket) {
 		sock_release(csocket);
@@ -1211,11 +1218,13 @@
 			return rc;
 		} else {
 			memset(srvTcp, 0, sizeof (struct TCP_Server_Info));
-			memcpy(&srvTcp->addr.sockAddr, &sin_server, sizeof (struct sockaddr_in));	
-            /* BB Add code for ipv6 case too */
+			memcpy(&srvTcp->addr.sockAddr, &sin_server, sizeof (struct sockaddr_in));
+			atomic_set(&srvTcp->inFlight,0);
+			/* BB Add code for ipv6 case too */
 			srvTcp->ssocket = csocket;
 			srvTcp->protocolType = IPV4;
 			init_waitqueue_head(&srvTcp->response_q);
+			init_waitqueue_head(&srvTcp->request_q);
 			INIT_LIST_HEAD(&srvTcp->pending_mid_q);
 			srvTcp->tcpStatus = CifsNew;
 			init_MUTEX(&srvTcp->tcpSem);
@@ -2752,6 +2761,7 @@
 				FreeXid(xid);
 				return 0;
 			}
+ 
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(HZ / 4);	/* give captive thread time to exit */
 			if((ses->server) && (ses->server->ssocket)) {            
Index: linux-2.6.5/fs/cifs/transport.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/transport.c	2004-05-27 10:44:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/transport.c	2004-05-27 10:45:13.000000000 +0200
@@ -182,14 +182,34 @@
 	long timeout;
 	struct mid_q_entry *midQ;
 
-	if ((ses == NULL) || (ses->server == NULL)) {
-		cERROR(1,("Null tcp session or smb session: %p",ses));
+	if (ses == NULL) {
+		cERROR(1,("Null smb session"));
 		return -EIO;
 	}
+	if(ses->server == NULL) {
+		cERROR(1,("Null tcp session"));
+		return -EIO;
+	}
+
+	/* Ensure that we do not send more than 50 overlapping requests 
+		to the same server. We may make this configurable later or
+		use ses->maxReq */
+
+	/* can not count locking commands against the total since
+		they are allowed to block on server */
+	if(long_op < 3) {
+		/* update # of requests on the wire to this server */
+		atomic_inc(&ses->server->inFlight); 
+	}
+ 
+	if(atomic_read(&ses->server->inFlight) > 50) {
+		wait_event(ses->server->request_q,atomic_read(&ses->server->inFlight) <= 50);
+	}
 
 	/* make sure that we sign in the same order that we send on this socket 
 		and avoid races inside tcp sendmsg code that could cause corruption
 		of smb data */
+
 	down(&ses->server->tcpSem); 
 
 	if (ses->server->tcpStatus == CifsExiting) {
@@ -210,6 +230,11 @@
 	midQ = AllocMidQEntry(in_buf, ses);
 	if (midQ == NULL) {
 		up(&ses->server->tcpSem);
+		/* If not lock req, update # of requests on wire to server */
+		if(long_op < 3) {
+			atomic_dec(&ses->server->inFlight); 
+			wake_up(&ses->server->request_q);
+		}
 		return -EIO;
 	}
 
@@ -219,6 +244,11 @@
 		       ("Illegal length, greater than maximum frame, %d ",
 			in_buf->smb_buf_length));
 		DeleteMidQEntry(midQ);
+		/* If not lock req, update # of requests on wire to server */
+		if(long_op < 3) {
+			atomic_dec(&ses->server->inFlight); 
+			wake_up(&ses->server->request_q);
+		}
 		return -EIO;
 	}
 
@@ -289,6 +319,11 @@
 		}
 		spin_unlock(&GlobalMid_Lock);
 		DeleteMidQEntry(midQ);
+		/* If not lock req, update # of requests on wire to server */
+		if(long_op < 3) {
+			atomic_dec(&ses->server->inFlight); 
+			wake_up(&ses->server->request_q);
+		}
 		return rc;
 	}
   
@@ -341,12 +376,22 @@
 		}
 	}
 cifs_no_response_exit:
-	DeleteMidQEntry(midQ);	/* BB what if process is killed?
-			 - BB add background daemon to clean up Mid entries from
-			 killed processes & test killing process with active mid */
+	DeleteMidQEntry(midQ);
+
+	if(long_op < 3) {
+		atomic_dec(&ses->server->inFlight); 
+		wake_up(&ses->server->request_q);
+	}
+
 	return rc;
 
 out_unlock:
 	up(&ses->server->tcpSem);
+	/* If not lock req, update # of requests on wire to server */
+	if(long_op < 3) {
+		atomic_dec(&ses->server->inFlight); 
+		wake_up(&ses->server->request_q);
+	}
+
 	return rc;
 }
