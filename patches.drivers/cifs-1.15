Index: linux-2.6.5/fs/cifs/AUTHORS
===================================================================
--- linux-2.6.5.orig/fs/cifs/AUTHORS	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/AUTHORS	2004-05-19 10:21:29.000000000 +0200
@@ -22,6 +22,7 @@
 Amrut Joshi
 Shobhit Dayal
 Sergey Vlasov
+Richard Hughes
 
 Test case and Bug Report contributors
 -------------------------------------
Index: linux-2.6.5/fs/cifs/CHANGES
===================================================================
--- linux-2.6.5.orig/fs/cifs/CHANGES	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/CHANGES	2004-05-19 10:21:29.000000000 +0200
@@ -1,3 +1,14 @@
+Version 1.15
+------------
+Change to mempools for alloc smb request buffers and multiplex structs
+to better handle low memory problems (and potential deadlocks).
+
+Version 1.14
+------------
+Fix incomplete listings of large directories on Samba servers when Unix
+extensions enabled.  Fix oops when smb_buffer can not be allocated. Fix
+rename deadlock when writing out dirty pages at same time.
+
 Version 1.13
 ------------
 Fix open of files in which O_CREATE can cause the mode to change in
Index: linux-2.6.5/fs/cifs/README
===================================================================
--- linux-2.6.5.orig/fs/cifs/README	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/README	2004-05-19 10:21:29.000000000 +0200
@@ -104,9 +104,21 @@
 see the manual pages ("man smb.conf") on the Samba server system.  Note that the 
 cifs vfs, unlike the smbfs vfs, does not read the smb.conf on the client system 
 (the few optional settings are passed in on mount via -o parameters instead).  
-Note that Samba 2.2.7 or later includes a fix that allows the CIFS VFS to delete 
+Note that Samba 2.2.7 or later includes a fix that allows the CIFS VFS to delete
 open files (required for strict POSIX compliance).  Windows Servers already 
-supported this feature.  
+supported this feature. Samba server does not allow symlinks that refer to files
+outside of the share, so in Samba versions prior to 3.0.5, most symlinks to
+files with absolute paths (ie beginning with slash) such as:
+	 ln -s /mnt/foo bar
+would be forbidden. Samba 3.0.5 server or later includes the ability to create 
+such symlinks safely by converting unsafe symlinks (ie symlinks to server 
+files that are outside of the share) to a samba specific format on the server
+that is ignored by local server applications and non-cifs clients and that will
+not be traversed by the Samba server).  This is opaque to the Linux client
+application using the cifs vfs. Absolute symlinks will work to Samba 3.0.5 or
+later, but only for remote clients using the CIFS Unix extensions, and will
+be invisbile to Windows clients and typically will not affect local
+applications running on the same server as Samba.  
 
 Use instructions:
 ================
@@ -142,6 +154,8 @@
         password=your_password
 2) By specifying the password in the PASSWD environment variable (similarly
 the user name can be taken from the USER environment variable).
+3) By specifying the password in a file by name via PASSWD_FILE
+4) By specifying the password in a file by file descriptor via PASSWD_FD
 
 If no password is provided, mount.cifs will prompt for password entry
 
@@ -166,8 +180,28 @@
 		mount.	
   domain	Set the SMB/CIFS workgroup name prepended to the
 		username during CIFS session establishment
-  uid           If CIFS Unix extensions are not supported by the server
-                this overrides the default uid for inodes.
+  uid		If CIFS Unix extensions are not supported by the server
+		this overrides the default uid for inodes. For mounts to
+		servers which do support the CIFS Unix extensions, such
+		as a properly configured Samba server, the server provides
+		the uid, gid and mode.  For servers which do not support
+		the Unix extensions, the default uid (and gid) returned on
+		lookup of existing files is the uid (gid) of the person
+		who executed the mount (root, except when mount.cifs
+		is configured setuid for user mounts) unless the "uid=" 
+		(gid) mount option is specified.  For the uid (gid) of newly
+		created files and directories, ie files created since 
+		the last mount of the server share, the expected uid 
+		(gid) is cached as as long as the inode remains in 
+		memory on the client.   Also note that permission
+		checks (authorization checks) on accesses to a file occur
+		at the server, but there are cases in which an administrator
+		may want to restrict at the client as well.  For those
+		servers which do not report a uid/gid owner
+		(such as Windows), permissions can also be checked at the
+		client, and a crude form of client side permission checking 
+		can be enabled by specifying file_mode and dir_mode on 
+		the client
   gid		If CIFS Unix extensions are not supported by the server
 		this overrides the default gid for inodes.
   file_mode     If CIFS Unix extensions are not supported by the server
@@ -219,6 +253,17 @@
 		if guest is specified on the mount options.  If no
 		password is specified a null password will be used.
 
+The mount.cifs mount helper also accepts a few mount options before -o
+including:
+
+	-S      take password from stdin (equivalent to setting the environment
+		variable "PASSWD_FD=0"
+	-V      print mount.cifs version
+	-?      display simple usage information
+
+With recent 2.6 kernel versions of modutils, the version of the cifs kernel
+module can be displayed via modinfo.
+
 Misc /proc/fs/cifs Flags and Debug Info
 =======================================
 Informational pseudo-files:
Index: linux-2.6.5/fs/cifs/TODO
===================================================================
--- linux-2.6.5.orig/fs/cifs/TODO	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/TODO	2004-05-19 10:21:29.000000000 +0200
@@ -1,4 +1,4 @@
-version 1.0.2 January 29, 2004
+version 1.14 May 14, 2004
 
 A Partial List of Known Problems and Missing Features
 =====================================================
@@ -21,8 +21,8 @@
 
 f) MD5-HMAC signing SMB PDUs when SPNEGO style SessionSetup 
 used (Kerberos or NTLMSSP). Signing alreadyimplemented for NTLM
-	and raw NTLMSSP already. This is important when enabling
-	extended security and mounting to Windows 2003 Servers
+and raw NTLMSSP already. This is important when enabling
+extended security and mounting to Windows 2003 Servers
 
 f) Directory entry caching relies on a 1 second timer, rather than 
 using FindNotify or equivalent.  - (started)
@@ -34,7 +34,8 @@
 
 i) support for the Linux 2.5 kernel new feature get_xattr and set_xattr
 which will allow us to expose dos attributes as well as real
-ACLs
+ACLs. This support has been started in the current code, but is
+ifdeffed out.
 
 k) finish writepages support (multi-page write behind for improved
 performance) and syncpage
@@ -42,7 +43,9 @@
 l) hook lower into the sockets api (as NFS/SunRPC does) to avoid the
 extra copy in/out of the socket buffers in some cases.
 
-m) finish support for IPv6
+m) finish support for IPv6.  This is mostly complete but
+needs a simple inet_pton like function to convert ipv6
+addresses in string representation.
 
 o) Better optimize open (and pathbased setfilesize) to reduce the
 oplock breaks coming from windows srv.  Piggyback identical file
@@ -53,8 +56,18 @@
 p) Improve performance of readpages by sending more than one read
 at a time when 8 pages or more are requested.
 
+q) For support of Windows9x/98 we need to retry failed mounts
+to *SMBSERVER (default server name) with the uppercase hostname
+in the RFC1001 session_init request.
 
-KNOWN BUGS (updated January 30, 2004)
+r) Add Extended Attributed support (for storing UID/GID info
+to Windows servers)
+
+s) Finish fcntl D_NOTIFY support so kde and gnome file list windows
+will autorefresh
+
+
+KNOWN BUGS (updated May 14, 2004)
 ====================================
 1) existing symbolic links (Windows reparse points) are recognized but
 can not be created remotely. They are implemented for Samba and those that
@@ -64,20 +77,22 @@
 but recognizes them
 3) create of new files to FAT partitions on Windows servers can
 succeed but still return access denied (appears to be Windows 
-not client problem).  NTFS partitions do not have this problem.
-4) debug connectathon special test case nfs_idem (which does
-some invalid symlink naming, or at least what Samba thinks
-is an invalid symlink target).
-5) debug connectation lock test case 10 which fails against
+not client problem) and has not been reproduced recently.
+NTFS partitions do not have this problem.
+4) debug connectation lock test case 10 which fails against
 Samba (may be unmappable due to POSIX to Windows lock model
 differences but worth investigating).  Also debug Samba to 
 see why lock test case 7 takes longer to complete to Samba
 than to Windows.
+5) prepare_write does not initialize pages properly when partial
+page writes begin in the middle of a page (pages can get zeroed).
+6) Write caching done incorrectly when files are only opened
+with write permission by the application.
 
 Misc testing to do
 =================
 1) check out max path names and max path name components against various server
-types.
+types. Return max path name in stat -f information
 
 2) Modify file portion of ltp so it can run against a mounted network
 share and run it against cifs vfs.
Index: linux-2.6.5/fs/cifs/cifsfs.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifsfs.c	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifsfs.c	2004-05-19 10:20:47.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/list.h>
 #include <linux/seq_file.h>
 #include <linux/vfs.h>
+#include <linux/mempool.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE
@@ -39,7 +40,9 @@
 #include "cifs_debug.h"
 #include "cifs_fs_sb.h"
 #include <linux/mm.h>
-#define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of all SMB PDUs */
+#define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
+/* BB when mempool_resize is added back in, we will resize pool on new mount */
+#define CIFS_MIN_RCV_POOL 11 /* enough for progress to five servers */
 
 #ifdef CIFS_QUOTA
 static struct quotactl_ops cifs_quotactl_ops;
@@ -209,9 +212,11 @@
 }
 
 static kmem_cache_t *cifs_inode_cachep;
-kmem_cache_t *cifs_req_cachep;
-kmem_cache_t *cifs_mid_cachep;
+static kmem_cache_t *cifs_req_cachep;
+static kmem_cache_t *cifs_mid_cachep;
 kmem_cache_t *cifs_oplock_cachep;
+mempool_t *cifs_req_poolp;
+mempool_t *cifs_mid_poolp;
 
 static struct inode *
 cifs_alloc_inode(struct super_block *sb)
@@ -593,12 +598,23 @@
 	if (cifs_req_cachep == NULL)
 		return -ENOMEM;
 
+	cifs_req_poolp = mempool_create(CIFS_MIN_RCV_POOL,
+					mempool_alloc_slab,
+					mempool_free_slab,
+					cifs_req_cachep);
+
+	if(cifs_req_poolp == NULL) {
+		kmem_cache_destroy(cifs_req_cachep);
+		return -ENOMEM;
+	}
+
 	return 0;
 }
 
 static void
 cifs_destroy_request_bufs(void)
 {
+	mempool_destroy(cifs_req_poolp);
 	if (kmem_cache_destroy(cifs_req_cachep))
 		printk(KERN_WARNING
 		       "cifs_destroy_request_cache: error not all structures were freed\n");
@@ -612,11 +628,22 @@
 				SLAB_HWCACHE_ALIGN, NULL, NULL);
 	if (cifs_mid_cachep == NULL)
 		return -ENOMEM;
+
+	cifs_mid_poolp = mempool_create(3 /* a reasonable min simultan opers */,
+					mempool_alloc_slab,
+					mempool_free_slab,
+					cifs_mid_cachep);
+	if(cifs_mid_poolp == NULL) {
+		kmem_cache_destroy(cifs_mid_cachep);
+		return -ENOMEM;
+	}
+
 	cifs_oplock_cachep = kmem_cache_create("cifs_oplock_structs",
 				sizeof (struct oplock_q_entry), 0,
 				SLAB_HWCACHE_ALIGN, NULL, NULL);
 	if (cifs_oplock_cachep == NULL) {
 		kmem_cache_destroy(cifs_mid_cachep);
+		mempool_destroy(cifs_mid_poolp);
 		return -ENOMEM;
 	}
 
@@ -626,9 +653,11 @@
 static void
 cifs_destroy_mids(void)
 {
+	mempool_destroy(cifs_mid_poolp);
 	if (kmem_cache_destroy(cifs_mid_cachep))
 		printk(KERN_WARNING
 		       "cifs_destroy_mids: error not all structures were freed\n");
+
 	if (kmem_cache_destroy(cifs_oplock_cachep))
 		printk(KERN_WARNING
 		       "error not all oplock structures were freed\n");
Index: linux-2.6.5/fs/cifs/cifsfs.h
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifsfs.h	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifsfs.h	2004-05-19 10:21:29.000000000 +0200
@@ -93,5 +93,5 @@
 			 size_t, int);
 extern ssize_t	cifs_getxattr(struct dentry *, const char *, void *, size_t);
 extern ssize_t	cifs_listxattr(struct dentry *, char *, size_t);
-#define CIFS_VERSION   "1.13"
+#define CIFS_VERSION   "1.15"
 #endif				/* _CIFSFS_H */
Index: linux-2.6.5/fs/cifs/cifspdu.h
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifspdu.h	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifspdu.h	2004-05-19 10:21:29.000000000 +0200
@@ -34,9 +34,10 @@
 #define SMB_COM_DELETE                0x06
 #define SMB_COM_RENAME                0x07
 #define SMB_COM_LOCKING_ANDX          0x24
+#define SMB_COM_COPY                  0x29
 #define SMB_COM_READ_ANDX             0x2E
 #define SMB_COM_WRITE_ANDX            0x2F
-#define SMB_COM_TRANSACTION2	      0x32
+#define SMB_COM_TRANSACTION2          0x32
 #define SMB_COM_TRANSACTION2_SECONDARY 0x33
 #define SMB_COM_FIND_CLOSE2           0x34
 #define SMB_COM_TREE_DISCONNECT       0x71
@@ -775,6 +776,34 @@
 	/* followed by NewFileName */
 } RENAME_REQ;
 
+	/* copy request flags */
+#define COPY_MUST_BE_FILE      0x0001
+#define COPY_MUST_BE_DIR       0x0002
+#define COPY_TARGET_MODE_ASCII 0x0004 /* if not set, binary */
+#define COPY_SOURCE_MODE_ASCII 0x0008 /* if not set, binary */
+#define COPY_VERIFY_WRITES     0x0010
+#define COPY_TREE              0x0020 
+
+typedef struct smb_com_copy_req {
+	struct smb_hdr hdr;	/* wct = 3 */
+	__u16 Tid2;
+	__u16 OpenFunction;
+	__u16 Flags;
+	__u16 ByteCount;
+	__u8 BufferFormat;	/* 4 = ASCII or Unicode */ 
+	unsigned char OldFileName[1];
+	/* followed by __u8 BufferFormat2 */
+	/* followed by NewFileName string */
+} COPY_REQ;
+
+typedef struct smb_com_copy_rsp {
+	struct smb_hdr hdr;     /* wct = 1 */
+	__u16 CopyCount;    /* number of files copied */
+	__u16 ByteCount;    /* may be zero */
+	__u8 BufferFormat;  /* 0x04 - only present if errored file follows */
+	unsigned char ErrorFileName[1]; /* only present if error in copy */
+} COPY_RSP;
+
 #define CREATE_HARD_LINK		0x103
 #define MOVEFILE_COPY_ALLOWED		0x0002
 #define MOVEFILE_REPLACE_EXISTING	0x0001
@@ -912,6 +941,15 @@
 #define FILE_NOTIFY_CHANGE_STREAM_SIZE  0x00000400
 #define FILE_NOTIFY_CHANGE_STREAM_WRITE 0x00000800
 
+#define FILE_ACTION_ADDED		0x00000001
+#define FILE_ACTION_REMOVED		0x00000002
+#define FILE_ACTION_MODIFIED		0x00000003
+#define FILE_ACTION_RENAMED_OLD_NAME	0x00000004
+#define FILE_ACTION_RENAMED_NEW_NAME	0x00000005
+#define FILE_ACTION_ADDED_STREAM	0x00000006
+#define FILE_ACTION_REMOVED_STREAM	0x00000007
+#define FILE_ACTION_MODIFIED_STREAM	0x00000008
+
 /* response contains array of the following structures */
 struct file_notify_information {
 	__u32 NextEntryOffset;
@@ -1010,8 +1048,13 @@
 #define SMB_SET_FILE_UNIX_HLINK         0x203
 #define SMB_SET_FILE_BASIC_INFO2        0x3ec
 #define SMB_SET_FILE_RENAME_INFORMATION 0x3f2
+#define SMB_FILE_ALL_INFO2              0x3fa
 #define SMB_SET_FILE_ALLOCATION_INFO2   0x3fb
 #define SMB_SET_FILE_END_OF_FILE_INFO2  0x3fc
+#define SMB_FILE_MOVE_CLUSTER_INFO      0x407
+#define SMB_FILE_QUOTA_INFO             0x408
+#define SMB_FILE_REPARSEPOINT_INFO      0x409
+#define SMB_FILE_MAXIMUM_INFO           0x40d
 
 /* Find File infolevels */
 #define SMB_FIND_FILE_DIRECTORY_INFO      0x101
@@ -1273,6 +1316,7 @@
 	__u16 LastNameOffset;
 } T2_FNEXT_RSP_PARMS;
 
+/* QFSInfo Levels */
 #define SMB_INFO_ALLOCATION         1
 #define SMB_INFO_VOLUME             2
 #define SMB_QUERY_FS_VOLUME_INFO    0x102
@@ -1280,6 +1324,8 @@
 #define SMB_QUERY_FS_DEVICE_INFO    0x104
 #define SMB_QUERY_FS_ATTRIBUTE_INFO 0x105
 #define SMB_QUERY_CIFS_UNIX_INFO    0x200
+#define SMB_QUERY_LABEL_INFO        0x3ea
+#define SMB_QUERY_FS_QUOTA_INFO     0x3ee
 
 typedef struct smb_com_transaction2_qfsi_req {
 	struct smb_hdr hdr;	/* wct = 14+ */
Index: linux-2.6.5/fs/cifs/cifsproto.h
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifsproto.h	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifsproto.h	2004-05-19 10:21:29.000000000 +0200
@@ -239,8 +239,9 @@
 			int whence, unsigned long offset, long long *newoffset);
 
 extern int CIFSSMBCopy(int xid,
-			struct cifsTconInfo *ftcon,
-			char *fromName,
-			struct cifsTconInfo *ttcon,
-			char *toName, int ofun, int flags);
+			struct cifsTconInfo *source_tcon,
+			const char *fromName,
+			const __u16 target_tid,
+			const char *toName, const int flags,
+			const struct nls_table *nls_codepage);
 #endif			/* _CIFSPROTO_H */
Index: linux-2.6.5/fs/cifs/cifssmb.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifssmb.c	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifssmb.c	2004-05-19 10:21:29.000000000 +0200
@@ -892,7 +892,6 @@
 	}
 
 	pSMB->ByteCount = 1 /* 1st signature byte */  + name_len + name_len2;
-    /* we could also set search attributes but not needed */
 	pSMB->hdr.smb_buf_length += pSMB->ByteCount;
 	pSMB->ByteCount = cpu_to_le16(pSMB->ByteCount);
 
@@ -986,6 +985,77 @@
 	return rc;
 }
 
+int
+CIFSSMBCopy(const int xid, struct cifsTconInfo *tcon, const char * fromName, 
+              const __u16 target_tid, const char *toName, const int flags,
+              const struct nls_table *nls_codepage)
+{
+        int rc = 0;
+        COPY_REQ *pSMB = NULL;
+        COPY_RSP *pSMBr = NULL;
+        int bytes_returned;
+        int name_len, name_len2;
+
+        cFYI(1, ("In CIFSSMBCopy"));
+copyRetry:
+        rc = smb_init(SMB_COM_COPY, 1, tcon, (void **) &pSMB,
+                      (void **) &pSMBr);
+        if (rc)
+                return rc;
+
+        pSMB->BufferFormat = 0x04;
+	pSMB->Tid2 = target_tid;
+
+	if(flags & COPY_TREE)
+		pSMB->Flags |= COPY_TREE;
+	pSMB->Flags = cpu_to_le16(pSMB->Flags);
+
+        if (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {
+                name_len =
+                    cifs_strtoUCS((wchar_t *) pSMB->OldFileName, fromName, 530
+                                  /* find define for this maxpathcomponent */
+                                  , nls_codepage);
+                name_len++;     /* trailing null */
+                name_len *= 2;
+                pSMB->OldFileName[name_len] = 0x04;     /* pad */
+        /* protocol requires ASCII signature byte on Unicode string */
+                pSMB->OldFileName[name_len + 1] = 0x00;
+                name_len2 =
+                    cifs_strtoUCS((wchar_t *) & pSMB->
+                                  OldFileName[name_len + 2], toName, 530,
+                                  nls_codepage);
+                name_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;
+                name_len2 *= 2; /* convert to bytes */
+        } else {                /* BB improve the check for buffer overruns BB */
+                name_len = strnlen(fromName, 530);
+                name_len++;     /* trailing null */
+                strncpy(pSMB->OldFileName, fromName, name_len);
+                name_len2 = strnlen(toName, 530);
+                name_len2++;    /* trailing null */
+                pSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */
+                strncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);
+                name_len2++;    /* trailing null */
+                name_len2++;    /* signature byte */
+        }
+
+        pSMB->ByteCount = 1 /* 1st signature byte */  + name_len + name_len2;
+        pSMB->hdr.smb_buf_length += pSMB->ByteCount;
+        pSMB->ByteCount = cpu_to_le16(pSMB->ByteCount);
+
+	rc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,
+		(struct smb_hdr *) pSMBr, &bytes_returned, 0);
+	if (rc) {
+		cFYI(1, ("Send error in copy = %d with %d files copied",
+			rc, pSMBr->CopyCount));
+	}
+	if (pSMB)
+		cifs_buf_release(pSMB);
+
+	if (rc == -EAGAIN)
+		goto copyRetry;
+
+	return rc;
+}
 
 int
 CIFSUnixCreateSymLink(const int xid, struct cifsTconInfo *tcon,
Index: linux-2.6.5/fs/cifs/connect.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/connect.c	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/connect.c	2004-05-19 10:21:04.000000000 +0200
@@ -63,6 +63,7 @@
 	mode_t dir_mode;
 	int rw:1;
 	int retry:1;
+	int intr:1;
 	unsigned int rsize;
 	unsigned int wsize;
 	unsigned int sockopt;
@@ -699,6 +700,7 @@
 				   (strnicmp(data, "exec", 4) == 0) ||
 				   (strnicmp(data, "noexec", 6) == 0) ||
 				   (strnicmp(data, "nodev", 5) == 0) ||
+				   (strnicmp(data, "noauto", 6) == 0) ||
 				   (strnicmp(data, "dev", 3) == 0)) {
 			/*  The mount tool or mount.cifs helper (if present)
 				uses these opts to set flags, and the flags are read
@@ -717,6 +719,12 @@
 			vol->retry = 0;
 		} else if (strnicmp(data, "nosoft", 6) == 0) {
 			vol->retry = 1;
+		} else if (strnicmp(data, "nointr", 6) == 0) {
+			vol->intr = 0;
+		} else if (strnicmp(data, "intr", 4) == 0) {
+			vol->intr = 1;
+		} else if (strnicmp(data, "noac", 4) == 0) {
+			printk(KERN_WARNING "CIFS: Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\n");
 		} else
 			printk(KERN_WARNING "CIFS: Unknown mount option %s\n",data);
 	}
Index: linux-2.6.5/fs/cifs/file.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/file.c	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/file.c	2004-05-19 10:21:00.000000000 +0200
@@ -1793,10 +1793,10 @@
 					cifsFile->search_resume_name = 
 						kmalloc(cifsFile->resume_name_length, GFP_KERNEL);
 					cFYI(1,("fnext last file: %s with name %d bytes long",
-						lastFindData->FileName,
+						pfindDataUnix->FileName,
 						cifsFile->resume_name_length));
 					memcpy(cifsFile->search_resume_name,
-						lastFindData->FileName, 
+						pfindDataUnix->FileName, 
 						cifsFile->resume_name_length);
 				}
 
Index: linux-2.6.5/fs/cifs/inode.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/inode.c	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/inode.c	2004-05-19 10:20:53.000000000 +0200
@@ -647,9 +647,12 @@
 		}
 	}
 
-
+	/* can not grab this sem since kernel filesys locking
+		documentation indicates i_sem may be taken by the kernel 
+		on lookup and rename which could deadlock if we grab
+		the i_sem here as well */
+/*	down(&direntry->d_inode->i_sem);*/
 	/* need to write out dirty pages here  */
-	down(&direntry->d_inode->i_sem);
 	if(direntry->d_inode->i_mapping) {
 		/* do we need to lock inode until after invalidate completes below? */
 		filemap_fdatawrite(direntry->d_inode->i_mapping);
@@ -663,9 +666,7 @@
 			invalidate_remote_inode(direntry->d_inode);
 		}
 	}
-
-
-	up(&direntry->d_inode->i_sem);
+/*	up(&direntry->d_inode->i_sem);*/
 	
 	if (full_path)
 		kfree(full_path);
Index: linux-2.6.5/fs/cifs/misc.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/misc.c	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/misc.c	2004-05-19 10:20:47.000000000 +0200
@@ -21,6 +21,7 @@
 
 #include <linux/slab.h>
 #include <linux/ctype.h>
+#include <linux/mempool.h>
 #include "cifspdu.h"
 #include "cifsglob.h"
 #include "cifsproto.h"
@@ -28,7 +29,7 @@
 #include "smberr.h"
 #include "nterr.h"
 
-extern kmem_cache_t *cifs_req_cachep;
+extern mempool_t *cifs_req_poolp;
 extern struct task_struct * oplockThread;
 
 __u16 GlobalMid;		/* multiplex id - rotating counter */
@@ -153,7 +154,7 @@
    albeit slightly larger than necessary and maxbuffersize 
    defaults to this and can not be bigger */
 	ret_buf =
-	    (struct smb_hdr *) kmem_cache_alloc(cifs_req_cachep, SLAB_KERNEL | SLAB_NOFS);
+	    (struct smb_hdr *) mempool_alloc(cifs_req_poolp, SLAB_KERNEL | SLAB_NOFS);
 
 	/* clear the first few header bytes */
 	if (ret_buf) {
@@ -172,7 +173,7 @@
 		cFYI(1, ("Null buffer passed to cifs_buf_release"));
 		return;
 	}
-	kmem_cache_free(cifs_req_cachep, buf_to_free);
+	mempool_free(buf_to_free,cifs_req_poolp);
 
 	atomic_dec(&bufAllocCount);
 	return;
Index: linux-2.6.5/fs/cifs/transport.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/transport.c	2004-05-19 10:15:10.000000000 +0200
+++ linux-2.6.5/fs/cifs/transport.c	2004-05-19 10:20:47.000000000 +0200
@@ -25,12 +25,13 @@
 #include <linux/net.h>
 #include <asm/uaccess.h>
 #include <asm/processor.h>
+#include <linux/mempool.h>
 #include "cifspdu.h"
 #include "cifsglob.h"
 #include "cifsproto.h"
 #include "cifs_debug.h"
   
-extern kmem_cache_t *cifs_mid_cachep;
+extern mempool_t *cifs_mid_poolp;
 extern kmem_cache_t *cifs_oplock_cachep;
 
 struct mid_q_entry *
@@ -47,8 +48,7 @@
 		return NULL;
 	}
 	
-	temp = (struct mid_q_entry *) kmem_cache_alloc(cifs_mid_cachep,
-						       SLAB_KERNEL);
+	temp = (struct mid_q_entry *) mempool_alloc(cifs_mid_poolp,SLAB_KERNEL | SLAB_NOFS);
 	if (temp == NULL)
 		return temp;
 	else {
@@ -79,7 +79,7 @@
 	atomic_dec(&midCount);
 	spin_unlock(&GlobalMid_Lock);
 	cifs_buf_release(midEntry->resp_buf);
-	kmem_cache_free(cifs_mid_cachep, midEntry);
+	mempool_free(midEntry, cifs_mid_poolp);
 }
 
 struct oplock_q_entry *
