diff -urNp linux-2.6.5/Documentation/scsi/aic79xx.txt linux-2.6.5.SUSE/Documentation/scsi/aic79xx.txt
--- linux-2.6.5/Documentation/scsi/aic79xx.txt	2004-04-04 05:37:37.000000000 +0200
+++ linux-2.6.5.SUSE/Documentation/scsi/aic79xx.txt	2004-05-13 16:42:17.000000000 +0200
@@ -1,5 +1,5 @@
 ====================================================================
-=             Adaptec Ultra320 Family Manager Set v1.3.11          =
+=             Adaptec Ultra320 Family Manager Set v2.0.8           =
 =                                                                  =
 =                            README for                            =
 =                    The Linux Operating System                    =
@@ -63,6 +63,157 @@ The following information is available i
                               68-pin)
 2. Version History
 
+   2.0.8 (March 7th, 2004)
+        - Fix PCI device/vendor ID mask for the 7901B probe entry
+          so the driver will successfully attach to 7901B parts
+          down on motherboards.
+
+   2.0.7 (February 24th, 2004)
+        - Implement delay on I/O after delivery of a Target Reset.
+        - Correct deregistration of sysrq handler when multiple
+          controllers are detected.
+
+   2.0.6 (February 6th, 2004)
+        - Force a renegotiation on all inqury commands so that
+          the negotiated transfer parameters are correct even
+          if the device has been externally reset since our last
+          command.  Devices are not allowed to report unit attention
+          conditions in response to inquiry requests otherwise we'd
+          not need to treat inquiry commands specially.
+        - Remove all vestiges of pre-2.4.X support.
+        - Close a very rare race-condition in RevA 790X controllers.
+          If both FIFOs are allocated before the sequencer's idle
+          loop is able to service the FIFO that was allocated first,
+          the sequencer could handle them out of order.  This could
+          lead to a deadlock where the FIFO attached to the SCSI bus
+          is being serviced by the sequencer, but the other FIFO is
+          required to handle a snapshot.  The sequencer now detects
+          this condition and always handles FIFOs that are not currently
+          on the bus first.
+        - Close a few race conditions by adding critical section
+          markers into the firmware.  These windows might have caused
+          issues during error recovery.
+        - Switch the complete DMA SCB list to a tailq so that multiple
+          SCBs completing with non-zero status do not interfere with
+          the state for the SCB currently being uploaded.
+        - Use the comparison of a kernel and a sequencer qfreeze
+          count to control the freezing of outgoing selections.  This
+          allows the kernel to handle non-zero SCB completions without
+          having to clear firmware critical sections.
+        - Change the completion FIFO mechanism so that all completion
+          entries are guaranteed aligned on a 64bit boundary.  This
+          avoids SCB DMA engine bugs that are triggered if the transfer
+          is interrupted (e.g. PCI disconnect) on a non-aligned boundary.
+          In some cases, these bugs would result in duplicate completions.
+        - Use one byte in the new completion entry to indicate if the
+          SCB completed without a residual or non-zero SCSI status.  This
+          avoids an extra memory reference in our interrupt handler.
+
+   2.0.5 (December 22nd, 2003)
+        - Correct a bug preventing the driver from renegotiating
+          during auto-request sense operations when a check
+          condition occurred for a zero length command.
+        - Sniff sense information returned by targets for unit
+          attention errors that may indicate that the device has
+          been changed.  If we see such status for non Domain
+          Validation related commands, start a DV scan for the
+          target.  In the past, DV would only occur for hot-plugged
+          devices if no target had been previously probed for a
+          particular ID.  This change guarantees that the DV process
+          will occur even if the user swaps devices without any
+          interveining I/O to tell us that a device has gone missing.
+          The old behavior, among other things, would fail to spin up
+          drives that were hot-plugged since the Linux mid-layer
+          will only spin-up drives on initial attach.
+        - Correct several issues in the rundown of the good status
+          FIFO during error recovery.  The typical failure scenario
+          evidenced by this defect was the loss of several commands
+          under high load when	 several queue full conditions occured
+          back to back.
+
+   2.0.4 (November 6th, 2003)
+        - Support the 2.6.0-test9 kernel
+        - Fix rare deadlock caused by using del_timer_sync from within
+          a timer handler.
+
+   2.0.3 (October 21st, 2003)
+        - On 7902A4 hardware, use the slow slew rate for transfer
+          rates slower than U320.  This behavior matches the Windows
+          driver.
+        - Fix some issues with the ahd_flush_qoutfifo() routine.
+        - Add a delay in the loop waiting for selection activity
+          to cease.  Otherwise we may exhaust the loop counter too
+          quickly on fast machines.
+        - Return to processing bad status completions through the
+          qoutfifo.  This reduces the amount of time the controller
+          is paused for these kinds of errors.
+        - Move additional common routines to the aiclib OSM library
+          to reduce code duplication.
+        - Leave removal of softcs from the global list of softcs to
+          the OSM.  This allows us to avoid holding the list_lock during
+          device destruction.
+        - Enforce a bus settle delay for bus resets that the
+          driver initiates.
+        - Fall back to basic DV for U160 devices that lack an
+          echo buffer.
+
+   2.0.2 (September 4th, 2003)
+        - Move additional common routines to the aiclib OSM library
+          to reduce code duplication.
+        - Avoid an inadvertant reset of the controller during the
+          memory mapped I/O test should the controller be left in
+          the reset state prior to driver initialization.  On some
+          systems, this extra reset resulted in a system hang due
+          to a chip access that occurred too soon after reset.
+        - Correct an endian bug in ahd_swap_with_next_hscb.  This
+          corrects strong-arm support.
+        - Reset the bus for transactions that timeout waiting for
+          the bus to go free after a disconnect or command complete
+          message.
+
+   2.0.1 (August 26th, 2003)
+        - Add magic sysrq handler that causes a card dump to be output
+          to the console for each controller.
+        - Avoid waking the mid-layer's error recovery handler during
+          timeout recovery by returning DID_ERROR instead of DID_TIMEOUT
+          for timed-out commands that have been aborted.
+        - Move additional common routines to the aiclib OSM library
+          to reduce code duplication.
+
+   2.0.0 (August 20th, 2003)
+        - Remove MMAPIO definition and allow memory mapped
+          I/O for any platform that supports PCI.
+        - Avoid clearing ENBUSFREE during single stepping to avoid
+          spurious "unexpected busfree while idle" messages.
+        - Correct deadlock in ahd_run_qoutfifo() processing.
+        - Optimize support for the 7901B.
+        - Correct a few cases where an explicit flush of pending
+          register writes was required to ensure acuracy in delays.
+        - Correct problems in manually flushing completed commands
+          on the controller.  The FIFOs are now flushed to ensure
+          that completed commands that are still draining to the
+          host are completed correctly.
+        - Correct incomplete CDB delivery detection on the 790XB.
+        - Ignore the cmd->underflow field since userland applications
+          using the legacy command pass-thru interface do not set
+          it correctly.  Honoring this field led to spurious errors
+          when users used the "scsi_unique_id" program.
+        - Perform timeout recovery within the driver instead of relying
+          on the Linux SCSI mid-layer to perform this function.  The
+          mid-layer does not know the full state of the SCSI bus and
+          is therefore prone to looping for several minutes to effect
+          recovery.  The new scheme recovers within 15 seconds of the
+          failure.
+        - Correct support for manual termination settings.
+        - Increase maximum wait time for serial eeprom writes allowing
+          writes to function correctly.
+
+   1.3.12 (August 11, 2003)
+        - Implement new error recovery thread that supercedes the existing
+          Linux SCSI error recovery code.
+        - Fix termination logic for 29320ALP.
+        - Fix SEEPROM delay to compensate for write ops taking longer.
+
    1.3.11 (July 11, 2003)
         - Fix several deadlock issues.
         - Add 29320ALP and 39320B Id's.
@@ -194,7 +345,7 @@ The following information is available i
           supported)
         - Support for the PCI-X standard up to 133MHz
         - Support for the PCI v2.2 standard
-	- Domain Validation
+        - Domain Validation
 
    2.2. Operating System Support:
         - Redhat Linux 7.2, 7.3, 8.0, Advanced Server 2.1
diff -urNp linux-2.6.5/Documentation/scsi/aic7xxx.txt linux-2.6.5.SUSE/Documentation/scsi/aic7xxx.txt
--- linux-2.6.5/Documentation/scsi/aic7xxx.txt	2004-04-04 05:36:53.000000000 +0200
+++ linux-2.6.5.SUSE/Documentation/scsi/aic7xxx.txt	2004-05-13 16:42:17.000000000 +0200
@@ -1,5 +1,5 @@
 ====================================================================
-=    Adaptec Aic7xxx Fast -> Ultra160 Family Manager Set v6.2.28   =
+=    Adaptec Aic7xxx Fast -> Ultra160 Family Manager Set v6.3.6    =
 =                            README for                            =
 =                     The Linux Operating System                   =
 ====================================================================
@@ -131,6 +131,97 @@ The following information is available i
       SCSI "stub" effects.
 
 2. Version History
+
+   6.3.6 (February 24th, 2004)
+        - Implement delay on I/O after delivery of a Target Reset.
+        - Correct deregistration of sysrq handler when multiple
+          controllers are detected.
+        - Correct timeout recovery issues found while debugging
+          active/active failover on an external RAID controller.
+
+   6.3.5 (February 22nd, 2004)
+        - Force a renegotiation on all inqury commands so that
+          the negotiated transfer parameters are correct even
+          if the device has been externally reset since our last
+          command.  Devices are not allowed to report unit attention
+          conditions in response to inquiry requests otherwise we'd
+          not need to treat inquiry commands specially.
+        - Remove all vestiges of pre-2.4.X support.
+        - Move all lock and DMA API support to the aiclib.
+
+   6.3.4 (December 22nd, 2003)
+        - Provide a better description string for the 2915/30LP.
+        - Sniff sense information returned by targets for unit
+          attention errors that may indicate that the device has
+          been changed.  If we see such status for non Domain
+          Validation related commands, start a DV scan for the
+          target.  In the past, DV would only occur for hot-plugged
+          devices if no target had been previously probed for a
+          particular ID.  This change guarantees that the DV process
+          will occur even if the user swaps devices without any
+          interveining I/O to tell us that a device has gone missing.
+          The old behavior, among other things, would fail to spin up
+          drives that were hot-plugged since the Linux mid-layer
+          will only spin-up drives on initial attach.
+
+   6.3.3 (November 6th, 2003)
+        - Support the 2.6.0-test9 kernel
+        - Fix rare deadlock caused by using del_timer_sync from within
+          a timer handler.
+
+   6.3.2 (October 28th, 2003)
+        - Enforce a bus settle delay for bus resets that the
+          driver initiates.
+        - Fall back to basic DV for U160 devices that lack an
+          echo buffer.
+        - Correctly detect that left over BIOS data has not
+          been initialized when the CHPRST status bit is set
+          during driver initialization.
+
+   6.3.1 (October 21st, 2003)
+        - Fix a compiler error when building with only EISA or PCI
+          support compiled into the kernel.
+        - Add chained dependencies to both the driver and aicasm Makefiles
+          to avoid problems with parallel builds.
+        - Move additional common routines to the aiclib OSM library
+          to reduce code duplication.
+        - Fix a bug in the testing of the AHC_TMODE_WIDEODD_BUG that
+          could cause target mode operations to hang.
+        - Leave removal of softcs from the global list of softcs to
+          the OSM.  This allows us to avoid holding the list_lock during
+          device destruction.
+
+   6.3.0 (September 8th, 2003)
+        - Move additional common routines to the aiclib OSM library
+          to reduce code duplication.
+        - Bump minor number to reflect change in error recovery strategy.
+
+   6.2.38 (August 31st, 2003)
+        - Avoid an inadvertant reset of the controller during the
+          memory mapped I/O test should the controller be left in
+          the reset state prior to driver initialization.  On some
+          systems, this extra reset resulted in a system hang due
+          to a chip access that occurred too soon after reset.
+        - Move additional common routines to the aiclib OSM library
+          to reduce code duplication.
+        - Add magic sysrq handler that causes a card dump to be output
+          to the console for each controller.
+
+   6.2.37 (August 12th, 2003)
+        - Perform timeout recovery within the driver instead of relying
+          on the Linux SCSI mid-layer to perform this function.  The
+          mid-layer does not know the full state of the SCSI bus and
+          is therefore prone to looping for several minutes to effect
+          recovery.  The new scheme recovers within 15 seconds of the
+          failure.
+        - Support writing 93c56/66 SEEPROM on newer cards.
+	- Avoid clearing ENBUSFREE during single stepping to avoid
+          spurious "unexpected busfree while idle" messages.
+        - Enable the use of the "Auto-Access-Pause" feature on the
+          aic7880 and aic7870 chips.  It was disabled due to an
+          oversight.  Using this feature drastically reduces command
+          delivery latency.
+
    6.2.36 (June 3rd, 2003)
         - Correct code that disables PCI parity error checking.
         - Correct and simplify handling of the ignore wide residue
@@ -305,7 +396,7 @@ The following information is available i
    -----------------------------------------------------------------
 
    Example:
-   'options aic7xxx aic7xxx=verbose,no_probe,tag_info:{{},{,,10}},seltime:1"
+   options aic7xxx aic7xxx=verbose,no_probe,tag_info:{{},{,,10}},seltime:1
         enables verbose logging, Disable EISA/VLB probing,
         and set tag depth on Controller 1/Target 2 to 10 tags.
 
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/Kconfig.aic79xx linux-2.6.5.SUSE/drivers/scsi/aic7xxx/Kconfig.aic79xx
--- linux-2.6.5/drivers/scsi/aic7xxx/Kconfig.aic79xx	2004-04-04 05:36:57.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/Kconfig.aic79xx	2004-05-13 16:42:17.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # AIC79XX 2.5.X Kernel configuration File.
-# $Id: //depot/linux-aic79xx-2.5.0/drivers/scsi/aic7xxx/Kconfig.aic79xx#4 $
+# $Id$
 #
 config SCSI_AIC79XX
 	tristate "Adaptec AIC79xx U320 support"
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/Kconfig.aic7xxx linux-2.6.5.SUSE/drivers/scsi/aic7xxx/Kconfig.aic7xxx
--- linux-2.6.5/drivers/scsi/aic7xxx/Kconfig.aic7xxx	2004-04-04 05:36:55.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/Kconfig.aic7xxx	2004-05-13 16:42:17.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # AIC7XXX and AIC79XX 2.5.X Kernel configuration File.
-# $Id: //depot/linux-aic79xx-2.5.0/drivers/scsi/aic7xxx/Kconfig.aic7xxx#7 $
+# $Id$
 #
 config SCSI_AIC7XXX
 	tristate "Adaptec AIC7xxx Fast -> U160 support (New Driver)"
@@ -11,9 +11,6 @@ config SCSI_AIC7XXX
 	SCSI controllers (the 274x and 284x series).  For AAA and ARO based
 	configurations, only SCSI functionality is provided.
 
-	To compile this driver as a module, choose M here: the
-	module will be called aic7xxx.
-
 config AIC7XXX_CMDS_PER_DEVICE
 	int "Maximum number of TCQ commands per device"
 	depends on SCSI_AIC7XXX
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/Makefile linux-2.6.5.SUSE/drivers/scsi/aic7xxx/Makefile
--- linux-2.6.5/drivers/scsi/aic7xxx/Makefile	2004-04-04 05:38:22.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/Makefile	2004-05-13 16:42:17.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Makefile for the Linux aic7xxx SCSI driver.
 #
-# $Id: //depot/linux-aic79xx-2.5.0/drivers/scsi/aic7xxx/Makefile#8 $
+# $Id$
 #
 
 # Let kbuild descend into aicasm when cleaning
@@ -33,10 +33,7 @@ aic79xx-y					+= aic79xx_osm.o	\
 						   aic79xx_proc.o	\
 						   aic79xx_osm_pci.o
 
-EXTRA_CFLAGS += -Idrivers/scsi
-ifdef WARNINGS_BECOME_ERRORS
-EXTRA_CFLAGS += -Werror
-endif
+EXTRA_CFLAGS += -Idrivers/scsi -Werror
 #EXTRA_CFLAGS += -g
 
 # Files generated that shall be removed upon make clean
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7770.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7770.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7770.c	2004-04-04 05:38:23.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7770.c	2004-05-13 16:42:17.000000000 +0200
@@ -37,9 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7770.c#32 $
- *
- * $FreeBSD$
+ * $Id$
  */
 
 #ifdef __linux__
@@ -47,6 +45,8 @@
 #include "aic7xxx_inline.h"
 #include "aic7xxx_93cx6.h"
 #else
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
 #include <dev/aic7xxx/aic7xxx_osm.h>
 #include <dev/aic7xxx/aic7xxx_inline.h>
 #include <dev/aic7xxx/aic7xxx_93cx6.h>
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7770_osm.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7770_osm.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7770_osm.c	2004-04-04 05:37:36.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7770_osm.c	2004-05-13 16:42:17.000000000 +0200
@@ -36,7 +36,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#14 $
+ * $Id$
  */
 
 #include "aic7xxx_osm.h"
@@ -73,7 +73,7 @@ typedef void *aic7770_dev_t;
 static int aic7770_linux_config(struct aic7770_identity *entry,
 				aic7770_dev_t dev, u_int eisaBase);
 
-void
+int
 ahc_linux_eisa_init(void)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -82,7 +82,7 @@ ahc_linux_eisa_init(void)
 	int i;
 
 	if (aic7xxx_probe_eisa_vl == 0)
-		return;
+		return (0);
 
 	/*
 	 * Linux requires the EISA IDs to be specified in
@@ -93,7 +93,7 @@ ahc_linux_eisa_init(void)
 					 (ahc_num_aic7770_devs + 1),
 					 M_DEVBUF, M_NOWAIT);
 	if (aic7770_driver.id_table == NULL)
-		return;
+		return (-ENOMEM);
 
 	for (eid = (struct eisa_device_id *)aic7770_driver.id_table,
 	     id = aic7770_ident_table, i = 0;
@@ -109,7 +109,7 @@ ahc_linux_eisa_init(void)
 	}
 	eid->sig[0] = 0;
 
-	eisa_driver_register(&aic7770_driver);
+	return (eisa_driver_register(&aic7770_driver));
 #else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) */
 	struct aic7770_identity *entry;
 	u_int  slot;
@@ -117,21 +117,15 @@ ahc_linux_eisa_init(void)
 	u_int  i;
 
 	if (aic7xxx_probe_eisa_vl == 0)
-		return;
+		return (0);
 
 	eisaBase = 0x1000 + AHC_EISA_SLOT_OFFSET;
 	for (slot = 1; slot < NUMSLOTS; eisaBase+=0x1000, slot++) {
 		uint32_t eisa_id;
 		size_t	 id_size;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-		if (check_region(eisaBase, AHC_EISA_IOSIZE) != 0)
-			continue;
-		request_region(eisaBase, AHC_EISA_IOSIZE, "aic7xxx");
-#else
 		if (request_region(eisaBase, AHC_EISA_IOSIZE, "aic7xxx") == 0)
 			continue;
-#endif
 
 		eisa_id = 0;
 		id_size = sizeof(eisa_id);
@@ -149,6 +143,7 @@ ahc_linux_eisa_init(void)
 		if (entry != NULL)
 			aic7770_linux_config(entry, NULL, eisaBase);
 	}
+	return (0);
 #endif
 }
 
@@ -190,6 +185,14 @@ aic7770_linux_config(struct aic7770_iden
 		free(name, M_DEVBUF);
 		return (ENOMEM);
 	}
+	ahc->dev_softc = dev;
+	if (aic_set_dma_mask(ahc, 0xFFFFFFFF) != 0
+       /*|| aic_set_consistent_dma_mask(ahc, 0xFFFFFFFF) != 0 */) {
+		printk(KERN_WARNING "aic7xxx: Unable to set DMA masks.\n");
+		ahc_free(ahc);
+		return (-ENOMEM);
+	}
+	ahc->platform_data->hw_dma_mask = 0xFFFFFFFF;
 	error = aic7770_config(ahc, entry, eisaBase);
 	if (error != 0) {
 		ahc->bsh.ioport = 0;
@@ -210,14 +213,8 @@ aic7770_map_registers(struct ahc_softc *
 	/*
 	 * Lock out other contenders for our i/o space.
 	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-	if (check_region(port, AHC_EISA_IOSIZE) != 0)
-		return (ENOMEM);
-	request_region(port, AHC_EISA_IOSIZE, "aic7xxx");
-#else
 	if (request_region(port, AHC_EISA_IOSIZE, "aic7xxx") == 0)
 		return (ENOMEM);
-#endif
 	ahc->tag = BUS_SPACE_PIO;
 	ahc->bsh.ioport = port;
 	return (0);
@@ -267,12 +264,14 @@ aic7770_eisa_dev_remove(struct device *d
 	if (ahc != NULL) {
 		u_long s;
 
+		TAILQ_REMOVE(&ahc_tailq, ahc, links);
+		ahc_list_unlock(&l);
 		ahc_lock(ahc, &s);
 		ahc_intr_enable(ahc, FALSE);
 		ahc_unlock(ahc, &s);
 		ahc_free(ahc);
-	}
-	ahc_list_unlock(&l);
+	} else
+		ahc_list_unlock(&l);
 
 	return (0);
 }
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx.h linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx.h
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx.h	2004-04-04 05:37:36.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx.h	2004-05-13 16:42:17.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.h#95 $
+ * $Id$
  *
  * $FreeBSD$
  */
@@ -74,9 +74,8 @@ struct scb_platform_data;
 #define ALL_TARGETS_MASK 0xFFFF
 #define INITIATOR_WILDCARD	(~0)
 #define	SCB_LIST_NULL		0xFF00
-#define	SCB_LIST_NULL_LE	(ahd_htole16(SCB_LIST_NULL))
-#define QOUTFIFO_ENTRY_VALID 0x8000
-#define QOUTFIFO_ENTRY_VALID_LE (ahd_htole16(0x8000))
+#define	SCB_LIST_NULL_LE	(aic_htole16(SCB_LIST_NULL))
+#define QOUTFIFO_ENTRY_VALID 0x80
 #define SCBID_IS_NULL(scbid) (((scbid) & 0xFF00 ) == SCB_LIST_NULL)
 
 #define SCSIID_TARGET(ahd, scsiid)	\
@@ -118,7 +117,7 @@ struct scb_platform_data;
 	((lun) | ((target) << 8))
 
 #define SCB_GET_TAG(scb) \
-	ahd_le16toh(scb->hscb->tag)
+	aic_le16toh(scb->hscb->tag)
 
 #ifndef	AHD_TARGET_MODE
 #undef	AHD_TMODE_ENABLE
@@ -202,6 +201,8 @@ do {								\
 #define AHD_BUSRESET_DELAY	25
 
 /******************* Chip Characteristics/Operating Settings  *****************/
+extern uint32_t ahd_attach_to_HostRAID_controllers;
+
 /*
  * Chip Type
  * The chip order is from least sophisticated to most sophisticated.
@@ -375,7 +376,9 @@ typedef enum {
 	AHD_RESET_POLL_ACTIVE = 0x200000,
 	AHD_UPDATE_PEND_CMDS  = 0x400000,
 	AHD_RUNNING_QOUTFIFO  = 0x800000,
-	AHD_HAD_FIRST_SEL     = 0x1000000
+	AHD_HAD_FIRST_SEL     = 0x1000000,
+	AHD_SHUTDOWN_RECOVERY = 0x2000000, /* Terminate recovery thread. */
+	AHD_HOSTRAID_BOARD    = 0x4000000
 } ahd_flag;
 
 /************************* Hardware  SCB Definition ***************************/
@@ -549,7 +552,7 @@ struct ahd_dma64_seg {
 
 struct map_node {
 	bus_dmamap_t		 dmamap;
-	bus_addr_t		 physaddr;
+	bus_addr_t		 busaddr;
 	uint8_t			*vaddr;
 	SLIST_ENTRY(map_node)	 links;
 };
@@ -591,12 +594,16 @@ typedef enum {
 	SCB_PKT_SENSE		= 0x02000,
 	SCB_CMDPHASE_ABORT	= 0x04000,
 	SCB_ON_COL_LIST		= 0x08000,
-	SCB_SILENT		= 0x10000 /*
+	SCB_SILENT		= 0x10000,/*
 					   * Be quiet about transmission type
 					   * errors.  They are expected and we
 					   * don't want to upset the user.  This
 					   * flag is typically used during DV.
 					   */
+	SCB_TIMEDOUT		= 0x20000/*
+					  * SCB has timed out and is on the
+					  * timedout list.
+					  */
 } scb_flag;
 
 struct scb {
@@ -613,8 +620,9 @@ struct scb {
 	} links2;
 #define pending_links links2.le
 #define collision_links links2.le
+	LIST_ENTRY(scb)		  timedout_links;
 	struct scb		 *col_scb;
-	ahd_io_ctx_t		  io_ctx;
+	aic_io_ctx_t		  io_ctx;
 	struct ahd_softc	 *ahd_softc;
 	scb_flag		  flags;
 #ifndef __linux__
@@ -1053,6 +1061,14 @@ typedef uint8_t ahd_mode_state;
 
 typedef void ahd_callback_t (void *);
 
+struct ahd_completion
+{
+	uint16_t	tag;
+	uint8_t		sg_status;
+	uint8_t		pad[4];
+	uint8_t		valid_tag;
+};
+
 struct ahd_softc {
 	bus_space_tag_t           tags[2];
 	bus_space_handle_t        bshs[2];
@@ -1062,6 +1078,7 @@ struct ahd_softc {
 	struct scb_data		  scb_data;
 
 	struct hardware_scb	 *next_queued_hscb;
+	struct map_node		 *next_queued_hscb_map;
 
 	/*
 	 * SCBs that have been sent to the controller
@@ -1069,6 +1086,11 @@ struct ahd_softc {
 	LIST_HEAD(, scb)	  pending_scbs;
 
 	/*
+	 * SCBs whose timeout routine has been called.
+	 */
+	LIST_HEAD(, scb)	  timedout_scbs;
+
+	/*
 	 * Current register window mode information.
 	 */
 	ahd_mode		  dst_mode;
@@ -1089,7 +1111,7 @@ struct ahd_softc {
 	/*
 	 * Platform specific device information.
 	 */
-	ahd_dev_softc_t		  dev_softc;
+	aic_dev_softc_t		  dev_softc;
 
 	/*
 	 * Bus specific device information.
@@ -1119,8 +1141,8 @@ struct ahd_softc {
 	/*
 	 * Timer handles for timer driven callbacks.
 	 */
-	ahd_timer_t		  reset_timer;
-	ahd_timer_t		  stat_timer;
+	aic_timer_t		  reset_timer;
+	aic_timer_t		  stat_timer;
 
 	/*
 	 * Statistics.
@@ -1140,16 +1162,23 @@ struct ahd_softc {
 	ahd_flag		  flags;
 	struct seeprom_config	 *seep_config;
 
-	/* Values to store in the SEQCTL register for pause and unpause */
-	uint8_t			  unpause;
-	uint8_t			  pause;
-
 	/* Command Queues */
+	struct ahd_completion    *qoutfifo;
 	uint16_t		  qoutfifonext;
 	uint16_t		  qoutfifonext_valid_tag;
 	uint16_t		  qinfifonext;
 	uint16_t		  qinfifo[AHD_SCB_MAX];
-	uint16_t		 *qoutfifo;
+
+	/*
+	 * Our qfreeze count.  The sequencer compares
+	 * this value with its own counter to determine
+	 * whether to allow selections to occur.
+	 */
+	uint16_t		  qfreeze_cnt;
+
+	/* Values to store in the SEQCTL register for pause and unpause */
+	uint8_t			  unpause;
+	uint8_t			  pause;
 
 	/* Critical Section Data */
 	struct cs		 *critical_sections;
@@ -1197,8 +1226,7 @@ struct ahd_softc {
 	 */
 	bus_dma_tag_t		  parent_dmat;
 	bus_dma_tag_t		  shared_data_dmat;
-	bus_dmamap_t		  shared_data_dmamap;
-	bus_addr_t		  shared_data_busaddr;
+	struct map_node		  shared_data_map;
 
 	/* Information saved through suspend/resume cycles */
 	struct ahd_suspend_state  suspend_state;
@@ -1299,9 +1327,9 @@ struct ahd_devinfo {
 };
 
 /****************************** PCI Structures ********************************/
-#define AHD_PCI_IOADDR0	PCIR_MAPS	/* I/O BAR*/
-#define AHD_PCI_MEMADDR	(PCIR_MAPS + 4)	/* Memory BAR */
-#define AHD_PCI_IOADDR1	(PCIR_MAPS + 12)/* Second I/O BAR */
+#define AHD_PCI_IOADDR0	PCIR_BAR(0)	/* I/O BAR*/
+#define AHD_PCI_MEMADDR	PCIR_BAR(1)	/* Memory BAR */
+#define AHD_PCI_IOADDR1	PCIR_BAR(3)	/* Second I/O BAR */
 
 typedef int (ahd_device_setup_t)(struct ahd_softc *);
 
@@ -1341,7 +1369,7 @@ ahd_unbusy_tcl(struct ahd_softc *ahd, u_
 }
 
 /***************************** PCI Front End *********************************/
-struct	ahd_pci_identity *ahd_find_pci_device(ahd_dev_softc_t);
+struct	ahd_pci_identity *ahd_find_pci_device(aic_dev_softc_t);
 int			  ahd_pci_config(struct ahd_softc *,
 					 struct ahd_pci_identity *);
 int	ahd_pci_test_register_access(struct ahd_softc *);
@@ -1433,6 +1461,8 @@ void			ahd_handle_scsi_status(struct ahd
 					       struct scb *scb);
 void			ahd_calc_residual(struct ahd_softc *ahd,
 					  struct scb *scb);
+void			ahd_timeout(struct scb *scb);
+void			ahd_recover_commands(struct ahd_softc *ahd);
 /*************************** Utility Functions ********************************/
 struct ahd_phase_table_entry*
 			ahd_lookup_phase_entry(int phase);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx.reg linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx.reg
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx.reg	2004-04-04 05:38:15.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx.reg	2004-05-13 16:42:17.000000000 +0200
@@ -39,7 +39,7 @@
  *
  * $FreeBSD$
  */
-VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#70 $"
+VERSION = "$Id$"
 
 /*
  * This file is processed by the aic7xxx_asm utility for use in assembling
@@ -65,13 +65,6 @@ VERSION = "$Id: //depot/aic7xxx/aic7xxx/
 		mvi	MODE_PTR, MK_MODE(src, dst);			\
 	}
 
-#define TOGGLE_DFF_MODE							\
-	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
-		call	toggle_dff_mode_work_around;			\
-	} else {							\
-		xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);		\
-	}
-	
 #define RESTORE_MODE(mode)						\
 	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
 		mov	mode call set_mode_work_around;			\
@@ -3542,10 +3535,34 @@ scratch_ram {
 	COMPLETE_DMA_SCB_HEAD {
 		size		2
 	}
-	/* Counting semaphore to prevent new select-outs */
+	/*
+	 * tail of list of SCBs that have
+	 * completed but need to be uploaded
+	 * to the host prior to being completed.
+	 */
+	COMPLETE_DMA_SCB_TAIL {
+		size		2
+	}
+	/*
+	 * head of list of SCBs that have
+	 * been uploaded to the host, but cannot
+	 * be completed until the QFREEZE is in
+	 * full effect (i.e. no selections pending).
+	 */
+	COMPLETE_ON_QFREEZE_HEAD {
+		size		2
+	}
+	/*
+	 * Counting semaphore to prevent new select-outs
+	 * The queue is frozen so long as the sequencer
+	 * and kernel freeze counts differ.
+	 */
 	QFREEZE_COUNT {
 		size		2
 	}
+	KERNEL_QFREEZE_COUNT {
+		size		2
+	}
 	/*
 	 * Mode to restore on legacy idle loop exit.
 	 */
@@ -3625,6 +3642,17 @@ scratch_ram {
 		size		1
 	}
 	/*
+	 * Kernel and sequencer offsets into the queue of
+	 * incoming target mode command descriptors.  The
+	 * queue is full when the KERNEL_TQINPOS == TQINPOS.
+	 */
+	KERNEL_TQINPOS {
+		size		1
+	}
+	TQINPOS {                
+		size		1
+	}
+	/*
 	 * Base address of our shared data with the kernel driver in host
 	 * memory.  This includes the qoutfifo and target mode
 	 * incoming command queue.
@@ -3639,17 +3667,6 @@ scratch_ram {
 	QOUTFIFO_NEXT_ADDR {
 		size		4
 	}
-	/*
-	 * Kernel and sequencer offsets into the queue of
-	 * incoming target mode command descriptors.  The
-	 * queue is full when the KERNEL_TQINPOS == TQINPOS.
-	 */
-	KERNEL_TQINPOS {
-		size		1
-	}
-	TQINPOS {                
-		size		1
-	}
 	ARG_1 {
 		size		1
 		mask	SEND_MSG		0x80
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx.seq linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx.seq
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx.seq	2004-04-04 05:38:00.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx.seq	2004-05-13 16:42:17.000000000 +0200
@@ -40,7 +40,7 @@
  * $FreeBSD$
  */
 
-VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#99 $"
+VERSION = "$Id$"
 PATCH_ARG_LIST = "struct ahd_softc *ahd"
 PREFIX = "ahd_"
 
@@ -68,13 +68,47 @@ no_error_set:
 	}
 	SET_MODE(M_SCSI, M_SCSI)
 	test	SCSISEQ0, ENSELO|ENARBO jnz idle_loop_checkbus;
-	test	SEQ_FLAGS2, SELECTOUT_QFROZEN jnz idle_loop_checkbus;
+	test	SEQ_FLAGS2, SELECTOUT_QFROZEN jz check_waiting_list;
+	/*
+	 * If the kernel has caught up with us, thaw the queue.
+	 */
+	mov	A, KERNEL_QFREEZE_COUNT;
+	cmp	QFREEZE_COUNT, A jne check_frozen_completions;
+	mov	A, KERNEL_QFREEZE_COUNT[1];
+	cmp	QFREEZE_COUNT[1], A jne check_frozen_completions;
+	and	SEQ_FLAGS2, ~SELECTOUT_QFROZEN;
+	jmp	check_waiting_list;
+check_frozen_completions:
+	test	SSTAT0, SELDO|SELINGO jnz idle_loop_checkbus;
+BEGIN_CRITICAL;
+	/*
+	 * If we have completions stalled waiting for the qfreeze
+	 * to take effect, move them over to the complete_scb list
+	 * now that no selections are pending.
+	 */
+	cmp	COMPLETE_ON_QFREEZE_HEAD[1],SCB_LIST_NULL je idle_loop_checkbus;
+	/*
+	 * Find the end of the qfreeze list.  The first element has
+	 * to be treated specially.
+	 */
+	bmov	SCBPTR, COMPLETE_ON_QFREEZE_HEAD, 2;
+	cmp 	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL je join_lists;
+	/*
+	 * Now the normal loop.
+	 */
+	bmov	SCBPTR, SCB_NEXT_COMPLETE, 2;
+	cmp 	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL jne . - 1;
+join_lists:
+	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
+	bmov	COMPLETE_SCB_HEAD, COMPLETE_ON_QFREEZE_HEAD, 2;
+	mvi	COMPLETE_ON_QFREEZE_HEAD[1], SCB_LIST_NULL;
+	jmp	idle_loop_checkbus;
+check_waiting_list:
 	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL je idle_loop_checkbus;
 	/*
 	 * ENSELO is cleared by a SELDO, so we must test for SELDO
 	 * one last time.
 	 */
-BEGIN_CRITICAL;
 	test	SSTAT0, SELDO jnz select_out;
 END_CRITICAL;
 	call	start_selection;
@@ -90,6 +124,13 @@ idle_loop_check_nonpackreq:
 	test	SSTAT2, NONPACKREQ jz . + 2;
 	call	unexpected_nonpkt_phase_find_ctxt;
 	if ((ahd->bugs & AHD_FAINT_LED_BUG) != 0) {
+		/*
+		 * On Rev A. hardware, the busy LED is only
+		 * turned on automaically during selections
+		 * and re-selections.  Make the LED status
+		 * more useful by forcing it to be on so
+		 * long as one of our data FIFOs is active.
+		 */
 		and	A, FIFO0FREE|FIFO1FREE, DFFSTAT;
 		cmp	A, FIFO0FREE|FIFO1FREE jne . + 3;
 		and	SBLKCTL, ~DIAGLEDEN|DIAGLEDON;
@@ -101,9 +142,9 @@ idle_loop_check_nonpackreq:
 	call	idle_loop_cchan;
 	jmp	idle_loop;
 
-BEGIN_CRITICAL;
 idle_loop_gsfifo:
 	SET_MODE(M_SCSI, M_SCSI)
+BEGIN_CRITICAL;
 idle_loop_gsfifo_in_scsi_mode:
 	test	LQISTAT2, LQIGSAVAIL jz return;
 	/*
@@ -152,11 +193,15 @@ END_CRITICAL;
 
 idle_loop_service_fifos:
 	SET_MODE(M_DFF0, M_DFF0)
+BEGIN_CRITICAL;
 	test	LONGJMP_ADDR[1], INVALID_ADDR jnz idle_loop_next_fifo;
 	call	longjmp;
+END_CRITICAL;
 idle_loop_next_fifo:
 	SET_MODE(M_DFF1, M_DFF1)
+BEGIN_CRITICAL;
 	test	LONGJMP_ADDR[1], INVALID_ADDR jz longjmp;
+END_CRITICAL;
 return:
 	ret;
 
@@ -170,7 +215,6 @@ BEGIN_CRITICAL;
 	test	CCSCBCTL, CCARREN|CCSCBEN jz scbdma_idle;
 	test	CCSCBCTL, CCSCBDIR jnz fetch_new_scb_inprog;
 	test	CCSCBCTL, CCSCBDONE jz return;
-END_CRITICAL;
 	/* FALLTHROUGH */
 scbdma_tohost_done:
 	test	CCSCBCTL, CCARREN jz fill_qoutfifo_dmadone;
@@ -180,26 +224,18 @@ scbdma_tohost_done:
 	 * bad SCSI status (currently only for underruns), we
 	 * queue the SCB for normal completion.  Otherwise, we
 	 * wait until any select-out activity has halted, and
-	 * then notify the host so that the transaction can be
-	 * dealt with.
+	 * then queue the completion.
 	 */
-	test	SCB_SCSI_STATUS, 0xff jnz scbdma_notify_host;
 	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
 	bmov	COMPLETE_DMA_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
+	cmp	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL jne . + 2;
+	mvi	COMPLETE_DMA_SCB_TAIL[1], SCB_LIST_NULL;
+	test	SCB_SCSI_STATUS, 0xff jz scbdma_queue_completion;
+	bmov	SCB_NEXT_COMPLETE, COMPLETE_ON_QFREEZE_HEAD, 2;
+	bmov	COMPLETE_ON_QFREEZE_HEAD, SCBPTR, 2 ret;
+scbdma_queue_completion:
 	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
 	bmov	COMPLETE_SCB_HEAD, SCBPTR, 2 ret;
-scbdma_notify_host:
-	SET_MODE(M_SCSI, M_SCSI)
-	test	SCSISEQ0, ENSELO jnz return;
-	test	SSTAT0, (SELDO|SELINGO) jnz return;
-	SET_MODE(M_CCHAN, M_CCHAN)
-	/*
-	 * Remove SCB and notify host.
-	 */
-	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
-	bmov	COMPLETE_DMA_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
-	SET_SEQINTCODE(BAD_SCB_STATUS)
-	ret;
 fill_qoutfifo_dmadone:
 	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
 	call	qoutfifo_updated;
@@ -208,6 +244,7 @@ fill_qoutfifo_dmadone:
 	test	QOFF_CTLSTA, SDSCB_ROLLOVR jz return;
 	bmov	QOUTFIFO_NEXT_ADDR, SHARED_DATA_ADDR, 4;
 	xor	QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID_TOGGLE ret;
+END_CRITICAL;
 
 qoutfifo_updated:
 	/*
@@ -324,14 +361,15 @@ fill_qoutfifo:
 	 * Keep track of the SCBs we are dmaing just
 	 * in case the DMA fails or is aborted.
 	 */
-	mov	A, QOUTFIFO_ENTRY_VALID_TAG;
 	bmov	COMPLETE_SCB_DMAINPROG_HEAD, COMPLETE_SCB_HEAD, 2;
 	mvi	CCSCBCTL, CCSCBRESET;
 	bmov	SCBHADDR, QOUTFIFO_NEXT_ADDR, 4;
 	bmov	SCBPTR, COMPLETE_SCB_HEAD, 2;
 fill_qoutfifo_loop:
-	mov	CCSCBRAM, SCBPTR;
-	or	CCSCBRAM, A, SCBPTR[1];
+	bmov	CCSCBRAM, SCBPTR, 2;
+	mov	CCSCBRAM, SCB_SGPTR[0];
+	bmov	CCSCBRAM, ALLZEROS, 4;
+	mov	CCSCBRAM, QOUTFIFO_ENTRY_VALID_TAG;
 	mov	NONE, SDSCB_QOFF;
 	inc	INT_COALESCING_CMDCOUNT;
 	add	CMDS_PENDING, -1;
@@ -354,7 +392,6 @@ dma_complete_scb:
 	bmov	SCBPTR, COMPLETE_DMA_SCB_HEAD, 2;
 	bmov	SCBHADDR, SCB_BUSADDR, 4;
 	mvi	CCARREN|CCSCBEN|CCSCBRESET jmp dma_scb;
-END_CRITICAL;
 
 /*
  * Either post or fetch an SCB from host memory.  The caller
@@ -371,9 +408,19 @@ dma_scb:
 	mvi	SCBHCNT, SCB_TRANSFER_SIZE;
 	mov	CCSCBCTL, SINDEX ret;
 
-BEGIN_CRITICAL;
 setjmp:
-	bmov	LONGJMP_ADDR, STACK, 2 ret;
+	/*
+	 * At least on the A, a return in the same
+	 * instruction as the bmov results in a return
+	 * to the caller, not to the new address at the
+	 * top of the stack.  Since we want the latter
+	 * (we use setjmp to register a handler from an
+	 * interrupt context but not invoke that handler
+	 * until we return to our idle loop), use a
+	 * separate ret instruction.
+	 */
+	bmov	LONGJMP_ADDR, STACK, 2;
+	ret;
 setjmp_inline:
 	bmov	LONGJMP_ADDR, STACK, 2;
 longjmp:
@@ -392,11 +439,6 @@ set_mode_work_around:
 	mvi	SEQINTCTL, INTVEC1DSL;
 	mov	MODE_PTR, SINDEX;
 	clr	SEQINTCTL ret;
-
-toggle_dff_mode_work_around:
-	mvi	SEQINTCTL, INTVEC1DSL;
-	xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);
-	clr	SEQINTCTL ret;
 }
 
 
@@ -490,6 +532,21 @@ allocate_fifo1:
 SET_SRC_MODE	M_SCSI;
 SET_DST_MODE	M_SCSI;
 select_in:
+	if ((ahd->bugs & AHD_FAINT_LED_BUG) != 0) {
+		/*
+		 * On Rev A. hardware, the busy LED is only
+		 * turned on automaically during selections
+		 * and re-selections.  Make the LED status
+		 * more useful by forcing it to be on from
+		 * the point of selection until our idle
+		 * loop determines that neither of our FIFOs
+		 * are busy.  This handles the non-packetized
+		 * case nicely as we will not return to the
+		 * idle loop until the busfree at the end of
+		 * each transaction.
+		 */
+		or	SBLKCTL, DIAGLEDEN|DIAGLEDON;
+	}
 	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
 		/*
 		 * Test to ensure that the bus has not
@@ -528,6 +585,21 @@ SET_SRC_MODE	M_SCSI;
 SET_DST_MODE	M_SCSI;
 select_out:
 BEGIN_CRITICAL;
+	if ((ahd->bugs & AHD_FAINT_LED_BUG) != 0) {
+		/*
+		 * On Rev A. hardware, the busy LED is only
+		 * turned on automaically during selections
+		 * and re-selections.  Make the LED status
+		 * more useful by forcing it to be on from
+		 * the point of re-selection until our idle
+		 * loop determines that neither of our FIFOs
+		 * are busy.  This handles the non-packetized
+		 * case nicely as we will not return to the
+		 * idle loop until the busfree at the end of
+		 * each transaction.
+		 */
+		or	SBLKCTL, DIAGLEDEN|DIAGLEDON;
+	}
 	/* Clear out all SCBs that have been successfully sent. */
 	if ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {
 		/*
@@ -1000,15 +1072,9 @@ not_found_ITloop:
 /*
  * We received a "command complete" message.  Put the SCB on the complete
  * queue and trigger a completion interrupt via the idle loop.  Before doing
- * so, check to see if there
- * is a residual or the status byte is something other than STATUS_GOOD (0).
- * In either of these conditions, we upload the SCB back to the host so it can
- * process this information.  In the case of a non zero status byte, we 
- * additionally interrupt the kernel driver synchronously, allowing it to
- * decide if sense should be retrieved.  If the kernel driver wishes to request
- * sense, it will fill the kernel SCB with a request sense command, requeue
- * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
- * RETURN_1 to SEND_SENSE.
+ * so, check to see if there is a residual or the status byte is something
+ * other than STATUS_GOOD (0).  In either of these conditions, we upload the
+ * SCB back to the host so it can process this information.
  */
 mesgin_complete:
 
@@ -1053,6 +1119,7 @@ complete_nomsg:
 	call	queue_scb_completion;
 	jmp	await_busfree;
 
+BEGIN_CRITICAL;
 freeze_queue:
 	/* Cancel any pending select-out. */
 	test	SSTAT0, SELDO|SELINGO jnz . + 2;
@@ -1063,6 +1130,7 @@ freeze_queue:
 	adc	QFREEZE_COUNT[1], A;
 	or	SEQ_FLAGS2, SELECTOUT_QFROZEN;
 	mov	A, ACCUM_SAVE ret;
+END_CRITICAL;
 
 /*
  * Complete the current FIFO's SCB if data for this same
@@ -1085,8 +1153,10 @@ queue_scb_completion:
 	test	SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
 	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
 complete:
+BEGIN_CRITICAL;
 	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
 	bmov	COMPLETE_SCB_HEAD, SCBPTR, 2 ret;
+END_CRITICAL;
 bad_status:
 	cmp	SCB_SCSI_STATUS, STATUS_PKT_SENSE je upload_scb;
 	call	freeze_queue;
@@ -1097,9 +1167,18 @@ upload_scb:
 	 * it on the host.
 	 */
 	bmov	SCB_TAG, SCBPTR, 2;
-	bmov	SCB_NEXT_COMPLETE, COMPLETE_DMA_SCB_HEAD, 2;
+BEGIN_CRITICAL;
+	or	SCB_SGPTR, SG_STATUS_VALID;
+	mvi	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL;
+	cmp	COMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne add_dma_scb_tail;
 	bmov	COMPLETE_DMA_SCB_HEAD, SCBPTR, 2;
-	or	SCB_SGPTR, SG_STATUS_VALID ret;
+	bmov	COMPLETE_DMA_SCB_TAIL, SCBPTR, 2 ret;
+add_dma_scb_tail:
+	bmov	REG0, SCBPTR, 2;
+	bmov	SCBPTR, COMPLETE_DMA_SCB_TAIL, 2;
+	bmov	SCB_NEXT_COMPLETE, REG0, 2;
+	bmov	COMPLETE_DMA_SCB_TAIL, REG0, 2 ret;
+END_CRITICAL;
 
 /*
  * Is it a disconnect message?  Set a flag in the SCB to remind us
@@ -1146,8 +1225,18 @@ SET_DST_MODE	M_DFF1;
 await_busfree_clrchn:
 	mvi	DFFSXFRCTL, CLRCHN;
 await_busfree_not_m_dff:
-	call	clear_target_state;
+	/* clear target specific flags */
+	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT;
 	test	SSTAT1,REQINIT|BUSFREE	jz .;
+	/*
+	 * We only set BUSFREE status once either a new
+	 * phase has been detected or we are really
+	 * BUSFREE.  This allows the driver to know
+	 * that we are active on the bus even though
+	 * no identified transaction exists should a
+	 * timeout occur while awaiting busfree.
+	 */
+	mvi	LASTPHASE, P_BUSFREE;
 	test	SSTAT1, BUSFREE jnz idle_loop;
 	SET_SEQINTCODE(MISSED_BUSFREE)
 
@@ -1202,11 +1291,6 @@ msgin_rdptrs_get_fifo:
 	call	allocate_fifo;
 	jmp	mesgin_done;
 
-clear_target_state:
-	mvi	LASTPHASE, P_BUSFREE;
-	/* clear target specific flags */
-	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT ret;
-
 phase_lock:     
 	if ((ahd->bugs & AHD_EARLY_REQ_BUG) != 0) {
 		/*
@@ -1298,6 +1382,47 @@ service_fifo:
 	test	CCSGCTL, CCSGENACK jnz return;
 
 	/*
+	 * Should the other FIFO get the S/G cache first?  If
+	 * both FIFOs have been allocated since we last checked
+	 * any FIFO, it is important that we service a FIFO
+	 * that is not actively on the bus first.  This guarantees
+	 * that a FIFO will be freed to handle snapshot requests for
+	 * any FIFO that is still on the bus.  Chips with RTI do not
+	 * perform snapshots, so don't bother with this test there.
+	 */
+	if ((ahd->features & AHD_RTI) == 0) {
+		/*
+		 * If we're not still receiving SCSI data,
+		 * it is safe to allocate the S/G cache to
+		 * this FIFO.
+		 */
+		test	DFCNTRL, SCSIEN jz idle_sgfetch_start;
+
+		/*
+		 * Switch to the other FIFO.  Non-RTI chips
+		 * also have the "set mode" bug, so we must
+		 * disable interrupts during the switch.
+		 */
+		mvi	SEQINTCTL, INTVEC1DSL;
+		xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);
+
+		/*
+		 * If the other FIFO needs loading, then it
+		 * must not have claimed the S/G cache yet
+		 * (SG_CACHE_AVAIL would have been cleared in
+		 * the orginal FIFO mode and we test this above).
+		 * Return to the idle loop so we can process the
+		 * FIFO not currently on the bus first.
+		 */
+		test	SG_STATE, LOADING_NEEDED jz idle_sgfetch_okay;
+		clr	SEQINTCTL ret;
+idle_sgfetch_okay:
+		xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);
+		clr	SEQINTCTL;
+	}
+
+idle_sgfetch_start:
+	/*
 	 * We fetch a "cacheline aligned" and sized amount of data
 	 * so we don't end up referencing a non-existant page.
 	 * Cacheline aligned is in quotes because the kernel will
@@ -1308,7 +1433,7 @@ service_fifo:
 	mvi	SGHCNT, SG_PREFETCH_CNT;
 	if ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0) {
 		/*
-		 * Need two instruction between "touches" of SGHADDR.
+		 * Need two instructions between "touches" of SGHADDR.
 		 */
 		nop;
 	}
@@ -1658,7 +1783,7 @@ export seq_isr:
 		 * savepointer in the current FIFO.  We do this so that
 		 * a pending CTXTDONE or SAVEPTR is visible in the active
 		 * FIFO.  This status is the only way we can detect if we
-		 * have lost the race (e.g. host paused us) and our attepts
+		 * have lost the race (e.g. host paused us) and our attempts
 		 * to disable the channel occurred after all REQs were
 		 * already seen and acked (REQINIT never comes true).
 		 */
@@ -1667,7 +1792,7 @@ export seq_isr:
 		test	DFCNTRL, DIRECTION jz interrupt_return;
 		and	DFCNTRL, ~SCSIEN;
 snapshot_wait_data_valid:
-		test	SEQINTSRC, (CTXTDONE|SAVEPTRS) jnz snapshot_data_valid;
+		test	SEQINTSRC, (CTXTDONE|SAVEPTRS) jnz interrupt_return;
 		test	SSTAT1, REQINIT	jz snapshot_wait_data_valid;
 snapshot_data_valid:
 		or	DFCNTRL, SCSIEN;
@@ -1834,7 +1959,6 @@ pkt_saveptrs_check_status:
 	dec	SCB_FIFO_USE_COUNT;
 	test	SCB_CONTROL, STATUS_RCVD jnz pkt_complete_scb_if_fifos_idle;
 	mvi	DFFSXFRCTL, CLRCHN ret;
-END_CRITICAL;
 
 /*
  * LAST_SEG_DONE status has been seen in the current FIFO.
@@ -1843,7 +1967,6 @@ END_CRITICAL;
  * Check for overrun and see if we can complete this command.
  */
 pkt_last_seg_done:
-BEGIN_CRITICAL;
 	/*
 	 * Mark transfer as completed.
 	 */
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_core.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_core.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_core.c	2004-04-04 05:36:12.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_core.c	2004-05-13 16:42:17.000000000 +0200
@@ -37,9 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.c#202 $
- *
- * $FreeBSD$
+ * $Id$
  */
 
 #ifdef __linux__
@@ -47,6 +45,8 @@
 #include "aic79xx_inline.h"
 #include "aicasm/aicasm_insformat.h"
 #else
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
 #include <dev/aic7xxx/aic79xx_osm.h>
 #include <dev/aic7xxx/aic79xx_inline.h>
 #include <dev/aic7xxx/aicasm/aicasm_insformat.h>
@@ -54,6 +54,7 @@
 
 /******************************** Globals *************************************/
 struct ahd_softc_tailq ahd_tailq = TAILQ_HEAD_INITIALIZER(ahd_tailq);
+uint32_t ahd_attach_to_HostRAID_controllers = 1;
 
 /***************************** Lookup Tables **********************************/
 char *ahd_chip_names[] =
@@ -224,6 +225,9 @@ static u_int		ahd_resolve_seqaddr(struct
 static void		ahd_download_instr(struct ahd_softc *ahd,
 					   u_int instrptr, uint8_t *dconsts);
 static int		ahd_probe_stack_size(struct ahd_softc *ahd);
+static void		ahd_other_scb_timeout(struct ahd_softc *ahd,
+					      struct scb *scb,
+					      struct scb *other_scb);
 static int		ahd_scb_active_in_fifo(struct ahd_softc *ahd,
 					       struct scb *scb);
 static void		ahd_run_data_fifo(struct ahd_softc *ahd,
@@ -334,6 +338,14 @@ ahd_restart(struct ahd_softc *ahd)
 	ahd_outb(ahd, SCSISEQ1,
 		 ahd_inb(ahd, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
 	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+
+	/*
+	 * Clear any pending sequencer interrupt.  It is no
+	 * longer relevant since we're resetting the Program
+	 * Counter.
+	 */
+	ahd_outb(ahd, CLRINT, CLRSEQINT);
+
 	ahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);
 	ahd_unpause(ahd);
 }
@@ -375,13 +387,7 @@ ahd_flush_qoutfifo(struct ahd_softc *ahd
 	saved_modes = ahd_save_modes(ahd);
 
 	/*
-	 * Complete any SCBs that just finished being
-	 * DMA'ed into the qoutfifo.
-	 */
-	ahd_run_qoutfifo(ahd);
-
-	/*
-	 * Flush the good status FIFO for compelted packetized commands.
+	 * Flush the good status FIFO for completed packetized commands.
 	 */
 	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
 	saved_scbptr = ahd_get_scbptr(ahd);
@@ -389,8 +395,7 @@ ahd_flush_qoutfifo(struct ahd_softc *ahd
 		u_int fifo_mode;
 		u_int i;
 		
-		scbid = (ahd_inb(ahd, GSFIFO+1) << 8)
-		      | ahd_inb(ahd, GSFIFO);
+		scbid = ahd_inw(ahd, GSFIFO);
 		scb = ahd_lookup_scb(ahd, scbid);
 		if (scb == NULL) {
 			printf("%s: Warning - GSFIFO SCB %d invalid\n",
@@ -403,22 +408,33 @@ ahd_flush_qoutfifo(struct ahd_softc *ahd
 		 * the host before completing the  command.
 		 */
 		fifo_mode = 0;
+rescan_fifos:
 		for (i = 0; i < 2; i++) {
 			/* Toggle to the other mode. */
 			fifo_mode ^= 1;
 			ahd_set_modes(ahd, fifo_mode, fifo_mode);
+
 			if (ahd_scb_active_in_fifo(ahd, scb) == 0)
 				continue;
 
 			ahd_run_data_fifo(ahd, scb);
 
 			/*
-			 * Clearing this transaction in this FIFO may
-			 * cause a CFG4DATA for this same transaction
-			 * to assert in the other FIFO.  Make sure we
-			 * loop one more time and check the other FIFO.
+			 * Running this FIFO may cause a CFG4DATA for
+			 * this same transaction to assert in the other
+			 * FIFO or a new snapshot SAVEPTRS interrupt
+			 * in this FIFO.  Even running a FIFO may not
+			 * clear the transaction if we are still waiting
+			 * for data to drain to the host. We must loop
+			 * until the transaction is not active in either
+			 * FIFO just to be sure.  Reset our loop counter
+			 * so we will visit both FIFOs again before
+			 * declaring this transaction finished.  We
+			 * also delay a bit so that status has a chance
+			 * to change before we look at this FIFO again.
 			 */
-			i = 0;
+			aic_delay(200);
+			goto rescan_fifos;
 		}
 		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
 		ahd_set_scbptr(ahd, scbid);
@@ -431,19 +447,28 @@ ahd_flush_qoutfifo(struct ahd_softc *ahd
 			/*
 			 * The transfer completed with a residual.
 			 * Place this SCB on the complete DMA list
-			 * so that we Update our in-core copy of the
+			 * so that we update our in-core copy of the
 			 * SCB before completing the command.
 			 */
 			ahd_outb(ahd, SCB_SCSI_STATUS, 0);
 			ahd_outb(ahd, SCB_SGPTR,
 				 ahd_inb_scbram(ahd, SCB_SGPTR)
 				 | SG_STATUS_VALID);
-			ahd_outw(ahd, SCB_TAG, SCB_GET_TAG(scb));
+			ahd_outw(ahd, SCB_TAG, scbid);
+			ahd_outw(ahd, SCB_NEXT_COMPLETE, SCB_LIST_NULL);
 			comp_head = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);
-			ahd_outw(ahd, SCB_NEXT_COMPLETE, comp_head);
-			if (SCBID_IS_NULL(comp_head))
-				ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD,
-					 SCB_GET_TAG(scb));
+			if (SCBID_IS_NULL(comp_head)) {
+				ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, scbid);
+				ahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, scbid);
+			} else {
+				u_int tail;
+
+				tail = ahd_inw(ahd, COMPLETE_DMA_SCB_TAIL);
+				ahd_set_scbptr(ahd, tail);
+				ahd_outw(ahd, SCB_NEXT_COMPLETE, scbid);
+				ahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, scbid);
+				ahd_set_scbptr(ahd, scbid);
+			}
 		} else
 			ahd_complete_scb(ahd, scb);
 	}
@@ -465,11 +490,24 @@ ahd_flush_qoutfifo(struct ahd_softc *ahd
 				break;
 		} else if ((ccscbctl & CCSCBDONE) != 0)
 			break;
-		ahd_delay(200);
+		aic_delay(200);
 	}
-	if ((ccscbctl & CCSCBDIR) != 0)
+	/*
+	 * We leave the sequencer to cleanup in the case of DMA's to
+	 * update the qoutfifo.  In all other cases (DMA's to the
+	 * chip or a push of an SCB from the COMPLETE_DMA_SCB list),
+	 * we disable the DMA engine so that the sequencer will not
+	 * attempt to handle the DMA completion.
+	 */
+	if ((ccscbctl & CCSCBDIR) != 0 || (ccscbctl & ARRDONE) != 0)
 		ahd_outb(ahd, CCSCBCTL, ccscbctl & ~(CCARREN|CCSCBEN));
 
+	/*
+	 * Complete any SCBs that just finished
+	 * being DMA'ed into the qoutfifo.
+	 */
+	ahd_run_qoutfifo(ahd);
+
 	saved_scbptr = ahd_get_scbptr(ahd);
 	/*
 	 * Manually update/complete any completed SCBs that are waiting to be
@@ -496,6 +534,24 @@ ahd_flush_qoutfifo(struct ahd_softc *ahd
 		scbid = next_scbid;
 	}
 	ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);
+	ahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, SCB_LIST_NULL);
+
+	scbid = ahd_inw(ahd, COMPLETE_ON_QFREEZE_HEAD);
+	while (!SCBID_IS_NULL(scbid)) {
+
+		ahd_set_scbptr(ahd, scbid);
+		next_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: Warning - Complete Qfrz SCB %d invalid\n",
+			       ahd_name(ahd), scbid);
+			continue;
+		}
+
+		ahd_complete_scb(ahd, scb);
+		scbid = next_scbid;
+	}
+	ahd_outw(ahd, COMPLETE_ON_QFREEZE_HEAD, SCB_LIST_NULL);
 
 	scbid = ahd_inw(ahd, COMPLETE_SCB_HEAD);
 	while (!SCBID_IS_NULL(scbid)) {
@@ -560,150 +616,146 @@ ahd_run_data_fifo(struct ahd_softc *ahd,
 {
 	u_int seqintsrc;
 
-	while (1) {
-		seqintsrc = ahd_inb(ahd, SEQINTSRC);
-		if ((seqintsrc & CFG4DATA) != 0) {
-			uint32_t datacnt;
-			uint32_t sgptr;
-
-			/*
-			 * Clear full residual flag.
-			 */
-			sgptr = ahd_inl_scbram(ahd, SCB_SGPTR) & ~SG_FULL_RESID;
-			ahd_outb(ahd, SCB_SGPTR, sgptr);
+	seqintsrc = ahd_inb(ahd, SEQINTSRC);
+	if ((seqintsrc & CFG4DATA) != 0) {
+		uint32_t datacnt;
+		uint32_t sgptr;
 
-			/*
-			 * Load datacnt and address.
-			 */
-			datacnt = ahd_inl_scbram(ahd, SCB_DATACNT);
-			if ((datacnt & AHD_DMA_LAST_SEG) != 0) {
-				sgptr |= LAST_SEG;
-				ahd_outb(ahd, SG_STATE, 0);
-			} else
-				ahd_outb(ahd, SG_STATE, LOADING_NEEDED);
-			ahd_outq(ahd, HADDR, ahd_inq_scbram(ahd, SCB_DATAPTR));
-			ahd_outl(ahd, HCNT, datacnt & AHD_SG_LEN_MASK);
-			ahd_outb(ahd, SG_CACHE_PRE, sgptr);
-			ahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);
+		/*
+		 * Clear full residual flag.
+		 */
+		sgptr = ahd_inl_scbram(ahd, SCB_SGPTR) & ~SG_FULL_RESID;
+		ahd_outb(ahd, SCB_SGPTR, sgptr);
 
-			/*
-			 * Initialize Residual Fields.
-			 */
-			ahd_outb(ahd, SCB_RESIDUAL_DATACNT+3, datacnt >> 24);
-			ahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr & SG_PTR_MASK);
+		/*
+		 * Load datacnt and address.
+		 */
+		datacnt = ahd_inl_scbram(ahd, SCB_DATACNT);
+		if ((datacnt & AHD_DMA_LAST_SEG) != 0) {
+			sgptr |= LAST_SEG;
+			ahd_outb(ahd, SG_STATE, 0);
+		} else
+			ahd_outb(ahd, SG_STATE, LOADING_NEEDED);
+		ahd_outq(ahd, HADDR, ahd_inq_scbram(ahd, SCB_DATAPTR));
+		ahd_outl(ahd, HCNT, datacnt & AHD_SG_LEN_MASK);
+		ahd_outb(ahd, SG_CACHE_PRE, sgptr);
+		ahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);
 
-			/*
-			 * Mark the SCB as having a FIFO in use.
-			 */
-			ahd_outb(ahd, SCB_FIFO_USE_COUNT,
-				 ahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT) + 1);
+		/*
+		 * Initialize Residual Fields.
+		 */
+		ahd_outb(ahd, SCB_RESIDUAL_DATACNT+3, datacnt >> 24);
+		ahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr & SG_PTR_MASK);
 
-			/*
-			 * Install a "fake" handler for this FIFO.
-			 */
-			ahd_outw(ahd, LONGJMP_ADDR, 0);
+		/*
+		 * Mark the SCB as having a FIFO in use.
+		 */
+		ahd_outb(ahd, SCB_FIFO_USE_COUNT,
+			 ahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT) + 1);
 
-			/*
-			 * Notify the hardware that we have satisfied
-			 * this sequencer interrupt.
-			 */
-			ahd_outb(ahd, CLRSEQINTSRC, CLRCFG4DATA);
-		} else if ((seqintsrc & SAVEPTRS) != 0) {
-			uint32_t sgptr;
-			uint32_t resid;
+		/*
+		 * Install a "fake" handler for this FIFO.
+		 */
+		ahd_outw(ahd, LONGJMP_ADDR, 0);
 
-			if ((ahd_inb(ahd, LONGJMP_ADDR+1)&INVALID_ADDR) != 0) {
-				/*
-				 * Snapshot Save Pointers.  Clear
-				 * the snapshot and continue.
-				 */
-				ahd_outb(ahd, DFFSXFRCTL, CLRCHN);
-				continue;
-			}
+		/*
+		 * Notify the hardware that we have satisfied
+		 * this sequencer interrupt.
+		 */
+		ahd_outb(ahd, CLRSEQINTSRC, CLRCFG4DATA);
+	} else if ((seqintsrc & SAVEPTRS) != 0) {
+		uint32_t sgptr;
+		uint32_t resid;
 
+		if ((ahd_inb(ahd, LONGJMP_ADDR+1)&INVALID_ADDR) != 0) {
 			/*
-			 * Disable S/G fetch so the DMA engine
-			 * is available to future users.
+			 * Snapshot Save Pointers.  All that
+			 * is necessary to clear the snapshot
+			 * is a CLRCHN.
 			 */
-			if ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)
-				ahd_outb(ahd, CCSGCTL, 0);
-			ahd_outb(ahd, SG_STATE, 0);
+			goto clrchn;
+		}
 
-			/*
-			 * Flush the data FIFO.  Strickly only
-			 * necessary for Rev A parts.
-			 */
-			ahd_outb(ahd, DFCNTRL,
-				 ahd_inb(ahd, DFCNTRL) | FIFOFLUSH);
+		/*
+		 * Disable S/G fetch so the DMA engine
+		 * is available to future users.
+		 */
+		if ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)
+			ahd_outb(ahd, CCSGCTL, 0);
+		ahd_outb(ahd, SG_STATE, 0);
 
-			/*
-			 * Calculate residual.
-			 */
-			sgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);
-			resid = ahd_inl(ahd, SHCNT);
-			resid |=
-			    ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+3) << 24;
-			ahd_outl(ahd, SCB_RESIDUAL_DATACNT, resid);
-			if ((ahd_inb(ahd, SG_CACHE_SHADOW) & LAST_SEG) == 0) {
-				/*
-				 * Must back up to the correct S/G element.
-				 * Typically this just means resetting our
-				 * low byte to the offset in the SG_CACHE,
-				 * but if we wrapped, we have to correct
-				 * the other bytes of the sgptr too.
-				 */
-				if ((ahd_inb(ahd, SG_CACHE_SHADOW) & 0x80) != 0
-				 && (sgptr & 0x80) == 0)
-					sgptr -= 0x100;
-				sgptr &= ~0xFF;
-				sgptr |= ahd_inb(ahd, SG_CACHE_SHADOW)
-				       & SG_ADDR_MASK;
-				ahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);
-				ahd_outb(ahd, SCB_RESIDUAL_DATACNT + 3, 0);
-			} else if ((resid & AHD_SG_LEN_MASK) == 0) {
-				ahd_outb(ahd, SCB_RESIDUAL_SGPTR,
-					 sgptr | SG_LIST_NULL);
-			}
-			/*
-			 * Save Pointers.
-			 */
-			ahd_outq(ahd, SCB_DATAPTR, ahd_inq(ahd, SHADDR));
-			ahd_outl(ahd, SCB_DATACNT, resid);
-			ahd_outl(ahd, SCB_SGPTR, sgptr);
-			ahd_outb(ahd, CLRSEQINTSRC, CLRSAVEPTRS);
-			ahd_outb(ahd, SEQIMODE,
-				 ahd_inb(ahd, SEQIMODE) | ENSAVEPTRS);
-			/*
-			 * If the data is to the SCSI bus, we are
-			 * done, otherwise wait for FIFOEMP.
-			 */
-			if ((ahd_inb(ahd, DFCNTRL) & DIRECTION) != 0)
-				break;
-		} else if ((ahd_inb(ahd, SG_STATE) & LOADING_NEEDED) != 0) {
-			uint32_t sgptr;
-			uint64_t data_addr;
-			uint32_t data_len;
-			u_int	 dfcntrl;
+		/*
+		 * Flush the data FIFO.  Strickly only
+		 * necessary for Rev A parts.
+		 */
+		ahd_outb(ahd, DFCNTRL, ahd_inb(ahd, DFCNTRL) | FIFOFLUSH);
 
-			/*
-			 * Disable S/G fetch so the DMA engine
-			 * is available to future users.
-			 */
-			if ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0) {
-				ahd_outb(ahd, CCSGCTL, 0);
-				ahd_outb(ahd, SG_STATE, LOADING_NEEDED);
-			}
+		/*
+		 * Calculate residual.
+		 */
+		sgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);
+		resid = ahd_inl(ahd, SHCNT);
+		resid |= ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+3) << 24;
+		ahd_outl(ahd, SCB_RESIDUAL_DATACNT, resid);
+		if ((ahd_inb(ahd, SG_CACHE_SHADOW) & LAST_SEG) == 0) {
+			/*
+			 * Must back up to the correct S/G element.
+			 * Typically this just means resetting our
+			 * low byte to the offset in the SG_CACHE,
+			 * but if we wrapped, we have to correct
+			 * the other bytes of the sgptr too.
+			 */
+			if ((ahd_inb(ahd, SG_CACHE_SHADOW) & 0x80) != 0
+			 && (sgptr & 0x80) == 0)
+				sgptr -= 0x100;
+			sgptr &= ~0xFF;
+			sgptr |= ahd_inb(ahd, SG_CACHE_SHADOW)
+			       & SG_ADDR_MASK;
+			ahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);
+			ahd_outb(ahd, SCB_RESIDUAL_DATACNT + 3, 0);
+		} else if ((resid & AHD_SG_LEN_MASK) == 0) {
+			ahd_outb(ahd, SCB_RESIDUAL_SGPTR,
+				 sgptr | SG_LIST_NULL);
+		}
+		/*
+		 * Save Pointers.
+		 */
+		ahd_outq(ahd, SCB_DATAPTR, ahd_inq(ahd, SHADDR));
+		ahd_outl(ahd, SCB_DATACNT, resid);
+		ahd_outl(ahd, SCB_SGPTR, sgptr);
+		ahd_outb(ahd, CLRSEQINTSRC, CLRSAVEPTRS);
+		ahd_outb(ahd, SEQIMODE,
+			 ahd_inb(ahd, SEQIMODE) | ENSAVEPTRS);
+		/*
+		 * If the data is to the SCSI bus, we are
+		 * done, otherwise wait for FIFOEMP.
+		 */
+		if ((ahd_inb(ahd, DFCNTRL) & DIRECTION) != 0)
+			goto clrchn;
+	} else if ((ahd_inb(ahd, SG_STATE) & LOADING_NEEDED) != 0) {
+		uint32_t sgptr;
+		uint64_t data_addr;
+		uint32_t data_len;
+		u_int	 dfcntrl;
 
-			/*
-			 * Wait for the DMA engine to notice that the
-			 * host transfer is enabled and that there is
-			 * space in the S/G FIFO for new segments before
-			 * loading more segments.
-			 */
-			if ((ahd_inb(ahd, DFSTATUS) & PRELOAD_AVAIL) == 0)
-				continue;
-			if ((ahd_inb(ahd, DFCNTRL) & HDMAENACK) == 0)
-				continue;
+		/*
+		 * Disable S/G fetch so the DMA engine
+		 * is available to future users.  We won't
+		 * be using the DMA engine to load segments.
+		 */
+		if ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0) {
+			ahd_outb(ahd, CCSGCTL, 0);
+			ahd_outb(ahd, SG_STATE, LOADING_NEEDED);
+		}
+
+		/*
+		 * Wait for the DMA engine to notice that the
+		 * host transfer is enabled and that there is
+		 * space in the S/G FIFO for new segments before
+		 * loading more segments.
+		 */
+		if ((ahd_inb(ahd, DFSTATUS) & PRELOAD_AVAIL) != 0
+		 && (ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0) {
 
 			/*
 			 * Determine the offset of the next S/G
@@ -750,7 +802,7 @@ ahd_run_data_fifo(struct ahd_softc *ahd,
 			 * Advertise the segment to the hardware.
 			 */
 			dfcntrl = ahd_inb(ahd, DFCNTRL)|PRELOADEN|HDMAEN;
-			if ((ahd->features & AHD_NEW_DFCNTRL_OPTS)!=0) {
+			if ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0) {
 				/*
 				 * Use SCSIENWRDIS so that SCSIEN
 				 * is never modified by this
@@ -759,35 +811,44 @@ ahd_run_data_fifo(struct ahd_softc *ahd,
 				dfcntrl |= SCSIENWRDIS;
 			}
 			ahd_outb(ahd, DFCNTRL, dfcntrl);
-		} else if ((ahd_inb(ahd, SG_CACHE_SHADOW)
-			 & LAST_SEG_DONE) != 0) {
-
-			/*
-			 * Transfer completed to the end of SG list
-			 * and has flushed to the host.
-			 */
-			ahd_outb(ahd, SCB_SGPTR,
-				 ahd_inb_scbram(ahd, SCB_SGPTR) | SG_LIST_NULL);
-			break;
-		} else if ((ahd_inb(ahd, DFSTATUS) & FIFOEMP) != 0) {
-			break;
 		}
-		ahd_delay(200);
+	} else if ((ahd_inb(ahd, SG_CACHE_SHADOW) & LAST_SEG_DONE) != 0) {
+
+		/*
+		 * Transfer completed to the end of SG list
+		 * and has flushed to the host.
+		 */
+		ahd_outb(ahd, SCB_SGPTR,
+			 ahd_inb_scbram(ahd, SCB_SGPTR) | SG_LIST_NULL);
+		goto clrchn;
+	} else if ((ahd_inb(ahd, DFSTATUS) & FIFOEMP) != 0) {
+clrchn:
+		/*
+		 * Clear any handler for this FIFO, decrement
+		 * the FIFO use count for the SCB, and release
+		 * the FIFO.
+		 */
+		ahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);
+		ahd_outb(ahd, SCB_FIFO_USE_COUNT,
+			 ahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT) - 1);
+		ahd_outb(ahd, DFFSXFRCTL, CLRCHN);
 	}
-	/*
-	 * Clear any handler for this FIFO, decrement
-	 * the FIFO use count for the SCB, and release
-	 * the FIFO.
-	 */
-	ahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);
-	ahd_outb(ahd, SCB_FIFO_USE_COUNT,
-		 ahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT) - 1);
-	ahd_outb(ahd, DFFSXFRCTL, CLRCHN);
 }
 
+/*
+ * Look for entries in the QoutFIFO that have completed.
+ * The valid_tag completion field indicates the validity
+ * of the entry - the valid value toggles each time through
+ * the queue. We use the sg_status field in the completion
+ * entry to avoid referencing the hscb if the completion
+ * occurred with no errors and no residual.  sg_status is
+ * a copy of the first byte (little endian) of the sgptr
+ * hscb field.
+ */
 void
 ahd_run_qoutfifo(struct ahd_softc *ahd)
 {
+	struct ahd_completion *completion;
 	struct scb *scb;
 	u_int  scb_index;
 
@@ -795,11 +856,13 @@ ahd_run_qoutfifo(struct ahd_softc *ahd)
 		panic("ahd_run_qoutfifo recursion");
 	ahd->flags |= AHD_RUNNING_QOUTFIFO;
 	ahd_sync_qoutfifo(ahd, BUS_DMASYNC_POSTREAD);
-	while ((ahd->qoutfifo[ahd->qoutfifonext]
-	     & QOUTFIFO_ENTRY_VALID_LE) == ahd->qoutfifonext_valid_tag) {
+	for (;;) {
+		completion = &ahd->qoutfifo[ahd->qoutfifonext];
 
-		scb_index = ahd_le16toh(ahd->qoutfifo[ahd->qoutfifonext]
-				      & ~QOUTFIFO_ENTRY_VALID_LE);
+		if (completion->valid_tag != ahd->qoutfifonext_valid_tag)
+			break;
+
+		scb_index = aic_le16toh(completion->tag);
 		scb = ahd_lookup_scb(ahd, scb_index);
 		if (scb == NULL) {
 			printf("%s: WARNING no command for scb %d "
@@ -807,12 +870,15 @@ ahd_run_qoutfifo(struct ahd_softc *ahd)
 			       ahd_name(ahd), scb_index,
 			       ahd->qoutfifonext);
 			ahd_dump_card_state(ahd);
-		} else
-			ahd_complete_scb(ahd, scb);
+		} else if ((completion->sg_status & SG_STATUS_VALID) != 0) {
+			ahd_handle_scb_status(ahd, scb);
+		} else {
+			ahd_done(ahd, scb);
+		}
 
 		ahd->qoutfifonext = (ahd->qoutfifonext+1) & (AHD_QOUT_SIZE-1);
 		if (ahd->qoutfifonext == 0)
-			ahd->qoutfifonext_valid_tag ^= QOUTFIFO_ENTRY_VALID_LE;
+			ahd->qoutfifonext_valid_tag ^= QOUTFIFO_ENTRY_VALID;
 	}
 	ahd->flags &= ~AHD_RUNNING_QOUTFIFO;
 }
@@ -878,26 +944,6 @@ ahd_handle_seqint(struct ahd_softc *ahd,
 		       ahd_name(ahd), seqintcode);
 #endif
 	switch (seqintcode) {
-	case BAD_SCB_STATUS:
-	{
-		struct	scb *scb;
-		u_int	scbid;
-		int	cmds_pending;
-
-		scbid = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb != NULL) {
-			ahd_complete_scb(ahd, scb);
-		} else {
-			printf("%s: WARNING no command for scb %d "
-			       "(bad status)\n", ahd_name(ahd), scbid);
-			ahd_dump_card_state(ahd);
-		}
-		cmds_pending = ahd_inw(ahd, CMDS_PENDING);
-		if (cmds_pending > 0)
-			ahd_outw(ahd, CMDS_PENDING, cmds_pending - 1);
-		break;
-	}
 	case ENTERING_NONPACK:
 	{
 		struct	scb *scb;
@@ -1062,11 +1108,11 @@ ahd_handle_seqint(struct ahd_softc *ahd,
 			ahd_outb(ahd, SAVED_LUN, 0);
 			ahd_outb(ahd, SEQ_FLAGS, 0);
 			ahd_assert_atn(ahd);
-			scb->flags &= ~(SCB_PACKETIZED);
+			scb->flags &= ~SCB_PACKETIZED;
 			scb->flags |= SCB_ABORT|SCB_CMDPHASE_ABORT;
 			ahd_freeze_devq(ahd, scb);
-			ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
-			ahd_freeze_scb(scb);
+			aic_set_transaction_status(scb, CAM_REQUEUE_REQ);
+			aic_freeze_scb(scb);
 
 			/*
 			 * Allow the sequencer to continue with
@@ -1314,7 +1360,7 @@ ahd_handle_seqint(struct ahd_softc *ahd,
 			       "NumSGs = %d.\n",
 			       ahd_inb(ahd, SEQ_FLAGS) & DPHASE
 			       ? "Have" : "Haven't",
-			       ahd_get_transfer_length(scb), scb->sg_count);
+			       aic_get_transfer_length(scb), scb->sg_count);
 			ahd_dump_sglist(scb);
 		}
 #endif
@@ -1324,8 +1370,8 @@ ahd_handle_seqint(struct ahd_softc *ahd,
 		 * target does a command complete.
 		 */
 		ahd_freeze_devq(ahd, scb);
-		ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
-		ahd_freeze_scb(scb);
+		aic_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+		aic_freeze_scb(scb);
 		break;
 	}
 	case MKMSG_FAILED:
@@ -1586,7 +1632,7 @@ ahd_handle_scsiint(struct ahd_softc *ahd
 			 */
 			ahd_scb_devinfo(ahd, &devinfo, scb);
 			ahd_force_renegotiation(ahd, &devinfo);
-			ahd_set_transaction_status(scb, CAM_SEL_TIMEOUT);
+			aic_set_transaction_status(scb, CAM_SEL_TIMEOUT);
 			ahd_freeze_devq(ahd, scb);
 		}
 		ahd_outb(ahd, CLRINT, CLRSCSIINT);
@@ -1661,7 +1707,15 @@ ahd_handle_scsiint(struct ahd_softc *ahd
 			clear_fifo = 0;
 			packetized =  (lqostat1 & LQOBUSFREE) != 0;
 			if (!packetized
-			 && ahd_inb(ahd, LASTPHASE) == P_BUSFREE)
+			 && ahd_inb(ahd, LASTPHASE) == P_BUSFREE
+			 && ((ahd_inb(ahd, SSTAT0) & SELDO) == 0
+			  || (ahd_inb(ahd, SCSISEQ0) & ENSELO) == 0))
+				/*
+				 * Assume packetized if we are not
+				 * on the bus in a non-packetized
+				 * capacity and any pending selection
+				 * was a packetized selection.
+				 */
 				packetized = 1;
 			break;
 		}
@@ -2033,8 +2087,8 @@ ahd_handle_pkt_busfree(struct ahd_softc 
 			}
 			scb->crc_retry_count++;
 		} else {
-			ahd_set_transaction_status(scb, CAM_UNCOR_PARITY);
-			ahd_freeze_scb(scb);
+			aic_set_transaction_status(scb, CAM_UNCOR_PARITY);
+			aic_freeze_scb(scb);
 			ahd_freeze_devq(ahd, scb);
 		}
 		/* Return unpausing the sequencer. */
@@ -2176,7 +2230,7 @@ ahd_handle_nonpkt_busfree(struct ahd_sof
 			 && ahd_match_scb(ahd, scb, target, 'A',
 					  CAM_LUN_WILDCARD, SCB_LIST_NULL,
 					  ROLE_INITIATOR))
-				ahd_set_transaction_status(scb, CAM_REQ_CMP);
+				aic_set_transaction_status(scb, CAM_REQ_CMP);
 #endif
 			ahd_handle_devreset(ahd, &devinfo, CAM_LUN_WILDCARD,
 					    CAM_BDR_SENT, "Bus Device Reset",
@@ -2267,8 +2321,8 @@ ahd_handle_nonpkt_busfree(struct ahd_sof
 	 && ((ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0)) {
 
 		ahd_freeze_devq(ahd, scb);
-		ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
-		ahd_freeze_scb(scb);
+		aic_set_transaction_status(scb, CAM_REQUEUE_REQ);
+		aic_freeze_scb(scb);
 		if ((ahd->msg_flags & MSG_FLAG_IU_REQ_CHANGED) != 0) {
 			ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
 				       SCB_GET_CHANNEL(ahd, scb),
@@ -2312,8 +2366,7 @@ ahd_handle_nonpkt_busfree(struct ahd_sof
 		       "PRGMCNT == 0x%x\n",
 		       ahd_lookup_phase_entry(lastphase)->phasemsg,
 		       aborted,
-		       ahd_inb(ahd, PRGMCNT)
-			| (ahd_inb(ahd, PRGMCNT+1) << 8));
+		       ahd_inw(ahd, PRGMCNT));
 		ahd_dump_card_state(ahd);
 	}
 	/* Always restart the sequencer. */
@@ -2357,7 +2410,7 @@ ahd_handle_proto_violation(struct ahd_so
 		printf("No SCB found during protocol violation\n");
 		goto proto_violation_reset;
 	} else {
-		ahd_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
+		aic_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
 		if ((seq_flags & NO_CDB_SENT) != 0) {
 			ahd_print_path(ahd, scb);
 			printf("No or incomplete CDB sent to device.\n");
@@ -2476,8 +2529,7 @@ ahd_clear_critical_section(struct ahd_so
 		u_int	i;
 
 		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-		seqaddr = ahd_inb(ahd, CURADDR)
-			| (ahd_inb(ahd, CURADDR+1) << 8);
+		seqaddr = ahd_inw(ahd, CURADDR);
 
 		cs = ahd->critical_sections;
 		for (i = 0; i < ahd->num_critical_sections; i++, cs++) {
@@ -2537,7 +2589,7 @@ ahd_clear_critical_section(struct ahd_so
 		ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
 		ahd_outb(ahd, HCNTRL, ahd->unpause);
 		while (!ahd_is_paused(ahd))
-			ahd_delay(200);
+			aic_delay(200);
 		ahd_update_modes(ahd);
 	}
 	if (stepping) {
@@ -2613,10 +2665,10 @@ ahd_print_scb(struct scb *scb)
 	for (i = 0; i < sizeof(hscb->shared_data.idata.cdb); i++)
 		printf("%#02x", hscb->shared_data.idata.cdb[i]);
 	printf("        dataptr:%#x%x datacnt:%#x sgptr:%#x tag:%#x\n",
-	       (uint32_t)((ahd_le64toh(hscb->dataptr) >> 32) & 0xFFFFFFFF),
-	       (uint32_t)(ahd_le64toh(hscb->dataptr) & 0xFFFFFFFF),
-	       ahd_le32toh(hscb->datacnt),
-	       ahd_le32toh(hscb->sgptr),
+	       (uint32_t)((aic_le64toh(hscb->dataptr) >> 32) & 0xFFFFFFFF),
+	       (uint32_t)(aic_le64toh(hscb->dataptr) & 0xFFFFFFFF),
+	       aic_le32toh(hscb->datacnt),
+	       aic_le32toh(hscb->sgptr),
 	       SCB_GET_TAG(scb));
 	ahd_dump_sglist(scb);
 }
@@ -2635,8 +2687,8 @@ ahd_dump_sglist(struct scb *scb)
 				uint64_t addr;
 				uint32_t len;
 
-				addr = ahd_le64toh(sg_list[i].addr);
-				len = ahd_le32toh(sg_list[i].len);
+				addr = aic_le64toh(sg_list[i].addr);
+				len = aic_le32toh(sg_list[i].len);
 				printf("sg[%d] - Addr 0x%x%x : Length %d%s\n",
 				       i,
 				       (uint32_t)((addr >> 32) & 0xFFFFFFFF),
@@ -2652,11 +2704,11 @@ ahd_dump_sglist(struct scb *scb)
 			for (i = 0; i < scb->sg_count; i++) {
 				uint32_t len;
 
-				len = ahd_le32toh(sg_list[i].len);
+				len = aic_le32toh(sg_list[i].len);
 				printf("sg[%d] - Addr 0x%x%x : Length %d%s\n",
 				       i,
 				       (len & AHD_SG_HIGH_ADDR_MASK) >> 24,
-				       ahd_le32toh(sg_list[i].addr),
+				       aic_le32toh(sg_list[i].addr),
 				       len & AHD_SG_LEN_MASK,
 				       len & AHD_DMA_LAST_SEG ? " Last" : "");
 			}
@@ -3198,14 +3250,25 @@ ahd_update_neg_table(struct ahd_softc *a
 		iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_PRECOMP_MASK;
 
 		if ((ahd->features & AHD_NEW_IOCELL_OPTS) != 0
-		 && (ppr_opts & MSG_EXT_PPR_DT_REQ) != 0) {
+		 && (ppr_opts & MSG_EXT_PPR_DT_REQ) != 0
+		 && (ppr_opts & MSG_EXT_PPR_IU_REQ) == 0) {
 			/*
 			 * Slow down our CRC interval to be
-			 * compatible with devices that can't
-			 * handle a CRC at full speed.
+			 * compatible with non-packetized
+			 * U160 devices that can't handle a
+			 * CRC at full speed.
 			 */
 			con_opts |= ENSLOWCRC;
 		}
+
+		if ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0) {
+			/*
+			 * On H2A4, revert to a slower slewrate
+			 * on non-paced transfers.
+			 */
+			iocell_opts[AHD_PRECOMP_SLEW_INDEX] &=
+			    ~AHD_SLEWRATE_MASK;
+		}
 	}
 
 	ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PRECOMP_SLEW);
@@ -4676,7 +4739,7 @@ ahd_handle_msg_reject(struct ahd_softc *
 		ahd_outb(ahd, SCB_CONTROL,
 			 ahd_inb_scbram(ahd, SCB_CONTROL) & mask);
 	 	scb->hscb->control &= mask;
-		ahd_set_transaction_tag(scb, /*enabled*/FALSE,
+		aic_set_transaction_tag(scb, /*enabled*/FALSE,
 					/*type*/MSG_SIMPLE_TASK);
 		ahd_outb(ahd, MSG_OUT, MSG_IDENTIFYFLAG);
 		ahd_assert_atn(ahd);
@@ -4734,7 +4797,7 @@ ahd_handle_ign_wide_residue(struct ahd_s
 	 * Perhaps add datadir to some spare bits in the hscb?
 	 */
 	if ((ahd_inb(ahd, SEQ_FLAGS) & DPHASE) == 0
-	 || ahd_get_transfer_dir(scb) != CAM_DIR_IN) {
+	 || aic_get_transfer_dir(scb) != CAM_DIR_IN) {
 		/*
 		 * Ignore the message if we haven't
 		 * seen an appropriate data phase yet.
@@ -4789,18 +4852,18 @@ ahd_handle_ign_wide_residue(struct ahd_s
 				 * to load so we must go back one.
 				 */
 				sg--;
-				sglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+				sglen = aic_le32toh(sg->len) & AHD_SG_LEN_MASK;
 				if (sg != scb->sg_list
 				 && sglen < (data_cnt & AHD_SG_LEN_MASK)) {
 
 					sg--;
-					sglen = ahd_le32toh(sg->len);
+					sglen = aic_le32toh(sg->len);
 					/*
 					 * Preserve High Address and SG_LIST
 					 * bits while setting the count to 1.
 					 */
 					data_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));
-					data_addr = ahd_le64toh(sg->addr)
+					data_addr = aic_le64toh(sg->addr)
 						  + (sglen & AHD_SG_LEN_MASK)
 						  - 1;
 
@@ -4822,18 +4885,18 @@ ahd_handle_ign_wide_residue(struct ahd_s
 				 * to load so we must go back one.
 				 */
 				sg--;
-				sglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+				sglen = aic_le32toh(sg->len) & AHD_SG_LEN_MASK;
 				if (sg != scb->sg_list
 				 && sglen < (data_cnt & AHD_SG_LEN_MASK)) {
 
 					sg--;
-					sglen = ahd_le32toh(sg->len);
+					sglen = aic_le32toh(sg->len);
 					/*
 					 * Preserve High Address and SG_LIST
 					 * bits while setting the count to 1.
 					 */
 					data_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));
-					data_addr = ahd_le32toh(sg->addr)
+					data_addr = aic_le32toh(sg->addr)
 						  + (sglen & AHD_SG_LEN_MASK)
 						  - 1;
 
@@ -4895,7 +4958,7 @@ ahd_reinitialize_dataptrs(struct ahd_sof
 	ahd_outb(ahd, DFFSXFRCTL, CLRCHN);
 	wait = 1000;
 	while (--wait && !(ahd_inb(ahd, MDFFSTAT) & FIFOFREE))
-		ahd_delay(100);
+		aic_delay(100);
 	if (wait == 0) {
 		ahd_print_path(ahd, scb);
 		printf("ahd_reinitialize_dataptrs: Forcing FIFO free.\n");
@@ -4911,10 +4974,7 @@ ahd_reinitialize_dataptrs(struct ahd_sof
 	 * Determine initial values for data_addr and data_cnt
 	 * for resuming the data phase.
 	 */
-	sgptr = (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 3) << 24)
-	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 2) << 16)
-	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 1) << 8)
-	      |	ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);
+	sgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);
 	sgptr &= SG_PTR_MASK;
 
 	resid = (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 2) << 16)
@@ -4929,13 +4989,10 @@ ahd_reinitialize_dataptrs(struct ahd_sof
 		/* The residual sg_ptr always points to the next sg */
 		sg--;
 
-		dataptr = ahd_le64toh(sg->addr)
-			+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)
+		dataptr = aic_le64toh(sg->addr)
+			+ (aic_le32toh(sg->len) & AHD_SG_LEN_MASK)
 			- resid;
-		ahd_outb(ahd, HADDR + 7, dataptr >> 56);
-		ahd_outb(ahd, HADDR + 6, dataptr >> 48);
-		ahd_outb(ahd, HADDR + 5, dataptr >> 40);
-		ahd_outb(ahd, HADDR + 4, dataptr >> 32);
+		ahd_outl(ahd, HADDR + 4, dataptr >> 32);
 	} else {
 		struct	 ahd_dma_seg *sg;
 
@@ -4944,16 +5001,13 @@ ahd_reinitialize_dataptrs(struct ahd_sof
 		/* The residual sg_ptr always points to the next sg */
 		sg--;
 
-		dataptr = ahd_le32toh(sg->addr)
-			+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)
+		dataptr = aic_le32toh(sg->addr)
+			+ (aic_le32toh(sg->len) & AHD_SG_LEN_MASK)
 			- resid;
 		ahd_outb(ahd, HADDR + 4,
-			 (ahd_le32toh(sg->len) & ~AHD_SG_LEN_MASK) >> 24);
+			 (aic_le32toh(sg->len) & ~AHD_SG_LEN_MASK) >> 24);
 	}
-	ahd_outb(ahd, HADDR + 3, dataptr >> 24);
-	ahd_outb(ahd, HADDR + 2, dataptr >> 16);
-	ahd_outb(ahd, HADDR + 1, dataptr >> 8);
-	ahd_outb(ahd, HADDR, dataptr);
+	ahd_outl(ahd, HADDR, dataptr);
 	ahd_outb(ahd, HCNT + 2, resid >> 16);
 	ahd_outb(ahd, HCNT + 1, resid >> 8);
 	ahd_outb(ahd, HCNT, resid);
@@ -5147,8 +5201,8 @@ ahd_alloc(void *platform_arg, char *name
 	ahd->bugs = AHD_BUGNONE;
 	ahd->flags = AHD_SPCHK_ENB_A|AHD_RESET_BUS_A|AHD_TERM_ENB_A
 		   | AHD_EXTENDED_TRANS_A|AHD_STPWLEVEL_A;
-	ahd_timer_init(&ahd->reset_timer);
-	ahd_timer_init(&ahd->stat_timer);
+	aic_timer_init(&ahd->reset_timer);
+	aic_timer_init(&ahd->stat_timer);
 	ahd->int_coalescing_timer = AHD_INT_COALESCING_TIMER_DEFAULT;
 	ahd->int_coalescing_maxcmds = AHD_INT_COALESCING_MAXCMDS_DEFAULT;
 	ahd->int_coalescing_mincmds = AHD_INT_COALESCING_MINCMDS_DEFAULT;
@@ -5184,24 +5238,24 @@ ahd_softc_insert(struct ahd_softc *ahd)
 {
 	struct ahd_softc *list_ahd;
 
-#if AHD_PCI_CONFIG > 0
+#if AIC_PCI_CONFIG > 0
 	/*
 	 * Second Function PCI devices need to inherit some
 	 * settings from function 0.
 	 */
 	if ((ahd->features & AHD_MULTI_FUNC) != 0) {
 		TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
-			ahd_dev_softc_t list_pci;
-			ahd_dev_softc_t pci;
+			aic_dev_softc_t list_pci;
+			aic_dev_softc_t pci;
 
 			list_pci = list_ahd->dev_softc;
 			pci = ahd->dev_softc;
-			if (ahd_get_pci_slot(list_pci) == ahd_get_pci_slot(pci)
-			 && ahd_get_pci_bus(list_pci) == ahd_get_pci_bus(pci)) {
+			if (aic_get_pci_slot(list_pci) == aic_get_pci_slot(pci)
+			 && aic_get_pci_bus(list_pci) == aic_get_pci_bus(pci)) {
 				struct ahd_softc *master;
 				struct ahd_softc *slave;
 
-				if (ahd_get_pci_function(list_pci) == 0) {
+				if (aic_get_pci_function(list_pci) == 0) {
 					master = list_ahd;
 					slave = ahd;
 				} else {
@@ -5266,27 +5320,27 @@ ahd_free(struct ahd_softc *ahd)
 {
 	int i;
 
+	ahd_terminate_recovery_thread(ahd);
 	switch (ahd->init_level) {
 	default:
 	case 5:
 		ahd_shutdown(ahd);
-		TAILQ_REMOVE(&ahd_tailq, ahd, links);
 		/* FALLTHROUGH */
 	case 4:
-		ahd_dmamap_unload(ahd, ahd->shared_data_dmat,
-				  ahd->shared_data_dmamap);
+		aic_dmamap_unload(ahd, ahd->shared_data_dmat,
+				  ahd->shared_data_map.dmamap);
 		/* FALLTHROUGH */
 	case 3:
-		ahd_dmamem_free(ahd, ahd->shared_data_dmat, ahd->qoutfifo,
-				ahd->shared_data_dmamap);
-		ahd_dmamap_destroy(ahd, ahd->shared_data_dmat,
-				   ahd->shared_data_dmamap);
+		aic_dmamem_free(ahd, ahd->shared_data_dmat, ahd->qoutfifo,
+				ahd->shared_data_map.dmamap);
+		aic_dmamap_destroy(ahd, ahd->shared_data_dmat,
+				   ahd->shared_data_map.dmamap);
 		/* FALLTHROUGH */
 	case 2:
-		ahd_dma_tag_destroy(ahd, ahd->shared_data_dmat);
+		aic_dma_tag_destroy(ahd, ahd->shared_data_dmat);
 	case 1:
 #ifndef __linux__
-		ahd_dma_tag_destroy(ahd, ahd->buffer_dmat);
+		aic_dma_tag_destroy(ahd, ahd->buffer_dmat);
 #endif
 		break;
 	case 0:
@@ -5294,7 +5348,7 @@ ahd_free(struct ahd_softc *ahd)
 	}
 
 #ifndef __linux__
-	ahd_dma_tag_destroy(ahd, ahd->parent_dmat);
+	aic_dma_tag_destroy(ahd, ahd->parent_dmat);
 #endif
 	ahd_platform_free(ahd);
 	ahd_fini_scbdata(ahd);
@@ -5347,8 +5401,8 @@ ahd_shutdown(void *arg)
 	/*
 	 * Stop periodic timer callbacks.
 	 */
-	ahd_timer_stop(&ahd->reset_timer);
-	ahd_timer_stop(&ahd->stat_timer);
+	aic_timer_stop(&ahd->reset_timer);
+	aic_timer_stop(&ahd->stat_timer);
 
 	/* This will reset most registers to 0, but not all */
 	ahd_reset(ahd, /*reinit*/FALSE);
@@ -5380,7 +5434,7 @@ ahd_reset(struct ahd_softc *ahd, int rei
 	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
 	sxfrctl1 = ahd_inb(ahd, SXFRCTL1);
 
-	cmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	cmd = aic_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
 	if ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {
 		uint32_t mod_cmd;
 
@@ -5394,7 +5448,7 @@ ahd_reset(struct ahd_softc *ahd, int rei
 		 * PERR and SERR responses during the CHIPRST.
 		 */
 		mod_cmd = cmd & ~(PCIM_CMD_PERRESPEN|PCIM_CMD_SERRESPEN);
-		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+		aic_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
 				     mod_cmd, /*bytes*/2);
 	}
 	ahd_outb(ahd, HCNTRL, CHIPRST | ahd->pause);
@@ -5407,7 +5461,7 @@ ahd_reset(struct ahd_softc *ahd, int rei
 	 */
 	wait = 1000;
 	do {
-		ahd_delay(1000);
+		aic_delay(1000);
 	} while (--wait && !(ahd_inb(ahd, HCNTRL) & CHIPRSTACK));
 
 	if (wait == 0) {
@@ -5421,9 +5475,9 @@ ahd_reset(struct ahd_softc *ahd, int rei
 		 * Clear any latched PCI error status and restore
 		 * previous SERR and PERR response enables.
 		 */
-		ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+		aic_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
 				     0xFF, /*bytes*/1);
-		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+		aic_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
 				     cmd, /*bytes*/2);
 	}
 
@@ -5550,7 +5604,7 @@ ahd_init_scbdata(struct ahd_softc *ahd)
 	 */
 
 	/* DMA tag for our hardware scb structures */
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+	if (aic_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -5564,7 +5618,7 @@ ahd_init_scbdata(struct ahd_softc *ahd)
 	scb_data->init_level++;
 
 	/* DMA tag for our S/G structures. */
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/8,
+	if (aic_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/8,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -5583,7 +5637,7 @@ ahd_init_scbdata(struct ahd_softc *ahd)
 	scb_data->init_level++;
 
 	/* DMA tag for our sense buffers.  We allocate in page sized chunks */
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+	if (aic_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -5671,13 +5725,13 @@ ahd_fini_scbdata(struct ahd_softc *ahd)
 
 		while ((sns_map = SLIST_FIRST(&scb_data->sense_maps)) != NULL) {
 			SLIST_REMOVE_HEAD(&scb_data->sense_maps, links);
-			ahd_dmamap_unload(ahd, scb_data->sense_dmat,
+			aic_dmamap_unload(ahd, scb_data->sense_dmat,
 					  sns_map->dmamap);
-			ahd_dmamem_free(ahd, scb_data->sense_dmat,
+			aic_dmamem_free(ahd, scb_data->sense_dmat,
 					sns_map->vaddr, sns_map->dmamap);
 			free(sns_map, M_DEVBUF);
 		}
-		ahd_dma_tag_destroy(ahd, scb_data->sense_dmat);
+		aic_dma_tag_destroy(ahd, scb_data->sense_dmat);
 		/* FALLTHROUGH */
 	}
 	case 6:
@@ -5686,13 +5740,13 @@ ahd_fini_scbdata(struct ahd_softc *ahd)
 
 		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps)) != NULL) {
 			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
-			ahd_dmamap_unload(ahd, scb_data->sg_dmat,
+			aic_dmamap_unload(ahd, scb_data->sg_dmat,
 					  sg_map->dmamap);
-			ahd_dmamem_free(ahd, scb_data->sg_dmat,
+			aic_dmamem_free(ahd, scb_data->sg_dmat,
 					sg_map->vaddr, sg_map->dmamap);
 			free(sg_map, M_DEVBUF);
 		}
-		ahd_dma_tag_destroy(ahd, scb_data->sg_dmat);
+		aic_dma_tag_destroy(ahd, scb_data->sg_dmat);
 		/* FALLTHROUGH */
 	}
 	case 5:
@@ -5701,13 +5755,13 @@ ahd_fini_scbdata(struct ahd_softc *ahd)
 
 		while ((hscb_map = SLIST_FIRST(&scb_data->hscb_maps)) != NULL) {
 			SLIST_REMOVE_HEAD(&scb_data->hscb_maps, links);
-			ahd_dmamap_unload(ahd, scb_data->hscb_dmat,
+			aic_dmamap_unload(ahd, scb_data->hscb_dmat,
 					  hscb_map->dmamap);
-			ahd_dmamem_free(ahd, scb_data->hscb_dmat,
+			aic_dmamem_free(ahd, scb_data->hscb_dmat,
 					hscb_map->vaddr, hscb_map->dmamap);
 			free(hscb_map, M_DEVBUF);
 		}
-		ahd_dma_tag_destroy(ahd, scb_data->hscb_dmat);
+		aic_dma_tag_destroy(ahd, scb_data->hscb_dmat);
 		/* FALLTHROUGH */
 	}
 	case 4:
@@ -5912,7 +5966,7 @@ ahd_free_scb(struct ahd_softc *ahd, stru
 				 scb, links.le);
 	}
 
-	ahd_platform_scb_free(ahd, scb);
+	aic_platform_scb_free(ahd, scb);
 }
 
 void
@@ -5943,7 +5997,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 		offset = (PAGE_SIZE / sizeof(*hscb)) - scb_data->scbs_left;
 		hscb_map = SLIST_FIRST(&scb_data->hscb_maps);
 		hscb = &((struct hardware_scb *)hscb_map->vaddr)[offset];
-		hscb_busaddr = hscb_map->physaddr + (offset * sizeof(*hscb));
+		hscb_busaddr = hscb_map->busaddr + (offset * sizeof(*hscb));
 	} else {
 		hscb_map = malloc(sizeof(*hscb_map), M_DEVBUF, M_NOWAIT);
 
@@ -5951,7 +6005,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 			return;
 
 		/* Allocate the next batch of hardware SCBs */
-		if (ahd_dmamem_alloc(ahd, scb_data->hscb_dmat,
+		if (aic_dmamem_alloc(ahd, scb_data->hscb_dmat,
 				     (void **)&hscb_map->vaddr,
 				     BUS_DMA_NOWAIT, &hscb_map->dmamap) != 0) {
 			free(hscb_map, M_DEVBUF);
@@ -5960,13 +6014,29 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 
 		SLIST_INSERT_HEAD(&scb_data->hscb_maps, hscb_map, links);
 
-		ahd_dmamap_load(ahd, scb_data->hscb_dmat, hscb_map->dmamap,
+		aic_dmamap_load(ahd, scb_data->hscb_dmat, hscb_map->dmamap,
 				hscb_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,
-				&hscb_map->physaddr, /*flags*/0);
+				&hscb_map->busaddr, /*flags*/0);
 
 		hscb = (struct hardware_scb *)hscb_map->vaddr;
-		hscb_busaddr = hscb_map->physaddr;
+		hscb_busaddr = hscb_map->busaddr;
 		scb_data->scbs_left = PAGE_SIZE / sizeof(*hscb);
+		if (ahd->next_queued_hscb == NULL) {
+			/*
+			 * We need one HSCB to serve as the "next HSCB".  Since
+			 * the tag identifier in this HSCB will never be used,
+			 * there is no point in using a valid SCB from the
+			 * free pool for it.  So, we allocate this "sentinel"
+			 * specially.
+	 		 */
+			ahd->next_queued_hscb = hscb;
+			ahd->next_queued_hscb_map = hscb_map;
+			memset(hscb, 0, sizeof(*hscb));
+			hscb->hscb_busaddr = aic_htole32(hscb_busaddr);
+			hscb++;
+			hscb_busaddr += sizeof(*hscb);
+			scb_data->scbs_left--;
+		}
 	}
 
 	if (scb_data->sgs_left != 0) {
@@ -5976,7 +6046,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 		       - scb_data->sgs_left) * ahd_sglist_size(ahd);
 		sg_map = SLIST_FIRST(&scb_data->sg_maps);
 		segs = sg_map->vaddr + offset;
-		sg_busaddr = sg_map->physaddr + offset;
+		sg_busaddr = sg_map->busaddr + offset;
 	} else {
 		sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
 
@@ -5984,7 +6054,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 			return;
 
 		/* Allocate the next batch of S/G lists */
-		if (ahd_dmamem_alloc(ahd, scb_data->sg_dmat,
+		if (aic_dmamem_alloc(ahd, scb_data->sg_dmat,
 				     (void **)&sg_map->vaddr,
 				     BUS_DMA_NOWAIT, &sg_map->dmamap) != 0) {
 			free(sg_map, M_DEVBUF);
@@ -5993,12 +6063,12 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 
 		SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);
 
-		ahd_dmamap_load(ahd, scb_data->sg_dmat, sg_map->dmamap,
+		aic_dmamap_load(ahd, scb_data->sg_dmat, sg_map->dmamap,
 				sg_map->vaddr, ahd_sglist_allocsize(ahd),
-				ahd_dmamap_cb, &sg_map->physaddr, /*flags*/0);
+				ahd_dmamap_cb, &sg_map->busaddr, /*flags*/0);
 
 		segs = sg_map->vaddr;
-		sg_busaddr = sg_map->physaddr;
+		sg_busaddr = sg_map->busaddr;
 		scb_data->sgs_left =
 		    ahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd);
 #ifdef AHD_DEBUG
@@ -6013,7 +6083,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 		offset = PAGE_SIZE - (AHD_SENSE_BUFSIZE * scb_data->sense_left);
 		sense_map = SLIST_FIRST(&scb_data->sense_maps);
 		sense_data = sense_map->vaddr + offset;
-		sense_busaddr = sense_map->physaddr + offset;
+		sense_busaddr = sense_map->busaddr + offset;
 	} else {
 		sense_map = malloc(sizeof(*sense_map), M_DEVBUF, M_NOWAIT);
 
@@ -6021,7 +6091,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 			return;
 
 		/* Allocate the next batch of sense buffers */
-		if (ahd_dmamem_alloc(ahd, scb_data->sense_dmat,
+		if (aic_dmamem_alloc(ahd, scb_data->sense_dmat,
 				     (void **)&sense_map->vaddr,
 				     BUS_DMA_NOWAIT, &sense_map->dmamap) != 0) {
 			free(sense_map, M_DEVBUF);
@@ -6030,12 +6100,12 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 
 		SLIST_INSERT_HEAD(&scb_data->sense_maps, sense_map, links);
 
-		ahd_dmamap_load(ahd, scb_data->sense_dmat, sense_map->dmamap,
+		aic_dmamap_load(ahd, scb_data->sense_dmat, sense_map->dmamap,
 				sense_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,
-				&sense_map->physaddr, /*flags*/0);
+				&sense_map->busaddr, /*flags*/0);
 
 		sense_data = sense_map->vaddr;
-		sense_busaddr = sense_map->physaddr;
+		sense_busaddr = sense_map->busaddr;
 		scb_data->sense_left = PAGE_SIZE / AHD_SENSE_BUFSIZE;
 #ifdef AHD_DEBUG
 		if (ahd_debug & AHD_SHOW_MEMORY)
@@ -6050,12 +6120,12 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 	scb_data->scbs_left -= newcount;
 	scb_data->sgs_left -= newcount;
 	for (i = 0; i < newcount; i++) {
-		u_int col_tag;
-
 		struct scb_platform_data *pdata;
+		u_int col_tag;
 #ifndef __linux__
 		int error;
 #endif
+
 		next_scb = (struct scb *)malloc(sizeof(*next_scb),
 						M_DEVBUF, M_NOWAIT);
 		if (next_scb == NULL)
@@ -6076,7 +6146,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 		next_scb->sense_busaddr = sense_busaddr;
 		memset(hscb, 0, sizeof(*hscb));
 		next_scb->hscb = hscb;
-		hscb->hscb_busaddr = ahd_htole32(hscb_busaddr);
+		hscb->hscb_busaddr = aic_htole32(hscb_busaddr);
 
 		/*
 		 * The sequencer always starts with the second entry.
@@ -6091,7 +6161,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 		next_scb->ahd_softc = ahd;
 		next_scb->flags = SCB_FLAG_NONE;
 #ifndef __linux__
-		error = ahd_dmamap_create(ahd, ahd->buffer_dmat, /*flags*/0,
+		error = aic_dmamap_create(ahd, ahd->buffer_dmat, /*flags*/0,
 					  &next_scb->dmamap);
 		if (error != 0) {
 			free(next_scb, M_DEVBUF);
@@ -6099,7 +6169,7 @@ ahd_alloc_scbs(struct ahd_softc *ahd)
 			break;
 		}
 #endif
-		next_scb->hscb->tag = ahd_htole16(scb_data->numscbs);
+		next_scb->hscb->tag = aic_htole16(scb_data->numscbs);
 		col_tag = scb_data->numscbs ^ 0x100;
 		next_scb->col_scb = ahd_find_scb_by_tag(ahd, col_tag);
 		if (next_scb->col_scb != NULL)
@@ -6159,7 +6229,6 @@ static const char *termstat_strings[] = 
 int
 ahd_init(struct ahd_softc *ahd)
 {
-	uint8_t		*base_vaddr;
 	uint8_t		*next_vaddr;
 	bus_addr_t	 next_baddr;
 	size_t		 driver_data_size;
@@ -6202,7 +6271,7 @@ ahd_init(struct ahd_softc *ahd)
 
 #ifndef __linux__
 	/* DMA tag for mapping buffers into device visible space. */
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+	if (aic_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/ahd->flags & AHD_39BIT_ADDRESSING
 					? (bus_addr_t)0x7FFFFFFFFFULL
@@ -6227,13 +6296,12 @@ ahd_init(struct ahd_softc *ahd)
 	 * for the target mode role, we must additionally provide space for
 	 * the incoming target command fifo.
 	 */
-	driver_data_size = AHD_SCB_MAX * sizeof(uint16_t)
-			 + sizeof(struct hardware_scb);
+	driver_data_size = AHD_SCB_MAX * sizeof(*ahd->qoutfifo);
 	if ((ahd->features & AHD_TARGETMODE) != 0)
 		driver_data_size += AHD_TMODE_CMDS * sizeof(struct target_cmd);
 	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0)
 		driver_data_size += PKT_OVERRUN_BUFSIZE;
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+	if (aic_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -6248,21 +6316,24 @@ ahd_init(struct ahd_softc *ahd)
 	ahd->init_level++;
 
 	/* Allocation of driver data */
-	if (ahd_dmamem_alloc(ahd, ahd->shared_data_dmat,
-			     (void **)&base_vaddr,
-			     BUS_DMA_NOWAIT, &ahd->shared_data_dmamap) != 0) {
+	if (aic_dmamem_alloc(ahd, ahd->shared_data_dmat,
+			     (void **)&ahd->shared_data_map.vaddr,
+			     BUS_DMA_NOWAIT,
+			     &ahd->shared_data_map.dmamap) != 0) {
 		return (ENOMEM);
 	}
 
 	ahd->init_level++;
 
 	/* And permanently map it in */
-	ahd_dmamap_load(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
-			base_vaddr, driver_data_size, ahd_dmamap_cb,
-			&ahd->shared_data_busaddr, /*flags*/0);
-	ahd->qoutfifo = (uint16_t *)base_vaddr;
+	aic_dmamap_load(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,
+			ahd->shared_data_map.vaddr, driver_data_size,
+			ahd_dmamap_cb, &ahd->shared_data_map.busaddr,
+			/*flags*/0);
+	ahd->qoutfifo = (struct ahd_completion *)ahd->shared_data_map.vaddr;
 	next_vaddr = (uint8_t *)&ahd->qoutfifo[AHD_QOUT_SIZE];
-	next_baddr = ahd->shared_data_busaddr + AHD_QOUT_SIZE*sizeof(uint16_t);
+	next_baddr = ahd->shared_data_map.busaddr
+		   + AHD_QOUT_SIZE*sizeof(struct ahd_completion);
 	if ((ahd->features & AHD_TARGETMODE) != 0) {
 		ahd->targetcmds = (struct target_cmd *)next_vaddr;
 		next_vaddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);
@@ -6275,16 +6346,6 @@ ahd_init(struct ahd_softc *ahd)
 		next_baddr += PKT_OVERRUN_BUFSIZE;
 	}
 
-	/*
-	 * We need one SCB to serve as the "next SCB".  Since the
-	 * tag identifier in this SCB will never be used, there is
-	 * no point in using a valid HSCB tag from an SCB pulled from
-	 * the standard free pool.  So, we allocate this "sentinel"
-	 * specially from the DMA safe memory chunk used for the QOUTFIFO.
-	 */
-	ahd->next_queued_hscb = (struct hardware_scb *)next_vaddr;
-	ahd->next_queued_hscb->hscb_busaddr = ahd_htole32(next_baddr);
-
 	ahd->init_level++;
 
 	/* Allocate SCB data now that buffer_dmat is initialized */
@@ -6374,7 +6435,7 @@ ahd_init(struct ahd_softc *ahd)
 	}
 init_done:
 	ahd_restart(ahd);
-	ahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,
+	aic_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,
 			ahd_stat_timer, ahd);
 	return (0);
 }
@@ -6435,7 +6496,7 @@ ahd_chip_init(struct ahd_softc *ahd)
 	for (wait = 10000;
 	     (ahd_inb(ahd, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
 	     wait--)
-		ahd_delay(100);
+		aic_delay(100);
 
 	/* Clear any false bus resets due to the transceivers settling */
 	ahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);
@@ -6588,10 +6649,10 @@ ahd_chip_init(struct ahd_softc *ahd)
 
 	/* All of our queues are empty */
 	ahd->qoutfifonext = 0;
-	ahd->qoutfifonext_valid_tag = QOUTFIFO_ENTRY_VALID_LE;
-	ahd_outb(ahd, QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID >> 8);
+	ahd->qoutfifonext_valid_tag = QOUTFIFO_ENTRY_VALID;
+	ahd_outb(ahd, QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID);
 	for (i = 0; i < AHD_QOUT_SIZE; i++)
-		ahd->qoutfifo[i] = 0;
+		ahd->qoutfifo[i].valid_tag = 0;
 	ahd_sync_qoutfifo(ahd, BUS_DMASYNC_PREREAD);
 
 	ahd->qinfifonext = 0;
@@ -6624,24 +6685,22 @@ ahd_chip_init(struct ahd_softc *ahd)
 	ahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);
 	ahd_outw(ahd, COMPLETE_SCB_DMAINPROG_HEAD, SCB_LIST_NULL);
 	ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);
+	ahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, SCB_LIST_NULL);
+	ahd_outw(ahd, COMPLETE_ON_QFREEZE_HEAD, SCB_LIST_NULL);
 
 	/*
 	 * The Freeze Count is 0.
 	 */
+	ahd->qfreeze_cnt = 0;
 	ahd_outw(ahd, QFREEZE_COUNT, 0);
+	ahd_outw(ahd, KERNEL_QFREEZE_COUNT, 0);
 
 	/*
 	 * Tell the sequencer where it can find our arrays in memory.
 	 */
-	busaddr = ahd->shared_data_busaddr;
-	ahd_outb(ahd, SHARED_DATA_ADDR, busaddr & 0xFF);
-	ahd_outb(ahd, SHARED_DATA_ADDR + 1, (busaddr >> 8) & 0xFF);
-	ahd_outb(ahd, SHARED_DATA_ADDR + 2, (busaddr >> 16) & 0xFF);
-	ahd_outb(ahd, SHARED_DATA_ADDR + 3, (busaddr >> 24) & 0xFF);
-	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR, busaddr & 0xFF);
-	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 1, (busaddr >> 8) & 0xFF);
-	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 2, (busaddr >> 16) & 0xFF);
-	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 3, (busaddr >> 24) & 0xFF);
+	busaddr = ahd->shared_data_map.busaddr;
+	ahd_outl(ahd, SHARED_DATA_ADDR, busaddr);
+	ahd_outl(ahd, QOUTFIFO_NEXT_ADDR, busaddr);
 
 	/*
 	 * Setup the allowed SCSI Sequences based on operational mode.
@@ -6689,11 +6748,8 @@ ahd_chip_init(struct ahd_softc *ahd)
 	/*
 	 * Tell the sequencer which SCB will be the next one it receives.
 	 */
-	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+	busaddr = aic_le32toh(ahd->next_queued_hscb->hscb_busaddr);
+	ahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);
 
 	/*
 	 * Default to coalescing disabled.
@@ -6997,43 +7053,34 @@ ahd_pause_and_flushwork(struct ahd_softc
 {
 	u_int intstat;
 	u_int maxloops;
-	u_int qfreeze_cnt;
 
 	maxloops = 1000;
 	ahd->flags |= AHD_ALL_INTERRUPTS;
 	ahd_pause(ahd);
 	/*
-	 * Increment the QFreeze Count so that the sequencer
-	 * will not start new selections.  We do this only
+	 * Freeze the outgoing selections.  We do this only
 	 * until we are safely paused without further selections
 	 * pending.
 	 */
-	ahd_outw(ahd, QFREEZE_COUNT, ahd_inw(ahd, QFREEZE_COUNT) + 1);
+	ahd->qfreeze_cnt--;
+	ahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);
 	ahd_outb(ahd, SEQ_FLAGS2, ahd_inb(ahd, SEQ_FLAGS2) | SELECTOUT_QFROZEN);
 	do {
-		struct scb *waiting_scb;
 
 		ahd_unpause(ahd);
+		/*
+		 * Give the sequencer some time to service
+		 * any active selections.
+		 */
+		aic_delay(500);
+
 		ahd_intr(ahd);
 		ahd_pause(ahd);
-		ahd_clear_critical_section(ahd);
 		intstat = ahd_inb(ahd, INTSTAT);
-		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-		if ((ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) == 0)
-			ahd_outb(ahd, SCSISEQ0,
-				 ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
-		/*
-		 * In the non-packetized case, the sequencer (for Rev A),
-		 * relies on ENSELO remaining set after SELDO.  The hardware
-		 * auto-clears ENSELO in the packetized case.
-		 */
-		waiting_scb = ahd_lookup_scb(ahd,
-					     ahd_inw(ahd, WAITING_TID_HEAD));
-		if (waiting_scb != NULL
-		 && (waiting_scb->flags & SCB_PACKETIZED) == 0
-		 && (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) != 0)
-			ahd_outb(ahd, SCSISEQ0,
-				 ahd_inb(ahd, SCSISEQ0) | ENSELO);
+		if ((intstat & INT_PEND) == 0) {
+			ahd_clear_critical_section(ahd);
+			intstat = ahd_inb(ahd, INTSTAT);
+		}
 	} while (--maxloops
 	      && (intstat != 0xFF || (ahd->features & AHD_REMOVABLE) == 0)
 	      && ((intstat & INT_PEND) != 0
@@ -7044,17 +7091,8 @@ ahd_pause_and_flushwork(struct ahd_softc
 		printf("Infinite interrupt loop, INTSTAT = %x",
 		      ahd_inb(ahd, INTSTAT));
 	}
-	qfreeze_cnt = ahd_inw(ahd, QFREEZE_COUNT);
-	if (qfreeze_cnt == 0) {
-		printf("%s: ahd_pause_and_flushwork with 0 qfreeze count!\n",
-		       ahd_name(ahd));
-	} else {
-		qfreeze_cnt--;
-	}
-	ahd_outw(ahd, QFREEZE_COUNT, qfreeze_cnt);
-	if (qfreeze_cnt == 0)
-		ahd_outb(ahd, SEQ_FLAGS2,
-			 ahd_inb(ahd, SEQ_FLAGS2) & ~SELECTOUT_QFROZEN);
+	ahd->qfreeze_cnt++;
+	ahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);
 
 	ahd_flush_qoutfifo(ahd);
 
@@ -7225,11 +7263,8 @@ ahd_qinfifo_requeue(struct ahd_softc *ah
 	if (prev_scb == NULL) {
 		uint32_t busaddr;
 
-		busaddr = ahd_le32toh(scb->hscb->hscb_busaddr);
-		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
-		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
-		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
-		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+		busaddr = aic_le32toh(scb->hscb->hscb_busaddr);
+		ahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);
 	} else {
 		prev_scb->hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;
 		ahd_sync_scb(ahd, prev_scb, 
@@ -7335,11 +7370,8 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 	 * for removal will be re-added to the queue as we go.
 	 */
 	ahd->qinfifonext = qinstart;
-	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+	busaddr = aic_le32toh(ahd->next_queued_hscb->hscb_busaddr);
+	ahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);
 
 	while (qinpos != qintail) {
 		scb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);
@@ -7360,13 +7392,13 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 				cam_status ostat;
 				cam_status cstat;
 
-				ostat = ahd_get_transaction_status(scb);
+				ostat = aic_get_transaction_status(scb);
 				if (ostat == CAM_REQ_INPROG)
-					ahd_set_transaction_status(scb,
+					aic_set_transaction_status(scb,
 								   status);
-				cstat = ahd_get_transaction_status(scb);
+				cstat = aic_get_transaction_status(scb);
 				if (cstat != CAM_REQ_CMP)
-					ahd_freeze_scb(scb);
+					aic_freeze_scb(scb);
 				if ((scb->flags & SCB_ACTIVE) == 0)
 					printf("Inactive SCB in qinfifo\n");
 				ahd_done(ahd, scb);
@@ -7401,6 +7433,7 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 	 * appropriate, traverse the SCBs of each "their id"
 	 * looking for matches.
 	 */
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
 	savedscbptr = ahd_get_scbptr(ahd);
 	tid_next = ahd_inw(ahd, WAITING_TID_HEAD);
 	tid_prev = SCB_LIST_NULL;
@@ -7470,7 +7503,7 @@ ahd_search_scb_list(struct ahd_softc *ah
 	u_int	prev;
 	int	found;
 
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
 	found = 0;
 	prev = SCB_LIST_NULL;
 	next = *list_head;
@@ -7502,12 +7535,12 @@ ahd_search_scb_list(struct ahd_softc *ah
 			cam_status ostat;
 			cam_status cstat;
 
-			ostat = ahd_get_transaction_status(scb);
+			ostat = aic_get_transaction_status(scb);
 			if (ostat == CAM_REQ_INPROG)
-				ahd_set_transaction_status(scb, status);
-			cstat = ahd_get_transaction_status(scb);
+				aic_set_transaction_status(scb, status);
+			cstat = aic_get_transaction_status(scb);
 			if (cstat != CAM_REQ_CMP)
-				ahd_freeze_scb(scb);
+				aic_freeze_scb(scb);
 			if ((scb->flags & SCB_ACTIVE) == 0)
 				printf("Inactive SCB in Waiting List\n");
 			ahd_done(ahd, scb);
@@ -7537,7 +7570,7 @@ static void
 ahd_stitch_tid_list(struct ahd_softc *ahd, u_int tid_prev,
 		    u_int tid_cur, u_int tid_next)
 {
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
 
 	if (SCBID_IS_NULL(tid_cur)) {
 
@@ -7577,7 +7610,7 @@ ahd_rem_wscb(struct ahd_softc *ahd, u_in
 {
 	u_int tail_offset;
 
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
 	if (!SCBID_IS_NULL(prev)) {
 		ahd_set_scbptr(ahd, prev);
 		ahd_outw(ahd, SCB_NEXT, next);
@@ -7698,11 +7731,11 @@ ahd_abort_scbs(struct ahd_softc *ahd, in
 		if (ahd_match_scb(ahd, scbp, target, channel, lun, tag, role)) {
 			cam_status ostat;
 
-			ostat = ahd_get_transaction_status(scbp);
+			ostat = aic_get_transaction_status(scbp);
 			if (ostat == CAM_REQ_INPROG)
-				ahd_set_transaction_status(scbp, status);
-			if (ahd_get_transaction_status(scbp) != CAM_REQ_CMP)
-				ahd_freeze_scb(scbp);
+				aic_set_transaction_status(scbp, status);
+			if (aic_get_transaction_status(scbp) != CAM_REQ_CMP)
+				aic_freeze_scb(scbp);
 			if ((scbp->flags & SCB_ACTIVE) == 0)
 				printf("Inactive SCB on pending list\n");
 			ahd_done(ahd, scbp);
@@ -7725,11 +7758,11 @@ ahd_reset_current_bus(struct ahd_softc *
 	scsiseq = ahd_inb(ahd, SCSISEQ0) & ~(ENSELO|ENARBO|SCSIRSTO);
 	ahd_outb(ahd, SCSISEQ0, scsiseq | SCSIRSTO);
 	ahd_flush_device_writes(ahd);
-	ahd_delay(AHD_BUSRESET_DELAY);
+	aic_delay(AHD_BUSRESET_DELAY);
 	/* Turn off the bus reset */
 	ahd_outb(ahd, SCSISEQ0, scsiseq);
 	ahd_flush_device_writes(ahd);
-	ahd_delay(AHD_BUSRESET_DELAY);
+	aic_delay(AHD_BUSRESET_DELAY);
 	if ((ahd->bugs & AHD_SCSIRST_BUG) != 0) {
 		/*
 		 * 2A Razor #474
@@ -7797,7 +7830,7 @@ ahd_reset_channel(struct ahd_softc *ahd,
 		ahd_outb(ahd, DFCNTRL,
 			 ahd_inb(ahd, DFCNTRL) & ~(SCSIEN|HDMAEN));
 		while ((ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0)
-			ahd_delay(10);
+			aic_delay(10);
 		/*
 		 * Set CURRFIFO to the now inactive channel.
 		 */
@@ -7810,7 +7843,7 @@ ahd_reset_channel(struct ahd_softc *ahd,
 	 */
 	ahd_clear_msg_state(ahd);
 	ahd_outb(ahd, SIMODE1,
-		 ahd_inb(ahd, SIMODE1) & ~(ENBUSFREE|ENSCSIRST|ENBUSFREE));
+		 ahd_inb(ahd, SIMODE1) & ~(ENBUSFREE|ENSCSIRST));
 
 	if (initiate_reset)
 		ahd_reset_current_bus(ahd);
@@ -7892,8 +7925,8 @@ ahd_reset_channel(struct ahd_softc *ahd,
 	 */
 	if ((ahd->flags & AHD_RESET_POLL_ACTIVE) == 0) {
 		ahd->flags |= AHD_RESET_POLL_ACTIVE;
-		ahd_freeze_simq(ahd);
-		ahd_timer_reset(&ahd->reset_timer, 0, ahd_reset_poll, ahd);
+		aic_freeze_simq(ahd);
+		aic_timer_reset(&ahd->reset_timer, 0, ahd_reset_poll, ahd);
 	}
 	return (found);
 }
@@ -7921,7 +7954,7 @@ ahd_reset_poll(void *arg)
 	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
 	ahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);
 	if ((ahd_inb(ahd, SSTAT1) & SCSIRSTI) != 0) {
-		ahd_timer_reset(&ahd->reset_timer, AHD_RESET_POLL_US,
+		aic_timer_reset(&ahd->reset_timer, AHD_RESET_POLL_US,
 				ahd_reset_poll, ahd);
 		ahd_unpause(ahd);
 		ahd_unlock(ahd, &s);
@@ -7936,7 +7969,7 @@ ahd_reset_poll(void *arg)
 	ahd_unpause(ahd);
 	ahd->flags &= ~AHD_RESET_POLL_ACTIVE;
 	ahd_unlock(ahd, &s);
-	ahd_release_simq(ahd);
+	aic_release_simq(ahd);
 	ahd_list_unlock(&l);
 }
 
@@ -7979,7 +8012,7 @@ ahd_stat_timer(void *arg)
 	ahd->cmdcmplt_bucket = (ahd->cmdcmplt_bucket+1) & (AHD_STAT_BUCKETS-1);
 	ahd->cmdcmplt_total -= ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket];
 	ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket] = 0;
-	ahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,
+	aic_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,
 			ahd_stat_timer, ahd);
 	ahd_unlock(ahd, &s);
 	ahd_list_unlock(&l);
@@ -8000,30 +8033,35 @@ ahd_handle_scb_status(struct ahd_softc *
 void
 ahd_handle_scsi_status(struct ahd_softc *ahd, struct scb *scb)
 {
-	struct hardware_scb *hscb;
-	u_int  qfreeze_cnt;
+	struct	hardware_scb *hscb;
+	int	paused;
 
 	/*
 	 * The sequencer freezes its select-out queue
 	 * anytime a SCSI status error occurs.  We must
-	 * handle the error and decrement the QFREEZE count
-	 * to allow the sequencer to continue.
+	 * handle the error and increment our qfreeze count
+	 * to allow the sequencer to continue.  We don't
+	 * bother clearing critical sections here since all
+	 * operations are on data structures that the sequencer
+	 * is not touching once the queue is frozen.
 	 */
 	hscb = scb->hscb; 
 
-	/* Freeze the queue until the client sees the error. */
-	ahd_freeze_devq(ahd, scb);
-	ahd_freeze_scb(scb);
-	qfreeze_cnt = ahd_inw(ahd, QFREEZE_COUNT);
-	if (qfreeze_cnt == 0) {
-		printf("%s: Bad status with 0 qfreeze count!\n", ahd_name(ahd));
+	if (ahd_is_paused(ahd)) {
+		paused = 1;
 	} else {
-		qfreeze_cnt--;
-		ahd_outw(ahd, QFREEZE_COUNT, qfreeze_cnt);
+		paused = 0;
+		ahd_pause(ahd);
 	}
-	if (qfreeze_cnt == 0)
-		ahd_outb(ahd, SEQ_FLAGS2,
-			 ahd_inb(ahd, SEQ_FLAGS2) & ~SELECTOUT_QFROZEN);
+
+	/* Freeze the queue until the client sees the error. */
+	ahd_freeze_devq(ahd, scb);
+	aic_freeze_scb(scb);
+	ahd->qfreeze_cnt++;
+	ahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);
+
+	if (paused == 0)
+		ahd_unpause(ahd);
 
 	/* Don't want to clobber the original sense code */
 	if ((scb->flags & SCB_SENSE) != 0) {
@@ -8032,12 +8070,12 @@ ahd_handle_scsi_status(struct ahd_softc 
 		 * a normal command completion.
 		 */
 		scb->flags &= ~SCB_SENSE;
-		ahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+		aic_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
 		ahd_done(ahd, scb);
 		return;
 	}
-	ahd_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
-	ahd_set_scsi_status(scb, hscb->shared_data.istatus.scsi_status);
+	aic_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
+	aic_set_scsi_status(scb, hscb->shared_data.istatus.scsi_status);
 	switch (hscb->shared_data.istatus.scsi_status) {
 	case STATUS_PKT_SENSE:
 	{
@@ -8045,7 +8083,7 @@ ahd_handle_scsi_status(struct ahd_softc 
 
 		ahd_sync_sense(ahd, scb, BUS_DMASYNC_POSTREAD);
 		siu = (struct scsi_status_iu_header *)scb->sense_data;
-		ahd_set_scsi_status(scb, siu->status);
+		aic_set_scsi_status(scb, siu->status);
 #ifdef AHD_DEBUG
 		if ((ahd_debug & AHD_SHOW_SENSE) != 0) {
 			ahd_print_path(ahd, scb);
@@ -8086,7 +8124,7 @@ ahd_handle_scsi_status(struct ahd_softc 
 				}
 			}
 			if (siu->status == SCSI_STATUS_OK)
-				ahd_set_transaction_status(scb,
+				aic_set_transaction_status(scb,
 							   CAM_REQ_CMP_ERR);
 		}
 		if ((siu->flags & SIU_SNSVALID) != 0) {
@@ -8116,7 +8154,7 @@ ahd_handle_scsi_status(struct ahd_softc 
 		}
 #endif
 
-		if (ahd_perform_autosense(scb) == 0)
+		if (aic_perform_autosense(scb) == 0)
 			break;
 
 		ahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),
@@ -8144,7 +8182,7 @@ ahd_handle_scsi_status(struct ahd_softc 
 #endif
 		scb->sg_count = 0;
 		sg = ahd_sg_setup(ahd, scb, sg, ahd_get_sense_bufaddr(ahd, scb),
-				  ahd_get_sense_bufsize(ahd, scb),
+				  aic_get_sense_bufsize(ahd, scb),
 				  /*last*/TRUE);
 		sc->opcode = REQUEST_SENSE;
 		sc->byte2 = 0;
@@ -8153,7 +8191,7 @@ ahd_handle_scsi_status(struct ahd_softc 
 			sc->byte2 = SCB_GET_LUN(scb) << 5;
 		sc->unused[0] = 0;
 		sc->unused[1] = 0;
-		sc->length = ahd_get_sense_bufsize(ahd, scb);
+		sc->length = aic_get_sense_bufsize(ahd, scb);
 		sc->control = 0;
 
 		/*
@@ -8173,7 +8211,7 @@ ahd_handle_scsi_status(struct ahd_softc 
 		 * errors will be reported before any data
 		 * phases occur.
 		 */
-		if (ahd_get_residual(scb) == ahd_get_transfer_length(scb)) {
+		if (aic_get_residual(scb) == aic_get_transfer_length(scb)) {
 			ahd_update_neg_request(ahd, &devinfo,
 					       tstate, targ_info,
 					       AHD_NEG_IF_NON_ASYNC);
@@ -8192,7 +8230,7 @@ ahd_handle_scsi_status(struct ahd_softc 
 		 * Ensure we have enough time to actually
 		 * retrieve the sense.
 		 */
-		ahd_scb_timer_reset(scb, 5 * 1000000);
+		aic_scb_timer_reset(scb, 5 * 1000000);
 		break;
 	}
 	case SCSI_STATUS_OK:
@@ -8234,7 +8272,7 @@ ahd_calc_residual(struct ahd_softc *ahd,
 	 */
 
 	hscb = scb->hscb;
-	sgptr = ahd_le32toh(hscb->sgptr);
+	sgptr = aic_le32toh(hscb->sgptr);
 	if ((sgptr & SG_STATUS_VALID) == 0)
 		/* Case 1 */
 		return;
@@ -8251,10 +8289,10 @@ ahd_calc_residual(struct ahd_softc *ahd,
 	 * regardless of the role for this SCB.
 	 */
 	spkt = &hscb->shared_data.istatus;
-	resid_sgptr = ahd_le32toh(spkt->residual_sgptr);
+	resid_sgptr = aic_le32toh(spkt->residual_sgptr);
 	if ((sgptr & SG_FULL_RESID) != 0) {
 		/* Case 3 */
-		resid = ahd_get_transfer_length(scb);
+		resid = aic_get_transfer_length(scb);
 	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
 		/* Case 4 */
 		return;
@@ -8263,8 +8301,8 @@ ahd_calc_residual(struct ahd_softc *ahd,
 		printf("data overrun detected Tag == 0x%x.\n",
 		       SCB_GET_TAG(scb));
 		ahd_freeze_devq(ahd, scb);
-		ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
-		ahd_freeze_scb(scb);
+		aic_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+		aic_freeze_scb(scb);
 		return;
 	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
 		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
@@ -8276,7 +8314,7 @@ ahd_calc_residual(struct ahd_softc *ahd,
 		 * Remainder of the SG where the transfer
 		 * stopped.  
 		 */
-		resid = ahd_le32toh(spkt->residual_datacnt) & AHD_SG_LEN_MASK;
+		resid = aic_le32toh(spkt->residual_datacnt) & AHD_SG_LEN_MASK;
 		sg = ahd_sg_bus_to_virt(ahd, scb, resid_sgptr & SG_PTR_MASK);
 
 		/* The residual sg_ptr always points to the next sg */
@@ -8287,15 +8325,15 @@ ahd_calc_residual(struct ahd_softc *ahd,
 		 * SG segments that are after the SG where
 		 * the transfer stopped.
 		 */
-		while ((ahd_le32toh(sg->len) & AHD_DMA_LAST_SEG) == 0) {
+		while ((aic_le32toh(sg->len) & AHD_DMA_LAST_SEG) == 0) {
 			sg++;
-			resid += ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+			resid += aic_le32toh(sg->len) & AHD_SG_LEN_MASK;
 		}
 	}
 	if ((scb->flags & SCB_SENSE) == 0)
-		ahd_set_residual(scb, resid);
+		aic_set_residual(scb, resid);
 	else
-		ahd_set_sense_residual(scb, resid);
+		aic_set_sense_residual(scb, resid);
 
 #ifdef AHD_DEBUG
 	if ((ahd_debug & AHD_SHOW_MISC) != 0) {
@@ -8407,8 +8445,7 @@ ahd_dumpseq(struct ahd_softc* ahd)
 	max_prog = 2048;
 
 	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
-	ahd_outb(ahd, PRGMCNT, 0);
-	ahd_outb(ahd, PRGMCNT+1, 0);
+	ahd_outw(ahd, PRGMCNT, 0);
 	for (i = 0; i < max_prog; i++) {
 		uint8_t ins_bytes[4];
 
@@ -8523,8 +8560,7 @@ ahd_loadseq(struct ahd_softc *ahd)
 	downloaded = 0;
 	skip_addr = 0;
 	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
-	ahd_outb(ahd, PRGMCNT, 0);
-	ahd_outb(ahd, PRGMCNT+1, 0);
+	ahd_outw(ahd, PRGMCNT, 0);
 
 	for (i = 0; i < sizeof(seqprog)/4; i++) {
 		if (ahd_check_patch(ahd, &cur_patch, i, &skip_addr) == 0) {
@@ -8653,7 +8689,7 @@ ahd_download_instr(struct ahd_softc *ahd
 	/*
 	 * The firmware is always compiled into a little endian format.
 	 */
-	instr.integer = ahd_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
+	instr.integer = aic_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
 
 	fmt1_ins = &instr.format1;
 	fmt3_ins = NULL;
@@ -8701,7 +8737,7 @@ ahd_download_instr(struct ahd_softc *ahd
 			instr.format1.parity = 1;
 
 		/* The sequencer is a little endian cpu */
-		instr.integer = ahd_htole32(instr.integer);
+		instr.integer = aic_htole32(instr.integer);
 		ahd_outsb(ahd, SEQRAM, instr.bytes, 4);
 		break;
 	}
@@ -8827,7 +8863,7 @@ ahd_dump_card_state(struct ahd_softc *ah
 	printf(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"
 	       "%s: Dumping Card State at program address 0x%x Mode 0x%x\n",
 	       ahd_name(ahd), 
-	       ahd_inb(ahd, CURADDR) | (ahd_inb(ahd, CURADDR+1) << 8),
+	       ahd_inw(ahd, CURADDR),
 	       ahd_build_mode_state(ahd, ahd->saved_src_mode,
 				    ahd->saved_dst_mode));
 	if (paused)
@@ -8943,6 +8979,15 @@ ahd_dump_card_state(struct ahd_softc *ah
 		scb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
 	}
 	printf("\n");
+	printf("Sequencer On QFreeze and Complete list: ");
+	scb_index = ahd_inw(ahd, COMPLETE_ON_QFREEZE_HEAD);
+	i = 0;
+	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
+		ahd_set_scbptr(ahd, scb_index);
+		printf("%d ", scb_index);
+		scb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
+	}
+	printf("\n");
 	ahd_set_scbptr(ahd, saved_scb_index);
 	dffstat = ahd_inb(ahd, DFFSTAT);
 	for (i = 0; i < 2; i++) {
@@ -9072,6 +9117,280 @@ ahd_dump_scbs(struct ahd_softc *ahd)
 	ahd_restore_modes(ahd, saved_modes);
 }
 
+
+/*************************** Timeout Handling *********************************/
+void
+ahd_timeout(struct scb *scb)
+{
+	struct ahd_softc *ahd;
+
+	ahd = scb->ahd_softc;
+	if ((scb->flags & SCB_ACTIVE) != 0) {
+		if ((scb->flags & SCB_TIMEDOUT) == 0) {
+			LIST_INSERT_HEAD(&ahd->timedout_scbs, scb,
+					 timedout_links);
+			scb->flags |= SCB_TIMEDOUT;
+		}
+		ahd_wakeup_recovery_thread(ahd);
+	}
+}
+
+/*
+ * ahd_recover_commands determines if any of the commands that have currently
+ * timedout are the root cause for this timeout.  Innocent commands are given
+ * a new timeout while we wait for the command executing on the bus to timeout.
+ * This routine is invoked from a thread context so we are allowed to sleep.
+ * Our lock is not held on entry.
+ */
+void
+ahd_recover_commands(struct ahd_softc *ahd)
+{
+	struct	scb *scb;
+	struct	scb *active_scb;
+	long	s;
+	int	found;
+	int	was_paused;
+	u_int	active_scbptr;
+	u_int	last_phase;
+
+	ahd_lock(ahd, &s);
+
+	/*
+	 * Pause the controller and manually flush any
+	 * commands that have just completed but that our
+	 * interrupt handler has yet to see.
+	 */
+	was_paused = ahd_is_paused(ahd);
+	ahd_pause_and_flushwork(ahd);
+
+	if (LIST_EMPTY(&ahd->timedout_scbs) != 0) {
+		/*
+		 * The timedout commands have already
+		 * completed.  This typically means
+		 * that either the timeout value was on
+		 * the hairy edge of what the device
+		 * requires or - more likely - interrupts
+		 * are not happening.
+		 */
+		printf("%s: Timedout SCBs already complete. "
+		       "Interrupts may not be functioning.\n", ahd_name(ahd));
+		ahd_unpause(ahd);
+		ahd_unlock(ahd, &s);
+		return;
+	}
+
+	printf("%s: Recovery Initiated - Card was %spaused\n", ahd_name(ahd),
+	       was_paused ? "" : "not ");
+	ahd_dump_card_state(ahd);
+
+	/*
+	 * Determine identity of SCB acting on the bus.
+	 * This test only catches non-packetized transactions.
+	 * Due to the fleeting nature of packetized operations,
+	 * we can't easily determine that a packetized operation
+	 * is on the bus.
+	 */
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	last_phase = ahd_inb(ahd, LASTPHASE);
+	active_scbptr = ahd_get_scbptr(ahd);
+	active_scb = NULL;
+	if (last_phase != P_BUSFREE
+	 || (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) == 0)
+		active_scb = ahd_lookup_scb(ahd, active_scbptr);
+
+	while ((scb = LIST_FIRST(&ahd->timedout_scbs)) != NULL) {
+		int	target;
+		int	lun;
+		char	channel;
+
+		target = SCB_GET_TARGET(ahd, scb);
+		channel = SCB_GET_CHANNEL(ahd, scb);
+		lun = SCB_GET_LUN(scb);
+
+		ahd_print_path(ahd, scb);
+		printf("SCB 0x%x - timed out\n", scb->hscb->tag);
+
+		if (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {
+			/*
+			 * Been down this road before.
+			 * Do a full bus reset.
+			 */
+			aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+bus_reset:
+			found = ahd_reset_channel(ahd, channel,
+						  /*Initiate Reset*/TRUE);
+			printf("%s: Issued Channel %c Bus Reset. "
+			       "%d SCBs aborted\n", ahd_name(ahd), channel,
+			       found);
+			continue;
+		}
+
+		/*
+		 * Remove the command from the timedout list in
+		 * preparation for requeing it.
+		 */
+		LIST_REMOVE(scb, timedout_links);
+		scb->flags &= ~SCB_TIMEDOUT;
+
+		if (active_scb != NULL) {
+
+			if (active_scb != scb) {
+				/*
+				 * If the active SCB is not us, assume that
+				 * the active SCB has a longer timeout than
+				 * the timedout SCB, and wait for the active
+				 * SCB to timeout.
+				 */ 
+				ahd_other_scb_timeout(ahd, scb, active_scb);
+				continue;
+			} 
+
+			/*
+			 * We're active on the bus, so assert ATN
+			 * and hope that the target responds.
+			 */
+			ahd_set_recoveryscb(ahd, active_scb);
+                	active_scb->flags |= SCB_RECOVERY_SCB|SCB_DEVICE_RESET;
+			ahd_outb(ahd, MSG_OUT, HOST_MSG);
+			ahd_outb(ahd, SCSISIGO, last_phase|ATNO);
+			ahd_print_path(ahd, active_scb);
+			printf("BDR message in message buffer\n");
+			aic_scb_timer_reset(scb, 2 * 1000000);
+			break;
+		} else if (last_phase != P_BUSFREE
+			&& ahd_inb(ahd, SCSIPHASE) == 0) {
+			/*
+			 * SCB is not identified, there
+			 * is no pending REQ, and the sequencer
+			 * has not seen a busfree.  Looks like
+			 * a stuck connection waiting to
+			 * go busfree.  Reset the bus.
+			 */
+			printf("%s: Connection stuck awaiting busfree or "
+			       "Identify Msg.\n", ahd_name(ahd));
+			goto bus_reset;
+		} else if (ahd_search_qinfifo(ahd, target, channel, lun,
+					      scb->hscb->tag, ROLE_INITIATOR,
+					      /*status*/0, SEARCH_COUNT) > 0) {
+
+			/*
+			 * We haven't even gone out on the bus
+			 * yet, so the timeout must be due to
+			 * some other command.  Reset the timer
+			 * and go on.
+			 */
+			ahd_other_scb_timeout(ahd, scb, scb);
+		} else {
+			/*
+			 * This SCB is for a disconnected transaction
+			 * and we haven't found a better candidate on
+			 * the bus to explain this timeout.
+			 */
+			ahd_set_recoveryscb(ahd, scb);
+
+			/*
+			 * Actually re-queue this SCB in an attempt
+			 * to select the device before it reconnects.
+			 * In either case (selection or reselection),
+			 * we will now issue a target reset to the
+			 * timed-out device.
+			 *
+			 * Set the MK_MESSAGE control bit indicating
+			 * that we desire to send a message.  We
+			 * also set the disconnected flag since
+			 * in the paging case there is no guarantee
+			 * that our SCB control byte matches the
+			 * version on the card.  We don't want the
+			 * sequencer to abort the command thinking
+			 * an unsolicited reselection occurred.
+			 */
+			scb->flags |= SCB_DEVICE_RESET;
+			scb->hscb->cdb_len = 0;
+			scb->hscb->task_attribute = 0;
+			scb->hscb->task_management = SIU_TASKMGMT_ABORT_TASK;
+
+			ahd_set_scbptr(ahd, SCB_GET_TAG(scb));
+			if ((scb->flags & SCB_PACKETIZED) != 0) {
+				/*
+				 * Mark the SCB has having an outstanding
+				 * task management function.  Should the command
+				 * complete normally before the task management
+				 * function can be sent, the host will be
+				 * notified to abort our requeued SCB.
+				 */
+				ahd_outb(ahd, SCB_TASK_MANAGEMENT,
+					 scb->hscb->task_management);
+			} else {
+				/*
+				 * If non-packetized, set the MK_MESSAGE control
+				 * bit indicating that we desire to send a
+				 * message.  We also set the disconnected flag
+				 * since there is no guarantee that our SCB
+				 * control byte matches the version on the
+				 * card.  We don't want the sequencer to abort
+				 * the command thinking an unsolicited
+				 * reselection occurred.
+				 */
+				scb->hscb->control |= MK_MESSAGE|DISCONNECTED;
+
+				/*
+				 * The sequencer will never re-reference the
+				 * in-core SCB.  To make sure we are notified
+				 * during reslection, set the MK_MESSAGE flag in
+				 * the card's copy of the SCB.
+				 */
+				ahd_outb(ahd, SCB_CONTROL,
+					 ahd_inb(ahd, SCB_CONTROL)|MK_MESSAGE);
+			}
+
+			/*
+			 * Clear out any entries in the QINFIFO first
+			 * so we are the next SCB for this target
+			 * to run.
+			 */
+			ahd_search_qinfifo(ahd, target, channel, lun,
+					   SCB_LIST_NULL, ROLE_INITIATOR,
+					   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
+			ahd_qinfifo_requeue_tail(ahd, scb);
+			ahd_set_scbptr(ahd, active_scbptr);
+			ahd_print_path(ahd, scb);
+			printf("Queuing a BDR SCB\n");
+			aic_scb_timer_reset(scb, 2 * 1000000);
+			break;
+		}
+	}
+	
+	/*
+	 * Any remaining SCBs were not the "culprit", so remove
+	 * them from the timeout list.  The timer for these commands
+	 * will be reset once the recovery SCB completes.
+	 */
+	while ((scb = LIST_FIRST(&ahd->timedout_scbs)) != NULL) {
+
+		LIST_REMOVE(scb, timedout_links);
+		scb->flags &= ~SCB_TIMEDOUT;
+	}
+
+	ahd_unpause(ahd);
+	ahd_unlock(ahd, &s);
+}
+
+static void
+ahd_other_scb_timeout(struct ahd_softc *ahd, struct scb *scb,
+		      struct scb *other_scb)
+{
+	u_int	newtimeout;
+
+	ahd_print_path(ahd, scb);
+	printf("Other SCB Timeout%s",
+ 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
+	       ? " again\n" : "\n");
+	scb->flags |= SCB_OTHERTCL_TIMEOUT;
+	newtimeout = MAX(aic_get_timeout(other_scb),
+			 aic_get_timeout(scb));
+	aic_scb_timer_reset(scb, newtimeout);
+}
+
 /**************************** Flexport Logic **********************************/
 /*
  * Read count 16bit words from 16bit word address start_addr from the
@@ -9178,9 +9497,9 @@ ahd_wait_seeprom(struct ahd_softc *ahd)
 {
 	int cnt;
 
-	cnt = 20;
+	cnt = 5000;
 	while ((ahd_inb(ahd, SEESTAT) & (SEEARBACK|SEEBUSY)) != 0 && --cnt)
-		ahd_delay(5);
+		aic_delay(5);
 
 	if (cnt == 0)
 		return (ETIMEDOUT);
@@ -9322,7 +9641,7 @@ ahd_wait_flexport(struct ahd_softc *ahd)
 	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
 	cnt = 1000000 * 2 / 5;
 	while ((ahd_inb(ahd, BRDCTL) & FLXARBACK) == 0 && --cnt)
-		ahd_delay(5);
+		aic_delay(5);
 
 	if (cnt == 0)
 		return (ETIMEDOUT);
@@ -9524,13 +9843,9 @@ ahd_handle_en_lun(struct ahd_softc *ahd,
 			if ((ahd->features & AHD_MULTI_TID) != 0) {
 				u_int targid_mask;
 
-				targid_mask = ahd_inb(ahd, TARGID)
-					    | (ahd_inb(ahd, TARGID + 1) << 8);
-
+				targid_mask = ahd_inw(ahd, TARGID);
 				targid_mask |= target_mask;
-				ahd_outb(ahd, TARGID, targid_mask);
-				ahd_outb(ahd, TARGID+1, (targid_mask >> 8));
-				
+				ahd_outw(ahd, TARGID, targid_mask);
 				ahd_update_scsiid(ahd, targid_mask);
 			} else {
 				u_int our_id;
@@ -9644,14 +9959,9 @@ ahd_handle_en_lun(struct ahd_softc *ahd,
 				if (ahd->features & AHD_MULTI_TID) {
 					u_int targid_mask;
 
-					targid_mask = ahd_inb(ahd, TARGID)
-						    | (ahd_inb(ahd, TARGID + 1)
-						       << 8);
-
+					targid_mask = ahd_inw(ahd, TARGID);
 					targid_mask &= ~target_mask;
-					ahd_outb(ahd, TARGID, targid_mask);
-					ahd_outb(ahd, TARGID+1,
-					 	 (targid_mask >> 8));
+					ahd_outw(ahd, TARGID, targid_mask);
 					ahd_update_scsiid(ahd, targid_mask);
 				}
 			}
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_inline.h linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_inline.h
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_inline.h	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_inline.h	2004-05-13 16:42:17.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx_inline.h#51 $
+ * $Id$
  *
  * $FreeBSD$
  */
@@ -250,15 +250,15 @@ ahd_sg_setup(struct ahd_softc *ahd, stru
 		struct ahd_dma64_seg *sg;
 
 		sg = (struct ahd_dma64_seg *)sgptr;
-		sg->addr = ahd_htole64(addr);
-		sg->len = ahd_htole32(len | (last ? AHD_DMA_LAST_SEG : 0));
+		sg->addr = aic_htole64(addr);
+		sg->len = aic_htole32(len | (last ? AHD_DMA_LAST_SEG : 0));
 		return (sg + 1);
 	} else {
 		struct ahd_dma_seg *sg;
 
 		sg = (struct ahd_dma_seg *)sgptr;
-		sg->addr = ahd_htole32(addr & 0xFFFFFFFF);
-		sg->len = ahd_htole32(len | ((addr >> 8) & 0x7F000000)
+		sg->addr = aic_htole32(addr & 0xFFFFFFFF);
+		sg->len = aic_htole32(len | ((addr >> 8) & 0x7F000000)
 				    | (last ? AHD_DMA_LAST_SEG : 0));
 		return (sg + 1);
 	}
@@ -273,7 +273,7 @@ ahd_setup_scb_common(struct ahd_softc *a
 		/* XXX what about ACA??  It is type 4, but TAG_TYPE == 0x3. */
 		scb->hscb->task_attribute = scb->hscb->control & SCB_TAG_TYPE;
 	} else {
-		if (ahd_get_transfer_length(scb) & 0x01)
+		if (aic_get_transfer_length(scb) & 0x01)
 			scb->hscb->task_attribute = SCB_XFERLEN_ODD;
 		else
 			scb->hscb->task_attribute = 0;
@@ -282,7 +282,7 @@ ahd_setup_scb_common(struct ahd_softc *a
 	if (scb->hscb->cdb_len <= MAX_CDB_LEN_WITH_SENSE_ADDR
 	 || (scb->hscb->cdb_len & SCB_CDB_LEN_PTR) != 0)
 		scb->hscb->shared_data.idata.cdb_plus_saddr.sense_addr =
-		    ahd_htole32(scb->sense_busaddr);
+		    aic_htole32(scb->sense_busaddr);
 }
 
 static __inline void
@@ -308,8 +308,8 @@ ahd_setup_data_scb(struct ahd_softc *ahd
 		if ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
 			uint64_t high_addr;
 
-			high_addr = ahd_le32toh(sg->len) & 0x7F000000;
-			scb->hscb->dataptr |= ahd_htole64(high_addr << 8);
+			high_addr = aic_le32toh(sg->len) & 0x7F000000;
+			scb->hscb->dataptr |= aic_htole64(high_addr << 8);
 		}
 		scb->hscb->datacnt = sg->len;
 	}
@@ -319,13 +319,13 @@ ahd_setup_data_scb(struct ahd_softc *ahd
 	 * sequencer will clear as soon as a data transfer
 	 * occurs.
 	 */
-	scb->hscb->sgptr = ahd_htole32(scb->sg_list_busaddr|SG_FULL_RESID);
+	scb->hscb->sgptr = aic_htole32(scb->sg_list_busaddr|SG_FULL_RESID);
 }
 
 static __inline void
 ahd_setup_noxfer_scb(struct ahd_softc *ahd, struct scb *scb)
 {
-	scb->hscb->sgptr = ahd_htole32(SG_LIST_NULL);
+	scb->hscb->sgptr = aic_htole32(SG_LIST_NULL);
 	scb->hscb->dataptr = 0;
 	scb->hscb->datacnt = 0;
 }
@@ -383,7 +383,7 @@ ahd_sg_virt_to_bus(struct ahd_softc *ahd
 static __inline void
 ahd_sync_scb(struct ahd_softc *ahd, struct scb *scb, int op)
 {
-	ahd_dmamap_sync(ahd, ahd->scb_data.hscb_dmat,
+	aic_dmamap_sync(ahd, ahd->scb_data.hscb_dmat,
 			scb->hscb_map->dmamap,
 			/*offset*/(uint8_t*)scb->hscb - scb->hscb_map->vaddr,
 			/*len*/sizeof(*scb->hscb), op);
@@ -395,7 +395,7 @@ ahd_sync_sglist(struct ahd_softc *ahd, s
 	if (scb->sg_count == 0)
 		return;
 
-	ahd_dmamap_sync(ahd, ahd->scb_data.sg_dmat,
+	aic_dmamap_sync(ahd, ahd->scb_data.sg_dmat,
 			scb->sg_map->dmamap,
 			/*offset*/scb->sg_list_busaddr - ahd_sg_size(ahd),
 			/*len*/ahd_sg_size(ahd) * scb->sg_count, op);
@@ -404,7 +404,7 @@ ahd_sync_sglist(struct ahd_softc *ahd, s
 static __inline void
 ahd_sync_sense(struct ahd_softc *ahd, struct scb *scb, int op)
 {
-	ahd_dmamap_sync(ahd, ahd->scb_data.sense_dmat,
+	aic_dmamap_sync(ahd, ahd->scb_data.sense_dmat,
 			scb->sense_map->dmamap,
 			/*offset*/scb->sense_busaddr,
 			/*len*/AHD_SENSE_BUFSIZE, op);
@@ -472,7 +472,7 @@ ahd_complete_scb(struct ahd_softc *ahd, 
 {
 	uint32_t sgptr;
 
-	sgptr = ahd_le32toh(scb->hscb->sgptr);
+	sgptr = aic_le32toh(scb->hscb->sgptr);
 	if ((sgptr & SG_STATUS_VALID) != 0)
 		ahd_handle_scb_status(ahd, scb);
 	else
@@ -488,7 +488,7 @@ ahd_update_residual(struct ahd_softc *ah
 {
 	uint32_t sgptr;
 
-	sgptr = ahd_le32toh(scb->hscb->sgptr);
+	sgptr = aic_le32toh(scb->hscb->sgptr);
 	if ((sgptr & SG_STATUS_VALID) != 0)
 		ahd_calc_residual(ahd, scb);
 }
@@ -522,12 +522,21 @@ do {								\
 static __inline uint16_t
 ahd_inw(struct ahd_softc *ahd, u_int port)
 {
+	/*
+	 * Read high byte first as some registers increment
+	 * or have other side effects when the low byte is
+	 * read.
+	 */
 	return ((ahd_inb(ahd, port+1) << 8) | ahd_inb(ahd, port));
 }
 
 static __inline void
 ahd_outw(struct ahd_softc *ahd, u_int port, u_int value)
 {
+	/*
+	 * Write low byte first to accomodate registers
+	 * such as PRGMCNT where the order maters.
+	 */
 	ahd_outb(ahd, port, value & 0xFF);
 	ahd_outb(ahd, port+1, (value >> 8) & 0xFF);
 }
@@ -684,7 +693,7 @@ ahd_inb_scbram(struct ahd_softc *ahd, u_
 	 * Razor #528
 	 */
 	value = ahd_inb(ahd, offset);
-	if ((ahd->flags & AHD_PCIX_SCBRAM_RD_BUG) != 0)
+	if ((ahd->bugs & AHD_PCIX_SCBRAM_RD_BUG) != 0)
 		ahd_inb(ahd, MODE_PTR);
 	return (value);
 }
@@ -727,7 +736,8 @@ ahd_lookup_scb(struct ahd_softc *ahd, u_
 static __inline void
 ahd_swap_with_next_hscb(struct ahd_softc *ahd, struct scb *scb)
 {
-	struct hardware_scb *q_hscb;
+	struct	 hardware_scb *q_hscb;
+	struct	 map_node *q_hscb_map;
 	uint32_t saved_hscb_busaddr;
 
 	/*
@@ -743,6 +753,7 @@ ahd_swap_with_next_hscb(struct ahd_softc
 	 * locate the correct SCB by SCB_TAG.
 	 */
 	q_hscb = ahd->next_queued_hscb;
+	q_hscb_map = ahd->next_queued_hscb_map;
 	saved_hscb_busaddr = q_hscb->hscb_busaddr;
 	memcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));
 	q_hscb->hscb_busaddr = saved_hscb_busaddr;
@@ -750,7 +761,9 @@ ahd_swap_with_next_hscb(struct ahd_softc
 
 	/* Now swap HSCB pointers. */
 	ahd->next_queued_hscb = scb->hscb;
+	ahd->next_queued_hscb_map = scb->hscb_map;
 	scb->hscb = q_hscb;
+	scb->hscb_map = q_hscb_map;
 
 	/* Now define the mapping from tag to SCB in the scbindex */
 	ahd->scb_data.scbindex[SCB_GET_TAG(scb)] = scb;
@@ -790,13 +803,13 @@ ahd_queue_scb(struct ahd_softc *ahd, str
 	if ((ahd_debug & AHD_SHOW_QUEUE) != 0) {
 		uint64_t host_dataptr;
 
-		host_dataptr = ahd_le64toh(scb->hscb->dataptr);
+		host_dataptr = aic_le64toh(scb->hscb->dataptr);
 		printf("%s: Queueing SCB 0x%x bus addr 0x%x - 0x%x%x/0x%x\n",
 		       ahd_name(ahd),
-		       SCB_GET_TAG(scb), ahd_le32toh(scb->hscb->hscb_busaddr),
+		       SCB_GET_TAG(scb), aic_le32toh(scb->hscb->hscb_busaddr),
 		       (u_int)((host_dataptr >> 32) & 0xFFFFFFFF),
 		       (u_int)(host_dataptr & 0xFFFFFFFF),
-		       ahd_le32toh(scb->hscb->datacnt));
+		       aic_le32toh(scb->hscb->datacnt));
 	}
 #endif
 	/* Tell the adapter about the newly queued SCB */
@@ -824,8 +837,9 @@ static __inline int	ahd_intr(struct ahd_
 static __inline void
 ahd_sync_qoutfifo(struct ahd_softc *ahd, int op)
 {
-	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
-			/*offset*/0, /*len*/AHC_SCB_MAX * sizeof(uint16_t), op);
+	aic_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,
+			/*offset*/0,
+			/*len*/AHD_SCB_MAX * sizeof(struct ahd_completion), op);
 }
 
 static __inline void
@@ -833,8 +847,8 @@ ahd_sync_tqinfifo(struct ahd_softc *ahd,
 {
 #ifdef AHD_TARGET_MODE
 	if ((ahd->flags & AHD_TARGETROLE) != 0) {
-		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
-				ahd->shared_data_dmamap,
+		aic_dmamap_sync(ahd, ahd->shared_data_dmat,
+				ahd->shared_data_map.dmamap,
 				ahd_targetcmd_offset(ahd, 0),
 				sizeof(struct target_cmd) * AHD_TMODE_CMDS,
 				op);
@@ -854,17 +868,17 @@ ahd_check_cmdcmpltqueues(struct ahd_soft
 	u_int retval;
 
 	retval = 0;
-	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
-			/*offset*/ahd->qoutfifonext, /*len*/2,
-			BUS_DMASYNC_POSTREAD);
-	if ((ahd->qoutfifo[ahd->qoutfifonext]
-	     & QOUTFIFO_ENTRY_VALID_LE) == ahd->qoutfifonext_valid_tag)
+	aic_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,
+			/*offset*/ahd->qoutfifonext * sizeof(*ahd->qoutfifo),
+			/*len*/sizeof(*ahd->qoutfifo), BUS_DMASYNC_POSTREAD);
+	if (ahd->qoutfifo[ahd->qoutfifonext].valid_tag
+	  == ahd->qoutfifonext_valid_tag)
 		retval |= AHD_RUN_QOUTFIFO;
 #ifdef AHD_TARGET_MODE
 	if ((ahd->flags & AHD_TARGETROLE) != 0
 	 && (ahd->flags & AHD_TQINFIFO_BLOCKED) == 0) {
-		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
-				ahd->shared_data_dmamap,
+		aic_dmamap_sync(ahd, ahd->shared_data_dmat,
+				ahd->shared_data_map.dmamap,
 				ahd_targetcmd_offset(ahd, ahd->tqinfifofnext),
 				/*len*/sizeof(struct target_cmd),
 				BUS_DMASYNC_POSTREAD);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_osm.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_osm.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_osm.c	2004-04-04 05:37:23.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_osm.c	2004-05-13 16:42:17.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Adaptec AIC79xx device driver for Linux.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#171 $
+ * $Id$
  *
  * --------------------------------------------------------------------------
  * Copyright (c) 1994-2000 Justin T. Gibbs.
@@ -52,9 +52,7 @@
  */
 #include "aiclib.c"
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
 #include <linux/init.h>		/* __setup */
-#endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 #include "sd.h"			/* For geometry detection */
@@ -62,19 +60,27 @@
 
 #include <linux/mm.h>		/* For fetching system memory size */
 
+/************************* Magic SysReq Support *******************************/
+static struct aic_sysrq_key_op ahd_sysrq_op =
+{
+	aic_sysrq_handler,
+	"aic79xxstatedump",
+	"Dump aic79xx controller information to Console"
+};
+
+static int ahd_sysrq_key;
+
+/***************************** Global Data ************************************/
+/*
+ * Driver Initialization Status.  Used by ahd_linux_exit().
+ */
+int ahd_init_status;
+
 /*
  * Lock protecting manipulation of the ahd softc list.
  */
 spinlock_t ahd_list_spinlock;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-struct proc_dir_entry proc_scsi_aic79xx = {
-	PROC_SCSI_AIC79XX, 7, "aic79xx",
-	S_IFDIR | S_IRUGO | S_IXUGO, 2,
-	0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
-};
-#endif
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 /* For dynamic sglist size calculation. */
 u_int ahd_linux_nseg;
@@ -433,6 +439,7 @@ MODULE_PARM(aic79xx, "s");
 MODULE_PARM_DESC(aic79xx,
 "period delimited, options string.\n"
 "	verbose			Enable verbose/diagnostic logging\n"
+"	attach_HostRAID:<int>	Attach to controllers in HostRAID mode\n"
 "	allow_memio		Allow device registers to be memory mapped\n"
 "	debug			Bitmask of debug values to enable\n"
 "	no_reset		Supress initial bus resets\n"
@@ -452,47 +459,49 @@ MODULE_PARM_DESC(aic79xx,
 "	seltime:<int>		Selection Timeout:\n"
 "				(0/256ms,1/128ms,2/64ms,3/32ms)\n"
 "\n"
-"	Sample /etc/modprobe.conf line:\n"
+"	Sample module configuration line:\n"
 "		Enable verbose logging\n"
 "		Set tag depth on Controller 2/Target 2 to 10 tags\n"
 "		Shorten the selection timeout to 128ms\n"
 "\n"
 "	options aic79xx 'aic79xx=verbose.tag_info:{{}.{}.{..10}}.seltime:1'\n"
 "\n"
-"	Sample /etc/modprobe.conf line:\n"
+"	Sample module configuration line:\n"
 "		Change Read Streaming for Controller's 2 and 3\n"
 "\n"
 "	options aic79xx 'aic79xx=rd_strm:{..0xFFF0.0xC0F0}'");
 #endif
 
 static void ahd_linux_handle_scsi_status(struct ahd_softc *,
-					 struct ahd_linux_device *,
+					 struct aic_linux_device *,
 					 struct scb *);
 static void ahd_linux_queue_cmd_complete(struct ahd_softc *ahd,
 					 Scsi_Cmnd *cmd);
 static void ahd_linux_filter_inquiry(struct ahd_softc *ahd,
 				     struct ahd_devinfo *devinfo);
+static int __init ahd_linux_init(void);
+static void ahd_linux_exit(void);
 static void ahd_linux_dev_timed_unfreeze(u_long arg);
+static void ahd_linux_targ_timed_unfreeze(u_long arg);
 static void ahd_linux_sem_timeout(u_long arg);
 static void ahd_linux_initialize_scsi_bus(struct ahd_softc *ahd);
 static void ahd_linux_size_nseg(void);
 static void ahd_linux_thread_run_complete_queue(struct ahd_softc *ahd);
 static void ahd_linux_start_dv(struct ahd_softc *ahd);
-static void ahd_linux_dv_timeout(struct scsi_cmnd *cmd);
 static int  ahd_linux_dv_thread(void *data);
 static void ahd_linux_kill_dv_thread(struct ahd_softc *ahd);
 static void ahd_linux_dv_target(struct ahd_softc *ahd, u_int target);
 static void ahd_linux_dv_transition(struct ahd_softc *ahd,
 				    struct scsi_cmnd *cmd,
 				    struct ahd_devinfo *devinfo,
-				    struct ahd_linux_target *targ);
+				    struct aic_linux_target *targ);
 static void ahd_linux_dv_fill_cmd(struct ahd_softc *ahd,
 				  struct scsi_cmnd *cmd,
 				  struct ahd_devinfo *devinfo);
 static void ahd_linux_dv_inq(struct ahd_softc *ahd,
 			     struct scsi_cmnd *cmd,
 			     struct ahd_devinfo *devinfo,
-			     struct ahd_linux_target *targ,
+			     struct aic_linux_target *targ,
 			     u_int request_length);
 static void ahd_linux_dv_tur(struct ahd_softc *ahd,
 			     struct scsi_cmnd *cmd,
@@ -500,19 +509,19 @@ static void ahd_linux_dv_tur(struct ahd_
 static void ahd_linux_dv_rebd(struct ahd_softc *ahd,
 			      struct scsi_cmnd *cmd,
 			      struct ahd_devinfo *devinfo,
-			      struct ahd_linux_target *targ);
+			      struct aic_linux_target *targ);
 static void ahd_linux_dv_web(struct ahd_softc *ahd,
 			     struct scsi_cmnd *cmd,
 			     struct ahd_devinfo *devinfo,
-			     struct ahd_linux_target *targ);
+			     struct aic_linux_target *targ);
 static void ahd_linux_dv_reb(struct ahd_softc *ahd,
 			     struct scsi_cmnd *cmd,
 			     struct ahd_devinfo *devinfo,
-			     struct ahd_linux_target *targ);
+			     struct aic_linux_target *targ);
 static void ahd_linux_dv_su(struct ahd_softc *ahd,
 			    struct scsi_cmnd *cmd,
 			    struct ahd_devinfo *devinfo,
-			    struct ahd_linux_target *targ);
+			    struct aic_linux_target *targ);
 static __inline int
 	   ahd_linux_dv_fallback(struct ahd_softc *ahd,
 				 struct ahd_devinfo *devinfo);
@@ -520,103 +529,57 @@ static int ahd_linux_fallback(struct ahd
 			      struct ahd_devinfo *devinfo);
 static __inline int ahd_linux_dv_fallback(struct ahd_softc *ahd,
 					  struct ahd_devinfo *devinfo);
-static void ahd_linux_dv_complete(Scsi_Cmnd *cmd);
-static void ahd_linux_generate_dv_pattern(struct ahd_linux_target *targ);
+static void ahd_linux_generate_dv_pattern(struct aic_linux_target *targ);
 static u_int ahd_linux_user_tagdepth(struct ahd_softc *ahd,
 				     struct ahd_devinfo *devinfo);
 static u_int ahd_linux_user_dv_setting(struct ahd_softc *ahd);
 static void ahd_linux_setup_user_rd_strm_settings(struct ahd_softc *ahd);
-static void ahd_linux_device_queue_depth(struct ahd_softc *ahd,
-					 struct ahd_linux_device *dev);
-static struct ahd_linux_target*	ahd_linux_alloc_target(struct ahd_softc*,
+static void aic_linux_device_queue_depth(struct ahd_softc *ahd,
+					 struct aic_linux_device *dev);
+static struct aic_linux_target*	ahd_linux_alloc_target(struct ahd_softc*,
 						       u_int, u_int);
 static void			ahd_linux_free_target(struct ahd_softc*,
-						      struct ahd_linux_target*);
-static struct ahd_linux_device*	ahd_linux_alloc_device(struct ahd_softc*,
-						       struct ahd_linux_target*,
+						      struct aic_linux_target*);
+static struct aic_linux_device*	ahd_linux_alloc_device(struct ahd_softc*,
+						       struct aic_linux_target*,
 						       u_int);
 static void			ahd_linux_free_device(struct ahd_softc*,
-						      struct ahd_linux_device*);
-static void ahd_linux_run_device_queue(struct ahd_softc*,
-				       struct ahd_linux_device*);
+						      struct aic_linux_device*);
 static void ahd_linux_setup_tag_info_global(char *p);
 static aic_option_callback_t ahd_linux_setup_tag_info;
 static aic_option_callback_t ahd_linux_setup_rd_strm_info;
 static aic_option_callback_t ahd_linux_setup_dv;
 static aic_option_callback_t ahd_linux_setup_iocell_info;
 static int ahd_linux_next_unit(void);
-static void ahd_runq_tasklet(unsigned long data);
 static int aic79xx_setup(char *c);
 
 /****************************** Inlines ***************************************/
 static __inline void ahd_schedule_completeq(struct ahd_softc *ahd);
-static __inline void ahd_schedule_runq(struct ahd_softc *ahd);
-static __inline void ahd_setup_runq_tasklet(struct ahd_softc *ahd);
-static __inline void ahd_teardown_runq_tasklet(struct ahd_softc *ahd);
-static __inline struct ahd_linux_device*
+static __inline struct aic_linux_device*
 		     ahd_linux_get_device(struct ahd_softc *ahd, u_int channel,
 					  u_int target, u_int lun, int alloc);
-static struct ahd_cmd *ahd_linux_run_complete_queue(struct ahd_softc *ahd);
-static __inline void ahd_linux_check_device_queue(struct ahd_softc *ahd,
-						  struct ahd_linux_device *dev);
-static __inline struct ahd_linux_device *
-		     ahd_linux_next_device_to_run(struct ahd_softc *ahd);
-static __inline void ahd_linux_run_device_queues(struct ahd_softc *ahd);
 static __inline void ahd_linux_unmap_scb(struct ahd_softc*, struct scb*);
-
-static __inline int ahd_linux_map_seg(struct ahd_softc *ahd, struct scb *scb,
-		 		      struct ahd_dma_seg *sg,
-				      bus_addr_t addr, bus_size_t len);
+static __inline struct ahd_dma_seg*
+		     ahd_linux_sg_setup(struct ahd_softc *ahd, struct scb *scb,
+					struct ahd_dma_seg *sg, bus_addr_t addr,
+					bus_size_t len, int last_seg);
 
 static __inline void
 ahd_schedule_completeq(struct ahd_softc *ahd)
 {
-	if ((ahd->platform_data->flags & AHD_RUN_CMPLT_Q_TIMER) == 0) {
-		ahd->platform_data->flags |= AHD_RUN_CMPLT_Q_TIMER;
+	if ((ahd->platform_data->flags & AIC_RUN_CMPLT_Q_TIMER) == 0) {
+		ahd->platform_data->flags |= AIC_RUN_CMPLT_Q_TIMER;
 		ahd->platform_data->completeq_timer.expires = jiffies;
 		add_timer(&ahd->platform_data->completeq_timer);
 	}
 }
 
-/*
- * Must be called with our lock held.
- */
-static __inline void
-ahd_schedule_runq(struct ahd_softc *ahd)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_schedule(&ahd->platform_data->runq_tasklet);
-#else
-	/*
-	 * Tasklets are not available, so run inline.
-	 */
-	ahd_runq_tasklet((unsigned long)ahd);
-#endif
-}
-
-static __inline
-void ahd_setup_runq_tasklet(struct ahd_softc *ahd)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_init(&ahd->platform_data->runq_tasklet, ahd_runq_tasklet,
-		     (unsigned long)ahd);
-#endif
-}
-
-static __inline void
-ahd_teardown_runq_tasklet(struct ahd_softc *ahd)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_kill(&ahd->platform_data->runq_tasklet);
-#endif
-}
-
-static __inline struct ahd_linux_device*
+static __inline struct aic_linux_device*
 ahd_linux_get_device(struct ahd_softc *ahd, u_int channel, u_int target,
 		     u_int lun, int alloc)
 {
-	struct ahd_linux_target *targ;
-	struct ahd_linux_device *dev;
+	struct aic_linux_target *targ;
+	struct aic_linux_device *dev;
 	u_int target_offset;
 
 	target_offset = target;
@@ -638,15 +601,13 @@ ahd_linux_get_device(struct ahd_softc *a
 }
 
 #define AHD_LINUX_MAX_RETURNED_ERRORS 4
-static struct ahd_cmd *
+static struct aic_cmd *
 ahd_linux_run_complete_queue(struct ahd_softc *ahd)
 {	
-	struct	ahd_cmd *acmd;
-	u_long	done_flags;
+	struct	aic_cmd *acmd;
 	int	with_errors;
 
 	with_errors = 0;
-	ahd_done_lock(ahd, &done_flags);
 	while ((acmd = TAILQ_FIRST(&ahd->platform_data->completeq)) != NULL) {
 		Scsi_Cmnd *cmd;
 
@@ -666,57 +627,13 @@ ahd_linux_run_complete_queue(struct ahd_
 			     acmd, acmd_links.tqe);
 		cmd = &acmd_scsi_cmd(acmd);
 		cmd->host_scribble = NULL;
-		if (ahd_cmd_get_transaction_status(cmd) != DID_OK
-		 || (cmd->result & 0xFF) != SCSI_STATUS_OK)
-			with_errors++;
-
 		cmd->scsi_done(cmd);
+		with_errors++;
 	}
-	ahd_done_unlock(ahd, &done_flags);
 	return (acmd);
 }
 
 static __inline void
-ahd_linux_check_device_queue(struct ahd_softc *ahd,
-			     struct ahd_linux_device *dev)
-{
-	if ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) != 0
-	 && dev->active == 0) {
-		dev->flags &= ~AHD_DEV_FREEZE_TIL_EMPTY;
-		dev->qfrozen--;
-	}
-
-	if (TAILQ_FIRST(&dev->busyq) == NULL
-	 || dev->openings == 0 || dev->qfrozen != 0)
-		return;
-
-	ahd_linux_run_device_queue(ahd, dev);
-}
-
-static __inline struct ahd_linux_device *
-ahd_linux_next_device_to_run(struct ahd_softc *ahd)
-{
-	
-	if ((ahd->flags & AHD_RESOURCE_SHORTAGE) != 0
-	 || (ahd->platform_data->qfrozen != 0
-	  && AHD_DV_SIMQ_FROZEN(ahd) == 0))
-		return (NULL);
-	return (TAILQ_FIRST(&ahd->platform_data->device_runq));
-}
-
-static __inline void
-ahd_linux_run_device_queues(struct ahd_softc *ahd)
-{
-	struct ahd_linux_device *dev;
-
-	while ((dev = ahd_linux_next_device_to_run(ahd)) != NULL) {
-		TAILQ_REMOVE(&ahd->platform_data->device_runq, dev, links);
-		dev->flags &= ~AHD_DEV_ON_RUN_LIST;
-		ahd_linux_check_device_queue(ahd, dev);
-	}
-}
-
-static __inline void
 ahd_linux_unmap_scb(struct ahd_softc *ahd, struct scb *scb)
 {
 	Scsi_Cmnd *cmd;
@@ -729,34 +646,22 @@ ahd_linux_unmap_scb(struct ahd_softc *ah
 		struct scatterlist *sg;
 
 		sg = (struct scatterlist *)cmd->request_buffer;
-		pci_unmap_sg(ahd->dev_softc, sg, cmd->use_sg, direction);
+		aic_unmap_sg(ahd, sg, cmd->use_sg, direction);
 	} else if (cmd->request_bufflen != 0) {
-		pci_unmap_single(ahd->dev_softc,
+		aic_unmap_single(ahd,
 				 scb->platform_data->buf_busaddr,
 				 cmd->request_bufflen, direction);
 	}
 }
 
-static __inline int
-ahd_linux_map_seg(struct ahd_softc *ahd, struct scb *scb,
-		  struct ahd_dma_seg *sg, bus_addr_t addr, bus_size_t len)
+static __inline struct ahd_dma_seg*
+ahd_linux_sg_setup(struct ahd_softc *ahd, struct scb *scb,
+		   struct ahd_dma_seg *sg, bus_addr_t addr,
+		   bus_size_t len, int last_seg)
 {
-	int	 consumed;
-
-	if ((scb->sg_count + 1) > AHD_NSEG)
-		panic("Too few segs for dma mapping.  "
-		      "Increase AHD_NSEG\n");
-
-	consumed = 1;
-	sg->addr = ahd_htole32(addr & 0xFFFFFFFF);
+	sg = ahd_sg_setup(ahd, scb, sg, addr, len, last_seg);
 	scb->platform_data->xfer_len += len;
-
-	if (sizeof(bus_addr_t) > 4
-	 && (ahd->flags & AHD_39BIT_ADDRESSING) != 0)
-		len |= (addr >> 8) & AHD_SG_HIGH_ADDR_MASK;
-
-	sg->len = ahd_htole32(len);
-	return (consumed);
+	return (sg);
 }
 
 /******************************** Macros **************************************/
@@ -797,7 +702,7 @@ static int	   ahd_linux_abort(Scsi_Cmnd 
  * number of segments needed for the current transfer.  Since the code that
  * sizes the SCSI malloc pool does not take into consideration fragmentation
  * of the pool, executing transactions numbering just a fraction of our
- * concurrent transaction limit with SG list lengths aproaching AHC_NSEG will
+ * concurrent transaction limit with SG list lengths aproaching AHD_NSEG will
  * quickly depleat the SCSI malloc pool of usable space.  Unfortunately, the
  * mid-layer does not properly handle this scsi malloc failures for the S/G
  * array and the result can be a lockup of the I/O subsystem.  We try to size
@@ -848,6 +753,165 @@ ahd_linux_size_nseg(void)
 #endif
 }
 
+/************************** Error Recovery ************************************/
+static int ahd_linux_recovery_thread(void *arg);
+
+static int
+ahd_linux_recovery_thread(void *arg)
+{
+	struct ahd_softc *ahd;
+	u_long s;
+
+	ahd = (struct ahd_softc *)arg;
+
+	/*
+	 * Complete thread creation.
+	 */
+	lock_kernel();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,60)
+	/*
+	 * Don't care about any signals.
+	 */
+	siginitsetinv(&current->blocked, 0);
+
+	daemonize();
+	sprintf(current->comm, "ahd_recovery_%d", ahd->unit);
+#else
+	daemonize("ahd_recovery_%d", ahd->unit);
+#endif
+	unlock_kernel();
+
+	while (1) {
+
+		/*
+		 * Use down_interruptible() rather than down() to
+		 * avoid inclusion in the load average.
+		 */
+		down_interruptible(&ahd->platform_data->recovery_sem);
+
+		ahd_lock(ahd, &s);
+		if ((ahd->flags & AHD_SHUTDOWN_RECOVERY) != 0) {
+			ahd_unlock(ahd, &s);
+			break;
+		}
+
+		/*
+		 * Don't bother the recovery handler if the
+		 * list has been cleared by a previous run
+		 * of the handler.  This can happen when
+		 * several SCBs timeout before our handler
+		 * can run causing our semaphore to be up'ed
+		 * repeatedly.  The extra calls need to be
+		 * avoided so that the recovery handler doesn't
+		 * confuse this case with timeouts occuring
+		 * due to interrupts failing to function.
+		 */
+		if (LIST_EMPTY(&ahd->timedout_scbs) != 0) {
+			ahd_unlock(ahd, &s);
+			continue;
+		}
+
+		ahd_unlock(ahd, &s);
+		ahd_recover_commands(ahd);
+
+		/*
+		 * Process any pent up completions.
+		 */
+		ahd_lock(ahd, &s);
+		aic_schedule_runq(ahd);
+		ahd_linux_run_complete_queue(ahd);
+		ahd_unlock(ahd, &s);
+	}
+	up(&ahd->platform_data->recovery_ending_sem);
+	return(0);
+}
+
+int
+ahd_spawn_recovery_thread(struct ahd_softc *ahd)
+{
+	ahd->platform_data->recovery_pid =
+	    kernel_thread(ahd_linux_recovery_thread, ahd, 0);
+	
+	if (ahd->platform_data->recovery_pid < 0)
+		return (-ahd->platform_data->recovery_pid);
+
+	return (0);
+}
+
+void
+ahd_terminate_recovery_thread(struct ahd_softc *ahd)
+{
+	u_long s;
+
+	ahd_lock(ahd, &s);
+	if (ahd->platform_data->recovery_pid != 0) {
+		ahd->flags |= AHD_SHUTDOWN_RECOVERY;
+		ahd_unlock(ahd, &s);
+		up(&ahd->platform_data->recovery_sem);
+
+		/*
+		 * Use the recovery_ending_sem as an indicator that
+		 * the dv thread is exiting.  Note that the dv
+		 * thread must still return after performing
+		 * the up on our semaphore before it has
+		 * completely exited this module.  Unfortunately,
+		 * there seems to be no easy way to wait for the
+		 * exit of a thread for which you are not the
+		 * parent (dv threads are parented by init).
+		 * Cross your fingers...
+		 */
+		down(&ahd->platform_data->recovery_ending_sem);
+
+		/*
+		 * Mark the recovery thread as already dead.  This
+		 * avoids attempting to kill it a second time.
+		 * This is necessary because we must kill the
+		 * our threads before calling ahd_free() in the
+		 * module shutdown case to avoid bogus locking
+		 * in the SCSI mid-layer, but when ahd_free() is
+		 * called without killing the DV thread in the
+		 * instance detach case, so ahd_platform_free()
+		 * calls us again to verify that the DV thread
+		 * is dead.
+		 */
+		ahd->platform_data->recovery_pid = 0;
+	} else {
+		ahd_unlock(ahd, &s);
+	}
+}
+
+void
+ahd_set_recoveryscb(struct ahd_softc *ahd, struct scb *scb)
+{
+	if ((scb->flags & SCB_RECOVERY_SCB) == 0) {
+		struct scb *list_scb;
+
+		scb->flags |= SCB_RECOVERY_SCB;
+
+		/*
+		 * Take all queued, but not sent SCBs out of the equation.
+		 * Also ensure that no new commands are queued to us while we
+		 * try to fix this problem.
+		 */
+		if ((scb->platform_data->flags & AIC_RELEASE_SIMQ) == 0) {
+			aic_freeze_simq(ahd);
+			scb->platform_data->flags |= AIC_RELEASE_SIMQ;
+		}
+
+		/*
+		 * Go through all of our pending SCBs and remove
+		 * any scheduled timeouts for them.  We will reschedule
+		 * them after we've successfully fixed this problem.
+		 */
+		LIST_FOREACH(list_scb, &ahd->pending_scbs, pending_links) {
+
+			scsi_delete_timer(list_scb->io_ctx);
+			list_scb->platform_data->flags &= ~AIC_TIMEOUT_ACTIVE;
+		}
+	}
+}
+
+/********************** Host Template Entry Points ****************************/
 /*
  * Try to detect an Adaptec 79XX controller.
  */
@@ -864,17 +928,19 @@ ahd_linux_detect(Scsi_Host_Template *tem
 	 */
 	spin_unlock_irq(&io_request_lock);
 #endif
+	found = 0;
 
 	/*
 	 * Sanity checking of Linux SCSI data structures so
 	 * that some of our hacks^H^H^H^H^Hassumptions aren't
 	 * violated.
 	 */
-	if (offsetof(struct ahd_cmd_internal, end)
+	if (offsetof(struct aic_cmd_internal, end)
 	  > offsetof(struct scsi_cmnd, host_scribble)) {
 		printf("ahd_linux_detect: SCSI data structures changed.\n");
 		printf("ahd_linux_detect: Unable to attach\n");
-		return (0);
+		ahd_init_status = -EINVAL;
+		goto done;
 	}
 	/*
 	 * Determine an appropriate size for our Scatter Gatther lists.
@@ -894,11 +960,7 @@ ahd_linux_detect(Scsi_Host_Template *tem
 "aic79xx: insmod or else it might trash certain memory areas.\n");
 #endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
 	template->proc_name = "aic79xx";
-#else
-	template->proc_dir = &proc_scsi_aic79xx;
-#endif
 
 	/*
 	 * Initialize our softc list lock prior to
@@ -907,7 +969,9 @@ ahd_linux_detect(Scsi_Host_Template *tem
 	ahd_list_lockinit();
 
 #ifdef CONFIG_PCI
-	ahd_linux_pci_init();
+	ahd_init_status = ahd_linux_pci_init();
+	if (ahd_init_status != 0)
+		goto done;
 #endif
 
 	/*
@@ -920,6 +984,7 @@ ahd_linux_detect(Scsi_Host_Template *tem
 		if (ahd_linux_register_host(ahd, template) == 0)
 			found++;
 	}
+done:
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 	spin_lock_irq(&io_request_lock);
 #endif
@@ -938,7 +1003,6 @@ ahd_linux_release(struct Scsi_Host * hos
 	struct ahd_softc *ahd;
 	u_long l;
 
-	ahd_list_lock(&l);
 	if (host != NULL) {
 
 		/*
@@ -946,17 +1010,20 @@ ahd_linux_release(struct Scsi_Host * hos
 		 * the free directly, but check our
 		 * list for extra sanity.
 		 */
+		ahd_list_lock(&l);
 		ahd = ahd_find_softc(*(struct ahd_softc **)host->hostdata);
 		if (ahd != NULL) {
 			u_long s;
 
+			TAILQ_REMOVE(&ahd_tailq, ahd, links);
+			ahd_list_unlock(&l);
 			ahd_lock(ahd, &s);
 			ahd_intr_enable(ahd, FALSE);
 			ahd_unlock(ahd, &s);
 			ahd_free(ahd);
-		}
+		} else
+			ahd_list_unlock(&l);
 	}
-	ahd_list_unlock(&l);
 	return (0);
 }
 #endif
@@ -996,7 +1063,7 @@ static int
 ahd_linux_queue(Scsi_Cmnd * cmd, void (*scsi_done) (Scsi_Cmnd *))
 {
 	struct	 ahd_softc *ahd;
-	struct	 ahd_linux_device *dev;
+	struct	 aic_linux_device *dev;
 	u_long	 flags;
 
 	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
@@ -1006,7 +1073,7 @@ ahd_linux_queue(Scsi_Cmnd * cmd, void (*
 	 */
 	cmd->scsi_done = scsi_done;
 
-	ahd_midlayer_entrypoint_lock(ahd, &flags);
+	ahd_entrypoint_lock(ahd, &flags);
 
 	/*
 	 * Close the race of a command that was in the process of
@@ -1015,36 +1082,64 @@ ahd_linux_queue(Scsi_Cmnd * cmd, void (*
 	 * perform DV.
 	 */
 	if (ahd->platform_data->qfrozen != 0
-	 && AHD_DV_CMD(cmd) == 0) {
+	 && AIC_DV_CMD(cmd) == 0) {
 
-		ahd_cmd_set_transaction_status(cmd, CAM_REQUEUE_REQ);
+		aic_cmd_set_transaction_status(cmd, CAM_REQUEUE_REQ);
 		ahd_linux_queue_cmd_complete(ahd, cmd);
 		ahd_schedule_completeq(ahd);
-		ahd_midlayer_entrypoint_unlock(ahd, &flags);
+		ahd_entrypoint_unlock(ahd, &flags);
 		return (0);
 	}
 	dev = ahd_linux_get_device(ahd, cmd->device->channel,
 				   cmd->device->id, cmd->device->lun,
 				   /*alloc*/TRUE);
 	if (dev == NULL) {
-		ahd_cmd_set_transaction_status(cmd, CAM_RESRC_UNAVAIL);
+
+		aic_cmd_set_transaction_status(cmd, CAM_RESRC_UNAVAIL);
 		ahd_linux_queue_cmd_complete(ahd, cmd);
 		ahd_schedule_completeq(ahd);
-		ahd_midlayer_entrypoint_unlock(ahd, &flags);
+		ahd_entrypoint_unlock(ahd, &flags);
 		printf("%s: aic79xx_linux_queue - Unable to allocate device!\n",
 		       ahd_name(ahd));
 		return (0);
+	} else if ((dev->flags & AIC_DEV_UNCONFIGURED) != 0
+		&& cmd->device->type != -1) {
+		/*
+		 * Configure devices that have already successfully
+		 * completed an inquiry. This  handles the case of
+		 * devices being destroyed due to transient selection
+		 * timeouts.
+		 */
+		dev->flags &= ~AIC_DEV_UNCONFIGURED;
+	 	dev->scsi_device = cmd->device;
+		aic_linux_device_queue_depth(ahd, dev);
 	}
-	if (cmd->cmd_len > MAX_CDB_LEN)
-		return (-EINVAL);
+
+	if (cmd->cmd_len > MAX_CDB_LEN) {
+
+		aic_cmd_set_transaction_status(cmd, CAM_REQ_INVALID);
+		ahd_linux_queue_cmd_complete(ahd, cmd);
+		ahd_schedule_completeq(ahd);
+		ahd_entrypoint_unlock(ahd, &flags);
+		printf("%s: aic79xx_linux_queue -"
+		       "CDB length of %d exceeds max!\n",
+		       ahd_name(ahd), cmd->cmd_len);
+		return (0);
+	}
+
+	/*
+	 * We perform our own timeout handling.
+	 */
+	scsi_delete_timer(cmd);
+
 	cmd->result = CAM_REQ_INPROG << 16;
-	TAILQ_INSERT_TAIL(&dev->busyq, (struct ahd_cmd *)cmd, acmd_links.tqe);
-	if ((dev->flags & AHD_DEV_ON_RUN_LIST) == 0) {
+	TAILQ_INSERT_TAIL(&dev->busyq, (struct aic_cmd *)cmd, acmd_links.tqe);
+	if ((dev->flags & AIC_DEV_ON_RUN_LIST) == 0) {
 		TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq, dev, links);
-		dev->flags |= AHD_DEV_ON_RUN_LIST;
-		ahd_linux_run_device_queues(ahd);
+		dev->flags |= AIC_DEV_ON_RUN_LIST;
+		aic_linux_run_device_queues(ahd);
 	}
-	ahd_midlayer_entrypoint_unlock(ahd, &flags);
+	ahd_entrypoint_unlock(ahd, &flags);
 	return (0);
 }
 
@@ -1064,13 +1159,13 @@ static int
 ahd_linux_slave_configure(Scsi_Device *device)
 {
 	struct	ahd_softc *ahd;
-	struct	ahd_linux_device *dev;
+	struct	aic_linux_device *dev;
 	u_long	flags;
 
 	ahd = *((struct ahd_softc **)device->host->hostdata);
 	if (bootverbose)
 		printf("%s: Slave Configure %d\n", ahd_name(ahd), device->id);
-	ahd_midlayer_entrypoint_lock(ahd, &flags);
+	ahd_entrypoint_lock(ahd, &flags);
 	/*
 	 * Since Linux has attached to the device, configure
 	 * it so we don't free and allocate the device
@@ -1080,12 +1175,12 @@ ahd_linux_slave_configure(Scsi_Device *d
 				   device->id, device->lun,
 				   /*alloc*/TRUE);
 	if (dev != NULL) {
-		dev->flags &= ~AHD_DEV_UNCONFIGURED;
-		dev->flags |= AHD_DEV_SLAVE_CONFIGURED;
+		dev->flags &= ~AIC_DEV_UNCONFIGURED;
+		dev->flags |= AIC_DEV_SLAVE_CONFIGURED;
 		dev->scsi_device = device;
-		ahd_linux_device_queue_depth(ahd, dev);
+		aic_linux_device_queue_depth(ahd, dev);
 	}
-	ahd_midlayer_entrypoint_unlock(ahd, &flags);
+	ahd_entrypoint_unlock(ahd, &flags);
 	return (0);
 }
 
@@ -1093,13 +1188,13 @@ static void
 ahd_linux_slave_destroy(Scsi_Device *device)
 {
 	struct	ahd_softc *ahd;
-	struct	ahd_linux_device *dev;
+	struct	aic_linux_device *dev;
 	u_long	flags;
 
 	ahd = *((struct ahd_softc **)device->host->hostdata);
 	if (bootverbose)
 		printf("%s: Slave Destroy %d\n", ahd_name(ahd), device->id);
-	ahd_midlayer_entrypoint_lock(ahd, &flags);
+	ahd_entrypoint_lock(ahd, &flags);
 	dev = ahd_linux_get_device(ahd, device->channel,
 				   device->id, device->lun,
 					   /*alloc*/FALSE);
@@ -1112,14 +1207,13 @@ ahd_linux_slave_destroy(Scsi_Device *dev
 	 * the refcounting process.
 	 */
 	if (dev != NULL
-	 && (dev->flags & AHD_DEV_SLAVE_CONFIGURED) != 0) {
-		dev->flags |= AHD_DEV_UNCONFIGURED;
+	 && (dev->flags & AIC_DEV_SLAVE_CONFIGURED) != 0) {
+		dev->flags |= AIC_DEV_UNCONFIGURED;
 		if (TAILQ_EMPTY(&dev->busyq)
-		 && dev->active == 0
-		 && (dev->flags & AHD_DEV_TIMER_ACTIVE) == 0)
+		 && dev->active == 0)
 			ahd_linux_free_device(ahd, dev);
 	}
-	ahd_midlayer_entrypoint_unlock(ahd, &flags);
+	ahd_entrypoint_unlock(ahd, &flags);
 }
 #else
 /*
@@ -1156,7 +1250,7 @@ ahd_linux_select_queue_depth(struct Scsi
 			continue;
 
 		if (device->host == host) {
-			struct	 ahd_linux_device *dev;
+			struct	 aic_linux_device *dev;
 
 			/*
 			 * Since Linux has attached to the device, configure
@@ -1167,13 +1261,13 @@ ahd_linux_select_queue_depth(struct Scsi
 						   device->id, device->lun,
 						   /*alloc*/TRUE);
 			if (dev != NULL) {
-				dev->flags &= ~AHD_DEV_UNCONFIGURED;
+				dev->flags &= ~AIC_DEV_UNCONFIGURED;
 				dev->scsi_device = device;
-				ahd_linux_device_queue_depth(ahd, dev);
+				aic_linux_device_queue_depth(ahd, dev);
 				device->queue_depth = dev->openings
 						    + dev->active;
-				if ((dev->flags & (AHD_DEV_Q_BASIC
-						| AHD_DEV_Q_TAGGED)) == 0) {
+				if ((dev->flags & (AIC_DEV_Q_BASIC
+						| AIC_DEV_Q_TAGGED)) == 0) {
 					/*
 					 * We allow the OS to queue 2 untagged
 					 * transactions to us at any time even
@@ -1262,9 +1356,9 @@ static int
 ahd_linux_abort(Scsi_Cmnd *cmd)
 {
 	struct ahd_softc *ahd;
-	struct ahd_cmd *acmd;
-	struct ahd_cmd *list_acmd;
-	struct ahd_linux_device *dev;
+	struct aic_cmd *acmd;
+	struct aic_cmd *list_acmd;
+	struct aic_linux_device *dev;
 	struct scb *pending_scb;
 	u_long s;
 	u_int  saved_scbptr;
@@ -1282,7 +1376,7 @@ ahd_linux_abort(Scsi_Cmnd *cmd)
 	paused = FALSE;
 	wait = FALSE;
 	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
-	acmd = (struct ahd_cmd *)cmd;
+	acmd = (struct aic_cmd *)cmd;
 
 	printf("%s:%d:%d:%d: Attempting to abort cmd %p:",
 	       ahd_name(ahd), cmd->device->channel, cmd->device->id,
@@ -1305,7 +1399,7 @@ ahd_linux_abort(Scsi_Cmnd *cmd)
 	 * by acquiring either the io_request_lock or our own
 	 * lock, this *should* be safe.
 	 */
-	ahd_midlayer_entrypoint_lock(ahd, &s);
+	ahd_entrypoint_lock(ahd, &s);
 
 	/*
 	 * First determine if we currently own this command.
@@ -1341,6 +1435,17 @@ ahd_linux_abort(Scsi_Cmnd *cmd)
 		       cmd->device->lun);
 		TAILQ_REMOVE(&dev->busyq, list_acmd, acmd_links.tqe);
 		cmd->result = DID_ABORT << 16;
+		/*
+		 * The completion handler believes that
+		 * commands without active timers running
+		 * have lost the race of completing before
+		 * their timer expires.  Since commands in
+		 * our busy queues do not have timers running,
+		 * appease the mid-layer by adding a timer
+		 * now.  This timer will be immediately
+		 * canceled by the midlayer.
+		 */
+		scsi_add_timer(cmd, 60*HZ, aic_linux_midlayer_timeout);
 		ahd_linux_queue_cmd_complete(ahd, cmd);
 		retval = SUCCESS;
 		goto done;
@@ -1516,7 +1621,7 @@ done:
 		struct timer_list timer;
 		int ret;
 
-		pending_scb->platform_data->flags |= AHD_SCB_UP_EH_SEM;
+		pending_scb->platform_data->flags |= AIC_SCB_UP_EH_SEM;
 		spin_unlock_irq(&ahd->platform_data->spin_lock);
 		init_timer(&timer);
 		timer.data = (u_long)pending_scb;
@@ -1533,9 +1638,9 @@ done:
 		}
 		spin_lock_irq(&ahd->platform_data->spin_lock);
 	}
-	ahd_schedule_runq(ahd);
+	aic_schedule_runq(ahd);
 	ahd_linux_run_complete_queue(ahd);
-	ahd_midlayer_entrypoint_unlock(ahd, &s);
+	ahd_entrypoint_unlock(ahd, &s);
 	return (retval);
 }
 
@@ -1554,7 +1659,7 @@ ahd_linux_dev_reset(Scsi_Cmnd *cmd)
 {
 	struct	ahd_softc *ahd;
 	struct	scsi_cmnd *recovery_cmd;
-	struct	ahd_linux_device *dev;
+	struct	aic_linux_device *dev;
 	struct	ahd_initiator_tinfo *tinfo;
 	struct	ahd_tmode_tstate *tstate;
 	struct	scb *scb;
@@ -1574,16 +1679,16 @@ ahd_linux_dev_reset(Scsi_Cmnd *cmd)
 		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
 		       cmd->device->lun, cmd);
 #endif
-	ahd_midlayer_entrypoint_lock(ahd, &s);
+	ahd_entrypoint_lock(ahd, &s);
 
 	dev = ahd_linux_get_device(ahd, cmd->device->channel, cmd->device->id,
 				   cmd->device->lun, /*alloc*/FALSE);
 	if (dev == NULL) {
-		ahd_midlayer_entrypoint_unlock(ahd, &s);
+		ahd_entrypoint_unlock(ahd, &s);
 		return (FAILED);
 	}
 	if ((scb = ahd_get_scb(ahd, AHD_NEVER_COL_IDX)) == NULL) {
-		ahd_midlayer_entrypoint_unlock(ahd, &s);
+		ahd_entrypoint_unlock(ahd, &s);
 		return (FAILED);
 	}
 	tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
@@ -1592,9 +1697,11 @@ ahd_linux_dev_reset(Scsi_Cmnd *cmd)
 	recovery_cmd->host_scribble = (char *)scb;
 	scb->io_ctx = recovery_cmd;
 	scb->platform_data->dev = dev;
+	scb->platform_data->flags = 0;
 	scb->sg_count = 0;
-	ahd_set_residual(scb, 0);
-	ahd_set_sense_residual(scb, 0);
+	aic_set_residual(scb, 0);
+	aic_set_sense_residual(scb, 0);
+	scb->platform_data->xfer_len = 0;
 	hscb = scb->hscb;
 	hscb->control = 0;
 	hscb->scsiid = BUILD_SCSIID(ahd, cmd);
@@ -1613,7 +1720,7 @@ ahd_linux_dev_reset(Scsi_Cmnd *cmd)
 	LIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);
 	ahd_queue_scb(ahd, scb);
 
-	scb->platform_data->flags |= AHD_SCB_UP_EH_SEM;
+	scb->platform_data->flags |= AIC_SCB_UP_EH_SEM;
 	spin_unlock_irq(&ahd->platform_data->spin_lock);
 	init_timer(&timer);
 	timer.data = (u_long)scb;
@@ -1629,9 +1736,9 @@ ahd_linux_dev_reset(Scsi_Cmnd *cmd)
 		retval = FAILED;
 	}
 	spin_lock_irq(&ahd->platform_data->spin_lock);
-	ahd_schedule_runq(ahd);
+	aic_schedule_runq(ahd);
 	ahd_linux_run_complete_queue(ahd);
-	ahd_midlayer_entrypoint_unlock(ahd, &s);
+	ahd_entrypoint_unlock(ahd, &s);
 	printf("%s: Device reset returning 0x%x\n", ahd_name(ahd), retval);
 	return (retval);
 }
@@ -1652,11 +1759,11 @@ ahd_linux_bus_reset(Scsi_Cmnd *cmd)
 		printf("%s: Bus reset called for cmd %p\n",
 		       ahd_name(ahd), cmd);
 #endif
-	ahd_midlayer_entrypoint_lock(ahd, &s);
+	ahd_entrypoint_lock(ahd, &s);
 	found = ahd_reset_channel(ahd, cmd->device->channel + 'A',
 				  /*initiate reset*/TRUE);
 	ahd_linux_run_complete_queue(ahd);
-	ahd_midlayer_entrypoint_unlock(ahd, &s);
+	ahd_entrypoint_unlock(ahd, &s);
 
 	if (bootverbose)
 		printf("%s: SCSI bus reset delivered. "
@@ -1665,195 +1772,8 @@ ahd_linux_bus_reset(Scsi_Cmnd *cmd)
 	return (SUCCESS);
 }
 
-Scsi_Host_Template aic79xx_driver_template = {
-	.module			= THIS_MODULE,
-	.name			= "aic79xx",
-	.proc_info		= ahd_linux_proc_info,
-	.info			= ahd_linux_info,
-	.queuecommand		= ahd_linux_queue,
-	.eh_abort_handler	= ahd_linux_abort,
-	.eh_device_reset_handler = ahd_linux_dev_reset,
-	.eh_bus_reset_handler	= ahd_linux_bus_reset,
-#if defined(__i386__)
-	.bios_param		= ahd_linux_biosparam,
-#endif
-	.can_queue		= AHD_MAX_QUEUE,
-	.this_id		= -1,
-	.cmd_per_lun		= 2,
-	.use_clustering		= ENABLE_CLUSTERING,
-	.slave_alloc		= ahd_linux_slave_alloc,
-	.slave_configure	= ahd_linux_slave_configure,
-	.slave_destroy		= ahd_linux_slave_destroy,
-};
-
-/**************************** Tasklet Handler *********************************/
-
-/*
- * In 2.4.X and above, this routine is called from a tasklet,
- * so we must re-acquire our lock prior to executing this code.
- * In all prior kernels, ahd_schedule_runq() calls this routine
- * directly and ahd_schedule_runq() is called with our lock held.
- */
-static void
-ahd_runq_tasklet(unsigned long data)
-{
-	struct ahd_softc* ahd;
-	struct ahd_linux_device *dev;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	u_long flags;
-#endif
-
-	ahd = (struct ahd_softc *)data;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	ahd_lock(ahd, &flags);
-#endif
-	while ((dev = ahd_linux_next_device_to_run(ahd)) != NULL) {
-	
-		TAILQ_REMOVE(&ahd->platform_data->device_runq, dev, links);
-		dev->flags &= ~AHD_DEV_ON_RUN_LIST;
-		ahd_linux_check_device_queue(ahd, dev);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		/* Yeild to our interrupt handler */
-		ahd_unlock(ahd, &flags);
-		ahd_lock(ahd, &flags);
-#endif
-	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	ahd_unlock(ahd, &flags);
-#endif
-}
-
-/******************************** Bus DMA *************************************/
-int
-ahd_dma_tag_create(struct ahd_softc *ahd, bus_dma_tag_t parent,
-		   bus_size_t alignment, bus_size_t boundary,
-		   bus_addr_t lowaddr, bus_addr_t highaddr,
-		   bus_dma_filter_t *filter, void *filterarg,
-		   bus_size_t maxsize, int nsegments,
-		   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)
-{
-	bus_dma_tag_t dmat;
-
-	dmat = malloc(sizeof(*dmat), M_DEVBUF, M_NOWAIT);
-	if (dmat == NULL)
-		return (ENOMEM);
-
-	/*
-	 * Linux is very simplistic about DMA memory.  For now don't
-	 * maintain all specification information.  Once Linux supplies
-	 * better facilities for doing these operations, or the
-	 * needs of this particular driver change, we might need to do
-	 * more here.
-	 */
-	dmat->alignment = alignment;
-	dmat->boundary = boundary;
-	dmat->maxsize = maxsize;
-	*ret_tag = dmat;
-	return (0);
-}
-
-void
-ahd_dma_tag_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat)
-{
-	free(dmat, M_DEVBUF);
-}
-
-int
-ahd_dmamem_alloc(struct ahd_softc *ahd, bus_dma_tag_t dmat, void** vaddr,
-		 int flags, bus_dmamap_t *mapp)
-{
-	bus_dmamap_t map;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT);
-	if (map == NULL)
-		return (ENOMEM);
-	/*
-	 * Although we can dma data above 4GB, our
-	 * "consistent" memory is below 4GB for
-	 * space efficiency reasons (only need a 4byte
-	 * address).  For this reason, we have to reset
-	 * our dma mask when doing allocations.
-	 */
-	if (ahd->dev_softc != NULL)
-		if (ahd_pci_set_dma_mask(ahd->dev_softc, 0xFFFFFFFF)) {
-			printk(KERN_WARNING "aic79xx: No suitable DMA available.\n");
-			return (ENODEV);
-		}
-	*vaddr = pci_alloc_consistent(ahd->dev_softc,
-				      dmat->maxsize, &map->bus_addr);
-	if (ahd->dev_softc != NULL)
-		if (ahd_pci_set_dma_mask(ahd->dev_softc,
-				     ahd->platform_data->hw_dma_mask)) {
-			printk(KERN_WARNING "aic79xx: No suitable DMA available.\n");
-			return (ENODEV);
-		}
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
-	/*
-	 * At least in 2.2.14, malloc is a slab allocator so all
-	 * allocations are aligned.  We assume for these kernel versions
-	 * that all allocations will be bellow 4Gig, physically contiguous,
-	 * and accessible via DMA by the controller.
-	 */
-	map = NULL; /* No additional information to store */
-	*vaddr = malloc(dmat->maxsize, M_DEVBUF, M_NOWAIT);
-#endif
-	if (*vaddr == NULL)
-		return (ENOMEM);
-	*mapp = map;
-	return(0);
-}
-
-void
-ahd_dmamem_free(struct ahd_softc *ahd, bus_dma_tag_t dmat,
-		void* vaddr, bus_dmamap_t map)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	pci_free_consistent(ahd->dev_softc, dmat->maxsize,
-			    vaddr, map->bus_addr);
-#else
-	free(vaddr, M_DEVBUF);
-#endif
-}
-
-int
-ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map,
-		void *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,
-		void *cb_arg, int flags)
-{
-	/*
-	 * Assume for now that this will only be used during
-	 * initialization and not for per-transaction buffer mapping.
-	 */
-	bus_dma_segment_t stack_sg;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	stack_sg.ds_addr = map->bus_addr;
-#else
-#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
-	stack_sg.ds_addr = VIRT_TO_BUS(buf);
-#endif
-	stack_sg.ds_len = dmat->maxsize;
-	cb(cb_arg, &stack_sg, /*nseg*/1, /*error*/0);
-	return (0);
-}
-
-void
-ahd_dmamap_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
-{
-	/*
-	 * The map may is NULL in our < 2.3.X implementation.
-	 */
-	if (map != NULL)
-		free(map, M_DEVBUF);
-}
-
-int
-ahd_dmamap_unload(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
-{
-	/* Nothing to do */
-	return (0);
-}
+Scsi_Host_Template aic79xx_driver_template = 
+	AIC_TEMPLATE_INITIALIZER("aic79xx", /*max_sectors*/8192);
 
 /********************* Platform Dependent Functions ***************************/
 /*
@@ -1889,19 +1809,19 @@ ahd_softc_comp(struct ahd_softc *lahd, s
 
 	/* Still equal.  Sort by bus/slot/func. */
 	if (aic79xx_reverse_scan != 0)
-		value = ahd_get_pci_bus(lahd->dev_softc)
-		      - ahd_get_pci_bus(rahd->dev_softc);
+		value = aic_get_pci_bus(lahd->dev_softc)
+		      - aic_get_pci_bus(rahd->dev_softc);
 	else
-		value = ahd_get_pci_bus(rahd->dev_softc)
-		      - ahd_get_pci_bus(lahd->dev_softc);
+		value = aic_get_pci_bus(rahd->dev_softc)
+		      - aic_get_pci_bus(lahd->dev_softc);
 	if (value != 0)
 		return (value);
 	if (aic79xx_reverse_scan != 0)
-		value = ahd_get_pci_slot(lahd->dev_softc)
-		      - ahd_get_pci_slot(rahd->dev_softc);
+		value = aic_get_pci_slot(lahd->dev_softc)
+		      - aic_get_pci_slot(rahd->dev_softc);
 	else
-		value = ahd_get_pci_slot(rahd->dev_softc)
-		      - ahd_get_pci_slot(lahd->dev_softc);
+		value = aic_get_pci_slot(rahd->dev_softc)
+		      - aic_get_pci_slot(lahd->dev_softc);
 	if (value != 0)
 		return (value);
 
@@ -1993,6 +1913,7 @@ aic79xx_setup(char *s)
 		{ "extended", &aic79xx_extended },
 		{ "no_reset", &aic79xx_no_reset },
 		{ "verbose", &aic79xx_verbose },
+		{ "attach_HostRAID", &ahd_attach_to_HostRAID_controllers },
 		{ "allow_memio", &aic79xx_allow_memio},
 #ifdef AHD_DEBUG
 		{ "debug", &ahd_debug },
@@ -2064,9 +1985,7 @@ aic79xx_setup(char *s)
 	return 1;
 }
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
 __setup("aic79xx=", aic79xx_setup);
-#endif
 
 uint32_t aic79xx_verbose;
 
@@ -2078,20 +1997,23 @@ ahd_linux_register_host(struct ahd_softc
 	char	*new_name;
 	u_long	s;
 	u_long	target;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	int	error;
+#endif
 
 	template->name = ahd->description;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	host = scsi_host_alloc(template, sizeof(struct ahd_softc *));
+#else
+	host = scsi_register(template, sizeof(struct ahd_softc *));
+#endif
 	if (host == NULL)
 		return (ENOMEM);
 
 	*((struct ahd_softc **)host->hostdata) = ahd;
 	ahd_lock(ahd, &s);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	scsi_assign_lock(host, &ahd->platform_data->spin_lock);
-#elif AHD_SCSI_HAS_HOST_LOCK != 0
-	host->lock = &ahd->platform_data->spin_lock;
-#endif
 	ahd->platform_data->host = host;
+	aic_assign_host_lock(ahd);
 	host->can_queue = AHD_MAX_QUEUE;
 	host->cmd_per_lun = 2;
 	host->sg_tablesize = AHD_NSEG;
@@ -2116,13 +2038,19 @@ ahd_linux_register_host(struct ahd_softc
 	ahd_linux_setup_user_rd_strm_settings(ahd);
 	ahd_linux_initialize_scsi_bus(ahd);
 	ahd_unlock(ahd, &s);
+	ahd_spawn_recovery_thread(ahd);
+	if (ahd->platform_data->recovery_pid < 0) {
+		printf("%s: Failed to create recovery thread, error= %d\n",
+		       ahd_name(ahd), ahd->platform_data->recovery_pid);
+		return (-ahd->platform_data->recovery_pid);
+	}
 	ahd->platform_data->dv_pid = kernel_thread(ahd_linux_dv_thread, ahd, 0);
-	ahd_lock(ahd, &s);
 	if (ahd->platform_data->dv_pid < 0) {
 		printf("%s: Failed to create DV thread, error= %d\n",
 		       ahd_name(ahd), ahd->platform_data->dv_pid);
 		return (-ahd->platform_data->dv_pid);
 	}
+	ahd_lock(ahd, &s);
 	/*
 	 * Initially allocate *all* of our linux target objects
 	 * so that the DV thread will scan them all in parallel
@@ -2142,7 +2070,7 @@ ahd_linux_register_host(struct ahd_softc
 		 * It is expected that either an external application
 		 * or a modified kernel will be used to probe this
 		 * ID if it is appropriate.  To accommodate these
-		 * installations, ahc_linux_alloc_target() will allocate
+		 * installations, ahd_linux_alloc_target() will allocate
 		 * for our ID if asked to do so.
 		 */
 		if (target == ahd->our_id) 
@@ -2155,7 +2083,9 @@ ahd_linux_register_host(struct ahd_softc
 	ahd_unlock(ahd, &s);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	scsi_add_host(host, &ahd->dev_softc->dev); /* XXX handle failure */
+	error = scsi_add_host(host, ahd->dev_softc);
+	if (error != 0)
+		return (-error);
 	scsi_scan_host(host);
 #endif
 	return (0);
@@ -2231,17 +2161,6 @@ ahd_linux_initialize_scsi_bus(struct ahd
 		ahd_update_neg_request(ahd, &devinfo, tstate,
 				       tinfo, AHD_NEG_ALWAYS);
 	}
-	/* Give the bus some time to recover */
-	if ((ahd->flags & AHD_RESET_BUS_A) != 0) {
-		ahd_freeze_simq(ahd);
-		init_timer(&ahd->platform_data->reset_timer);
-		ahd->platform_data->reset_timer.data = (u_long)ahd;
-		ahd->platform_data->reset_timer.expires =
-		    jiffies + (AIC79XX_RESET_DELAY * HZ)/1000;
-		ahd->platform_data->reset_timer.function =
-		    (ahd_linux_callback_t *)ahd_release_simq;
-		add_timer(&ahd->platform_data->reset_timer);
-	}
 }
 
 int
@@ -2254,24 +2173,23 @@ ahd_platform_alloc(struct ahd_softc *ahd
 	memset(ahd->platform_data, 0, sizeof(struct ahd_platform_data));
 	TAILQ_INIT(&ahd->platform_data->completeq);
 	TAILQ_INIT(&ahd->platform_data->device_runq);
-	ahd->platform_data->irq = AHD_LINUX_NOIRQ;
+	ahd->platform_data->irq = AIC_LINUX_NOIRQ;
 	ahd->platform_data->hw_dma_mask = 0xFFFFFFFF;
 	ahd_lockinit(ahd);
-	ahd_done_lockinit(ahd);
+	init_timer(&ahd->platform_data->bus_settle_timer);
+	ahd->platform_data->bus_settle_timer.data = (u_long)ahd;
+	ahd->platform_data->bus_settle_timer.function =
+	    (aic_linux_callback_t *)aic_bus_settle_complete;
 	init_timer(&ahd->platform_data->completeq_timer);
 	ahd->platform_data->completeq_timer.data = (u_long)ahd;
 	ahd->platform_data->completeq_timer.function =
-	    (ahd_linux_callback_t *)ahd_linux_thread_run_complete_queue;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	    (aic_linux_callback_t *)ahd_linux_thread_run_complete_queue;
 	init_MUTEX_LOCKED(&ahd->platform_data->eh_sem);
 	init_MUTEX_LOCKED(&ahd->platform_data->dv_sem);
 	init_MUTEX_LOCKED(&ahd->platform_data->dv_cmd_sem);
-#else
-	ahd->platform_data->eh_sem = MUTEX_LOCKED;
-	ahd->platform_data->dv_sem = MUTEX_LOCKED;
-	ahd->platform_data->dv_cmd_sem = MUTEX_LOCKED;
-#endif
-	ahd_setup_runq_tasklet(ahd);
+	init_MUTEX_LOCKED(&ahd->platform_data->recovery_sem);
+	init_MUTEX_LOCKED(&ahd->platform_data->recovery_ending_sem);
+	aic_setup_tasklets(ahd);
 	ahd->seltime = (aic79xx_seltime & 0x3) << 4;
 	return (0);
 }
@@ -2279,32 +2197,47 @@ ahd_platform_alloc(struct ahd_softc *ahd
 void
 ahd_platform_free(struct ahd_softc *ahd)
 {
-	struct ahd_linux_target *targ;
-	struct ahd_linux_device *dev;
+	struct aic_linux_target *targ;
+	struct aic_linux_device *dev;
 	int i, j;
 
 	if (ahd->platform_data != NULL) {
 		del_timer_sync(&ahd->platform_data->completeq_timer);
 		ahd_linux_kill_dv_thread(ahd);
-		ahd_teardown_runq_tasklet(ahd);
+		aic_teardown_tasklets(ahd);
 		if (ahd->platform_data->host != NULL) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 			scsi_remove_host(ahd->platform_data->host);
-#endif
 			scsi_host_put(ahd->platform_data->host);
+#else
+			scsi_unregister(ahd->platform_data->host);
+#endif
 		}
 
 		/* destroy all of the device and target objects */
 		for (i = 0; i < AHD_NUM_TARGETS; i++) {
 			targ = ahd->platform_data->targets[i];
 			if (targ != NULL) {
-				/* Keep target around through the loop. */
+
+				/*
+				 * Stop any unfreeze timer from running.
+				 */
+				del_timer_sync(&targ->timer);
+
+				/*
+				 * Keep target around through the loop.
+				 * The timer above may also have held
+				 * a refcount, but since we forcibly
+				 * delete the target, we don't care
+				 * about the extra reference.
+				 */
 				targ->refcount++;
 				for (j = 0; j < AHD_NUM_LUNS; j++) {
 
 					if (targ->devices[j] == NULL)
 						continue;
 					dev = targ->devices[j];
+					del_timer_sync(&dev->timer);
 					ahd_linux_free_device(ahd, dev);
 				}
 				/*
@@ -2315,7 +2248,7 @@ ahd_platform_free(struct ahd_softc *ahd)
 			}
 		}
 
-		if (ahd->platform_data->irq != AHD_LINUX_NOIRQ)
+		if (ahd->platform_data->irq != AIC_LINUX_NOIRQ)
 			free_irq(ahd->platform_data->irq, ahd);
 		if (ahd->tags[0] == BUS_SPACE_PIO
 		 && ahd->bshs[0].ioport != 0)
@@ -2330,10 +2263,8 @@ ahd_platform_free(struct ahd_softc *ahd)
 			base_addr = (u_long)ahd->bshs[0].maddr;
 			base_addr &= PAGE_MASK;
 			iounmap((void *)base_addr);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 			release_mem_region(ahd->platform_data->mem_busaddr,
 					   0x1000);
-#endif
 		}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0) && \
     LINUX_VERSION_CODE  < KERNEL_VERSION(2,5,0)
@@ -2383,7 +2314,7 @@ void
 ahd_platform_set_tags(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
 		      ahd_queue_alg alg)
 {
-	struct ahd_linux_device *dev;
+	struct aic_linux_device *dev;
 	int was_queuing;
 	int now_queuing;
 
@@ -2392,27 +2323,27 @@ ahd_platform_set_tags(struct ahd_softc *
 				   devinfo->lun, /*alloc*/FALSE);
 	if (dev == NULL)
 		return;
-	was_queuing = dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED);
+	was_queuing = dev->flags & (AIC_DEV_Q_BASIC|AIC_DEV_Q_TAGGED);
 	switch (alg) {
 	default:
 	case AHD_QUEUE_NONE:
 		now_queuing = 0;
 		break; 
 	case AHD_QUEUE_BASIC:
-		now_queuing = AHD_DEV_Q_BASIC;
+		now_queuing = AIC_DEV_Q_BASIC;
 		break;
 	case AHD_QUEUE_TAGGED:
-		now_queuing = AHD_DEV_Q_TAGGED;
+		now_queuing = AIC_DEV_Q_TAGGED;
 		break;
 	}
-	if ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) == 0
+	if ((dev->flags & AIC_DEV_FREEZE_TIL_EMPTY) == 0
 	 && (was_queuing != now_queuing)
 	 && (dev->active != 0)) {
-		dev->flags |= AHD_DEV_FREEZE_TIL_EMPTY;
+		dev->flags |= AIC_DEV_FREEZE_TIL_EMPTY;
 		dev->qfrozen++;
 	}
 
-	dev->flags &= ~(AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED|AHD_DEV_PERIODIC_OTAG);
+	dev->flags &= ~(AIC_DEV_Q_BASIC|AIC_DEV_Q_TAGGED|AIC_DEV_PERIODIC_OTAG);
 	if (now_queuing) {
 		u_int usertags;
 
@@ -2432,11 +2363,11 @@ ahd_platform_set_tags(struct ahd_softc *
 			 */
 			dev->openings = 1;
 		} else if (alg == AHD_QUEUE_TAGGED) {
-			dev->flags |= AHD_DEV_Q_TAGGED;
+			dev->flags |= AIC_DEV_Q_TAGGED;
 			if (aic79xx_periodic_otag != 0)
-				dev->flags |= AHD_DEV_PERIODIC_OTAG;
+				dev->flags |= AIC_DEV_PERIODIC_OTAG;
 		} else
-			dev->flags |= AHD_DEV_Q_BASIC;
+			dev->flags |= AIC_DEV_Q_BASIC;
 	} else {
 		/* We can only have one opening. */
 		dev->maxtags = 0;
@@ -2444,13 +2375,13 @@ ahd_platform_set_tags(struct ahd_softc *
 	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	if (dev->scsi_device != NULL) {
-		switch ((dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED))) {
-		case AHD_DEV_Q_BASIC:
+		switch ((dev->flags & (AIC_DEV_Q_BASIC|AIC_DEV_Q_TAGGED))) {
+		case AIC_DEV_Q_BASIC:
 			scsi_adjust_queue_depth(dev->scsi_device,
 						MSG_SIMPLE_TASK,
 						dev->openings + dev->active);
 			break;
-		case AHD_DEV_Q_TAGGED:
+		case AIC_DEV_Q_TAGGED:
 			scsi_adjust_queue_depth(dev->scsi_device,
 						MSG_ORDERED_TASK,
 						dev->openings + dev->active);
@@ -2503,9 +2434,9 @@ ahd_platform_abort_scbs(struct ahd_softc
 	for (; targ < maxtarg; targ++) {
 
 		for (; clun < maxlun; clun++) {
-			struct ahd_linux_device *dev;
-			struct ahd_busyq *busyq;
-			struct ahd_cmd *acmd;
+			struct aic_linux_device *dev;
+			struct aic_busyq *busyq;
+			struct aic_cmd *acmd;
 
 			dev = ahd_linux_get_device(ahd, /*chan*/0, targ,
 						   clun, /*alloc*/FALSE);
@@ -2521,6 +2452,18 @@ ahd_platform_abort_scbs(struct ahd_softc
 					     acmd_links.tqe);
 				count++;
 				cmd->result = status << 16;
+				/*
+				 * The completion handler believes that
+				 * commands without active timers running
+				 * have lost the race of completing before
+				 * their timer expires.  Since commands in
+				 * our busy queues do not have timers running,
+				 * appease the mid-layer by adding a timer
+				 * now.  This timer will be immediately
+				 * canceled by the midlayer.
+				 */
+				scsi_add_timer(cmd, 60*HZ,
+					       aic_linux_midlayer_timeout);
 				ahd_linux_queue_cmd_complete(ahd, cmd);
 			}
 		}
@@ -2536,7 +2479,7 @@ ahd_linux_thread_run_complete_queue(stru
 
 	ahd_lock(ahd, &flags);
 	del_timer(&ahd->platform_data->completeq_timer);
-	ahd->platform_data->flags &= ~AHD_RUN_CMPLT_Q_TIMER;
+	ahd->platform_data->flags &= ~AIC_RUN_CMPLT_Q_TIMER;
 	ahd_linux_run_complete_queue(ahd);
 	ahd_unlock(ahd, &flags);
 }
@@ -2549,14 +2492,23 @@ ahd_linux_start_dv(struct ahd_softc *ahd
 	 * Freeze the simq and signal ahd_linux_queue to not let any
 	 * more commands through
 	 */
-	if ((ahd->platform_data->flags & AHD_DV_ACTIVE) == 0) {
+	if ((ahd->platform_data->flags & AIC_DV_ACTIVE) == 0) {
 #ifdef AHD_DEBUG
 		if (ahd_debug & AHD_SHOW_DV)
 			printf("%s: Starting DV\n", ahd_name(ahd));
 #endif
 
-		ahd->platform_data->flags |= AHD_DV_ACTIVE;
-		ahd_freeze_simq(ahd);
+		ahd->platform_data->flags |= AIC_DV_ACTIVE;
+
+		/*
+		 * Prevent upper layer from sending any
+		 * commands to us.
+		 */
+		aic_freeze_simq(ahd);
+		scsi_block_requests(ahd->platform_data->host);
+		ahd_platform_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
+					CAM_LUN_WILDCARD, SCB_LIST_NULL,
+					ROLE_INITIATOR, CAM_REQUEUE_REQ);
 
 		/* Wake up the DV kthread */
 		up(&ahd->platform_data->dv_sem);
@@ -2595,6 +2547,7 @@ ahd_linux_dv_thread(void *data)
 	unlock_kernel();
 
 	while (1) {
+
 		/*
 		 * Use down_interruptible() rather than down() to
 		 * avoid inclusion in the load average.
@@ -2603,7 +2556,7 @@ ahd_linux_dv_thread(void *data)
 
 		/* Check to see if we've been signaled to exit */
 		ahd_lock(ahd, &s);
-		if ((ahd->platform_data->flags & AHD_DV_SHUTDOWN) != 0) {
+		if ((ahd->platform_data->flags & AIC_DV_SHUTDOWN) != 0) {
 			ahd_unlock(ahd, &s);
 			break;
 		}
@@ -2620,7 +2573,7 @@ ahd_linux_dv_thread(void *data)
 		 */
 		ahd_lock(ahd, &s);
 		while (LIST_FIRST(&ahd->pending_scbs) != NULL) {
-			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_EMPTY;
+			ahd->platform_data->flags |= AIC_DV_WAIT_SIMQ_EMPTY;
 			ahd_unlock(ahd, &s);
 			down_interruptible(&ahd->platform_data->dv_sem);
 			ahd_lock(ahd, &s);
@@ -2630,8 +2583,8 @@ ahd_linux_dv_thread(void *data)
 		 * Wait for the SIMQ to be released so that DV is the
 		 * only reason the queue is frozen.
 		 */
-		while (AHD_DV_SIMQ_FROZEN(ahd) == 0) {
-			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_RELEASE;
+		while (AIC_DV_SIMQ_FROZEN(ahd) == 0) {
+			ahd->platform_data->flags |= AIC_DV_WAIT_SIMQ_RELEASE;
 			ahd_unlock(ahd, &s);
 			down_interruptible(&ahd->platform_data->dv_sem);
 			ahd_lock(ahd, &s);
@@ -2642,14 +2595,17 @@ ahd_linux_dv_thread(void *data)
 			ahd_linux_dv_target(ahd, target);
 
 		ahd_lock(ahd, &s);
-		ahd->platform_data->flags &= ~AHD_DV_ACTIVE;
-		ahd_unlock(ahd, &s);
+		ahd->platform_data->flags &= ~AIC_DV_ACTIVE;
 
 		/*
 		 * Release the SIMQ so that normal commands are
 		 * allowed to continue on the bus.
 		 */
-		ahd_release_simq(ahd);
+		aic_release_simq_locked(ahd);
+
+		ahd_unlock(ahd, &s);
+
+		scsi_unblock_requests(ahd->platform_data->host);
 	}
 	up(&ahd->platform_data->eh_sem);
 	return (0);
@@ -2662,7 +2618,7 @@ ahd_linux_kill_dv_thread(struct ahd_soft
 
 	ahd_lock(ahd, &s);
 	if (ahd->platform_data->dv_pid != 0) {
-		ahd->platform_data->flags |= AHD_DV_SHUTDOWN;
+		ahd->platform_data->flags |= AIC_DV_SHUTDOWN;
 		ahd_unlock(ahd, &s);
 		up(&ahd->platform_data->dv_sem);
 
@@ -2682,10 +2638,10 @@ ahd_linux_kill_dv_thread(struct ahd_soft
 		/*
 		 * Mark the dv thread as already dead.  This
 		 * avoids attempting to kill it a second time.
-		 * This is necessary because we must kill the
-		 * DV thread before calling ahd_free() in the
+		 * This is necessary because we must kill our
+		 * threads before calling ahd_free() in the
 		 * module shutdown case to avoid bogus locking
-		 * in the SCSI mid-layer, but we ahd_free() is
+		 * in the SCSI mid-layer, but when ahd_free() is
 		 * called without killing the DV thread in the
 		 * instance detach case, so ahd_platform_free()
 		 * calls us again to verify that the DV thread
@@ -2705,10 +2661,10 @@ ahd_linux_kill_dv_thread(struct ahd_soft
 	ahd_set_dv_state(ahd, targ, newstate, __LINE__)
 
 static __inline void
-ahd_set_dv_state(struct ahd_softc *ahd, struct ahd_linux_target *targ,
-		 ahd_dv_state newstate, u_int line)
+ahd_set_dv_state(struct ahd_softc *ahd, struct aic_linux_target *targ,
+		 aic_dv_state newstate, u_int line)
 {
-	ahd_dv_state oldstate;
+	aic_dv_state oldstate;
 
 	oldstate = targ->dv_state;
 #ifdef AHD_DEBUG
@@ -2728,7 +2684,7 @@ static void
 ahd_linux_dv_target(struct ahd_softc *ahd, u_int target_offset)
 {
 	struct	 ahd_devinfo devinfo;
-	struct	 ahd_linux_target *targ;
+	struct	 aic_linux_target *targ;
 	struct	 scsi_cmnd *cmd;
 	struct	 scsi_device *scsi_dev;
 	struct	 scsi_sense_data *sense;
@@ -2742,7 +2698,7 @@ ahd_linux_dv_target(struct ahd_softc *ah
 	echo_size = 0;
 	ahd_lock(ahd, &s);
 	targ = ahd->platform_data->targets[target_offset];
-	if (targ == NULL || (targ->flags & AHD_DV_REQUIRED) == 0) {
+	if (targ == NULL || (targ->flags & AIC_DV_REQUIRED) == 0) {
 		ahd_unlock(ahd, &s);
 		return;
 	}
@@ -2765,14 +2721,14 @@ ahd_linux_dv_target(struct ahd_softc *ah
 	scsi_dev->channel = devinfo.channel - 'A';
 	ahd->platform_data->dv_scsi_dev = scsi_dev;
 
-	AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_INQ_SHORT_ASYNC);
+	AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_INQ_SHORT_ASYNC);
 
-	while (targ->dv_state != AHD_DV_STATE_EXIT) {
+	while (targ->dv_state != AIC_DV_STATE_EXIT) {
 		timeout = AHD_LINUX_DV_TIMEOUT;
 		switch (targ->dv_state) {
-		case AHD_DV_STATE_INQ_SHORT_ASYNC:
-		case AHD_DV_STATE_INQ_ASYNC:
-		case AHD_DV_STATE_INQ_ASYNC_VERIFY:
+		case AIC_DV_STATE_INQ_SHORT_ASYNC:
+		case AIC_DV_STATE_INQ_ASYNC:
+		case AIC_DV_STATE_INQ_ASYNC_VERIFY:
 			/*
 			 * Set things to async narrow to reduce the
 			 * chance that the INQ will fail.
@@ -2784,36 +2740,36 @@ ahd_linux_dv_target(struct ahd_softc *ah
 				      AHD_TRANS_GOAL, /*paused*/FALSE);
 			ahd_unlock(ahd, &s);
 			timeout = 10 * HZ;
-			targ->flags &= ~AHD_INQ_VALID;
+			targ->flags &= ~AIC_INQ_VALID;
 			/* FALLTHROUGH */
-		case AHD_DV_STATE_INQ_VERIFY:
+		case AIC_DV_STATE_INQ_VERIFY:
 		{
 			u_int inq_len;
 
-			if (targ->dv_state == AHD_DV_STATE_INQ_SHORT_ASYNC)
+			if (targ->dv_state == AIC_DV_STATE_INQ_SHORT_ASYNC)
 				inq_len = AHD_LINUX_DV_INQ_SHORT_LEN;
 			else
 				inq_len = targ->inq_data->additional_length + 5;
 			ahd_linux_dv_inq(ahd, cmd, &devinfo, targ, inq_len);
 			break;
 		}
-		case AHD_DV_STATE_TUR:
-		case AHD_DV_STATE_BUSY:
+		case AIC_DV_STATE_TUR:
+		case AIC_DV_STATE_BUSY:
 			timeout = 5 * HZ;
 			ahd_linux_dv_tur(ahd, cmd, &devinfo);
 			break;
-		case AHD_DV_STATE_REBD:
+		case AIC_DV_STATE_REBD:
 			ahd_linux_dv_rebd(ahd, cmd, &devinfo, targ);
 			break;
-		case AHD_DV_STATE_WEB:
+		case AIC_DV_STATE_WEB:
 			ahd_linux_dv_web(ahd, cmd, &devinfo, targ);
 			break;
 
-		case AHD_DV_STATE_REB:
+		case AIC_DV_STATE_REB:
 			ahd_linux_dv_reb(ahd, cmd, &devinfo, targ);
 			break;
 
-		case AHD_DV_STATE_SU:
+		case AIC_DV_STATE_SU:
 			ahd_linux_dv_su(ahd, cmd, &devinfo, targ);
 			timeout = 50 * HZ;
 			break;
@@ -2825,8 +2781,6 @@ ahd_linux_dv_target(struct ahd_softc *ah
 		}
 
 		/* Queue the command and wait for it to complete */
-		/* Abuse eh_timeout in the scsi_cmnd struct for our purposes */
-		init_timer(&cmd->eh_timeout);
 #ifdef AHD_DEBUG
 		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
 			/*
@@ -2836,32 +2790,35 @@ ahd_linux_dv_target(struct ahd_softc *ah
 			 */
 			timeout += HZ;
 #endif
-		scsi_add_timer(cmd, timeout, ahd_linux_dv_timeout);
+		init_timer(&cmd->eh_timeout);
+		cmd->timeout_per_command = timeout;
+
 		/*
 		 * In 2.5.X, it is assumed that all calls from the
 		 * "midlayer" (which we are emulating) will have the
 		 * ahd host lock held.  For other kernels, the
 		 * io_request_lock must be held.
 		 */
-#if AHD_SCSI_HAS_HOST_LOCK != 0
+#if AIC_SCSI_HAS_HOST_LOCK != 0
 		ahd_lock(ahd, &s);
 #else
 		spin_lock_irqsave(&io_request_lock, s);
 #endif
 		ahd_linux_queue(cmd, ahd_linux_dv_complete);
-#if AHD_SCSI_HAS_HOST_LOCK != 0
+#if AIC_SCSI_HAS_HOST_LOCK != 0
 		ahd_unlock(ahd, &s);
 #else
 		spin_unlock_irqrestore(&io_request_lock, s);
 #endif
 		down_interruptible(&ahd->platform_data->dv_cmd_sem);
+
 		/*
 		 * Wait for the SIMQ to be released so that DV is the
 		 * only reason the queue is frozen.
 		 */
 		ahd_lock(ahd, &s);
-		while (AHD_DV_SIMQ_FROZEN(ahd) == 0) {
-			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_RELEASE;
+		while (AIC_DV_SIMQ_FROZEN(ahd) == 0) {
+			ahd->platform_data->flags |= AIC_DV_WAIT_SIMQ_RELEASE;
 			ahd_unlock(ahd, &s);
 			down_interruptible(&ahd->platform_data->dv_sem);
 			ahd_lock(ahd, &s);
@@ -2872,7 +2829,7 @@ ahd_linux_dv_target(struct ahd_softc *ah
 	}
 
 out:
-	if ((targ->flags & AHD_INQ_VALID) != 0
+	if ((targ->flags & AIC_INQ_VALID) != 0
 	 && ahd_linux_get_device(ahd, devinfo.channel - 'A',
 				 devinfo.target, devinfo.lun,
 				 /*alloc*/FALSE) == NULL) {
@@ -2883,7 +2840,7 @@ out:
 		 * parameters found in the inquiry string.
 		 */
 		ahd_linux_filter_inquiry(ahd, &devinfo);
-		if ((targ->flags & (AHD_BASIC_DV|AHD_ENHANCED_DV)) != 0) {
+		if ((targ->flags & (AIC_BASIC_DV|AIC_ENHANCED_DV)) != 0) {
 			ahd_print_devinfo(ahd, &devinfo);
 			printf("DV failed to configure device.  "
 			       "Please file a bug report against "
@@ -2908,7 +2865,7 @@ out:
 		free(targ->dv_buffer1, M_DEVBUF);
 		targ->dv_buffer1 = NULL;
 	}
-	targ->flags &= ~AHD_DV_REQUIRED;
+	targ->flags &= ~AIC_DV_REQUIRED;
 	if (targ->refcount == 0)
 		ahd_linux_free_target(ahd, targ);
 	ahd_unlock(ahd, &s);
@@ -2917,13 +2874,13 @@ out:
 static void
 ahd_linux_dv_transition(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
 			struct ahd_devinfo *devinfo,
-			struct ahd_linux_target *targ)
+			struct aic_linux_target *targ)
 {
 	u_int32_t status;
 
 	status = aic_error_action(cmd, targ->inq_data,
-				  ahd_cmd_get_transaction_status(cmd),
-				  ahd_cmd_get_scsi_status(cmd));
+				  aic_cmd_get_transaction_status(cmd),
+				  aic_cmd_get_scsi_status(cmd));
 
 	
 #ifdef AHD_DEBUG
@@ -2936,8 +2893,8 @@ ahd_linux_dv_transition(struct ahd_softc
 #endif
 
 	switch (targ->dv_state) {
-	case AHD_DV_STATE_INQ_SHORT_ASYNC:
-	case AHD_DV_STATE_INQ_ASYNC:
+	case AIC_DV_STATE_INQ_SHORT_ASYNC:
+	case AIC_DV_STATE_INQ_ASYNC:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		{
@@ -2946,21 +2903,21 @@ ahd_linux_dv_transition(struct ahd_softc
 		}
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_TUR:
 		case SS_RETRY:
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ)
 				targ->dv_state_retry--;
 			if ((status & SS_ERRMASK) == EBUSY)
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_BUSY);
 			if (targ->dv_state_retry < 10)
 				break;
 			/* FALLTHROUGH */
 		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 #ifdef AHD_DEBUG
 			if (ahd_debug & AHD_SHOW_DV) {
 				ahd_print_devinfo(ahd, devinfo);
@@ -2970,7 +2927,7 @@ ahd_linux_dv_transition(struct ahd_softc
 			break;
 		}
 		break;
-	case AHD_DV_STATE_INQ_ASYNC_VERIFY:
+	case AIC_DV_STATE_INQ_ASYNC_VERIFY:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		{
@@ -2984,12 +2941,12 @@ ahd_linux_dv_transition(struct ahd_softc
 				 * Try from the top again.
 				 */
 				AHD_SET_DV_STATE(ahd, targ,
-						 AHD_DV_STATE_INQ_SHORT_ASYNC);
+						 AIC_DV_STATE_INQ_SHORT_ASYNC);
 				break;
 			}
 
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state+1);
-			targ->flags |= AHD_INQ_VALID;
+			targ->flags |= AIC_INQ_VALID;
 			if (ahd_linux_user_dv_setting(ahd) == 0)
 				break;
 
@@ -3002,33 +2959,33 @@ ahd_linux_dv_transition(struct ahd_softc
 			default:
 			case SID_SPI_CLOCK_ST:
 				/* Assume only basic DV is supported. */
-				targ->flags |= AHD_BASIC_DV;
+				targ->flags |= AIC_BASIC_DV;
 				break;
 			case SID_SPI_CLOCK_DT:
 			case SID_SPI_CLOCK_DT_ST:
-				targ->flags |= AHD_ENHANCED_DV;
+				targ->flags |= AIC_ENHANCED_DV;
 				break;
 			}
 			break;
 		}
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_TUR:
 		case SS_RETRY:
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ)
 				targ->dv_state_retry--;
 
 			if ((status & SS_ERRMASK) == EBUSY)
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_BUSY);
 			if (targ->dv_state_retry < 10)
 				break;
 			/* FALLTHROUGH */
 		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 #ifdef AHD_DEBUG
 			if (ahd_debug & AHD_SHOW_DV) {
 				ahd_print_devinfo(ahd, devinfo);
@@ -3038,14 +2995,14 @@ ahd_linux_dv_transition(struct ahd_softc
 			break;
 		}
 		break;
-	case AHD_DV_STATE_INQ_VERIFY:
+	case AIC_DV_STATE_INQ_VERIFY:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		{
 
 			if (memcmp(targ->inq_data, targ->dv_buffer,
 				   AHD_LINUX_DV_INQ_LEN) == 0) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 				break;
 			}
 
@@ -3067,7 +3024,7 @@ ahd_linux_dv_transition(struct ahd_softc
 #endif
 
 			if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 				break;
 			}
 			/*
@@ -3080,18 +3037,18 @@ ahd_linux_dv_transition(struct ahd_softc
 		}
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_TUR:
 		case SS_RETRY:
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if ((status & SSQ_FALLBACK) != 0) {
 				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
 					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 					break;
 				}
 				/*
@@ -3100,12 +3057,12 @@ ahd_linux_dv_transition(struct ahd_softc
 				 */
 				targ->dv_state_retry = 0;
 			} else if ((status & SS_ERRMASK) == EBUSY)
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_BUSY);
 			if (targ->dv_state_retry < 10)
 				break;
 			/* FALLTHROUGH */
 		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 #ifdef AHD_DEBUG
 			if (ahd_debug & AHD_SHOW_DV) {
 				ahd_print_devinfo(ahd, devinfo);
@@ -3116,33 +3073,33 @@ ahd_linux_dv_transition(struct ahd_softc
 		}
 		break;
 
-	case AHD_DV_STATE_TUR:
+	case AIC_DV_STATE_TUR:
 		switch (status & SS_MASK) {
 		case SS_NOP:
-			if ((targ->flags & AHD_BASIC_DV) != 0) {
+			if ((targ->flags & AIC_BASIC_DV) != 0) {
 				ahd_linux_filter_inquiry(ahd, devinfo);
 				AHD_SET_DV_STATE(ahd, targ,
-						 AHD_DV_STATE_INQ_VERIFY);
-			} else if ((targ->flags & AHD_ENHANCED_DV) != 0) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_REBD);
+						 AIC_DV_STATE_INQ_VERIFY);
+			} else if ((targ->flags & AIC_ENHANCED_DV) != 0) {
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_REBD);
 			} else {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 			}
 			break;
 		case SS_RETRY:
 		case SS_TUR:
 			if ((status & SS_ERRMASK) == EBUSY) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_BUSY);
 				break;
 			}
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if ((status & SSQ_FALLBACK) != 0) {
 				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
 					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 					break;
 				}
 				/*
@@ -3158,7 +3115,7 @@ ahd_linux_dv_transition(struct ahd_softc
 					printf("DV TUR reties exhausted\n");
 				}
 #endif
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 				break;
 			}
 			if (status & SSQ_DELAY)
@@ -3166,25 +3123,25 @@ ahd_linux_dv_transition(struct ahd_softc
 
 			break;
 		case SS_START:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_SU);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_SU);
 			break;
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
 
-	case AHD_DV_STATE_REBD:
+	case AIC_DV_STATE_REBD:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		{
 			uint32_t echo_size;
 
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_WEB);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_WEB);
 			echo_size = scsi_3btoul(&targ->dv_buffer[1]);
 			echo_size &= 0x1FFF;
 #ifdef AHD_DEBUG
@@ -3194,7 +3151,17 @@ ahd_linux_dv_transition(struct ahd_softc
 			}
 #endif
 			if (echo_size == 0) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				/*
+				 * Fall back to basic DV.
+				 */
+				if (bootverbose) {
+					ahd_print_devinfo(ahd, devinfo);
+					printf("Echo Buffer unavailable.  "
+					       "Performing basic DV.\n");
+				}
+				targ->flags &= ~AIC_ENHANCED_DV;
+				targ->flags |= AIC_BASIC_DV;
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_TUR);
 				break;
 			}
 
@@ -3209,11 +3176,11 @@ ahd_linux_dv_transition(struct ahd_softc
 		}
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_RETRY:
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ)
 				targ->dv_state_retry--;
 			if (targ->dv_state_retry <= 10)
@@ -3232,30 +3199,30 @@ ahd_linux_dv_transition(struct ahd_softc
 			 * and try level 1 DV.
 			 */
 			ahd_linux_filter_inquiry(ahd, devinfo);
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_INQ_VERIFY);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_INQ_VERIFY);
 			targ->dv_echo_size = 0;
 			break;
 		}
 		break;
 
-	case AHD_DV_STATE_WEB:
+	case AIC_DV_STATE_WEB:
 		switch (status & SS_MASK) {
 		case SS_NOP:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_REB);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_REB);
 			break;
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_RETRY:
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if ((status & SSQ_FALLBACK) != 0) {
 				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
 					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 					break;
 				}
 				/*
@@ -3274,22 +3241,22 @@ ahd_linux_dv_transition(struct ahd_softc
 			}
 #endif
 		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
 
-	case AHD_DV_STATE_REB:
+	case AIC_DV_STATE_REB:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 			if (memcmp(targ->dv_buffer, targ->dv_buffer1,
 				   targ->dv_echo_size) != 0) {
 				if (ahd_linux_dv_fallback(ahd, devinfo) != 0)
 					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 				else
 					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_WEB);
+							 AIC_DV_STATE_WEB);
 				break;
 			}
 			
@@ -3301,24 +3268,24 @@ ahd_linux_dv_transition(struct ahd_softc
 				free(targ->dv_buffer1, M_DEVBUF);
 				targ->dv_buffer1 = NULL;
 			}
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 			break;
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_RETRY:
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if ((status & SSQ_FALLBACK) != 0) {
 				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
 					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 					break;
 				}
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_WEB);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_WEB);
 			}
 			if (targ->dv_state_retry <= 10) {
 				if ((status & (SSQ_DELAY_RANDOM|SSQ_DELAY))!= 0)
@@ -3333,35 +3300,35 @@ ahd_linux_dv_transition(struct ahd_softc
 #endif
 			/* FALLTHROUGH */
 		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
 
-	case AHD_DV_STATE_SU:
+	case AIC_DV_STATE_SU:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
 
-	case AHD_DV_STATE_BUSY:
+	case AIC_DV_STATE_BUSY:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		case SS_INQ_REFRESH:
 			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_TUR:
 		case SS_RETRY:
 			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if (targ->dv_state_retry < 60) {
@@ -3374,11 +3341,11 @@ ahd_linux_dv_transition(struct ahd_softc
 					printf("DV BUSY reties exhausted\n");
 				}
 #endif
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 			}
 			break;
 		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
@@ -3386,7 +3353,7 @@ ahd_linux_dv_transition(struct ahd_softc
 	default:
 		printf("%s: Invalid DV completion state %d\n", ahd_name(ahd),
 		       targ->dv_state);
-		AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+		AHD_SET_DV_STATE(ahd, targ, AIC_DV_STATE_EXIT);
 		break;
 	}
 }
@@ -3406,7 +3373,7 @@ ahd_linux_dv_fill_cmd(struct ahd_softc *
  */
 static void
 ahd_linux_dv_inq(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ,
+		 struct ahd_devinfo *devinfo, struct aic_linux_target *targ,
 		 u_int request_length)
 {
 
@@ -3419,7 +3386,7 @@ ahd_linux_dv_inq(struct ahd_softc *ahd, 
 	if (targ->inq_data == NULL)
 		targ->inq_data = malloc(AHD_LINUX_DV_INQ_LEN,
 					M_DEVBUF, M_WAITOK);
-	if (targ->dv_state > AHD_DV_STATE_INQ_ASYNC) {
+	if (targ->dv_state > AIC_DV_STATE_INQ_ASYNC) {
 		if (targ->dv_buffer != NULL)
 			free(targ->dv_buffer, M_DEVBUF);
 		targ->dv_buffer = malloc(AHD_LINUX_DV_INQ_LEN,
@@ -3432,7 +3399,7 @@ ahd_linux_dv_inq(struct ahd_softc *ahd, 
 	cmd->cmnd[0] = INQUIRY;
 	cmd->cmnd[4] = request_length;
 	cmd->request_bufflen = request_length;
-	if (targ->dv_state > AHD_DV_STATE_INQ_ASYNC)
+	if (targ->dv_state > AIC_DV_STATE_INQ_ASYNC)
 		cmd->request_buffer = targ->dv_buffer;
 	else
 		cmd->request_buffer = targ->inq_data;
@@ -3461,7 +3428,7 @@ ahd_linux_dv_tur(struct ahd_softc *ahd, 
 
 static void
 ahd_linux_dv_rebd(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
+		 struct ahd_devinfo *devinfo, struct aic_linux_target *targ)
 {
 
 #ifdef AHD_DEBUG
@@ -3486,7 +3453,7 @@ ahd_linux_dv_rebd(struct ahd_softc *ahd,
 
 static void
 ahd_linux_dv_web(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
+		 struct ahd_devinfo *devinfo, struct aic_linux_target *targ)
 {
 
 #ifdef AHD_DEBUG
@@ -3508,7 +3475,7 @@ ahd_linux_dv_web(struct ahd_softc *ahd, 
 
 static void
 ahd_linux_dv_reb(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
+		 struct ahd_devinfo *devinfo, struct aic_linux_target *targ)
 {
 
 #ifdef AHD_DEBUG
@@ -3531,7 +3498,7 @@ ahd_linux_dv_reb(struct ahd_softc *ahd, 
 static void
 ahd_linux_dv_su(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
 		struct ahd_devinfo *devinfo,
-		struct ahd_linux_target *targ)
+		struct aic_linux_target *targ)
 {
 	u_int le;
 
@@ -3566,7 +3533,7 @@ ahd_linux_dv_fallback(struct ahd_softc *
 static int
 ahd_linux_fallback(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
 {
-	struct	ahd_linux_target *targ;
+	struct	aic_linux_target *targ;
 	struct	ahd_initiator_tinfo *tinfo;
 	struct	ahd_transinfo *goal;
 	struct	ahd_tmode_tstate *tstate;
@@ -3737,7 +3704,7 @@ ahd_linux_fallback(struct ahd_softc *ahd
 	return (0);
 }
 
-static void
+void
 ahd_linux_dv_timeout(struct scsi_cmnd *cmd)
 {
 	struct	ahd_softc *ahd;
@@ -3771,29 +3738,18 @@ ahd_linux_dv_timeout(struct scsi_cmnd *c
 	 * error code.
 	 */
 	if ((scb->flags & SCB_SENSE) != 0)
-		ahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+		aic_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
 	else
-		ahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+		aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);
 	ahd_reset_channel(ahd, cmd->device->channel + 'A', /*initiate*/TRUE);
 
-	/*
-	 * Add a minimal bus settle delay for devices that are slow to
-	 * respond after bus resets.
-	 */
-	ahd_freeze_simq(ahd);
-	init_timer(&ahd->platform_data->reset_timer);
-	ahd->platform_data->reset_timer.data = (u_long)ahd;
-	ahd->platform_data->reset_timer.expires = jiffies + HZ / 2;
-	ahd->platform_data->reset_timer.function =
-	    (ahd_linux_callback_t *)ahd_release_simq;
-	add_timer(&ahd->platform_data->reset_timer);
-	if (ahd_linux_next_device_to_run(ahd) != NULL)
-		ahd_schedule_runq(ahd);
+	if (aic_linux_next_device_to_run(ahd) != NULL)
+		aic_schedule_runq(ahd);
 	ahd_linux_run_complete_queue(ahd);
 	ahd_unlock(ahd, &flags);
 }
 
-static void
+void
 ahd_linux_dv_complete(struct scsi_cmnd *cmd)
 {
 	struct ahd_softc *ahd;
@@ -3815,7 +3771,7 @@ ahd_linux_dv_complete(struct scsi_cmnd *
 }
 
 static void
-ahd_linux_generate_dv_pattern(struct ahd_linux_target *targ)
+ahd_linux_generate_dv_pattern(struct aic_linux_target *targ)
 {
 	uint16_t b;
 	u_int	 i;
@@ -3981,8 +3937,8 @@ ahd_linux_setup_user_rd_strm_settings(st
  * Determines the queue depth for a given device.
  */
 static void
-ahd_linux_device_queue_depth(struct ahd_softc *ahd,
-			     struct ahd_linux_device *dev)
+aic_linux_device_queue_depth(struct ahd_softc *ahd,
+			     struct aic_linux_device *dev)
 {
 	struct	ahd_devinfo devinfo;
 	u_int	tags;
@@ -4005,10 +3961,10 @@ ahd_linux_device_queue_depth(struct ahd_
 	}
 }
 
-static void
-ahd_linux_run_device_queue(struct ahd_softc *ahd, struct ahd_linux_device *dev)
+void
+ahd_linux_run_device_queue(struct ahd_softc *ahd, struct aic_linux_device *dev)
 {
-	struct	 ahd_cmd *acmd;
+	struct	 aic_cmd *acmd;
 	struct	 scsi_cmnd *cmd;
 	struct	 scb *scb;
 	struct	 hardware_scb *hscb;
@@ -4017,22 +3973,23 @@ ahd_linux_run_device_queue(struct ahd_so
 	u_int	 col_idx;
 	uint16_t mask;
 
-	if ((dev->flags & AHD_DEV_ON_RUN_LIST) != 0)
+	if ((dev->flags & AIC_DEV_ON_RUN_LIST) != 0)
 		panic("running device on run list");
 
 	while ((acmd = TAILQ_FIRST(&dev->busyq)) != NULL
-	    && dev->openings > 0 && dev->qfrozen == 0) {
+	    && dev->openings > 0 && dev->qfrozen == 0
+	    && dev->target->qfrozen == 0) {
 
 		/*
 		 * Schedule us to run later.  The only reason we are not
 		 * running is because the whole controller Q is frozen.
 		 */
 		if (ahd->platform_data->qfrozen != 0
-		 && AHD_DV_SIMQ_FROZEN(ahd) == 0) {
+		 && AIC_DV_SIMQ_FROZEN(ahd) == 0) {
 
 			TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq,
 					  dev, links);
-			dev->flags |= AHD_DEV_ON_RUN_LIST;
+			dev->flags |= AIC_DEV_ON_RUN_LIST;
 			return;
 		}
 
@@ -4043,7 +4000,7 @@ ahd_linux_run_device_queue(struct ahd_so
 		 */
 		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
 					    cmd->device->id, &tstate);
-		if ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) == 0
+		if ((dev->flags & (AIC_DEV_Q_TAGGED|AIC_DEV_Q_BASIC)) == 0
 		 || (tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
 			col_idx = AHD_NEVER_COL_IDX;
 		} else {
@@ -4053,13 +4010,15 @@ ahd_linux_run_device_queue(struct ahd_so
 		if ((scb = ahd_get_scb(ahd, col_idx)) == NULL) {
 			TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq,
 					 dev, links);
-			dev->flags |= AHD_DEV_ON_RUN_LIST;
-			ahd->flags |= AHD_RESOURCE_SHORTAGE;
+			dev->flags |= AIC_DEV_ON_RUN_LIST;
+			ahd->flags |= AIC_RESOURCE_SHORTAGE;
+			ahd->platform_data->qfrozen++;
 			return;
 		}
 		TAILQ_REMOVE(&dev->busyq, acmd, acmd_links.tqe);
 		scb->io_ctx = cmd;
 		scb->platform_data->dev = dev;
+		scb->platform_data->flags = 0;
 		hscb = scb->hscb;
 		cmd->host_scribble = (char *)scb;
 
@@ -4075,7 +4034,7 @@ ahd_linux_run_device_queue(struct ahd_so
 		if ((ahd->user_discenable & mask) != 0)
 			hscb->control |= DISCENB;
 
-	 	if (AHD_DV_CMD(cmd) != 0)
+	 	if (AIC_DV_CMD(cmd) != 0)
 			scb->flags |= SCB_SILENT;
 
 		if ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0)
@@ -4084,9 +4043,33 @@ ahd_linux_run_device_queue(struct ahd_so
 		if ((tstate->auto_negotiate & mask) != 0) {
 			scb->flags |= SCB_AUTO_NEGOTIATE;
 			scb->hscb->control |= MK_MESSAGE;
+		} else if (cmd->cmnd[0] == INQUIRY
+			&& (tinfo->curr.offset != 0
+			 || tinfo->curr.width != MSG_EXT_WDTR_BUS_8_BIT
+			 || tinfo->curr.ppr_options != 0)
+			&& (tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ)==0) {
+			/*
+			 * The SCSI spec requires inquiry
+			 * commands to complete without
+			 * reporting unit attention conditions.
+			 * Because of this, an inquiry command
+			 * that occurs just after a device is
+			 * reset will result in a data phase
+			 * with mismatched negotiated rates.
+			 * The core already forces a renegotiation
+			 * for reset events that are visible to
+			 * our controller or that we initiate,
+			 * but a third party device reset or a
+			 * hot-plug insertion can still cause this
+			 * issue.  Therefore, we force a re-negotiation
+			 * for every inquiry command unless we
+			 * are async.
+			 */
+			scb->flags |= SCB_NEGOTIATE;
+			scb->hscb->control |= MK_MESSAGE;
 		}
 
-		if ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) != 0) {
+		if ((dev->flags & (AIC_DEV_Q_TAGGED|AIC_DEV_Q_BASIC)) != 0) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 			int	msg_bytes;
 			uint8_t tag_msgs[2];
@@ -4098,8 +4081,8 @@ ahd_linux_run_device_queue(struct ahd_so
 					dev->commands_since_idle_or_otag = 0;
 			} else
 #endif
-			if (dev->commands_since_idle_or_otag == AHD_OTAG_THRESH
-			 && (dev->flags & AHD_DEV_Q_TAGGED) != 0) {
+			if (dev->commands_since_idle_or_otag == AIC_OTAG_THRESH
+			 && (dev->flags & AIC_DEV_Q_TAGGED) != 0) {
 				hscb->control |= MSG_ORDERED_TASK;
 				dev->commands_since_idle_or_otag = 0;
 			} else {
@@ -4111,8 +4094,9 @@ ahd_linux_run_device_queue(struct ahd_so
 		memcpy(hscb->shared_data.idata.cdb, cmd->cmnd, hscb->cdb_len);
 
 		scb->sg_count = 0;
-		ahd_set_residual(scb, 0);
-		ahd_set_sense_residual(scb, 0);
+		aic_set_residual(scb, 0);
+		aic_set_sense_residual(scb, 0);
+		scb->platform_data->xfer_len = 0;
 		if (cmd->use_sg != 0) {
 			void	*sg;
 			struct	 scatterlist *cur_seg;
@@ -4121,18 +4105,15 @@ ahd_linux_run_device_queue(struct ahd_so
 
 			cur_seg = (struct scatterlist *)cmd->request_buffer;
 			dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
-			nseg = pci_map_sg(ahd->dev_softc, cur_seg,
-					  cmd->use_sg, dir);
-			scb->platform_data->xfer_len = 0;
+			nseg = aic_map_sg(ahd, cur_seg, cmd->use_sg, dir);
 			for (sg = scb->sg_list; nseg > 0; nseg--, cur_seg++) {
 				bus_addr_t addr;
 				bus_size_t len;
 
 				addr = sg_dma_address(cur_seg);
 				len = sg_dma_len(cur_seg);
-				scb->platform_data->xfer_len += len;
-				sg = ahd_sg_setup(ahd, scb, sg, addr, len,
-						  /*last*/nseg == 1);
+				sg = ahd_linux_sg_setup(ahd, scb, sg, addr, len,
+							/*last*/nseg == 1);
 			}
 		} else if (cmd->request_bufflen != 0) {
 			void *sg;
@@ -4141,13 +4122,13 @@ ahd_linux_run_device_queue(struct ahd_so
 
 			sg = scb->sg_list;
 			dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
-			addr = pci_map_single(ahd->dev_softc,
+			addr = aic_map_single(ahd,
 					      cmd->request_buffer,
 					      cmd->request_bufflen, dir);
-			scb->platform_data->xfer_len = cmd->request_bufflen;
 			scb->platform_data->buf_busaddr = addr;
-			sg = ahd_sg_setup(ahd, scb, sg, addr,
-					  cmd->request_bufflen, /*last*/TRUE);
+			sg = ahd_linux_sg_setup(ahd, scb, sg, addr,
+						cmd->request_bufflen,
+						/*last*/TRUE);
 		}
 
 		LIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);
@@ -4163,9 +4144,10 @@ ahd_linux_run_device_queue(struct ahd_so
 				dev->target->cmds_since_error = 0;
 		}
 
-		if ((dev->flags & AHD_DEV_PERIODIC_OTAG) != 0)
+		if ((dev->flags & AIC_DEV_PERIODIC_OTAG) != 0)
 			dev->commands_since_idle_or_otag++;
 		scb->flags |= SCB_ACTIVE;
+		aic_scb_timer_start(scb);
 		ahd_queue_scb(ahd, scb);
 	}
 }
@@ -4183,8 +4165,8 @@ ahd_linux_isr(int irq, void *dev_id, str
 	ahd = (struct ahd_softc *) dev_id;
 	ahd_lock(ahd, &flags); 
 	ours = ahd_intr(ahd);
-	if (ahd_linux_next_device_to_run(ahd) != NULL)
-		ahd_schedule_runq(ahd);
+	if (aic_linux_next_device_to_run(ahd) != NULL)
+		aic_schedule_runq(ahd);
 	ahd_linux_run_complete_queue(ahd);
 	ahd_unlock(ahd, &flags);
 	return IRQ_RETVAL(ours);
@@ -4198,10 +4180,10 @@ ahd_platform_flushwork(struct ahd_softc 
 		;
 }
 
-static struct ahd_linux_target*
+static struct aic_linux_target*
 ahd_linux_alloc_target(struct ahd_softc *ahd, u_int channel, u_int target)
 {
-	struct ahd_linux_target *targ;
+	struct aic_linux_target *targ;
 
 	targ = malloc(sizeof(*targ), M_DEVBUF, M_NOWAIT);
 	if (targ == NULL)
@@ -4209,14 +4191,15 @@ ahd_linux_alloc_target(struct ahd_softc 
 	memset(targ, 0, sizeof(*targ));
 	targ->channel = channel;
 	targ->target = target;
-	targ->ahd = ahd;
-	targ->flags = AHD_DV_REQUIRED;
+	targ->softc = ahd;
+	targ->flags = AIC_DV_REQUIRED;
+	init_timer(&targ->timer);
 	ahd->platform_data->targets[target] = targ;
 	return (targ);
 }
 
 static void
-ahd_linux_free_target(struct ahd_softc *ahd, struct ahd_linux_target *targ)
+ahd_linux_free_target(struct ahd_softc *ahd, struct aic_linux_target *targ)
 {
 	struct ahd_devinfo devinfo;
 	struct ahd_initiator_tinfo *tinfo;
@@ -4252,11 +4235,11 @@ ahd_linux_free_target(struct ahd_softc *
 	free(targ, M_DEVBUF);
 }
 
-static struct ahd_linux_device*
+static struct aic_linux_device*
 ahd_linux_alloc_device(struct ahd_softc *ahd,
-		 struct ahd_linux_target *targ, u_int lun)
+		 struct aic_linux_target *targ, u_int lun)
 {
-	struct ahd_linux_device *dev;
+	struct aic_linux_device *dev;
 
 	dev = malloc(sizeof(*dev), M_DEVBUG, M_NOWAIT);
 	if (dev == NULL)
@@ -4264,7 +4247,7 @@ ahd_linux_alloc_device(struct ahd_softc 
 	memset(dev, 0, sizeof(*dev));
 	init_timer(&dev->timer);
 	TAILQ_INIT(&dev->busyq);
-	dev->flags = AHD_DEV_UNCONFIGURED;
+	dev->flags = AIC_DEV_UNCONFIGURED;
 	dev->lun = lun;
 	dev->target = targ;
 
@@ -4287,17 +4270,16 @@ ahd_linux_alloc_device(struct ahd_softc 
 }
 
 static void
-ahd_linux_free_device(struct ahd_softc *ahd, struct ahd_linux_device *dev)
+ahd_linux_free_device(struct ahd_softc *ahd, struct aic_linux_device *dev)
 {
-	struct ahd_linux_target *targ;
+	struct aic_linux_target *targ;
 
-	del_timer(&dev->timer);
 	targ = dev->target;
 	targ->devices[dev->lun] = NULL;
 	free(dev, M_DEVBUF);
 	targ->refcount--;
 	if (targ->refcount == 0
-	 && (targ->flags & AHD_DV_REQUIRED) == 0)
+	 && (targ->flags & AIC_DV_REQUIRED) == 0)
 		ahd_linux_free_target(ahd, targ);
 }
 
@@ -4309,7 +4291,7 @@ ahd_send_async(struct ahd_softc *ahd, ch
 	case AC_TRANSFER_NEG:
 	{
 		char	buf[80];
-		struct	ahd_linux_target *targ;
+		struct	aic_linux_target *targ;
 		struct	info_str info;
 		struct	ahd_initiator_tinfo *tinfo;
 		struct	ahd_tmode_tstate *tstate;
@@ -4366,11 +4348,14 @@ ahd_send_async(struct ahd_softc *ahd, ch
 	}
         case AC_SENT_BDR:
 	{
+		struct	aic_linux_target *targ;
+		int	target_offset;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+
 		WARN_ON(lun != CAM_LUN_WILDCARD);
 		scsi_report_device_reset(ahd->platform_data->host,
 					 channel - 'A', target);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 		Scsi_Device *scsi_dev;
 
 		/*
@@ -4388,15 +4373,57 @@ ahd_send_async(struct ahd_softc *ahd, ch
 			}
 		}
 #endif
+		/*
+		 * Freeze the target for a 500ms to give the
+		 * target some time to recover from this BDR.
+		 */
+		target_offset = target;
+		if (channel == 'B')
+			target_offset += 8;
+		targ = ahd->platform_data->targets[target_offset];
+		if (targ == NULL)
+			break;
+		if ((targ->flags & AIC_TARG_TIMER_ACTIVE) != 0) {
+			printf("%s:%c:%d: Target Timer still active during "
+			       "BDR processing\n", ahd_name(ahd),
+				targ->channel, targ->target);
+			break;
+		}
+		/*
+		 * Keep the reference count non-zero during
+		 * the lifetime of the timer.  This
+		 * guarantees that the target will not
+		 * be freed before our timer executes.
+		 */
+		targ->refcount++;
+		targ->flags |= AIC_TARG_TIMER_ACTIVE;
+		targ->qfrozen++;
+		init_timer(&targ->timer);
+		targ->timer.data = (u_long)targ;
+		targ->timer.expires = jiffies + (HZ/2);
+		targ->timer.function = ahd_linux_targ_timed_unfreeze;
+		add_timer(&targ->timer);
 		break;
 	}
         case AC_BUS_RESET:
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
 		if (ahd->platform_data->host != NULL) {
 			scsi_report_bus_reset(ahd->platform_data->host,
 					      channel - 'A');
 		}
-#endif
+		/*
+		 * Add a minimal bus settle delay for devices that are slow to
+		 * respond after bus resets.
+		 */
+		if ((ahd->platform_data->flags & AIC_BUS_SETTLE_TIMER) == 0) {
+			aic_freeze_simq(ahd);
+			ahd->platform_data->flags |= AIC_BUS_SETTLE_TIMER;
+			ahd->platform_data->bus_settle_timer.expires =
+			    jiffies + (AIC79XX_RESET_DELAY * HZ)/1000;
+			add_timer(&ahd->platform_data->bus_settle_timer);
+		} else {
+			mod_timer(&ahd->platform_data->bus_settle_timer,
+				  jiffies + (AIC79XX_RESET_DELAY * HZ)/1000);
+		}
                 break;
         default:
                 panic("ahd_send_async: Unexpected async event");
@@ -4410,14 +4437,18 @@ void
 ahd_done(struct ahd_softc *ahd, struct scb *scb)
 {
 	Scsi_Cmnd *cmd;
-	struct	  ahd_linux_device *dev;
+	struct	  aic_linux_device *dev;
 
 	if ((scb->flags & SCB_ACTIVE) == 0) {
 		printf("SCB %d done'd twice\n", SCB_GET_TAG(scb));
 		ahd_dump_card_state(ahd);
 		panic("Stopping for safety");
 	}
+
 	LIST_REMOVE(scb, pending_links);
+	if ((scb->flags & SCB_TIMEDOUT) != 0)
+		LIST_REMOVE(scb, timedout_links);
+
 	cmd = scb->io_ctx;
 	dev = scb->platform_data->dev;
 	dev->active--;
@@ -4435,11 +4466,11 @@ ahd_done(struct ahd_softc *ahd, struct s
 	 * the sense buffer looks "sane".
 	 */
 	cmd->sense_buffer[0] = 0;
-	if (ahd_get_transaction_status(scb) == CAM_REQ_INPROG) {
+	if (aic_get_transaction_status(scb) == CAM_REQ_INPROG) {
 		uint32_t amount_xferred;
 
 		amount_xferred =
-		    ahd_get_transfer_length(scb) - ahd_get_residual(scb);
+		    aic_get_transfer_length(scb) - aic_get_residual(scb);
 		if ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {
 #ifdef AHD_DEBUG
 			if ((ahd_debug & AHD_SHOW_MISC) != 0) {
@@ -4447,7 +4478,7 @@ ahd_done(struct ahd_softc *ahd, struct s
 				printf("Set CAM_UNCOR_PARITY\n");
 			}
 #endif
-			ahd_set_transaction_status(scb, CAM_UNCOR_PARITY);
+			aic_set_transaction_status(scb, CAM_UNCOR_PARITY);
 #ifdef AHD_REPORT_UNDERFLOWS
 		/*
 		 * This code is disabled by default as some
@@ -4469,31 +4500,57 @@ ahd_done(struct ahd_softc *ahd, struct s
 			ahd_print_path(ahd, scb);
 			printf("Saw underflow (%ld of %ld bytes). "
 			       "Treated as error\n",
-				ahd_get_residual(scb),
-				ahd_get_transfer_length(scb));
-			ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+				aic_get_residual(scb),
+				aic_get_transfer_length(scb));
+			aic_set_transaction_status(scb, CAM_DATA_RUN_ERR);
 #endif
 		} else {
-			ahd_set_transaction_status(scb, CAM_REQ_CMP);
+			aic_set_transaction_status(scb, CAM_REQ_CMP);
 		}
-	} else if (ahd_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {
+	} else if (aic_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {
 		ahd_linux_handle_scsi_status(ahd, dev, scb);
-	} else if (ahd_get_transaction_status(scb) == CAM_SEL_TIMEOUT) {
-		dev->flags |= AHD_DEV_UNCONFIGURED;
-		if (AHD_DV_CMD(cmd) == FALSE)
-			dev->target->flags &= ~AHD_DV_REQUIRED;
+	} else if (aic_get_transaction_status(scb) == CAM_SEL_TIMEOUT) {
+		struct aic_linux_target *targ;
+		struct aic_linux_device *cur_dev;
+		int i;
+
+		/*
+		 * Mark all devices linked off this target
+		 * as unconfigured.
+		 */
+		targ = dev->target;
+		for (i = 0; i < AHD_NUM_LUNS; i++) {
+
+			if (targ->devices[i] == NULL)
+				continue;
+			cur_dev = targ->devices[i];
+			cur_dev->flags |= AIC_DEV_UNCONFIGURED;
+
+			/*
+			 * Don't free the dev for this
+			 * command prematurely.
+			 */
+			if (cur_dev == dev)
+				continue;
+
+			if (TAILQ_EMPTY(&cur_dev->busyq)
+			 && cur_dev->active == 0)
+				ahd_linux_free_device(ahd, cur_dev);
+		}
+		if (AIC_DV_CMD(cmd) == FALSE)
+			dev->target->flags &= ~AIC_DV_REQUIRED;
 	}
 	/*
 	 * Start DV for devices that require it assuming the first command
 	 * sent does not result in a selection timeout.
 	 */
-	if (ahd_get_transaction_status(scb) != CAM_SEL_TIMEOUT
-	 && (dev->target->flags & AHD_DV_REQUIRED) != 0)
+	if (aic_get_transaction_status(scb) != CAM_SEL_TIMEOUT
+	 && (dev->target->flags & AIC_DV_REQUIRED) != 0)
 		ahd_linux_start_dv(ahd);
 
 	if (dev->openings == 1
-	 && ahd_get_transaction_status(scb) == CAM_REQ_CMP
-	 && ahd_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)
+	 && aic_get_transaction_status(scb) == CAM_REQ_CMP
+	 && aic_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)
 		dev->tag_success_count++;
 	/*
 	 * Some devices deal with temporary internal resource
@@ -4502,7 +4559,7 @@ ahd_done(struct ahd_softc *ahd, struct s
 	 * back to our previous queue depth.
 	 */
 	if ((dev->openings + dev->active) < dev->maxtags
-	 && dev->tag_success_count > AHD_TAG_SUCCESS_INTERVAL) {
+	 && dev->tag_success_count > AIC_TAG_SUCCESS_INTERVAL) {
 		dev->tag_success_count = 0;
 		dev->openings++;
 	}
@@ -4511,39 +4568,68 @@ ahd_done(struct ahd_softc *ahd, struct s
 		dev->commands_since_idle_or_otag = 0;
 
 	if (TAILQ_EMPTY(&dev->busyq)) {
-		if ((dev->flags & AHD_DEV_UNCONFIGURED) != 0
-		 && dev->active == 0
-		 && (dev->flags & AHD_DEV_TIMER_ACTIVE) == 0)
+		if ((dev->flags & AIC_DEV_UNCONFIGURED) != 0
+		 && dev->active == 0)
 			ahd_linux_free_device(ahd, dev);
-	} else if ((dev->flags & AHD_DEV_ON_RUN_LIST) == 0) {
+	} else if ((dev->flags & AIC_DEV_ON_RUN_LIST) == 0) {
 		TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq, dev, links);
-		dev->flags |= AHD_DEV_ON_RUN_LIST;
+		dev->flags |= AIC_DEV_ON_RUN_LIST;
 	}
 
 	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
 		printf("Recovery SCB completes\n");
-		if (ahd_get_transaction_status(scb) == CAM_BDR_SENT
-		 || ahd_get_transaction_status(scb) == CAM_REQ_ABORTED)
-			ahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);
-		if ((scb->platform_data->flags & AHD_SCB_UP_EH_SEM) != 0) {
-			scb->platform_data->flags &= ~AHD_SCB_UP_EH_SEM;
+		if (aic_get_transaction_status(scb) == CAM_BDR_SENT
+		 || aic_get_transaction_status(scb) == CAM_REQ_ABORTED)
+			aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+		if ((scb->platform_data->flags & AIC_SCB_UP_EH_SEM) != 0) {
+			scb->platform_data->flags &= ~AIC_SCB_UP_EH_SEM;
 			up(&ahd->platform_data->eh_sem);
+		} else {
+			struct  scb *list_scb;
+
+			/*
+			 * We were able to complete the command successfully,
+			 * so reinstate the timeouts for all other pending
+			 * commands.
+			 */
+			LIST_FOREACH(list_scb,
+				     &ahd->pending_scbs, pending_links) {
+
+				aic_scb_timer_start(list_scb);
+                	}
 		}
 	}
 
+	if ((scb->platform_data->flags & AIC_TIMEOUT_ACTIVE) == 0) {
+		/*
+		 * The completion handler believes that
+		 * commands without active timers running
+		 * have lost the race of completing before
+		 * their timer expires.  Since commands in
+		 * our busy queues do not have timers running,
+		 * appease the mid-layer by adding a timer
+		 * now.  This timer will be immediately
+		 * canceled by the midlayer.
+		 */
+		scsi_add_timer(cmd, 60*HZ, aic_linux_midlayer_timeout);
+	}
+
+	if ((scb->platform_data->flags & AIC_RELEASE_SIMQ) != 0)
+		aic_release_simq_locked(ahd);
+
 	ahd_free_scb(ahd, scb);
 	ahd_linux_queue_cmd_complete(ahd, cmd);
 
-	if ((ahd->platform_data->flags & AHD_DV_WAIT_SIMQ_EMPTY) != 0
+	if ((ahd->platform_data->flags & AIC_DV_WAIT_SIMQ_EMPTY) != 0
 	 && LIST_FIRST(&ahd->pending_scbs) == NULL) {
-		ahd->platform_data->flags &= ~AHD_DV_WAIT_SIMQ_EMPTY;
+		ahd->platform_data->flags &= ~AIC_DV_WAIT_SIMQ_EMPTY;
 		up(&ahd->platform_data->dv_sem);
 	}
 }
 
 static void
 ahd_linux_handle_scsi_status(struct ahd_softc *ahd,
-			     struct ahd_linux_device *dev, struct scb *scb)
+			     struct aic_linux_device *dev, struct scb *scb)
 {
 	struct	ahd_devinfo devinfo;
 
@@ -4563,7 +4649,7 @@ ahd_linux_handle_scsi_status(struct ahd_
 	 * we don't clobber the device with too many
 	 * commands.
 	 */
-	switch (ahd_get_scsi_status(scb)) {
+	switch (aic_get_scsi_status(scb)) {
 	default:
 		break;
 	case SCSI_STATUS_CHECK_COND:
@@ -4577,13 +4663,15 @@ ahd_linux_handle_scsi_status(struct ahd_
 		 */
 		cmd = scb->io_ctx;
 		if ((scb->flags & (SCB_SENSE|SCB_PKT_SENSE)) != 0) {
-			struct scsi_status_iu_header *siu;
-			u_int sense_size;
-			u_int sense_offset;
+			struct	scsi_status_iu_header *siu;
+			struct	scsi_sense_data *sense;
+			u_int	sense_size;
+			u_int	sense_offset;
+			int	error_code, sense_key, asc, ascq;
 
 			if (scb->flags & SCB_SENSE) {
 				sense_size = MIN(sizeof(struct scsi_sense_data)
-					       - ahd_get_sense_residual(scb),
+					       - aic_get_sense_residual(scb),
 						 sizeof(cmd->sense_buffer));
 				sense_offset = 0;
 			} else {
@@ -4598,10 +4686,10 @@ ahd_linux_handle_scsi_status(struct ahd_
 				sense_offset = SIU_SENSE_OFFSET(siu);
 			}
 
+			sense = (struct scsi_sense_data *)
+			    (ahd_get_sense_buf(ahd, scb) + sense_offset);
 			memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
-			memcpy(cmd->sense_buffer,
-			       ahd_get_sense_buf(ahd, scb)
-			       + sense_offset, sense_size);
+			memcpy(cmd->sense_buffer, sense, sense_size);
 			cmd->result |= (DRIVER_SENSE << 24);
 
 #ifdef AHD_DEBUG
@@ -4618,6 +4706,23 @@ ahd_linux_handle_scsi_status(struct ahd_
 				printf("\n");
 			}
 #endif
+			/*
+			 * If this is not a DV command and the target
+			 * provides some status that makes us believe
+			 * that the target has changed (power on reset,
+			 * etc.) kick off a DV scan to re-validate the
+			 * device.
+			 */
+	 		if (AIC_DV_CMD(cmd) != 0)
+				break;
+
+			scsi_extract_sense(sense, &error_code,
+					   &sense_key, &asc, &ascq);
+			if (error_code == SSD_CURRENT_ERROR
+			 && sense_key == SSD_KEY_UNIT_ATTENTION
+			 && asc == 0x29
+			 && (ascq == 0 || ascq == 1))
+				dev->target->flags |= AIC_DV_REQUIRED;
 		}
 		break;
 	}
@@ -4657,7 +4762,7 @@ ahd_linux_handle_scsi_status(struct ahd_
 				 * this device.
 				 */
 				if (dev->last_queuefull_same_count
-				 == AHD_LOCK_TAGS_COUNT) {
+				 == AIC_LOCK_TAGS_COUNT) {
 					dev->maxtags = dev->active;
 					ahd_print_path(ahd, scb);
 					printf("Locking max tag count at %d\n",
@@ -4667,10 +4772,10 @@ ahd_linux_handle_scsi_status(struct ahd_
 				dev->tags_on_last_queuefull = dev->active;
 				dev->last_queuefull_same_count = 0;
 			}
-			ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
-			ahd_set_scsi_status(scb, SCSI_STATUS_OK);
+			aic_set_transaction_status(scb, CAM_REQUEUE_REQ);
+			aic_set_scsi_status(scb, SCSI_STATUS_OK);
 			ahd_platform_set_tags(ahd, &devinfo,
-				     (dev->flags & AHD_DEV_Q_BASIC)
+				     (dev->flags & AIC_DEV_Q_BASIC)
 				   ? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);
 			break;
 		}
@@ -4680,9 +4785,9 @@ ahd_linux_handle_scsi_status(struct ahd_
 		 */
 		dev->openings = 1;
 		ahd_platform_set_tags(ahd, &devinfo,
-			     (dev->flags & AHD_DEV_Q_BASIC)
+			     (dev->flags & AIC_DEV_Q_BASIC)
 			   ? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);
-		ahd_set_scsi_status(scb, SCSI_STATUS_BUSY);
+		aic_set_scsi_status(scb, SCSI_STATUS_BUSY);
 		/* FALLTHROUGH */
 	}
 	case SCSI_STATUS_BUSY:
@@ -4690,14 +4795,21 @@ ahd_linux_handle_scsi_status(struct ahd_
 		 * Set a short timer to defer sending commands for
 		 * a bit since Linux will not delay in this case.
 		 */
-		if ((dev->flags & AHD_DEV_TIMER_ACTIVE) != 0) {
+		if ((dev->flags & AIC_DEV_TIMER_ACTIVE) != 0) {
 			printf("%s:%c:%d: Device Timer still active during "
 			       "busy processing\n", ahd_name(ahd),
 				dev->target->channel, dev->target->target);
 			break;
 		}
-		dev->flags |= AHD_DEV_TIMER_ACTIVE;
 		dev->qfrozen++;
+		/*
+		 * Keep the active count non-zero during
+		 * the lifetime of the timer.  This
+		 * guarantees that the device will not
+		 * be freed before our timer executes.
+		 */
+		dev->active++;
+		dev->flags |= AIC_DEV_TIMER_ACTIVE;
 		init_timer(&dev->timer);
 		dev->timer.data = (u_long)dev;
 		dev->timer.expires = jiffies + (HZ/2);
@@ -4722,9 +4834,9 @@ ahd_linux_queue_cmd_complete(struct ahd_
 	 * not guarantee the order that aborted commands will be
 	 * returned to us.
 	 */
-	struct ahd_completeq *completeq;
-	struct ahd_cmd *list_cmd;
-	struct ahd_cmd *acmd;
+	struct aic_completeq *completeq;
+	struct aic_cmd *list_cmd;
+	struct aic_cmd *acmd;
 
 	/*
 	 * Map CAM error codes into Linux Error codes.  We
@@ -4732,13 +4844,13 @@ ahd_linux_queue_cmd_complete(struct ahd_
 	 * full error information available when making
 	 * state change decisions.
 	 */
-	if (AHD_DV_CMD(cmd) == FALSE) {
+	if (AIC_DV_CMD(cmd) == FALSE) {
 		uint32_t status;
 		u_int new_status;
 
-		status = ahd_cmd_get_transaction_status(cmd);
+		status = aic_cmd_get_transaction_status(cmd);
 		if (status != CAM_REQ_CMP) {
-			struct ahd_linux_device *dev;
+			struct aic_linux_device *dev;
 			struct ahd_devinfo devinfo;
 			cam_status cam_status;
 			uint32_t action;
@@ -4758,8 +4870,8 @@ ahd_linux_queue_cmd_complete(struct ahd_
 					    dev->target->channel == 0 ? 'A':'B',
 					    ROLE_INITIATOR);
 
-			scsi_status = ahd_cmd_get_scsi_status(cmd);
-			cam_status = ahd_cmd_get_transaction_status(cmd);
+			scsi_status = aic_cmd_get_scsi_status(cmd);
+			cam_status = aic_cmd_get_transaction_status(cmd);
 			action = aic_error_action(cmd, dev->target->inq_data,
 						  cam_status, scsi_status);
 			if ((action & SSQ_FALLBACK) != 0) {
@@ -4802,7 +4914,17 @@ no_fallback:
 			new_status = DID_PARITY;
 			break;
 		case CAM_CMD_TIMEOUT:
-			new_status = DID_TIME_OUT;
+			/*
+			 *  Returning DID_TIME_OUT will 
+			 *  wake up the error recovery
+			 *  thread instead of doing the
+			 *  command retry we desire. Since
+			 *  we have already recovered the
+			 *  command, returning DID_ERROR
+			 *  will cause a retry up to the
+			 *  retry limit for this command.
+			 */
+			new_status = DID_ERROR;
 			break;
 		case CAM_UA_ABORT:
 		case CAM_REQ_CMP_ERR:
@@ -4832,7 +4954,7 @@ no_fallback:
 			if (cmd->retries > 0)
 				cmd->retries--;
 			new_status = DID_OK;
-			ahd_cmd_set_scsi_status(cmd, SCSI_STATUS_CHECK_COND);
+			aic_cmd_set_scsi_status(cmd, SCSI_STATUS_CHECK_COND);
 			cmd->result |= (DRIVER_SENSE << 24);
 			memset(cmd->sense_buffer, 0,
 			       sizeof(cmd->sense_buffer));
@@ -4846,12 +4968,21 @@ no_fallback:
 			break;
 		}
 
-		ahd_cmd_set_transaction_status(cmd, new_status);
+		aic_cmd_set_transaction_status(cmd, new_status);
+	}
+
+	/*
+	 * Commands that have completed successfully
+	 * can be completed to the OS immediately.
+	 */
+	if (cmd->result == (DID_OK << 16)) {
+		cmd->scsi_done(cmd);
+		return;
 	}
 
 	completeq = &ahd->platform_data->completeq;
 	list_cmd = TAILQ_FIRST(completeq);
-	acmd = (struct ahd_cmd *)cmd;
+	acmd = (struct aic_cmd *)cmd;
 	while (list_cmd != NULL
 	    && acmd_scsi_cmd(list_cmd).serial_number
 	     < acmd_scsi_cmd(acmd).serial_number)
@@ -4871,7 +5002,7 @@ ahd_linux_filter_inquiry(struct ahd_soft
 	struct	ahd_transinfo *goal;
 	struct	ahd_transinfo *curr;
 	struct	ahd_tmode_tstate *tstate;
-	struct	ahd_linux_device *dev;
+	struct	aic_linux_device *dev;
 	u_int	width;
 	u_int	period;
 	u_int	offset;
@@ -4893,9 +5024,9 @@ ahd_linux_filter_inquiry(struct ahd_soft
 	sid = (struct scsi_inquiry_data *)dev->target->inq_data;
 	if (SID_QUAL(sid) == SID_QUAL_LU_CONNECTED) {
 
-		dev->flags &= ~AHD_DEV_UNCONFIGURED;
+		dev->flags &= ~AIC_DEV_UNCONFIGURED;
 	} else {
-		dev->flags |= AHD_DEV_UNCONFIGURED;
+		dev->flags |= AIC_DEV_UNCONFIGURED;
 		return;
 	}
 
@@ -4961,48 +5092,6 @@ ahd_linux_filter_inquiry(struct ahd_soft
 			 AHD_TRANS_GOAL, /*paused*/FALSE);
 }
 
-void
-ahd_freeze_simq(struct ahd_softc *ahd)
-{
-	ahd->platform_data->qfrozen++;
-	if (ahd->platform_data->qfrozen == 1) {
-		scsi_block_requests(ahd->platform_data->host);
-		ahd_platform_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
-					CAM_LUN_WILDCARD, SCB_LIST_NULL,
-					ROLE_INITIATOR, CAM_REQUEUE_REQ);
-	}
-}
-
-void
-ahd_release_simq(struct ahd_softc *ahd)
-{
-	u_long s;
-	int    unblock_reqs;
-
-	unblock_reqs = 0;
-	ahd_lock(ahd, &s);
-	if (ahd->platform_data->qfrozen > 0)
-		ahd->platform_data->qfrozen--;
-	if (ahd->platform_data->qfrozen == 0) {
-		unblock_reqs = 1;
-	}
-	if (AHD_DV_SIMQ_FROZEN(ahd)
-	 && ((ahd->platform_data->flags & AHD_DV_WAIT_SIMQ_RELEASE) != 0)) {
-		ahd->platform_data->flags &= ~AHD_DV_WAIT_SIMQ_RELEASE;
-		up(&ahd->platform_data->dv_sem);
-	}
-	ahd_schedule_runq(ahd);
-	ahd_unlock(ahd, &s);
-	/*
-	 * There is still a race here.  The mid-layer
-	 * should keep its own freeze count and use
-	 * a bottom half handler to run the queues
-	 * so we can unblock with our own lock held.
-	 */
-	if (unblock_reqs)
-		scsi_unblock_requests(ahd->platform_data->host);
-}
-
 static void
 ahd_linux_sem_timeout(u_long arg)
 {
@@ -5013,8 +5102,8 @@ ahd_linux_sem_timeout(u_long arg)
 	scb = (struct scb *)arg;
 	ahd = scb->ahd_softc;
 	ahd_lock(ahd, &s);
-	if ((scb->platform_data->flags & AHD_SCB_UP_EH_SEM) != 0) {
-		scb->platform_data->flags &= ~AHD_SCB_UP_EH_SEM;
+	if ((scb->platform_data->flags & AIC_SCB_UP_EH_SEM) != 0) {
+		scb->platform_data->flags &= ~AIC_SCB_UP_EH_SEM;
 		up(&ahd->platform_data->eh_sem);
 	}
 	ahd_unlock(ahd, &s);
@@ -5023,39 +5112,92 @@ ahd_linux_sem_timeout(u_long arg)
 static void
 ahd_linux_dev_timed_unfreeze(u_long arg)
 {
-	struct ahd_linux_device *dev;
+	struct aic_linux_device *dev;
 	struct ahd_softc *ahd;
 	u_long s;
 
-	dev = (struct ahd_linux_device *)arg;
-	ahd = dev->target->ahd;
+	dev = (struct aic_linux_device *)arg;
+	ahd = dev->target->softc;
 	ahd_lock(ahd, &s);
-	dev->flags &= ~AHD_DEV_TIMER_ACTIVE;
+
+	/*
+	 * Release our hold on the device.
+	 */
+	dev->flags &= ~AIC_DEV_TIMER_ACTIVE;
+	dev->active--;
+
 	if (dev->qfrozen > 0)
 		dev->qfrozen--;
 	if (dev->qfrozen == 0
-	 && (dev->flags & AHD_DEV_ON_RUN_LIST) == 0)
+	 && dev->target->qfrozen == 0
+	 && (dev->flags & AIC_DEV_ON_RUN_LIST) == 0)
 		ahd_linux_run_device_queue(ahd, dev);
-	if ((dev->flags & AHD_DEV_UNCONFIGURED) != 0
+	if ((dev->flags & AIC_DEV_UNCONFIGURED) != 0
+	 && TAILQ_EMPTY(&dev->busyq)
 	 && dev->active == 0)
 		ahd_linux_free_device(ahd, dev);
 	ahd_unlock(ahd, &s);
 }
 
+static void
+ahd_linux_targ_timed_unfreeze(u_long arg)
+{
+	struct aic_linux_target *targ;
+	struct ahd_softc *ahd;
+	u_long s;
+
+	targ = (struct aic_linux_target *)arg;
+	ahd = targ->softc;
+	ahd_lock(ahd, &s);
+
+	/*
+	 * Release our hold on the target.
+	 */
+	targ->flags &= ~AIC_TARG_TIMER_ACTIVE;
+	targ->refcount--;
+
+	if (targ->qfrozen > 0)
+		targ->qfrozen--;
+	if (targ->qfrozen == 0) {
+		u_int i;
+
+		for (i = 0; i < AHD_NUM_LUNS; i++) {
+			struct aic_linux_device *dev;
+		
+			dev = targ->devices[i];
+			if (dev == NULL
+	 		 || (dev->flags & AIC_DEV_ON_RUN_LIST) != 0)
+				continue;
+
+			aic_linux_check_device_queue(ahd, dev);
+		}
+	}
+	ahd_unlock(ahd, &s);
+}
+
 void
 ahd_platform_dump_card_state(struct ahd_softc *ahd)
 {
-	struct ahd_linux_device *dev;
+	struct Scsi_Host *host;
+	struct aic_linux_device *dev;
 	int target;
 	int maxtarget;
 	int lun;
 	int i;
 
+	host = ahd->platform_data->host;
+	printf("%s: Host Status: Failed(%d) %s%s%s\n",
+	       ahd_name(ahd),
+	       host->host_failed,
+	       host->eh_active ? "eh_active " : "",
+	       host->host_blocked ? "host_blocked " : "",
+	       host->host_self_blocked ? "host_self_blocked " : "");
+	       
 	maxtarget = (ahd->features & AHD_WIDE) ? 15 : 7;
 	for (target = 0; target <=maxtarget; target++) {
 
 		for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
-			struct ahd_cmd *acmd;
+			struct aic_cmd *acmd;
 
 			dev = ahd_linux_get_device(ahd, 0, target,
 						   lun, /*alloc*/FALSE);
@@ -5076,38 +5218,48 @@ ahd_platform_dump_card_state(struct ahd_
 static int __init
 ahd_linux_init(void)
 {
+	int	found;
+
+	ahd_sysrq_key = aic_install_sysrq(&ahd_sysrq_op);
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-       return (ahd_linux_detect(&aic79xx_driver_template) ? 0 : -ENODEV);
+	found = ahd_linux_detect(&aic79xx_driver_template);
 #else
 	scsi_register_module(MODULE_SCSI_HA, &aic79xx_driver_template);
-	if (aic79xx_driver_template.present == 0) {
-		scsi_unregister_module(MODULE_SCSI_HA,
-				       &aic79xx_driver_template);
-		return (-ENODEV);
-	}
-
-	return (0);
+	found = aic79xx_driver_template.present;
 #endif
+#ifdef MODULE
+	if (found == 0)
+		ahd_init_status = -ENODEV;
+#endif
+	if (ahd_init_status != 0) {
+		/*
+		 * Linux will not call our exit
+		 * routine if we fail to load.
+		 * Force cleanup if initialization
+		 * is not successful.
+		 */
+		ahd_linux_exit();
+	}
+	return (ahd_init_status);
 }
 
-static void __exit
+static void 
 ahd_linux_exit(void)
 {
 	struct ahd_softc *ahd;
-	u_long l;
 
 	/*
-	 * Shutdown DV threads before going into the SCSI mid-layer.
+	 * Shutdown our threads before going into the SCSI mid-layer.
 	 * This avoids situations where the mid-layer locks the entire
 	 * kernel so that waiting for our DV threads to exit leads
 	 * to deadlock.
 	 */
-	ahd_list_lock(&l);
 	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
 
 		ahd_linux_kill_dv_thread(ahd);
+		ahd_terminate_recovery_thread(ahd);
 	}
-	ahd_list_unlock(&l);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 	/*
 	 * In 2.4 we have to unregister from the PCI core _after_
@@ -5117,6 +5269,8 @@ ahd_linux_exit(void)
 	scsi_unregister_module(MODULE_SCSI_HA, &aic79xx_driver_template);
 #endif
 	ahd_linux_pci_exit();
+
+	aic_remove_sysrq(ahd_sysrq_key, &ahd_sysrq_op);
 }
 
 module_init(ahd_linux_init);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_osm.h linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_osm.h
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_osm.h	2004-04-04 05:37:24.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_osm.h	2004-05-13 16:42:17.000000000 +0200
@@ -36,50 +36,19 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#137 $
+ * $Id$
  *
  */
 #ifndef _AIC79XX_LINUX_H_
 #define _AIC79XX_LINUX_H_
 
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/pci.h>
-#include <linux/smp_lock.h>
 #include <linux/version.h>
-#include <linux/module.h>
-#include <asm/byteorder.h>
-#include <asm/io.h>
 
 #ifndef KERNEL_VERSION
 #define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-#include <linux/interrupt.h> /* For tasklet support. */
 #include <linux/config.h>
-#include <linux/slab.h>
-#else
-#include <linux/malloc.h>
-#endif
-
-/* Core SCSI definitions */
-#define AIC_LIB_PREFIX ahd
-#include "scsi.h"
-#include "hosts.h"
-
-/* Name space conflict with BSD queue macros */
-#ifdef LIST_HEAD
-#undef LIST_HEAD
-#endif
-
-#include "cam.h"
-#include "queue.h"
-#include "scsi_message.h"
-#include "scsi_iu.h"
-#include "aiclib.h"
 
 /*********************************** Debugging ********************************/
 #ifdef CONFIG_AIC79XX_DEBUG_ENABLE
@@ -96,188 +65,27 @@
 /* No debugging code. */
 #endif
 
-/********************************** Misc Macros *******************************/
-#define	roundup(x, y)   ((((x)+((y)-1))/(y))*(y))
-#define	powerof2(x)	((((x)-1)&(x))==0)
-
-/************************* Forward Declarations *******************************/
-struct ahd_softc;
-typedef struct pci_dev *ahd_dev_softc_t;
-typedef Scsi_Cmnd      *ahd_io_ctx_t;
-
-/******************************* Byte Order ***********************************/
-#define ahd_htobe16(x)	cpu_to_be16(x)
-#define ahd_htobe32(x)	cpu_to_be32(x)
-#define ahd_htobe64(x)	cpu_to_be64(x)
-#define ahd_htole16(x)	cpu_to_le16(x)
-#define ahd_htole32(x)	cpu_to_le32(x)
-#define ahd_htole64(x)	cpu_to_le64(x)
-
-#define ahd_be16toh(x)	be16_to_cpu(x)
-#define ahd_be32toh(x)	be32_to_cpu(x)
-#define ahd_be64toh(x)	be64_to_cpu(x)
-#define ahd_le16toh(x)	le16_to_cpu(x)
-#define ahd_le32toh(x)	le32_to_cpu(x)
-#define ahd_le64toh(x)	le64_to_cpu(x)
-
-#ifndef LITTLE_ENDIAN
-#define LITTLE_ENDIAN 1234
-#endif
-
-#ifndef BIG_ENDIAN
-#define BIG_ENDIAN 4321
-#endif
-
-#ifndef BYTE_ORDER
-#if defined(__BIG_ENDIAN)
-#define BYTE_ORDER BIG_ENDIAN
-#endif
-#if defined(__LITTLE_ENDIAN)
-#define BYTE_ORDER LITTLE_ENDIAN
-#endif
-#endif /* BYTE_ORDER */
-
-/************************* Configuration Data *********************************/
-extern uint32_t aic79xx_allow_memio;
-extern int aic79xx_detect_complete;
-extern Scsi_Host_Template aic79xx_driver_template;
-
-/***************************** Bus Space/DMA **********************************/
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,17)
-typedef dma_addr_t bus_addr_t;
-#else
-typedef uint32_t bus_addr_t;
-#endif
-typedef uint32_t bus_size_t;
-
-typedef enum {
-	BUS_SPACE_MEMIO,
-	BUS_SPACE_PIO
-} bus_space_tag_t;
-
-typedef union {
-	u_long		  ioport;
-	volatile uint8_t *maddr;
-} bus_space_handle_t;
-
-typedef struct bus_dma_segment
-{
-	bus_addr_t	ds_addr;
-	bus_size_t	ds_len;
-} bus_dma_segment_t;
-
-struct ahd_linux_dma_tag
-{
-	bus_size_t	alignment;
-	bus_size_t	boundary;
-	bus_size_t	maxsize;
-};
-typedef struct ahd_linux_dma_tag* bus_dma_tag_t;
-
-struct ahd_linux_dmamap
-{
-	bus_addr_t	bus_addr;
-};
-typedef struct ahd_linux_dmamap* bus_dmamap_t;
-
-typedef int bus_dma_filter_t(void*, bus_addr_t);
-typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);
-
-#define BUS_DMA_WAITOK		0x0
-#define BUS_DMA_NOWAIT		0x1
-#define BUS_DMA_ALLOCNOW	0x2
-#define BUS_DMA_LOAD_SEGS	0x4	/*
-					 * Argument is an S/G list not
-					 * a single buffer.
-					 */
-
-#define BUS_SPACE_MAXADDR	0xFFFFFFFF
-#define BUS_SPACE_MAXADDR_32BIT	0xFFFFFFFF
-#define BUS_SPACE_MAXSIZE_32BIT	0xFFFFFFFF
-
-int	ahd_dma_tag_create(struct ahd_softc *, bus_dma_tag_t /*parent*/,
-			   bus_size_t /*alignment*/, bus_size_t /*boundary*/,
-			   bus_addr_t /*lowaddr*/, bus_addr_t /*highaddr*/,
-			   bus_dma_filter_t*/*filter*/, void */*filterarg*/,
-			   bus_size_t /*maxsize*/, int /*nsegments*/,
-			   bus_size_t /*maxsegsz*/, int /*flags*/,
-			   bus_dma_tag_t */*dma_tagp*/);
-
-void	ahd_dma_tag_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/);
-
-int	ahd_dmamem_alloc(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
-			 void** /*vaddr*/, int /*flags*/,
-			 bus_dmamap_t* /*mapp*/);
-
-void	ahd_dmamem_free(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
-			void* /*vaddr*/, bus_dmamap_t /*map*/);
-
-void	ahd_dmamap_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/,
-			   bus_dmamap_t /*map*/);
-
-int	ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t /*dmat*/,
-			bus_dmamap_t /*map*/, void * /*buf*/,
-			bus_size_t /*buflen*/, bus_dmamap_callback_t *,
-			void */*callback_arg*/, int /*flags*/);
-
-int	ahd_dmamap_unload(struct ahd_softc *, bus_dma_tag_t, bus_dmamap_t);
-
-/*
- * Operations performed by ahd_dmamap_sync().
- */
-#define BUS_DMASYNC_PREREAD	0x01	/* pre-read synchronization */
-#define BUS_DMASYNC_POSTREAD	0x02	/* post-read synchronization */
-#define BUS_DMASYNC_PREWRITE	0x04	/* pre-write synchronization */
-#define BUS_DMASYNC_POSTWRITE	0x08	/* post-write synchronization */
-
-/*
- * XXX
- * ahd_dmamap_sync is only used on buffers allocated with
- * the pci_alloc_consistent() API.  Although I'm not sure how
- * this works on architectures with a write buffer, Linux does
- * not have an API to sync "coherent" memory.  Perhaps we need
- * to do an mb()?
- */
-#define ahd_dmamap_sync(ahd, dma_tag, dmamap, offset, len, op)
-
-/************************** Timer DataStructures ******************************/
-typedef struct timer_list ahd_timer_t;
-
 /********************************** Includes **********************************/
+/* Core SCSI definitions */
+#define AIC_LIB_PREFIX ahd
+#define AIC_CONST_PREFIX AHD
+
 #ifdef CONFIG_AIC79XX_REG_PRETTY_PRINT
 #define AIC_DEBUG_REGISTERS 1
 #else
 #define AIC_DEBUG_REGISTERS 0
 #endif
-#include "aic79xx.h"
-
-/***************************** Timer Facilities *******************************/
-#define ahd_timer_init init_timer
-#define ahd_timer_stop del_timer_sync
-typedef void ahd_linux_callback_t (u_long);  
-static __inline void ahd_timer_reset(ahd_timer_t *timer, u_int usec,
-				     ahd_callback_t *func, void *arg);
-static __inline void ahd_scb_timer_reset(struct scb *scb, u_int usec);
-
-static __inline void
-ahd_timer_reset(ahd_timer_t *timer, u_int usec, ahd_callback_t *func, void *arg)
-{
-	struct ahd_softc *ahd;
+#define AIC_CORE_INCLUDE "aic79xx.h"
+#include "aiclib.h"
 
-	ahd = (struct ahd_softc *)arg;
-	del_timer(timer);
-	timer->data = (u_long)arg;
-	timer->expires = jiffies + (usec * HZ)/1000000;
-	timer->function = (ahd_linux_callback_t*)func;
-	add_timer(timer);
-}
+/************************* Configuration Data *********************************/
+extern uint32_t aic79xx_allow_memio;
+extern int aic79xx_detect_complete;
+extern Scsi_Host_Template aic79xx_driver_template;
 
-static __inline void
-ahd_scb_timer_reset(struct scb *scb, u_int usec)
-{
-	mod_timer(&scb->io_ctx->eh_timeout, jiffies + (usec * HZ)/1000000);
-}
+/***************************** Domain Validation ******************************/
+void ahd_linux_dv_complete(Scsi_Cmnd *cmd);
+void ahd_linux_dv_timeout(struct scsi_cmnd *cmd);
 
 /***************************** SMP support ************************************/
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
@@ -286,199 +94,7 @@ ahd_scb_timer_reset(struct scb *scb, u_i
 #include <linux/smp.h>
 #endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) || defined(SCSI_HAS_HOST_LOCK))
-#define AHD_SCSI_HAS_HOST_LOCK 1
-#else
-#define AHD_SCSI_HAS_HOST_LOCK 0
-#endif
-
-#define AIC79XX_DRIVER_VERSION "1.3.11"
-
-/**************************** Front End Queues ********************************/
-/*
- * Data structure used to cast the Linux struct scsi_cmnd to something
- * that allows us to use the queue macros.  The linux structure has
- * plenty of space to hold the links fields as required by the queue
- * macros, but the queue macors require them to have the correct type.
- */
-struct ahd_cmd_internal {
-	/* Area owned by the Linux scsi layer. */
-	uint8_t	private[offsetof(struct scsi_cmnd, SCp.Status)];
-	union {
-		STAILQ_ENTRY(ahd_cmd)	ste;
-		LIST_ENTRY(ahd_cmd)	le;
-		TAILQ_ENTRY(ahd_cmd)	tqe;
-	} links;
-	uint32_t			end;
-};
-
-struct ahd_cmd {
-	union {
-		struct ahd_cmd_internal	icmd;
-		struct scsi_cmnd	scsi_cmd;
-	} un;
-};
-
-#define acmd_icmd(cmd) ((cmd)->un.icmd)
-#define acmd_scsi_cmd(cmd) ((cmd)->un.scsi_cmd)
-#define acmd_links un.icmd.links
-
-/*************************** Device Data Structures ***************************/
-/*
- * A per probed device structure used to deal with some error recovery
- * scenarios that the Linux mid-layer code just doesn't know how to
- * handle.  The structure allocated for a device only becomes persistent
- * after a successfully completed inquiry command to the target when
- * that inquiry data indicates a lun is present.
- */
-TAILQ_HEAD(ahd_busyq, ahd_cmd);
-typedef enum {
-	AHD_DEV_UNCONFIGURED	 = 0x01,
-	AHD_DEV_FREEZE_TIL_EMPTY = 0x02, /* Freeze queue until active == 0 */
-	AHD_DEV_TIMER_ACTIVE	 = 0x04, /* Our timer is active */
-	AHD_DEV_ON_RUN_LIST	 = 0x08, /* Queued to be run later */
-	AHD_DEV_Q_BASIC		 = 0x10, /* Allow basic device queuing */
-	AHD_DEV_Q_TAGGED	 = 0x20, /* Allow full SCSI2 command queueing */
-	AHD_DEV_PERIODIC_OTAG	 = 0x40, /* Send OTAG to prevent starvation */
-	AHD_DEV_SLAVE_CONFIGURED = 0x80	 /* slave_configure() has been called */
-} ahd_linux_dev_flags;
-
-struct ahd_linux_target;
-struct ahd_linux_device {
-	TAILQ_ENTRY(ahd_linux_device) links;
-	struct			ahd_busyq busyq;
-
-	/*
-	 * The number of transactions currently
-	 * queued to the device.
-	 */
-	int			active;
-
-	/*
-	 * The currently allowed number of 
-	 * transactions that can be queued to
-	 * the device.  Must be signed for
-	 * conversion from tagged to untagged
-	 * mode where the device may have more
-	 * than one outstanding active transaction.
-	 */
-	int			openings;
-
-	/*
-	 * A positive count indicates that this
-	 * device's queue is halted.
-	 */
-	u_int			qfrozen;
-	
-	/*
-	 * Cumulative command counter.
-	 */
-	u_long			commands_issued;
-
-	/*
-	 * The number of tagged transactions when
-	 * running at our current opening level
-	 * that have been successfully received by
-	 * this device since the last QUEUE FULL.
-	 */
-	u_int			tag_success_count;
-#define AHD_TAG_SUCCESS_INTERVAL 50
-
-	ahd_linux_dev_flags	flags;
-
-	/*
-	 * Per device timer.
-	 */
-	struct timer_list	timer;
-
-	/*
-	 * The high limit for the tags variable.
-	 */
-	u_int			maxtags;
-
-	/*
-	 * The computed number of tags outstanding
-	 * at the time of the last QUEUE FULL event.
-	 */
-	u_int			tags_on_last_queuefull;
-
-	/*
-	 * How many times we have seen a queue full
-	 * with the same number of tags.  This is used
-	 * to stop our adaptive queue depth algorithm
-	 * on devices with a fixed number of tags.
-	 */
-	u_int			last_queuefull_same_count;
-#define AHD_LOCK_TAGS_COUNT 50
-
-	/*
-	 * How many transactions have been queued
-	 * without the device going idle.  We use
-	 * this statistic to determine when to issue
-	 * an ordered tag to prevent transaction
-	 * starvation.  This statistic is only updated
-	 * if the AHD_DEV_PERIODIC_OTAG flag is set
-	 * on this device.
-	 */
-	u_int			commands_since_idle_or_otag;
-#define AHD_OTAG_THRESH	500
-
-	int			lun;
-	Scsi_Device	       *scsi_device;
-	struct			ahd_linux_target *target;
-};
-
-typedef enum {
-	AHD_DV_REQUIRED		 = 0x01,
-	AHD_INQ_VALID		 = 0x02,
-	AHD_BASIC_DV		 = 0x04,
-	AHD_ENHANCED_DV		 = 0x08
-} ahd_linux_targ_flags;
-
-/* DV States */
-typedef enum {
-	AHD_DV_STATE_EXIT = 0,
-	AHD_DV_STATE_INQ_SHORT_ASYNC,
-	AHD_DV_STATE_INQ_ASYNC,
-	AHD_DV_STATE_INQ_ASYNC_VERIFY,
-	AHD_DV_STATE_TUR,
-	AHD_DV_STATE_REBD,
-	AHD_DV_STATE_INQ_VERIFY,
-	AHD_DV_STATE_WEB,
-	AHD_DV_STATE_REB,
-	AHD_DV_STATE_SU,
-	AHD_DV_STATE_BUSY
-} ahd_dv_state;
-
-struct ahd_linux_target {
-	struct ahd_linux_device	 *devices[AHD_NUM_LUNS];
-	int			  channel;
-	int			  target;
-	int			  refcount;
-	struct ahd_transinfo	  last_tinfo;
-	struct ahd_softc	 *ahd;
-	ahd_linux_targ_flags	  flags;
-	struct scsi_inquiry_data *inq_data;
-	/*
-	 * The next "fallback" period to use for narrow/wide transfers.
-	 */
-	uint8_t			  dv_next_narrow_period;
-	uint8_t			  dv_next_wide_period;
-	uint8_t			  dv_max_width;
-	uint8_t			  dv_max_ppr_options;
-	uint8_t			  dv_last_ppr_options;
-	u_int			  dv_echo_size;
-	ahd_dv_state		  dv_state;
-	u_int			  dv_state_retry;
-	uint8_t			 *dv_buffer;
-	uint8_t			 *dv_buffer1;
-
-	/*
-	 * Cumulative counter of errors.
-	 */
-	u_long			errors_detected;
-	u_long			cmds_since_error;
-};
+#define AIC79XX_DRIVER_VERSION "2.0.8"
 
 /********************* Definitions Required by the Core ***********************/
 /*
@@ -500,94 +116,19 @@ extern u_int ahd_linux_nseg;
 #define	AHD_NSEG 128
 #endif
 
-/*
- * Per-SCB OSM storage.
- */
-typedef enum {
-	AHD_SCB_UP_EH_SEM = 0x1
-} ahd_linux_scb_flags;
-
-struct scb_platform_data {
-	struct ahd_linux_device	*dev;
-	bus_addr_t		 buf_busaddr;
-	uint32_t		 xfer_len;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-	uint32_t		 resid;		/* Transfer residual */
-#endif
-	uint32_t		 sense_resid;	/* Auto-Sense residual */
-	ahd_linux_scb_flags	 flags;
-};
-
-/*
- * Define a structure used for each host adapter.  All members are
- * aligned on a boundary >= the size of the member to honor the
- * alignment restrictions of the various platforms supported by
- * this driver.
- */
-typedef enum {
-	AHD_DV_WAIT_SIMQ_EMPTY	 = 0x01,
-	AHD_DV_WAIT_SIMQ_RELEASE = 0x02,
-	AHD_DV_ACTIVE		 = 0x04,
-	AHD_DV_SHUTDOWN		 = 0x08,
-	AHD_RUN_CMPLT_Q_TIMER	 = 0x10
-} ahd_linux_softc_flags;
-
-TAILQ_HEAD(ahd_completeq, ahd_cmd);
-
-struct ahd_platform_data {
-	/*
-	 * Fields accessed from interrupt context.
-	 */
-	struct ahd_linux_target *targets[AHD_NUM_TARGETS]; 
-	TAILQ_HEAD(, ahd_linux_device) device_runq;
-	struct ahd_completeq	 completeq;
-
-	spinlock_t		 spin_lock;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	struct tasklet_struct	 runq_tasklet;
-#endif
-	u_int			 qfrozen;
-	pid_t			 dv_pid;
-	struct timer_list	 completeq_timer;
-	struct timer_list	 reset_timer;
-	struct timer_list	 stats_timer;
-	struct semaphore	 eh_sem;
-	struct semaphore	 dv_sem;
-	struct semaphore	 dv_cmd_sem;	/* XXX This needs to be in
-						 * the target struct
-						 */
-	struct scsi_device	*dv_scsi_dev;
-	struct Scsi_Host        *host;		/* pointer to scsi host */
-#define AHD_LINUX_NOIRQ	((uint32_t)~0)
-	uint32_t		 irq;		/* IRQ for this adapter */
-	uint32_t		 bios_address;
-	uint32_t		 mem_busaddr;	/* Mem Base Addr */
-	bus_addr_t		 hw_dma_mask;
-	ahd_linux_softc_flags	 flags;
-};
-
-/************************** OS Utility Wrappers *******************************/
-#define printf printk
-#define M_NOWAIT GFP_ATOMIC
-#define M_WAITOK 0
-#define malloc(size, type, flags) kmalloc(size, flags)
-#define free(ptr, type) kfree(ptr)
-
-static __inline void ahd_delay(long);
-static __inline void
-ahd_delay(long usec)
-{
-	/*
-	 * udelay on Linux can have problems for
-	 * multi-millisecond waits.  Wait at most
-	 * 1024us per call.
-	 */
-	while (usec > 0) {
-		udelay(usec % 1024);
-		usec -= 1024;
-	}
-}
-
+/************************** Error Recovery ************************************/
+static __inline void	ahd_wakeup_recovery_thread(struct ahd_softc *ahd); 
+  
+static __inline void
+ahd_wakeup_recovery_thread(struct ahd_softc *ahd)
+{ 
+	up(&ahd->platform_data->recovery_sem);
+}
+ 
+int			ahd_spawn_recovery_thread(struct ahd_softc *ahd);
+void			ahd_terminate_recovery_thread(struct ahd_softc *ahd);
+void			ahd_set_recoveryscb(struct ahd_softc *ahd,
+					    struct scb *scb);
 
 /***************************** Low Level I/O **********************************/
 static __inline uint8_t ahd_inb(struct ahd_softc * ahd, long port);
@@ -599,6 +140,7 @@ static __inline void ahd_outsb(struct ah
 			       uint8_t *, int count);
 static __inline void ahd_insb(struct ahd_softc * ahd, long port,
 			       uint8_t *, int count);
+static __inline void ahd_flush_device_writes(struct ahd_softc *);
 
 static __inline uint8_t
 ahd_inb(struct ahd_softc * ahd, long port)
@@ -678,7 +220,15 @@ ahd_insb(struct ahd_softc * ahd, long po
 		*array++ = ahd_inb(ahd, port);
 }
 
+static __inline void
+ahd_flush_device_writes(struct ahd_softc *ahd)
+{
+	/* XXX Is this sufficient for all architectures??? */
+	ahd_inb(ahd, INTSTAT);
+}
+
 /**************************** Initialization **********************************/
+extern int	ahd_init_status;
 int		ahd_linux_register_host(struct ahd_softc *,
 					Scsi_Host_Template *);
 
@@ -695,184 +245,8 @@ struct info_str {
 void	ahd_format_transinfo(struct info_str *info,
 			     struct ahd_transinfo *tinfo);
 
-/******************************** Locking *************************************/
-/* Lock protecting internal data structures */
-static __inline void ahd_lockinit(struct ahd_softc *);
-static __inline void ahd_lock(struct ahd_softc *, unsigned long *flags);
-static __inline void ahd_unlock(struct ahd_softc *, unsigned long *flags);
-
-/* Lock acquisition and release of the above lock in midlayer entry points. */
-static __inline void ahd_midlayer_entrypoint_lock(struct ahd_softc *,
-						  unsigned long *flags);
-static __inline void ahd_midlayer_entrypoint_unlock(struct ahd_softc *,
-						    unsigned long *flags);
-
-/* Lock held during command compeletion to the upper layer */
-static __inline void ahd_done_lockinit(struct ahd_softc *);
-static __inline void ahd_done_lock(struct ahd_softc *, unsigned long *flags);
-static __inline void ahd_done_unlock(struct ahd_softc *, unsigned long *flags);
-
-/* Lock held during ahd_list manipulation and ahd softc frees */
-extern spinlock_t ahd_list_spinlock;
-static __inline void ahd_list_lockinit(void);
-static __inline void ahd_list_lock(unsigned long *flags);
-static __inline void ahd_list_unlock(unsigned long *flags);
-
-static __inline void
-ahd_lockinit(struct ahd_softc *ahd)
-{
-	spin_lock_init(&ahd->platform_data->spin_lock);
-}
-
-static __inline void
-ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	spin_lock_irqsave(&ahd->platform_data->spin_lock, *flags);
-}
-
-static __inline void
-ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	spin_unlock_irqrestore(&ahd->platform_data->spin_lock, *flags);
-}
-
-static __inline void
-ahd_midlayer_entrypoint_lock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	/*
-	 * In 2.5.X and some 2.4.X versions, the midlayer takes our
-	 * lock just before calling us, so we avoid locking again.
-	 * For other kernel versions, the io_request_lock is taken
-	 * just before our entry point is called.  In this case, we
-	 * trade the io_request_lock for our per-softc lock.
-	 */
-#if AHD_SCSI_HAS_HOST_LOCK == 0
-	spin_unlock(&io_request_lock);
-	spin_lock(&ahd->platform_data->spin_lock);
-#endif
-}
-
-static __inline void
-ahd_midlayer_entrypoint_unlock(struct ahd_softc *ahd, unsigned long *flags)
-{
-#if AHD_SCSI_HAS_HOST_LOCK == 0
-	spin_unlock(&ahd->platform_data->spin_lock);
-	spin_lock(&io_request_lock);
-#endif
-}
-
-static __inline void
-ahd_done_lockinit(struct ahd_softc *ahd)
-{
-	/*
-	 * In 2.5.X, our own lock is held during completions.
-	 * In previous versions, the io_request_lock is used.
-	 * In either case, we can't initialize this lock again.
-	 */
-}
-
-static __inline void
-ahd_done_lock(struct ahd_softc *ahd, unsigned long *flags)
-{
-#if AHD_SCSI_HAS_HOST_LOCK == 0
-	spin_lock(&io_request_lock);
-#endif
-}
-
-static __inline void
-ahd_done_unlock(struct ahd_softc *ahd, unsigned long *flags)
-{
-#if AHD_SCSI_HAS_HOST_LOCK == 0
-	spin_unlock(&io_request_lock);
-#endif
-}
-
-static __inline void
-ahd_list_lockinit()
-{
-	spin_lock_init(&ahd_list_spinlock);
-}
-
-static __inline void
-ahd_list_lock(unsigned long *flags)
-{
-	spin_lock_irqsave(&ahd_list_spinlock, *flags);
-}
-
-static __inline void
-ahd_list_unlock(unsigned long *flags)
-{
-	spin_unlock_irqrestore(&ahd_list_spinlock, *flags);
-}
-
 /******************************* PCI Definitions ******************************/
-/*
- * PCIM_xxx: mask to locate subfield in register
- * PCIR_xxx: config register offset
- * PCIC_xxx: device class
- * PCIS_xxx: device subclass
- * PCIP_xxx: device programming interface
- * PCIV_xxx: PCI vendor ID (only required to fixup ancient devices)
- * PCID_xxx: device ID
- */
-#define PCIR_DEVVENDOR		0x00
-#define PCIR_VENDOR		0x00
-#define PCIR_DEVICE		0x02
-#define PCIR_COMMAND		0x04
-#define PCIM_CMD_PORTEN		0x0001
-#define PCIM_CMD_MEMEN		0x0002
-#define PCIM_CMD_BUSMASTEREN	0x0004
-#define PCIM_CMD_MWRICEN	0x0010
-#define PCIM_CMD_PERRESPEN	0x0040
-#define	PCIM_CMD_SERRESPEN	0x0100
-#define PCIR_STATUS		0x06
-#define PCIR_REVID		0x08
-#define PCIR_PROGIF		0x09
-#define PCIR_SUBCLASS		0x0a
-#define PCIR_CLASS		0x0b
-#define PCIR_CACHELNSZ		0x0c
-#define PCIR_LATTIMER		0x0d
-#define PCIR_HEADERTYPE		0x0e
-#define PCIM_MFDEV		0x80
-#define PCIR_BIST		0x0f
-#define PCIR_CAP_PTR		0x34
-
-/* config registers for header type 0 devices */
-#define PCIR_MAPS	0x10
-#define PCIR_SUBVEND_0	0x2c
-#define PCIR_SUBDEV_0	0x2e
-
-/****************************** PCI-X definitions *****************************/
-#define PCIXR_COMMAND	0x96
-#define PCIXR_DEVADDR	0x98
-#define PCIXM_DEVADDR_FNUM	0x0003	/* Function Number */
-#define PCIXM_DEVADDR_DNUM	0x00F8	/* Device Number */
-#define PCIXM_DEVADDR_BNUM	0xFF00	/* Bus Number */
-#define PCIXR_STATUS	0x9A
-#define PCIXM_STATUS_64BIT	0x0001	/* Active 64bit connection to device. */
-#define PCIXM_STATUS_133CAP	0x0002	/* Device is 133MHz capable */
-#define PCIXM_STATUS_SCDISC	0x0004	/* Split Completion Discarded */
-#define PCIXM_STATUS_UNEXPSC	0x0008	/* Unexpected Split Completion */
-#define PCIXM_STATUS_CMPLEXDEV	0x0010	/* Device Complexity (set == bridge) */
-#define PCIXM_STATUS_MAXMRDBC	0x0060	/* Maximum Burst Read Count */
-#define PCIXM_STATUS_MAXSPLITS	0x0380	/* Maximum Split Transactions */
-#define PCIXM_STATUS_MAXCRDS	0x1C00	/* Maximum Cumulative Read Size */
-#define PCIXM_STATUS_RCVDSCEM	0x2000	/* Received a Split Comp w/Error msg */
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 extern struct pci_driver aic79xx_pci_driver;
-#endif
-
-typedef enum
-{
-	AHD_POWER_STATE_D0,
-	AHD_POWER_STATE_D1,
-	AHD_POWER_STATE_D2,
-	AHD_POWER_STATE_D3
-} ahd_power_state;
-
-void ahd_power_state_change(struct ahd_softc *ahd,
-			    ahd_power_state new_state);
 
 /******************************* PCI Routines *********************************/
 int			 ahd_linux_pci_init(void);
@@ -880,110 +254,6 @@ void			 ahd_linux_pci_exit(void);
 int			 ahd_pci_map_registers(struct ahd_softc *ahd);
 int			 ahd_pci_map_int(struct ahd_softc *ahd);
 
-static __inline uint32_t ahd_pci_read_config(ahd_dev_softc_t pci,
-					     int reg, int width);
-
-static __inline uint32_t
-ahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)
-{
-	switch (width) {
-	case 1:
-	{
-		uint8_t retval;
-
-		pci_read_config_byte(pci, reg, &retval);
-		return (retval);
-	}
-	case 2:
-	{
-		uint16_t retval;
-		pci_read_config_word(pci, reg, &retval);
-		return (retval);
-	}
-	case 4:
-	{
-		uint32_t retval;
-		pci_read_config_dword(pci, reg, &retval);
-		return (retval);
-	}
-	default:
-		panic("ahd_pci_read_config: Read size too big");
-		/* NOTREACHED */
-		return (0);
-	}
-}
-
-static __inline void ahd_pci_write_config(ahd_dev_softc_t pci,
-					  int reg, uint32_t value,
-					  int width);
-
-static __inline void
-ahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)
-{
-	switch (width) {
-	case 1:
-		pci_write_config_byte(pci, reg, value);
-		break;
-	case 2:
-		pci_write_config_word(pci, reg, value);
-		break;
-	case 4:
-		pci_write_config_dword(pci, reg, value);
-		break;
-	default:
-		panic("ahd_pci_write_config: Write size too big");
-		/* NOTREACHED */
-	}
-}
-
-static __inline int ahd_get_pci_function(ahd_dev_softc_t);
-static __inline int
-ahd_get_pci_function(ahd_dev_softc_t pci)
-{
-	return (PCI_FUNC(pci->devfn));
-}
-
-static __inline int ahd_get_pci_slot(ahd_dev_softc_t);
-static __inline int
-ahd_get_pci_slot(ahd_dev_softc_t pci)
-{
-	return (PCI_SLOT(pci->devfn));
-}
-
-static __inline int ahd_get_pci_bus(ahd_dev_softc_t);
-static __inline int
-ahd_get_pci_bus(ahd_dev_softc_t pci)
-{
-	return (pci->bus->number);
-}
-
-static __inline void ahd_flush_device_writes(struct ahd_softc *);
-static __inline void
-ahd_flush_device_writes(struct ahd_softc *ahd)
-{
-	/* XXX Is this sufficient for all architectures??? */
-	ahd_inb(ahd, INTSTAT);
-}
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,3,0)
-#define pci_map_sg(pdev, sg_list, nseg, direction) (nseg)
-#define pci_unmap_sg(pdev, sg_list, nseg, direction)
-#define sg_dma_address(sg) (VIRT_TO_BUS((sg)->address))
-#define sg_dma_len(sg) ((sg)->length)
-#define pci_map_single(pdev, buffer, bufflen, direction) \
-	(VIRT_TO_BUS(buffer))
-#define pci_unmap_single(pdev, buffer, buflen, direction)
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
-#define ahd_pci_set_dma_mask pci_set_dma_mask
-#else
-/*
- * Always "return" 0 for success.
- */
-#define ahd_pci_set_dma_mask(dev_softc, mask)	\
-	(((dev_softc)->dma_mask = mask) && 0)
-#endif
 /**************************** Proc FS Support *********************************/
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 int	ahd_linux_proc_info(char *, char **, off_t, int, int, int);
@@ -992,203 +262,11 @@ int	ahd_linux_proc_info(struct Scsi_Host
 			    off_t, int, int);
 #endif
 
-/*************************** Domain Validation ********************************/
-#define AHD_DV_CMD(cmd) ((cmd)->scsi_done == ahd_linux_dv_complete)
-#define AHD_DV_SIMQ_FROZEN(ahd)					\
-	((((ahd)->platform_data->flags & AHD_DV_ACTIVE) != 0)	\
-	 && (ahd)->platform_data->qfrozen == 1)
-
 /*********************** Transaction Access Wrappers **************************/
-static __inline void ahd_cmd_set_transaction_status(Scsi_Cmnd *, uint32_t);
-static __inline void ahd_set_transaction_status(struct scb *, uint32_t);
-static __inline void ahd_cmd_set_scsi_status(Scsi_Cmnd *, uint32_t);
-static __inline void ahd_set_scsi_status(struct scb *, uint32_t);
-static __inline uint32_t ahd_cmd_get_transaction_status(Scsi_Cmnd *cmd);
-static __inline uint32_t ahd_get_transaction_status(struct scb *);
-static __inline uint32_t ahd_cmd_get_scsi_status(Scsi_Cmnd *cmd);
-static __inline uint32_t ahd_get_scsi_status(struct scb *);
-static __inline void ahd_set_transaction_tag(struct scb *, int, u_int);
-static __inline u_long ahd_get_transfer_length(struct scb *);
-static __inline int ahd_get_transfer_dir(struct scb *);
-static __inline void ahd_set_residual(struct scb *, u_long);
-static __inline void ahd_set_sense_residual(struct scb *scb, u_long resid);
-static __inline u_long ahd_get_residual(struct scb *);
-static __inline u_long ahd_get_sense_residual(struct scb *);
-static __inline int ahd_perform_autosense(struct scb *);
-static __inline uint32_t ahd_get_sense_bufsize(struct ahd_softc *,
-					       struct scb *);
-static __inline void ahd_notify_xfer_settings_change(struct ahd_softc *,
-						     struct ahd_devinfo *);
-static __inline void ahd_platform_scb_free(struct ahd_softc *ahd,
-					   struct scb *scb);
-static __inline void ahd_freeze_scb(struct scb *scb);
-
-static __inline
-void ahd_cmd_set_transaction_status(Scsi_Cmnd *cmd, uint32_t status)
-{
-	cmd->result &= ~(CAM_STATUS_MASK << 16);
-	cmd->result |= status << 16;
-}
-
-static __inline
-void ahd_set_transaction_status(struct scb *scb, uint32_t status)
-{
-	ahd_cmd_set_transaction_status(scb->io_ctx,status);
-}
-
-static __inline
-void ahd_cmd_set_scsi_status(Scsi_Cmnd *cmd, uint32_t status)
-{
-	cmd->result &= ~0xFFFF;
-	cmd->result |= status;
-}
-
-static __inline
-void ahd_set_scsi_status(struct scb *scb, uint32_t status)
-{
-	ahd_cmd_set_scsi_status(scb->io_ctx, status);
-}
-
-static __inline
-uint32_t ahd_cmd_get_transaction_status(Scsi_Cmnd *cmd)
-{
-	return ((cmd->result >> 16) & CAM_STATUS_MASK);
-}
-
-static __inline
-uint32_t ahd_get_transaction_status(struct scb *scb)
-{
-	return (ahd_cmd_get_transaction_status(scb->io_ctx));
-}
-
-static __inline
-uint32_t ahd_cmd_get_scsi_status(Scsi_Cmnd *cmd)
-{
-	return (cmd->result & 0xFFFF);
-}
-
-static __inline
-uint32_t ahd_get_scsi_status(struct scb *scb)
-{
-	return (ahd_cmd_get_scsi_status(scb->io_ctx));
-}
-
-static __inline
-void ahd_set_transaction_tag(struct scb *scb, int enabled, u_int type)
-{
-	/*
-	 * Nothing to do for linux as the incoming transaction
-	 * has no concept of tag/non tagged, etc.
-	 */
-}
-
-static __inline
-u_long ahd_get_transfer_length(struct scb *scb)
-{
-	return (scb->platform_data->xfer_len);
-}
-
-static __inline
-int ahd_get_transfer_dir(struct scb *scb)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,40)
-	return (scb->io_ctx->sc_data_direction);
-#else
-	if (scb->io_ctx->bufflen == 0)
-		return (CAM_DIR_NONE);
-
-	switch(scb->io_ctx->cmnd[0]) {
-	case 0x08:  /* READ(6)  */
-	case 0x28:  /* READ(10) */
-	case 0xA8:  /* READ(12) */
-		return (CAM_DIR_IN);
-        case 0x0A:  /* WRITE(6)  */
-        case 0x2A:  /* WRITE(10) */
-        case 0xAA:  /* WRITE(12) */
-		return (CAM_DIR_OUT);
-        default:
-		return (CAM_DIR_NONE);
-        }
-#endif
-}
-
-static __inline
-void ahd_set_residual(struct scb *scb, u_long resid)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	scb->io_ctx->resid = resid;
-#else
-	scb->platform_data->resid = resid;
-#endif
-}
-
-static __inline
-void ahd_set_sense_residual(struct scb *scb, u_long resid)
-{
-	scb->platform_data->sense_resid = resid;
-}
-
-static __inline
-u_long ahd_get_residual(struct scb *scb)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	return (scb->io_ctx->resid);
-#else
-	return (scb->platform_data->resid);
-#endif
-}
-
-static __inline
-u_long ahd_get_sense_residual(struct scb *scb)
-{
-	return (scb->platform_data->sense_resid);
-}
-
-static __inline
-int ahd_perform_autosense(struct scb *scb)
-{
-	/*
-	 * We always perform autosense in Linux.
-	 * On other platforms this is set on a
-	 * per-transaction basis.
-	 */
-	return (1);
-}
-
-static __inline uint32_t
-ahd_get_sense_bufsize(struct ahd_softc *ahd, struct scb *scb)
-{
-	return (sizeof(struct scsi_sense_data));
-}
-
-static __inline void
-ahd_notify_xfer_settings_change(struct ahd_softc *ahd,
-				struct ahd_devinfo *devinfo)
-{
-	/* Nothing to do here for linux */
-}
-
-static __inline void
-ahd_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)
-{
-	ahd->flags &= ~AHD_RESOURCE_SHORTAGE;
-}
-
 int	ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg);
 void	ahd_platform_free(struct ahd_softc *ahd);
 void	ahd_platform_init(struct ahd_softc *ahd);
 void	ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb);
-void	ahd_freeze_simq(struct ahd_softc *ahd);
-void	ahd_release_simq(struct ahd_softc *ahd);
-
-static __inline void
-ahd_freeze_scb(struct scb *scb)
-{
-	if ((scb->io_ctx->result & (CAM_DEV_QFRZN << 16)) == 0) {
-                scb->io_ctx->result |= CAM_DEV_QFRZN << 16;
-                scb->platform_data->dev->qfrozen++;
-        }
-}
 
 void	ahd_platform_set_tags(struct ahd_softc *ahd,
 			      struct ahd_devinfo *devinfo, ahd_queue_alg);
@@ -1206,9 +284,9 @@ void	ahd_print_path(struct ahd_softc *, 
 void	ahd_platform_dump_card_state(struct ahd_softc *ahd);
 
 #ifdef CONFIG_PCI
-#define AHD_PCI_CONFIG 1
+#define AIC_PCI_CONFIG 1
 #else
-#define AHD_PCI_CONFIG 0
+#define AIC_PCI_CONFIG 0
 #endif
 #define bootverbose aic79xx_verbose
 extern uint32_t aic79xx_verbose;
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_osm_pci.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_osm_pci.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_osm_pci.c	2004-04-04 05:36:53.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_osm_pci.c	2004-05-13 16:42:17.000000000 +0200
@@ -36,17 +36,19 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#25 $
+ * $Id$
  */
 
 #include "aic79xx_osm.h"
 #include "aic79xx_inline.h"
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-struct pci_device_id
-{
-};
-#endif
+/*
+ * Include aiclib_pci.c as part of our
+ * "module dependencies are hard" work around.
+ */
+#include "aiclib_pci.c"
+
+static int	ahd_pci_module_registered;
 
 static int	ahd_linux_pci_dev_probe(struct pci_dev *pdev,
 					const struct pci_device_id *ent);
@@ -55,7 +57,6 @@ static int	ahd_linux_pci_reserve_io_regi
 static int	ahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,
 						 u_long *bus_addr,
 						 uint8_t **maddr);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 static void	ahd_linux_pci_dev_remove(struct pci_dev *pdev);
 
 /* We do our own ID filtering.  So, grab all SCSI storage class devices. */
@@ -64,6 +65,10 @@ static struct pci_device_id ahd_linux_pc
 		0x9005, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
 		PCI_CLASS_STORAGE_SCSI << 8, 0xFFFF00, 0
 	},
+	{
+		0x9005, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_STORAGE_RAID << 8, 0xFFFF00, 0
+	},
 	{ 0 }
 };
 
@@ -92,21 +97,22 @@ ahd_linux_pci_dev_remove(struct pci_dev 
 	if (ahd != NULL) {
 		u_long s;
 
+		TAILQ_REMOVE(&ahd_tailq, ahd, links);
+		ahd_list_unlock(&l);
 		ahd_lock(ahd, &s);
 		ahd_intr_enable(ahd, FALSE);
 		ahd_unlock(ahd, &s);
 		ahd_free(ahd);
-	}
-	ahd_list_unlock(&l);
+	} else
+		ahd_list_unlock(&l);
 }
-#endif /* !LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) */
 
 static int
 ahd_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	char		 buf[80];
 	struct		 ahd_softc *ahd;
-	ahd_dev_softc_t	 pci;
+	aic_dev_softc_t	 dev;
 	struct		 ahd_pci_identity *entry;
 	char		*name;
 	int		 error;
@@ -117,7 +123,7 @@ ahd_linux_pci_dev_probe(struct pci_dev *
 	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
 		struct pci_dev *probed_pdev;
 
-		probed_pdev = ahd->dev_softc;
+		probed_pdev = aic_pci_dev(ahd);
 		if (probed_pdev->bus->number == pdev->bus->number
 		 && probed_pdev->devfn == pdev->devfn)
 			break;
@@ -127,8 +133,8 @@ ahd_linux_pci_dev_probe(struct pci_dev *
 		return (-ENODEV);
 	}
 
-	pci = pdev;
-	entry = ahd_find_pci_device(pci);
+	dev = aic_pci_dev_to_dev(pdev);
+	entry = ahd_find_pci_device(dev);
 	if (entry == NULL)
 		return (-ENODEV);
 
@@ -138,9 +144,9 @@ ahd_linux_pci_dev_probe(struct pci_dev *
 	 * common detect routine.
 	 */
 	sprintf(buf, "ahd_pci:%d:%d:%d",
-		ahd_get_pci_bus(pci),
-		ahd_get_pci_slot(pci),
-		ahd_get_pci_function(pci));
+		aic_get_pci_bus(dev),
+		aic_get_pci_slot(dev),
+		aic_get_pci_function(dev));
 	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
 	if (name == NULL)
 		return (-ENOMEM);
@@ -148,13 +154,19 @@ ahd_linux_pci_dev_probe(struct pci_dev *
 	ahd = ahd_alloc(NULL, name);
 	if (ahd == NULL)
 		return (-ENOMEM);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	ahd->dev_softc = dev;
 	if (pci_enable_device(pdev)) {
 		ahd_free(ahd);
 		return (-ENODEV);
 	}
 	pci_set_master(pdev);
 
+	if (aic_set_consistent_dma_mask(ahd, 0xFFFFFFFF) != 0) {
+		printk(KERN_WARNING "aic79xx: Unable to set"
+		       "coherent DMA mask.\n");
+		ahd_free(ahd);
+		return (-ENOMEM);
+	}
 	if (sizeof(bus_addr_t) > 4) {
 		uint64_t   memsize;
 		bus_addr_t mask_64bit;
@@ -164,26 +176,28 @@ ahd_linux_pci_dev_probe(struct pci_dev *
 		mask_64bit = (bus_addr_t)0xFFFFFFFFFFFFFFFFULL;
 		mask_39bit = (bus_addr_t)0x7FFFFFFFFFULL;
 		if (memsize >= 0x8000000000ULL
-	 	 && ahd_pci_set_dma_mask(pdev, mask_64bit) == 0) {
+	 	 && aic_set_dma_mask(ahd, mask_64bit) == 0) {
 			ahd->flags |= AHD_64BIT_ADDRESSING;
 			ahd->platform_data->hw_dma_mask = mask_64bit;
 		} else if (memsize > 0x80000000
-			&& ahd_pci_set_dma_mask(pdev, mask_39bit) == 0) {
+			&& aic_set_dma_mask(ahd, mask_39bit) == 0) {
 			ahd->flags |= AHD_39BIT_ADDRESSING;
 			ahd->platform_data->hw_dma_mask = mask_39bit;
 		}
 	} else {
-		ahd_pci_set_dma_mask(pdev, 0xFFFFFFFF);
+		if (aic_set_dma_mask(ahd, 0xFFFFFFFF) != 0) {
+			printk(KERN_WARNING "aic79xx: Unable to set data "
+			       "DMA mask.\n");
+			ahd_free(ahd);
+			return (-ENOMEM);
+		}
 		ahd->platform_data->hw_dma_mask = 0xFFFFFFFF;
 	}
-#endif
-	ahd->dev_softc = pci;
 	error = ahd_pci_config(ahd, entry);
 	if (error != 0) {
 		ahd_free(ahd);
 		return (-error);
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 	pci_set_drvdata(pdev, ahd);
 	if (aic79xx_detect_complete) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -194,80 +208,48 @@ ahd_linux_pci_dev_probe(struct pci_dev *
 		return (-ENODEV);
 #endif
 	}
-#endif
 	return (0);
 }
 
 int
 ahd_linux_pci_init(void)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	return (pci_module_init(&aic79xx_pci_driver));
-#else
-	struct pci_dev *pdev;
-	u_int class;
-	int found;
-
-	/* If we don't have a PCI bus, we can't find any adapters. */
-	if (pci_present() == 0)
-		return (0);
-
-	found = 0;
-	pdev = NULL;
-	class = PCI_CLASS_STORAGE_SCSI << 8;
-	while ((pdev = pci_find_class(class, pdev)) != NULL) {
-		ahd_dev_softc_t pci;
-		int error;
-
-		pci = pdev;
-		error = ahd_linux_pci_dev_probe(pdev, /*pci_devid*/NULL);
-		if (error == 0)
-			found++;
-	}
-	return (found);
-#endif
+	int error;
+	
+	error = pci_module_init(&aic79xx_pci_driver);
+	if (error == 0)
+		ahd_pci_module_registered = 1;
+	return (error);
 }
 
 void
 ahd_linux_pci_exit(void)
 {
-	pci_unregister_driver(&aic79xx_pci_driver);
+	if (ahd_pci_module_registered != 0)
+		pci_unregister_driver(&aic79xx_pci_driver);
 }
 
 static int
 ahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd, u_long *base,
 				 u_long *base2)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	*base = pci_resource_start(ahd->dev_softc, 0);
+
+	*base = pci_resource_start(aic_pci_dev(ahd), 0);
+
 	/*
 	 * This is really the 3rd bar and should be at index 2,
 	 * but the Linux PCI code doesn't know how to "count" 64bit
 	 * bars.
 	 */
-	*base2 = pci_resource_start(ahd->dev_softc, 3);
-#else
-	*base = ahd_pci_read_config(ahd->dev_softc, AHD_PCI_IOADDR0, 4);
-	*base2 = ahd_pci_read_config(ahd->dev_softc, AHD_PCI_IOADDR1, 4);
-	*base &= PCI_BASE_ADDRESS_IO_MASK;
-	*base2 &= PCI_BASE_ADDRESS_IO_MASK;
-#endif
+	*base2 = pci_resource_start(aic_pci_dev(ahd), 3);
 	if (*base == 0 || *base2 == 0)
 		return (ENOMEM);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-	if (check_region(*base, 256) != 0
-	 || check_region(*base2, 256) != 0)
-		return (ENOMEM);
-	request_region(*base, 256, "aic79xx");
-	request_region(*base2, 256, "aic79xx");
-#else
 	if (request_region(*base, 256, "aic79xx") == 0)
 		return (ENOMEM);
 	if (request_region(*base2, 256, "aic79xx") == 0) {
 		release_region(*base2, 256);
 		return (ENOMEM);
 	}
-#endif
 	return (0);
 }
 
@@ -288,29 +270,18 @@ ahd_linux_pci_reserve_mem_region(struct 
 		return (ENOMEM);
 
 	error = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	start = pci_resource_start(ahd->dev_softc, 1);
+	start = pci_resource_start(aic_pci_dev(ahd), 1);
 	base_page = start & PAGE_MASK;
 	base_offset = start - base_page;
-#else
-	start = ahd_pci_read_config(ahd->dev_softc, PCIR_MAPS+4, 4);
-	base_offset = start & PCI_BASE_ADDRESS_MEM_MASK;
-	base_page = base_offset & PAGE_MASK;
-	base_offset -= base_page;
-#endif
 	if (start != 0) {
 		*bus_addr = start;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 		if (request_mem_region(start, 0x1000, "aic79xx") == 0)
 			error = ENOMEM;
-#endif
 		if (error == 0) {
 			*maddr = ioremap_nocache(base_page, base_offset + 256);
 			if (*maddr == NULL) {
 				error = ENOMEM;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 				release_mem_region(start, 0x1000);
-#endif
 			} else
 				*maddr += base_offset;
 		}
@@ -330,7 +301,7 @@ ahd_pci_map_registers(struct ahd_softc *
 	/*
 	 * If its allowed, we prefer memory mapped access.
 	 */
-	command = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 4);
+	command = aic_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 4);
 	command &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);
 	base = 0;
 	maddr = NULL;
@@ -341,21 +312,19 @@ ahd_pci_map_registers(struct ahd_softc *
 		ahd->bshs[0].maddr = maddr;
 		ahd->tags[1] = BUS_SPACE_MEMIO;
 		ahd->bshs[1].maddr = maddr + 0x100;
-		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+		aic_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
 				     command | PCIM_CMD_MEMEN, 4);
 
 		if (ahd_pci_test_register_access(ahd) != 0) {
 
 			printf("aic79xx: PCI Device %d:%d:%d "
 			       "failed memory mapped test.  Using PIO.\n",
-			       ahd_get_pci_bus(ahd->dev_softc),
-			       ahd_get_pci_slot(ahd->dev_softc),
-			       ahd_get_pci_function(ahd->dev_softc));
+			       aic_get_pci_bus(ahd->dev_softc),
+			       aic_get_pci_slot(ahd->dev_softc),
+			       aic_get_pci_function(ahd->dev_softc));
 			iounmap((void *)((u_long)maddr & PAGE_MASK));
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 			release_mem_region(ahd->platform_data->mem_busaddr,
 					   0x1000);
-#endif
 			ahd->bshs[0].maddr = NULL;
 			maddr = NULL;
 		} else
@@ -363,9 +332,9 @@ ahd_pci_map_registers(struct ahd_softc *
 	} else if (bootverbose) {
 		printf("aic79xx: PCI%d:%d:%d MEM region 0x%lx "
 		       "unavailable. Cannot memory map device.\n",
-		       ahd_get_pci_bus(ahd->dev_softc),
-		       ahd_get_pci_slot(ahd->dev_softc),
-		       ahd_get_pci_function(ahd->dev_softc),
+		       aic_get_pci_bus(ahd->dev_softc),
+		       aic_get_pci_slot(ahd->dev_softc),
+		       aic_get_pci_function(ahd->dev_softc),
 		       base);
 	}
 
@@ -382,13 +351,13 @@ ahd_pci_map_registers(struct ahd_softc *
 		} else {
 			printf("aic79xx: PCI%d:%d:%d IO regions 0x%lx and 0x%lx"
 			       "unavailable. Cannot map device.\n",
-			       ahd_get_pci_bus(ahd->dev_softc),
-			       ahd_get_pci_slot(ahd->dev_softc),
-			       ahd_get_pci_function(ahd->dev_softc),
+			       aic_get_pci_bus(ahd->dev_softc),
+			       aic_get_pci_slot(ahd->dev_softc),
+			       aic_get_pci_function(ahd->dev_softc),
 			       base, base2);
 		}
 	}
-	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, 4);
+	aic_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, 4);
 	return (error);
 }
 
@@ -397,49 +366,10 @@ ahd_pci_map_int(struct ahd_softc *ahd)
 {
 	int error;
 
-	error = request_irq(ahd->dev_softc->irq, ahd_linux_isr,
+	error = request_irq(aic_pci_dev(ahd)->irq, ahd_linux_isr,
 			    SA_SHIRQ, "aic79xx", ahd);
 	if (error == 0)
-		ahd->platform_data->irq = ahd->dev_softc->irq;
+		ahd->platform_data->irq = aic_pci_dev(ahd)->irq;
 	
 	return (-error);
 }
-
-void
-ahd_power_state_change(struct ahd_softc *ahd, ahd_power_state new_state)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	pci_set_power_state(ahd->dev_softc, new_state);
-#else
-	uint32_t cap;
-	u_int cap_offset;
-
-	/*
-	 * Traverse the capability list looking for
-	 * the power management capability.
-	 */
-	cap = 0;
-	cap_offset = ahd_pci_read_config(ahd->dev_softc,
-					 PCIR_CAP_PTR, /*bytes*/1);
-	while (cap_offset != 0) {
-
-		cap = ahd_pci_read_config(ahd->dev_softc,
-					  cap_offset, /*bytes*/4);
-		if ((cap & 0xFF) == 1
-		 && ((cap >> 16) & 0x3) > 0) {
-			uint32_t pm_control;
-
-			pm_control = ahd_pci_read_config(ahd->dev_softc,
-							 cap_offset + 4,
-							 /*bytes*/4);
-			pm_control &= ~0x3;
-			pm_control |= new_state;
-			ahd_pci_write_config(ahd->dev_softc,
-					     cap_offset + 4,
-					     pm_control, /*bytes*/2);
-			break;
-		}
-		cap_offset = (cap >> 8) & 0xFF;
-	}
-#endif 
-}
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_pci.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_pci.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_pci.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_pci.c	2004-05-13 16:42:17.000000000 +0200
@@ -38,15 +38,15 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx_pci.c#77 $
- *
- * $FreeBSD$
+ * $Id$
  */
 
 #ifdef __linux__
 #include "aic79xx_osm.h"
 #include "aic79xx_inline.h"
 #else
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
 #include <dev/aic7xxx/aic79xx_osm.h>
 #include <dev/aic7xxx/aic79xx_inline.h>
 #endif
@@ -65,23 +65,23 @@ ahd_compose_id(u_int device, u_int vendo
 }
 
 #define ID_ALL_MASK			0xFFFFFFFFFFFFFFFFull
-#define ID_ALL_IROC_MASK		0xFFFFFF7FFFFFFFFFull
+#define ID_ALL_IROC_MASK		0xFF7FFFFFFFFFFFFFull
 #define ID_DEV_VENDOR_MASK		0xFFFFFFFF00000000ull
 #define ID_9005_GENERIC_MASK		0xFFF0FFFF00000000ull
-#define ID_9005_GENERIC_IROC_MASK	0xFFF0FF7F00000000ull
+#define ID_9005_GENERIC_IROC_MASK	0xFF70FFFF00000000ull
 
 #define ID_AIC7901			0x800F9005FFFF9005ull
 #define ID_AHA_29320A			0x8000900500609005ull
 #define ID_AHA_29320ALP			0x8017900500449005ull
 
 #define ID_AIC7901A			0x801E9005FFFF9005ull
-#define ID_AHA_29320			0x8012900500429005ull
-#define ID_AHA_29320B			0x8013900500439005ull
 #define ID_AHA_29320LP			0x8014900500449005ull
 
 #define ID_AIC7902			0x801F9005FFFF9005ull
 #define ID_AIC7902_B			0x801D9005FFFF9005ull
 #define ID_AHA_39320			0x8010900500409005ull
+#define ID_AHA_29320			0x8012900500429005ull
+#define ID_AHA_29320B			0x8013900500439005ull
 #define ID_AHA_39320_B			0x8015900500409005ull
 #define ID_AHA_39320A			0x8016900500409005ull
 #define ID_AHA_39320D			0x8011900500419005ull
@@ -92,10 +92,11 @@ ahd_compose_id(u_int device, u_int vendo
 #define ID_AIC7902_PCI_REV_B0		0x10
 #define SUBID_HP			0x0E11
 
+#define DEVID_9005_HOSTRAID(id) ((id) & 0x80)
+
 #define DEVID_9005_TYPE(id) ((id) & 0xF)
 #define		DEVID_9005_TYPE_HBA		0x0	/* Standard Card */
 #define		DEVID_9005_TYPE_HBA_2EXT	0x1	/* 2 External Ports */
-#define		DEVID_9005_TYPE_IROC		0x8	/* Raid(0,1,10) Card */
 #define		DEVID_9005_TYPE_MB		0xF	/* On Motherboard */
 
 #define DEVID_9005_MFUNC(id) ((id) & 0x10)
@@ -136,24 +137,24 @@ struct ahd_pci_identity ahd_pci_ident_ta
 	},
 	/* aic7901A based controllers */
 	{
-		ID_AHA_29320,
+		ID_AHA_29320LP,
 		ID_ALL_MASK,
-		"Adaptec 29320 Ultra320 SCSI adapter",
+		"Adaptec 29320LP Ultra320 SCSI adapter",
 		ahd_aic7901A_setup
 	},
+	/* aic7902 based controllers */	
 	{
-		ID_AHA_29320B,
+		ID_AHA_29320,
 		ID_ALL_MASK,
-		"Adaptec 29320B Ultra320 SCSI adapter",
-		ahd_aic7901A_setup
+		"Adaptec 29320 Ultra320 SCSI adapter",
+		ahd_aic7902_setup
 	},
 	{
-		ID_AHA_29320LP,
+		ID_AHA_29320B,
 		ID_ALL_MASK,
-		"Adaptec 29320LP Ultra320 SCSI adapter",
-		ahd_aic7901A_setup
+		"Adaptec 29320B Ultra320 SCSI adapter",
+		ahd_aic7902_setup
 	},
-	/* aic7902 based controllers */	
 	{
 		ID_AHA_39320,
 		ID_ALL_MASK,
@@ -196,22 +197,10 @@ struct ahd_pci_identity ahd_pci_ident_ta
 		"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter",
 		ahd_aic7902_setup
 	},
-	{
-		ID_AHA_29320,
-		ID_ALL_MASK,
-		"Adaptec 29320 Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
-	{
-		ID_AHA_29320B,
-		ID_ALL_MASK,
-		"Adaptec 29320B Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
 	/* Generic chip probes for devices we don't know 'exactly' */
 	{
-		ID_AIC7901 & ID_DEV_VENDOR_MASK,
-		ID_DEV_VENDOR_MASK,
+		ID_AIC7901 & ID_9005_GENERIC_MASK,
+		ID_9005_GENERIC_MASK,
 		"Adaptec AIC7901 Ultra320 SCSI adapter",
 		ahd_aic7901_setup
 	},
@@ -275,7 +264,7 @@ static void	ahd_configure_termination(st
 static void	ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat);
 
 struct ahd_pci_identity *
-ahd_find_pci_device(ahd_dev_softc_t pci)
+ahd_find_pci_device(aic_dev_softc_t pci)
 {
 	uint64_t  full_id;
 	uint16_t  device;
@@ -285,15 +274,23 @@ ahd_find_pci_device(ahd_dev_softc_t pci)
 	struct	  ahd_pci_identity *entry;
 	u_int	  i;
 
-	vendor = ahd_pci_read_config(pci, PCIR_DEVVENDOR, /*bytes*/2);
-	device = ahd_pci_read_config(pci, PCIR_DEVICE, /*bytes*/2);
-	subvendor = ahd_pci_read_config(pci, PCIR_SUBVEND_0, /*bytes*/2);
-	subdevice = ahd_pci_read_config(pci, PCIR_SUBDEV_0, /*bytes*/2);
+	vendor = aic_pci_read_config(pci, PCIR_DEVVENDOR, /*bytes*/2);
+	device = aic_pci_read_config(pci, PCIR_DEVICE, /*bytes*/2);
+	subvendor = aic_pci_read_config(pci, PCIR_SUBVEND_0, /*bytes*/2);
+	subdevice = aic_pci_read_config(pci, PCIR_SUBDEV_0, /*bytes*/2);
 	full_id = ahd_compose_id(device,
 				 vendor,
 				 subdevice,
 				 subvendor);
 
+	/*
+	 * If we are configured to attach to HostRAID
+	 * controllers, mask out the IROC/HostRAID bit
+	 * in the 
+	 */
+	if (ahd_attach_to_HostRAID_controllers)
+		full_id &= ID_ALL_IROC_MASK;
+
 	for (i = 0; i < ahd_num_pci_devs; i++) {
 		entry = &ahd_pci_ident_table[i];
 		if (entry->full_id == (full_id & entry->id_mask)) {
@@ -313,15 +310,24 @@ ahd_pci_config(struct ahd_softc *ahd, st
 	u_long		 l;
 	u_int		 command;
 	uint32_t	 devconfig;
+	uint16_t	 device; 
 	uint16_t	 subvendor; 
 	int		 error;
 
 	shared_scb_data = NULL;
 	ahd->description = entry->name;
 	/*
+	 * Record if this is a HostRAID board.
+	 */
+	device = aic_pci_read_config(ahd->dev_softc,
+				     PCIR_DEVICE, /*bytes*/2);
+	if (DEVID_9005_HOSTRAID(device))
+		ahd->flags |= AHD_HOSTRAID_BOARD;
+
+	/*
 	 * Record if this is an HP board.
 	 */
-	subvendor = ahd_pci_read_config(ahd->dev_softc,
+	subvendor = aic_pci_read_config(ahd->dev_softc,
 					PCIR_SUBVEND_0, /*bytes*/2);
 	if (subvendor == SUBID_HP)
 		ahd->flags |= AHD_HP_BOARD;
@@ -330,7 +336,7 @@ ahd_pci_config(struct ahd_softc *ahd, st
 	if (error != 0)
 		return (error);
 	
-	devconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
+	devconfig = aic_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
 	if ((devconfig & PCIXINITPAT) == PCIXINIT_PCI33_66) {
 		ahd->chip |= AHD_PCI;
 		/* Disable PCIX workarounds when running in PCI mode. */
@@ -340,7 +346,7 @@ ahd_pci_config(struct ahd_softc *ahd, st
 	}
 	ahd->bus_description = pci_bus_modes[PCI_BUS_MODES_INDEX(devconfig)];
 
-	ahd_power_state_change(ahd, AHD_POWER_STATE_D0);
+	aic_power_state_change(ahd, AIC_POWER_STATE_D0);
 
 	error = ahd_pci_map_registers(ahd);
 	if (error != 0)
@@ -358,17 +364,17 @@ ahd_pci_config(struct ahd_softc *ahd, st
 		if (bootverbose)
 			printf("%s: Enabling 39Bit Addressing\n",
 			       ahd_name(ahd));
-		devconfig = ahd_pci_read_config(ahd->dev_softc,
+		devconfig = aic_pci_read_config(ahd->dev_softc,
 						DEVCONFIG, /*bytes*/4);
 		devconfig |= DACEN;
-		ahd_pci_write_config(ahd->dev_softc, DEVCONFIG,
+		aic_pci_write_config(ahd->dev_softc, DEVCONFIG,
 				     devconfig, /*bytes*/4);
 	}
 	
 	/* Ensure busmastering is enabled */
-	command = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	command = aic_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
 	command |= PCIM_CMD_BUSMASTEREN;
-	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, /*bytes*/2);
+	aic_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, /*bytes*/2);
 
 	error = ahd_softc_init(ahd);
 	if (error != 0)
@@ -381,7 +387,7 @@ ahd_pci_config(struct ahd_softc *ahd, st
 		return (ENXIO);
 
 	ahd->pci_cachesize =
-	    ahd_pci_read_config(ahd->dev_softc, CSIZE_LATTIME,
+	    aic_pci_read_config(ahd->dev_softc, CSIZE_LATTIME,
 				/*bytes*/1) & CACHESIZE;
 	ahd->pci_cachesize *= 4;
 
@@ -431,8 +437,8 @@ ahd_pci_test_register_access(struct ahd_
 	 * Enable PCI error interrupt status, but suppress NMIs
 	 * generated by SERR raised due to target aborts.
 	 */
-	cmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
-	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+	cmd = aic_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	aic_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
 			     cmd & ~PCIM_CMD_SERRESPEN, /*bytes*/2);
 
 	/*
@@ -452,8 +458,10 @@ ahd_pci_test_register_access(struct ahd_
 	 * or read prefetching could be initiated by the
 	 * CPU or host bridge.  Our device does not support
 	 * either, so look for data corruption and/or flaged
-	 * PCI errors.
+	 * PCI errors.  First pause without causing another
+	 * chip reset.
 	 */
+	hcntrl &= ~CHIPRST;
 	ahd_outb(ahd, HCNTRL, hcntrl|PAUSE);
 	while (ahd_is_paused(ahd) == 0)
 		;
@@ -462,9 +470,9 @@ ahd_pci_test_register_access(struct ahd_
 	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
 	targpcistat = ahd_inb(ahd, TARGPCISTAT);
 	ahd_outb(ahd, TARGPCISTAT, targpcistat);
-	pci_status1 = ahd_pci_read_config(ahd->dev_softc,
+	pci_status1 = aic_pci_read_config(ahd->dev_softc,
 					  PCIR_STATUS + 1, /*bytes*/1);
-	ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+	aic_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
 			     pci_status1, /*bytes*/1);
 	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
 	ahd_outb(ahd, CLRINT, CLRPCIINT);
@@ -493,14 +501,14 @@ fail:
 
 		/* Silently clear any latched errors. */
 		ahd_outb(ahd, TARGPCISTAT, targpcistat);
-		pci_status1 = ahd_pci_read_config(ahd->dev_softc,
+		pci_status1 = aic_pci_read_config(ahd->dev_softc,
 						  PCIR_STATUS + 1, /*bytes*/1);
-		ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+		aic_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
 				     pci_status1, /*bytes*/1);
 		ahd_outb(ahd, CLRINT, CLRPCIINT);
 	}
 	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS);
-	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
+	aic_pci_write_config(ahd->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
 	return (error);
 }
 
@@ -649,14 +657,14 @@ ahd_configure_termination(struct ahd_sof
 	uint8_t	 termctl;
 	uint32_t devconfig;
 
-	devconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
+	devconfig = aic_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
 	devconfig &= ~STPWLEVEL;
 	if ((ahd->flags & AHD_STPWLEVEL_A) != 0)
 		devconfig |= STPWLEVEL;
 	if (bootverbose)
 		printf("%s: STPWLEVEL is %s\n",
 		       ahd_name(ahd), (devconfig & STPWLEVEL) ? "on" : "off");
-	ahd_pci_write_config(ahd->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
+	aic_pci_write_config(ahd->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
  
 	/* Make sure current sensing is off. */
 	if ((ahd->flags & AHD_CURRENT_SENSING) != 0) {
@@ -701,6 +709,7 @@ ahd_configure_termination(struct ahd_sof
 	 * Now set the termination based on what we found.
 	 */
 	sxfrctl1 = ahd_inb(ahd, SXFRCTL1) & ~STPWEN;
+	ahd->flags &= ~AHD_TERM_ENB_A;
 	if ((termctl & FLX_TERMCTL_ENPRILOW) != 0) {
 		ahd->flags |= AHD_TERM_ENB_A;
 		sxfrctl1 |= STPWEN;
@@ -833,9 +842,9 @@ ahd_pci_intr(struct ahd_softc *ahd)
 			}
 		}	
 	}
-	pci_status1 = ahd_pci_read_config(ahd->dev_softc,
+	pci_status1 = aic_pci_read_config(ahd->dev_softc,
 					  PCIR_STATUS + 1, /*bytes*/1);
-	ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+	aic_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
 			     pci_status1, /*bytes*/1);
 	ahd_restore_modes(ahd, saved_modes);
 	ahd_outb(ahd, CLRINT, CLRPCIINT);
@@ -857,7 +866,7 @@ ahd_pci_split_intr(struct ahd_softc *ahd
 	 * Check for splits in all modes.  Modes 0 and 1
 	 * additionally have SG engine splits to look at.
 	 */
-	pcix_status = ahd_pci_read_config(ahd->dev_softc, PCIXR_STATUS,
+	pcix_status = aic_pci_read_config(ahd->dev_softc, PCIXR_STATUS,
 					  /*bytes*/2);
 	printf("%s: PCI Split Interrupt - PCI-X status = 0x%x\n",
 	       ahd_name(ahd), pcix_status);
@@ -906,7 +915,7 @@ ahd_pci_split_intr(struct ahd_softc *ahd
 	/*
 	 * Clear PCI-X status bits.
 	 */
-	ahd_pci_write_config(ahd->dev_softc, PCIXR_STATUS,
+	aic_pci_write_config(ahd->dev_softc, PCIXR_STATUS,
 			     pcix_status, /*bytes*/2);
 	ahd_outb(ahd, CLRINT, CLRSPLTINT);
 	ahd_restore_modes(ahd, saved_modes);
@@ -941,18 +950,18 @@ ahd_aic7902_setup(struct ahd_softc *ahd)
 static int
 ahd_aic790X_setup(struct ahd_softc *ahd)
 {
-	ahd_dev_softc_t pci;
+	aic_dev_softc_t pci;
 	u_int rev;
 
 	pci = ahd->dev_softc;
-	rev = ahd_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
+	rev = aic_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev < ID_AIC7902_PCI_REV_A4) {
 		printf("%s: Unable to attach to unsupported chip revision %d\n",
 		       ahd_name(ahd), rev);
-		ahd_pci_write_config(pci, PCIR_COMMAND, 0, /*bytes*/2);
+		aic_pci_write_config(pci, PCIR_COMMAND, 0, /*bytes*/2);
 		return (ENXIO);
 	}
-	ahd->channel = ahd_get_pci_function(pci) + 'A';
+	ahd->channel = aic_get_pci_function(pci) + 'A';
 	if (rev < ID_AIC7902_PCI_REV_B0) {
 		/*
 		 * Enable A series workarounds.
@@ -1002,10 +1011,10 @@ ahd_aic790X_setup(struct ahd_softc *ahd)
 		 * XXX - Find out exactly what this does from the hardware
 		 * 	 folks!
 		 */
-		devconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
-		ahd_pci_write_config(pci, DEVCONFIG1,
+		devconfig1 = aic_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
+		aic_pci_write_config(pci, DEVCONFIG1,
 				     devconfig1|PREQDIS, /*bytes*/1);
-		devconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
+		devconfig1 = aic_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
 	}
 
 	return (0);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_proc.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_proc.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_proc.c	2004-04-04 05:37:40.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_proc.c	2004-05-13 16:42:17.000000000 +0200
@@ -37,7 +37,7 @@
  * String handling code courtesy of Gerard Roudier's <groudier@club-internet.fr>
  * sym driver.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#19 $
+ * $Id$
  */
 #include "aic79xx_osm.h"
 #include "aic79xx_inline.h"
@@ -49,7 +49,7 @@ static void	ahd_dump_target_state(struct
 				      u_int our_id, char channel,
 				      u_int target_id, u_int target_offset);
 static void	ahd_dump_device_state(struct info_str *info,
-				      struct ahd_linux_device *dev);
+				      struct aic_linux_device *dev);
 static int	ahd_proc_write_seeprom(struct ahd_softc *ahd,
 				       char *buffer, int length);
 
@@ -166,7 +166,7 @@ ahd_dump_target_state(struct ahd_softc *
 		      u_int our_id, char channel, u_int target_id,
 		      u_int target_offset)
 {
-	struct	ahd_linux_target *targ;
+	struct	aic_linux_target *targ;
 	struct	ahd_initiator_tinfo *tinfo;
 	struct	ahd_tmode_tstate *tstate;
 	int	lun;
@@ -187,7 +187,7 @@ ahd_dump_target_state(struct ahd_softc *
 	copy_info(info, "\tTransmission Errors %ld\n", targ->errors_detected);
 
 	for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
-		struct ahd_linux_device *dev;
+		struct aic_linux_device *dev;
 
 		dev = targ->devices[lun];
 
@@ -199,7 +199,7 @@ ahd_dump_target_state(struct ahd_softc *
 }
 
 static void
-ahd_dump_device_state(struct info_str *info, struct ahd_linux_device *dev)
+ahd_dump_device_state(struct info_str *info, struct aic_linux_device *dev)
 {
 	copy_info(info, "\tChannel %c Target %d Lun %d Settings\n",
 		  dev->target->channel + 'A', dev->target->target, dev->lun);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_reg.h_shipped linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_reg.h_shipped
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_reg.h_shipped	2004-04-04 05:38:23.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_reg.h_shipped	2004-05-13 16:42:17.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#94 $
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#70 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#118 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#75 $
  */
 typedef int (ahd_reg_print_t)(u_int, u_int *, u_int);
 typedef struct ahd_reg_parse_entry {
@@ -83,17 +83,17 @@ ahd_reg_print_t ahd_hs_mailbox_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrseqintstat_print;
+ahd_reg_print_t ahd_seqintstat_print;
 #else
-#define ahd_clrseqintstat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRSEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
+#define ahd_seqintstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqintstat_print;
+ahd_reg_print_t ahd_clrseqintstat_print;
 #else
-#define ahd_seqintstat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
+#define ahd_clrseqintstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -412,17 +412,17 @@ ahd_reg_print_t ahd_sxfrctl0_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_businitid_print;
+ahd_reg_print_t ahd_dlcount_print;
 #else
-#define ahd_businitid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BUSINITID", 0x3c, regvalue, cur_col, wrap)
+#define ahd_dlcount_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DLCOUNT", 0x3c, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dlcount_print;
+ahd_reg_print_t ahd_businitid_print;
 #else
-#define ahd_dlcount_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DLCOUNT", 0x3c, regvalue, cur_col, wrap)
+#define ahd_businitid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BUSINITID", 0x3c, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -517,13 +517,6 @@ ahd_reg_print_t ahd_selid_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sblkctl_print;
-#else
-#define ahd_sblkctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SBLKCTL", 0x4a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_optionmode_print;
 #else
 #define ahd_optionmode_print(regvalue, cur_col, wrap) \
@@ -531,10 +524,10 @@ ahd_reg_print_t ahd_optionmode_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sstat0_print;
+ahd_reg_print_t ahd_sblkctl_print;
 #else
-#define ahd_sstat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SSTAT0", 0x4b, regvalue, cur_col, wrap)
+#define ahd_sblkctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SBLKCTL", 0x4a, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -545,6 +538,13 @@ ahd_reg_print_t ahd_clrsint0_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat0_print;
+#else
+#define ahd_sstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT0", 0x4b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_simode0_print;
 #else
 #define ahd_simode0_print(regvalue, cur_col, wrap) \
@@ -573,17 +573,17 @@ ahd_reg_print_t ahd_sstat2_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrsint2_print;
+ahd_reg_print_t ahd_simode2_print;
 #else
-#define ahd_clrsint2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRSINT2", 0x4d, regvalue, cur_col, wrap)
+#define ahd_simode2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE2", 0x4d, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_simode2_print;
+ahd_reg_print_t ahd_clrsint2_print;
 #else
-#define ahd_simode2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SIMODE2", 0x4d, regvalue, cur_col, wrap)
+#define ahd_clrsint2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT2", 0x4d, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -685,13 +685,6 @@ ahd_reg_print_t ahd_clrsint3_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqomode0_print;
-#else
-#define ahd_lqomode0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOMODE0", 0x54, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_lqostat0_print;
 #else
 #define ahd_lqostat0_print(regvalue, cur_col, wrap) \
@@ -706,6 +699,20 @@ ahd_reg_print_t ahd_clrlqoint0_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqomode0_print;
+#else
+#define ahd_lqomode0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOMODE0", 0x54, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqomode1_print;
+#else
+#define ahd_lqomode1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOMODE1", 0x55, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_lqostat1_print;
 #else
 #define ahd_lqostat1_print(regvalue, cur_col, wrap) \
@@ -720,13 +727,6 @@ ahd_reg_print_t ahd_clrlqoint1_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqomode1_print;
-#else
-#define ahd_lqomode1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOMODE1", 0x55, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_lqostat2_print;
 #else
 #define ahd_lqostat2_print(regvalue, cur_col, wrap) \
@@ -909,17 +909,17 @@ ahd_reg_print_t ahd_annexcol_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scschkn_print;
+ahd_reg_print_t ahd_annexdat_print;
 #else
-#define ahd_scschkn_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSCHKN", 0x66, regvalue, cur_col, wrap)
+#define ahd_annexdat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ANNEXDAT", 0x66, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_annexdat_print;
+ahd_reg_print_t ahd_scschkn_print;
 #else
-#define ahd_annexdat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ANNEXDAT", 0x66, regvalue, cur_col, wrap)
+#define ahd_scschkn_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSCHKN", 0x66, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1000,17 +1000,17 @@ ahd_reg_print_t ahd_pll400ctl1_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_pll400cnt0_print;
+ahd_reg_print_t ahd_unfairness_print;
 #else
-#define ahd_pll400cnt0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PLL400CNT0", 0x6e, regvalue, cur_col, wrap)
+#define ahd_unfairness_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "UNFAIRNESS", 0x6e, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_unfairness_print;
+ahd_reg_print_t ahd_pll400cnt0_print;
 #else
-#define ahd_unfairness_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "UNFAIRNESS", 0x6e, regvalue, cur_col, wrap)
+#define ahd_pll400cnt0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL400CNT0", 0x6e, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1056,13 +1056,6 @@ ahd_reg_print_t ahd_hodmaen_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sghaddr_print;
-#else
-#define ahd_sghaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGHADDR", 0x7c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_scbhaddr_print;
 #else
 #define ahd_scbhaddr_print(regvalue, cur_col, wrap) \
@@ -1070,10 +1063,10 @@ ahd_reg_print_t ahd_scbhaddr_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sghcnt_print;
+ahd_reg_print_t ahd_sghaddr_print;
 #else
-#define ahd_sghcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGHCNT", 0x84, regvalue, cur_col, wrap)
+#define ahd_sghaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGHADDR", 0x7c, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1084,6 +1077,13 @@ ahd_reg_print_t ahd_scbhcnt_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sghcnt_print;
+#else
+#define ahd_sghcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGHCNT", 0x84, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_dff_thrsh_print;
 #else
 #define ahd_dff_thrsh_print(regvalue, cur_col, wrap) \
@@ -1154,13 +1154,6 @@ ahd_reg_print_t ahd_nsenable_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchrxmsg1_print;
-#else
-#define ahd_dchrxmsg1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHRXMSG1", 0x91, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_cmcrxmsg1_print;
 #else
 #define ahd_cmcrxmsg1_print(regvalue, cur_col, wrap) \
@@ -1168,17 +1161,17 @@ ahd_reg_print_t ahd_cmcrxmsg1_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchrxmsg2_print;
+ahd_reg_print_t ahd_dchrxmsg1_print;
 #else
-#define ahd_dchrxmsg2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHRXMSG2", 0x92, regvalue, cur_col, wrap)
+#define ahd_dchrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG1", 0x91, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyrxmsg2_print;
+ahd_reg_print_t ahd_dchrxmsg2_print;
 #else
-#define ahd_ovlyrxmsg2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYRXMSG2", 0x92, regvalue, cur_col, wrap)
+#define ahd_dchrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG2", 0x92, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1196,6 +1189,13 @@ ahd_reg_print_t ahd_ost_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg2_print;
+#else
+#define ahd_ovlyrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG2", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_dchrxmsg3_print;
 #else
 #define ahd_dchrxmsg3_print(regvalue, cur_col, wrap) \
@@ -1203,6 +1203,13 @@ ahd_reg_print_t ahd_dchrxmsg3_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg3_print;
+#else
+#define ahd_ovlyrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG3", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_cmcrxmsg3_print;
 #else
 #define ahd_cmcrxmsg3_print(regvalue, cur_col, wrap) \
@@ -1217,13 +1224,6 @@ ahd_reg_print_t ahd_pcixctl_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyrxmsg3_print;
-#else
-#define ahd_ovlyrxmsg3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYRXMSG3", 0x93, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_ovlyseqbcnt_print;
 #else
 #define ahd_ovlyseqbcnt_print(regvalue, cur_col, wrap) \
@@ -1231,13 +1231,6 @@ ahd_reg_print_t ahd_ovlyseqbcnt_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcseqbcnt_print;
-#else
-#define ahd_cmcseqbcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCSEQBCNT", 0x94, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_dchseqbcnt_print;
 #else
 #define ahd_dchseqbcnt_print(regvalue, cur_col, wrap) \
@@ -1245,17 +1238,17 @@ ahd_reg_print_t ahd_dchseqbcnt_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcspltstat0_print;
+ahd_reg_print_t ahd_cmcseqbcnt_print;
 #else
-#define ahd_cmcspltstat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
+#define ahd_cmcseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCSEQBCNT", 0x94, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyspltstat0_print;
+ahd_reg_print_t ahd_cmcspltstat0_print;
 #else
-#define ahd_ovlyspltstat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
+#define ahd_cmcspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1266,10 +1259,10 @@ ahd_reg_print_t ahd_dchspltstat0_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchspltstat1_print;
+ahd_reg_print_t ahd_ovlyspltstat0_print;
 #else
-#define ahd_dchspltstat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
+#define ahd_ovlyspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1287,6 +1280,13 @@ ahd_reg_print_t ahd_ovlyspltstat1_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchspltstat1_print;
+#else
+#define ahd_dchspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_sgrxmsg0_print;
 #else
 #define ahd_sgrxmsg0_print(regvalue, cur_col, wrap) \
@@ -1378,17 +1378,17 @@ ahd_reg_print_t ahd_sgspltstat0_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sfunct_print;
+ahd_reg_print_t ahd_sgspltstat1_print;
 #else
-#define ahd_sfunct_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SFUNCT", 0x9f, regvalue, cur_col, wrap)
+#define ahd_sgspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGSPLTSTAT1", 0x9f, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgspltstat1_print;
+ahd_reg_print_t ahd_sfunct_print;
 #else
-#define ahd_sgspltstat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGSPLTSTAT1", 0x9f, regvalue, cur_col, wrap)
+#define ahd_sfunct_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SFUNCT", 0x9f, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1504,17 +1504,17 @@ ahd_reg_print_t ahd_ccsgaddr_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccscbaddr_print;
+ahd_reg_print_t ahd_ccscbadr_bk_print;
 #else
-#define ahd_ccscbaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSCBADDR", 0xac, regvalue, cur_col, wrap)
+#define ahd_ccscbadr_bk_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBADR_BK", 0xac, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccscbadr_bk_print;
+ahd_reg_print_t ahd_ccscbaddr_print;
 #else
-#define ahd_ccscbadr_bk_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSCBADR_BK", 0xac, regvalue, cur_col, wrap)
+#define ahd_ccscbaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBADDR", 0xac, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1525,17 +1525,17 @@ ahd_reg_print_t ahd_cmc_rambist_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccsgctl_print;
+ahd_reg_print_t ahd_ccscbctl_print;
 #else
-#define ahd_ccsgctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSGCTL", 0xad, regvalue, cur_col, wrap)
+#define ahd_ccscbctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBCTL", 0xad, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccscbctl_print;
+ahd_reg_print_t ahd_ccsgctl_print;
 #else
-#define ahd_ccscbctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSCBCTL", 0xad, regvalue, cur_col, wrap)
+#define ahd_ccsgctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSGCTL", 0xad, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1707,13 +1707,6 @@ ahd_reg_print_t ahd_wrtbiascalc_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfptrs_print;
-#else
-#define ahd_dfptrs_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFPTRS", 0xc8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_rcvrbiascalc_print;
 #else
 #define ahd_rcvrbiascalc_print(regvalue, cur_col, wrap) \
@@ -1721,10 +1714,10 @@ ahd_reg_print_t ahd_rcvrbiascalc_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfbkptr_print;
+ahd_reg_print_t ahd_dfptrs_print;
 #else
-#define ahd_dfbkptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFBKPTR", 0xc9, regvalue, cur_col, wrap)
+#define ahd_dfptrs_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFPTRS", 0xc8, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1735,6 +1728,13 @@ ahd_reg_print_t ahd_skewcalc_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfbkptr_print;
+#else
+#define ahd_dfbkptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFBKPTR", 0xc9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_dfdbctl_print;
 #else
 #define ahd_dfdbctl_print(regvalue, cur_col, wrap) \
@@ -1826,17 +1826,17 @@ ahd_reg_print_t ahd_dindex_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_brkaddr1_print;
+ahd_reg_print_t ahd_brkaddr0_print;
 #else
-#define ahd_brkaddr1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BRKADDR1", 0xe6, regvalue, cur_col, wrap)
+#define ahd_brkaddr0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRKADDR0", 0xe6, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_brkaddr0_print;
+ahd_reg_print_t ahd_brkaddr1_print;
 #else
-#define ahd_brkaddr0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BRKADDR0", 0xe6, regvalue, cur_col, wrap)
+#define ahd_brkaddr1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRKADDR1", 0xe6, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1889,13 +1889,6 @@ ahd_reg_print_t ahd_stack_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_curaddr_print;
-#else
-#define ahd_curaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CURADDR", 0xf4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_intvec1_addr_print;
 #else
 #define ahd_intvec1_addr_print(regvalue, cur_col, wrap) \
@@ -1903,10 +1896,10 @@ ahd_reg_print_t ahd_intvec1_addr_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_intvec2_addr_print;
+ahd_reg_print_t ahd_curaddr_print;
 #else
-#define ahd_intvec2_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INTVEC2_ADDR", 0xf6, regvalue, cur_col, wrap)
+#define ahd_curaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CURADDR", 0xf4, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -1917,6 +1910,13 @@ ahd_reg_print_t ahd_lastaddr_print;
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intvec2_addr_print;
+#else
+#define ahd_intvec2_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTVEC2_ADDR", 0xf6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_longjmp_addr_print;
 #else
 #define ahd_longjmp_addr_print(regvalue, cur_col, wrap) \
@@ -1994,192 +1994,213 @@ ahd_reg_print_t ahd_complete_dma_scb_hea
 #endif
 
 #if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_complete_dma_scb_tail_print;
+#else
+#define ahd_complete_dma_scb_tail_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "COMPLETE_DMA_SCB_TAIL", 0x12e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_complete_on_qfreeze_head_print;
+#else
+#define ahd_complete_on_qfreeze_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "COMPLETE_ON_QFREEZE_HEAD", 0x130, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_qfreeze_count_print;
 #else
 #define ahd_qfreeze_count_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "QFREEZE_COUNT", 0x12e, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "QFREEZE_COUNT", 0x132, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_kernel_qfreeze_count_print;
+#else
+#define ahd_kernel_qfreeze_count_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "KERNEL_QFREEZE_COUNT", 0x134, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_saved_mode_print;
 #else
 #define ahd_saved_mode_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SAVED_MODE", 0x130, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "SAVED_MODE", 0x136, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_msg_out_print;
 #else
 #define ahd_msg_out_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MSG_OUT", 0x131, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "MSG_OUT", 0x137, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_dmaparams_print;
 #else
 #define ahd_dmaparams_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DMAPARAMS", 0x132, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "DMAPARAMS", 0x138, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_seq_flags_print;
 #else
 #define ahd_seq_flags_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQ_FLAGS", 0x133, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "SEQ_FLAGS", 0x139, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_saved_scsiid_print;
 #else
 #define ahd_saved_scsiid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SAVED_SCSIID", 0x134, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "SAVED_SCSIID", 0x13a, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_saved_lun_print;
 #else
 #define ahd_saved_lun_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SAVED_LUN", 0x135, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "SAVED_LUN", 0x13b, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_lastphase_print;
 #else
 #define ahd_lastphase_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LASTPHASE", 0x136, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "LASTPHASE", 0x13c, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_qoutfifo_entry_valid_tag_print;
 #else
 #define ahd_qoutfifo_entry_valid_tag_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG", 0x137, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG", 0x13d, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_shared_data_addr_print;
+ahd_reg_print_t ahd_kernel_tqinpos_print;
 #else
-#define ahd_shared_data_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SHARED_DATA_ADDR", 0x138, regvalue, cur_col, wrap)
+#define ahd_kernel_tqinpos_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "KERNEL_TQINPOS", 0x13e, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_qoutfifo_next_addr_print;
+ahd_reg_print_t ahd_tqinpos_print;
 #else
-#define ahd_qoutfifo_next_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR", 0x13c, regvalue, cur_col, wrap)
+#define ahd_tqinpos_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TQINPOS", 0x13f, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_kernel_tqinpos_print;
+ahd_reg_print_t ahd_shared_data_addr_print;
 #else
-#define ahd_kernel_tqinpos_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "KERNEL_TQINPOS", 0x140, regvalue, cur_col, wrap)
+#define ahd_shared_data_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHARED_DATA_ADDR", 0x140, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_tqinpos_print;
+ahd_reg_print_t ahd_qoutfifo_next_addr_print;
 #else
-#define ahd_tqinpos_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "TQINPOS", 0x141, regvalue, cur_col, wrap)
+#define ahd_qoutfifo_next_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR", 0x144, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_arg_1_print;
 #else
 #define ahd_arg_1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ARG_1", 0x142, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "ARG_1", 0x148, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_arg_2_print;
 #else
 #define ahd_arg_2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ARG_2", 0x143, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "ARG_2", 0x149, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_last_msg_print;
 #else
 #define ahd_last_msg_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LAST_MSG", 0x144, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "LAST_MSG", 0x14a, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_scsiseq_template_print;
 #else
 #define ahd_scsiseq_template_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSISEQ_TEMPLATE", 0x145, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "SCSISEQ_TEMPLATE", 0x14b, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_initiator_tag_print;
 #else
 #define ahd_initiator_tag_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INITIATOR_TAG", 0x146, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "INITIATOR_TAG", 0x14c, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_seq_flags2_print;
 #else
 #define ahd_seq_flags2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQ_FLAGS2", 0x147, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "SEQ_FLAGS2", 0x14d, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_allocfifo_scbptr_print;
 #else
 #define ahd_allocfifo_scbptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR", 0x148, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR", 0x14e, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_int_coalescing_timer_print;
 #else
 #define ahd_int_coalescing_timer_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INT_COALESCING_TIMER", 0x14a, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "INT_COALESCING_TIMER", 0x150, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_int_coalescing_maxcmds_print;
 #else
 #define ahd_int_coalescing_maxcmds_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INT_COALESCING_MAXCMDS", 0x14c, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "INT_COALESCING_MAXCMDS", 0x152, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_int_coalescing_mincmds_print;
 #else
 #define ahd_int_coalescing_mincmds_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INT_COALESCING_MINCMDS", 0x14d, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "INT_COALESCING_MINCMDS", 0x153, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_cmds_pending_print;
 #else
 #define ahd_cmds_pending_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMDS_PENDING", 0x14e, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "CMDS_PENDING", 0x154, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_int_coalescing_cmdcount_print;
 #else
 #define ahd_int_coalescing_cmdcount_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INT_COALESCING_CMDCOUNT", 0x150, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "INT_COALESCING_CMDCOUNT", 0x156, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_local_hs_mailbox_print;
 #else
 #define ahd_local_hs_mailbox_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LOCAL_HS_MAILBOX", 0x151, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "LOCAL_HS_MAILBOX", 0x157, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
 ahd_reg_print_t ahd_cmdsize_table_print;
 #else
 #define ahd_cmdsize_table_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMDSIZE_TABLE", 0x152, regvalue, cur_col, wrap)
+    ahd_print_register(NULL, 0, "CMDSIZE_TABLE", 0x158, regvalue, cur_col, wrap)
 #endif
 
 #if AIC_DEBUG_REGISTERS
@@ -2434,13 +2455,6 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		HOST_TQINPOS    	0x80
 #define		ENINT_COALESCE  	0x40
 
-#define	CLRSEQINTSTAT   		0x0c
-#define		CLRSEQ_SWTMRTO  	0x10
-#define		CLRSEQ_SEQINT   	0x08
-#define		CLRSEQ_SCSIINT  	0x04
-#define		CLRSEQ_PCIINT   	0x02
-#define		CLRSEQ_SPLTINT  	0x01
-
 #define	SEQINTSTAT      		0x0c
 #define		SEQ_SWTMRTO     	0x10
 #define		SEQ_SEQINT      	0x08
@@ -2448,6 +2462,13 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		SEQ_PCIINT      	0x02
 #define		SEQ_SPLTINT     	0x01
 
+#define	CLRSEQINTSTAT   		0x0c
+#define		CLRSEQ_SWTMRTO  	0x10
+#define		CLRSEQ_SEQINT   	0x08
+#define		CLRSEQ_SCSIINT  	0x04
+#define		CLRSEQ_PCIINT   	0x02
+#define		CLRSEQ_SPLTINT  	0x01
+
 #define	SWTIMER         		0x0e
 
 #define	SNSCB_QOFF      		0x10
@@ -2623,10 +2644,10 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		BIOSCANCELEN    	0x10
 #define		SPIOEN          	0x08
 
-#define	BUSINITID       		0x3c
-
 #define	DLCOUNT         		0x3c
 
+#define	BUSINITID       		0x3c
+
 #define	SXFRCTL1        		0x3d
 #define		BITBUCKET       	0x80
 #define		ENSACHK         	0x40
@@ -2693,13 +2714,6 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		SELID_MASK      	0xf0
 #define		ONEBIT          	0x08
 
-#define	SBLKCTL         		0x4a
-#define		DIAGLEDEN       	0x80
-#define		DIAGLEDON       	0x40
-#define		ENAB40          	0x08
-#define		ENAB20          	0x04
-#define		SELWIDE         	0x02
-
 #define	OPTIONMODE      		0x4a
 #define		OPTIONMODE_DEFAULTS	0x02
 #define		BIOSCANCTL      	0x80
@@ -2709,15 +2723,12 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		ENDGFORMCHK     	0x04
 #define		AUTO_MSGOUT_DE  	0x02
 
-#define	SSTAT0          		0x4b
-#define		TARGET          	0x80
-#define		SELDO           	0x40
-#define		SELDI           	0x20
-#define		SELINGO         	0x10
-#define		IOERR           	0x08
-#define		OVERRUN         	0x04
-#define		SPIORDY         	0x02
-#define		ARBDO           	0x01
+#define	SBLKCTL         		0x4a
+#define		DIAGLEDEN       	0x80
+#define		DIAGLEDON       	0x40
+#define		ENAB40          	0x08
+#define		ENAB20          	0x04
+#define		SELWIDE         	0x02
 
 #define	CLRSINT0        		0x4b
 #define		CLRSELDO        	0x40
@@ -2728,6 +2739,16 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		CLRSPIORDY      	0x02
 #define		CLRARBDO        	0x01
 
+#define	SSTAT0          		0x4b
+#define		TARGET          	0x80
+#define		SELDO           	0x40
+#define		SELDI           	0x20
+#define		SELINGO         	0x10
+#define		IOERR           	0x08
+#define		OVERRUN         	0x04
+#define		SPIORDY         	0x02
+#define		ARBDO           	0x01
+
 #define	SIMODE0         		0x4b
 #define		ENSELDO         	0x40
 #define		ENSELDI         	0x20
@@ -2768,17 +2789,17 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		BUSFREE_DFF0    	0x80
 #define		BUSFREE_LQO     	0x40
 
+#define	SIMODE2         		0x4d
+#define		ENWIDE_RES      	0x04
+#define		ENSDONE         	0x02
+#define		ENDMADONE       	0x01
+
 #define	CLRSINT2        		0x4d
 #define		CLRNONPACKREQ   	0x20
 #define		CLRWIDE_RES     	0x04
 #define		CLRSDONE        	0x02
 #define		CLRDMADONE      	0x01
 
-#define	SIMODE2         		0x4d
-#define		ENWIDE_RES      	0x04
-#define		ENSDONE         	0x02
-#define		ENDMADONE       	0x01
-
 #define	PERRDIAG        		0x4e
 #define		HIZERO          	0x80
 #define		HIPERR          	0x40
@@ -2871,13 +2892,6 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		CLRNTRAMPERR    	0x02
 #define		CLROSRAMPERR    	0x01
 
-#define	LQOMODE0        		0x54
-#define		ENLQOTARGSCBPERR	0x10
-#define		ENLQOSTOPT2     	0x08
-#define		ENLQOATNLQ      	0x04
-#define		ENLQOATNPKT     	0x02
-#define		ENLQOTCRC       	0x01
-
 #define	LQOSTAT0        		0x54
 #define		LQOTARGSCBPERR  	0x10
 #define		LQOSTOPT2       	0x08
@@ -2892,6 +2906,20 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		CLRLQOATNPKT    	0x02
 #define		CLRLQOTCRC      	0x01
 
+#define	LQOMODE0        		0x54
+#define		ENLQOTARGSCBPERR	0x10
+#define		ENLQOSTOPT2     	0x08
+#define		ENLQOATNLQ      	0x04
+#define		ENLQOATNPKT     	0x02
+#define		ENLQOTCRC       	0x01
+
+#define	LQOMODE1        		0x55
+#define		ENLQOINITSCBPERR	0x10
+#define		ENLQOSTOPI2     	0x08
+#define		ENLQOBADQAS     	0x04
+#define		ENLQOBUSFREE    	0x02
+#define		ENLQOPHACHGINPKT	0x01
+
 #define	LQOSTAT1        		0x55
 #define		LQOINITSCBPERR  	0x10
 #define		LQOSTOPI2       	0x08
@@ -2906,13 +2934,6 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		CLRLQOBUSFREE   	0x02
 #define		CLRLQOPHACHGINPKT	0x01
 
-#define	LQOMODE1        		0x55
-#define		ENLQOINITSCBPERR	0x10
-#define		ENLQOSTOPI2     	0x08
-#define		ENLQOBADQAS     	0x04
-#define		ENLQOBUSFREE    	0x02
-#define		ENLQOPHACHGINPKT	0x01
-
 #define	LQOSTAT2        		0x56
 #define		LQOPKT          	0xe0
 #define		LQOWAITFIFO     	0x10
@@ -3028,6 +3049,8 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 
 #define	ANNEXCOL        		0x65
 
+#define	ANNEXDAT        		0x66
+
 #define	SCSCHKN         		0x66
 #define		STSELSKIDDIS    	0x40
 #define		CURRFIFODEF     	0x20
@@ -3037,8 +3060,6 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		SHVALIDSTDIS    	0x02
 #define		LSTSGCLRDIS     	0x01
 
-#define	ANNEXDAT        		0x66
-
 #define	IOWNID          		0x67
 
 #define	PLL960CTL0      		0x68
@@ -3071,10 +3092,10 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		PLL_CNTCLR      	0x40
 #define		PLL_RST         	0x01
 
-#define	PLL400CNT0      		0x6e
-
 #define	UNFAIRNESS      		0x6e
 
+#define	PLL400CNT0      		0x6e
+
 #define	HADDR           		0x70
 
 #define	PLLDELAY        		0x70
@@ -3088,14 +3109,14 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 
 #define	HODMAEN         		0x7a
 
-#define	SGHADDR         		0x7c
-
 #define	SCBHADDR        		0x7c
 
-#define	SGHCNT          		0x84
+#define	SGHADDR         		0x7c
 
 #define	SCBHCNT         		0x84
 
+#define	SGHCNT          		0x84
+
 #define	DFF_THRSH       		0x88
 #define		WR_DFTHRSH      	0x70
 #define		RD_DFTHRSH      	0x07
@@ -3113,8 +3134,8 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		RD_DFTHRSH_63   	0x03
 #define		RD_DFTHRSH_50   	0x02
 #define		RD_DFTHRSH_25   	0x01
-#define		WR_DFTHRSH_MIN  	0x00
 #define		RD_DFTHRSH_MIN  	0x00
+#define		WR_DFTHRSH_MIN  	0x00
 
 #define	ROMADDR         		0x8a
 
@@ -3150,20 +3171,22 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		DCH1NSEN        	0x02
 #define		DCH0NSEN        	0x01
 
-#define	DCHRXMSG1       		0x91
-
 #define	CMCRXMSG1       		0x91
 
-#define	DCHRXMSG2       		0x92
+#define	DCHRXMSG1       		0x91
 
-#define	OVLYRXMSG2      		0x92
+#define	DCHRXMSG2       		0x92
 
 #define	CMCRXMSG2       		0x92
 
 #define	OST             		0x92
 
+#define	OVLYRXMSG2      		0x92
+
 #define	DCHRXMSG3       		0x93
 
+#define	OVLYRXMSG3      		0x93
+
 #define	CMCRXMSG3       		0x93
 
 #define	PCIXCTL         		0x93
@@ -3175,26 +3198,24 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		TSCSERREN       	0x02
 #define		CMPABCDIS       	0x01
 
-#define	OVLYRXMSG3      		0x93
-
 #define	OVLYSEQBCNT     		0x94
 
-#define	CMCSEQBCNT      		0x94
-
 #define	DCHSEQBCNT      		0x94
 
-#define	CMCSPLTSTAT0    		0x96
+#define	CMCSEQBCNT      		0x94
 
-#define	OVLYSPLTSTAT0   		0x96
+#define	CMCSPLTSTAT0    		0x96
 
 #define	DCHSPLTSTAT0    		0x96
 
-#define	DCHSPLTSTAT1    		0x97
+#define	OVLYSPLTSTAT0   		0x96
 
 #define	CMCSPLTSTAT1    		0x97
 
 #define	OVLYSPLTSTAT1   		0x97
 
+#define	DCHSPLTSTAT1    		0x97
+
 #define	SGRXMSG0        		0x98
 #define		CDNUM           	0xf8
 #define		CFNUM           	0x07
@@ -3244,13 +3265,13 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		RXSCEMSG        	0x02
 #define		RXSPLTRSP       	0x01
 
+#define	SGSPLTSTAT1     		0x9f
+#define		RXDATABUCKET    	0x01
+
 #define	SFUNCT          		0x9f
 #define		TEST_GROUP      	0xf0
 #define		TEST_NUM        	0x0f
 
-#define	SGSPLTSTAT1     		0x9f
-#define		RXDATABUCKET    	0x01
-
 #define	DF0PCISTAT      		0xa0
 
 #define	REG0            		0xa0
@@ -3299,10 +3320,10 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 
 #define	CCSGADDR        		0xac
 
-#define	CCSCBADDR       		0xac
-
 #define	CCSCBADR_BK     		0xac
 
+#define	CCSCBADDR       		0xac
+
 #define	CMC_RAMBIST     		0xad
 #define		SG_ELEMENT_SIZE 	0x80
 #define		SCBRAMBIST_FAIL 	0x40
@@ -3311,14 +3332,6 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		CMC_BUFFER_BIST_FAIL	0x02
 #define		CMC_BUFFER_BIST_EN	0x01
 
-#define	CCSGCTL         		0xad
-#define		CCSGEN          	0x0c
-#define		CCSGDONE        	0x80
-#define		SG_CACHE_AVAIL  	0x10
-#define		CCSGENACK       	0x08
-#define		SG_FETCH_REQ    	0x02
-#define		CCSGRESET       	0x01
-
 #define	CCSCBCTL        		0xad
 #define		CCSCBDONE       	0x80
 #define		ARRDONE         	0x40
@@ -3327,6 +3340,14 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		CCSCBDIR        	0x04
 #define		CCSCBRESET      	0x01
 
+#define	CCSGCTL         		0xad
+#define		CCSGEN          	0x0c
+#define		CCSGDONE        	0x80
+#define		SG_CACHE_AVAIL  	0x10
+#define		CCSGENACK       	0x08
+#define		SG_FETCH_REQ    	0x02
+#define		CCSGRESET       	0x01
+
 #define	CCSGRAM         		0xb0
 
 #define	FLEXADR         		0xb0
@@ -3356,8 +3377,8 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define	SEEDAT          		0xbc
 
 #define	SEECTL          		0xbe
-#define		SEEOP_EWEN      	0x40
 #define		SEEOP_WALL      	0x40
+#define		SEEOP_EWEN      	0x40
 #define		SEEOP_EWDS      	0x40
 #define		SEEOPCODE       	0x70
 #define		SEERST          	0x02
@@ -3414,14 +3435,14 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 
 #define	WRTBIASCALC     		0xc7
 
-#define	DFPTRS          		0xc8
-
 #define	RCVRBIASCALC    		0xc8
 
-#define	DFBKPTR         		0xc9
+#define	DFPTRS          		0xc8
 
 #define	SKEWCALC        		0xc9
 
+#define	DFBKPTR         		0xc9
+
 #define	DFDBCTL         		0xcb
 #define		DFF_CIO_WR_RDY  	0x20
 #define		DFF_CIO_RD_RDY  	0x10
@@ -3475,11 +3496,11 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 
 #define	DINDEX          		0xe4
 
+#define	BRKADDR0        		0xe6
+
 #define	BRKADDR1        		0xe6
 #define		BRKDIS          	0x80
 
-#define	BRKADDR0        		0xe6
-
 #define	ALLONES         		0xe8
 
 #define	ALLZEROS        		0xea
@@ -3494,14 +3515,14 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 
 #define	STACK           		0xf2
 
-#define	CURADDR         		0xf4
-
 #define	INTVEC1_ADDR    		0xf4
 
-#define	INTVEC2_ADDR    		0xf6
+#define	CURADDR         		0xf4
 
 #define	LASTADDR        		0xf6
 
+#define	INTVEC2_ADDR    		0xf6
+
 #define	LONGJMP_ADDR    		0xf8
 
 #define	ACCUM_SAVE      		0xfa
@@ -3524,25 +3545,31 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 
 #define	COMPLETE_DMA_SCB_HEAD		0x12c
 
-#define	QFREEZE_COUNT   		0x12e
+#define	COMPLETE_DMA_SCB_TAIL		0x12e
+
+#define	COMPLETE_ON_QFREEZE_HEAD		0x130
+
+#define	QFREEZE_COUNT   		0x132
 
-#define	SAVED_MODE      		0x130
+#define	KERNEL_QFREEZE_COUNT		0x134
 
-#define	MSG_OUT         		0x131
+#define	SAVED_MODE      		0x136
 
-#define	DMAPARAMS       		0x132
+#define	MSG_OUT         		0x137
+
+#define	DMAPARAMS       		0x138
 #define		PRELOADEN       	0x80
 #define		WIDEODD         	0x40
 #define		SCSIEN          	0x20
 #define		SDMAEN          	0x10
 #define		SDMAENACK       	0x10
-#define		HDMAENACK       	0x08
 #define		HDMAEN          	0x08
+#define		HDMAENACK       	0x08
 #define		DIRECTION       	0x04
 #define		FIFOFLUSH       	0x02
 #define		FIFORESET       	0x01
 
-#define	SEQ_FLAGS       		0x133
+#define	SEQ_FLAGS       		0x139
 #define		NOT_IDENTIFIED  	0x80
 #define		NO_CDB_SENT     	0x40
 #define		TARGET_CMD_IS_TAGGED	0x40
@@ -3553,11 +3580,11 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		SPHASE_PENDING  	0x02
 #define		NO_DISCONNECT   	0x01
 
-#define	SAVED_SCSIID    		0x134
+#define	SAVED_SCSIID    		0x13a
 
-#define	SAVED_LUN       		0x135
+#define	SAVED_LUN       		0x13b
 
-#define	LASTPHASE       		0x136
+#define	LASTPHASE       		0x13c
 #define		PHASE_MASK      	0xe0
 #define		CDI             	0x80
 #define		IOI             	0x40
@@ -3572,18 +3599,18 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		P_DATAOUT_DT    	0x20
 #define		P_DATAOUT       	0x00
 
-#define	QOUTFIFO_ENTRY_VALID_TAG		0x137
+#define	QOUTFIFO_ENTRY_VALID_TAG		0x13d
 
-#define	SHARED_DATA_ADDR		0x138
+#define	KERNEL_TQINPOS  		0x13e
 
-#define	QOUTFIFO_NEXT_ADDR		0x13c
+#define	TQINPOS         		0x13f
 
-#define	KERNEL_TQINPOS  		0x140
+#define	SHARED_DATA_ADDR		0x140
 
-#define	TQINPOS         		0x141
+#define	QOUTFIFO_NEXT_ADDR		0x144
 
-#define	ARG_1           		0x142
-#define	RETURN_1        		0x142
+#define	ARG_1           		0x148
+#define	RETURN_1        		0x148
 #define		SEND_MSG        	0x80
 #define		SEND_SENSE      	0x40
 #define		SEND_REJ        	0x20
@@ -3593,12 +3620,12 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		CONT_MSG_LOOP_READ	0x03
 #define		CONT_MSG_LOOP_TARG	0x02
 
-#define	ARG_2           		0x143
-#define	RETURN_2        		0x143
+#define	ARG_2           		0x149
+#define	RETURN_2        		0x149
 
-#define	LAST_MSG        		0x144
+#define	LAST_MSG        		0x14a
 
-#define	SCSISEQ_TEMPLATE		0x145
+#define	SCSISEQ_TEMPLATE		0x14b
 #define		MANUALCTL       	0x40
 #define		ENSELI          	0x20
 #define		ENRSELI         	0x10
@@ -3606,27 +3633,27 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define		ENAUTOATNP      	0x02
 #define		ALTSTIM         	0x01
 
-#define	INITIATOR_TAG   		0x146
+#define	INITIATOR_TAG   		0x14c
 
-#define	SEQ_FLAGS2      		0x147
+#define	SEQ_FLAGS2      		0x14d
 #define		SELECTOUT_QFROZEN	0x04
 #define		TARGET_MSG_PENDING	0x02
 
-#define	ALLOCFIFO_SCBPTR		0x148
+#define	ALLOCFIFO_SCBPTR		0x14e
 
-#define	INT_COALESCING_TIMER		0x14a
+#define	INT_COALESCING_TIMER		0x150
 
-#define	INT_COALESCING_MAXCMDS		0x14c
+#define	INT_COALESCING_MAXCMDS		0x152
 
-#define	INT_COALESCING_MINCMDS		0x14d
+#define	INT_COALESCING_MINCMDS		0x153
 
-#define	CMDS_PENDING    		0x14e
+#define	CMDS_PENDING    		0x154
 
-#define	INT_COALESCING_CMDCOUNT		0x150
+#define	INT_COALESCING_CMDCOUNT		0x156
 
-#define	LOCAL_HS_MAILBOX		0x151
+#define	LOCAL_HS_MAILBOX		0x157
 
-#define	CMDSIZE_TABLE   		0x152
+#define	CMDSIZE_TABLE   		0x158
 
 #define	SCB_BASE        		0x180
 
@@ -3701,6 +3728,16 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define	SCB_DISCONNECTED_LISTS		0x1b8
 
 
+#define	AHD_TIMER_MAX_US	0x18ffe7
+#define	AHD_TIMER_MAX_TICKS	0xffff
+#define	AHD_SENSE_BUFSIZE	0x100
+#define	BUS_8_BIT	0x00
+#define	TARGET_CMD_CMPLT	0xfe
+#define	SEEOP_WRAL_ADDR	0x40
+#define	AHD_AMPLITUDE_DEF	0x07
+#define	AHD_PRECOMP_CUTBACK_37	0x07
+#define	AHD_PRECOMP_SHIFT	0x00
+#define	AHD_ANNEXCOL_PRECOMP_SLEW	0x04
 #define	AHD_TIMER_US_PER_TICK	0x19
 #define	SCB_TRANSFER_SIZE_FULL_LUN	0x38
 #define	STATUS_QUEUE_FULL	0x28
@@ -3724,28 +3761,18 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 #define	B_CURRFIFO_0	0x02
 #define	LUNLEN_SINGLE_LEVEL_LUN	0x0f
 #define	NVRAM_SCB_OFFSET	0x2c
-#define	AHD_TIMER_MAX_US	0x18ffe7
-#define	AHD_TIMER_MAX_TICKS	0xffff
 #define	STATUS_PKT_SENSE	0xff
 #define	CMD_GROUP_CODE_SHIFT	0x05
-#define	AHD_SENSE_BUFSIZE	0x100
 #define	MAX_OFFSET_PACED_BUG	0x7f
-#define	BUS_8_BIT	0x00
 #define	STIMESEL_BUG_ADJ	0x08
 #define	STIMESEL_MIN	0x18
 #define	STIMESEL_SHIFT	0x03
 #define	CCSGRAM_MAXSEGS	0x10
 #define	INVALID_ADDR	0x80
-#define	TARGET_CMD_CMPLT	0xfe
-#define	SEEOP_WRAL_ADDR	0x40
 #define	SEEOP_ERAL_ADDR	0x80
-#define	AHD_AMPLITUDE_DEF	0x07
 #define	AHD_SLEWRATE_DEF_REVB	0x08
-#define	AHD_PRECOMP_CUTBACK_37	0x07
 #define	AHD_PRECOMP_CUTBACK_17	0x04
-#define	AHD_PRECOMP_SHIFT	0x00
 #define	AHD_PRECOMP_MASK	0x07
-#define	AHD_ANNEXCOL_PRECOMP_SLEW	0x04
 #define	SRC_MODE_SHIFT	0x00
 #define	PKT_OVERRUN_BUFSIZE	0x200
 #define	SCB_TRANSFER_SIZE_1BYTE_LUN	0x30
@@ -3772,5 +3799,5 @@ ahd_reg_print_t ahd_scb_disconnected_lis
 
 
 /* Exported Labels */
-#define	LABEL_seq_isr 	0x269
-#define	LABEL_timer_isr	0x265
+#define	LABEL_seq_isr 	0x283
+#define	LABEL_timer_isr	0x27f
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_reg_print.c_shipped linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_reg_print.c_shipped
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_reg_print.c_shipped	2004-04-04 05:36:13.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_reg_print.c_shipped	2004-05-13 16:42:17.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#94 $
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#70 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#118 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#75 $
  */
 
 #include "aic79xx_osm.h"
@@ -172,21 +172,6 @@ ahd_hs_mailbox_print(u_int regvalue, u_i
 	    0x0b, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t CLRSEQINTSTAT_parse_table[] = {
-	{ "CLRSEQ_SPLTINT",	0x01, 0x01 },
-	{ "CLRSEQ_PCIINT",	0x02, 0x02 },
-	{ "CLRSEQ_SCSIINT",	0x04, 0x04 },
-	{ "CLRSEQ_SEQINT",	0x08, 0x08 },
-	{ "CLRSEQ_SWTMRTO",	0x10, 0x10 }
-};
-
-int
-ahd_clrseqintstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRSEQINTSTAT_parse_table, 5, "CLRSEQINTSTAT",
-	    0x0c, regvalue, cur_col, wrap));
-}
-
 static ahd_reg_parse_entry_t SEQINTSTAT_parse_table[] = {
 	{ "SEQ_SPLTINT",	0x01, 0x01 },
 	{ "SEQ_PCIINT",		0x02, 0x02 },
@@ -202,6 +187,21 @@ ahd_seqintstat_print(u_int regvalue, u_i
 	    0x0c, regvalue, cur_col, wrap));
 }
 
+static ahd_reg_parse_entry_t CLRSEQINTSTAT_parse_table[] = {
+	{ "CLRSEQ_SPLTINT",	0x01, 0x01 },
+	{ "CLRSEQ_PCIINT",	0x02, 0x02 },
+	{ "CLRSEQ_SCSIINT",	0x04, 0x04 },
+	{ "CLRSEQ_SEQINT",	0x08, 0x08 },
+	{ "CLRSEQ_SWTMRTO",	0x10, 0x10 }
+};
+
+int
+ahd_clrseqintstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSEQINTSTAT_parse_table, 5, "CLRSEQINTSTAT",
+	    0x0c, regvalue, cur_col, wrap));
+}
+
 int
 ahd_swtimer_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
@@ -670,16 +670,16 @@ ahd_sxfrctl0_print(u_int regvalue, u_int
 }
 
 int
-ahd_businitid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_dlcount_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "BUSINITID",
+	return (ahd_print_register(NULL, 0, "DLCOUNT",
 	    0x3c, regvalue, cur_col, wrap));
 }
 
 int
-ahd_dlcount_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_businitid_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "DLCOUNT",
+	return (ahd_print_register(NULL, 0, "BUSINITID",
 	    0x3c, regvalue, cur_col, wrap));
 }
 
@@ -859,21 +859,6 @@ ahd_selid_print(u_int regvalue, u_int *c
 	    0x49, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t SBLKCTL_parse_table[] = {
-	{ "SELWIDE",		0x02, 0x02 },
-	{ "ENAB20",		0x04, 0x04 },
-	{ "ENAB40",		0x08, 0x08 },
-	{ "DIAGLEDON",		0x40, 0x40 },
-	{ "DIAGLEDEN",		0x80, 0x80 }
-};
-
-int
-ahd_sblkctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SBLKCTL_parse_table, 5, "SBLKCTL",
-	    0x4a, regvalue, cur_col, wrap));
-}
-
 static ahd_reg_parse_entry_t OPTIONMODE_parse_table[] = {
 	{ "AUTO_MSGOUT_DE",	0x02, 0x02 },
 	{ "ENDGFORMCHK",	0x04, 0x04 },
@@ -891,22 +876,19 @@ ahd_optionmode_print(u_int regvalue, u_i
 	    0x4a, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t SSTAT0_parse_table[] = {
-	{ "ARBDO",		0x01, 0x01 },
-	{ "SPIORDY",		0x02, 0x02 },
-	{ "OVERRUN",		0x04, 0x04 },
-	{ "IOERR",		0x08, 0x08 },
-	{ "SELINGO",		0x10, 0x10 },
-	{ "SELDI",		0x20, 0x20 },
-	{ "SELDO",		0x40, 0x40 },
-	{ "TARGET",		0x80, 0x80 }
+static ahd_reg_parse_entry_t SBLKCTL_parse_table[] = {
+	{ "SELWIDE",		0x02, 0x02 },
+	{ "ENAB20",		0x04, 0x04 },
+	{ "ENAB40",		0x08, 0x08 },
+	{ "DIAGLEDON",		0x40, 0x40 },
+	{ "DIAGLEDEN",		0x80, 0x80 }
 };
 
 int
-ahd_sstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_sblkctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(SSTAT0_parse_table, 8, "SSTAT0",
-	    0x4b, regvalue, cur_col, wrap));
+	return (ahd_print_register(SBLKCTL_parse_table, 5, "SBLKCTL",
+	    0x4a, regvalue, cur_col, wrap));
 }
 
 static ahd_reg_parse_entry_t CLRSINT0_parse_table[] = {
@@ -926,6 +908,24 @@ ahd_clrsint0_print(u_int regvalue, u_int
 	    0x4b, regvalue, cur_col, wrap));
 }
 
+static ahd_reg_parse_entry_t SSTAT0_parse_table[] = {
+	{ "ARBDO",		0x01, 0x01 },
+	{ "SPIORDY",		0x02, 0x02 },
+	{ "OVERRUN",		0x04, 0x04 },
+	{ "IOERR",		0x08, 0x08 },
+	{ "SELINGO",		0x10, 0x10 },
+	{ "SELDI",		0x20, 0x20 },
+	{ "SELDO",		0x40, 0x40 },
+	{ "TARGET",		0x80, 0x80 }
+};
+
+int
+ahd_sstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT0_parse_table, 8, "SSTAT0",
+	    0x4b, regvalue, cur_col, wrap));
+}
+
 static ahd_reg_parse_entry_t SIMODE0_parse_table[] = {
 	{ "ENARBDO",		0x01, 0x01 },
 	{ "ENSPIORDY",		0x02, 0x02 },
@@ -998,30 +998,30 @@ ahd_sstat2_print(u_int regvalue, u_int *
 	    0x4d, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t CLRSINT2_parse_table[] = {
-	{ "CLRDMADONE",		0x01, 0x01 },
-	{ "CLRSDONE",		0x02, 0x02 },
-	{ "CLRWIDE_RES",	0x04, 0x04 },
-	{ "CLRNONPACKREQ",	0x20, 0x20 }
+static ahd_reg_parse_entry_t SIMODE2_parse_table[] = {
+	{ "ENDMADONE",		0x01, 0x01 },
+	{ "ENSDONE",		0x02, 0x02 },
+	{ "ENWIDE_RES",		0x04, 0x04 }
 };
 
 int
-ahd_clrsint2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_simode2_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(CLRSINT2_parse_table, 4, "CLRSINT2",
+	return (ahd_print_register(SIMODE2_parse_table, 3, "SIMODE2",
 	    0x4d, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t SIMODE2_parse_table[] = {
-	{ "ENDMADONE",		0x01, 0x01 },
-	{ "ENSDONE",		0x02, 0x02 },
-	{ "ENWIDE_RES",		0x04, 0x04 }
+static ahd_reg_parse_entry_t CLRSINT2_parse_table[] = {
+	{ "CLRDMADONE",		0x01, 0x01 },
+	{ "CLRSDONE",		0x02, 0x02 },
+	{ "CLRWIDE_RES",	0x04, 0x04 },
+	{ "CLRNONPACKREQ",	0x20, 0x20 }
 };
 
 int
-ahd_simode2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_clrsint2_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(SIMODE2_parse_table, 3, "SIMODE2",
+	return (ahd_print_register(CLRSINT2_parse_table, 4, "CLRSINT2",
 	    0x4d, regvalue, cur_col, wrap));
 }
 
@@ -1220,21 +1220,6 @@ ahd_clrsint3_print(u_int regvalue, u_int
 	    0x53, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t LQOMODE0_parse_table[] = {
-	{ "ENLQOTCRC",		0x01, 0x01 },
-	{ "ENLQOATNPKT",	0x02, 0x02 },
-	{ "ENLQOATNLQ",		0x04, 0x04 },
-	{ "ENLQOSTOPT2",	0x08, 0x08 },
-	{ "ENLQOTARGSCBPERR",	0x10, 0x10 }
-};
-
-int
-ahd_lqomode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQOMODE0_parse_table, 5, "LQOMODE0",
-	    0x54, regvalue, cur_col, wrap));
-}
-
 static ahd_reg_parse_entry_t LQOSTAT0_parse_table[] = {
 	{ "LQOTCRC",		0x01, 0x01 },
 	{ "LQOATNPKT",		0x02, 0x02 },
@@ -1265,6 +1250,36 @@ ahd_clrlqoint0_print(u_int regvalue, u_i
 	    0x54, regvalue, cur_col, wrap));
 }
 
+static ahd_reg_parse_entry_t LQOMODE0_parse_table[] = {
+	{ "ENLQOTCRC",		0x01, 0x01 },
+	{ "ENLQOATNPKT",	0x02, 0x02 },
+	{ "ENLQOATNLQ",		0x04, 0x04 },
+	{ "ENLQOSTOPT2",	0x08, 0x08 },
+	{ "ENLQOTARGSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqomode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOMODE0_parse_table, 5, "LQOMODE0",
+	    0x54, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOMODE1_parse_table[] = {
+	{ "ENLQOPHACHGINPKT",	0x01, 0x01 },
+	{ "ENLQOBUSFREE",	0x02, 0x02 },
+	{ "ENLQOBADQAS",	0x04, 0x04 },
+	{ "ENLQOSTOPI2",	0x08, 0x08 },
+	{ "ENLQOINITSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqomode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOMODE1_parse_table, 5, "LQOMODE1",
+	    0x55, regvalue, cur_col, wrap));
+}
+
 static ahd_reg_parse_entry_t LQOSTAT1_parse_table[] = {
 	{ "LQOPHACHGINPKT",	0x01, 0x01 },
 	{ "LQOBUSFREE",		0x02, 0x02 },
@@ -1295,21 +1310,6 @@ ahd_clrlqoint1_print(u_int regvalue, u_i
 	    0x55, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t LQOMODE1_parse_table[] = {
-	{ "ENLQOPHACHGINPKT",	0x01, 0x01 },
-	{ "ENLQOBUSFREE",	0x02, 0x02 },
-	{ "ENLQOBADQAS",	0x04, 0x04 },
-	{ "ENLQOSTOPI2",	0x08, 0x08 },
-	{ "ENLQOINITSCBPERR",	0x10, 0x10 }
-};
-
-int
-ahd_lqomode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQOMODE1_parse_table, 5, "LQOMODE1",
-	    0x55, regvalue, cur_col, wrap));
-}
-
 static ahd_reg_parse_entry_t LQOSTAT2_parse_table[] = {
 	{ "LQOSTOP0",		0x01, 0x01 },
 	{ "LQOPHACHGOUTPKT",	0x02, 0x02 },
@@ -1594,6 +1594,13 @@ ahd_annexcol_print(u_int regvalue, u_int
 	    0x65, regvalue, cur_col, wrap));
 }
 
+int
+ahd_annexdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ANNEXDAT",
+	    0x66, regvalue, cur_col, wrap));
+}
+
 static ahd_reg_parse_entry_t SCSCHKN_parse_table[] = {
 	{ "LSTSGCLRDIS",	0x01, 0x01 },
 	{ "SHVALIDSTDIS",	0x02, 0x02 },
@@ -1612,13 +1619,6 @@ ahd_scschkn_print(u_int regvalue, u_int 
 }
 
 int
-ahd_annexdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ANNEXDAT",
-	    0x66, regvalue, cur_col, wrap));
-}
-
-int
 ahd_iownid_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "IOWNID",
@@ -1728,16 +1728,16 @@ ahd_pll400ctl1_print(u_int regvalue, u_i
 }
 
 int
-ahd_pll400cnt0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_unfairness_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "PLL400CNT0",
+	return (ahd_print_register(NULL, 0, "UNFAIRNESS",
 	    0x6e, regvalue, cur_col, wrap));
 }
 
 int
-ahd_unfairness_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_pll400cnt0_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "UNFAIRNESS",
+	return (ahd_print_register(NULL, 0, "PLL400CNT0",
 	    0x6e, regvalue, cur_col, wrap));
 }
 
@@ -1788,30 +1788,30 @@ ahd_hodmaen_print(u_int regvalue, u_int 
 }
 
 int
-ahd_sghaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_scbhaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "SGHADDR",
+	return (ahd_print_register(NULL, 0, "SCBHADDR",
 	    0x7c, regvalue, cur_col, wrap));
 }
 
 int
-ahd_scbhaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_sghaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "SCBHADDR",
+	return (ahd_print_register(NULL, 0, "SGHADDR",
 	    0x7c, regvalue, cur_col, wrap));
 }
 
 int
-ahd_sghcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_scbhcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "SGHCNT",
+	return (ahd_print_register(NULL, 0, "SCBHCNT",
 	    0x84, regvalue, cur_col, wrap));
 }
 
 int
-ahd_scbhcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_sghcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "SCBHCNT",
+	return (ahd_print_register(NULL, 0, "SGHCNT",
 	    0x84, regvalue, cur_col, wrap));
 }
 
@@ -1950,25 +1950,25 @@ ahd_nsenable_print(u_int regvalue, u_int
 	    0x91, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t DCHRXMSG1_parse_table[] = {
+static ahd_reg_parse_entry_t CMCRXMSG1_parse_table[] = {
 	{ "CBNUM",		0xff, 0xff }
 };
 
 int
-ahd_dchrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_cmcrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(DCHRXMSG1_parse_table, 1, "DCHRXMSG1",
+	return (ahd_print_register(CMCRXMSG1_parse_table, 1, "CMCRXMSG1",
 	    0x91, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t CMCRXMSG1_parse_table[] = {
+static ahd_reg_parse_entry_t DCHRXMSG1_parse_table[] = {
 	{ "CBNUM",		0xff, 0xff }
 };
 
 int
-ahd_cmcrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_dchrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(CMCRXMSG1_parse_table, 1, "CMCRXMSG1",
+	return (ahd_print_register(DCHRXMSG1_parse_table, 1, "DCHRXMSG1",
 	    0x91, regvalue, cur_col, wrap));
 }
 
@@ -1983,17 +1983,6 @@ ahd_dchrxmsg2_print(u_int regvalue, u_in
 	    0x92, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t OVLYRXMSG2_parse_table[] = {
-	{ "MINDEX",		0xff, 0xff }
-};
-
-int
-ahd_ovlyrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYRXMSG2_parse_table, 1, "OVLYRXMSG2",
-	    0x92, regvalue, cur_col, wrap));
-}
-
 static ahd_reg_parse_entry_t CMCRXMSG2_parse_table[] = {
 	{ "MINDEX",		0xff, 0xff }
 };
@@ -2012,6 +2001,17 @@ ahd_ost_print(u_int regvalue, u_int *cur
 	    0x92, regvalue, cur_col, wrap));
 }
 
+static ahd_reg_parse_entry_t OVLYRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_ovlyrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG2_parse_table, 1, "OVLYRXMSG2",
+	    0x92, regvalue, cur_col, wrap));
+}
+
 static ahd_reg_parse_entry_t DCHRXMSG3_parse_table[] = {
 	{ "MCLASS",		0x0f, 0x0f }
 };
@@ -2023,6 +2023,17 @@ ahd_dchrxmsg3_print(u_int regvalue, u_in
 	    0x93, regvalue, cur_col, wrap));
 }
 
+static ahd_reg_parse_entry_t OVLYRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_ovlyrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG3_parse_table, 1, "OVLYRXMSG3",
+	    0x93, regvalue, cur_col, wrap));
+}
+
 static ahd_reg_parse_entry_t CMCRXMSG3_parse_table[] = {
 	{ "MCLASS",		0x0f, 0x0f }
 };
@@ -2051,17 +2062,6 @@ ahd_pcixctl_print(u_int regvalue, u_int 
 	    0x93, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t OVLYRXMSG3_parse_table[] = {
-	{ "MCLASS",		0x0f, 0x0f }
-};
-
-int
-ahd_ovlyrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYRXMSG3_parse_table, 1, "OVLYRXMSG3",
-	    0x93, regvalue, cur_col, wrap));
-}
-
 int
 ahd_ovlyseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
@@ -2070,16 +2070,16 @@ ahd_ovlyseqbcnt_print(u_int regvalue, u_
 }
 
 int
-ahd_cmcseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_dchseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "CMCSEQBCNT",
+	return (ahd_print_register(NULL, 0, "DCHSEQBCNT",
 	    0x94, regvalue, cur_col, wrap));
 }
 
 int
-ahd_dchseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_cmcseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "DCHSEQBCNT",
+	return (ahd_print_register(NULL, 0, "CMCSEQBCNT",
 	    0x94, regvalue, cur_col, wrap));
 }
 
@@ -2101,7 +2101,7 @@ ahd_cmcspltstat0_print(u_int regvalue, u
 	    0x96, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t OVLYSPLTSTAT0_parse_table[] = {
+static ahd_reg_parse_entry_t DCHSPLTSTAT0_parse_table[] = {
 	{ "RXSPLTRSP",		0x01, 0x01 },
 	{ "RXSCEMSG",		0x02, 0x02 },
 	{ "RXOVRUN",		0x04, 0x04 },
@@ -2113,13 +2113,13 @@ static ahd_reg_parse_entry_t OVLYSPLTSTA
 };
 
 int
-ahd_ovlyspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_dchspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(OVLYSPLTSTAT0_parse_table, 8, "OVLYSPLTSTAT0",
+	return (ahd_print_register(DCHSPLTSTAT0_parse_table, 8, "DCHSPLTSTAT0",
 	    0x96, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t DCHSPLTSTAT0_parse_table[] = {
+static ahd_reg_parse_entry_t OVLYSPLTSTAT0_parse_table[] = {
 	{ "RXSPLTRSP",		0x01, 0x01 },
 	{ "RXSCEMSG",		0x02, 0x02 },
 	{ "RXOVRUN",		0x04, 0x04 },
@@ -2131,42 +2131,42 @@ static ahd_reg_parse_entry_t DCHSPLTSTAT
 };
 
 int
-ahd_dchspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_ovlyspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(DCHSPLTSTAT0_parse_table, 8, "DCHSPLTSTAT0",
+	return (ahd_print_register(OVLYSPLTSTAT0_parse_table, 8, "OVLYSPLTSTAT0",
 	    0x96, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t DCHSPLTSTAT1_parse_table[] = {
+static ahd_reg_parse_entry_t CMCSPLTSTAT1_parse_table[] = {
 	{ "RXDATABUCKET",	0x01, 0x01 }
 };
 
 int
-ahd_dchspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_cmcspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(DCHSPLTSTAT1_parse_table, 1, "DCHSPLTSTAT1",
+	return (ahd_print_register(CMCSPLTSTAT1_parse_table, 1, "CMCSPLTSTAT1",
 	    0x97, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t CMCSPLTSTAT1_parse_table[] = {
+static ahd_reg_parse_entry_t OVLYSPLTSTAT1_parse_table[] = {
 	{ "RXDATABUCKET",	0x01, 0x01 }
 };
 
 int
-ahd_cmcspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_ovlyspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(CMCSPLTSTAT1_parse_table, 1, "CMCSPLTSTAT1",
+	return (ahd_print_register(OVLYSPLTSTAT1_parse_table, 1, "OVLYSPLTSTAT1",
 	    0x97, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t OVLYSPLTSTAT1_parse_table[] = {
+static ahd_reg_parse_entry_t DCHSPLTSTAT1_parse_table[] = {
 	{ "RXDATABUCKET",	0x01, 0x01 }
 };
 
 int
-ahd_ovlyspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_dchspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(OVLYSPLTSTAT1_parse_table, 1, "OVLYSPLTSTAT1",
+	return (ahd_print_register(DCHSPLTSTAT1_parse_table, 1, "DCHSPLTSTAT1",
 	    0x97, regvalue, cur_col, wrap));
 }
 
@@ -2320,26 +2320,26 @@ ahd_sgspltstat0_print(u_int regvalue, u_
 	    0x9e, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t SFUNCT_parse_table[] = {
-	{ "TEST_NUM",		0x0f, 0x0f },
-	{ "TEST_GROUP",		0xf0, 0xf0 }
+static ahd_reg_parse_entry_t SGSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
 };
 
 int
-ahd_sfunct_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_sgspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(SFUNCT_parse_table, 2, "SFUNCT",
+	return (ahd_print_register(SGSPLTSTAT1_parse_table, 1, "SGSPLTSTAT1",
 	    0x9f, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t SGSPLTSTAT1_parse_table[] = {
-	{ "RXDATABUCKET",	0x01, 0x01 }
+static ahd_reg_parse_entry_t SFUNCT_parse_table[] = {
+	{ "TEST_NUM",		0x0f, 0x0f },
+	{ "TEST_GROUP",		0xf0, 0xf0 }
 };
 
 int
-ahd_sgspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_sfunct_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(SGSPLTSTAT1_parse_table, 1, "SGSPLTSTAT1",
+	return (ahd_print_register(SFUNCT_parse_table, 2, "SFUNCT",
 	    0x9f, regvalue, cur_col, wrap));
 }
 
@@ -2537,16 +2537,16 @@ ahd_ccsgaddr_print(u_int regvalue, u_int
 }
 
 int
-ahd_ccscbaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_ccscbadr_bk_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "CCSCBADDR",
+	return (ahd_print_register(NULL, 0, "CCSCBADR_BK",
 	    0xac, regvalue, cur_col, wrap));
 }
 
 int
-ahd_ccscbadr_bk_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_ccscbaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "CCSCBADR_BK",
+	return (ahd_print_register(NULL, 0, "CCSCBADDR",
 	    0xac, regvalue, cur_col, wrap));
 }
 
@@ -2566,22 +2566,6 @@ ahd_cmc_rambist_print(u_int regvalue, u_
 	    0xad, regvalue, cur_col, wrap));
 }
 
-static ahd_reg_parse_entry_t CCSGCTL_parse_table[] = {
-	{ "CCSGRESET",		0x01, 0x01 },
-	{ "SG_FETCH_REQ",	0x02, 0x02 },
-	{ "CCSGENACK",		0x08, 0x08 },
-	{ "SG_CACHE_AVAIL",	0x10, 0x10 },
-	{ "CCSGDONE",		0x80, 0x80 },
-	{ "CCSGEN",		0x0c, 0x0c }
-};
-
-int
-ahd_ccsgctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CCSGCTL_parse_table, 6, "CCSGCTL",
-	    0xad, regvalue, cur_col, wrap));
-}
-
 static ahd_reg_parse_entry_t CCSCBCTL_parse_table[] = {
 	{ "CCSCBRESET",		0x01, 0x01 },
 	{ "CCSCBDIR",		0x04, 0x04 },
@@ -2598,6 +2582,22 @@ ahd_ccscbctl_print(u_int regvalue, u_int
 	    0xad, regvalue, cur_col, wrap));
 }
 
+static ahd_reg_parse_entry_t CCSGCTL_parse_table[] = {
+	{ "CCSGRESET",		0x01, 0x01 },
+	{ "SG_FETCH_REQ",	0x02, 0x02 },
+	{ "CCSGENACK",		0x08, 0x08 },
+	{ "SG_CACHE_AVAIL",	0x10, 0x10 },
+	{ "CCSGDONE",		0x80, 0x80 },
+	{ "CCSGEN",		0x0c, 0x0c }
+};
+
+int
+ahd_ccsgctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CCSGCTL_parse_table, 6, "CCSGCTL",
+	    0xad, regvalue, cur_col, wrap));
+}
+
 int
 ahd_ccsgram_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
@@ -2841,30 +2841,30 @@ ahd_wrtbiascalc_print(u_int regvalue, u_
 }
 
 int
-ahd_dfptrs_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_rcvrbiascalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "DFPTRS",
+	return (ahd_print_register(NULL, 0, "RCVRBIASCALC",
 	    0xc8, regvalue, cur_col, wrap));
 }
 
 int
-ahd_rcvrbiascalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_dfptrs_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "RCVRBIASCALC",
+	return (ahd_print_register(NULL, 0, "DFPTRS",
 	    0xc8, regvalue, cur_col, wrap));
 }
 
 int
-ahd_dfbkptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_skewcalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "DFBKPTR",
+	return (ahd_print_register(NULL, 0, "SKEWCALC",
 	    0xc9, regvalue, cur_col, wrap));
 }
 
 int
-ahd_skewcalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_dfbkptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "SKEWCALC",
+	return (ahd_print_register(NULL, 0, "DFBKPTR",
 	    0xc9, regvalue, cur_col, wrap));
 }
 
@@ -3001,6 +3001,13 @@ ahd_dindex_print(u_int regvalue, u_int *
 	    0xe4, regvalue, cur_col, wrap));
 }
 
+int
+ahd_brkaddr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BRKADDR0",
+	    0xe6, regvalue, cur_col, wrap));
+}
+
 static ahd_reg_parse_entry_t BRKADDR1_parse_table[] = {
 	{ "BRKDIS",		0x80, 0x80 }
 };
@@ -3013,13 +3020,6 @@ ahd_brkaddr1_print(u_int regvalue, u_int
 }
 
 int
-ahd_brkaddr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "BRKADDR0",
-	    0xe6, regvalue, cur_col, wrap));
-}
-
-int
 ahd_allones_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "ALLONES",
@@ -3069,30 +3069,30 @@ ahd_stack_print(u_int regvalue, u_int *c
 }
 
 int
-ahd_curaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_intvec1_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "CURADDR",
+	return (ahd_print_register(NULL, 0, "INTVEC1_ADDR",
 	    0xf4, regvalue, cur_col, wrap));
 }
 
 int
-ahd_intvec1_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_curaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "INTVEC1_ADDR",
+	return (ahd_print_register(NULL, 0, "CURADDR",
 	    0xf4, regvalue, cur_col, wrap));
 }
 
 int
-ahd_intvec2_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_lastaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "INTVEC2_ADDR",
+	return (ahd_print_register(NULL, 0, "LASTADDR",
 	    0xf6, regvalue, cur_col, wrap));
 }
 
 int
-ahd_lastaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_intvec2_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "LASTADDR",
+	return (ahd_print_register(NULL, 0, "INTVEC2_ADDR",
 	    0xf6, regvalue, cur_col, wrap));
 }
 
@@ -3174,24 +3174,45 @@ ahd_complete_dma_scb_head_print(u_int re
 }
 
 int
+ahd_complete_dma_scb_tail_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "COMPLETE_DMA_SCB_TAIL",
+	    0x12e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_complete_on_qfreeze_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "COMPLETE_ON_QFREEZE_HEAD",
+	    0x130, regvalue, cur_col, wrap));
+}
+
+int
 ahd_qfreeze_count_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "QFREEZE_COUNT",
-	    0x12e, regvalue, cur_col, wrap));
+	    0x132, regvalue, cur_col, wrap));
+}
+
+int
+ahd_kernel_qfreeze_count_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "KERNEL_QFREEZE_COUNT",
+	    0x134, regvalue, cur_col, wrap));
 }
 
 int
 ahd_saved_mode_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "SAVED_MODE",
-	    0x130, regvalue, cur_col, wrap));
+	    0x136, regvalue, cur_col, wrap));
 }
 
 int
 ahd_msg_out_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "MSG_OUT",
-	    0x131, regvalue, cur_col, wrap));
+	    0x137, regvalue, cur_col, wrap));
 }
 
 static ahd_reg_parse_entry_t DMAPARAMS_parse_table[] = {
@@ -3211,7 +3232,7 @@ int
 ahd_dmaparams_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(DMAPARAMS_parse_table, 10, "DMAPARAMS",
-	    0x132, regvalue, cur_col, wrap));
+	    0x138, regvalue, cur_col, wrap));
 }
 
 static ahd_reg_parse_entry_t SEQ_FLAGS_parse_table[] = {
@@ -3230,21 +3251,21 @@ int
 ahd_seq_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(SEQ_FLAGS_parse_table, 9, "SEQ_FLAGS",
-	    0x133, regvalue, cur_col, wrap));
+	    0x139, regvalue, cur_col, wrap));
 }
 
 int
 ahd_saved_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "SAVED_SCSIID",
-	    0x134, regvalue, cur_col, wrap));
+	    0x13a, regvalue, cur_col, wrap));
 }
 
 int
 ahd_saved_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "SAVED_LUN",
-	    0x135, regvalue, cur_col, wrap));
+	    0x13b, regvalue, cur_col, wrap));
 }
 
 static ahd_reg_parse_entry_t LASTPHASE_parse_table[] = {
@@ -3267,42 +3288,42 @@ int
 ahd_lastphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(LASTPHASE_parse_table, 13, "LASTPHASE",
-	    0x136, regvalue, cur_col, wrap));
+	    0x13c, regvalue, cur_col, wrap));
 }
 
 int
 ahd_qoutfifo_entry_valid_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG",
-	    0x137, regvalue, cur_col, wrap));
+	    0x13d, regvalue, cur_col, wrap));
 }
 
 int
-ahd_shared_data_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_kernel_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "SHARED_DATA_ADDR",
-	    0x138, regvalue, cur_col, wrap));
+	return (ahd_print_register(NULL, 0, "KERNEL_TQINPOS",
+	    0x13e, regvalue, cur_col, wrap));
 }
 
 int
-ahd_qoutfifo_next_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR",
-	    0x13c, regvalue, cur_col, wrap));
+	return (ahd_print_register(NULL, 0, "TQINPOS",
+	    0x13f, regvalue, cur_col, wrap));
 }
 
 int
-ahd_kernel_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_shared_data_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "KERNEL_TQINPOS",
+	return (ahd_print_register(NULL, 0, "SHARED_DATA_ADDR",
 	    0x140, regvalue, cur_col, wrap));
 }
 
 int
-ahd_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+ahd_qoutfifo_next_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
-	return (ahd_print_register(NULL, 0, "TQINPOS",
-	    0x141, regvalue, cur_col, wrap));
+	return (ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR",
+	    0x144, regvalue, cur_col, wrap));
 }
 
 static ahd_reg_parse_entry_t ARG_1_parse_table[] = {
@@ -3320,21 +3341,21 @@ int
 ahd_arg_1_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(ARG_1_parse_table, 8, "ARG_1",
-	    0x142, regvalue, cur_col, wrap));
+	    0x148, regvalue, cur_col, wrap));
 }
 
 int
 ahd_arg_2_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "ARG_2",
-	    0x143, regvalue, cur_col, wrap));
+	    0x149, regvalue, cur_col, wrap));
 }
 
 int
 ahd_last_msg_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "LAST_MSG",
-	    0x144, regvalue, cur_col, wrap));
+	    0x14a, regvalue, cur_col, wrap));
 }
 
 static ahd_reg_parse_entry_t SCSISEQ_TEMPLATE_parse_table[] = {
@@ -3350,14 +3371,14 @@ int
 ahd_scsiseq_template_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(SCSISEQ_TEMPLATE_parse_table, 6, "SCSISEQ_TEMPLATE",
-	    0x145, regvalue, cur_col, wrap));
+	    0x14b, regvalue, cur_col, wrap));
 }
 
 int
 ahd_initiator_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "INITIATOR_TAG",
-	    0x146, regvalue, cur_col, wrap));
+	    0x14c, regvalue, cur_col, wrap));
 }
 
 static ahd_reg_parse_entry_t SEQ_FLAGS2_parse_table[] = {
@@ -3369,63 +3390,63 @@ int
 ahd_seq_flags2_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(SEQ_FLAGS2_parse_table, 2, "SEQ_FLAGS2",
-	    0x147, regvalue, cur_col, wrap));
+	    0x14d, regvalue, cur_col, wrap));
 }
 
 int
 ahd_allocfifo_scbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR",
-	    0x148, regvalue, cur_col, wrap));
+	    0x14e, regvalue, cur_col, wrap));
 }
 
 int
 ahd_int_coalescing_timer_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "INT_COALESCING_TIMER",
-	    0x14a, regvalue, cur_col, wrap));
+	    0x150, regvalue, cur_col, wrap));
 }
 
 int
 ahd_int_coalescing_maxcmds_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "INT_COALESCING_MAXCMDS",
-	    0x14c, regvalue, cur_col, wrap));
+	    0x152, regvalue, cur_col, wrap));
 }
 
 int
 ahd_int_coalescing_mincmds_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "INT_COALESCING_MINCMDS",
-	    0x14d, regvalue, cur_col, wrap));
+	    0x153, regvalue, cur_col, wrap));
 }
 
 int
 ahd_cmds_pending_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "CMDS_PENDING",
-	    0x14e, regvalue, cur_col, wrap));
+	    0x154, regvalue, cur_col, wrap));
 }
 
 int
 ahd_int_coalescing_cmdcount_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "INT_COALESCING_CMDCOUNT",
-	    0x150, regvalue, cur_col, wrap));
+	    0x156, regvalue, cur_col, wrap));
 }
 
 int
 ahd_local_hs_mailbox_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "LOCAL_HS_MAILBOX",
-	    0x151, regvalue, cur_col, wrap));
+	    0x157, regvalue, cur_col, wrap));
 }
 
 int
 ahd_cmdsize_table_print(u_int regvalue, u_int *cur_col, u_int wrap)
 {
 	return (ahd_print_register(NULL, 0, "CMDSIZE_TABLE",
-	    0x152, regvalue, cur_col, wrap));
+	    0x158, regvalue, cur_col, wrap));
 }
 
 int
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_seq.h_shipped linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_seq.h_shipped
--- linux-2.6.5/drivers/scsi/aic7xxx/aic79xx_seq.h_shipped	2004-04-04 05:38:22.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic79xx_seq.h_shipped	2004-05-13 16:42:17.000000000 +0200
@@ -2,215 +2,226 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#94 $
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#70 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#118 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#75 $
  */
 static uint8_t seqprog[] = {
 	0xff, 0x02, 0x06, 0x78,
-	0x00, 0xea, 0x50, 0x59,
+	0x00, 0xea, 0x60, 0x59,
 	0x01, 0xea, 0x04, 0x30,
 	0xff, 0x04, 0x0c, 0x78,
-	0x19, 0xea, 0x50, 0x59,
+	0x19, 0xea, 0x60, 0x59,
 	0x19, 0xea, 0x04, 0x00,
-	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x5a, 0x59,
 	0x33, 0xea, 0x00, 0x00,
-	0x60, 0x3a, 0x1a, 0x68,
-	0x04, 0x47, 0x1b, 0x68,
-	0xff, 0x21, 0x1b, 0x70,
-	0x40, 0x4b, 0x92, 0x69,
-	0x00, 0xe2, 0x54, 0x59,
-	0x40, 0x4b, 0x92, 0x69,
-	0x20, 0x4b, 0x82, 0x69,
-	0xfc, 0x42, 0x24, 0x78,
-	0x10, 0x40, 0x24, 0x78,
-	0x00, 0xe2, 0xc4, 0x5d,
-	0x20, 0x4d, 0x28, 0x78,
-	0x00, 0xe2, 0xc4, 0x5d,
+	0x60, 0x3a, 0x3a, 0x68,
+	0x04, 0x4d, 0x35, 0x78,
+	0x01, 0x34, 0xc1, 0x31,
+	0x00, 0x32, 0x21, 0x60,
+	0x01, 0x35, 0xc1, 0x31,
+	0x00, 0x33, 0x21, 0x60,
+	0xfb, 0x4d, 0x9b, 0x0a,
+	0x00, 0xe2, 0x34, 0x40,
+	0x50, 0x4b, 0x3a, 0x68,
+	0xff, 0x31, 0x3b, 0x70,
+	0x02, 0x30, 0x51, 0x31,
+	0xff, 0x8d, 0x2d, 0x70,
+	0x02, 0x8c, 0x51, 0x31,
+	0xff, 0x8d, 0x29, 0x60,
+	0x02, 0x28, 0x19, 0x33,
+	0x02, 0x30, 0x51, 0x32,
+	0xff, 0xea, 0x62, 0x02,
+	0x00, 0xe2, 0x3a, 0x40,
+	0xff, 0x21, 0x3b, 0x70,
+	0x40, 0x4b, 0xa6, 0x69,
+	0x00, 0xe2, 0x64, 0x59,
+	0x40, 0x4b, 0xa6, 0x69,
+	0x20, 0x4b, 0x92, 0x69,
+	0xfc, 0x42, 0x44, 0x78,
+	0x10, 0x40, 0x44, 0x78,
+	0x00, 0xe2, 0xf8, 0x5d,
+	0x20, 0x4d, 0x48, 0x78,
+	0x00, 0xe2, 0xf8, 0x5d,
 	0x30, 0x3f, 0xc0, 0x09,
-	0x30, 0xe0, 0x30, 0x60,
+	0x30, 0xe0, 0x50, 0x60,
 	0x7f, 0x4a, 0x94, 0x08,
-	0x00, 0xe2, 0x32, 0x40,
+	0x00, 0xe2, 0x52, 0x40,
 	0xc0, 0x4a, 0x94, 0x00,
-	0x00, 0xe2, 0x3e, 0x58,
-	0x00, 0xe2, 0x56, 0x58,
-	0x00, 0xe2, 0x66, 0x58,
+	0x00, 0xe2, 0x5e, 0x58,
+	0x00, 0xe2, 0x76, 0x58,
+	0x00, 0xe2, 0x86, 0x58,
 	0x00, 0xe2, 0x06, 0x40,
-	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x5a, 0x59,
 	0x33, 0xea, 0x00, 0x00,
-	0x01, 0x52, 0x64, 0x78,
+	0x01, 0x52, 0x84, 0x78,
 	0x02, 0x58, 0x50, 0x31,
 	0xff, 0xea, 0x10, 0x0b,
-	0xff, 0x97, 0x4f, 0x78,
-	0x50, 0x4b, 0x4a, 0x68,
+	0xff, 0x97, 0x6f, 0x78,
+	0x50, 0x4b, 0x6a, 0x68,
 	0xbf, 0x3a, 0x74, 0x08,
-	0x14, 0xea, 0x50, 0x59,
+	0x14, 0xea, 0x60, 0x59,
 	0x14, 0xea, 0x04, 0x00,
 	0x08, 0x92, 0x25, 0x03,
-	0xff, 0x90, 0x3f, 0x68,
-	0x00, 0xe2, 0x56, 0x5b,
-	0x00, 0xe2, 0x3e, 0x40,
-	0x00, 0xea, 0x44, 0x59,
+	0xff, 0x90, 0x5f, 0x68,
+	0x00, 0xe2, 0x72, 0x5b,
+	0x00, 0xe2, 0x5e, 0x40,
+	0x00, 0xea, 0x5a, 0x59,
 	0x01, 0xea, 0x00, 0x30,
-	0x80, 0xf9, 0x5e, 0x68,
-	0x00, 0xe2, 0x42, 0x59,
-	0x11, 0xea, 0x44, 0x59,
+	0x80, 0xf9, 0x7e, 0x68,
+	0x00, 0xe2, 0x58, 0x59,
+	0x11, 0xea, 0x5a, 0x59,
 	0x11, 0xea, 0x00, 0x00,
-	0x80, 0xf9, 0x42, 0x79,
+	0x80, 0xf9, 0x58, 0x79,
 	0xff, 0xea, 0xd4, 0x0d,
-	0x22, 0xea, 0x44, 0x59,
+	0x22, 0xea, 0x5a, 0x59,
 	0x22, 0xea, 0x00, 0x00,
-	0x10, 0x16, 0x70, 0x78,
-	0x01, 0x0b, 0xa2, 0x32,
+	0x10, 0x16, 0x90, 0x78,
 	0x10, 0x16, 0x2c, 0x00,
-	0x18, 0xad, 0x00, 0x79,
-	0x04, 0xad, 0xca, 0x68,
-	0x80, 0xad, 0x64, 0x78,
-	0x10, 0xad, 0x98, 0x78,
-	0xff, 0x88, 0x83, 0x68,
+	0x01, 0x0b, 0xae, 0x32,
+	0x18, 0xad, 0x12, 0x79,
+	0x04, 0xad, 0xdc, 0x68,
+	0x80, 0xad, 0x84, 0x78,
+	0x10, 0xad, 0xaa, 0x78,
 	0xe7, 0xad, 0x5a, 0x09,
 	0x02, 0x8c, 0x59, 0x32,
+	0xff, 0x8d, 0xa1, 0x60,
+	0xff, 0xea, 0x5e, 0x02,
+	0xff, 0x88, 0xa7, 0x78,
+	0x02, 0x30, 0x19, 0x33,
+	0x02, 0xa8, 0x60, 0x36,
 	0x02, 0x28, 0x19, 0x33,
 	0x02, 0xa8, 0x50, 0x36,
-	0x33, 0xea, 0x44, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x40, 0x3a, 0x64, 0x68,
-	0x50, 0x4b, 0x64, 0x68,
-	0x22, 0xea, 0x44, 0x59,
-	0x22, 0xea, 0x00, 0x00,
-	0xe7, 0xad, 0x5a, 0x09,
-	0x02, 0x8c, 0x59, 0x32,
-	0x1a, 0xea, 0x50, 0x59,
-	0x1a, 0xea, 0x04, 0x00,
-	0xff, 0xea, 0xd4, 0x0d,
 	0xe7, 0xad, 0x5a, 0x09,
-	0x00, 0xe2, 0xa6, 0x58,
+	0x00, 0xe2, 0xb8, 0x58,
 	0xff, 0xea, 0x56, 0x02,
-	0x04, 0x7c, 0x78, 0x32,
-	0x20, 0x16, 0x64, 0x78,
-	0x04, 0x38, 0x79, 0x32,
-	0x80, 0x37, 0x6f, 0x16,
-	0xff, 0x2d, 0xb5, 0x60,
-	0xff, 0x29, 0xb5, 0x60,
-	0x40, 0x51, 0xc5, 0x78,
-	0xff, 0x4f, 0xb5, 0x68,
-	0xff, 0x4d, 0xc1, 0x19,
-	0x00, 0x4e, 0xd5, 0x19,
-	0x00, 0xe2, 0xc4, 0x50,
-	0x01, 0x4c, 0xc1, 0x31,
-	0x00, 0x50, 0xd5, 0x19,
-	0x00, 0xe2, 0xc4, 0x48,
-	0x80, 0x18, 0x64, 0x78,
-	0x02, 0x4a, 0x1d, 0x30,
+	0x04, 0x7c, 0x88, 0x32,
+	0x20, 0x16, 0x84, 0x78,
+	0x04, 0x40, 0x89, 0x32,
+	0x80, 0x3d, 0x7b, 0x16,
+	0xff, 0x2d, 0xc7, 0x60,
+	0xff, 0x29, 0xc7, 0x60,
+	0x40, 0x57, 0xd7, 0x78,
+	0xff, 0x55, 0xc7, 0x68,
+	0xff, 0x53, 0xc1, 0x19,
+	0x00, 0x54, 0xd5, 0x19,
+	0x00, 0xe2, 0xd6, 0x50,
+	0x01, 0x52, 0xc1, 0x31,
+	0x00, 0x56, 0xd5, 0x19,
+	0x00, 0xe2, 0xd6, 0x48,
+	0x80, 0x18, 0x84, 0x78,
+	0x02, 0x50, 0x1d, 0x30,
 	0x10, 0xea, 0x18, 0x00,
 	0x60, 0x18, 0x30, 0x00,
 	0x7f, 0x18, 0x30, 0x0c,
 	0x02, 0xea, 0x02, 0x00,
-	0xff, 0xea, 0xa0, 0x0a,
+	0xff, 0xea, 0xac, 0x0a,
 	0x80, 0x18, 0x30, 0x04,
-	0x40, 0xad, 0x64, 0x78,
+	0x40, 0xad, 0x84, 0x78,
 	0xe7, 0xad, 0x5a, 0x09,
 	0x02, 0xa8, 0x40, 0x31,
 	0xff, 0xea, 0xc0, 0x09,
-	0x01, 0x4e, 0x9d, 0x1a,
-	0x00, 0x4f, 0x9f, 0x22,
+	0x01, 0x54, 0xa9, 0x1a,
+	0x00, 0x55, 0xab, 0x22,
 	0x01, 0x94, 0x6d, 0x33,
-	0x01, 0xea, 0x20, 0x33,
+	0xff, 0xea, 0x20, 0x0b,
 	0x04, 0xac, 0x49, 0x32,
 	0xff, 0xea, 0x5a, 0x03,
 	0xff, 0xea, 0x5e, 0x03,
 	0x01, 0x10, 0xd4, 0x31,
-	0x10, 0x92, 0xf5, 0x68,
+	0x10, 0x92, 0x07, 0x69,
 	0x3d, 0x93, 0xc5, 0x29,
 	0xfe, 0xe2, 0xc4, 0x09,
 	0x01, 0xea, 0xc6, 0x01,
 	0x02, 0xe2, 0xc8, 0x31,
 	0x02, 0xec, 0x50, 0x31,
 	0x02, 0xa0, 0xda, 0x31,
-	0xff, 0xa9, 0xf4, 0x70,
+	0xff, 0xa9, 0x06, 0x71,
 	0x02, 0xa0, 0x58, 0x37,
-	0xff, 0x21, 0xfd, 0x70,
+	0xff, 0x21, 0x0f, 0x71,
 	0x02, 0x22, 0x51, 0x31,
 	0x02, 0xa0, 0x5c, 0x33,
 	0x02, 0xa0, 0x44, 0x36,
 	0x02, 0xa0, 0x40, 0x32,
 	0x02, 0xa0, 0x44, 0x36,
-	0x04, 0x47, 0x05, 0x69,
-	0x40, 0x16, 0x30, 0x69,
-	0xff, 0x2d, 0x35, 0x61,
-	0xff, 0x29, 0x65, 0x70,
-	0x01, 0x37, 0xc1, 0x31,
+	0x04, 0x4d, 0x17, 0x69,
+	0x40, 0x16, 0x44, 0x69,
+	0xff, 0x2d, 0x49, 0x61,
+	0xff, 0x29, 0x85, 0x70,
 	0x02, 0x28, 0x55, 0x32,
 	0x01, 0xea, 0x5a, 0x01,
-	0x04, 0x3c, 0xf9, 0x30,
+	0x04, 0x44, 0xf9, 0x30,
 	0x02, 0x28, 0x51, 0x31,
-	0x01, 0xa8, 0x60, 0x31,
-	0x00, 0xa9, 0x60, 0x01,
+	0x02, 0xa8, 0x60, 0x31,
+	0x01, 0xa4, 0x61, 0x31,
+	0x04, 0xea, 0x60, 0x31,
+	0x01, 0x3d, 0x61, 0x31,
 	0x01, 0x14, 0xd4, 0x31,
-	0x01, 0x50, 0xa1, 0x1a,
-	0xff, 0x4e, 0x9d, 0x1a,
-	0xff, 0x4f, 0x9f, 0x22,
-	0xff, 0x8d, 0x29, 0x71,
-	0x80, 0xac, 0x28, 0x71,
-	0x20, 0x16, 0x28, 0x69,
+	0x01, 0x56, 0xad, 0x1a,
+	0xff, 0x54, 0xa9, 0x1a,
+	0xff, 0x55, 0xab, 0x22,
+	0xff, 0x8d, 0x3d, 0x71,
+	0x80, 0xac, 0x3c, 0x71,
+	0x20, 0x16, 0x3c, 0x69,
 	0x02, 0x8c, 0x51, 0x31,
-	0x00, 0xe2, 0x12, 0x41,
+	0x00, 0xe2, 0x22, 0x41,
 	0x01, 0xac, 0x08, 0x31,
 	0x09, 0xea, 0x5a, 0x01,
 	0x02, 0x8c, 0x51, 0x32,
 	0xff, 0xea, 0x1a, 0x07,
 	0x04, 0x24, 0xf9, 0x30,
-	0x1d, 0xea, 0x3a, 0x41,
+	0x1d, 0xea, 0x4e, 0x41,
 	0x02, 0x2c, 0x51, 0x31,
 	0x04, 0xa8, 0xf9, 0x30,
-	0x19, 0xea, 0x3a, 0x41,
+	0x19, 0xea, 0x4e, 0x41,
 	0x06, 0xea, 0x08, 0x81,
 	0x01, 0xe2, 0x5a, 0x35,
-	0x02, 0xf2, 0xf0, 0x35,
+	0x02, 0xf2, 0xf0, 0x31,
+	0xff, 0xea, 0xd4, 0x0d,
 	0x02, 0xf2, 0xf0, 0x31,
 	0x02, 0xf8, 0xe4, 0x35,
 	0x80, 0xea, 0xb2, 0x01,
 	0x01, 0xe2, 0x00, 0x30,
 	0xff, 0xea, 0xb2, 0x0d,
-	0x80, 0xea, 0xb2, 0x01,
-	0x11, 0x00, 0x00, 0x10,
-	0xff, 0xea, 0xb2, 0x0d,
 	0x01, 0xe2, 0x04, 0x30,
 	0x01, 0xea, 0x04, 0x34,
 	0x02, 0x20, 0xbd, 0x30,
 	0x02, 0x20, 0xb9, 0x30,
 	0x02, 0x20, 0x51, 0x31,
 	0x4c, 0x93, 0xd7, 0x28,
-	0x10, 0x92, 0x63, 0x79,
+	0x10, 0x92, 0x73, 0x79,
 	0x01, 0x6b, 0xc0, 0x30,
 	0x02, 0x64, 0xc8, 0x00,
 	0x40, 0x3a, 0x74, 0x04,
-	0x00, 0xe2, 0x56, 0x58,
-	0x33, 0xea, 0x44, 0x59,
+	0x00, 0xe2, 0x76, 0x58,
+	0x33, 0xea, 0x5a, 0x59,
 	0x33, 0xea, 0x00, 0x00,
 	0x30, 0x3f, 0xc0, 0x09,
-	0x30, 0xe0, 0x64, 0x61,
-	0x20, 0x3f, 0x7a, 0x69,
-	0x10, 0x3f, 0x64, 0x79,
+	0x30, 0xe0, 0x74, 0x61,
+	0x20, 0x3f, 0x8a, 0x69,
+	0x10, 0x3f, 0x74, 0x79,
 	0x02, 0xea, 0x7e, 0x00,
-	0x00, 0xea, 0x44, 0x59,
+	0x00, 0xea, 0x5a, 0x59,
 	0x01, 0xea, 0x00, 0x30,
-	0x02, 0x48, 0x51, 0x35,
+	0x02, 0x4e, 0x51, 0x35,
 	0x01, 0xea, 0x7e, 0x00,
-	0x11, 0xea, 0x44, 0x59,
+	0x11, 0xea, 0x5a, 0x59,
 	0x11, 0xea, 0x00, 0x00,
-	0x02, 0x48, 0x51, 0x35,
+	0x02, 0x4e, 0x51, 0x35,
+	0xc0, 0x4a, 0x94, 0x00,
+	0x04, 0x41, 0x98, 0x79,
 	0x08, 0xea, 0x98, 0x00,
 	0x08, 0x57, 0xae, 0x00,
 	0x08, 0x3c, 0x78, 0x00,
-	0xf0, 0x49, 0x68, 0x0a,
+	0xf0, 0x49, 0x74, 0x0a,
 	0x0f, 0x67, 0xc0, 0x09,
-	0x00, 0x34, 0x69, 0x02,
+	0x00, 0x3a, 0x75, 0x02,
 	0x20, 0xea, 0x96, 0x00,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x40, 0x3a, 0xae, 0x69,
+	0x00, 0xe2, 0x10, 0x42,
+	0xc0, 0x4a, 0x94, 0x00,
+	0x40, 0x3a, 0xc4, 0x69,
 	0x02, 0x55, 0x06, 0x68,
-	0x02, 0x56, 0xae, 0x69,
-	0xff, 0x5b, 0xae, 0x61,
+	0x02, 0x56, 0xc4, 0x69,
+	0xff, 0x5b, 0xc4, 0x61,
 	0x02, 0x20, 0x51, 0x31,
 	0x80, 0xea, 0xb2, 0x01,
 	0x44, 0xea, 0x00, 0x00,
@@ -218,237 +229,246 @@ static uint8_t seqprog[] = {
 	0x33, 0xea, 0x00, 0x00,
 	0xff, 0xea, 0xb2, 0x09,
 	0xff, 0xe0, 0xc0, 0x19,
-	0xff, 0xe0, 0xb0, 0x79,
+	0xff, 0xe0, 0xc6, 0x79,
 	0x02, 0xac, 0x51, 0x31,
-	0x00, 0xe2, 0xa6, 0x41,
+	0x00, 0xe2, 0xbc, 0x41,
 	0x02, 0x5e, 0x50, 0x31,
 	0x02, 0xa8, 0xb8, 0x30,
 	0x02, 0x5c, 0x50, 0x31,
-	0xff, 0xad, 0xc1, 0x71,
+	0xff, 0xad, 0xd7, 0x71,
 	0x02, 0xac, 0x41, 0x31,
 	0x02, 0x22, 0x51, 0x31,
 	0x02, 0xa0, 0x5c, 0x33,
 	0x02, 0xa0, 0x44, 0x32,
-	0x00, 0xe2, 0xca, 0x41,
-	0x10, 0x92, 0xcb, 0x69,
+	0x00, 0xe2, 0xe0, 0x41,
+	0x10, 0x92, 0xe1, 0x69,
 	0x3d, 0x93, 0xc9, 0x29,
 	0x01, 0xe4, 0xc8, 0x01,
 	0x01, 0xea, 0xca, 0x01,
 	0xff, 0xea, 0xda, 0x01,
 	0x02, 0x20, 0x51, 0x31,
 	0x02, 0xae, 0x41, 0x32,
-	0xff, 0x21, 0xd3, 0x61,
+	0xff, 0x21, 0xe9, 0x61,
 	0xff, 0xea, 0x46, 0x02,
 	0x02, 0x5c, 0x50, 0x31,
 	0x40, 0xea, 0x96, 0x00,
-	0x02, 0x56, 0xcc, 0x6d,
-	0x01, 0x55, 0xcc, 0x6d,
-	0x10, 0x92, 0xdf, 0x79,
-	0x10, 0x40, 0xe8, 0x69,
-	0x01, 0x56, 0xe8, 0x79,
+	0x02, 0x56, 0x00, 0x6e,
+	0x01, 0x55, 0x00, 0x6e,
+	0x10, 0x92, 0xf5, 0x79,
+	0x10, 0x40, 0xfe, 0x69,
+	0x01, 0x56, 0xfe, 0x79,
 	0xff, 0x97, 0x07, 0x78,
-	0x13, 0xea, 0x50, 0x59,
+	0x13, 0xea, 0x60, 0x59,
 	0x13, 0xea, 0x04, 0x00,
 	0x00, 0xe2, 0x06, 0x40,
 	0xbf, 0x3a, 0x74, 0x08,
+	0x04, 0x41, 0x04, 0x7a,
 	0x08, 0xea, 0x98, 0x00,
 	0x08, 0x57, 0xae, 0x00,
-	0x01, 0x93, 0x69, 0x32,
-	0x01, 0x94, 0x6b, 0x32,
-	0x40, 0xea, 0x66, 0x02,
+	0x01, 0x93, 0x75, 0x32,
+	0x01, 0x94, 0x77, 0x32,
+	0x40, 0xea, 0x72, 0x02,
 	0x08, 0x3c, 0x78, 0x00,
-	0x80, 0xea, 0x62, 0x02,
-	0x00, 0xe2, 0xb8, 0x5b,
-	0x01, 0x36, 0xc1, 0x31,
-	0x9f, 0xe0, 0x4c, 0x7c,
-	0x80, 0xe0, 0x0c, 0x72,
-	0xa0, 0xe0, 0x44, 0x72,
-	0xc0, 0xe0, 0x3a, 0x72,
-	0xe0, 0xe0, 0x74, 0x72,
-	0x01, 0xea, 0x50, 0x59,
+	0x80, 0xea, 0x6e, 0x02,
+	0x00, 0xe2, 0xde, 0x5b,
+	0x01, 0x3c, 0xc1, 0x31,
+	0x9f, 0xe0, 0x80, 0x7c,
+	0x80, 0xe0, 0x24, 0x72,
+	0xa0, 0xe0, 0x60, 0x72,
+	0xc0, 0xe0, 0x56, 0x72,
+	0xe0, 0xe0, 0x90, 0x72,
+	0x01, 0xea, 0x60, 0x59,
 	0x01, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x80, 0x33, 0x13, 0x7a,
-	0x03, 0xea, 0x50, 0x59,
+	0x00, 0xe2, 0x10, 0x42,
+	0x80, 0x39, 0x2b, 0x7a,
+	0x03, 0xea, 0x60, 0x59,
 	0x03, 0xea, 0x04, 0x00,
-	0xee, 0x00, 0x1a, 0x6a,
+	0xee, 0x00, 0x32, 0x6a,
 	0x05, 0xea, 0xb4, 0x00,
-	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x5a, 0x59,
 	0x33, 0xea, 0x00, 0x00,
-	0x02, 0xa8, 0x90, 0x32,
-	0x00, 0xe2, 0x6a, 0x59,
+	0x02, 0xa8, 0x9c, 0x32,
+	0x00, 0xe2, 0x7a, 0x59,
 	0xef, 0x96, 0xd5, 0x19,
-	0x00, 0xe2, 0x2a, 0x52,
+	0x00, 0xe2, 0x42, 0x52,
 	0x09, 0x80, 0xe1, 0x30,
 	0x02, 0xea, 0x36, 0x00,
 	0xa8, 0xea, 0x32, 0x00,
-	0x00, 0xe2, 0x30, 0x42,
+	0x00, 0xe2, 0x48, 0x42,
 	0x01, 0x96, 0xd1, 0x30,
 	0x10, 0x80, 0x89, 0x31,
 	0x20, 0xea, 0x32, 0x00,
-	0xbf, 0x33, 0x67, 0x0a,
-	0x20, 0x19, 0x32, 0x6a,
-	0x02, 0x4d, 0xf8, 0x69,
-	0x40, 0x33, 0x67, 0x02,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x80, 0x33, 0xb5, 0x6a,
+	0xbf, 0x39, 0x73, 0x0a,
+	0x10, 0x4c, 0x52, 0x6a,
+	0x20, 0x19, 0x4a, 0x6a,
+	0x20, 0x19, 0x4e, 0x6a,
+	0x02, 0x4d, 0x10, 0x6a,
+	0x40, 0x39, 0x73, 0x02,
+	0x00, 0xe2, 0x10, 0x42,
+	0x80, 0x39, 0xd1, 0x6a,
 	0x01, 0x44, 0x10, 0x33,
 	0x08, 0x92, 0x25, 0x03,
-	0x00, 0xe2, 0xf8, 0x41,
+	0x00, 0xe2, 0x10, 0x42,
 	0x10, 0xea, 0x80, 0x00,
-	0x01, 0x31, 0xc5, 0x31,
-	0x80, 0xe2, 0x60, 0x62,
-	0x10, 0x92, 0x85, 0x6a,
+	0x01, 0x37, 0xc5, 0x31,
+	0x80, 0xe2, 0x7c, 0x62,
+	0x10, 0x92, 0xa1, 0x6a,
 	0xc0, 0x94, 0xc5, 0x01,
-	0x40, 0x92, 0x51, 0x6a,
+	0x40, 0x92, 0x6d, 0x6a,
 	0xbf, 0xe2, 0xc4, 0x09,
-	0x20, 0x92, 0x65, 0x7a,
+	0x20, 0x92, 0x81, 0x7a,
 	0x01, 0xe2, 0x88, 0x30,
-	0x00, 0xe2, 0xb8, 0x5b,
-	0xa0, 0x36, 0x6d, 0x62,
+	0x00, 0xe2, 0xde, 0x5b,
+	0xa0, 0x3c, 0x89, 0x62,
 	0x23, 0x92, 0x89, 0x08,
-	0x00, 0xe2, 0xb8, 0x5b,
-	0xa0, 0x36, 0x6d, 0x62,
-	0x00, 0xa8, 0x64, 0x42,
-	0xff, 0xe2, 0x64, 0x62,
-	0x00, 0xe2, 0x84, 0x42,
+	0x00, 0xe2, 0xde, 0x5b,
+	0xa0, 0x3c, 0x89, 0x62,
+	0x00, 0xa8, 0x80, 0x42,
+	0xff, 0xe2, 0x80, 0x62,
+	0x00, 0xe2, 0xa0, 0x42,
 	0x40, 0xea, 0x98, 0x00,
 	0x01, 0xe2, 0x88, 0x30,
-	0x00, 0xe2, 0xb8, 0x5b,
-	0xa0, 0x36, 0x43, 0x72,
+	0x00, 0xe2, 0xde, 0x5b,
+	0xa0, 0x3c, 0x5f, 0x72,
 	0x40, 0xea, 0x98, 0x00,
-	0x01, 0x31, 0x89, 0x32,
-	0x08, 0xea, 0x62, 0x02,
-	0x00, 0xe2, 0xf8, 0x41,
-	0xe0, 0xea, 0xd4, 0x5b,
-	0x80, 0xe0, 0xc0, 0x6a,
-	0x04, 0xe0, 0x66, 0x73,
-	0x02, 0xe0, 0x96, 0x73,
-	0x00, 0xea, 0x1e, 0x73,
-	0x03, 0xe0, 0xa6, 0x73,
-	0x23, 0xe0, 0x96, 0x72,
-	0x08, 0xe0, 0xbc, 0x72,
-	0x00, 0xe2, 0xb8, 0x5b,
-	0x07, 0xea, 0x50, 0x59,
+	0x01, 0x37, 0x95, 0x32,
+	0x08, 0xea, 0x6e, 0x02,
+	0x00, 0xe2, 0x10, 0x42,
+	0xe0, 0xea, 0xfa, 0x5b,
+	0x80, 0xe0, 0xdc, 0x6a,
+	0x04, 0xe0, 0x8e, 0x73,
+	0x02, 0xe0, 0xc0, 0x73,
+	0x00, 0xea, 0x3a, 0x73,
+	0x03, 0xe0, 0xd0, 0x73,
+	0x23, 0xe0, 0xb2, 0x72,
+	0x08, 0xe0, 0xd8, 0x72,
+	0x00, 0xe2, 0xde, 0x5b,
+	0x07, 0xea, 0x60, 0x59,
 	0x07, 0xea, 0x04, 0x00,
-	0x08, 0x42, 0xf9, 0x71,
-	0x04, 0x42, 0x93, 0x62,
-	0x01, 0x43, 0x89, 0x30,
-	0x00, 0xe2, 0x84, 0x42,
+	0x08, 0x48, 0x11, 0x72,
+	0x04, 0x48, 0xaf, 0x62,
+	0x01, 0x49, 0x89, 0x30,
+	0x00, 0xe2, 0xa0, 0x42,
 	0x01, 0x44, 0xd4, 0x31,
-	0x00, 0xe2, 0x84, 0x42,
-	0x01, 0x00, 0x60, 0x32,
-	0x33, 0xea, 0x44, 0x59,
+	0x00, 0xe2, 0xa0, 0x42,
+	0x01, 0x00, 0x6c, 0x32,
+	0x33, 0xea, 0x5a, 0x59,
 	0x33, 0xea, 0x00, 0x00,
-	0x4c, 0x34, 0xc1, 0x28,
+	0x4c, 0x3a, 0xc1, 0x28,
 	0x01, 0x64, 0xc0, 0x31,
-	0x00, 0x30, 0x45, 0x59,
-	0x01, 0x30, 0x01, 0x30,
-	0x01, 0xe0, 0xba, 0x7a,
-	0xa0, 0xea, 0xca, 0x5b,
-	0x01, 0xa0, 0xba, 0x62,
-	0x01, 0x84, 0xaf, 0x7a,
-	0x01, 0x95, 0xbd, 0x6a,
-	0x05, 0xea, 0x50, 0x59,
+	0x00, 0x36, 0x5b, 0x59,
+	0x01, 0x36, 0x01, 0x30,
+	0x01, 0xe0, 0xd6, 0x7a,
+	0xa0, 0xea, 0xf0, 0x5b,
+	0x01, 0xa0, 0xd6, 0x62,
+	0x01, 0x84, 0xcb, 0x7a,
+	0x01, 0x95, 0xd9, 0x6a,
+	0x05, 0xea, 0x60, 0x59,
 	0x05, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xbc, 0x42,
-	0x03, 0xea, 0x50, 0x59,
+	0x00, 0xe2, 0xd8, 0x42,
+	0x03, 0xea, 0x60, 0x59,
 	0x03, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xbc, 0x42,
-	0x07, 0xea, 0xdc, 0x5b,
+	0x00, 0xe2, 0xd8, 0x42,
+	0x07, 0xea, 0x02, 0x5c,
 	0x01, 0x44, 0xd4, 0x31,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x3f, 0xe0, 0x6a, 0x0a,
-	0xc0, 0x34, 0xc1, 0x09,
-	0x00, 0x35, 0x51, 0x01,
+	0x00, 0xe2, 0x10, 0x42,
+	0x3f, 0xe0, 0x76, 0x0a,
+	0xc0, 0x3a, 0xc1, 0x09,
+	0x00, 0x3b, 0x51, 0x01,
 	0xff, 0xea, 0x52, 0x09,
-	0x30, 0x34, 0xc5, 0x09,
+	0x30, 0x3a, 0xc5, 0x09,
 	0x3d, 0xe2, 0xc4, 0x29,
 	0xb8, 0xe2, 0xc4, 0x19,
 	0x01, 0xea, 0xc6, 0x01,
 	0x02, 0xe2, 0xc8, 0x31,
 	0x02, 0xec, 0x40, 0x31,
-	0xff, 0xa1, 0xdc, 0x72,
+	0xff, 0xa1, 0xf8, 0x72,
 	0x02, 0xe8, 0xda, 0x31,
 	0x02, 0xa0, 0x50, 0x31,
-	0x00, 0xe2, 0xfe, 0x42,
-	0x80, 0x33, 0x67, 0x02,
+	0x00, 0xe2, 0x1a, 0x43,
+	0x80, 0x39, 0x73, 0x02,
 	0x01, 0x44, 0xd4, 0x31,
-	0x00, 0xe2, 0xb8, 0x5b,
-	0x01, 0x33, 0x67, 0x02,
-	0xe0, 0x36, 0x19, 0x63,
-	0x02, 0x33, 0x67, 0x02,
-	0x20, 0x46, 0x12, 0x63,
+	0x00, 0xe2, 0xde, 0x5b,
+	0x01, 0x39, 0x73, 0x02,
+	0xe0, 0x3c, 0x35, 0x63,
+	0x02, 0x39, 0x73, 0x02,
+	0x20, 0x46, 0x2e, 0x63,
 	0xff, 0xea, 0x52, 0x09,
-	0xa8, 0xea, 0xca, 0x5b,
-	0x04, 0x92, 0xf9, 0x7a,
-	0x01, 0x34, 0xc1, 0x31,
-	0x00, 0x93, 0xf9, 0x62,
-	0x01, 0x35, 0xc1, 0x31,
-	0x00, 0x94, 0x03, 0x73,
+	0xa8, 0xea, 0xf0, 0x5b,
+	0x04, 0x92, 0x15, 0x7b,
+	0x01, 0x3a, 0xc1, 0x31,
+	0x00, 0x93, 0x15, 0x63,
+	0x01, 0x3b, 0xc1, 0x31,
+	0x00, 0x94, 0x1f, 0x73,
 	0x01, 0xa9, 0x52, 0x11,
-	0xff, 0xa9, 0xee, 0x6a,
-	0x00, 0xe2, 0x12, 0x43,
-	0x10, 0x33, 0x67, 0x02,
-	0x04, 0x92, 0x13, 0x7b,
+	0xff, 0xa9, 0x0a, 0x6b,
+	0x00, 0xe2, 0x2e, 0x43,
+	0x10, 0x39, 0x73, 0x02,
+	0x04, 0x92, 0x2f, 0x7b,
 	0xfb, 0x92, 0x25, 0x0b,
-	0xff, 0xea, 0x66, 0x0a,
-	0x01, 0xa4, 0x0d, 0x6b,
-	0x02, 0xa8, 0x90, 0x32,
-	0x00, 0xe2, 0x6a, 0x59,
-	0x10, 0x92, 0xbd, 0x7a,
-	0xff, 0xea, 0xdc, 0x5b,
-	0x00, 0xe2, 0xbc, 0x42,
-	0x04, 0xea, 0x50, 0x59,
+	0xff, 0xea, 0x72, 0x0a,
+	0x01, 0xa4, 0x29, 0x6b,
+	0x02, 0xa8, 0x9c, 0x32,
+	0x00, 0xe2, 0x7a, 0x59,
+	0x10, 0x92, 0xd9, 0x7a,
+	0xff, 0xea, 0x02, 0x5c,
+	0x00, 0xe2, 0xd8, 0x42,
+	0x04, 0xea, 0x60, 0x59,
 	0x04, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xbc, 0x42,
-	0x04, 0xea, 0x50, 0x59,
+	0x00, 0xe2, 0xd8, 0x42,
+	0x04, 0xea, 0x60, 0x59,
 	0x04, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x08, 0x92, 0xb5, 0x7a,
-	0xc0, 0x33, 0x29, 0x7b,
-	0x80, 0x33, 0xb5, 0x6a,
-	0xff, 0x88, 0x29, 0x6b,
-	0x40, 0x33, 0xb5, 0x6a,
-	0x10, 0x92, 0x2f, 0x7b,
-	0x0a, 0xea, 0x50, 0x59,
+	0x00, 0xe2, 0x10, 0x42,
+	0x08, 0x92, 0xd1, 0x7a,
+	0xc0, 0x39, 0x45, 0x7b,
+	0x80, 0x39, 0xd1, 0x6a,
+	0xff, 0x88, 0x45, 0x6b,
+	0x40, 0x39, 0xd1, 0x6a,
+	0x10, 0x92, 0x4b, 0x7b,
+	0x0a, 0xea, 0x60, 0x59,
 	0x0a, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x4e, 0x5b,
-	0x00, 0xe2, 0x82, 0x43,
-	0x50, 0x4b, 0x36, 0x6b,
+	0x00, 0xe2, 0x6a, 0x5b,
+	0x00, 0xe2, 0xaa, 0x43,
+	0x50, 0x4b, 0x52, 0x6b,
 	0xbf, 0x3a, 0x74, 0x08,
 	0x01, 0xe0, 0xf4, 0x31,
 	0xff, 0xea, 0xc0, 0x09,
-	0x01, 0x2e, 0x5d, 0x1a,
-	0x00, 0x2f, 0x5f, 0x22,
-	0x04, 0x47, 0x8f, 0x02,
+	0x01, 0x32, 0x65, 0x1a,
+	0x00, 0x33, 0x67, 0x22,
+	0x04, 0x4d, 0x9b, 0x02,
 	0x01, 0xfa, 0xc0, 0x35,
-	0x02, 0xa8, 0x84, 0x32,
+	0x02, 0xa8, 0x90, 0x32,
 	0x02, 0xea, 0xb4, 0x00,
-	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x5a, 0x59,
 	0x33, 0xea, 0x00, 0x00,
-	0x02, 0x42, 0x51, 0x31,
-	0xff, 0x90, 0x65, 0x68,
-	0xff, 0x88, 0x5b, 0x6b,
-	0x01, 0xa4, 0x57, 0x6b,
-	0x02, 0xa4, 0x5f, 0x6b,
-	0x01, 0x84, 0x5f, 0x7b,
+	0x02, 0x48, 0x51, 0x31,
+	0xff, 0x90, 0x85, 0x68,
+	0xff, 0x88, 0x77, 0x6b,
+	0x01, 0xa4, 0x73, 0x6b,
+	0x02, 0xa4, 0x7b, 0x6b,
+	0x01, 0x84, 0x7b, 0x7b,
 	0x02, 0x28, 0x19, 0x33,
 	0x02, 0xa8, 0x50, 0x36,
-	0xff, 0x88, 0x5f, 0x73,
-	0x00, 0xe2, 0x32, 0x5b,
+	0xff, 0x88, 0x7b, 0x73,
+	0x00, 0xe2, 0x4e, 0x5b,
 	0x02, 0xa8, 0x20, 0x33,
-	0x02, 0x2c, 0x19, 0x33,
+	0x04, 0xa4, 0x49, 0x03,
+	0xff, 0xea, 0x1a, 0x03,
+	0xff, 0x2d, 0x87, 0x63,
 	0x02, 0xa8, 0x58, 0x32,
-	0x04, 0xa4, 0x49, 0x07,
-	0xc0, 0x33, 0xb5, 0x6a,
+	0x02, 0xa8, 0x5c, 0x36,
+	0x02, 0xa8, 0x40, 0x31,
+	0x02, 0x2e, 0x51, 0x31,
+	0x02, 0xa0, 0x18, 0x33,
+	0x02, 0xa0, 0x5c, 0x36,
+	0xc0, 0x39, 0xd1, 0x6a,
 	0x04, 0x92, 0x25, 0x03,
-	0x20, 0x92, 0x83, 0x6b,
+	0x20, 0x92, 0xab, 0x6b,
 	0x02, 0xa8, 0x40, 0x31,
-	0xc0, 0x34, 0xc1, 0x09,
-	0x00, 0x35, 0x51, 0x01,
+	0xc0, 0x3a, 0xc1, 0x09,
+	0x00, 0x3b, 0x51, 0x01,
 	0xff, 0xea, 0x52, 0x09,
-	0x30, 0x34, 0xc5, 0x09,
+	0x30, 0x3a, 0xc5, 0x09,
 	0x3d, 0xe2, 0xc4, 0x29,
 	0xb8, 0xe2, 0xc4, 0x19,
 	0x01, 0xea, 0xc6, 0x01,
@@ -458,69 +478,75 @@ static uint8_t seqprog[] = {
 	0xf7, 0x57, 0xae, 0x08,
 	0x08, 0xea, 0x98, 0x00,
 	0x01, 0x44, 0xd4, 0x31,
-	0xee, 0x00, 0x8c, 0x6b,
+	0xee, 0x00, 0xb4, 0x6b,
 	0x02, 0xea, 0xb4, 0x00,
-	0x00, 0xe2, 0xb4, 0x5b,
-	0x09, 0x4c, 0x8e, 0x7b,
+	0xc0, 0xea, 0x72, 0x02,
+	0x09, 0x4c, 0xb6, 0x7b,
+	0x01, 0xea, 0x78, 0x02,
 	0x08, 0x4c, 0x06, 0x68,
-	0x0b, 0xea, 0x50, 0x59,
+	0x0b, 0xea, 0x60, 0x59,
 	0x0b, 0xea, 0x04, 0x00,
 	0x01, 0x44, 0xd4, 0x31,
-	0x20, 0x33, 0xf9, 0x79,
-	0x00, 0xe2, 0x9e, 0x5b,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x01, 0x84, 0xa3, 0x7b,
+	0x20, 0x39, 0x11, 0x7a,
+	0x00, 0xe2, 0xc8, 0x5b,
+	0x00, 0xe2, 0x10, 0x42,
+	0x01, 0x84, 0xcd, 0x7b,
 	0x01, 0xa4, 0x49, 0x07,
 	0x08, 0x60, 0x30, 0x33,
 	0x08, 0x80, 0x41, 0x37,
-	0xdf, 0x33, 0x67, 0x0a,
-	0xee, 0x00, 0xb0, 0x6b,
+	0xdf, 0x39, 0x73, 0x0a,
+	0xee, 0x00, 0xda, 0x6b,
 	0x05, 0xea, 0xb4, 0x00,
-	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x5a, 0x59,
 	0x33, 0xea, 0x00, 0x00,
-	0x00, 0xe2, 0x6a, 0x59,
-	0x00, 0xe2, 0xbc, 0x42,
-	0x01, 0xea, 0x6c, 0x02,
-	0xc0, 0xea, 0x66, 0x06,
-	0xff, 0x42, 0xc4, 0x6b,
-	0x01, 0x41, 0xb8, 0x6b,
-	0x02, 0x41, 0xb8, 0x7b,
-	0xff, 0x42, 0xc4, 0x6b,
-	0x01, 0x41, 0xb8, 0x6b,
-	0x02, 0x41, 0xb8, 0x7b,
-	0xff, 0x42, 0xc4, 0x7b,
-	0x04, 0x4c, 0xb8, 0x6b,
-	0xe0, 0x41, 0x6c, 0x0e,
+	0x00, 0xe2, 0x7a, 0x59,
+	0x00, 0xe2, 0xd8, 0x42,
+	0xff, 0x42, 0xea, 0x6b,
+	0x01, 0x41, 0xde, 0x6b,
+	0x02, 0x41, 0xde, 0x7b,
+	0xff, 0x42, 0xea, 0x6b,
+	0x01, 0x41, 0xde, 0x6b,
+	0x02, 0x41, 0xde, 0x7b,
+	0xff, 0x42, 0xea, 0x7b,
+	0x04, 0x4c, 0xde, 0x6b,
+	0xe0, 0x41, 0x78, 0x0e,
 	0x01, 0x44, 0xd4, 0x31,
-	0xff, 0x42, 0xcc, 0x7b,
-	0x04, 0x4c, 0xcc, 0x6b,
-	0xe0, 0x41, 0x6c, 0x0a,
-	0xe0, 0x36, 0xf9, 0x61,
+	0xff, 0x42, 0xf2, 0x7b,
+	0x04, 0x4c, 0xf2, 0x6b,
+	0xe0, 0x41, 0x78, 0x0a,
+	0xe0, 0x3c, 0x11, 0x62,
 	0xff, 0xea, 0xca, 0x09,
 	0x01, 0xe2, 0xc8, 0x31,
 	0x01, 0x46, 0xda, 0x35,
 	0x01, 0x44, 0xd4, 0x35,
 	0x10, 0xea, 0x80, 0x00,
-	0x01, 0xe2, 0x62, 0x36,
-	0x04, 0xa6, 0xe4, 0x7b,
+	0x01, 0xe2, 0x6e, 0x36,
+	0x04, 0xa6, 0x0a, 0x7c,
 	0xff, 0xea, 0x5a, 0x09,
 	0xff, 0xea, 0x4c, 0x0d,
-	0x01, 0xa6, 0x02, 0x6c,
-	0x10, 0xad, 0x64, 0x78,
-	0x80, 0xad, 0xfa, 0x6b,
-	0x08, 0xad, 0x64, 0x68,
+	0x01, 0xa6, 0x36, 0x6c,
+	0x10, 0xad, 0x84, 0x78,
+	0x80, 0xad, 0x2e, 0x6c,
+	0x08, 0xad, 0x84, 0x68,
+	0x20, 0x19, 0x22, 0x7c,
+	0x80, 0xea, 0xb2, 0x01,
+	0x11, 0x00, 0x00, 0x10,
+	0x02, 0xa6, 0x1e, 0x7c,
+	0xff, 0xea, 0xb2, 0x0d,
+	0x11, 0x00, 0x00, 0x10,
+	0xff, 0xea, 0xb2, 0x09,
 	0x04, 0x84, 0xf9, 0x30,
 	0x00, 0xea, 0x08, 0x81,
 	0xff, 0xea, 0xd4, 0x09,
 	0x02, 0x84, 0xf9, 0x88,
 	0x0d, 0xea, 0x5a, 0x01,
 	0x04, 0xa6, 0x4c, 0x05,
-	0x04, 0xa6, 0x64, 0x78,
+	0x04, 0xa6, 0x84, 0x78,
 	0xff, 0xea, 0x5a, 0x09,
 	0x03, 0x84, 0x59, 0x89,
 	0x03, 0xea, 0x4c, 0x01,
-	0x80, 0x1a, 0x64, 0x78,
-	0x08, 0x19, 0x64, 0x78,
+	0x80, 0x1a, 0x84, 0x78,
+	0x08, 0x19, 0x84, 0x78,
 	0x08, 0xb0, 0xe0, 0x30,
 	0x04, 0xb0, 0xe0, 0x30,
 	0x03, 0xb0, 0xf0, 0x30,
@@ -533,259 +559,259 @@ static uint8_t seqprog[] = {
 	0x00, 0x86, 0x0d, 0x23,
 	0x00, 0x87, 0x0f, 0x23,
 	0x01, 0x84, 0xc5, 0x31,
-	0x80, 0x83, 0x25, 0x7c,
+	0x80, 0x83, 0x59, 0x7c,
 	0x02, 0xe2, 0xc4, 0x01,
 	0xff, 0xea, 0x4c, 0x09,
 	0x01, 0xe2, 0x36, 0x30,
 	0xc8, 0x19, 0x32, 0x00,
 	0x88, 0x19, 0x32, 0x00,
 	0x01, 0xac, 0xd4, 0x99,
-	0x00, 0xe2, 0x64, 0x50,
+	0x00, 0xe2, 0x84, 0x50,
 	0xfe, 0xa6, 0x4c, 0x0d,
 	0x0b, 0x98, 0xe1, 0x30,
 	0xfd, 0xa4, 0x49, 0x09,
-	0x80, 0xa3, 0x39, 0x7c,
+	0x80, 0xa3, 0x6d, 0x7c,
 	0x02, 0xa4, 0x48, 0x01,
 	0x01, 0xa4, 0x36, 0x30,
 	0xa8, 0xea, 0x32, 0x00,
 	0xfd, 0xa4, 0x49, 0x0b,
 	0x05, 0xa3, 0x07, 0x33,
-	0x80, 0x83, 0x45, 0x6c,
+	0x80, 0x83, 0x79, 0x6c,
 	0x02, 0xea, 0x4c, 0x05,
 	0xff, 0xea, 0x4c, 0x0d,
-	0x00, 0xe2, 0x3e, 0x59,
-	0x02, 0xa6, 0xe6, 0x6b,
+	0x00, 0xe2, 0x52, 0x59,
+	0x02, 0xa6, 0x0c, 0x6c,
 	0x80, 0xf9, 0xf2, 0x05,
-	0xc0, 0x33, 0x53, 0x7c,
-	0x03, 0xea, 0x50, 0x59,
+	0xc0, 0x39, 0x87, 0x7c,
+	0x03, 0xea, 0x60, 0x59,
 	0x03, 0xea, 0x04, 0x00,
-	0x20, 0x33, 0x77, 0x7c,
-	0x01, 0x84, 0x5d, 0x6c,
-	0x06, 0xea, 0x50, 0x59,
+	0x20, 0x39, 0xab, 0x7c,
+	0x01, 0x84, 0x91, 0x6c,
+	0x06, 0xea, 0x60, 0x59,
 	0x06, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x7a, 0x44,
-	0x01, 0x00, 0x60, 0x32,
-	0xee, 0x00, 0x66, 0x6c,
+	0x00, 0xe2, 0xae, 0x44,
+	0x01, 0x00, 0x6c, 0x32,
+	0xee, 0x00, 0x9a, 0x6c,
 	0x05, 0xea, 0xb4, 0x00,
-	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x5a, 0x59,
 	0x33, 0xea, 0x00, 0x00,
 	0x80, 0x3d, 0x7a, 0x00,
-	0xfc, 0x42, 0x68, 0x7c,
+	0xfc, 0x42, 0x9c, 0x7c,
 	0x7f, 0x3d, 0x7a, 0x08,
-	0x00, 0x30, 0x45, 0x59,
-	0x01, 0x30, 0x01, 0x30,
-	0x09, 0xea, 0x50, 0x59,
+	0x00, 0x36, 0x5b, 0x59,
+	0x01, 0x36, 0x01, 0x30,
+	0x09, 0xea, 0x60, 0x59,
 	0x09, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x01, 0xa4, 0x5d, 0x6c,
-	0x00, 0xe2, 0x30, 0x5c,
-	0x20, 0x33, 0x67, 0x02,
-	0x01, 0x00, 0x60, 0x32,
-	0x02, 0xa6, 0x82, 0x7c,
-	0x00, 0xe2, 0x46, 0x5c,
-	0x00, 0xe2, 0x56, 0x58,
-	0x00, 0xe2, 0x66, 0x58,
-	0x00, 0xe2, 0x3a, 0x58,
-	0x00, 0x30, 0x45, 0x59,
-	0x01, 0x30, 0x01, 0x30,
-	0x20, 0x19, 0x82, 0x6c,
-	0x00, 0xe2, 0xb2, 0x5c,
-	0x04, 0x19, 0x9c, 0x6c,
+	0x00, 0xe2, 0x10, 0x42,
+	0x01, 0xa4, 0x91, 0x6c,
+	0x00, 0xe2, 0x64, 0x5c,
+	0x20, 0x39, 0x73, 0x02,
+	0x01, 0x00, 0x6c, 0x32,
+	0x02, 0xa6, 0xb6, 0x7c,
+	0x00, 0xe2, 0x7a, 0x5c,
+	0x00, 0xe2, 0x76, 0x58,
+	0x00, 0xe2, 0x86, 0x58,
+	0x00, 0xe2, 0x5a, 0x58,
+	0x00, 0x36, 0x5b, 0x59,
+	0x01, 0x36, 0x01, 0x30,
+	0x20, 0x19, 0xb6, 0x6c,
+	0x00, 0xe2, 0xe6, 0x5c,
+	0x04, 0x19, 0xd0, 0x6c,
 	0x02, 0x19, 0x32, 0x00,
-	0x01, 0x84, 0x9d, 0x7c,
-	0x01, 0x1b, 0x96, 0x7c,
-	0x01, 0x1a, 0x9c, 0x6c,
-	0x00, 0xe2, 0x4c, 0x44,
-	0x80, 0x4b, 0xa2, 0x6c,
-	0x01, 0x4c, 0x9e, 0x7c,
-	0x03, 0x42, 0x4c, 0x6c,
-	0x00, 0xe2, 0xe0, 0x5b,
+	0x01, 0x84, 0xd1, 0x7c,
+	0x01, 0x1b, 0xca, 0x7c,
+	0x01, 0x1a, 0xd0, 0x6c,
+	0x00, 0xe2, 0x80, 0x44,
+	0x80, 0x4b, 0xd6, 0x6c,
+	0x01, 0x4c, 0xd2, 0x7c,
+	0x03, 0x42, 0x80, 0x6c,
+	0x00, 0xe2, 0x06, 0x5c,
 	0x80, 0xf9, 0xf2, 0x01,
-	0x04, 0x33, 0xf9, 0x79,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x08, 0x5d, 0xba, 0x6c,
-	0x00, 0xe2, 0x56, 0x58,
-	0x00, 0x30, 0x45, 0x59,
-	0x01, 0x30, 0x01, 0x30,
-	0x02, 0x1b, 0xaa, 0x7c,
-	0x08, 0x5d, 0xb8, 0x7c,
+	0x04, 0x39, 0x11, 0x7a,
+	0x00, 0xe2, 0x10, 0x42,
+	0x08, 0x5d, 0xee, 0x6c,
+	0x00, 0xe2, 0x76, 0x58,
+	0x00, 0x36, 0x5b, 0x59,
+	0x01, 0x36, 0x01, 0x30,
+	0x02, 0x1b, 0xde, 0x7c,
+	0x08, 0x5d, 0xec, 0x7c,
 	0x03, 0x68, 0x00, 0x37,
 	0x01, 0x84, 0x09, 0x07,
-	0x80, 0x1b, 0xc4, 0x7c,
-	0x80, 0x84, 0xc5, 0x6c,
+	0x80, 0x1b, 0xf8, 0x7c,
+	0x80, 0x84, 0xf9, 0x6c,
 	0xff, 0x85, 0x0b, 0x1b,
 	0xff, 0x86, 0x0d, 0x23,
 	0xff, 0x87, 0x0f, 0x23,
 	0xf8, 0x1b, 0x08, 0x0b,
 	0xff, 0xea, 0x06, 0x0b,
 	0x03, 0x68, 0x00, 0x37,
-	0x00, 0xe2, 0xc4, 0x58,
+	0x00, 0xe2, 0xd6, 0x58,
 	0x10, 0xea, 0x18, 0x00,
 	0xf9, 0xd9, 0xb2, 0x0d,
 	0x01, 0xd9, 0xb2, 0x05,
 	0x01, 0x52, 0x48, 0x31,
-	0x20, 0xa4, 0xee, 0x7c,
-	0x20, 0x5b, 0xee, 0x7c,
-	0x80, 0xf9, 0xfc, 0x7c,
+	0x20, 0xa4, 0x22, 0x7d,
+	0x20, 0x5b, 0x22, 0x7d,
+	0x80, 0xf9, 0x30, 0x7d,
 	0x02, 0xea, 0xb4, 0x00,
 	0x11, 0x00, 0x00, 0x10,
-	0x04, 0x19, 0x08, 0x7d,
+	0x04, 0x19, 0x3c, 0x7d,
 	0xdf, 0x19, 0x32, 0x08,
-	0x60, 0x5b, 0xe6, 0x6c,
-	0x01, 0x4c, 0xe2, 0x7c,
+	0x60, 0x5b, 0x3c, 0x6d,
+	0x01, 0x4c, 0x16, 0x7d,
 	0x20, 0x19, 0x32, 0x00,
 	0x01, 0xd9, 0xb2, 0x05,
 	0x02, 0xea, 0xb4, 0x00,
 	0x01, 0xd9, 0xb2, 0x05,
-	0x10, 0x5b, 0x00, 0x6d,
-	0x08, 0x5b, 0x0a, 0x6d,
-	0x20, 0x5b, 0xfa, 0x6c,
-	0x02, 0x5b, 0x2a, 0x6d,
-	0x0e, 0xea, 0x50, 0x59,
+	0x10, 0x5b, 0x34, 0x6d,
+	0x08, 0x5b, 0x3e, 0x6d,
+	0x20, 0x5b, 0x2e, 0x6d,
+	0x02, 0x5b, 0x5e, 0x6d,
+	0x0e, 0xea, 0x60, 0x59,
 	0x0e, 0xea, 0x04, 0x00,
-	0x80, 0xf9, 0xea, 0x6c,
+	0x80, 0xf9, 0x1e, 0x6d,
 	0xdf, 0x5c, 0xb8, 0x08,
 	0x01, 0xd9, 0xb2, 0x05,
-	0x01, 0xa4, 0xe5, 0x6d,
-	0x00, 0xe2, 0x30, 0x5c,
-	0x00, 0xe2, 0x34, 0x5d,
+	0x01, 0xa4, 0x19, 0x6e,
+	0x00, 0xe2, 0x64, 0x5c,
+	0x00, 0xe2, 0x68, 0x5d,
 	0x01, 0x90, 0x21, 0x1b,
 	0x01, 0xd9, 0xb2, 0x05,
-	0x00, 0xe2, 0x32, 0x5b,
+	0x00, 0xe2, 0x4e, 0x5b,
 	0xf3, 0x96, 0xd5, 0x19,
-	0x00, 0xe2, 0x18, 0x55,
-	0x80, 0x96, 0x19, 0x6d,
-	0x0f, 0xea, 0x50, 0x59,
+	0x00, 0xe2, 0x4c, 0x55,
+	0x80, 0x96, 0x4d, 0x6d,
+	0x0f, 0xea, 0x60, 0x59,
 	0x0f, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x20, 0x45,
+	0x00, 0xe2, 0x54, 0x45,
 	0x04, 0x8c, 0xe1, 0x30,
 	0x01, 0xea, 0xf2, 0x00,
 	0x02, 0xea, 0x36, 0x00,
 	0xa8, 0xea, 0x32, 0x00,
-	0xff, 0x97, 0x27, 0x7d,
-	0x14, 0xea, 0x50, 0x59,
+	0xff, 0x97, 0x5b, 0x7d,
+	0x14, 0xea, 0x60, 0x59,
 	0x14, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x96, 0x5d,
+	0x00, 0xe2, 0xca, 0x5d,
 	0x01, 0xd9, 0xb2, 0x05,
 	0x09, 0x80, 0xe1, 0x30,
 	0x02, 0xea, 0x36, 0x00,
 	0xa8, 0xea, 0x32, 0x00,
-	0x00, 0xe2, 0x8e, 0x5d,
+	0x00, 0xe2, 0xc2, 0x5d,
 	0x01, 0xd9, 0xb2, 0x05,
-	0x02, 0xa6, 0x44, 0x7d,
-	0x00, 0xe2, 0x3e, 0x59,
-	0x20, 0x5b, 0x52, 0x6d,
-	0xfc, 0x42, 0x3e, 0x7d,
-	0x10, 0x40, 0x40, 0x6d,
-	0x20, 0x4d, 0x42, 0x7d,
-	0x08, 0x5d, 0x52, 0x6d,
-	0x02, 0xa6, 0xe6, 0x6b,
-	0x00, 0xe2, 0x3e, 0x59,
-	0x20, 0x5b, 0x52, 0x6d,
-	0x01, 0x1b, 0x72, 0x6d,
-	0xfc, 0x42, 0x4e, 0x7d,
-	0x10, 0x40, 0x50, 0x6d,
-	0x20, 0x4d, 0x64, 0x78,
-	0x08, 0x5d, 0x64, 0x78,
+	0x02, 0xa6, 0x78, 0x7d,
+	0x00, 0xe2, 0x52, 0x59,
+	0x20, 0x5b, 0x86, 0x6d,
+	0xfc, 0x42, 0x72, 0x7d,
+	0x10, 0x40, 0x74, 0x6d,
+	0x20, 0x4d, 0x76, 0x7d,
+	0x08, 0x5d, 0x86, 0x6d,
+	0x02, 0xa6, 0x0c, 0x6c,
+	0x00, 0xe2, 0x52, 0x59,
+	0x20, 0x5b, 0x86, 0x6d,
+	0x01, 0x1b, 0xa6, 0x6d,
+	0xfc, 0x42, 0x82, 0x7d,
+	0x10, 0x40, 0x84, 0x6d,
+	0x20, 0x4d, 0x84, 0x78,
+	0x08, 0x5d, 0x84, 0x78,
 	0x02, 0x19, 0x32, 0x00,
 	0x01, 0x5b, 0x40, 0x31,
-	0x00, 0xe2, 0xb2, 0x5c,
-	0x00, 0xe2, 0x9e, 0x5b,
+	0x00, 0xe2, 0xe6, 0x5c,
+	0x00, 0xe2, 0xc8, 0x5b,
 	0x20, 0xea, 0xb6, 0x00,
-	0x00, 0xe2, 0xe0, 0x5b,
+	0x00, 0xe2, 0x06, 0x5c,
 	0x20, 0x5c, 0xb8, 0x00,
-	0x04, 0x19, 0x68, 0x6d,
-	0x01, 0x1a, 0x68, 0x6d,
-	0x00, 0xe2, 0x3e, 0x59,
-	0x01, 0x1a, 0x64, 0x78,
+	0x04, 0x19, 0x9c, 0x6d,
+	0x01, 0x1a, 0x9c, 0x6d,
+	0x00, 0xe2, 0x52, 0x59,
+	0x01, 0x1a, 0x84, 0x78,
 	0x80, 0xf9, 0xf2, 0x01,
-	0x20, 0xa0, 0xcc, 0x7d,
+	0x20, 0xa0, 0x00, 0x7e,
 	0xff, 0x90, 0x21, 0x1b,
-	0x08, 0x92, 0x43, 0x6b,
+	0x08, 0x92, 0x5f, 0x6b,
 	0x02, 0xea, 0xb4, 0x04,
 	0x01, 0xa4, 0x49, 0x03,
-	0x40, 0x5b, 0x82, 0x6d,
-	0x00, 0xe2, 0x3e, 0x59,
-	0x40, 0x5b, 0x82, 0x6d,
-	0x04, 0x5d, 0xe6, 0x7d,
-	0x01, 0x1a, 0xe6, 0x7d,
-	0x20, 0x4d, 0x64, 0x78,
-	0x40, 0x5b, 0xcc, 0x7d,
-	0x04, 0x5d, 0xe6, 0x7d,
-	0x01, 0x1a, 0xe6, 0x7d,
+	0x40, 0x5b, 0xb6, 0x6d,
+	0x00, 0xe2, 0x52, 0x59,
+	0x40, 0x5b, 0xb6, 0x6d,
+	0x04, 0x5d, 0x1a, 0x7e,
+	0x01, 0x1a, 0x1a, 0x7e,
+	0x20, 0x4d, 0x84, 0x78,
+	0x40, 0x5b, 0x00, 0x7e,
+	0x04, 0x5d, 0x1a, 0x7e,
+	0x01, 0x1a, 0x1a, 0x7e,
 	0x80, 0xf9, 0xf2, 0x01,
 	0xff, 0x90, 0x21, 0x1b,
-	0x08, 0x92, 0x43, 0x6b,
+	0x08, 0x92, 0x5f, 0x6b,
 	0x02, 0xea, 0xb4, 0x04,
-	0x00, 0xe2, 0x3e, 0x59,
-	0x01, 0x1b, 0x64, 0x78,
+	0x00, 0xe2, 0x52, 0x59,
+	0x01, 0x1b, 0x84, 0x78,
 	0x80, 0xf9, 0xf2, 0x01,
 	0x02, 0xea, 0xb4, 0x04,
-	0x00, 0xe2, 0x3e, 0x59,
-	0x01, 0x1b, 0xaa, 0x6d,
-	0x40, 0x5b, 0xb8, 0x7d,
-	0x01, 0x1b, 0xaa, 0x6d,
+	0x00, 0xe2, 0x52, 0x59,
+	0x01, 0x1b, 0xde, 0x6d,
+	0x40, 0x5b, 0xec, 0x7d,
+	0x01, 0x1b, 0xde, 0x6d,
 	0x02, 0x19, 0x32, 0x00,
-	0x01, 0x1a, 0x64, 0x78,
+	0x01, 0x1a, 0x84, 0x78,
 	0x80, 0xf9, 0xf2, 0x01,
 	0xff, 0xea, 0x10, 0x03,
 	0x08, 0x92, 0x25, 0x03,
-	0x00, 0xe2, 0x42, 0x43,
-	0x01, 0x1a, 0xb4, 0x7d,
-	0x40, 0x5b, 0xb0, 0x7d,
-	0x01, 0x1a, 0x9e, 0x6d,
-	0xfc, 0x42, 0x64, 0x78,
-	0x01, 0x1a, 0xb8, 0x6d,
-	0x10, 0xea, 0x50, 0x59,
+	0x00, 0xe2, 0x5e, 0x43,
+	0x01, 0x1a, 0xe8, 0x7d,
+	0x40, 0x5b, 0xe4, 0x7d,
+	0x01, 0x1a, 0xd2, 0x6d,
+	0xfc, 0x42, 0x84, 0x78,
+	0x01, 0x1a, 0xec, 0x6d,
+	0x10, 0xea, 0x60, 0x59,
 	0x10, 0xea, 0x04, 0x00,
-	0xfc, 0x42, 0x64, 0x78,
-	0x10, 0x40, 0xbe, 0x6d,
-	0x20, 0x4d, 0x64, 0x78,
-	0x40, 0x5b, 0x9e, 0x6d,
-	0x01, 0x1a, 0x64, 0x78,
+	0xfc, 0x42, 0x84, 0x78,
+	0x10, 0x40, 0xf2, 0x6d,
+	0x20, 0x4d, 0x84, 0x78,
+	0x40, 0x5b, 0xd2, 0x6d,
+	0x01, 0x1a, 0x84, 0x78,
 	0x01, 0x90, 0x21, 0x1b,
 	0x30, 0x3f, 0xc0, 0x09,
-	0x30, 0xe0, 0x64, 0x60,
-	0x40, 0x4b, 0x64, 0x68,
+	0x30, 0xe0, 0x84, 0x60,
+	0x40, 0x4b, 0x84, 0x68,
 	0xff, 0xea, 0x52, 0x01,
-	0xee, 0x00, 0xd2, 0x6d,
+	0xee, 0x00, 0x08, 0x6e,
 	0x80, 0xf9, 0xf2, 0x01,
 	0xff, 0x90, 0x21, 0x1b,
 	0x02, 0xea, 0xb4, 0x00,
 	0x20, 0xea, 0x9a, 0x00,
-	0xf3, 0x42, 0xde, 0x6d,
-	0x12, 0xea, 0x50, 0x59,
+	0xf3, 0x42, 0x12, 0x6e,
+	0x12, 0xea, 0x60, 0x59,
 	0x12, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xf8, 0x41,
-	0x0d, 0xea, 0x50, 0x59,
+	0x00, 0xe2, 0x10, 0x42,
+	0x0d, 0xea, 0x60, 0x59,
 	0x0d, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xf8, 0x41,
+	0x00, 0xe2, 0x10, 0x42,
 	0x01, 0x90, 0x21, 0x1b,
-	0x11, 0xea, 0x50, 0x59,
+	0x11, 0xea, 0x60, 0x59,
 	0x11, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x32, 0x5b,
+	0x00, 0xe2, 0x4e, 0x5b,
 	0x08, 0x5a, 0xb4, 0x00,
-	0x00, 0xe2, 0x0c, 0x5e,
+	0x00, 0xe2, 0x40, 0x5e,
 	0xa8, 0xea, 0x32, 0x00,
-	0x00, 0xe2, 0x3e, 0x59,
-	0x80, 0x1a, 0xfa, 0x7d,
-	0x00, 0xe2, 0x0c, 0x5e,
+	0x00, 0xe2, 0x52, 0x59,
+	0x80, 0x1a, 0x2e, 0x7e,
+	0x00, 0xe2, 0x40, 0x5e,
 	0x80, 0x19, 0x32, 0x00,
-	0x40, 0x5b, 0x00, 0x6e,
-	0x08, 0x5a, 0x00, 0x7e,
-	0x20, 0x4d, 0x64, 0x78,
+	0x40, 0x5b, 0x34, 0x6e,
+	0x08, 0x5a, 0x34, 0x7e,
+	0x20, 0x4d, 0x84, 0x78,
 	0x02, 0x84, 0x09, 0x03,
-	0x40, 0x5b, 0xcc, 0x7d,
+	0x40, 0x5b, 0x00, 0x7e,
 	0xff, 0x90, 0x21, 0x1b,
 	0x80, 0xf9, 0xf2, 0x01,
-	0x08, 0x92, 0x43, 0x6b,
+	0x08, 0x92, 0x5f, 0x6b,
 	0x02, 0xea, 0xb4, 0x04,
-	0x01, 0x38, 0xe1, 0x30,
-	0x05, 0x39, 0xe3, 0x98,
+	0x01, 0x40, 0xe1, 0x30,
+	0x05, 0x41, 0xe3, 0x98,
 	0x01, 0xe0, 0xf4, 0x31,
 	0xff, 0xea, 0xc0, 0x09,
-	0x00, 0x3a, 0xe5, 0x20,
-	0x00, 0x3b, 0xe7, 0x20,
+	0x00, 0x42, 0xe5, 0x20,
+	0x00, 0x43, 0xe7, 0x20,
 	0x01, 0xfa, 0xc0, 0x31,
 	0x04, 0xea, 0xe8, 0x30,
 	0xff, 0xea, 0xf0, 0x08,
@@ -794,12 +820,20 @@ static uint8_t seqprog[] = {
 };
 
 typedef int ahd_patch_func_t (struct ahd_softc *ahd);
+static ahd_patch_func_t ahd_patch23_func;
+
+static int
+ahd_patch23_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0);
+}
+
 static ahd_patch_func_t ahd_patch22_func;
 
 static int
 ahd_patch22_func(struct ahd_softc *ahd)
 {
-	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0);
+	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0);
 }
 
 static ahd_patch_func_t ahd_patch21_func;
@@ -807,7 +841,7 @@ static ahd_patch_func_t ahd_patch21_func
 static int
 ahd_patch21_func(struct ahd_softc *ahd)
 {
-	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0);
+	return ((ahd->flags & AHD_INITIATORROLE) != 0);
 }
 
 static ahd_patch_func_t ahd_patch20_func;
@@ -815,7 +849,7 @@ static ahd_patch_func_t ahd_patch20_func
 static int
 ahd_patch20_func(struct ahd_softc *ahd)
 {
-	return ((ahd->features & AHD_RTI) == 0);
+	return ((ahd->flags & AHD_TARGETROLE) != 0);
 }
 
 static ahd_patch_func_t ahd_patch19_func;
@@ -823,7 +857,7 @@ static ahd_patch_func_t ahd_patch19_func
 static int
 ahd_patch19_func(struct ahd_softc *ahd)
 {
-	return ((ahd->flags & AHD_INITIATORROLE) != 0);
+	return ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0);
 }
 
 static ahd_patch_func_t ahd_patch18_func;
@@ -831,7 +865,7 @@ static ahd_patch_func_t ahd_patch18_func
 static int
 ahd_patch18_func(struct ahd_softc *ahd)
 {
-	return ((ahd->flags & AHD_TARGETROLE) != 0);
+	return ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0);
 }
 
 static ahd_patch_func_t ahd_patch17_func;
@@ -839,7 +873,7 @@ static ahd_patch_func_t ahd_patch17_func
 static int
 ahd_patch17_func(struct ahd_softc *ahd)
 {
-	return ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0);
+	return ((ahd->flags & AHD_39BIT_ADDRESSING) != 0);
 }
 
 static ahd_patch_func_t ahd_patch16_func;
@@ -847,7 +881,7 @@ static ahd_patch_func_t ahd_patch16_func
 static int
 ahd_patch16_func(struct ahd_softc *ahd)
 {
-	return ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0);
+	return ((ahd->flags & AHD_64BIT_ADDRESSING) != 0);
 }
 
 static ahd_patch_func_t ahd_patch15_func;
@@ -855,7 +889,7 @@ static ahd_patch_func_t ahd_patch15_func
 static int
 ahd_patch15_func(struct ahd_softc *ahd)
 {
-	return ((ahd->flags & AHD_39BIT_ADDRESSING) != 0);
+	return ((ahd->features & AHD_NEW_DFCNTRL_OPTS) == 0);
 }
 
 static ahd_patch_func_t ahd_patch14_func;
@@ -863,7 +897,7 @@ static ahd_patch_func_t ahd_patch14_func
 static int
 ahd_patch14_func(struct ahd_softc *ahd)
 {
-	return ((ahd->flags & AHD_64BIT_ADDRESSING) != 0);
+	return ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0);
 }
 
 static ahd_patch_func_t ahd_patch13_func;
@@ -871,7 +905,7 @@ static ahd_patch_func_t ahd_patch13_func
 static int
 ahd_patch13_func(struct ahd_softc *ahd)
 {
-	return ((ahd->features & AHD_NEW_DFCNTRL_OPTS) == 0);
+	return ((ahd->features & AHD_RTI) == 0);
 }
 
 static ahd_patch_func_t ahd_patch12_func;
@@ -879,7 +913,7 @@ static ahd_patch_func_t ahd_patch12_func
 static int
 ahd_patch12_func(struct ahd_softc *ahd)
 {
-	return ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0);
+	return ((ahd->bugs & AHD_EARLY_REQ_BUG) != 0);
 }
 
 static ahd_patch_func_t ahd_patch11_func;
@@ -887,7 +921,7 @@ static ahd_patch_func_t ahd_patch11_func
 static int
 ahd_patch11_func(struct ahd_softc *ahd)
 {
-	return ((ahd->bugs & AHD_EARLY_REQ_BUG) != 0);
+	return ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0);
 }
 
 static ahd_patch_func_t ahd_patch10_func;
@@ -895,7 +929,7 @@ static ahd_patch_func_t ahd_patch10_func
 static int
 ahd_patch10_func(struct ahd_softc *ahd)
 {
-	return ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0);
+	return ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0);
 }
 
 static ahd_patch_func_t ahd_patch9_func;
@@ -903,7 +937,7 @@ static ahd_patch_func_t ahd_patch9_func;
 static int
 ahd_patch9_func(struct ahd_softc *ahd)
 {
-	return ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0);
+	return ((ahd->features & AHD_FAST_CDB_DELIVERY) != 0);
 }
 
 static ahd_patch_func_t ahd_patch8_func;
@@ -992,147 +1026,149 @@ static struct patch {
 	{ ahd_patch0_func, 5, 1, 1 },
 	{ ahd_patch2_func, 6, 1, 2 },
 	{ ahd_patch0_func, 7, 1, 1 },
-	{ ahd_patch3_func, 20, 5, 1 },
-	{ ahd_patch2_func, 29, 1, 2 },
-	{ ahd_patch0_func, 30, 1, 1 },
-	{ ahd_patch1_func, 37, 1, 2 },
-	{ ahd_patch0_func, 38, 1, 1 },
-	{ ahd_patch2_func, 43, 1, 2 },
-	{ ahd_patch0_func, 44, 1, 1 },
-	{ ahd_patch2_func, 47, 1, 2 },
-	{ ahd_patch0_func, 48, 1, 1 },
-	{ ahd_patch2_func, 51, 1, 2 },
-	{ ahd_patch0_func, 52, 1, 1 },
-	{ ahd_patch2_func, 65, 1, 2 },
-	{ ahd_patch0_func, 66, 1, 1 },
-	{ ahd_patch2_func, 69, 1, 2 },
-	{ ahd_patch0_func, 70, 1, 1 },
-	{ ahd_patch1_func, 73, 1, 2 },
-	{ ahd_patch0_func, 74, 1, 1 },
-	{ ahd_patch4_func, 107, 1, 1 },
-	{ ahd_patch2_func, 162, 6, 1 },
-	{ ahd_patch1_func, 168, 2, 1 },
-	{ ahd_patch5_func, 170, 1, 1 },
-	{ ahd_patch2_func, 179, 1, 2 },
-	{ ahd_patch0_func, 180, 1, 1 },
-	{ ahd_patch6_func, 181, 2, 2 },
-	{ ahd_patch0_func, 183, 6, 3 },
-	{ ahd_patch2_func, 186, 1, 2 },
-	{ ahd_patch0_func, 187, 1, 1 },
-	{ ahd_patch2_func, 190, 1, 2 },
-	{ ahd_patch0_func, 191, 1, 1 },
-	{ ahd_patch7_func, 193, 2, 1 },
-	{ ahd_patch5_func, 201, 16, 2 },
-	{ ahd_patch0_func, 217, 1, 1 },
-	{ ahd_patch8_func, 237, 2, 1 },
-	{ ahd_patch1_func, 241, 1, 2 },
-	{ ahd_patch0_func, 242, 1, 1 },
-	{ ahd_patch7_func, 245, 2, 1 },
-	{ ahd_patch1_func, 259, 1, 2 },
-	{ ahd_patch0_func, 260, 1, 1 },
-	{ ahd_patch1_func, 263, 1, 2 },
-	{ ahd_patch0_func, 264, 1, 1 },
-	{ ahd_patch2_func, 267, 1, 2 },
-	{ ahd_patch0_func, 268, 1, 1 },
-	{ ahd_patch1_func, 323, 1, 2 },
-	{ ahd_patch0_func, 324, 1, 1 },
-	{ ahd_patch2_func, 332, 1, 2 },
-	{ ahd_patch0_func, 333, 1, 1 },
-	{ ahd_patch2_func, 336, 1, 2 },
-	{ ahd_patch0_func, 337, 1, 1 },
-	{ ahd_patch1_func, 343, 1, 2 },
-	{ ahd_patch0_func, 344, 1, 1 },
-	{ ahd_patch1_func, 346, 1, 2 },
+	{ ahd_patch3_func, 36, 5, 1 },
+	{ ahd_patch2_func, 45, 1, 2 },
+	{ ahd_patch0_func, 46, 1, 1 },
+	{ ahd_patch1_func, 53, 1, 2 },
+	{ ahd_patch0_func, 54, 1, 1 },
+	{ ahd_patch2_func, 59, 1, 2 },
+	{ ahd_patch0_func, 60, 1, 1 },
+	{ ahd_patch2_func, 63, 1, 2 },
+	{ ahd_patch0_func, 64, 1, 1 },
+	{ ahd_patch2_func, 67, 1, 2 },
+	{ ahd_patch0_func, 68, 1, 1 },
+	{ ahd_patch4_func, 116, 1, 1 },
+	{ ahd_patch2_func, 173, 3, 1 },
+	{ ahd_patch1_func, 176, 2, 1 },
+	{ ahd_patch5_func, 178, 1, 1 },
+	{ ahd_patch2_func, 187, 1, 2 },
+	{ ahd_patch0_func, 188, 1, 1 },
+	{ ahd_patch6_func, 189, 2, 2 },
+	{ ahd_patch0_func, 191, 6, 3 },
+	{ ahd_patch2_func, 194, 1, 2 },
+	{ ahd_patch0_func, 195, 1, 1 },
+	{ ahd_patch2_func, 198, 1, 2 },
+	{ ahd_patch0_func, 199, 1, 1 },
+	{ ahd_patch3_func, 201, 1, 1 },
+	{ ahd_patch7_func, 202, 3, 1 },
+	{ ahd_patch3_func, 211, 1, 1 },
+	{ ahd_patch5_func, 212, 16, 2 },
+	{ ahd_patch0_func, 228, 1, 1 },
+	{ ahd_patch8_func, 248, 2, 1 },
+	{ ahd_patch1_func, 252, 1, 2 },
+	{ ahd_patch0_func, 253, 1, 1 },
+	{ ahd_patch7_func, 256, 3, 1 },
+	{ ahd_patch1_func, 271, 1, 2 },
+	{ ahd_patch0_func, 272, 1, 1 },
+	{ ahd_patch1_func, 275, 1, 2 },
+	{ ahd_patch0_func, 276, 1, 1 },
+	{ ahd_patch2_func, 279, 1, 2 },
+	{ ahd_patch0_func, 280, 1, 1 },
+	{ ahd_patch9_func, 293, 2, 2 },
+	{ ahd_patch0_func, 295, 1, 1 },
+	{ ahd_patch1_func, 337, 1, 2 },
+	{ ahd_patch0_func, 338, 1, 1 },
+	{ ahd_patch2_func, 346, 1, 2 },
 	{ ahd_patch0_func, 347, 1, 1 },
-	{ ahd_patch9_func, 366, 1, 1 },
-	{ ahd_patch9_func, 369, 1, 1 },
-	{ ahd_patch9_func, 371, 1, 1 },
-	{ ahd_patch9_func, 383, 1, 1 },
-	{ ahd_patch1_func, 393, 1, 2 },
-	{ ahd_patch0_func, 394, 1, 1 },
-	{ ahd_patch1_func, 396, 1, 2 },
-	{ ahd_patch0_func, 397, 1, 1 },
-	{ ahd_patch1_func, 405, 1, 2 },
-	{ ahd_patch0_func, 406, 1, 1 },
-	{ ahd_patch2_func, 419, 1, 2 },
+	{ ahd_patch2_func, 350, 1, 2 },
+	{ ahd_patch0_func, 351, 1, 1 },
+	{ ahd_patch1_func, 357, 1, 2 },
+	{ ahd_patch0_func, 358, 1, 1 },
+	{ ahd_patch1_func, 360, 1, 2 },
+	{ ahd_patch0_func, 361, 1, 1 },
+	{ ahd_patch10_func, 380, 1, 1 },
+	{ ahd_patch10_func, 383, 1, 1 },
+	{ ahd_patch10_func, 385, 1, 1 },
+	{ ahd_patch10_func, 397, 1, 1 },
+	{ ahd_patch1_func, 407, 1, 2 },
+	{ ahd_patch0_func, 408, 1, 1 },
+	{ ahd_patch1_func, 410, 1, 2 },
+	{ ahd_patch0_func, 411, 1, 1 },
+	{ ahd_patch1_func, 419, 1, 2 },
 	{ ahd_patch0_func, 420, 1, 1 },
-	{ ahd_patch10_func, 450, 1, 1 },
-	{ ahd_patch1_func, 457, 1, 2 },
-	{ ahd_patch0_func, 458, 1, 1 },
-	{ ahd_patch2_func, 470, 1, 2 },
-	{ ahd_patch0_func, 471, 1, 1 },
-	{ ahd_patch11_func, 476, 6, 2 },
-	{ ahd_patch0_func, 482, 1, 1 },
-	{ ahd_patch12_func, 505, 1, 1 },
-	{ ahd_patch13_func, 514, 1, 1 },
-	{ ahd_patch14_func, 515, 1, 2 },
-	{ ahd_patch0_func, 516, 1, 1 },
-	{ ahd_patch15_func, 519, 1, 1 },
-	{ ahd_patch14_func, 520, 1, 1 },
-	{ ahd_patch16_func, 531, 1, 2 },
-	{ ahd_patch0_func, 532, 1, 1 },
-	{ ahd_patch1_func, 551, 1, 2 },
-	{ ahd_patch0_func, 552, 1, 1 },
-	{ ahd_patch1_func, 555, 1, 2 },
-	{ ahd_patch0_func, 556, 1, 1 },
-	{ ahd_patch2_func, 561, 1, 2 },
-	{ ahd_patch0_func, 562, 1, 1 },
-	{ ahd_patch2_func, 566, 1, 2 },
-	{ ahd_patch0_func, 567, 1, 1 },
-	{ ahd_patch1_func, 568, 1, 2 },
-	{ ahd_patch0_func, 569, 1, 1 },
-	{ ahd_patch2_func, 580, 1, 2 },
-	{ ahd_patch0_func, 581, 1, 1 },
-	{ ahd_patch17_func, 585, 1, 1 },
-	{ ahd_patch18_func, 590, 1, 1 },
-	{ ahd_patch19_func, 591, 2, 1 },
-	{ ahd_patch18_func, 595, 1, 2 },
-	{ ahd_patch0_func, 596, 1, 1 },
-	{ ahd_patch2_func, 599, 1, 2 },
-	{ ahd_patch0_func, 600, 1, 1 },
-	{ ahd_patch2_func, 615, 1, 2 },
-	{ ahd_patch0_func, 616, 1, 1 },
-	{ ahd_patch20_func, 617, 14, 1 },
-	{ ahd_patch1_func, 635, 1, 2 },
-	{ ahd_patch0_func, 636, 1, 1 },
-	{ ahd_patch20_func, 637, 1, 1 },
-	{ ahd_patch1_func, 649, 1, 2 },
-	{ ahd_patch0_func, 650, 1, 1 },
-	{ ahd_patch1_func, 657, 1, 2 },
-	{ ahd_patch0_func, 658, 1, 1 },
-	{ ahd_patch17_func, 681, 1, 1 },
-	{ ahd_patch17_func, 719, 1, 1 },
-	{ ahd_patch1_func, 730, 1, 2 },
-	{ ahd_patch0_func, 731, 1, 1 },
-	{ ahd_patch1_func, 748, 1, 2 },
-	{ ahd_patch0_func, 749, 1, 1 },
-	{ ahd_patch1_func, 751, 1, 2 },
-	{ ahd_patch0_func, 752, 1, 1 },
-	{ ahd_patch1_func, 755, 1, 2 },
-	{ ahd_patch0_func, 756, 1, 1 },
-	{ ahd_patch21_func, 758, 1, 2 },
-	{ ahd_patch0_func, 759, 2, 1 },
-	{ ahd_patch22_func, 762, 4, 2 },
-	{ ahd_patch0_func, 766, 1, 1 },
-	{ ahd_patch22_func, 774, 11, 1 }
+	{ ahd_patch2_func, 433, 1, 2 },
+	{ ahd_patch0_func, 434, 1, 1 },
+	{ ahd_patch11_func, 470, 1, 1 },
+	{ ahd_patch1_func, 478, 1, 2 },
+	{ ahd_patch0_func, 479, 1, 1 },
+	{ ahd_patch2_func, 491, 1, 2 },
+	{ ahd_patch0_func, 492, 1, 1 },
+	{ ahd_patch12_func, 495, 6, 2 },
+	{ ahd_patch0_func, 501, 1, 1 },
+	{ ahd_patch13_func, 522, 7, 1 },
+	{ ahd_patch14_func, 531, 1, 1 },
+	{ ahd_patch15_func, 540, 1, 1 },
+	{ ahd_patch16_func, 541, 1, 2 },
+	{ ahd_patch0_func, 542, 1, 1 },
+	{ ahd_patch17_func, 545, 1, 1 },
+	{ ahd_patch16_func, 546, 1, 1 },
+	{ ahd_patch18_func, 557, 1, 2 },
+	{ ahd_patch0_func, 558, 1, 1 },
+	{ ahd_patch1_func, 577, 1, 2 },
+	{ ahd_patch0_func, 578, 1, 1 },
+	{ ahd_patch1_func, 581, 1, 2 },
+	{ ahd_patch0_func, 582, 1, 1 },
+	{ ahd_patch2_func, 587, 1, 2 },
+	{ ahd_patch0_func, 588, 1, 1 },
+	{ ahd_patch2_func, 592, 1, 2 },
+	{ ahd_patch0_func, 593, 1, 1 },
+	{ ahd_patch1_func, 594, 1, 2 },
+	{ ahd_patch0_func, 595, 1, 1 },
+	{ ahd_patch2_func, 606, 1, 2 },
+	{ ahd_patch0_func, 607, 1, 1 },
+	{ ahd_patch19_func, 611, 1, 1 },
+	{ ahd_patch20_func, 616, 1, 1 },
+	{ ahd_patch21_func, 617, 2, 1 },
+	{ ahd_patch20_func, 621, 1, 2 },
+	{ ahd_patch0_func, 622, 1, 1 },
+	{ ahd_patch2_func, 625, 1, 2 },
+	{ ahd_patch0_func, 626, 1, 1 },
+	{ ahd_patch2_func, 641, 1, 2 },
+	{ ahd_patch0_func, 642, 1, 1 },
+	{ ahd_patch13_func, 643, 14, 1 },
+	{ ahd_patch1_func, 661, 1, 2 },
+	{ ahd_patch0_func, 662, 1, 1 },
+	{ ahd_patch13_func, 663, 1, 1 },
+	{ ahd_patch1_func, 675, 1, 2 },
+	{ ahd_patch0_func, 676, 1, 1 },
+	{ ahd_patch1_func, 683, 1, 2 },
+	{ ahd_patch0_func, 684, 1, 1 },
+	{ ahd_patch19_func, 707, 1, 1 },
+	{ ahd_patch19_func, 745, 1, 1 },
+	{ ahd_patch1_func, 756, 1, 2 },
+	{ ahd_patch0_func, 757, 1, 1 },
+	{ ahd_patch1_func, 774, 1, 2 },
+	{ ahd_patch0_func, 775, 1, 1 },
+	{ ahd_patch1_func, 777, 1, 2 },
+	{ ahd_patch0_func, 778, 1, 1 },
+	{ ahd_patch1_func, 781, 1, 2 },
+	{ ahd_patch0_func, 782, 1, 1 },
+	{ ahd_patch22_func, 784, 1, 2 },
+	{ ahd_patch0_func, 785, 2, 1 },
+	{ ahd_patch23_func, 788, 4, 2 },
+	{ ahd_patch0_func, 792, 1, 1 },
+	{ ahd_patch23_func, 800, 11, 1 }
 };
 
 static struct cs {
 	uint16_t	begin;
 	uint16_t	end;
 } critical_sections[] = {
-	{ 11, 12 },
-	{ 13, 14 },
-	{ 29, 42 },
-	{ 56, 59 },
-	{ 101, 128 },
-	{ 129, 157 },
-	{ 159, 162 },
-	{ 170, 178 },
-	{ 201, 250 },
-	{ 681, 697 },
-	{ 697, 711 },
-	{ 721, 725 }
+	{ 17, 28 },
+	{ 29, 30 },
+	{ 47, 58 },
+	{ 61, 63 },
+	{ 65, 66 },
+	{ 72, 92 },
+	{ 110, 137 },
+	{ 138, 173 },
+	{ 178, 186 },
+	{ 211, 262 },
+	{ 423, 431 },
+	{ 441, 443 },
+	{ 446, 455 },
+	{ 707, 737 },
+	{ 747, 751 }
 };
 
 static const int num_critical_sections = sizeof(critical_sections)
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx.h linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx.h
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx.h	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx.h	2004-05-13 16:42:17.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.h#79 $
+ * $Id$
  *
  * $FreeBSD$
  */
@@ -243,7 +243,7 @@ typedef enum {
 	 */
 	AHC_AIC7850_FE	= AHC_SPIOCAP|AHC_AUTOPAUSE|AHC_TARGETMODE|AHC_ULTRA,
 	AHC_AIC7860_FE	= AHC_AIC7850_FE,
-	AHC_AIC7870_FE	= AHC_TARGETMODE,
+	AHC_AIC7870_FE	= AHC_TARGETMODE|AHC_AUTOPAUSE,
 	AHC_AIC7880_FE	= AHC_AIC7870_FE|AHC_ULTRA,
 	/*
 	 * Although we have space for both the initiator and
@@ -366,7 +366,8 @@ typedef enum {
 	AHC_SCB_CONFIG_USED   = 0x4000000, /* No SEEPROM but SCB2 had info. */
 	AHC_NO_BIOS_INIT      = 0x8000000, /* No BIOS left over settings. */
 	AHC_DISABLE_PCI_PERR  = 0x10000000,
-	AHC_HAS_TERM_LOGIC    = 0x20000000
+	AHC_HAS_TERM_LOGIC    = 0x20000000,
+	AHC_SHUTDOWN_RECOVERY = 0x40000000 /* Terminate recovery thread. */
 } ahc_flag;
 
 /************************* Hardware  SCB Definition ***************************/
@@ -411,6 +412,7 @@ struct target_data {
 	uint8_t  initiator_tag;		/* Initiator's transaction tag */
 };
 
+#define MAX_CDB_LEN 16
 struct hardware_scb {
 /*0*/	union {
 		/*
@@ -530,7 +532,7 @@ struct sg_map_node {
  * The current state of this SCB.
  */
 typedef enum {
-	SCB_FREE		= 0x0000,
+	SCB_FLAG_NONE		= 0x0000,
 	SCB_OTHERTCL_TIMEOUT	= 0x0002,/*
 					  * Another device was active
 					  * during the first timeout for
@@ -560,12 +562,16 @@ typedef enum {
 					  * to report the error.
 					  */
 	SCB_TARGET_SCB		= 0x2000,
-	SCB_SILENT		= 0x4000 /*
+	SCB_SILENT		= 0x4000,/*
 					  * Be quiet about transmission type
 					  * errors.  They are expected and we
 					  * don't want to upset the user.  This
 					  * flag is typically used during DV.
 					  */
+	SCB_TIMEDOUT		= 0x8000 /*
+					  * SCB has timed out and is on the
+					  * timedout list.
+					  */
 } scb_flag;
 
 struct scb {
@@ -575,7 +581,8 @@ struct scb {
 		TAILQ_ENTRY(scb)  tqe;
 	} links;
 	LIST_ENTRY(scb)		  pending_links;
-	ahc_io_ctx_t		  io_ctx;
+	LIST_ENTRY(scb)		  timedout_links;
+	aic_io_ctx_t		  io_ctx;
 	struct ahc_softc	 *ahc_softc;
 	scb_flag		  flags;
 #ifndef __linux__
@@ -929,6 +936,11 @@ struct ahc_softc {
 	LIST_HEAD(, scb)	  pending_scbs;
 
 	/*
+	 * SCBs whose timeout routine has been called.
+	 */
+	LIST_HEAD(, scb)	  timedout_scbs;
+
+	/*
 	 * Counting lock for deferring the release of additional
 	 * untagged transactions from the untagged_queues.  When
 	 * the lock is decremented to 0, all queues in the
@@ -958,7 +970,7 @@ struct ahc_softc {
 	/*
 	 * Platform specific device information.
 	 */
-	ahc_dev_softc_t		  dev_softc;
+	aic_dev_softc_t		  dev_softc;
 
 	/*
 	 * Bus specific device information.
@@ -1135,6 +1147,9 @@ struct ahc_devinfo {
 };
 
 /****************************** PCI Structures ********************************/
+#define	AHC_PCI_IOADDR  PCIR_BAR(0)	/* I/O Address */
+#define	AHC_PCI_MEMADDR PCIR_BAR(1)	/* Mem I/O Address */
+
 typedef int (ahc_device_setup_t)(struct ahc_softc *);
 
 struct ahc_pci_identity {
@@ -1167,7 +1182,7 @@ void			ahc_busy_tcl(struct ahc_softc *ah
 				     u_int tcl, u_int busyid);
 
 /***************************** PCI Front End *********************************/
-struct ahc_pci_identity	*ahc_find_pci_device(ahc_dev_softc_t);
+struct ahc_pci_identity	*ahc_find_pci_device(aic_dev_softc_t);
 int			 ahc_pci_config(struct ahc_softc *,
 					struct ahc_pci_identity *);
 int			 ahc_pci_test_register_access(struct ahc_softc *);
@@ -1231,7 +1246,7 @@ int			ahc_search_qinfifo(struct ahc_soft
 					   role_t role, uint32_t status,
 					   ahc_search_action action);
 int			ahc_search_untagged_queues(struct ahc_softc *ahc,
-						   ahc_io_ctx_t ctx,
+						   aic_io_ctx_t ctx,
 						   int target, char channel,
 						   int lun, uint32_t status,
 						   ahc_search_action action);
@@ -1248,6 +1263,8 @@ int			ahc_abort_scbs(struct ahc_softc *a
 void			ahc_restart(struct ahc_softc *ahc);
 void			ahc_calc_residual(struct ahc_softc *ahc,
 					  struct scb *scb);
+void			ahc_timeout(struct scb *scb);
+void			ahc_recover_commands(struct ahc_softc *ahc);
 /*************************** Utility Functions ********************************/
 struct ahc_phase_table_entry*
 			ahc_lookup_phase_entry(int phase);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx.reg linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx.reg
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx.reg	2004-04-04 05:38:23.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx.reg	2004-05-13 16:42:17.000000000 +0200
@@ -39,7 +39,7 @@
  *
  * $FreeBSD$
  */
-VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#39 $"
+VERSION = "$Id$"
 
 /*
  * This file is processed by the aic7xxx_asm utility for use in assembling
@@ -1306,7 +1306,6 @@ scratch_ram {
 	 */
 	MWI_RESIDUAL {
 		size		1
-		alias	TARG_IMMEDIATE_SCB
 	}
 	/*
 	 * SCBID of the next SCB to be started by the controller.
@@ -1461,6 +1460,7 @@ scratch_ram {
 	 */
 	LAST_MSG {
 		size		1
+		alias	TARG_IMMEDIATE_SCB
 	}
 
 	/*
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx.seq linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx.seq
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx.seq	2004-04-04 05:37:42.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx.seq	2004-05-13 16:42:17.000000000 +0200
@@ -40,7 +40,7 @@
  * $FreeBSD$
  */
 
-VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#56 $"
+VERSION = "$Id$"
 PATCH_ARG_LIST = "struct ahc_softc *ahc"
 PREFIX = "ahc_"
 
@@ -679,6 +679,7 @@ await_busfree:
 		clr	SCSIBUSL;	/* Prevent bit leakage durint SELTO */
 	}
 	and	SXFRCTL0, ~SPIOEN;
+	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT;
 	test	SSTAT1,REQINIT|BUSFREE	jz .;
 	test	SSTAT1, BUSFREE jnz poll_for_work;
 	mvi	MISSED_BUSFREE call set_seqint;
@@ -1097,7 +1098,7 @@ ultra2_dmahalt:
 		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;
 		if ((ahc->flags & AHC_TARGETROLE) != 0) {
 			test	SSTAT0, TARGET jz dma_last_sg;
-			if ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0) {
+			if ((ahc->bugs & AHC_TMODE_WIDEODD_BUG) != 0) {
 				test	DMAPARAMS, DIRECTION jz dma_mid_sg;
 			}
 		}
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_93cx6.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_93cx6.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_93cx6.c	2004-04-04 05:38:21.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_93cx6.c	2004-05-13 16:42:17.000000000 +0200
@@ -28,9 +28,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#17 $
- *
- * $FreeBSD$
+ * $Id$
  */
 
 /*
@@ -64,7 +62,6 @@
  *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB
  *   first).  The clock cycling from low to high initiates the next data
  *   bit to be sent from the chip.
- *
  */
 
 #ifdef __linux__
@@ -72,6 +69,8 @@
 #include "aic7xxx_inline.h"
 #include "aic7xxx_93cx6.h"
 #else
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
 #include <dev/aic7xxx/aic7xxx_osm.h>
 #include <dev/aic7xxx/aic7xxx_inline.h>
 #include <dev/aic7xxx/aic7xxx_93cx6.h>
@@ -81,14 +80,22 @@
  * Right now, we only have to read the SEEPROM.  But we make it easier to
  * add other 93Cx6 functions.
  */
-static struct seeprom_cmd {
+struct seeprom_cmd {
   	uint8_t len;
- 	uint8_t bits[9];
-} seeprom_read = {3, {1, 1, 0}};
+ 	uint8_t bits[11];
+};
 
+/* Short opcodes for the c46 */
 static struct seeprom_cmd seeprom_ewen = {9, {1, 0, 0, 1, 1, 0, 0, 0, 0}};
 static struct seeprom_cmd seeprom_ewds = {9, {1, 0, 0, 0, 0, 0, 0, 0, 0}};
+
+/* Long opcodes for the C56/C66 */
+static struct seeprom_cmd seeprom_long_ewen = {11, {1, 0, 0, 1, 1, 0, 0, 0, 0}};
+static struct seeprom_cmd seeprom_long_ewds = {11, {1, 0, 0, 0, 0, 0, 0, 0, 0}};
+
+/* Common opcodes */
 static struct seeprom_cmd seeprom_write = {3, {1, 0, 1}};
+static struct seeprom_cmd seeprom_read  = {3, {1, 1, 0}};
 
 /*
  * Wait for the SEERDY to go high; about 800 ns.
@@ -222,12 +229,25 @@ int
 ahc_write_seeprom(struct seeprom_descriptor *sd, uint16_t *buf,
 		  u_int start_addr, u_int count)
 {
+	struct seeprom_cmd *ewen, *ewds;
 	uint16_t v;
 	uint8_t temp;
 	int i, k;
 
 	/* Place the chip into write-enable mode */
-	send_seeprom_cmd(sd, &seeprom_ewen);
+	if (sd->sd_chip == C46) {
+		ewen = &seeprom_ewen;
+		ewds = &seeprom_ewds;
+	} else if (sd->sd_chip == C56_66) {
+		ewen = &seeprom_long_ewen;
+		ewds = &seeprom_long_ewds;
+	} else {
+		printf("ahc_write_seeprom: unsupported seeprom type %d\n",
+		       sd->sd_chip);
+		return (0);
+	}
+
+	send_seeprom_cmd(sd, ewen);
 	reset_seeprom(sd);
 
 	/* Write all requested data out to the seeprom. */
@@ -277,7 +297,7 @@ ahc_write_seeprom(struct seeprom_descrip
 	}
 
 	/* Put the chip back into write-protect mode */
-	send_seeprom_cmd(sd, &seeprom_ewds);
+	send_seeprom_cmd(sd, ewds);
 	reset_seeprom(sd);
 
 	return (1);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_core.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_core.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_core.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_core.c	2004-05-13 16:42:17.000000000 +0200
@@ -37,9 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.c#134 $
- *
- * $FreeBSD$
+ * $Id$
  */
 
 #ifdef __linux__
@@ -47,6 +45,8 @@
 #include "aic7xxx_inline.h"
 #include "aicasm/aicasm_insformat.h"
 #else
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
 #include <dev/aic7xxx/aic7xxx_osm.h>
 #include <dev/aic7xxx/aic7xxx_inline.h>
 #include <dev/aic7xxx/aicasm/aicasm_insformat.h>
@@ -290,10 +290,19 @@ ahc_restart(struct ahc_softc *ahc)
 		ahc_outb(ahc, SEQ_FLAGS2,
 			 ahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);
 	}
+
+	/*
+	 * Clear any pending sequencer interrupt.  It is no
+	 * longer relevant since we're resetting the Program
+	 * Counter.
+	 */
+	ahc_outb(ahc, CLRINT, CLRSEQINT);
+
 	ahc_outb(ahc, MWI_RESIDUAL, 0);
 	ahc_outb(ahc, SEQCTL, ahc->seqctl);
 	ahc_outb(ahc, SEQADDR0, 0);
 	ahc_outb(ahc, SEQADDR1, 0);
+
 	ahc_unpause(ahc);
 }
 
@@ -320,7 +329,7 @@ ahc_run_qoutfifo(struct ahc_softc *ahc)
 			 */
 			modnext = ahc->qoutfifonext & ~0x3;
 			*((uint32_t *)(&ahc->qoutfifo[modnext])) = 0xFFFFFFFFUL;
-			ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
+			aic_dmamap_sync(ahc, ahc->shared_data_dmat,
 					ahc->shared_data_dmamap,
 					/*offset*/modnext, /*len*/4,
 					BUS_DMASYNC_PREREAD);
@@ -365,6 +374,7 @@ ahc_run_untagged_queue(struct ahc_softc 
 	if ((scb = TAILQ_FIRST(queue)) != NULL
 	 && (scb->flags & SCB_ACTIVE) == 0) {
 		scb->flags |= SCB_ACTIVE;
+		aic_scb_timer_start(scb);
 		ahc_queue_scb(ahc, scb);
 	}
 }
@@ -458,14 +468,14 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			 * complete.
 			 */
 			scb->flags &= ~SCB_SENSE;
-			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+			aic_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
 			break;
 		}
-		ahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
+		aic_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
 		/* Freeze the queue until the client sees the error. */
 		ahc_freeze_devq(ahc, scb);
-		ahc_freeze_scb(scb);
-		ahc_set_scsi_status(scb, hscb->shared_data.status.scsi_status);
+		aic_freeze_scb(scb);
+		aic_set_scsi_status(scb, hscb->shared_data.status.scsi_status);
 		switch (hscb->shared_data.status.scsi_status) {
 		case SCSI_STATUS_OK:
 			printf("%s: Interrupted for staus of 0???\n",
@@ -487,7 +497,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			}
 #endif
 
-			if (ahc_perform_autosense(scb) == 0)
+			if (aic_perform_autosense(scb) == 0)
 				break;
 
 			targ_info = ahc_fetch_transinfo(ahc,
@@ -509,12 +519,12 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			}
 #endif
 			sg->addr = ahc_get_sense_bufaddr(ahc, scb);
-			sg->len = ahc_get_sense_bufsize(ahc, scb);
+			sg->len = aic_get_sense_bufsize(ahc, scb);
 			sg->len |= AHC_DMA_LAST_SEG;
 
 			/* Fixup byte order */
-			sg->addr = ahc_htole32(sg->addr);
-			sg->len = ahc_htole32(sg->len);
+			sg->addr = aic_htole32(sg->addr);
+			sg->len = aic_htole32(sg->len);
 
 			sc->opcode = REQUEST_SENSE;
 			sc->byte2 = 0;
@@ -543,8 +553,8 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			 * errors will be reported before any data
 			 * phases occur.
 			 */
-			if (ahc_get_residual(scb) 
-			 == ahc_get_transfer_length(scb)) {
+			if (aic_get_residual(scb) 
+			 == aic_get_transfer_length(scb)) {
 				ahc_update_neg_request(ahc, &devinfo,
 						       tstate, targ_info,
 						       AHC_NEG_IF_NON_ASYNC);
@@ -558,7 +568,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			hscb->dataptr = sg->addr; 
 			hscb->datacnt = sg->len;
 			hscb->sgptr = scb->sg_list_phys | SG_FULL_RESID;
-			hscb->sgptr = ahc_htole32(hscb->sgptr);
+			hscb->sgptr = aic_htole32(hscb->sgptr);
 			scb->sg_count = 1;
 			scb->flags |= SCB_SENSE;
 			ahc_qinfifo_requeue_tail(ahc, scb);
@@ -567,7 +577,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			 * Ensure we have enough time to actually
 			 * retrieve the sense.
 			 */
-			ahc_scb_timer_reset(scb, 5 * 1000000);
+			aic_scb_timer_reset(scb, 5 * 1000000);
 			break;
 		}
 		default:
@@ -768,7 +778,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 					if ((ahc_inb(ahc, SCSISIGI)
 					  & (CDI|MSGI)) != 0)
 						break;
-					ahc_delay(100);
+					aic_delay(100);
 				}
 				ahc_outb(ahc, SXFRCTL1,
 					 ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
@@ -782,7 +792,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 					scb_index = ahc_inb(ahc, SCB_TAG);
 					scb = ahc_lookup_scb(ahc, scb_index);
 					if (scb != NULL)
-						ahc_set_transaction_status(scb,
+						aic_set_transaction_status(scb,
 						    CAM_UNCOR_PARITY);
 					ahc_reset_channel(ahc, devinfo.channel, 
 							  /*init reset*/TRUE);
@@ -820,16 +830,16 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 		ahc_print_path(ahc, scb);
 		printf("%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n",
 		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
-		       ahc_get_transfer_length(scb), scb->sg_count);
+		       aic_get_transfer_length(scb), scb->sg_count);
 		if (scb->sg_count > 0) {
 			for (i = 0; i < scb->sg_count; i++) {
 
 				printf("sg[%d] - Addr 0x%x%x : Length %d\n",
 				       i,
-				       (ahc_le32toh(scb->sg_list[i].len) >> 24
+				       (aic_le32toh(scb->sg_list[i].len) >> 24
 				        & SG_HIGH_ADDR_BITS),
-				       ahc_le32toh(scb->sg_list[i].addr),
-				       ahc_le32toh(scb->sg_list[i].len)
+				       aic_le32toh(scb->sg_list[i].addr),
+				       aic_le32toh(scb->sg_list[i].len)
 				       & AHC_SG_LEN_MASK);
 			}
 		}
@@ -839,12 +849,12 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 		 */
 		ahc_freeze_devq(ahc, scb);
 		if ((scb->flags & SCB_SENSE) == 0) {
-			ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+			aic_set_transaction_status(scb, CAM_DATA_RUN_ERR);
 		} else {
 			scb->flags &= ~SCB_SENSE;
-			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+			aic_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
 		}
-		ahc_freeze_scb(scb);
+		aic_freeze_scb(scb);
 
 		if ((ahc->features & AHC_ULTRA2) != 0) {
 			/*
@@ -1188,7 +1198,7 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 			 */
 			ahc_scb_devinfo(ahc, &devinfo, scb);
 			ahc_force_renegotiation(ahc, &devinfo);
-			ahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);
+			aic_set_transaction_status(scb, CAM_SEL_TIMEOUT);
 			ahc_freeze_devq(ahc, scb);
 		}
 		ahc_outb(ahc, CLRINT, CLRSCSIINT);
@@ -1270,7 +1280,7 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 						  CAM_LUN_WILDCARD,
 						  SCB_LIST_NULL,
 						  ROLE_INITIATOR)) {
-					ahc_set_transaction_status(scb, CAM_REQ_CMP);
+					aic_set_transaction_status(scb, CAM_REQ_CMP);
 				}
 #endif
 				ahc_compile_devinfo(&devinfo,
@@ -1482,7 +1492,7 @@ ahc_clear_critical_section(struct ahc_so
 		}
 		ahc_outb(ahc, HCNTRL, ahc->unpause);
 		while (!ahc_is_paused(ahc))
-			ahc_delay(200);
+			aic_delay(200);
 	}
 	if (stepping) {
 		ahc_outb(ahc, SIMODE0, simode0);
@@ -1530,18 +1540,18 @@ ahc_print_scb(struct scb *scb)
 	for (i = 0; i < sizeof(hscb->shared_data.cdb); i++)
 		printf("%#02x", hscb->shared_data.cdb[i]);
 	printf("        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x\n",
-		ahc_le32toh(hscb->dataptr),
-		ahc_le32toh(hscb->datacnt),
-		ahc_le32toh(hscb->sgptr),
+		aic_le32toh(hscb->dataptr),
+		aic_le32toh(hscb->datacnt),
+		aic_le32toh(hscb->sgptr),
 		hscb->tag);
 	if (scb->sg_count > 0) {
 		for (i = 0; i < scb->sg_count; i++) {
 			printf("sg[%d] - Addr 0x%x%x : Length %d\n",
 			       i,
-			       (ahc_le32toh(scb->sg_list[i].len) >> 24
+			       (aic_le32toh(scb->sg_list[i].len) >> 24
 			        & SG_HIGH_ADDR_BITS),
-			       ahc_le32toh(scb->sg_list[i].addr),
-			       ahc_le32toh(scb->sg_list[i].len));
+			       aic_le32toh(scb->sg_list[i].addr),
+			       aic_le32toh(scb->sg_list[i].len));
 		}
 	}
 }
@@ -2575,7 +2585,7 @@ ahc_handle_proto_violation(struct ahc_so
 		printf("No SCB found during protocol violation\n");
 		goto proto_violation_reset;
 	} else {
-		ahc_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
+		aic_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
 		if ((seq_flags & NO_CDB_SENT) != 0) {
 			ahc_print_path(ahc, scb);
 			printf("No or incomplete CDB sent to device.\n");
@@ -3513,7 +3523,7 @@ ahc_handle_msg_reject(struct ahc_softc *
 		ahc_outb(ahc, SCB_CONTROL,
 			 ahc_inb(ahc, SCB_CONTROL) & mask);
 	 	scb->hscb->control &= mask;
-		ahc_set_transaction_tag(scb, /*enabled*/FALSE,
+		aic_set_transaction_tag(scb, /*enabled*/FALSE,
 					/*type*/MSG_SIMPLE_TASK);
 		ahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);
 		ahc_assert_atn(ahc);
@@ -3570,7 +3580,7 @@ ahc_handle_ign_wide_residue(struct ahc_s
 	 * Perhaps add datadir to some spare bits in the hscb?
 	 */
 	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
-	 || ahc_get_transfer_dir(scb) != CAM_DIR_IN) {
+	 || aic_get_transfer_dir(scb) != CAM_DIR_IN) {
 		/*
 		 * Ignore the message if we haven't
 		 * seen an appropriate data phase yet.
@@ -3626,18 +3636,18 @@ ahc_handle_ign_wide_residue(struct ahc_s
 			 * to load so we must go back one.
 			 */
 			sg--;
-			sglen = ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
+			sglen = aic_le32toh(sg->len) & AHC_SG_LEN_MASK;
 			if (sg != scb->sg_list
 			 && sglen < (data_cnt & AHC_SG_LEN_MASK)) {
 
 				sg--;
-				sglen = ahc_le32toh(sg->len);
+				sglen = aic_le32toh(sg->len);
 				/*
 				 * Preserve High Address and SG_LIST bits
 				 * while setting the count to 1.
 				 */
 				data_cnt = 1 | (sglen & (~AHC_SG_LEN_MASK));
-				data_addr = ahc_le32toh(sg->addr)
+				data_addr = aic_le32toh(sg->addr)
 					  + (sglen & AHC_SG_LEN_MASK) - 1;
 
 				/*
@@ -3693,8 +3703,8 @@ ahc_reinitialize_dataptrs(struct ahc_sof
 	      | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 1) << 8)
 	      | ahc_inb(ahc, SCB_RESIDUAL_DATACNT);
 
-	dataptr = ahc_le32toh(sg->addr)
-		+ (ahc_le32toh(sg->len) & AHC_SG_LEN_MASK)
+	dataptr = aic_le32toh(sg->addr)
+		+ (aic_le32toh(sg->len) & AHC_SG_LEN_MASK)
 		- resid;
 	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
 		u_int dscommand1;
@@ -3702,7 +3712,7 @@ ahc_reinitialize_dataptrs(struct ahc_sof
 		dscommand1 = ahc_inb(ahc, DSCOMMAND1);
 		ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
 		ahc_outb(ahc, HADDR,
-			 (ahc_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);
+			 (aic_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);
 		ahc_outb(ahc, DSCOMMAND1, dscommand1);
 	}
 	ahc_outb(ahc, HADDR + 3, dataptr >> 24);
@@ -3883,7 +3893,7 @@ ahc_softc_insert(struct ahc_softc *ahc)
 {
 	struct ahc_softc *list_ahc;
 
-#if AHC_PCI_CONFIG > 0
+#if AIC_PCI_CONFIG > 0
 	/*
 	 * Second Function PCI devices need to inherit some
 	 * settings from function 0.
@@ -3891,17 +3901,17 @@ ahc_softc_insert(struct ahc_softc *ahc)
 	if ((ahc->chip & AHC_BUS_MASK) == AHC_PCI
 	 && (ahc->features & AHC_MULTI_FUNC) != 0) {
 		TAILQ_FOREACH(list_ahc, &ahc_tailq, links) {
-			ahc_dev_softc_t list_pci;
-			ahc_dev_softc_t pci;
+			aic_dev_softc_t list_pci;
+			aic_dev_softc_t pci;
 
 			list_pci = list_ahc->dev_softc;
 			pci = ahc->dev_softc;
-			if (ahc_get_pci_slot(list_pci) == ahc_get_pci_slot(pci)
-			 && ahc_get_pci_bus(list_pci) == ahc_get_pci_bus(pci)) {
+			if (aic_get_pci_slot(list_pci) == aic_get_pci_slot(pci)
+			 && aic_get_pci_bus(list_pci) == aic_get_pci_bus(pci)) {
 				struct ahc_softc *master;
 				struct ahc_softc *slave;
 
-				if (ahc_get_pci_function(list_pci) == 0) {
+				if (aic_get_pci_function(list_pci) == 0) {
 					master = list_ahc;
 					slave = ahc;
 				} else {
@@ -3969,27 +3979,27 @@ ahc_free(struct ahc_softc *ahc)
 {
 	int i;
 
+	ahc_terminate_recovery_thread(ahc);
 	switch (ahc->init_level) {
 	default:
 	case 5:
 		ahc_shutdown(ahc);
-		TAILQ_REMOVE(&ahc_tailq, ahc, links);
 		/* FALLTHROUGH */
 	case 4:
-		ahc_dmamap_unload(ahc, ahc->shared_data_dmat,
+		aic_dmamap_unload(ahc, ahc->shared_data_dmat,
 				  ahc->shared_data_dmamap);
 		/* FALLTHROUGH */
 	case 3:
-		ahc_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,
+		aic_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,
 				ahc->shared_data_dmamap);
-		ahc_dmamap_destroy(ahc, ahc->shared_data_dmat,
+		aic_dmamap_destroy(ahc, ahc->shared_data_dmat,
 				   ahc->shared_data_dmamap);
 		/* FALLTHROUGH */
 	case 2:
-		ahc_dma_tag_destroy(ahc, ahc->shared_data_dmat);
+		aic_dma_tag_destroy(ahc, ahc->shared_data_dmat);
 	case 1:
 #ifndef __linux__
-		ahc_dma_tag_destroy(ahc, ahc->buffer_dmat);
+		aic_dma_tag_destroy(ahc, ahc->buffer_dmat);
 #endif
 		break;
 	case 0:
@@ -3997,7 +4007,7 @@ ahc_free(struct ahc_softc *ahc)
 	}
 
 #ifndef __linux__
-	ahc_dma_tag_destroy(ahc, ahc->parent_dmat);
+	aic_dma_tag_destroy(ahc, ahc->parent_dmat);
 #endif
 	ahc_platform_free(ahc);
 	ahc_fini_scbdata(ahc);
@@ -4079,14 +4089,6 @@ ahc_reset(struct ahc_softc *ahc, int rei
 	 * to disturb the integrity of the bus.
 	 */
 	ahc_pause(ahc);
-	if ((ahc_inb(ahc, HCNTRL) & CHIPRST) != 0) {
-		/*
-		 * The chip has not been initialized since
-		 * PCI/EISA/VLB bus reset.  Don't trust
-		 * "left over BIOS data".
-		 */
-		ahc->flags |= AHC_NO_BIOS_INIT;
-	}
 	sxfrctl1_b = 0;
 	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {
 		u_int sblkctl;
@@ -4112,7 +4114,7 @@ ahc_reset(struct ahc_softc *ahc, int rei
 	 */
 	wait = 1000;
 	do {
-		ahc_delay(1000);
+		aic_delay(1000);
 	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));
 
 	if (wait == 0) {
@@ -4292,7 +4294,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	 */
 
 	/* DMA tag for our hardware scb structures */
-	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
+	if (aic_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -4307,7 +4309,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	scb_data->init_level++;
 
 	/* Allocation for our hscbs */
-	if (ahc_dmamem_alloc(ahc, scb_data->hscb_dmat,
+	if (aic_dmamem_alloc(ahc, scb_data->hscb_dmat,
 			     (void **)&scb_data->hscbs,
 			     BUS_DMA_NOWAIT, &scb_data->hscb_dmamap) != 0) {
 		goto error_exit;
@@ -4316,7 +4318,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	scb_data->init_level++;
 
 	/* And permanently map them */
-	ahc_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,
+	aic_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,
 			scb_data->hscbs,
 			AHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb),
 			ahc_dmamap_cb, &scb_data->hscb_busaddr, /*flags*/0);
@@ -4324,7 +4326,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	scb_data->init_level++;
 
 	/* DMA tag for our sense buffers */
-	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
+	if (aic_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -4339,7 +4341,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	scb_data->init_level++;
 
 	/* Allocate them */
-	if (ahc_dmamem_alloc(ahc, scb_data->sense_dmat,
+	if (aic_dmamem_alloc(ahc, scb_data->sense_dmat,
 			     (void **)&scb_data->sense,
 			     BUS_DMA_NOWAIT, &scb_data->sense_dmamap) != 0) {
 		goto error_exit;
@@ -4348,7 +4350,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	scb_data->init_level++;
 
 	/* And permanently map them */
-	ahc_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,
+	aic_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,
 			scb_data->sense,
 			AHC_SCB_MAX_ALLOC * sizeof(struct scsi_sense_data),
 			ahc_dmamap_cb, &scb_data->sense_busaddr, /*flags*/0);
@@ -4356,7 +4358,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	scb_data->init_level++;
 
 	/* DMA tag for our S/G structures.  We allocate in page sized chunks */
-	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/8,
+	if (aic_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/8,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -4413,35 +4415,35 @@ ahc_fini_scbdata(struct ahc_softc *ahc)
 
 		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
 			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
-			ahc_dmamap_unload(ahc, scb_data->sg_dmat,
+			aic_dmamap_unload(ahc, scb_data->sg_dmat,
 					  sg_map->sg_dmamap);
-			ahc_dmamem_free(ahc, scb_data->sg_dmat,
+			aic_dmamem_free(ahc, scb_data->sg_dmat,
 					sg_map->sg_vaddr,
 					sg_map->sg_dmamap);
 			free(sg_map, M_DEVBUF);
 		}
-		ahc_dma_tag_destroy(ahc, scb_data->sg_dmat);
+		aic_dma_tag_destroy(ahc, scb_data->sg_dmat);
 	}
 	case 6:
-		ahc_dmamap_unload(ahc, scb_data->sense_dmat,
+		aic_dmamap_unload(ahc, scb_data->sense_dmat,
 				  scb_data->sense_dmamap);
 	case 5:
-		ahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,
+		aic_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,
 				scb_data->sense_dmamap);
-		ahc_dmamap_destroy(ahc, scb_data->sense_dmat,
+		aic_dmamap_destroy(ahc, scb_data->sense_dmat,
 				   scb_data->sense_dmamap);
 	case 4:
-		ahc_dma_tag_destroy(ahc, scb_data->sense_dmat);
+		aic_dma_tag_destroy(ahc, scb_data->sense_dmat);
 	case 3:
-		ahc_dmamap_unload(ahc, scb_data->hscb_dmat,
+		aic_dmamap_unload(ahc, scb_data->hscb_dmat,
 				  scb_data->hscb_dmamap);
 	case 2:
-		ahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,
+		aic_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,
 				scb_data->hscb_dmamap);
-		ahc_dmamap_destroy(ahc, scb_data->hscb_dmat,
+		aic_dmamap_destroy(ahc, scb_data->hscb_dmat,
 				   scb_data->hscb_dmamap);
 	case 1:
-		ahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);
+		aic_dma_tag_destroy(ahc, scb_data->hscb_dmat);
 		break;
 	case 0:
 		break;
@@ -4474,7 +4476,7 @@ ahc_alloc_scbs(struct ahc_softc *ahc)
 		return;
 
 	/* Allocate S/G space for the next batch of SCBS */
-	if (ahc_dmamem_alloc(ahc, scb_data->sg_dmat,
+	if (aic_dmamem_alloc(ahc, scb_data->sg_dmat,
 			     (void **)&sg_map->sg_vaddr,
 			     BUS_DMA_NOWAIT, &sg_map->sg_dmamap) != 0) {
 		free(sg_map, M_DEVBUF);
@@ -4483,7 +4485,7 @@ ahc_alloc_scbs(struct ahc_softc *ahc)
 
 	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);
 
-	ahc_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,
+	aic_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,
 			sg_map->sg_vaddr, PAGE_SIZE, ahc_dmamap_cb,
 			&sg_map->sg_physaddr, /*flags*/0);
 
@@ -4510,9 +4512,9 @@ ahc_alloc_scbs(struct ahc_softc *ahc)
 		 */
 		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
 		next_scb->ahc_softc = ahc;
-		next_scb->flags = SCB_FREE;
+		next_scb->flags = SCB_FLAG_NONE;
 #ifndef __linux__
-		error = ahc_dmamap_create(ahc, ahc->buffer_dmat, /*flags*/0,
+		error = aic_dmamap_create(ahc, ahc->buffer_dmat, /*flags*/0,
 					  &next_scb->dmamap);
 		if (error != 0)
 			break;
@@ -4747,7 +4749,7 @@ ahc_chip_init(struct ahc_softc *ahc)
 		for (wait = 5000;
 		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
 		     wait--)
-			ahc_delay(100);
+			aic_delay(100);
 	}
 	ahc_restart(ahc);
 	return (0);
@@ -4760,6 +4762,7 @@ int
 ahc_init(struct ahc_softc *ahc)
 {
 	int	 max_targ;
+	int	 error;
 	u_int	 i;
 	u_int	 scsi_conf;
 	u_int	 ultraenb;
@@ -4817,7 +4820,7 @@ ahc_init(struct ahc_softc *ahc)
 
 #ifndef __linux__
 	/* DMA tag for mapping buffers into device visible space. */
-	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
+	if (aic_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/ahc->flags & AHC_39BIT_ADDRESSING
 					? (bus_addr_t)0x7FFFFFFFFFULL
@@ -4848,7 +4851,7 @@ ahc_init(struct ahc_softc *ahc)
 	if ((ahc->features & AHC_TARGETMODE) != 0)
 		driver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)
 				 + /*DMA WideOdd Bug Buffer*/1;
-	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
+	if (aic_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -4863,7 +4866,7 @@ ahc_init(struct ahc_softc *ahc)
 	ahc->init_level++;
 
 	/* Allocation of driver data */
-	if (ahc_dmamem_alloc(ahc, ahc->shared_data_dmat,
+	if (aic_dmamem_alloc(ahc, ahc->shared_data_dmat,
 			     (void **)&ahc->qoutfifo,
 			     BUS_DMA_NOWAIT, &ahc->shared_data_dmamap) != 0) {
 		return (ENOMEM);
@@ -4872,7 +4875,7 @@ ahc_init(struct ahc_softc *ahc)
 	ahc->init_level++;
 
 	/* And permanently map it in */
-	ahc_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
+	aic_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
 			ahc->qoutfifo, driver_data_size, ahc_dmamap_cb,
 			&ahc->shared_data_busaddr, /*flags*/0);
 
@@ -4915,6 +4918,13 @@ ahc_init(struct ahc_softc *ahc)
 		}
 	}
 
+	/*
+	 * Fire up a recovery thread for this controller.
+	 */
+	error = ahc_spawn_recovery_thread(ahc);
+	if (error != 0)
+		return (error);
+
 	if (ahc->scb_data->maxhscbs < AHC_SCB_MAX_ALLOC) {
 		ahc->flags |= AHC_PAGESCBS;
 	} else {
@@ -5112,14 +5122,23 @@ ahc_pause_and_flushwork(struct ahc_softc
 	ahc->flags |= AHC_ALL_INTERRUPTS;
 	paused = FALSE;
 	do {
-		if (paused)
+		if (paused) {
 			ahc_unpause(ahc);
+			/*
+			 * Give the sequencer some time to service
+			 * any active selections.
+			 */
+			aic_delay(500);
+		}
 		ahc_intr(ahc);
 		ahc_pause(ahc);
 		paused = TRUE;
 		ahc_outb(ahc, SCSISEQ, ahc_inb(ahc, SCSISEQ) & ~ENSELO);
-		ahc_clear_critical_section(ahc);
 		intstat = ahc_inb(ahc, INTSTAT);
+		if ((intstat & INT_PEND) == 0) {
+			ahc_clear_critical_section(ahc);
+			intstat = ahc_inb(ahc, INTSTAT);
+		}
 	} while (--maxloops
 	      && (intstat != 0xFF || (ahc->features & AHC_REMOVABLE) == 0)
 	      && ((intstat & INT_PEND) != 0
@@ -5399,12 +5418,12 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 				cam_status ostat;
 				cam_status cstat;
 
-				ostat = ahc_get_transaction_status(scb);
+				ostat = aic_get_transaction_status(scb);
 				if (ostat == CAM_REQ_INPROG)
-					ahc_set_transaction_status(scb, status);
-				cstat = ahc_get_transaction_status(scb);
+					aic_set_transaction_status(scb, status);
+				cstat = aic_get_transaction_status(scb);
 				if (cstat != CAM_REQ_CMP)
-					ahc_freeze_scb(scb);
+					aic_freeze_scb(scb);
 				if ((scb->flags & SCB_ACTIVE) == 0)
 					printf("Inactive SCB in qinfifo\n");
 				ahc_done(ahc, scb);
@@ -5511,15 +5530,15 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 				cam_status ostat;
 				cam_status cstat;
 
-				ostat = ahc_get_transaction_status(scb);
+				ostat = aic_get_transaction_status(scb);
 				if (ostat == CAM_REQ_INPROG)
-					ahc_set_transaction_status(scb,
+					aic_set_transaction_status(scb,
 								   status);
-				cstat = ahc_get_transaction_status(scb);
+				cstat = aic_get_transaction_status(scb);
 				if (cstat != CAM_REQ_CMP)
-					ahc_freeze_scb(scb);
+					aic_freeze_scb(scb);
 				if ((scb->flags & SCB_ACTIVE) == 0)
-					printf("Inactive SCB in Waiting List\n");
+					printf("Inactive SCB in Wait List\n");
 				ahc_done(ahc, scb);
 				/* FALLTHROUGH */
 			}
@@ -5539,7 +5558,7 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 	}
 	ahc_outb(ahc, SCBPTR, curscbptr);
 
-	found += ahc_search_untagged_queues(ahc, /*ahc_io_ctx_t*/NULL, target,
+	found += ahc_search_untagged_queues(ahc, /*aic_io_ctx_t*/NULL, target,
 					    channel, lun, status, action);
 
 	if (action == SEARCH_COMPLETE)
@@ -5548,7 +5567,7 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 }
 
 int
-ahc_search_untagged_queues(struct ahc_softc *ahc, ahc_io_ctx_t ctx,
+ahc_search_untagged_queues(struct ahc_softc *ahc, aic_io_ctx_t ctx,
 			   int target, char channel, int lun, uint32_t status,
 			   ahc_search_action action)
 {
@@ -5619,14 +5638,12 @@ ahc_search_untagged_queues(struct ahc_so
 				cam_status ostat;
 				cam_status cstat;
 
-				ostat = ahc_get_transaction_status(scb);
+				ostat = aic_get_transaction_status(scb);
 				if (ostat == CAM_REQ_INPROG)
-					ahc_set_transaction_status(scb, status);
-				cstat = ahc_get_transaction_status(scb);
+					aic_set_transaction_status(scb, status);
+				cstat = aic_get_transaction_status(scb);
 				if (cstat != CAM_REQ_CMP)
-					ahc_freeze_scb(scb);
-				if ((scb->flags & SCB_ACTIVE) == 0)
-					printf("Inactive SCB in untaggedQ\n");
+					aic_freeze_scb(scb);
 				ahc_done(ahc, scb);
 				break;
 			}
@@ -5923,11 +5940,11 @@ ahc_abort_scbs(struct ahc_softc *ahc, in
 		if (ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)) {
 			cam_status ostat;
 
-			ostat = ahc_get_transaction_status(scbp);
+			ostat = aic_get_transaction_status(scbp);
 			if (ostat == CAM_REQ_INPROG)
-				ahc_set_transaction_status(scbp, status);
-			if (ahc_get_transaction_status(scbp) != CAM_REQ_CMP)
-				ahc_freeze_scb(scbp);
+				aic_set_transaction_status(scbp, status);
+			if (aic_get_transaction_status(scbp) != CAM_REQ_CMP)
+				aic_freeze_scb(scbp);
 			if ((scbp->flags & SCB_ACTIVE) == 0)
 				printf("Inactive SCB on pending list\n");
 			ahc_done(ahc, scbp);
@@ -5949,7 +5966,7 @@ ahc_reset_current_bus(struct ahc_softc *
 	scsiseq = ahc_inb(ahc, SCSISEQ);
 	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
 	ahc_flush_device_writes(ahc);
-	ahc_delay(AHC_BUSRESET_DELAY);
+	aic_delay(AHC_BUSRESET_DELAY);
 	/* Turn off the bus reset */
 	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);
 
@@ -6156,7 +6173,7 @@ ahc_calc_residual(struct ahc_softc *ahc,
 	 */
 
 	hscb = scb->hscb;
-	sgptr = ahc_le32toh(hscb->sgptr);
+	sgptr = aic_le32toh(hscb->sgptr);
 	if ((sgptr & SG_RESID_VALID) == 0)
 		/* Case 1 */
 		return;
@@ -6167,10 +6184,10 @@ ahc_calc_residual(struct ahc_softc *ahc,
 		return;
 
 	spkt = &hscb->shared_data.status;
-	resid_sgptr = ahc_le32toh(spkt->residual_sg_ptr);
+	resid_sgptr = aic_le32toh(spkt->residual_sg_ptr);
 	if ((sgptr & SG_FULL_RESID) != 0) {
 		/* Case 3 */
-		resid = ahc_get_transfer_length(scb);
+		resid = aic_get_transfer_length(scb);
 	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
 		/* Case 4 */
 		return;
@@ -6183,7 +6200,7 @@ ahc_calc_residual(struct ahc_softc *ahc,
 		 * Remainder of the SG where the transfer
 		 * stopped.  
 		 */
-		resid = ahc_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;
+		resid = aic_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;
 		sg = ahc_sg_bus_to_virt(scb, resid_sgptr & SG_PTR_MASK);
 
 		/* The residual sg_ptr always points to the next sg */
@@ -6194,15 +6211,15 @@ ahc_calc_residual(struct ahc_softc *ahc,
 		 * SG segments that are after the SG where
 		 * the transfer stopped.
 		 */
-		while ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
+		while ((aic_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
 			sg++;
-			resid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
+			resid += aic_le32toh(sg->len) & AHC_SG_LEN_MASK;
 		}
 	}
 	if ((scb->flags & SCB_SENSE) == 0)
-		ahc_set_residual(scb, resid);
+		aic_set_residual(scb, resid);
 	else
-		ahc_set_sense_residual(scb, resid);
+		aic_set_sense_residual(scb, resid);
 
 #ifdef AHC_DEBUG
 	if ((ahc_debug & AHC_SHOW_MISC) != 0) {
@@ -6482,7 +6499,7 @@ ahc_download_instr(struct ahc_softc *ahc
 	/*
 	 * The firmware is always compiled into a little endian format.
 	 */
-	instr.integer = ahc_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
+	instr.integer = aic_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
 
 	fmt1_ins = &instr.format1;
 	fmt3_ins = NULL;
@@ -6587,7 +6604,7 @@ ahc_download_instr(struct ahc_softc *ahc
 			}
 		}
 		/* The sequencer is a little endian cpu */
-		instr.integer = ahc_htole32(instr.integer);
+		instr.integer = aic_htole32(instr.integer);
 		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
 		break;
 	default:
@@ -6827,6 +6844,324 @@ ahc_dump_card_state(struct ahc_softc *ah
 		ahc_unpause(ahc);
 }
 
+/*************************** Timeout Handling *********************************/
+void
+ahc_timeout(struct scb *scb)
+{
+	struct ahc_softc *ahc;
+
+	ahc = scb->ahc_softc;
+	if ((scb->flags & SCB_ACTIVE) != 0) {
+		if ((scb->flags & SCB_TIMEDOUT) == 0) {
+			LIST_INSERT_HEAD(&ahc->timedout_scbs, scb,
+					 timedout_links);
+			scb->flags |= SCB_TIMEDOUT;
+		}
+		ahc_wakeup_recovery_thread(ahc);
+	}
+}
+
+/*
+ * ahc_recover_commands determines if any of the commands that have currently
+ * timedout are the root cause for this timeout.  Innocent commands are given
+ * a new timeout while we wait for the command executing on the bus to timeout.
+ * This routine is invoked from a thread context so we are allowed to sleep.
+ * Our lock is not held on entry.
+ */
+void
+ahc_recover_commands(struct ahc_softc *ahc)
+{
+	struct	scb *scb;
+	long	s;
+	int	found;
+	int	restart_needed;
+	u_int	last_phase;
+
+	ahc_lock(ahc, &s);
+
+	/*
+	 * Pause the controller and manually flush any
+	 * commands that have just completed but that our
+	 * interrupt handler has yet to see.
+	 */
+	ahc_pause_and_flushwork(ahc);
+
+	if (LIST_EMPTY(&ahc->timedout_scbs) != 0) {
+		/*
+		 * The timedout commands have already
+		 * completed.  This typically means
+		 * that either the timeout value was on
+		 * the hairy edge of what the device
+		 * requires or - more likely - interrupts
+		 * are not happening.
+		 */
+		printf("%s: Timedout SCBs already complete. "
+		       "Interrupts may not be functioning.\n", ahc_name(ahc));
+		ahc_unpause(ahc);
+		ahc_unlock(ahc, &s);
+		return;
+	}
+
+	restart_needed = 0;
+	printf("%s: Recovery Initiated\n", ahc_name(ahc));
+	ahc_dump_card_state(ahc);
+
+	last_phase = ahc_inb(ahc, LASTPHASE);
+	while ((scb = LIST_FIRST(&ahc->timedout_scbs)) != NULL) {
+		u_int	active_scb_index;
+		u_int	saved_scbptr;
+		int	target;
+		int	lun;
+		int	i;
+		char	channel;
+
+		target = SCB_GET_TARGET(ahc, scb);
+		channel = SCB_GET_CHANNEL(ahc, scb);
+		lun = SCB_GET_LUN(scb);
+
+		ahc_print_path(ahc, scb);
+		printf("SCB 0x%x - timed out\n", scb->hscb->tag);
+		if (scb->sg_count > 0) {
+			for (i = 0; i < scb->sg_count; i++) {
+				printf("sg[%d] - Addr 0x%x : Length %d\n",
+				       i,
+				       scb->sg_list[i].addr,
+				       scb->sg_list[i].len & AHC_SG_LEN_MASK);
+			}
+		}
+		if (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {
+			/*
+			 * Been down this road before.
+			 * Do a full bus reset.
+			 */
+			aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+bus_reset:
+			found = ahc_reset_channel(ahc, channel,
+						  /*Initiate Reset*/TRUE);
+			printf("%s: Issued Channel %c Bus Reset. "
+			       "%d SCBs aborted\n", ahc_name(ahc), channel,
+			       found);
+			continue;
+		}
+
+		/*
+		 * Remove the command from the timedout list in
+		 * preparation for requeing it.
+		 */
+		LIST_REMOVE(scb, timedout_links);
+		scb->flags &= ~SCB_TIMEDOUT;
+
+		/*
+		 * If we are a target, transition to bus free and report
+		 * the timeout.
+		 * 
+		 * The target/initiator that is holding up the bus may not
+		 * be the same as the one that triggered this timeout
+		 * (different commands have different timeout lengths).
+		 * If the bus is idle and we are actiing as the initiator
+		 * for this request, queue a BDR message to the timed out
+		 * target.  Otherwise, if the timed out transaction is
+		 * active:
+		 *   Initiator transaction:
+		 *	Stuff the message buffer with a BDR message and assert
+		 *	ATN in the hopes that the target will let go of the bus
+		 *	and go to the mesgout phase.  If this fails, we'll
+		 *	get another timeout 2 seconds later which will attempt
+		 *	a bus reset.
+		 *
+		 *   Target transaction:
+		 *	Transition to BUS FREE and report the error.
+		 *	It's good to be the target!
+		 */
+		saved_scbptr = ahc_inb(ahc, SCBPTR);
+		active_scb_index = ahc_inb(ahc, SCB_TAG);
+
+		if ((ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) == 0
+		  && (active_scb_index < ahc->scb_data->numscbs)) {
+			struct scb *active_scb;
+
+			/*
+			 * If the active SCB is not us, assume that
+			 * the active SCB has a longer timeout than
+			 * the timedout SCB, and wait for the active
+			 * SCB to timeout.
+			 */ 
+			active_scb = ahc_lookup_scb(ahc, active_scb_index);
+			if (active_scb != scb) {
+				u_int	newtimeout;
+
+				ahc_print_path(ahc, scb);
+				printf("Other SCB Timeout%s",
+			 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
+				       ? " again\n" : "\n");
+				scb->flags |= SCB_OTHERTCL_TIMEOUT;
+				newtimeout =
+				    MAX(aic_get_timeout(active_scb),
+					aic_get_timeout(scb));
+				aic_scb_timer_reset(scb, newtimeout);
+				continue;
+			} 
+
+			/* It's us */
+			if ((scb->flags & SCB_TARGET_SCB) != 0) {
+
+				/*
+				 * Send back any queued up transactions
+				 * and properly record the error condition.
+				 */
+				ahc_abort_scbs(ahc, SCB_GET_TARGET(ahc, scb),
+					       SCB_GET_CHANNEL(ahc, scb),
+					       SCB_GET_LUN(scb),
+					       scb->hscb->tag,
+					       ROLE_TARGET,
+					       CAM_CMD_TIMEOUT);
+
+				/* Will clear us from the bus */
+				restart_needed = 1;
+				break;
+			}
+
+			ahc_set_recoveryscb(ahc, active_scb);
+			ahc_outb(ahc, MSG_OUT, HOST_MSG);
+			ahc_outb(ahc, SCSISIGO, last_phase|ATNO);
+			ahc_print_path(ahc, active_scb);
+			printf("BDR message in message buffer\n");
+			active_scb->flags |= SCB_DEVICE_RESET;
+			aic_scb_timer_reset(scb, 2 * 1000000);
+		} else if (last_phase != P_BUSFREE
+			&& (ahc_inb(ahc, SSTAT1) & REQINIT) == 0) {
+			/*
+			 * SCB is not identified, there
+			 * is no pending REQ, and the sequencer
+			 * has not seen a busfree.  Looks like
+			 * a stuck connection waiting to
+			 * go busfree.  Reset the bus.
+			 */
+			printf("%s: Connection stuck awaiting busfree or "
+			       "Identify Msg.\n", ahc_name(ahc));
+			goto bus_reset;
+		} else {
+			int	 disconnected;
+
+			if (last_phase != P_BUSFREE
+			 && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {
+				/* Hung target selection.  Goto busfree */
+				printf("%s: Hung target selection\n",
+				       ahc_name(ahc));
+				restart_needed = 1;
+				break;
+			}
+
+			/* XXX Shouldn't panic.  Just punt instead? */
+			if ((scb->flags & SCB_TARGET_SCB) != 0)
+				panic("Timed-out target SCB but bus idle");
+
+			if (ahc_search_qinfifo(ahc, target, channel, lun,
+					       scb->hscb->tag, ROLE_INITIATOR,
+					       /*status*/0, SEARCH_COUNT) > 0) {
+				disconnected = FALSE;
+			} else {
+				disconnected = TRUE;
+			}
+
+			if (disconnected) {
+
+				ahc_set_recoveryscb(ahc, scb);
+				/*
+				 * Actually re-queue this SCB in an attempt
+				 * to select the device before it reconnects.
+				 * In either case (selection or reselection),
+				 * we will now issue a target reset to the
+				 * timed-out device.
+				 *
+				 * Set the MK_MESSAGE control bit indicating
+				 * that we desire to send a message.  We
+				 * also set the disconnected flag since
+				 * in the paging case there is no guarantee
+				 * that our SCB control byte matches the
+				 * version on the card.  We don't want the
+				 * sequencer to abort the command thinking
+				 * an unsolicited reselection occurred.
+				 */
+				scb->hscb->control |= MK_MESSAGE|DISCONNECTED;
+				scb->flags |= SCB_DEVICE_RESET;
+
+				/*
+				 * Remove any cached copy of this SCB in the
+				 * disconnected list in preparation for the
+				 * queuing of our abort SCB.  We use the
+				 * same element in the SCB, SCB_NEXT, for
+				 * both the qinfifo and the disconnected list.
+				 */
+				ahc_search_disc_list(ahc, target, channel,
+						     lun, scb->hscb->tag,
+						     /*stop_on_first*/TRUE,
+						     /*remove*/TRUE,
+						     /*save_state*/FALSE);
+
+				/*
+				 * In the non-paging case, the sequencer will
+				 * never re-reference the in-core SCB.
+				 * To make sure we are notified during
+				 * reslection, set the MK_MESSAGE flag in
+				 * the card's copy of the SCB.
+				 */
+				if ((ahc->flags & AHC_PAGESCBS) == 0) {
+					ahc_outb(ahc, SCBPTR, scb->hscb->tag);
+					ahc_outb(ahc, SCB_CONTROL,
+						 ahc_inb(ahc, SCB_CONTROL)
+						| MK_MESSAGE);
+				}
+
+				/*
+				 * Clear out any entries in the QINFIFO first
+				 * so we are the next SCB for this target
+				 * to run.
+				 */
+				ahc_search_qinfifo(ahc,
+						   SCB_GET_TARGET(ahc, scb),
+						   channel, SCB_GET_LUN(scb),
+						   SCB_LIST_NULL,
+						   ROLE_INITIATOR,
+						   CAM_REQUEUE_REQ,
+						   SEARCH_COMPLETE);
+				ahc_print_path(ahc, scb);
+				printf("Queuing a BDR SCB\n");
+				ahc_qinfifo_requeue_tail(ahc, scb);
+				ahc_outb(ahc, SCBPTR, saved_scbptr);
+				aic_scb_timer_reset(scb, 2 * 1000000);
+			} else {
+				/* Go "immediatly" to the bus reset */
+				/* This shouldn't happen */
+				ahc_set_recoveryscb(ahc, scb);
+				ahc_print_path(ahc, scb);
+				printf("SCB %d: Immediate reset.  "
+					"Flags = 0x%x\n", scb->hscb->tag,
+					scb->flags);
+				goto bus_reset;
+			}
+		}
+		break;
+	}
+	
+	/*
+	 * Any remaining SCBs were not the "culprit", so remove
+	 * them from the timeout list.  The timer for these commands
+	 * will be reset once the recovery SCB completes.
+	 */
+	while ((scb = LIST_FIRST(&ahc->timedout_scbs)) != NULL) {
+
+		LIST_REMOVE(scb, timedout_links);
+		scb->flags &= ~SCB_TIMEDOUT;
+	}
+
+	if (restart_needed)
+		ahc_restart(ahc);
+	else
+		ahc_unpause(ahc);
+	ahc_unlock(ahc, &s);
+}
+
 /************************* Target Mode ****************************************/
 #ifdef AHC_TARGET_MODE
 cam_status
@@ -7305,7 +7640,7 @@ ahc_run_tqinfifo(struct ahc_softc *ahc, 
 			break;
 
 		cmd->cmd_valid = 0;
-		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
+		aic_dmamap_sync(ahc, ahc->shared_data_dmat,
 				ahc->shared_data_dmamap,
 				ahc_targetcmd_offset(ahc, ahc->tqinfifonext),
 				sizeof(struct target_cmd),
@@ -7442,7 +7777,7 @@ ahc_handle_target_cmd(struct ahc_softc *
 		       initiator, target, lun, ahc->pending_device);
 #endif
 		ahc->pending_device = lstate;
-		ahc_freeze_ccb((union ccb *)atio);
+		aic_freeze_ccb((union ccb *)atio);
 		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
 	}
 	xpt_done((union ccb*)atio);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_inline.h linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_inline.h
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_inline.h	2004-04-04 05:38:26.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_inline.h	2004-05-13 16:42:17.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#43 $
+ * $Id$
  *
  * $FreeBSD$
  */
@@ -196,7 +196,7 @@ ahc_hscb_busaddr(struct ahc_softc *ahc, 
 static __inline void
 ahc_sync_scb(struct ahc_softc *ahc, struct scb *scb, int op)
 {
-	ahc_dmamap_sync(ahc, ahc->scb_data->hscb_dmat,
+	aic_dmamap_sync(ahc, ahc->scb_data->hscb_dmat,
 			ahc->scb_data->hscb_dmamap,
 			/*offset*/(scb->hscb - ahc->hscbs) * sizeof(*scb->hscb),
 			/*len*/sizeof(*scb->hscb), op);
@@ -208,7 +208,7 @@ ahc_sync_sglist(struct ahc_softc *ahc, s
 	if (scb->sg_count == 0)
 		return;
 
-	ahc_dmamap_sync(ahc, ahc->scb_data->sg_dmat, scb->sg_map->sg_dmamap,
+	aic_dmamap_sync(ahc, ahc->scb_data->sg_dmat, scb->sg_map->sg_dmamap,
 			/*offset*/(scb->sg_list - scb->sg_map->sg_vaddr)
 				* sizeof(struct ahc_dma_seg),
 			/*len*/sizeof(struct ahc_dma_seg) * scb->sg_count, op);
@@ -272,7 +272,7 @@ ahc_update_residual(struct ahc_softc *ah
 {
 	uint32_t sgptr;
 
-	sgptr = ahc_le32toh(scb->hscb->sgptr);
+	sgptr = aic_le32toh(scb->hscb->sgptr);
 	if ((sgptr & SG_RESID_VALID) != 0)
 		ahc_calc_residual(ahc, scb);
 }
@@ -383,13 +383,13 @@ ahc_free_scb(struct ahc_softc *ahc, stru
 	hscb = scb->hscb;
 	/* Clean up for the next user */
 	ahc->scb_data->scbindex[hscb->tag] = NULL;
-	scb->flags = SCB_FREE;
+	scb->flags = SCB_FLAG_NONE;
 	hscb->control = 0;
 
 	SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links.sle);
 
 	/* Notify the OSM that a resource is now available. */
-	ahc_platform_scb_free(ahc, scb);
+	aic_platform_scb_free(ahc, scb);
 }
 
 static __inline struct scb *
@@ -427,7 +427,7 @@ ahc_swap_with_next_hscb(struct ahc_softc
 	memcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));
 	if ((scb->flags & SCB_CDB32_PTR) != 0) {
 		q_hscb->shared_data.cdb_ptr =
-		    ahc_htole32(ahc_hscb_busaddr(ahc, q_hscb->tag)
+		    aic_htole32(ahc_hscb_busaddr(ahc, q_hscb->tag)
 			      + offsetof(struct hardware_scb, cdb32));
 	}
 	q_hscb->tag = saved_tag;
@@ -458,7 +458,7 @@ ahc_queue_scb(struct ahc_softc *ahc, str
 	 * Setup data "oddness".
 	 */
 	scb->hscb->lun &= LID;
-	if (ahc_get_transfer_length(scb) & 0x1)
+	if (aic_get_transfer_length(scb) & 0x1)
 		scb->hscb->lun |= SCB_XFERLEN_ODD;
 
 	/*
@@ -512,7 +512,7 @@ static __inline int	ahc_intr(struct ahc_
 static __inline void
 ahc_sync_qoutfifo(struct ahc_softc *ahc, int op)
 {
-	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
+	aic_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
 			/*offset*/0, /*len*/256, op);
 }
 
@@ -521,7 +521,7 @@ ahc_sync_tqinfifo(struct ahc_softc *ahc,
 {
 #ifdef AHC_TARGET_MODE
 	if ((ahc->flags & AHC_TARGETROLE) != 0) {
-		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
+		aic_dmamap_sync(ahc, ahc->shared_data_dmat,
 				ahc->shared_data_dmamap,
 				ahc_targetcmd_offset(ahc, 0),
 				sizeof(struct target_cmd) * AHC_TMODE_CMDS,
@@ -542,7 +542,7 @@ ahc_check_cmdcmpltqueues(struct ahc_soft
 	u_int retval;
 
 	retval = 0;
-	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
+	aic_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
 			/*offset*/ahc->qoutfifonext, /*len*/1,
 			BUS_DMASYNC_POSTREAD);
 	if (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL)
@@ -550,7 +550,7 @@ ahc_check_cmdcmpltqueues(struct ahc_soft
 #ifdef AHC_TARGET_MODE
 	if ((ahc->flags & AHC_TARGETROLE) != 0
 	 && (ahc->flags & AHC_TQINFIFO_BLOCKED) == 0) {
-		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
+		aic_dmamap_sync(ahc, ahc->shared_data_dmat,
 				ahc->shared_data_dmamap,
 				ahc_targetcmd_offset(ahc, ahc->tqinfifofnext),
 				/*len*/sizeof(struct target_cmd),
@@ -593,7 +593,7 @@ ahc_intr(struct ahc_softc *ahc)
 	}
 
 	if ((intstat & INT_PEND) == 0) {
-#if AHC_PCI_CONFIG > 0
+#if AIC_PCI_CONFIG > 0
 		if (ahc->unsolicited_ints > 500) {
 			ahc->unsolicited_ints = 0;
 			if ((ahc->chip & AHC_PCI) != 0
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_osm.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_osm.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_osm.c	2004-04-04 05:36:17.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_osm.c	2004-05-13 16:42:17.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * Adaptec AIC7xxx device driver for Linux.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#235 $
+ * $Id$
  *
  * Copyright (c) 1994 John Aycock
  *   The University of Calgary Department of Computer Science.
@@ -129,9 +129,7 @@
  */
 #include "aiclib.c"
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
 #include <linux/init.h>		/* __setup */
-#endif
 
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
@@ -139,7 +137,22 @@
 #endif
 
 #include <linux/mm.h>		/* For fetching system memory size */
-#include <linux/blkdev.h>		/* For block_size() */
+
+/************************* Magic SysReq Support *******************************/
+static struct aic_sysrq_key_op ahc_sysrq_op =
+{
+	aic_sysrq_handler,
+	"aic7xxxstatedump",
+	"Dump aic7xxx controller information to Console"
+};
+
+static int ahc_sysrq_key;
+
+/***************************** Global Data ************************************/
+/*
+ * Driver Initialization Status.  Used by ahc_linux_exit().
+ */
+int ahc_init_status;
 
 /*
  * Lock protecting manipulation of the ahc softc list.
@@ -151,14 +164,6 @@ spinlock_t ahc_list_spinlock;
 u_int ahc_linux_nseg;
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-struct proc_dir_entry proc_scsi_aic7xxx = {
-	PROC_SCSI_AIC7XXX, 7, "aic7xxx",
-	S_IFDIR | S_IRUGO | S_IXUGO, 2,
-	0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
-};
-#endif
-
 /*
  * Set this to the delay in seconds after SCSI bus reset.
  * Note, we honor this only for the initial bus reset.
@@ -472,7 +477,7 @@ MODULE_PARM_DESC(aic7xxx,
 "	seltime:<int>		Selection Timeout\n"
 "				(0/256ms,1/128ms,2/64ms,3/32ms)\n"
 "\n"
-"	Sample /etc/modprobe.conf line:\n"
+"	Sample module configuration line:\n"
 "		Toggle EISA/VLB probing\n"
 "		Set tag depth on Controller 1/Target 1 to 10 tags\n"
 "		Shorten the selection timeout to 128ms\n"
@@ -482,35 +487,35 @@ MODULE_PARM_DESC(aic7xxx,
 #endif
 
 static void ahc_linux_handle_scsi_status(struct ahc_softc *,
-					 struct ahc_linux_device *,
+					 struct aic_linux_device *,
 					 struct scb *);
 static void ahc_linux_queue_cmd_complete(struct ahc_softc *ahc,
 					 Scsi_Cmnd *cmd);
 static void ahc_linux_filter_inquiry(struct ahc_softc*, struct ahc_devinfo*);
 static void ahc_linux_sem_timeout(u_long arg);
-static void ahc_linux_freeze_simq(struct ahc_softc *ahc);
-static void ahc_linux_release_simq(u_long arg);
 static void ahc_linux_dev_timed_unfreeze(u_long arg);
+static void ahc_linux_targ_timed_unfreeze(u_long arg);
+static int __init ahc_linux_init(void);
+static void ahc_linux_exit(void);
 static int  ahc_linux_queue_recovery_cmd(Scsi_Cmnd *cmd, scb_flag flag);
 static void ahc_linux_initialize_scsi_bus(struct ahc_softc *ahc);
 static void ahc_linux_size_nseg(void);
 static void ahc_linux_thread_run_complete_queue(struct ahc_softc *ahc);
 static void ahc_linux_start_dv(struct ahc_softc *ahc);
-static void ahc_linux_dv_timeout(struct scsi_cmnd *cmd);
 static int  ahc_linux_dv_thread(void *data);
 static void ahc_linux_kill_dv_thread(struct ahc_softc *ahc);
 static void ahc_linux_dv_target(struct ahc_softc *ahc, u_int target);
 static void ahc_linux_dv_transition(struct ahc_softc *ahc,
 				    struct scsi_cmnd *cmd,
 				    struct ahc_devinfo *devinfo,
-				    struct ahc_linux_target *targ);
+				    struct aic_linux_target *targ);
 static void ahc_linux_dv_fill_cmd(struct ahc_softc *ahc,
 				  struct scsi_cmnd *cmd,
 				  struct ahc_devinfo *devinfo);
 static void ahc_linux_dv_inq(struct ahc_softc *ahc,
 			     struct scsi_cmnd *cmd,
 			     struct ahc_devinfo *devinfo,
-			     struct ahc_linux_target *targ,
+			     struct aic_linux_target *targ,
 			     u_int request_length);
 static void ahc_linux_dv_tur(struct ahc_softc *ahc,
 			     struct scsi_cmnd *cmd,
@@ -518,58 +523,48 @@ static void ahc_linux_dv_tur(struct ahc_
 static void ahc_linux_dv_rebd(struct ahc_softc *ahc,
 			      struct scsi_cmnd *cmd,
 			      struct ahc_devinfo *devinfo,
-			      struct ahc_linux_target *targ);
+			      struct aic_linux_target *targ);
 static void ahc_linux_dv_web(struct ahc_softc *ahc,
 			     struct scsi_cmnd *cmd,
 			     struct ahc_devinfo *devinfo,
-			     struct ahc_linux_target *targ);
+			     struct aic_linux_target *targ);
 static void ahc_linux_dv_reb(struct ahc_softc *ahc,
 			     struct scsi_cmnd *cmd,
 			     struct ahc_devinfo *devinfo,
-			     struct ahc_linux_target *targ);
+			     struct aic_linux_target *targ);
 static void ahc_linux_dv_su(struct ahc_softc *ahc,
 			    struct scsi_cmnd *cmd,
 			    struct ahc_devinfo *devinfo,
-			    struct ahc_linux_target *targ);
+			    struct aic_linux_target *targ);
 static int ahc_linux_fallback(struct ahc_softc *ahc,
 			      struct ahc_devinfo *devinfo);
-static void ahc_linux_dv_complete(Scsi_Cmnd *cmd);
-static void ahc_linux_generate_dv_pattern(struct ahc_linux_target *targ);
+static void ahc_linux_generate_dv_pattern(struct aic_linux_target *targ);
 static u_int ahc_linux_user_tagdepth(struct ahc_softc *ahc,
 				     struct ahc_devinfo *devinfo);
 static u_int ahc_linux_user_dv_setting(struct ahc_softc *ahc);
-static void ahc_linux_device_queue_depth(struct ahc_softc *ahc,
-					 struct ahc_linux_device *dev);
-static struct ahc_linux_target*	ahc_linux_alloc_target(struct ahc_softc*,
+static void aic_linux_device_queue_depth(struct ahc_softc *ahc,
+					 struct aic_linux_device *dev);
+static struct aic_linux_target*	ahc_linux_alloc_target(struct ahc_softc*,
 						       u_int, u_int);
 static void			ahc_linux_free_target(struct ahc_softc*,
-						      struct ahc_linux_target*);
-static struct ahc_linux_device*	ahc_linux_alloc_device(struct ahc_softc*,
-						       struct ahc_linux_target*,
+						      struct aic_linux_target*);
+static struct aic_linux_device*	ahc_linux_alloc_device(struct ahc_softc*,
+						       struct aic_linux_target*,
 						       u_int);
 static void			ahc_linux_free_device(struct ahc_softc*,
-						      struct ahc_linux_device*);
-static void ahc_linux_run_device_queue(struct ahc_softc*,
-				       struct ahc_linux_device*);
+						      struct aic_linux_device*);
 static void ahc_linux_setup_tag_info_global(char *p);
 static aic_option_callback_t ahc_linux_setup_tag_info;
 static aic_option_callback_t ahc_linux_setup_dv;
 static int  aic7xxx_setup(char *s);
 static int  ahc_linux_next_unit(void);
-static void ahc_runq_tasklet(unsigned long data);
-static struct ahc_cmd *ahc_linux_run_complete_queue(struct ahc_softc *ahc);
+static struct aic_cmd *ahc_linux_run_complete_queue(struct ahc_softc *ahc);
 
 /********************************* Inlines ************************************/
-static __inline void ahc_schedule_runq(struct ahc_softc *ahc);
-static __inline struct ahc_linux_device*
+static __inline struct aic_linux_device*
 		     ahc_linux_get_device(struct ahc_softc *ahc, u_int channel,
 					  u_int target, u_int lun, int alloc);
 static __inline void ahc_schedule_completeq(struct ahc_softc *ahc);
-static __inline void ahc_linux_check_device_queue(struct ahc_softc *ahc,
-						  struct ahc_linux_device *dev);
-static __inline struct ahc_linux_device *
-		     ahc_linux_next_device_to_run(struct ahc_softc *ahc);
-static __inline void ahc_linux_run_device_queues(struct ahc_softc *ahc);
 static __inline void ahc_linux_unmap_scb(struct ahc_softc*, struct scb*);
 
 static __inline int ahc_linux_map_seg(struct ahc_softc *ahc, struct scb *scb,
@@ -579,35 +574,19 @@ static __inline int ahc_linux_map_seg(st
 static __inline void
 ahc_schedule_completeq(struct ahc_softc *ahc)
 {
-	if ((ahc->platform_data->flags & AHC_RUN_CMPLT_Q_TIMER) == 0) {
-		ahc->platform_data->flags |= AHC_RUN_CMPLT_Q_TIMER;
+	if ((ahc->platform_data->flags & AIC_RUN_CMPLT_Q_TIMER) == 0) {
+		ahc->platform_data->flags |= AIC_RUN_CMPLT_Q_TIMER;
 		ahc->platform_data->completeq_timer.expires = jiffies;
 		add_timer(&ahc->platform_data->completeq_timer);
 	}
 }
 
-/*
- * Must be called with our lock held.
- */
-static __inline void
-ahc_schedule_runq(struct ahc_softc *ahc)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_schedule(&ahc->platform_data->runq_tasklet);
-#else
-	/*
-	 * Tasklets are not available, so run inline.
-	 */
-	ahc_runq_tasklet((unsigned long)ahc);
-#endif
-}
-
-static __inline struct ahc_linux_device*
+static __inline struct aic_linux_device*
 ahc_linux_get_device(struct ahc_softc *ahc, u_int channel, u_int target,
 		     u_int lun, int alloc)
 {
-	struct ahc_linux_target *targ;
-	struct ahc_linux_device *dev;
+	struct aic_linux_target *targ;
+	struct aic_linux_device *dev;
 	u_int target_offset;
 
 	target_offset = target;
@@ -629,15 +608,13 @@ ahc_linux_get_device(struct ahc_softc *a
 }
 
 #define AHC_LINUX_MAX_RETURNED_ERRORS 4
-static struct ahc_cmd *
+static struct aic_cmd *
 ahc_linux_run_complete_queue(struct ahc_softc *ahc)
 {
-	struct	ahc_cmd *acmd;
-	u_long	done_flags;
+	struct	aic_cmd *acmd;
 	int	with_errors;
 
 	with_errors = 0;
-	ahc_done_lock(ahc, &done_flags);
 	while ((acmd = TAILQ_FIRST(&ahc->platform_data->completeq)) != NULL) {
 		Scsi_Cmnd *cmd;
 
@@ -657,56 +634,11 @@ ahc_linux_run_complete_queue(struct ahc_
 			     acmd, acmd_links.tqe);
 		cmd = &acmd_scsi_cmd(acmd);
 		cmd->host_scribble = NULL;
-		if (ahc_cmd_get_transaction_status(cmd) != DID_OK
-		 || (cmd->result & 0xFF) != SCSI_STATUS_OK)
-			with_errors++;
-
 		cmd->scsi_done(cmd);
+		with_errors++;
 	}
-	ahc_done_unlock(ahc, &done_flags);
 	return (acmd);
 }
-
-static __inline void
-ahc_linux_check_device_queue(struct ahc_softc *ahc,
-			     struct ahc_linux_device *dev)
-{
-	if ((dev->flags & AHC_DEV_FREEZE_TIL_EMPTY) != 0
-	 && dev->active == 0) {
-		dev->flags &= ~AHC_DEV_FREEZE_TIL_EMPTY;
-		dev->qfrozen--;
-	}
-
-	if (TAILQ_FIRST(&dev->busyq) == NULL
-	 || dev->openings == 0 || dev->qfrozen != 0)
-		return;
-
-	ahc_linux_run_device_queue(ahc, dev);
-}
-
-static __inline struct ahc_linux_device *
-ahc_linux_next_device_to_run(struct ahc_softc *ahc)
-{
-	
-	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0
-	 || (ahc->platform_data->qfrozen != 0
-	  && AHC_DV_SIMQ_FROZEN(ahc) == 0))
-		return (NULL);
-	return (TAILQ_FIRST(&ahc->platform_data->device_runq));
-}
-
-static __inline void
-ahc_linux_run_device_queues(struct ahc_softc *ahc)
-{
-	struct ahc_linux_device *dev;
-
-	while ((dev = ahc_linux_next_device_to_run(ahc)) != NULL) {
-		TAILQ_REMOVE(&ahc->platform_data->device_runq, dev, links);
-		dev->flags &= ~AHC_DEV_ON_RUN_LIST;
-		ahc_linux_check_device_queue(ahc, dev);
-	}
-}
-
 static __inline void
 ahc_linux_unmap_scb(struct ahc_softc *ahc, struct scb *scb)
 {
@@ -718,10 +650,10 @@ ahc_linux_unmap_scb(struct ahc_softc *ah
 		struct scatterlist *sg;
 
 		sg = (struct scatterlist *)cmd->request_buffer;
-		pci_unmap_sg(ahc->dev_softc, sg, cmd->use_sg,
+		aic_unmap_sg(ahc, sg, cmd->use_sg,
 			     scsi_to_pci_dma_dir(cmd->sc_data_direction));
 	} else if (cmd->request_bufflen != 0) {
-		pci_unmap_single(ahc->dev_softc,
+		aic_unmap_single(ahc,
 				 scb->platform_data->buf_busaddr,
 				 cmd->request_bufflen,
 				 scsi_to_pci_dma_dir(cmd->sc_data_direction));
@@ -739,14 +671,14 @@ ahc_linux_map_seg(struct ahc_softc *ahc,
 		      "Increase AHC_NSEG\n");
 
 	consumed = 1;
-	sg->addr = ahc_htole32(addr & 0xFFFFFFFF);
+	sg->addr = aic_htole32(addr & 0xFFFFFFFF);
 	scb->platform_data->xfer_len += len;
 
 	if (sizeof(bus_addr_t) > 4
 	 && (ahc->flags & AHC_39BIT_ADDRESSING) != 0)
 		len |= (addr >> 8) & AHC_SG_HIGH_ADDR_MASK;
 
-	sg->len = ahc_htole32(len);
+	sg->len = aic_htole32(len);
 	return (consumed);
 }
 
@@ -836,6 +768,164 @@ ahc_linux_size_nseg(void)
 #endif
 }
 
+/************************** Error Recovery ************************************/
+static int ahc_linux_recovery_thread(void *arg);
+
+static int
+ahc_linux_recovery_thread(void *arg)
+{
+	struct ahc_softc *ahc;
+	u_long s;
+
+	ahc = (struct ahc_softc *)arg;
+
+	/*
+	 * Complete thread creation.
+	 */
+	lock_kernel();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,60)
+	/*
+	 * Don't care about any signals.
+	 */
+	siginitsetinv(&current->blocked, 0);
+
+	daemonize();
+	sprintf(current->comm, "ahc_recovery_%d", ahc->unit);
+#else
+	daemonize("ahc_recovery_%d", ahc->unit);
+#endif
+	unlock_kernel();
+
+	while (1) {
+
+		/*
+		 * Use down_interruptible() rather than down() to
+		 * avoid inclusion in the load average.
+		 */
+		down_interruptible(&ahc->platform_data->recovery_sem);
+
+		ahc_lock(ahc, &s);
+		if ((ahc->flags & AHC_SHUTDOWN_RECOVERY) != 0) {
+			ahc_unlock(ahc, &s);
+			break;
+		}
+
+		/*
+		 * Don't bother the recovery handler if the
+		 * list has been cleared by a previous run
+		 * of the handler.  This can happen when
+		 * several SCBs timeout before our handler
+		 * can run causing our semaphore to be up'ed
+		 * repeatedly.  The extra calls need to be
+		 * avoided so that the recovery handler doesn't
+		 * confuse this case with timeouts occuring
+		 * due to interrupts failing to function.
+		 */
+		if (LIST_EMPTY(&ahc->timedout_scbs) != 0) {
+			ahc_unlock(ahc, &s);
+			continue;
+		}
+		ahc_unlock(ahc, &s);
+		ahc_recover_commands(ahc);
+
+		/*
+		 * Process any pent up completions.
+		 */
+		ahc_lock(ahc, &s);
+		aic_schedule_runq(ahc);
+		ahc_linux_run_complete_queue(ahc);
+		ahc_unlock(ahc, &s);
+	}
+	up(&ahc->platform_data->recovery_ending_sem);
+	return(0);
+}
+
+int
+ahc_spawn_recovery_thread(struct ahc_softc *ahc)
+{
+	ahc->platform_data->recovery_pid =
+	    kernel_thread(ahc_linux_recovery_thread, ahc, 0);
+
+	if (ahc->platform_data->recovery_pid < 0)
+		return (-ahc->platform_data->recovery_pid);
+
+	return (0);
+}
+
+void
+ahc_terminate_recovery_thread(struct ahc_softc *ahc)
+{
+	u_long s;
+
+	ahc_lock(ahc, &s);
+	if (ahc->platform_data->recovery_pid != 0) {
+		ahc->flags |= AHC_SHUTDOWN_RECOVERY;
+		ahc_unlock(ahc, &s);
+		up(&ahc->platform_data->recovery_sem);
+
+		/*
+		 * Use the recovery_ending_sem as an indicator that
+		 * the dv thread is exiting.  Note that the dv
+		 * thread must still return after performing
+		 * the up on our semaphore before it has
+		 * completely exited this module.  Unfortunately,
+		 * there seems to be no easy way to wait for the
+		 * exit of a thread for which you are not the
+		 * parent (dv threads are parented by init).
+		 * Cross your fingers...
+		 */
+		down(&ahc->platform_data->recovery_ending_sem);
+
+		/*
+		 * Mark the recovery thread as already dead.  This
+		 * avoids attempting to kill it a second time.
+		 * This is necessary because we must kill the
+		 * our threads before calling ahc_free() in the
+		 * module shutdown case to avoid bogus locking
+		 * in the SCSI mid-layer, but when ahc_free() is
+		 * called without killing the DV thread in the
+		 * instance detach case, so ahc_platform_free()
+		 * calls us again to verify that the DV thread
+		 * is dead.
+		 */
+		ahc->platform_data->recovery_pid = 0;
+	} else {
+		ahc_unlock(ahc, &s);
+	}
+}
+
+void
+ahc_set_recoveryscb(struct ahc_softc *ahc, struct scb *scb)
+{
+	if ((scb->flags & SCB_RECOVERY_SCB) == 0) {
+		struct scb *list_scb;
+
+		scb->flags |= SCB_RECOVERY_SCB;
+
+		/*
+		 * Take all queued, but not sent SCBs out of the equation.
+		 * Also ensure that no new commands are queued to us while we
+		 * try to fix this problem.
+		 */
+		if ((scb->platform_data->flags & AIC_RELEASE_SIMQ) == 0) {
+			aic_freeze_simq(ahc);
+			scb->platform_data->flags |= AIC_RELEASE_SIMQ;
+		}
+
+		/*
+		 * Go through all of our pending SCBs and remove
+		 * any scheduled timeouts for them.  We will reschedule
+		 * them after we've successfully fixed this problem.
+		 */
+		LIST_FOREACH(list_scb, &ahc->pending_scbs, pending_links) {
+
+			scsi_delete_timer(list_scb->io_ctx);
+			list_scb->platform_data->flags &= ~AIC_TIMEOUT_ACTIVE;
+		}
+	}
+}
+
+/************************ Linux Entry Points **********************************/
 /*
  * Try to detect an Adaptec 7XXX controller.
  */
@@ -852,17 +942,19 @@ ahc_linux_detect(Scsi_Host_Template *tem
 	 */
 	spin_unlock_irq(&io_request_lock);
 #endif
+	found = 0;
 
 	/*
 	 * Sanity checking of Linux SCSI data structures so
 	 * that some of our hacks^H^H^H^H^Hassumptions aren't
 	 * violated.
 	 */
-	if (offsetof(struct ahc_cmd_internal, end)
+	if (offsetof(struct aic_cmd_internal, end)
 	  > offsetof(struct scsi_cmnd, host_scribble)) {
 		printf("ahc_linux_detect: SCSI data structures changed.\n");
 		printf("ahc_linux_detect: Unable to attach\n");
-		return (0);
+		ahc_init_status = -EINVAL;
+		goto done;
 	}
 	ahc_linux_size_nseg();
 #ifdef MODULE
@@ -879,11 +971,7 @@ ahc_linux_detect(Scsi_Host_Template *tem
 "aic7xxx: insmod or else it might trash certain memory areas.\n");
 #endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
 	template->proc_name = "aic7xxx";
-#else
-	template->proc_dir = &proc_scsi_aic7xxx;
-#endif
 
 	/*
 	 * Initialize our softc list lock prior to
@@ -892,11 +980,15 @@ ahc_linux_detect(Scsi_Host_Template *tem
 	ahc_list_lockinit();
 
 #ifdef CONFIG_PCI
-	ahc_linux_pci_init();
+	ahc_init_status = ahc_linux_pci_init();
+	if (ahc_init_status != 0)
+		goto done;
 #endif
 
 #ifdef CONFIG_EISA
-	ahc_linux_eisa_init();
+	ahc_init_status = ahc_linux_eisa_init();
+	if (ahc_init_status != 0)
+		goto done;
 #endif
 
 	/*
@@ -909,6 +1001,7 @@ ahc_linux_detect(Scsi_Host_Template *tem
 		if (ahc_linux_register_host(ahc, template) == 0)
 			found++;
 	}
+done:
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 	spin_lock_irq(&io_request_lock);
 #endif
@@ -927,7 +1020,6 @@ ahc_linux_release(struct Scsi_Host * hos
 	struct ahc_softc *ahc;
 	u_long l;
 
-	ahc_list_lock(&l);
 	if (host != NULL) {
 
 		/*
@@ -935,17 +1027,20 @@ ahc_linux_release(struct Scsi_Host * hos
 		 * the free directly, but check our
 		 * list for extra sanity.
 		 */
+		ahc_list_lock(&l);
 		ahc = ahc_find_softc(*(struct ahc_softc **)host->hostdata);
 		if (ahc != NULL) {
 			u_long s;
 
+			TAILQ_REMOVE(&ahc_tailq, ahc, links);
+			ahc_list_unlock(&l);
 			ahc_lock(ahc, &s);
 			ahc_intr_enable(ahc, FALSE);
 			ahc_unlock(ahc, &s);
 			ahc_free(ahc);
-		}
+		} else
+			ahc_list_unlock(&l);
 	}
-	ahc_list_unlock(&l);
 	return (0);
 }
 #endif
@@ -985,7 +1080,7 @@ static int
 ahc_linux_queue(Scsi_Cmnd * cmd, void (*scsi_done) (Scsi_Cmnd *))
 {
 	struct	 ahc_softc *ahc;
-	struct	 ahc_linux_device *dev;
+	struct	 aic_linux_device *dev;
 	u_long	 flags;
 
 	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
@@ -995,7 +1090,7 @@ ahc_linux_queue(Scsi_Cmnd * cmd, void (*
 	 */
 	cmd->scsi_done = scsi_done;
 
-	ahc_midlayer_entrypoint_lock(ahc, &flags);
+	ahc_entrypoint_lock(ahc, &flags);
 
 	/*
 	 * Close the race of a command that was in the process of
@@ -1004,33 +1099,63 @@ ahc_linux_queue(Scsi_Cmnd * cmd, void (*
 	 * perform DV.
 	 */
 	if (ahc->platform_data->qfrozen != 0
-	 && AHC_DV_CMD(cmd) == 0) {
+	 && AIC_DV_CMD(cmd) == 0) {
 
-		ahc_cmd_set_transaction_status(cmd, CAM_REQUEUE_REQ);
+		aic_cmd_set_transaction_status(cmd, CAM_REQUEUE_REQ);
 		ahc_linux_queue_cmd_complete(ahc, cmd);
 		ahc_schedule_completeq(ahc);
-		ahc_midlayer_entrypoint_unlock(ahc, &flags);
+		ahc_entrypoint_unlock(ahc, &flags);
 		return (0);
 	}
 	dev = ahc_linux_get_device(ahc, cmd->device->channel, cmd->device->id,
 				   cmd->device->lun, /*alloc*/TRUE);
 	if (dev == NULL) {
-		ahc_cmd_set_transaction_status(cmd, CAM_RESRC_UNAVAIL);
+
+		aic_cmd_set_transaction_status(cmd, CAM_RESRC_UNAVAIL);
 		ahc_linux_queue_cmd_complete(ahc, cmd);
 		ahc_schedule_completeq(ahc);
-		ahc_midlayer_entrypoint_unlock(ahc, &flags);
+		ahc_entrypoint_unlock(ahc, &flags);
 		printf("%s: aic7xxx_linux_queue - Unable to allocate device!\n",
 		       ahc_name(ahc));
 		return (0);
+	} else if ((dev->flags & AIC_DEV_UNCONFIGURED) != 0
+		&& cmd->device->type != -1) {
+		/*
+		 * Configure devices that have already successfully
+		 * completed an inquiry. This  handles the case of
+		 * devices being destroyed due to transient selection
+		 * timeouts.
+		 */
+		dev->flags &= ~AIC_DEV_UNCONFIGURED;
+	 	dev->scsi_device = cmd->device;
+		aic_linux_device_queue_depth(ahc, dev);
 	}
+
+	if (cmd->cmd_len > MAX_CDB_LEN) {
+
+		aic_cmd_set_transaction_status(cmd, CAM_REQ_INVALID);
+		ahc_linux_queue_cmd_complete(ahc, cmd);
+		ahc_schedule_completeq(ahc);
+		ahc_entrypoint_unlock(ahc, &flags);
+		printf("%s: aic7xxx_linux_queue -"
+		       "CDB length of %d exceeds max!\n",
+		       ahc_name(ahc), cmd->cmd_len);
+		return (0);
+	}
+
+	/*
+	 * We perform our own timeout handling.
+	 */
+	scsi_delete_timer(cmd);
+
 	cmd->result = CAM_REQ_INPROG << 16;
-	TAILQ_INSERT_TAIL(&dev->busyq, (struct ahc_cmd *)cmd, acmd_links.tqe);
-	if ((dev->flags & AHC_DEV_ON_RUN_LIST) == 0) {
+	TAILQ_INSERT_TAIL(&dev->busyq, (struct aic_cmd *)cmd, acmd_links.tqe);
+	if ((dev->flags & AIC_DEV_ON_RUN_LIST) == 0) {
 		TAILQ_INSERT_TAIL(&ahc->platform_data->device_runq, dev, links);
-		dev->flags |= AHC_DEV_ON_RUN_LIST;
-		ahc_linux_run_device_queues(ahc);
+		dev->flags |= AIC_DEV_ON_RUN_LIST;
+		aic_linux_run_device_queues(ahc);
 	}
-	ahc_midlayer_entrypoint_unlock(ahc, &flags);
+	ahc_entrypoint_unlock(ahc, &flags);
 	return (0);
 }
 
@@ -1050,13 +1175,13 @@ static int
 ahc_linux_slave_configure(Scsi_Device *device)
 {
 	struct	ahc_softc *ahc;
-	struct	ahc_linux_device *dev;
+	struct	aic_linux_device *dev;
 	u_long	flags;
 
 	ahc = *((struct ahc_softc **)device->host->hostdata);
 	if (bootverbose)
 		printf("%s: Slave Configure %d\n", ahc_name(ahc), device->id);
-	ahc_midlayer_entrypoint_lock(ahc, &flags);
+	ahc_entrypoint_lock(ahc, &flags);
 	/*
 	 * Since Linux has attached to the device, configure
 	 * it so we don't free and allocate the device
@@ -1066,11 +1191,11 @@ ahc_linux_slave_configure(Scsi_Device *d
 				   device->id, device->lun,
 				   /*alloc*/TRUE);
 	if (dev != NULL) {
-		dev->flags &= ~AHC_DEV_UNCONFIGURED;
+		dev->flags &= ~AIC_DEV_UNCONFIGURED;
 		dev->scsi_device = device;
-		ahc_linux_device_queue_depth(ahc, dev);
+		aic_linux_device_queue_depth(ahc, dev);
 	}
-	ahc_midlayer_entrypoint_unlock(ahc, &flags);
+	ahc_entrypoint_unlock(ahc, &flags);
 	return (0);
 }
 
@@ -1078,13 +1203,13 @@ static void
 ahc_linux_slave_destroy(Scsi_Device *device)
 {
 	struct	ahc_softc *ahc;
-	struct	ahc_linux_device *dev;
+	struct	aic_linux_device *dev;
 	u_long	flags;
 
 	ahc = *((struct ahc_softc **)device->host->hostdata);
 	if (bootverbose)
 		printf("%s: Slave Destroy %d\n", ahc_name(ahc), device->id);
-	ahc_midlayer_entrypoint_lock(ahc, &flags);
+	ahc_entrypoint_lock(ahc, &flags);
 	dev = ahc_linux_get_device(ahc, device->channel,
 				   device->id, device->lun,
 					   /*alloc*/FALSE);
@@ -1096,14 +1221,13 @@ ahc_linux_slave_destroy(Scsi_Device *dev
 	 * the refcounting process.
 	 */
 	if (dev != NULL
-	 && (dev->flags & AHC_DEV_SLAVE_CONFIGURED) != 0) {
-		dev->flags |= AHC_DEV_UNCONFIGURED;
+	 && (dev->flags & AIC_DEV_SLAVE_CONFIGURED) != 0) {
+		dev->flags |= AIC_DEV_UNCONFIGURED;
 		if (TAILQ_EMPTY(&dev->busyq)
-		 && dev->active == 0
-	 	 && (dev->flags & AHC_DEV_TIMER_ACTIVE) == 0)
+		 && dev->active == 0)
 			ahc_linux_free_device(ahc, dev);
 	}
-	ahc_midlayer_entrypoint_unlock(ahc, &flags);
+	ahc_entrypoint_unlock(ahc, &flags);
 }
 #else
 /*
@@ -1139,7 +1263,7 @@ ahc_linux_select_queue_depth(struct Scsi
 			continue;
 
 		if (device->host == host) {
-			struct	 ahc_linux_device *dev;
+			struct	 aic_linux_device *dev;
 
 			/*
 			 * Since Linux has attached to the device, configure
@@ -1150,13 +1274,13 @@ ahc_linux_select_queue_depth(struct Scsi
 						   device->id, device->lun,
 						   /*alloc*/TRUE);
 			if (dev != NULL) {
-				dev->flags &= ~AHC_DEV_UNCONFIGURED;
+				dev->flags &= ~AIC_DEV_UNCONFIGURED;
 				dev->scsi_device = device;
-				ahc_linux_device_queue_depth(ahc, dev);
+				aic_linux_device_queue_depth(ahc, dev);
 				device->queue_depth = dev->openings
 						    + dev->active;
-				if ((dev->flags & (AHC_DEV_Q_BASIC
-						| AHC_DEV_Q_TAGGED)) == 0) {
+				if ((dev->flags & (AIC_DEV_Q_BASIC
+						| AIC_DEV_Q_TAGGED)) == 0) {
 					/*
 					 * We allow the OS to queue 2 untagged
 					 * transactions to us at any time even
@@ -1281,11 +1405,11 @@ ahc_linux_bus_reset(Scsi_Cmnd *cmd)
 	int    found;
 
 	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
-	ahc_midlayer_entrypoint_lock(ahc, &s);
+	ahc_entrypoint_lock(ahc, &s);
 	found = ahc_reset_channel(ahc, cmd->device->channel + 'A',
 				  /*initiate reset*/TRUE);
 	ahc_linux_run_complete_queue(ahc);
-	ahc_midlayer_entrypoint_unlock(ahc, &s);
+	ahc_entrypoint_unlock(ahc, &s);
 
 	if (bootverbose)
 		printf("%s: SCSI bus reset delivered. "
@@ -1294,63 +1418,8 @@ ahc_linux_bus_reset(Scsi_Cmnd *cmd)
 	return SUCCESS;
 }
 
-Scsi_Host_Template aic7xxx_driver_template = {
-	.module			= THIS_MODULE,
-	.name			= "aic7xxx",
-	.proc_info		= ahc_linux_proc_info,
-	.info			= ahc_linux_info,
-	.queuecommand		= ahc_linux_queue,
-	.eh_abort_handler	= ahc_linux_abort,
-	.eh_device_reset_handler = ahc_linux_dev_reset,
-	.eh_bus_reset_handler	= ahc_linux_bus_reset,
-#if defined(__i386__)
-	.bios_param		= ahc_linux_biosparam,
-#endif
-	.can_queue		= AHC_MAX_QUEUE,
-	.this_id		= -1,
-	.cmd_per_lun		= 2,
-	.use_clustering		= ENABLE_CLUSTERING,
-	.slave_alloc		= ahc_linux_slave_alloc,
-	.slave_configure	= ahc_linux_slave_configure,
-	.slave_destroy		= ahc_linux_slave_destroy,
-};
-
-/**************************** Tasklet Handler *********************************/
-
-/*
- * In 2.4.X and above, this routine is called from a tasklet,
- * so we must re-acquire our lock prior to executing this code.
- * In all prior kernels, ahc_schedule_runq() calls this routine
- * directly and ahc_schedule_runq() is called with our lock held.
- */
-static void
-ahc_runq_tasklet(unsigned long data)
-{
-	struct ahc_softc* ahc;
-	struct ahc_linux_device *dev;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	u_long flags;
-#endif
-
-	ahc = (struct ahc_softc *)data;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	ahc_lock(ahc, &flags);
-#endif
-	while ((dev = ahc_linux_next_device_to_run(ahc)) != NULL) {
-	
-		TAILQ_REMOVE(&ahc->platform_data->device_runq, dev, links);
-		dev->flags &= ~AHC_DEV_ON_RUN_LIST;
-		ahc_linux_check_device_queue(ahc, dev);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		/* Yeild to our interrupt handler */
-		ahc_unlock(ahc, &flags);
-		ahc_lock(ahc, &flags);
-#endif
-	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	ahc_unlock(ahc, &flags);
-#endif
-}
+Scsi_Host_Template aic7xxx_driver_template =
+	AIC_TEMPLATE_INITIALIZER("aic7xxx", /* max_sectors*/8192);
 
 /******************************** Macros **************************************/
 #define BUILD_SCSIID(ahc, cmd)						    \
@@ -1358,138 +1427,6 @@ ahc_runq_tasklet(unsigned long data)
 	| (((cmd)->device->channel == 0) ? (ahc)->our_id : (ahc)->our_id_b) \
 	| (((cmd)->device->channel == 0) ? 0 : TWIN_CHNLB))
 
-/******************************** Bus DMA *************************************/
-int
-ahc_dma_tag_create(struct ahc_softc *ahc, bus_dma_tag_t parent,
-		   bus_size_t alignment, bus_size_t boundary,
-		   bus_addr_t lowaddr, bus_addr_t highaddr,
-		   bus_dma_filter_t *filter, void *filterarg,
-		   bus_size_t maxsize, int nsegments,
-		   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)
-{
-	bus_dma_tag_t dmat;
-
-	dmat = malloc(sizeof(*dmat), M_DEVBUF, M_NOWAIT);
-	if (dmat == NULL)
-		return (ENOMEM);
-
-	/*
-	 * Linux is very simplistic about DMA memory.  For now don't
-	 * maintain all specification information.  Once Linux supplies
-	 * better facilities for doing these operations, or the
-	 * needs of this particular driver change, we might need to do
-	 * more here.
-	 */
-	dmat->alignment = alignment;
-	dmat->boundary = boundary;
-	dmat->maxsize = maxsize;
-	*ret_tag = dmat;
-	return (0);
-}
-
-void
-ahc_dma_tag_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat)
-{
-	free(dmat, M_DEVBUF);
-}
-
-int
-ahc_dmamem_alloc(struct ahc_softc *ahc, bus_dma_tag_t dmat, void** vaddr,
-		 int flags, bus_dmamap_t *mapp)
-{
-	bus_dmamap_t map;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT);
-	if (map == NULL)
-		return (ENOMEM);
-	/*
-	 * Although we can dma data above 4GB, our
-	 * "consistent" memory is below 4GB for
-	 * space efficiency reasons (only need a 4byte
-	 * address).  For this reason, we have to reset
-	 * our dma mask when doing allocations.
-	 */
-	if (ahc->dev_softc != NULL)
-		if (ahc_pci_set_dma_mask(ahc->dev_softc, 0xFFFFFFFF)) {
-			printk(KERN_WARNING "aic7xxx: No suitable DMA available.\n");
-			return (ENODEV);
-		}
-	*vaddr = pci_alloc_consistent(ahc->dev_softc,
-				      dmat->maxsize, &map->bus_addr);
-	if (ahc->dev_softc != NULL)
-		if (ahc_pci_set_dma_mask(ahc->dev_softc,
-				     ahc->platform_data->hw_dma_mask)) {
-			printk(KERN_WARNING "aic7xxx: No suitable DMA available.\n");
-			return (ENODEV);
-		}
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
-	/*
-	 * At least in 2.2.14, malloc is a slab allocator so all
-	 * allocations are aligned.  We assume for these kernel versions
-	 * that all allocations will be bellow 4Gig, physically contiguous,
-	 * and accessible via DMA by the controller.
-	 */
-	map = NULL; /* No additional information to store */
-	*vaddr = malloc(dmat->maxsize, M_DEVBUF, M_NOWAIT);
-#endif
-	if (*vaddr == NULL)
-		return (ENOMEM);
-	*mapp = map;
-	return(0);
-}
-
-void
-ahc_dmamem_free(struct ahc_softc *ahc, bus_dma_tag_t dmat,
-		void* vaddr, bus_dmamap_t map)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	pci_free_consistent(ahc->dev_softc, dmat->maxsize,
-			    vaddr, map->bus_addr);
-#else
-	free(vaddr, M_DEVBUF);
-#endif
-}
-
-int
-ahc_dmamap_load(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map,
-		void *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,
-		void *cb_arg, int flags)
-{
-	/*
-	 * Assume for now that this will only be used during
-	 * initialization and not for per-transaction buffer mapping.
-	 */
-	bus_dma_segment_t stack_sg;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	stack_sg.ds_addr = map->bus_addr;
-#else
-#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
-	stack_sg.ds_addr = VIRT_TO_BUS(buf);
-#endif
-	stack_sg.ds_len = dmat->maxsize;
-	cb(cb_arg, &stack_sg, /*nseg*/1, /*error*/0);
-	return (0);
-}
-
-void
-ahc_dmamap_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)
-{
-	/*
-	 * The map may is NULL in our < 2.3.X implementation.
-	 */
-	if (map != NULL)
-		free(map, M_DEVBUF);
-}
-
-int
-ahc_dmamap_unload(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)
-{
-	/* Nothing to do */
-	return (0);
-}
-
 /********************* Platform Dependent Functions ***************************/
 /*
  * Compare "left hand" softc with "right hand" softc, returning:
@@ -1534,24 +1471,25 @@ ahc_softc_comp(struct ahc_softc *lahc, s
 
 	/* Still equal.  Sort by BIOS address, ioport, or bus/slot/func. */
 	switch (rvalue) {
+#ifdef CONFIG_PCI
 	case AHC_PCI:
 	{
 		char primary_channel;
 
 		if (aic7xxx_reverse_scan != 0)
-			value = ahc_get_pci_bus(lahc->dev_softc)
-			      - ahc_get_pci_bus(rahc->dev_softc);
+			value = aic_get_pci_bus(lahc->dev_softc)
+			      - aic_get_pci_bus(rahc->dev_softc);
 		else
-			value = ahc_get_pci_bus(rahc->dev_softc)
-			      - ahc_get_pci_bus(lahc->dev_softc);
+			value = aic_get_pci_bus(rahc->dev_softc)
+			      - aic_get_pci_bus(lahc->dev_softc);
 		if (value != 0)
 			break;
 		if (aic7xxx_reverse_scan != 0)
-			value = ahc_get_pci_slot(lahc->dev_softc)
-			      - ahc_get_pci_slot(rahc->dev_softc);
+			value = aic_get_pci_slot(lahc->dev_softc)
+			      - aic_get_pci_slot(rahc->dev_softc);
 		else
-			value = ahc_get_pci_slot(rahc->dev_softc)
-			      - ahc_get_pci_slot(lahc->dev_softc);
+			value = aic_get_pci_slot(rahc->dev_softc)
+			      - aic_get_pci_slot(lahc->dev_softc);
 		if (value != 0)
 			break;
 		/*
@@ -1566,6 +1504,8 @@ ahc_softc_comp(struct ahc_softc *lahc, s
 			value = 1;
 		break;
 	}
+#endif
+#ifdef CONFIG_EISA
 	case AHC_EISA:
 		if ((rahc->flags & AHC_BIOS_ENABLED) != 0) {
 			value = rahc->platform_data->bios_address
@@ -1575,6 +1515,7 @@ ahc_softc_comp(struct ahc_softc *lahc, s
 			      - lahc->bsh.ioport; 
 		}
 		break;
+#endif
 	default:
 		panic("ahc_softc_sort: invalid bus type");
 	}
@@ -1694,9 +1635,7 @@ aic7xxx_setup(char *s)
 	return 1;
 }
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
 __setup("aic7xxx=", aic7xxx_setup);
-#endif
 
 uint32_t aic7xxx_verbose;
 
@@ -1708,20 +1647,23 @@ ahc_linux_register_host(struct ahc_softc
 	char	*new_name;
 	u_long	 s;
 	u_int	 targ_offset;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	int	 error;
+#endif
 
 	template->name = ahc->description;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	host = scsi_host_alloc(template, sizeof(struct ahc_softc *));
+#else
+	host = scsi_register(template, sizeof(struct ahc_softc *));
+#endif
 	if (host == NULL)
 		return (ENOMEM);
 
 	*((struct ahc_softc **)host->hostdata) = ahc;
 	ahc_lock(ahc, &s);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	scsi_assign_lock(host, &ahc->platform_data->spin_lock);
-#elif AHC_SCSI_HAS_HOST_LOCK != 0
-	host->lock = &ahc->platform_data->spin_lock;
-#endif
 	ahc->platform_data->host = host;
+	aic_assign_host_lock(ahc);
 	host->can_queue = AHC_MAX_QUEUE;
 	host->cmd_per_lun = 2;
 	/* XXX No way to communicate the ID for multiple channels */
@@ -1745,13 +1687,19 @@ ahc_linux_register_host(struct ahc_softc
 #endif
 	ahc_linux_initialize_scsi_bus(ahc);
 	ahc_unlock(ahc, &s);
+	ahc_spawn_recovery_thread(ahc);
+	if (ahc->platform_data->recovery_pid < 0) {
+		printf("%s: Failed to create recovery thread, error= %d\n",
+		       ahc_name(ahc), ahc->platform_data->recovery_pid);
+		return (-ahc->platform_data->recovery_pid);
+	}
 	ahc->platform_data->dv_pid = kernel_thread(ahc_linux_dv_thread, ahc, 0);
-	ahc_lock(ahc, &s);
 	if (ahc->platform_data->dv_pid < 0) {
 		printf("%s: Failed to create DV thread, error= %d\n",
 		       ahc_name(ahc), ahc->platform_data->dv_pid);
 		return (-ahc->platform_data->dv_pid);
 	}
+	ahc_lock(ahc, &s);
 	/*
 	 * Initially allocate *all* of our linux target objects
 	 * so that the DV thread will scan them all in parallel
@@ -1796,7 +1744,9 @@ ahc_linux_register_host(struct ahc_softc
 	ahc_unlock(ahc, &s);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	scsi_add_host(host, (ahc->dev_softc ? &ahc->dev_softc->dev : NULL)); /* XXX handle failure */
+	error = scsi_add_host(host, ahc->dev_softc);
+	if (error != 0)
+		return (-error);
 	scsi_scan_host(host);
 #endif
 	return (0);
@@ -1894,17 +1844,6 @@ ahc_linux_initialize_scsi_bus(struct ahc
 		ahc_update_neg_request(ahc, &devinfo, tstate,
 				       tinfo, AHC_NEG_ALWAYS);
 	}
-	/* Give the bus some time to recover */
-	if ((ahc->flags & (AHC_RESET_BUS_A|AHC_RESET_BUS_B)) != 0) {
-		ahc_linux_freeze_simq(ahc);
-		init_timer(&ahc->platform_data->reset_timer);
-		ahc->platform_data->reset_timer.data = (u_long)ahc;
-		ahc->platform_data->reset_timer.expires =
-		    jiffies + (AIC7XXX_RESET_DELAY * HZ)/1000;
-		ahc->platform_data->reset_timer.function =
-		    ahc_linux_release_simq;
-		add_timer(&ahc->platform_data->reset_timer);
-	}
 }
 
 int
@@ -1918,27 +1857,23 @@ ahc_platform_alloc(struct ahc_softc *ahc
 	memset(ahc->platform_data, 0, sizeof(struct ahc_platform_data));
 	TAILQ_INIT(&ahc->platform_data->completeq);
 	TAILQ_INIT(&ahc->platform_data->device_runq);
-	ahc->platform_data->irq = AHC_LINUX_NOIRQ;
+	ahc->platform_data->irq = AIC_LINUX_NOIRQ;
 	ahc->platform_data->hw_dma_mask = 0xFFFFFFFF;
 	ahc_lockinit(ahc);
-	ahc_done_lockinit(ahc);
+	init_timer(&ahc->platform_data->bus_settle_timer);
+	ahc->platform_data->bus_settle_timer.data = (u_long)ahc;
+	ahc->platform_data->bus_settle_timer.function =
+	    (aic_linux_callback_t *)aic_bus_settle_complete;
 	init_timer(&ahc->platform_data->completeq_timer);
 	ahc->platform_data->completeq_timer.data = (u_long)ahc;
 	ahc->platform_data->completeq_timer.function =
-	    (ahc_linux_callback_t *)ahc_linux_thread_run_complete_queue;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	    (aic_linux_callback_t *)ahc_linux_thread_run_complete_queue;
 	init_MUTEX_LOCKED(&ahc->platform_data->eh_sem);
 	init_MUTEX_LOCKED(&ahc->platform_data->dv_sem);
 	init_MUTEX_LOCKED(&ahc->platform_data->dv_cmd_sem);
-#else
-	ahc->platform_data->eh_sem = MUTEX_LOCKED;
-	ahc->platform_data->dv_sem = MUTEX_LOCKED;
-	ahc->platform_data->dv_cmd_sem = MUTEX_LOCKED;
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_init(&ahc->platform_data->runq_tasklet, ahc_runq_tasklet,
-		     (unsigned long)ahc);
-#endif
+	init_MUTEX_LOCKED(&ahc->platform_data->recovery_sem);
+	init_MUTEX_LOCKED(&ahc->platform_data->recovery_ending_sem);
+	aic_setup_tasklets(ahc);
 	ahc->seltime = (aic7xxx_seltime & 0x3) << 4;
 	ahc->seltime_b = (aic7xxx_seltime & 0x3) << 4;
 	if (aic7xxx_pci_parity == 0)
@@ -1950,34 +1885,47 @@ ahc_platform_alloc(struct ahc_softc *ahc
 void
 ahc_platform_free(struct ahc_softc *ahc)
 {
-	struct ahc_linux_target *targ;
-	struct ahc_linux_device *dev;
+	struct aic_linux_target *targ;
+	struct aic_linux_device *dev;
 	int i, j;
 
 	if (ahc->platform_data != NULL) {
 		del_timer_sync(&ahc->platform_data->completeq_timer);
 		ahc_linux_kill_dv_thread(ahc);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		tasklet_kill(&ahc->platform_data->runq_tasklet);
-#endif
+		aic_teardown_tasklets(ahc);
 		if (ahc->platform_data->host != NULL) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 			scsi_remove_host(ahc->platform_data->host);
-#endif
 			scsi_host_put(ahc->platform_data->host);
+#else
+			scsi_unregister(ahc->platform_data->host);
+#endif
 		}
 
 		/* destroy all of the device and target objects */
 		for (i = 0; i < AHC_NUM_TARGETS; i++) {
 			targ = ahc->platform_data->targets[i];
 			if (targ != NULL) {
-				/* Keep target around through the loop. */
+
+				/*
+				 * Stop any unfreeze timer from running.
+				 */
+				del_timer_sync(&targ->timer);
+
+				/*
+				 * Keep target around through the loop.
+				 * The timer above may also have held
+				 * a refcount, but since we forcibly
+				 * delete the target, we don't care
+				 * about the extra reference.
+				 */
 				targ->refcount++;
 				for (j = 0; j < AHC_NUM_LUNS; j++) {
 
 					if (targ->devices[j] == NULL)
 						continue;
 					dev = targ->devices[j];
+					del_timer_sync(&dev->timer);
 					ahc_linux_free_device(ahc, dev);
 				}
 				/*
@@ -1988,7 +1936,7 @@ ahc_platform_free(struct ahc_softc *ahc)
  			}
  		}
 
-		if (ahc->platform_data->irq != AHC_LINUX_NOIRQ)
+		if (ahc->platform_data->irq != AIC_LINUX_NOIRQ)
 			free_irq(ahc->platform_data->irq, ahc);
 		if (ahc->tag == BUS_SPACE_PIO
 		 && ahc->bsh.ioport != 0)
@@ -2000,10 +1948,8 @@ ahc_platform_free(struct ahc_softc *ahc)
 			base_addr = (u_long)ahc->bsh.maddr;
 			base_addr &= PAGE_MASK;
 			iounmap((void *)base_addr);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 			release_mem_region(ahc->platform_data->mem_busaddr,
 					   0x1000);
-#endif
 		}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0) && \
     LINUX_VERSION_CODE  < KERNEL_VERSION(2,5,0)
@@ -2033,7 +1979,7 @@ void
 ahc_platform_set_tags(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
 		      ahc_queue_alg alg)
 {
-	struct ahc_linux_device *dev;
+	struct aic_linux_device *dev;
 	int was_queuing;
 	int now_queuing;
 
@@ -2042,27 +1988,27 @@ ahc_platform_set_tags(struct ahc_softc *
 				   devinfo->lun, /*alloc*/FALSE);
 	if (dev == NULL)
 		return;
-	was_queuing = dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED);
+	was_queuing = dev->flags & (AIC_DEV_Q_BASIC|AIC_DEV_Q_TAGGED);
 	switch (alg) {
 	default:
 	case AHC_QUEUE_NONE:
 		now_queuing = 0;
 		break; 
 	case AHC_QUEUE_BASIC:
-		now_queuing = AHC_DEV_Q_BASIC;
+		now_queuing = AIC_DEV_Q_BASIC;
 		break;
 	case AHC_QUEUE_TAGGED:
-		now_queuing = AHC_DEV_Q_TAGGED;
+		now_queuing = AIC_DEV_Q_TAGGED;
 		break;
 	}
-	if ((dev->flags & AHC_DEV_FREEZE_TIL_EMPTY) == 0
+	if ((dev->flags & AIC_DEV_FREEZE_TIL_EMPTY) == 0
 	 && (was_queuing != now_queuing)
 	 && (dev->active != 0)) {
-		dev->flags |= AHC_DEV_FREEZE_TIL_EMPTY;
+		dev->flags |= AIC_DEV_FREEZE_TIL_EMPTY;
 		dev->qfrozen++;
 	}
 
-	dev->flags &= ~(AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED|AHC_DEV_PERIODIC_OTAG);
+	dev->flags &= ~(AIC_DEV_Q_BASIC|AIC_DEV_Q_TAGGED|AIC_DEV_PERIODIC_OTAG);
 	if (now_queuing) {
 		u_int usertags;
 
@@ -2082,11 +2028,11 @@ ahc_platform_set_tags(struct ahc_softc *
 			 */
 			dev->openings = 1;
 		} else if (alg == AHC_QUEUE_TAGGED) {
-			dev->flags |= AHC_DEV_Q_TAGGED;
+			dev->flags |= AIC_DEV_Q_TAGGED;
 			if (aic7xxx_periodic_otag != 0)
-				dev->flags |= AHC_DEV_PERIODIC_OTAG;
+				dev->flags |= AIC_DEV_PERIODIC_OTAG;
 		} else
-			dev->flags |= AHC_DEV_Q_BASIC;
+			dev->flags |= AIC_DEV_Q_BASIC;
 	} else {
 		/* We can only have one opening. */
 		dev->maxtags = 0;
@@ -2094,13 +2040,13 @@ ahc_platform_set_tags(struct ahc_softc *
 	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	if (dev->scsi_device != NULL) {
-		switch ((dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED))) {
-		case AHC_DEV_Q_BASIC:
+		switch ((dev->flags & (AIC_DEV_Q_BASIC|AIC_DEV_Q_TAGGED))) {
+		case AIC_DEV_Q_BASIC:
 			scsi_adjust_queue_depth(dev->scsi_device,
 						MSG_SIMPLE_TASK,
 						dev->openings + dev->active);
 			break;
-		case AHC_DEV_Q_TAGGED:
+		case AIC_DEV_Q_TAGGED:
 			scsi_adjust_queue_depth(dev->scsi_device,
 						MSG_ORDERED_TASK,
 						dev->openings + dev->active);
@@ -2164,9 +2110,9 @@ ahc_platform_abort_scbs(struct ahc_softc
 		for (; targ < maxtarg; targ++) {
 
 			for (; clun < maxlun; clun++) {
-				struct ahc_linux_device *dev;
-				struct ahc_busyq *busyq;
-				struct ahc_cmd *acmd;
+				struct aic_linux_device *dev;
+				struct aic_busyq *busyq;
+				struct aic_cmd *acmd;
 
 				dev = ahc_linux_get_device(ahc, chan,
 							   targ, clun,
@@ -2183,6 +2129,20 @@ ahc_platform_abort_scbs(struct ahc_softc
 						     acmd_links.tqe);
 					count++;
 					cmd->result = status << 16;
+					/*
+					 * The completion handler believes that
+					 * commands without active timers
+					 * running have lost the race of
+					 * completing before their timer
+					 * expires.  Since commands in our
+					 * busy queues do not have timers
+					 * running, appease the mid-layer by
+					 * adding a timer now.  This timer will
+					 * be immediately canceled by the
+					 * midlayer.
+					 */
+					scsi_add_timer(cmd, 60*HZ,
+					    aic_linux_midlayer_timeout);
 					ahc_linux_queue_cmd_complete(ahc, cmd);
 				}
 			}
@@ -2199,7 +2159,7 @@ ahc_linux_thread_run_complete_queue(stru
 
 	ahc_lock(ahc, &flags);
 	del_timer(&ahc->platform_data->completeq_timer);
-	ahc->platform_data->flags &= ~AHC_RUN_CMPLT_Q_TIMER;
+	ahc->platform_data->flags &= ~AIC_RUN_CMPLT_Q_TIMER;
 	ahc_linux_run_complete_queue(ahc);
 	ahc_unlock(ahc, &flags);
 }
@@ -2212,14 +2172,23 @@ ahc_linux_start_dv(struct ahc_softc *ahc
 	 * Freeze the simq and signal ahc_linux_queue to not let any
 	 * more commands through.
 	 */
-	if ((ahc->platform_data->flags & AHC_DV_ACTIVE) == 0) {
+	if ((ahc->platform_data->flags & AIC_DV_ACTIVE) == 0) {
 #ifdef AHC_DEBUG
 		if (ahc_debug & AHC_SHOW_DV)
 			printf("%s: Waking DV thread\n", ahc_name(ahc));
 #endif
 
-		ahc->platform_data->flags |= AHC_DV_ACTIVE;
-		ahc_linux_freeze_simq(ahc);
+		ahc->platform_data->flags |= AIC_DV_ACTIVE;
+
+		/*
+		 * Prevent upper layer from sending any
+		 * commands to us.
+		 */
+		aic_freeze_simq(ahc);
+		scsi_block_requests(ahc->platform_data->host);
+		ahc_platform_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
+					CAM_LUN_WILDCARD, SCB_LIST_NULL,
+					ROLE_INITIATOR, CAM_REQUEUE_REQ);
 
 		/* Wake up the DV kthread */
 		up(&ahc->platform_data->dv_sem);
@@ -2233,7 +2202,7 @@ ahc_linux_kill_dv_thread(struct ahc_soft
 
 	ahc_lock(ahc, &s);
 	if (ahc->platform_data->dv_pid != 0) {
-		ahc->platform_data->flags |= AHC_DV_SHUTDOWN;
+		ahc->platform_data->flags |= AIC_DV_SHUTDOWN;
 		ahc_unlock(ahc, &s);
 		up(&ahc->platform_data->dv_sem);
 
@@ -2308,7 +2277,7 @@ ahc_linux_dv_thread(void *data)
 
 		/* Check to see if we've been signaled to exit */
 		ahc_lock(ahc, &s);
-		if ((ahc->platform_data->flags & AHC_DV_SHUTDOWN) != 0) {
+		if ((ahc->platform_data->flags & AIC_DV_SHUTDOWN) != 0) {
 			ahc_unlock(ahc, &s);
 			break;
 		}
@@ -2325,7 +2294,7 @@ ahc_linux_dv_thread(void *data)
 		 */
 		ahc_lock(ahc, &s);
 		while (LIST_FIRST(&ahc->pending_scbs) != NULL) {
-			ahc->platform_data->flags |= AHC_DV_WAIT_SIMQ_EMPTY;
+			ahc->platform_data->flags |= AIC_DV_WAIT_SIMQ_EMPTY;
 			ahc_unlock(ahc, &s);
 			down_interruptible(&ahc->platform_data->dv_sem);
 			ahc_lock(ahc, &s);
@@ -2335,8 +2304,8 @@ ahc_linux_dv_thread(void *data)
 		 * Wait for the SIMQ to be released so that DV is the
 		 * only reason the queue is frozen.
 		 */
-		while (AHC_DV_SIMQ_FROZEN(ahc) == 0) {
-			ahc->platform_data->flags |= AHC_DV_WAIT_SIMQ_RELEASE;
+		while (AIC_DV_SIMQ_FROZEN(ahc) == 0) {
+			ahc->platform_data->flags |= AIC_DV_WAIT_SIMQ_RELEASE;
 			ahc_unlock(ahc, &s);
 			down_interruptible(&ahc->platform_data->dv_sem);
 			ahc_lock(ahc, &s);
@@ -2347,14 +2316,16 @@ ahc_linux_dv_thread(void *data)
 			ahc_linux_dv_target(ahc, target);
 
 		ahc_lock(ahc, &s);
-		ahc->platform_data->flags &= ~AHC_DV_ACTIVE;
-		ahc_unlock(ahc, &s);
+		ahc->platform_data->flags &= ~AIC_DV_ACTIVE;
 
 		/*
 		 * Release the SIMQ so that normal commands are
 		 * allowed to continue on the bus.
 		 */
-		ahc_linux_release_simq((u_long)ahc);
+		aic_release_simq_locked(ahc);
+		ahc_unlock(ahc, &s);
+
+		scsi_unblock_requests(ahc->platform_data->host);
 	}
 	up(&ahc->platform_data->eh_sem);
 	return (0);
@@ -2368,10 +2339,10 @@ ahc_linux_dv_thread(void *data)
 	ahc_set_dv_state(ahc, targ, newstate, __LINE__)
 
 static __inline void
-ahc_set_dv_state(struct ahc_softc *ahc, struct ahc_linux_target *targ,
-		 ahc_dv_state newstate, u_int line)
+ahc_set_dv_state(struct ahc_softc *ahc, struct aic_linux_target *targ,
+		 aic_dv_state newstate, u_int line)
 {
-	ahc_dv_state oldstate;
+	aic_dv_state oldstate;
 
 	oldstate = targ->dv_state;
 #ifdef AHC_DEBUG
@@ -2391,7 +2362,7 @@ static void
 ahc_linux_dv_target(struct ahc_softc *ahc, u_int target_offset)
 {
 	struct	 ahc_devinfo devinfo;
-	struct	 ahc_linux_target *targ;
+	struct	 aic_linux_target *targ;
 	struct	 scsi_cmnd *cmd;
 	struct	 scsi_device *scsi_dev;
 	struct	 scsi_sense_data *sense;
@@ -2405,7 +2376,7 @@ ahc_linux_dv_target(struct ahc_softc *ah
 	echo_size = 0;
 	ahc_lock(ahc, &s);
 	targ = ahc->platform_data->targets[target_offset];
-	if (targ == NULL || (targ->flags & AHC_DV_REQUIRED) == 0) {
+	if (targ == NULL || (targ->flags & AIC_DV_REQUIRED) == 0) {
 		ahc_unlock(ahc, &s);
 		return;
 	}
@@ -2430,14 +2401,14 @@ ahc_linux_dv_target(struct ahc_softc *ah
 	scsi_dev->channel = devinfo.channel - 'A';
 	ahc->platform_data->dv_scsi_dev = scsi_dev;
 
-	AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_INQ_SHORT_ASYNC);
+	AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_INQ_SHORT_ASYNC);
 
-	while (targ->dv_state != AHC_DV_STATE_EXIT) {
+	while (targ->dv_state != AIC_DV_STATE_EXIT) {
 		timeout = AHC_LINUX_DV_TIMEOUT;
 		switch (targ->dv_state) {
-		case AHC_DV_STATE_INQ_SHORT_ASYNC:
-		case AHC_DV_STATE_INQ_ASYNC:
-		case AHC_DV_STATE_INQ_ASYNC_VERIFY:
+		case AIC_DV_STATE_INQ_SHORT_ASYNC:
+		case AIC_DV_STATE_INQ_ASYNC:
+		case AIC_DV_STATE_INQ_ASYNC_VERIFY:
 			/*
 			 * Set things to async narrow to reduce the
 			 * chance that the INQ will fail.
@@ -2449,36 +2420,36 @@ ahc_linux_dv_target(struct ahc_softc *ah
 				      AHC_TRANS_GOAL, /*paused*/FALSE);
 			ahc_unlock(ahc, &s);
 			timeout = 10 * HZ;
-			targ->flags &= ~AHC_INQ_VALID;
+			targ->flags &= ~AIC_INQ_VALID;
 			/* FALLTHROUGH */
-		case AHC_DV_STATE_INQ_VERIFY:
+		case AIC_DV_STATE_INQ_VERIFY:
 		{
 			u_int inq_len;
 
-			if (targ->dv_state == AHC_DV_STATE_INQ_SHORT_ASYNC)
+			if (targ->dv_state == AIC_DV_STATE_INQ_SHORT_ASYNC)
 				inq_len = AHC_LINUX_DV_INQ_SHORT_LEN;
 			else
 				inq_len = targ->inq_data->additional_length + 5;
 			ahc_linux_dv_inq(ahc, cmd, &devinfo, targ, inq_len);
 			break;
 		}
-		case AHC_DV_STATE_TUR:
-		case AHC_DV_STATE_BUSY:
+		case AIC_DV_STATE_TUR:
+		case AIC_DV_STATE_BUSY:
 			timeout = 5 * HZ;
 			ahc_linux_dv_tur(ahc, cmd, &devinfo);
 			break;
-		case AHC_DV_STATE_REBD:
+		case AIC_DV_STATE_REBD:
 			ahc_linux_dv_rebd(ahc, cmd, &devinfo, targ);
 			break;
-		case AHC_DV_STATE_WEB:
+		case AIC_DV_STATE_WEB:
 			ahc_linux_dv_web(ahc, cmd, &devinfo, targ);
 			break;
 
-		case AHC_DV_STATE_REB:
+		case AIC_DV_STATE_REB:
 			ahc_linux_dv_reb(ahc, cmd, &devinfo, targ);
 			break;
 
-		case AHC_DV_STATE_SU:
+		case AIC_DV_STATE_SU:
 			ahc_linux_dv_su(ahc, cmd, &devinfo, targ);
 			timeout = 50 * HZ;
 			break;
@@ -2490,8 +2461,6 @@ ahc_linux_dv_target(struct ahc_softc *ah
 		}
 
 		/* Queue the command and wait for it to complete */
-		/* Abuse eh_timeout in the scsi_cmnd struct for our purposes */
-		init_timer(&cmd->eh_timeout);
 #ifdef AHC_DEBUG
 		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
 			/*
@@ -2501,20 +2470,22 @@ ahc_linux_dv_target(struct ahc_softc *ah
 			 */
 			timeout += HZ;
 #endif
-		scsi_add_timer(cmd, timeout, ahc_linux_dv_timeout);
+		init_timer(&cmd->eh_timeout);
+		cmd->timeout_per_command = timeout;
+
 		/*
 		 * In 2.5.X, it is assumed that all calls from the
 		 * "midlayer" (which we are emulating) will have the
 		 * ahc host lock held.  For other kernels, the
 		 * io_request_lock must be held.
 		 */
-#if AHC_SCSI_HAS_HOST_LOCK != 0
+#if AIC_SCSI_HAS_HOST_LOCK != 0
 		ahc_lock(ahc, &s);
 #else
 		spin_lock_irqsave(&io_request_lock, s);
 #endif
 		ahc_linux_queue(cmd, ahc_linux_dv_complete);
-#if AHC_SCSI_HAS_HOST_LOCK != 0
+#if AIC_SCSI_HAS_HOST_LOCK != 0
 		ahc_unlock(ahc, &s);
 #else
 		spin_unlock_irqrestore(&io_request_lock, s);
@@ -2525,8 +2496,8 @@ ahc_linux_dv_target(struct ahc_softc *ah
 		 * only reason the queue is frozen.
 		 */
 		ahc_lock(ahc, &s);
-		while (AHC_DV_SIMQ_FROZEN(ahc) == 0) {
-			ahc->platform_data->flags |= AHC_DV_WAIT_SIMQ_RELEASE;
+		while (AIC_DV_SIMQ_FROZEN(ahc) == 0) {
+			ahc->platform_data->flags |= AIC_DV_WAIT_SIMQ_RELEASE;
 			ahc_unlock(ahc, &s);
 			down_interruptible(&ahc->platform_data->dv_sem);
 			ahc_lock(ahc, &s);
@@ -2537,7 +2508,7 @@ ahc_linux_dv_target(struct ahc_softc *ah
 	}
 
 out:
-	if ((targ->flags & AHC_INQ_VALID) != 0
+	if ((targ->flags & AIC_INQ_VALID) != 0
 	 && ahc_linux_get_device(ahc, devinfo.channel - 'A',
 				 devinfo.target, devinfo.lun,
 				 /*alloc*/FALSE) == NULL) {
@@ -2548,7 +2519,7 @@ out:
 		 * parameters found in the inquiry string.
 		 */
 		ahc_linux_filter_inquiry(ahc, &devinfo);
-		if ((targ->flags & (AHC_BASIC_DV|AHC_ENHANCED_DV)) != 0) {
+		if ((targ->flags & (AIC_BASIC_DV|AIC_ENHANCED_DV)) != 0) {
 			ahc_print_devinfo(ahc, &devinfo);
 			printf("DV failed to configure device.  "
 			       "Please file a bug report against "
@@ -2573,7 +2544,7 @@ out:
 		free(targ->dv_buffer1, M_DEVBUF);
 		targ->dv_buffer1 = NULL;
 	}
-	targ->flags &= ~AHC_DV_REQUIRED;
+	targ->flags &= ~AIC_DV_REQUIRED;
 	if (targ->refcount == 0)
 		ahc_linux_free_target(ahc, targ);
 	ahc_unlock(ahc, &s);
@@ -2582,13 +2553,13 @@ out:
 static void
 ahc_linux_dv_transition(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
 			struct ahc_devinfo *devinfo,
-			struct ahc_linux_target *targ)
+			struct aic_linux_target *targ)
 {
 	u_int32_t status;
 
 	status = aic_error_action(cmd, targ->inq_data,
-				  ahc_cmd_get_transaction_status(cmd),
-				  ahc_cmd_get_scsi_status(cmd));
+				  aic_cmd_get_transaction_status(cmd),
+				  aic_cmd_get_scsi_status(cmd));
 	
 #ifdef AHC_DEBUG
 	if (ahc_debug & AHC_SHOW_DV) {
@@ -2600,8 +2571,8 @@ ahc_linux_dv_transition(struct ahc_softc
 #endif
 
 	switch (targ->dv_state) {
-	case AHC_DV_STATE_INQ_SHORT_ASYNC:
-	case AHC_DV_STATE_INQ_ASYNC:
+	case AIC_DV_STATE_INQ_SHORT_ASYNC:
+	case AIC_DV_STATE_INQ_ASYNC:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		{
@@ -2610,21 +2581,21 @@ ahc_linux_dv_transition(struct ahc_softc
 		}
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_TUR:
 		case SS_RETRY:
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
-			if (ahc_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ)
 				targ->dv_state_retry--;
 			if ((status & SS_ERRMASK) == EBUSY)
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_BUSY);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_BUSY);
 			if (targ->dv_state_retry < 10)
 				break;
 			/* FALLTHROUGH */
 		default:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 #ifdef AHC_DEBUG
 			if (ahc_debug & AHC_SHOW_DV) {
 				ahc_print_devinfo(ahc, devinfo);
@@ -2634,7 +2605,7 @@ ahc_linux_dv_transition(struct ahc_softc
 			break;
 		}
 		break;
-	case AHC_DV_STATE_INQ_ASYNC_VERIFY:
+	case AIC_DV_STATE_INQ_ASYNC_VERIFY:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		{
@@ -2648,12 +2619,12 @@ ahc_linux_dv_transition(struct ahc_softc
 				 * Try from the top again.
 				 */
 				AHC_SET_DV_STATE(ahc, targ,
-						 AHC_DV_STATE_INQ_SHORT_ASYNC);
+						 AIC_DV_STATE_INQ_SHORT_ASYNC);
 				break;
 			}
 
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state+1);
-			targ->flags |= AHC_INQ_VALID;
+			targ->flags |= AIC_INQ_VALID;
 			if (ahc_linux_user_dv_setting(ahc) == 0)
 				break;
 
@@ -2666,33 +2637,33 @@ ahc_linux_dv_transition(struct ahc_softc
 			default:
 			case SID_SPI_CLOCK_ST:
 				/* Assume only basic DV is supported. */
-				targ->flags |= AHC_BASIC_DV;
+				targ->flags |= AIC_BASIC_DV;
 				break;
 			case SID_SPI_CLOCK_DT:
 			case SID_SPI_CLOCK_DT_ST:
-				targ->flags |= AHC_ENHANCED_DV;
+				targ->flags |= AIC_ENHANCED_DV;
 				break;
 			}
 			break;
 		}
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_TUR:
 		case SS_RETRY:
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
-			if (ahc_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ)
 				targ->dv_state_retry--;
 
 			if ((status & SS_ERRMASK) == EBUSY)
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_BUSY);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_BUSY);
 			if (targ->dv_state_retry < 10)
 				break;
 			/* FALLTHROUGH */
 		default:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 #ifdef AHC_DEBUG
 			if (ahc_debug & AHC_SHOW_DV) {
 				ahc_print_devinfo(ahc, devinfo);
@@ -2702,14 +2673,14 @@ ahc_linux_dv_transition(struct ahc_softc
 			break;
 		}
 		break;
-	case AHC_DV_STATE_INQ_VERIFY:
+	case AIC_DV_STATE_INQ_VERIFY:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		{
 
 			if (memcmp(targ->inq_data, targ->dv_buffer,
 				   AHC_LINUX_DV_INQ_LEN) == 0) {
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 				break;
 			}
 #ifdef AHC_DEBUG
@@ -2730,7 +2701,7 @@ ahc_linux_dv_transition(struct ahc_softc
 #endif
 
 			if (ahc_linux_fallback(ahc, devinfo) != 0) {
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 				break;
 			}
 			/*
@@ -2743,18 +2714,18 @@ ahc_linux_dv_transition(struct ahc_softc
 		}
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_TUR:
 		case SS_RETRY:
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
-			if (ahc_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if ((status & SSQ_FALLBACK) != 0) {
 				if (ahc_linux_fallback(ahc, devinfo) != 0) {
 					AHC_SET_DV_STATE(ahc, targ,
-							 AHC_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 					break;
 				}
 				/*
@@ -2763,12 +2734,12 @@ ahc_linux_dv_transition(struct ahc_softc
 				 */
 				targ->dv_state_retry = 0;
 			} else if ((status & SS_ERRMASK) == EBUSY)
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_BUSY);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_BUSY);
 			if (targ->dv_state_retry < 10)
 				break;
 			/* FALLTHROUGH */
 		default:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 #ifdef AHC_DEBUG
 			if (ahc_debug & AHC_SHOW_DV) {
 				ahc_print_devinfo(ahc, devinfo);
@@ -2779,33 +2750,33 @@ ahc_linux_dv_transition(struct ahc_softc
 		}
 		break;
 
-	case AHC_DV_STATE_TUR:
+	case AIC_DV_STATE_TUR:
 		switch (status & SS_MASK) {
 		case SS_NOP:
-			if ((targ->flags & AHC_BASIC_DV) != 0) {
+			if ((targ->flags & AIC_BASIC_DV) != 0) {
 				ahc_linux_filter_inquiry(ahc, devinfo);
 				AHC_SET_DV_STATE(ahc, targ,
-						 AHC_DV_STATE_INQ_VERIFY);
-			} else if ((targ->flags & AHC_ENHANCED_DV) != 0) {
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_REBD);
+						 AIC_DV_STATE_INQ_VERIFY);
+			} else if ((targ->flags & AIC_ENHANCED_DV) != 0) {
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_REBD);
 			} else {
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 			}
 			break;
 		case SS_RETRY:
 		case SS_TUR:
 			if ((status & SS_ERRMASK) == EBUSY) {
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_BUSY);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_BUSY);
 				break;
 			}
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
-			if (ahc_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if ((status & SSQ_FALLBACK) != 0) {
 				if (ahc_linux_fallback(ahc, devinfo) != 0) {
 					AHC_SET_DV_STATE(ahc, targ,
-							 AHC_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 					break;
 				}
 				/*
@@ -2821,7 +2792,7 @@ ahc_linux_dv_transition(struct ahc_softc
 					printf("DV TUR reties exhausted\n");
 				}
 #endif
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 				break;
 			}
 			if (status & SSQ_DELAY)
@@ -2829,25 +2800,25 @@ ahc_linux_dv_transition(struct ahc_softc
 
 			break;
 		case SS_START:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_SU);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_SU);
 			break;
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		default:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
 
-	case AHC_DV_STATE_REBD:
+	case AIC_DV_STATE_REBD:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		{
 			uint32_t echo_size;
 
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_WEB);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_WEB);
 			echo_size = scsi_3btoul(&targ->dv_buffer[1]);
 			echo_size &= 0x1FFF;
 #ifdef AHC_DEBUG
@@ -2857,7 +2828,17 @@ ahc_linux_dv_transition(struct ahc_softc
 			}
 #endif
 			if (echo_size == 0) {
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				/*
+				 * Fall back to basic DV.
+				 */
+				if (bootverbose) {
+					ahc_print_devinfo(ahc, devinfo);
+					printf("Echo Buffer unavailable.  "
+					       "Performing basic DV.\n");
+				}
+				targ->flags &= ~AIC_ENHANCED_DV;
+				targ->flags |= AIC_BASIC_DV;
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_TUR);
 				break;
 			}
 
@@ -2872,11 +2853,11 @@ ahc_linux_dv_transition(struct ahc_softc
 		}
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_RETRY:
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
-			if (ahc_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ)
 				targ->dv_state_retry--;
 			if (targ->dv_state_retry <= 10)
@@ -2895,30 +2876,30 @@ ahc_linux_dv_transition(struct ahc_softc
 			 * and try level 1 DV.
 			 */
 			ahc_linux_filter_inquiry(ahc, devinfo);
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_INQ_VERIFY);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_INQ_VERIFY);
 			targ->dv_echo_size = 0;
 			break;
 		}
 		break;
 
-	case AHC_DV_STATE_WEB:
+	case AIC_DV_STATE_WEB:
 		switch (status & SS_MASK) {
 		case SS_NOP:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_REB);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_REB);
 			break;
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_RETRY:
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
-			if (ahc_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if ((status & SSQ_FALLBACK) != 0) {
 				if (ahc_linux_fallback(ahc, devinfo) != 0) {
 					AHC_SET_DV_STATE(ahc, targ,
-							 AHC_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 					break;
 				}
 				/*
@@ -2937,22 +2918,22 @@ ahc_linux_dv_transition(struct ahc_softc
 			}
 #endif
 		default:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
 
-	case AHC_DV_STATE_REB:
+	case AIC_DV_STATE_REB:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 			if (memcmp(targ->dv_buffer, targ->dv_buffer1,
 				   targ->dv_echo_size) != 0) {
 				if (ahc_linux_fallback(ahc, devinfo) != 0)
 					AHC_SET_DV_STATE(ahc, targ,
-							 AHC_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 				else
 					AHC_SET_DV_STATE(ahc, targ,
-							 AHC_DV_STATE_WEB);
+							 AIC_DV_STATE_WEB);
 				break;
 			}
 			
@@ -2964,24 +2945,24 @@ ahc_linux_dv_transition(struct ahc_softc
 				free(targ->dv_buffer1, M_DEVBUF);
 				targ->dv_buffer1 = NULL;
 			}
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 			break;
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_RETRY:
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
-			if (ahc_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if ((status & SSQ_FALLBACK) != 0) {
 				if (ahc_linux_fallback(ahc, devinfo) != 0) {
 					AHC_SET_DV_STATE(ahc, targ,
-							 AHC_DV_STATE_EXIT);
+							 AIC_DV_STATE_EXIT);
 					break;
 				}
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_WEB);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_WEB);
 			}
 			if (targ->dv_state_retry <= 10) {
 				if ((status & (SSQ_DELAY_RANDOM|SSQ_DELAY))!= 0)
@@ -2996,35 +2977,35 @@ ahc_linux_dv_transition(struct ahc_softc
 #endif
 			/* FALLTHROUGH */
 		default:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
 
-	case AHC_DV_STATE_SU:
+	case AIC_DV_STATE_SU:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		default:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
 
-	case AHC_DV_STATE_BUSY:
+	case AIC_DV_STATE_BUSY:
 		switch (status & SS_MASK) {
 		case SS_NOP:
 		case SS_INQ_REFRESH:
 			AHC_SET_DV_STATE(ahc, targ,
-					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+					 AIC_DV_STATE_INQ_SHORT_ASYNC);
 			break;
 		case SS_TUR:
 		case SS_RETRY:
 			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
-			if (ahc_cmd_get_transaction_status(cmd)
+			if (aic_cmd_get_transaction_status(cmd)
 			 == CAM_REQUEUE_REQ) {
 				targ->dv_state_retry--;
 			} else if (targ->dv_state_retry < 60) {
@@ -3037,11 +3018,11 @@ ahc_linux_dv_transition(struct ahc_softc
 					printf("DV BUSY reties exhausted\n");
 				}
 #endif
-				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 			}
 			break;
 		default:
-			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 			break;
 		}
 		break;
@@ -3049,7 +3030,7 @@ ahc_linux_dv_transition(struct ahc_softc
 	default:
 		printf("%s: Invalid DV completion state %d\n", ahc_name(ahc),
 		       targ->dv_state);
-		AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+		AHC_SET_DV_STATE(ahc, targ, AIC_DV_STATE_EXIT);
 		break;
 	}
 }
@@ -3069,7 +3050,7 @@ ahc_linux_dv_fill_cmd(struct ahc_softc *
  */
 static void
 ahc_linux_dv_inq(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
-		 struct ahc_devinfo *devinfo, struct ahc_linux_target *targ,
+		 struct ahc_devinfo *devinfo, struct aic_linux_target *targ,
 		 u_int request_length)
 {
 
@@ -3082,7 +3063,7 @@ ahc_linux_dv_inq(struct ahc_softc *ahc, 
 	if (targ->inq_data == NULL)
 		targ->inq_data = malloc(AHC_LINUX_DV_INQ_LEN,
 					M_DEVBUF, M_WAITOK);
-	if (targ->dv_state > AHC_DV_STATE_INQ_ASYNC) {
+	if (targ->dv_state > AIC_DV_STATE_INQ_ASYNC) {
 		if (targ->dv_buffer != NULL)
 			free(targ->dv_buffer, M_DEVBUF);
 		targ->dv_buffer = malloc(AHC_LINUX_DV_INQ_LEN,
@@ -3095,7 +3076,7 @@ ahc_linux_dv_inq(struct ahc_softc *ahc, 
 	cmd->cmnd[0] = INQUIRY;
 	cmd->cmnd[4] = request_length;
 	cmd->request_bufflen = request_length;
-	if (targ->dv_state > AHC_DV_STATE_INQ_ASYNC)
+	if (targ->dv_state > AIC_DV_STATE_INQ_ASYNC)
 		cmd->request_buffer = targ->dv_buffer;
 	else
 		cmd->request_buffer = targ->inq_data;
@@ -3124,7 +3105,7 @@ ahc_linux_dv_tur(struct ahc_softc *ahc, 
 
 static void
 ahc_linux_dv_rebd(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
-		 struct ahc_devinfo *devinfo, struct ahc_linux_target *targ)
+		 struct ahc_devinfo *devinfo, struct aic_linux_target *targ)
 {
 
 #ifdef AHC_DEBUG
@@ -3149,7 +3130,7 @@ ahc_linux_dv_rebd(struct ahc_softc *ahc,
 
 static void
 ahc_linux_dv_web(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
-		 struct ahc_devinfo *devinfo, struct ahc_linux_target *targ)
+		 struct ahc_devinfo *devinfo, struct aic_linux_target *targ)
 {
 
 #ifdef AHC_DEBUG
@@ -3171,7 +3152,7 @@ ahc_linux_dv_web(struct ahc_softc *ahc, 
 
 static void
 ahc_linux_dv_reb(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
-		 struct ahc_devinfo *devinfo, struct ahc_linux_target *targ)
+		 struct ahc_devinfo *devinfo, struct aic_linux_target *targ)
 {
 
 #ifdef AHC_DEBUG
@@ -3194,7 +3175,7 @@ ahc_linux_dv_reb(struct ahc_softc *ahc, 
 static void
 ahc_linux_dv_su(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
 		struct ahc_devinfo *devinfo,
-		struct ahc_linux_target *targ)
+		struct aic_linux_target *targ)
 {
 	u_int le;
 
@@ -3216,7 +3197,7 @@ ahc_linux_dv_su(struct ahc_softc *ahc, s
 static int
 ahc_linux_fallback(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
 {
-	struct	ahc_linux_target *targ;
+	struct	aic_linux_target *targ;
 	struct	ahc_initiator_tinfo *tinfo;
 	struct	ahc_transinfo *goal;
 	struct	ahc_tmode_tstate *tstate;
@@ -3395,7 +3376,7 @@ ahc_linux_fallback(struct ahc_softc *ahc
 	return (0);
 }
 
-static void
+void
 ahc_linux_dv_timeout(struct scsi_cmnd *cmd)
 {
 	struct	ahc_softc *ahc;
@@ -3429,29 +3410,19 @@ ahc_linux_dv_timeout(struct scsi_cmnd *c
 	 * error code.
 	 */
 	if ((scb->flags & SCB_SENSE) != 0)
-		ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+		aic_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
 	else
-		ahc_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+		aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);
 	ahc_reset_channel(ahc, cmd->device->channel + 'A', /*initiate*/TRUE);
 
-	/*
-	 * Add a minimal bus settle delay for devices that are slow to
-	 * respond after bus resets.
-	 */
-	ahc_linux_freeze_simq(ahc);
-	init_timer(&ahc->platform_data->reset_timer);
-	ahc->platform_data->reset_timer.data = (u_long)ahc;
-	ahc->platform_data->reset_timer.expires = jiffies + HZ / 2;
-	ahc->platform_data->reset_timer.function =
-	    (ahc_linux_callback_t *)ahc_linux_release_simq;
-	add_timer(&ahc->platform_data->reset_timer);
-	if (ahc_linux_next_device_to_run(ahc) != NULL)
-		ahc_schedule_runq(ahc);
+	if (aic_linux_next_device_to_run(ahc) != NULL)
+		aic_schedule_runq(ahc);
+
 	ahc_linux_run_complete_queue(ahc);
 	ahc_unlock(ahc, &flags);
 }
 
-static void
+void
 ahc_linux_dv_complete(struct scsi_cmnd *cmd)
 {
 	struct ahc_softc *ahc;
@@ -3473,7 +3444,7 @@ ahc_linux_dv_complete(struct scsi_cmnd *
 }
 
 static void
-ahc_linux_generate_dv_pattern(struct ahc_linux_target *targ)
+ahc_linux_generate_dv_pattern(struct aic_linux_target *targ)
 {
 	uint16_t b;
 	u_int	 i;
@@ -3605,8 +3576,8 @@ ahc_linux_user_dv_setting(struct ahc_sof
  * Determines the queue depth for a given device.
  */
 static void
-ahc_linux_device_queue_depth(struct ahc_softc *ahc,
-			     struct ahc_linux_device *dev)
+aic_linux_device_queue_depth(struct ahc_softc *ahc,
+			     struct aic_linux_device *dev)
 {
 	struct	ahc_devinfo devinfo;
 	u_int	tags;
@@ -3630,10 +3601,10 @@ ahc_linux_device_queue_depth(struct ahc_
 	}
 }
 
-static void
-ahc_linux_run_device_queue(struct ahc_softc *ahc, struct ahc_linux_device *dev)
+void
+ahc_linux_run_device_queue(struct ahc_softc *ahc, struct aic_linux_device *dev)
 {
-	struct	 ahc_cmd *acmd;
+	struct	 aic_cmd *acmd;
 	struct	 scsi_cmnd *cmd;
 	struct	 scb *scb;
 	struct	 hardware_scb *hscb;
@@ -3641,21 +3612,22 @@ ahc_linux_run_device_queue(struct ahc_so
 	struct	 ahc_tmode_tstate *tstate;
 	uint16_t mask;
 
-	if ((dev->flags & AHC_DEV_ON_RUN_LIST) != 0)
+	if ((dev->flags & AIC_DEV_ON_RUN_LIST) != 0)
 		panic("running device on run list");
 
 	while ((acmd = TAILQ_FIRST(&dev->busyq)) != NULL
-	    && dev->openings > 0 && dev->qfrozen == 0) {
+	    && dev->openings > 0 && dev->qfrozen == 0
+	    && dev->target->qfrozen == 0) {
 
 		/*
 		 * Schedule us to run later.  The only reason we are not
 		 * running is because the whole controller Q is frozen.
 		 */
 		if (ahc->platform_data->qfrozen != 0
-	 	 && AHC_DV_SIMQ_FROZEN(ahc) == 0) {
+	 	 && AIC_DV_SIMQ_FROZEN(ahc) == 0) {
 			TAILQ_INSERT_TAIL(&ahc->platform_data->device_runq,
 					  dev, links);
-			dev->flags |= AHC_DEV_ON_RUN_LIST;
+			dev->flags |= AIC_DEV_ON_RUN_LIST;
 			return;
 		}
 		/*
@@ -3664,14 +3636,16 @@ ahc_linux_run_device_queue(struct ahc_so
 		if ((scb = ahc_get_scb(ahc)) == NULL) {
 			TAILQ_INSERT_TAIL(&ahc->platform_data->device_runq,
 					 dev, links);
-			dev->flags |= AHC_DEV_ON_RUN_LIST;
-			ahc->flags |= AHC_RESOURCE_SHORTAGE;
+			dev->flags |= AIC_DEV_ON_RUN_LIST;
+			ahc->flags |= AIC_RESOURCE_SHORTAGE;
+			ahc->platform_data->qfrozen++;
 			return;
 		}
 		TAILQ_REMOVE(&dev->busyq, acmd, acmd_links.tqe);
 		cmd = &acmd_scsi_cmd(acmd);
 		scb->io_ctx = cmd;
 		scb->platform_data->dev = dev;
+		scb->platform_data->flags = 0;
 		hscb = scb->hscb;
 		cmd->host_scribble = (char *)scb;
 
@@ -3693,15 +3667,37 @@ ahc_linux_run_device_queue(struct ahc_so
 		if ((ahc->user_discenable & mask) != 0)
 			hscb->control |= DISCENB;
 
-	 	if (AHC_DV_CMD(cmd) != 0)
+	 	if (AIC_DV_CMD(cmd) != 0)
 			scb->flags |= SCB_SILENT;
 
 		if ((tstate->auto_negotiate & mask) != 0) {
 			scb->flags |= SCB_AUTO_NEGOTIATE;
 			scb->hscb->control |= MK_MESSAGE;
+		} else if (cmd->cmnd[0] == INQUIRY
+			&& (tinfo->curr.offset != 0
+			 || tinfo->curr.width != MSG_EXT_WDTR_BUS_8_BIT)) {
+			/*
+			 * The SCSI spec requires inquiry
+			 * commands to complete without
+			 * reporting unit attention conditions.
+			 * Because of this, an inquiry command
+			 * that occurs just after a device is
+			 * reset will result in a data phase
+			 * with mismatched negotiated rates.
+			 * The core already forces a renegotiation
+			 * for reset events that are visible to
+			 * our controller or that we initiate,
+			 * but a third party device reset or a
+			 * hot-plug insertion can still cause this
+			 * issue.  Therefore, we force a re-negotiation
+			 * for every inquiry command unless we
+			 * are async.
+			 */
+			scb->flags |= SCB_NEGOTIATE;
+			scb->hscb->control |= MK_MESSAGE;
 		}
 
-		if ((dev->flags & (AHC_DEV_Q_TAGGED|AHC_DEV_Q_BASIC)) != 0) {
+		if ((dev->flags & (AIC_DEV_Q_TAGGED|AIC_DEV_Q_BASIC)) != 0) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 			int	msg_bytes;
 			uint8_t tag_msgs[2];
@@ -3713,8 +3709,8 @@ ahc_linux_run_device_queue(struct ahc_so
 					dev->commands_since_idle_or_otag = 0;
 			} else
 #endif
-			if (dev->commands_since_idle_or_otag == AHC_OTAG_THRESH
-			 && (dev->flags & AHC_DEV_Q_TAGGED) != 0) {
+			if (dev->commands_since_idle_or_otag == AIC_OTAG_THRESH
+			 && (dev->flags & AIC_DEV_Q_TAGGED) != 0) {
 				hscb->control |= MSG_ORDERED_TASK;
 				dev->commands_since_idle_or_otag = 0;
 			} else {
@@ -3731,8 +3727,8 @@ ahc_linux_run_device_queue(struct ahc_so
 		}
 
 		scb->platform_data->xfer_len = 0;
-		ahc_set_residual(scb, 0);
-		ahc_set_sense_residual(scb, 0);
+		aic_set_residual(scb, 0);
+		aic_set_sense_residual(scb, 0);
 		scb->sg_count = 0;
 		if (cmd->use_sg != 0) {
 			struct	ahc_dma_seg *sg;
@@ -3741,7 +3737,7 @@ ahc_linux_run_device_queue(struct ahc_so
 			int	nseg;
 
 			cur_seg = (struct scatterlist *)cmd->request_buffer;
-			nseg = pci_map_sg(ahc->dev_softc, cur_seg, cmd->use_sg,
+			nseg = aic_map_sg(ahc, cur_seg, cmd->use_sg,
 			    scsi_to_pci_dma_dir(cmd->sc_data_direction));
 			end_seg = cur_seg + nseg;
 			/* Copy the segments into the SG list. */
@@ -3764,13 +3760,13 @@ ahc_linux_run_device_queue(struct ahc_so
 				cur_seg++;
 			}
 			sg--;
-			sg->len |= ahc_htole32(AHC_DMA_LAST_SEG);
+			sg->len |= aic_htole32(AHC_DMA_LAST_SEG);
 
 			/*
 			 * Reset the sg list pointer.
 			 */
 			scb->hscb->sgptr =
-			    ahc_htole32(scb->sg_list_phys | SG_FULL_RESID);
+			    aic_htole32(scb->sg_list_phys | SG_FULL_RESID);
 
 			/*
 			 * Copy the first SG into the "current"
@@ -3783,7 +3779,7 @@ ahc_linux_run_device_queue(struct ahc_so
 			bus_addr_t addr;
 
 			sg = scb->sg_list;
-			addr = pci_map_single(ahc->dev_softc,
+			addr = aic_map_single(ahc,
 			       cmd->request_buffer,
 			       cmd->request_bufflen,
 			       scsi_to_pci_dma_dir(cmd->sc_data_direction));
@@ -3791,13 +3787,13 @@ ahc_linux_run_device_queue(struct ahc_so
 			scb->sg_count = ahc_linux_map_seg(ahc, scb,
 							  sg, addr,
 							  cmd->request_bufflen);
-			sg->len |= ahc_htole32(AHC_DMA_LAST_SEG);
+			sg->len |= aic_htole32(AHC_DMA_LAST_SEG);
 
 			/*
 			 * Reset the sg list pointer.
 			 */
 			scb->hscb->sgptr =
-			    ahc_htole32(scb->sg_list_phys | SG_FULL_RESID);
+			    aic_htole32(scb->sg_list_phys | SG_FULL_RESID);
 
 			/*
 			 * Copy the first SG into the "current"
@@ -3806,7 +3802,7 @@ ahc_linux_run_device_queue(struct ahc_so
 			scb->hscb->dataptr = sg->addr;
 			scb->hscb->datacnt = sg->len;
 		} else {
-			scb->hscb->sgptr = ahc_htole32(SG_LIST_NULL);
+			scb->hscb->sgptr = aic_htole32(SG_LIST_NULL);
 			scb->hscb->dataptr = 0;
 			scb->hscb->datacnt = 0;
 			scb->sg_count = 0;
@@ -3817,7 +3813,7 @@ ahc_linux_run_device_queue(struct ahc_so
 		dev->openings--;
 		dev->active++;
 		dev->commands_issued++;
-		if ((dev->flags & AHC_DEV_PERIODIC_OTAG) != 0)
+		if ((dev->flags & AIC_DEV_PERIODIC_OTAG) != 0)
 			dev->commands_since_idle_or_otag++;
 
 		/*
@@ -3839,6 +3835,7 @@ ahc_linux_run_device_queue(struct ahc_so
 				continue;
 		}
 		scb->flags |= SCB_ACTIVE;
+		aic_scb_timer_start(scb);
 		ahc_queue_scb(ahc, scb);
 	}
 }
@@ -3856,8 +3853,8 @@ ahc_linux_isr(int irq, void *dev_id, str
 	ahc = (struct ahc_softc *) dev_id;
 	ahc_lock(ahc, &flags); 
 	ours = ahc_intr(ahc);
-	if (ahc_linux_next_device_to_run(ahc) != NULL)
-		ahc_schedule_runq(ahc);
+	if (aic_linux_next_device_to_run(ahc) != NULL)
+		aic_schedule_runq(ahc);
 	ahc_linux_run_complete_queue(ahc);
 	ahc_unlock(ahc, &flags);
 	return IRQ_RETVAL(ours);
@@ -3871,10 +3868,10 @@ ahc_platform_flushwork(struct ahc_softc 
 		;
 }
 
-static struct ahc_linux_target*
+static struct aic_linux_target*
 ahc_linux_alloc_target(struct ahc_softc *ahc, u_int channel, u_int target)
 {
-	struct ahc_linux_target *targ;
+	struct aic_linux_target *targ;
 	u_int target_offset;
 
 	target_offset = target;
@@ -3887,14 +3884,15 @@ ahc_linux_alloc_target(struct ahc_softc 
 	memset(targ, 0, sizeof(*targ));
 	targ->channel = channel;
 	targ->target = target;
-	targ->ahc = ahc;
-	targ->flags = AHC_DV_REQUIRED;
+	targ->softc = ahc;
+	targ->flags = AIC_DV_REQUIRED;
+	init_timer(&targ->timer);
 	ahc->platform_data->targets[target_offset] = targ;
 	return (targ);
 }
 
 static void
-ahc_linux_free_target(struct ahc_softc *ahc, struct ahc_linux_target *targ)
+ahc_linux_free_target(struct ahc_softc *ahc, struct aic_linux_target *targ)
 {
 	struct ahc_devinfo devinfo;
 	struct ahc_initiator_tinfo *tinfo;
@@ -3934,11 +3932,11 @@ ahc_linux_free_target(struct ahc_softc *
 	free(targ, M_DEVBUF);
 }
 
-static struct ahc_linux_device*
+static struct aic_linux_device*
 ahc_linux_alloc_device(struct ahc_softc *ahc,
-		 struct ahc_linux_target *targ, u_int lun)
+		 struct aic_linux_target *targ, u_int lun)
 {
-	struct ahc_linux_device *dev;
+	struct aic_linux_device *dev;
 
 	dev = malloc(sizeof(*dev), M_DEVBUG, M_NOWAIT);
 	if (dev == NULL)
@@ -3946,7 +3944,7 @@ ahc_linux_alloc_device(struct ahc_softc 
 	memset(dev, 0, sizeof(*dev));
 	init_timer(&dev->timer);
 	TAILQ_INIT(&dev->busyq);
-	dev->flags = AHC_DEV_UNCONFIGURED;
+	dev->flags = AIC_DEV_UNCONFIGURED;
 	dev->lun = lun;
 	dev->target = targ;
 
@@ -3962,24 +3960,23 @@ ahc_linux_alloc_device(struct ahc_softc 
 	 * a tagged queuing capable device.
 	 */
 	dev->maxtags = 0;
-	
+
 	targ->refcount++;
 	targ->devices[lun] = dev;
 	return (dev);
 }
 
 static void
-ahc_linux_free_device(struct ahc_softc *ahc, struct ahc_linux_device *dev)
+ahc_linux_free_device(struct ahc_softc *ahc, struct aic_linux_device *dev)
 {
-	struct ahc_linux_target *targ;
+	struct aic_linux_target *targ;
 
-	del_timer_sync(&dev->timer);
 	targ = dev->target;
 	targ->devices[dev->lun] = NULL;
 	free(dev, M_DEVBUF);
 	targ->refcount--;
 	if (targ->refcount == 0
-	 && (targ->flags & AHC_DV_REQUIRED) == 0)
+	 && (targ->flags & AIC_DV_REQUIRED) == 0)
 		ahc_linux_free_target(ahc, targ);
 }
 
@@ -3991,7 +3988,7 @@ ahc_send_async(struct ahc_softc *ahc, ch
 	case AC_TRANSFER_NEG:
 	{
 		char	buf[80];
-		struct	ahc_linux_target *targ;
+		struct	aic_linux_target *targ;
 		struct	info_str info;
 		struct	ahc_initiator_tinfo *tinfo;
 		struct	ahc_tmode_tstate *tstate;
@@ -4054,11 +4051,14 @@ ahc_send_async(struct ahc_softc *ahc, ch
 	}
         case AC_SENT_BDR:
 	{
+		struct	aic_linux_target *targ;
+		int	target_offset;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+
 		WARN_ON(lun != CAM_LUN_WILDCARD);
 		scsi_report_device_reset(ahc->platform_data->host,
 					 channel - 'A', target);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 		Scsi_Device *scsi_dev;
 
 		/*
@@ -4076,15 +4076,57 @@ ahc_send_async(struct ahc_softc *ahc, ch
 			}
 		}
 #endif
+		/*
+		 * Freeze the target for a 500ms to give the
+		 * target some time to recover from this BDR.
+		 */
+		target_offset = target;
+		if (channel == 'B')
+			target_offset += 8;
+		targ = ahc->platform_data->targets[target_offset];
+		if (targ == NULL)
+			break;
+		if ((targ->flags & AIC_TARG_TIMER_ACTIVE) != 0) {
+			printf("%s:%c:%d: Target Timer still active during "
+			       "BDR processing\n", ahc_name(ahc),
+				targ->channel, targ->target);
+			break;
+		}
+		/*
+		 * Keep the reference count non-zero during
+		 * the lifetime of the timer.  This
+		 * guarantees that the target will not
+		 * be freed before our timer executes.
+		 */
+		targ->refcount++;
+		targ->flags |= AIC_TARG_TIMER_ACTIVE;
+		targ->qfrozen++;
+		init_timer(&targ->timer);
+		targ->timer.data = (u_long)targ;
+		targ->timer.expires = jiffies + (HZ/2);
+		targ->timer.function = ahc_linux_targ_timed_unfreeze;
+		add_timer(&targ->timer);
 		break;
 	}
         case AC_BUS_RESET:
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
 		if (ahc->platform_data->host != NULL) {
 			scsi_report_bus_reset(ahc->platform_data->host,
 					      channel - 'A');
 		}
-#endif
+		/*
+		 * Add a minimal bus settle delay for devices that are slow to
+		 * respond after bus resets.
+		 */
+		if ((ahc->platform_data->flags & AIC_BUS_SETTLE_TIMER) == 0) {
+			aic_freeze_simq(ahc);
+			ahc->platform_data->flags |= AIC_BUS_SETTLE_TIMER;
+			ahc->platform_data->bus_settle_timer.expires =
+			    jiffies + (AIC7XXX_RESET_DELAY * HZ)/1000;
+			add_timer(&ahc->platform_data->bus_settle_timer);
+		} else {
+			mod_timer(&ahc->platform_data->bus_settle_timer,
+				  jiffies + (AIC7XXX_RESET_DELAY * HZ)/1000);
+		}
                 break;
         default:
                 panic("ahc_send_async: Unexpected async event");
@@ -4098,9 +4140,11 @@ void
 ahc_done(struct ahc_softc *ahc, struct scb *scb)
 {
 	Scsi_Cmnd *cmd;
-	struct	   ahc_linux_device *dev;
+	struct	   aic_linux_device *dev;
 
 	LIST_REMOVE(scb, pending_links);
+	if ((scb->flags & SCB_TIMEDOUT) != 0)
+		LIST_REMOVE(scb, timedout_links);
 	if ((scb->flags & SCB_UNTAGGEDQ) != 0) {
 		struct scb_tailq *untagged_q;
 		int target_offset;
@@ -4109,13 +4153,17 @@ ahc_done(struct ahc_softc *ahc, struct s
 		untagged_q = &(ahc->untagged_queues[target_offset]);
 		TAILQ_REMOVE(untagged_q, scb, links.tqe);
 		ahc_run_untagged_queue(ahc, untagged_q);
-	}
-
-	if ((scb->flags & SCB_ACTIVE) == 0) {
+	} else if ((scb->flags & SCB_ACTIVE) == 0) {
+		/*
+		 * Transactions aborted from the untagged queue may
+		 * not have been dispatched to the controller, so
+		 * only check the SCB_ACTIVE flag for tagged transactions.
+		 */
 		printf("SCB %d done'd twice\n", scb->hscb->tag);
 		ahc_dump_card_state(ahc);
 		panic("Stopping for safety");
 	}
+
 	cmd = scb->io_ctx;
 	dev = scb->platform_data->dev;
 	dev->active--;
@@ -4133,11 +4181,11 @@ ahc_done(struct ahc_softc *ahc, struct s
 	 * the sense buffer looks "sane".
 	 */
 	cmd->sense_buffer[0] = 0;
-	if (ahc_get_transaction_status(scb) == CAM_REQ_INPROG) {
+	if (aic_get_transaction_status(scb) == CAM_REQ_INPROG) {
 		uint32_t amount_xferred;
 
 		amount_xferred =
-		    ahc_get_transfer_length(scb) - ahc_get_residual(scb);
+		    aic_get_transfer_length(scb) - aic_get_residual(scb);
 		if ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {
 #ifdef AHC_DEBUG
 			if ((ahc_debug & AHC_SHOW_MISC) != 0) {
@@ -4145,7 +4193,7 @@ ahc_done(struct ahc_softc *ahc, struct s
 				printf("Set CAM_UNCOR_PARITY\n");
 			}
 #endif
-			ahc_set_transaction_status(scb, CAM_UNCOR_PARITY);
+			aic_set_transaction_status(scb, CAM_UNCOR_PARITY);
 #ifdef AHC_REPORT_UNDERFLOWS
 		/*
 		 * This code is disabled by default as some
@@ -4167,31 +4215,57 @@ ahc_done(struct ahc_softc *ahc, struct s
 			ahc_print_path(ahc, scb);
 			printf("Saw underflow (%ld of %ld bytes). "
 			       "Treated as error\n",
-				ahc_get_residual(scb),
-				ahc_get_transfer_length(scb));
-			ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+				aic_get_residual(scb),
+				aic_get_transfer_length(scb));
+			aic_set_transaction_status(scb, CAM_DATA_RUN_ERR);
 #endif
 		} else {
-			ahc_set_transaction_status(scb, CAM_REQ_CMP);
+			aic_set_transaction_status(scb, CAM_REQ_CMP);
 		}
-	} else if (ahc_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {
+	} else if (aic_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {
 		ahc_linux_handle_scsi_status(ahc, dev, scb);
-	} else if (ahc_get_transaction_status(scb) == CAM_SEL_TIMEOUT) {
-		dev->flags |= AHC_DEV_UNCONFIGURED;
-		if (AHC_DV_CMD(cmd) == FALSE)
-			dev->target->flags &= ~AHC_DV_REQUIRED;
+	} else if (aic_get_transaction_status(scb) == CAM_SEL_TIMEOUT) {
+		struct aic_linux_target *targ;
+		struct aic_linux_device *cur_dev;
+		int i;
+
+		/*
+		 * Mark all devices linked off this target
+		 * as unconfigured.
+		 */
+		targ = dev->target;
+		for (i = 0; i < AHC_NUM_LUNS; i++) {
+
+			if (targ->devices[i] == NULL)
+				continue;
+			cur_dev = targ->devices[i];
+			cur_dev->flags |= AIC_DEV_UNCONFIGURED;
+
+			/*
+			 * Don't free the dev for this
+			 * command prematurely.
+			 */
+			if (cur_dev == dev)
+				continue;
+
+			if (TAILQ_EMPTY(&cur_dev->busyq)
+			 && cur_dev->active == 0)
+				ahc_linux_free_device(ahc, cur_dev);
+		}
+		if (AIC_DV_CMD(cmd) == FALSE)
+			dev->target->flags &= ~AIC_DV_REQUIRED;
 	}
 	/*
 	 * Start DV for devices that require it assuming the first command
 	 * sent does not result in a selection timeout.
 	 */
-	if (ahc_get_transaction_status(scb) != CAM_SEL_TIMEOUT
-	 && (dev->target->flags & AHC_DV_REQUIRED) != 0)
+	if (aic_get_transaction_status(scb) != CAM_SEL_TIMEOUT
+	 && (dev->target->flags & AIC_DV_REQUIRED) != 0)
 		ahc_linux_start_dv(ahc);
 
 	if (dev->openings == 1
-	 && ahc_get_transaction_status(scb) == CAM_REQ_CMP
-	 && ahc_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)
+	 && aic_get_transaction_status(scb) == CAM_REQ_CMP
+	 && aic_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)
 		dev->tag_success_count++;
 	/*
 	 * Some devices deal with temporary internal resource
@@ -4200,7 +4274,7 @@ ahc_done(struct ahc_softc *ahc, struct s
 	 * back to our previous queue depth.
 	 */
 	if ((dev->openings + dev->active) < dev->maxtags
-	 && dev->tag_success_count > AHC_TAG_SUCCESS_INTERVAL) {
+	 && dev->tag_success_count > AIC_TAG_SUCCESS_INTERVAL) {
 		dev->tag_success_count = 0;
 		dev->openings++;
 	}
@@ -4209,32 +4283,61 @@ ahc_done(struct ahc_softc *ahc, struct s
 		dev->commands_since_idle_or_otag = 0;
 
 	if (TAILQ_EMPTY(&dev->busyq)) {
-		if ((dev->flags & AHC_DEV_UNCONFIGURED) != 0
-		 && dev->active == 0
-	 	 && (dev->flags & AHC_DEV_TIMER_ACTIVE) == 0)
+		if ((dev->flags & AIC_DEV_UNCONFIGURED) != 0
+		 && dev->active == 0)
 			ahc_linux_free_device(ahc, dev);
-	} else if ((dev->flags & AHC_DEV_ON_RUN_LIST) == 0) {
+	} else if ((dev->flags & AIC_DEV_ON_RUN_LIST) == 0) {
 		TAILQ_INSERT_TAIL(&ahc->platform_data->device_runq, dev, links);
-		dev->flags |= AHC_DEV_ON_RUN_LIST;
+		dev->flags |= AIC_DEV_ON_RUN_LIST;
 	}
 
 	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
 		printf("Recovery SCB completes\n");
-		if (ahc_get_transaction_status(scb) == CAM_BDR_SENT
-		 || ahc_get_transaction_status(scb) == CAM_REQ_ABORTED)
-			ahc_set_transaction_status(scb, CAM_CMD_TIMEOUT);
-		if ((ahc->platform_data->flags & AHC_UP_EH_SEMAPHORE) != 0) {
-			ahc->platform_data->flags &= ~AHC_UP_EH_SEMAPHORE;
+		if (aic_get_transaction_status(scb) == CAM_BDR_SENT
+		 || aic_get_transaction_status(scb) == CAM_REQ_ABORTED)
+			aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+		if ((scb->platform_data->flags & AIC_SCB_UP_EH_SEM) != 0) {
+			scb->platform_data->flags &= ~AIC_SCB_UP_EH_SEM;
 			up(&ahc->platform_data->eh_sem);
+		} else {
+			struct  scb *list_scb;
+
+			/*
+			 * We were able to complete the command successfully,
+			 * so reinstate the timeouts for all other pending
+			 * commands.
+			 */
+			LIST_FOREACH(list_scb,
+				     &ahc->pending_scbs, pending_links) {
+
+				aic_scb_timer_start(list_scb);
+                	}
 		}
 	}
 
+	if ((scb->platform_data->flags & AIC_TIMEOUT_ACTIVE) == 0) {
+		/*
+		 * The completion handler believes that
+		 * commands without active timers running
+		 * have lost the race of completing before
+		 * their timer expires.  Since commands in
+		 * our busy queues do not have timers running,
+		 * appease the mid-layer by adding a timer
+		 * now.  This timer will be immediately
+		 * canceled by the midlayer.
+		 */
+		scsi_add_timer(cmd, 60*HZ, aic_linux_midlayer_timeout);
+	}
+
+	if ((scb->platform_data->flags & AIC_RELEASE_SIMQ) != 0)
+		aic_release_simq_locked(ahc);
+
 	ahc_free_scb(ahc, scb);
 	ahc_linux_queue_cmd_complete(ahc, cmd);
 
-	if ((ahc->platform_data->flags & AHC_DV_WAIT_SIMQ_EMPTY) != 0
+	if ((ahc->platform_data->flags & AIC_DV_WAIT_SIMQ_EMPTY) != 0
 	 && LIST_FIRST(&ahc->pending_scbs) == NULL) {
-		ahc->platform_data->flags &= ~AHC_DV_WAIT_SIMQ_EMPTY;
+		ahc->platform_data->flags &= ~AIC_DV_WAIT_SIMQ_EMPTY;
 		up(&ahc->platform_data->dv_sem);
 	}
 		
@@ -4242,7 +4345,7 @@ ahc_done(struct ahc_softc *ahc, struct s
 
 static void
 ahc_linux_handle_scsi_status(struct ahc_softc *ahc,
-			     struct ahc_linux_device *dev, struct scb *scb)
+			     struct aic_linux_device *dev, struct scb *scb)
 {
 	struct	ahc_devinfo devinfo;
 
@@ -4262,7 +4365,7 @@ ahc_linux_handle_scsi_status(struct ahc_
 	 * we don't clobber the device with too many
 	 * commands.
 	 */
-	switch (ahc_get_scsi_status(scb)) {
+	switch (aic_get_scsi_status(scb)) {
 	default:
 		break;
 	case SCSI_STATUS_CHECK_COND:
@@ -4276,13 +4379,15 @@ ahc_linux_handle_scsi_status(struct ahc_
 		 */
 		cmd = scb->io_ctx;
 		if (scb->flags & SCB_SENSE) {
-			u_int sense_size;
+			struct	scsi_sense_data *sense;
+			u_int	sense_size;
+			int	error_code, sense_key, asc, ascq;
 
+			sense = ahc_get_sense_buf(ahc, scb);
 			sense_size = MIN(sizeof(struct scsi_sense_data)
-				       - ahc_get_sense_residual(scb),
+				       - aic_get_sense_residual(scb),
 					 sizeof(cmd->sense_buffer));
-			memcpy(cmd->sense_buffer,
-			       ahc_get_sense_buf(ahc, scb), sense_size);
+			memcpy(cmd->sense_buffer, sense, sense_size);
 			if (sense_size < sizeof(cmd->sense_buffer))
 				memset(&cmd->sense_buffer[sense_size], 0,
 				       sizeof(cmd->sense_buffer) - sense_size);
@@ -4301,6 +4406,23 @@ ahc_linux_handle_scsi_status(struct ahc_
 				printf("\n");
 			}
 #endif
+			/*
+			 * If this is not a DV command and the target
+			 * provides some status that makes us believe
+			 * that the target has changed (power on reset,
+			 * etc.) kick off a DV scan to re-validate the
+			 * device.
+			 */
+	 		if (AIC_DV_CMD(cmd) != 0)
+				break;
+
+			scsi_extract_sense(sense, &error_code,
+					   &sense_key, &asc, &ascq);
+			if (error_code == SSD_CURRENT_ERROR
+			 && sense_key == SSD_KEY_UNIT_ATTENTION
+			 && asc == 0x29
+			 && (ascq == 0 || ascq == 1))
+				dev->target->flags |= AIC_DV_REQUIRED;
 		}
 		break;
 	}
@@ -4337,7 +4459,7 @@ ahc_linux_handle_scsi_status(struct ahc_
 				 * this device.
 				 */
 				if (dev->last_queuefull_same_count
-				 == AHC_LOCK_TAGS_COUNT) {
+				 == AIC_LOCK_TAGS_COUNT) {
 					dev->maxtags = dev->active;
 					ahc_print_path(ahc, scb);
 					printf("Locking max tag count at %d\n",
@@ -4347,10 +4469,10 @@ ahc_linux_handle_scsi_status(struct ahc_
 				dev->tags_on_last_queuefull = dev->active;
 				dev->last_queuefull_same_count = 0;
 			}
-			ahc_set_transaction_status(scb, CAM_REQUEUE_REQ);
-			ahc_set_scsi_status(scb, SCSI_STATUS_OK);
+			aic_set_transaction_status(scb, CAM_REQUEUE_REQ);
+			aic_set_scsi_status(scb, SCSI_STATUS_OK);
 			ahc_platform_set_tags(ahc, &devinfo,
-				     (dev->flags & AHC_DEV_Q_BASIC)
+				     (dev->flags & AIC_DEV_Q_BASIC)
 				   ? AHC_QUEUE_BASIC : AHC_QUEUE_TAGGED);
 			break;
 		}
@@ -4359,9 +4481,9 @@ ahc_linux_handle_scsi_status(struct ahc_
 		 * as if the target returned BUSY SCSI status.
 		 */
 		dev->openings = 1;
-		ahc_set_scsi_status(scb, SCSI_STATUS_BUSY);
+		aic_set_scsi_status(scb, SCSI_STATUS_BUSY);
 		ahc_platform_set_tags(ahc, &devinfo,
-			     (dev->flags & AHC_DEV_Q_BASIC)
+			     (dev->flags & AIC_DEV_Q_BASIC)
 			   ? AHC_QUEUE_BASIC : AHC_QUEUE_TAGGED);
 		/* FALLTHROUGH */
 	}
@@ -4371,14 +4493,21 @@ ahc_linux_handle_scsi_status(struct ahc_
 		 * Set a short timer to defer sending commands for
 		 * a bit since Linux will not delay in this case.
 		 */
-		if ((dev->flags & AHC_DEV_TIMER_ACTIVE) != 0) {
+		if ((dev->flags & AIC_DEV_TIMER_ACTIVE) != 0) {
 			printf("%s:%c:%d: Device Timer still active during "
 			       "busy processing\n", ahc_name(ahc),
 				dev->target->channel, dev->target->target);
 			break;
 		}
-		dev->flags |= AHC_DEV_TIMER_ACTIVE;
 		dev->qfrozen++;
+		/*
+		 * Keep the active count non-zero during
+		 * the lifetime of the timer.  This
+		 * guarantees that the device will not
+		 * be freed before our timer executes.
+		 */
+		dev->active++;
+		dev->flags |= AIC_DEV_TIMER_ACTIVE;
 		init_timer(&dev->timer);
 		dev->timer.data = (u_long)dev;
 		dev->timer.expires = jiffies + (HZ/2);
@@ -4404,9 +4533,9 @@ ahc_linux_queue_cmd_complete(struct ahc_
 	 * not guarantee the order that aborted commands will be
 	 * returned to us.
 	 */
-	struct ahc_completeq *completeq;
-	struct ahc_cmd *list_cmd;
-	struct ahc_cmd *acmd;
+	struct aic_completeq *completeq;
+	struct aic_cmd *list_cmd;
+	struct aic_cmd *acmd;
 
 	/*
 	 * Map CAM error codes into Linux Error codes.  We
@@ -4414,10 +4543,10 @@ ahc_linux_queue_cmd_complete(struct ahc_
 	 * full error information available when making
 	 * state change decisions.
 	 */
-	if (AHC_DV_CMD(cmd) == FALSE) {
+	if (AIC_DV_CMD(cmd) == FALSE) {
 		u_int new_status;
 
-		switch (ahc_cmd_get_transaction_status(cmd)) {
+		switch (aic_cmd_get_transaction_status(cmd)) {
 		case CAM_REQ_INPROG:
 		case CAM_REQ_CMP:
 		case CAM_SCSI_STATUS_ERROR:
@@ -4444,7 +4573,17 @@ ahc_linux_queue_cmd_complete(struct ahc_
 			new_status = DID_PARITY;
 			break;
 		case CAM_CMD_TIMEOUT:
-			new_status = DID_TIME_OUT;
+			/*
+			 *  Returning DID_TIME_OUT will 
+			 *  wake up the error recovery
+			 *  thread instead of doing the
+			 *  command retry we desire. Since
+			 *  we have already recovered the
+			 *  command, returning DID_ERROR
+			 *  will cause a retry up to the
+			 *  retry limit for this command.
+			 */
+			new_status = DID_ERROR;
 			break;
 		case CAM_UA_ABORT:
 		case CAM_REQ_CMP_ERR:
@@ -4474,7 +4613,7 @@ ahc_linux_queue_cmd_complete(struct ahc_
 			if (cmd->retries > 0)
 				cmd->retries--;
 			new_status = DID_OK;
-			ahc_cmd_set_scsi_status(cmd, SCSI_STATUS_CHECK_COND);
+			aic_cmd_set_scsi_status(cmd, SCSI_STATUS_CHECK_COND);
 			cmd->result |= (DRIVER_SENSE << 24);
 			memset(cmd->sense_buffer, 0,
 			       sizeof(cmd->sense_buffer));
@@ -4488,12 +4627,21 @@ ahc_linux_queue_cmd_complete(struct ahc_
 			break;
 		}
 
-		ahc_cmd_set_transaction_status(cmd, new_status);
+		aic_cmd_set_transaction_status(cmd, new_status);
+	}
+
+	/*
+	 * Commands that have completed successfully
+	 * can be completed to the OS immediately.
+	 */
+	if (cmd->result == (DID_OK << 16)) {
+		cmd->scsi_done(cmd);
+		return;
 	}
 
 	completeq = &ahc->platform_data->completeq;
 	list_cmd = TAILQ_FIRST(completeq);
-	acmd = (struct ahc_cmd *)cmd;
+	acmd = (struct aic_cmd *)cmd;
 	while (list_cmd != NULL
 	    && acmd_scsi_cmd(list_cmd).serial_number
 	     < acmd_scsi_cmd(acmd).serial_number)
@@ -4514,7 +4662,7 @@ ahc_linux_filter_inquiry(struct ahc_soft
 	struct	ahc_transinfo *curr;
 	struct	ahc_tmode_tstate *tstate;
 	struct	ahc_syncrate *syncrate;
-	struct	ahc_linux_device *dev;
+	struct	aic_linux_device *dev;
 	u_int	maxsync;
 	u_int	width;
 	u_int	period;
@@ -4537,9 +4685,9 @@ ahc_linux_filter_inquiry(struct ahc_soft
 	sid = (struct scsi_inquiry_data *)dev->target->inq_data;
 	if (SID_QUAL(sid) == SID_QUAL_LU_CONNECTED) {
 
-		dev->flags &= ~AHC_DEV_UNCONFIGURED;
+		dev->flags &= ~AIC_DEV_UNCONFIGURED;
 	} else {
-		dev->flags |= AHC_DEV_UNCONFIGURED;
+		dev->flags |= AIC_DEV_UNCONFIGURED;
 		return;
 	}
 
@@ -4616,84 +4764,84 @@ ahc_linux_filter_inquiry(struct ahc_soft
 static void
 ahc_linux_sem_timeout(u_long arg)
 {
+	struct	scb *scb;
 	struct	ahc_softc *ahc;
 	u_long	s;
 
-	ahc = (struct ahc_softc *)arg;
-
+	scb = (struct scb *)arg;
+	ahc = scb->ahc_softc;
 	ahc_lock(ahc, &s);
-	if ((ahc->platform_data->flags & AHC_UP_EH_SEMAPHORE) != 0) {
-		ahc->platform_data->flags &= ~AHC_UP_EH_SEMAPHORE;
+	if ((scb->platform_data->flags & AIC_SCB_UP_EH_SEM) != 0) {
+		scb->platform_data->flags &= ~AIC_SCB_UP_EH_SEM;
 		up(&ahc->platform_data->eh_sem);
 	}
 	ahc_unlock(ahc, &s);
 }
 
 static void
-ahc_linux_freeze_simq(struct ahc_softc *ahc)
-{
-	ahc->platform_data->qfrozen++;
-	if (ahc->platform_data->qfrozen == 1) {
-		scsi_block_requests(ahc->platform_data->host);
-
-		/* XXX What about Twin channels? */
-		ahc_platform_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
-					CAM_LUN_WILDCARD, SCB_LIST_NULL,
-					ROLE_INITIATOR, CAM_REQUEUE_REQ);
-	}
-}
-
-static void
-ahc_linux_release_simq(u_long arg)
+ahc_linux_dev_timed_unfreeze(u_long arg)
 {
+	struct aic_linux_device *dev;
 	struct ahc_softc *ahc;
 	u_long s;
-	int    unblock_reqs;
-
-	ahc = (struct ahc_softc *)arg;
 
-	unblock_reqs = 0;
+	dev = (struct aic_linux_device *)arg;
+	ahc = dev->target->softc;
 	ahc_lock(ahc, &s);
-	if (ahc->platform_data->qfrozen > 0)
-		ahc->platform_data->qfrozen--;
-	if (ahc->platform_data->qfrozen == 0)
-		unblock_reqs = 1;
-	if (AHC_DV_SIMQ_FROZEN(ahc)
-	 && ((ahc->platform_data->flags & AHC_DV_WAIT_SIMQ_RELEASE) != 0)) {
-		ahc->platform_data->flags &= ~AHC_DV_WAIT_SIMQ_RELEASE;
-		up(&ahc->platform_data->dv_sem);
-	}
-	ahc_schedule_runq(ahc);
-	ahc_unlock(ahc, &s);
+
 	/*
-	 * There is still a race here.  The mid-layer
-	 * should keep its own freeze count and use
-	 * a bottom half handler to run the queues
-	 * so we can unblock with our own lock held.
+	 * Release our hold on the device.
 	 */
-	if (unblock_reqs)
-		scsi_unblock_requests(ahc->platform_data->host);
+	dev->flags &= ~AIC_DEV_TIMER_ACTIVE;
+	dev->active--;
+
+	if (dev->qfrozen > 0)
+		dev->qfrozen--;
+	if (dev->qfrozen == 0
+	 && dev->target->qfrozen == 0
+	 && (dev->flags & AIC_DEV_ON_RUN_LIST) == 0)
+		ahc_linux_run_device_queue(ahc, dev);
+	if ((dev->flags & AIC_DEV_UNCONFIGURED) != 0
+	 && TAILQ_EMPTY(&dev->busyq)
+	 && dev->active == 0)
+		ahc_linux_free_device(ahc, dev);
+	ahc_unlock(ahc, &s);
 }
 
 static void
-ahc_linux_dev_timed_unfreeze(u_long arg)
+ahc_linux_targ_timed_unfreeze(u_long arg)
 {
-	struct ahc_linux_device *dev;
+	struct aic_linux_target *targ;
 	struct ahc_softc *ahc;
 	u_long s;
 
-	dev = (struct ahc_linux_device *)arg;
-	ahc = dev->target->ahc;
+	targ = (struct aic_linux_target *)arg;
+	ahc = targ->softc;
 	ahc_lock(ahc, &s);
-	dev->flags &= ~AHC_DEV_TIMER_ACTIVE;
-	if (dev->qfrozen > 0)
-		dev->qfrozen--;
-	if (dev->qfrozen == 0
-	 && (dev->flags & AHC_DEV_ON_RUN_LIST) == 0)
-		ahc_linux_run_device_queue(ahc, dev);
-	if (TAILQ_EMPTY(&dev->busyq)
-	 && dev->active == 0)
-		ahc_linux_free_device(ahc, dev);
+
+	/*
+	 * Release our hold on the target.
+	 */
+	targ->flags &= ~AIC_TARG_TIMER_ACTIVE;
+	targ->refcount--;
+
+	targ->flags &= ~AIC_TARG_TIMER_ACTIVE;
+	if (targ->qfrozen > 0)
+		targ->qfrozen--;
+	if (targ->qfrozen == 0) {
+		u_int i;
+
+		for (i = 0; i < AHC_NUM_LUNS; i++) {
+			struct aic_linux_device *dev;
+		
+			dev = targ->devices[i];
+			if (dev == NULL
+	 		 || (dev->flags & AIC_DEV_ON_RUN_LIST) != 0)
+				continue;
+
+			aic_linux_check_device_queue(ahc, dev);
+		}
+	}
 	ahc_unlock(ahc, &s);
 }
 
@@ -4701,9 +4849,9 @@ static int
 ahc_linux_queue_recovery_cmd(Scsi_Cmnd *cmd, scb_flag flag)
 {
 	struct ahc_softc *ahc;
-	struct ahc_cmd *acmd;
-	struct ahc_cmd *list_acmd;
-	struct ahc_linux_device *dev;
+	struct aic_cmd *acmd;
+	struct aic_cmd *list_acmd;
+	struct aic_linux_device *dev;
 	struct scb *pending_scb;
 	u_long s;
 	u_int  saved_scbptr;
@@ -4721,7 +4869,7 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 	paused = FALSE;
 	wait = FALSE;
 	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
-	acmd = (struct ahc_cmd *)cmd;
+	acmd = (struct aic_cmd *)cmd;
 
 	printf("%s:%d:%d:%d: Attempting to queue a%s message\n",
 	       ahc_name(ahc), cmd->device->channel,
@@ -4747,7 +4895,7 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 	 * by acquiring either the io_request_lock or our own
 	 * lock, this *should* be safe.
 	 */
-	ahc_midlayer_entrypoint_lock(ahc, &s);
+	ahc_entrypoint_lock(ahc, &s);
 
 	/*
 	 * First determine if we currently own this command.
@@ -4783,13 +4931,24 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 		if (flag == SCB_ABORT) {
 			TAILQ_REMOVE(&dev->busyq, list_acmd, acmd_links.tqe);
 			cmd->result = DID_ABORT << 16;
+			/*
+			 * The completion handler believes that
+			 * commands without active timers running
+			 * have lost the race of completing before
+			 * their timer expires.  Since commands in our
+			 * busy queues do not have timers running,
+			 * appease the mid-layer by adding a timer
+			 * now.  This timer will be immediately
+			 * canceled by the midlayer.
+			 */
+			scsi_add_timer(cmd, 60*HZ, aic_linux_midlayer_timeout);
 			ahc_linux_queue_cmd_complete(ahc, cmd);
 			retval = SUCCESS;
 			goto done;
 		}
 	}
 
-	if ((dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED)) == 0
+	if ((dev->flags & (AIC_DEV_Q_BASIC|AIC_DEV_Q_TAGGED)) == 0
 	 && ahc_search_untagged_queues(ahc, cmd, cmd->device->id,
 				       cmd->device->channel + 'A',
 				       cmd->device->lun,
@@ -5005,10 +5164,10 @@ done:
 		struct timer_list timer;
 		int ret;
 
-		ahc->platform_data->flags |= AHC_UP_EH_SEMAPHORE;
+		pending_scb->platform_data->flags |= AIC_SCB_UP_EH_SEM;
 		spin_unlock_irq(&ahc->platform_data->spin_lock);
 		init_timer(&timer);
-		timer.data = (u_long)ahc;
+		timer.data = (u_long)pending_scb;
 		timer.expires = jiffies + (5 * HZ);
 		timer.function = ahc_linux_sem_timeout;
 		add_timer(&timer);
@@ -5022,16 +5181,17 @@ done:
 		}
 		spin_lock_irq(&ahc->platform_data->spin_lock);
 	}
-	ahc_schedule_runq(ahc);
+	aic_schedule_runq(ahc);
 	ahc_linux_run_complete_queue(ahc);
-	ahc_midlayer_entrypoint_unlock(ahc, &s);
+	ahc_entrypoint_unlock(ahc, &s);
 	return (retval);
 }
 
 void
 ahc_platform_dump_card_state(struct ahc_softc *ahc)
 {
-	struct ahc_linux_device *dev;
+	struct Scsi_Host *host;
+	struct aic_linux_device *dev;
 	int channel;
 	int maxchannel;
 	int target;
@@ -5039,6 +5199,14 @@ ahc_platform_dump_card_state(struct ahc_
 	int lun;
 	int i;
 
+	host = ahc->platform_data->host;
+	printf("%s: Host Status: Failed(%d) %s%s%s\n",
+	       ahc_name(ahc),
+	       host->host_failed,
+	       host->eh_active ? "eh_active " : "",
+	       host->host_blocked ? "host_blocked " : "",
+	       host->host_self_blocked ? "host_self_blocked " : "");
+	       
 	maxchannel = (ahc->features & AHC_TWIN) ? 1 : 0;
 	maxtarget = (ahc->features & AHC_WIDE) ? 15 : 7;
 	for (channel = 0; channel <= maxchannel; channel++) {
@@ -5046,7 +5214,7 @@ ahc_platform_dump_card_state(struct ahc_
 		for (target = 0; target <=maxtarget; target++) {
 
 			for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
-				struct ahc_cmd *acmd;
+				struct aic_cmd *acmd;
 
 				dev = ahc_linux_get_device(ahc, channel, target,
 							   lun, /*alloc*/FALSE);
@@ -5070,38 +5238,48 @@ ahc_platform_dump_card_state(struct ahc_
 static int __init
 ahc_linux_init(void)
 {
+	int found;
+
+	ahc_sysrq_key = aic_install_sysrq(&ahc_sysrq_op);
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	return (ahc_linux_detect(&aic7xxx_driver_template) ? 0 : -ENODEV);
+	found = ahc_linux_detect(&aic7xxx_driver_template);
 #else
 	scsi_register_module(MODULE_SCSI_HA, &aic7xxx_driver_template);
-	if (aic7xxx_driver_template.present == 0) {
-		scsi_unregister_module(MODULE_SCSI_HA,
-				       &aic7xxx_driver_template);
-		return (-ENODEV);
-	}
-
-	return (0);
+	found = aic7xxx_driver_template.present;
 #endif
+#ifdef MODULE
+	if (found == 0)
+		ahc_init_status = -ENODEV;
+#endif
+	if (ahc_init_status != 0) {
+		/*
+		 * Linux will not call our exit
+		 * routine if we fail to load.
+		 * Force cleanup if initialization
+		 * is not successful.
+		 */
+		ahc_linux_exit();
+	}
+	return (ahc_init_status);
 }
 
-static void __exit
+static void
 ahc_linux_exit(void)
 {
 	struct ahc_softc *ahc;
-	u_long l;
 
 	/*
-	 * Shutdown DV threads before going into the SCSI mid-layer.
+	 * Shutdown our threads before going into the SCSI mid-layer.
 	 * This avoids situations where the mid-layer locks the entire
 	 * kernel so that waiting for our DV threads to exit leads
 	 * to deadlock.
 	 */
-	ahc_list_lock(&l);
 	TAILQ_FOREACH(ahc, &ahc_tailq, links) {
 
 		ahc_linux_kill_dv_thread(ahc);
+		ahc_terminate_recovery_thread(ahc);
 	}
-	ahc_list_unlock(&l);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 	/*
@@ -5117,6 +5295,7 @@ ahc_linux_exit(void)
 #ifdef CONFIG_EISA
 	ahc_linux_eisa_exit();
 #endif
+	aic_remove_sysrq(ahc_sysrq_key, &ahc_sysrq_op);
 }
 
 module_init(ahc_linux_init);
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_osm.h linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_osm.h
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_osm.h	2004-04-04 05:36:56.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_osm.h	2004-05-13 16:42:17.000000000 +0200
@@ -53,50 +53,22 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#151 $
+ * $Id$
  *
  */
 #ifndef _AIC7XXX_LINUX_H_
 #define _AIC7XXX_LINUX_H_
 
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/pci.h>
-#include <linux/smp_lock.h>
 #include <linux/version.h>
-#include <linux/module.h>
-#include <asm/byteorder.h>
-#include <asm/io.h>
 
 #ifndef KERNEL_VERSION
 #define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-#include <linux/interrupt.h> /* For tasklet support. */
 #include <linux/config.h>
-#include <linux/slab.h>
-#else
-#include <linux/malloc.h>
-#endif
-
-/* Core SCSI definitions */
-#define AIC_LIB_PREFIX ahc
-#include "scsi.h"
-#include "hosts.h"
-
-/* Name space conflict with BSD queue macros */
-#ifdef LIST_HEAD
-#undef LIST_HEAD
 #endif
 
-#include "cam.h"
-#include "queue.h"
-#include "scsi_message.h"
-#include "aiclib.h"
-
 /*********************************** Debugging ********************************/
 #ifdef CONFIG_AIC7XXX_DEBUG_ENABLE
 #ifdef CONFIG_AIC7XXX_DEBUG_MASK
@@ -111,42 +83,18 @@
 /* No debugging code. */
 #endif
 
-/************************* Forward Declarations *******************************/
-struct ahc_softc;
-typedef struct pci_dev *ahc_dev_softc_t;
-typedef Scsi_Cmnd      *ahc_io_ctx_t;
-
-/******************************* Byte Order ***********************************/
-#define ahc_htobe16(x)	cpu_to_be16(x)
-#define ahc_htobe32(x)	cpu_to_be32(x)
-#define ahc_htobe64(x)	cpu_to_be64(x)
-#define ahc_htole16(x)	cpu_to_le16(x)
-#define ahc_htole32(x)	cpu_to_le32(x)
-#define ahc_htole64(x)	cpu_to_le64(x)
-
-#define ahc_be16toh(x)	be16_to_cpu(x)
-#define ahc_be32toh(x)	be32_to_cpu(x)
-#define ahc_be64toh(x)	be64_to_cpu(x)
-#define ahc_le16toh(x)	le16_to_cpu(x)
-#define ahc_le32toh(x)	le32_to_cpu(x)
-#define ahc_le64toh(x)	le64_to_cpu(x)
-
-#ifndef LITTLE_ENDIAN
-#define LITTLE_ENDIAN 1234
-#endif
-
-#ifndef BIG_ENDIAN
-#define BIG_ENDIAN 4321
-#endif
+/********************************** Includes **********************************/
+/* Core SCSI definitions */
+#define AIC_LIB_PREFIX ahc
+#define AIC_CONST_PREFIX AHC
 
-#ifndef BYTE_ORDER
-#if defined(__BIG_ENDIAN)
-#define BYTE_ORDER BIG_ENDIAN
-#endif
-#if defined(__LITTLE_ENDIAN)
-#define BYTE_ORDER LITTLE_ENDIAN
+#ifdef CONFIG_AIC7XXX_REG_PRETTY_PRINT
+#define AIC_DEBUG_REGISTERS 1
+#else
+#define AIC_DEBUG_REGISTERS 0
 #endif
-#endif /* BYTE_ORDER */
+#define	AIC_CORE_INCLUDE "aic7xxx.h"
+#include "aiclib.h"
 
 /************************* Configuration Data *********************************/
 extern u_int aic7xxx_no_probe;
@@ -154,142 +102,9 @@ extern u_int aic7xxx_allow_memio;
 extern int aic7xxx_detect_complete;
 extern Scsi_Host_Template aic7xxx_driver_template;
 
-/***************************** Bus Space/DMA **********************************/
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,17)
-typedef dma_addr_t bus_addr_t;
-#else
-typedef uint32_t bus_addr_t;
-#endif
-typedef uint32_t bus_size_t;
-
-typedef enum {
-	BUS_SPACE_MEMIO,
-	BUS_SPACE_PIO
-} bus_space_tag_t;
-
-typedef union {
-	u_long		  ioport;
-	volatile uint8_t *maddr;
-} bus_space_handle_t;
-
-typedef struct bus_dma_segment
-{
-	bus_addr_t	ds_addr;
-	bus_size_t	ds_len;
-} bus_dma_segment_t;
-
-struct ahc_linux_dma_tag
-{
-	bus_size_t	alignment;
-	bus_size_t	boundary;
-	bus_size_t	maxsize;
-};
-typedef struct ahc_linux_dma_tag* bus_dma_tag_t;
-
-struct ahc_linux_dmamap
-{
-	bus_addr_t	bus_addr;
-};
-typedef struct ahc_linux_dmamap* bus_dmamap_t;
-
-typedef int bus_dma_filter_t(void*, bus_addr_t);
-typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);
-
-#define BUS_DMA_WAITOK		0x0
-#define BUS_DMA_NOWAIT		0x1
-#define BUS_DMA_ALLOCNOW	0x2
-#define BUS_DMA_LOAD_SEGS	0x4	/*
-					 * Argument is an S/G list not
-					 * a single buffer.
-					 */
-
-#define BUS_SPACE_MAXADDR	0xFFFFFFFF
-#define BUS_SPACE_MAXADDR_32BIT	0xFFFFFFFF
-#define BUS_SPACE_MAXSIZE_32BIT	0xFFFFFFFF
-
-int	ahc_dma_tag_create(struct ahc_softc *, bus_dma_tag_t /*parent*/,
-			   bus_size_t /*alignment*/, bus_size_t /*boundary*/,
-			   bus_addr_t /*lowaddr*/, bus_addr_t /*highaddr*/,
-			   bus_dma_filter_t*/*filter*/, void */*filterarg*/,
-			   bus_size_t /*maxsize*/, int /*nsegments*/,
-			   bus_size_t /*maxsegsz*/, int /*flags*/,
-			   bus_dma_tag_t */*dma_tagp*/);
-
-void	ahc_dma_tag_destroy(struct ahc_softc *, bus_dma_tag_t /*tag*/);
-
-int	ahc_dmamem_alloc(struct ahc_softc *, bus_dma_tag_t /*dmat*/,
-			 void** /*vaddr*/, int /*flags*/,
-			 bus_dmamap_t* /*mapp*/);
-
-void	ahc_dmamem_free(struct ahc_softc *, bus_dma_tag_t /*dmat*/,
-			void* /*vaddr*/, bus_dmamap_t /*map*/);
-
-void	ahc_dmamap_destroy(struct ahc_softc *, bus_dma_tag_t /*tag*/,
-			   bus_dmamap_t /*map*/);
-
-int	ahc_dmamap_load(struct ahc_softc *ahc, bus_dma_tag_t /*dmat*/,
-			bus_dmamap_t /*map*/, void * /*buf*/,
-			bus_size_t /*buflen*/, bus_dmamap_callback_t *,
-			void */*callback_arg*/, int /*flags*/);
-
-int	ahc_dmamap_unload(struct ahc_softc *, bus_dma_tag_t, bus_dmamap_t);
-
-/*
- * Operations performed by ahc_dmamap_sync().
- */
-#define BUS_DMASYNC_PREREAD	0x01	/* pre-read synchronization */
-#define BUS_DMASYNC_POSTREAD	0x02	/* post-read synchronization */
-#define BUS_DMASYNC_PREWRITE	0x04	/* pre-write synchronization */
-#define BUS_DMASYNC_POSTWRITE	0x08	/* post-write synchronization */
-
-/*
- * XXX
- * ahc_dmamap_sync is only used on buffers allocated with
- * the pci_alloc_consistent() API.  Although I'm not sure how
- * this works on architectures with a write buffer, Linux does
- * not have an API to sync "coherent" memory.  Perhaps we need
- * to do an mb()?
- */
-#define ahc_dmamap_sync(ahc, dma_tag, dmamap, offset, len, op)
-
-/************************** Timer DataStructures ******************************/
-typedef struct timer_list ahc_timer_t;
-
-/********************************** Includes **********************************/
-#ifdef CONFIG_AIC7XXX_REG_PRETTY_PRINT
-#define AIC_DEBUG_REGISTERS 1
-#else
-#define AIC_DEBUG_REGISTERS 0
-#endif
-#include "aic7xxx.h"
-
-/***************************** Timer Facilities *******************************/
-#define ahc_timer_init init_timer
-#define ahc_timer_stop del_timer_sync
-typedef void ahc_linux_callback_t (u_long);  
-static __inline void ahc_timer_reset(ahc_timer_t *timer, int usec,
-				     ahc_callback_t *func, void *arg);
-static __inline void ahc_scb_timer_reset(struct scb *scb, u_int usec);
-
-static __inline void
-ahc_timer_reset(ahc_timer_t *timer, int usec, ahc_callback_t *func, void *arg)
-{
-	struct ahc_softc *ahc;
-
-	ahc = (struct ahc_softc *)arg;
-	del_timer(timer);
-	timer->data = (u_long)arg;
-	timer->expires = jiffies + (usec * HZ)/1000000;
-	timer->function = (ahc_linux_callback_t*)func;
-	add_timer(timer);
-}
-
-static __inline void
-ahc_scb_timer_reset(struct scb *scb, u_int usec)
-{
-	mod_timer(&scb->io_ctx->eh_timeout, jiffies + (usec * HZ)/1000000);
-}
+/***************************** Domain Validation ******************************/
+void ahc_linux_dv_complete(Scsi_Cmnd *cmd);
+void ahc_linux_dv_timeout(struct scsi_cmnd *cmd);
 
 /***************************** SMP support ************************************/
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
@@ -298,193 +113,7 @@ ahc_scb_timer_reset(struct scb *scb, u_i
 #include <linux/smp.h>
 #endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) || defined(SCSI_HAS_HOST_LOCK))
-#define AHC_SCSI_HAS_HOST_LOCK 1
-#else
-#define AHC_SCSI_HAS_HOST_LOCK 0
-#endif
-
-#define AIC7XXX_DRIVER_VERSION "6.2.36"
-
-/**************************** Front End Queues ********************************/
-/*
- * Data structure used to cast the Linux struct scsi_cmnd to something
- * that allows us to use the queue macros.  The linux structure has
- * plenty of space to hold the links fields as required by the queue
- * macros, but the queue macors require them to have the correct type.
- */
-struct ahc_cmd_internal {
-	/* Area owned by the Linux scsi layer. */
-	uint8_t	private[offsetof(struct scsi_cmnd, SCp.Status)];
-	union {
-		STAILQ_ENTRY(ahc_cmd)	ste;
-		LIST_ENTRY(ahc_cmd)	le;
-		TAILQ_ENTRY(ahc_cmd)	tqe;
-	} links;
-	uint32_t			end;
-};
-
-struct ahc_cmd {
-	union {
-		struct ahc_cmd_internal	icmd;
-		struct scsi_cmnd	scsi_cmd;
-	} un;
-};
-
-#define acmd_icmd(cmd) ((cmd)->un.icmd)
-#define acmd_scsi_cmd(cmd) ((cmd)->un.scsi_cmd)
-#define acmd_links un.icmd.links
-
-/*************************** Device Data Structures ***************************/
-/*
- * A per probed device structure used to deal with some error recovery
- * scenarios that the Linux mid-layer code just doesn't know how to
- * handle.  The structure allocated for a device only becomes persistent
- * after a successfully completed inquiry command to the target when
- * that inquiry data indicates a lun is present.
- */
-TAILQ_HEAD(ahc_busyq, ahc_cmd);
-typedef enum {
-	AHC_DEV_UNCONFIGURED	 = 0x01,
-	AHC_DEV_FREEZE_TIL_EMPTY = 0x02, /* Freeze queue until active == 0 */
-	AHC_DEV_TIMER_ACTIVE	 = 0x04, /* Our timer is active */
-	AHC_DEV_ON_RUN_LIST	 = 0x08, /* Queued to be run later */
-	AHC_DEV_Q_BASIC		 = 0x10, /* Allow basic device queuing */
-	AHC_DEV_Q_TAGGED	 = 0x20, /* Allow full SCSI2 command queueing */
-	AHC_DEV_PERIODIC_OTAG	 = 0x40, /* Send OTAG to prevent starvation */
-	AHC_DEV_SLAVE_CONFIGURED = 0x80	 /* slave_configure() has been called */
-} ahc_linux_dev_flags;
-
-struct ahc_linux_target;
-struct ahc_linux_device {
-	TAILQ_ENTRY(ahc_linux_device) links;
-	struct		ahc_busyq busyq;
-
-	/*
-	 * The number of transactions currently
-	 * queued to the device.
-	 */
-	int			active;
-
-	/*
-	 * The currently allowed number of 
-	 * transactions that can be queued to
-	 * the device.  Must be signed for
-	 * conversion from tagged to untagged
-	 * mode where the device may have more
-	 * than one outstanding active transaction.
-	 */
-	int			openings;
-
-	/*
-	 * A positive count indicates that this
-	 * device's queue is halted.
-	 */
-	u_int			qfrozen;
-	
-	/*
-	 * Cumulative command counter.
-	 */
-	u_long			commands_issued;
-
-	/*
-	 * The number of tagged transactions when
-	 * running at our current opening level
-	 * that have been successfully received by
-	 * this device since the last QUEUE FULL.
-	 */
-	u_int			tag_success_count;
-#define AHC_TAG_SUCCESS_INTERVAL 50
-
-	ahc_linux_dev_flags	flags;
-
-	/*
-	 * Per device timer.
-	 */
-	struct timer_list	timer;
-
-	/*
-	 * The high limit for the tags variable.
-	 */
-	u_int			maxtags;
-
-	/*
-	 * The computed number of tags outstanding
-	 * at the time of the last QUEUE FULL event.
-	 */
-	u_int			tags_on_last_queuefull;
-
-	/*
-	 * How many times we have seen a queue full
-	 * with the same number of tags.  This is used
-	 * to stop our adaptive queue depth algorithm
-	 * on devices with a fixed number of tags.
-	 */
-	u_int			last_queuefull_same_count;
-#define AHC_LOCK_TAGS_COUNT 50
-
-	/*
-	 * How many transactions have been queued
-	 * without the device going idle.  We use
-	 * this statistic to determine when to issue
-	 * an ordered tag to prevent transaction
-	 * starvation.  This statistic is only updated
-	 * if the AHC_DEV_PERIODIC_OTAG flag is set
-	 * on this device.
-	 */
-	u_int			commands_since_idle_or_otag;
-#define AHC_OTAG_THRESH	500
-
-	int			lun;
-	Scsi_Device	       *scsi_device;
-	struct			ahc_linux_target *target;
-};
-
-typedef enum {
-	AHC_DV_REQUIRED		 = 0x01,
-	AHC_INQ_VALID		 = 0x02,
-	AHC_BASIC_DV		 = 0x04,
-	AHC_ENHANCED_DV		 = 0x08
-} ahc_linux_targ_flags;
-
-/* DV States */
-typedef enum {
-	AHC_DV_STATE_EXIT = 0,
-	AHC_DV_STATE_INQ_SHORT_ASYNC,
-	AHC_DV_STATE_INQ_ASYNC,
-	AHC_DV_STATE_INQ_ASYNC_VERIFY,
-	AHC_DV_STATE_TUR,
-	AHC_DV_STATE_REBD,
-	AHC_DV_STATE_INQ_VERIFY,
-	AHC_DV_STATE_WEB,
-	AHC_DV_STATE_REB,
-	AHC_DV_STATE_SU,
-	AHC_DV_STATE_BUSY
-} ahc_dv_state;
-
-struct ahc_linux_target {
-	struct ahc_linux_device	 *devices[AHC_NUM_LUNS];
-	int			  channel;
-	int			  target;
-	int			  refcount;
-	struct ahc_transinfo	  last_tinfo;
-	struct ahc_softc	 *ahc;
-	ahc_linux_targ_flags	  flags;
-	struct scsi_inquiry_data *inq_data;
-	/*
-	 * The next "fallback" period to use for narrow/wide transfers.
-	 */
-	uint8_t			  dv_next_narrow_period;
-	uint8_t			  dv_next_wide_period;
-	uint8_t			  dv_max_width;
-	uint8_t			  dv_max_ppr_options;
-	uint8_t			  dv_last_ppr_options;
-	u_int			  dv_echo_size;
-	ahc_dv_state		  dv_state;
-	u_int			  dv_state_retry;
-	char			 *dv_buffer;
-	char			 *dv_buffer1;
-};
+#define AIC7XXX_DRIVER_VERSION "6.3.6"
 
 /********************* Definitions Required by the Core ***********************/
 /*
@@ -506,93 +135,19 @@ extern u_int ahc_linux_nseg;
 #define	AHC_NSEG 128
 #endif
 
-/*
- * Per-SCB OSM storage.
- */
-typedef enum {
-	AHC_UP_EH_SEMAPHORE = 0x1
-} ahc_linux_scb_flags;
-
-struct scb_platform_data {
-	struct ahc_linux_device	*dev;
-	bus_addr_t		 buf_busaddr;
-	uint32_t		 xfer_len;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-	uint32_t		 resid;		/* Transfer residual */
-#endif
-	uint32_t		 sense_resid;	/* Auto-Sense residual */
-	ahc_linux_scb_flags	 flags;
-};
-
-/*
- * Define a structure used for each host adapter.  All members are
- * aligned on a boundary >= the size of the member to honor the
- * alignment restrictions of the various platforms supported by
- * this driver.
- */
-typedef enum {
-	AHC_DV_WAIT_SIMQ_EMPTY	 = 0x01,
-	AHC_DV_WAIT_SIMQ_RELEASE = 0x02,
-	AHC_DV_ACTIVE		 = 0x04,
-	AHC_DV_SHUTDOWN		 = 0x08,
-	AHC_RUN_CMPLT_Q_TIMER	 = 0x10
-} ahc_linux_softc_flags;
-
-TAILQ_HEAD(ahc_completeq, ahc_cmd);
-
-struct ahc_platform_data {
-	/*
-	 * Fields accessed from interrupt context.
-	 */
-	struct ahc_linux_target *targets[AHC_NUM_TARGETS]; 
-	TAILQ_HEAD(, ahc_linux_device) device_runq;
-	struct ahc_completeq	 completeq;
-
-	spinlock_t		 spin_lock;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	struct tasklet_struct	 runq_tasklet;
-#endif
-	u_int			 qfrozen;
-	pid_t			 dv_pid;
-	struct timer_list	 completeq_timer;
-	struct timer_list	 reset_timer;
-	struct semaphore	 eh_sem;
-	struct semaphore	 dv_sem;
-	struct semaphore	 dv_cmd_sem;	/* XXX This needs to be in
-						 * the target struct
-						 */
-	struct scsi_device	*dv_scsi_dev;
-	struct Scsi_Host        *host;		/* pointer to scsi host */
-#define AHC_LINUX_NOIRQ	((uint32_t)~0)
-	uint32_t		 irq;		/* IRQ for this adapter */
-	uint32_t		 bios_address;
-	uint32_t		 mem_busaddr;	/* Mem Base Addr */
-	bus_addr_t		 hw_dma_mask;
-	ahc_linux_softc_flags	 flags;
-};
-
-/************************** OS Utility Wrappers *******************************/
-#define printf printk
-#define M_NOWAIT GFP_ATOMIC
-#define M_WAITOK 0
-#define malloc(size, type, flags) kmalloc(size, flags)
-#define free(ptr, type) kfree(ptr)
-
-static __inline void ahc_delay(long);
-static __inline void
-ahc_delay(long usec)
-{
-	/*
-	 * udelay on Linux can have problems for
-	 * multi-millisecond waits.  Wait at most
-	 * 1024us per call.
-	 */
-	while (usec > 0) {
-		udelay(usec % 1024);
-		usec -= 1024;
-	}
-}
-
+/************************** Error Recovery ************************************/
+static __inline void	ahc_wakeup_recovery_thread(struct ahc_softc *ahc); 
+  
+static __inline void
+ahc_wakeup_recovery_thread(struct ahc_softc *ahc)
+{ 
+	up(&ahc->platform_data->recovery_sem);
+}
+ 
+int			ahc_spawn_recovery_thread(struct ahc_softc *ahc);
+void			ahc_terminate_recovery_thread(struct ahc_softc *ahc);
+void			ahc_set_recoveryscb(struct ahc_softc *ahc,
+					    struct scb *scb);
 
 /***************************** Low Level I/O **********************************/
 static __inline uint8_t ahc_inb(struct ahc_softc * ahc, long port);
@@ -601,6 +156,7 @@ static __inline void ahc_outsb(struct ah
 			       uint8_t *, int count);
 static __inline void ahc_insb(struct ahc_softc * ahc, long port,
 			       uint8_t *, int count);
+static __inline void ahc_flush_device_writes(struct ahc_softc *);
 
 static __inline uint8_t
 ahc_inb(struct ahc_softc * ahc, long port)
@@ -655,7 +211,15 @@ ahc_insb(struct ahc_softc * ahc, long po
 		*array++ = ahc_inb(ahc, port);
 }
 
+static __inline void
+ahc_flush_device_writes(struct ahc_softc *ahc)
+{
+	/* XXX Is this sufficient for all architectures??? */
+	ahc_inb(ahc, INTSTAT);
+}
+
 /**************************** Initialization **********************************/
+extern int	ahc_init_status;
 int		ahc_linux_register_host(struct ahc_softc *,
 					Scsi_Host_Template *);
 
@@ -672,165 +236,11 @@ struct info_str {
 void	ahc_format_transinfo(struct info_str *info,
 			     struct ahc_transinfo *tinfo);
 
-/******************************** Locking *************************************/
-/* Lock protecting internal data structures */
-static __inline void ahc_lockinit(struct ahc_softc *);
-static __inline void ahc_lock(struct ahc_softc *, unsigned long *flags);
-static __inline void ahc_unlock(struct ahc_softc *, unsigned long *flags);
-
-/* Lock acquisition and release of the above lock in midlayer entry points. */
-static __inline void ahc_midlayer_entrypoint_lock(struct ahc_softc *,
-						  unsigned long *flags);
-static __inline void ahc_midlayer_entrypoint_unlock(struct ahc_softc *,
-						    unsigned long *flags);
-
-/* Lock held during command compeletion to the upper layer */
-static __inline void ahc_done_lockinit(struct ahc_softc *);
-static __inline void ahc_done_lock(struct ahc_softc *, unsigned long *flags);
-static __inline void ahc_done_unlock(struct ahc_softc *, unsigned long *flags);
-
-/* Lock held during ahc_list manipulation and ahc softc frees */
-extern spinlock_t ahc_list_spinlock;
-static __inline void ahc_list_lockinit(void);
-static __inline void ahc_list_lock(unsigned long *flags);
-static __inline void ahc_list_unlock(unsigned long *flags);
-
-static __inline void
-ahc_lockinit(struct ahc_softc *ahc)
-{
-	spin_lock_init(&ahc->platform_data->spin_lock);
-}
-
-static __inline void
-ahc_lock(struct ahc_softc *ahc, unsigned long *flags)
-{
-	spin_lock_irqsave(&ahc->platform_data->spin_lock, *flags);
-}
-
-static __inline void
-ahc_unlock(struct ahc_softc *ahc, unsigned long *flags)
-{
-	spin_unlock_irqrestore(&ahc->platform_data->spin_lock, *flags);
-}
-
-static __inline void
-ahc_midlayer_entrypoint_lock(struct ahc_softc *ahc, unsigned long *flags)
-{
-	/*
-	 * In 2.5.X and some 2.4.X versions, the midlayer takes our
-	 * lock just before calling us, so we avoid locking again.
-	 * For other kernel versions, the io_request_lock is taken
-	 * just before our entry point is called.  In this case, we
-	 * trade the io_request_lock for our per-softc lock.
-	 */
-#if AHC_SCSI_HAS_HOST_LOCK == 0
-	spin_unlock(&io_request_lock);
-	spin_lock(&ahc->platform_data->spin_lock);
-#endif
-}
-
-static __inline void
-ahc_midlayer_entrypoint_unlock(struct ahc_softc *ahc, unsigned long *flags)
-{
-#if AHC_SCSI_HAS_HOST_LOCK == 0
-	spin_unlock(&ahc->platform_data->spin_lock);
-	spin_lock(&io_request_lock);
-#endif
-}
-
-static __inline void
-ahc_done_lockinit(struct ahc_softc *ahc)
-{
-	/*
-	 * In 2.5.X, our own lock is held during completions.
-	 * In previous versions, the io_request_lock is used.
-	 * In either case, we can't initialize this lock again.
-	 */
-}
-
-static __inline void
-ahc_done_lock(struct ahc_softc *ahc, unsigned long *flags)
-{
-#if AHC_SCSI_HAS_HOST_LOCK == 0
-	spin_lock_irqsave(&io_request_lock, *flags);
-#endif
-}
-
-static __inline void
-ahc_done_unlock(struct ahc_softc *ahc, unsigned long *flags)
-{
-#if AHC_SCSI_HAS_HOST_LOCK == 0
-	spin_unlock_irqrestore(&io_request_lock, *flags);
-#endif
-}
-
-static __inline void
-ahc_list_lockinit(void)
-{
-	spin_lock_init(&ahc_list_spinlock);
-}
-
-static __inline void
-ahc_list_lock(unsigned long *flags)
-{
-	spin_lock_irqsave(&ahc_list_spinlock, *flags);
-}
-
-static __inline void
-ahc_list_unlock(unsigned long *flags)
-{
-	spin_unlock_irqrestore(&ahc_list_spinlock, *flags);
-}
-
 /******************************* PCI Definitions ******************************/
-/*
- * PCIM_xxx: mask to locate subfield in register
- * PCIR_xxx: config register offset
- * PCIC_xxx: device class
- * PCIS_xxx: device subclass
- * PCIP_xxx: device programming interface
- * PCIV_xxx: PCI vendor ID (only required to fixup ancient devices)
- * PCID_xxx: device ID
- */
-#define PCIR_DEVVENDOR		0x00
-#define PCIR_VENDOR		0x00
-#define PCIR_DEVICE		0x02
-#define PCIR_COMMAND		0x04
-#define PCIM_CMD_PORTEN		0x0001
-#define PCIM_CMD_MEMEN		0x0002
-#define PCIM_CMD_BUSMASTEREN	0x0004
-#define PCIM_CMD_MWRICEN	0x0010
-#define PCIM_CMD_PERRESPEN	0x0040
-#define	PCIM_CMD_SERRESPEN	0x0100
-#define PCIR_STATUS		0x06
-#define PCIR_REVID		0x08
-#define PCIR_PROGIF		0x09
-#define PCIR_SUBCLASS		0x0a
-#define PCIR_CLASS		0x0b
-#define PCIR_CACHELNSZ		0x0c
-#define PCIR_LATTIMER		0x0d
-#define PCIR_HEADERTYPE		0x0e
-#define PCIM_MFDEV		0x80
-#define PCIR_BIST		0x0f
-#define PCIR_CAP_PTR		0x34
-
-/* config registers for header type 0 devices */
-#define PCIR_MAPS	0x10
-#define PCIR_SUBVEND_0	0x2c
-#define PCIR_SUBDEV_0	0x2e
-
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 extern struct pci_driver aic7xxx_pci_driver;
 #endif
 
-typedef enum
-{
-	AHC_POWER_STATE_D0,
-	AHC_POWER_STATE_D1,
-	AHC_POWER_STATE_D2,
-	AHC_POWER_STATE_D3
-} ahc_power_state;
-
 /**************************** VL/EISA Routines ********************************/
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) \
   && (defined(__i386__) || defined(__alpha__)) \
@@ -840,7 +250,7 @@ typedef enum
 
 #ifdef CONFIG_EISA
 extern uint32_t aic7xxx_probe_eisa_vl;
-void			 ahc_linux_eisa_init(void);
+int			 ahc_linux_eisa_init(void);
 void			 ahc_linux_eisa_exit(void);
 int			 aic7770_map_registers(struct ahc_softc *ahc,
 					       u_int port);
@@ -849,118 +259,12 @@ int			 aic7770_map_int(struct ahc_softc 
 
 /******************************* PCI Routines *********************************/
 #ifdef CONFIG_PCI
-void			 ahc_power_state_change(struct ahc_softc *ahc,
-						ahc_power_state new_state);
 int			 ahc_linux_pci_init(void);
 void			 ahc_linux_pci_exit(void);
 int			 ahc_pci_map_registers(struct ahc_softc *ahc);
 int			 ahc_pci_map_int(struct ahc_softc *ahc);
+#endif 
 
-static __inline uint32_t ahc_pci_read_config(ahc_dev_softc_t pci,
-					     int reg, int width);
-
-static __inline uint32_t
-ahc_pci_read_config(ahc_dev_softc_t pci, int reg, int width)
-{
-	switch (width) {
-	case 1:
-	{
-		uint8_t retval;
-
-		pci_read_config_byte(pci, reg, &retval);
-		return (retval);
-	}
-	case 2:
-	{
-		uint16_t retval;
-		pci_read_config_word(pci, reg, &retval);
-		return (retval);
-	}
-	case 4:
-	{
-		uint32_t retval;
-		pci_read_config_dword(pci, reg, &retval);
-		return (retval);
-	}
-	default:
-		panic("ahc_pci_read_config: Read size too big");
-		/* NOTREACHED */
-		return (0);
-	}
-}
-
-static __inline void ahc_pci_write_config(ahc_dev_softc_t pci,
-					  int reg, uint32_t value,
-					  int width);
-
-static __inline void
-ahc_pci_write_config(ahc_dev_softc_t pci, int reg, uint32_t value, int width)
-{
-	switch (width) {
-	case 1:
-		pci_write_config_byte(pci, reg, value);
-		break;
-	case 2:
-		pci_write_config_word(pci, reg, value);
-		break;
-	case 4:
-		pci_write_config_dword(pci, reg, value);
-		break;
-	default:
-		panic("ahc_pci_write_config: Write size too big");
-		/* NOTREACHED */
-	}
-}
-
-static __inline int ahc_get_pci_function(ahc_dev_softc_t);
-static __inline int
-ahc_get_pci_function(ahc_dev_softc_t pci)
-{
-	return (PCI_FUNC(pci->devfn));
-}
-
-static __inline int ahc_get_pci_slot(ahc_dev_softc_t);
-static __inline int
-ahc_get_pci_slot(ahc_dev_softc_t pci)
-{
-	return (PCI_SLOT(pci->devfn));
-}
-
-static __inline int ahc_get_pci_bus(ahc_dev_softc_t);
-static __inline int
-ahc_get_pci_bus(ahc_dev_softc_t pci)
-{
-	return (pci->bus->number);
-}
-#endif
-
-static __inline void ahc_flush_device_writes(struct ahc_softc *);
-static __inline void
-ahc_flush_device_writes(struct ahc_softc *ahc)
-{
-	/* XXX Is this sufficient for all architectures??? */
-	ahc_inb(ahc, INTSTAT);
-}
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,3,0)
-#define pci_map_sg(pdev, sg_list, nseg, direction) (nseg)
-#define pci_unmap_sg(pdev, sg_list, nseg, direction)
-#define sg_dma_address(sg) (VIRT_TO_BUS((sg)->address))
-#define sg_dma_len(sg) ((sg)->length)
-#define pci_map_single(pdev, buffer, bufflen, direction) \
-	(VIRT_TO_BUS(buffer))
-#define pci_unmap_single(pdev, buffer, buflen, direction)
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
-#define ahc_pci_set_dma_mask pci_set_dma_mask
-#else
-/*
- * Always "return" 0 for success.
- */
-#define ahc_pci_set_dma_mask(dev_softc, mask)  			\
-	(((dev_softc)->dma_mask = mask) && 0)
-#endif
 /**************************** Proc FS Support *********************************/
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 int	ahc_linux_proc_info(char *, char **, off_t, int, int, int);
@@ -976,194 +280,9 @@ int	ahc_linux_proc_info(struct Scsi_Host
 	 && (ahc)->platform_data->qfrozen == 1)
 
 /*********************** Transaction Access Wrappers *************************/
-static __inline void ahc_cmd_set_transaction_status(Scsi_Cmnd *, uint32_t);
-static __inline void ahc_set_transaction_status(struct scb *, uint32_t);
-static __inline void ahc_cmd_set_scsi_status(Scsi_Cmnd *, uint32_t);
-static __inline void ahc_set_scsi_status(struct scb *, uint32_t);
-static __inline uint32_t ahc_cmd_get_transaction_status(Scsi_Cmnd *cmd);
-static __inline uint32_t ahc_get_transaction_status(struct scb *);
-static __inline uint32_t ahc_cmd_get_scsi_status(Scsi_Cmnd *cmd);
-static __inline uint32_t ahc_get_scsi_status(struct scb *);
-static __inline void ahc_set_transaction_tag(struct scb *, int, u_int);
-static __inline u_long ahc_get_transfer_length(struct scb *);
-static __inline int ahc_get_transfer_dir(struct scb *);
-static __inline void ahc_set_residual(struct scb *, u_long);
-static __inline void ahc_set_sense_residual(struct scb *scb, u_long resid);
-static __inline u_long ahc_get_residual(struct scb *);
-static __inline u_long ahc_get_sense_residual(struct scb *);
-static __inline int ahc_perform_autosense(struct scb *);
-static __inline uint32_t ahc_get_sense_bufsize(struct ahc_softc *,
-					       struct scb *);
-static __inline void ahc_notify_xfer_settings_change(struct ahc_softc *,
-						     struct ahc_devinfo *);
-static __inline void ahc_platform_scb_free(struct ahc_softc *ahc,
-					   struct scb *scb);
-static __inline void ahc_freeze_scb(struct scb *scb);
-
-static __inline
-void ahc_cmd_set_transaction_status(Scsi_Cmnd *cmd, uint32_t status)
-{
-	cmd->result &= ~(CAM_STATUS_MASK << 16);
-	cmd->result |= status << 16;
-}
-
-static __inline
-void ahc_set_transaction_status(struct scb *scb, uint32_t status)
-{
-	ahc_cmd_set_transaction_status(scb->io_ctx,status);
-}
-
-static __inline
-void ahc_cmd_set_scsi_status(Scsi_Cmnd *cmd, uint32_t status)
-{
-	cmd->result &= ~0xFFFF;
-	cmd->result |= status;
-}
-
-static __inline
-void ahc_set_scsi_status(struct scb *scb, uint32_t status)
-{
-	ahc_cmd_set_scsi_status(scb->io_ctx, status);
-}
-
-static __inline
-uint32_t ahc_cmd_get_transaction_status(Scsi_Cmnd *cmd)
-{
-	return ((cmd->result >> 16) & CAM_STATUS_MASK);
-}
-
-static __inline
-uint32_t ahc_get_transaction_status(struct scb *scb)
-{
-	return (ahc_cmd_get_transaction_status(scb->io_ctx));
-}
-
-static __inline
-uint32_t ahc_cmd_get_scsi_status(Scsi_Cmnd *cmd)
-{
-	return (cmd->result & 0xFFFF);
-}
-
-static __inline
-uint32_t ahc_get_scsi_status(struct scb *scb)
-{
-	return (ahc_cmd_get_scsi_status(scb->io_ctx));
-}
-
-static __inline
-void ahc_set_transaction_tag(struct scb *scb, int enabled, u_int type)
-{
-	/*
-	 * Nothing to do for linux as the incoming transaction
-	 * has no concept of tag/non tagged, etc.
-	 */
-}
-
-static __inline
-u_long ahc_get_transfer_length(struct scb *scb)
-{
-	return (scb->platform_data->xfer_len);
-}
-
-static __inline
-int ahc_get_transfer_dir(struct scb *scb)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,40)
-	return (scb->io_ctx->sc_data_direction);
-#else
-	if (scb->io_ctx->bufflen == 0)
-		return (CAM_DIR_NONE);
-
-	switch(scb->io_ctx->cmnd[0]) {
-	case 0x08:  /* READ(6)  */
-	case 0x28:  /* READ(10) */
-	case 0xA8:  /* READ(12) */
-		return (CAM_DIR_IN);
-        case 0x0A:  /* WRITE(6)  */
-        case 0x2A:  /* WRITE(10) */
-        case 0xAA:  /* WRITE(12) */
-		return (CAM_DIR_OUT);
-        default:
-		return (CAM_DIR_NONE);
-        }
-#endif
-}
-
-static __inline
-void ahc_set_residual(struct scb *scb, u_long resid)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	scb->io_ctx->resid = resid;
-#else
-	scb->platform_data->resid = resid;
-#endif
-}
-
-static __inline
-void ahc_set_sense_residual(struct scb *scb, u_long resid)
-{
-	scb->platform_data->sense_resid = resid;
-}
-
-static __inline
-u_long ahc_get_residual(struct scb *scb)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	return (scb->io_ctx->resid);
-#else
-	return (scb->platform_data->resid);
-#endif
-}
-
-static __inline
-u_long ahc_get_sense_residual(struct scb *scb)
-{
-	return (scb->platform_data->sense_resid);
-}
-
-static __inline
-int ahc_perform_autosense(struct scb *scb)
-{
-	/*
-	 * We always perform autosense in Linux.
-	 * On other platforms this is set on a
-	 * per-transaction basis.
-	 */
-	return (1);
-}
-
-static __inline uint32_t
-ahc_get_sense_bufsize(struct ahc_softc *ahc, struct scb *scb)
-{
-	return (sizeof(struct scsi_sense_data));
-}
-
-static __inline void
-ahc_notify_xfer_settings_change(struct ahc_softc *ahc,
-				struct ahc_devinfo *devinfo)
-{
-	/* Nothing to do here for linux */
-}
-
-static __inline void
-ahc_platform_scb_free(struct ahc_softc *ahc, struct scb *scb)
-{
-	ahc->flags &= ~AHC_RESOURCE_SHORTAGE;
-}
-
 int	ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg);
 void	ahc_platform_free(struct ahc_softc *ahc);
 void	ahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb);
-
-static __inline void
-ahc_freeze_scb(struct scb *scb)
-{
-	if ((scb->io_ctx->result & (CAM_DEV_QFRZN << 16)) == 0) {
-                scb->io_ctx->result |= CAM_DEV_QFRZN << 16;
-                scb->platform_data->dev->qfrozen++;
-        }
-}
-
 void	ahc_platform_set_tags(struct ahc_softc *ahc,
 			      struct ahc_devinfo *devinfo, ahc_queue_alg);
 int	ahc_platform_abort_scbs(struct ahc_softc *ahc, int target,
@@ -1180,9 +299,9 @@ void	ahc_print_path(struct ahc_softc *, 
 void	ahc_platform_dump_card_state(struct ahc_softc *ahc);
 
 #ifdef CONFIG_PCI
-#define AHC_PCI_CONFIG 1
+#define AIC_PCI_CONFIG 1
 #else
-#define AHC_PCI_CONFIG 0
+#define AIC_PCI_CONFIG 0
 #endif
 #define bootverbose aic7xxx_verbose
 extern u_int aic7xxx_verbose;
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c	2004-04-04 05:36:54.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c	2004-05-13 16:42:17.000000000 +0200
@@ -36,16 +36,18 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#47 $
+ * $Id$
  */
 
 #include "aic7xxx_osm.h"
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-struct pci_device_id
-{
-};
-#endif
+/*
+ * Include aiclib_pci.c as part of our
+ * "module dependencies are hard" work around.
+ */
+#include "aiclib_pci.c"
+
+static int	ahc_pci_module_registered;
 
 static int	ahc_linux_pci_dev_probe(struct pci_dev *pdev,
 					const struct pci_device_id *ent);
@@ -54,7 +56,6 @@ static int	ahc_linux_pci_reserve_io_regi
 static int	ahc_linux_pci_reserve_mem_region(struct ahc_softc *ahc,
 						 u_long *bus_addr,
 						 uint8_t **maddr);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 static void	ahc_linux_pci_dev_remove(struct pci_dev *pdev);
 
 /* We do our own ID filtering.  So, grab all SCSI storage class devices. */
@@ -95,14 +96,15 @@ ahc_linux_pci_dev_remove(struct pci_dev 
 	if (ahc != NULL) {
 		u_long s;
 
+		TAILQ_REMOVE(&ahc_tailq, ahc, links);
+		ahc_list_unlock(&l);
 		ahc_lock(ahc, &s);
 		ahc_intr_enable(ahc, FALSE);
 		ahc_unlock(ahc, &s);
 		ahc_free(ahc);
-	}
-	ahc_list_unlock(&l);
+	} else
+		ahc_list_unlock(&l);
 }
-#endif /* !LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) */
 
 static int
 ahc_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
@@ -110,7 +112,7 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 	char		 buf[80];
 	bus_addr_t	 mask_39bit;
 	struct		 ahc_softc *ahc;
-	ahc_dev_softc_t	 pci;
+	aic_dev_softc_t	 dev;
 	struct		 ahc_pci_identity *entry;
 	char		*name;
 	int		 error;
@@ -121,7 +123,7 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 	TAILQ_FOREACH(ahc, &ahc_tailq, links) {
 		struct pci_dev *probed_pdev;
 
-		probed_pdev = ahc->dev_softc;
+		probed_pdev = aic_dev_to_pci_dev(ahc->dev_softc);
 		if (probed_pdev->bus->number == pdev->bus->number
 		 && probed_pdev->devfn == pdev->devfn)
 			break;
@@ -131,8 +133,8 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 		return (-ENODEV);
 	}
 
-	pci = pdev;
-	entry = ahc_find_pci_device(pci);
+	dev = aic_pci_dev_to_dev(pdev);
+	entry = ahc_find_pci_device(dev);
 	if (entry == NULL)
 		return (-ENODEV);
 
@@ -142,9 +144,9 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 	 * common detect routine.
 	 */
 	sprintf(buf, "ahc_pci:%d:%d:%d",
-		ahc_get_pci_bus(pci),
-		ahc_get_pci_slot(pci),
-		ahc_get_pci_function(pci));
+		aic_get_pci_bus(dev),
+		aic_get_pci_slot(dev),
+		aic_get_pci_function(dev));
 	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
 	if (name == NULL)
 		return (-ENOMEM);
@@ -152,34 +154,41 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 	ahc = ahc_alloc(NULL, name);
 	if (ahc == NULL)
 		return (-ENOMEM);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	ahc->dev_softc = dev;
+
 	if (pci_enable_device(pdev)) {
 		ahc_free(ahc);
 		return (-ENODEV);
 	}
 	pci_set_master(pdev);
 
+	if (aic_set_consistent_dma_mask(ahc, 0xFFFFFFFF) != 0) {
+		printk(KERN_WARNING "aic7xxx: Unable to set"
+		       "coherent DMA mask.\n");
+		ahc_free(ahc);
+		return (-ENOMEM);
+	}
+
 	mask_39bit = (bus_addr_t)0x7FFFFFFFFFULL;
 	if (sizeof(bus_addr_t) > 4
 	 && ahc_linux_get_memsize() > 0x80000000
-	 && ahc_pci_set_dma_mask(pdev, mask_39bit) == 0) {
+	 && aic_set_dma_mask(ahc, mask_39bit) == 0) {
 		ahc->flags |= AHC_39BIT_ADDRESSING;
 		ahc->platform_data->hw_dma_mask = mask_39bit;
 	} else {
-		if (ahc_pci_set_dma_mask(pdev, 0xFFFFFFFF)) {
-			printk(KERN_WARNING "aic7xxx: No suitable DMA available.\n");
-                	return (-ENODEV);
+		if (aic_set_dma_mask(ahc, 0xFFFFFFFF) != 0) {
+			printk(KERN_WARNING "aic7xxx: Unable to set data "
+			       "DMA mask.\n");
+			ahc_free(ahc);
+			return (-ENOMEM);
 		}
 		ahc->platform_data->hw_dma_mask = 0xFFFFFFFF;
 	}
-#endif
-	ahc->dev_softc = pci;
 	error = ahc_pci_config(ahc, entry);
 	if (error != 0) {
 		ahc_free(ahc);
 		return (-error);
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 	pci_set_drvdata(pdev, ahc);
 	if (aic7xxx_detect_complete) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -190,44 +199,25 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 		return (-ENODEV);
 #endif
 	}
-#endif
 	return (0);
 }
 
 int
 ahc_linux_pci_init(void)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	return (pci_module_init(&aic7xxx_pci_driver));
-#else
-	struct pci_dev *pdev;
-	u_int class;
-	int found;
-
-	/* If we don't have a PCI bus, we can't find any adapters. */
-	if (pci_present() == 0)
-		return (0);
-
-	found = 0;
-	pdev = NULL;
-	class = PCI_CLASS_STORAGE_SCSI << 8;
-	while ((pdev = pci_find_class(class, pdev)) != NULL) {
-		ahc_dev_softc_t pci;
-		int error;
-
-		pci = pdev;
-		error = ahc_linux_pci_dev_probe(pdev, /*pci_devid*/NULL);
-		if (error == 0)
-			found++;
-	}
-	return (found);
-#endif
+	int error;
+	
+	error = pci_module_init(&aic7xxx_pci_driver);
+	if (error == 0)
+		ahc_pci_module_registered = 1;
+	return (error);
 }
 
 void
 ahc_linux_pci_exit(void)
 {
-	pci_unregister_driver(&aic7xxx_pci_driver);
+	if (ahc_pci_module_registered != 0)
+		pci_unregister_driver(&aic7xxx_pci_driver);
 }
 
 static int
@@ -236,22 +226,11 @@ ahc_linux_pci_reserve_io_region(struct a
 	if (aic7xxx_allow_memio == 0)
 		return (ENOMEM);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	*base = pci_resource_start(ahc->dev_softc, 0);
-#else
-	*base = ahc_pci_read_config(ahc->dev_softc, PCIR_MAPS, 4);
-	*base &= PCI_BASE_ADDRESS_IO_MASK;
-#endif
+	*base = pci_resource_start(aic_pci_dev(ahc), 0);
 	if (*base == 0)
 		return (ENOMEM);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-	if (check_region(*base, 256) != 0)
-		return (ENOMEM);
-	request_region(*base, 256, "aic7xxx");
-#else
 	if (request_region(*base, 256, "aic7xxx") == 0)
 		return (ENOMEM);
-#endif
 	return (0);
 }
 
@@ -266,29 +245,18 @@ ahc_linux_pci_reserve_mem_region(struct 
 	int	error;
 
 	error = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	start = pci_resource_start(ahc->dev_softc, 1);
+	start = pci_resource_start(aic_pci_dev(ahc), 1);
 	base_page = start & PAGE_MASK;
 	base_offset = start - base_page;
-#else
-	start = ahc_pci_read_config(ahc->dev_softc, PCIR_MAPS+4, 4);
-	base_offset = start & PCI_BASE_ADDRESS_MEM_MASK;
-	base_page = base_offset & PAGE_MASK;
-	base_offset -= base_page;
-#endif
 	if (start != 0) {
 		*bus_addr = start;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 		if (request_mem_region(start, 0x1000, "aic7xxx") == 0)
 			error = ENOMEM;
-#endif
 		if (error == 0) {
 			*maddr = ioremap_nocache(base_page, base_offset + 256);
 			if (*maddr == NULL) {
 				error = ENOMEM;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 				release_mem_region(start, 0x1000);
-#endif
 			} else
 				*maddr += base_offset;
 		}
@@ -308,7 +276,7 @@ ahc_pci_map_registers(struct ahc_softc *
 	/*
 	 * If its allowed, we prefer memory mapped access.
 	 */
-	command = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, 4);
+	command = aic_pci_read_config(ahc->dev_softc, PCIR_COMMAND, 4);
 	command &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);
 	base = 0;
 	maddr = NULL;
@@ -317,7 +285,7 @@ ahc_pci_map_registers(struct ahc_softc *
 		ahc->platform_data->mem_busaddr = base;
 		ahc->tag = BUS_SPACE_MEMIO;
 		ahc->bsh.maddr = maddr;
-		ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,
+		aic_pci_write_config(ahc->dev_softc, PCIR_COMMAND,
 				     command | PCIM_CMD_MEMEN, 4);
 
 		/*
@@ -328,14 +296,12 @@ ahc_pci_map_registers(struct ahc_softc *
 
 			printf("aic7xxx: PCI Device %d:%d:%d "
 			       "failed memory mapped test.  Using PIO.\n",
-			       ahc_get_pci_bus(ahc->dev_softc),
-			       ahc_get_pci_slot(ahc->dev_softc),
-			       ahc_get_pci_function(ahc->dev_softc));
+			       aic_get_pci_bus(ahc->dev_softc),
+			       aic_get_pci_slot(ahc->dev_softc),
+			       aic_get_pci_function(ahc->dev_softc));
 			iounmap((void *)((u_long)maddr & PAGE_MASK));
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 			release_mem_region(ahc->platform_data->mem_busaddr,
 					   0x1000);
-#endif
 			ahc->bsh.maddr = NULL;
 			maddr = NULL;
 		} else
@@ -343,9 +309,9 @@ ahc_pci_map_registers(struct ahc_softc *
 	} else {
 		printf("aic7xxx: PCI%d:%d:%d MEM region 0x%lx "
 		       "unavailable. Cannot memory map device.\n",
-		       ahc_get_pci_bus(ahc->dev_softc),
-		       ahc_get_pci_slot(ahc->dev_softc),
-		       ahc_get_pci_function(ahc->dev_softc),
+		       aic_get_pci_bus(ahc->dev_softc),
+		       aic_get_pci_slot(ahc->dev_softc),
+		       aic_get_pci_function(ahc->dev_softc),
 		       base);
 	}
 
@@ -355,20 +321,20 @@ ahc_pci_map_registers(struct ahc_softc *
 	if (maddr == NULL) {
 
 		error = ahc_linux_pci_reserve_io_region(ahc, &base);
-		if (error == 0) {
+		if (error == 0 && ahc_pci_test_register_access(ahc) == 0) {
 			ahc->tag = BUS_SPACE_PIO;
 			ahc->bsh.ioport = base;
 			command |= PCIM_CMD_PORTEN;
 		} else {
 			printf("aic7xxx: PCI%d:%d:%d IO region 0x%lx[0..255] "
 			       "unavailable. Cannot map device.\n",
-			       ahc_get_pci_bus(ahc->dev_softc),
-			       ahc_get_pci_slot(ahc->dev_softc),
-			       ahc_get_pci_function(ahc->dev_softc),
+			       aic_get_pci_bus(ahc->dev_softc),
+			       aic_get_pci_slot(ahc->dev_softc),
+			       aic_get_pci_function(ahc->dev_softc),
 			       base);
 		}
 	}
-	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, 4);
+	aic_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, 4);
 	return (error);
 }
 
@@ -377,49 +343,10 @@ ahc_pci_map_int(struct ahc_softc *ahc)
 {
 	int error;
 
-	error = request_irq(ahc->dev_softc->irq, ahc_linux_isr,
+	error = request_irq(aic_pci_dev(ahc)->irq, ahc_linux_isr,
 			    SA_SHIRQ, "aic7xxx", ahc);
 	if (error == 0)
-		ahc->platform_data->irq = ahc->dev_softc->irq;
+		ahc->platform_data->irq = aic_pci_dev(ahc)->irq;
 	
 	return (-error);
 }
-
-void
-ahc_power_state_change(struct ahc_softc *ahc, ahc_power_state new_state)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	pci_set_power_state(ahc->dev_softc, new_state);
-#else
-	uint32_t cap;
-	u_int cap_offset;
-
-	/*
-	 * Traverse the capability list looking for
-	 * the power management capability.
-	 */
-	cap = 0;
-	cap_offset = ahc_pci_read_config(ahc->dev_softc,
-					 PCIR_CAP_PTR, /*bytes*/1);
-	while (cap_offset != 0) {
-
-		cap = ahc_pci_read_config(ahc->dev_softc,
-					  cap_offset, /*bytes*/4);
-		if ((cap & 0xFF) == 1
-		 && ((cap >> 16) & 0x3) > 0) {
-			uint32_t pm_control;
-
-			pm_control = ahc_pci_read_config(ahc->dev_softc,
-							 cap_offset + 4,
-							 /*bytes*/4);
-			pm_control &= ~0x3;
-			pm_control |= new_state;
-			ahc_pci_write_config(ahc->dev_softc,
-					     cap_offset + 4,
-					     pm_control, /*bytes*/2);
-			break;
-		}
-		cap_offset = (cap >> 8) & 0xFF;
-	}
-#endif 
-}
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_pci.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_pci.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_pci.c	2004-04-04 05:36:16.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_pci.c	2004-05-13 16:42:17.000000000 +0200
@@ -39,9 +39,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#69 $
- *
- * $FreeBSD$
+ * $Id$
  */
 
 #ifdef __linux__
@@ -49,14 +47,13 @@
 #include "aic7xxx_inline.h"
 #include "aic7xxx_93cx6.h"
 #else
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
 #include <dev/aic7xxx/aic7xxx_osm.h>
 #include <dev/aic7xxx/aic7xxx_inline.h>
 #include <dev/aic7xxx/aic7xxx_93cx6.h>
 #endif
 
-#define AHC_PCI_IOADDR	PCIR_MAPS	/* I/O Address */
-#define AHC_PCI_MEMADDR	(PCIR_MAPS + 4)	/* Mem I/O Address */
-
 static __inline uint64_t
 ahc_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)
 {
@@ -133,6 +130,7 @@ ahc_compose_id(u_int device, u_int vendo
 #define ID_AHA_29160C			0x0080900562209005ull
 #define ID_AHA_29160B			0x00809005E2209005ull
 #define ID_AHA_19160B			0x0081900562A19005ull
+#define ID_AHA_2915_30LP		0x0082900502109005ull
 
 #define ID_AIC7896			0x005F9005FFFF9005ull
 #define ID_AIC7896_ARO			0x00539005FFFF9005ull
@@ -470,6 +468,12 @@ struct ahc_pci_identity ahc_pci_ident_ta
 		"Adaptec aic7892 Ultra160 SCSI adapter (ARO)",
 		ahc_aic7892_setup
 	},
+	{
+		ID_AHA_2915_30LP,
+		ID_ALL_MASK,
+		"Adaptec 2915/30LP Ultra160 SCSI adapter",
+		ahc_aic7892_setup
+	},
 	/* aic7895 based controllers */	
 	{
 		ID_AHA_2940U_DUAL,
@@ -738,7 +742,7 @@ ahc_9005_subdevinfo_valid(uint16_t devic
 }
 
 struct ahc_pci_identity *
-ahc_find_pci_device(ahc_dev_softc_t pci)
+ahc_find_pci_device(aic_dev_softc_t pci)
 {
 	uint64_t  full_id;
 	uint16_t  device;
@@ -748,10 +752,10 @@ ahc_find_pci_device(ahc_dev_softc_t pci)
 	struct	  ahc_pci_identity *entry;
 	u_int	  i;
 
-	vendor = ahc_pci_read_config(pci, PCIR_DEVVENDOR, /*bytes*/2);
-	device = ahc_pci_read_config(pci, PCIR_DEVICE, /*bytes*/2);
-	subvendor = ahc_pci_read_config(pci, PCIR_SUBVEND_0, /*bytes*/2);
-	subdevice = ahc_pci_read_config(pci, PCIR_SUBDEV_0, /*bytes*/2);
+	vendor = aic_pci_read_config(pci, PCIR_DEVVENDOR, /*bytes*/2);
+	device = aic_pci_read_config(pci, PCIR_DEVICE, /*bytes*/2);
+	subvendor = aic_pci_read_config(pci, PCIR_SUBVEND_0, /*bytes*/2);
+	subdevice = aic_pci_read_config(pci, PCIR_SUBDEV_0, /*bytes*/2);
 	full_id = ahc_compose_id(device, vendor, subdevice, subvendor);
 
 	/*
@@ -761,7 +765,7 @@ ahc_find_pci_device(ahc_dev_softc_t pci)
 	 * to sanity check it prior to accepting the subdevice
 	 * ID as valid.
 	 */
-	if (ahc_get_pci_function(pci) > 0
+	if (aic_get_pci_function(pci) > 0
 	 && ahc_9005_subdevinfo_valid(vendor, device, subvendor, subdevice)
 	 && SUBID_9005_MFUNCENB(subdevice) == 0)
 		return (NULL);
@@ -798,7 +802,7 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	ahc->chip |= AHC_PCI;
 	ahc->description = entry->name;
 
-	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
+	aic_power_state_change(ahc, AIC_POWER_STATE_D0);
 
 	error = ahc_pci_map_registers(ahc);
 	if (error != 0)
@@ -812,7 +816,7 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	 */
 	ahc_intr_enable(ahc, FALSE);
 
-	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4);
+	devconfig = aic_pci_read_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4);
 
 	/*
 	 * If we need to support high memory, enable dual
@@ -831,13 +835,13 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	/* Ensure that pci error generation, a test feature, is disabled. */
 	devconfig |= PCIERRGENDIS;
 
-	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
+	aic_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
 
 	/* Ensure busmastering is enabled */
-	command = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	command = aic_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/2);
 	command |= PCIM_CMD_BUSMASTEREN;
 
-	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, /*bytes*/2);
+	aic_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, /*bytes*/2);
 
 	/* On all PCI adapters, we allow SCB paging */
 	ahc->flags |= AHC_PAGESCBS;
@@ -920,14 +924,14 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	ahc_outb(ahc, DSCOMMAND0, dscommand0);
 
 	ahc->pci_cachesize =
-	    ahc_pci_read_config(ahc->dev_softc, CSIZE_LATTIME,
+	    aic_pci_read_config(ahc->dev_softc, CSIZE_LATTIME,
 				/*bytes*/1) & CACHESIZE;
 	ahc->pci_cachesize *= 4;
 
 	if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0
 	 && ahc->pci_cachesize == 4) {
 
-		ahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME,
+		aic_pci_write_config(ahc->dev_softc, CSIZE_LATTIME,
 				     0, /*bytes*/1);
 		ahc->pci_cachesize = 0;
 	}
@@ -939,7 +943,7 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	if ((ahc->features & AHC_ULTRA) != 0) {
 		uint32_t devconfig;
 
-		devconfig = ahc_pci_read_config(ahc->dev_softc,
+		devconfig = aic_pci_read_config(ahc->dev_softc,
 						DEVCONFIG, /*bytes*/4);
 		if ((devconfig & REXTVALID) == 0)
 			ahc->features &= ~AHC_ULTRA;
@@ -1005,11 +1009,11 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	 * that occur during runtime and resume events.
 	 */
 	ahc->bus_softc.pci_softc.devconfig =
-	    ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4);
+	    aic_pci_read_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4);
 	ahc->bus_softc.pci_softc.command =
-	    ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/1);
+	    aic_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/1);
 	ahc->bus_softc.pci_softc.csize_lattime =
-	    ahc_pci_read_config(ahc->dev_softc, CSIZE_LATTIME, /*bytes*/1);
+	    aic_pci_read_config(ahc->dev_softc, CSIZE_LATTIME, /*bytes*/1);
 	ahc->bus_softc.pci_softc.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
 	ahc->bus_softc.pci_softc.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
 	if ((ahc->features & AHC_DT) != 0) {
@@ -1063,7 +1067,7 @@ ahc_ext_scbram_present(struct ahc_softc 
 	uint32_t devconfig;
 
 	chip = ahc->chip & AHC_CHIPID_MASK;
-	devconfig = ahc_pci_read_config(ahc->dev_softc,
+	devconfig = aic_pci_read_config(ahc->dev_softc,
 					DEVCONFIG, /*bytes*/4);
 	single_user = (devconfig & MPORTMODE) != 0;
 
@@ -1101,13 +1105,13 @@ ahc_scbram_config(struct ahc_softc *ahc,
 		 * Set the SCB Base addr (highest address bit)
 		 * depending on which channel we are.
 		 */
-		ahc_outb(ahc, SCBBADDR, ahc_get_pci_function(ahc->dev_softc));
+		ahc_outb(ahc, SCBBADDR, aic_get_pci_function(ahc->dev_softc));
 	}
 
 	ahc->flags &= ~AHC_LSCBS_ENABLED;
 	if (large)
 		ahc->flags |= AHC_LSCBS_ENABLED;
-	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4);
+	devconfig = aic_pci_read_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4);
 	if ((ahc->features & AHC_ULTRA2) != 0) {
 		u_int dscommand0;
 
@@ -1140,7 +1144,7 @@ ahc_scbram_config(struct ahc_softc *ahc,
 	else
 		devconfig &= ~EXTSCBPEN;
 
-	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
+	aic_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
 }
 
 /*
@@ -1263,8 +1267,8 @@ ahc_pci_test_register_access(struct ahc_
 	 * Enable PCI error interrupt status, but suppress NMIs
 	 * generated by SERR raised due to target aborts.
 	 */
-	cmd = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/2);
-	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,
+	cmd = aic_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	aic_pci_write_config(ahc->dev_softc, PCIR_COMMAND,
 			     cmd & ~PCIM_CMD_SERRESPEN, /*bytes*/2);
 
 	/*
@@ -1276,24 +1280,36 @@ ahc_pci_test_register_access(struct ahc_
 	 * use for this test.
 	 */
 	hcntrl = ahc_inb(ahc, HCNTRL);
+
 	if (hcntrl == 0xFF)
 		goto fail;
 
+	if ((hcntrl & CHIPRST) != 0) {
+		/*
+		 * The chip has not been initialized since
+		 * PCI/EISA/VLB bus reset.  Don't trust
+		 * "left over BIOS data".
+		 */
+		ahc->flags |= AHC_NO_BIOS_INIT;
+	}
+
 	/*
 	 * Next create a situation where write combining
 	 * or read prefetching could be initiated by the
 	 * CPU or host bridge.  Our device does not support
 	 * either, so look for data corruption and/or flagged
-	 * PCI errors.
+	 * PCI errors.  First pause without causing another
+	 * chip reset.
 	 */
+	hcntrl &= ~CHIPRST;
 	ahc_outb(ahc, HCNTRL, hcntrl|PAUSE);
 	while (ahc_is_paused(ahc) == 0)
 		;
 
 	/* Clear any PCI errors that occurred before our driver attached. */
-	status1 = ahc_pci_read_config(ahc->dev_softc,
+	status1 = aic_pci_read_config(ahc->dev_softc,
 				      PCIR_STATUS + 1, /*bytes*/1);
-	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
+	aic_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
 			     status1, /*bytes*/1);
 	ahc_outb(ahc, CLRINT, CLRPARERR);
 
@@ -1303,7 +1319,7 @@ ahc_pci_test_register_access(struct ahc_
 	if (ahc_inl(ahc, SCB_BASE) != 0x5aa555aa)
 		goto fail;
 
-	status1 = ahc_pci_read_config(ahc->dev_softc,
+	status1 = aic_pci_read_config(ahc->dev_softc,
 				      PCIR_STATUS + 1, /*bytes*/1);
 	if ((status1 & STA) != 0)
 		goto fail;
@@ -1312,13 +1328,13 @@ ahc_pci_test_register_access(struct ahc_
 
 fail:
 	/* Silently clear any latched errors. */
-	status1 = ahc_pci_read_config(ahc->dev_softc,
+	status1 = aic_pci_read_config(ahc->dev_softc,
 				      PCIR_STATUS + 1, /*bytes*/1);
-	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
+	aic_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
 			     status1, /*bytes*/1);
 	ahc_outb(ahc, CLRINT, CLRPARERR);
 	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
-	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
+	aic_pci_write_config(ahc->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
 	return (error);
 }
 
@@ -1388,6 +1404,10 @@ check_extport(struct ahc_softc *ahc, u_i
 			sd.sd_chip = C56_66;
 		}
 		ahc_release_seeprom(&sd);
+
+		/* Remember the SEEPROM type for later */
+		if (sd.sd_chip == C56_66)
+			ahc->flags |= AHC_LARGE_SEEPROM;
 	}
 
 	if (!have_seeprom) {
@@ -1573,12 +1593,12 @@ ahc_parse_pci_eeprom(struct ahc_softc *a
 		uint32_t devconfig;
 
 		/* Honor the STPWLEVEL settings */
-		devconfig = ahc_pci_read_config(ahc->dev_softc,
+		devconfig = aic_pci_read_config(ahc->dev_softc,
 						DEVCONFIG, /*bytes*/4);
 		devconfig &= ~STPWLEVEL;
 		if ((sc->bios_control & CFSTPWLEVEL) != 0)
 			devconfig |= STPWLEVEL;
-		ahc_pci_write_config(ahc->dev_softc, DEVCONFIG,
+		aic_pci_write_config(ahc->dev_softc, DEVCONFIG,
 				     devconfig, /*bytes*/4);
 	}
 	/* Set SCSICONF info */
@@ -1891,10 +1911,10 @@ aic785X_cable_detect(struct ahc_softc *a
 	ahc_outb(ahc, SPIOCAP, spiocap);
 	ahc_outb(ahc, BRDCTL, BRDRW|BRDCS);
 	ahc_flush_device_writes(ahc);
-	ahc_delay(500);
+	aic_delay(500);
 	ahc_outb(ahc, BRDCTL, 0);
 	ahc_flush_device_writes(ahc);
-	ahc_delay(500);
+	aic_delay(500);
 	brdctl = ahc_inb(ahc, BRDCTL);
 	*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;
 	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
@@ -1920,7 +1940,7 @@ ahc_acquire_seeprom(struct ahc_softc *ah
 	SEEPROM_OUTB(sd, sd->sd_MS);
 	wait = 1000;  /* 1 second timeout in msec */
 	while (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {
-		ahc_delay(1000);  /* delay 1 msec */
+		aic_delay(1000);  /* delay 1 msec */
 	}
 	if ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {
 		SEEPROM_OUTB(sd, 0); 
@@ -2000,7 +2020,7 @@ ahc_pci_intr(struct ahc_softc *ahc)
 	if ((error & PCIERRSTAT) == 0)
 		return;
 
-	status1 = ahc_pci_read_config(ahc->dev_softc,
+	status1 = aic_pci_read_config(ahc->dev_softc,
 				      PCIR_STATUS + 1, /*bytes*/1);
 
 	printf("%s: PCI error Interrupt at seqaddr = 0x%x\n",
@@ -2030,7 +2050,7 @@ ahc_pci_intr(struct ahc_softc *ahc)
 	}
 
 	/* Clear latched errors. */
-	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
+	aic_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
 			     status1, /*bytes*/1);
 
 	if ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {
@@ -2091,7 +2111,7 @@ static int
 ahc_pci_resume(struct ahc_softc *ahc)
 {
 
-	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
+	aic_power_state_change(ahc, AIC_POWER_STATE_D0);
 
 	/*
 	 * We assume that the OS has restored our register
@@ -2099,11 +2119,11 @@ ahc_pci_resume(struct ahc_softc *ahc)
 	 * that the OS doesn't know about and rely on our chip
 	 * reset handler to handle the rest.
 	 */
-	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4,
+	aic_pci_write_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4,
 			     ahc->bus_softc.pci_softc.devconfig);
-	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/1,
+	aic_pci_write_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/1,
 			     ahc->bus_softc.pci_softc.command);
-	ahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME, /*bytes*/1,
+	aic_pci_write_config(ahc->dev_softc, CSIZE_LATTIME, /*bytes*/1,
 			     ahc->bus_softc.pci_softc.csize_lattime);
 	if ((ahc->flags & AHC_HAS_TERM_LOGIC) != 0) {
 		struct	seeprom_descriptor sd;
@@ -2126,7 +2146,7 @@ ahc_pci_resume(struct ahc_softc *ahc)
 static int
 ahc_aic785X_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 	uint8_t rev;
 
 	pci = ahc->dev_softc;
@@ -2134,7 +2154,7 @@ ahc_aic785X_setup(struct ahc_softc *ahc)
 	ahc->chip = AHC_AIC7850;
 	ahc->features = AHC_AIC7850_FE;
 	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
-	rev = ahc_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
+	rev = aic_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev >= 1)
 		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
 	ahc->instruction_ram_size = 512;
@@ -2144,7 +2164,7 @@ ahc_aic785X_setup(struct ahc_softc *ahc)
 static int
 ahc_aic7860_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 	uint8_t rev;
 
 	pci = ahc->dev_softc;
@@ -2152,7 +2172,7 @@ ahc_aic7860_setup(struct ahc_softc *ahc)
 	ahc->chip = AHC_AIC7860;
 	ahc->features = AHC_AIC7860_FE;
 	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
-	rev = ahc_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
+	rev = aic_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev >= 1)
 		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
 	ahc->instruction_ram_size = 512;
@@ -2219,7 +2239,7 @@ ahc_aha494X_setup(struct ahc_softc *ahc)
 static int
 ahc_aic7880_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 	uint8_t rev;
 
 	pci = ahc->dev_softc;
@@ -2227,7 +2247,7 @@ ahc_aic7880_setup(struct ahc_softc *ahc)
 	ahc->chip = AHC_AIC7880;
 	ahc->features = AHC_AIC7880_FE;
 	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
-	rev = ahc_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
+	rev = aic_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev >= 1) {
 		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
 	} else {
@@ -2270,7 +2290,7 @@ ahc_aha398XU_setup(struct ahc_softc *ahc
 static int
 ahc_aic7890_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 	uint8_t rev;
 
 	pci = ahc->dev_softc;
@@ -2278,7 +2298,7 @@ ahc_aic7890_setup(struct ahc_softc *ahc)
 	ahc->chip = AHC_AIC7890;
 	ahc->features = AHC_AIC7890_FE;
 	ahc->flags |= AHC_NEWEEPROM_FMT;
-	rev = ahc_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
+	rev = aic_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev == 0)
 		ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
 	ahc->instruction_ram_size = 768;
@@ -2301,15 +2321,15 @@ ahc_aic7892_setup(struct ahc_softc *ahc)
 static int
 ahc_aic7895_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 	uint8_t rev;
 
 	pci = ahc->dev_softc;
-	ahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';
+	ahc->channel = aic_get_pci_function(pci) == 1 ? 'B' : 'A';
 	/*
 	 * The 'C' revision of the aic7895 has a few additional features.
 	 */
-	rev = ahc_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
+	rev = aic_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev >= 4) {
 		ahc->chip = AHC_AIC7895C;
 		ahc->features = AHC_AIC7895C_FE;
@@ -2325,9 +2345,9 @@ ahc_aic7895_setup(struct ahc_softc *ahc)
 		 * we have.  Disabling MWI reduces performance, so
 		 * turn it on again.
 		 */
-		command = ahc_pci_read_config(pci, PCIR_COMMAND, /*bytes*/1);
+		command = aic_pci_read_config(pci, PCIR_COMMAND, /*bytes*/1);
 		command |= PCIM_CMD_MWRICEN;
-		ahc_pci_write_config(pci, PCIR_COMMAND, command, /*bytes*/1);
+		aic_pci_write_config(pci, PCIR_COMMAND, command, /*bytes*/1);
 		ahc->bugs |= AHC_PCI_MWI_BUG;
 	}
 	/*
@@ -2344,10 +2364,10 @@ ahc_aic7895_setup(struct ahc_softc *ahc)
 	 * Cachesize must also be zero due to stray DAC
 	 * problem when sitting behind some bridges.
 	 */
-	ahc_pci_write_config(pci, CSIZE_LATTIME, 0, /*bytes*/1);
-	devconfig = ahc_pci_read_config(pci, DEVCONFIG, /*bytes*/1);
+	aic_pci_write_config(pci, CSIZE_LATTIME, 0, /*bytes*/1);
+	devconfig = aic_pci_read_config(pci, DEVCONFIG, /*bytes*/1);
 	devconfig |= MRDCEN;
-	ahc_pci_write_config(pci, DEVCONFIG, devconfig, /*bytes*/1);
+	aic_pci_write_config(pci, DEVCONFIG, devconfig, /*bytes*/1);
 #endif
 	ahc->flags |= AHC_NEWEEPROM_FMT;
 	ahc->instruction_ram_size = 512;
@@ -2357,10 +2377,10 @@ ahc_aic7895_setup(struct ahc_softc *ahc)
 static int
 ahc_aic7896_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 
 	pci = ahc->dev_softc;
-	ahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';
+	ahc->channel = aic_get_pci_function(pci) == 1 ? 'B' : 'A';
 	ahc->chip = AHC_AIC7896;
 	ahc->features = AHC_AIC7896_FE;
 	ahc->flags |= AHC_NEWEEPROM_FMT;
@@ -2372,10 +2392,10 @@ ahc_aic7896_setup(struct ahc_softc *ahc)
 static int
 ahc_aic7899_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 
 	pci = ahc->dev_softc;
-	ahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';
+	ahc->channel = aic_get_pci_function(pci) == 1 ? 'B' : 'A';
 	ahc->chip = AHC_AIC7899;
 	ahc->features = AHC_AIC7899_FE;
 	ahc->flags |= AHC_NEWEEPROM_FMT;
@@ -2406,10 +2426,10 @@ ahc_raid_setup(struct ahc_softc *ahc)
 static int
 ahc_aha394XX_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 
 	pci = ahc->dev_softc;
-	switch (ahc_get_pci_slot(pci)) {
+	switch (aic_get_pci_slot(pci)) {
 	case AHC_394X_SLOT_CHANNEL_A:
 		ahc->channel = 'A';
 		break;
@@ -2419,7 +2439,7 @@ ahc_aha394XX_setup(struct ahc_softc *ahc
 	default:
 		printf("adapter at unexpected slot %d\n"
 		       "unable to map to a channel\n",
-		       ahc_get_pci_slot(pci));
+		       aic_get_pci_slot(pci));
 		ahc->channel = 'A';
 	}
 	return (0);
@@ -2428,10 +2448,10 @@ ahc_aha394XX_setup(struct ahc_softc *ahc
 static int
 ahc_aha398XX_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 
 	pci = ahc->dev_softc;
-	switch (ahc_get_pci_slot(pci)) {
+	switch (aic_get_pci_slot(pci)) {
 	case AHC_398X_SLOT_CHANNEL_A:
 		ahc->channel = 'A';
 		break;
@@ -2444,7 +2464,7 @@ ahc_aha398XX_setup(struct ahc_softc *ahc
 	default:
 		printf("adapter at unexpected slot %d\n"
 		       "unable to map to a channel\n",
-		       ahc_get_pci_slot(pci));
+		       aic_get_pci_slot(pci));
 		ahc->channel = 'A';
 		break;
 	}
@@ -2455,10 +2475,10 @@ ahc_aha398XX_setup(struct ahc_softc *ahc
 static int
 ahc_aha494XX_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
+	aic_dev_softc_t pci;
 
 	pci = ahc->dev_softc;
-	switch (ahc_get_pci_slot(pci)) {
+	switch (aic_get_pci_slot(pci)) {
 	case AHC_494X_SLOT_CHANNEL_A:
 		ahc->channel = 'A';
 		break;
@@ -2474,7 +2494,7 @@ ahc_aha494XX_setup(struct ahc_softc *ahc
 	default:
 		printf("adapter at unexpected slot %d\n"
 		       "unable to map to a channel\n",
-		       ahc_get_pci_slot(pci));
+		       aic_get_pci_slot(pci));
 		ahc->channel = 'A';
 	}
 	ahc->flags |= AHC_LARGE_SEEPROM;
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_proc.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_proc.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_proc.c	2004-04-04 05:36:14.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_proc.c	2004-05-13 16:42:17.000000000 +0200
@@ -37,7 +37,7 @@
  * String handling code courtesy of Gerard Roudier's <groudier@club-internet.fr>
  * sym driver.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#29 $
+ * $Id$
  */
 #include "aic7xxx_osm.h"
 #include "aic7xxx_inline.h"
@@ -50,7 +50,7 @@ static void	ahc_dump_target_state(struct
 				      u_int our_id, char channel,
 				      u_int target_id, u_int target_offset);
 static void	ahc_dump_device_state(struct info_str *info,
-				      struct ahc_linux_device *dev);
+				      struct aic_linux_device *dev);
 static int	ahc_proc_write_seeprom(struct ahc_softc *ahc,
 				       char *buffer, int length);
 
@@ -141,7 +141,7 @@ ahc_dump_target_state(struct ahc_softc *
 		      u_int our_id, char channel, u_int target_id,
 		      u_int target_offset)
 {
-	struct	ahc_linux_target *targ;
+	struct	aic_linux_target *targ;
 	struct	ahc_initiator_tinfo *tinfo;
 	struct	ahc_tmode_tstate *tstate;
 	int	lun;
@@ -163,7 +163,7 @@ ahc_dump_target_state(struct ahc_softc *
 	ahc_format_transinfo(info, &tinfo->curr);
 
 	for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
-		struct ahc_linux_device *dev;
+		struct aic_linux_device *dev;
 
 		dev = targ->devices[lun];
 
@@ -175,7 +175,7 @@ ahc_dump_target_state(struct ahc_softc *
 }
 
 static void
-ahc_dump_device_state(struct info_str *info, struct ahc_linux_device *dev)
+ahc_dump_device_state(struct info_str *info, struct aic_linux_device *dev)
 {
 	copy_info(info, "\tChannel %c Target %d Lun %d Settings\n",
 		  dev->target->channel + 'A', dev->target->target, dev->lun);
@@ -204,7 +204,8 @@ ahc_proc_write_seeprom(struct ahc_softc 
 		ahc_pause(ahc);
 
 	if (length != sizeof(struct seeprom_config)) {
-		printf("ahc_proc_write_seeprom: incorrect buffer size\n");
+		printf("ahc_proc_write_seeprom: incorrect buffer size %d\n",
+		       length);
 		goto done;
 	}
 
@@ -215,7 +216,7 @@ ahc_proc_write_seeprom(struct ahc_softc 
 	}
 
 	sd.sd_ahc = ahc;
-#if AHC_PCI_CONFIG > 0
+#if AIC_PCI_CONFIG > 0
 	if ((ahc->chip & AHC_PCI) != 0) {
 		sd.sd_control_offset = SEECTL;
 		sd.sd_status_offset = SEECTL;
@@ -271,7 +272,7 @@ ahc_proc_write_seeprom(struct ahc_softc 
 				  sizeof(struct seeprom_config)/2);
 		ahc_read_seeprom(&sd, (uint16_t *)ahc->seep_config,
 				 start_addr, sizeof(struct seeprom_config)/2);
-#if AHC_PCI_CONFIG > 0
+#if AIC_PCI_CONFIG > 0
 		if ((ahc->chip & AHC_VL) == 0)
 			ahc_release_seeprom(&sd);
 #endif
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped	2004-04-04 05:37:25.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped	2004-05-13 16:42:17.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#56 $
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#39 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#58 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#40 $
  */
 typedef int (ahc_reg_print_t)(u_int, u_int *, u_int);
 typedef struct ahc_reg_parse_entry {
@@ -1298,7 +1298,6 @@ ahc_reg_print_t ahc_sg_cache_pre_print;
 #define	CMDSIZE_TABLE_TAIL		0x34
 
 #define	MWI_RESIDUAL    		0x38
-#define	TARG_IMMEDIATE_SCB		0x38
 
 #define	NEXT_QUEUED_SCB 		0x39
 
@@ -1380,6 +1379,7 @@ ahc_reg_print_t ahc_sg_cache_pre_print;
 #define	RETURN_2        		0x52
 
 #define	LAST_MSG        		0x53
+#define	TARG_IMMEDIATE_SCB		0x53
 
 #define	SCSISEQ_TEMPLATE		0x54
 #define		ENSELO          	0x40
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_reg_print.c_shipped linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_reg_print.c_shipped
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_reg_print.c_shipped	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_reg_print.c_shipped	2004-05-13 16:42:17.000000000 +0200
@@ -2,8 +2,8 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#56 $
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#39 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#58 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#40 $
  */
 
 #include "aic7xxx_osm.h"
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped
--- linux-2.6.5/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped	2004-04-04 05:38:28.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped	2004-05-13 16:42:17.000000000 +0200
@@ -2,13 +2,13 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#56 $
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#39 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#58 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#40 $
  */
 static uint8_t seqprog[] = {
 	0xb2, 0x00, 0x00, 0x08,
 	0xf7, 0x11, 0x22, 0x08,
-	0x00, 0x65, 0xec, 0x59,
+	0x00, 0x65, 0xee, 0x59,
 	0xf7, 0x01, 0x02, 0x08,
 	0xff, 0x6a, 0x24, 0x08,
 	0x40, 0x00, 0x40, 0x68,
@@ -21,15 +21,15 @@ static uint8_t seqprog[] = {
 	0x01, 0x4d, 0xc8, 0x30,
 	0x00, 0x4c, 0x12, 0x70,
 	0x01, 0x39, 0xa2, 0x30,
-	0x00, 0x6a, 0xc0, 0x5e,
+	0x00, 0x6a, 0xc2, 0x5e,
 	0x01, 0x51, 0x20, 0x31,
 	0x01, 0x57, 0xae, 0x00,
 	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0x51, 0x12, 0x5e,
+	0x00, 0x51, 0x14, 0x5e,
 	0x01, 0x51, 0xc8, 0x30,
 	0x00, 0x39, 0xc8, 0x60,
 	0x00, 0xbb, 0x30, 0x70,
-	0xc1, 0x6a, 0xd8, 0x5e,
+	0xc1, 0x6a, 0xda, 0x5e,
 	0x01, 0xbf, 0x72, 0x30,
 	0x01, 0x40, 0x7e, 0x31,
 	0x01, 0x90, 0x80, 0x30,
@@ -49,10 +49,10 @@ static uint8_t seqprog[] = {
 	0x08, 0x6a, 0x78, 0x00,
 	0x01, 0x50, 0xc8, 0x30,
 	0xe0, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xfc, 0x5d,
+	0x48, 0x6a, 0xfe, 0x5d,
 	0x01, 0x6a, 0xdc, 0x01,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xfc, 0x5d,
+	0x48, 0x6a, 0xfe, 0x5d,
 	0x01, 0x6a, 0x26, 0x01,
 	0xf0, 0x19, 0x7a, 0x08,
 	0x0f, 0x18, 0xc8, 0x08,
@@ -93,7 +93,7 @@ static uint8_t seqprog[] = {
 	0x00, 0x65, 0x20, 0x41,
 	0x02, 0x57, 0xae, 0x00,
 	0x00, 0x65, 0x9e, 0x40,
-	0x61, 0x6a, 0xd8, 0x5e,
+	0x61, 0x6a, 0xda, 0x5e,
 	0x08, 0x51, 0x20, 0x71,
 	0x02, 0x0b, 0xb2, 0x78,
 	0x00, 0x65, 0xae, 0x40,
@@ -106,7 +106,7 @@ static uint8_t seqprog[] = {
 	0x80, 0x3d, 0x7a, 0x00,
 	0x20, 0x6a, 0x16, 0x00,
 	0x00, 0x65, 0xcc, 0x41,
-	0x00, 0x65, 0xb2, 0x5e,
+	0x00, 0x65, 0xb4, 0x5e,
 	0x00, 0x65, 0x12, 0x40,
 	0x20, 0x11, 0xd2, 0x68,
 	0x20, 0x6a, 0x18, 0x00,
@@ -140,27 +140,27 @@ static uint8_t seqprog[] = {
 	0x80, 0x0b, 0xc4, 0x79,
 	0x12, 0x01, 0x02, 0x00,
 	0x01, 0xab, 0xac, 0x30,
-	0xe4, 0x6a, 0x6e, 0x5d,
+	0xe4, 0x6a, 0x70, 0x5d,
 	0x40, 0x6a, 0x16, 0x00,
-	0x80, 0x3e, 0x84, 0x5d,
+	0x80, 0x3e, 0x86, 0x5d,
 	0x20, 0xb8, 0x18, 0x79,
-	0x20, 0x6a, 0x84, 0x5d,
-	0x00, 0xab, 0x84, 0x5d,
+	0x20, 0x6a, 0x86, 0x5d,
+	0x00, 0xab, 0x86, 0x5d,
 	0x01, 0xa9, 0x78, 0x30,
 	0x10, 0xb8, 0x20, 0x79,
-	0xe4, 0x6a, 0x6e, 0x5d,
+	0xe4, 0x6a, 0x70, 0x5d,
 	0x00, 0x65, 0xae, 0x40,
 	0x10, 0x03, 0x3c, 0x69,
 	0x08, 0x3c, 0x5a, 0x69,
 	0x04, 0x3c, 0x92, 0x69,
 	0x02, 0x3c, 0x98, 0x69,
 	0x01, 0x3c, 0x44, 0x79,
-	0xff, 0x6a, 0x70, 0x00,
+	0xff, 0x6a, 0xa6, 0x00,
 	0x00, 0x65, 0xa4, 0x59,
-	0x00, 0x6a, 0xc0, 0x5e,
-	0xff, 0x38, 0x30, 0x71,
+	0x00, 0x6a, 0xc2, 0x5e,
+	0xff, 0x53, 0x30, 0x71,
 	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0x38, 0x12, 0x5e,
+	0x00, 0x53, 0x14, 0x5e,
 	0x00, 0x65, 0xea, 0x58,
 	0x12, 0x01, 0x02, 0x00,
 	0x00, 0x65, 0x18, 0x41,
@@ -168,10 +168,10 @@ static uint8_t seqprog[] = {
 	0x00, 0x65, 0xf2, 0x58,
 	0xfd, 0x57, 0xae, 0x08,
 	0x00, 0x65, 0xae, 0x40,
-	0xe4, 0x6a, 0x6e, 0x5d,
+	0xe4, 0x6a, 0x70, 0x5d,
 	0x20, 0x3c, 0x4a, 0x79,
-	0x02, 0x6a, 0x84, 0x5d,
-	0x04, 0x6a, 0x84, 0x5d,
+	0x02, 0x6a, 0x86, 0x5d,
+	0x04, 0x6a, 0x86, 0x5d,
 	0x01, 0x03, 0x4c, 0x69,
 	0xf7, 0x11, 0x22, 0x08,
 	0xff, 0x6a, 0x24, 0x08,
@@ -182,13 +182,13 @@ static uint8_t seqprog[] = {
 	0x80, 0x86, 0xc8, 0x08,
 	0x01, 0x4f, 0xc8, 0x30,
 	0x00, 0x50, 0x6c, 0x61,
-	0xc4, 0x6a, 0x6e, 0x5d,
+	0xc4, 0x6a, 0x70, 0x5d,
 	0x40, 0x3c, 0x68, 0x79,
-	0x28, 0x6a, 0x84, 0x5d,
+	0x28, 0x6a, 0x86, 0x5d,
 	0x00, 0x65, 0x4c, 0x41,
-	0x08, 0x6a, 0x84, 0x5d,
+	0x08, 0x6a, 0x86, 0x5d,
 	0x00, 0x65, 0x4c, 0x41,
-	0x84, 0x6a, 0x6e, 0x5d,
+	0x84, 0x6a, 0x70, 0x5d,
 	0x00, 0x65, 0xf2, 0x58,
 	0x01, 0x66, 0xc8, 0x30,
 	0x01, 0x64, 0xd8, 0x31,
@@ -208,16 +208,16 @@ static uint8_t seqprog[] = {
 	0xf7, 0x3c, 0x78, 0x08,
 	0x00, 0x65, 0x20, 0x41,
 	0x40, 0xaa, 0x7e, 0x10,
-	0x04, 0xaa, 0x6e, 0x5d,
-	0x00, 0x65, 0x56, 0x42,
-	0xc4, 0x6a, 0x6e, 0x5d,
+	0x04, 0xaa, 0x70, 0x5d,
+	0x00, 0x65, 0x58, 0x42,
+	0xc4, 0x6a, 0x70, 0x5d,
 	0xc0, 0x6a, 0x7e, 0x00,
-	0x00, 0xa8, 0x84, 0x5d,
+	0x00, 0xa8, 0x86, 0x5d,
 	0xe4, 0x6a, 0x06, 0x00,
-	0x00, 0x6a, 0x84, 0x5d,
+	0x00, 0x6a, 0x86, 0x5d,
 	0x00, 0x65, 0x4c, 0x41,
 	0x10, 0x3c, 0xa8, 0x69,
-	0x00, 0xbb, 0x8a, 0x44,
+	0x00, 0xbb, 0x8c, 0x44,
 	0x18, 0x6a, 0xda, 0x01,
 	0x01, 0x69, 0xd8, 0x31,
 	0x1c, 0x6a, 0xd0, 0x01,
@@ -227,31 +227,32 @@ static uint8_t seqprog[] = {
 	0x01, 0x93, 0x26, 0x01,
 	0x03, 0x6a, 0x2a, 0x01,
 	0x01, 0x69, 0x32, 0x31,
-	0x1c, 0x6a, 0xe0, 0x5d,
+	0x1c, 0x6a, 0xe2, 0x5d,
 	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0xa8, 0x5e,
+	0x00, 0x65, 0xaa, 0x5e,
 	0x01, 0x50, 0xa0, 0x18,
 	0x02, 0x6a, 0x22, 0x05,
 	0x1a, 0x01, 0x02, 0x00,
 	0x80, 0x6a, 0x74, 0x00,
 	0x40, 0x6a, 0x78, 0x00,
 	0x40, 0x6a, 0x16, 0x00,
-	0x00, 0x65, 0xd8, 0x5d,
+	0x00, 0x65, 0xda, 0x5d,
 	0x01, 0x3f, 0xc8, 0x30,
-	0xbf, 0x64, 0x56, 0x7a,
-	0x80, 0x64, 0x9e, 0x73,
-	0xa0, 0x64, 0x00, 0x74,
-	0xc0, 0x64, 0xf4, 0x73,
-	0xe0, 0x64, 0x30, 0x74,
-	0x01, 0x6a, 0xd8, 0x5e,
+	0xbf, 0x64, 0x58, 0x7a,
+	0x80, 0x64, 0xa0, 0x73,
+	0xa0, 0x64, 0x02, 0x74,
+	0xc0, 0x64, 0xf6, 0x73,
+	0xe0, 0x64, 0x32, 0x74,
+	0x01, 0x6a, 0xda, 0x5e,
 	0x00, 0x65, 0xcc, 0x41,
 	0xf7, 0x11, 0x22, 0x08,
 	0x01, 0x06, 0xd4, 0x30,
 	0xff, 0x6a, 0x24, 0x08,
 	0xf7, 0x01, 0x02, 0x08,
-	0x09, 0x0c, 0xe6, 0x79,
+	0xc0, 0x6a, 0x78, 0x00,
+	0x09, 0x0c, 0xe8, 0x79,
 	0x08, 0x0c, 0x04, 0x68,
-	0xb1, 0x6a, 0xd8, 0x5e,
+	0xb1, 0x6a, 0xda, 0x5e,
 	0xff, 0x6a, 0x26, 0x09,
 	0x12, 0x01, 0x02, 0x00,
 	0x02, 0x6a, 0x08, 0x30,
@@ -264,29 +265,29 @@ static uint8_t seqprog[] = {
 	0x00, 0xa5, 0x4a, 0x21,
 	0x00, 0xa6, 0x4c, 0x21,
 	0x00, 0xa7, 0x4e, 0x25,
-	0x08, 0xeb, 0xdc, 0x7e,
-	0x80, 0xeb, 0x06, 0x7a,
+	0x08, 0xeb, 0xde, 0x7e,
+	0x80, 0xeb, 0x08, 0x7a,
 	0xff, 0x6a, 0xd6, 0x09,
-	0x08, 0xeb, 0x0a, 0x6a,
+	0x08, 0xeb, 0x0c, 0x6a,
 	0xff, 0x6a, 0xd4, 0x0c,
-	0x80, 0xa3, 0xdc, 0x6e,
-	0x88, 0xeb, 0x20, 0x72,
-	0x08, 0xeb, 0xdc, 0x6e,
-	0x04, 0xea, 0x24, 0xe2,
-	0x08, 0xee, 0xdc, 0x6e,
+	0x80, 0xa3, 0xde, 0x6e,
+	0x88, 0xeb, 0x22, 0x72,
+	0x08, 0xeb, 0xde, 0x6e,
+	0x04, 0xea, 0x26, 0xe2,
+	0x08, 0xee, 0xde, 0x6e,
 	0x04, 0x6a, 0xd0, 0x81,
 	0x05, 0xa4, 0xc0, 0x89,
 	0x03, 0xa5, 0xc2, 0x31,
 	0x09, 0x6a, 0xd6, 0x05,
-	0x00, 0x65, 0x08, 0x5a,
+	0x00, 0x65, 0x0a, 0x5a,
 	0x06, 0xa4, 0xd4, 0x89,
-	0x80, 0x94, 0xdc, 0x7e,
+	0x80, 0x94, 0xde, 0x7e,
 	0x07, 0xe9, 0x10, 0x31,
 	0x01, 0xe9, 0x46, 0x31,
-	0x00, 0xa3, 0xba, 0x5e,
-	0x00, 0x65, 0xfa, 0x59,
+	0x00, 0xa3, 0xbc, 0x5e,
+	0x00, 0x65, 0xfc, 0x59,
 	0x01, 0xa4, 0xca, 0x30,
-	0x80, 0xa3, 0x34, 0x7a,
+	0x80, 0xa3, 0x36, 0x7a,
 	0x02, 0x65, 0xca, 0x00,
 	0x01, 0x65, 0xf8, 0x31,
 	0x80, 0x93, 0x26, 0x01,
@@ -294,162 +295,162 @@ static uint8_t seqprog[] = {
 	0x01, 0x8c, 0xc8, 0x30,
 	0x00, 0x88, 0xc8, 0x18,
 	0x02, 0x64, 0xc8, 0x88,
-	0xff, 0x64, 0xdc, 0x7e,
-	0xff, 0x8d, 0x4a, 0x6a,
-	0xff, 0x8e, 0x4a, 0x6a,
+	0xff, 0x64, 0xde, 0x7e,
+	0xff, 0x8d, 0x4c, 0x6a,
+	0xff, 0x8e, 0x4c, 0x6a,
 	0x03, 0x8c, 0xd4, 0x98,
-	0x00, 0x65, 0xdc, 0x56,
+	0x00, 0x65, 0xde, 0x56,
 	0x01, 0x64, 0x70, 0x30,
 	0xff, 0x64, 0xc8, 0x10,
 	0x01, 0x64, 0xc8, 0x18,
 	0x00, 0x8c, 0x18, 0x19,
 	0xff, 0x8d, 0x1a, 0x21,
 	0xff, 0x8e, 0x1c, 0x25,
-	0xc0, 0x3c, 0x5a, 0x7a,
-	0x21, 0x6a, 0xd8, 0x5e,
+	0xc0, 0x3c, 0x5c, 0x7a,
+	0x21, 0x6a, 0xda, 0x5e,
 	0xa8, 0x6a, 0x76, 0x00,
 	0x79, 0x6a, 0x76, 0x00,
-	0x40, 0x3f, 0x62, 0x6a,
+	0x40, 0x3f, 0x64, 0x6a,
 	0x04, 0x3b, 0x76, 0x00,
 	0x04, 0x6a, 0xd4, 0x81,
-	0x20, 0x3c, 0x6a, 0x7a,
-	0x51, 0x6a, 0xd8, 0x5e,
-	0x00, 0x65, 0x82, 0x42,
+	0x20, 0x3c, 0x6c, 0x7a,
+	0x51, 0x6a, 0xda, 0x5e,
+	0x00, 0x65, 0x84, 0x42,
 	0x20, 0x3c, 0x78, 0x00,
-	0x00, 0xb3, 0xba, 0x5e,
+	0x00, 0xb3, 0xbc, 0x5e,
 	0x07, 0xac, 0x10, 0x31,
 	0x05, 0xb3, 0x46, 0x31,
 	0x88, 0x6a, 0xcc, 0x00,
-	0xac, 0x6a, 0xee, 0x5d,
+	0xac, 0x6a, 0xf0, 0x5d,
 	0xa3, 0x6a, 0xcc, 0x00,
-	0xb3, 0x6a, 0xf2, 0x5d,
-	0x00, 0x65, 0x3a, 0x5a,
+	0xb3, 0x6a, 0xf4, 0x5d,
+	0x00, 0x65, 0x3c, 0x5a,
 	0xfd, 0xa4, 0x48, 0x09,
 	0x03, 0x8c, 0x10, 0x30,
-	0x00, 0x65, 0xe6, 0x5d,
-	0x01, 0xa4, 0x94, 0x7a,
+	0x00, 0x65, 0xe8, 0x5d,
+	0x01, 0xa4, 0x96, 0x7a,
 	0x04, 0x3b, 0x76, 0x08,
 	0x01, 0x3b, 0x26, 0x31,
 	0x80, 0x02, 0x04, 0x00,
-	0x10, 0x0c, 0x8a, 0x7a,
-	0x03, 0x9e, 0x8c, 0x6a,
+	0x10, 0x0c, 0x8c, 0x7a,
+	0x03, 0x9e, 0x8e, 0x6a,
 	0x7f, 0x02, 0x04, 0x08,
-	0x91, 0x6a, 0xd8, 0x5e,
+	0x91, 0x6a, 0xda, 0x5e,
 	0x00, 0x65, 0xcc, 0x41,
 	0x01, 0xa4, 0xca, 0x30,
-	0x80, 0xa3, 0x9a, 0x7a,
+	0x80, 0xa3, 0x9c, 0x7a,
 	0x02, 0x65, 0xca, 0x00,
 	0x01, 0x65, 0xf8, 0x31,
 	0x01, 0x3b, 0x26, 0x31,
-	0x00, 0x65, 0x0e, 0x5a,
-	0x01, 0xfc, 0xa8, 0x6a,
-	0x80, 0x0b, 0x9e, 0x6a,
-	0x10, 0x0c, 0x9e, 0x7a,
-	0x20, 0x93, 0x9e, 0x6a,
+	0x00, 0x65, 0x10, 0x5a,
+	0x01, 0xfc, 0xaa, 0x6a,
+	0x80, 0x0b, 0xa0, 0x6a,
+	0x10, 0x0c, 0xa0, 0x7a,
+	0x20, 0x93, 0xa0, 0x6a,
 	0x02, 0x93, 0x26, 0x01,
-	0x02, 0xfc, 0xb2, 0x7a,
-	0x40, 0x0d, 0xc6, 0x6a,
+	0x02, 0xfc, 0xb4, 0x7a,
+	0x40, 0x0d, 0xc8, 0x6a,
 	0x01, 0xa4, 0x48, 0x01,
-	0x00, 0x65, 0xc6, 0x42,
-	0x40, 0x0d, 0xb8, 0x6a,
-	0x00, 0x65, 0x0e, 0x5a,
-	0x00, 0x65, 0xaa, 0x42,
-	0x80, 0xfc, 0xc2, 0x7a,
-	0x80, 0xa4, 0xc2, 0x6a,
+	0x00, 0x65, 0xc8, 0x42,
+	0x40, 0x0d, 0xba, 0x6a,
+	0x00, 0x65, 0x10, 0x5a,
+	0x00, 0x65, 0xac, 0x42,
+	0x80, 0xfc, 0xc4, 0x7a,
+	0x80, 0xa4, 0xc4, 0x6a,
 	0xff, 0xa5, 0x4a, 0x19,
 	0xff, 0xa6, 0x4c, 0x21,
 	0xff, 0xa7, 0x4e, 0x21,
 	0xf8, 0xfc, 0x48, 0x09,
 	0x7f, 0xa3, 0x46, 0x09,
-	0x04, 0x3b, 0xe2, 0x6a,
+	0x04, 0x3b, 0xe4, 0x6a,
 	0x02, 0x93, 0x26, 0x01,
-	0x01, 0x94, 0xc8, 0x7a,
-	0x01, 0x94, 0xc8, 0x7a,
-	0x01, 0x94, 0xc8, 0x7a,
-	0x01, 0x94, 0xc8, 0x7a,
-	0x01, 0x94, 0xc8, 0x7a,
-	0x01, 0xa4, 0xe0, 0x7a,
-	0x01, 0xfc, 0xd6, 0x7a,
-	0x01, 0x94, 0xe2, 0x6a,
-	0x01, 0x94, 0xe2, 0x6a,
-	0x01, 0x94, 0xe2, 0x6a,
-	0x00, 0x65, 0x82, 0x42,
-	0x01, 0x94, 0xe0, 0x7a,
-	0x10, 0x94, 0xe2, 0x6a,
+	0x01, 0x94, 0xca, 0x7a,
+	0x01, 0x94, 0xca, 0x7a,
+	0x01, 0x94, 0xca, 0x7a,
+	0x01, 0x94, 0xca, 0x7a,
+	0x01, 0x94, 0xca, 0x7a,
+	0x01, 0xa4, 0xe2, 0x7a,
+	0x01, 0xfc, 0xd8, 0x7a,
+	0x01, 0x94, 0xe4, 0x6a,
+	0x01, 0x94, 0xe4, 0x6a,
+	0x01, 0x94, 0xe4, 0x6a,
+	0x00, 0x65, 0x84, 0x42,
+	0x01, 0x94, 0xe2, 0x7a,
+	0x10, 0x94, 0xe4, 0x6a,
 	0xd7, 0x93, 0x26, 0x09,
-	0x28, 0x93, 0xe6, 0x6a,
+	0x28, 0x93, 0xe8, 0x6a,
 	0x01, 0x85, 0x0a, 0x01,
-	0x02, 0xfc, 0xee, 0x6a,
+	0x02, 0xfc, 0xf0, 0x6a,
 	0x01, 0x14, 0x46, 0x31,
 	0xff, 0x6a, 0x10, 0x09,
 	0xfe, 0x85, 0x0a, 0x09,
-	0xff, 0x38, 0xfc, 0x6a,
-	0x80, 0xa3, 0xfc, 0x7a,
-	0x80, 0x0b, 0xfa, 0x7a,
-	0x04, 0x3b, 0xfc, 0x7a,
+	0xff, 0x38, 0xfe, 0x6a,
+	0x80, 0xa3, 0xfe, 0x7a,
+	0x80, 0x0b, 0xfc, 0x7a,
+	0x04, 0x3b, 0xfe, 0x7a,
 	0xbf, 0x3b, 0x76, 0x08,
 	0x01, 0x3b, 0x26, 0x31,
-	0x00, 0x65, 0x0e, 0x5a,
-	0x01, 0x0b, 0x0a, 0x6b,
-	0x10, 0x0c, 0xfe, 0x7a,
-	0x04, 0x93, 0x08, 0x6b,
-	0x01, 0x94, 0x06, 0x7b,
-	0x10, 0x94, 0x08, 0x6b,
+	0x00, 0x65, 0x10, 0x5a,
+	0x01, 0x0b, 0x0c, 0x6b,
+	0x10, 0x0c, 0x00, 0x7b,
+	0x04, 0x93, 0x0a, 0x6b,
+	0x01, 0x94, 0x08, 0x7b,
+	0x10, 0x94, 0x0a, 0x6b,
 	0xc7, 0x93, 0x26, 0x09,
 	0x01, 0x99, 0xd4, 0x30,
-	0x38, 0x93, 0x0c, 0x6b,
-	0xff, 0x08, 0x5a, 0x6b,
-	0xff, 0x09, 0x5a, 0x6b,
-	0xff, 0x0a, 0x5a, 0x6b,
-	0xff, 0x38, 0x28, 0x7b,
+	0x38, 0x93, 0x0e, 0x6b,
+	0xff, 0x08, 0x5c, 0x6b,
+	0xff, 0x09, 0x5c, 0x6b,
+	0xff, 0x0a, 0x5c, 0x6b,
+	0xff, 0x38, 0x2a, 0x7b,
 	0x04, 0x14, 0x10, 0x31,
 	0x01, 0x38, 0x18, 0x31,
 	0x02, 0x6a, 0x1a, 0x31,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x14, 0x6a, 0xf4, 0x5d,
-	0x00, 0x38, 0xe0, 0x5d,
+	0x14, 0x6a, 0xf6, 0x5d,
+	0x00, 0x38, 0xe2, 0x5d,
 	0xff, 0x6a, 0x70, 0x08,
-	0x00, 0x65, 0x54, 0x43,
-	0x80, 0xa3, 0x2e, 0x7b,
+	0x00, 0x65, 0x56, 0x43,
+	0x80, 0xa3, 0x30, 0x7b,
 	0x01, 0xa4, 0x48, 0x01,
-	0x00, 0x65, 0x5a, 0x43,
-	0x08, 0xeb, 0x34, 0x7b,
-	0x00, 0x65, 0x0e, 0x5a,
-	0x08, 0xeb, 0x30, 0x6b,
+	0x00, 0x65, 0x5c, 0x43,
+	0x08, 0xeb, 0x36, 0x7b,
+	0x00, 0x65, 0x10, 0x5a,
+	0x08, 0xeb, 0x32, 0x6b,
 	0x07, 0xe9, 0x10, 0x31,
 	0x01, 0xe9, 0xca, 0x30,
 	0x01, 0x65, 0x46, 0x31,
-	0x00, 0x6a, 0xba, 0x5e,
+	0x00, 0x6a, 0xbc, 0x5e,
 	0x88, 0x6a, 0xcc, 0x00,
-	0xa4, 0x6a, 0xf4, 0x5d,
-	0x08, 0x6a, 0xe0, 0x5d,
+	0xa4, 0x6a, 0xf6, 0x5d,
+	0x08, 0x6a, 0xe2, 0x5d,
 	0x0d, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0xa8, 0x5e,
+	0x00, 0x65, 0xaa, 0x5e,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x00, 0x65, 0x8a, 0x5e,
+	0x00, 0x65, 0x8c, 0x5e,
 	0x01, 0x99, 0x46, 0x31,
-	0x00, 0xa3, 0xba, 0x5e,
+	0x00, 0xa3, 0xbc, 0x5e,
 	0x01, 0x88, 0x10, 0x31,
-	0x00, 0x65, 0x3a, 0x5a,
-	0x00, 0x65, 0xfa, 0x59,
+	0x00, 0x65, 0x3c, 0x5a,
+	0x00, 0x65, 0xfc, 0x59,
 	0x03, 0x8c, 0x10, 0x30,
-	0x00, 0x65, 0xe6, 0x5d,
-	0x80, 0x0b, 0x82, 0x6a,
-	0x80, 0x0b, 0x62, 0x6b,
-	0x01, 0x0c, 0x5c, 0x7b,
-	0x10, 0x0c, 0x82, 0x7a,
-	0x03, 0x9e, 0x82, 0x6a,
-	0x00, 0x65, 0x04, 0x5a,
-	0x00, 0x6a, 0xba, 0x5e,
-	0x01, 0xa4, 0x82, 0x6b,
-	0xff, 0x38, 0x78, 0x7b,
+	0x00, 0x65, 0xe8, 0x5d,
+	0x80, 0x0b, 0x84, 0x6a,
+	0x80, 0x0b, 0x64, 0x6b,
+	0x01, 0x0c, 0x5e, 0x7b,
+	0x10, 0x0c, 0x84, 0x7a,
+	0x03, 0x9e, 0x84, 0x6a,
+	0x00, 0x65, 0x06, 0x5a,
+	0x00, 0x6a, 0xbc, 0x5e,
+	0x01, 0xa4, 0x84, 0x6b,
+	0xff, 0x38, 0x7a, 0x7b,
 	0x01, 0x38, 0xc8, 0x30,
 	0x00, 0x08, 0x40, 0x19,
 	0xff, 0x6a, 0xc8, 0x08,
 	0x00, 0x09, 0x42, 0x21,
 	0x00, 0x0a, 0x44, 0x21,
 	0xff, 0x6a, 0x70, 0x08,
-	0x00, 0x65, 0x7a, 0x43,
+	0x00, 0x65, 0x7c, 0x43,
 	0x03, 0x08, 0x40, 0x31,
 	0x03, 0x08, 0x40, 0x31,
 	0x01, 0x08, 0x40, 0x31,
@@ -461,16 +462,16 @@ static uint8_t seqprog[] = {
 	0x04, 0x3c, 0xcc, 0x79,
 	0xfb, 0x3c, 0x78, 0x08,
 	0x04, 0x93, 0x20, 0x79,
-	0x01, 0x0c, 0x8e, 0x6b,
+	0x01, 0x0c, 0x90, 0x6b,
 	0x80, 0xba, 0x20, 0x79,
 	0x80, 0x04, 0x20, 0x79,
-	0xe4, 0x6a, 0x6e, 0x5d,
-	0x23, 0x6a, 0x84, 0x5d,
-	0x01, 0x6a, 0x84, 0x5d,
+	0xe4, 0x6a, 0x70, 0x5d,
+	0x23, 0x6a, 0x86, 0x5d,
+	0x01, 0x6a, 0x86, 0x5d,
 	0x00, 0x65, 0x20, 0x41,
 	0x00, 0x65, 0xcc, 0x41,
-	0x80, 0x3c, 0xa2, 0x7b,
-	0x21, 0x6a, 0xd8, 0x5e,
+	0x80, 0x3c, 0xa4, 0x7b,
+	0x21, 0x6a, 0xda, 0x5e,
 	0x01, 0xbc, 0x18, 0x31,
 	0x02, 0x6a, 0x1a, 0x31,
 	0x02, 0x6a, 0xf8, 0x01,
@@ -480,16 +481,16 @@ static uint8_t seqprog[] = {
 	0xff, 0x6a, 0x12, 0x08,
 	0xff, 0x6a, 0x14, 0x08,
 	0xf3, 0xbc, 0xd4, 0x18,
-	0xa0, 0x6a, 0xc8, 0x53,
+	0xa0, 0x6a, 0xca, 0x53,
 	0x04, 0xa0, 0x10, 0x31,
 	0xac, 0x6a, 0x26, 0x01,
 	0x04, 0xa0, 0x10, 0x31,
 	0x03, 0x08, 0x18, 0x31,
 	0x88, 0x6a, 0xcc, 0x00,
-	0xa0, 0x6a, 0xf4, 0x5d,
-	0x00, 0xbc, 0xe0, 0x5d,
+	0xa0, 0x6a, 0xf6, 0x5d,
+	0x00, 0xbc, 0xe2, 0x5d,
 	0x3d, 0x6a, 0x26, 0x01,
-	0x00, 0x65, 0xe0, 0x43,
+	0x00, 0x65, 0xe2, 0x43,
 	0xff, 0x6a, 0x10, 0x09,
 	0xa4, 0x6a, 0x26, 0x01,
 	0x0c, 0xa0, 0x32, 0x31,
@@ -499,128 +500,128 @@ static uint8_t seqprog[] = {
 	0x36, 0x6a, 0x26, 0x01,
 	0x02, 0x93, 0x26, 0x01,
 	0x35, 0x6a, 0x26, 0x01,
-	0x00, 0x65, 0x9c, 0x5e,
-	0x00, 0x65, 0x9c, 0x5e,
+	0x00, 0x65, 0x9e, 0x5e,
+	0x00, 0x65, 0x9e, 0x5e,
 	0x02, 0x93, 0x26, 0x01,
 	0xbf, 0x3c, 0x78, 0x08,
-	0x04, 0x0b, 0xe6, 0x6b,
-	0x10, 0x0c, 0xe2, 0x7b,
-	0x01, 0x03, 0xe6, 0x6b,
-	0x20, 0x93, 0xe8, 0x6b,
-	0x04, 0x0b, 0xee, 0x6b,
+	0x04, 0x0b, 0xe8, 0x6b,
+	0x10, 0x0c, 0xe4, 0x7b,
+	0x01, 0x03, 0xe8, 0x6b,
+	0x20, 0x93, 0xea, 0x6b,
+	0x04, 0x0b, 0xf0, 0x6b,
 	0x40, 0x3c, 0x78, 0x00,
 	0xc7, 0x93, 0x26, 0x09,
-	0x38, 0x93, 0xf0, 0x6b,
+	0x38, 0x93, 0xf2, 0x6b,
 	0x00, 0x65, 0xcc, 0x41,
-	0x80, 0x3c, 0x56, 0x6c,
+	0x80, 0x3c, 0x58, 0x6c,
 	0x01, 0x06, 0x50, 0x31,
 	0x80, 0xb8, 0x70, 0x01,
 	0x00, 0x65, 0xcc, 0x41,
 	0x10, 0x3f, 0x06, 0x00,
 	0x10, 0x6a, 0x06, 0x00,
 	0x01, 0x3a, 0xca, 0x30,
-	0x80, 0x65, 0x1c, 0x64,
-	0x10, 0xb8, 0x40, 0x6c,
+	0x80, 0x65, 0x1e, 0x64,
+	0x10, 0xb8, 0x42, 0x6c,
 	0xc0, 0x3e, 0xca, 0x00,
-	0x40, 0xb8, 0x0c, 0x6c,
+	0x40, 0xb8, 0x0e, 0x6c,
 	0xbf, 0x65, 0xca, 0x08,
-	0x20, 0xb8, 0x20, 0x7c,
+	0x20, 0xb8, 0x22, 0x7c,
 	0x01, 0x65, 0x0c, 0x30,
-	0x00, 0x65, 0xd8, 0x5d,
-	0xa0, 0x3f, 0x28, 0x64,
+	0x00, 0x65, 0xda, 0x5d,
+	0xa0, 0x3f, 0x2a, 0x64,
 	0x23, 0xb8, 0x0c, 0x08,
-	0x00, 0x65, 0xd8, 0x5d,
-	0xa0, 0x3f, 0x28, 0x64,
-	0x00, 0xbb, 0x20, 0x44,
-	0xff, 0x65, 0x20, 0x64,
-	0x00, 0x65, 0x40, 0x44,
+	0x00, 0x65, 0xda, 0x5d,
+	0xa0, 0x3f, 0x2a, 0x64,
+	0x00, 0xbb, 0x22, 0x44,
+	0xff, 0x65, 0x22, 0x64,
+	0x00, 0x65, 0x42, 0x44,
 	0x40, 0x6a, 0x18, 0x00,
 	0x01, 0x65, 0x0c, 0x30,
-	0x00, 0x65, 0xd8, 0x5d,
-	0xa0, 0x3f, 0xfc, 0x73,
+	0x00, 0x65, 0xda, 0x5d,
+	0xa0, 0x3f, 0xfe, 0x73,
 	0x40, 0x6a, 0x18, 0x00,
 	0x01, 0x3a, 0xa6, 0x30,
 	0x08, 0x6a, 0x74, 0x00,
 	0x00, 0x65, 0xcc, 0x41,
-	0x64, 0x6a, 0x68, 0x5d,
-	0x80, 0x64, 0xd8, 0x6c,
-	0x04, 0x64, 0x9a, 0x74,
-	0x02, 0x64, 0xaa, 0x74,
-	0x00, 0x6a, 0x60, 0x74,
-	0x03, 0x64, 0xc8, 0x74,
-	0x23, 0x64, 0x48, 0x74,
-	0x08, 0x64, 0x5c, 0x74,
-	0x61, 0x6a, 0xd8, 0x5e,
-	0x00, 0x65, 0xd8, 0x5d,
+	0x64, 0x6a, 0x6a, 0x5d,
+	0x80, 0x64, 0xda, 0x6c,
+	0x04, 0x64, 0x9c, 0x74,
+	0x02, 0x64, 0xac, 0x74,
+	0x00, 0x6a, 0x62, 0x74,
+	0x03, 0x64, 0xca, 0x74,
+	0x23, 0x64, 0x4a, 0x74,
+	0x08, 0x64, 0x5e, 0x74,
+	0x61, 0x6a, 0xda, 0x5e,
+	0x00, 0x65, 0xda, 0x5d,
 	0x08, 0x51, 0xce, 0x71,
-	0x00, 0x65, 0x40, 0x44,
-	0x80, 0x04, 0x5a, 0x7c,
-	0x51, 0x6a, 0x5e, 0x5d,
-	0x01, 0x51, 0x5a, 0x64,
-	0x01, 0xa4, 0x52, 0x7c,
-	0x80, 0xba, 0x5c, 0x6c,
-	0x41, 0x6a, 0xd8, 0x5e,
-	0x00, 0x65, 0x5c, 0x44,
-	0x21, 0x6a, 0xd8, 0x5e,
-	0x00, 0x65, 0x5c, 0x44,
-	0x07, 0x6a, 0x54, 0x5d,
+	0x00, 0x65, 0x42, 0x44,
+	0x80, 0x04, 0x5c, 0x7c,
+	0x51, 0x6a, 0x60, 0x5d,
+	0x01, 0x51, 0x5c, 0x64,
+	0x01, 0xa4, 0x54, 0x7c,
+	0x80, 0xba, 0x5e, 0x6c,
+	0x41, 0x6a, 0xda, 0x5e,
+	0x00, 0x65, 0x5e, 0x44,
+	0x21, 0x6a, 0xda, 0x5e,
+	0x00, 0x65, 0x5e, 0x44,
+	0x07, 0x6a, 0x56, 0x5d,
 	0x01, 0x06, 0xd4, 0x30,
 	0x00, 0x65, 0xcc, 0x41,
-	0x80, 0xb8, 0x56, 0x7c,
-	0xc0, 0x3c, 0x6a, 0x7c,
-	0x80, 0x3c, 0x56, 0x6c,
-	0xff, 0xa8, 0x6a, 0x6c,
-	0x40, 0x3c, 0x56, 0x6c,
-	0x10, 0xb8, 0x6e, 0x7c,
-	0xa1, 0x6a, 0xd8, 0x5e,
-	0x01, 0xb4, 0x74, 0x6c,
-	0x02, 0xb4, 0x76, 0x6c,
-	0x01, 0xa4, 0x76, 0x7c,
-	0xff, 0xa8, 0x86, 0x7c,
+	0x80, 0xb8, 0x58, 0x7c,
+	0xc0, 0x3c, 0x6c, 0x7c,
+	0x80, 0x3c, 0x58, 0x6c,
+	0xff, 0xa8, 0x6c, 0x6c,
+	0x40, 0x3c, 0x58, 0x6c,
+	0x10, 0xb8, 0x70, 0x7c,
+	0xa1, 0x6a, 0xda, 0x5e,
+	0x01, 0xb4, 0x76, 0x6c,
+	0x02, 0xb4, 0x78, 0x6c,
+	0x01, 0xa4, 0x78, 0x7c,
+	0xff, 0xa8, 0x88, 0x7c,
 	0x04, 0xb4, 0x68, 0x01,
 	0x01, 0x6a, 0x76, 0x00,
-	0x00, 0xbb, 0x12, 0x5e,
-	0xff, 0xa8, 0x86, 0x7c,
-	0x71, 0x6a, 0xd8, 0x5e,
-	0x40, 0x51, 0x86, 0x64,
-	0x00, 0x65, 0xb2, 0x5e,
+	0x00, 0xbb, 0x14, 0x5e,
+	0xff, 0xa8, 0x88, 0x7c,
+	0x71, 0x6a, 0xda, 0x5e,
+	0x40, 0x51, 0x88, 0x64,
+	0x00, 0x65, 0xb4, 0x5e,
 	0x00, 0x65, 0xde, 0x41,
-	0x00, 0xbb, 0x8a, 0x5c,
+	0x00, 0xbb, 0x8c, 0x5c,
 	0x00, 0x65, 0xde, 0x41,
-	0x00, 0x65, 0xb2, 0x5e,
+	0x00, 0x65, 0xb4, 0x5e,
 	0x01, 0x65, 0xa2, 0x30,
 	0x01, 0xf8, 0xc8, 0x30,
 	0x01, 0x4e, 0xc8, 0x30,
-	0x00, 0x6a, 0xb6, 0xdd,
-	0x00, 0x51, 0xc8, 0x5d,
+	0x00, 0x6a, 0xb8, 0xdd,
+	0x00, 0x51, 0xca, 0x5d,
 	0x01, 0x4e, 0x9c, 0x18,
 	0x02, 0x6a, 0x22, 0x05,
-	0xc0, 0x3c, 0x56, 0x6c,
+	0xc0, 0x3c, 0x58, 0x6c,
 	0x04, 0xb8, 0x70, 0x01,
-	0x00, 0x65, 0xd4, 0x5e,
+	0x00, 0x65, 0xd6, 0x5e,
 	0x20, 0xb8, 0xde, 0x69,
 	0x01, 0xbb, 0xa2, 0x30,
 	0x3f, 0xba, 0x7c, 0x08,
-	0x00, 0xb9, 0xce, 0x5c,
+	0x00, 0xb9, 0xd0, 0x5c,
 	0x00, 0x65, 0xde, 0x41,
 	0x01, 0x06, 0xd4, 0x30,
 	0x20, 0x3c, 0xcc, 0x79,
-	0x20, 0x3c, 0x5c, 0x7c,
-	0x01, 0xa4, 0xb8, 0x7c,
+	0x20, 0x3c, 0x5e, 0x7c,
+	0x01, 0xa4, 0xba, 0x7c,
 	0x01, 0xb4, 0x68, 0x01,
 	0x00, 0x65, 0xcc, 0x41,
-	0x00, 0x65, 0x5c, 0x44,
+	0x00, 0x65, 0x5e, 0x44,
 	0x04, 0x14, 0x58, 0x31,
 	0x01, 0x06, 0xd4, 0x30,
 	0x08, 0xa0, 0x60, 0x31,
 	0xac, 0x6a, 0xcc, 0x00,
-	0x14, 0x6a, 0xf4, 0x5d,
+	0x14, 0x6a, 0xf6, 0x5d,
 	0x01, 0x06, 0xd4, 0x30,
-	0xa0, 0x6a, 0xec, 0x5d,
+	0xa0, 0x6a, 0xee, 0x5d,
 	0x00, 0x65, 0xcc, 0x41,
 	0xdf, 0x3c, 0x78, 0x08,
 	0x12, 0x01, 0x02, 0x00,
-	0x00, 0x65, 0x5c, 0x44,
+	0x00, 0x65, 0x5e, 0x44,
 	0x4c, 0x65, 0xcc, 0x28,
 	0x01, 0x3e, 0x20, 0x31,
 	0xd0, 0x66, 0xcc, 0x18,
@@ -631,102 +632,102 @@ static uint8_t seqprog[] = {
 	0xd0, 0x65, 0xca, 0x18,
 	0x01, 0x3e, 0x20, 0x31,
 	0x30, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xe6, 0x4c,
+	0x00, 0x65, 0xe8, 0x4c,
 	0xe1, 0x6a, 0x22, 0x01,
 	0xff, 0x6a, 0xd4, 0x08,
 	0x20, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xee, 0x54,
+	0x00, 0x65, 0xf0, 0x54,
 	0xe1, 0x6a, 0x22, 0x01,
 	0xff, 0x6a, 0xd4, 0x08,
 	0x20, 0x65, 0xca, 0x18,
 	0xe0, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xf8, 0x4c,
+	0x00, 0x65, 0xfa, 0x4c,
 	0xe1, 0x6a, 0x22, 0x01,
 	0xff, 0x6a, 0xd4, 0x08,
 	0xd0, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0x00, 0x55,
+	0x00, 0x65, 0x02, 0x55,
 	0xe1, 0x6a, 0x22, 0x01,
 	0xff, 0x6a, 0xd4, 0x08,
 	0x01, 0x6c, 0xa2, 0x30,
-	0xff, 0x51, 0x12, 0x75,
-	0x00, 0x51, 0x8e, 0x5d,
+	0xff, 0x51, 0x14, 0x75,
+	0x00, 0x51, 0x90, 0x5d,
 	0x01, 0x51, 0x20, 0x31,
-	0x00, 0x65, 0x34, 0x45,
+	0x00, 0x65, 0x36, 0x45,
 	0x3f, 0xba, 0xc8, 0x08,
-	0x00, 0x3e, 0x34, 0x75,
-	0x00, 0x65, 0xb0, 0x5e,
+	0x00, 0x3e, 0x36, 0x75,
+	0x00, 0x65, 0xb2, 0x5e,
 	0x80, 0x3c, 0x78, 0x00,
 	0x01, 0x06, 0xd4, 0x30,
-	0x00, 0x65, 0xd8, 0x5d,
+	0x00, 0x65, 0xda, 0x5d,
 	0x01, 0x3c, 0x78, 0x00,
-	0xe0, 0x3f, 0x50, 0x65,
+	0xe0, 0x3f, 0x52, 0x65,
 	0x02, 0x3c, 0x78, 0x00,
-	0x20, 0x12, 0x50, 0x65,
-	0x51, 0x6a, 0x5e, 0x5d,
-	0x00, 0x51, 0x8e, 0x5d,
-	0x51, 0x6a, 0x5e, 0x5d,
+	0x20, 0x12, 0x52, 0x65,
+	0x51, 0x6a, 0x60, 0x5d,
+	0x00, 0x51, 0x90, 0x5d,
+	0x51, 0x6a, 0x60, 0x5d,
 	0x01, 0x51, 0x20, 0x31,
 	0x04, 0x3c, 0x78, 0x00,
 	0x01, 0xb9, 0xc8, 0x30,
-	0x00, 0x3d, 0x4e, 0x65,
+	0x00, 0x3d, 0x50, 0x65,
 	0x08, 0x3c, 0x78, 0x00,
 	0x3f, 0xba, 0xc8, 0x08,
-	0x00, 0x3e, 0x4e, 0x65,
+	0x00, 0x3e, 0x50, 0x65,
 	0x10, 0x3c, 0x78, 0x00,
-	0x04, 0xb8, 0x4e, 0x7d,
+	0x04, 0xb8, 0x50, 0x7d,
 	0xfb, 0xb8, 0x70, 0x09,
-	0x20, 0xb8, 0x44, 0x6d,
+	0x20, 0xb8, 0x46, 0x6d,
 	0x01, 0x90, 0xc8, 0x30,
 	0xff, 0x6a, 0xa2, 0x00,
-	0x00, 0x3d, 0xce, 0x5c,
+	0x00, 0x3d, 0xd0, 0x5c,
 	0x01, 0x64, 0x20, 0x31,
 	0xff, 0x6a, 0x78, 0x08,
 	0x00, 0x65, 0xea, 0x58,
-	0x10, 0xb8, 0x5c, 0x7c,
-	0xff, 0x6a, 0x54, 0x5d,
-	0x00, 0x65, 0x5c, 0x44,
-	0x00, 0x65, 0xb0, 0x5e,
-	0x31, 0x6a, 0xd8, 0x5e,
-	0x00, 0x65, 0x5c, 0x44,
+	0x10, 0xb8, 0x5e, 0x7c,
+	0xff, 0x6a, 0x56, 0x5d,
+	0x00, 0x65, 0x5e, 0x44,
+	0x00, 0x65, 0xb2, 0x5e,
+	0x31, 0x6a, 0xda, 0x5e,
+	0x00, 0x65, 0x5e, 0x44,
 	0x10, 0x3f, 0x06, 0x00,
 	0x10, 0x6a, 0x06, 0x00,
 	0x01, 0x65, 0x74, 0x34,
-	0x81, 0x6a, 0xd8, 0x5e,
-	0x00, 0x65, 0x60, 0x45,
+	0x81, 0x6a, 0xda, 0x5e,
+	0x00, 0x65, 0x62, 0x45,
 	0x01, 0x06, 0xd4, 0x30,
-	0x01, 0x0c, 0x60, 0x7d,
-	0x04, 0x0c, 0x5a, 0x6d,
+	0x01, 0x0c, 0x62, 0x7d,
+	0x04, 0x0c, 0x5c, 0x6d,
 	0xe0, 0x03, 0x7e, 0x08,
 	0xe0, 0x3f, 0xcc, 0x61,
 	0x01, 0x65, 0xcc, 0x30,
 	0x01, 0x12, 0xda, 0x34,
 	0x01, 0x06, 0xd4, 0x34,
-	0x01, 0x03, 0x6e, 0x6d,
+	0x01, 0x03, 0x70, 0x6d,
 	0x40, 0x03, 0xcc, 0x08,
 	0x01, 0x65, 0x06, 0x30,
 	0x40, 0x65, 0xc8, 0x08,
-	0x00, 0x66, 0x7c, 0x75,
-	0x40, 0x65, 0x7c, 0x7d,
-	0x00, 0x65, 0x7c, 0x5d,
+	0x00, 0x66, 0x7e, 0x75,
+	0x40, 0x65, 0x7e, 0x7d,
+	0x00, 0x65, 0x7e, 0x5d,
 	0xff, 0x6a, 0xd4, 0x08,
 	0xff, 0x6a, 0xd4, 0x08,
 	0xff, 0x6a, 0xd4, 0x08,
 	0xff, 0x6a, 0xd4, 0x0c,
 	0x08, 0x01, 0x02, 0x00,
-	0x02, 0x0b, 0x86, 0x7d,
+	0x02, 0x0b, 0x88, 0x7d,
 	0x01, 0x65, 0x0c, 0x30,
-	0x02, 0x0b, 0x8a, 0x7d,
+	0x02, 0x0b, 0x8c, 0x7d,
 	0xf7, 0x01, 0x02, 0x0c,
 	0x01, 0x65, 0xc8, 0x30,
-	0xff, 0x41, 0xae, 0x75,
+	0xff, 0x41, 0xb0, 0x75,
 	0x01, 0x41, 0x20, 0x31,
 	0xff, 0x6a, 0xa4, 0x00,
-	0x00, 0x65, 0x9e, 0x45,
-	0xff, 0xbf, 0xae, 0x75,
+	0x00, 0x65, 0xa0, 0x45,
+	0xff, 0xbf, 0xb0, 0x75,
 	0x01, 0x90, 0xa4, 0x30,
 	0x01, 0xbf, 0x20, 0x31,
-	0x00, 0xbb, 0x98, 0x65,
-	0xff, 0x52, 0xac, 0x75,
+	0x00, 0xbb, 0x9a, 0x65,
+	0xff, 0x52, 0xae, 0x75,
 	0x01, 0xbf, 0xcc, 0x30,
 	0x01, 0x90, 0xca, 0x30,
 	0x01, 0x52, 0x20, 0x31,
@@ -734,28 +735,28 @@ static uint8_t seqprog[] = {
 	0x01, 0x65, 0x20, 0x35,
 	0x01, 0xbf, 0x82, 0x34,
 	0x01, 0x64, 0xa2, 0x30,
-	0x00, 0x6a, 0xc0, 0x5e,
+	0x00, 0x6a, 0xc2, 0x5e,
 	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0x51, 0x12, 0x46,
+	0x00, 0x51, 0x14, 0x46,
 	0x01, 0x65, 0xa4, 0x30,
 	0xe0, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0x06, 0x5e,
+	0x48, 0x6a, 0x08, 0x5e,
 	0x01, 0x6a, 0xd0, 0x01,
 	0x01, 0x6a, 0xdc, 0x05,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0x06, 0x5e,
-	0x01, 0x6a, 0xe0, 0x5d,
+	0x48, 0x6a, 0x08, 0x5e,
+	0x01, 0x6a, 0xe2, 0x5d,
 	0x01, 0x6a, 0x26, 0x05,
 	0x01, 0x65, 0xd8, 0x31,
 	0x09, 0xee, 0xdc, 0x01,
-	0x80, 0xee, 0xcc, 0x7d,
+	0x80, 0xee, 0xce, 0x7d,
 	0xff, 0x6a, 0xdc, 0x0d,
 	0x01, 0x65, 0x32, 0x31,
 	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0xa8, 0x46,
-	0x81, 0x6a, 0xd8, 0x5e,
-	0x01, 0x0c, 0xd8, 0x7d,
-	0x04, 0x0c, 0xd6, 0x6d,
+	0x00, 0x65, 0xaa, 0x46,
+	0x81, 0x6a, 0xda, 0x5e,
+	0x01, 0x0c, 0xda, 0x7d,
+	0x04, 0x0c, 0xd8, 0x6d,
 	0xe0, 0x03, 0x06, 0x08,
 	0xe0, 0x03, 0x7e, 0x0c,
 	0x01, 0x65, 0x18, 0x31,
@@ -774,7 +775,7 @@ static uint8_t seqprog[] = {
 	0x01, 0x6c, 0xda, 0x34,
 	0x3d, 0x64, 0xa4, 0x28,
 	0x55, 0x64, 0xc8, 0x28,
-	0x00, 0x65, 0x06, 0x46,
+	0x00, 0x65, 0x08, 0x46,
 	0x2e, 0x64, 0xa4, 0x28,
 	0x66, 0x64, 0xc8, 0x28,
 	0x00, 0x6c, 0xda, 0x18,
@@ -785,63 +786,63 @@ static uint8_t seqprog[] = {
 	0x00, 0x6c, 0xda, 0x24,
 	0x01, 0x65, 0xc8, 0x30,
 	0xe0, 0x6a, 0xcc, 0x00,
-	0x44, 0x6a, 0x02, 0x5e,
+	0x44, 0x6a, 0x04, 0x5e,
 	0x01, 0x90, 0xe2, 0x31,
-	0x04, 0x3b, 0x26, 0x7e,
+	0x04, 0x3b, 0x28, 0x7e,
 	0x30, 0x6a, 0xd0, 0x01,
 	0x20, 0x6a, 0xd0, 0x01,
 	0x1d, 0x6a, 0xdc, 0x01,
-	0xdc, 0xee, 0x22, 0x66,
-	0x00, 0x65, 0x3e, 0x46,
+	0xdc, 0xee, 0x24, 0x66,
+	0x00, 0x65, 0x40, 0x46,
 	0x20, 0x6a, 0xd0, 0x01,
 	0x01, 0x6a, 0xdc, 0x01,
 	0x20, 0xa0, 0xd8, 0x31,
 	0x09, 0xee, 0xdc, 0x01,
-	0x80, 0xee, 0x2e, 0x7e,
+	0x80, 0xee, 0x30, 0x7e,
 	0x11, 0x6a, 0xdc, 0x01,
-	0x50, 0xee, 0x32, 0x66,
+	0x50, 0xee, 0x34, 0x66,
 	0x20, 0x6a, 0xd0, 0x01,
 	0x09, 0x6a, 0xdc, 0x01,
-	0x88, 0xee, 0x38, 0x66,
+	0x88, 0xee, 0x3a, 0x66,
 	0x19, 0x6a, 0xdc, 0x01,
-	0xd8, 0xee, 0x3c, 0x66,
+	0xd8, 0xee, 0x3e, 0x66,
 	0xff, 0x6a, 0xdc, 0x09,
-	0x18, 0xee, 0x40, 0x6e,
+	0x18, 0xee, 0x42, 0x6e,
 	0xff, 0x6a, 0xd4, 0x0c,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x44, 0x6a, 0x02, 0x5e,
-	0x20, 0x6a, 0xe0, 0x5d,
+	0x44, 0x6a, 0x04, 0x5e,
+	0x20, 0x6a, 0xe2, 0x5d,
 	0x01, 0x3b, 0x26, 0x31,
-	0x04, 0x3b, 0x5a, 0x6e,
+	0x04, 0x3b, 0x5c, 0x6e,
 	0xa0, 0x6a, 0xca, 0x00,
 	0x20, 0x65, 0xc8, 0x18,
-	0x00, 0x65, 0x98, 0x5e,
-	0x00, 0x65, 0x52, 0x66,
+	0x00, 0x65, 0x9a, 0x5e,
+	0x00, 0x65, 0x54, 0x66,
 	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0xa8, 0x46,
+	0x00, 0x65, 0xaa, 0x46,
 	0xa0, 0x6a, 0xcc, 0x00,
 	0xff, 0x6a, 0xc8, 0x08,
-	0x20, 0x94, 0x5e, 0x6e,
-	0x10, 0x94, 0x60, 0x6e,
-	0x08, 0x94, 0x7a, 0x6e,
-	0x08, 0x94, 0x7a, 0x6e,
-	0x08, 0x94, 0x7a, 0x6e,
+	0x20, 0x94, 0x60, 0x6e,
+	0x10, 0x94, 0x62, 0x6e,
+	0x08, 0x94, 0x7c, 0x6e,
+	0x08, 0x94, 0x7c, 0x6e,
+	0x08, 0x94, 0x7c, 0x6e,
 	0xff, 0x8c, 0xc8, 0x10,
 	0xc1, 0x64, 0xc8, 0x18,
 	0xf8, 0x64, 0xc8, 0x08,
 	0x01, 0x99, 0xda, 0x30,
-	0x00, 0x66, 0x6e, 0x66,
-	0xc0, 0x66, 0xaa, 0x76,
+	0x00, 0x66, 0x70, 0x66,
+	0xc0, 0x66, 0xac, 0x76,
 	0x60, 0x66, 0xc8, 0x18,
 	0x3d, 0x64, 0xc8, 0x28,
-	0x00, 0x65, 0x5e, 0x46,
+	0x00, 0x65, 0x60, 0x46,
 	0xf7, 0x93, 0x26, 0x09,
-	0x08, 0x93, 0x7c, 0x6e,
+	0x08, 0x93, 0x7e, 0x6e,
 	0x00, 0x62, 0xc4, 0x18,
-	0x00, 0x65, 0xa8, 0x5e,
-	0x00, 0x65, 0x88, 0x5e,
-	0x00, 0x65, 0x88, 0x5e,
-	0x00, 0x65, 0x88, 0x5e,
+	0x00, 0x65, 0xaa, 0x5e,
+	0x00, 0x65, 0x8a, 0x5e,
+	0x00, 0x65, 0x8a, 0x5e,
+	0x00, 0x65, 0x8a, 0x5e,
 	0x01, 0x99, 0xda, 0x30,
 	0x01, 0x99, 0xda, 0x30,
 	0x01, 0x99, 0xda, 0x30,
@@ -858,11 +859,11 @@ static uint8_t seqprog[] = {
 	0x01, 0x6c, 0x32, 0x31,
 	0x01, 0x6c, 0x32, 0x31,
 	0x01, 0x6c, 0x32, 0x35,
-	0x08, 0x94, 0xa8, 0x7e,
+	0x08, 0x94, 0xaa, 0x7e,
 	0xf7, 0x93, 0x26, 0x09,
-	0x08, 0x93, 0xac, 0x6e,
+	0x08, 0x93, 0xae, 0x6e,
 	0xff, 0x6a, 0xd4, 0x0c,
-	0x04, 0xb8, 0xd4, 0x6e,
+	0x04, 0xb8, 0xd6, 0x6e,
 	0x01, 0x42, 0x7e, 0x31,
 	0xff, 0x6a, 0x76, 0x01,
 	0x01, 0x90, 0x84, 0x34,
@@ -870,14 +871,14 @@ static uint8_t seqprog[] = {
 	0x01, 0x85, 0x0a, 0x01,
 	0x7f, 0x65, 0x10, 0x09,
 	0xfe, 0x85, 0x0a, 0x0d,
-	0xff, 0x42, 0xd0, 0x66,
-	0xff, 0x41, 0xc8, 0x66,
-	0xd1, 0x6a, 0xd8, 0x5e,
+	0xff, 0x42, 0xd2, 0x66,
+	0xff, 0x41, 0xca, 0x66,
+	0xd1, 0x6a, 0xda, 0x5e,
 	0xff, 0x6a, 0xca, 0x04,
 	0x01, 0x41, 0x20, 0x31,
 	0x01, 0xbf, 0x82, 0x30,
 	0x01, 0x6a, 0x76, 0x00,
-	0x00, 0xbb, 0x12, 0x46,
+	0x00, 0xbb, 0x14, 0x46,
 	0x01, 0x42, 0x20, 0x31,
 	0x01, 0xbf, 0x84, 0x34,
 	0x01, 0x41, 0x7e, 0x31,
@@ -941,7 +942,7 @@ static ahc_patch_func_t ahc_patch17_func
 static int
 ahc_patch17_func(struct ahc_softc *ahc)
 {
-	return ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0);
+	return ((ahc->bugs & AHC_TMODE_WIDEODD_BUG) != 0);
 }
 
 static ahc_patch_func_t ahc_patch16_func;
@@ -1142,152 +1143,152 @@ static struct patch {
 	{ ahc_patch0_func, 196, 1, 1 },
 	{ ahc_patch9_func, 212, 6, 2 },
 	{ ahc_patch0_func, 218, 6, 1 },
-	{ ahc_patch8_func, 226, 20, 2 },
+	{ ahc_patch8_func, 226, 21, 2 },
 	{ ahc_patch1_func, 241, 1, 1 },
-	{ ahc_patch1_func, 248, 1, 2 },
-	{ ahc_patch0_func, 249, 2, 2 },
-	{ ahc_patch11_func, 250, 1, 1 },
-	{ ahc_patch9_func, 258, 27, 3 },
-	{ ahc_patch1_func, 274, 10, 2 },
-	{ ahc_patch13_func, 277, 1, 1 },
-	{ ahc_patch14_func, 285, 14, 1 },
-	{ ahc_patch1_func, 301, 1, 2 },
-	{ ahc_patch0_func, 302, 1, 1 },
-	{ ahc_patch9_func, 305, 1, 1 },
-	{ ahc_patch13_func, 310, 1, 1 },
-	{ ahc_patch9_func, 311, 2, 2 },
-	{ ahc_patch0_func, 313, 4, 1 },
-	{ ahc_patch14_func, 317, 1, 1 },
-	{ ahc_patch15_func, 319, 2, 3 },
-	{ ahc_patch9_func, 319, 1, 2 },
-	{ ahc_patch0_func, 320, 1, 1 },
-	{ ahc_patch6_func, 325, 1, 2 },
-	{ ahc_patch0_func, 326, 1, 1 },
-	{ ahc_patch1_func, 330, 47, 11 },
-	{ ahc_patch6_func, 337, 2, 4 },
-	{ ahc_patch7_func, 337, 1, 1 },
-	{ ahc_patch8_func, 338, 1, 1 },
-	{ ahc_patch0_func, 339, 1, 1 },
-	{ ahc_patch16_func, 340, 1, 1 },
-	{ ahc_patch6_func, 356, 6, 3 },
-	{ ahc_patch16_func, 356, 5, 1 },
-	{ ahc_patch0_func, 362, 7, 1 },
-	{ ahc_patch13_func, 372, 5, 1 },
-	{ ahc_patch0_func, 377, 52, 17 },
-	{ ahc_patch14_func, 377, 1, 1 },
-	{ ahc_patch7_func, 379, 2, 2 },
-	{ ahc_patch17_func, 380, 1, 1 },
-	{ ahc_patch9_func, 383, 1, 1 },
-	{ ahc_patch18_func, 390, 1, 1 },
-	{ ahc_patch14_func, 395, 9, 3 },
-	{ ahc_patch9_func, 396, 3, 2 },
-	{ ahc_patch0_func, 399, 3, 1 },
-	{ ahc_patch9_func, 407, 6, 2 },
-	{ ahc_patch0_func, 413, 9, 2 },
-	{ ahc_patch13_func, 413, 1, 1 },
-	{ ahc_patch13_func, 422, 2, 1 },
-	{ ahc_patch14_func, 424, 1, 1 },
-	{ ahc_patch9_func, 426, 1, 2 },
-	{ ahc_patch0_func, 427, 1, 1 },
-	{ ahc_patch7_func, 428, 1, 1 },
+	{ ahc_patch1_func, 249, 1, 2 },
+	{ ahc_patch0_func, 250, 2, 2 },
+	{ ahc_patch11_func, 251, 1, 1 },
+	{ ahc_patch9_func, 259, 27, 3 },
+	{ ahc_patch1_func, 275, 10, 2 },
+	{ ahc_patch13_func, 278, 1, 1 },
+	{ ahc_patch14_func, 286, 14, 1 },
+	{ ahc_patch1_func, 302, 1, 2 },
+	{ ahc_patch0_func, 303, 1, 1 },
+	{ ahc_patch9_func, 306, 1, 1 },
+	{ ahc_patch13_func, 311, 1, 1 },
+	{ ahc_patch9_func, 312, 2, 2 },
+	{ ahc_patch0_func, 314, 4, 1 },
+	{ ahc_patch14_func, 318, 1, 1 },
+	{ ahc_patch15_func, 320, 2, 3 },
+	{ ahc_patch9_func, 320, 1, 2 },
+	{ ahc_patch0_func, 321, 1, 1 },
+	{ ahc_patch6_func, 326, 1, 2 },
+	{ ahc_patch0_func, 327, 1, 1 },
+	{ ahc_patch1_func, 331, 47, 11 },
+	{ ahc_patch6_func, 338, 2, 4 },
+	{ ahc_patch7_func, 338, 1, 1 },
+	{ ahc_patch8_func, 339, 1, 1 },
+	{ ahc_patch0_func, 340, 1, 1 },
+	{ ahc_patch16_func, 341, 1, 1 },
+	{ ahc_patch6_func, 357, 6, 3 },
+	{ ahc_patch16_func, 357, 5, 1 },
+	{ ahc_patch0_func, 363, 7, 1 },
+	{ ahc_patch13_func, 373, 5, 1 },
+	{ ahc_patch0_func, 378, 52, 17 },
+	{ ahc_patch14_func, 378, 1, 1 },
+	{ ahc_patch7_func, 380, 2, 2 },
+	{ ahc_patch17_func, 381, 1, 1 },
+	{ ahc_patch9_func, 384, 1, 1 },
+	{ ahc_patch18_func, 391, 1, 1 },
+	{ ahc_patch14_func, 396, 9, 3 },
+	{ ahc_patch9_func, 397, 3, 2 },
+	{ ahc_patch0_func, 400, 3, 1 },
+	{ ahc_patch9_func, 408, 6, 2 },
+	{ ahc_patch0_func, 414, 9, 2 },
+	{ ahc_patch13_func, 414, 1, 1 },
+	{ ahc_patch13_func, 423, 2, 1 },
+	{ ahc_patch14_func, 425, 1, 1 },
+	{ ahc_patch9_func, 427, 1, 2 },
+	{ ahc_patch0_func, 428, 1, 1 },
 	{ ahc_patch7_func, 429, 1, 1 },
-	{ ahc_patch8_func, 430, 3, 3 },
-	{ ahc_patch6_func, 431, 1, 2 },
-	{ ahc_patch0_func, 432, 1, 1 },
-	{ ahc_patch9_func, 433, 1, 1 },
-	{ ahc_patch15_func, 434, 1, 2 },
-	{ ahc_patch13_func, 434, 1, 1 },
-	{ ahc_patch14_func, 436, 9, 4 },
-	{ ahc_patch9_func, 436, 1, 1 },
-	{ ahc_patch9_func, 443, 2, 1 },
-	{ ahc_patch0_func, 445, 4, 3 },
-	{ ahc_patch9_func, 445, 1, 2 },
-	{ ahc_patch0_func, 446, 3, 1 },
-	{ ahc_patch1_func, 450, 2, 1 },
-	{ ahc_patch7_func, 452, 10, 2 },
-	{ ahc_patch0_func, 462, 1, 1 },
-	{ ahc_patch8_func, 463, 118, 22 },
-	{ ahc_patch1_func, 465, 3, 2 },
-	{ ahc_patch0_func, 468, 5, 3 },
-	{ ahc_patch9_func, 468, 2, 2 },
-	{ ahc_patch0_func, 470, 3, 1 },
-	{ ahc_patch1_func, 475, 2, 2 },
-	{ ahc_patch0_func, 477, 6, 3 },
-	{ ahc_patch9_func, 477, 2, 2 },
-	{ ahc_patch0_func, 479, 3, 1 },
-	{ ahc_patch1_func, 485, 2, 2 },
-	{ ahc_patch0_func, 487, 9, 7 },
-	{ ahc_patch9_func, 487, 5, 6 },
-	{ ahc_patch19_func, 487, 1, 2 },
-	{ ahc_patch0_func, 488, 1, 1 },
-	{ ahc_patch19_func, 490, 1, 2 },
-	{ ahc_patch0_func, 491, 1, 1 },
-	{ ahc_patch0_func, 492, 4, 1 },
-	{ ahc_patch6_func, 497, 3, 2 },
-	{ ahc_patch0_func, 500, 1, 1 },
-	{ ahc_patch6_func, 510, 1, 2 },
-	{ ahc_patch0_func, 511, 1, 1 },
-	{ ahc_patch20_func, 548, 7, 1 },
-	{ ahc_patch3_func, 583, 1, 2 },
-	{ ahc_patch0_func, 584, 1, 1 },
-	{ ahc_patch21_func, 587, 1, 1 },
-	{ ahc_patch8_func, 589, 106, 33 },
-	{ ahc_patch4_func, 591, 1, 1 },
-	{ ahc_patch1_func, 597, 2, 2 },
-	{ ahc_patch0_func, 599, 1, 1 },
-	{ ahc_patch1_func, 602, 1, 2 },
-	{ ahc_patch0_func, 603, 1, 1 },
-	{ ahc_patch9_func, 604, 3, 3 },
-	{ ahc_patch15_func, 605, 1, 1 },
-	{ ahc_patch0_func, 607, 4, 1 },
-	{ ahc_patch19_func, 616, 2, 2 },
-	{ ahc_patch0_func, 618, 1, 1 },
-	{ ahc_patch19_func, 622, 10, 3 },
-	{ ahc_patch5_func, 624, 8, 1 },
-	{ ahc_patch0_func, 632, 9, 2 },
-	{ ahc_patch5_func, 633, 8, 1 },
-	{ ahc_patch4_func, 643, 1, 2 },
-	{ ahc_patch0_func, 644, 1, 1 },
-	{ ahc_patch19_func, 645, 1, 2 },
-	{ ahc_patch0_func, 646, 3, 2 },
-	{ ahc_patch4_func, 648, 1, 1 },
-	{ ahc_patch5_func, 649, 1, 1 },
-	{ ahc_patch5_func, 652, 1, 1 },
-	{ ahc_patch5_func, 654, 1, 1 },
-	{ ahc_patch4_func, 656, 2, 2 },
-	{ ahc_patch0_func, 658, 2, 1 },
-	{ ahc_patch5_func, 660, 1, 1 },
-	{ ahc_patch5_func, 663, 1, 1 },
-	{ ahc_patch5_func, 666, 1, 1 },
-	{ ahc_patch19_func, 670, 1, 1 },
-	{ ahc_patch19_func, 673, 1, 1 },
-	{ ahc_patch4_func, 679, 1, 1 },
-	{ ahc_patch6_func, 682, 1, 2 },
-	{ ahc_patch0_func, 683, 1, 1 },
-	{ ahc_patch7_func, 695, 16, 1 },
-	{ ahc_patch4_func, 711, 20, 1 },
-	{ ahc_patch9_func, 732, 4, 2 },
-	{ ahc_patch0_func, 736, 4, 1 },
-	{ ahc_patch9_func, 740, 4, 2 },
-	{ ahc_patch0_func, 744, 3, 1 },
-	{ ahc_patch6_func, 750, 1, 1 },
-	{ ahc_patch22_func, 752, 14, 1 },
-	{ ahc_patch7_func, 766, 3, 1 },
-	{ ahc_patch9_func, 778, 24, 8 },
-	{ ahc_patch19_func, 782, 1, 2 },
-	{ ahc_patch0_func, 783, 1, 1 },
-	{ ahc_patch15_func, 788, 4, 2 },
-	{ ahc_patch0_func, 792, 7, 3 },
-	{ ahc_patch23_func, 792, 5, 2 },
-	{ ahc_patch0_func, 797, 2, 1 },
-	{ ahc_patch0_func, 802, 42, 3 },
-	{ ahc_patch18_func, 814, 18, 2 },
-	{ ahc_patch0_func, 832, 1, 1 },
-	{ ahc_patch4_func, 856, 1, 1 },
-	{ ahc_patch4_func, 857, 3, 2 },
-	{ ahc_patch0_func, 860, 1, 1 },
-	{ ahc_patch13_func, 861, 3, 1 },
-	{ ahc_patch4_func, 864, 12, 1 }
+	{ ahc_patch7_func, 430, 1, 1 },
+	{ ahc_patch8_func, 431, 3, 3 },
+	{ ahc_patch6_func, 432, 1, 2 },
+	{ ahc_patch0_func, 433, 1, 1 },
+	{ ahc_patch9_func, 434, 1, 1 },
+	{ ahc_patch15_func, 435, 1, 2 },
+	{ ahc_patch13_func, 435, 1, 1 },
+	{ ahc_patch14_func, 437, 9, 4 },
+	{ ahc_patch9_func, 437, 1, 1 },
+	{ ahc_patch9_func, 444, 2, 1 },
+	{ ahc_patch0_func, 446, 4, 3 },
+	{ ahc_patch9_func, 446, 1, 2 },
+	{ ahc_patch0_func, 447, 3, 1 },
+	{ ahc_patch1_func, 451, 2, 1 },
+	{ ahc_patch7_func, 453, 10, 2 },
+	{ ahc_patch0_func, 463, 1, 1 },
+	{ ahc_patch8_func, 464, 118, 22 },
+	{ ahc_patch1_func, 466, 3, 2 },
+	{ ahc_patch0_func, 469, 5, 3 },
+	{ ahc_patch9_func, 469, 2, 2 },
+	{ ahc_patch0_func, 471, 3, 1 },
+	{ ahc_patch1_func, 476, 2, 2 },
+	{ ahc_patch0_func, 478, 6, 3 },
+	{ ahc_patch9_func, 478, 2, 2 },
+	{ ahc_patch0_func, 480, 3, 1 },
+	{ ahc_patch1_func, 486, 2, 2 },
+	{ ahc_patch0_func, 488, 9, 7 },
+	{ ahc_patch9_func, 488, 5, 6 },
+	{ ahc_patch19_func, 488, 1, 2 },
+	{ ahc_patch0_func, 489, 1, 1 },
+	{ ahc_patch19_func, 491, 1, 2 },
+	{ ahc_patch0_func, 492, 1, 1 },
+	{ ahc_patch0_func, 493, 4, 1 },
+	{ ahc_patch6_func, 498, 3, 2 },
+	{ ahc_patch0_func, 501, 1, 1 },
+	{ ahc_patch6_func, 511, 1, 2 },
+	{ ahc_patch0_func, 512, 1, 1 },
+	{ ahc_patch20_func, 549, 7, 1 },
+	{ ahc_patch3_func, 584, 1, 2 },
+	{ ahc_patch0_func, 585, 1, 1 },
+	{ ahc_patch21_func, 588, 1, 1 },
+	{ ahc_patch8_func, 590, 106, 33 },
+	{ ahc_patch4_func, 592, 1, 1 },
+	{ ahc_patch1_func, 598, 2, 2 },
+	{ ahc_patch0_func, 600, 1, 1 },
+	{ ahc_patch1_func, 603, 1, 2 },
+	{ ahc_patch0_func, 604, 1, 1 },
+	{ ahc_patch9_func, 605, 3, 3 },
+	{ ahc_patch15_func, 606, 1, 1 },
+	{ ahc_patch0_func, 608, 4, 1 },
+	{ ahc_patch19_func, 617, 2, 2 },
+	{ ahc_patch0_func, 619, 1, 1 },
+	{ ahc_patch19_func, 623, 10, 3 },
+	{ ahc_patch5_func, 625, 8, 1 },
+	{ ahc_patch0_func, 633, 9, 2 },
+	{ ahc_patch5_func, 634, 8, 1 },
+	{ ahc_patch4_func, 644, 1, 2 },
+	{ ahc_patch0_func, 645, 1, 1 },
+	{ ahc_patch19_func, 646, 1, 2 },
+	{ ahc_patch0_func, 647, 3, 2 },
+	{ ahc_patch4_func, 649, 1, 1 },
+	{ ahc_patch5_func, 650, 1, 1 },
+	{ ahc_patch5_func, 653, 1, 1 },
+	{ ahc_patch5_func, 655, 1, 1 },
+	{ ahc_patch4_func, 657, 2, 2 },
+	{ ahc_patch0_func, 659, 2, 1 },
+	{ ahc_patch5_func, 661, 1, 1 },
+	{ ahc_patch5_func, 664, 1, 1 },
+	{ ahc_patch5_func, 667, 1, 1 },
+	{ ahc_patch19_func, 671, 1, 1 },
+	{ ahc_patch19_func, 674, 1, 1 },
+	{ ahc_patch4_func, 680, 1, 1 },
+	{ ahc_patch6_func, 683, 1, 2 },
+	{ ahc_patch0_func, 684, 1, 1 },
+	{ ahc_patch7_func, 696, 16, 1 },
+	{ ahc_patch4_func, 712, 20, 1 },
+	{ ahc_patch9_func, 733, 4, 2 },
+	{ ahc_patch0_func, 737, 4, 1 },
+	{ ahc_patch9_func, 741, 4, 2 },
+	{ ahc_patch0_func, 745, 3, 1 },
+	{ ahc_patch6_func, 751, 1, 1 },
+	{ ahc_patch22_func, 753, 14, 1 },
+	{ ahc_patch7_func, 767, 3, 1 },
+	{ ahc_patch9_func, 779, 24, 8 },
+	{ ahc_patch19_func, 783, 1, 2 },
+	{ ahc_patch0_func, 784, 1, 1 },
+	{ ahc_patch15_func, 789, 4, 2 },
+	{ ahc_patch0_func, 793, 7, 3 },
+	{ ahc_patch23_func, 793, 5, 2 },
+	{ ahc_patch0_func, 798, 2, 1 },
+	{ ahc_patch0_func, 803, 42, 3 },
+	{ ahc_patch18_func, 815, 18, 2 },
+	{ ahc_patch0_func, 833, 1, 1 },
+	{ ahc_patch4_func, 857, 1, 1 },
+	{ ahc_patch4_func, 858, 3, 2 },
+	{ ahc_patch0_func, 861, 1, 1 },
+	{ ahc_patch13_func, 862, 3, 1 },
+	{ ahc_patch4_func, 865, 12, 1 }
 };
 
 static struct cs {
@@ -1296,11 +1297,11 @@ static struct cs {
 } critical_sections[] = {
 	{ 11, 18 },
 	{ 21, 30 },
-	{ 711, 727 },
-	{ 857, 860 },
-	{ 864, 870 },
-	{ 872, 874 },
-	{ 874, 876 }
+	{ 712, 728 },
+	{ 858, 861 },
+	{ 865, 871 },
+	{ 873, 875 },
+	{ 875, 877 }
 };
 
 static const int num_critical_sections = sizeof(critical_sections)
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm.c	2004-04-04 05:36:55.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm.c	2004-05-13 16:42:17.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#22 $
+ * $Id$
  *
  * $FreeBSD$
  */
@@ -609,10 +609,10 @@ output_listing(char *ifilename)
 
 		while (line < cur_instr->srcline) {
 			fgets(buf, sizeof(buf), ifile);
-				fprintf(listfile, "\t\t%s", buf);
+				fprintf(listfile, "             \t%s", buf);
 				line++;
 		}
-		fprintf(listfile, "%03x %02x%02x%02x%02x", instrptr,
+		fprintf(listfile, "%04x %02x%02x%02x%02x", instrptr,
 #if BYTE_ORDER == LITTLE_ENDIAN
 			cur_instr->format.bytes[0],
 			cur_instr->format.bytes[1],
@@ -624,14 +624,23 @@ output_listing(char *ifilename)
 			cur_instr->format.bytes[1],
 			cur_instr->format.bytes[0]);
 #endif
-		fgets(buf, sizeof(buf), ifile);
-		fprintf(listfile, "\t%s", buf);
-		line++;
+		/*
+		 * Macro expansions can cause several instructions
+		 * to be output for a single source line.  Only
+		 * advance the line once in these cases.
+		 */
+		if (line == cur_instr->srcline) {
+			fgets(buf, sizeof(buf), ifile);
+			fprintf(listfile, "\t%s", buf);
+			line++;
+		} else {
+			fprintf(listfile, "\n");
+		}
 		instrptr++;
 	}
 	/* Dump the remainder of the file */
 	while(fgets(buf, sizeof(buf), ifile) != NULL)
-		fprintf(listfile, "\t\t%s", buf);
+		fprintf(listfile, "             %s", buf);
 
 	fclose(ifile);
 }
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
--- linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y	2004-04-04 05:36:24.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y	2004-05-13 16:42:17.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#29 $
+ * $Id$
  *
  * $FreeBSD$
  */
@@ -157,6 +157,8 @@ static int  is_download_const(expression
 
 %token T_END_CS
 
+%token T_PAD_PAGE
+
 %token T_FIELD
 
 %token T_ENUM
@@ -189,6 +191,10 @@ static int  is_download_const(expression
 
 %token <value> T_OR
 
+/* 16 bit extensions */
+%token <value> T_OR16 T_AND16 T_XOR16 T_ADD16
+%token <value> T_ADC16 T_MVI16 T_TEST16 T_CMP16 T_CMPXCHG
+
 %token T_RET
 
 %token T_NOP
@@ -207,7 +213,7 @@ static int  is_download_const(expression
 
 %type <expression> expression immediate immediate_or_a
 
-%type <value> export ret f1_opcode f2_opcode jmp_jc_jnc_call jz_jnz je_jne
+%type <value> export ret f1_opcode f2_opcode f4_opcode jmp_jc_jnc_call jz_jnz je_jne
 
 %type <value> mode_value mode_list macro_arglist
 
@@ -1304,6 +1310,15 @@ f2_opcode:
 |	T_ROR { $$ = AIC_OP_ROR; }
 ;
 
+f4_opcode:
+	T_OR16	{ $$ = AIC_OP_OR16; }
+|	T_AND16 { $$ = AIC_OP_AND16; }
+|	T_XOR16 { $$ = AIC_OP_XOR16; }
+|	T_ADD16 { $$ = AIC_OP_ADD16; }
+|	T_ADC16 { $$ = AIC_OP_ADC16; }
+|	T_MVI16 { $$ = AIC_OP_MVI16; }
+;
+
 code:
 	f2_opcode destination ',' expression opt_source ret ';'
 	{
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h
--- linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h	2004-04-04 05:38:20.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h	2004-05-13 16:42:17.000000000 +0200
@@ -37,11 +37,12 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#11 $
+ * $Id$
  *
  * $FreeBSD$
  */
 
+/* 8bit ALU logic operations */
 struct ins_format1 {
 #if BYTE_ORDER == LITTLE_ENDIAN
 	uint32_t	immediate	: 8,
@@ -60,6 +61,7 @@ struct ins_format1 {
 #endif
 };
 
+/* 8bit ALU shift/rotate operations */
 struct ins_format2 {
 #if BYTE_ORDER == LITTLE_ENDIAN
 	uint32_t	shift_control	: 8,
@@ -78,6 +80,7 @@ struct ins_format2 {
 #endif
 };
 
+/* 8bit branch control operations */
 struct ins_format3 {
 #if BYTE_ORDER == LITTLE_ENDIAN
 	uint32_t	immediate	: 8,
@@ -94,10 +97,68 @@ struct ins_format3 {
 #endif
 };
 
+/* 16bit ALU logic operations */
+struct ins_format4 {
+#if BYTE_ORDER == LITTLE_ENDIAN
+	uint32_t	opcode_ext	: 8,
+			source		: 9,
+			destination	: 9,
+			ret		: 1,
+			opcode		: 4,
+			parity		: 1;
+#else
+	uint32_t	parity		: 1,
+			opcode		: 4,
+			ret		: 1,
+			destination	: 9,
+			source		: 9,
+			opcode_ext	: 8;
+#endif
+};
+
+/* 16bit branch control operations */
+struct ins_format5 {
+#if BYTE_ORDER == LITTLE_ENDIAN
+	uint32_t	opcode_ext	: 8,
+			source		: 9,
+			address		: 10,
+			opcode		: 4,
+			parity		: 1;
+#else
+	uint32_t	parity		: 1,
+			opcode		: 4,
+			address		: 10,
+			source		: 9,
+			opcode_ext	: 8;
+#endif
+};
+
+/*  Far branch operations */
+struct ins_format6 {
+#if BYTE_ORDER == LITTLE_ENDIAN
+	uint32_t	page		: 3,
+			opcode_ext	: 5,
+			source		: 9,
+			address		: 10,
+			opcode		: 4,
+			parity		: 1;
+#else
+	uint32_t	parity		: 1,
+			opcode		: 4,
+			address		: 10,
+			source		: 9,
+			opcode_ext	: 5,
+			page		: 3;
+#endif
+};
+
 union ins_formats {
 		struct ins_format1 format1;
 		struct ins_format2 format2;
 		struct ins_format3 format3;
+		struct ins_format4 format4;
+		struct ins_format5 format5;
+		struct ins_format6 format6;
 		uint8_t		   bytes[4];
 		uint32_t	   integer;
 };
@@ -116,6 +177,8 @@ struct instruction {
 #define	AIC_OP_ROL	0x5
 #define	AIC_OP_BMOV	0x6
 
+#define	AIC_OP_MVI16	0x7
+
 #define	AIC_OP_JMP	0x8
 #define AIC_OP_JC	0x9
 #define AIC_OP_JNC	0xa
@@ -129,3 +192,26 @@ struct instruction {
 #define	AIC_OP_SHL	0x10
 #define	AIC_OP_SHR	0x20
 #define	AIC_OP_ROR	0x30
+
+/* 16bit Ops. Low byte main opcode.  High byte extended opcode. */ 
+#define	AIC_OP_OR16	0x8005
+#define	AIC_OP_AND16	0x8105
+#define	AIC_OP_XOR16	0x8205
+#define	AIC_OP_ADD16	0x8305
+#define	AIC_OP_ADC16	0x8405
+#define AIC_OP_JNE16	0x8805
+#define AIC_OP_JNZ16	0x8905
+#define AIC_OP_JE16	0x8C05
+#define AIC_OP_JZ16	0x8B05
+#define AIC_OP_JMP16	0x9005
+#define AIC_OP_JC16	0x9105
+#define AIC_OP_JNC16	0x9205
+#define AIC_OP_CALL16	0x9305
+#define AIC_OP_CALL16	0x9305
+
+/* Page extension is low three bits of second opcode byte. */
+#define AIC_OP_JMPF	0xA005
+#define AIC_OP_CALLF	0xB005
+#define AIC_OP_JCF	0xC005
+#define AIC_OP_JNCF	0xD005
+#define AIC_OP_CMPXCHG	0xE005
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l
--- linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l	2004-04-04 05:36:58.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l	2004-05-13 16:42:17.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#8 $
+ * $Id$
  *
  * $FreeBSD$
  */
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l
--- linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l	2004-04-04 05:37:40.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l	2004-05-13 16:42:17.000000000 +0200
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#19 $
+ * $Id$
  *
  * $FreeBSD$
  */
@@ -132,7 +132,7 @@ if[ \t]*\(		{
 						*string_buf_ptr++ = *yptr++;
 				}
 			}
-
+else			{ return T_ELSE; }
 VERSION			{ return T_VERSION; }
 PREFIX			{ return T_PREFIX; }
 PATCH_ARG_LIST		{ return T_PATCH_ARG_LIST; }
@@ -173,10 +173,6 @@ RW|RO|WO		{
 					yylval.value = WO;
 				 return T_MODE;
 			}
-BEGIN_CRITICAL		{ return T_BEGIN_CS; }
-END_CRITICAL		{ return T_END_CS; }
-SET_SRC_MODE		{ return T_SET_SRC_MODE; }
-SET_DST_MODE		{ return T_SET_DST_MODE; }
 field			{ return T_FIELD; }
 enum			{ return T_ENUM; }
 mask			{ return T_MASK; }
@@ -192,6 +188,13 @@ none			{ return T_NONE; }
 sindex			{ return T_SINDEX; }
 A			{ return T_A; }
 
+	/* Instruction Formatting */
+PAD_PAGE		{ return T_PAD_PAGE; }
+BEGIN_CRITICAL		{ return T_BEGIN_CS; }
+END_CRITICAL		{ return T_END_CS; }
+SET_SRC_MODE		{ return T_SET_SRC_MODE; }
+SET_DST_MODE		{ return T_SET_DST_MODE; }
+
 	/* Opcodes */
 shl			{ return T_SHL; }
 shr			{ return T_SHR; }
@@ -223,7 +226,17 @@ and			{ return T_AND;	}
 or			{ return T_OR;	}
 ret			{ return T_RET; }
 nop			{ return T_NOP; }
-else			{ return T_ELSE; }
+
+	/* ARP2 16bit extensions */
+or16			{ return T_OR16; }
+and16			{ return T_AND16; }
+xor16			{ return T_XOR16; }
+add16			{ return T_ADD16; }
+adc16			{ return T_ADC16; }
+mvi16			{ return T_MVI16; }
+test16			{ return T_TEST16; }
+cmp16			{ return T_CMP16; }
+cmpxchg			{ return T_CMPXCHG; }
 
 	/* Allowed Symbols */
 \<\<			{ return T_EXPR_LSHIFT; }
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c	2004-04-04 05:38:22.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c	2004-05-13 16:42:17.000000000 +0200
@@ -37,7 +37,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#24 $
+ * $Id$
  *
  * $FreeBSD$
  */
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aiclib.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aiclib.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aiclib.c	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aiclib.c	2004-05-13 16:42:17.000000000 +0200
@@ -30,16 +30,6 @@
  * $Id$
  */
 
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include <linux/version.h>
-
-/* Core SCSI definitions */
-#include "scsi.h"
-#include "hosts.h"
-#include "aiclib.h"
-#include "cam.h"
-
 #ifndef FALSE
 #define FALSE   0
 #endif /* FALSE */
@@ -1410,3 +1400,325 @@ aic_parse_brace_option(char *opt_name, c
 	}
 	return (opt_arg);
 }
+
+/************************* Magic SysReq Support *******************************/
+void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+aic_sysrq_handler(int key, struct pt_regs *unused, struct kbd_struct *unused1,
+		  struct tty_struct *unused2)
+#else
+aic_sysrq_handler(int key, struct pt_regs *unused, struct tty_struct *unused2)
+#endif
+{
+#ifdef CONFIG_MAGIC_SYSRQ
+	struct aic_softc *aic;
+	u_long l;
+
+	aic_list_lock(&l);
+
+	TAILQ_FOREACH(aic, &aic_tailq, links) {
+		u_long s;
+
+		aic_lock(aic, &s);
+		aic_dump_card_state(aic);
+		aic_unlock(aic, &s);
+	}
+	aic_list_unlock(&l);
+#endif
+}
+
+int
+aic_install_sysrq(struct aic_sysrq_key_op *key_op)
+{
+#ifdef CONFIG_MAGIC_SYSRQ
+	char *str;
+	int len;
+	int i;
+
+	str = key_op->help_msg;
+	len = strlen(str);
+	for (i = 0; i < len; i++) {
+		int key;
+
+		key = str[i];
+		if (register_sysrq_key(key, key_op) == 0) {
+
+			if (key >= 'a' && key <= 'z')
+				str[i] = key + ('A' - 'a');
+			return (key);
+		}
+	}
+#endif
+	return (0);
+}
+
+void
+aic_remove_sysrq(int key, struct aic_sysrq_key_op *key_op)
+{
+#ifdef CONFIG_MAGIC_SYSRQ
+	unregister_sysrq_key(key, key_op);
+#endif
+}
+
+/******************************** Bus DMA *************************************/
+int
+aic_dma_tag_create(struct aic_softc *aic, bus_dma_tag_t parent,
+		   bus_size_t alignment, bus_size_t boundary,
+		   bus_addr_t lowaddr, bus_addr_t highaddr,
+		   bus_dma_filter_t *filter, void *filterarg,
+		   bus_size_t maxsize, int nsegments,
+		   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)
+{
+	bus_dma_tag_t dmat;
+
+	dmat = malloc(sizeof(*dmat), M_DEVBUF, M_NOWAIT);
+	if (dmat == NULL)
+		return (ENOMEM);
+
+	/*
+	 * Linux is very simplistic about DMA memory.  For now don't
+	 * maintain all specification information.  Once Linux supplies
+	 * better facilities for doing these operations, or the
+	 * needs of this particular driver change, we might need to do
+	 * more here.
+	 */
+	dmat->alignment = alignment;
+	dmat->boundary = boundary;
+	dmat->maxsize = maxsize;
+	*ret_tag = dmat;
+	return (0);
+}
+
+void
+aic_dma_tag_destroy(struct aic_softc *aic, bus_dma_tag_t dmat)
+{
+	free(dmat, M_DEVBUF);
+}
+
+int
+aic_dmamem_alloc(struct aic_softc *aic, bus_dma_tag_t dmat, void** vaddr,
+		 int flags, bus_dmamap_t *mapp)
+{
+	bus_dmamap_t map;
+
+	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT);
+	if (map == NULL)
+		return (ENOMEM);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	/*
+	 * Although we can dma data above 4GB, our
+	 * coherent memory is below 4GB for
+	 * space efficiency reasons (only need a 4byte
+	 * address).  For this reason, we have to reset
+	 * our dma mask when doing allocations.
+	 */
+	aic_set_dma_mask(aic, 0xFFFFFFFF);
+#endif
+	*vaddr = aic_alloc_coherent(aic, dmat->maxsize, &map->bus_addr);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	aic_set_dma_mask(aic, aic->platform_data->hw_dma_mask);
+#endif
+	if (*vaddr == NULL)
+		return (ENOMEM);
+	*mapp = map;
+	return(0);
+}
+
+void
+aic_dmamem_free(struct aic_softc *aic, bus_dma_tag_t dmat,
+		void* vaddr, bus_dmamap_t map)
+{
+	aic_free_coherent(aic, dmat->maxsize, vaddr, map->bus_addr);
+}
+
+int
+aic_dmamap_load(struct aic_softc *aic, bus_dma_tag_t dmat, bus_dmamap_t map,
+		void *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,
+		void *cb_arg, int flags)
+{
+	/*
+	 * Assume for now that this will only be used during
+	 * initialization and not for per-transaction buffer mapping.
+	 */
+	bus_dma_segment_t stack_sg;
+
+	stack_sg.ds_addr = map->bus_addr;
+	stack_sg.ds_len = dmat->maxsize;
+	cb(cb_arg, &stack_sg, /*nseg*/1, /*error*/0);
+	return (0);
+}
+
+void
+aic_dmamap_destroy(struct aic_softc *aic, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	free(map, M_DEVBUF);
+}
+
+int
+aic_dmamap_unload(struct aic_softc *aic, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	/* Nothing to do */
+	return (0);
+}
+
+/***************************** Queue Handling ********************************/
+/*
+ * In 2.4.X and above, this routine is called from a tasklet,
+ * so we must re-acquire our lock prior to executing this code.
+ * In all prior kernels, aic_schedule_runq() calls this routine
+ * directly and aic_schedule_runq() is called with our lock held.
+ */
+void
+aic_runq_tasklet(unsigned long data)
+{
+	struct aic_softc* aic;
+	struct aic_linux_device *dev;
+	u_long flags;
+
+	aic = (struct aic_softc *)data;
+	aic_lock(aic, &flags);
+	while ((dev = aic_linux_next_device_to_run(aic)) != NULL) {
+	
+		TAILQ_REMOVE(&aic->platform_data->device_runq, dev, links);
+		dev->flags &= ~AIC_DEV_ON_RUN_LIST;
+		aic_linux_check_device_queue(aic, dev);
+		/* Yeild to our interrupt handler */
+		aic_unlock(aic, &flags);
+		aic_lock(aic, &flags);
+	}
+	aic_unlock(aic, &flags);
+}
+
+void
+aic_unblock_tasklet(unsigned long data)
+{
+	struct aic_softc* aic;
+
+	aic = (struct aic_softc *)data;
+	scsi_unblock_requests(aic->platform_data->host);
+}
+
+void
+aic_bus_settle_complete(u_long data)
+{
+	struct aic_softc *aic;
+	u_long s;
+
+	aic = (struct aic_softc *)data;
+	/*
+	 * Guard against our bottom half scheduling another
+	 * bus settle delay just as our timer runs.  If this
+	 * occurs, do nothing.  The newly scheduled timer will
+	 * take care of things.
+	 */
+	aic_lock(aic, &s);
+	if (timer_pending(&aic->platform_data->bus_settle_timer) == 0) {
+		aic->platform_data->flags &= ~AIC_BUS_SETTLE_TIMER;
+		aic_release_simq_locked(aic);
+	}
+	aic_unlock(aic, &s);
+}
+
+void
+aic_freeze_simq(struct aic_softc *aic)
+{
+	aic->platform_data->qfrozen++;
+	if (aic->platform_data->qfrozen == 1)
+		scsi_block_requests(aic->platform_data->host);
+}
+
+void
+aic_release_simq(struct aic_softc *aic)
+{
+	u_long s;
+
+	aic_lock(aic, &s);
+	aic_release_simq_locked(aic);
+	aic_unlock(aic, &s);
+}
+
+void
+aic_release_simq_locked(struct aic_softc *aic)
+{
+
+	if (aic->platform_data->qfrozen > 0)
+		aic->platform_data->qfrozen--;
+	if (AIC_DV_SIMQ_FROZEN(aic)
+	 && ((aic->platform_data->flags & AIC_DV_WAIT_SIMQ_RELEASE) != 0)) {
+		aic->platform_data->flags &= ~AIC_DV_WAIT_SIMQ_RELEASE;
+		up(&aic->platform_data->dv_sem);
+	}
+	if (aic->platform_data->qfrozen == 0) {
+		aic_schedule_unblock(aic);
+		aic_schedule_runq(aic);
+	}
+}
+
+/***************************** Timer Facilities *******************************/
+void
+aic_platform_timeout(struct scsi_cmnd *cmd)
+{
+
+	if (AIC_DV_CMD(cmd) != 0) {
+
+		aic_linux_dv_timeout(cmd);
+	} else {
+		struct	scb *scb;
+		struct	aic_softc *aic;
+		u_long	s;
+
+		scb = (struct scb *)cmd->host_scribble;
+		aic = scb->aic_softc;
+		aic_lock(aic, &s);
+
+		if (scb == NULL
+		 || scb->flags == SCB_FLAG_NONE) {
+			int done_late;
+
+			/*
+			 * Handle timeout/completion races.
+			 * If the command is still sitting on
+			 * our completion queue, just re-instate
+			 * the timeout.  If we've already completed
+			 * the command, the function pointer in our
+			 * timer will be cleared and we will need to
+			 * additionally complete it again to the mid-layer.
+			 *
+			 * Since done_late is cleared by adding a
+			 * timer, we must save off its value first.
+			 */
+			done_late = cmd->eh_timeout.function == NULL;
+			scsi_add_timer(cmd, 60*HZ, aic_linux_midlayer_timeout);
+			if (done_late)
+				cmd->scsi_done(cmd);
+		} else if ((scb->platform_data->flags & AIC_TIMEOUT_ACTIVE)) {
+
+			/*
+			 * Handle the case of timeouts that expire just
+			 * as we delete timers during recovery by skipping
+			 * SCBs that don't have timers active.
+			 */
+			scb->platform_data->flags &= ~AIC_TIMEOUT_ACTIVE;
+
+			/*
+			 * We must clear out the function pointer so that
+			 * scsi_add_timer does not believe that a del_timer
+			 * is required before setting up a new timer for
+			 * this command.
+			 */
+			scb->io_ctx->eh_timeout.function = NULL;
+			aic_timeout(scb);
+		}
+		aic_unlock(aic, &s);
+	}
+}
+
+void
+aic_linux_midlayer_timeout(struct scsi_cmnd *cmd)
+{
+	struct aic_softc *aic;
+
+	aic = *(struct aic_softc **)cmd->device->host->hostdata;
+	printf("%s: midlayer_timeout\n", aic_name(aic));
+}
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aiclib.h linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aiclib.h
--- linux-2.6.5/drivers/scsi/aic7xxx/aiclib.h	2004-04-04 05:36:17.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aiclib.h	2004-05-13 16:42:17.000000000 +0200
@@ -1,4 +1,5 @@
 /*
+ * SCSI definitions...
  * Largely written by Julian Elischer (julian@tfs.com)
  * for TRW Financial Systems.
  *
@@ -16,7 +17,7 @@
  *
  * $FreeBSD: src/sys/cam/scsi/scsi_all.h,v 1.21 2002/10/08 17:12:44 ken Exp $
  *
- * Copyright (c) 2003 Adaptec Inc.
+ * Copyright (c) 2003, 2004 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -57,6 +58,35 @@
 #ifndef	_AICLIB_H
 #define _AICLIB_H
 
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/smp_lock.h>
+#include <linux/module.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+
+#include <linux/slab.h>
+#include <linux/interrupt.h> /* For tasklet support. */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <linux/blk.h>
+#endif
+#include <linux/blkdev.h>
+
+#include "scsi.h"
+#include "hosts.h"
+
+/* Name space conflict with BSD queue macros */
+#ifdef LIST_HEAD
+#undef LIST_HEAD
+#endif
+#include "cam.h"
+#include "queue.h"
+#include "scsi_message.h"
+#include "scsi_iu.h"
+
 /*
  * Linux Interrupt Support.
  */
@@ -66,9 +96,824 @@ typedef void irqreturn_t;
 #endif
 
 /*
- * SCSI command format
+ * Linux Timer Support.
  */
+#define AIC_USECS_PER_JIFFY (1000000/HZ)
 
+/**************************** Module Library Hack *****************************/
+/*
+ * What we'd like to do is have a single "scsi library" module that both the
+ * aic7xxx and aic79xx drivers could load and depend on.  A cursory examination
+ * of implementing module dependencies in Linux (handling the install and
+ * initrd cases) does not look promissing.  For now, we just duplicate this
+ * code in both drivers using a simple symbol renaming scheme that hides this
+ * hack from the drivers.
+ */
+#define AIC_LIB_ENTRY_CONCAT(x, prefix)	prefix ## x
+#define	AIC_LIB_ENTRY_EXPAND(x, prefix) AIC_LIB_ENTRY_CONCAT(x, prefix)
+#define AIC_LIB_ENTRY(x)		AIC_LIB_ENTRY_EXPAND(x, AIC_LIB_PREFIX)
+
+#define AIC_CONST_ENTRY(x)		AIC_LIB_ENTRY_EXPAND(x,AIC_CONST_PREFIX)
+
+#define	aic_sense_desc			AIC_LIB_ENTRY(_sense_desc)
+#define	aic_sense_error_action		AIC_LIB_ENTRY(_sense_error_action)
+#define	aic_error_action		AIC_LIB_ENTRY(_error_action)
+#define	aic_op_desc			AIC_LIB_ENTRY(_op_desc)
+#define	aic_cdb_string			AIC_LIB_ENTRY(_cdb_string)
+#define aic_print_inquiry		AIC_LIB_ENTRY(_print_inquiry)
+#define aic_calc_syncsrate		AIC_LIB_ENTRY(_calc_syncrate)
+#define	aic_calc_syncparam		AIC_LIB_ENTRY(_calc_syncparam)
+#define	aic_calc_speed			AIC_LIB_ENTRY(_calc_speed)
+#define	aic_inquiry_match		AIC_LIB_ENTRY(_inquiry_match)
+#define	aic_static_inquiry_match	AIC_LIB_ENTRY(_static_inquiry_match)
+#define	aic_parse_brace_option		AIC_LIB_ENTRY(_parse_brace_option)
+#define	aic_power_state_change		AIC_LIB_ENTRY(_power_state_change)
+#define	aic_sysrq_handler		AIC_LIB_ENTRY(_sysrq_handler)
+#define	aic_install_sysrq		AIC_LIB_ENTRY(_install_sysrq)
+#define	aic_remove_sysrq		AIC_LIB_ENTRY(_remove_sysrq)
+#define	aic_list_lockinit		AIC_LIB_ENTRY(_list_lockinit)
+#define	aic_list_lock			AIC_LIB_ENTRY(_list_lock)
+#define	aic_list_unlock			AIC_LIB_ENTRY(_list_unlock)
+#define	aic_entrypoint_lock		AIC_LIB_ENTRY(_entrypoint_lock)
+#define	aic_entrypoint_unlock		AIC_LIB_ENTRY(_entrypoint_unlock)
+#define	aic_lockinit			AIC_LIB_ENTRY(_lockinit)
+#define	aic_lock			AIC_LIB_ENTRY(_lock)
+#define	aic_unlock			AIC_LIB_ENTRY(_unlock)
+#define	aic_dump_card_state		AIC_LIB_ENTRY(_dump_card_state)
+#define	aic_linux_dv_complete		AIC_LIB_ENTRY(_linux_dv_complete)
+#define	aic_linux_run_device_queue	AIC_LIB_ENTRY(_linux_run_device_queue)
+#define	aic_linux_dv_timeout		AIC_LIB_ENTRY(_linux_dv_timeout)
+#define	aic_linux_midlayer_timeout	AIC_LIB_ENTRY(_linux_midlayer_timeout)
+#define	aic_freeze_simq			AIC_LIB_ENTRY(_freeze_simq)
+#define	aic_bus_settle_complete		AIC_LIB_ENTRY(_bus_settle_complete)
+#define	aic_release_simq		AIC_LIB_ENTRY(_release_simq)
+#define	aic_release_simq		AIC_LIB_ENTRY(_release_simq)
+#define	aic_release_simq_locked		AIC_LIB_ENTRY(_release_simq_locked)
+#define	aic_dma_tag_create		AIC_LIB_ENTRY(_dma_tag_create)
+#define	aic_dma_tag_destroy		AIC_LIB_ENTRY(_dma_tag_destroy)
+#define	aic_dmamem_alloc		AIC_LIB_ENTRY(_dmamem_alloc)
+#define	aic_dmamem_free			AIC_LIB_ENTRY(_dmamem_free)
+#define	aic_dmamap_create		AIC_LIB_ENTRY(_dmamap_create)
+#define	aic_dmamap_destroy		AIC_LIB_ENTRY(_dmamap_destroy)
+#define	aic_dmamap_load			AIC_LIB_ENTRY(_dmamap_load)
+#define	aic_dmamap_unload		AIC_LIB_ENTRY(_dmamap_unload)
+#define	aic_dmamap_destroy		AIC_LIB_ENTRY(_dmamap_destroy)
+#define	aic_timeout			AIC_LIB_ENTRY(_timeout)
+#define	aic_runq_tasklet		AIC_LIB_ENTRY(_runq_tasklet)
+#define	aic_unblock_tasklet		AIC_LIB_ENTRY(_unblock_tasklet)
+#define	aic_platform_timeout		AIC_LIB_ENTRY(_platform_timeout)
+#define	aic_name			AIC_LIB_ENTRY(_name)
+
+#define aic_list_spinlock		AIC_LIB_ENTRY(_list_spinlock)
+#define	aic_tailq			AIC_LIB_ENTRY(_tailq)
+#define	aic_softc			AIC_LIB_ENTRY(_softc)
+#define	aic_transinfo			AIC_LIB_ENTRY(_transinfo)
+#define	aic_platform_data		AIC_LIB_ENTRY(_platform_data)
+#define	aic_devinfo			AIC_LIB_ENTRY(_devinfo)
+#define	aic_callback_t			AIC_LIB_ENTRY(_callback_t)
+
+#define	AIC_NUM_LUNS			AIC_CONST_ENTRY(_NUM_LUNS)
+#define	AIC_NUM_TARGETS			AIC_CONST_ENTRY(_NUM_TARGETS)
+#define	AIC_RESOURCE_SHORTAGE		AIC_CONST_ENTRY(_RESOURCE_SHORTAGE)
+
+/*************************** Forward Declarations *****************************/
+struct aic_softc;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+typedef struct device *aic_dev_softc_t;
+#else
+typedef struct pci_dev *aic_dev_softc_t;
+#endif
+typedef Scsi_Cmnd     *aic_io_ctx_t;
+
+/*************************** Timer DataStructures *****************************/
+typedef struct timer_list aic_timer_t;
+
+/***************************** Bus Space/DMA **********************************/
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,17)
+typedef dma_addr_t bus_addr_t;
+#else
+typedef uint32_t bus_addr_t;
+#endif
+typedef uint32_t bus_size_t;
+
+typedef enum {
+	BUS_SPACE_MEMIO,
+	BUS_SPACE_PIO
+} bus_space_tag_t;
+
+typedef union {
+	u_long		  ioport;
+	volatile uint8_t *maddr;
+} bus_space_handle_t;
+
+typedef struct bus_dma_segment
+{
+	bus_addr_t	ds_addr;
+	bus_size_t	ds_len;
+} bus_dma_segment_t;
+
+struct aic_linux_dma_tag
+{
+	bus_size_t	alignment;
+	bus_size_t	boundary;
+	bus_size_t	maxsize;
+};
+typedef struct aic_linux_dma_tag* bus_dma_tag_t;
+
+struct aic_linux_dmamap
+{
+	bus_addr_t	bus_addr;
+};
+typedef struct aic_linux_dmamap* bus_dmamap_t;
+
+typedef int bus_dma_filter_t(void*, bus_addr_t);
+typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);
+
+#define BUS_DMA_WAITOK		0x0
+#define BUS_DMA_NOWAIT		0x1
+#define BUS_DMA_ALLOCNOW	0x2
+#define BUS_DMA_LOAD_SEGS	0x4	/*
+					 * Argument is an S/G list not
+					 * a single buffer.
+					 */
+
+#define BUS_SPACE_MAXADDR	0xFFFFFFFF
+#define BUS_SPACE_MAXADDR_32BIT	0xFFFFFFFF
+#define BUS_SPACE_MAXSIZE_32BIT	0xFFFFFFFF
+
+int	aic_dma_tag_create(struct aic_softc *, bus_dma_tag_t /*parent*/,
+			   bus_size_t /*alignment*/, bus_size_t /*boundary*/,
+			   bus_addr_t /*lowaddr*/, bus_addr_t /*highaddr*/,
+			   bus_dma_filter_t*/*filter*/, void */*filterarg*/,
+			   bus_size_t /*maxsize*/, int /*nsegments*/,
+			   bus_size_t /*maxsegsz*/, int /*flags*/,
+			   bus_dma_tag_t */*dma_tagp*/);
+
+void	aic_dma_tag_destroy(struct aic_softc *, bus_dma_tag_t /*tag*/);
+
+int	aic_dmamem_alloc(struct aic_softc *, bus_dma_tag_t /*dmat*/,
+			 void** /*vaddr*/, int /*flags*/,
+			 bus_dmamap_t* /*mapp*/);
+
+void	aic_dmamem_free(struct aic_softc *, bus_dma_tag_t /*dmat*/,
+			void* /*vaddr*/, bus_dmamap_t /*map*/);
+
+void	aic_dmamap_destroy(struct aic_softc *, bus_dma_tag_t /*tag*/,
+			   bus_dmamap_t /*map*/);
+
+int	aic_dmamap_load(struct aic_softc *aic, bus_dma_tag_t /*dmat*/,
+			bus_dmamap_t /*map*/, void * /*buf*/,
+			bus_size_t /*buflen*/, bus_dmamap_callback_t *,
+			void */*callback_arg*/, int /*flags*/);
+
+int	aic_dmamap_unload(struct aic_softc *, bus_dma_tag_t, bus_dmamap_t);
+
+/*
+ * Operations performed by aic_dmamap_sync().
+ */
+#define BUS_DMASYNC_PREREAD	0x01	/* pre-read synchronization */
+#define BUS_DMASYNC_POSTREAD	0x02	/* post-read synchronization */
+#define BUS_DMASYNC_PREWRITE	0x04	/* pre-write synchronization */
+#define BUS_DMASYNC_POSTWRITE	0x08	/* post-write synchronization */
+
+/*
+ * XXX
+ * aic_dmamap_sync is only used on buffers allocated with
+ * the pci_alloc_consistent() API.  Although I'm not sure how
+ * this works on architectures with a write buffer, Linux does
+ * not have an API to sync "coherent" memory.  Perhaps we need
+ * to do an mb()?
+ */
+#define aic_dmamap_sync(aic, dma_tag, dmamap, offset, len, op)
+
+/*************************** Linux DMA Wrappers *******************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define	aic_alloc_coherent(aic, size, bus_addr_ptr) \
+	dma_alloc_coherent(aic->dev_softc, size, bus_addr_ptr, /*flag*/0)
+
+#define	aic_free_coherent(aic, size, vaddr, bus_addr) \
+	dma_free_coherent(aic->dev_softc, size, vaddr, bus_addr)
+
+#define	aic_map_single(aic, buf, size, direction) \
+	dma_map_single(aic->dev_softc, buf, size, direction)
+
+#define	aic_unmap_single(aic, busaddr, size, direction) \
+	dma_unmap_single(aic->dev_softc, busaddr, size, direction)
+
+#define	aic_map_sg(aic, sg_list, num_sg, direction) \
+	dma_map_sg(aic->dev_softc, sg_list, num_sg, direction)
+
+#define	aic_unmap_sg(aic, sg_list, num_sg, direction) \
+	dma_unmap_sg(aic->dev_softc, sg_list, num_sg, direction)
+
+#else /* LINUX_VERSION_CODE > KERNEL_VERSION(2,4,0) */
+
+#define	aic_alloc_coherent(aic, size, bus_addr_ptr) \
+	pci_alloc_consistent(aic->dev_softc, size, bus_addr_ptr)
+
+#define	aic_free_coherent(aic, size, vaddr, bus_addr) \
+	pci_free_consistent(aic->dev_softc, size, vaddr, bus_addr)
+
+#define	aic_map_single(aic, buf, size, direction) \
+	pci_map_single(aic->dev_softc, buf, size, direction)
+
+#define	aic_unmap_single(aic, busaddr, size, direction) \
+	pci_unmap_single(aic->dev_softc, busaddr, size, direction)
+
+#define	aic_map_sg(aic, sg_list, num_sg, direction) \
+	pci_map_sg(aic->dev_softc, sg_list, num_sg, direction)
+
+#define	aic_unmap_sg(aic, sg_list, num_sg, direction) \
+	pci_unmap_sg(aic->dev_softc, sg_list, num_sg, direction)
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,4,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+
+#define aic_set_dma_mask(aic, mask) dma_set_mask(aic->dev_softc, mask)
+#define aic_set_consistent_dma_mask(aic, mask) \
+	pci_set_consistent_dma_mask(aic_dev_to_pci_dev(aic->dev_softc), mask)
+
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
+
+/*
+ * Device softc is NULL for EISA devices.
+ */
+#define aic_set_dma_mask(aic, mask) 			\
+	((aic)->dev_softc == NULL ? 0 : pci_set_dma_mask(aic->dev_softc, mask))
+
+/* Always successfull in 2.4.X kernels */
+#define aic_set_consistent_dma_mask(aic, mask) (0)
+
+#else
+/*
+ * Device softc is NULL for EISA devices.
+ * Always "return" 0 for success.
+ */
+#define aic_set_dma_mask(aic, mask)			\
+    (((aic)->dev_softc == NULL)				\
+     ? 0						\
+     : (((aic)->dev_softc->dma_mask = mask) && 0))
+
+/* Always successfull in 2.4.X kernels */
+#define aic_set_consistent_dma_mask(aic, mask) (0)
+
+#endif
+
+/************************* Host Template Macros *******************************/
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) || defined(SCSI_HAS_HOST_LOCK))
+#define AIC_SCSI_HAS_HOST_LOCK 1
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define aic_assign_host_lock(aic)			\
+    scsi_assign_lock((aic)->platform_data->host,	\
+		     &(aic)->platform_data->spin_lock)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,21) \
+   && defined(AIC_RED_HAT_LINUX_KERNEL)
+#define aic_assign_host_lock(aic)				\
+do {								\
+        (aic)->platform_data->host->host_lock =			\
+		&(aic)->platform_data->spin_lock;		\
+} while (0)
+#else
+#define aic_assign_host_lock(aic)				\
+do {								\
+        (aic)->platform_data->host->lock =			\
+		&(aic)->platform_data->spin_lock;		\
+} while (0)
+#endif
+#else   /* !AIC_SCSI_HAS_HOST_LOCK */
+#define AIC_SCSI_HAS_HOST_LOCK 0
+#define aic_assign_host_lock(aic)
+#endif  /* !AIC_SCSI_HAS_HOST_LOCK */
+
+#if defined CONFIG_HIGHIO
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+/* Assume RedHat Distribution with its different HIGHIO conventions. */
+#define	AIC_TEMPLATE_DMA_SETTINGS()	\
+	.can_dma_32		= 1,	\
+	.single_sg_okay		= 1,
+#else
+#define	AIC_TEMPLATE_DMA_SETTINGS()	\
+	.highmem_io		= 1,
+#endif
+#else
+#define	AIC_TEMPLATE_DMA_SETTINGS()
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,7)
+#define	AIC_TEMPLATE_MAX_SECTORS(sectors) \
+	.max_sectors		= (sectors),
+#else
+#define	AIC_TEMPLATE_MAX_SECTORS(sectors)
+#endif
+
+#if defined(__i386__)
+#define	AIC_TEMPLATE_BIOSPARAM() \
+	.bios_param		= AIC_LIB_ENTRY(_linux_biosparam),
+#else
+#define	AIC_TEMPLATE_BIOSPARAM()
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define	AIC_TEMPLATE_VERSIONED_ENTRIES() \
+	.slave_alloc		= AIC_LIB_ENTRY(_linux_slave_alloc), \
+	.slave_configure	= AIC_LIB_ENTRY(_linux_slave_configure), \
+	.slave_destroy		= AIC_LIB_ENTRY(_linux_slave_destroy)
+#else
+#define	AIC_TEMPLATE_VERSIONED_ENTRIES() \
+	.detect			= AIC_LIB_ENTRY(_linux_detect), \
+	.release		= AIC_LIB_ENTRY(_linux_release), \
+	.select_queue_depths	= AIC_LIB_ENTRY(_linux_select_queue_depth), \
+	.use_new_eh_code	= 1
+#endif
+
+#define AIC_TEMPLATE_INITIALIZER(NAME, MAX_SECTORS)			\
+{									\
+	.module			= THIS_MODULE,				\
+	.name			= NAME,					\
+	.proc_info		= AIC_LIB_ENTRY(_linux_proc_info),	\
+	.info			= AIC_LIB_ENTRY(_linux_info),		\
+	.queuecommand		= AIC_LIB_ENTRY(_linux_queue),		\
+	.eh_abort_handler	= AIC_LIB_ENTRY(_linux_abort),		\
+	.eh_device_reset_handler = AIC_LIB_ENTRY(_linux_dev_reset),	\
+	.eh_bus_reset_handler	= AIC_LIB_ENTRY(_linux_bus_reset),	\
+	.can_queue		= AIC_CONST_ENTRY(_MAX_QUEUE),		\
+	.this_id		= -1,					\
+	.cmd_per_lun		= 2,					\
+	.use_clustering		= ENABLE_CLUSTERING,			\
+	AIC_TEMPLATE_MAX_SECTORS(MAX_SECTORS)				\
+	AIC_TEMPLATE_DMA_SETTINGS()					\
+	AIC_TEMPLATE_BIOSPARAM()					\
+	AIC_TEMPLATE_VERSIONED_ENTRIES()				\
+}
+
+/************************** OS Utility Wrappers *******************************/
+#define printf printk
+#define M_NOWAIT GFP_ATOMIC
+#define M_WAITOK 0
+#define malloc(size, type, flags) kmalloc(size, flags)
+#define free(ptr, type) kfree(ptr)
+
+static __inline void aic_delay(long);
+static __inline void
+aic_delay(long usec)
+{
+	/*
+	 * udelay on Linux can have problems for
+	 * multi-millisecond waits.  Wait at most
+	 * 1024us per call.
+	 */
+	while (usec > 0) {
+		udelay(usec % 1024);
+		usec -= 1024;
+	}
+}
+
+/********************************** Misc Macros *******************************/
+#define	roundup(x, y)   ((((x)+((y)-1))/(y))*(y))
+#define	powerof2(x)	((((x)-1)&(x))==0)
+
+/******************************* Byte Order ***********************************/
+#define aic_htobe16(x)	cpu_to_be16(x)
+#define aic_htobe32(x)	cpu_to_be32(x)
+#define aic_htobe64(x)	cpu_to_be64(x)
+#define aic_htole16(x)	cpu_to_le16(x)
+#define aic_htole32(x)	cpu_to_le32(x)
+#define aic_htole64(x)	cpu_to_le64(x)
+
+#define aic_be16toh(x)	be16_to_cpu(x)
+#define aic_be32toh(x)	be32_to_cpu(x)
+#define aic_be64toh(x)	be64_to_cpu(x)
+#define aic_le16toh(x)	le16_to_cpu(x)
+#define aic_le32toh(x)	le32_to_cpu(x)
+#define aic_le64toh(x)	le64_to_cpu(x)
+
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+
+#ifndef BYTE_ORDER
+#if defined(__BIG_ENDIAN)
+#define BYTE_ORDER BIG_ENDIAN
+#endif
+#if defined(__LITTLE_ENDIAN)
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+#endif /* BYTE_ORDER */
+
+/********************************* Core Includes ******************************/
+#include AIC_CORE_INCLUDE
+
+/**************************** Front End Queues ********************************/
+/*
+ * Data structure used to cast the Linux struct scsi_cmnd to something
+ * that allows us to use the queue macros.  The linux structure has
+ * plenty of space to hold the links fields as required by the queue
+ * macros, but the queue macors require them to have the correct type.
+ */
+struct aic_cmd_internal {
+	/* Area owned by the Linux scsi layer. */
+	uint8_t	private[offsetof(struct scsi_cmnd, SCp.Status)];
+	union {
+		STAILQ_ENTRY(aic_cmd)	ste;
+		LIST_ENTRY(aic_cmd)	le;
+		TAILQ_ENTRY(aic_cmd)	tqe;
+	} links;
+	uint32_t			end;
+};
+
+struct aic_cmd {
+	union {
+		struct aic_cmd_internal	icmd;
+		struct scsi_cmnd	scsi_cmd;
+	} un;
+};
+
+#define acmd_icmd(cmd) ((cmd)->un.icmd)
+#define acmd_scsi_cmd(cmd) ((cmd)->un.scsi_cmd)
+#define acmd_links un.icmd.links
+
+/*************************** Device Data Structures ***************************/
+/*
+ * A per probed device structure used to deal with some error recovery
+ * scenarios that the Linux mid-layer code just doesn't know how to
+ * handle.  The structure allocated for a device only becomes persistent
+ * after a successfully completed inquiry command to the target when
+ * that inquiry data indicates a lun is present.
+ */
+TAILQ_HEAD(aic_busyq, aic_cmd);
+typedef enum {
+	AIC_DEV_UNCONFIGURED	 = 0x01,
+	AIC_DEV_FREEZE_TIL_EMPTY = 0x02, /* Freeze queue until active == 0 */
+	AIC_DEV_TIMER_ACTIVE	 = 0x04, /* Our timer is active */
+	AIC_DEV_ON_RUN_LIST	 = 0x08, /* Queued to be run later */
+	AIC_DEV_Q_BASIC		 = 0x10, /* Allow basic device queuing */
+	AIC_DEV_Q_TAGGED	 = 0x20, /* Allow full SCSI2 command queueing */
+	AIC_DEV_PERIODIC_OTAG	 = 0x40, /* Send OTAG to prevent starvation */
+	AIC_DEV_SLAVE_CONFIGURED = 0x80	 /* slave_configure() has been called */
+} aic_linux_dev_flags;
+
+struct aic_linux_target;
+struct aic_linux_device {
+	TAILQ_ENTRY(aic_linux_device) links;
+	struct			aic_busyq busyq;
+
+	/*
+	 * The number of transactions currently
+	 * queued to the device.
+	 */
+	int			active;
+
+	/*
+	 * The currently allowed number of 
+	 * transactions that can be queued to
+	 * the device.  Must be signed for
+	 * conversion from tagged to untagged
+	 * mode where the device may have more
+	 * than one outstanding active transaction.
+	 */
+	int			openings;
+
+	/*
+	 * A positive count indicates that this
+	 * device's queue is halted.
+	 */
+	u_int			qfrozen;
+	
+	/*
+	 * Cumulative command counter.
+	 */
+	u_long			commands_issued;
+
+	/*
+	 * The number of tagged transactions when
+	 * running at our current opening level
+	 * that have been successfully received by
+	 * this device since the last QUEUE FULL.
+	 */
+	u_int			tag_success_count;
+#define AIC_TAG_SUCCESS_INTERVAL 50
+
+	aic_linux_dev_flags	flags;
+
+	/*
+	 * Per device timer.
+	 */
+	struct timer_list	timer;
+
+	/*
+	 * The high limit for the tags variable.
+	 */
+	u_int			maxtags;
+
+	/*
+	 * The computed number of tags outstanding
+	 * at the time of the last QUEUE FULL event.
+	 */
+	u_int			tags_on_last_queuefull;
+
+	/*
+	 * How many times we have seen a queue full
+	 * with the same number of tags.  This is used
+	 * to stop our adaptive queue depth algorithm
+	 * on devices with a fixed number of tags.
+	 */
+	u_int			last_queuefull_same_count;
+#define AIC_LOCK_TAGS_COUNT 50
+
+	/*
+	 * How many transactions have been queued
+	 * without the device going idle.  We use
+	 * this statistic to determine when to issue
+	 * an ordered tag to prevent transaction
+	 * starvation.  This statistic is only updated
+	 * if the AIC_DEV_PERIODIC_OTAG flag is set
+	 * on this device.
+	 */
+	u_int			commands_since_idle_or_otag;
+#define AIC_OTAG_THRESH	500
+
+	int			lun;
+	Scsi_Device	       *scsi_device;
+	struct			aic_linux_target *target;
+};
+
+typedef enum {
+	AIC_DV_REQUIRED		 = 0x01,
+	AIC_INQ_VALID		 = 0x02,
+	AIC_BASIC_DV		 = 0x04,
+	AIC_ENHANCED_DV		 = 0x08,
+	AIC_TARG_TIMER_ACTIVE	 = 0x10
+} aic_linux_targ_flags;
+
+/* DV States */
+typedef enum {
+	AIC_DV_STATE_EXIT = 0,
+	AIC_DV_STATE_INQ_SHORT_ASYNC,
+	AIC_DV_STATE_INQ_ASYNC,
+	AIC_DV_STATE_INQ_ASYNC_VERIFY,
+	AIC_DV_STATE_TUR,
+	AIC_DV_STATE_REBD,
+	AIC_DV_STATE_INQ_VERIFY,
+	AIC_DV_STATE_WEB,
+	AIC_DV_STATE_REB,
+	AIC_DV_STATE_SU,
+	AIC_DV_STATE_BUSY
+} aic_dv_state;
+
+struct aic_linux_target {
+	/*
+	 * A positive count indicates that this
+	 * target's queue is halted.
+	 */
+	u_int			  qfrozen;
+
+	struct aic_linux_device	 *devices[AIC_NUM_LUNS];
+	int			  channel;
+	int			  target;
+	int			  refcount;
+	struct aic_transinfo	  last_tinfo;
+	struct aic_softc	 *softc;
+	aic_linux_targ_flags	  flags;
+	struct scsi_inquiry_data *inq_data;
+	/*
+	 * Per target timer.
+	 */
+	struct timer_list	timer;
+
+	/*
+	 * The next "fallback" period to use for narrow/wide transfers.
+	 */
+	uint8_t			  dv_next_narrow_period;
+	uint8_t			  dv_next_wide_period;
+	uint8_t			  dv_max_width;
+	uint8_t			  dv_max_ppr_options;
+	uint8_t			  dv_last_ppr_options;
+	u_int			  dv_echo_size;
+	aic_dv_state		  dv_state;
+	u_int			  dv_state_retry;
+	uint8_t			 *dv_buffer;
+	uint8_t			 *dv_buffer1;
+
+	/*
+	 * Cumulative counter of errors.
+	 */
+	u_long			errors_detected;
+	u_long			cmds_since_error;
+};
+
+/*************** OSM Dependent Components of Core Datastructures **************/
+/*
+ * Per-SCB OSM storage.
+ */
+typedef enum {
+	AIC_SCB_UP_EH_SEM	= 0x1,
+	AIC_TIMEOUT_ACTIVE	= 0x2,
+	AIC_RELEASE_SIMQ	= 0x4
+} aic_linux_scb_flags;
+
+struct scb_platform_data {
+	struct aic_linux_device	*dev;
+	bus_addr_t		 buf_busaddr;
+	uint32_t		 xfer_len;
+	uint32_t		 sense_resid;	/* Auto-Sense residual */
+	aic_linux_scb_flags	 flags;
+};
+
+/*
+ * Define a structure used for each host adapter.  All members are
+ * aligned on a boundary >= the size of the member to honor the
+ * alignment restrictions of the various platforms supported by
+ * this driver.
+ */
+typedef enum {
+	AIC_DV_WAIT_SIMQ_EMPTY	 = 0x01,
+	AIC_DV_WAIT_SIMQ_RELEASE = 0x02,
+	AIC_DV_ACTIVE		 = 0x04,
+	AIC_DV_SHUTDOWN		 = 0x08,
+	AIC_RUN_CMPLT_Q_TIMER	 = 0x10,
+	AIC_BUS_SETTLE_TIMER	 = 0x20
+} aic_linux_softc_flags;
+
+TAILQ_HEAD(aic_completeq, aic_cmd);
+
+struct aic_platform_data {
+	/*
+	 * Fields accessed from interrupt context.
+	 */
+	struct aic_linux_target *targets[AIC_NUM_TARGETS]; 
+	TAILQ_HEAD(, aic_linux_device) device_runq;
+	struct aic_completeq	 completeq;
+
+	spinlock_t		 spin_lock;
+	struct tasklet_struct	 runq_tasklet;
+	struct tasklet_struct	 unblock_tasklet;
+	u_int			 qfrozen;
+	pid_t			 dv_pid;
+	pid_t			 recovery_pid;
+	struct timer_list	 completeq_timer;
+	struct timer_list	 bus_settle_timer;
+	struct timer_list	 stats_timer;
+	struct semaphore	 eh_sem;
+	struct semaphore	 dv_sem;
+	struct semaphore	 dv_cmd_sem;
+	struct semaphore	 recovery_sem;
+	struct semaphore	 recovery_ending_sem;
+	struct scsi_device	*dv_scsi_dev;
+	struct Scsi_Host        *host;		/* pointer to scsi host */
+#define AIC_LINUX_NOIRQ	((uint32_t)~0)
+	uint32_t		 irq;		/* IRQ for this adapter */
+	uint32_t		 bios_address;
+	uint32_t		 mem_busaddr;	/* Mem Base Addr */
+	bus_addr_t		 hw_dma_mask;
+	aic_linux_softc_flags	 flags;
+};
+
+/******************************** Locking *************************************/
+/* Lock protecting internal data structures */
+static __inline void aic_lockinit(struct aic_softc *);
+static __inline void aic_lock(struct aic_softc *, unsigned long *flags);
+static __inline void aic_unlock(struct aic_softc *, unsigned long *flags);
+
+/* Lock acquisition and release of the above lock in midlayer entry points. */
+static __inline void aic_entrypoint_lock(struct aic_softc *,
+					 unsigned long *flags);
+static __inline void aic_entrypoint_unlock(struct aic_softc *,
+					   unsigned long *flags);
+
+/* Lock held during aic_list manipulation and aic softc frees */
+extern spinlock_t aic_list_spinlock;
+static __inline void aic_list_lockinit(void);
+static __inline void aic_list_lock(unsigned long *flags);
+static __inline void aic_list_unlock(unsigned long *flags);
+
+static __inline void
+aic_lockinit(struct aic_softc *aic)
+{
+	spin_lock_init(&aic->platform_data->spin_lock);
+}
+
+static __inline void
+aic_lock(struct aic_softc *aic, unsigned long *flags)
+{
+	spin_lock_irqsave(&aic->platform_data->spin_lock, *flags);
+}
+
+static __inline void
+aic_unlock(struct aic_softc *aic, unsigned long *flags)
+{
+	spin_unlock_irqrestore(&aic->platform_data->spin_lock, *flags);
+}
+
+static __inline void
+aic_entrypoint_lock(struct aic_softc *aic, unsigned long *flags)
+{
+	/*
+	 * In 2.5.X and some 2.4.X versions, the midlayer takes our
+	 * lock just before calling us, so we avoid locking again.
+	 * For other kernel versions, the io_request_lock is taken
+	 * just before our entry point is called.  In this case, we
+	 * trade the io_request_lock for our per-softc lock.
+	 */
+#if AIC_SCSI_HAS_HOST_LOCK == 0
+	spin_unlock(&io_request_lock);
+	spin_lock(&aic->platform_data->spin_lock);
+#endif
+}
+
+static __inline void
+aic_entrypoint_unlock(struct aic_softc *aic, unsigned long *flags)
+{
+#if AIC_SCSI_HAS_HOST_LOCK == 0
+	spin_unlock(&aic->platform_data->spin_lock);
+	spin_lock(&io_request_lock);
+#endif
+}
+
+static __inline void
+aic_list_lockinit(void)
+{
+	spin_lock_init(&aic_list_spinlock);
+}
+
+static __inline void
+aic_list_lock(unsigned long *flags)
+{
+	spin_lock_irqsave(&aic_list_spinlock, *flags);
+}
+
+static __inline void
+aic_list_unlock(unsigned long *flags)
+{
+	spin_unlock_irqrestore(&aic_list_spinlock, *flags);
+}
+
+/***************************** Timer Facilities *******************************/
+typedef void aic_linux_callback_t (u_long);  
+void aic_platform_timeout(struct scsi_cmnd *);
+void aic_linux_midlayer_timeout(struct scsi_cmnd *);
+
+#define aic_timer_init init_timer
+#define aic_timer_stop del_timer_sync
+static __inline void aic_timer_reset(aic_timer_t *timer, uint32_t usec,
+				     aic_callback_t *func, void *arg);
+static __inline uint32_t aic_get_timeout(struct scb *);
+static __inline void aic_scb_timer_start(struct scb *scb);
+static __inline void aic_scb_timer_reset(struct scb *scb, uint32_t usec);
+
+static __inline void
+aic_timer_reset(aic_timer_t *timer, uint32_t usec,
+		aic_callback_t *func, void *arg)
+{
+	struct aic_softc *aic;
+
+	aic = (struct aic_softc *)arg;
+	del_timer(timer);
+	timer->data = (u_long)arg;
+	timer->expires = jiffies + (usec / AIC_USECS_PER_JIFFY);
+	timer->function = (aic_linux_callback_t*)func;
+	add_timer(timer);
+}
+
+static __inline uint32_t
+aic_get_timeout(struct scb *scb)
+{
+
+	/*
+	 * Convert from jiffies to usec.
+	 */
+	return (scb->io_ctx->timeout_per_command * AIC_USECS_PER_JIFFY);
+}
+
+static __inline void
+aic_scb_timer_start(struct scb *scb)
+{
+	scb->platform_data->flags |= AIC_TIMEOUT_ACTIVE;
+	scsi_add_timer(scb->io_ctx, scb->io_ctx->timeout_per_command,
+		       aic_platform_timeout);
+}
+
+static __inline void
+aic_scb_timer_reset(struct scb *scb, uint32_t usec)
+{
+	/*
+	 * Restore timer data that is clobbered by scsi_delete_timer().
+	 */
+	scb->io_ctx->eh_timeout.data = (unsigned long)scb->io_ctx;
+	scb->io_ctx->eh_timeout.function =
+	    (void (*)(unsigned long))aic_platform_timeout;
+	scb->platform_data->flags |= AIC_TIMEOUT_ACTIVE;
+	mod_timer(&scb->io_ctx->eh_timeout,
+		  jiffies + (usec / AIC_USECS_PER_JIFFY));
+}
+
+/************************* SCSI command formats *******************************/
 /*
  * Define dome bits that are in ALL (or a lot of) scsi commands
  */
@@ -865,6 +1710,183 @@ typedef enum {
 
 extern const char *scsi_sense_key_text[];
 
+/*************************** Domain Validation ********************************/
+#define AIC_DV_CMD(cmd) ((cmd)->scsi_done == aic_linux_dv_complete)
+#define AIC_DV_SIMQ_FROZEN(aic)					\
+	((((aic)->platform_data->flags & AIC_DV_ACTIVE) != 0)	\
+	 && (aic)->platform_data->qfrozen == 1)
+
+/******************************* PCI Definitions ******************************/
+/*
+ * PCIM_xxx: mask to locate subfield in register
+ * PCIR_xxx: config register offset
+ * PCIC_xxx: device class
+ * PCIS_xxx: device subclass
+ * PCIP_xxx: device programming interface
+ * PCIV_xxx: PCI vendor ID (only required to fixup ancient devices)
+ * PCID_xxx: device ID
+ */
+#define PCIR_DEVVENDOR		0x00
+#define PCIR_VENDOR		0x00
+#define PCIR_DEVICE		0x02
+#define PCIR_COMMAND		0x04
+#define PCIM_CMD_PORTEN		0x0001
+#define PCIM_CMD_MEMEN		0x0002
+#define PCIM_CMD_BUSMASTEREN	0x0004
+#define PCIM_CMD_MWRICEN	0x0010
+#define PCIM_CMD_PERRESPEN	0x0040
+#define	PCIM_CMD_SERRESPEN	0x0100
+#define PCIR_STATUS		0x06
+#define PCIR_REVID		0x08
+#define PCIR_PROGIF		0x09
+#define PCIR_SUBCLASS		0x0a
+#define PCIR_CLASS		0x0b
+#define PCIR_CACHELNSZ		0x0c
+#define PCIR_LATTIMER		0x0d
+#define PCIR_HEADERTYPE		0x0e
+#define PCIM_MFDEV		0x80
+#define PCIR_BIST		0x0f
+#define PCIR_CAP_PTR		0x34
+
+/* config registers for header type 0 devices */
+#define PCIR_MAPS	0x10
+#define PCIR_BARS	PCIR_MAPS
+#define PCIR_BAR(x)	(PCIR_BARS + (x) * 4)
+#define PCIR_SUBVEND_0	0x2c
+#define PCIR_SUBDEV_0	0x2e
+
+typedef enum
+{
+	AIC_POWER_STATE_D0,
+	AIC_POWER_STATE_D1,
+	AIC_POWER_STATE_D2,
+	AIC_POWER_STATE_D3
+} aic_power_state;
+
+/****************************** PCI-X definitions *****************************/
+#define PCIXR_COMMAND	0x96
+#define PCIXR_DEVADDR	0x98
+#define PCIXM_DEVADDR_FNUM	0x0003	/* Function Number */
+#define PCIXM_DEVADDR_DNUM	0x00F8	/* Device Number */
+#define PCIXM_DEVADDR_BNUM	0xFF00	/* Bus Number */
+#define PCIXR_STATUS	0x9A
+#define PCIXM_STATUS_64BIT	0x0001	/* Active 64bit connection to device. */
+#define PCIXM_STATUS_133CAP	0x0002	/* Device is 133MHz capable */
+#define PCIXM_STATUS_SCDISC	0x0004	/* Split Completion Discarded */
+#define PCIXM_STATUS_UNEXPSC	0x0008	/* Unexpected Split Completion */
+#define PCIXM_STATUS_CMPLEXDEV	0x0010	/* Device Complexity (set == bridge) */
+#define PCIXM_STATUS_MAXMRDBC	0x0060	/* Maximum Burst Read Count */
+#define PCIXM_STATUS_MAXSPLITS	0x0380	/* Maximum Split Transactions */
+#define PCIXM_STATUS_MAXCRDS	0x1C00	/* Maximum Cumulative Read Size */
+#define PCIXM_STATUS_RCVDSCEM	0x2000	/* Received a Split Comp w/Error msg */
+
+/**************************** KObject Wrappers ********************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define	aic_dev_to_pci_dev(dev)		to_pci_dev(dev)
+#define	aic_dev_to_eisa_dev(dev)	to_eisa_dev(dev)
+#define	aic_pci_dev_to_dev(pci)		(&pci->dev)
+#define	aic_eisa_dev_to_dev(eisa)	(&eisa->dev)
+#else
+#define	aic_dev_to_pci_dev(dev)		(dev)
+#define	aic_dev_to_eisa_dev(dev)	(NULL)
+#define	aic_pci_dev_to_dev(pci)		(pci)
+#define	aic_eisa_dev_to_dev(eisa)	(NULL)
+#endif
+
+#define	aic_pci_dev(aic)		aic_dev_to_pci_dev((aic)->dev_softc)
+#define	aic_eisa_dev(aic)		aic_dev_to_eisa_dev((aic)->dev_softc)
+/***************************** PCI Routines ***********************************/
+static __inline uint32_t aic_pci_read_config(aic_dev_softc_t dev,
+					     int reg, int width);
+static __inline void aic_pci_write_config(aic_dev_softc_t dev,
+					  int reg, uint32_t value,
+					  int width);
+static __inline int aic_get_pci_function(aic_dev_softc_t);
+static __inline int aic_get_pci_slot(aic_dev_softc_t);
+static __inline int aic_get_pci_bus(aic_dev_softc_t);
+
+static __inline uint32_t
+aic_pci_read_config(aic_dev_softc_t dev, int reg, int width)
+{
+	struct pci_dev *pci;
+
+	pci = aic_dev_to_pci_dev(dev);
+	switch (width) {
+	case 1:
+	{
+		uint8_t retval;
+
+		pci_read_config_byte(pci, reg, &retval);
+		return (retval);
+	}
+	case 2:
+	{
+		uint16_t retval;
+		pci_read_config_word(pci, reg, &retval);
+		return (retval);
+	}
+	case 4:
+	{
+		uint32_t retval;
+		pci_read_config_dword(pci, reg, &retval);
+		return (retval);
+	}
+	default:
+		panic("aic_pci_read_config: Read size too big");
+		/* NOTREACHED */
+		return (0);
+	}
+}
+
+static __inline void
+aic_pci_write_config(aic_dev_softc_t dev, int reg, uint32_t value, int width)
+{
+	struct pci_dev *pci;
+
+	pci = aic_dev_to_pci_dev(dev);
+	switch (width) {
+	case 1:
+		pci_write_config_byte(pci, reg, value);
+		break;
+	case 2:
+		pci_write_config_word(pci, reg, value);
+		break;
+	case 4:
+		pci_write_config_dword(pci, reg, value);
+		break;
+	default:
+		panic("aic_pci_write_config: Write size too big");
+		/* NOTREACHED */
+	}
+}
+
+static __inline int
+aic_get_pci_function(aic_dev_softc_t dev)
+{
+	struct pci_dev *pci;
+
+	pci = aic_dev_to_pci_dev(dev);
+	return (PCI_FUNC(pci->devfn));
+}
+
+static __inline int
+aic_get_pci_slot(aic_dev_softc_t dev)
+{
+	struct pci_dev *pci;
+
+	pci = aic_dev_to_pci_dev(dev);
+	return (PCI_SLOT(pci->devfn));
+}
+
+static __inline int
+aic_get_pci_bus(aic_dev_softc_t dev)
+{
+	struct pci_dev *pci;
+
+	pci = aic_dev_to_pci_dev(dev);
+	return (pci->bus->number);
+}
+
 /************************* Large Disk Handling ********************************/
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 static __inline int aic_sector_div(u_long capacity, int heads, int sectors);
@@ -886,34 +1908,31 @@ aic_sector_div(sector_t capacity, int he
 }
 #endif
 
-/**************************** Module Library Hack *****************************/
-/*
- * What we'd like to do is have a single "scsi library" module that both the
- * aic7xxx and aic79xx drivers could load and depend on.  A cursory examination
- * of implementing module dependencies in Linux (handling the install and
- * initrd cases) does not look promissing.  For now, we just duplicate this
- * code in both drivers using a simple symbol renaming scheme that hides this
- * hack from the drivers.
- */
-#define AIC_LIB_ENTRY_CONCAT(x, prefix)	prefix ## x
-#define	AIC_LIB_ENTRY_EXPAND(x, prefix) AIC_LIB_ENTRY_CONCAT(x, prefix)
-#define AIC_LIB_ENTRY(x)		AIC_LIB_ENTRY_EXPAND(x, AIC_LIB_PREFIX)
+/************************* Magic SysReq Support *******************************/
+#include <linux/sysrq.h>
 
-#define	aic_sense_desc			AIC_LIB_ENTRY(_sense_desc)
-#define	aic_sense_error_action		AIC_LIB_ENTRY(_sense_error_action)
-#define	aic_error_action		AIC_LIB_ENTRY(_error_action)
-#define	aic_op_desc			AIC_LIB_ENTRY(_op_desc)
-#define	aic_cdb_string			AIC_LIB_ENTRY(_cdb_string)
-#define aic_print_inquiry		AIC_LIB_ENTRY(_print_inquiry)
-#define aic_calc_syncsrate		AIC_LIB_ENTRY(_calc_syncrate)
-#define	aic_calc_syncparam		AIC_LIB_ENTRY(_calc_syncparam)
-#define	aic_calc_speed			AIC_LIB_ENTRY(_calc_speed)
-#define	aic_inquiry_match		AIC_LIB_ENTRY(_inquiry_match)
-#define	aic_static_inquiry_match	AIC_LIB_ENTRY(_static_inquiry_match)
-#define	aic_parse_brace_option		AIC_LIB_ENTRY(_parse_brace_option)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+typedef void aic_sysrq_handler_t (int, struct pt_regs *, struct kbd_struct *,
+				  struct tty_struct *);
+#else
+typedef void aic_sysrq_handler_t (int, struct pt_regs *, struct tty_struct *);
+#endif
 
-/******************************************************************************/
+#ifdef CONFIG_MAGIC_SYSRQ
+#define	aic_sysrq_key_op sysrq_key_op
+#else
+struct aic_sysrq_key_op {
+	aic_sysrq_handler_t *handler;
+	char *help_msg;
+	char *action_msg;
+};
+#endif
 
+aic_sysrq_handler_t	aic_sysrq_handler;
+int			aic_install_sysrq(struct aic_sysrq_key_op *);
+void			aic_remove_sysrq(int key,
+					 struct aic_sysrq_key_op *key_op);
+/************************ SCSI Library Functions *****************************/
 void			aic_sense_desc(int /*sense_key*/, int /*asc*/,
 				       int /*ascq*/, struct scsi_inquiry_data*,
 				       const char** /*sense_key_desc*/,
@@ -1043,4 +2062,279 @@ scsi_4btoul(uint8_t *bytes)
 	return (rv);
 }
 
+/******************************* PCI Funcitons ********************************/
+void aic_power_state_change(struct aic_softc *aic, aic_power_state new_state);
+
+/******************************* Queue Handling *******************************/
+void		     aic_runq_tasklet(unsigned long data);
+void		     aic_unblock_tasklet(unsigned long data);
+void		     aic_linux_run_device_queue(struct aic_softc*,
+						struct aic_linux_device*);
+void		     aic_bus_settle_complete(u_long data);
+void		     aic_freeze_simq(struct aic_softc *aic);
+void		     aic_release_simq(struct aic_softc *aic);
+void		     aic_release_simq_locked(struct aic_softc *aic);
+static __inline void aic_schedule_runq(struct aic_softc *aic);
+static __inline void aic_schedule_unblock(struct aic_softc *aic);
+static __inline struct aic_linux_device *
+		     aic_linux_next_device_to_run(struct aic_softc *aic);
+static __inline void aic_linux_check_device_queue(struct aic_softc *aic,
+						  struct aic_linux_device *dev);
+static __inline void aic_linux_run_device_queues(struct aic_softc *aic);
+
+/*
+ * Must be called with our lock held.
+ */
+static __inline void
+aic_schedule_runq(struct aic_softc *aic)
+{
+	tasklet_schedule(&aic->platform_data->runq_tasklet);
+}
+
+static __inline void
+aic_schedule_unblock(struct aic_softc *aic)
+{
+	tasklet_schedule(&aic->platform_data->unblock_tasklet);
+}
+
+static __inline struct aic_linux_device *
+aic_linux_next_device_to_run(struct aic_softc *aic)
+{
+	
+	if (aic->platform_data->qfrozen != 0
+	 && AIC_DV_SIMQ_FROZEN(aic) == 0)
+		return (NULL);
+	return (TAILQ_FIRST(&aic->platform_data->device_runq));
+}
+
+static __inline void
+aic_linux_check_device_queue(struct aic_softc *aic,
+			     struct aic_linux_device *dev)
+{
+	if ((dev->flags & AIC_DEV_FREEZE_TIL_EMPTY) != 0
+	 && dev->active == 0) {
+		dev->flags &= ~AIC_DEV_FREEZE_TIL_EMPTY;
+		dev->qfrozen--;
+	}
+
+	if (TAILQ_FIRST(&dev->busyq) == NULL
+	 || dev->openings == 0 || dev->qfrozen != 0
+	 || dev->target->qfrozen != 0)
+		return;
+
+	aic_linux_run_device_queue(aic, dev);
+}
+
+static __inline void
+aic_linux_run_device_queues(struct aic_softc *aic)
+{
+	struct aic_linux_device *dev;
+
+	while ((dev = aic_linux_next_device_to_run(aic)) != NULL) {
+		TAILQ_REMOVE(&aic->platform_data->device_runq, dev, links);
+		dev->flags &= ~AIC_DEV_ON_RUN_LIST;
+		aic_linux_check_device_queue(aic, dev);
+	}
+}
+
+/****************************** Tasklet Support *******************************/
+static __inline void	aic_setup_tasklets(struct aic_softc *aic);
+static __inline void	aic_teardown_tasklets(struct aic_softc *aic);
+
+static __inline void
+aic_setup_tasklets(struct aic_softc *aic)
+{
+	tasklet_init(&aic->platform_data->runq_tasklet, aic_runq_tasklet,
+		     (unsigned long)aic);
+	tasklet_init(&aic->platform_data->unblock_tasklet, aic_unblock_tasklet,
+		     (unsigned long)aic);
+}
+
+static __inline void
+aic_teardown_tasklets(struct aic_softc *aic)
+{
+	tasklet_kill(&aic->platform_data->runq_tasklet);
+	tasklet_kill(&aic->platform_data->unblock_tasklet);
+}
+
+/*********************** Transaction Access Wrappers **************************/
+static __inline void aic_cmd_set_transaction_status(Scsi_Cmnd *, uint32_t);
+static __inline void aic_set_transaction_status(struct scb *, uint32_t);
+static __inline void aic_cmd_set_scsi_status(Scsi_Cmnd *, uint32_t);
+static __inline void aic_set_scsi_status(struct scb *, uint32_t);
+static __inline uint32_t aic_cmd_get_transaction_status(Scsi_Cmnd *cmd);
+static __inline uint32_t aic_get_transaction_status(struct scb *);
+static __inline uint32_t aic_cmd_get_scsi_status(Scsi_Cmnd *cmd);
+static __inline uint32_t aic_get_scsi_status(struct scb *);
+static __inline void aic_set_transaction_tag(struct scb *, int, u_int);
+static __inline u_long aic_get_transfer_length(struct scb *);
+static __inline int aic_get_transfer_dir(struct scb *);
+static __inline void aic_set_residual(struct scb *, u_long);
+static __inline void aic_set_sense_residual(struct scb *scb, u_long resid);
+static __inline u_long aic_get_residual(struct scb *);
+static __inline u_long aic_get_sense_residual(struct scb *);
+static __inline int aic_perform_autosense(struct scb *);
+static __inline uint32_t aic_get_sense_bufsize(struct aic_softc *,
+					       struct scb *);
+static __inline void aic_notify_xfer_settings_change(struct aic_softc *,
+						     struct aic_devinfo *);
+static __inline void aic_platform_scb_free(struct aic_softc *aic,
+					   struct scb *scb);
+static __inline void aic_freeze_scb(struct scb *scb);
+
+static __inline
+void aic_cmd_set_transaction_status(Scsi_Cmnd *cmd, uint32_t status)
+{
+	cmd->result &= ~(CAM_STATUS_MASK << 16);
+	cmd->result |= status << 16;
+}
+
+static __inline
+void aic_set_transaction_status(struct scb *scb, uint32_t status)
+{
+	aic_cmd_set_transaction_status(scb->io_ctx,status);
+}
+
+static __inline
+void aic_cmd_set_scsi_status(Scsi_Cmnd *cmd, uint32_t status)
+{
+	cmd->result &= ~0xFFFF;
+	cmd->result |= status;
+}
+
+static __inline
+void aic_set_scsi_status(struct scb *scb, uint32_t status)
+{
+	aic_cmd_set_scsi_status(scb->io_ctx, status);
+}
+
+static __inline
+uint32_t aic_cmd_get_transaction_status(Scsi_Cmnd *cmd)
+{
+	return ((cmd->result >> 16) & CAM_STATUS_MASK);
+}
+
+static __inline
+uint32_t aic_get_transaction_status(struct scb *scb)
+{
+	return (aic_cmd_get_transaction_status(scb->io_ctx));
+}
+
+static __inline
+uint32_t aic_cmd_get_scsi_status(Scsi_Cmnd *cmd)
+{
+	return (cmd->result & 0xFFFF);
+}
+
+static __inline
+uint32_t aic_get_scsi_status(struct scb *scb)
+{
+	return (aic_cmd_get_scsi_status(scb->io_ctx));
+}
+
+static __inline
+void aic_set_transaction_tag(struct scb *scb, int enabled, u_int type)
+{
+	/*
+	 * Nothing to do for linux as the incoming transaction
+	 * has no concept of tag/non tagged, etc.
+	 */
+}
+
+static __inline
+u_long aic_get_transfer_length(struct scb *scb)
+{
+	return (scb->platform_data->xfer_len);
+}
+
+static __inline
+int aic_get_transfer_dir(struct scb *scb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,40)
+	return (scb->io_ctx->sc_data_direction);
+#else
+	if (scb->io_ctx->bufflen == 0)
+		return (CAM_DIR_NONE);
+
+	switch(scb->io_ctx->cmnd[0]) {
+	case 0x08:  /* READ(6)  */
+	case 0x28:  /* READ(10) */
+	case 0xA8:  /* READ(12) */
+		return (CAM_DIR_IN);
+        case 0x0A:  /* WRITE(6)  */
+        case 0x2A:  /* WRITE(10) */
+        case 0xAA:  /* WRITE(12) */
+		return (CAM_DIR_OUT);
+        default:
+		return (CAM_DIR_NONE);
+        }
+#endif
+}
+
+static __inline
+void aic_set_residual(struct scb *scb, u_long resid)
+{
+	scb->io_ctx->resid = resid;
+}
+
+static __inline
+void aic_set_sense_residual(struct scb *scb, u_long resid)
+{
+	scb->platform_data->sense_resid = resid;
+}
+
+static __inline
+u_long aic_get_residual(struct scb *scb)
+{
+	return (scb->io_ctx->resid);
+}
+
+static __inline
+u_long aic_get_sense_residual(struct scb *scb)
+{
+	return (scb->platform_data->sense_resid);
+}
+
+static __inline
+int aic_perform_autosense(struct scb *scb)
+{
+	/*
+	 * We always perform autosense in Linux.
+	 * On other platforms this is set on a
+	 * per-transaction basis.
+	 */
+	return (1);
+}
+
+static __inline uint32_t
+aic_get_sense_bufsize(struct aic_softc *aic, struct scb *scb)
+{
+	return (sizeof(struct scsi_sense_data));
+}
+
+static __inline void
+aic_notify_xfer_settings_change(struct aic_softc *aic,
+				struct aic_devinfo *devinfo)
+{
+	/* Nothing to do here for linux */
+}
+
+static __inline void
+aic_platform_scb_free(struct aic_softc *aic, struct scb *scb)
+{
+	if ((aic->flags & AIC_RESOURCE_SHORTAGE) != 0) {
+		aic->flags &= ~AIC_RESOURCE_SHORTAGE;
+		aic_release_simq_locked(aic);
+	}
+}
+
+static __inline void
+aic_freeze_scb(struct scb *scb)
+{
+	if ((scb->io_ctx->result & (CAM_DEV_QFRZN << 16)) == 0) {
+                scb->io_ctx->result |= CAM_DEV_QFRZN << 16;
+                scb->platform_data->dev->qfrozen++;
+        }
+}
+
 #endif /*_AICLIB_H */
diff -urNp linux-2.6.5/drivers/scsi/aic7xxx/aiclib_pci.c linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aiclib_pci.c
--- linux-2.6.5/drivers/scsi/aic7xxx/aiclib_pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/scsi/aic7xxx/aiclib_pci.c	2004-03-17 06:38:47.000000000 +0100
@@ -0,0 +1,79 @@
+/*
+ * Implementation of Utility functions for PCI controller types.
+ *
+ * Copyright (c) 2000-2003 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#25 $
+ */
+
+void
+aic_power_state_change(struct aic_softc *aic, aic_power_state new_state)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	pci_set_power_state(aic_dev_to_pci_dev(aic->dev_softc), new_state);
+#else
+	uint32_t cap;
+	u_int cap_offset;
+
+	/*
+	 * Traverse the capability list looking for
+	 * the power management capability.
+	 */
+	cap = 0;
+	cap_offset = aic_pci_read_config(aic->dev_softc,
+					 PCIR_CAP_PTR, /*bytes*/1);
+	while (cap_offset != 0) {
+
+		cap = aic_pci_read_config(aic->dev_softc,
+					  cap_offset, /*bytes*/4);
+		if ((cap & 0xFF) == 1
+		 && ((cap >> 16) & 0x3) > 0) {
+			uint32_t pm_control;
+
+			pm_control = aic_pci_read_config(aic->dev_softc,
+							 cap_offset + 4,
+							 /*bytes*/4);
+			pm_control &= ~0x3;
+			pm_control |= new_state;
+			aic_pci_write_config(aic->dev_softc,
+					     cap_offset + 4,
+					     pm_control, /*bytes*/2);
+			break;
+		}
+		cap_offset = (cap >> 8) & 0xFF;
+	}
+#endif 
+}
