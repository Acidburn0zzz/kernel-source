diff -purN linux-post-2.6.6-rc2-20040424/drivers/scsi/Makefile linuxppc64-post-2.6.6-rc2-20040424/drivers/scsi/Makefile
--- linux-post-2.6.6-rc2-20040424/drivers/scsi/Makefile	2004-03-21 16:54:11.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/drivers/scsi/Makefile	2004-04-13 04:04:32.000000000 +0000
@@ -124,6 +125,7 @@ obj-$(CONFIG_SCSI_SATA_SIL)	+= libata.o 
 obj-$(CONFIG_SCSI_SATA_VIA)	+= libata.o sata_via.o
 obj-$(CONFIG_SCSI_SATA_VITESSE)	+= libata.o sata_vsc.o
 obj-$(CONFIG_SCSI_SATA_SIS)	+= libata.o sata_sis.o
+obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
 
 obj-$(CONFIG_ARM)		+= arm/
 
diff -purN linux-2.6.5/drivers/scsi/Kconfig linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/Kconfig
--- linux-2.6.5/drivers/scsi/Kconfig	2004-04-04 03:38:14.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/Kconfig	2004-04-26 09:29:59.000000000 +0000
@@ -752,6 +752,23 @@ config SCSI_IPS
 	  To compile this driver as a module, choose M here: the
 	  module will be called ips.
 
+config SCSI_IBMVSCSI
+	tristate "IBM Virtual SCSI support"
+	depends on PPC_PSERIES || PPC_ISERIES
+	help
+	  This is the IBM Virtual SCSI Client
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ibmvscsic.
+
+config SCSI_IBMVSCSIS
+	tristate "IBM Virtual SCSI Server support"
+	depends on PPC_PSERIES
+	help
+	  This is the IBM Virtual SCSI Server
+	  To compile this driver as a module, choose M here: the
+	  module will be called ibmvscsis.
+
 config SCSI_INITIO
 	tristate "Initio 9100U(W) support"
 	depends on PCI && SCSI && BROKEN
diff -purN linux-2.6.5/drivers/scsi/ibmvscsi/Makefile linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/Makefile
--- linux-2.6.5/drivers/scsi/ibmvscsi/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/Makefile	2004-04-26 09:29:59.000000000 +0000
@@ -0,0 +1,7 @@
+obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic.o
+
+ibmvscsic-y			+= ibmvscsi.o
+ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
+ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
+ 
+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsis.o
diff -purN linux-2.6.5/drivers/scsi/ibmvscsi/ibmvscsi.c linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/ibmvscsi.c
--- linux-2.6.5/drivers/scsi/ibmvscsi/ibmvscsi.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/ibmvscsi.c	2004-04-26 09:29:59.000000000 +0000
@@ -0,0 +1,1334 @@
+/* ------------------------------------------------------------
+ * ibmvscsi.c
+ * (C) Copyright IBM Corporation 1994, 2004
+ * Authors: Colin DeVilbiss (devilbis@us.ibm.com)
+ *          Santiago Leon (santil@us.ibm.com)
+ *          Dave Boutcher (sleddog@us.ibm.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * ------------------------------------------------------------
+ * Emulation of a SCSI host adapter for Virtual I/O devices
+ *
+ * This driver supports the SCSI adapter implemented by the IBM
+ * Power5 firmware.  That SCSI adapter is not a physical adapter,
+ * but allows Linux SCSI peripheral drivers to directly
+ * access devices in another logical partition on the physical system.
+ *
+ * The virtual adapter(s) are present in the open firmware device
+ * tree just like real adapters.
+ *
+ * One of the capabilities provided on these systems is the ability
+ * to DMA between partitions.  The architecture states that for VSCSI,
+ * the server side is allowed to DMA to and from the client.  The client
+ * is never trusted to DMA to or from the server directly.
+ *
+ * Messages are sent between partitions on a "Command/Response Queue" 
+ * (CRQ), which is just a buffer of 16 byte entries in the receiver's 
+ * Senders cannot access the buffer directly, but send messages by
+ * making a hypervisor call and passing in the 16 bytes.  The hypervisor
+ * puts the message in the next 16 byte space in round-robbin fashion,
+ * turns on the high order bit of the message (the valid bit), and 
+ * generates an interrupt to the receiver (if interrupts are turned on.) 
+ * The receiver just turns off the valid bit when they have copied out
+ * the message.
+ *
+ * The VSCSI client builds a SCSI Remote Protocol (SRP) Information Unit
+ * (IU) (as defined in the T10 standard available at www.t10.org), gets 
+ * a DMA address for the message, and sends it to the server as the
+ * payload of a CRQ message.  The server DMAs the SRP IU and processes it,
+ * including doing any additional data transfers.  When it is done, it
+ * DMAs the SRP response back to the same address as the request came from,
+ * and sends a CRQ message back to inform the client that the request has
+ * completed.
+ *
+ * Note that some of the underlying infrastructure is different between
+ * machines conforming to the "RS/6000 Platform Architecture" (RPA) and
+ * the older iSeries hypervisor models.  To support both, some low level
+ * routines have been broken out into rpa_vscsi.c and iseries_vscsi.c.
+ * The Makefile should pick one, not two, not zero, of these.
+ *
+ * TODO: This is currently pretty tied to the IBM i/pSeries hypervisor
+ * interfaces.  It would be really nice to abstract this above an RDMA
+ * layer.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_device.h>
+#include "ibmvscsi.h"
+
+/* The values below are somewhat arbitrary default values, but 
+ * OS/400 will use 3 busses (disks, CDs, tapes, I think.)
+ * Note that there are 3 bits of channel value, 6 bits of id, and
+ * 5 bits of LUN.
+ */
+static int max_id = 64;
+static int max_channel = 3;
+static int init_timeout = 5;
+static int max_requests = 50;
+
+MODULE_DESCRIPTION("IBM Virtual SCSI");
+MODULE_AUTHOR("Dave Boutcher");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+module_param_named(max_id, max_id, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(max_id, "Largest ID value for each channel");
+module_param_named(max_channel, max_channel, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(max_channel, "Largest channel value");
+module_param_named(init_timeout, init_timeout, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(init_timeout, "Initialization timeout in seconds");
+module_param_named(max_requests, max_requests, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(max_requests, "Maximum requests for this adapter");
+
+/* ------------------------------------------------------------
+ * Routines for the event pool and event structs
+ */
+/**
+ * initialize_event_pool: - Allocates and initializes the event pool for a host
+ * @pool:	event_pool to be initialized
+ * @size:	Number of events in pool
+ * @hostdata:	ibmvscsi_host_data who owns the event pool
+ *
+ * Returns zero on success.
+*/
+static int initialize_event_pool(struct event_pool *pool,
+				 int size, struct ibmvscsi_host_data *hostdata)
+{
+	int i;
+
+	pool->size = size;
+	pool->events = kmalloc(pool->size * sizeof(*pool->events), GFP_KERNEL);
+	if (!pool->events)
+		return -ENOMEM;
+	memset(pool->events, 0x00, pool->size * sizeof(*pool->events));
+
+	pool->iu_storage =
+	    dma_alloc_coherent(hostdata->dev,
+			       pool->size * sizeof(*pool->iu_storage),
+			       &pool->iu_token, 0);
+	if (!pool->iu_storage) {
+		kfree(pool->events);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < pool->size; ++i) {
+		struct srp_event_struct *evt = &pool->events[i];
+		memset(&evt->crq, 0x00, sizeof(evt->crq));
+		evt->crq.valid = 0x80;
+		evt->crq.IU_length = sizeof(*evt->evt);
+		evt->crq.IU_data_ptr = pool->iu_token + sizeof(*evt->evt) * i;
+		evt->evt = pool->iu_storage + i;
+		evt->hostdata = hostdata;
+	}
+
+	return 0;
+}
+
+/**
+ * release_event_pool: - Frees memory of an event pool of a host
+ * @pool:	event_pool to be released
+ * @hostdata:	ibmvscsi_host_data who owns the even pool
+ *
+ * Returns zero on success.
+*/
+static void release_event_pool(struct event_pool *pool,
+			       struct ibmvscsi_host_data *hostdata)
+{
+	int i, in_use = 0;
+	for (i = 0; i < pool->size; ++i)
+		if (pool->events[i].in_use)
+			++in_use;
+	if (in_use)
+		printk(KERN_WARNING
+		       "ibmvscsi: releasing event pool with %d "
+		       "events still in use?\n", in_use);
+	kfree(pool->events);
+	dma_free_coherent(hostdata->dev,
+			  pool->size * sizeof(*pool->iu_storage),
+			  pool->iu_storage, pool->iu_token);
+}
+
+/**
+ * ibmvscsi_valid_event_struct: - Determines if event is valid.
+ * @pool:	event_pool that contains the event
+ * @evt:	srp_event_struct to be checked for validity
+ *
+ * Returns zero if event is invalid, one otherwise.
+*/
+int ibmvscsi_valid_event_struct(struct event_pool *pool,
+				struct srp_event_struct *evt)
+{
+	int index = evt - pool->events;
+	if (index < 0 || index >= pool->size)	/* outside of bounds */
+		return 0;
+	if (evt != pool->events + index)	/* unaligned */
+		return 0;
+	return 1;
+}
+
+/**
+ * ibmvscsi_free-event_struct: - Changes status of event to "free"
+ * @pool:	event_pool that contains the event
+ * @evt:	srp_event_struct to be modified
+ *
+*/
+static void ibmvscsi_free_event_struct(struct event_pool *pool,
+				       struct srp_event_struct *evt)
+{
+	if (!ibmvscsi_valid_event_struct(pool, evt)) {
+		printk(KERN_ERR
+		       "ibmvscsi: Freeing invalid event_struct %p "
+		       "(not in pool %p)\n", evt, pool->events);
+		return;
+	}
+	if (!evt->in_use) {
+		printk(KERN_ERR
+		       "ibmvscsi: Freeing event_struct %p "
+		       "which is not in use!\n", evt);
+		return;
+	}
+	evt->in_use = 0;
+}
+
+/**
+ * ibmvscsi_get_event_struct: - Gets the next free event in pool
+ * @pool:	event_pool that contains the events to be searched
+ *
+ * Returns the next event in "free" state, and NULL if none are free.
+ * Note that no synchronization is done here, we assume the host_lock
+ * will syncrhonze things.
+*/
+static
+struct srp_event_struct *ibmvscsi_get_event_struct(struct event_pool *pool)
+{
+	struct srp_event_struct *cur, *last = pool->events + pool->size;
+
+	for (cur = pool->events; cur < last; ++cur)
+		if (!cur->in_use) {
+			cur->in_use = 1;
+			break;
+		}
+
+	if (cur >= last) {
+		printk(KERN_ERR "ibmvscsi: found no event struct in pool!\n");
+		return NULL;
+	}
+
+	return cur;
+}
+
+/**
+ * evt_struct_for: - Initializes the next free event
+ * @pool:	event_pool that contains events to be searched
+ * @evt:	VIOSRP_IU that the event will point to
+ * @cmnd:	The scsi cmnd object for this event.  Can be NULL
+ * @done:	Callback function when event is processed
+ *
+ * Returns the initialized event, and NULL if there are no free events
+ */
+static
+struct srp_event_struct *evt_struct_for(struct event_pool *pool,
+					union VIOSRP_IU *evt,
+					struct scsi_cmnd *cmnd,
+					void (*done) (struct srp_event_struct
+						      *))
+{
+	struct srp_event_struct *evt_struct = ibmvscsi_get_event_struct(pool);
+	if (!evt_struct)
+		return NULL;
+
+	*evt_struct->evt = *evt;
+	evt_struct->evt->srp.generic.tag = (u64) (unsigned long)evt_struct;
+
+	evt_struct->cmnd = cmnd;
+	evt_struct->done = done;
+	return evt_struct;
+}
+
+/* ------------------------------------------------------------
+ * Routines for receiving SCSI responses from the hosting partition
+ */
+/**
+ * unmap_direct_data: - Unmap address pointed by SRP_CMD
+ * @cmd:	SRP_CMD whose additional_data member will be unmapped
+ * @dev:	device for which the memory is mapped
+ *
+*/
+static void unmap_direct_data(struct SRP_CMD *cmd, struct device *dev)
+{
+	struct memory_descriptor *data =
+	    (struct memory_descriptor *)cmd->additional_data;
+	dma_unmap_single(dev, data->virtual_address, data->length,
+			 DMA_BIDIRECTIONAL);
+}
+
+/**
+ * unmap_direct_data: - Unmap array of address pointed by SRP_CMD
+ * @cmd:	SRP_CMD whose additional_data member will be unmapped
+ * @dev:	device for which the memory is mapped
+ *
+*/
+static void unmap_indirect_data(struct SRP_CMD *cmd, struct device *dev)
+{
+	struct indirect_descriptor *indirect =
+	    (struct indirect_descriptor *)cmd->additional_data;
+	int i, num_mapped = indirect->head.length / sizeof(indirect->list[0]);
+	for (i = 0; i < num_mapped; ++i) {
+		struct memory_descriptor *data = &indirect->list[i];
+		dma_unmap_single(dev,
+				 data->virtual_address,
+				 data->length, DMA_BIDIRECTIONAL);
+	}
+}
+
+/**
+ * unmap_direct_data: - Unmap data pointed in SRP_CMD based on the format
+ * @cmd:	SRP_CMD whose additional_data member will be unmapped
+ * @dev:	device for which the memory is mapped
+ *
+*/
+static void unmap_cmd_data(struct SRP_CMD *cmd, struct device *dev)
+{
+	if ((cmd->data_out_format == SRP_NO_BUFFER) &&
+	    (cmd->data_in_format == SRP_NO_BUFFER))
+		return;
+	else if ((cmd->data_out_format == SRP_DIRECT_BUFFER) ||
+		 (cmd->data_in_format == SRP_DIRECT_BUFFER))
+		unmap_direct_data(cmd, dev);
+	else
+		unmap_indirect_data(cmd, dev);
+}
+
+/**
+ * map_sg_data: - Maps dma for a scatterlist and initializes decriptor fields
+ * @cmd:	Scsi_Cmnd with the scatterlist
+ * @srp_cmd:	SRP_CMD that contains the memory descriptor
+ * @dev:	device for which to map dma memory
+ *
+ * Called by map_data_for_srp_cmd() when building srp cmd from scsi cmd.
+ * Returns 1 on success.
+*/
+static int map_sg_data(struct scsi_cmnd *cmd,
+		       struct SRP_CMD *srp_cmd, struct device *dev)
+{
+
+	int i, sg_mapped;
+	u64 total_length = 0;
+	struct scatterlist *sg = cmd->request_buffer;
+	struct memory_descriptor *data =
+	    (struct memory_descriptor *)srp_cmd->additional_data;
+	struct indirect_descriptor *indirect =
+	    (struct indirect_descriptor *)data;
+
+	sg_mapped = dma_map_sg(dev, sg, cmd->use_sg, DMA_BIDIRECTIONAL);
+
+	if (sg_mapped == 0)
+		return 0;
+
+	/* special case; we can use a single direct descriptor */
+	if (sg_mapped == 1) {
+		if (cmd->sc_data_direction == DMA_TO_DEVICE)
+			srp_cmd->data_out_format = SRP_DIRECT_BUFFER;
+		else
+			srp_cmd->data_in_format = SRP_DIRECT_BUFFER;
+		data->virtual_address = sg_dma_address(&sg[0]);
+		data->length = sg_dma_len(&sg[0]);
+		data->memory_handle = 0;
+		return 1;
+	}
+
+	if (sg_mapped > MAX_INDIRECT_BUFS) {
+		printk(KERN_ERR
+		       "ibmvscsi: More than %d mapped sg entries, got %d\n",
+		       MAX_INDIRECT_BUFS, sg_mapped);
+		return 0;
+	}
+
+	if (cmd->sc_data_direction == DMA_TO_DEVICE) {
+		srp_cmd->data_out_format = SRP_INDIRECT_BUFFER;
+		srp_cmd->data_out_count = sg_mapped;
+	} else {
+		srp_cmd->data_in_format = SRP_INDIRECT_BUFFER;
+		srp_cmd->data_in_count = sg_mapped;
+	}
+	indirect->head.virtual_address = 0;
+	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
+	indirect->head.memory_handle = 0;
+	for (i = 0; i < sg_mapped; ++i) {
+		struct memory_descriptor *descr = &indirect->list[i];
+		struct scatterlist *sg_entry = &sg[i];
+		descr->virtual_address = sg_dma_address(sg_entry);
+		descr->length = sg_dma_len(sg_entry);
+		descr->memory_handle = 0;
+		total_length += sg_dma_len(sg_entry);
+	}
+	indirect->total_length = total_length;
+
+	return 1;
+}
+
+/**
+ * map_sg_data: - Maps memory and initializes memory decriptor fields
+ * @cmd:	struct scsi_cmnd with the memory to be mapped
+ * @srp_cmd:	SRP_CMD that contains the memory descriptor
+ * @dev:	device for which to map dma memory
+ *
+ * Called by map_data_for_srp_cmd() when building srp cmd from scsi cmd.
+ * Returns 1 on success.
+*/
+static int map_single_data(struct scsi_cmnd *cmd,
+			   struct SRP_CMD *srp_cmd, struct device *dev)
+{
+	struct memory_descriptor *data =
+	    (struct memory_descriptor *)srp_cmd->additional_data;
+
+	data->virtual_address =
+	    (u64) (unsigned long)dma_map_single(dev, cmd->request_buffer,
+						cmd->request_bufflen,
+						DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(data->virtual_address)) {
+		printk(KERN_ERR
+		       "ibmvscsi: Unable to map request_buffer for command!\n");
+		return 0;
+	}
+	data->length = cmd->request_bufflen;
+	data->memory_handle = 0;
+
+	if (cmd->sc_data_direction == DMA_TO_DEVICE)
+		srp_cmd->data_out_format = SRP_DIRECT_BUFFER;
+	else
+		srp_cmd->data_in_format = SRP_DIRECT_BUFFER;
+
+	return 1;
+}
+
+/**
+ * map_data_for_srp_cmd: - Calls functions to map data for srp cmds
+ * @cmd:	struct scsi_cmnd with the memory to be mapped
+ * @srp_cmd:	SRP_CMD that contains the memory descriptor
+ * @dev:	dma device for which to map dma memory
+ *
+ * Called by scsi_cmd_to_srp_cmd() when converting scsi cmds to srp cmds 
+ * Returns 1 on success.
+*/
+static int map_data_for_srp_cmd(struct scsi_cmnd *cmd,
+				struct SRP_CMD *srp_cmd, struct device *dev)
+{
+	switch (cmd->sc_data_direction) {
+	case DMA_FROM_DEVICE:
+	case DMA_TO_DEVICE:
+		break;
+	case DMA_NONE:
+		return 1;
+	case DMA_BIDIRECTIONAL:
+		printk(KERN_ERR
+		       "ibmvscsi: Can't map DMA_BIDIRECTIONAL to read/write\n");
+		return 0;
+	default:
+		printk(KERN_ERR
+		       "ibmvscsi: Unknown data direction 0x%02x; can't map!\n",
+		       cmd->sc_data_direction);
+		return 0;
+	}
+
+	if (!cmd->request_buffer)
+		return 1;
+	if (cmd->use_sg)
+		return map_sg_data(cmd, srp_cmd, dev);
+	return map_single_data(cmd, srp_cmd, dev);
+}
+
+/* ------------------------------------------------------------
+ * Routines for sending and receiving SRPs
+ */
+/**
+ * ibmvscsi_send_srp_event: - Transforms event to u64 array and calls send_crq()
+ * @evt_struct:	evt_struct to be sent
+ * @hostdata:	ibmvscsi_host_data of host
+ *
+ * Returns the value returned from ibmvscsi_send_crq(). (Zero for success)
+ * Note that this routine assumes that host_lock is held for synchronization
+*/
+static int ibmvscsi_send_srp_event(struct srp_event_struct *evt_struct,
+				   struct ibmvscsi_host_data *hostdata)
+{
+	struct scsi_cmnd *cmnd;
+	u64 *crq_as_u64 = (u64 *) & evt_struct->crq;
+
+	/* If we have exhausted our request limit, just queue this request.
+	 * Note that there are rare cases involving driver generated requests 
+	 * (such as task management requests) that the mid layer may think we
+	 * can handle more requests (can_queue) when we actually can't
+	 */
+	if ((evt_struct->crq.format == VIOSRP_SRP_FORMAT) &&
+	    (atomic_dec_if_positive(&hostdata->request_limit) < 0)) {
+		printk("ibmvscsi: Warning, request_limit exceeded\n");
+		unmap_cmd_data(&evt_struct->evt->srp.cmd, hostdata->dev);
+		ibmvscsi_free_event_struct(&hostdata->pool, evt_struct);
+		return SCSI_MLQUEUE_HOST_BUSY;
+	}
+
+	/* Add this to the sent list.  We need to do this 
+	 * before we actually send 
+	 * in case it comes back REALLY fast
+	 */
+	list_add_tail(&evt_struct->list, &hostdata->sent);
+
+	if (ibmvscsi_send_crq(hostdata, crq_as_u64[0], crq_as_u64[1]) != 0) {
+		list_del(&evt_struct->list);
+
+		cmnd = evt_struct->cmnd;
+		printk(KERN_ERR "ibmvscsi: failed to send event struct\n");
+		unmap_cmd_data(&evt_struct->evt->srp.cmd, hostdata->dev);
+		ibmvscsi_free_event_struct(&hostdata->pool, evt_struct);
+		cmnd->result = DID_ERROR << 16;
+		evt_struct->cmnd_done(cmnd);
+	}
+
+	return 0;
+}
+
+/**
+ * handle_cmd_rsp: -  Handle responses from commands
+ * @evt_struct:	srp_event_struct to be handled
+ *
+ * Used as a callback by when sending scsi cmds (by scsi_cmd_to_event_struct). 
+ * Gets called by ibmvscsi_handle_crq()
+*/
+static void handle_cmd_rsp(struct srp_event_struct *evt_struct)
+{
+	struct SRP_RSP *rsp = &evt_struct->evt->srp.rsp;
+	struct scsi_cmnd *cmnd = (struct scsi_cmnd *)evt_struct->cmnd;
+
+	if (cmnd) {
+		cmnd->result = rsp->status;
+		if (((cmnd->result >> 1) & 0x1f) == CHECK_CONDITION)
+			memcpy(cmnd->sense_buffer,
+			       rsp->sense_and_response_data,
+			       rsp->sense_data_list_length);
+		unmap_cmd_data(&evt_struct->cmd, evt_struct->hostdata->dev);
+
+		if (rsp->dounder)
+			cmnd->resid = rsp->data_out_residual_count;
+		else if (rsp->diunder)
+			cmnd->resid = rsp->data_in_residual_count;
+	}
+
+	if (evt_struct->cmnd_done) {
+		evt_struct->cmnd_done(cmnd);
+	}
+}
+
+/* ------------------------------------------------------------
+ * Routines for queuing individual SCSI commands to the hosting partition
+ */
+
+/**
+ * lun_from_dev: - Returns the lun of the scsi device
+ * @dev:	struct scsi_device
+ *
+*/
+static inline u16 lun_from_dev(struct scsi_device *dev)
+{
+	return (0x2 << 14) | (dev->id << 8) | (dev->channel << 5) | dev->lun;
+}
+
+/**
+ * scsi_cmd_to_srp_cmd: - Initializes srp cmd with data from scsi cmd
+ * @cmd:	source struct scsi_cmnd
+ * @srp_cmd:	target SRP_CMD
+ * @hostdata:	ibmvscsi_host_data of host
+ *
+ * Returns 1 on success.
+*/
+static int scsi_cmd_to_srp_cmd(struct scsi_cmnd *cmd,
+			       struct SRP_CMD *srp_cmd,
+			       struct ibmvscsi_host_data *hostdata)
+{
+	u16 lun = lun_from_dev(cmd->device);
+	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
+
+	srp_cmd->type = SRP_CMD_TYPE;
+	memcpy(srp_cmd->cdb, cmd->cmnd, sizeof(cmd->cmnd));
+	srp_cmd->lun = ((u64) lun) << 48;
+
+	return map_data_for_srp_cmd(cmd, srp_cmd, hostdata->dev);
+}
+
+/**
+ * scsi_cmd_to_event_struct: - Initializes a srp_event_struct 
+ *                             with data from scsi cmd
+ * @cmd:	Source struct scsi_cmnd
+ * @done:	Callback function to be called when cmd is completed
+ * @hostdata:	ibmvscsi_host_data of host
+ *
+ * Returns the srp_event_struct to be used or NULL if not successful.
+*/
+static struct srp_event_struct *scsi_cmd_to_event_struct(struct scsi_cmnd *cmd,
+							 void (*done) (struct
+								       scsi_cmnd
+								       *),
+							 struct
+							 ibmvscsi_host_data
+							 *hostdata)
+{
+	struct SRP_CMD srp_cmd;
+	struct srp_event_struct *evt_struct;
+
+	if (!scsi_cmd_to_srp_cmd(cmd, &srp_cmd, hostdata)) {
+		printk(KERN_ERR "ibmvscsi: couldn't convert cmd to SRP_CMD\n");
+		return NULL;
+	}
+
+	evt_struct = evt_struct_for(&hostdata->pool,
+				    (union VIOSRP_IU *)&srp_cmd,
+				    (void *)cmd, handle_cmd_rsp);
+	if (!evt_struct)
+		return NULL;
+
+	evt_struct->cmd = srp_cmd;
+	evt_struct->cmnd_done = done;
+	evt_struct->crq.timeout = cmd->timeout;
+	return evt_struct;
+}
+
+/**
+ * ibmvscsi_queue: - The queuecommand function of the scsi template 
+ * @cmd:	struct scsi_cmnd to be executed
+ * @done:	Callback function to be called when cmd is completed
+*/
+static
+int ibmvscsi_queuecommand(struct scsi_cmnd *cmd,
+			  void (*done) (struct scsi_cmnd *))
+{
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)&cmd->device->host->hostdata;
+	struct srp_event_struct *evt_struct =
+	    scsi_cmd_to_event_struct(cmd, done, hostdata);
+
+	if (!evt_struct)
+		return SCSI_MLQUEUE_HOST_BUSY;
+
+	evt_struct->crq.format = VIOSRP_SRP_FORMAT;
+
+	return ibmvscsi_send_srp_event(evt_struct, hostdata);
+}
+
+/* ------------------------------------------------------------
+ * Routines for driver initialization
+ */
+/**
+ * adapter_info_rsp: - Handle response to MAD adapter info request
+ * @evt_struct:	srp_event_struct with the response
+ *
+ * Used as a "done" callback by when sending adapter_info. Gets called
+ * by ibmvscsi_handle_crq()
+*/
+static void adapter_info_rsp(struct srp_event_struct *evt_struct)
+{
+	struct ibmvscsi_host_data *hostdata = evt_struct->hostdata;
+	dma_unmap_single(hostdata->dev,
+			 evt_struct->evt->mad.adapter_info.buffer,
+			 evt_struct->evt->mad.adapter_info.common.length,
+			 DMA_BIDIRECTIONAL);
+
+	if (evt_struct->evt->mad.adapter_info.common.status) {
+		printk("ibmvscsi: error %d getting adapter info\n",
+		       evt_struct->evt->mad.adapter_info.common.status);
+	} else {
+		printk("ibmvscsi: host srp version: %s, "
+		       "host partition %s (%d), OS %d\n",
+		       hostdata->madapter_info.srp_version,
+		       hostdata->madapter_info.partition_name,
+		       hostdata->madapter_info.partition_number,
+		       hostdata->madapter_info.os_type);
+	}
+}
+
+/**
+ * send_mad_adapter_info: - Sends the mad adapter info request
+ *      and stores the result so it can be retrieved with
+ *      sysfs.  We COULD consider causing a failure if the
+ *      returned SRP version doesn't match ours.
+ * @hostdata:	ibmvscsi_host_data of host
+ * 
+ * Returns zero if successful.
+*/
+static void send_mad_adapter_info(struct ibmvscsi_host_data *hostdata)
+{
+	struct VIOSRP_ADAPTER_INFO req;
+	struct srp_event_struct *evt_struct;
+
+	memset(&hostdata->madapter_info, 0x00, sizeof(hostdata->madapter_info));
+	memset(&req, 0x00, sizeof(req));
+	req.common.type = VIOSRP_ADAPTER_INFO_TYPE;
+	req.common.length = sizeof(hostdata->madapter_info);
+	req.buffer = dma_map_single(hostdata->dev,
+				    &hostdata->madapter_info,
+				    sizeof(hostdata->madapter_info),
+				    DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(req.buffer)) {
+		printk(KERN_ERR
+		       "ibmvscsi: Unable to map request_buffer "
+		       "for adapter_info!\n");
+		return;
+	}
+
+	evt_struct = evt_struct_for(&hostdata->pool,
+				    (union VIOSRP_IU *)&req, NULL,
+				    adapter_info_rsp);
+	evt_struct->crq.format = VIOSRP_MAD_FORMAT;
+
+	if (!evt_struct) {
+		printk(KERN_ERR "ibmvscsi: couldn't allocate an event "
+		       "for ADAPTER_INFO_REQ!\n");
+		dma_unmap_single(hostdata->dev, req.buffer,
+				 req.common.length, DMA_BIDIRECTIONAL);
+		return;
+	}
+
+	if (ibmvscsi_send_srp_event(evt_struct, hostdata))
+		printk(KERN_ERR "ibmvscsi: couldn't send ADAPTER_INFO_REQ!\n");
+};
+
+/**
+ * login_rsp: - Handle response to SRP login request
+ * @evt_struct:	srp_event_struct with the response
+ *
+ * Used as a "done" callback by when sending srp_login. Gets called
+ * by ibmvscsi_handle_crq()
+*/
+static void login_rsp(struct srp_event_struct *evt_struct)
+{
+	struct ibmvscsi_host_data *hostdata = evt_struct->hostdata;
+	switch (evt_struct->evt->srp.generic.type) {
+	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
+		break;
+	case SRP_LOGIN_REJ_TYPE:	/* refused! */
+		printk(KERN_INFO "ibmvscsi: SRP_LOGIN_REQ rejected\n");
+		/* Login failed.  */
+		atomic_set(&hostdata->request_limit, -1);
+		return;
+	default:
+		printk(KERN_ERR
+		       "ibmvscsi: Invalid login response typecode 0x%02x!\n",
+		       evt_struct->evt->srp.generic.type);
+		/* Login failed.  */
+		atomic_set(&hostdata->request_limit, -1);
+		return;
+	}
+
+	printk(KERN_INFO "ibmvscsi: SRP_LOGIN succeeded\n");
+
+	if (evt_struct->evt->srp.login_rsp.request_limit_delta > (max_requests-2))
+	    evt_struct->evt->srp.login_rsp.request_limit_delta = max_requests-2;
+
+	/* Now we know what the real request-limit is */
+	atomic_set(&hostdata->request_limit,
+		   evt_struct->evt->srp.login_rsp.request_limit_delta);
+
+	hostdata->host->can_queue =
+	    evt_struct->evt->srp.login_rsp.request_limit_delta;
+
+	send_mad_adapter_info(hostdata);
+	return;
+}
+
+/**
+ * send_srp_login: - Sends the srp login
+ * @hostdata:	ibmvscsi_host_data of host
+ * 
+ * Returns zero if successful.
+*/
+static int send_srp_login(struct ibmvscsi_host_data *hostdata)
+{
+	int rc;
+	unsigned long flags;
+
+	struct SRP_LOGIN_REQ req = {
+		.type = SRP_LOGIN_REQ_TYPE,
+		.max_requested_initiator_to_target_iulen = sizeof(union SRP_IU),
+		.required_buffer_formats = 0x0002	/* direct and indirect */
+	};
+	struct srp_event_struct *evt_struct = evt_struct_for(&hostdata->pool,
+							     (union VIOSRP_IU *)
+							     &req,
+							     NULL,
+							     login_rsp);
+
+	if (!evt_struct) {
+		printk(KERN_ERR
+		       "ibmvscsi: couldn't allocate an event for login req!\n");
+		return FAILED;
+	}
+
+	/* Start out with a request limit of 1, since this is negotiated in
+	 * the login request we are just sending
+	 */
+	atomic_set(&hostdata->request_limit, 1);
+	evt_struct->crq.format = VIOSRP_SRP_FORMAT;
+
+	spin_lock_irqsave(hostdata->host->host_lock, flags);
+	rc = ibmvscsi_send_srp_event(evt_struct, hostdata);
+	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
+	return rc;
+};
+
+/**
+ * sync_completion: Signal that a synchronous command has completed
+ * Note that after returning from this call, the evt_struct is freed.
+ * the caller waiting on this completion shouldn't touch the evt_struct
+ * again.
+ */
+static void sync_completion(struct srp_event_struct *evt_struct)
+{
+	complete(&evt_struct->comp);
+}
+
+/**
+ * ibmvscsi_abort: Abort a command...from scsi host template
+ * send this over to the server and wait synchronously for the response
+ */
+static int ibmvscsi_eh_abort_handler(struct scsi_cmnd *cmd)
+{
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)cmd->device->host->hostdata;
+	union VIOSRP_IU iu;
+	struct SRP_TSK_MGMT *tsk_mgmt = &iu.srp.tsk_mgmt;
+	struct srp_event_struct *evt;
+	struct srp_event_struct *tmp_evt, *found_evt;
+	u16 lun = lun_from_dev(cmd->device);
+
+	/* First, find this command in our sent list so we can figure
+	 * out the correct tag
+	 */
+	found_evt = NULL;
+	list_for_each_entry(tmp_evt, &hostdata->sent, list) {
+		if (tmp_evt->cmnd == cmd) {
+			found_evt = tmp_evt;
+			break;
+		}
+	}
+
+	/* Set up an abort SRP command */
+	memset(&iu, 0x00, sizeof(iu));
+	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
+	tsk_mgmt->lun = ((u64) lun) << 48;
+	tsk_mgmt->task_mgmt_flags = 0x01;	/* ABORT TASK */
+	tsk_mgmt->managed_task_tag = (u64) (unsigned long)found_evt;
+
+	printk(KERN_INFO "ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n",
+	       tsk_mgmt->lun, tsk_mgmt->managed_task_tag);
+
+	evt = evt_struct_for(&hostdata->pool, &iu, NULL, sync_completion);
+	if (!evt) {
+		printk(KERN_ERR "ibmvscsi: failed to allocate abort() event\n");
+		return FAILED;
+	}
+	evt->crq.format = VIOSRP_SRP_FORMAT;
+
+	init_completion(&evt->comp);
+	if (ibmvscsi_send_srp_event(evt, hostdata) != 0) {
+		printk(KERN_ERR "ibmvscsi: failed to send abort() event\n");
+		return FAILED;
+	}
+
+	spin_unlock_irq(hostdata->host->host_lock);
+	wait_for_completion(&evt->comp);
+	spin_lock_irq(hostdata->host->host_lock);
+
+	/* Because we dropped the spinlock above, it's possible
+	 * The event is no longer in our list.  Make sure it didn't
+	 * complete while we were aborting
+	 */
+	list_for_each_entry(tmp_evt, &hostdata->sent, list) {
+		if (tmp_evt->cmnd == cmd) {
+			found_evt = tmp_evt;
+			break;
+		}
+	}
+	if (found_evt == NULL)
+		return SUCCESS;
+
+	cmd->result = (DID_ABORT << 16);
+	list_del(&found_evt->list);
+	unmap_cmd_data(&found_evt->cmd, found_evt->hostdata->dev);
+	ibmvscsi_free_event_struct(&found_evt->hostdata->pool, found_evt);
+	atomic_inc(&hostdata->request_limit);
+	printk(KERN_INFO
+	       "ibmvscsi: successfully aborted task tag 0x%lx\n",
+	       tsk_mgmt->managed_task_tag);
+	return SUCCESS;
+}
+
+/**
+ * ibmvscsi_eh_device_reset_handler: Reset a single LUN...from scsi host 
+ * template send this over to the server and wait synchronously for the 
+ * response
+ */
+static int ibmvscsi_eh_device_reset_handler(struct scsi_cmnd *cmd)
+{
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)cmd->device->host->hostdata;
+
+	union VIOSRP_IU iu;
+	struct SRP_TSK_MGMT *tsk_mgmt = &iu.srp.tsk_mgmt;
+	struct srp_event_struct *evt;
+	struct srp_event_struct *tmp_evt, *pos;
+	u16 lun = lun_from_dev(cmd->device);
+
+	/* Set up a lun reset SRP command */
+	memset(&iu, 0x00, sizeof(iu));
+	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
+	tsk_mgmt->lun = ((u64) lun) << 48;
+	tsk_mgmt->task_mgmt_flags = 0x08;	/* LUN RESET */
+
+	printk(KERN_INFO "ibmvscsi: resetting device. lun 0x%lx\n",
+	       tsk_mgmt->lun);
+
+	evt = evt_struct_for(&hostdata->pool, &iu, NULL, sync_completion);
+	if (!evt) {
+		printk(KERN_ERR "ibmvscsi: failed to allocate reset event\n");
+		return FAILED;
+	}
+	evt->crq.format = VIOSRP_SRP_FORMAT;
+
+	init_completion(&evt->comp);
+	if (ibmvscsi_send_srp_event(evt, hostdata) != 0) {
+		printk(KERN_ERR "ibmvscsi: failed to send reset event\n");
+		return FAILED;
+	}
+
+	spin_unlock_irq(hostdata->host->host_lock);
+	wait_for_completion(&evt->comp);
+	spin_lock_irq(hostdata->host->host_lock);
+
+	/* We need to find all commands for this LUN that have not yet been
+	 * responded to, and fail them with DID_RESET
+	 */
+	list_for_each_entry_safe(tmp_evt, pos, &hostdata->sent, list) {
+		if (tmp_evt->cmnd->device == cmd->device) {
+			tmp_evt->cmnd->result = (DID_RESET << 16);
+			list_del(&tmp_evt->list);
+			unmap_cmd_data(&tmp_evt->cmd, tmp_evt->hostdata->dev);
+			ibmvscsi_free_event_struct(&tmp_evt->hostdata->pool,
+						   tmp_evt);
+			if (tmp_evt->cmnd_done)
+				tmp_evt->cmnd_done(tmp_evt->cmnd);
+		}
+	}
+	return SUCCESS;
+}
+
+/**
+ * purge_requests: Our virtual adapter just shut down.  purge any sent requests
+ * @hostdata:    the adapter
+ */
+static void purge_requests(struct ibmvscsi_host_data *hostdata)
+{
+	struct srp_event_struct *tmp_evt, *pos;
+	unsigned long flags;
+
+	spin_lock_irqsave(hostdata->host->host_lock, flags);
+	list_for_each_entry_safe(tmp_evt, pos, &hostdata->sent, list) {
+		tmp_evt->cmnd->result = (DID_ERROR << 16);
+		list_del(&tmp_evt->list);
+		unmap_cmd_data(&tmp_evt->cmd, tmp_evt->hostdata->dev);
+		ibmvscsi_free_event_struct(&tmp_evt->hostdata->pool, tmp_evt);
+		if (tmp_evt->cmnd_done)
+			tmp_evt->cmnd_done(tmp_evt->cmnd);
+	}
+	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
+}
+
+/**
+ * ibmvscsi_handle_crq: - Handles and frees received events in the CRQ
+ * @crq:	Command/Response queue
+ * @hostdata:	ibmvscsi_host_data of host
+ *
+*/
+void ibmvscsi_handle_crq(struct VIOSRP_CRQ *crq,
+			 struct ibmvscsi_host_data *hostdata)
+{
+	unsigned long flags;
+	struct srp_event_struct *evt_struct =
+	    (struct srp_event_struct *)crq->IU_data_ptr;
+	switch (crq->valid) {
+	case 0xC0:		/* initialization */
+		switch (crq->format) {
+		case 0x01:	/* Initialization message */
+			printk(KERN_INFO "ibmvscsi: partner initialized\n");
+			/* Send back a response */
+			if (ibmvscsi_send_crq(hostdata,
+					      0xC002000000000000, 0) == 0) {
+				/* Now login */
+				send_srp_login(hostdata);
+			} else {
+				printk(KERN_ERR
+				       "ibmvscsi: Unable to send init rsp\n");
+			}
+
+			break;
+		case 0x02:	/* Initialization response */
+			printk(KERN_INFO
+			       "ibmvscsi: partner initialization complete\n");
+
+			/* Now login */
+			send_srp_login(hostdata);
+			break;
+		default:
+			printk(KERN_ERR "ibmvscsi: unknown crq message type\n");
+		}
+		return;
+	case 0xFF:		/* Hypervisor telling us the connection is closed */
+		printk(KERN_INFO "ibmvscsi: Virtual adapter failed!\n");
+
+		atomic_set(&hostdata->request_limit, -1);
+		purge_requests(hostdata);
+		return;
+	case 0x80:		/* real payload */
+		break;
+	default:
+		printk(KERN_ERR
+		       "ibmvscsi: got an invalid message type 0x%02x\n",
+		       crq->valid);
+		return;
+	}
+
+	/* The only kind of payload CRQs we should get are responses to
+	 * things we send. Make sure this response is to something we
+	 * actually sent
+	 */
+	if (!ibmvscsi_valid_event_struct(&hostdata->pool, evt_struct)) {
+		printk(KERN_ERR
+		       "ibmvscsi: returned correlation_token 0x%p is invalid!\n",
+		       (void *)crq->IU_data_ptr);
+		return;
+	}
+
+	if (crq->format == VIOSRP_SRP_FORMAT)
+		atomic_add(evt_struct->evt->srp.rsp.request_limit_delta,
+			   &hostdata->request_limit);
+
+	if (evt_struct->done)
+		evt_struct->done(evt_struct);
+	else
+		printk(KERN_ERR
+		       "ibmvscsi: returned done() is NULL; not running it!\n");
+
+	/*
+	 * Lock the host_lock before messing with these structures, since we
+	 * are running in a task context
+	 */
+	spin_lock_irqsave(evt_struct->hostdata->host->host_lock, flags);
+	list_del(&evt_struct->list);
+	ibmvscsi_free_event_struct(&evt_struct->hostdata->pool, evt_struct);
+	spin_unlock_irqrestore(evt_struct->hostdata->host->host_lock, flags);
+}
+
+/**
+ * ibmvscsi_get_host_config: Send the command to the server to get host
+ * configuration data.  The data is opaque to us.
+ */
+static int ibmvscsi_do_host_config(struct ibmvscsi_host_data *hostdata,
+				   unsigned char *buffer, int length)
+{
+	struct VIOSRP_HOST_CONFIG host_config;
+	struct srp_event_struct *evt_struct;
+	int rc;
+
+	memset(&host_config, 0x00, sizeof(host_config));
+	host_config.common.type = VIOSRP_HOST_CONFIG_TYPE;
+	host_config.common.length = length;
+	host_config.buffer = dma_map_single(hostdata->dev, buffer, length,
+					    DMA_BIDIRECTIONAL);
+
+	if (dma_mapping_error(host_config.buffer)) {
+		printk(KERN_ERR
+		       "ibmvscsi: dma_mapping error " "getting host config\n");
+		return -1;
+	}
+
+	evt_struct = evt_struct_for(&hostdata->pool,
+				    (union VIOSRP_IU *)&host_config,
+				    NULL, sync_completion);
+
+	if (!evt_struct) {
+		printk(KERN_ERR
+		       "ibmvscsi: could't allocate event for HOST_CONFIG!\n");
+		dma_unmap_single(hostdata->dev, host_config.buffer, length,
+				 DMA_BIDIRECTIONAL);
+		rc = -1;
+	} else {
+		evt_struct->crq.format = VIOSRP_MAD_FORMAT;
+		init_completion(&evt_struct->comp);
+		rc = ibmvscsi_send_srp_event(evt_struct, hostdata);
+		if (rc == 0) {
+			wait_for_completion(&evt_struct->comp);
+			dma_unmap_single(hostdata->dev, host_config.buffer, 
+					 length,
+					 DMA_BIDIRECTIONAL);
+		}
+	}
+
+
+	return rc ? rc : host_config.common.status;
+}
+
+/* ------------------------------------------------------------
+ * sysfs attributes
+ */
+static ssize_t show_host_srp_version(struct class_device *class_dev, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(class_dev);
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)shost->hostdata;
+	int len;
+
+	len = snprintf(buf, PAGE_SIZE, "%s\n",
+		       hostdata->madapter_info.srp_version);
+	return len;
+}
+
+static struct class_device_attribute ibmvscsi_host_srp_version = {
+	.attr = {
+		 .name = "srp_version",
+		 .mode = S_IRUGO,
+		 },
+	.show = show_host_srp_version,
+};
+
+static ssize_t show_host_partition_name(struct class_device *class_dev,
+					char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(class_dev);
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)shost->hostdata;
+	int len;
+
+	len = snprintf(buf, PAGE_SIZE, "%s\n",
+		       hostdata->madapter_info.partition_name);
+	return len;
+}
+
+static struct class_device_attribute ibmvscsi_host_partition_name = {
+	.attr = {
+		 .name = "partition_name",
+		 .mode = S_IRUGO,
+		 },
+	.show = show_host_partition_name,
+};
+
+static ssize_t show_host_partition_number(struct class_device *class_dev,
+					  char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(class_dev);
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)shost->hostdata;
+	int len;
+
+	len = snprintf(buf, PAGE_SIZE, "%d\n",
+		       hostdata->madapter_info.partition_number);
+	return len;
+}
+
+static struct class_device_attribute ibmvscsi_host_partition_number = {
+	.attr = {
+		 .name = "partition_number",
+		 .mode = S_IRUGO,
+		 },
+	.show = show_host_partition_number,
+};
+
+static ssize_t show_host_mad_version(struct class_device *class_dev, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(class_dev);
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)shost->hostdata;
+	int len;
+
+	len = snprintf(buf, PAGE_SIZE, "%d\n",
+		       hostdata->madapter_info.mad_version);
+	return len;
+}
+
+static struct class_device_attribute ibmvscsi_host_mad_version = {
+	.attr = {
+		 .name = "mad_version",
+		 .mode = S_IRUGO,
+		 },
+	.show = show_host_mad_version,
+};
+
+static ssize_t show_host_os_type(struct class_device *class_dev, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(class_dev);
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)shost->hostdata;
+	int len;
+
+	len = snprintf(buf, PAGE_SIZE, "%d\n", hostdata->madapter_info.os_type);
+	return len;
+}
+
+static struct class_device_attribute ibmvscsi_host_os_type = {
+	.attr = {
+		 .name = "os_type",
+		 .mode = S_IRUGO,
+		 },
+	.show = show_host_os_type,
+};
+
+static ssize_t show_host_config(struct class_device *class_dev, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(class_dev);
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)shost->hostdata;
+
+	/* returns null-terminated host config data */
+	if (ibmvscsi_do_host_config(hostdata, buf, PAGE_SIZE) == 0)
+		return strlen(buf);
+	else
+		return 0;
+}
+
+static struct class_device_attribute ibmvscsi_host_config = {
+	.attr = {
+		 .name = "config",
+		 .mode = S_IRUGO,
+		 },
+	.show = show_host_config,
+};
+
+static struct class_device_attribute *ibmvscsi_attrs[] = {
+	&ibmvscsi_host_srp_version,
+	&ibmvscsi_host_partition_name,
+	&ibmvscsi_host_partition_number,
+	&ibmvscsi_host_mad_version,
+	&ibmvscsi_host_os_type,
+	&ibmvscsi_host_config,
+	NULL
+};
+
+/* ------------------------------------------------------------
+ * SCSI driver registration
+ */
+static struct scsi_host_template driver_template = {
+	.module = THIS_MODULE,
+	.name = "SCSI host adapter emulator for RPA/iSeries Virtual I/O",
+	.proc_name = "ibmvscsi",
+	.queuecommand = ibmvscsi_queuecommand,
+	.eh_abort_handler = ibmvscsi_eh_abort_handler,
+	.eh_device_reset_handler = ibmvscsi_eh_device_reset_handler,
+	.cmd_per_lun = 16,
+	.can_queue = 1,		/* Updated after SRP_LOGIN */
+	.this_id = -1,
+	.sg_tablesize = MAX_INDIRECT_BUFS,
+	.use_clustering = ENABLE_CLUSTERING,
+	.shost_attrs = ibmvscsi_attrs,
+};
+
+/**
+ * Called by bus code for each adapter
+ */
+struct ibmvscsi_host_data *ibmvscsi_probe(struct device *dev)
+{
+	struct ibmvscsi_host_data *hostdata;
+	struct Scsi_Host *host;
+	unsigned long wait_switch = 0;
+
+	host = scsi_host_alloc(&driver_template, sizeof(*hostdata));
+	if (!host) {
+		printk(KERN_ERR "ibmvscsi: couldn't allocate host data\n");
+		goto scsi_host_alloc_failed;
+	}
+
+	hostdata = (struct ibmvscsi_host_data *)host->hostdata;
+	memset(hostdata, 0x00, sizeof(*hostdata));
+	INIT_LIST_HEAD(&hostdata->sent);
+	hostdata->host = host;
+	hostdata->dev = dev;
+	atomic_set(&hostdata->request_limit, -1);
+
+	if (ibmvscsi_init_crq_queue(&hostdata->queue, hostdata,
+				    max_requests) != 0) {
+		printk(KERN_ERR "ibmvscsi: couldn't initialize crq\n");
+		goto init_crq_failed;
+	}
+	if (initialize_event_pool(&hostdata->pool,
+				  max_requests, hostdata) != 0) {
+		printk(KERN_ERR "ibmvscsi: couldn't initialize event pool\n");
+		goto init_pool_failed;
+	}
+
+	host->max_lun = 8;
+	host->max_id = max_id;
+	host->max_channel = max_channel;
+
+	if (scsi_add_host(hostdata->host, hostdata->dev))
+		goto add_host_failed;
+
+	/* Try to send an initialization message.  Note that this is allowed
+	 * to fail if the other end is not acive.  In that case we don't
+	 * want to scan
+	 */
+	if (ibmvscsi_send_crq(hostdata, 0xC001000000000000, 0) == 0) {
+		/*
+		 * Wait around max init_timeout secs for the adapter to finish
+		 * initializing. When we are done initializing, we will have a
+		 * valid request_limit.  We don't want Linux scanning before
+		 * we are ready.
+		 */
+		for (wait_switch = jiffies + (init_timeout * HZ);
+		     time_before(jiffies, wait_switch) &&
+		     atomic_read(&hostdata->request_limit) < 0;) {
+
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(HZ/100);
+		}
+
+		/* if we now have a valid request_limit, initiate a scan */
+		if (atomic_read(&hostdata->request_limit) > 0)
+			scsi_scan_host(host);
+	}
+
+	return hostdata;
+
+      add_host_failed:
+	release_event_pool(&hostdata->pool, hostdata);
+      init_pool_failed:
+	ibmvscsi_release_crq_queue(&hostdata->queue, hostdata, max_requests);
+      init_crq_failed:
+	scsi_host_put(host);
+      scsi_host_alloc_failed:
+	return NULL;
+}
+
+void ibmvscsi_remove(struct ibmvscsi_host_data *hostdata)
+{
+	release_event_pool(&hostdata->pool, hostdata);
+	ibmvscsi_release_crq_queue(&hostdata->queue, hostdata, max_requests);
+
+	scsi_remove_host(hostdata->host);
+	scsi_host_put(hostdata->host);
+	return;
+}
diff -purN linux-2.6.5/drivers/scsi/ibmvscsi/ibmvscsi.h linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/ibmvscsi.h
--- linux-2.6.5/drivers/scsi/ibmvscsi/ibmvscsi.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/ibmvscsi.h	2004-04-26 09:29:59.000000000 +0000
@@ -0,0 +1,111 @@
+/* ------------------------------------------------------------
+ * ibmvscsi.h
+ * (C) Copyright IBM Corporation 1994, 2003
+ * Authors: Colin DeVilbiss (devilbis@us.ibm.com)
+ *          Santiago Leon (santil@us.ibm.com)
+ *          Dave Boutcher (sleddog@us.ibm.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * ------------------------------------------------------------
+ * Emulation of a SCSI host adapter for Virtual I/O devices
+ *
+ * This driver allows the Linux SCSI peripheral drivers to directly
+ * access devices in the hosting partition, either on an iSeries
+ * hypervisor system or a converged hypervisor system.
+ */
+#ifndef IBMVSCSI_H
+#define IBMVSCSI_H
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h> 
+#include "viosrp.h"
+
+struct scsi_cmnd;
+struct Scsi_Host;
+/**
+ * Work out the number of scatter/gather buffers we support
+ */
+static const struct SRP_CMD *fake_srp_cmd = NULL;
+enum {
+	MAX_INDIRECT_BUFS = (sizeof(fake_srp_cmd->additional_data) -
+			     sizeof(struct indirect_descriptor)) /
+	    sizeof(struct memory_descriptor)
+};
+
+/* ------------------------------------------------------------
+ * Data Structures
+ */
+/* an RPA command/response transport queue */
+struct crq_queue {
+	struct VIOSRP_CRQ *msgs;
+	int size, cur;
+	dma_addr_t msg_token;
+	spinlock_t lock;
+};
+
+/* a unit of work for the hosting partition */
+struct srp_event_struct {
+	union VIOSRP_IU *evt;
+	struct scsi_cmnd *cmnd;
+	struct list_head list;
+	void (*done) (struct srp_event_struct *);
+	struct VIOSRP_CRQ crq;
+	struct ibmvscsi_host_data *hostdata;
+	char in_use;
+	struct SRP_CMD cmd;
+	void (*cmnd_done) (struct scsi_cmnd *);
+	struct completion comp;
+};
+
+/* a pool of event structs for use */
+struct event_pool {
+	struct srp_event_struct *events;
+	u32 size;
+	union VIOSRP_IU *iu_storage;
+	dma_addr_t iu_token;
+};
+
+/* all driver data associated with a host adapter */
+struct ibmvscsi_host_data {
+	atomic_t request_limit;
+	struct device *dev;
+	struct event_pool pool;
+	struct crq_queue queue;
+	struct tasklet_struct srp_task;
+	struct list_head sent;
+	struct Scsi_Host *host;
+	struct MAD_ADAPTER_INFO_DATA madapter_info;
+};
+
+/* routines for managing a command/response queue */
+int ibmvscsi_init_crq_queue(struct crq_queue *queue,
+			    struct ibmvscsi_host_data *hostdata,
+			    int max_requests);
+void ibmvscsi_release_crq_queue(struct crq_queue *queue,
+				struct ibmvscsi_host_data *hostdata,
+				int max_requests);
+void ibmvscsi_handle_crq(struct VIOSRP_CRQ *crq,
+			 struct ibmvscsi_host_data *hostdata);
+int ibmvscsi_send_crq(struct ibmvscsi_host_data *hostdata,
+		      u64 word1, u64 word2);
+
+/* Probe/remove routines */
+struct ibmvscsi_host_data *ibmvscsi_probe(struct device *dev);
+void ibmvscsi_remove(struct ibmvscsi_host_data *hostdata);
+
+#endif				/* IBMVSCSI_H */
diff -purN linux-2.6.5/drivers/scsi/ibmvscsi/ibmvscsis.c linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/ibmvscsis.c
--- linux-2.6.5/drivers/scsi/ibmvscsi/ibmvscsis.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/ibmvscsis.c	2004-04-26 09:30:21.000000000 +0000
@@ -0,0 +1,2637 @@
+/**************************************************************************/
+/* -*- -linux- -*-                                                        */
+/* IBM eServer i/pSeries Virtual SCSI Target Driver                       */
+/* Copyright (C) 2003 Dave Boutcher (boutcher@us.ibm.com) IBM Corp.       */
+/*                                                                        */
+/*  This program is free software; you can redistribute it and/or modify  */
+/*  it under the terms of the GNU General Public License as published by  */
+/*  the Free Software Foundation; either version 2 of the License, or     */
+/*  (at your option) any later version.                                   */
+/*                                                                        */
+/*  This program is distributed in the hope that it will be useful,       */
+/*  but WITHOUT ANY WARRANTY; without even the implied warranty of        */
+/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */
+/*  GNU General Public License for more details.                          */
+/*                                                                        */
+/*  You should have received a copy of the GNU General Public License     */
+/*  along with this program; if not, write to the Free Software           */
+/*  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  */
+/*                                                                   USA  */
+/*                                                                        */
+/* This module contains the eServer virtual SCSI target code.  The driver */
+/* takes SRP requests from the virtual SCSI client (the linux version is  */
+/* int ibmvscsi.c, but there can be other clients, like AIX or OF) and    */
+/* passes them on to real devices in this system.                         */
+/*                                                                        */
+/* The basic hierarchy (and somewhat the organization of this file) is    */
+/* that SCSI CDBs are in SRPs are in CRQs.                                */
+/*                                                                        */
+/**************************************************************************/
+/*
+  TODO:
+  - Support redirecting SRP SCSI requests to a real SCSI driver
+*/
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/blkdev.h>
+#include <linux/fs.h>
+#include <linux/bio.h>
+
+#include <asm/hvcall.h>
+#include <asm/vio.h>
+#include <asm/iommu.h>
+
+#include "../scsi.h"
+#include "viosrp.h"
+
+MODULE_DESCRIPTION("IBM Virtual SCSI Target");
+MODULE_AUTHOR("Dave Boutcher");
+MODULE_LICENSE("GPL");
+
+static int ibmvscsis_debug = 0;
+
+/*
+ * Quick macro to enable/disable interrupts
+ * TODO: move to vio.h to be common with ibmvscsi.c
+ */
+#define h_vio_signal(ua, mode) \
+  plpar_hcall_norets(H_VIO_SIGNAL, ua, mode)
+
+/* 
+ * These are indexes into the following table, and have to match!!!
+ */
+#define SENSE_SUCCESS       0
+#define SENSE_ABORT         1
+#define SENSE_INVALID_ID    2
+#define SENSE_DEVICE_FAULT  3
+#define SENSE_DEVICE_BUSY   4
+#define SENSE_UNIT_OFFLINE  5
+#define SENSE_INVALID_CMD   6
+#define SENSE_INTERMEDIATE  7
+#define SENSE_WRITE_PROT    8
+
+static unsigned char ibmvscsis_sense_data[][3] = {
+/*
+ * Sense key lookup table
+ * Format: SenseKey,AdditionalSenseCode,AdditionalSenseCodeQualifier
+ * Adapted from 3w-xxxx.h
+ */
+	{0x00, 0x00, 0x00},	/* Success           */
+	{0x0b, 0x00, 0x00},	/* Aborted command   */
+	{0x0b, 0x14, 0x00},	/* ID not found      */
+	{0x04, 0x00, 0x00},	/* Device fault      */
+	{0x0b, 0x00, 0x00},	/* Device busy       */
+	{0x02, 0x04, 0x00},	/* Unit offline      */
+	{0x20, 0x04, 0x00},	/* Invalid Command   */
+	{0x10, 0x00, 0x00},	/* Intermediate      */
+	{0x07, 0x27, 0x00},	/* Write Protected   */
+};
+
+/*
+ * SCSI defined structure for inquiry data
+ * TODO: Seral number is currently messed up if you do
+ *       scsiinfo.  I'm not sure why and I think it comes out of 
+ *       here
+ */
+struct inquiry_data {
+	u8 qual_type;
+	u8 rmb_reserve;
+	u8 version;
+	u8 aerc_naca_hisup_format;
+	u8 addl_len;
+	u8 sccs_reserved;
+	u8 bque_encserv_vs_multip_mchngr_reserved;
+	u8 reladr_reserved_linked_cmdqueue_vs;
+	char vendor[8];
+	char product[16];
+	char revision[4];
+	char vendor_specific[20];
+	char reserved1[2];
+	char version_descriptor[16];
+	char reserved2[22];
+};
+
+/*
+ * Our proc dir entry under /proc/drivers.  We use proc to configure
+ * this driver right now.
+ * TODO: For 2.5 move to sysfs
+ */
+#ifdef CONFIG_PROC_FS
+#define IBMVSCSIS_PROC_DIR "ibmvscsis"
+static struct proc_dir_entry *ibmvscsis_proc_dir;
+#endif
+
+extern int vio_num_address_cells;
+
+/* 
+ * an RPA command/response transport queue.  This is our structure
+ * that points to the actual queue.  feel free to modify this structure
+ * as needed
+ */
+struct crq_queue {
+	struct VIOSRP_CRQ *msgs;
+	int size, cur;
+	dma_addr_t msg_token;
+	spinlock_t lock;
+};
+
+/*
+ * This structure tracks our fundamental unit of work.  Whenever
+ * an SRP Information Unit (IU) arrives, we track all the good stuff
+ * here
+ */
+struct iu_entry {
+	union VIOSRP_IU *iu;
+	struct server_adapter *adapter;
+	struct list_head next;
+	dma_addr_t iu_token;
+	int aborted;
+	struct {
+		dma_addr_t remote_token;
+		char *data_buffer;
+		dma_addr_t data_token;
+		long data_len;
+		struct vdev *vd;
+		char in_use:1;
+		char diunder:1;
+		char diover:1;
+		char dounder:1;
+		char doover:1;
+		char write:1;
+		char linked:1;
+		int data_out_residual_count;
+		int data_in_residual_count;
+		int ioerr;
+	} req;
+};
+
+/* 
+ * a pool of ius for use 
+ */
+struct iu_pool {
+	spinlock_t lock;
+	struct list_head iu_entries;
+	struct iu_entry *list;
+	union VIOSRP_IU *iu_storage;
+	dma_addr_t iu_token;
+	u32 size;
+};
+
+/*
+ * Represents a single device that someone told us about
+ * that we treat as a LUN
+ */
+struct vdev {
+	struct list_head list;
+	char type;		/* 'B' for block, 'S' for SCSI */
+	atomic_t refcount;
+	int disabled;
+	u64 lun;
+	struct {
+		struct block_device *bdev;
+		dev_t dev;
+		long blksize;
+		long lastlba;
+		int ro;
+	} b;
+};
+
+/*
+ * Represents a bus.  target #'s in SCSI are 6 bits long,
+ * so you can have 64 targets per bus
+ */
+#define TARGETS_PER_BUS (64)
+#define BUS_PER_ADAPTER (8)
+struct vbus {
+	struct vdev *vdev[TARGETS_PER_BUS];
+};
+
+/*
+ * Buffer cache
+ */
+struct dma_buffer {
+	dma_addr_t token;
+	char *addr;
+	size_t len;
+};
+#define DMA_BUFFER_CACHE_SIZE (16)
+#define DMA_BUFFER_INIT_COUNT (4)
+#define DMA_BUFFER_INIT_LEN (PAGE_SIZE*16)
+
+/* all driver data associated with a host adapter */
+struct server_adapter {
+	struct device *dev;
+	struct vio_dev *dma_dev;
+	struct crq_queue queue;
+	struct tasklet_struct crq_tasklet;
+	struct tasklet_struct endio_tasklet;
+	atomic_t crq_task_count;	/* TODO: this is only for debugging. get rid of it */
+	atomic_t endio_task_count;	/* TODO: this is only for debugging. get rid of it */
+	struct iu_pool pool;
+	spinlock_t lock;
+	struct bio *bio_done;
+	struct bio *bio_donetail;
+	struct list_head inflight;
+	struct vbus *vbus[8];
+	int nvdevs;
+	char name[32];
+	unsigned long liobn;
+	unsigned long riobn;
+
+	/* This ugly expression allocates a bit array of 
+	 * in-use flags large enough for the number of buffers
+	 */
+	unsigned long dma_buffer_use[(DMA_BUFFER_CACHE_SIZE +
+				      sizeof(unsigned long) - 1)
+				     / sizeof(unsigned long)];
+	struct dma_buffer dma_buffer[DMA_BUFFER_CACHE_SIZE];
+
+	/* Statistics only */
+	atomic_t iu_count;	/* number allocated */
+	atomic_t bio_count;	/* number allocated */
+	atomic_t crq_processed;
+	atomic_t interrupts;
+	atomic_t read_processed;
+	atomic_t write_processed;
+	atomic_t buffers_allocated;
+	atomic_t errors;
+};
+
+/* 
+ * Forward declarations
+ */
+static long send_rsp(struct iu_entry *iue, int status);
+
+/*
+ * The following are lifted from usb.h
+ */
+#define DEBUG 1
+#ifdef DEBUG
+#define dbg(format, arg...) if (ibmvscsis_debug) printk(KERN_WARNING __FILE__ ": " format , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) printk(KERN_ERR __FILE__ ": " format , ## arg)
+#define info(format, arg...) printk(KERN_INFO __FILE__ ": " format  , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING __FILE__ ": " format , ## arg)
+
+/* ==============================================================
+ * Utility Routines
+ * ==============================================================
+ */
+/*
+ * return an 8 byte lun given a bus, target, lun.  
+ * Today this only supports single level luns.  Should we add a level or a
+ * 64 bit LUN as input to support multi-level luns?
+ */
+u64 make_lun(unsigned int bus, unsigned int target, unsigned int lun)
+{
+	u16 result = (0x8000 |
+		      ((target & 0x003f) << 8) |
+		      ((bus & 0x0007) << 5) | (lun & 0x001f));
+	return ((u64) result) << 48;
+}
+
+/*
+ * Given an 8 byte LUN, return the first level bus/target/lun.
+ * Today this doesn't support multi-level LUNs
+ */
+#define GETBUS(x) ((int)((((u64)(x)) >> 53) & 0x0007))
+#define GETTARGET(x) ((int)((((u64)(x)) >> 56) & 0x003f))
+#define GETLUN(x) ((int)((((u64)(x)) >> 48) & 0x001f))
+
+static u8 getcontrolbyte(u8 * cdb)
+{
+	return cdb[COMMAND_SIZE(cdb[0]) - 1];
+}
+
+static u8 getlink(struct iu_entry *iue)
+{
+	return (getcontrolbyte(iue->iu->srp.cmd.cdb) & 0x01);
+}
+
+/*
+ * Given an SRP, figure out the data in length
+ */
+static int did_len(struct SRP_CMD *cmd)
+{
+	struct memory_descriptor *md;
+	struct indirect_descriptor *id;
+	int offset = cmd->additional_cdb_len * 4;
+
+	switch (cmd->data_out_format) {
+	case SRP_NO_BUFFER:
+		offset += 0;
+		break;
+	case SRP_DIRECT_BUFFER:
+		offset += sizeof(struct memory_descriptor);
+		break;
+	case SRP_INDIRECT_BUFFER:
+		offset += sizeof(struct indirect_descriptor)
+		    +
+		    ((cmd->data_out_count -
+		      1) * sizeof(struct memory_descriptor));
+		break;
+	default:
+		err("ibmvscsis: did_len Invalid data_out_format %d\n",
+		    cmd->data_out_format);
+		return 0;
+	}
+
+	switch (cmd->data_in_format) {
+	case SRP_NO_BUFFER:
+		return 0;
+	case SRP_DIRECT_BUFFER:
+		md = (struct memory_descriptor *)(cmd->additional_data +
+						  offset);
+		return md->length;
+	case SRP_INDIRECT_BUFFER:
+		id = (struct indirect_descriptor *)(cmd->additional_data +
+						    offset);
+		return id->total_length;
+	default:
+		err("ibmvscsis: Invalid data_in_format %d\n",
+		    cmd->data_in_format);
+		return 0;
+	}
+}
+
+/* 
+ * We keep a pool of IUs, this routine builds the pool.  The pool is 
+ * per-adapter.  The size of the pool is negotiated as part of the SRP
+ * login, where we negotiate the number of requests (IUs) the client
+ * can send us.  This routine is not synchronized.
+ */
+static int initialize_iu_pool(struct server_adapter *adapter, int size)
+{
+	struct iu_pool *pool = &adapter->pool;
+	int i;
+
+	pool->size = size;
+	pool->lock = SPIN_LOCK_UNLOCKED;
+	INIT_LIST_HEAD(&pool->iu_entries);
+
+	pool->list = kmalloc(pool->size * sizeof(*pool->list), GFP_KERNEL);
+	if (!pool->list) {
+		err("Error: no memory for IU list\n");
+		return -ENOMEM;
+	}
+	memset(pool->list, 0x00, pool->size * sizeof(*pool->list));
+
+	pool->iu_storage =
+	    dma_alloc_coherent(adapter->dev,
+			       pool->size * sizeof(*pool->iu_storage),
+			       &pool->iu_token, 0);
+	if (!pool->iu_storage) {
+		err("Error: no memory for IU pool\n");
+		kfree(pool->list);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < pool->size; ++i) {
+		pool->list[i].iu = pool->iu_storage + i;
+		pool->list[i].iu_token =
+		    pool->iu_token + sizeof(*pool->iu_storage) * i;
+		pool->list[i].adapter = adapter;
+		list_add_tail(&pool->list[i].next, &pool->iu_entries);
+	}
+
+	return 0;
+}
+
+/*
+ * Free the pool we allocated in initialize_iu_pool
+ */
+static void release_iu_pool(struct server_adapter *adapter)
+{
+	struct iu_pool *pool = &adapter->pool;
+	int i, in_use = 0;
+	for (i = 0; i < pool->size; ++i)
+		if (pool->list[i].req.in_use)
+			++in_use;
+	if (in_use)
+		err("ibmvscsis: releasing event pool with %d events still in use?\n", in_use);
+	kfree(pool->list);
+	dma_free_coherent(adapter->dev, pool->size * sizeof(*pool->iu_storage),
+			  pool->iu_storage, pool->iu_token);
+}
+
+/*
+ * Get an IU from the pool.  Return NULL of the pool is empty.  This
+ * routine is syncronized by a lock.  The routine sets all the important
+ * fields to 0
+ */
+static struct iu_entry *get_iu(struct server_adapter *adapter)
+{
+	struct iu_entry *e;
+	unsigned long flags;
+
+	spin_lock_irqsave(&adapter->pool.lock, flags);
+	if (!list_empty(&adapter->pool.iu_entries)) {
+		e = list_entry(adapter->pool.iu_entries.next, struct iu_entry,
+			       next);
+		list_del(adapter->pool.iu_entries.next);
+
+		if (e->req.in_use) {
+			err("Found in-use iue in pool!");
+		}
+
+		memset(&e->req, 0x00, sizeof(e->req));
+
+		e->req.in_use = 1;
+	} else {
+		e = NULL;
+	}
+
+	spin_unlock_irqrestore(&adapter->pool.lock, flags);
+	atomic_inc(&adapter->iu_count);
+	return e;
+}
+
+/* 
+ * Return an IU to the pool.  This routine is synchronized
+ */
+static void free_iu(struct iu_entry *iue)
+{
+	unsigned long flags;
+	if (iue->req.vd) {
+		atomic_dec(&iue->req.vd->refcount);
+	}
+
+	spin_lock_irqsave(&iue->adapter->pool.lock, flags);
+	if (iue->req.in_use == 0) {
+		warn("ibmvscsis: Internal error, freeing iue twice!\n");
+	} else {
+		iue->req.in_use = 0;
+		list_add_tail(&iue->next, &iue->adapter->pool.iu_entries);
+	}
+	spin_unlock_irqrestore(&iue->adapter->pool.lock, flags);
+	atomic_dec(&iue->adapter->iu_count);
+}
+
+/*
+ * Get a CRQ from the inter-partition queue.
+ */
+static struct VIOSRP_CRQ *crq_queue_next_crq(struct crq_queue *queue)
+{
+	struct VIOSRP_CRQ *crq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&queue->lock, flags);
+	crq = &queue->msgs[queue->cur];
+	if (crq->valid & 0x80) {
+		if (++queue->cur == queue->size)
+			queue->cur = 0;
+	} else
+		crq = NULL;
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+	return crq;
+}
+
+/* 
+ * Make the RDMA hypervisor call.  There should be a better way to do this
+ * than inline assembler.
+ * TODO: Fix the inline assembler
+ */
+static long h_copy_rdma(long length,
+			unsigned long sliobn, unsigned long slioba,
+			unsigned long dliobn, unsigned long dlioba)
+{
+	long lpar_rc = 0;
+	__asm__ __volatile__(" li 3,0x110 \n\t"
+			     " mr 4, %1 \n\t"
+			     " mr 5, %2 \n\t"
+			     " mr 6, %3 \n\t"
+			     " mr 7, %4 \n\t"
+			     " mr 8, %5 \n\t"
+			     " .long 0x44000022 \n\t"
+			     " mr %0, 3 \n\t":"=&r"(lpar_rc)
+			     :"r"(length), "r"(sliobn), "r"(slioba),
+			     "r"(dliobn), "r"(dlioba)
+			     :"r0", "r3", "r4", "r5", "r6", "r7", "r8", "cr0",
+			     "cr1", "ctr", "xer", "memory");
+	return lpar_rc;
+}
+
+/*
+ * Send an SRP to another partition using the CRQ.
+ */
+static int send_srp(struct iu_entry *iue, u64 length)
+{
+	long rc, rc1;
+	union {
+		struct VIOSRP_CRQ cooked;
+		u64 raw[2];
+	} crq;
+
+	/* First copy the SRP */
+	rc = h_copy_rdma(length,
+			 iue->adapter->liobn,
+			 iue->iu_token,
+			 iue->adapter->riobn, iue->req.remote_token);
+
+	if (rc) {
+		err("Error: In send_srp, h_copy_rdma rc %ld\n", rc);
+	}
+
+	crq.cooked.valid = 0x80;
+	crq.cooked.format = VIOSRP_SRP_FORMAT;
+	crq.cooked.reserved = 0x00;
+	crq.cooked.timeout = 0x00;
+	crq.cooked.IU_length = length;
+	crq.cooked.IU_data_ptr = iue->iu->srp.generic.tag;
+
+	if (rc == 0) {
+		crq.cooked.status = 0x99;	/* TODO: is this right? */
+	} else {
+		crq.cooked.status = 0x00;
+	}
+
+	rc1 =
+	    plpar_hcall_norets(H_SEND_CRQ, iue->adapter->dma_dev->unit_address,
+			       crq.raw[0], crq.raw[1]);
+
+	if (rc1) {
+		err("ibmvscscsis Error: In send_srp, h_send_crq rc %ld\n", rc1);
+		return rc1;
+	}
+
+	return rc;
+}
+
+/*
+ * Send data to a single SRP memory descriptor
+ * Returns amount of data sent, or negative value on error
+ */
+static long send_md_data(dma_addr_t stoken, int len,
+			 struct memory_descriptor *md,
+			 struct server_adapter *adapter)
+{
+	int tosend;
+	long rc;
+
+	if (len < md->length)
+		tosend = len;
+	else
+		tosend = md->length;
+
+	rc = h_copy_rdma(tosend,
+			 adapter->liobn,
+			 stoken, adapter->riobn, md->virtual_address);
+
+	if (rc != H_Success) {
+		err("Error sending data with h_copy_rdma, rc %ld\n", rc);
+		return -1;
+	}
+
+	return tosend;
+}
+
+/*
+ * Send data to the SRP data_in buffers
+ * Returns amount of data sent, or negative value on error
+ */
+static long send_cmd_data(dma_addr_t stoken, int len, struct iu_entry *iue)
+{
+	struct SRP_CMD *cmd = &iue->iu->srp.cmd;
+	struct memory_descriptor *md;
+	struct indirect_descriptor *id;
+	int offset = 0;
+	int total_length = 0;
+	int i;
+	int thislen;
+	int bytes;
+	int sentlen = 0;
+
+	offset = cmd->additional_cdb_len * 4;
+
+	switch (cmd->data_out_format) {
+	case SRP_NO_BUFFER:
+		offset += 0;
+		break;
+	case SRP_DIRECT_BUFFER:
+		offset += sizeof(struct memory_descriptor);
+		break;
+	case SRP_INDIRECT_BUFFER:
+		offset += sizeof(struct indirect_descriptor)
+		    +
+		    ((cmd->data_out_count -
+		      1) * sizeof(struct memory_descriptor));
+		break;
+	default:
+		err("Error: did_len Invalid data_out_format %d\n",
+		    cmd->data_out_format);
+		return 0;
+	}
+
+	switch (cmd->data_in_format) {
+	case SRP_NO_BUFFER:
+		return 0;
+	case SRP_DIRECT_BUFFER:
+		md = (struct memory_descriptor *)(cmd->additional_data +
+						  offset);
+		return send_md_data(stoken, len, md, iue->adapter);
+	}
+
+	if (cmd->data_in_format != SRP_INDIRECT_BUFFER) {
+		err("Error: send_cmd_data Invalid data_in_format %d\n",
+		    cmd->data_in_format);
+		return 0;
+	}
+
+	id = (struct indirect_descriptor *)(cmd->additional_data + offset);
+
+	total_length = id->total_length;
+
+	/* Work through the partial memory descriptor list */
+	for (i = 0; ((i < cmd->data_in_count) && (len)); i++) {
+		if (len > id->list[i].length) {
+			thislen = id->list[i].length;
+		} else {
+			thislen = len;
+		}
+
+		bytes =
+		    send_md_data(stoken + sentlen, thislen, id->list + i,
+				 iue->adapter);
+		if (bytes < 0)
+			return bytes;
+
+		if (bytes != thislen) {
+			warn("Error: Tried to send %d, sent %d\n", thislen,
+			     bytes);
+		}
+
+		sentlen += bytes;
+		total_length -= bytes;
+		len -= bytes;
+	}
+
+	if (len) {
+		warn("Left over data sending to indirect buffer\n");
+		iue->req.diover = 1;
+		iue->req.data_in_residual_count = len;
+	}
+
+	return sentlen;
+}
+
+/*
+ * Get data from the other partition from a single SRP memory descriptor
+ * Returns amount of data sent, or negative value on error
+ */
+static long get_md_data(dma_addr_t ttoken, int len,
+			struct memory_descriptor *md,
+			struct server_adapter *adapter)
+{
+	int toget;
+	long rc;
+
+	if (len < md->length)
+		toget = len;
+	else
+		toget = md->length;
+
+	rc = h_copy_rdma(toget,
+			 adapter->riobn,
+			 md->virtual_address, adapter->liobn, ttoken);
+
+	if (rc != H_Success) {
+		err("Error sending data with h_copy_rdma, rc %ld\n", rc);
+		return -1;
+	}
+
+	return toget;
+}
+
+/*
+ * Get data from an SRP data in area.
+ * Returns amount of data sent, or negative value on error
+ */
+static long get_cmd_data(dma_addr_t stoken, int len, struct iu_entry *iue)
+{
+	struct SRP_CMD *cmd = &iue->iu->srp.cmd;
+	struct memory_descriptor *md;
+	struct indirect_descriptor *id;
+	int offset = 0;
+	int total_length = 0;
+	int i;
+	int thislen;
+	int bytes;
+	int sentlen = 0;
+
+	offset = cmd->additional_cdb_len * 4;
+
+	switch (cmd->data_out_format) {
+	case SRP_NO_BUFFER:
+		return 0;
+		break;
+	case SRP_DIRECT_BUFFER:
+		md = (struct memory_descriptor *)(cmd->additional_data +
+						  offset);
+		return get_md_data(stoken, len, md, iue->adapter);
+		break;
+	}
+
+	if (cmd->data_out_format != SRP_INDIRECT_BUFFER) {
+		err("get_cmd_data Invalid data_out_format %d\n",
+		    cmd->data_out_format);
+		return 0;
+	}
+
+	id = (struct indirect_descriptor *)(cmd->additional_data + offset);
+
+	total_length = id->total_length;
+
+	/* Work through the partial memory descriptor list */
+	for (i = 0; ((i < cmd->data_out_count) && (len)); i++) {
+		if (len > id->list[i].length) {
+			thislen = id->list[i].length;
+		} else {
+			thislen = len;
+		}
+
+		bytes =
+		    get_md_data(stoken + sentlen, thislen, id->list + i,
+				iue->adapter);
+		if (bytes < 0)
+			return bytes;
+
+		if (bytes != thislen) {
+			err("Tried to send %d, sent %d\n", thislen, bytes);
+		}
+
+		sentlen += bytes;
+		total_length -= bytes;
+		len -= bytes;
+	}
+
+	if (len) {
+		warn("Left over data get indirect buffer\n");
+	}
+
+	return sentlen;
+}
+
+/*
+ * Get some data buffers to start.  This doesn't lock the adapter structure!
+ */
+static void init_data_buffer(struct server_adapter *adapter)
+{
+	int i;
+
+	for (i = 0; i < DMA_BUFFER_INIT_COUNT; i++) {
+		if (adapter->dma_buffer[i].addr == NULL) {
+			adapter->dma_buffer[i].addr = (char *)
+			    dma_alloc_coherent(adapter->dev,
+					       DMA_BUFFER_INIT_LEN,
+					       &adapter->dma_buffer[i].token,
+					       0);
+			adapter->dma_buffer[i].len = DMA_BUFFER_INIT_LEN;
+			dbg("data buf %p token %8.8x, len %ld\n",
+			    adapter->dma_buffer[i].addr,
+			    adapter->dma_buffer[i].token,
+			    adapter->dma_buffer[i].len);
+			atomic_inc(&adapter->buffers_allocated);
+		}
+	}
+
+	return;
+}
+
+/*
+ * Get a memory buffer that includes a mapped TCE.  
+ */
+static void get_data_buffer(char **buffer, dma_addr_t * data_token, size_t len,
+			    struct server_adapter *adapter)
+{
+	int i;
+
+	for (i = 0; i < DMA_BUFFER_CACHE_SIZE; i++) {
+		if ((adapter->dma_buffer[i].addr) &&
+		    (adapter->dma_buffer[i].len >= len) &&
+		    (!test_and_set_bit(i, adapter->dma_buffer_use))) {
+			*buffer = adapter->dma_buffer[i].addr;
+			*data_token = adapter->dma_buffer[i].token;
+			return;
+		}
+	}
+
+	/* Couldn't get a buffer!  Try and get a new one */
+	*buffer = (char *)dma_alloc_coherent(adapter->dev, len, data_token, 0);
+	atomic_inc(&adapter->buffers_allocated);
+	dbg("get:  %p, %8.8x, %ld\n", *buffer, *data_token, len);
+	return;
+}
+
+/*
+ * Free a memory buffer that includes a mapped TCE.  
+ */
+static void free_data_buffer(char *buffer, dma_addr_t data_token, size_t len,
+			     struct server_adapter *adapter)
+{
+	int i;
+
+	/* First see if this buffer is already in the cache */
+	for (i = 0; i < DMA_BUFFER_CACHE_SIZE; i++) {
+		if (adapter->dma_buffer[i].addr == buffer) {
+			if (adapter->dma_buffer[i].token != data_token) {
+				err("Incoherent data buffer pool info!\n");
+			}
+			if (!test_and_clear_bit(i, adapter->dma_buffer_use)) {
+				err("Freeing data buffer twice!\n");
+			}
+			return;
+		}
+	}
+
+	/* See if there is an empty slot in our list */
+	for (i = 0; i < DMA_BUFFER_CACHE_SIZE; i++) {
+		if (!test_and_set_bit(i, adapter->dma_buffer_use)) {
+			if (adapter->dma_buffer[i].addr == NULL) {
+				adapter->dma_buffer[i].addr = buffer;
+				adapter->dma_buffer[i].token = data_token;
+				adapter->dma_buffer[i].len = len;
+				clear_bit(i, adapter->dma_buffer_use);
+				return;
+			} else {
+				clear_bit(i, adapter->dma_buffer_use);
+			}
+		}
+	}
+
+	/* Now see if there is a smaller buffer we should throw out */
+	for (i = 0; i < DMA_BUFFER_CACHE_SIZE; i++) {
+		if (!test_and_set_bit(i, adapter->dma_buffer_use)) {
+			if (adapter->dma_buffer[i].len < len) {
+				dbg("fre1: %p, %8.8x, %ld\n",
+				    adapter->dma_buffer[i].addr,
+				    adapter->dma_buffer[i].token,
+				    adapter->dma_buffer[i].len);
+
+				dma_free_coherent(adapter->dev,
+						  adapter->dma_buffer[i].len,
+						  adapter->dma_buffer[i].addr,
+						  adapter->dma_buffer[i].token);
+
+				atomic_dec(&adapter->buffers_allocated);
+
+				adapter->dma_buffer[i].addr = buffer;
+				adapter->dma_buffer[i].token = data_token;
+				adapter->dma_buffer[i].len = len;
+				clear_bit(i, adapter->dma_buffer_use);
+				return;
+			} else {
+				clear_bit(i, adapter->dma_buffer_use);
+			}
+		}
+	}
+
+	/* No space to cache this.  Give it back to the kernel */
+	dbg("fre2: %p, %8.8x, %ld\n", buffer, data_token, len);
+	dma_free_coherent(adapter->dev, len, buffer, data_token);
+	atomic_dec(&adapter->buffers_allocated);
+}
+
+/*
+ * Release all the data buffers
+ */
+static void release_data_buffer(struct server_adapter *adapter)
+{
+	int i;
+	int free_in_use = 0;
+
+	for (i = 0; i < DMA_BUFFER_INIT_COUNT; i++) {
+		if (adapter->dma_buffer[i].addr != NULL) {
+			if (test_bit(i, adapter->dma_buffer_use)) {
+				free_in_use++;
+			}
+			dma_free_coherent(adapter->dev,
+					  adapter->dma_buffer[i].len,
+					  adapter->dma_buffer[i].addr,
+					  adapter->dma_buffer[i].token);
+
+			atomic_dec(&adapter->buffers_allocated);
+		}
+	}
+
+	if (free_in_use) {
+		err("Freeing %d in-use data buffers\n", free_in_use);
+	}
+	return;
+}
+
+/*
+ * the routine that gets called on end_io of our bios.  We basically
+ * schedule the processing to be done in our task, since we don't want
+ * do things like RDMA in someone else's interrupt handler
+ *
+ * Each iu request may result in multiple bio requests.  only proceed
+ * when all the bio requests have done.
+ */
+static int ibmvscsis_end_io(struct bio *bio, unsigned int nbytes, int error)
+{
+	struct iu_entry *iue = (struct iu_entry *)bio->bi_private;
+	struct server_adapter *adapter = iue->adapter;
+	unsigned long flags;
+
+	if (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {
+		iue->req.ioerr = 1;
+	};
+
+	/* Add the bio to the done queue */
+	spin_lock_irqsave(&adapter->lock, flags);
+	if (adapter->bio_donetail) {
+		adapter->bio_donetail->bi_next = bio;
+		adapter->bio_donetail = bio;
+	} else
+		adapter->bio_done = adapter->bio_donetail = bio;
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* Schedule the task */
+	tasklet_schedule(&adapter->endio_tasklet);
+
+	return 0;
+}
+
+/*
+ * Find the vdev structure from the LUN field in an SRP IUE
+ * Note that this routine bumps a refcount field in the vdev.
+ * Normally this is done when free_iu is called.
+ */
+static struct vdev *find_device(struct iu_entry *iue)
+{
+	u16 *lun = (u16 *) & iue->iu->srp.cmd.lun;
+	u32 bus = (lun[0] & 0x00E0) >> 5;
+	u32 target = (lun[0] & 0x3F00) >> 8;
+	u32 slun = (lun[0] & 0x001F);
+	struct vdev *vd;
+	unsigned long flags;
+
+	/* If asking for a lun other than 0, return nope */
+	if (slun) {
+		return NULL;
+	}
+
+	/* Only from SRP CMD */
+	if (iue->iu->srp.generic.type != SRP_CMD_TYPE)
+		return NULL;
+
+	/* if not a recognized LUN format, return NULL */
+	if ((lun[0] & 0xC000) != 0x8000)
+		return NULL;
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+	if (iue->adapter->vbus[bus] == NULL) {
+		spin_unlock_irqrestore(&iue->adapter->lock, flags);
+		return NULL;
+	}
+
+	vd = iue->adapter->vbus[bus]->vdev[target];
+
+	if ((vd == NULL) || (vd->disabled)) {
+		spin_unlock_irqrestore(&iue->adapter->lock, flags);
+		return NULL;
+	}
+
+	if (vd) {
+		atomic_inc(&vd->refcount);
+	}
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+
+	return vd;
+}
+
+/*
+ * Process BH buffer completions.  When the end_io routine gets called 
+ * we queue the bio on an internal queue and start a task to process them
+ */
+static void endio_task(unsigned long data)
+{
+	struct server_adapter *adapter = (struct server_adapter *)data;
+	struct iu_entry *iue;
+	struct bio *bio;
+	int bytes;
+	unsigned long flags;
+
+	if (atomic_inc_return(&adapter->endio_task_count) > 1) {
+		err("In endio_task twice!!!\n");
+	}
+
+	do {
+		spin_lock_irqsave(&adapter->lock, flags);
+		if ((bio = adapter->bio_done)) {
+			if (bio == adapter->bio_donetail)
+				adapter->bio_donetail = NULL;
+			adapter->bio_done = bio->bi_next;
+			bio->bi_next = NULL;
+		}
+		if (bio) {
+			/* Remove this iue from the in-flight list */
+			iue = (struct iu_entry *)bio->bi_private;
+			list_del(&iue->next);
+		}
+
+		spin_unlock_irqrestore(&adapter->lock, flags);
+
+		if (bio) {
+			/* Send back the SRP and data if this request was NOT
+			 * aborted 
+			 */
+			if (!iue->aborted) {
+
+				if (!iue->req.ioerr) {
+					/* return data if this was a read */
+					if (!iue->req.write) {
+						bytes =
+						    send_cmd_data(iue->req.
+								  data_token,
+								  iue->req.
+								  data_len,
+								  iue);
+						if (bytes != iue->req.data_len) {
+							err("Error sending data on response (tried %d, sent %d\n", bio->bi_size, bytes);
+							send_rsp(iue,
+								 SENSE_ABORT);
+						} else {
+							send_rsp(iue,
+								 SENSE_SUCCESS);
+						}
+					} else {
+						send_rsp(iue, SENSE_SUCCESS);
+					}
+				} else {
+					err("Block operation failed\n");
+					print_command(iue->iu->srp.cmd.cdb);
+					send_rsp(iue, SENSE_DEVICE_FAULT);
+				}
+			}
+
+			free_data_buffer(iue->req.data_buffer,
+					 iue->req.data_token, iue->req.data_len,
+					 adapter);
+
+			free_iu(iue);
+
+			bio_put(bio);
+			atomic_dec(&adapter->bio_count);
+		}
+	} while (bio);
+	atomic_dec(&adapter->endio_task_count);
+}
+
+/* ==============================================================
+ * SCSI Command Emulation Routines
+ * ==============================================================
+ */
+
+/*
+ * Process an inquiry SCSI Command
+ */
+static void process_inquiry(struct iu_entry *iue)
+{
+	struct inquiry_data *id;
+	dma_addr_t data_token;
+	int bytes;
+
+	id = (struct inquiry_data *)dma_alloc_coherent(iue->adapter->dev,
+						       sizeof(*id),
+						       &data_token, 0);
+	memset(id, 0x00, sizeof(*id));
+
+	/* If we have a valid device */
+	if (iue->req.vd) {
+		dbg("  inquiry returning device\n");
+		id->qual_type = 0x00;	/* Direct Access    */
+		id->rmb_reserve = 0x00;	/* TODO: CD is removable  */
+		id->version = 0x84;	/* ISO/IE                 */
+		id->aerc_naca_hisup_format = 0x22;	/* naca & format 0x02 */
+		id->addl_len = sizeof(*id) - 4;	/* sizeof(*this) - 4 */
+		id->bque_encserv_vs_multip_mchngr_reserved = 0x00;
+		id->reladr_reserved_linked_cmdqueue_vs = 0x02;	/* CMDQ   */
+		memcpy(id->vendor, "IBM     ", 8);
+		memcpy(id->product, "VSCSI blkdev    ", 16);
+		memcpy(id->revision, "0001", 4);
+	} else {
+		dbg("  inquiry returning no device\n");
+		id->qual_type = 0x7F;	/* Not supported, no device */
+	}
+
+	bytes = send_cmd_data(data_token, sizeof(*id), iue);
+
+	dma_free_coherent(iue->adapter->dev, sizeof(*id), id, data_token);
+
+	if (bytes < 0) {
+		send_rsp(iue, SENSE_DEVICE_FAULT);
+	} else {
+		send_rsp(iue, SENSE_SUCCESS);
+	}
+
+	free_iu(iue);
+}
+
+/*
+ * Handle an I/O.  Called by WRITE6, WRITE10, etc
+ */
+static void process_rw(char *cmd, int rw, struct iu_entry *iue, long lba,
+		       long len)
+{
+	char *buffer;
+	struct bio *bio;
+	int bytes;
+	int num_biovec;
+	int cur_biovec;
+	long flags;
+
+	dbg("%s %16.16lx[%d:%d:%d][%d:%d] lba %ld len %ld reladr %d link %d\n",
+	    cmd,
+	    iue->iu->srp.cmd.lun,
+	    GETBUS(iue->iu->srp.cmd.lun),
+	    GETTARGET(iue->iu->srp.cmd.lun),
+	    GETLUN(iue->iu->srp.cmd.lun),
+	    MAJOR(iue->req.vd->b.dev),
+	    MINOR(iue->req.vd->b.dev),
+	    lba,
+	    len / iue->req.vd->b.blksize,
+	    iue->iu->srp.cmd.cdb[1] & 0x01, iue->req.linked);
+
+	if (rw == WRITE) {
+		atomic_inc(&iue->adapter->write_processed);
+	} else if (rw == READ) {
+		atomic_inc(&iue->adapter->read_processed);
+	} else {
+		err("Major internal error...rw not read or write\n");
+		send_rsp(iue, SENSE_DEVICE_FAULT);
+
+		free_iu(iue);
+		return;
+	}
+
+	if (len == 0) {
+		warn("Zero length I/O\n");
+		send_rsp(iue, SENSE_INVALID_CMD);
+
+		free_iu(iue);
+		return;
+	}
+
+	/* Writing to a read-only device */
+	if ((rw == WRITE) && (iue->req.vd->b.ro)) {
+		warn("WRITE op to r/o device\n");
+		send_rsp(iue, SENSE_WRITE_PROT);
+
+		free_iu(iue);
+		return;
+	}
+
+	get_data_buffer(&buffer, &iue->req.data_token, len, iue->adapter);
+	iue->req.data_buffer = buffer;
+	iue->req.data_len = len;
+	if (buffer == NULL) {
+		err("Not able to get a data buffer (%lu pages)\n",
+		    len / PAGE_SIZE);
+		send_rsp(iue, SENSE_DEVICE_FAULT);
+
+		free_iu(iue);
+		return;
+	}
+
+	/* if reladr */
+	if (iue->iu->srp.cmd.cdb[1] & 0x01) {
+		lba = lba + iue->req.vd->b.lastlba;
+	}
+
+	/* If this command is linked, Keep this lba */
+	if (iue->req.linked) {
+		iue->req.vd->b.lastlba = lba;
+	} else {
+		iue->req.vd->b.lastlba = 0;
+	}
+
+	if (rw == WRITE) {
+		iue->req.write = 1;
+		/* Get the data */
+		bytes = get_cmd_data(iue->req.data_token, len, iue);
+		if (bytes != len) {
+			err("Error transferring data\n");
+			send_rsp(iue, SENSE_DEVICE_FAULT);
+
+			free_iu(iue);
+			return;
+		}
+	}
+
+	num_biovec = (len - 1) / PAGE_CACHE_SIZE + 1;
+
+	bio = bio_alloc(GFP_ATOMIC, num_biovec);
+	if (!bio) {
+		/* Ouch.  couldn't get a bio.  Mark this I/O as 
+		 * in error, then decrement the outstanding bio.
+		 * If there are still outstanding bio, they will send
+		 * the error and free the IU.  If there are none, we
+		 * should do it here
+		 */
+		iue->req.ioerr = 1;
+		err("Not able to get a bio\n");
+		send_rsp(iue, SENSE_DEVICE_FAULT);
+		free_iu(iue);
+		return;
+	}
+
+	iue->aborted = 0;
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+	list_add_tail(&iue->next, &iue->adapter->inflight);
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+
+	atomic_inc(&iue->adapter->bio_count);
+	bio->bi_size = len;
+	bio->bi_bdev = iue->req.vd->b.bdev;
+	bio->bi_sector = lba;
+	bio->bi_end_io = &ibmvscsis_end_io;
+	bio->bi_private = iue;
+	bio->bi_rw = (rw == WRITE) ? 1 : 0;
+	bio->bi_phys_segments = 1;
+	bio->bi_hw_segments = 1;
+
+	/* This all assumes that the buffers we get are page-aligned */
+	for (cur_biovec = 0; cur_biovec < num_biovec; cur_biovec++) {
+		long thislen;
+
+		if (len > PAGE_CACHE_SIZE) {
+			thislen = PAGE_CACHE_SIZE;
+		} else {
+			thislen = len;
+		}
+
+		bio->bi_io_vec[cur_biovec].bv_page = virt_to_page(buffer);
+		bio->bi_io_vec[cur_biovec].bv_len = thislen;
+		bio->bi_io_vec[cur_biovec].bv_offset =
+		    (unsigned long)buffer & PAGE_OFFSET_MASK;
+		bio->bi_vcnt++;
+
+		len -= thislen;
+		buffer += thislen;
+	}
+	generic_make_request(bio);
+}
+
+/*
+ * Process a READ6
+ */
+static void processRead6(struct iu_entry *iue)
+{
+	long lba = (*((u32 *) (iue->iu->srp.cmd.cdb))) & 0x001FFFFF;
+	long len = iue->iu->srp.cmd.cdb[4];
+
+	/* Length of 0 indicates 256 */
+	if (len == 0) {
+		len = 256;
+	}
+
+	len = len * iue->req.vd->b.blksize;
+
+	process_rw("Read6", READ, iue, lba, len);
+}
+
+/*
+ * Process a READ10
+ */
+static void processRead10(struct iu_entry *iue)
+{
+	long lba = *((u32 *) (iue->iu->srp.cmd.cdb + 2));
+	long len =
+	    *((u16 *) (iue->iu->srp.cmd.cdb + 7)) * iue->req.vd->b.blksize;
+
+	process_rw("Read10", READ, iue, lba, len);
+}
+
+/*
+ * Process a READ10
+ */
+static void processRead12(struct iu_entry *iue)
+{
+	long lba = *((u32 *) (iue->iu->srp.cmd.cdb + 2));
+	long len =
+	    *((u32 *) (iue->iu->srp.cmd.cdb + 6)) * iue->req.vd->b.blksize;
+
+	process_rw("Read12", READ, iue, lba, len);
+}
+
+static void processWrite6(struct iu_entry *iue)
+{
+	long lba = (*((u32 *) (iue->iu->srp.cmd.cdb))) & 0x001FFFFF;
+	long len = iue->iu->srp.cmd.cdb[4];
+
+	/* Length of 0 indicates 256 */
+	if (len == 0) {
+		len = 256;
+	}
+
+	len = len * iue->req.vd->b.blksize;
+
+	process_rw("Write6", WRITE, iue, lba, len);
+}
+
+static void processWrite10(struct iu_entry *iue)
+{
+	long lba = *((u32 *) (iue->iu->srp.cmd.cdb + 2));
+	long len =
+	    *((u16 *) (iue->iu->srp.cmd.cdb + 7)) * iue->req.vd->b.blksize;
+
+	process_rw("Write10", WRITE, iue, lba, len);
+}
+
+static void processWrite12(struct iu_entry *iue)
+{
+	long lba = *((u32 *) (iue->iu->srp.cmd.cdb + 2));
+	long len =
+	    *((u32 *) (iue->iu->srp.cmd.cdb + 6)) * iue->req.vd->b.blksize;
+
+	process_rw("Write12", WRITE, iue, lba, len);
+}
+
+/*
+ * Handle Read Capacity
+ */
+static void processReadCapacity(struct iu_entry *iue)
+{
+	struct ReadCapacityData {
+		u32 blocks;
+		u32 blocksize;
+	} *cap;
+	dma_addr_t data_token;
+	int bytes;
+
+	cap = (struct ReadCapacityData *)dma_alloc_coherent(iue->adapter->dev,
+							    sizeof(*cap),
+							    &data_token, 0);
+
+	/* return block size and last valid block */
+	cap->blocksize = iue->req.vd->b.blksize;
+	cap->blocks = iue->req.vd->b.bdev->bd_inode->i_size
+	    / iue->req.vd->b.blksize 
+	    - 1;
+
+	info("Reporting capacity as %u block of size %u\n", cap->blocks,
+	     cap->blocksize);
+
+	bytes = send_cmd_data(data_token, sizeof(*cap), iue);
+
+	dma_free_coherent(iue->adapter->dev, sizeof(*cap), cap, data_token);
+
+	if (bytes != sizeof(*cap)) {
+		err("Error sending read capacity data. bytes %d, wanted %ld\n",
+		    bytes, sizeof(*cap));
+	}
+
+	send_rsp(iue, SENSE_SUCCESS);
+
+	free_iu(iue);
+}
+
+/*
+ * Process Mode Sense
+ * TODO: I know scsiinfo asks for a bunch of mode pages not implemented here.
+ *       Also, we need to act differently for virtual disk and virtual CD
+ */
+#define MODE_SENSE_BUFFER_SIZE (512)
+static void processModeSense(struct iu_entry *iue)
+{
+	dma_addr_t data_token;
+	int bytes;
+
+	u8 *mode = (u8 *) dma_alloc_coherent(iue->adapter->dev,
+					     MODE_SENSE_BUFFER_SIZE,
+					     &data_token, 0);
+	/* which page */
+	switch (iue->iu->srp.cmd.cdb[2]) {
+	case 0:
+	case 0x3f:
+		mode[1] = 0x00;	/* Default medium */
+		if (iue->req.vd->b.ro) {
+			mode[2] = 0x80;	/* device specific  */
+		} else {
+			mode[2] = 0x00;	/* device specific  */
+		}
+		/* note the DPOFUA bit is set to zero! */
+		mode[3] = 0x08;	/* block descriptor length */
+		*((u32 *) & mode[4]) = iue->req.vd->b.bdev->bd_inode->i_size /
+		    iue->req.vd->b.blksize;
+		*((u32 *) & mode[8]) = iue->req.vd->b.blksize;
+		bytes = mode[0] = 12;	/* length */
+		break;
+
+	case 0x08:		/* Cache page */
+		/* length should be 4 */
+		if (iue->iu->srp.cmd.cdb[4] != 4
+		    && iue->iu->srp.cmd.cdb[4] != 0x20) {
+			send_rsp(iue, SENSE_INVALID_CMD);
+			dma_free_coherent(iue->adapter->dev,
+					  MODE_SENSE_BUFFER_SIZE,
+					  mode, data_token);
+			free_iu(iue);
+			return;
+		}
+
+		mode[1] = 0x00;	/* Default medium */
+		if (iue->req.vd->b.ro) {
+			mode[2] = 0x80;	/* device specific */
+		} else {
+			mode[2] = 0x00;	/* device specific */
+		}
+		/* note the DPOFUA bit is set to zero! */
+		mode[3] = 0x08;	/* block descriptor length */
+		*((u32 *) & mode[4]) = iue->req.vd->b.bdev->bd_inode->i_size /
+		    iue->req.vd->b.blksize;
+		*((u32 *) & mode[8]) = iue->req.vd->b.blksize;
+
+		/* Cache page */
+		mode[12] = 0x08;	/* page */
+		mode[13] = 0x12;	/* page length */
+		mode[14] = 0x01;	/* no cache (0x04 for read/write cache) */
+
+		bytes = mode[0] = 12 + mode[13];	/* length */
+		break;
+	default:
+		warn("Request for unknown mode page %d\n",
+		     iue->iu->srp.cmd.cdb[2]);
+		send_rsp(iue, SENSE_INVALID_CMD);
+		dma_free_coherent(iue->adapter->dev,
+				  MODE_SENSE_BUFFER_SIZE, mode, data_token);
+		free_iu(iue);
+		return;
+	}
+
+	bytes = send_cmd_data(data_token, bytes, iue);
+
+	dma_free_coherent(iue->adapter->dev,
+			  MODE_SENSE_BUFFER_SIZE, mode, data_token);
+
+	send_rsp(iue, SENSE_SUCCESS);
+
+	free_iu(iue);
+	return;
+}
+
+/*
+ * Report LUNS command.
+ */
+static void processReportLUNs(struct iu_entry *iue)
+{
+	int listsize = did_len(&iue->iu->srp.cmd);
+	dma_addr_t data_token;
+	int index = 2;		/* Start after the two entries (length and LUN0) */
+	int bus;
+	int target;
+	int bytes;
+	unsigned long flags;
+
+	u64 *lunlist = (u64 *) dma_alloc_coherent(iue->adapter->dev,
+						  listsize,
+						  &data_token, 0);
+
+	memset(lunlist, 0x00, listsize);
+
+	/* work out list size in units of u64 */
+	listsize = listsize / 8;
+
+	if (listsize < 1) {
+		warn("report luns buffer too small\n");
+		send_rsp(iue, SENSE_INVALID_CMD);
+		free_iu(iue);
+	}
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+
+	/* send lunlist of size 1 when requesting lun is not all zeros */
+	if (iue->iu->srp.cmd.lun != 0x0LL) {
+		*lunlist = ((u64) 1 * 8) << 32;
+		goto send_lunlist;
+	}
+
+	/* return the total number of luns plus LUN0 in bytes */
+	*lunlist = (((u64) ((iue->adapter->nvdevs + 1) * 8)) << 32);
+
+	dbg("reporting %d luns\n", iue->adapter->nvdevs + 1);
+	/* loop through the bus */
+	for (bus = 0; bus < BUS_PER_ADAPTER; bus++) {
+		/* If this bus exists */
+		if (iue->adapter->vbus[bus]) {
+			/* loop through the targets */
+			for (target = 0; target < TARGETS_PER_BUS; target++) {
+				/* If the target exists */
+				if (iue->adapter->vbus[bus]->vdev[target]) {
+					if ((index < listsize) &&
+					    (!iue->adapter->vbus[bus]->
+					     vdev[target]->disabled)) {
+						lunlist[index++] =
+						    iue->adapter->vbus[bus]->
+						    vdev[target]->lun;
+						dbg("  lun %16.16lx\n",
+						    iue->adapter->vbus[bus]->
+						    vdev[target]->lun);
+					}
+				}
+			}
+		}
+	}
+
+      send_lunlist:
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+
+	bytes = send_cmd_data(data_token, (index * 8), iue);
+
+	dma_free_coherent(iue->adapter->dev, listsize * 8, lunlist, data_token);
+
+	if (bytes != (index * 8)) {
+		err("Error sending report luns data. bytes %d, wanted %d\n",
+		    bytes, index * 4);
+		send_rsp(iue, SENSE_ABORT);
+	} else {
+		send_rsp(iue, SENSE_SUCCESS);
+	}
+
+	free_iu(iue);
+	return;
+}
+
+/*
+ * Process an IU.  
+ *
+ * Note that THIS routine is responsible for returning the IU from the pool
+ * The current assumption is that all the process routines called from here
+ * are, in turn, responsible for freeing the IU
+ */
+static void process_cmd(struct iu_entry *iue)
+{
+	union VIOSRP_IU *iu = iue->iu;
+
+	iue->req.vd = find_device(iue);
+
+	if ((iue->req.vd == NULL) &&
+	    (iu->srp.cmd.cdb[0] != REPORT_LUNS) &&
+	    (iu->srp.cmd.cdb[0] != INQUIRY)) {
+		dbg("Cmd %2.2x for unknown LUN %16.16lx\n",
+		    iu->srp.cmd.cdb[0], iue->iu->srp.cmd.lun);
+		send_rsp(iue, SENSE_INVALID_ID);
+		free_iu(iue);
+		return;
+	}
+
+	iue->req.linked = getlink(iue);
+
+	switch (iu->srp.cmd.cdb[0]) {
+	case READ_6:
+		processRead6(iue);
+		break;
+	case READ_10:
+		processRead10(iue);
+		break;
+	case READ_12:
+		processRead12(iue);
+		break;
+	case WRITE_6:
+		processWrite6(iue);
+		break;
+	case WRITE_10:
+		processWrite10(iue);
+		break;
+	case WRITE_12:
+		processWrite12(iue);
+		break;
+	case REPORT_LUNS:
+		dbg("REPORT LUNS lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		processReportLUNs(iue);
+		break;
+	case INQUIRY:
+		dbg("INQUIRY lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		process_inquiry(iue);
+		break;
+	case READ_CAPACITY:
+		dbg("READ CAPACITY lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		processReadCapacity(iue);
+		break;
+	case MODE_SENSE:
+		dbg("MODE SENSE lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		processModeSense(iue);
+		break;
+	case TEST_UNIT_READY:
+		/* we already know the device exists */
+		dbg("TEST UNIT READY lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		send_rsp(iue, SENSE_SUCCESS);
+		free_iu(iue);
+		break;
+	case START_STOP:
+		/* just respond OK */
+		dbg("START_STOP lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		send_rsp(iue, SENSE_SUCCESS);
+		free_iu(iue);
+		break;
+	default:
+		warn("Unsupported SCSI Command 0x%2.2x\n", iu->srp.cmd.cdb[0]);
+		send_rsp(iue, SENSE_INVALID_CMD);
+		free_iu(iue);
+	}
+}
+
+u16 send_adapter_info(struct iu_entry *iue,
+		      dma_addr_t remote_buffer, u16 length)
+{
+	dma_addr_t data_token;
+	int bytes;
+	struct device_node *rootdn;
+	const char *partition_name = "";
+	unsigned int *p_number_ptr;
+	struct MAD_ADAPTER_INFO_DATA *info =
+	    (struct MAD_ADAPTER_INFO_DATA *)dma_alloc_coherent(iue->adapter->
+							       dev,
+							       sizeof(*info),
+							       &data_token, 0);
+
+	dbg("in send_adapter_info\n ");
+	rootdn = find_path_device("/");
+	if ((info) && (!dma_mapping_error(data_token))) {
+		memset(info, 0x00, sizeof(*info));
+
+		dbg("building adapter_info\n ");
+		strcpy(info->srp_version, "1.6a");
+		partition_name =
+		    get_property(rootdn, "ibm,partition-name", NULL);
+		if (partition_name)
+			strncpy(info->partition_name, partition_name,
+				sizeof(info->partition_name));
+		p_number_ptr =
+		    (unsigned int *)get_property(rootdn, "ibm,partition-no",
+						 NULL);
+		if (p_number_ptr)
+			info->partition_number = *p_number_ptr;
+		info->mad_version = 1;
+		info->os_type = 3;
+
+		bytes = send_cmd_data(data_token, sizeof(*info), iue);
+
+		dma_free_coherent(iue->adapter->dev,
+				  sizeof(*info), info, data_token);
+	} else {
+		dbg("bad dma_alloc_cohereint in adapter_info\n ");
+		bytes = -1;
+	}
+
+	if (bytes < 0) {
+		return 1;
+	} else {
+		return 0;
+	}
+
+}
+
+/* ==============================================================
+ * SRP Processing Routines
+ * ==============================================================
+ */
+/*
+ * Process an incoming SRP Login request
+ */
+static void process_login(struct iu_entry *iue)
+{
+	union VIOSRP_IU *iu = iue->iu;
+	u64 tag = iu->srp.generic.tag;
+
+	/* TODO handle case that requested size is wrong and buffer format is wrong */
+	memset(iu, 0x00, sizeof(struct SRP_LOGIN_RSP));
+	iu->srp.login_rsp.type = SRP_LOGIN_RSP_TYPE;
+	iu->srp.login_rsp.request_limit_delta = iue->adapter->pool.size;
+	iu->srp.login_rsp.tag = tag;
+	iu->srp.login_rsp.max_initiator_to_target_iulen = sizeof(union SRP_IU);
+	iu->srp.login_rsp.max_target_to_initiator_iulen = sizeof(union SRP_IU);
+	iu->srp.login_rsp.supported_buffer_formats = 0x0002;	/* direct and indirect */
+	iu->srp.login_rsp.multi_channel_result = 0x00;	/* TODO fix if we were already logged in */
+
+	send_srp(iue, sizeof(iu->srp.login_rsp));
+}
+
+/*
+ * Send an SRP response that includes sense data
+ */
+static long send_rsp(struct iu_entry *iue, int status)
+{
+	u8 *sense = iue->iu->srp.rsp.sense_and_response_data;
+	u64 tag = iue->iu->srp.generic.tag;
+	union VIOSRP_IU *iu = iue->iu;
+
+	if (status != SENSE_SUCCESS) {
+		atomic_inc(&iue->adapter->errors);
+	}
+
+	/* If the linked bit is on and status is good */
+	if ((iue->req.linked) && (status == SENSE_SUCCESS)) {
+		status = SENSE_INTERMEDIATE;
+	}
+
+	memset(iu, 0x00, sizeof(struct SRP_RSP));
+	iu->srp.rsp.type = SRP_RSP_TYPE;
+	iu->srp.rsp.request_limit_delta = 1;
+	iu->srp.rsp.tag = tag;
+
+	iu->srp.rsp.diunder = iue->req.diunder;
+	iu->srp.rsp.diover = iue->req.diover;
+	iu->srp.rsp.dounder = iue->req.dounder;
+	iu->srp.rsp.doover = iue->req.doover;
+
+	iu->srp.rsp.data_in_residual_count = iue->req.data_in_residual_count;
+	iu->srp.rsp.data_out_residual_count = iue->req.data_out_residual_count;
+
+	iu->srp.rsp.rspvalid = 0;
+
+	iu->srp.rsp.response_data_list_length = 0;
+
+	if (status) {
+		iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
+		iu->srp.rsp.snsvalid = 1;
+		iu->srp.rsp.sense_data_list_length = 18;	/* TODO be smarter about this */
+
+		/* Valid bit and 'current errors' */
+		sense[0] = (0x1 << 7 | 0x70);
+
+		/* Sense key */
+		sense[2] = ibmvscsis_sense_data[status][0];
+
+		/* Additional sense length */
+		sense[7] = 0xa;	/* 10 bytes */
+
+		/* Additional sense code */
+		sense[12] = ibmvscsis_sense_data[status][1];
+
+		/* Additional sense code qualifier */
+		sense[13] = ibmvscsis_sense_data[status][2];
+	} else {
+		iu->srp.rsp.status = 0;
+	}
+
+	send_srp(iue, sizeof(iu->srp.rsp));
+
+	return 0;
+}
+
+static void process_device_reset(struct iu_entry *iue)
+{
+	struct iu_entry *tmp_iue;
+	unsigned long flags;
+	union VIOSRP_IU *iu = iue->iu;
+
+	info("device reset for lun %16.16lx\n", iu->srp.tsk_mgmt.lun);
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+
+	list_for_each_entry(tmp_iue, &iue->adapter->inflight, next) {
+		if (iu->srp.tsk_mgmt.lun == tmp_iue->iu->srp.cmd.lun) {
+			{
+				tmp_iue->aborted = 1;
+			}
+		}
+
+	}
+
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+}
+
+static void process_abort(struct iu_entry *iue)
+{
+	struct iu_entry *tmp_iue;
+	unsigned long flags;
+	union VIOSRP_IU *iu = iue->iu;
+
+	info("aborting task with tag %16.16lx, lun %16.16lx\n",
+	     iu->srp.tsk_mgmt.managed_task_tag, iu->srp.tsk_mgmt.lun);
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+
+	list_for_each_entry(tmp_iue, &iue->adapter->inflight, next) {
+		if (tmp_iue->iu->srp.cmd.tag ==
+		    iu->srp.tsk_mgmt.managed_task_tag) {
+			{
+				tmp_iue->aborted = 1;
+				info("abort successful\n");
+				spin_unlock_irqrestore(&iue->adapter->lock,
+						       flags);
+				send_rsp(iue, SENSE_SUCCESS);
+				return;
+			}
+		}
+	}
+	info("unable to abort cmd\n");
+
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+}
+
+static void process_tsk_mgmt(struct iu_entry *iue)
+{
+	union VIOSRP_IU *iu = iue->iu;
+
+	if (iu->srp.tsk_mgmt.task_mgmt_flags != 0x01) {
+		process_abort(iue);
+	} else if (iu->srp.tsk_mgmt.task_mgmt_flags != 0x08) {
+		process_device_reset(iue);
+	} else {
+		send_rsp(iue, SENSE_INVALID_CMD);
+	}
+}
+
+static void process_iu(struct VIOSRP_CRQ *crq, struct server_adapter *adapter)
+{
+	struct iu_entry *iue = get_iu(adapter);
+	union VIOSRP_IU *iu;
+	int queued = 0;
+	long rc;
+
+	if (iue == NULL) {
+		/* TODO Yikes! */
+		warn("Error getting IU from pool, other side exceeded limit\n");
+		return;
+	}
+
+	iue->req.remote_token = crq->IU_data_ptr;
+
+	rc = h_copy_rdma(crq->IU_length,
+			 iue->adapter->riobn,
+			 iue->req.remote_token, adapter->liobn, iue->iu_token);
+
+	iu = iue->iu;
+
+	if (rc) {
+		err("Got rc %ld from h_copy_rdma\n", rc);
+	}
+
+	if (crq->format == VIOSRP_MAD_FORMAT) {
+		switch (iu->mad.empty_iu.common.type) {
+		case VIOSRP_EMPTY_IU_TYPE:
+			warn("Unsupported EMPTY MAD IU\n");
+			break;
+		case VIOSRP_ERROR_LOG_TYPE:
+			warn("Unsupported ERROR LOG MAD IU\n");
+			iu->mad.error_log.common.status = 1;
+			send_srp(iue, sizeof(iu->mad.error_log));
+			break;
+		case VIOSRP_ADAPTER_INFO_TYPE:
+			iu->mad.adapter_info.common.status =
+			    send_adapter_info(iue,
+					      iu->mad.adapter_info.buffer,
+					      iu->mad.adapter_info.common.
+					      length);
+
+			send_srp(iue, sizeof(iu->mad.adapter_info));
+			break;
+		case VIOSRP_HOST_CONFIG_TYPE:
+			iu->mad.host_config.common.status = 1;
+			send_srp(iue, sizeof(iu->mad.host_config));
+			break;
+		default:
+			warn("Unsupported MAD type %d\n", iu->srp.generic.type);
+		}
+	} else {
+		switch (iu->srp.generic.type) {
+		case SRP_LOGIN_REQ_TYPE:
+			dbg("SRP LOGIN\n");
+			process_login(iue);
+			break;
+		case SRP_LOGIN_RSP_TYPE:
+			warn("Unsupported LOGIN_RSP SRP IU\n");
+			break;
+		case SRP_I_LOGOUT_TYPE:
+			warn("Unsupported I_LOGOUT SRP IU\n");
+			break;
+		case SRP_T_LOGOUT_TYPE:
+			warn("Unsupported T_LOGOUT SRP IU\n");
+			break;
+		case SRP_TSK_MGMT_TYPE:
+			process_tsk_mgmt(iue);
+			break;
+		case SRP_CMD_TYPE:
+			process_cmd(iue);
+			queued = 1;
+			break;
+		case SRP_RSP_TYPE:
+			warn("Unsupported RSP SRP IU\n");
+			break;
+		case SRP_CRED_REQ_TYPE:
+			warn("Unsupported CRED_REQ SRP IU\n");
+			break;
+		case SRP_CRED_RSP_TYPE:
+			warn("Unsupported CRED_RSP SRP IU\n");
+			break;
+		case SRP_AER_REQ_TYPE:
+			warn("Unsupported AER_REQ SRP IU\n");
+			break;
+		case SRP_AER_RSP_TYPE:
+			warn("Unsupported AER_RSP SRP IU\n");
+			break;
+		default:
+			warn("Unsupported SRP type %d\n", iu->srp.generic.type);
+		}
+	}
+
+	/* 
+	 * If no one has queued the IU for further work, free it 
+	 * Note that this is kind of an ugly design based on setting
+	 * this variable up above in cases where the routine we call
+	 * is responsible for freeing the IU
+	 */
+	if (!queued)
+		free_iu(iue);
+}
+
+/* ==============================================================
+ * CRQ Processing Routines
+ * ==============================================================
+ */
+
+/*
+ * Handle a CRQ event
+ */
+static void handle_crq(struct VIOSRP_CRQ *crq, struct server_adapter *adapter)
+{
+	switch (crq->valid) {
+	case 0xC0:		/* initialization */
+		switch (crq->format) {
+		case 0x01:
+			info("Partner just initialized\n");
+			plpar_hcall_norets(H_SEND_CRQ,
+					   adapter->dma_dev->unit_address,
+					   0xC002000000000000, 0);
+			break;
+		case 0x02:
+			info("ibmvscsis: partner initialization complete\n");
+			break;
+		default:
+			err("Unknwn CRQ format %d\n", crq->format);
+		}
+		return;
+	case 0xFF:		/* transport event */
+		info("ibmvscsis: partner closed\n");
+		return;
+	case 0x80:		/* real payload */
+		{
+			switch (crq->format) {
+			case VIOSRP_SRP_FORMAT:
+			case VIOSRP_MAD_FORMAT:
+				process_iu(crq, adapter);
+				break;
+			case VIOSRP_OS400_FORMAT:
+				warn("Unsupported OS400 format CRQ\n");
+				break;
+
+			case VIOSRP_AIX_FORMAT:
+				warn("Unsupported AIX format CRQ\n");
+				break;
+
+			case VIOSRP_LINUX_FORMAT:
+				warn("Unsupported LINUX format CRQ\n");
+				break;
+
+			case VIOSRP_INLINE_FORMAT:
+				warn("Unsupported _INLINE_ format CRQ\n");
+				break;
+
+			default:
+				err("Unsupported CRQ format %d\n", crq->format);
+			}
+		}
+		break;
+	default:
+		err("ibmvscsis: got an invalid message type 0x%02x!?\n",
+		    crq->valid);
+		return;
+	}
+
+}
+
+/*
+ * Task to handle CRQs and completions
+ */
+static void crq_task(unsigned long data)
+{
+	struct server_adapter *adapter = (struct server_adapter *)data;
+	struct VIOSRP_CRQ *crq;
+	long rc;
+	int done = 0;
+
+	if (atomic_inc_return(&adapter->crq_task_count) > 1) {
+		err("In crq_task twice!!!\n");
+	}
+
+	while (!done) {
+
+		/* Loop through and process CRQs */
+		while ((crq = crq_queue_next_crq(&adapter->queue)) != NULL) {
+			atomic_inc(&adapter->crq_processed);
+			handle_crq(crq, adapter);
+			crq->valid = 0x00;
+		}
+
+		rc = h_vio_signal(adapter->dma_dev->unit_address, 1);
+		if (rc != 0) {
+			err("Error %ld enabling interrupts!!!\n", rc);
+		}
+		if ((crq = crq_queue_next_crq(&adapter->queue)) != NULL) {
+			rc = h_vio_signal(adapter->dma_dev->unit_address, 0);
+			if (rc != 0) {
+				err("Error %ld enabling interrupts!!!\n", rc);
+			}
+			handle_crq(crq, adapter);
+			crq->valid = 0x00;
+		} else {
+			done = 1;
+		}
+	}
+	atomic_dec(&adapter->crq_task_count);
+}
+
+/*
+ * Handle the interrupt that occurs when something is placed on our CRQ
+ */
+static irqreturn_t handle_interrupt(int irq, void *dev_instance,
+				    struct pt_regs *regs)
+{
+	struct server_adapter *adapter = (struct server_adapter *)dev_instance;
+	long rc;
+
+	rc = h_vio_signal(adapter->dma_dev->unit_address, 0);
+	if (rc != 0) {
+		err(" Error %ld disabling interrupts!!!\n", rc);
+	}
+
+	atomic_inc(&adapter->interrupts);
+
+	tasklet_schedule(&adapter->crq_tasklet);
+
+	return IRQ_HANDLED;
+}
+
+/* 
+ * Initialize our CRQ
+ * return zero on success, non-zero on failure 
+ */
+static int initialize_crq_queue(struct crq_queue *queue,
+				struct server_adapter *adapter)
+{
+	int rc;
+
+	queue->msgs = (struct VIOSRP_CRQ *)get_zeroed_page(GFP_KERNEL);
+	if (!queue->msgs)
+		goto malloc_failed;
+	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
+
+	queue->msg_token = dma_map_single(adapter->dev, queue->msgs,
+					  queue->size * sizeof(*queue->msgs),
+					  DMA_BIDIRECTIONAL);
+
+	if (dma_mapping_error(queue->msg_token))
+		goto map_failed;
+
+	rc = plpar_hcall_norets(H_REG_CRQ, adapter->dma_dev->unit_address,
+				queue->msg_token, PAGE_SIZE);
+
+	/* If we opened successfully, send an init message */
+	if (rc == 0) {
+		plpar_hcall_norets(H_SEND_CRQ, adapter->dma_dev->unit_address,
+				   0xC001000000000000, 0);
+	} else if (rc == 2) {
+		/* Other end is still closed.  This is normal */
+		info("connection registered, other end closed\n");
+	} else {
+		err("couldn't register crq--rc 0x%x\n", rc);
+		goto reg_crq_failed;
+	}
+
+	if (request_irq
+	    (adapter->dma_dev->irq, &handle_interrupt, SA_INTERRUPT,
+	     "ibmvscsis", adapter) != 0)
+		goto req_irq_failed;
+
+	queue->cur = 0;
+	queue->lock = SPIN_LOCK_UNLOCKED;
+
+	return 0;
+
+      req_irq_failed:
+	plpar_hcall_norets(H_FREE_CRQ, adapter->dma_dev->unit_address);
+      reg_crq_failed:
+	dma_unmap_single(adapter->dev, queue->msg_token,
+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
+      map_failed:
+	free_page((unsigned long)queue->msgs);
+      malloc_failed:
+	return -1;
+}
+
+/*
+ * Release the CRQ
+ */
+static void release_crq_queue(struct crq_queue *queue,
+			      struct server_adapter *adapter)
+{
+	info("releasing crq\n");
+	free_irq(adapter->dma_dev->irq, adapter);
+	plpar_hcall_norets(H_FREE_CRQ, adapter->dma_dev->unit_address);
+	dma_unmap_single(adapter->dev, queue->msg_token,
+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
+	free_page((unsigned long)queue->msgs);
+}
+
+/* ==============================================================
+ * Module Management
+ * ==============================================================
+ */
+/*
+ * Add a block device as a SCSI LUN
+ */
+static void add_block_device(int majo, int mino, int bus, int target,
+			     struct server_adapter *adapter, int ro)
+{
+	struct vdev *vd;
+	struct vbus *newbus = NULL;
+	mode_t mode;
+	unsigned long flags;
+	dev_t kd = MKDEV(majo, mino);
+
+	if (bus >= BUS_PER_ADAPTER) {
+		err("Invalid bus %u specified\n", bus);
+		return;
+	}
+
+	if (target >= TARGETS_PER_BUS) {
+		err("Invalid target %u specified\n", bus);
+		return;
+	}
+
+	vd = (struct vdev *)kmalloc(sizeof(struct vdev), GFP_KERNEL);
+	if (vd == NULL) {
+		err("Unable to allocate memory for vdev structure");
+		return;
+	}
+
+	memset(vd, 0x00, sizeof(*vd));
+	vd->type = 'B';
+	vd->lun = make_lun(bus, target, 0);
+	vd->b.dev = kd;
+	vd->b.bdev = bdget(kd);
+	vd->b.blksize = 512;
+	vd->b.ro = ro;
+
+	if (ro) {
+		mode = FMODE_READ;
+	} else {
+		mode = FMODE_READ | FMODE_WRITE;
+	}
+
+	if (blkdev_get(vd->b.bdev, mode, 0) != 0) {
+		err("Error opening block device\n");
+		kfree(vd);
+		return;
+	}
+
+	if (adapter->vbus[bus] == NULL) {
+		newbus =
+		    (struct vbus *)kmalloc(sizeof(struct vbus), GFP_KERNEL);
+		memset(newbus, 0x00, sizeof(*newbus));
+	}
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	if ((newbus) && (adapter->vbus[bus] == NULL)) {
+		adapter->vbus[bus] = newbus;
+		newbus = NULL;
+	}
+
+	if (adapter->vbus[bus]->vdev[target] != NULL) {
+		spin_unlock_irqrestore(&adapter->lock, flags);
+		err("Error: Duplicate vdev as lun 0x%lx\n", vd->lun);
+		kfree(vd);
+		return;
+	}
+
+	adapter->vbus[bus]->vdev[target] = vd;
+	adapter->nvdevs++;
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	if (newbus)
+		kfree(newbus);
+
+	info("Adding block device %d:%d as %sLUN 0x%lx\n",
+	     majo, mino, ro ? "read only " : "", vd->lun);
+	return;
+}
+
+static void remove_block_device(int bus, int target,
+				struct server_adapter *adapter)
+{
+	struct vdev *vd;
+	unsigned long flags;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	if ((!adapter->vbus[bus]) || (!adapter->vbus[bus]->vdev[target])) {
+		spin_unlock_irqrestore(&adapter->lock, flags);
+		err("Error removing non-existant device at bus %d, target %d\n",
+		    bus, target);
+		return;
+	}
+
+	vd = adapter->vbus[bus]->vdev[target];
+
+	if (vd->disabled) {
+		spin_unlock_irqrestore(&adapter->lock, flags);
+		err("Device at bus %d, target %d removed twice\n", bus, target);
+		return;
+	}
+
+	adapter->nvdevs--;
+
+	vd->disabled = 1;
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* Wait while any users of this device finish.  Note there should
+	 * be no new users, since we have marked this disabled
+	 *
+	 * We just poll here, since we are blocking a proc_write
+	 */
+	while (atomic_read(&vd->refcount)) {
+		schedule_timeout(HZ / 4);	/* 1/4 second */
+	}
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	adapter->vbus[bus]->vdev[target] = NULL;
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	if (blkdev_put(vd->b.bdev)) {
+		err("Error closing block device!\n");
+	}
+	kfree(vd);
+
+	info("Removed block device at %d:%d\n", bus, target);
+}
+
+/*
+ * Handle read from our proc system file.  There is one of these
+ * files per adapter
+ */
+static int ibmvscsis_proc_read(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	struct server_adapter *adapter = (struct server_adapter *)data;
+	int len = 0;
+	int bus;
+	int target;
+	struct vdev *vd;
+	unsigned long flags;
+
+	len += sprintf(page + len, "IBM VSCSI Server: %s\n", adapter->name);
+	len += sprintf(page + len, "interrupts: %10d\t\tread ops:   %10d\n",
+		       atomic_read(&adapter->interrupts),
+		       atomic_read(&adapter->read_processed));
+	len += sprintf(page + len, "crq msgs:   %10d\t\twrite ops:  %10d\n",
+		       atomic_read(&adapter->crq_processed),
+		       atomic_read(&adapter->write_processed));
+	len += sprintf(page + len, "iu alloc:   %10d\t\tbio alloc:  %10d\n",
+		       atomic_read(&adapter->iu_count),
+		       atomic_read(&adapter->bio_count));
+
+	len += sprintf(page + len, "buf alloc:  %10d\t\terrors:     %10d\n",
+		       atomic_read(&adapter->buffers_allocated),
+		       atomic_read(&adapter->errors));
+
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	/* loop through the bus */
+	for (bus = 0; bus < BUS_PER_ADAPTER; bus++) {
+		/* If this bus exists */
+		if (adapter->vbus[bus]) {
+			/* loop through the targets */
+			for (target = 0; target < TARGETS_PER_BUS; target++) {
+				/* If the target exists */
+				if (adapter->vbus[bus]->vdev[target]) {
+					vd = adapter->vbus[bus]->vdev[target];
+					if (vd->type == 'B') {
+						len +=
+						    sprintf(page + len,
+							    "Block Device Major %d, Minor %d, Bus %d, Target %d LUN %d\n",
+							    MAJOR(vd->b.dev),
+							    MINOR(vd->b.dev),
+							    GETBUS(vd->lun),
+							    GETTARGET(vd->lun),
+							    GETLUN(vd->lun));
+					}
+				}
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	*eof = 1;
+	return len;
+}
+
+/*
+ * Handle proc file system write.  One per adapter, currently used just
+ * to add virtual devices to our adapters.
+ */
+static int ibmvscsis_proc_write(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	int offset = 0;
+	int bytes;
+	char token[10];
+	char type[4];
+	int majo = -1;
+	int mino = -1;
+	unsigned int bus = -1;
+	unsigned int target = -1;
+	int ro = 0;
+
+	struct server_adapter *adapter = (struct server_adapter *)data;
+
+	if (sscanf(buffer + offset, "%9s%n", token, &bytes) != 1) {
+		err("Error on read of proc file\n");
+		return count;
+	}
+	offset += bytes;
+
+	if (strcmp(token, "add") == 0) {
+
+		if (sscanf(buffer + offset, "%3s%n", type, &bytes) != 1) {
+			err("Error on read of proc file\n");
+			return count;
+		}
+		offset += bytes;
+
+		sscanf(buffer + offset, "%i%n", &majo, &bytes);
+		offset += bytes;
+
+		sscanf(buffer + offset, "%i%n", &mino, &bytes);
+		offset += bytes;
+
+		sscanf(buffer + offset, "%i%n", &bus, &bytes);
+		offset += bytes;
+
+		sscanf(buffer + offset, "%i%n", &target, &bytes);
+		offset += bytes;
+
+		if (strcmp(type, "b") == 0) {
+			ro = 0;
+		} else if (strcmp(type, "br") == 0) {
+			ro = 1;
+		} else {
+			err("Invalid type %s on add request\n", type);
+			return count;
+		}
+
+		if ((majo == -1) || (mino == -1)) {
+			err("Ignoring command %s device %d::%ds type %s\n",
+			    token, majo, mino, type);
+			return count;
+		}
+		add_block_device(majo, mino, bus, target, adapter, ro);
+	} else if (strcmp(token, "remove") == 0) {
+		if (sscanf(buffer + offset, "%3s%n", type, &bytes) != 1) {
+			err("Error on read of proc file\n");
+			return count;
+		}
+		offset += bytes;
+
+		sscanf(buffer + offset, "%i%n", &bus, &bytes);
+		offset += bytes;
+
+		sscanf(buffer + offset, "%i%n", &target, &bytes);
+		offset += bytes;
+
+		if ((strcmp(type, "b") != 0) && (strcmp(type, "br") != 0)) {
+			err("Ignoring remove command for invalid type %s\n",
+			    type);
+			return count;
+		}
+
+		if ((bus == -1) || (target == -1)) {
+			err("Ignoring remove command bus %d target%ds\n",
+			    bus, target);
+			return count;
+		}
+
+		remove_block_device(bus, target, adapter);
+	} else if (strcmp(token, "debug") == 0) {
+		ibmvscsis_debug = 1;
+		dbg("debugging on\n");
+	} else {
+		err("Ignoring command %s\n", token);
+	}
+
+	return count;
+}
+
+static void ibmvscsis_proc_register_driver(void)
+{
+#ifdef CONFIG_PROC_FS
+	ibmvscsis_proc_dir =
+	    create_proc_entry(IBMVSCSIS_PROC_DIR, S_IFDIR, proc_root_driver);
+#endif
+}
+
+static void ibmvscsis_proc_unregister_driver(void)
+{
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry(IBMVSCSIS_PROC_DIR, proc_root_driver);
+#endif
+}
+
+static void ibmvscsis_proc_register_adapter(struct server_adapter *adapter)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *entry;
+	entry = create_proc_entry(adapter->name, S_IFREG, ibmvscsis_proc_dir);
+	entry->data = (void *)adapter;
+	entry->read_proc = ibmvscsis_proc_read;
+	entry->write_proc = ibmvscsis_proc_write;
+#endif
+}
+
+static void ibmvscsis_proc_unregister_adapter(struct server_adapter *adapter)
+{
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry(adapter->name, ibmvscsis_proc_dir);
+#endif
+}
+
+static int ibmvscsis_probe(struct vio_dev *dev, const struct vio_device_id *id)
+{
+	struct server_adapter *adapter;
+	int rc;
+	unsigned int *dma_window;
+	unsigned int dma_window_property_size;
+
+	info("entering probe for UA 0x%x\n", dev->unit_address);
+
+	adapter = kmalloc(sizeof(*adapter), GFP_KERNEL);
+	if (!adapter) {
+		err("couldn't kmalloc adapter structure\n");
+		return -1;
+	}
+	memset(adapter, 0x00, sizeof(*adapter));
+	adapter->dma_dev = dev;
+	adapter->dev = &dev->dev;
+	dev->driver_data = adapter;
+	sprintf(adapter->name, "%x", dev->unit_address);
+	adapter->lock = SPIN_LOCK_UNLOCKED;
+
+	dma_window =
+	    (unsigned int *)vio_get_attribute(dev, "ibm,my-dma-window",
+					      &dma_window_property_size);
+	if (!dma_window) {
+		warn("Couldn't find ibm,my-dma-window property\n");
+	}
+
+	adapter->liobn = dma_window[0];
+	/* RPA docs say that #address-cells is always 1 for virtual
+	   devices, but some older boxes' OF returns 2.  This should
+	   be removed by GA, unless there is legacy OFs that still
+	   have 2 or 3 for #address-cells */
+	/*adapter->riobn = dma_window[2+vio_num_address_cells]; */
+
+	/* This is just an ugly kludge. Remove as soon as the OF for all
+	   machines actually follow the spec and encodes the offset field
+	   as phys-encode (that is, #address-cells wide) */
+	if (dma_window_property_size == 24) {
+		adapter->riobn = dma_window[3];
+	} else if (dma_window_property_size == 40) {
+		adapter->riobn = dma_window[5];
+	} else {
+		warn("ibmvscsis: Invalid size of ibm,my-dma-window=%i\n",
+		     dma_window_property_size);
+	}
+
+	tasklet_init(&adapter->crq_tasklet, crq_task, (unsigned long)adapter);
+
+	tasklet_init(&adapter->endio_tasklet,
+		     endio_task, (unsigned long)adapter);
+
+	INIT_LIST_HEAD(&adapter->inflight);
+
+	/* Initialize the buffer cache */
+	init_data_buffer(adapter);
+
+	/* Arbitrarily support 16 IUs right now */
+	rc = initialize_iu_pool(adapter, 16);
+	if (rc) {
+		kfree(adapter);
+		return rc;
+	}
+
+	rc = initialize_crq_queue(&adapter->queue, adapter);
+	if (rc != 0) {
+		kfree(adapter);
+		return rc;
+	}
+
+	rc = h_vio_signal(adapter->dma_dev->unit_address, 1);
+	if (rc != 0) {
+		err("Error %d enabling interrupts!!!\n", rc);
+	}
+
+	ibmvscsis_proc_register_adapter(adapter);
+
+	return 0;
+}
+
+static int ibmvscsis_remove(struct vio_dev *dev)
+{
+	int bus;
+	int target;
+
+	struct server_adapter *adapter =
+	    (struct server_adapter *)dev->driver_data;
+
+	info("entering remove for UA 0x%x\n", dev->unit_address);
+
+	ibmvscsis_proc_unregister_adapter(adapter);
+
+	/* 
+	 * No one should be adding any devices at this point because we blew 
+	 * away the proc file system entry 
+	 *
+	 * Loop through the bus
+	 */
+	for (bus = 0; bus < BUS_PER_ADAPTER; bus++) {
+		/* If this bus exists */
+		if (adapter->vbus[bus]) {
+			/* loop through the targets */
+			for (target = 0; target < TARGETS_PER_BUS; target++) {
+				/* If the target exists */
+				if (adapter->vbus[bus]->vdev[target]) {
+					remove_block_device(bus, target,
+							    adapter);
+				}
+			}
+		}
+	}
+
+	release_crq_queue(&adapter->queue, adapter);
+
+	release_iu_pool(adapter);
+
+	release_data_buffer(adapter);
+
+	kfree(adapter);
+
+	return 0;
+}
+
+static struct vio_device_id ibmvscsis_device_table[] __devinitdata = {
+	{"v-scsi-host", "IBM,v-scsi-host"},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(vio, ibmvscsis_device_table);
+
+static struct vio_driver ibmvscsis_driver = {
+	.name = "ibmvscss",
+	.id_table = ibmvscsis_device_table,
+	.probe = ibmvscsis_probe,
+	.remove = ibmvscsis_remove,
+};
+
+static int mod_init(void)
+{
+	int rc;
+
+	info("ibmvscsis initialized\n");
+
+	ibmvscsis_proc_register_driver();
+
+	rc = vio_register_driver(&ibmvscsis_driver);
+
+	if (rc) {
+		warn("rc %d from vio_register_driver\n", rc);
+	}
+
+	return rc;
+}
+
+static void mod_exit(void)
+{
+	info("terminated\n");
+
+	vio_unregister_driver(&ibmvscsis_driver);
+
+	ibmvscsis_proc_unregister_driver();
+}
+
+module_init(mod_init);
+module_exit(mod_exit);
diff -purN linux-2.6.5/drivers/scsi/ibmvscsi/iseries_vscsi.c linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/iseries_vscsi.c
--- linux-2.6.5/drivers/scsi/ibmvscsi/iseries_vscsi.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/iseries_vscsi.c	2004-04-26 09:29:59.000000000 +0000
@@ -0,0 +1,160 @@
+/* ------------------------------------------------------------
+ * iSeries_vscsi.c
+ * (C) Copyright IBM Corporation 1994, 2003
+ * Authors: Colin DeVilbiss (devilbis@us.ibm.com)
+ *          Santiago Leon (santil@us.ibm.com)
+ *          Dave Boutcher (sleddog@us.ibm.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * ------------------------------------------------------------
+ * iSeries-specific functions of the SCSI host adapter for Virtual I/O devices
+ *
+ * This driver allows the Linux SCSI peripheral drivers to directly
+ * access devices in the hosting partition, either on an iSeries
+ * hypervisor system or a converged hypervisor system.
+ */
+
+#include <asm/iSeries/vio.h>
+#include <asm/iSeries/HvLpEvent.h>
+#include <asm/iSeries/HvTypes.h>
+#include <asm/iSeries/HvLpConfig.h>
+#include <asm/vio.h>
+#include <linux/device.h>
+#include "ibmvscsi.h"
+
+static void noop_release(struct device *dev) {};
+
+/* global variables */
+static struct ibmvscsi_host_data *single_host_data;
+static struct vio_dev iseries_vscsi_dev = {
+	.dev.bus = &vio_bus_type,
+	.dev.bus_id = "vscsi",
+	.dev.release = noop_release
+};
+
+/* ------------------------------------------------------------
+ * Routines for direct interpartition interaction
+ */
+struct VIOSRPLpEvent {
+	struct HvLpEvent lpevt;	/* 0x00-0x17          */
+	u32 reserved1;		/* 0x18-0x1B; unused  */
+	u16 version;		/* 0x1C-0x1D; unused  */
+	u16 subtype_rc;		/* 0x1E-0x1F; unused  */
+	struct VIOSRP_CRQ crq;	/* 0x20-0x3F          */
+};
+
+/** 
+ * standard interface for handling logical partition events.
+ */
+static void ibmvscsi_handle_event(struct HvLpEvent *lpevt)
+{
+	struct VIOSRPLpEvent *evt = (struct VIOSRPLpEvent *)lpevt;
+
+	if (!evt) {
+		printk(KERN_ERR "ibmvscsi: received null event\n");
+		return;
+	}
+
+	if (single_host_data == NULL) {
+		printk(KERN_ERR
+		       "ibmvscsi: received event, no adapter present\n");
+		return;
+	}
+
+	ibmvscsi_handle_crq(&evt->crq, single_host_data);
+}
+
+/* ------------------------------------------------------------
+ * Routines for driver initialization
+ */
+int ibmvscsi_init_crq_queue(struct crq_queue *queue,
+			    struct ibmvscsi_host_data *hostdata,
+			    int max_requests)
+{
+	int rc;
+
+	rc = viopath_open(viopath_hostLp, viomajorsubtype_scsi, 0);
+	if (rc < 0) {
+		printk("viopath_open failed with rc %d in open_event_path\n",
+		       rc);
+		goto viopath_open_failed;
+	}
+
+	rc = vio_setHandler(viomajorsubtype_scsi, ibmvscsi_handle_event);
+	if (rc < 0) {
+		printk("vio_setHandler failed with rc %d in open_event_path\n",
+		       rc);
+		goto vio_setHandler_failed;
+	}
+	return 0;
+
+      vio_setHandler_failed:
+	viopath_close(viopath_hostLp, viomajorsubtype_scsi,
+		      max_requests);
+      viopath_open_failed:
+	return -1;
+}
+
+void ibmvscsi_release_crq_queue(struct crq_queue *queue,
+				struct ibmvscsi_host_data *hostdata,
+				int max_requests)
+{
+	vio_clearHandler(viomajorsubtype_scsi);
+	viopath_close(viopath_hostLp, viomajorsubtype_scsi,
+		      max_requests);
+}
+
+/**
+ * ibmvscsi_send_crq: - Send a CRQ
+ * @hostdata:	the adapter
+ * @word1:	the first 64 bits of the data
+ * @word2:	the second 64 bits of the data
+ */
+int ibmvscsi_send_crq(struct ibmvscsi_host_data *hostdata, u64 word1, u64 word2)
+{
+	single_host_data = hostdata;
+	return HvCallEvent_signalLpEventFast(viopath_hostLp,
+					     HvLpEvent_Type_VirtualIo,
+					     viomajorsubtype_scsi,
+					     HvLpEvent_AckInd_NoAck,
+					     HvLpEvent_AckType_ImmediateAck,
+					     viopath_sourceinst(viopath_hostLp),
+					     viopath_targetinst(viopath_hostLp),
+					     0,
+					     VIOVERSION << 16, word1, word2, 0,
+					     0);
+}
+
+int __init ibmvscsi_module_init(void)
+{
+	iseries_vscsi_dev.archdata = to_vio_dev(iSeries_vio_dev)->archdata;
+	if (device_register(&iseries_vscsi_dev.dev)) {
+		printk(KERN_ERR "ibmvscsi: failed to register device\n");
+		return 1;
+	}
+	single_host_data = ibmvscsi_probe(&iseries_vscsi_dev.dev);
+	return (single_host_data == NULL);
+}
+
+void __exit ibmvscsi_module_exit(void)
+{
+	ibmvscsi_remove(single_host_data);
+	device_unregister(&iseries_vscsi_dev.dev);
+}
+
+module_init(ibmvscsi_module_init);
+module_exit(ibmvscsi_module_exit);
diff -purN linux-2.6.5/drivers/scsi/ibmvscsi/rpa_vscsi.c linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/rpa_vscsi.c
--- linux-2.6.5/drivers/scsi/ibmvscsi/rpa_vscsi.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/rpa_vscsi.c	2004-04-26 09:29:59.000000000 +0000
@@ -0,0 +1,287 @@
+/* ------------------------------------------------------------
+ * rpa_vscsi.c
+ * (C) Copyright IBM Corporation 1994, 2003
+ * Authors: Colin DeVilbiss (devilbis@us.ibm.com)
+ *          Santiago Leon (santil@us.ibm.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * ------------------------------------------------------------
+ * RPA-specific functions of the SCSI host adapter for Virtual I/O devices
+ *
+ * This driver allows the Linux SCSI peripheral drivers to directly
+ * access devices in the hosting partition, either on an iSeries
+ * hypervisor system or a converged hypervisor system.
+ */
+
+#include <asm/vio.h>
+#include <asm/iommu.h>
+#include <asm/hvcall.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include "ibmvscsi.h"
+
+/* ------------------------------------------------------------
+ * Routines for managing the command/response queue
+ */
+/**
+ * ibmvscsi_handle_event: - Interrupt handler for crq events
+ * @irq:	number of irq to handle, not used
+ * @dev_instance: ibmvscsi_host_data of host that received interrupt
+ * @regs:	pt_regs with registers
+ *
+ * Disables interrupts and schedules srp_task
+ * Always returns IRQ_HANDLED
+ */
+static irqreturn_t ibmvscsi_handle_event(int irq,
+					 void *dev_instance,
+					 struct pt_regs *regs)
+{
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)dev_instance;
+	vio_disable_interrupts(to_vio_dev(hostdata->dev));
+	tasklet_schedule(&hostdata->srp_task);
+	return IRQ_HANDLED;
+}
+
+/**
+ * release_crq_queue: - Deallocates data and unregisters CRQ
+ * @queue:	crq_queue to initialize and register
+ * @host_data:	ibmvscsi_host_data of host
+ *
+ * Frees irq, deallocates a page for messages, unmaps dma, and unregisters
+ * the crq with the hypervisor.
+ */
+void ibmvscsi_release_crq_queue(struct crq_queue *queue,
+				struct ibmvscsi_host_data *hostdata,
+				int max_requests)
+{
+	long rc;
+	struct vio_dev *vdev = to_vio_dev(hostdata->dev);
+	free_irq(vdev->irq, (void *)hostdata);
+	tasklet_kill(&hostdata->srp_task);
+	do {
+		rc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);
+	} while (H_isLongBusy(rc));
+	dma_unmap_single(hostdata->dev,
+			 queue->msg_token,
+			 queue->size * sizeof(*queue->msgs),
+			 DMA_BIDIRECTIONAL);
+	free_page((unsigned long)queue->msgs);
+}
+
+/**
+ * crq_queue_next_crq: - Returns the next entry in message queue
+ * @queue:	crq_queue to use
+ *
+ * Returns pointer to next entry in queue, or NULL if there are no new 
+ * entried in the CRQ.
+ */
+static struct VIOSRP_CRQ *crq_queue_next_crq(struct crq_queue *queue)
+{
+	struct VIOSRP_CRQ *crq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&queue->lock, flags);
+	crq = &queue->msgs[queue->cur];
+	if (crq->valid & 0x80) {
+		if (++queue->cur == queue->size)
+			queue->cur = 0;
+	} else
+		crq = NULL;
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+	return crq;
+}
+
+/**
+ * ibmvscsi_send_crq: - Send a CRQ
+ * @hostdata:	the adapter
+ * @word1:	the first 64 bits of the data
+ * @word2:	the second 64 bits of the data
+ */
+int ibmvscsi_send_crq(struct ibmvscsi_host_data *hostdata, u64 word1, u64 word2)
+{
+	struct vio_dev *vdev = to_vio_dev(hostdata->dev);
+
+	return plpar_hcall_norets(H_SEND_CRQ, vdev->unit_address, word1, word2);
+}
+
+/**
+ * ibmvscsi_task: - Process srps asynchronously
+ * @data:	ibmvscsi_host_data of host
+ */
+static void ibmvscsi_task(void *data)
+{
+	struct ibmvscsi_host_data *hostdata = (struct ibmvscsi_host_data *)data;
+	struct vio_dev *vdev = to_vio_dev(hostdata->dev);
+	struct VIOSRP_CRQ *crq;
+	int done = 0;
+
+	while (!done) {
+		/* Pull all the valid messages off the CRQ */
+		while ((crq = crq_queue_next_crq(&hostdata->queue)) != NULL) {
+			ibmvscsi_handle_crq(crq, hostdata);
+			crq->valid = 0x00;
+		}
+
+		vio_enable_interrupts(vdev);
+		if ((crq = crq_queue_next_crq(&hostdata->queue)) != NULL) {
+			vio_disable_interrupts(vdev);
+			ibmvscsi_handle_crq(crq, hostdata);
+			crq->valid = 0x00;
+		} else {
+			done = 1;
+		}
+	}
+}
+
+/**
+ * initialize_crq_queue: - Initializes and registers CRQ with hypervisor
+ * @queue:	crq_queue to initialize and register
+ * @hostdata:	ibmvscsi_host_data of host
+ *
+ * Allocates a page for messages, maps it for dma, and registers
+ * the crq with the hypervisor.
+ * Returns zero on success.
+ */
+int ibmvscsi_init_crq_queue(struct crq_queue *queue,
+			    struct ibmvscsi_host_data *hostdata,
+			    int max_requests)
+{
+	int rc;
+	struct vio_dev *vdev = to_vio_dev(hostdata->dev);
+
+	queue->msgs = (struct VIOSRP_CRQ *)get_zeroed_page(GFP_KERNEL);
+
+	if (!queue->msgs)
+		goto malloc_failed;
+	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
+
+	queue->msg_token = dma_map_single(hostdata->dev, queue->msgs,
+					  queue->size * sizeof(*queue->msgs),
+					  DMA_BIDIRECTIONAL);
+
+	if (dma_mapping_error(queue->msg_token))
+		goto map_failed;
+
+	rc = plpar_hcall_norets(H_REG_CRQ,
+				vdev->unit_address,
+				queue->msg_token, PAGE_SIZE);
+	if (rc == 2) {
+		/* Adapter is good, but other end is not ready */
+		printk(KERN_WARNING "ibmvscsi: Partner adapter not ready\n");
+	} else if (rc != 0) {
+		printk(KERN_WARNING
+		       "ibmvscsi: couldn't register crq--rc 0x%x\n", rc);
+		goto reg_crq_failed;
+	}
+
+	if (request_irq(vdev->irq,
+			ibmvscsi_handle_event,
+			0, "ibmvscsi", (void *)hostdata) != 0) {
+		printk(KERN_ERR "ibmvscsi: couldn't register irq 0x%x\n",
+		       vdev->irq);
+		goto req_irq_failed;
+	}
+
+	rc = vio_enable_interrupts(vdev);
+	if (rc != 0) {
+		printk(KERN_ERR "ibmvscsi:  Error %d enabling interrupts!!!\n",
+		       rc);
+		goto req_irq_failed;
+	}
+
+	queue->cur = 0;
+	queue->lock = SPIN_LOCK_UNLOCKED;
+
+	tasklet_init(&hostdata->srp_task, (void *) ibmvscsi_task,
+		     (unsigned long) hostdata);
+
+	return 0;
+
+      req_irq_failed:
+	plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);
+      reg_crq_failed:
+	dma_unmap_single(hostdata->dev,
+			 queue->msg_token,
+			 queue->size * sizeof(*queue->msgs),
+			 DMA_BIDIRECTIONAL);
+      map_failed:
+	free_page((unsigned long)queue->msgs);
+      malloc_failed:
+	return -1;
+}
+
+/**
+ * rpa_device_table: Used by vio.c to match devices in the device tree we 
+ * support.
+ */
+static struct vio_device_id rpa_device_table[] __devinitdata = {
+	{"scsi-3", "IBM,v-scsi"},	/* Note: This entry can go away when 
+					   all the firmware is up to date */
+	{"vscsi", "IBM,v-scsi"},
+	{0,}
+};
+
+/**
+ * rpa_probe: The callback from the virtual I/O bus code.
+ * @vdev     : The vio specific device structure
+ * @id       : the device id..we don't currently use it
+ */
+static int rpa_probe(struct vio_dev *vdev, const struct vio_device_id *id)
+{
+	struct ibmvscsi_host_data *hostdata = ibmvscsi_probe(&vdev->dev);
+	if (hostdata) {
+		vdev->driver_data = hostdata;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+/**
+ * rpa_remove: The callback from the virtual I/O bus code to remove a device
+ * @vdev     : The vio specific device structure
+ */
+static int rpa_remove(struct vio_dev *vdev)
+{
+	struct ibmvscsi_host_data *hostdata =
+	    (struct ibmvscsi_host_data *)vdev->driver_data;
+	ibmvscsi_remove(hostdata);
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(vio, rpa_device_table);
+static struct vio_driver ibmvscsi_driver = {
+	.name = "ibmvscsi",
+	.id_table = rpa_device_table,
+	.probe = rpa_probe,
+	.remove = rpa_remove
+};
+
+int __init ibmvscsi_module_init(void)
+{
+	return vio_register_driver(&ibmvscsi_driver);
+}
+
+void __exit ibmvscsi_module_exit(void)
+{
+	vio_unregister_driver(&ibmvscsi_driver);
+}
+
+module_init(ibmvscsi_module_init);
+module_exit(ibmvscsi_module_exit);
diff -purN linux-2.6.5/drivers/scsi/ibmvscsi/srp.h linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/srp.h
--- linux-2.6.5/drivers/scsi/ibmvscsi/srp.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/srp.h	2004-04-26 09:29:59.000000000 +0000
@@ -0,0 +1,225 @@
+/*****************************************************************************/
+/* srp.h -- SCSI RDMA Protocol definitions                                   */
+/*                                                                           */
+/* Written By: Colin Devilbis, IBM Corporation                               */
+/*                                                                           */
+/* Copyright (C) 2003 IBM Corporation                                        */
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation; either version 2 of the License, or         */
+/* (at your option) any later version.                                       */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+/*                                                                           */
+/*                                                                           */
+/* This file contains structures and definitions for the SCSI RDMA Protocol  */
+/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
+/* file was based on the 16a version of the standard                         */
+/*                                                                           */
+/*****************************************************************************/
+#ifndef SRP_H
+#define SRP_H
+
+#define PACKED __attribute__((packed))
+
+enum SRP_TYPES {
+	SRP_LOGIN_REQ_TYPE = 0x00,
+	SRP_LOGIN_RSP_TYPE = 0xC0,
+	SRP_LOGIN_REJ_TYPE = 0x80,
+	SRP_I_LOGOUT_TYPE = 0x03,
+	SRP_T_LOGOUT_TYPE = 0x80,
+	SRP_TSK_MGMT_TYPE = 0x01,
+	SRP_CMD_TYPE = 0x02,
+	SRP_RSP_TYPE = 0xC1,
+	SRP_CRED_REQ_TYPE = 0x81,
+	SRP_CRED_RSP_TYPE = 0x41,
+	SRP_AER_REQ_TYPE = 0x82,
+	SRP_AER_RSP_TYPE = 0x42
+};
+
+enum SRP_DESCRIPTOR_FORMATS {
+	SRP_NO_BUFFER = 0x00,
+	SRP_DIRECT_BUFFER = 0x01,
+	SRP_INDIRECT_BUFFER = 0x02
+};
+
+struct memory_descriptor {
+	u64 virtual_address;
+	u32 memory_handle;
+	u32 length;
+};
+
+struct indirect_descriptor {
+	struct memory_descriptor head;
+	u64 total_length;
+	struct memory_descriptor list[1];
+};
+
+struct SRP_GENERIC {
+	u8 type;
+	u8 reserved1[7];
+	u64 tag;
+};
+
+struct SRP_LOGIN_REQ {
+	u8 type;
+	u8 reserved1[7];
+	u64 tag;
+	u32 max_requested_initiator_to_target_iulen;
+	u32 reserved2;
+	u16 required_buffer_formats;
+	u8 reserved3:6;
+	u8 multi_channel_action:2;
+	u8 reserved4;
+	u32 reserved5;
+	u8 initiator_port_identifier[16];
+	u8 target_port_identifier[16];
+};
+
+struct SRP_LOGIN_RSP {
+	u8 type;
+	u8 reserved1[3];
+	u32 request_limit_delta;
+	u64 tag;
+	u32 max_initiator_to_target_iulen;
+	u32 max_target_to_initiator_iulen;
+	u16 supported_buffer_formats;
+	u8 reserved2:6;
+	u8 multi_channel_result:2;
+	u8 reserved3;
+	u8 reserved4[24];
+};
+
+struct SRP_LOGIN_REJ {
+	u8 type;
+	u8 reserved1[3];
+	u32 reason;
+	u64 tag;
+	u64 reserved2;
+	u16 supported_buffer_formats;
+	u8 reserved3[6];
+};
+
+struct SRP_I_LOGOUT {
+	u8 type;
+	u8 reserved1[7];
+	u64 tag;
+};
+
+struct SRP_T_LOGOUT {
+	u8 type;
+	u8 reserved1[3];
+	u32 reason;
+	u64 tag;
+};
+
+struct SRP_TSK_MGMT {
+	u8 type;
+	u8 reserved1[7];
+	u64 tag;
+	u32 reserved2;
+	u64 lun PACKED;
+	u8 reserved3;
+	u8 reserved4;
+	u8 task_mgmt_flags;
+	u8 reserved5;
+	u64 managed_task_tag;
+	u64 reserved6;
+};
+
+struct SRP_CMD {
+	u8 type;
+	u32 reserved1 PACKED;
+	u8 data_out_format:4;
+	u8 data_in_format:4;
+	u8 data_out_count;
+	u8 data_in_count;
+	u64 tag;
+	u32 reserved2;
+	u64 lun PACKED;
+	u8 reserved3;
+	u8 reserved4:5;
+	u8 task_attribute:3;
+	u8 reserved5;
+	u8 additional_cdb_len;
+	u8 cdb[16];
+	u8 additional_data[0x100 - 0x30];
+};
+
+struct SRP_RSP {
+	u8 type;
+	u8 reserved1[3];
+	u32 request_limit_delta;
+	u64 tag;
+	u16 reserved2;
+	u8 reserved3:2;
+	u8 diunder:1;
+	u8 diover:1;
+	u8 dounder:1;
+	u8 doover:1;
+	u8 snsvalid:1;
+	u8 rspvalid:1;
+	u8 status;
+	u32 data_in_residual_count;
+	u32 data_out_residual_count;
+	u32 sense_data_list_length;
+	u32 response_data_list_length;
+	u8 sense_and_response_data[18];
+};
+
+struct SRP_CRED_REQ {
+	u8 type;
+	u8 reserved1[3];
+	u32 request_limit_delta;
+	u64 tag;
+};
+
+struct SRP_CRED_RSP {
+	u8 type;
+	u8 reserved1[7];
+	u64 tag;
+};
+
+struct SRP_AER_REQ {
+	u8 type;
+	u8 reserved1[3];
+	u32 request_limit_delta;
+	u64 tag;
+	u32 reserved2;
+	u64 lun;
+	u32 sense_data_list_length;
+	u32 reserved3;
+	u8 sense_data[20];
+};
+
+struct SRP_AER_RSP {
+	u8 type;
+	u8 reserved1[7];
+	u64 tag;
+};
+
+union SRP_IU {
+	struct SRP_GENERIC generic;
+	struct SRP_LOGIN_REQ login_req;
+	struct SRP_LOGIN_RSP login_rsp;
+	struct SRP_LOGIN_REJ login_rej;
+	struct SRP_I_LOGOUT i_logout;
+	struct SRP_T_LOGOUT t_logout;
+	struct SRP_TSK_MGMT tsk_mgmt;
+	struct SRP_CMD cmd;
+	struct SRP_RSP rsp;
+	struct SRP_CRED_REQ cred_req;
+	struct SRP_CRED_RSP cred_rsp;
+	struct SRP_AER_REQ aer_req;
+	struct SRP_AER_RSP aer_rsp;
+};
+
+#endif
diff -purN linux-2.6.5/drivers/scsi/ibmvscsi/viosrp.h linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/viosrp.h
--- linux-2.6.5/drivers/scsi/ibmvscsi/viosrp.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5.ibm-ppc64-vscsi/drivers/scsi/ibmvscsi/viosrp.h	2004-04-26 09:29:59.000000000 +0000
@@ -0,0 +1,126 @@
+/*****************************************************************************/
+/* srp.h -- SCSI RDMA Protocol definitions                                   */
+/*                                                                           */
+/* Written By: Colin Devilbis, IBM Corporation                               */
+/*                                                                           */
+/* Copyright (C) 2003 IBM Corporation                                        */
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation; either version 2 of the License, or         */
+/* (at your option) any later version.                                       */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+/*                                                                           */
+/*                                                                           */
+/* This file contains structures and definitions for IBM RPA (RS/6000        */
+/* platform architecture) implementation of the SRP (SCSI RDMA Protocol)     */
+/* standard.  SRP is used on IBM iSeries and pSeries platforms to send SCSI  */
+/* commands between logical partitions.                                      */
+/*                                                                           */
+/* SRP Information Units (IUs) are sent on a "Command/Response Queue" (CRQ)  */
+/* between partitions.  The definitions in this file are architected,        */
+/* and cannot be changed without breaking compatibility with other versions  */
+/* of Linux and other operating systems (AIX, OS/400) that talk this protocol*/
+/* between logical partitions                                                */
+/*****************************************************************************/
+#ifndef VIOSRP_H
+#define VIOSRP_H
+#include "srp.h"
+
+enum VIOSRP_CRQ_FORMATS {
+	VIOSRP_SRP_FORMAT = 0x01,
+	VIOSRP_MAD_FORMAT = 0x02,
+	VIOSRP_OS400_FORMAT = 0x03,
+	VIOSRP_AIX_FORMAT = 0x04,
+	VIOSRP_LINUX_FORMAT = 0x06,
+	VIOSRP_INLINE_FORMAT = 0x07
+};
+
+struct VIOSRP_CRQ {
+	u8 valid;		/* used by RPA */
+	u8 format;		/* SCSI vs out-of-band */
+	u8 reserved;
+	u8 status;		/* non-scsi failure? (e.g. DMA failure) */
+	u16 timeout;		/* in seconds */
+	u16 IU_length;		/* in bytes */
+	u64 IU_data_ptr;	/* the TCE for transferring data */
+};
+
+/* MADs are Management requests above and beyond the IUs defined in the SRP
+ * standard.  
+ */
+enum VIOSRP_MAD_TYPES {
+	VIOSRP_EMPTY_IU_TYPE = 0x01,
+	VIOSRP_ERROR_LOG_TYPE = 0x02,
+	VIOSRP_ADAPTER_INFO_TYPE = 0x03,
+	VIOSRP_HOST_CONFIG_TYPE = 0x04
+};
+
+/* 
+ * Common MAD header
+ */
+struct MAD_COMMON {
+	u32 type;
+	u16 status;
+	u16 length;
+	u64 tag;
+};
+
+/*
+ * All SRP (and MAD) requests normally flow from the
+ * client to the server.  There is no way for the server to send
+ * an asynchronous message back to the client.  The Empty IU is used
+ * to hang out a meaningless request to the server so that it can respond
+ * asynchrouously with something like a SCSI AER 
+ */
+struct VIOSRP_EMPTY_IU {
+	struct MAD_COMMON common;
+	u64 buffer;
+	u32 port;
+};
+
+struct VIOSRP_ERROR_LOG {
+	struct MAD_COMMON common;
+	u64 buffer;
+};
+
+struct VIOSRP_ADAPTER_INFO {
+	struct MAD_COMMON common;
+	u64 buffer;
+};
+
+struct VIOSRP_HOST_CONFIG {
+	struct MAD_COMMON common;
+	u64 buffer;
+};
+
+union MAD_IU {
+	struct VIOSRP_EMPTY_IU empty_iu;
+	struct VIOSRP_ERROR_LOG error_log;
+	struct VIOSRP_ADAPTER_INFO adapter_info;
+	struct VIOSRP_HOST_CONFIG host_config;
+};
+
+union VIOSRP_IU {
+	union SRP_IU srp;
+	union MAD_IU mad;
+};
+
+struct MAD_ADAPTER_INFO_DATA {
+	char srp_version[8];
+	char partition_name[96];
+	u32 partition_number;
+	u32 mad_version;
+	u32 os_type;
+	u32 port_max_txu[8];	/* per-port maximum transfer */
+};
+
+#endif
