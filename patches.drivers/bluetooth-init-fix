===== drivers/bluetooth/bluecard_cs.c 1.16 vs edited =====
--- 1.16/drivers/bluetooth/bluecard_cs.c	Sun Feb 29 00:53:36 2004
+++ edited/drivers/bluetooth/bluecard_cs.c	Mon Apr  5 02:51:46 2004
@@ -505,13 +505,13 @@
 	unsigned int iobase;
 	unsigned char reg;
 
-	if (!info) {
+	if (!info || !info->hdev) {
 		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
 
 	if (!test_bit(CARD_READY, &(info->hw_state)))
-		return IRQ_NONE;
+		return IRQ_HANDLED;
 
 	iobase = info->link.io.BasePort1;
 
@@ -725,6 +725,27 @@
 	info->rx_count = 0;
 	info->rx_skb = NULL;
 
+	/* Initialize HCI device */
+	hdev = hci_alloc_dev();
+	if (!hdev) {
+		BT_ERR("Can't allocate HCI device");
+		return -ENOMEM;
+	}
+
+	info->hdev = hdev;
+
+	hdev->type = HCI_PCCARD;
+	hdev->driver_data = info;
+
+	hdev->open     = bluecard_hci_open;
+	hdev->close    = bluecard_hci_close;
+	hdev->flush    = bluecard_hci_flush;
+	hdev->send     = bluecard_hci_send_frame;
+	hdev->destruct = bluecard_hci_destruct;
+	hdev->ioctl    = bluecard_hci_ioctl;
+
+	hdev->owner = THIS_MODULE;
+
 	id = inb(iobase + 0x30);
 
 	if ((id & 0x0f) == 0x02)
@@ -776,28 +797,7 @@
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout((HZ * 5) / 4);		// or set it to 3/2
 
-
-	/* Initialize and register HCI device */
-	hdev = hci_alloc_dev();
-	if (!hdev) {
-		BT_ERR("Can't allocate HCI device");
-		return -ENOMEM;
-	}
-
-	info->hdev = hdev;
-
-	hdev->type = HCI_PCCARD;
-	hdev->driver_data = info;
-
-	hdev->open = bluecard_hci_open;
-	hdev->close = bluecard_hci_close;
-	hdev->flush = bluecard_hci_flush;
-	hdev->send = bluecard_hci_send_frame;
-	hdev->destruct = bluecard_hci_destruct;
-	hdev->ioctl = bluecard_hci_ioctl;
-
-	hdev->owner = THIS_MODULE;
-	
+	/* Register HCI device */
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
===== drivers/bluetooth/dtl1_cs.c 1.15 vs edited =====
--- 1.15/drivers/bluetooth/dtl1_cs.c	Sun Feb 29 00:53:06 2004
+++ edited/drivers/bluetooth/dtl1_cs.c	Mon Apr  5 02:42:00 2004
@@ -312,7 +312,7 @@
 	int boguscount = 0;
 	int iir, lsr;
 
-	if (!info) {
+	if (!info || !info->hdev) {
 		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
@@ -483,6 +483,27 @@
 
 	set_bit(XMIT_WAITING, &(info->tx_state));
 
+	/* Initialize HCI device */
+	hdev = hci_alloc_dev();
+	if (!hdev) {
+		BT_ERR("Can't allocate HCI device");
+		return -ENOMEM;
+	}
+
+	info->hdev = hdev;
+
+	hdev->type = HCI_PCCARD;
+	hdev->driver_data = info;
+
+	hdev->open     = dtl1_hci_open;
+	hdev->close    = dtl1_hci_close;
+	hdev->flush    = dtl1_hci_flush;
+	hdev->send     = dtl1_hci_send_frame;
+	hdev->destruct = dtl1_hci_destruct;
+	hdev->ioctl    = dtl1_hci_ioctl;
+
+	hdev->owner = THIS_MODULE;
+
 	spin_lock_irqsave(&(info->lock), flags);
 
 	/* Reset UART */
@@ -506,28 +527,7 @@
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout(HZ * 2);
 
-
-	/* Initialize and register HCI device */
-	hdev = hci_alloc_dev();
-	if (!hdev) {
-		BT_ERR("Can't allocate HCI device");
-		return -ENOMEM;
-	}
-
-	info->hdev = hdev;
-
-	hdev->type = HCI_PCCARD;
-	hdev->driver_data = info;
-
-	hdev->open = dtl1_hci_open;
-	hdev->close = dtl1_hci_close;
-	hdev->flush = dtl1_hci_flush;
-	hdev->send = dtl1_hci_send_frame;
-	hdev->destruct = dtl1_hci_destruct;
-	hdev->ioctl = dtl1_hci_ioctl;
-
-	hdev->owner = THIS_MODULE;
-
+	/* Register HCI device */
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
