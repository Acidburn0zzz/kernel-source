diff -urNp linux-2.6.8/drivers/char/fetchop.c linux-2.6.8.SUSE/drivers/char/fetchop.c
--- linux-2.6.8/drivers/char/fetchop.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.SUSE/drivers/char/fetchop.c	2004-08-30 15:47:12.315595528 +0200
@@ -0,0 +1,501 @@
+/*
+ * SN Platform FetchOp Support
+ *
+ * This driver exports the SN fetchop facility to user processes.
+ * Fetchops are atomic memory operations that are implemented in the
+ * memory controller on SGI SN hardware.
+ */
+
+/*
+ * Copyright (C) 2001-2004 Silicon Graphics, Inc.  All rights
+ * reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Further, this software is distributed without any warranty that it is
+ * free of the rightful claim of any third person regarding infringement
+ * or the like.  Any license provided herein, whether implied or
+ * otherwise, applies only to this software file.  Patent licenses, if
+ * any, provided herein do not apply to combinations of this program with
+ * other software, or any other product whatsoever.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA
+ * 02111-1307, USA.
+ *
+ * Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
+ * Mountain View, CA  94043, or:
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
+ * http://oss.sgi.com/projects/GenInfo/NoticeExplan
+ */
+
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/vmalloc.h>
+#include <linux/bitops.h>
+#include <linux/efi.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/machvec.h>
+#include <asm/uaccess.h>
+#include <asm/sn/sgi.h>
+#include <asm/sn/addrs.h>
+#include <asm/sn/arch.h>
+#include <asm/sn/fetchop.h>
+#include <asm/sn/sn_cpuid.h>
+
+
+#define DRIVER_ID_STR	"SGI Fetchop Device Driver"
+#define REVISION	"1.03"
+
+
+#define MSPEC_TO_NID(maddr)	nasid_to_cnodeid(NASID_GET(maddr))
+
+
+static int fetchop_mmap(struct file *file, struct vm_area_struct *vma);
+static void fetchop_open(struct vm_area_struct *vma);
+static void fetchop_close(struct vm_area_struct *vma);
+
+static struct file_operations fetchop_fops = {
+	owner:		THIS_MODULE,
+	mmap:		fetchop_mmap,
+};
+
+static struct miscdevice fetchop_miscdev = {
+	minor:		MISC_DYNAMIC_MINOR,
+	name:		"sgi_fetchop",
+	fops:		&fetchop_fops
+};
+
+static struct vm_operations_struct fetchop_vm_ops = {
+	open:		fetchop_open,
+	close:		fetchop_close,
+};
+
+/*
+ * There is one of these structs per node. It is used to manage the fetchop
+ * space that is available on the node. Current assumption is that there is
+ * only 1 fetchop block of memory per node.
+ */
+struct node_fetchops {
+	long		maddr;		/* MSPEC address of start of fetchops. */
+	int		count;		/* Total number of fetchop pages. */
+	atomic_t	free;		/* Number of pages currently free. */
+	unsigned long	bits[1];	/* Bitmap for managing pages. */
+};
+
+
+/*
+ * One of these structures is allocated when a fetchop region is mmaped. The
+ * structure is pointed to by the vma->vm_private_data field in the vma struct. 
+ * This structure is used to record the addresses of the fetchop pages.
+ */
+struct vma_data {
+	int		count;		/* Number of pages allocated. */
+	atomic_t	refcnt;		/* Number of vmas sharing the data. */
+	unsigned long	maddr[1];	/* Array of MSPEC addresses. */
+};
+
+
+/*
+ * Fetchop statistics.
+ */
+struct fetchop_stats {
+	unsigned long  map_count;	/* Number of active mmap's */
+	unsigned long  pages_in_use;	/* Number of fetchop pages in use */
+	unsigned long  pages_total;	/* Total number of fetchop pages */
+};
+
+static struct fetchop_stats	fetchop_stats;
+static struct node_fetchops	*node_fetchops[MAX_COMPACT_NODES];
+static spinlock_t		fetchop_lock = SPIN_LOCK_UNLOCKED;
+
+
+/*
+ * Walk the EFI memory map and call 'callback' once for each EFI memory
+ * descriptor whose attribute exactly matches the attributes
+ * specified by the caller
+ */
+void
+efi_memmap_walk_att (u64 desired_attribute, efi_freemem_callback_t callback,
+		     void *arg)
+{
+	void *efi_map_start, *efi_map_end, *p;
+	efi_memory_desc_t *md;
+	u64 efi_desc_size, start, end;
+
+	efi_map_start = __va(ia64_boot_param->efi_memmap);
+	efi_map_end   = efi_map_start + ia64_boot_param->efi_memmap_size;
+	efi_desc_size = ia64_boot_param->efi_memdesc_size;
+
+	for (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {
+		md = p;
+
+		if (md->attribute == desired_attribute) {
+			start = PAGE_ALIGN(md->phys_addr);
+			end = PAGE_ALIGN((md->phys_addr+
+					  (md->num_pages << EFI_PAGE_SHIFT)) &
+					  PAGE_MASK);
+			if ((*callback)(start, end, arg) < 0)
+				return;
+		}
+	}
+}
+
+
+/*
+ * fetchop_initialize_page
+ *
+ * Initial a page that is about to be used for fetchops. 
+ * All fetchop variables in the page are set to 0.
+ *
+ */
+static void
+fetchop_initialize_page(unsigned long maddr)
+{
+	unsigned long	p, pe;
+
+	for (p=FETCHOP_KADDR_TO_MSPEC_ADDR(maddr), pe=p+PAGE_SIZE; p<pe; p+=FETCHOP_VAR_SIZE)
+		FETCHOP_STORE_OP(p,FETCHOP_STORE, 0);
+}
+
+
+/*
+ * fetchop_alloc_page
+ *
+ * Allocate 1 fetchop page. Allocates on the requested node. If no
+ * fetchops are available on the requested node, roundrobin starting
+ * with higher nodes.
+ */
+static unsigned long
+fetchop_alloc_page(int nid)
+{
+	int i, bit;
+	struct node_fetchops *fops;
+	unsigned long maddr;
+
+	if (nid < 0 || nid >= numnodes)
+		nid = numa_node_id();
+	for (i=0; i<numnodes; i++) {
+		fops = node_fetchops[nid];
+		while (fops && (bit = find_first_zero_bit(fops->bits, fops->count)) < fops->count) {
+			if (test_and_set_bit(bit, fops->bits) == 0) {
+				atomic_dec(&node_fetchops[nid]->free);
+				maddr = fops->maddr + (bit<<PAGE_SHIFT);
+				fetchop_initialize_page(maddr);
+				return maddr;
+			}
+		}
+		nid = (nid+1 < numnodes) ? nid+1 : 0;
+	}
+	return 0;
+
+}
+
+
+/*
+ * fetchop_free_pages
+ *
+ * Free all fetchop pages that are linked to a vma struct.
+ */
+static void
+fetchop_free_page(unsigned long maddr)
+{
+	int nid, bit;
+
+	nid = MSPEC_TO_NID(maddr);
+	bit = (maddr - node_fetchops[nid]->maddr) >> PAGE_SHIFT;
+	clear_bit(bit, node_fetchops[nid]->bits);
+	atomic_inc(&node_fetchops[nid]->free);
+}
+
+static void
+fetchop_free_pages(struct vma_data *vdata)
+{
+	int i;
+
+	for (i=0; i<vdata->count; i++)
+		fetchop_free_page(vdata->maddr[i]);
+}
+
+
+/*
+ * fetchop_update_stats
+ *
+ * Update statistics of the number of fetchop mappings & pages.
+ * If creating a new mapping, ensure that we don't exceed the maximum allowed
+ * number of fetchop pages.
+ */
+static int
+fetchop_update_stats(int mmap, long count)
+{
+	int	ret = 0;
+
+	spin_lock(&fetchop_lock);
+	if (count > 0 && fetchop_stats.pages_in_use + count > fetchop_stats.pages_total)  {
+		ret = -1;
+	} else {
+		fetchop_stats.map_count += mmap;
+		fetchop_stats.pages_in_use += count;
+	}
+	spin_unlock(&fetchop_lock);
+
+	return ret;
+}
+
+
+/*
+ * fetchop_mmap
+ *
+ * Called when mmaping the device. Creates fetchop pages and map them
+ * to user space.
+ */
+static int
+fetchop_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long vm_start;
+	unsigned long maddr;
+	int pages;
+	struct vma_data *vdata;
+
+	if (vma->vm_pgoff != 0)
+		return -EINVAL;
+
+	if ((vma->vm_flags&VM_WRITE) == 0)
+		return -EPERM;
+
+	pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+	if (fetchop_update_stats(1, pages) < 0)
+		return -ENOSPC;
+
+	if (!(vdata=vmalloc(sizeof(struct vma_data)+(pages-1)*sizeof(long)))) {
+		fetchop_update_stats(-1, -pages);
+		return -ENOMEM;
+	}
+
+	vdata->count = 0;
+	vdata->refcnt = ATOMIC_INIT(1);
+	vma->vm_private_data = vdata;
+
+	vma->vm_flags |= (VM_IO | VM_SHM | VM_LOCKED | VM_NONCACHED);
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_ops = &fetchop_vm_ops;
+	vm_start = vma->vm_start;
+
+	while (vm_start < vma->vm_end) {
+		maddr = fetchop_alloc_page(numa_node_id());
+		if (maddr == 0)
+			BUG();
+		vdata->maddr[vdata->count++] = maddr;
+
+
+		if (remap_page_range(vma, vm_start, __pa(maddr), PAGE_SIZE, vma->vm_page_prot)) {
+			fetchop_free_pages(vma->vm_private_data);
+			vfree(vdata);
+			fetchop_update_stats(-1, -pages);
+			return -EAGAIN;
+		}
+		vm_start += PAGE_SIZE;
+	}
+
+	return 0;
+}
+
+/*
+ * fetchop_open
+ *
+ * Called when a device mapping is created by a means other than mmap
+ * (via fork, etc.).  Increments the reference count on the underlying
+ * fetchop data so it is not freed prematurely.
+ */
+static void
+fetchop_open(struct vm_area_struct *vma)
+{
+	struct vma_data *vdata;
+
+	vdata = vma->vm_private_data;
+	if (vdata && vdata->count) {
+		atomic_inc(&vdata->refcnt);
+	}
+}
+
+/*
+ * fetchop_close
+ *
+ * Called when unmapping a device mapping. Frees all fetchop pages
+ * belonging to the vma.
+ */
+static void
+fetchop_close(struct vm_area_struct *vma)
+{
+	struct vma_data *vdata;
+
+	vdata = vma->vm_private_data;
+	if (vdata && vdata->count && !atomic_dec(&vdata->refcnt)) {
+		fetchop_free_pages(vdata);
+		fetchop_update_stats(-1, -vdata->count);
+		vfree(vdata);
+	}
+}
+
+#ifdef CONFIG_PROC_FS
+
+static struct proc_dir_entry   *proc_fetchop;
+
+/*
+ * fetchop_read_proc
+ *
+ * Implements /proc/fetchop. Return statistics about fetchops.
+ */
+static int
+fetchop_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	struct node_fetchops *fops;
+	int len = 0, nid;
+
+	len += sprintf(page + len, "mappings               : %lu\n", fetchop_stats.map_count);
+	len += sprintf(page + len, "current fetchop pages  : %lu\n", fetchop_stats.pages_in_use);
+	len += sprintf(page + len, "maximum fetchop pages  : %lu\n", fetchop_stats.pages_total);
+
+	len += sprintf(page + len, "%4s %7s %7s\n", "node", "total", "free");
+	for (nid = 0; nid < numnodes; nid++) {
+		fops = node_fetchops[nid];
+		len += sprintf(page + len, "%4d %7d %7d\n", nid, fops ? fops->count : 0, fops ? atomic_read(&fops->free) : 0);
+	}
+
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len   -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+}
+
+static int
+fetchop_write_proc (struct file *file, const char *userbuf, unsigned long count, void *data)
+{
+    char buf[80];
+
+    if (copy_from_user(buf, userbuf, count < sizeof(buf) ? count : sizeof(buf)))
+        return -EFAULT;
+
+    return count;
+}
+#endif /* CONFIG_PROC_FS */
+
+/*
+ * fetchop_build_memmap,
+ *
+ * Called at boot time to build a map of pages that can be used for
+ * fetchops.
+ */
+static int __init
+fetchop_build_memmap(unsigned long start, unsigned long end, void *arg)
+{
+	struct node_fetchops *fops;
+	long count, bytes;
+
+	count = (end - start) >> PAGE_SHIFT;
+	bytes = sizeof(struct node_fetchops) + count/8;
+	fops = vmalloc(bytes);
+	memset(fops, 0, bytes);
+	fops->maddr = FETCHOP_KADDR_TO_MSPEC_ADDR(start);
+	fops->count = count;
+	atomic_add(count, &fops->free);
+	fetchop_stats.pages_total += count;
+	node_fetchops[MSPEC_TO_NID(start)] = fops;
+
+	sn_flush_all_caches((long)__va(start), end - start);
+
+	return 0;
+}
+
+
+
+/*
+ * fetchop_init
+ *
+ * Called at boot time to initialize the fetchop facility.
+ */
+static int __init
+fetchop_init(void)
+{
+	int ret;
+
+	if (!ia64_platform_is("sn2"))
+		return -ENODEV;
+
+	if ((ret = misc_register(&fetchop_miscdev))) {
+		printk(KERN_ERR "%s: failed to register device\n", DRIVER_ID_STR);
+		return ret;
+	}
+	printk(KERN_DEBUG "%s:  registered misc-device with minor %d\n", DRIVER_ID_STR, fetchop_miscdev.minor);
+
+#ifdef CONFIG_PROC_FS
+	if ((proc_fetchop = create_proc_entry(FETCHOP_BASENAME, 0644, NULL)) == NULL) {
+		printk(KERN_ERR "%s: unable to create proc entry", DRIVER_ID_STR);
+		misc_deregister(&fetchop_miscdev);
+		return -EINVAL;
+	}
+	proc_fetchop->read_proc = fetchop_read_proc;
+	proc_fetchop->write_proc = fetchop_write_proc;
+#endif /* CONFIG_PROC_FS */
+
+	efi_memmap_walk_att(EFI_MEMORY_UC, fetchop_build_memmap, 0);
+	printk(KERN_INFO "%s: v%s\n", DRIVER_ID_STR, REVISION);
+
+	return 0;
+}
+
+
+
+/*-----------------------------------------------------------------------------
+ * KERNEL APIs
+ * 	Note: right now, these APIs return a full page of fetchops.  If these
+ *	interfaces are used often for tasks which do not require a full page of
+ *	fetchops, new APIs should be added to suballocate out of a single page.
+ */
+
+unsigned long
+fetchop_kalloc_page(int nid)
+{
+	if (fetchop_update_stats(1, 1) < 0)
+		return 0;
+	return fetchop_alloc_page(nid);
+}
+EXPORT_SYMBOL(fetchop_kalloc_page);
+
+
+void
+fetchop_kfree_page(unsigned long maddr)
+{
+	fetchop_free_page(maddr);
+	fetchop_update_stats(-1, -1);
+}
+EXPORT_SYMBOL(fetchop_kfree_page);
+
+module_init(fetchop_init);
+
+MODULE_AUTHOR("Silicon Graphics, Inc.");
+MODULE_DESCRIPTION("Driver for SGI SN 'fetchop' atomic memory operations");
+MODULE_LICENSE("GPL");
diff -urNp linux-2.6.8/drivers/char/Kconfig linux-2.6.8.SUSE/drivers/char/Kconfig
--- linux-2.6.8/drivers/char/Kconfig	2004-08-30 15:46:58.537801196 +0200
+++ linux-2.6.8.SUSE/drivers/char/Kconfig	2004-08-30 15:47:12.313595848 +0200
@@ -381,6 +381,15 @@ config AU1000_SERIAL_CONSOLE
 	  If you have an Alchemy AU1000 processor (MIPS based) and you want
 	  to use a console on a serial port, say Y.  Otherwise, say N.
 
+config FETCHOP
+	bool "SGI Altix small TLB memory mapping support"
+	depends on IA64
+	default y if IA64
+	help
+	  Support small TLB entry memory mapping for special uncached
+	  operations that can operate without interference from
+	  kernel speculation.
+
 config QTRONIX_KEYBOARD
 	bool "Enable Qtronix 990P Keyboard Support"
 	depends on IT8712
diff -urNp linux-2.6.8/drivers/char/Makefile linux-2.6.8.SUSE/drivers/char/Makefile
--- linux-2.6.8/drivers/char/Makefile	2004-08-30 15:46:58.537801196 +0200
+++ linux-2.6.8.SUSE/drivers/char/Makefile	2004-08-30 15:47:38.423415926 +0200
@@ -42,6 +42,7 @@ obj-$(CONFIG_SX)		+= sx.o generic_serial
 obj-$(CONFIG_RIO)		+= rio/ generic_serial.o
 obj-$(CONFIG_HVC_CONSOLE)	+= hvc_console.o hvsi.o
 obj-$(CONFIG_RAW_DRIVER)	+= raw.o
+obj-$(CONFIG_FETCHOP)		+= fetchop.o
 obj-$(CONFIG_SGI_SNSC)		+= snsc.o
 obj-$(CONFIG_VIOCONS) += viocons.o
 obj-$(CONFIG_VIOTAPE)		+= viotape.o
diff -urNp linux-2.6.8/include/asm-ia64/fetchop.h linux-2.6.8.SUSE/include/asm-ia64/fetchop.h
--- linux-2.6.8/include/asm-ia64/fetchop.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.SUSE/include/asm-ia64/fetchop.h	2004-08-30 15:47:12.315595528 +0200
@@ -0,0 +1,85 @@
+/*
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 2001-2004 Silicon Graphics, Inc.  All rights reserved.
+ */
+
+#ifndef _ASM_IA64_SN_FETCHOP_H
+#define _ASM_IA64_SN_FETCHOP_H
+
+#include <linux/config.h>
+
+#define FETCHOP_BASENAME	"sgi_fetchop"
+#define FETCHOP_FULLNAME	"/dev/sgi_fetchop"
+
+
+
+#define FETCHOP_VAR_SIZE 64 /* 64 byte per fetchop variable */
+
+#define FETCHOP_LOAD		0
+#define FETCHOP_INCREMENT	8
+#define FETCHOP_DECREMENT	16
+#define FETCHOP_CLEAR		24
+
+#define FETCHOP_STORE		0
+#define FETCHOP_AND		24
+#define FETCHOP_OR		32
+
+#define FETCHOP_CLEAR_CACHE	56
+
+#define FETCHOP_LOAD_OP(addr, op) ( \
+         *(volatile long *)((char*) (addr) + (op)))
+
+#define FETCHOP_STORE_OP(addr, op, x) ( \
+         *(volatile long *)((char*) (addr) + (op)) = (long) (x))
+
+#ifdef __KERNEL__
+
+/*
+ * Convert a region 6 (kaddr) address to the address of the fetchop variable
+ */
+#define FETCHOP_KADDR_TO_MSPEC_ADDR(kaddr)	TO_MSPEC(kaddr)
+
+
+/*
+ * Each Atomic Memory Operation (AMO formerly known as fetchop)
+ * variable is 64 bytes long.  The first 8 bytes are used.  The
+ * remaining 56 bytes are unaddressable due to the operation taking
+ * that portion of the address.
+ * 
+ * NOTE: The AMO_t _MUST_ be placed in either the first or second half
+ * of the cache line.  The cache line _MUST NOT_ be used for anything
+ * other than additional AMO_t entries.  This is because there are two
+ * addresses which reference the same physical cache line.  One will
+ * be a cached entry with the memory type bits all set.  This address
+ * may be loaded into processor cache.  The AMO_t will be referenced
+ * uncached via the memory special memory type.  If any portion of the
+ * cached cache-line is modified, when that line is flushed, it will
+ * overwrite the uncached value in physical memory and lead to
+ * inconsistency.
+ */
+typedef struct {
+        u64 variable;
+        u64 unused[7];
+} AMO_t;
+
+
+/*
+ * The following APIs are externalized to the kernel to allocate/free pages of
+ * fetchop variables.
+ *	fetchop_kalloc_page	- Allocate/initialize 1 fetchop page on the
+ *				  specified cnode. 
+ *	fetchop_kfree_page	- Free a previously allocated fetchop page
+ */
+
+unsigned long fetchop_kalloc_page(int nid);
+void fetchop_kfree_page(unsigned long maddr);
+
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_IA64_SN_FETCHOP_H */
+
diff -urNp linux-2.6.8/include/asm-ia64/sn/arch.h linux-2.6.8.SUSE/include/asm-ia64/sn/arch.h
--- linux-2.6.8/include/asm-ia64/sn/arch.h	2004-08-14 07:36:56.000000000 +0200
+++ linux-2.6.8.SUSE/include/asm-ia64/sn/arch.h	2004-08-30 15:47:12.315595528 +0200
@@ -14,6 +14,7 @@
 #include <asm/types.h>
 #include <asm/sn/types.h>
 #include <asm/sn/sn_cpuid.h>
+#include <asm/sn/sn2/arch.h>
 
 typedef u64	shubreg_t;
 typedef u64	hubreg_t;
diff -urNp linux-2.6.8/include/linux/mm.h linux-2.6.8.SUSE/include/linux/mm.h
--- linux-2.6.8/include/linux/mm.h	2004-08-30 15:46:57.292000633 +0200
+++ linux-2.6.8.SUSE/include/linux/mm.h	2004-08-30 15:47:12.316595368 +0200
@@ -133,6 +133,7 @@ struct vm_area_struct {
 #define VM_DONTEXPAND	0x00040000	/* Cannot expand with mremap() */
 #define VM_RESERVED	0x00080000	/* Don't unmap it from swap_out */
 #define VM_ACCOUNT	0x00100000	/* Is a VM accounted object */
+#define VM_NONCACHED	0x00200000	/* Noncached access */
 #define VM_HUGETLB	0x00400000	/* Huge TLB Page VM */
 #define VM_NONLINEAR	0x00800000	/* Is non-linear (remap_file_pages) */
 
