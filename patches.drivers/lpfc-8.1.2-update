From: James Smart <James.Smart@emulex.com>
Subject: lpfc 8.1.2 driver update
References: 149107
Patch-Mainline: yes

This patch set updates the lpfc driver to revision 8.1.2, which includes
the following changes:

  - Remove several unused prototypes
  - Remove unreferenced cfg_fcp_bind_method from struct lpfc_hba
  - Remove unused SLI_IOCB_HIGH_PRIORITY
  - Handling of ELS commands RRQ, RPS, RPL and LIRR correctly
  - Fixed a race condition in the PLOGI retry logic.
  - Explicitly initialize the skip_post argument to lpfc_sli_send_reset
    on a ERATT interrupt.
  - Fixed system panic in lpfc_sli_brdreset during dynamic add of LP11K
  - Fixed a double insertion of mail box object to the SLI mailbox list.
  - Add module parameter to limit number of outstanding commands per lpfc HBA
  - Misc FC Discovery changes
  - Correct use of the hostdata field in scsi_host
  - Remove hba_list from struct lpfc_hba
  - Add ERROR and WARM_START modes for diagnostic purposes.
  - Added support for FAN
  - Make lpfc_els_rsp_rps_acc and lpfc_els_rsp_rpl_acc static
  - Code style changes for Discovery code
  - Allow turning on internal loop-back mode
  - Code cleanup of lpfc_mbx_cmpl_config_link
  - Fixed module parameter descriptions.
  - Fix panic caused by HBA resets and target side cable pulls
  - Modify RSCN handling to unregister rpis on lost FCP_TARGETs immediately
  - Change version number to 8.1.2

Signed-off-by: James Smart <James.Smart@emulex.com>
Acked-by: Hannes Reinecke <hare@suse.de>

diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_attr.c linux-2.6.15/drivers/scsi/lpfc/lpfc_attr.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_attr.c	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_attr.c	2006-02-09 15:44:58.417222701 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -79,7 +79,7 @@ static ssize_t
 lpfc_serialnum_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	return snprintf(buf, PAGE_SIZE, "%s\n",phba->SerialNumber);
 }
 
@@ -87,7 +87,7 @@ static ssize_t
 lpfc_modeldesc_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	return snprintf(buf, PAGE_SIZE, "%s\n",phba->ModelDesc);
 }
 
@@ -95,7 +95,7 @@ static ssize_t
 lpfc_modelname_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	return snprintf(buf, PAGE_SIZE, "%s\n",phba->ModelName);
 }
 
@@ -103,7 +103,7 @@ static ssize_t
 lpfc_programtype_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	return snprintf(buf, PAGE_SIZE, "%s\n",phba->ProgramType);
 }
 
@@ -111,7 +111,7 @@ static ssize_t
 lpfc_portnum_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	return snprintf(buf, PAGE_SIZE, "%s\n",phba->Port);
 }
 
@@ -119,7 +119,7 @@ static ssize_t
 lpfc_fwrev_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	char fwrev[32];
 	lpfc_decode_firmware_rev(phba, fwrev, 1);
 	return snprintf(buf, PAGE_SIZE, "%s\n",fwrev);
@@ -130,7 +130,7 @@ lpfc_hdw_show(struct class_device *cdev,
 {
 	char hdw[9];
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	lpfc_vpd_t *vp = &phba->vpd;
 	lpfc_jedec_to_ascii(vp->rev.biuRev, hdw);
 	return snprintf(buf, PAGE_SIZE, "%s\n", hdw);
@@ -139,16 +139,18 @@ static ssize_t
 lpfc_option_rom_version_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	return snprintf(buf, PAGE_SIZE, "%s\n", phba->OptionROMVersion);
 }
 static ssize_t
 lpfc_state_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	int len = 0;
 	switch (phba->hba_state) {
+	case LPFC_STATE_UNKNOWN:
+	case LPFC_WARM_START:
 	case LPFC_INIT_START:
 	case LPFC_INIT_MBX_CMDS:
 	case LPFC_LINK_DOWN:
@@ -194,7 +196,7 @@ static ssize_t
 lpfc_num_discovered_ports_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	return snprintf(buf, PAGE_SIZE, "%d\n", phba->fc_map_cnt +
 							phba->fc_unmap_cnt);
 }
@@ -203,7 +205,7 @@ lpfc_num_discovered_ports_show(struct cl
 static int
 lpfc_issue_lip(struct Scsi_Host *host)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba *) host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *) host->hostdata;
 	LPFC_MBOXQ_t *pmboxq;
 	int mbxstatus = MBXERR_ERROR;
 
@@ -235,7 +237,7 @@ static ssize_t
 lpfc_nport_evt_cnt_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	return snprintf(buf, PAGE_SIZE, "%d\n", phba->nport_event_cnt);
 }
 
@@ -243,7 +245,7 @@ static ssize_t
 lpfc_board_online_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 
 	if (phba->fc_flag & FC_OFFLINE_MODE)
 		return snprintf(buf, PAGE_SIZE, "0\n");
@@ -256,7 +258,7 @@ lpfc_board_online_store(struct class_dev
 								size_t count)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	struct completion online_compl;
 	int val=0, status=0;
 
@@ -279,10 +281,62 @@ lpfc_board_online_store(struct class_dev
 }
 
 static ssize_t
+lpfc_board_mode_show(struct class_device *cdev, char *buf)
+{
+	struct Scsi_Host *host = class_to_shost(cdev);
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
+	char  * state;
+
+	if (phba->hba_state == LPFC_HBA_ERROR)
+		state = "error";
+	else if (phba->hba_state == LPFC_WARM_START)
+		state = "warm start";
+	else if (phba->hba_state == LPFC_INIT_START)
+		state = "offline";
+	else
+		state = "online";
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", state);
+}
+
+static ssize_t
+lpfc_board_mode_store(struct class_device *cdev, const char *buf, size_t count)
+{
+	struct Scsi_Host *host = class_to_shost(cdev);
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
+	struct completion online_compl;
+	int status=0;
+
+	init_completion(&online_compl);
+
+	if(strncmp(buf, "online", sizeof("online") - 1) == 0)
+		lpfc_workq_post_event(phba, &status, &online_compl,
+				      LPFC_EVT_ONLINE);
+	else if (strncmp(buf, "offline", sizeof("offline") - 1) == 0)
+		lpfc_workq_post_event(phba, &status, &online_compl,
+				      LPFC_EVT_OFFLINE);
+	else if (strncmp(buf, "warm", sizeof("warm") - 1) == 0)
+		lpfc_workq_post_event(phba, &status, &online_compl,
+				      LPFC_EVT_WARM_START);
+ 	else if (strncmp(buf, "error", sizeof("error") - 1) == 0)
+		lpfc_workq_post_event(phba, &status, &online_compl,
+				      LPFC_EVT_KILL);
+	else
+		return -EINVAL;
+
+	wait_for_completion(&online_compl);
+
+	if (!status)
+		return strlen(buf);
+	else
+		return -EIO;
+}
+
+static ssize_t
 lpfc_poll_show(struct class_device *cdev, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 
 	return snprintf(buf, PAGE_SIZE, "%#x\n", phba->cfg_poll);
 }
@@ -292,7 +346,7 @@ lpfc_poll_store(struct class_device *cde
 		size_t count)
 {
 	struct Scsi_Host *host = class_to_shost(cdev);
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	uint32_t creg_val;
 	uint32_t old_val;
 	int val=0;
@@ -349,7 +403,7 @@ static ssize_t \
 lpfc_##attr##_show(struct class_device *cdev, char *buf) \
 { \
 	struct Scsi_Host *host = class_to_shost(cdev);\
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];\
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;\
 	int val = 0;\
 	val = phba->cfg_##attr;\
 	return snprintf(buf, PAGE_SIZE, "%d\n",\
@@ -361,7 +415,7 @@ static ssize_t \
 lpfc_##attr##_show(struct class_device *cdev, char *buf) \
 { \
 	struct Scsi_Host *host = class_to_shost(cdev);\
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];\
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;\
 	int val = 0;\
 	val = phba->cfg_##attr;\
 	return snprintf(buf, PAGE_SIZE, "%#x\n",\
@@ -404,7 +458,7 @@ static ssize_t \
 lpfc_##attr##_store(struct class_device *cdev, const char *buf, size_t count) \
 { \
 	struct Scsi_Host *host = class_to_shost(cdev);\
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];\
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;\
 	int val=0;\
 	if (!isdigit(buf[0]))\
 		return -EINVAL;\
@@ -480,6 +534,8 @@ static CLASS_DEVICE_ATTR(management_vers
 			 NULL);
 static CLASS_DEVICE_ATTR(board_online, S_IRUGO | S_IWUSR,
 			 lpfc_board_online_show, lpfc_board_online_store);
+static CLASS_DEVICE_ATTR(board_mode, S_IRUGO | S_IWUSR,
+			 lpfc_board_mode_show, lpfc_board_mode_store);
 
 static int lpfc_poll = 0;
 module_param(lpfc_poll, int, 0);
@@ -520,6 +576,16 @@ LPFC_ATTR_R(lun_queue_depth, 30, 1, 128,
 	    "Max number of FCP commands we can queue to a specific LUN");
 
 /*
+# hba_queue_depth:  This parameter is used to limit the number of outstanding
+# commands per lpfc HBA. Value range is [32,8192]. If this parameter
+# value is greater than the maximum number of exchanges supported by the HBA,
+# then maximum number of exchanges supported by the HBA is used to determine
+# the hba_queue_depth.
+*/
+LPFC_ATTR_R(hba_queue_depth, 8192, 32, 8192,
+	    "Max number of FCP commands we can queue to a lpfc HBA");
+
+/*
 # Some disk devices have a "select ID" or "select Target" capability.
 # From a protocol standpoint "select ID" usually means select the
 # Fibre channel "ALPA".  In the FC-AL Profile there is an "informative
@@ -550,6 +616,7 @@ LPFC_ATTR_RW(nodev_tmo, 30, 0, 255,
 /*
 # lpfc_topology:  link topology for init link
 #            0x0  = attempt loop mode then point-to-point
+#            0x01 = internal loopback mode
 #            0x02 = attempt point-to-point mode only
 #            0x04 = attempt loop mode only
 #            0x06 = attempt point-to-point mode then loop
@@ -557,7 +624,7 @@ LPFC_ATTR_RW(nodev_tmo, 30, 0, 255,
 # Set loop mode if you want to run as an NL_Port. Value range is [0,0x6].
 # Default value is 0.
 */
-LPFC_ATTR_R(topology, 0, 0, 6, "Select Fibre Channel topology");
+LPFC_ATTR_RW(topology, 0, 0, 6, "Select Fibre Channel topology");
 
 /*
 # lpfc_link_speed: Link speed selection for initializing the Fibre Channel
@@ -597,10 +664,10 @@ LPFC_ATTR_R(ack0, 0, 0, 1, "Enable ACK0 
 # is 0. Default value of cr_count is 1. The cr_count feature is disabled if
 # cr_delay is set to 0.
 */
-LPFC_ATTR_RW(cr_delay, 0, 0, 63, "A count of milliseconds after which an"
+LPFC_ATTR_RW(cr_delay, 0, 0, 63, "A count of milliseconds after which an "
 		"interrupt response is generated");
 
-LPFC_ATTR_RW(cr_count, 1, 1, 255, "A count of I/O completions after which an"
+LPFC_ATTR_RW(cr_count, 1, 1, 255, "A count of I/O completions after which an "
 		"interrupt response is generated");
 
 /*
@@ -616,7 +683,7 @@ LPFC_ATTR_RW(fdmi_on, 0, 0, 2, "Enable F
 # Specifies the maximum number of ELS cmds we can have outstanding (for
 # discovery). Value range is [1,64]. Default value = 32.
 */
-LPFC_ATTR(discovery_threads, 32, 1, 64, "Maximum number of ELS commands"
+LPFC_ATTR(discovery_threads, 32, 1, 64, "Maximum number of ELS commands "
 		 "during discovery");
 
 /*
@@ -649,6 +716,7 @@ struct class_device_attribute *lpfc_host
 	&class_device_attr_lpfc_drvr_version,
 	&class_device_attr_lpfc_log_verbose,
 	&class_device_attr_lpfc_lun_queue_depth,
+	&class_device_attr_lpfc_hba_queue_depth,
 	&class_device_attr_lpfc_nodev_tmo,
 	&class_device_attr_lpfc_fcp_class,
 	&class_device_attr_lpfc_use_adisc,
@@ -663,6 +731,7 @@ struct class_device_attribute *lpfc_host
 	&class_device_attr_nport_evt_cnt,
 	&class_device_attr_management_version,
 	&class_device_attr_board_online,
+	&class_device_attr_board_mode,
 	&class_device_attr_lpfc_poll,
 	&class_device_attr_lpfc_poll_tmo,
 	NULL,
@@ -674,7 +743,7 @@ sysfs_ctlreg_write(struct kobject *kobj,
 	size_t buf_off;
 	struct Scsi_Host *host = class_to_shost(container_of(kobj,
 					     struct class_device, kobj));
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 
 	if ((off + count) > FF_REG_AREA_SIZE)
 		return -ERANGE;
@@ -707,7 +776,7 @@ sysfs_ctlreg_read(struct kobject *kobj, 
 	uint32_t * tmp_ptr;
 	struct Scsi_Host *host = class_to_shost(container_of(kobj,
 					     struct class_device, kobj));
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 
 	if (off > FF_REG_AREA_SIZE)
 		return -ERANGE;
@@ -762,7 +831,7 @@ sysfs_mbox_write(struct kobject *kobj, c
 {
 	struct Scsi_Host * host =
 		class_to_shost(container_of(kobj, struct class_device, kobj));
-	struct lpfc_hba * phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba * phba = (struct lpfc_hba*)host->hostdata;
 	struct lpfcMboxq * mbox = NULL;
 
 	if ((count + off) > MAILBOX_CMD_SIZE)
@@ -815,7 +884,7 @@ sysfs_mbox_read(struct kobject *kobj, ch
 	struct Scsi_Host *host =
 		class_to_shost(container_of(kobj, struct class_device,
 					    kobj));
-	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)host->hostdata;
 	int rc;
 
 	if (off > sizeof(MAILBOX_t))
@@ -872,8 +941,11 @@ sysfs_mbox_read(struct kobject *kobj, ch
 		case MBX_DUMP_MEMORY:
 		case MBX_DOWN_LOAD:
 		case MBX_UPDATE_CFG:
+		case MBX_KILL_BOARD:
 		case MBX_LOAD_AREA:
 		case MBX_LOAD_EXP_ROM:
+		case MBX_BEACON:
+		case MBX_DEL_LD_ENTRY:
 			break;
 		case MBX_READ_SPARM64:
 		case MBX_READ_LA:
@@ -990,7 +1062,7 @@ lpfc_free_sysfs_attr(struct lpfc_hba *ph
 static void
 lpfc_get_host_port_id(struct Scsi_Host *shost)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata;
 	/* note: fc_myDID already in cpu endianness */
 	fc_host_port_id(shost) = phba->fc_myDID;
 }
@@ -998,7 +1070,7 @@ lpfc_get_host_port_id(struct Scsi_Host *
 static void
 lpfc_get_host_port_type(struct Scsi_Host *shost)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata;
 
 	spin_lock_irq(shost->host_lock);
 
@@ -1023,7 +1095,7 @@ lpfc_get_host_port_type(struct Scsi_Host
 static void
 lpfc_get_host_port_state(struct Scsi_Host *shost)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata;
 
 	spin_lock_irq(shost->host_lock);
 
@@ -1031,6 +1103,8 @@ lpfc_get_host_port_state(struct Scsi_Hos
 		fc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;
 	else {
 		switch (phba->hba_state) {
+		case LPFC_STATE_UNKNOWN:
+		case LPFC_WARM_START:
 		case LPFC_INIT_START:
 		case LPFC_INIT_MBX_CMDS:
 		case LPFC_LINK_DOWN:
@@ -1064,7 +1138,7 @@ lpfc_get_host_port_state(struct Scsi_Hos
 static void
 lpfc_get_host_speed(struct Scsi_Host *shost)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata;
 
 	spin_lock_irq(shost->host_lock);
 
@@ -1091,7 +1165,7 @@ lpfc_get_host_speed(struct Scsi_Host *sh
 static void
 lpfc_get_host_fabric_name (struct Scsi_Host *shost)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba*)shost->hostdata;
 	u64 node_name;
 
 	spin_lock_irq(shost->host_lock);
@@ -1113,7 +1187,7 @@ lpfc_get_host_fabric_name (struct Scsi_H
 static struct fc_host_statistics *
 lpfc_get_stats(struct Scsi_Host *shost)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba *)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *)shost->hostdata;
 	struct lpfc_sli *psli = &phba->sli;
 	struct fc_host_statistics *hs = &phba->link_stats;
 	LPFC_MBOXQ_t *pmboxq;
@@ -1203,7 +1277,7 @@ static void
 lpfc_get_starget_port_id(struct scsi_target *starget)
 {
 	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
-	struct lpfc_hba *phba = (struct lpfc_hba *) shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *) shost->hostdata;
 	uint32_t did = -1;
 	struct lpfc_nodelist *ndlp = NULL;
 
@@ -1224,7 +1298,7 @@ static void
 lpfc_get_starget_node_name(struct scsi_target *starget)
 {
 	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
-	struct lpfc_hba *phba = (struct lpfc_hba *) shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *) shost->hostdata;
 	u64 node_name = 0;
 	struct lpfc_nodelist *ndlp = NULL;
 
@@ -1245,7 +1319,7 @@ static void
 lpfc_get_starget_port_name(struct scsi_target *starget)
 {
 	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
-	struct lpfc_hba *phba = (struct lpfc_hba *) shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *) shost->hostdata;
 	u64 port_name = 0;
 	struct lpfc_nodelist *ndlp = NULL;
 
@@ -1411,5 +1485,9 @@ lpfc_get_cfgparam(struct lpfc_hba *phba)
 	default:
 		phba->cfg_hba_queue_depth = LPFC_DFT_HBA_Q_DEPTH;
 	}
+
+	if (phba->cfg_hba_queue_depth > lpfc_hba_queue_depth)
+		lpfc_hba_queue_depth_init(phba, lpfc_hba_queue_depth);
+
 	return;
 }
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_crtn.h linux-2.6.15/drivers/scsi/lpfc/lpfc_crtn.h
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_crtn.h	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_crtn.h	2006-02-09 15:44:58.381220535 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -26,6 +26,7 @@ void lpfc_clear_la(struct lpfc_hba *, LP
 void lpfc_config_link(struct lpfc_hba *, LPFC_MBOXQ_t *);
 int lpfc_read_sparam(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_read_config(struct lpfc_hba *, LPFC_MBOXQ_t *);
+void lpfc_read_lnk_stat(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_set_slim(struct lpfc_hba *, LPFC_MBOXQ_t *, uint32_t, uint32_t);
 int lpfc_reg_login(struct lpfc_hba *, uint32_t, uint8_t *, LPFC_MBOXQ_t *,
 		   uint32_t);
@@ -42,9 +43,6 @@ void lpfc_mbx_cmpl_reg_login(struct lpfc
 void lpfc_mbx_cmpl_fabric_reg_login(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_mbx_cmpl_ns_reg_login(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_mbx_cmpl_fdmi_reg_login(struct lpfc_hba *, LPFC_MBOXQ_t *);
-int lpfc_nlp_plogi(struct lpfc_hba *, struct lpfc_nodelist *);
-int lpfc_nlp_adisc(struct lpfc_hba *, struct lpfc_nodelist *);
-int lpfc_nlp_unmapped(struct lpfc_hba *, struct lpfc_nodelist *);
 int lpfc_nlp_list(struct lpfc_hba *, struct lpfc_nodelist *, int);
 void lpfc_set_disctmo(struct lpfc_hba *);
 int lpfc_can_disctmo(struct lpfc_hba *);
@@ -54,12 +52,10 @@ int lpfc_check_sli_ndlp(struct lpfc_hba 
 int lpfc_nlp_remove(struct lpfc_hba *, struct lpfc_nodelist *);
 void lpfc_nlp_init(struct lpfc_hba *, struct lpfc_nodelist *, uint32_t);
 struct lpfc_nodelist *lpfc_setup_disc_node(struct lpfc_hba *, uint32_t);
-struct lpfc_nodelist *lpfc_setup_rscn_node(struct lpfc_hba *, uint32_t);
 void lpfc_disc_list_loopmap(struct lpfc_hba *);
 void lpfc_disc_start(struct lpfc_hba *);
 void lpfc_disc_flush_list(struct lpfc_hba *);
 void lpfc_disc_timeout(unsigned long);
-void lpfc_scan_timeout(unsigned long);
 
 struct lpfc_nodelist *lpfc_findnode_rpi(struct lpfc_hba * phba, uint16_t rpi);
 
@@ -68,12 +64,6 @@ int lpfc_do_work(void *);
 int lpfc_disc_state_machine(struct lpfc_hba *, struct lpfc_nodelist *, void *,
 			    uint32_t);
 
-uint32_t lpfc_cmpl_prli_reglogin_issue(struct lpfc_hba *,
-				       struct lpfc_nodelist *, void *,
-				       uint32_t);
-uint32_t lpfc_cmpl_plogi_prli_issue(struct lpfc_hba *, struct lpfc_nodelist *,
-				    void *, uint32_t);
-
 int lpfc_check_sparm(struct lpfc_hba *, struct lpfc_nodelist *,
 		     struct serv_parm *, uint32_t);
 int lpfc_els_abort(struct lpfc_hba *, struct lpfc_nodelist * ndlp,
@@ -117,18 +107,15 @@ void lpfc_fdmi_tmo_handler(struct lpfc_h
 int lpfc_config_port_prep(struct lpfc_hba *);
 int lpfc_config_port_post(struct lpfc_hba *);
 int lpfc_hba_down_prep(struct lpfc_hba *);
+int lpfc_hba_down_post(struct lpfc_hba *);
 void lpfc_hba_init(struct lpfc_hba *, uint32_t *);
 int lpfc_post_buffer(struct lpfc_hba *, struct lpfc_sli_ring *, int, int);
 void lpfc_decode_firmware_rev(struct lpfc_hba *, char *, int);
-uint8_t *lpfc_get_lpfchba_info(struct lpfc_hba *, uint8_t *);
-int lpfc_fcp_abort(struct lpfc_hba *, int, int, int);
 int lpfc_online(struct lpfc_hba *);
 int lpfc_offline(struct lpfc_hba *);
 
-
 int lpfc_sli_setup(struct lpfc_hba *);
 int lpfc_sli_queue_setup(struct lpfc_hba *);
-void lpfc_slim_access(struct lpfc_hba *);
 
 void lpfc_handle_eratt(struct lpfc_hba *);
 void lpfc_handle_latt(struct lpfc_hba *);
@@ -137,6 +124,7 @@ irqreturn_t lpfc_intr_handler(int, void 
 void lpfc_read_rev(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_config_ring(struct lpfc_hba *, int, LPFC_MBOXQ_t *);
 void lpfc_config_port(struct lpfc_hba *, LPFC_MBOXQ_t *);
+void lpfc_kill_board(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_mbox_put(struct lpfc_hba *, LPFC_MBOXQ_t *);
 LPFC_MBOXQ_t *lpfc_mbox_get(struct lpfc_hba *);
 
@@ -149,6 +137,11 @@ void lpfc_sli_poll_fcp_ring(struct lpfc_
 struct lpfc_iocbq * lpfc_sli_get_iocbq(struct lpfc_hba *);
 void lpfc_sli_release_iocbq(struct lpfc_hba * phba, struct lpfc_iocbq * iocb);
 uint16_t lpfc_sli_next_iotag(struct lpfc_hba * phba, struct lpfc_iocbq * iocb);
+
+int lpfc_sli_brdready(struct lpfc_hba *, uint32_t);
+int lpfc_sli_brdkill(struct lpfc_hba *);
+int lpfc_sli_brdreset(struct lpfc_hba *);
+int lpfc_sli_brdrestart(struct lpfc_hba *);
 int lpfc_sli_hba_setup(struct lpfc_hba *);
 int lpfc_sli_hba_down(struct lpfc_hba *);
 int lpfc_sli_issue_mbox(struct lpfc_hba *, LPFC_MBOXQ_t *, uint32_t);
@@ -174,9 +167,6 @@ int lpfc_sli_abort_iocb(struct lpfc_hba 
 
 void lpfc_mbox_timeout(unsigned long);
 void lpfc_mbox_timeout_handler(struct lpfc_hba *);
-void lpfc_map_fcp_cmnd_to_bpl(struct lpfc_hba *, struct lpfc_scsi_buf *);
-void lpfc_free_scsi_cmd(struct lpfc_scsi_buf *);
-uint32_t lpfc_os_timeout_transform(struct lpfc_hba *, uint32_t);
 
 struct lpfc_nodelist *lpfc_findnode_did(struct lpfc_hba * phba, uint32_t order,
 					uint32_t did);
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_ct.c linux-2.6.15/drivers/scsi/lpfc/lpfc_ct.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_ct.c	2006-01-03 04:21:10.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_ct.c	2006-02-09 15:44:58.425223183 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -260,8 +260,10 @@ lpfc_gen_req(struct lpfc_hba *phba, stru
 	icmd->un.genreq64.w5.hcsw.Rctl = FC_UNSOL_CTL;
 	icmd->un.genreq64.w5.hcsw.Type = FC_COMMON_TRANSPORT_ULP;
 
-	if (!tmo)
-		tmo = (2 * phba->fc_ratov) + 1;
+	if (!tmo) {
+		 /* FC spec states we need 3 * ratov for CT requests */
+		tmo = (3 * phba->fc_ratov);
+	}
 	icmd->ulpTimeout = tmo;
 	icmd->ulpBdeCount = 1;
 	icmd->ulpLe = 1;
@@ -321,6 +323,7 @@ lpfc_ns_rsp(struct lpfc_hba * phba, stru
 	struct lpfc_sli_ct_request *Response =
 		(struct lpfc_sli_ct_request *) mp->virt;
 	struct lpfc_nodelist *ndlp = NULL;
+	struct lpfc_nodelist *next_ndlp;
 	struct lpfc_dmabuf *mlast, *next_mp;
 	uint32_t *ctptr = (uint32_t *) & Response->un.gid.PortType;
 	uint32_t Did;
@@ -389,8 +392,36 @@ lpfc_ns_rsp(struct lpfc_hba * phba, stru
 nsout1:
 	list_del(&head);
 
-	/* Here we are finished in the case RSCN */
+	/*
+ 	 * The driver has cycled through all Nports in the RSCN payload.
+ 	 * Complete the handling by cleaning up and marking the
+ 	 * current driver state.
+ 	 */
 	if (phba->hba_state == LPFC_HBA_READY) {
+
+		/*
+		 * Switch ports that connect a loop of multiple targets need
+		 * special consideration.  The driver wants to unregister the
+		 * rpi only on the target that was pulled from the loop.  On
+		 * RSCN, the driver wants to rediscover an NPort only if the
+		 * driver flagged it as NLP_NPR_2B_DISC.  Provided adisc is
+		 * not enabled and the NPort is not capable of retransmissions
+		 * (FC Tape) prevent timing races with the scsi error handler by
+		 * unregistering the Nport's RPI.  This action causes all
+		 * outstanding IO to flush back to the midlayer.
+		 */
+		list_for_each_entry_safe(ndlp, next_ndlp, &phba->fc_npr_list,
+					 nlp_listp) {
+			if (!(ndlp->nlp_flag & NLP_NPR_2B_DISC) &&
+			    (lpfc_rscn_payload_check(phba, ndlp->nlp_DID))) {
+				if ((phba->cfg_use_adisc == 0) &&
+				    !(ndlp->nlp_fcp_info &
+				      NLP_FCP_2_DEVICE)) {
+					lpfc_unreg_rpi(phba, ndlp);
+					ndlp->nlp_flag &= ~NLP_NPR_ADISC;
+				}
+			}
+		}
 		lpfc_els_flush_rscn(phba);
 		spin_lock_irq(phba->host->host_lock);
 		phba->fc_flag |= FC_RSCN_MODE; /* we are still in RSCN mode */
@@ -449,6 +480,11 @@ lpfc_cmpl_ct_cmd_gid_ft(struct lpfc_hba 
 		CTrsp = (struct lpfc_sli_ct_request *) outp->virt;
 		if (CTrsp->CommandResponse.bits.CmdRsp ==
 		    be16_to_cpu(SLI_CT_RESPONSE_FS_ACC)) {
+			lpfc_printf_log(phba, KERN_INFO, LOG_DISCOVERY,
+					"%d:0239 NameServer Rsp "
+					"Data: x%x\n",
+					phba->brd_no,
+					phba->fc_flag);
 			lpfc_ns_rsp(phba, outp,
 				    (uint32_t) (irsp->un.genreq64.bdl.bdeSize));
 		} else if (CTrsp->CommandResponse.bits.CmdRsp ==
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_disc.h linux-2.6.15/drivers/scsi/lpfc/lpfc_disc.h
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_disc.h	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_disc.h	2006-02-09 15:44:58.397221498 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -28,18 +28,24 @@
  * This is used by Fibre Channel protocol to support FCP.
  */
 
+/* worker thread events */
+enum lpfc_work_type {
+	LPFC_EVT_NODEV_TMO,
+	LPFC_EVT_ONLINE,
+	LPFC_EVT_OFFLINE,
+	LPFC_EVT_WARM_START,
+	LPFC_EVT_KILL,
+	LPFC_EVT_ELS_RETRY,
+};
+
 /* structure used to queue event to the discovery tasklet */
 struct lpfc_work_evt {
 	struct list_head      evt_listp;
 	void                * evt_arg1;
 	void                * evt_arg2;
-	uint32_t              evt;
+	enum lpfc_work_type   evt;
 };
 
-#define LPFC_EVT_NODEV_TMO	0x1
-#define LPFC_EVT_ONLINE		0x2
-#define LPFC_EVT_OFFLINE	0x3
-#define LPFC_EVT_ELS_RETRY	0x4
 
 struct lpfc_nodelist {
 	struct list_head nlp_listp;
@@ -56,6 +62,7 @@ struct lpfc_nodelist {
 
 	uint16_t        nlp_rpi;
 	uint16_t        nlp_state;		/* state transition indicator */
+	uint16_t        nlp_prev_state;		/* state transition indicator */
 	uint16_t        nlp_xri;		/* output exchange id for RPI */
 	uint16_t        nlp_sid;		/* scsi id */
 #define NLP_NO_SID		0xffff
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_els.c linux-2.6.15/drivers/scsi/lpfc/lpfc_els.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_els.c	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_els.c	2006-02-09 15:44:58.409222220 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -92,7 +92,7 @@ lpfc_els_chk_latt(struct lpfc_hba * phba
 		}
 	}
 
-	return (1);
+	return 1;
 
 }
 
@@ -235,7 +235,7 @@ lpfc_prep_els_iocb(struct lpfc_hba * phb
 				ndlp->nlp_DID, icmd->ulpIoTag, cmdSize);
 	}
 
-	return (elsiocb);
+	return elsiocb;
 }
 
 
@@ -446,9 +446,10 @@ lpfc_cmpl_els_flogi(struct lpfc_hba * ph
 		lpfc_printf_log(phba,
 				KERN_INFO,
 				LOG_ELS,
-				"%d:0100 FLOGI failure Data: x%x x%x\n",
+				"%d:0100 FLOGI failure Data: x%x x%x x%x\n",
 				phba->brd_no,
-				irsp->ulpStatus, irsp->un.ulpWord[4]);
+				irsp->ulpStatus, irsp->un.ulpWord[4],
+				irsp->ulpTimeout);
 		goto flogifail;
 	}
 
@@ -517,7 +518,7 @@ lpfc_issue_els_flogi(struct lpfc_hba * p
 	cmdsize = (sizeof (uint32_t) + sizeof (struct serv_parm));
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 1, cmdsize, retry,
 					  ndlp, ELS_CMD_FLOGI)) == 0) {
-		return (1);
+		return 1;
 	}
 
 	icmd = &elsiocb->iocb;
@@ -552,9 +553,9 @@ lpfc_issue_els_flogi(struct lpfc_hba * p
 	spin_unlock_irq(phba->host->host_lock);
 	if (rc == IOCB_ERROR) {
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
-	return (0);
+	return 0;
 }
 
 int
@@ -611,29 +612,21 @@ lpfc_initial_flogi(struct lpfc_hba * phb
 {
 	struct lpfc_nodelist *ndlp;
 
-	/* First look for Fabric ndlp on the unmapped list */
-
-	if ((ndlp =
-	     lpfc_findnode_did(phba, NLP_SEARCH_UNMAPPED,
-			       Fabric_DID)) == 0) {
+	/* First look for the Fabric ndlp */
+	ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, Fabric_DID);
+	if (!ndlp) {
 		/* Cannot find existing Fabric ndlp, so allocate a new one */
-		if ((ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL))
-		    == 0) {
-			return (0);
-		}
+		ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);
+		if (!ndlp)
+			return 0;
 		lpfc_nlp_init(phba, ndlp, Fabric_DID);
-	}
-	else {
-		phba->fc_unmap_cnt--;
-		list_del(&ndlp->nlp_listp);
-		spin_lock_irq(phba->host->host_lock);
-		ndlp->nlp_flag &= ~NLP_LIST_MASK;
-		spin_unlock_irq(phba->host->host_lock);
+	} else {
+		lpfc_nlp_list(phba, ndlp, NLP_JUST_DQ);
 	}
 	if (lpfc_issue_els_flogi(phba, ndlp, 0)) {
 		mempool_free( ndlp, phba->nlp_mem_pool);
 	}
-	return (1);
+	return 1;
 }
 
 static void
@@ -675,22 +668,23 @@ lpfc_cmpl_els_plogi(struct lpfc_hba * ph
 
 	irsp = &rspiocb->iocb;
 	ndlp = (struct lpfc_nodelist *) cmdiocb->context1;
-	spin_lock_irq(phba->host->host_lock);
-	ndlp->nlp_flag &= ~NLP_PLOGI_SND;
-	spin_unlock_irq(phba->host->host_lock);
 
 	/* Since ndlp can be freed in the disc state machine, note if this node
 	 * is being used during discovery.
 	 */
 	disc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);
+	spin_lock_irq(phba->host->host_lock);
+	ndlp->nlp_flag &= ~(NLP_PLOGI_SND | NLP_NPR_2B_DISC);
+	spin_unlock_irq(phba->host->host_lock);
 	rc   = 0;
 
 	/* PLOGI completes to NPort <nlp_DID> */
 	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
 			"%d:0102 PLOGI completes to NPort x%x "
-			"Data: x%x x%x x%x x%x\n",
+			"Data: x%x x%x x%x x%x x%x\n",
 			phba->brd_no, ndlp->nlp_DID, irsp->ulpStatus,
-			irsp->un.ulpWord[4], disc, phba->num_disc_nodes);
+			irsp->un.ulpWord[4], irsp->ulpTimeout, disc,
+			phba->num_disc_nodes);
 
 	/* Check to see if link went down during discovery */
 	if (lpfc_els_chk_latt(phba)) {
@@ -722,9 +716,8 @@ lpfc_cmpl_els_plogi(struct lpfc_hba * ph
 		   ((irsp->un.ulpWord[4] == IOERR_SLI_ABORTED) ||
 		   (irsp->un.ulpWord[4] == IOERR_LINK_DOWN) ||
 		   (irsp->un.ulpWord[4] == IOERR_SLI_DOWN))) {
-			disc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);
-		}
-		else {
+			rc = NLP_STE_FREED_NODE;
+		} else {
 			rc = lpfc_disc_state_machine(phba, ndlp, cmdiocb,
 					NLP_EVT_CMPL_PLOGI);
 		}
@@ -747,18 +740,11 @@ lpfc_cmpl_els_plogi(struct lpfc_hba * ph
 		lpfc_more_plogi(phba);
 	}
 
-	if (rc != NLP_STE_FREED_NODE) {
+	if (phba->num_disc_nodes == 0) {
 		spin_lock_irq(phba->host->host_lock);
-		ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
+		phba->fc_flag &= ~FC_NDISC_ACTIVE;
 		spin_unlock_irq(phba->host->host_lock);
-	}
 
-	if (phba->num_disc_nodes == 0) {
-		if(disc) {
-			spin_lock_irq(phba->host->host_lock);
-			phba->fc_flag &= ~FC_NDISC_ACTIVE;
-			spin_unlock_irq(phba->host->host_lock);
-		}
 		lpfc_can_disctmo(phba);
 		if (phba->fc_flag & FC_RSCN_MODE) {
 			/* Check to see if more RSCNs came in while we were
@@ -796,10 +782,10 @@ lpfc_issue_els_plogi(struct lpfc_hba * p
 	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
 
 	cmdsize = (sizeof (uint32_t) + sizeof (struct serv_parm));
-	if ((elsiocb = lpfc_prep_els_iocb(phba, 1, cmdsize, retry,
-					  ndlp, ELS_CMD_PLOGI)) == 0) {
-		return (1);
-	}
+	elsiocb = lpfc_prep_els_iocb(phba, 1, cmdsize, retry, ndlp,
+								ELS_CMD_PLOGI);
+	if (!elsiocb)
+		return 1;
 
 	icmd = &elsiocb->iocb;
 	pcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);
@@ -824,10 +810,10 @@ lpfc_issue_els_plogi(struct lpfc_hba * p
 		ndlp->nlp_flag &= ~NLP_PLOGI_SND;
 		spin_unlock_irq(phba->host->host_lock);
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
 	spin_unlock_irq(phba->host->host_lock);
-	return (0);
+	return 0;
 }
 
 static void
@@ -851,9 +837,10 @@ lpfc_cmpl_els_prli(struct lpfc_hba * phb
 	/* PRLI completes to NPort <nlp_DID> */
 	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
 			"%d:0103 PRLI completes to NPort x%x "
-			"Data: x%x x%x x%x\n",
+			"Data: x%x x%x x%x x%x\n",
 			phba->brd_no, ndlp->nlp_DID, irsp->ulpStatus,
-			irsp->un.ulpWord[4], phba->num_disc_nodes);
+			irsp->un.ulpWord[4], irsp->ulpTimeout,
+			phba->num_disc_nodes);
 
 	phba->fc_prli_sent--;
 	/* Check to see if link went down during discovery */
@@ -873,8 +860,7 @@ lpfc_cmpl_els_prli(struct lpfc_hba * phb
 		   (irsp->un.ulpWord[4] == IOERR_LINK_DOWN) ||
 		   (irsp->un.ulpWord[4] == IOERR_SLI_DOWN))) {
 			goto out;
-		}
-		else {
+		} else {
 			lpfc_disc_state_machine(phba, ndlp, cmdiocb,
 					NLP_EVT_CMPL_PRLI);
 		}
@@ -906,7 +892,7 @@ lpfc_issue_els_prli(struct lpfc_hba * ph
 	cmdsize = (sizeof (uint32_t) + sizeof (PRLI));
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 1, cmdsize, retry,
 					  ndlp, ELS_CMD_PRLI)) == 0) {
-		return (1);
+		return 1;
 	}
 
 	icmd = &elsiocb->iocb;
@@ -943,11 +929,11 @@ lpfc_issue_els_prli(struct lpfc_hba * ph
 		ndlp->nlp_flag &= ~NLP_PRLI_SND;
 		spin_unlock_irq(phba->host->host_lock);
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
 	spin_unlock_irq(phba->host->host_lock);
 	phba->fc_prli_sent++;
-	return (0);
+	return 0;
 }
 
 static void
@@ -1016,21 +1002,22 @@ lpfc_cmpl_els_adisc(struct lpfc_hba * ph
 
 	irsp = &(rspiocb->iocb);
 	ndlp = (struct lpfc_nodelist *) cmdiocb->context1;
-	spin_lock_irq(phba->host->host_lock);
-	ndlp->nlp_flag &= ~NLP_ADISC_SND;
-	spin_unlock_irq(phba->host->host_lock);
 
 	/* Since ndlp can be freed in the disc state machine, note if this node
 	 * is being used during discovery.
 	 */
 	disc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);
+	spin_lock_irq(phba->host->host_lock);
+	ndlp->nlp_flag &= ~(NLP_ADISC_SND | NLP_NPR_2B_DISC);
+	spin_unlock_irq(phba->host->host_lock);
 
 	/* ADISC completes to NPort <nlp_DID> */
 	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
 			"%d:0104 ADISC completes to NPort x%x "
-			"Data: x%x x%x x%x x%x\n",
+			"Data: x%x x%x x%x x%x x%x\n",
 			phba->brd_no, ndlp->nlp_DID, irsp->ulpStatus,
-			irsp->un.ulpWord[4], disc, phba->num_disc_nodes);
+			irsp->un.ulpWord[4], irsp->ulpTimeout, disc,
+			phba->num_disc_nodes);
 
 	/* Check to see if link went down during discovery */
 	if (lpfc_els_chk_latt(phba)) {
@@ -1054,13 +1041,10 @@ lpfc_cmpl_els_adisc(struct lpfc_hba * ph
 		}
 		/* ADISC failed */
 		/* Do not call DSM for lpfc_els_abort'ed ELS cmds */
-		if ((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&
-		   ((irsp->un.ulpWord[4] == IOERR_SLI_ABORTED) ||
-		   (irsp->un.ulpWord[4] == IOERR_LINK_DOWN) ||
-		   (irsp->un.ulpWord[4] == IOERR_SLI_DOWN))) {
-			disc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);
-		}
-		else {
+		if ((irsp->ulpStatus != IOSTAT_LOCAL_REJECT) ||
+		   ((irsp->un.ulpWord[4] != IOERR_SLI_ABORTED) &&
+		   (irsp->un.ulpWord[4] != IOERR_LINK_DOWN) &&
+		   (irsp->un.ulpWord[4] != IOERR_SLI_DOWN))) {
 			lpfc_disc_state_machine(phba, ndlp, cmdiocb,
 					NLP_EVT_CMPL_ADISC);
 		}
@@ -1112,9 +1096,6 @@ lpfc_cmpl_els_adisc(struct lpfc_hba * ph
 			}
 		}
 	}
-	spin_lock_irq(phba->host->host_lock);
-	ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
-	spin_unlock_irq(phba->host->host_lock);
 out:
 	lpfc_els_free_iocb(phba, cmdiocb);
 	return;
@@ -1138,7 +1119,7 @@ lpfc_issue_els_adisc(struct lpfc_hba * p
 	cmdsize = (sizeof (uint32_t) + sizeof (ADISC));
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 1, cmdsize, retry,
 					  ndlp, ELS_CMD_ADISC)) == 0) {
-		return (1);
+		return 1;
 	}
 
 	icmd = &elsiocb->iocb;
@@ -1163,10 +1144,10 @@ lpfc_issue_els_adisc(struct lpfc_hba * p
 		ndlp->nlp_flag &= ~NLP_ADISC_SND;
 		spin_unlock_irq(phba->host->host_lock);
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
 	spin_unlock_irq(phba->host->host_lock);
-	return (0);
+	return 0;
 }
 
 static void
@@ -1190,9 +1171,10 @@ lpfc_cmpl_els_logo(struct lpfc_hba * phb
 	/* LOGO completes to NPort <nlp_DID> */
 	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
 			"%d:0105 LOGO completes to NPort x%x "
-			"Data: x%x x%x x%x\n",
+			"Data: x%x x%x x%x x%x\n",
 			phba->brd_no, ndlp->nlp_DID, irsp->ulpStatus,
-			irsp->un.ulpWord[4], phba->num_disc_nodes);
+			irsp->un.ulpWord[4], irsp->ulpTimeout,
+			phba->num_disc_nodes);
 
 	/* Check to see if link went down during discovery */
 	if (lpfc_els_chk_latt(phba))
@@ -1211,18 +1193,15 @@ lpfc_cmpl_els_logo(struct lpfc_hba * phb
 		   (irsp->un.ulpWord[4] == IOERR_LINK_DOWN) ||
 		   (irsp->un.ulpWord[4] == IOERR_SLI_DOWN))) {
 			goto out;
-		}
-		else {
+		} else {
 			lpfc_disc_state_machine(phba, ndlp, cmdiocb,
 					NLP_EVT_CMPL_LOGO);
 		}
 	} else {
-		/* Good status, call state machine */
+		/* Good status, call state machine.
+		 * This will unregister the rpi if needed.
+		 */
 		lpfc_disc_state_machine(phba, ndlp, cmdiocb, NLP_EVT_CMPL_LOGO);
-
-		if (ndlp->nlp_flag & NLP_DELAY_TMO) {
-			lpfc_unreg_rpi(phba, ndlp);
-		}
 	}
 
 out:
@@ -1247,7 +1226,7 @@ lpfc_issue_els_logo(struct lpfc_hba * ph
 	cmdsize = 2 * (sizeof (uint32_t) + sizeof (struct lpfc_name));
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 1, cmdsize, retry,
 					  ndlp, ELS_CMD_LOGO)) == 0) {
-		return (1);
+		return 1;
 	}
 
 	icmd = &elsiocb->iocb;
@@ -1268,10 +1247,10 @@ lpfc_issue_els_logo(struct lpfc_hba * ph
 		ndlp->nlp_flag &= ~NLP_LOGO_SND;
 		spin_unlock_irq(phba->host->host_lock);
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
 	spin_unlock_irq(phba->host->host_lock);
-	return (0);
+	return 0;
 }
 
 static void
@@ -1286,9 +1265,10 @@ lpfc_cmpl_els_cmd(struct lpfc_hba * phba
 	lpfc_printf_log(phba,
 			KERN_INFO,
 			LOG_ELS,
-			"%d:0106 ELS cmd tag x%x completes Data: x%x x%x\n",
+			"%d:0106 ELS cmd tag x%x completes Data: x%x x%x x%x\n",
 			phba->brd_no,
-			irsp->ulpIoTag, irsp->ulpStatus, irsp->un.ulpWord[4]);
+			irsp->ulpIoTag, irsp->ulpStatus,
+			irsp->un.ulpWord[4], irsp->ulpTimeout);
 
 	/* Check to see if link went down during discovery */
 	lpfc_els_chk_latt(phba);
@@ -1310,16 +1290,16 @@ lpfc_issue_els_scr(struct lpfc_hba * phb
 	psli = &phba->sli;
 	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
 	cmdsize = (sizeof (uint32_t) + sizeof (SCR));
-	if ((ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL)) == 0) {
-		return (1);
-	}
+	ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);
+	if (!ndlp)
+		return 1;
 
 	lpfc_nlp_init(phba, ndlp, nportid);
 
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 1, cmdsize, retry,
 					  ndlp, ELS_CMD_SCR)) == 0) {
 		mempool_free( ndlp, phba->nlp_mem_pool);
-		return (1);
+		return 1;
 	}
 
 	icmd = &elsiocb->iocb;
@@ -1339,11 +1319,11 @@ lpfc_issue_els_scr(struct lpfc_hba * phb
 		spin_unlock_irq(phba->host->host_lock);
 		mempool_free( ndlp, phba->nlp_mem_pool);
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
 	spin_unlock_irq(phba->host->host_lock);
 	mempool_free( ndlp, phba->nlp_mem_pool);
-	return (0);
+	return 0;
 }
 
 static int
@@ -1363,15 +1343,15 @@ lpfc_issue_els_farpr(struct lpfc_hba * p
 	psli = &phba->sli;
 	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
 	cmdsize = (sizeof (uint32_t) + sizeof (FARP));
-	if ((ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL)) == 0) {
-		return (1);
-	}
+	ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);
+	if (!ndlp)
+		return 1;
 	lpfc_nlp_init(phba, ndlp, nportid);
 
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 1, cmdsize, retry,
 					  ndlp, ELS_CMD_RNID)) == 0) {
 		mempool_free( ndlp, phba->nlp_mem_pool);
-		return (1);
+		return 1;
 	}
 
 	icmd = &elsiocb->iocb;
@@ -1405,11 +1385,11 @@ lpfc_issue_els_farpr(struct lpfc_hba * p
 		spin_unlock_irq(phba->host->host_lock);
 		mempool_free( ndlp, phba->nlp_mem_pool);
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
 	spin_unlock_irq(phba->host->host_lock);
 	mempool_free( ndlp, phba->nlp_mem_pool);
-	return (0);
+	return 0;
 }
 
 void
@@ -1450,8 +1430,9 @@ lpfc_els_retry_delay_handler(struct lpfc
 
 	phba = ndlp->nlp_phba;
 	spin_lock_irq(phba->host->host_lock);
-	did = (uint32_t) (ndlp->nlp_DID);
-	cmd = (uint32_t) (ndlp->nlp_last_elscmd);
+	did = ndlp->nlp_DID;
+	cmd = ndlp->nlp_last_elscmd;
+	ndlp->nlp_last_elscmd = 0;
 
 	if (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {
 		spin_unlock_irq(phba->host->host_lock);
@@ -1467,24 +1448,32 @@ lpfc_els_retry_delay_handler(struct lpfc
 		lpfc_issue_els_flogi(phba, ndlp, retry);
 		break;
 	case ELS_CMD_PLOGI:
-		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
-		lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
-		lpfc_issue_els_plogi(phba, ndlp, retry);
+		if (!lpfc_issue_els_plogi(phba, ndlp, retry)) {
+			ndlp->nlp_prev_state = ndlp->nlp_state;
+			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+			lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
+		}
 		break;
 	case ELS_CMD_ADISC:
-		ndlp->nlp_state = NLP_STE_ADISC_ISSUE;
-		lpfc_nlp_list(phba, ndlp, NLP_ADISC_LIST);
-		lpfc_issue_els_adisc(phba, ndlp, retry);
+		if (!lpfc_issue_els_adisc(phba, ndlp, retry)) {
+			ndlp->nlp_prev_state = ndlp->nlp_state;
+			ndlp->nlp_state = NLP_STE_ADISC_ISSUE;
+			lpfc_nlp_list(phba, ndlp, NLP_ADISC_LIST);
+		}
 		break;
 	case ELS_CMD_PRLI:
-		ndlp->nlp_state = NLP_STE_PRLI_ISSUE;
-		lpfc_nlp_list(phba, ndlp, NLP_PRLI_LIST);
-		lpfc_issue_els_prli(phba, ndlp, retry);
+		if (!lpfc_issue_els_prli(phba, ndlp, retry)) {
+			ndlp->nlp_prev_state = ndlp->nlp_state;
+			ndlp->nlp_state = NLP_STE_PRLI_ISSUE;
+			lpfc_nlp_list(phba, ndlp, NLP_PRLI_LIST);
+		}
 		break;
 	case ELS_CMD_LOGO:
-		ndlp->nlp_state = NLP_STE_NPR_NODE;
-		lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
-		lpfc_issue_els_logo(phba, ndlp, retry);
+		if (!lpfc_issue_els_logo(phba, ndlp, retry)) {
+			ndlp->nlp_prev_state = ndlp->nlp_state;
+			ndlp->nlp_state = NLP_STE_NPR_NODE;
+			lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
+		}
 		break;
 	}
 	return;
@@ -1537,11 +1526,6 @@ lpfc_els_retry(struct lpfc_hba * phba, s
 
 		case IOERR_SEQUENCE_TIMEOUT:
 			retry = 1;
-			if ((cmd == ELS_CMD_FLOGI)
-			    && (phba->fc_topology != TOPOLOGY_LOOP)) {
-				delay = 1;
-				maxretry = 48;
-			}
 			break;
 
 		case IOERR_NO_RESOURCES:
@@ -1646,36 +1630,41 @@ lpfc_els_retry(struct lpfc_hba * phba, s
 			mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ);
 			ndlp->nlp_flag |= NLP_DELAY_TMO;
 
+			ndlp->nlp_prev_state = ndlp->nlp_state;
 			ndlp->nlp_state = NLP_STE_NPR_NODE;
 			lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 			ndlp->nlp_last_elscmd = cmd;
 
-			return (1);
+			return 1;
 		}
 		switch (cmd) {
 		case ELS_CMD_FLOGI:
 			lpfc_issue_els_flogi(phba, ndlp, cmdiocb->retry);
-			return (1);
+			return 1;
 		case ELS_CMD_PLOGI:
+			ndlp->nlp_prev_state = ndlp->nlp_state;
 			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
 			lpfc_issue_els_plogi(phba, ndlp, cmdiocb->retry);
-			return (1);
+			return 1;
 		case ELS_CMD_ADISC:
+			ndlp->nlp_prev_state = ndlp->nlp_state;
 			ndlp->nlp_state = NLP_STE_ADISC_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_ADISC_LIST);
 			lpfc_issue_els_adisc(phba, ndlp, cmdiocb->retry);
-			return (1);
+			return 1;
 		case ELS_CMD_PRLI:
+			ndlp->nlp_prev_state = ndlp->nlp_state;
 			ndlp->nlp_state = NLP_STE_PRLI_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_PRLI_LIST);
 			lpfc_issue_els_prli(phba, ndlp, cmdiocb->retry);
-			return (1);
+			return 1;
 		case ELS_CMD_LOGO:
+			ndlp->nlp_prev_state = ndlp->nlp_state;
 			ndlp->nlp_state = NLP_STE_NPR_NODE;
 			lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 			lpfc_issue_els_logo(phba, ndlp, cmdiocb->retry);
-			return (1);
+			return 1;
 		}
 	}
 
@@ -1686,7 +1675,7 @@ lpfc_els_retry(struct lpfc_hba * phba, s
 			phba->brd_no,
 			cmd, ndlp->nlp_DID, cmdiocb->retry, ndlp->nlp_flag);
 
-	return (0);
+	return 0;
 }
 
 int
@@ -1735,10 +1724,6 @@ lpfc_cmpl_els_logo_acc(struct lpfc_hba *
 			phba->brd_no, ndlp->nlp_DID, ndlp->nlp_flag,
 			ndlp->nlp_state, ndlp->nlp_rpi);
 
-	spin_lock_irq(phba->host->host_lock);
-	ndlp->nlp_flag &= ~NLP_LOGO_ACC;
-	spin_unlock_irq(phba->host->host_lock);
-
 	switch (ndlp->nlp_state) {
 	case NLP_STE_UNUSED_NODE:	/* node is just allocated */
 		lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
@@ -1776,11 +1761,12 @@ lpfc_cmpl_els_acc(struct lpfc_hba * phba
 	/* ELS response tag <ulpIoTag> completes */
 	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
 			"%d:0110 ELS response tag x%x completes "
-			"Data: x%x x%x x%x x%x x%x x%x\n",
+			"Data: x%x x%x x%x x%x x%x x%x x%x\n",
 			phba->brd_no,
 			cmdiocb->iocb.ulpIoTag, rspiocb->iocb.ulpStatus,
-			rspiocb->iocb.un.ulpWord[4], ndlp->nlp_DID,
-			ndlp->nlp_flag, ndlp->nlp_state, ndlp->nlp_rpi);
+			rspiocb->iocb.un.ulpWord[4], rspiocb->iocb.ulpTimeout,
+ 			ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,
+			ndlp->nlp_rpi);
 
 	if (mbox) {
 		if ((rspiocb->iocb.ulpStatus == 0)
@@ -1791,6 +1777,7 @@ lpfc_cmpl_els_acc(struct lpfc_hba * phba
 			lpfc_unreg_rpi(phba, ndlp);
 			mbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;
 			mbox->context2 = ndlp;
+			ndlp->nlp_prev_state = ndlp->nlp_state;
 			ndlp->nlp_state = NLP_STE_REG_LOGIN_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_REGLOGIN_LIST);
 			if (lpfc_sli_issue_mbox(phba, mbox,
@@ -1805,6 +1792,7 @@ lpfc_cmpl_els_acc(struct lpfc_hba * phba
 			mempool_free( mbox, phba->mbox_mem_pool);
 			if (ndlp->nlp_flag & NLP_ACC_REGLOGIN) {
 				lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
+				ndlp = NULL;
 			}
 		}
 	}
@@ -1842,7 +1830,8 @@ lpfc_els_rsp_acc(struct lpfc_hba * phba,
 		if ((elsiocb =
 		     lpfc_prep_els_iocb(phba, 0, cmdsize, oldiocb->retry,
 					ndlp, ELS_CMD_ACC)) == 0) {
-			return (1);
+			ndlp->nlp_flag &= ~NLP_LOGO_ACC;
+			return 1;
 		}
 		icmd = &elsiocb->iocb;
 		icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
@@ -1855,7 +1844,7 @@ lpfc_els_rsp_acc(struct lpfc_hba * phba,
 		if ((elsiocb =
 		     lpfc_prep_els_iocb(phba, 0, cmdsize, oldiocb->retry,
 					ndlp, ELS_CMD_ACC)) == 0) {
-			return (1);
+			return 1;
 		}
 		icmd = &elsiocb->iocb;
 		icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
@@ -1869,7 +1858,7 @@ lpfc_els_rsp_acc(struct lpfc_hba * phba,
 		memcpy(pcmd, &phba->fc_sparam, sizeof (struct serv_parm));
 		break;
 	default:
-		return (1);
+		return 1;
 	}
 
 	if (newnode)
@@ -1885,6 +1874,9 @@ lpfc_els_rsp_acc(struct lpfc_hba * phba,
 			ndlp->nlp_flag, ndlp->nlp_state, ndlp->nlp_rpi);
 
 	if (ndlp->nlp_flag & NLP_LOGO_ACC) {
+		spin_lock_irq(phba->host->host_lock);
+		ndlp->nlp_flag &= ~NLP_LOGO_ACC;
+		spin_unlock_irq(phba->host->host_lock);
 		elsiocb->iocb_cmpl = lpfc_cmpl_els_logo_acc;
 	} else {
 		elsiocb->iocb_cmpl = lpfc_cmpl_els_acc;
@@ -1896,9 +1888,9 @@ lpfc_els_rsp_acc(struct lpfc_hba * phba,
 	spin_unlock_irq(phba->host->host_lock);
 	if (rc == IOCB_ERROR) {
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
-	return (0);
+	return 0;
 }
 
 int
@@ -1920,7 +1912,7 @@ lpfc_els_rsp_reject(struct lpfc_hba * ph
 	cmdsize = 2 * sizeof (uint32_t);
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 0, cmdsize, oldiocb->retry,
 					  ndlp, ELS_CMD_LS_RJT)) == 0) {
-		return (1);
+		return 1;
 	}
 
 	icmd = &elsiocb->iocb;
@@ -1948,9 +1940,9 @@ lpfc_els_rsp_reject(struct lpfc_hba * ph
 	spin_unlock_irq(phba->host->host_lock);
 	if (rc == IOCB_ERROR) {
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
-	return (0);
+	return 0;
 }
 
 int
@@ -1973,7 +1965,7 @@ lpfc_els_rsp_adisc_acc(struct lpfc_hba *
 	cmdsize = sizeof (uint32_t) + sizeof (ADISC);
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 0, cmdsize, oldiocb->retry,
 					  ndlp, ELS_CMD_ACC)) == 0) {
-		return (1);
+		return 1;
 	}
 
 	/* Xmit ADISC ACC response tag <ulpIoTag> */
@@ -2006,9 +1998,9 @@ lpfc_els_rsp_adisc_acc(struct lpfc_hba *
 	spin_unlock_irq(phba->host->host_lock);
 	if (rc == IOCB_ERROR) {
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
-	return (0);
+	return 0;
 }
 
 int
@@ -2030,13 +2022,10 @@ lpfc_els_rsp_prli_acc(struct lpfc_hba * 
 	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
 
 	cmdsize = sizeof (uint32_t) + sizeof (PRLI);
-	if ((elsiocb = lpfc_prep_els_iocb(phba, 0, cmdsize, oldiocb->retry,
-					  ndlp,
-					  (ELS_CMD_ACC |
-					   (ELS_CMD_PRLI & ~ELS_RSP_MASK)))) ==
-	    0) {
-		return (1);
-	}
+	elsiocb = lpfc_prep_els_iocb(phba, 0, cmdsize, oldiocb->retry, ndlp,
+				(ELS_CMD_ACC | (ELS_CMD_PRLI & ~ELS_RSP_MASK)));
+	if (!elsiocb)
+		return 1;
 
 	/* Xmit PRLI ACC response tag <ulpIoTag> */
 	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
@@ -2086,9 +2075,9 @@ lpfc_els_rsp_prli_acc(struct lpfc_hba * 
 	spin_unlock_irq(phba->host->host_lock);
 	if (rc == IOCB_ERROR) {
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
-	return (0);
+	return 0;
 }
 
 static int
@@ -2116,7 +2105,7 @@ lpfc_els_rsp_rnid_acc(struct lpfc_hba * 
 
 	if ((elsiocb = lpfc_prep_els_iocb(phba, 0, cmdsize, oldiocb->retry,
 					  ndlp, ELS_CMD_ACC)) == 0) {
-		return (1);
+		return 1;
 	}
 
 	/* Xmit RNID ACC response tag <ulpIoTag> */
@@ -2169,9 +2158,9 @@ lpfc_els_rsp_rnid_acc(struct lpfc_hba * 
 	spin_unlock_irq(phba->host->host_lock);
 	if (rc == IOCB_ERROR) {
 		lpfc_els_free_iocb(phba, elsiocb);
-		return (1);
+		return 1;
 	}
-	return (0);
+	return 0;
 }
 
 int
@@ -2187,6 +2176,7 @@ lpfc_els_disc_adisc(struct lpfc_hba * ph
 		if (ndlp->nlp_flag & NLP_NPR_2B_DISC) {
 			if (ndlp->nlp_flag & NLP_NPR_ADISC) {
 				ndlp->nlp_flag &= ~NLP_NPR_ADISC;
+				ndlp->nlp_prev_state = ndlp->nlp_state;
 				ndlp->nlp_state = NLP_STE_ADISC_ISSUE;
 				lpfc_nlp_list(phba, ndlp,
 					NLP_ADISC_LIST);
@@ -2208,7 +2198,7 @@ lpfc_els_disc_adisc(struct lpfc_hba * ph
 		phba->fc_flag &= ~FC_NLP_MORE;
 		spin_unlock_irq(phba->host->host_lock);
 	}
-	return(sentadisc);
+	return sentadisc;
 }
 
 int
@@ -2224,6 +2214,7 @@ lpfc_els_disc_plogi(struct lpfc_hba * ph
 		if ((ndlp->nlp_flag & NLP_NPR_2B_DISC) &&
 		   (!(ndlp->nlp_flag & NLP_DELAY_TMO))) {
 			if (!(ndlp->nlp_flag & NLP_NPR_ADISC)) {
+				ndlp->nlp_prev_state = ndlp->nlp_state;
 				ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
 				lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
 				lpfc_issue_els_plogi(phba, ndlp, 0);
@@ -2244,7 +2235,7 @@ lpfc_els_disc_plogi(struct lpfc_hba * ph
 		phba->fc_flag &= ~FC_NLP_MORE;
 		spin_unlock_irq(phba->host->host_lock);
 	}
-	return(sentplogi);
+	return sentplogi;
 }
 
 int
@@ -2264,7 +2255,7 @@ lpfc_els_flush_rscn(struct lpfc_hba * ph
 	phba->fc_flag &= ~(FC_RSCN_MODE | FC_RSCN_DISCOVERY);
 	spin_unlock_irq(phba->host->host_lock);
 	lpfc_can_disctmo(phba);
-	return (0);
+	return 0;
 }
 
 int
@@ -2285,7 +2276,7 @@ lpfc_rscn_payload_check(struct lpfc_hba 
 
 	/* If we are doing a FULL RSCN rediscovery, match everything */
 	if (phba->fc_flag & FC_RSCN_DISCOVERY) {
-		return (did);
+		return did;
 	}
 
 	for (i = 0; i < phba->fc_rscn_id_cnt; i++) {
@@ -2333,7 +2324,7 @@ lpfc_rscn_payload_check(struct lpfc_hba 
 			}
 		}
 	}
-	return (match);
+	return match;
 }
 
 static int
@@ -2365,8 +2356,13 @@ lpfc_rscn_recovery_check(struct lpfc_hba
 
 			lpfc_disc_state_machine(phba, ndlp, NULL,
 					NLP_EVT_DEVICE_RECOVERY);
+
+			/* Make sure NLP_DELAY_TMO is NOT running
+			 * after a device recovery event.
+			 */
 			if (ndlp->nlp_flag & NLP_DELAY_TMO) {
 				ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+				ndlp->nlp_last_elscmd = 0;
 				del_timer_sync(&ndlp->nlp_delayfunc);
 				if (!list_empty(&ndlp->
 						els_retry_evt.evt_listp))
@@ -2375,7 +2371,7 @@ lpfc_rscn_recovery_check(struct lpfc_hba
 			}
 		}
 	}
-	return (0);
+	return 0;
 }
 
 static int
@@ -2411,7 +2407,7 @@ lpfc_els_rcv_rscn(struct lpfc_hba * phba
 	if (phba->hba_state < LPFC_NS_QRY) {
 		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL,
 								newnode);
-		return (0);
+		return 0;
 	}
 
 	/* If we are already processing an RSCN, save the received
@@ -2453,7 +2449,7 @@ lpfc_els_rcv_rscn(struct lpfc_hba * phba
 
 		/* send RECOVERY event for ALL nodes that match RSCN payload */
 		lpfc_rscn_recovery_check(phba);
-		return (0);
+		return 0;
 	}
 
 	phba->fc_flag |= FC_RSCN_MODE;
@@ -2472,7 +2468,7 @@ lpfc_els_rcv_rscn(struct lpfc_hba * phba
 	/* send RECOVERY event for ALL nodes that match RSCN payload */
 	lpfc_rscn_recovery_check(phba);
 
-	return (lpfc_els_handle_rscn(phba));
+	return lpfc_els_handle_rscn(phba);
 }
 
 int
@@ -2494,40 +2490,41 @@ lpfc_els_handle_rscn(struct lpfc_hba * p
 
 	/* To process RSCN, first compare RSCN data with NameServer */
 	phba->fc_ns_retry = 0;
-	if ((ndlp = lpfc_findnode_did(phba, NLP_SEARCH_UNMAPPED,
-				      NameServer_DID))) {
+	ndlp = lpfc_findnode_did(phba, NLP_SEARCH_UNMAPPED, NameServer_DID);
+	if (ndlp) {
 		/* Good ndlp, issue CT Request to NameServer */
 		if (lpfc_ns_cmd(phba, ndlp, SLI_CTNS_GID_FT) == 0) {
 			/* Wait for NameServer query cmpl before we can
 			   continue */
-			return (1);
+			return 1;
 		}
 	} else {
 		/* If login to NameServer does not exist, issue one */
 		/* Good status, issue PLOGI to NameServer */
-		if ((ndlp =
-		     lpfc_findnode_did(phba, NLP_SEARCH_ALL, NameServer_DID))) {
+		ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, NameServer_DID);
+		if (ndlp) {
 			/* Wait for NameServer login cmpl before we can
 			   continue */
-			return (1);
+			return 1;
 		}
-		if ((ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL))
-		    == 0) {
+		ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);
+		if (!ndlp) {
 			lpfc_els_flush_rscn(phba);
-			return (0);
+			return 0;
 		} else {
 			lpfc_nlp_init(phba, ndlp, NameServer_DID);
 			ndlp->nlp_type |= NLP_FABRIC;
+			ndlp->nlp_prev_state = ndlp->nlp_state;
 			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
 			lpfc_issue_els_plogi(phba, ndlp, 0);
 			/* Wait for NameServer login cmpl before we can
 			   continue */
-			return (1);
+			return 1;
 		}
 	}
 
 	lpfc_els_flush_rscn(phba);
-	return (0);
+	return 0;
 }
 
 static int
@@ -2561,7 +2558,7 @@ lpfc_els_rcv_flogi(struct lpfc_hba * phb
 				"%d:0113 An FLOGI ELS command x%x was received "
 				"from DID x%x in Loop Mode\n",
 				phba->brd_no, cmd, did);
-		return (1);
+		return 1;
 	}
 
 	did = Fabric_DID;
@@ -2577,7 +2574,7 @@ lpfc_els_rcv_flogi(struct lpfc_hba * phb
 		if (!rc) {
 			if ((mbox = mempool_alloc(phba->mbox_mem_pool,
 						  GFP_KERNEL)) == 0) {
-				return (1);
+				return 1;
 			}
 			lpfc_linkdown(phba);
 			lpfc_init_link(phba, mbox,
@@ -2590,9 +2587,8 @@ lpfc_els_rcv_flogi(struct lpfc_hba * phb
 			if (rc == MBX_NOT_FINISHED) {
 				mempool_free( mbox, phba->mbox_mem_pool);
 			}
-			return (1);
-		}
-		else if (rc > 0) {	/* greater than */
+			return 1;
+		} else if (rc > 0) {	/* greater than */
 			spin_lock_irq(phba->host->host_lock);
 			phba->fc_flag |= FC_PT2PT_PLOGI;
 			spin_unlock_irq(phba->host->host_lock);
@@ -2606,13 +2602,13 @@ lpfc_els_rcv_flogi(struct lpfc_hba * phb
 		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
 		stat.un.b.vendorUnique = 0;
 		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
-		return (1);
+		return 1;
 	}
 
 	/* Send back ACC */
 	lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, NULL, newnode);
 
-	return (0);
+	return 0;
 }
 
 static int
@@ -2650,45 +2646,246 @@ lpfc_els_rcv_rnid(struct lpfc_hba * phba
 		stat.un.b.vendorUnique = 0;
 		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
 	}
-	return (0);
+	return 0;
 }
 
 static int
-lpfc_els_rcv_rrq(struct lpfc_hba * phba, struct lpfc_iocbq * cmdiocb,
+lpfc_els_rcv_lirr(struct lpfc_hba * phba, struct lpfc_iocbq * cmdiocb,
+		 struct lpfc_nodelist * ndlp)
+{
+	struct ls_rjt stat;
+
+	/* For now, unconditionally reject this command */
+	stat.un.b.lsRjtRsvd0 = 0;
+	stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+	stat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;
+	stat.un.b.vendorUnique = 0;
+	lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	return 0;
+}
+
+static void
+lpfc_els_rsp_rps_acc(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)
+{
+	struct lpfc_sli *psli;
+	struct lpfc_sli_ring *pring;
+	MAILBOX_t *mb;
+	IOCB_t *icmd;
+	RPS_RSP *rps_rsp;
+	uint8_t *pcmd;
+	struct lpfc_iocbq *elsiocb;
+	struct lpfc_nodelist *ndlp;
+	uint16_t xri, status;
+	uint32_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];
+	mb = &pmb->mb;
+
+	ndlp = (struct lpfc_nodelist *) pmb->context2;
+	xri = (uint16_t) ((unsigned long)(pmb->context1));
+	pmb->context1 = 0;
+	pmb->context2 = 0;
+
+	if (mb->mbxStatus) {
+		mempool_free( pmb, phba->mbox_mem_pool);
+		return;
+	}
+
+	cmdsize = sizeof(RPS_RSP) + sizeof(uint32_t);
+	mempool_free( pmb, phba->mbox_mem_pool);
+	elsiocb = lpfc_prep_els_iocb(phba, 0, cmdsize, lpfc_max_els_tries,
+					  		ndlp, ELS_CMD_ACC);
+	if (!elsiocb)
+		return;
+
+	icmd = &elsiocb->iocb;
+	icmd->ulpContext = xri;
+
+	pcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);
+	*((uint32_t *) (pcmd)) = ELS_CMD_ACC;
+	pcmd += sizeof (uint32_t); /* Skip past command */
+	rps_rsp = (RPS_RSP *)pcmd;
+
+	if (phba->fc_topology != TOPOLOGY_LOOP)
+		status = 0x10;
+	else
+		status = 0x8;
+	if (phba->fc_flag & FC_FABRIC)
+		status |= 0x4;
+
+	rps_rsp->rsvd1 = 0;
+	rps_rsp->portStatus = be16_to_cpu(status);
+	rps_rsp->linkFailureCnt = be32_to_cpu(mb->un.varRdLnk.linkFailureCnt);
+	rps_rsp->lossSyncCnt = be32_to_cpu(mb->un.varRdLnk.lossSyncCnt);
+	rps_rsp->lossSignalCnt = be32_to_cpu(mb->un.varRdLnk.lossSignalCnt);
+	rps_rsp->primSeqErrCnt = be32_to_cpu(mb->un.varRdLnk.primSeqErrCnt);
+	rps_rsp->invalidXmitWord = be32_to_cpu(mb->un.varRdLnk.invalidXmitWord);
+	rps_rsp->crcCnt = be32_to_cpu(mb->un.varRdLnk.crcCnt);
+
+	/* Xmit ELS RPS ACC response tag <ulpIoTag> */
+	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
+			"%d:0128 Xmit ELS RPS ACC response tag x%x "
+			"Data: x%x x%x x%x x%x x%x\n",
+			phba->brd_no,
+			elsiocb->iocb.ulpIoTag,
+			elsiocb->iocb.ulpContext, ndlp->nlp_DID,
+			ndlp->nlp_flag, ndlp->nlp_state, ndlp->nlp_rpi);
+
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_acc;
+	phba->fc_stat.elsXmitACC++;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, 0) == IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+	}
+	return;
+}
+
+static int
+lpfc_els_rcv_rps(struct lpfc_hba * phba, struct lpfc_iocbq * cmdiocb,
 		 struct lpfc_nodelist * ndlp)
 {
-	struct lpfc_dmabuf *pcmd;
 	uint32_t *lp;
+	uint8_t flag;
+	LPFC_MBOXQ_t *mbox;
+	struct lpfc_dmabuf *pcmd;
+	RPS *rps;
+	struct ls_rjt stat;
+
+	if ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&
+	    (ndlp->nlp_state != NLP_STE_MAPPED_NODE)) {
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	}
+
+	pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;
+	lp = (uint32_t *) pcmd->virt;
+	flag = (be32_to_cpu(*lp++) & 0xf);
+	rps = (RPS *) lp;
+
+	if ((flag == 0) ||
+	    ((flag == 1) && (be32_to_cpu(rps->un.portNum) == 0)) ||
+	    ((flag == 2) && (memcmp(&rps->un.portName, &phba->fc_portname,
+			   sizeof (struct lpfc_name)) == 0))) {
+		if ((mbox = mempool_alloc(phba->mbox_mem_pool, GFP_ATOMIC))) {
+			lpfc_read_lnk_stat(phba, mbox);
+			mbox->context1 =
+			    (void *)((unsigned long)cmdiocb->iocb.ulpContext);
+			mbox->context2 = ndlp;
+			mbox->mbox_cmpl = lpfc_els_rsp_rps_acc;
+			if (lpfc_sli_issue_mbox (phba, mbox,
+			    (MBX_NOWAIT | MBX_STOP_IOCB)) != MBX_NOT_FINISHED) {
+				/* Mbox completion will send ELS Response */
+				return 0;
+			}
+			mempool_free(mbox, phba->mbox_mem_pool);
+		}
+	}
+	stat.un.b.lsRjtRsvd0 = 0;
+	stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+	stat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;
+	stat.un.b.vendorUnique = 0;
+	lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	return 0;
+}
+
+static int
+lpfc_els_rsp_rpl_acc(struct lpfc_hba * phba, uint16_t cmdsize,
+		 struct lpfc_iocbq * oldiocb, struct lpfc_nodelist * ndlp)
+{
 	IOCB_t *icmd;
+	IOCB_t *oldcmd;
+	RPL_RSP rpl_rsp;
+	struct lpfc_iocbq *elsiocb;
 	struct lpfc_sli_ring *pring;
 	struct lpfc_sli *psli;
-	RRQ *rrq;
-	uint32_t cmd, did;
+	uint8_t *pcmd;
 
 	psli = &phba->sli;
-	pring = &psli->ring[LPFC_FCP_RING];
-	icmd = &cmdiocb->iocb;
-	did = icmd->un.elsreq64.remoteID;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	if ((elsiocb =
+	     lpfc_prep_els_iocb(phba, 0, cmdsize, oldiocb->retry,
+				ndlp, ELS_CMD_ACC)) == 0) {
+		return 1;
+	}
+	icmd = &elsiocb->iocb;
+	oldcmd = &oldiocb->iocb;
+	icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
+
+	pcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);
+	*((uint32_t *) (pcmd)) = ELS_CMD_ACC;
+	pcmd += sizeof (uint16_t);
+	*((uint16_t *)(pcmd)) = be16_to_cpu(cmdsize);
+	pcmd += sizeof(uint16_t);
+
+	/* Setup the RPL ACC payload */
+	rpl_rsp.listLen = be32_to_cpu(1);
+	rpl_rsp.index = 0;
+	rpl_rsp.port_num_blk.portNum = 0;
+	rpl_rsp.port_num_blk.portID = be32_to_cpu(phba->fc_myDID);
+	memcpy(&rpl_rsp.port_num_blk.portName, &phba->fc_portname,
+	    sizeof(struct lpfc_name));
+
+	memcpy(pcmd, &rpl_rsp, cmdsize - sizeof(uint32_t));
+
+
+	/* Xmit ELS RPL ACC response tag <ulpIoTag> */
+	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
+			"%d:0128 Xmit ELS RPL ACC response tag x%x "
+			"Data: x%x x%x x%x x%x x%x\n",
+			phba->brd_no,
+			elsiocb->iocb.ulpIoTag,
+			elsiocb->iocb.ulpContext, ndlp->nlp_DID,
+			ndlp->nlp_flag, ndlp->nlp_state, ndlp->nlp_rpi);
+
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_acc;
+
+	phba->fc_stat.elsXmitACC++;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, 0) == IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return 1;
+	}
+	return 0;
+}
+
+static int
+lpfc_els_rcv_rpl(struct lpfc_hba * phba, struct lpfc_iocbq * cmdiocb,
+		 struct lpfc_nodelist * ndlp)
+{
+	struct lpfc_dmabuf *pcmd;
+	uint32_t *lp;
+	uint32_t maxsize;
+	uint16_t cmdsize;
+	RPL *rpl;
+	struct ls_rjt stat;
+
+	if ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&
+	    (ndlp->nlp_state != NLP_STE_MAPPED_NODE)) {
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	}
+
 	pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;
 	lp = (uint32_t *) pcmd->virt;
+	rpl = (RPL *) (lp + 1);
 
-	cmd = *lp++;
-	rrq = (RRQ *) lp;
+	maxsize = be32_to_cpu(rpl->maxsize);
 
-	/* RRQ received */
-	/* Get oxid / rxid from payload and abort it */
-	spin_lock_irq(phba->host->host_lock);
-	if ((rrq->SID == be32_to_cpu(phba->fc_myDID))) {
-		lpfc_sli_abort_iocb(phba, pring, 0, 0, rrq->Oxid,
-							LPFC_CTX_CTX);
+	/* We support only one port */
+	if ((rpl->index == 0) &&
+	    ((maxsize == 0) ||
+	     ((maxsize * sizeof(uint32_t)) >= sizeof(RPL_RSP)))) {
+		cmdsize = sizeof(uint32_t) + sizeof(RPL_RSP);
 	} else {
-		lpfc_sli_abort_iocb(phba, pring, 0, 0, rrq->Rxid,
-							LPFC_CTX_CTX);
+		cmdsize = sizeof(uint32_t) + maxsize * sizeof(uint32_t);
 	}
-
-	spin_unlock_irq(phba->host->host_lock);
-	/* ACCEPT the rrq request */
-	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
+	lpfc_els_rsp_rpl_acc(phba, cmdsize, cmdiocb, ndlp);
 
 	return 0;
 }
@@ -2720,7 +2917,7 @@ lpfc_els_rcv_farp(struct lpfc_hba * phba
 
 	/* We will only support match on WWPN or WWNN */
 	if (fp->Mflags & ~(FARP_MATCH_NODE | FARP_MATCH_PORT)) {
-		return (0);
+		return 0;
 	}
 
 	cnt = 0;
@@ -2743,6 +2940,7 @@ lpfc_els_rcv_farp(struct lpfc_hba * phba
 		   (ndlp->nlp_state == NLP_STE_MAPPED_NODE)) {
 			/* Log back into the node before sending the FARP. */
 			if (fp->Rflags & FARP_REQUEST_PLOGI) {
+				ndlp->nlp_prev_state = ndlp->nlp_state;
 				ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
 				lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
 				lpfc_issue_els_plogi(phba, ndlp, 0);
@@ -2754,7 +2952,7 @@ lpfc_els_rcv_farp(struct lpfc_hba * phba
 			}
 		}
 	}
-	return (0);
+	return 0;
 }
 
 static int
@@ -2787,47 +2985,89 @@ lpfc_els_rcv_farpr(struct lpfc_hba * phb
 
 static int
 lpfc_els_rcv_fan(struct lpfc_hba * phba, struct lpfc_iocbq * cmdiocb,
-		 struct lpfc_nodelist * ndlp)
+		 struct lpfc_nodelist * fan_ndlp)
 {
 	struct lpfc_dmabuf *pcmd;
 	uint32_t *lp;
 	IOCB_t *icmd;
-	FAN *fp;
 	uint32_t cmd, did;
+	FAN *fp;
+	struct lpfc_nodelist *ndlp, *next_ndlp;
+
+	/* FAN received */
+	lpfc_printf_log(phba, KERN_INFO, LOG_ELS, "%d:265 FAN received\n",
+								phba->brd_no);
 
 	icmd = &cmdiocb->iocb;
 	did = icmd->un.elsreq64.remoteID;
-	pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;
-	lp = (uint32_t *) pcmd->virt;
+	pcmd = (struct lpfc_dmabuf *)cmdiocb->context2;
+	lp = (uint32_t *)pcmd->virt;
 
 	cmd = *lp++;
-	fp = (FAN *) lp;
+	fp = (FAN *)lp;
 
-	/* FAN received */
-
-	/* ACCEPT the FAN request */
-	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
+	/* FAN received; Fan does not have a reply sequence */
 
 	if (phba->hba_state == LPFC_LOCAL_CFG_LINK) {
-		/* The discovery state machine needs to take a different
-		 * action if this node has switched fabrics
-		 */
-		if ((memcmp(&fp->FportName, &phba->fc_fabparam.portName,
-			    sizeof (struct lpfc_name)) != 0)
-		    ||
-		    (memcmp(&fp->FnodeName, &phba->fc_fabparam.nodeName,
-			    sizeof (struct lpfc_name)) != 0)) {
-			/* This node has switched fabrics.  An FLOGI is required
-			 * after the timeout
+		if ((memcmp(&phba->fc_fabparam.nodeName, &fp->FnodeName,
+			sizeof(struct lpfc_name)) != 0) ||
+		    (memcmp(&phba->fc_fabparam.portName, &fp->FportName,
+			sizeof(struct lpfc_name)) != 0)) {
+			/*
+			 * This node has switched fabrics.  FLOGI is required
+			 * Clean up the old rpi's
 			 */
-			return (0);
+
+			list_for_each_entry_safe(ndlp, next_ndlp,
+				&phba->fc_npr_list, nlp_listp) {
+
+				if (ndlp->nlp_type & NLP_FABRIC) {
+					/*
+					 * Clean up old Fabric, Nameserver and
+					 * other NLP_FABRIC logins
+					 */
+					lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
+				} else if (!(ndlp->nlp_flag & NLP_NPR_ADISC)) {
+					/* Fail outstanding I/O now since this
+					 * device is marked for PLOGI
+					 */
+					lpfc_unreg_rpi(phba, ndlp);
+				}
+			}
+
+			phba->hba_state = LPFC_FLOGI;
+			lpfc_set_disctmo(phba);
+			lpfc_initial_flogi(phba);
+			return 0;
 		}
+		/* Discovery not needed,
+		 * move the nodes to their original state.
+		 */
+		list_for_each_entry_safe(ndlp, next_ndlp, &phba->fc_npr_list,
+			nlp_listp) {
 
-		/* Start discovery */
+			switch (ndlp->nlp_prev_state) {
+			case NLP_STE_UNMAPPED_NODE:
+				ndlp->nlp_prev_state = NLP_STE_NPR_NODE;
+				ndlp->nlp_state = NLP_STE_UNMAPPED_NODE;
+				lpfc_nlp_list(phba, ndlp, NLP_UNMAPPED_LIST);
+				break;
+
+			case NLP_STE_MAPPED_NODE:
+				ndlp->nlp_prev_state = NLP_STE_NPR_NODE;
+				ndlp->nlp_state = NLP_STE_MAPPED_NODE;
+				lpfc_nlp_list(phba, ndlp, NLP_MAPPED_LIST);
+				break;
+
+			default:
+				break;
+			}
+		}
+
+		/* Start discovery - this should just do CLEAR_LA */
 		lpfc_disc_start(phba);
 	}
-
-	return (0);
+	return 0;
 }
 
 void
@@ -2950,7 +3190,6 @@ lpfc_els_flush_cmd(struct lpfc_hba * phb
 	struct lpfc_dmabuf *pcmd;
 	uint32_t *elscmd;
 	uint32_t els_command;
-	uint32_t remote_ID;
 
 	pring = &phba->sli.ring[LPFC_ELS_RING];
 	spin_lock_irq(phba->host->host_lock);
@@ -2973,18 +3212,6 @@ lpfc_els_flush_cmd(struct lpfc_hba * phb
 		elscmd = (uint32_t *) (pcmd->virt);
 		els_command = *elscmd;
 
-		if (cmd->ulpCommand == CMD_GEN_REQUEST64_CR) {
-			struct lpfc_nodelist *ndlp;
-
-			ndlp = lpfc_findnode_rpi(phba, cmd->ulpContext);
-			remote_ID = ndlp->nlp_DID;
-			if (phba->hba_state == LPFC_HBA_READY) {
-				continue;
-			}
-		} else {
-			remote_ID = cmd->un.elsreq64.remoteID;
-		}
-
 		list_del(&piocb->list);
 		pring->txcmplq_cnt--;
 
@@ -2995,8 +3222,7 @@ lpfc_els_flush_cmd(struct lpfc_hba * phb
 			spin_unlock_irq(phba->host->host_lock);
 			(piocb->iocb_cmpl) (phba, piocb, piocb);
 			spin_lock_irq(phba->host->host_lock);
-		}
-		else
+		} else
 			lpfc_sli_release_iocbq(phba, piocb);
 	}
 
@@ -3010,18 +3236,6 @@ lpfc_els_flush_cmd(struct lpfc_hba * phb
 		elscmd = (uint32_t *) (pcmd->virt);
 		els_command = *elscmd;
 
-		if (cmd->ulpCommand == CMD_GEN_REQUEST64_CR) {
-			struct lpfc_nodelist *ndlp;
-
-			ndlp = lpfc_findnode_rpi(phba, cmd->ulpContext);
-			remote_ID = ndlp->nlp_DID;
-			if (phba->hba_state == LPFC_HBA_READY) {
-				continue;
-			}
-		} else {
-			remote_ID = cmd->un.elsreq64.remoteID;
-		}
-
 		list_del(&piocb->list);
 		pring->txcmplq_cnt--;
 
@@ -3032,8 +3246,7 @@ lpfc_els_flush_cmd(struct lpfc_hba * phb
 			spin_unlock_irq(phba->host->host_lock);
 			(piocb->iocb_cmpl) (phba, piocb, piocb);
 			spin_lock_irq(phba->host->host_lock);
-		}
-		else
+		} else
 			lpfc_sli_release_iocbq(phba, piocb);
 	}
 	spin_unlock_irq(phba->host->host_lock);
@@ -3105,10 +3318,11 @@ lpfc_els_unsol_event(struct lpfc_hba * p
 	}
 
 	did = icmd->un.rcvels.remoteID;
-	if ((ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, did)) == 0) {
+	ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, did);
+	if (!ndlp) {
 		/* Cannot find existing Fabric ndlp, so allocate a new one */
-		if ((ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL))
-		    == 0) {
+		ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);
+		if (!ndlp) {
 			lpfc_mbuf_free(phba, mp->virt, mp->phys);
 			kfree(mp);
 			drop_cmd = 1;
@@ -3201,10 +3415,6 @@ lpfc_els_unsol_event(struct lpfc_hba * p
 		phba->fc_stat.elsRcvFAN++;
 		lpfc_els_rcv_fan(phba, elsiocb, ndlp);
 		break;
-	case ELS_CMD_RRQ:
-		phba->fc_stat.elsRcvRRQ++;
-		lpfc_els_rcv_rrq(phba, elsiocb, ndlp);
-		break;
 	case ELS_CMD_PRLI:
 		phba->fc_stat.elsRcvPRLI++;
 		if (phba->hba_state < LPFC_DISC_AUTH) {
@@ -3213,9 +3423,33 @@ lpfc_els_unsol_event(struct lpfc_hba * p
 		}
 		lpfc_disc_state_machine(phba, ndlp, elsiocb, NLP_EVT_RCV_PRLI);
 		break;
+	case ELS_CMD_LIRR:
+		phba->fc_stat.elsRcvLIRR++;
+		lpfc_els_rcv_lirr(phba, elsiocb, ndlp);
+		if (newnode) {
+			mempool_free( ndlp, phba->nlp_mem_pool);
+		}
+		break;
+	case ELS_CMD_RPS:
+		phba->fc_stat.elsRcvRPS++;
+		lpfc_els_rcv_rps(phba, elsiocb, ndlp);
+		if (newnode) {
+			mempool_free( ndlp, phba->nlp_mem_pool);
+		}
+		break;
+	case ELS_CMD_RPL:
+		phba->fc_stat.elsRcvRPL++;
+		lpfc_els_rcv_rpl(phba, elsiocb, ndlp);
+		if (newnode) {
+			mempool_free( ndlp, phba->nlp_mem_pool);
+		}
+		break;
 	case ELS_CMD_RNID:
 		phba->fc_stat.elsRcvRNID++;
 		lpfc_els_rcv_rnid(phba, elsiocb, ndlp);
+		if (newnode) {
+			mempool_free( ndlp, phba->nlp_mem_pool);
+		}
 		break;
 	default:
 		/* Unsupported ELS command, reject */
@@ -3249,8 +3483,9 @@ dropit:
 	if (drop_cmd == 1) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_ELS,
 				"%d:0111 Dropping received ELS cmd "
-				"Data: x%x x%x\n", phba->brd_no,
-				icmd->ulpStatus, icmd->un.ulpWord[4]);
+				"Data: x%x x%x x%x\n", phba->brd_no,
+				icmd->ulpStatus, icmd->un.ulpWord[4],
+				icmd->ulpTimeout);
 		phba->fc_stat.elsRcvDrop++;
 	}
 	return;
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc.h linux-2.6.15/drivers/scsi/lpfc/lpfc.h
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc.h	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc.h	2006-02-09 15:44:58.385220776 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -121,7 +121,9 @@ struct lpfc_stats {
 	uint32_t elsRcvLOGO;
 	uint32_t elsRcvPRLO;
 	uint32_t elsRcvPRLI;
-	uint32_t elsRcvRRQ;
+	uint32_t elsRcvLIRR;
+	uint32_t elsRcvRPS;
+	uint32_t elsRcvRPL;
 	uint32_t elsXmitFLOGI;
 	uint32_t elsXmitPLOGI;
 	uint32_t elsXmitPRLI;
@@ -167,32 +169,33 @@ struct lpfc_sysfs_mbox {
 };
 
 struct lpfc_hba {
-	struct list_head hba_list;	/* List of hbas/ports */
 	struct lpfc_sli sli;
 	struct lpfc_sli2_slim *slim2p;
 	dma_addr_t slim2p_mapping;
 	uint16_t pci_cfg_value;
 
 	struct semaphore hba_can_block;
-	uint32_t hba_state;
+	int32_t hba_state;
 
-#define LPFC_INIT_START           1	/* Initial state after board reset */
-#define LPFC_INIT_MBX_CMDS        2	/* Initialize HBA with mbox commands */
-#define LPFC_LINK_DOWN            3	/* HBA initialized, link is down */
-#define LPFC_LINK_UP              4	/* Link is up  - issue READ_LA */
-#define LPFC_LOCAL_CFG_LINK       5	/* local NPORT Id configured */
-#define LPFC_FLOGI                6	/* FLOGI sent to Fabric */
-#define LPFC_FABRIC_CFG_LINK      7	/* Fabric assigned NPORT Id
+#define LPFC_STATE_UNKNOWN        0    /* HBA state is unknown */
+#define LPFC_WARM_START           1    /* HBA state after selective reset */
+#define LPFC_INIT_START           2    /* Initial state after board reset */
+#define LPFC_INIT_MBX_CMDS        3    /* Initialize HBA with mbox commands */
+#define LPFC_LINK_DOWN            4    /* HBA initialized, link is down */
+#define LPFC_LINK_UP              5    /* Link is up  - issue READ_LA */
+#define LPFC_LOCAL_CFG_LINK       6    /* local NPORT Id configured */
+#define LPFC_FLOGI                7    /* FLOGI sent to Fabric */
+#define LPFC_FABRIC_CFG_LINK      8    /* Fabric assigned NPORT Id
 					   configured */
-#define LPFC_NS_REG               8	/* Register with NameServer */
-#define LPFC_NS_QRY               9	/* Query NameServer for NPort ID list */
-#define LPFC_BUILD_DISC_LIST      10	/* Build ADISC and PLOGI lists for
+#define LPFC_NS_REG               9	/* Register with NameServer */
+#define LPFC_NS_QRY               10	/* Query NameServer for NPort ID list */
+#define LPFC_BUILD_DISC_LIST      11	/* Build ADISC and PLOGI lists for
 					 * device authentication / discovery */
-#define LPFC_DISC_AUTH            11	/* Processing ADISC list */
-#define LPFC_CLEAR_LA             12	/* authentication cmplt - issue
+#define LPFC_DISC_AUTH            12	/* Processing ADISC list */
+#define LPFC_CLEAR_LA             13	/* authentication cmplt - issue
 					   CLEAR_LA */
 #define LPFC_HBA_READY            32
-#define LPFC_HBA_ERROR            0xff
+#define LPFC_HBA_ERROR            -1
 
 	uint8_t fc_linkspeed;	/* Link speed after last READ_LA */
 
@@ -245,6 +248,7 @@ struct lpfc_hba {
 #define FC_SCSI_SCAN_TMO        0x4000	/* scsi scan timer running */
 #define FC_ABORT_DISCOVERY      0x8000	/* we want to abort discovery */
 #define FC_NDISC_ACTIVE         0x10000	/* NPort discovery active */
+#define FC_BYPASSED_MODE        0x20000	/* NPort is in bypassed mode */
 
 	uint32_t fc_topology;	/* link topology, from LINK INIT */
 
@@ -290,7 +294,6 @@ struct lpfc_hba {
 	uint32_t cfg_cr_delay;
 	uint32_t cfg_cr_count;
 	uint32_t cfg_fdmi_on;
-	uint32_t cfg_fcp_bind_method;
 	uint32_t cfg_discovery_threads;
 	uint32_t cfg_max_luns;
 	uint32_t cfg_poll;
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_hbadisc.c linux-2.6.15/drivers/scsi/lpfc/lpfc_hbadisc.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_hbadisc.c	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_hbadisc.c	2006-02-09 15:44:58.417222701 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -108,7 +108,7 @@ lpfc_work_list_done(struct lpfc_hba * ph
 				 evt_listp);
 		spin_unlock_irq(phba->host->host_lock);
 		free_evt = 1;
-		switch(evtp->evt) {
+		switch (evtp->evt) {
 		case LPFC_EVT_NODEV_TMO:
 			ndlp = (struct lpfc_nodelist *)(evtp->evt_arg1);
 			lpfc_process_nodev_timeout(phba, ndlp);
@@ -120,11 +120,33 @@ lpfc_work_list_done(struct lpfc_hba * ph
 			free_evt = 0;
 			break;
 		case LPFC_EVT_ONLINE:
-			*(int *)(evtp->evt_arg1)  = lpfc_online(phba);
+			if (phba->hba_state < LPFC_LINK_DOWN)
+				*(int *)(evtp->evt_arg1)  = lpfc_online(phba);
+			else
+				*(int *)(evtp->evt_arg1)  = 0;
 			complete((struct completion *)(evtp->evt_arg2));
 			break;
 		case LPFC_EVT_OFFLINE:
-			*(int *)(evtp->evt_arg1)  = lpfc_offline(phba);
+			if (phba->hba_state >= LPFC_LINK_DOWN)
+				lpfc_offline(phba);
+			lpfc_sli_brdrestart(phba);
+			*(int *)(evtp->evt_arg1) =
+				lpfc_sli_brdready(phba,HS_FFRDY | HS_MBRDY);
+			complete((struct completion *)(evtp->evt_arg2));
+			break;
+		case LPFC_EVT_WARM_START:
+			if (phba->hba_state >= LPFC_LINK_DOWN)
+				lpfc_offline(phba);
+			lpfc_sli_brdreset(phba);
+			lpfc_hba_down_post(phba);
+			*(int *)(evtp->evt_arg1) =
+				lpfc_sli_brdready(phba, HS_MBRDY);
+			complete((struct completion *)(evtp->evt_arg2));
+			break;
+		case LPFC_EVT_KILL:
+			if (phba->hba_state >= LPFC_LINK_DOWN)
+				lpfc_offline(phba);
+			*(int *)(evtp->evt_arg1)  = lpfc_sli_brdkill(phba);
 			complete((struct completion *)(evtp->evt_arg2));
 			break;
 		}
@@ -151,13 +173,13 @@ lpfc_work_done(struct lpfc_hba * phba)
 	work_hba_events=phba->work_hba_events;
 	spin_unlock_irq(phba->host->host_lock);
 
-	if(ha_copy & HA_ERATT)
+	if (ha_copy & HA_ERATT)
 		lpfc_handle_eratt(phba);
 
-	if(ha_copy & HA_MBATT)
+	if (ha_copy & HA_MBATT)
 		lpfc_sli_handle_mb_event(phba);
 
-	if(ha_copy & HA_LATT)
+	if (ha_copy & HA_LATT)
 		lpfc_handle_latt(phba);
 
 	if (work_hba_events & WORKER_DISC_TMO)
@@ -283,16 +305,20 @@ lpfc_linkdown(struct lpfc_hba * phba)
 {
 	struct lpfc_sli       *psli;
 	struct lpfc_nodelist  *ndlp, *next_ndlp;
-	struct list_head *listp;
-	struct list_head *node_list[7];
+	struct list_head *listp, *node_list[7];
 	LPFC_MBOXQ_t     *mb;
 	int               rc, i;
 
 	psli = &phba->sli;
+	/* sysfs or selective reset may call this routine to clean up */
+	if (phba->hba_state >= LPFC_LINK_DOWN) {
+		if (phba->hba_state == LPFC_LINK_DOWN)
+			return 0;
 
-	spin_lock_irq(phba->host->host_lock);
-	phba->hba_state = LPFC_LINK_DOWN;
-	spin_unlock_irq(phba->host->host_lock);
+		spin_lock_irq(phba->host->host_lock);
+		phba->hba_state = LPFC_LINK_DOWN;
+		spin_unlock_irq(phba->host->host_lock);
+	}
 
 	/* Clean up any firmware default rpi's */
 	if ((mb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL))) {
@@ -324,32 +350,19 @@ lpfc_linkdown(struct lpfc_hba * phba)
 			continue;
 
 		list_for_each_entry_safe(ndlp, next_ndlp, listp, nlp_listp) {
-			/* Fabric nodes are not handled thru state machine for
-			   link down */
-			if (ndlp->nlp_type & NLP_FABRIC) {
-				/* Remove ALL Fabric nodes except Fabric_DID */
-				if (ndlp->nlp_DID != Fabric_DID) {
-					/* Take it off current list and free */
-					lpfc_nlp_list(phba, ndlp,
-						NLP_NO_LIST);
-				}
-			}
-			else {
 
-				rc = lpfc_disc_state_machine(phba, ndlp, NULL,
-						     NLP_EVT_DEVICE_RECOVERY);
+			rc = lpfc_disc_state_machine(phba, ndlp, NULL,
+					     NLP_EVT_DEVICE_RECOVERY);
 
-				/* Check config parameter use-adisc or FCP-2 */
-				if ((rc != NLP_STE_FREED_NODE) &&
-					(phba->cfg_use_adisc == 0) &&
-					!(ndlp->nlp_fcp_info &
-						NLP_FCP_2_DEVICE)) {
-					/* We know we will have to relogin, so
-					 * unreglogin the rpi right now to fail
-					 * any outstanding I/Os quickly.
-					 */
-					lpfc_unreg_rpi(phba, ndlp);
-				}
+			/* Check config parameter use-adisc or FCP-2 */
+			if ((rc != NLP_STE_FREED_NODE) &&
+				(phba->cfg_use_adisc == 0) &&
+				!(ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE)) {
+				/* We know we will have to relogin, so
+				 * unreglogin the rpi right now to fail
+				 * any outstanding I/Os quickly.
+				 */
+				lpfc_unreg_rpi(phba, ndlp);
 			}
 		}
 	}
@@ -384,13 +397,15 @@ lpfc_linkdown(struct lpfc_hba * phba)
 	lpfc_can_disctmo(phba);
 
 	/* Must process IOCBs on all rings to handle ABORTed I/Os */
-	return (0);
+	return 0;
 }
 
 static int
 lpfc_linkup(struct lpfc_hba * phba)
 {
 	struct lpfc_nodelist *ndlp, *next_ndlp;
+	struct list_head *listp, *node_list[7];
+	int i;
 
 	spin_lock_irq(phba->host->host_lock);
 	phba->hba_state = LPFC_LINK_UP;
@@ -401,14 +416,33 @@ lpfc_linkup(struct lpfc_hba * phba)
 	spin_unlock_irq(phba->host->host_lock);
 
 
-	/*
-	 * Clean up old Fabric NLP_FABRIC logins.
-	 */
-	list_for_each_entry_safe(ndlp, next_ndlp, &phba->fc_nlpunmap_list,
-				nlp_listp) {
-		if (ndlp->nlp_DID == Fabric_DID) {
-			/* Take it off current list and free */
-			lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
+	node_list[0] = &phba->fc_plogi_list;
+	node_list[1] = &phba->fc_adisc_list;
+	node_list[2] = &phba->fc_reglogin_list;
+	node_list[3] = &phba->fc_prli_list;
+	node_list[4] = &phba->fc_nlpunmap_list;
+	node_list[5] = &phba->fc_nlpmap_list;
+	node_list[6] = &phba->fc_npr_list;
+	for (i = 0; i < 7; i++) {
+		listp = node_list[i];
+		if (list_empty(listp))
+			continue;
+
+		list_for_each_entry_safe(ndlp, next_ndlp, listp, nlp_listp) {
+			if (phba->fc_flag & FC_LBIT) {
+				if (ndlp->nlp_type & NLP_FABRIC) {
+					/* On Linkup its safe to clean up the
+					 * ndlp from Fabric connections.
+					 */
+					lpfc_nlp_list(phba, ndlp,
+							NLP_UNUSED_LIST);
+				} else if (!(ndlp->nlp_flag & NLP_NPR_ADISC)) {
+					/* Fail outstanding IO now since device
+					 * is marked for PLOGI.
+					 */
+					lpfc_unreg_rpi(phba, ndlp);
+				}
+			}
 		}
 	}
 
@@ -462,7 +496,7 @@ lpfc_mbx_cmpl_clear_la(struct lpfc_hba *
 		lpfc_els_disc_plogi(phba);
 	}
 
-	if(!phba->num_disc_nodes) {
+	if (!phba->num_disc_nodes) {
 		spin_lock_irq(phba->host->host_lock);
 		phba->fc_flag &= ~FC_NDISC_ACTIVE;
 		spin_unlock_irq(phba->host->host_lock);
@@ -504,80 +538,59 @@ out:
 }
 
 static void
-lpfc_mbx_cmpl_config_link(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)
+lpfc_mbx_cmpl_local_config_link(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)
 {
-	struct lpfc_sli *psli;
-	MAILBOX_t *mb;
-
-	psli = &phba->sli;
-	mb = &pmb->mb;
-	/* Check for error */
-	if (mb->mbxStatus) {
-		/* CONFIG_LINK mbox error <mbxStatus> state <hba_state> */
-		lpfc_printf_log(phba, KERN_ERR, LOG_MBOX,
-				"%d:0306 CONFIG_LINK mbxStatus error x%x "
-				"HBA state x%x\n",
-				phba->brd_no, mb->mbxStatus, phba->hba_state);
+	struct lpfc_sli *psli = &phba->sli;
+	int rc;
 
-		lpfc_linkdown(phba);
-		phba->hba_state = LPFC_HBA_ERROR;
+	if (pmb->mb.mbxStatus)
 		goto out;
-	}
 
-	if (phba->hba_state == LPFC_LOCAL_CFG_LINK) {
-		if (phba->fc_topology == TOPOLOGY_LOOP) {
-			/* If we are public loop and L bit was set */
-			if ((phba->fc_flag & FC_PUBLIC_LOOP) &&
-			    !(phba->fc_flag & FC_LBIT)) {
-				/* Need to wait for FAN - use discovery timer
-				 * for timeout.  hba_state is identically
-				 * LPFC_LOCAL_CFG_LINK while waiting for FAN
-				 */
-				lpfc_set_disctmo(phba);
-				mempool_free( pmb, phba->mbox_mem_pool);
-				return;
-			}
+	mempool_free(pmb, phba->mbox_mem_pool);
+
+	if (phba->fc_topology == TOPOLOGY_LOOP &&
+		phba->fc_flag & FC_PUBLIC_LOOP &&
+		 !(phba->fc_flag & FC_LBIT)) {
+			/* Need to wait for FAN - use discovery timer
+			 * for timeout.  hba_state is identically
+			 * LPFC_LOCAL_CFG_LINK while waiting for FAN
+			 */
+			lpfc_set_disctmo(phba);
+			return;
 		}
 
-		/* Start discovery by sending a FLOGI hba_state is identically
-		 * LPFC_FLOGI while waiting for FLOGI cmpl
-		 */
-		phba->hba_state = LPFC_FLOGI;
-		lpfc_set_disctmo(phba);
-		lpfc_initial_flogi(phba);
-		mempool_free( pmb, phba->mbox_mem_pool);
-		return;
-	}
-	if (phba->hba_state == LPFC_FABRIC_CFG_LINK) {
-		mempool_free( pmb, phba->mbox_mem_pool);
-		return;
-	}
+	/* Start discovery by sending a FLOGI. hba_state is identically
+	 * LPFC_FLOGI while waiting for FLOGI cmpl
+	 */
+	phba->hba_state = LPFC_FLOGI;
+	lpfc_set_disctmo(phba);
+	lpfc_initial_flogi(phba);
+	return;
 
 out:
-	/* CONFIG_LINK bad hba state <hba_state> */
-	lpfc_printf_log(phba,
-			KERN_ERR,
-			LOG_DISCOVERY,
+	lpfc_printf_log(phba, KERN_ERR, LOG_MBOX,
+			"%d:0306 CONFIG_LINK mbxStatus error x%x "
+			"HBA state x%x\n",
+			phba->brd_no, pmb->mb.mbxStatus, phba->hba_state);
+
+	lpfc_linkdown(phba);
+
+	phba->hba_state = LPFC_HBA_ERROR;
+
+	lpfc_printf_log(phba, KERN_ERR, LOG_DISCOVERY,
 			"%d:0200 CONFIG_LINK bad hba state x%x\n",
 			phba->brd_no, phba->hba_state);
 
-	if (phba->hba_state != LPFC_CLEAR_LA) {
-		lpfc_clear_la(phba, pmb);
-		pmb->mbox_cmpl = lpfc_mbx_cmpl_clear_la;
-		if (lpfc_sli_issue_mbox(phba, pmb, (MBX_NOWAIT | MBX_STOP_IOCB))
-		    == MBX_NOT_FINISHED) {
-			mempool_free( pmb, phba->mbox_mem_pool);
-			lpfc_disc_flush_list(phba);
-			psli->ring[(psli->ip_ring)].flag &=
-				~LPFC_STOP_IOCB_EVENT;
-			psli->ring[(psli->fcp_ring)].flag &=
-				~LPFC_STOP_IOCB_EVENT;
-			psli->ring[(psli->next_ring)].flag &=
-				~LPFC_STOP_IOCB_EVENT;
-			phba->hba_state = LPFC_HBA_READY;
-		}
-	} else {
-		mempool_free( pmb, phba->mbox_mem_pool);
+	lpfc_clear_la(phba, pmb);
+	pmb->mbox_cmpl = lpfc_mbx_cmpl_clear_la;
+	rc = lpfc_sli_issue_mbox(phba, pmb, (MBX_NOWAIT | MBX_STOP_IOCB));
+	if (rc == MBX_NOT_FINISHED) {
+		mempool_free(pmb, phba->mbox_mem_pool);
+		lpfc_disc_flush_list(phba);
+		psli->ring[(psli->ip_ring)].flag &= ~LPFC_STOP_IOCB_EVENT;
+		psli->ring[(psli->fcp_ring)].flag &= ~LPFC_STOP_IOCB_EVENT;
+		psli->ring[(psli->next_ring)].flag &= ~LPFC_STOP_IOCB_EVENT;
+		phba->hba_state = LPFC_HBA_READY;
 	}
 	return;
 }
@@ -650,7 +663,7 @@ lpfc_mbx_process_link_up(struct lpfc_hba
 	cfglink_mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
 
 	spin_lock_irq(phba->host->host_lock);
-	switch(la->UlnkSpeed) {
+	switch (la->UlnkSpeed) {
 		case LA_1GHZ_LINK:
 			phba->fc_linkspeed = LA_1GHZ_LINK;
 			break;
@@ -731,7 +744,7 @@ lpfc_mbx_process_link_up(struct lpfc_hba
 	if (cfglink_mbox) {
 		phba->hba_state = LPFC_LOCAL_CFG_LINK;
 		lpfc_config_link(phba, cfglink_mbox);
-		cfglink_mbox->mbox_cmpl = lpfc_mbx_cmpl_config_link;
+		cfglink_mbox->mbox_cmpl = lpfc_mbx_cmpl_local_config_link;
 		lpfc_sli_issue_mbox(phba, cfglink_mbox,
 						(MBX_NOWAIT | MBX_STOP_IOCB));
 	}
@@ -784,6 +797,13 @@ lpfc_mbx_cmpl_read_la(struct lpfc_hba * 
 
 	memcpy(&phba->alpa_map[0], mp->virt, 128);
 
+	spin_lock_irq(phba->host->host_lock);
+	if (la->pb)
+		phba->fc_flag |= FC_BYPASSED_MODE;
+	else
+		phba->fc_flag &= ~FC_BYPASSED_MODE;
+	spin_unlock_irq(phba->host->host_lock);
+
 	if (((phba->fc_eventTag + 1) < la->eventTag) ||
 	     (phba->fc_eventTag == la->eventTag)) {
 		phba->fc_stat.LinkMultiEvent++;
@@ -904,32 +924,36 @@ lpfc_mbx_cmpl_fabric_reg_login(struct lp
 		 */
 		lpfc_issue_els_scr(phba, SCR_DID, 0);
 
-		/* Allocate a new node instance.  If the pool is empty, just
-		 * start the discovery process and skip the Nameserver login
-		 * process.  This is attempted again later on.  Otherwise, issue
-		 * a Port Login (PLOGI) to the NameServer
-		 */
-		if ((ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL))
-		    == 0) {
-			lpfc_disc_start(phba);
-		} else {
-			lpfc_nlp_init(phba, ndlp, NameServer_DID);
-			ndlp->nlp_type |= NLP_FABRIC;
-			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
-			lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
-			lpfc_issue_els_plogi(phba, ndlp, 0);
-			if (phba->cfg_fdmi_on) {
-				if ((ndlp_fdmi = mempool_alloc(
-						       phba->nlp_mem_pool,
-						       GFP_KERNEL))) {
-					lpfc_nlp_init(phba, ndlp_fdmi,
-						FDMI_DID);
-					ndlp_fdmi->nlp_type |= NLP_FABRIC;
-					ndlp_fdmi->nlp_state =
-					    NLP_STE_PLOGI_ISSUE;
-					lpfc_issue_els_plogi(phba, ndlp_fdmi,
-							     0);
-				}
+		ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, NameServer_DID);
+		if (!ndlp) {
+			/* Allocate a new node instance. If the pool is empty,
+			 * start the discovery process and skip the Nameserver
+			 * login process.  This is attempted again later on.
+			 * Otherwise, issue a Port Login (PLOGI) to NameServer.
+			 */
+			ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_ATOMIC);
+			if (!ndlp) {
+				lpfc_disc_start(phba);
+				lpfc_mbuf_free(phba, mp->virt, mp->phys);
+				kfree(mp);
+				mempool_free( pmb, phba->mbox_mem_pool);
+				return;
+			} else {
+				lpfc_nlp_init(phba, ndlp, NameServer_DID);
+				ndlp->nlp_type |= NLP_FABRIC;
+			}
+		}
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
+		lpfc_issue_els_plogi(phba, ndlp, 0);
+		if (phba->cfg_fdmi_on) {
+			ndlp_fdmi = mempool_alloc(phba->nlp_mem_pool,
+								GFP_KERNEL);
+			if (ndlp_fdmi) {
+				lpfc_nlp_init(phba, ndlp_fdmi, FDMI_DID);
+				ndlp_fdmi->nlp_type |= NLP_FABRIC;
+				ndlp_fdmi->nlp_state = NLP_STE_PLOGI_ISSUE;
+				lpfc_issue_els_plogi(phba, ndlp_fdmi, 0);
 			}
 		}
 	}
@@ -937,7 +961,6 @@ lpfc_mbx_cmpl_fabric_reg_login(struct lp
 	lpfc_mbuf_free(phba, mp->virt, mp->phys);
 	kfree(mp);
 	mempool_free( pmb, phba->mbox_mem_pool);
-
 	return;
 }
 
@@ -1070,12 +1093,11 @@ lpfc_nlp_list(struct lpfc_hba * phba, st
 
 	psli = &phba->sli;
 	/* Sanity check to ensure we are not moving to / from the same list */
-	if ((nlp->nlp_flag & NLP_LIST_MASK) == list) {
+	if ((nlp->nlp_flag & NLP_LIST_MASK) == list)
 		if (list != NLP_NO_LIST)
-			return(0);
-	}
+			return 0;
 
-	switch(nlp->nlp_flag & NLP_LIST_MASK) {
+	switch (nlp->nlp_flag & NLP_LIST_MASK) {
 	case NLP_NO_LIST: /* Not on any list */
 		break;
 	case NLP_UNUSED_LIST:
@@ -1125,6 +1147,7 @@ lpfc_nlp_list(struct lpfc_hba * phba, st
 			spin_lock_irq(phba->host->host_lock);
 			nlp->nlp_flag &= ~NLP_DELAY_TMO;
 			spin_unlock_irq(phba->host->host_lock);
+			nlp->nlp_last_elscmd = 0;
 			del_timer_sync(&nlp->nlp_delayfunc);
 			if (!list_empty(&nlp->els_retry_evt.evt_listp))
 				list_del_init(&nlp->els_retry_evt.evt_listp);
@@ -1144,7 +1167,7 @@ lpfc_nlp_list(struct lpfc_hba * phba, st
 			phba->brd_no,
 			nlp->nlp_DID, list, nlp->nlp_flag);
 
-	switch(list) {
+	switch (list) {
 	case NLP_NO_LIST: /* No list, just remove it */
 		lpfc_nlp_remove(phba, nlp);
 		/* as node removed - stop further transport calls */
@@ -1241,17 +1264,10 @@ lpfc_nlp_list(struct lpfc_hba * phba, st
 		list_add_tail(&nlp->nlp_listp, &phba->fc_npr_list);
 		phba->fc_npr_cnt++;
 
-		/*
-		 * Sanity check for Fabric entity.
-		 * Set nodev_tmo for NPR state, for Fabric use 1 sec.
-		 */
-		if (nlp->nlp_type & NLP_FABRIC) {
-			mod_timer(&nlp->nlp_tmofunc, jiffies + HZ);
-		}
-		else {
+		if (!(nlp->nlp_flag & NLP_NODEV_TMO))
 			mod_timer(&nlp->nlp_tmofunc,
-			    jiffies + HZ * phba->cfg_nodev_tmo);
-		}
+		 			jiffies + HZ * phba->cfg_nodev_tmo);
+
 		spin_lock_irq(phba->host->host_lock);
 		nlp->nlp_flag |= NLP_NODEV_TMO;
 		nlp->nlp_flag &= ~NLP_RCV_PLOGI;
@@ -1303,7 +1319,7 @@ lpfc_nlp_list(struct lpfc_hba * phba, st
 			}
 		}
 	}
-	return (0);
+	return 0;
 }
 
 /*
@@ -1314,7 +1330,15 @@ lpfc_set_disctmo(struct lpfc_hba * phba)
 {
 	uint32_t tmo;
 
-	tmo = ((phba->fc_ratov * 2) + 1);
+	if (phba->hba_state == LPFC_LOCAL_CFG_LINK) {
+		/* For FAN, timeout should be greater then edtov */
+		tmo = (((phba->fc_edtov + 999) / 1000) + 1);
+	} else {
+		/* Normal discovery timeout should be > then ELS/CT timeout
+		 * FC spec states we need 3 * ratov for CT requests
+		 */
+		tmo = ((phba->fc_ratov * 3) + 3);
+	}
 
 	mod_timer(&phba->fc_disctmo, jiffies + HZ * tmo);
 	spin_lock_irq(phba->host->host_lock);
@@ -1354,7 +1378,7 @@ lpfc_can_disctmo(struct lpfc_hba * phba)
 			phba->brd_no, phba->hba_state, phba->fc_flag,
 			phba->fc_plogi_cnt, phba->fc_adisc_cnt);
 
-	return (0);
+	return 0;
 }
 
 /*
@@ -1375,11 +1399,11 @@ lpfc_check_sli_ndlp(struct lpfc_hba * ph
 		switch (icmd->ulpCommand) {
 		case CMD_GEN_REQUEST64_CR:
 			if (icmd->ulpContext == (volatile ushort)ndlp->nlp_rpi)
-				return (1);
+				return 1;
 		case CMD_ELS_REQUEST64_CR:
 		case CMD_XMIT_ELS_RSP64_CX:
 			if (iocb->context1 == (uint8_t *) ndlp)
-				return (1);
+				return 1;
 		}
 	} else if (pring->ringno == psli->ip_ring) {
 
@@ -1387,15 +1411,15 @@ lpfc_check_sli_ndlp(struct lpfc_hba * ph
 		/* Skip match check if waiting to relogin to FCP target */
 		if ((ndlp->nlp_type & NLP_FCP_TARGET) &&
 		  (ndlp->nlp_flag & NLP_DELAY_TMO)) {
-			return (0);
+			return 0;
 		}
 		if (icmd->ulpContext == (volatile ushort)ndlp->nlp_rpi) {
-			return (1);
+			return 1;
 		}
 	} else if (pring->ringno == psli->next_ring) {
 
 	}
-	return (0);
+	return 0;
 }
 
 /*
@@ -1456,7 +1480,7 @@ lpfc_no_rpi(struct lpfc_hba * phba, stru
 
 		}
 	}
-	return (0);
+	return 0;
 }
 
 /*
@@ -1547,6 +1571,7 @@ lpfc_freenode(struct lpfc_hba * phba, st
 	spin_unlock_irq(phba->host->host_lock);
 	del_timer_sync(&ndlp->nlp_tmofunc);
 
+	ndlp->nlp_last_elscmd = 0;
 	del_timer_sync(&ndlp->nlp_delayfunc);
 
 	if (!list_empty(&ndlp->nodev_timeout_evt.evt_listp))
@@ -1556,7 +1581,7 @@ lpfc_freenode(struct lpfc_hba * phba, st
 
 	lpfc_unreg_rpi(phba, ndlp);
 
-	return (0);
+	return 0;
 }
 
 /*
@@ -1582,6 +1607,7 @@ lpfc_nlp_remove(struct lpfc_hba * phba, 
 		spin_lock_irq(phba->host->host_lock);
 		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
 		spin_unlock_irq(phba->host->host_lock);
+		ndlp->nlp_last_elscmd = 0;
 		del_timer_sync(&ndlp->nlp_delayfunc);
 		if (!list_empty(&ndlp->els_retry_evt.evt_listp))
 			list_del_init(&ndlp->els_retry_evt.evt_listp);
@@ -1591,12 +1617,11 @@ lpfc_nlp_remove(struct lpfc_hba * phba, 
 		spin_lock_irq(phba->host->host_lock);
 		ndlp->nlp_flag |= NLP_DELAY_REMOVE;
 		spin_unlock_irq(phba->host->host_lock);
-	}
-	else {
+	} else {
 		lpfc_freenode(phba, ndlp);
 		mempool_free( ndlp, phba->nlp_mem_pool);
 	}
-	return(0);
+	return 0;
 }
 
 static int
@@ -1607,20 +1632,20 @@ lpfc_matchdid(struct lpfc_hba * phba, st
 	D_ID matchdid;
 
 	if (did == Bcast_DID)
-		return (0);
+		return 0;
 
 	if (ndlp->nlp_DID == 0) {
-		return (0);
+		return 0;
 	}
 
 	/* First check for Direct match */
 	if (ndlp->nlp_DID == did)
-		return (1);
+		return 1;
 
 	/* Next check for area/domain identically equals 0 match */
 	mydid.un.word = phba->fc_myDID;
 	if ((mydid.un.b.domain == 0) && (mydid.un.b.area == 0)) {
-		return (0);
+		return 0;
 	}
 
 	matchdid.un.word = did;
@@ -1631,9 +1656,9 @@ lpfc_matchdid(struct lpfc_hba * phba, st
 			if ((ndlpdid.un.b.domain == 0) &&
 			    (ndlpdid.un.b.area == 0)) {
 				if (ndlpdid.un.b.id)
-					return (1);
+					return 1;
 			}
-			return (0);
+			return 0;
 		}
 
 		matchdid.un.word = ndlp->nlp_DID;
@@ -1642,11 +1667,11 @@ lpfc_matchdid(struct lpfc_hba * phba, st
 			if ((matchdid.un.b.domain == 0) &&
 			    (matchdid.un.b.area == 0)) {
 				if (matchdid.un.b.id)
-					return (1);
+					return 1;
 			}
 		}
 	}
-	return (0);
+	return 0;
 }
 
 /* Search for a nodelist entry on a specific list */
@@ -1671,7 +1696,7 @@ lpfc_findnode_did(struct lpfc_hba * phba
 						phba->brd_no,
 						ndlp, ndlp->nlp_DID,
 						ndlp->nlp_flag, data1);
-				return (ndlp);
+				return ndlp;
 			}
 		}
 	}
@@ -1692,7 +1717,7 @@ lpfc_findnode_did(struct lpfc_hba * phba
 						phba->brd_no,
 						ndlp, ndlp->nlp_DID,
 						ndlp->nlp_flag, data1);
-				return (ndlp);
+				return ndlp;
 			}
 		}
 	}
@@ -1714,7 +1739,7 @@ lpfc_findnode_did(struct lpfc_hba * phba
 						phba->brd_no,
 						ndlp, ndlp->nlp_DID,
 						ndlp->nlp_flag, data1);
-				return (ndlp);
+				return ndlp;
 			}
 		}
 	}
@@ -1736,7 +1761,7 @@ lpfc_findnode_did(struct lpfc_hba * phba
 						phba->brd_no,
 						ndlp, ndlp->nlp_DID,
 						ndlp->nlp_flag, data1);
-				return (ndlp);
+				return ndlp;
 			}
 		}
 	}
@@ -1758,7 +1783,7 @@ lpfc_findnode_did(struct lpfc_hba * phba
 						phba->brd_no,
 						ndlp, ndlp->nlp_DID,
 						ndlp->nlp_flag, data1);
-				return (ndlp);
+				return ndlp;
 			}
 		}
 	}
@@ -1780,7 +1805,7 @@ lpfc_findnode_did(struct lpfc_hba * phba
 						phba->brd_no,
 						ndlp, ndlp->nlp_DID,
 						ndlp->nlp_flag, data1);
-				return (ndlp);
+				return ndlp;
 			}
 		}
 	}
@@ -1802,7 +1827,7 @@ lpfc_findnode_did(struct lpfc_hba * phba
 						phba->brd_no,
 						ndlp, ndlp->nlp_DID,
 						ndlp->nlp_flag, data1);
-				return (ndlp);
+				return ndlp;
 			}
 		}
 	}
@@ -1824,7 +1849,7 @@ lpfc_findnode_did(struct lpfc_hba * phba
 						phba->brd_no,
 						ndlp, ndlp->nlp_DID,
 						ndlp->nlp_flag, data1);
-				return (ndlp);
+				return ndlp;
 			}
 		}
 	}
@@ -1846,8 +1871,9 @@ lpfc_setup_disc_node(struct lpfc_hba * p
 	struct lpfc_nodelist *ndlp;
 	uint32_t flg;
 
-	if ((ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, did)) == 0) {
-		if ((phba->hba_state == LPFC_HBA_READY) &&
+	ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, did);
+	if (!ndlp) {
+		if ((phba->fc_flag & FC_RSCN_MODE) &&
 		   ((lpfc_rscn_payload_check(phba, did) == 0)))
 			return NULL;
 		ndlp = (struct lpfc_nodelist *)
@@ -1860,22 +1886,31 @@ lpfc_setup_disc_node(struct lpfc_hba * p
 		ndlp->nlp_flag |= NLP_NPR_2B_DISC;
 		return ndlp;
 	}
-	if ((phba->hba_state == LPFC_HBA_READY) &&
-	    (phba->fc_flag & FC_RSCN_MODE)) {
+	if (phba->fc_flag & FC_RSCN_MODE) {
 		if (lpfc_rscn_payload_check(phba, did)) {
 			ndlp->nlp_flag |= NLP_NPR_2B_DISC;
-		}
-		else {
+
+			/* Since this node is marked for discovery,
+			 * delay timeout is not needed.
+			 */
+			if (ndlp->nlp_flag & NLP_DELAY_TMO) {
+				ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+				spin_unlock_irq(phba->host->host_lock);
+				del_timer_sync(&ndlp->nlp_delayfunc);
+				spin_lock_irq(phba->host->host_lock);
+				if (!list_empty(&ndlp->els_retry_evt.
+								evt_listp))
+					list_del_init(&ndlp->els_retry_evt.
+						      		evt_listp);
+			}
+		} else {
 			ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
 			ndlp = NULL;
 		}
-	}
-	else {
+	} else {
 		flg = ndlp->nlp_flag & NLP_LIST_MASK;
-		if ((flg == NLP_ADISC_LIST) ||
-		(flg == NLP_PLOGI_LIST)) {
+		if ((flg == NLP_ADISC_LIST) || (flg == NLP_PLOGI_LIST))
 			return NULL;
-		}
 		ndlp->nlp_state = NLP_STE_NPR_NODE;
 		lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 		ndlp->nlp_flag |= NLP_NPR_2B_DISC;
@@ -2023,8 +2058,7 @@ lpfc_disc_start(struct lpfc_hba * phba)
 				spin_lock_irq(phba->host->host_lock);
 				phba->fc_flag &= ~FC_RSCN_MODE;
 				spin_unlock_irq(phba->host->host_lock);
-			}
-			else
+			} else
 				lpfc_els_handle_rscn(phba);
 		}
 	}
@@ -2174,7 +2208,7 @@ static void
 lpfc_disc_timeout_handler(struct lpfc_hba *phba)
 {
 	struct lpfc_sli *psli;
-	struct lpfc_nodelist *ndlp;
+	struct lpfc_nodelist *ndlp, *next_ndlp;
 	LPFC_MBOXQ_t *clearlambox, *initlinkmbox;
 	int rc, clrlaerr = 0;
 
@@ -2201,10 +2235,19 @@ lpfc_disc_timeout_handler(struct lpfc_hb
 				 "%d:0221 FAN timeout\n",
 				 phba->brd_no);
 
-		/* Forget about FAN, Start discovery by sending a FLOGI
-		 * hba_state is identically LPFC_FLOGI while waiting for FLOGI
-		 * cmpl
-		 */
+		/* Start discovery by sending FLOGI, clean up old rpis */
+		list_for_each_entry_safe(ndlp, next_ndlp, &phba->fc_npr_list,
+					nlp_listp) {
+			if (ndlp->nlp_type & NLP_FABRIC) {
+				/* Clean up the ndlp on Fabric connections */
+				lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
+			} else if (!(ndlp->nlp_flag & NLP_NPR_ADISC)) {
+				/* Fail outstanding IO now since device
+				 * is marked for PLOGI.
+				 */
+				lpfc_unreg_rpi(phba, ndlp);
+			}
+		}
 		phba->hba_state = LPFC_FLOGI;
 		lpfc_set_disctmo(phba);
 		lpfc_initial_flogi(phba);
@@ -2473,7 +2516,7 @@ lpfc_findnode_rpi(struct lpfc_hba * phba
 	for (i = 0; i < ARRAY_SIZE(lists); i++ )
 		list_for_each_entry(ndlp, lists[i], nlp_listp)
 			if (ndlp->nlp_rpi == rpi)
-				return (ndlp);
+				return ndlp;
 
 	return NULL;
 }
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_hw.h linux-2.6.15/drivers/scsi/lpfc/lpfc_hw.h
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_hw.h	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_hw.h	2006-02-09 15:44:58.385220776 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -454,10 +454,13 @@ struct serv_parm {	/* Structure is in Bi
 #define ELS_CMD_ADISC     0x52000000
 #define ELS_CMD_FARP      0x54000000
 #define ELS_CMD_FARPR     0x55000000
+#define ELS_CMD_RPS       0x56000000
+#define ELS_CMD_RPL       0x57000000
 #define ELS_CMD_FAN       0x60000000
 #define ELS_CMD_RSCN      0x61040000
 #define ELS_CMD_SCR       0x62000000
 #define ELS_CMD_RNID      0x78000000
+#define ELS_CMD_LIRR      0x7A000000
 #else	/*  __LITTLE_ENDIAN_BITFIELD */
 #define ELS_CMD_MASK      0xffff
 #define ELS_RSP_MASK      0xff
@@ -486,10 +489,13 @@ struct serv_parm {	/* Structure is in Bi
 #define ELS_CMD_ADISC     0x52
 #define ELS_CMD_FARP      0x54
 #define ELS_CMD_FARPR     0x55
+#define ELS_CMD_RPS       0x56
+#define ELS_CMD_RPL       0x57
 #define ELS_CMD_FAN       0x60
 #define ELS_CMD_RSCN      0x0461
 #define ELS_CMD_SCR       0x62
 #define ELS_CMD_RNID      0x78
+#define ELS_CMD_LIRR      0x7A
 #endif
 
 /*
@@ -758,12 +764,40 @@ typedef struct _RNID {		/* Structure is 
 	} un;
 } RNID;
 
-typedef struct _RRQ {		/* Structure is in Big Endian format */
-	uint32_t SID;
-	uint16_t Oxid;
-	uint16_t Rxid;
-	uint8_t resv[32];	/* optional association hdr */
-} RRQ;
+typedef struct  _RPS {  	/* Structure is in Big Endian format */
+	union {
+		uint32_t portNum;
+		struct lpfc_name portName;
+	} un;
+} RPS;
+
+typedef struct  _RPS_RSP {	/* Structure is in Big Endian format */
+	uint16_t rsvd1;
+	uint16_t portStatus;
+	uint32_t linkFailureCnt;
+	uint32_t lossSyncCnt;
+	uint32_t lossSignalCnt;
+	uint32_t primSeqErrCnt;
+	uint32_t invalidXmitWord;
+	uint32_t crcCnt;
+} RPS_RSP;
+
+typedef struct  _RPL {  	/* Structure is in Big Endian format */
+	uint32_t maxsize;
+	uint32_t index;
+} RPL;
+
+typedef struct  _PORT_NUM_BLK {
+	uint32_t portNum;
+	uint32_t portID;
+	struct lpfc_name portName;
+} PORT_NUM_BLK;
+
+typedef struct  _RPL_RSP { 	/* Structure is in Big Endian format */
+	uint32_t listLen;
+	uint32_t index;
+	PORT_NUM_BLK port_num_blk;
+} RPL_RSP;
 
 /* This is used for RSCN command */
 typedef struct _D_ID {		/* Structure is in Big Endian format */
@@ -804,7 +838,6 @@ typedef struct _ELS_PKT {	/* Structure i
 		FARP farp;	/* Payload for FARP/ACC */
 		FAN fan;	/* Payload for FAN */
 		SCR scr;	/* Payload for SCR/ACC */
-		RRQ rrq;	/* Payload for RRQ */
 		RNID rnid;	/* Payload for RNID */
 		uint8_t pad[128 - 4];	/* Pad out to payload of 128 bytes */
 	} un;
@@ -1200,7 +1233,9 @@ typedef struct {		/* FireFly BIU registe
 #define MBX_SET_MASK        0x20
 #define MBX_SET_SLIM        0x21
 #define MBX_UNREG_D_ID      0x23
+#define MBX_KILL_BOARD      0x24
 #define MBX_CONFIG_FARP     0x25
+#define MBX_BEACON          0x2A
 
 #define MBX_LOAD_AREA       0x81
 #define MBX_RUN_BIU_DIAG64  0x84
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_init.c linux-2.6.15/drivers/scsi/lpfc/lpfc_init.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_init.c	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_init.c	2006-02-09 15:44:58.381220535 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -459,11 +459,47 @@ lpfc_hba_down_prep(struct lpfc_hba * phb
 	lpfc_els_flush_cmd(phba);
 	lpfc_disc_flush_list(phba);
 
+	/* Disable SLI2 since we disabled interrupts */
+	phba->sli.sli_flag &= ~LPFC_SLI2_ACTIVE;
 	return (0);
 }
 
 /************************************************************************/
 /*                                                                      */
+/*    lpfc_hba_down_post                                                */
+/*    This routine will do uninitialization after the HBA is reset      */
+/*    when bringing down the SLI Layer.                                 */
+/*    This routine returns 0 on success. Any other return value         */
+/*    indicates an error.                                               */
+/*                                                                      */
+/************************************************************************/
+int
+lpfc_hba_down_post(struct lpfc_hba * phba)
+{
+	struct lpfc_sli *psli = &phba->sli;
+	struct lpfc_sli_ring *pring;
+	struct lpfc_dmabuf *mp, *next_mp;
+	int i;
+
+	/* Cleanup preposted buffers on the ELS ring */
+	pring = &psli->ring[LPFC_ELS_RING];
+	list_for_each_entry_safe(mp, next_mp, &pring->postbufq, list) {
+		list_del(&mp->list);
+		pring->postbufq_cnt--;
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+	}
+
+	for (i = 0; i < psli->num_rings; i++) {
+		pring = &psli->ring[i];
+		lpfc_sli_abort_iocb_ring(phba, pring);
+	}
+
+	return 0;
+}
+
+/************************************************************************/
+/*                                                                      */
 /*    lpfc_handle_eratt                                                 */
 /*    This routine will handle processing a Host Attention              */
 /*    Error Status event. This will be initialized                      */
@@ -476,20 +512,6 @@ lpfc_handle_eratt(struct lpfc_hba * phba
 	struct lpfc_sli *psli = &phba->sli;
 	struct lpfc_sli_ring  *pring;
 
-	/*
-	 * If a reset is sent to the HBA restore PCI configuration registers.
-	 */
-	if ( phba->hba_state == LPFC_INIT_START ) {
-		mdelay(1);
-		readl(phba->HCregaddr); /* flush */
-		writel(0, phba->HCregaddr);
-		readl(phba->HCregaddr); /* flush */
-
-		/* Restore PCI cmd register */
-		pci_write_config_word(phba->pcidev,
-				      PCI_COMMAND, phba->pci_cfg_value);
-	}
-
 	if (phba->work_hs & HS_FFER6) {
 		/* Re-establishing Link */
 		lpfc_printf_log(phba, KERN_INFO, LOG_LINK_EVENT,
@@ -516,6 +538,7 @@ lpfc_handle_eratt(struct lpfc_hba * phba
 		 * attempt to restart it.
 		 */
 		lpfc_offline(phba);
+		lpfc_sli_brdrestart(phba);
 		if (lpfc_online(phba) == 0) {	/* Initialize the HBA */
 			mod_timer(&phba->fc_estabtmo, jiffies + HZ * 60);
 			return;
@@ -532,7 +555,8 @@ lpfc_handle_eratt(struct lpfc_hba * phba
 				phba->work_status[0], phba->work_status[1]);
 
 		lpfc_offline(phba);
-
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_hba_down_post(phba);
 	}
 }
 
@@ -1462,9 +1486,23 @@ lpfc_pci_probe_one(struct pci_dev *pdev,
 	phba->pci_bar2_map = pci_resource_start(phba->pcidev, 2);
 	bar2map_len        = pci_resource_len(phba->pcidev, 2);
 
-	/* Map HBA SLIM and Control Registers to a kernel virtual address. */
+	/* Map HBA SLIM to a kernel virtual address. */
 	phba->slim_memmap_p      = ioremap(phba->pci_bar0_map, bar0map_len);
+	if (!phba->slim_memmap_p) {
+		error = -ENODEV;
+		dev_printk(KERN_ERR, &pdev->dev,
+			   "ioremap failed for SLIM memory.\n");
+		goto out_idr_remove;
+	}
+
+	/* Map HBA Control Registers to a kernel virtual address. */
 	phba->ctrl_regs_memmap_p = ioremap(phba->pci_bar2_map, bar2map_len);
+	if (!phba->ctrl_regs_memmap_p) {
+		error = -ENODEV;
+		dev_printk(KERN_ERR, &pdev->dev,
+			   "ioremap failed for HBA control registers.\n");
+		goto out_iounmap_slim;
+	}
 
 	/* Allocate memory for SLI-2 structures */
 	phba->slim2p = dma_alloc_coherent(&phba->pcidev->dev, SLI2_SLIM_SIZE,
@@ -1539,7 +1577,6 @@ lpfc_pci_probe_one(struct pci_dev *pdev,
 	INIT_LIST_HEAD(&phba->lpfc_scsi_buf_list);
 
 	host->transportt = lpfc_transport_template;
-	host->hostdata[0] = (unsigned long)phba;
 	pci_set_drvdata(pdev, host);
 	error = scsi_add_host(host, &pdev->dev);
 	if (error)
@@ -1643,6 +1680,7 @@ out_free_slim:
 							phba->slim2p_mapping);
 out_iounmap:
 	iounmap(phba->ctrl_regs_memmap_p);
+out_iounmap_slim:
 	iounmap(phba->slim_memmap_p);
 out_idr_remove:
 	idr_remove(&lpfc_hba_index, phba->brd_no);
@@ -1660,7 +1698,7 @@ static void __devexit
 lpfc_pci_remove_one(struct pci_dev *pdev)
 {
 	struct Scsi_Host   *host = pci_get_drvdata(pdev);
-	struct lpfc_hba    *phba = (struct lpfc_hba *)host->hostdata[0];
+	struct lpfc_hba    *phba = (struct lpfc_hba *)host->hostdata;
 	unsigned long iflag;
 
 	lpfc_free_sysfs_attr(phba);
@@ -1681,6 +1719,7 @@ lpfc_pci_remove_one(struct pci_dev *pdev
 	 * the HBA.
 	 */
 	lpfc_sli_hba_down(phba);
+	lpfc_sli_brdrestart(phba);
 
 	/* Release the irq reservation */
 	free_irq(phba->pcidev->irq, phba);
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_mbox.c linux-2.6.15/drivers/scsi/lpfc/lpfc_mbox.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_mbox.c	2006-01-03 04:21:10.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_mbox.c	2006-02-09 15:44:58.409222220 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -195,6 +195,9 @@ lpfc_init_link(struct lpfc_hba * phba,
 		mb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_PT_PT;
 		mb->un.varInitLnk.link_flags |= FLAGS_TOPOLOGY_FAILOVER;
 		break;
+	case FLAGS_LOCAL_LB:
+		mb->un.varInitLnk.link_flags = FLAGS_LOCAL_LB;
+		break;
 	}
 
 	/* NEW_FEATURE
@@ -336,6 +339,23 @@ lpfc_read_config(struct lpfc_hba * phba,
 	return;
 }
 
+/*************************************************/
+/*  lpfc_read_lnk_stat  Issue a READ LINK STATUS */
+/*                mailbox command                */
+/*************************************************/
+void
+lpfc_read_lnk_stat(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->mbxCommand = MBX_READ_LNK_STAT;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
 /********************************************/
 /*  lpfc_reg_login  Issue a REG_LOGIN       */
 /*                  mailbox command         */
@@ -620,6 +640,17 @@ lpfc_config_port(struct lpfc_hba * phba,
 }
 
 void
+lpfc_kill_board(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb = &pmb->mb;
+
+	memset(pmb, 0, sizeof(LPFC_MBOXQ_t));
+	mb->mbxCommand = MBX_KILL_BOARD;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+void
 lpfc_mbox_put(struct lpfc_hba * phba, LPFC_MBOXQ_t * mbq)
 {
 	struct lpfc_sli *psli;
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_nportdisc.c linux-2.6.15/drivers/scsi/lpfc/lpfc_nportdisc.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_nportdisc.c	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_nportdisc.c	2006-02-09 15:44:58.405221979 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -46,13 +46,13 @@ lpfc_check_adisc(struct lpfc_hba * phba,
 	 * table entry for that node.
 	 */
 	if (memcmp(nn, &ndlp->nlp_nodename, sizeof (struct lpfc_name)) != 0)
-		return (0);
+		return 0;
 
 	if (memcmp(pn, &ndlp->nlp_portname, sizeof (struct lpfc_name)) != 0)
-		return (0);
+		return 0;
 
 	/* we match, return success */
-	return (1);
+	return 1;
 }
 
 int
@@ -150,8 +150,7 @@ lpfc_check_elscmpl_iocb(struct lpfc_hba 
 			lp = (uint32_t *) prsp->virt;
 			ptr = (void *)((uint8_t *)lp + sizeof(uint32_t));
 		}
-	}
-	else {
+	} else {
 		/* Force ulpStatus error since we are returning NULL ptr */
 		if (!(irsp->ulpStatus)) {
 			irsp->ulpStatus = IOSTAT_LOCAL_REJECT;
@@ -159,7 +158,7 @@ lpfc_check_elscmpl_iocb(struct lpfc_hba 
 		}
 		ptr = NULL;
 	}
-	return (ptr);
+	return ptr;
 }
 
 
@@ -262,11 +261,12 @@ lpfc_els_abort(struct lpfc_hba * phba, s
 	/* If we are delaying issuing an ELS command, cancel it */
 	if (ndlp->nlp_flag & NLP_DELAY_TMO) {
 		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		ndlp->nlp_last_elscmd = 0;
 		del_timer_sync(&ndlp->nlp_delayfunc);
 		if (!list_empty(&ndlp->els_retry_evt.evt_listp))
 			list_del_init(&ndlp->els_retry_evt.evt_listp);
 	}
-	return (0);
+	return 0;
 }
 
 static int
@@ -300,12 +300,10 @@ lpfc_rcv_plogi(struct lpfc_hba * phba,
 				/* Start discovery - this should just do
 				   CLEAR_LA */
 				lpfc_disc_start(phba);
-			}
-			else {
+			} else {
 				lpfc_initial_flogi(phba);
 			}
-		}
-		else {
+		} else {
 			stat.un.b.lsRjtRsnCode = LSRJT_LOGICAL_BSY;
 			stat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;
 			lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb,
@@ -321,7 +319,7 @@ lpfc_rcv_plogi(struct lpfc_hba * phba,
 		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
 		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
 		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
-		return (0);
+		return 0;
 	}
 	icmd = &cmdiocb->iocb;
 
@@ -353,7 +351,7 @@ lpfc_rcv_plogi(struct lpfc_hba * phba,
 		((sp->cmn.bbRcvSizeMsb & 0x0F) << 8) | sp->cmn.bbRcvSizeLsb;
 
 	/* no need to reg_login if we are already in one of these states */
-	switch(ndlp->nlp_state) {
+	switch (ndlp->nlp_state) {
 	case  NLP_STE_NPR_NODE:
 		if (!(ndlp->nlp_flag & NLP_NPR_ADISC))
 			break;
@@ -362,7 +360,7 @@ lpfc_rcv_plogi(struct lpfc_hba * phba,
 	case  NLP_STE_UNMAPPED_NODE:
 	case  NLP_STE_MAPPED_NODE:
 		lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, NULL, 0);
-		return (1);
+		return 1;
 	}
 
 	if ((phba->fc_flag & FC_PT2PT)
@@ -398,24 +396,16 @@ lpfc_rcv_plogi(struct lpfc_hba * phba,
 	 */
 	mbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;
 	mbox->context2  = ndlp;
-	ndlp->nlp_flag |= NLP_ACC_REGLOGIN;
+	ndlp->nlp_flag |= (NLP_ACC_REGLOGIN | NLP_RCV_PLOGI);
 
-	/* If there is an outstanding PLOGI issued, abort it before
-	 * sending ACC rsp to PLOGI recieved.
-	 */
-	if (ndlp->nlp_state == NLP_STE_PLOGI_ISSUE) {
-		/* software abort outstanding PLOGI */
-		lpfc_els_abort(phba, ndlp, 1);
-	}
-	ndlp->nlp_flag |= NLP_RCV_PLOGI;
 	lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, mbox, 0);
-	return (1);
+	return 1;
 
 out:
 	stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
 	stat.un.b.lsRjtRsnCodeExp = LSEXP_OUT_OF_RESOURCE;
 	lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
-	return (0);
+	return 0;
 }
 
 static int
@@ -451,12 +441,11 @@ lpfc_rcv_padisc(struct lpfc_hba * phba,
 	    (lpfc_check_adisc(phba, ndlp, pnn, ppn))) {
 		if (cmd == ELS_CMD_ADISC) {
 			lpfc_els_rsp_adisc_acc(phba, cmdiocb, ndlp);
-		}
-		else {
+		} else {
 			lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp,
 				NULL, 0);
 		}
-		return (1);
+		return 1;
 	}
 	/* Reject this request because invalid parameters */
 	stat.un.b.lsRjtRsvd0 = 0;
@@ -465,16 +454,17 @@ lpfc_rcv_padisc(struct lpfc_hba * phba,
 	stat.un.b.vendorUnique = 0;
 	lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
 
-	ndlp->nlp_last_elscmd = (unsigned long)ELS_CMD_PLOGI;
 	/* 1 sec timeout */
 	mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ);
 
 	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag |= NLP_DELAY_TMO;
 	spin_unlock_irq(phba->host->host_lock);
+	ndlp->nlp_last_elscmd = ELS_CMD_PLOGI;
+	ndlp->nlp_prev_state = ndlp->nlp_state;
 	ndlp->nlp_state = NLP_STE_NPR_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
-	return (0);
+	return 0;
 }
 
 static int
@@ -489,25 +479,33 @@ lpfc_rcv_logo(struct lpfc_hba * phba,
 	ndlp->nlp_flag |= NLP_LOGO_ACC;
 	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
 
-	if (!(ndlp->nlp_type & NLP_FABRIC)) {
+	if (!(ndlp->nlp_type & NLP_FABRIC) ||
+		(ndlp->nlp_state == NLP_STE_ADISC_ISSUE)) {
 		/* Only try to re-login if this is NOT a Fabric Node */
-		ndlp->nlp_last_elscmd = (unsigned long)ELS_CMD_PLOGI;
 		mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ * 1);
 		spin_lock_irq(phba->host->host_lock);
 		ndlp->nlp_flag |= NLP_DELAY_TMO;
 		spin_unlock_irq(phba->host->host_lock);
-	}
 
-	ndlp->nlp_state = NLP_STE_NPR_NODE;
-	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
+		ndlp->nlp_last_elscmd = ELS_CMD_PLOGI;
+		ndlp->nlp_prev_state = ndlp->nlp_state;
+		ndlp->nlp_state = NLP_STE_NPR_NODE;
+		lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
+	} else {
+		ndlp->nlp_prev_state = ndlp->nlp_state;
+		ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+		lpfc_nlp_list(phba, ndlp, NLP_UNUSED_LIST);
+	}
 
+	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag &= ~NLP_NPR_ADISC;
+	spin_unlock_irq(phba->host->host_lock);
 	/* The driver has to wait until the ACC completes before it continues
 	 * processing the LOGO.  The action will resume in
 	 * lpfc_cmpl_els_logo_acc routine. Since part of processing includes an
 	 * unreg_login, the driver waits so the ACC does not get aborted.
 	 */
-	return (0);
+	return 0;
 }
 
 static void
@@ -555,20 +553,12 @@ lpfc_disc_set_adisc(struct lpfc_hba * ph
 	if ((phba->cfg_use_adisc == 0) &&
 		!(phba->fc_flag & FC_RSCN_MODE)) {
 		if (!(ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE))
-			return (0);
+			return 0;
 	}
 	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag |= NLP_NPR_ADISC;
 	spin_unlock_irq(phba->host->host_lock);
-	return (1);
-}
-
-static uint32_t
-lpfc_disc_noop(struct lpfc_hba * phba,
-		struct lpfc_nodelist * ndlp, void *arg, uint32_t evt)
-{
-	/* This routine does nothing, just return the current state */
-	return (ndlp->nlp_state);
+	return 1;
 }
 
 static uint32_t
@@ -583,7 +573,7 @@ lpfc_disc_illegal(struct lpfc_hba * phba
 			phba->brd_no,
 			ndlp->nlp_DID, evt, ndlp->nlp_state, ndlp->nlp_rpi,
 			ndlp->nlp_flag);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 /* Start of Discovery State Machine routines */
@@ -597,12 +587,13 @@ lpfc_rcv_plogi_unused_node(struct lpfc_h
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	if (lpfc_rcv_plogi(phba, ndlp, cmdiocb)) {
+		ndlp->nlp_prev_state = NLP_STE_UNUSED_NODE;
 		ndlp->nlp_state = NLP_STE_UNUSED_NODE;
 		lpfc_nlp_list(phba, ndlp, NLP_UNUSED_LIST);
-		return (ndlp->nlp_state);
+		return ndlp->nlp_state;
 	}
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 static uint32_t
@@ -611,7 +602,7 @@ lpfc_rcv_els_unused_node(struct lpfc_hba
 {
 	lpfc_issue_els_logo(phba, ndlp, 0);
 	lpfc_nlp_list(phba, ndlp, NLP_UNUSED_LIST);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -628,7 +619,7 @@ lpfc_rcv_logo_unused_node(struct lpfc_hb
 	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
 	lpfc_nlp_list(phba, ndlp, NLP_UNUSED_LIST);
 
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -636,7 +627,7 @@ lpfc_cmpl_logo_unused_node(struct lpfc_h
 			  struct lpfc_nodelist * ndlp, void *arg, uint32_t evt)
 {
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 static uint32_t
@@ -644,7 +635,7 @@ lpfc_device_rm_unused_node(struct lpfc_h
 			   struct lpfc_nodelist * ndlp, void *arg, uint32_t evt)
 {
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 static uint32_t
@@ -677,12 +668,26 @@ lpfc_rcv_plogi_plogi_issue(struct lpfc_h
 		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
 		stat.un.b.lsRjtRsnCodeExp = LSEXP_CMD_IN_PROGRESS;
 		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
-	}
-	else {
+	} else {
 		lpfc_rcv_plogi(phba, ndlp, cmdiocb);
 	} /* if our portname was less */
 
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
+}
+
+static uint32_t
+lpfc_rcv_logo_plogi_issue(struct lpfc_hba * phba,
+			  struct lpfc_nodelist * ndlp, void *arg, uint32_t evt)
+{
+	struct lpfc_iocbq     *cmdiocb;
+
+	cmdiocb = (struct lpfc_iocbq *) arg;
+
+	/* software abort outstanding PLOGI */
+	lpfc_els_abort(phba, ndlp, 1);
+
+	lpfc_rcv_logo(phba, ndlp, cmdiocb);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -695,24 +700,24 @@ lpfc_rcv_els_plogi_issue(struct lpfc_hba
 
 	/* software abort outstanding PLOGI */
 	lpfc_els_abort(phba, ndlp, 1);
-	mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ * 1);
-	spin_lock_irq(phba->host->host_lock);
-	ndlp->nlp_flag |= NLP_DELAY_TMO;
-	spin_unlock_irq(phba->host->host_lock);
 
 	if (evt == NLP_EVT_RCV_LOGO) {
 		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
-	}
-	else {
+	} else {
 		lpfc_issue_els_logo(phba, ndlp, 0);
 	}
 
 	/* Put ndlp in npr list set plogi timer for 1 sec */
-	ndlp->nlp_last_elscmd = (unsigned long)ELS_CMD_PLOGI;
+	mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ * 1);
+	spin_lock_irq(phba->host->host_lock);
+	ndlp->nlp_flag |= NLP_DELAY_TMO;
+	spin_unlock_irq(phba->host->host_lock);
+	ndlp->nlp_last_elscmd = ELS_CMD_PLOGI;
+	ndlp->nlp_prev_state = NLP_STE_PLOGI_ISSUE;
 	ndlp->nlp_state = NLP_STE_NPR_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -731,7 +736,8 @@ lpfc_cmpl_plogi_plogi_issue(struct lpfc_
 	rspiocb = cmdiocb->context_un.rsp_iocb;
 
 	if (ndlp->nlp_flag & NLP_ACC_REGLOGIN) {
-		return (ndlp->nlp_state);
+		/* Recovery from PLOGI collision logic */
+		return ndlp->nlp_state;
 	}
 
 	irsp = &rspiocb->iocb;
@@ -791,7 +797,7 @@ lpfc_cmpl_plogi_plogi_issue(struct lpfc_
 		 * execute first, queue this command to
 		 * be processed later.
 		 */
-		switch(ndlp->nlp_DID) {
+		switch (ndlp->nlp_DID) {
 		case NameServer_DID:
 			mbox->mbox_cmpl =
 				lpfc_mbx_cmpl_ns_reg_login;
@@ -812,7 +818,7 @@ lpfc_cmpl_plogi_plogi_issue(struct lpfc_
 				NLP_STE_REG_LOGIN_ISSUE;
 			lpfc_nlp_list(phba, ndlp,
 				      NLP_REGLOGIN_LIST);
-			return (ndlp->nlp_state);
+			return ndlp->nlp_state;
 		}
 		mempool_free(mbox, phba->mbox_mem_pool);
 	} else {
@@ -824,7 +830,7 @@ lpfc_cmpl_plogi_plogi_issue(struct lpfc_
 	/* Free this node since the driver cannot login or has the wrong
 	   sparm */
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 static uint32_t
@@ -835,7 +841,7 @@ lpfc_device_rm_plogi_issue(struct lpfc_h
 	lpfc_els_abort(phba, ndlp, 1);
 
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 static uint32_t
@@ -846,13 +852,14 @@ lpfc_device_recov_plogi_issue(struct lpf
 	/* software abort outstanding PLOGI */
 	lpfc_els_abort(phba, ndlp, 1);
 
+	ndlp->nlp_prev_state = NLP_STE_PLOGI_ISSUE;
 	ndlp->nlp_state = NLP_STE_NPR_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
 	spin_unlock_irq(phba->host->host_lock);
 
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -868,13 +875,14 @@ lpfc_rcv_plogi_adisc_issue(struct lpfc_h
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	if (lpfc_rcv_plogi(phba, ndlp, cmdiocb)) {
-		return (ndlp->nlp_state);
+		return ndlp->nlp_state;
 	}
+	ndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;
 	ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
 	lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
 	lpfc_issue_els_plogi(phba, ndlp, 0);
 
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -887,7 +895,7 @@ lpfc_rcv_prli_adisc_issue(struct lpfc_hb
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -903,7 +911,7 @@ lpfc_rcv_logo_adisc_issue(struct lpfc_hb
 	lpfc_els_abort(phba, ndlp, 0);
 
 	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -916,7 +924,7 @@ lpfc_rcv_padisc_adisc_issue(struct lpfc_
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_padisc(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -930,7 +938,7 @@ lpfc_rcv_prlo_adisc_issue(struct lpfc_hb
 
 	/* Treat like rcv logo */
 	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -950,29 +958,33 @@ lpfc_cmpl_adisc_adisc_issue(struct lpfc_
 
 	if ((irsp->ulpStatus) ||
 		(!lpfc_check_adisc(phba, ndlp, &ap->nodeName, &ap->portName))) {
-		ndlp->nlp_last_elscmd = (unsigned long)ELS_CMD_PLOGI;
 		/* 1 sec timeout */
 		mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ);
 		spin_lock_irq(phba->host->host_lock);
 		ndlp->nlp_flag |= NLP_DELAY_TMO;
 		spin_unlock_irq(phba->host->host_lock);
+		ndlp->nlp_last_elscmd = ELS_CMD_PLOGI;
 
 		memset(&ndlp->nlp_nodename, 0, sizeof (struct lpfc_name));
 		memset(&ndlp->nlp_portname, 0, sizeof (struct lpfc_name));
 
+		ndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;
 		ndlp->nlp_state = NLP_STE_NPR_NODE;
 		lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 		lpfc_unreg_rpi(phba, ndlp);
-		return (ndlp->nlp_state);
+		return ndlp->nlp_state;
 	}
+
 	if (ndlp->nlp_type & NLP_FCP_TARGET) {
+		ndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;
 		ndlp->nlp_state = NLP_STE_MAPPED_NODE;
 		lpfc_nlp_list(phba, ndlp, NLP_MAPPED_LIST);
 	} else {
+		ndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;
 		ndlp->nlp_state = NLP_STE_UNMAPPED_NODE;
 		lpfc_nlp_list(phba, ndlp, NLP_UNMAPPED_LIST);
 	}
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -984,7 +996,7 @@ lpfc_device_rm_adisc_issue(struct lpfc_h
 	lpfc_els_abort(phba, ndlp, 1);
 
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 static uint32_t
@@ -995,14 +1007,15 @@ lpfc_device_recov_adisc_issue(struct lpf
 	/* software abort outstanding ADISC */
 	lpfc_els_abort(phba, ndlp, 1);
 
+	ndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;
 	ndlp->nlp_state = NLP_STE_NPR_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
+	ndlp->nlp_flag |= NLP_NPR_ADISC;
 	spin_unlock_irq(phba->host->host_lock);
 
-	lpfc_disc_set_adisc(phba, ndlp);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1015,7 +1028,7 @@ lpfc_rcv_plogi_reglogin_issue(struct lpf
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_plogi(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1028,7 +1041,7 @@ lpfc_rcv_prli_reglogin_issue(struct lpfc
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1041,7 +1054,7 @@ lpfc_rcv_logo_reglogin_issue(struct lpfc
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1054,7 +1067,7 @@ lpfc_rcv_padisc_reglogin_issue(struct lp
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_padisc(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1066,7 +1079,7 @@ lpfc_rcv_prlo_reglogin_issue(struct lpfc
 
 	cmdiocb = (struct lpfc_iocbq *) arg;
 	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1090,31 +1103,34 @@ lpfc_cmpl_reglogin_reglogin_issue(struct
 				phba->brd_no,
 				did, mb->mbxStatus, phba->hba_state);
 
+		/* Put ndlp in npr list set plogi timer for 1 sec */
 		mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ * 1);
 		spin_lock_irq(phba->host->host_lock);
 		ndlp->nlp_flag |= NLP_DELAY_TMO;
 		spin_unlock_irq(phba->host->host_lock);
+		ndlp->nlp_last_elscmd = ELS_CMD_PLOGI;
 
 		lpfc_issue_els_logo(phba, ndlp, 0);
-		/* Put ndlp in npr list set plogi timer for 1 sec */
-		ndlp->nlp_last_elscmd = (unsigned long)ELS_CMD_PLOGI;
+		ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
 		ndlp->nlp_state = NLP_STE_NPR_NODE;
 		lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
-		return (ndlp->nlp_state);
+		return ndlp->nlp_state;
 	}
 
 	ndlp->nlp_rpi = mb->un.varWords[0];
 
 	/* Only if we are not a fabric nport do we issue PRLI */
 	if (!(ndlp->nlp_type & NLP_FABRIC)) {
+		ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
 		ndlp->nlp_state = NLP_STE_PRLI_ISSUE;
 		lpfc_nlp_list(phba, ndlp, NLP_PRLI_LIST);
 		lpfc_issue_els_prli(phba, ndlp, 0);
 	} else {
+		ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
 		ndlp->nlp_state = NLP_STE_UNMAPPED_NODE;
 		lpfc_nlp_list(phba, ndlp, NLP_UNMAPPED_LIST);
 	}
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1123,7 +1139,7 @@ lpfc_device_rm_reglogin_issue(struct lpf
 			      uint32_t evt)
 {
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 static uint32_t
@@ -1131,12 +1147,13 @@ lpfc_device_recov_reglogin_issue(struct 
 			       struct lpfc_nodelist * ndlp, void *arg,
 			       uint32_t evt)
 {
+	ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
 	ndlp->nlp_state = NLP_STE_NPR_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
 	spin_unlock_irq(phba->host->host_lock);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1148,7 +1165,7 @@ lpfc_rcv_plogi_prli_issue(struct lpfc_hb
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_plogi(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1160,7 +1177,7 @@ lpfc_rcv_prli_prli_issue(struct lpfc_hba
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1175,7 +1192,7 @@ lpfc_rcv_logo_prli_issue(struct lpfc_hba
 	lpfc_els_abort(phba, ndlp, 1);
 
 	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1187,7 +1204,7 @@ lpfc_rcv_padisc_prli_issue(struct lpfc_h
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_padisc(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 /* This routine is envoked when we rcv a PRLO request from a nport
@@ -1203,7 +1220,7 @@ lpfc_rcv_prlo_prli_issue(struct lpfc_hba
 
 	cmdiocb = (struct lpfc_iocbq *) arg;
 	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1220,9 +1237,10 @@ lpfc_cmpl_prli_prli_issue(struct lpfc_hb
 
 	irsp = &rspiocb->iocb;
 	if (irsp->ulpStatus) {
+		ndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;
 		ndlp->nlp_state = NLP_STE_UNMAPPED_NODE;
 		lpfc_nlp_list(phba, ndlp, NLP_UNMAPPED_LIST);
-		return (ndlp->nlp_state);
+		return ndlp->nlp_state;
 	}
 
 	/* Check out PRLI rsp */
@@ -1238,9 +1256,10 @@ lpfc_cmpl_prli_prli_issue(struct lpfc_hb
 			ndlp->nlp_fcp_info |= NLP_FCP_2_DEVICE;
 	}
 
+	ndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;
 	ndlp->nlp_state = NLP_STE_MAPPED_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_MAPPED_LIST);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 /*! lpfc_device_rm_prli_issue
@@ -1268,7 +1287,7 @@ lpfc_device_rm_prli_issue(struct lpfc_hb
 	lpfc_els_abort(phba, ndlp, 1);
 
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 
@@ -1295,12 +1314,13 @@ lpfc_device_recov_prli_issue(struct lpfc
 	/* software abort outstanding PRLI */
 	lpfc_els_abort(phba, ndlp, 1);
 
+	ndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;
 	ndlp->nlp_state = NLP_STE_NPR_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
 	spin_unlock_irq(phba->host->host_lock);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1312,7 +1332,7 @@ lpfc_rcv_plogi_unmap_node(struct lpfc_hb
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_plogi(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1325,7 +1345,7 @@ lpfc_rcv_prli_unmap_node(struct lpfc_hba
 
 	lpfc_rcv_prli(phba, ndlp, cmdiocb);
 	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1337,7 +1357,7 @@ lpfc_rcv_logo_unmap_node(struct lpfc_hba
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1349,7 +1369,7 @@ lpfc_rcv_padisc_unmap_node(struct lpfc_h
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_padisc(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1360,21 +1380,21 @@ lpfc_rcv_prlo_unmap_node(struct lpfc_hba
 
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
-	/* Treat like rcv logo */
-	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
 lpfc_device_recov_unmap_node(struct lpfc_hba * phba,
 			   struct lpfc_nodelist * ndlp, void *arg, uint32_t evt)
 {
+	ndlp->nlp_prev_state = NLP_STE_UNMAPPED_NODE;
 	ndlp->nlp_state = NLP_STE_NPR_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 	ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
 	lpfc_disc_set_adisc(phba, ndlp);
 
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1386,7 +1406,7 @@ lpfc_rcv_plogi_mapped_node(struct lpfc_h
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_plogi(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1398,7 +1418,7 @@ lpfc_rcv_prli_mapped_node(struct lpfc_hb
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1410,7 +1430,7 @@ lpfc_rcv_logo_mapped_node(struct lpfc_hb
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1423,7 +1443,7 @@ lpfc_rcv_padisc_mapped_node(struct lpfc_
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_padisc(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1442,7 +1462,7 @@ lpfc_rcv_prlo_mapped_node(struct lpfc_hb
 
 	/* Treat like rcv logo */
 	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1450,13 +1470,14 @@ lpfc_device_recov_mapped_node(struct lpf
 			    struct lpfc_nodelist * ndlp, void *arg,
 			    uint32_t evt)
 {
+	ndlp->nlp_prev_state = NLP_STE_MAPPED_NODE;
 	ndlp->nlp_state = NLP_STE_NPR_NODE;
 	lpfc_nlp_list(phba, ndlp, NLP_NPR_LIST);
 	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
 	spin_unlock_irq(phba->host->host_lock);
 	lpfc_disc_set_adisc(phba, ndlp);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1470,23 +1491,24 @@ lpfc_rcv_plogi_npr_node(struct lpfc_hba 
 
 	/* Ignore PLOGI if we have an outstanding LOGO */
 	if (ndlp->nlp_flag & NLP_LOGO_SND) {
-		return (ndlp->nlp_state);
+		return ndlp->nlp_state;
 	}
 
 	if (lpfc_rcv_plogi(phba, ndlp, cmdiocb)) {
 		spin_lock_irq(phba->host->host_lock);
 		ndlp->nlp_flag &= ~(NLP_NPR_ADISC | NLP_NPR_2B_DISC);
 		spin_unlock_irq(phba->host->host_lock);
-		return (ndlp->nlp_state);
+		return ndlp->nlp_state;
 	}
 
 	/* send PLOGI immediately, move to PLOGI issue state */
 	if (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {
+			ndlp->nlp_prev_state = NLP_STE_NPR_NODE;
 			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
 			lpfc_issue_els_plogi(phba, ndlp, 0);
 	}
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1506,16 +1528,21 @@ lpfc_rcv_prli_npr_node(struct lpfc_hba *
 
 	if (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {
 		if (ndlp->nlp_flag & NLP_NPR_ADISC) {
+			spin_lock_irq(phba->host->host_lock);
+			ndlp->nlp_flag &= ~NLP_NPR_ADISC;
+			spin_unlock_irq(phba->host->host_lock);
+			ndlp->nlp_prev_state = NLP_STE_NPR_NODE;
 			ndlp->nlp_state = NLP_STE_ADISC_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_ADISC_LIST);
 			lpfc_issue_els_adisc(phba, ndlp, 0);
 		} else {
+			ndlp->nlp_prev_state = NLP_STE_NPR_NODE;
 			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
 			lpfc_issue_els_plogi(phba, ndlp, 0);
 		}
 	}
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1528,7 +1555,7 @@ lpfc_rcv_logo_npr_node(struct lpfc_hba *
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
 	lpfc_rcv_logo(phba, ndlp, cmdiocb);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1544,16 +1571,18 @@ lpfc_rcv_padisc_npr_node(struct lpfc_hba
 
 	if (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {
 		if (ndlp->nlp_flag & NLP_NPR_ADISC) {
+			ndlp->nlp_prev_state = NLP_STE_NPR_NODE;
 			ndlp->nlp_state = NLP_STE_ADISC_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_ADISC_LIST);
 			lpfc_issue_els_adisc(phba, ndlp, 0);
 		} else {
+			ndlp->nlp_prev_state = NLP_STE_NPR_NODE;
 			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
 			lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
 			lpfc_issue_els_plogi(phba, ndlp, 0);
 		}
 	}
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1565,25 +1594,47 @@ lpfc_rcv_prlo_npr_node(struct lpfc_hba *
 
 	cmdiocb = (struct lpfc_iocbq *) arg;
 
+	spin_lock_irq(phba->host->host_lock);
+	ndlp->nlp_flag |= NLP_LOGO_ACC;
+	spin_unlock_irq(phba->host->host_lock);
+
 	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, NULL, 0);
 
-	if (ndlp->nlp_flag & NLP_DELAY_TMO) {
-		if (ndlp->nlp_last_elscmd == (unsigned long)ELS_CMD_PLOGI) {
-			return (ndlp->nlp_state);
-		} else {
-			spin_lock_irq(phba->host->host_lock);
-			ndlp->nlp_flag &= ~NLP_DELAY_TMO;
-			spin_unlock_irq(phba->host->host_lock);
-			del_timer_sync(&ndlp->nlp_delayfunc);
-			if (!list_empty(&ndlp->els_retry_evt.evt_listp))
-				list_del_init(&ndlp->els_retry_evt.evt_listp);
-		}
+	if (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {
+		mod_timer(&ndlp->nlp_delayfunc, jiffies + HZ * 1);
+		spin_lock_irq(phba->host->host_lock);
+		ndlp->nlp_flag |= NLP_DELAY_TMO;
+		ndlp->nlp_flag &= ~NLP_NPR_ADISC;
+		spin_unlock_irq(phba->host->host_lock);
+		ndlp->nlp_last_elscmd = ELS_CMD_PLOGI;
+	} else {
+		spin_lock_irq(phba->host->host_lock);
+		ndlp->nlp_flag &= ~NLP_NPR_ADISC;
+		spin_unlock_irq(phba->host->host_lock);
 	}
+	return ndlp->nlp_state;
+}
 
-	ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
-	lpfc_nlp_list(phba, ndlp, NLP_PLOGI_LIST);
-	lpfc_issue_els_plogi(phba, ndlp, 0);
-	return (ndlp->nlp_state);
+static uint32_t
+lpfc_cmpl_plogi_npr_node(struct lpfc_hba * phba,
+			  struct lpfc_nodelist * ndlp, void *arg, uint32_t evt)
+{
+	struct lpfc_iocbq *cmdiocb, *rspiocb;
+
+	cmdiocb = (struct lpfc_iocbq *) arg;
+	rspiocb = cmdiocb->context_un.rsp_iocb;
+	return ndlp->nlp_state;
+}
+
+static uint32_t
+lpfc_cmpl_prli_npr_node(struct lpfc_hba * phba,
+			  struct lpfc_nodelist * ndlp, void *arg, uint32_t evt)
+{
+	struct lpfc_iocbq *cmdiocb, *rspiocb;
+
+	cmdiocb = (struct lpfc_iocbq *) arg;
+	rspiocb = cmdiocb->context_un.rsp_iocb;
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1592,7 +1643,19 @@ lpfc_cmpl_logo_npr_node(struct lpfc_hba 
 {
 	lpfc_unreg_rpi(phba, ndlp);
 	/* This routine does nothing, just return the current state */
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
+}
+
+static uint32_t
+lpfc_cmpl_adisc_npr_node(struct lpfc_hba * phba,
+			    struct lpfc_nodelist * ndlp, void *arg,
+			    uint32_t evt)
+{
+	struct lpfc_iocbq *cmdiocb, *rspiocb;
+
+	cmdiocb = (struct lpfc_iocbq *) arg;
+	rspiocb = cmdiocb->context_un.rsp_iocb;
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1606,9 +1669,10 @@ lpfc_cmpl_reglogin_npr_node(struct lpfc_
 	pmb = (LPFC_MBOXQ_t *) arg;
 	mb = &pmb->mb;
 
-	ndlp->nlp_rpi = mb->un.varWords[0];
+	if (!mb->mbxStatus)
+		ndlp->nlp_rpi = mb->un.varWords[0];
 
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 static uint32_t
@@ -1617,7 +1681,7 @@ lpfc_device_rm_npr_node(struct lpfc_hba 
 			    uint32_t evt)
 {
 	lpfc_nlp_list(phba, ndlp, NLP_NO_LIST);
-	return (NLP_STE_FREED_NODE);
+	return NLP_STE_FREED_NODE;
 }
 
 static uint32_t
@@ -1627,8 +1691,17 @@ lpfc_device_recov_npr_node(struct lpfc_h
 {
 	spin_lock_irq(phba->host->host_lock);
 	ndlp->nlp_flag &= ~NLP_NPR_2B_DISC;
+	if (ndlp->nlp_flag & NLP_DELAY_TMO) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		if (!list_empty(&ndlp->els_retry_evt.evt_listp))
+			list_del_init(&ndlp->els_retry_evt.evt_listp);
+		spin_unlock_irq(phba->host->host_lock);
+		ndlp->nlp_last_elscmd = 0;
+		del_timer_sync(&ndlp->nlp_delayfunc);
+		return ndlp->nlp_state;
+	}
 	spin_unlock_irq(phba->host->host_lock);
-	return (ndlp->nlp_state);
+	return ndlp->nlp_state;
 }
 
 
@@ -1707,7 +1780,7 @@ static uint32_t (*lpfc_disc_action[NLP_S
 
 	lpfc_rcv_plogi_plogi_issue,	/* RCV_PLOGI   PLOGI_ISSUE    */
 	lpfc_rcv_els_plogi_issue,	/* RCV_PRLI        */
-	lpfc_rcv_els_plogi_issue,	/* RCV_LOGO        */
+	lpfc_rcv_logo_plogi_issue,	/* RCV_LOGO        */
 	lpfc_rcv_els_plogi_issue,	/* RCV_ADISC       */
 	lpfc_rcv_els_plogi_issue,	/* RCV_PDISC       */
 	lpfc_rcv_els_plogi_issue,	/* RCV_PRLO        */
@@ -1795,10 +1868,10 @@ static uint32_t (*lpfc_disc_action[NLP_S
 	lpfc_rcv_padisc_npr_node,       /* RCV_ADISC       */
 	lpfc_rcv_padisc_npr_node,       /* RCV_PDISC       */
 	lpfc_rcv_prlo_npr_node,         /* RCV_PRLO        */
-	lpfc_disc_noop,			/* CMPL_PLOGI      */
-	lpfc_disc_noop,			/* CMPL_PRLI       */
+	lpfc_cmpl_plogi_npr_node,	/* CMPL_PLOGI      */
+	lpfc_cmpl_prli_npr_node,	/* CMPL_PRLI       */
 	lpfc_cmpl_logo_npr_node,        /* CMPL_LOGO       */
-	lpfc_disc_noop,			/* CMPL_ADISC      */
+	lpfc_cmpl_adisc_npr_node,       /* CMPL_ADISC      */
 	lpfc_cmpl_reglogin_npr_node,    /* CMPL_REG_LOGIN  */
 	lpfc_device_rm_npr_node,        /* DEVICE_RM       */
 	lpfc_device_recov_npr_node,     /* DEVICE_RECOVERY */
@@ -1844,10 +1917,9 @@ lpfc_disc_state_machine(struct lpfc_hba 
 		ndlp->nlp_flag &= ~NLP_DELAY_REMOVE;
 		spin_unlock_irq(phba->host->host_lock);
 		lpfc_nlp_remove(phba, ndlp);
-		return (NLP_STE_FREED_NODE);
+		return NLP_STE_FREED_NODE;
 	}
 	if (rc == NLP_STE_FREED_NODE)
-		return (NLP_STE_FREED_NODE);
-	ndlp->nlp_state = rc;
-	return (rc);
+		return NLP_STE_FREED_NODE;
+	return rc;
 }
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_scsi.c linux-2.6.15/drivers/scsi/lpfc/lpfc_scsi.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_scsi.c	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_scsi.c	2006-02-09 15:44:58.421222942 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -467,7 +467,7 @@ lpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba 
 	sdev = cmd->device;
 	cmd->scsi_done(cmd);
 
-	if (!result &&
+	if (!result && pnode != NULL &&
 	   ((jiffies - pnode->last_ramp_up_time) >
 		LPFC_Q_RAMP_UP_INTERVAL * HZ) &&
 	   ((jiffies - pnode->last_q_full_time) >
@@ -495,7 +495,7 @@ lpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba 
 	 * Check for queue full.  If the lun is reporting queue full, then
 	 * back off the lun queue depth to prevent target overloads.
 	 */
-	if (result == SAM_STAT_TASK_SET_FULL) {
+	if (result == SAM_STAT_TASK_SET_FULL && pnode != NULL) {
 		pnode->last_q_full_time = jiffies;
 
 		shost_for_each_device(tmp_sdev, sdev->host) {
@@ -743,7 +743,7 @@ lpfc_scsi_tgt_reset(struct lpfc_scsi_buf
 const char *
 lpfc_info(struct Scsi_Host *host)
 {
-	struct lpfc_hba    *phba = (struct lpfc_hba *) host->hostdata[0];
+	struct lpfc_hba    *phba = (struct lpfc_hba *) host->hostdata;
 	int len;
 	static char  lpfcinfobuf[384];
 
@@ -803,7 +803,7 @@ static int
 lpfc_queuecommand(struct scsi_cmnd *cmnd, void (*done) (struct scsi_cmnd *))
 {
 	struct lpfc_hba *phba =
-		(struct lpfc_hba *) cmnd->device->host->hostdata[0];
+		(struct lpfc_hba *) cmnd->device->host->hostdata;
 	struct lpfc_sli *psli = &phba->sli;
 	struct lpfc_rport_data *rdata = cmnd->device->hostdata;
 	struct lpfc_nodelist *ndlp = rdata->pnode;
@@ -877,7 +877,7 @@ static int
 lpfc_abort_handler(struct scsi_cmnd *cmnd)
 {
 	struct Scsi_Host *shost = cmnd->device->host;
-	struct lpfc_hba *phba = (struct lpfc_hba *)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *)shost->hostdata;
 	struct lpfc_sli_ring *pring = &phba->sli.ring[phba->sli.fcp_ring];
 	struct lpfc_iocbq *iocb;
 	struct lpfc_iocbq *abtsiocb;
@@ -981,7 +981,7 @@ static int
 lpfc_reset_lun_handler(struct scsi_cmnd *cmnd)
 {
 	struct Scsi_Host *shost = cmnd->device->host;
-	struct lpfc_hba *phba = (struct lpfc_hba *)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *)shost->hostdata;
 	struct lpfc_scsi_buf *lpfc_cmd;
 	struct lpfc_iocbq *iocbq, *iocbqrsp;
 	struct lpfc_rport_data *rdata = cmnd->device->hostdata;
@@ -1094,7 +1094,7 @@ static int
 lpfc_reset_bus_handler(struct scsi_cmnd *cmnd)
 {
 	struct Scsi_Host *shost = cmnd->device->host;
-	struct lpfc_hba *phba = (struct lpfc_hba *)shost->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *)shost->hostdata;
 	struct lpfc_nodelist *ndlp = NULL;
 	int match;
 	int ret = FAILED, i, err_count = 0;
@@ -1195,7 +1195,7 @@ out:
 static int
 lpfc_slave_alloc(struct scsi_device *sdev)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba *)sdev->host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *)sdev->host->hostdata;
 	struct lpfc_scsi_buf *scsi_buf = NULL;
 	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));
 	uint32_t total = 0, i;
@@ -1251,7 +1251,7 @@ lpfc_slave_alloc(struct scsi_device *sde
 static int
 lpfc_slave_configure(struct scsi_device *sdev)
 {
-	struct lpfc_hba *phba = (struct lpfc_hba *) sdev->host->hostdata[0];
+	struct lpfc_hba *phba = (struct lpfc_hba *) sdev->host->hostdata;
 	struct fc_rport *rport = starget_to_rport(sdev->sdev_target);
 
 	if (sdev->tagged_supported)
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_sli.c linux-2.6.15/drivers/scsi/lpfc/lpfc_sli.c
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_sli.c	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_sli.c	2006-02-09 15:44:58.389221017 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -513,7 +513,9 @@ lpfc_sli_chk_mbx_command(uint8_t mbxComm
 	case MBX_SET_MASK:
 	case MBX_SET_SLIM:
 	case MBX_UNREG_D_ID:
+	case MBX_KILL_BOARD:
 	case MBX_CONFIG_FARP:
+	case MBX_BEACON:
 	case MBX_LOAD_AREA:
 	case MBX_RUN_BIU_DIAG64:
 	case MBX_CONFIG_PORT:
@@ -1512,98 +1514,162 @@ lpfc_sli_abort_iocb_ring(struct lpfc_hba
 	return errcnt;
 }
 
-/******************************************************************************
-* lpfc_sli_send_reset
-*
-* Note: After returning from this function, the HBA cannot be accessed for
-* 1 ms. Since we do not wish to delay in interrupt context, it is the
-* responsibility of the caller to perform the mdelay(1) and flush via readl().
-******************************************************************************/
-static int
-lpfc_sli_send_reset(struct lpfc_hba * phba, uint16_t skip_post)
+int
+lpfc_sli_brdready(struct lpfc_hba * phba, uint32_t mask)
 {
-	MAILBOX_t *swpmb;
-	volatile uint32_t word0;
-	void __iomem *to_slim;
-	unsigned long flags = 0;
+	uint32_t status;
+	int i = 0;
+	int retval = 0;
 
-	spin_lock_irqsave(phba->host->host_lock, flags);
+	/* Read the HBA Host Status Register */
+	status = readl(phba->HSregaddr);
 
-	/* A board reset must use REAL SLIM. */
-	phba->sli.sli_flag &= ~LPFC_SLI2_ACTIVE;
+	/*
+	 * Check status register every 100ms for 5 retries, then every
+	 * 500ms for 5, then every 2.5 sec for 5, then reset board and
+	 * every 2.5 sec for 4.
+	 * Break our of the loop if errors occurred during init.
+	 */
+	while (((status & mask) != mask) &&
+	       !(status & HS_FFERM) &&
+	       i++ < 20) {
 
-	word0 = 0;
-	swpmb = (MAILBOX_t *) & word0;
-	swpmb->mbxCommand = MBX_RESTART;
-	swpmb->mbxHc = 1;
+		if (i <= 5)
+			msleep(10);
+		else if (i <= 10)
+			msleep(500);
+		else
+			msleep(2500);
 
-	to_slim = phba->MBslimaddr;
-	writel(*(uint32_t *) swpmb, to_slim);
-	readl(to_slim); /* flush */
+		if (i == 15) {
+			phba->hba_state = LPFC_STATE_UNKNOWN; /* Do post */
+			lpfc_sli_brdrestart(phba);
+		}
+		/* Read the HBA Host Status Register */
+		status = readl(phba->HSregaddr);
+	}
 
-	/* Only skip post after fc_ffinit is completed */
-	if (skip_post) {
-		word0 = 1;	/* This is really setting up word1 */
-	} else {
-		word0 = 0;	/* This is really setting up word1 */
+	/* Check to see if any errors occurred during init */
+	if ((status & HS_FFERM) || (i >= 20)) {
+		phba->hba_state = LPFC_HBA_ERROR;
+		retval = 1;
 	}
-	to_slim = phba->MBslimaddr + sizeof (uint32_t);
-	writel(*(uint32_t *) swpmb, to_slim);
-	readl(to_slim); /* flush */
 
-	/* Turn off parity checking and serr during the physical reset */
-	pci_read_config_word(phba->pcidev, PCI_COMMAND, &phba->pci_cfg_value);
-	pci_write_config_word(phba->pcidev, PCI_COMMAND,
-			      (phba->pci_cfg_value &
-			       ~(PCI_COMMAND_PARITY | PCI_COMMAND_SERR)));
+	return retval;
+}
 
-	writel(HC_INITFF, phba->HCregaddr);
+int
+lpfc_sli_brdkill(struct lpfc_hba * phba)
+{
+	struct lpfc_sli *psli;
+	LPFC_MBOXQ_t *pmb;
+	uint32_t status;
+	uint32_t ha_copy;
+	int retval;
+	int i = 0;
 
-	phba->hba_state = LPFC_INIT_START;
-	spin_unlock_irqrestore(phba->host->host_lock, flags);
+	psli = &phba->sli;
 
-	return 0;
+	/* Kill HBA */
+	lpfc_printf_log(phba,
+		KERN_INFO,
+		LOG_SLI,
+		"%d:0329 Kill HBA Data: x%x x%x\n",
+		phba->brd_no,
+		phba->hba_state,
+		psli->sli_flag);
+
+	if ((pmb = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool,
+						  GFP_ATOMIC)) == 0) {
+		return 1;
+	}
+
+	/* Disable the error attention */
+	spin_lock_irq(phba->host->host_lock);
+	status = readl(phba->HCregaddr);
+	status &= ~HC_ERINT_ENA;
+	writel(status, phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+	spin_unlock_irq(phba->host->host_lock);
+
+	lpfc_kill_board(phba, pmb);
+	pmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;
+	retval = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);
+
+	if (retval != MBX_SUCCESS) {
+		if (retval != MBX_BUSY)
+			mempool_free(pmb, phba->mbox_mem_pool);
+		return 1;
+	}
+
+	mempool_free(pmb, phba->mbox_mem_pool);
+
+	/* There is no completion for a KILL_BOARD mbox cmd. Check for an error
+	 * attention every 100ms for 3 seconds. If we don't get ERATT after
+	 * 3 seconds we still set HBA_ERROR state because the status of the
+	 * board is now undefined.
+	 */
+	ha_copy = readl(phba->HAregaddr);
+
+	while ((i++ < 30) && !(ha_copy & HA_ERATT)) {
+		mdelay(100);
+		ha_copy = readl(phba->HAregaddr);
+	}
+
+	del_timer_sync(&psli->mbox_tmo);
+
+	spin_lock_irq(phba->host->host_lock);
+	psli->sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+	spin_unlock_irq(phba->host->host_lock);
+
+	psli->mbox_active = NULL;
+	lpfc_hba_down_post(phba);
+	phba->hba_state = LPFC_HBA_ERROR;
+
+	return (ha_copy & HA_ERATT ? 0 : 1);
 }
 
-static int
-lpfc_sli_brdreset(struct lpfc_hba * phba, uint16_t skip_post)
+int
+lpfc_sli_brdreset(struct lpfc_hba * phba)
 {
+	struct lpfc_sli *psli;
 	struct lpfc_sli_ring *pring;
+	uint16_t cfg_value;
 	int i;
-	struct lpfc_dmabuf *mp, *next_mp;
-	unsigned long flags = 0;
-
-	lpfc_sli_send_reset(phba, skip_post);
-	mdelay(1);
 
-	spin_lock_irqsave(phba->host->host_lock, flags);
-	/* Risk the write on flush case ie no delay after the readl */
-	readl(phba->HCregaddr); /* flush */
-	/* Now toggle INITFF bit set by lpfc_sli_send_reset */
-	writel(0, phba->HCregaddr);
-	readl(phba->HCregaddr); /* flush */
+	psli = &phba->sli;
 
-	/* Restore PCI cmd register */
-	pci_write_config_word(phba->pcidev, PCI_COMMAND, phba->pci_cfg_value);
+	/* Reset HBA */
+	lpfc_printf_log(phba, KERN_INFO, LOG_SLI,
+			"%d:0325 Reset HBA Data: x%x x%x\n", phba->brd_no,
+			phba->hba_state, psli->sli_flag);
 
 	/* perform board reset */
 	phba->fc_eventTag = 0;
 	phba->fc_myDID = 0;
-	phba->fc_prevDID = Mask_DID;
+	phba->fc_prevDID = 0;
 
-	/* Reset HBA */
-	lpfc_printf_log(phba,
-		KERN_INFO,
-		LOG_SLI,
-		"%d:0325 Reset HBA Data: x%x x%x x%x\n",
-		phba->brd_no,
-		phba->hba_state,
-		phba->sli.sli_flag,
-		skip_post);
+	psli->sli_flag = 0;
+
+	/* Turn off parity checking and serr during the physical reset */
+	pci_read_config_word(phba->pcidev, PCI_COMMAND, &cfg_value);
+	pci_write_config_word(phba->pcidev, PCI_COMMAND,
+			      (cfg_value &
+			       ~(PCI_COMMAND_PARITY | PCI_COMMAND_SERR)));
+
+	/* Now toggle INITFF bit in the Host Control Register */
+	writel(HC_INITFF, phba->HCregaddr);
+	mdelay(1);
+	readl(phba->HCregaddr); /* flush */
+	writel(0, phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+
+	/* Restore PCI cmd register */
+	pci_write_config_word(phba->pcidev, PCI_COMMAND, cfg_value);
 
 	/* Initialize relevant SLI info */
-	for (i = 0; i < phba->sli.num_rings; i++) {
-		pring = &phba->sli.ring[i];
+	for (i = 0; i < psli->num_rings; i++) {
+		pring = &psli->ring[i];
 		pring->flag = 0;
 		pring->rspidx = 0;
 		pring->next_cmdidx  = 0;
@@ -1611,27 +1677,62 @@ lpfc_sli_brdreset(struct lpfc_hba * phba
 		pring->cmdidx = 0;
 		pring->missbufcnt = 0;
 	}
-	spin_unlock_irqrestore(phba->host->host_lock, flags);
 
-	if (skip_post) {
-		mdelay(100);
+	phba->hba_state = LPFC_WARM_START;
+	return 0;
+}
+
+int
+lpfc_sli_brdrestart(struct lpfc_hba * phba)
+{
+	MAILBOX_t *mb;
+	struct lpfc_sli *psli;
+	uint16_t skip_post;
+	volatile uint32_t word0;
+	void __iomem *to_slim;
+
+	spin_lock_irq(phba->host->host_lock);
+
+	psli = &phba->sli;
+
+	/* Restart HBA */
+	lpfc_printf_log(phba, KERN_INFO, LOG_SLI,
+			"%d:0328 Restart HBA Data: x%x x%x\n", phba->brd_no,
+			phba->hba_state, psli->sli_flag);
+
+	word0 = 0;
+	mb = (MAILBOX_t *) &word0;
+	mb->mbxCommand = MBX_RESTART;
+	mb->mbxHc = 1;
+
+	to_slim = phba->MBslimaddr;
+	writel(*(uint32_t *) mb, to_slim);
+	readl(to_slim); /* flush */
+
+	/* Only skip post after fc_ffinit is completed */
+	if (phba->hba_state) {
+		skip_post = 1;
+		word0 = 1;	/* This is really setting up word1 */
 	} else {
-		mdelay(2000);
+		skip_post = 0;
+		word0 = 0;	/* This is really setting up word1 */
 	}
+	to_slim = (uint8_t *) phba->MBslimaddr + sizeof (uint32_t);
+	writel(*(uint32_t *) mb, to_slim);
+	readl(to_slim); /* flush */
 
-	spin_lock_irqsave(phba->host->host_lock, flags);
-	/* Cleanup preposted buffers on the ELS ring */
-	pring = &phba->sli.ring[LPFC_ELS_RING];
-	list_for_each_entry_safe(mp, next_mp, &pring->postbufq, list) {
-		list_del(&mp->list);
-		pring->postbufq_cnt--;
-		lpfc_mbuf_free(phba, mp->virt, mp->phys);
-		kfree(mp);
-	}
-	spin_unlock_irqrestore(phba->host->host_lock, flags);
+	lpfc_sli_brdreset(phba);
+
+	phba->hba_state = LPFC_INIT_START;
+
+	spin_unlock_irq(phba->host->host_lock);
+
+	if (skip_post)
+		mdelay(100);
+	else
+		mdelay(2000);
 
-	for (i = 0; i < phba->sli.num_rings; i++)
-		lpfc_sli_abort_iocb_ring(phba, &phba->sli.ring[i]);
+	lpfc_hba_down_post(phba);
 
 	return 0;
 }
@@ -1691,7 +1792,8 @@ lpfc_sli_chipset_init(struct lpfc_hba *p
 		}
 
 		if (i == 15) {
-			lpfc_sli_brdreset(phba, 0);
+			phba->hba_state = LPFC_STATE_UNKNOWN; /* Do post */
+			lpfc_sli_brdrestart(phba);
 		}
 		/* Read the HBA Host Status Register */
 		status = readl(phba->HSregaddr);
@@ -1735,8 +1837,8 @@ lpfc_sli_hba_setup(struct lpfc_hba * phb
 	}
 
 	while (resetcount < 2 && !done) {
-		phba->hba_state = 0;
-		lpfc_sli_brdreset(phba, 0);
+		phba->hba_state = LPFC_STATE_UNKNOWN;
+		lpfc_sli_brdrestart(phba);
 		msleep(2500);
 		rc = lpfc_sli_chipset_init(phba);
 		if (rc)
@@ -1920,6 +2022,14 @@ lpfc_sli_issue_mbox(struct lpfc_hba * ph
 	mb = &pmbox->mb;
 	status = MBX_SUCCESS;
 
+	if (phba->hba_state == LPFC_HBA_ERROR) {
+		spin_unlock_irqrestore(phba->host->host_lock, drvr_flag);
+
+		/* Mbox command <mbxCommand> cannot issue */
+		LOG_MBOX_CANNOT_ISSUE_DATA( phba, mb, psli, flag)
+		return (MBX_NOT_FINISHED);
+	}
+
 	if (psli->sli_flag & LPFC_SLI_MBOX_ACTIVE) {
 		/* Polling for a mbox command when another one is already active
 		 * is not allowed in SLI. Also, the driver must have established
@@ -2002,7 +2112,8 @@ lpfc_sli_issue_mbox(struct lpfc_hba * ph
 
 	/* If we are not polling, we MUST be in SLI2 mode */
 	if (flag != MBX_POLL) {
-		if (!(psli->sli_flag & LPFC_SLI2_ACTIVE)) {
+		if (!(psli->sli_flag & LPFC_SLI2_ACTIVE) &&
+		    (mb->mbxCommand != MBX_KILL_BOARD)) {
 			psli->sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
 			spin_unlock_irqrestore(phba->host->host_lock,
 					       drvr_flag);
@@ -2035,7 +2146,8 @@ lpfc_sli_issue_mbox(struct lpfc_hba * ph
 		/* First copy command data to host SLIM area */
 		lpfc_sli_pcimem_bcopy(mb, &phba->slim2p->mbx, MAILBOX_CMD_SIZE);
 	} else {
-		if (mb->mbxCommand == MBX_CONFIG_PORT) {
+		if (mb->mbxCommand == MBX_CONFIG_PORT ||
+		    mb->mbxCommand == MBX_KILL_BOARD) {
 			/* copy command data into host mbox for cmpl */
 			lpfc_sli_pcimem_bcopy(mb, &phba->slim2p->mbx,
 					MAILBOX_CMD_SIZE);
@@ -2086,8 +2198,9 @@ lpfc_sli_issue_mbox(struct lpfc_hba * ph
 		ha_copy = readl(phba->HAregaddr);
 
 		/* Wait for command to complete */
-		while (((word0 & OWN_CHIP) == OWN_CHIP)
-		       || !(ha_copy & HA_MBATT)) {
+		while (((word0 & OWN_CHIP) == OWN_CHIP) ||
+		       (!(ha_copy & HA_MBATT) &&
+			(phba->hba_state > LPFC_WARM_START))) {
 			if (i++ >= 100) {
 				psli->sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
 				spin_unlock_irqrestore(phba->host->host_lock,
@@ -2237,16 +2350,6 @@ lpfc_sli_issue_iocb(struct lpfc_hba *phb
 		   !(phba->sli.sli_flag & LPFC_PROCESS_LA)))
 		goto iocb_busy;
 
-	/*
-	 * Check to see if this is a high priority command.
-	 * If so bypass tx queue processing.
-	 */
-	if (unlikely((flag & SLI_IOCB_HIGH_PRIORITY) &&
-		     (iocb = lpfc_sli_next_iocb_slot(phba, pring)))) {
-		lpfc_sli_submit_iocb(phba, pring, iocb, piocb);
-		piocb = NULL;
-	}
-
 	while ((iocb = lpfc_sli_next_iocb_slot(phba, pring)) &&
 	       (nextiocb = lpfc_sli_next_iocb(phba, pring, &piocb)))
 		lpfc_sli_submit_iocb(phba, pring, iocb, nextiocb);
@@ -2465,15 +2568,6 @@ lpfc_sli_hba_down(struct lpfc_hba * phba
 
 	spin_unlock_irqrestore(phba->host->host_lock, flags);
 
-	/*
-	 * Provided the hba is not in an error state, reset it.  It is not
-	 * capable of IO anymore.
-	 */
-	if (phba->hba_state != LPFC_HBA_ERROR) {
-		phba->hba_state = LPFC_INIT_START;
-		lpfc_sli_brdreset(phba, 1);
-	}
-
 	return 1;
 }
 
@@ -2877,11 +2971,10 @@ lpfc_sli_issue_mbox_wait(struct lpfc_hba
 		pmboxq->context1 = NULL;
 		/* if schedule_timeout returns 0, we timed out and were not
 		   woken up */
-		if (timeleft == 0) {
+		if ((timeleft == 0) || signal_pending(current))
 			retval = MBX_TIMEOUT;
-		} else {
+		else
 			retval = MBX_SUCCESS;
-		}
 	}
 
 
@@ -2987,13 +3080,6 @@ lpfc_intr_handler(int irq, void *dev_id,
 			/* Clear Chip error bit */
 			writel(HA_ERATT, phba->HAregaddr);
 			readl(phba->HAregaddr); /* flush */
-
-			/*
-			 * Reseting the HBA is the only reliable way
-			 * to shutdown interrupt when there is a
-			 * ERROR.
-			 */
-			lpfc_sli_send_reset(phba, phba->hba_state);
 		}
 
 		spin_lock(phba->host->host_lock);
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_sli.h linux-2.6.15/drivers/scsi/lpfc/lpfc_sli.h
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_sli.h	2006-01-03 04:21:10.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_sli.h	2006-02-09 15:44:58.329217406 +0100
@@ -61,7 +61,6 @@ struct lpfc_iocbq {
 };
 
 #define SLI_IOCB_RET_IOCB      1	/* Return IOCB if cmd ring full */
-#define SLI_IOCB_HIGH_PRIORITY 2	/* High priority command */
 
 #define IOCB_SUCCESS        0
 #define IOCB_BUSY           1
diff -purN linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_version.h linux-2.6.15/drivers/scsi/lpfc/lpfc_version.h
--- linux-2.6.15/drivers/scsi/lpfc.orig/lpfc_version.h	2006-02-09 15:44:32.000000000 +0100
+++ linux-2.6.15/drivers/scsi/lpfc/lpfc_version.h	2006-02-09 15:44:58.429223423 +0100
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2005 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2006 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -18,12 +18,12 @@
  * included with this package.                                     *
  *******************************************************************/
 
-#define LPFC_DRIVER_VERSION "8.1.1"
+#define LPFC_DRIVER_VERSION "8.1.2"
 
 #define LPFC_DRIVER_NAME "lpfc"
 
 #define LPFC_MODULE_DESC "Emulex LightPulse Fibre Channel SCSI driver " \
 		LPFC_DRIVER_VERSION
-#define LPFC_COPYRIGHT "Copyright(c) 2004-2005 Emulex.  All rights reserved."
+#define LPFC_COPYRIGHT "Copyright(c) 2004-2006 Emulex.  All rights reserved."
 
 #define DFC_API_VERSION "0.0.0"
