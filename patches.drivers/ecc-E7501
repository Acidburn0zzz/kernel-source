diff -urNp linux-2.6.5/drivers/char/ecc.c linux-2.6.5.SUSE/drivers/char/ecc.c
--- linux-2.6.5/drivers/char/ecc.c	2004-05-26 14:27:06.580596012 +0200
+++ linux-2.6.5.SUSE/drivers/char/ecc.c	2004-05-26 14:28:22.247557702 +0200
@@ -23,12 +23,14 @@
 #include <linux/proc_fs.h>
 
 #define	ECC_VER	"0.14 (Oct 10 2001)"
+#define KERN_ECC KERN_ALERT 
 
 static struct timer_list ecctimer;
 static struct pci_dev *bridge = NULL;
 static u16 vendor, device;
 static int scrub_needed;
 static int scrub_row;
+static int ecc_scrub = -1;
 
 /* memory types */
 #define BANK_EMPTY	0	/* Empty bank */
@@ -59,6 +61,7 @@ static struct bankstruct
 #define ECC_DETECT	3	/* Detects ECC errors */
 #define ECC_CORRECT	4	/* Detects ECC errors and corrects SBE */
 #define ECC_AUTO	5	/* Detects ECC errors and has hardware scrubber */
+#define ECC_SKIP        6       /* Wrong bridge; keep looking */
 
 static struct ChipsetInfo
 {
@@ -66,6 +69,7 @@ static struct ChipsetInfo
 	int ecc_mode;		/* current ECC mode */
 	void (*check)(void);	/* pointer to ecc checking routine */
 	void (*clear_err)(void);	/* pointer to error clear routine */
+        u32 addr_shift;
 #if 0
 /*
  * I dont think we care about SERR at the moment.
@@ -358,6 +362,244 @@ void probe_serverworks(void)
 	}
 }
 
+
+
+static void check_cnb30le(void)
+{
+  unsigned long mesr;
+  unsigned char errsts;
+  unsigned char eccsyn;
+  unsigned row, ca, ra;
+  int i;
+  char *ename;
+  int ebit;
+  static unsigned char cnb30_syndrome_dbits[64] = {
+    0xC1, 0xC2, 0xC4, 0xC8, 0xA1, 0xA2, 0xA4, 0xA8, /*  0- 7 */
+    0x91, 0x92, 0x94, 0x98, 0x61, 0x62, 0x64, 0x68, /*  8-15 */
+    0x51, 0x52, 0x54, 0x58, 0x31, 0x32, 0x34, 0x38, /* 16-23 */
+    0xF8, 0x4F, 0x70, 0xD0, 0x0E, 0x0B, 0xF1, 0x2F, /* 24-31 */
+    0x1C, 0x2C, 0x4C, 0x8C, 0x1A, 0x2A, 0x4A, 0x8A, /* 32-39 */
+    0x19, 0x29, 0x49, 0x89, 0x16, 0x26, 0x46, 0x86, /* 40-47 */
+    0x15, 0x25, 0x45, 0x85, 0x13, 0x23, 0x43, 0x83, /* 48-55 */
+    0x8F, 0xF4, 0x07, 0x0D, 0xE0, 0xB0, 0x1F, 0xF2  /* 56-63 */ };
+  static unsigned char cnb30_syndrome_cbits[8] = {
+    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
+
+  errsts = pci_byte(0x47);
+  if ((errsts & 0x06) == 0)
+    return; /* no ECC errors */
+
+  mesr = pci_dword(0x94);
+  row = (mesr>>29) & 0x7;
+  ca = (mesr>>15) & 0x3fff;
+  ra = mesr & 0x7fff;
+  eccsyn = pci_byte(0xe8);        /* ECC syndrome register */
+  if (errsts & 0x04) {
+#if 1
+    /* for normal operation, don't fill up logs with ra/ca */
+    printk(KERN_ERR "ECC: UE: row=%d syn=%02x\n", row, eccsyn);
+#else
+    printk(KERN_ERR "ECC: UE: row=%d ca.ra=%04x.%04x syn=%02x\n", row, ca, ra, eccsyn);
+#endif
+    bank[row].mbecount++;
+    if (errsts & 0x02)
+      bank[row].sbecount++;
+  } else if (errsts & 0x02) {
+    ebit = 0;
+    ename = "?";
+    for (i=0; i<64; ++i) {
+      if (cnb30_syndrome_dbits[i] == eccsyn) {
+	ebit = i;
+	ename = "d";
+	break;
+      }
+    }
+    for (i=0; i<8; ++i) {
+      if (cnb30_syndrome_cbits[i] == eccsyn) {
+	ebit = i;
+	ename = "c";
+	break;
+      }
+    }
+#if 1
+    /* for normal operation, don't fill up logs with ra/ca */
+    printk(KERN_ERR "ECC: CE: row=%d syn=%02x bit=%s%d\n", row, eccsyn, ename, ebit);
+#else
+    printk(KERN_ERR "ECC: CE: row=%d ca.ra=%04x.%04x syn=%02x bit=%s%d\n", row, ca, ra, eccsyn, ename, ebit);
+#endif
+    bank[row].sbecount++;
+  }
+  pci_write_config_byte(bridge, 0x47, (errsts & 0x06)); /* clear error */
+#ifdef DEBUG
+  printk(KERN_ERR "check cnb30le completed!");
+#endif
+}
+
+static void probe_cnb30le(void)
+{
+  int loop, papc, tmp, efcr;
+  unsigned char mrpr = 0;
+
+  if ((bridge->devfn & 0x07) != 0) {
+    /* we need function 0 of the bridge */
+    cs.ecc_cap = ECC_SKIP;
+    return;
+  }
+
+  cs.ecc_cap = ECC_AUTO;
+
+  papc = tmp = pci_byte(0x48);
+  if (ecc_scrub == 0)
+    papc &= ~0x01;  /* turn off scrubbing */
+  else if (ecc_scrub == 1)
+    papc |= 0x01;   /* turn on scrubbing */
+  if (papc != tmp)
+    pci_write_config_byte(bridge, 0x48, papc);      /* update scrubbing */
+
+  efcr = pci_byte(0xe0);
+  if (efcr & 0x04) {
+    /* ecc enabled */
+    if (papc & 0x01)
+      cs.ecc_mode = ECC_AUTO; /* scrubbing enabled */
+    else
+      cs.ecc_mode = ECC_CORRECT;      /* scrubbing disabled */
+    pci_write_config_byte(bridge, 0x47, 0x06); /* clear errors */
+  } else {
+    cs.ecc_mode = ECC_NONE; /* ecc disabled */
+  }
+
+  cs.check = check_cnb30le;
+
+  for(loop=0;loop<8;loop++)
+    {
+      int attr = pci_byte(0x7c+loop/2);
+      if (loop & 1) attr >>= 4;
+      attr &= 0x0f;
+#if 0
+      printk(KERN_ERR "ECC: row %d 0x%x\n", loop, attr);
+#endif
+      bank[loop].mtype = BANK_SDR;
+      bank[loop].eccmode = cs.ecc_mode;
+      bank[loop].endaddr = pci_byte(0x81+loop*2)<<24;
+      if (attr || bank[loop].endaddr)
+	mrpr |= 1 << loop;
+    }
+  pci_write_config_byte(bridge, 0x90, mrpr); /* rows present */
+
+#ifdef DEBUG
+  printk(KERN_ERR "probe cnb30le completed!");
+#endif
+}
+
+static void check_e7500(void)
+{
+  static int row = 0;
+  int dram_ferr, dram_nerr;
+  u32 eap;
+  u8 ce_syndrome;
+
+  dram_ferr = pci_byte(0x80);
+  dram_nerr = pci_byte(0x82);
+  if (dram_ferr & 2) {
+    /*
+    **  Bits 27:6 of the address register contain
+    **  bits 33:12 of the physical address.
+    */
+    eap = pci_dword(0xB0) & 0x0FFFFFC0;
+    row = find_row(eap >> 6);
+    bank[row].mbecount++;
+    pci_write_config_byte(bridge, 0x80, 2);
+    printk(KERN_ECC "ECC: UE at memory address %lx0 bank %d\n",
+	   (long unsigned int)eap << 2, row);
+  }
+  if (dram_ferr & 1) {
+    eap = pci_dword(0xA0) & 0x0FFFFFC0;
+    row = find_row(eap >> 6);       /* pages */
+    ce_syndrome = (dram_ferr & 1) ? pci_byte(0xD0) & 0x7F : 0;
+    bank[row].sbecount++;
+    pci_write_config_byte(bridge, 0x80, 1);
+    printk(KERN_ECC "ECC: CE at memory address %lx0 bank %d syndrome %x\n",
+	   (long unsigned int)eap << 2, row, ce_syndrome);
+  }
+  /*
+  **  If the next-error register is set, we don't know the row.
+  **  We'd like to count the errors, though, so count them in the
+  **  last row that was reported.
+  */
+  if (dram_nerr & 2) {
+    bank[row].mbecount++;
+    pci_write_config_byte(bridge, 0x82, 2);
+    printk(KERN_ECC "ECC: second UE\n");
+  }
+  if (dram_nerr & 1) {
+    bank[row].sbecount++;
+    pci_write_config_byte(bridge, 0x82, 1);
+    printk(KERN_ECC "ECC: second CE\n");
+  }
+}
+
+static struct pci_dev* find_function(int fn)
+{
+  static struct pci_dev *pfn = NULL;
+  int devfn;
+
+  devfn = (bridge->devfn & ~7) + (fn & 7);
+  while ((pfn = pci_find_class(PCI_CLASS_BRIDGE_HOST << 8, pfn))) {
+    if (pfn->devfn == devfn && pfn->bus->number == bridge->bus->number)
+      return pfn;
+  }
+  return NULL;
+}
+
+static void probe_e7500(void)
+{
+  int loop;
+  u32 drc;
+  u16 mchcfgns, dvnp;
+  int ddim[] = { ECC_NONE, ECC_RESERVED, ECC_CORRECT, ECC_RESERVED };
+  struct pci_dev *pf1;
+  static struct pci_dev e7500_bridge1;
+
+  /*
+  **  E750x use functions 0 & 1.
+  **  We get our probe info from 0, but need
+  **  a struct pci_dev of function 1 for the checker.
+  */
+  if ((bridge->devfn & 0x07) != 0) {
+    cs.ecc_cap = ECC_SKIP;
+    return;
+  }
+  cs.ecc_cap = ECC_AUTO;
+  cs.addr_shift = 12;     /* address units are 4KB pages */
+
+  mchcfgns = pci_word(0x52);
+  drc = pci_dword(0x7C);
+  dvnp = pci_word(0xe0);
+
+  ddim[2] = (mchcfgns & 1) ? ECC_AUTO : ECC_CORRECT;
+  cs.ecc_mode = ddim[(drc>>20)&3];
+  for(loop=0; loop<8; loop++) {
+    bank[loop].endaddr = (unsigned long)pci_byte(0x60+loop)
+      << (26-cs.addr_shift);
+    bank[loop].mtype = BANK_DDR;
+    bank[loop].eccmode = cs.ecc_mode;
+  }
+  cs.check = check_e7500;
+  if (dvnp & 1)
+    /* fn 1 disabled; we need to see it */
+    pci_write_config_word(bridge, 0xe0, dvnp & ~1);
+  /*
+  **  If d0f1 doesn't exist, we have to invent it.
+  */
+  if ((pf1 = find_function(1)) == NULL) {
+    e7500_bridge1 = *bridge;        /* clone d0f0 */
+    e7500_bridge1.devfn += 1;       /* fn 0 -> 1 */
+    pf1 = &e7500_bridge1;
+  }
+  bridge = pf1;
+}
+
+
 /*
  * 450gx probing is buggered at the moment. help me obi-wan.
  */
@@ -406,6 +648,79 @@ void probe_450gx(void)
 	cs.SBE_err_mask = 0xFFFFFFFC;
 }
 
+static void check_e7501(void)
+{
+  int errsts = pci_word(0x80) | pci_word(0x82);
+#ifdef DEBUG
+  printk(KERN_DEBUG "error state : 0x%x\n",errsts);
+#endif
+  if (errsts & 2)
+    {
+      u32 eap = (pci_dword(0xB0) & 0x0FFFFFC0)<<6 ;
+      char derrsyn = pci_word(0xD0) & 0x7F;
+      printk(KERN_ERR "ECC: MBE at memory address 0x%lx\n row %d syndrome 0x%x",
+	     (long unsigned int)eap, find_row(eap), derrsyn);
+      scrub_needed = 2;
+      scrub_row = find_row(eap);
+      bank[scrub_row].mbecount++;
+    }
+  if (errsts & 1)
+    {
+      u32 eap = (pci_dword(0xA0) & 0x0FFFFFC0)<<6;
+      char derrsyn = pci_byte(0xD0) & 0x7F;
+      printk(KERN_ERR "ECC: SBE at memory address 0x%lx row %d syndrome 0x%x\n",
+	     (long unsigned int)eap, find_row(eap), derrsyn);
+      scrub_needed = 1;
+      scrub_row = find_row(eap);
+      bank[scrub_row].sbecount++;
+    }
+}
+
+static void probe_e7501(void)
+{
+  int loop;
+  int chan,granu=26;
+  u32 drc;
+  int ddim[] = { ECC_NONE, ECC_RESERVED, ECC_CORRECT, ECC_RESERVED };
+  drc = pci_dword(0x7C);
+  cs.ecc_cap = ECC_CORRECT;
+  /*cs.ecc_mode = ddim[(drc>>19)&3];*/
+  cs.ecc_mode = ddim[(drc>>20)&3];
+
+  cs.check = check_e7501;
+  /*cs.check = check_e7500;*/
+
+
+  /* e7501 support 2 channel mode:
+   * dual-channel, whose address granularity is 64MB (<<26);
+   * single-channel, whose address granularity is 32MB (<<25).
+   * We should check current mode!FIXME*/
+
+  chan=(drc>>18)&3;
+  if(chan == 0)
+    granu=25;
+  else if (chan == 1)
+    granu=26;
+#ifdef DEBUG
+  printk(KERN_DEBUG "ecc type:%d\n",(drc>>20)&3);
+  printk(KERN_DEBUG "ecc channel:%d\n",chan);
+  printk(KERN_DEBUG "ecc granu:%d\n",granu);
+#endif
+  for(loop=0;loop<16;loop++) /*should be 8?*/
+    {
+      // bank[loop].endaddr=(unsigned long)pci_word(0x60+(loop*2))<<granu;
+      bank[loop].endaddr=(unsigned long)pci_byte(0x60+loop)<<granu;
+      bank[loop].mtype = BANK_DDR;
+      bank[loop].eccmode = cs.ecc_mode;
+        #if 0
+        #ifdef DEBUG
+      printk(KERN_DEBUG "bank %d, origin 0x%lx,end 0x%x\n",loop,(unsigned long)pci_word(0x60+(loop*2)),bank[loop].\
+	     endaddr);
+        #endif
+        #endif
+    }
+}
+
 /* there seems to be NO WAY to distinguish 440zx from 440bx!! >B( */
 void probe_440bx(void)
 {
@@ -1100,7 +1415,7 @@ int procfile_read(char *page, char **sta
 	len += sprintf(page, "Chipset ECC capability : %s\n", ecc[cs.ecc_cap]);
 	len += sprintf(page + len, "Current ECC mode : %s\n", ecc[cs.ecc_mode]);
 	len += sprintf(page + len, "Bank\tSize\tType\tECC\tSBE\tMBE\n");
-	for (loop = 0; loop < 8; ++loop) {
+	for (loop = 0; loop < 16; ++loop) {
 		last_mem = bank[loop].endaddr;
 		if (last_mem > mem_end) {
 			len += sprintf(page + len, "%d\t", loop);
@@ -1171,12 +1486,16 @@ static struct pci_probe_matrix probe_mat
 	{ 0x1106, 0x0694, probe_via }, /* vt82c694 - pro133a */
 	/* Serverworks */
 	{ 0x1166, 0x0008, probe_serverworks }, /* CNB20HE - serverset iii he */
-	{ 0x1166, 0x0009, probe_serverworks }, /* serverset iii le */
+
+	{ 0x1166, 0x0009, probe_cnb30le }, /* serverset iii le */
+
 	/* Intel */
 	{ 0x8086, 0x1130, 0 }, /* 815 doesnt support ecc */
 	{ 0x8086, 0x122d, 0 }, /* 430fx doesnt support ecc */
 	{ 0x8086, 0x1237, probe_440fx },
 	{ 0x8086, 0x1250, probe_430hx },
+        { 0x8086, 0x2540, probe_e7500 },
+	{ 0x8086, 0x254c, probe_e7501 }, 
 	{ 0x8086, 0x1A21, probe_840 },
 	{ 0x8086, 0x1A30, probe_845 },
 	{ 0x8086, 0x2530, probe_850 },
@@ -1199,6 +1518,7 @@ int find_chipset(void) {
 	while ((bridge = pci_find_class(PCI_CLASS_BRIDGE_HOST << 8, bridge)))
 	{
 		int loop = 0;
+		cs.ecc_cap = ECC_NONE;
 		pci_read_config_word(bridge, PCI_VENDOR_ID, &vendor);
 		pci_read_config_word(bridge, PCI_DEVICE_ID, &device);
 		while(probe_matrix[loop].vendor)
@@ -1209,6 +1529,9 @@ int find_chipset(void) {
 				if(probe_matrix[loop].check)
 				{
 					probe_matrix[loop].check();
+					if (cs.ecc_cap == ECC_SKIP)
+					  break;
+					printk("ECC: Found memory controller %x:%04x\n", vendor, device);
 					return 1;
 				} else {
 					printk("<1>ECC: Unsupported device %x:%x.\n", vendor, device);
@@ -1217,7 +1540,10 @@ int find_chipset(void) {
 			}
 			loop++;
 		}
-		printk("<1>ECC: Unknown device %x:%x.\n", vendor, device);
+                if (cs.ecc_cap == ECC_SKIP)
+		  cs.ecc_cap = ECC_NONE;  /* probe said keep looking */
+                else
+		  printk("<1>ECC: Unknown device %x:%x.\n", vendor, device);
 	}
 	printk("<1>ECC: Can't find host bridge.\n");
 	return 0;
@@ -1238,7 +1564,7 @@ int init_module(void) {
 #endif
 	printk("<1>ECC: monitor version %s\n", ECC_VER);
 
-	for (loop=0;loop<8;loop++) {
+	for (loop=0;loop<16;loop++) {
 		bank[loop].endaddr = 0;
 		bank[loop].sbecount = 0;
 		bank[loop].mbecount = 0;
