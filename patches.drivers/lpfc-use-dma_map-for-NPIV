From: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Subject: scsi: use dma_map_sg for NPIV
Patch-Mainline: Yes

This patch uses dma_map_sg with phba->pcidev->dev instead of
scsi_dma_map.

scsi_dma_map doesn't work for NPIV since fc_vport->dev isn't fully
initialized. check_addr() in arch/x86_64/kernel/pci-nommu.c leads to
the crash since dev->dma_mask is NULL.

For more details:

http://marc.info/?l=linux-scsi&m=118312448030633&w=2

Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Signed-off-by: James Smart <james.smart@emulex.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
f17f444a846cc9b524937829b521fa1006db98b1
 drivers/scsi/lpfc/lpfc_scsi.c |   13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

--- a/drivers/scsi/lpfc/lpfc_scsi.c	2007-08-27 14:01:23.000000000 -0400
+++ b/drivers/scsi/lpfc/lpfc_scsi.c	2007-08-27 14:01:23.000000000 -0400
@@ -332,8 +332,7 @@ lpfc_scsi_prep_dma_buf(struct lpfc_hba *
 	 * data bde entry.
 	 */
 	bpl += 2;
-	nseg = scsi_dma_map(scsi_cmnd);
-	if (nseg > 0) {
+	if (scsi_sg_count(scsi_cmnd)) {
 		/*
 		 * The driver stores the segment count returned from pci_map_sg
 		 * because this a count of dma-mappings used to map the use_sg
@@ -341,6 +340,11 @@ lpfc_scsi_prep_dma_buf(struct lpfc_hba *
 		 * architectures that implement an IOMMU.
 		 */
 
+		nseg = dma_map_sg(&phba->pcidev->dev, scsi_sglist(scsi_cmnd),
+				  scsi_sg_count(scsi_cmnd), datadir);
+		if (unlikely(!nseg))
+			return 1;
+
 		lpfc_cmd->seg_cnt = nseg;
 		if (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {
 			printk(KERN_ERR "%s: Too many sg segments from "
@@ -370,8 +374,7 @@ lpfc_scsi_prep_dma_buf(struct lpfc_hba *
 			bpl++;
 			num_bde++;
 		}
-	} else if (nseg < 0)
-		return 1;
+	}
 
 	/*
 	 * Finish initializing those IOCB fields that are dependent on the
@@ -506,7 +509,7 @@ lpfc_handle_fcp_err(struct lpfc_vport *v
 					"underrun converted to error "
 					"Data: x%x x%x x%x\n",
 					phba->brd_no, vpi, cmnd->cmnd[0],
-					cmnd->request_bufflen,
+					scsi_bufflen(cmnd),
 					scsi_get_resid(cmnd), cmnd->underflow);
 			host_status = DID_ERROR;
 		}
