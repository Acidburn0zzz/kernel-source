Index: linux-2.6.5/fs/cifs/CHANGES
===================================================================
--- linux-2.6.5.orig/fs/cifs/CHANGES	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/CHANGES	2004-06-15 11:07:47.000000000 +0200
@@ -1,3 +1,30 @@
+Version 1.18
+------------
+Do not rename hardlinked files (since that should be a noop). Flush
+cached write behind data when reopening a file after session abend,
+except when already in write. Grab per socket sem during reconnect 
+to avoid oops in sendmsg if overlapping with reconnect.
+
+
+Version 1.17
+------------
+Update number of blocks in file so du command is happier (in Linux a fake
+blocksize of 512 is required for calculating number of blocks in inode).
+Fix prepare write of partial pages to read in data from server if possible.
+Fix race on tcpStatus field between unmount and reconnection code, causing
+cifsd process sometimes to hang around forever. Improve out of memory
+checks in cifs_filldir
+
+Version 1.16
+------------
+Fix incorrect file size in file handle based setattr on big endian hardware.
+Fix oops in build_path_from_dentry when out of memory.  Add checks for invalid
+and closing file structs in writepage/partialpagewrite.  Add statistics
+for each mounted share (new menuconfig option). Fix endianness problem in
+volume information displayed in /proc/fs/cifs/DebugData (only affects
+affects big endian architectures). Prevent renames while constructing
+path names for open, mkdir and rmdir.
+
 Version 1.15
 ------------
 Change to mempools for alloc smb request buffers and multiplex structs
Index: linux-2.6.5/fs/cifs/TODO
===================================================================
--- linux-2.6.5.orig/fs/cifs/TODO	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/TODO	2004-06-15 11:07:47.000000000 +0200
@@ -1,7 +1,7 @@
-version 1.14 May 14, 2004
+version 1.16 May 27, 2004
 
-A Partial List of Known Problems and Missing Features
-=====================================================
+A Partial List of Missing Features
+==================================
 
 Contributions are welcome.  There are plenty of opportunities
 for visible, important contributions to this module.  Here
@@ -54,7 +54,8 @@
 spurious oplock breaks).
 
 p) Improve performance of readpages by sending more than one read
-at a time when 8 pages or more are requested.
+at a time when 8 pages or more are requested.  Evaluate whether
+reads larger than 16K would be helpful.
 
 q) For support of Windows9x/98 we need to retry failed mounts
 to *SMBSERVER (default server name) with the uppercase hostname
@@ -66,8 +67,10 @@
 s) Finish fcntl D_NOTIFY support so kde and gnome file list windows
 will autorefresh
 
+t) Add GUI tool to configure /proc/fs/cifs settings and for display of
+the CIFS statistics
 
-KNOWN BUGS (updated May 14, 2004)
+KNOWN BUGS (updated May 27, 2004)
 ====================================
 1) existing symbolic links (Windows reparse points) are recognized but
 can not be created remotely. They are implemented for Samba and those that
@@ -77,20 +80,16 @@
 but recognizes them
 3) create of new files to FAT partitions on Windows servers can
 succeed but still return access denied (appears to be Windows 
-not client problem) and has not been reproduced recently.
+server not cifs client problem) and has not been reproduced recently.
 NTFS partitions do not have this problem.
 4) debug connectation lock test case 10 which fails against
 Samba (may be unmappable due to POSIX to Windows lock model
 differences but worth investigating).  Also debug Samba to 
 see why lock test case 7 takes longer to complete to Samba
 than to Windows.
-5) prepare_write does not initialize pages properly when partial
-page writes begin in the middle of a page (pages can get zeroed).
-6) Write caching done incorrectly when files are only opened
-with write permission by the application.
 
 Misc testing to do
-=================
+==================
 1) check out max path names and max path name components against various server
 types. Return max path name in stat -f information
 
@@ -102,5 +101,6 @@
 and when signing is disabled to request larger read sizes (larger than 
 negotiated size) and send larger write sizes to modern servers.
 
-4) More exhaustively test the recently added NT4 support
+4) More exhaustively test the recently added NT4 support against various
+NT4 service pack levels.
 
Index: linux-2.6.5/fs/cifs/cifsfs.h
===================================================================
--- linux-2.6.5.orig/fs/cifs/cifsfs.h	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/cifsfs.h	2004-06-15 11:07:47.000000000 +0200
@@ -93,5 +93,5 @@
 			 size_t, int);
 extern ssize_t	cifs_getxattr(struct dentry *, const char *, void *, size_t);
 extern ssize_t	cifs_listxattr(struct dentry *, char *, size_t);
-#define CIFS_VERSION   "1.15"
+#define CIFS_VERSION   "1.18"
 #endif				/* _CIFSFS_H */
Index: linux-2.6.5/fs/cifs/connect.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/connect.c	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/connect.c	2004-06-15 11:07:47.000000000 +0200
@@ -128,7 +128,8 @@
 		}
 	}
 	read_unlock(&GlobalSMBSeslock);
-
+	/* do not want to be sending data on a socket we are freeing */
+	down(&server->tcpSem); 
 	if(server->ssocket) {
 		cFYI(1,("State: 0x%x Flags: 0x%lx", server->ssocket->state,
 			server->ssocket->flags));
@@ -154,7 +155,7 @@
 		}
 	}
 	spin_unlock(&GlobalMid_Lock);
-
+	up(&server->tcpSem); 
 
 	while ((server->tcpStatus != CifsExiting) && (server->tcpStatus != CifsGood))
 	{
@@ -610,6 +611,8 @@
 			}
 			if ((temp_len = strnlen(value, 300)) < 300) {
 				vol->UNC = kmalloc(temp_len+1,GFP_KERNEL);
+				if(vol->UNC == NULL)
+					return 1;
 				strcpy(vol->UNC,value);
 				if (strncmp(vol->UNC, "//", 2) == 0) {
 					vol->UNC[0] = '\\';
@@ -757,6 +760,8 @@
 		}
 		if ((temp_len = strnlen(devname, 300)) < 300) {
 			vol->UNC = kmalloc(temp_len+1,GFP_KERNEL);
+			if(vol->UNC == NULL)
+				return 1;
 			strcpy(vol->UNC,devname);
 			if (strncmp(vol->UNC, "//", 2) == 0) {
 				vol->UNC[0] = '\\';
@@ -1555,7 +1560,7 @@
 					bcc_ptr +=
 					    pSMBr->resp.SecurityBlobLength;
 
-				if (smb_buffer->Flags2 &= SMBFLG2_UNICODE) {
+				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
 					if ((long) (bcc_ptr) % 2) {
 						remaining_words =
 						    (BCC(smb_buffer_response)
@@ -1808,7 +1813,7 @@
 					      pSMBr->resp.SecurityBlobLength));
 				}
 
-				if (smb_buffer->Flags2 &= SMBFLG2_UNICODE) {
+				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
 					if ((long) (bcc_ptr) % 2) {
 						remaining_words =
 						    (BCC(smb_buffer_response)
@@ -2119,7 +2124,7 @@
 						ses->server->secMode |= 
 							SECMODE_SIGN_ENABLED;
 
-				if (smb_buffer->Flags2 &= SMBFLG2_UNICODE) {
+				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
 					if ((long) (bcc_ptr) % 2) {
 						remaining_words =
 						    (BCC(smb_buffer_response)
@@ -2515,7 +2520,7 @@
 				cFYI(1,
 				     ("NTLMSSP response to Authenticate "));
 
-				if (smb_buffer->Flags2 &= SMBFLG2_UNICODE) {
+				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
 					if ((long) (bcc_ptr) % 2) {
 						remaining_words =
 						    (BCC(smb_buffer_response)
@@ -2714,7 +2719,7 @@
         /* skip service field (NB: this field is always ASCII) */
 		bcc_ptr += length + 1;	
 		strncpy(tcon->treeName, tree, MAX_TREE_SIZE);
-		if (smb_buffer->Flags2 &= SMBFLG2_UNICODE) {
+		if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
 			length = UniStrnlen((wchar_t *) bcc_ptr, 512);
 			if (((long) bcc_ptr + (2 * length)) -
 			    (long) pByteArea(smb_buffer_response) <=
Index: linux-2.6.5/fs/cifs/dir.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/dir.c	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/dir.c	2004-06-15 11:07:47.000000000 +0200
@@ -315,7 +315,9 @@
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
+	down(&direntry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
+	up(&direntry->d_sb->s_vfs_rename_sem);
 	if(full_path == NULL)
 		rc = -ENOMEM;
 	
Index: linux-2.6.5/fs/cifs/file.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/file.c	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/file.c	2004-06-15 11:07:47.000000000 +0200
@@ -80,7 +80,9 @@
 		}
 	}
 
+	down(&inode->i_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(file->f_dentry);
+	up(&inode->i_sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -261,7 +263,7 @@
 	return rc;
 }
 
-static int cifs_reopen_file(struct inode *inode, struct file *file)
+static int cifs_reopen_file(struct inode *inode, struct file *file, int can_flush)
 {
 	int rc = -EACCES;
 	int xid, oplock;
@@ -273,7 +275,6 @@
 	int desiredAccess = 0x20197;
 	int disposition = FILE_OPEN;
 	__u16 netfid;
-	FILE_ALL_INFO * buf = NULL;
 
 	if(inode == NULL)
 		return -EBADF;
@@ -298,7 +299,10 @@
 	}
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
-
+/* can not grab rename sem here because various ops, including
+those that already have the rename sem can end up causing writepage
+to get called and if the server was down that means we end up here,
+and we can never tell if the caller already has the rename_sem */
 	full_path = build_path_from_dentry(file->f_dentry);
 	if(full_path == NULL) {
 		up(&pCifsFile->fh_sem);
@@ -323,21 +327,23 @@
 	else
 		oplock = FALSE;
 
-		/* BB pass O_SYNC flag through on file attributes .. BB */
+	
+	/* Can not refresh inode by passing in file_info buf to be returned
+	 by SMBOpen and then calling get_inode_info with returned buf 
+	 since file might have write behind data that needs to be flushed 
+	 and server version of file size can be stale. If we 
+	 knew for sure that inode was not dirty locally we could do this */
 
-		/* Also refresh inode by passing in file_info buf returned by SMBOpen
-		   and calling get_inode_info with returned buf (at least
-		   helps non-Unix server case */
-	buf = kmalloc(sizeof(FILE_ALL_INFO),GFP_KERNEL);
+/*	buf = kmalloc(sizeof(FILE_ALL_INFO),GFP_KERNEL);
 	if(buf==0) {
 		up(&pCifsFile->fh_sem);
 		if (full_path)
 			kfree(full_path);
 		FreeXid(xid);
 		return -ENOMEM;
-	}
+	}*/
 	rc = CIFSSMBOpen(xid, pTcon, full_path, disposition, desiredAccess,
-				CREATE_NOT_DIR, &netfid, &oplock, buf, cifs_sb->local_nls);
+				CREATE_NOT_DIR, &netfid, &oplock, NULL, cifs_sb->local_nls);
 	if (rc) {
 		up(&pCifsFile->fh_sem);
 		cFYI(1, ("cifs_open returned 0x%x ", rc));
@@ -348,13 +354,25 @@
 		up(&pCifsFile->fh_sem);
 		pCifsInode = CIFS_I(inode);
 		if(pCifsInode) {
-			if (pTcon->ses->capabilities & CAP_UNIX)
-				rc = cifs_get_inode_info_unix(&inode,
+			if(can_flush) {
+				filemap_fdatawrite(inode->i_mapping);
+				filemap_fdatawait(inode->i_mapping);
+			/* temporarily disable caching while we
+			go to server to get inode info */
+				pCifsInode->clientCanCacheAll = FALSE;
+				pCifsInode->clientCanCacheRead = FALSE;
+				if (pTcon->ses->capabilities & CAP_UNIX)
+					rc = cifs_get_inode_info_unix(&inode,
 						full_path, inode->i_sb);
-			else
-				rc = cifs_get_inode_info(&inode,
-						full_path, buf, inode->i_sb);
-
+				else
+					rc = cifs_get_inode_info(&inode,
+						full_path, NULL, inode->i_sb);
+			} /* else we are writing out data to server already
+			and could deadlock if we tried to flush data, and 
+			since we do not know if we have data that would
+			invalidate the current end of file on the server
+			we can not go to the server to get the new
+			inod info */
 			if((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
 				pCifsInode->clientCanCacheAll =  TRUE;
 				pCifsInode->clientCanCacheRead = TRUE;
@@ -370,8 +388,6 @@
 		}
 	}
 
-	if (buf)
-		kfree(buf);
 	if (full_path)
 		kfree(full_path);
 	FreeXid(xid);
@@ -607,7 +623,11 @@
 					FreeXid(xid);
 					return total_written;
 				}
-				rc = cifs_reopen_file(file->f_dentry->d_inode,file);
+				/* we could deadlock if we called
+				 filemap_fdatawait from here so tell
+				reopen_file not to flush data to server now */
+				rc = cifs_reopen_file(file->f_dentry->d_inode,
+					file,FALSE);
 				if(rc != 0)
 					break;
 			}
@@ -947,14 +967,14 @@
 		cFYI(1,("attempting read on write only file instance"));
 	}
 
-
 	for (total_read = 0,current_offset=read_data; read_size > total_read;
 				total_read += bytes_read,current_offset+=bytes_read) {
 		current_read_size = min_t(const int,read_size - total_read,cifs_sb->rsize);
 		rc = -EAGAIN;
 		while(rc == -EAGAIN) {
 			if ((open_file->invalidHandle) && (!open_file->closePend)) {
-				rc = cifs_reopen_file(file->f_dentry->d_inode,file);
+				rc = cifs_reopen_file(file->f_dentry->d_inode,
+					file,TRUE);
 				if(rc != 0)
 					break;
 			}
@@ -1104,7 +1124,8 @@
 		rc = -EAGAIN;
 		while(rc == -EAGAIN) {
 			if ((open_file->invalidHandle) && (!open_file->closePend)) {
-				rc = cifs_reopen_file(file->f_dentry->d_inode,file);
+				rc = cifs_reopen_file(file->f_dentry->d_inode,
+					file, TRUE);
 				if(rc != 0)
 					break;
 			}
@@ -1188,26 +1209,26 @@
 	char * read_data;
 	int rc;
 
-        page_cache_get(page);
-        read_data = kmap(page);
-        /* for reads over a certain size could initiate async read ahead */
+	page_cache_get(page);
+	read_data = kmap(page);
+	/* for reads over a certain size could initiate async read ahead */
                                                                                                                            
-        rc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);
+	rc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);
                                                                                                                            
-        if (rc < 0)
-                goto io_error;
-        else {
-                cFYI(1,("Bytes read %d ",rc));
-        }
+	if (rc < 0)
+		goto io_error;
+	else {
+		cFYI(1,("Bytes read %d ",rc));
+	}
                                                                                                                            
-        file->f_dentry->d_inode->i_atime = CURRENT_TIME;
+	file->f_dentry->d_inode->i_atime = CURRENT_TIME;
                                                                                                                            
-        if(PAGE_CACHE_SIZE > rc) {
-                memset(read_data+rc, 0, PAGE_CACHE_SIZE - rc);
-        }
-        flush_dcache_page(page);
-        SetPageUptodate(page);
-        rc = 0;
+	if(PAGE_CACHE_SIZE > rc) {
+		memset(read_data+rc, 0, PAGE_CACHE_SIZE - rc);
+	}
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	rc = 0;
                                                                                                                            
 io_error:
         kunmap(page);
Index: linux-2.6.5/fs/cifs/inode.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/inode.c	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/inode.c	2004-06-15 11:07:47.000000000 +0200
@@ -442,7 +442,9 @@
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
+	down(&inode->i_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
+	up(&inode->i_sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -499,7 +501,9 @@
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
+	down(&inode->i_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
+	up(&inode->i_sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -548,6 +552,8 @@
                      different share. Might eventually add support for this */
 	}
 
+	/* we already  have the rename sem so we do not need
+	to grab it again here to protect the path integrity */
 	fromName = build_path_from_dentry(source_direntry);
 	toName = build_path_from_dentry(target_direntry);
 	if((fromName == NULL) || (toName == NULL)) {
@@ -558,9 +564,38 @@
 	rc = CIFSSMBRename(xid, pTcon, fromName, toName,
 			   cifs_sb_source->local_nls);
 	if(rc == -EEXIST) {
-		cifs_unlink(target_inode, target_direntry);
-		rc = CIFSSMBRename(xid, pTcon, fromName, toName,
-				   cifs_sb_source->local_nls);
+		/* check if they are the same file 
+		because rename of hardlinked files is a noop */
+		FILE_UNIX_BASIC_INFO * info_buf_source;
+		FILE_UNIX_BASIC_INFO * info_buf_target;
+
+		info_buf_source = 
+			kmalloc(2 * sizeof(FILE_UNIX_BASIC_INFO),GFP_KERNEL);
+		if(info_buf_source != NULL) {
+			info_buf_target = info_buf_source+1;
+			rc = CIFSSMBUnixQPathInfo(xid, pTcon, fromName, 
+				info_buf_source, cifs_sb_source->local_nls);
+			if(rc == 0) {
+				rc = CIFSSMBUnixQPathInfo(xid,pTcon,toName,
+						info_buf_target,
+						cifs_sb_target->local_nls);
+			}
+			if((rc == 0) && 
+				(info_buf_source->UniqueId == 
+				 info_buf_target->UniqueId)) {
+			/* do not rename since the files are hardlinked 
+			   which is a noop */
+			} else {
+			/* we either can not tell the files are hardlinked
+			(as with Windows servers) or files are not hardlinked 
+			so delete the target manually before renaming to
+			follow POSIX rather than Windows semantics */
+				cifs_unlink(target_inode, target_direntry);
+				rc = CIFSSMBRename(xid, pTcon, fromName, toName,
+					cifs_sb_source->local_nls);
+			}
+			kfree(info_buf_source);
+		} /* if we can not get memory just leave rc as EEXIST */
 	}
 
 	if((rc == -EIO)||(rc == -EEXIST)) {
@@ -763,7 +798,9 @@
 	cifs_sb = CIFS_SB(direntry->d_inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
+	down(&direntry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
+	up(&direntry->d_sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
Index: linux-2.6.5/fs/cifs/link.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/link.c	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/link.c	2004-06-15 11:07:47.000000000 +0200
@@ -44,10 +44,13 @@
 	cifs_sb_target = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb_target->tcon;
 
-/* No need to check for cross device links since server will do that - BB note DFS case in future though (when we may have to check) */
+/* No need to check for cross device links since server will do that
+   BB note DFS case in future though (when we may have to check) */
 
+	down(&inode->i_sb->s_vfs_rename_sem);
 	fromName = build_path_from_dentry(old_file);
 	toName = build_path_from_dentry(direntry);
+	up(&inode->i_sb->s_vfs_rename_sem);
 	if((fromName == NULL) || (toName == NULL)) {
 		rc = -ENOMEM;
 		goto cifs_hl_exit;
@@ -96,7 +99,11 @@
 	struct cifsTconInfo *pTcon;
 
 	xid = GetXid();
+
+	down(&direntry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
+	up(&direntry->d_sb->s_vfs_rename_sem);
+
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -159,7 +166,10 @@
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
+	down(&inode->i_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
+	up(&inode->i_sb->s_vfs_rename_sem);
+
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
Index: linux-2.6.5/fs/cifs/transport.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/transport.c	2004-06-15 11:06:18.000000000 +0200
+++ linux-2.6.5/fs/cifs/transport.c	2004-06-15 11:07:47.000000000 +0200
@@ -120,13 +120,13 @@
 	 unsigned int smb_buf_length, struct sockaddr *sin)
 {
 	int rc = 0;
+	int i = 0;
 	struct msghdr smb_msg;
 	struct iovec iov;
 	mm_segment_t temp_fs;
 
 	if(ssocket == NULL)
 		return -ENOTSOCK; /* BB eventually add reconnect code here */
-/*  ssocket->sk->allocation = GFP_BUFFER; *//* BB is this spurious? */
 	iov.iov_base = smb_buffer;
 	iov.iov_len = smb_buf_length + 4;
 
@@ -152,6 +152,14 @@
 	while(iov.iov_len > 0) {
 		rc = sock_sendmsg(ssocket, &smb_msg, smb_buf_length + 4);
 		if ((rc == -ENOSPC) || (rc == -EAGAIN)) {
+			i++;
+			if(i > 60) {
+				cERROR(1,
+				   ("sends on sock %p stuck for 30 seconds",
+				    ssocket));
+				rc = -EAGAIN;
+				break;
+			}
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(HZ/2);
 			continue;
@@ -235,7 +243,7 @@
 			atomic_dec(&ses->server->inFlight); 
 			wake_up(&ses->server->request_q);
 		}
-		return -EIO;
+		return -ENOMEM;
 	}
 
 	if (in_buf->smb_buf_length > CIFS_MAX_MSGSIZE + MAX_CIFS_HDR_SIZE - 4) {
@@ -260,7 +268,17 @@
 	midQ->midState = MID_REQUEST_SUBMITTED;
 	rc = smb_send(ses->server->ssocket, in_buf, in_buf->smb_buf_length,
 		      (struct sockaddr *) &(ses->server->addr.sockAddr));
-	up(&ses->server->tcpSem);
+	if(rc < 0) {
+		DeleteMidQEntry(midQ);
+		up(&ses->server->tcpSem);
+		/* If not lock req, update # of requests on wire to server */
+		if(long_op < 3) {
+			atomic_dec(&ses->server->inFlight); 
+			wake_up(&ses->server->request_q);
+		}
+		return rc;
+	} else
+		up(&ses->server->tcpSem);
 	if (long_op == -1)
 		goto cifs_no_response_exit;
 	else if (long_op == 2) /* writes past end of file can take looooong time */
