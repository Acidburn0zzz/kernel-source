From: Oliver Neukum <oneukum@suse.de>
Subject: reset_resume and autosuspend for appletouch touchpads
Patch-mainline: submitted
References: bnc#388399

This allows the use of usb persist for appletouch devices. It's needed
because X can't deal with hotplug events caused by hibernation.

---

--- linux-2.6.25-rc7-vanilla/drivers/input/mouse/appletouch.c	2008-03-31 15:16:40.000000000 +0200
+++ linux-2.6.25-rc7-work/drivers/input/mouse/appletouch.c	2008-04-03 12:46:24.000000000 +0200
@@ -32,6 +32,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/usb/input.h>
 
 /* Apple has powerbooks which have the keyboard with different Product IDs */
@@ -140,6 +141,7 @@ MODULE_DEVICE_TABLE (usb, atp_table);
 struct atp {
 	char			phys[64];
 	struct usb_device *	udev;		/* usb device */
+	struct usb_interface *	intf;		/* usb interface */
 	struct urb *		urb;		/* usb request block */
 	signed char *		data;		/* transferred data */
 	struct input_dev *	input;		/* input dev */
@@ -158,6 +160,7 @@ struct atp {
 	int			datalen;	/* size of an USB urb transfer */
 	int			idlecount;      /* number of empty packets */
 	struct work_struct      work;
+	struct mutex		lock;
 };
 
 #define dbg_dump(msg, tab) \
@@ -345,6 +348,11 @@ static inline void atp_report_fingers(st
 	input_report_key(input, BTN_TOOL_TRIPLETAP, fingers > 2);
 }
 
+static void atp_mark_busy(struct atp *dev)
+{
+	usb_mark_last_busy(dev->udev);
+}
+
 static void atp_complete(struct urb* urb)
 {
 	int x, y, x_z, y_z, x_f, y_f;
@@ -384,6 +392,9 @@ static void atp_complete(struct urb* urb
 		goto exit;
 	}
 
+	/* mark busy for autosuspend purposes */
+	atp_mark_busy(dev);
+
 	/* reorder the sensors values */
 	if (atp_is_geyser_3(dev)) {
 		memset(dev->xy_cur, 0, sizeof(dev->xy_cur));
@@ -561,21 +572,52 @@ exit:
 static int atp_open(struct input_dev *input)
 {
 	struct atp *dev = input_get_drvdata(input);
+	int rv;
 
-	if (usb_submit_urb(dev->urb, GFP_ATOMIC))
-		return -EIO;
+	mutex_lock(&dev->lock);
+
+	rv = usb_autopm_get_interface(dev->intf);
+	if ( rv < 0)
+		goto err_out;
+
+	rv = usb_submit_urb(dev->urb, GFP_KERNEL);
+	if (rv < 0)
+		goto err_put;
 
 	dev->open = 1;
-	return 0;
+	dev->intf->needs_remote_wakeup = 1;
+
+err_put:
+	usb_autopm_put_interface(dev->intf);
+err_out:
+	mutex_unlock(&dev->lock);
+	return rv;
 }
 
 static void atp_close(struct input_dev *input)
 {
 	struct atp *dev = input_get_drvdata(input);
 
+	mutex_lock(&dev->lock);
 	usb_kill_urb(dev->urb);
 	cancel_work_sync(&dev->work);
 	dev->open = 0;
+	dev->intf->needs_remote_wakeup = 0;
+	mutex_unlock(&dev->lock);
+}
+
+static int handle_geyser(struct atp *dev)
+{
+	struct usb_device *udev = dev->udev;
+
+	if (!atp_is_fountain(dev)) {
+		/* switch to raw sensor mode */
+		if (atp_geyser_init(udev))
+			return -EIO;
+
+		printk(KERN_INFO "appletouch: Geyser mode initialized.\n");
+	}
+	return 0;
 }
 
 static int atp_probe(struct usb_interface *iface, const struct usb_device_id *id)
@@ -612,7 +654,9 @@ static int atp_probe(struct usb_interfac
 		goto err_free_devs;
 	}
 
+	mutex_init(&dev->lock);
 	dev->udev = udev;
+	dev->intf = iface;
 	dev->input = input_dev;
 	dev->overflowwarn = 0;
 	if (atp_is_geyser_3(dev))
@@ -622,13 +666,8 @@ static int atp_probe(struct usb_interfac
 	else
 		dev->datalen = 81;
 
-	if (!atp_is_fountain(dev)) {
-		/* switch to raw sensor mode */
-		if (atp_geyser_init(udev))
-			goto err_free_devs;
-
-		printk(KERN_INFO "appletouch: Geyser mode initialized.\n");
-	}
+	if (handle_geyser(dev) < 0)
+		goto err_free_devs;
 
 	dev->urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!dev->urb)
@@ -747,19 +786,65 @@ static int atp_resume(struct usb_interfa
 {
 	struct atp *dev = usb_get_intfdata(iface);
 
-	if (dev->open && usb_submit_urb(dev->urb, GFP_ATOMIC))
+	if (dev->open && usb_submit_urb(dev->urb, GFP_NOIO))
 		return -EIO;
 
 	return 0;
 }
 
+static int recover_dev(struct atp *dev)
+{
+	int rv;
+
+	rv = handle_geyser(dev);
+	if (rv < 0)
+		return rv;
+
+	if (dev->open && usb_submit_urb(dev->urb, GFP_NOIO))
+		return -EIO;
+
+	return 0;	
+}
+
+static int atp_pre_reset(struct usb_interface *iface)
+{
+	struct atp *dev = usb_get_intfdata(iface);
+
+	mutex_lock(&dev->lock);
+	if (dev->open)
+		usb_kill_urb(dev->urb);
+
+	return 0;
+}
+
+static int atp_post_reset(struct usb_interface *iface)
+{
+	struct atp *dev = usb_get_intfdata(iface);
+	int rv;
+
+	rv = recover_dev(dev);
+	mutex_unlock(&dev->lock);
+	return rv;
+}
+
+static int atp_reset_resume(struct usb_interface *iface)
+{
+	struct atp *dev = usb_get_intfdata(iface);
+
+	return recover_dev(dev);
+}
+
 static struct usb_driver atp_driver = {
 	.name		= "appletouch",
 	.probe		= atp_probe,
 	.disconnect	= atp_disconnect,
 	.suspend	= atp_suspend,
 	.resume		= atp_resume,
+	.reset_resume	= atp_reset_resume,
+	.pre_reset	= atp_pre_reset,
+	.post_reset	= atp_post_reset,
 	.id_table	= atp_table,
+	.supports_autosuspend = 1,
 };
 
 static int __init atp_init(void)

