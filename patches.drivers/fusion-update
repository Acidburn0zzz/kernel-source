diff -urNp linux-2.6.5/drivers/message/fusion/Makefile linux-2.6.5.SUSE/drivers/message/fusion/Makefile
--- linux-2.6.5/drivers/message/fusion/Makefile	2004-04-04 05:37:36.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/message/fusion/Makefile	2004-04-13 17:44:29.000000000 +0200
@@ -22,11 +22,6 @@ EXTRA_CFLAGS += ${MPT_CFLAGS}
 #EXTRA_CFLAGS += -DMPT_DEBUG_MSG_FRAME
 #EXTRA_CFLAGS += -DMPT_DEBUG_SG
 
-# This is a temporary fix for the reply/request fifo
-# for some 64bit archs. Uncommenting this line
-# will place the fifo's in 32bit space
-#EXTRA_CFLAGS += -DMPTBASE_MEM_ALLOC_FIFO_FIX
-
 #
 # driver/module specifics...
 #
diff -urNp linux-2.6.5/drivers/message/fusion/mptbase.c linux-2.6.5.SUSE/drivers/message/fusion/mptbase.c
--- linux-2.6.5/drivers/message/fusion/mptbase.c	2004-04-04 05:36:27.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/message/fusion/mptbase.c	2004-04-13 17:44:29.000000000 +0200
@@ -123,12 +123,6 @@ MODULE_LICENSE("GPL");
 /*
  *  cmd line parameters
  */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,59)
-MODULE_PARM(PortIo, "0-1i");
-MODULE_PARM_DESC(PortIo, "[0]=Use mmap, 1=Use port io");
-#endif
-static int PortIo = 0;
-
 #ifdef MFCNT
 static int mfcounter = 0;
 #define PRINT_MF_COUNT 20000
@@ -269,8 +263,6 @@ struct _mpt_ioc_proc_list {
  */
 
 static struct pci_device_id mptbase_pci_table[] = {
-	{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FC909,
-		PCI_ANY_ID, PCI_ANY_ID },
 	{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FC929,
 		PCI_ANY_ID, PCI_ANY_ID },
 	{ PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FC919,
@@ -287,39 +279,10 @@ static struct pci_device_id mptbase_pci_
 };
 MODULE_DEVICE_TABLE(pci, mptbase_pci_table);
 
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/* 20000207 -sralston
- *  GRRRRR...  IOSpace (port i/o) register access (for the 909) is back!
- * 20000517 -sralston
- *  Let's trying going back to default mmap register access...
- */
-
-static inline u32 CHIPREG_READ32(volatile u32 *a)
-{
-	if (PortIo)
-		return inl((unsigned long)a);
-	else
-		return readl(a);
-}
-
-static inline void CHIPREG_WRITE32(volatile u32 *a, u32 v)
-{
-	if (PortIo)
-		outl(v, (unsigned long)a);
-	else
-		writel(v, a);
-}
-
-static inline void CHIPREG_PIO_WRITE32(volatile u32 *a, u32 v)
-{
-	outl(v, (unsigned long)a);
-}
-
-static inline u32 CHIPREG_PIO_READ32(volatile u32 *a)
-{
-	return inl((unsigned long)a);
-}
+#define CHIPREG_READ32(addr) 		readl(addr)
+#define CHIPREG_WRITE32(addr,val) 	writel(val, addr)
+#define CHIPREG_PIO_WRITE32(addr,val)	outl(val, (unsigned long)addr)
+#define CHIPREG_PIO_READ32(addr) 	inl((unsigned long)addr)
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -1280,17 +1243,12 @@ mptbase_probe(struct pci_dev *pdev, cons
 		return r;
 	}
 
-#if 0
-	/* broken because some code assumes that multiple calls
-	   to pci_alloc_consistent return data in the same 4GB segment. 
-	   This cannot work on machines with enough memory. */
 	if (!pci_set_consistent_dma_mask(pdev, mask))
 		dprintk((KERN_INFO MYNAM
 			": Using 64 bit consistent mask\n"));
 	else
 		dprintk((KERN_INFO MYNAM
 			": Not using 64 bit consistent mask\n"));
-#endif
 
 	ioc = kmalloc(sizeof(MPT_ADAPTER), GFP_ATOMIC);
 	if (ioc == NULL) {
@@ -1304,23 +1262,6 @@ mptbase_probe(struct pci_dev *pdev, cons
 
 	ioc->pcidev = pdev;
 
-#if defined(MPTBASE_MEM_ALLOC_FIFO_FIX)
-	memcpy(&ioc->pcidev32,ioc->pcidev,sizeof(struct pci_dev));
-	if (pci_set_dma_mask(&ioc->pcidev32, 0xFFFFFFFF)) {
-		dprintk((KERN_INFO MYNAM
-			": error setting 32bit mask\n"));
-		kfree(ioc);
-		return -ENODEV;
-	}
-
-	if (pci_set_consistent_dma_mask(&ioc->pcidev32, 0xFFFFFFFF)) {
-		dprintk((KERN_INFO MYNAM
-			": error setting 32bit mask\n"));
-		kfree(ioc);
-		return -ENODEV;
-	}
-#endif
-
 	ioc->diagPending = 0;
 	spin_lock_init(&ioc->diagLock);
 
@@ -1382,32 +1323,24 @@ mptbase_probe(struct pci_dev *pdev, cons
 
 	dprintk((KERN_INFO MYNAM ": MPT adapter @ %lx, msize=%dd bytes\n", mem_phys, msize));
 	dprintk((KERN_INFO MYNAM ": (port i/o @ %lx, psize=%dd bytes)\n", port, psize));
-	dprintk((KERN_INFO MYNAM ": Using %s register access method\n", PortIo ? "PortIo" : "MemMap"));
 
 	mem = NULL;
-	if (! PortIo) {
-		/* Get logical ptr for PciMem0 space */
-		/*mem = ioremap(mem_phys, msize);*/
-		mem = ioremap(mem_phys, 0x100);
-		if (mem == NULL) {
-			printk(KERN_ERR MYNAM ": ERROR - Unable to map adapter memory!\n");
-			kfree(ioc);
-			return -EINVAL;
-		}
-		ioc->memmap = mem;
+	/* Get logical ptr for PciMem0 space */
+	/*mem = ioremap(mem_phys, msize);*/
+	mem = ioremap(mem_phys, 0x100);
+	if (mem == NULL) {
+		printk(KERN_ERR MYNAM ": ERROR - Unable to map adapter memory!\n");
+		kfree(ioc);
+		return -EINVAL;
 	}
+	ioc->memmap = mem;
 	dprintk((KERN_INFO MYNAM ": mem = %p, mem_phys = %lx\n", mem, mem_phys));
 
 	dprintk((KERN_INFO MYNAM ": facts @ %p, pfacts[0] @ %p\n",
 			&ioc->facts, &ioc->pfacts[0]));
-	if (PortIo) {
-		u8 *pmem = (u8*)port;
-		ioc->mem_phys = port;
-		ioc->chip = (SYSIF_REGS*)pmem;
-	} else {
-		ioc->mem_phys = mem_phys;
-		ioc->chip = (SYSIF_REGS*)mem;
-	}
+
+	ioc->mem_phys = mem_phys;
+	ioc->chip = (SYSIF_REGS*)mem;
 
 	/* Save Port IO values incase we need to do downloadboot */
 	{
@@ -1417,11 +1350,7 @@ mptbase_probe(struct pci_dev *pdev, cons
 	}
 
 	ioc->chip_type = FCUNK;
-	if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC909) {
-		ioc->chip_type = FC909;
-		ioc->prod_name = "LSIFC909";
-	}
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC929) {
+	if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC929) {
 		ioc->chip_type = FC929;
 		ioc->prod_name = "LSIFC929";
 	}
@@ -2075,7 +2004,7 @@ static void
 mpt_adapter_disable(MPT_ADAPTER *this, int freeup)
 {
 	if (this != NULL) {
-		int sz;
+		int sz=0;
 		u32 state;
 		int ret;
 
@@ -2100,28 +2029,18 @@ mpt_adapter_disable(MPT_ADAPTER *this, i
 		/* Clear any lingering interrupt */
 		CHIPREG_WRITE32(&this->chip->IntStatus, 0);
 
-		if (freeup && this->reply_alloc != NULL) {
-			sz = (this->reply_sz * this->reply_depth) + 128;
-			pci_free_consistent(this->pcidev, sz,
-					this->reply_alloc, this->reply_alloc_dma);
+		if (freeup && this->fifo_pool != NULL) {
+			pci_free_consistent(this->pcidev,
+				this->fifo_pool_sz,
+				this->fifo_pool, this->fifo_pool_dma);
 			this->reply_frames = NULL;
 			this->reply_alloc = NULL;
-			this->alloc_total -= sz;
-		}
-
-		if (freeup && this->req_alloc != NULL) {
-			sz = (this->req_sz * this->req_depth) + 128;
-			/*
-			 *  Rounding UP to nearest 4-kB boundary here...
-			 */
-			sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
-			pci_free_consistent(this->pcidev, sz,
-					this->req_alloc, this->req_alloc_dma);
 			this->req_frames = NULL;
 			this->req_alloc = NULL;
-			this->alloc_total -= sz;
+			this->chain_alloc = NULL;
+			this->fifo_pool = NULL;
+			this->alloc_total -= this->fifo_pool_sz;
 		}
-
 		if (freeup && this->sense_buf_pool != NULL) {
 			sz = (this->req_depth * MPT_SENSE_BUFFER_ALLOC);
 			pci_free_consistent(this->pcidev, sz,
@@ -2572,10 +2491,10 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 			 * Set values for this IOC's request & reply frame sizes,
 			 * and request & reply queue depths...
 			 */
-			ioc->req_sz = MIN(MPT_DEFAULT_FRAME_SIZE, facts->RequestFrameSize * 4);
-			ioc->req_depth = MIN(MPT_MAX_REQ_DEPTH, facts->GlobalCredits);
+			ioc->req_sz = min(MPT_DEFAULT_FRAME_SIZE, facts->RequestFrameSize * 4);
+			ioc->req_depth = min_t(int, MPT_MAX_REQ_DEPTH, facts->GlobalCredits);
 			ioc->reply_sz = MPT_REPLY_FRAME_SIZE;
-			ioc->reply_depth = MIN(MPT_DEFAULT_REPLY_DEPTH, facts->ReplyQueueDepth);
+			ioc->reply_depth = min_t(int, MPT_DEFAULT_REPLY_DEPTH, facts->ReplyQueueDepth);
 
 			dprintk((MYIOC_s_INFO_FMT "reply_sz=%3d, reply_depth=%4d\n",
 				ioc->name, ioc->reply_sz, ioc->reply_depth));
@@ -3799,105 +3718,126 @@ PrimeIocFifos(MPT_ADAPTER *ioc)
 	unsigned long b;
 	unsigned long flags;
 	dma_addr_t aligned_mem_dma;
-	u8 *mem, *aligned_mem;
+	u8 *aligned_mem;
 	int i, sz;
+	int chain_buffer_sz, reply_buffer_sz, request_buffer_sz;
+	int scale, num_sge, num_chain;
 
-	/*  Prime reply FIFO...  */
+	/* request buffer size,  rounding UP to nearest 4-kB boundary */
+	request_buffer_sz = (ioc->req_sz * ioc->req_depth) + 128;
+	request_buffer_sz = ((request_buffer_sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
 
-	if (ioc->reply_frames == NULL) {
-		sz = (ioc->reply_sz * ioc->reply_depth) + 128;
-#if defined(MPTBASE_MEM_ALLOC_FIFO_FIX)
-		mem = pci_alloc_consistent(&ioc->pcidev32, sz, &ioc->reply_alloc_dma);
-#else		
-		mem = pci_alloc_consistent(ioc->pcidev, sz, &ioc->reply_alloc_dma);
-#endif		
-		if (mem == NULL)
-			goto out_fail;
+	/* reply buffer size */
+	reply_buffer_sz = (ioc->reply_sz * ioc->reply_depth) + 128;
 
-		memset(mem, 0, sz);
-		ioc->alloc_total += sz;
-		ioc->reply_alloc = mem;
-		dprintk((KERN_INFO MYNAM ": %s.reply_alloc  @ %p[%p], sz=%d bytes\n",
-			 	ioc->name, mem, (void *)(ulong)ioc->reply_alloc_dma, sz));
+	/* chain buffer size, copied from from mptscsih_initChainBuffers()
+	 *
+	 * Calculate the number of chain buffers needed(plus 1) per I/O
+	 * then multiply the the maximum number of simultaneous cmds
+	 *
+	 * num_sge = num sge in request frame + last chain buffer
+	 * scale = num sge per chain buffer if no chain element
+	 */
 
-		b = (unsigned long) mem;
-		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
-		aligned_mem = (u8 *) b;
-		ioc->reply_frames = (MPT_FRAME_HDR *) aligned_mem;
-		ioc->reply_frames_dma =
-			(ioc->reply_alloc_dma + (aligned_mem - mem));
+	scale = ioc->req_sz/(sizeof(dma_addr_t) + sizeof(u32));
+	if (sizeof(dma_addr_t) == sizeof(u64))
+		num_sge =  scale + (ioc->req_sz - 60) / (sizeof(dma_addr_t) + sizeof(u32));
+	else
+		num_sge =  1 + scale + (ioc->req_sz - 64) / (sizeof(dma_addr_t) + sizeof(u32));
 
-		ioc->reply_frames_low_dma = (u32) (ioc->reply_frames_dma & 0xFFFFFFFF);
+	num_chain = 1;
+	while (MPT_SCSI_SG_DEPTH - num_sge > 0) {
+		num_chain++;
+		num_sge += (scale - 1);
 	}
+	num_chain++;
 
-	/* Post Reply frames to FIFO
-	 */
-	aligned_mem_dma = ioc->reply_frames_dma;
-	dprintk((KERN_INFO MYNAM ": %s.reply_frames @ %p[%p]\n",
-		 	ioc->name, ioc->reply_frames, (void *)(ulong)aligned_mem_dma));
+	if ((int)ioc->chip_type > (int) FC929)
+		num_chain *= MPT_SCSI_CAN_QUEUE;
+	else
+		num_chain *= MPT_FC_CAN_QUEUE;
 
-	for (i = 0; i < ioc->reply_depth; i++) {
-		/*  Write each address to the IOC!  */
-		CHIPREG_WRITE32(&ioc->chip->ReplyFifo, aligned_mem_dma);
-		aligned_mem_dma += ioc->reply_sz;
-	}
+	chain_buffer_sz = num_chain * ioc->req_sz;
 
+	if(ioc->fifo_pool == NULL) {
 
-	/*  Request FIFO - WE manage this!  */
+		ioc->fifo_pool_sz = request_buffer_sz +
+			reply_buffer_sz + chain_buffer_sz;
 
-	if (ioc->req_frames == NULL) {
-		sz = (ioc->req_sz * ioc->req_depth) + 128;
-		/*
-		 *  Rounding UP to nearest 4-kB boundary here...
-		 */
-		sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
+		ioc->fifo_pool = pci_alloc_consistent(ioc->pcidev,
+		ioc->fifo_pool_sz, &ioc->fifo_pool_dma);
 
-#if defined(MPTBASE_MEM_ALLOC_FIFO_FIX)
-		mem = pci_alloc_consistent(&ioc->pcidev32, sz, &ioc->req_alloc_dma);
-#else
-		mem = pci_alloc_consistent(ioc->pcidev, sz, &ioc->req_alloc_dma);
-#endif		
-		if (mem == NULL)
+		if( ioc->fifo_pool == NULL)
 			goto out_fail;
 
-		memset(mem, 0, sz);
-		ioc->alloc_total += sz;
-		ioc->req_alloc = mem;
+		ioc->alloc_total += ioc->fifo_pool_sz;
+		memset(ioc->fifo_pool, 0, ioc->fifo_pool_sz);
+
+		/* reply fifo pointers */
+		ioc->reply_alloc = ioc->fifo_pool;
+		ioc->reply_alloc_dma = ioc->fifo_pool_dma;
+		/* request fifo pointers */
+		ioc->req_alloc = ioc->reply_alloc+reply_buffer_sz;
+		ioc->req_alloc_dma = ioc->reply_alloc_dma+reply_buffer_sz;
+		/* chain buffer pointers */
+		ioc->chain_alloc = ioc->req_alloc+request_buffer_sz;
+		ioc->chain_alloc_dma = ioc->req_alloc_dma+request_buffer_sz;
+		ioc->chain_alloc_sz = chain_buffer_sz;
+
+		/*  Prime reply FIFO...  */
+		dprintk((KERN_INFO MYNAM ": %s.reply_alloc  @ %p[%p], sz=%d bytes\n",
+			 	ioc->name, mem, (void *)(ulong)ioc->reply_alloc_dma, reply_buffer_sz));
+
+		b = (unsigned long) ioc->reply_alloc;
+		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
+		aligned_mem = (u8 *) b;
+		ioc->reply_frames = (MPT_FRAME_HDR *) aligned_mem;
+		ioc->reply_frames_dma =
+			(ioc->reply_alloc_dma + (aligned_mem - ioc->reply_alloc));
+
+		ioc->reply_frames_low_dma = (u32) (ioc->reply_frames_dma & 0xFFFFFFFF);
+	
+		/*  Request FIFO - WE manage this!  */
 		dprintk((KERN_INFO MYNAM ": %s.req_alloc    @ %p[%p], sz=%d bytes\n",
-			 	ioc->name, mem, (void *)(ulong)ioc->req_alloc_dma, sz));
+			 	ioc->name, mem, (void *)(ulong)ioc->req_alloc_dma, request_buffer_sz));
 
-		b = (unsigned long) mem;
+		b = (unsigned long) ioc->req_alloc;
 		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
 		aligned_mem = (u8 *) b;
 		ioc->req_frames = (MPT_FRAME_HDR *) aligned_mem;
 		ioc->req_frames_dma =
-			(ioc->req_alloc_dma + (aligned_mem - mem));
+			(ioc->req_alloc_dma + (aligned_mem - ioc->req_alloc));
 
 		ioc->req_frames_low_dma = (u32) (ioc->req_frames_dma & 0xFFFFFFFF);
 
-		if (sizeof(dma_addr_t) == sizeof(u64)) {
-			/* Check: upper 32-bits of the request and reply frame
-			 * physical addresses must be the same.
-			 */
-			if (((u64)ioc->req_frames_dma >> 32) != ((u64)ioc->reply_frames_dma >> 32)){
-				goto out_fail;
-			}
-		}
-
 #if defined(CONFIG_MTRR) && 0
 		/*
 		 *  Enable Write Combining MTRR for IOC's memory region.
 		 *  (at least as much as we can; "size and base must be
 		 *  multiples of 4 kiB"
 		 */
-		ioc->mtrr_reg = mtrr_add(ioc->req_alloc_dma,
-					 sz,
+		ioc->mtrr_reg = mtrr_add(ioc->fifo_pool,
+					 ioc->fifo_pool_sz,
 					 MTRR_TYPE_WRCOMB, 1);
 		dprintk((MYIOC_s_INFO_FMT "MTRR region registered (base:size=%08x:%x)\n",
-				ioc->name, ioc->req_alloc_dma, sz));
+				ioc->name, ioc->fifo_pool, ioc->fifo_pool_sz));
 #endif
+
+	} /* ioc->fifo_pool == NULL */
+	
+	/* Post Reply frames to FIFO
+	 */
+	aligned_mem_dma = ioc->reply_frames_dma;
+	dprintk((KERN_INFO MYNAM ": %s.reply_frames @ %p[%p]\n",
+		 	ioc->name, ioc->reply_frames, (void *)(ulong)aligned_mem_dma));
+
+	for (i = 0; i < ioc->reply_depth; i++) {
+		/*  Write each address to the IOC!  */
+		CHIPREG_WRITE32(&ioc->chip->ReplyFifo, aligned_mem_dma);
+		aligned_mem_dma += ioc->reply_sz;
 	}
 
+
 	/* Initialize Request frames linked list
 	 */
 	aligned_mem_dma = ioc->req_frames_dma;
@@ -3931,24 +3871,17 @@ PrimeIocFifos(MPT_ADAPTER *ioc)
 	return 0;
 
 out_fail:
-	if (ioc->reply_alloc != NULL) {
-		sz = (ioc->reply_sz * ioc->reply_depth) + 128;
+	if (ioc->fifo_pool != NULL) {
 		pci_free_consistent(ioc->pcidev,
-				sz,
-				ioc->reply_alloc, ioc->reply_alloc_dma);
+				ioc->fifo_pool_sz,
+				ioc->fifo_pool, ioc->fifo_pool_dma);
 		ioc->reply_frames = NULL;
 		ioc->reply_alloc = NULL;
-		ioc->alloc_total -= sz;
-	}
-	if (ioc->req_alloc != NULL) {
-		sz = (ioc->req_sz * ioc->req_depth) + 128;
-		/*
-		 *  Rounding UP to nearest 4-kB boundary here...
-		 */
-		sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
-		pci_free_consistent(ioc->pcidev,
-				sz,
-				ioc->req_alloc, ioc->req_alloc_dma);
+		ioc->req_frames = NULL;
+		ioc->req_alloc = NULL;
+		ioc->chain_alloc = NULL;
+		ioc->fifo_pool = NULL;
+		ioc->alloc_total -= ioc->fifo_pool_sz;
 #if defined(CONFIG_MTRR) && 0
 		if (ioc->mtrr_reg > 0) {
 			mtrr_del(ioc->mtrr_reg, 0, 0);
@@ -3956,9 +3889,6 @@ out_fail:
 					ioc->name));
 		}
 #endif
-		ioc->req_frames = NULL;
-		ioc->req_alloc = NULL;
-		ioc->alloc_total -= sz;
 	}
 	if (ioc->sense_buf_pool != NULL) {
 		sz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);
@@ -4070,7 +4000,7 @@ mpt_handshake_req_reply_wait(MPT_ADAPTER
 		/*
 		 * Copy out the cached reply...
 		 */
-		for (ii=0; ii < MIN(replyBytes/2,mptReply->MsgLength*2); ii++)
+		for (ii=0; ii < min(replyBytes/2,mptReply->MsgLength*2); ii++)
 			u16reply[ii] = ioc->hs_reply[ii];
 	} else {
 		return -99;
@@ -4317,7 +4247,7 @@ GetLanConfigPages(MPT_ADAPTER *ioc)
 
 			if ((rc = mpt_config(ioc, &cfg)) == 0) {
 				/* save the data */
-				copy_sz = MIN(sizeof(LANPage0_t), data_sz);
+				copy_sz = min_t(int, sizeof(LANPage0_t), data_sz);
 				memcpy(&ioc->lan_cnfg_page0, ppage0_alloc, copy_sz);
 
 			}
@@ -4362,7 +4292,7 @@ GetLanConfigPages(MPT_ADAPTER *ioc)
 
 		if ((rc = mpt_config(ioc, &cfg)) == 0) {
 			/* save the data */
-			copy_sz = MIN(sizeof(LANPage1_t), data_sz);
+			copy_sz = min_t(int, sizeof(LANPage1_t), data_sz);
 			memcpy(&ioc->lan_cnfg_page1, ppage1_alloc, copy_sz);
 		}
 
@@ -4431,7 +4361,7 @@ GetFcPortPage0(MPT_ADAPTER *ioc, int por
 		if ((rc = mpt_config(ioc, &cfg)) == 0) {
 			/* save the data */
 			pp0dest = &ioc->fc_port_page0[portnum];
-			copy_sz = MIN(sizeof(FCPortPage0_t), data_sz);
+			copy_sz = min_t(int, sizeof(FCPortPage0_t), data_sz);
 			memcpy(pp0dest, ppage0_alloc, copy_sz);
 
 			/*
@@ -5517,9 +5447,7 @@ procmpt_destroy(void)
 			(void) sprintf(pname+namelen, "/%s", mpt_ioc_proc_list[ii].name);
 			remove_proc_entry(pname, NULL);
 		}
-
 		remove_proc_entry(ioc->name, mpt_proc_root_dir);
-
 		ioc = mpt_adapter_find_next(ioc);
 	}
 
@@ -6329,7 +6257,6 @@ fusion_exit(void)
 {
 
 	dprintk((KERN_INFO MYNAM ": fusion_exit() called!\n"));
-	pci_unregister_driver(&mptbase_driver);
 
 	/* Whups?  20010120 -sralston
 	 *  Moved this *above* removal of all MptAdapters!
@@ -6337,7 +6264,7 @@ fusion_exit(void)
 #ifdef CONFIG_PROC_FS
 	(void) procmpt_destroy();
 #endif
-
+	pci_unregister_driver(&mptbase_driver);
 	mpt_reset_deregister(mpt_base_index);
 }
 
diff -urNp linux-2.6.5/drivers/message/fusion/mptbase.h linux-2.6.5.SUSE/drivers/message/fusion/mptbase.h
--- linux-2.6.5/drivers/message/fusion/mptbase.h	2004-04-04 05:36:25.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/message/fusion/mptbase.h	2004-04-13 17:44:29.000000000 +0200
@@ -81,8 +81,8 @@
 #define COPYRIGHT	"Copyright (c) 1999-2004 " MODULEAUTHOR
 #endif
 
-#define MPT_LINUX_VERSION_COMMON	"3.01.01"
-#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-3.01.01"
+#define MPT_LINUX_VERSION_COMMON	"3.01.03"
+#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-3.01.03"
 #define WHAT_MAGIC_STRING		"@" "(" "#" ")"
 
 #define show_mptmod_ver(s,ver)  \
@@ -156,6 +156,28 @@
 #define C0_1030				0x08
 #define XL_929				0x01
 
+
+/*
+ *	Try to keep these at 2^N-1
+ */
+#define MPT_FC_CAN_QUEUE	127
+#define MPT_SCSI_CAN_QUEUE	127
+
+/*
+ * Set the MAX_SGE value based on user input.
+ */
+#ifdef  CONFIG_FUSION_MAX_SGE
+#if     CONFIG_FUSION_MAX_SGE  < 16
+#define MPT_SCSI_SG_DEPTH	16
+#elif   CONFIG_FUSION_MAX_SGE  > 128
+#define MPT_SCSI_SG_DEPTH	128
+#else
+#define MPT_SCSI_SG_DEPTH	CONFIG_FUSION_MAX_SGE
+#endif
+#else
+#define MPT_SCSI_SG_DEPTH	40
+#endif
+
 #ifdef __KERNEL__	/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
@@ -581,6 +603,12 @@ typedef struct _MPT_ADAPTER
 	int			 alloc_total;
 	u32			 last_state;
 	int			 active;
+	u8			*fifo_pool;	/* dma pool for fifo's */
+	dma_addr_t		 fifo_pool_dma;
+	int			 fifo_pool_sz;	/* allocated size */
+	u8			*chain_alloc;	/* chain buffer alloc ptr */
+	dma_addr_t		chain_alloc_dma;
+	int			chain_alloc_sz;
 	u8			*reply_alloc;	/* Reply frames alloc ptr */
 	dma_addr_t		 reply_alloc_dma;
 	MPT_FRAME_HDR		*reply_frames;	/* Reply msg frames - rounded up! */
@@ -608,9 +636,6 @@ typedef struct _MPT_ADAPTER
 	u32			 sense_buf_low_dma;
 	int			 mtrr_reg;
 	struct pci_dev		*pcidev;	/* struct pci_dev pointer */
-#if defined(MPTBASE_MEM_ALLOC_FIFO_FIX)
-	struct pci_dev		pcidev32;	/* struct pci_dev pointer */
-#endif	
 	u8			*memmap;	/* mmap address */
 	struct Scsi_Host	*sh;		/* Scsi Host pointer */
 	ScsiCfgData		spi_data;	/* Scsi config. data */
@@ -1061,13 +1086,6 @@ extern int		  mpt_ASCQ_TableSz;
 /*
  *  More (public) macros...
  */
-#ifndef MIN
-#define MIN(a, b)   (((a) < (b)) ? (a) : (b))
-#endif
-#ifndef MAX
-#define MAX(a, b)   (((a) > (b)) ? (a) : (b))
-#endif
-
 #ifndef offsetof
 #define offsetof(t, m)	((size_t) (&((t *)0)->m))
 #endif
diff -urNp linux-2.6.5/drivers/message/fusion/mptctl.c linux-2.6.5.SUSE/drivers/message/fusion/mptctl.c
--- linux-2.6.5/drivers/message/fusion/mptctl.c	2004-04-04 05:36:15.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/message/fusion/mptctl.c	2004-04-13 17:44:29.000000000 +0200
@@ -285,7 +285,7 @@ mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME
 				dctlprintk((MYIOC_s_INFO_FMT ": Copying Reply Frame @%p to IOC!\n",
 						ioc->name, reply));
 				memcpy(ioc->ioctl->ReplyFrame, reply,
-					MIN(ioc->reply_sz, 4*reply->u.reply.MsgLength));
+					min(ioc->reply_sz, 4*reply->u.reply.MsgLength));
 				ioc->ioctl->status |= MPT_IOCTL_STATUS_RF_VALID;
 
 				/* Set the command status to GOOD if IOC Status is GOOD
@@ -336,7 +336,7 @@ mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME
 			// NOTE: Expects/requires non-Turbo reply!
 			dctlprintk((MYIOC_s_INFO_FMT ":Caching MPI_FUNCTION_FW_DOWNLOAD reply!\n",
 				ioc->name));
-			memcpy(fwReplyBuffer, reply, MIN(sizeof(fwReplyBuffer), 4*reply->u.reply.MsgLength));
+			memcpy(fwReplyBuffer, reply, min_t(int, sizeof(fwReplyBuffer), 4*reply->u.reply.MsgLength));
 			ReplyMsg = (pMPIDefaultReply_t) fwReplyBuffer;
 		}
 	}
@@ -991,7 +991,7 @@ kbuf_alloc_2_sgl(int bytes, u32 sgdir, i
 	MptSge_t	*sgl;
 	int		 numfrags = 0;
 	int		 fragcnt = 0;
-	int		 alloc_sz = MIN(bytes,MAX_KMALLOC_SZ);	// avoid kernel warning msg!
+	int		 alloc_sz = min(bytes,MAX_KMALLOC_SZ);	// avoid kernel warning msg!
 	int		 bytes_allocd = 0;
 	int		 this_alloc;
 	dma_addr_t	 pa;					// phys addr
@@ -1036,7 +1036,7 @@ kbuf_alloc_2_sgl(int bytes, u32 sgdir, i
 	sgl = sglbuf;
 	sg_spill = ((ioc->req_sz - sge_offset)/(sizeof(dma_addr_t) + sizeof(u32))) - 1;
 	while (bytes_allocd < bytes) {
-		this_alloc = MIN(alloc_sz, bytes-bytes_allocd);
+		this_alloc = min(alloc_sz, bytes-bytes_allocd);
 		buflist[buflist_ent].len = this_alloc;
 		buflist[buflist_ent].kptr = pci_alloc_consistent(ioc->pcidev,
 								 this_alloc,
@@ -2293,9 +2293,9 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 		 */
 		if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
 			if (karg.maxReplyBytes < ioc->reply_sz) {
-				 sz = MIN(karg.maxReplyBytes, 4*ioc->ioctl->ReplyFrame[2]);
+				 sz = min(karg.maxReplyBytes, 4*ioc->ioctl->ReplyFrame[2]);
 			} else {
-				 sz = MIN(ioc->reply_sz, 4*ioc->ioctl->ReplyFrame[2]);
+				 sz = min(ioc->reply_sz, 4*ioc->ioctl->ReplyFrame[2]);
 			}
 
 			if (sz > 0) {
@@ -2314,7 +2314,7 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 		/* If valid sense data, copy to user.
 		 */
 		if (ioc->ioctl->status & MPT_IOCTL_STATUS_SENSE_VALID) {
-			sz = MIN(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
+			sz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
 			if (sz > 0) {
 				if (copy_to_user((char *)karg.senseDataPtr, ioc->ioctl->sense, sz)) {
 					printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
diff -urNp linux-2.6.5/drivers/message/fusion/mptscsih.c linux-2.6.5.SUSE/drivers/message/fusion/mptscsih.c
--- linux-2.6.5/drivers/message/fusion/mptscsih.c	2004-04-04 05:38:28.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/message/fusion/mptscsih.c	2004-04-13 17:44:29.000000000 +0200
@@ -196,8 +196,9 @@ static int	mptscsih_doDv(MPT_SCSI_HOST *
 static void	mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVPARAMETERS *dv,void *pPage);
 static void	mptscsih_fillbuf(char *buffer, int size, int index, int width);
 #endif
+#ifdef MODULE
 static int	mptscsih_setup(char *str);
-
+#endif
 /* module entry point */
 static int  __init   mptscsih_init  (void);
 static void __exit   mptscsih_exit  (void);
@@ -1061,26 +1062,6 @@ search_doneQ_for_cmd(MPT_SCSI_HOST *hd, 
 	return;
 }
 
-static void
-mptscsih_reset_timeouts (MPT_SCSI_HOST *hd)
-{
-	Scsi_Cmnd	*SCpnt;
-	int		 ii;
-	int		 max = hd->ioc->req_depth;
-		
-
-	for (ii= 0; ii < max; ii++) {
-		if ((SCpnt = hd->ScsiLookup[ii]) != NULL) {
-	/* calling mod_timer() panics in 2.6 kernel...
-	 * need to investigate
-	 */
-//			mod_timer(&SCpnt->eh_timeout, jiffies + (HZ * 60));
-			dtmprintk((MYIOC_s_WARN_FMT "resetting SCpnt=%p timeout + 60HZ",
-				(hd && hd->ioc) ? hd->ioc->name : "ioc?", SCpnt));
-		}
-	}
-}
-
 /*
  *	mptscsih_flush_running_cmds - For each command found, search
  *		Scsi_Host instance taskQ and reply to OS.
@@ -1239,6 +1220,16 @@ mptscsih_initChainBuffers (MPT_SCSI_HOST
 	int		sz, ii, num_chain;
 	int 		scale, num_sge;
 
+	/* chain buffer allocation done from PrimeIocFifos */	
+	if (hd->ioc->fifo_pool == NULL) 
+		return -1;
+	
+	hd->ChainBuffer = hd->ioc->chain_alloc;
+	hd->ChainBufferDMA = hd->ioc->chain_alloc_dma;
+	
+	dprintk((KERN_INFO "  ChainBuffer    @ %p(%p), sz=%d\n",
+		 hd->ChainBuffer, (void *)(ulong)hd->ChainBufferDMA, hd->ioc->chain_alloc_sz));
+		
 	/* ReqToChain size must equal the req_depth
 	 * index = req_idx
 	 */
@@ -1294,26 +1285,7 @@ mptscsih_initChainBuffers (MPT_SCSI_HOST
 		mem = (u8 *) hd->ChainToChain;
 	}
 	memset(mem, 0xFF, sz);
-	sz = num_chain * hd->ioc->req_sz;
-	if (hd->ChainBuffer == NULL) {
-		/* Allocate free chain buffer pool
-		 */
-#if defined(MPTBASE_MEM_ALLOC_FIFO_FIX)
-		mem = pci_alloc_consistent(&hd->ioc->pcidev32, sz, &hd->ChainBufferDMA);
-#else		
-		mem = pci_alloc_consistent(hd->ioc->pcidev, sz, &hd->ChainBufferDMA);
-#endif		
-		if (mem == NULL)
-			return -1;
 
-		hd->ChainBuffer = (u8*)mem;
-	} else {
-		mem = (u8 *) hd->ChainBuffer;
-	}
-	memset(mem, 0, sz);
-
-	dprintk((KERN_INFO "  ChainBuffer    @ %p(%p), sz=%d\n",
-		 hd->ChainBuffer, (void *)(ulong)hd->ChainBufferDMA, sz));
 
 	/* Initialize the free chain Q.
 	 */
@@ -1366,8 +1338,8 @@ mptscsih_report_queue_full(Scsi_Cmnd *sc
 
 		if (sc->device && sc->device->host != NULL && sc->device->host->hostdata != NULL)
 			ioc_str = ((MPT_SCSI_HOST *)sc->device->host->hostdata)->ioc->name;
-		printk(MYIOC_s_WARN_FMT "Device (%d:%d:%d) reported QUEUE_FULL!\n",
-				ioc_str, 0, sc->device->id, sc->device->lun);
+		dprintk((MYIOC_s_WARN_FMT "Device (%d:%d:%d) reported QUEUE_FULL!\n",
+				ioc_str, 0, sc->device->id, sc->device->lun));
 		last_queue_full = time;
 	}
 }
@@ -1761,7 +1733,6 @@ mptscsih_remove(struct pci_dev *pdev)
 		int sz1, sz2, sz3, sztarget=0;
 		int szr2chain = 0;
 		int szc2chain = 0;
-		int szchain = 0;
 		int szQ = 0;
 
 		mptscsih_shutdown(&pdev->dev);
@@ -1786,15 +1757,6 @@ mptscsih_remove(struct pci_dev *pdev)
 			hd->ChainToChain = NULL;
 		}
 
-		if (hd->ChainBuffer != NULL) {
-			sz2 = hd->num_chain * hd->ioc->req_sz;
-			szchain = szr2chain + szc2chain + sz2;
-
-			pci_free_consistent(hd->ioc->pcidev, sz2,
-				    hd->ChainBuffer, hd->ChainBufferDMA);
-			hd->ChainBuffer = NULL;
-		}
-
 		if (hd->memQ != NULL) {
 			szQ = host->can_queue * sizeof(MPT_DONE_Q);
 			kfree(hd->memQ);
@@ -3375,7 +3337,7 @@ mptscsih_slave_destroy(Scsi_Device *devi
 					raid_volume==0;i++)
 						
 					if(device->id == 
-					  hd->ioc->spi_data.pIocPg3->PhysDisk[i].PhysDiskNum) {
+					  hd->ioc->spi_data.pIocPg3->PhysDisk[i].PhysDiskID) {
 						raid_volume=1;
 						hd->ioc->spi_data.forceDv |=
 						  MPT_SCSICFG_RELOAD_IOC_PG3;
@@ -3706,8 +3668,6 @@ mptscsih_ioc_reset(MPT_ADAPTER *ioc, int
 		 */
 		hd->resetPending = 1;
 
-		mptscsih_reset_timeouts (hd);
-	
 	} else if (reset_phase == MPT_IOC_PRE_RESET) {
 		dtmprintk((MYIOC_s_WARN_FMT "Pre-Diag Reset\n", ioc->name));
 
@@ -4519,7 +4479,7 @@ void mptscsih_setTargetNegoParms(MPT_SCS
 					if (nfactor < pspi_data->minSyncFactor )
 						nfactor = pspi_data->minSyncFactor;
 
-					factor = MAX (factor, nfactor);
+					factor = max(factor, nfactor);
 					if (factor == MPT_ASYNC)
 						offset = 0;
 				} else {
@@ -4727,7 +4687,7 @@ mptscsih_writeSDP1(MPT_SCSI_HOST *hd, in
 		maxid = ioc->sh->max_id - 1;
 	} else if (ioc->sh) {
 		id = target_id;
-		maxid = MIN(id, ioc->sh->max_id - 1);
+		maxid = min_t(int, id, ioc->sh->max_id - 1);
 	}
 
 	for (; id <= maxid; id++) {
@@ -5134,7 +5094,7 @@ mptscsih_scandv_complete(MPT_ADAPTER *io
 				sense_data = ((u8 *)hd->ioc->sense_buf_pool +
 					(req_idx * MPT_SENSE_BUFFER_ALLOC));
 
-				sz = MIN (pReq->SenseBufferLength,
+				sz = min_t(int, pReq->SenseBufferLength,
 							SCSI_STD_SENSE_BYTES);
 				memcpy(hd->pLocal->sense, sense_data, sz);
 
@@ -5786,7 +5746,7 @@ mptscsih_domainValidation(void *arg)
 				ioc->spi_data.forceDv &= ~MPT_SCSICFG_RELOAD_IOC_PG3;
 			}
 
-			maxid = MIN (ioc->sh->max_id, MPT_MAX_SCSI_DEVICES);
+			maxid = min_t(int, ioc->sh->max_id, MPT_MAX_SCSI_DEVICES);
 
 			for (id = 0; id < maxid; id++) {
 				spin_lock_irqsave(&dvtaskQ_lock, flags);
@@ -6509,7 +6469,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int bus
 	if (echoBufSize > 0) {
 		iocmd.flags |= MPT_ICFLAG_ECHO;
 		if (dataBufSize > 0)
-			bufsize = MIN(echoBufSize, dataBufSize);
+			bufsize = min(echoBufSize, dataBufSize);
 		else
 			bufsize = echoBufSize;
 	} else if (dataBufSize == 0)
@@ -6520,7 +6480,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int bus
 
 	/* Data buffers for write-read-compare test max 1K.
 	 */
-	sz = MIN(bufsize, 1024);
+	sz = min(bufsize, 1024);
 
 	/* --- loop ----
 	 * On first pass, always issue a reserve.
@@ -6875,9 +6835,9 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 		}
 
 		/* limit by adapter capabilities */
-		width = MIN(width, hd->ioc->spi_data.maxBusWidth);
-		offset = MIN(offset, hd->ioc->spi_data.maxSyncOffset);
-		factor = MAX(factor, hd->ioc->spi_data.minSyncFactor);
+		width = min(width, hd->ioc->spi_data.maxBusWidth);
+		offset = min(offset, hd->ioc->spi_data.maxSyncOffset);
+		factor = max(factor, hd->ioc->spi_data.minSyncFactor);
 
 		/* Check Consistency */
 		if (offset && (factor < MPT_ULTRA2) && !width)
@@ -7217,19 +7177,22 @@ mptscsih_fillbuf(char *buffer, int size,
 #define	ARG_SEP	','
 #endif
 
+#ifdef MODULE
 static char setup_token[] __initdata =
 	"dv:"
 	"width:"
 	"factor:"
 	"saf-te:"
        ;	/* DO NOT REMOVE THIS ';' */
-
+#endif
+       
 #define OPT_DV			1
 #define OPT_MAX_WIDTH		2
 #define OPT_MIN_SYNC_FACTOR	3
 #define OPT_SAF_TE		4
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+#ifdef MODULE
 static int
 get_setup_token(char *p)
 {
@@ -7298,7 +7261,7 @@ mptscsih_setup(char *str)
 	}
 	return 1;
 }
-
+#endif
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 
diff -urNp linux-2.6.5/drivers/message/fusion/mptscsih.h linux-2.6.5.SUSE/drivers/message/fusion/mptscsih.h
--- linux-2.6.5/drivers/message/fusion/mptscsih.h	2004-04-04 05:38:25.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/message/fusion/mptscsih.h	2004-04-13 17:44:29.000000000 +0200
@@ -66,12 +66,6 @@
  *	SCSI Public stuff...
  */
 
-/*
- *	Try to keep these at 2^N-1
- */
-#define MPT_FC_CAN_QUEUE	127
-#define MPT_SCSI_CAN_QUEUE	127
-
 #define MPT_SCSI_CMD_PER_DEV_HIGH	31
 #define MPT_SCSI_CMD_PER_DEV_LOW	7
 
@@ -79,21 +73,6 @@
 
 #define MPT_SCSI_MAX_SECTORS    8192
 
-/*
- * Set the MAX_SGE value based on user input.
- */
-#ifdef  CONFIG_FUSION_MAX_SGE
-#if     CONFIG_FUSION_MAX_SGE  < 16
-#define MPT_SCSI_SG_DEPTH	16
-#elif   CONFIG_FUSION_MAX_SGE  > 128
-#define MPT_SCSI_SG_DEPTH	128
-#else
-#define MPT_SCSI_SG_DEPTH	CONFIG_FUSION_MAX_SGE
-#endif
-#else
-#define MPT_SCSI_SG_DEPTH	40
-#endif
-
 /* To disable domain validation, uncomment the
  * following line. No effect for FC devices.
  * For SCSI devices, driver will negotiate to
