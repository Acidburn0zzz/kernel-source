From: Alex Aizman <itn780@yahoo.com>
Subject: open-iscsi update

Update to open-iscsi svn 446.

Signed-off-by: Hannes Reinecke <hare@suse.de>

--- linux-2.6.14/drivers/scsi/iscsi_tcp.c	2005-12-19 09:22:05.652434516 +0100
+++ open-iscsi/kernel/iscsi_tcp.c	2005-12-19 09:33:45.000000000 +0100
@@ -536,6 +536,22 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, s
 	return 0;
 }
 
+static void
+iscsi_reject_rsp(struct iscsi_conn *conn)
+{
+	/* FIXME: implement! */
+	printk(KERN_ERR "iscsi: reject PDU received!\n");
+	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+}
+
+static void
+iscsi_async_event_rsp(struct iscsi_conn *conn)
+{
+	/* FIXME: implement! */
+	printk(KERN_ERR "iscsi: async event PDU received!\n");
+	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+}
+
 static int
 iscsi_hdr_recv(struct iscsi_conn *conn)
 {
@@ -686,7 +702,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 		switch(conn->in.opcode) {
 		case ISCSI_OP_LOGIN_RSP:
 		case ISCSI_OP_TEXT_RSP:
-		case ISCSI_OP_LOGOUT_RSP: 
+		case ISCSI_OP_LOGOUT_RSP:
 			rc = iscsi_check_assign_cmdsn(session,
 						 (struct iscsi_nopin*)hdr);
 			if (rc)
@@ -727,12 +743,12 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 			}
 			spin_unlock(&session->lock);
 			break;
-		case ISCSI_OP_NOOP_IN: 
+		case ISCSI_OP_NOOP_IN:
 			if (hdr->ttt != ISCSI_RESERVED_TAG) {
 				rc = ISCSI_ERR_PROTO;
 				break;
 			}
-			rc = iscsi_check_assign_cmdsn(session, 
+			rc = iscsi_check_assign_cmdsn(session,
 						(struct iscsi_nopin*)hdr);
 			if (rc)
 				break;
@@ -767,14 +783,14 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 				if (!rc && hdr->ttt != ISCSI_RESERVED_TAG)
 					rc = iscsi_recv_pdu(iscsi_handle(conn),
 							    hdr, NULL, 0);
-			} else 
+			} else
 				rc = ISCSI_ERR_PROTO;
 			break;
 		case ISCSI_OP_REJECT:
-			/* we need sth like iscsi_reject_rsp()*/
+			iscsi_reject_rsp(conn);
+			break;
 		case ISCSI_OP_ASYNC_EVENT:
-			/* we need sth like iscsi_async_event_rsp() */
-			rc = ISCSI_ERR_BAD_OPCODE;
+			iscsi_async_event_rsp(conn);
 			break;
 		default:
 			rc = ISCSI_ERR_BAD_OPCODE;
@@ -929,7 +945,7 @@ static int iscsi_scsi_data_in(struct isc
 				      sc->request_bufflen, ctask->data_offset);
 		if (rc == -EAGAIN)
 			return rc;
-		if (conn->datadgst_en) 
+		if (conn->datadgst_en)
 			iscsi_recv_digest_update(conn, sc->request_buffer, i);
 		rc = 0;
 		goto done;
@@ -1024,7 +1040,7 @@ iscsi_data_recv(struct iscsi_conn *conn)
 		conn->in.hdr = &conn->hdr;
 		conn->senselen = (conn->data[0] << 8) | conn->data[1];
 		rc = iscsi_cmd_rsp(conn, conn->in.ctask);
-		if (!rc && conn->datadgst_en) 
+		if (!rc && conn->datadgst_en)
 			iscsi_recv_digest_update(conn, conn->data,
 						 conn->in.datalen);
 	}
@@ -1051,7 +1067,7 @@ iscsi_data_recv(struct iscsi_conn *conn)
 		rc = iscsi_recv_pdu(iscsi_handle(conn), conn->in.hdr,
 				    conn->data, conn->in.datalen);
 
-		if (!rc && conn->datadgst_en && 
+		if (!rc && conn->datadgst_en &&
 			conn->in.opcode != ISCSI_OP_LOGIN_RSP)
 			iscsi_recv_digest_update(conn, conn->data,
 			  			conn->in.datalen);
@@ -1680,7 +1696,7 @@ iscsi_cmd_init(struct iscsi_conn *conn, 
 		zero_data(ctask->hdr.dlength);
 	}
 
-	iscsi_buf_init_virt(&ctask->headbuf, (char*)&ctask->hdr, 
+	iscsi_buf_init_virt(&ctask->headbuf, (char*)&ctask->hdr,
 			    sizeof(struct iscsi_hdr));
 	conn->scsicmd_pdus_cnt++;
 }
@@ -1746,7 +1762,7 @@ static inline int
 handle_xmstate_r_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	ctask->xmstate &= ~XMSTATE_R_HDR;
-	if (conn->hdrdgst_en) 
+	if (conn->hdrdgst_en)
 		iscsi_hdr_digest(conn, &ctask->headbuf, (u8*)ctask->hdrext);
 	if (!iscsi_sendhdr(conn, &ctask->headbuf, 0)) {
 		BUG_ON(ctask->xmstate != XMSTATE_IDLE);
@@ -1760,7 +1776,7 @@ static inline int
 handle_xmstate_w_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	ctask->xmstate &= ~XMSTATE_W_HDR;
-	if (conn->hdrdgst_en) 
+	if (conn->hdrdgst_en)
 		iscsi_hdr_digest(conn, &ctask->headbuf, (u8*)ctask->hdrext);
 	if (iscsi_sendhdr(conn, &ctask->headbuf, ctask->imm_count)) {
 		ctask->xmstate |= XMSTATE_W_HDR;
@@ -2148,7 +2164,7 @@ unsolicit_head_again:
 solicit_head_again:
 		r2t = ctask->r2t;
 		if (conn->hdrdgst_en)
-			iscsi_hdr_digest(conn, &r2t->headbuf, 
+			iscsi_hdr_digest(conn, &r2t->headbuf,
 					(u8*)r2t->dtask->hdrext);
 		if (iscsi_sendhdr(conn, &r2t->headbuf, r2t->data_count)) {
 			ctask->xmstate &= ~XMSTATE_SOL_DATA;
@@ -3391,7 +3407,7 @@ iscsi_conn_set_param(iscsi_connh_t connh
 	switch(param) {
 	case ISCSI_PARAM_MAX_RECV_DLENGTH: {
 		char *saveptr = conn->data;
-		gfp_t flags = GFP_KERNEL;
+		int flags = GFP_KERNEL;
 
 		if (conn->data_size >= value) {
 			conn->max_recv_dlength = value;
@@ -3613,6 +3629,8 @@ static struct iscsi_transport iscsi_tcp_
 	.name			= "tcp",
 	.caps			= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST
 				  | CAP_DATADGST,
+	.af			= AF_INET,
+	.rdma			= 0,
 	.host_template		= &iscsi_sht,
 	.hostdata_size		= sizeof(struct iscsi_session),
 	.max_conn		= 1,
--- linux-2.6.14/drivers/scsi/scsi_transport_iscsi.c	2005-12-19 09:22:05.060398772 +0100
+++ open-iscsi/kernel/scsi_transport_iscsi.c	2005-12-19 09:33:45.000000000 +0100
@@ -21,11 +21,8 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 #include <linux/module.h>
-#include <linux/string.h>
-#include <linux/slab.h>
 #include <linux/mempool.h>
 #include <net/tcp.h>
-
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_device.h>
@@ -117,6 +114,8 @@ show_transport_attr(caps, "0x%x");
 show_transport_attr(max_lun, "%d");
 show_transport_attr(max_conn, "%d");
 show_transport_attr(max_cmd_len, "%d");
+show_transport_attr(af, "%d");
+show_transport_attr(rdma, "%d");
 
 static struct attribute *iscsi_transport_attrs[] = {
 	&class_device_attr_handle.attr,
@@ -124,6 +123,8 @@ static struct attribute *iscsi_transport
 	&class_device_attr_max_lun.attr,
 	&class_device_attr_max_conn.attr,
 	&class_device_attr_max_cmd_len.attr,
+	&class_device_attr_af.attr,
+	&class_device_attr_rdma.attr,
 	NULL,
 };
 
@@ -249,7 +250,7 @@ static inline struct list_head *skb_to_l
 }
 
 static void*
-mempool_zone_alloc_skb(gfp_t gfp_mask, void *pool_data)
+mempool_zone_alloc_skb(unsigned int gfp_mask, void *pool_data)
 {
 	struct mempool_zone *zone = pool_data;
 
@@ -1234,7 +1235,7 @@ static __init int iscsi_transport_init(v
 		goto unregister_session_class;
 
 	nls = netlink_kernel_create(NETLINK_ISCSI, 1, iscsi_if_rx,
-				    THIS_MODULE);
+			THIS_MODULE);
 	if (!nls) {
 		err = -ENOBUFS;
 		goto unregister_notifier;
--- linux-2.6.14/include/scsi/scsi_transport_iscsi.h	2005-12-19 09:22:04.472363269 +0100
+++ open-iscsi/kernel/scsi_transport_iscsi.h	2005-12-19 09:33:45.000000000 +0100
@@ -47,6 +47,8 @@ struct iscsi_transport {
 	struct module *owner;
 	char *name;
 	unsigned int caps;
+	unsigned short af;
+	unsigned short rdma;
 	struct scsi_host_template *host_template;
 	int hostdata_size;
 	int max_lun;
--- linux-2.6.14/include/scsi/iscsi_if.h	2005-12-19 09:22:04.472363269 +0100
+++ open-iscsi/include/iscsi_if.h	2005-12-19 09:33:45.000000000 +0100
@@ -160,8 +160,9 @@ enum iscsi_param {
 	ISCSI_PARAM_ERL			= 11,
 	ISCSI_PARAM_IFMARKER_EN		= 12,
 	ISCSI_PARAM_OFMARKER_EN		= 13,
+	ISCSI_PARAM_RDMAEXTENSIONS      = 14,
 };
-#define ISCSI_PARAM_MAX			14
+#define ISCSI_PARAM_MAX			15
 
 typedef uint64_t iscsi_sessionh_t;	/* iSCSI Data-Path session handle */
 typedef uint64_t iscsi_connh_t;		/* iSCSI Data-Path connection handle */
