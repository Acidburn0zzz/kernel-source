From: Alex Aizman <itn780@yahoo.com>
Subject: open-iscsi update

Update to open-iscsi svn 436.

Signed-off-by: Hannes Reinecke <hare@suse.de>

--- linux-2.6.14/include/scsi/iscsi_if.h.orig	2005-11-03 09:12:52.393605091 +0100
+++ linux-2.6.14/include/scsi/iscsi_if.h	2005-11-03 09:18:27.581792542 +0100
@@ -160,8 +160,9 @@ enum iscsi_param {
 	ISCSI_PARAM_ERL			= 11,
 	ISCSI_PARAM_IFMARKER_EN		= 12,
 	ISCSI_PARAM_OFMARKER_EN		= 13,
+	ISCSI_PARAM_RDMAEXTENSIONS      = 14,
 };
-#define ISCSI_PARAM_MAX			14
+#define ISCSI_PARAM_MAX			15
 
 typedef uint64_t iscsi_sessionh_t;	/* iSCSI Data-Path session handle */
 typedef uint64_t iscsi_connh_t;		/* iSCSI Data-Path connection handle */
--- linux-2.6.14/include/scsi/scsi_transport_iscsi.h.orig	2005-11-03 09:12:52.393605091 +0100
+++ linux-2.6.14/include/scsi/scsi_transport_iscsi.h	2005-11-03 09:17:51.335610637 +0100
@@ -47,6 +47,8 @@ struct iscsi_transport {
 	struct module *owner;
 	char *name;
 	unsigned int caps;
+	unsigned short af;
+	unsigned short rdma;
 	struct scsi_host_template *host_template;
 	int hostdata_size;
 	int max_lun;
--- linux-2.6.14/drivers/scsi/scsi_transport_iscsi.c.orig	2005-11-03 09:12:52.385604609 +0100
+++ linux-2.6.14/drivers/scsi/scsi_transport_iscsi.c	2005-11-03 09:16:57.508369925 +0100
@@ -114,6 +114,8 @@ show_transport_attr(caps, "0x%x");
 show_transport_attr(max_lun, "%d");
 show_transport_attr(max_conn, "%d");
 show_transport_attr(max_cmd_len, "%d");
+show_transport_attr(af, "%d");
+show_transport_attr(rdma, "%d");
 
 static struct attribute *iscsi_transport_attrs[] = {
 	&class_device_attr_handle.attr,
@@ -121,6 +123,8 @@ static struct attribute *iscsi_transport
 	&class_device_attr_max_lun.attr,
 	&class_device_attr_max_conn.attr,
 	&class_device_attr_max_cmd_len.attr,
+	&class_device_attr_af.attr,
+	&class_device_attr_rdma.attr,
 	NULL,
 };
 
--- linux-2.6.14/drivers/scsi/iscsi_tcp.c.orig	2005-11-03 09:12:52.281598341 +0100
+++ linux-2.6.14/drivers/scsi/iscsi_tcp.c	2005-11-03 09:15:12.598052030 +0100
@@ -536,6 +536,22 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, s
 	return 0;
 }
 
+static void
+iscsi_reject_rsp(struct iscsi_conn *conn)
+{
+	/* FIXME: implement! */
+	printk(KERN_ERR "iscsi: reject PDU received!\n");
+	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+}
+
+static void
+iscsi_async_event_rsp(struct iscsi_conn *conn)
+{
+	/* FIXME: implement! */
+	printk(KERN_ERR "iscsi: async event PDU received!\n");
+	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+}
+
 static int
 iscsi_hdr_recv(struct iscsi_conn *conn)
 {
@@ -584,7 +600,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 	}
 
 	/* save opcode for later */
-	conn->in.opcode = hdr->opcode;
+	conn->in.opcode = hdr->opcode & ISCSI_OPCODE_MASK;
 
 	/* verify itt (itt encoding: age+cid+itt) */
 	if (hdr->itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
@@ -642,9 +658,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 		switch(conn->in.opcode) {
 		case ISCSI_OP_SCSI_CMD_RSP:
 			BUG_ON((void*)ctask != ctask->sc->SCp.ptr);
-			if (ctask->hdr.flags & ISCSI_FLAG_CMD_WRITE)
-				rc = iscsi_cmd_rsp(conn, ctask);
-			else if (!conn->in.datalen)
+			if (!conn->in.datalen)
 				rc = iscsi_cmd_rsp(conn, ctask);
 			else
 				/*
@@ -666,8 +680,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 			break;
 		case ISCSI_OP_R2T:
 			BUG_ON((void*)ctask != ctask->sc->SCp.ptr);
-			if (ctask->hdr.flags & ISCSI_FLAG_CMD_WRITE &&
-			    ctask->sc->sc_data_direction == DMA_TO_DEVICE)
+			if (ctask->sc->sc_data_direction == DMA_TO_DEVICE)
 				rc = iscsi_r2t_rsp(conn, ctask);
 			else
 				rc = ISCSI_ERR_PROTO;
@@ -775,10 +788,10 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 				rc = ISCSI_ERR_PROTO;
 			break;
 		case ISCSI_OP_REJECT:
-			/* we need sth like iscsi_reject_rsp()*/
+			iscsi_reject_rsp(conn);
+			break;
 		case ISCSI_OP_ASYNC_EVENT:
-			/* we need sth like iscsi_async_event_rsp() */
-			rc = ISCSI_ERR_BAD_OPCODE;
+			iscsi_async_event_rsp(conn);
 			break;
 		default:
 			rc = ISCSI_ERR_BAD_OPCODE;
@@ -906,11 +919,20 @@ partial_sg_digest_update(struct iscsi_co
 	crypto_digest_update(conn->data_rx_tfm, &temp, 1);
 }
 
+static void
+iscsi_recv_digest_update(struct iscsi_conn *conn, char* buf, int len)
+{
+	struct scatterlist tmp;
+
+	sg_init_one(&tmp, buf, len);
+	crypto_digest_update(conn->data_rx_tfm, &tmp, 1);
+}
+
 static int iscsi_scsi_data_in(struct iscsi_conn *conn)
 {
 	struct iscsi_cmd_task *ctask = conn->in.ctask;
 	struct scsi_cmnd *sc = ctask->sc;
-	struct scatterlist tmp, *sg;
+	struct scatterlist *sg;
 	int i, offset, rc = 0;
 
 	BUG_ON((void*)ctask != sc->SCp.ptr);
@@ -924,10 +946,8 @@ static int iscsi_scsi_data_in(struct isc
 				      sc->request_bufflen, ctask->data_offset);
 		if (rc == -EAGAIN)
 			return rc;
-		if (conn->datadgst_en) {
-			sg_init_one(&tmp, sc->request_buffer, i);
-			crypto_digest_update(conn->data_rx_tfm, &tmp, 1);
-		}
+		if (conn->datadgst_en) 
+			iscsi_recv_digest_update(conn, sc->request_buffer, i);
 		rc = 0;
 		goto done;
 	}
@@ -1021,6 +1041,9 @@ iscsi_data_recv(struct iscsi_conn *conn)
 		conn->in.hdr = &conn->hdr;
 		conn->senselen = (conn->data[0] << 8) | conn->data[1];
 		rc = iscsi_cmd_rsp(conn, conn->in.ctask);
+		if (!rc && conn->datadgst_en) 
+			iscsi_recv_digest_update(conn, conn->data,
+						 conn->in.datalen);
 	}
 	break;
 	case ISCSI_OP_TEXT_RSP:
@@ -1045,6 +1068,11 @@ iscsi_data_recv(struct iscsi_conn *conn)
 		rc = iscsi_recv_pdu(iscsi_handle(conn), conn->in.hdr,
 				    conn->data, conn->in.datalen);
 
+		if (!rc && conn->datadgst_en && 
+			conn->in.opcode != ISCSI_OP_LOGIN_RSP)
+			iscsi_recv_digest_update(conn, conn->data,
+			  			conn->in.datalen);
+
 		if (mtask && conn->login_mtask != mtask) {
 			spin_lock(&session->lock);
 			__kfifo_put(session->mgmtpool.queue, (void*)&mtask,
@@ -1053,6 +1081,8 @@ iscsi_data_recv(struct iscsi_conn *conn)
 		}
 	}
 	break;
+	case ISCSI_OP_ASYNC_EVENT:
+	case ISCSI_OP_REJECT:
 	default:
 		BUG_ON(1);
 	}
@@ -1115,7 +1145,7 @@ more:
 		rc = iscsi_hdr_recv(conn);
 		if (!rc && conn->in.datalen) {
 			if (conn->datadgst_en &&
-			    conn->in.opcode == ISCSI_OP_SCSI_DATA_IN) {
+				conn->in.opcode != ISCSI_OP_LOGIN_RSP) {
 				BUG_ON(!conn->data_rx_tfm);
 				crypto_digest_init(conn->data_rx_tfm);
 			}
@@ -1127,26 +1157,24 @@ more:
 	}
 
 	if (conn->in_progress == IN_PROGRESS_DDIGEST_RECV) {
+		uint32_t recv_digest;
 		debug_tcp("extra data_recv offset %d copy %d\n",
 			  conn->in.offset, conn->in.copy);
-		if (conn->in.opcode == ISCSI_OP_SCSI_DATA_IN) {
-			uint32_t recv_digest;
-			skb_copy_bits(conn->in.skb, conn->in.offset,
-				      &recv_digest, 4);
-			conn->in.offset += 4;
-			conn->in.copy -= 4;
-			if (recv_digest != conn->in.datadgst) {
-				debug_tcp("iscsi_tcp: data digest error!"
-					  "0x%x != 0x%x\n", recv_digest,
-					  conn->in.datadgst);
-				iscsi_conn_failure(conn, ISCSI_ERR_DATA_DGST);
-				return 0;
-			} else {
-				debug_tcp("iscsi_tcp: data digest match!"
-					  "0x%x == 0x%x\n", recv_digest,
-					  conn->in.datadgst);
-				conn->in_progress = IN_PROGRESS_WAIT_HEADER;
-			}
+		skb_copy_bits(conn->in.skb, conn->in.offset,
+				&recv_digest, 4);
+		conn->in.offset += 4;
+		conn->in.copy -= 4;
+		if (recv_digest != conn->in.datadgst) {
+			debug_tcp("iscsi_tcp: data digest error!"
+				  "0x%x != 0x%x\n", recv_digest,
+				  conn->in.datadgst);
+			iscsi_conn_failure(conn, ISCSI_ERR_DATA_DGST);
+			return 0;
+		} else {
+			debug_tcp("iscsi_tcp: data digest match!"
+				  "0x%x == 0x%x\n", recv_digest,
+				  conn->in.datadgst);
+			conn->in_progress = IN_PROGRESS_WAIT_HEADER;
 		}
 	}
 
@@ -1168,7 +1196,7 @@ more:
 		conn->in.copy -= conn->in.padding;
 		conn->in.offset += conn->in.padding;
 		if (conn->datadgst_en &&
-		    conn->in.opcode == ISCSI_OP_SCSI_DATA_IN) {
+			conn->in.opcode != ISCSI_OP_LOGIN_RSP) {
 			if (conn->in.padding) {
 				debug_tcp("padding -> %d\n", conn->in.padding);
 				memset(pad, 0, conn->in.padding);
@@ -1237,8 +1265,9 @@ iscsi_tcp_state_change(struct sock *sk)
 	conn = (struct iscsi_conn*)sk->sk_user_data;
 	session = conn->session;
 
-	if (sk->sk_state == TCP_CLOSE_WAIT ||
-	    sk->sk_state == TCP_CLOSE) {
+	if ((sk->sk_state == TCP_CLOSE_WAIT ||
+	     sk->sk_state == TCP_CLOSE) &&
+	    !atomic_read(&sk->sk_rmem_alloc)) {
 		debug_tcp("iscsi_tcp_state_change: TCP_CLOSE|TCP_CLOSE_WAIT\n");
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 	}
@@ -3590,6 +3619,8 @@ static struct iscsi_transport iscsi_tcp_
 	.name			= "tcp",
 	.caps			= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST
 				  | CAP_DATADGST,
+	.af			= AF_INET,
+	.rdma			= 0,
 	.host_template		= &iscsi_sht,
 	.hostdata_size		= sizeof(struct iscsi_session),
 	.max_conn		= 1,
