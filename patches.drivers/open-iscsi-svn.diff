From: Alex Aizman <itn780@yahoo.com>
Subject: open-iscsi update

Update to open-iscsi svn 401.

Signed-off-by: Hannes Reinecke <hare@suse.de>

--- linux-2.6.12/include/scsi/iscsi_proto.h	2005-08-17 09:31:22.951832916 +0200
+++ linux-2.6.12.iscsi/include/scsi/iscsi_proto.h	2005-08-18 14:49:40.000000000 +0200
@@ -56,7 +56,8 @@ struct iscsi_hdr {
 	__be32		ttt;		/* Target Task Tag */
 	__be32		statsn;
 	__be32		exp_statsn;
-	uint8_t		other[16];
+	__be32		max_statsn;
+	uint8_t		other[12];
 };
 
 /************************* RFC 3720 Begin *****************************/
@@ -78,6 +79,11 @@ struct iscsi_hdr {
 #define ISCSI_OP_LOGOUT			0x06
 #define ISCSI_OP_SNACK			0x10
 
+#define ISCSI_OP_VENDOR1_CMD		0x1c
+#define ISCSI_OP_VENDOR2_CMD		0x1d
+#define ISCSI_OP_VENDOR3_CMD		0x1e
+#define ISCSI_OP_VENDOR4_CMD		0x1f
+
 /* Target Opcode values */
 #define ISCSI_OP_NOOP_IN		0x20
 #define ISCSI_OP_SCSI_CMD_RSP		0x21
@@ -90,12 +96,20 @@ struct iscsi_hdr {
 #define ISCSI_OP_ASYNC_EVENT		0x32
 #define ISCSI_OP_REJECT			0x3f
 
+struct iscsi_ahs_hdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t ahspec[5];
+};
+
+#define ISCSI_AHSTYPE_CDB		1
+#define ISCSI_AHSTYPE_RLENGTH		2
+
 /* iSCSI PDU Header */
 struct iscsi_cmd {
 	uint8_t opcode;
 	uint8_t flags;
-	uint8_t rsvd2;
-	uint8_t cmdrn;
+	__be16 rsvd2;
 	uint8_t hlength;
 	uint8_t dlength[3];
 	uint8_t lun[8];
@@ -120,6 +134,13 @@ struct iscsi_cmd {
 #define ISCSI_ATTR_HEAD_OF_QUEUE	3
 #define ISCSI_ATTR_ACA			4
 
+struct iscsi_rlength_ahdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t reserved;
+	__be32 read_length;
+};
+
 /* SCSI Response Header */
 struct iscsi_cmd_rsp {
 	uint8_t opcode;
@@ -227,7 +248,7 @@ struct iscsi_tm {
 	uint8_t rsvd2[8];
 };
 
-#define ISCSI_FLAG_TASK_MGMT_FUNCTION_MASK	0x7F
+#define ISCSI_FLAG_TM_FUNC_MASK			0x7F
 
 /* Function values */
 #define ISCSI_TM_FUNC_ABORT_TASK		1
@@ -257,14 +278,14 @@ struct iscsi_tm_rsp {
 };
 
 /* Response values */
-#define SCSI_TCP_TM_RESP_COMPLETE	0x00
-#define SCSI_TCP_TM_RESP_NO_TASK	0x01
-#define SCSI_TCP_TM_RESP_NO_LUN		0x02
-#define SCSI_TCP_TM_RESP_TASK_ALLEGIANT	0x03
-#define SCSI_TCP_TM_RESP_NO_FAILOVER	0x04
-#define SCSI_TCP_TM_RESP_NOT_SUPPORTED	0x05
-#define SCSI_TCP_TM_RESP_AUTH_FAILED	0x06
-#define SCSI_TCP_TM_RESP_REJECTED	0xff
+#define ISCSI_TMF_RSP_COMPLETE		0x00
+#define ISCSI_TMF_RSP_NO_TASK		0x01
+#define ISCSI_TMF_RSP_NO_LUN		0x02
+#define ISCSI_TMF_RSP_TASK_ALLEGIANT	0x03
+#define ISCSI_TMF_RSP_NO_FAILOVER	0x04
+#define ISCSI_TMF_RSP_NOT_SUPPORTED	0x05
+#define ISCSI_TMF_RSP_AUTH_FAILED	0x06
+#define ISCSI_TMF_RSP_REJECTED		0xff
 
 /* Ready To Transfer Header */
 struct iscsi_r2t_rsp {
--- linux-2.6.12/drivers/scsi/iscsi_tcp.c	2005-08-17 09:31:22.918837849 +0200
+++ linux-2.6.12.iscsi/drivers/scsi/iscsi_tcp.c	2005-08-18 14:49:40.000000000 +0200
@@ -129,14 +129,11 @@ iscsi_buf_left(struct iscsi_buf *ibuf)
 }
 
 static inline void
-iscsi_buf_init_hdr(struct iscsi_conn *conn, struct iscsi_buf *ibuf,
-		   char *vbuf, u8 *crc)
+iscsi_hdr_digest(struct iscsi_conn *conn, struct iscsi_buf *buf,
+		 u8* crc)
 {
-	iscsi_buf_init_virt(ibuf, vbuf, sizeof(struct iscsi_hdr));
-	if (conn->hdrdgst_en) {
-		crypto_digest_digest(conn->tx_tfm, &ibuf->sg, 1, crc);
-		ibuf->sg.length += sizeof(uint32_t);
-	}
+	crypto_digest_digest(conn->tx_tfm, &buf->sg, 1, crc);
+	buf->sg.length += sizeof(uint32_t);
 }
 
 static void
@@ -427,8 +424,8 @@ iscsi_solicit_data_init(struct iscsi_con
 
 	r2t->sent = 0;
 
-	iscsi_buf_init_hdr(conn, &r2t->headbuf, (char*)hdr,
-			   (u8 *)dtask->hdrext);
+	iscsi_buf_init_virt(&r2t->headbuf, (char*)hdr,
+			   sizeof(struct iscsi_hdr));
 
 	r2t->dtask = dtask;
 
@@ -557,7 +557,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 	conn->data_copied = 0;
 
 	/* read AHS */
-	conn->in.ahslen = hdr->hlength*(4*sizeof(__u16));
+	conn->in.ahslen = hdr->hlength * 4;
 	conn->in.offset += conn->in.ahslen;
 	conn->in.copy -= conn->in.ahslen;
 	if (conn->in.copy < 0) {
@@ -754,7 +751,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 						(void*)&mtask, sizeof(void*));
 				conn->tmabort_state =
 					((struct iscsi_tm_rsp *)hdr)->
-					response == SCSI_TCP_TM_RESP_COMPLETE ?
+					response == ISCSI_TMF_RSP_COMPLETE ?
 						TMABORT_SUCCESS:TMABORT_FAILED;
 				/* unblock eh_abort() */
 				wake_up(&conn->ehwait);
@@ -1064,7 +1061,6 @@ iscsi_tcp_data_recv(read_descriptor_t *r
 {
 	int rc;
 	struct iscsi_conn *conn = rd_desc->arg.data;
-	int start = skb_headlen(skb);
 	int processed;
 	char pad[ISCSI_PAD_LEN];
 	struct scatterlist sg;
@@ -1073,7 +1069,7 @@ iscsi_tcp_data_recv(read_descriptor_t *r
 	 * Save current SKB and its offset in the corresponding
 	 * connection context.
 	 */
-	conn->in.copy = start - offset;
+	conn->in.copy = skb->len - offset;
 	conn->in.offset = offset;
 	conn->in.skb = skb;
 	conn->in.len = conn->in.copy;
@@ -1385,7 +1381,7 @@ iscsi_sendpage(struct iscsi_conn *conn, 
 	BUG_ON(buf->sent + size > buf->sg.length);
 	if (size > *count)
 		size = *count;
-	if (buf->sent + size != buf->sg.length)
+	if (buf->sent + size != buf->sg.length || *count != size)
 		flags |= MSG_MORE;
 
 	res = iscsi_send(sk, buf, size, flags);
@@ -1494,8 +1490,8 @@ iscsi_solicit_data_cont(struct iscsi_con
 	}
 	conn->dataout_pdus_cnt++;
 
-	iscsi_buf_init_hdr(conn, &r2t->headbuf, (char*)hdr,
-			   (u8 *)dtask->hdrext);
+	iscsi_buf_init_virt(&r2t->headbuf, (char*)hdr,
+			   sizeof(struct iscsi_hdr));
 
 	r2t->dtask = dtask;
 
@@ -1541,8 +1537,8 @@ iscsi_unsolicit_data_init(struct iscsi_c
 		hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	}
 
-	iscsi_buf_init_hdr(conn, &ctask->headbuf, (char*)hdr,
-			   (u8 *)dtask->hdrext);
+	iscsi_buf_init_virt(&ctask->headbuf, (char*)hdr,
+			   sizeof(struct iscsi_hdr));
 
 	list_add(&dtask->item, &ctask->dataqueue);
 
@@ -1662,8 +1658,8 @@ iscsi_cmd_init(struct iscsi_conn *conn, 
 		zero_data(ctask->hdr.dlength);
 	}
 
-	iscsi_buf_init_hdr(conn, &ctask->headbuf, (char*)&ctask->hdr,
-			    (u8 *)ctask->hdrext);
+	iscsi_buf_init_virt(&ctask->headbuf, (char*)&ctask->hdr, 
+			    sizeof(struct iscsi_hdr));
 	conn->scsicmd_pdus_cnt++;
 }
 
@@ -1692,6 +1688,11 @@ iscsi_mtask_xmit(struct iscsi_conn *conn
 		mtask->xmstate &= ~XMSTATE_IMM_HDR;
 		if (mtask->data_count)
 			mtask->xmstate |= XMSTATE_IMM_DATA;
+		if (conn->c_stage != ISCSI_CONN_INITIAL_STAGE &&
+	    	    conn->stop_stage != STOP_CONN_RECOVER &&
+		    conn->hdrdgst_en)
+			iscsi_hdr_digest(conn, &mtask->headbuf,
+					(u8*)mtask->hdrext);
 		if (iscsi_sendhdr(conn, &mtask->headbuf, mtask->data_count)) {
 			mtask->xmstate |= XMSTATE_IMM_HDR;
 			if (mtask->data_count)
@@ -1723,6 +1724,8 @@ static inline int
 handle_xmstate_r_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	ctask->xmstate &= ~XMSTATE_R_HDR;
+	if (conn->hdrdgst_en) 
+		iscsi_hdr_digest(conn, &ctask->headbuf, (u8*)ctask->hdrext);
 	if (!iscsi_sendhdr(conn, &ctask->headbuf, 0)) {
 		BUG_ON(ctask->xmstate != XMSTATE_IDLE);
 		return 0; /* wait for Data-In */
@@ -1735,6 +1738,8 @@ static inline int
 handle_xmstate_w_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	ctask->xmstate &= ~XMSTATE_W_HDR;
+	if (conn->hdrdgst_en) 
+		iscsi_hdr_digest(conn, &ctask->headbuf, (u8*)ctask->hdrext);
 	if (iscsi_sendhdr(conn, &ctask->headbuf, ctask->imm_count)) {
 		ctask->xmstate |= XMSTATE_W_HDR;
 		return -EAGAIN;
@@ -1813,7 +1818,9 @@ handle_xmstate_uns_hdr(struct iscsi_conn
 		iscsi_unsolicit_data_init(conn, ctask);
 		BUG_ON(!ctask->dtask);
 		dtask = ctask->dtask;
-
+		if (conn->hdrdgst_en)
+			iscsi_hdr_digest(conn, &ctask->headbuf,
+					(u8*)dtask->hdrext);
 		ctask->xmstate &= ~XMSTATE_UNS_INIT;
 	}
 	if (iscsi_sendhdr(conn, &ctask->headbuf, ctask->data_count)) {
@@ -2118,7 +2125,9 @@ unsolicit_head_again:
 				    sizeof(void*));
 solicit_head_again:
 		r2t = ctask->r2t;
-
+		if (conn->hdrdgst_en)
+			iscsi_hdr_digest(conn, &r2t->headbuf, 
+					(u8*)r2t->dtask->hdrext);
 		if (iscsi_sendhdr(conn, &r2t->headbuf, r2t->data_count)) {
 			ctask->xmstate &= ~XMSTATE_SOL_DATA;
 			ctask->xmstate |= XMSTATE_SOL_HDR;
@@ -2889,14 +2898,8 @@ iscsi_conn_send_generic(struct iscsi_con
 
 	memcpy(&mtask->hdr, hdr, sizeof(struct iscsi_hdr));
 
-	if (conn->c_stage == ISCSI_CONN_INITIAL_STAGE ||
-	    conn->stop_stage == STOP_CONN_RECOVER)
-		iscsi_buf_init_virt(&mtask->headbuf, (char*)&mtask->hdr,
+	iscsi_buf_init_virt(&mtask->headbuf, (char*)&mtask->hdr,
 				    sizeof(struct iscsi_hdr));
-	else
-		/* this will update header digest */
-		iscsi_buf_init_hdr(conn, &mtask->headbuf, (char*)&mtask->hdr,
-				    (u8 *)mtask->hdrext);
 
 	spin_unlock_bh(&session->lock);
 
