Subject: [PATCH 3/3] dm-netlink support
From: Mike Andersone <andmike@us.ibm.com>
Patch-Mainline: not yet

This patch adds a call to init dm_nl during dm init, and calls to dm_nl
functions for path failure / reinstate events.

Signed-off-by: Mike Anderson <andmike@us.ibm.com>
Acked-by: Hannes Reinecke <hare@suse.de>

 drivers/md/dm-ioctl.c |    2 +-
 drivers/md/dm-mpath.c |   32 ++++++++++++++++++++++++++++----
 drivers/md/dm-raid1.c |    2 +-
 drivers/md/dm-snap.c  |    2 +-
 drivers/md/dm-table.c |    5 ++++-
 drivers/md/dm.c       |    2 ++
 drivers/md/dm.h       |    6 +++++-
 7 files changed, 42 insertions(+), 9 deletions(-)

Index: sas-2.6-patched/drivers/md/dm.h
===================================================================
--- sas-2.6-patched.orig/drivers/md/dm.h	2006-01-11 22:49:27.000000000 -0800
+++ sas-2.6-patched/drivers/md/dm.h	2006-01-11 22:51:53.000000000 -0800
@@ -14,6 +14,7 @@
 #include <linux/device-mapper.h>
 #include <linux/list.h>
 #include <linux/blkdev.h>
+#include "dm-netlink.h"
 
 #define DM_NAME "device-mapper"
 #define DMWARN(f, x...) printk(KERN_WARNING DM_NAME ": " f "\n" , ## x)
@@ -108,7 +109,7 @@ int dm_table_add_target(struct dm_table 
 int dm_table_complete(struct dm_table *t);
 void dm_table_event_callback(struct dm_table *t,
 			     void (*fn)(void *), void *context);
-void dm_table_event(struct dm_table *t);
+void dm_table_event(struct dm_table *t, struct dm_evt *evt);
 sector_t dm_table_get_size(struct dm_table *t);
 struct dm_target *dm_table_get_target(struct dm_table *t, unsigned int index);
 struct dm_target *dm_table_find_target(struct dm_table *t, sector_t sector);
@@ -192,4 +193,7 @@ void dm_stripe_exit(void);
 void *dm_vcalloc(unsigned long nmemb, unsigned long elem_size);
 union map_info *dm_get_mapinfo(struct bio *bio);
 
+int dm_nl_init(void);
+void dm_nl_exit(void);
+
 #endif
Index: sas-2.6-patched/drivers/md/dm.c
===================================================================
--- sas-2.6-patched.orig/drivers/md/dm.c	2006-01-11 22:49:27.000000000 -0800
+++ sas-2.6-patched/drivers/md/dm.c	2006-01-11 22:51:53.000000000 -0800
@@ -163,6 +163,7 @@ int (*_inits[])(void) __initdata = {
 	dm_linear_init,
 	dm_stripe_init,
 	dm_interface_init,
+	dm_nl_init,
 };
 
 void (*_exits[])(void) = {
@@ -171,6 +172,7 @@ void (*_exits[])(void) = {
 	dm_linear_exit,
 	dm_stripe_exit,
 	dm_interface_exit,
+	dm_nl_exit,
 };
 
 static int __init dm_init(void)
Index: sas-2.6-patched/drivers/md/dm-mpath.c
===================================================================
--- sas-2.6-patched.orig/drivers/md/dm-mpath.c	2006-01-11 22:49:27.000000000 -0800
+++ sas-2.6-patched/drivers/md/dm-mpath.c	2006-01-11 23:13:35.000000000 -0800
@@ -10,6 +10,7 @@
 #include "dm-hw-handler.h"
 #include "dm-bio-list.h"
 #include "dm-bio-record.h"
+#include "dm-netlink.h"
 
 #include <linux/ctype.h>
 #include <linux/init.h>
@@ -80,6 +81,7 @@ struct multipath {
 	unsigned queue_size;
 
 	struct work_struct trigger_event;
+	struct list_head evt_list;
 
 	/*
 	 * We must use a mempool of mpath_io structs so that we
@@ -426,9 +428,18 @@ out:
  */
 static void trigger_event(void *data)
 {
+	unsigned long flags;
+	struct dm_evt *evt = NULL;
 	struct multipath *m = (struct multipath *) data;
 
-	dm_table_event(m->ti->table);
+	spin_lock_irqsave(&m->lock, flags);
+	if (!list_empty(&m->evt_list)) {
+		evt = list_entry(m->evt_list.next, struct dm_evt, elist);
+		list_del_init(&evt->elist);
+	}
+	spin_unlock_irqrestore(&m->lock, flags);
+
+	dm_table_event(m->ti->table, evt);
 }
 
 /*-----------------------------------------------------------------
@@ -798,9 +809,10 @@ static int multipath_map(struct dm_targe
 /*
  * Take a path out of use.
  */
-static int fail_path(struct pgpath *pgpath)
+static int __fail_path(struct pgpath *pgpath, struct bio *bio)
 {
 	unsigned long flags;
+	struct dm_evt *evt;
 	struct multipath *m = pgpath->pg->m;
 
 	spin_lock_irqsave(&m->lock, flags);
@@ -819,6 +831,10 @@ static int fail_path(struct pgpath *pgpa
 	if (pgpath == m->current_pgpath)
 		m->current_pgpath = NULL;
 
+	/* Get error data from bio when available */
+	evt = dm_path_fail_evt(pgpath->path.dev->name, 0x5A5A5A5A);
+	if (evt)
+		list_add(&evt->elist, &m->evt_list);
 	queue_work(kmultipathd, &m->trigger_event);
 
 out:
@@ -827,6 +843,11 @@ out:
 	return 0;
 }
 
+static int fail_path(struct pgpath *pgpath)
+{
+	return __fail_path(pgpath, NULL);
+}
+
 /*
  * Reinstate a previously-failed path
  */
@@ -834,6 +855,7 @@ static int reinstate_path(struct pgpath 
 {
 	int r = 0;
 	unsigned long flags;
+	struct dm_evt *evt;
 	struct multipath *m = pgpath->pg->m;
 
 	spin_lock_irqsave(&m->lock, flags);
@@ -858,7 +880,9 @@ static int reinstate_path(struct pgpath 
 	if (!m->nr_valid_paths++ && m->queue_size)
 		queue_work(kmultipathd, &m->process_queued_ios);
 
-	queue_work(kmultipathd, &m->trigger_event);
+	evt = dm_path_reinstate_evt(pgpath->path.dev->name);
+	if (evt)
+		queue_work(kmultipathd, &m->trigger_event);
 
 out:
 	spin_unlock_irqrestore(&m->lock, flags);
@@ -1028,7 +1052,7 @@ static int do_end_io(struct multipath *m
 
 	if (mpio->pgpath) {
 		if (err_flags & MP_FAIL_PATH)
-			fail_path(mpio->pgpath);
+			__fail_path(mpio->pgpath, bio);
 
 		if (err_flags & MP_BYPASS_PG)
 			bypass_pg(m, mpio->pgpath->pg, 1);
Index: sas-2.6-patched/drivers/md/dm-ioctl.c
===================================================================
--- sas-2.6-patched.orig/drivers/md/dm-ioctl.c	2006-01-11 22:49:27.000000000 -0800
+++ sas-2.6-patched/drivers/md/dm-ioctl.c	2006-01-11 22:51:53.000000000 -0800
@@ -240,7 +240,7 @@ static void __hash_remove(struct hash_ce
 
 	table = dm_get_table(hc->md);
 	if (table) {
-		dm_table_event(table);
+		dm_table_event(table, NULL);
 		dm_table_put(table);
 	}
 
Index: sas-2.6-patched/drivers/md/dm-raid1.c
===================================================================
--- sas-2.6-patched.orig/drivers/md/dm-raid1.c	2006-01-11 22:49:27.000000000 -0800
+++ sas-2.6-patched/drivers/md/dm-raid1.c	2006-01-11 22:51:53.000000000 -0800
@@ -671,7 +671,7 @@ static void do_recovery(struct mirror_se
 	if (!ms->in_sync &&
 	    (log->type->get_sync_count(log) == ms->nr_regions)) {
 		/* the sync is complete */
-		dm_table_event(ms->ti->table);
+		dm_table_event(ms->ti->table, NULL);
 		ms->in_sync = 1;
 	}
 }
Index: sas-2.6-patched/drivers/md/dm-snap.c
===================================================================
--- sas-2.6-patched.orig/drivers/md/dm-snap.c	2006-01-11 22:49:27.000000000 -0800
+++ sas-2.6-patched/drivers/md/dm-snap.c	2006-01-11 22:51:53.000000000 -0800
@@ -640,7 +640,7 @@ static void pending_complete(struct pend
 
 		error_bios(bio_list_get(&pe->snapshot_bios));
 
-		dm_table_event(s->table);
+		dm_table_event(s->table, NULL);
 	}
 
  out:
Index: sas-2.6-patched/drivers/md/dm-table.c
===================================================================
--- sas-2.6-patched.orig/drivers/md/dm-table.c	2006-01-11 22:49:27.000000000 -0800
+++ sas-2.6-patched/drivers/md/dm-table.c	2006-01-11 22:51:53.000000000 -0800
@@ -776,7 +776,7 @@ void dm_table_event_callback(struct dm_t
 	up(&_event_lock);
 }
 
-void dm_table_event(struct dm_table *t)
+void dm_table_event(struct dm_table *t, struct dm_evt *evt)
 {
 	/*
 	 * You can no longer call dm_table_event() from interrupt
@@ -788,6 +788,9 @@ void dm_table_event(struct dm_table *t)
 	if (t->event_fn)
 		t->event_fn(t->event_context);
 	up(&_event_lock);
+
+	if (evt)
+		dm_send_evt(evt);
 }
 
 sector_t dm_table_get_size(struct dm_table *t)
