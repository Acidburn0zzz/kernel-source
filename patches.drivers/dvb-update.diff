50_dvb
diff -up linux-2.6.9-rc2/Documentation/dvb/README.dibusb linux/Documentation/dvb/README.dibusb
--- linux-2.6.9-rc2/Documentation/dvb/README.dibusb	2004-09-17 14:56:38.533650885 +0200
+++ linux/Documentation/dvb/README.dibusb	2004-09-17 14:56:38.533650885 +0200
@@ -0,0 +1,152 @@
+Documentation for dib3000mb frontend driver and dibusb device driver
+
+The drivers should work with 
+
+- Twinhan VisionPlus VisionDTV USB-Ter DVB-T Device (VP7041)
+	http://www.twinhan.com/visiontv-2_4.htm
+	
+- CTS Portable (Chinese Television System)
+	http://www.2cts.tv/ctsportable/
+
+- KWorld V-Stream XPERT DTV - DVB-T USB
+	http://www.kworld.com.tw/asp/pindex.asp?id=4&pid=13
+
+- HAMA DVB-T USB device
+	http://www.hama.de/portal/articleId*110620/action*2598
+ 
+- DiBcom USB DVB-T reference device
+
+- Ultima Electronic/Artec T1 USB TVBOX
+	http://www.arteceuro.com/products-tvbox.html
+
+
+Copyright (C) 2004 Patrick Boettcher (patrick.boettcher@desy.de), 
+
+both drivers based on GPL code, which has
+
+Copyright (C) 2004 Amaury Demol for DiBcom (ademol@dibcom.fr)
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation, version 2.
+
+
+NEWS:
+  2004-09-13 - added support for a new device (Artec T1 USB TVBOX), thanks
+               to Christian Motschke for reporting
+  2004-09-05 - released the dibusb device and dib3000mb-frontend driver
+
+  (old news for vp7041.c)
+  2004-07-15 - found out, by accident, that the device has a TUA6010XS for 
+               frequency generator
+  2004-07-12 - figured out, that the driver should also work with the
+               CTS Portable (Chinese Television System)
+  2004-07-08 - firmware-extraction-2.422-problem solved, driver is now working 
+               properly with firmware extracted from 2.422
+			 - #if for 2.6.4 (dvb), compile issue
+			 - changed firmware handling, see vp7041.txt sec 1.1
+  2004-07-02 - some tuner modifications, v0.1, cleanups, first public
+  2004-06-28 - now using the dvb_dmx_swfilter_packets, everything 
+               runs fine now
+  2004-06-27 - able to watch and switching channels (pre-alpha)
+             - no section filtering yet
+  2004-06-06 - first TS received, but kernel oops :/
+  2004-05-14 - firmware loader is working
+  2004-05-11 - start writing the driver
+
+1. How to use?
+NOTE: This driver was developed using Linux 2.6.6., 
+it is working with 2.6.7, 2.6.8.1.
+
+Linux 2.4.x support is not planned, but patches are very welcome.
+
+NOTE: I'm using Debian testing, so the following explaination (especially
+the hotplug-path) needn't match your system, but probably it will :).
+
+1.1. Firmware
+
+The USB driver needs to download a firmware to start working.
+
+You can either use "get_dvb_firmware dibusb" to download the firmware or you
+can get it directly via 
+
+http://linuxtv.org/cgi-bin/cvsweb.cgi/dvb-kernel/firmware/dvb-dibusb-5.0.0.11.fw?rev=1.1&content-type=text/plain
+
+1.2. Compiling
+
+Since the driver is in the linux kernel, activating the driver in
+your favorite config-environment should sufficient. I recommend
+to compile the driver as module. Hotplug does the rest.
+
+1.3. Loading the drivers
+
+Hotplug is able to load the driver, when it is needed (because you plugged
+in the device).
+
+If you want to enable debug output, you have to load the driver manually.
+
+modprobe dvb-dibusb debug=1 
+modprobe dib3000mb debug=1
+
+should do the trick.
+
+When the driver is loaded successfully, the firmware file was in 
+the right place and the device is connected, the "Power"-LED should be
+turned on.
+
+At this point you should be able to start a dvb-capable application. For myself
+I used mplayer, dvbscan, tzap and kaxtv, they are working. Using the device
+as a slave device in vdr, was not working for me. Some work has to be done 
+(patches and comments are very welcome).
+
+2. Known problems and bugs
+
+TODO: 
+- add some additional URBs for USB data transfer
+- due a firmware problem i2c writes during mpeg transfers destroy the stream
+  no i2c writes during streaming, interrupt streaming, when adding another pid
+
+2.1. Adding new devices 
+
+It is not possible to determine the range of devices based on the DiBcom 
+reference design. This is because the reference design of DiBcom can be sold
+to third persons, without telling DiBcom (so done with the Twinhan VP7041 and 
+the HAMA device).
+
+When you think you have a device like this and the driver does not recognizes it,
+please send the ****load.inf and the ****cap.inf of the Windows driver to me.
+
+Sometimes the Vendor or Product ID is identical to the ones of Twinhan, even 
+though it is not a Twinhan device (e.g. HAMA), then please send me the name 
+of the device. I will add it to this list in order to make this clear to 
+others.
+
+If you are familar with C you can also add the VID and PID of the device to 
+the dvb-dibusb.[hc]-files and create a patch and send it over to me or to 
+the linux-dvb mailing list, _after_ you have tried compiling and modprobing
+it.
+
+2.2. Comments
+  
+Patches, comments and suggestions are very very welcome
+
+3. Acknowledgements
+	Amaury Demol (ademol@dibcom.fr) and Francois Kanounnikoff from DiBcom for 
+	providing specs, code and help, on which the dvb-dibusb and dib3000mb are 
+	based.
+  
+   Alex Woods for frequently answering question about usb and dvb
+    stuff, a big thank you
+
+   Bernd Wagner for helping with huge bug reports and discussions.
+   
+   Some guys on the linux-dvb mailing list for encouraging me
+   
+   Peter Schildmann >peter.schildmann-nospam-at-web.de< for his 
+    user-level firmware loader, which saves a lot of time 
+    (when writing the vp7041 driver)
+
+   Ulf Hermenau for helping me out with traditional chinese.
+   
+   André Smoktun and Christian Frömmel for supporting me with
+    hardware and listening to my problems very patient
diff -up linux-2.6.9-rc2/Documentation/dvb/avermedia.txt linux/Documentation/dvb/avermedia.txt
--- linux-2.6.9-rc2/Documentation/dvb/avermedia.txt	2004-09-14 10:36:40.000000000 +0200
+++ linux/Documentation/dvb/avermedia.txt	2004-09-17 14:56:38.536650323 +0200
@@ -6,7 +6,6 @@ HOWTO: Get An Avermedia DVB-T working un
    Assumptions and Introduction
    The Avermedia DVB-T
    Getting the card going
-   Getting the Firmware
    Receiving DVB-T in Australia
    Known Limitations
    Further Update
@@ -149,28 +148,9 @@ Getting the card going
    to start accessing the card with utilities such as scan, tzap,
    dvbstream etc.
 
-   The  current version of the frontend module sp887x.o, contains
-   no firmware drivers?, so the first time you open it with a DVB
-   utility  the driver will try to download some initial firmware
-   to  the card. You will need to download this firmware from the
-   web,  or  copy  it from an installation of the Windows drivers
-   that probably came with your card, before you can use it.
-
-   The  default  Linux  filesystem  location for this firmware is
-   /usr/lib/hotplug/firmware/sc_main.mc .
-     _________________________________________________________
-
-Getting the Firmware
-
-   As the firmware for the card is no longer contained within the
-   driver,  it  is  necessary  to  extract  it  from  the windows
-   drivers.
-
-   The  Windows  drivers  for the Avermedia DVB-T can be obtained
-   from: http://babyurl.com/H3U970 and you can get an application
-   to extract the firmware from:
-   http://www.kyz.uklinux.net/cabextract.php.
-     _________________________________________________________
+   The frontend module sp887x.o, requires an external   firmware.
+   Please use  the  command "get_dvb_firmware sp887x" to download
+   it. Then copy it to /usr/lib/hotplug/firmware.
 
 Receiving DVB-T in Australia
 
diff -up linux-2.6.9-rc2/Documentation/dvb/cards.txt linux/Documentation/dvb/cards.txt
--- linux-2.6.9-rc2/Documentation/dvb/cards.txt	2004-09-14 10:37:21.000000000 +0200
+++ linux/Documentation/dvb/cards.txt	2004-09-17 14:56:38.538649948 +0200
@@ -38,6 +38,7 @@ o Frontends drivers: 
                		  Comtech DVBT-6k07 (SP5730 PLL)
                		  (NxtWave Communications NXT6000 demodulator)
    - sp887x		: Microtune 7202D
+   - dib3000mb	: DiBcom 3000-MB Frontend
   DVB-S/C/T:
    - dst		: TwinHan DST Frontend
 
@@ -49,7 +50,7 @@ o Cards based on the Phillips saa7146 mu
   - "budget" cards (i.e. without hardware MPEG decoder):
     - Technotrend Budget / Hauppauge WinTV-Nova PCI Cards
     - SATELCO Multimedia PCI
-    - KNC1 DVB-S
+    - KNC1 DVB-S, Typhoon DVB-S, Terratec Cinergy 1200 DVB-S (no CI support)
     - Typhoon DVB-S budget
     - Fujitsu-Siemens Activy DVB-S budget card
 
@@ -66,4 +67,9 @@ o Technotrend / Hauppauge DVB USB device
   - Nova USB
   - DEC 2000-T, 3000-S, 2540-T
 
+o DiBcom DVB-T USB based devices:
+  - Twinhan VisionPlus VisionDTV USB-Ter DVB-T Device
+  - KWorld V-Stream XPERT DTV - DVB-T USB
+  - HAMA DVB-T USB device
+
 o Experimental support for the analog module of the Siemens DVB-C PCI card
diff -up linux-2.6.9-rc2/Documentation/dvb/contributors.txt linux/Documentation/dvb/contributors.txt
--- linux-2.6.9-rc2/Documentation/dvb/contributors.txt	2004-09-14 10:34:55.000000000 +0200
+++ linux/Documentation/dvb/contributors.txt	2004-09-17 14:56:38.539649761 +0200
@@ -69,6 +69,8 @@ Andreas 'randy' Weinberger
 Kenneth Aafløy <ke-aa@frisurf.no>
   for adding support for Typhoon DVB-S budget card
 
+Ernst Peinlich <e.peinlich@inode.at>
+  for tuning/DiSEqC support for the DEC 3000-s
 
 (If you think you should be in this list, but you are not, drop a
  line to the DVB mailing list)
diff -up linux-2.6.9-rc2/Documentation/dvb/faq.txt linux/Documentation/dvb/faq.txt
--- linux-2.6.9-rc2/Documentation/dvb/faq.txt	2004-09-14 10:37:06.000000000 +0200
+++ linux/Documentation/dvb/faq.txt	2004-09-17 14:56:38.541649386 +0200
@@ -93,7 +93,7 @@ Some very frequently asked questions abo
 	http://www.mythtv.org/
 		MythTV - analog TV PVR, but now with DVB support, too
 		(with software MPEG decode)
-
+	
 	http://dvbsnoop.sourceforge.net/
 		DVB sniffer program to monitor, analyze, debug, dump
 		or view dvb/mpeg/dsm-cc/mhp stream information (TS,
@@ -129,25 +129,25 @@ Some very frequently asked questions abo
 	  $ "echo 0 > /proc/sys/net/ipv4/conf/dvb0/rp_filter"
 
 7. What the hell are all those modules that need to be loaded?
-
+         
 	For a dvb-ttpci av7110 based full-featured card the following
 	modules are loaded:
 
 	- videodev: Video4Linux core module. This is the base module that
 	  gives you access to the "analog" tv picture of the av7110 mpeg2
 	  decoder.
-
+	  
 	- v4l2-common: common functions for Video4Linux-2 drivers
-
+	
 	- v4l1-compat: backward compatiblity layer for Video4Linux-1 legacy
 	  applications
 
 	- dvb-core: DVB core module. This provides you with the
 	  /dev/dvb/adapter entries
-
+	
 	- saa7146: SAA7146 core driver. This is need to access any SAA7146
 	  based card in your system.
-
+	
 	- saa7146_vv: SAA7146 video and vbi functions. These are only needed
 	  for full-featured cards.
 
diff -up linux-2.6.9-rc2/Documentation/dvb/get_dvb_firmware linux/Documentation/dvb/get_dvb_firmware
--- linux-2.6.9-rc2/Documentation/dvb/get_dvb_firmware	2004-09-17 14:56:38.544648824 +0200
+++ linux/Documentation/dvb/get_dvb_firmware	2004-09-17 14:56:38.544648824 +0200
@@ -0,0 +1,339 @@
+#!/usr/bin/perl
+#     DVB firmware extractor
+#  
+#     (c) 2004 Andrew de Quincey
+#  
+#     This program is free software; you can redistribute it and/or modify
+#       it under the terms of the GNU General Public License as published by
+#       the Free Software Foundation; either version 2 of the License, or
+#       (at your option) any later version.
+#  
+#     This program is distributed in the hope that it will be useful,
+#       but WITHOUT ANY WARRANTY; without even the implied warranty of
+#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  
+#     GNU General Public License for more details.
+#  
+#     You should have received a copy of the GNU General Public License
+#       along with this program; if not, write to the Free Software
+#       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+use File::Temp qw/ tempdir /;
+use IO::Handle;
+
+@components = ( "alps_tdlb7", "sp887x", "tda10045", "tda10046", "av7110", "dec2000t", "dec2540t", "dec3000s", "vp7041", "dibusb" );
+
+# Check args
+syntax() if (scalar(@ARGV) != 1);
+$cid = $ARGV[0];
+
+# Do it!
+for($i=0; $i < scalar(@components); $i++) {
+    if ($cid eq $components[$i]) {
+	$outfile = eval($cid);
+	die $@ if $@;
+	print STDERR "Firmware $outfile extracted successfully. Now copy it to /usr/lib/hotplug/firmware/.\n";
+	exit(0);
+    }
+}
+
+# If we get here, it wasn't found
+print STDERR "Unknown component \"$cid\"\n";
+syntax();
+
+
+
+
+# ---------------------------------------------------------------
+# Firmware-specific extraction subroutines
+
+sub alps_tdlb7 {
+    my $sourcefile = "tt_Premium_217g.zip";
+    my $url = "http://www.technotrend.de/new/217g/$sourcefile";
+    my $hash = "53970ec17a538945a6d8cb608a7b3899";
+    my $outfile = "dvb-fe-tdlb7.fw";
+    my $tmpdir = tempdir(DIR => "/tmp", CLEANUP => 1);
+
+    checkstandard();
+    
+    wgetfile($sourcefile, $url);
+    unzip($sourcefile, $tmpdir);
+    verify("$tmpdir/software/OEM/HE/App/boot/SC_MAIN.MC", $hash);
+    copy("$tmpdir/software/OEM/HE/App/boot/SC_MAIN.MC", $outfile);
+    
+    $outfile;
+}
+
+sub sp887x {
+    my $sourcefile = "Dvbt1.3.57.6.zip";
+    my $url = "http://www.avermedia.com/software/$sourcefile";
+    my $cabfile = "DVBT Net  Ver1.3.57.6/disk1/data1.cab";
+    my $hash = "237938d53a7f834c05c42b894ca68ac3";
+    my $outfile = "dvb-fe-sp887x.fw";
+    my $tmpdir = tempdir(DIR => "/tmp", CLEANUP => 1);
+    
+    checkstandard();
+    checkunshield();
+    
+    wgetfile($sourcefile, $url);
+    unzip($sourcefile, $tmpdir);
+    unshield("$tmpdir/$cabfile", $tmpdir);
+    verify("$tmpdir/sc_main.mc", $hash);
+    copy("$tmpdir/sc_main.mc", $outfile);
+    
+    $outfile;
+}
+
+sub tda10045 {
+    my $sourcefile = "tt_budget_217g.zip";
+    my $url = "http://www.technotrend.de/new/217g/$sourcefile";
+    my $hash = "2105fd5bf37842fbcdfa4bfd58f3594a";
+    my $outfile = "dvb-fe-tda10045.fw";
+    my $tmpdir = tempdir(DIR => "/tmp", CLEANUP => 1);
+
+    checkstandard();    
+    
+    wgetfile($sourcefile, $url);
+    unzip($sourcefile, $tmpdir);
+    extract("$tmpdir/software/OEM/PCI/App/ttlcdacc.dll", 0x37ef9, 30555, "$tmpdir/fwtmp");
+    verify("$tmpdir/fwtmp", $hash);
+    copy("$tmpdir/fwtmp", $outfile);
+    
+    $outfile;
+}
+
+sub tda10046 {
+    my $sourcefile = "tt_budget_217g.zip";
+    my $url = "http://www.technotrend.de/new/217g/$sourcefile";
+    my $hash = "a25b579e37109af60f4a36c37893957c";
+    my $outfile = "dvb-fe-tda10046.fw";
+    my $tmpdir = tempdir(DIR => "/tmp", CLEANUP => 1);
+
+    checkstandard();
+    
+    wgetfile($sourcefile, $url);
+    unzip($sourcefile, $tmpdir);
+    extract("$tmpdir/software/OEM/PCI/App/ttlcdacc.dll", 0x3f731, 24479, "$tmpdir/fwtmp");
+    verify("$tmpdir/fwtmp", $hash);
+    copy("$tmpdir/fwtmp", $outfile);
+    
+    $outfile;
+}
+
+sub av7110 {
+    my $sourcefile = "dvb-ttpci-01.fw-261c";
+    my $url = "http://www.linuxtv.org/download/dvb/firmware/$sourcefile";
+    my $hash = "7b263de6b0b92d2347319c65adc7d4fb";
+    my $outfile = "dvb-ttpci-01.fw";
+
+    checkstandard();
+    
+    wgetfile($sourcefile, $url);
+    verify($sourcefile, $hash);
+    copy($sourcefile, $outfile);
+    
+    $outfile;
+}
+
+sub dec2000t {
+    my $sourcefile = "dec217g.exe";
+    my $url = "http://hauppauge.lightpath.net/de/$sourcefile";
+    my $hash = "bd86f458cee4a8f0a8ce2d20c66215a9";
+    my $outfile = "dvb-ttusb-dec-2000t.fw";
+    my $tmpdir = tempdir(DIR => "/tmp", CLEANUP => 1);
+
+    checkstandard();
+    
+    wgetfile($sourcefile, $url);
+    unzip($sourcefile, $tmpdir);
+    verify("$tmpdir/software/OEM/STB/App/Boot/STB_PC_T.bin", $hash);
+    copy("$tmpdir/software/OEM/STB/App/Boot/STB_PC_T.bin", $outfile);
+
+    $outfile;
+}
+
+sub dec2540t {
+    my $sourcefile = "dec217g.exe";
+    my $url = "http://hauppauge.lightpath.net/de/$sourcefile";
+    my $hash = "53e58f4f5b5c2930beee74a7681fed92";
+    my $outfile = "dvb-ttusb-dec-2540t.fw";
+    my $tmpdir = tempdir(DIR => "/tmp", CLEANUP => 1);
+
+    checkstandard();
+    
+    wgetfile($sourcefile, $url);
+    unzip($sourcefile, $tmpdir);
+    verify("$tmpdir/software/OEM/STB/App/Boot/STB_PC_X.bin", $hash);
+    copy("$tmpdir/software/OEM/STB/App/Boot/STB_PC_X.bin", $outfile);
+
+    $outfile;
+}
+
+sub dec3000s {
+    my $sourcefile = "dec217g.exe";
+    my $url = "http://hauppauge.lightpath.net/de/$sourcefile";
+    my $hash = "b013ececea83f4d6d8d2a29ac7c1b448";
+    my $outfile = "dvb-ttusb-dec-3000s.fw";
+    my $tmpdir = tempdir(DIR => "/tmp", CLEANUP => 1);
+
+    checkstandard();
+    
+    wgetfile($sourcefile, $url);
+    unzip($sourcefile, $tmpdir);
+    verify("$tmpdir/software/OEM/STB/App/Boot/STB_PC_S.bin", $hash);
+    copy("$tmpdir/software/OEM/STB/App/Boot/STB_PC_S.bin", $outfile);
+
+    $outfile;
+}
+
+sub vp7041 {
+    my $sourcefile = "2.422.zip";
+    my $url = "http://www.twinhan.com/files/driver/USB-Ter/$sourcefile";
+    my $hash = "e88c9372d1f66609a3e7b072c53fbcfe";
+    my $outfile = "dvb-vp7041-2.422.fw";
+    my $tmpdir = tempdir(DIR => "/tmp", CLEANUP => 1);
+    
+    checkstandard();
+    
+    wgetfile($sourcefile, $url);
+    unzip($sourcefile, $tmpdir);
+    extract("$tmpdir/VisionDTV/Drivers/Win2K&XP/UDTTload.sys", 12503, 3036, "$tmpdir/fwtmp1");
+    extract("$tmpdir/VisionDTV/Drivers/Win2K&XP/UDTTload.sys", 2207, 10274, "$tmpdir/fwtmp2");
+
+    my $CMD = "\000\001\000\222\177\000";
+    my $PAD = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000";
+    my ($FW);
+    open $FW, ">$tmpdir/fwtmp3";
+    print $FW "$CMD\001$PAD";
+    print $FW "$CMD\001$PAD";
+    appendfile($FW, "$tmpdir/fwtmp1");
+    print $FW "$CMD\000$PAD";
+    print $FW "$CMD\001$PAD";
+    appendfile($FW, "$tmpdir/fwtmp2");
+    print $FW "$CMD\001$PAD";
+    print $FW "$CMD\000$PAD";
+    close($FW);
+
+    verify("$tmpdir/fwtmp3", $hash);
+    copy("$tmpdir/fwtmp3", $outfile);
+
+    $outfile;
+}
+
+sub dibusb {
+	my $url = "http://linuxtv.org/cgi-bin/cvsweb.cgi/dvb-kernel/firmware/dvb-dibusb-5.0.0.11.fw?rev=1.1&content-type=text/plain";
+	my $outfile = "dvb-dibusb-5.0.0.11.fw";
+	my $hash = "fa490295a527360ca16dcdf3224ca243";
+
+	checkstandard();
+
+	wgetfile($outfile, $url);
+	verify($outfile,$hash);
+
+	$outfile;
+}
+
+# ---------------------------------------------------------------
+# Utilities
+
+sub checkstandard {
+    if (system("which unzip > /dev/null 2>&1")) {
+	die "This firmware requires the unzip command - see ftp://ftp.info-zip.org/pub/infozip/UnZip.html\n";
+    }
+    if (system("which md5sum > /dev/null 2>&1")) {
+	die "This firmware requires the md5sum command - see http://www.gnu.org/software/coreutils/\n";
+    }
+    if (system("which wget > /dev/null 2>&1")) {
+	die "This firmware requires the wget command - see http://wget.sunsite.dk/\n";
+    }
+}
+
+sub checkunshield {
+    if (system("which unshield > /dev/null 2>&1")) {
+	die "This firmware requires the unshield command - see http://sourceforge.net/projects/synce/\n";
+    }
+}
+
+sub wgetfile {
+    my ($sourcefile, $url) = @_;
+
+    if (! -f $sourcefile) {
+	system("wget -O \"$sourcefile\" \"$url\"") and die "wget failed - unable to download firmware";
+    }
+}
+
+sub unzip {
+    my ($sourcefile, $todir) = @_;
+
+    $status = system("unzip -q -o -d \"$todir\" \"$sourcefile\" 2>/dev/null" );
+    if ((($status >> 8) > 2) || (($status & 0xff) != 0)) {
+	die ("unzip failed - unable to extract firmware");
+    }
+}
+
+sub unshield {
+    my ($sourcefile, $todir) = @_;
+
+    system("unshield -d \"$todir\" \"$sourcefile\" > /dev/null" ) and die ("unshield failed - unable to extract firmware");
+}
+
+sub verify {
+    my ($filename, $hash) = @_;
+    my ($testhash);
+
+    open(CMD, "md5sum \"$filename\"|");
+    $testhash = <CMD>;
+    $testhash =~ /([a-zA-Z0-9]*)/;
+    $testhash = $1;
+    close CMD;
+    die "Hash of extracted file does not match!\n" if ($testhash ne $hash);
+}
+
+sub copy {
+    my ($from, $to) = @_;
+    
+    system("cp -f \"$from\" \"$to\"") and die ("cp failed");
+}
+
+sub extract {
+    my ($infile, $offset, $length, $outfile) = @_;
+    my ($chunklength, $buf, $rcount);
+    
+    open INFILE, "<$infile";
+    open OUTFILE, ">$outfile";
+    sysseek(INFILE, $offset, SEEK_SET);
+    while($length > 0) {
+	# Calc chunk size
+	$chunklength = 2048;
+	$chunklength = $length if ($chunklength > $length);
+	
+	$rcount = sysread(INFILE, $buf, $chunklength);
+	die "Ran out of data\n" if ($rcount != $chunklength);
+	syswrite(OUTFILE, $buf);
+	$length -= $rcount;
+    }
+    close INFILE;
+    close OUTFILE;
+}
+
+sub appendfile {
+    my ($FH, $infile) = @_;
+    my ($buf);
+    
+    open INFILE, "<$infile";
+    while(1) {
+	$rcount = sysread(INFILE, $buf, 2048);
+	last if ($rcount == 0);
+	print $FH $buf;
+    }
+    close(INFILE);
+}
+
+sub syntax() {
+    print STDERR "syntax: get_dvb_firmware <component>\n";
+    print STDERR "Supported components:\n";
+    for($i=0; $i < scalar(@components); $i++) {
+	print STDERR "\t" . $components[$i] . "\n";
+    }
+    exit(1);
+}
diff -up linux-2.6.9-rc2/Documentation/dvb/readme.txt linux/Documentation/dvb/readme.txt
--- linux-2.6.9-rc2/Documentation/dvb/readme.txt	2004-09-14 10:34:43.000000000 +0200
+++ linux/Documentation/dvb/readme.txt	2004-09-17 14:56:38.546648449 +0200
@@ -28,9 +28,9 @@ is the who-is-who of DVB development
 "faq.txt"
 contains frequently asked questions and their answers.
 
-"firmware.txt" 
-contains informations for required external firmware
-files and where to get them.
+"get_dvb_firmware"
+script to download and extract firmware for those devices
+that require it.
 
 "ttusb-dec.txt"
 contains detailed informations about the
@@ -41,4 +41,11 @@ contains detailed installation instructi
 various bt8xx based "budget" DVB cards
 (Nebula, Pinnacle PCTV, Twinhan DST)
 
+"vp7041.txt"
+contains detailed informations about the
+Visionplus VisionDTV USB-Ter DVB-T adapter.
+
+"udev.txt"
+how to get DVB and udev up and running.
+
 Good luck and have fun!
diff -up linux-2.6.9-rc2/Documentation/dvb/ttusb-dec.txt linux/Documentation/dvb/ttusb-dec.txt
--- linux-2.6.9-rc2/Documentation/dvb/ttusb-dec.txt	2004-09-14 10:38:08.000000000 +0200
+++ linux/Documentation/dvb/ttusb-dec.txt	2004-09-17 14:56:38.642630466 +0200
@@ -6,6 +6,8 @@ Driver Status
 
 Supported:
 	DEC2000-t
+	DEC2450-t
+	DEC3000-s
 	Linux Kernels 2.4 and 2.6
 	Video Streaming
 	Audio Streaming
@@ -13,52 +15,30 @@ Supported:
 	Channel Zapping
 	Hotplug firmware loader under 2.6 kernels
 
-In Progress:
-	DEC2540-t
-	DEC3000-s
-
 To Do:
 	Tuner status information
 	DVB network interface
 	Streaming video PC->DEC
+	Conax support for 2450-t
 
 Getting the Firmware
 --------------------
-The firmware can be found in the software update zip files on this page:
-http://www.hauppauge.de/sw_dec.htm
-
-The firmwares are named as follows:
-DEC2000-t:	STB_PC_T.bin
-DEC2540-t:	STB_PC_X.bin
-DEC3000-s:	STB_PC_S.bin
-
-Note that firmwares since version 2.16 beta2 for the DEC2000-t give the device
-the USB ID of the DEC3000-s.  The driver copes with this.
-
-Instructions follow for retrieving version 2.16 of the firmware:
-
-wget http://hauppauge.lightpath.net/de/dec216.exe
-unzip -j dec216.exe software/OEM/STB/App/Boot/STB_PC_T.bin
-unzip -j dec216.exe software/OEM/STB/App/Boot/STB_PC_X.bin
-unzip -j dec216.exe software/OEM/STB/App/Boot/STB_PC_S.bin
+To download the firmware, use the following commands:
+"get_dvb_firmware dec2000t"
+"get_dvb_firmware dec2540t"
+"get_dvb_firmware dec3000s"
 
 
 Compilation Notes for 2.4 kernels
 ---------------------------------
 For 2.4 kernels the firmware for the DECs is compiled into the driver itself.
-The firmwares are expected to be in the build-2.4 directory at compilation
-time.
 
-mv STB_PC_T.bin build-2.4/dvb-ttusb-dec-2000t.fw
-mv STB_PC_X.bin build-2.4/dvb-ttusb-dec-2540t.fw
-mv STB_PC_S.bin build-2.4/dvb-ttusb-dec-3000s.fw
+Copy the three files downloaded above into the build-2.4 directory.
 
 
 Hotplug Firmware Loading for 2.6 kernels
 ----------------------------------------
 For 2.6 kernels the firmware is loaded at the point that the driver module is
-loaded.  See Documentation/dvb/firmware.txt for more information.
+loaded.  See linux/Documentation/dvb/firmware.txt for more information.
 
-mv STB_PC_T.bin /usr/lib/hotplug/firmware/dvb-ttusb-dec-2000t.fw
-mv STB_PC_X.bin /usr/lib/hotplug/firmware/dvb-ttusb-dec-2540t.fw
-mv STB_PC_S.bin /usr/lib/hotplug/firmware/dvb-ttusb-dec-3000s.fw
+Copy the three files downloaded above into the /usr/lib/hotplug/firmware directory.
diff -up linux-2.6.9-rc2/Documentation/dvb/udev.txt linux/Documentation/dvb/udev.txt
--- linux-2.6.9-rc2/Documentation/dvb/udev.txt	2004-09-17 14:56:38.644630091 +0200
+++ linux/Documentation/dvb/udev.txt	2004-09-17 14:56:38.644630091 +0200
@@ -0,0 +1,46 @@
+The DVB subsystem currently registers to the sysfs subsystem using the
+"class_simple" interface.
+
+This means that only the basic informations like module loading parameters
+are presented through sysfs. Other things that might be interesting are
+currently *not* available.
+
+Nevertheless it's now possible to add proper udev rules so that the
+DVB device nodes are created automatically.
+
+We assume that you have udev already up and running and that have been
+creating the DVB device nodes manually up to now due to the missing sysfs
+support.
+
+0. Don't forget to disable your current method of creating the
+device nodes manually.
+
+1. Unfortunately, you'll need a helper script to transform the kernel
+sysfs device name into the well known dvb adapter / device naming scheme.
+The script should be called "dvb.sh" and should be placed into a script
+dir where udev can execute it, most likely /etc/udev/scripts/
+
+So, create a new file /etc/udev/scripts/dvb.sh and add the following:
+------------------------------schnipp------------------------------------------------
+#!/bin/sh
+/bin/echo $1 | /bin/sed -e 's,dvb\([0-9]\)\.\([^0-9]*\)\([0-9]\),dvb/adapter\1/\2\3,'
+------------------------------schnipp------------------------------------------------
+
+Don't forget to make the script executable with "chmod".
+
+1. You need to create a proper udev rule that will create the device nodes
+like you know them. All real distributions out there scan the /etc/udev/rules.d
+directory for rule files. The main udev configuration file /etc/udev/udev.conf
+will tell you the directory where the rules are, most likely it's /etc/udev/rules.d/
+
+Create a new rule file in that directory called "dvb.rule" and add the following line:
+------------------------------schnipp------------------------------------------------
+KERNEL="dvb*", PROGRAM="/etc/udev/scripts/dvb.sh %k", NAME="%c"
+------------------------------schnipp------------------------------------------------
+
+If you want more control over the device nodes (for example a special group membership)
+have a look at "man udev".
+
+For every device that registers to the sysfs subsystem with a "dvb" prefix,
+the helper script /etc/udev/scripts/dvb.sh is invoked, which will then
+create the proper device node in your /dev/ directory.
diff -up linux-2.6.9-rc2/drivers/media/common/saa7146_core.c linux/drivers/media/common/saa7146_core.c
--- linux-2.6.9-rc2/drivers/media/common/saa7146_core.c	2004-09-14 10:36:56.000000000 +0200
+++ linux/drivers/media/common/saa7146_core.c	2004-09-17 14:56:38.647629529 +0200
@@ -133,8 +133,6 @@ static struct scatterlist* vmalloc_to_sg
 /********************************************************************************/
 /* common page table functions */
 
-#define SAA7146_PGTABLE_SIZE 4096
-
 char *saa7146_vmalloc_build_pgtable(struct pci_dev *pci, long length, struct saa7146_pgtable *pt)
 {
 	int pages = (length+PAGE_SIZE-1)/PAGE_SIZE;
@@ -182,11 +180,11 @@ int saa7146_pgtable_alloc(struct pci_dev
         u32          *cpu;
         dma_addr_t   dma_addr;
 
-	cpu = pci_alloc_consistent(pci, SAA7146_PGTABLE_SIZE, &dma_addr);
+	cpu = pci_alloc_consistent(pci, PAGE_SIZE, &dma_addr);
 	if (NULL == cpu) {
 		return -ENOMEM;
 	}
-	pt->size = SAA7146_PGTABLE_SIZE;
+	pt->size = PAGE_SIZE;
 	pt->cpu  = cpu;
 	pt->dma  = dma_addr;
 
@@ -196,17 +194,13 @@ int saa7146_pgtable_alloc(struct pci_dev
 int saa7146_pgtable_build_single(struct pci_dev *pci, struct saa7146_pgtable *pt,
 	struct scatterlist *list, int sglen  )
 {
-	u32   *ptr, fill;
+	u32 *ptr, fill;
 	int nr_pages = 0;
-	int   i,p;
+	int i,p;
 
-	BUG_ON( 0 == sglen);
+	BUG_ON(0 == sglen);
+	BUG_ON(list->offset > PAGE_SIZE);
 
-	if (list->offset > PAGE_SIZE) {
-		DEB_D(("offset > PAGE_SIZE. this should not happen."));
-		return -EINVAL;
-	}
-	
 	/* if we have a user buffer, the first page may not be
 	   aligned to a page boundary. */
 	pt->offset = list->offset;
@@ -217,7 +211,7 @@ int saa7146_pgtable_build_single(struct 
 		printk("i:%d, adr:0x%08x, len:%d, offset:%d\n", i,sg_dma_address(list), sg_dma_len(list), list->offset);
 */
 		for (p = 0; p * 4096 < list->length; p++, ptr++) {
-			*ptr = sg_dma_address(list) + p * 4096;
+			*ptr = cpu_to_le32(sg_dma_address(list) + p * 4096);
 			nr_pages++;
 		}
 	}
@@ -254,7 +248,6 @@ void saa7146_setgpio(struct saa7146_dev 
 
 /********************************************************************************/
 /* interrupt handler */
-
 static irqreturn_t interrupt_hw(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct saa7146_dev *dev = (struct saa7146_dev*)dev_id;
@@ -340,7 +333,7 @@ static int saa7146_init_one(struct pci_d
 	memset(dev, 0x0, sizeof(struct saa7146_dev));
 
 	DEB_EE(("pci:%p\n",pci));
-
+	
 	if (pci_enable_device(pci)) {
 		ERR(("pci_enable_device() failed.\n"));
 		err = -EIO;
@@ -405,25 +398,25 @@ static int saa7146_init_one(struct pci_d
 	if( NULL == dev->d_rps0.cpu_addr ) {
 		err = -ENOMEM;
 		goto kmalloc_error_1;
-	}
+	}	
 	memset(dev->d_rps0.cpu_addr, 0x0, SAA7146_RPS_MEM);
 
 	dev->d_rps1.cpu_addr = pci_alloc_consistent(dev->pci, SAA7146_RPS_MEM, &dev->d_rps1.dma_handle);	
 	if( NULL == dev->d_rps1.cpu_addr ) {
 		err = -ENOMEM;
 		goto kmalloc_error_2;
-	}
+	}	
 	memset(dev->d_rps1.cpu_addr, 0x0, SAA7146_RPS_MEM);
-
+	
 	dev->d_i2c.cpu_addr = pci_alloc_consistent(dev->pci, SAA7146_RPS_MEM, &dev->d_i2c.dma_handle);	
 	if( NULL == dev->d_i2c.cpu_addr ) {
 		err = -ENOMEM;
 		goto kmalloc_error_3;
-	}
+	}	
 	memset(dev->d_i2c.cpu_addr, 0x0, SAA7146_RPS_MEM);
 
 	/* the rest + print status message */
-
+	
 	/* create a nice device name */
 	sprintf(&dev->name[0], "saa7146 (%d)",saa7146_num);
 
diff -up linux-2.6.9-rc2/drivers/media/common/saa7146_fops.c linux/drivers/media/common/saa7146_fops.c
--- linux-2.6.9-rc2/drivers/media/common/saa7146_fops.c	2004-09-14 10:35:49.000000000 +0200
+++ linux/drivers/media/common/saa7146_fops.c	2004-09-17 14:56:38.650628967 +0200
@@ -9,13 +9,13 @@ int saa7146_res_get(struct saa7146_fh *f
 {
 	struct saa7146_dev *dev = fh->dev;
 	struct saa7146_vv *vv = dev->vv_data;
-
+	
 	if (fh->resources & bit) {
 		DEB_D(("already allocated! want: 0x%02x, cur:0x%02x\n",bit,vv->resources));
 		/* have it already allocated */
 		return 1;
 	}
-
+	
 	/* is it free? */
 	down(&dev->lock);
 	if (vv->resources & bit) {
@@ -88,10 +88,7 @@ int saa7146_buffer_queue(struct saa7146_
 #endif
 	DEB_EE(("dev:%p, dmaq:%p, buf:%p\n", dev, q, buf));
 
-	if( NULL == q ) {
-		ERR(("internal error: fatal NULL pointer for q.\n"));
-		return 0;
-	}
+	BUG_ON(!q);
 
 	if (NULL == q->curr) {
 		q->curr = buf;
@@ -112,14 +109,11 @@ void saa7146_buffer_finish(struct saa714
 #ifdef DEBUG_SPINLOCKS
 	BUG_ON(!spin_is_locked(&dev->slock));
 #endif
-	if( NULL == q->curr ) {
-		ERR(("internal error: fatal NULL pointer for q->curr.\n"));
-		return;
-	}
-
 	DEB_EE(("dev:%p, dmaq:%p, state:%d\n", dev, q, state));
 	DEB_EE(("q->curr:%p\n",q->curr));
 
+	BUG_ON(!q->curr);
+
 	/* finish current buffer */
 	if (NULL == q->curr) {
 		DEB_D(("aiii. no current buffer\n"));
@@ -138,10 +132,7 @@ void saa7146_buffer_next(struct saa7146_
 {
 	struct saa7146_buf *buf,*next = NULL;
 
-	if( NULL == q ) {
-		ERR(("internal error: fatal NULL pointer for q.\n"));
-		return;
-	}
+	BUG_ON(!q);
 
 	DEB_INT(("dev:%p, dmaq:%p, vbi:%d\n", dev, q, vbi));
 
@@ -284,7 +275,7 @@ static int fops_open(struct inode *inode
 		DEB_S(("initializing video...\n"));
 		result = saa7146_video_uops.open(dev,file);
 	}
-
+	
 	if (0 != result) {
 		goto out;
 	}
@@ -469,7 +460,7 @@ int saa7146_vv_init(struct saa7146_dev* 
 	memset(vv, 0x0, sizeof(*vv));
 
 	DEB_EE(("dev:%p\n",dev));
-	
+
 	/* set default values for video parts of the saa7146 */
 	saa7146_write(dev, BCS_CTRL, 0x80400040);
 
@@ -515,45 +506,58 @@ int saa7146_vv_release(struct saa7146_de
 	return 0;
 }
 
-int saa7146_register_device(struct video_device *vid, struct saa7146_dev* dev, char *name, int type)
+int saa7146_register_device(struct video_device **vid, struct saa7146_dev* dev,
+			    char *name, int type)
 {
 	struct saa7146_vv *vv = dev->vv_data;
+	struct video_device *vfd;
 
 	DEB_EE(("dev:%p, name:'%s', type:%d\n",dev,name,type));
- 
- 	*vid = device_template;
-	strlcpy(vid->name, name, sizeof(vid->name));
-	vid->priv = dev;
+
+	// released by vfd->release
+ 	vfd = video_device_alloc();
+	if (vfd == NULL)
+		return -ENOMEM;
+
+	memcpy(vfd, &device_template, sizeof(struct video_device));
+	strlcpy(vfd->name, name, sizeof(vfd->name));
+	vfd->release = video_device_release;
+	vfd->priv = dev;
 
 	// fixme: -1 should be an insmod parameter *for the extension* (like "video_nr");
-	if (video_register_device(vid,type,-1) < 0) {
+	if (video_register_device(vfd, type, -1) < 0) {
 		ERR(("cannot register v4l2 device. skipping.\n"));
 		return -1;
 	}
 
 	if( VFL_TYPE_GRABBER == type ) {
-		vv->video_minor = vid->minor;
-		INFO(("%s: registered device video%d [v4l2]\n", dev->name,vid->minor & 0x1f));
+		vv->video_minor = vfd->minor;
+		INFO(("%s: registered device video%d [v4l2]\n",
+			dev->name, vfd->minor & 0x1f));
 	} else {
-		vv->vbi_minor = vid->minor;
-		INFO(("%s: registered device vbi%d [v4l2]\n", dev->name,vid->minor & 0x1f));
+		vv->vbi_minor = vfd->minor;
+		INFO(("%s: registered device vbi%d [v4l2]\n",
+			dev->name, vfd->minor & 0x1f));
 	}
 
+	*vid = vfd;
 	return 0;
 }
 
-int saa7146_unregister_device(struct video_device *vid, struct saa7146_dev* dev)
+int saa7146_unregister_device(struct video_device **vid, struct saa7146_dev* dev)
 {
 	struct saa7146_vv *vv = dev->vv_data;
 	
 	DEB_EE(("dev:%p\n",dev));
 
-	if( VFL_TYPE_GRABBER == vid->type ) {
+	if( VFL_TYPE_GRABBER == (*vid)->type ) {
 		vv->video_minor = -1;
 	} else {
 		vv->vbi_minor = -1;
 	}
-	video_unregister_device(vid);
+
+	video_unregister_device(*vid);
+	*vid = NULL;
 
 	return 0;
 }
diff -up linux-2.6.9-rc2/drivers/media/common/saa7146_hlp.c linux/drivers/media/common/saa7146_hlp.c
--- linux-2.6.9-rc2/drivers/media/common/saa7146_hlp.c	2004-09-14 10:36:31.000000000 +0200
+++ linux/drivers/media/common/saa7146_hlp.c	2004-09-17 14:56:38.654628218 +0200
@@ -413,10 +413,10 @@ static void calculate_clipping_registers
 
 	/* fill up cliptable */
 	for(i = 0; i < cnt_pixel; i++) {
-		clipping[2*i] |= (pixel_list[i] << 16);
+		clipping[2*i] |= cpu_to_le32(pixel_list[i] << 16);
 	}
 	for(i = 0; i < cnt_line; i++) {
-		clipping[(2*i)+1] |= (line_list[i] << 16);
+		clipping[(2*i)+1] |= cpu_to_le32(line_list[i] << 16);
 	}
 
 	/* fill up cliptable with the display infos */
@@ -430,7 +430,7 @@ static void calculate_clipping_registers
 			if( pixel_list[i] < (x[j] + w[j])) {
 			
 				if ( pixel_list[i] >= x[j] ) {
-					clipping[2*i] |= (1 << j);			
+					clipping[2*i] |= cpu_to_le32(1 << j);			
 				}
 			}
 		}
@@ -442,7 +442,7 @@ static void calculate_clipping_registers
 			if( line_list[i] < (y[j] + h[j]) ) {
 
 				if( line_list[i] >= y[j] ) {
-					clipping[(2*i)+1] |= (1 << j);			
+					clipping[(2*i)+1] |= cpu_to_le32(1 << j);			
 				}
 			}
 		}
@@ -491,10 +491,10 @@ static void saa7146_set_clipping_rect(st
 	struct	saa7146_video_dma vdma2;
 	u32 clip_format;
 	u32 arbtr_ctrl;
-
+	
 	/* check clipcount, disable clipping if clipcount == 0*/
 	if( fh->ov.nclips == 0 ) {
-		saa7146_disable_clipping(dev);
+	 	saa7146_disable_clipping(dev);
 		return;
 	}
 
@@ -560,9 +560,10 @@ static void saa7146_set_window(struct sa
 }
 
 /* calculate the new memory offsets for a desired position */
-static void saa7146_set_position(struct saa7146_dev *dev, int w_x, int w_y, int w_height, enum v4l2_field field)
+static void saa7146_set_position(struct saa7146_dev *dev, int w_x, int w_y, int w_height, enum v4l2_field field, u32 pixelformat)
 {	
 	struct saa7146_vv *vv = dev->vv_data;
+	struct saa7146_format *sfmt = format_by_fourcc(dev, pixelformat);
 
 	int b_depth = vv->ov_fmt->depth;
 	int b_bpl = vv->ov_fb.fmt.bytesperline;
@@ -601,7 +602,7 @@ static void saa7146_set_position(struct 
 		vdma1.pitch *= -1;
 	}
 		
-	vdma1.base_page = 0;
+	vdma1.base_page = sfmt->swap;
 	vdma1.num_line_byte = (vv->standard->v_field<<16)+vv->standard->h_pixels;
 
 	saa7146_write_out_dma(dev, 1, &vdma1);
@@ -621,7 +622,7 @@ static void saa7146_set_output_format(st
 
 void saa7146_set_picture_prop(struct saa7146_dev *dev, int brightness, int contrast, int colour)
 {
-	u32	bcs_ctrl = 0;
+	u32 bcs_ctrl = 0;
 	
 	calculate_bcs_ctrl_register(dev, brightness, contrast, colour, &bcs_ctrl);
 	saa7146_write(dev, BCS_CTRL, bcs_ctrl);
@@ -657,14 +658,14 @@ int saa7146_enable_overlay(struct saa714
 	struct saa7146_vv *vv = dev->vv_data;
 
 	saa7146_set_window(dev, fh->ov.win.w.width, fh->ov.win.w.height, fh->ov.win.field);
-	saa7146_set_position(dev, fh->ov.win.w.left, fh->ov.win.w.top, fh->ov.win.w.height, fh->ov.win.field);
+	saa7146_set_position(dev, fh->ov.win.w.left, fh->ov.win.w.top, fh->ov.win.w.height, fh->ov.win.field, vv->ov_fmt->pixelformat);
 	saa7146_set_output_format(dev, vv->ov_fmt->trans);
 	saa7146_set_clipping_rect(fh);
 
 	/* enable video dma1 */
 	saa7146_write(dev, MC1, (MASK_06 | MASK_22));
 	return 0;
-}
+}		
 
 void saa7146_disable_overlay(struct saa7146_fh *fh)
 {
@@ -686,8 +687,8 @@ void saa7146_write_out_dma(struct saa714
 	/* calculate starting address */
 	where  = (which-1)*0x18;
 
-		saa7146_write(dev, where, 	vdma->base_odd);
-		saa7146_write(dev, where+0x04, 	vdma->base_even);
+	saa7146_write(dev, where, 	vdma->base_odd);
+	saa7146_write(dev, where+0x04, 	vdma->base_even);
 	saa7146_write(dev, where+0x08, 	vdma->prot_addr);
 	saa7146_write(dev, where+0x0c, 	vdma->pitch);
 	saa7146_write(dev, where+0x10, 	vdma->base_page);
@@ -704,6 +705,7 @@ void saa7146_write_out_dma(struct saa714
 	printk("vdma%d.num_line_byte: 0x%08x\n", which,vdma->num_line_byte);
 */
 }
+
 static int calculate_video_dma_grab_packed(struct saa7146_dev* dev, struct saa7146_buf *buf)
 {
 	struct saa7146_vv *vv = dev->vv_data;
@@ -724,11 +726,11 @@ static int calculate_video_dma_grab_pack
 	if( bytesperline != 0) {
 		vdma1.pitch = bytesperline*2;
 	} else {
-	vdma1.pitch		= (width*depth*2)/8;
+		vdma1.pitch = (width*depth*2)/8;
 	}
 	vdma1.num_line_byte	= ((vv->standard->v_field<<16) + vv->standard->h_pixels);
-	vdma1.base_page		= buf->pt[0].dma | ME1;
-	
+	vdma1.base_page		= buf->pt[0].dma | ME1 | sfmt->swap;
+		
 	if( 0 != vv->vflip ) {
 		vdma1.prot_addr	= buf->pt[0].offset;
 		vdma1.base_even	= buf->pt[0].offset+(vdma1.pitch/2)*height;
@@ -785,7 +787,6 @@ static int calc_planar_422(struct saa714
 		vdma3->prot_addr	= buf->pt[2].offset;
 		vdma3->base_even	= ((vdma3->pitch/2)*height)+buf->pt[2].offset;
 		vdma3->base_odd		= vdma3->base_even - (vdma3->pitch/2);
-
 	} else {
 		vdma3->base_even	= buf->pt[2].offset;
 		vdma3->base_odd		= vdma3->base_even + (vdma3->pitch/2);
@@ -938,7 +939,7 @@ static void program_capture_engine(struc
 {
 	struct saa7146_vv *vv = dev->vv_data;
 	int count = 0;
-
+	
 	unsigned long e_wait = vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? CMD_E_FID_A : CMD_E_FID_B;
 	unsigned long o_wait = vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? CMD_O_FID_A : CMD_O_FID_B;
 
@@ -969,10 +970,10 @@ static void program_capture_engine(struc
 	/* wait for o_fid_a/b / e_fid_a/b toggle */
 	if ( vv->last_field == V4L2_FIELD_INTERLACED ) {
 		WRITE_RPS0(CMD_PAUSE | o_wait);
-	WRITE_RPS0(CMD_PAUSE | e_wait);
+		WRITE_RPS0(CMD_PAUSE | e_wait);
 	} else if ( vv->last_field == V4L2_FIELD_TOP ) {
 		WRITE_RPS0(CMD_PAUSE | (vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? MASK_10 : MASK_09));
-	WRITE_RPS0(CMD_PAUSE | o_wait);
+		WRITE_RPS0(CMD_PAUSE | o_wait);
 	} else if ( vv->last_field == V4L2_FIELD_BOTTOM ) {
 		WRITE_RPS0(CMD_PAUSE | (vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? MASK_10 : MASK_09));
 		WRITE_RPS0(CMD_PAUSE | e_wait);
@@ -981,17 +982,17 @@ static void program_capture_engine(struc
 	/* turn off video-dma1 */
 	WRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));
 	WRITE_RPS0(MASK_22 | MASK_06);	    		/* => mask */
-	WRITE_RPS0(MASK_22);					/* => values */
+	WRITE_RPS0(MASK_22);				/* => values */
 	if( 0 != planar ) {
 		/* turn off video-dma2 */
 		WRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));		
 		WRITE_RPS0(MASK_05 | MASK_21);	    		/* => mask */
-		WRITE_RPS0(MASK_21);					/* => values */
+		WRITE_RPS0(MASK_21);				/* => values */
 
 		/* turn off video-dma3 */
 		WRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));		
 		WRITE_RPS0(MASK_04 | MASK_20);	    		/* => mask */
-		WRITE_RPS0(MASK_20);					/* => values */
+		WRITE_RPS0(MASK_20);				/* => values */
 	}
 
 	/* generate interrupt */
@@ -1006,7 +1007,7 @@ void saa7146_set_capture(struct saa7146_
 	struct saa7146_format *sfmt = format_by_fourcc(dev,buf->fmt->pixelformat);
 	struct saa7146_vv *vv = dev->vv_data;
 	u32 vdma1_prot_addr;
-
+	
 	DEB_CAP(("buf:%p, next:%p\n",buf,next));
 
 	vdma1_prot_addr = saa7146_read(dev, PROT_ADDR1);
@@ -1034,7 +1035,7 @@ void saa7146_set_capture(struct saa7146_
 		calculate_video_dma_grab_packed(dev, buf);
 		program_capture_engine(dev,0);
 	}
-
+	
 /*
 	printk("vdma%d.base_even:     0x%08x\n", 1,saa7146_read(dev,BASE_EVEN1));
 	printk("vdma%d.base_odd:      0x%08x\n", 1,saa7146_read(dev,BASE_ODD1));
diff -up linux-2.6.9-rc2/drivers/media/common/saa7146_i2c.c linux/drivers/media/common/saa7146_i2c.c
--- linux-2.6.9-rc2/drivers/media/common/saa7146_i2c.c	2004-09-14 10:37:53.000000000 +0200
+++ linux/drivers/media/common/saa7146_i2c.c	2004-09-17 14:56:38.657627656 +0200
@@ -296,7 +296,7 @@ int saa7146_i2c_transfer(struct saa7146_
 
 	if ( count > 3 || 0 != (SAA7146_I2C_SHORT_DELAY & dev->ext->flags) )
 		short_delay = 1;
-  
+
 	do {
 		/* reset the i2c-device if necessary */
 		err = saa7146_i2c_reset(dev);
@@ -375,7 +375,7 @@ out:
 static int saa7146_i2c_xfer(struct i2c_adapter* adapter, struct i2c_msg msg[], int num)
 {
 	struct saa7146_dev* dev = i2c_get_adapdata(adapter);
-	
+
 	/* use helper function to transfer data */
 	return saa7146_i2c_transfer(dev, msg, num, adapter->retries);
 }
@@ -393,7 +393,7 @@ static struct i2c_algorithm saa7146_algo
 	.functionality	= saa7146_i2c_func,
 };
 
-int saa7146_i2c_adapter_prepare(struct saa7146_dev *dev, struct i2c_adapter *i2c_adapter, unsigned int class, u32 bitrate)
+int saa7146_i2c_adapter_prepare(struct saa7146_dev *dev, struct i2c_adapter *i2c_adapter, u32 bitrate)
 {
 	DEB_EE(("bitrate: 0x%08x\n",bitrate));
 	
@@ -404,13 +404,11 @@ int saa7146_i2c_adapter_prepare(struct s
 	saa7146_i2c_reset(dev);
 
 	if( NULL != i2c_adapter ) {
-		memset(i2c_adapter,0,sizeof(struct i2c_adapter));
-		strcpy(i2c_adapter->name, dev->name);	
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-		i2c_adapter->data = dev;
+ 		i2c_adapter->data = dev;
 #else
+		BUG_ON(!i2c_adapter->class);
 		i2c_set_adapdata(i2c_adapter,dev);
-		i2c_adapter->class = class;
 #endif
 		i2c_adapter->algo	   = &saa7146_algo;
 		i2c_adapter->algo_data     = NULL;
diff -up linux-2.6.9-rc2/drivers/media/common/saa7146_vbi.c linux/drivers/media/common/saa7146_vbi.c
--- linux-2.6.9-rc2/drivers/media/common/saa7146_vbi.c	2004-09-14 10:34:33.000000000 +0200
+++ linux/drivers/media/common/saa7146_vbi.c	2004-09-17 14:56:38.659627281 +0200
@@ -34,10 +34,10 @@ static int vbi_workaround(struct saa7146
 	saa7146_write(dev, NUM_LINE_BYTE3, (2<<16)|((vbi_pixel_to_capture)<<0));
 	saa7146_write(dev, MC2, MASK_04|MASK_20);
 
-		/* load brs-control register */
-		WRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));
-		/* BXO = 1h, BRS to outbound */
-		WRITE_RPS1(0xc000008c);   
+	/* load brs-control register */
+	WRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));
+	/* BXO = 1h, BRS to outbound */
+	WRITE_RPS1(0xc000008c);   
 	/* wait for vbi_a or vbi_b*/
 	if ( 0 != (SAA7146_USE_PORT_B_FOR_VBI & dev->ext_vv_data->flags)) {
 		DEB_D(("...using port b\n"));
@@ -50,35 +50,35 @@ static int vbi_workaround(struct saa7146
 		DEB_D(("...using port a\n"));
 		WRITE_RPS1(CMD_PAUSE | MASK_10);
 	}
-		/* upload brs */
-		WRITE_RPS1(CMD_UPLOAD | MASK_08);
-		/* load brs-control register */
-		WRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));
-		/* BYO = 1, BXO = NQBIL (=1728 for PAL, for NTSC this is 858*2) - NumByte3 (=1440) = 288 */
-		WRITE_RPS1(((1728-(vbi_pixel_to_capture)) << 7) | MASK_19);
-		/* wait for brs_done */
-		WRITE_RPS1(CMD_PAUSE | MASK_08);
-		/* upload brs */
-		WRITE_RPS1(CMD_UPLOAD | MASK_08);
-		/* load video-dma3 NumLines3 and NumBytes3 */
-		WRITE_RPS1(CMD_WR_REG | (1 << 8) | (NUM_LINE_BYTE3/4));
-		/* dev->vbi_count*2 lines, 720 pixel (= 1440 Bytes) */
-		WRITE_RPS1((2 << 16) | (vbi_pixel_to_capture));
-		/* load brs-control register */
-		WRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));
-		/* Set BRS right: note: this is an experimental value for BXO (=> PAL!) */
-		WRITE_RPS1((540 << 7) | (5 << 19));  // 5 == vbi_start  
-		/* wait for brs_done */
-		WRITE_RPS1(CMD_PAUSE | MASK_08);
-		/* upload brs and video-dma3*/
-		WRITE_RPS1(CMD_UPLOAD | MASK_08 | MASK_04);
-		/* load mc2 register: enable dma3 */
-		WRITE_RPS1(CMD_WR_REG | (1 << 8) | (MC1/4));
-		WRITE_RPS1(MASK_20 | MASK_04);
-		/* generate interrupt */
-		WRITE_RPS1(CMD_INTERRUPT);
-		/* stop rps1 */
-		WRITE_RPS1(CMD_STOP);
+	/* upload brs */
+	WRITE_RPS1(CMD_UPLOAD | MASK_08);
+	/* load brs-control register */
+	WRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));
+	/* BYO = 1, BXO = NQBIL (=1728 for PAL, for NTSC this is 858*2) - NumByte3 (=1440) = 288 */
+	WRITE_RPS1(((1728-(vbi_pixel_to_capture)) << 7) | MASK_19);
+	/* wait for brs_done */
+	WRITE_RPS1(CMD_PAUSE | MASK_08);
+	/* upload brs */
+	WRITE_RPS1(CMD_UPLOAD | MASK_08);
+	/* load video-dma3 NumLines3 and NumBytes3 */
+	WRITE_RPS1(CMD_WR_REG | (1 << 8) | (NUM_LINE_BYTE3/4));
+	/* dev->vbi_count*2 lines, 720 pixel (= 1440 Bytes) */
+	WRITE_RPS1((2 << 16) | (vbi_pixel_to_capture));
+	/* load brs-control register */
+	WRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));
+	/* Set BRS right: note: this is an experimental value for BXO (=> PAL!) */
+	WRITE_RPS1((540 << 7) | (5 << 19));  // 5 == vbi_start  
+	/* wait for brs_done */
+	WRITE_RPS1(CMD_PAUSE | MASK_08);
+	/* upload brs and video-dma3*/
+	WRITE_RPS1(CMD_UPLOAD | MASK_08 | MASK_04);
+	/* load mc2 register: enable dma3 */
+	WRITE_RPS1(CMD_WR_REG | (1 << 8) | (MC1/4));
+	WRITE_RPS1(MASK_20 | MASK_04);
+	/* generate interrupt */
+	WRITE_RPS1(CMD_INTERRUPT);
+	/* stop rps1 */
+	WRITE_RPS1(CMD_STOP);
 	
 	/* we have to do the workaround twice to be sure that
 	   everything is ok */
@@ -154,6 +154,7 @@ void saa7146_set_vbi_capture(struct saa7
 	vdma3.pitch	= vbi_pixel_to_capture;
 	vdma3.base_page	= buf->pt[2].dma | ME1;
 	vdma3.num_line_byte = (16 << 16) | vbi_pixel_to_capture;
+
 	saa7146_write_out_dma(dev, 3, &vdma3);
 
 	/* write beginning of rps-program */
@@ -245,7 +246,7 @@ static int buffer_prepare(struct file *f
 		saa7146_pgtable_free(dev->pci, &buf->pt[2]);
 		saa7146_pgtable_alloc(dev->pci, &buf->pt[2]);
 
-		err = videobuf_iolock(dev->pci,&buf->vb,NULL);
+		err = videobuf_iolock(dev->pci,&buf->vb, NULL);
 		if (err)
 			goto oops;
 		err = saa7146_pgtable_build_single(dev->pci, &buf->pt[2], buf->vb.dma.sglist, buf->vb.dma.sglen);
@@ -315,7 +316,7 @@ static void vbi_stop(struct saa7146_fh *
 	struct saa7146_vv *vv = dev->vv_data;
 	unsigned long flags;
 	DEB_VBI(("dev:%p, fh:%p\n",dev, fh));
-	
+
 	spin_lock_irqsave(&dev->slock,flags);
 
 	/* disable rps1  */
@@ -424,8 +425,8 @@ static int vbi_open(struct saa7146_dev *
 	}
 
 	/* upload brs register */
-	saa7146_write(dev, MC2, (MASK_08|MASK_24));		
-	return 0;
+	saa7146_write(dev, MC2, (MASK_08|MASK_24));
+	return 0;		
 }
 
 static void vbi_close(struct saa7146_dev *dev, struct file *file)
diff -up linux-2.6.9-rc2/drivers/media/common/saa7146_video.c linux/drivers/media/common/saa7146_video.c
--- linux-2.6.9-rc2/drivers/media/common/saa7146_video.c	2004-09-14 10:36:40.000000000 +0200
+++ linux/drivers/media/common/saa7146_video.c	2004-09-17 14:56:38.664626345 +0200
@@ -38,6 +38,13 @@ static struct saa7146_format formats[] =
 		.depth		= 32,
 		.flags		= 0,
 	}, {
+		.name 		= "RGB-32 (R-G-B)",
+		.pixelformat	= V4L2_PIX_FMT_RGB32,
+		.trans 		= RGB32_COMPOSED,
+		.depth		= 32,
+		.flags		= 0,
+		.swap		= 0x2,
+	}, {
 		.name 		= "Greyscale-8",
 		.pixelformat	= V4L2_PIX_FMT_GREY,
 		.trans 		= Y8,
@@ -183,7 +190,7 @@ static int try_fmt(struct saa7146_fh *fh
 		enum v4l2_field field;
 		int maxw, maxh;
 		int calc_bpl;
-
+		
 		DEB_EE(("V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p, fh:%p\n",dev,fh));
 
 		fmt = format_by_fourcc(dev,f->fmt.pix.pixelformat);
@@ -270,23 +277,23 @@ int saa7146_start_preview(struct saa7146
 	if (IS_CAPTURE_ACTIVE(fh) != 0) {
 		DEB_D(("streaming capture is active.\n"));
 		return -EBUSY;
-		}
+	}
 
 	/* check if overlay is running */
 	if (IS_OVERLAY_ACTIVE(fh) != 0) {		
 		if (vv->video_fh == fh) {
-		DEB_D(("overlay is already active.\n"));
-		return 0;
-	}
+			DEB_D(("overlay is already active.\n"));
+			return 0;
+		}
 		DEB_D(("overlay is already active in another open.\n"));
 		return -EBUSY;
 	}
-	
+
 	if (0 == saa7146_res_get(fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP)) {
 		DEB_D(("cannot get necessary overlay resources\n"));
 		return -EBUSY;
-	}	
-	
+	}
+
 	err = try_win(dev,&fh->ov.win);
 	if (0 != err) {
 		saa7146_res_free(vv->video_fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);
@@ -324,7 +331,7 @@ int saa7146_stop_preview(struct saa7146_
 		DEB_D(("streaming capture is active.\n"));
 		return -EBUSY;
 	}
-
+	
 	/* check if overlay is running at all */
 	if ((vv->video_status & STATUS_OVERLAY) == 0) {		
 		DEB_D(("no active overlay.\n"));
@@ -340,7 +347,7 @@ int saa7146_stop_preview(struct saa7146_
 	vv->video_fh = NULL;
 
 	saa7146_disable_overlay(fh);
-	
+
 	saa7146_res_free(fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);
 
 	return 0;
@@ -388,8 +395,8 @@ static int s_fmt(struct saa7146_fh *fh, 
 
 		/* check if our current overlay is active */
 		if (IS_OVERLAY_ACTIVE(fh) != 0) {
-				saa7146_stop_preview(fh);
-				saa7146_start_preview(fh);
+			saa7146_stop_preview(fh);
+			saa7146_start_preview(fh);
 		}
 		return 0;
 	default:
@@ -573,8 +580,8 @@ static int set_control(struct saa7146_fh
 	up(&dev->lock);
 	
 	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-				saa7146_stop_preview(fh);
-				saa7146_start_preview(fh);
+		saa7146_stop_preview(fh);
+		saa7146_start_preview(fh);
 	}
 	return 0;
 }
@@ -634,7 +641,7 @@ static int saa7146_pgtable_build(struct 
 		/* walk all pages, copy all page addresses to ptr1 */
 		for (i = 0; i < length; i++, list++) {
 			for (p = 0; p * 4096 < list->length; p++, ptr1++) {
-				*ptr1 = sg_dma_address(list) - list->offset;
+				*ptr1 = cpu_to_le32(sg_dma_address(list) - list->offset);
 			}
 		}
 /*
@@ -712,13 +719,13 @@ static int video_begin(struct saa7146_fh
 
 	if ((vv->video_status & STATUS_CAPTURE) != 0) {
 		if (vv->video_fh == fh) {
-		DEB_S(("already capturing.\n"));
+			DEB_S(("already capturing.\n"));
 			return 0;
-	}
+		}
 		DEB_S(("already capturing in another open.\n"));
 		return -EBUSY;
 	}
-
+	
 	if ((vv->video_status & STATUS_OVERLAY) != 0) {
 		DEB_S(("warning: suspending overlay video for streaming capture.\n"));
 		vv->ov_suspend = vv->video_fh;
@@ -748,7 +755,7 @@ static int video_begin(struct saa7146_fh
 		}
 		return -EBUSY;
 	}
-
+	
 	/* clear out beginning of streaming bit (rps register 0)*/
 	saa7146_write(dev, MC2, MASK_27 );
 
@@ -804,7 +811,7 @@ static int video_end(struct saa7146_fh *
 	saa7146_write(dev, MC1, dmas);
 
 	spin_unlock_irqrestore(&dev->slock, flags);
-	
+
 	vv->video_fh = NULL;
 	vv->video_status = 0;
 
@@ -813,8 +820,8 @@ static int video_end(struct saa7146_fh *
 	if (vv->ov_suspend != NULL) {
 		saa7146_start_preview(vv->ov_suspend);
 		vv->ov_suspend = NULL;
-}
-
+	}
+	
 	return 0;
 }
 
@@ -908,7 +915,7 @@ int saa7146_video_do_ioctl(struct inode 
 		struct saa7146_format *fmt;
 
 		DEB_EE(("VIDIOC_S_FBUF\n"));
-
+		
 		if(!capable(CAP_SYS_ADMIN) &&
 		   !capable(CAP_SYS_RAWIO))
 			return -EPERM;
@@ -929,7 +936,7 @@ int saa7146_video_do_ioctl(struct inode 
 			if (vv->video_fh != fh) {
 				DEB_D(("refusing to change framebuffer informations while overlay is active in another open.\n"));
 				return -EBUSY;
-		}
+			}
 		}
 
 		down(&dev->lock);
@@ -999,10 +1006,10 @@ int saa7146_video_do_ioctl(struct inode 
 		return get_control(fh,arg);
 	}
 	case VIDIOC_S_CTRL:
-
-
-
-
+/* FIXME: remove when videodev2.h update is in kernel */
+#ifdef VIDIOC_S_CTRL_OLD
+	case VIDIOC_S_CTRL_OLD:
+#endif
 	{
 		DEB_EE(("VIDIOC_S_CTRL\n"));
 		err = set_control(fh,arg);
@@ -1066,7 +1073,7 @@ int saa7146_video_do_ioctl(struct inode 
 		v4l2_std_id *id = arg;
 		int found = 0;
 		int i, err;
-						
+		
 		DEB_EE(("VIDIOC_S_STD\n"));
 
 		if ((vv->video_status & STATUS_CAPTURE) == STATUS_CAPTURE) {
@@ -1111,10 +1118,10 @@ int saa7146_video_do_ioctl(struct inode 
 		return 0;
 	}
 	case VIDIOC_OVERLAY:
-
-
-
-
+/* FIXME: remove when videodev2.h update is in kernel */
+#ifdef VIDIOC_OVERLAY_OLD
+	case VIDIOC_OVERLAY_OLD:
+#endif
 	{
 		int on = *(int *)arg;
 		int err = 0;
@@ -1154,11 +1161,11 @@ int saa7146_video_do_ioctl(struct inode 
 	case VIDIOC_STREAMON: {
 		int *type = arg;
 		DEB_D(("VIDIOC_STREAMON, type:%d\n",*type));
-
+	
 		err = video_begin(fh);
 		if( 0 != err) {
-				return err;
-			}
+			return err;
+		}
 		err = videobuf_streamon(file,q);
 		return err;
 	}
@@ -1183,7 +1190,7 @@ int saa7146_video_do_ioctl(struct inode 
 		err = videobuf_streamoff(file,q);
 		if (0 != err) {
 			DEB_D(("warning: videobuf_streamoff() failed.\n"));
-		video_end(fh, file);
+			video_end(fh, file);
 		} else {
 			err = video_end(fh, file);
 		}
@@ -1427,7 +1434,7 @@ static void video_close(struct saa7146_d
 	} else if (IS_OVERLAY_ACTIVE(fh) != 0) {
 		err = saa7146_stop_preview(fh);
 	}
-	
+		
 	/* hmm, why is this function declared void? */
 	/* return err */
 }
@@ -1456,15 +1463,15 @@ static ssize_t video_read(struct file *f
 	struct saa7146_dev *dev = fh->dev;
 	struct saa7146_vv *vv = dev->vv_data;
 	ssize_t ret = 0;
-
+	
 	DEB_EE(("called.\n"));
 
 	if ((vv->video_status & STATUS_CAPTURE) != 0) {
-	/* fixme: should we allow read() captures while streaming capture? */
+		/* fixme: should we allow read() captures while streaming capture? */
 		if (vv->video_fh == fh) {
-		DEB_S(("already capturing.\n"));
-		return -EBUSY;
-	}
+			DEB_S(("already capturing.\n"));
+			return -EBUSY;
+		}
 		DEB_S(("already capturing in another open.\n"));
 		return -EBUSY;
 	}
@@ -1476,7 +1483,7 @@ static ssize_t video_read(struct file *f
 
 	ret = videobuf_read_one(file,&fh->video_q , data, count, ppos);
 	if (ret != 0) {
-	video_end(fh, file);
+		video_end(fh, file);
 	} else {
 		ret = video_end(fh, file);
 	}
@@ -1486,7 +1493,7 @@ out:
 		saa7146_start_preview(vv->ov_suspend);
 		vv->ov_suspend = NULL;
 	}
-	
+
 	return ret;
 }
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/Kconfig linux/drivers/media/dvb/Kconfig
--- linux-2.6.9-rc2/drivers/media/dvb/Kconfig	2004-09-14 10:35:02.000000000 +0200
+++ linux/drivers/media/dvb/Kconfig	2004-09-17 14:56:38.666625970 +0200
@@ -8,24 +8,15 @@ config DVB
 	bool "DVB For Linux"
 	depends on NET && INET
 	---help---
-	  Support Digital Video Broadcasting hardware.  Enable this if you 
-	  own a DVB adapter and want to use it or if you compile Linux for 
+	  Support Digital Video Broadcasting hardware.  Enable this if you
+	  own a DVB adapter and want to use it or if you compile Linux for
 	  a digital SetTopBox.
 
-	  API specs and user tools are available from
-	  <http://www.linuxtv.org/>. 
+	  API specs and user tools are available from <http://www.linuxtv.org/>.
 
-	  Please report problems regarding this driver to the LinuxDVB 
+	  Please report problems regarding this driver to the LinuxDVB
 	  mailing list.
 
-	  You might want add the following lines to your /etc/modules.conf:
-	  	
-	  	alias char-major-250 dvb
-	  	alias dvb dvb-ttpci
-	  	below dvb-ttpci alps_bsru6 alps_bsrv2 \
-	  			grundig_29504-401 grundig_29504-491 \
-	  			ves1820
-
 	  If unsure say N.
 
 source "drivers/media/dvb/dvb-core/Kconfig"
@@ -40,6 +31,7 @@ comment "Supported USB Adapters"
 	depends on DVB_CORE && USB
 source "drivers/media/dvb/ttusb-budget/Kconfig"
 source "drivers/media/dvb/ttusb-dec/Kconfig"
+source "drivers/media/dvb/dibusb/Kconfig"
 
 comment "Supported FlexCopII (B2C2) Adapters"
 	depends on DVB_CORE && PCI
@@ -50,4 +42,3 @@ comment "Supported BT878 Adapters"
 source "drivers/media/dvb/bt8xx/Kconfig"
 
 endmenu
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/Makefile linux/drivers/media/dvb/Makefile
--- linux-2.6.9-rc2/drivers/media/dvb/Makefile	2004-09-14 10:36:20.000000000 +0200
+++ linux/drivers/media/dvb/Makefile	2004-09-17 14:56:38.667625783 +0200
@@ -2,5 +2,4 @@
 # Makefile for the kernel multimedia device drivers.
 #
 
-obj-y        := dvb-core/ frontends/ ttpci/ ttusb-dec/ ttusb-budget/ b2c2/ bt8xx/
-
+obj-y        := dvb-core/ frontends/ ttpci/ ttusb-dec/ ttusb-budget/ b2c2/ bt8xx/ dibusb/
diff -up linux-2.6.9-rc2/drivers/media/dvb/b2c2/skystar2.c linux/drivers/media/dvb/b2c2/skystar2.c
--- linux-2.6.9-rc2/drivers/media/dvb/b2c2/skystar2.c	2004-09-14 10:38:23.000000000 +0200
+++ linux/drivers/media/dvb/b2c2/skystar2.c	2004-09-17 14:56:38.674624471 +0200
@@ -12,10 +12,10 @@
  * Misc reorganization, polishing, restyling
  *     Roberto Ragusa, r.ragusa at libero.it
  *       
- * Added hardware filtering support, 
+ * Added hardware filtering support,
  *     Niklas Peinecke, peinecke at gdv.uni-hannover.de
  *
- *
+ * 	
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public License
  * as published by the Free Software Foundation; either version 2.1
@@ -30,14 +30,16 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
+
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <linux/version.h>
 
 #include <asm/io.h>
 
-#include "dvb_i2c.h"
 #include "dvb_frontend.h"
 
 #include <linux/dvb/frontend.h>
@@ -49,12 +51,17 @@
 #include "demux.h"
 #include "dvb_net.h"
 
-#include "dvb_functions.h"
 
-static int debug = 0;
+static int debug;
+static int enable_hw_filters = 2;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Set debugging level (0 = default, 1 = most messages, 2 = all messages).");
+module_param(enable_hw_filters, int, 0444);
+MODULE_PARM_DESC(enable_hw_filters, "enable hardware filters: supported values: 0 (none), 1, 2");
+
 #define dprintk(x...)	do { if (debug>=1) printk(x); } while (0)
 #define ddprintk(x...)	do { if (debug>=2) printk(x); } while (0)
-static int enable_hw_filters = 2;
 
 #define SIZE_OF_BUF_DMA1	0x3ac00
 #define SIZE_OF_BUF_DMA2	0x758
@@ -89,7 +96,7 @@ struct adapter {
 	struct dmxdev dmxdev;
 	struct dmx_frontend hw_frontend;
 	struct dmx_frontend mem_frontend;
-	struct dvb_i2c_bus *i2c_bus;
+	struct i2c_adapter i2c_adap;	
 	struct dvb_net dvbnet;
 
 	struct semaphore i2c_sem;
@@ -277,9 +284,9 @@ static u32 flex_i2c_write(struct adapter
 	return buf - start;
 }
 
-static int master_xfer(struct dvb_i2c_bus *i2c, const struct i2c_msg *msgs, int num)
+static int master_xfer(struct i2c_adapter* adapter, struct i2c_msg msgs[], int num)
 {
-	struct adapter *tmp = i2c->data;
+	struct adapter *tmp = i2c_get_adapdata(adapter);
 	int i, ret = 0;
 
 	if (down_interruptible(&tmp->i2c_sem))
@@ -287,16 +294,16 @@ static int master_xfer(struct dvb_i2c_bu
 
 	ddprintk("%s: %d messages to transfer\n", __FUNCTION__, num);
 
-		for (i = 0; i < num; i++) {
+	for (i = 0; i < num; i++) {
 		ddprintk("message %d: flags=0x%x, addr=0x%x, buf=0x%x, len=%d \n", i,
 			 msgs[i].flags, msgs[i].addr, msgs[i].buf[0], msgs[i].len);
-	
-		/* allow only the mt312 and stv0299 frontends to access the bus */
-		if ((msgs[i].addr != 0x0e) && (msgs[i].addr != 0x68) && (msgs[i].addr != 0x61)) {
-		up(&tmp->i2c_sem);
 
-		return -EREMOTEIO;
-	}
+		/* allow only the mt312, mt352 and stv0299 frontends to access the bus */
+		if ((msgs[i].addr != 0x0e) && (msgs[i].addr != 0x68) &&
+		    (msgs[i].addr != 0x61) && (msgs[i].addr != 0x0f)) {
+			up(&tmp->i2c_sem);
+			return -EREMOTEIO;
+		}
 	}
 
 	// read command
@@ -312,7 +319,7 @@ static int master_xfer(struct dvb_i2c_bu
 			for (i = 0; i < 2; i++) {
 				printk("message %d: flags=0x%x, addr=0x%x, buf=0x%x, len=%d \n", i,
 				       msgs[i].flags, msgs[i].addr, msgs[i].buf[0], msgs[i].len);
-		}
+			}
 
 			return -EREMOTEIO;
 		}
@@ -363,7 +370,7 @@ static void sram_set_net_dest(struct ada
 
 	udelay(1000);
 
-	/* return value is never used? */
+	/*return value is never used? */
 /*	return tmp; */
 }
 
@@ -383,7 +390,7 @@ static void sram_set_cai_dest(struct ada
 
 	udelay(1000);
 
-	/* return value is never used? */
+	/*return value is never used? */
 /*	return tmp; */
 }
 
@@ -403,7 +410,7 @@ static void sram_set_cao_dest(struct ada
 
 	udelay(1000);
 
-	/* return value is never used? */
+	/*return value is never used? */
 /*	return tmp; */
 }
 
@@ -547,8 +554,8 @@ static void sram_read(struct adapter *ad
 	while (len != 0) {
 		length = len;
 
-		// check if the address range belongs to the same 
-		// 32K memory chip. If not, the data is read from 
+		// check if the address range belongs to the same
+		// 32K memory chip. If not, the data is read from
 		// one chip at a time.
 		if ((addr >> 0x0f) != ((addr + len - 1) >> 0x0f)) {
 			length = (((addr >> 0x0f) + 1) << 0x0f) - addr;
@@ -569,7 +576,7 @@ static void sram_write(struct adapter *a
 	while (len != 0) {
 		length = len;
 
-		// check if the address range belongs to the same 
+		// check if the address range belongs to the same
 		// 32K memory chip. If not, the data is written to
 		// one chip at a time.
 		if ((addr >> 0x0f) != ((addr + len - 1) >> 0x0f)) {
@@ -668,7 +675,7 @@ static u32 sram_length(struct adapter *a
 	if (adapter->dw_sram_type == 0x10000)
 		return 32768;	//  32K
 	if (adapter->dw_sram_type == 0x00000)
-		return 65536;	//  64K        
+		return 65536;	//  64K
 	if (adapter->dw_sram_type == 0x20000)
 		return 131072;	// 128K
 
@@ -682,7 +689,7 @@ static u32 sram_length(struct adapter *a
 
    FlexCop works only with one bank at a time. The bank is selected
    by bits 28-29 of the 0x700 register.
-  
+
    bank 0 covers addresses 0x00000-0x07fff
    bank 1 covers addresses 0x08000-0x0ffff
    bank 2 covers addresses 0x10000-0x17fff
@@ -765,7 +772,7 @@ static void sll_detect_sram_size(struct 
 	sram_detect_for_flex2(adapter);
 }
 
-/* EEPROM (Skystar2 has one "24LC08B" chip on board) */
+/*EEPROM (Skystar2 has one "24LC08B" chip on board) */
 /*
 static int eeprom_write(struct adapter *adapter, u16 addr, u8 *buf, u16 len)
 {
@@ -1092,7 +1099,7 @@ static void init_pids(struct adapter *ad
 		dprintk("%s: setting filter %d to 0x1fff\n", __FUNCTION__, i);
 		adapter->hw_pids[i] = 0x1fff;
 		pid_set_hw_pid(adapter, i, 0x1fff);
-}
+	}
 
 	pid_set_group_pid(adapter, 0);
 	pid_set_group_mask(adapter, 0x1fe0);
@@ -1155,15 +1162,15 @@ static int add_hw_pid(struct adapter *ad
 				adapter->hw_pids[i] = pid;
 				pid_set_hw_pid(adapter, i, pid);
 				filter_enable_hw_filter(adapter, i, 1);
-		return 1;
-	}
-	}
+				return 1;
+			}
+		}
 	}
 	/* if we have not used a filter, this pid depends on whole bandwidth */
 	dprintk("%s: pid=%d whole_bandwidth\n", __FUNCTION__, pid);
 	whole_bandwidth_inc(adapter);
-		return 1;
-	}
+	return 1;
+}
 
 /* returns -1 if the pid was not present in the filters */
 static int remove_hw_pid(struct adapter *adapter, u16 pid)
@@ -1184,15 +1191,15 @@ static int remove_hw_pid(struct adapter 
 				adapter->hw_pids[i] = 0x1fff;
 				pid_set_hw_pid(adapter, i, 0x1fff);
 				filter_enable_hw_filter(adapter, i, 0);
-		return 1;
-	}
-	}
+				return 1;
+			}
+		}
 	}
 	/* if we have not used a filter, this pid depended on whole bandwith */
 	dprintk("%s: pid=%d whole_bandwidth\n", __FUNCTION__, pid);
 	whole_bandwidth_dec(adapter);
-		return 1;
-	}
+	return 1;
+}
 
 /* Adds a PID to the filters.
    Adding a pid more than once is possible, we keep reference counts.
@@ -1211,7 +1218,7 @@ static int add_pid(struct adapter *adapt
 	for (i = 0; i < adapter->pid_count; i++)
 		if (adapter->pid_list[i] == pid) {
 			adapter->pid_rc[i]++;	// increment ref counter
-		return 1;
+			return 1;
 		}
 
 	if (adapter->pid_count == N_PID_SLOTS)
@@ -1222,8 +1229,8 @@ static int add_pid(struct adapter *adapt
 	// hardware setting
 	add_hw_pid(adapter, pid);
 
-			return 1;
-		}
+	return 1;
+}
 
 /* Removes a PID from the filters. */
 static int remove_pid(struct adapter *adapter, u16 pid)
@@ -1250,7 +1257,6 @@ static int remove_pid(struct adapter *ad
 			return 1;
 		}
 	}
-
 	return -1;
 }
 
@@ -1313,7 +1319,7 @@ static void irq_dma_enable_disable_irq(s
        subbuffer size in 32-bit words is stored in the first 24 bits of
        register 0x004. The last 8 bits of register 0x004 contain the number
        of subbuffers.
-       
+
        the first 30 bits of register 0x000 contain the address of the first
        subbuffer. The last 2 bits contain 0, when dma1 is disabled and 1,
        when dma1 is enabled.
@@ -1328,7 +1334,7 @@ static void irq_dma_enable_disable_irq(s
        subbuffer size in 32-bit words is stored in the first 24 bits of
        register 0x014. The last 8 bits of register 0x014 contain the number
        of subbuffers.
-       
+
        the first 30 bits of register 0x010 contain the address of the first
        subbuffer.  The last 2 bits contain 0, when dma1 is disabled and 1,
        when dma1 is enabled.
@@ -1494,20 +1500,20 @@ static void dma_start_stop(struct adapte
 		if (((dma_mask & 2) != 0) && ((adapter->dma_status & 2) != 0)) {
 			dma_enable = dma_enable & 0xfffffffd;
 		}
-		//stop dma
+		// stop dma
 		if ((dma_enable == 0) && ((adapter->dma_status & 4) != 0)) {
 			ctrl_enable_receive_data(adapter, 0);
 
 			udelay(3000);
 		}
-		//disable dma1
+		// disable dma1
 		if (((dma_mask & 1) != 0) && ((adapter->dma_status & 1) != 0) && (adapter->dmaq1.bus_addr != 0)) {
 			write_reg_dw(adapter, 0x000, adapter->dmaq1.bus_addr);
 			write_reg_dw(adapter, 0x00c, (adapter->dmaq1.bus_addr + adapter->dmaq1.buffer_size / 2) | 1);
 
 			adapter->dma_status = adapter->dma_status & ~0x00000001;
 		}
-		//disable dma2
+		// disable dma2
 		if (((dma_mask & 2) != 0) && ((adapter->dma_status & 2) != 0) && (adapter->dmaq2.bus_addr != 0)) {
 			write_reg_dw(adapter, 0x010, adapter->dmaq2.bus_addr);
 
@@ -1565,14 +1571,14 @@ static void close_stream(struct adapter 
 	if (adapter->capturing == 0) {
 		u32 dma_mask = 0;
 
-	if ((adapter->dma_status & 1) != 0)
-		dma_mask = dma_mask | 0x00000001;
-	if ((adapter->dma_status & 2) != 0)
-		dma_mask = dma_mask | 0x00000002;
+		if ((adapter->dma_status & 1) != 0)
+			dma_mask = dma_mask | 0x00000001;
+		if ((adapter->dma_status & 2) != 0)
+			dma_mask = dma_mask | 0x00000002;
 
-	if (dma_mask != 0) {
+		if (dma_mask != 0) {
 			dma_start_stop(adapter, dma_mask, 0);
-	}
+		}
 	}
 	remove_pid(adapter, pid);
 }
@@ -1659,7 +1665,7 @@ static irqreturn_t isr(int irq, void *de
 		spin_unlock_irq(&tmp->lock);
 		return IRQ_NONE;
 	}
-	
+
 	while (value != 0) {
 		if ((value & 0x03) != 0)
 			interrupt_service_dma1(tmp);
@@ -1826,7 +1832,7 @@ static void decide_how_many_hw_filters(s
 	int hw_filters;
 	int mod_option_hw_filters;
 
-	// FlexCop IIb & III have 6+32 hw filters    
+	// FlexCop IIb & III have 6+32 hw filters
 	// FlexCop II has 6 hw filters, every other should have at least 6
 	switch (adapter->b2c2_revision) {
 	case 0x82:		/* II */
@@ -1873,7 +1879,7 @@ static int driver_initialize(struct pci_
 
 	memset(adapter, 0, sizeof(struct adapter));
 
-	pci_set_drvdata(pdev,adapter);
+	pci_set_drvdata(pdev, adapter);
 
 	adapter->pdev = pdev;
 	adapter->irq = pdev->irq;
@@ -1926,8 +1932,8 @@ static int driver_initialize(struct pci_
 		pci_set_drvdata(pdev, NULL);
 		release_region(pci_resource_start(pdev, 1), pci_resource_len(pdev, 1));
 		release_mem_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
-			return -ENODEV;
-		}
+		return -ENODEV;
+	}
 
 	decide_how_many_hw_filters(adapter);
 
@@ -2089,7 +2095,7 @@ static void diseqc_send_bit(struct adapt
 
 
 static void diseqc_send_byte(struct adapter *adapter, int data)
-		{
+{
 	int i, par = 1, d;
 
 	for (i = 7; i >= 0; i--) {
@@ -2099,7 +2105,7 @@ static void diseqc_send_byte(struct adap
 	}
 
 	diseqc_send_bit(adapter, par);
-		}
+}
 
 
 static int send_diseqc_msg(struct adapter *adapter, int len, u8 *msg, unsigned long burst)
@@ -2122,7 +2128,7 @@ static int send_diseqc_msg(struct adapte
 			udelay(12500);
 			set_tuner_tone(adapter, 0);
 		}
-		dvb_delay(20);
+		msleep(20);
 	}
 
 	return 0;
@@ -2139,10 +2145,10 @@ int soft_diseqc(struct adapter *adapter,
 			break;
 		case SEC_TONE_OFF:
 			set_tuner_tone(adapter, 0);
-				break;
-			default:
-				return -EINVAL;
-			};
+			break;
+		default:
+			return -EINVAL;
+		};
 		break;
 
 	case FE_DISEQC_SEND_MASTER_CMD:
@@ -2165,7 +2171,7 @@ int soft_diseqc(struct adapter *adapter,
 }
 
 static int flexcop_diseqc_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
-		{
+{
 	struct adapter *adapter = fe->before_after_data;
 
 	struct dvb_frontend_info info;
@@ -2223,11 +2229,50 @@ static int flexcop_diseqc_ioctl(struct d
 	default:
 
 		return -EOPNOTSUPP;
+
 	};
 
 	return 0;
 }
 
+
+static int client_register(struct i2c_client *client)
+{
+	struct adapter *adapter = (struct adapter*)i2c_get_adapdata(client->adapter);
+
+	dprintk("client_register\n");
+
+	if (client->driver->command)
+		return client->driver->command(client, FE_REGISTER, adapter->dvb_adapter);
+	return 0;
+}
+
+static int client_unregister(struct i2c_client *client)
+{
+	struct adapter *adapter = (struct adapter*)i2c_get_adapdata(client->adapter);
+
+	dprintk("client_unregister\n");
+
+	if (client->driver->command)
+		return client->driver->command(client, FE_UNREGISTER, adapter->dvb_adapter);
+	return 0;
+}
+
+u32 flexcop_i2c_func(struct i2c_adapter *adapter)
+{
+	printk("flexcop_i2c_func\n");
+
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm    flexcop_algo = {
+	.name		= "flexcop i2c algorithm",
+	.id		= I2C_ALGO_BIT,
+	.master_xfer	= master_xfer,
+	.functionality	= flexcop_i2c_func,
+};
+
+
 static int skystar2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct adapter *adapter;
@@ -2258,10 +2303,27 @@ static int skystar2_probe(struct pci_dev
 
 	init_MUTEX(&adapter->i2c_sem);
 
-	adapter->i2c_bus = dvb_register_i2c_bus(master_xfer, adapter, adapter->dvb_adapter, 0);
 
-	if (!adapter->i2c_bus)
+	memset(&adapter->i2c_adap, 0, sizeof(struct i2c_adapter));
+	strcpy(adapter->i2c_adap.name, "Technisat SkyStar2 driver");
+
+	i2c_set_adapdata(&adapter->i2c_adap, adapter);
+
+#ifdef I2C_ADAP_CLASS_TV_DIGITAL
+	adapter->i2c_adap.class 	    = I2C_ADAP_CLASS_TV_DIGITAL;
+#else
+	adapter->i2c_adap.class 	    = I2C_CLASS_TV_DIGITAL;
+#endif
+	adapter->i2c_adap.algo              = &flexcop_algo;
+	adapter->i2c_adap.algo_data         = NULL;
+	adapter->i2c_adap.id                = I2C_ALGO_BIT;
+	adapter->i2c_adap.client_register   = client_register;
+	adapter->i2c_adap.client_unregister = client_unregister;
+
+	if (i2c_add_adapter(&adapter->i2c_adap) < 0) {
+		dvb_unregister_adapter (adapter->dvb_adapter);
 		return -ENOMEM;
+	}
 
 	dvb_add_frontend_ioctls(adapter->dvb_adapter, flexcop_diseqc_ioctl, NULL, adapter);
 
@@ -2327,8 +2389,7 @@ static void skystar2_remove(struct pci_d
 		if (adapter->dvb_adapter != NULL) {
 			dvb_remove_frontend_ioctls(adapter->dvb_adapter, flexcop_diseqc_ioctl, NULL);
 
-			if (adapter->i2c_bus != NULL)
-				dvb_unregister_i2c_bus(master_xfer, adapter->i2c_bus->adapter, adapter->i2c_bus->id);
+			i2c_del_adapter(&adapter->i2c_adap);
 
 			dvb_unregister_adapter(adapter->dvb_adapter);
 		}
@@ -2345,7 +2406,7 @@ static struct pci_device_id skystar2_pci
 MODULE_DEVICE_TABLE(pci, skystar2_pci_tbl);
 
 static struct pci_driver skystar2_pci_driver = {
-	.name = "SkyStar2",
+	.name = "Technisat SkyStar2 driver",
 	.id_table = skystar2_pci_tbl,
 	.probe = skystar2_probe,
 	.remove = skystar2_remove,
@@ -2364,10 +2425,5 @@ static void skystar2_cleanup(void)
 module_init(skystar2_init);
 module_exit(skystar2_cleanup);
 
-MODULE_PARM(debug, "i");
-MODULE_PARM_DESC(debug, "enable verbose debug messages: supported values: 1 and 2");
-MODULE_PARM(enable_hw_filters, "i");
-MODULE_PARM_DESC(enable_hw_filters, "enable hardware filters: supported values: 0 (none), 1, 2");
-
 MODULE_DESCRIPTION("Technisat SkyStar2 DVB PCI Driver");
 MODULE_LICENSE("GPL");
diff -up linux-2.6.9-rc2/drivers/media/dvb/bt8xx/Kconfig linux/drivers/media/dvb/bt8xx/Kconfig
--- linux-2.6.9-rc2/drivers/media/dvb/bt8xx/Kconfig	2004-09-14 10:35:20.000000000 +0200
+++ linux/drivers/media/dvb/bt8xx/Kconfig	2004-09-17 14:56:38.675624284 +0200
@@ -1,13 +1,16 @@
 config DVB_BT8XX
-	tristate "Nebula/Pinnacle PCTV PCI cards"
+	tristate "Nebula/Pinnacle PCTV/Twinhan PCI cards"
 	depends on DVB_CORE && PCI && VIDEO_BT848
 	help
 	  Support for PCI cards based on the Bt8xx PCI bridge. Examples are
-	  the Nebula cards, the Pinnacle PCTV cards, and Twinhan DST cards.
+	  the Nebula cards, the Pinnacle PCTV cards and Twinhan DST cards.
 
           Since these cards have no MPEG decoder onboard, they transmit
 	  only compressed MPEG data over the PCI bus, so you need
 	  an external software decoder to watch TV on your computer.
 
-	  Say Y if you own such a device and want to use it.
+	  If you have a Twinhan card, don't forget to select
+	  "Twinhan DST based DVB-S/-T frontend".
 
+	  Say Y if you own such a device and want to use it.
+	  
diff -up linux-2.6.9-rc2/drivers/media/dvb/bt8xx/bt878.c linux/drivers/media/dvb/bt8xx/bt878.c
--- linux-2.6.9-rc2/drivers/media/dvb/bt8xx/bt878.c	2004-09-14 10:35:55.000000000 +0200
+++ linux/drivers/media/dvb/bt8xx/bt878.c	2004-09-17 14:56:38.678623722 +0200
@@ -27,8 +27,8 @@
  * 
  */
 
-#include <linux/version.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <asm/io.h>
@@ -46,20 +46,19 @@
 #include "bt878.h"
 #include "dst-bt878.h"
 
-#include "dvb_functions.h"
 
 /**************************************/
 /* Miscellaneous utility  definitions */
 /**************************************/
 
-unsigned int bt878_verbose = 1;
-unsigned int bt878_debug = 0;
-MODULE_PARM(bt878_verbose, "i");
+static unsigned int bt878_verbose = 1;
+static unsigned int bt878_debug;
+
+module_param_named(verbose, bt878_verbose, int, 0444);
 MODULE_PARM_DESC(bt878_verbose,
 		 "verbose startup messages, default is 1 (yes)");
-MODULE_PARM(bt878_debug, "i");
-MODULE_PARM_DESC(bt878_debug, "debug messages, default is 0 (no)");
-MODULE_LICENSE("GPL");
+module_param_named(debug, bt878_debug, int, 0644);
+MODULE_PARM_DESC(bt878_debug, "Turn on/off debugging (default:off).");
 
 int bt878_num;
 struct bt878 bt878[BT878_MAX];
@@ -339,10 +338,6 @@ static irqreturn_t bt878_irq(int irq, vo
 	return IRQ_HANDLED;
 }
 
-extern int bttv_gpio_enable(unsigned int card, unsigned long mask, unsigned long data);
-extern int bttv_read_gpio(unsigned int card, unsigned long *data);
-extern int bttv_write_gpio(unsigned int card, unsigned long mask, unsigned long data);
-
 int
 bt878_device_control(struct bt878 *bt, unsigned int cmd, union dst_gpio_packet *mp)
 {
@@ -386,20 +381,20 @@ bt878_device_control(struct bt878 *bt, u
 
 EXPORT_SYMBOL(bt878_device_control);
 
-struct bt878 *bt878_find_by_dvb_adap(struct dvb_adapter *adap)
+struct bt878 *bt878_find_by_i2c_adap(struct i2c_adapter *adapter)
 {
 	unsigned int card_nr;
 	
-	printk("bt878 find by dvb adap: checking \"%s\"\n",adap->name);
+	printk("bt878 find by dvb adap: checking \"%s\"\n",adapter->name);
 	for (card_nr = 0; card_nr < bt878_num; card_nr++) {
-		if (bt878[card_nr].adap_ptr == adap)
+		if (bt878[card_nr].adapter == adapter)
 			return &bt878[card_nr];
 	}
-	printk("bt878 find by dvb adap: NOT found \"%s\"\n",adap->name);
+	printk("bt878 find by dvb adap: NOT found \"%s\"\n",adapter->name);
 	return NULL;
 }
 
-EXPORT_SYMBOL(bt878_find_by_dvb_adap);
+EXPORT_SYMBOL(bt878_find_by_i2c_adap);
 
 /***********************/
 /* PCI device handling */
@@ -417,8 +412,6 @@ static int __devinit bt878_probe(struct 
 
 	printk(KERN_INFO "bt878: Bt878 AUDIO function found (%d).\n",
 	       bt878_num);
-	if (pci_enable_device(dev))
-		return -EIO;
 
 	bt = &bt878[bt878_num];
 	bt->dev = dev;
@@ -428,10 +421,11 @@ static int __devinit bt878_probe(struct 
 	bt->id = dev->device;
 	bt->irq = dev->irq;
 	bt->bt878_adr = pci_resource_start(dev, 0);
+	if (pci_enable_device(dev))
+		return -EIO;
 	if (!request_mem_region(pci_resource_start(dev, 0),
 				pci_resource_len(dev, 0), "bt878")) {
-		result = -EBUSY;
-		goto fail0;
+		return -EBUSY;
 	}
 
 	pci_read_config_byte(dev, PCI_CLASS_REVISION, &bt->revision);
@@ -502,8 +496,6 @@ static int __devinit bt878_probe(struct 
       fail1:
 	release_mem_region(pci_resource_start(bt->dev, 0),
 			   pci_resource_len(bt->dev, 0));
-      fail0:
-	pci_disable_device(dev);
 	return result;
 }
 
@@ -520,7 +512,7 @@ static void __devexit bt878_remove(struc
 
 	/* first disable interrupts before unmapping the memory! */
 	btwrite(0, BT878_AINT_MASK);
-	btwrite(~0U, BT878_AINT_STAT);
+	btwrite(~0x0UL, BT878_AINT_STAT);
 
 	/* disable PCI bus-mastering */
 	pci_read_config_byte(bt->dev, PCI_COMMAND, &command);
@@ -543,7 +535,6 @@ static void __devexit bt878_remove(struc
 	bt878_mem_free(bt);
 
 	pci_set_drvdata(pci_dev, NULL);
-	pci_disable_device(pci_dev);
 	return;
 }
 
@@ -611,6 +602,9 @@ EXPORT_SYMBOL(bt878_cleanup_module);
 module_init(bt878_init_module);
 module_exit(bt878_cleanup_module);
 
+//MODULE_AUTHOR("XXX");
+MODULE_LICENSE("GPL");
+
 /*
  * Local variables:
  * c-basic-offset: 8
diff -up linux-2.6.9-rc2/drivers/media/dvb/bt8xx/bt878.h linux/drivers/media/dvb/bt8xx/bt878.h
--- linux-2.6.9-rc2/drivers/media/dvb/bt8xx/bt878.h	2004-09-14 10:38:13.000000000 +0200
+++ linux/drivers/media/dvb/bt8xx/bt878.h	2004-09-17 14:56:38.680623347 +0200
@@ -26,6 +26,7 @@
 #include <linux/sched.h>
 #include <linux/spinlock.h>
 #include "bt848.h"
+#include "bttv.h"
 
 #define BT878_VERSION_CODE 0x000000
 
@@ -94,7 +95,7 @@ struct bt878 {
 	struct semaphore  gpio_lock;
 	unsigned int nr;
 	unsigned int bttv_nr;
-	struct dvb_adapter *adap_ptr;
+	struct i2c_adapter *adapter;
 	struct pci_dev *dev;
 	unsigned int id;
 	unsigned int TS_Size;
diff -up linux-2.6.9-rc2/drivers/media/dvb/bt8xx/dvb-bt8xx.c linux/drivers/media/dvb/bt8xx/dvb-bt8xx.c
--- linux-2.6.9-rc2/drivers/media/dvb/bt8xx/dvb-bt8xx.c	2004-09-14 10:34:53.000000000 +0200
+++ linux/drivers/media/dvb/bt8xx/dvb-bt8xx.c	2004-09-17 14:56:38.683622785 +0200
@@ -21,7 +21,9 @@
 
 #include <asm/bitops.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/init.h>
+#include <linux/device.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
@@ -33,33 +35,32 @@
 
 #include "dvb-bt8xx.h"
 
-#include "dvb_functions.h"
-
 #include "bt878.h"
 
-/* ID THAT MUST GO INTO i2c ids */
-#ifndef  I2C_DRIVERID_DVB_BT878A
-# define I2C_DRIVERID_DVB_BT878A I2C_DRIVERID_EXP0+10
-#endif
-
-
-#define dprintk if (debug) printk
+static int debug;
 
-extern int bttv_get_cardinfo(unsigned int card, int *type, int *cardid);
-extern struct pci_dev* bttv_get_pcidev(unsigned int card);
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off debugging (default:off).");
 
-static LIST_HEAD(card_list);
-static int debug = 0;
+#define dprintk( args... ) \
+	do { \
+		if (debug) printk(KERN_DEBUG args); \
+	} while (0)
 
 static void dvb_bt8xx_task(unsigned long data)
 {
 	struct dvb_bt8xx_card *card = (struct dvb_bt8xx_card *)data;
 
-	//printk("%d ", finished_block);
+	//printk("%d ", card->bt->finished_block);
 
 	while (card->bt->last_block != card->bt->finished_block) {
-		(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)(&card->demux, &card->bt->buf_cpu[card->bt->last_block * card->bt->block_bytes], card->bt->block_bytes);
-		card->bt->last_block = (card->bt->last_block + 1) % card->bt->block_count;
+		(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
+			(&card->demux,
+			 &card->bt->buf_cpu[card->bt->last_block *
+					    card->bt->block_bytes],
+			 card->bt->block_bytes);
+		card->bt->last_block = (card->bt->last_block + 1) %
+					card->bt->block_count;
 	}
 }
 
@@ -103,23 +104,6 @@ static int dvb_bt8xx_stop_feed(struct dv
 	return 0;
 }
 
-static int master_xfer (struct dvb_i2c_bus *i2c, const struct i2c_msg msgs[], int num)
-{
-	struct dvb_bt8xx_card *card = i2c->data;
-	int retval;
-
-	if (down_interruptible (&card->bt->gpio_lock))
-		return -ERESTARTSYS;
-
-	retval = i2c_transfer(card->i2c_adapter,
-			      (struct i2c_msg*) msgs,
-			      num);
-
-	up(&card->bt->gpio_lock);
-
-	return retval;
-}
-
 static int is_pci_slot_eq(struct pci_dev* adev, struct pci_dev* bdev)
 {
 	if ((adev->subsystem_vendor == bdev->subsystem_vendor) &&
@@ -142,168 +126,18 @@ static struct bt878 __init *dvb_bt8xx_87
 	return NULL;
 }
 
-static int __init dvb_bt8xx_card_match(unsigned int bttv_nr, char *card_name, u32 gpio_mode, u32 op_sync_orin, u32 irq_err_ignore)
-{
-	struct dvb_bt8xx_card *card;
-	struct pci_dev* bttv_pci_dev;
-
-	dprintk("dvb_bt8xx: identified card%d as %s\n", bttv_nr, card_name);
-			
-	if (!(card = kmalloc(sizeof(struct dvb_bt8xx_card), GFP_KERNEL)))
-		return -ENOMEM;
-
-	memset(card, 0, sizeof(*card));
-	card->bttv_nr = bttv_nr;
-	strncpy(card->card_name, card_name, sizeof(card_name) - 1);
-	
-	if (!(bttv_pci_dev = bttv_get_pcidev(bttv_nr))) {
-		printk("dvb_bt8xx: no pci device for card %d\n", card->bttv_nr);
-		kfree(card);
-		return -EFAULT;
-	}
-
-	if (!(card->bt = dvb_bt8xx_878_match(card->bttv_nr, bttv_pci_dev))) {
-		printk("dvb_bt8xx: unable to determine DMA core of card %d\n", card->bttv_nr);
-	
-		kfree(card);
-		return -EFAULT;
-		
-	}
-	init_MUTEX(&card->bt->gpio_lock);
-	card->bt->bttv_nr = bttv_nr;
-	card->gpio_mode = gpio_mode;
-	card->op_sync_orin = op_sync_orin;
-	card->irq_err_ignore = irq_err_ignore;
-	list_add_tail(&card->list, &card_list);
-
-	return 0;
-}
-
-static struct dvb_bt8xx_card *dvb_bt8xx_find_by_i2c_adap(struct i2c_adapter *adap)
-{
-	struct dvb_bt8xx_card *card;
-	struct list_head *item;
-	
-	printk("find by i2c adap: checking \"%s\"\n",adap->name);
-	list_for_each(item, &card_list) {
-		card = list_entry(item, struct dvb_bt8xx_card, list);
-		if (card->i2c_adapter == adap)
-			return card;
-	}
-	return NULL;
-}
-
-static struct dvb_bt8xx_card *dvb_bt8xx_find_by_pci(struct i2c_adapter *adap)
-{
-	struct dvb_bt8xx_card *card;
-	struct list_head *item;
-	struct device  *dev;
-	struct pci_dev *pci;
-	
-	printk("find by pci: checking \"%s\"\n",adap->name);
-	dev = adap->dev.parent;
-	if (NULL == dev) {
-		/* shoudn't happen with 2.6.0-test7 + newer */
-		printk("attach: Huh? i2c adapter not in sysfs tree?\n");
-		return NULL;
-	}
-	pci = to_pci_dev(dev);
-	list_for_each(item, &card_list) {
-		card = list_entry(item, struct dvb_bt8xx_card, list);
-		if (is_pci_slot_eq(pci, card->bt->dev)) {
-			return card;
-		}
-	}
-	return NULL;
-}
-
-static int dvb_bt8xx_attach(struct i2c_adapter *adap)
-{
-	struct dvb_bt8xx_card *card;
-	
-	printk("attach: checking \"%s\"\n",adap->name);
-
-	/* looking for bt878 cards ... */
-	if (adap->id != (I2C_ALGO_BIT | I2C_HW_B_BT848))
-		return 0;
-	card = dvb_bt8xx_find_by_pci(adap);
-	if (!card)
-		return 0;
-	card->i2c_adapter = adap;
-	printk("attach: \"%s\", to card %d\n",
-	       adap->name, card->bttv_nr);
-	try_module_get(adap->owner);
-
-	return 0;
-}
-
-static void dvb_bt8xx_i2c_adap_free(struct i2c_adapter *adap)
-{
-	module_put(adap->owner);
-}
-
-static int dvb_bt8xx_detach(struct i2c_adapter *adap)
-{
-	struct dvb_bt8xx_card *card;
-
-	card = dvb_bt8xx_find_by_i2c_adap(adap);
-	if (!card)
-		return 0;
-
-	/* This should not happen. We have locked the module! */
-	printk("detach: \"%s\", for card %d removed\n",
-	       adap->name, card->bttv_nr);
-	return 0;
-}
-
-static struct i2c_driver dvb_bt8xx_driver = {
-	.owner           = THIS_MODULE,
-	.name            = "dvb_bt8xx",
-        .id              = I2C_DRIVERID_DVB_BT878A,
-	.flags           = I2C_DF_NOTIFY,
-        .attach_adapter  = dvb_bt8xx_attach,
-        .detach_adapter  = dvb_bt8xx_detach,
-};
-
-static void __init dvb_bt8xx_get_adaps(void)
-{
-	i2c_add_driver(&dvb_bt8xx_driver);
-}
-
-static void __exit dvb_bt8xx_exit_adaps(void)
-{
-	i2c_del_driver(&dvb_bt8xx_driver);
-}
-
-static int __init dvb_bt8xx_load_card( struct dvb_bt8xx_card *card)
+static int __init dvb_bt8xx_load_card(struct dvb_bt8xx_card *card)
 {
 	int result;
 
-	if (!card->i2c_adapter) {
-		printk("dvb_bt8xx: unable to determine i2c adaptor of card %d, deleting\n", card->bttv_nr);
-
-		return -EFAULT;
-	
-	}
-
-	if ((result = dvb_register_adapter(&card->dvb_adapter, card->card_name, THIS_MODULE)) < 0) {
-	
+	if ((result = dvb_register_adapter(&card->dvb_adapter, card->card_name,
+					   THIS_MODULE)) < 0) {
 		printk("dvb_bt8xx: dvb_register_adapter failed (errno = %d)\n", result);
-		
-		dvb_bt8xx_i2c_adap_free(card->i2c_adapter);
 		return result;
 		
 	}
-	card->bt->adap_ptr = card->dvb_adapter;
-
-	if (!(dvb_register_i2c_bus(master_xfer, card, card->dvb_adapter, 0))) {
-		printk("dvb_bt8xx: dvb_register_i2c_bus of card%d failed\n", card->bttv_nr);
 
-		dvb_unregister_adapter(card->dvb_adapter);
-		dvb_bt8xx_i2c_adap_free(card->i2c_adapter);
-
-		return -EFAULT;
-	}
+	card->bt->adapter = card->i2c_adapter;
 
 	memset(&card->demux, 0, sizeof(struct dvb_demux));
 
@@ -319,10 +153,7 @@ static int __init dvb_bt8xx_load_card( s
 	if ((result = dvb_dmx_init(&card->demux)) < 0) {
 		printk("dvb_bt8xx: dvb_dmx_init failed (errno = %d)\n", result);
 
-		dvb_unregister_i2c_bus(master_xfer, card->dvb_adapter, 0);
 		dvb_unregister_adapter(card->dvb_adapter);
-		dvb_bt8xx_i2c_adap_free(card->i2c_adapter);
-		
 		return result;
 	}
 
@@ -334,10 +165,7 @@ static int __init dvb_bt8xx_load_card( s
 		printk("dvb_bt8xx: dvb_dmxdev_init failed (errno = %d)\n", result);
 
 		dvb_dmx_release(&card->demux);
-		dvb_unregister_i2c_bus(master_xfer, card->dvb_adapter, 0);
 		dvb_unregister_adapter(card->dvb_adapter);
-		dvb_bt8xx_i2c_adap_free(card->i2c_adapter);
-		
 		return result;
 	}
 
@@ -348,10 +176,7 @@ static int __init dvb_bt8xx_load_card( s
 
 		dvb_dmxdev_release(&card->dmxdev);
 		dvb_dmx_release(&card->demux);
-		dvb_unregister_i2c_bus(master_xfer, card->dvb_adapter, 0);
 		dvb_unregister_adapter(card->dvb_adapter);
-		dvb_bt8xx_i2c_adap_free(card->i2c_adapter);
-		
 		return result;
 	}
 	
@@ -363,10 +188,7 @@ static int __init dvb_bt8xx_load_card( s
 		card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
 		dvb_dmxdev_release(&card->dmxdev);
 		dvb_dmx_release(&card->demux);
-		dvb_unregister_i2c_bus(master_xfer, card->dvb_adapter, 0);
 		dvb_unregister_adapter(card->dvb_adapter);
-		dvb_bt8xx_i2c_adap_free(card->i2c_adapter);
-		
 		return result;
 	}
 
@@ -377,10 +199,7 @@ static int __init dvb_bt8xx_load_card( s
 		card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
 		dvb_dmxdev_release(&card->dmxdev);
 		dvb_dmx_release(&card->demux);
-		dvb_unregister_i2c_bus(master_xfer, card->dvb_adapter, 0);
 		dvb_unregister_adapter(card->dvb_adapter);
-		dvb_bt8xx_i2c_adap_free(card->i2c_adapter);
-		
 		return result;
 	}
 
@@ -393,138 +212,167 @@ static int __init dvb_bt8xx_load_card( s
 	return 0;
 }
 
-static int __init dvb_bt8xx_load_all(void)
+static int dvb_bt8xx_probe(struct device *dev)
 {
+	struct bttv_sub_device *sub = to_bttv_sub_dev(dev);
 	struct dvb_bt8xx_card *card;
-	struct list_head *entry, *entry_safe;
+	struct pci_dev* bttv_pci_dev;
+	int ret;
+
+	if (!(card = kmalloc(sizeof(struct dvb_bt8xx_card), GFP_KERNEL)))
+		return -ENOMEM;
 
-	list_for_each_safe(entry, entry_safe, &card_list) {
-		card = list_entry(entry, struct dvb_bt8xx_card, list);
-		if (dvb_bt8xx_load_card(card) < 0) {
-			list_del(&card->list);
-			kfree(card);
-			continue;
-		}
+	memset(card, 0, sizeof(*card));
+	card->bttv_nr = sub->core->nr;
+	strncpy(card->card_name, sub->core->name, sizeof(sub->core->name));
+	card->i2c_adapter = &sub->core->i2c_adap;
+
+	switch(sub->core->type)
+	{
+	case BTTV_PINNACLESAT:
+		card->gpio_mode = 0x0400C060;
+		card->op_sync_orin = 0;
+		card->irq_err_ignore = 0;
+		/* 26, 15, 14, 6, 5 
+		 * A_PWRDN  DA_DPM DA_SBR DA_IOM_DA 
+		 * DA_APP(parallel) */
+		break;
+
+	case BTTV_NEBULA_DIGITV:
+	case BTTV_AVDVBT_761:
+		card->gpio_mode = (1 << 26) | (1 << 14) | (1 << 5);
+		card->op_sync_orin = 0;
+		card->irq_err_ignore = 0;
+		/* A_PWRDN DA_SBR DA_APP (high speed serial) */
+		break;
+
+	case BTTV_AVDVBT_771: //case 0x07711461:
+		card->gpio_mode = 0x0400402B;
+		card->op_sync_orin = BT878_RISC_SYNC_MASK;
+		card->irq_err_ignore = 0;
+		/* A_PWRDN DA_SBR  DA_APP[0] PKTP=10 RISC_ENABLE FIFO_ENABLE*/
+		break;
+
+	case BTTV_TWINHAN_DST:
+		card->gpio_mode = 0x2204f2c;
+		card->op_sync_orin = BT878_RISC_SYNC_MASK;
+		card->irq_err_ignore = BT878_APABORT | BT878_ARIPERR |
+				       BT878_APPERR | BT878_AFBUS;
+		/* 25,21,14,11,10,9,8,3,2 then
+		 * 0x33 = 5,4,1,0
+		 * A_SEL=SML, DA_MLB, DA_SBR,
+		 * DA_SDR=f, fifo trigger = 32 DWORDS
+		 * IOM = 0 == audio A/D
+		 * DPM = 0 == digital audio mode
+		 * == async data parallel port
+		 * then 0x33 (13 is set by start_capture)
+		 * DA_APP = async data parallel port,
+		 * ACAP_EN = 1,
+		 * RISC+FIFO ENABLE */
+		break;
+
+	default:
+		printk(KERN_WARNING "dvb_bt8xx: Unknown bttv card type: %d.\n",
+				sub->core->type);
+		kfree(card);
+		return -ENODEV;
 	}
-	return 0;
 
-}
+	dprintk("dvb_bt8xx: identified card%d as %s\n", card->bttv_nr, card->card_name);
+			
+	if (!(bttv_pci_dev = bttv_get_pcidev(card->bttv_nr))) {
+		printk("dvb_bt8xx: no pci device for card %d\n", card->bttv_nr);
+		kfree(card);
+		return -EFAULT;
+	}
 
-#define BT878_NEBULA	0x68
-#define BT878_TWINHAN_DST 0x71
+	if (!(card->bt = dvb_bt8xx_878_match(card->bttv_nr, bttv_pci_dev))) {
+		printk("dvb_bt8xx: unable to determine DMA core of card %d\n", card->bttv_nr);
+	
+		kfree(card);
+		return -EFAULT;
+		
+	}
 
-static int __init dvb_bt8xx_init(void)
-{
-	unsigned int card_nr = 0;
-	int card_id;
-	int card_type;
+	init_MUTEX(&card->bt->gpio_lock);
+	card->bt->bttv_nr = sub->core->nr;
 
-	dprintk("dvb_bt8xx: enumerating available bttv cards...\n");
-	
-	while (bttv_get_cardinfo(card_nr, &card_type, &card_id) == 0) {
-		switch(card_id) {
-			case 0x001C11BD:
-				dvb_bt8xx_card_match(card_nr, "Pinnacle PCTV DVB-S",
-					       0x0400C060, 0, 0);
-				/* 26, 15, 14, 6, 5 
-				 * A_G2X  DA_DPM DA_SBR DA_IOM_DA 
-				 * DA_APP(parallel) */
-				break;
-			case 0x01010071:
-nebula:
-				dvb_bt8xx_card_match(card_nr, "Nebula DigiTV DVB-T",
-					     (1 << 26) | (1 << 14) | (1 << 5),
-					     0, 0);
-				/* A_PWRDN DA_SBR DA_APP (high speed serial) */
-				break;
-			case 0x07611461:
-				dvb_bt8xx_card_match(card_nr, "Avermedia DVB-T",
-					     (1 << 26) | (1 << 14) | (1 << 5),
-					     0, 0);
-				/* A_PWRDN DA_SBR DA_APP (high speed serial) */
-				break;
-			case 0x0:
-				if (card_type == BT878_NEBULA ||
-					card_type == BT878_TWINHAN_DST)
-					goto dst;
-				goto unknown_card;
-			case 0x2611BD:
-			case 0x11822:
-dst:
-				dvb_bt8xx_card_match(card_nr, "DST DVB-S", 0x2204f2c,
-						BT878_RISC_SYNC_MASK,
-						BT878_APABORT | BT878_ARIPERR | BT878_APPERR | BT878_AFBUS);
-				/* 25,21,14,11,10,9,8,3,2 then
-				 * 0x33 = 5,4,1,0
-				 * A_SEL=SML, DA_MLB, DA_SBR, 
-				 * DA_SDR=f, fifo trigger = 32 DWORDS
-				 * IOM = 0 == audio A/D
-				 * DPM = 0 == digital audio mode
-				 * == async data parallel port
-				 * then 0x33 (13 is set by start_capture)
-				 * DA_APP = async data parallel port, 
-				 * ACAP_EN = 1,
-				 * RISC+FIFO ENABLE */
-				break;
-			default:
-unknown_card:
-				printk("%s: unknown card_id found %0X\n",
-					__FUNCTION__, card_id);
-				if (card_type == BT878_NEBULA) {
-					printk("%s: bttv type set to nebula\n",
-						__FUNCTION__);
-					goto nebula;
-				}
-				if (card_type == BT878_TWINHAN_DST) {
-					printk("%s: bttv type set to Twinhan DST\n",
-						__FUNCTION__);
-					goto dst;
-				}
-				printk("%s: unknown card_type found %0X, NOT LOADED\n",
-					__FUNCTION__, card_type);
-				printk("%s: unknown card_nr found %0X\n",
-					__FUNCTION__, card_nr);
-		}
-		card_nr++;
+	if ( (ret = dvb_bt8xx_load_card(card)) ) {
+		kfree(card);
+		return ret;
 	}
-	dvb_bt8xx_get_adaps();
-	dvb_bt8xx_load_all();
 
+	dev_set_drvdata(dev, card);
 	return 0;
-
 }
 
-static void __exit dvb_bt8xx_exit(void)
+static int dvb_bt8xx_remove(struct device *dev)
 {
-	struct dvb_bt8xx_card *card;
-	struct list_head *entry, *entry_safe;
+	struct dvb_bt8xx_card *card = dev_get_drvdata(dev);
 
-	dvb_bt8xx_exit_adaps();
-	list_for_each_safe(entry, entry_safe, &card_list) {
-		card = list_entry(entry, struct dvb_bt8xx_card, list);
-		
-		dprintk("dvb_bt8xx: unloading card%d\n", card->bttv_nr);
+	dprintk("dvb_bt8xx: unloading card%d\n", card->bttv_nr);
 
-		bt878_stop(card->bt);
-		tasklet_kill(&card->bt->tasklet);
-		dvb_net_release(&card->dvbnet);
-		card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);
-		card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
-		dvb_dmxdev_release(&card->dmxdev);
-		dvb_dmx_release(&card->demux);
-		dvb_unregister_i2c_bus(master_xfer, card->dvb_adapter, 0);
-		dvb_bt8xx_i2c_adap_free(card->i2c_adapter);
-		dvb_unregister_adapter(card->dvb_adapter);
-		
-		list_del(&card->list);
-		kfree(card);
+	bt878_stop(card->bt);
+	tasklet_kill(&card->bt->tasklet);
+	dvb_net_release(&card->dvbnet);
+	card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);
+	card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
+	dvb_dmxdev_release(&card->dmxdev);
+	dvb_dmx_release(&card->demux);
+	dvb_unregister_adapter(card->dvb_adapter);
+
+	list_del(&card->list);
+	kfree(card);
+
+	return 0;
+}
+
+static void dvb_bt8xx_i2c_info(struct bttv_sub_device *sub,
+			       struct i2c_client *client, int attach)
+{
+	struct dvb_bt8xx_card *card = dev_get_drvdata(&sub->dev);
+
+	if (attach) {
+		printk("xxx attach\n");
+		if (client->driver->command)
+			client->driver->command(client, FE_REGISTER,
+						card->dvb_adapter);
+	} else {
+		printk("xxx detach\n");
+		if (client->driver->command)
+			client->driver->command(client, FE_UNREGISTER,
+						card->dvb_adapter);
 	}
+}
+
+static struct bttv_sub_driver driver = {
+	.drv = {
+		.name		= "dvb-bt8xx",
+		.probe		= dvb_bt8xx_probe,
+		.remove		= dvb_bt8xx_remove,
+		/* FIXME:
+		 * .shutdown	= dvb_bt8xx_shutdown,
+		 * .suspend	= dvb_bt8xx_suspend,
+		 * .resume	= dvb_bt8xx_resume,
+		 */
+	},
+	.i2c_info = dvb_bt8xx_i2c_info,
+};
 
+static int __init dvb_bt8xx_init(void)
+{
+	return bttv_sub_register(&driver, "dvb");
+}
+
+static void __exit dvb_bt8xx_exit(void)
+{
+	bttv_sub_unregister(&driver);
 }
 
 module_init(dvb_bt8xx_init);
 module_exit(dvb_bt8xx_exit);
+
 MODULE_DESCRIPTION("Bt8xx based DVB adapter driver");
 MODULE_AUTHOR("Florian Schirmer <jolt@tuxbox.org>");
 MODULE_LICENSE("GPL");
-MODULE_PARM(debug, "i");
+
diff -up linux-2.6.9-rc2/drivers/media/dvb/bt8xx/dvb-bt8xx.h linux/drivers/media/dvb/bt8xx/dvb-bt8xx.h
--- linux-2.6.9-rc2/drivers/media/dvb/bt8xx/dvb-bt8xx.h	2004-09-14 10:37:58.000000000 +0200
+++ linux/drivers/media/dvb/bt8xx/dvb-bt8xx.h	2004-09-17 14:56:38.687622036 +0200
@@ -25,9 +25,9 @@
 #include <linux/i2c.h>
 #include "dvbdev.h"
 #include "dvb_net.h"
+#include "bttv.h"
 
 struct dvb_bt8xx_card {
-
 	struct list_head list;
 	u8 active;
 	char card_name[32];
@@ -43,5 +43,5 @@ struct dvb_bt8xx_card {
 	u32 irq_err_ignore;
 	struct i2c_adapter *i2c_adapter;
 	struct dvb_net dvbnet;
-				
 };
+
diff -up linux-2.6.9-rc2/drivers/media/dvb/dibusb/Kconfig linux/drivers/media/dvb/dibusb/Kconfig
--- linux-2.6.9-rc2/drivers/media/dvb/dibusb/Kconfig	2004-09-17 14:56:38.709617915 +0200
+++ linux/drivers/media/dvb/dibusb/Kconfig	2004-09-17 14:56:38.712617353 +0200
@@ -0,0 +1,31 @@
+config DVB_DIBUSB
+	tristate "Twinhan/KWorld/Hama/Artec USB DVB-T devices"
+	depends on DVB_CORE && USB
+	select FW_LOADER
+	help
+	  Support for USB 1.1 DVB-T devices based on a reference design made by 
+	  DiBcom (http://www.dibcom.fr).
+
+	  Devices supported by this driver:
+
+	    Twinhan VisionPlus VisionDTV USB-Ter (VP7041)
+	    KWorld V-Stream XPERT DTV - DVB-T USB
+	    Hama DVB-T USB-Box
+	    DiBcom reference device (non-public)
+	    Ultima Electronic/Artec T1 USB TVBOX
+
+	  The VP7041 seems to be identical to "CTS Portable" (Chinese 
+	  Television System).
+
+	  These devices can be understood as budget ones, they "only" deliver
+	  the MPEG data.
+
+	  Currently all known copies of the DiBcom reference design have the DiBcom 3000MB 
+	  frontend onboard. Please enable and load this one manually in order to use this
+	  device.
+	  
+	  A firmware is needed to use the device. See Documentation/dvb/README.dibusb
+	  details.
+
+	  Say Y if you own such a device and want to use it. You should build it as
+	  a module.
diff -up linux-2.6.9-rc2/drivers/media/dvb/dibusb/Makefile linux/drivers/media/dvb/dibusb/Makefile
--- linux-2.6.9-rc2/drivers/media/dvb/dibusb/Makefile	2004-09-17 14:56:38.714616978 +0200
+++ linux/drivers/media/dvb/dibusb/Makefile	2004-09-17 14:56:38.715616791 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_DVB_DIBUSB) += dvb-dibusb.o
+
+EXTRA_CFLAGS = -Idrivers/media/dvb/dvb-core/
diff -up linux-2.6.9-rc2/drivers/media/dvb/dibusb/dvb-dibusb.c linux/drivers/media/dvb/dibusb/dvb-dibusb.c
--- linux-2.6.9-rc2/drivers/media/dvb/dibusb/dvb-dibusb.c	2004-09-17 14:56:38.717616416 +0200
+++ linux/drivers/media/dvb/dibusb/dvb-dibusb.c	2004-09-17 14:56:38.718616229 +0200
@@ -0,0 +1,719 @@
+/*
+ * Driver for mobile USB Budget DVB-T devices based on reference 
+ * design made by DiBcom (http://www.dibcom.fr/)
+ * 
+ * dvb-dibusb.c
+ * 
+ * Copyright (C) 2004 Patrick Boettcher (patrick.boettcher@desy.de)
+ * 
+ * based on GPL code from DiBcom, which has
+ *
+ * Copyright (C) 2004 Amaury Demol for DiBcom (ademol@dibcom.fr)
+ *
+ * 
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ * Acknowledgements
+ * 
+ *  Amaury Demol (ademol@dibcom.fr) from DiBcom for providing specs and driver
+ *  sources, on which this driver (and the dib3000mb frontend) are based.
+ *
+ *  TODO
+ *   - probing for i2c addresses, it is possible, that they have been changed 
+ *     by the vendor
+ * 
+ * see Documentation/dvb/README.dibusb for more information
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/usb.h>
+#include <linux/firmware.h>
+#include <linux/version.h>
+#include <linux/moduleparam.h>
+#include <linux/pci.h>
+
+#include "dmxdev.h"
+#include "dvb_demux.h"
+#include "dvb_filter.h"
+#include "dvb_net.h"
+#include "dvb_frontend.h"
+
+#include "dvb-dibusb.h"
+
+/* debug */
+
+#ifdef CONFIG_DVB_DIBCOM_DEBUG
+#define dprintk_new(level,args...) \
+	    do { if ((debug & level)) { printk(args); } } while (0)
+
+#define debug_dump(b,l) if (debug) {\
+	int i; deb_xfer("%s: %d > ",__FUNCTION__,l); \
+	for (i = 0; i < l; i++) deb_xfer("%02x ", b[i]); \
+	deb_xfer("\n");\
+}
+
+static int debug;
+module_param(debug, int, 0x644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info,2=xfer,4=alotmore (|-able)).");
+#else
+#define dprintk_new(args...)
+#define debug_dump(b,l)
+#endif
+
+#define deb_info(args...) dprintk_new(0x01,args)
+#define deb_xfer(args...) dprintk_new(0x02,args)
+#define deb_alot(args...) dprintk_new(0x04,args)
+
+/* Version information */
+#define DRIVER_VERSION "0.0"
+#define DRIVER_DESC "DiBcom based USB Budget DVB-T device"
+#define DRIVER_AUTHOR "Patrick Boettcher, patrick.boettcher@desy.de"
+
+/* USB Driver stuff */
+	
+/* table of devices that work with this driver */
+static struct usb_device_id dibusb_table [] = {
+	{ USB_DEVICE(USB_TWINHAN_VENDOR_ID, USB_VP7041_PRODUCT_PREFW_ID) },
+	{ USB_DEVICE(USB_TWINHAN_VENDOR_ID, USB_VP7041_PRODUCT_ID) },
+	{ USB_DEVICE(USB_IMC_NETWORKS_VENDOR_ID, USB_VP7041_PRODUCT_PREFW_ID) },
+	{ USB_DEVICE(USB_IMC_NETWORKS_VENDOR_ID, USB_VP7041_PRODUCT_ID) },
+	{ USB_DEVICE(USB_KWORLD_VENDOR_ID, USB_VSTREAM_PRODUCT_PREFW_ID) },
+	{ USB_DEVICE(USB_KWORLD_VENDOR_ID, USB_VSTREAM_PRODUCT_ID) },
+	{ USB_DEVICE(USB_DIBCOM_VENDOR_ID, USB_DIBCOM_PRODUCT_PREFW_ID) },
+	{ USB_DEVICE(USB_DIBCOM_VENDOR_ID, USB_DIBCOM_PRODUCT_ID) },
+	{ USB_DEVICE(USB_ULTIMA_ELECTRONIC_ID, USB_ULTIMA_ELEC_PROD_PREFW_ID) },
+	{ USB_DEVICE(USB_ULTIMA_ELECTRONIC_ID, USB_ULTIMA_ELEC_PROD_ID) },
+	{ }					/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, dibusb_table);
+
+static int dibusb_readwrite_usb(struct usb_dibusb *dib, 
+		u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)
+{
+	int actlen,ret = -ENOMEM;
+
+	if (wbuf == NULL || wlen == 0)
+		return -EINVAL;
+
+/*	if (dib->disconnecting)
+		return -EINVAL;*/
+
+	if ((ret = down_interruptible(&dib->usb_sem)))
+		return ret;
+
+	debug_dump(wbuf,wlen);
+		
+	ret = usb_bulk_msg(dib->udev,COMMAND_PIPE,
+			wbuf,wlen,&actlen,DIBUSB_I2C_TIMEOUT);
+		
+	if (ret)
+		err("bulk message failed: %d (%d/%d)",ret,wlen,actlen);
+	else
+		ret = actlen != wlen ? -1 : 0;
+
+	/* an answer is expected */
+	if (!ret && rbuf && rlen) {
+		ret = usb_bulk_msg(dib->udev,RESULT_PIPE,rbuf,rlen,
+				&actlen,DIBUSB_I2C_TIMEOUT);
+
+		if (ret)
+			err("recv bulk message failed: %d",ret);
+		else {
+			deb_alot("rlen: %d\n",rlen);
+			debug_dump(rbuf,actlen);
+		}
+	}
+	
+	up(&dib->usb_sem);
+	return ret;
+}
+
+static int dibusb_write_usb(struct usb_dibusb *dib, u8 *buf, u16 len)
+{
+	return dibusb_readwrite_usb(dib,buf,len,NULL,0);
+}
+
+static int dibusb_i2c_msg(struct usb_dibusb *dib, u8 addr, 
+		u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)
+{
+	u8 sndbuf[wlen+4]; /* lead(1) devaddr,direction(1) addr(2) data(wlen) (len(2) (when reading)) */
+	/* write only ? */
+	int wo = (rbuf == NULL || rlen == 0), 
+		len = 2 + wlen + (wo ? 0 : 2);
+
+	deb_alot("wo: %d, wlen: %d, len: %d\n",wo,wlen,len);
+	
+	sndbuf[0] = wo ? DIBUSB_REQ_I2C_WRITE : DIBUSB_REQ_I2C_READ;
+	sndbuf[1] = (addr & 0xfe) | (wo ? 0 : 1);
+
+	memcpy(&sndbuf[2],wbuf,wlen);
+	
+	if (!wo) {
+		sndbuf[wlen+2] = (rlen >> 8) & 0xff;
+		sndbuf[wlen+3] = rlen & 0xff;
+	}
+	
+	return dibusb_readwrite_usb(dib,sndbuf,len,rbuf,rlen);
+}
+
+/*
+ * DVB stuff 
+ */
+
+static struct dibusb_pid * dibusb_get_free_pid(struct usb_dibusb *dib)
+{
+	int i;
+	unsigned long flags;
+	struct dibusb_pid *dpid = NULL;
+
+	spin_lock_irqsave(&dib->pid_list_lock,flags);
+	for (i=0; i < DIBUSB_MAX_PIDS; i++)
+		if (!dib->pid_list[i].active) {
+			dpid = dib->pid_list + i;
+			dpid->active = 1;
+			break;
+		}
+	spin_unlock_irqrestore(&dib->pid_list_lock,flags);
+	return dpid;
+}
+
+static int dibusb_start_xfer(struct usb_dibusb *dib)
+{
+	u8 b[4] = { 
+		(DIB3000MB_REG_FIFO >> 8) & 0xff,
+		(DIB3000MB_REG_FIFO) & 0xff,
+		(DIB3000MB_FIFO_ACTIVATE >> 8) & 0xff,
+		(DIB3000MB_FIFO_ACTIVATE) & 0xff
+	};
+	return dibusb_i2c_msg(dib,DIBUSB_DEMOD_I2C_ADDR_DEFAULT,b,4,NULL,0);
+}
+
+static int dibusb_stop_xfer(struct usb_dibusb *dib)
+{
+	u8 b[4] = { 
+		(DIB3000MB_REG_FIFO >> 8) & 0xff,
+		(DIB3000MB_REG_FIFO) & 0xff,
+		(DIB3000MB_FIFO_INHIBIT >> 8) & 0xff,
+		(DIB3000MB_FIFO_INHIBIT) & 0xff
+	};
+	return dibusb_i2c_msg(dib,DIBUSB_DEMOD_I2C_ADDR_DEFAULT,b,4,NULL,0);
+}
+
+static int dibusb_set_pid(struct dibusb_pid *dpid)
+{
+	u16 pid = dpid->pid | (dpid->active ? DIB3000MB_ACTIVATE_FILTERING : 0);
+	u8 b[4] = { 
+		(dpid->reg >> 8) & 0xff,
+		(dpid->reg) & 0xff,
+		(pid >> 8) & 0xff,
+		(pid) & 0xff
+	};
+	
+	return dibusb_i2c_msg(dpid->dib,DIBUSB_DEMOD_I2C_ADDR_DEFAULT,b,4,NULL,0);
+}
+
+static void dibusb_urb_complete(struct urb *urb, struct pt_regs *ptregs)
+{
+	struct usb_dibusb *dib = urb->context;
+
+	if (!dib->streaming)
+		return;
+
+	if (urb->status == 0) {
+		deb_info("URB return len: %d\n",urb->actual_length);
+		if (urb->actual_length % 188)
+			deb_info("TS Packets: %d, %d\n", urb->actual_length/188,urb->actual_length % 188);
+		dvb_dmx_swfilter_packets(&dib->demux, (u8*) urb->transfer_buffer,urb->actual_length/188);
+	}
+
+	if (dib->streaming)
+		usb_submit_urb(urb,GFP_KERNEL);
+}
+
+
+static int dibusb_start_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+//	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
+	struct usb_dibusb *dib = dvbdmxfeed->demux->priv;
+	struct dibusb_pid *dpid;
+	int ret = 0;
+
+	deb_info("pid: 0x%04x, feedtype: %d\n", dvbdmxfeed->pid,dvbdmxfeed->type);
+
+	if ((dpid = dibusb_get_free_pid(dib)) == NULL) {
+		err("no free pid in list.");
+		return -ENODEV;
+	}
+	dvbdmxfeed->priv = dpid;
+	dpid->pid = dvbdmxfeed->pid;
+
+	dibusb_set_pid(dpid);
+
+	if (0 == dib->feed_count++) {
+		usb_fill_bulk_urb( dib->buf_urb, dib->udev, DATA_PIPE,
+			dib->buffer, 8192, dibusb_urb_complete, dib);
+		dib->buf_urb->transfer_flags = 0;
+		dib->buf_urb->timeout = 0;
+
+		if ((ret = usb_submit_urb(dib->buf_urb,GFP_KERNEL))) {
+			dibusb_stop_xfer(dib);
+			err("could not submit buffer urb.");
+			return ret;
+		}
+		
+		if ((ret = dibusb_start_xfer(dib)))
+			return ret;
+
+		dib->streaming = 1;
+	}
+	return 0;
+}
+
+static int dibusb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	struct usb_dibusb *dib = dvbdmxfeed->demux->priv;
+	struct dibusb_pid *dpid = (struct dibusb_pid *) dvbdmxfeed->priv;
+
+	deb_info("stopfeed pid: 0x%04x, feedtype: %d",dvbdmxfeed->pid, dvbdmxfeed->type);
+
+	if (dpid == NULL)
+		err("channel in dmxfeed->priv was NULL");
+	else {
+		dpid->active = 0;
+		dpid->pid = 0;
+		dibusb_set_pid(dpid);
+	}
+
+	if (--dib->feed_count == 0) {
+		dib->streaming = 0;
+		usb_unlink_urb(dib->buf_urb);
+		dibusb_stop_xfer(dib);
+	}		
+	return 0;
+}
+
+/*
+ * firmware transfers
+ */
+
+/*
+ * do not use this, just a workaround for a bug, 
+ * which will never occur :).
+ */
+static int dibusb_interrupt_read_loop(struct usb_dibusb *dib)
+{
+	u8 b[1] = { DIBUSB_REQ_INTR_READ };
+	return dibusb_write_usb(dib,b,1);
+}
+
+/*
+ * TODO: a tasklet should run with a delay of 1/10 second
+ * and fill an appropriate event device ?
+ */
+static int dibusb_read_remote_control(struct usb_dibusb *dib) 
+{
+	u8 b[1] = { DIBUSB_REQ_POLL_REMOTE }, rb[5];
+	int ret;
+	if ((ret = dibusb_readwrite_usb(dib,b,1,rb,5))) 
+		return ret;
+
+	return 0;
+}
+
+/*
+ * ioctl for the firmware 
+ */
+static int dibusb_ioctl_cmd(struct usb_dibusb *dib, u8 cmd, u8 *param, int plen)
+{
+	u8 b[34];
+	int size = plen > 32 ? 32 : plen;
+	b[0] = DIBUSB_REQ_SET_IOCTL;
+	b[1] = cmd;
+	memcpy(&b[2],param,size);
+
+	return dibusb_write_usb(dib,b,2+size);
+}
+
+/*
+ * ioctl for power control
+ */
+static int dibusb_hw_sleep(struct usb_dibusb *dib)
+{
+	u8 b[1] = { DIBUSB_IOCTL_POWER_SLEEP };
+	return dibusb_ioctl_cmd(dib,DIBUSB_IOCTL_CMD_POWER_MODE, b,1);
+}
+
+static int dibusb_hw_wakeup(struct usb_dibusb *dib)
+{
+	u8 b[1] = { DIBUSB_IOCTL_POWER_WAKEUP };
+	return dibusb_ioctl_cmd(dib,DIBUSB_IOCTL_CMD_POWER_MODE, b,1);
+}
+
+/*
+ * I2C
+ */
+static int dibusb_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num)
+{
+	struct usb_dibusb *dib = i2c_get_adapdata(adap);
+	int i;
+
+	if (down_interruptible(&dib->i2c_sem) < 0) 
+		return -EAGAIN;
+	
+	for (i = 0; i < num; i++) {
+		/* write/read request */
+		if (i+1 < num && (msg[i+1].flags & I2C_M_RD)) {
+			if (dibusb_i2c_msg(dib, msg[i].addr, msg[i].buf,msg[i].len,
+						msg[i+1].buf,msg[i+1].len) < 0)
+				break;
+			i++;
+		} else 
+			if (dibusb_i2c_msg(dib, msg[i].addr, msg[i].buf,msg[i].len,NULL,0) < 0)
+				break;
+	}
+	
+	up(&dib->i2c_sem);
+	return i;	
+}
+
+static u32 dibusb_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static int dibusb_i2c_client_register (struct i2c_client *i2c)
+{
+	struct usb_dibusb *dib = i2c_get_adapdata(i2c->adapter);
+	if (i2c->driver->command)
+		return i2c->driver->command(i2c,FE_REGISTER,dib->adapter);
+	return 0;
+}
+
+static int dibusb_i2c_client_unregister (struct i2c_client *i2c)
+{
+	struct usb_dibusb *dib = i2c_get_adapdata(i2c->adapter);
+	if (i2c->driver->command)
+		return i2c->driver->command(i2c,FE_UNREGISTER,dib->adapter);
+	return 0;
+}
+
+static struct i2c_algorithm dibusb_algo = {
+	.name			= "DiBcom USB i2c algorithm",
+	.id				= I2C_ALGO_BIT,
+	.master_xfer	= dibusb_i2c_xfer,
+	.functionality	= dibusb_i2c_func,
+};
+
+static int dibusb_dvb_init(struct usb_dibusb *dib)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,4)
+    if ((ret = dvb_register_adapter(&dib->adapter, DRIVER_DESC)) < 0) {
+#else
+    if ((ret = dvb_register_adapter(&dib->adapter, DRIVER_DESC , 
+			THIS_MODULE)) < 0) {
+#endif
+		deb_info("dvb_register_adapter failed: error %d", ret);
+		goto err;
+	}
+
+	strncpy(dib->i2c_adap.name,dib->dibdev->name,I2C_NAME_SIZE);
+#ifdef I2C_ADAP_CLASS_TV_DIGITAL
+	dib->i2c_adap.class = I2C_ADAP_CLASS_TV_DIGITAL,
+#else
+	dib->i2c_adap.class = I2C_CLASS_TV_DIGITAL,
+#endif
+	dib->i2c_adap.algo 		= &dibusb_algo;
+	dib->i2c_adap.algo_data = NULL;
+	dib->i2c_adap.id		= I2C_ALGO_BIT;
+	dib->i2c_adap.client_register   = dibusb_i2c_client_register,
+	dib->i2c_adap.client_unregister = dibusb_i2c_client_unregister,
+	
+	i2c_set_adapdata(&dib->i2c_adap, dib);
+	
+	if ((i2c_add_adapter(&dib->i2c_adap) < 0)) {
+		err("could not add i2c adapter");
+		goto err_i2c;
+	}
+
+	dib->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;
+
+	dib->demux.priv = (void *)dib;
+	dib->demux.filternum = DIBUSB_MAX_PIDS;
+	dib->demux.feednum = DIBUSB_MAX_PIDS;
+	dib->demux.start_feed = dibusb_start_feed;
+	dib->demux.stop_feed = dibusb_stop_feed;
+	dib->demux.write_to_decoder = NULL;
+	if ((ret = dvb_dmx_init(&dib->demux)) < 0) {
+		err("dvb_dmx_init failed: error %d",ret);
+		goto err_dmx;
+	}
+
+	dib->dmxdev.filternum = dib->demux.filternum;
+	dib->dmxdev.demux = &dib->demux.dmx;
+	dib->dmxdev.capabilities = 0;
+	if ((ret = dvb_dmxdev_init(&dib->dmxdev, dib->adapter)) < 0) {
+		err("dvb_dmxdev_init failed: error %d",ret);
+		goto err_dmx_dev;
+	}
+
+	dvb_net_init(dib->adapter, &dib->dvb_net, &dib->demux.dmx);
+	
+	goto success;
+err_dmx_dev:
+	dvb_dmx_release(&dib->demux);
+err_dmx:
+	i2c_del_adapter(&dib->i2c_adap);
+err_i2c:
+	dvb_unregister_adapter(dib->adapter);
+err:
+	return ret;
+success:
+	return 0;
+}
+
+static int dibusb_dvb_exit(struct usb_dibusb *dib)
+{
+	deb_info("unregistering DVB part\n");
+	dvb_net_release(&dib->dvb_net);
+	dib->demux.dmx.close(&dib->demux.dmx);
+	dvb_dmxdev_release(&dib->dmxdev);
+	dvb_dmx_release(&dib->demux);
+	i2c_del_adapter(&dib->i2c_adap);
+	dvb_unregister_adapter(dib->adapter);
+
+	return 0;
+}
+
+static int dibusb_exit(struct usb_dibusb *dib)
+{
+	usb_free_urb(dib->buf_urb);
+	pci_free_consistent(NULL,8192,dib->buffer,dib->dma_handle);
+	return 0;
+}
+
+static int dibusb_init(struct usb_dibusb *dib)
+{
+	int ret,i;
+	sema_init(&dib->usb_sem, 1);
+	sema_init(&dib->i2c_sem, 1);
+	
+	/*
+	 * when reloading the driver w/o replugging the device 
+	 * a timeout occures, this helps
+	 */
+	usb_clear_halt(dib->udev,COMMAND_PIPE);
+	usb_clear_halt(dib->udev,RESULT_PIPE);
+	usb_clear_halt(dib->udev,DATA_PIPE);
+
+	/* dibusb_reset_cpu(dib); */
+
+	dib->buffer = pci_alloc_consistent(NULL,8192, &dib->dma_handle);
+	memset(dib->buffer,0,8192);
+	if (!(dib->buf_urb = usb_alloc_urb(0,GFP_KERNEL))) {
+		dibusb_exit(dib);
+		return -ENOMEM;
+	}
+	
+	for (i=0; i < DIBUSB_MAX_PIDS; i++) {
+		dib->pid_list[i].reg = i+DIB3000MB_REG_FIRST_PID;
+		dib->pid_list[i].pid = 0;
+		dib->pid_list[i].active = 0;
+		dib->pid_list[i].dib = dib;
+	}
+
+	dib->streaming = 0;
+	dib->feed_count = 0;
+	
+	if ((ret = dibusb_dvb_init(dib))) {
+		dibusb_exit(dib);
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * load a firmware packet to the device 
+ */
+static int dibusb_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 len)
+{
+	return usb_control_msg(udev, usb_sndctrlpipe(udev,0),
+			0xa0, USB_TYPE_VENDOR, addr, 0x00, data, len, 5*HZ);
+}
+
+static int dibusb_loadfirmware(struct usb_device *udev,
+		struct dibusb_device *dibdev) 
+{
+	const struct firmware *fw = NULL;
+	u16 addr;
+	u8 *b,*p;
+	int ret = 0,i;
+
+	for (i = 0; i < sizeof(valid_firmware_filenames)/sizeof(const char*); i++) {
+		if ((ret = request_firmware(&fw, valid_firmware_filenames[i], &udev->dev)) == 0) {
+			info("using firmware file (%s).",valid_firmware_filenames[i]);
+			break;
+		}
+		deb_info("tried to find '%s' firmware - unsuccessful. (%d)\n",
+				valid_firmware_filenames[i],ret);
+	}
+		
+	if (fw == NULL) {
+		err("did not find a valid firmware file. "
+			"Please see linux/Documentation/dvb/ for more details on firmware-problems.");
+		return -EINVAL;
+	} 
+	p = kmalloc(fw->size,GFP_KERNEL);	
+	if (p != NULL) {
+		u8 reset;
+		/*
+		 * you cannot use the fw->data as buffer for 
+		 * usb_control_msg, a new buffer has to be
+		 * created
+		 */
+		memcpy(p,fw->data,fw->size);
+
+		/* stop the CPU */
+		reset = 1;
+		if ((ret = dibusb_writemem(udev,DIBUSB_CPU_CSREG,&reset,1)) != 1) 
+			err("could not stop the USB controller CPU.");
+		for(i = 0; p[i+3] == 0 && i < fw->size; ) { 
+			b = (u8 *) &p[i];
+			addr = *((u16 *) &b[1]);
+
+			ret = dibusb_writemem(udev,addr,&b[4],b[0]);
+		
+			if (ret != b[0]) {
+				err("error while transferring firmware "
+					"(transferred size: %d, block size: %d)",
+					ret,b[1]);
+				ret = -EINVAL;
+				break;
+			}
+			i += 5 + b[0];
+		}
+		/* restart the CPU */
+		reset = 0;
+		if ((ret = dibusb_writemem(udev,DIBUSB_CPU_CSREG,&reset,1)) != 1) 
+			err("could not restart the USB controller CPU.");
+
+		kfree(p);
+		ret = 0;
+	} else { 
+		ret = -ENOMEM;
+	}
+	release_firmware(fw);
+
+	return ret;
+}
+
+/*
+ * USB 
+ */
+static int dibusb_probe(struct usb_interface *intf, 
+		const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct usb_dibusb *dib = NULL;
+	struct dibusb_device *dibdev = NULL;
+	
+	int ret = -ENOMEM,i,cold=0;
+
+	for (i = 0; i < DIBUSB_SUPPORTED_DEVICES; i++)
+		if (dibusb_devices[i].cold_product_id == udev->descriptor.idProduct || 
+			dibusb_devices[i].warm_product_id == udev->descriptor.idProduct) {
+			dibdev = &dibusb_devices[i];
+			
+			cold = dibdev->cold_product_id == udev->descriptor.idProduct;
+			
+			if (cold)
+				info("found a '%s' in cold state, will try to load a firmware",dibdev->name);
+			else
+				info("found a '%s' in warm state.",dibdev->name);
+		}
+	
+	if (dibdev == NULL) {
+		err("something went very wrong, "
+				"unknown product ID: %.4x",udev->descriptor.idProduct);
+		return -ENODEV;
+	}
+	
+	if (cold)
+		ret = dibusb_loadfirmware(udev,dibdev);
+	else {
+		dib = kmalloc(sizeof(struct usb_dibusb),GFP_KERNEL);
+		if (dib == NULL) {
+			err("no memory");
+			return ret;
+		}
+		memset(dib,0,sizeof(struct usb_dibusb));
+		
+		dib->udev = udev;
+		dib->dibdev = dibdev;
+		
+		usb_set_intfdata(intf, dib);
+
+		ret = dibusb_init(dib);
+	}
+	
+	if (ret == 0)
+		info("%s successfully initialized and connected.",dibdev->name);
+	else 
+		info("%s error while loading driver (%d)",dibdev->name,ret);
+	return ret;
+}
+
+static void dibusb_disconnect(struct usb_interface *intf)
+{
+	struct usb_dibusb *dib = usb_get_intfdata(intf);
+	const char *name = DRIVER_DESC;
+	
+	usb_set_intfdata(intf,NULL);
+	if (dib != NULL) {
+		name = dib->dibdev->name;
+		dibusb_dvb_exit(dib);
+		dibusb_exit(dib);
+		kfree(dib);
+	}
+	info("%s successfully deinitialized and disconnected.",name);
+	
+}
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver dibusb_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "dvb_dibusb",
+	.probe 		= dibusb_probe,
+	.disconnect = dibusb_disconnect,
+	.id_table 	= dibusb_table,
+};
+
+/* module stuff */
+static int __init usb_dibusb_init(void)
+{
+	int result;
+	if ((result = usb_register(&dibusb_driver))) {
+		err("usb_register failed. Error number %d",result);
+		return result;
+	}
+	
+	return 0;
+}
+
+static void __exit usb_dibusb_exit(void)
+{
+	/* deregister this driver from the USB subsystem */
+	usb_deregister(&dibusb_driver);
+}
+
+module_init (usb_dibusb_init);
+module_exit (usb_dibusb_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff -up linux-2.6.9-rc2/drivers/media/dvb/dibusb/dvb-dibusb.h linux/drivers/media/dvb/dibusb/dvb-dibusb.h
--- linux-2.6.9-rc2/drivers/media/dvb/dibusb/dvb-dibusb.h	2004-09-17 14:56:38.720615854 +0200
+++ linux/drivers/media/dvb/dibusb/dvb-dibusb.h	2004-09-17 14:56:38.720615854 +0200
@@ -0,0 +1,175 @@
+/*
+ * dvb-dibusb.h
+ * 
+ * Copyright (C) 2004 Patrick Boettcher (patrick.boettcher@desy.de)
+ * 
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ *
+ * for more information see dvb-dibusb.c .
+ */
+
+#ifndef __DVB_DIBUSB_H__
+#define __DVB_DIBUSB_H__
+
+/* Vendor IDs */
+#define USB_TWINHAN_VENDOR_ID			0x1822
+#define USB_IMC_NETWORKS_VENDOR_ID		0x13d3
+#define USB_KWORLD_VENDOR_ID			0xeb1a
+#define USB_DIBCOM_VENDOR_ID			0x10b8
+#define USB_ULTIMA_ELECTRONIC_ID		0x05d8
+
+/* Product IDs before loading the firmware */
+#define USB_VP7041_PRODUCT_PREFW_ID		0x3201
+#define USB_VSTREAM_PRODUCT_PREFW_ID	0x17de
+#define USB_DIBCOM_PRODUCT_PREFW_ID		0x0bb8
+#define USB_ULTIMA_ELEC_PROD_PREFW_ID	0x8105
+
+/* product ID afterwards */
+#define USB_VP7041_PRODUCT_ID			0x3202
+#define USB_VSTREAM_PRODUCT_ID			0x17df
+#define USB_DIBCOM_PRODUCT_ID			0x0bb9
+#define USB_ULTIMA_ELEC_PROD_ID			0x8106
+
+/* CS register start/stop the usb controller cpu */
+#define DIBUSB_CPU_CSREG				0x7F92
+
+// 0x10 is the I2C address of the first demodulator on the board
+#define DIBUSB_DEMOD_I2C_ADDR_DEFAULT	0x10
+#define DIBUSB_I2C_TIMEOUT 				HZ*5
+
+#define DIBUSB_MAX_PIDS					16
+
+#define DIB3000MB_REG_FIRST_PID			(   153)
+
+struct usb_dibusb;
+
+struct dibusb_pid {
+	u16 reg;
+	u16 pid;
+	int active;
+	struct usb_dibusb *dib;
+};
+
+struct usb_dibusb {
+	/* usb */
+	struct usb_device * udev;
+
+	struct dibusb_device * dibdev;
+
+	int streaming;
+	int feed_count;
+	struct urb *buf_urb;
+	u8 *buffer;
+	dma_addr_t dma_handle;
+	
+	spinlock_t pid_list_lock;
+	struct dibusb_pid pid_list[DIBUSB_MAX_PIDS];
+
+	/* I2C */
+	struct i2c_adapter i2c_adap;
+	struct i2c_client i2c_client;
+
+	/* locking */
+	struct semaphore usb_sem;
+	struct semaphore i2c_sem;
+
+	/* dvb */
+	struct dvb_adapter *adapter;
+	struct dmxdev dmxdev;
+	struct dvb_demux demux;
+	struct dvb_net dvb_net;
+};
+
+
+struct dibusb_device {
+	u16 cold_product_id;
+	u16 warm_product_id;
+	u8 demod_addr;
+	const char *name;
+};
+
+/* static array of valid firmware names, the best one first */
+static const char * valid_firmware_filenames[] = {
+	"dvb-dibusb-5.0.0.11.fw",
+};
+
+#define DIBUSB_SUPPORTED_DEVICES	4
+
+/* USB Driver stuff */
+static struct dibusb_device dibusb_devices[DIBUSB_SUPPORTED_DEVICES] = {
+	{	.cold_product_id = USB_VP7041_PRODUCT_PREFW_ID, 
+		.warm_product_id = USB_VP7041_PRODUCT_ID,
+		.name = "Twinhan VisionDTV USB-Ter/HAMA USB DVB-T device", 
+		.demod_addr = DIBUSB_DEMOD_I2C_ADDR_DEFAULT,
+	},
+	{	.cold_product_id = USB_VSTREAM_PRODUCT_PREFW_ID,
+		.warm_product_id = USB_VSTREAM_PRODUCT_ID,
+		.name = "KWorld V-Stream XPERT DTV - DVB-T USB",
+		.demod_addr = DIBUSB_DEMOD_I2C_ADDR_DEFAULT,
+	},
+	{	.cold_product_id = USB_DIBCOM_PRODUCT_PREFW_ID,
+		.warm_product_id = USB_DIBCOM_PRODUCT_ID,
+		.name = "DiBcom USB reference design",
+		.demod_addr = DIBUSB_DEMOD_I2C_ADDR_DEFAULT,
+	},
+	{
+ 		.cold_product_id = USB_ULTIMA_ELEC_PROD_PREFW_ID,
+		.warm_product_id = USB_ULTIMA_ELEC_PROD_ID,
+		.name = "Ultima Electronic/Artec T1 USB TVBOX",
+		.demod_addr = DIBUSB_DEMOD_I2C_ADDR_DEFAULT,
+	}, 
+};
+
+#define COMMAND_PIPE	usb_sndbulkpipe(dib->udev, 0x01)
+#define RESULT_PIPE		usb_rcvbulkpipe(dib->udev, 0x81)
+#define DATA_PIPE		usb_rcvbulkpipe(dib->udev, 0x82)
+/* 
+ * last endpoint 0x83 only used for chaining the buffers 
+ * of the endpoints in the cypress 
+ */
+#define CHAIN_PIPE_DO_NOT_USE	usb_rcvbulkpipe(dib->udev, 0x83)
+
+/* types of first byte of each buffer */
+
+#define DIBUSB_REQ_START_READ			0x00
+#define DIBUSB_REQ_START_DEMOD			0x01
+#define DIBUSB_REQ_I2C_READ  			0x02
+#define DIBUSB_REQ_I2C_WRITE 			0x03
+
+/* prefix for reading the current RC key */
+#define DIBUSB_REQ_POLL_REMOTE			0x04
+
+/* 0x05 0xXX */
+#define DIBUSB_REQ_SET_STREAMING_MODE	0x05
+
+/* interrupt the internal read loop, when blocking */
+#define DIBUSB_REQ_INTR_READ		   	0x06
+
+/* IO control 
+ * 0x07 <cmd 1 byte> <param 32 bytes>
+ */ 
+#define DIBUSB_REQ_SET_IOCTL			0x07
+
+/* IOCTL commands */
+
+/* change the power mode in firmware */ 
+#define DIBUSB_IOCTL_CMD_POWER_MODE		0x00
+#define DIBUSB_IOCTL_POWER_SLEEP			0x00
+#define DIBUSB_IOCTL_POWER_WAKEUP			0x01
+
+
+/* 
+ * values from the demodulator which are needed in
+ * the usb driver as well 
+ */
+
+#define DIB3000MB_REG_FIFO              (   145)
+#define DIB3000MB_FIFO_INHIBIT              (     1)
+#define DIB3000MB_FIFO_ACTIVATE             (     0)
+
+#define DIB3000MB_ACTIVATE_FILTERING            (0x2000)
+
+#endif
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/Kconfig linux/drivers/media/dvb/dvb-core/Kconfig
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/Kconfig	2004-09-14 10:37:41.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/Kconfig	2004-09-17 14:56:38.722615480 +0200
@@ -8,4 +8,4 @@ config DVB_CORE
 	  to build your drivers outside the kernel, but need the DVB core. All 
 	  in-kernel drivers will select this automatically if needed.
 	  If unsure say N.
-
+ 
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/Makefile linux/drivers/media/dvb/dvb-core/Makefile
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/Makefile	2004-09-14 10:38:03.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/Makefile	2004-09-17 14:56:38.724615105 +0200
@@ -3,7 +3,7 @@
 #
 
 dvb-core-objs = dvbdev.o dmxdev.o dvb_demux.o dvb_filter.o \
-	        dvb_ca_en50221.o dvb_functions.o dvb_frontend.o \
-		dvb_i2c.o dvb_net.o dvb_ksyms.o dvb_ringbuffer.o
+	        dvb_ca_en50221.o dvb_frontend.o \
+		dvb_net.o dvb_ksyms.o dvb_ringbuffer.o
 
 obj-$(CONFIG_DVB_CORE) += dvb-core.o
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/demux.h linux/drivers/media/dvb/dvb-core/demux.h
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/demux.h	2004-09-14 10:35:10.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/demux.h	2004-09-17 14:56:38.726614730 +0200
@@ -284,7 +284,7 @@ struct dmx_demux { 
 
         int (*get_stc) (struct dmx_demux* demux, unsigned int num,
 			u64 *stc, unsigned int *base);
-}; 
+};
 
 /*--------------------------------------------------------------------------*/ 
 /* Demux directory */ 
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dmxdev.c linux/drivers/media/dvb/dvb-core/dmxdev.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dmxdev.c	2004-09-14 10:37:05.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dmxdev.c	2004-09-17 14:56:38.729614168 +0200
@@ -25,6 +25,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/sched.h>
 #include <linux/poll.h>
 #include <linux/ioctl.h>
@@ -33,10 +34,11 @@
 #include <asm/system.h>
 
 #include "dmxdev.h"
-#include "dvb_functions.h"
 
-MODULE_PARM(debug,"i");
-static int debug = 0;
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off debugging (default:off).");
 
 #define dprintk	if (debug) printk
 
@@ -996,6 +998,7 @@ static int dvb_demux_release(struct inod
 	return dvb_dmxdev_filter_free(dmxdev, dmxdevfilter);
 }
 
+
 static struct file_operations dvb_demux_fops = {
 	.owner		= THIS_MODULE,
 	.read		= dvb_demux_read,
@@ -1005,6 +1008,7 @@ static struct file_operations dvb_demux_
 	.poll		= dvb_demux_poll,
 };
 
+
 static struct dvb_device dvbdev_demux = {
 	.priv		= NULL,
 	.users		= 1,
@@ -1012,8 +1016,9 @@ static struct dvb_device dvbdev_demux = 
 	.fops		= &dvb_demux_fops
 };
 
+
 static int dvb_dvr_do_ioctl(struct inode *inode, struct file *file,
-			    unsigned int cmd, void *parg)
+		     unsigned int cmd, void *parg)
 {
 	struct dvb_device *dvbdev=(struct dvb_device *) file->private_data;
 	struct dmxdev *dmxdev=(struct dmxdev *) dvbdev->priv;
@@ -1036,8 +1041,9 @@ static int dvb_dvr_do_ioctl(struct inode
 	return ret;
 }
 
+
 static int dvb_dvr_ioctl(struct inode *inode, struct file *file,
-			 unsigned int cmd, unsigned long arg)
+		  unsigned int cmd, unsigned long arg)
 {
 	return dvb_usercopy(inode, file, cmd, arg, dvb_dvr_do_ioctl);
 }
@@ -1088,7 +1094,7 @@ dvb_dmxdev_init(struct dmxdev *dmxdev, s
 {
 	int i;
 
-	if (dmxdev->demux->open(dmxdev->demux)<0)
+	if (dmxdev->demux->open(dmxdev->demux) < 0)
 		return -EUSERS;
 	
 	dmxdev->filter = vmalloc(dmxdev->filternum*sizeof(struct dmxdev_filter));
@@ -1113,6 +1119,7 @@ dvb_dmxdev_init(struct dmxdev *dmxdev, s
 		dvb_dmxdev_filter_state_set(&dmxdev->filter[i], DMXDEV_STATE_FREE);
 		dvb_dmxdev_dvr_state_set(&dmxdev->dvr[i], DMXDEV_STATE_FREE);
 	}
+
 	dvb_register_device(dvb_adapter, &dmxdev->dvbdev, &dvbdev_demux, dmxdev, DVB_DEVICE_DEMUX);
 	dvb_register_device(dvb_adapter, &dmxdev->dvr_dvbdev, &dvbdev_dvr, dmxdev, DVB_DEVICE_DVR);
 
@@ -1126,10 +1133,12 @@ dvb_dmxdev_release(struct dmxdev *dmxdev
 {
 	dvb_unregister_device(dmxdev->dvbdev);
 	dvb_unregister_device(dmxdev->dvr_dvbdev);
+
 	if (dmxdev->filter) {
 		vfree(dmxdev->filter);
 		dmxdev->filter=NULL;
 	}
+
 	if (dmxdev->dvr) {
 		vfree(dmxdev->dvr);
 		dmxdev->dvr=NULL;
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ca_en50221.c linux/drivers/media/dvb/dvb-core/dvb_ca_en50221.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2004-09-14 10:35:11.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2004-09-17 14:56:38.735613044 +0200
@@ -32,16 +32,19 @@
 #include <linux/slab.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/vmalloc.h>
 #include <linux/delay.h>
-#include <asm/semaphore.h>
-#include <asm/atomic.h>
+#include <linux/rwsem.h>
 
 #include "dvb_ca_en50221.h"
-#include "dvb_functions.h"
 #include "dvb_ringbuffer.h"
 
-static int dvb_ca_en50221_debug = 0;
+static int dvb_ca_en50221_debug;
+
+module_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);
+MODULE_PARM_DESC(cam_debug, "enable verbose debug messages");
+
 #define dprintk if (dvb_ca_en50221_debug) printk
 
 #define INIT_TIMEOUT_SECS 5
@@ -108,7 +111,7 @@ struct dvb_ca_slot {
         int link_buf_size;
 
         /* semaphore for syncing access to slot structure */
-        struct semaphore sem;
+        struct rw_semaphore sem;
 
         /* buffer for incoming packets */
         struct dvb_ringbuffer rx_buffer;
@@ -199,7 +202,6 @@ static u8* findstr(u8* haystack, int hle
 static int dvb_ca_en50221_check_camstatus(struct dvb_ca_private* ca, int slot)
 {
         int slot_status;
-        int status;
         int cam_present_now;
         int cam_changed;
 
@@ -209,9 +211,7 @@ static int dvb_ca_en50221_check_camstatu
         }
 
         /* poll mode */
-        if ((status = down_interruptible(&ca->slot_info[slot].sem)) != 0) return status;
         slot_status = ca->pub->poll_slot_status(ca->pub, slot);
-        up(&ca->slot_info[slot].sem);
 
         cam_present_now = (slot_status & DVB_CA_EN50221_POLL_CAM_PRESENT) ? 1: 0;
         cam_changed = (slot_status & DVB_CA_EN50221_POLL_CAM_CHANGED) ? 1: 0;
@@ -277,7 +277,7 @@ static int dvb_ca_en50221_wait_if_status
                 }
 
                 /* wait for a bit */
-                dvb_delay(1);
+                msleep(1);
         }
 
         dprintk("%s failed timeout:%lu\n", __FUNCTION__, jiffies - start);
@@ -306,10 +306,6 @@ static int dvb_ca_en50221_link_init(stru
         /* we'll be determining these during this function */
         ca->slot_info[slot].da_irq_supported = 0;
 
-        /* reset the link interface. Note CAM IRQs are disabled */
-        if ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, CMDREG_RS)) != 0) return ret;
-        if ((ret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_FR, HZ/10)) != 0) return ret;
-
         /* set the host link buffer size temporarily. it will be overwritten with the
          * real negotiated size later. */
         ca->slot_info[slot].link_buf_size = 2;
@@ -360,6 +356,13 @@ static int dvb_ca_en50221_read_tuple(str
 
         /* grab the next tuple length and type */
         if ((_tupleType = ca->pub->read_attribute_mem(ca->pub, slot, _address)) < 0) return _tupleType;
+        if (_tupleType == 0xff) {
+                dprintk("END OF CHAIN TUPLE type:0x%x\n", _tupleType);
+                *address += 2;
+                *tupleType = _tupleType;
+                *tupleLength = 0;
+                return 0;
+        }
         if ((_tupleLength = ca->pub->read_attribute_mem(ca->pub, slot, _address+2)) < 0) return _tupleLength;
         _address += 4;
 
@@ -452,8 +455,8 @@ static int dvb_ca_en50221_parse_attribut
 
         /* is it a version we support? */
         if (strncmp(dvb_str + 8, "1.00", 4)) {
-                printk("dvb_ca: Unsupported DVB CAM module version %c%c%c%c\n",
-                        dvb_str[8], dvb_str[9], dvb_str[10], dvb_str[11]);
+                printk("dvb_ca adapter %d: Unsupported DVB CAM module version %c%c%c%c\n",
+		       ca->dvbdev->adapter->num, dvb_str[8], dvb_str[9], dvb_str[10], dvb_str[11]);
                 return -EINVAL;
         }
 
@@ -550,30 +553,27 @@ static int dvb_ca_en50221_read_data(stru
 
         dprintk ("%s\n", __FUNCTION__);
 
-        /* acquire the slot */
-        if ((status = down_interruptible(&ca->slot_info[slot].sem)) != 0) return status;
-
         /* check if we have space for a link buf in the rx_buffer */
         if (ebuf == NULL) {
-                if (dvb_ringbuffer_free(&ca->slot_info[slot].rx_buffer) <
-                    (ca->slot_info[slot].link_buf_size + DVB_RINGBUFFER_PKTHDRSIZE)) {
-                        status = -EAGAIN;
-                        goto exit;
+		int buf_free;
+		
+		down_read(&ca->slot_info[slot].sem);
+		buf_free = dvb_ringbuffer_free(&ca->slot_info[slot].rx_buffer);
+		up_read(&ca->slot_info[slot].sem);
+		
+                if (buf_free < (ca->slot_info[slot].link_buf_size + DVB_RINGBUFFER_PKTHDRSIZE)) {
+			status = -EAGAIN;
+			goto exit;
                 }
         }
 
-        /* reset the interface if there's been a tx error */
+        /* check if there is data available */
         if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0) goto exit;
-        if (status & STATUSREG_TXERR) {
-                ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
-                status = -EIO;
-                goto exit;
-        }
         if (!(status & STATUSREG_DA)) {
-                /* no data */
-                status = 0;
-                goto exit;
-        }
+		/* no data */
+		status = 0;
+		goto exit;
+	}
 
         /* read the amount of data */
         if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH)) < 0) goto exit;
@@ -584,22 +584,22 @@ static int dvb_ca_en50221_read_data(stru
         /* check it will fit */
         if (ebuf == NULL) {
                 if (bytes_read > ca->slot_info[slot].link_buf_size) {
-                        printk("dvb_ca: CAM tried to send a buffer larger than the link buffer size!\n");
+                        printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size!\n", ca->dvbdev->adapter->num);
                         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
                         status = -EIO;
-                        goto exit;
+			goto exit;
                 }
                 if (bytes_read < 2) {
-                        printk("dvb_ca: CAM sent a buffer that was less than 2 bytes!\n");
+                        printk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n", ca->dvbdev->adapter->num);
                         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
                         status = -EIO;
-                        goto exit;
+			goto exit;
                 }
         } else {
                 if (bytes_read > ecount) {
-                        printk("dvb_ca: CAM tried to send a buffer larger than the ecount size!\n");
+                        printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size!\n", ca->dvbdev->adapter->num);
                         status = -EIO;
-                        goto exit;
+			goto exit;
                 }
         }
 
@@ -612,29 +612,32 @@ static int dvb_ca_en50221_read_data(stru
                 buf[i] = status;
         }
 
-        /* check for read error (RE should now go to 0) */
+        /* check for read error (RE should now be 0) */
         if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0) goto exit;
         if (status & STATUSREG_RE) {
-                status = -EIO;
-                goto exit;
-        }
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+		status = -EIO;
+		goto exit;
+	}
 
-        /* OK, add it to the receive buffer, or copy into external buffer if supplied */
+        /* OK, add it to the receive buffer, or copy into external buffer if supplied */	
         if (ebuf == NULL) {
+		down_read(&ca->slot_info[slot].sem);
                 dvb_ringbuffer_pkt_write(&ca->slot_info[slot].rx_buffer, buf, bytes_read);
+		up_read(&ca->slot_info[slot].sem);
         } else {
                 memcpy(ebuf, buf, bytes_read);
         }
+	
+	dprintk("Received CA packet for slot %i connection id 0x%x last_frag:%i size:0x%x\n", slot, buf[0], (buf[1] & 0x80) == 0, bytes_read);
 
         /* wake up readers when a last_fragment is received */
         if ((buf[1] & 0x80) == 0x00) {
-                wake_up_interruptible(&ca->wait_queue);
+		wake_up_interruptible(&ca->wait_queue);
         }
-
-        status = bytes_read;
+	status = bytes_read;
 
 exit:
-        up(&ca->slot_info[slot].sem);
         return status;
 }
 
@@ -662,22 +665,12 @@ static int dvb_ca_en50221_write_data(str
         // sanity check
         if (bytes_write > ca->slot_info[slot].link_buf_size) return -EINVAL;
 
-        /* acquire the slot */
-        if ((status = down_interruptible(&ca->slot_info[slot].sem)) != 0) return status;
-
-        /* reset the interface if there's been a tx error */
+        /* check if interface is actually waiting for us to read from it, or if a read is in progress */
         if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0) goto exitnowrite;
-        if (status & STATUSREG_TXERR) {
-                ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
-                status = -EIO;
-                goto exitnowrite;
-        }
-
-        /* check if interface is actually waiting for us to read from it */
-        if (status & STATUSREG_DA) {
-                status = -EAGAIN;
-                goto exitnowrite;
-        }
+        if (status & (STATUSREG_DA|STATUSREG_RE)) {
+		status = -EAGAIN;
+		goto exitnowrite;
+	}
 
         /* OK, set HC bit */
         if ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN | CMDREG_HC)) != 0) goto exit;
@@ -685,10 +678,10 @@ static int dvb_ca_en50221_write_data(str
         /* check if interface is still free */
         if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0) goto exit;
         if (!(status & STATUSREG_FR)) {
-                /* it wasn't free => try again later */
-                status = -EAGAIN;
-                goto exit;
-        }
+		/* it wasn't free => try again later */
+		status = -EAGAIN; 
+		goto exit;
+	}
 
         /* send the amount of data */
         if ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH, bytes_write >> 8)) != 0) goto exit;
@@ -702,16 +695,18 @@ static int dvb_ca_en50221_write_data(str
         /* check for write error (WE should now be 0) */
         if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0) goto exit;
         if (status & STATUSREG_WE) {
-                status = -EIO;
-                goto exit;
-        }
+		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+		status = -EIO;
+		goto exit;
+	}
         status = bytes_write;
 
+	dprintk("Wrote CA packet for slot %i, connection id 0x%x last_frag:%i size:0x%x\n", slot, buf[0], (buf[1] & 0x80) == 0, bytes_write);
+	
 exit:
         ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);
 
 exitnowrite:
-        up(&ca->slot_info[slot].sem);
         return status;
 }
 
@@ -729,16 +724,14 @@ exitnowrite:
  */
 static int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private* ca, int slot)
 {
-        int status;
-
         dprintk ("%s\n", __FUNCTION__);
 
-        if ((status = down_interruptible(&ca->slot_info[slot].sem)) != 0) return status;
+        down_write(&ca->slot_info[slot].sem);
         ca->pub->slot_shutdown(ca->pub, slot);
         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
         if (ca->slot_info[slot].rx_buffer.data) vfree(ca->slot_info[slot].rx_buffer.data);
         ca->slot_info[slot].rx_buffer.data = NULL;
-        up(&ca->slot_info[slot].sem);
+        up_write(&ca->slot_info[slot].sem);
 
         /* need to wake up all processes to check if they're now
            trying to write to a defunct CAM */
@@ -821,10 +814,7 @@ void dvb_ca_en50221_frda_irq(struct dvb_
                 break;
 
         case DVB_CA_SLOTSTATE_RUNNING:
-                flags = ca->pub->read_cam_control(pubca, slot, CTRLIF_STATUS);
-                if (flags & STATUSREG_DA) {
-                        dvb_ca_en50221_thread_wakeup(ca);
-                }
+		if (ca->open) dvb_ca_en50221_read_data(ca, slot, NULL, 0);
                 break;
         }
 }
@@ -934,7 +924,11 @@ static int dvb_ca_en50221_thread(void* d
 
         /* setup kernel thread */
         snprintf(name, sizeof(name), "kdvb-ca-%i:%i", ca->dvbdev->adapter->num, ca->dvbdev->id);
-        dvb_kernel_thread_setup(name);
+
+        lock_kernel ();
+        daemonize (name);
+        sigfillset (&current->blocked);
+        unlock_kernel ();
 
         /* choose the correct initial delay */
         dvb_ca_en50221_thread_update_delay(ca);
@@ -984,7 +978,7 @@ static int dvb_ca_en50221_thread(void* d
 
                         case DVB_CA_SLOTSTATE_WAITREADY:
                                 if (time_after(jiffies, ca->slot_info[slot].timeout)) {
-                                        printk("dvb_ca: PC card did not respond :(\n");
+                                        printk("dvb_ca adaptor %d: PC card did not respond :(\n", ca->dvbdev->adapter->num);
                                         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
 				        dvb_ca_en50221_thread_update_delay(ca);
                                         break;
@@ -994,18 +988,23 @@ static int dvb_ca_en50221_thread(void* d
 
                         case DVB_CA_SLOTSTATE_VALIDATE:
                                 if (dvb_ca_en50221_parse_attributes(ca, slot) != 0) {
-                                        printk("dvb_ca: Invalid PC card inserted :(\n");
+                                        printk("dvb_ca adapter %d: Invalid PC card inserted :(\n", ca->dvbdev->adapter->num);
                                         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
 				        dvb_ca_en50221_thread_update_delay(ca);
                                         break;
                                 }
                                 if (dvb_ca_en50221_set_configoption(ca, slot) != 0) {
-                                        printk("dvb_ca: Unable to initialise CAM :(\n");
+                                        printk("dvb_ca adapter %d: Unable to initialise CAM :(\n", ca->dvbdev->adapter->num);
                                         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
 				        dvb_ca_en50221_thread_update_delay(ca);
                                         break;
                                 }
-
+                                if (ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, CMDREG_RS) != 0) {
+                                        printk("dvb_ca adapter %d: Unable to reset CAM IF\n", ca->dvbdev->adapter->num);
+                                        ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+                                        dvb_ca_en50221_thread_update_delay(ca);
+                                        break;
+                                }
                                 dprintk("DVB CAM validated successfully\n");
 
                                 ca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);
@@ -1015,7 +1014,7 @@ static int dvb_ca_en50221_thread(void* d
 
                         case DVB_CA_SLOTSTATE_WAITFR:
                                 if (time_after(jiffies, ca->slot_info[slot].timeout)) {
-                                        printk("dvb_ca: DVB CAM did not respond :(\n");
+                                        printk("dvb_ca adapter %d: DVB CAM did not respond :(\n", ca->dvbdev->adapter->num);
                                         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
 				        dvb_ca_en50221_thread_update_delay(ca);
                                         break;
@@ -1030,7 +1029,7 @@ static int dvb_ca_en50221_thread(void* d
 
                         case DVB_CA_SLOTSTATE_LINKINIT:
                                 if (dvb_ca_en50221_link_init(ca, slot) != 0) {
-                                        printk("dvb_ca: DVB CAM link initialisation failed :(\n");
+                                        printk("dvb_ca adapter %d: DVB CAM link initialisation failed :(\n", ca->dvbdev->adapter->num);
                                         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
 			                dvb_ca_en50221_thread_update_delay(ca);
                                         break;
@@ -1038,7 +1037,7 @@ static int dvb_ca_en50221_thread(void* d
 
                                 rxbuf = vmalloc(RX_BUFFER_SIZE);
                                 if (rxbuf == NULL) {
-                                        printk("dvb_ca: Unable to allocate CAM rx buffer :(\n");
+                                        printk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);
                                         ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
 				        dvb_ca_en50221_thread_update_delay(ca);
                                         break;
@@ -1048,12 +1047,16 @@ static int dvb_ca_en50221_thread(void* d
                                 ca->pub->slot_ts_enable(ca->pub, slot);
                                 ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
                                 dvb_ca_en50221_thread_update_delay(ca);
-                                printk("dvb_ca: DVB CAM detected and initialised successfully\n");
+                                printk("dvb_ca adapter %d: DVB CAM detected and initialised successfully\n", ca->dvbdev->adapter->num);
                                 break;
 
                         case DVB_CA_SLOTSTATE_RUNNING:
                                 if (!ca->open) break;
+				
+				// no need to poll if the CAM supports IRQs
+				if (ca->slot_info[slot].da_irq_supported) break;
 
+				// poll mode
                                 pktcount = 0;
                                 while(dvb_ca_en50221_read_data(ca, slot, NULL, 0) > 0) {
                                         if (!ca->open) break;
@@ -1196,7 +1199,7 @@ static ssize_t dvb_ca_en50221_io_write(s
         int status;
         char fragbuf[HOST_LINK_BUF_SIZE];
         int fragpos = 0;
-        size_t fraglen;
+        int fraglen;
         unsigned long timeout;
         int written;
 
@@ -1233,7 +1236,7 @@ static ssize_t dvb_ca_en50221_io_write(s
 			}
                         if (status != -EAGAIN) goto exit;
 
-                        dvb_delay(1);
+                        msleep(1);
                 }
 	        if (!written) {
 		        status = -EIO;
@@ -1257,7 +1260,7 @@ static int dvb_ca_en50221_io_read_condit
         int slot;
         int slot_count = 0;
         int idx;
-        size_t fraglen;
+        int fraglen;
         int connection_id = -1;
         int found = 0;
         u8 hdr[2];
@@ -1266,7 +1269,7 @@ static int dvb_ca_en50221_io_read_condit
         while((slot_count < ca->slot_count) && (!found)) {
                 if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING) goto nextslot;
 
-                if ((*result = down_interruptible(&ca->slot_info[slot].sem)) != 0) return 1;
+                down_read(&ca->slot_info[slot].sem);
 
                 idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
                 while(idx != -1) {
@@ -1281,7 +1284,7 @@ static int dvb_ca_en50221_io_read_condit
                         idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);
                 }
 
-                if (!found) up(&ca->slot_info[slot].sem);
+                if (!found) up_read(&ca->slot_info[slot].sem);
 
 nextslot:
                 slot = (slot + 1) % ca->slot_count;
@@ -1341,7 +1344,7 @@ static ssize_t dvb_ca_en50221_io_read(st
         pktlen = 2;
         do {
                 if (idx == -1) {
-                        printk("dvb_ca: BUG: read packet ended before last_fragment encountered\n");
+                        printk("dvb_ca adapter %d: BUG: read packet ended before last_fragment encountered\n", ca->dvbdev->adapter->num);
                         status = -EIO;
                         goto exit;
                 }
@@ -1378,7 +1381,7 @@ static ssize_t dvb_ca_en50221_io_read(st
         status = pktlen;
 
 exit:
-        up(&ca->slot_info[slot].sem);
+        up_read(&ca->slot_info[slot].sem);
         return status;
 }
 
@@ -1406,7 +1409,9 @@ static int dvb_ca_en50221_io_open(struct
 
         for(i=0; i< ca->slot_count; i++) {
                 if (ca->slot_info[i].slot_state == DVB_CA_SLOTSTATE_RUNNING) {
+		        down_write(&ca->slot_info[i].sem);
                         dvb_ringbuffer_flush(&ca->slot_info[i].rx_buffer);
+		        up_write(&ca->slot_info[i].sem);
                 }
         }
 
@@ -1464,7 +1469,7 @@ static unsigned int dvb_ca_en50221_io_po
         dprintk ("%s\n", __FUNCTION__);
 
         if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
-                up(&ca->slot_info[slot].sem);
+                up_read(&ca->slot_info[slot].sem);
                 mask |= POLLIN;
         }
 
@@ -1475,7 +1480,7 @@ static unsigned int dvb_ca_en50221_io_po
         poll_wait(file, &ca->wait_queue, wait);
 
         if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
-                up(&ca->slot_info[slot].sem);
+                up_read(&ca->slot_info[slot].sem);
                 mask |= POLLIN;
         }
 
@@ -1484,21 +1489,21 @@ static unsigned int dvb_ca_en50221_io_po
 
 
 static struct file_operations dvb_ca_fops = {
-        owner: THIS_MODULE,
-        read: dvb_ca_en50221_io_read,
-        write: dvb_ca_en50221_io_write,
-        ioctl: dvb_ca_en50221_io_ioctl,
-        open: dvb_ca_en50221_io_open,
-        release: dvb_ca_en50221_io_release,
-        poll: dvb_ca_en50221_io_poll,
+        .owner	= THIS_MODULE,
+        .read	= dvb_ca_en50221_io_read,
+        .write	= dvb_ca_en50221_io_write,
+        .ioctl	= dvb_ca_en50221_io_ioctl,
+        .open	= dvb_ca_en50221_io_open,
+        .release= dvb_ca_en50221_io_release,
+        .poll	= dvb_ca_en50221_io_poll,
 };
 
 static struct dvb_device dvbdev_ca = {
-        priv: NULL,
-        users: 1,
-        readers: 1,
-        writers: 1,
-        fops: &dvb_ca_fops,
+        .priv	= NULL,
+        .users	= 1,
+        .readers= 1,
+        .writers= 1,
+        .fops	= &dvb_ca_fops,
 };
 
 
@@ -1559,7 +1564,7 @@ int dvb_ca_en50221_init(struct dvb_adapt
                 ca->slot_info[i].slot_state = DVB_CA_SLOTSTATE_NONE;
                 atomic_set(&ca->slot_info[i].camchange_count, 0);
                 ca->slot_info[i].camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;
-                init_MUTEX(&ca->slot_info[i].sem);
+                init_rwsem(&ca->slot_info[i].sem);
         }
 
         if (signal_pending(current)) {
@@ -1569,7 +1574,9 @@ int dvb_ca_en50221_init(struct dvb_adapt
         mb();
 
         /* create a kthread for monitoring this CA device */
+
         ret = kernel_thread (dvb_ca_en50221_thread, ca, 0);
+
         if (ret < 0) {
                 printk("dvb_ca_init: failed to start kernel_thread (%d)\n", ret);
                 goto error;
@@ -1605,7 +1612,7 @@ void dvb_ca_en50221_release(struct dvb_c
         /* shutdown the thread if there was one */
         if (ca->thread_pid) {
                 if (kill_proc(ca->thread_pid, 0, 1) == -ESRCH) {
-                        printk("dvb_ca_release: thread PID %d already died\n", ca->thread_pid);
+                        printk("dvb_ca_release adapter %d: thread PID %d already died\n", ca->dvbdev->adapter->num, ca->thread_pid);
                 } else {
                         ca->exit = 1;
                         mb();
@@ -1623,6 +1630,3 @@ void dvb_ca_en50221_release(struct dvb_c
         pubca->private = NULL;
 }
 
-MODULE_PARM(dvb_ca_en50221_debug,"i");
-
-MODULE_PARM_DESC(dvb_ca_en50221_debug, "enable verbose debug messages");
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ca_en50221.h linux/drivers/media/dvb/dvb-core/dvb_ca_en50221.h
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ca_en50221.h	2004-09-14 10:37:29.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_ca_en50221.h	2004-09-17 14:56:38.738612482 +0200
@@ -42,6 +42,9 @@
 /* Structure describing a CA interface */
 struct dvb_ca_en50221 {
 
+	/* NOTE: the read_*, write_* and poll_slot_status functions must use locks as
+	 * they may be called from several threads at once */
+
 	/* functions for accessing attribute memory on the CAM */
 	int (*read_attribute_mem)(struct dvb_ca_en50221* ca, int slot, int address);
 	int (*write_attribute_mem)(struct dvb_ca_en50221* ca, int slot, int address, u8 value);
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_demux.c linux/drivers/media/dvb/dvb-core/dvb_demux.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_demux.c	2004-09-14 10:34:48.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_demux.c	2004-09-17 14:56:38.743611546 +0200
@@ -27,11 +27,10 @@
 #include <linux/module.h>
 #include <linux/poll.h>
 #include <linux/string.h>
-	#include <linux/crc32.h>
+#include <linux/crc32.h>
 #include <asm/uaccess.h>
 
 #include "dvb_demux.h"
-#include "dvb_functions.h"
 
 #define NOBUFS  
 /* 
@@ -94,14 +93,16 @@ static inline u16 ts_pid(const u8 *buf)
 
 static inline u8 payload(const u8 *tsp)
 {
-	if (!(tsp[3]&0x10)) // no payload?
+	if (!(tsp[3] & 0x10)) // no payload?
 		return 0;
-	if (tsp[3]&0x20) {  // adaptation field?
-		if (tsp[4]>183)    // corrupted data?
+
+	if (tsp[3] & 0x20) {  // adaptation field?
+		if (tsp[4] > 183)    // corrupted data?
 			return 0;
 		else
 			return 184-1-tsp[4];
 	}
+
 	return 184;
 }
 
@@ -204,7 +205,7 @@ static inline int dvb_dmx_swfilter_secti
 		section_syntax_indicator = ((sec->secbuf[1] & 0x80) != 0);
 		if (section_syntax_indicator &&
 		    demux->check_crc32(feed, sec->secbuf, sec->seclen))
-		return -1;
+			return -1;
 	}
 
 	do {
@@ -239,13 +240,13 @@ static void dvb_dmx_swfilter_section_new
 			for(i = 0; i < n; i++)
 				printk(" %02x", sec->secbuf[i]);
 			printk("\n");
-			}
-			}
+		}
+	}
 #endif
 
 	sec->tsfeedp = sec->secbufp = sec->seclen = 0;
 	sec->secbuf = sec->secbuf_base;
-		}
+}
 
 /* 
 ** Losless Section Demux 1.4 by Emard
@@ -277,7 +278,7 @@ static int dvb_dmx_swfilter_section_copy
 	/* -----------------------------------------------------
 	** Dump all the sections we can find in the data (Emard)
 	*/
-
+	
 	limit = sec->tsfeedp;
 	if(limit > DMX_MAX_SECFEED_SIZE)
 		return -1; /* internal error should never happen */
@@ -297,11 +298,11 @@ static int dvb_dmx_swfilter_section_copy
 		dvb_dmx_swfilter_section_feed(feed);
 		sec->secbufp += seclen; /* secbufp and secbuf moving together is */
 		sec->secbuf += seclen; /* redundand but saves pointer arithmetic */
-		}
-
-		return 0;
 	}
 
+	return 0;
+}
+
 
 static int dvb_dmx_swfilter_section_packet(struct dvb_demux_feed *feed, const u8 *buf) 
 {
@@ -310,12 +311,12 @@ static int dvb_dmx_swfilter_section_pack
 	u8 cc;
 
 	count = payload(buf);
-		
+
 	if (count == 0)  /* count == 0 if no payload or out of range */
-			return -1;
+		return -1;
 
 	p = 188-count; /* payload start */
-
+	
 	cc = buf[3] & 0x0f;
 	ccok = ((feed->cc+1) & 0x0f) == cc ? 1 : 0;
 	feed->cc = cc;
@@ -416,7 +417,7 @@ void dvb_dmx_swfilter_packet(struct dvb_
 			continue;
 
 		if (feed->pid == pid) {
-			dvb_dmx_swfilter_packet_type (feed, buf);
+			dvb_dmx_swfilter_packet_type(feed, buf);
 			if (DVR_FEED(feed))
 				continue;
 		}
@@ -426,14 +427,13 @@ void dvb_dmx_swfilter_packet(struct dvb_
 	}
 }
 
-
 void dvb_dmx_swfilter_packets(struct dvb_demux *demux, const u8 *buf, size_t count)
 {
 	spin_lock(&demux->lock);
 
 	while (count--) {
                	if(buf[0] == 0x47) {
-		dvb_dmx_swfilter_packet(demux, buf);
+		        dvb_dmx_swfilter_packet(demux, buf);
 		}
 		buf += 188;
 	}
@@ -444,8 +444,8 @@ void dvb_dmx_swfilter_packets(struct dvb
 
 void dvb_dmx_swfilter(struct dvb_demux *demux, const u8 *buf, size_t count)
 {
-	int p = 0,i, j;
-	
+	int p = 0, i, j;
+
 	spin_lock(&demux->lock);
 
 	if ((i = demux->tsbufp)) {
@@ -456,7 +456,7 @@ void dvb_dmx_swfilter(struct dvb_demux *
 		}
 		memcpy(&demux->tsbuf[i], buf, j);
 		if (demux->tsbuf[0] == 0x47)
-		dvb_dmx_swfilter_packet(demux, demux->tsbuf);
+			dvb_dmx_swfilter_packet(demux, demux->tsbuf);
 		demux->tsbufp = 0;
 		p += j;
 	}
@@ -565,29 +565,35 @@ static int dvb_demux_feed_find(struct dv
 		if (entry == feed)
 			return 1;
 
-		return 0;
-		}
+	return 0;
+}
 
 static void dvb_demux_feed_add(struct dvb_demux_feed *feed)
 {
+	spin_lock_irq(&feed->demux->lock);
 	if (dvb_demux_feed_find(feed)) {
 		printk(KERN_ERR "%s: feed already in list (type=%x state=%x pid=%x)\n",
 				__FUNCTION__, feed->type, feed->state, feed->pid);
-		return;
+		goto out;
 	}
 
 	list_add(&feed->list_head, &feed->demux->feed_list);
+out:
+	spin_unlock_irq(&feed->demux->lock);
 }
 
 static void dvb_demux_feed_del(struct dvb_demux_feed *feed)
 {
+	spin_lock_irq(&feed->demux->lock);
 	if (!(dvb_demux_feed_find(feed))) {
 		printk(KERN_ERR "%s: feed not in list (type=%x state=%x pid=%x)\n",
 				__FUNCTION__, feed->type, feed->state, feed->pid);
-		return;
-}
+		goto out;
+	}
 
 	list_del(&feed->list_head);
+out:
+	spin_unlock_irq(&feed->demux->lock);
 }
 
 static int dmx_ts_feed_set (struct dmx_ts_feed* ts_feed, u16 pid, int ts_type, 
@@ -600,7 +606,7 @@ static int dmx_ts_feed_set (struct dmx_t
 
 	if (pid > DMX_MAX_PID)
 		return -EINVAL;
-	
+
 	if (down_interruptible (&demux->mutex))
 		return -ERESTARTSYS;
 
@@ -696,7 +702,7 @@ static int dmx_ts_feed_stop_filtering(st
 	if (down_interruptible (&demux->mutex))
 		return -ERESTARTSYS;
 
-	if (feed->state<DMX_STATE_GO) {
+	if (feed->state < DMX_STATE_GO) {
 		up(&demux->mutex);
 		return -EINVAL;
 	}
@@ -787,9 +793,9 @@ static int dvbdmx_release_ts_feed(struct
 
 	dvb_demux_feed_del(feed);
 
-		feed->pid = 0xffff;
-	
-	if (feed->ts_type & TS_DECODER)
+	feed->pid = 0xffff;
+
+	if (feed->ts_type & TS_DECODER && feed->pes_type < DMX_TS_PES_OTHER)
 		demux->pesfilter[feed->pes_type] = NULL;
 
 	up(&demux->mutex);
@@ -804,43 +810,43 @@ static int dvbdmx_release_ts_feed(struct
 static int dmx_section_feed_allocate_filter(struct dmx_section_feed* feed, 
 				     struct dmx_section_filter** filter) 
 {
-	struct dvb_demux_feed *dvbdmxfeed=(struct dvb_demux_feed *) feed;
-	struct dvb_demux *dvbdemux=dvbdmxfeed->demux;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux *dvbdemux = dvbdmxfeed->demux;
 	struct dvb_demux_filter *dvbdmxfilter;
 
 	if (down_interruptible (&dvbdemux->mutex))
 		return -ERESTARTSYS;
 
-	dvbdmxfilter=dvb_dmx_filter_alloc(dvbdemux);
+	dvbdmxfilter = dvb_dmx_filter_alloc(dvbdemux);
 	if (!dvbdmxfilter) {
 		up(&dvbdemux->mutex);
 		return -EBUSY;
 	}
 
 	spin_lock_irq(&dvbdemux->lock);
-	*filter=&dvbdmxfilter->filter;
-	(*filter)->parent=feed;
-	(*filter)->priv=NULL;
-	dvbdmxfilter->feed=dvbdmxfeed;
-	dvbdmxfilter->type=DMX_TYPE_SEC;
-	dvbdmxfilter->state=DMX_STATE_READY;
-
-	dvbdmxfilter->next=dvbdmxfeed->filter;
-	dvbdmxfeed->filter=dvbdmxfilter;
+	*filter = &dvbdmxfilter->filter;
+	(*filter)->parent = feed;
+	(*filter)->priv = NULL;
+	dvbdmxfilter->feed = dvbdmxfeed;
+	dvbdmxfilter->type = DMX_TYPE_SEC;
+	dvbdmxfilter->state = DMX_STATE_READY;
+	dvbdmxfilter->next = dvbdmxfeed->filter;
+	dvbdmxfeed->filter = dvbdmxfilter;
 	spin_unlock_irq(&dvbdemux->lock);
+
 	up(&dvbdemux->mutex);
 	return 0;
 }
 
 
 static int dmx_section_feed_set(struct dmx_section_feed* feed, 
-		     u16 pid, size_t circular_buffer_size, 
-		     int descramble, int check_crc) 
+			 u16 pid, size_t circular_buffer_size, 
+			 int descramble, int check_crc) 
 {
-	struct dvb_demux_feed *dvbdmxfeed=(struct dvb_demux_feed *) feed;
-	struct dvb_demux *dvbdmx=dvbdmxfeed->demux;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 
-	if (pid>0x1fff)
+	if (pid > 0x1fff)
 		return -EINVAL;
 
 	if (down_interruptible (&dvbdmx->mutex))
@@ -849,16 +855,17 @@ static int dmx_section_feed_set(struct d
 	dvb_demux_feed_add(dvbdmxfeed);
 
 	dvbdmxfeed->pid = pid;
-	dvbdmxfeed->buffer_size=circular_buffer_size;
-	dvbdmxfeed->descramble=descramble;
+	dvbdmxfeed->buffer_size = circular_buffer_size;
+	dvbdmxfeed->descramble = descramble;
 	if (dvbdmxfeed->descramble) {
 		up(&dvbdmx->mutex);
 		return -ENOSYS;
 	}
 
-	dvbdmxfeed->feed.sec.check_crc=check_crc;
+	dvbdmxfeed->feed.sec.check_crc = check_crc;
+
 #ifdef NOBUFS
-	dvbdmxfeed->buffer=NULL;
+	dvbdmxfeed->buffer = NULL;
 #else
 	dvbdmxfeed->buffer=vmalloc(dvbdmxfeed->buffer_size);
 	if (!dvbdmxfeed->buffer) {
@@ -866,38 +873,40 @@ static int dmx_section_feed_set(struct d
 		return -ENOMEM;
 	}
 #endif
-	dvbdmxfeed->state=DMX_STATE_READY;
+
+	dvbdmxfeed->state = DMX_STATE_READY;
 	up(&dvbdmx->mutex);
 	return 0;
 }
 
+
 static void prepare_secfilters(struct dvb_demux_feed *dvbdmxfeed)
 {
 	int i;
 	struct dvb_demux_filter *f;
 	struct dmx_section_filter *sf;
 	u8 mask, mode, doneq;
-		
+
 	if (!(f=dvbdmxfeed->filter))
 		return;
 	do {
-		sf=&f->filter;
-		doneq=0;
+		sf = &f->filter;
+		doneq = 0;
 		for (i=0; i<DVB_DEMUX_MASK_MAX; i++) {
-			mode=sf->filter_mode[i];
-			mask=sf->filter_mask[i];
-			f->maskandmode[i]=mask&mode;
-			doneq|=f->maskandnotmode[i]=mask&~mode;
+			mode = sf->filter_mode[i];
+			mask = sf->filter_mask[i];
+			f->maskandmode[i] = mask & mode;
+			doneq |= f->maskandnotmode[i] = mask & ~mode;
 		}
-		f->doneq=doneq ? 1 : 0;
-	} while ((f=f->next));
+		f->doneq = doneq ? 1 : 0;
+	} while ((f = f->next));
 }
 
 
 static int dmx_section_feed_start_filtering(struct dmx_section_feed *feed)
 {
-	struct dvb_demux_feed *dvbdmxfeed=(struct dvb_demux_feed *) feed;
-	struct dvb_demux *dvbdmx=dvbdmxfeed->demux;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	int ret;
 
 	if (down_interruptible (&dvbdmx->mutex))
@@ -907,6 +916,7 @@ static int dmx_section_feed_start_filter
 		up(&dvbdmx->mutex);
 		return -EBUSY;
 	}
+
 	if (!dvbdmxfeed->filter) {
 		up(&dvbdmx->mutex);
 		return -EINVAL;
@@ -914,8 +924,8 @@ static int dmx_section_feed_start_filter
 
 	dvbdmxfeed->feed.sec.tsfeedp = 0;
 	dvbdmxfeed->feed.sec.secbuf = dvbdmxfeed->feed.sec.secbuf_base;
-	dvbdmxfeed->feed.sec.secbufp=0;
-	dvbdmxfeed->feed.sec.seclen=0;
+	dvbdmxfeed->feed.sec.secbufp = 0;
+	dvbdmxfeed->feed.sec.seclen = 0;
 	
 	if (!dvbdmx->start_feed) {
 		up(&dvbdmx->mutex);
@@ -930,9 +940,10 @@ static int dmx_section_feed_start_filter
 	}
 
 	spin_lock_irq(&dvbdmx->lock);
-	feed->is_filtering=1;
-	dvbdmxfeed->state=DMX_STATE_GO;
+	feed->is_filtering = 1;
+	dvbdmxfeed->state = DMX_STATE_GO;
 	spin_unlock_irq(&dvbdmx->lock);
+
 	up(&dvbdmx->mutex);
 	return 0;
 }
@@ -940,8 +951,8 @@ static int dmx_section_feed_start_filter
 
 static int dmx_section_feed_stop_filtering(struct dmx_section_feed* feed)
 {
-	struct dvb_demux_feed *dvbdmxfeed=(struct dvb_demux_feed *) feed;
-	struct dvb_demux *dvbdmx=dvbdmxfeed->demux;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	int ret;
 
 	if (down_interruptible (&dvbdmx->mutex))
@@ -951,11 +962,14 @@ static int dmx_section_feed_stop_filteri
 		up(&dvbdmx->mutex);
 		return -ENODEV;
 	}
-	ret=dvbdmx->stop_feed(dvbdmxfeed); 
+
+	ret = dvbdmx->stop_feed(dvbdmxfeed); 
+
 	spin_lock_irq(&dvbdmx->lock);
-	dvbdmxfeed->state=DMX_STATE_READY;
-	feed->is_filtering=0;
+	dvbdmxfeed->state = DMX_STATE_READY;
+	feed->is_filtering = 0;
 	spin_unlock_irq(&dvbdmx->lock);
+
 	up(&dvbdmx->mutex);
 	return ret;
 }
@@ -964,31 +978,33 @@ static int dmx_section_feed_stop_filteri
 static int dmx_section_feed_release_filter(struct dmx_section_feed *feed, 
 				struct dmx_section_filter* filter)
 {
-	struct dvb_demux_filter *dvbdmxfilter=(struct dvb_demux_filter *) filter, *f;
-	struct dvb_demux_feed *dvbdmxfeed=(struct dvb_demux_feed *) feed;
-	struct dvb_demux *dvbdmx=dvbdmxfeed->demux;
+	struct dvb_demux_filter *dvbdmxfilter = (struct dvb_demux_filter *) filter, *f;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 
 	if (down_interruptible (&dvbdmx->mutex))
 		return -ERESTARTSYS;
 
-	if (dvbdmxfilter->feed!=dvbdmxfeed) {
+	if (dvbdmxfilter->feed != dvbdmxfeed) {
 		up(&dvbdmx->mutex);
 		return -EINVAL;
 	}
+
 	if (feed->is_filtering) 
 		feed->stop_filtering(feed);
 	
 	spin_lock_irq(&dvbdmx->lock);
-	f=dvbdmxfeed->filter;
+	f = dvbdmxfeed->filter;
 
 	if (f == dvbdmxfilter) {
-		dvbdmxfeed->filter=dvbdmxfilter->next;
+		dvbdmxfeed->filter = dvbdmxfilter->next;
 	} else {
-		while(f->next!=dvbdmxfilter)
-			f=f->next;
-		f->next=f->next->next;
+		while(f->next != dvbdmxfilter)
+			f = f->next;
+		f->next = f->next->next;
 	}
-	dvbdmxfilter->state=DMX_STATE_FREE;
+
+	dvbdmxfilter->state = DMX_STATE_FREE;
 	spin_unlock_irq(&dvbdmx->lock);
 	up(&dvbdmx->mutex);
 	return 0;
@@ -998,35 +1014,36 @@ static int dvbdmx_allocate_section_feed(
 					struct dmx_section_feed **feed,
 					dmx_section_cb callback)
 {
-	struct dvb_demux *dvbdmx=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdmx = (struct dvb_demux *) demux;
 	struct dvb_demux_feed *dvbdmxfeed;
 
 	if (down_interruptible (&dvbdmx->mutex))
 		return -ERESTARTSYS;
 
-	if (!(dvbdmxfeed=dvb_dmx_feed_alloc(dvbdmx))) {
+	if (!(dvbdmxfeed = dvb_dmx_feed_alloc(dvbdmx))) {
 		up(&dvbdmx->mutex);
 		return -EBUSY;
 	}
-	dvbdmxfeed->type=DMX_TYPE_SEC;
-	dvbdmxfeed->cb.sec=callback;
-	dvbdmxfeed->demux=dvbdmx;
-	dvbdmxfeed->pid=0xffff;
+
+	dvbdmxfeed->type = DMX_TYPE_SEC;
+	dvbdmxfeed->cb.sec = callback;
+	dvbdmxfeed->demux = dvbdmx;
+	dvbdmxfeed->pid = 0xffff;
 	dvbdmxfeed->feed.sec.secbuf = dvbdmxfeed->feed.sec.secbuf_base;
 	dvbdmxfeed->feed.sec.secbufp = dvbdmxfeed->feed.sec.seclen = 0;
 	dvbdmxfeed->feed.sec.tsfeedp = 0;
-	dvbdmxfeed->filter=NULL;
-	dvbdmxfeed->buffer=NULL;
+	dvbdmxfeed->filter = NULL;
+	dvbdmxfeed->buffer = NULL;
 
 	(*feed)=&dvbdmxfeed->feed.sec;
-	(*feed)->is_filtering=0;
-	(*feed)->parent=demux;
-	(*feed)->priv=NULL;
-
-	(*feed)->set=dmx_section_feed_set;
-	(*feed)->allocate_filter=dmx_section_feed_allocate_filter;
-	(*feed)->start_filtering=dmx_section_feed_start_filtering;
-	(*feed)->stop_filtering=dmx_section_feed_stop_filtering;
+	(*feed)->is_filtering = 0;
+	(*feed)->parent = demux;
+	(*feed)->priv = NULL;
+
+	(*feed)->set = dmx_section_feed_set;
+	(*feed)->allocate_filter = dmx_section_feed_allocate_filter;
+	(*feed)->start_filtering = dmx_section_feed_start_filtering;
+	(*feed)->stop_filtering = dmx_section_feed_stop_filtering;
 	(*feed)->release_filter = dmx_section_feed_release_filter;
 
 	up(&dvbdmx->mutex);
@@ -1036,8 +1053,8 @@ static int dvbdmx_allocate_section_feed(
 static int dvbdmx_release_section_feed(struct dmx_demux *demux, 
 				       struct dmx_section_feed *feed)
 {
-	struct dvb_demux_feed *dvbdmxfeed=(struct dvb_demux_feed *) feed;
-	struct dvb_demux *dvbdmx=(struct dvb_demux *) demux;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux *dvbdmx = (struct dvb_demux *) demux;
 
 	if (down_interruptible (&dvbdmx->mutex))
 		return -ERESTARTSYS;
@@ -1056,7 +1073,7 @@ static int dvbdmx_release_section_feed(s
 
 	dvb_demux_feed_del(dvbdmxfeed);
 
-		dvbdmxfeed->pid = 0xffff;
+	dvbdmxfeed->pid = 0xffff;
 
 	up(&dvbdmx->mutex);
 	return 0;
@@ -1069,10 +1086,11 @@ static int dvbdmx_release_section_feed(s
 
 static int dvbdmx_open(struct dmx_demux *demux)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
 
-	if (dvbdemux->users>=MAX_DVB_DEMUX_USERS)
+	if (dvbdemux->users >= MAX_DVB_DEMUX_USERS)
 		return -EUSERS;
+
 	dvbdemux->users++;
 	return 0;
 }
@@ -1080,10 +1098,11 @@ static int dvbdmx_open(struct dmx_demux 
 
 static int dvbdmx_close(struct dmx_demux *demux)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
 
-	if (dvbdemux->users==0)
+	if (dvbdemux->users == 0)
 		return -ENODEV;
+
 	dvbdemux->users--;
 	//FIXME: release any unneeded resources if users==0
 	return 0;
@@ -1110,9 +1129,9 @@ static int dvbdmx_write(struct dmx_demux
 
 static int dvbdmx_add_frontend(struct dmx_demux *demux, struct dmx_frontend *frontend)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
 	struct list_head *head = &dvbdemux->frontend_list;
-
+	
 	list_add(&(frontend->connectivity_list), head);
 
 	return 0;
@@ -1121,8 +1140,8 @@ static int dvbdmx_add_frontend(struct dm
 
 static int dvbdmx_remove_frontend(struct dmx_demux *demux, struct dmx_frontend *frontend)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
-	struct list_head *pos, *n, *head=&dvbdemux->frontend_list;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct list_head *pos, *n, *head = &dvbdemux->frontend_list;
 
 	list_for_each_safe (pos, n, head) {
 		if (DMX_FE_ENTRY(pos) == frontend) {
@@ -1130,23 +1149,25 @@ static int dvbdmx_remove_frontend(struct
 			return 0;
 		}
 	}
+
 	return -ENODEV;
 }
 
 
 static struct list_head * dvbdmx_get_frontends(struct dmx_demux *demux)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
 
 	if (list_empty(&dvbdemux->frontend_list))
 		return NULL;
+
 	return &dvbdemux->frontend_list;
 }
 
 
 int dvbdmx_connect_frontend(struct dmx_demux *demux, struct dmx_frontend *frontend)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
 
 	if (demux->frontend)
 		return -EINVAL;
@@ -1154,7 +1175,7 @@ int dvbdmx_connect_frontend(struct dmx_d
 	if (down_interruptible (&dvbdemux->mutex))
 		return -ERESTARTSYS;
 
-	demux->frontend=frontend;
+	demux->frontend = frontend;
 	up(&dvbdemux->mutex);
 	return 0;
 }
@@ -1162,12 +1183,13 @@ int dvbdmx_connect_frontend(struct dmx_d
 
 int dvbdmx_disconnect_frontend(struct dmx_demux *demux)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
 
 	if (down_interruptible (&dvbdemux->mutex))
 		return -ERESTARTSYS;
 
-	demux->frontend=NULL;
+	demux->frontend = NULL;
+
 	up(&dvbdemux->mutex);
 	return 0;
 }
@@ -1175,7 +1197,7 @@ int dvbdmx_disconnect_frontend(struct dm
 
 static int dvbdmx_get_pes_pids(struct dmx_demux *demux, u16 *pids)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
 
 	memcpy(pids, dvbdemux->pids, 5*sizeof(u16));
 	return 0;
@@ -1187,35 +1209,40 @@ int dvb_dmx_init(struct dvb_demux *dvbde
 	int i, err;
 	struct dmx_demux *dmx = &dvbdemux->dmx;
 
-	dvbdemux->users=0;
-	dvbdemux->filter=vmalloc(dvbdemux->filternum*sizeof(struct dvb_demux_filter));
+	dvbdemux->users = 0;
+	dvbdemux->filter = vmalloc(dvbdemux->filternum*sizeof(struct dvb_demux_filter));
+
 	if (!dvbdemux->filter)
 		return -ENOMEM;
 
-	dvbdemux->feed=vmalloc(dvbdemux->feednum*sizeof(struct dvb_demux_feed));
+	dvbdemux->feed = vmalloc(dvbdemux->feednum*sizeof(struct dvb_demux_feed));
 	if (!dvbdemux->feed) {
 		vfree(dvbdemux->filter);
 		return -ENOMEM;
 	}
+
 	for (i=0; i<dvbdemux->filternum; i++) {
-		dvbdemux->filter[i].state=DMX_STATE_FREE;
-		dvbdemux->filter[i].index=i;
+		dvbdemux->filter[i].state = DMX_STATE_FREE;
+		dvbdemux->filter[i].index = i;
 	}
+
 	for (i=0; i<dvbdemux->feednum; i++)
-		dvbdemux->feed[i].state=DMX_STATE_FREE;
+		dvbdemux->feed[i].state = DMX_STATE_FREE;
+
 	dvbdemux->frontend_list.next=
 	  dvbdemux->frontend_list.prev=
 	    &dvbdemux->frontend_list;
+
 	for (i=0; i<DMX_TS_PES_OTHER; i++) {
-		dvbdemux->pesfilter[i]=NULL;
-		dvbdemux->pids[i]=0xffff;
+		dvbdemux->pesfilter[i] = NULL;
+		dvbdemux->pids[i] = 0xffff;
 	}
 
 	INIT_LIST_HEAD(&dvbdemux->feed_list);
 
 	dvbdemux->playing = 0;
 	dvbdemux->recording = 0;
-	dvbdemux->tsbufp=0;
+	dvbdemux->tsbufp = 0;
 
 	if (!dvbdemux->check_crc32)
 		dvbdemux->check_crc32 = dvb_dmx_crc32;
@@ -1223,26 +1250,27 @@ int dvb_dmx_init(struct dvb_demux *dvbde
 	 if (!dvbdemux->memcopy)
 		 dvbdemux->memcopy = dvb_dmx_memcopy;
 
-	dmx->frontend=NULL;
+	dmx->frontend = NULL;
 	dmx->reg_list.prev = dmx->reg_list.next = &dmx->reg_list;
-	dmx->priv=(void *) dvbdemux;
-	dmx->open=dvbdmx_open;
-	dmx->close=dvbdmx_close;
-	dmx->write=dvbdmx_write;
-	dmx->allocate_ts_feed=dvbdmx_allocate_ts_feed;
-	dmx->release_ts_feed=dvbdmx_release_ts_feed;
-	dmx->allocate_section_feed=dvbdmx_allocate_section_feed;
-	dmx->release_section_feed=dvbdmx_release_section_feed;
+	dmx->priv = (void *) dvbdemux;
+	dmx->open = dvbdmx_open;
+	dmx->close = dvbdmx_close;
+	dmx->write = dvbdmx_write;
+	dmx->allocate_ts_feed = dvbdmx_allocate_ts_feed;
+	dmx->release_ts_feed = dvbdmx_release_ts_feed;
+	dmx->allocate_section_feed = dvbdmx_allocate_section_feed;
+	dmx->release_section_feed = dvbdmx_release_section_feed;
 
-	dmx->descramble_mac_address=NULL;
-	dmx->descramble_section_payload=NULL;
+	dmx->descramble_mac_address = NULL;
+	dmx->descramble_section_payload = NULL;
 	
-	dmx->add_frontend=dvbdmx_add_frontend;
-	dmx->remove_frontend=dvbdmx_remove_frontend;
-	dmx->get_frontends=dvbdmx_get_frontends;
-	dmx->connect_frontend=dvbdmx_connect_frontend;
-	dmx->disconnect_frontend=dvbdmx_disconnect_frontend;
-	dmx->get_pes_pids=dvbdmx_get_pes_pids;
+	dmx->add_frontend = dvbdmx_add_frontend;
+	dmx->remove_frontend = dvbdmx_remove_frontend;
+	dmx->get_frontends = dvbdmx_get_frontends;
+	dmx->connect_frontend = dvbdmx_connect_frontend;
+	dmx->disconnect_frontend = dvbdmx_disconnect_frontend;
+	dmx->get_pes_pids = dvbdmx_get_pes_pids;
+
 	sema_init(&dvbdemux->mutex, 1);
 	spin_lock_init(&dvbdemux->lock);
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_filter.c linux/drivers/media/dvb/dvb-core/dvb_filter.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_filter.c	2004-09-14 10:38:13.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_filter.c	2004-09-17 14:56:38.745611171 +0200
@@ -569,11 +569,11 @@ int dvb_filter_pes2ts(struct dvb_filter_
 {
 	unsigned char *buf=p2ts->buf;
 	int ret=0, rest;
-	
+
 	//len=6+((pes[4]<<8)|pes[5]);
 
 	if (payload_start)
-	buf[1]|=0x40;
+		buf[1]|=0x40;
 	else
 		buf[1]&=~0x40;
 	while (len>=184) {
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_filter.h linux/drivers/media/dvb/dvb-core/dvb_filter.h
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_filter.h	2004-09-14 10:34:53.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_filter.h	2004-09-17 14:56:38.748610609 +0200
@@ -219,18 +219,18 @@ struct mpg_picture {
                   /* [0] 1st field, [1] 2nd field */
 
         s8        picture_coding_type[2];
-                 /* [0] 1st field, [1] 2nd field */
+                  /* [0] 1st field, [1] 2nd field */
         s8        picture_structure[2];
-                 /* [0] 1st field, [1] 2nd field */
+                  /* [0] 1st field, [1] 2nd field */
         s8        picture_display_extension_flag[2];
-                 /* [0] 1st field, [1] 2nd field */
-                 /* picture_display_extenion() 0:no 1:exit*/
+                  /* [0] 1st field, [1] 2nd field */
+                  /* picture_display_extenion() 0:no 1:exit*/
         s8        pts_flag[2];
-                 /* [0] 1st field, [1] 2nd field */
+                  /* [0] 1st field, [1] 2nd field */
 };
 
 struct dvb_audio_info {
-	int layer               ;
+	int layer;
 	u32 bit_rate;
 	u32 frequency;
 	u32 mode;
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_frontend.c linux/drivers/media/dvb/dvb-core/dvb_frontend.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_frontend.c	2004-09-14 10:34:54.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_frontend.c	2004-09-17 14:56:38.754609485 +0200
@@ -1,10 +1,11 @@
 /*
- * dvb-core.c: DVB core driver
+ * dvb_frontend.c: DVB frontend tuning interface/thread
+ *
  *
  * Copyright (C) 1999-2001 Ralph  Metzler
- *                         Marcus Metzler
- *                         Holger Waechtler 
- *                                    for convergence integrated media GmbH
+ *			   Marcus Metzler
+ *			   Holger Waechtler
+ *				      for convergence integrated media GmbH
  *
  * Copyright (C) 2004 Andrew de Quincey (tuning thread cleanup)
  *
@@ -15,7 +16,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -31,13 +32,33 @@
 #include <linux/slab.h>
 #include <linux/poll.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/list.h>
 #include <asm/processor.h>
 #include <asm/semaphore.h>
 
 #include "dvb_frontend.h"
 #include "dvbdev.h"
-#include "dvb_functions.h"
+
+static int dvb_frontend_debug;
+static int dvb_shutdown_timeout = 5;
+static int dvb_override_frequency_bending;
+static int dvb_force_auto_inversion;
+static int dvb_override_tune_delay;
+static int do_frequency_bending;
+
+module_param_named(frontend_debug, dvb_frontend_debug, int, 0644);
+MODULE_PARM_DESC(dvb_frontend_debug, "Turn on/off frontend core debugging (default:off).");
+module_param(dvb_shutdown_timeout, int, 0444);
+MODULE_PARM_DESC(dvb_shutdown_timeout, "wait <shutdown_timeout> seconds after close() before suspending hardware");
+module_param(dvb_override_frequency_bending, int, 0444);
+MODULE_PARM_DESC(dvb_override_frequency_bending, "0: normal (default), 1: never use frequency bending, 2: always use frequency bending");
+module_param(dvb_force_auto_inversion, int, 0444);
+MODULE_PARM_DESC(dvb_force_auto_inversion, "0: normal (default), 1: INVERSION_AUTO forced always");
+module_param(dvb_override_tune_delay, int, 0444);
+MODULE_PARM_DESC(dvb_override_tune_delay, "0: normal (default), >0 => delay in milliseconds to wait for lock after a tune attempt");
+
+#define dprintk if (dvb_frontend_debug) printk
 
 #define FESTATE_IDLE 1
 #define FESTATE_RETUNE 2
@@ -66,26 +87,15 @@
  * FESTATE_LOSTLOCK. When the lock has been lost, and we're searching it again.
  */
 
-
-static int dvb_frontend_debug = 0;
-static int dvb_shutdown_timeout = 5;
-static int dvb_override_frequency_bending = 0;
-static int dvb_force_auto_inversion = 0;
-static int dvb_override_tune_delay = 0;
-
-static int do_frequency_bending = 0;
-
-#define dprintk if (dvb_frontend_debug) printk
-
 #define MAX_EVENT 8
 
 struct dvb_fe_events {
 	struct dvb_frontend_event events[MAX_EVENT];
-	int                       eventw;
-	int                       eventr;
-	int                       overflow;
-	wait_queue_head_t         wait_queue;
-	struct semaphore          sem;
+	int			  eventw;
+	int			  eventr;
+	int			  overflow;
+	wait_queue_head_t	  wait_queue;
+	struct semaphore	  sem;
 };
 
 
@@ -95,6 +105,7 @@ struct dvb_frontend_data {
 	struct dvb_device *dvbdev;
 	struct dvb_frontend_parameters parameters;
 	struct dvb_fe_events events;
+	struct module *module;
 	struct semaphore sem;
 	struct list_head list_head;
 	wait_queue_head_t wait_queue;
@@ -112,7 +123,7 @@ struct dvb_frontend_data {
 	int step_size;
 	int exit;
 	int wakeup;
-        fe_status_t status;
+	fe_status_t status;
 };
 
 
@@ -142,7 +153,7 @@ static LIST_HEAD(frontend_notifier_list)
 static DECLARE_MUTEX(frontend_mutex);
 
 
-static int dvb_frontend_internal_ioctl (struct dvb_frontend *frontend, 
+static int dvb_frontend_internal_ioctl (struct dvb_frontend *frontend,
 				 unsigned int cmd, void *arg)
 {
 	int err = -EOPNOTSUPP;
@@ -167,14 +178,14 @@ static int dvb_frontend_internal_ioctl (
  *  if 2 tuners are located side by side you can get interferences when
  *  they try to tune to the same frequency, so both lose sync.
  *  We will slightly mistune in this case. The AFC of the demodulator
- *  should make it still possible to receive the requested transponder 
+ *  should make it still possible to receive the requested transponder
  *  on both tuners...
  */
 static void dvb_bend_frequency (struct dvb_frontend_data *this_fe, int recursive)
 {
 	struct list_head *entry;
 	int stepsize = this_fe->info->frequency_stepsize;
-	int this_fe_adap_num = this_fe->frontend.i2c->adapter->num;
+	int this_fe_adap_num = this_fe->frontend.dvb_adapter->num;
 	int frequency;
 
 	if (!stepsize || recursive > 10) {
@@ -198,7 +209,7 @@ static void dvb_bend_frequency (struct d
 
 		fe = list_entry (entry, struct dvb_frontend_data, list_head);
 
-		if (fe->frontend.i2c->adapter->num != this_fe_adap_num)
+		if (fe->frontend.dvb_adapter->num != this_fe_adap_num)
 			continue;
 
 		f = fe->parameters.frequency;
@@ -210,7 +221,7 @@ static void dvb_bend_frequency (struct d
 		frequency += this_fe->bending;
 
 		if (this_fe != fe && (fe->state != FESTATE_IDLE) &&
-                    frequency > f - stepsize && frequency < f + stepsize)
+		    frequency > f - stepsize && frequency < f + stepsize)
 		{
 			if (recursive % 2)
 				this_fe->bending += stepsize;
@@ -233,13 +244,10 @@ static void dvb_call_frontend_notifiers 
 	dprintk ("%s\n", __FUNCTION__);
 
 	if (((s ^ fe->status) & FE_HAS_LOCK) && (s & FE_HAS_LOCK))
-		dvb_delay (fe->info->notifier_delay);
+		msleep (fe->info->notifier_delay);
 
 	fe->status = s;
 
-	if (!(s & FE_HAS_LOCK) && (fe->info->caps & FE_CAN_MUTE_TS))
-		return;
-
 	/**
 	 *   now tell the Demux about the TS status changes...
 	 */
@@ -268,7 +276,7 @@ static void dvb_frontend_add_event (stru
 
 	e = &events->events[events->eventw];
 
-	memcpy (&e->parameters, &fe->parameters, 
+	memcpy (&e->parameters, &fe->parameters,
 		sizeof (struct dvb_frontend_parameters));
 
 	if (status & FE_HAS_LOCK)
@@ -289,52 +297,52 @@ static void dvb_frontend_add_event (stru
 static int dvb_frontend_get_event (struct dvb_frontend_data *fe,
 			    struct dvb_frontend_event *event, int flags)
 {
-        struct dvb_fe_events *events = &fe->events;
+	struct dvb_fe_events *events = &fe->events;
 
 	dprintk ("%s\n", __FUNCTION__);
 
 	if (events->overflow) {
-                events->overflow = 0;
-                return -EOVERFLOW;
-        }
+		events->overflow = 0;
+		return -EOVERFLOW;
+	}
 
-        if (events->eventw == events->eventr) {
+	if (events->eventw == events->eventr) {
 		int ret;
 
-                if (flags & O_NONBLOCK)
-                        return -EWOULDBLOCK;
+		if (flags & O_NONBLOCK)
+			return -EWOULDBLOCK;
 
 		up(&fe->sem);
 
-                ret = wait_event_interruptible (events->wait_queue,
-                                                events->eventw != events->eventr);
+		ret = wait_event_interruptible (events->wait_queue,
+						events->eventw != events->eventr);
 
-        	if (down_interruptible (&fe->sem))
+		if (down_interruptible (&fe->sem))
 			return -ERESTARTSYS;
 
-                if (ret < 0)
-                        return ret;
-        }
+		if (ret < 0)
+			return ret;
+	}
 
-        if (down_interruptible (&events->sem))
+	if (down_interruptible (&events->sem))
 		return -ERESTARTSYS;
 
-       	memcpy (event, &events->events[events->eventr],
+	memcpy (event, &events->events[events->eventr],
 		sizeof(struct dvb_frontend_event));
 
-        events->eventr = (events->eventr + 1) % MAX_EVENT;
+	events->eventr = (events->eventr + 1) % MAX_EVENT;
 
-       	up (&events->sem);
+	up (&events->sem);
 
-        return 0;
+	return 0;
 }
 
 static void dvb_frontend_init (struct dvb_frontend_data *fe)
 {
 	struct dvb_frontend *frontend = &fe->frontend;
 
-	dprintk ("DVB: initialising frontend %i:%i (%s)...\n",
-		 frontend->i2c->adapter->num, frontend->i2c->id,
+	dprintk ("DVB: initialising frontend %i (%s)...\n",
+		 frontend->dvb_adapter->num,
 		 fe->info->name);
 
 	dvb_frontend_internal_ioctl (frontend, FE_INIT, NULL);
@@ -342,24 +350,24 @@ static void dvb_frontend_init (struct dv
 
 static void update_delay (int *quality, int *delay, int min_delay, int locked)
 {
-	int q2;
+	    int q2;
 
-	dprintk ("%s\n", __FUNCTION__);
+	    dprintk ("%s\n", __FUNCTION__);
 
-	if (locked)
-		(*quality) = (*quality * 220 + 36*256) / 256;
-	else
-		(*quality) = (*quality * 220 + 0) / 256;
+	    if (locked)
+		      (*quality) = (*quality * 220 + 36*256) / 256;
+	    else
+		      (*quality) = (*quality * 220 + 0) / 256;
 
-	q2 = *quality - 128;
-	q2 *= q2;
+	    q2 = *quality - 128;
+	    q2 *= q2;
 
 	    *delay = min_delay + q2 * HZ / (128*128);
 }
 
 /**
  * Performs automatic twiddling of frontend parameters.
- * 
+ *
  * @param fe The frontend concerned.
  * @param check_wrapped Checks if an iteration has completed. DO NOT SET ON THE FIRST ATTEMPT
  * @returns Number of complete iterations that have been performed.
@@ -371,25 +379,26 @@ static int dvb_frontend_autotune(struct 
 	int original_inversion = fe->parameters.inversion;
 	u32 original_frequency = fe->parameters.frequency;
 
-	// are we using autoinversion?
-	autoinversion = ((!(fe->info->caps & FE_CAN_INVERSION_AUTO)) && (fe->parameters.inversion == INVERSION_AUTO));
+	/* are we using autoinversion? */
+	autoinversion = ((!(fe->info->caps & FE_CAN_INVERSION_AUTO)) &&
+			 (fe->parameters.inversion == INVERSION_AUTO));
 
-	// setup parameters correctly
+	/* setup parameters correctly */
 	while(!ready) {
-		// calculate the lnb_drift
+		/* calculate the lnb_drift */
 		fe->lnb_drift = fe->auto_step * fe->step_size;
 
-		// wrap the auto_step if we've exceeded the maximum drift
+		/* wrap the auto_step if we've exceeded the maximum drift */
 		if (fe->lnb_drift > fe->max_drift) {
 			fe->auto_step = 0;
 			fe->auto_sub_step = 0;
 			fe->lnb_drift = 0;
 		}
 
-		// perform inversion and +/- zigzag
+		/* perform inversion and +/- zigzag */
 		switch(fe->auto_sub_step) {
 		case 0:
-			// try with the current inversion and current drift setting
+			/* try with the current inversion and current drift setting */
 			ready = 1;
 			break;
 
@@ -402,51 +411,52 @@ static int dvb_frontend_autotune(struct 
 
 		case 2:
 			if (fe->lnb_drift == 0) break;
-		    
+
 			fe->lnb_drift = -fe->lnb_drift;
 			ready = 1;
 			break;
-	    
+
 		case 3:
 			if (fe->lnb_drift == 0) break;
 			if (!autoinversion) break;
-		    
+
 			fe->inversion = (fe->inversion == INVERSION_OFF) ? INVERSION_ON : INVERSION_OFF;
 			fe->lnb_drift = -fe->lnb_drift;
 			ready = 1;
 			break;
-		    
+
 		default:
 			fe->auto_step++;
-			fe->auto_sub_step = -1; // it'll be incremented to 0 in a moment
+			fe->auto_sub_step = -1; /* it'll be incremented to 0 in a moment */
 			break;
 		}
-	    
+
 		if (!ready) fe->auto_sub_step++;
 	}
 
-	// if this attempt would hit where we started, indicate a complete iteration has occurred
-	if ((fe->auto_step == fe->started_auto_step) && (fe->auto_sub_step == 0) && check_wrapped) {
+	/* if this attempt would hit where we started, indicate a complete
+	 * iteration has occurred */
+	if ((fe->auto_step == fe->started_auto_step) &&
+	    (fe->auto_sub_step == 0) && check_wrapped) {
 		return 1;
-		}
+	}
 
-	// perform frequency bending if necessary
+	/* perform frequency bending if necessary */
 	if ((dvb_override_frequency_bending != 1) && do_frequency_bending)
 		dvb_bend_frequency(fe, 0);
 
-	// instrumentation
-	dprintk("%s: drift:%i bending:%i inversion:%i auto_step:%i auto_sub_step:%i started_auto_step:%i\n", 
-		__FUNCTION__, fe->lnb_drift, fe->bending, fe->inversion, fe->auto_step, fe->auto_sub_step,
-		fe->started_auto_step);
-    
-	// set the frontend itself
+	dprintk("%s: drift:%i bending:%i inversion:%i auto_step:%i "
+		"auto_sub_step:%i started_auto_step:%i\n",
+		__FUNCTION__, fe->lnb_drift, fe->bending, fe->inversion,
+		fe->auto_step, fe->auto_sub_step, fe->started_auto_step);
+
+	/* set the frontend itself */
 	fe->parameters.frequency += fe->lnb_drift + fe->bending;
 	if (autoinversion) fe->parameters.inversion = fe->inversion;
 	dvb_frontend_internal_ioctl (&fe->frontend, FE_SET_FRONTEND, &fe->parameters);
 	fe->parameters.frequency = original_frequency;
 	fe->parameters.inversion = original_inversion;
 
-	// normal return
 	fe->auto_sub_step++;
 	return 0;
 }
@@ -490,17 +500,20 @@ static int dvb_frontend_thread (void *da
 
 	dprintk ("%s\n", __FUNCTION__);
 
-	snprintf (name, sizeof(name), "kdvb-fe-%i:%i",
-		  fe->frontend.i2c->adapter->num, fe->frontend.i2c->id);
+	snprintf (name, sizeof(name), "kdvb-fe-%i",
+		  fe->frontend.dvb_adapter->num);
 
-	dvb_kernel_thread_setup (name);
+        lock_kernel ();
+        daemonize (name);
+        sigfillset (&current->blocked);
+        unlock_kernel ();
 
 	dvb_call_frontend_notifiers (fe, 0);
 	dvb_frontend_init (fe);
 	fe->wakeup = 0;
 
 	while (1) {
-		up (&fe->sem);      /* is locked when we enter the thread... */
+		up (&fe->sem);	    /* is locked when we enter the thread... */
 
 		timeout = wait_event_interruptible_timeout(fe->wait_queue,0 != dvb_frontend_should_wakeup (fe), delay);
 		if (-ERESTARTSYS == timeout || 0 != dvb_frontend_is_exiting (fe)) {
@@ -511,65 +524,70 @@ static int dvb_frontend_thread (void *da
 		if (down_interruptible (&fe->sem))
 			break;
 
-		// if we've got no parameters, just keep idling
+		/* if we've got no parameters, just keep idling */
 		if (fe->state & FESTATE_IDLE) {
 			delay = 3*HZ;
 			quality = 0;
 			continue;
 		}
 
-		// get the frontend status
-		dvb_frontend_internal_ioctl (&fe->frontend, FE_READ_STATUS, &s);
-		if (s != fe->status)
-			dvb_frontend_add_event (fe, s);
-
-		// if we're not tuned, and we have a lock, move to the TUNED state
+		/* get the frontend status */
+		if (fe->state & FESTATE_RETUNE) {
+			s = 0;
+		} else {
+			dvb_frontend_internal_ioctl (&fe->frontend, FE_READ_STATUS, &s);
+			if (s != fe->status) {
+				dvb_frontend_add_event (fe, s);
+			}
+		}
+		/* if we're not tuned, and we have a lock, move to the TUNED state */
 		if ((fe->state & FESTATE_WAITFORLOCK) && (s & FE_HAS_LOCK)) {
 			update_delay(&quality, &delay, fe->min_delay, s & FE_HAS_LOCK);
 			fe->state = FESTATE_TUNED;
 
-			// if we're tuned, then we have determined the correct inversion
-			if ((!(fe->info->caps & FE_CAN_INVERSION_AUTO)) && (fe->parameters.inversion == INVERSION_AUTO)) {
+			/* if we're tuned, then we have determined the correct inversion */
+			if ((!(fe->info->caps & FE_CAN_INVERSION_AUTO)) &&
+			    (fe->parameters.inversion == INVERSION_AUTO)) {
 				fe->parameters.inversion = fe->inversion;
 			}
 			continue;
 		}
 
-		// if we are tuned already, check we're still locked
+		/* if we are tuned already, check we're still locked */
 		if (fe->state & FESTATE_TUNED) {
 			update_delay(&quality, &delay, fe->min_delay, s & FE_HAS_LOCK);
 
-			// we're tuned, and the lock is still good...
-		if (s & FE_HAS_LOCK) {
+			/* we're tuned, and the lock is still good... */
+			if (s & FE_HAS_LOCK)
 				continue;
-		} else {
-				// if we _WERE_ tuned, but now don't have a lock, need to zigzag
+			else {
+				/* if we _WERE_ tuned, but now don't have a lock,
+				 * need to zigzag */
 				fe->state = FESTATE_ZIGZAG_FAST;
 				fe->started_auto_step = fe->auto_step;
 				check_wrapped = 0;
-				// fallthrough
 			}
 		}
 
-		// don't actually do anything if we're in the LOSTLOCK state, the frontend is set to
-		// FE_CAN_RECOVER, and the max_drift is 0
-		if ((fe->state & FESTATE_LOSTLOCK) && 
+		/* don't actually do anything if we're in the LOSTLOCK state,
+		 * the frontend is set to FE_CAN_RECOVER, and the max_drift is 0 */
+		if ((fe->state & FESTATE_LOSTLOCK) &&
 		    (fe->info->caps & FE_CAN_RECOVER) && (fe->max_drift == 0)) {
 			update_delay(&quality, &delay, fe->min_delay, s & FE_HAS_LOCK);
-						continue;
-				}
-	    
-		// don't do anything if we're in the DISEQC state, since this might be someone
-		// with a motorized dish controlled by DISEQC. If its actually a re-tune, there will
-		// be a SET_FRONTEND soon enough.
+			continue;
+		}
+
+		/* don't do anything if we're in the DISEQC state, since this
+		 * might be someone with a motorized dish controlled by DISEQC.
+		 * If its actually a re-tune, there will be a SET_FRONTEND soon enough.	*/
 		if (fe->state & FESTATE_DISEQC) {
 			update_delay(&quality, &delay, fe->min_delay, s & FE_HAS_LOCK);
 			continue;
-				}
+		}
 
-		// if we're in the RETUNE state, set everything up for a brand new scan,
-		// keeping the current inversion setting, as the next tune is _very_ likely
-		// to require the same
+		/* if we're in the RETUNE state, set everything up for a brand
+		 * new scan, keeping the current inversion setting, as the next
+		 * tune is _very_ likely to require the same */
 		if (fe->state & FESTATE_RETUNE) {
 			fe->lnb_drift = 0;
 			fe->auto_step = 0;
@@ -578,43 +596,42 @@ static int dvb_frontend_thread (void *da
 			check_wrapped = 0;
 		}
 
-		// fast zigzag.
+		/* fast zigzag. */
 		if ((fe->state & FESTATE_SEARCHING_FAST) || (fe->state & FESTATE_RETUNE)) {
 			delay = fe->min_delay;
 
-			// peform a tune
+			/* peform a tune */
 			if (dvb_frontend_autotune(fe, check_wrapped)) {
-				// OK, if we've run out of trials at the fast speed. Drop back to
-				// slow for the _next_ attempt
+				/* OK, if we've run out of trials at the fast speed.
+				 * Drop back to slow for the _next_ attempt */
 				fe->state = FESTATE_SEARCHING_SLOW;
 				fe->started_auto_step = fe->auto_step;
 				continue;
 			}
 			check_wrapped = 1;
 
-			// if we've just retuned, enter the ZIGZAG_FAST state. This ensures
-			// we cannot return from an FE_SET_FRONTEND ioctl before the first frontend
-			// tune occurs
+			/* if we've just retuned, enter the ZIGZAG_FAST state.
+			 * This ensures we cannot return from an
+			 * FE_SET_FRONTEND ioctl before the first frontend tune
+			 * occurs */
 			if (fe->state & FESTATE_RETUNE) {
 				fe->state = FESTATE_TUNING_FAST;
 				wake_up_interruptible(&fe->wait_queue);
 			}
 		}
 
-		// slow zigzag
+		/* slow zigzag */
 		if (fe->state & FESTATE_SEARCHING_SLOW) {
 			update_delay(&quality, &delay, fe->min_delay, s & FE_HAS_LOCK);
-		    
-			// Note: don't bother checking for wrapping; we stay in this state 
-			// until we get a lock
+
+			/* Note: don't bother checking for wrapping; we stay in this
+			 * state until we get a lock */
 			dvb_frontend_autotune(fe, 0);
 		}
 	};
 
 	if (dvb_shutdown_timeout)
-		dvb_frontend_internal_ioctl (&fe->frontend, FE_SLEEP, NULL); 
-
-	up (&fe->sem);
+		dvb_frontend_internal_ioctl (&fe->frontend, FE_SLEEP, NULL);
 
 	fe->thread_pid = 0;
 	mb();
@@ -630,7 +647,7 @@ static void dvb_frontend_stop (struct dv
 
 	dprintk ("%s\n", __FUNCTION__);
 
-		fe->exit = 1;
+	fe->exit = 1;
 	mb();
 
 	if (!fe->thread_pid)
@@ -673,7 +690,7 @@ static int dvb_frontend_start (struct dv
 		if (!fe->exit)
 			return 0;
 		else
-		dvb_frontend_stop (fe);
+			dvb_frontend_stop (fe);
 	}
 
 	if (signal_pending(current))
@@ -687,6 +704,7 @@ static int dvb_frontend_start (struct dv
 	mb();
 
 	ret = kernel_thread (dvb_frontend_thread, fe, 0);
+
 	if (ret < 0) {
 		printk("dvb_frontend_start: failed to start kernel_thread (%d)\n", ret);
 		up(&fe->sem);
@@ -711,6 +729,11 @@ static int dvb_frontend_ioctl (struct in
 	if (!fe || !fe->frontend.ioctl || fe->exit)
 		return -ENODEV;
 
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY &&
+	    (_IOC_DIR(cmd) != _IOC_READ || cmd == FE_GET_EVENT ||
+	     cmd == FE_DISEQC_RECV_SLAVE_REPLY))
+		return -EPERM;
+
 	if (down_interruptible (&fe->sem))
 		return -ERESTARTSYS;
 
@@ -718,6 +741,7 @@ static int dvb_frontend_ioctl (struct in
 	case FE_DISEQC_SEND_MASTER_CMD:
 	case FE_DISEQC_SEND_BURST:
 	case FE_SET_TONE:
+	case FE_SET_VOLTAGE:
 		if (fe->status)
 			dvb_call_frontend_notifiers (fe, 0);
 		dvb_frontend_internal_ioctl (&fe->frontend, cmd, parg);
@@ -726,57 +750,70 @@ static int dvb_frontend_ioctl (struct in
 
 	case FE_SET_FRONTEND:
 		fe->state = FESTATE_RETUNE;
-	    
+
 		memcpy (&fe->parameters, parg,
 			sizeof (struct dvb_frontend_parameters));
 
 		memset(&fetunesettings, 0, sizeof(struct dvb_frontend_tune_settings));
 		memcpy(&fetunesettings.parameters, parg,
 		       sizeof (struct dvb_frontend_parameters));
-		    
-		// force auto frequency inversion if requested
+
+		/* force auto frequency inversion if requested */
 		if (dvb_force_auto_inversion) {
 			fe->parameters.inversion = INVERSION_AUTO;
 			fetunesettings.parameters.inversion = INVERSION_AUTO;
 		}
+		if (fe->info->type == FE_OFDM) {
+			/* without hierachical coding code_rate_LP is irrelevant,
+			 * so we tolerate the otherwise invalid FEC_NONE setting */
+			if (fe->parameters.u.ofdm.hierarchy_information == HIERARCHY_NONE &&
+			    fe->parameters.u.ofdm.code_rate_LP == FEC_NONE)
+				fe->parameters.u.ofdm.code_rate_LP = FEC_AUTO;
+		}
 
-		// get frontend-specific tuning settings
-		if (dvb_frontend_internal_ioctl(&fe->frontend, FE_GET_TUNE_SETTINGS, &fetunesettings) == 0) {
+		/* get frontend-specific tuning settings */
+		if (dvb_frontend_internal_ioctl(&fe->frontend, FE_GET_TUNE_SETTINGS,
+						&fetunesettings) == 0) {
 			fe->min_delay = (fetunesettings.min_delay_ms * HZ) / 1000;
 			fe->max_drift = fetunesettings.max_drift;
 			fe->step_size = fetunesettings.step_size;
 		} else {
-			// default values
+			/* default values */
 			switch(fe->info->type) {
 			case FE_QPSK:
-				fe->min_delay = HZ/20; // default mindelay of 50ms
+				fe->min_delay = HZ/20;
 				fe->step_size = fe->parameters.u.qpsk.symbol_rate / 16000;
 				fe->max_drift = fe->parameters.u.qpsk.symbol_rate / 2000;
-		break;
-			    
+				break;
+
 			case FE_QAM:
-				fe->min_delay = HZ/20; // default mindelay of 50ms
-				fe->step_size = 0;
-				fe->max_drift = 0; // don't want any zigzagging under DVB-C frontends
+				fe->min_delay = HZ/20;
+				fe->step_size = 0; /* no zigzag */
+				fe->max_drift = 0;
 				break;
-			    
+
 			case FE_OFDM:
-				fe->min_delay = HZ/20; // default mindelay of 50ms
+				fe->min_delay = HZ/20;
 				fe->step_size = fe->info->frequency_stepsize * 2;
 				fe->max_drift = (fe->info->frequency_stepsize * 2) + 1;
 				break;
+			case FE_ATSC:
+				printk("dvb-core: FE_ATSC not handled yet.\n");
+				break;
 			}
 		}
 		if (dvb_override_tune_delay > 0) {
 		       fe->min_delay = (dvb_override_tune_delay * HZ) / 1000;
 		}
 
-		dvb_frontend_add_event (fe, 0);	    
+		dvb_frontend_wakeup(fe);
+		dvb_frontend_add_event (fe, 0);
 		break;
 
 	case FE_GET_EVENT:
 		err = dvb_frontend_get_event (fe, parg, file->f_flags);
 		break;
+
 	case FE_GET_FRONTEND:
 		memcpy (parg, &fe->parameters,
 			sizeof (struct dvb_frontend_parameters));
@@ -789,20 +826,13 @@ static int dvb_frontend_ioctl (struct in
 	if (err < 0)
 		return err;
 
-	// Force the CAN_INVERSION_AUTO bit on. If the frontend doesn't do it, it is done for it.
+	/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn't
+	 * do it, it is done for it. */
 	if ((cmd == FE_GET_INFO) && (err == 0)) {
 		struct dvb_frontend_info* tmp = (struct dvb_frontend_info*) parg;
 		tmp->caps |= FE_CAN_INVERSION_AUTO;
 	}
 
-	// if the frontend has just been set, wait until the first tune has finished.
-	// This ensures the app doesn't start reading data too quickly, perhaps from the
-	// previous lock, which is REALLY CONFUSING TO DEBUG!
-	if ((cmd == FE_SET_FRONTEND) && (err == 0)) {
-		dvb_frontend_wakeup(fe);
-		err = wait_event_interruptible(fe->wait_queue, fe->state & ~FESTATE_RETUNE);
-	}
-
 	return err;
 }
 
@@ -842,7 +872,12 @@ static int dvb_frontend_open (struct ino
 		/*  empty event queue */
 		fe->events.eventr = fe->events.eventw = 0;
 	}
-	
+
+	if (!ret && fe->module) {
+		if (!try_module_get(fe->module))
+			return -EINVAL;
+	}
+
 	return ret;
 }
 
@@ -851,27 +886,33 @@ static int dvb_frontend_release (struct 
 {
 	struct dvb_device *dvbdev = file->private_data;
 	struct dvb_frontend_data *fe = dvbdev->priv;
+	int ret = 0;
 
 	dprintk ("%s\n", __FUNCTION__);
 
 	if ((file->f_flags & O_ACCMODE) != O_RDONLY)
 		fe->release_jiffies = jiffies;
 
-	return dvb_generic_release (inode, file);
+	ret = dvb_generic_release (inode, file);
+
+	if (!ret && fe->module)
+		module_put(fe->module);
+
+	return ret;
 }
 
 
 
 int
 dvb_add_frontend_ioctls (struct dvb_adapter *adapter,
-                         int (*before_ioctl) (struct dvb_frontend *frontend,
-                                              unsigned int cmd, void *arg),
-                         int (*after_ioctl)  (struct dvb_frontend *frontend,
-                                              unsigned int cmd, void *arg),
+			 int (*before_ioctl) (struct dvb_frontend *frontend,
+					      unsigned int cmd, void *arg),
+			 int (*after_ioctl)  (struct dvb_frontend *frontend,
+					      unsigned int cmd, void *arg),
 			 void *before_after_data)
 {
 	struct dvb_frontend_ioctl_data *ioctl;
-        struct list_head *entry;
+	struct list_head *entry;
 
 	dprintk ("%s\n", __FUNCTION__);
 
@@ -897,7 +938,7 @@ dvb_add_frontend_ioctls (struct dvb_adap
 
 		fe = list_entry (entry, struct dvb_frontend_data, list_head);
 
-		if (fe->frontend.i2c->adapter == adapter &&
+		if (fe->frontend.dvb_adapter == adapter &&
 		    fe->frontend.before_ioctl == NULL &&
 		    fe->frontend.after_ioctl == NULL)
 		{
@@ -916,9 +957,9 @@ dvb_add_frontend_ioctls (struct dvb_adap
 void
 dvb_remove_frontend_ioctls (struct dvb_adapter *adapter,
 			    int (*before_ioctl) (struct dvb_frontend *frontend,
-                                                 unsigned int cmd, void *arg),
-                            int (*after_ioctl)  (struct dvb_frontend *frontend,
-                                                 unsigned int cmd, void *arg))
+						 unsigned int cmd, void *arg),
+			    int (*after_ioctl)	(struct dvb_frontend *frontend,
+						 unsigned int cmd, void *arg))
 {
 	struct list_head *entry, *n;
 
@@ -931,7 +972,7 @@ dvb_remove_frontend_ioctls (struct dvb_a
 
 		fe = list_entry (entry, struct dvb_frontend_data, list_head);
 
-		if (fe->frontend.i2c->adapter == adapter &&
+		if (fe->frontend.dvb_adapter == adapter &&
 		    fe->frontend.before_ioctl == before_ioctl &&
 		    fe->frontend.after_ioctl == after_ioctl)
 		{
@@ -952,7 +993,7 @@ dvb_remove_frontend_ioctls (struct dvb_a
 		{
 			list_del (&ioctl->list_head);
 			kfree (ioctl);
-			
+
 			break;
 		}
 	}
@@ -992,7 +1033,7 @@ dvb_add_frontend_notifier (struct dvb_ad
 
 		fe = list_entry (entry, struct dvb_frontend_data, list_head);
 
-		if (fe->frontend.i2c->adapter == adapter &&
+		if (fe->frontend.dvb_adapter == adapter &&
 		    fe->frontend.notifier_callback == NULL)
 		{
 			fe->frontend.notifier_callback = callback;
@@ -1021,7 +1062,7 @@ dvb_remove_frontend_notifier (struct dvb
 
 		fe = list_entry (entry, struct dvb_frontend_data, list_head);
 
-		if (fe->frontend.i2c->adapter == adapter &&
+		if (fe->frontend.dvb_adapter == adapter &&
 		    fe->frontend.notifier_callback == callback)
 		{
 			fe->frontend.notifier_callback = NULL;
@@ -1039,7 +1080,7 @@ dvb_remove_frontend_notifier (struct dvb
 		{
 			list_del (&notifier->list_head);
 			kfree (notifier);
-			
+
 			break;
 		}
 	}
@@ -1056,14 +1097,13 @@ static struct file_operations dvb_fronte
 	.release	= dvb_frontend_release
 };
 
-
-
 int
 dvb_register_frontend (int (*ioctl) (struct dvb_frontend *frontend,
 				     unsigned int cmd, void *arg),
-		       struct dvb_i2c_bus *i2c,
+		       struct dvb_adapter *dvb_adapter,
 		       void *data,
-		       struct dvb_frontend_info *info)
+		       struct dvb_frontend_info *info,
+		       struct module *module)
 {
 	struct list_head *entry;
 	struct dvb_frontend_data *fe;
@@ -1093,9 +1133,10 @@ dvb_register_frontend (int (*ioctl) (str
 	init_MUTEX (&fe->events.sem);
 	fe->events.eventw = fe->events.eventr = 0;
 	fe->events.overflow = 0;
+	fe->module = module;
 
 	fe->frontend.ioctl = ioctl;
-	fe->frontend.i2c = i2c;
+	fe->frontend.dvb_adapter = dvb_adapter;
 	fe->frontend.data = data;
 	fe->info = info;
 	fe->inversion = INVERSION_OFF;
@@ -1107,7 +1148,7 @@ dvb_register_frontend (int (*ioctl) (str
 				    struct dvb_frontend_ioctl_data,
 				    list_head);
 
-		if (ioctl->adapter == i2c->adapter) {
+		if (ioctl->adapter == dvb_adapter) {
 			fe->frontend.before_ioctl = ioctl->before_ioctl;
 			fe->frontend.after_ioctl = ioctl->after_ioctl;
 			fe->frontend.before_after_data = ioctl->before_after_data;
@@ -1122,7 +1163,7 @@ dvb_register_frontend (int (*ioctl) (str
 				       struct dvb_frontend_notifier_data,
 				       list_head);
 
-		if (notifier->adapter == i2c->adapter) {
+		if (notifier->adapter == dvb_adapter) {
 			fe->frontend.notifier_callback = notifier->callback;
 			fe->frontend.notifier_data = notifier->data;
 			break;
@@ -1131,27 +1172,25 @@ dvb_register_frontend (int (*ioctl) (str
 
 	list_add_tail (&fe->list_head, &frontend_list);
 
-	printk ("DVB: registering frontend %i:%i (%s)...\n",
-		fe->frontend.i2c->adapter->num, fe->frontend.i2c->id,
+	printk ("DVB: registering frontend %i (%s)...\n",
+		fe->frontend.dvb_adapter->num,
 		fe->info->name);
 
-	dvb_register_device (i2c->adapter, &fe->dvbdev, &dvbdev_template,
+	dvb_register_device (dvb_adapter, &fe->dvbdev, &dvbdev_template,
 			     fe, DVB_DEVICE_FRONTEND);
 
 	if ((info->caps & FE_NEEDS_BENDING) || (dvb_override_frequency_bending == 2))
 		do_frequency_bending = 1;
-    
-	up (&frontend_mutex);
 
+	up (&frontend_mutex);
 	return 0;
 }
 
-
 int dvb_unregister_frontend (int (*ioctl) (struct dvb_frontend *frontend,
 					   unsigned int cmd, void *arg),
-			     struct dvb_i2c_bus *i2c)
+			     struct dvb_adapter *dvb_adapter)
 {
-        struct list_head *entry, *n;
+	struct list_head *entry, *n;
 
 	dprintk ("%s\n", __FUNCTION__);
 
@@ -1162,7 +1201,7 @@ int dvb_unregister_frontend (int (*ioctl
 
 		fe = list_entry (entry, struct dvb_frontend_data, list_head);
 
-		if (fe->frontend.ioctl == ioctl && fe->frontend.i2c == i2c) {
+		if (fe->frontend.ioctl == ioctl && fe->frontend.dvb_adapter == dvb_adapter) {
 			dvb_unregister_device (fe->dvbdev);
 			list_del (entry);
 			up (&frontend_mutex);
@@ -1176,14 +1215,3 @@ int dvb_unregister_frontend (int (*ioctl
 	return -EINVAL;
 }
 
-MODULE_PARM(dvb_frontend_debug,"i");
-MODULE_PARM(dvb_shutdown_timeout,"i");
-MODULE_PARM(dvb_override_frequency_bending,"i");
-MODULE_PARM(dvb_force_auto_inversion,"i");
-MODULE_PARM(dvb_override_tune_delay,"i");
-
-MODULE_PARM_DESC(dvb_frontend_debug, "enable verbose debug messages");
-MODULE_PARM_DESC(dvb_shutdown_timeout, "wait <shutdown_timeout> seconds after close() before suspending hardware");
-MODULE_PARM_DESC(dvb_override_frequency_bending, "0: normal (default), 1: never use frequency bending, 2: always use frequency bending");
-MODULE_PARM_DESC(dvb_force_auto_inversion, "0: normal (default), 1: INVERSION_AUTO forced always");
-MODULE_PARM_DESC(dvb_override_tune_delay, "0: normal (default), >0 => delay in milliseconds to wait for lock after a tune attempt");
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_frontend.h linux/drivers/media/dvb/dvb-core/dvb_frontend.h
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_frontend.h	2004-09-14 10:37:51.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_frontend.h	2004-09-17 14:56:38.756609110 +0200
@@ -1,9 +1,12 @@
 /* 
  * dvb_frontend.h
  *
- * Copyright (C) 2001 Ralph Metzler for convergence integrated media GmbH
- *                    overhauled by Holger Waechtler for Convergence GmbH
+ * Copyright (C) 2001 convergence integrated media GmbH
+ * Copyright (C) 2004 convergence GmbH
  *
+ * Written by Ralph Metzler
+ * Overhauled by Holger Waechtler
+ * Kernel I2C stuff by Michael Hunold <hunold@convergence.de>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public License
@@ -31,14 +34,31 @@
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/errno.h>
+#include <linux/delay.h>
 
 #include <linux/dvb/frontend.h>
 
-#include "dvb_i2c.h"
 #include "dvbdev.h"
 
-
-
+/* FIXME: Move to i2c-id.h */
+#define I2C_DRIVERID_DVBFE_ALPS_TDLB7	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_ALPS_TDMB7	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_AT76C651	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_CX24110	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_CX22702	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_DIB3000MB	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_DST		I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_DUMMY	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_L64781	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_MT312	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_MT352	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_NXT6000	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_SP887X	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_STV0299	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_TDA1004X	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_TDA8083	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_VES1820	I2C_DRIVERID_EXP2
+#define I2C_DRIVERID_DVBFE_VES1X93	I2C_DRIVERID_EXP2
 
 /**
  *   when before_ioctl is registered and returns value 0, ioctl and after_ioctl
@@ -50,7 +70,7 @@ struct dvb_frontend {
 	int (*ioctl) (struct dvb_frontend *frontend, unsigned int cmd, void *arg);
 	int (*after_ioctl) (struct dvb_frontend *frontend, unsigned int cmd, void *arg);
 	void (*notifier_callback) (fe_status_t s, void *data);
-	struct dvb_i2c_bus *i2c;
+	struct dvb_adapter *dvb_adapter;
 	void *before_after_data;   /*  can be used by hardware module... */
 	void *notifier_data;       /*  can be used by hardware module... */
 	void *data;                /*  can be used by hardware module... */
@@ -72,22 +92,24 @@ struct dvb_frontend_tune_settings {
  *   FE_INIT. Ioctl used to initialise the frontend.
  *   FE_GET_TUNE_SETTINGS. Get the frontend-specific tuning loop settings for the supplied set of parameters.
  */
-#define FE_SLEEP              _IO('v', 80)
-#define FE_INIT               _IO('v', 81)
+#define FE_SLEEP              _IO  ('v', 80)
+#define FE_INIT               _IO  ('v', 81)
 #define FE_GET_TUNE_SETTINGS  _IOWR('v', 83, struct dvb_frontend_tune_settings)
-
+#define FE_REGISTER	      _IO  ('v', 84)
+#define FE_UNREGISTER	      _IO  ('v', 85)
 
 extern int
 dvb_register_frontend (int (*ioctl) (struct dvb_frontend *frontend,
 				     unsigned int cmd, void *arg),
-		       struct dvb_i2c_bus *i2c,
+		       struct dvb_adapter *dvb_adapter,
 		       void *data,
-		       struct dvb_frontend_info *info);
+		       struct dvb_frontend_info *info,
+		       struct module *module);
 
 extern int
 dvb_unregister_frontend (int (*ioctl) (struct dvb_frontend *frontend,
 				       unsigned int cmd, void *arg),
-			 struct dvb_i2c_bus *i2c);
+			 struct dvb_adapter *dvb_adapter);
 
 
 /**
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ksyms.c linux/drivers/media/dvb/dvb-core/dvb_ksyms.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ksyms.c	2004-09-14 10:38:00.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_ksyms.c	2004-09-17 14:56:38.758608736 +0200
@@ -30,11 +30,6 @@ EXPORT_SYMBOL(dvb_remove_frontend_ioctls
 EXPORT_SYMBOL(dvb_add_frontend_notifier);
 EXPORT_SYMBOL(dvb_remove_frontend_notifier);
 
-EXPORT_SYMBOL(dvb_register_i2c_bus);
-EXPORT_SYMBOL(dvb_unregister_i2c_bus);
-EXPORT_SYMBOL(dvb_register_i2c_device);
-EXPORT_SYMBOL(dvb_unregister_i2c_device);
-
 EXPORT_SYMBOL(dvb_net_init);
 EXPORT_SYMBOL(dvb_net_release);
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_net.c linux/drivers/media/dvb/dvb-core/dvb_net.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_net.c	2004-09-14 10:34:50.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_net.c	2004-09-17 14:56:38.763607799 +0200
@@ -1,4 +1,4 @@
-/* 
+/*
  * dvb_net.c
  *
  * Copyright (C) 2001 Convergence integrated media GmbH
@@ -18,12 +18,12 @@
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@@ -40,10 +40,9 @@
 
 #include "dvb_demux.h"
 #include "dvb_net.h"
-#include "dvb_functions.h"
 
 
-static inline __u32 iov_crc32( __u32 c, struct kvec *iov, unsigned int cnt )
+static inline __u32 iov_crc32( __u32 c, struct iovec *iov, unsigned int cnt )
 {
 	unsigned int j;
 	for (j = 0; j < cnt; j++)
@@ -127,7 +126,7 @@ struct dvb_net_priv {
 
 
 /**
- *	Determine the packet's protocol ID. The rule here is that we 
+ *	Determine the packet's protocol ID. The rule here is that we
  *	assume 802.3 if the type field is short enough to be a length.
  *	This is normal practice and works for any 'now in use' protocol.
  *
@@ -139,23 +138,23 @@ static unsigned short dvb_net_eth_type_t
 {
 	struct ethhdr *eth;
 	unsigned char *rawp;
-	
+
 	skb->mac.raw=skb->data;
 	skb_pull(skb,dev->hard_header_len);
 	eth= skb->mac.ethernet;
-	
+
 	if (*eth->h_dest & 1) {
 		if(memcmp(eth->h_dest,dev->broadcast, ETH_ALEN)==0)
 			skb->pkt_type=PACKET_BROADCAST;
 		else
 			skb->pkt_type=PACKET_MULTICAST;
 	}
-	
+
 	if (ntohs(eth->h_proto) >= 1536)
 		return eth->h_proto;
-		
+
 	rawp = skb->data;
-	
+
 	/**
 	 *	This is a magic hack to spot IPX packets. Older Novell breaks
 	 *	the protocol design and runs IPX over 802.3 without an 802.2 LLC
@@ -164,7 +163,7 @@ static unsigned short dvb_net_eth_type_t
 	 */
 	if (*(unsigned short *)rawp == 0xFFFF)
 		return htons(ETH_P_802_3);
-		
+
 	/**
 	 *	Real 802.2 LLC
 	 */
@@ -481,7 +480,7 @@ static void dvb_net_ule( struct net_devi
 			/* Check CRC32, we've got it in our skb already. */
 			unsigned short ulen = htons(priv->ule_sndu_len);
 			unsigned short utype = htons(priv->ule_sndu_type);
-			struct kvec iov[4] = {
+			struct iovec iov[4] = {
 				{ &ulen, sizeof ulen },
 				{ &utype, sizeof utype },
 				{ NULL, 0 },
@@ -563,7 +562,7 @@ static int dvb_net_ts_callback(const u8 
 	if (buffer2 != 0)
 		printk(KERN_WARNING "buffer2 not 0: %p.\n", buffer2);
 	if (buffer1_len > 32768)
-		printk(KERN_WARNING "length > 32k: %zu.\n", buffer1_len);
+		printk(KERN_WARNING "length > 32k: %u.\n", buffer1_len);
 	/* printk("TS callback: %u bytes, %u TS cells @ %p.\n",
 	          buffer1_len, buffer1_len / TS_SZ, buffer1); */
 	dvb_net_ule(dev, buffer1, buffer1_len);
@@ -639,12 +638,12 @@ static void dvb_net_sec(struct net_devic
 	eth[13] = 0x00;
 
 	skb->protocol = dvb_net_eth_type_trans(skb, dev);
-        
+
 	stats->rx_packets++;
 	stats->rx_bytes+=skb->len;
         netif_rx(skb);
 }
- 
+
 static int dvb_net_sec_callback(const u8 *buffer1, size_t buffer1_len,
 		 const u8 *buffer2, size_t buffer2_len,
 		 struct dmx_section_filter *filter,
@@ -721,7 +720,7 @@ static int dvb_net_feed_start(struct net
 	struct dvb_net_priv *priv = (struct dvb_net_priv*) dev->priv;
         struct dmx_demux *demux = priv->demux;
         unsigned char *mac = (unsigned char *) dev->dev_addr;
-		
+
 	dprintk("%s: rx_mode %i\n", __FUNCTION__, priv->rx_mode);
 	if (priv->secfeed || priv->secfilter || priv->multi_secfilter[0])
 		printk("%s: BUG %d\n", __FUNCTION__, __LINE__);
@@ -731,51 +730,51 @@ static int dvb_net_feed_start(struct net
 	priv->tsfeed = NULL;
 
 	if (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {
-	dprintk("%s: alloc secfeed\n", __FUNCTION__);
-	ret=demux->allocate_section_feed(demux, &priv->secfeed, 
+		dprintk("%s: alloc secfeed\n", __FUNCTION__);
+		ret=demux->allocate_section_feed(demux, &priv->secfeed,
 					 dvb_net_sec_callback);
-	if (ret<0) {
-		printk("%s: could not allocate section feed\n", dev->name);
-		return ret;
-	}
+		if (ret<0) {
+			printk("%s: could not allocate section feed\n", dev->name);
+			return ret;
+		}
 
-	ret = priv->secfeed->set(priv->secfeed, priv->pid, 32768, 0, 1);
+		ret = priv->secfeed->set(priv->secfeed, priv->pid, 32768, 0, 1);
 
-	if (ret<0) {
-		printk("%s: could not set section feed\n", dev->name);
-		priv->demux->release_section_feed(priv->demux, priv->secfeed);
-		priv->secfeed=NULL;
-		return ret;
-	}
+		if (ret<0) {
+			printk("%s: could not set section feed\n", dev->name);
+			priv->demux->release_section_feed(priv->demux, priv->secfeed);
+			priv->secfeed=NULL;
+			return ret;
+		}
 
-	if (priv->rx_mode != RX_MODE_PROMISC) {
-		dprintk("%s: set secfilter\n", __FUNCTION__);
+		if (priv->rx_mode != RX_MODE_PROMISC) {
+			dprintk("%s: set secfilter\n", __FUNCTION__);
 			dvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_normal);
-	}
+		}
 
-	switch (priv->rx_mode) {
-	case RX_MODE_MULTI:
-		for (i = 0; i < priv->multi_num; i++) {
-			dprintk("%s: set multi_secfilter[%d]\n", __FUNCTION__, i);
+		switch (priv->rx_mode) {
+		case RX_MODE_MULTI:
+			for (i = 0; i < priv->multi_num; i++) {
+				dprintk("%s: set multi_secfilter[%d]\n", __FUNCTION__, i);
 				dvb_net_filter_sec_set(dev, &priv->multi_secfilter[i],
-					   priv->multi_macs[i], mask_normal);
-		}
-		break;
-	case RX_MODE_ALL_MULTI:
-		priv->multi_num=1;
-		dprintk("%s: set multi_secfilter[0]\n", __FUNCTION__);
+						       priv->multi_macs[i], mask_normal);
+			}
+			break;
+		case RX_MODE_ALL_MULTI:
+			priv->multi_num=1;
+			dprintk("%s: set multi_secfilter[0]\n", __FUNCTION__);
 			dvb_net_filter_sec_set(dev, &priv->multi_secfilter[0],
-				   mac_allmulti, mask_allmulti);
-		break;
-	case RX_MODE_PROMISC:
-		priv->multi_num=0;
-		dprintk("%s: set secfilter\n", __FUNCTION__);
+					       mac_allmulti, mask_allmulti);
+			break;
+		case RX_MODE_PROMISC:
+			priv->multi_num=0;
+			dprintk("%s: set secfilter\n", __FUNCTION__);
 			dvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_promisc);
-		break;
-	}
-	
-	dprintk("%s: start filtering\n", __FUNCTION__);
-	priv->secfeed->start_filtering(priv->secfeed);
+			break;
+		}
+
+		dprintk("%s: start filtering\n", __FUNCTION__);
+		priv->secfeed->start_filtering(priv->secfeed);
 	} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {
 		struct timespec timeout = { 0, 30000000 }; // 30 msec
 
@@ -818,33 +817,33 @@ static int dvb_net_feed_stop(struct net_
 
 	dprintk("%s\n", __FUNCTION__);
 	if (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {
-        if (priv->secfeed) {
-		if (priv->secfeed->is_filtering) {
-			dprintk("%s: stop secfeed\n", __FUNCTION__);
-		        priv->secfeed->stop_filtering(priv->secfeed);
-		}
+		if (priv->secfeed) {
+			if (priv->secfeed->is_filtering) {
+				dprintk("%s: stop secfeed\n", __FUNCTION__);
+				priv->secfeed->stop_filtering(priv->secfeed);
+			}
 
-		if (priv->secfilter) {
-			dprintk("%s: release secfilter\n", __FUNCTION__);
-			priv->secfeed->release_filter(priv->secfeed,
-					       priv->secfilter);
-		priv->secfilter=NULL;
-		}
+			if (priv->secfilter) {
+				dprintk("%s: release secfilter\n", __FUNCTION__);
+				priv->secfeed->release_filter(priv->secfeed,
+							      priv->secfilter);
+				priv->secfilter=NULL;
+			}
 
-		for (i=0; i<priv->multi_num; i++) {
-			if (priv->multi_secfilter[i]) {
+			for (i=0; i<priv->multi_num; i++) {
+				if (priv->multi_secfilter[i]) {
 					dprintk("%s: release multi_filter[%d]\n",
 						__FUNCTION__, i);
-				priv->secfeed->release_filter(priv->secfeed,
-						       priv->multi_secfilter[i]);
-			priv->multi_secfilter[i]=NULL;
-		}
-		}
+					priv->secfeed->release_filter(priv->secfeed,
+								      priv->multi_secfilter[i]);
+					priv->multi_secfilter[i] = NULL;
+				}
+			}
 
-		priv->demux->release_section_feed(priv->demux, priv->secfeed);
-		priv->secfeed=NULL;
-	} else
-		printk("%s: no feed to stop\n", dev->name);
+			priv->demux->release_section_feed(priv->demux, priv->secfeed);
+			priv->secfeed = NULL;
+		} else
+			printk("%s: no feed to stop\n", dev->name);
 	} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {
 		if (priv->tsfeed) {
 			if (priv->tsfeed->is_filtering) {
@@ -884,8 +883,8 @@ static void wq_set_multicast_list (void 
 	dvb_net_feed_stop(dev);
 
 	priv->rx_mode = RX_MODE_UNI;
-	
-	if(dev->flags & IFF_PROMISC) {
+
+	if (dev->flags & IFF_PROMISC) {
 		dprintk("%s: promiscuous mode\n", dev->name);
 		priv->rx_mode = RX_MODE_PROMISC;
 	} else if ((dev->flags & IFF_ALLMULTI)) {
@@ -901,15 +900,15 @@ static void wq_set_multicast_list (void 
 		priv->rx_mode = RX_MODE_MULTI;
 		priv->multi_num = 0;
 
-		for (mci = 0, mc=dev->mc_list; 
+		for (mci = 0, mc=dev->mc_list;
 		     mci < dev->mc_count;
 		     mc = mc->next, mci++) {
 			dvb_set_mc_filter(dev, mc);
 		}
 	}
 
-		dvb_net_feed_start(dev);
-	}
+	dvb_net_feed_start(dev);
+}
 
 
 static void dvb_net_set_multicast_list (struct net_device *dev)
@@ -975,7 +974,6 @@ static struct net_device_stats * dvb_net
         return &((struct dvb_net_priv*) dev->priv)->stats;
 }
 
-
 static void dvb_net_setup(struct net_device *dev)
 {
 	ether_setup(dev);
@@ -990,7 +988,6 @@ static void dvb_net_setup(struct net_dev
 	dev->mtu		= 4096;
 	dev->mc_count           = 0;
 	dev->hard_header_cache  = NULL;
-
 	dev->flags |= IFF_NOARP;
 }
 
@@ -1015,7 +1012,7 @@ static int dvb_net_add_if(struct dvb_net
 	struct dvb_net_priv *priv;
 	int result;
 	int if_num;
- 
+
 	if (feedtype != DVB_NET_FEEDTYPE_MPE && feedtype != DVB_NET_FEEDTYPE_ULE)
 		return -EINVAL;
 	if ((if_num = get_if(dvbnet)) < 0)
@@ -1025,14 +1022,14 @@ static int dvb_net_add_if(struct dvb_net
 			   dvb_net_setup);
 	if (!net)
 		return -ENOMEM;
-	
+
 	sprintf(net->name, "dvb%d_%d", dvbnet->dvbdev->adapter->num, if_num);
 
-	net->addr_len  		= 6;
+	net->addr_len		= 6;
 	memcpy(net->dev_addr, dvbnet->dvbdev->adapter->proposed_mac, 6);
 
 	dvbnet->device[if_num] = net;
-	
+
 	priv = net->priv;
         priv->demux = dvbnet->demux;
         priv->pid = pid;
@@ -1046,7 +1043,7 @@ static int dvb_net_add_if(struct dvb_net
 	INIT_WORK(&priv->restart_net_feed_wq, wq_restart_net_feed, net);
 
         net->base_addr = pid;
-                
+
 	if ((result = register_netdev(net)) < 0) {
 		dvbnet->device[if_num] = NULL;
 		free_netdev(net);
@@ -1056,7 +1053,6 @@ static int dvb_net_add_if(struct dvb_net
         return if_num;
 }
 
-
 static int dvb_net_remove_if(struct dvb_net *dvbnet, int num)
 {
 	struct net_device *net = dvbnet->device[num];
@@ -1077,7 +1073,6 @@ static int dvb_net_remove_if(struct dvb_
 	return 0;
 }
 
-
 static int dvb_net_do_ioctl(struct inode *inode, struct file *file,
 		  unsigned int cmd, void *parg)
 {
@@ -1086,16 +1081,16 @@ static int dvb_net_do_ioctl(struct inode
 
 	if (((file->f_flags&O_ACCMODE)==O_RDONLY))
 		return -EPERM;
-	
+
 	switch (cmd) {
 	case NET_ADD_IF:
 	{
 		struct dvb_net_if *dvbnetif=(struct dvb_net_if *)parg;
 		int result;
-		
+
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
-
+			
 		if (!try_module_get(dvbdev->adapter->module))
 			return -EPERM;
 
@@ -1118,6 +1113,7 @@ static int dvb_net_do_ioctl(struct inode
 			return -EINVAL;
 
 		netdev = dvbnet->device[dvbnetif->if_num];
+
 		priv_data=(struct dvb_net_priv*)netdev->priv;
 		dvbnetif->pid=priv_data->pid;
 		dvbnetif->feedtype=priv_data->feedtype;
@@ -1157,9 +1153,10 @@ static int dvb_net_do_ioctl(struct inode
 
 		if (dvbnetif->if_num >= DVB_NET_DEVICES_MAX ||
 		    !dvbnet->state[dvbnetif->if_num])
-		return -EINVAL;
+			return -EINVAL;
 
 		netdev = dvbnet->device[dvbnetif->if_num];
+
 		priv_data=(struct dvb_net_priv*)netdev->priv;
 		dvbnetif->pid=priv_data->pid;
 		break;
@@ -1209,7 +1206,7 @@ int dvb_net_init (struct dvb_adapter *ad
 		  struct dmx_demux *dmx)
 {
 	int i;
-		
+
 	dvbnet->demux = dmx;
 
 	for (i=0; i<DVB_NET_DEVICES_MAX; i++)
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ringbuffer.c linux/drivers/media/dvb/dvb-core/dvb_ringbuffer.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ringbuffer.c	2004-09-14 10:36:41.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_ringbuffer.c	2004-09-17 14:56:38.765607424 +0200
@@ -2,9 +2,9 @@
  *
  * dvb_ringbuffer.c: ring buffer implementation for the dvb driver
  *
- * Copyright (C) 2003 Oliver Endriss 
+ * Copyright (C) 2003 Oliver Endriss
  * Copyright (C) 2004 Andrew de Quincey
- * 
+ *
  * based on code originally found in av7110.c & dvb_ci.c:
  * Copyright (C) 1999-2003 Ralph  Metzler
  *                       & Marcus Metzler for convergence integrated media GmbH
@@ -13,7 +13,7 @@
  * modify it under the terms of the GNU Lesser General Public License
  * as published by the Free Software Foundation; either version 2.1
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@@ -63,7 +63,7 @@ int dvb_ringbuffer_empty(struct dvb_ring
 ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)
 {
         ssize_t free;
-  
+
         free = rbuf->pread - rbuf->pwrite;
         if (free <= 0)
                 free += rbuf->size;
@@ -75,7 +75,7 @@ ssize_t dvb_ringbuffer_free(struct dvb_r
 ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)
 {
         ssize_t avail;
-  
+
         avail = rbuf->pwrite - rbuf->pread;
         if (avail < 0)
                 avail += rbuf->size;
@@ -137,19 +137,19 @@ ssize_t dvb_ringbuffer_write(struct dvb_
 {
         size_t todo = len;
         size_t split;
-    
+
         split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
 
         if (split > 0) {
-		memcpy(rbuf->data+rbuf->pwrite, buf, split);
+                memcpy(rbuf->data+rbuf->pwrite, buf, split);
                 buf += split;
                 todo -= split;
                 rbuf->pwrite = 0;
         }
-	memcpy(rbuf->data+rbuf->pwrite, buf, todo);
+        memcpy(rbuf->data+rbuf->pwrite, buf, todo);
         rbuf->pwrite = (rbuf->pwrite + todo) % rbuf->size;
 
-	return len;
+        return len;
 }
 
 ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf, size_t len)
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ringbuffer.h linux/drivers/media/dvb/dvb-core/dvb_ringbuffer.h
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvb_ringbuffer.h	2004-09-14 10:38:08.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_ringbuffer.h	2004-09-17 14:56:38.768606862 +0200
@@ -2,9 +2,9 @@
  *
  * dvb_ringbuffer.h: ring buffer implementation for the dvb driver
  *
- * Copyright (C) 2003 Oliver Endriss 
+ * Copyright (C) 2003 Oliver Endriss
  * Copyright (C) 2004 Andrew de Quincey
- * 
+ *
  * based on code originally found in av7110.c & dvb_ci.c:
  * Copyright (C) 1999-2003 Ralph Metzler & Marcus Metzler
  *                         for convergence integrated media GmbH
@@ -13,12 +13,12 @@
  * modify it under the terms of the GNU Lesser General Public License
  * as published by the Free Software Foundation; either version 2.1
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@@ -52,7 +52,7 @@ struct dvb_ringbuffer {
 **
 **     *** write <buflen> bytes ***
 **     free = dvb_ringbuffer_free(rbuf);
-**     if (free >= buflen) 
+**     if (free >= buflen)
 **         count = dvb_ringbuffer_write(rbuf, buffer, buflen);
 **     else
 **         ...
@@ -64,7 +64,7 @@ struct dvb_ringbuffer {
 **     else
 **         ...
 **
-** (2) If there is exactly one reader and one writer, there is no need 
+** (2) If there is exactly one reader and one writer, there is no need
 **     to lock read or write operations.
 **     Two or more readers must be locked against each other.
 **     Flushing the buffer counts as a read operation.
@@ -99,13 +99,13 @@ extern void dvb_ringbuffer_flush_spinloc
 /* advance read ptr by <num> bytes */
 #define DVB_RINGBUFFER_SKIP(rbuf,num)	\
 			(rbuf)->pread=((rbuf)->pread+(num))%(rbuf)->size
- 
+
 /*
-** read <len> bytes from ring buffer into <buf> 
+** read <len> bytes from ring buffer into <buf>
 ** <usermem> specifies whether <buf> resides in user space
 ** returns number of bytes transferred or -EFAULT
 */
-extern ssize_t dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, 
+extern ssize_t dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf,
                                    size_t len, int usermem);
 
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvbdev.c linux/drivers/media/dvb/dvb-core/dvbdev.c
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvbdev.c	2004-09-14 10:34:52.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvbdev.c	2004-09-17 14:56:38.770606488 +0200
@@ -25,30 +25,36 @@
 #include <linux/errno.h>
 #include <linux/string.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/device.h>
 
 #include "dvbdev.h"
-#include "dvb_functions.h"
 
-static int dvbdev_debug = 0;
+static int dvbdev_debug;
+
+module_param(dvbdev_debug, int, 0644);
+MODULE_PARM_DESC(dvbdev_debug, "Turn on/off device debugging (default:off).");
+
 #define dprintk if (dvbdev_debug) printk
 
 static LIST_HEAD(dvb_adapter_list);
 static DECLARE_MUTEX(dvbdev_register_lock);
 
-
-static char *dnames[] = { 
+static const char * const dnames[] = {
         "video", "audio", "sec", "frontend", "demux", "dvr", "ca",
 	"net", "osd"
 };
 
-
 #define DVB_MAX_IDS              4
 #define nums2minor(num,type,id)  ((num << 6) | (id << 4) | type)
 
+struct class_simple *dvb_class;
+EXPORT_SYMBOL(dvb_class);
+
 static struct dvb_device* dvbdev_find_device (int minor)
 {
 	struct list_head *entry;
@@ -101,7 +107,6 @@ static struct file_operations dvb_device
 	.open =		dvb_device_open,
 };
 
-
 int dvb_generic_open(struct inode *inode, struct file *file)
 {
         struct dvb_device *dvbdev = file->private_data;
@@ -139,7 +144,7 @@ int dvb_generic_release(struct inode *in
 	} else {
 		dvbdev->writers++;
 	}
-
+	
 	dvbdev->users++;
 	return 0;
 }
@@ -216,12 +221,15 @@ int dvb_register_device(struct dvb_adapt
 	list_add_tail (&dvbdev->list_head, &adap->device_list);
 
 	devfs_mk_cdev(MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
-			S_IFCHR | S_IRUSR | S_IWUSR,
+ 			S_IFCHR | S_IRUSR | S_IWUSR,
 			"dvb/adapter%d/%s%d", adap->num, dnames[type], id);
 
+	class_simple_device_add(dvb_class, MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
+				NULL, "dvb%d.%s%d", adap->num, dnames[type], id);
+
 	dprintk("DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
 		adap->num, dnames[type], id, nums2minor(adap->num, type, id),
-		nums2minor(adap->num, type, id));
+ 		nums2minor(adap->num, type, id));
 
 	return 0;
 }
@@ -232,12 +240,15 @@ void dvb_unregister_device(struct dvb_de
 	if (!dvbdev)
 		return;
 
-		devfs_remove("dvb/adapter%d/%s%d", dvbdev->adapter->num,
-				dnames[dvbdev->type], dvbdev->id);
+	devfs_remove("dvb/adapter%d/%s%d", dvbdev->adapter->num,
+			dnames[dvbdev->type], dvbdev->id);
 
-		list_del(&dvbdev->list_head);
-		kfree(dvbdev);
-	}
+	class_simple_device_remove(MKDEV(DVB_MAJOR, nums2minor(dvbdev->adapter->num,
+					dvbdev->type, dvbdev->id)));
+
+	list_del (&dvbdev->list_head);
+	kfree (dvbdev);
+}
 
 
 static int dvbdev_get_free_adapter_num (void)
@@ -285,7 +296,6 @@ int dvb_register_adapter(struct dvb_adap
 	printk ("DVB: registering new adapter (%s).\n", name);
 	
 	devfs_mk_dir("dvb/adapter%d", num);
-
 	adap->num = num;
 	adap->name = name;
 	adap->module = module;
@@ -300,24 +310,95 @@ int dvb_register_adapter(struct dvb_adap
 
 int dvb_unregister_adapter(struct dvb_adapter *adap)
 {
+	devfs_remove("dvb/adapter%d", adap->num);
+
 	if (down_interruptible (&dvbdev_register_lock))
 		return -ERESTARTSYS;
-        devfs_remove("dvb/adapter%d", adap->num);
 	list_del (&adap->list_head);
 	up (&dvbdev_register_lock);
 	kfree (adap);
 	return 0;
 }
 
+/* if the miracle happens and "generic_usercopy()" is included into
+   the kernel, then this can vanish. please don't make the mistake and
+   define this as video_usercopy(). this will introduce a dependecy
+   to the v4l "videodev.o" module, which is unnecessary for some
+   cards (ie. the budget dvb-cards don't need the v4l module...) */
+int dvb_usercopy(struct inode *inode, struct file *file,
+	             unsigned int cmd, unsigned long arg,
+		     int (*func)(struct inode *inode, struct file *file,
+		     unsigned int cmd, void *arg))
+{
+        char    sbuf[128];
+        void    *mbuf = NULL;
+        void    *parg = NULL;
+        int     err  = -EINVAL;
+
+        /*  Copy arguments into temp kernel buffer  */
+        switch (_IOC_DIR(cmd)) {
+        case _IOC_NONE:
+		/*
+		 * For this command, the pointer is actually an integer
+		 * argument.
+		 */
+		parg = (void *) arg;
+		break;
+        case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+        case _IOC_WRITE:
+        case (_IOC_WRITE | _IOC_READ):
+                if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+                        parg = sbuf;
+                } else {
+                        /* too big to allocate from stack */
+                        mbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);
+                        if (NULL == mbuf)
+                                return -ENOMEM;
+                        parg = mbuf;
+                }
+
+                err = -EFAULT;
+                if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+                        goto out;
+                break;
+        }
+
+        /* call driver */
+        if ((err = func(inode, file, cmd, parg)) == -ENOIOCTLCMD)
+                err = -EINVAL;
+
+        if (err < 0)
+                goto out;
+
+        /*  Copy results into user buffer  */
+        switch (_IOC_DIR(cmd))
+        {
+        case _IOC_READ:
+        case (_IOC_WRITE | _IOC_READ):
+                if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+                        err = -EFAULT;
+                break;
+        }
+
+out:
+        if (mbuf)
+                kfree(mbuf);
+
+        return err;
+}
 
 static int __init init_dvbdev(void)
 {
 	int retval;
+
+	if ((retval = register_chrdev(DVB_MAJOR,"DVB", &dvb_device_fops)))
+		printk("dvb-core: unable to get major %d\n", DVB_MAJOR);
+
 	devfs_mk_dir("dvb");
 
-	retval = register_chrdev(DVB_MAJOR,"DVB", &dvb_device_fops);
-	if (retval)
-		printk("video_dev: unable to get major %d\n", DVB_MAJOR);
+	dvb_class = class_simple_create(THIS_MODULE, "dvb");
+	if (IS_ERR(dvb_class))
+		return PTR_ERR(dvb_class);
 
 	return retval;
 }
@@ -327,6 +408,7 @@ static void __exit exit_dvbdev(void)
 {
 	unregister_chrdev(DVB_MAJOR, "DVB");
         devfs_remove("dvb");
+	class_simple_destroy(dvb_class);
 }
 
 module_init(init_dvbdev);
@@ -336,6 +418,3 @@ MODULE_DESCRIPTION("DVB Core Driver");
 MODULE_AUTHOR("Marcus Metzler, Ralph Metzler, Holger Waechtler");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(dvbdev_debug,"i");
-MODULE_PARM_DESC(dvbdev_debug, "enable verbose debug messages");
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvbdev.h linux/drivers/media/dvb/dvb-core/dvbdev.h
--- linux-2.6.9-rc2/drivers/media/dvb/dvb-core/dvbdev.h	2004-09-14 10:35:03.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvbdev.h	2004-09-17 14:56:38.773605926 +0200
@@ -28,6 +28,7 @@
 #include <linux/fs.h>
 #include <linux/list.h>
 #include <linux/devfs_fs_kernel.h>
+#include <linux/smp_lock.h>
 
 #define DVB_MAJOR 212
 
@@ -56,9 +57,6 @@ struct dvb_adapter {
 struct dvb_device {
 	struct list_head list_head;
 	struct file_operations *fops;
- 
- 
- 
 	struct dvb_adapter *adapter;
 	int type;
 	u32 id;
@@ -92,5 +90,15 @@ extern int dvb_generic_open (struct inod
 extern int dvb_generic_release (struct inode *inode, struct file *file);
 extern int dvb_generic_ioctl (struct inode *inode, struct file *file,
 			      unsigned int cmd, unsigned long arg);
+
+/* we don't mess with video_usercopy() any more,
+we simply define out own dvb_usercopy(), which will hopefully become
+generic_usercopy()  someday... */
+
+extern int dvb_usercopy(struct inode *inode, struct file *file,
+	                    unsigned int cmd, unsigned long arg,
+			    int (*func)(struct inode *inode, struct file *file,
+			    unsigned int cmd, void *arg));
+			      
 #endif /* #ifndef _DVBDEV_H_ */
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/Kconfig linux/drivers/media/dvb/frontends/Kconfig
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/Kconfig	2004-09-14 10:34:48.000000000 +0200
+++ linux/drivers/media/dvb/frontends/Kconfig	2004-09-17 14:56:38.775605551 +0200
@@ -1,76 +1,92 @@
-comment "Supported Frontend Modules"
-	depends on DVB
-
-config DVB_TWINHAN_DST
-	tristate "TWINHAN DST based DVB-S frontend (QPSK)"
-	depends on DVB_CORE && DVB_BT8XX
-	help
-	  Used in such cards as the VP-1020/1030, Twinhan DST,
-	  VVmer TV@SAT. Say Y when you want to support frontends 
-	  using this asic.
-
-	  This module requires the dvb-bt8xx driver and dvb bt878
-	  module.
+comment "DVB-S (satellite) frontends"
+	depends on DVB_CORE
 
 config DVB_STV0299
-	tristate "STV0299 based DVB-S frontend (QPSK)"
+	tristate "ST STV0299 based"
 	depends on DVB_CORE
 	help
-	  The stv0299 by ST is used in many DVB-S tuner modules, 
-	  say Y when you want to support frontends based on this 
-	  DVB-S demodulator.
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
 
 	  Some examples are the Alps BSRU6, the Philips SU1278 and
 	  the LG TDQB-S00x.
 
-	  If you don't know what tuner module is soldered on your 
-	  DVB adapter simply enable all supported frontends, the 
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
+	  right one will get autodetected.
+
+config DVB_CX24110
+	tristate "Connexant CX24110 based"
+	depends on DVB_CORE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
+	  right one will get autodetected.
+
+config DVB_GRUNDIG_29504_491
+	tristate "Grundig 29504-491 based"
+	depends on DVB_CORE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
+	  right one will get autodetected.
+
+config DVB_MT312
+	tristate "Zarlink MT312 based"
+	depends on DVB_CORE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
+config DVB_VES1X93
+	tristate "VLSI VES1893 or VES1993 based"
+	depends on DVB_CORE
+	help
+	  A DVB-S tuner module. Say Y when you want to support this frontend.
+
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
+	  right one will get autodetected.
+
+comment "DVB-T (terrestrial) frontends"
+	depends on DVB_CORE
+
 config DVB_SP887X
- 	tristate "Frontends with sp887x demodulators, e.g. Microtune DTF7072"
+ 	tristate "Microtune sp887x based (i.e. Microtune DTF7072)"
  	depends on DVB_CORE
  	help
- 	  A DVB-T demodulator driver. Say Y when you want to support the sp887x.
- 
+ 	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
+	  This driver needs external firmware. Please use the command
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware sp887x" to
+	  download/extract it, and then copy it to /usr/lib/hotplug/firmware.
+
  	  If you don't know what tuner module is soldered on your
  	  DVB adapter simply enable all supported frontends, the
  	  right one will get autodetected.
 
-
-config DVB_SP887X_FIRMWARE_FILE
-        string "Full pathname of sp887x firmware file"
-        depends on DVB_SP887X
-        default "/usr/lib/hotplug/firmware/sc_main.mc"
-        help
-          This driver needs a copy of the Avermedia firmware. The version tested
-	  is part of the Avermedia DVB-T 1.3.26.3 Application. This can be downloaded
-	  from the Avermedia web site.
-	  If the software is installed in Windows the file will be in the
-	  /Program Files/AVerTV DVB-T/ directory and is called sc_main.mc.
-	  Alternatively it can "extracted" from the install cab files but this will have
-	  to be done in windows as I don't know of a linux version of extract.exe.
-	  Copy this file to /usr/lib/hotplug/firmware/sc_main.mc.
-	  With this version of the file the first 10 bytes are discarded and the next
-	  0x4000 loaded. This may change in future versions.
-
 config DVB_ALPS_TDLB7
-	tristate "Alps TDLB7 (OFDM)"
+	tristate "Alps TDLB7 based"
 	depends on DVB_CORE
 	help
 	  A DVB-T tuner module. Say Y when you want to support this frontend.
 
-	  This tuner module needs some microcode located in a file called
-	  "Sc_main.mc" in the windows driver. Please pass the module parameter
-	  mcfile="/PATH/FILENAME" when loading alps_tdlb7.o.
+	  This driver needs external firmware. Please use the command
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware alps_tdlb7" to
+	  download/extract it, and then copy it to /usr/lib/hotplug/firmware.
 
 	  If you don't know what tuner module is soldered on your
 	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-
 config DVB_ALPS_TDMB7
-	tristate "Alps TDMB7 (OFDM)"
+	tristate "Alps TDMB7 based"
 	depends on DVB_CORE
 	help
 	  A DVB-T tuner module. Say Y when you want to support this frontend.
@@ -79,109 +95,107 @@ config DVB_ALPS_TDMB7
 	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-config DVB_ATMEL_AT76C651
-	tristate "Atmel AT76C651 (QAM)"
+config DVB_CX22702
+ 	tristate "Conexant cx22702 demodulator (OFDM)"
+ 	depends on DVB_CORE
+ 	help
+ 	  A DVB-T tuner module. Say Y when you want to support this frontend.
+ 
+ 	  If you don't know what tuner module is soldered on your
+ 	  DVB adapter simply enable all supported frontends, the
+ 	  right one will get autodetected.
+
+config DVB_GRUNDIG_29504_401
+	tristate "Grundig 29504-401 based"
 	depends on DVB_CORE
 	help
-	  The AT76C651 Demodulator is used in some DVB-C SetTopBoxes. Say Y
-	  when you see this demodulator chip near your tuner module.
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
 
 	  If you don't know what tuner module is soldered on your
 	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-config DVB_CX24110
-	tristate "Frontends with Connexant CX24110 demodulator (QPSK)"
+config DVB_TDA1004X
+	tristate "Philips TDA10045H/TDA10046H based"
 	depends on DVB_CORE
 	help
-	  The CX24110 Demodulator is used in some DVB-S frontends. 
-	  Say Y if you want support for this chip in your kernel.
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
 
-	  If you don't know what tuner module is soldered on your 
-	  DVB adapter simply enable all supported frontends, the 
+	  This driver needs external firmware. Please use the commands
+	  "<kerneldir>/Documentation/dvb/get_dvb_firmware tda10045",
+  	  "<kerneldir>/Documentation/dvb/get_dvb_firmware tda10046" to
+	  download/extract them, and then copy them to /usr/lib/hotplug/firmware.
+
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-config DVB_GRUNDIG_29504_491
-	tristate "Grundig 29504-491 (QPSK)"
+config DVB_NXT6000
+	tristate "NxtWave Communications NXT6000 based"
 	depends on DVB_CORE
 	help
-	  A DVB-S tuner module. Say Y when you want to support this frontend.
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
 
-	  If you don't know what tuner module is soldered on your 
-	  DVB adapter simply enable all supported frontends, the 
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-config DVB_GRUNDIG_29504_401
-	tristate "Grundig 29504-401 (OFDM)"
+config DVB_MT352
+	tristate "Zarlink MT352 based"
 	depends on DVB_CORE
 	help
 	  A DVB-T tuner module. Say Y when you want to support this frontend.
 
-	  If you don't know what tuner module is soldered on your 
-	  DVB adapter simply enable all supported frontends, the 
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-config DVB_MT312
-	tristate "Zarlink MT312 Satellite Channel Decoder (QPSK)"
+config DVB_DIB3000MB
+	tristate "DiBcom 3000-MB" 
 	depends on DVB_CORE
 	help
-	  A DVB-S tuner module. Say Y when you want to support this frontend.
-
-	  If you don't know what tuner module is soldered on your 
-	  DVB adapter simply enable all supported frontends, the 
+	  A DVB-T tuner module. Designed for mobile usage. Say Y when you want
+	  to support this frontend.
+	 
+	  Used on USB-powered devices. You should also say Y to DVB_DIBUSB 
+	  (DiBcom USB DVB-T Adapter) to support the actual device, 
+	  this is "only" the frontend/tuner.
+	 
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-config DVB_VES1820
-	tristate "Frontends with external VES1820 demodulator (QAM)"
+comment "DVB-C (cable) frontends"
 	depends on DVB_CORE
-	help
-	  The VES1820 Demodulator is used on many DVB-C PCI cards and in some
-	  DVB-C SetTopBoxes. Say Y when you see this demodulator chip near your
-	  tuner module.
-
-	  If you don't know what tuner module is soldered on your 
-	  DVB adapter simply enable all supported frontends, the 
-	  right one will get autodetected.
 
-config DVB_VES1X93
-	tristate "Frontends with VES1893 or VES1993 demodulator (QPSK)"
+config DVB_ATMEL_AT76C651
+	tristate "Atmel AT76C651 based"
 	depends on DVB_CORE
 	help
-	  A DVB-S tuner module. Say Y when you want to support this frontend.
+ 	  A DVB-C tuner module. Say Y when you want to support this frontend.
 
-	  If you don't know what tuner module is soldered on your 
-	  DVB adapter simply enable all supported frontends, the 
+	  If you don't know what tuner module is soldered on your
+	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-config DVB_TDA1004X
-	tristate "Frontends with external TDA10045H or TDA10046H demodulators (OFDM)"
+config DVB_VES1820
+	tristate "VLSI VES1820 based"
 	depends on DVB_CORE
 	help
-	  A DVB-T tuner module. Say Y when you want to support this frontend.
+ 	  A DVB-C tuner module. Say Y when you want to support this frontend.
 
 	  If you don't know what tuner module is soldered on your
 	  DVB adapter simply enable all supported frontends, the
 	  right one will get autodetected.
 
-config DVB_TDA1004X_FIRMWARE_FILE
-        string "Full pathname of tda1004x.bin firmware file"
-        depends on DVB_TDA1004X
-        default "/usr/lib/hotplug/firmware/tda1004x.bin"
-        help
-          The TDA1004X requires additional firmware in order to function.
-          The firmware file can obtained as follows:
-            wget http://www.technotrend.de/new/215/TTweb_215a_budget_20_05_2003.zip
-            unzip -j TTweb_215a_budget_20_05_2003.zip Software/Oem/PCI/App/ttlcdacc.dll
-            mv ttlcdacc.dll /usr/lib/hotplug/firmware/tda1004x.bin
-	  Note: even if you're using a USB device, you MUST get the file from the
-	  TechnoTrend PCI drivers.
-
-config DVB_NXT6000
-	tristate "Frontends with NxtWave Communications NXT6000 demodulator (OFDM)"
+comment "Misc. Frontend Modules"
 	depends on DVB_CORE
+
+config DVB_TWINHAN_DST
+	tristate "Twinhan DST based DVB-S/-T frontend"
+	depends on DVB_CORE && DVB_BT8XX
 	help
-	  A DVB-T tuner module. Say Y when you want to support this frontend.
+	  Used in such cards as the VP-1020/1030, Twinhan DST,
+	  VVmer TV@SAT. Say Y when you want to support frontends
+	  using this asic.
 
-	  If you don't know what tuner module is soldered on your
-	  DVB adapter simply enable all supported frontends, the
-	  right one will get autodetected.
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/Makefile linux/drivers/media/dvb/frontends/Makefile
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/Makefile	2004-09-14 10:34:34.000000000 +0200
+++ linux/drivers/media/dvb/frontends/Makefile	2004-09-17 14:56:38.777605177 +0200
@@ -12,9 +12,13 @@ obj-$(CONFIG_DVB_ATMEL_AT76C651) += at76
 obj-$(CONFIG_DVB_CX24110) += cx24110.o
 obj-$(CONFIG_DVB_GRUNDIG_29504_491) += grundig_29504-491.o
 obj-$(CONFIG_DVB_GRUNDIG_29504_401) += grundig_29504-401.o
+obj-$(CONFIG_DVB_DIB3000MB) += dib3000mb.o
 obj-$(CONFIG_DVB_MT312) += mt312.o
 obj-$(CONFIG_DVB_VES1820) += ves1820.o
 obj-$(CONFIG_DVB_VES1X93) += ves1x93.o
 obj-$(CONFIG_DVB_TDA1004X) += tda1004x.o
 obj-$(CONFIG_DVB_SP887X) += sp887x.o
 obj-$(CONFIG_DVB_NXT6000) += nxt6000.o
+obj-$(CONFIG_DVB_MT352) += mt352.o
+obj-$(CONFIG_DVB_CX22702) += cx22702.o
+
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/alps_tdlb7.c linux/drivers/media/dvb/frontends/alps_tdlb7.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/alps_tdlb7.c	2004-09-14 10:38:20.000000000 +0200
+++ linux/drivers/media/dvb/frontends/alps_tdlb7.c	2004-09-17 14:56:38.781604427 +0200
@@ -19,34 +19,34 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
+/*
+ * This driver needs external firmware. Please use the command
+ * "<kerneldir>/Documentation/dvb/get_dvb_firmware alps_tdlb7" to
+ * download/extract it, and then copy it to /usr/lib/hotplug/firmware.
+ */ 
+#define SP887X_DEFAULT_FIRMWARE "dvb-fe-tdlb7-2.16.fw"
 
-
-/* 
-    This driver needs a copy of the firmware file 'Sc_main.mc' from the Haupauge
-    windows driver in the '/usr/lib/DVB/driver/frontends' directory.
-    You can also pass the complete file name with the module parameter 'firmware_file'.
-    
-*/  
-
-#include <linux/module.h>
 #include <linux/init.h>
-#include <linux/vmalloc.h>
-#include <linux/fs.h>
-#include <linux/unistd.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
 #include <linux/delay.h>
-#include <linux/syscalls.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
-#ifndef CONFIG_ALPS_TDLB7_FIRMWARE_LOCATION
-#define CONFIG_ALPS_TDLB7_FIRMWARE_LOCATION "/usr/lib/DVB/driver/frontends/Sc_main.mc"
-#endif
+#define FRONTEND_NAME "dvbfe_alps_tdlb7"
 
-static char * firmware_file = CONFIG_ALPS_TDLB7_FIRMWARE_LOCATION;
-static int debug = 0;
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
+
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
 
-#define dprintk	if (debug) printk
 
 /* firmware size for sp8870 */
 #define SP8870_FIRMWARE_SIZE 16382
@@ -68,14 +68,18 @@ static struct dvb_frontend_info tdlb7_in
 				  FE_CAN_HIERARCHY_AUTO |  FE_CAN_RECOVER
 };
 
+struct tdlb7_state {
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
 
-static int sp8870_writereg (struct dvb_i2c_bus *i2c, u16 reg, u16 data)
+static int sp8870_writereg (struct i2c_adapter *i2c, u16 reg, u16 data)
 {
         u8 buf [] = { reg >> 8, reg & 0xff, data >> 8, data & 0xff };
 	struct i2c_msg msg = { .addr = 0x71, .flags = 0, .buf = buf, .len = 4 };
 	int err;
 
-        if ((err = i2c->xfer (i2c, &msg, 1)) != 1) {
+        if ((err = i2c_transfer (i2c, &msg, 1)) != 1) {
 		dprintk ("%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\n", __FUNCTION__, err, reg, data);
 		return -EREMOTEIO;
 	}
@@ -83,8 +87,7 @@ static int sp8870_writereg (struct dvb_i
         return 0;
 }
 
-
-static u16 sp8870_readreg (struct dvb_i2c_bus *i2c, u16 reg)
+static u16 sp8870_readreg (struct i2c_adapter *i2c, u16 reg)
 {
 	int ret;
 	u8 b0 [] = { reg >> 8 , reg & 0xff };
@@ -92,7 +95,7 @@ static u16 sp8870_readreg (struct dvb_i2
 	struct i2c_msg msg [] = { { .addr = 0x71, .flags = 0, .buf = b0, .len = 2 },
 			   { .addr = 0x71, .flags = I2C_M_RD, .buf = b1, .len = 2 } };
 
-	ret = i2c->xfer (i2c, msg, 2);
+	ret = i2c_transfer (i2c, msg, 2);
 
 	if (ret != 2) {
 		dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
@@ -102,22 +105,26 @@ static u16 sp8870_readreg (struct dvb_i2
 	return (b1[0] << 8 | b1[1]);
 }
 
-
-static int sp5659_write (struct dvb_i2c_bus *i2c, u8 data [4])
+static int sp5659_write (struct i2c_adapter *i2c, u8 data [4])
 {
         int ret;
-        struct i2c_msg msg = { .addr = 0x60, .flags = 0, .buf = data, .len = 4 };
 
-        ret = i2c->xfer (i2c, &msg, 1);
+        u8 buf_open [] = { 0x206 >> 8, 0x206 & 0xff, 0x001 >> 8, 0x001 & 0xff };
+        u8 buf_close [] = { 0x206 >> 8, 0x206 & 0xff, 0x000 >> 8, 0x000 & 0xff };
+
+        struct i2c_msg msg[3] = { {.addr = 0x71, .flags = 0, .buf = buf_open, .len = 4 },
+				  {.addr = 0x60, .flags = 0, .buf = data, .len = 4 },
+				  {.addr = 0x71, .flags = 0, .buf = buf_close, .len = 4 } };
+
+        ret = i2c_transfer (i2c, &msg[0], 3);
 
-        if (ret != 1)
+        if (ret != 3)
                 printk("%s: i/o error (ret == %i)\n", __FUNCTION__, ret);
 
-        return (ret != 1) ? -1 : 0;
+        return (ret != 3) ? -EREMOTEIO : 0;
 }
 
-
-static void sp5659_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq)
+static void sp5659_set_tv_freq (struct i2c_adapter *i2c, u32 freq)
 {
         u32 div = (freq + 36200000) / 166666;
         u8 buf [4];
@@ -125,7 +132,7 @@ static void sp5659_set_tv_freq (struct d
 
 	if (freq <= 782000000)
 		pwr = 1;
-	else 
+	else
 		pwr = 2;
 
 	buf[0] = (div >> 8) & 0x7f;
@@ -134,67 +141,25 @@ static void sp5659_set_tv_freq (struct d
 	buf[3] = pwr << 6;
 
 	/* open i2c gate for PLL message transmission... */
-	sp8870_writereg(i2c, 0x206, 0x001);
 	sp5659_write (i2c, buf);
-	sp8870_writereg(i2c, 0x206, 0x000);
-}
-
-
-static int sp8870_read_firmware_file (const char *fn, char **fp)
-{
-        int fd;
-	loff_t filesize;
-	char *dp;
-
-	fd = sys_open(fn, 0, 0);
-	if (fd == -1) {
-                printk("%s: unable to open '%s'.\n", __FUNCTION__, fn);
-		return -EIO;
-	}
-
-	filesize = sys_lseek(fd, 0L, 2);
-	if (filesize <= 0 || filesize < SP8870_FIRMWARE_OFFSET + SP8870_FIRMWARE_SIZE) {
-	        printk("%s: firmware filesize to small '%s'\n", __FUNCTION__, fn);
-		sys_close(fd);
-		return -EIO;
-	}
-
-	*fp= dp = vmalloc(SP8870_FIRMWARE_SIZE);
-	if (dp == NULL)	{
-		printk("%s: out of memory loading '%s'.\n", __FUNCTION__, fn);
-		sys_close(fd);
-		return -EIO;
-	}
-
-	sys_lseek(fd, SP8870_FIRMWARE_OFFSET, 0);
-	if (sys_read(fd, dp, SP8870_FIRMWARE_SIZE) != SP8870_FIRMWARE_SIZE) {
-		printk("%s: failed to read '%s'.\n",__FUNCTION__, fn);
-		vfree(dp);
-		sys_close(fd);
-		return -EIO;
-	}
-
-	sys_close(fd);
-	*fp = dp;
-
-	return 0;
 }
 
-
-static int sp8870_firmware_upload (struct dvb_i2c_bus *i2c)
+static int sp8870_firmware_upload (struct i2c_adapter *i2c, const struct firmware *fw)
 {
 	struct i2c_msg msg;
-	char *fw_buf = NULL;
+	char *fw_buf = fw->data;
 	int fw_pos;
 	u8 tx_buf[255];
 	int tx_len;
 	int err = 0;
-	mm_segment_t fs = get_fs();
 
 	dprintk ("%s: ...\n", __FUNCTION__);
 
-	// system controller stop 
-	sp8870_writereg(i2c,0x0F00,0x0000);
+	if (fw->size < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET)
+		return -EINVAL;
+
+	// system controller stop
+	sp8870_writereg(i2c, 0x0F00, 0x0000);
 
 	// instruction RAM register hiword
 	sp8870_writereg(i2c, 0x8F08, ((SP8870_FIRMWARE_SIZE / 2) & 0xFFFF));
@@ -202,44 +167,31 @@ static int sp8870_firmware_upload (struc
 	// instruction RAM MWR
 	sp8870_writereg(i2c, 0x8F0A, ((SP8870_FIRMWARE_SIZE / 2) >> 16));
 
-	// reading firmware file to buffer
-	set_fs(get_ds());
-        err = sp8870_read_firmware_file(firmware_file, (char**) &fw_buf);
-	set_fs(fs);
-	if (err != 0) {
-		printk("%s: reading firmware file failed!\n", __FUNCTION__);
-		return err;
-	}
-
 	// do firmware upload
-	fw_pos = 0;
-	while (fw_pos < SP8870_FIRMWARE_SIZE){
-		tx_len = (fw_pos <= SP8870_FIRMWARE_SIZE - 252) ? 252 : SP8870_FIRMWARE_SIZE - fw_pos;
+	fw_pos = SP8870_FIRMWARE_OFFSET;
+	while (fw_pos < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET){
+		tx_len = (fw_pos <= SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - 252) ? 252 : SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - fw_pos;
 		// write register 0xCF0A
 		tx_buf[0] = 0xCF;
 		tx_buf[1] = 0x0A;
 		memcpy(&tx_buf[2], fw_buf + fw_pos, tx_len);
-		msg.addr=0x71;
-		msg.flags=0;
+		msg.addr = 0x71;
+		msg.flags = 0;
 		msg.buf = tx_buf;
 		msg.len = tx_len + 2;
-        	if ((err = i2c->xfer (i2c, &msg, 1)) != 1) {
+        	if ((err = i2c_transfer (i2c, &msg, 1)) != 1) {
 			printk("%s: firmware upload failed!\n", __FUNCTION__);
 			printk ("%s: i2c error (err == %i)\n", __FUNCTION__, err);
-        		vfree(fw_buf);
 			return err;
 		}
 		fw_pos += tx_len;
 	}
 
-	vfree(fw_buf);
-
 	dprintk ("%s: done!\n", __FUNCTION__);
 	return 0;
 };
 
-
-static void sp8870_microcontroller_stop (struct dvb_i2c_bus *i2c)
+static void sp8870_microcontroller_stop (struct i2c_adapter *i2c)
 {
 	sp8870_writereg(i2c, 0x0F08, 0x000);
 	sp8870_writereg(i2c, 0x0F09, 0x000);
@@ -248,8 +200,7 @@ static void sp8870_microcontroller_stop 
 	sp8870_writereg(i2c, 0x0F00, 0x000);
 }
 
-
-static void sp8870_microcontroller_start (struct dvb_i2c_bus *i2c)
+static void sp8870_microcontroller_start (struct i2c_adapter *i2c)
 {
 	sp8870_writereg(i2c, 0x0F08, 0x000);
 	sp8870_writereg(i2c, 0x0F09, 0x000);
@@ -261,25 +212,24 @@ static void sp8870_microcontroller_start
 	sp8870_readreg(i2c, 0x0D01);
 }
 
-
-static int sp8870_init (struct dvb_i2c_bus *i2c)
+static int sp8870_init (struct i2c_adapter *i2c)
 {
 	dprintk ("%s\n", __FUNCTION__);
 
 	/* enable TS output and interface pins */
 	sp8870_writereg(i2c, 0xc18, 0x00d);
 
-	// system controller stop 
+	// system controller stop
 	sp8870_microcontroller_stop(i2c);
 
 	// ADC mode
-	sp8870_writereg(i2c,0x0301,0x0003);
+	sp8870_writereg(i2c, 0x0301, 0x0003);
 
 	// Reed Solomon parity bytes passed to output
-	sp8870_writereg(i2c,0x0C13,0x0001);
+	sp8870_writereg(i2c, 0x0C13, 0x0001);
 
 	// MPEG clock is suppressed if no valid data
-	sp8870_writereg(i2c,0x0C14,0x0001);
+	sp8870_writereg(i2c, 0x0C14, 0x0001);
 
 	/* bit 0x010: enable data valid signal */
 	sp8870_writereg(i2c, 0x0D00, 0x010);
@@ -288,8 +238,7 @@ static int sp8870_init (struct dvb_i2c_b
 	return 0;
 }
 
-
-static int sp8870_read_status (struct dvb_i2c_bus *i2c,  fe_status_t * fe_status)
+static int sp8870_read_status (struct i2c_adapter *i2c,  fe_status_t * fe_status)
 {
 	int status;
 	int signal;
@@ -314,8 +263,7 @@ static int sp8870_read_status (struct dv
 	return 0;
 }
 
-
-static int sp8870_read_ber (struct dvb_i2c_bus *i2c, u32 * ber)
+static int sp8870_read_ber (struct i2c_adapter *i2c, u32 * ber)
 {
 	int ret;
 	u32 tmp;
@@ -340,11 +288,10 @@ static int sp8870_read_ber (struct dvb_i
 	*ber = tmp;
 
 	return 0;
-	}
-
+}
 
-static int sp8870_read_signal_strength (struct dvb_i2c_bus *i2c,  u16 * signal)
-	{
+static int sp8870_read_signal_strength (struct i2c_adapter *i2c,  u16 * signal)
+{
 	int ret;
 	u16 tmp;
 
@@ -366,21 +313,19 @@ static int sp8870_read_signal_strength (
 		*signal = 0xFFFF - tmp;
 
 	return 0;
-	}
-
-
-static int sp8870_read_snr(struct dvb_i2c_bus *i2c, u32* snr)
-	{
-                *snr=0;  
-		return -EOPNOTSUPP;
-	}
+}
 
+static int sp8870_read_snr(struct i2c_adapter *i2c, u32* snr)
+{
+	*snr = 0;
+	return -EOPNOTSUPP;
+}
 
-static int sp8870_read_uncorrected_blocks (struct dvb_i2c_bus *i2c, u32* ublocks)
-	{
+static int sp8870_read_uncorrected_blocks (struct i2c_adapter *i2c, u32* ublocks)
+{
 		int ret;
 
-		*ublocks=0;  
+		*ublocks = 0;
 
 		ret = sp8870_readreg(i2c, 0xC0C);
 		if (ret < 0)
@@ -392,15 +337,13 @@ static int sp8870_read_uncorrected_block
 		*ublocks = ret;
 
 		return 0;
-	}
-
+}
 
-static int sp8870_read_data_valid_signal(struct dvb_i2c_bus *i2c)
+static int sp8870_read_data_valid_signal(struct i2c_adapter *i2c)
 {
 	return (sp8870_readreg(i2c, 0x0D02) > 0);
 }
 
-
 static
 int configure_reg0xc05 (struct dvb_frontend_parameters *p, u16 *reg0xc05)
 {
@@ -473,59 +416,57 @@ int configure_reg0xc05 (struct dvb_front
 	return 0;
 }
 
-
-static int sp8870_set_frontend_parameters (struct dvb_i2c_bus *i2c,
+static int sp8870_set_frontend_parameters (struct i2c_adapter *i2c,
 				      struct dvb_frontend_parameters *p)
-        {
+{
 	int  err;
 	u16 reg0xc05;
 
 	if ((err = configure_reg0xc05(p, &reg0xc05)))
 		return err;
 
-		// system controller stop 
+	// system controller stop
 	sp8870_microcontroller_stop(i2c);
 
 	// set tuner parameters
-		sp5659_set_tv_freq (i2c, p->frequency);
+	sp5659_set_tv_freq (i2c, p->frequency);
+
+	// sample rate correction bit [23..17]
+	sp8870_writereg(i2c, 0x0319, 0x000A);
+
+	// sample rate correction bit [16..0]
+	sp8870_writereg(i2c, 0x031A, 0x0AAB);
+
+	// integer carrier offset
+	sp8870_writereg(i2c, 0x0309, 0x0400);
+
+	// fractional carrier offset
+	sp8870_writereg(i2c, 0x030A, 0x0000);
 
-		// sample rate correction bit [23..17]
-		sp8870_writereg(i2c,0x0319,0x000A);
-		
-		// sample rate correction bit [16..0]
-		sp8870_writereg(i2c,0x031A,0x0AAB);
-
-		// integer carrier offset 
-		sp8870_writereg(i2c,0x0309,0x0400);
-
-		// fractional carrier offset
-		sp8870_writereg(i2c,0x030A,0x0000);
-
-		// filter for 6/7/8 Mhz channel
-		if (p->u.ofdm.bandwidth == BANDWIDTH_6_MHZ)
-			sp8870_writereg(i2c,0x0311,0x0002);
-		else if (p->u.ofdm.bandwidth == BANDWIDTH_7_MHZ)
-			sp8870_writereg(i2c,0x0311,0x0001);
-		else
-			sp8870_writereg(i2c,0x0311,0x0000);
-
-		// scan order: 2k first = 0x0000, 8k first = 0x0001 
-		if (p->u.ofdm.transmission_mode == TRANSMISSION_MODE_2K)
-			sp8870_writereg(i2c,0x0338,0x0000);
-		else
-			sp8870_writereg(i2c,0x0338,0x0001);
+	// filter for 6/7/8 Mhz channel
+	if (p->u.ofdm.bandwidth == BANDWIDTH_6_MHZ)
+		sp8870_writereg(i2c, 0x0311, 0x0002);
+	else if (p->u.ofdm.bandwidth == BANDWIDTH_7_MHZ)
+		sp8870_writereg(i2c, 0x0311, 0x0001);
+	else
+		sp8870_writereg(i2c, 0x0311, 0x0000);
+
+	// scan order: 2k first = 0x0000, 8k first = 0x0001
+	if (p->u.ofdm.transmission_mode == TRANSMISSION_MODE_2K)
+		sp8870_writereg(i2c, 0x0338, 0x0000);
+	else
+		sp8870_writereg(i2c, 0x0338, 0x0001);
 
 	sp8870_writereg(i2c, 0xc05, reg0xc05);
 
 	// read status reg in order to clear pending irqs
 	sp8870_readreg(i2c, 0x200);
 
-		// system controller start
+	// system controller start
 	sp8870_microcontroller_start(i2c);
 
 	return 0;
-        }
-
+}
 
 // number of trials to recover from lockup
 #define MAXTRIALS 5
@@ -537,8 +478,8 @@ static int lockups = 0;
 // only for debugging: counter for channel switches
 static int switches = 0;
 
-static int sp8870_set_frontend (struct dvb_i2c_bus *i2c, struct dvb_frontend_parameters *p)
-	{
+static int sp8870_set_frontend (struct i2c_adapter *i2c, struct dvb_frontend_parameters *p)
+{
 	/*
 	    The firmware of the sp8870 sometimes locks up after setting frontend parameters.
 	    We try to detect this by checking the data valid signal.
@@ -569,7 +510,7 @@ static int sp8870_set_frontend (struct d
 			udelay(10);
 		}
 		if (valid)
-		break;
+			break;
 	}
 
 	if (!valid) {
@@ -592,24 +533,22 @@ static int sp8870_set_frontend (struct d
 	return 0;
 }
 
-
-static int sp8870_sleep(struct dvb_i2c_bus *i2c)
+static int sp8870_sleep(struct i2c_adapter *i2c)
 {
 	// tristate TS output and disable interface pins
 	return sp8870_writereg(i2c, 0xC18, 0x000);
 }
 
-
-static int sp8870_wake_up(struct dvb_i2c_bus *i2c)
+static int sp8870_wake_up(struct i2c_adapter *i2c)
 {
 	// enable TS output and interface pins
 	return sp8870_writereg(i2c, 0xC18, 0x00D);
 }
 
-
 static int tdlb7_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
+	struct tdlb7_state *state = (struct tdlb7_state *) fe->data;
+	struct i2c_adapter *i2c = state->i2c;
 
         switch (cmd) {
         case FE_GET_INFO:
@@ -664,61 +603,144 @@ static int tdlb7_ioctl (struct dvb_front
         return 0;
 }
 
+static struct i2c_client client_template;
 
-static int tdlb7_attach (struct dvb_i2c_bus *i2c, void **data)
+static int attach_adapter(struct i2c_adapter *adapter)
 {
-        u8 b0 [] = { 0x02 , 0x00 };
+	struct i2c_client *client;
+	struct tdlb7_state *state;
+	const struct firmware *fw;
+	int ret;
+
+	u8 b0 [] = { 0x02 , 0x00 };
         u8 b1 [] = { 0, 0 };
         struct i2c_msg msg [] = { { .addr = 0x71, .flags = 0, .buf = b0, .len = 2 },
                                   { .addr = 0x71, .flags = I2C_M_RD, .buf = b1, .len = 2 } };
 
 	dprintk ("%s\n", __FUNCTION__);
 
-        if (i2c->xfer (i2c, msg, 2) != 2)
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	if (NULL == (state = kmalloc(sizeof(struct tdlb7_state), GFP_KERNEL))) {
+		kfree(client);
+		return -ENOMEM;
+	}
+	state->i2c = adapter;
+
+        if (i2c_transfer (adapter, msg, 2) != 2) {
+		kfree(state);
+		kfree(client);
                 return -ENODEV;
+	}
 
-	sp8870_firmware_upload(i2c);
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	i2c_set_clientdata(client, (void*)state);
+
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	/* request the firmware, this will block until someone uploads it */
+	printk("tdlb7: waiting for firmware upload...\n");
+	ret = request_firmware(&fw, SP887X_DEFAULT_FIRMWARE, &client->dev);
+	if (ret) {
+		printk("tdlb7: no firmware upload (timeout or file not found?)\n");
+		goto out;
+	}
+
+	ret = sp8870_firmware_upload(adapter, fw);
+	if (ret) {
+		printk("tdlb7: writing firmware to device failed\n");
+		release_firmware(fw);
+		goto out;
+	}
+
+	ret = dvb_register_frontend(tdlb7_ioctl, state->dvb, state,
+					&tdlb7_info, THIS_MODULE);
+	if (ret) {
+		printk("tdlb7: registering frontend to dvb-core failed.\n");
+		release_firmware(fw);
+		goto out;
+	}
 
-	return dvb_register_frontend (tdlb7_ioctl, i2c, NULL, &tdlb7_info);
+	return 0;
+out:
+	i2c_detach_client(client);
+	kfree(client);
+	kfree(state);
+	return ret;
 }
 
-
-static void tdlb7_detach (struct dvb_i2c_bus *i2c, void *data)
+static int detach_client(struct i2c_client *client)
 {
+	struct tdlb7_state *state = (struct tdlb7_state*)i2c_get_clientdata(client);
+
 	dprintk ("%s\n", __FUNCTION__);
 
-	dvb_unregister_frontend (tdlb7_ioctl, i2c);
+	dvb_unregister_frontend (tdlb7_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
 }
 
-
-static int __init init_tdlb7 (void)
+static int command (struct i2c_client *client, unsigned int cmd, void *arg)
 {
+	struct tdlb7_state *state = (struct tdlb7_state*)i2c_get_clientdata(client);
+
 	dprintk ("%s\n", __FUNCTION__);
 
-	return dvb_register_i2c_device (THIS_MODULE, tdlb7_attach, tdlb7_detach);
+	switch (cmd) {
+	case FE_REGISTER:
+		state->dvb = (struct dvb_adapter*)arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= FRONTEND_NAME,
+	.id 		= I2C_DRIVERID_DVBFE_ALPS_TDLB7,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = attach_adapter,
+	.detach_client 	= detach_client,
+	.command 	= command,
+};
 
-static void __exit exit_tdlb7 (void)
-{
-	dprintk ("%s\n", __FUNCTION__);
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
 
-	dvb_unregister_i2c_device (tdlb7_attach);
+static int __init init_tdlb7(void)
+{
+	return i2c_add_driver(&driver);
 }
 
+static void __exit exit_tdlb7(void)
+{
+	if (i2c_del_driver(&driver))
+		printk("tdlb7: driver deregistration failed\n");
+}
 
 module_init(init_tdlb7);
 module_exit(exit_tdlb7);
 
-
-MODULE_PARM(debug,"i");
-MODULE_PARM_DESC(debug, "enable verbose debug messages");
-
-MODULE_PARM(firmware_file,"s");
-MODULE_PARM_DESC(firmware_file, "where to find the firmware file");
-
 MODULE_DESCRIPTION("TDLB7 DVB-T Frontend");
 MODULE_AUTHOR("Juergen Peitz");
 MODULE_LICENSE("GPL");
 
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/alps_tdmb7.c linux/drivers/media/dvb/frontends/alps_tdmb7.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/alps_tdmb7.c	2004-09-14 10:34:52.000000000 +0200
+++ linux/drivers/media/dvb/frontends/alps_tdmb7.c	2004-09-17 14:56:38.785603678 +0200
@@ -1,4 +1,4 @@
-/* 
+/*
     Alps TDMB7 DVB OFDM frontend driver
 
     Copyright (C) 2001-2002 Convergence Integrated Media GmbH
@@ -18,20 +18,28 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-*/    
+*/
 
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
+#define FRONTEND_NAME "dvbfe_alps_tdmb7"
 
-static int debug = 0;
-#define dprintk	if (debug) printk
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
+
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
 
 
 static struct dvb_frontend_info tdmb7_info = {
@@ -49,10 +57,14 @@ static struct dvb_frontend_info tdmb7_in
 #endif
 	.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 	      FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
-	      FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | 
+	      FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
               FE_CAN_RECOVER
 };
 
+struct tdmb7_state {
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
 
 static u8 init_tab [] = {
 	0x04, 0x10,
@@ -75,8 +87,7 @@ static u8 init_tab [] = {
 	0x47, 0x05,
 };
 
-
-static int cx22700_writereg (struct dvb_i2c_bus *i2c, u8 reg, u8 data)
+static int cx22700_writereg (struct i2c_adapter *i2c, u8 reg, u8 data)
 {
 	int ret;
 	u8 buf [] = { reg, data };
@@ -84,42 +95,40 @@ static int cx22700_writereg (struct dvb_
 
 	dprintk ("%s\n", __FUNCTION__);
 
-	ret = i2c->xfer (i2c, &msg, 1);
+	ret = i2c_transfer (i2c, &msg, 1);
 
-	if (ret != 1) 
+	if (ret != 1)
 		printk("%s: writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\n",
 			__FUNCTION__, reg, data, ret);
 
 	return (ret != 1) ? -1 : 0;
 }
 
-
-static u8 cx22700_readreg (struct dvb_i2c_bus *i2c, u8 reg)
+static u8 cx22700_readreg (struct i2c_adapter *i2c, u8 reg)
 {
 	int ret;
 	u8 b0 [] = { reg };
 	u8 b1 [] = { 0 };
 	struct i2c_msg msg [] = { { .addr = 0x43, .flags = 0, .buf = b0, .len = 1 },
 			   { .addr = 0x43, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
-        
+
 	dprintk ("%s\n", __FUNCTION__);
 
-	ret = i2c->xfer (i2c, msg, 2);
-        
-	if (ret != 2) 
+	ret = i2c_transfer (i2c, msg, 2);
+
+	if (ret != 2)
 		printk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
 
 	return b1[0];
 }
 
-
-static int pll_write (struct dvb_i2c_bus *i2c, u8 data [4])
+static int pll_write (struct i2c_adapter *i2c, u8 data [4])
 {
 	struct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = 4 };
 	int ret;
 
 	cx22700_writereg (i2c, 0x0a, 0x00);  /* open i2c bus switch */
-	ret = i2c->xfer (i2c, &msg, 1);
+	ret = i2c_transfer (i2c, &msg, 1);
 	cx22700_writereg (i2c, 0x0a, 0x01);  /* close i2c bus switch */
 
 	if (ret != 1)
@@ -128,12 +137,11 @@ static int pll_write (struct dvb_i2c_bus
 	return (ret != 1) ? -1 : 0;
 }
 
-
 /**
- *   set up the downconverter frequency divisor for a 
+ *   set up the downconverter frequency divisor for a
  *   reference clock comparision frequency of 125 kHz.
  */
-static int pll_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq)
+static int pll_set_tv_freq (struct i2c_adapter *i2c, u32 freq)
 {
 	u32 div = (freq + 36166667) / 166667;
 #if 1 //ALPS_SETTINGS
@@ -149,8 +157,7 @@ static int pll_set_tv_freq (struct dvb_i
 	return pll_write (i2c, buf);
 }
 
-
-static int cx22700_init (struct dvb_i2c_bus *i2c)
+static int cx22700_init (struct i2c_adapter *i2c)
 {
 	int i;
 
@@ -159,18 +166,17 @@ static int cx22700_init (struct dvb_i2c_
 	cx22700_writereg (i2c, 0x00, 0x02);   /*  soft reset */
 	cx22700_writereg (i2c, 0x00, 0x00);
 
-	dvb_delay(10);
-	
+	msleep(10);
+
 	for (i=0; i<sizeof(init_tab); i+=2)
 		cx22700_writereg (i2c, init_tab[i], init_tab[i+1]);
 
 	cx22700_writereg (i2c, 0x00, 0x01);
-	
+
 	return 0;
 }
 
-
-static int cx22700_set_inversion (struct dvb_i2c_bus *i2c, int inversion)
+static int cx22700_set_inversion (struct i2c_adapter *i2c, int inversion)
 {
 	u8 val;
 
@@ -190,8 +196,7 @@ static int cx22700_set_inversion (struct
 	}
 }
 
-
-static int cx22700_set_tps (struct dvb_i2c_bus *i2c, struct dvb_ofdm_parameters *p)
+static int cx22700_set_tps (struct i2c_adapter *i2c, struct dvb_ofdm_parameters *p)
 {
 	static const u8 qam_tab [4] = { 0, 1, 0, 2 };
 	static const u8 fec_tab [6] = { 0, 1, 2, 0, 3, 4 };
@@ -253,8 +258,7 @@ static int cx22700_set_tps (struct dvb_i
 	return 0;
 }
 
-
-static int cx22700_get_tps (struct dvb_i2c_bus *i2c, struct dvb_ofdm_parameters *p)
+static int cx22700_get_tps (struct i2c_adapter *i2c, struct dvb_ofdm_parameters *p)
 {
 	static const fe_modulation_t qam_tab [3] = { QPSK, QAM_16, QAM_64 };
 	static const fe_code_rate_t fec_tab [5] = { FEC_1_2, FEC_2_3, FEC_3_4,
@@ -278,7 +282,6 @@ static int cx22700_get_tps (struct dvb_i
 	else
 		p->constellation = qam_tab[(val >> 3) & 0x3];
 
-
 	val = cx22700_readreg (i2c, 0x02);
 
 	if (((val >> 3) & 0x07) > 4)
@@ -291,7 +294,6 @@ static int cx22700_get_tps (struct dvb_i
 	else
 		p->code_rate_LP = fec_tab[val & 0x07];
 
-
 	val = cx22700_readreg (i2c, 0x03);
 
 	p->guard_interval = GUARD_INTERVAL_1_32 + ((val >> 6) & 0x3);
@@ -300,10 +302,10 @@ static int cx22700_get_tps (struct dvb_i
 	return 0;
 }
 
-
 static int tdmb7_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
+	struct tdmb7_state *state = fe->data;
+	struct i2c_adapter *i2c = state->i2c;
 
 	dprintk ("%s\n", __FUNCTION__);
 
@@ -358,7 +360,7 @@ static int tdmb7_ioctl (struct dvb_front
 		*((u16*) arg) = ~rs_ber;
 		break;
 	}
-	case FE_READ_UNCORRECTED_BLOCKS: 
+	case FE_READ_UNCORRECTED_BLOCKS:
 		*((u32*) arg) = cx22700_readreg (i2c, 0x0f);
 		cx22700_writereg (i2c, 0x0f, 0x00);
 		break;
@@ -382,7 +384,7 @@ static int tdmb7_ioctl (struct dvb_front
         {
 		struct dvb_frontend_parameters *p = arg;
 		u8 reg09 = cx22700_readreg (i2c, 0x09);
-		
+
 		p->inversion = reg09 & 0x1 ? INVERSION_ON : INVERSION_OFF;
 		return cx22700_get_tps (i2c, &p->u.ofdm);
         }
@@ -406,52 +408,124 @@ static int tdmb7_ioctl (struct dvb_front
 	return 0;
 }
 
+static struct i2c_client client_template;
 
-
-static int tdmb7_attach (struct dvb_i2c_bus *i2c, void **data)
+static int attach_adapter (struct i2c_adapter *adapter)
 {
-        u8 b0 [] = { 0x7 };
-        u8 b1 [] = { 0 };
-        struct i2c_msg msg [] = { { .addr = 0x43, .flags = 0, .buf = b0, .len = 1 },
-                                  { .addr = 0x43, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
+	struct tdmb7_state *state;
+	struct i2c_client *client;
+	int ret;
+
+	u8 b0 [] = { 0x7 };
+	u8 b1 [] = { 0 };
+	struct i2c_msg msg [] = { { .addr = 0x43, .flags = 0, .buf = b0, .len = 1 },
+				  { .addr = 0x43, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
 
 	dprintk ("%s\n", __FUNCTION__);
 
-        if (i2c->xfer (i2c, msg, 2) != 2)
-                return -ENODEV;
+	if (i2c_transfer(adapter, msg, 2) != 2)
+		return -ENODEV;
 
-	return dvb_register_frontend (tdmb7_ioctl, i2c, NULL, &tdmb7_info);
-}
+	if (NULL == (state = kmalloc(sizeof(struct tdmb7_state), GFP_KERNEL)))
+		return -ENOMEM;
+
+	state->i2c = adapter;
 
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	i2c_set_clientdata(client, state);
+
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(state);
+		kfree(client);
+		return ret;
+	}
 
-static void tdmb7_detach (struct dvb_i2c_bus *i2c, void *data)
+	BUG_ON(!state->dvb);
+
+	ret = dvb_register_frontend (tdmb7_ioctl, state->dvb, state,
+					 &tdmb7_info, THIS_MODULE);
+	if (ret) {
+		i2c_detach_client(client);
+		kfree(state);
+		kfree(client);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int detach_client (struct i2c_client *client)
 {
+	struct tdmb7_state *state = i2c_get_clientdata(client);
+
 	dprintk ("%s\n", __FUNCTION__);
 
-	dvb_unregister_frontend (tdmb7_ioctl, i2c);
+	dvb_unregister_frontend (tdmb7_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
 }
 
-
-static int __init init_tdmb7 (void)
+static int command (struct i2c_client *client,
+		    unsigned int cmd, void *arg)
 {
-	dprintk ("%s\n", __FUNCTION__);
+	struct tdmb7_state *state = i2c_get_clientdata(client);
+
+	dprintk("%s\n", __FUNCTION__);
 
-	return dvb_register_i2c_device (THIS_MODULE, tdmb7_attach, tdmb7_detach);
+	switch (cmd) {
+	case FE_REGISTER:
+		state->dvb = arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner		= THIS_MODULE,
+	.name		= FRONTEND_NAME,
+	.id		= I2C_DRIVERID_DVBFE_ALPS_TDMB7,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= attach_adapter,
+	.detach_client	= detach_client,
+	.command	= command,
+};
 
-static void __exit exit_tdmb7 (void)
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags		= I2C_CLIENT_ALLOW_USE,
+	.driver		= &driver,
+};
+
+static int __init init_tdmb7 (void)
 {
-	dprintk ("%s\n", __FUNCTION__);
+	return i2c_add_driver(&driver);
+}
 
-	dvb_unregister_i2c_device (tdmb7_attach);
+static void __exit exit_tdmb7 (void)
+{
+	if (i2c_del_driver(&driver))
+		printk(KERN_ERR "alps_tdmb7: driver deregistration failed.\n");
 }
 
 module_init (init_tdmb7);
 module_exit (exit_tdmb7);
 
-MODULE_PARM(debug,"i");
-MODULE_PARM_DESC(debug, "enable verbose debug messages");
 MODULE_DESCRIPTION("TDMB7 DVB Frontend driver");
 MODULE_AUTHOR("Holger Waechtler");
 MODULE_LICENSE("GPL");
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/at76c651.c linux/drivers/media/dvb/frontends/at76c651.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/at76c651.c	2004-09-14 10:37:26.000000000 +0200
+++ linux/drivers/media/dvb/frontends/at76c651.c	2004-09-17 14:56:38.790602741 +0200
@@ -1,10 +1,10 @@
 /*
  * at76c651.c
  * 
- * Atmel DVB-C Frontend Driver (at76c651/dat7021)
+ * Atmel DVB-C Frontend Driver (at76c651/tua6010xs)
  *
  * Copyright (C) 2001 fnbrd <fnbrd@gmx.de>
- *             & 2002 Andreas Oberritter <obi@linuxtv.org>
+ *             & 2002-2004 Andreas Oberritter <obi@linuxtv.org>
  *             & 2003 Wolfram Joost <dbox2@frokaschwei.de>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -21,10 +21,17 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
+ * AT76C651
+ * http://www.nalanda.nitc.ac.in/industry/datasheets/atmel/acrobat/doc1293.pdf
+ * http://www.atmel.com/atmel/acrobat/doc1320.pdf
+ *
+ * TUA6010XS
+ * http://www.infineon.com/cgi/ecrm.dll/ecrm/scripts/public_download.jsp?oid=19512
  */
 
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/slab.h>
@@ -34,29 +41,22 @@
 #endif
 
 #include "dvb_frontend.h"
-#include "dvb_i2c.h"
-#include "dvb_functions.h"
 
-static int debug = 0;
-static u8 at76c651_qam;
-static u8 at76c651_revision;
+#define FRONTEND_NAME "dvbfe_at76c651"
 
-#define dprintk	if (debug) printk
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
 
-/*
- * DAT7021
- * -------
- * Input Frequency Range (RF): 48.25 MHz to 863.25 MHz
- * Band Width: 8 MHz
- * Level Input (Range for Digital Signals): -61 dBm to -41 dBm
- * Output Frequency (IF): 36 MHz
- *
- * (see http://www.atmel.com/atmel/acrobat/doc1320.pdf)
- */
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
 
-static struct dvb_frontend_info at76c651_info = {
 
-	.name = "Atmel AT76C651(B) with DAT7021",
+static struct dvb_frontend_info at76c651_info = {
+	.name = "Atmel AT76C651B with TUA6010XS",
 	.type = FE_QAM,
 	.frequency_min = 48250000,
 	.frequency_max = 863250000,
@@ -74,6 +74,13 @@ static struct dvb_frontend_info at76c651
 	    FE_CAN_MUTE_TS | FE_CAN_QAM_256 | FE_CAN_RECOVER
 };
 
+struct at76c651_state {
+	u8 revision;
+	u8 qam;
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
+
 #if ! defined(__powerpc__)
 static __inline__ int __ilog2(unsigned long x)
 {
@@ -89,60 +96,55 @@ static __inline__ int __ilog2(unsigned l
 }
 #endif
 
-static int at76c651_writereg(struct dvb_i2c_bus *i2c, u8 reg, u8 data)
+static int at76c651_writereg(struct i2c_adapter *i2c, u8 reg, u8 data)
 {
-
 	int ret;
 	u8 buf[] = { reg, data };
-	struct i2c_msg msg = { .addr = 0x1a >> 1, .flags = 0, .buf = buf, .len = 2 };
+	struct i2c_msg msg =
+		{ .addr = 0x1a >> 1, .flags = 0, .buf = buf, .len = 2 };
 
-	ret = i2c->xfer(i2c, &msg, 1);
+	ret = i2c_transfer(i2c, &msg, 1);
 
 	if (ret != 1)
 		dprintk("%s: writereg error "
 			"(reg == 0x%02x, val == 0x%02x, ret == %i)\n",
 			__FUNCTION__, reg, data, ret);
 
-	dvb_delay(10);
+	msleep(10);
 
 	return (ret != 1) ? -EREMOTEIO : 0;
-
 }
 
-static u8 at76c651_readreg(struct dvb_i2c_bus *i2c, u8 reg)
+static u8 at76c651_readreg(struct i2c_adapter *i2c, u8 reg)
 {
-
 	int ret;
-	u8 b0[] = { reg };
-	u8 b1[] = { 0 };
-	struct i2c_msg msg[] = { {.addr =  0x1a >> 1, .flags =  0, .buf =  b0, .len = 1},
-			  {.addr =  0x1a >> 1, .flags =  I2C_M_RD, .buf =  b1, .len = 1} };
+	u8 val;
+	struct i2c_msg msg[] = {
+		{ .addr = 0x1a >> 1, .flags = 0, .buf = &reg, .len = 1 },
+		{ .addr = 0x1a >> 1, .flags = I2C_M_RD, .buf = &val, .len = 1 }
+	};
 
-	ret = i2c->xfer(i2c, msg, 2);
+	ret = i2c_transfer(i2c, msg, 2);
 
 	if (ret != 2)
 		dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
 
-	return b1[0];
-
+	return val;
 }
 
-static int at76c651_reset(struct dvb_i2c_bus *i2c)
+static int at76c651_reset(struct i2c_adapter *i2c)
 {
-
 	return at76c651_writereg(i2c, 0x07, 0x01);
-
 }
 
-static int at76c651_disable_interrupts(struct dvb_i2c_bus *i2c)
+static void at76c651_disable_interrupts(struct i2c_adapter *i2c)
 {
-
-	return at76c651_writereg(i2c, 0x0b, 0x00);
-
+	at76c651_writereg(i2c, 0x0b, 0x00);
 }
 
-static int at76c651_set_auto_config(struct dvb_i2c_bus *i2c)
+static int at76c651_set_auto_config(struct at76c651_state *state)
 {
+	struct i2c_adapter *i2c = state->i2c;
 
 	/*
 	 * Autoconfig
@@ -155,22 +157,22 @@ static int at76c651_set_auto_config(stru
 	 */
 
 	at76c651_writereg(i2c, 0x10, 0x06);
-	at76c651_writereg(i2c, 0x11, ((at76c651_qam == 5) || (at76c651_qam == 7)) ? 0x12 : 0x10);
+	at76c651_writereg(i2c, 0x11, ((state->qam == 5) || (state->qam == 7)) ? 0x12 : 0x10);
 	at76c651_writereg(i2c, 0x15, 0x28);
 	at76c651_writereg(i2c, 0x20, 0x09);
-	at76c651_writereg(i2c, 0x24, ((at76c651_qam == 5) || (at76c651_qam == 7)) ? 0xC0 : 0x90);
+	at76c651_writereg(i2c, 0x24, ((state->qam == 5) || (state->qam == 7)) ? 0xC0 : 0x90);
 	at76c651_writereg(i2c, 0x30, 0x90);
-	if (at76c651_qam == 5)
+	if (state->qam == 5)
 		at76c651_writereg(i2c, 0x35, 0x2A);
 
 	/*
 	 * Initialize A/D-converter
 	 */
 
-	if (at76c651_revision == 0x11) {
+	if (state->revision == 0x11) {
 		at76c651_writereg(i2c, 0x2E, 0x38);
 		at76c651_writereg(i2c, 0x2F, 0x13);
-}
+	}
 
 	at76c651_disable_interrupts(i2c);
 
@@ -181,137 +183,111 @@ static int at76c651_set_auto_config(stru
 	at76c651_reset(i2c);
 
 	return 0;
-
 }
 
-static int at76c651_set_bbfreq(struct dvb_i2c_bus *i2c)
+static void at76c651_set_bbfreq(struct i2c_adapter *i2c)
 {
-
 	at76c651_writereg(i2c, 0x04, 0x3f);
 	at76c651_writereg(i2c, 0x05, 0xee);
-
-	return 0;
-
 }
 
-static int at76c651_switch_tuner_i2c(struct dvb_i2c_bus *i2c, u8 enable)
+static int at76c651_pll_write(struct i2c_adapter *i2c, u8 *buf, size_t len)
 {
-
-	if (enable)
-		return at76c651_writereg(i2c, 0x0c, 0xc2 | 0x01);
-	else
-		return at76c651_writereg(i2c, 0x0c, 0xc2);
-
-}
-
-static int dat7021_write(struct dvb_i2c_bus *i2c, u32 tw)
-{
-
 	int ret;
 	struct i2c_msg msg =
-	    { .addr = 0xc2 >> 1, .flags = 0, .buf = (u8 *) & tw, .len = sizeof (tw) };
+	    { .addr = 0xc2 >> 1, .flags = 0, .buf = buf, .len = len };
 
-#ifdef __LITTLE_ENDIAN
-	tw = __cpu_to_be32(tw);
-#endif
+	at76c651_writereg(i2c, 0x0c, 0xc3);
 
-	at76c651_switch_tuner_i2c(i2c, 1);
+	ret = i2c_transfer(i2c, &msg, 1);
 
-	ret = i2c->xfer(i2c, &msg, 1);
+	at76c651_writereg(i2c, 0x0c, 0xc2);
 
-	at76c651_switch_tuner_i2c(i2c, 0);
-
-	if (ret != 4)
-		return -EFAULT;
-
-	at76c651_reset(i2c);
+	if (ret < 0)
+		return ret;
+	else if (ret != 1)
+		return -EREMOTEIO;
 
 	return 0;
-
 }
 
-static int dat7021_set_tv_freq(struct dvb_i2c_bus *i2c, u32 freq)
+static int tua6010_setfreq(struct i2c_adapter *i2c, u32 freq)
 {
+	u32 div;
+	u8 buf[4];
+	u8 vu, p2, p1, p0;
 
-	u32 dw;
-
-	freq /= 1000;
-
-	if ((freq < 48250) || (freq > 863250))
+	if ((freq < 50000000) || (freq > 900000000))
 		return -EINVAL;
 
-	/*
-	 * formula: dw=0x17e28e06+(freq-346000UL)/8000UL*0x800000
-	 *      or: dw=0x4E28E06+(freq-42000) / 125 * 0x20000
-	 */
-
-	dw = (freq - 42000) * 4096;
-	dw = dw / 125;
-	dw = dw * 32;
+	div = (freq + 36125000) / 62500;
 
-	if (freq > 394000)
-		dw += 0x4E28E85;
+	if (freq > 400000000)
+		vu = 1, p2 = 1, p1 = 0, p0 = 1;
+	else if (freq > 140000000)
+		vu = 0, p2 = 1, p1 = 1, p0 = 0;
 	else
-		dw += 0x4E28E06;
+		vu = 0, p2 = 0, p1 = 1, p0 = 1;
 
-	return dat7021_write(i2c, dw);
+	buf[0] = (div >> 8) & 0x7f;
+	buf[1] = (div >> 0) & 0xff;
+	buf[2] = 0x8e;
+	buf[3] = (vu << 7) | (p2 << 2) | (p1 << 1) | p0;
 
+	return at76c651_pll_write(i2c, buf, 4);
 }
 
-static int at76c651_set_symbolrate(struct dvb_i2c_bus *i2c, u32 symbolrate)
+static int at76c651_set_symbol_rate(struct i2c_adapter *i2c, u32 symbol_rate)
 {
-
 	u8 exponent;
 	u32 mantissa;
 
-	if (symbolrate > 9360000)
+	if (symbol_rate > 9360000)
 		return -EINVAL;
 
 	/*
 	 * FREF = 57800 kHz
-	 * exponent = 10 + floor ( log2 ( symbolrate / FREF ) )
-	 * mantissa = ( symbolrate / FREF) * ( 1 << ( 30 - exponent ) )
+	 * exponent = 10 + floor (log2(symbol_rate / FREF))
+	 * mantissa = (symbol_rate / FREF) * (1 << (30 - exponent))
 	 */
 
-	exponent = __ilog2((symbolrate << 4) / 903125);
-	mantissa = ((symbolrate / 3125) * (1 << (24 - exponent))) / 289;
+	exponent = __ilog2((symbol_rate << 4) / 903125);
+	mantissa = ((symbol_rate / 3125) * (1 << (24 - exponent))) / 289;
 
 	at76c651_writereg(i2c, 0x00, mantissa >> 13);
 	at76c651_writereg(i2c, 0x01, mantissa >> 5);
 	at76c651_writereg(i2c, 0x02, (mantissa << 3) | exponent);
 
 	return 0;
-
 }
 
-static int at76c651_set_qam(struct dvb_i2c_bus *i2c, fe_modulation_t qam)
+static int at76c651_set_qam(struct at76c651_state *state, fe_modulation_t qam)
 {
-
 	switch (qam) {
 	case QPSK:
-		at76c651_qam = 0x02;
+		state->qam = 0x02;
 		break;
 	case QAM_16:
-		at76c651_qam = 0x04;
+		state->qam = 0x04;
 		break;
 	case QAM_32:
-		at76c651_qam = 0x05;
+		state->qam = 0x05;
 		break;
 	case QAM_64:
-		at76c651_qam = 0x06;
+		state->qam = 0x06;
 		break;
 	case QAM_128:
-		at76c651_qam = 0x07;
+		state->qam = 0x07;
 		break;
 	case QAM_256:
-		at76c651_qam = 0x08;
+		state->qam = 0x08;
 		break;
 #if 0
 	case QAM_512:
-		at76c651_qam = 0x09;
+		state->qam = 0x09;
 		break;
 	case QAM_1024:
-		at76c651_qam = 0x0A;
+		state->qam = 0x0A;
 		break;
 #endif
 	default:
@@ -319,14 +295,12 @@ static int at76c651_set_qam(struct dvb_i
 
 	}
 
-	return at76c651_writereg(i2c, 0x03, at76c651_qam);
-
+	return at76c651_writereg(state->i2c, 0x03, state->qam);
 }
 
-static int at76c651_set_inversion(struct dvb_i2c_bus *i2c,
-		       fe_spectral_inversion_t inversion)
+static int at76c651_set_inversion(struct i2c_adapter *i2c,
+				  fe_spectral_inversion_t inversion)
 {
-
 	u8 feciqinv = at76c651_readreg(i2c, 0x60);
 
 	switch (inversion) {
@@ -348,109 +322,102 @@ static int at76c651_set_inversion(struct
 	}
 
 	return at76c651_writereg(i2c, 0x60, feciqinv);
-
 }
 
-static int at76c651_set_parameters(struct dvb_i2c_bus *i2c,
-			struct dvb_frontend_parameters *p)
+static int at76c651_set_parameters(struct at76c651_state *state,
+				   struct dvb_frontend_parameters *p)
 {
+	struct i2c_adapter *i2c = state->i2c;
+	int ret;
 
-	dat7021_set_tv_freq(i2c, p->frequency);
-	at76c651_set_symbolrate(i2c, p->u.qam.symbol_rate);
-	at76c651_set_inversion(i2c, p->inversion);
-	at76c651_set_auto_config(i2c);
-        at76c651_reset(i2c);
+	if ((ret = tua6010_setfreq(i2c, p->frequency)))
+		return ret;
 
-	return 0;
+	if ((ret = at76c651_set_symbol_rate(i2c, p->u.qam.symbol_rate)))
+		return ret;
 
+	if ((ret = at76c651_set_inversion(i2c, p->inversion)))
+		return ret;
+
+	return at76c651_set_auto_config(state);
 }
 
-static int at76c651_set_defaults(struct dvb_i2c_bus *i2c)
+static int at76c651_set_defaults(struct at76c651_state *state)
 {
+	struct i2c_adapter *i2c = state->i2c;
 
-	at76c651_set_symbolrate(i2c, 6900000);
-	at76c651_set_qam(i2c, QAM_64);
+	at76c651_set_symbol_rate(i2c, 6900000);
+	at76c651_set_qam(state, QAM_64);
 	at76c651_set_bbfreq(i2c);
-	at76c651_set_auto_config(i2c);
+	at76c651_set_auto_config(state);
 
 	return 0;
-
 }
 
 static int at76c651_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
+	struct at76c651_state *state = fe->data;
+	struct i2c_adapter *i2c = state->i2c;
 
 	switch (cmd) {
-
 	case FE_GET_INFO:
-		memcpy(arg, &at76c651_info, sizeof (struct dvb_frontend_info));
+		memcpy(arg, &at76c651_info, sizeof(struct dvb_frontend_info));
 		break;
 
 	case FE_READ_STATUS:
-		{
-
-			fe_status_t *status = (fe_status_t *) arg;
-			u8 sync;
-
-			/*
-			 * Bits: FEC, CAR, EQU, TIM, AGC2, AGC1, ADC, PLL (PLL=0) 
-			 */
-			sync = at76c651_readreg(fe->i2c, 0x80);
-
-			*status = 0;
-
-			if (sync & (0x04 | 0x10))	/* AGC1 || TIM */
-				*status |= FE_HAS_SIGNAL;
-
-			if (sync & 0x10)	/* TIM */
-				*status |= FE_HAS_CARRIER;
-
-			if (sync & 0x80)	/* FEC */
-				*status |= FE_HAS_VITERBI;
-
-			if (sync & 0x40)	/* CAR */
-				*status |= FE_HAS_SYNC;
-
-			if ((sync & 0xF0) == 0xF0)	/* TIM && EQU && CAR && FEC */
-				*status |= FE_HAS_LOCK;
-
-			break;
+	{
+		fe_status_t *status = arg;
+		u8 sync;
 
-		}
+		/*
+		 * Bits: FEC, CAR, EQU, TIM, AGC2, AGC1, ADC, PLL (PLL=0) 
+		 */
+		sync = at76c651_readreg(i2c, 0x80);
+
+		*status = 0;
+
+		if (sync & (0x04 | 0x10))	/* AGC1 || TIM */
+			*status |= FE_HAS_SIGNAL;
+		if (sync & 0x10)		/* TIM */
+			*status |= FE_HAS_CARRIER;
+		if (sync & 0x80)		/* FEC */
+			*status |= FE_HAS_VITERBI;
+		if (sync & 0x40)		/* CAR */
+			*status |= FE_HAS_SYNC;
+		if ((sync & 0xF0) == 0xF0)	/* TIM && EQU && CAR && FEC */
+			*status |= FE_HAS_LOCK;
+		break;
+	}
 
 	case FE_READ_BER:
-		{
-			u32 *ber = (u32 *) arg;
-
-			*ber = (at76c651_readreg(fe->i2c, 0x81) & 0x0F) << 16;
-			*ber |= at76c651_readreg(fe->i2c, 0x82) << 8;
-			*ber |= at76c651_readreg(fe->i2c, 0x83);
-			*ber *= 10;
-
-			break;
-		}
+	{
+		u32 *ber = arg;
+		*ber = (at76c651_readreg(i2c, 0x81) & 0x0F) << 16;
+		*ber |= at76c651_readreg(i2c, 0x82) << 8;
+		*ber |= at76c651_readreg(i2c, 0x83);
+		*ber *= 10;
+		break;
+	}
 
 	case FE_READ_SIGNAL_STRENGTH:
-		{
-			u8 gain = ~at76c651_readreg(fe->i2c, 0x91);
-
-			*(u16 *) arg = (gain << 8) | gain;
-			break;
-		}
+	{
+		u8 gain = ~at76c651_readreg(i2c, 0x91);
+		*(u16 *)arg = (gain << 8) | gain;
+		break;
+	}
 
 	case FE_READ_SNR:
-		*(u16 *) arg =
-		    0xFFFF -
-		    ((at76c651_readreg(fe->i2c, 0x8F) << 8) |
-		     at76c651_readreg(fe->i2c, 0x90));
+		*(u16 *)arg = 0xFFFF -
+		    ((at76c651_readreg(i2c, 0x8F) << 8) |
+		     at76c651_readreg(i2c, 0x90));
 		break;
 
 	case FE_READ_UNCORRECTED_BLOCKS:
-		*(u32 *) arg = at76c651_readreg(fe->i2c, 0x82);
+		*(u32 *)arg = at76c651_readreg(i2c, 0x82);
 		break;
 
 	case FE_SET_FRONTEND:
-		return at76c651_set_parameters(fe->i2c, arg);
+		return at76c651_set_parameters(state, arg);
 
 	case FE_GET_FRONTEND:
 		break;
@@ -459,77 +426,145 @@ static int at76c651_ioctl(struct dvb_fro
 		break;
 
 	case FE_INIT:
-		return at76c651_set_defaults(fe->i2c);
+		return at76c651_set_defaults(state);
 
 	case FE_GET_TUNE_SETTINGS:
 	{
-	        struct dvb_frontend_tune_settings* fesettings = (struct dvb_frontend_tune_settings*) arg;
+	        struct dvb_frontend_tune_settings *fesettings = arg;
 	        fesettings->min_delay_ms = 50;
 	        fesettings->step_size = 0;
 	        fesettings->max_drift = 0;
-	        return 0;
-	}	    
+		break;
+	}
 
 	default:
 		return -ENOIOCTLCMD;
 	}
 
 	return 0;
-
 }
 
-static int at76c651_attach(struct dvb_i2c_bus *i2c, void **data)
-{
-	if ( (at76c651_readreg(i2c, 0x0E) != 0x65) ||
-	     ( ( (at76c651_revision = at76c651_readreg(i2c, 0x0F)) & 0xFE) != 0x10) )
+static struct i2c_client client_template;
+
+static int attach_adapter(struct i2c_adapter *adapter)
 {
-		dprintk("no AT76C651(B) found\n");
+	struct at76c651_state *state;
+	struct i2c_client *client;
+	int ret;
+
+	if (at76c651_readreg(adapter, 0x0E) != 0x65)
+		return -ENODEV;
+
+	if (!(state = kmalloc(sizeof(struct at76c651_state), GFP_KERNEL)))
+		return -ENOMEM;
+
+	state->i2c = adapter;
+	state->revision = at76c651_readreg(adapter, 0x0F) & 0xFE;
+
+	switch (state->revision) {
+	case 0x10:
+		at76c651_info.name[14] = 'A';
+		break;
+	case 0x11:
+		at76c651_info.name[14] = 'B';
+		break;
+	default:
+		kfree(state);
 		return -ENODEV;
 	}
 
-	if (at76c651_revision == 0x10)
-	{
-		dprintk("AT76C651A found\n");
-		strcpy(at76c651_info.name,"Atmel AT76C651A with DAT7021");
-		}
-	else
-	{
-		strcpy(at76c651_info.name,"Atmel AT76C651B with DAT7021");
-		dprintk("AT76C651B found\n");
+	if (!(client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = 0x1a >> 1;
+	i2c_set_clientdata(client, state);
+
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(state);
+		kfree(client);
+		return ret;
 	}
 
-	at76c651_set_defaults(i2c);
+	BUG_ON(!state->dvb);
 
-	return dvb_register_frontend(at76c651_ioctl, i2c, NULL, &at76c651_info);
+	ret = dvb_register_frontend(at76c651_ioctl, state->dvb, state,
+					&at76c651_info, THIS_MODULE);
+	if (ret) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
 
+	return 0;
 }
 
-static void at76c651_detach(struct dvb_i2c_bus *i2c, void *data)
+static int detach_client(struct i2c_client *client)
 {
+	struct at76c651_state *state = i2c_get_clientdata(client);
 
-	dvb_unregister_frontend(at76c651_ioctl, i2c);
+	dvb_unregister_frontend(at76c651_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
 
+	return 0;
 }
 
-static int __init at76c651_init(void)
+static int command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
+	struct at76c651_state *state = i2c_get_clientdata(client);
+
+	switch (cmd) {
+	case FE_REGISTER:
+		state->dvb = arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
 
-	return dvb_register_i2c_device(THIS_MODULE, at76c651_attach,
-				       at76c651_detach);
+static struct i2c_driver driver = {
+	.owner		= THIS_MODULE,
+	.name		= FRONTEND_NAME,
+	.id		= I2C_DRIVERID_DVBFE_AT76C651,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= attach_adapter,
+	.detach_client	= detach_client,
+	.command	= command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags		= I2C_CLIENT_ALLOW_USE,
+	.driver		= &driver,
+};
 
+static int __init at76c651_init(void)
+{
+	return i2c_add_driver(&driver);
 }
 
 static void __exit at76c651_exit(void)
 {
-
-	dvb_unregister_i2c_device(at76c651_attach);
-
+	if (i2c_del_driver(&driver))
+		printk(KERN_ERR "at76c651: driver deregistration failed.\n");
 }
 
 module_init(at76c651_init);
 module_exit(at76c651_exit);
 
-MODULE_DESCRIPTION("at76c651/dat7021 dvb-c frontend driver");
+MODULE_DESCRIPTION("at76c651/tua6010xs dvb-c frontend driver");
 MODULE_AUTHOR("Andreas Oberritter <obi@linuxtv.org>");
 MODULE_LICENSE("GPL");
-MODULE_PARM(debug, "i");
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/cx22702.c linux/drivers/media/dvb/frontends/cx22702.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/cx22702.c	2004-09-17 14:56:38.793602179 +0200
+++ linux/drivers/media/dvb/frontends/cx22702.c	2004-09-17 14:56:38.794601992 +0200
@@ -0,0 +1,900 @@
+/*
+    Conexant 22702 DVB OFDM frontend driver
+
+    based on:
+        Alps TDMB7 DVB OFDM frontend driver
+
+    Copyright (C) 2001-2002 Convergence Integrated Media GmbH
+	  Holger Waechtler <holger@convergence.de>
+
+    Copyright (C) 2004 Steven Toth <steve@toth.demon.co.uk>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/    
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include "dvb_frontend.h"
+
+#define FRONTEND_NAME "dvbfe_cx22702"
+
+#define I2C_EEPROM_SLAVE_ADDR 0x50
+
+#define PLLTYPE_DTT7592 1
+#define PLLTYPE_DTT7595 2
+#define PLLTYPE_DTT7579 3
+
+static int debug = 0;
+
+#define dprintk	if (debug) printk
+
+static struct dvb_frontend_info cx22702_info = {
+	.name			= "CX22702 Demod Thomson 759x/7579 PLL",
+	.type			= FE_OFDM,
+	.frequency_min		= 177000000,
+	.frequency_max		= 858000000,
+	.frequency_stepsize	= 166666,
+	.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+	FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+	FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+	FE_CAN_HIERARCHY_AUTO | FE_CAN_GUARD_INTERVAL_AUTO | 
+	FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER
+};
+
+struct cx22702_state {
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+	struct dvb_frontend_info cx22702_info;
+   	char pll_type;
+	int pll_addr;
+	int demod_addr;
+	u8 prevUCBlocks;
+};
+
+/* Register values to initialise the demod */
+static u8 init_tab [] = {
+	0x00, 0x00, /* Stop aquisition */
+	0x0B, 0x06,
+	0x09, 0x01,
+	0x0D, 0x41,
+	0x16, 0x32,
+	0x20, 0x0A,
+	0x21, 0x17,
+	0x24, 0x3e,
+	0x26, 0xff,
+	0x27, 0x10,
+	0x28, 0x00,
+	0x29, 0x00,
+	0x2a, 0x10,
+	0x2b, 0x00,
+	0x2c, 0x10,
+	0x2d, 0x00,
+	0x48, 0xd4,
+	0x49, 0x56,
+	0x6b, 0x1e,
+	0xc8, 0x02,
+	0xf8, 0x02,
+	0xf9, 0x00,
+	0xfa, 0x00,
+	0xfb, 0x00,
+	0xfc, 0x00,
+	0xfd, 0x00,
+};
+
+static struct i2c_client client_template;
+
+static int cx22702_writereg (struct i2c_adapter *i2c, int demod_addr, u8 reg, u8 data)
+{
+	int ret;
+	u8 buf [] = { reg, data };
+	struct i2c_msg msg = { .addr = demod_addr, .flags = 0, .buf = buf, .len = 2 };
+
+	ret = i2c_transfer(i2c, &msg, 1);
+
+	if (ret != 1) 
+		printk("%s: writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\n",
+			__FUNCTION__, reg, data, ret);
+
+	return (ret != 1) ? -1 : 0;
+}
+
+static u8 cx22702_readreg (struct i2c_adapter *i2c, int demod_addr, u8 reg)
+{
+	int ret;
+	u8 b0 [] = { reg };
+	u8 b1 [] = { 0 };
+
+	struct i2c_msg msg [] = {
+		{ .addr = demod_addr, .flags = 0, .buf = b0, .len = 1 },
+		{ .addr = demod_addr, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
+        
+	ret = i2c_transfer(i2c, msg, 2);
+        
+	if (ret != 2) 
+		printk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
+
+	return b1[0];
+}
+
+static int pll_readreg(struct i2c_adapter *i2c, int pll_addr, int demod_addr, u8 reg)
+{
+	u8 b0 [] = { reg };
+	u8 b1 [] = { 0 };
+
+	struct i2c_msg msg [] = {
+		{ .addr = pll_addr, .flags = 0,        .buf = b0, .len = 1 },
+		{ .addr = pll_addr, .flags = I2C_M_RD, .buf = b1, .len = 1 }
+	};
+
+	cx22702_writereg (i2c, demod_addr, 0x0D, cx22702_readreg(i2c,demod_addr,0x0D) &0xfe); // Enable PLL bus
+	if (i2c_transfer(i2c, msg, 2) != 2) {
+		printk ("%s i2c pll request failed\n", __FUNCTION__);
+		cx22702_writereg (i2c, demod_addr, 0x0D, cx22702_readreg(i2c,demod_addr,0x0D) | 1); // Disable PLL bus
+		return -ENODEV;
+	}
+	cx22702_writereg (i2c, demod_addr, 0x0D, cx22702_readreg(i2c,demod_addr,0x0D) | 1); // Disable PLL bus
+
+	return b1[0];
+}
+
+static int pll_write (struct i2c_adapter *i2c, int pll_addr, int demod_addr, u8 data [4])
+{
+	int ret=0;
+	struct i2c_msg msg = { .addr = pll_addr, .flags = 0, .buf = data, .len = 4 };
+
+	cx22702_writereg (i2c, demod_addr, 0x0D, cx22702_readreg(i2c,demod_addr,0x0D) &0xfe);  // Enable PLL bus
+	ret = i2c_transfer(i2c, &msg, 1);
+	cx22702_writereg (i2c, demod_addr, 0x0D, cx22702_readreg(i2c,demod_addr,0x0D) | 1); // Disable PLL bus
+
+	if (ret != 1)
+		printk("%s: i/o error (addr == 0x%02x, ret == %i)\n", __FUNCTION__, msg.addr, ret);
+
+	return (ret != 1) ? -1 : 0;
+}
+
+static int pll_dtt759x_set_tv_freq (struct i2c_adapter *i2c, struct cx22702_state *state, u32 freq, int bandwidth)
+{
+	int ret;
+
+	u32 div = (freq + 36166667) / 166666;
+
+	/* dividerhigh, dividerlow, control, bandwidth switch tuner args */
+	unsigned char buf [4] = {
+		(div >> 8) & 0x7f,
+		div & 0xff,
+		0x84,
+		0x00
+	};
+
+	if(freq < 470000000) {
+		buf[3] = 0x02;
+	} else {
+		buf[3] = 0x08;
+	}
+
+	if(bandwidth == BANDWIDTH_7_MHZ) {
+		buf[3] |= 0x10;
+	}
+
+	// Now compensate for the charge pump osc
+	if(freq <= 264000000) {
+		buf[2] = buf[2] | 0x30;
+	} else if (freq <= 735000000) {
+		buf[2] = buf[2] | 0x38;
+	} else if (freq <= 835000000) {
+		buf[2] = buf[2] | 0x70;
+	} else if (freq <= 896000000) {
+		buf[2] = buf[2] | 0x78;
+	}	
+   
+	dprintk ("%s: freq == %i, div == 0x%04x\n", __FUNCTION__, (int) freq, (int) div);
+   
+	ret= pll_write (i2c, state->pll_addr, state->demod_addr, buf);
+	if(ret<0) {
+		dprintk ("%s: first pll_write failed\n",__FUNCTION__);
+		return ret;
+	}
+
+	/* Set the AGC during search */
+	buf[2]=(buf[2] & 0xc7) | 0x18;
+	buf[3]=0xa0;
+	ret=pll_write (i2c, state->pll_addr, state->demod_addr, buf);
+	if(ret<0) {
+		dprintk ("%s: second pll_write failed\n",__FUNCTION__);
+		return ret;
+	}
+
+	/* Tuner needs a small amount of time */
+	msleep(100);
+
+	/* Set the AGC post-search */   
+	buf[3]=0x20;
+	ret=pll_write (i2c, state->pll_addr, state->demod_addr, buf);
+	if(ret<0) {
+		dprintk ("%s: third pll_write failed\n",__FUNCTION__);
+		return ret;
+	}
+
+	return ret;
+
+}
+
+static int pll_dtt7579_set_tv_freq (struct i2c_adapter *i2c, struct cx22702_state *state, u32 freq, int bandwidth)
+{
+	int ret;
+
+	u32 div = (freq + 36166667) / 166666;
+
+	/* dividerhigh, dividerlow */
+	unsigned char buf [4] = {
+		div >> 8,
+		div & 0xff,
+		0x00,
+		0x00
+	};
+
+	// FIXME: bandwidth setting unknown
+   
+	// Now compensate for the charge pump osc
+	if(freq <= 506000000) {
+		buf[2] = 0xb4;
+	   	buf[3] = 0x02;
+	} else if (freq <= 735000000) {
+   		buf[2] = 0xbc;
+	   	buf[3] = 0x08;
+	} else if (freq <= 835000000) {
+      		buf[2] = 0xf4;
+	   	buf[3] = 0x08;
+	} else if (freq <= 896000000) {
+		buf[2] = 0xfc;
+	   	buf[3] = 0x08;
+	}
+
+	dprintk ("%s: freq == %i, div == 0x%04x\n", __FUNCTION__, (int) freq, (int) div);
+
+	ret= pll_write (i2c, state->pll_addr, state->demod_addr, buf);
+	if(ret<0) {
+		dprintk ("%s: first pll_write failed\n",__FUNCTION__);
+		return ret;
+	}
+
+	/* Set the AGC to search */
+	buf[2]=(buf[2] & 0xdc) | 0x9c;
+	buf[3]=0xa0;
+	ret=pll_write (i2c, state->pll_addr, state->demod_addr, buf);
+	if(ret<0) {
+		dprintk ("%s: second pll_write failed\n",__FUNCTION__);
+		return ret;
+	}
+
+	return ret;
+
+}
+
+/* Reset the demod hardware and reset all of the configuration registers
+   to a default state. */
+static int cx22702_init (struct i2c_adapter *i2c, struct cx22702_state *state)
+{
+	int i;
+
+	cx22702_writereg (i2c, state->demod_addr, 0x00, 0x02);
+
+	msleep(10);
+	
+	for (i=0; i<sizeof(init_tab); i+=2)
+		cx22702_writereg (i2c, state->demod_addr, init_tab[i], init_tab[i+1]);
+
+	return 0;	
+}
+
+static int cx22702_set_inversion (struct i2c_adapter *i2c, struct cx22702_state *state, int inversion)
+{
+	u8 val;
+
+	switch (inversion) {
+
+		case INVERSION_AUTO:
+			return -EOPNOTSUPP;
+
+		case INVERSION_ON:
+			val = cx22702_readreg (i2c, state->demod_addr, 0x0C);
+			return cx22702_writereg (i2c, state->demod_addr, 0x0C, val | 0x01);
+
+		case INVERSION_OFF:
+			val = cx22702_readreg (i2c, state->demod_addr, 0x0C);
+			return cx22702_writereg (i2c, state->demod_addr, 0x0C, val & 0xfe);
+
+		default:
+			return -EINVAL;
+
+	}
+
+}
+
+/* Talk to the demod, set the FEC, GUARD, QAM settings etc */
+static int cx22702_set_tps (struct i2c_adapter *i2c, struct cx22702_state *state,
+			    struct dvb_frontend_parameters *p)
+{
+	u8 val;
+
+	/* set PLL */
+	switch(state->pll_type) {
+	case PLLTYPE_DTT7592:
+	case PLLTYPE_DTT7595:
+		pll_dtt759x_set_tv_freq (i2c, state, p->frequency, p->u.ofdm.bandwidth);
+		break;
+
+	case PLLTYPE_DTT7579:
+		pll_dtt7579_set_tv_freq (i2c, state, p->frequency, p->u.ofdm.bandwidth);
+		break;
+	}
+   
+	/* set inversion */
+	cx22702_set_inversion (i2c, state, p->inversion);
+
+	/* set bandwidth */
+	switch(p->u.ofdm.bandwidth) {
+	case BANDWIDTH_6_MHZ:
+		cx22702_writereg(i2c, state->demod_addr, 0x0C, (cx22702_readreg(i2c, state->demod_addr, 0x0C) & 0xcf) | 0x20 );
+		break;
+	case BANDWIDTH_7_MHZ:
+		cx22702_writereg(i2c, state->demod_addr, 0x0C, (cx22702_readreg(i2c, state->demod_addr, 0x0C) & 0xcf) | 0x10 );
+		break;
+	case BANDWIDTH_8_MHZ:
+		cx22702_writereg(i2c, state->demod_addr, 0x0C, cx22702_readreg(i2c, state->demod_addr, 0x0C) &0xcf );
+		break;
+	default:
+		dprintk ("%s: invalid bandwidth\n",__FUNCTION__);
+		return -EINVAL;
+	}
+
+   
+	p->u.ofdm.code_rate_LP = FEC_AUTO; //temp hack as manual not working
+     
+	/* use auto configuration? */
+	if((p->u.ofdm.hierarchy_information==HIERARCHY_AUTO) || 
+	   (p->u.ofdm.constellation==QAM_AUTO) ||
+	   (p->u.ofdm.code_rate_HP==FEC_AUTO) || 
+	   (p->u.ofdm.code_rate_LP==FEC_AUTO) || 
+	   (p->u.ofdm.guard_interval==GUARD_INTERVAL_AUTO) || 
+	   (p->u.ofdm.transmission_mode==TRANSMISSION_MODE_AUTO) ) {
+
+		/* TPS Source - use hardware driven values */
+		cx22702_writereg(i2c, state->demod_addr, 0x06, 0x10);
+		cx22702_writereg(i2c, state->demod_addr, 0x07, 0x9);
+		cx22702_writereg(i2c, state->demod_addr, 0x08, 0xC1);
+		cx22702_writereg(i2c, state->demod_addr, 0x0B, cx22702_readreg(i2c, state->demod_addr, 0x0B) & 0xfc );
+		cx22702_writereg(i2c, state->demod_addr, 0x0C, (cx22702_readreg(i2c, state->demod_addr, 0x0C) & 0xBF) | 0x40 );
+		cx22702_writereg(i2c, state->demod_addr, 0x00, 0x01); /* Begin aquisition */
+		printk("%s: Autodetecting\n",__FUNCTION__);
+		return 0;
+	}
+
+   	/* manually programmed values */
+	val=0;
+	switch(p->u.ofdm.constellation) {
+		case   QPSK: val = (val&0xe7); break;
+		case QAM_16: val = (val&0xe7)|0x08; break;
+		case QAM_64: val = (val&0xe7)|0x10; break;
+		default:
+			dprintk ("%s: invalid constellation\n",__FUNCTION__);
+			return -EINVAL;
+	}
+	switch(p->u.ofdm.hierarchy_information) {
+		case HIERARCHY_NONE: val = (val&0xf8); break;
+		case    HIERARCHY_1: val = (val&0xf8)|1; break;
+		case    HIERARCHY_2: val = (val&0xf8)|2; break;
+		case    HIERARCHY_4: val = (val&0xf8)|3; break;
+		default:
+			dprintk ("%s: invalid hierarchy\n",__FUNCTION__);
+			return -EINVAL;
+	}
+	cx22702_writereg (i2c, state->demod_addr, 0x06, val);
+
+	val=0;
+	switch(p->u.ofdm.code_rate_HP) {
+		case FEC_NONE:
+		case FEC_1_2: val = (val&0xc7); break;
+		case FEC_2_3: val = (val&0xc7)|0x08; break;
+		case FEC_3_4: val = (val&0xc7)|0x10; break;
+		case FEC_5_6: val = (val&0xc7)|0x18; break;
+		case FEC_7_8: val = (val&0xc7)|0x20; break;
+		default:
+			dprintk ("%s: invalid code_rate_HP\n",__FUNCTION__);
+			return -EINVAL;
+	}
+	switch(p->u.ofdm.code_rate_LP) {
+		case FEC_NONE:
+		case FEC_1_2: val = (val&0xf8); break;
+		case FEC_2_3: val = (val&0xf8)|1; break;
+		case FEC_3_4: val = (val&0xf8)|2; break;
+		case FEC_5_6: val = (val&0xf8)|3; break;
+		case FEC_7_8: val = (val&0xf8)|4; break;
+		default:
+			dprintk ("%s: invalid code_rate_LP\n",__FUNCTION__);
+			return -EINVAL;
+	}
+	cx22702_writereg (i2c, state->demod_addr, 0x07, val);
+
+	val=0;
+	switch(p->u.ofdm.guard_interval) {
+		case GUARD_INTERVAL_1_32: val = (val&0xf3); break;
+		case GUARD_INTERVAL_1_16: val = (val&0xf3)|0x04; break;
+		case  GUARD_INTERVAL_1_8: val = (val&0xf3)|0x08; break;
+		case  GUARD_INTERVAL_1_4: val = (val&0xf3)|0x0c; break;
+		default:
+			dprintk ("%s: invalid guard_interval\n",__FUNCTION__);
+			return -EINVAL;
+	}
+	switch(p->u.ofdm.transmission_mode) {
+		case TRANSMISSION_MODE_2K: val = (val&0xfc); break;
+		case TRANSMISSION_MODE_8K: val = (val&0xfc)|1; break;
+		default:
+			dprintk ("%s: invalid transmission_mode\n",__FUNCTION__);
+			return -EINVAL;
+	}
+	cx22702_writereg (i2c, state->demod_addr, 0x08, val);
+	cx22702_writereg(i2c, state->demod_addr, 0x0B, (cx22702_readreg(i2c, state->demod_addr, 0x0B) & 0xfc) | 0x02 );
+	cx22702_writereg(i2c, state->demod_addr, 0x0C, (cx22702_readreg(i2c, state->demod_addr, 0x0C) & 0xBF) | 0x40 );
+
+	/* Begin channel aquisition */
+	cx22702_writereg(i2c, state->demod_addr, 0x00, 0x01);
+
+	return 0;
+}
+
+/* Retrieve the demod settings */
+static int cx22702_get_tps (struct i2c_adapter *i2c, struct cx22702_state *state,
+			    struct dvb_ofdm_parameters *p)
+{
+	u8 val;
+
+	/* Make sure the TPS regs are valid */
+	if (!(cx22702_readreg(i2c, state->demod_addr, 0x0A) & 0x20))
+		return -EAGAIN;
+
+	val = cx22702_readreg (i2c, state->demod_addr, 0x01);
+	switch( (val&0x18)>>3) {
+		case 0: p->constellation =   QPSK; break;
+		case 1: p->constellation = QAM_16; break;
+		case 2: p->constellation = QAM_64; break;
+	}
+	switch( val&0x07 ) {
+		case 0: p->hierarchy_information = HIERARCHY_NONE; break;
+		case 1: p->hierarchy_information =    HIERARCHY_1; break;
+		case 2: p->hierarchy_information =    HIERARCHY_2; break;
+		case 3: p->hierarchy_information =    HIERARCHY_4; break;
+	}
+
+
+	val = cx22702_readreg (i2c, state->demod_addr, 0x02);
+	switch( (val&0x38)>>3 ) {
+		case 0: p->code_rate_HP = FEC_1_2; break;
+		case 1: p->code_rate_HP = FEC_2_3; break;
+		case 2: p->code_rate_HP = FEC_3_4; break;
+		case 3: p->code_rate_HP = FEC_5_6; break;
+		case 4: p->code_rate_HP = FEC_7_8; break;
+	}
+	switch( val&0x07 ) {
+		case 0: p->code_rate_LP = FEC_1_2; break;
+		case 1: p->code_rate_LP = FEC_2_3; break;
+		case 2: p->code_rate_LP = FEC_3_4; break;
+		case 3: p->code_rate_LP = FEC_5_6; break;
+		case 4: p->code_rate_LP = FEC_7_8; break;
+	}
+
+
+	val = cx22702_readreg (i2c, state->demod_addr, 0x03);
+	switch( (val&0x0c)>>2 ) {
+		case 0: p->guard_interval = GUARD_INTERVAL_1_32; break;
+		case 1: p->guard_interval = GUARD_INTERVAL_1_16; break;
+		case 2: p->guard_interval =  GUARD_INTERVAL_1_8; break;
+		case 3: p->guard_interval =  GUARD_INTERVAL_1_4; break;
+	}
+	switch( val&0x03 ) {
+		case 0: p->transmission_mode = TRANSMISSION_MODE_2K; break;
+		case 1: p->transmission_mode = TRANSMISSION_MODE_8K; break;
+	}
+
+	return 0;
+}
+
+static int cx22702_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
+{
+	struct cx22702_state *state = fe->data;
+	struct i2c_adapter *i2c = state->i2c;
+	u8 reg0A;
+	u8 reg23;
+	u8 ucblocks;
+
+	switch (cmd) {
+		case FE_GET_INFO:
+			memcpy (arg, &state->cx22702_info, sizeof(struct dvb_frontend_info));
+			break;
+
+		case FE_READ_STATUS:
+		{
+			fe_status_t *status = (fe_status_t *) arg;
+
+			*status = 0;
+
+			reg0A = cx22702_readreg (i2c, state->demod_addr, 0x0A);
+			reg23 = cx22702_readreg (i2c, state->demod_addr, 0x23);
+
+			dprintk ("%s: status demod=0x%02x agc=0x%02x\n"
+				,__FUNCTION__,reg0A,reg23);
+
+			if(reg0A & 0x10) {
+				*status |= FE_HAS_LOCK;
+				*status |= FE_HAS_VITERBI;
+				*status |= FE_HAS_SYNC;
+			}
+
+			if(reg0A & 0x20) 
+				*status |= FE_HAS_CARRIER;
+
+			if(reg23 < 0xf0) 
+				*status |= FE_HAS_SIGNAL;
+
+			break;
+
+		}
+
+		case FE_READ_BER:
+			if(cx22702_readreg (i2c, state->demod_addr, 0xE4) & 0x02) {
+				/* Realtime statistics */
+				*((u32*) arg) = (cx22702_readreg (i2c, state->demod_addr, 0xDE) & 0x7F) << 7
+					| (cx22702_readreg (i2c, state->demod_addr, 0xDF)&0x7F);
+			} else {
+				/* Averagtine statistics */
+				*((u32*) arg) = (cx22702_readreg (i2c, state->demod_addr, 0xDE) & 0x7F) << 7
+					| cx22702_readreg (i2c, state->demod_addr, 0xDF);
+			}
+			break;
+
+		case FE_READ_SIGNAL_STRENGTH:
+		{
+			u16 ss = cx22702_readreg (i2c, state->demod_addr, 0x23);
+			*((u16*) arg) = ss;
+			break;
+		}
+
+		/* We don't have an register for this */
+		/* We'll take the inverse of the BER register */
+		case FE_READ_SNR:
+		{
+			u16 rs_ber=0;
+			if(cx22702_readreg (i2c, state->demod_addr, 0xE4) & 0x02) {
+				/* Realtime statistics */
+				rs_ber = (cx22702_readreg (i2c, state->demod_addr, 0xDE) & 0x7F) << 7
+					| (cx22702_readreg (i2c, state->demod_addr, 0xDF)& 0x7F);
+			} else {
+				/* Averagine statistics */
+				rs_ber = (cx22702_readreg (i2c, state->demod_addr, 0xDE) & 0x7F) << 8
+					| cx22702_readreg (i2c, state->demod_addr, 0xDF);
+			}
+			*((u16*) arg) = ~rs_ber;
+			break;
+		}
+
+		case FE_READ_UNCORRECTED_BLOCKS: 
+			/* RS Uncorrectable Packet Count then reset */
+			ucblocks = cx22702_readreg (i2c, state->demod_addr, 0xE3);
+			if (state->prevUCBlocks < ucblocks) *((u32*) arg) = (ucblocks - state->prevUCBlocks);
+			else *((u32*) arg) = state->prevUCBlocks - ucblocks;
+	   		state->prevUCBlocks = ucblocks;
+			break;
+
+		case FE_SET_FRONTEND:
+		{
+			struct dvb_frontend_parameters *p = arg;
+			int ret;
+
+			if((ret=cx22702_set_tps (i2c, state, p))<0) {
+				dprintk ("%s: set_tps failed ret=%d\n",__FUNCTION__,ret);
+				return ret;
+			}
+			break;
+		}
+
+		case FE_GET_FRONTEND:
+		{
+			struct dvb_frontend_parameters *p = arg;
+			u8 reg0C = cx22702_readreg (i2c, state->demod_addr, 0x0C);
+		
+			p->inversion = reg0C & 0x1 ? INVERSION_ON : INVERSION_OFF;
+			return cx22702_get_tps (i2c, state, &p->u.ofdm);
+		}
+
+		case FE_INIT:
+			return cx22702_init (i2c, state);
+
+		default:
+			return -EOPNOTSUPP;
+	};
+
+	return 0;
+}
+
+/* Validate the eeprom contents, make sure content look ok.
+   Get the eeprom data. */
+static int cx22702_validate_eeprom(struct i2c_adapter *i2c, int* minfreq, int* pll_type, int* pll_addr, int* demod_addr)
+{
+	u8 b0 [] = { 0 };
+	u8 b1 [128];
+	u32 model=0;
+	u8 tuner=0;
+	int i,j;
+
+	struct i2c_msg msg [] = {
+		{ .addr = I2C_EEPROM_SLAVE_ADDR, .flags = 0,        .buf = b0, .len = 1 },
+		{ .addr = I2C_EEPROM_SLAVE_ADDR, .flags = I2C_M_RD, .buf = b1, .len = 128 }
+	};
+
+	if (i2c_transfer(i2c, msg, 2) != 2) {
+		printk ("%s i2c eeprom request failed\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	if(debug) {
+		dprintk ("i2c eeprom content:\n");
+		j=0;
+		for(i=0;i<128;i++) {
+			dprintk("%02x ",b1[i]);
+			if(j++==16) {
+				dprintk("\n");
+				j=0;
+			}
+		}
+ 		dprintk("\n");
+	}
+
+	if( (b1[8]!=0x84) || (b1[10]!=0x00) ) {
+		printk ("%s eeprom content is not valid\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	/* Make sure we support the board model */
+	model = b1[0x1f] << 24 | b1[0x1e] << 16 | b1[0x1d] << 8 | b1[0x1c];
+	switch(model) {
+		case 90002:
+		case 90500:
+		case 90501:
+			dprintk ("%s: Model #%d\n",__FUNCTION__,model);
+			break;	
+		default:
+			printk ("%s: Unknown model #%d not supported\n",__FUNCTION__,model);
+			return -ENODEV;	
+	}
+
+	/* Make sure we support the tuner */
+	tuner = b1[0x2d];
+	switch(tuner) {
+		case 0x4B:
+			dprintk ("%s: Tuner Thomson DTT 7595\n",__FUNCTION__);
+			*minfreq = 177000000;
+			*pll_type = PLLTYPE_DTT7595;
+			break;	
+		case 0x4C:
+			dprintk ("%s: Tuner Thomson DTT 7592\n",__FUNCTION__);
+			*minfreq = 474000000;
+			*pll_type = PLLTYPE_DTT7592;
+			break;	
+		default:
+			printk ("%s: Unknown tuner 0x%02x not supported\n",__FUNCTION__,tuner);
+			return -ENODEV;	
+	}
+	*pll_addr = 0x61;
+	*demod_addr = 0x43;   
+	return 0;
+}
+
+
+/* Validate the demod, make sure we understand the hardware */
+static int cx22702_validate_demod(struct i2c_adapter *i2c, int demod_addr)
+{
+	u8 b0 [] = { 0x1f };
+	u8 b1 [] = { 0 };
+
+	struct i2c_msg msg [] = {
+		{ .addr = demod_addr, .flags = 0,        .buf = b0, .len = 1 },
+		{ .addr = demod_addr, .flags = I2C_M_RD, .buf = b1, .len = 1 }
+	};
+
+	if (i2c_transfer(i2c, msg, 2) != 2) {
+		printk ("%s i2c demod request failed\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	if( (b1[0]!=0x3) ) {
+		printk ("%s i2c demod type 0x(%02x) not known\n", __FUNCTION__,b1[0]);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/* Validate the tuner PLL, make sure we understand the hardware */
+static int cx22702_validate_pll(struct i2c_adapter *i2c, int pll_addr, int demod_addr)
+{
+	int result=0;
+
+	if( (result=pll_readreg(i2c,pll_addr,demod_addr,0xc2)) < 0)
+		return result;
+
+	if( (result >= 0) && (result&0x30) )
+		return 0;
+
+	return result;
+}
+
+/* Check we can see the I2c clients */
+static int cx22702_attach_adapter(struct i2c_adapter *adapter)
+{
+	struct cx22702_state *state;
+	struct i2c_client *client;
+	int ret;
+	int minfreq;
+	int pll_type;
+	int pll_addr;
+	int demod_addr;
+
+	if (0 == (adapter->class & I2C_CLASS_TV_DIGITAL)) {
+		dprintk("Ignoring adapter 0x%x:%s (no digital tv card).\n",
+			adapter->id, adapter->name);
+		return 0;
+	}
+
+	dprintk("Trying to attach to adapter 0x%x:%s.\n",
+		adapter->id, adapter->name);
+
+	if (!strcmp(adapter->name, "Conexant DVB-T reference design")) {
+	   	printk("cx22702: Detected Conexant DVB-T card - PLL Thomson DTT7579\n");
+		pll_type = PLLTYPE_DTT7579;
+		pll_addr = 0x60;
+		demod_addr = 0x43;
+		minfreq = 177000000; // guess
+	} else {
+		// default to Hauppauge Nova-T for the moment
+	   	printk("cx22702: Detected Hauppauge Nova-T DVB-T - PLL Thomson DTT759x\n");
+		ret=cx22702_validate_eeprom(adapter, &minfreq, &pll_type, &pll_addr, &demod_addr);
+		if(ret < 0)
+			return ret;
+	}
+
+	ret=cx22702_validate_demod(adapter, demod_addr);
+	if(ret < 0)
+		return ret;
+
+	ret=cx22702_validate_pll(adapter, pll_addr, demod_addr);
+	if(ret < 0)
+		return ret;
+
+	if ( !(state = kmalloc(sizeof(struct cx22702_state), GFP_KERNEL)) )
+		return -ENOMEM;
+
+	memset(state, 0, sizeof(struct cx22702_state));
+	state->i2c = adapter;
+	memcpy(&state->cx22702_info, &cx22702_info, sizeof(struct dvb_frontend_info));   
+	state->cx22702_info.frequency_min = minfreq;
+	state->pll_type = pll_type;
+	state->pll_addr = pll_addr; 
+	state->demod_addr = demod_addr;
+
+	if ( !(client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)) ) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = state->demod_addr;
+	i2c_set_clientdata(client, state);
+   
+	if ((ret = i2c_attach_client(client))) {
+		printk("cx22702: attach failed %i\n", ret);
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+	return 0;	
+}
+
+static int cx22702_detach_client(struct i2c_client *client)
+{
+	struct cx22702_state *state = i2c_get_clientdata(client);
+
+	if (NULL != state->dvb) {
+		dvb_unregister_frontend (cx22702_ioctl, state->dvb);
+		state->dvb = NULL;
+	}
+	i2c_detach_client(client);
+	kfree(client);
+	return 0;
+}
+
+static int command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	struct cx22702_state *state = i2c_get_clientdata(client);
+	int rc;
+
+	switch(cmd) {
+	case FE_REGISTER:
+		if (NULL != state->dvb)
+			break;
+		state->dvb = arg;
+		rc = dvb_register_frontend(cx22702_ioctl, state->dvb, state,
+					   &state->cx22702_info, THIS_MODULE);
+		if (0 != rc) {
+			printk("cx22702: dvb_register_frontend failed with rc=%d\n",rc);
+			state->dvb = NULL;
+			return rc;
+		}
+		break;
+	case FE_UNREGISTER:
+		if (NULL == state->dvb)
+			break;
+		dvb_unregister_frontend (cx22702_ioctl, state->dvb);
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static struct i2c_driver driver = {
+	.owner = THIS_MODULE,
+	.name  = FRONTEND_NAME,
+	.id = I2C_DRIVERID_DVBFE_CX22702,
+	.flags = I2C_DF_NOTIFY,
+	.attach_adapter = cx22702_attach_adapter,
+	.detach_client = cx22702_detach_client,
+	.command = command,
+};
+
+static struct i2c_client client_template = {
+	.name = FRONTEND_NAME,
+	.flags = I2C_CLIENT_ALLOW_USE,
+	.driver = &driver,
+};
+
+static int __init init_cx22702 (void)
+{
+	return i2c_add_driver(&driver);
+}
+
+static void __exit exit_cx22702 (void)
+{
+	if (i2c_del_driver(&driver))
+		printk(KERN_ERR "cx22702: driver deregistration failed.\n");
+}
+
+module_init (init_cx22702);
+module_exit (exit_cx22702);
+
+MODULE_PARM(debug,"i");
+MODULE_PARM_DESC(debug, "Enable verbose debug messages");
+MODULE_DESCRIPTION("CX22702 / Thomson DTT 759x / Thomson DTT 7579 PLL DVB Frontend driver");
+MODULE_AUTHOR("Steven Toth");
+MODULE_LICENSE("GPL");
+
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/cx24110.c linux/drivers/media/dvb/frontends/cx24110.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/cx24110.c	2004-09-14 10:34:36.000000000 +0200
+++ linux/drivers/media/dvb/frontends/cx24110.c	2004-09-17 14:56:38.798601243 +0200
@@ -35,13 +35,22 @@
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/init.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
-static int debug = 0;
-#define dprintk	if (debug) printk
+#define FRONTEND_NAME "dvbfe_cx24110"
+
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
+
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
 
 
 static struct dvb_frontend_info cx24110_info = {
@@ -63,6 +72,10 @@ static struct dvb_frontend_info cx24110_
 };
 /* fixme: are these values correct? especially ..._tolerance and caps */
 
+struct cx24110_state {
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
 
 static struct {u8 reg; u8 data;} cx24110_regdata[]=
                       /* Comments beginning with @ denote this value should
@@ -127,7 +140,7 @@ static struct {u8 reg; u8 data;} cx24110
 	};
 
 
-static int cx24110_writereg (struct dvb_i2c_bus *i2c, int reg, int data)
+static int cx24110_writereg (struct i2c_adapter *i2c, int reg, int data)
 {
         u8 buf [] = { reg, data };
 	struct i2c_msg msg = { .addr = 0x55, .flags = 0, .buf = buf, .len = 2 };
@@ -135,8 +148,9 @@ static int cx24110_writereg (struct dvb_
    cx24110 might show up at any address */
 	int err;
 
-        if ((err = i2c->xfer (i2c, &msg, 1)) != 1) {
-		dprintk ("%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\n", __FUNCTION__, err, reg, data);
+        if ((err = i2c_transfer(i2c, &msg, 1)) != 1) {
+		dprintk ("%s: writereg error (err == %i, reg == 0x%02x,"
+			 " data == 0x%02x)\n", __FUNCTION__, err, reg, data);
 		return -EREMOTEIO;
 	}
 
@@ -144,7 +158,7 @@ static int cx24110_writereg (struct dvb_
 }
 
 
-static u8 cx24110_readreg (struct dvb_i2c_bus *i2c, u8 reg)
+static u8 cx24110_readreg (struct i2c_adapter *i2c, u8 reg)
 {
 	int ret;
 	u8 b0 [] = { reg };
@@ -152,7 +166,7 @@ static u8 cx24110_readreg (struct dvb_i2
 	struct i2c_msg msg [] = { { .addr = 0x55, .flags = 0, .buf = b0, .len = 1 },
 			   { .addr = 0x55, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
 /* fixme (medium): address might be different from 0x55 */
-	ret = i2c->xfer (i2c, msg, 2);
+	ret = i2c_transfer(i2c, msg, 2);
 
 	if (ret != 2)
 		dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
@@ -161,7 +175,7 @@ static u8 cx24110_readreg (struct dvb_i2
 }
 
 
-static int cx24108_write (struct dvb_i2c_bus *i2c, u32 data)
+static int cx24108_write (struct i2c_adapter *i2c, u32 data)
 {
 /* tuner data is 21 bits long, must be left-aligned in data */
 /* tuner cx24108 is written through a dedicated 3wire interface on the demod chip */
@@ -195,7 +209,7 @@ dprintk("cx24110 debug: cx24108_write(%8
 }
 
 
-static int cx24108_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq)
+static int cx24108_set_tv_freq (struct i2c_adapter *i2c, u32 freq)
 {
 /* fixme (low): error handling */
         int i, a, n, pump;
@@ -247,7 +261,7 @@ static int cx24108_set_tv_freq (struct d
         cx24108_write(i2c,pll);
         cx24110_writereg(i2c,0x56,0x7f);
 
-	dvb_delay(10); /* wait a moment for the tuner pll to lock */
+	msleep(10); /* wait a moment for the tuner pll to lock */
 
 	/* tuner pll lock can be monitored on GPIO pin 4 of cx24110 */
         while (!(cx24110_readreg(i2c,0x66)&0x20)&&i<1000)
@@ -259,7 +273,7 @@ static int cx24108_set_tv_freq (struct d
 }
 
 
-static int cx24110_init (struct dvb_i2c_bus *i2c)
+static int cx24110_initfe(struct i2c_adapter *i2c)
 {
 /* fixme (low): error handling */
         int i;
@@ -274,7 +288,7 @@ static int cx24110_init (struct dvb_i2c_
 }
 
 
-static int cx24110_set_inversion (struct dvb_i2c_bus *i2c, fe_spectral_inversion_t inversion)
+static int cx24110_set_inversion (struct i2c_adapter *i2c, fe_spectral_inversion_t inversion)
 {
 /* fixme (low): error handling */
 
@@ -309,7 +323,7 @@ static int cx24110_set_inversion (struct
 }
 
 
-static int cx24110_set_fec (struct dvb_i2c_bus *i2c, fe_code_rate_t fec)
+static int cx24110_set_fec (struct i2c_adapter *i2c, fe_code_rate_t fec)
 {
 /* fixme (low): error handling */
 
@@ -355,7 +369,7 @@ static int cx24110_set_fec (struct dvb_i
 }
 
 
-static fe_code_rate_t cx24110_get_fec (struct dvb_i2c_bus *i2c)
+static fe_code_rate_t cx24110_get_fec (struct i2c_adapter *i2c)
 {
 	int i;
 
@@ -372,7 +386,7 @@ static fe_code_rate_t cx24110_get_fec (s
 }
 
 
-static int cx24110_set_symbolrate (struct dvb_i2c_bus *i2c, u32 srate)
+static int cx24110_set_symbolrate (struct i2c_adapter *i2c, u32 srate)
 {
 /* fixme (low): add error handling */
         u32 ratio;
@@ -454,7 +468,7 @@ dprintk("cx24110 debug: entering %s(%d)\
 }
 
 
-static int cx24110_set_voltage (struct dvb_i2c_bus *i2c, fe_sec_voltage_t voltage)
+static int cx24110_set_voltage (struct i2c_adapter *i2c, fe_sec_voltage_t voltage)
 {
 	switch (voltage) {
 	case SEC_VOLTAGE_13:
@@ -466,16 +480,17 @@ static int cx24110_set_voltage (struct d
 	};
 }
 
-static void sendDiSEqCMessage(struct dvb_i2c_bus *i2c, struct dvb_diseqc_master_cmd *pCmd)
+static void cx24110_send_diseqc_msg(struct i2c_adapter *i2c,
+				    struct dvb_diseqc_master_cmd *cmd)
 {
 	int i, rv;
 
-	for (i = 0; i < pCmd->msg_len; i++)
-		cx24110_writereg(i2c, 0x79 + i, pCmd->msg[i]);
+	for (i = 0; i < cmd->msg_len; i++)
+		cx24110_writereg(i2c, 0x79 + i, cmd->msg[i]);
 
 	rv = cx24110_readreg(i2c, 0x76);
 
-	cx24110_writereg(i2c, 0x76, ((rv & 0x90) | 0x40) | ((pCmd->msg_len-3) & 3));
+	cx24110_writereg(i2c, 0x76, ((rv & 0x90) | 0x40) | ((cmd->msg_len-3) & 3));
 	for (i=500; i-- > 0 && !(cx24110_readreg(i2c,0x76)&0x40);)
 		; /* wait for LNB ready */
 }
@@ -483,7 +498,8 @@ static void sendDiSEqCMessage(struct dvb
 
 static int cx24110_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
+	struct cx24110_state *state = fe->data;
+	struct i2c_adapter *i2c = state->i2c;
 	static int lastber=0, lastbyer=0,lastbler=0, lastesn0=0, sum_bler=0;
 
         switch (cmd) {
@@ -618,7 +634,7 @@ static int cx24110_ioctl (struct dvb_fro
 /* cannot do this from the FE end. How to communicate this to the place where it can be done? */
 		break;
         case FE_INIT:
-		return cx24110_init (i2c);
+		return cx24110_initfe(i2c);
 
 	case FE_SET_TONE:
 		return cx24110_writereg(i2c,0x76,(cx24110_readreg(i2c,0x76)&~0x10)|((((fe_sec_tone_mode_t) arg)==SEC_TONE_ON)?0x10:0));
@@ -626,7 +642,8 @@ static int cx24110_ioctl (struct dvb_fro
 		return cx24110_set_voltage (i2c, (fe_sec_voltage_t) arg);
 
 	case FE_DISEQC_SEND_MASTER_CMD:
-		sendDiSEqCMessage(i2c, (struct dvb_diseqc_master_cmd*) arg);
+		// FIXME Status?
+		cx24110_send_diseqc_msg(i2c, (struct dvb_diseqc_master_cmd*) arg);
 		return 0;
 
 	default:
@@ -636,43 +653,118 @@ static int cx24110_ioctl (struct dvb_fro
         return 0;
 }
 
+static struct i2c_client client_template;
 
-static int cx24110_attach (struct dvb_i2c_bus *i2c, void **data)
+static int attach_adapter (struct i2c_adapter *adapter)
 {
+	struct cx24110_state *state;
+	struct i2c_client *client;
+	int ret = 0;
 	u8 sig;
 
-	sig=cx24110_readreg (i2c, 0x00);
+	dprintk("Trying to attach to adapter 0x%x:%s.\n",
+		adapter->id, adapter->name);
+
+	sig = cx24110_readreg (adapter, 0x00);
 	if ( sig != 0x5a && sig != 0x69 )
 		return -ENODEV;
 
-	return dvb_register_frontend (cx24110_ioctl, i2c, NULL, &cx24110_info);
-}
+	if ( !(state = kmalloc(sizeof(struct cx24110_state), GFP_KERNEL)) )
+		return -ENOMEM;
 
+	memset(state, 0, sizeof(struct cx24110_state));
+	state->i2c = adapter;
 
-static void cx24110_detach (struct dvb_i2c_bus *i2c, void *data)
-{
-	dvb_unregister_frontend (cx24110_ioctl, i2c);
+	if ( !(client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)) ) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = 0x55;
+	i2c_set_clientdata(client, state);
+
+	if ((ret = i2c_attach_client(client))) {
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	BUG_ON(!state->dvb);
+
+	if ((ret = dvb_register_frontend(cx24110_ioctl, state->dvb, state,
+					     &cx24110_info, THIS_MODULE))) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	return 0;
 }
 
+static int detach_client (struct i2c_client *client)
+{
+	struct cx24110_state *state = i2c_get_clientdata(client);
 
-static int __init init_cx24110 (void)
+	dvb_unregister_frontend(cx24110_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
+
+static int command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	return dvb_register_i2c_device (THIS_MODULE, cx24110_attach, cx24110_detach);
+	struct cx24110_state *state = i2c_get_clientdata(client);
+
+	switch(cmd) {
+	case FE_REGISTER:
+		state->dvb = arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner		= THIS_MODULE,
+	.name		= FRONTEND_NAME,
+	.id		= I2C_DRIVERID_DVBFE_CX24110,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= attach_adapter,
+	.detach_client	= detach_client,
+	.command	= command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags		= I2C_CLIENT_ALLOW_USE,
+	.driver		= &driver,
+};
 
-static void __exit exit_cx24110 (void)
+static int __init cx24110_init(void)
 {
-	dvb_unregister_i2c_device (cx24110_attach);
+	return i2c_add_driver(&driver);
 }
 
+static void __exit cx24110_exit(void)
+{
+	if (i2c_del_driver(&driver))
+		printk(KERN_ERR "cx24110: driver deregistration failed.\n");
+}
 
-module_init(init_cx24110);
-module_exit(exit_cx24110);
-
+module_init(cx24110_init);
+module_exit(cx24110_exit);
 
 MODULE_DESCRIPTION("DVB Frontend driver module for the Conexant cx24108/cx24110 chipset");
 MODULE_AUTHOR("Peter Hettkamp");
 MODULE_LICENSE("GPL");
-MODULE_PARM(debug,"i");
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/dib3000mb.c linux/drivers/media/dvb/frontends/dib3000mb.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/dib3000mb.c	2004-09-17 14:56:38.801600681 +0200
+++ linux/drivers/media/dvb/frontends/dib3000mb.c	2004-09-17 14:56:38.801600681 +0200
@@ -0,0 +1,857 @@
+/*
+ * Frontend driver for mobile DVB-T demodulator DiBcom 3000-MB 
+ * DiBcom (http://www.dibcom.fr/)
+ *
+ * Copyright (C) 2004 Patrick Boettcher (patrick.boettcher@desy.de)
+ * 
+ * based on GPL code from DibCom, which has
+ *
+ * Copyright (C) 2004 Amaury Demol for DiBcom (ademol@dibcom.fr)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ * Acknowledgements
+ * 
+ *  Amaury Demol (ademol@dibcom.fr) from DiBcom for providing specs and driver
+ *  sources, on which this driver (and the dvb-dibusb) are based.
+ *
+ * see Documentation/dvb/README.dibusb for more information
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include "dvb_frontend.h"
+
+#include "dib3000mb.h"
+
+/* debug */
+
+#ifdef CONFIG_DVB_DIBCOM_DEBUG
+#define dprintk_new(level,args...) \
+	do { if ((debug & level)) { printk(args); } } while (0)
+
+static int debug;
+module_param(debug, int, 0x644);
+MODULE_PARM_DESC(debug, "set debugging level (1=info,2=xfer,4=alotmore (|-able)).");
+#else
+#define dprintk_new(args...)
+#endif
+
+#define deb_info(args...) dprintk_new(0x01,args)
+#define deb_xfer(args...) dprintk_new(0x02,args)
+#define deb_alot(args...) dprintk_new(0x04,args)
+
+/* Version information */
+#define DRIVER_VERSION "0.1"
+#define DRIVER_DESC "DiBcom 3000-MB DVB-T frontend"
+#define DRIVER_AUTHOR "Patrick Boettcher, patrick.boettcher@desy.de"
+
+struct dib3000mb_state {
+	struct i2c_client *i2c;
+	struct dvb_adapter *dvb;
+	u16 manufactor_id;
+	u16 device_id;
+};
+
+static struct dvb_frontend_info dib3000mb_info = {
+	.name			= "DiBcom 3000-MB DVB-T frontend",
+	.type 			= FE_OFDM,
+	.frequency_min 		= 44250000,
+	.frequency_max 		= 867250000,
+	.frequency_stepsize	= 62500,
+	.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO | 
+			FE_CAN_GUARD_INTERVAL_AUTO | 
+			FE_CAN_HIERARCHY_AUTO,
+};
+
+
+#define rd(reg) dib3000mb_read_reg(state->i2c,reg)
+#define wr(reg,val) if (dib3000mb_write_reg(state->i2c,reg,val)) \
+	{ err("while sending 0x%04x to 0x%04x.",val,reg); return -EREMOTEIO; }
+#define wr_foreach(a,v) { int i; \
+	deb_alot("sizeof: %d %d\n",sizeof(a),sizeof(v));\
+	for (i=0; i < sizeof(a)/sizeof(u16); i++) \
+		wr(a[i],v[i]); \
+}
+
+static u16 dib3000mb_read_reg(struct i2c_client *i2c, u16 reg)
+{
+	u8 wb[] = { ((reg >> 8) | 0x80) & 0xff, reg & 0xff };
+	u8 rb[2]; 
+	struct i2c_msg msg[] = {
+		{ .addr = i2c->addr, .flags = 0,        .buf = wb, .len = 2 },
+		{ .addr = i2c->addr, .flags = I2C_M_RD, .buf = rb, .len = 2 },
+	};
+	deb_alot("reading from i2c bus (reg: %d)\n",reg);
+
+	if (i2c_transfer(i2c->adapter,msg,2) != 2)
+		deb_alot("i2c read error\n");
+
+	return (rb[0] << 8) | rb[1];
+}
+
+static int dib3000mb_write_reg(struct i2c_client *i2c,u16 reg, u16 val)
+{
+	u8 b[] = { 
+		(reg >> 8) & 0xff, reg & 0xff, 
+		(val >> 8) & 0xff, val & 0xff,
+	};
+	struct i2c_msg msg[] = { { .addr = i2c->addr, .flags = 0, .buf = b, .len = 4 } };
+	deb_alot("writing to i2c bus (reg: %d, val: %d)\n",reg,val);
+
+	return i2c_transfer(i2c->adapter,msg,1) != 1 ? -EREMOTEIO : 0 ;
+}
+
+static int dib3000mb_tuner_thomson_cable_eu(struct dib3000mb_state *state,
+		u32 freq)
+{
+	u32 tfreq = (freq + 36125000) / 62500;
+	unsigned int addr;
+	int vu,p0,p1,p2;
+	
+	if (freq > 403250000)
+		vu = 1, p2 = 1, p1 = 0, p0 = 1;
+	else if (freq > 115750000)
+		vu = 0, p2 = 1, p1 = 1, p0 = 0;
+	else if (freq > 44250000)
+		vu = 0, p2 = 0, p1 = 1, p0 = 1;
+	else 
+		return -EINVAL;
+	/* TODO better solution for i2c->addr handling */
+	addr = state->i2c->addr;
+	state->i2c->addr = DIB3000MB_TUNER_ADDR_DEFAULT;
+	wr(tfreq & 0x7fff,(0x8e << 8) + ((vu << 7) | (p2 << 2) | (p1 << 1) | p0) );
+	state->i2c->addr = addr;
+	
+	return 0;
+}
+
+static int dib3000mb_get_frontend(struct dib3000mb_state *state, 
+		struct dvb_frontend_parameters *fep)
+{
+	struct dvb_ofdm_parameters *ofdm = &fep->u.ofdm;
+	fe_code_rate_t *cr;
+	u16 tps_val;
+	int inv_test1,inv_test2;
+	u32 dds_val, threshold = 0x800000;
+	
+	if (!rd(DIB3000MB_REG_TPS_LOCK)) 
+		return -EINVAL;
+
+	dds_val = ((rd(DIB3000MB_REG_DDS_VALUE_MSB) & 0xff) << 16) + rd(DIB3000MB_REG_DDS_VALUE_LSB);
+	if (dds_val & threshold)
+		inv_test1 = 0;
+	else if (dds_val == threshold) 
+		inv_test1 = 1;
+	else 
+		inv_test1 = 2;
+
+	dds_val = ((rd(DIB3000MB_REG_DDS_FREQ_MSB) & 0xff) << 16) + rd(DIB3000MB_REG_DDS_FREQ_LSB);
+	if (dds_val & threshold)
+		inv_test2 = 0;
+	else if (dds_val == threshold) 
+		inv_test2 = 1;
+	else 
+		inv_test2 = 2;
+	
+	fep->inversion = 
+		((inv_test2 == 2) && (inv_test1==1 || inv_test1==0))
+					||
+		((inv_test2 == 0) && (inv_test1==1 || inv_test1==2));
+
+	deb_info("inversion %d %d, %d\n",inv_test2,inv_test1, fep->inversion);
+	
+	switch ((tps_val = rd(DIB3000MB_REG_TPS_QAM))) {
+		case DIB3000MB_QAM_QPSK:
+			deb_info("QPSK ");
+			ofdm->constellation = QPSK;
+			break;
+		case DIB3000MB_QAM_QAM16:
+			deb_info("QAM16 ");
+			ofdm->constellation = QAM_16;
+			break;
+		case DIB3000MB_QAM_QAM64:
+			deb_info("QAM64 ");
+			ofdm->constellation = QAM_64;
+			break;
+		default:
+			err("Unexpected constellation returned by TPS (%d)",tps_val);
+			break;
+ 	}
+	deb_info("TPS: %d\n",tps_val);
+
+	if (rd(DIB3000MB_REG_TPS_HRCH)) {
+		deb_info("HRCH ON\n");
+		tps_val = rd(DIB3000MB_REG_TPS_CODE_RATE_LP);
+		cr = &ofdm->code_rate_LP;
+		ofdm->code_rate_HP = FEC_NONE;
+		
+		switch ((tps_val = rd(DIB3000MB_REG_TPS_VIT_ALPHA))) {
+			case DIB3000MB_VIT_ALPHA_OFF:
+				deb_info("HIERARCHY_NONE ");
+				ofdm->hierarchy_information = HIERARCHY_NONE;
+				break;
+			case DIB3000MB_VIT_ALPHA_1:
+				deb_info("HIERARCHY_1 ");
+				ofdm->hierarchy_information = HIERARCHY_1;
+				break;
+			case DIB3000MB_VIT_ALPHA_2:
+				deb_info("HIERARCHY_2 ");
+				ofdm->hierarchy_information = HIERARCHY_2;
+				break;
+			case DIB3000MB_VIT_ALPHA_4:
+				deb_info("HIERARCHY_4 ");
+				ofdm->hierarchy_information = HIERARCHY_4;
+				break;
+			default:
+				err("Unexpected ALPHA value returned by TPS (%d)",tps_val);
+		}	
+		deb_info("TPS: %d\n",tps_val);
+	} else {
+		deb_info("HRCH OFF\n");
+		tps_val = rd(DIB3000MB_REG_TPS_CODE_RATE_HP);
+		cr = &ofdm->code_rate_HP;
+		ofdm->code_rate_LP = FEC_NONE;
+		ofdm->hierarchy_information = HIERARCHY_NONE;
+	}
+
+	switch (tps_val) {
+		case DIB3000MB_FEC_1_2:
+			deb_info("FEC_1_2 ");
+			*cr = FEC_1_2;
+			break;
+		case DIB3000MB_FEC_2_3:
+			deb_info("FEC_2_3 ");
+			*cr = FEC_2_3;
+			break;
+		case DIB3000MB_FEC_3_4:
+			deb_info("FEC_3_4 ");
+			*cr = FEC_3_4;
+			break;
+		case DIB3000MB_FEC_5_6:
+			deb_info("FEC_5_6 ");
+			*cr = FEC_4_5;
+			break;
+		case DIB3000MB_FEC_7_8:
+			deb_info("FEC_7_8 ");
+			*cr = FEC_7_8;
+			break;
+		default:
+			err("Unexpected FEC returned by TPS (%d)",tps_val);
+			break;
+	}
+	deb_info("TPS: %d\n",tps_val);
+	
+	switch ((tps_val = rd(DIB3000MB_REG_TPS_GUARD_TIME))) {
+		case DIB3000MB_GUARD_TIME_1_32:
+			deb_info("GUARD_INTERVAL_1_32 ");
+			ofdm->guard_interval = GUARD_INTERVAL_1_32;
+			break;
+		case DIB3000MB_GUARD_TIME_1_16:
+			deb_info("GUARD_INTERVAL_1_16 ");
+			ofdm->guard_interval = GUARD_INTERVAL_1_16;
+			break;
+		case DIB3000MB_GUARD_TIME_1_8:
+			deb_info("GUARD_INTERVAL_1_8 ");
+			ofdm->guard_interval = GUARD_INTERVAL_1_8;
+			break;
+		case DIB3000MB_GUARD_TIME_1_4:
+			deb_info("GUARD_INTERVAL_1_4 ");
+			ofdm->guard_interval = GUARD_INTERVAL_1_4;
+			break;
+		default:
+			err("Unexpected Guard Time returned by TPS (%d)",tps_val);
+			break;
+	}
+	deb_info("TPS: %d\n",tps_val);
+	
+	switch ((tps_val = rd(DIB3000MB_REG_TPS_FFT))) {
+		case DIB3000MB_FFT_2K:
+			deb_info("TRANSMISSION_MODE_2K ");
+			ofdm->transmission_mode = TRANSMISSION_MODE_2K;
+			break;
+		case DIB3000MB_FFT_8K:
+			deb_info("TRANSMISSION_MODE_8K ");
+			ofdm->transmission_mode = TRANSMISSION_MODE_8K;
+			break;
+		default:
+			err("unexpected transmission mode return by TPS (%d)",tps_val);
+	}
+	deb_info("TPS: %d\n",tps_val);
+	return 0;
+}
+
+static int dib3000mb_set_frontend(struct dib3000mb_state *state,
+		struct dvb_frontend_parameters *fep, int tuner);
+
+static int dib3000mb_fe_read_search_status(struct dib3000mb_state *state) 
+{
+	u16 irq;
+	struct dvb_frontend_parameters fep;
+	
+	irq = rd(DIB3000MB_REG_AS_IRQ_PENDING);
+
+	if (irq & 0x02) {
+		if (rd(DIB3000MB_REG_LOCK2_VALUE) & 0x01) {
+			if (dib3000mb_get_frontend(state,&fep) == 0) {
+				deb_info("reading tuning data from frontend succeeded.\n");
+				return dib3000mb_set_frontend(state,&fep,0) == 0;
+			} else {
+				deb_info("reading tuning data failed -> tuning failed.\n");
+				return 0;
+			}
+		} else {
+			deb_info("AS IRQ was pending, but LOCK2 was not & 0x01.\n");
+			return 0;
+		}
+	} else if (irq & 0x01) {
+		deb_info("Autosearch failed.\n");
+		return 0;
+	}
+
+	return -1;
+}
+
+static int dib3000mb_set_frontend(struct dib3000mb_state *state,
+		struct dvb_frontend_parameters *fep, int tuner)
+{
+	struct dvb_ofdm_parameters *ofdm = &fep->u.ofdm;
+	fe_code_rate_t fe_cr;
+	int search_state,seq;
+	
+	if (tuner) {
+		wr(DIB3000MB_REG_TUNER,
+				DIB3000MB_ACTIVATE_TUNER_XFER( DIB3000MB_TUNER_ADDR_DEFAULT ) );
+		dib3000mb_tuner_thomson_cable_eu(state,fep->frequency);
+		
+		/* wait for tuner */
+		msleep(1);
+		wr(DIB3000MB_REG_TUNER, 
+				DIB3000MB_DEACTIVATE_TUNER_XFER( DIB3000MB_TUNER_ADDR_DEFAULT ) );
+
+		switch (ofdm->bandwidth) {
+			case BANDWIDTH_8_MHZ:
+			case BANDWIDTH_AUTO:
+				wr_foreach(dib3000mb_reg_timing_freq,dib3000mb_timing_freq[2]);
+				wr_foreach(dib3000mb_reg_bandwidth,dib3000mb_bandwidth_8mhz);
+				break;
+			case BANDWIDTH_7_MHZ:
+				wr_foreach(dib3000mb_reg_timing_freq,dib3000mb_timing_freq[1]);
+				wr_foreach(dib3000mb_reg_bandwidth,dib3000mb_bandwidth_7mhz);
+				break;
+			case BANDWIDTH_6_MHZ:
+				wr_foreach(dib3000mb_reg_timing_freq,dib3000mb_timing_freq[0]);
+				wr_foreach(dib3000mb_reg_bandwidth,dib3000mb_bandwidth_6mhz);
+				break;
+			default:
+				err("unkown bandwidth value.");
+				return -EINVAL;
+				break;
+		}
+	}	
+	wr(DIB3000MB_REG_LOCK1_MASK,DIB3000MB_LOCK1_SEARCH_4);
+
+	switch (ofdm->transmission_mode) {
+		case TRANSMISSION_MODE_2K:
+			wr(DIB3000MB_REG_FFT,DIB3000MB_FFT_2K);
+			break;
+		case TRANSMISSION_MODE_8K:
+			wr(DIB3000MB_REG_FFT,DIB3000MB_FFT_8K);
+			break;
+		case TRANSMISSION_MODE_AUTO:
+			wr(DIB3000MB_REG_FFT,DIB3000MB_FFT_AUTO);
+			break;
+		default:
+			return -EINVAL;
+	}
+	
+	switch (ofdm->guard_interval) {
+		case GUARD_INTERVAL_1_32:
+			wr(DIB3000MB_REG_GUARD_TIME,DIB3000MB_GUARD_TIME_1_32);
+			break;
+		case GUARD_INTERVAL_1_16:
+			wr(DIB3000MB_REG_GUARD_TIME,DIB3000MB_GUARD_TIME_1_16);
+			break;
+		case GUARD_INTERVAL_1_8:
+			wr(DIB3000MB_REG_GUARD_TIME,DIB3000MB_GUARD_TIME_1_8);
+			break;
+		case GUARD_INTERVAL_1_4:
+			wr(DIB3000MB_REG_GUARD_TIME,DIB3000MB_GUARD_TIME_1_4);
+			break;
+		case GUARD_INTERVAL_AUTO:
+			wr(DIB3000MB_REG_GUARD_TIME,DIB3000MB_GUARD_TIME_AUTO);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	switch (fep->inversion) {
+		case INVERSION_OFF:
+			wr(DIB3000MB_REG_DDS_INV,DIB3000MB_DDS_INV_OFF);
+			break;
+		case INVERSION_AUTO:
+		case INVERSION_ON:
+			wr(DIB3000MB_REG_DDS_INV,DIB3000MB_DDS_INV_ON);
+			break;
+		default:
+			return -EINVAL;
+	}
+	
+	switch (ofdm->constellation) {
+		case QPSK:
+			wr(DIB3000MB_REG_QAM,DIB3000MB_QAM_QPSK);
+			break;
+		case QAM_16:
+			wr(DIB3000MB_REG_QAM,DIB3000MB_QAM_QAM16);
+			break;
+		case QAM_64:
+			wr(DIB3000MB_REG_QAM,DIB3000MB_QAM_QAM64);
+			break;
+		case QAM_AUTO:
+			break;
+		default:
+			return -EINVAL;
+	}
+	
+	switch (ofdm->hierarchy_information) {
+		case HIERARCHY_NONE:
+		case HIERARCHY_1:
+			wr(DIB3000MB_REG_VIT_ALPHA,DIB3000MB_VIT_ALPHA_1);
+			break;
+		case HIERARCHY_2:
+			wr(DIB3000MB_REG_VIT_ALPHA,DIB3000MB_VIT_ALPHA_2);
+			break;
+		case HIERARCHY_4:
+			wr(DIB3000MB_REG_VIT_ALPHA,DIB3000MB_VIT_ALPHA_4);
+			break; 
+		case HIERARCHY_AUTO:
+			wr(DIB3000MB_REG_VIT_ALPHA,DIB3000MB_VIT_ALPHA_AUTO);
+			break;
+		default:
+			return -EINVAL;
+	}
+	
+	if (ofdm->hierarchy_information == HIERARCHY_NONE) {
+		wr(DIB3000MB_REG_VIT_HRCH,DIB3000MB_VIT_HRCH_OFF);
+		wr(DIB3000MB_REG_VIT_HP,DIB3000MB_VIT_HP);
+		fe_cr = ofdm->code_rate_HP;
+	} else {
+		wr(DIB3000MB_REG_VIT_HRCH,DIB3000MB_VIT_HRCH_ON);
+		wr(DIB3000MB_REG_VIT_HP,DIB3000MB_VIT_LP);
+		fe_cr = ofdm->code_rate_LP;
+	}
+			
+	switch (fe_cr) {
+		case FEC_1_2:
+			wr(DIB3000MB_REG_VIT_CODE_RATE,DIB3000MB_FEC_1_2);
+			break;
+		case FEC_2_3:
+			wr(DIB3000MB_REG_VIT_CODE_RATE,DIB3000MB_FEC_2_3);
+			break;
+		case FEC_3_4:
+			wr(DIB3000MB_REG_VIT_CODE_RATE,DIB3000MB_FEC_3_4);
+			break;
+		case FEC_5_6:
+			wr(DIB3000MB_REG_VIT_CODE_RATE,DIB3000MB_FEC_5_6);
+			break;
+		case FEC_7_8:
+			wr(DIB3000MB_REG_VIT_CODE_RATE,DIB3000MB_FEC_7_8);
+			break;
+		case FEC_NONE:
+		case FEC_AUTO:
+			break;
+		default:
+			return -EINVAL;
+	}	
+	
+	seq = dib3000mb_seq
+		[ofdm->transmission_mode == TRANSMISSION_MODE_AUTO]
+		[ofdm->guard_interval == GUARD_INTERVAL_AUTO]
+		[fep->inversion == INVERSION_AUTO];
+
+	deb_info("seq? %d\n",seq);
+	
+	wr(DIB3000MB_REG_SEQ,seq);
+	
+	wr(DIB3000MB_REG_ISI,seq ? DIB3000MB_ISI_INHIBIT : DIB3000MB_ISI_ACTIVATE);
+
+	if (ofdm->transmission_mode == TRANSMISSION_MODE_2K) {
+		if (ofdm->guard_interval == GUARD_INTERVAL_1_8) {
+			wr(DIB3000MB_REG_SYNC_IMPROVEMENT,DIB3000MB_SYNC_IMPROVE_2K_1_8);
+		} else {
+			wr(DIB3000MB_REG_SYNC_IMPROVEMENT,DIB3000MB_SYNC_IMPROVE_DEFAULT);
+		}
+		
+		wr(DIB3000MB_REG_UNK_121,DIB3000MB_UNK_121_2K);
+	} else {
+		wr(DIB3000MB_REG_UNK_121,DIB3000MB_UNK_121_DEFAULT);
+	}
+
+	wr(DIB3000MB_REG_MOBILE_ALGO,DIB3000MB_MOBILE_ALGO_OFF);
+	wr(DIB3000MB_REG_MOBILE_MODE_QAM,DIB3000MB_MOBILE_MODE_QAM_OFF);
+	wr(DIB3000MB_REG_MOBILE_MODE,DIB3000MB_MOBILE_MODE_OFF);
+		
+	wr_foreach(dib3000mb_reg_agc_bandwidth,dib3000mb_agc_bandwidth_high);
+	
+	wr(DIB3000MB_REG_ISI,DIB3000MB_ISI_ACTIVATE);
+
+	wr(DIB3000MB_REG_RESTART,DIB3000MB_RESTART_AGC+DIB3000MB_RESTART_CTRL);
+	wr(DIB3000MB_REG_RESTART,DIB3000MB_RESTART_OFF);
+	
+	/* wait for AGC lock */
+	msleep(70);
+
+	wr_foreach(dib3000mb_reg_agc_bandwidth,dib3000mb_agc_bandwidth_low);
+	
+	/* something has to be auto searched */ 
+	if (ofdm->constellation == QAM_AUTO ||
+		ofdm->hierarchy_information == HIERARCHY_AUTO ||
+		fe_cr == FEC_AUTO || 
+		fep->inversion == INVERSION_AUTO) {
+		
+		deb_info("autosearch enabled.\n");	
+		
+		wr(DIB3000MB_REG_ISI,DIB3000MB_ISI_INHIBIT);
+		
+		wr(DIB3000MB_REG_RESTART,DIB3000MB_RESTART_AUTO_SEARCH);
+		wr(DIB3000MB_REG_RESTART,DIB3000MB_RESTART_OFF);
+		
+		while ((search_state = dib3000mb_fe_read_search_status(state)) < 0);
+		
+		return search_state ? 0 : -EINVAL;
+	} else {
+		wr(DIB3000MB_REG_RESTART,DIB3000MB_RESTART_CTRL);
+		wr(DIB3000MB_REG_RESTART,DIB3000MB_RESTART_OFF);
+		msleep(70);
+	}
+	return 0;
+}
+
+
+static int dib3000mb_fe_init(struct dib3000mb_state *state,int mobile_mode)
+{
+	wr(DIB3000MB_REG_POWER_CONTROL,DIB3000MB_POWER_UP);
+	
+	wr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_AGC);
+	
+	wr(DIB3000MB_REG_RESET_DEVICE,DIB3000MB_RESET_DEVICE);
+	wr(DIB3000MB_REG_RESET_DEVICE,DIB3000MB_RESET_DEVICE_RST);
+	
+	wr(DIB3000MB_REG_CLOCK,DIB3000MB_CLOCK_DEFAULT);
+	
+	wr(DIB3000MB_REG_ELECT_OUT_MODE,DIB3000MB_ELECT_OUT_MODE_ON);
+
+	wr(DIB3000MB_REG_QAM,DIB3000MB_QAM_RESERVED);
+	wr(DIB3000MB_REG_VIT_ALPHA,DIB3000MB_VIT_ALPHA_AUTO);
+	
+	wr(DIB3000MB_REG_DDS_FREQ_MSB,DIB3000MB_DDS_FREQ_MSB);
+	wr(DIB3000MB_REG_DDS_FREQ_LSB,DIB3000MB_DDS_FREQ_LSB);
+
+	wr_foreach(dib3000mb_reg_timing_freq,dib3000mb_timing_freq[2]);
+
+	wr_foreach(dib3000mb_reg_impulse_noise,
+			dib3000mb_impulse_noise_values[DIB3000MB_IMPNOISE_OFF]);
+	
+	wr_foreach(dib3000mb_reg_agc_gain,dib3000mb_default_agc_gain);
+
+	wr(DIB3000MB_REG_PHASE_NOISE,DIB3000MB_PHASE_NOISE_DEFAULT);
+
+	wr_foreach(dib3000mb_reg_phase_noise, dib3000mb_default_noise_phase);
+	
+	wr_foreach(dib3000mb_reg_lock_duration,dib3000mb_default_lock_duration);
+
+	wr_foreach(dib3000mb_reg_agc_bandwidth,dib3000mb_agc_bandwidth_low);
+
+	wr(DIB3000MB_REG_LOCK0_MASK,DIB3000MB_LOCK0_DEFAULT);
+	wr(DIB3000MB_REG_LOCK1_MASK,DIB3000MB_LOCK1_SEARCH_4);
+	wr(DIB3000MB_REG_LOCK2_MASK,DIB3000MB_LOCK2_DEFAULT);
+	wr(DIB3000MB_REG_SEQ,dib3000mb_seq[1][1][1]);
+		
+	wr_foreach(dib3000mb_reg_bandwidth,dib3000mb_bandwidth_8mhz);
+	
+	wr(DIB3000MB_REG_UNK_68,DIB3000MB_UNK_68);
+	wr(DIB3000MB_REG_UNK_69,DIB3000MB_UNK_69);
+	wr(DIB3000MB_REG_UNK_71,DIB3000MB_UNK_71);
+	wr(DIB3000MB_REG_UNK_77,DIB3000MB_UNK_77);
+	wr(DIB3000MB_REG_UNK_78,DIB3000MB_UNK_78);
+	wr(DIB3000MB_REG_ISI,DIB3000MB_ISI_INHIBIT);
+	wr(DIB3000MB_REG_UNK_92,DIB3000MB_UNK_92);
+	wr(DIB3000MB_REG_UNK_96,DIB3000MB_UNK_96);
+	wr(DIB3000MB_REG_UNK_97,DIB3000MB_UNK_97);
+	wr(DIB3000MB_REG_UNK_106,DIB3000MB_UNK_106);
+	wr(DIB3000MB_REG_UNK_107,DIB3000MB_UNK_107);
+	wr(DIB3000MB_REG_UNK_108,DIB3000MB_UNK_108);
+	wr(DIB3000MB_REG_UNK_122,DIB3000MB_UNK_122);
+	wr(DIB3000MB_REG_MOBILE_MODE_QAM,DIB3000MB_MOBILE_MODE_QAM_OFF);
+	wr(DIB3000MB_REG_VIT_CODE_RATE,DIB3000MB_FEC_1_2);
+	wr(DIB3000MB_REG_VIT_HP,DIB3000MB_VIT_HP);
+	wr(DIB3000MB_REG_BERLEN,DIB3000MB_BERLEN_DEFAULT);
+
+	wr_foreach(dib3000mb_reg_filter_coeffs,dib3000mb_filter_coeffs);
+
+	wr(DIB3000MB_REG_MOBILE_ALGO,DIB3000MB_MOBILE_ALGO_ON);
+	wr(DIB3000MB_REG_MULTI_DEMOD_MSB,DIB3000MB_MULTI_DEMOD_MSB);
+	wr(DIB3000MB_REG_MULTI_DEMOD_LSB,DIB3000MB_MULTI_DEMOD_LSB);
+
+	wr(DIB3000MB_REG_OUTPUT_MODE,DIB3000MB_OUTPUT_MODE_SLAVE);
+
+	wr(DIB3000MB_REG_FIFO_142,DIB3000MB_FIFO_142);
+	wr(DIB3000MB_REG_MPEG2_OUT_MODE,DIB3000MB_MPEG2_OUT_MODE_188);
+	wr(DIB3000MB_REG_FIFO_144,DIB3000MB_FIFO_144);
+	wr(DIB3000MB_REG_FIFO,DIB3000MB_FIFO_INHIBIT);
+	wr(DIB3000MB_REG_FIFO_146,DIB3000MB_FIFO_146);
+	wr(DIB3000MB_REG_FIFO_147,DIB3000MB_FIFO_147);
+	
+	wr(DIB3000MB_REG_DATA_IN_DIVERSITY,DIB3000MB_DATA_DIVERSITY_IN_OFF);	
+	return 0;
+}
+
+static int dib3000mb_read_status(struct dib3000mb_state *state,fe_status_t *stat)
+{
+	*stat = 0;
+	*stat |= rd(DIB3000MB_REG_AGC_LOCK) ? FE_HAS_SIGNAL : 0;
+	*stat |= rd(DIB3000MB_REG_CARRIER_LOCK) ? FE_HAS_CARRIER : 0;
+	*stat |= rd(DIB3000MB_REG_VIT_LCK) ? FE_HAS_VITERBI : 0;
+	*stat |= rd(DIB3000MB_REG_TS_SYNC_LOCK) ? FE_HAS_SYNC : 0;
+	*stat |= *stat ? FE_HAS_LOCK : 0;
+
+	deb_info("actual status is %2x\n",*stat);
+	
+	deb_info("autoval: tps: %d, qam: %d, hrch: %d, alpha: %d, hp: %d, lp: %d, guard: %d, fft: %d cell: %d\n",
+			rd(DIB3000MB_REG_TPS_LOCK),
+			rd(DIB3000MB_REG_TPS_QAM), 
+			rd(DIB3000MB_REG_TPS_HRCH),
+			rd(DIB3000MB_REG_TPS_VIT_ALPHA),
+			rd(DIB3000MB_REG_TPS_CODE_RATE_HP),
+			rd(DIB3000MB_REG_TPS_CODE_RATE_LP), 
+			rd(DIB3000MB_REG_TPS_GUARD_TIME),
+			rd(DIB3000MB_REG_TPS_FFT),
+			rd(DIB3000MB_REG_TPS_CELL_ID));
+
+	//*stat = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+	return 0;
+}
+
+static int dib3000mb_read_ber(struct dib3000mb_state *state,u32 *ber)
+{
+	*ber = 
+		(((rd(DIB3000MB_REG_BER_MSB) << 16) & 0x1f) | rd(DIB3000MB_REG_BER_LSB) ) /
+		 100000000;
+	return 0;
+}
+
+static int dib3000mb_signal_strength(struct dib3000mb_state *state, u16 *strength)
+{
+//	*stength = DIB3000MB_REG_SIGNAL_POWER 
+	return 0;
+}
+
+static int dib3000mb_sleep(struct dib3000mb_state *state)
+{
+	wr(DIB3000MB_REG_POWER_CONTROL,DIB3000MB_POWER_DOWN);
+	return 0;
+}
+
+static int dib3000mb_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
+{
+	struct dib3000mb_state *state = fe->data;
+	int ret = 0;		
+	switch (cmd) {
+		case FE_GET_INFO:
+			deb_info("FE_GET_INFO\n");
+			memcpy(arg, &dib3000mb_info, sizeof(struct dvb_frontend_info));
+			break;
+
+		case FE_READ_STATUS: 
+			deb_info("FE_READ_STATUS\n");
+			ret = dib3000mb_read_status(state,(fe_status_t *)arg);
+			break;
+
+		case FE_READ_BER:
+			deb_info("FE_READ_BER\n");
+			ret = dib3000mb_read_ber(state,(u32 *)arg);
+			break;
+
+		case FE_READ_SIGNAL_STRENGTH:
+			deb_info("FE_READ_SIG_STRENGTH\n");
+			ret = dib3000mb_signal_strength(state,(u16 *) arg);
+			break;
+
+		case FE_READ_SNR:
+			deb_info("FE_READ_SNR\n");
+			break;
+
+		case FE_READ_UNCORRECTED_BLOCKS: 
+			deb_info("FE_READ_UNCORRECTED_BLOCKS\n");
+			break;
+
+		case FE_SET_FRONTEND:
+			deb_info("FE_SET_FRONTEND\n");
+			ret = dib3000mb_set_frontend(state,(struct dvb_frontend_parameters *) arg,1);
+			break;
+
+		case FE_GET_FRONTEND:
+			deb_info("FE_GET_FRONTEND\n");
+			ret = dib3000mb_get_frontend(state,(struct dvb_frontend_parameters *) arg);
+			break;
+
+		case FE_SLEEP:
+			deb_info("FE_SLEEP\n");
+			ret = dib3000mb_sleep(state);
+			break;
+
+		case FE_INIT:
+			deb_info("FE_INIT\n");
+			ret = dib3000mb_fe_init(state,0);
+			break;
+
+		case FE_SET_TONE:
+		case FE_SET_VOLTAGE:
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+	return 0;
+} 
+
+static struct i2c_client client_template;
+
+static int dib3000mb_attach_adapter(struct i2c_adapter *adapter)
+{
+	struct i2c_client *client;
+	struct dib3000mb_state *state;
+	int ret = -ENOMEM;
+
+	deb_info("i2c probe with adapter '%s'.\n",adapter->name);
+	
+	if ((state = kmalloc(sizeof(struct dib3000mb_state),GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+	
+
+	if ((client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)) == NULL)
+		goto i2c_kmalloc_err;
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+
+	client->adapter = adapter;
+	client->addr = 0x10; 
+	state->i2c = client;
+	
+	i2c_set_clientdata(client,state);
+
+	state->manufactor_id = dib3000mb_read_reg(client, DIB3000MB_REG_MANUFACTOR_ID);
+	state->device_id = dib3000mb_read_reg(client,DIB3000MB_REG_DEVICE_ID);
+	if (state->manufactor_id == 0x01b3 && state->device_id == 0x3000) 
+		info("found a DiBCom (0x%04x) 3000-MB DVB-T frontend (ver: %x).",
+				state->manufactor_id, state->device_id);
+	else {
+		err("did not found a DiBCom 3000-MB.");
+		ret = -ENODEV;
+		goto probe_err;
+	}
+	
+	if ((ret = i2c_attach_client(client))) 
+		goto i2c_attach_err;
+
+	if (state->dvb == NULL) 
+		goto i2c_attach_err;
+
+	if ((ret = dvb_register_frontend(dib3000mb_ioctl, state->dvb, state,
+					     &dib3000mb_info, THIS_MODULE)))
+		goto dvb_fe_err;
+	
+	
+	goto success;
+dvb_fe_err:
+	i2c_detach_client(client);
+i2c_attach_err:
+probe_err:
+	kfree(client);
+i2c_kmalloc_err:
+	kfree(state);
+	return ret;
+success:
+	return 0;
+}
+
+
+static int dib3000mb_detach_client(struct i2c_client *client)
+{
+	struct dib3000mb_state *state = i2c_get_clientdata(client);
+
+	deb_info("i2c detach\n");
+
+	dvb_unregister_frontend(dib3000mb_ioctl, state->dvb);
+	i2c_detach_client(client);
+	kfree(client);
+	kfree(state);
+
+	return 0;
+}
+
+static int dib3000mb_command(struct i2c_client *client,
+			      unsigned int cmd, void *arg)
+{
+	struct dib3000mb_state *state = i2c_get_clientdata(client);
+	deb_info("i2c command.\n");
+	switch(cmd) {
+		case FE_REGISTER:
+			state->dvb = arg;
+			break;
+		case FE_UNREGISTER:
+			state->dvb = NULL;
+			break;
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static struct i2c_driver driver = {
+	.owner		= THIS_MODULE,
+	.name		= "dib3000mb",
+	.id			= I2C_DRIVERID_DVBFE_DIB3000MB,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= dib3000mb_attach_adapter,
+	.detach_client	= dib3000mb_detach_client,
+	.command	= dib3000mb_command,
+};
+
+static struct i2c_client client_template = {
+	.name		= "dib3000mb",
+	.flags		= I2C_CLIENT_ALLOW_USE,
+	.driver		= &driver,
+};
+
+/* module stuff */
+static int __init dib3000mb_init(void)
+{
+	deb_info("debugging level: %d\n",debug);
+	return i2c_add_driver(&driver);
+}
+
+static void __exit dib3000mb_exit(void)
+{
+	i2c_del_driver(&driver);
+}
+
+module_init (dib3000mb_init);
+module_exit (dib3000mb_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/dib3000mb.h linux/drivers/media/dvb/frontends/dib3000mb.h
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/dib3000mb.h	2004-09-17 14:56:38.804600119 +0200
+++ linux/drivers/media/dvb/frontends/dib3000mb.h	2004-09-17 14:56:38.805599931 +0200
@@ -0,0 +1,657 @@
+/*
+ * dib3000mb.h
+ * 
+ * Copyright (C) 2004 Patrick Boettcher (patrick.boettcher@desy.de)
+ * 
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ * 
+ * for more information see dib3000mb.c .
+ */
+
+#ifndef __DIB3000MB_H_INCLUDED__
+#define __DIB3000MB_H_INCLUDED__
+
+/* info and err, taken from usb.h, if there is anything available like by default,
+ * please change !
+ */
+#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , __FILE__ , ## arg)
+#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , __FILE__ , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , __FILE__ , ## arg)
+
+/* register addresses and some of their default values */
+
+/* restart subsystems */
+#define DIB3000MB_REG_RESTART			(     0)
+
+#define DIB3000MB_RESTART_OFF			(     0)
+#define DIB3000MB_RESTART_AUTO_SEARCH		(1 << 1)
+#define DIB3000MB_RESTART_CTRL				(1 << 2)
+#define DIB3000MB_RESTART_AGC				(1 << 3)
+
+/* FFT size */
+#define DIB3000MB_REG_FFT				(     1)
+#define DIB3000MB_FFT_2K					(     0)
+#define DIB3000MB_FFT_8K					(     1)
+#define DIB3000MB_FFT_AUTO					(     1)
+
+/* Guard time */
+#define DIB3000MB_REG_GUARD_TIME		(     2)
+#define DIB3000MB_GUARD_TIME_1_32			(     0)
+#define DIB3000MB_GUARD_TIME_1_16			(     1)
+#define DIB3000MB_GUARD_TIME_1_8			(     2)
+#define DIB3000MB_GUARD_TIME_1_4			(     3)
+#define DIB3000MB_GUARD_TIME_AUTO			(     0)
+
+/* QAM */
+#define DIB3000MB_REG_QAM				(     3)
+#define DIB3000MB_QAM_QPSK					(     0)
+#define DIB3000MB_QAM_QAM16					(     1)
+#define DIB3000MB_QAM_QAM64					(     2)
+#define DIB3000MB_QAM_RESERVED				(     3)
+
+/* Alpha coefficient high priority Viterbi algorithm */
+#define DIB3000MB_REG_VIT_ALPHA			(     4)
+#define DIB3000MB_VIT_ALPHA_OFF				(     0)
+#define DIB3000MB_VIT_ALPHA_1				(     1)
+#define DIB3000MB_VIT_ALPHA_2				(     2)
+#define DIB3000MB_VIT_ALPHA_4				(     4)
+#define DIB3000MB_VIT_ALPHA_AUTO			(     7)
+
+/* spectrum inversion */
+#define DIB3000MB_REG_DDS_INV			(     5)
+#define DIB3000MB_DDS_INV_OFF				(     0)
+#define DIB3000MB_DDS_INV_ON				(     1)
+
+/* DDS frequency value (IF position) ad ? values don't match reg_3000mb.txt */ 
+#define DIB3000MB_REG_DDS_FREQ_MSB		(     6)
+#define DIB3000MB_REG_DDS_FREQ_LSB		(     7)
+#define DIB3000MB_DDS_FREQ_MSB				(   178)
+#define DIB3000MB_DDS_FREQ_LSB				(  8990)
+
+/* timing frequency (carrier spacing) */
+#define DIB3000MB_REG_TIMING_FREQ_MSB	(     8)
+#define DIB3000MB_REG_TIMING_FREQ_LSB	(     9)
+
+static u16 dib3000mb_reg_timing_freq[] = {
+	DIB3000MB_REG_TIMING_FREQ_MSB, DIB3000MB_REG_TIMING_FREQ_LSB 
+};
+static u16 dib3000mb_timing_freq[][2] = {
+	{ 126 , 48873 }, /* 6 MHz */
+	{ 147 , 57019 }, /* 7 MHz */ 
+	{ 168 , 65164 }, /* 8 MHz */
+};
+
+/* impulse noise parameter */
+#define DIB3000MB_REG_IMPNOISE_10		(    10)
+#define DIB3000MB_REG_IMPNOISE_11		(    11)
+#define DIB3000MB_REG_IMPNOISE_12		(    12)
+#define DIB3000MB_REG_IMPNOISE_13		(    13)
+#define DIB3000MB_REG_IMPNOISE_14		(    14)
+#define DIB3000MB_REG_IMPNOISE_15		(    15)
+/* 36 ??? */
+#define DIB3000MB_REG_IMPNOISE_36		(    36)
+
+enum dib3000mb_impulse_noise_type {
+	DIB3000MB_IMPNOISE_OFF,
+	DIB3000MB_IMPNOISE_MOBILE,
+	DIB3000MB_IMPNOISE_FIXED,
+	DIB3000MB_IMPNOISE_DEFAULT
+};
+
+static u16 dib3000mb_reg_impulse_noise[] = {
+ DIB3000MB_REG_IMPNOISE_10, DIB3000MB_REG_IMPNOISE_11, 
+ DIB3000MB_REG_IMPNOISE_12, DIB3000MB_REG_IMPNOISE_15,
+ DIB3000MB_REG_IMPNOISE_36
+};
+
+static u16 dib3000mb_impulse_noise_values[][5] = {
+	{ 0x0000, 0x0004, 0x0014, 0x01ff, 0x0399 }, /* off */
+	{ 0x0001, 0x0004, 0x0014, 0x01ff, 0x037b }, /* mobile */
+	{ 0x0001, 0x0004, 0x0020, 0x01bd, 0x0399 }, /* fixed */
+	{ 0x0000, 0x0002, 0x000a, 0x01ff, 0x0399 }, /* default */
+};
+
+/* 
+ * Dual Automatic-Gain-Control 
+ * - gains RF in tuner (AGC1) 
+ * - gains IF after filtering (AGC2)
+ */
+
+/* also from 16 to 18 */
+#define DIB3000MB_REG_AGC_GAIN_19		(    19)
+#define DIB3000MB_REG_AGC_GAIN_20		(    20)
+#define DIB3000MB_REG_AGC_GAIN_21		(    21)
+#define DIB3000MB_REG_AGC_GAIN_22		(    22)
+#define DIB3000MB_REG_AGC_GAIN_23		(    23)
+#define DIB3000MB_REG_AGC_GAIN_24		(    24)
+#define DIB3000MB_REG_AGC_GAIN_25		(    25)
+#define DIB3000MB_REG_AGC_GAIN_26		(    26)
+#define DIB3000MB_REG_AGC_GAIN_27		(    27)
+#define DIB3000MB_REG_AGC_GAIN_28		(    28)
+#define DIB3000MB_REG_AGC_GAIN_29		(    29)
+#define DIB3000MB_REG_AGC_GAIN_30		(    30)
+#define DIB3000MB_REG_AGC_GAIN_31		(    31)
+#define DIB3000MB_REG_AGC_GAIN_32		(    32)
+
+static u16 dib3000mb_reg_agc_gain[] = {
+  DIB3000MB_REG_AGC_GAIN_19, DIB3000MB_REG_AGC_GAIN_20, DIB3000MB_REG_AGC_GAIN_21,
+  DIB3000MB_REG_AGC_GAIN_22, DIB3000MB_REG_AGC_GAIN_23, DIB3000MB_REG_AGC_GAIN_24,
+  DIB3000MB_REG_AGC_GAIN_25, DIB3000MB_REG_AGC_GAIN_26, DIB3000MB_REG_AGC_GAIN_27,
+  DIB3000MB_REG_AGC_GAIN_28, DIB3000MB_REG_AGC_GAIN_29, DIB3000MB_REG_AGC_GAIN_30,
+  DIB3000MB_REG_AGC_GAIN_31, DIB3000MB_REG_AGC_GAIN_32 };
+  
+static u16 dib3000mb_default_agc_gain[] =
+	{ 0x0001, 52429,   623, 128, 166, 195, 61,   /* RF ??? */
+	  0x0001, 53766, 38011,   0,  90,  33, 23 }; /* IF ??? */
+
+/* phase noise */
+#define DIB3000MB_REG_PHASE_NOISE_33		(    33)
+#define DIB3000MB_REG_PHASE_NOISE_34		(    34)
+#define DIB3000MB_REG_PHASE_NOISE_35		(    35)
+#define DIB3000MB_REG_PHASE_NOISE_36		(    36)
+#define DIB3000MB_REG_PHASE_NOISE_37		(    37)
+#define DIB3000MB_REG_PHASE_NOISE_38		(    38)
+
+/* DIB3000MB_REG_PHASE_NOISE_36 is set when setting the impulse noise */
+static u16 dib3000mb_reg_phase_noise[] = {
+	DIB3000MB_REG_PHASE_NOISE_33, DIB3000MB_REG_PHASE_NOISE_34, DIB3000MB_REG_PHASE_NOISE_35,
+	DIB3000MB_REG_PHASE_NOISE_37, DIB3000MB_REG_PHASE_NOISE_38
+};
+
+static u16 dib3000mb_default_noise_phase[] = { 2, 544, 0, 5, 4 };
+
+/* lock duration */
+#define DIB3000MB_REG_LOCK_DURATION_39	(    39)
+#define DIB3000MB_REG_LOCK_DURATION_40	(    40)
+
+static u16 dib3000mb_reg_lock_duration[] = {
+	DIB3000MB_REG_LOCK_DURATION_39, DIB3000MB_REG_LOCK_DURATION_40
+};
+
+static u16 dib3000mb_default_lock_duration[] = { 135, 135 };
+
+/* AGC loop bandwidth */
+
+#define DIB3000MB_REG_AGC_BW_43			(    43)
+#define DIB3000MB_REG_AGC_BW_44			(    44)
+#define DIB3000MB_REG_AGC_BW_45			(    45)
+#define DIB3000MB_REG_AGC_BW_46			(    46)
+#define DIB3000MB_REG_AGC_BW_47			(    47)
+#define DIB3000MB_REG_AGC_BW_48			(    48)
+#define DIB3000MB_REG_AGC_BW_49			(    49)
+#define DIB3000MB_REG_AGC_BW_50			(    50)
+
+static u16 dib3000mb_reg_agc_bandwidth[] = {
+	DIB3000MB_REG_AGC_BW_43, DIB3000MB_REG_AGC_BW_44, DIB3000MB_REG_AGC_BW_45, 
+	DIB3000MB_REG_AGC_BW_46, DIB3000MB_REG_AGC_BW_47, DIB3000MB_REG_AGC_BW_48,
+	DIB3000MB_REG_AGC_BW_49, DIB3000MB_REG_AGC_BW_50
+};
+
+static u16 dib3000mb_agc_bandwidth_low[]  = 
+	{ 2088, 10, 2088, 10, 3448, 5, 3448, 5 };
+static u16 dib3000mb_agc_bandwidth_high[] = 
+	{ 2349,  5, 2349,  5, 2586, 2, 2586, 2 };
+
+/* 
+ * lock0 definition (coff_lock) 
+ */
+#define DIB3000MB_REG_LOCK0_MASK		(    51)
+#define DIB3000MB_LOCK0_DEFAULT				(     4)
+
+/*
+ * lock1 definition (cpil_lock)
+ * for auto search 
+ * which values hide behind the lock masks 
+ */
+#define DIB3000MB_REG_LOCK1_MASK		(    52)
+#define DIB3000MB_LOCK1_SEARCH_4			(0x0004)
+#define DIB3000MB_LOCK1_SEARCH_2048			(0x0800)
+#define DIB3000MB_LOCK1_DEFAULT				(0x0001)
+
+/*
+ * lock2 definition (fec_lock) */
+#define DIB3000MB_REG_LOCK2_MASK		(    53)
+#define DIB3000MB_LOCK2_DEFAULT				(0x0080)
+
+/* 
+ * SEQ ? what was that again ... :) 
+ * changes when, inversion, guard time and fft is
+ * either automatically detected or not
+ */
+#define DIB3000MB_REG_SEQ				(    54)
+
+/* all values have been set manually */
+static u16 dib3000mb_seq[2][2][2] = 	/* fft,gua,   inv   */
+	{ /* fft */ 
+		{ /* gua */ 
+			{ 0, 1 },					/*  0   0   { 0,1 } */
+			{ 3, 9 },					/*  0   1   { 0,1 } */
+		},
+		{ 
+			{ 2, 5 },					/*  1   0   { 0,1 } */
+			{ 6, 11 },					/*  1   1   { 0,1 } */
+		}
+	};
+
+/* bandwidth */
+#define DIB3000MB_REG_BW_55				(    55)
+#define DIB3000MB_REG_BW_56				(    56)
+#define DIB3000MB_REG_BW_57				(    57)
+#define DIB3000MB_REG_BW_58				(    58)
+#define DIB3000MB_REG_BW_59				(    59)
+#define DIB3000MB_REG_BW_60				(    60)
+#define DIB3000MB_REG_BW_61				(    61)
+#define DIB3000MB_REG_BW_62				(    62)
+#define DIB3000MB_REG_BW_63				(    63)
+#define DIB3000MB_REG_BW_64				(    64)
+#define DIB3000MB_REG_BW_65				(    65)
+#define DIB3000MB_REG_BW_66				(    66)
+#define DIB3000MB_REG_BW_67				(    67)
+
+static u16 dib3000mb_reg_bandwidth[] = {
+	DIB3000MB_REG_BW_55, DIB3000MB_REG_BW_56, DIB3000MB_REG_BW_57, 
+	DIB3000MB_REG_BW_58, DIB3000MB_REG_BW_59, DIB3000MB_REG_BW_60,
+	DIB3000MB_REG_BW_61, DIB3000MB_REG_BW_62, DIB3000MB_REG_BW_63,
+	DIB3000MB_REG_BW_64, DIB3000MB_REG_BW_65, DIB3000MB_REG_BW_66, 
+	DIB3000MB_REG_BW_67
+};
+
+static u16 dib3000mb_bandwidth_6mhz[] = 
+	{ 0, 33, 53312, 112, 46635, 563, 36565, 0, 1000, 0, 1010, 1, 45264 };
+
+static u16 dib3000mb_bandwidth_7mhz[] =
+	{ 0, 28, 64421,  96, 39973, 483,  3255, 0, 1000, 0, 1010, 1, 45264 };
+
+static u16 dib3000mb_bandwidth_8mhz[] =
+	{ 0, 25, 23600,  84, 34976, 422, 43808, 0, 1000, 0, 1010, 1, 45264 };
+
+#define DIB3000MB_REG_UNK_68				(    68)
+#define DIB3000MB_UNK_68						(     0)
+
+#define DIB3000MB_REG_UNK_69				(    69)
+#define DIB3000MB_UNK_69						(     0)
+
+#define DIB3000MB_REG_UNK_71				(    71)
+#define DIB3000MB_UNK_71						(     0)
+
+#define DIB3000MB_REG_UNK_77				(    77)
+#define DIB3000MB_UNK_77						(     6)
+
+#define DIB3000MB_REG_UNK_78				(    78)
+#define DIB3000MB_UNK_78						(0x0080)
+
+/* isi */
+#define DIB3000MB_REG_ISI				(    79)
+#define DIB3000MB_ISI_ACTIVATE				(     0)
+#define DIB3000MB_ISI_INHIBIT				(     1)
+
+/* sync impovement */
+#define DIB3000MB_REG_SYNC_IMPROVEMENT	(    84)
+#define DIB3000MB_SYNC_IMPROVE_2K_1_8		(     3)
+#define DIB3000MB_SYNC_IMPROVE_DEFAULT		(     0)
+
+/* phase noise compensation inhibition */
+#define DIB3000MB_REG_PHASE_NOISE		(    87)
+#define DIB3000MB_PHASE_NOISE_DEFAULT	(     0)
+
+#define DIB3000MB_REG_UNK_92				(    92)
+#define DIB3000MB_UNK_92						(0x0080)
+
+#define DIB3000MB_REG_UNK_96				(    96)
+#define DIB3000MB_UNK_96						(0x0010)
+
+#define DIB3000MB_REG_UNK_97				(    97)
+#define DIB3000MB_UNK_97						(0x0009)
+
+/* mobile mode ??? */
+#define DIB3000MB_REG_MOBILE_MODE		(   101)
+#define DIB3000MB_MOBILE_MODE_ON				(     1)
+#define DIB3000MB_MOBILE_MODE_OFF			(     0)
+
+#define DIB3000MB_REG_UNK_106			(   106)
+#define DIB3000MB_UNK_106					(0x0080)
+
+#define DIB3000MB_REG_UNK_107			(   107)
+#define DIB3000MB_UNK_107					(0x0080)
+
+#define DIB3000MB_REG_UNK_108			(   108)
+#define DIB3000MB_UNK_108					(0x0080)
+
+/* fft ??? */
+#define DIB3000MB_REG_UNK_121			(   121)
+#define DIB3000MB_UNK_121_2K				(     7)
+#define DIB3000MB_UNK_121_DEFAULT			(     5)
+
+#define DIB3000MB_REG_UNK_122			(   122)
+#define DIB3000MB_UNK_122					(  2867)
+
+/* QAM for mobile mode */
+#define DIB3000MB_REG_MOBILE_MODE_QAM	(   126)
+#define DIB3000MB_MOBILE_MODE_QAM_64			(     3)
+#define DIB3000MB_MOBILE_MODE_QAM_QPSK_16	(     1)
+#define DIB3000MB_MOBILE_MODE_QAM_OFF		(     0)
+
+/* 
+ * data diversity when having more than one chip on-board
+ * see also DIB3000MB_OUTPUT_MODE_DATA_DIVERSITY
+ */
+#define DIB3000MB_REG_DATA_IN_DIVERSITY		(   127)
+#define DIB3000MB_DATA_DIVERSITY_IN_OFF			(     0)
+#define DIB3000MB_DATA_DIVERSITY_IN_ON			(     2)
+
+/* vit hrch */
+#define DIB3000MB_REG_VIT_HRCH			(   128)
+#define DIB3000MB_VIT_HRCH_ON				(     1)
+#define DIB3000MB_VIT_HRCH_OFF				(     0)
+
+/* vit code rate */
+#define DIB3000MB_REG_VIT_CODE_RATE		(   129)
+
+/* forward error correction code rates */
+#define DIB3000MB_FEC_1_2					(     0)
+#define DIB3000MB_FEC_2_3					(     1)
+#define DIB3000MB_FEC_3_4					(     2)
+#define DIB3000MB_FEC_4_5					(     3)
+#define DIB3000MB_FEC_5_6					(     4)
+#define DIB3000MB_FEC_7_8					(     5)
+
+/* vit select hp */
+#define DIB3000MB_REG_VIT_HP			(   130)
+#define DIB3000MB_VIT_LP					(     0)
+#define DIB3000MB_VIT_HP					(     1)
+
+/* time frame for Bit-Error-Rate calculation */
+#define DIB3000MB_REG_BERLEN			(   135)
+#define DIB3000MB_BERLEN_LONG				(     0)
+#define DIB3000MB_BERLEN_DEFAULT			(     1)
+#define DIB3000MB_BERLEN_MEDIUM				(     2)
+#define DIB3000MB_BERLEN_SHORT				(     3)
+
+/* 142 - 152 FIFO parameters 
+ * which is what ?
+ */
+
+#define DIB3000MB_REG_FIFO_142			(   142)
+#define DIB3000MB_FIFO_142					(     0)
+
+/* MPEG2 TS output mode */
+#define DIB3000MB_REG_MPEG2_OUT_MODE	(   143)
+#define DIB3000MB_MPEG2_OUT_MODE_204		(     0)
+#define DIB3000MB_MPEG2_OUT_MODE_188		(     1)
+
+#define DIB3000MB_REG_FIFO_144			(   144)
+#define DIB3000MB_FIFO_144					(     1)
+
+#define DIB3000MB_REG_FIFO				(   145)
+#define DIB3000MB_FIFO_INHIBIT				(     1)
+#define DIB3000MB_FIFO_ACTIVATE				(     0)
+
+#define DIB3000MB_REG_FIFO_146			(   146)
+#define DIB3000MB_FIFO_146					(     3)
+
+#define DIB3000MB_REG_FIFO_147			(   147)
+#define DIB3000MB_FIFO_147					(0x0100)
+
+/* 
+ * pidfilter 
+ * it is not a hardware pidfilter but a filter which drops all pids
+ * except the ones set. Necessary because of the limited USB1.1 bandwidth.
+ */
+#define DIB3000MB_REG_FILTER_PID_0		(   153)
+#define DIB3000MB_REG_FILTER_PID_1		(   154)
+#define DIB3000MB_REG_FILTER_PID_2		(   155)
+#define DIB3000MB_REG_FILTER_PID_3		(   156)
+#define DIB3000MB_REG_FILTER_PID_4		(   157)
+#define DIB3000MB_REG_FILTER_PID_5		(   158)
+#define DIB3000MB_REG_FILTER_PID_6		(   159)
+#define DIB3000MB_REG_FILTER_PID_7		(   160)
+#define DIB3000MB_REG_FILTER_PID_8		(   161)
+#define DIB3000MB_REG_FILTER_PID_9		(   162)
+#define DIB3000MB_REG_FILTER_PID_10		(   163)
+#define DIB3000MB_REG_FILTER_PID_11		(   164)
+#define DIB3000MB_REG_FILTER_PID_12		(   165)
+#define DIB3000MB_REG_FILTER_PID_13		(   166)
+#define DIB3000MB_REG_FILTER_PID_14		(   167)
+#define DIB3000MB_REG_FILTER_PID_15		(   168)
+
+#define DIB3000MB_ACTIVATE_FILTERING			(0x2000)
+
+/*
+ * output mode
+ * USB devices have to use 'slave'-mode
+ * see also DIB3000MB_REG_ELECT_OUT_MODE
+ */
+#define DIB3000MB_REG_OUTPUT_MODE		(   169)
+#define DIB3000MB_OUTPUT_MODE_GATED_CLK		(     0)
+#define DIB3000MB_OUTPUT_MODE_CONT_CLK		(     1)
+#define DIB3000MB_OUTPUT_MODE_SERIAL		(     2)
+#define DIB3000MB_OUTPUT_MODE_DATA_DIVERSITY	(     5)
+#define DIB3000MB_OUTPUT_MODE_SLAVE			(     6)
+
+/* irq event mask */
+#define DIB3000MB_REG_IRQ_EVENT_MASK		(   170)
+#define DIB3000MB_IRQ_EVENT_MASK				(     0)
+
+/* filter coefficients */
+#define DIB3000MB_REG_FILTER_COEF_171	(   171)
+#define DIB3000MB_REG_FILTER_COEF_172	(   172)
+#define DIB3000MB_REG_FILTER_COEF_173	(   173)
+#define DIB3000MB_REG_FILTER_COEF_174	(   174)
+#define DIB3000MB_REG_FILTER_COEF_175	(   175)
+#define DIB3000MB_REG_FILTER_COEF_176	(   176)
+#define DIB3000MB_REG_FILTER_COEF_177	(   177)
+#define DIB3000MB_REG_FILTER_COEF_178	(   178)
+#define DIB3000MB_REG_FILTER_COEF_179	(   179)
+#define DIB3000MB_REG_FILTER_COEF_180	(   180)
+#define DIB3000MB_REG_FILTER_COEF_181	(   181)
+#define DIB3000MB_REG_FILTER_COEF_182	(   182)
+#define DIB3000MB_REG_FILTER_COEF_183	(   183)
+#define DIB3000MB_REG_FILTER_COEF_184	(   184)
+#define DIB3000MB_REG_FILTER_COEF_185	(   185)
+#define DIB3000MB_REG_FILTER_COEF_186	(   186)
+#define DIB3000MB_REG_FILTER_COEF_187	(   187)
+#define DIB3000MB_REG_FILTER_COEF_188	(   188)
+#define DIB3000MB_REG_FILTER_COEF_189	(   189)
+#define DIB3000MB_REG_FILTER_COEF_190	(   190)
+#define DIB3000MB_REG_FILTER_COEF_191	(   191)
+#define DIB3000MB_REG_FILTER_COEF_192	(   192)
+#define DIB3000MB_REG_FILTER_COEF_193	(   193)
+#define DIB3000MB_REG_FILTER_COEF_194	(   194)
+
+static u16 dib3000mb_reg_filter_coeffs[] = {
+	DIB3000MB_REG_FILTER_COEF_171, DIB3000MB_REG_FILTER_COEF_172, DIB3000MB_REG_FILTER_COEF_173,
+	DIB3000MB_REG_FILTER_COEF_174, DIB3000MB_REG_FILTER_COEF_175, DIB3000MB_REG_FILTER_COEF_176,
+	DIB3000MB_REG_FILTER_COEF_177, DIB3000MB_REG_FILTER_COEF_178, DIB3000MB_REG_FILTER_COEF_179,
+	DIB3000MB_REG_FILTER_COEF_180, DIB3000MB_REG_FILTER_COEF_181, DIB3000MB_REG_FILTER_COEF_182,
+	DIB3000MB_REG_FILTER_COEF_183, DIB3000MB_REG_FILTER_COEF_184, DIB3000MB_REG_FILTER_COEF_185,
+	DIB3000MB_REG_FILTER_COEF_186,                                DIB3000MB_REG_FILTER_COEF_188,
+	DIB3000MB_REG_FILTER_COEF_189, DIB3000MB_REG_FILTER_COEF_190, DIB3000MB_REG_FILTER_COEF_191,
+	DIB3000MB_REG_FILTER_COEF_192,                                DIB3000MB_REG_FILTER_COEF_194
+};
+
+static u16 dib3000mb_filter_coeffs[] = {
+	 226,  160,   29, 
+ 	 979,  998,   19,  
+	  22, 1019, 1006, 
+	1022,   12,    6, 
+	1017, 1017,    3,  
+	   6,       1019,
+	1021,    2,    3,
+	   1,          0,
+};
+
+/* 
+ * mobile algorithm (when you are moving with your device) 
+ * but not faster than 90 km/h
+ */
+#define DIB3000MB_REG_MOBILE_ALGO		(   195)
+#define DIB3000MB_MOBILE_ALGO_ON			(     0)
+#define DIB3000MB_MOBILE_ALGO_OFF			(     1)
+
+/* multiple demodulators algorithm */
+#define DIB3000MB_REG_MULTI_DEMOD_MSB	(   206)
+#define DIB3000MB_REG_MULTI_DEMOD_LSB	(   207)
+
+/* terminator, no more demods */
+#define DIB3000MB_MULTI_DEMOD_MSB			( 32767)
+#define DIB3000MB_MULTI_DEMOD_LSB			(  4095)
+
+/* bring the device into a known  */
+#define DIB3000MB_REG_RESET_DEVICE		(  1024)
+#define DIB3000MB_RESET_DEVICE				(0x812c)
+#define DIB3000MB_RESET_DEVICE_RST			(     0)
+
+/* identification registers, manufactor an the device */
+#define DIB3000MB_REG_MANUFACTOR_ID		(  1025)
+#define DIB3000MB_MANUFACTOR_ID_DIBCOM		(0x01B3)
+
+#define DIB3000MB_REG_DEVICE_ID			(  1026)
+#define DIB3000MB_DEVICE_ID					(0x3000)
+
+/* hardware clock configuration */
+#define DIB3000MB_REG_CLOCK				(  1027)
+#define DIB3000MB_CLOCK_DEFAULT				(0x9000)
+#define DIB3000MB_CLOCK_DIVERSITY			(0x92b0)
+
+/* power down config */
+#define DIB3000MB_REG_POWER_CONTROL		(  1028)
+#define DIB3000MB_POWER_DOWN				(     1)
+#define DIB3000MB_POWER_UP					(     0)
+
+/* electrical output mode */
+#define DIB3000MB_REG_ELECT_OUT_MODE	(  1029)
+#define DIB3000MB_ELECT_OUT_MODE_OFF		(     0)
+#define DIB3000MB_ELECT_OUT_MODE_ON			(     1)
+
+/* set the tuner i2c address */
+#define DIB3000MB_REG_TUNER				(  1089)
+#define DIB3000MB_TUNER_ADDR_DEFAULT		(   194)
+#define DIB3000MB_ACTIVATE_TUNER_XFER(a)	(0xffff & (a << 7))
+#define DIB3000MB_DEACTIVATE_TUNER_XFER(a)	(0xffff & ((a << 7) + 0x80)) 
+
+/* monitoring registers (read only) */
+
+/* agc loop locked (size: 1) */
+#define DIB3000MB_REG_AGC_LOCK			(   324)
+
+/* agc power (size: 16) */
+#define DIB3000MB_REG_AGC_POWER			(   325)
+
+/* agc1 value (16) */
+#define DIB3000MB_REG_AGC1_VALUE		(   326)
+
+/* agc2 value (16) */
+#define DIB3000MB_REG_AGC2_VALUE		(   327)
+
+/* total RF power (16), can be used for signal strength */
+#define DIB3000MB_REG_RF_POWER			(   328)
+
+/* dds_frequency with offset (24) */
+#define DIB3000MB_REG_DDS_VALUE_MSB		(   339)
+#define DIB3000MB_REG_DDS_VALUE_LSB		(   340)
+
+/* timing offset signed (24) */
+#define DIB3000MB_REG_TIMING_OFFSET_MSB	(   341)
+#define DIB3000MB_REG_TIMING_OFFSET_LSB	(   342)
+
+/* fft start position (13) */
+#define DIB3000MB_REG_FFT_WINDOW_POS	(   353)
+
+/* carriers locked (1) */
+#define DIB3000MB_REG_CARRIER_LOCK		(   355)
+
+/* noise power (24) */
+#define DIB3000MB_REG_NOISE_POWER_MSB	(   372)
+#define DIB3000MB_REG_NOISE_POWER_LSB	(   373)
+
+#define DIB3000MB_REG_MOBILE_NOISE_MSB	(   374)
+#define DIB3000MB_REG_MOBILE_NOISE_LSB	(   375)
+
+/* 
+ * signal power (16), this and the above can be 
+ * used to calculate the signal/noise - ratio
+ */
+#define DIB3000MB_REG_SIGNAL_POWER		(   380)
+
+/* mer (24) */
+#define DIB3000MB_REG_MER_MSB			(   381)
+#define DIB3000MB_REG_MER_LSB			(   382)
+
+/*
+ * Transmission Parameter Signalling (TPS) 
+ * the following registers can be used to get TPS-information.
+ * The values are according to the DVB-T standard.
+ */
+
+/* TPS locked (1) */
+#define DIB3000MB_REG_TPS_LOCK			(   394)
+
+/* QAM from TPS (2) (values according to DIB3000MB_REG_QAM) */
+#define DIB3000MB_REG_TPS_QAM			(   398)
+
+/* hierarchy from TPS (1) */
+#define DIB3000MB_REG_TPS_HRCH			(   399)
+
+/* alpha from TPS (3) (values according to DIB3000MB_REG_VIT_ALPHA) */
+#define DIB3000MB_REG_TPS_VIT_ALPHA		(   400)
+
+/* code rate high priority from TPS (3) (values according to DIB3000MB_FEC_*) */
+#define DIB3000MB_REG_TPS_CODE_RATE_HP	(   401)
+
+/* code rate low priority from TPS (3) if DIB3000MB_REG_TPS_VIT_ALPHA */
+#define DIB3000MB_REG_TPS_CODE_RATE_LP	(   402)
+
+/* guard time from TPS (2) (values according to DIB3000MB_REG_GUARD_TIME */
+#define DIB3000MB_REG_TPS_GUARD_TIME	(   403)
+
+/* fft size from TPS (2) (values according to DIB3000MB_REG_FFT) */
+#define DIB3000MB_REG_TPS_FFT			(   404)
+
+/* cell id from TPS (16) */
+#define DIB3000MB_REG_TPS_CELL_ID		(   406)
+
+/* TPS (68) */
+#define DIB3000MB_REG_TPS_1				(   408)
+#define DIB3000MB_REG_TPS_2				(   409)
+#define DIB3000MB_REG_TPS_3				(   410)
+#define DIB3000MB_REG_TPS_4				(   411)
+#define DIB3000MB_REG_TPS_5				(   412)
+
+/* bit error rate (before RS correction) (21) */
+#define DIB3000MB_REG_BER_MSB			(   414)
+#define DIB3000MB_REG_BER_LSB			(   415)
+
+/* packet error rate (uncorrected TS packets) (16) */
+#define DIB3000MB_REG_PACKET_ERROR_RATE	(   417)
+
+/* packet error count (16) */
+#define DIB3000MB_REG_PACKET_ERROR_COUNT	(   420)
+
+/* viterbi locked (1) */
+#define DIB3000MB_REG_VIT_LCK			(   421)
+
+/* viterbi inidcator (16) */
+#define DIB3000MB_REG_VIT_INDICATOR		(   422)
+
+/* transport stream sync lock (1) */
+#define DIB3000MB_REG_TS_SYNC_LOCK		(   423)
+
+/* transport stream RS lock (1) */ 
+#define DIB3000MB_REG_TS_RS_LOCK		(   424)
+
+/* lock mask 0 value (1) */
+#define DIB3000MB_REG_LOCK0_VALUE		(   425)
+
+/* lock mask 1 value (1) */
+#define DIB3000MB_REG_LOCK1_VALUE		(   426)
+
+/* lock mask 2 value (1) */
+#define DIB3000MB_REG_LOCK2_VALUE		(   427)
+
+/* interrupt pending for auto search */
+#define DIB3000MB_REG_AS_IRQ_PENDING	(   434)
+
+#endif
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/dst-bt878.h linux/drivers/media/dvb/frontends/dst-bt878.h
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/dst-bt878.h	2004-09-14 10:37:15.000000000 +0200
+++ linux/drivers/media/dvb/frontends/dst-bt878.h	2004-09-17 14:56:38.807599557 +0200
@@ -30,9 +30,8 @@ union dst_gpio_packet {
 #define DST_IG_READ	2
 #define DST_IG_TS       3
 
-struct bt878 ;
+struct bt878;
 
-int
-bt878_device_control(struct bt878 *bt, unsigned int cmd, union dst_gpio_packet *mp);
+int bt878_device_control(struct bt878 *bt, unsigned int cmd, union dst_gpio_packet *mp);
 
-struct bt878 *bt878_find_by_dvb_adap(struct dvb_adapter *adap);
+struct bt878 *bt878_find_by_i2c_adap(struct i2c_adapter *adap);
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/dst.c linux/drivers/media/dvb/frontends/dst.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/dst.c	2004-09-14 10:37:25.000000000 +0200
+++ linux/drivers/media/dvb/frontends/dst.c	2004-09-17 14:56:38.813598433 +0200
@@ -3,8 +3,6 @@
 
     Copyright (C) 2003 Jamie Honan
 
-
-
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -20,7 +18,7 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-*/    
+*/
 
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -32,32 +30,19 @@
 #include <asm/div64.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 #include "dst-bt878.h"
 
-unsigned int dst_debug = 0;
 unsigned int dst_verbose = 0;
-
 MODULE_PARM(dst_verbose, "i");
-MODULE_PARM_DESC(dst_verbose,
-		 "verbose startup messages, default is 1 (yes)");
+MODULE_PARM_DESC(dst_verbose, "verbose startup messages, default is 1 (yes)");
+unsigned int dst_debug = 0;
 MODULE_PARM(dst_debug, "i");
 MODULE_PARM_DESC(dst_debug, "debug messages, default is 0 (no)");
 
-#define DST_MAX_CARDS	6
-unsigned int dst_cur_no = 0;
-
-unsigned int dst_type[DST_MAX_CARDS] = { [0 ... (DST_MAX_CARDS-1)] = (-1U)};
-unsigned int dst_type_flags[DST_MAX_CARDS] = { [0 ... (DST_MAX_CARDS-1)] = (-1U)};
-MODULE_PARM(dst_type, "1-" __stringify(DST_MAX_CARDS) "i");
-MODULE_PARM_DESC(dst_type,
-		"Type of DST card, 0 Satellite, 1 terrestial TV, 2 Cable, default driver determined");
-MODULE_PARM(dst_type_flags, "1-" __stringify(DST_MAX_CARDS) "i");
-MODULE_PARM_DESC(dst_type_flags,
-		"Type flags of DST card, bitfield 1=10 byte tuner, 2=TS is 204, 4=symdiv");
-
 #define dprintk	if (dst_debug) printk
 
+#define DST_I2C_ADDR 0x55
+
 #define DST_TYPE_IS_SAT		0
 #define DST_TYPE_IS_TERR	1
 #define DST_TYPE_IS_CABLE	2
@@ -71,67 +56,65 @@ MODULE_PARM_DESC(dst_type_flags,
 #define HAS_POWER	4
 
 struct dst_data {
-	u8	tx_tuna[10];
-	u8	rx_tuna[10];
-	u8	rxbuffer[10];
-	u8	diseq_flags;
-	u8	dst_type;
-	u32	type_flags;
-	u32 frequency;     /* intermediate frequency in kHz for QPSK */
-        fe_spectral_inversion_t inversion;
-        u32   symbol_rate;  /* symbol rate in Symbols per second */
-	fe_code_rate_t  fec;
+	u8 tx_tuna[10];
+	u8 rx_tuna[10];
+	u8 rxbuffer[10];
+	u8 diseq_flags;
+	u8 dst_type;
+	u32 type_flags;
+	u32 frequency;		/* intermediate frequency in kHz for QPSK */
+	fe_spectral_inversion_t inversion;
+	u32 symbol_rate;	/* symbol rate in Symbols per second */
+	fe_code_rate_t fec;
 	fe_sec_voltage_t voltage;
 	fe_sec_tone_mode_t tone;
 	u32 decode_freq;
-	u8  decode_lock;
+	u8 decode_lock;
 	u16 decode_strength;
 	u16 decode_snr;
 	unsigned long cur_jiff;
-	u8  k22;
+	u8 k22;
 	fe_bandwidth_t bandwidth;
+
 	struct bt878 *bt;
-	struct dvb_i2c_bus *i2c;
-} ;
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
 
 static struct dvb_frontend_info dst_info_sat = {
-	.name 			= "DST SAT",
-	.type 			= FE_QPSK,
-	.frequency_min 		= 950000,
-	.frequency_max 		= 2150000,
-	.frequency_stepsize 	= 1000,           /* kHz for QPSK frontends */
-	.frequency_tolerance 	= 29500,
-	.symbol_rate_min	= 1000000,
-	.symbol_rate_max	= 45000000,
+	.name = "DST SAT",
+	.type = FE_QPSK,
+	.frequency_min = 950000,
+	.frequency_max = 2150000,
+	.frequency_stepsize = 1000,	/* kHz for QPSK frontends */
+	.frequency_tolerance = 29500,
+	.symbol_rate_min = 1000000,
+	.symbol_rate_max = 45000000,
 /*     . symbol_rate_tolerance	= 	???,*/
-	.notifier_delay		= 50,                /* 1/20 s */
-	.caps = FE_CAN_FEC_AUTO |
-		FE_CAN_QPSK
+	.notifier_delay = 50,	/* 1/20 s */
+	.caps = FE_CAN_FEC_AUTO | FE_CAN_QPSK
 };
 
 static struct dvb_frontend_info dst_info_cable = {
-	.name 			= "DST CABLE",
-	.type 			= FE_QAM,
-        .frequency_stepsize 	= 62500,
-	.frequency_min 		= 51000000,
-	.frequency_max 		= 858000000,
-	.symbol_rate_min	= 1000000,
-	.symbol_rate_max	= 45000000,
+	.name = "DST CABLE",
+	.type = FE_QAM,
+	.frequency_stepsize = 62500,
+	.frequency_min = 51000000,
+	.frequency_max = 858000000,
+	.symbol_rate_min = 1000000,
+	.symbol_rate_max = 45000000,
 /*     . symbol_rate_tolerance	= 	???,*/
-	.notifier_delay		= 50,                /* 1/20 s */
-	.caps = FE_CAN_FEC_AUTO |
-		FE_CAN_QAM_AUTO
+	.notifier_delay = 50,	/* 1/20 s */
+	.caps = FE_CAN_FEC_AUTO | FE_CAN_QAM_AUTO
 };
 
-static struct dvb_frontend_info dst_info_tv = {
-	.name 			= "DST TERR",
-	.type 			= FE_OFDM,
-	.frequency_min 		= 137000000,
-	.frequency_max 		= 858000000,
-	.frequency_stepsize 	= 166667,
-	.caps = FE_CAN_FEC_AUTO |
-	    FE_CAN_QAM_AUTO |
-	    FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO
+static struct dvb_frontend_info dst_info_terr = {
+	.name = "DST TERR",
+	.type = FE_OFDM,
+	.frequency_min = 137000000,
+	.frequency_max = 858000000,
+	.frequency_stepsize = 166667,
+	.caps = FE_CAN_FEC_AUTO | FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO
 };
 
 static void dst_packsize(struct dst_data *dst, int psize)
@@ -150,158 +133,151 @@ static int dst_gpio_outb(struct dst_data
 
 	enb.enb.mask = mask;
 	enb.enb.enable = enbb;
-        if ((err = bt878_device_control(dst->bt, DST_IG_ENABLE, &enb)) < 0) {
-		dprintk ("%s: dst_gpio_enb error (err == %i, mask == 0x%02x, enb == 0x%02x)\n", __FUNCTION__, err, mask, enbb);
+	if ((err = bt878_device_control(dst->bt, DST_IG_ENABLE, &enb)) < 0) {
+		dprintk("%s: dst_gpio_enb error (err == %i, mask == 0x%02x, enb == 0x%02x)\n", __FUNCTION__, err, mask, enbb);
 		return -EREMOTEIO;
 	}
 
-	/* because complete disabling means no output, no need to do
-	 * output packet */
+	/* because complete disabling means no output, no need to do output packet */
 	if (enbb == 0)
 		return 0;
 
 	bits.outp.mask = enbb;
 	bits.outp.highvals = outhigh;
 
-        if ((err = bt878_device_control(dst->bt, DST_IG_WRITE, &bits)) < 0) {
-		dprintk ("%s: dst_gpio_outb error (err == %i, enbb == 0x%02x, outhigh == 0x%02x)\n", __FUNCTION__, err, enbb, outhigh);
+	if ((err = bt878_device_control(dst->bt, DST_IG_WRITE, &bits)) < 0) {
+		dprintk("%s: dst_gpio_outb error (err == %i, enbb == 0x%02x, outhigh == 0x%02x)\n", __FUNCTION__, err, enbb, outhigh);
 		return -EREMOTEIO;
 	}
-        return 0;
+	return 0;
 }
 
-static int dst_gpio_inb(struct dst_data *dst, u8 *result)
+static int dst_gpio_inb(struct dst_data *dst, u8 * result)
 {
 	union dst_gpio_packet rd_packet;
 	int err;
 
 	*result = 0;
 
-        if ((err = bt878_device_control(dst->bt, DST_IG_READ, &rd_packet)) < 0) {
-		dprintk ("%s: dst_gpio_inb error (err == %i)\n", __FUNCTION__, err);
+	if ((err = bt878_device_control(dst->bt, DST_IG_READ, &rd_packet)) < 0) {
+		dprintk("%s: dst_gpio_inb error (err == %i)\n", __FUNCTION__, err);
 		return -EREMOTEIO;
 	}
-	*result = (u8)rd_packet.rd.value;
-        return 0;
+	*result = (u8) rd_packet.rd.value;
+	return 0;
 }
 
 #define DST_I2C_ENABLE	1
 #define DST_8820  	2
 
-static int
-dst_reset8820(struct dst_data *dst)
+static int dst_reset8820(struct dst_data *dst)
 {
-int retval;
+	int retval;
 	/* pull 8820 gpio pin low, wait, high, wait, then low */
 	// dprintk ("%s: reset 8820\n", __FUNCTION__);
 	retval = dst_gpio_outb(dst, DST_8820, DST_8820, 0);
 	if (retval < 0)
 		return retval;
-	dvb_delay(10);
+	msleep(10);
 	retval = dst_gpio_outb(dst, DST_8820, DST_8820, DST_8820);
 	if (retval < 0)
 		return retval;
 	/* wait for more feedback on what works here *
-	dvb_delay(10);
-	retval = dst_gpio_outb(dst, DST_8820, DST_8820, 0);
-	if (retval < 0)
-		return retval;
-	*/
+	   msleep(10);
+	   retval = dst_gpio_outb(dst, DST_8820, DST_8820, 0);
+	   if (retval < 0)
+	   return retval;
+	 */
 	return 0;
 }
 
-static int
-dst_i2c_enable(struct dst_data *dst)
+static int dst_i2c_enable(struct dst_data *dst)
 {
-int retval;
+	int retval;
 	/* pull I2C enable gpio pin low, wait */
 	// dprintk ("%s: i2c enable\n", __FUNCTION__);
 	retval = dst_gpio_outb(dst, ~0, DST_I2C_ENABLE, 0);
 	if (retval < 0)
 		return retval;
 	// dprintk ("%s: i2c enable delay\n", __FUNCTION__);
-	dvb_delay(33);
+	msleep(33);	
 	return 0;
 }
 
-static int
-dst_i2c_disable(struct dst_data *dst)
+static int dst_i2c_disable(struct dst_data *dst)
 {
-int retval;
+	int retval;
 	/* release I2C enable gpio pin, wait */
 	// dprintk ("%s: i2c disable\n", __FUNCTION__);
 	retval = dst_gpio_outb(dst, ~0, 0, 0);
 	if (retval < 0)
 		return retval;
 	// dprintk ("%s: i2c disable delay\n", __FUNCTION__);
-	dvb_delay(33);
+	msleep(33);
 	return 0;
 }
 
-static int
-dst_wait_dst_ready(struct dst_data *dst)
+static int dst_wait_dst_ready(struct dst_data *dst)
 {
-u8 reply;
-int retval;
-int i;
+	u8 reply;
+	int retval;
+	int i;
 	for (i = 0; i < 200; i++) {
 		retval = dst_gpio_inb(dst, &reply);
 		if (retval < 0)
 			return retval;
 		if ((reply & DST_I2C_ENABLE) == 0) {
-			dprintk ("%s: dst wait ready after %d\n", __FUNCTION__, i);
+			dprintk("%s: dst wait ready after %d\n", __FUNCTION__, i);
 			return 1;
 		}
-		dvb_delay(5);
+		msleep(5);
 	}
-	dprintk ("%s: dst wait NOT ready after %d\n", __FUNCTION__, i);
+	dprintk("%s: dst wait NOT ready after %d\n", __FUNCTION__, i);
 	return 0;
 }
 
-#define DST_I2C_ADDR 0x55
-
-static int write_dst (struct dst_data *dst, u8 *data, u8 len)
+static int write_dst(struct dst_data *dst, u8 * data, u8 len)
 {
 	struct i2c_msg msg = {
-		.addr = DST_I2C_ADDR, .flags = 0, .buf = data, .len = len };
+		.addr = DST_I2C_ADDR,.flags = 0,.buf = data,.len = len
+	};
 	int err;
 	int cnt;
 
 	if (dst_debug && dst_verbose) {
 		u8 i;
-		dprintk("%s writing",__FUNCTION__);
-		for (i = 0 ; i < len ; i++) {
+		dprintk("%s writing", __FUNCTION__);
+		for (i = 0; i < len; i++) {
 			dprintk(" 0x%02x", data[i]);
 		}
 		dprintk("\n");
 	}
-	dvb_delay(30);
+	msleep(30);
 	for (cnt = 0; cnt < 4; cnt++) {
-		if ((err = dst->i2c->xfer (dst->i2c, &msg, 1)) < 0) {
-			dprintk ("%s: write_dst error (err == %i, len == 0x%02x, b0 == 0x%02x)\n", __FUNCTION__, err, len, data[0]);
+		if ((err = i2c_transfer(dst->i2c, &msg, 1)) < 0) {
+			dprintk("%s: write_dst error (err == %i, len == 0x%02x, b0 == 0x%02x)\n", __FUNCTION__, err, len, data[0]);
 			dst_i2c_disable(dst);
-			dvb_delay(500);
+			msleep(500);
 			dst_i2c_enable(dst);
-			dvb_delay(500);
+			msleep(500);
 			continue;
 		} else
 			break;
 	}
 	if (cnt >= 4)
 		return -EREMOTEIO;
-        return 0;
+	return 0;
 }
 
-static int read_dst (struct dst_data *dst, u8 *ret, u8 len)
+static int read_dst(struct dst_data *dst, u8 * ret, u8 len)
 {
-	struct i2c_msg msg = 
-		{ .addr = DST_I2C_ADDR, .flags = I2C_M_RD, .buf = ret, .len = len };
+	struct i2c_msg msg = {.addr = DST_I2C_ADDR,.flags = I2C_M_RD,.buf = ret,.len = len };
 	int err;
 	int cnt;
 
 	for (cnt = 0; cnt < 4; cnt++) {
-		if ((err = dst->i2c->xfer (dst->i2c, &msg, 1)) < 0) {
-			dprintk ("%s: read_dst error (err == %i, len == 0x%02x, b0 == 0x%02x)\n", __FUNCTION__, err, len, ret[0]);
+		if ((err = i2c_transfer(dst->i2c, &msg, 1)) < 0) {
+			dprintk("%s: read_dst error (err == %i, len == 0x%02x, b0 == 0x%02x)\n", __FUNCTION__, err, len, ret[0]);
 			dst_i2c_disable(dst);
 			dst_i2c_enable(dst);
 			continue;
@@ -333,7 +309,7 @@ static int dst_set_freq(struct dst_data 
 			return -EINVAL;
 		val = &dst->tx_tuna[0];
 		val[2] = (freq >> 8) & 0x7f;
-		val[3] = (u8)freq;
+		val[3] = (u8) freq;
 		val[4] = 1;
 		val[8] &= ~4;
 		if (freq < 1531)
@@ -345,7 +321,7 @@ static int dst_set_freq(struct dst_data 
 		val = &dst->tx_tuna[0];
 		val[2] = (freq >> 16) & 0xff;
 		val[3] = (freq >> 8) & 0xff;
-		val[4] = (u8)freq;
+		val[4] = (u8) freq;
 		val[5] = 0;
 		switch (dst->bandwidth) {
 		case BANDWIDTH_6_MHZ:
@@ -370,7 +346,7 @@ static int dst_set_freq(struct dst_data 
 		val = &dst->tx_tuna[0];
 		val[2] = (freq >> 16) & 0xff;
 		val[3] = (freq >> 8) & 0xff;
-		val[4] = (u8)freq;
+		val[4] = (u8) freq;
 	} else
 		return -EINVAL;
 	return 0;
@@ -386,7 +362,7 @@ static int dst_set_bandwidth(struct dst_
 		return 0;
 
 	val = &dst->tx_tuna[0];
-        switch (bandwidth) {
+	switch (bandwidth) {
 	case BANDWIDTH_6_MHZ:
 		val[6] = 6;
 		break;
@@ -405,7 +381,7 @@ static int dst_set_bandwidth(struct dst_
 	return 0;
 }
 
-static int dst_set_inversion (struct dst_data *dst, fe_spectral_inversion_t inversion)
+static int dst_set_inversion(struct dst_data *dst, fe_spectral_inversion_t inversion)
 {
 	u8 *val;
 
@@ -428,18 +404,18 @@ static int dst_set_inversion (struct dst
 }
 
 
-static int dst_set_fec (struct dst_data *dst, fe_code_rate_t fec)
+static int dst_set_fec(struct dst_data *dst, fe_code_rate_t fec)
 {
 	dst->fec = fec;
 	return 0;
 }
 
-static fe_code_rate_t dst_get_fec (struct dst_data *dst)
+static fe_code_rate_t dst_get_fec(struct dst_data *dst)
 {
 	return dst->fec;
 }
 
-static int dst_set_symbolrate (struct dst_data *dst, u32 srate)
+static int dst_set_symbolrate(struct dst_data *dst, u32 srate)
 {
 	u8 *val;
 	u32 symcalc;
@@ -450,7 +426,6 @@ static int dst_set_symbolrate (struct ds
 	if (dst->dst_type == DST_TYPE_IS_TERR) {
 		return 0;
 	}
-
 	// dprintk("%s: set srate %u\n", __FUNCTION__, srate);
 	srate /= 1000;
 	val = &dst->tx_tuna[0];
@@ -459,15 +434,15 @@ static int dst_set_symbolrate (struct ds
 		sval = srate;
 		sval <<= 20;
 		do_div(sval, 88000);
-	        symcalc = (u32)sval;
+		symcalc = (u32) sval;
 		// dprintk("%s: set symcalc %u\n", __FUNCTION__, symcalc);
-		val[5] = (u8)(symcalc >> 12);
-		val[6] = (u8)(symcalc >> 4);
-		val[7] = (u8)(symcalc << 4);
+		val[5] = (u8) (symcalc >> 12);
+		val[6] = (u8) (symcalc >> 4);
+		val[7] = (u8) (symcalc << 4);
 	} else {
-		val[5] = (u8)(srate >> 16) & 0x7f;
-		val[6] = (u8)(srate >> 8);
-		val[7] = (u8)srate;
+		val[5] = (u8) (srate >> 16) & 0x7f;
+		val[6] = (u8) (srate >> 8);
+		val[7] = (u8) srate;
 	}
 	val[8] &= ~0x20;
 	if (srate > 8000)
@@ -476,10 +451,10 @@ static int dst_set_symbolrate (struct ds
 }
 
 
-static u8 dst_check_sum(u8 *buf, u32 len)
+static u8 dst_check_sum(u8 * buf, u32 len)
 {
 	u32 i;
-	u8  val = 0;
+	u8 val = 0;
 	if (!len)
 		return 0;
 	for (i = 0; i < len; i++) {
@@ -489,23 +464,25 @@ static u8 dst_check_sum(u8 *buf, u32 len
 }
 
 typedef struct dst_types {
-	char	*mstr;
-	int	offs;
-	u8	dst_type;
-	u32	type_flags;
+	char *mstr;
+	int offs;
+	u8 dst_type;
+	u32 type_flags;
 } DST_TYPES;
 
 struct dst_types dst_tlist[] = {
-	{ "DST-020", 0,  DST_TYPE_IS_SAT,    DST_TYPE_HAS_SYMDIV },
-	{ "DST-030", 0,  DST_TYPE_IS_SAT,    DST_TYPE_HAS_TS204|DST_TYPE_HAS_NEWTUNE },
-	{ "DST-03T", 0,  DST_TYPE_IS_SAT,    DST_TYPE_HAS_SYMDIV|DST_TYPE_HAS_TS204},
-	{ "DST-MOT", 0,  DST_TYPE_IS_SAT,    DST_TYPE_HAS_SYMDIV },
-	{ "DST-CI",  1,  DST_TYPE_IS_SAT,    DST_TYPE_HAS_TS204|DST_TYPE_HAS_NEWTUNE },
-	{ "DSTMCI",  1,  DST_TYPE_IS_SAT,    DST_TYPE_HAS_NEWTUNE },
-	{ "DSTFCI",  1,  DST_TYPE_IS_SAT,    DST_TYPE_HAS_NEWTUNE },
-	{ "DCTNEW",  1,  DST_TYPE_IS_CABLE,  DST_TYPE_HAS_NEWTUNE },
-	{ "DCT_CI",  1,  DST_TYPE_IS_CABLE,  DST_TYPE_HAS_NEWTUNE|DST_TYPE_HAS_TS204 },
-	{ "DTTDIG" , 1,  DST_TYPE_IS_TERR,   0} };
+	{"DST-020", 0, DST_TYPE_IS_SAT, DST_TYPE_HAS_SYMDIV},
+	{"DST-030", 0, DST_TYPE_IS_SAT, DST_TYPE_HAS_TS204 | DST_TYPE_HAS_NEWTUNE},
+	{"DST-03T", 0, DST_TYPE_IS_SAT, DST_TYPE_HAS_SYMDIV | DST_TYPE_HAS_TS204},
+	{"DST-MOT", 0, DST_TYPE_IS_SAT, DST_TYPE_HAS_SYMDIV},
+	{"DST-CI",  1, DST_TYPE_IS_SAT, DST_TYPE_HAS_TS204 | DST_TYPE_HAS_NEWTUNE},
+	{"DSTMCI",  1, DST_TYPE_IS_SAT, DST_TYPE_HAS_NEWTUNE},
+	{"DSTFCI",  1, DST_TYPE_IS_SAT, DST_TYPE_HAS_NEWTUNE},
+	{"DCTNEW",  1, DST_TYPE_IS_CABLE, DST_TYPE_HAS_NEWTUNE},
+	{"DCT_CI",  1, DST_TYPE_IS_CABLE, DST_TYPE_HAS_NEWTUNE | DST_TYPE_HAS_TS204},
+	{"DTTDIG",  1, DST_TYPE_IS_TERR, 0}
+};
+
 /* DCTNEW and DCT-CI are guesses */
 
 static void dst_type_flags_print(u32 type_flags)
@@ -524,25 +501,24 @@ static int dst_type_print(u8 type)
 {
 	char *otype;
 	switch (type) {
-		case DST_TYPE_IS_SAT:
-			otype = "satellite";
-			break;
-		case DST_TYPE_IS_TERR:
-			otype = "terrestial TV";
-			break;
-		case DST_TYPE_IS_CABLE:
-			otype = "terrestial TV";
-			break;
-		default:
-			printk("%s: invalid dst type %d\n",
-				__FUNCTION__, type);
-			return -EINVAL;
+	case DST_TYPE_IS_SAT:
+		otype = "satellite";
+		break;
+	case DST_TYPE_IS_TERR:
+		otype = "terrestial TV";
+		break;
+	case DST_TYPE_IS_CABLE:
+		otype = "terrestial TV";
+		break;
+	default:
+		printk("%s: invalid dst type %d\n", __FUNCTION__, type);
+		return -EINVAL;
 	}
 	printk("DST type : %s\n", otype);
 	return 0;
 }
 
-static int dst_check_ci (struct dst_data *dst)
+static int dst_check_ci(struct dst_data *dst)
 {
 	u8 txbuf[8];
 	u8 rxbuf[8];
@@ -554,18 +530,18 @@ static int dst_check_ci (struct dst_data
 
 	memset(txbuf, 0, sizeof(txbuf));
 	txbuf[1] = 6;
-	txbuf[7] = dst_check_sum (txbuf, 7);
- 
+	txbuf[7] = dst_check_sum(txbuf, 7);
+
 	dst_i2c_enable(dst);
 	dst_reset8820(dst);
-	retval = write_dst (dst, txbuf, 8);
+	retval = write_dst(dst, txbuf, 8);
 	if (retval < 0) {
 		dst_i2c_disable(dst);
 		dprintk("%s: write not successful, maybe no card?\n", __FUNCTION__);
 		return retval;
 	}
-	dvb_delay(3);
-	retval = read_dst (dst, rxbuf, 1);
+	msleep(3);
+	retval = read_dst(dst, rxbuf, 1);
 	dst_i2c_disable(dst);
 	if (retval < 0) {
 		dprintk("%s: read not successful, maybe no card?\n", __FUNCTION__);
@@ -578,21 +554,19 @@ static int dst_check_ci (struct dst_data
 	if (!dst_wait_dst_ready(dst))
 		return 0;
 	// dst_i2c_enable(i2c); Dimitri
-	retval = read_dst (dst, rxbuf, 8);
+	retval = read_dst(dst, rxbuf, 8);
 	dst_i2c_disable(dst);
 	if (retval < 0) {
 		dprintk("%s: read not successful\n", __FUNCTION__);
 		return retval;
 	}
-	if (rxbuf[7] != dst_check_sum (rxbuf, 7)) {
+	if (rxbuf[7] != dst_check_sum(rxbuf, 7)) {
 		dprintk("%s: checksum failure\n", __FUNCTION__);
 		return retval;
 	}
 	rxbuf[7] = '\0';
 	for (i = 0, dsp = &dst_tlist[0]; i < sizeof(dst_tlist) / sizeof(dst_tlist[0]); i++, dsp++) {
-		if (!strncmp(&rxbuf[dsp->offs],
-				dsp->mstr,
-				strlen(dsp->mstr))) {
+		if (!strncmp(&rxbuf[dsp->offs], dsp->mstr, strlen(dsp->mstr))) {
 			use_type_flags = dsp->type_flags;
 			use_dst_type = dsp->dst_type;
 			printk("%s: recognize %s\n", __FUNCTION__, dsp->mstr);
@@ -605,28 +579,10 @@ static int dst_check_ci (struct dst_data
 		use_dst_type = DST_TYPE_IS_SAT;
 		use_type_flags = DST_TYPE_HAS_SYMDIV;
 	}
-	switch (dst_type[dst_cur_no]) {
-		case (-1U):
-			/* not used */
-			break;
-		case DST_TYPE_IS_SAT:
-		case DST_TYPE_IS_TERR:
-		case DST_TYPE_IS_CABLE:
-			use_dst_type = (u8)(dst_type[dst_cur_no]);
-			break;
-		default:
-			printk("%s: invalid user override dst type %d, not used\n",
-				__FUNCTION__, dst_type[dst_cur_no]);
-			break;
-	}
 	dst_type_print(use_dst_type);
-	if (dst_type_flags[dst_cur_no] != (-1U)) {
-		printk("%s: user override dst type flags 0x%x\n",
-				__FUNCTION__, dst_type_flags[dst_cur_no]);
-		use_type_flags = dst_type_flags[dst_cur_no];
-	}
+
 	dst->type_flags = use_type_flags;
-	dst->dst_type= use_dst_type;
+	dst->dst_type = use_dst_type;
 	dst_type_flags_print(dst->type_flags);
 
 	if (dst->type_flags & DST_TYPE_HAS_TS204) {
@@ -635,21 +591,21 @@ static int dst_check_ci (struct dst_data
 	return 0;
 }
 
-static int dst_command (struct dst_data *dst, u8 *data, u8 len)
+static int dst_command(struct dst_data *dst, u8 * data, u8 len)
 {
 	int retval;
 	u8 reply;
 
 	dst_i2c_enable(dst);
 	dst_reset8820(dst);
-	retval = write_dst (dst, data, len);
+	retval = write_dst(dst, data, len);
 	if (retval < 0) {
 		dst_i2c_disable(dst);
 		dprintk("%s: write not successful\n", __FUNCTION__);
 		return retval;
 	}
-	dvb_delay(33);
-	retval = read_dst (dst, &reply, 1);
+	msleep(33);
+	retval = read_dst(dst, &reply, 1);
 	dst_i2c_disable(dst);
 	if (retval < 0) {
 		dprintk("%s: read verify  not successful\n", __FUNCTION__);
@@ -664,13 +620,13 @@ static int dst_command (struct dst_data 
 	if (!dst_wait_dst_ready(dst))
 		return 0;
 	// dst_i2c_enable(i2c); Per dimitri
-	retval = read_dst (dst, dst->rxbuffer, 8);
+	retval = read_dst(dst, dst->rxbuffer, 8);
 	dst_i2c_disable(dst);
 	if (retval < 0) {
 		dprintk("%s: read not successful\n", __FUNCTION__);
 		return 0;
 	}
-	if (dst->rxbuffer[7] != dst_check_sum (dst->rxbuffer, 7)) {
+	if (dst->rxbuffer[7] != dst_check_sum(dst->rxbuffer, 7)) {
 		dprintk("%s: checksum failure\n", __FUNCTION__);
 		return 0;
 	}
@@ -680,7 +636,7 @@ static int dst_command (struct dst_data 
 static int dst_get_signal(struct dst_data *dst)
 {
 	int retval;
-	u8 get_signal[] = {0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb};
+	u8 get_signal[] = { 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb };
 
 	if ((dst->diseq_flags & ATTEMPT_TUNE) == 0) {
 		dst->decode_lock = dst->decode_strength = dst->decode_snr = 0;
@@ -690,20 +646,16 @@ static int dst_get_signal(struct dst_dat
 		dst->decode_lock = dst->decode_strength = dst->decode_snr = 0;
 		return 0;
 	}
-	if (time_after_eq(jiffies, dst->cur_jiff + (HZ/5))) {
-		retval =  dst_command(dst, get_signal, 8);
+	if (time_after_eq(jiffies, dst->cur_jiff + (HZ / 5))) {
+		retval = dst_command(dst, get_signal, 8);
 		if (retval < 0)
 			return retval;
 		if (dst->dst_type == DST_TYPE_IS_SAT) {
-			dst->decode_lock = ((dst->rxbuffer[6] & 0x10) == 0) ?
-					1 : 0;
+			dst->decode_lock = ((dst->rxbuffer[6] & 0x10) == 0) ? 1 : 0;
 			dst->decode_strength = dst->rxbuffer[5] << 8;
-			dst->decode_snr = dst->rxbuffer[2] << 8 |
-				dst->rxbuffer[3];
-		} else if ((dst->dst_type == DST_TYPE_IS_TERR) ||
-				(dst->dst_type == DST_TYPE_IS_CABLE)) {
-			dst->decode_lock = (dst->rxbuffer[1]) ?
-					1 : 0;
+			dst->decode_snr = dst->rxbuffer[2] << 8 | dst->rxbuffer[3];
+		} else if ((dst->dst_type == DST_TYPE_IS_TERR) || (dst->dst_type == DST_TYPE_IS_CABLE)) {
+			dst->decode_lock = (dst->rxbuffer[1]) ? 1 : 0;
 			dst->decode_strength = dst->rxbuffer[4] << 8;
 			dst->decode_snr = dst->rxbuffer[3] << 8;
 		}
@@ -726,9 +678,9 @@ static int dst_get_signal(struct dst_dat
  * Diseqc 4    0x00, 0x08, 0x04, 0xe0, 0x10, 0x38, 0xfc, 0xe0 
  */
 
-static int dst_set_diseqc (struct dst_data *dst, u8 *cmd, u8 len)
+static int dst_set_diseqc(struct dst_data *dst, u8 * cmd, u8 len)
 {
-	u8 paket[8] =  {0x00, 0x08, 0x04, 0xe0, 0x10, 0x38, 0xf0, 0xec };
+	u8 paket[8] = { 0x00, 0x08, 0x04, 0xe0, 0x10, 0x38, 0xf0, 0xec };
 
 	if (dst->dst_type == DST_TYPE_IS_TERR)
 		return 0;
@@ -736,19 +688,19 @@ static int dst_set_diseqc (struct dst_da
 	if (len == 0 || len > 4)
 		return -EINVAL;
 	memcpy(&paket[3], cmd, len);
-	paket[7] = dst_check_sum (&paket[0], 7);
+	paket[7] = dst_check_sum(&paket[0], 7);
 	dst_command(dst, paket, 8);
 	return 0;
 }
 
-static int dst_tone_power_cmd (struct dst_data *dst)
+static int dst_tone_power_cmd(struct dst_data *dst)
 {
-	u8 paket[8] =  {0x00, 0x09, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00};
+	u8 paket[8] = { 0x00, 0x09, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00 };
 
 	if (dst->dst_type == DST_TYPE_IS_TERR)
 		return 0;
 
-	if (dst->voltage == SEC_VOLTAGE_OFF) 
+	if (dst->voltage == SEC_VOLTAGE_OFF)
 		paket[4] = 0;
 	else
 		paket[4] = 1;
@@ -756,12 +708,12 @@ static int dst_tone_power_cmd (struct ds
 		paket[2] = dst->k22;
 	else
 		paket[2] = 0;
-	paket[7] = dst_check_sum (&paket[0], 7);
+	paket[7] = dst_check_sum(&paket[0], 7);
 	dst_command(dst, paket, 8);
 	return 0;
 }
 
-static int dst_set_voltage (struct dst_data *dst, fe_sec_voltage_t voltage)
+static int dst_set_voltage(struct dst_data *dst, fe_sec_voltage_t voltage)
 {
 	u8 *val;
 	int need_cmd;
@@ -788,7 +740,7 @@ static int dst_set_voltage (struct dst_d
 		break;
 	case SEC_VOLTAGE_OFF:
 		need_cmd = 1;
-		dst->diseq_flags &= ~(HAS_POWER|HAS_LOCK|ATTEMPT_TUNE);
+		dst->diseq_flags &= ~(HAS_POWER | HAS_LOCK | ATTEMPT_TUNE);
 		break;
 	default:
 		return -EINVAL;
@@ -800,7 +752,7 @@ static int dst_set_voltage (struct dst_d
 }
 
 
-static int dst_set_tone (struct dst_data *dst, fe_sec_tone_mode_t tone)
+static int dst_set_tone(struct dst_data *dst, fe_sec_tone_mode_t tone)
 {
 	u8 *val;
 
@@ -826,9 +778,9 @@ static int dst_set_tone (struct dst_data
 	return 0;
 }
 
-static int dst_get_tuna (struct dst_data *dst)
+static int dst_get_tuna(struct dst_data *dst)
 {
-int retval;
+	int retval;
 	if ((dst->diseq_flags & ATTEMPT_TUNE) == 0)
 		return 0;
 	dst->diseq_flags &= ~(HAS_LOCK);
@@ -836,43 +788,43 @@ int retval;
 		return 0;
 	if (dst->type_flags & DST_TYPE_HAS_NEWTUNE) {
 		/* how to get variable length reply ???? */
-		retval = read_dst (dst, dst->rx_tuna, 10);
+		retval = read_dst(dst, dst->rx_tuna, 10);
 	} else {
-		retval = read_dst (dst, &dst->rx_tuna[2], 8);
+		retval = read_dst(dst, &dst->rx_tuna[2], 8);
 	}
 	if (retval < 0) {
 		dprintk("%s: read not successful\n", __FUNCTION__);
 		return 0;
 	}
 	if (dst->type_flags & DST_TYPE_HAS_NEWTUNE) {
-		if (dst->rx_tuna[9] != dst_check_sum (&dst->rx_tuna[0], 9)) {
+		if (dst->rx_tuna[9] != dst_check_sum(&dst->rx_tuna[0], 9)) {
 			dprintk("%s: checksum failure?\n", __FUNCTION__);
 			return 0;
 		}
 	} else {
-		if (dst->rx_tuna[9] != dst_check_sum (&dst->rx_tuna[2], 7)) {
+		if (dst->rx_tuna[9] != dst_check_sum(&dst->rx_tuna[2], 7)) {
 			dprintk("%s: checksum failure?\n", __FUNCTION__);
 			return 0;
 		}
 	}
 	if (dst->rx_tuna[2] == 0 && dst->rx_tuna[3] == 0)
 		return 0;
-	dst->decode_freq = ((dst->rx_tuna[2] & 0x7f) << 8) +  dst->rx_tuna[3];
+	dst->decode_freq = ((dst->rx_tuna[2] & 0x7f) << 8) + dst->rx_tuna[3];
 
 	dst->decode_lock = 1;
 	/*
-	dst->decode_n1 = (dst->rx_tuna[4] << 8) +  
-			(dst->rx_tuna[5]);
+	   dst->decode_n1 = (dst->rx_tuna[4] << 8) +  
+	   (dst->rx_tuna[5]);
 
-	dst->decode_n2 = (dst->rx_tuna[8] << 8) +  
-			(dst->rx_tuna[7]);
-	*/
+	   dst->decode_n2 = (dst->rx_tuna[8] << 8) +  
+	   (dst->rx_tuna[7]);
+	 */
 	dst->diseq_flags |= HAS_LOCK;
 	/* dst->cur_jiff = jiffies; */
 	return 1;
 }
 
-static int dst_write_tuna (struct dst_data *dst)
+static int dst_write_tuna(struct dst_data *dst)
 {
 	int retval;
 	u8 reply;
@@ -882,25 +834,25 @@ static int dst_write_tuna (struct dst_da
 	dst->decode_lock = dst->decode_strength = dst->decode_snr = 0;
 	if (dst->dst_type == DST_TYPE_IS_SAT) {
 		if (!(dst->diseq_flags & HAS_POWER))
-			dst_set_voltage (dst, SEC_VOLTAGE_13);
+			dst_set_voltage(dst, SEC_VOLTAGE_13);
 	}
-	dst->diseq_flags &= ~(HAS_LOCK|ATTEMPT_TUNE);
+	dst->diseq_flags &= ~(HAS_LOCK | ATTEMPT_TUNE);
 	dst_i2c_enable(dst);
 	if (dst->type_flags & DST_TYPE_HAS_NEWTUNE) {
 		dst_reset8820(dst);
-		dst->tx_tuna[9] = dst_check_sum (&dst->tx_tuna[0], 9);
-		retval = write_dst (dst, &dst->tx_tuna[0], 10);
+		dst->tx_tuna[9] = dst_check_sum(&dst->tx_tuna[0], 9);
+		retval = write_dst(dst, &dst->tx_tuna[0], 10);
 	} else {
-		dst->tx_tuna[9] = dst_check_sum (&dst->tx_tuna[2], 7);
-		retval = write_dst (dst, &dst->tx_tuna[2], 8);
+		dst->tx_tuna[9] = dst_check_sum(&dst->tx_tuna[2], 7);
+		retval = write_dst(dst, &dst->tx_tuna[2], 8);
 	}
 	if (retval < 0) {
 		dst_i2c_disable(dst);
 		dprintk("%s: write not successful\n", __FUNCTION__);
 		return retval;
 	}
-	dvb_delay(3);
-	retval = read_dst (dst, &reply, 1);
+	msleep(3);
+	retval = read_dst(dst, &reply, 1);
 	dst_i2c_disable(dst);
 	if (retval < 0) {
 		dprintk("%s: read verify  not successful\n", __FUNCTION__);
@@ -914,14 +866,14 @@ static int dst_write_tuna (struct dst_da
 	return dst_get_tuna(dst);
 }
 
-static void dst_init (struct dst_data *dst)
+static void dst_init(struct dst_data *dst)
 {
-static u8 ini_satci_tuna[] = {  9, 0, 3, 0xb6, 1, 0,    0x73, 0x21, 0, 0 };
-static u8 ini_satfta_tuna[] = { 0, 0, 3, 0xb6, 1, 0x55, 0xbd, 0x50, 0, 0 };
-static u8 ini_tvfta_tuna[] = { 0, 0,  3, 0xb6, 1, 7,    0x0,   0x0, 0, 0 };
-static u8 ini_tvci_tuna[] = { 9, 0,  3, 0xb6, 1, 7,    0x0,   0x0, 0, 0 };
-static u8 ini_cabfta_tuna[] = { 0, 0,  3, 0xb6, 1, 7,    0x0,   0x0, 0, 0 };
-static u8 ini_cabci_tuna[] = { 9, 0,  3, 0xb6, 1, 7,    0x0,   0x0, 0, 0 };
+	static u8 ini_satci_tuna[] = { 9, 0, 3, 0xb6, 1, 0, 0x73, 0x21, 0, 0 };
+	static u8 ini_satfta_tuna[] = { 0, 0, 3, 0xb6, 1, 0x55, 0xbd, 0x50, 0, 0 };
+	static u8 ini_tvfta_tuna[] = { 0, 0, 3, 0xb6, 1, 7, 0x0, 0x0, 0, 0 };
+	static u8 ini_tvci_tuna[] = { 9, 0, 3, 0xb6, 1, 7, 0x0, 0x0, 0, 0 };
+	static u8 ini_cabfta_tuna[] = { 0, 0, 3, 0xb6, 1, 7, 0x0, 0x0, 0, 0 };
+	static u8 ini_cabci_tuna[] = { 9, 0, 3, 0xb6, 1, 7, 0x0, 0x0, 0, 0 };
 	dst->inversion = INVERSION_ON;
 	dst->voltage = SEC_VOLTAGE_13;
 	dst->tone = SEC_TONE_OFF;
@@ -933,19 +885,13 @@ static u8 ini_cabci_tuna[] = { 9, 0,  3,
 	dst->cur_jiff = jiffies;
 	if (dst->dst_type == DST_TYPE_IS_SAT) {
 		dst->frequency = 950000;
-		memcpy(dst->tx_tuna, ((dst->type_flags &  DST_TYPE_HAS_NEWTUNE )? 
-					ini_satci_tuna : ini_satfta_tuna),
-				sizeof(ini_satfta_tuna));
+		memcpy(dst->tx_tuna, ((dst->type_flags & DST_TYPE_HAS_NEWTUNE) ? ini_satci_tuna : ini_satfta_tuna), sizeof(ini_satfta_tuna));
 	} else if (dst->dst_type == DST_TYPE_IS_TERR) {
 		dst->frequency = 137000000;
-		memcpy(dst->tx_tuna, ((dst->type_flags &  DST_TYPE_HAS_NEWTUNE )? 
-					ini_tvci_tuna : ini_tvfta_tuna),
-				sizeof(ini_tvfta_tuna));
+		memcpy(dst->tx_tuna, ((dst->type_flags & DST_TYPE_HAS_NEWTUNE) ? ini_tvci_tuna : ini_tvfta_tuna), sizeof(ini_tvfta_tuna));
 	} else if (dst->dst_type == DST_TYPE_IS_CABLE) {
 		dst->frequency = 51000000;
-		memcpy(dst->tx_tuna, ((dst->type_flags &  DST_TYPE_HAS_NEWTUNE )? 
-					ini_cabci_tuna : ini_cabfta_tuna),
-				sizeof(ini_cabfta_tuna));
+		memcpy(dst->tx_tuna, ((dst->type_flags & DST_TYPE_HAS_NEWTUNE) ? ini_cabci_tuna : ini_cabfta_tuna), sizeof(ini_cabfta_tuna));
 	}
 }
 
@@ -953,230 +899,354 @@ struct lkup {
 	unsigned int cmd;
 	char *desc;
 } looker[] = {
-	{FE_GET_INFO,                "FE_GET_INFO:"},
-	{FE_READ_STATUS,             "FE_READ_STATUS:" },
-	{FE_READ_BER,                "FE_READ_BER:" },
-	{FE_READ_SIGNAL_STRENGTH,    "FE_READ_SIGNAL_STRENGTH:" },
-	{FE_READ_SNR,                "FE_READ_SNR:" },
-	{FE_READ_UNCORRECTED_BLOCKS, "FE_READ_UNCORRECTED_BLOCKS:" },
-	{FE_SET_FRONTEND,            "FE_SET_FRONTEND:" },
-	{FE_GET_FRONTEND,            "FE_GET_FRONTEND:" },
-	{FE_SLEEP,                   "FE_SLEEP:" },
-	{FE_INIT,                    "FE_INIT:" },
-	{FE_SET_TONE,                "FE_SET_TONE:" },
-	{FE_SET_VOLTAGE,             "FE_SET_VOLTAGE:" },
-	};
+	{
+	FE_GET_INFO, "FE_GET_INFO:"}, {
+	FE_READ_STATUS, "FE_READ_STATUS:"}, {
+	FE_READ_BER, "FE_READ_BER:"}, {
+	FE_READ_SIGNAL_STRENGTH, "FE_READ_SIGNAL_STRENGTH:"}, {
+	FE_READ_SNR, "FE_READ_SNR:"}, {
+	FE_READ_UNCORRECTED_BLOCKS, "FE_READ_UNCORRECTED_BLOCKS:"}, {
+	FE_SET_FRONTEND, "FE_SET_FRONTEND:"}, {
+	FE_GET_FRONTEND, "FE_GET_FRONTEND:"}, {
+	FE_SLEEP, "FE_SLEEP:"}, {
+	FE_INIT, "FE_INIT:"}, {
+	FE_SET_TONE, "FE_SET_TONE:"}, {
+FE_SET_VOLTAGE, "FE_SET_VOLTAGE:"},};
 
-static int dst_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
+static int dst_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
 	struct dst_data *dst = fe->data;
 	int retval;
 	/*
-	char  *cc;
-                
-	cc = "FE_UNSUPP:";
-	for(retval = 0; retval < sizeof(looker) / sizeof(looker[0]); retval++) {
-		if (looker[retval].cmd == cmd) {
-			cc = looker[retval].desc;
-			break;
-		}
-	}
-	dprintk("%s cmd %s (0x%x)\n",__FUNCTION__, cc, cmd);
-	*/
+	   char  *cc;
+
+	   cc = "FE_UNSUPP:";
+	   for(retval = 0; retval < sizeof(looker) / sizeof(looker[0]); retval++) {
+	   if (looker[retval].cmd == cmd) {
+	   cc = looker[retval].desc;
+	   break;
+	   }
+	   }
+	   dprintk("%s cmd %s (0x%x)\n",__FUNCTION__, cc, cmd);
+	 */
 	// printk("%s: dst %8.8x bt %8.8x i2c %8.8x\n", __FUNCTION__, dst, dst->bt, dst->i2c);
 	/* should be set by attach, but just in case */
-	dst->i2c = fe->i2c;
-        switch (cmd) {
-        case FE_GET_INFO: 
-	{
-	     struct dvb_frontend_info *info;
-		info = &dst_info_sat;
-		if (dst->dst_type == DST_TYPE_IS_TERR)
-			info = &dst_info_tv;
-		else if (dst->dst_type == DST_TYPE_IS_CABLE)
-			info = &dst_info_cable;
-		memcpy (arg, info, sizeof(struct dvb_frontend_info));
-		break;
-	}
-        case FE_READ_STATUS:
-	{
-		fe_status_t *status = arg;
 
-		*status = 0;
-		if (dst->diseq_flags & HAS_LOCK) {
-			dst_get_signal(dst);
-			if (dst->decode_lock)
-				*status |= FE_HAS_LOCK 
-					| FE_HAS_SIGNAL 
-					| FE_HAS_CARRIER
-					| FE_HAS_SYNC
-					| FE_HAS_VITERBI;
+	switch (cmd) {
+	case FE_GET_INFO:
+		{
+			struct dvb_frontend_info *info;
+			info = &dst_info_sat;
+			if (dst->dst_type == DST_TYPE_IS_TERR)
+				info = &dst_info_terr;
+			else if (dst->dst_type == DST_TYPE_IS_CABLE)
+				info = &dst_info_cable;
+			memcpy(arg, info, sizeof(struct dvb_frontend_info));
+			break;
+		}
+	case FE_READ_STATUS:
+		{
+			fe_status_t *status = arg;
+
+			*status = 0;
+			if (dst->diseq_flags & HAS_LOCK) {
+				dst_get_signal(dst);
+				if (dst->decode_lock)
+					*status |= FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_SYNC | FE_HAS_VITERBI;
+			}
+			break;
 		}
-		break;
-	}
 
-        case FE_READ_BER:
-	{
-		/* guess */
-		// *(u32*) arg = dst->decode_n1;
-		*(u32*) arg = 0;
-		return -EOPNOTSUPP; 
-	}
+	case FE_READ_BER:
+		{
+			/* guess */
+			// *(u32*) arg = dst->decode_n1;
+			*(u32 *) arg = 0;
+			return -EOPNOTSUPP;
+		}
 
-        case FE_READ_SIGNAL_STRENGTH:
-	{
-		dst_get_signal(dst);
-		*((u16*) arg) = dst->decode_strength;
-		break;
-	}
+	case FE_READ_SIGNAL_STRENGTH:
+		{
+			dst_get_signal(dst);
+			*((u16 *) arg) = dst->decode_strength;
+			break;
+		}
 
-        case FE_READ_SNR:
-	{
-		dst_get_signal(dst);
-		*((u16*) arg) = dst->decode_snr;
-		break;
-	}
+	case FE_READ_SNR:
+		{
+			dst_get_signal(dst);
+			*((u16 *) arg) = dst->decode_snr;
+			break;
+		}
 
-	case FE_READ_UNCORRECTED_BLOCKS: 
-	{
-		*((u32*) arg) = 0;    /* the stv0299 can't measure BER and */
-		return -EOPNOTSUPP;   /* errors at the same time.... */
-	}
+	case FE_READ_UNCORRECTED_BLOCKS:
+		{
+			*((u32 *) arg) = 0;	/* the stv0299 can't measure BER and */
+			return -EOPNOTSUPP;	/* errors at the same time.... */
+		}
 
-        case FE_SET_FRONTEND:
-        {
-		struct dvb_frontend_parameters *p = arg;
+	case FE_SET_FRONTEND:
+		{
+			struct dvb_frontend_parameters *p = arg;
+
+			dst_set_freq(dst, p->frequency);
+			dst_set_inversion(dst, p->inversion);
+			if (dst->dst_type == DST_TYPE_IS_SAT) {
+				dst_set_fec(dst, p->u.qpsk.fec_inner);
+				dst_set_symbolrate(dst, p->u.qpsk.symbol_rate);
+			} else if (dst->dst_type == DST_TYPE_IS_TERR) {
+				dst_set_bandwidth(dst, p->u.ofdm.bandwidth);
+			} else if (dst->dst_type == DST_TYPE_IS_CABLE) {
+				dst_set_fec(dst, p->u.qam.fec_inner);
+				dst_set_symbolrate(dst, p->u.qam.symbol_rate);
+			}
+			dst_write_tuna(dst);
 
-		dst_set_freq (dst, p->frequency);
-		dst_set_inversion (dst, p->inversion);
-		if (dst->dst_type == DST_TYPE_IS_SAT) {
-			dst_set_fec (dst, p->u.qpsk.fec_inner);
-			dst_set_symbolrate (dst, p->u.qpsk.symbol_rate);
-		} else if (dst->dst_type == DST_TYPE_IS_TERR) {
-			dst_set_bandwidth(dst, p->u.ofdm.bandwidth);
-		} else if (dst->dst_type == DST_TYPE_IS_CABLE) {
-			dst_set_fec (dst, p->u.qam.fec_inner);
-			dst_set_symbolrate (dst, p->u.qam.symbol_rate);
+			break;
 		}
-		dst_write_tuna (dst);
-
-                break;
-        }
 
 	case FE_GET_FRONTEND:
-	{
-		struct dvb_frontend_parameters *p = arg;
+		{
+			struct dvb_frontend_parameters *p = arg;
 
 
-		p->frequency = dst->decode_freq;
-		p->inversion = dst->inversion;
-		if (dst->dst_type == DST_TYPE_IS_SAT) {
-			p->u.qpsk.symbol_rate = dst->symbol_rate;
-			p->u.qpsk.fec_inner = dst_get_fec (dst);
-		} else if (dst->dst_type == DST_TYPE_IS_TERR) {
-			p->u.ofdm.bandwidth = dst->bandwidth;
-		} else if (dst->dst_type == DST_TYPE_IS_CABLE) {
-			p->u.qam.symbol_rate = dst->symbol_rate;
-			p->u.qam.fec_inner = dst_get_fec (dst);
-			p->u.qam.modulation = QAM_AUTO;
+			p->frequency = dst->decode_freq;
+			p->inversion = dst->inversion;
+			if (dst->dst_type == DST_TYPE_IS_SAT) {
+				p->u.qpsk.symbol_rate = dst->symbol_rate;
+				p->u.qpsk.fec_inner = dst_get_fec(dst);
+			} else if (dst->dst_type == DST_TYPE_IS_TERR) {
+				p->u.ofdm.bandwidth = dst->bandwidth;
+			} else if (dst->dst_type == DST_TYPE_IS_CABLE) {
+				p->u.qam.symbol_rate = dst->symbol_rate;
+				p->u.qam.fec_inner = dst_get_fec(dst);
+				p->u.qam.modulation = QAM_AUTO;
+			}
+			break;
 		}
-		break;
-	}
 
-        case FE_SLEEP:
+	case FE_SLEEP:
 		return 0;
 
-        case FE_INIT:
+	case FE_INIT:
 		dst_init(dst);
 		break;
 
 	case FE_DISEQC_SEND_MASTER_CMD:
-	{
-		struct dvb_diseqc_master_cmd *cmd = (struct dvb_diseqc_master_cmd *)arg;
-		retval = dst_set_diseqc (dst, cmd->msg, cmd->msg_len);
-		if (retval < 0)
-			return retval;
-		break;
-	}
+		{
+			struct dvb_diseqc_master_cmd *cmd = (struct dvb_diseqc_master_cmd *) arg;
+			retval = dst_set_diseqc(dst, cmd->msg, cmd->msg_len);
+			if (retval < 0)
+				return retval;
+			break;
+		}
 	case FE_SET_TONE:
-		retval = dst_set_tone (dst, (fe_sec_tone_mode_t) arg);
+		retval = dst_set_tone(dst, (fe_sec_tone_mode_t) arg);
 		if (retval < 0)
 			return retval;
 		break;
 	case FE_SET_VOLTAGE:
-		retval = dst_set_voltage (dst, (fe_sec_voltage_t) arg);
+		retval = dst_set_voltage(dst, (fe_sec_voltage_t) arg);
 		if (retval < 0)
 			return retval;
 		break;
 	default:
 		return -EOPNOTSUPP;
-        };
-        
-        return 0;
-} 
+	};
+
+	return 0;
+}
 
+static ssize_t attr_read_type(struct device *dev, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dst_data *dst = (struct dst_data *) i2c_get_clientdata(client);
+	return sprintf(buf, "0x%02x\n", dst->dst_type);
+}
+
+static ssize_t attr_write_type(struct device *dev, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dst_data *dst = (struct dst_data *) i2c_get_clientdata(client);
+	unsigned long type;
+	type = simple_strtoul(buf, NULL, 0);
+	dst->dst_type = type & 0xff;
+	return strlen(buf) + 1;
+}
+
+/* dst_type, "Type of DST card, 0 Satellite, 1 terrestial, 2 Cable, default driver determined"); */
+static struct device_attribute dev_attr_client_type = {
+	.attr = {.name = "type",.mode = S_IRUGO | S_IWUGO,.owner = THIS_MODULE},
+	.show = &attr_read_type,
+	.store = &attr_write_type,
+};
+
+static ssize_t attr_read_flags(struct device *dev, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dst_data *dst = (struct dst_data *) i2c_get_clientdata(client);
+	return sprintf(buf, "0x%02x\n", dst->type_flags);
+}
 
-static int dst_attach (struct dvb_i2c_bus *i2c, void **data)
+static ssize_t attr_write_flags(struct device *dev, const char *buf, size_t count)
 {
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dst_data *dst = (struct dst_data *) i2c_get_clientdata(client);
+	unsigned long flags;
+	flags = simple_strtoul(buf, NULL, 0);
+	dst->type_flags = flags & 0xffffffff;
+	return strlen(buf) + 1;
+}
+
+/* dst_type_flags, "Type flags of DST card, bitfield 1=10 byte tuner, 2=TS is 204, 4=symdiv"); */
+static struct device_attribute dev_attr_client_flags = {
+	.attr = {.name = "flags",.mode = S_IRUGO | S_IWUGO,.owner = THIS_MODULE},
+	.show = &attr_read_flags,
+	.store = &attr_write_flags,
+};
+
+static struct i2c_client client_template;
+
+static int attach_adapter(struct i2c_adapter *adapter)
+{
+	struct i2c_client *client;
 	struct dst_data *dst;
 	struct bt878 *bt;
 	struct dvb_frontend_info *info;
+	int ret;
 
-	dprintk("%s: check ci\n", __FUNCTION__);
-	if (dst_cur_no >= DST_MAX_CARDS) {
-		dprintk("%s: can't have more than %d cards\n", __FUNCTION__, DST_MAX_CARDS);
-		return -ENODEV;
-	}
-	bt = bt878_find_by_dvb_adap(i2c->adapter);
+	bt = bt878_find_by_i2c_adap(adapter);
 	if (!bt)
 		return -ENODEV;
+
 	dst = kmalloc(sizeof(struct dst_data), GFP_KERNEL);
 	if (dst == NULL) {
 		printk(KERN_INFO "%s: Out of memory.\n", __FUNCTION__);
 		return -ENOMEM;
 	}
+
 	memset(dst, 0, sizeof(*dst));
-	*data = dst;
 	dst->bt = bt;
-	dst->i2c = i2c;
+	dst->i2c = adapter;
 	if (dst_check_ci(dst) < 0) {
 		kfree(dst);
 		return -ENODEV;
 	}
+	dst_init(dst);
 
-	dst_init (dst);
-	dprintk("%s: register dst %p bt %p i2c %p\n", __FUNCTION__, 
-			dst, dst->bt, dst->i2c);
+	dprintk("%s: register dst %8.8x bt %8.8x i2c %8.8x\n", __FUNCTION__, (u32) dst, (u32) (dst->bt), (u32) (dst->i2c));
 
-	info = &dst_info_sat;
-	if (dst->dst_type == DST_TYPE_IS_TERR)
-		info = &dst_info_tv;
-	else if (dst->dst_type == DST_TYPE_IS_CABLE)
+	switch (dst->dst_type) {
+	case DST_TYPE_IS_TERR:
+		info = &dst_info_terr;
+		break;
+	case DST_TYPE_IS_CABLE:
 		info = &dst_info_cable;
+		break;
+	case DST_TYPE_IS_SAT:
+		info = &dst_info_sat;
+		break;
+	default:
+		printk("dst: unknown frontend type. please report to the LinuxTV.org DVB mailinglist.\n");
+		kfree(dst);
+		return -ENODEV;
+	}
+
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		kfree(dst);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = DST_I2C_ADDR;
+
+	i2c_set_clientdata(client, (void *) dst);
+
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(client);
+		kfree(dst);
+		return -EFAULT;
+	}
+
+	BUG_ON(!dst->dvb);
+
+	device_create_file(&client->dev, &dev_attr_client_type);
+	device_create_file(&client->dev, &dev_attr_client_flags);
+
+	ret = dvb_register_frontend(dst_ioctl, dst->dvb, dst, info, THIS_MODULE);
+	if (ret) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(dst);
+		return -EFAULT;
+	}
 
-	dvb_register_frontend (dst_ioctl, i2c, dst, info);
-	dst_cur_no++;
 	return 0;
 }
 
-static void dst_detach (struct dvb_i2c_bus *i2c, void *data)
+static int detach_client(struct i2c_client *client)
 {
-	dvb_unregister_frontend (dst_ioctl, i2c);
-	dprintk("%s: unregister dst %p\n", __FUNCTION__, data);
-	if (data)
-		kfree(data);
+	struct dst_data *state = (struct dst_data *) i2c_get_clientdata(client);
+	
+	dvb_unregister_frontend(dst_ioctl, state->dvb);
+
+	device_remove_file(&client->dev, &dev_attr_client_type);
+	device_remove_file(&client->dev, &dev_attr_client_flags);
+
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+
+	kfree(client);
+	kfree(state);
+
+	return 0;
 }
 
-static int __init init_dst (void)
+static int command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	return dvb_register_i2c_device (THIS_MODULE, dst_attach, dst_detach);
+	struct dst_data *state = (struct dst_data *) i2c_get_clientdata(client);
+
+	switch (cmd) {
+	case FE_REGISTER:
+		state->dvb = (struct dvb_adapter *) arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
-static void __exit exit_dst (void)
+static struct i2c_driver driver = {
+	.owner = THIS_MODULE,
+	.name = "dst",
+	.id = I2C_DRIVERID_DVBFE_DST,
+	.flags = I2C_DF_NOTIFY,
+	.attach_adapter = attach_adapter,
+	.detach_client = detach_client,
+	.command = command,
+};
+
+static struct i2c_client client_template = {
+	I2C_DEVNAME("dst"),
+	.flags = I2C_CLIENT_ALLOW_USE,
+	.driver = &driver,
+};
+
+static int __init init_dst(void)
 {
-	dvb_unregister_i2c_device (dst_attach);
+	return i2c_add_driver(&driver);
 }
 
+static void __exit exit_dst(void)
+{
+	if (i2c_del_driver(&driver))
+		printk("dst: driver deregistration failed\n");
+}
 
 module_init(init_dst);
 module_exit(exit_dst);
@@ -1184,4 +1254,3 @@ module_exit(exit_dst);
 MODULE_DESCRIPTION("DST DVB-S Frontend");
 MODULE_AUTHOR("Jamie Honan");
 MODULE_LICENSE("GPL");
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/dvb_dummy_fe.c linux/drivers/media/dvb/frontends/dvb_dummy_fe.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/dvb_dummy_fe.c	2004-09-14 10:34:59.000000000 +0200
+++ linux/drivers/media/dvb/frontends/dvb_dummy_fe.c	2004-09-17 14:56:38.816597871 +0200
@@ -20,12 +20,16 @@
  */    
 
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/init.h>
 
 #include "dvb_frontend.h"
 
-static int sct = 0;
+#define FRONTEND_NAME "dvbfe_dummy"
 
+static int frontend_type;
+module_param(frontend_type, int, 0444);
+MODULE_PARM_DESC(frontend_type, "0 == DVB-S, 1 == DVB-C, 2 == DVB-T");
 
 /* depending on module parameter sct deliver different infos
  */
@@ -48,13 +52,13 @@ static struct dvb_frontend_info dvb_s_du
 };
 
 static struct dvb_frontend_info dvb_c_dummyfe_info = {
-	.name = "DVB-C dummy frontend",
-	.type = FE_QAM,
-	.frequency_stepsize = 62500,
-	.frequency_min = 51000000,
-	.frequency_max = 858000000,
-	.symbol_rate_min = (57840000/2)/64,     /* SACLK/64 == (XIN/2)/64 */
-	.symbol_rate_max = (57840000/2)/4,      /* SACLK/4 */
+	.name			= "DVB-C dummy frontend",
+	.type 			= FE_QAM,
+	.frequency_stepsize	= 62500,
+	.frequency_min 		= 51000000,
+	.frequency_max 		= 858000000,
+	.symbol_rate_min 	= (57840000/2)/64,     /* SACLK/64 == (XIN/2)/64 */
+	.symbol_rate_max 	= (57840000/2)/4,      /* SACLK/4 */
 #if 0
 	.frequency_tolerance	= ???,
 	.symbol_rate_tolerance	= ???,  /* ppm */  /* == 8% (spec p. 5) */
@@ -66,16 +70,16 @@ static struct dvb_frontend_info dvb_c_du
 };
 
 static struct dvb_frontend_info dvb_t_dummyfe_info = {
-	.name = "DVB-T dummy frontend",
-	.type = FE_OFDM,
-	.frequency_min = 0,
-	.frequency_max = 863250000,
-	.frequency_stepsize = 62500,
-	/*.frequency_tolerance = */	/* FIXME: 12% of SR */
-	.symbol_rate_min = 0,		/* FIXME */
-	.symbol_rate_max = 9360000,	/* FIXME */
-	.symbol_rate_tolerance = 4000,
-	.notifier_delay = 0,
+	.name			= "DVB-T dummy frontend",
+	.type 			= FE_OFDM,
+	.frequency_min 		= 0,
+	.frequency_max 		= 863250000,
+	.frequency_stepsize	= 62500,
+	/*.frequency_tolerance 	= */	/* FIXME: 12% of SR */
+	.symbol_rate_min 	= 0,		/* FIXME */
+	.symbol_rate_max 	= 9360000,	/* FIXME */
+	.symbol_rate_tolerance 	= 4000,
+	.notifier_delay 	= 0,
 	.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
 			FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
@@ -87,8 +91,7 @@ static struct dvb_frontend_info dvb_t_du
 
 struct dvb_frontend_info *frontend_info(void)
 {
-	switch(sct)
-	{
+	switch(frontend_type) {
 	case 2:
 		return &dvb_t_dummyfe_info;
 	case 1:
@@ -168,38 +171,96 @@ static int dvbdummyfe_ioctl (struct dvb_
         return 0;
 } 
 
+static struct i2c_client client_template;
 
-static int dvbdummyfe_attach (struct dvb_i2c_bus *i2c, void **data)
+static int dvbdummyfe_attach_adapter(struct i2c_adapter *adapter)
 {
-	return dvb_register_frontend (dvbdummyfe_ioctl, i2c, NULL, frontend_info());
+	struct dvb_adapter *dvb;
+	struct i2c_client *client;
+	int ret;
+
+	if ((client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+
+	if ((ret = i2c_attach_client(client))) {
+		kfree(client);
+		return ret;
+	}
+
+	dvb = i2c_get_clientdata(client);
+	BUG_ON(!dvb);
+
+	if ((ret = dvb_register_frontend(dvbdummyfe_ioctl, dvb, NULL,
+					     frontend_info(), THIS_MODULE))) {
+		kfree(client);
+		return ret;
+	}
+
+	return 0;
 }
 
 
-static void dvbdummyfe_detach (struct dvb_i2c_bus *i2c, void *data)
+static int dvbdummyfe_detach_client(struct i2c_client *client)
 {
-	dvb_unregister_frontend (dvbdummyfe_ioctl, i2c);
+	struct dvb_adapter *dvb = i2c_get_clientdata(client);
+
+	dvb_unregister_frontend(dvbdummyfe_ioctl, dvb);
+	i2c_detach_client(client);
+	kfree(client);
+	return 0;
 }
 
+static int dvbdummyfe_command(struct i2c_client *client,
+			      unsigned int cmd, void *arg)
+{
+	switch(cmd) {
+	case FE_REGISTER:
+		i2c_set_clientdata(client, arg);
+		break;
+	case FE_UNREGISTER:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static struct i2c_driver driver = {
+	.owner		= THIS_MODULE,
+	.name		= FRONTEND_NAME,
+	.id		= I2C_DRIVERID_DVBFE_DUMMY,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= dvbdummyfe_attach_adapter,
+	.detach_client	= dvbdummyfe_detach_client,
+	.command	= dvbdummyfe_command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags		= I2C_CLIENT_ALLOW_USE,
+	.driver		= &driver,
+};
 
 static int __init init_dvbdummyfe (void)
 {
-	return dvb_register_i2c_device (THIS_MODULE,
-					dvbdummyfe_attach, 
-					dvbdummyfe_detach);
+	return i2c_add_driver(&driver);
 }
 
-
 static void __exit exit_dvbdummyfe (void)
 {
-	dvb_unregister_i2c_device (dvbdummyfe_attach);
+	if (i2c_del_driver(&driver))
+		printk(KERN_ERR "dummyfe: driver deregistration failed.\n");
 }
 
 
 module_init(init_dvbdummyfe);
 module_exit(exit_dvbdummyfe);
 
-
 MODULE_DESCRIPTION("DVB DUMMY Frontend");
 MODULE_AUTHOR("Emard");
 MODULE_LICENSE("GPL");
-MODULE_PARM(sct, "i");
+
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/grundig_29504-401.c linux/drivers/media/dvb/frontends/grundig_29504-401.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/grundig_29504-401.c	2004-09-14 10:34:46.000000000 +0200
+++ linux/drivers/media/dvb/frontends/grundig_29504-401.c	2004-09-17 14:56:38.819597309 +0200
@@ -25,22 +25,35 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
-static int debug = 0;
+#define FRONTEND_NAME "dvbfe_l64781"
 
-#define dprintk	if (debug) printk
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
+
+static int debug;
+static int old_set_tv_freq;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+module_param(old_set_tv_freq, int, 0644);
+MODULE_PARM_DESC(old_set_tv_freq, "Use old tsa5060_set_tv_freq calculations.");
 
-struct grundig_state {
+struct l64781_state {
 	int first:1;
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
 };
 
-struct dvb_frontend_info grundig_29504_401_info = {
-	.name = "Grundig 29504-401",
+struct dvb_frontend_info l64781_info = {
+	.name = "Grundig 29504-401 (LSI L64781 Based)",
 	.type = FE_OFDM,
 /*	.frequency_min = ???,*/
 /*	.frequency_max = ???,*/
@@ -55,13 +68,13 @@ struct dvb_frontend_info grundig_29504_4
 };
 
 
-static int l64781_writereg (struct dvb_i2c_bus *i2c, u8 reg, u8 data)
+static int l64781_writereg (struct i2c_adapter *i2c, u8 reg, u8 data)
 {
 	int ret;
 	u8 buf [] = { reg, data };
 	struct i2c_msg msg = { .addr = 0x55, .flags = 0, .buf = buf, .len = 2 };
 
-	if ((ret = i2c->xfer (i2c, &msg, 1)) != 1)
+	if ((ret = i2c_transfer(i2c, &msg, 1)) != 1)
 		dprintk ("%s: write_reg error (reg == %02x) = %02x!\n",
 			 __FUNCTION__, reg, ret);
 
@@ -69,7 +82,7 @@ static int l64781_writereg (struct dvb_i
 }
 
 
-static u8 l64781_readreg (struct dvb_i2c_bus *i2c, u8 reg)
+static u8 l64781_readreg (struct i2c_adapter *i2c, u8 reg)
 {
 	int ret;
 	u8 b0 [] = { reg };
@@ -77,7 +90,7 @@ static u8 l64781_readreg (struct dvb_i2c
 	struct i2c_msg msg [] = { { .addr = 0x55, .flags = 0, .buf = b0, .len = 1 },
 			   { .addr = 0x55, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
 
-	ret = i2c->xfer (i2c, msg, 2);
+	ret = i2c_transfer(i2c, msg, 2);
 
 	if (ret != 2)
 		dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
@@ -86,12 +99,12 @@ static u8 l64781_readreg (struct dvb_i2c
 }
 
 
-static int tsa5060_write (struct dvb_i2c_bus *i2c, u8 data [4])
+static int tsa5060_write (struct i2c_adapter *i2c, u8 data [4])
 {
 	int ret;
 	struct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = 4 };
 
-	if ((ret = i2c->xfer (i2c, &msg, 1)) != 1)
+	if ((ret = i2c_transfer(i2c, &msg, 1)) != 1)
 		dprintk ("%s: write_reg error == %02x!\n", __FUNCTION__, ret);
 
 	return (ret != 1) ? -1 : 0;
@@ -103,14 +116,17 @@ static int tsa5060_write (struct dvb_i2c
  *   reference clock comparision frequency of 166666 Hz.
  *   frequency offset is 36125000 Hz.
  */
-static int tsa5060_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq)
+static int tsa5060_set_tv_freq (struct i2c_adapter *i2c, u32 freq)
 {
-#if 1
 	u32 div;
 	u8 buf [4];
 	u8 cfg, cpump, band_select;
 
-	div = (36125000 + freq) / 166666;
+	if (old_set_tv_freq)
+	        div = (36000000 + freq) / 166666;
+	else
+		div = (36125000 + freq) / 166666;
+
 	cfg = 0x88;
 
 	cpump = freq < 175000000 ? 2 : freq < 390000000 ? 1 :
@@ -121,27 +137,18 @@ static int tsa5060_set_tv_freq (struct d
 	buf [0] = (div >> 8) & 0x7f;
 	buf [1] = div & 0xff;
 	buf [2] = ((div >> 10) & 0x60) | cfg;
-	buf [3] = (cpump << 6) | band_select;
-#else
-	/* old code which seems to work better for at least one person */
-        u32 div;
-        u8 buf [4];
-        u8 cfg;
-
-        div = (36000000 + freq) / 166666;
-        cfg = 0x88;
 
-        buf [0] = (div >> 8) & 0x7f;
-        buf [1] = div & 0xff;
-        buf [2] = ((div >> 10) & 0x60) | cfg;
-        buf [3] = 0xc0;
-#endif
+	if (old_set_tv_freq)
+		buf [3] = 0xc0;
+	else
+		buf [3] = (cpump << 6) | band_select;
 
-	return tsa5060_write (i2c, buf);
+	return tsa5060_write(i2c, buf);
 }
 
 
-static void apply_tps (struct dvb_i2c_bus *i2c)
+
+static void apply_tps (struct i2c_adapter *i2c)
 {
 	l64781_writereg (i2c, 0x2a, 0x00);
 	l64781_writereg (i2c, 0x2a, 0x01);
@@ -155,7 +162,7 @@ static void apply_tps (struct dvb_i2c_bu
 }
 
 
-static void reset_afc (struct dvb_i2c_bus *i2c)
+static void reset_afc (struct i2c_adapter *i2c)
 {
 	/* Set AFC stall for the AFC_INIT_FRQ setting, TIM_STALL for
 	   timing offset */
@@ -173,7 +180,7 @@ static void reset_afc (struct dvb_i2c_bu
 }
 
 
-static int apply_frontend_param (struct dvb_i2c_bus *i2c,
+static int apply_frontend_param (struct i2c_adapter *i2c,
 			  struct dvb_frontend_parameters *param)
 {
 	/* The coderates for FEC_NONE, FEC_4_5 and FEC_FEC_6_7 are arbitrary */
@@ -285,16 +292,16 @@ static int apply_frontend_param (struct 
 }
 
 
-static int reset_and_configure (struct dvb_i2c_bus *i2c)
+static int reset_and_configure (struct i2c_adapter *i2c)
 {
 	u8 buf [] = { 0x06 };
 	struct i2c_msg msg = { .addr = 0x00, .flags = 0, .buf = buf, .len = 1 };
 
-	return (i2c->xfer (i2c, &msg, 1) == 1) ? 0 : -ENODEV;
+	return (i2c_transfer(i2c, &msg, 1) == 1) ? 0 : -ENODEV;
 }
 
 
-static int get_frontend(struct dvb_i2c_bus* i2c, struct dvb_frontend_parameters* param)
+static int get_frontend(struct i2c_adapter* i2c, struct dvb_frontend_parameters* param)
 {
 	int tmp;
 
@@ -412,7 +419,7 @@ static int get_frontend(struct dvb_i2c_b
 }
 
 
-static int init (struct dvb_i2c_bus *i2c)
+static int init (struct i2c_adapter *i2c)
 {
         reset_and_configure (i2c);
 
@@ -449,16 +456,16 @@ static int init (struct dvb_i2c_bus *i2c
 
 
 static 
-int grundig_29504_401_ioctl (struct dvb_frontend *fe,
+int l64781_ioctl (struct dvb_frontend *fe,
 			     unsigned int cmd, void *arg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
+	struct l64781_state* state = fe->data;
+	struct i2c_adapter *i2c = state->i2c;
 	int res;
-	struct grundig_state* state = (struct grundig_state*) fe->data;
 
         switch (cmd) {
         case FE_GET_INFO:
-		memcpy (arg, &grundig_29504_401_info,
+		memcpy (arg, &l64781_info,
 			sizeof(struct dvb_frontend_info));
                 break;
 
@@ -546,7 +553,7 @@ int grundig_29504_401_ioctl (struct dvb_
 		res = init (i2c);
 		if ((res == 0) && (state->first)) {
 			state->first = 0;
-			dvb_delay(200);
+			msleep(200);
 		}
 		return res;
 
@@ -567,28 +574,26 @@ int grundig_29504_401_ioctl (struct dvb_
         return 0;
 } 
 
-
-static int l64781_attach (struct dvb_i2c_bus *i2c, void **data)
+static int l64781_probe(struct i2c_adapter *i2c)
 {
 	u8 reg0x3e;
 	u8 b0 [] = { 0x1a };
 	u8 b1 [] = { 0x00 };
 	struct i2c_msg msg [] = { { .addr = 0x55, .flags = 0, .buf = b0, .len = 1 },
 			   { .addr = 0x55, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
-	struct grundig_state* state;
 
 	/**
 	 *  the L64781 won't show up before we send the reset_and_configure()
 	 *  broadcast. If nothing responds there is no L64781 on the bus...
 	 */
 	if (reset_and_configure(i2c) < 0) {
-		dprintk("no response on reset_and_configure() broadcast, bailing out...\n");
+		dprintk("No response to reset and configure broadcast...\n");
 		return -ENODEV;
 	}
 
 	/* The chip always responds to reads */
-	if (i2c->xfer(i2c, msg, 2) != 2) {  
-	        dprintk("no response to read on I2C bus\n");
+	if (i2c_transfer(i2c, msg, 2) != 2) {  
+	        dprintk("No response to read on I2C bus\n");
 		return -ENODEV;
 	}
 
@@ -607,58 +612,138 @@ static int l64781_attach (struct dvb_i2c
 	/* Responds to all reads with 0 */
 	if (l64781_readreg(i2c, 0x1a) != 0) {
  	        dprintk("Read 1 returned unexpcted value\n");
-	        goto bailout;
-	}	  
+	        goto out;
+	}
 
 	/* Turn the chip on */
 	l64781_writereg (i2c, 0x3e, 0xa5);
-	
+
 	/* Responds with register default value */
 	if (l64781_readreg(i2c, 0x1a) != 0xa1) { 
  	        dprintk("Read 2 returned unexpcted value\n");
-	        goto bailout;
+	        goto out;
 	}
 
-	state = kmalloc(sizeof(struct grundig_state), GFP_KERNEL);
-	if (state == NULL) goto bailout;
-	*data = state;
+	return 0;
+out:
+	l64781_writereg (i2c, 0x3e, reg0x3e);  /* restore reg 0x3e */
+	return -ENODEV;
+}
+
+static struct i2c_client client_template;
+
+static int l64781_attach_adapter(struct i2c_adapter *adapter)
+{
+	struct l64781_state *state;
+	struct i2c_client *client;
+	int ret;
+
+	dprintk("Trying to attach to adapter 0x%x:%s.\n",
+		adapter->id, adapter->name);
+
+	if ((ret = l64781_probe(adapter)))
+		return ret;
+
+	if ( !(state = kmalloc(sizeof(struct l64781_state), GFP_KERNEL)) )
+		return -ENOMEM;
+
+	memset(state, 0, sizeof(struct l64781_state));
+	state->i2c = adapter;
 	state->first = 1;
 
-	return dvb_register_frontend (grundig_29504_401_ioctl, i2c, state,
-			       &grundig_29504_401_info);
+	if ( !(client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)) ) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = 0; //XXX
+	i2c_set_clientdata(client, state);
+
+	if ((ret = i2c_attach_client(client))) {
+		kfree(state);
+		kfree(client);
+		return ret;
+	}
+
+	BUG_ON(!state->dvb);
+
+	if ((ret = dvb_register_frontend(l64781_ioctl, state->dvb, state,
+					     &l64781_info, THIS_MODULE))) {
+		i2c_detach_client(client);
+		kfree(state);
+		kfree(client);
+		return ret;
+	}
 
- bailout:
-	l64781_writereg (i2c, 0x3e, reg0x3e);  /* restore reg 0x3e */
-	return -ENODEV;
+	return 0;
 }
 
+static int l64781_detach_client(struct i2c_client *client)
+{
+	struct l64781_state *state = i2c_get_clientdata(client);
 
+	dvb_unregister_frontend(l64781_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
 
-static void l64781_detach (struct dvb_i2c_bus *i2c, void *data)
+static int l64781_command(struct i2c_client *client,
+			  unsigned int cmd, void *arg)
 {
-	kfree(data);
-	dvb_unregister_frontend (grundig_29504_401_ioctl, i2c);
+	struct l64781_state *data = i2c_get_clientdata(client);
+	dprintk ("%s\n", __FUNCTION__);
+
+	switch (cmd) {
+	case FE_REGISTER: {
+		data->dvb = arg;
+		break;
+	}
+	case FE_UNREGISTER: {
+		data->dvb = NULL;
+		break;
+	}
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= FRONTEND_NAME,
+	.id 		= I2C_DRIVERID_DVBFE_L64781,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = l64781_attach_adapter,
+	.detach_client 	= l64781_detach_client,
+	.command 	= l64781_command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
 
-static int __init init_grundig_29504_401 (void)
+static int __init init_l64781 (void)
 {
-	return dvb_register_i2c_device (THIS_MODULE,
-					l64781_attach, l64781_detach);
+	return i2c_add_driver(&driver);
 }
 
-
-static void __exit exit_grundig_29504_401 (void)
+static void __exit exit_l64781 (void)
 {
-	dvb_unregister_i2c_device (l64781_attach);
+	if (i2c_del_driver(&driver))
+		printk(KERN_ERR "l64781: driver deregistration failed\n");
 }
 
-module_init(init_grundig_29504_401);
-module_exit(exit_grundig_29504_401);
+module_init(init_l64781);
+module_exit(exit_l64781);
 
-MODULE_PARM(debug,"i");
-MODULE_PARM_DESC(debug, "enable verbose debug messages");
-MODULE_DESCRIPTION("Grundig 29504-401 DVB-T Frontend");
+MODULE_DESCRIPTION("Grundig 29504-401 DVB-T Frontend (LSI L64781 Based)");
 MODULE_AUTHOR("Holger Waechtler, Marko Kohtala");
 MODULE_LICENSE("GPL");
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/grundig_29504-491.c linux/drivers/media/dvb/frontends/grundig_29504-491.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/grundig_29504-491.c	2004-09-14 10:37:20.000000000 +0200
+++ linux/drivers/media/dvb/frontends/grundig_29504-491.c	2004-09-17 14:56:38.823596559 +0200
@@ -27,17 +27,31 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
-static int debug = 0;
-#define dprintk	if (debug) printk
+#define FRONTEND_NAME "dvbfe_tda8083"
 
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
 
-static struct dvb_frontend_info grundig_29504_491_info = {
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+
+struct tda8083_state {
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
+
+static struct dvb_frontend_info tda8083_info = {
 	.name			= "Grundig 29504-491, (TDA8083 based)",
 	.type			= FE_QPSK,
 	.frequency_min		= 950000,     /* FIXME: guessed! */
@@ -55,8 +69,6 @@ static struct dvb_frontend_info grundig_
 		FE_CAN_QPSK | FE_CAN_MUTE_TS
 };
 
-
-
 static u8 tda8083_init_tab [] = {
 	0x04, 0x00, 0x4a, 0x79, 0x04, 0x00, 0xff, 0xea,
 	0x48, 0x42, 0x79, 0x60, 0x70, 0x52, 0x9a, 0x10,
@@ -67,14 +79,13 @@ static u8 tda8083_init_tab [] = {
 };
 
 
-
-static int tda8083_writereg (struct dvb_i2c_bus *i2c, u8 reg, u8 data)
+static int tda8083_writereg (struct i2c_adapter *i2c, u8 reg, u8 data)
 {
 	int ret;
 	u8 buf [] = { reg, data };
 	struct i2c_msg msg = { .addr = 0x68, .flags = 0, .buf = buf, .len = 2 };
 
-        ret = i2c->xfer (i2c, &msg, 1);
+        ret = i2c_transfer(i2c, &msg, 1);
 
         if (ret != 1)
                 dprintk ("%s: writereg error (reg %02x, ret == %i)\n",
@@ -84,13 +95,13 @@ static int tda8083_writereg (struct dvb_
 }
 
 
-static int tda8083_readregs (struct dvb_i2c_bus *i2c, u8 reg1, u8 *b, u8 len)
+static int tda8083_readregs (struct i2c_adapter *i2c, u8 reg1, u8 *b, u8 len)
 {
 	int ret;
 	struct i2c_msg msg [] = { { .addr = 0x68, .flags = 0, .buf = &reg1, .len = 1 },
 			   { .addr = 0x68, .flags = I2C_M_RD, .buf = b, .len = len } };
 
-	ret = i2c->xfer (i2c, msg, 2);
+	ret = i2c_transfer(i2c, msg, 2);
 
 	if (ret != 2)
 		dprintk ("%s: readreg error (reg %02x, ret == %i)\n",
@@ -100,7 +111,7 @@ static int tda8083_readregs (struct dvb_
 }
 
 
-static inline u8 tda8083_readreg (struct dvb_i2c_bus *i2c, u8 reg)
+static inline u8 tda8083_readreg (struct i2c_adapter *i2c, u8 reg)
 {
 	u8 val;
 
@@ -110,12 +121,12 @@ static inline u8 tda8083_readreg (struct
 }
 
 
-static int tsa5522_write (struct dvb_i2c_bus *i2c, u8 data [4])
+static int tsa5522_write (struct i2c_adapter *i2c, u8 data [4])
 {
 	int ret;
 	struct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = 4 };
 
-	ret = i2c->xfer (i2c, &msg, 1);
+	ret = i2c_transfer(i2c, &msg, 1);
 
 	if (ret != 1)
 		dprintk("%s: i/o error (ret == %i)\n", __FUNCTION__, ret);
@@ -128,7 +139,7 @@ static int tsa5522_write (struct dvb_i2c
  *   set up the downconverter frequency divisor for a
  *   reference clock comparision frequency of 125 kHz.
  */
-static int tsa5522_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq)
+static int tsa5522_set_tv_freq (struct i2c_adapter *i2c, u32 freq)
 {
 	u32 div = freq / 125;
 	u8 buf [4] = { (div >> 8) & 0x7f, div & 0xff, 0x8e, 0x00 };
@@ -137,7 +148,7 @@ static int tsa5522_set_tv_freq (struct d
 }
 
 
-static int tda8083_init (struct dvb_i2c_bus *i2c)
+static int tda8083_init (struct i2c_adapter *i2c)
 {
 	int i;
 	
@@ -150,7 +161,7 @@ static int tda8083_init (struct dvb_i2c_
 }
 
 
-static int tda8083_set_inversion (struct dvb_i2c_bus *i2c, fe_spectral_inversion_t inversion)
+static int tda8083_set_inversion (struct i2c_adapter *i2c, fe_spectral_inversion_t inversion)
 {
 	/*  XXX FIXME: implement other modes than FEC_AUTO */
 	if (inversion == INVERSION_AUTO)
@@ -160,7 +171,7 @@ static int tda8083_set_inversion (struct
 }
 
 
-static int tda8083_set_fec (struct dvb_i2c_bus *i2c, fe_code_rate_t fec)
+static int tda8083_set_fec (struct i2c_adapter *i2c, fe_code_rate_t fec)
 {
 	if (fec == FEC_AUTO)
 		return tda8083_writereg (i2c, 0x07, 0xff);
@@ -172,7 +183,7 @@ static int tda8083_set_fec (struct dvb_i
 }
 
 
-static fe_code_rate_t tda8083_get_fec (struct dvb_i2c_bus *i2c)
+static fe_code_rate_t tda8083_get_fec (struct i2c_adapter *i2c)
 {
 	u8 index;
 	static fe_code_rate_t fec_tab [] = { FEC_8_9, FEC_1_2, FEC_2_3, FEC_3_4,
@@ -184,7 +195,7 @@ static fe_code_rate_t tda8083_get_fec (s
 }
 
 
-static int tda8083_set_symbolrate (struct dvb_i2c_bus *i2c, u32 srate)
+static int tda8083_set_symbolrate (struct i2c_adapter *i2c, u32 srate)
 {
         u32 ratio;
 	u32 tmp;
@@ -224,19 +235,19 @@ static int tda8083_set_symbolrate (struc
 }
 
 
-static void tda8083_wait_diseqc_fifo (struct dvb_i2c_bus *i2c, int timeout)
+static void tda8083_wait_diseqc_fifo (struct i2c_adapter *i2c, int timeout)
 {
 	unsigned long start = jiffies;
 
 	while (jiffies - start < timeout &&
                !(tda8083_readreg(i2c, 0x02) & 0x80))
 	{
-		dvb_delay(50);
+		msleep(50);
 	};
 }
 
 
-static int tda8083_send_diseqc_msg (struct dvb_i2c_bus *i2c,
+static int tda8083_send_diseqc_msg (struct i2c_adapter *i2c,
 			     struct dvb_diseqc_master_cmd *m)
 {
 	int i;
@@ -254,7 +265,7 @@ static int tda8083_send_diseqc_msg (stru
 }
 
 
-static int tda8083_send_diseqc_burst (struct dvb_i2c_bus *i2c, fe_sec_mini_cmd_t burst)
+static int tda8083_send_diseqc_burst (struct i2c_adapter *i2c, fe_sec_mini_cmd_t burst)
 {
 	switch (burst) {
 	case SEC_MINI_A:
@@ -273,7 +284,7 @@ static int tda8083_send_diseqc_burst (st
 }
 
 
-static int tda8083_set_tone (struct dvb_i2c_bus *i2c, fe_sec_tone_mode_t tone)
+static int tda8083_set_tone (struct i2c_adapter *i2c, fe_sec_tone_mode_t tone)
 {
 	tda8083_writereg (i2c, 0x26, 0xf1);
 
@@ -288,7 +299,7 @@ static int tda8083_set_tone (struct dvb_
 }
 
 
-static int tda8083_set_voltage (struct dvb_i2c_bus *i2c, fe_sec_voltage_t voltage)
+static int tda8083_set_voltage (struct i2c_adapter *i2c, fe_sec_voltage_t voltage)
 {
 	switch (voltage) {
 	case SEC_VOLTAGE_13:
@@ -301,15 +312,15 @@ static int tda8083_set_voltage (struct d
 }
 
 
-static int grundig_29504_491_ioctl (struct dvb_frontend *fe, unsigned int cmd,
-			     void *arg)
+static int tda8083_ioctl(struct dvb_frontend *fe, unsigned int cmd,
+			 void *arg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
+	struct tda8083_state *state = fe->data;
+	struct i2c_adapter *i2c = state->i2c;
 
         switch (cmd) {
 	case FE_GET_INFO:
-		memcpy (arg, &grundig_29504_491_info, 
-			sizeof(struct dvb_frontend_info));
+		memcpy (arg, &tda8083_info, sizeof(struct dvb_frontend_info));
                 break;
 
         case FE_READ_STATUS:
@@ -426,40 +437,119 @@ static int grundig_29504_491_ioctl (stru
 	return 0;
 } 
 
+static struct i2c_client client_template;
 
-static int tda8083_attach (struct dvb_i2c_bus *i2c, void **data)
+static int tda8083_attach_adapter(struct i2c_adapter *adapter)
 {
-	if ((tda8083_readreg (i2c, 0x00)) != 0x05)
+	struct tda8083_state *state;
+	struct i2c_client *client;
+	int ret;
+
+	dprintk("Trying to attach to adapter 0x%x:%s.\n",
+		adapter->id, adapter->name);
+
+	if ((tda8083_readreg (adapter, 0x00)) != 0x05)
 		return -ENODEV;
 
-	return dvb_register_frontend (grundig_29504_491_ioctl, i2c, NULL,
-			       &grundig_29504_491_info);
+	if ( !(state = kmalloc(sizeof(struct tda8083_state), GFP_KERNEL)) )
+		return -ENOMEM;
+
+	if ( !(client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)) ) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	memset(state, 0, sizeof(struct tda8083_state));
+	state->i2c = adapter;
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = 0; //XXX
+	i2c_set_clientdata(client, state);
+
+	if ((ret = i2c_attach_client(client))) {
+		kfree(state);
+		kfree(client);
+		return ret;
+	}
+
+	BUG_ON(!state->dvb);
+
+	if ((ret = dvb_register_frontend(tda8083_ioctl, state->dvb, state,
+					     &tda8083_info, THIS_MODULE))) {
+		i2c_detach_client(client);
+		kfree(state);
+		kfree(client);
+		return ret;
+	}
+
+	return 0;
 }
 
+static int tda8083_detach_client(struct i2c_client *client)
+{
+	struct tda8083_state *state = i2c_get_clientdata(client);
+
+	dvb_unregister_frontend (tda8083_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
 
-static void tda8083_detach (struct dvb_i2c_bus *i2c, void *data)
+static int tda8083_command (struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	dvb_unregister_frontend (grundig_29504_491_ioctl, i2c);
+	struct tda8083_state *data = i2c_get_clientdata(client);
+	dprintk ("%s\n", __FUNCTION__);
+
+	switch (cmd) {
+	case FE_REGISTER: {
+		data->dvb = arg;
+		break;
+	}
+	case FE_UNREGISTER: {
+		data->dvb = NULL;
+		break;
+	}
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= FRONTEND_NAME,
+	.id 		= I2C_DRIVERID_DVBFE_TDA8083,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = tda8083_attach_adapter,
+	.detach_client 	= tda8083_detach_client,
+	.command 	= tda8083_command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
 
 static int __init init_tda8083 (void)
 {
-	return dvb_register_i2c_device (THIS_MODULE,
-					tda8083_attach, tda8083_detach);
+	return i2c_add_driver(&driver);
 }
 
-
-static void __exit exit_tda8083 (void)
+static void __exit exit_tda8083(void)
 {
-	dvb_unregister_i2c_device (tda8083_attach);
+	if (i2c_del_driver(&driver))
+		printk("grundig_29504_401: driver deregistration failed\n");
 }
 
 module_init(init_tda8083);
 module_exit(exit_tda8083);
 
-MODULE_PARM(debug,"i");
-MODULE_DESCRIPTION("Grundig 29504-491 DVB frontend driver");
+MODULE_DESCRIPTION("Grundig 29504-491 DVB frontend driver (TDA8083 Based)");
 MODULE_AUTHOR("Ralph Metzler, Holger Waechtler");
 MODULE_LICENSE("GPL");
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/mt312.c linux/drivers/media/dvb/frontends/mt312.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/mt312.c	2004-09-14 10:34:41.000000000 +0200
+++ linux/drivers/media/dvb/frontends/mt312.c	2004-09-17 14:56:38.828595623 +0200
@@ -28,30 +28,32 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 
 #include "dvb_frontend.h"
 #include "mt312.h"
 
+#define FRONTEND_NAME "dvbfe_mt312"
+
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
+
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+
 #define I2C_ADDR_MT312		0x0e
 #define I2C_ADDR_SL1935		0x61
 #define I2C_ADDR_TSA5059	0x61
 
-#define MT312_DEBUG		0
-
 #define MT312_SYS_CLK		90000000UL	/* 90 MHz */
 #define MT312_LPOWER_SYS_CLK	60000000UL	/* 60 MHz */
 #define MT312_PLL_CLK		10000000UL	/* 10 MHz */
 
-/* number of active frontends */
-static int mt312_count = 0;
-
-#if MT312_DEBUG == 0
-#define dprintk(x...)
-#else
-static int debug = 0;
-#define dprintk if(debug == 1) printk
-#endif
-
 static struct dvb_frontend_info mt312_info = {
 	.name = "Zarlink MT312",
 	.type = FE_QPSK,
@@ -70,7 +72,13 @@ static struct dvb_frontend_info mt312_in
             FE_CAN_RECOVER
 };
 
-static int mt312_read(struct dvb_i2c_bus *i2c,
+struct mt312_state {
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+	int id;
+};
+
+static int mt312_read(struct i2c_adapter *i2c,
 		      const enum mt312_reg_addr reg, void *buf,
 		      const size_t count)
 {
@@ -87,26 +95,25 @@ static int mt312_read(struct dvb_i2c_bus
 	msg[1].buf = buf;
 	msg[1].len = count;
 
-	ret = i2c->xfer(i2c, msg, 2);
+	ret = i2c_transfer(i2c, msg, 2);
 
-	if ((ret != 2) && (mt312_count != 0)) {
+	if (ret != 2) {
 		printk(KERN_ERR "%s: ret == %d\n", __FUNCTION__, ret);
 		return -EREMOTEIO;
 	}
-#if MT312_DEBUG
+
 	if(debug) {
 		int i;
-		printk(KERN_INFO "R(%d):", reg & 0x7f);
+		dprintk("R(%d):", reg & 0x7f);
 		for (i = 0; i < count; i++)
 			printk(" %02x", ((const u8 *) buf)[i]);
 		printk("\n");
 	}
-#endif
 
 	return 0;
 }
 
-static int mt312_write(struct dvb_i2c_bus *i2c,
+static int mt312_write(struct i2c_adapter *i2c,
 		       const enum mt312_reg_addr reg, const void *src,
 		       const size_t count)
 {
@@ -114,15 +121,13 @@ static int mt312_write(struct dvb_i2c_bu
 	u8 buf[count + 1];
 	struct i2c_msg msg;
 
-#if MT312_DEBUG
 	if(debug) {
 		int i;
-		printk(KERN_INFO "W(%d):", reg & 0x7f);
+		dprintk("W(%d):", reg & 0x7f);
 		for (i = 0; i < count; i++)
 			printk(" %02x", ((const u8 *) src)[i]);
 		printk("\n");
 	}
-#endif
 
 	buf[0] = reg;
 	memcpy(&buf[1], src, count);
@@ -132,29 +137,29 @@ static int mt312_write(struct dvb_i2c_bu
 	msg.buf = buf;
 	msg.len = count + 1;
 
-	ret = i2c->xfer(i2c, &msg, 1);
+	ret = i2c_transfer(i2c, &msg, 1);
 
 	if (ret != 1) {
-		printk(KERN_ERR "%s: ret == %d\n", __FUNCTION__, ret);
+		dprintk("%s: ret == %d\n", __FUNCTION__, ret);
 		return -EREMOTEIO;
 	}
 
 	return 0;
 }
 
-static inline int mt312_readreg(struct dvb_i2c_bus *i2c,
-				const enum mt312_reg_addr reg, u8 * val)
+static inline int mt312_readreg(struct i2c_adapter *i2c,
+				const enum mt312_reg_addr reg, u8 *val)
 {
 	return mt312_read(i2c, reg, val, 1);
 }
 
-static inline int mt312_writereg(struct dvb_i2c_bus *i2c,
+static inline int mt312_writereg(struct i2c_adapter *i2c,
 				 const enum mt312_reg_addr reg, const u8 val)
 {
 	return mt312_write(i2c, reg, &val, 1);
 }
 
-static int mt312_pll_write(struct dvb_i2c_bus *i2c, const u8 addr,
+static int mt312_pll_write(struct i2c_adapter *i2c, const u8 addr,
 			   u8 * buf, const u8 len)
 {
 	int ret;
@@ -168,7 +173,7 @@ static int mt312_pll_write(struct dvb_i2
 	if ((ret = mt312_writereg(i2c, GPP_CTRL, 0x40)) < 0)
 		return ret;
 
-	if ((ret = i2c->xfer(i2c, &msg, 1)) != 1)
+	if ((ret = i2c_transfer(i2c, &msg, 1)) != 1)
 		printk(KERN_ERR "%s: i/o error (ret == %d)\n", __FUNCTION__, ret);
 
 	if ((ret = mt312_writereg(i2c, GPP_CTRL, 0x00)) < 0)
@@ -182,7 +187,7 @@ static inline u32 mt312_div(u32 a, u32 b
 	return (a + (b / 2)) / b;
 }
 
-static int sl1935_set_tv_freq(struct dvb_i2c_bus *i2c, u32 freq, u32 sr)
+static int sl1935_set_tv_freq(struct i2c_adapter *i2c, u32 freq, u32 sr)
 {
 	/* 155 uA, Baseband Path B */
 	u8 buf[4] = { 0x00, 0x00, 0x80, 0x00 };
@@ -219,7 +224,7 @@ static int sl1935_set_tv_freq(struct dvb
 	return mt312_pll_write(i2c, I2C_ADDR_SL1935, buf, sizeof(buf));
 }
 
-static int tsa5059_set_tv_freq(struct dvb_i2c_bus *i2c, u32 freq, u32 sr)
+static int tsa5059_set_tv_freq(struct i2c_adapter *i2c, u32 freq, u32 sr)
 {
 	u8 buf[4];
 
@@ -239,13 +244,14 @@ static int tsa5059_set_tv_freq(struct dv
 	return mt312_pll_write(i2c, I2C_ADDR_TSA5059, buf, sizeof(buf));
 }
 
-static int mt312_reset(struct dvb_i2c_bus *i2c, const u8 full)
+static int mt312_reset(struct i2c_adapter *i2c, const u8 full)
 {
 	return mt312_writereg(i2c, RESET, full ? 0x80 : 0x40);
 }
 
-static int mt312_init(struct dvb_i2c_bus *i2c, const long id, u8 pll)
+static int mt312_initfe(struct mt312_state *state, u8 pll)
 {
+	struct i2c_adapter *i2c = state->i2c;
 	int ret;
 	u8 buf[2];
 
@@ -297,7 +303,7 @@ static int mt312_init(struct dvb_i2c_bus
 	return 0;
 }
 
-static int mt312_send_master_cmd(struct dvb_i2c_bus *i2c,
+static int mt312_send_master_cmd(struct i2c_adapter *i2c,
 				 const struct dvb_diseqc_master_cmd *c)
 {
 	int ret;
@@ -328,14 +334,14 @@ static int mt312_send_master_cmd(struct 
 	return 0;
 }
 
-static int mt312_recv_slave_reply(struct dvb_i2c_bus *i2c,
+static int mt312_recv_slave_reply(struct i2c_adapter *i2c,
 				  struct dvb_diseqc_slave_reply *r)
 {
 	/* TODO */
 	return -EOPNOTSUPP;
 }
 
-static int mt312_send_burst(struct dvb_i2c_bus *i2c, const fe_sec_mini_cmd_t c)
+static int mt312_send_burst(struct i2c_adapter *i2c, const fe_sec_mini_cmd_t c)
 {
 	const u8 mini_tab[2] = { 0x02, 0x03 };
 
@@ -356,7 +362,7 @@ static int mt312_send_burst(struct dvb_i
 	return 0;
 }
 
-static int mt312_set_tone(struct dvb_i2c_bus *i2c, const fe_sec_tone_mode_t t)
+static int mt312_set_tone(struct i2c_adapter *i2c, const fe_sec_tone_mode_t t)
 {
 	const u8 tone_tab[2] = { 0x01, 0x00 };
 
@@ -377,7 +383,7 @@ static int mt312_set_tone(struct dvb_i2c
 	return 0;
 }
 
-static int mt312_set_voltage(struct dvb_i2c_bus *i2c, const fe_sec_voltage_t v)
+static int mt312_set_voltage(struct i2c_adapter *i2c, const fe_sec_voltage_t v)
 {
 	const u8 volt_tab[3] = { 0x00, 0x40, 0x00 };
 
@@ -387,8 +393,9 @@ static int mt312_set_voltage(struct dvb_
 	return mt312_writereg(i2c, DISEQC_MODE, volt_tab[v]);
 }
 
-static int mt312_read_status(struct dvb_i2c_bus *i2c, fe_status_t *s, const long id)
+static int mt312_read_status(struct mt312_state *state, fe_status_t *s)
 {
+	struct i2c_adapter *i2c = state->i2c;
 	int ret;
 	u8 status[3], vit_mode;
 
@@ -409,8 +416,9 @@ static int mt312_read_status(struct dvb_
 		*s |= FE_HAS_SYNC;	/* byte align lock */
 	if (status[0] & 0x01)
 		*s |= FE_HAS_LOCK;	/* qpsk lock */
+
 	// VP310 doesn't have AUTO, so we "implement it here" ACCJr
-	if ((id == ID_VP310) && !(status[0] & 0x01)) {
+	if ((state->id == ID_VP310) && !(status[0] & 0x01)) {
 		if ((ret = mt312_readreg(i2c, VIT_MODE, &vit_mode)) < 0)
 			return ret;
 		vit_mode ^= 0x40;
@@ -423,7 +431,7 @@ static int mt312_read_status(struct dvb_
 	return 0;
 }
 
-static int mt312_read_bercnt(struct dvb_i2c_bus *i2c, u32 * ber)
+static int mt312_read_bercnt(struct i2c_adapter *i2c, u32 *ber)
 {
 	int ret;
 	u8 buf[3];
@@ -436,7 +444,7 @@ static int mt312_read_bercnt(struct dvb_
 	return 0;
 }
 
-static int mt312_read_agc(struct dvb_i2c_bus *i2c, u16 * signal_strength)
+static int mt312_read_agc(struct i2c_adapter *i2c, u16 *signal_strength)
 {
 	int ret;
 	u8 buf[3];
@@ -456,7 +464,7 @@ static int mt312_read_agc(struct dvb_i2c
 	return 0;
 }
 
-static int mt312_read_snr(struct dvb_i2c_bus *i2c, u16 * snr)
+static int mt312_read_snr(struct i2c_adapter *i2c, u16 *snr)
 {
 	int ret;
 	u8 buf[2];
@@ -469,7 +477,7 @@ static int mt312_read_snr(struct dvb_i2c
 	return 0;
 }
 
-static int mt312_read_ubc(struct dvb_i2c_bus *i2c, u32 * ubc)
+static int mt312_read_ubc(struct i2c_adapter *i2c, u32 *ubc)
 {
 	int ret;
 	u8 buf[2];
@@ -482,10 +490,10 @@ static int mt312_read_ubc(struct dvb_i2c
 	return 0;
 }
 
-static int mt312_set_frontend(struct dvb_i2c_bus *i2c,
-			      const struct dvb_frontend_parameters *p,
-			      const long id)
+static int mt312_set_frontend(struct mt312_state *state,
+			      const struct dvb_frontend_parameters *p)
 {
+	struct i2c_adapter *i2c = state->i2c;
 	int ret;
 	u8 buf[5], config_val;
 	u16 sr;
@@ -494,7 +502,7 @@ static int mt312_set_frontend(struct dvb
 	    { 0x00, 0x01, 0x02, 0x04, 0x3f, 0x08, 0x10, 0x20, 0x3f, 0x3f };
 	const u8 inv_tab[3] = { 0x00, 0x40, 0x80 };
 
-	int (*set_tv_freq)(struct dvb_i2c_bus *i2c, u32 freq, u32 sr);
+	int (*set_tv_freq)(struct i2c_adapter *i2c, u32 freq, u32 sr);
 
 	dprintk("%s: Freq %d\n", __FUNCTION__, p->frequency);
 
@@ -518,7 +526,7 @@ static int mt312_set_frontend(struct dvb
 	    || (p->u.qpsk.fec_inner == FEC_8_9))
 		return -EINVAL;
 
-	switch (id) {
+	switch (state->id) {
 	case ID_VP310:
 	// For now we will do this only for the VP310.
 	// It should be better for the mt312 as well, but tunning will be slower. ACCJr 09/29/03
@@ -527,13 +535,13 @@ static int mt312_set_frontend(struct dvb
 		if (p->u.qpsk.symbol_rate >= 30000000) //Note that 30MS/s should use 90MHz
 		{
 			if ((config_val & 0x0c) == 0x08) //We are running 60MHz
-				if ((ret = mt312_init(i2c, id, (u8) 90)) < 0)
+				if ((ret = mt312_initfe(state, (u8) 90)) < 0)
 					return ret;
 		}
 		else
 		{
 			if ((config_val & 0x0c) == 0x0C) //We are running 90MHz
-				if ((ret = mt312_init(i2c, id, (u8) 60)) < 0)
+				if ((ret = mt312_initfe(state, (u8) 60)) < 0)
 					return ret;
 		}
 		set_tv_freq = tsa5059_set_tv_freq;
@@ -575,8 +583,8 @@ static int mt312_set_frontend(struct dvb
 	return 0;
 }
 
-static int mt312_get_inversion(struct dvb_i2c_bus *i2c,
-			       fe_spectral_inversion_t * i)
+static int mt312_get_inversion(struct i2c_adapter *i2c,
+			       fe_spectral_inversion_t *i)
 {
 	int ret;
 	u8 vit_mode;
@@ -590,7 +598,7 @@ static int mt312_get_inversion(struct dv
 	return 0;
 }
 
-static int mt312_get_symbol_rate(struct dvb_i2c_bus *i2c, u32 * sr)
+static int mt312_get_symbol_rate(struct i2c_adapter *i2c, u32 *sr)
 {
 	int ret;
 	u8 sym_rate_h;
@@ -637,7 +645,7 @@ static int mt312_get_symbol_rate(struct 
 	return 0;
 }
 
-static int mt312_get_code_rate(struct dvb_i2c_bus *i2c, fe_code_rate_t * cr)
+static int mt312_get_code_rate(struct i2c_adapter *i2c, fe_code_rate_t *cr)
 {
 	const fe_code_rate_t fec_tab[8] =
 	    { FEC_1_2, FEC_2_3, FEC_3_4, FEC_5_6, FEC_6_7, FEC_7_8,
@@ -654,7 +662,7 @@ static int mt312_get_code_rate(struct dv
 	return 0;
 }
 
-static int mt312_get_frontend(struct dvb_i2c_bus *i2c,
+static int mt312_get_frontend(struct i2c_adapter *i2c,
 			      struct dvb_frontend_parameters *p)
 {
 	int ret;
@@ -671,7 +679,7 @@ static int mt312_get_frontend(struct dvb
 	return 0;
 }
 
-static int mt312_sleep(struct dvb_i2c_bus *i2c)
+static int mt312_sleep(struct i2c_adapter *i2c)
 {
 	int ret;
 	u8 config;
@@ -692,7 +700,8 @@ static int mt312_sleep(struct dvb_i2c_bu
 
 static int mt312_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
+	struct mt312_state *state = fe->data;
+	struct i2c_adapter *i2c = state->i2c;
 
 	switch (cmd) {
 	case FE_GET_INFO:
@@ -706,7 +715,7 @@ static int mt312_ioctl(struct dvb_fronte
 		return mt312_send_master_cmd(i2c, arg);
 
 	case FE_DISEQC_RECV_SLAVE_REPLY:
-		if ((long) fe->data == ID_MT312)
+		if (state->id == ID_MT312)
 			return mt312_recv_slave_reply(i2c, arg);
 		else
 			return -EOPNOTSUPP;
@@ -724,7 +733,7 @@ static int mt312_ioctl(struct dvb_fronte
 		return -EOPNOTSUPP;
 
 	case FE_READ_STATUS:
-		return mt312_read_status(i2c, arg, (long) fe->data);
+		return mt312_read_status(state, arg);
 
 	case FE_READ_BER:
 		return mt312_read_bercnt(i2c, arg);
@@ -739,7 +748,7 @@ static int mt312_ioctl(struct dvb_fronte
 		return mt312_read_ubc(i2c, arg);
 
 	case FE_SET_FRONTEND:
-		return mt312_set_frontend(i2c, arg, (long) fe->data);
+		return mt312_set_frontend(state, arg);
 
 	case FE_GET_FRONTEND:
 		return mt312_get_frontend(i2c, arg);
@@ -751,12 +760,14 @@ static int mt312_ioctl(struct dvb_fronte
 		return mt312_sleep(i2c);
 
 	case FE_INIT:
-	//For the VP310 we should run at 60MHz when ever possible.
-	//It should be better to run the mt312 ar lower speed when ever possible, but tunning will be slower. ACCJr 09/29/03
-		if ((long)fe->data == ID_MT312)
-			return mt312_init(i2c, (long) fe->data, (u8) 90);
+		/* For the VP310 we should run at 60MHz when ever possible.
+		 * It should be better to run the mt312 ar lower speed when
+		 * ever possible, but tunning will be slower. ACCJr 09/29/03
+		 */
+		if (state->id == ID_MT312)
+			return mt312_initfe(state, (u8) 90);
 		else
-			return mt312_init(i2c, (long) fe->data, (u8) 60);
+			return mt312_initfe(state, (u8) 60);
 
 	case FE_GET_TUNE_SETTINGS:
 	{
@@ -774,52 +785,124 @@ static int mt312_ioctl(struct dvb_fronte
 	return 0;
 }
 
-static int mt312_attach(struct dvb_i2c_bus *i2c, void **data)
+static struct i2c_client client_template;
+
+static int mt312_attach_adapter(struct i2c_adapter *adapter)
 {
+	struct mt312_state *state;
+	struct i2c_client *client;
 	int ret;
 	u8 id;
 
-	if ((ret = mt312_readreg(i2c, ID, &id)) < 0)
-		return ret;
+	dprintk("Trying to attach to adapter 0x%x:%s.\n",
+		adapter->id, adapter->name);
+
+	if (mt312_readreg(adapter, ID, &id) < 0)
+		return -ENODEV;
 
 	if ((id != ID_VP310) && (id != ID_MT312))
 		return -ENODEV;
 
-	if ((ret = dvb_register_frontend(mt312_ioctl, i2c,
-				(void *)(long)id, &mt312_info)) < 0)
+	if ( !(state = kmalloc(sizeof(struct mt312_state), GFP_KERNEL)) )
+		return -ENOMEM;
+
+	memset(state, 0, sizeof(struct mt312_state));
+	state->i2c = adapter;
+	state->id = id;
+
+	if ( !(client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)) ) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = I2C_ADDR_MT312;
+	i2c_set_clientdata(client, state);
+
+	if ((ret = i2c_attach_client(client))) {
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	BUG_ON(!state->dvb);
+
+	if ((ret = dvb_register_frontend(mt312_ioctl, state->dvb, state,
+					     &mt312_info, THIS_MODULE))) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(state);
 		return ret;
+	}
 
-	mt312_count++;
+	return 0;
+}
 
+static int mt312_detach_client(struct i2c_client *client)
+{
+	struct mt312_state *state = i2c_get_clientdata(client);
+
+	dprintk ("%s\n", __FUNCTION__);
+
+	dvb_unregister_frontend (mt312_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
 	return 0;
 }
 
-static void mt312_detach(struct dvb_i2c_bus *i2c, void *data)
+static int mt312_command (struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	dvb_unregister_frontend(mt312_ioctl, i2c);
+	struct mt312_state *state = i2c_get_clientdata(client);
+
+	dprintk ("%s\n", __FUNCTION__);
 
-	if (mt312_count)
-		mt312_count--;
+	switch (cmd) {
+	case FE_REGISTER:
+		state->dvb = arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= FRONTEND_NAME,
+	.id 		= I2C_DRIVERID_DVBFE_MT312,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = mt312_attach_adapter,
+	.detach_client 	= mt312_detach_client,
+	.command 	= mt312_command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
+
 static int __init mt312_module_init(void)
 {
-	return dvb_register_i2c_device(THIS_MODULE, mt312_attach, mt312_detach);
+	return i2c_add_driver(&driver);
 }
 
 static void __exit mt312_module_exit(void)
 {
-	dvb_unregister_i2c_device(mt312_attach);
+	if (i2c_del_driver(&driver))
+		printk(KERN_ERR "mt312: driver deregistration failed.\n");
 }
 
 module_init(mt312_module_init);
 module_exit(mt312_module_exit);
 
-#if MT312_DEBUG != 0
-MODULE_PARM(debug,"i");
-MODULE_PARM_DESC(debug, "enable verbose debug messages");
-#endif
-
 MODULE_DESCRIPTION("MT312 Satellite Channel Decoder Driver");
 MODULE_AUTHOR("Andreas Oberritter <obi@linuxtv.org>");
 MODULE_LICENSE("GPL");
+
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/mt352.c linux/drivers/media/dvb/frontends/mt352.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/mt352.c	2004-09-17 14:56:38.831595061 +0200
+++ linux/drivers/media/dvb/frontends/mt352.c	2004-09-17 14:56:38.831595061 +0200
@@ -0,0 +1,901 @@
+/*
+ *  Driver for Zarlink DVB-T MT352 demodulator
+ *
+ *  Written by Holger Waechtler <holger@qanu.de>
+ *	 and Daniel Mack <daniel@qanu.de>
+ *
+ *  AVerMedia AVerTV DVB-T 771 support by
+ *       Wolfram Joost <dbox2@frokaschwei.de>
+ *
+ *  Support for Samsung TDTC9251DH01C(M) tuner
+ *
+ *  Copyright (C) 2004 Antonio Mancuso <antonio.mancuso@digitaltelevision.it>
+ *                     Amauri  Celani  <acelani@essegi.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include "dvb_frontend.h"
+#include "mt352.h"
+
+#define FRONTEND_NAME "dvbfe_mt352"
+
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
+
+static int debug;
+static int force_card = -1;
+static int card_type = -1;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+//FIXME: Should be an array.
+module_param(force_card, int, 0444);
+MODULE_PARM_DESC(force_card, "Force card type.\n\t(0 == AVDVBT771, 1 == TUA6034, "
+		 "2 == TDTC9251DH01C).\n\tDefault is that AVDVBT771 is attempted "
+		 "to be autodetected,\n\tif you do not have this card, you must "
+		 "specify the card type here.");
+
+
+struct mt352_state {
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
+
+#define mt352_write(ibuf, ilen)						\
+do {									\
+	struct i2c_msg msg = { .addr = I2C_MT352_ADDR, .flags = 0,	\
+			       .buf = ibuf, .len = ilen };		\
+	int err = i2c_transfer(i2c, &msg, 1);				\
+	if (err != 1) {							\
+		printk(KERN_WARNING					\
+		       "mt352_write() failed (err = %d)!\n", err);	\
+		return err;						\
+	}								\
+} while (0)
+
+// FIXME:
+static struct _tuner_info tuner_info [] = {
+	//AVERMEDIA 771 board
+	{
+	  .fe_frequency_min = 174000000,
+	  .fe_frequency_max = 862000000,
+	  .fe_frequency_stepsize = 83333,
+	  .coderate_hp_shift = 7,
+	  .coderate_lp_shift = 4,
+	  .constellation_shift = 13,
+	  .tx_mode_shift = 0,
+	  .guard_interval_shift = 2,
+	  .hierarchy_shift = 10,
+	  .read_reg_flag = I2C_M_NOSTART,
+	  .mt352_init = mt352_init_AVERMEDIA771,
+	  .mt352_charge_pump = mt352_cp_AVERMEDIA771,
+	  .mt352_band_select = mt352_bs_AVERMEDIA771
+	},
+	//TUA6034 tuner
+	{
+	  .fe_frequency_min = 174000000,
+	  .fe_frequency_max = 862000000,
+	  .fe_frequency_stepsize = 166667,
+	  .coderate_hp_shift = 9,
+	  .coderate_lp_shift = 6,
+	  .constellation_shift = 14,
+	  .tx_mode_shift = 1,
+	  .guard_interval_shift = 3,
+	  .hierarchy_shift = 12,
+	  .read_reg_flag = I2C_M_NOSTART,
+	  .mt352_init = mt352_init_TUA6034,
+	  .mt352_charge_pump = mt352_cp_TUA6034,
+	  .mt352_band_select = mt352_bs_TUA6034
+	},
+	//TDTC9251DH01C tuner
+	{
+	  .fe_frequency_min = 474000000,
+	  .fe_frequency_max = 858000000,
+	  .fe_frequency_stepsize = 166667,
+	  .coderate_hp_shift = 9,
+	  .coderate_lp_shift = 6,
+	  .constellation_shift = 4,
+	  .tx_mode_shift = 1,
+	  .guard_interval_shift = 3,
+	  .hierarchy_shift = 12,
+	  .read_reg_flag = 0,
+	  .mt352_init = mt352_init_TDTC9251DH01C,
+	  .mt352_charge_pump = mt352_cp_TDTC9251DH01C,
+	  .mt352_band_select = mt352_bs_TDTC9251DH01C
+	}
+};
+
+
+static struct dvb_frontend_info mt352_info = {
+	.name			= "DVB-T Zarlink MT352 demodulator driver",
+	.type			= FE_OFDM,
+/*
+	.frequency_min		= 0,
+	.frequency_max		= 0,
+	.frequency_stepsize	= 0,
+	.frequency_tolerance	= 0,
+	.symbol_rate_min	= 1000000,
+	.symbol_rate_max	= 45000000,
+	.symbol_rate_tolerance	= ???,
+*/
+	.notifier_delay		 = 0,
+	.caps = FE_CAN_INVERSION_AUTO | FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
+		FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
+		FE_CAN_FEC_AUTO |
+		FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+		FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
+		FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |
+		FE_CAN_MUTE_TS
+};
+
+static int mt352_init_TUA6034(struct i2c_adapter *i2c)
+{
+	static u8 mt352_reset [] = { RESET, 0x80 };
+	static u8 mt352_clock_config [] = { CLOCK_CTL, 0x38, 0x2d };
+	static u8 mt352_adc_ctl_1_cfg [] = { ADC_CTL_1, 0x40 };
+	static u8 mt352_agc_cfg [] = { AGC_TARGET, 0x19, 0xa0 };
+	static u8 mt352_acq_ctl [] = { ACQ_CTL, 0x50 };
+
+	mt352_write(mt352_clock_config, sizeof(mt352_clock_config));
+	udelay(2000);
+	mt352_write(mt352_reset, sizeof(mt352_reset));
+	mt352_write(mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));
+	mt352_write(mt352_acq_ctl, sizeof(mt352_acq_ctl));
+
+	mt352_write(mt352_agc_cfg, sizeof(mt352_agc_cfg));
+
+	return 0;
+}
+
+static int mt352_init_AVERMEDIA771(struct i2c_adapter *i2c)
+{
+	static u8 mt352_reset [] = { RESET, 0x80 };
+	static u8 mt352_clock_config [] = { CLOCK_CTL, 0x38, 0x2d };
+	static u8 mt352_adc_ctl_1_cfg [] = { ADC_CTL_1, 0x40 };
+	static u8 mt352_agc_cfg [] = { AGC_TARGET, 0x10, 0x23, 0x00, 0xFF, 0xFF,
+				       0x00, 0xFF, 0x00, 0x40, 0x40 };
+	static u8 mt352_acq_ctl [] = { ACQ_CTL, 0x50 };
+	static u8 mt352_av771_extra[] = { 0xB5, 0x7A };
+
+	mt352_write(mt352_clock_config, sizeof(mt352_clock_config));
+	udelay(2000);
+	mt352_write(mt352_reset, sizeof(mt352_reset));
+	mt352_write(mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));
+	mt352_write(mt352_acq_ctl, sizeof(mt352_acq_ctl));
+
+	mt352_write(mt352_agc_cfg,sizeof(mt352_agc_cfg));
+	udelay(2000);
+	mt352_write(mt352_av771_extra,sizeof(mt352_av771_extra));
+
+	return 0;
+}
+
+static int mt352_init_TDTC9251DH01C(struct i2c_adapter *i2c)
+{
+	static u8 mt352_reset [] = { RESET, 0x80 };
+	static u8 mt352_clock_config [] = { CLOCK_CTL, 0x10, 0x2d };
+	static u8 mt352_adc_ctl_1_cfg [] = { ADC_CTL_1, 0x40 };
+	static u8 mt352_agc_cfg [] = { AGC_TARGET, 0x28, 0xa1 };
+	static u8 mt352_acq_ctl [] = { ACQ_CTL, 0x50 };
+
+	mt352_write(mt352_clock_config, sizeof(mt352_clock_config));
+	udelay(2000);
+	mt352_write(mt352_reset, sizeof(mt352_reset));
+	mt352_write(mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));
+	mt352_write(mt352_acq_ctl, sizeof(mt352_acq_ctl));
+
+	mt352_write(mt352_agc_cfg, sizeof(mt352_agc_cfg));
+
+	return 0;
+}
+
+static unsigned char mt352_cp_TUA6034(u32 freq)
+{
+	unsigned char cp = 0;
+
+	if (freq < 542)
+		cp = 0xbe;
+	else if (freq < 830)
+		cp = 0xf6;
+	else
+		cp = 0xfe;
+
+	return cp;
+}
+
+static unsigned char mt352_cp_AVERMEDIA771(u32 freq)
+{
+	unsigned char cp = 0;
+
+	if (freq < 150)
+		cp = 0xB4;
+	else if (freq < 173)
+		cp = 0xBC;
+	else if (freq < 250)
+		cp = 0xB4;
+	else if (freq < 400)
+		cp = 0xBC;
+	else if (freq < 420)
+		cp = 0xF4;
+	else if (freq < 470)
+		cp = 0xFC;
+	else if (freq < 600)
+		cp = 0xBC;
+	else if (freq < 730)
+		cp = 0xF4;
+	else
+		cp = 0xFC;
+
+	return cp;
+}
+
+static unsigned char mt352_cp_TDTC9251DH01C(u32 freq)
+{
+	return(0xcc);
+}
+
+static unsigned char mt352_bs_TUA6034(u32 freq)
+{
+	unsigned char bs = 0;
+
+	if (freq < 250)
+		bs = 0x01;
+	else
+		bs = 0x08;
+
+	return bs;
+}
+
+static unsigned char mt352_bs_AVERMEDIA771(u32 freq)
+{
+	unsigned char bs = 0;
+
+	if (freq < 150)
+		bs = 0x01;
+	else if (freq < 173)
+		bs = 0x01;
+	else if (freq < 250)
+		bs = 0x02;
+	else if (freq < 400)
+		bs = 0x02;
+	else if (freq < 420)
+		bs = 0x02;
+	else if (freq < 470)
+		bs = 0x02;
+	else if (freq < 600)
+		bs = 0x08;
+	else if (freq < 730)
+		bs = 0x08;
+	else
+		bs = 0x08;
+
+	return bs;
+}
+
+static unsigned char mt352_bs_TDTC9251DH01C(u32 freq)
+{
+	unsigned char bs = 0;
+
+	if ((freq >= 48) && (freq <= 154))      /* low band */
+		bs = 0x09;
+
+	if ((freq >= 161) && (freq <= 439))     /* medium band */
+		bs = 0x0a;
+
+	if ((freq >= 447) && (freq <= 863))     /* high band */
+		bs = 0x08;
+
+	return bs;
+}
+
+
+static int mt352_detect_avermedia_771(struct i2c_adapter *i2c)
+{
+	int i;
+	u8 reg;
+	u8 id[4];
+	const u8 pciid[4] = { 0x07, 0x71, 0x14, 0x61 };
+	struct i2c_msg msg[2] =
+	{
+		{
+			.addr = 0x50,
+			.flags = I2C_M_NOSTART,
+			.buf = &reg,
+			.len = 1
+		},
+		{
+			.addr = 0x50,
+			.flags = I2C_M_RD,
+			.len = 1
+		}
+	};
+
+	for (i = 0; i < 4; i++)
+	{
+		reg = i + 0xFC;
+		msg[1].buf = id + i;
+		if (i2c_transfer(i2c,msg,2) != 2)
+		{
+			return 0;
+		}
+	}
+
+	return *((u32 *) id) == *((u32 *) pciid);
+}
+
+static int mt352_init(struct i2c_adapter *i2c)
+{
+	/**
+	 *  all register write sequence have the register address of the
+	 *  first register in the first byte, thenafter the value to write
+	 *  into this and the following registers.
+	 *
+	 *
+	 *  We only write non-default settings, all default settings are
+	 *  restored by the full mt352_reset sequence.
+	 *
+	 *
+	 *  The optimal AGC target value and slope might vary from tuner
+	 *  type to tuner type, so check whether you need to adjust this one...
+	 **/
+
+	return(MT352_INIT(i2c));
+}
+
+static int mt352_sleep(struct i2c_adapter *i2c)
+{
+	static u8 mt352_softdown[] = { 0x89, 0x20, 0x08 };
+
+	mt352_write(mt352_softdown, sizeof(mt352_softdown));
+
+	return 0;
+}
+
+static int mt352_set_parameters(struct i2c_adapter *i2c,
+				struct dvb_frontend_parameters *param)
+{
+	unsigned char buf[14];
+	unsigned int tps = 0;
+	struct dvb_ofdm_parameters *op = &param->u.ofdm;
+	u32 freq = param->frequency / 1000000;
+	uint16_t tmp;
+
+	switch (op->code_rate_HP) {
+		case FEC_2_3:
+			tps |= (1 << CODERATE_HP_SHIFT);
+			break;
+		case FEC_3_4:
+			tps |= (2 << CODERATE_HP_SHIFT);
+			break;
+		case FEC_5_6:
+			tps |= (3 << CODERATE_HP_SHIFT);
+			break;
+		case FEC_7_8:
+			tps |= (4 << CODERATE_HP_SHIFT);
+			break;
+		case FEC_1_2:
+		case FEC_AUTO:
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	switch (op->code_rate_LP) {
+		case FEC_2_3:
+			tps |= (1 <<  CODERATE_LP_SHIFT);
+			break;
+		case FEC_3_4:
+			tps |= (2 <<  CODERATE_LP_SHIFT);
+			break;
+		case FEC_5_6:
+			tps |= (3 <<  CODERATE_LP_SHIFT);
+			break;
+		case FEC_7_8:
+			tps |= (4 <<  CODERATE_LP_SHIFT);
+			break;
+		case FEC_1_2:
+		case FEC_AUTO:
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	switch (op->constellation) {
+		case QPSK:
+			break;
+		case QAM_AUTO:
+		case QAM_16:
+			tps |= (1 << CONSTELLATION_SHIFT);
+			break;
+		case QAM_64:
+			tps |= (2 << CONSTELLATION_SHIFT);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	switch (op->transmission_mode) {
+		case TRANSMISSION_MODE_2K:
+		case TRANSMISSION_MODE_AUTO:
+			break;
+		case TRANSMISSION_MODE_8K:
+			tps |= (1 << TX_MODE_SHIFT);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	switch (op->guard_interval) {
+		case GUARD_INTERVAL_1_32:
+		case GUARD_INTERVAL_AUTO:
+			break;
+		case GUARD_INTERVAL_1_16:
+			tps |= (1 << GUARD_INTERVAL_SHIFT);
+			break;
+		case GUARD_INTERVAL_1_8:
+			tps |= (2 << GUARD_INTERVAL_SHIFT);
+			break;
+		case GUARD_INTERVAL_1_4:
+			tps |= (3 << GUARD_INTERVAL_SHIFT);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	switch (op->hierarchy_information) {
+		case HIERARCHY_AUTO:
+		case HIERARCHY_NONE:
+			break;
+		case HIERARCHY_1:
+			tps |= (1 << HIERARCHY_SHIFT);
+			break;
+		case HIERARCHY_2:
+			tps |= (2 << HIERARCHY_SHIFT);
+			break;
+		case HIERARCHY_4:
+			tps |= (3 << HIERARCHY_SHIFT);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+
+	buf[0] = TPS_GIVEN_1; /* TPS_GIVEN_1 and following registers */
+
+	buf[1] = msb(tps);      /* TPS_GIVEN_(1|0) */
+	buf[2] = lsb(tps);
+
+	buf[3] = 0x50;
+
+	/**
+	 *  these settings assume 20.48MHz f_ADC, for other tuners you might
+	 *  need other values. See p. 33 in the MT352 Design Manual.
+	 */
+	if (op->bandwidth == BANDWIDTH_8_MHZ) {
+		buf[4] = 0x72;  /* TRL_NOMINAL_RATE_(1|0) */
+		buf[5] = 0x49;
+	} else if (op->bandwidth == BANDWIDTH_7_MHZ) {
+		buf[4] = 0x64;
+		buf[5] = 0x00;
+	} else {		/* 6MHz */
+		buf[4] = 0x55;
+		buf[5] = 0xb7;
+	}
+
+	buf[6] = 0x31;  /* INPUT_FREQ_(1|0), 20.48MHz clock, 36.166667MHz IF */
+	buf[7] = 0x05;  /* see MT352 Design Manual page 32 for details */
+
+	buf[8] = I2C_TUNER_ADDR;
+
+	/**
+	 *  All the following settings are tuner module dependent,
+	 *  check the datasheet...
+	 */
+
+	/* here we assume 1/6MHz == 166.66kHz stepsize */
+	#define IF_FREQUENCYx6 217    /* 6 * 36.16666666667MHz */
+	tmp = ((param->frequency*3)/500000) + IF_FREQUENCYx6;
+
+	buf[9] = msb(tmp);      /* CHAN_START_(1|0) */
+	buf[10] = lsb(tmp);
+
+	buf[11] = MT352_CHARGE_PUMP(freq);
+	buf[12] = MT352_BAND_SELECT(freq);
+
+	buf[13] = 0x01; /* TUNER_GO!! */
+
+	mt352_write(buf, sizeof(buf));
+
+	return 0;
+}
+
+static u8 mt352_read_register(struct i2c_adapter *i2c, u8 reg)
+{
+	int ret;
+	u8 b0 [] = { reg };
+	u8 b1 [] = { 0 };
+	struct i2c_msg msg [] = { { .addr = I2C_MT352_ADDR,
+				    .flags =  READ_REG_FLAG,
+				    .buf = b0, .len = 1 },
+				  { .addr = I2C_MT352_ADDR,
+				    .flags = I2C_M_RD,
+				    .buf = b1, .len = 1 } };
+
+	ret = i2c_transfer(i2c, msg, 2);
+
+	if (ret != 2)
+		printk(KERN_WARNING
+		       "%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
+
+	return b1[0];
+}
+
+
+static int mt352_get_parameters(struct i2c_adapter *i2c,
+				struct dvb_frontend_parameters *param)
+{
+	u16 tps;
+	u16 div;
+	u8 trl;
+	struct dvb_ofdm_parameters *op = &param->u.ofdm;
+	static const u8 tps_fec_to_api[8] =
+	{
+		FEC_1_2,
+		FEC_2_3,
+		FEC_3_4,
+		FEC_5_6,
+		FEC_7_8,
+		FEC_AUTO,
+		FEC_AUTO,
+		FEC_AUTO
+	};
+
+	if ( (mt352_read_register(i2c,0x00) & 0xC0) != 0xC0 )
+	{
+		return -EINVAL;
+	}
+
+	/* Use TPS_RECEIVED-registers, not the TPS_CURRENT-registers because
+	 * the mt352 sometimes works with the wrong parameters
+	 */
+	tps = (mt352_read_register(i2c,	TPS_RECEIVED_1) << 8) | mt352_read_register(i2c, TPS_RECEIVED_0);
+	div = (mt352_read_register(i2c, CHAN_START_1) << 8) | mt352_read_register(i2c, CHAN_START_0);
+	trl = mt352_read_register(i2c, TRL_NOMINAL_RATE_1);
+
+	op->code_rate_HP = tps_fec_to_api[(tps >> 7) & 7];
+	op->code_rate_LP = tps_fec_to_api[(tps >> 4) & 7];
+
+	switch ( (tps >> 13) & 3)
+	{
+		case 0:
+			op->constellation = QPSK;
+			break;
+		case 1:
+			op->constellation = QAM_16;
+			break;
+		case 2:
+			op->constellation = QAM_64;
+			break;
+		default:
+			op->constellation = QAM_AUTO;
+			break;
+	}
+
+	op->transmission_mode = (tps & 0x01) ? TRANSMISSION_MODE_8K : TRANSMISSION_MODE_2K;
+
+	switch ( (tps >> 2) & 3)
+	{
+		case 0:
+			op->guard_interval = GUARD_INTERVAL_1_32;
+			break;
+		case 1:
+			op->guard_interval = GUARD_INTERVAL_1_16;
+			break;
+		case 2:
+			op->guard_interval = GUARD_INTERVAL_1_8;
+			break;
+		case 3:
+			op->guard_interval = GUARD_INTERVAL_1_4;
+			break;
+		default:
+			op->guard_interval = GUARD_INTERVAL_AUTO;
+			break;
+	}
+
+	switch ( (tps >> 10) & 7)
+	{
+		case 0:
+			op->hierarchy_information = HIERARCHY_NONE;
+			break;
+		case 1:
+			op->hierarchy_information = HIERARCHY_1;
+			break;
+		case 2:
+			op->hierarchy_information = HIERARCHY_2;
+			break;
+		case 3:
+			op->hierarchy_information = HIERARCHY_4;
+			break;
+		default:
+			op->hierarchy_information = HIERARCHY_AUTO;
+			break;
+	}
+
+	param->frequency = ( 500 * (div - IF_FREQUENCYx6) ) / 3 * 1000;
+
+	if (trl == 0x72)
+	{
+		op->bandwidth = BANDWIDTH_8_MHZ;
+	}
+	else if (trl == 0x64)
+	{
+		op->bandwidth = BANDWIDTH_7_MHZ;
+	}
+	else
+	{
+		op->bandwidth = BANDWIDTH_6_MHZ;
+	}
+
+
+	if (mt352_read_register(i2c, STATUS_2) & 0x02)
+		param->inversion = INVERSION_OFF;
+	else
+		param->inversion = INVERSION_ON;
+
+	return 0;
+}
+
+
+static int mt352_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
+{
+	struct mt352_state *state = fe->data;
+	struct i2c_adapter *i2c = state->i2c;
+	u8 r,snr;
+	fe_status_t *status;
+	u16 signal;
+	struct dvb_frontend_tune_settings *fe_tune_settings;
+
+	switch (cmd) {
+	case FE_GET_INFO:
+		memcpy (arg, &mt352_info, sizeof(struct dvb_frontend_info));
+		break;
+
+	case FE_READ_STATUS:
+		status = arg;
+		*status = 0;
+		r = mt352_read_register (i2c, STATUS_0);
+		if (r & (1 << 4))
+			*status = FE_HAS_CARRIER;
+		if (r & (1 << 1))
+			*status |= FE_HAS_VITERBI;
+		if (r & (1 << 5))
+			*status |= FE_HAS_LOCK;
+
+		r = mt352_read_register (i2c, STATUS_1);
+		if (r & (1 << 1))
+			*status |= FE_HAS_SYNC;
+
+		r = mt352_read_register (i2c, STATUS_3);
+		if (r & (1 << 6))
+			*status |= FE_HAS_SIGNAL;
+
+		break;
+
+	case FE_READ_BER:
+		*((u32 *) arg) = (mt352_read_register (i2c, RS_ERR_CNT_2) << 16) |
+		       (mt352_read_register (i2c, RS_ERR_CNT_1) << 8) |
+		       (mt352_read_register (i2c, RS_ERR_CNT_0));
+		break;
+
+	case FE_READ_SIGNAL_STRENGTH:
+		signal = (mt352_read_register (i2c, AGC_GAIN_3) << 8) |
+			     (mt352_read_register (i2c, AGC_GAIN_2));
+		*((u16*) arg) = ~signal;
+		break;
+
+	case FE_READ_SNR:
+		snr = mt352_read_register (i2c, SNR);
+		*((u16*) arg) = (snr << 8) | snr;
+		break;
+
+	case FE_READ_UNCORRECTED_BLOCKS:
+		*(u32*) arg = (mt352_read_register (i2c,  RS_UBC_1) << 8) |
+			      (mt352_read_register (i2c,  RS_UBC_0));
+		break;
+
+	case FE_SET_FRONTEND:
+		return mt352_set_parameters (i2c,
+				 (struct dvb_frontend_parameters *) arg);
+
+	case FE_GET_FRONTEND:
+		return mt352_get_parameters (i2c,
+				 (struct dvb_frontend_parameters *) arg);
+
+	case FE_GET_TUNE_SETTINGS:
+		fe_tune_settings = (struct dvb_frontend_tune_settings *) arg;
+		fe_tune_settings->min_delay_ms = 800;
+		fe_tune_settings->step_size = 0;
+		fe_tune_settings->max_drift = 0;
+		break;
+
+	case FE_SLEEP:
+		return mt352_sleep(i2c);
+
+	case FE_INIT:
+		return mt352_init(i2c);
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static struct i2c_client client_template;
+
+static int mt352_attach_adapter(struct i2c_adapter *i2c)
+{
+	struct mt352_state *state;
+	struct i2c_client *client;
+	static u8 mt352_reset_attach [] = { 0x50, 0xC0 };
+	int ret;
+
+	dprintk("Trying to attach to adapter 0x%x:%s.\n",
+		i2c->id, i2c->name);
+
+	/* set the proper MT352 frequency range */
+	mt352_info.frequency_min =  FE_FREQ_MIN;
+	mt352_info.frequency_max =  FE_FREQ_MAX;
+	mt352_info.frequency_stepsize =  FE_FREQ_STEPSIZE;
+
+	if ( !(state = kmalloc(sizeof(struct mt352_state), GFP_KERNEL)) )
+		return -ENOMEM;
+
+	memset(state, 0, sizeof(struct mt352_state));
+	state->i2c = i2c;
+
+	if (mt352_detect_avermedia_771(i2c)) {
+		card_type = CARD_AVDVBT771;
+	} else if (force_card < 0) {
+		dprintk("Avermedia 771 not detected, maybe you should try the "
+			"'force_card' module parameter?.\n");
+		kfree(state);
+		return -ENODEV;
+	}
+
+	if (force_card > 0) {
+		if (card_type >= 0 && force_card != card_type)
+			printk(KERN_WARNING "dvbfe_mt352: Warning, overriding"
+					    " detected card.\n");
+		card_type = force_card;
+	}
+
+	if (mt352_read_register(i2c, CHIP_ID) != ID_MT352) {
+		kfree(state);
+		return -ENODEV;
+	}
+
+	if (card_type == CARD_AVDVBT771)
+		printk(KERN_INFO FRONTEND_NAME ": Setup for Avermedia 771.\n");
+	else if (card_type == CARD_TUA6034)
+		printk(KERN_INFO FRONTEND_NAME ": Setup for TUA6034.\n");
+	else if (card_type == CARD_TDTC9251DH01C)
+		printk(KERN_INFO FRONTEND_NAME ": Setup for TDTC9251DH01C.\n");
+
+	/* Do a "hard" reset */
+	mt352_write(mt352_reset_attach, sizeof(mt352_reset_attach));
+
+	if ( !(client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)) ) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = i2c;
+	client->addr = 0; // XXX
+	i2c_set_clientdata(client, state);
+
+	if ((ret = i2c_attach_client(client))) {
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	BUG_ON(!state->dvb);
+
+	if ((ret = dvb_register_frontend(mt352_ioctl, state->dvb, state,
+					     &mt352_info, THIS_MODULE))) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mt352_detach_client(struct i2c_client *client)
+{
+	struct mt352_state *state = i2c_get_clientdata(client);
+
+	dvb_unregister_frontend (mt352_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
+
+static int mt352_command (struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	struct mt352_state *state = i2c_get_clientdata(client);
+
+	switch (cmd) {
+	case FE_REGISTER:
+		state->dvb = arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= FRONTEND_NAME,
+	.id 		= I2C_DRIVERID_DVBFE_MT352,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = mt352_attach_adapter,
+	.detach_client 	= mt352_detach_client,
+	.command 	= mt352_command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
+
+static int __init mt352_module_init(void)
+{
+	return i2c_add_driver(&driver);
+}
+
+static void __exit mt352_module_exit(void)
+{
+	if (i2c_del_driver(&driver))
+		printk(KERN_ERR "mt352: driver deregistration failed.\n");
+}
+
+module_init(mt352_module_init);
+module_exit(mt352_module_exit);
+
+MODULE_DESCRIPTION("DVB-T MT352 Zarlink");
+MODULE_AUTHOR("Holger Waechtler, Daniel Mack, Antonio Mancuso");
+MODULE_LICENSE("GPL");
+
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/mt352.h linux/drivers/media/dvb/frontends/mt352.h
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/mt352.h	2004-09-17 14:56:38.833594686 +0200
+++ linux/drivers/media/dvb/frontends/mt352.h	2004-09-17 14:56:38.834594499 +0200
@@ -0,0 +1,177 @@
+/*
+ *  Driver for Zarlink DVB-T MT352 demodulator
+ *
+ *  Written by Holger Waechtler <holger@qanu.de>
+ *	 and Daniel Mack <daniel@qanu.de>
+ *
+ *  Support for Samsung TDTC9251DH01C(M) tuner
+ *
+ *  Copyright (C) 2004 Antonio Mancuso <antonio.mancuso@digitaltelevision.it>
+ *                     Amauri  Celani  <acelani@essegi.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
+ */
+
+#ifndef _MT352_
+#define _MT352_
+
+#define I2C_MT352_ADDR  0x0f
+#define I2C_TUNER_ADDR  0xc2
+#define ID_MT352        0x13
+
+#define CARD_AVDVBT771	    0x00
+#define CARD_TUA6034	    0x01
+#define CARD_TDTC9251DH01C  0x02
+
+#define msb(x) (((x) >> 8) & 0xff)
+#define lsb(x) ((x) & 0xff)
+
+enum mt352_reg_addr {
+	STATUS_0           = 0x00,
+	STATUS_1           = 0x01,
+	STATUS_2           = 0x02,
+	STATUS_3           = 0x03,
+	STATUS_4           = 0x04,
+	INTERRUPT_0        = 0x05,
+	INTERRUPT_1        = 0x06,
+	INTERRUPT_2        = 0x07,
+	INTERRUPT_3        = 0x08,
+	SNR                = 0x09,
+	VIT_ERR_CNT_2      = 0x0A,
+	VIT_ERR_CNT_1      = 0x0B,
+	VIT_ERR_CNT_0      = 0x0C,
+	RS_ERR_CNT_2       = 0x0D,
+	RS_ERR_CNT_1       = 0x0E,
+	RS_ERR_CNT_0       = 0x0F,
+	RS_UBC_1           = 0x10,
+	RS_UBC_0           = 0x11,
+	AGC_GAIN_3         = 0x12,
+	AGC_GAIN_2         = 0x13,
+	AGC_GAIN_1         = 0x14,
+	AGC_GAIN_0         = 0x15,
+	FREQ_OFFSET_2      = 0x17,
+	FREQ_OFFSET_1      = 0x18,
+	FREQ_OFFSET_0      = 0x19,
+	TIMING_OFFSET_1    = 0x1A,
+	TIMING_OFFSET_0    = 0x1B,
+	CHAN_FREQ_1        = 0x1C,
+	CHAN_FREQ_0        = 0x1D,
+	TPS_RECEIVED_1     = 0x1E,
+	TPS_RECEIVED_0     = 0x1F,
+	TPS_CURRENT_1      = 0x20,
+	TPS_CURRENT_0      = 0x21,
+	TPS_CELL_ID_1      = 0x22,
+	TPS_CELL_ID_0      = 0x23,
+	TPS_MISC_DATA_2    = 0x24,
+	TPS_MISC_DATA_1    = 0x25,
+	TPS_MISC_DATA_0    = 0x26,
+	RESET              = 0x50,
+	TPS_GIVEN_1        = 0x51,
+	TPS_GIVEN_0        = 0x52,
+	ACQ_CTL            = 0x53,
+	TRL_NOMINAL_RATE_1 = 0x54,
+	TRL_NOMINAL_RATE_0 = 0x55,
+	INPUT_FREQ_1       = 0x56,
+	INPUT_FREQ_0       = 0x57,
+	TUNER_ADDR         = 0x58,
+	CHAN_START_1       = 0x59,
+	CHAN_START_0       = 0x5A,
+	CONT_1             = 0x5B,
+	CONT_0             = 0x5C,
+	TUNER_GO           = 0x5D,
+	STATUS_EN_0        = 0x5F,
+	STATUS_EN_1        = 0x60,
+	INTERRUPT_EN_0     = 0x61,
+	INTERRUPT_EN_1     = 0x62,
+	INTERRUPT_EN_2     = 0x63,
+	INTERRUPT_EN_3     = 0x64,
+	AGC_TARGET         = 0x67,
+	AGC_CTL            = 0x68,
+	CAPT_RANGE         = 0x75,
+	SNR_SELECT_1       = 0x79,
+	SNR_SELECT_0       = 0x7A,
+	RS_ERR_PER_1       = 0x7C,
+	RS_ERR_PER_0       = 0x7D,
+	CHIP_ID            = 0x7F,
+	CHAN_STOP_1        = 0x80,
+	CHAN_STOP_0        = 0x81,
+	CHAN_STEP_1        = 0x82,
+	CHAN_STEP_0        = 0x83,
+	FEC_LOCK_TIME      = 0x85,
+	OFDM_LOCK_TIME     = 0x86,
+	ACQ_DELAY          = 0x87,
+	SCAN_CTL           = 0x88,
+	CLOCK_CTL          = 0x89,
+	CONFIG             = 0x8A,
+	MCLK_RATIO         = 0x8B,
+	GPP_CTL            = 0x8C,
+	ADC_CTL_1          = 0x8E,
+	ADC_CTL_0          = 0x8F
+};
+
+struct _tuner_info {
+	__u32 fe_frequency_min;
+#define FE_FREQ_MIN tuner_info[card_type].fe_frequency_min
+
+	__u32 fe_frequency_max;
+#define FE_FREQ_MAX tuner_info[card_type].fe_frequency_max
+
+	__u32 fe_frequency_stepsize; //verificare se u32 e' corretto
+#define FE_FREQ_STEPSIZE  tuner_info[card_type].fe_frequency_stepsize
+
+	__u32 coderate_hp_shift; //verificare se u32 giusto
+#define CODERATE_HP_SHIFT tuner_info[card_type].coderate_hp_shift
+
+	__u32 coderate_lp_shift;
+#define CODERATE_LP_SHIFT tuner_info[card_type].coderate_lp_shift
+
+	int constellation_shift;
+#define CONSTELLATION_SHIFT tuner_info[card_type].constellation_shift
+
+	int tx_mode_shift;
+#define TX_MODE_SHIFT tuner_info[card_type].tx_mode_shift
+
+	int guard_interval_shift;
+#define GUARD_INTERVAL_SHIFT tuner_info[card_type].guard_interval_shift
+
+	int hierarchy_shift;
+#define HIERARCHY_SHIFT tuner_info[card_type].hierarchy_shift
+
+	int read_reg_flag;
+#define READ_REG_FLAG tuner_info[card_type].read_reg_flag
+
+	int (* mt352_init) (struct i2c_adapter *i2c);
+#define MT352_INIT tuner_info[card_type].mt352_init
+
+	unsigned char (* mt352_charge_pump) (u32 freq);
+#define MT352_CHARGE_PUMP tuner_info[card_type].mt352_charge_pump
+
+	unsigned char (* mt352_band_select) (u32 freq);
+#define MT352_BAND_SELECT tuner_info[card_type].mt352_band_select
+};
+
+static int mt352_init_TUA6034(struct i2c_adapter *i2c);
+static int mt352_init_AVERMEDIA771(struct i2c_adapter *i2c);
+static int mt352_init_TDTC9251DH01C(struct i2c_adapter *i2c);
+static unsigned char mt352_cp_TUA6034(u32 freq);
+static unsigned char mt352_cp_AVERMEDIA771(u32 freq);
+static unsigned char mt352_cp_TDTC9251DH01C(u32 freq);
+static unsigned char mt352_bs_TUA6034(u32 freq);
+static unsigned char mt352_bs_AVERMEDIA771(u32 freq);
+static unsigned char mt352_bs_TDTC9251DH01C(u32 freq);
+static int mt352_detect_avermedia_771(struct i2c_adapter *i2c);
+
+#endif                          /* _MT352_ */
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/nxt6000.c linux/drivers/media/dvb/frontends/nxt6000.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/nxt6000.c	2004-09-14 10:36:56.000000000 +0200
+++ linux/drivers/media/dvb/frontends/nxt6000.c	2004-09-17 14:56:38.838593749 +0200
@@ -1,9 +1,8 @@
-/* 
-
+/*
 	NxtWave Communications - NXT6000 demodulator driver
-	
+
 	This driver currently supports:
-	
+
 	Alps TDME7 (Tuner: MITEL SP5659)
 	Alps TDED4 (Tuner: TI ALP510, external Nxt6000)
 	Comtech DVBT-6k07 (PLL IC: SP5730)
@@ -24,8 +23,7 @@
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-*/    
+*/
 
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -36,30 +34,29 @@
 #include "dvb_frontend.h"
 #include "nxt6000.h"
 
-static int debug = 0;
-
 MODULE_DESCRIPTION("NxtWave NXT6000 DVB demodulator driver");
 MODULE_AUTHOR("Florian Schirmer");
 MODULE_LICENSE("GPL");
+
+static int debug = 0;
 MODULE_PARM(debug, "i");
 
 static struct dvb_frontend_info nxt6000_info = {
-
 	.name = "NxtWave NXT6000",
 	.type = FE_OFDM,
 	.frequency_min = 0,
 	.frequency_max = 863250000,
 	.frequency_stepsize = 62500,
-	/*.frequency_tolerance = */	/* FIXME: 12% of SR */
-	.symbol_rate_min = 0,		/* FIXME */
+	/*.frequency_tolerance = *//* FIXME: 12% of SR */
+	.symbol_rate_min = 0,	/* FIXME */
 	.symbol_rate_max = 9360000,	/* FIXME */
 	.symbol_rate_tolerance = 4000,
 	.notifier_delay = 0,
-	.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 | 
-                FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 | 
-                FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO | 
-                FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO | 
-                FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO | 
+	.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+                FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+                FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
+                FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+                FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
                 FE_CAN_HIERARCHY_AUTO,
 };
 
@@ -68,103 +65,90 @@ struct nxt6000_config {
 	u8 tuner_addr;
 	u8 tuner_type;
 	u8 clock_inversion;
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
 };
 
 #define TUNER_TYPE_ALP510	0
 #define TUNER_TYPE_SP5659	1
 #define TUNER_TYPE_SP5730	2
 
-#define FE2NXT(fe) ((struct nxt6000_config *)((fe)->data))
+// #define FE2NXT(fe) ((struct nxt6000_config *)((fe)->data))
 #define FREQ2DIV(freq) ((freq + 36166667) / 166667)
 
 #define dprintk if (debug) printk
 
-static int nxt6000_write(struct dvb_i2c_bus *i2c, u8 addr, u8 reg, u8 data)
+static int nxt6000_write(struct i2c_adapter *i2c, u8 addr, u8 reg, u8 data)
 {
-
-	u8 buf[] = {reg, data};
-	struct i2c_msg msg = {.addr = addr >> 1, .flags = 0, .buf = buf, .len = 2};
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = {.addr = addr >> 1,.flags = 0,.buf = buf,.len = 2 };
 	int ret;
-	
-	if ((ret = i2c->xfer(i2c, &msg, 1)) != 1)
+
+	if ((ret = i2c_transfer(i2c, &msg, 1)) != 1)
 		dprintk("nxt6000: nxt6000_write error (.addr = 0x%02X, reg: 0x%02X, data: 0x%02X, ret: %d)\n", addr, reg, data, ret);
 
 	return (ret != 1) ? -EFAULT : 0;
-	
 }
 
-static u8 nxt6000_writereg(struct dvb_frontend *fe, u8 reg, u8 data)
+static u8 nxt6000_writereg(struct nxt6000_config *nxt, u8 reg, u8 data)
 {
-
-	struct nxt6000_config *nxt = FE2NXT(fe);
-
-	return nxt6000_write(fe->i2c, nxt->demod_addr, reg, data);
-
+	return nxt6000_write(nxt->i2c, nxt->demod_addr, reg, data);
 }
 
-static u8 nxt6000_read(struct dvb_i2c_bus *i2c, u8 addr, u8 reg)
+static u8 nxt6000_read(struct i2c_adapter *i2c, u8 addr, u8 reg)
 {
-
 	int ret;
-	u8 b0[] = {reg};
-	u8 b1[] = {0};
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
 	struct i2c_msg msgs[] = {
 		{.addr = addr >> 1,.flags = 0,.buf = b0,.len = 1},
 		{.addr = addr >> 1,.flags = I2C_M_RD,.buf = b1,.len = 1}
 	};
 
-	ret = i2c->xfer(i2c, msgs, 2);
-	
+	ret = i2c_transfer(i2c, msgs, 2);
+
 	if (ret != 2)
 		dprintk("nxt6000: nxt6000_read error (.addr = 0x%02X, reg: 0x%02X, ret: %d)\n", addr, reg, ret);
-	
-	return b1[0];
 
+	return b1[0];
 }
 
-static u8 nxt6000_readreg(struct dvb_frontend *fe, u8 reg)
+static u8 nxt6000_readreg(struct nxt6000_config *nxt, u8 reg)
 {
-
-	struct nxt6000_config *nxt = FE2NXT(fe);
-
-	return nxt6000_read(fe->i2c, nxt->demod_addr, reg);
+	return nxt6000_read(nxt->i2c, nxt->demod_addr, reg);
 }
 
-static int pll_test(struct dvb_i2c_bus *i2c, u8 demod_addr, u8 tuner_addr)
+static int pll_test(struct i2c_adapter *i2c, u8 demod_addr, u8 tuner_addr)
 {
 	u8 buf [1];
 	struct i2c_msg msg = {.addr = tuner_addr >> 1,.flags = I2C_M_RD,.buf = buf,.len = 1 };
 	int ret;
 
 	nxt6000_write(i2c, demod_addr, ENABLE_TUNER_IIC, 0x01);	/* open i2c bus switch */
-	ret = i2c->xfer(i2c, &msg, 1);
+	ret = i2c_transfer(i2c, &msg, 1);
 	nxt6000_write(i2c, demod_addr, ENABLE_TUNER_IIC, 0x00);	/* close i2c bus switch */
 
 	return (ret != 1) ? -EFAULT : 0;
 }
 
-static int pll_write(struct dvb_i2c_bus *i2c, u8 demod_addr, u8 tuner_addr, u8 *buf, u8 len)
+static int pll_write(struct i2c_adapter *i2c, u8 demod_addr, u8 tuner_addr, u8 * buf, u8 len)
 {
-
-	struct i2c_msg msg = {.addr = tuner_addr >> 1, .flags = 0, .buf = buf, .len = len};
+	struct i2c_msg msg = {.addr = tuner_addr >> 1,.flags = 0,.buf = buf,.len = len };
 	int ret;
-				
-	nxt6000_write(i2c, demod_addr, ENABLE_TUNER_IIC, 0x01);		/* open i2c bus switch */
-	ret = i2c->xfer(i2c, &msg, 1);
-	nxt6000_write(i2c, demod_addr, ENABLE_TUNER_IIC, 0x00);		/* close i2c bus switch */
-										
+
+	nxt6000_write(i2c, demod_addr, ENABLE_TUNER_IIC, 0x01);	/* open i2c bus switch */
+	ret = i2c_transfer(i2c, &msg, 1);
+	nxt6000_write(i2c, demod_addr, ENABLE_TUNER_IIC, 0x00);	/* close i2c bus switch */
+
 	if (ret != 1)
 		dprintk("nxt6000: pll_write error %d\n", ret);
-																
-	return (ret != 1) ? -EFAULT : 0;
 
+	return (ret != 1) ? -EFAULT : 0;
 }
 
-static int sp5659_set_tv_freq(struct dvb_frontend *fe, u32 freq)
+static int sp5659_set_tv_freq(struct nxt6000_config *nxt, u32 freq)
 {
-
 	u8 buf[4];
-	struct nxt6000_config *nxt = FE2NXT(fe);
 
 	buf[0] = (FREQ2DIV(freq) >> 8) & 0x7F;
 	buf[1] = FREQ2DIV(freq) & 0xFF;
@@ -179,15 +163,12 @@ static int sp5659_set_tv_freq(struct dvb
 	else
 		return -EINVAL;
 
-	return pll_write(fe->i2c, nxt->demod_addr, nxt->tuner_addr, buf, 4);
-	
+	return pll_write(nxt->i2c, nxt->demod_addr, nxt->tuner_addr, buf, 4);
 }
 
-static int alp510_set_tv_freq(struct dvb_frontend *fe, u32 freq)
+static int alp510_set_tv_freq(struct nxt6000_config *nxt, u32 freq)
 {
-
 	u8 buf[4];
-	struct nxt6000_config *nxt = FE2NXT(fe);
 
 	buf[0] = (FREQ2DIV(freq) >> 8) & 0x7F;
 	buf[1] = FREQ2DIV(freq) & 0xFF;
@@ -217,15 +198,12 @@ static int alp510_set_tv_freq(struct dvb
 		return -EINVAL;
 #endif
 
-	return pll_write(fe->i2c, nxt->demod_addr, nxt->tuner_addr, buf, 4);
-	
+	return pll_write(nxt->i2c, nxt->demod_addr, nxt->tuner_addr, buf, 4);
 }
 
-static int sp5730_set_tv_freq(struct dvb_frontend *fe, u32 freq)
+static int sp5730_set_tv_freq(struct nxt6000_config *nxt, u32 freq)
 {
-
 	u8 buf[4];
-	struct nxt6000_config *nxt = FE2NXT(fe);
 
 	buf[0] = (FREQ2DIV(freq) >> 8) & 0x7F;
 	buf[1] = FREQ2DIV(freq) & 0xFF;
@@ -250,149 +228,115 @@ static int sp5730_set_tv_freq(struct dvb
 	else
 		return -EINVAL;
 
-	return pll_write(fe->i2c, nxt->demod_addr, nxt->tuner_addr, buf, 4);
-	
+	return pll_write(nxt->i2c, nxt->demod_addr, nxt->tuner_addr, buf, 4);
 }
 
-static void nxt6000_reset(struct dvb_frontend *fe)
+static void nxt6000_reset(struct nxt6000_config *fe)
 {
-
 	u8 val;
 
 	val = nxt6000_readreg(fe, OFDM_COR_CTL);
-	
+
 	nxt6000_writereg(fe, OFDM_COR_CTL, val & ~COREACT);
 	nxt6000_writereg(fe, OFDM_COR_CTL, val | COREACT);
-	
 }
 
-static int nxt6000_set_bandwidth(struct dvb_frontend *fe, fe_bandwidth_t bandwidth)
+static int nxt6000_set_bandwidth(struct nxt6000_config *fe, fe_bandwidth_t bandwidth)
 {
-
 	u16 nominal_rate;
 	int result;
 
-	switch(bandwidth) {
-	
-		case BANDWIDTH_6_MHZ:
-		
-			nominal_rate = 0x55B7;
-			
-			break;
-
-		case BANDWIDTH_7_MHZ:
+	switch (bandwidth) {
 
-			nominal_rate = 0x6400;
-			
-			break;
+	case BANDWIDTH_6_MHZ:
+		nominal_rate = 0x55B7;
+		break;
 
-		case BANDWIDTH_8_MHZ:
+	case BANDWIDTH_7_MHZ:
+		nominal_rate = 0x6400;
+		break;
 
-			nominal_rate = 0x7249;
-			
-			break;
+	case BANDWIDTH_8_MHZ:
+		nominal_rate = 0x7249;
+		break;
 
-		default:
-			
-			return -EINVAL;
-			
+	default:
+		return -EINVAL;
 	}
 
 	if ((result = nxt6000_writereg(fe, OFDM_TRL_NOMINALRATE_1, nominal_rate & 0xFF)) < 0)
 		return result;
-		
+
 	return nxt6000_writereg(fe, OFDM_TRL_NOMINALRATE_2, (nominal_rate >> 8) & 0xFF);
-		
 }
 
-static int nxt6000_set_guard_interval(struct dvb_frontend *fe, fe_guard_interval_t guard_interval)
+static int nxt6000_set_guard_interval(struct nxt6000_config *fe, fe_guard_interval_t guard_interval)
 {
+	switch (guard_interval) {
 
-	switch(guard_interval) {
-	
-		case GUARD_INTERVAL_1_32:
-
-			return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, 0x00 | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x03));
-
-		case GUARD_INTERVAL_1_16:
+	case GUARD_INTERVAL_1_32:
+		return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, 0x00 | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x03));
 
-			return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, 0x01 | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x03));
+	case GUARD_INTERVAL_1_16:
+		return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, 0x01 | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x03));
 
-		case GUARD_INTERVAL_AUTO:
-		case GUARD_INTERVAL_1_8:
+	case GUARD_INTERVAL_AUTO:
+	case GUARD_INTERVAL_1_8:
+		return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, 0x02 | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x03));
 
-			return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, 0x02 | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x03));
-
-		case GUARD_INTERVAL_1_4:
-
-			return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, 0x03 | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x03));
-			
-		default:
-		
-			return -EINVAL;
+	case GUARD_INTERVAL_1_4:
+		return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, 0x03 | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x03));
 
+	default:
+		return -EINVAL;
 	}
-
 }
 
-static int nxt6000_set_inversion(struct dvb_frontend *fe, fe_spectral_inversion_t inversion)
+static int nxt6000_set_inversion(struct nxt6000_config *fe, fe_spectral_inversion_t inversion)
 {
+	switch (inversion) {
 
-	switch(inversion) {
-	
-		case INVERSION_OFF:
-		
-			return nxt6000_writereg(fe, OFDM_ITB_CTL, 0x00);
-			
-		case INVERSION_ON:
-		
-			return nxt6000_writereg(fe, OFDM_ITB_CTL, ITBINV);
+	case INVERSION_OFF:
+		return nxt6000_writereg(fe, OFDM_ITB_CTL, 0x00);
 
-		default:
-		
-			return -EINVAL;	
-	
-	}
+	case INVERSION_ON:
+		return nxt6000_writereg(fe, OFDM_ITB_CTL, ITBINV);
+
+	default:
+		return -EINVAL;
 
+	}
 }
 
-static int nxt6000_set_transmission_mode(struct dvb_frontend *fe, fe_transmit_mode_t transmission_mode)
+static int nxt6000_set_transmission_mode(struct nxt6000_config *fe, fe_transmit_mode_t transmission_mode)
 {
-
 	int result;
 
-	switch(transmission_mode) {
+	switch (transmission_mode) {
 
-		case TRANSMISSION_MODE_2K:	
+	case TRANSMISSION_MODE_2K:
+		if ((result = nxt6000_writereg(fe, EN_DMD_RACQ, 0x00 | (nxt6000_readreg(fe, EN_DMD_RACQ) & ~0x03))) < 0)
+			return result;
 
-			if ((result = nxt6000_writereg(fe, EN_DMD_RACQ, 0x00 | (nxt6000_readreg(fe, EN_DMD_RACQ) & ~0x03))) < 0)
-				return result;
-				
-			return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, (0x00 << 2) | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x04));
+		return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, (0x00 << 2) | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x04));
 
-		case TRANSMISSION_MODE_8K:	
-		case TRANSMISSION_MODE_AUTO:	
+	case TRANSMISSION_MODE_8K:
+	case TRANSMISSION_MODE_AUTO:
+		if ((result = nxt6000_writereg(fe, EN_DMD_RACQ, 0x02 | (nxt6000_readreg(fe, EN_DMD_RACQ) & ~0x03))) < 0)
+			return result;
 
-			if ((result = nxt6000_writereg(fe, EN_DMD_RACQ, 0x02 | (nxt6000_readreg(fe, EN_DMD_RACQ) & ~0x03))) < 0)
-				return result;
+		return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, (0x01 << 2) | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x04));
 
-			return nxt6000_writereg(fe, OFDM_COR_MODEGUARD, (0x01 << 2) | (nxt6000_readreg(fe, OFDM_COR_MODEGUARD) & ~0x04));
+	default:
+		return -EINVAL;
 
-		default:
-			
-			return -EINVAL;
-	
 	}
-
 }
 
-static void nxt6000_setup(struct dvb_frontend *fe)
+static void nxt6000_setup(struct nxt6000_config *fe)
 {
-
-	struct nxt6000_config *nxt = FE2NXT(fe);
-
 	nxt6000_writereg(fe, RS_COR_SYNC_PARAM, SYNC_PARAM);
-	nxt6000_writereg(fe, BER_CTRL, /*(1 << 2) |*/ (0x01 << 1) | 0x01);
+	nxt6000_writereg(fe, BER_CTRL, /*(1 << 2) | */ (0x01 << 1) | 0x01);
 	nxt6000_writereg(fe, VIT_COR_CTL, VIT_COR_RESYNC);
 	nxt6000_writereg(fe, OFDM_COR_CTL, (0x01 << 5) | (nxt6000_readreg(fe, OFDM_COR_CTL) & 0x0F));
 	nxt6000_writereg(fe, OFDM_COR_MODEGUARD, FORCEMODE8K | 0x02);
@@ -408,17 +352,16 @@ static void nxt6000_setup(struct dvb_fro
 	nxt6000_writereg(fe, ANALOG_CONTROL_0, 1 << 5);
 	nxt6000_writereg(fe, EN_DMD_RACQ, (1 << 7) | (3 << 4) | 2);
 	nxt6000_writereg(fe, DIAG_CONFIG, TB_SET);
-	
-	if (nxt->clock_inversion)
+
+	if (fe->clock_inversion)
 		nxt6000_writereg(fe, SUB_DIAG_MODE_SEL, CLKINVERSION);
 	else
 		nxt6000_writereg(fe, SUB_DIAG_MODE_SEL, 0);
-		
-	nxt6000_writereg(fe, TS_FORMAT, 0);
 
+	nxt6000_writereg(fe, TS_FORMAT, 0);
 }
 
-static void nxt6000_dump_status(struct dvb_frontend *fe)
+static void nxt6000_dump_status(struct nxt6000_config *fe)
 {
 	u8 val;
 
@@ -437,7 +380,7 @@ static void nxt6000_dump_status(struct d
 	printk("NXT6000 status:");
 
 	val = nxt6000_readreg(fe, RS_COR_STAT);
-	
+
 	printk(" DATA DESCR LOCK: %d,", val & 0x01);
 	printk(" DATA SYNC LOCK: %d,", (val >> 1) & 0x01);
 
@@ -445,91 +388,73 @@ static void nxt6000_dump_status(struct d
 
 	printk(" VITERBI LOCK: %d,", (val >> 7) & 0x01);
 
-	switch((val >> 4) & 0x07) {
-	
-		case 0x00: 
-		
-			printk(" VITERBI CODERATE: 1/2,");
-			
-			break;
-	
-		case 0x01: 
-		
-			printk(" VITERBI CODERATE: 2/3,");
-			
-			break;
-	
-		case 0x02: 
-		
-			printk(" VITERBI CODERATE: 3/4,");
-			
-			break;
-	
-		case 0x03: 
-			printk(" VITERBI CODERATE: 5/6,");
+	switch ((val >> 4) & 0x07) {
+
+	case 0x00:
+		printk(" VITERBI CODERATE: 1/2,");
 		break;
 
-		case 0x04: 
-			printk(" VITERBI CODERATE: 7/8,");
-			break;
+	case 0x01:
+		printk(" VITERBI CODERATE: 2/3,");
+		break;
+
+	case 0x02:
+		printk(" VITERBI CODERATE: 3/4,");
+		break;
+
+	case 0x03:
+		printk(" VITERBI CODERATE: 5/6,");
+		break;
+
+	case 0x04:
+		printk(" VITERBI CODERATE: 7/8,");
+		break;
+
+	default:
+		printk(" VITERBI CODERATE: Reserved,");
 
-		default: 
-		
-			printk(" VITERBI CODERATE: Reserved,");
-			
 	}
 
 	val = nxt6000_readreg(fe, OFDM_COR_STAT);
-	
+
 	printk(" CHCTrack: %d,", (val >> 7) & 0x01);
 	printk(" TPSLock: %d,", (val >> 6) & 0x01);
 	printk(" SYRLock: %d,", (val >> 5) & 0x01);
 	printk(" AGCLock: %d,", (val >> 4) & 0x01);
 
-	switch(val & 0x0F) {
-	
-		case 0x00:
-		
-			printk(" CoreState: IDLE,");
-			
-			break;
-	
-		case 0x02:
-		
-			printk(" CoreState: WAIT_AGC,");
-			
-			break;
-	
-		case 0x03:
-		
-			printk(" CoreState: WAIT_SYR,");
-			
-			break;
-	
-		case 0x04:
-			printk(" CoreState: WAIT_PPM,");
+	switch (val & 0x0F) {
+
+	case 0x00:
+		printk(" CoreState: IDLE,");
 		break;
 
-		case 0x01:
-			printk(" CoreState: WAIT_TRL,");
-			break;
+	case 0x02:
+		printk(" CoreState: WAIT_AGC,");
+		break;
 
-		case 0x05:
-		
-			printk(" CoreState: WAIT_TPS,");
-			
-			break;
+	case 0x03:
+		printk(" CoreState: WAIT_SYR,");
+		break;
 
-		case 0x06:
-		
-			printk(" CoreState: MONITOR_TPS,");
-			
-			break;
+	case 0x04:
+		printk(" CoreState: WAIT_PPM,");
+		break;
+
+	case 0x01:
+		printk(" CoreState: WAIT_TRL,");
+		break;
+
+	case 0x05:
+		printk(" CoreState: WAIT_TPS,");
+		break;
+
+	case 0x06:
+		printk(" CoreState: MONITOR_TPS,");
+		break;
+
+	default:
+		printk(" CoreState: Reserved,");
 
-		default: 
-		
-			printk(" CoreState: Reserved,");
-			
 	}
 
 	val = nxt6000_readreg(fe, OFDM_SYR_STAT);
@@ -537,166 +462,132 @@ static void nxt6000_dump_status(struct d
 	printk(" SYRLock: %d,", (val >> 4) & 0x01);
 	printk(" SYRMode: %s,", (val >> 2) & 0x01 ? "8K" : "2K");
 
-	switch((val >> 4) & 0x03) {
-	
-		case 0x00: 
-		
-			printk(" SYRGuard: 1/32,");
-			
-			break;
-	
-		case 0x01: 
-		
-			printk(" SYRGuard: 1/16,");
-			
-			break;
-	
-		case 0x02: 
-		
-			printk(" SYRGuard: 1/8,");
-			
-			break;
-	
-		case 0x03: 
-		
-			printk(" SYRGuard: 1/4,");
-			
-			break;
-			
+	switch ((val >> 4) & 0x03) {
+
+	case 0x00:
+		printk(" SYRGuard: 1/32,");
+		break;
+
+	case 0x01:
+		printk(" SYRGuard: 1/16,");
+		break;
+
+	case 0x02:
+		printk(" SYRGuard: 1/8,");
+		break;
+
+	case 0x03:
+		printk(" SYRGuard: 1/4,");
+		break;
 	}
 
 	val = nxt6000_readreg(fe, OFDM_TPS_RCVD_3);
-	
-	switch((val >> 4) & 0x07) {
-	
-		case 0x00: 
-		
-			printk(" TPSLP: 1/2,");
-			
-			break;
-	
-		case 0x01: 
-		
-			printk(" TPSLP: 2/3,");
-			
-			break;
-	
-		case 0x02: 
-		
-			printk(" TPSLP: 3/4,");
-			
-			break;
-	
-		case 0x03: 
-			printk(" TPSLP: 5/6,");
+
+	switch ((val >> 4) & 0x07) {
+
+	case 0x00:
+		printk(" TPSLP: 1/2,");
 		break;
 
-		case 0x04: 
-			printk(" TPSLP: 7/8,");
-			break;
+	case 0x01:
+		printk(" TPSLP: 2/3,");
+		break;
+
+	case 0x02:
+		printk(" TPSLP: 3/4,");
+		break;
+
+	case 0x03:
+		printk(" TPSLP: 5/6,");
+		break;
+
+	case 0x04:
+		printk(" TPSLP: 7/8,");
+		break;
+
+	default:
+		printk(" TPSLP: Reserved,");
 
-		default: 
-		
-			printk(" TPSLP: Reserved,");
-			
 	}
 
-	switch(val & 0x07) {
-	
-		case 0x00: 
-		
-			printk(" TPSHP: 1/2,");
-			
-			break;
-	
-		case 0x01: 
-		
-			printk(" TPSHP: 2/3,");
-			
-			break;
-	
-		case 0x02: 
-		
-			printk(" TPSHP: 3/4,");
-			
-			break;
-	
-		case 0x03: 
-			printk(" TPSHP: 5/6,");
+	switch (val & 0x07) {
+
+	case 0x00:
+		printk(" TPSHP: 1/2,");
 		break;
 
-		case 0x04: 
-			printk(" TPSHP: 7/8,");
-			break;
+	case 0x01:
+		printk(" TPSHP: 2/3,");
+		break;
+
+	case 0x02:
+		printk(" TPSHP: 3/4,");
+		break;
+
+	case 0x03:
+		printk(" TPSHP: 5/6,");
+		break;
+
+	case 0x04:
+		printk(" TPSHP: 7/8,");
+		break;
+
+	default:
+		printk(" TPSHP: Reserved,");
 
-		default: 
-		
-			printk(" TPSHP: Reserved,");
-			
 	}
 
 	val = nxt6000_readreg(fe, OFDM_TPS_RCVD_4);
-	
+
 	printk(" TPSMode: %s,", val & 0x01 ? "8K" : "2K");
-	
-	switch((val >> 4) & 0x03) {
-	
-		case 0x00: 
-		
-			printk(" TPSGuard: 1/32,");
-			
-			break;
-	
-		case 0x01: 
-		
-			printk(" TPSGuard: 1/16,");
-			
-			break;
-	
-		case 0x02: 
-		
-			printk(" TPSGuard: 1/8,");
-			
-			break;
-	
-		case 0x03: 
-		
-			printk(" TPSGuard: 1/4,");
-			
-			break;
-			
+
+	switch ((val >> 4) & 0x03) {
+
+	case 0x00:
+		printk(" TPSGuard: 1/32,");
+		break;
+
+	case 0x01:
+		printk(" TPSGuard: 1/16,");
+		break;
+
+	case 0x02:
+		printk(" TPSGuard: 1/8,");
+		break;
+
+	case 0x03:
+		printk(" TPSGuard: 1/4,");
+		break;
+
 	}
-	
+
 	/* Strange magic required to gain access to RF_AGC_STATUS */
 	nxt6000_readreg(fe, RF_AGC_VAL_1);
 	val = nxt6000_readreg(fe, RF_AGC_STATUS);
 	val = nxt6000_readreg(fe, RF_AGC_STATUS);
 
 	printk(" RF AGC LOCK: %d,", (val >> 4) & 0x01);
-
 	printk("\n");
-	
 }
 
-static int nxt6000_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
+static int nxt6000_ioctl(struct dvb_frontend *f, unsigned int cmd, void *arg)
 {
+	struct nxt6000_config *fe = (struct nxt6000_config *) f->data;
 
 	switch (cmd) {
 
-		case FE_GET_INFO:
-
-			memcpy(arg, &nxt6000_info, sizeof (struct dvb_frontend_info));
+	case FE_GET_INFO:
+		memcpy(arg, &nxt6000_info, sizeof(struct dvb_frontend_info));
+		return 0;
 
-			return 0;
-
-		case FE_READ_STATUS:
+	case FE_READ_STATUS:
 		{
-			fe_status_t *status = (fe_status_t *)arg;
+			fe_status_t *status = (fe_status_t *) arg;
 
 			u8 core_status;
 
 			*status = 0;
-			
+
 			core_status = nxt6000_readreg(fe, OFDM_COR_STAT);
 
 			if (core_status & AGCLOCKED)
@@ -710,28 +601,28 @@ static int nxt6000_ioctl(struct dvb_fron
 
 			if (nxt6000_readreg(fe, RS_COR_STAT) & RSCORESTATUS)
 				*status |= FE_HAS_SYNC;
-				
+
 			if ((core_status & TPSLOCKED) && (*status == (FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)))
 				*status |= FE_HAS_LOCK;
-				
+
 			if (debug)
 				nxt6000_dump_status(fe);
 
 			return 0;
-			
+
 		}
-	
-		case FE_READ_BER:
+
+	case FE_READ_BER:
 		{
-			u32 *ber = (u32 *)arg;
+			u32 *ber = (u32 *) arg;
 
-			*ber=0;
+			*ber = 0;
 
 			return 0;
-			
+
 		}
-	
-		case FE_READ_SIGNAL_STRENGTH:
+
+	case FE_READ_SIGNAL_STRENGTH:
 		{
 			s16 *signal = (s16 *) arg;
 /*
@@ -739,10 +630,10 @@ static int nxt6000_ioctl(struct dvb_fron
 */
 			*signal = 0;
 			return 0;
-			
+
 		}
-	
-		case FE_READ_SNR:
+
+	case FE_READ_SNR:
 		{
 			s16 *snr = (s16 *) arg;
 /*
@@ -752,54 +643,45 @@ static int nxt6000_ioctl(struct dvb_fron
 			*snr = 0;
 			break;
 		}
-	
-		case FE_READ_UNCORRECTED_BLOCKS: 
+
+	case FE_READ_UNCORRECTED_BLOCKS:
 		{
-			u32 *ublocks = (u32 *)arg;
+			u32 *ublocks = (u32 *) arg;
 
 			*ublocks = 0;
-
 			break;
 		}
-	
-		case FE_INIT:
-			nxt6000_reset(fe);
-			nxt6000_setup(fe);
+
+	case FE_INIT:
+		nxt6000_reset(fe);
+		nxt6000_setup(fe);
 		break;
 
-		case FE_SET_FRONTEND:
+	case FE_SET_FRONTEND:
 		{
-			struct nxt6000_config *nxt = FE2NXT(fe);
-			struct dvb_frontend_parameters *param = (struct dvb_frontend_parameters *)arg;
+			struct dvb_frontend_parameters *param = (struct dvb_frontend_parameters *) arg;
 			int result;
 
-			switch(nxt->tuner_type) {
-			
-				case TUNER_TYPE_ALP510:
-
-					if ((result = alp510_set_tv_freq(fe, param->frequency)) < 0)
-						return result;
-						
-					break;
-
-				case TUNER_TYPE_SP5659:
-
-					if ((result = sp5659_set_tv_freq(fe, param->frequency)) < 0)
-						return result;
-						
-					break;
-					
-				case TUNER_TYPE_SP5730:
-
-					if ((result = sp5730_set_tv_freq(fe, param->frequency)) < 0)
-						return result;
-
-					break;
-
-				default:
-				
-					return -EFAULT;
-					
+			switch (fe->tuner_type) {
+
+			case TUNER_TYPE_ALP510:
+				if ((result = alp510_set_tv_freq(fe, param->frequency)) < 0)
+					return result;
+				break;
+
+			case TUNER_TYPE_SP5659:
+				if ((result = sp5659_set_tv_freq(fe, param->frequency)) < 0)
+					return result;
+				break;
+
+			case TUNER_TYPE_SP5730:
+				if ((result = sp5730_set_tv_freq(fe, param->frequency)) < 0)
+					return result;
+				break;
+
+			default:
+				return -EFAULT;
+
 			}
 
 			if ((result = nxt6000_set_bandwidth(fe, param->u.ofdm.bandwidth)) < 0)
@@ -810,110 +692,157 @@ static int nxt6000_ioctl(struct dvb_fron
 				return result;
 			if ((result = nxt6000_set_inversion(fe, param->inversion)) < 0)
 				return result;
-			
+
 			break;
 		}
 
-		default:
-
-			return -EOPNOTSUPP;
-
+	default:
+		return -EOPNOTSUPP;
 	}
 
 	return 0;
-	
-} 
+}
+
+static u8 demod_addr_tbl[] = { 0x14, 0x18, 0x24, 0x28 };
 
-static u8 demod_addr_tbl[] = {0x14, 0x18, 0x24, 0x28};
+static struct i2c_client client_template;
 
-static int nxt6000_attach(struct dvb_i2c_bus *i2c, void **data)
+static int attach_adapter(struct i2c_adapter *adapter)
 {
+	struct i2c_client *client;
+	struct nxt6000_config *nxt;
 	u8 addr_nr;
-	u8 fe_count = 0;
-	struct nxt6000_config *pnxt;
+	int ret;
 
-	dprintk("nxt6000: attach\n");
-	
-	pnxt = kmalloc(sizeof(demod_addr_tbl)*sizeof(struct nxt6000_config), GFP_KERNEL);
-	if (NULL == pnxt) {
-		dprintk("nxt6000: no memory for private data.\n");
+	if ((nxt = kmalloc(sizeof(struct nxt6000_config), GFP_KERNEL)) == NULL)
 		return -ENOMEM;
-	}
-	*data = pnxt;
+
+	memset(nxt, 0, sizeof(*nxt));
+	nxt->i2c = adapter;
 
 	for (addr_nr = 0; addr_nr < sizeof(demod_addr_tbl); addr_nr++) {
-		struct nxt6000_config *nxt = &pnxt[addr_nr];
-	
-		if (nxt6000_read(i2c, demod_addr_tbl[addr_nr], OFDM_MSC_REV) != NXT6000ASICDEVICE)
+
+		if (nxt6000_read(adapter, demod_addr_tbl[addr_nr], OFDM_MSC_REV) != NXT6000ASICDEVICE)
 			continue;
 
-		if (pll_test(i2c, demod_addr_tbl[addr_nr], 0xC0) == 0) {
+		if (pll_test(adapter, demod_addr_tbl[addr_nr], 0xC0) == 0) {
 			nxt->tuner_addr = 0xC0;
 			nxt->tuner_type = TUNER_TYPE_ALP510;
 			nxt->clock_inversion = 1;
-	
+
 			dprintk("nxt6000: detected TI ALP510 tuner at 0x%02X\n", nxt->tuner_addr);
-		
-		} else if (pll_test(i2c, demod_addr_tbl[addr_nr], 0xC2) == 0) {
+
+		} else if (pll_test(adapter, demod_addr_tbl[addr_nr], 0xC2) == 0) {
 			nxt->tuner_addr = 0xC2;
 			nxt->tuner_type = TUNER_TYPE_SP5659;
 			nxt->clock_inversion = 0;
 
 			dprintk("nxt6000: detected MITEL SP5659 tuner at 0x%02X\n", nxt->tuner_addr);
-		
-		} else if (pll_test(i2c, demod_addr_tbl[addr_nr], 0xC0) == 0) {
+
+		} else if (pll_test(adapter, demod_addr_tbl[addr_nr], 0xC0) == 0) {
 			nxt->tuner_addr = 0xC0;
 			nxt->tuner_type = TUNER_TYPE_SP5730;
 			nxt->clock_inversion = 0;
 
 			dprintk("nxt6000: detected SP5730 tuner at 0x%02X\n", nxt->tuner_addr);
-		
+
 		} else {
 			printk("nxt6000: unable to detect tuner\n");
-			continue;	
+			continue;
 		}
-		
-		nxt->demod_addr = demod_addr_tbl[addr_nr];
-	  
-		dprintk("nxt6000: attached at %d:%d\n", i2c->adapter->num, i2c->id);
-	
-		dvb_register_frontend(nxt6000_ioctl, i2c, (void *)nxt, &nxt6000_info);
-		
-		fe_count++;
-	}
-	
-	if (fe_count == 0) {
-		kfree(pnxt);
+	}
+
+	if (addr_nr == sizeof(demod_addr_tbl)) {
+		kfree(nxt);
 		return -ENODEV;
 	}
-	
+
+	nxt->demod_addr = demod_addr_tbl[addr_nr];
+
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		kfree(nxt);
+		return -ENOMEM;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = demod_addr_tbl[addr_nr];
+	i2c_set_clientdata(client, (void *) nxt);
+
+	ret = i2c_attach_client(client);
+	if (ret) 
+		goto out;
+
+	BUG_ON(!nxt->dvb);
+
+	ret = dvb_register_frontend(nxt6000_ioctl, nxt->dvb, nxt, &nxt6000_info, THIS_MODULE);
+	if (ret) {
+		i2c_detach_client(client);
+		goto out;
+	}
+
+	ret = 0;
+out:
+	kfree(client);
+	kfree(nxt);
+	return ret;
+}
+
+static int detach_client(struct i2c_client *client)
+{
+	struct nxt6000_config *state = (struct nxt6000_config *) i2c_get_clientdata(client);
+	dvb_unregister_frontend(nxt6000_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
 	return 0;
 }
 
-static void nxt6000_detach(struct dvb_i2c_bus *i2c, void *data)
+static int command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	struct nxt6000_config *pnxt = (struct nxt6000_config *)data;
-	dprintk("nxt6000: detach\n");
-	dvb_unregister_frontend(nxt6000_ioctl, i2c);
-	kfree(pnxt);
+	struct nxt6000_config *state = (struct nxt6000_config *) i2c_get_clientdata(client);
+
+	switch (cmd) {
+	case FE_REGISTER:{
+			state->dvb = (struct dvb_adapter *) arg;
+			break;
+		}
+	case FE_UNREGISTER:{
+			state->dvb = NULL;
+			break;
+		}
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner = THIS_MODULE,
+	.name = "nxt6000",
+	.id = I2C_DRIVERID_DVBFE_NXT6000,
+	.flags = I2C_DF_NOTIFY,
+	.attach_adapter = attach_adapter,
+	.detach_client = detach_client,
+	.command = command,
+};
+
+static struct i2c_client client_template = {
+	I2C_DEVNAME("nxt6000"),
+	.flags = I2C_CLIENT_ALLOW_USE,
+	.driver = &driver,
+};
+
 static __init int nxt6000_init(void)
 {
-
-	dprintk("nxt6000: init\n");
-	
-	return dvb_register_i2c_device(THIS_MODULE, nxt6000_attach, nxt6000_detach);
-	
+	return i2c_add_driver(&driver);
 }
 
 static __exit void nxt6000_exit(void)
 {
-
-	dprintk("nxt6000: cleanup\n");
-
-	dvb_unregister_i2c_device(nxt6000_attach);
-
+	if (i2c_del_driver(&driver))
+		printk("nxt6000: driver deregistration failed\n");
 }
 
 module_init(nxt6000_init);
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/nxt6000.h linux/drivers/media/dvb/frontends/nxt6000.h
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/nxt6000.h	2004-09-14 10:34:33.000000000 +0200
+++ linux/drivers/media/dvb/frontends/nxt6000.h	2004-09-17 14:56:38.840593375 +0200
@@ -65,10 +65,10 @@
 #define BER_DONE               (0x08)
 #define BER_OVERFLOW           (0x10)
 
-/* 0x38 OFDM_BERTimer */     /* Use the alias registers */
+			     /* 0x38 OFDM_BERTimer *//* Use the alias registers */
 #define A_VIT_BER_TIMER_0      (0x1D)
 
-/* 0x3A VIT_BER_TIMER_0 */   /* Use the alias registers */
+			     /* 0x3A VIT_BER_TIMER_0 *//* Use the alias registers */
 #define A_VIT_BER_0            (0x1B)
 
 /* 0x40 OFDM_COR_CTL */
@@ -123,7 +123,7 @@
 /* 0x4D OFDM_ITB_FREQ_2 */
 #define OFDM_ITB_FREQ_2        (0x4D)
 
-/* 0x4E  OFDM_CAS_CTL */       
+/* 0x4E  OFDM_CAS_CTL */
 #define OFDM_CAS_CTL           (0x4E)
 #define ACSDIS                 (0x40)
 #define CCSEN                  (0x80)
@@ -152,7 +152,7 @@
 #define OFDM_SCR_CTL           (0x58)
 #define SYR_ADJ_DECAY_MASK     (0x70)
 #define SYR_ADJ_DECAY          (0x30)
- 
+
 /* 0x59 OFDM_PPM_CTL_1 */
 #define OFDM_PPM_CTL_1         (0x59)
 #define PPMMAX_MASK            (0x30)
@@ -219,7 +219,7 @@
 
 /* 0x82 EN_DMD_RACQ */
 #define EN_DMD_RACQ            (0x82)
-#define EN_DMD_RACQ_REG_VAL    (0x81) 
+#define EN_DMD_RACQ_REG_VAL    (0x81)
 #define EN_DMD_RACQ_REG_VAL_14 (0x01)
 
 /* 0x84 SNR_COMMAND */
@@ -263,4 +263,3 @@
 #define GATED_CLOCK            (0x01)
 
 #define NXT6000ASICDEVICE      (0x0b)
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/sp887x.c linux/drivers/media/dvb/frontends/sp887x.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/sp887x.c	2004-09-14 10:37:12.000000000 +0200
+++ linux/drivers/media/dvb/frontends/sp887x.c	2004-09-17 14:56:38.844592626 +0200
@@ -2,43 +2,32 @@
    Driver for the Microtune 7202D Frontend
 */
 
-/*
-   This driver needs a copy of the Avermedia firmware. The version tested
-   is part of the Avermedia DVB-T 1.3.26.3 Application. If the software is
-   installed in Windows the file will be in the /Program Files/AVerTV DVB-T/
-   directory and is called sc_main.mc. Alternatively it can "extracted" from
-   the install cab files. Copy this file to '/usr/lib/hotplug/firmware/sc_main.mc'.
-   With this version of the file the first 10 bytes are discarded and the
-   next 0x4000 loaded. This may change in future versions.
+/*   
+ * This driver needs external firmware. Please use the command
+ * "<kerneldir>/Documentation/dvb/get_dvb_firmware sp887x" to
+ * download/extract it, and then copy it to /usr/lib/hotplug/firmware.
  */
+#define SP887X_DEFAULT_FIRMWARE "dvb-fe-sp887x.fw"
 
-#include <linux/kernel.h>
-#include <linux/vmalloc.h>
-#include <linux/module.h>
 #include <linux/init.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/unistd.h>
-#include <linux/fcntl.h>
-#include <linux/errno.h>
-#include <linux/i2c.h>
-#include <linux/syscalls.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
-#ifndef DVB_SP887X_FIRMWARE_FILE
-#define DVB_SP887X_FIRMWARE_FILE "/usr/lib/hotplug/firmware/sc_main.mc"
-#endif
+#define FRONTEND_NAME "dvbfe_sp887x"
 
-static char *sp887x_firmware = DVB_SP887X_FIRMWARE_FILE;
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
 
-#if 0
-#define dprintk(x...) printk(x)
-#else
-#define dprintk(x...)
-#endif
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
 
 #if 0
 #define LOG(dir,addr,buf,len) 					\
@@ -53,9 +42,7 @@ static char *sp887x_firmware = DVB_SP887
 #define LOG(dir,addr,buf,len)
 #endif
 
-
-static
-struct dvb_frontend_info sp887x_info = {
+static struct dvb_frontend_info sp887x_info = {
 	.name = "Microtune MT7202DTF",
 	.type = FE_OFDM,
 	.frequency_min =  50500000,
@@ -67,16 +54,19 @@ struct dvb_frontend_info sp887x_info = {
                 FE_CAN_RECOVER
 };
 
-static
-int i2c_writebytes (struct dvb_frontend *fe, u8 addr, u8 *buf, u8 len)
+struct sp887x_state {
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
+
+static int i2c_writebytes (struct i2c_adapter *i2c, u8 addr, u8 *buf, u8 len)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
 	struct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = len };
 	int err;
 
 	LOG("i2c_writebytes", msg.addr, msg.buf, msg.len);
 
-	if ((err = i2c->xfer (i2c, &msg, 1)) != 1) {
+	if ((err = i2c_transfer (i2c, &msg, 1)) != 1) {
 		printk ("%s: i2c write error (addr %02x, err == %i)\n",
 			__FUNCTION__, addr, err);
 		return -EREMOTEIO;
@@ -85,23 +75,19 @@ int i2c_writebytes (struct dvb_frontend 
 	return 0;
 }
 
-
-
-static
-int sp887x_writereg (struct dvb_frontend *fe, u16 reg, u16 data)
+static int sp887x_writereg (struct i2c_adapter *i2c, u16 reg, u16 data)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
 	u8 b0 [] = { reg >> 8 , reg & 0xff, data >> 8, data & 0xff };
 	struct i2c_msg msg = { .addr = 0x70, .flags = 0, .buf = b0, .len = 4 };
 	int ret;
 
 	LOG("sp887x_writereg", msg.addr, msg.buf, msg.len);
 
-	if ((ret = i2c->xfer(i2c, &msg, 1)) != 1) {
+	if ((ret = i2c_transfer(i2c, &msg, 1)) != 1) {
 		/**
 		 *  in case of soft reset we ignore ACK errors...
 		 */
-		if (!(reg == 0xf1a && data == 0x000 && 
+		if (!(reg == 0xf1a && data == 0x000 &&
 			(ret == -EREMOTEIO || ret == -EFAULT)))
 		{
 			printk("%s: writereg error "
@@ -114,11 +100,8 @@ int sp887x_writereg (struct dvb_frontend
 	return 0;
 }
 
-
-static
-u16 sp887x_readreg (struct dvb_frontend *fe, u16 reg)
+static u16 sp887x_readreg (struct i2c_adapter *i2c, u16 reg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
 	u8 b0 [] = { reg >> 8 , reg & 0xff };
 	u8 b1 [2];
 	int ret;
@@ -128,39 +111,33 @@ u16 sp887x_readreg (struct dvb_frontend 
 	LOG("sp887x_readreg (w)", msg[0].addr, msg[0].buf, msg[0].len);
 	LOG("sp887x_readreg (r)", msg[1].addr, msg[1].buf, msg[1].len);
 
-	if ((ret = i2c->xfer(i2c, msg, 2)) != 2)
+	if ((ret = i2c_transfer(i2c, msg, 2)) != 2)
 		printk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
 
 	return (((b1[0] << 8) | b1[1]) & 0xfff);
 }
 
-
-static
-void sp887x_microcontroller_stop (struct dvb_frontend *fe)
+static void sp887x_microcontroller_stop (struct i2c_adapter *fe)
 {
 	dprintk("%s\n", __FUNCTION__);
 	sp887x_writereg(fe, 0xf08, 0x000);
-	sp887x_writereg(fe, 0xf09, 0x000);		
+	sp887x_writereg(fe, 0xf09, 0x000);
 
 	/* microcontroller STOP */
 	sp887x_writereg(fe, 0xf00, 0x000);
 }
 
-
-static
-void sp887x_microcontroller_start (struct dvb_frontend *fe)
+static void sp887x_microcontroller_start (struct i2c_adapter *fe)
 {
 	dprintk("%s\n", __FUNCTION__);
 	sp887x_writereg(fe, 0xf08, 0x000);
-	sp887x_writereg(fe, 0xf09, 0x000);		
+	sp887x_writereg(fe, 0xf09, 0x000);
 
 	/* microcontroller START */
 	sp887x_writereg(fe, 0xf00, 0x001);
 }
 
-
-static
-void sp887x_setup_agc (struct dvb_frontend *fe)
+static void sp887x_setup_agc (struct i2c_adapter *fe)
 {
 	/* setup AGC parameters */
 	dprintk("%s\n", __FUNCTION__);
@@ -180,72 +157,31 @@ void sp887x_setup_agc (struct dvb_fronte
 	sp887x_writereg(fe, 0x303, 0x000);
 }
 
-
 #define BLOCKSIZE 30
-
+#define FW_SIZE 0x4000
 /**
  *  load firmware and setup MPEG interface...
  */
-static
-int sp887x_initial_setup (struct dvb_frontend *fe)
+static int sp887x_initial_setup (struct i2c_adapter *fe, const struct firmware *fw)
 {
 	u8 buf [BLOCKSIZE+2];
-	unsigned char *firmware = NULL;
 	int i;
-	int fd;
-	int filesize;
-	int fw_size;
-	mm_segment_t fs;
+	int fw_size = fw->size;
+	unsigned char *mem = fw->data;
 
 	dprintk("%s\n", __FUNCTION__);
 
+	/* ignore the first 10 bytes, then we expect 0x4000 bytes of firmware */
+	if (fw_size < FW_SIZE+10)
+		return -ENODEV;
+
+	mem = fw->data + 10;
+
 	/* soft reset */
 	sp887x_writereg(fe, 0xf1a, 0x000);
 
 	sp887x_microcontroller_stop (fe);
 
-	fs = get_fs();
-
-	// Load the firmware
-	set_fs(get_ds());
-	fd = sys_open(sp887x_firmware, 0, 0);
-	if (fd < 0) {
-		printk(KERN_WARNING "%s: Unable to open firmware %s\n", __FUNCTION__,
-		       sp887x_firmware);
-		return -EIO;
-	}
-	filesize = sys_lseek(fd, 0L, 2);
-	if (filesize <= 0) {
-		printk(KERN_WARNING "%s: Firmware %s is empty\n", __FUNCTION__,
-		       sp887x_firmware);
-		sys_close(fd);
-		return -EIO;
-	}
-
-	fw_size = 0x4000;
-
-	// allocate buffer for it
-	firmware = vmalloc(fw_size);
-	if (firmware == NULL) {
-		printk(KERN_WARNING "%s: Out of memory loading firmware\n",
-		       __FUNCTION__);
-		sys_close(fd);
-		return -EIO;
-	}
-
-	// read it!
-	// read the first 16384 bytes from the file
-	// ignore the first 10 bytes
-	sys_lseek(fd, 10, 0);
-	if (sys_read(fd, firmware, fw_size) != fw_size) {
-		printk(KERN_WARNING "%s: Failed to read firmware\n", __FUNCTION__);
-		vfree(firmware);
-		sys_close(fd);
-		return -EIO;
-	}
-	sys_close(fd);
-	set_fs(fs);
-
 	printk ("%s: firmware upload... ", __FUNCTION__);
 
 	/* setup write pointer to -1 (end of memory) */
@@ -255,12 +191,12 @@ int sp887x_initial_setup (struct dvb_fro
 	/* dummy write (wrap around to start of memory) */
 	sp887x_writereg(fe, 0x8f0a, 0x0000);
 
-	for (i=0; i<fw_size; i+=BLOCKSIZE) {
+	for (i = 0; i < FW_SIZE; i += BLOCKSIZE) {
 		int c = BLOCKSIZE;
 		int err;
 
-		if (i+c > fw_size)
-			c = fw_size - i;
+		if (i+c > FW_SIZE)
+			c = FW_SIZE - i;
 
 		/* bit 0x8000 in address is set to enable 13bit mode */
 		/* bit 0x4000 enables multibyte read/write transfers */
@@ -268,18 +204,15 @@ int sp887x_initial_setup (struct dvb_fro
 		buf[0] = 0xcf;
 		buf[1] = 0x0a;
 
-		memcpy(&buf[2], firmware + i, c);
+		memcpy(&buf[2], mem + i, c);
 
 		if ((err = i2c_writebytes (fe, 0x70, buf, c+2)) < 0) {
 			printk ("failed.\n");
 			printk ("%s: i2c error (err == %i)\n", __FUNCTION__, err);
-			vfree(firmware);
 			return err;
 		}
 	}
 
-	vfree(firmware);
-
 	/* don't write RS bytes between packets */
 	sp887x_writereg(fe, 0xc13, 0x001);
 
@@ -305,13 +238,11 @@ int sp887x_initial_setup (struct dvb_fro
 	return 0;
 };
 
-
 /**
  *  returns the actual tuned center frequency which can be used
  *  to initialise the AFC registers
  */
-static
-int tsa5060_setup_pll (struct dvb_frontend *fe, int freq)
+static int tsa5060_setup_pll (struct i2c_adapter *fe, int freq)
 {
 	u8 cfg, cpump, band_select;
 	u8 buf [4];
@@ -338,13 +269,10 @@ int tsa5060_setup_pll (struct dvb_fronte
 	return (div * 166666 - 36000000);
 }
 
-
-
-static
-int configure_reg0xc05 (struct dvb_frontend_parameters *p, u16 *reg0xc05)
+static int configure_reg0xc05 (struct dvb_frontend_parameters *p, u16 *reg0xc05)
 {
 	int known_parameters = 1;
-	
+
 	*reg0xc05 = 0x000;
 
 	switch (p->u.ofdm.constellation) {
@@ -412,13 +340,11 @@ int configure_reg0xc05 (struct dvb_front
 	return 0;
 }
 
-
 /**
  *  estimates division of two 24bit numbers,
  *  derived from the ves1820/stv0299 driver code
  */
-static
-void divide (int n, int d, int *quotient_i, int *quotient_f)
+static void divide (int n, int d, int *quotient_i, int *quotient_f)
 {
 	unsigned int q, r;
 
@@ -436,9 +362,7 @@ void divide (int n, int d, int *quotient
 	}
 }
 
-
-static
-void sp887x_correct_offsets (struct dvb_frontend *fe,
+static void sp887x_correct_offsets (struct i2c_adapter *fe,
 			     struct dvb_frontend_parameters *p,
 			     int actual_freq)
 {
@@ -469,9 +393,7 @@ void sp887x_correct_offsets (struct dvb_
 	sp887x_writereg(fe, 0x30a, frequency_shift & 0xfff);
 }
 
-
-static
-int sp887x_setup_frontend_parameters (struct dvb_frontend *fe,
+static int sp887x_setup_frontend_parameters (struct i2c_adapter *fe,
 				      struct dvb_frontend_parameters *p)
 {
 	int actual_freq, err;
@@ -481,7 +403,7 @@ int sp887x_setup_frontend_parameters (st
 	    p->u.ofdm.bandwidth != BANDWIDTH_7_MHZ &&
 	    p->u.ofdm.bandwidth != BANDWIDTH_6_MHZ)
 		return -EINVAL;
-	
+
 	if ((err = configure_reg0xc05(p, &reg0xc05)))
 		return err;
 
@@ -529,10 +451,11 @@ int sp887x_setup_frontend_parameters (st
 	return 0;
 }
 
-
-static
-int sp887x_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
+static int sp887x_ioctl(struct dvb_frontend *f, unsigned int cmd, void *arg)
 {
+	struct sp887x_state *state = (struct sp887x_state *) f->data;
+	struct i2c_adapter *fe = state->i2c;
+
         switch (cmd) {
         case FE_GET_INFO:
 		memcpy (arg, &sp887x_info, sizeof(struct dvb_frontend_info));
@@ -622,10 +545,6 @@ int sp887x_ioctl (struct dvb_frontend *f
 		break;
 
         case FE_INIT:
-		if (fe->data == NULL) {	  /* first time initialisation... */
-			fe->data = (void*) ~0;
-			sp887x_initial_setup (fe);
-		}
 		/* enable TS output and interface pins */
 		sp887x_writereg(fe, 0xc18, 0x00d);
 		break;
@@ -633,11 +552,11 @@ int sp887x_ioctl (struct dvb_frontend *f
 	case FE_GET_TUNE_SETTINGS:
 	{
 	        struct dvb_frontend_tune_settings* fesettings = (struct dvb_frontend_tune_settings*) arg;
-	        fesettings->min_delay_ms = 50;
-	        fesettings->step_size = 0;
-	        fesettings->max_drift = 0;
+	        fesettings->min_delay_ms = 350;
+	        fesettings->step_size = 166666*2;
+	        fesettings->max_drift = (166666*2)+1;
 	        return 0;
-	}	    
+	}
 
 	default:
 		return -EOPNOTSUPP;
@@ -646,51 +565,139 @@ int sp887x_ioctl (struct dvb_frontend *f
         return 0;
 }
 
+static struct i2c_client client_template;
 
-
-static
-int sp887x_attach (struct dvb_i2c_bus *i2c, void **data)
+static int attach_adapter(struct i2c_adapter *adapter)
 {
+	struct i2c_client *client;
+	struct sp887x_state *state;
+	const struct firmware *fw;
+	int ret;
+
 	struct i2c_msg msg = {.addr = 0x70, .flags = 0, .buf = NULL, .len = 0 };
 
 	dprintk ("%s\n", __FUNCTION__);
 
-	if (i2c->xfer (i2c, &msg, 1) != 1)
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	if (NULL == (state = kmalloc(sizeof(struct sp887x_state), GFP_KERNEL))) {
+		kfree(client);
+		return -ENOMEM;
+	}
+	state->i2c = adapter;
+
+	if (i2c_transfer (adapter, &msg, 1) != 1) {
+		kfree(state);
+		kfree(client);
                 return -ENODEV;
+	}
 
-	return dvb_register_frontend (sp887x_ioctl, i2c, NULL, &sp887x_info);
-}
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	i2c_set_clientdata(client, (void*)state);
+
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	/* request the firmware, this will block until someone uploads it */
+	printk("sp887x: waiting for firmware upload...\n");
+	ret = request_firmware(&fw, SP887X_DEFAULT_FIRMWARE, &client->dev);
+	if (ret) {
+		printk("sp887x: no firmware upload (timeout or file not found?)\n");
+		goto out;
+	}
+
+	ret = sp887x_initial_setup(adapter, fw);
+	if (ret) {
+		printk("sp887x: writing firmware to device failed\n");
+		goto out;
+	}
+
+	ret = dvb_register_frontend(sp887x_ioctl, state->dvb, state,
+					&sp887x_info, THIS_MODULE);
+	if (ret) {
+		printk("sp887x: registering frontend to dvb-core failed.\n");
+		goto out;
+	}
 
+	return 0;
+out:
+	release_firmware(fw);
+	i2c_detach_client(client);
+	kfree(client);
+	kfree(state);
+	return ret;
+}
 
-static
-void sp887x_detach (struct dvb_i2c_bus *i2c, void *data)
+static int detach_client(struct i2c_client *client)
 {
+	struct sp887x_state *state = (struct sp887x_state*)i2c_get_clientdata(client);
+
 	dprintk ("%s\n", __FUNCTION__);
-	dvb_unregister_frontend (sp887x_ioctl, i2c);
-}
 
+	dvb_unregister_frontend (sp887x_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
 
-static
-int __init init_sp887x (void)
+static int command (struct i2c_client *client, unsigned int cmd, void *arg)
 {
+	struct sp887x_state *state = (struct sp887x_state*)i2c_get_clientdata(client);
+
 	dprintk ("%s\n", __FUNCTION__);
-	return dvb_register_i2c_device (NULL, sp887x_attach, sp887x_detach);
+
+	switch (cmd) {
+	case FE_REGISTER:
+		state->dvb = (struct dvb_adapter*)arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= FRONTEND_NAME,
+	.id 		= I2C_DRIVERID_DVBFE_SP887X,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = attach_adapter,
+	.detach_client 	= detach_client,
+	.command 	= command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
 
-static
-void __exit exit_sp887x (void)
+static int __init init_sp887x(void)
 {
-	dprintk ("%s\n", __FUNCTION__);
-	dvb_unregister_i2c_device (sp887x_attach);
+	return i2c_add_driver(&driver);
 }
 
+static void __exit exit_sp887x(void)
+{
+	if (i2c_del_driver(&driver))
+		printk("sp887x: driver deregistration failed\n");
+}
 
 module_init(init_sp887x);
 module_exit(exit_sp887x);
 
-
 MODULE_DESCRIPTION("sp887x DVB-T demodulator driver");
 MODULE_LICENSE("GPL");
 
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/stv0299.c linux/drivers/media/dvb/frontends/stv0299.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/stv0299.c	2004-09-14 10:38:09.000000000 +0200
+++ linux/drivers/media/dvb/frontends/stv0299.c	2004-09-17 14:56:38.852591127 +0200
@@ -8,7 +8,7 @@
 	<ralph@convergence.de>,
 	<holger@convergence.de>,
 	<js@convergence.de>
-    
+
 
     Philips SU1278/SH
 
@@ -18,7 +18,7 @@
     LG TDQF-S001F
 
     Copyright (C) 2002 Felix Domke <tmbinc@elitedvb.net>
-                     & Andreas Oberritter <obi@linuxtv.org>
+		     & Andreas Oberritter <obi@linuxtv.org>
 
 
     Support for Samsung TBMU24112IMB used on Technisat SkyStar2 rev. 2.6B
@@ -43,43 +43,51 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-*/    
+*/
 
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <asm/div64.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
-#if 0
-#define dprintk(x...) printk(x)
-#else
-#define dprintk(x...)
-#endif
+#define FRONTEND_NAME "dvbfe_stv0299"
 
-static int stv0299_status = 0;
-static int disable_typhoon = 0;
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
+
+static int debug;
+static int stv0299_status;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+module_param(stv0299_status, int, 0444);
+MODULE_PARM_DESC(stv0299_status, "Which status value to support "
+		 "(0 == BER (default), 1 == UCBLOCKS)");
 
 #define STATUS_BER 0
 #define STATUS_UCBLOCKS 1
 
 
 /* frontend types */
-#define UNKNOWN_FRONTEND  -1
+#define UNKNOWN_FRONTEND       -1
 #define PHILIPS_SU1278_TSA	0 // SU1278 with TSA5059 synth and datasheet recommended settings
-#define ALPS_BSRU6         1
-#define LG_TDQF_S001F      2
-#define PHILIPS_SU1278_TUA      3 // SU1278 with TUA6100 synth
-#define SAMSUNG_TBMU24112IMB    4
+#define ALPS_BSRU6		1
+#define LG_TDQF_S001F		2
+#define PHILIPS_SU1278_TUA	3 // SU1278 with TUA6100 synth
+#define SAMSUNG_TBMU24112IMB	4
 #define PHILIPS_SU1278_TSA_TT	5 // SU1278 with TSA5059 synth and TechnoTrend settings
 #define PHILIPS_SU1278_TSA_TY	6 // SU1278 with TUA5059 synth and Typhoon wiring
+#define PHILIPS_SU1278_TSA_CI	7 // SU1278 with TUA5059 synth and TerraTec Cinergy wiring
 
 /* Master Clock = 88 MHz */
-#define M_CLK (88000000UL) 
+#define M_CLK (88000000UL)
 
 /* Master Clock for TT cards = 64 MHz */
 #define M_CLK_SU1278_TSA_TT (64000000UL)
@@ -89,11 +97,11 @@ static struct dvb_frontend_info uni0299_
 	.type			= FE_QPSK,
 	.frequency_min		= 950000,
 	.frequency_max		= 2150000,
-	.frequency_stepsize	= 125,   /* kHz for QPSK frontends */
+	.frequency_stepsize	= 125,	 /* kHz for QPSK frontends */
 	.frequency_tolerance	= M_CLK/2000,
 	.symbol_rate_min	= 1000000,
 	.symbol_rate_max	= 45000000,
-	.symbol_rate_tolerance	= 500,  /* ppm */
+	.symbol_rate_tolerance	= 500,	/* ppm */
 	.notifier_delay		= 0,
 	.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 	      FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
@@ -108,34 +116,36 @@ struct stv0299_state {
 	u32 tuner_frequency;
 	u32 symbol_rate;
 	fe_code_rate_t fec_inner;
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
 };
 
 
 static u8 init_tab [] = {
-	0x04, 0x7d,   /* F22FR = 0x7d                                 */
-		      /* F22 = f_VCO / 128 / 0x7d = 22 kHz            */
+	0x04, 0x7d,   /* F22FR = 0x7d				      */
+		      /* F22 = f_VCO / 128 / 0x7d = 22 kHz	      */
 
-        /* I2C bus repeater */
-	0x05, 0x35,   /* I2CT = 0, SCLT = 1, SDAT = 1                 */
+	/* I2C bus repeater */
+	0x05, 0x35,   /* I2CT = 0, SCLT = 1, SDAT = 1		      */
 
- 	/* general purpose DAC registers */
+	/* general purpose DAC registers */
 	0x06, 0x40,   /* DAC not used, set to high impendance mode    */
-	0x07, 0x00,   /* DAC LSB                                      */
+	0x07, 0x00,   /* DAC LSB				      */
 
 	/* DiSEqC registers */
 	0x08, 0x40,   /* DiSEqC off, LNB power on OP2/LOCK pin on     */
-	0x09, 0x00,   /* FIFO                                         */
+	0x09, 0x00,   /* FIFO					      */
 
-        /* Input/Output configuration register */
+	/* Input/Output configuration register */
 	0x0c, 0x51,   /* OP1 ctl = Normal, OP1 val = 1 (LNB Power ON) */
-	              /* OP0 ctl = Normal, OP0 val = 1 (18 V)         */
-                      /* Nyquist filter = 00, QPSK reverse = 0        */
-                   
-        /* AGC1 control register */
+		      /* OP0 ctl = Normal, OP0 val = 1 (18 V)	      */
+		      /* Nyquist filter = 00, QPSK reverse = 0	      */
+
+	/* AGC1 control register */
 	0x0d, 0x82,   /* DC offset compensation = ON, beta_agc1 = 2   */
 
-        /* Timing loop register */
-	0x0e, 0x23,   /* alpha_tmg = 2, beta_tmg = 3                  */
+	/* Timing loop register */
+	0x0e, 0x23,   /* alpha_tmg = 2, beta_tmg = 3		      */
 
 	0x10, 0x3f,   // AGC2  0x3d
 
@@ -157,7 +167,7 @@ static u8 init_tab [] = {
 	0x22, 0x00,
 	0x23, 0x00,
 
-	0x28, 0x00,  // out imp: normal  out type: parallel FEC mode:0
+	0x28, 0x00,  // out imp: normal	 out type: parallel FEC mode:0
 
 	0x29, 0x1e,  // 1/2 threshold
 	0x2a, 0x14,  // 2/3 threshold
@@ -220,70 +230,70 @@ static u8 init_tab_samsung [] = {
 
 
 static u8 init_tab_su1278_tsa_tt [] = {
-        0x01, 0x0f,
-        0x02, 0x30,
-        0x03, 0x00,
-        0x04, 0x5b,
-        0x05, 0x85,
-        0x06, 0x02,
-        0x07, 0x00,
-        0x08, 0x02,
-        0x09, 0x00,
-        0x0C, 0x01,
-        0x0D, 0x81,
-        0x0E, 0x44,
-        0x0f, 0x14,
-        0x10, 0x3c,
-        0x11, 0x84,
-        0x12, 0xda,
-        0x13, 0x97,
-        0x14, 0x95,
-        0x15, 0xc9,
-        0x16, 0x19,
-        0x17, 0x8c,
-        0x18, 0x59,
-        0x19, 0xf8,
-        0x1a, 0xfe,
-        0x1c, 0x7f,
-        0x1d, 0x00,
-        0x1e, 0x00,
-        0x1f, 0x50,
-        0x20, 0x00,
-        0x21, 0x00,
-        0x22, 0x00,
-        0x23, 0x00,
-        0x28, 0x00,
-        0x29, 0x28,
-        0x2a, 0x14,
-        0x2b, 0x0f,
-        0x2c, 0x09,
-        0x2d, 0x09,
-        0x31, 0x1f,
-        0x32, 0x19,
-        0x33, 0xfc,
-        0x34, 0x13
+	0x01, 0x0f,
+	0x02, 0x30,
+	0x03, 0x00,
+	0x04, 0x5b,
+	0x05, 0x85,
+	0x06, 0x02,
+	0x07, 0x00,
+	0x08, 0x02,
+	0x09, 0x00,
+	0x0C, 0x01,
+	0x0D, 0x81, 
+	0x0E, 0x44,
+	0x0f, 0x14,
+	0x10, 0x3c,
+	0x11, 0x84,
+	0x12, 0xda,
+	0x13, 0x97,
+	0x14, 0x95,
+	0x15, 0xc9,
+	0x16, 0x19,
+	0x17, 0x8c,
+	0x18, 0x59,
+	0x19, 0xf8,
+	0x1a, 0xfe,
+	0x1c, 0x7f,
+	0x1d, 0x00,
+	0x1e, 0x00,
+	0x1f, 0x50,
+	0x20, 0x00,
+	0x21, 0x00,
+	0x22, 0x00,
+	0x23, 0x00,
+	0x28, 0x00,
+	0x29, 0x28,
+	0x2a, 0x14,
+	0x2b, 0x0f,
+	0x2c, 0x09,
+	0x2d, 0x09,
+	0x31, 0x1f,
+	0x32, 0x19,
+	0x33, 0xfc,
+	0x34, 0x13
 };
 
-static int stv0299_set_FEC (struct dvb_i2c_bus *i2c, fe_code_rate_t fec);
-static int stv0299_set_symbolrate (struct dvb_i2c_bus *i2c, u32 srate, int tuner_type);
+static int stv0299_set_FEC (struct i2c_adapter *i2c, fe_code_rate_t fec);
+static int stv0299_set_symbolrate (struct i2c_adapter *i2c, u32 srate, int tuner_type);
 
-static int stv0299_writereg (struct dvb_i2c_bus *i2c, u8 reg, u8 data)
+static int stv0299_writereg (struct i2c_adapter *i2c, u8 reg, u8 data)
 {
 	int ret;
 	u8 buf [] = { reg, data };
 	struct i2c_msg msg = { .addr = 0x68, .flags = 0, .buf = buf, .len = 2 };
 
-	ret = i2c->xfer (i2c, &msg, 1);
+	ret = i2c_transfer (i2c, &msg, 1);
 
-	if (ret != 1) 
+	if (ret != 1)
 		dprintk("%s: writereg error (reg == 0x%02x, val == 0x%02x, "
 			"ret == %i)\n", __FUNCTION__, reg, data, ret);
 
-	return (ret != 1) ? -1 : 0;
+	return (ret != 1) ? -EREMOTEIO : 0;
 }
 
 
-static u8 stv0299_readreg (struct dvb_i2c_bus *i2c, u8 reg)
+static u8 stv0299_readreg (struct i2c_adapter *i2c, u8 reg)
 {
 	int ret;
 	u8 b0 [] = { reg };
@@ -291,9 +301,9 @@ static u8 stv0299_readreg (struct dvb_i2
 	struct i2c_msg msg [] = { { .addr = 0x68, .flags = 0, .buf = b0, .len = 1 },
 			   { .addr = 0x68, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
 
-	ret = i2c->xfer (i2c, msg, 2);
-        
-	if (ret != 2) 
+	ret = i2c_transfer (i2c, msg, 2);
+
+	if (ret != 2)
 		dprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n",
 				__FUNCTION__, reg, ret);
 
@@ -301,22 +311,22 @@ static u8 stv0299_readreg (struct dvb_i2
 }
 
 
-static int stv0299_readregs (struct dvb_i2c_bus *i2c, u8 reg1, u8 *b, u8 len)
+static int stv0299_readregs (struct i2c_adapter *i2c, u8 reg1, u8 *b, u8 len)
 {
-        int ret;
-        struct i2c_msg msg [] = { { .addr = 0x68, .flags = 0, .buf = &reg1, .len = 1 },
-                           { .addr = 0x68, .flags = I2C_M_RD, .buf = b, .len = len } };
+	int ret;
+	struct i2c_msg msg [] = { { .addr = 0x68, .flags = 0, .buf = &reg1, .len = 1 },
+			   { .addr = 0x68, .flags = I2C_M_RD, .buf = b, .len = len } };
 
-        ret = i2c->xfer (i2c, msg, 2);
+	ret = i2c_transfer (i2c, msg, 2);
 
-        if (ret != 2)
-                dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
+	if (ret != 2)
+		dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
 
-        return ret == 2 ? 0 : ret;
+	return ret == 2 ? 0 : ret;
 }
 
 
-static int pll_write (struct dvb_i2c_bus *i2c, u8 addr, u8 *data, int len)
+static int pll_write (struct i2c_adapter *i2c, u8 addr, u8 *data, int len)
 {
 	int ret;
 	struct i2c_msg msg = { addr: addr, .flags = 0, .buf = data, .len = len };
@@ -324,7 +334,7 @@ static int pll_write (struct dvb_i2c_bus
 
 	stv0299_writereg(i2c, 0x05, 0xb5);	/*  enable i2c repeater on stv0299  */
 
-	ret =  i2c->xfer (i2c, &msg, 1);
+	ret =  i2c_transfer (i2c, &msg, 1);
 
 	stv0299_writereg(i2c, 0x05, 0x35);	/*  disable i2c repeater on stv0299  */
 
@@ -335,7 +345,7 @@ static int pll_write (struct dvb_i2c_bus
 }
 
 
-static int sl1935_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq, int ftype)
+static int sl1935_set_tv_freq (struct i2c_adapter *i2c, u32 freq, int ftype)
 {
 	u8 buf[4];
 	u32 div;
@@ -355,10 +365,10 @@ static int sl1935_set_tv_freq (struct dv
 }
 
 /**
- *   set up the downconverter frequency divisor for a 
+ *   set up the downconverter frequency divisor for a
  *   reference clock comparision frequency of 125 kHz.
  */
-static int tsa5059_set_tv_freq	(struct dvb_i2c_bus *i2c, u32 freq, int ftype, int srate)
+static int tsa5059_set_tv_freq	(struct i2c_adapter *i2c, u32 freq, int ftype, int srate)
 {
 	u8 addr;
 	u32 div;
@@ -370,8 +380,8 @@ static int tsa5059_set_tv_freq	(struct d
 	if ((freq < 950000) || (freq > 2150000)) return -EINVAL;
 
 	if (ftype == PHILIPS_SU1278_TSA_TT) {
-        divisor = 500;
-        regcode = 2;
+		divisor = 500;
+		regcode = 2;
 	} else {
 		divisor = 125;
 		regcode = 4;
@@ -383,21 +393,22 @@ static int tsa5059_set_tv_freq	(struct d
 	buf[1] = div & 0xff;
 	buf[2] = 0x80 | ((div & 0x18000) >> 10) | regcode;
 	buf[3] = 0;
-
+    
 	// tuner-specific settings
 	switch(ftype) {
 	case PHILIPS_SU1278_TSA:
 	case PHILIPS_SU1278_TSA_TT:
 	case PHILIPS_SU1278_TSA_TY:
-		if (ftype == PHILIPS_SU1278_TSA_TY)
+	case PHILIPS_SU1278_TSA_CI:
+		if (ftype == PHILIPS_SU1278_TSA_TY || ftype == PHILIPS_SU1278_TSA_CI)
 			addr = 0x61;
 		else
-		addr = 0x60;
+			addr = 0x60;
 
 		buf[3] |= 0x20;
 
 		if (srate < 4000000) buf[3] |= 1;
-	   
+
 		if (freq < 1250000) buf[3] |= 0;
 		else if (freq < 1550000) buf[3] |= 0x40;
 		else if (freq < 2050000) buf[3] |= 0x80;
@@ -408,7 +419,7 @@ static int tsa5059_set_tv_freq	(struct d
 		addr = 0x61;
 		buf[3] = 0xC4;
 		if (freq > 1530000) buf[3] = 0xc0;
-	 	break;
+		break;
 
 	default:
 		return -EINVAL;
@@ -421,7 +432,7 @@ static int tsa5059_set_tv_freq	(struct d
 #define MIN2(a,b) ((a) < (b) ? (a) : (b))
 #define MIN3(a,b,c) MIN2(MIN2(a,b),c)
 
-static int tua6100_set_tv_freq	(struct dvb_i2c_bus *i2c, u32 freq,
+static int tua6100_set_tv_freq	(struct i2c_adapter *i2c, u32 freq,
 			 int ftype, int srate)
 {
 	u8 reg0 [2] = { 0x00, 0x00 };
@@ -458,7 +469,7 @@ static int tua6100_set_tv_freq	(struct d
 			reg0[1] = 0x0B;
 		else if ((first_ZF >= 1420) && (first_ZF < 1455))
 			reg0[1] = 0x0F;
-}
+	}
 
 	if (first_ZF > 1525)
 		reg1[1] |= 0x80;
@@ -466,41 +477,41 @@ static int tua6100_set_tv_freq	(struct d
 		reg1[1] &= 0x7F;
 
 	if (_fband == 2) {
-	        if (first_ZF > 1430) { /* 1430MHZ */
-	                reg1[1] &= 0xCF; /* N2 */
+		if (first_ZF > 1430) { /* 1430MHZ */
+			reg1[1] &= 0xCF; /* N2 */
 			reg2[1] &= 0xCF; /* R2 */
 			reg2[1] |= 0x10;
-	        } else {
-        		reg1[1] &= 0xCF; /* N2 */
+		} else {
+			reg1[1] &= 0xCF; /* N2 */
 			reg1[1] |= 0x20;
 			reg2[1] &= 0xCF; /* R2 */
 			reg2[1] |= 0x10;
 		}
-}
+	}
 
 	if (_fband == 3) {
-        	if ((first_ZF >= 1455) &&
+		if ((first_ZF >= 1455) &&
 		    (first_ZF < 1630)) {
 			reg1[1] &= 0xCF; /* N2 */
 			reg1[1] |= 0x20;
 			reg2[1] &= 0xCF; /* R2 */
-	        } else {
+		} else {
 			if (first_ZF < 1455) {
-	                        reg1[1] &= 0xCF; /* N2 */
+				reg1[1] &= 0xCF; /* N2 */
 				reg1[1] |= 0x20;
-                	        reg2[1] &= 0xCF; /* R2 */
-                        	reg2[1] |= 0x10;
-	                } else {
-	                        if (first_ZF >= 1630) {
-        	                        reg1[1] &= 0xCF; /* N2 */
-                        	        reg2[1] &= 0xCF; /* R2 */
-                                	reg2[1] |= 0x10;
-	                        }
-        	        }
-	        }
+				reg2[1] &= 0xCF; /* R2 */
+				reg2[1] |= 0x10;
+			} else {
+				if (first_ZF >= 1630) {
+					reg1[1] &= 0xCF; /* N2 */
+					reg2[1] &= 0xCF; /* R2 */
+					reg2[1] |= 0x10;
+				}
+			}
+		}
 	}
 
-        /* set ports, enable P0 for symbol rates > 4Ms/s */
+	/* set ports, enable P0 for symbol rates > 4Ms/s */
 	if (srate >= 4000000)
 		reg1[1] |= 0x0c;
 	else
@@ -510,17 +521,17 @@ static int tua6100_set_tv_freq	(struct d
 
 	R = 64;
 	A = 64;
-	P = 64;  //32
+	P = 64;	 //32
 
 	M = (freq * R) / 4;		/* in Mhz */
 	N = (M - A * 1000) / (P * 1000);
 
 	reg1[1] |= (N >> 9) & 0x03;
-	reg1[2]  = (N >> 1) & 0xff;
-	reg1[3]  = (N << 7) & 0x80;
+	reg1[2]	 = (N >> 1) & 0xff;
+	reg1[3]	 = (N << 7) & 0x80;
 
 	reg2[1] |= (R >> 8) & 0x03;
-	reg2[2]  = R & 0xFF;	/* R */
+	reg2[2]	 = R & 0xFF;	/* R */
 
 	reg1[3] |= A & 0x7f;	/* A */
 
@@ -542,25 +553,25 @@ static int tua6100_set_tv_freq	(struct d
 }
 
 
-static int pll_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq, int ftype, int srate)
+static int pll_set_tv_freq (struct i2c_adapter *i2c, u32 freq, int ftype, int srate)
 {
 	switch(ftype) {
 	case SAMSUNG_TBMU24112IMB:
 		return sl1935_set_tv_freq(i2c, freq, ftype);
-
+	
 	case LG_TDQF_S001F:
 		return sl1935_set_tv_freq(i2c, freq, ftype);
-
+	    
 	case PHILIPS_SU1278_TUA:
 		return tua6100_set_tv_freq(i2c, freq, ftype, srate);
 
 	default:
 		return tsa5059_set_tv_freq(i2c, freq, ftype, srate);
-}
+	}
 }
 
 #if 0
-static int tsa5059_read_status	(struct dvb_i2c_bus *i2c)
+static int tsa5059_read_status	(struct i2c_adapter *i2c)
 {
 	int ret;
 	u8 rpt1 [] = { 0x05, 0xb5 };
@@ -571,7 +582,7 @@ static int tsa5059_read_status	(struct d
 
 	dprintk ("%s\n", __FUNCTION__);
 
-	ret = i2c->xfer (i2c, msg, 2);
+	ret = i2c_transfer (i2c, msg, 2);
 
 	if (ret != 2)
 		dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
@@ -581,7 +592,7 @@ static int tsa5059_read_status	(struct d
 #endif
 
 
-static int stv0299_init (struct dvb_i2c_bus *i2c, int ftype)
+static int stv0299_init (struct i2c_adapter *i2c, int ftype)
 {
 	int i;
 
@@ -600,34 +611,34 @@ static int stv0299_init (struct dvb_i2c_
 		break;
 
 	case PHILIPS_SU1278_TSA_TT:
-	        for (i=0; i<sizeof(init_tab_su1278_tsa_tt); i+=2) {
+		for (i=0; i<sizeof(init_tab_su1278_tsa_tt); i+=2) {
 			stv0299_writereg (i2c, init_tab_su1278_tsa_tt[i], init_tab_su1278_tsa_tt[i+1]);
 		}
-	        break;
-
+		break;
+	    
 	default:
-	stv0299_writereg (i2c, 0x01, 0x15);
+		stv0299_writereg (i2c, 0x01, 0x15);
 		stv0299_writereg (i2c, 0x02, ftype == PHILIPS_SU1278_TUA ? 0x00 : 0x30);
-	stv0299_writereg (i2c, 0x03, 0x00);
+		stv0299_writereg (i2c, 0x03, 0x00);
 
-	for (i=0; i<sizeof(init_tab); i+=2)
-		stv0299_writereg (i2c, init_tab[i], init_tab[i+1]);
+		for (i=0; i<sizeof(init_tab); i+=2)
+			stv0299_writereg (i2c, init_tab[i], init_tab[i+1]);
 
-        /* AGC1 reference register setup */
-		if (ftype == PHILIPS_SU1278_TSA || ftype == PHILIPS_SU1278_TSA_TY)
+		/* AGC1 reference register setup */
+		if (ftype == PHILIPS_SU1278_TSA || ftype == PHILIPS_SU1278_TSA_TY || ftype == PHILIPS_SU1278_TSA_CI)
 		  stv0299_writereg (i2c, 0x0f, 0x92);  /* Iagc = Inverse, m1 = 18 */
 		else if (ftype == PHILIPS_SU1278_TUA)
 		  stv0299_writereg (i2c, 0x0f, 0x94);  /* Iagc = Inverse, m1 = 20 */
-	else
-	  stv0299_writereg (i2c, 0x0f, 0x52);  /* Iagc = Normal,  m1 = 18 */
+		else
+		  stv0299_writereg (i2c, 0x0f, 0x52);  /* Iagc = Normal,  m1 = 18 */
 		break;
 	}
-	
+
 	switch(stv0299_status) {
 	case STATUS_BER:
 		stv0299_writereg(i2c, 0x34, 0x93);
 		break;
-	
+
 	case STATUS_UCBLOCKS:
 		stv0299_writereg(i2c, 0x34, 0xB3);
 		break;
@@ -637,7 +648,7 @@ static int stv0299_init (struct dvb_i2c_
 }
 
 
-static int stv0299_set_FEC (struct dvb_i2c_bus *i2c, fe_code_rate_t fec)
+static int stv0299_set_FEC (struct i2c_adapter *i2c, fe_code_rate_t fec)
 {
 	dprintk ("%s\n", __FUNCTION__);
 
@@ -677,11 +688,11 @@ static int stv0299_set_FEC (struct dvb_i
 		dprintk ("%s : FEC invalid\n", __FUNCTION__);
 		return -EINVAL;
 	}
-}
+    }
 }
 
 
-static fe_code_rate_t stv0299_get_fec (struct dvb_i2c_bus *i2c)
+static fe_code_rate_t stv0299_get_fec (struct i2c_adapter *i2c)
 {
 	static fe_code_rate_t fec_tab [] = { FEC_2_3, FEC_3_4, FEC_5_6,
 					     FEC_7_8, FEC_1_2 };
@@ -699,7 +710,7 @@ static fe_code_rate_t stv0299_get_fec (s
 }
 
 
-static int stv0299_wait_diseqc_fifo (struct dvb_i2c_bus *i2c, int timeout)
+static int stv0299_wait_diseqc_fifo (struct i2c_adapter *i2c, int timeout)
 {
 	unsigned long start = jiffies;
 
@@ -710,14 +721,14 @@ static int stv0299_wait_diseqc_fifo (str
 			dprintk ("%s: timeout!!\n", __FUNCTION__);
 			return -ETIMEDOUT;
 		}
-		dvb_delay(10);
+		msleep(10);
 	};
 
 	return 0;
 }
 
 
-static int stv0299_wait_diseqc_idle (struct dvb_i2c_bus *i2c, int timeout)
+static int stv0299_wait_diseqc_idle (struct i2c_adapter *i2c, int timeout)
 {
 	unsigned long start = jiffies;
 
@@ -728,14 +739,14 @@ static int stv0299_wait_diseqc_idle (str
 			dprintk ("%s: timeout!!\n", __FUNCTION__);
 			return -ETIMEDOUT;
 		}
-		dvb_delay(10);
+		msleep(10);
 	};
 
 	return 0;
 }
 
 
-static int stv0299_send_diseqc_msg (struct dvb_i2c_bus *i2c,
+static int stv0299_send_diseqc_msg (struct i2c_adapter *i2c,
 			     struct dvb_diseqc_master_cmd *m)
 {
 	u8 val;
@@ -766,7 +777,7 @@ static int stv0299_send_diseqc_msg (stru
 }
 
 
-static int stv0299_send_diseqc_burst (struct dvb_i2c_bus *i2c, fe_sec_mini_cmd_t burst)
+static int stv0299_send_diseqc_burst (struct i2c_adapter *i2c, fe_sec_mini_cmd_t burst)
 {
 	u8 val;
 
@@ -777,7 +788,7 @@ static int stv0299_send_diseqc_burst (st
 
 	val = stv0299_readreg (i2c, 0x08);
 
-	if (stv0299_writereg (i2c, 0x08, (val & ~0x7) | 0x2))   /* burst mode */
+	if (stv0299_writereg (i2c, 0x08, (val & ~0x7) | 0x2))	/* burst mode */
 		return -EREMOTEIO;
 
 	if (stv0299_writereg (i2c, 0x09, burst == SEC_MINI_A ? 0x00 : 0xff))
@@ -793,12 +804,12 @@ static int stv0299_send_diseqc_burst (st
 }
 
 
-static int stv0299_set_tone (struct dvb_i2c_bus *i2c, fe_sec_tone_mode_t tone)
+static int stv0299_set_tone (struct i2c_adapter *i2c, fe_sec_tone_mode_t tone)
 {
 	u8 val;
 
 	dprintk("%s: %s\n", __FUNCTION__,
-		tone == SEC_TONE_ON ? "SEC_TONE_ON" : 
+		tone == SEC_TONE_ON ? "SEC_TONE_ON" :
 		tone == SEC_TONE_OFF ? "SEC_TONE_OFF" : "??");
 
 	if (stv0299_wait_diseqc_idle (i2c, 100) < 0)
@@ -809,36 +820,36 @@ static int stv0299_set_tone (struct dvb_
 	switch (tone) {
 	case SEC_TONE_ON:
 	{
-	    	dprintk("%s: TONE_ON\n", __FUNCTION__);
+		dprintk("%s: TONE_ON\n", __FUNCTION__);
 		return stv0299_writereg (i2c, 0x08, val | 0x3);
-	}	
+	}
 	case SEC_TONE_OFF:
 	{
-	    	dprintk("%s: TONE_OFF\n", __FUNCTION__);
+		dprintk("%s: TONE_OFF\n", __FUNCTION__);
 		return stv0299_writereg (i2c, 0x08, (val & ~0x3) | 0x02);
 	}
 	default:
 	{
-	    	dprintk("%s: TONE INVALID\n", __FUNCTION__);
+		dprintk("%s: TONE INVALID\n", __FUNCTION__);
 		return -EINVAL;
 	}
 	};
 }
 
 
-static int stv0299_set_voltage (struct dvb_i2c_bus *i2c, fe_sec_voltage_t voltage,
+static int stv0299_set_voltage (struct i2c_adapter *i2c, fe_sec_voltage_t voltage,
 				int tuner_type)
 {
 	u8 reg0x08;
 	u8 reg0x0c;
 
 	dprintk("%s: %s\n", __FUNCTION__,
-		voltage == SEC_VOLTAGE_13 ? "SEC_VOLTAGE_13" : 
+		voltage == SEC_VOLTAGE_13 ? "SEC_VOLTAGE_13" :
 		voltage == SEC_VOLTAGE_18 ? "SEC_VOLTAGE_18" : "??");
 
 	reg0x08 = stv0299_readreg (i2c, 0x08);
 	reg0x0c = stv0299_readreg (i2c, 0x0c);
-
+    
 	/**
 	 *  H/V switching over OP0, OP1 and OP2 are LNB power enable bits
 	 */
@@ -849,11 +860,18 @@ static int stv0299_set_voltage (struct d
 		return stv0299_writereg (i2c, 0x08, 0x00); /*	LNB power off! */
 	}
 	
+	if (tuner_type == PHILIPS_SU1278_TSA_CI) 
+	{
+		stv0299_writereg (i2c, 0x08, reg0x08 & 0xBF); // switch LNB power on OP2/LOCK pin off
+	}
+	else
+	{
 		stv0299_writereg (i2c, 0x08, reg0x08 | 0x40);
+	}
 
 	switch (voltage) {
 	case SEC_VOLTAGE_13:
-		if (tuner_type == PHILIPS_SU1278_TSA_TY)
+		if (tuner_type == PHILIPS_SU1278_TSA_TY || tuner_type == PHILIPS_SU1278_TSA_CI)
 			return stv0299_writereg (i2c, 0x0c, reg0x0c | 0x10);
 		else
 			return stv0299_writereg (i2c, 0x0c, reg0x0c | 0x40);
@@ -867,57 +885,59 @@ static int stv0299_set_voltage (struct d
 }
 
 
-static int stv0299_set_symbolrate (struct dvb_i2c_bus *i2c, u32 srate, int tuner_type)
+static int stv0299_set_symbolrate (struct i2c_adapter *i2c, u32 srate, int tuner_type)
 {
 	u64 big = srate;
 	u32 ratio;
 	u8 aclk = 0;
 	u8 bclk = 0;
 	u8 m1;
-        int Mclk = M_CLK;
-
-        // check rate is within limits
+	int Mclk = M_CLK;
+    
+	// check rate is within limits
 	if ((srate < 1000000) || (srate > 45000000)) return -EINVAL;
-
-        // calculate value to program
+    
+	// calculate value to program
 	if (tuner_type == PHILIPS_SU1278_TSA_TT) Mclk = M_CLK_SU1278_TSA_TT;
-        big = big << 20;
+	big = big << 20;
 	big += (Mclk-1); // round correctly
-        do_div(big, Mclk);
-        ratio = big << 4;
-
-        // program registers
+	do_div(big, Mclk);
+	ratio = big << 4;
+    
+	// program registers
 	switch(tuner_type) {
 	case PHILIPS_SU1278_TSA_TT:
-	        stv0299_writereg (i2c, 0x0e, 0x44);
-	        if (srate >= 10000000) {
-		        stv0299_writereg (i2c, 0x13, 0x97);
-		        stv0299_writereg (i2c, 0x14, 0x95);
-		        stv0299_writereg (i2c, 0x15, 0xc9);
-		        stv0299_writereg (i2c, 0x17, 0x8c);
-		        stv0299_writereg (i2c, 0x1a, 0xfe);
-		        stv0299_writereg (i2c, 0x1c, 0x7f);
-		        stv0299_writereg (i2c, 0x2d, 0x09);
+		stv0299_writereg (i2c, 0x0e, 0x44);
+		if (srate >= 10000000) {
+			stv0299_writereg (i2c, 0x13, 0x97);
+			stv0299_writereg (i2c, 0x14, 0x95);
+			stv0299_writereg (i2c, 0x15, 0xc9);
+			stv0299_writereg (i2c, 0x17, 0x8c);
+			stv0299_writereg (i2c, 0x1a, 0xfe);
+			stv0299_writereg (i2c, 0x1c, 0x7f);
+			stv0299_writereg (i2c, 0x2d, 0x09);
 		} else {
-		        stv0299_writereg (i2c, 0x13, 0x99);
-		        stv0299_writereg (i2c, 0x14, 0x8d);
-		        stv0299_writereg (i2c, 0x15, 0xce);
-		        stv0299_writereg (i2c, 0x17, 0x43);
-		        stv0299_writereg (i2c, 0x1a, 0x1d);
-		        stv0299_writereg (i2c, 0x1c, 0x12);
-		        stv0299_writereg (i2c, 0x2d, 0x05);
+			stv0299_writereg (i2c, 0x13, 0x99);
+			stv0299_writereg (i2c, 0x14, 0x8d);
+			stv0299_writereg (i2c, 0x15, 0xce);
+			stv0299_writereg (i2c, 0x17, 0x43);
+			stv0299_writereg (i2c, 0x1a, 0x1d);
+			stv0299_writereg (i2c, 0x1c, 0x12);
+			stv0299_writereg (i2c, 0x2d, 0x05);
 		}
-	        stv0299_writereg (i2c, 0x0e, 0x23);
-	        stv0299_writereg (i2c, 0x0f, 0x94);
-	        stv0299_writereg (i2c, 0x10, 0x39);
-	        stv0299_writereg (i2c, 0x15, 0xc9);
-
-	        stv0299_writereg (i2c, 0x1f, (ratio >> 16) & 0xff);
-	        stv0299_writereg (i2c, 0x20, (ratio >>  8) & 0xff);
-	        stv0299_writereg (i2c, 0x21, (ratio      ) & 0xf0);
-	        break;
 
+		stv0299_writereg (i2c, 0x0e, 0x23);
+		stv0299_writereg (i2c, 0x0f, 0x94);
+		stv0299_writereg (i2c, 0x10, 0x39);
+		stv0299_writereg (i2c, 0x15, 0xc9);
+	    
+		stv0299_writereg (i2c, 0x1f, (ratio >> 16) & 0xff);
+		stv0299_writereg (i2c, 0x20, (ratio >>	8) & 0xff);
+		stv0299_writereg (i2c, 0x21, (ratio	 ) & 0xf0);
+		break;
+	    
 	case PHILIPS_SU1278_TSA_TY:
+	case PHILIPS_SU1278_TSA_CI:
 	case PHILIPS_SU1278_TSA:
 		aclk = 0xb5;
 		if (srate < 2000000) bclk = 0x86;
@@ -928,12 +948,12 @@ static int stv0299_set_symbolrate (struc
 		m1 = 0x14;
 		if (srate < 4000000) m1 = 0x10;
 
-	    	stv0299_writereg (i2c, 0x13, aclk);
-  	        stv0299_writereg (i2c, 0x14, bclk);
-	        stv0299_writereg (i2c, 0x1f, (ratio >> 16) & 0xff);
-	        stv0299_writereg (i2c, 0x20, (ratio >>  8) & 0xff);
-	        stv0299_writereg (i2c, 0x21, (ratio      ) & 0xf0);
-	        stv0299_writereg (i2c, 0x0f, (stv0299_readreg(i2c, 0x0f) & 0xc0) | m1);
+		stv0299_writereg (i2c, 0x13, aclk);
+		stv0299_writereg (i2c, 0x14, bclk);
+		stv0299_writereg (i2c, 0x1f, (ratio >> 16) & 0xff);
+		stv0299_writereg (i2c, 0x20, (ratio >>	8) & 0xff);
+		stv0299_writereg (i2c, 0x21, (ratio	 ) & 0xf0);
+		stv0299_writereg (i2c, 0x0f, (stv0299_readreg(i2c, 0x0f) & 0xc0) | m1);
 		break;
 
 	case ALPS_BSRU6:
@@ -944,21 +964,21 @@ static int stv0299_set_symbolrate (struc
 		else if (srate < 14000000) { aclk = 0xb7; bclk = 0x53; }
 		else if (srate < 30000000) { aclk = 0xb6; bclk = 0x53; }
 		else if (srate < 45000000) { aclk = 0xb4; bclk = 0x51; }
-  
-	stv0299_writereg (i2c, 0x13, aclk);
-	stv0299_writereg (i2c, 0x14, bclk);
-	stv0299_writereg (i2c, 0x1f, (ratio >> 16) & 0xff);
-	stv0299_writereg (i2c, 0x20, (ratio >>  8) & 0xff);
-	stv0299_writereg (i2c, 0x21, (ratio      ) & 0xf0);
+
+		stv0299_writereg (i2c, 0x13, aclk);
+		stv0299_writereg (i2c, 0x14, bclk);
+		stv0299_writereg (i2c, 0x1f, (ratio >> 16) & 0xff);
+		stv0299_writereg (i2c, 0x20, (ratio >>	8) & 0xff);
+		stv0299_writereg (i2c, 0x21, (ratio	 ) & 0xf0);
 		break;
 	}
-
+    
 
 	return 0;
 }
 
 
-static int stv0299_get_symbolrate (struct dvb_i2c_bus *i2c, int tuner_type)
+static int stv0299_get_symbolrate (struct i2c_adapter *i2c, int tuner_type)
 {
 	u32 Mclk = M_CLK / 4096L;
 	u32 srate;
@@ -968,8 +988,8 @@ static int stv0299_get_symbolrate (struc
 
 	dprintk ("%s\n", __FUNCTION__);
 
-    	if (tuner_type == PHILIPS_SU1278_TSA_TT) Mclk = M_CLK_SU1278_TSA_TT / 4096L;
-
+	if (tuner_type == PHILIPS_SU1278_TSA_TT) Mclk = M_CLK_SU1278_TSA_TT / 4096L;
+    
 	stv0299_readregs (i2c, 0x1f, sfr, 3);
 	stv0299_readregs (i2c, 0x1a, &rtf, 1);
 
@@ -977,7 +997,6 @@ static int stv0299_get_symbolrate (struc
 	srate *= Mclk;
 	srate /= 16;
 	srate += (sfr[2] >> 4) * Mclk / 256;
-
 	offset = (s32) rtf * (srate / 4096L);
 	offset /= 128;
 
@@ -995,19 +1014,19 @@ static int stv0299_get_symbolrate (struc
 
 static int uni0299_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
 	struct stv0299_state *state = (struct stv0299_state *) fe->data;
-
+	struct i2c_adapter *i2c = state->i2c;
+   
 	dprintk ("%s\n", __FUNCTION__);
 
 	switch (cmd) {
-	case FE_GET_INFO:
+	case FE_GET_INFO: 
 	{
-	        struct dvb_frontend_info* tmp = (struct dvb_frontend_info*) arg;
+		struct dvb_frontend_info* tmp = (struct dvb_frontend_info*) arg;
 		memcpy (arg, &uni0299_info, sizeof(struct dvb_frontend_info));
 
 		if (state->tuner_type == PHILIPS_SU1278_TSA_TT) {
-		        tmp->frequency_tolerance = M_CLK_SU1278_TSA_TT / 2000;
+			tmp->frequency_tolerance = M_CLK_SU1278_TSA_TT / 2000;
 		}
 		break;
 	}
@@ -1040,10 +1059,10 @@ static int uni0299_ioctl (struct dvb_fro
 		break;
 	}
 
-        case FE_READ_BER:
+	case FE_READ_BER:
 		if (stv0299_status == STATUS_BER) {
-		*((u32*) arg) = (stv0299_readreg (i2c, 0x1d) << 8)
-			       | stv0299_readreg (i2c, 0x1e);
+			*((u32*) arg) = (stv0299_readreg (i2c, 0x1d) << 8)
+				       | stv0299_readreg (i2c, 0x1e);
 		} else {
 			*((u32*) arg) = 0;
 		}
@@ -1052,7 +1071,7 @@ static int uni0299_ioctl (struct dvb_fro
 	case FE_READ_SIGNAL_STRENGTH:
 	{
 		s32 signal =  0xffff - ((stv0299_readreg (i2c, 0x18) << 8)
-			               | stv0299_readreg (i2c, 0x19));
+				       | stv0299_readreg (i2c, 0x19));
 
 		dprintk ("%s : FE_READ_SIGNAL_STRENGTH : AGC2I: 0x%02x%02x, signal=0x%04x\n", __FUNCTION__,
 			 stv0299_readreg (i2c, 0x18),
@@ -1063,26 +1082,26 @@ static int uni0299_ioctl (struct dvb_fro
 				(signal < 0) ? 0 : signal;
 		break;
 	}
-        case FE_READ_SNR:
+	case FE_READ_SNR:
 	{
 		s32 snr = 0xffff - ((stv0299_readreg (i2c, 0x24) << 8)
-			           | stv0299_readreg (i2c, 0x25));
+				   | stv0299_readreg (i2c, 0x25));
 		snr = 3 * (snr - 0xa100);
 		*((u16*) arg) = (snr > 0xffff) ? 0xffff :
 				(snr < 0) ? 0 : snr;
 		break;
 	}
-	case FE_READ_UNCORRECTED_BLOCKS: 
+	case FE_READ_UNCORRECTED_BLOCKS:
 		if (stv0299_status == STATUS_UCBLOCKS) {
 			*((u32*) arg) = (stv0299_readreg (i2c, 0x1d) << 8)
-			               | stv0299_readreg (i2c, 0x1e);
+				       | stv0299_readreg (i2c, 0x1e);
 		} else {
 			*((u32*) arg) = 0;
 		}
 		break;
 
-        case FE_SET_FRONTEND:
-        {
+	case FE_SET_FRONTEND:
+	{
 		struct dvb_frontend_parameters *p = arg;
 		int invval = 0;
 
@@ -1126,7 +1145,7 @@ static int uni0299_ioctl (struct dvb_fro
 				stv0299_writereg (i2c, 0x23, 0x00);
 				stv0299_writereg (i2c, 0x32, 0x19);
 				stv0299_set_symbolrate (i2c, p->u.qpsk.symbol_rate, state->tuner_type);
-                stv0299_set_FEC (i2c, p->u.qpsk.fec_inner);
+				stv0299_set_FEC (i2c, p->u.qpsk.fec_inner);
 			}
 			break;
 		}
@@ -1135,28 +1154,28 @@ static int uni0299_ioctl (struct dvb_fro
 			pll_set_tv_freq (i2c, p->frequency, state->tuner_type, p->u.qpsk.symbol_rate);
 			stv0299_set_FEC (i2c, p->u.qpsk.fec_inner);
 			stv0299_set_symbolrate (i2c, p->u.qpsk.symbol_rate, state->tuner_type);
-		stv0299_writereg (i2c, 0x22, 0x00);
-		stv0299_writereg (i2c, 0x23, 0x00);
-		stv0299_readreg (i2c, 0x23);
-		stv0299_writereg (i2c, 0x12, 0xb9);
+			stv0299_writereg (i2c, 0x22, 0x00);
+			stv0299_writereg (i2c, 0x23, 0x00);
+			stv0299_readreg (i2c, 0x23);
+			stv0299_writereg (i2c, 0x12, 0xb9);
 			break;
 		}
 
 		state->tuner_frequency = p->frequency;
 		state->fec_inner = p->u.qpsk.fec_inner;
 		state->symbol_rate = p->u.qpsk.symbol_rate;
-                break;
-        }
+		break;
+	}
 
-        case FE_GET_FRONTEND:
-        {
+	case FE_GET_FRONTEND:
+	{
 		struct dvb_frontend_parameters *p = arg;
 		s32 derot_freq;
-	        int Mclk = M_CLK;
+		int Mclk = M_CLK;
 		int invval;
 
 		if (state->tuner_type == PHILIPS_SU1278_TSA_TT) Mclk = M_CLK_SU1278_TSA_TT;
-
+	    
 		derot_freq = (s32)(s16) ((stv0299_readreg (i2c, 0x22) << 8)
 					| stv0299_readreg (i2c, 0x23));
 
@@ -1172,17 +1191,17 @@ static int uni0299_ioctl (struct dvb_fro
 
 		p->u.qpsk.fec_inner = stv0299_get_fec (i2c);
 		p->u.qpsk.symbol_rate = stv0299_get_symbolrate (i2c, state->tuner_type);
-                break;
-        }
+		break;
+	}
 
-        case FE_SLEEP:
-		stv0299_writereg (i2c, 0x0c, 0x00);  /*  LNB power off! */
-		stv0299_writereg (i2c, 0x08, 0x00); /*  LNB power off! */
+	case FE_SLEEP:
+		stv0299_writereg (i2c, 0x0c, 0x00); /*	LNB power off! */
+		stv0299_writereg (i2c, 0x08, 0x00); /*	LNB power off! */
 		stv0299_writereg (i2c, 0x02, 0x80);
 		state->initialised = 0;
 		break;
 
-        case FE_INIT:
+	case FE_INIT:
 		switch(state->tuner_type) {
 		case PHILIPS_SU1278_TSA_TT:
 			state->tuner_frequency = 0;
@@ -1240,7 +1259,7 @@ static int uni0299_ioctl (struct dvb_fro
 
 		return 0;
 	}
-
+	    
 	default:
 		return -EOPNOTSUPP;
 	};
@@ -1248,13 +1267,13 @@ static int uni0299_ioctl (struct dvb_fro
 	return 0;
 }
 
-static long probe_tuner (struct dvb_i2c_bus *i2c)
+static long probe_tuner (struct i2c_adapter *adapter)
 {
-	struct dvb_adapter * adapter = (struct dvb_adapter *) i2c->adapter;
-
-        /* read the status register of TSA5059 */
+	struct i2c_adapter *i2c = adapter; /* superfluous */
+	
+	/* read the status register of TSA5059 */
 	u8 rpt[] = { 0x05, 0xb5 };
-        u8 stat [] = { 0 };
+	u8 stat [] = { 0 };
 	u8 tda6100_buf [] = { 0, 0 };
 	int ret;
 	struct i2c_msg msg1 [] = {{ .addr = 0x68, .flags = 0, .buf = rpt,  len: 2 },
@@ -1269,47 +1288,47 @@ static long probe_tuner (struct dvb_i2c_
 	stv0299_writereg (i2c, 0x03, 0x00);
 
 
-	printk ("%s: try to attach to %s\n", __FUNCTION__, adapter->name);
-
-	if ( strcmp(adapter->name, "SkyStar2") == 0 )
-	{
-	    printk ("%s: setup for tuner Samsung TBMU24112IMB\n", __FILE__);
+	printk("stv0299: try to attach to %s\n", adapter->name);
 
-    	    return SAMSUNG_TBMU24112IMB;
+	if (!strcmp(adapter->name, "Technisat SkyStar2 driver")) {
+	    printk ("stv0299: setup for tuner Samsung TBMU24112IMB\n");
+	    return SAMSUNG_TBMU24112IMB;
 	}
 
-	if ((ret = i2c->xfer(i2c, msg1, 2)) == 2) {
-	        if ( strcmp(adapter->name, "TT-Budget/WinTV-NOVA-CI PCI") == 0 ) {
-		        // technotrend cards require non-datasheet settings
-			printk ("%s: setup for tuner SU1278 (TSA5059 synth) on"
-				" TechnoTrend hardware\n", __FILE__);
-		        return PHILIPS_SU1278_TSA_TT;
+	if ((ret = i2c_transfer(i2c, msg1, 2)) == 2) {
+		if ( strcmp(adapter->name, "TT-Budget/WinTV-NOVA-CI PCI") == 0 ) {
+			// technotrend cards require non-datasheet settings
+			printk ("stv0299: setup for tuner SU1278 (TSA5059 synth) on TechnoTrend hardware\n");
+			return PHILIPS_SU1278_TSA_TT;
 		}  else {
-		        // fall back to datasheet-recommended settings
-			printk ("%s: setup for tuner SU1278 (TSA5059 synth)\n",
-				__FILE__);
-		        return PHILIPS_SU1278_TSA;
-		}
+			// fall back to datasheet-recommended settings
+			printk ("stv0299: setup for tuner SU1278 (TSA5059 synth)\n");
+			return PHILIPS_SU1278_TSA;
 		}
+	}
 
-	if ((ret = i2c->xfer(i2c, msg2, 2)) == 2) {
-		if ( strcmp(adapter->name, "KNC1 DVB-S") == 0 &&
-		     !disable_typhoon )
+	if ((ret = i2c_transfer(i2c, msg2, 2)) == 2) {
+		if ( strcmp(adapter->name, "KNC1 DVB-S") == 0 )
 		{
 			// Typhoon cards have unusual wiring.
-			printk ("%s: setup for tuner SU1278 (TSA5059 synth) on"
-				" Typhoon hardware\n", __FILE__);
+			printk ("stv0299: setup for tuner SU1278 (TSA5059 synth) on Typhoon hardware\n");
 			return PHILIPS_SU1278_TSA_TY;
+		} 
+		else if ( strcmp(adapter->name, "TerraTec Cinergy 1200 DVB-S") == 0 )
+		{
+			// Cinergy cards have unusual wiring.
+			printk ("%s: setup for tuner SU1278 (TSA5059 synth) on"
+				" TerraTec hardware\n", __FILE__);
+			return PHILIPS_SU1278_TSA_CI;
 		}
 		//else if ((stat[0] & 0x3f) == 0) {
 		else if (0) {
-			printk ("%s: setup for tuner TDQF-S001F\n", __FILE__);
+			printk ("stv0299: setup for tuner TDQF-S001F\n");
 			return LG_TDQF_S001F;
-	} else {
-			printk ("%s: setup for tuner BSRU6, TDQB-S00x\n",
-			__FILE__);
+		} else {
+			printk ("stv0299: setup for tuner BSRU6, TDQB-S00x\n");
 			return ALPS_BSRU6;
-	}
+		}
 	}
 
 	/**
@@ -1317,29 +1336,29 @@ static long probe_tuner (struct dvb_i2c_
 	 */
 	stv0299_writereg (i2c, 0x02, 0x00);
 
-	if ((ret = i2c->xfer(i2c, msg3, 2)) == 2) {
-		printk ("%s: setup for tuner Philips SU1278 (TUA6100 synth)\n",
-			__FILE__);
+	if ((ret = i2c_transfer(i2c, msg3, 2)) == 2) {
+		printk ("stv0299: setup for tuner Philips SU1278 (TUA6100 synth)\n");
 		return PHILIPS_SU1278_TUA;
 	}
 
-	printk ("%s: unknown PLL synthesizer (ret == %i), "
-		"please report to <linuxdvb@linuxtv.org>!!\n",
-		__FILE__, ret);
+	printk ("stv0299: unknown PLL synthesizer (ret == %i), please report to <linuxdvb@linuxtv.org>!!\n", ret);
 
 	return UNKNOWN_FRONTEND;
 }
 
+static struct i2c_client client_template;
 
-static int uni0299_attach (struct dvb_i2c_bus *i2c, void **data)
+static int attach_adapter(struct i2c_adapter *adapter)
 {
+	struct i2c_client *client;
 	struct stv0299_state* state;
 	int tuner_type;
+	int ret;
 	u8 id;
- 
-	stv0299_writereg (i2c, 0x02, 0x34); /* standby off */
-	dvb_delay(200);
-	id = stv0299_readreg (i2c, 0x00);
+
+	stv0299_writereg(adapter, 0x02, 0x34); /* standby off */
+	msleep(200);
+	id = stv0299_readreg(adapter, 0x00);
 
 	dprintk ("%s: id == 0x%02x\n", __FUNCTION__, id);
 
@@ -1348,53 +1367,112 @@ static int uni0299_attach (struct dvb_i2
 	if (id != 0xa1 && id != 0x80)
 		return -ENODEV;
 
-	if ((tuner_type = probe_tuner(i2c)) < 0)
+	if ((tuner_type = probe_tuner(adapter)) < 0)
 		return -ENODEV;
 
 	if ((state = kmalloc(sizeof(struct stv0299_state), GFP_KERNEL)) == NULL) {
 		return -ENOMEM;
 	}
 
-	*data = state;
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
 	state->tuner_type = tuner_type;
 	state->tuner_frequency = 0;
 	state->initialised = 0;
-	return dvb_register_frontend (uni0299_ioctl, i2c, (void *) state,
-			       &uni0299_info);
+	state->i2c = adapter;
+	
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = (0x68>>1);
+	i2c_set_clientdata(client, (void*)state);
+	
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(client);
+		kfree(state);
+		return -EFAULT;
+	}
+	
+	BUG_ON(!state->dvb);
+
+	ret = dvb_register_frontend(uni0299_ioctl, state->dvb, state,
+					&uni0299_info, THIS_MODULE);
+	if (ret) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(state);
+		return -EFAULT;
+	}
+	
+	return 0;
 }
 
+static int detach_client(struct i2c_client *client)
+{
+	struct stv0299_state *state = (struct stv0299_state*)i2c_get_clientdata(client);
 
-static void uni0299_detach (struct dvb_i2c_bus *i2c, void *data)
+	dvb_unregister_frontend (uni0299_ioctl, state->dvb);
+	i2c_detach_client(client);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
+
+static int command (struct i2c_client *client, unsigned int cmd, void *arg)
 {
+	struct stv0299_state *data = (struct stv0299_state*)i2c_get_clientdata(client);
 	dprintk ("%s\n", __FUNCTION__);
-	kfree(data);
-	dvb_unregister_frontend (uni0299_ioctl, i2c);
+
+	switch (cmd) {
+	case FE_REGISTER: {
+		data->dvb = (struct dvb_adapter*)arg;
+		break;
+	}
+	case FE_UNREGISTER: {
+		data->dvb = NULL;
+		break;
+	}
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= FRONTEND_NAME,
+	.id 		= I2C_DRIVERID_DVBFE_STV0299,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = attach_adapter,
+	.detach_client 	= detach_client,
+	.command 	= command,
+};
+
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
 
 static int __init init_uni0299 (void)
 {
-	dprintk ("%s\n", __FUNCTION__);
-	return dvb_register_i2c_device (NULL, uni0299_attach, uni0299_detach);
+	return i2c_add_driver(&driver);
 }
 
-
 static void __exit exit_uni0299 (void)
 {
-	dprintk ("%s\n", __FUNCTION__);
-
-	dvb_unregister_i2c_device (uni0299_attach);
+	if (i2c_del_driver(&driver))
+		printk("stv0299: driver deregistration failed\n");
 }
 
 module_init (init_uni0299);
 module_exit (exit_uni0299);
 
 MODULE_DESCRIPTION("Universal STV0299/TSA5059/SL1935 DVB Frontend driver");
-MODULE_AUTHOR("Ralph Metzler, Holger Waechtler, Peter Schildmann, Felix Domke, Andreas Oberritter, Andrew de Quincey");
+MODULE_AUTHOR("Ralph Metzler, Holger Waechtler, Peter Schildmann, Felix Domke, "
+              "Andreas Oberritter, Andrew de Quincey, Kenneth Aafløy");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(stv0299_status, "i");
-MODULE_PARM_DESC(stv0299_status, "Which status value to support (0: BER, 1: UCBLOCKS)");
-
-MODULE_PARM(disable_typhoon, "i");
-MODULE_PARM_DESC(disable_typhoon, "Disable support for Philips SU1278 on Typhoon hardware.");
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/tda1004x.c linux/drivers/media/dvb/frontends/tda1004x.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/tda1004x.c	2004-09-14 10:34:33.000000000 +0200
+++ linux/drivers/media/dvb/frontends/tda1004x.c	2004-09-17 14:56:38.859589816 +0200
@@ -19,118 +19,113 @@
      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
    */
-
 /*
-    This driver needs a copy of the DLL "ttlcdacc.dll" from the Haupauge or Technotrend
-    windows driver saved as '/usr/lib/hotplug/firmware/tda1004x.bin'.
-    You can also pass the complete file name with the module parameter 'tda1004x_firmware'.
-
-    Currently the DLL from v2.15a of the technotrend driver is supported. Other versions can
-    be added reasonably painlessly.
-
-    Windows driver URL: http://www.technotrend.de/
+ * This driver needs external firmware. Please use the commands
+ * "<kerneldir>/Documentation/dvb/get_dvb_firmware tda10045",
+ * "<kerneldir>/Documentation/dvb/get_dvb_firmware tda10046" to
+ * download/extract them, and then copy them to /usr/lib/hotplug/firmware.
  */
+#define TDA10045_DEFAULT_FIRMWARE "dvb-fe-tda10045.fw"
+#define TDA10046_DEFAULT_FIRMWARE "dvb-fe-tda10046.fw"
 
-
-#include <linux/kernel.h>
-#include <linux/vmalloc.h>
-#include <linux/module.h>
 #include <linux/init.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/fcntl.h>
-#include <linux/errno.h>
-#include <linux/syscalls.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
-#ifndef DVB_TDA1004X_FIRMWARE_FILE
-#define DVB_TDA1004X_FIRMWARE_FILE "/usr/lib/hotplug/firmware/tda1004x.bin"
-#endif
-
-static int tda1004x_debug = 0;
-static char *tda1004x_firmware = DVB_TDA1004X_FIRMWARE_FILE;
-
-#define MC44BC374_ADDRESS        0x65
-
-#define TDA1004X_CHIPID          0x00
-#define TDA1004X_AUTO            0x01
-#define TDA1004X_IN_CONF1        0x02
-#define TDA1004X_IN_CONF2        0x03
-#define TDA1004X_OUT_CONF1       0x04
-#define TDA1004X_OUT_CONF2       0x05
-#define TDA1004X_STATUS_CD       0x06
-#define TDA1004X_CONFC4          0x07
-#define TDA1004X_DSSPARE2        0x0C
-#define TDA10045H_CODE_IN        0x0D
-#define TDA10045H_FWPAGE         0x0E
-#define TDA1004X_SCAN_CPT        0x10
-#define TDA1004X_DSP_CMD         0x11
-#define TDA1004X_DSP_ARG         0x12
-#define TDA1004X_DSP_DATA1       0x13
-#define TDA1004X_DSP_DATA2       0x14
-#define TDA1004X_CONFADC1        0x15
-#define TDA1004X_CONFC1          0x16
-#define TDA10045H_S_AGC          0x1a
-#define TDA10046H_AGC_TUN_LEVEL  0x1a
-#define TDA1004X_SNR             0x1c
-#define TDA1004X_CONF_TS1        0x1e
-#define TDA1004X_CONF_TS2        0x1f
-#define TDA1004X_CBER_RESET      0x20
-#define TDA1004X_CBER_MSB        0x21
-#define TDA1004X_CBER_LSB        0x22
-#define TDA1004X_CVBER_LUT       0x23
-#define TDA1004X_VBER_MSB        0x24
-#define TDA1004X_VBER_MID        0x25
-#define TDA1004X_VBER_LSB        0x26
-#define TDA1004X_UNCOR           0x27
-
-#define TDA10045H_CONFPLL_P      0x2D
-#define TDA10045H_CONFPLL_M_MSB  0x2E
-#define TDA10045H_CONFPLL_M_LSB  0x2F
-#define TDA10045H_CONFPLL_N      0x30
-
-#define TDA10046H_CONFPLL1       0x2D
-#define TDA10046H_CONFPLL2       0x2F
-#define TDA10046H_CONFPLL3       0x30
-#define TDA10046H_TIME_WREF1     0x31
-#define TDA10046H_TIME_WREF2     0x32
-#define TDA10046H_TIME_WREF3     0x33
-#define TDA10046H_TIME_WREF4     0x34
-#define TDA10046H_TIME_WREF5     0x35
-
-#define TDA10045H_UNSURW_MSB     0x31
-#define TDA10045H_UNSURW_LSB     0x32
-#define TDA10045H_WREF_MSB       0x33
-#define TDA10045H_WREF_MID       0x34
-#define TDA10045H_WREF_LSB       0x35
-#define TDA10045H_MUXOUT         0x36
-#define TDA1004X_CONFADC2        0x37
+#define FRONTEND_NAME "dvbfe_tda1004x"
 
-#define TDA10045H_IOFFSET        0x38
+#define dprintk(args...) \
+	do { \
+		if (debug) printk(KERN_DEBUG FRONTEND_NAME ": " args); \
+	} while (0)
+
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+#define MC44BC374_ADDRESS	 0x65
+
+#define TDA1004X_CHIPID		 0x00
+#define TDA1004X_AUTO		 0x01
+#define TDA1004X_IN_CONF1	 0x02
+#define TDA1004X_IN_CONF2	 0x03
+#define TDA1004X_OUT_CONF1	 0x04
+#define TDA1004X_OUT_CONF2	 0x05
+#define TDA1004X_STATUS_CD	 0x06
+#define TDA1004X_CONFC4		 0x07
+#define TDA1004X_DSSPARE2	 0x0C
+#define TDA10045H_CODE_IN	 0x0D
+#define TDA10045H_FWPAGE	 0x0E
+#define TDA1004X_SCAN_CPT	 0x10
+#define TDA1004X_DSP_CMD	 0x11
+#define TDA1004X_DSP_ARG	 0x12
+#define TDA1004X_DSP_DATA1	 0x13
+#define TDA1004X_DSP_DATA2	 0x14
+#define TDA1004X_CONFADC1	 0x15
+#define TDA1004X_CONFC1		 0x16
+#define TDA10045H_S_AGC		 0x1a
+#define TDA10046H_AGC_TUN_LEVEL	 0x1a
+#define TDA1004X_SNR		 0x1c
+#define TDA1004X_CONF_TS1	 0x1e
+#define TDA1004X_CONF_TS2	 0x1f
+#define TDA1004X_CBER_RESET	 0x20
+#define TDA1004X_CBER_MSB	 0x21
+#define TDA1004X_CBER_LSB	 0x22
+#define TDA1004X_CVBER_LUT	 0x23
+#define TDA1004X_VBER_MSB	 0x24
+#define TDA1004X_VBER_MID	 0x25
+#define TDA1004X_VBER_LSB	 0x26
+#define TDA1004X_UNCOR		 0x27
+
+#define TDA10045H_CONFPLL_P	 0x2D
+#define TDA10045H_CONFPLL_M_MSB	 0x2E
+#define TDA10045H_CONFPLL_M_LSB	 0x2F
+#define TDA10045H_CONFPLL_N	 0x30
+
+#define TDA10046H_CONFPLL1	 0x2D
+#define TDA10046H_CONFPLL2	 0x2F
+#define TDA10046H_CONFPLL3	 0x30
+#define TDA10046H_TIME_WREF1	 0x31
+#define TDA10046H_TIME_WREF2	 0x32
+#define TDA10046H_TIME_WREF3	 0x33
+#define TDA10046H_TIME_WREF4	 0x34
+#define TDA10046H_TIME_WREF5	 0x35
+
+#define TDA10045H_UNSURW_MSB	 0x31
+#define TDA10045H_UNSURW_LSB	 0x32
+#define TDA10045H_WREF_MSB	 0x33
+#define TDA10045H_WREF_MID	 0x34
+#define TDA10045H_WREF_LSB	 0x35
+#define TDA10045H_MUXOUT	 0x36
+#define TDA1004X_CONFADC2	 0x37
+
+#define TDA10045H_IOFFSET	 0x38
 
 #define TDA10046H_CONF_TRISTATE1 0x3B
 #define TDA10046H_CONF_TRISTATE2 0x3C
-#define TDA10046H_CONF_POLARITY  0x3D
-#define TDA10046H_FREQ_OFFSET    0x3E
-#define TDA10046H_GPIO_OUT_SEL   0x41
-#define TDA10046H_GPIO_SELECT    0x42
-#define TDA10046H_AGC_CONF       0x43
-#define TDA10046H_AGC_GAINS      0x46
-#define TDA10046H_AGC_TUN_MIN    0x47
-#define TDA10046H_AGC_TUN_MAX    0x48
-#define TDA10046H_AGC_IF_MIN     0x49
-#define TDA10046H_AGC_IF_MAX     0x4A
-
-#define TDA10046H_FREQ_PHY2_MSB  0x4D
-#define TDA10046H_FREQ_PHY2_LSB  0x4E
-
-#define TDA10046H_CVBER_CTRL     0x4F
-#define TDA10046H_AGC_IF_LEVEL   0x52
-#define TDA10046H_CODE_CPT       0x57
-#define TDA10046H_CODE_IN        0x58
+#define TDA10046H_CONF_POLARITY	 0x3D
+#define TDA10046H_FREQ_OFFSET	 0x3E
+#define TDA10046H_GPIO_OUT_SEL	 0x41
+#define TDA10046H_GPIO_SELECT	 0x42
+#define TDA10046H_AGC_CONF	 0x43
+#define TDA10046H_AGC_GAINS	 0x46
+#define TDA10046H_AGC_TUN_MIN	 0x47
+#define TDA10046H_AGC_TUN_MAX	 0x48
+#define TDA10046H_AGC_IF_MIN	 0x49
+#define TDA10046H_AGC_IF_MAX	 0x4A
+
+#define TDA10046H_FREQ_PHY2_MSB	 0x4D
+#define TDA10046H_FREQ_PHY2_LSB	 0x4E
+
+#define TDA10046H_CVBER_CTRL	 0x4F
+#define TDA10046H_AGC_IF_LEVEL	 0x52
+#define TDA10046H_CODE_CPT	 0x57
+#define TDA10046H_CODE_IN	 0x58
 
 
 #define FE_TYPE_TDA10045H     0
@@ -139,8 +134,6 @@ static char *tda1004x_firmware = DVB_TDA
 #define TUNER_TYPE_TD1344     0
 #define TUNER_TYPE_TD1316     1
 
-#define dprintk if (tda1004x_debug) printk
-
 static struct dvb_frontend_info tda10045h_info = {
 	.name = "Philips TDA10045H",
 	.type = FE_OFDM,
@@ -155,41 +148,33 @@ static struct dvb_frontend_info tda10045
 };
 
 static struct dvb_frontend_info tda10046h_info = {
-        .name = "Philips TDA10046H",
-        .type = FE_OFDM,
-        .frequency_min = 51000000,
-        .frequency_max = 858000000,
-        .frequency_stepsize = 166667,
-        .caps =
-            FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-            FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
-            FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
-            FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO
+	.name = "Philips TDA10046H",
+	.type = FE_OFDM,
+	.frequency_min = 51000000,
+	.frequency_max = 858000000,
+	.frequency_stepsize = 166667,
+	.caps =
+	    FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+	    FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+	    FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+	    FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO
 };
 
-
 struct tda1004x_state {
 	u8 tda1004x_address;
 	u8 tuner_address;
-	u8 initialised:1;
-        u8 tuner_type:2;
-        u8 fe_type:2;
+	u8 initialised;
+	u8 tuner_type;
+	u8 fe_type;
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+
+	int dspCodeCounterReg;
+	int dspCodeInReg;
+	int dspVersion;
 };
 
-
-struct fwinfo {
-	int file_size;
-	int fw_offset;
-	int fw_size;
-};
-static struct fwinfo tda10045h_fwinfo[] = { {.file_size = 286720,.fw_offset = 0x34cc5,.fw_size = 30555} };
-static int tda10045h_fwinfo_count = sizeof(tda10045h_fwinfo) / sizeof(struct fwinfo);
-
-static struct fwinfo tda10046h_fwinfo[] = { {.file_size = 286720,.fw_offset = 0x3c4f9,.fw_size = 24479} };
-static int tda10046h_fwinfo_count = sizeof(tda10046h_fwinfo) / sizeof(struct fwinfo);
-
-
-static int tda1004x_write_byte(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state, int reg, int data)
+static int tda1004x_write_byte(struct i2c_adapter *i2c, struct tda1004x_state *tda_state, int reg, int data)
 {
 	int ret;
 	u8 buf[] = { reg, data };
@@ -197,35 +182,35 @@ static int tda1004x_write_byte(struct dv
 
 	dprintk("%s: reg=0x%x, data=0x%x\n", __FUNCTION__, reg, data);
 
-        msg.addr = tda_state->tda1004x_address;
-	ret = i2c->xfer(i2c, &msg, 1);
+	msg.addr = tda_state->tda1004x_address;
+	ret = i2c_transfer(i2c, &msg, 1);
 
 	if (ret != 1)
 		dprintk("%s: error reg=0x%x, data=0x%x, ret=%i\n",
-		       __FUNCTION__, reg, data, ret);
+			__FUNCTION__, reg, data, ret);
 
 	dprintk("%s: success reg=0x%x, data=0x%x, ret=%i\n", __FUNCTION__,
 		reg, data, ret);
 	return (ret != 1) ? -1 : 0;
 }
 
-static int tda1004x_read_byte(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state, int reg)
+static int tda1004x_read_byte(struct i2c_adapter *i2c, struct tda1004x_state *tda_state, int reg)
 {
 	int ret;
 	u8 b0[] = { reg };
 	u8 b1[] = { 0 };
 	struct i2c_msg msg[] = {{ .addr=0, .flags=0, .buf=b0, .len=1},
-	                        { .addr=0, .flags=I2C_M_RD, .buf=b1, .len = 1}};
+				{ .addr=0, .flags=I2C_M_RD, .buf=b1, .len = 1}};
 
 	dprintk("%s: reg=0x%x\n", __FUNCTION__, reg);
 
-        msg[0].addr = tda_state->tda1004x_address;
-        msg[1].addr = tda_state->tda1004x_address;
-	ret = i2c->xfer(i2c, msg, 2);
+	msg[0].addr = tda_state->tda1004x_address;
+	msg[1].addr = tda_state->tda1004x_address;
+	ret = i2c_transfer(i2c, msg, 2);
 
 	if (ret != 2) {
 		dprintk("%s: error reg=0x%x, ret=%i\n", __FUNCTION__, reg,
-		       ret);
+			ret);
 		return -1;
 	}
 
@@ -234,9 +219,9 @@ static int tda1004x_read_byte(struct dvb
 	return b1[0];
 }
 
-static int tda1004x_write_mask(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state, int reg, int mask, int data)
+static int tda1004x_write_mask(struct i2c_adapter *i2c, struct tda1004x_state *tda_state, int reg, int mask, int data)
 {
-        int val;
+	int val;
 	dprintk("%s: reg=0x%x, mask=0x%x, data=0x%x\n", __FUNCTION__, reg,
 		mask, data);
 
@@ -253,7 +238,7 @@ static int tda1004x_write_mask(struct dv
 	return tda1004x_write_byte(i2c, tda_state, reg, val);
 }
 
-static int tda1004x_write_buf(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state, int reg, unsigned char *buf, int len)
+static int tda1004x_write_buf(struct i2c_adapter *i2c, struct tda1004x_state *tda_state, int reg, unsigned char *buf, int len)
 {
 	int i;
 	int result;
@@ -270,357 +255,312 @@ static int tda1004x_write_buf(struct dvb
 	return result;
 }
 
-static int tda1004x_enable_tuner_i2c(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state)
+static int tda1004x_enable_tuner_i2c(struct i2c_adapter *i2c, struct tda1004x_state *tda_state)
 {
-        int result;
+	int result;
 	dprintk("%s\n", __FUNCTION__);
 
 	result = tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 2, 2);
-	dvb_delay(1);
+	msleep(1);
 	return result;
 }
 
-static int tda1004x_disable_tuner_i2c(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state)
+static int tda1004x_disable_tuner_i2c(struct i2c_adapter *i2c, struct tda1004x_state *tda_state)
 {
-
 	dprintk("%s\n", __FUNCTION__);
 
 	return tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 2, 0);
 }
 
+static int tda10045h_set_bandwidth(struct i2c_adapter *i2c,
+				   struct tda1004x_state *tda_state,
+				   fe_bandwidth_t bandwidth)
+{
+	static u8 bandwidth_6mhz[] = { 0x02, 0x00, 0x3d, 0x00, 0x60, 0x1e, 0xa7, 0x45, 0x4f };
+	static u8 bandwidth_7mhz[] = { 0x02, 0x00, 0x37, 0x00, 0x4a, 0x2f, 0x6d, 0x76, 0xdb };
+	static u8 bandwidth_8mhz[] = { 0x02, 0x00, 0x3d, 0x00, 0x48, 0x17, 0x89, 0xc7, 0x14 };
 
-static int tda10045h_set_bandwidth(struct dvb_i2c_bus *i2c,
-	                           struct tda1004x_state *tda_state,
-		                   fe_bandwidth_t bandwidth)
-{
-        static u8 bandwidth_6mhz[] = { 0x02, 0x00, 0x3d, 0x00, 0x60, 0x1e, 0xa7, 0x45, 0x4f };
-        static u8 bandwidth_7mhz[] = { 0x02, 0x00, 0x37, 0x00, 0x4a, 0x2f, 0x6d, 0x76, 0xdb };
-        static u8 bandwidth_8mhz[] = { 0x02, 0x00, 0x3d, 0x00, 0x48, 0x17, 0x89, 0xc7, 0x14 };
-
-        switch (bandwidth) {
+	switch (bandwidth) {
 	case BANDWIDTH_6_MHZ:
 		tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0x14);
-                tda1004x_write_buf(i2c, tda_state, TDA10045H_CONFPLL_P, bandwidth_6mhz, sizeof(bandwidth_6mhz));
+		tda1004x_write_buf(i2c, tda_state, TDA10045H_CONFPLL_P, bandwidth_6mhz, sizeof(bandwidth_6mhz));
 		break;
 
 	case BANDWIDTH_7_MHZ:
 		tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0x80);
-                tda1004x_write_buf(i2c, tda_state, TDA10045H_CONFPLL_P, bandwidth_7mhz, sizeof(bandwidth_7mhz));
+		tda1004x_write_buf(i2c, tda_state, TDA10045H_CONFPLL_P, bandwidth_7mhz, sizeof(bandwidth_7mhz));
 		break;
 
 	case BANDWIDTH_8_MHZ:
 		tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0x14);
-                tda1004x_write_buf(i2c, tda_state, TDA10045H_CONFPLL_P, bandwidth_8mhz, sizeof(bandwidth_8mhz));
+		tda1004x_write_buf(i2c, tda_state, TDA10045H_CONFPLL_P, bandwidth_8mhz, sizeof(bandwidth_8mhz));
 		break;
 
 	default:
 		return -EINVAL;
 	}
 
-        tda1004x_write_byte(i2c, tda_state, TDA10045H_IOFFSET, 0);
+	tda1004x_write_byte(i2c, tda_state, TDA10045H_IOFFSET, 0);
 
-        // done
-        return 0;
+	return 0;
 }
 
+static int tda10046h_set_bandwidth(struct i2c_adapter *i2c,
+				   struct tda1004x_state *tda_state,
+				   fe_bandwidth_t bandwidth)
+{
+	static u8 bandwidth_6mhz[] = { 0x80, 0x15, 0xfe, 0xab, 0x8e };
+	static u8 bandwidth_7mhz[] = { 0x6e, 0x02, 0x53, 0xc8, 0x25 };
+	static u8 bandwidth_8mhz[] = { 0x60, 0x12, 0xa8, 0xe4, 0xbd };
 
-static int tda10046h_set_bandwidth(struct dvb_i2c_bus *i2c,
-                                   struct tda1004x_state *tda_state,
-                                   fe_bandwidth_t bandwidth)
-{
-        static u8 bandwidth_6mhz[] = { 0x80, 0x15, 0xfe, 0xab, 0x8e };
-        static u8 bandwidth_7mhz[] = { 0x6e, 0x02, 0x53, 0xc8, 0x25 };
-        static u8 bandwidth_8mhz[] = { 0x60, 0x12, 0xa8, 0xe4, 0xbd };
-
-        switch (bandwidth) {
-        case BANDWIDTH_6_MHZ:
-                tda1004x_write_buf(i2c, tda_state, TDA10046H_TIME_WREF1, bandwidth_6mhz, sizeof(bandwidth_6mhz));
-                tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0);
-                break;
+	switch (bandwidth) {
+	case BANDWIDTH_6_MHZ:
+		tda1004x_write_buf(i2c, tda_state, TDA10046H_TIME_WREF1, bandwidth_6mhz, sizeof(bandwidth_6mhz));
+		tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0);
+		break;
 
-        case BANDWIDTH_7_MHZ:
-                tda1004x_write_buf(i2c, tda_state, TDA10046H_TIME_WREF1, bandwidth_7mhz, sizeof(bandwidth_7mhz));
-                tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0);
-                break;
+	case BANDWIDTH_7_MHZ:
+		tda1004x_write_buf(i2c, tda_state, TDA10046H_TIME_WREF1, bandwidth_7mhz, sizeof(bandwidth_7mhz));
+		tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0);
+		break;
 
-        case BANDWIDTH_8_MHZ:
-                tda1004x_write_buf(i2c, tda_state, TDA10046H_TIME_WREF1, bandwidth_8mhz, sizeof(bandwidth_8mhz));
-                tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0xFF);
-                break;
+	case BANDWIDTH_8_MHZ:
+		tda1004x_write_buf(i2c, tda_state, TDA10046H_TIME_WREF1, bandwidth_8mhz, sizeof(bandwidth_8mhz));
+		tda1004x_write_byte(i2c, tda_state, TDA1004X_DSSPARE2, 0xFF);
+		break;
 
-        default:
-                return -EINVAL;
-        }
+	default:
+		return -EINVAL;
+	}
 
-        // done
-        return 0;
+	return 0;
 }
 
-
-static int tda1004x_fwupload(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state)
+static int tda1004x_do_upload(struct i2c_adapter *i2c, struct tda1004x_state *state, unsigned char *mem, unsigned int len)
 {
-	u8 fw_buf[65];
-	struct i2c_msg fw_msg = {.addr = 0,.flags = 0,.buf = fw_buf,.len = 0 };
-	unsigned char *firmware = NULL;
-	int filesize;
-	int fd;
-	int fwinfo_idx;
-	int fw_size = 0;
-        int fw_pos, fw_offset;
+	u8 buf[65];
+	struct i2c_msg fw_msg = {.addr = 0,.flags = 0,.buf = buf,.len = 0 };
 	int tx_size;
-	mm_segment_t fs = get_fs();
-        int dspCodeCounterReg=0, dspCodeInReg=0, dspVersion=0;
-        int fwInfoCount=0;
-        struct fwinfo* fwInfo = NULL;
-        unsigned long timeout;
-
-        // DSP parameters
-        switch(tda_state->fe_type) {
-        case FE_TYPE_TDA10045H:
-                dspCodeCounterReg = TDA10045H_FWPAGE;
-                dspCodeInReg = TDA10045H_CODE_IN;
-                dspVersion = 0x2c;
-                fwInfoCount = tda10045h_fwinfo_count;
-                fwInfo = tda10045h_fwinfo;
-                break;
-
-        case FE_TYPE_TDA10046H:
-                dspCodeCounterReg = TDA10046H_CODE_CPT;
-                dspCodeInReg = TDA10046H_CODE_IN;
-                dspVersion = 0x20;
-                fwInfoCount = tda10046h_fwinfo_count;
-                fwInfo = tda10046h_fwinfo;
-                break;
-        }
-
-	// Load the firmware
-	set_fs(get_ds());
-	fd = sys_open(tda1004x_firmware, 0, 0);
-	if (fd < 0) {
-		printk("%s: Unable to open firmware %s\n", __FUNCTION__,
-		       tda1004x_firmware);
-		return -EIO;
-	}
-	filesize = sys_lseek(fd, 0L, 2);
-	if (filesize <= 0) {
-		printk("%s: Firmware %s is empty\n", __FUNCTION__,
-		       tda1004x_firmware);
-		sys_close(fd);
-		return -EIO;
-	}
-
-        // find extraction parameters for firmware
-        for (fwinfo_idx = 0; fwinfo_idx < fwInfoCount; fwinfo_idx++) {
-                if (fwInfo[fwinfo_idx].file_size == filesize)
-			break;
-	}
-        if (fwinfo_idx >= fwInfoCount) {
-		printk("%s: Unsupported firmware %s\n", __FUNCTION__, tda1004x_firmware);
-		sys_close(fd);
-		return -EIO;
-	}
-        fw_size = fwInfo[fwinfo_idx].fw_size;
-        fw_offset = fwInfo[fwinfo_idx].fw_offset;
-
-	// allocate buffer for it
-	firmware = vmalloc(fw_size);
-	if (firmware == NULL) {
-		printk("%s: Out of memory loading firmware\n",
-		       __FUNCTION__);
-		sys_close(fd);
-		return -EIO;
-	}
+	int pos = 0;
 
-	// read it!
-	sys_lseek(fd, fw_offset, 0);
-	if (sys_read(fd, firmware, fw_size) != fw_size) {
-		printk("%s: Failed to read firmware\n", __FUNCTION__);
-		vfree(firmware);
-		sys_close(fd);
-		return -EIO;
-	}
-	sys_close(fd);
-	set_fs(fs);
+	/* clear code counter */
+	tda1004x_write_byte(i2c, state, state->dspCodeCounterReg, 0);
+	fw_msg.addr = state->tda1004x_address;
 
-        // set some valid bandwith parameters before uploading
-        switch(tda_state->fe_type) {
-        case FE_TYPE_TDA10045H:
-                // reset chip
-		tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 0x10, 0);
-                tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 8, 8);
-                tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 8, 0);
-                dvb_delay(10);
-
-                // set parameters
-                tda10045h_set_bandwidth(i2c, tda_state, BANDWIDTH_8_MHZ);
-                break;
-
-        case FE_TYPE_TDA10046H:
-                // reset chip
-		tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 1, 0);
-                tda1004x_write_mask(i2c, tda_state, TDA10046H_CONF_TRISTATE1, 1, 0);
-                dvb_delay(10);
-
-                // set parameters
-                tda1004x_write_byte(i2c, tda_state, TDA10046H_CONFPLL2, 10);
-                tda1004x_write_byte(i2c, tda_state, TDA10046H_CONFPLL3, 0);
-                tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_OFFSET, 99);
-                tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_PHY2_MSB, 0xd4);
-                tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_PHY2_LSB, 0x2c);
-                tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 8, 8); // going to boot from HOST
-                break;
-        }
-
-	// do the firmware upload
-        tda1004x_write_byte(i2c, tda_state, dspCodeCounterReg, 0); // clear code counter
-        fw_msg.addr = tda_state->tda1004x_address;
-	fw_pos = 0;
-	while (fw_pos != fw_size) {
+	buf[0] = state->dspCodeInReg;
+	while (pos != len) {
 
 		// work out how much to send this time
-		tx_size = fw_size - fw_pos;
-                if (tx_size > 0x10) {
-                        tx_size = 0x10;
+		tx_size = len - pos;
+		if (tx_size > 0x10) {
+			tx_size = 0x10;
 		}
 
 		// send the chunk
-                fw_buf[0] = dspCodeInReg;
-		memcpy(fw_buf + 1, firmware + fw_pos, tx_size);
+		memcpy(buf + 1, mem + pos, tx_size);
 		fw_msg.len = tx_size + 1;
-		if (i2c->xfer(i2c, &fw_msg, 1) != 1) {
-                        printk("tda1004x: Error during firmware upload\n");
-			vfree(firmware);
+		if (i2c_transfer(i2c, &fw_msg, 1) != 1) {
+			printk("tda1004x: Error during firmware upload\n");
 			return -EIO;
 		}
-		fw_pos += tx_size;
+		pos += tx_size;
 
-		dprintk("%s: fw_pos=0x%x\n", __FUNCTION__, fw_pos);
+		dprintk("%s: fw_pos=0x%x\n", __FUNCTION__, pos);
 	}
-	vfree(firmware);
+	return 0;
+}
 
-        // wait for DSP to initialise
-        switch(tda_state->fe_type) {
-        case FE_TYPE_TDA10045H:
-                // DSPREADY doesn't seem to work on the TDA10045H
-                dvb_delay(100);
-                break;
-
-        case FE_TYPE_TDA10046H:
-                timeout = jiffies + HZ;
-                while(!(tda1004x_read_byte(i2c, tda_state, TDA1004X_STATUS_CD) & 0x20)) {
-                        if (time_after(jiffies, timeout)) {
-                                printk("tda1004x: DSP failed to initialised.\n");
-                                return -EIO;
-                        }
-
-                        dvb_delay(1);
-                }
-                break;
-        }
-
-        // check upload was OK
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 0x10, 0); // we want to read from the DSP
-	tda1004x_write_byte(i2c, tda_state, TDA1004X_DSP_CMD, 0x67);
-	if ((tda1004x_read_byte(i2c, tda_state, TDA1004X_DSP_DATA1) != 0x67) ||
-            (tda1004x_read_byte(i2c, tda_state, TDA1004X_DSP_DATA2) != dspVersion)) {
-		printk("%s: firmware upload failed!\n", __FUNCTION__);
+static int tda1004x_check_upload_ok(struct i2c_adapter *i2c, struct tda1004x_state *state)
+{
+	u8 data1, data2;
+
+	// check upload was OK
+	tda1004x_write_mask(i2c, state, TDA1004X_CONFC4, 0x10, 0); // we want to read from the DSP
+	tda1004x_write_byte(i2c, state, TDA1004X_DSP_CMD, 0x67);
+
+	data1 = tda1004x_read_byte(i2c, state, TDA1004X_DSP_DATA1);
+	data2 = tda1004x_read_byte(i2c, state, TDA1004X_DSP_DATA2);
+	if (data1 != 0x67 || data2 != state->dspVersion) {
+		printk("tda1004x: firmware upload failed!\n");
 		return -EIO;
 	}
 
-        // success
-        return 0;
+	return 0;
 }
 
 
-static int tda10045h_init(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state)
+static int tda10045_fwupload(struct i2c_adapter *i2c, struct tda1004x_state *state, struct i2c_client *client)
 {
-        struct i2c_msg tuner_msg = {.addr = 0,.flags = 0,.buf = NULL,.len = 0 };
-        static u8 disable_mc44BC374c[] = { 0x1d, 0x74, 0xa0, 0x68 };
+	int ret;
+	const struct firmware *fw;
 
-        dprintk("%s\n", __FUNCTION__);
+	/* request the firmware, this will block until someone uploads it */
+	printk("tda1004x: waiting for firmware upload...\n");
+	ret = request_firmware(&fw, TDA10045_DEFAULT_FIRMWARE, &client->dev);
+	if (ret) {
+		printk("tda1004x: no firmware upload (timeout or file not found?)\n");
+	   	return ret;
+	}
+   
+	/* set some valid bandwith parameters before uploading */
+
+	/* reset chip */
+	tda1004x_write_mask(i2c, state, TDA1004X_CONFC4, 0x10, 0);
+	tda1004x_write_mask(i2c, state, TDA1004X_CONFC4, 8, 8);
+	tda1004x_write_mask(i2c, state, TDA1004X_CONFC4, 8, 0);
+	msleep(10);
+
+	/* set parameters */
+	tda10045h_set_bandwidth(i2c, state, BANDWIDTH_8_MHZ);
+
+	ret = tda1004x_do_upload(i2c, state, fw->data, fw->size);
+	if (ret)
+		return ret;
+
+	/* wait for DSP to initialise */
+	/* DSPREADY doesn't seem to work on the TDA10045H */
+	msleep(100);
+
+	ret = tda1004x_check_upload_ok(i2c, state);
+	if (ret)
+		return ret;
 
-	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFADC1, 0x10, 0); // wake up the ADC
+	return 0;
+}
+
+static int tda10046_fwupload(struct i2c_adapter *i2c, struct tda1004x_state *state, struct i2c_client *client)
+{
+	unsigned long timeout;
+	int ret;
+	const struct firmware *fw;
 
-        // Disable the MC44BC374C
-        tda1004x_enable_tuner_i2c(i2c, tda_state);
-        tuner_msg.addr = MC44BC374_ADDRESS;
-        tuner_msg.buf = disable_mc44BC374c;
-        tuner_msg.len = sizeof(disable_mc44BC374c);
-        if (i2c->xfer(i2c, &tuner_msg, 1) != 1) {
-                i2c->xfer(i2c, &tuner_msg, 1);
-        }
-        tda1004x_disable_tuner_i2c(i2c, tda_state);
+	/* request the firmware, this will block until someone uploads it */
+	printk("tda1004x: waiting for firmware upload...\n");
+	ret = request_firmware(&fw, TDA10046_DEFAULT_FIRMWARE, &client->dev);
+	if (ret) {
+		printk("tda1004x: no firmware upload (timeout or file not found?)\n");
+   	   	return ret;
+	}
+
+	/* set some valid bandwith parameters before uploading */
+
+	/* reset chip */
+	tda1004x_write_mask(i2c, state, TDA1004X_CONFC4, 1, 0);
+	tda1004x_write_mask(i2c, state, TDA10046H_CONF_TRISTATE1, 1, 0);
+	msleep(10);
+
+	/* set parameters */
+	tda1004x_write_byte(i2c, state, TDA10046H_CONFPLL2, 10);
+	tda1004x_write_byte(i2c, state, TDA10046H_CONFPLL3, 0);
+	tda1004x_write_byte(i2c, state, TDA10046H_FREQ_OFFSET, 99);
+	tda1004x_write_byte(i2c, state, TDA10046H_FREQ_PHY2_MSB, 0xd4);
+	tda1004x_write_byte(i2c, state, TDA10046H_FREQ_PHY2_LSB, 0x2c);
+	tda1004x_write_mask(i2c, state, TDA1004X_CONFC4, 8, 8); // going to boot from HOST
+
+	ret = tda1004x_do_upload(i2c, state, fw->data, fw->size);
+	if (ret)
+		return ret;
+
+	/* wait for DSP to initialise */
+	timeout = jiffies + HZ;
+	while(!(tda1004x_read_byte(i2c, state, TDA1004X_STATUS_CD) & 0x20)) {
+		if (time_after(jiffies, timeout)) {
+			printk("tda1004x: DSP failed to initialised.\n");
+			return -EIO;
+		}
+		msleep(1);
+	}
 
-	// tda setup
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 0x20, 0); // disable DSP watchdog timer
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 8, 0); // select HP stream
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x40, 0); // no frequency inversion
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x80, 0x80); // enable pulse killer
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 0x10, 0x10); // enable auto offset
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF2, 0xC0, 0x0); // no frequency offset
-        tda1004x_write_byte(i2c, tda_state, TDA1004X_CONF_TS1, 0); // setup MPEG2 TS interface
-        tda1004x_write_byte(i2c, tda_state, TDA1004X_CONF_TS2, 0); // setup MPEG2 TS interface
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_VBER_MSB, 0xe0, 0xa0); // 10^6 VBER measurement bits
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x10, 0); // VAGC polarity
-        tda1004x_write_byte(i2c, tda_state, TDA1004X_CONFADC1, 0x2e);
+	ret = tda1004x_check_upload_ok(i2c, state);
+	if (ret)
+		return ret;
 
-	// done
 	return 0;
 }
 
+static int tda10045h_init(struct i2c_adapter *i2c, struct tda1004x_state *tda_state)
+{
+	struct i2c_msg tuner_msg = {.addr = 0,.flags = 0,.buf = NULL,.len = 0 };
+	static u8 disable_mc44BC374c[] = { 0x1d, 0x74, 0xa0, 0x68 };
+
+	dprintk("%s\n", __FUNCTION__);
+
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFADC1, 0x10, 0); // wake up the ADC
+
+	// Disable the MC44BC374C
+	tda1004x_enable_tuner_i2c(i2c, tda_state);
+	tuner_msg.addr = MC44BC374_ADDRESS;
+	tuner_msg.buf = disable_mc44BC374c;
+	tuner_msg.len = sizeof(disable_mc44BC374c);
+	if (i2c_transfer(i2c, &tuner_msg, 1) != 1) {
+		i2c_transfer(i2c, &tuner_msg, 1);
+	}
+	tda1004x_disable_tuner_i2c(i2c, tda_state);
+
+	// tda setup
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 0x20, 0); // disable DSP watchdog timer
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 8, 0); // select HP stream
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x40, 0); // no frequency inversion
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x80, 0x80); // enable pulse killer
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 0x10, 0x10); // enable auto offset
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF2, 0xC0, 0x0); // no frequency offset
+	tda1004x_write_byte(i2c, tda_state, TDA1004X_CONF_TS1, 0); // setup MPEG2 TS interface
+	tda1004x_write_byte(i2c, tda_state, TDA1004X_CONF_TS2, 0); // setup MPEG2 TS interface
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_VBER_MSB, 0xe0, 0xa0); // 10^6 VBER measurement bits
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x10, 0); // VAGC polarity
+	tda1004x_write_byte(i2c, tda_state, TDA1004X_CONFADC1, 0x2e);
 
+	return 0;
+}
 
-static int tda10046h_init(struct dvb_i2c_bus *i2c, struct tda1004x_state *tda_state)
+static int tda10046h_init(struct i2c_adapter *i2c, struct tda1004x_state *tda_state)
 {
-        struct i2c_msg tuner_msg = {.addr = 0,.flags = 0,.buf = NULL,.len = 0 };
-        static u8 disable_mc44BC374c[] = { 0x1d, 0x74, 0xa0, 0x68 };
+	struct i2c_msg tuner_msg = {.addr = 0,.flags = 0,.buf = NULL,.len = 0 };
+	static u8 disable_mc44BC374c[] = { 0x1d, 0x74, 0xa0, 0x68 };
 
-        dprintk("%s\n", __FUNCTION__);
+	dprintk("%s\n", __FUNCTION__);
 
 	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 1, 0); // wake up the chip
 
-        // Disable the MC44BC374C
-        tda1004x_enable_tuner_i2c(i2c, tda_state);
-        tuner_msg.addr = MC44BC374_ADDRESS;
-        tuner_msg.buf = disable_mc44BC374c;
-        tuner_msg.len = sizeof(disable_mc44BC374c);
-        if (i2c->xfer(i2c, &tuner_msg, 1) != 1) {
-                i2c->xfer(i2c, &tuner_msg, 1);
-        }
-        tda1004x_disable_tuner_i2c(i2c, tda_state);
-
-        // tda setup
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 0x20, 0); // disable DSP watchdog timer
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x40, 0x40); // TT TDA10046H needs inversion ON
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 8, 0); // select HP stream
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x80, 0); // disable pulse killer
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_CONFPLL2, 10); // PLL M = 10
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_CONFPLL3, 0); // PLL P = N = 0
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_OFFSET, 99); // FREQOFFS = 99
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_PHY2_MSB, 0xd4); // } PHY2 = -11221
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_PHY2_LSB, 0x2c); // }
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_CONF, 0); // AGC setup
-        tda1004x_write_mask(i2c, tda_state, TDA10046H_CONF_POLARITY, 0x60, 0x60); // set AGC polarities
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_TUN_MIN, 0);    // }
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_TUN_MAX, 0xff); // } AGC min/max values
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_IF_MIN, 0);     // }
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_IF_MAX, 0xff);  // }
-        tda1004x_write_mask(i2c, tda_state, TDA10046H_CVBER_CTRL, 0x30, 0x10); // 10^6 VBER measurement bits
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_GAINS, 1); // IF gain 2, TUN gain 1
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 0x80, 0); // crystal is 50ppm
-        tda1004x_write_byte(i2c, tda_state, TDA1004X_CONF_TS1, 7); // MPEG2 interface config
-        tda1004x_write_mask(i2c, tda_state, TDA1004X_CONF_TS2, 0x31, 0); // MPEG2 interface config
-        tda1004x_write_mask(i2c, tda_state, TDA10046H_CONF_TRISTATE1, 0x9e, 0); // disable AGC_TUN
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_CONF_TRISTATE2, 0xe1); // tristate setup
-        tda1004x_write_byte(i2c, tda_state, TDA10046H_GPIO_OUT_SEL, 0xcc); // GPIO output config
-        tda1004x_write_mask(i2c, tda_state, TDA10046H_GPIO_SELECT, 8, 8); // GPIO select
-        tda10046h_set_bandwidth(i2c, tda_state, BANDWIDTH_8_MHZ); // default bandwidth 8 MHz
-
-        // done
-        return 0;
-}
+	// Disable the MC44BC374C
+	tda1004x_enable_tuner_i2c(i2c, tda_state);
+	tuner_msg.addr = MC44BC374_ADDRESS;
+	tuner_msg.buf = disable_mc44BC374c;
+	tuner_msg.len = sizeof(disable_mc44BC374c);
+	if (i2c_transfer(i2c, &tuner_msg, 1) != 1) {
+		i2c_transfer(i2c, &tuner_msg, 1);
+	}
+	tda1004x_disable_tuner_i2c(i2c, tda_state);
 
+	// tda setup
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 0x20, 0); // disable DSP watchdog timer
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x40, 0x40); // TT TDA10046H needs inversion ON
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 8, 0); // select HP stream
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x80, 0); // disable pulse killer
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_CONFPLL2, 10); // PLL M = 10
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_CONFPLL3, 0); // PLL P = N = 0
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_OFFSET, 99); // FREQOFFS = 99
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_PHY2_MSB, 0xd4); // } PHY2 = -11221
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_FREQ_PHY2_LSB, 0x2c); // }
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_CONF, 0); // AGC setup
+	tda1004x_write_mask(i2c, tda_state, TDA10046H_CONF_POLARITY, 0x60, 0x60); // set AGC polarities
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_TUN_MIN, 0);	  // }
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_TUN_MAX, 0xff); // } AGC min/max values
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_IF_MIN, 0);	  // }
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_IF_MAX, 0xff);  // }
+	tda1004x_write_mask(i2c, tda_state, TDA10046H_CVBER_CTRL, 0x30, 0x10); // 10^6 VBER measurement bits
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_AGC_GAINS, 1); // IF gain 2, TUN gain 1
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 0x80, 0); // crystal is 50ppm
+	tda1004x_write_byte(i2c, tda_state, TDA1004X_CONF_TS1, 7); // MPEG2 interface config
+	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONF_TS2, 0x31, 0); // MPEG2 interface config
+	tda1004x_write_mask(i2c, tda_state, TDA10046H_CONF_TRISTATE1, 0x9e, 0); // disable AGC_TUN
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_CONF_TRISTATE2, 0xe1); // tristate setup
+	tda1004x_write_byte(i2c, tda_state, TDA10046H_GPIO_OUT_SEL, 0xcc); // GPIO output config
+	tda1004x_write_mask(i2c, tda_state, TDA10046H_GPIO_SELECT, 8, 8); // GPIO select
+	tda10046h_set_bandwidth(i2c, tda_state, BANDWIDTH_8_MHZ); // default bandwidth 8 MHz
 
+	return 0;
+}
 
 static int tda1004x_encode_fec(int fec)
 {
@@ -662,26 +602,26 @@ static int tda1004x_decode_fec(int tdafe
 	return -1;
 }
 
-static int tda1004x_set_frequency(struct dvb_i2c_bus *i2c,
-			   struct tda1004x_state *tda_state,
-			   struct dvb_frontend_parameters *fe_params)
+static int tda1004x_set_frequency(struct i2c_adapter *i2c,
+				  struct tda1004x_state *tda_state,
+				  struct dvb_frontend_parameters *fe_params)
 {
 	u8 tuner_buf[4];
 	struct i2c_msg tuner_msg = {.addr=0, .flags=0, .buf=tuner_buf, .len=sizeof(tuner_buf) };
-        int tuner_frequency = 0;
-        u8 band, cp, filter;
+	int tuner_frequency = 0;
+	u8 band, cp, filter;
 	int counter, counter2;
 
 	dprintk("%s\n", __FUNCTION__);
 
 	// setup the frequency buffer
-        switch (tda_state->tuner_type) {
-        case TUNER_TYPE_TD1344:
+	switch (tda_state->tuner_type) {
+	case TUNER_TYPE_TD1344:
 
 		// setup tuner buffer
-                // ((Fif+((1000000/6)/2)) + Finput)/(1000000/6)
+		// ((Fif+((1000000/6)/2)) + Finput)/(1000000/6)
 		tuner_frequency =
-                        (((fe_params->frequency / 1000) * 6) + 217502) / 1000;
+			(((fe_params->frequency / 1000) * 6) + 217502) / 1000;
 		tuner_buf[0] = tuner_frequency >> 8;
 		tuner_buf[1] = tuner_frequency & 0xff;
 		tuner_buf[2] = 0x88;
@@ -695,7 +635,7 @@ static int tda1004x_set_frequency(struct
 		tda1004x_enable_tuner_i2c(i2c, tda_state);
 		tuner_msg.addr = tda_state->tuner_address;
 		tuner_msg.len = 4;
-		i2c->xfer(i2c, &tuner_msg, 1);
+		i2c_transfer(i2c, &tuner_msg, 1);
 
 		// wait for it to finish
 		tuner_msg.len = 1;
@@ -703,7 +643,7 @@ static int tda1004x_set_frequency(struct
 		counter = 0;
 		counter2 = 0;
 		while (counter++ < 100) {
-			if (i2c->xfer(i2c, &tuner_msg, 1) == 1) {
+			if (i2c_transfer(i2c, &tuner_msg, 1) == 1) {
 				if (tuner_buf[0] & 0x40) {
 					counter2++;
 				} else {
@@ -718,13 +658,13 @@ static int tda1004x_set_frequency(struct
 		tda1004x_disable_tuner_i2c(i2c, tda_state);
 		break;
 
-        case TUNER_TYPE_TD1316:
+	case TUNER_TYPE_TD1316:
 		// determine charge pump
 		tuner_frequency = fe_params->frequency + 36130000;
 		if (tuner_frequency < 87000000) {
 			return -EINVAL;
 		} else if (tuner_frequency < 130000000) {
-                        cp = 3;
+			cp = 3;
 		} else if (tuner_frequency < 160000000) {
 			cp = 5;
 		} else if (tuner_frequency < 200000000) {
@@ -747,9 +687,9 @@ static int tda1004x_set_frequency(struct
 
 		// determine band
 		if (fe_params->frequency < 49000000) {
-                        return -EINVAL;
+			return -EINVAL;
 		} else if (fe_params->frequency < 159000000) {
-                        band = 1;
+			band = 1;
 		} else if (fe_params->frequency < 444000000) {
 			band = 2;
 		} else if (fe_params->frequency < 861000000) {
@@ -761,10 +701,10 @@ static int tda1004x_set_frequency(struct
 		// work out filter
 		switch (fe_params->u.ofdm.bandwidth) {
 		case BANDWIDTH_6_MHZ:
-                        filter = 0;
-                        break;
+			filter = 0;
+			break;
 
-                case BANDWIDTH_7_MHZ:
+		case BANDWIDTH_7_MHZ:
 			filter = 0;
 			break;
 
@@ -776,37 +716,37 @@ static int tda1004x_set_frequency(struct
 			return -EINVAL;
 		}
 
-                // calculate divisor
-                // ((36130000+((1000000/6)/2)) + Finput)/(1000000/6)
+		// calculate divisor
+		// ((36130000+((1000000/6)/2)) + Finput)/(1000000/6)
 		tuner_frequency =
-                        (((fe_params->frequency / 1000) * 6) + 217280) / 1000;
+		      (((fe_params->frequency / 1000) * 6) + 217280) / 1000;
 
-                // setup tuner buffer
+		// setup tuner buffer
 		tuner_buf[0] = tuner_frequency >> 8;
 		tuner_buf[1] = tuner_frequency & 0xff;
 		tuner_buf[2] = 0xca;
 		tuner_buf[3] = (cp << 5) | (filter << 3) | band;
 
 		// tune it
-                if (tda_state->fe_type == FE_TYPE_TDA10046H) {
-                        // setup auto offset
-                        tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 0x10, 0x10);
-                        tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF1, 0x80, 0);
-                        tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF2, 0xC0, 0);
-
-                        // disable agc_conf[2]
-                        tda1004x_write_mask(i2c, tda_state, TDA10046H_AGC_CONF, 4, 0);
-                }
+		if (tda_state->fe_type == FE_TYPE_TDA10046H) {
+			// setup auto offset
+			tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 0x10, 0x10);
+			tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF1, 0x80, 0);
+			tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF2, 0xC0, 0);
+
+			// disable agc_conf[2]
+			tda1004x_write_mask(i2c, tda_state, TDA10046H_AGC_CONF, 4, 0);
+		}
 		tda1004x_enable_tuner_i2c(i2c, tda_state);
 		tuner_msg.addr = tda_state->tuner_address;
 		tuner_msg.len = 4;
-                if (i2c->xfer(i2c, &tuner_msg, 1) != 1) {
+		if (i2c_transfer(i2c, &tuner_msg, 1) != 1) {
 			return -EIO;
 		}
-		dvb_delay(1);
+		msleep(1);
 		tda1004x_disable_tuner_i2c(i2c, tda_state);
-                if (tda_state->fe_type == FE_TYPE_TDA10046H)
-                        tda1004x_write_mask(i2c, tda_state, TDA10046H_AGC_CONF, 4, 4);
+		if (tda_state->fe_type == FE_TYPE_TDA10046H)
+			tda1004x_write_mask(i2c, tda_state, TDA10046H_AGC_CONF, 4, 4);
 		break;
 
 	default:
@@ -815,27 +755,28 @@ static int tda1004x_set_frequency(struct
 
 	dprintk("%s: success\n", __FUNCTION__);
 
-	// done
 	return 0;
 }
 
-static int tda1004x_set_fe(struct dvb_i2c_bus *i2c,
-	 	           struct tda1004x_state *tda_state,
-		           struct dvb_frontend_parameters *fe_params)
+static int tda1004x_set_fe(struct i2c_adapter *i2c,
+			   struct tda1004x_state *tda_state,
+			   struct dvb_frontend_parameters *fe_params)
 {
 	int tmp;
-        int inversion;
+	int inversion;
 
 	dprintk("%s\n", __FUNCTION__);
 
 	// set frequency
-        if ((tmp = tda1004x_set_frequency(i2c, tda_state, fe_params)) < 0)
+	if ((tmp = tda1004x_set_frequency(i2c, tda_state, fe_params)) < 0)
 		return tmp;
 
-        // hardcoded to use auto as much as possible
-        fe_params->u.ofdm.code_rate_HP = FEC_AUTO;
-        fe_params->u.ofdm.guard_interval = GUARD_INTERVAL_AUTO;
-        fe_params->u.ofdm.transmission_mode = TRANSMISSION_MODE_AUTO;
+	// Hardcoded to use auto as much as possible
+	// The TDA10045 is very unreliable if AUTO mode is _not_ used. I have not
+	// yet tested the TDA10046 to see if this issue has been fixed
+	fe_params->u.ofdm.code_rate_HP = FEC_AUTO;
+	fe_params->u.ofdm.guard_interval = GUARD_INTERVAL_AUTO;
+	fe_params->u.ofdm.transmission_mode = TRANSMISSION_MODE_AUTO;
 
 	// Set standard params.. or put them to auto
 	if ((fe_params->u.ofdm.code_rate_HP == FEC_AUTO) ||
@@ -855,11 +796,9 @@ static int tda1004x_set_fe(struct dvb_i2
 		tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF2, 7, tmp);
 
 		// set LP FEC
-		if (fe_params->u.ofdm.code_rate_LP != FEC_NONE) {
-			tmp = tda1004x_encode_fec(fe_params->u.ofdm.code_rate_LP);
-			if (tmp < 0) return tmp;
-			tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF2, 0x38, tmp << 3);
-		}
+		tmp = tda1004x_encode_fec(fe_params->u.ofdm.code_rate_LP);
+		if (tmp < 0) return tmp;
+		tda1004x_write_mask(i2c, tda_state, TDA1004X_IN_CONF2, 0x38, tmp << 3);
 
 		// set constellation
 		switch (fe_params->u.ofdm.constellation) {
@@ -902,25 +841,25 @@ static int tda1004x_set_fe(struct dvb_i2
 		}
 	}
 
-        // set bandwidth
-        switch(tda_state->fe_type) {
-        case FE_TYPE_TDA10045H:
-                tda10045h_set_bandwidth(i2c, tda_state, fe_params->u.ofdm.bandwidth);
-                break;
-
-        case FE_TYPE_TDA10046H:
-                tda10046h_set_bandwidth(i2c, tda_state, fe_params->u.ofdm.bandwidth);
-                break;
-        }
-
-        // need to invert the inversion for TT TDA10046H
-        inversion = fe_params->inversion;
-        if (tda_state->fe_type == FE_TYPE_TDA10046H) {
-                inversion = inversion ? INVERSION_OFF : INVERSION_ON;
-        }
+	// set bandwidth
+	switch(tda_state->fe_type) {
+	case FE_TYPE_TDA10045H:
+		tda10045h_set_bandwidth(i2c, tda_state, fe_params->u.ofdm.bandwidth);
+		break;
+
+	case FE_TYPE_TDA10046H:
+		tda10046h_set_bandwidth(i2c, tda_state, fe_params->u.ofdm.bandwidth);
+		break;
+	}
+
+	// need to invert the inversion for TT TDA10046H
+	inversion = fe_params->inversion;
+	if (tda_state->fe_type == FE_TYPE_TDA10046H) {
+		inversion = inversion ? INVERSION_OFF : INVERSION_ON;
+	}
 
 	// set inversion
-        switch (inversion) {
+	switch (inversion) {
 	case INVERSION_OFF:
 		tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC1, 0x20, 0);
 		break;
@@ -985,28 +924,25 @@ static int tda1004x_set_fe(struct dvb_i2
 		return -EINVAL;
 	}
 
-        // start the lock
-        switch(tda_state->fe_type) {
-        case FE_TYPE_TDA10045H:
-	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 8, 8);
-	tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 8, 0);
-	dvb_delay(10);
-                break;
+	// start the lock
+	switch(tda_state->fe_type) {
+	case FE_TYPE_TDA10045H:
+		tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 8, 8);
+		tda1004x_write_mask(i2c, tda_state, TDA1004X_CONFC4, 8, 0);
+		msleep(10);
+		break;
 
-        case FE_TYPE_TDA10046H:
-                tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 0x40, 0x40);
-                dvb_delay(10);
-                break;
-        }
+	case FE_TYPE_TDA10046H:
+		tda1004x_write_mask(i2c, tda_state, TDA1004X_AUTO, 0x40, 0x40);
+		msleep(10);
+		break;
+	}
 
-	// done
 	return 0;
 }
 
-
-static int tda1004x_get_fe(struct dvb_i2c_bus *i2c, struct tda1004x_state* tda_state, struct dvb_frontend_parameters *fe_params)
+static int tda1004x_get_fe(struct i2c_adapter *i2c, struct tda1004x_state* tda_state, struct dvb_frontend_parameters *fe_params)
 {
-
 	dprintk("%s\n", __FUNCTION__);
 
 	// inversion status
@@ -1015,41 +951,41 @@ static int tda1004x_get_fe(struct dvb_i2
 		fe_params->inversion = INVERSION_ON;
 	}
 
-        // need to invert the inversion for TT TDA10046H
-        if (tda_state->fe_type == FE_TYPE_TDA10046H) {
-                fe_params->inversion = fe_params->inversion ? INVERSION_OFF : INVERSION_ON;
-        }
+	// need to invert the inversion for TT TDA10046H
+	if (tda_state->fe_type == FE_TYPE_TDA10046H) {
+		fe_params->inversion = fe_params->inversion ? INVERSION_OFF : INVERSION_ON;
+	}
 
 	// bandwidth
-        switch(tda_state->fe_type) {
-        case FE_TYPE_TDA10045H:
-                switch (tda1004x_read_byte(i2c, tda_state, TDA10045H_WREF_LSB)) {
-	case 0x14:
-		fe_params->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;
-		break;
-	case 0xdb:
-		fe_params->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;
-		break;
-	case 0x4f:
-		fe_params->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;
-		break;
-	}
-                break;
-
-        case FE_TYPE_TDA10046H:
-                switch (tda1004x_read_byte(i2c, tda_state, TDA10046H_TIME_WREF1)) {
-                case 0x60:
-                        fe_params->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;
-                        break;
-                case 0x6e:
-                        fe_params->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;
-                        break;
-                case 0x80:
-                        fe_params->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;
-                        break;
-                }
-                break;
-        }
+	switch(tda_state->fe_type) {
+	case FE_TYPE_TDA10045H:
+		switch (tda1004x_read_byte(i2c, tda_state, TDA10045H_WREF_LSB)) {
+		case 0x14:
+			fe_params->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;
+			break;
+		case 0xdb:
+			fe_params->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;
+			break;
+		case 0x4f:
+			fe_params->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;
+			break;
+		}
+		break;
+
+	case FE_TYPE_TDA10046H:
+		switch (tda1004x_read_byte(i2c, tda_state, TDA10046H_TIME_WREF1)) {
+		case 0x60:
+			fe_params->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;
+			break;
+		case 0x6e:
+			fe_params->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;
+			break;
+		case 0x80:
+			fe_params->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;
+			break;
+		}
+		break;
+	}
 
 	// FEC
 	fe_params->u.ofdm.code_rate_HP =
@@ -1108,16 +1044,14 @@ static int tda1004x_get_fe(struct dvb_i2
 		break;
 	}
 
-	// done
 	return 0;
 }
 
-
-static int tda1004x_read_status(struct dvb_i2c_bus *i2c, struct tda1004x_state* tda_state, fe_status_t * fe_status)
+static int tda1004x_read_status(struct i2c_adapter *i2c, struct tda1004x_state* tda_state, fe_status_t * fe_status)
 {
 	int status;
-        int cber;
-        int vber;
+	int cber;
+	int vber;
 
 	dprintk("%s\n", __FUNCTION__);
 
@@ -1127,85 +1061,83 @@ static int tda1004x_read_status(struct d
 		return -EIO;
 	}
 
-        // decode
+	// decode
 	*fe_status = 0;
-        if (status & 4) *fe_status |= FE_HAS_SIGNAL;
-        if (status & 2) *fe_status |= FE_HAS_CARRIER;
-        if (status & 8) *fe_status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
-
-        // if we don't already have VITERBI (i.e. not LOCKED), see if the viterbi
-        // is getting anything valid
-        if (!(*fe_status & FE_HAS_VITERBI)) {
-                // read the CBER
-                cber = tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_LSB);
-                if (cber == -1) return -EIO;
-                status = tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_MSB);
-                if (status == -1) return -EIO;
-                cber |= (status << 8);
-                tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_RESET);
-
-                if (cber != 65535) {
-                        *fe_status |= FE_HAS_VITERBI;
-                }
-        }
-
-        // if we DO have some valid VITERBI output, but don't already have SYNC
-        // bytes (i.e. not LOCKED), see if the RS decoder is getting anything valid.
-        if ((*fe_status & FE_HAS_VITERBI) && (!(*fe_status & FE_HAS_SYNC))) {
-                // read the VBER
-                vber = tda1004x_read_byte(i2c, tda_state, TDA1004X_VBER_LSB);
-                if (vber == -1) return -EIO;
-                status = tda1004x_read_byte(i2c, tda_state, TDA1004X_VBER_MID);
-                if (status == -1) return -EIO;
-                vber |= (status << 8);
-                status = tda1004x_read_byte(i2c, tda_state, TDA1004X_VBER_MSB);
-                if (status == -1) return -EIO;
-                vber |= ((status << 16) & 0x0f);
-                tda1004x_read_byte(i2c, tda_state, TDA1004X_CVBER_LUT);
-
-                // if RS has passed some valid TS packets, then we must be
-                // getting some SYNC bytes
-                if (vber < 16632) {
-                        *fe_status |= FE_HAS_SYNC;
-                }
-        }
+	if (status & 4) *fe_status |= FE_HAS_SIGNAL;
+	if (status & 2) *fe_status |= FE_HAS_CARRIER;
+	if (status & 8) *fe_status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+
+	// if we don't already have VITERBI (i.e. not LOCKED), see if the viterbi
+	// is getting anything valid
+	if (!(*fe_status & FE_HAS_VITERBI)) {
+		// read the CBER
+		cber = tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_LSB);
+		if (cber == -1) return -EIO;
+		status = tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_MSB);
+		if (status == -1) return -EIO;
+		cber |= (status << 8);
+		tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_RESET);
+
+		if (cber != 65535) {
+			*fe_status |= FE_HAS_VITERBI;
+		}
+	}
+
+	// if we DO have some valid VITERBI output, but don't already have SYNC
+	// bytes (i.e. not LOCKED), see if the RS decoder is getting anything valid.
+	if ((*fe_status & FE_HAS_VITERBI) && (!(*fe_status & FE_HAS_SYNC))) {
+		// read the VBER
+		vber = tda1004x_read_byte(i2c, tda_state, TDA1004X_VBER_LSB);
+		if (vber == -1) return -EIO;
+		status = tda1004x_read_byte(i2c, tda_state, TDA1004X_VBER_MID);
+		if (status == -1) return -EIO;
+		vber |= (status << 8);
+		status = tda1004x_read_byte(i2c, tda_state, TDA1004X_VBER_MSB);
+		if (status == -1) return -EIO;
+		vber |= ((status << 16) & 0x0f);
+		tda1004x_read_byte(i2c, tda_state, TDA1004X_CVBER_LUT);
+
+		// if RS has passed some valid TS packets, then we must be
+		// getting some SYNC bytes
+		if (vber < 16632) {
+			*fe_status |= FE_HAS_SYNC;
+		}
+	}
 
 	// success
 	dprintk("%s: fe_status=0x%x\n", __FUNCTION__, *fe_status);
 	return 0;
 }
 
-static int tda1004x_read_signal_strength(struct dvb_i2c_bus *i2c, struct tda1004x_state* tda_state, u16 * signal)
+static int tda1004x_read_signal_strength(struct i2c_adapter *i2c, struct tda1004x_state* tda_state, u16 * signal)
 {
 	int tmp;
-        int reg = 0;
+	int reg = 0;
 
 	dprintk("%s\n", __FUNCTION__);
 
-        // determine the register to use
-        switch(tda_state->fe_type) {
-        case FE_TYPE_TDA10045H:
-                reg = TDA10045H_S_AGC;
-                break;
-
-        case FE_TYPE_TDA10046H:
-                reg = TDA10046H_AGC_IF_LEVEL;
-                break;
-        }
+	// determine the register to use
+	switch(tda_state->fe_type) {
+	case FE_TYPE_TDA10045H:
+		reg = TDA10045H_S_AGC;
+		break;
+
+	case FE_TYPE_TDA10046H:
+		reg = TDA10046H_AGC_IF_LEVEL;
+		break;
+	}
 
 	// read it
-        tmp = tda1004x_read_byte(i2c, tda_state, reg);
+	tmp = tda1004x_read_byte(i2c, tda_state, reg);
 	if (tmp < 0)
 		return -EIO;
 
-	// done
 	*signal = (tmp << 8) | tmp;
 	dprintk("%s: signal=0x%x\n", __FUNCTION__, *signal);
 	return 0;
 }
 
-
-static int tda1004x_read_snr(struct dvb_i2c_bus *i2c, struct tda1004x_state* tda_state, u16 * snr)
+static int tda1004x_read_snr(struct i2c_adapter *i2c, struct tda1004x_state* tda_state, u16 * snr)
 {
 	int tmp;
 
@@ -1215,17 +1147,16 @@ static int tda1004x_read_snr(struct dvb_
 	tmp = tda1004x_read_byte(i2c, tda_state, TDA1004X_SNR);
 	if (tmp < 0)
 		return -EIO;
-        if (tmp) {
-                tmp = 255 - tmp;
-        }
+	if (tmp) {
+		tmp = 255 - tmp;
+	}
 
-        // done
 	*snr = ((tmp << 8) | tmp);
 	dprintk("%s: snr=0x%x\n", __FUNCTION__, *snr);
 	return 0;
 }
 
-static int tda1004x_read_ucblocks(struct dvb_i2c_bus *i2c, struct tda1004x_state* tda_state, u32* ucblocks)
+static int tda1004x_read_ucblocks(struct i2c_adapter *i2c, struct tda1004x_state* tda_state, u32* ucblocks)
 {
 	int tmp;
 	int tmp2;
@@ -1238,7 +1169,7 @@ static int tda1004x_read_ucblocks(struct
 	tmp = tda1004x_read_byte(i2c, tda_state, TDA1004X_UNCOR);
 	if (tmp < 0)
 		return -EIO;
-        tmp &= 0x7f;
+	tmp &= 0x7f;
 	while (counter++ < 5) {
 		tda1004x_write_mask(i2c, tda_state, TDA1004X_UNCOR, 0x80, 0);
 		tda1004x_write_mask(i2c, tda_state, TDA1004X_UNCOR, 0x80, 0);
@@ -1252,7 +1183,6 @@ static int tda1004x_read_ucblocks(struct
 			break;
 	}
 
-	// done
 	if (tmp != 0x7f) {
 		*ucblocks = tmp;
 	} else {
@@ -1262,27 +1192,26 @@ static int tda1004x_read_ucblocks(struct
 	return 0;
 }
 
-static int tda1004x_read_ber(struct dvb_i2c_bus *i2c, struct tda1004x_state* tda_state, u32* ber)
+static int tda1004x_read_ber(struct i2c_adapter *i2c, struct tda1004x_state* tda_state, u32* ber)
 {
-        int tmp;
+	int tmp;
 
 	dprintk("%s\n", __FUNCTION__);
 
 	// read it in
-        tmp = tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_LSB);
-        if (tmp < 0) return -EIO;
-        *ber = tmp << 1;
-        tmp = tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_MSB);
-        if (tmp < 0) return -EIO;
-        *ber |= (tmp << 9);
-        tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_RESET);
+	tmp = tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_LSB);
+	if (tmp < 0) return -EIO;
+	*ber = tmp << 1;
+	tmp = tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_MSB);
+	if (tmp < 0) return -EIO;
+	*ber |= (tmp << 9);
+	tda1004x_read_byte(i2c, tda_state, TDA1004X_CBER_RESET);
 
-	// done
 	dprintk("%s: ber=0x%x\n", __FUNCTION__, *ber);
 	return 0;
 }
 
-static int tda1004x_sleep(struct dvb_i2c_bus *i2c, struct tda1004x_state* tda_state)
+static int tda1004x_sleep(struct i2c_adapter *i2c, struct tda1004x_state* tda_state)
 {
 	switch(tda_state->fe_type) {
 	case FE_TYPE_TDA10045H:
@@ -1297,26 +1226,25 @@ static int tda1004x_sleep(struct dvb_i2c
 	return 0;
 }
 
-
 static int tda1004x_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-	int status = 0;
-	struct dvb_i2c_bus *i2c = fe->i2c;
 	struct tda1004x_state *tda_state = (struct tda1004x_state *) fe->data;
+	struct i2c_adapter *i2c = tda_state->i2c;
+	int status = 0;
 
 	dprintk("%s: cmd=0x%x\n", __FUNCTION__, cmd);
 
 	switch (cmd) {
 	case FE_GET_INFO:
-                switch(tda_state->fe_type) {
-                case FE_TYPE_TDA10045H:
-        		memcpy(arg, &tda10045h_info, sizeof(struct dvb_frontend_info));
-                        break;
-
-                case FE_TYPE_TDA10046H:
-                        memcpy(arg, &tda10046h_info, sizeof(struct dvb_frontend_info));
-                        break;
-                }
+		switch(tda_state->fe_type) {
+		case FE_TYPE_TDA10045H:
+			memcpy(arg, &tda10045h_info, sizeof(struct dvb_frontend_info));
+			break;
+
+		case FE_TYPE_TDA10046H:
+			memcpy(arg, &tda10046h_info, sizeof(struct dvb_frontend_info));
+			break;
+		}
 		break;
 
 	case FE_READ_STATUS:
@@ -1351,15 +1279,15 @@ static int tda1004x_ioctl(struct dvb_fro
 			return 0;
 
 		// OK, perform initialisation
-                switch(tda_state->fe_type) {
-                case FE_TYPE_TDA10045H:
-                        status = tda10045h_init(i2c, tda_state);
-                        break;
-
-                case FE_TYPE_TDA10046H:
-                        status = tda10046h_init(i2c, tda_state);
-                        break;
-                }
+		switch(tda_state->fe_type) {
+		case FE_TYPE_TDA10045H:
+			status = tda10045h_init(i2c, tda_state);
+			break;
+
+		case FE_TYPE_TDA10046H:
+			status = tda10046h_init(i2c, tda_state);
+			break;
+		}
 		if (status == 0)
 			tda_state->initialised = 1;
 		return status;
@@ -1372,7 +1300,7 @@ static int tda1004x_ioctl(struct dvb_fro
 		fesettings->max_drift = 166667*2;
 		return 0;
 	}
-	    
+
 	default:
 		return -EOPNOTSUPP;
 	}
@@ -1380,90 +1308,86 @@ static int tda1004x_ioctl(struct dvb_fro
 	return 0;
 }
 
-
-static int tda1004x_attach(struct dvb_i2c_bus *i2c, void **data)
+static int tda1004x_attach(struct i2c_adapter *i2c, struct tda1004x_state* state)
 {
-        int tda1004x_address = -1;
+	int tda1004x_address = -1;
 	int tuner_address = -1;
-        int fe_type = -1;
-        int tuner_type = -1;
-	struct tda1004x_state tda_state;
-	struct tda1004x_state* ptda_state;
+	int fe_type = -1;
+	int tuner_type = -1;
 	struct i2c_msg tuner_msg = {.addr=0, .flags=0, .buf=NULL, .len=0 };
-        static u8 td1344_init[] = { 0x0b, 0xf5, 0x88, 0xab };
-        static u8 td1316_init[] = { 0x0b, 0xf5, 0x85, 0xab };
-        static u8 td1316_init_tda10046h[] = { 0x0b, 0xf5, 0x80, 0xab };
-        int status;
+	static u8 td1344_init[] = { 0x0b, 0xf5, 0x88, 0xab };
+	static u8 td1316_init[] = { 0x0b, 0xf5, 0x85, 0xab };
+	static u8 td1316_init_tda10046h[] = { 0x0b, 0xf5, 0x80, 0xab };
 
 	dprintk("%s\n", __FUNCTION__);
 
-        // probe for tda10045h
-        if (tda1004x_address == -1) {
-                tda_state.tda1004x_address = 0x08;
-	if (tda1004x_read_byte(i2c, &tda_state, TDA1004X_CHIPID) == 0x25) {
-                        tda1004x_address = 0x08;
-                        fe_type = FE_TYPE_TDA10045H;
-                printk("tda1004x: Detected Philips TDA10045H.\n");
-        }
-        }
-
-        // probe for tda10046h
-        if (tda1004x_address == -1) {
-                tda_state.tda1004x_address = 0x08;
-                if (tda1004x_read_byte(i2c, &tda_state, TDA1004X_CHIPID) == 0x46) {
-                        tda1004x_address = 0x08;
-                        fe_type = FE_TYPE_TDA10046H;
-                        printk("tda1004x: Detected Philips TDA10046H.\n");
-                }
-        }
+	// probe for tda10045h
+	if (tda1004x_address == -1) {
+		state->tda1004x_address = 0x08;
+		if (tda1004x_read_byte(i2c, state, TDA1004X_CHIPID) == 0x25) {
+			tda1004x_address = 0x08;
+			fe_type = FE_TYPE_TDA10045H;
+			printk("tda1004x: Detected Philips TDA10045H.\n");
+		}
+	}
 
-        // did we find a frontend?
-        if (tda1004x_address == -1) {
+	// probe for tda10046h
+	if (tda1004x_address == -1) {
+		state->tda1004x_address = 0x08;
+		if (tda1004x_read_byte(i2c, state, TDA1004X_CHIPID) == 0x46) {
+			tda1004x_address = 0x08;
+			fe_type = FE_TYPE_TDA10046H;
+			printk("tda1004x: Detected Philips TDA10046H.\n");
+		}
+	}
+
+	// did we find a frontend?
+	if (tda1004x_address == -1) {
 		return -ENODEV;
-        }
+	}
 
-        // enable access to the tuner
-	tda1004x_enable_tuner_i2c(i2c, &tda_state);
+	// enable access to the tuner
+	tda1004x_enable_tuner_i2c(i2c, state);
 
-        // check for a TD1344 first
-        if (tuner_address == -1) {
-                tuner_msg.addr = 0x61;
-	tuner_msg.buf = td1344_init;
-	tuner_msg.len = sizeof(td1344_init);
-	if (i2c->xfer(i2c, &tuner_msg, 1) == 1) {
-                dvb_delay(1);
-                        tuner_address = 0x61;
-                        tuner_type = TUNER_TYPE_TD1344;
-                        printk("tda1004x: Detected Philips TD1344 tuner.\n");
-                }
-        }
-
-        // OK, try a TD1316 on address 0x63
-        if (tuner_address == -1) {
-                tuner_msg.addr = 0x63;
-                tuner_msg.buf = td1316_init;
-                tuner_msg.len = sizeof(td1316_init);
-                if (i2c->xfer(i2c, &tuner_msg, 1) == 1) {
-                        dvb_delay(1);
-                        tuner_address = 0x63;
-                        tuner_type = TUNER_TYPE_TD1316;
-                        printk("tda1004x: Detected Philips TD1316 tuner.\n");
-                }
-        }
-
-        // OK, TD1316 again, on address 0x60 (TDA10046H)
-        if (tuner_address == -1) {
-                tuner_msg.addr = 0x60;
-                tuner_msg.buf = td1316_init_tda10046h;
-                tuner_msg.len = sizeof(td1316_init_tda10046h);
-                if (i2c->xfer(i2c, &tuner_msg, 1) == 1) {
-                        dvb_delay(1);
-                        tuner_address = 0x60;
-                        tuner_type = TUNER_TYPE_TD1316;
-                        printk("tda1004x: Detected Philips TD1316 tuner.\n");
+	// check for a TD1344 first
+	if (tuner_address == -1) {
+		tuner_msg.addr = 0x61;
+		tuner_msg.buf = td1344_init;
+		tuner_msg.len = sizeof(td1344_init);
+		if (i2c_transfer(i2c, &tuner_msg, 1) == 1) {
+			msleep(1);
+			tuner_address = 0x61;
+			tuner_type = TUNER_TYPE_TD1344;
+			printk("tda1004x: Detected Philips TD1344 tuner.\n");
+		}
+	}
+
+	// OK, try a TD1316 on address 0x63
+	if (tuner_address == -1) {
+		tuner_msg.addr = 0x63;
+		tuner_msg.buf = td1316_init;
+		tuner_msg.len = sizeof(td1316_init);
+		if (i2c_transfer(i2c, &tuner_msg, 1) == 1) {
+			msleep(1);
+			tuner_address = 0x63;
+			tuner_type = TUNER_TYPE_TD1316;
+			printk("tda1004x: Detected Philips TD1316 tuner.\n");
+		}
+	}
+
+	// OK, TD1316 again, on address 0x60 (TDA10046H)
+	if (tuner_address == -1) {
+		tuner_msg.addr = 0x60;
+		tuner_msg.buf = td1316_init_tda10046h;
+		tuner_msg.len = sizeof(td1316_init_tda10046h);
+		if (i2c_transfer(i2c, &tuner_msg, 1) == 1) {
+			msleep(1);
+			tuner_address = 0x60;
+			tuner_type = TUNER_TYPE_TD1316;
+			printk("tda1004x: Detected Philips TD1316 tuner.\n");
 		}
 	}
-	tda1004x_disable_tuner_i2c(i2c, &tda_state);
+	tda1004x_disable_tuner_i2c(i2c, state);
 
 	// did we find a tuner?
 	if (tuner_address == -1) {
@@ -1471,58 +1395,164 @@ static int tda1004x_attach(struct dvb_i2
 		return -ENODEV;
 	}
 
-        // create state
-        tda_state.tda1004x_address = tda1004x_address;
-        tda_state.fe_type = fe_type;
-	tda_state.tuner_address = tuner_address;
-        tda_state.tuner_type = tuner_type;
-	tda_state.initialised = 0;
+	// create state
+	state->tda1004x_address = tda1004x_address;
+	state->fe_type = fe_type;
+	state->tuner_address = tuner_address;
+	state->tuner_type = tuner_type;
+	state->initialised = 0;
+
+	return 0;
+}
+
+static struct i2c_client client_template;
+
+static int attach_adapter(struct i2c_adapter *adapter)
+{
+	struct i2c_client *client;
+	struct tda1004x_state *state;
+	int ret;
 
-        // upload firmware
-        if ((status = tda1004x_fwupload(i2c, &tda_state)) != 0) return status;
+	dprintk ("%s\n", __FUNCTION__);
 
-	// create the real state we'll be passing about
-	if ((ptda_state = (struct tda1004x_state*) kmalloc(sizeof(struct tda1004x_state), GFP_KERNEL)) == NULL) {
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
 		return -ENOMEM;
 	}
-	memcpy(ptda_state, &tda_state, sizeof(struct tda1004x_state));
-	*data = ptda_state;
 
-	// register
-        switch(tda_state.fe_type) {
-        case FE_TYPE_TDA10045H:
-		return dvb_register_frontend(tda1004x_ioctl, i2c, ptda_state, &tda10045h_info);
+	if (NULL == (state = kmalloc(sizeof(struct tda1004x_state), GFP_KERNEL))) {
+		kfree(client);
+		return -ENOMEM;
+	}
+	state->i2c = adapter;
+
+	ret = tda1004x_attach(adapter, state);
+	if (ret) {
+		kfree(state);
+		kfree(client);
+		return -ENODEV;
+	}
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = state->tda1004x_address;
+	i2c_set_clientdata(client, (void*)state);
+
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	// upload firmware
+	BUG_ON(!state->dvb);
+
+	switch(state->fe_type) {
+	case FE_TYPE_TDA10045H:
+		state->dspCodeCounterReg = TDA10045H_FWPAGE;
+		state->dspCodeInReg =  TDA10045H_CODE_IN;
+		state->dspVersion = 0x2c;
+
+		ret = tda10045_fwupload(adapter, state, client);
+		if (ret) {
+			printk("tda1004x: firmware upload failed\n");
+			goto out;
+		}
+
+		ret = dvb_register_frontend(tda1004x_ioctl, state->dvb,
+						state, &tda10045h_info,
+						THIS_MODULE);
+		break;
+	case FE_TYPE_TDA10046H:
+		state->dspCodeCounterReg = TDA10046H_CODE_CPT;
+		state->dspCodeInReg =  TDA10046H_CODE_IN;
+		state->dspVersion = 0x20;
+
+		ret = tda10046_fwupload(adapter, state, client);
+		if (ret) {
+			printk("tda1004x: firmware upload failed\n");
+			goto out;
+		}
+
+		ret = dvb_register_frontend(tda1004x_ioctl, state->dvb,
+						state, &tda10046h_info,
+						THIS_MODULE);
+		break;
+	default:
+		BUG_ON(1);
+	}
 
-        case FE_TYPE_TDA10046H:
-		return dvb_register_frontend(tda1004x_ioctl, i2c, ptda_state, &tda10046h_info);
-        }
+	if (ret) {
+		printk("tda1004x: registering frontend failed\n");
+		goto out;
+	}
 
-        // should not get here
-        return -EINVAL;
+	return 0;
+out:
+	i2c_detach_client(client);
+	kfree(client);
+	kfree(state);
+	return ret;
 }
 
+static int detach_client(struct i2c_client *client)
+{
+	struct tda1004x_state *state = (struct tda1004x_state*)i2c_get_clientdata(client);
+
+	dprintk ("%s\n", __FUNCTION__);
+
+	dvb_unregister_frontend (tda1004x_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
 
-static
-void tda1004x_detach(struct dvb_i2c_bus *i2c, void *data)
+static int command (struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	dprintk("%s\n", __FUNCTION__);
+	struct tda1004x_state *state = (struct tda1004x_state*)i2c_get_clientdata(client);
+
+	dprintk ("%s\n", __FUNCTION__);
 
-	kfree(data);
-	dvb_unregister_frontend(tda1004x_ioctl, i2c);
+	switch (cmd) {
+	case FE_REGISTER:
+		state->dvb = (struct dvb_adapter*)arg;
+		break;
+	case FE_UNREGISTER:
+		state->dvb = NULL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= FRONTEND_NAME,
+	.id 		= I2C_DRIVERID_DVBFE_TDA1004X,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = attach_adapter,
+	.detach_client 	= detach_client,
+	.command 	= command,
+};
 
-static
-int __init init_tda1004x(void)
+static struct i2c_client client_template = {
+	.name		= FRONTEND_NAME,
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
+
+static int __init init_tda1004x(void)
 {
-	return dvb_register_i2c_device(THIS_MODULE, tda1004x_attach, tda1004x_detach);
+	return i2c_add_driver(&driver);
 }
 
-
-static
-void __exit exit_tda1004x(void)
+static void __exit exit_tda1004x(void)
 {
-	dvb_unregister_i2c_device(tda1004x_attach);
+	if (i2c_del_driver(&driver))
+		printk("tda1004x: driver deregistration failed\n");
 }
 
 module_init(init_tda1004x);
@@ -1532,8 +1562,3 @@ MODULE_DESCRIPTION("Philips TDA10045H & 
 MODULE_AUTHOR("Andrew de Quincey & Robert Schlabbach");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(tda1004x_debug, "i");
-MODULE_PARM_DESC(tda1004x_debug, "enable verbose debug messages");
-
-MODULE_PARM(tda1004x_firmware, "s");
-MODULE_PARM_DESC(tda1004x_firmware, "Where to find the firmware file");
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/ves1820.c linux/drivers/media/dvb/frontends/ves1820.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/ves1820.c	2004-09-14 10:35:53.000000000 +0200
+++ linux/drivers/media/dvb/frontends/ves1820.c	2004-09-17 14:56:38.863589066 +0200
@@ -1,4 +1,4 @@
-/* 
+/*
     VES1820  - Single Chip Cable Channel Receiver driver module
                used on the the Siemens DVB-C cards
 
@@ -17,7 +17,7 @@
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/    
+*/
 
 #include <linux/config.h>
 #include <linux/delay.h>
@@ -29,63 +29,34 @@
 #include <linux/slab.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
+/* I2C_DRIVERID_VES1820 is already defined in i2c-id.h */
 
 #if 0
-#define dprintk(x...) printk(x)
-#else
-#define dprintk(x...)
+static int debug = 0;
+#define dprintk	if (debug) printk
 #endif
 
-#define MAX_UNITS 4
-static int pwm[MAX_UNITS] = { -1, -1, -1, -1 };
 static int verbose;
 
-/**
- *  since we need only a few bits to store internal state we don't allocate
- *  extra memory but use frontend->data as bitfield
- */
+struct ves1820_state {
+	int pwm;
+	u8 reg0;
+	int tuner;
+	u8 demod_addr;
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
+};
 
-#define SET_PWM(data,pwm) do { 		\
-	long d = (long)data;		\
-	d &= ~0xff; 			\
-	d |= pwm; 			\
-	data = (void *)d;		\
-} while (0)
-
-#define SET_REG0(data,reg0) do {	\
-	long d = (long)data;		\
-	d &= ~(0xff << 8); 		\
-	d |= reg0 << 8; 		\
-	data = (void *)d;		\
-} while (0)
-
-#define SET_TUNER(data,type) do {	\
-	long d = (long)data;		\
-	d &= ~(0xff << 16); 		\
-	d |= type << 16;		\
-	data = (void *)d;		\
-} while (0)
-
-#define SET_DEMOD_ADDR(data,type) do {	\
-	long d = (long)data;		\
-	d &= ~(0xff << 24); 		\
-	d |= type << 24;		\
-	data = (void *)d;		\
-} while (0)
-
-#define GET_PWM(data) ((u8) ((long) data & 0xff))
-#define GET_REG0(data) ((u8) (((long) data >> 8) & 0xff))
-#define GET_TUNER(data) ((u8) (((long) data >> 16) & 0xff))
-#define GET_DEMOD_ADDR(data) ((u8) (((long) data >> 24) & 0xff))
+/* possible ves1820 adresses */
+static u8 addr[] = { 0x61, 0x62 };
 
 #if defined(CONFIG_DBOX2)
 #define XIN 69600000UL
 #define DISABLE_INVERSION(reg0)		do { reg0 &= ~0x20; } while (0)
 #define ENABLE_INVERSION(reg0)		do { reg0 |= 0x20; } while (0)
 #define HAS_INVERSION(reg0)		(reg0 & 0x20)
-#else	/* PCI cards */
+#else				/* PCI cards */
 #define XIN 57840000UL
 #define DISABLE_INVERSION(reg0)		do { reg0 |= 0x20; } while (0)
 #define ENABLE_INVERSION(reg0)		do { reg0 &= ~0x20; } while (0)
@@ -94,30 +65,29 @@ static int verbose;
 
 #define FIN (XIN >> 4)
 
-
-
 static struct dvb_frontend_info ves1820_info = {
 	.name = "VES1820 based DVB-C frontend",
 	.type = FE_QAM,
 	.frequency_stepsize = 62500,
 	.frequency_min = 51000000,
 	.frequency_max = 858000000,
-	.symbol_rate_min = (XIN/2)/64,     /* SACLK/64 == (XIN/2)/64 */
-	.symbol_rate_max = (XIN/2)/4,      /* SACLK/4 */
+	.symbol_rate_min = (XIN / 2) / 64,	/* SACLK/64 == (XIN/2)/64 */
+	.symbol_rate_max = (XIN / 2) / 4,	/* SACLK/4 */
 #if 0
-	.frequency_tolerance = ???,
-	.symbol_rate_tolerance = ???,  /* ppm */  /* == 8% (spec p. 5) */
+	.frequency_tolerance = ? ? ?,
+	.symbol_rate_tolerance = ? ? ?,	/* ppm *//* == 8% (spec p. 5) */
 	.notifier_delay = ?,
 #endif
-	.caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
-		FE_CAN_QAM_128 | FE_CAN_QAM_256 | 
-		FE_CAN_FEC_AUTO | FE_CAN_INVERSION_AUTO,
+	.caps = FE_CAN_QAM_16 |
+		FE_CAN_QAM_32 |
+		FE_CAN_QAM_64 |
+		FE_CAN_QAM_128 |
+		FE_CAN_QAM_256 |
+		FE_CAN_FEC_AUTO |
+		FE_CAN_INVERSION_AUTO,
 };
 
-
-
-static u8 ves1820_inittab [] =
-{
+static u8 ves1820_inittab[] = {
 	0x69, 0x6A, 0x9B, 0x12, 0x12, 0x46, 0x26, 0x1A,
 	0x43, 0x6A, 0xAA, 0xAA, 0x1E, 0x85, 0x43, 0x20,
 	0xE0, 0x00, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -127,79 +97,70 @@ static u8 ves1820_inittab [] =
 	0x00, 0x00, 0x00, 0x00, 0x40
 };
 
-
-static int ves1820_writereg (struct dvb_frontend *fe, u8 reg, u8 data)
+static int ves1820_writereg(struct ves1820_state *state, u8 reg, u8 data)
 {
-	u8 addr = GET_DEMOD_ADDR(fe->data);
-        u8 buf[] = { 0x00, reg, data };
-	struct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 3 };
-	struct dvb_i2c_bus *i2c = fe->i2c;
-        int ret;
+	u8 buf[] = { 0x00, reg, data };
+	struct i2c_msg msg = {.addr = state->demod_addr,.flags = 0,.buf = buf,.len = 3 };
+	int ret;
 
-	ret = i2c->xfer (i2c, &msg, 1);
+	ret = i2c_transfer(state->i2c, &msg, 1);
 
 	if (ret != 1)
-		printk("DVB: VES1820(%d): %s, writereg error "
-			"(reg == 0x%02x, val == 0x%02x, ret == %i)\n",
-			fe->i2c->adapter->num, __FUNCTION__, reg, data, ret);
+		printk("ves1820: %s(): writereg error (reg == 0x%02x,"
+			"val == 0x%02x, ret == %i)\n", __FUNCTION__, reg, data, ret);
 
-	dvb_delay(10);
+	msleep(10);
 	return (ret != 1) ? -EREMOTEIO : 0;
 }
 
-
-static u8 ves1820_readreg (struct dvb_frontend *fe, u8 reg)
+static u8 ves1820_readreg(struct ves1820_state *state, u8 reg)
 {
-	u8 b0 [] = { 0x00, reg };
-	u8 b1 [] = { 0 };
-	u8 addr = GET_DEMOD_ADDR(fe->data);
-	struct i2c_msg msg [] = { { .addr = addr, .flags = 0, .buf = b0, .len = 2 },
-	                   { .addr = addr, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
-	struct dvb_i2c_bus *i2c = fe->i2c;
+	u8 b0[] = { 0x00, reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{.addr = state->demod_addr,.flags = 0,.buf = b0,.len = 2},
+		{.addr = state->demod_addr,.flags = I2C_M_RD,.buf = b1,.len = 1}
+	};
 	int ret;
 
-	ret = i2c->xfer (i2c, msg, 2);
+	ret = i2c_transfer(state->i2c, msg, 2);
 
 	if (ret != 2)
-		printk("DVB: VES1820(%d): %s: readreg error (ret == %i)\n",
-				fe->i2c->adapter->num, __FUNCTION__, ret);
+		printk("ves1820: %s(): readreg error (reg == 0x%02x,"
+		"ret == %i)\n", __FUNCTION__, reg, ret);
 
 	return b1[0];
 }
 
-
-static int tuner_write (struct dvb_i2c_bus *i2c, u8 addr, u8 data [4])
+static int tuner_write(struct ves1820_state *state, u8 addr, u8 data[4])
 {
-        int ret;
-        struct i2c_msg msg = { .addr = addr, .flags = 0, .buf = data, .len = 4 };
+	int ret;
+	struct i2c_msg msg = {.addr = addr,.flags = 0,.buf = data,.len = 4 };
 
-        ret = i2c->xfer (i2c, &msg, 1);
+	ret = i2c_transfer(state->i2c, &msg, 1);
 
-        if (ret != 1)
-                printk("DVB: VES1820(%d): %s: i/o error (ret == %i)\n",
-				i2c->adapter->num, __FUNCTION__, ret);
+	if (ret != 1)
+		printk("ves1820: %s(): i/o error (ret == %i)\n", __FUNCTION__, ret);
 
-        return (ret != 1) ? -EREMOTEIO : 0;
+	return (ret != 1) ? -EREMOTEIO : 0;
 }
 
-
 /**
  *   set up the downconverter frequency divisor for a
  *   reference clock comparision frequency of 62.5 kHz.
  */
-static int tuner_set_tv_freq (struct dvb_frontend *fe, u32 freq)
+static int tuner_set_tv_freq(struct ves1820_state *state, u32 freq)
 {
-        u32 div, ifreq;
-	static u8 addr [] = { 0x61, 0x62 };
-	static u8 byte3 [] = { 0x8e, 0x85 };
-	int tuner_type = GET_TUNER(fe->data);
-        u8 buf [4];
+	u32 div, ifreq;
+	static u8 byte3[] = { 0x8e, 0x85 };
+	int tuner_type = state->tuner;
+	u8 buf[4];
 
-	if (tuner_type == 0xff)     /*  PLL not reachable over i2c ...  */
+	if (tuner_type == 0xff)	/*  PLL not reachable over i2c ...  */
 		return 0;
 
-	if (strstr (fe->i2c->adapter->name, "Technotrend") ||
-	    strstr (fe->i2c->adapter->name, "TT-Budget"))
+	if (strstr(state->i2c->name, "Technotrend")
+	 || strstr(state->i2c->name, "TT-Budget"))
 		ifreq = 35937500;
 	else
 		ifreq = 36125000;
@@ -212,147 +173,147 @@ static int tuner_set_tv_freq (struct dvb
 
 	if (tuner_type == 1) {
 		buf[2] |= (div >> 10) & 0x60;
-		buf[3] = (freq < 174000000 ? 0x88 :
-			  freq < 470000000 ? 0x84 : 0x81);
+		buf[3] = (freq < 174000000 ? 0x88 : freq < 470000000 ? 0x84 : 0x81);
 	} else {
-		buf[3] = (freq < 174000000 ? 0xa1 :
-			  freq < 454000000 ? 0x92 : 0x34);
+		buf[3] = (freq < 174000000 ? 0xa1 : freq < 454000000 ? 0x92 : 0x34);
 	}
 
-        return tuner_write (fe->i2c, addr[tuner_type], buf);
+	return tuner_write(state, addr[tuner_type], buf);
 }
 
-
-static int ves1820_setup_reg0 (struct dvb_frontend *fe, u8 reg0,
-			fe_spectral_inversion_t inversion)
+static int ves1820_setup_reg0(struct ves1820_state *state, u8 reg0, fe_spectral_inversion_t inversion)
 {
-	reg0 |= GET_REG0(fe->data) & 0x62;
-	
+	reg0 |= state->reg0 & 0x62;
+
 	if (INVERSION_ON == inversion)
 		ENABLE_INVERSION(reg0);
 	else if (INVERSION_OFF == inversion)
 		DISABLE_INVERSION(reg0);
-	
-	ves1820_writereg (fe, 0x00, reg0 & 0xfe);
-        ves1820_writereg (fe, 0x00, reg0 | 0x01);
+
+	ves1820_writereg(state, 0x00, reg0 & 0xfe);
+	ves1820_writereg(state, 0x00, reg0 | 0x01);
 
 	/**
 	 *  check lock and toggle inversion bit if required...
 	 */
-	if (INVERSION_AUTO == inversion && !(ves1820_readreg (fe, 0x11) & 0x08)) {
+	if (INVERSION_AUTO == inversion && !(ves1820_readreg(state, 0x11) & 0x08)) {
 		mdelay(50);
-		if (!(ves1820_readreg (fe, 0x11) & 0x08)) {
+		if (!(ves1820_readreg(state, 0x11) & 0x08)) {
 			reg0 ^= 0x20;
-			ves1820_writereg (fe, 0x00, reg0 & 0xfe);
-        		ves1820_writereg (fe, 0x00, reg0 | 0x01);
+			ves1820_writereg(state, 0x00, reg0 & 0xfe);
+			ves1820_writereg(state, 0x00, reg0 | 0x01);
 		}
 	}
 
-	SET_REG0(fe->data, reg0);
+	state->reg0 = reg0;
 
 	return 0;
 }
 
-
-static int ves1820_init (struct dvb_frontend *fe)
+static int ves1820_init(struct ves1820_state *state)
 {
 	int i;
-        
-        dprintk("DVB: VES1820(%d): init chip\n", fe->i2c->adapter->num);
 
-        ves1820_writereg (fe, 0, 0);
+	ves1820_writereg(state, 0, 0);
 
 #if defined(CONFIG_DBOX2)
 	ves1820_inittab[2] &= ~0x08;
 #endif
 
-	for (i=0; i<53; i++)
-                ves1820_writereg (fe, i, ves1820_inittab[i]);
+	for (i = 0; i < 53; i++)
+		ves1820_writereg(state, i, ves1820_inittab[i]);
 
-	ves1820_writereg (fe, 0x34, GET_PWM(fe->data)); 
+	ves1820_writereg(state, 0x34, state->pwm);
 
 	return 0;
 }
 
-
-static int ves1820_set_symbolrate (struct dvb_frontend *fe, u32 symbolrate)
+static int ves1820_set_symbolrate(struct ves1820_state *state, u32 symbolrate)
 {
-        s32 BDR; 
-        s32 BDRI;
-        s16 SFIL=0;
-        u16 NDEC = 0;
-        u32 tmp, ratio;
+	s32 BDR;
+	s32 BDRI;
+	s16 SFIL = 0;
+	u16 NDEC = 0;
+	u32 tmp, ratio;
 
-        if (symbolrate > XIN/2) 
-                symbolrate = XIN/2;
+	if (symbolrate > XIN / 2)
+		symbolrate = XIN / 2;
 
 	if (symbolrate < 500000)
-                symbolrate = 500000;
+		symbolrate = 500000;
 
-        if (symbolrate < XIN/16) NDEC = 1;
-        if (symbolrate < XIN/32) NDEC = 2;
-        if (symbolrate < XIN/64) NDEC = 3;
-
-        if (symbolrate < (u32)(XIN/12.3)) SFIL = 1;
-        if (symbolrate < (u32)(XIN/16))	 SFIL = 0;
-        if (symbolrate < (u32)(XIN/24.6)) SFIL = 1;
-        if (symbolrate < (u32)(XIN/32))	 SFIL = 0;
-        if (symbolrate < (u32)(XIN/49.2)) SFIL = 1;
-        if (symbolrate < (u32)(XIN/64))	 SFIL = 0;
-        if (symbolrate < (u32)(XIN/98.4)) SFIL = 1;
-        
-        symbolrate <<= NDEC;
-        ratio = (symbolrate << 4) / FIN;
-        tmp =  ((symbolrate << 4) % FIN) << 8;
-        ratio = (ratio << 8) + tmp / FIN;
-        tmp = (tmp % FIN) << 8;
-        ratio = (ratio << 8) + (tmp + FIN/2) / FIN;
-        
-        BDR = ratio;
-        BDRI = (((XIN << 5) / symbolrate) + 1) / 2;
-        
-        if (BDRI > 0xFF) 
-                BDRI = 0xFF;
-        
-        SFIL = (SFIL << 4) | ves1820_inittab[0x0E];
-        
-        NDEC = (NDEC << 6) | ves1820_inittab[0x03];
-
-        ves1820_writereg (fe, 0x03, NDEC);
-        ves1820_writereg (fe, 0x0a, BDR&0xff);
-        ves1820_writereg (fe, 0x0b, (BDR>> 8)&0xff);
-        ves1820_writereg (fe, 0x0c, (BDR>>16)&0x3f);
-
-        ves1820_writereg (fe, 0x0d, BDRI);
-        ves1820_writereg (fe, 0x0e, SFIL);
-
-        return 0;
-}
+	if (symbolrate < XIN / 16)
+		NDEC = 1;
+	if (symbolrate < XIN / 32)
+		NDEC = 2;
+	if (symbolrate < XIN / 64)
+		NDEC = 3;
+
+	if (symbolrate < (u32) (XIN / 12.3))
+		SFIL = 1;
+	if (symbolrate < (u32) (XIN / 16))
+		SFIL = 0;
+	if (symbolrate < (u32) (XIN / 24.6))
+		SFIL = 1;
+	if (symbolrate < (u32) (XIN / 32))
+		SFIL = 0;
+	if (symbolrate < (u32) (XIN / 49.2))
+		SFIL = 1;
+	if (symbolrate < (u32) (XIN / 64))
+		SFIL = 0;
+	if (symbolrate < (u32) (XIN / 98.4))
+		SFIL = 1;
+
+	symbolrate <<= NDEC;
+	ratio = (symbolrate << 4) / FIN;
+	tmp = ((symbolrate << 4) % FIN) << 8;
+	ratio = (ratio << 8) + tmp / FIN;
+	tmp = (tmp % FIN) << 8;
+	ratio = (ratio << 8) + (tmp + FIN / 2) / FIN;
+
+	BDR = ratio;
+	BDRI = (((XIN << 5) / symbolrate) + 1) / 2;
+
+	if (BDRI > 0xFF)
+		BDRI = 0xFF;
+
+	SFIL = (SFIL << 4) | ves1820_inittab[0x0E];
+
+	NDEC = (NDEC << 6) | ves1820_inittab[0x03];
+
+	ves1820_writereg(state, 0x03, NDEC);
+	ves1820_writereg(state, 0x0a, BDR & 0xff);
+	ves1820_writereg(state, 0x0b, (BDR >> 8) & 0xff);
+	ves1820_writereg(state, 0x0c, (BDR >> 16) & 0x3f);
 
+	ves1820_writereg(state, 0x0d, BDRI);
+	ves1820_writereg(state, 0x0e, SFIL);
 
-static int ves1820_set_parameters (struct dvb_frontend *fe,
-			    struct dvb_frontend_parameters *p)
-{
-	static const u8 reg0x00 [] = { 0x00, 0x04, 0x08, 0x0c, 0x10 };
-	static const u8 reg0x01 [] = {  140,  140,  106,  100,   92 };
-	static const u8 reg0x05 [] = {  135,  100,   70,   54,   38 };
-	static const u8 reg0x08 [] = {  162,  116,   67,   52,   35 };
-	static const u8 reg0x09 [] = {  145,  150,  106,  126,  107 };
+	return 0;
+}
+
+static int ves1820_set_parameters(struct ves1820_state *state, struct dvb_frontend_parameters *p)
+{
+	static const u8 reg0x00[] = { 0x00, 0x04, 0x08, 0x0c, 0x10 };
+	static const u8 reg0x01[] = { 140, 140, 106, 100, 92 };
+	static const u8 reg0x05[] = { 135, 100, 70, 54, 38 };
+	static const u8 reg0x08[] = { 162, 116, 67, 52, 35 };
+	static const u8 reg0x09[] = { 145, 150, 106, 126, 107 };
 	int real_qam = p->u.qam.modulation - QAM_16;
 
 	if (real_qam < 0 || real_qam > 4)
 		return -EINVAL;
 
-	tuner_set_tv_freq (fe, p->frequency);
-	ves1820_set_symbolrate (fe, p->u.qam.symbol_rate);
-	ves1820_writereg (fe, 0x34, GET_PWM(fe->data));
-
-        ves1820_writereg (fe, 0x01, reg0x01[real_qam]);
-        ves1820_writereg (fe, 0x05, reg0x05[real_qam]);
-        ves1820_writereg (fe, 0x08, reg0x08[real_qam]);
-        ves1820_writereg (fe, 0x09, reg0x09[real_qam]);
+	tuner_set_tv_freq(state, p->frequency);
+	ves1820_set_symbolrate(state, p->u.qam.symbol_rate);
+	ves1820_writereg(state, 0x34, state->pwm);
+
+	ves1820_writereg(state, 0x01, reg0x01[real_qam]);
+	ves1820_writereg(state, 0x05, reg0x05[real_qam]);
+	ves1820_writereg(state, 0x08, reg0x08[real_qam]);
+	ves1820_writereg(state, 0x09, reg0x09[real_qam]);
 
-	ves1820_setup_reg0 (fe, reg0x00[real_qam], p->inversion);
+	ves1820_setup_reg0(state, reg0x00[real_qam], p->inversion);
 
 	/* yes, this speeds things up: userspace reports lock in about 8 ms
 	   instead of 500 to 1200 ms after calling FE_SET_FRONTEND. */
@@ -361,133 +322,127 @@ static int ves1820_set_parameters (struc
 	return 0;
 }
 
-
-
-static int ves1820_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
+static int ves1820_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-        switch (cmd) {
+	struct ves1820_state *state = (struct ves1820_state *) fe->data;
+
+	switch (cmd) {
 	case FE_GET_INFO:
-		memcpy (arg, &ves1820_info, sizeof(struct dvb_frontend_info));
+		memcpy(arg, &ves1820_info, sizeof(struct dvb_frontend_info));
 		break;
 
-        case FE_READ_STATUS:
-	{
-		fe_status_t *status = (fe_status_t *) arg;
-		int sync;
+	case FE_READ_STATUS:
+		{
+			fe_status_t *status = (fe_status_t *) arg;
+			int sync;
 
-		*status = 0;
+			*status = 0;
 
-                sync = ves1820_readreg (fe, 0x11);
+			sync = ves1820_readreg(state, 0x11);
 
-		if (sync & 1)
-			*status |= FE_HAS_SIGNAL;
+			if (sync & 1)
+				*status |= FE_HAS_SIGNAL;
 
-		if (sync & 2)
-			*status |= FE_HAS_CARRIER;
+			if (sync & 2)
+				*status |= FE_HAS_CARRIER;
 
-		if (sync & 2)           /* XXX FIXME! */
-			*status |= FE_HAS_VITERBI;
-		
-		if (sync & 4)
-			*status |= FE_HAS_SYNC;
+			if (sync & 2)	/* XXX FIXME! */
+				*status |= FE_HAS_VITERBI;
 
-		if (sync & 8)
-			*status |= FE_HAS_LOCK;
+			if (sync & 4)
+				*status |= FE_HAS_SYNC;
 
-		break;
-	}
+			if (sync & 8)
+				*status |= FE_HAS_LOCK;
+
+			break;
+		}
 
 	case FE_READ_BER:
-	{
-		u32 ber = ves1820_readreg(fe, 0x14) |
-			 (ves1820_readreg(fe, 0x15) << 8) |
-			 ((ves1820_readreg(fe, 0x16) & 0x0f) << 16);
-		*((u32*) arg) = 10 * ber;
-		break;
-	}
+		{
+			u32 ber = ves1820_readreg(state, 0x14) |
+					(ves1820_readreg(state, 0x15) << 8) |
+					((ves1820_readreg(state, 0x16) & 0x0f) << 16);
+			*((u32 *) arg) = 10 * ber;
+			break;
+		}
 	case FE_READ_SIGNAL_STRENGTH:
-	{
-		u8 gain = ves1820_readreg(fe, 0x17);
-		*((u16*) arg) = (gain << 8) | gain;
-		break;
-	}
+		{
+			u8 gain = ves1820_readreg(state, 0x17);
+			*((u16 *) arg) = (gain << 8) | gain;
+			break;
+		}
 
 	case FE_READ_SNR:
-	{
-		u8 quality = ~ves1820_readreg(fe, 0x18);
-		*((u16*) arg) = (quality << 8) | quality;
-		break;
-	}
+		{
+			u8 quality = ~ves1820_readreg(state, 0x18);
+			*((u16 *) arg) = (quality << 8) | quality;
+			break;
+		}
 
 	case FE_READ_UNCORRECTED_BLOCKS:
-		*((u32*) arg) = ves1820_readreg (fe, 0x13) & 0x7f;
-		if (*((u32*) arg) == 0x7f)
-			*((u32*) arg) = 0xffffffff;
+		*((u32 *) arg) = ves1820_readreg(state, 0x13) & 0x7f;
+		if (*((u32 *) arg) == 0x7f)
+			*((u32 *) arg) = 0xffffffff;
 		/* reset uncorrected block counter */
-		ves1820_writereg (fe, 0x10, ves1820_inittab[0x10] & 0xdf);
-	        ves1820_writereg (fe, 0x10, ves1820_inittab[0x10]);
+		ves1820_writereg(state, 0x10, ves1820_inittab[0x10] & 0xdf);
+		ves1820_writereg(state, 0x10, ves1820_inittab[0x10]);
 		break;
 
-        case FE_SET_FRONTEND:
-		return ves1820_set_parameters (fe, arg);
+	case FE_SET_FRONTEND:
+		return ves1820_set_parameters(state, arg);
 
 	case FE_GET_FRONTEND:
-	{
-		struct dvb_frontend_parameters *p = (struct dvb_frontend_parameters *)arg;
-		u8 reg0 = GET_REG0(fe->data);
-		int sync;
-		s8 afc = 0;
-                
-                sync = ves1820_readreg (fe, 0x11);
-			afc = ves1820_readreg(fe, 0x19);
-		if (verbose) {
-			/* AFC only valid when carrier has been recovered */
-			printk(sync & 2 ? "DVB: VES1820(%d): AFC (%d) %dHz\n" :
-					  "DVB: VES1820(%d): [AFC (%d) %dHz]\n",
-					fe->i2c->adapter->num, afc,
-			       -((s32)p->u.qam.symbol_rate * afc) >> 10);
+		{
+			struct dvb_frontend_parameters *p = (struct dvb_frontend_parameters *) arg;
+			int sync;
+			s8 afc = 0;
+
+			sync = ves1820_readreg(state, 0x11);
+			afc = ves1820_readreg(state, 0x19);
+			if (verbose) {
+				/* AFC only valid when carrier has been recovered */
+				printk(sync & 2 ? "ves1820: AFC (%d) %dHz\n" :
+					"ves1820: [AFC (%d) %dHz]\n", afc, -((s32) p->u.qam.symbol_rate * afc) >> 10);
+			}
+
+			p->inversion = HAS_INVERSION(state->reg0) ? INVERSION_ON : INVERSION_OFF;
+			p->u.qam.modulation = ((state->reg0 >> 2) & 7) + QAM_16;
+
+			p->u.qam.fec_inner = FEC_NONE;
+
+			p->frequency = ((p->frequency + 31250) / 62500) * 62500;
+			if (sync & 2)
+				p->frequency -= ((s32) p->u.qam.symbol_rate * afc) >> 10;
+			break;
 		}
-
-		p->inversion = HAS_INVERSION(reg0) ? INVERSION_ON : INVERSION_OFF;
-		p->u.qam.modulation = ((reg0 >> 2) & 7) + QAM_16;
-
-		p->u.qam.fec_inner = FEC_NONE;
-
-		p->frequency = ((p->frequency + 31250) / 62500) * 62500;
-		if (sync & 2)
-			p->frequency -= ((s32)p->u.qam.symbol_rate * afc) >> 10;
-		break;
-	}
 	case FE_SLEEP:
-		ves1820_writereg (fe, 0x1b, 0x02);  /* pdown ADC */
-		ves1820_writereg (fe, 0x00, 0x80);  /* standby */
+		ves1820_writereg(state, 0x1b, 0x02);	/* pdown ADC */
+		ves1820_writereg(state, 0x00, 0x80);	/* standby */
 		break;
 
-        case FE_INIT:
-                return ves1820_init (fe);
-
-        default:
-                return -EINVAL;
-        }
+	case FE_INIT:
+		return ves1820_init(state);
 
-        return 0;
-} 
+	default:
+		return -EINVAL;
+	}
 
+	return 0;
+}
 
-static long probe_tuner (struct dvb_i2c_bus *i2c)
+static long probe_tuner(struct i2c_adapter *i2c)
 {
-	static const struct i2c_msg msg1 = 
-		{ .addr = 0x61, .flags = 0, .buf = NULL, .len = 0 };
-	static const struct i2c_msg msg2 =
-		{ .addr = 0x62, .flags = 0, .buf = NULL, .len = 0 };
+	struct i2c_msg msg1 = {.addr = 0x61,.flags = 0,.buf = NULL,.len = 0 };
+	struct i2c_msg msg2 = {.addr = 0x62,.flags = 0,.buf = NULL,.len = 0 };
 	int type;
 
-	if (i2c->xfer(i2c, &msg1, 1) == 1) {
+	if (i2c_transfer(i2c, &msg1, 1) == 1) {
 		type = 0;
-		printk ("DVB: VES1820(%d): setup for tuner spXXXX\n", i2c->adapter->num);
-	} else if (i2c->xfer(i2c, &msg2, 1) == 1) {
+		printk("ves1820: setup for tuner spXXXX\n");
+	} else if (i2c_transfer(i2c, &msg2, 1) == 1) {
 		type = 1;
-		printk ("DVB: VES1820(%d): setup for tuner sp5659c\n", i2c->adapter->num);
+		printk("ves1820: setup for tuner sp5659c\n");
 	} else {
 		type = -1;
 	}
@@ -495,100 +450,192 @@ static long probe_tuner (struct dvb_i2c_
 	return type;
 }
 
-
-static u8 read_pwm (struct dvb_i2c_bus *i2c)
+static u8 read_pwm(struct i2c_adapter *i2c)
 {
 	u8 b = 0xff;
 	u8 pwm;
-	struct i2c_msg msg [] = { { .addr = 0x50, .flags = 0, .buf = &b, .len = 1 },
-			 { .addr = 0x50, .flags = I2C_M_RD, .buf = &pwm, .len = 1 } };
+	struct i2c_msg msg[] = { {.addr = 0x50,.flags = 0,.buf = &b,.len = 1},
+	{.addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1}
+	};
 
-	if ((i2c->xfer(i2c, msg, 2) != 2) || (pwm == 0xff))
+	if ((i2c_transfer(i2c, msg, 2) != 2) || (pwm == 0xff))
 		pwm = 0x48;
 
-	printk("DVB: VES1820(%d): pwm=0x%02x\n", i2c->adapter->num, pwm);
+	printk("ves1820: pwm=0x%02x\n", pwm);
 
 	return pwm;
 }
 
-
-static long probe_demod_addr (struct dvb_i2c_bus *i2c)
+static long probe_demod_addr(struct i2c_adapter *i2c)
 {
-	u8 b [] = { 0x00, 0x1a };
+	u8 b[] = { 0x00, 0x1a };
 	u8 id;
-	struct i2c_msg msg [] = { { .addr = 0x08, .flags = 0, .buf = b, .len = 2 },
-	                   { .addr = 0x08, .flags = I2C_M_RD, .buf = &id, .len = 1 } };
+	struct i2c_msg msg[] = { {.addr = 0x08,.flags = 0,.buf = b,.len = 2},
+	{.addr = 0x08,.flags = I2C_M_RD,.buf = &id,.len = 1}
+	};
 
-	if (i2c->xfer(i2c, msg, 2) == 2 && (id & 0xf0) == 0x70)
+	if (i2c_transfer(i2c, msg, 2) == 2 && (id & 0xf0) == 0x70)
 		return msg[0].addr;
 
 	msg[0].addr = msg[1].addr = 0x09;
 
-	if (i2c->xfer(i2c, msg, 2) == 2 && (id & 0xf0) == 0x70)
+	if (i2c_transfer(i2c, msg, 2) == 2 && (id & 0xf0) == 0x70)
 		return msg[0].addr;
 
 	return -1;
 }
 
+static ssize_t attr_read_pwm(struct device *dev, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ves1820_state *state = (struct ves1820_state *) i2c_get_clientdata(client);
+	return sprintf(buf, "0x%02x\n", state->pwm);
+}
 
-static int ves1820_attach (struct dvb_i2c_bus *i2c, void **data)
+static ssize_t attr_write_pwm(struct device *dev, const char *buf, size_t count)
 {
-	void *priv = NULL;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ves1820_state *state = (struct ves1820_state *) i2c_get_clientdata(client);
+	unsigned long pwm;
+	pwm = simple_strtoul(buf, NULL, 0);
+	state->pwm = pwm & 0xff;
+	return strlen(buf)+1;
+}
+
+static struct device_attribute dev_attr_client_name = {
+	.attr	= { .name = "pwm", .mode = S_IRUGO|S_IWUGO, .owner = THIS_MODULE },
+	.show	= &attr_read_pwm,
+	.store  = &attr_write_pwm,
+};
+
+static struct i2c_client client_template;
+
+static int attach_adapter(struct i2c_adapter *adapter)
+{
+	struct i2c_client *client;
+	struct ves1820_state *state;
 	long demod_addr;
-	long tuner_type;
+	int tuner_type;
+	int ret;
 
-	if ((demod_addr = probe_demod_addr(i2c)) < 0)
+	demod_addr = probe_demod_addr(adapter);
+	if (demod_addr < 0)
 		return -ENODEV;
 
-	tuner_type = probe_tuner(i2c);
+	tuner_type = probe_tuner(adapter);
+	if (tuner_type < 0) {
+		printk("ves1820: demod found, but unknown tuner type.\n");
+		return -ENODEV;
+	}
 
-	if ((i2c->adapter->num < MAX_UNITS) && pwm[i2c->adapter->num] != -1) {
-		printk("DVB: VES1820(%d): pwm=0x%02x (user specified)\n",
-				i2c->adapter->num, pwm[i2c->adapter->num]);
-		SET_PWM(priv, pwm[i2c->adapter->num]);
+	if ((state = kmalloc(sizeof(struct ves1820_state), GFP_KERNEL)) == NULL) {
+		return -ENOMEM;
 	}
-	else
-		SET_PWM(priv, read_pwm(i2c));
-	SET_REG0(priv, ves1820_inittab[0]);
-	SET_TUNER(priv, tuner_type);
-	SET_DEMOD_ADDR(priv, demod_addr);
 
-	return dvb_register_frontend (ves1820_ioctl, i2c, priv, &ves1820_info);
-}
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		kfree(state);
+		return -ENOMEM;
+	}
 
+	memset(state, 0, sizeof(*state));
+	state->i2c = adapter;
+	state->tuner = tuner_type;
+	state->pwm = read_pwm(adapter);
+	state->reg0 = ves1820_inittab[0];
+	state->demod_addr = demod_addr;
+
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = addr[tuner_type];
+
+	i2c_set_clientdata(client, (void *) state);
+
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
 
-static void ves1820_detach (struct dvb_i2c_bus *i2c, void *data)
-{
-	dvb_unregister_frontend (ves1820_ioctl, i2c);
+	BUG_ON(!state->dvb);
+
+	device_create_file(&client->dev, &dev_attr_client_name);
+
+	ret = dvb_register_frontend(ves1820_ioctl, state->dvb, state, &ves1820_info, THIS_MODULE);
+	if (ret) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(state);
+		return ret;
+	}
+
+	return 0;
 }
 
+static int detach_client(struct i2c_client *client)
+{
+	struct ves1820_state *state = (struct ves1820_state *) i2c_get_clientdata(client);
+	dvb_unregister_frontend(ves1820_ioctl, state->dvb);
+	device_remove_file(&client->dev, &dev_attr_client_name);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
 
-static int __init init_ves1820 (void)
+static int command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	int i;
-	for (i = 0; i < MAX_UNITS; i++)
-		if (pwm[i] < -1 || pwm[i] > 255)
-			return -EINVAL;
-	return dvb_register_i2c_device (THIS_MODULE,
-					ves1820_attach, ves1820_detach);
+	struct ves1820_state *state = (struct ves1820_state *) i2c_get_clientdata(client);
+
+	switch (cmd) {
+	case FE_REGISTER:{
+			state->dvb = (struct dvb_adapter *) arg;
+			break;
+		}
+	case FE_UNREGISTER:{
+			state->dvb = NULL;
+			break;
+		}
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner = THIS_MODULE,
+	.name = "ves1820",
+	.id = I2C_DRIVERID_VES1820,
+	.flags = I2C_DF_NOTIFY,
+	.attach_adapter = attach_adapter,
+	.detach_client = detach_client,
+	.command = command,
+};
 
-static void __exit exit_ves1820 (void)
+static struct i2c_client client_template = {
+	I2C_DEVNAME("ves1820"),
+	.flags = I2C_CLIENT_ALLOW_USE,
+	.driver = &driver,
+};
+
+static int __init init_ves1820(void)
 {
-	dvb_unregister_i2c_device (ves1820_attach);
+	return i2c_add_driver(&driver);
 }
 
+static void __exit exit_ves1820(void)
+{
+	if (i2c_del_driver(&driver))
+		printk("ves1820: driver deregistration failed\n");
+}
 
 module_init(init_ves1820);
 module_exit(exit_ves1820);
 
-MODULE_PARM(pwm, "1-" __MODULE_STRING(MAX_UNITS) "i");
-MODULE_PARM_DESC(pwm, "override PWM value stored in EEPROM (tuner calibration)");
 MODULE_PARM(verbose, "i");
 MODULE_PARM_DESC(verbose, "print AFC offset after tuning for debugging the PWM setting");
 
 MODULE_DESCRIPTION("VES1820 DVB-C frontend driver");
 MODULE_AUTHOR("Ralph Metzler, Holger Waechtler");
 MODULE_LICENSE("GPL");
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/frontends/ves1x93.c linux/drivers/media/dvb/frontends/ves1x93.c
--- linux-2.6.9-rc2/drivers/media/dvb/frontends/ves1x93.c	2004-09-14 10:34:45.000000000 +0200
+++ linux/drivers/media/dvb/frontends/ves1x93.c	2004-09-17 14:56:38.867588317 +0200
@@ -28,9 +28,9 @@
 #include <linux/init.h>
 #include <linux/string.h>
 #include <linux/slab.h>
+#include <linux/delay.h>
 
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
 
 static int debug = 0;
 #define dprintk	if (debug) printk
@@ -49,12 +49,12 @@ static struct dvb_frontend_info ves1x93_
 	.type			= FE_QPSK,
 	.frequency_min		= 950000,
 	.frequency_max		= 2150000,
-	.frequency_stepsize	= 250,           /* kHz for QPSK frontends */
+	.frequency_stepsize	= 125,		 /* kHz for QPSK frontends */
 	.frequency_tolerance	= 29500,
 	.symbol_rate_min	= 1000000,
 	.symbol_rate_max	= 45000000,
-/*      .symbol_rate_tolerance	=	???,*/
-	.notifier_delay		= 50,                /* 1/20 s */
+/*	.symbol_rate_tolerance	=	???,*/
+	.notifier_delay		= 50,		     /* 1/20 s */
 	.caps = FE_CAN_INVERSION_AUTO |
 		FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
 		FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
@@ -95,10 +95,10 @@ static u8 * init_1x93_tab;
 
 static u8 init_1893_wtab[] =
 {
-        1,1,1,1,1,1,1,1, 1,1,0,0,1,1,0,0,
-        0,1,0,0,0,0,0,0, 1,0,1,1,0,0,0,1,
-        1,1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0,
-        1,1,1,0,1,1
+	1,1,1,1,1,1,1,1, 1,1,0,0,1,1,0,0,
+	0,1,0,0,0,0,0,0, 1,0,1,1,0,0,0,1,
+	1,1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0,
+	1,1,1,0,1,1
 };
 
 
@@ -112,26 +112,28 @@ static u8 init_1993_wtab[] =
 
 struct ves1x93_state {
 	fe_spectral_inversion_t inversion;
+	struct i2c_adapter *i2c;
+	struct dvb_adapter *dvb;
 };
 
 
 
-static int ves1x93_writereg (struct dvb_i2c_bus *i2c, u8 reg, u8 data)
+static int ves1x93_writereg (struct i2c_adapter *i2c, u8 reg, u8 data)
 {
-        u8 buf [] = { 0x00, reg, data };
+	u8 buf [] = { 0x00, reg, data };
 	struct i2c_msg msg = { .addr = 0x08, .flags = 0, .buf = buf, .len = 3 };
 	int err;
 
-        if ((err = i2c->xfer (i2c, &msg, 1)) != 1) {
+	if ((err = i2c_transfer (i2c, &msg, 1)) != 1) {
 		dprintk ("%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\n", __FUNCTION__, err, reg, data);
 		return -EREMOTEIO;
 	}
 
-        return 0;
+	return 0;
 }
 
 
-static u8 ves1x93_readreg (struct dvb_i2c_bus *i2c, u8 reg)
+static u8 ves1x93_readreg (struct i2c_adapter *i2c, u8 reg)
 {
 	int ret;
 	u8 b0 [] = { 0x00, reg };
@@ -139,7 +141,7 @@ static u8 ves1x93_readreg (struct dvb_i2
 	struct i2c_msg msg [] = { { .addr = 0x08, .flags = 0, .buf = b0, .len = 2 },
 			   { .addr = 0x08, .flags = I2C_M_RD, .buf = b1, .len = 1 } };
 
-	ret = i2c->xfer (i2c, msg, 2);
+	ret = i2c_transfer (i2c, msg, 2);
 
 	if (ret != 2)
 		dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
@@ -148,19 +150,19 @@ static u8 ves1x93_readreg (struct dvb_i2
 }
 
 
-static int tuner_write (struct dvb_i2c_bus *i2c, u8 *data, u8 len)
+static int tuner_write (struct i2c_adapter *i2c, u8 *data, u8 len)
 {
-        int ret;
-        struct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = len };
+	int ret;
+	struct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = len };
 
 	ves1x93_writereg(i2c, 0x00, 0x11);
-        ret = i2c->xfer (i2c, &msg, 1);
+	ret = i2c_transfer (i2c, &msg, 1);
 	ves1x93_writereg(i2c, 0x00, 0x01);
 
-        if (ret != 1)
-                printk("%s: i/o error (ret == %i)\n", __FUNCTION__, ret);
+	if (ret != 1)
+		printk("%s: i/o error (ret == %i)\n", __FUNCTION__, ret);
 
-        return (ret != 1) ? -1 : 0;
+	return (ret != 1) ? -1 : 0;
 }
 
 
@@ -169,16 +171,32 @@ static int tuner_write (struct dvb_i2c_b
  *   set up the downconverter frequency divisor for a
  *   reference clock comparision frequency of 125 kHz.
  */
-static int sp5659_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq, u8 pwr)
+static int sp5659_set_tv_freq (struct i2c_adapter *i2c, u32 freq)
 {
-        u32 div = (freq + 479500) / 125;
-	u8 buf [4] = { (div >> 8) & 0x7f, div & 0xff, 0x95, (pwr << 5) | 0x30 };
+	u8 pwr = 0;
+   	u8 buf[4];
+	u32 div = (freq + 479500) / 125;
+   
+	if (freq > 2000000) pwr = 3;
+	else if (freq > 1800000) pwr = 2;
+	else if (freq > 1600000) pwr = 1;
+	else if (freq > 1200000) pwr = 0;
+	else if (freq >= 1100000) pwr = 1;
+	else pwr = 2;
+
+   	buf[0] = (div >> 8) & 0x7f;
+   	buf[1] = div & 0xff;
+   	buf[2] = ((div & 0x18000) >> 10) | 0x95;
+   	buf[3] = (pwr << 6) | 0x30;
+   	
+   	// NOTE: since we're using a prescaler of 2, we set the
+	// divisor frequency to 62.5kHz and divide by 125 above
 
 	return tuner_write (i2c, buf, sizeof(buf));
 }
 
 
-static int tsa5059_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq)
+static int tsa5059_set_tv_freq (struct i2c_adapter *i2c, u32 freq)
 {
 	int ret;
 	u8 buf [2];
@@ -194,10 +212,10 @@ static int tsa5059_set_tv_freq (struct d
 }
 
 
-static int tuner_set_tv_freq (struct dvb_i2c_bus *i2c, u32 freq, u8 pwr)
+static int tuner_set_tv_freq (struct i2c_adapter *i2c, u32 freq)
 {
 	if ((demod_type == DEMOD_VES1893) && (board_type == BOARD_SIEMENS_PCI))
-		return sp5659_set_tv_freq (i2c, freq, pwr);
+		return sp5659_set_tv_freq (i2c, freq);
 	else if (demod_type == DEMOD_VES1993)
 		return tsa5059_set_tv_freq (i2c, freq);
 
@@ -205,7 +223,7 @@ static int tuner_set_tv_freq (struct dvb
 }
 
 
-static int ves1x93_init (struct dvb_i2c_bus *i2c)
+static int ves1x93_init (struct i2c_adapter *i2c)
 {
 	int i;
 	int size;
@@ -249,24 +267,16 @@ static int ves1x93_init (struct dvb_i2c_
 }
 
 
-static int ves1x93_clr_bit (struct dvb_i2c_bus *i2c)
-{
-        ves1x93_writereg (i2c, 0, init_1x93_tab[0] & 0xfe);
-        ves1x93_writereg (i2c, 0, init_1x93_tab[0]);
-	dvb_delay(5);
-	return 0;
-}
-
-static int ves1x93_init_aquire (struct dvb_i2c_bus *i2c)
+static int ves1x93_clr_bit (struct i2c_adapter *i2c)
 {
-        ves1x93_writereg (i2c, 3, 0x00);
-	ves1x93_writereg (i2c, 3, init_1x93_tab[3]);
-	dvb_delay(5);
+	msleep(10);
+	ves1x93_writereg (i2c, 0, init_1x93_tab[0] & 0xfe);
+	ves1x93_writereg (i2c, 0, init_1x93_tab[0]);
+	msleep(50);
 	return 0;
 }
 
-
-static int ves1x93_set_inversion (struct dvb_i2c_bus *i2c, fe_spectral_inversion_t inversion)
+static int ves1x93_set_inversion (struct i2c_adapter *i2c, fe_spectral_inversion_t inversion)
 {
 	u8 val;
 
@@ -293,7 +303,7 @@ static int ves1x93_set_inversion (struct
 }
 
 
-static int ves1x93_set_fec (struct dvb_i2c_bus *i2c, fe_code_rate_t fec)
+static int ves1x93_set_fec (struct i2c_adapter *i2c, fe_code_rate_t fec)
 {
 	if (fec == FEC_AUTO)
 		return ves1x93_writereg (i2c, 0x0d, 0x08);
@@ -304,16 +314,16 @@ static int ves1x93_set_fec (struct dvb_i
 }
 
 
-static fe_code_rate_t ves1x93_get_fec (struct dvb_i2c_bus *i2c)
+static fe_code_rate_t ves1x93_get_fec (struct i2c_adapter *i2c)
 {
 	return FEC_1_2 + ((ves1x93_readreg (i2c, 0x0d) >> 4) & 0x7);
 }
 
 
-static int ves1x93_set_symbolrate (struct dvb_i2c_bus *i2c, u32 srate)
+static int ves1x93_set_symbolrate (struct i2c_adapter *i2c, u32 srate)
 {
 	u32 BDR;
-        u32 ratio;
+	u32 ratio;
 	u8  ADCONF, FCONF, FNR;
 	u32 BDRI;
 	u32 tmp;
@@ -361,15 +371,15 @@ static int ves1x93_set_symbolrate (struc
 
 	FNR = 0xff;
 
-	if (ratio < MUL/3)           FNR = 0;
+	if (ratio < MUL/3)	     FNR = 0;
 	if (ratio < (MUL*11)/50)     FNR = 1;
-	if (ratio < MUL/6)           FNR = 2;
-	if (ratio < MUL/9)           FNR = 3;
-	if (ratio < MUL/12)          FNR = 4;
+	if (ratio < MUL/6)	     FNR = 2;
+	if (ratio < MUL/9)	     FNR = 3;
+	if (ratio < MUL/12)	     FNR = 4;
 	if (ratio < (MUL*11)/200)    FNR = 5;
-	if (ratio < MUL/24)          FNR = 6;
+	if (ratio < MUL/24)	     FNR = 6;
 	if (ratio < (MUL*27)/1000)   FNR = 7;
-	if (ratio < MUL/48)          FNR = 8;
+	if (ratio < MUL/48)	     FNR = 8;
 	if (ratio < (MUL*137)/10000) FNR = 9;
 
 	if (FNR == 0xff) {
@@ -379,16 +389,16 @@ static int ves1x93_set_symbolrate (struc
 	} else {
 		ADCONF = 0x81;
 		FCONF  = 0x88 | (FNR >> 1) | ((FNR & 0x01) << 5);
-		/*FCONF  = 0x80 | ((FNR & 0x01) << 5) | (((FNR > 1) & 0x03) << 3) | ((FNR >> 1) & 0x07);*/
+		/*FCONF	 = 0x80 | ((FNR & 0x01) << 5) | (((FNR > 1) & 0x03) << 3) | ((FNR >> 1) & 0x07);*/
 	}
 
 	BDR = (( (ratio << (FNR >> 1)) >> 4) + 1) >> 1;
 	BDRI = ( ((FIN << 8) / ((srate << (FNR >> 1)) >> 2)) + 1) >> 1;
 
-        dprintk("FNR= %d\n", FNR);
-        dprintk("ratio= %08x\n", (unsigned int) ratio);
-        dprintk("BDR= %08x\n", (unsigned int) BDR);
-        dprintk("BDRI= %02x\n", (unsigned int) BDRI);
+	dprintk("FNR= %d\n", FNR);
+	dprintk("ratio= %08x\n", (unsigned int) ratio);
+	dprintk("BDR= %08x\n", (unsigned int) BDR);
+	dprintk("BDRI= %02x\n", (unsigned int) BDRI);
 
 	if (BDRI > 0xff)
 		BDRI = 0xff;
@@ -413,27 +423,7 @@ static int ves1x93_set_symbolrate (struc
 	return 0;
 }
 
-
-static int ves1x93_afc (struct dvb_i2c_bus *i2c, u32 freq, u32 srate)
-{
-	int afc;
-
-	afc = ((int)((ves1x93_readreg (i2c, 0x0a) << 1) & 0xff))/2;
-	afc = (afc * (int)(srate/1000/8))/16;
-    
-	if (afc) {
-	
-		freq -= afc;
-
-		tuner_set_tv_freq (i2c, freq, 0);
-
-		ves1x93_init_aquire (i2c);
-	}
-       
-	return 0;
-}
-
-static int ves1x93_set_voltage (struct dvb_i2c_bus *i2c, fe_sec_voltage_t voltage)
+static int ves1x93_set_voltage (struct i2c_adapter *i2c, fe_sec_voltage_t voltage)
 {
 	switch (voltage) {
 	case SEC_VOLTAGE_13:
@@ -450,19 +440,34 @@ static int ves1x93_set_voltage (struct d
 
 static int ves1x93_ioctl (struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-	struct dvb_i2c_bus *i2c = fe->i2c;
-	struct ves1x93_state *state = (struct ves1x93_state*) fe->data;
+	struct ves1x93_state *state = (struct ves1x93_state *) fe->data;
+	struct i2c_adapter *i2c = state->i2c;
 
-        switch (cmd) {
-        case FE_GET_INFO:
+	switch (cmd) {
+	case FE_GET_INFO:
 		memcpy (arg, &ves1x93_info, sizeof(struct dvb_frontend_info));
 		break;
 
-        case FE_READ_STATUS:
+	case FE_READ_STATUS:
 	{
 		fe_status_t *status = arg;
 		u8 sync = ves1x93_readreg (i2c, 0x0e);
 
+		/*
+		 * The ves1893 sometimes returns sync values that make no sense,
+		 * because, e.g., the SIGNAL bit is 0, while some of the higher
+		 * bits are 1 (and how can there be a CARRIER w/o a SIGNAL?).
+		 * Tests showed that the the VITERBI and SYNC bits are returned
+		 * reliably, while the SIGNAL and CARRIER bits ar sometimes wrong.
+		 * If such a case occurs, we read the value again, until we get a
+		 * valid value.
+		 */
+		int maxtry = 10; /* just for safety - let's not get stuck here */
+		while ((sync & 0x03) != 0x03 && (sync & 0x0c) && maxtry--) {
+			msleep(10);
+			sync = ves1x93_readreg (i2c, 0x0e);
+		}
+
 		*status = 0;
 
 		if (sync & 1)
@@ -483,25 +488,25 @@ static int ves1x93_ioctl (struct dvb_fro
 		break;
 	}
 
-        case FE_READ_BER:
+	case FE_READ_BER:
 	{
 		u32 *ber = (u32 *) arg;
 
 		*ber = ves1x93_readreg (i2c, 0x15);
-                *ber |= (ves1x93_readreg (i2c, 0x16) << 8);
-                *ber |= ((ves1x93_readreg (i2c, 0x17) & 0x0F) << 16);
+		*ber |= (ves1x93_readreg (i2c, 0x16) << 8);
+		*ber |= ((ves1x93_readreg (i2c, 0x17) & 0x0F) << 16);
 		*ber *= 10;
 		break;
 	}
 
-        case FE_READ_SIGNAL_STRENGTH:
+	case FE_READ_SIGNAL_STRENGTH:
 	{
 		u8 signal = ~ves1x93_readreg (i2c, 0x0b);
 		*((u16*) arg) = (signal << 8) | signal;
 		break;
 	}
 
-        case FE_READ_SNR:
+	case FE_READ_SNR:
 	{
 		u8 snr = ~ves1x93_readreg (i2c, 0x1c);
 		*(u16*) arg = (snr << 8) | snr;
@@ -520,18 +525,17 @@ static int ves1x93_ioctl (struct dvb_fro
 		break;
 	}
 
-        case FE_SET_FRONTEND:
-        {
+	case FE_SET_FRONTEND:
+	{
 		struct dvb_frontend_parameters *p = arg;
 
-		tuner_set_tv_freq (i2c, p->frequency, 0);
+		tuner_set_tv_freq (i2c, p->frequency);
 		ves1x93_set_inversion (i2c, p->inversion);
 		ves1x93_set_fec (i2c, p->u.qpsk.fec_inner);
 		ves1x93_set_symbolrate (i2c, p->u.qpsk.symbol_rate);
-		ves1x93_afc (i2c, p->frequency, p->u.qpsk.symbol_rate);	    
 		state->inversion = p->inversion;
-                break;
-        }
+		break;
+	}
 
 	case FE_GET_FRONTEND:
 	{
@@ -555,35 +559,38 @@ static int ves1x93_ioctl (struct dvb_fro
 		break;
 	}
 
-        case FE_SLEEP:
+	case FE_SLEEP:
 		if (board_type == BOARD_SIEMENS_PCI)
 			ves1x93_writereg (i2c, 0x1f, 0x00);    /*  LNB power off  */
 		return ves1x93_writereg (i2c, 0x00, 0x08);
 
-        case FE_INIT:
+	case FE_INIT:
 		return ves1x93_init (i2c);
 
 	case FE_SET_TONE:
 		return -EOPNOTSUPP;  /* the ves1893 can generate the 22k */
-		                     /* let's implement this when we have */
-		                     /* a box that uses the 22K_0 pin... */
+				     /* let's implement this when we have */
+				     /* a box that uses the 22K_0 pin... */
 
 	case FE_SET_VOLTAGE:
 		return ves1x93_set_voltage (i2c, (fe_sec_voltage_t) arg);
 
 	default:
 		return -EOPNOTSUPP;
-        };
-        
-        return 0;
+	};
+	
+	return 0;
 } 
 
+static struct i2c_client client_template;
 
-static int ves1x93_attach (struct dvb_i2c_bus *i2c, void **data)
+static int attach_adapter(struct i2c_adapter *adapter)
 {
-	u8 identity = ves1x93_readreg(i2c, 0x1e);
+	struct i2c_client *client;
 	struct ves1x93_state* state;
-
+	u8 identity = ves1x93_readreg(adapter, 0x1e);
+	int ret;
+	
 	switch (identity) {
 	case 0xdc: /* VES1893A rev1 */
 		printk("ves1x93: Detected ves1893a rev1\n");
@@ -608,19 +615,88 @@ static int ves1x93_attach (struct dvb_i2
 	if ((state = kmalloc(sizeof(struct ves1x93_state), GFP_KERNEL)) == NULL) {
 		return -ENOMEM;
 	}
+
+	if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
 	state->inversion = INVERSION_OFF;
-	*data = state;
+	state->i2c = adapter;
+	
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adapter;
+	client->addr = (0x08>>1);
+	i2c_set_clientdata(client, (void*)state);
+	
+	ret = i2c_attach_client(client);
+	if (ret) {
+		kfree(client);
+		kfree(state);
+		return -EFAULT;
+	}
+
+	BUG_ON(!state->dvb);
+
+	ret = dvb_register_frontend(ves1x93_ioctl, state->dvb, state,
+					&ves1x93_info, THIS_MODULE);
+	if (ret) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(state);
+		return -EFAULT;
+	}
 
-	return dvb_register_frontend (ves1x93_ioctl, i2c, (void*) state, &ves1x93_info);
+	return 0;
 }
 
+static int detach_client(struct i2c_client *client)
+{
+	struct ves1x93_state *state = (struct ves1x93_state*)i2c_get_clientdata(client);
+	dvb_unregister_frontend(ves1x93_ioctl, state->dvb);
+	i2c_detach_client(client);
+	BUG_ON(state->dvb);
+	kfree(client);
+	kfree(state);
+	return 0;
+}
 
-static void ves1x93_detach (struct dvb_i2c_bus *i2c, void *data)
+static int command (struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	kfree(data);
-	dvb_unregister_frontend (ves1x93_ioctl, i2c);
+	struct ves1x93_state *state = (struct ves1x93_state*)i2c_get_clientdata(client);
+
+	dprintk ("%s\n", __FUNCTION__);
+
+	switch (cmd) {
+	case FE_REGISTER: {
+		state->dvb = (struct dvb_adapter*)arg;
+		break;
+	}
+	case FE_UNREGISTER: {
+		state->dvb = NULL;
+		break;
+	}
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
 }
 
+static struct i2c_driver driver = {
+	.owner 		= THIS_MODULE,
+	.name 		= "ves1x93",
+	.id 		= I2C_DRIVERID_DVBFE_VES1X93,
+	.flags 		= I2C_DF_NOTIFY,
+	.attach_adapter = attach_adapter,
+	.detach_client 	= detach_client,
+	.command 	= command,
+};
+
+static struct i2c_client client_template = {
+	I2C_DEVNAME("ves1x93"),
+	.flags 		= I2C_CLIENT_ALLOW_USE,
+	.driver  	= &driver,
+};
 
 static int __init init_ves1x93 (void)
 {
@@ -638,16 +714,16 @@ static int __init init_ves1x93 (void)
 		return -EIO;
 	}
 
-	return dvb_register_i2c_device (THIS_MODULE, ves1x93_attach, ves1x93_detach);
+	return i2c_add_driver(&driver);
 }
 
 
 static void __exit exit_ves1x93 (void)
 {
-	dvb_unregister_i2c_device (ves1x93_attach);
+	if (i2c_del_driver(&driver))
+		printk("vex1x93: driver deregistration failed\n");
 }
 
-
 module_init(init_ves1x93);
 module_exit(exit_ves1x93);
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/Kconfig linux/drivers/media/dvb/ttpci/Kconfig
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/Kconfig	2004-09-14 10:34:45.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/Kconfig	2004-09-17 14:56:38.869587942 +0200
@@ -1,6 +1,6 @@
 config DVB_AV7110
 	tristate "AV7110 cards"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE
 	select FW_LOADER
 	select VIDEO_DEV
 	select VIDEO_SAA7146_VV
@@ -11,11 +11,16 @@ config DVB_AV7110
 	  This driver only supports the fullfeatured cards with
 	  onboard MPEG2 decoder.
 
+          This driver needs an external firmware. Please use the script
+          "<kerneldir>/Documentation/dvb/get_dvb_firmware av7110" to
+          download/extract it, and then copy it to /usr/lib/hotplug/firmware.
+
 	  Say Y if you own such a card and want to use it.
 
 config DVB_AV7110_FIRMWARE
 	bool "Compile AV7110 firmware into the driver"
 	depends on DVB_AV7110 && !STANDALONE
+	default y if DVB_AV7110=y
 	help
 	  The AV7110 firmware is normally loaded by the firmware hotplug manager.
 	  If you want to compile the firmware into the driver you need to say
@@ -33,6 +38,7 @@ config DVB_AV7110_FIRMWARE_FILE
 config DVB_AV7110_OSD
 	bool "AV7110 OSD support"
 	depends on DVB_AV7110
+	default y if DVB_AV7110=y || DVB_AV7110=m
 	help
 	  The AV7110 firmware provides some code to generate an OnScreenDisplay
 	  on the video output. This is kind of nonstandard and not guaranteed to
@@ -45,7 +51,7 @@ config DVB_AV7110_OSD
 
 config DVB_BUDGET
 	tristate "Budget cards"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE
 	select VIDEO_SAA7146
 	help
 	  Support for simple SAA7146 based DVB cards
@@ -59,7 +65,7 @@ config DVB_BUDGET
 
 config DVB_BUDGET_CI
 	tristate "Budget cards with onboard CI connector"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE
 	select VIDEO_SAA7146
 	help
 	  Support for simple SAA7146 based DVB cards
@@ -76,7 +82,7 @@ config DVB_BUDGET_CI
 
 config DVB_BUDGET_AV
 	tristate "Budget cards with analog video inputs"
-	depends on DVB_CORE && PCI
+	depends on DVB_CORE
 	select VIDEO_DEV
 	select VIDEO_SAA7146_VV
 	help
@@ -91,7 +97,7 @@ config DVB_BUDGET_AV
 
 config DVB_BUDGET_PATCH
 	tristate "AV7110 cards with Budget Patch"
-	depends on DVB_BUDGET
+	depends on DVB_CORE && DVB_BUDGET
 	select DVB_AV7110
 	help
 	  Support for Budget Patch (full TS) modification on 
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/Makefile linux/drivers/media/dvb/ttpci/Makefile
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/Makefile	2004-09-14 10:34:46.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/Makefile	2004-09-17 14:56:38.871587568 +0200
@@ -13,7 +13,7 @@ obj-$(CONFIG_DVB_AV7110) += dvb-ttpci.o 
 
 EXTRA_CFLAGS = -Idrivers/media/dvb/dvb-core/
 
-hostprogs-y	:= fdump
+host-progs	:= fdump
 
 ifdef CONFIG_DVB_AV7110_FIRMWARE
 $(obj)/av7110.o: $(obj)/fdump $(obj)/av7110_firm.h 
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110.c linux/drivers/media/dvb/ttpci/av7110.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110.c	2004-09-14 10:36:42.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110.c	2004-09-17 14:56:38.880585882 +0200
@@ -2,7 +2,7 @@
  * driver for the SAA7146 based AV110 cards (like the Fujitsu-Siemens DVB)
  * av7110.c: initialization and demux stuff
  *
- * Copyright (C) 1999-2002 Ralph  Metzler 
+ * Copyright (C) 1999-2002 Ralph  Metzler
  *                       & Marcus Metzler for convergence integrated media GmbH
  *
  * originally based on code by:
@@ -12,19 +12,19 @@
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
- * 
+ *
  *
  * the project's page is at http://www.linuxtv.org/dvb/
  */
@@ -41,6 +41,7 @@
 #include <linux/smp_lock.h>
 
 #include <linux/kernel.h>
+#include <linux/moduleparam.h>
 #include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/fcntl.h>
@@ -50,18 +51,14 @@
 #include <linux/vmalloc.h>
 #include <linux/firmware.h>
 #include <linux/crc32.h>
+#include <linux/i2c.h>
 
 #include <asm/system.h>
 #include <asm/semaphore.h>
 
 #include <linux/dvb/frontend.h>
 
-#include "dvb_i2c.h"
 #include "dvb_frontend.h"
-#include "dvb_functions.h"
-
-
-	#define DEBUG_VARIABLE av7110_debug
 
 #include "ttpci-eeprom.h"
 #include "av7110.h"
@@ -70,27 +67,94 @@
 #include "av7110_ca.h"
 #include "av7110_ipack.h"
 
+static int av7110_debug;
+static int vidmode = CVBS_RGB_OUT;
+static int pids_off;
+static int adac = DVB_ADAC_TI;
+static int hw_sections;
+static int rgb_on;
+static int volume = 255;
+
+module_param_named(debug, av7110_debug, int, 0644);
+MODULE_PARM_DESC(av7110_debug, "Turn on/off debugging (default:off).");
+module_param(vidmode, int, 0444);
+MODULE_PARM_DESC(vidmode,"analog video out: 0 off, 1 CVBS+RGB (default), 2 CVBS+YC, 3 YC");
+module_param(pids_off, int, 0444);
+MODULE_PARM_DESC(pids_off,"clear video/audio/PCR PID filters when demux is closed");
+module_param(adac, int, 0444);
+MODULE_PARM_DESC(adac,"audio DAC type: 0 TI, 1 CRYSTAL, 2 MSP (use if autodetection fails)");
+module_param(hw_sections, int, 0444);
+MODULE_PARM_DESC(hw_sections, "0 use software section filter, 1 use hardware");
+module_param(rgb_on, int, 0444);
+MODULE_PARM_DESC(rgb_on, "For Siemens DVB-C cards only: Enable RGB control"
+		" signal on SCART pin 16 to switch SCART video mode from CVBS to RGB");
+module_param(volume, int, 0444);
+MODULE_PARM_DESC(volume, "initial volume: default 255 (range 0-255)");
 
 static void restart_feeds(struct av7110 *av7110);
 
-int av7110_debug = 0;
+int av7110_num = 0;
 
-static int vidmode=CVBS_RGB_OUT;
-static int pids_off;
-static int adac=DVB_ADAC_TI;
-static int hw_sections = 0;
-static int rgb_on = 0;
+static void init_av7110_av(struct av7110 *av7110)
+{
+	struct saa7146_dev *dev=av7110->dev;
 
-int av7110_num = 0;
+	/* set internal volume control to maximum */
+	av7110->adac_type = DVB_ADAC_TI;
+	av7110_set_volume(av7110, av7110->mixer.volume_left, av7110->mixer.volume_right);
+
+	av7710_set_video_mode(av7110, vidmode);
+
+	/* handle different card types */
+	/* remaining inits according to card and frontend type */
+	av7110->has_analog_tuner = 0;
+	av7110->current_input = 0;
+	if (i2c_writereg(av7110, 0x20, 0x00, 0x00) == 1) {
+		printk ("av7110(%d): Crystal audio DAC detected\n",
+			av7110->dvb_adapter->num);
+		av7110->adac_type = DVB_ADAC_CRYSTAL;
+		i2c_writereg(av7110, 0x20, 0x01, 0xd2);
+		i2c_writereg(av7110, 0x20, 0x02, 0x49);
+		i2c_writereg(av7110, 0x20, 0x03, 0x00);
+		i2c_writereg(av7110, 0x20, 0x04, 0x00);
+
+	/**
+	 * some special handling for the Siemens DVB-C cards...
+	 */
+	} else if (0 == av7110_init_analog_module(av7110)) {
+		/* done. */
+	}
+	else if (dev->pci->subsystem_vendor == 0x110a) {
+		printk("av7110(%d): DVB-C w/o analog module detected\n",
+			av7110->dvb_adapter->num);
+		av7110->adac_type = DVB_ADAC_NONE;
+	}
+	else {
+		av7110->adac_type = adac;
+		printk("av7110(%d): adac type set to %d\n",
+			av7110->dvb_adapter->num, av7110->adac_type);
+	}
 
+	if (av7110->adac_type == DVB_ADAC_NONE || av7110->adac_type == DVB_ADAC_MSP) {
+		// switch DVB SCART on
+		av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, MainSwitch, 1, 0);
+		av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, ADSwitch, 1, 1);
+		if (rgb_on)
+			saa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI); // RGB on, SCART pin 16
+		//saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO); // SCARTpin 8
+	}
+
+	av7110_set_volume(av7110, av7110->mixer.volume_left, av7110->mixer.volume_right);
+	av7110_setup_irc_config(av7110, 0);
+}
 
 static void recover_arm(struct av7110 *av7110)
 {
 	DEB_EE(("av7110: %p\n",av7110));
 
 	av7110_bootarm(av7110);
-        dvb_delay(100); 
-        restart_feeds(av7110);
+	msleep(100);
+	restart_feeds(av7110);
 	av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, SetIR, 1, av7110->ir_config);
 }
 
@@ -98,20 +162,24 @@ static void arm_error(struct av7110 *av7
 {
 	DEB_EE(("av7110: %p\n",av7110));
 
-        av7110->arm_errors++;
-        av7110->arm_ready=0;
-        recover_arm(av7110);
+	av7110->arm_errors++;
+	av7110->arm_ready = 0;
+	recover_arm(av7110);
 }
 
 static int arm_thread(void *data)
 {
 	struct av7110 *av7110 = data;
-	unsigned long timeout;
-        u16 newloops = 0;
+	u16 newloops = 0;
+	int timeout;
 
 	DEB_EE(("av7110: %p\n",av7110));
-	
-	dvb_kernel_thread_setup ("arm_mon");
+
+        lock_kernel ();
+        daemonize ("arm_mon");
+        sigfillset (&current->blocked);
+        unlock_kernel ();
+
 	av7110->arm_thread = current;
 
 	while (1) {
@@ -121,28 +189,31 @@ static int arm_thread(void *data)
 			break;
 		}
 
-                if (!av7110->arm_ready)
-                        continue;
+		if (!av7110->arm_ready)
+			continue;
 
-                if (down_interruptible(&av7110->dcomlock))
-                        break;
+		if (down_interruptible(&av7110->dcomlock))
+			break;
 
-                newloops=rdebi(av7110, DEBINOSWAP, STATUS_LOOPS, 0, 2);
-                up(&av7110->dcomlock);
+		newloops = rdebi(av7110, DEBINOSWAP, STATUS_LOOPS, 0, 2);
+		up(&av7110->dcomlock);
 
-                if (newloops==av7110->arm_loops) {
-                        printk(KERN_ERR "av7110%d: ARM crashed!\n",
-				av7110->dvb_adapter->num);
+		if (newloops == av7110->arm_loops) {
+			printk(KERN_ERR "av7110%d: ARM crashed!\n",
+			       av7110->dvb_adapter->num);
 
 			arm_error(av7110);
+			av7710_set_video_mode(av7110, vidmode);
 
-                        if (down_interruptible(&av7110->dcomlock))
-                                break;
+			init_av7110_av(av7110);
 
-                        newloops=rdebi(av7110, DEBINOSWAP, STATUS_LOOPS, 0, 2)-1;
-                        up(&av7110->dcomlock);
-                }
-                av7110->arm_loops=newloops;
+			if (down_interruptible(&av7110->dcomlock))
+				break;
+
+			newloops = rdebi(av7110, DEBINOSWAP, STATUS_LOOPS, 0, 2) - 1;
+			up(&av7110->dcomlock);
+		}
+		av7110->arm_loops = newloops;
 	}
 
 	av7110->arm_thread = NULL;
@@ -152,11 +223,11 @@ static int arm_thread(void *data)
 
 /**
  *  Hack! we save the last av7110 ptr. This should be ok, since
- *  you rarely will use more then one IR control. 
+ *  you rarely will use more then one IR control.
  *
  *  If we want to support multiple controls we would have to do much more...
  */
-void av7110_setup_irc_config (struct av7110 *av7110, u32 ir_config)
+void av7110_setup_irc_config(struct av7110 *av7110, u32 ir_config)
 {
 	static struct av7110 *last;
 
@@ -175,31 +246,31 @@ void av7110_setup_irc_config (struct av7
 
 static void (*irc_handler)(u32);
 
-void av7110_register_irc_handler(void (*func)(u32)) 
+void av7110_register_irc_handler(void (*func)(u32))
 {
 	DEB_EE(("registering %p\n", func));
-        irc_handler = func;
+	irc_handler = func;
 }
 
-void av7110_unregister_irc_handler(void (*func)(u32)) 
+void av7110_unregister_irc_handler(void (*func)(u32))
 {
 	DEB_EE(("unregistering %p\n", func));
-        irc_handler = NULL;
+	irc_handler = NULL;
 }
 
-void run_handlers(unsigned long ircom) 
+void run_handlers(unsigned long ircom)
 {
-        if (irc_handler != NULL)
-                (*irc_handler)((u32) ircom);
+	if (irc_handler != NULL)
+		(*irc_handler)((u32) ircom);
 }
 
-DECLARE_TASKLET(irtask,run_handlers,0);
+DECLARE_TASKLET(irtask, run_handlers, 0);
 
 void IR_handle(struct av7110 *av7110, u32 ircom)
 {
 	DEB_S(("av7110: ircommand = %08x\n", ircom));
-        irtask.data = (unsigned long) ircom;
-        tasklet_schedule(&irtask);
+	irtask.data = (unsigned long) ircom;
+	tasklet_schedule(&irtask);
 }
 
 /****************************************************************************
@@ -207,53 +278,53 @@ void IR_handle(struct av7110 *av7110, u3
  ****************************************************************************/
 
 static inline int DvbDmxFilterCallback(u8 * buffer1, size_t buffer1_len,
-                     u8 * buffer2, size_t buffer2_len,
-                     struct dvb_demux_filter *dvbdmxfilter,
-                     enum dmx_success success,
-                     struct av7110 *av7110)
-{
-	DEB_INT(("av7110: %p\n",av7110));
-
-        if (!dvbdmxfilter->feed->demux->dmx.frontend)
-                return 0;
-        if (dvbdmxfilter->feed->demux->dmx.frontend->source==DMX_MEMORY_FE)
-                return 0;
-        
-        switch(dvbdmxfilter->type) {
-        case DMX_TYPE_SEC:
-                if ((((buffer1[1]<<8)|buffer1[2])&0xfff)+3!=buffer1_len)
-                        return 0;
-                if (dvbdmxfilter->doneq) {
-                        struct dmx_section_filter *filter=&dvbdmxfilter->filter;
-                        int i;
-                        u8 xor, neq=0;
-                        
-                        for (i=0; i<DVB_DEMUX_MASK_MAX; i++) {
-                                xor=filter->filter_value[i]^buffer1[i];
-                                neq|=dvbdmxfilter->maskandnotmode[i]&xor;
-                        }
-                        if (!neq)
-                                return 0;
-                }
-                return dvbdmxfilter->feed->cb.sec(buffer1, buffer1_len,
+		     u8 * buffer2, size_t buffer2_len,
+		     struct dvb_demux_filter *dvbdmxfilter,
+		     enum dmx_success success,
+		     struct av7110 *av7110)
+{
+	DEB_INT(("av7110: %p\n", av7110));
+
+	if (!dvbdmxfilter->feed->demux->dmx.frontend)
+		return 0;
+	if (dvbdmxfilter->feed->demux->dmx.frontend->source == DMX_MEMORY_FE)
+		return 0;
+
+	switch (dvbdmxfilter->type) {
+	case DMX_TYPE_SEC:
+		if ((((buffer1[1] << 8) | buffer1[2]) & 0xfff) + 3 != buffer1_len)
+			return 0;
+		if (dvbdmxfilter->doneq) {
+			struct dmx_section_filter *filter = &dvbdmxfilter->filter;
+			int i;
+			u8 xor, neq = 0;
+
+			for (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {
+				xor = filter->filter_value[i] ^ buffer1[i];
+				neq |= dvbdmxfilter->maskandnotmode[i] & xor;
+			}
+			if (!neq)
+				return 0;
+		}
+		return dvbdmxfilter->feed->cb.sec(buffer1, buffer1_len,
 						  buffer2, buffer2_len,
 						  &dvbdmxfilter->filter,
-						  DMX_OK); 
-        case DMX_TYPE_TS:
-                if (!(dvbdmxfilter->feed->ts_type & TS_PACKET)) 
-                        return 0;
-                if (dvbdmxfilter->feed->ts_type & TS_PAYLOAD_ONLY) 
-                        return dvbdmxfilter->feed->cb.ts(buffer1, buffer1_len,
-                                                         buffer2, buffer2_len,
-                                                         &dvbdmxfilter->feed->feed.ts,
-                                                         DMX_OK); 
-                else
+						  DMX_OK);
+	case DMX_TYPE_TS:
+		if (!(dvbdmxfilter->feed->ts_type & TS_PACKET))
+			return 0;
+		if (dvbdmxfilter->feed->ts_type & TS_PAYLOAD_ONLY)
+			return dvbdmxfilter->feed->cb.ts(buffer1, buffer1_len,
+							 buffer2, buffer2_len,
+							 &dvbdmxfilter->feed->feed.ts,
+							 DMX_OK);
+		else
 			av7110_p2t_write(buffer1, buffer1_len,
-                                  dvbdmxfilter->feed->pid, 
-                                  &av7110->p2t_filter[dvbdmxfilter->index]);
+					 dvbdmxfilter->feed->pid,
+					 &av7110->p2t_filter[dvbdmxfilter->index]);
 	default:
-	        return 0;
-        }
+		return 0;
+	}
 }
 
 
@@ -261,191 +332,191 @@ static inline int DvbDmxFilterCallback(u
 static inline void print_time(char *s)
 {
 #ifdef DEBUG_TIMING
-        struct timeval tv;
-        do_gettimeofday(&tv);
-        printk("%s: %d.%d\n", s, (int)tv.tv_sec, (int)tv.tv_usec);
+	struct timeval tv;
+	do_gettimeofday(&tv);
+	printk("%s: %d.%d\n", s, (int)tv.tv_sec, (int)tv.tv_usec);
 #endif
 }
 
 static void debiirq (unsigned long data)
 {
 	struct av7110 *av7110 = (struct av7110*) data;
-        int type=av7110->debitype;
-        int handle=(type>>8)&0x1f;
-	
+	int type = av7110->debitype;
+	int handle = (type >> 8) & 0x1f;
+
 //	DEB_EE(("av7110: %p\n",av7110));
 
-        print_time("debi");
-        saa7146_write(av7110->dev, IER, 
-                      saa7146_read(av7110->dev, IER) & ~MASK_19 );
-        saa7146_write(av7110->dev, ISR, MASK_19 );
+	print_time("debi");
+	saa7146_write(av7110->dev, IER,
+		      saa7146_read(av7110->dev, IER) & ~MASK_19);
+	saa7146_write(av7110->dev, ISR, MASK_19);
 
-        if (type==-1) {
+	if (type == -1) {
 		printk("DEBI irq oops @ %ld, psr:0x%08x, ssr:0x%08x\n",
 		       jiffies, saa7146_read(av7110->dev, PSR),
 		       saa7146_read(av7110->dev, SSR));
 		spin_lock(&av7110->debilock);
-                ARM_ClearMailBox(av7110);
-                ARM_ClearIrq(av7110);
+		ARM_ClearMailBox(av7110);
+		ARM_ClearIrq(av7110);
+		spin_unlock(&av7110->debilock);
+		return;
+	}
+	av7110->debitype = -1;
+
+	switch (type & 0xff) {
+
+	case DATA_TS_RECORD:
+		dvb_dmx_swfilter_packets(&av7110->demux,
+					 (const u8 *) av7110->debi_virt,
+					 av7110->debilen / 188);
+		spin_lock(&av7110->debilock);
+		iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+		ARM_ClearMailBox(av7110);
 		spin_unlock(&av7110->debilock);
-                return;
-        }
-        av7110->debitype=-1;
-
-        switch (type&0xff) {
-
-        case DATA_TS_RECORD:
-                dvb_dmx_swfilter_packets(&av7110->demux, 
-                                      (const u8 *)av7110->debi_virt, 
-                                      av7110->debilen/188);
-                spin_lock(&av7110->debilock);
-                iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                ARM_ClearMailBox(av7110);
-                spin_unlock(&av7110->debilock);
-                return;
+		return;
 
-        case DATA_PES_RECORD:
-                if (av7110->demux.recording) 
+	case DATA_PES_RECORD:
+		if (av7110->demux.recording)
 			av7110_record_cb(&av7110->p2t[handle],
-                                  (u8 *)av7110->debi_virt,
-                                  av7110->debilen);
-                spin_lock(&av7110->debilock);
-                iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                ARM_ClearMailBox(av7110);
-                spin_unlock(&av7110->debilock);
-                return;
-
-        case DATA_IPMPE:
-        case DATA_FSECTION:
-        case DATA_PIPING:
-                if (av7110->handle2filter[handle]) 
-                        DvbDmxFilterCallback((u8 *)av7110->debi_virt, 
-                                             av7110->debilen, NULL, 0, 
-                                             av7110->handle2filter[handle], 
-                                             DMX_OK, av7110); 
-                spin_lock(&av7110->debilock);
-                iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                ARM_ClearMailBox(av7110);
-                spin_unlock(&av7110->debilock);
-                return;
-
-        case DATA_CI_GET:
-        {
-                u8 *data=av7110->debi_virt;
-
-                if ((data[0]<2) && data[2]==0xff) {
-                        int flags=0;
-                        if (data[5]>0) 
-                                flags|=CA_CI_MODULE_PRESENT;
-                        if (data[5]>5) 
-                                flags|=CA_CI_MODULE_READY;
-                        av7110->ci_slot[data[0]].flags=flags;
-                } else
-                        ci_get_data(&av7110->ci_rbuffer, 
-                                    av7110->debi_virt, 
-                                    av7110->debilen);
-                spin_lock(&av7110->debilock);
-                iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                ARM_ClearMailBox(av7110);
-                spin_unlock(&av7110->debilock);
-                return;
-        }
+					 (u8 *) av7110->debi_virt,
+					 av7110->debilen);
+		spin_lock(&av7110->debilock);
+		iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+		ARM_ClearMailBox(av7110);
+		spin_unlock(&av7110->debilock);
+		return;
+
+	case DATA_IPMPE:
+	case DATA_FSECTION:
+	case DATA_PIPING:
+		if (av7110->handle2filter[handle])
+			DvbDmxFilterCallback((u8 *)av7110->debi_virt,
+					     av7110->debilen, NULL, 0,
+					     av7110->handle2filter[handle],
+					     DMX_OK, av7110);
+		spin_lock(&av7110->debilock);
+		iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+		ARM_ClearMailBox(av7110);
+		spin_unlock(&av7110->debilock);
+		return;
+
+	case DATA_CI_GET:
+	{
+		u8 *data = av7110->debi_virt;
+
+		if ((data[0] < 2) && data[2] == 0xff) {
+			int flags = 0;
+			if (data[5] > 0)
+				flags |= CA_CI_MODULE_PRESENT;
+			if (data[5] > 5)
+				flags |= CA_CI_MODULE_READY;
+			av7110->ci_slot[data[0]].flags = flags;
+		} else
+			ci_get_data(&av7110->ci_rbuffer,
+				    av7110->debi_virt,
+				    av7110->debilen);
+		spin_lock(&av7110->debilock);
+		iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+		ARM_ClearMailBox(av7110);
+		spin_unlock(&av7110->debilock);
+		return;
+	}
 
-        case DATA_COMMON_INTERFACE:
-                CI_handle(av7110, (u8 *)av7110->debi_virt, av7110->debilen);
+	case DATA_COMMON_INTERFACE:
+		CI_handle(av7110, (u8 *)av7110->debi_virt, av7110->debilen);
 #if 0
-        {
-                int i;
+	{
+		int i;
 
-                printk("av7110%d: ", av7110->num);
-                printk("%02x ", *(u8 *)av7110->debi_virt);
-                printk("%02x ", *(1+(u8 *)av7110->debi_virt));
-                for (i=2; i<av7110->debilen; i++)
-                  printk("%02x ", (*(i+(unsigned char *)av7110->debi_virt)));
-                for (i=2; i<av7110->debilen; i++)
-                  printk("%c", chtrans(*(i+(unsigned char *)av7110->debi_virt)));
+		printk("av7110%d: ", av7110->num);
+		printk("%02x ", *(u8 *)av7110->debi_virt);
+		printk("%02x ", *(1+(u8 *)av7110->debi_virt));
+		for (i = 2; i < av7110->debilen; i++)
+			printk("%02x ", (*(i+(unsigned char *)av7110->debi_virt)));
+		for (i = 2; i < av7110->debilen; i++)
+			printk("%c", chtrans(*(i+(unsigned char *)av7110->debi_virt)));
 
-                printk("\n");
-        }
+		printk("\n");
+	}
 #endif
-                spin_lock(&av7110->debilock);
-                iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                ARM_ClearMailBox(av7110);
-                spin_unlock(&av7110->debilock);
-                return;
-
-        case DATA_DEBUG_MESSAGE:
-                ((s8*)av7110->debi_virt)[Reserved_SIZE-1]=0;
-                printk("%s\n", (s8 *)av7110->debi_virt);
-                spin_lock(&av7110->debilock);
-                iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                ARM_ClearMailBox(av7110);
-                spin_unlock(&av7110->debilock);
-                return;
-
-        case DATA_CI_PUT:
-        case DATA_MPEG_PLAY:
-        case DATA_BMP_LOAD:
-                spin_lock(&av7110->debilock);
-                iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
-                ARM_ClearMailBox(av7110);
-                spin_unlock(&av7110->debilock);
-                return;
-        default:
-                break;
-        }
-        spin_lock(&av7110->debilock);
-        ARM_ClearMailBox(av7110);
-        spin_unlock(&av7110->debilock);
+		spin_lock(&av7110->debilock);
+		iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+		ARM_ClearMailBox(av7110);
+		spin_unlock(&av7110->debilock);
+		return;
+
+	case DATA_DEBUG_MESSAGE:
+		((s8*)av7110->debi_virt)[Reserved_SIZE - 1] = 0;
+		printk("%s\n", (s8 *) av7110->debi_virt);
+		spin_lock(&av7110->debilock);
+		iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+		ARM_ClearMailBox(av7110);
+		spin_unlock(&av7110->debilock);
+		return;
+
+	case DATA_CI_PUT:
+	case DATA_MPEG_PLAY:
+	case DATA_BMP_LOAD:
+		spin_lock(&av7110->debilock);
+		iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
+		ARM_ClearMailBox(av7110);
+		spin_unlock(&av7110->debilock);
+		return;
+	default:
+		break;
+	}
+	spin_lock(&av7110->debilock);
+	ARM_ClearMailBox(av7110);
+	spin_unlock(&av7110->debilock);
 }
 
 static void gpioirq (unsigned long data)
 {
 	struct av7110 *av7110 = (struct av7110*) data;
-        u32 rxbuf, txbuf;
-        int len;
-        
-        //printk("GPIO0 irq\n");        
+	u32 rxbuf, txbuf;
+	int len;
+
+	//printk("GPIO0 irq\n");
 
-        if (av7110->debitype !=-1)
+	if (av7110->debitype !=-1)
 		printk("GPIO0 irq oops @ %ld, psr:0x%08x, ssr:0x%08x\n",
 		       jiffies, saa7146_read(av7110->dev, PSR),
 		       saa7146_read(av7110->dev, SSR));
-       
-        spin_lock(&av7110->debilock);
+
+	spin_lock(&av7110->debilock);
 
 	ARM_ClearIrq(av7110);
 
-        saa7146_write(av7110->dev, IER, 
-                      saa7146_read(av7110->dev, IER) & ~MASK_19 );
-        saa7146_write(av7110->dev, ISR, MASK_19 );
-
-        av7110->debitype = irdebi(av7110, DEBINOSWAP, IRQ_STATE, 0, 2);
-        av7110->debilen  = irdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
-        rxbuf=irdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-        txbuf=irdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
+	saa7146_write(av7110->dev, IER,
+		      saa7146_read(av7110->dev, IER) & ~MASK_19);
+	saa7146_write(av7110->dev, ISR, MASK_19);
+
+	av7110->debitype = irdebi(av7110, DEBINOSWAP, IRQ_STATE, 0, 2);
+	av7110->debilen  = irdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
+	rxbuf = irdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+	txbuf = irdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
 	len = (av7110->debilen + 3) & ~3;
 
-//        DEB_D(("GPIO0 irq %d %d\n", av7110->debitype, av7110->debilen));
-        print_time("gpio");
+//	DEB_D(("GPIO0 irq %d %d\n", av7110->debitype, av7110->debilen));
+	print_time("gpio");
 
-//       DEB_D(("GPIO0 irq %02x\n", av7110->debitype&0xff));        
-        switch (av7110->debitype&0xff) {
+//	DEB_D(("GPIO0 irq %02x\n", av7110->debitype&0xff));
+	switch (av7110->debitype & 0xff) {
 
-        case DATA_TS_PLAY:
-        case DATA_PES_PLAY:
-                break;
+	case DATA_TS_PLAY:
+	case DATA_PES_PLAY:
+		break;
 
 	case DATA_MPEG_VIDEO_EVENT:
 	{
 		u32 h_ar;
 		struct video_event event;
 
-                av7110->video_size.w = irdebi(av7110, DEBINOSWAP, STATUS_MPEG_WIDTH, 0, 2);
-                h_ar = irdebi(av7110, DEBINOSWAP, STATUS_MPEG_HEIGHT_AR, 0, 2);
+		av7110->video_size.w = irdebi(av7110, DEBINOSWAP, STATUS_MPEG_WIDTH, 0, 2);
+		h_ar = irdebi(av7110, DEBINOSWAP, STATUS_MPEG_HEIGHT_AR, 0, 2);
 
-                iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
-                iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+		iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
+		iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
 
 		av7110->video_size.h = h_ar & 0xfff;
 		DEB_D(("GPIO0 irq: DATA_MPEG_VIDEO_EVENT: w/h/ar = %u/%u/%u\n",
@@ -477,153 +548,153 @@ static void gpioirq (unsigned long data)
 		break;
 	}
 
-        case DATA_CI_PUT:
-        {
-                int avail;
-                struct dvb_ringbuffer *cibuf=&av7110->ci_wbuffer;
-
-                avail=dvb_ringbuffer_avail(cibuf);
-                if (avail<=2) {
-                        iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
-                        break;
-                } 
-                len= DVB_RINGBUFFER_PEEK(cibuf,0)<<8;
-                len|=DVB_RINGBUFFER_PEEK(cibuf,1);
-                if (avail<len+2) {
-                        iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
-                        break;
-                } 
-                DVB_RINGBUFFER_SKIP(cibuf,2); 
-
-                dvb_ringbuffer_read(cibuf,av7110->debi_virt,len,0);
-
-                wake_up(&cibuf->queue);
-                iwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);
-                iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);
+	case DATA_CI_PUT:
+	{
+		int avail;
+		struct dvb_ringbuffer *cibuf = &av7110->ci_wbuffer;
+
+		avail = dvb_ringbuffer_avail(cibuf);
+		if (avail <= 2) {
+			iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
+			break;
+		}
+		len = DVB_RINGBUFFER_PEEK(cibuf, 0) << 8;
+		len |= DVB_RINGBUFFER_PEEK(cibuf, 1);
+		if (avail < len + 2) {
+			iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
+			break;
+		}
+		DVB_RINGBUFFER_SKIP(cibuf, 2);
+
+		dvb_ringbuffer_read(cibuf, av7110->debi_virt,len, 0);
+
+		wake_up(&cibuf->queue);
+		iwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);
+		iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);
 		saa7146_wait_for_debi_done(av7110->dev);
-                saa7146_write(av7110->dev, IER, 
-                              saa7146_read(av7110->dev, IER) | MASK_19 );
+		saa7146_write(av7110->dev, IER,
+			      saa7146_read(av7110->dev, IER) | MASK_19);
 		if (len < 5)
 			len = 5; /* we want a real DEBI DMA */
-                iwdebi(av7110, DEBISWAB, DPRAM_BASE+txbuf, 0, (len+3)&~3);
-                spin_unlock(&av7110->debilock);
-                return;
-        }
-
-        case DATA_MPEG_PLAY:
-                if (!av7110->playing) {
-                        iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
-                        break;
-                }
-                len=0;
-                if (av7110->debitype&0x100) {
-                        spin_lock(&av7110->aout.lock);
+		iwdebi(av7110, DEBISWAB, DPRAM_BASE + txbuf, 0, (len + 3) & ~3);
+		spin_unlock(&av7110->debilock);
+		return;
+	}
+
+	case DATA_MPEG_PLAY:
+		if (!av7110->playing) {
+			iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
+			break;
+		}
+		len = 0;
+		if (av7110->debitype & 0x100) {
+			spin_lock(&av7110->aout.lock);
 			len=av7110_pes_play(av7110->debi_virt, &av7110->aout, 2048);
-                        spin_unlock(&av7110->aout.lock);
-                }
-                if (len<=0 && (av7110->debitype&0x200)
-                        &&av7110->videostate.play_state!=VIDEO_FREEZED) {
-                        spin_lock(&av7110->avout.lock);
+			spin_unlock(&av7110->aout.lock);
+		}
+		if (len <=0 && (av7110->debitype & 0x200)
+		    &&av7110->videostate.play_state != VIDEO_FREEZED) {
+			spin_lock(&av7110->avout.lock);
 			len=av7110_pes_play(av7110->debi_virt, &av7110->avout, 2048);
-                        spin_unlock(&av7110->avout.lock);
-                }
-                if (len<=0) {
-                        iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
-                        break;
-                } 
-                DEB_D(("GPIO0 PES_PLAY len=%04x\n", len));        
-                iwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);
-                iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);
+			spin_unlock(&av7110->avout.lock);
+		}
+		if (len <= 0) {
+			iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
+			break;
+		}
+		DEB_D(("GPIO0 PES_PLAY len=%04x\n", len));
+		iwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);
+		iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);
 		saa7146_wait_for_debi_done(av7110->dev);
-                saa7146_write(av7110->dev, IER, 
-                              saa7146_read(av7110->dev, IER) | MASK_19 );
+		saa7146_write(av7110->dev, IER,
+			      saa7146_read(av7110->dev, IER) | MASK_19);
 
-                iwdebi(av7110, DEBISWAB, DPRAM_BASE+txbuf, 0, (len+3)&~3);
-                spin_unlock(&av7110->debilock);
-                return;
-
-        case DATA_BMP_LOAD:
-                len=av7110->debilen;
-                if (!len) {
-                        av7110->bmp_state=BMP_LOADED;
-                        iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
-                        iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
-                        wake_up(&av7110->bmpq);
-                        break;
-                }
-                if (len>av7110->bmplen)
-                        len=av7110->bmplen;
-                if (len>2*1024)
-                        len=2*1024;
-                iwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);
-                iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);
-                memcpy(av7110->debi_virt, av7110->bmpbuf+av7110->bmpp, len);
-                av7110->bmpp+=len;
-                av7110->bmplen-=len;
+		iwdebi(av7110, DEBISWAB, DPRAM_BASE + txbuf, 0, (len + 3) & ~3);
+		spin_unlock(&av7110->debilock);
+		return;
+
+	case DATA_BMP_LOAD:
+		len = av7110->debilen;
+		if (!len) {
+			av7110->bmp_state = BMP_LOADED;
+			iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);
+			iwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);
+			wake_up(&av7110->bmpq);
+			break;
+		}
+		if (len > av7110->bmplen)
+			len = av7110->bmplen;
+		if (len > 2 * 1024)
+			len = 2 * 1024;
+		iwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);
+		iwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);
+		memcpy(av7110->debi_virt, av7110->bmpbuf+av7110->bmpp, len);
+		av7110->bmpp += len;
+		av7110->bmplen -= len;
 		saa7146_wait_for_debi_done(av7110->dev);
-                saa7146_write(av7110->dev, IER, 
-                              saa7146_read(av7110->dev, IER) | MASK_19 );
+		saa7146_write(av7110->dev, IER,
+			      saa7146_read(av7110->dev, IER) | MASK_19);
 		if (len < 5)
 			len = 5; /* we want a real DEBI DMA */
-                iwdebi(av7110, DEBISWAB, DPRAM_BASE+txbuf, 0, (len+3)&~3);
-                spin_unlock(&av7110->debilock);
-                return;
-
-        case DATA_CI_GET:
-        case DATA_COMMON_INTERFACE:
-        case DATA_FSECTION:
-        case DATA_IPMPE:
-        case DATA_PIPING:
-                if (!len || len>4*1024) {
-                        iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                        break;
+		iwdebi(av7110, DEBISWAB, DPRAM_BASE+txbuf, 0, (len + 3) & ~3);
+		spin_unlock(&av7110->debilock);
+		return;
+
+	case DATA_CI_GET:
+	case DATA_COMMON_INTERFACE:
+	case DATA_FSECTION:
+	case DATA_IPMPE:
+	case DATA_PIPING:
+		if (!len || len > 4 * 1024) {
+			iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+			break;
 		}
 		/* fall through */
 
-        case DATA_TS_RECORD:
-        case DATA_PES_RECORD:
+	case DATA_TS_RECORD:
+	case DATA_PES_RECORD:
 		saa7146_wait_for_debi_done(av7110->dev);
-                saa7146_write(av7110->dev, IER, 
-                              saa7146_read(av7110->dev, IER) | MASK_19);
-                irdebi(av7110, DEBISWAB, DPRAM_BASE+rxbuf, 0, len);
-                spin_unlock(&av7110->debilock);
-                return;
+		saa7146_write(av7110->dev, IER,
+			      saa7146_read(av7110->dev, IER) | MASK_19);
+		irdebi(av7110, DEBISWAB, DPRAM_BASE+rxbuf, 0, len);
+		spin_unlock(&av7110->debilock);
+		return;
 
-        case DATA_DEBUG_MESSAGE:
+	case DATA_DEBUG_MESSAGE:
 		saa7146_wait_for_debi_done(av7110->dev);
-                if (!len || len>0xff) {
-                        iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                        break;
-                }
-                saa7146_write(av7110->dev, IER, 
-                              saa7146_read(av7110->dev, IER) | MASK_19);
-                irdebi(av7110, DEBISWAB, Reserved, 0, len);
-                spin_unlock(&av7110->debilock);
-                return;
-
-        case DATA_IRCOMMAND: 
-                IR_handle(av7110, 
-                          swahw32(irdebi(av7110, DEBINOSWAP, Reserved, 0, 4)));
-                iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
-                break;
-
-        default:
-                printk("gpioirq unknown type=%d len=%d\n", 
-                       av7110->debitype, av7110->debilen);
-                break;
-        }      
-        ARM_ClearMailBox(av7110);
-        av7110->debitype=-1;
-        spin_unlock(&av7110->debilock);
+		if (!len || len > 0xff) {
+			iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+			break;
+		}
+		saa7146_write(av7110->dev, IER,
+			      saa7146_read(av7110->dev, IER) | MASK_19);
+		irdebi(av7110, DEBISWAB, Reserved, 0, len);
+		spin_unlock(&av7110->debilock);
+		return;
+
+	case DATA_IRCOMMAND:
+		IR_handle(av7110,
+			  swahw32(irdebi(av7110, DEBINOSWAP, Reserved, 0, 4)));
+		iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
+		break;
+
+	default:
+		printk("gpioirq unknown type=%d len=%d\n",
+		       av7110->debitype, av7110->debilen);
+		break;
+	}
+	ARM_ClearMailBox(av7110);
+	av7110->debitype = -1;
+	spin_unlock(&av7110->debilock);
 }
 
 
@@ -638,9 +709,11 @@ static int dvb_osd_ioctl(struct inode *i
 
 	if (cmd == OSD_SEND_CMD)
 		return av7110_osd_cmd(av7110, (osd_cmd_t *) parg);
+	if (cmd == OSD_GET_CAPABILITY)
+		return av7110_osd_capability(av7110, (osd_cap_t *) parg);
 
 	return -EINVAL;
-        }
+}
 
 
 static struct file_operations dvb_osd_fops = {
@@ -662,7 +735,7 @@ static struct dvb_device dvbdev_osd = {
 
 static inline int SetPIDs(struct av7110 *av7110, u16 vpid, u16 apid, u16 ttpid,
 			  u16 subpid, u16 pcrpid)
-        {
+{
 	DEB_EE(("av7110: %p\n", av7110));
 
 	if (vpid == 0x1fff || apid == 0x1fff ||
@@ -682,7 +755,7 @@ void ChangePIDs(struct av7110 *av7110, u
 		u16 subpid, u16 pcrpid)
 {
 	DEB_EE(("av7110: %p\n", av7110));
-        
+
 	if (down_interruptible(&av7110->pid_mutex))
 		return;
 
@@ -694,13 +767,13 @@ void ChangePIDs(struct av7110 *av7110, u
 		av7110->pids[DMX_PES_TELETEXT] = ttpid;
 	if (!(pcrpid & 0x8000))
 		av7110->pids[DMX_PES_PCR] = pcrpid;
-	
+
 	av7110->pids[DMX_PES_SUBTITLE] = 0;
 
 	if (av7110->fe_synced) {
 		pcrpid = av7110->pids[DMX_PES_PCR];
 		SetPIDs(av7110, vpid, apid, ttpid, subpid, pcrpid);
-        }
+	}
 
 	up(&av7110->pid_mutex);
 }
@@ -720,7 +793,7 @@ static int StartHWFilter(struct dvb_demu
 //	u16 mode=0x0320;
 	u16 mode=0xb96a;
 
-	DEB_EE(("av7110: %p\n",av7110));
+	DEB_EE(("av7110: %p\n", av7110));
 
 	if (dvbdmxfilter->type == DMX_TYPE_SEC) {
 		if (hw_sections) {
@@ -731,11 +804,11 @@ static int StartHWFilter(struct dvb_demu
 					(dvbdmxfilter->filter.filter_value[i] << 8) |
 					dvbdmxfilter->maskandmode[i];
 			mode = 4;
-                }
+		}
 	} else if ((dvbdmxfeed->ts_type & TS_PACKET) &&
 		   !(dvbdmxfeed->ts_type & TS_PAYLOAD_ONLY)) {
 		av7110_p2t_init(&av7110->p2t_filter[dvbdmxfilter->index], dvbdmxfeed);
-        }
+	}
 
 	buf[0] = (COMTYPE_PID_FILTER << 8) + AddPIDFilter;
 	buf[1] = 16;
@@ -746,13 +819,13 @@ static int StartHWFilter(struct dvb_demu
 	if (ret < 0) {
 		printk("StartHWFilter error\n");
 		return ret;
-        }
+	}
 
 	av7110->handle2filter[handle] = dvbdmxfilter;
 	dvbdmxfilter->hw_handle = handle;
 
 	return ret;
-                }
+}
 
 static int StopHWFilter(struct dvb_demux_filter *dvbdmxfilter)
 {
@@ -761,7 +834,7 @@ static int StopHWFilter(struct dvb_demux
 	u16 answ[2];
 	int ret;
 	u16 handle;
-        
+
 	DEB_EE(("av7110: %p\n", av7110));
 
 	handle = dvbdmxfilter->hw_handle;
@@ -770,7 +843,7 @@ static int StopHWFilter(struct dvb_demux
 		       handle));
 		DEB_S(("dvb: filter type = %d\n", dvbdmxfilter->type));
 		return 0;
-                }
+	}
 
 	av7110->handle2filter[handle] = NULL;
 
@@ -784,8 +857,8 @@ static int StopHWFilter(struct dvb_demux
 	if (answ[1] != handle) {
 		DEB_S(("dvb: filter %d shutdown error :%d\n", handle, answ[1]));
 		ret = -1;
-        }
-        return ret;
+	}
+	return ret;
 }
 
 
@@ -796,7 +869,7 @@ static void dvb_feed_start_pid(struct dv
 	u16 *pid = dvbdmx->pids, npids[5];
 	int i;
 
-	DEB_EE(("av7110: %p\n",av7110));
+	DEB_EE(("av7110: %p\n", av7110));
 
 	npids[0] = npids[1] = npids[2] = npids[3] = npids[4] = 0xffff;
 	i = dvbdmxfeed->pes_type;
@@ -809,7 +882,7 @@ static void dvb_feed_start_pid(struct dv
 	}
 	if (dvbdmxfeed->pes_type <= 2 || dvbdmxfeed->pes_type == 4)
 		ChangePIDs(av7110, npids[1], npids[0], npids[2], npids[3], npids[4]);
-        
+
 	if (dvbdmxfeed->pes_type < 2 && npids[0])
 		if (av7110->fe_synced)
 			av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, Scan, 0);
@@ -821,16 +894,16 @@ static void dvb_feed_start_pid(struct dv
 			av7110_av_start_record(av7110, RP_VIDEO, dvbdmxfeed);
 	}
 }
-                
+
 static void dvb_feed_stop_pid(struct dvb_demux_feed *dvbdmxfeed)
 {
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct av7110 *av7110 = (struct av7110 *) dvbdmx->priv;
 	u16 *pid = dvbdmx->pids, npids[5];
 	int i;
-                
+
 	DEB_EE(("av7110: %p\n", av7110));
-                
+
 	if (dvbdmxfeed->pes_type <= 1) {
 		av7110_av_stop(av7110, dvbdmxfeed->pes_type ?  RP_VIDEO : RP_AUDIO);
 		if (!av7110->rec_mode)
@@ -845,31 +918,31 @@ static void dvb_feed_stop_pid(struct dvb
 		if (dvbdmxfeed->ts_type & TS_PACKET)
 			StopHWFilter(dvbdmxfeed->filter);
 		npids[2] = 0;
-                break;
+		break;
 	case 0:
 	case 1:
 	case 4:
 		if (!pids_off)
 			return;
 		npids[i] = (pid[i]&0x8000) ? 0 : pid[i];
-                break;
-        }
+		break;
+	}
 	ChangePIDs(av7110, npids[1], npids[0], npids[2], npids[3], npids[4]);
 }
-        
+
 static int av7110_start_feed(struct dvb_demux_feed *feed)
 {
 	struct dvb_demux *demux = feed->demux;
 	struct av7110 *av7110 = (struct av7110 *) demux->priv;
-                
+
 	DEB_EE(("av7110: %p\n", av7110));
-                
+
 	if (!demux->dmx.frontend)
 		return -EINVAL;
-                        
+
 	if (feed->pid > 0x1fff)
 		return -EINVAL;
-                        
+
 	if (feed->type == DMX_TYPE_TS) {
 		if ((feed->ts_type & TS_DECODER) &&
 		    (feed->pes_type < DMX_TS_PES_OTHER)) {
@@ -884,17 +957,17 @@ static int av7110_start_feed(struct dvb_
 					       av7110_av_start_play(av7110,RP_AV);
 					       demux->playing = 1;
 					}
-                        break;
-                default:
+				break;
+			default:
 				dvb_feed_start_pid(feed);
-                        break;
-                }
+				break;
+			}
 		} else if ((feed->ts_type & TS_PACKET) &&
 			   (demux->dmx.frontend->source != DMX_MEMORY_FE)) {
 			StartHWFilter(feed->filter);
 		}
 	}
-                
+
 	if (feed->type == DMX_TYPE_SEC) {
 		int i;
 
@@ -908,8 +981,8 @@ static int av7110_start_feed(struct dvb_
 			demux->filter[i].state = DMX_STATE_GO;
 			if (demux->dmx.frontend->source != DMX_MEMORY_FE)
 				StartHWFilter(&demux->filter[i]);
-        }
-        }
+		}
+	}
 
 	return 0;
 }
@@ -920,7 +993,7 @@ static int av7110_stop_feed(struct dvb_d
 	struct dvb_demux *demux = feed->demux;
 	struct av7110 *av7110 = (struct av7110 *) demux->priv;
 
-	DEB_EE(("av7110: %p\n",av7110));
+	DEB_EE(("av7110: %p\n", av7110));
 
 	if (feed->type == DMX_TYPE_TS) {
 		if (feed->ts_type & TS_DECODER) {
@@ -951,7 +1024,7 @@ static int av7110_stop_feed(struct dvb_d
 		}
 	}
 
-        return 0;
+	return 0;
 }
 
 
@@ -962,7 +1035,7 @@ static void restart_feeds(struct av7110 
 	int mode;
 	int i;
 
-	DEB_EE(("av7110: %p\n",av7110));
+	DEB_EE(("av7110: %p\n", av7110));
 
 	mode = av7110->playing;
 	av7110->playing = 0;
@@ -995,7 +1068,7 @@ static int dvb_get_stc(struct dmx_demux 
 		BUG();
 	av7110 = (struct av7110 *) dvbdemux->priv;
 
-	DEB_EE(("av7110: %p\n",av7110));
+	DEB_EE(("av7110: %p\n", av7110));
 
 	if (num != 0)
 		return -EINVAL;
@@ -1004,14 +1077,14 @@ static int dvb_get_stc(struct dmx_demux 
 	if (ret) {
 		printk(KERN_ERR "%s: av7110_fw_request error\n", __FUNCTION__);
 		return -EIO;
-}
+	}
 	DEB_EE(("av7110: fwstc = %04hx %04hx %04hx %04hx\n",
 		fwstc[0], fwstc[1], fwstc[2], fwstc[3]));
 
 	*stc =	(((uint64_t) ((fwstc[3] & 0x8000) >> 15)) << 32) |
 		(((uint64_t)  fwstc[1]) << 16) | ((uint64_t) fwstc[0]);
 	*base = 1;
-        
+
 	DEB_EE(("av7110: stc = %lu\n", (unsigned long)*stc));
 
 	return 0;
@@ -1039,7 +1112,7 @@ static int av7110_diseqc_ioctl(struct dv
 			break;
 		default:
 			return -EINVAL;
-};
+		};
 		break;
 
 	case FE_DISEQC_SEND_MASTER_CMD:
@@ -1055,52 +1128,52 @@ static int av7110_diseqc_ioctl(struct dv
 
 	default:
 		return -EOPNOTSUPP;
-};
+	};
 
 	return 0;
 }
 
 
-static void av7110_before_after_tune (fe_status_t s, void *data)
+static void av7110_before_after_tune(fe_status_t s, void *data)
 {
 	struct av7110 *av7110 = data;
 
-	DEB_EE(("av7110: %p\n",av7110));
+	DEB_EE(("av7110: %p\n", av7110));
 
-        av7110->fe_synced = (s & FE_HAS_LOCK) ? 1 : 0;
+	av7110->fe_synced = (s & FE_HAS_LOCK) ? 1 : 0;
 
-        if (av7110->playing)
-                return;
+	if (av7110->playing)
+		return;
 
-        if (down_interruptible(&av7110->pid_mutex))
-                return;
+	if (down_interruptible(&av7110->pid_mutex))
+		return;
 
 	if (av7110->fe_synced) {
-                SetPIDs(av7110, av7110->pids[DMX_PES_VIDEO], 
-                        av7110->pids[DMX_PES_AUDIO], 
-                        av7110->pids[DMX_PES_TELETEXT], 0, 
-                        av7110->pids[DMX_PES_PCR]);
+		SetPIDs(av7110, av7110->pids[DMX_PES_VIDEO],
+			av7110->pids[DMX_PES_AUDIO],
+			av7110->pids[DMX_PES_TELETEXT], 0,
+			av7110->pids[DMX_PES_PCR]);
 		av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, Scan, 0);
 	} else {
 		SetPIDs(av7110, 0, 0, 0, 0, 0);
 		av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, FlushTSQueue, 0);
 	}
 
-        up(&av7110->pid_mutex);
+	up(&av7110->pid_mutex);
 }
 
 
 static int av7110_register(struct av7110 *av7110)
 {
-        int ret, i;
-        struct dvb_demux *dvbdemux=&av7110->demux;
+	int ret, i;
+	struct dvb_demux *dvbdemux = &av7110->demux;
 
-	DEB_EE(("av7110: %p\n",av7110));
+	DEB_EE(("av7110: %p\n", av7110));
 
-        if (av7110->registered)
-                return -1;
+	if (av7110->registered)
+		return -1;
 
-        av7110->registered=1;
+	av7110->registered = 1;
 
 	dvb_add_frontend_notifier (av7110->dvb_adapter,
 				   av7110_before_after_tune, av7110);
@@ -1111,10 +1184,10 @@ static int av7110_register(struct av7110
 	dvb_add_frontend_ioctls (av7110->dvb_adapter,
 				 av7110_diseqc_ioctl, NULL, av7110);
 
-        dvbdemux->priv = (void *) av7110;
+	dvbdemux->priv = (void *) av7110;
 
-	for (i=0; i<32; i++)
-		av7110->handle2filter[i]=NULL;
+	for (i = 0; i < 32; i++)
+		av7110->handle2filter[i] = NULL;
 
 	dvbdemux->filternum = 32;
 	dvbdemux->feednum = 32;
@@ -1130,27 +1203,27 @@ static int av7110_register(struct av7110
 	av7110->dmxdev.filternum = 32;
 	av7110->dmxdev.demux = &dvbdemux->dmx;
 	av7110->dmxdev.capabilities = 0;
-        
+
 	dvb_dmxdev_init(&av7110->dmxdev, av7110->dvb_adapter);
 
-        av7110->hw_frontend.source = DMX_FRONTEND_0;
+	av7110->hw_frontend.source = DMX_FRONTEND_0;
 
-        ret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &av7110->hw_frontend);
+	ret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &av7110->hw_frontend);
+
+	if (ret < 0)
+		return ret;
 
-        if (ret < 0)
-                return ret;
-        
-        av7110->mem_frontend.source = DMX_MEMORY_FE;
+	av7110->mem_frontend.source = DMX_MEMORY_FE;
 
 	ret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &av7110->mem_frontend);
 
 	if (ret < 0)
-                return ret;
-        
-        ret = dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, 
+		return ret;
+
+	ret = dvbdemux->dmx.connect_frontend(&dvbdemux->dmx,
 					     &av7110->hw_frontend);
-        if (ret < 0)
-                return ret;
+	if (ret < 0)
+		return ret;
 
 	av7110_av_register(av7110);
 	av7110_ca_register(av7110);
@@ -1159,8 +1232,8 @@ static int av7110_register(struct av7110
 	dvb_register_device(av7110->dvb_adapter, &av7110->osd_dev,
 			    &dvbdev_osd, av7110, DVB_DEVICE_OSD);
 #endif
-        
-        dvb_net_init(av7110->dvb_adapter, &av7110->dvb_net, &dvbdemux->dmx);
+
+	dvb_net_init(av7110->dvb_adapter, &av7110->dvb_net, &dvbdemux->dmx);
 
 	return 0;
 }
@@ -1168,25 +1241,24 @@ static int av7110_register(struct av7110
 
 static void dvb_unregister(struct av7110 *av7110)
 {
-        struct dvb_demux *dvbdemux=&av7110->demux;
+	struct dvb_demux *dvbdemux = &av7110->demux;
 
-	DEB_EE(("av7110: %p\n",av7110));
+	DEB_EE(("av7110: %p\n", av7110));
 
-        if (!av7110->registered)
-                return;
+	if (!av7110->registered)
+		return;
 
 	dvb_net_release(&av7110->dvb_net);
 
 	dvbdemux->dmx.close(&dvbdemux->dmx);
-        dvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &av7110->hw_frontend);
-        dvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &av7110->mem_frontend);
+	dvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &av7110->hw_frontend);
+	dvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &av7110->mem_frontend);
 
-        dvb_dmxdev_release(&av7110->dmxdev);
-        dvb_dmx_release(&av7110->demux);
+	dvb_dmxdev_release(&av7110->dmxdev);
+	dvb_dmx_release(&av7110->demux);
 
 	dvb_remove_frontend_notifier (av7110->dvb_adapter,
 				      av7110_before_after_tune);
-
 	dvb_remove_frontend_ioctls (av7110->dvb_adapter,
 				    av7110_diseqc_ioctl, NULL);
 
@@ -1203,19 +1275,17 @@ static void dvb_unregister(struct av7110
 int i2c_writereg(struct av7110 *av7110, u8 id, u8 reg, u8 val)
 {
 	u8 msg[2] = { reg, val };
-	struct dvb_i2c_bus *i2c = av7110->i2c_bus;
 	struct i2c_msg msgs;
-	
+
 	msgs.flags = 0;
 	msgs.addr = id / 2;
 	msgs.len = 2;
 	msgs.buf = msg;
-	return i2c->xfer(i2c, &msgs, 1);
+	return i2c_transfer(&av7110->i2c_adap, &msgs, 1);
 }
 
 u8 i2c_readreg(struct av7110 *av7110, u8 id, u8 reg)
 {
-	struct dvb_i2c_bus *i2c = av7110->i2c_bus;
 	u8 mm1[] = {0x00};
 	u8 mm2[] = {0x00};
 	struct i2c_msg msgs[2];
@@ -1226,17 +1296,11 @@ u8 i2c_readreg(struct av7110 *av7110, u8
 	mm1[0] = reg;
 	msgs[0].len = 1; msgs[1].len = 1;
 	msgs[0].buf = mm1; msgs[1].buf = mm2;
-	i2c->xfer(i2c, msgs, 2);
+	i2c_transfer(&av7110->i2c_adap, msgs, 2);
 
 	return mm2[0];
 }
 
-static int master_xfer(struct dvb_i2c_bus *i2c, const struct i2c_msg msgs[], int num)
-{
-	struct saa7146_dev *dev = i2c->data;
-	return saa7146_i2c_transfer(dev, msgs, num, 6);
-}
-
 /****************************************************************************
  * INITIALIZATION
  ****************************************************************************/
@@ -1246,10 +1310,10 @@ static int check_firmware(struct av7110*
 {
 	u32 crc = 0, len = 0;
 	unsigned char *ptr;
-		
+
 	/* check for firmware magic */
 	ptr = av7110->bin_fw;
-	if (ptr[0] != 'A' || ptr[1] != 'V' || 
+	if (ptr[0] != 'A' || ptr[1] != 'V' ||
 	    ptr[2] != 'F' || ptr[3] != 'W') {
 		printk("dvb-ttpci: this is not an av7110 firmware\n");
 		return -EINVAL;
@@ -1257,34 +1321,34 @@ static int check_firmware(struct av7110*
 	ptr += 4;
 
 	/* check dpram file */
-	crc = ntohl(*(u32*)ptr);
+	crc = ntohl(*(u32*) ptr);
 	ptr += 4;
-	len = ntohl(*(u32*)ptr);
+	len = ntohl(*(u32*) ptr);
 	ptr += 4;
 	if (len >= 512) {
 		printk("dvb-ttpci: dpram file is way to big.\n");
 		return -EINVAL;
 	}
-	if( crc != crc32_le(0,ptr,len)) {
+	if (crc != crc32_le(0, ptr, len)) {
 		printk("dvb-ttpci: crc32 of dpram file does not match.\n");
 		return -EINVAL;
 	}
 	av7110->bin_dpram = ptr;
 	av7110->size_dpram = len;
 	ptr += len;
-	
+
 	/* check root file */
-	crc = ntohl(*(u32*)ptr);
+	crc = ntohl(*(u32*) ptr);
 	ptr += 4;
-	len = ntohl(*(u32*)ptr);
+	len = ntohl(*(u32*) ptr);
 	ptr += 4;
-	
+
 	if (len <= 200000 || len >= 300000 ||
 	    len > ((av7110->bin_fw + av7110->size_fw) - ptr)) {
-		printk("dvb-ttpci: root file has strange size (%d). aborting.\n",len);
+		printk("dvb-ttpci: root file has strange size (%d). aborting.\n", len);
 		return -EINVAL;
 	}
-	if( crc != crc32_le(0,ptr,len)) {
+	if( crc != crc32_le(0, ptr, len)) {
 		printk("dvb-ttpci: crc32 of root file does not match.\n");
 		return -EINVAL;
 	}
@@ -1310,27 +1374,66 @@ static int get_firmware(struct av7110* a
 	/* request the av7110 firmware, this will block until someone uploads it */
 	ret = request_firmware(&fw, "dvb-ttpci-01.fw", &av7110->dev->pci->dev);
 	if (ret) {
-		printk("dvb-ttpci: cannot request firmware!\n");
+		if (ret == -ENOENT) {
+			printk(KERN_ERR "dvb-ttpci: could not load firmware,"
+			       " file not found: dvb-ttpci-01.fw\n");
+			printk(KERN_ERR "dvb-ttpci: usually this should be in"
+			       " /usr/lib/hotplug/firmware\n");
+			printk(KERN_ERR "dvb-ttpci: and can be downloaded here"
+			       " http://www.linuxtv.org/download/dvb/firmware/\n");
+		} else
+			printk(KERN_ERR "dvb-ttpci: cannot request firmware"
+			       " (error %i)\n", ret);
 		return -EINVAL;
 	}
+
 	if (fw->size <= 200000) {
 		printk("dvb-ttpci: this firmware is way too small.\n");
+		release_firmware(fw);
 		return -EINVAL;
 	}
+
 	/* check if the firmware is available */
 	av7110->bin_fw = (unsigned char*) vmalloc(fw->size);
 	if (NULL == av7110->bin_fw) {
 		DEB_D(("out of memory\n"));
+		release_firmware(fw);
 		return -ENOMEM;
 	}
+
 	memcpy(av7110->bin_fw, fw->data, fw->size);
 	av7110->size_fw = fw->size;
 	if ((ret = check_firmware(av7110)))
 		vfree(av7110->bin_fw);
+
+	release_firmware(fw);
 	return ret;
 }
 #endif
 
+
+static int client_register(struct i2c_client *client)
+{
+	struct saa7146_dev *dev = (struct saa7146_dev*)i2c_get_adapdata(client->adapter);
+	struct av7110 *av7110 = (struct av7110*)dev->ext_priv;
+
+	/* fixme: check for "type" (ie. frontend type) */
+	if (client->driver->command)
+		return client->driver->command(client, FE_REGISTER, av7110->dvb_adapter);
+	return 0;
+}
+
+static int client_unregister(struct i2c_client *client)
+{
+	struct saa7146_dev *dev = (struct saa7146_dev*)i2c_get_adapdata(client->adapter);
+	struct av7110 *av7110 = (struct av7110*)dev->ext_priv;
+
+	/* fixme: check for "type" (ie. frontend type) */
+	if (client->driver->command)
+		return client->driver->command(client, FE_UNREGISTER, av7110->dvb_adapter);
+	return 0;
+}
+
 static int av7110_attach(struct saa7146_dev* dev, struct saa7146_pci_extension_data *pci_ext)
 {
 	struct av7110 *av7110 = NULL;
@@ -1345,9 +1448,9 @@ static int av7110_attach(struct saa7146_
 	}
 	DEB_EE(("av7110: %p\n", av7110));
 	memset(av7110, 0, sizeof(struct av7110));
-	
-	av7110->card_name = (char*)pci_ext->ext_priv;
-	av7110->dev=(struct saa7146_dev *)dev;
+
+	av7110->card_name = (char*) pci_ext->ext_priv;
+	av7110->dev = (struct saa7146_dev *) dev;
 	dev->ext_priv = av7110;
 
 	if ((ret = get_firmware(av7110))) {
@@ -1361,72 +1464,81 @@ static int av7110_attach(struct saa7146_
 	   get recognized before the main driver is fully loaded */
 	saa7146_write(dev, GPIO_CTRL, 0x500000);
 
-	saa7146_i2c_adapter_prepare(dev, NULL, 0, SAA7146_I2C_BUS_BIT_RATE_120); /* 275 kHz */
+	av7110->i2c_adap = (struct i2c_adapter) {
+		.client_register = client_register,
+		.client_unregister = client_unregister,
+#ifdef I2C_ADAP_CLASS_TV_DIGITAL
+		.class = I2C_ADAP_CLASS_TV_DIGITAL,
+#else
+		.class = I2C_CLASS_TV_DIGITAL,
+#endif
+	};
+	strlcpy(av7110->i2c_adap.name, pci_ext->ext_priv, sizeof(av7110->i2c_adap.name));
 
-	av7110->i2c_bus = dvb_register_i2c_bus (master_xfer, dev,
-						av7110->dvb_adapter, 0);
+	saa7146_i2c_adapter_prepare(dev, &av7110->i2c_adap, SAA7146_I2C_BUS_BIT_RATE_120); /* 275 kHz */
 
-	if (!av7110->i2c_bus) {
+	if (i2c_add_adapter(&av7110->i2c_adap) < 0) {
 		dvb_unregister_adapter (av7110->dvb_adapter);
 		kfree(av7110);
 		return -ENOMEM;
 	}
 
-	ttpci_eeprom_parse_mac(av7110->i2c_bus);
+	ttpci_eeprom_parse_mac(&av7110->i2c_adap, av7110->dvb_adapter->proposed_mac);
 
 	saa7146_write(dev, PCI_BT_V1, 0x1c00101f);
 	saa7146_write(dev, BCS_CTRL, 0x80400040);
 
 	/* set dd1 stream a & b */
-      	saa7146_write(dev, DD1_STREAM_B, 0x00000000);
+	saa7146_write(dev, DD1_STREAM_B, 0x00000000);
 	saa7146_write(dev, DD1_INIT, 0x03000000);
 	saa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));
 
 	/* upload all */
 	saa7146_write(dev, MC2, 0x077c077c);
-        saa7146_write(dev, GPIO_CTRL, 0x000000);
+	saa7146_write(dev, GPIO_CTRL, 0x000000);
 
 	tasklet_init (&av7110->debi_tasklet, debiirq, (unsigned long) av7110);
 	tasklet_init (&av7110->gpio_tasklet, gpioirq, (unsigned long) av7110);
 
-        sema_init(&av7110->pid_mutex, 1);
-
-        /* locks for data transfers from/to AV7110 */
-        spin_lock_init (&av7110->debilock);
-        sema_init(&av7110->dcomlock, 1);
-        av7110->debilock=SPIN_LOCK_UNLOCKED;
-        av7110->debitype=-1;
+	sema_init(&av7110->pid_mutex, 1);
 
-        /* default OSD window */
-        av7110->osdwin=1;
+	/* locks for data transfers from/to AV7110 */
+	spin_lock_init (&av7110->debilock);
+	sema_init(&av7110->dcomlock, 1);
+	av7110->debilock = SPIN_LOCK_UNLOCKED;
+	av7110->debitype = -1;
+
+	/* default OSD window */
+	av7110->osdwin = 1;
+	sema_init(&av7110->osd_sema, 1);
 
-        /* ARM "watchdog" */
+	/* ARM "watchdog" */
 	init_waitqueue_head(&av7110->arm_wait);
-        av7110->arm_thread=NULL;
-     
-        /* allocate and init buffers */
-        av7110->debi_virt = pci_alloc_consistent(dev->pci, 8192,
+	av7110->arm_thread = NULL;
+
+	/* allocate and init buffers */
+	av7110->debi_virt = pci_alloc_consistent(dev->pci, 8192,
 						 &av7110->debi_bus);
 	if (!av7110->debi_virt) {
 		ret = -ENOMEM;
-                goto err;
+		goto err;
 	}
 
-        av7110->iobuf = vmalloc(AVOUTLEN+AOUTLEN+BMPLEN+4*IPACKS);
+	av7110->iobuf = vmalloc(AVOUTLEN+AOUTLEN+BMPLEN+4*IPACKS);
 	if (!av7110->iobuf) {
 		ret = -ENOMEM;
-                goto err;
+		goto err;
 	}
 
 	av7110_av_init(av7110);
 
-        /* init BMP buffer */
-        av7110->bmpbuf=av7110->iobuf+AVOUTLEN+AOUTLEN;
-        init_waitqueue_head(&av7110->bmpq);
-        
+	/* init BMP buffer */
+	av7110->bmpbuf = av7110->iobuf+AVOUTLEN+AOUTLEN;
+	init_waitqueue_head(&av7110->bmpq);
+
 	av7110_ca_init(av7110);
 
-        /* load firmware into AV7110 cards */
+	/* load firmware into AV7110 cards */
 	av7110_bootarm(av7110);
 	if (av7110_firmversion(av7110)) {
 		ret = -EIO;
@@ -1443,82 +1555,39 @@ static int av7110_attach(struct saa7146_
 		goto err2;
 	}
 
-	/* set internal volume control to maximum */
-	av7110->adac_type = DVB_ADAC_TI;
-	av7110_set_volume(av7110, 0xff, 0xff);
-
-	av7710_set_video_mode(av7110, vidmode);
-
-	/* handle different card types */
-	/* remaining inits according to card and frontend type */
-	av7110->has_analog_tuner = 0;
-	av7110->current_input = 0;
-	if (i2c_writereg(av7110, 0x20, 0x00, 0x00)==1) {
-		printk ("av7110(%d): Crystal audio DAC detected\n",
-			av7110->dvb_adapter->num);
-		av7110->adac_type = DVB_ADAC_CRYSTAL;
-		i2c_writereg(av7110, 0x20, 0x01, 0xd2);
-		i2c_writereg(av7110, 0x20, 0x02, 0x49);
-		i2c_writereg(av7110, 0x20, 0x03, 0x00);
-		i2c_writereg(av7110, 0x20, 0x04, 0x00);
-	
-	/**
-	 * some special handling for the Siemens DVB-C cards...
-	 */
-	} else if (0 == av7110_init_analog_module(av7110)) {
-		/* done. */
-	}
-	else if (dev->pci->subsystem_vendor == 0x110a) {
-		printk("av7110(%d): DVB-C w/o analog module detected\n",
-			av7110->dvb_adapter->num);
-		av7110->adac_type = DVB_ADAC_NONE;
-	}
-	else {
-		av7110->adac_type = adac;
-		printk("av7110(%d): adac type set to %d\n",
-			av7110->dvb_adapter->num, av7110->adac_type);
-		}
+	/* set initial volume in mixer struct */
+	av7110->mixer.volume_left  = volume;
+	av7110->mixer.volume_right = volume;
 
-	if (av7110->adac_type == DVB_ADAC_NONE || av7110->adac_type == DVB_ADAC_MSP) {
-		// switch DVB SCART on
-		av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, MainSwitch, 1, 0);
-		av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, ADSwitch, 1, 1);
-		if (rgb_on)
-			saa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI); // RGB on, SCART pin 16
-		//saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO); // SCARTpin 8
-	}
-	
-	av7110_set_volume(av7110, 0xff, 0xff);
+	init_av7110_av(av7110);
 
-	av7110_setup_irc_config (av7110, 0);
 	av7110_register(av7110);
-	
+
 	/* special case DVB-C: these cards have an analog tuner
 	   plus need some special handling, so we have separate
 	   saa7146_ext_vv data for these... */
 	ret = av7110_init_v4l(av7110);
-	
+
 	if (ret)
 		goto err3;
 
-	printk(KERN_INFO "av7110: found av7110-%d.\n",av7110_num);
+	printk(KERN_INFO "av7110: found av7110-%d.\n", av7110_num);
 	av7110->device_initialized = 1;
 	av7110_num++;
-        return 0;
+	return 0;
 
 err3:
 	av7110->arm_rmmod = 1;
 	wake_up_interruptible(&av7110->arm_wait);
 	while (av7110->arm_thread)
-		dvb_delay(1);
+		msleep(1);
 err2:
 	av7110_ca_exit(av7110);
 	av7110_av_exit(av7110);
 err:
-	dvb_unregister_i2c_bus (master_xfer,av7110->i2c_bus->adapter,
-				av7110->i2c_bus->id);
+	i2c_del_adapter(&av7110->i2c_adap);
 
-	dvb_unregister_adapter (av7110->dvb_adapter);
+	dvb_unregister_adapter(av7110->dvb_adapter);
 
 	if (NULL != av7110->debi_virt)
 		pci_free_consistent(dev->pci, 8192, av7110->debi_virt, av7110->debi_bus);
@@ -1534,26 +1603,26 @@ err:
 static int av7110_detach (struct saa7146_dev* saa)
 {
 	struct av7110 *av7110 = (struct av7110*)saa->ext_priv;
-	DEB_EE(("av7110: %p\n",av7110));
-	
+	DEB_EE(("av7110: %p\n", av7110));
+
 	if( 0 == av7110->device_initialized ) {
 		return 0;
 	}
 
 	av7110_exit_v4l(av7110);
 
-	av7110->arm_rmmod=1;
+	av7110->arm_rmmod = 1;
 	wake_up_interruptible(&av7110->arm_wait);
 
 	while (av7110->arm_thread)
-		dvb_delay(1);
+		msleep(1);
 
 	dvb_unregister(av7110);
-	
+
 	IER_DISABLE(saa, (MASK_19 | MASK_03));
-//	saa7146_write (av7110->dev, IER, 
+//	saa7146_write (av7110->dev, IER,
 //		     saa7146_read(av7110->dev, IER) & ~(MASK_19 | MASK_03));
-	
+
 	saa7146_write(av7110->dev, ISR,(MASK_19 | MASK_03));
 
 	av7110_ca_exit(av7110);
@@ -1563,22 +1632,23 @@ static int av7110_detach (struct saa7146
 	pci_free_consistent(saa->pci, 8192, av7110->debi_virt,
 			    av7110->debi_bus);
 
-	dvb_unregister_i2c_bus (master_xfer,av7110->i2c_bus->adapter, av7110->i2c_bus->id);
+	i2c_del_adapter(&av7110->i2c_adap);
+
 	dvb_unregister_adapter (av7110->dvb_adapter);
 
 	av7110_num--;
-#ifndef CONFIG_DVB_AV7110_FIRMWARE_FILE 
+#ifndef CONFIG_DVB_AV7110_FIRMWARE_FILE
 	if (av7110->bin_fw)
 		vfree(av7110->bin_fw);
 #endif
-	kfree (av7110);
+	kfree(av7110);
 	saa->ext_priv = NULL;
 
 	return 0;
 }
 
 
-static void av7110_irq(struct saa7146_dev* dev, u32 *isr) 
+static void av7110_irq(struct saa7146_dev* dev, u32 *isr)
 {
 	struct av7110 *av7110 = (struct av7110*)dev->ext_priv;
 
@@ -1586,7 +1656,7 @@ static void av7110_irq(struct saa7146_de
 
 	if (*isr & MASK_19)
 		tasklet_schedule (&av7110->debi_tasklet);
-	
+
 	if (*isr & MASK_03)
 		tasklet_schedule (&av7110->gpio_tasklet);
 }
@@ -1602,7 +1672,7 @@ static struct saa7146_pci_extension_data
 MAKE_AV7110_INFO(fs_1_5, "Siemens cable card PCI rev1.5");
 MAKE_AV7110_INFO(fs_1_3, "Siemens/Technotrend/Hauppauge PCI rev1.3");
 MAKE_AV7110_INFO(tt_1_6, "Technotrend/Hauppauge PCI rev1.3 or 1.6");
-MAKE_AV7110_INFO(tt_2_1, "Technotrend/Hauppauge PCI rev2.1");
+MAKE_AV7110_INFO(tt_2_1, "Technotrend/Hauppauge PCI rev2.1 or 2.2");
 MAKE_AV7110_INFO(tt_t,	 "Technotrend/Hauppauge PCI DVB-T");
 MAKE_AV7110_INFO(unkwn0, "Technotrend/Hauppauge PCI rev?(unknown0)?");
 MAKE_AV7110_INFO(unkwn1, "Technotrend/Hauppauge PCI rev?(unknown1)?");
@@ -1645,17 +1715,17 @@ static struct saa7146_extension av7110_e
 
 	.irq_mask	= MASK_19|MASK_03,
 	.irq_func	= av7110_irq,
-};	
+};
 
 
-static int __init av7110_init(void) 
+static int __init av7110_init(void)
 {
 	int retval;
 	retval = saa7146_register_extension(&av7110_extension);
 #if defined(CONFIG_INPUT_EVDEV) || defined(CONFIG_INPUT_EVDEV_MODULE)
 	if (retval)
 		goto failed_saa7146_register;
-	
+
 	retval = av7110_ir_init();
 	if (retval)
 		goto failed_av7110_ir_init;
@@ -1684,15 +1754,3 @@ MODULE_DESCRIPTION("driver for the SAA71
 MODULE_AUTHOR("Ralph Metzler, Marcus Metzler, others");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(av7110_debug,"i");
-MODULE_PARM(vidmode,"i");
-MODULE_PARM_DESC(vidmode,"analog video out: 0 off, 1 CVBS+RGB (default), 2 CVBS+YC, 3 YC");
-MODULE_PARM(pids_off,"i");
-MODULE_PARM_DESC(pids_off,"clear video/audio/PCR PID filters when demux is closed");
-MODULE_PARM(adac,"i");
-MODULE_PARM_DESC(adac,"audio DAC type: 0 TI, 1 CRYSTAL, 2 MSP (use if autodetection fails)");
-MODULE_PARM(hw_sections, "i");
-MODULE_PARM_DESC(hw_sections, "0 use software section filter, 1 use hardware");
-MODULE_PARM(rgb_on, "i");
-MODULE_PARM_DESC(rgb_on, "For Siemens DVB-C cards only: Enable RGB control"
-		" signal on SCART pin 16 to switch SCART video mode from CVBS to RGB");
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110.h linux/drivers/media/dvb/ttpci/av7110.h
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110.h	2004-09-14 10:34:34.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110.h	2004-09-17 14:56:38.882585507 +0200
@@ -4,13 +4,12 @@
 #include <linux/interrupt.h>
 #include <linux/socket.h>
 #include <linux/netdevice.h>
+#include <linux/i2c.h>
 
 #ifdef CONFIG_DEVFS_FS
 #include <linux/devfs_fs_kernel.h>
 #endif
 
-#include <media/saa7146_vv.h>
-
 #include <linux/dvb/video.h>
 #include <linux/dvb/audio.h>
 #include <linux/dvb/dmx.h>
@@ -26,78 +25,80 @@
 #include "dvb_net.h"
 #include "dvb_ringbuffer.h"
 
+#include <media/saa7146_vv.h>
 
 #define MAXFILT 32
 
 enum {AV_PES_STREAM, PS_STREAM, TS_STREAM, PES_STREAM};
 
 struct av7110_p2t {
-        u8                pes[TS_SIZE];
-        u8                counter;
-        long int          pos;
-        int               frags;
-        struct dvb_demux_feed *feed;
+	u8		  pes[TS_SIZE];
+	u8		  counter;
+	long int	  pos;
+	int		  frags;
+	struct dvb_demux_feed *feed;
 };
 
 /* video MPEG decoder events: */
 /* (code copied from dvb_frontend.c, should maybe be factored out...) */
 #define MAX_VIDEO_EVENT 8
 struct dvb_video_events {
-	struct video_event        events[MAX_VIDEO_EVENT];
-	int                       eventw;
-	int                       eventr;
-	int                       overflow;
-	wait_queue_head_t         wait_queue;
-	spinlock_t                lock;
+	struct video_event	  events[MAX_VIDEO_EVENT];
+	int			  eventw;
+	int			  eventr;
+	int			  overflow;
+	wait_queue_head_t	  wait_queue;
+	spinlock_t		  lock;
 };
 
 
 /* place to store all the necessary device information */
 struct av7110 {
 
-        /* devices */
+	/* devices */
 
-        struct dvb_device       dvb_dev;
-        struct dvb_net               dvb_net;
+	struct dvb_device	dvb_dev;
+	struct dvb_net		dvb_net;
 
-	struct video_device	v4l_dev;
-	struct video_device	vbi_dev;
+	struct video_device	*v4l_dev;
+	struct video_device	*vbi_dev;
 
-        struct saa7146_dev	*dev;
+	struct saa7146_dev	*dev;
+
+	struct i2c_adapter	i2c_adap;
 
-	struct dvb_i2c_bus	*i2c_bus;	
 	char			*card_name;
 
 	/* support for analog module of dvb-c */
 	int			has_analog_tuner;
 	int			current_input;
 	u32			current_freq;
-				
-	struct tasklet_struct   debi_tasklet;
-	struct tasklet_struct   gpio_tasklet;
 
-        int adac_type;         /* audio DAC type */
-#define DVB_ADAC_TI       0
+	struct tasklet_struct	debi_tasklet;
+	struct tasklet_struct	gpio_tasklet;
+
+	int adac_type;	       /* audio DAC type */
+#define DVB_ADAC_TI	  0
 #define DVB_ADAC_CRYSTAL  1
-#define DVB_ADAC_MSP      2
-#define DVB_ADAC_NONE    -1
+#define DVB_ADAC_MSP	  2
+#define DVB_ADAC_NONE	 -1
 
 
-        /* buffers */
+	/* buffers */
 
-        void                   *iobuf;   /* memory for all buffers */
-        struct dvb_ringbuffer        avout;   /* buffer for video or A/V mux */
+	void		       *iobuf;	 /* memory for all buffers */
+	struct dvb_ringbuffer	avout;   /* buffer for video or A/V mux */
 #define AVOUTLEN (128*1024)
-        struct dvb_ringbuffer        aout;    /* buffer for audio */
+	struct dvb_ringbuffer	aout;    /* buffer for audio */
 #define AOUTLEN (64*1024)
-        void                   *bmpbuf;
+	void		       *bmpbuf;
 #define BMPLEN (8*32768+1024)
 
-        /* bitmap buffers and states */
+	/* bitmap buffers and states */
 
-        int                     bmpp;
-        int                     bmplen;
-        int                     bmp_state;
+	int			bmpp;
+	int			bmplen;
+	int			bmp_state;
 #define BMP_NONE     0
 #define BMP_LOADING  1
 #define BMP_LOADINGS 2
@@ -105,100 +106,101 @@ struct av7110 {
 	wait_queue_head_t	bmpq;
 
 
-        /* DEBI and polled command interface */
+	/* DEBI and polled command interface */
 
-        spinlock_t              debilock;
-        struct semaphore        dcomlock;
-        int                     debitype;
-        int                     debilen;
+	spinlock_t		debilock;
+	struct semaphore	dcomlock;
+	int			debitype;
+	int			debilen;
 
 
-        /* Recording and playback flags */
+	/* Recording and playback flags */
 
-        int                     rec_mode;
-        int                     playing;
+	int			rec_mode;
+	int			playing;
 #define RP_NONE  0
 #define RP_VIDEO 1
 #define RP_AUDIO 2
-#define RP_AV    3
+#define RP_AV	 3
 
 
-        /* OSD */
+	/* OSD */
 
-        int                     osdwin;      /* currently active window */
-        u16                     osdbpp[8];
+	int			osdwin;      /* currently active window */
+	u16			osdbpp[8];
+	struct semaphore	osd_sema;
 
+	/* CA */
 
-        /* CA */
+	ca_slot_info_t		ci_slot[2];
 
-        ca_slot_info_t          ci_slot[2];
+	int			vidmode;
+	struct dmxdev		dmxdev;
+	struct dvb_demux	demux;
 
-        int                     vidmode;
-        struct dmxdev		dmxdev;
-        struct dvb_demux             demux;
+	struct dmx_frontend	hw_frontend;
+	struct dmx_frontend	mem_frontend;
 
-        struct dmx_frontend	hw_frontend;
-        struct dmx_frontend	mem_frontend;
+	int			fe_synced;
+	struct semaphore	pid_mutex;
 
-        int                     fe_synced; 
-        struct semaphore        pid_mutex;
-
-        int                     video_blank;
-        struct video_status     videostate;
-        int                     display_ar;
-        int                     trickmode;
+	int			video_blank;
+	struct video_status	videostate;
+	int			display_ar;
+	int			trickmode;
 #define TRICK_NONE   0
 #define TRICK_FAST   1
 #define TRICK_SLOW   2
 #define TRICK_FREEZE 3
-        struct audio_status      audiostate;
+	struct audio_status	audiostate;
 
-        struct dvb_demux_filter     *handle2filter[32];
-        struct av7110_p2t		p2t_filter[MAXFILT];
-        struct dvb_filter_pes2ts	p2t[2];
-        struct ipack			ipack[2];
-        u8                     *kbuf[2];
+	struct dvb_demux_filter *handle2filter[32];
+	struct av7110_p2t	 p2t_filter[MAXFILT];
+	struct dvb_filter_pes2ts p2t[2];
+	struct ipack		 ipack[2];
+	u8			*kbuf[2];
 
-        int sinfo;
-        int feeding;
+	int sinfo;
+	int feeding;
 
-        int arm_errors;
-        int registered;
+	int arm_errors;
+	int registered;
 
 
 	/* AV711X */
 
-        u32                 arm_fw;
-        u32                 arm_rtsl;
-        u32                 arm_vid;
-        u32                 arm_app;
-        u32                 avtype;
-        int                 arm_ready;
-        struct task_struct *arm_thread;
+	u32		    arm_fw;
+	u32		    arm_rtsl;
+	u32		    arm_vid;
+	u32		    arm_app;
+	u32		    avtype;
+	int		    arm_ready;
+	struct task_struct *arm_thread;
 	wait_queue_head_t   arm_wait;
-        u16                 arm_loops;
-        int                 arm_rmmod;
+	u16		    arm_loops;
+	int		    arm_rmmod;
+
+	void		   *debi_virt;
+	dma_addr_t	    debi_bus;
+
+	u16		    pids[DMX_PES_OTHER];
 
-        void               *debi_virt;
-        dma_addr_t          debi_bus;
+	struct dvb_ringbuffer	 ci_rbuffer;
+	struct dvb_ringbuffer	 ci_wbuffer;
 
-        u16                 pids[DMX_PES_OTHER];
-        
-        struct dvb_ringbuffer    ci_rbuffer;
-        struct dvb_ringbuffer    ci_wbuffer;
-
-
-        struct dvb_adapter       *dvb_adapter;
-        struct dvb_device        *video_dev;
-        struct dvb_device        *audio_dev;
-        struct dvb_device        *ca_dev;
-        struct dvb_device        *osd_dev;
+	struct audio_mixer	mixer;
+
+	struct dvb_adapter	 *dvb_adapter;
+	struct dvb_device	 *video_dev;
+	struct dvb_device	 *audio_dev;
+	struct dvb_device	 *ca_dev;
+	struct dvb_device	 *osd_dev;
 
 	struct dvb_video_events  video_events;
-	video_size_t             video_size;
+	video_size_t		 video_size;
+
+	u32		    ir_config;
 
-        u32                 ir_config;
-	
 	/* firmware stuff */
 	unsigned int device_initialized;
 
@@ -217,7 +219,7 @@ extern void ChangePIDs(struct av7110 *av
 		       u16 subpid, u16 pcrpid);
 
 extern void av7110_register_irc_handler(void (*func)(u32));
-extern void av7110_unregister_irc_handler(void (*func)(u32)); 
+extern void av7110_unregister_irc_handler(void (*func)(u32));
 extern void av7110_setup_irc_config (struct av7110 *av7110, u32 ir_config);
 
 extern int av7110_ir_init (void);
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_av.c linux/drivers/media/dvb/ttpci/av7110_av.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_av.c	2004-09-14 10:34:52.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110_av.c	2004-09-17 14:56:38.886584758 +0200
@@ -37,14 +37,10 @@
 #include <linux/smp_lock.h>
 #include <linux/fs.h>
 
-#define DEBUG_VARIABLE av7110_debug
-extern int av7110_debug;
-
 #include "av7110.h"
 #include "av7110_hw.h"
 #include "av7110_av.h"
 #include "av7110_ipack.h"
-#include "dvb_functions.h"
 
 /* MPEG-2 (ISO 13818 / H.222.0) stream types */
 #define PROG_STREAM_MAP  0xBC
@@ -93,7 +89,6 @@ extern int av7110_debug;
 #define PIECE_RATE	 0x40
 #define SEAM_SPLICE	 0x20
 
-
 static void p_to_t(u8 const *buf, long int length, u16 pid,
 		   u8 *counter, struct dvb_demux_feed *feed);
 
@@ -285,13 +280,15 @@ int av7110_pes_play(void *dest, struct d
 	return blen;
 }
 
-
 int av7110_set_volume(struct av7110 *av7110, int volleft, int volright)
 {
 	int err, vol, val, balance = 0;
 
 	DEB_EE(("av7110: %p\n", av7110));
 
+	av7110->mixer.volume_left = volleft;
+	av7110->mixer.volume_right = volright;
+
 	switch (av7110->adac_type) {
 	case DVB_ADAC_TI:
 		volleft = (volleft * 256) / 1036;
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_ca.c linux/drivers/media/dvb/ttpci/av7110_ca.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_ca.c	2004-09-14 10:36:46.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110_ca.c	2004-09-17 14:56:38.889584196 +0200
@@ -38,13 +38,8 @@
 #include <linux/byteorder/swabb.h>
 #include <linux/smp_lock.h>
 
-#define DEBUG_VARIABLE av7110_debug
-extern int av7110_debug;
-
-#include "dvb_i2c.h"
 #include "av7110.h"
 #include "av7110_hw.h"
-#include "dvb_functions.h"
 
 
 void CI_handle(struct av7110 *av7110, u8 *data, u16 len)
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_hw.c linux/drivers/media/dvb/ttpci/av7110_hw.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_hw.c	2004-09-14 10:36:44.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110_hw.c	2004-09-17 14:56:38.894583259 +0200
@@ -38,12 +38,8 @@
 #include <linux/smp_lock.h>
 #include <linux/fs.h>
 
-#define DEBUG_VARIABLE av7110_debug
-extern int av7110_debug;
-
 #include "av7110.h"
 #include "av7110_hw.h"
-#include "dvb_functions.h"
 
 /****************************************************************************
  * DEBI functions
@@ -106,7 +102,7 @@ void av7110_reset_arm(struct av7110 *av7
 	saa7146_write(av7110->dev, ISR, (MASK_19 | MASK_03));
 
 	saa7146_setgpio(av7110->dev, RESET_LINE, SAA7146_GPIO_OUTHI);
-	dvb_delay(30);	/* the firmware needs some time to initialize */
+	msleep(30);	/* the firmware needs some time to initialize */
 
 	ARM_ResetMailBox(av7110);
 
@@ -268,7 +264,7 @@ int av7110_bootarm(struct av7110 *av7110
 		return -1;
 	}
 	saa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTHI);
-	dvb_delay(30);	/* the firmware needs some time to initialize */
+	msleep(30);	/* the firmware needs some time to initialize */
 
 	//ARM_ClearIrq(av7110);
 	ARM_ResetMailBox(av7110);
@@ -302,7 +298,7 @@ int __av7110_send_fw_cmd(struct av7110 *
 
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2 )) {
-		dvb_delay(1);
+		msleep(1);
 		if (time_after(jiffies, start + ARM_WAIT_FREE)) {
 			printk(KERN_ERR "%s: timeout waiting for COMMAND idle\n", __FUNCTION__);
 			return -1;
@@ -312,7 +308,7 @@ int __av7110_send_fw_cmd(struct av7110 *
 #ifndef _NOHANDSHAKE
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2 )) {
-		dvb_delay(1);
+		msleep(1);
 		if (time_after(jiffies, start + ARM_WAIT_SHAKE)) {
 			printk(KERN_ERR "%s: timeout waiting for HANDSHAKE_REG\n", __FUNCTION__);
 			return -1;
@@ -322,7 +318,7 @@ int __av7110_send_fw_cmd(struct av7110 *
 
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2) & OSDQFull) {
-		dvb_delay(1);
+		msleep(1);
 		if (time_after(jiffies, start + ARM_WAIT_OSD)) {
 			printk(KERN_ERR "%s: timeout waiting for !OSDQFull\n", __FUNCTION__);
 			return -1;
@@ -341,7 +337,7 @@ int __av7110_send_fw_cmd(struct av7110 *
 #ifdef COM_DEBUG
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2 )) {
-		dvb_delay(1);
+		msleep(1);
 		if (time_after(jiffies, start + ARM_WAIT_FREE)) {
 			printk(KERN_ERR "%s: timeout waiting for COMMAND to complete\n",
 			       __FUNCTION__);
@@ -458,7 +454,7 @@ int av7110_fw_request(struct av7110 *av7
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2)) {
 #ifdef _NOHANDSHAKE
-		dvb_delay(1);
+		msleep(1);
 #endif
 		if (time_after(jiffies, start + ARM_WAIT_FREE)) {
 			printk("%s: timeout waiting for COMMAND to complete\n", __FUNCTION__);
@@ -470,7 +466,7 @@ int av7110_fw_request(struct av7110 *av7
 #ifndef _NOHANDSHAKE
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2 )) {
-		dvb_delay(1);
+		msleep(1);
 		if (time_after(jiffies, start + ARM_WAIT_SHAKE)) {
 			printk(KERN_ERR "%s: timeout waiting for HANDSHAKE_REG\n", __FUNCTION__);
 			up(&av7110->dcomlock);
@@ -630,7 +626,7 @@ static int FlushText(struct av7110 *av71
 		return -ERESTARTSYS;
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, BUFF1_BASE, 0, 2)) {
-		dvb_delay(1);
+		msleep(1);
 		if (time_after(jiffies, start + ARM_WAIT_OSD)) {
 			printk(KERN_ERR "%s: timeout waiting for BUFF1_BASE == 0\n",
 			       __FUNCTION__);
@@ -654,7 +650,7 @@ static int WriteText(struct av7110 *av71
 
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, BUFF1_BASE, 0, 2)) {
-		dvb_delay(1);
+		msleep(1);
 		if (time_after(jiffies, start + ARM_WAIT_OSD)) {
 			printk(KERN_ERR "%s: timeout waiting for BUFF1_BASE == 0\n",
 			       __FUNCTION__);
@@ -665,7 +661,7 @@ static int WriteText(struct av7110 *av71
 #ifndef _NOHANDSHAKE
 	start = jiffies;
 	while (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2)) {
-		dvb_delay(1);
+		msleep(1);
 		if (time_after(jiffies, start + ARM_WAIT_SHAKE)) {
 			printk(KERN_ERR "%s: timeout waiting for HANDSHAKE_REG\n",
 			       __FUNCTION__);
@@ -721,7 +717,7 @@ static inline int DestroyOSDWindow(struc
 }
 
 static inline int CreateOSDWindow(struct av7110 *av7110, u8 windownr,
-				  enum av7110_window_display_type disptype,
+				  osd_raw_window_t disptype,
 				  u16 width, u16 height)
 {
 	return av7110_fw_cmd(av7110, COMTYPE_OSD, WCreate, 4,
@@ -732,8 +728,8 @@ static inline int CreateOSDWindow(struct
 static enum av7110_osd_palette_type bpp2pal[8] = {
 	Pal1Bit, Pal2Bit, 0, Pal4Bit, 0, 0, 0, Pal8Bit
 };
-static enum av7110_window_display_type bpp2bit[8] = {
-	BITMAP1, BITMAP2, 0, BITMAP4, 0, 0, 0, BITMAP8
+static osd_raw_window_t bpp2bit[8] = {
+	OSD_BITMAP1, OSD_BITMAP2, 0, OSD_BITMAP4, 0, 0, 0, OSD_BITMAP8
 };
 
 static inline int LoadBitmap(struct av7110 *av7110, u16 format,
@@ -743,32 +739,26 @@ static inline int LoadBitmap(struct av71
 	int i;
 	int d, delta;
 	u8 c;
-	DECLARE_WAITQUEUE(wait, current);
-
+	int ret;
+	
 	DEB_EE(("av7110: %p\n", av7110));
 
-	if (av7110->bmp_state == BMP_LOADING) {
-		add_wait_queue(&av7110->bmpq, &wait);
-		while (1) {
-			set_current_state(TASK_INTERRUPTIBLE);
-			if (av7110->bmp_state != BMP_LOADING
-			    || signal_pending(current))
-				break;
-			schedule();
-		}
-		set_current_state(TASK_RUNNING);
-		remove_wait_queue(&av7110->bmpq, &wait);
-	}
-	if (av7110->bmp_state == BMP_LOADING)
+	ret = wait_event_interruptible_timeout(av7110->bmpq, av7110->bmp_state != BMP_LOADING, HZ);
+	if (ret == -ERESTARTSYS || ret == 0) {
+		printk("dvb-ttpci: warning: timeout waiting in %s()\n", __FUNCTION__);
+		av7110->bmp_state = BMP_NONE;
 		return -1;
+	}
+	BUG_ON (av7110->bmp_state == BMP_LOADING);
+
 	av7110->bmp_state = BMP_LOADING;
-	if	(format == BITMAP8) {
+	if	(format == OSD_BITMAP8) {
 		bpp=8; delta = 1;
-	} else if (format == BITMAP4) {
+	} else if (format == OSD_BITMAP4) {
 		bpp=4; delta = 2;
-	} else if (format == BITMAP2) {
+	} else if (format == OSD_BITMAP2) {
 		bpp=2; delta = 4;
-	} else if (format == BITMAP1) {
+	} else if (format == OSD_BITMAP1) {
 		bpp=1; delta = 8;
 	} else {
 		av7110->bmp_state = BMP_NONE;
@@ -786,7 +776,7 @@ static inline int LoadBitmap(struct av71
 			return -1;
 		}
 	}
-	if (format != BITMAP8) {
+	if (format != OSD_BITMAP8) {
 		for (i = 0; i < dx * dy / delta; i++) {
 			c = ((u8 *)av7110->bmpbuf)[1024 + i * delta + delta - 1];
 			for (d = delta - 2; d >= 0; d--) {
@@ -802,27 +792,22 @@ static inline int LoadBitmap(struct av71
 
 static int BlitBitmap(struct av7110 *av7110, u16 win, u16 x, u16 y, u16 trans)
 {
-	DECLARE_WAITQUEUE(wait, current);
+	int ret;
 
 	DEB_EE(("av7110: %p\n", av7110));
 
-       if (av7110->bmp_state == BMP_NONE)
+	BUG_ON (av7110->bmp_state == BMP_NONE);
+
+	ret = wait_event_interruptible_timeout(av7110->bmpq, av7110->bmp_state != BMP_LOADING, HZ);
+	if (ret == -ERESTARTSYS || ret == 0) {
+		printk("dvb-ttpci: warning: timeout waiting in %s()\n", __FUNCTION__);
+		av7110->bmp_state = BMP_NONE;
 		return -1;
-	if (av7110->bmp_state == BMP_LOADING) {
-		add_wait_queue(&av7110->bmpq, &wait);
-		while (1) {
-			set_current_state(TASK_INTERRUPTIBLE);
-			if (av7110->bmp_state != BMP_LOADING
-			    || signal_pending(current))
-				break;
-			schedule();
-		}
-		set_current_state(TASK_RUNNING);
-		remove_wait_queue(&av7110->bmpq, &wait);
 	}
-	if (av7110->bmp_state == BMP_LOADED)
-		return av7110_fw_cmd(av7110, COMTYPE_OSD, BlitBmp, 4, win, x, y, trans);
-	return -1;
+
+	BUG_ON (av7110->bmp_state != BMP_LOADED);
+
+	return av7110_fw_cmd(av7110, COMTYPE_OSD, BlitBmp, 4, win, x, y, trans);
 }
 
 static inline int ReleaseBitmap(struct av7110 *av7110)
@@ -865,18 +850,22 @@ static void OSDSetColor(struct av7110 *a
 		  color, ((blend >> 4) & 0x0f));
 }
 
-static int OSDSetPalette(struct av7110 *av7110, u32 *colors, u8 first, u8 last)
+static int OSDSetPalette(struct av7110 *av7110, u32 __user * colors, u8 first, u8 last)
 {
        int i;
        int length = last - first + 1;
 
        if (length * 4 > DATA_BUFF3_SIZE)
-	       return -1;
+	       return -EINVAL;
 
        for (i = 0; i < length; i++) {
-	       u32 blend = (colors[i] & 0xF0000000) >> 4;
-	       u32 yuv = blend ? RGB2YUV(colors[i] & 0xFF, (colors[i] >> 8) & 0xFF,
-					 (colors[i] >> 16) & 0xFF) | blend : 0;
+	       u32 color, blend, yuv;
+
+	       if (get_user(color, colors + i))
+		       return -EFAULT;
+	       blend = (color & 0xF0000000) >> 4;
+	       yuv = blend ? RGB2YUV(color & 0xFF, (color >> 8) & 0xFF,
+				     (color >> 16) & 0xFF) | blend : 0;
 	       yuv = ((yuv & 0xFFFF0000) >> 16) | ((yuv & 0x0000FFFF) << 16);
 	       wdebi(av7110, DEBINOSWAP, DATA_BUFF3_BASE + i * 4, yuv, 4);
        }
@@ -887,7 +876,7 @@ static int OSDSetPalette(struct av7110 *
 }
 
 static int OSDSetBlock(struct av7110 *av7110, int x0, int y0,
-		       int x1, int y1, int inc, u8 __user *data)
+		       int x1, int y1, int inc, u8 __user * data)
 {
 	uint w, h, bpp, bpl, size, lpb, bnum, brest;
 	int i;
@@ -922,10 +911,19 @@ static int OSDSetBlock(struct av7110 *av
 
 int av7110_osd_cmd(struct av7110 *av7110, osd_cmd_t *dc)
 {
+	int ret;
+	
+	ret = down_interruptible(&av7110->osd_sema);
+	if (ret)
+		return -ERESTARTSYS;
+
+	/* stupid, but OSD functions don't provide a return code anyway */
+	ret = 0;
+	
 	switch (dc->cmd) {
 	case OSD_Close:
 		DestroyOSDWindow(av7110, av7110->osdwin);
-		return 0;
+		goto out;
 	case OSD_Open:
 		av7110->osdbpp[av7110->osdwin] = (dc->color - 1) & 7;
 		CreateOSDWindow(av7110, av7110->osdwin,
@@ -935,90 +933,84 @@ int av7110_osd_cmd(struct av7110 *av7110
 			MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);
 			SetColorBlend(av7110, av7110->osdwin);
 		}
-		return 0;
+		goto out;
 	case OSD_Show:
 		MoveWindowRel(av7110, av7110->osdwin, 0, 0);
-		return 0;
+		goto out;
 	case OSD_Hide:
 		HideWindow(av7110, av7110->osdwin);
-		return 0;
+		goto out;
 	case OSD_Clear:
 		DrawBlock(av7110, av7110->osdwin, 0, 0, 720, 576, 0);
-		return 0;
+		goto out;
 	case OSD_Fill:
 		DrawBlock(av7110, av7110->osdwin, 0, 0, 720, 576, dc->color);
-		return 0;
+		goto out;
 	case OSD_SetColor:
 		OSDSetColor(av7110, dc->color, dc->x0, dc->y0, dc->x1, dc->y1);
-		return 0;
+		goto out;
 	case OSD_SetPalette:
 	{
-		int len = dc->x0-dc->color+1;
-		void *buf;
-		if (len <= 0)
-			return 0;
-
-		buf = kmalloc(len * 4, GFP_KERNEL);
-		if (!buf)
-			return -ENOMEM;
-
-		if (copy_from_user(buf, dc->data, len * 4)) {
-			kfree(buf);
-			return -EFAULT;
-		}
-
-		if (FW_VERSION(av7110->arm_app) >= 0x2618)
-			OSDSetPalette(av7110, buf, dc->color, dc->x0);
-		else {
-			int i;
-			u8 *colors = buf;
-
-			for (i = 0; i<len; i++)
-				OSDSetColor(av7110, dc->color + i,
-					colors[i * 4], colors[i * 4 + 1],
-					colors[i * 4 + 2], colors[i * 4 + 3]);
+		if (FW_VERSION(av7110->arm_app) >= 0x2618) {
+			ret = OSDSetPalette(av7110, (u32 *)dc->data, dc->color, dc->x0);
+			goto out;
+		} else {
+			int i, len = dc->x0-dc->color+1;
+			u8 *colors = (u8 *)dc->data;
+			u8 r, g, b, blend;
+
+			for (i = 0; i<len; i++) {
+				if (get_user(r, colors + i * 4) ||
+				    get_user(g, colors + i * 4 + 1) ||
+				    get_user(b, colors + i * 4 + 2) ||
+				    get_user(blend, colors + i * 4 + 3)) {
+					ret = -EFAULT;
+					goto out;
+				    }
+				OSDSetColor(av7110, dc->color + i, r, g, b, blend);
+			}
 		}
-		kfree(buf);
-		return 0;
+		ret = 0;
+		goto out;
 	}
 	case OSD_SetTrans:
-		return 0;
+		goto out;
 	case OSD_SetPixel:
 		DrawLine(av7110, av7110->osdwin,
 			 dc->x0, dc->y0, 0, 0, dc->color);
-		return 0;
+		goto out;
 	case OSD_GetPixel:
-		return 0;
-
+		goto out;
 	case OSD_SetRow:
 		dc->y1 = dc->y0;
 		/* fall through */
 	case OSD_SetBlock:
 		OSDSetBlock(av7110, dc->x0, dc->y0, dc->x1, dc->y1, dc->color, dc->data);
-		return 0;
-
+		goto out;
 	case OSD_FillRow:
 		DrawBlock(av7110, av7110->osdwin, dc->x0, dc->y0,
 			  dc->x1-dc->x0+1, dc->y1, dc->color);
-		return 0;
+		goto out;
 	case OSD_FillBlock:
 		DrawBlock(av7110, av7110->osdwin, dc->x0, dc->y0,
 			  dc->x1 - dc->x0 + 1, dc->y1 - dc->y0 + 1, dc->color);
-		return 0;
+		goto out;
 	case OSD_Line:
 		DrawLine(av7110, av7110->osdwin,
 			 dc->x0, dc->y0, dc->x1 - dc->x0, dc->y1 - dc->y0, dc->color);
-		return 0;
+		goto out;
 	case OSD_Query:
-		return 0;
+		goto out;
 	case OSD_Test:
-		return 0;
+		goto out;
 	case OSD_Text:
 	{
 		char textbuf[240];
 
-		if (strncpy_from_user(textbuf, dc->data, 240) < 0)
-			return -EFAULT;
+		if (strncpy_from_user(textbuf, dc->data, 240) < 0) {
+			ret = -EFAULT;
+			goto out;
+		}
 		textbuf[239] = 0;
 		if (dc->x1 > 3)
 			dc->x1 = 3;
@@ -1026,19 +1018,58 @@ int av7110_osd_cmd(struct av7110 *av7110
 			(u16) (dc->color & 0xffff), (u16) (dc->color >> 16));
 		FlushText(av7110);
 		WriteText(av7110, av7110->osdwin, dc->x0, dc->y0, textbuf);
-		return 0;
+		goto out;
 	}
 	case OSD_SetWindow:
-		if (dc->x0 < 1 || dc->x0 > 7)
-			return -EINVAL;
+		if (dc->x0 < 1 || dc->x0 > 7) {
+			ret = -EINVAL;
+			goto out;
+		}
 		av7110->osdwin = dc->x0;
-		return 0;
+		goto out;
 	case OSD_MoveWindow:
 		MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);
 		SetColorBlend(av7110, av7110->osdwin);
-		return 0;
+		goto out;
+	case OSD_OpenRaw:
+		if (dc->color < OSD_BITMAP1 || dc->color > OSD_CURSOR) {
+			ret = -EINVAL;
+			goto out;
+		}
+		if (dc->color >= OSD_BITMAP1 && dc->color <= OSD_BITMAP8HR) {
+			av7110->osdbpp[av7110->osdwin] = (1 << (dc->color & 3)) - 1;
+		}
+		else {
+			av7110->osdbpp[av7110->osdwin] = 0;
+		}
+		CreateOSDWindow(av7110, av7110->osdwin, (osd_raw_window_t)dc->color,
+				dc->x1 - dc->x0 + 1, dc->y1 - dc->y0 + 1);
+		if (!dc->data) {
+			MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);
+			SetColorBlend(av7110, av7110->osdwin);
+		}
+		goto out;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out;
 	}
+
+out:
+	up(&av7110->osd_sema);
+	return ret;
+}
+
+int av7110_osd_capability(struct av7110 *av7110, osd_cap_t *cap)
+{
+        switch (cap->cmd) {
+        case OSD_CAP_MEMSIZE:
+                if (FW_4M_SDRAM(av7110->arm_app))
+                        cap->val = 1000000;
+                else
+                        cap->val = 92000;
+                return 0;
+        default:
+                return -EINVAL;
+        }
 }
 #endif /* CONFIG_DVB_AV7110_OSD */
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_hw.h linux/drivers/media/dvb/ttpci/av7110_hw.h
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_hw.h	2004-09-14 10:35:15.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110_hw.h	2004-09-17 14:56:38.896582884 +0200
@@ -39,29 +39,6 @@ enum av7110_osd_palette_type
 	Pal8Bit =  256	   /* 256 colors for 16 bit palette */
 };
 
-enum av7110_window_display_type {
-	BITMAP1,	   /* 1 bit bitmap */
-	BITMAP2,	   /* 2 bit bitmap */
-	BITMAP4,	   /* 4 bit bitmap */
-	BITMAP8,	   /* 8 bit bitmap */
-	BITMAP1HR,	   /* 1 Bit bitmap half resolution */
-	BITMAP2HR,	   /* 2 bit bitmap half resolution */
-	BITMAP4HR,	   /* 4 bit bitmap half resolution */
-	BITMAP8HR,	   /* 8 bit bitmap half resolution */
-	YCRCB422,	   /* 4:2:2 YCRCB Graphic Display */
-	YCRCB444,	   /* 4:4:4 YCRCB Graphic Display */
-	YCRCB444HR,	   /* 4:4:4 YCRCB graphic half resolution */
-	VIDEOTSIZE,	   /* True Size Normal MPEG Video Display */
-	VIDEOHSIZE,	   /* MPEG Video Display Half Resolution */
-	VIDEOQSIZE,	   /* MPEG Video Display Quarter Resolution */
-	VIDEODSIZE,	   /* MPEG Video Display Double Resolution */
-	VIDEOTHSIZE,	   /* True Size MPEG Video Display Half Resolution */
-	VIDEOTQSIZE,	   /* True Size MPEG Video Display Quarter Resolution*/
-	VIDEOTDSIZE,	   /* True Size MPEG Video Display Double Resolution */
-	VIDEONSIZE,	   /* Full Size MPEG Video Display */
-	CURSOR		   /* Cursor */
-};
-
 /* switch defines */
 #define SB_GPIO 3
 #define SB_OFF	SAA7146_GPIO_OUTLO  /* SlowBlank off (TV-Mode) */
@@ -388,6 +365,7 @@ extern void av7110_reset_arm(struct av71
 extern int av7110_bootarm(struct av7110 *av7110);
 extern int av7110_firmversion(struct av7110 *av7110);
 #define FW_CI_LL_SUPPORT(arm_app) ((arm_app) & 0x80000000)
+#define FW_4M_SDRAM(arm_app)      ((arm_app) & 0x40000000)
 #define FW_VERSION(arm_app)	  ((arm_app) & 0x0000FFFF)
 
 extern int av7110_fw_cmd(struct av7110 *av7110, int type, int com, int num, ...);
@@ -495,7 +473,7 @@ static int inline vidcom(struct av7110 *
 
 static int inline audcom(struct av7110 *av7110, u32 com)
 {
-	return av7110_fw_cmd(av7110, COMTYPE_MISC, AV7110_FW_AUDIO_COMMAND, 4,
+	return av7110_fw_cmd(av7110, COMTYPE_MISC, AV7110_FW_AUDIO_COMMAND, 2,
 			     (com>>16), (com&0xffff));
 }
 
@@ -510,6 +488,7 @@ extern int av7110_diseqc_send(struct av7
 
 #ifdef CONFIG_DVB_AV7110_OSD
 extern int av7110_osd_cmd(struct av7110 *av7110, osd_cmd_t *dc);
+extern int av7110_osd_capability(struct av7110 *av7110, osd_cap_t *cap);
 #endif /* CONFIG_DVB_AV7110_OSD */
 
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_ipack.c linux/drivers/media/dvb/ttpci/av7110_ipack.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_ipack.c	2004-09-14 10:35:18.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110_ipack.c	2004-09-17 14:56:38.900582135 +0200
@@ -21,9 +21,9 @@ void av7110_ipack_reset(struct ipack *p)
 
 
 int av7110_ipack_init(struct ipack *p, int size,
-		       void (*func)(u8 *buf, int size, void *priv))
+		      void (*func)(u8 *buf, int size, void *priv))
 {
-	if ( !(p->buf = vmalloc(size*sizeof(u8))) ){
+	if (!(p->buf = vmalloc(size*sizeof(u8)))) {
 		printk ("Couldn't allocate memory for ipack\n");
 		return -ENOMEM;
 	}
@@ -35,7 +35,7 @@ int av7110_ipack_init(struct ipack *p, i
 }
 
 
-void av7110_ipack_free(struct ipack * p)
+void av7110_ipack_free(struct ipack *p)
 {
 	if (p->buf)
 		vfree(p->buf);
@@ -47,44 +47,44 @@ static void send_ipack(struct ipack *p)
 	int off;
 	struct dvb_audio_info ai;
 	int ac3_off = 0;
-	int streamid=0;
-	int nframes= 0;
-	int f=0;
+	int streamid = 0;
+	int nframes = 0;
+	int f = 0;
 
-	switch ( p->mpeg ){
-	case 2:		
+	switch (p->mpeg) {
+	case 2:
 		if (p->count < 10)
 			return;
 		p->buf[3] = p->cid;
 		p->buf[4] = (u8)(((p->count - 6) & 0xff00) >> 8);
 		p->buf[5] = (u8)((p->count - 6) & 0x00ff);
-		if (p->repack_subids && p->cid == PRIVATE_STREAM1){
-			off = 9+p->buf[8];
+		if (p->repack_subids && p->cid == PRIVATE_STREAM1) {
+			off = 9 + p->buf[8];
 			streamid = p->buf[off];
 			if ((streamid & 0xf8) == 0x80) {
 				ai.off = 0;
-				ac3_off = ((p->buf[off+2] << 8)| 
-					   p->buf[off+3]);
+				ac3_off = ((p->buf[off + 2] << 8)|
+					   p->buf[off + 3]);
 				if (ac3_off < p->count)
-					f=dvb_filter_get_ac3info(p->buf+off+3+ac3_off, 
-						      p->count-ac3_off, &ai,0);
-				if ( !f ){
-					nframes = (p->count-off-3-ac3_off)/ 
+					f = dvb_filter_get_ac3info(p->buf + off + 3 + ac3_off,
+								   p->count - ac3_off, &ai, 0);
+				if (!f) {
+					nframes = (p->count - off - 3 - ac3_off) /
 						ai.framesize + 1;
 					p->buf[off + 2] = (ac3_off >> 8) & 0xff;
 					p->buf[off + 3] = (ac3_off) & 0xff;
-					p->buf[off+1] = nframes;
+					p->buf[off + 1] = nframes;
 					ac3_off +=  nframes * ai.framesize - p->count;
 				}
 			}
-		} 
+		}
 		p->func(p->buf, p->count, p->data);
-	
+
 		p->buf[6] = 0x80;
 		p->buf[7] = 0x00;
 		p->buf[8] = 0x00;
 		p->count = 9;
-		if (p->repack_subids && p->cid == PRIVATE_STREAM1 
+		if (p->repack_subids && p->cid == PRIVATE_STREAM1
 		    && (streamid & 0xf8) == 0x80) {
 			p->count += 4;
 			p->buf[9] = streamid;
@@ -101,7 +101,7 @@ static void send_ipack(struct ipack *p)
 		p->buf[4] = (u8)(((p->count - 6) & 0xff00) >> 8);
 		p->buf[5] = (u8)((p->count - 6) & 0x00ff);
 		p->func(p->buf, p->count, p->data);
-	
+
 		p->buf[6] = 0x0f;
 		p->count = 7;
 		break;
@@ -111,9 +111,9 @@ static void send_ipack(struct ipack *p)
 
 void av7110_ipack_flush(struct ipack *p)
 {
-	if (p->plength != MMAX_PLENGTH-6 || p->found<=6)
+	if (p->plength != MMAX_PLENGTH - 6 || p->found <= 6)
 		return;
-	p->plength = p->found-6;
+	p->plength = p->found - 6;
 	p->found = 0;
 	send_ipack(p);
 	av7110_ipack_reset(p);
@@ -122,9 +122,9 @@ void av7110_ipack_flush(struct ipack *p)
 
 static void write_ipack(struct ipack *p, const u8 *data, int count)
 {
-	u8 headr[3] = { 0x00, 0x00, 0x01} ;
+	u8 headr[3] = { 0x00, 0x00, 0x01 };
 
-	if (p->count < 6){
+	if (p->count < 6) {
 		memcpy(p->buf, headr, 3);
 		p->count = 6;
 	}
@@ -138,7 +138,7 @@ static void write_ipack(struct ipack *p,
 		p->count += rest;
 		send_ipack(p);
 		if (count - rest > 0)
-			write_ipack(p, data+rest, count-rest);
+			write_ipack(p, data + rest, count - rest);
 	}
 }
 
@@ -146,13 +146,13 @@ static void write_ipack(struct ipack *p,
 int av7110_ipack_instant_repack (const u8 *buf, int count, struct ipack *p)
 {
 	int l;
-	int c=0;
+	int c = 0;
 
 	while (c < count && (p->mpeg == 0 ||
 			     (p->mpeg == 1 && p->found < 7) ||
 			     (p->mpeg == 2 && p->found < 9))
-	       &&  (p->found < 5 || !p->done)){
-		switch ( p->found ){
+	       &&  (p->found < 5 || !p->done)) {
+		switch (p->found) {
 		case 0:
 		case 1:
 			if (buf[c] == 0x00)
@@ -172,7 +172,7 @@ int av7110_ipack_instant_repack (const u
 			break;
 		case 3:
 			p->cid = 0;
-			switch (buf[c]){
+			switch (buf[c]) {
 			case PROG_STREAM_MAP:
 			case PRIVATE_STREAM2:
 			case PROG_STREAM_DIR:
@@ -195,16 +195,16 @@ int av7110_ipack_instant_repack (const u
 				break;
 			}
 			break;
-			
+
 		case 4:
-			if (count-c > 1){
+			if (count-c > 1) {
 				p->plen[0] = buf[c];
 				c++;
 				p->plen[1] = buf[c];
 				c++;
-				p->found+=2;
-				p->plength=(p->plen[0]<<8)|p->plen[1];
- 			} else {
+				p->found += 2;
+				p->plength = (p->plen[0] << 8) | p->plen[1];
+			} else {
 				p->plen[0] = buf[c];
 				p->found++;
 				return count;
@@ -214,10 +214,10 @@ int av7110_ipack_instant_repack (const u
 			p->plen[1] = buf[c];
 			c++;
 			p->found++;
-			p->plength=(p->plen[0]<<8)|p->plen[1];
+			p->plength = (p->plen[0] << 8) | p->plen[1];
 			break;
 		case 6:
-			if (!p->done){
+			if (!p->done) {
 				p->flag1 = buf[c];
 				c++;
 				p->found++;
@@ -233,15 +233,15 @@ int av7110_ipack_instant_repack (const u
 			break;
 
 		case 7:
-			if ( !p->done && p->mpeg == 2) {
+			if (!p->done && p->mpeg == 2) {
 				p->flag2 = buf[c];
 				c++;
 				p->found++;
-			}	
+			}
 			break;
 
 		case 8:
-			if ( !p->done && p->mpeg == 2) {
+			if (!p->done && p->mpeg == 2) {
 				p->hlength = buf[c];
 				c++;
 				p->found++;
@@ -256,28 +256,26 @@ int av7110_ipack_instant_repack (const u
 	if (!p->plength)
 		p->plength = MMAX_PLENGTH - 6;
 
-	if ( p->done || ((p->mpeg == 2 && p->found >= 9) || 
-	     (p->mpeg == 1 && p->found >= 7)) ){
-		switch (p->cid){
-			
-		case AUDIO_STREAM_S ... AUDIO_STREAM_E:			
+	if (p->done || ((p->mpeg == 2 && p->found >= 9) ||
+			(p->mpeg == 1 && p->found >= 7))) {
+		switch (p->cid) {
+		case AUDIO_STREAM_S ... AUDIO_STREAM_E:
 		case VIDEO_STREAM_S ... VIDEO_STREAM_E:
 		case PRIVATE_STREAM1:
-			
 			if (p->mpeg == 2 && p->found == 9) {
 				write_ipack(p, &p->flag1, 1);
 				write_ipack(p, &p->flag2, 1);
 				write_ipack(p, &p->hlength, 1);
 			}
 
-			if (p->mpeg == 1 && p->found == 7) 
+			if (p->mpeg == 1 && p->found == 7)
 				write_ipack(p, &p->flag1, 1);
-			
-			if (p->mpeg == 2 && (p->flag2 & PTS_ONLY) &&  
+
+			if (p->mpeg == 2 && (p->flag2 & PTS_ONLY) &&
 			    p->found < 14) {
 				while (c < count && p->found < 14) {
-					p->pts[p->found-9] = buf[c];
-					write_ipack(p, buf+c, 1);
+					p->pts[p->found - 9] = buf[c];
+					write_ipack(p, buf + c, 1);
 					c++;
 					p->found++;
 				}
@@ -292,30 +290,30 @@ int av7110_ipack_instant_repack (const u
 					p->hlength = 1;
 				}
 
-				while (!p->which && c < count && 
+				while (!p->which && c < count &&
 				       p->check == 0xff){
 					p->check = buf[c];
-					write_ipack(p, buf+c, 1);
+					write_ipack(p, buf + c, 1);
 					c++;
 					p->found++;
 					p->hlength++;
 				}
-				
+
 				if (c == count)
 					return count;
-				
+
 				if ((p->check & 0xc0) == 0x40 && !p->which) {
 					p->check = buf[c];
-					write_ipack(p, buf+c, 1);
+					write_ipack(p, buf + c, 1);
 					c++;
 					p->found++;
 					p->hlength++;
-					
+
 					p->which = 1;
 					if (c == count)
 						return count;
 					p->check = buf[c];
-					write_ipack(p, buf+c, 1);
+					write_ipack(p, buf + c, 1);
 					c++;
 					p->found++;
 					p->hlength++;
@@ -323,10 +321,10 @@ int av7110_ipack_instant_repack (const u
 					if (c == count)
 						return count;
 				}
-				
-				if (p->which == 1){
+
+				if (p->which == 1) {
 					p->check = buf[c];
-					write_ipack(p, buf+c, 1);
+					write_ipack(p, buf + c, 1);
 					c++;
 					p->found++;
 					p->hlength++;
@@ -334,20 +332,20 @@ int av7110_ipack_instant_repack (const u
 					if (c == count)
 						return count;
 				}
-				
+
 				if ((p->check & 0x30) && p->check != 0xff) {
 					p->flag2 = (p->check & 0xf0) << 2;
 					p->pts[0] = p->check;
 					p->which = 3;
-				} 
-			
+				}
+
 				if (c == count)
 					return count;
 				if (p->which > 2){
 					if ((p->flag2 & PTS_DTS_FLAGS) == PTS_ONLY) {
 						while (c < count && p->which < 7) {
 							p->pts[p->which - 2] = buf[c];
-							write_ipack(p,buf+c,1);
+							write_ipack(p, buf + c, 1);
 							c++;
 							p->found++;
 							p->which++;
@@ -357,9 +355,9 @@ int av7110_ipack_instant_repack (const u
 							return count;
 					} else if ((p->flag2 & PTS_DTS_FLAGS) == PTS_DTS) {
 						while (c < count && p->which < 12) {
-							if (p->which< 7)
+							if (p->which < 7)
 								p->pts[p->which - 2] = buf[c];
-							write_ipack(p,buf+c,1);
+							write_ipack(p, buf + c, 1);
 							c++;
 							p->found++;
 							p->which++;
@@ -370,39 +368,37 @@ int av7110_ipack_instant_repack (const u
 					}
 					p->which = 2000;
 				}
-				
+
 			}
-			
-			while (c < count && p->found < p->plength+6){
-				l = count -c;
-				if (l+p->found > p->plength+6)
-					l = p->plength+6-p->found;
-				write_ipack(p, buf+c, l);
+
+			while (c < count && p->found < p->plength + 6) {
+				l = count - c;
+				if (l + p->found > p->plength + 6)
+					l = p->plength + 6 - p->found;
+				write_ipack(p, buf + c, l);
 				p->found += l;
 				c += l;
-			}	
-			
+			}
 			break;
 		}
 
 
-		if ( p->done ){
-			if( p->found + count - c < p->plength+6){
-				p->found += count-c;
+		if (p->done) {
+			if (p->found + count - c < p->plength + 6) {
+				p->found += count - c;
 				c = count;
 			} else {
-				c += p->plength+6 - p->found;
-				p->found = p->plength+6;
+				c += p->plength + 6 - p->found;
+				p->found = p->plength + 6;
 			}
 		}
 
-		if (p->plength && p->found == p->plength+6) {
+		if (p->plength && p->found == p->plength + 6) {
 			send_ipack(p);
 			av7110_ipack_reset(p);
 			if (c < count)
-				av7110_ipack_instant_repack(buf+c, count-c, p);
+				av7110_ipack_instant_repack(buf + c, count - c, p);
 		}
 	}
 	return count;
 }
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_ipack.h linux/drivers/media/dvb/ttpci/av7110_ipack.h
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_ipack.h	2004-09-14 10:34:34.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110_ipack.h	2004-09-17 14:56:38.902581760 +0200
@@ -2,7 +2,7 @@
 #define _AV7110_IPACK_H_
 
 extern int av7110_ipack_init(struct ipack *p, int size,
-			      void (*func)(u8 *buf,  int size, void *priv));
+			     void (*func)(u8 *buf,  int size, void *priv));
 
 extern void av7110_ipack_reset(struct ipack *p);
 extern int  av7110_ipack_instant_repack(const u8 *buf, int count, struct ipack *p);
@@ -10,4 +10,3 @@ extern void av7110_ipack_free(struct ipa
 extern void av7110_ipack_flush(struct ipack *p);
 
 #endif
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_ir.c linux/drivers/media/dvb/ttpci/av7110_ir.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_ir.c	2004-09-14 10:34:51.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110_ir.c	2004-09-17 14:56:38.904581386 +0200
@@ -1,23 +1,21 @@
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/input.h>
 #include <linux/proc_fs.h>
 #include <asm/bitops.h>
 
 #include "av7110.h"
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-#include "input_fake.h"
-#endif
-
-
 #define UP_TIMEOUT (HZ/4)
 
-static int av7110_ir_debug = 0;
+static int av7110_ir_debug;
 
-#define dprintk(x...)  do { if (av7110_ir_debug) printk (x); } while (0)
+module_param_named(debug_ir, av7110_ir_debug, int, 0644);
+MODULE_PARM_DESC(av7110_ir_debug, "Turn on/off IR debugging (default:off).");
 
+#define dprintk(x...)  do { if (av7110_ir_debug) printk (x); } while (0)
 
 static struct input_dev input_dev;
 
@@ -26,40 +24,40 @@ static u32 ir_config;
 static u16 key_map [256] = {
 	KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7,
 	KEY_8, KEY_9, KEY_BACK, 0, KEY_POWER, KEY_MUTE, 0, KEY_INFO,
-	KEY_VOLUMEUP, KEY_VOLUMEDOWN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	KEY_VOLUMEUP, KEY_VOLUMEDOWN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 	KEY_CHANNELUP, KEY_CHANNELDOWN, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 	0, 0, 0, 0, KEY_TEXT, 0, 0, KEY_TV, 0, 0, 0, 0, 0, KEY_SETUP, 0, 0,
 	0, 0, 0, KEY_SUBTITLE, 0, 0, KEY_LANGUAGE, 0,
-	KEY_RADIO, 0, 0, 0, 0, KEY_EXIT, 0, 0, 
+	KEY_RADIO, 0, 0, 0, 0, KEY_EXIT, 0, 0,
 	KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_OK, 0, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, KEY_RED, KEY_GREEN, KEY_YELLOW,
-	KEY_BLUE, 0, 0, 0, 0, 0, 0, 0, KEY_MENU, KEY_LIST, 0, 0, 0, 0, 0, 0, 
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	KEY_BLUE, 0, 0, 0, 0, 0, 0, 0, KEY_MENU, KEY_LIST, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 	0, 0, 0, 0, KEY_UP, KEY_UP, KEY_DOWN, KEY_DOWN,
-	0, 0, 0, 0, KEY_EPG, 0, 0, 0, 
+	0, 0, 0, 0, KEY_EPG, 0, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, KEY_VCR
 };
 
 
-static void av7110_emit_keyup (unsigned long data)
+static void av7110_emit_keyup(unsigned long data)
 {
-	if (!data || !test_bit (data, input_dev.key))
+	if (!data || !test_bit(data, input_dev.key))
 		return;
 
-	input_event (&input_dev, EV_KEY, data, !!0);
+	input_event(&input_dev, EV_KEY, data, !!0);
 }
 
 
 static struct timer_list keyup_timer = { .function = av7110_emit_keyup };
 
 
-static void av7110_emit_key (u32 ircom)
+static void av7110_emit_key(u32 ircom)
 {
 	u8 data;
 	u8 addr;
@@ -79,9 +77,9 @@ static void av7110_emit_key (u32 ircom)
 	}
 
 	keycode = key_map[data];
-	
-	dprintk ("#########%08x######### addr %i data 0x%02x (keycode %i)\n",
-		 ircom, addr, data, keycode);
+
+	dprintk("#########%08x######### addr %i data 0x%02x (keycode %i)\n",
+		ircom, addr, data, keycode);
 
 	/* check device address (if selected) */
 	if (ir_config & 0x4000)
@@ -93,41 +91,41 @@ static void av7110_emit_key (u32 ircom)
 		return;
 	}
 
-	if (ir_config & 0x0001) 
+	if (ir_config & 0x0001)
 		new_toggle = 0; /* RCMM */
 	else
 		new_toggle = (ircom & 0x800); /* RC5 */
 
-	if (timer_pending (&keyup_timer)) {
-		del_timer (&keyup_timer);
+	if (timer_pending(&keyup_timer)) {
+		del_timer(&keyup_timer);
 		if (keyup_timer.data != keycode || new_toggle != old_toggle) {
-			input_event (&input_dev, EV_KEY, keyup_timer.data, !!0);
-			input_event (&input_dev, EV_KEY, keycode, !0);
+			input_event(&input_dev, EV_KEY, keyup_timer.data, !!0);
+			input_event(&input_dev, EV_KEY, keycode, !0);
 		} else
-			input_event (&input_dev, EV_KEY, keycode, 2);
+			input_event(&input_dev, EV_KEY, keycode, 2);
 
 	} else
-	input_event (&input_dev, EV_KEY, keycode, !0);
+		input_event(&input_dev, EV_KEY, keycode, !0);
 
 	keyup_timer.expires = jiffies + UP_TIMEOUT;
 	keyup_timer.data = keycode;
 
-	add_timer (&keyup_timer);
+	add_timer(&keyup_timer);
 
 	old_toggle = new_toggle;
 }
 
-static void input_register_keys (void)
+static void input_register_keys(void)
 {
 	int i;
 
-	memset (input_dev.keybit, 0, sizeof(input_dev.keybit));
+	memset(input_dev.keybit, 0, sizeof(input_dev.keybit));
 
-	for (i=0; i<sizeof(key_map)/sizeof(key_map[0]); i++) {
+	for (i = 0; i < sizeof(key_map) / sizeof(key_map[0]); i++) {
 		if (key_map[i] > KEY_MAX)
 			key_map[i] = 0;
 		else if (key_map[i] > KEY_RESERVED)
-			set_bit (key_map[i], input_dev.keybit);
+			set_bit(key_map[i], input_dev.keybit);
 	}
 }
 
@@ -138,62 +136,57 @@ static void input_repeat_key(unsigned lo
 }
 
 
-static int av7110_ir_write_proc (struct file *file, const char __user *buffer,
-	                  unsigned long count, void *data)
+static int av7110_ir_write_proc(struct file *file, const char __user *buffer,
+				unsigned long count, void *data)
 {
 	char *page;
 	int size = 4 + 256 * sizeof(u16);
 
 	if (count < size)
 		return -EINVAL;
-	
-	page = (char *)vmalloc(size);
+
+	page = (char *) vmalloc(size);
 	if (!page)
 		return -ENOMEM;
-	
+
 	if (copy_from_user(page, buffer, size)) {
 		vfree(page);
 		return -EFAULT;
 	}
 
-	memcpy (&ir_config, page, 4);
-	memcpy (&key_map, page + 4, 256 * sizeof(u16));
-
+	memcpy(&ir_config, page, 4);
+	memcpy(&key_map, page + 4, 256 * sizeof(u16));
 	vfree(page);
-
-	av7110_setup_irc_config (NULL, ir_config);
-
-	input_register_keys ();
-
+	av7110_setup_irc_config(NULL, ir_config);
+	input_register_keys();
 	return count;
 }
 
 
-int __init av7110_ir_init (void)
+int __init av7110_ir_init(void)
 {
 	static struct proc_dir_entry *e;
 
-	init_timer (&keyup_timer);
+	init_timer(&keyup_timer);
 	keyup_timer.data = 0;
 
-        input_dev.name = "DVB on-card IR receiver";
+	input_dev.name = "DVB on-card IR receiver";
 
-        /**
-         *  enable keys
-         */
-        set_bit (EV_KEY, input_dev.evbit);
-        set_bit (EV_REP, input_dev.evbit);
+	/**
+	 *  enable keys
+	 */
+	set_bit(EV_KEY, input_dev.evbit);
+	set_bit(EV_REP, input_dev.evbit);
 
-	input_register_keys ();
+	input_register_keys();
 
 	input_register_device(&input_dev);
 	input_dev.timer.function = input_repeat_key;
 
-	av7110_setup_irc_config (NULL, 0x0001);
-	av7110_register_irc_handler (av7110_emit_key);
-
-	e = create_proc_entry ("av7110_ir", S_IFREG | S_IRUGO | S_IWUSR, NULL);
+	av7110_setup_irc_config(NULL, 0x0001);
+	av7110_register_irc_handler(av7110_emit_key);
 
+	e = create_proc_entry("av7110_ir", S_IFREG | S_IRUGO | S_IWUSR, NULL);
 	if (e) {
 		e->write_proc = av7110_ir_write_proc;
 		e->size = 4 + 256 * sizeof(u16);
@@ -203,16 +196,14 @@ int __init av7110_ir_init (void)
 }
 
 
-void __exit av7110_ir_exit (void)
+void __exit av7110_ir_exit(void)
 {
-	remove_proc_entry ("av7110_ir", NULL);
-	av7110_unregister_irc_handler (av7110_emit_key);
+	del_timer_sync(&keyup_timer);
+	remove_proc_entry("av7110_ir", NULL);
+	av7110_unregister_irc_handler(av7110_emit_key);
 	input_unregister_device(&input_dev);
 }
 
 //MODULE_AUTHOR("Holger Waechtler <holger@convergence.de>");
 //MODULE_LICENSE("GPL");
 
-MODULE_PARM(av7110_ir_debug,"i");
-MODULE_PARM_DESC(av7110_ir_debug, "enable AV7110 IR receiver debug messages");
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_v4l.c linux/drivers/media/dvb/ttpci/av7110_v4l.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/av7110_v4l.c	2004-09-14 10:36:09.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/av7110_v4l.c	2004-09-17 14:56:38.907580824 +0200
@@ -35,23 +35,16 @@
 #include <linux/byteorder/swabb.h>
 #include <linux/smp_lock.h>
 
-#define DEBUG_VARIABLE av7110_debug
-extern int av7110_debug;
-
-#include "dvb_i2c.h"
 #include "av7110.h"
 #include "av7110_hw.h"
 #include "av7110_av.h"
-#include "dvb_functions.h"
-
 
 int msp_writereg(struct av7110 *av7110, u8 dev, u16 reg, u16 val)
 {
 	u8 msg[5] = { dev, reg >> 8, reg & 0xff, val >> 8 , val & 0xff };
-	struct dvb_i2c_bus *i2c = av7110->i2c_bus;
 	struct i2c_msg msgs = { .flags = 0, .addr = 0x40, .len = 5, .buf = msg };
 
-	if (i2c->xfer(i2c, &msgs, 1) != 1) {
+	if (i2c_transfer(&av7110->i2c_adap, &msgs, 1) != 1) {
 		printk("av7110(%d): %s(%u = %u) failed\n",
 		       av7110->dvb_adapter->num, __FUNCTION__, reg, val);
 		return -EIO;
@@ -63,13 +56,12 @@ int msp_readreg(struct av7110 *av7110, u
 {
 	u8 msg1[3] = { dev, reg >> 8, reg & 0xff };
 	u8 msg2[2];
-	struct dvb_i2c_bus *i2c = av7110->i2c_bus;
 	struct i2c_msg msgs[2] = {
 		{ .flags = 0,	     .addr = 0x40, .len = 3, .buf = msg1 },
 		{ .flags = I2C_M_RD, .addr = 0x40, .len = 2, .buf = msg2 }
 	};
 
-	if (i2c->xfer(i2c, msgs, 2) != 2) {
+	if (i2c_transfer(&av7110->i2c_adap, &msgs[0], 2) != 2) {
 		printk("av7110(%d): %s(%u) failed\n",
 		       av7110->dvb_adapter->num, __FUNCTION__, reg);
 		return -EIO;
@@ -78,8 +70,6 @@ int msp_readreg(struct av7110 *av7110, u
 	return 0;
 }
 
-
-
 static struct v4l2_input inputs[2] = {
 	{
 		.index		= 0,
@@ -189,7 +179,7 @@ int av7110_dvb_c_switch(struct saa7146_f
 			vv->ov_suspend = NULL;
 		}
 	}
-
+	
 	if (0 != av7110->current_input) {
 		adswitch = 1;
 		band = 0x60; /* analog band */
@@ -264,8 +254,8 @@ int av7110_ioctl(struct saa7146_fh *fh, 
 		t->signal = 0xffff;
 		t->afc = 0;
 
-		// FIXME: standard / stereo detection is still broken
-		msp_readreg(av7110, MSP_RD_DEM, 0x007e, &stereo_det);
+// FIXME: standard / stereo detection is still broken
+msp_readreg(av7110, MSP_RD_DEM, 0x007e, &stereo_det);
 printk("VIDIOC_G_TUNER: msp3400 TV standard detection: 0x%04x\n", stereo_det);
 
 		msp_readreg(av7110, MSP_RD_DSP, 0x0018, &stereo_det);
@@ -517,7 +507,7 @@ int av7110_init_analog_module(struct av7
 	printk("av7110(%d): DVB-C analog module detected, initializing MSP3400\n",
 		av7110->dvb_adapter->num);
 	av7110->adac_type = DVB_ADAC_MSP;
-	dvb_delay(100); // the probing above resets the msp...
+	msleep(100); // the probing above resets the msp...
 	msp_readreg(av7110, MSP_RD_DSP, 0x001e, &version1);
 	msp_readreg(av7110, MSP_RD_DSP, 0x001f, &version2);
 	printk("av7110(%d): MSP3400 version 0x%04x 0x%04x\n",
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget-av.c linux/drivers/media/dvb/ttpci/budget-av.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget-av.c	2004-09-14 10:37:14.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/budget-av.c	2004-09-17 14:56:38.911580074 +0200
@@ -30,14 +30,12 @@
  * the project's page is at http://www.linuxtv.org/dvb/
  */
 
-#include <media/saa7146_vv.h>
-
 #include "budget.h"
-#include "dvb_functions.h"
+#include <media/saa7146_vv.h>
 
 struct budget_av {
 	struct budget budget;
-	struct video_device vd;
+	struct video_device *vd;
 	int cur_input;
 	int has_saa7113;
 };
@@ -47,7 +45,7 @@ struct budget_av {
  ****************************************************************************/
 
 
-static u8 i2c_readreg (struct dvb_i2c_bus *i2c, u8 id, u8 reg)
+static u8 i2c_readreg (struct i2c_adapter *i2c, u8 id, u8 reg)
 {
 	u8 mm1[] = {0x00};
 	u8 mm2[] = {0x00};
@@ -60,12 +58,12 @@ static u8 i2c_readreg (struct dvb_i2c_bu
 	msgs[0].len = 1; msgs[1].len = 1;
 	msgs[0].buf = mm1; msgs[1].buf = mm2;
 
-	i2c->xfer(i2c, msgs, 2);
+	i2c_transfer(i2c, msgs, 2);
 
 	return mm2[0];
 }
 
-static int i2c_readregs(struct dvb_i2c_bus *i2c, u8 id, u8 reg, u8 *buf, u8 len)
+static int i2c_readregs(struct i2c_adapter *i2c, u8 id, u8 reg, u8 *buf, u8 len)
 {
         u8 mm1[] = { reg };
         struct i2c_msg msgs[2] = {
@@ -73,13 +71,14 @@ static int i2c_readregs(struct dvb_i2c_b
 		{ .addr = id/2, .flags = I2C_M_RD, .buf = buf, .len = len }
 	};
 
-        if (i2c->xfer(i2c, msgs, 2) != 2)
+        if (i2c_transfer(i2c, msgs, 2) != 2)
 		return -EIO;
+
 	return 0;
 }
 
 
-static int i2c_writereg (struct dvb_i2c_bus *i2c, u8 id, u8 reg, u8 val)
+static int i2c_writereg (struct i2c_adapter *i2c, u8 id, u8 reg, u8 val)
 {
         u8 msg[2]={ reg, val }; 
         struct i2c_msg msgs;
@@ -88,7 +87,7 @@ static int i2c_writereg (struct dvb_i2c_
         msgs.addr=id/2;
         msgs.len=2;
         msgs.buf=msg;
-        return i2c->xfer (i2c, &msgs, 1);
+        return i2c_transfer(i2c, &msgs, 1);
 }
 
 
@@ -127,7 +126,7 @@ static int saa7113_init (struct budget_a
 	struct budget *budget = &budget_av->budget;
 	const u8 *data = saa7113_tab;
 
-        if (i2c_writereg (budget->i2c_bus, 0x4a, 0x01, 0x08) != 1) {
+        if (i2c_writereg (&budget->i2c_adap, 0x4a, 0x01, 0x08) != 1) {
                 DEB_D(("saa7113: not found on KNC card\n"));
                 return -ENODEV;
         }
@@ -135,12 +134,12 @@ static int saa7113_init (struct budget_a
         INFO(("saa7113: detected and initializing\n"));
 
 	while (*data != 0xff) {
-                i2c_writereg(budget->i2c_bus, 0x4a, *data, *(data+1));
+                i2c_writereg(&budget->i2c_adap, 0x4a, *data, *(data+1));
                 data += 2;
         }
 
 	DEB_D(("saa7113: status=%02x\n",
-	      i2c_readreg(budget->i2c_bus, 0x4a, 0x1f)));
+	      i2c_readreg(&budget->i2c_adap, 0x4a, 0x1f)));
 
 	return 0;
 }
@@ -154,11 +153,11 @@ static int saa7113_setinput (struct budg
 		return -ENODEV;
 
 	if (input == 1) {
-		i2c_writereg(budget->i2c_bus, 0x4a, 0x02, 0xc7);
-		i2c_writereg(budget->i2c_bus, 0x4a, 0x09, 0x80);
+		i2c_writereg(&budget->i2c_adap, 0x4a, 0x02, 0xc7);
+		i2c_writereg(&budget->i2c_adap, 0x4a, 0x09, 0x80);
 	} else if (input == 0) {
-		i2c_writereg(budget->i2c_bus, 0x4a, 0x02, 0xc0);
-		i2c_writereg(budget->i2c_bus, 0x4a, 0x09, 0x00);
+		i2c_writereg(&budget->i2c_adap, 0x4a, 0x02, 0xc0);
+		i2c_writereg(&budget->i2c_adap, 0x4a, 0x09, 0x00);
 	} else
 		return -EINVAL;
 
@@ -175,11 +174,11 @@ static int budget_av_detach (struct saa7
 	DEB_EE(("dev: %p\n",dev));
 
 	if ( 1 == budget_av->has_saa7113 ) {
-	saa7146_setgpio(dev, 0, SAA7146_GPIO_OUTLO);
+		saa7146_setgpio(dev, 0, SAA7146_GPIO_OUTLO);
 
-	dvb_delay(200);
+		msleep(200);
 
-	saa7146_unregister_device (&budget_av->vd, dev);
+		saa7146_unregister_device (&budget_av->vd, dev);
 	}
 
 	err = ttpci_budget_deinit (&budget_av->budget);
@@ -201,7 +200,7 @@ static int budget_av_attach (struct saa7
 
 	DEB_EE(("dev: %p\n",dev));
 
-	if (bi->type != BUDGET_KNC1) {
+	if (bi->type != BUDGET_KNC1 && bi->type != BUDGET_CIN1200) {
 		return -ENODEV;
 	}
 
@@ -210,13 +209,13 @@ static int budget_av_attach (struct saa7
 
 	memset(budget_av, 0, sizeof(struct budget_av));
 
+	dev->ext_priv = budget_av;
+
 	if ((err = ttpci_budget_init(&budget_av->budget, dev, info))) {
 		kfree(budget_av);
 		return err;
 	}
 
-	dev->ext_priv = budget_av;
-
 	/* knc1 initialization */
 	saa7146_write(dev, DD1_STREAM_B, 0x04000000);
 	saa7146_write(dev, DD1_INIT, 0x07000600);
@@ -225,41 +224,41 @@ static int budget_av_attach (struct saa7
 	//test_knc_ci(av7110);
 
 	saa7146_setgpio(dev, 0, SAA7146_GPIO_OUTHI);
-	dvb_delay(500);
+	msleep(500);
 
 	if ( 0 == saa7113_init(budget_av) ) {
 		budget_av->has_saa7113 = 1;
-
-	if ( 0 != saa7146_vv_init(dev,&vv_data)) {
-		/* fixme: proper cleanup here */
-		ERR(("cannot init vv subsystem.\n"));
-		return err;
-	}
-
-	if ((err = saa7146_register_device(&budget_av->vd, dev, "knc1",
-					   VFL_TYPE_GRABBER)))
-	{
-		/* fixme: proper cleanup here */
-		ERR(("cannot register capture v4l2 device.\n"));
-		return err;
-	}
-
-	/* beware: this modifies dev->vv ... */
-	saa7146_set_hps_source_and_sync(dev, SAA7146_HPS_SOURCE_PORT_A,
-					SAA7146_HPS_SYNC_PORT_A);
-
-	saa7113_setinput (budget_av, 0);
+		
+		if ( 0 != saa7146_vv_init(dev,&vv_data)) {
+			/* fixme: proper cleanup here */
+			ERR(("cannot init vv subsystem.\n"));
+			return err;
+		}
+		
+		if ((err = saa7146_register_device(&budget_av->vd, dev, "knc1",
+						   VFL_TYPE_GRABBER)))
+		{
+			/* fixme: proper cleanup here */
+			ERR(("cannot register capture v4l2 device.\n"));
+			return err;
+		}
+		
+		/* beware: this modifies dev->vv ... */
+		saa7146_set_hps_source_and_sync(dev, SAA7146_HPS_SOURCE_PORT_A,
+						SAA7146_HPS_SYNC_PORT_A);
+		
+		saa7113_setinput (budget_av, 0);
 	} else {
 		budget_av->has_saa7113 = 0;
-
-	saa7146_setgpio(dev, 0, SAA7146_GPIO_OUTLO);
+		
+		saa7146_setgpio(dev, 0, SAA7146_GPIO_OUTLO);
 	}
 
 	/* fixme: find some sane values here... */
 	saa7146_write(dev, PCI_BT_V1, 0x1c00101f);
 
 	mac = budget_av->budget.dvb_adapter->proposed_mac;
-	if (i2c_readregs(budget_av->budget.i2c_bus, 0xa0, 0x30, mac, 6)) {
+	if (i2c_readregs(&budget_av->budget.i2c_adap, 0xa0, 0x30, mac, 6)) {
 		printk("KNC1-%d: Could not read MAC from KNC1 card\n",
 				budget_av->budget.dvb_adapter->num);
 		memset(mac, 0, 6);
@@ -343,7 +342,7 @@ static struct saa7146_standard standard[
 		.h_offset	= 0x06,	.h_pixels 	= 708,
 		.v_max_out	= 480,	.h_max_out	= 640,
 	}
-};
+};		
 
 static struct saa7146_ext_vv vv_data = {
 	.inputs		= 2,
@@ -361,9 +360,11 @@ static struct saa7146_extension budget_e
 
 
 MAKE_BUDGET_INFO(knc1, "KNC1 DVB-S", BUDGET_KNC1);
+MAKE_BUDGET_INFO(cin1200, "TerraTec Cinergy 1200 DVB-S", BUDGET_CIN1200);
 
 static struct pci_device_id pci_tbl [] = {
 	MAKE_EXTENSION_PCI(knc1, 0x1131, 0x4f56),
+	MAKE_EXTENSION_PCI(cin1200, 0x153b, 0x1154),
 	{
 		.vendor    = 0,
 	}
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget-ci.c linux/drivers/media/dvb/ttpci/budget-ci.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget-ci.c	2004-09-14 10:34:45.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/budget-ci.c	2004-09-17 14:56:38.915579325 +0200
@@ -1,7 +1,7 @@
 /*
- * budget-ci.c: driver for the SAA7146 based Budget DVB cards 
+ * budget-ci.c: driver for the SAA7146 based Budget DVB cards
  *
- * Compiled from various sources by Michael Hunold <michael@mihu.de> 
+ * Compiled from various sources by Michael Hunold <michael@mihu.de>
  *
  *     msp430 IR support contributed by Jack Thomasson <jkt@Helius.COM>
  *     partially based on the Siemens DVB driver by Ralph+Marcus Metzler
@@ -12,19 +12,19 @@
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
  * GNU General Public License for more details.
- * 
+ *
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
- * 
+ *
  *
  * the project's page is at http://www.linuxtv.org/dvb/
  */
@@ -38,13 +38,8 @@
 #include <linux/input.h>
 #include <linux/spinlock.h>
 
-#include "dvb_functions.h"
 #include "dvb_ca_en50221.h"
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-#include "input_fake.h"
-#endif
-
 #define DEBIADDR_IR		0x1234
 #define DEBIADDR_CICONTROL	0x0000
 #define DEBIADDR_CIVERSION	0x4000
@@ -79,14 +74,15 @@ static u32 budget_debiread (struct budge
 {
 	struct saa7146_dev *saa = budget_ci->budget.dev;
 	u32 result = 0;
+        unsigned long flags;
 
 	if (count > 4 || count <= 0)
 		return 0;
 
-	spin_lock(&budget_ci->debilock);
-
+	spin_lock_irqsave(&budget_ci->debilock, flags);
+   
 	if (saa7146_wait_for_debi_done(saa) < 0) {
-		spin_unlock(&budget_ci->debilock);
+		spin_unlock_irqrestore(&budget_ci->debilock, flags);
 		return 0;
 	}
 
@@ -101,21 +97,22 @@ static u32 budget_debiread (struct budge
 	result = saa7146_read(saa, 0x88);
 	result &= (0xffffffffUL >> ((4 - count) * 8));
 
-	spin_unlock(&budget_ci->debilock);
+	spin_unlock_irqrestore(&budget_ci->debilock, flags);
 	return result;
 }
 
 static u8 budget_debiwrite (struct budget_ci* budget_ci, u32 config, int addr, int count, u32 value)
 {
 	struct saa7146_dev *saa = budget_ci->budget.dev;
+        unsigned long flags;
 
 	if (count > 4 || count <= 0)
 		return 0;
 
-	spin_lock(&budget_ci->debilock);
-
+	spin_lock_irqsave(&budget_ci->debilock, flags);
+   
 	if (saa7146_wait_for_debi_done(saa) < 0) {
-		spin_unlock(&budget_ci->debilock);
+		spin_unlock_irqrestore(&budget_ci->debilock, flags);
 		return 0;
 	}
 
@@ -128,7 +125,7 @@ static u8 budget_debiwrite (struct budge
 
 	saa7146_wait_for_debi_done(saa);
 
-	spin_unlock(&budget_ci->debilock);
+	spin_unlock_irqrestore(&budget_ci->debilock, flags);
 	return 0;
 }
 
@@ -138,52 +135,52 @@ static u8 budget_debiwrite (struct budge
    Hauppauge (from NOVA-CI-s box product)
    i've taken a "middle of the road" approach and note the differences
 */
-static  u16 key_map[64] = {
+static	u16 key_map[64] = {
 	/* 0x0X */
 	KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8,
 	KEY_9,
 	KEY_ENTER,
 	KEY_RED,
-	KEY_POWER,              /* RADIO on Hauppauge */
+	KEY_POWER,		/* RADIO on Hauppauge */
 	KEY_MUTE,
 	0,
-	KEY_A,                  /* TV on Hauppauge */
+	KEY_A,			/* TV on Hauppauge */
 	/* 0x1X */
 	KEY_VOLUMEUP, KEY_VOLUMEDOWN,
 	0, 0,
 	KEY_B,
 	0, 0, 0, 0, 0, 0, 0,
 	KEY_UP, KEY_DOWN,
-	KEY_OPTION,             /* RESERVED on Hauppauge */
+	KEY_OPTION,		/* RESERVED on Hauppauge */
 	KEY_BREAK,
 	/* 0x2X */
 	KEY_CHANNELUP, KEY_CHANNELDOWN,
-	KEY_PREVIOUS,           /* Prev. Ch on Zenith, SOURCE on Hauppauge */
+	KEY_PREVIOUS,		/* Prev. Ch on Zenith, SOURCE on Hauppauge */
 	0, KEY_RESTART, KEY_OK,
-	KEY_CYCLEWINDOWS,       /* MINIMIZE on Hauppauge */
+	KEY_CYCLEWINDOWS,	/* MINIMIZE on Hauppauge */
 	0,
-	KEY_ENTER,              /* VCR mode on Zenith */
+	KEY_ENTER,		/* VCR mode on Zenith */
 	KEY_PAUSE,
 	0,
 	KEY_RIGHT, KEY_LEFT,
 	0,
-	KEY_MENU,               /* FULL SCREEN on Hauppauge */
+	KEY_MENU,		/* FULL SCREEN on Hauppauge */
 	0,
 	/* 0x3X */
 	KEY_SLOW,
-	KEY_PREVIOUS,           /* VCR mode on Zenith */
+	KEY_PREVIOUS,		/* VCR mode on Zenith */
 	KEY_REWIND,
 	0,
 	KEY_FASTFORWARD,
 	KEY_PLAY, KEY_STOP,
 	KEY_RECORD,
-	KEY_TUNER,              /* TV/VCR on Zenith */
+	KEY_TUNER,		/* TV/VCR on Zenith */
 	0,
 	KEY_C,
 	0,
 	KEY_EXIT,
 	KEY_POWER2,
-	KEY_TUNER,              /* VCR mode on Zenith */
+	KEY_TUNER,		/* VCR mode on Zenith */
 	0,
 };
 
@@ -200,7 +197,7 @@ static void msp430_ir_debounce (unsigned
 	dev->rep[0] = 0;
 	dev->timer.expires = jiffies + HZ * 350 / 1000;
 	add_timer(&dev->timer);
-	input_event(dev, EV_KEY, key_map[dev->repeat_key], 2);  /* REPEAT */
+	input_event(dev, EV_KEY, key_map[dev->repeat_key], 2);	/* REPEAT */
 }
 
 
@@ -212,22 +209,22 @@ static void msp430_ir_interrupt (unsigne
 	unsigned int code = budget_debiread(budget_ci, DEBINOSWAP, DEBIADDR_IR, 2) >> 8;
 
 	if (code & 0x40) {
-	        code &= 0x3f;
+		code &= 0x3f;
 
-        	if (timer_pending(&dev->timer)) {
-                	if (code == dev->repeat_key) {
-                        	++dev->rep[0];
-	                        return;
-        	        }
-                	del_timer(&dev->timer);
-		        input_event(dev, EV_KEY, key_map[dev->repeat_key], !!0);
+		if (timer_pending(&dev->timer)) {
+			if (code == dev->repeat_key) {
+				++dev->rep[0];
+				return;
+			}
+			del_timer(&dev->timer);
+			input_event(dev, EV_KEY, key_map[dev->repeat_key], !!0);
 		}
 
 		if (!key_map[code]) {
-        	        printk ("DVB (%s): no key for %02x!\n",
+			printk ("DVB (%s): no key for %02x!\n",
 				__FUNCTION__, code);
-		        return;
-       		}
+			return;
+		}
 
 		/* initialize debounce and repeat */
 		dev->repeat_key = code;
@@ -236,7 +233,7 @@ static void msp430_ir_interrupt (unsigne
 		/* 350 milliseconds */
 		dev->timer.expires = jiffies + HZ * 350 / 1000;
 		/* MAKE */
-        	input_event(dev, EV_KEY, key_map[code], !0);
+		input_event(dev, EV_KEY, key_map[code], !0);
 		add_timer(&dev->timer);
 	}
 }
@@ -264,7 +261,7 @@ static int msp430_ir_init (struct budget
 
 	saa7146_write(saa, IER, saa7146_read(saa, IER) | MASK_06);
 
-	saa7146_setgpio(saa, 3, SAA7146_GPIO_IRQHI); 
+	saa7146_setgpio(saa, 3, SAA7146_GPIO_IRQHI);
 
 	return 0;
 }
@@ -326,7 +323,7 @@ static int ciintf_slot_reset(struct dvb_
 	saa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);
 	budget_ci->slot_status = SLOTSTATUS_RESET;
 	budget_debiwrite(budget_ci, DEBICICTL, DEBIADDR_CICONTROL, 1, 0);
-	dvb_delay(1);
+	msleep(1);
 	budget_debiwrite(budget_ci, DEBICICTL, DEBIADDR_CICONTROL, 1, CICONTROL_RESET);
 
 	saa7146_setgpio(saa, 1, SAA7146_GPIO_OUTHI);
@@ -372,14 +369,13 @@ static void ciintf_interrupt (unsigned l
 	// ensure we don't get spurious IRQs during initialisation
 	if (!budget_ci->budget.ci_present) return;
 
+	// read the CAM status
 	flags = budget_debiread(budget_ci, DEBICICTL, DEBIADDR_CICONTROL, 1);
-
-	// always set the GPIO mode back to "normal", in case the card is
-	// yanked at an inopportune moment
-	saa7146_setgpio(saa, 0, SAA7146_GPIO_IRQLO);
-
 	if (flags & CICONTROL_CAMDETECT) {
 
+		// GPIO should be set to trigger on falling edge if a CAM is present
+		saa7146_setgpio(saa, 0, SAA7146_GPIO_IRQLO);
+
 		if (budget_ci->slot_status & SLOTSTATUS_NONE) {
 			// CAM insertion IRQ
 			budget_ci->slot_status = SLOTSTATUS_PRESENT;
@@ -395,7 +391,15 @@ static void ciintf_interrupt (unsigned l
 			dvb_ca_en50221_frda_irq(&budget_ci->ca, 0);
 		}
 	} else {
+
+		// trigger on rising edge if a CAM is not present - when a CAM is inserted, we
+		// only want to get the IRQ when it sets READY. If we trigger on the falling edge,
+		// the CAM might not actually be ready yet.
+		saa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);
+
+	   	// generate a CAM removal IRQ if we haven't already
 		if (budget_ci->slot_status & SLOTSTATUS_OCCUPIED) {
+			// CAM removal IRQ
 			budget_ci->slot_status = SLOTSTATUS_NONE;
 			dvb_ca_en50221_camchange_irq(&budget_ci->ca, 0, DVB_CA_EN50221_CAMCHANGE_REMOVED);
 		}
@@ -446,7 +450,11 @@ static int ciintf_init(struct budget_ci*
 
 	// Setup CI slot IRQ
 	tasklet_init (&budget_ci->ciintf_irq_tasklet, ciintf_interrupt, (unsigned long) budget_ci);
-	saa7146_setgpio(saa, 0, SAA7146_GPIO_IRQLO);
+	if (budget_ci->slot_status != SLOTSTATUS_NONE) {
+		saa7146_setgpio(saa, 0, SAA7146_GPIO_IRQLO);
+	} else {
+		saa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);
+	}
 	saa7146_write(saa, IER, saa7146_read(saa, IER) | MASK_03);
 	budget_debiwrite(budget_ci, DEBICICTL, DEBIADDR_CICONTROL, 1, CICONTROL_RESET);
 
@@ -475,7 +483,7 @@ static void ciintf_deinit(struct budget_
 	saa7146_setgpio(saa, 0, SAA7146_GPIO_INPUT);
 	tasklet_kill(&budget_ci->ciintf_irq_tasklet);
 	budget_debiwrite(budget_ci, DEBICICTL, DEBIADDR_CICONTROL, 1, 0);
-	dvb_delay(1);
+	msleep(1);
 	budget_debiwrite(budget_ci, DEBICICTL, DEBIADDR_CICONTROL, 1, CICONTROL_RESET);
 
 	// disable TS data stream to CI interface
@@ -490,14 +498,14 @@ static void ciintf_deinit(struct budget_
 
 static void budget_ci_irq (struct saa7146_dev *dev, u32 *isr)
 {
-        struct budget_ci *budget_ci = (struct budget_ci*) dev->ext_priv;
+	struct budget_ci *budget_ci = (struct budget_ci*) dev->ext_priv;
 
-        DEB_EE(("dev: %p, budget_ci: %p\n", dev, budget_ci));
+	DEB_EE(("dev: %p, budget_ci: %p\n", dev, budget_ci));
 
-        if (*isr & MASK_06)
-                tasklet_schedule (&budget_ci->msp430_irq_tasklet);
+	if (*isr & MASK_06)
+		tasklet_schedule (&budget_ci->msp430_irq_tasklet);
 
-        if (*isr & MASK_10)
+	if (*isr & MASK_10)
 		ttpci_budget_irq10_handler (dev, isr);
 
 	if ((*isr & MASK_03) && (budget_ci->budget.ci_present))
@@ -520,20 +528,19 @@ static int budget_ci_attach (struct saa7
 	spin_lock_init(&budget_ci->debilock);
 	budget_ci->budget.ci_present = 0;
 
+	dev->ext_priv = budget_ci;
+
 	if ((err = ttpci_budget_init (&budget_ci->budget, dev, info))) {
 		kfree (budget_ci);
 		return err;
 	}
 
-	dev->ext_priv = budget_ci;
-
 	tasklet_init (&budget_ci->msp430_irq_tasklet, msp430_ir_interrupt,
 		      (unsigned long) budget_ci);
 
 	msp430_ir_init (budget_ci);
 
-	// UNCOMMENT TO TEST CI INTERFACE
-//	ciintf_init(budget_ci);
+	ciintf_init(budget_ci);
 
 	return 0;
 }
@@ -564,17 +571,17 @@ static int budget_ci_detach (struct saa7
 
 
 
-static struct saa7146_extension budget_extension; 
+static struct saa7146_extension budget_extension;
 
 MAKE_BUDGET_INFO(ttbci,	"TT-Budget/WinTV-NOVA-CI PCI",	BUDGET_TT_HW_DISEQC);
-MAKE_BUDGET_INFO(ttbt2,	"TT-Budget/WinTV-NOVA-T  PCI",	BUDGET_TT);
+MAKE_BUDGET_INFO(ttbt2,	"TT-Budget/WinTV-NOVA-T	 PCI",	BUDGET_TT);
 
 static struct pci_device_id pci_tbl[] = {
 	MAKE_EXTENSION_PCI(ttbci, 0x13c2, 0x100c),
 	MAKE_EXTENSION_PCI(ttbci, 0x13c2, 0x100f),
-	MAKE_EXTENSION_PCI(ttbt2,  0x13c2, 0x1011),
+	MAKE_EXTENSION_PCI(ttbt2, 0x13c2, 0x1011),
 	{
-		.vendor    = 0,
+		.vendor	   = 0,
 	}
 };
 
@@ -582,7 +589,7 @@ MODULE_DEVICE_TABLE(pci, pci_tbl);
 
 static struct saa7146_extension budget_extension = {
 	.name		= "budget_ci dvb\0",
-	.flags	 	= 0,
+	.flags		= 0,
 
 	.module		= THIS_MODULE,
 	.pci_tbl	= &pci_tbl[0],
@@ -591,10 +598,10 @@ static struct saa7146_extension budget_e
 
 	.irq_mask	= MASK_03 | MASK_06 | MASK_10,
 	.irq_func	= budget_ci_irq,
-};	
+};
 
 
-static int __init budget_ci_init(void) 
+static int __init budget_ci_init(void)
 {
 	return saa7146_register_extension(&budget_extension);
 }
@@ -603,7 +610,7 @@ static int __init budget_ci_init(void) 
 static void __exit budget_ci_exit(void)
 {
 	DEB_EE((".\n"));
-	saa7146_unregister_extension(&budget_extension); 
+	saa7146_unregister_extension(&budget_extension);
 }
 
 module_init(budget_ci_init);
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget-core.c linux/drivers/media/dvb/ttpci/budget-core.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget-core.c	2004-09-14 10:35:08.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/budget-core.c	2004-09-17 14:56:38.918578763 +0200
@@ -34,10 +34,15 @@
  * the project's page is at http://www.linuxtv.org/dvb/
  */
 
+#include <linux/moduleparam.h>
+
 #include "budget.h"
 #include "ttpci-eeprom.h"
 
-int budget_debug = 0;
+static int budget_debug;
+
+module_param_named(debug, budget_debug, int, 0644);
+MODULE_PARM_DESC(budget_debug, "Turn on/off budget debugging (default:off).");
 
 /****************************************************************************
  * TT budget / WinTV Nova
@@ -47,33 +52,33 @@ static int stop_ts_capture(struct budget
 {
 	DEB_EE(("budget: %p\n",budget));
 
-        if (--budget->feeding)
-                return budget->feeding;
+	if (--budget->feeding)
+		return budget->feeding;
 
-        saa7146_write(budget->dev, MC1, MASK_20); // DMA3 off
+	saa7146_write(budget->dev, MC1, MASK_20); // DMA3 off
 	IER_DISABLE(budget->dev, MASK_10);
-        return 0;
+	return 0;
 }
 
 
 static int start_ts_capture (struct budget *budget)
 {
-        struct saa7146_dev *dev=budget->dev;
+	struct saa7146_dev *dev=budget->dev;
 
 	DEB_EE(("budget: %p\n",budget));
 
-        if (budget->feeding) 
-                return ++budget->feeding;
+	if (budget->feeding)
+		return ++budget->feeding;
 
-      	saa7146_write(dev, MC1, MASK_20); // DMA3 off
+	saa7146_write(dev, MC1, MASK_20); // DMA3 off
 
-        memset(budget->grabbing, 0x00, TS_HEIGHT*TS_WIDTH);
+	memset(budget->grabbing, 0x00, TS_HEIGHT*TS_WIDTH);
 
-        saa7146_write(dev, PCI_BT_V1, 0x001c0000 |
-            (saa7146_read(dev, PCI_BT_V1) & ~0x001f0000));
+	saa7146_write(dev, PCI_BT_V1, 0x001c0000 |
+	    (saa7146_read(dev, PCI_BT_V1) & ~0x001f0000));
 
-        budget->tsf=0xff;
-        budget->ttbp=0;
+	budget->tsf=0xff;
+	budget->ttbp=0;
 
 	/*
 	 *  Signal path on the Activy:
@@ -95,64 +100,64 @@ static int start_ts_capture (struct budg
 			saa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));
 			saa7146_write(dev, BRS_CTRL, 0x00000000);
 		} else {
-        saa7146_write(dev, DD1_INIT, 0x02000600);
-        saa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));
-        saa7146_write(dev, BRS_CTRL, 0x60000000);	
+			saa7146_write(dev, DD1_INIT, 0x02000600);
+			saa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));
+			saa7146_write(dev, BRS_CTRL, 0x60000000);
 		}
 	}
 
-      	saa7146_write(dev, MC2, (MASK_08 | MASK_24));
-        mdelay(10);
+	saa7146_write(dev, MC2, (MASK_08 | MASK_24));
+	mdelay(10);
 
-        saa7146_write(dev, BASE_ODD3, 0);
-        saa7146_write(dev, BASE_EVEN3, 0);
-        saa7146_write(dev, PROT_ADDR3, TS_WIDTH*TS_HEIGHT);	
-        saa7146_write(dev, BASE_PAGE3, budget->pt.dma |ME1|0x90);
+	saa7146_write(dev, BASE_ODD3, 0);
+	saa7146_write(dev, BASE_EVEN3, 0);
+	saa7146_write(dev, PROT_ADDR3, TS_WIDTH*TS_HEIGHT);
+	saa7146_write(dev, BASE_PAGE3, budget->pt.dma |ME1|0x90);
 
 	if (budget->card->type == BUDGET_FS_ACTIVY) {
 		saa7146_write(dev, PITCH3, TS_WIDTH/2);
 		saa7146_write(dev, NUM_LINE_BYTE3, ((TS_HEIGHT*2)<<16)|(TS_WIDTH/2));
 	} else {
 		saa7146_write(dev, PITCH3, TS_WIDTH);
-        saa7146_write(dev, NUM_LINE_BYTE3, (TS_HEIGHT<<16)|TS_WIDTH);
+		saa7146_write(dev, NUM_LINE_BYTE3, (TS_HEIGHT<<16)|TS_WIDTH);
 	}
 
-      	saa7146_write(dev, MC2, (MASK_04 | MASK_20));
-     	saa7146_write(dev, MC1, (MASK_04 | MASK_20)); // DMA3 on
+	saa7146_write(dev, MC2, (MASK_04 | MASK_20));
+	saa7146_write(dev, MC1, (MASK_04 | MASK_20)); // DMA3 on
 
 	IER_ENABLE(budget->dev, MASK_10); // VPE
 
-        return ++budget->feeding;
+	return ++budget->feeding;
 }
 
 
 static void vpeirq (unsigned long data)
 {
-        struct budget *budget = (struct budget*) data;
-        u8 *mem = (u8 *)(budget->grabbing);
-        u32 olddma = budget->ttbp;
-        u32 newdma = saa7146_read(budget->dev, PCI_VDP3);
+	struct budget *budget = (struct budget*) data;
+	u8 *mem = (u8 *)(budget->grabbing);
+	u32 olddma = budget->ttbp;
+	u32 newdma = saa7146_read(budget->dev, PCI_VDP3);
 
-        /* nearest lower position divisible by 188 */
-        newdma -= newdma % 188;
+	/* nearest lower position divisible by 188 */
+	newdma -= newdma % 188;
 
-        if (newdma >= TS_BUFLEN)
-                return;
+	if (newdma >= TS_BUFLEN)
+		return;
 
 	budget->ttbp = newdma;
-	
+
 	if(budget->feeding == 0 || newdma == olddma)
 		return;
 
-        if (newdma > olddma) { /* no wraparound, dump olddma..newdma */
-                        dvb_dmx_swfilter_packets(&budget->demux, 
-        	                mem+olddma, (newdma-olddma) / 188);
-        } else { /* wraparound, dump olddma..buflen and 0..newdma */
-	                dvb_dmx_swfilter_packets(&budget->demux,
-        	                mem+olddma, (TS_BUFLEN-olddma) / 188);
-                        dvb_dmx_swfilter_packets(&budget->demux,
-                                mem, newdma / 188);
-        }
+	if (newdma > olddma) { /* no wraparound, dump olddma..newdma */
+			dvb_dmx_swfilter_packets(&budget->demux,
+				mem+olddma, (newdma-olddma) / 188);
+	} else { /* wraparound, dump olddma..buflen and 0..newdma */
+			dvb_dmx_swfilter_packets(&budget->demux,
+				mem+olddma, (TS_BUFLEN-olddma) / 188);
+			dvb_dmx_swfilter_packets(&budget->demux,
+				mem, newdma / 188);
+	}
 }
 
 
@@ -162,14 +167,14 @@ static void vpeirq (unsigned long data)
 
 static int budget_start_feed(struct dvb_demux_feed *feed)
 {
-        struct dvb_demux *demux = feed->demux;
-        struct budget *budget = (struct budget*) demux->priv;
+	struct dvb_demux *demux = feed->demux;
+	struct budget *budget = (struct budget*) demux->priv;
 	int status;
 
 	DEB_EE(("budget: %p\n",budget));
 
-        if (!demux->dmx.frontend)
-                return -EINVAL;
+	if (!demux->dmx.frontend)
+		return -EINVAL;
 
    	spin_lock(&budget->feedlock);   
 	status = start_ts_capture (budget);
@@ -179,8 +184,8 @@ static int budget_start_feed(struct dvb_
 
 static int budget_stop_feed(struct dvb_demux_feed *feed)
 {
-        struct dvb_demux *demux = feed->demux;
-        struct budget *budget = (struct budget *) demux->priv;
+	struct dvb_demux *demux = feed->demux;
+	struct budget *budget = (struct budget *) demux->priv;
 	int status;
 
 	DEB_EE(("budget: %p\n",budget));
@@ -194,49 +199,49 @@ static int budget_stop_feed(struct dvb_d
 
 static int budget_register(struct budget *budget)
 {
-        struct dvb_demux *dvbdemux=&budget->demux;
-        int ret;
+	struct dvb_demux *dvbdemux = &budget->demux;
+	int ret;
 
 	DEB_EE(("budget: %p\n",budget));
 
-        dvbdemux->priv = (void *) budget;
+	dvbdemux->priv = (void *) budget;
 
 	dvbdemux->filternum = 256;
-        dvbdemux->feednum = 256;
-        dvbdemux->start_feed = budget_start_feed;
-        dvbdemux->stop_feed = budget_stop_feed;
-        dvbdemux->write_to_decoder = NULL;
-
-        dvbdemux->dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING |
-                                      DMX_MEMORY_BASED_FILTERING);
-
-        dvb_dmx_init(&budget->demux);
-
-        budget->dmxdev.filternum = 256;
-        budget->dmxdev.demux = &dvbdemux->dmx;
-        budget->dmxdev.capabilities = 0;
-
-        dvb_dmxdev_init(&budget->dmxdev, budget->dvb_adapter);
-
-        budget->hw_frontend.source = DMX_FRONTEND_0;
-
-        ret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &budget->hw_frontend);
-
-        if (ret < 0)
-                return ret;
-        
-        budget->mem_frontend.source = DMX_MEMORY_FE;
-        ret=dvbdemux->dmx.add_frontend (&dvbdemux->dmx, 
-                                        &budget->mem_frontend);
-        if (ret<0)
-                return ret;
-        
-        ret=dvbdemux->dmx.connect_frontend (&dvbdemux->dmx, 
-                                            &budget->hw_frontend);
-        if (ret < 0)
-                return ret;
+	dvbdemux->feednum = 256;
+	dvbdemux->start_feed = budget_start_feed;
+	dvbdemux->stop_feed = budget_stop_feed;
+	dvbdemux->write_to_decoder = NULL;
+
+	dvbdemux->dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING |
+				      DMX_MEMORY_BASED_FILTERING);
+
+	dvb_dmx_init(&budget->demux);
+
+	budget->dmxdev.filternum = 256;
+	budget->dmxdev.demux = &dvbdemux->dmx;
+	budget->dmxdev.capabilities = 0;
+
+	dvb_dmxdev_init(&budget->dmxdev, budget->dvb_adapter);
+
+	budget->hw_frontend.source = DMX_FRONTEND_0;
+
+	ret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &budget->hw_frontend);
+
+	if (ret < 0)
+		return ret;
 
-        dvb_net_init(budget->dvb_adapter, &budget->dvb_net, &dvbdemux->dmx);
+	budget->mem_frontend.source = DMX_MEMORY_FE;
+	ret=dvbdemux->dmx.add_frontend (&dvbdemux->dmx,
+					&budget->mem_frontend);
+	if (ret<0)
+		return ret;
+
+	ret=dvbdemux->dmx.connect_frontend (&dvbdemux->dmx,
+					    &budget->hw_frontend);
+	if (ret < 0)
+		return ret;
+
+	dvb_net_init(budget->dvb_adapter, &budget->dvb_net, &dvbdemux->dmx);
 
 	return 0;
 }
@@ -244,27 +249,40 @@ static int budget_register(struct budget
 
 static void budget_unregister(struct budget *budget)
 {
-        struct dvb_demux *dvbdemux=&budget->demux;
+	struct dvb_demux *dvbdemux=&budget->demux;
 
 	DEB_EE(("budget: %p\n",budget));
 
 	dvb_net_release(&budget->dvb_net);
 
 	dvbdemux->dmx.close(&dvbdemux->dmx);
-        dvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &budget->hw_frontend);
-        dvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &budget->mem_frontend);
+	dvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &budget->hw_frontend);
+	dvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &budget->mem_frontend);
 
-        dvb_dmxdev_release(&budget->dmxdev);
-        dvb_dmx_release(&budget->demux);
+	dvb_dmxdev_release(&budget->dmxdev);
+	dvb_dmx_release(&budget->demux);
 }
 
-
-static int master_xfer (struct dvb_i2c_bus *i2c, const struct i2c_msg msgs[], int num)
+/* fixme: can this be unified among all saa7146 based dvb cards? */
+static int client_register(struct i2c_client *client)
 {
-	struct saa7146_dev *dev = i2c->data;
-	return saa7146_i2c_transfer(dev, msgs, num, 6);
+	struct saa7146_dev *dev = (struct saa7146_dev*)i2c_get_adapdata(client->adapter);
+	struct budget *budget = (struct budget*)dev->ext_priv;
+
+	if (client->driver->command)
+		return client->driver->command(client, FE_REGISTER, budget->dvb_adapter);
+	return 0;
 }
 
+static int client_unregister(struct i2c_client *client)
+{
+	struct saa7146_dev *dev = (struct saa7146_dev*)i2c_get_adapdata(client->adapter);
+	struct budget *budget = (struct budget*)dev->ext_priv;
+
+	if (client->driver->command)
+		return client->driver->command(client, FE_UNREGISTER, budget->dvb_adapter);
+	return 0;
+}
 
 int ttpci_budget_init (struct budget *budget,
 		       struct saa7146_dev* dev,
@@ -284,7 +302,7 @@ int ttpci_budget_init (struct budget *bu
 	dvb_register_adapter(&budget->dvb_adapter, budget->card->name, THIS_MODULE);
 
 	/* set dd1 stream a & b */
-      	saa7146_write(dev, DD1_STREAM_B, 0x00000000);
+	saa7146_write(dev, DD1_STREAM_B, 0x00000000);
 	saa7146_write(dev, MC2, (MASK_09 | MASK_25));
 	saa7146_write(dev, MC2, (MASK_10 | MASK_26));
 	saa7146_write(dev, DD1_INIT, 0x02000000);
@@ -297,21 +315,31 @@ int ttpci_budget_init (struct budget *bu
 	spin_lock_init(&budget->feedlock);
 
 	/* the Siemens DVB needs this if you want to have the i2c chips
-           get recognized before the main driver is loaded */
+	   get recognized before the main driver is loaded */
 	if (bi->type != BUDGET_FS_ACTIVY)
 		saa7146_write(dev, GPIO_CTRL, 0x500000); /* GPIO 3 = 1 */
+
+	budget->i2c_adap = (struct i2c_adapter) {
+		.client_register = client_register,
+		.client_unregister = client_unregister,
+#ifdef I2C_ADAP_CLASS_TV_DIGITAL
+		.class = I2C_ADAP_CLASS_TV_DIGITAL,
+#else
+		.class = I2C_CLASS_TV_DIGITAL,
+#endif
+	};
 	
-	saa7146_i2c_adapter_prepare(dev, NULL, 0, SAA7146_I2C_BUS_BIT_RATE_120);
+	strlcpy(budget->i2c_adap.name, budget->card->name, sizeof(budget->i2c_adap.name));
 
-	budget->i2c_bus = dvb_register_i2c_bus (master_xfer, dev,
-						budget->dvb_adapter, 0);
+	saa7146_i2c_adapter_prepare(dev, &budget->i2c_adap, SAA7146_I2C_BUS_BIT_RATE_120);
+	strcpy(budget->i2c_adap.name, budget->card->name);
 
-	if (!budget->i2c_bus) {
+	if (i2c_add_adapter(&budget->i2c_adap) < 0) {
 		dvb_unregister_adapter (budget->dvb_adapter);
 		return -ENOMEM;
 	}
 
-	ttpci_eeprom_parse_mac(budget->i2c_bus);
+	ttpci_eeprom_parse_mac(&budget->i2c_adap, budget->dvb_adapter->proposed_mac);
 
 	if( NULL == (budget->grabbing = saa7146_vmalloc_build_pgtable(dev->pci,length,&budget->pt))) {
 		ret = -ENOMEM;
@@ -320,7 +348,7 @@ int ttpci_budget_init (struct budget *bu
 
 	saa7146_write(dev, PCI_BT_V1, 0x001c0000);
 	/* upload all */
-        saa7146_write(dev, GPIO_CTRL, 0x000000);
+	saa7146_write(dev, GPIO_CTRL, 0x000000);
 
 	tasklet_init (&budget->vpe_tasklet, vpeirq, (unsigned long) budget);
 
@@ -330,16 +358,15 @@ int ttpci_budget_init (struct budget *bu
 	else
 		saa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);
 
-        if (budget_register(budget) == 0) {
+	if (budget_register(budget) == 0) {
 		return 0;
 	}
 err:
+	i2c_del_adapter(&budget->i2c_adap);
+
 	if (budget->grabbing)
 		vfree(budget->grabbing);
 
-	dvb_unregister_i2c_bus (master_xfer,budget->i2c_bus->adapter,
-				budget->i2c_bus->id);
-
 	dvb_unregister_adapter (budget->dvb_adapter);
 
 	return ret;
@@ -354,8 +381,7 @@ int ttpci_budget_deinit (struct budget *
 
 	budget_unregister (budget);
 
-	dvb_unregister_i2c_bus (master_xfer, budget->i2c_bus->adapter,
-				budget->i2c_bus->id);
+	i2c_del_adapter(&budget->i2c_adap);
 
 	dvb_unregister_adapter (budget->dvb_adapter);
 
@@ -368,7 +394,7 @@ int ttpci_budget_deinit (struct budget *
 	return 0;
 }
 
-void ttpci_budget_irq10_handler (struct saa7146_dev* dev, u32 *isr) 
+void ttpci_budget_irq10_handler (struct saa7146_dev* dev, u32 *isr)
 {
 	struct budget *budget = (struct budget*)dev->ext_priv;
 
@@ -402,7 +428,5 @@ EXPORT_SYMBOL_GPL(ttpci_budget_irq10_han
 EXPORT_SYMBOL_GPL(ttpci_budget_set_video_port);
 EXPORT_SYMBOL_GPL(budget_debug);
 
-MODULE_PARM(budget_debug,"i");
 MODULE_LICENSE("GPL");
 
-
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget-patch.c linux/drivers/media/dvb/ttpci/budget-patch.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget-patch.c	2004-09-14 10:34:46.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/budget-patch.c	2004-09-17 14:56:38.920578389 +0200
@@ -167,7 +167,7 @@ static int budget_patch_attach (struct s
         struct budget_patch *budget;
         int err;
 	int count = 0;
-
+	
         if (!(budget = kmalloc (sizeof(struct budget_patch), GFP_KERNEL)))
                 return -ENOMEM;
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget.c linux/drivers/media/dvb/ttpci/budget.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget.c	2004-09-14 10:36:14.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/budget.c	2004-09-17 14:56:38.923577827 +0200
@@ -35,7 +35,6 @@
  */
 
 #include "budget.h"
-#include "dvb_functions.h"
 
 static void Set22K (struct budget *budget, int state)
 {
@@ -100,7 +99,7 @@ static int SendDiSEqCMsg (struct budget 
 			udelay(12500);
 			saa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);
 		}
-		dvb_delay(20);
+		msleep(20);
 	}
 
 	return 0;
@@ -202,6 +201,8 @@ static int budget_attach (struct saa7146
 
 	DEB_EE(("dev:%p, info:%p, budget:%p\n",dev,info,budget));
 
+	dev->ext_priv = budget;
+
 	if ((err = ttpci_budget_init (budget, dev, info))) {
 		printk("==> failed\n");
 		kfree (budget);
@@ -212,11 +213,9 @@ static int budget_attach (struct saa7146
 		dvb_add_frontend_ioctls (budget->dvb_adapter,
 				 budget_ioctl_activy, NULL, budget);
 	else
-	dvb_add_frontend_ioctls (budget->dvb_adapter,
+		dvb_add_frontend_ioctls (budget->dvb_adapter,
 				 budget_diseqc_ioctl, NULL, budget);
 
-	dev->ext_priv = budget;
-
 	return 0;
 }
 
@@ -230,14 +229,14 @@ static int budget_detach (struct saa7146
 		dvb_remove_frontend_ioctls (budget->dvb_adapter,
 				    budget_ioctl_activy, NULL);
 	else
-	dvb_remove_frontend_ioctls (budget->dvb_adapter,
+		dvb_remove_frontend_ioctls (budget->dvb_adapter,
 				    budget_diseqc_ioctl, NULL);
 
 	err = ttpci_budget_deinit (budget);
 
 	kfree (budget);
 	dev->ext_priv = NULL;
-
+	
 	return err;
 }
 
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget.h linux/drivers/media/dvb/ttpci/budget.h
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/budget.h	2004-09-14 10:36:30.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/budget.h	2004-09-17 14:56:38.925577452 +0200
@@ -1,9 +1,6 @@
 #ifndef __BUDGET_DVB__
 #define __BUDGET_DVB__
 
-#include <media/saa7146.h>
-
-#include "dvb_i2c.h"
 #include "dvb_frontend.h"
 #include "dvbdev.h"
 #include "demux.h"
@@ -12,6 +9,8 @@
 #include "dvb_filter.h"
 #include "dvb_net.h"
 
+#include <media/saa7146.h>
+
 extern int budget_debug;
 
 struct budget_info {
@@ -24,11 +23,11 @@ struct budget {
 
         /* devices */
         struct dvb_device       dvb_dev;
-        struct dvb_net               dvb_net;
+        struct dvb_net		dvb_net;
 
         struct saa7146_dev	*dev;
 
-	struct dvb_i2c_bus	*i2c_bus;	
+	struct i2c_adapter	i2c_adap;	
 	struct budget_info	*card;
 
 	unsigned char		*grabbing;
@@ -37,15 +36,15 @@ struct budget {
 	struct tasklet_struct   fidb_tasklet;
 	struct tasklet_struct   vpe_tasklet;
 
-        struct dmxdev                dmxdev;
+        struct dmxdev           dmxdev;
         struct dvb_demux	demux;
 
-        struct dmx_frontend          hw_frontend;
-        struct dmx_frontend          mem_frontend;
+        struct dmx_frontend     hw_frontend;
+        struct dmx_frontend     mem_frontend;
 
         int                     fe_synced; 
         struct semaphore        pid_mutex;
-
+	
 	int                     ci_present;
         int                     video_port;
 
@@ -79,6 +78,7 @@ static struct saa7146_pci_extension_data
 #define BUDGET_KNC1		   2
 #define BUDGET_PATCH		   3
 #define BUDGET_FS_ACTIVY	   4
+#define BUDGET_CIN1200		   5
 
 #define BUDGET_VIDEO_PORTA         0
 #define BUDGET_VIDEO_PORTB         1
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/ttpci-eeprom.c linux/drivers/media/dvb/ttpci/ttpci-eeprom.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/ttpci-eeprom.c	2004-09-14 10:36:42.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/ttpci-eeprom.c	2004-09-17 14:56:38.927577077 +0200
@@ -35,9 +35,8 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/string.h>
+#include <linux/i2c.h>
 
-#include "dvb_i2c.h"
-#include "dvb_functions.h"
 
 #if 1
 #define dprintk(x...) do { printk(x); } while (0)
@@ -85,19 +84,19 @@ static int getmac_tt(u8 * decodedMAC, u8
         return 0;
 }
 
-static int ttpci_eeprom_read_encodedMAC(struct dvb_i2c_bus *i2c, u8 * encodedMAC)
+static int ttpci_eeprom_read_encodedMAC(struct i2c_adapter *adapter, u8 * encodedMAC)
 {
 	int ret;
 	u8 b0[] = { 0xcc };
 
 	struct i2c_msg msg[] = {
-		{.addr = 0x50,.flags = 0,.buf = b0,.len = 1},
+		{ .addr = 0x50, .flags = 0, .buf = b0, .len = 1 },
 		{ .addr = 0x50, .flags = I2C_M_RD, .buf = encodedMAC, .len = 20 }
 	};
 
 	/* dprintk("%s\n", __FUNCTION__); */
 
-	ret = i2c->xfer(i2c, msg, 2);
+	ret = i2c_transfer(adapter, msg, 2);
 
 	if (ret != 2)		/* Assume EEPROM isn't there */
 		return (-ENODEV);
@@ -106,36 +105,34 @@ static int ttpci_eeprom_read_encodedMAC(
 }
 
 
-int ttpci_eeprom_parse_mac(struct dvb_i2c_bus *i2c)
+int ttpci_eeprom_parse_mac(struct i2c_adapter *adapter, u8 *proposed_mac)
 {
 	int ret, i;
 	u8 encodedMAC[20];
 	u8 decodedMAC[6];
 
-	ret = ttpci_eeprom_read_encodedMAC(i2c, encodedMAC);
+	ret = ttpci_eeprom_read_encodedMAC(adapter, encodedMAC);
 
 	if (ret != 0) {		/* Will only be -ENODEV */
 		dprintk("Couldn't read from EEPROM: not there?\n");
-		memset(i2c->adapter->proposed_mac, 0, 6);
+		memset(proposed_mac, 0, 6);
 		return ret;
 	}
 
 	ret = getmac_tt(decodedMAC, encodedMAC);
 	if( ret != 0 ) {
-		dprintk("%s adapter %i failed MAC signature check\n",
-			i2c->adapter->name, i2c->adapter->num);
+		dprintk("adapter failed MAC signature check\n");
 		dprintk("encoded MAC from EEPROM was " );
 		for(i=0; i<19; i++) {
 			dprintk( "%.2x:", encodedMAC[i]);
 		}
 		dprintk("%.2x\n", encodedMAC[19]);
-		memset(i2c->adapter->proposed_mac, 0, 6);
+		memset(proposed_mac, 0, 6);
 		return ret;
 	}
 
-	memcpy(i2c->adapter->proposed_mac, decodedMAC, 6);
-	dprintk("%s adapter %i has MAC addr = %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
-		i2c->adapter->name, i2c->adapter->num,
+	memcpy(proposed_mac, decodedMAC, 6);
+	dprintk("adapter has MAC addr = %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
 		decodedMAC[0], decodedMAC[1], decodedMAC[2],
 		decodedMAC[3], decodedMAC[4], decodedMAC[5]);
 	return 0;
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttpci/ttpci-eeprom.h linux/drivers/media/dvb/ttpci/ttpci-eeprom.h
--- linux-2.6.9-rc2/drivers/media/dvb/ttpci/ttpci-eeprom.h	2004-09-14 10:34:50.000000000 +0200
+++ linux/drivers/media/dvb/ttpci/ttpci-eeprom.h	2004-09-17 14:56:38.929576703 +0200
@@ -25,8 +25,9 @@
 #ifndef __TTPCI_EEPROM_H__
 #define __TTPCI_EEPROM_H__
 
-#include "dvb_i2c.h"
+#include <linux/types.h>
+#include <linux/i2c.h>
 
-extern int ttpci_eeprom_parse_mac(struct dvb_i2c_bus *i2c);
+extern int ttpci_eeprom_parse_mac(struct i2c_adapter *adapter, u8 *propsed_mac);
 
 #endif
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c linux/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c	2004-09-14 10:38:00.000000000 +0200
+++ linux/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c	2004-09-17 14:56:38.933575953 +0200
@@ -13,6 +13,7 @@
 #include <linux/slab.h>
 #include <linux/wait.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/usb.h>
 #include <linux/delay.h>
 #include <linux/time.h>
@@ -28,8 +29,6 @@
 #include <linux/dvb/dmx.h>
 #include <linux/pci.h>
 
-#include "dvb_functions.h"
-
 /*
   TTUSB_HWSECTIONS:
     the DSP supports filtering in hardware, however, since the "muxstream"
@@ -38,18 +37,21 @@
     so the best way is maybe to keep TTUSB_HWSECTIONS undef'd and just
     parse TS data. USB bandwith will be a problem when having large
     datastreams, especially for dvb-net, but hey, that's not my problem.
-	
+
   TTUSB_DISEQC, TTUSB_TONE:
     let the STC do the diseqc/tone stuff. this isn't supported at least with
     my TTUSB, so let it undef'd unless you want to implement another
     frontend. never tested.
-		
+
   DEBUG:
     define it to > 3 for really hardcore debugging. you probably don't want
     this unless the device doesn't load at all. > 2 for bandwidth statistics.
 */
 
-static int debug = 0;
+static int debug;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off debugging (default:off).");
 
 #define dprintk(x...) do { if (debug) printk(KERN_DEBUG x); } while (0)
 
@@ -80,6 +82,8 @@ struct ttusb {
 	struct dvb_adapter *adapter;
 	struct usb_device *dev;
 
+	struct i2c_adapter i2c_adap;	
+
 	int disconnecting;
 	int iso_streaming;
 
@@ -109,7 +113,7 @@ struct ttusb {
 
 	int cc;			/* MuxCounter - will increment on EVERY MUX PACKET */
 	/* (including stuffing. yes. really.) */
-
+	
 
 	u8 last_result[32];
 
@@ -242,10 +246,9 @@ static int ttusb_i2c_msg(struct ttusb *t
 	return rcv_len;
 }
 
-static int ttusb_i2c_xfer(struct dvb_i2c_bus *i2c, const struct i2c_msg msg[],
-		   int num)
+static int master_xfer(struct i2c_adapter* adapter, struct i2c_msg msg[], int num)
 {
-	struct ttusb *ttusb = i2c->data;
+	struct ttusb *ttusb = i2c_get_adapdata(adapter);
 	int i = 0;
 	int inc;
 
@@ -514,7 +517,7 @@ static int ttusb_set_tone(struct ttusb *
 
 static int ttusb_lnb_ioctl(struct dvb_frontend *fe, unsigned int cmd, void *arg)
 {
-	struct ttusb *ttusb = fe->i2c->data;
+	struct ttusb *ttusb = fe->before_after_data;
 
 	switch (cmd) {
 	case FE_SET_VOLTAGE:
@@ -787,7 +790,7 @@ static void ttusb_iso_irq(struct urb *ur
 			ttusb_process_frame(ttusb, data, len);
 		}
 	}
-	usb_submit_urb(urb, GFP_KERNEL);
+	usb_submit_urb(urb, GFP_ATOMIC);
 }
 
 static void ttusb_free_iso_urbs(struct ttusb *ttusb)
@@ -822,7 +825,7 @@ static int ttusb_alloc_iso_urbs(struct t
 
 		if (!
 		    (urb =
-		     usb_alloc_urb(FRAMES_PER_ISO_BUF, GFP_KERNEL))) {
+		     usb_alloc_urb(FRAMES_PER_ISO_BUF, GFP_ATOMIC))) {
 			ttusb_free_iso_urbs(ttusb);
 			return -ENOMEM;
 		}
@@ -880,7 +883,7 @@ static int ttusb_start_iso_xfer(struct t
 	}
 
 	for (i = 0; i < ISO_BUF_COUNT; i++) {
-		if ((err = usb_submit_urb(ttusb->iso_urb[i], GFP_KERNEL))) {
+		if ((err = usb_submit_urb(ttusb->iso_urb[i], GFP_ATOMIC))) {
 			ttusb_stop_iso_xfer(ttusb);
 			printk
 			    ("%s: failed urb submission (%i: err = %i)!\n",
@@ -1068,6 +1071,38 @@ static struct file_operations stc_fops =
 };
 #endif
 
+u32 functionality(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm ttusb_dec_algo = {
+	.name		= "ttusb dec i2c algorithm",
+	.id		= I2C_ALGO_BIT,
+	.master_xfer	= master_xfer,
+	.functionality	= functionality,
+};
+
+static int client_register(struct i2c_client *client)
+{
+	struct ttusb *ttusb = (struct ttusb*)i2c_get_adapdata(client->adapter);
+
+	if (client->driver->command)
+		return client->driver->command(client, FE_REGISTER, ttusb->adapter);
+
+	return 0;
+}
+
+static int client_unregister(struct i2c_client *client)
+{
+	struct ttusb *ttusb = (struct ttusb*)i2c_get_adapdata(client->adapter);
+
+	if (client->driver->command)
+		return client->driver->command(client, FE_UNREGISTER, ttusb->adapter);
+
+	return 0;
+}
+
 static int ttusb_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
 	struct usb_device *udev;
@@ -1078,17 +1113,6 @@ static int ttusb_probe(struct usb_interf
 
 	udev = interface_to_usbdev(intf);
 
-	/* Device has already been reset; its configuration was chosen.
-	 * If this fault happens, use a hotplug script to choose the
-	 * right configuration (write bConfigurationValue in sysfs).
-	 */
-	if (udev->actconfig->desc.bConfigurationValue != 1) {
-		dev_err(&intf->dev, "device config is #%d, need #1\n",
-			udev->actconfig->desc.bConfigurationValue);
-		return -ENODEV;
-	}
-
-
         if (intf->altsetting->desc.bInterfaceNumber != 1) return -ENODEV;
 
 	if (!(ttusb = kmalloc(sizeof(struct ttusb), GFP_KERNEL)))
@@ -1117,7 +1141,29 @@ static int ttusb_probe(struct usb_interf
 
 	dvb_register_adapter(&ttusb->adapter, "Technotrend/Hauppauge Nova-USB", THIS_MODULE);
 
-	dvb_register_i2c_bus(ttusb_i2c_xfer, ttusb, ttusb->adapter, 0);
+	/* i2c */
+	memset(&ttusb->i2c_adap, 0, sizeof(struct i2c_adapter));
+	strcpy(ttusb->i2c_adap.name, "TTUSB DEC");
+
+	i2c_set_adapdata(&ttusb->i2c_adap, ttusb);
+
+#ifdef I2C_ADAP_CLASS_TV_DIGITAL
+	ttusb->i2c_adap.class 	    	  = I2C_ADAP_CLASS_TV_DIGITAL;
+#else
+	ttusb->i2c_adap.class 	    	  = I2C_CLASS_TV_DIGITAL;
+#endif
+	ttusb->i2c_adap.algo              = &ttusb_dec_algo;
+	ttusb->i2c_adap.algo_data         = NULL;
+	ttusb->i2c_adap.id                = I2C_ALGO_BIT;
+	ttusb->i2c_adap.client_register   = client_register;
+	ttusb->i2c_adap.client_unregister = client_unregister;
+	
+	result = i2c_add_adapter(&ttusb->i2c_adap);
+	if (result) {
+		dvb_unregister_adapter (ttusb->adapter);
+		return result;
+	}
+
 	dvb_add_frontend_ioctls(ttusb->adapter, ttusb_lnb_ioctl, NULL,
 				ttusb);
 
@@ -1137,9 +1183,10 @@ static int ttusb_probe(struct usb_interf
 	ttusb->dvb_demux.write_to_decoder = NULL;
 
 	if ((result = dvb_dmx_init(&ttusb->dvb_demux)) < 0) {
-		printk("ttusb_dvb: dvb_dmx_init failed (errno = %d)\n",
-		       result);
-		goto err;
+		printk("ttusb_dvb: dvb_dmx_init failed (errno = %d)\n", result);
+		i2c_del_adapter(&ttusb->i2c_adap);
+		dvb_unregister_adapter (ttusb->adapter);
+		return -ENODEV;
 	}
 //FIXME dmxdev (nur WAS?)
 	ttusb->dmxdev.filternum = ttusb->dvb_demux.filternum;
@@ -1150,15 +1197,20 @@ static int ttusb_probe(struct usb_interf
 		printk("ttusb_dvb: dvb_dmxdev_init failed (errno = %d)\n",
 		       result);
 		dvb_dmx_release(&ttusb->dvb_demux);
-		goto err;
+		i2c_del_adapter(&ttusb->i2c_adap);
+		dvb_unregister_adapter (ttusb->adapter);
+		return -ENODEV;
 	}
 
-	if (dvb_net_init
-	    (ttusb->adapter, &ttusb->dvbnet, &ttusb->dvb_demux.dmx)) {
+	if (dvb_net_init(ttusb->adapter, &ttusb->dvbnet, &ttusb->dvb_demux.dmx)) {
 		printk("ttusb_dvb: dvb_net_init failed!\n");
+		dvb_dmxdev_release(&ttusb->dmxdev);
+		dvb_dmx_release(&ttusb->dvb_demux);
+		i2c_del_adapter(&ttusb->i2c_adap);
+		dvb_unregister_adapter (ttusb->adapter);
+		return -ENODEV;
 	}
 
-      err:
 #if 0
 	ttusb->stc_devfs_handle =
 	    devfs_register(ttusb->adapter->devfs_handle, TTUSB_BUDGET_NAME,
@@ -1166,7 +1218,6 @@ static int ttusb_probe(struct usb_interf
 			   S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP
 			   | S_IROTH | S_IWOTH, &stc_fops, ttusb);
 #endif
-
 	usb_set_intfdata(intf, (void *) ttusb);
 
 	return 0;
@@ -1187,7 +1238,7 @@ static void ttusb_disconnect(struct usb_
 	dvb_dmxdev_release(&ttusb->dmxdev);
 	dvb_dmx_release(&ttusb->dvb_demux);
 
-	dvb_unregister_i2c_bus(ttusb_i2c_xfer, ttusb->adapter, 0);
+	i2c_del_adapter(&ttusb->i2c_adap);
 	dvb_unregister_adapter(ttusb->adapter);
 
 	ttusb_free_iso_urbs(ttusb);
@@ -1234,9 +1285,6 @@ static void __exit ttusb_exit(void)
 module_init(ttusb_init);
 module_exit(ttusb_exit);
 
-MODULE_PARM(debug, "i");
-MODULE_PARM_DESC(debug, "Debug or not");
-
 MODULE_AUTHOR("Holger Waechtler <holger@convergence.de>");
 MODULE_DESCRIPTION("TTUSB DVB Driver");
 MODULE_LICENSE("GPL");
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttusb-dec/Kconfig linux/drivers/media/dvb/ttusb-dec/Kconfig
--- linux-2.6.9-rc2/drivers/media/dvb/ttusb-dec/Kconfig	2004-09-14 10:34:50.000000000 +0200
+++ linux/drivers/media/dvb/ttusb-dec/Kconfig	2004-09-17 14:56:38.935575579 +0200
@@ -12,8 +12,10 @@ config DVB_TTUSB_DEC
 	  only compressed MPEG data over the USB bus, so you need
 	  an external software decoder to watch TV on your computer.	  
 
-	  The DEC devices require firmware in order to boot into a mode in
-	  which they are slaves to the PC.  See
-	  <file:Documentation/dvb/ttusb-dec.txt> for details.
+          This driver needs external firmware. Please use the commands
+          "<kerneldir>/Documentation/dvb/get_dvb_firmware dec2000t",
+          "<kerneldir>/Documentation/dvb/get_dvb_firmware dec2540t",	
+          "<kerneldir>/Documentation/dvb/get_dvb_firmware dec3000s",
+          download/extract them, and then copy them to /usr/lib/hotplug/firmware.
 
 	  Say Y if you own such a device and want to use it.
diff -up linux-2.6.9-rc2/drivers/media/dvb/ttusb-dec/ttusb_dec.c linux/drivers/media/dvb/ttusb-dec/ttusb_dec.c
--- linux-2.6.9-rc2/drivers/media/dvb/ttusb-dec/ttusb_dec.c	2004-09-14 10:37:35.000000000 +0200
+++ linux/drivers/media/dvb/ttusb-dec/ttusb_dec.c	2004-09-17 14:56:38.941574455 +0200
@@ -22,10 +22,12 @@
 #include <asm/semaphore.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/usb.h>
+#include <linux/version.h>
 #include <linux/interrupt.h>
 #include <linux/firmware.h>
 #if defined(CONFIG_CRC32) || defined(CONFIG_CRC32_MODULE)
@@ -37,13 +39,17 @@
 
 #include "dmxdev.h"
 #include "dvb_demux.h"
-#include "dvb_i2c.h"
 #include "dvb_filter.h"
 #include "dvb_frontend.h"
 #include "dvb_net.h"
 
-static int debug = 0;
-static int output_pva = 0;
+static int debug;
+static int output_pva;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off debugging (default:off).");
+module_param(output_pva, int, 0444);
+MODULE_PARM_DESC(output_pva, "Output PVA from dvr device (default:off)");
 
 #define dprintk	if (debug) printk
 
@@ -95,7 +101,6 @@ struct ttusb_dec {
 	struct dmxdev			dmxdev;
 	struct dvb_demux		demux;
 	struct dmx_frontend		frontend;
-	struct dvb_i2c_bus		i2c_bus;
 	struct dvb_net			dvb_net;
 	struct dvb_frontend_info	*frontend_info;
 	int (*frontend_ioctl) (struct dvb_frontend *, unsigned int, void *);
@@ -105,14 +110,14 @@ struct ttusb_dec {
 	int			voltage;
 
 	/* USB bits */
-	struct usb_device	*udev;
-	u8			trans_count;
-	unsigned int		command_pipe;
-	unsigned int		result_pipe;
+	struct usb_device		*udev;
+	u8				trans_count;
+	unsigned int			command_pipe;
+	unsigned int			result_pipe;
 	unsigned int			in_pipe;
 	unsigned int			out_pipe;
 	enum ttusb_dec_interface	interface;
-	struct semaphore	usb_sem;
+	struct semaphore		usb_sem;
 
 	void			*iso_buffer;
 	dma_addr_t		iso_dma_handle;
@@ -211,7 +216,7 @@ static int ttusb_dec_send_command(struct
 	u8 *b;
 
 	dprintk("%s\n", __FUNCTION__);
-	
+
 	b = kmalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);
 	if (!b)
 		return -ENOMEM;
@@ -350,9 +355,9 @@ static void ttusb_dec_set_pids(struct tt
 
 	ttusb_dec_send_command(dec, 0x50, sizeof(b), b, NULL, NULL);
 
-		dvb_filter_pes2ts_init(&dec->a_pes2ts, dec->pid[DMX_PES_AUDIO],
+	dvb_filter_pes2ts_init(&dec->a_pes2ts, dec->pid[DMX_PES_AUDIO],
 			       ttusb_dec_audio_pes2ts_cb, dec);
-		dvb_filter_pes2ts_init(&dec->v_pes2ts, dec->pid[DMX_PES_VIDEO],
+	dvb_filter_pes2ts_init(&dec->v_pes2ts, dec->pid[DMX_PES_VIDEO],
 			       ttusb_dec_video_pes2ts_cb, dec);
 	dec->v_pes_length = 0;
 	dec->v_pes_postbytes = 0;
@@ -375,7 +380,7 @@ static void ttusb_dec_process_pva(struct
 	case 0x01: {		/* VideoStream */
 		int prebytes = pva[5] & 0x03;
 		int postbytes = (pva[5] & 0x0c) >> 2;
-			u16 v_pes_payload_length;
+		u16 v_pes_payload_length;
 
 		if (output_pva) {
 			dec->video_filter->feed->cb.ts(pva, length, NULL, 0,
@@ -383,23 +388,23 @@ static void ttusb_dec_process_pva(struct
 			return;
 		}
 
-			if (dec->v_pes_postbytes > 0 &&
-			    dec->v_pes_postbytes == prebytes) {
-				memcpy(&dec->v_pes[dec->v_pes_length],
+		if (dec->v_pes_postbytes > 0 &&
+		    dec->v_pes_postbytes == prebytes) {
+			memcpy(&dec->v_pes[dec->v_pes_length],
 			       &pva[12], prebytes);
 
-				dvb_filter_pes2ts(&dec->v_pes2ts, dec->v_pes,
+			dvb_filter_pes2ts(&dec->v_pes2ts, dec->v_pes,
 					  dec->v_pes_length + prebytes, 1);
-			}
+		}
 
 		if (pva[5] & 0x10) {
-				dec->v_pes[7] = 0x80;
-				dec->v_pes[8] = 0x05;
+			dec->v_pes[7] = 0x80;
+			dec->v_pes[8] = 0x05;
 
 			dec->v_pes[9] = 0x21 | ((pva[8] & 0xc0) >> 5);
 			dec->v_pes[10] = ((pva[8] & 0x3f) << 2) |
 					 ((pva[9] & 0xc0) >> 6);
-				dec->v_pes[11] = 0x01 |
+			dec->v_pes[11] = 0x01 |
 					 ((pva[9] & 0x3f) << 2) |
 					 ((pva[10] & 0x80) >> 6);
 			dec->v_pes[12] = ((pva[10] & 0x7f) << 1) |
@@ -409,33 +414,33 @@ static void ttusb_dec_process_pva(struct
 			memcpy(&dec->v_pes[14], &pva[12 + prebytes],
 			       length - 12 - prebytes);
 			dec->v_pes_length = 14 + length - 12 - prebytes;
-			} else {
-				dec->v_pes[7] = 0x00;
-				dec->v_pes[8] = 0x00;
+		} else {
+			dec->v_pes[7] = 0x00;
+			dec->v_pes[8] = 0x00;
 
 			memcpy(&dec->v_pes[9], &pva[8], length - 8);
 			dec->v_pes_length = 9 + length - 8;
-			}
+		}
 
-			dec->v_pes_postbytes = postbytes;
+		dec->v_pes_postbytes = postbytes;
 
-			if (dec->v_pes[9 + dec->v_pes[8]] == 0x00 &&
-			    dec->v_pes[10 + dec->v_pes[8]] == 0x00 &&
-			    dec->v_pes[11 + dec->v_pes[8]] == 0x01)
-				dec->v_pes[6] = 0x84;
-			else
-				dec->v_pes[6] = 0x80;
+		if (dec->v_pes[9 + dec->v_pes[8]] == 0x00 &&
+		    dec->v_pes[10 + dec->v_pes[8]] == 0x00 &&
+		    dec->v_pes[11 + dec->v_pes[8]] == 0x01)
+			dec->v_pes[6] = 0x84;
+		else
+			dec->v_pes[6] = 0x80;
 
-			v_pes_payload_length = htons(dec->v_pes_length - 6 +
-						     postbytes);
-			memcpy(&dec->v_pes[4], &v_pes_payload_length, 2);
-
-			if (postbytes == 0)
-				dvb_filter_pes2ts(&dec->v_pes2ts, dec->v_pes,
-						  dec->v_pes_length, 1);
+		v_pes_payload_length = htons(dec->v_pes_length - 6 +
+					     postbytes);
+		memcpy(&dec->v_pes[4], &v_pes_payload_length, 2);
+
+		if (postbytes == 0)
+			dvb_filter_pes2ts(&dec->v_pes2ts, dec->v_pes,
+					  dec->v_pes_length, 1);
 
-			break;
-		}
+		break;
+	}
 
 	case 0x02:		/* MainAudioStream */
 		if (output_pva) {
@@ -517,7 +522,7 @@ static void ttusb_dec_process_packet(str
 	case TTUSB_DEC_PACKET_PVA:
 		if (dec->pva_stream_count)
 			ttusb_dec_process_pva(dec, dec->packet,
-						 dec->packet_payload_length);
+					      dec->packet_payload_length);
 		break;
 
 	case TTUSB_DEC_PACKET_SECTION:
@@ -543,7 +548,7 @@ static void swap_bytes(u8 *b, int length
 	}
 }
 
-static void ttusb_dec_process_urb_frame(struct ttusb_dec * dec, u8 * b,
+static void ttusb_dec_process_urb_frame(struct ttusb_dec *dec, u8 *b,
 					int length)
 {
 	swap_bytes(b, length);
@@ -592,7 +597,7 @@ static void ttusb_dec_process_urb_frame(
 						TTUSB_DEC_PACKET_EMPTY;
 					dec->packet_payload_length = 2;
 					dec->packet_state = 7;
-			} else {
+				} else {
 					printk("%s: unknown packet type: "
 					       "%02x%02x\n", __FUNCTION__,
 					       dec->packet[0], dec->packet[1]);
@@ -628,23 +633,23 @@ static void ttusb_dec_process_urb_frame(
 			int remainder = dec->packet_payload_length -
 					dec->packet_length;
 
-				if (length >= remainder) {
+			if (length >= remainder) {
 				memcpy(dec->packet + dec->packet_length,
-					       b, remainder);
+				       b, remainder);
 				dec->packet_length += remainder;
-					b += remainder;
-					length -= remainder;
+				b += remainder;
+				length -= remainder;
 				dec->packet_state++;
-				} else {
+			} else {
 				memcpy(&dec->packet[dec->packet_length],
-					       b, length);
+				       b, length);
 				dec->packet_length += length;
-					length = 0;
-				}
-
-				break;
+				length = 0;
 			}
 
+			break;
+		}
+
 		case 7: {
 			int tail = 4;
 
@@ -706,7 +711,6 @@ static void ttusb_dec_process_urb(struct
 
 		for (i = 0; i < FRAMES_PER_ISO_BUF; i++) {
 			struct usb_iso_packet_descriptor *d;
-
 			u8 *b;
 			int length;
 			struct urb_frame *frame;
@@ -1100,7 +1104,7 @@ static int ttusb_dec_alloc_iso_urbs(stru
 				 	       &dec->iso_dma_handle);
 
 	memset(dec->iso_buffer, 0,
-	       sizeof(ISO_FRAME_SIZE * (FRAMES_PER_ISO_BUF * ISO_BUF_COUNT)));
+	       ISO_FRAME_SIZE * (FRAMES_PER_ISO_BUF * ISO_BUF_COUNT));
 
 	for (i = 0; i < ISO_BUF_COUNT; i++) {
 		struct urb *urb;
@@ -1169,6 +1173,7 @@ static int ttusb_dec_boot_dsp(struct ttu
 	u32 crc32_csum, crc32_check, tmp;
 #endif
 	const struct firmware *fw_entry = NULL;
+
 	dprintk("%s\n", __FUNCTION__);
 
 	if (request_firmware(&fw_entry, dec->firmware_name, &dec->udev->dev)) {
@@ -1181,7 +1186,7 @@ static int ttusb_dec_boot_dsp(struct ttu
 	firmware_size = fw_entry->size;
 
 	if (firmware_size < 60) {
-		printk("%s: firmware size too small for DSP code (%zu < 60).\n",
+		printk("%s: firmware size too small for DSP code (%u < 60).\n",
 			__FUNCTION__, firmware_size);
 		return -1;
 	}
@@ -1277,7 +1282,7 @@ static int ttusb_dec_init_stb(struct ttu
 			result = ttusb_dec_boot_dsp(dec);
 			if (result)
 				return result;
-		else
+			else
 				return 1;
 		} else {
 			/* We can't trust the USB IDs that some firmwares
@@ -1305,7 +1310,7 @@ static int ttusb_dec_init_stb(struct ttu
 				dec->can_playback = 1;
 
 			return 0;
-	}
+		}
 	}
 	else
 		return result;
@@ -1437,7 +1442,6 @@ static int ttusb_dec_2000t_frontend_ioct
 	dprintk("%s\n", __FUNCTION__);
 
 	switch (cmd) {
-
 	case FE_GET_INFO:
 		dprintk("%s: FE_GET_INFO\n", __FUNCTION__);
 		memcpy(arg, dec->frontend_info,
@@ -1445,27 +1449,27 @@ static int ttusb_dec_2000t_frontend_ioct
 		break;
 
 	case FE_READ_STATUS: {
-			fe_status_t *status = (fe_status_t *)arg;
-			dprintk("%s: FE_READ_STATUS\n", __FUNCTION__);
-			*status = FE_HAS_SIGNAL | FE_HAS_VITERBI |
-				  FE_HAS_SYNC | FE_HAS_CARRIER | FE_HAS_LOCK;
-			break;
-		}
+		fe_status_t *status = (fe_status_t *)arg;
+		dprintk("%s: FE_READ_STATUS\n", __FUNCTION__);
+		*status = FE_HAS_SIGNAL | FE_HAS_VITERBI |
+			  FE_HAS_SYNC | FE_HAS_CARRIER | FE_HAS_LOCK;
+		break;
+	}
 
 	case FE_READ_BER: {
-			u32 *ber = (u32 *)arg;
-			dprintk("%s: FE_READ_BER\n", __FUNCTION__);
-			*ber = 0;
-			return -ENOSYS;
-			break;
-		}
+		u32 *ber = (u32 *)arg;
+		dprintk("%s: FE_READ_BER\n", __FUNCTION__);
+		*ber = 0;
+		return -ENOSYS;
+		break;
+	}
 
 	case FE_READ_SIGNAL_STRENGTH: {
-			dprintk("%s: FE_READ_SIGNAL_STRENGTH\n", __FUNCTION__);
-			*(s32 *)arg = 0xFF;
-			return -ENOSYS;
-			break;
-		}
+		dprintk("%s: FE_READ_SIGNAL_STRENGTH\n", __FUNCTION__);
+		*(s32 *)arg = 0xFF;
+		return -ENOSYS;
+		break;
+	}
 
 	case FE_READ_SNR:
 		dprintk("%s: FE_READ_SNR\n", __FUNCTION__);
@@ -1480,28 +1484,28 @@ static int ttusb_dec_2000t_frontend_ioct
 		break;
 
 	case FE_SET_FRONTEND: {
-			struct dvb_frontend_parameters *p =
-				(struct dvb_frontend_parameters *)arg;
+		struct dvb_frontend_parameters *p =
+			(struct dvb_frontend_parameters *)arg;
 		u8 b[] = { 0x00, 0x00, 0x00, 0x03,
 			   0x00, 0x00, 0x00, 0x00,
 			   0x00, 0x00, 0x00, 0x01,
 			   0x00, 0x00, 0x00, 0xff,
 			   0x00, 0x00, 0x00, 0xff };
-			u32 freq;
+		u32 freq;
 
-			dprintk("%s: FE_SET_FRONTEND\n", __FUNCTION__);
+		dprintk("%s: FE_SET_FRONTEND\n", __FUNCTION__);
 
-			dprintk("            frequency->%d\n", p->frequency);
-			dprintk("            symbol_rate->%d\n",
-				p->u.qam.symbol_rate);
-			dprintk("            inversion->%d\n", p->inversion);
-
-			freq = htonl(p->frequency / 1000);
-			memcpy(&b[4], &freq, sizeof (u32));
-			ttusb_dec_send_command(dec, 0x71, sizeof(b), b, NULL, NULL);
+		dprintk("            frequency->%d\n", p->frequency);
+		dprintk("            symbol_rate->%d\n",
+			p->u.qam.symbol_rate);
+		dprintk("            inversion->%d\n", p->inversion);
+
+		freq = htonl(p->frequency / 1000);
+		memcpy(&b[4], &freq, sizeof (u32));
+		ttusb_dec_send_command(dec, 0x71, sizeof(b), b, NULL, NULL);
 
-			break;
-		}
+		break;
+	}
 
 	case FE_GET_FRONTEND:
 		dprintk("%s: FE_GET_FRONTEND\n", __FUNCTION__);
@@ -1519,7 +1523,6 @@ static int ttusb_dec_2000t_frontend_ioct
 	default:
 		dprintk("%s: unknown IOCTL (0x%X)\n", __FUNCTION__, cmd);
 		return -EINVAL;
-
 	}
 
 	return 0;
@@ -1541,27 +1544,27 @@ static int ttusb_dec_3000s_frontend_ioct
 		break;
 
 	case FE_READ_STATUS: {
-			fe_status_t *status = (fe_status_t *)arg;
-			dprintk("%s: FE_READ_STATUS\n", __FUNCTION__);
-			*status = FE_HAS_SIGNAL | FE_HAS_VITERBI |
-				  FE_HAS_SYNC | FE_HAS_CARRIER | FE_HAS_LOCK;
-			break;
-		}
+		fe_status_t *status = (fe_status_t *)arg;
+		dprintk("%s: FE_READ_STATUS\n", __FUNCTION__);
+		*status = FE_HAS_SIGNAL | FE_HAS_VITERBI |
+			  FE_HAS_SYNC | FE_HAS_CARRIER | FE_HAS_LOCK;
+		break;
+	}
 
 	case FE_READ_BER: {
-			u32 *ber = (u32 *)arg;
-			dprintk("%s: FE_READ_BER\n", __FUNCTION__);
-			*ber = 0;
-			return -ENOSYS;
-			break;
-		}
+		u32 *ber = (u32 *)arg;
+		dprintk("%s: FE_READ_BER\n", __FUNCTION__);
+		*ber = 0;
+		return -ENOSYS;
+		break;
+	}
 
 	case FE_READ_SIGNAL_STRENGTH: {
-			dprintk("%s: FE_READ_SIGNAL_STRENGTH\n", __FUNCTION__);
-			*(s32 *)arg = 0xFF;
-			return -ENOSYS;
-			break;
-		}
+		dprintk("%s: FE_READ_SIGNAL_STRENGTH\n", __FUNCTION__);
+		*(s32 *)arg = 0xFF;
+		return -ENOSYS;
+		break;
+	}
 
 	case FE_READ_SNR:
 		dprintk("%s: FE_READ_SNR\n", __FUNCTION__);
@@ -1576,8 +1579,8 @@ static int ttusb_dec_3000s_frontend_ioct
 		break;
 
 	case FE_SET_FRONTEND: {
-			struct dvb_frontend_parameters *p =
-				(struct dvb_frontend_parameters *)arg;
+		struct dvb_frontend_parameters *p =
+			(struct dvb_frontend_parameters *)arg;
 		u8 b[] = { 0x00, 0x00, 0x00, 0x01,
 			   0x00, 0x00, 0x00, 0x00,
 			   0x00, 0x00, 0x00, 0x01,
@@ -1588,32 +1591,32 @@ static int ttusb_dec_3000s_frontend_ioct
 			   0x00, 0x00, 0x00, 0x00,
 			   0x00, 0x00, 0x00, 0x00,
 			   0x00, 0x00, 0x00, 0x00 };
-			u32 freq;
-			u32 sym_rate;
-			u32 band;
+		u32 freq;
+		u32 sym_rate;
+		u32 band;
 		u32 lnb_voltage;
 
-			dprintk("%s: FE_SET_FRONTEND\n", __FUNCTION__);
+		dprintk("%s: FE_SET_FRONTEND\n", __FUNCTION__);
 
-			dprintk("            frequency->%d\n", p->frequency);
-			dprintk("            symbol_rate->%d\n",
-				p->u.qam.symbol_rate);
-			dprintk("            inversion->%d\n", p->inversion);
+		dprintk("            frequency->%d\n", p->frequency);
+		dprintk("            symbol_rate->%d\n",
+			p->u.qam.symbol_rate);
+		dprintk("            inversion->%d\n", p->inversion);
 
-		freq = htonl(p->frequency * 1000 +
+		freq = htonl(p->frequency +
 		       (dec->hi_band ? LOF_HI : LOF_LO));
-			memcpy(&b[4], &freq, sizeof(u32));
-			sym_rate = htonl(p->u.qam.symbol_rate);
-			memcpy(&b[12], &sym_rate, sizeof(u32));
-			band = htonl(dec->hi_band ? LOF_HI : LOF_LO);
-			memcpy(&b[24], &band, sizeof(u32));
+		memcpy(&b[4], &freq, sizeof(u32));
+		sym_rate = htonl(p->u.qam.symbol_rate);
+		memcpy(&b[12], &sym_rate, sizeof(u32));
+		band = htonl(dec->hi_band ? LOF_HI : LOF_LO);
+		memcpy(&b[24], &band, sizeof(u32));
 		lnb_voltage = htonl(dec->voltage);
 		memcpy(&b[28], &lnb_voltage, sizeof(u32));
 
-			ttusb_dec_send_command(dec, 0x71, sizeof(b), b, NULL, NULL);
+		ttusb_dec_send_command(dec, 0x71, sizeof(b), b, NULL, NULL);
 
-			break;
-		}
+		break;
+	}
 
 	case FE_GET_FRONTEND:
 		dprintk("%s: FE_GET_FRONTEND\n", __FUNCTION__);
@@ -1628,20 +1631,29 @@ static int ttusb_dec_3000s_frontend_ioct
 		dprintk("%s: FE_INIT\n", __FUNCTION__);
 		break;
 
-	case FE_DISEQC_SEND_MASTER_CMD:
+	case FE_DISEQC_SEND_MASTER_CMD: {
+		u8 b[] = { 0x00, 0xff, 0x00, 0x00,
+			   0x00, 0x00, 0x00, 0x00,
+			   0x00, 0x00 };
+		struct dvb_diseqc_master_cmd *cmd = arg;
+		memcpy(&b[4], cmd->msg, cmd->msg_len);
 		dprintk("%s: FE_DISEQC_SEND_MASTER_CMD\n", __FUNCTION__);
+		ttusb_dec_send_command(dec, 0x72,
+				       sizeof(b) - (6 - cmd->msg_len), b,
+				       NULL, NULL);
 		break;
+	}
 
 	case FE_DISEQC_SEND_BURST:
 		dprintk("%s: FE_DISEQC_SEND_BURST\n", __FUNCTION__);
 		break;
 
 	case FE_SET_TONE: {
-			fe_sec_tone_mode_t tone = (fe_sec_tone_mode_t)arg;
-			dprintk("%s: FE_SET_TONE\n", __FUNCTION__);
-			dec->hi_band = (SEC_TONE_ON == tone);
-			break;
-		}
+		fe_sec_tone_mode_t tone = (fe_sec_tone_mode_t)arg;
+		dprintk("%s: FE_SET_TONE\n", __FUNCTION__);
+		dec->hi_band = (SEC_TONE_ON == tone);
+		break;
+	}
 
 	case FE_SET_VOLTAGE:
 		dprintk("%s: FE_SET_VOLTAGE\n", __FUNCTION__);
@@ -1661,7 +1673,6 @@ static int ttusb_dec_3000s_frontend_ioct
 	default:
 		dprintk("%s: unknown IOCTL (0x%X)\n", __FUNCTION__, cmd);
 		return -EINVAL;
-
 	}
 
 	return 0;
@@ -1669,15 +1680,13 @@ static int ttusb_dec_3000s_frontend_ioct
 
 static void ttusb_dec_init_frontend(struct ttusb_dec *dec)
 {
-	dec->i2c_bus.adapter = dec->adapter;
-
-	dvb_register_frontend(dec->frontend_ioctl, &dec->i2c_bus, (void *)dec,
-			      dec->frontend_info);
+	int ret;
+	ret = dvb_register_frontend(dec->frontend_ioctl, dec->adapter, dec, dec->frontend_info, THIS_MODULE);
 }
 
 static void ttusb_dec_exit_frontend(struct ttusb_dec *dec)
 {
-	dvb_unregister_frontend(dec->frontend_ioctl, &dec->i2c_bus);
+	dvb_unregister_frontend(dec->frontend_ioctl, dec->adapter);
 }
 
 static void ttusb_dec_init_filters(struct ttusb_dec *dec)
@@ -1718,17 +1727,17 @@ static int ttusb_dec_probe(struct usb_in
 	memset(dec, 0, sizeof(struct ttusb_dec));
 
 	switch (id->idProduct) {
-		case 0x1006:
+	case 0x1006:
 		ttusb_dec_set_model(dec, TTUSB_DEC3000S);
-			break;
+		break;
 
-		case 0x1008:
+	case 0x1008:
 		ttusb_dec_set_model(dec, TTUSB_DEC2000T);
 		break;
 
 	case 0x1009:
 		ttusb_dec_set_model(dec, TTUSB_DEC2540T);
-			break;
+		break;
 	}
 
 	dec->udev = udev;
@@ -1760,11 +1769,11 @@ static void ttusb_dec_disconnect(struct 
 	dprintk("%s\n", __FUNCTION__);
 
 	if (dec->active) {
-	ttusb_dec_exit_tasklet(dec);
+		ttusb_dec_exit_tasklet(dec);
 		ttusb_dec_exit_filters(dec);
-	ttusb_dec_exit_usb(dec);
+		ttusb_dec_exit_usb(dec);
 		ttusb_dec_exit_frontend(dec);
-	ttusb_dec_exit_dvb(dec);
+		ttusb_dec_exit_dvb(dec);
 	}
 
 	kfree(dec);
@@ -1809,9 +1818,9 @@ static struct usb_device_id ttusb_dec_ta
 
 static struct usb_driver ttusb_dec_driver = {
 	.name		= "ttusb-dec",
-      .probe		= ttusb_dec_probe,
-      .disconnect	= ttusb_dec_disconnect,
-      .id_table		= ttusb_dec_table,
+	.probe		= ttusb_dec_probe,
+	.disconnect	= ttusb_dec_disconnect,
+	.id_table	= ttusb_dec_table,
 };
 
 static int __init ttusb_dec_init(void)
@@ -1840,7 +1849,3 @@ MODULE_DESCRIPTION(DRIVER_NAME);
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(usb, ttusb_dec_table);
 
-MODULE_PARM(debug, "i");
-MODULE_PARM_DESC(debug, "Debug level");
-MODULE_PARM(output_pva, "i");
-MODULE_PARM_DESC(output_pva, "Output PVA from dvr device");
diff -up linux-2.6.9-rc2/include/linux/dvb/dmx.h linux/include/linux/dvb/dmx.h
--- linux-2.6.9-rc2/include/linux/dvb/dmx.h	2004-09-14 10:37:32.000000000 +0200
+++ linux/include/linux/dvb/dmx.h	2004-09-17 14:56:38.950572769 +0200
@@ -31,6 +31,7 @@
 #include <time.h>
 #endif
 
+
 #define DMX_FILTER_SIZE 16
 
 typedef enum
@@ -112,7 +113,7 @@ typedef struct dmx_filter
 struct dmx_sct_filter_params
 {
 	__u16            pid;
-	dmx_filter_t        filter;
+	dmx_filter_t   filter;
 	__u32            timeout;
 	__u32            flags;
 #define DMX_CHECK_CRC       1
@@ -125,9 +126,9 @@ struct dmx_sct_filter_params
 struct dmx_pes_filter_params
 {
 	__u16            pid;
-	dmx_input_t         input;
-	dmx_output_t        output;
-	dmx_pes_type_t      pes_type;
+	dmx_input_t    input;
+	dmx_output_t   output;
+	dmx_pes_type_t pes_type;
 	__u32            flags;
 };
 
@@ -165,16 +166,16 @@ struct dmx_stc {
 };
 
 
-#define DMX_START                _IO('o',41) 
-#define DMX_STOP                 _IO('o',42)
-#define DMX_SET_FILTER           _IOW('o',43,struct dmx_sct_filter_params)
-#define DMX_SET_PES_FILTER       _IOW('o',44,struct dmx_pes_filter_params)
-#define DMX_SET_BUFFER_SIZE      _IO('o',45)
-#define DMX_GET_EVENT            _IOR('o',46,struct dmx_event)
+#define DMX_START                _IO('o', 41) 
+#define DMX_STOP                 _IO('o', 42)
+#define DMX_SET_FILTER           _IOW('o', 43, struct dmx_sct_filter_params)
+#define DMX_SET_PES_FILTER       _IOW('o', 44, struct dmx_pes_filter_params)
+#define DMX_SET_BUFFER_SIZE      _IO('o', 45)
+#define DMX_GET_EVENT            _IOR('o', 46, struct dmx_event)
 #define DMX_GET_PES_PIDS         _IOR('o', 47, __u16[5])
-#define DMX_GET_CAPS             _IOR('o',48,dmx_caps_t)
-#define DMX_SET_SOURCE           _IOW('o',49,dmx_source_t)
-#define DMX_GET_STC              _IOWR('o',50,struct dmx_stc)
+#define DMX_GET_CAPS             _IOR('o', 48, dmx_caps_t)
+#define DMX_SET_SOURCE           _IOW('o', 49, dmx_source_t)
+#define DMX_GET_STC              _IOWR('o', 50, struct dmx_stc)
 
 #endif /*_DVBDMX_H_*/
 
diff -up linux-2.6.9-rc2/include/linux/dvb/frontend.h linux/include/linux/dvb/frontend.h
--- linux-2.6.9-rc2/include/linux/dvb/frontend.h	2004-09-14 10:35:25.000000000 +0200
+++ linux/include/linux/dvb/frontend.h	2004-09-17 14:56:38.952572394 +0200
@@ -2,10 +2,10 @@
  * frontend.h
  *
  * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
- *                    Ralph  Metzler <ralph@convergence.de>
- *                    Holger Waechtler <holger@convergence.de>
- *                    Andre Draszik <ad@convergence.de>
- *                    for convergence integrated media GmbH
+ *		    Ralph  Metzler <ralph@convergence.de>
+ *		    Holger Waechtler <holger@convergence.de>
+ *		    Andre Draszik <ad@convergence.de>
+ *		    for convergence integrated media GmbH
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public License
@@ -30,52 +30,55 @@
 
 
 typedef enum fe_type {
-        FE_QPSK,
-        FE_QAM,
-        FE_OFDM
+	FE_QPSK,
+	FE_QAM,
+	FE_OFDM,
+	FE_ATSC
 } fe_type_t;
 
 
 typedef enum fe_caps {
-	FE_IS_STUPID                  = 0,
-	FE_CAN_INVERSION_AUTO         = 0x1,
-	FE_CAN_FEC_1_2                = 0x2,
-	FE_CAN_FEC_2_3                = 0x4,
-	FE_CAN_FEC_3_4                = 0x8,
-	FE_CAN_FEC_4_5                = 0x10,
-	FE_CAN_FEC_5_6                = 0x20,
-	FE_CAN_FEC_6_7                = 0x40,
-	FE_CAN_FEC_7_8                = 0x80,
-	FE_CAN_FEC_8_9                = 0x100,
-	FE_CAN_FEC_AUTO               = 0x200,
-	FE_CAN_QPSK                   = 0x400,
-	FE_CAN_QAM_16                 = 0x800,
-	FE_CAN_QAM_32                 = 0x1000,
-	FE_CAN_QAM_64                 = 0x2000,
-	FE_CAN_QAM_128                = 0x4000,
-	FE_CAN_QAM_256                = 0x8000,
-	FE_CAN_QAM_AUTO               = 0x10000,
-	FE_CAN_TRANSMISSION_MODE_AUTO = 0x20000,
-	FE_CAN_BANDWIDTH_AUTO         = 0x40000,
-	FE_CAN_GUARD_INTERVAL_AUTO    = 0x80000,
-	FE_CAN_HIERARCHY_AUTO         = 0x100000,
-	FE_NEEDS_BENDING              = 0x20000000, // frontend requires frequency bending
-	FE_CAN_RECOVER                = 0x40000000, // frontend can recover from a cable unplug automatically
-	FE_CAN_MUTE_TS                = 0x80000000  // frontend can stop spurious TS data output
+	FE_IS_STUPID			= 0,
+	FE_CAN_INVERSION_AUTO		= 0x1,
+	FE_CAN_FEC_1_2			= 0x2,
+	FE_CAN_FEC_2_3			= 0x4,
+	FE_CAN_FEC_3_4			= 0x8,
+	FE_CAN_FEC_4_5			= 0x10,
+	FE_CAN_FEC_5_6			= 0x20,
+	FE_CAN_FEC_6_7			= 0x40,
+	FE_CAN_FEC_7_8			= 0x80,
+	FE_CAN_FEC_8_9			= 0x100,
+	FE_CAN_FEC_AUTO			= 0x200,
+	FE_CAN_QPSK			= 0x400,
+	FE_CAN_QAM_16			= 0x800,
+	FE_CAN_QAM_32			= 0x1000,
+	FE_CAN_QAM_64			= 0x2000,
+	FE_CAN_QAM_128			= 0x4000,
+	FE_CAN_QAM_256			= 0x8000,
+	FE_CAN_QAM_AUTO			= 0x10000,
+	FE_CAN_TRANSMISSION_MODE_AUTO	= 0x20000,
+	FE_CAN_BANDWIDTH_AUTO		= 0x40000,
+	FE_CAN_GUARD_INTERVAL_AUTO	= 0x80000,
+	FE_CAN_HIERARCHY_AUTO		= 0x100000,
+	FE_CAN_8VSB			= 0x200000,
+	FE_CAN_16VSB			= 0x400000,
+	FE_NEEDS_BENDING		= 0x20000000, // frontend requires frequency bending
+	FE_CAN_RECOVER			= 0x40000000, // frontend can recover from a cable unplug automatically
+	FE_CAN_MUTE_TS			= 0x80000000  // frontend can stop spurious TS data output
 } fe_caps_t;
 
 
 struct dvb_frontend_info {
 	char       name[128];
-        fe_type_t  type;
-        __u32      frequency_min;
-        __u32      frequency_max;
+	fe_type_t  type;
+	__u32      frequency_min;
+	__u32      frequency_max;
 	__u32      frequency_stepsize;
 	__u32      frequency_tolerance;
 	__u32      symbol_rate_min;
-        __u32      symbol_rate_max;
-	__u32      symbol_rate_tolerance;     /* ppm */
-	__u32      notifier_delay;            /* ms */
+	__u32      symbol_rate_max;
+	__u32      symbol_rate_tolerance;	/* ppm */
+	__u32      notifier_delay;		/* ms */
 	fe_caps_t  caps;
 };
 
@@ -85,76 +88,76 @@ struct dvb_frontend_info {
  *  the meaning of this struct...
  */
 struct dvb_diseqc_master_cmd {
-        __u8 msg [6];        /*  { framing, address, command, data [3] } */
-        __u8 msg_len;        /*  valid values are 3...6  */
+	__u8 msg [6];	/*  { framing, address, command, data [3] } */
+	__u8 msg_len;	/*  valid values are 3...6  */
 };
 
 
 struct dvb_diseqc_slave_reply {
-	__u8 msg [4];        /*  { framing, data [3] } */
-	__u8 msg_len;        /*  valid values are 0...4, 0 means no msg  */
-	int     timeout;        /*  return from ioctl after timeout ms with */
-};                              /*  errorcode when no message was received  */
+	__u8 msg [4];	/*  { framing, data [3] } */
+	__u8 msg_len;	/*  valid values are 0...4, 0 means no msg  */
+	int  timeout;	/*  return from ioctl after timeout ms with */
+};			/*  errorcode when no message was received  */
 
 
 typedef enum fe_sec_voltage {
-        SEC_VOLTAGE_13,
-        SEC_VOLTAGE_18,
+	SEC_VOLTAGE_13,
+	SEC_VOLTAGE_18,
 	SEC_VOLTAGE_OFF
 } fe_sec_voltage_t;
 
 
 typedef enum fe_sec_tone_mode {
-        SEC_TONE_ON,
-        SEC_TONE_OFF
+	SEC_TONE_ON,
+	SEC_TONE_OFF
 } fe_sec_tone_mode_t;
 
 
 typedef enum fe_sec_mini_cmd {
-        SEC_MINI_A,
-        SEC_MINI_B
+	SEC_MINI_A,
+	SEC_MINI_B
 } fe_sec_mini_cmd_t;
 
 
 typedef enum fe_status {
-	FE_HAS_SIGNAL     = 0x01,   /*  found something above the noise level */
-	FE_HAS_CARRIER    = 0x02,   /*  found a DVB signal  */
-	FE_HAS_VITERBI    = 0x04,   /*  FEC is stable  */
-	FE_HAS_SYNC       = 0x08,   /*  found sync bytes  */
-	FE_HAS_LOCK       = 0x10,   /*  everything's working... */
-	FE_TIMEDOUT       = 0x20,   /*  no lock within the last ~2 seconds */
-	FE_REINIT         = 0x40    /*  frontend was reinitialized,  */
-} fe_status_t;                      /*  application is recommended to reset */
-                                    /*  DiSEqC, tone and parameters */
+	FE_HAS_SIGNAL	= 0x01,   /*  found something above the noise level */
+	FE_HAS_CARRIER	= 0x02,   /*  found a DVB signal  */
+	FE_HAS_VITERBI	= 0x04,   /*  FEC is stable  */
+	FE_HAS_SYNC	= 0x08,   /*  found sync bytes  */
+	FE_HAS_LOCK	= 0x10,   /*  everything's working... */
+	FE_TIMEDOUT	= 0x20,   /*  no lock within the last ~2 seconds */
+	FE_REINIT	= 0x40    /*  frontend was reinitialized,  */
+} fe_status_t;			  /*  application is recommended to reset */
+				  /*  DiSEqC, tone and parameters */
 
 typedef enum fe_spectral_inversion {
-        INVERSION_OFF,
-        INVERSION_ON,
-        INVERSION_AUTO
+	INVERSION_OFF,
+	INVERSION_ON,
+	INVERSION_AUTO
 } fe_spectral_inversion_t;
 
 
 typedef enum fe_code_rate {
-        FEC_NONE = 0,
-        FEC_1_2,
-        FEC_2_3,
-        FEC_3_4,
-        FEC_4_5,
-        FEC_5_6,
-        FEC_6_7,
-        FEC_7_8,
-        FEC_8_9,
-        FEC_AUTO
+	FEC_NONE = 0,
+	FEC_1_2,
+	FEC_2_3,
+	FEC_3_4,
+	FEC_4_5,
+	FEC_5_6,
+	FEC_6_7,
+	FEC_7_8,
+	FEC_8_9,
+	FEC_AUTO
 } fe_code_rate_t;
 
 
 typedef enum fe_modulation {
-        QPSK,
-        QAM_16,
-        QAM_32,
-        QAM_64,
-        QAM_128,
-        QAM_256,
+	QPSK,
+	QAM_16,
+	QAM_32,
+	QAM_64,
+	QAM_128,
+	QAM_256,
 	QAM_AUTO
 } fe_modulation_t;
 
@@ -192,32 +195,32 @@ typedef enum fe_hierarchy {
 
 
 struct dvb_qpsk_parameters {
-        __u32           symbol_rate;  /* symbol rate in Symbols per second */
-        fe_code_rate_t  fec_inner;    /* forward error correction (see above) */
+	__u32		symbol_rate;  /* symbol rate in Symbols per second */
+	fe_code_rate_t	fec_inner;    /* forward error correction (see above) */
 };
 
 
 struct dvb_qam_parameters {
-        __u32            symbol_rate; /* symbol rate in Symbols per second */
-        fe_code_rate_t   fec_inner;   /* forward error correction (see above) */
-        fe_modulation_t  modulation;  /* modulation type (see above) */
+	__u32		symbol_rate; /* symbol rate in Symbols per second */
+	fe_code_rate_t	fec_inner;   /* forward error correction (see above) */
+	fe_modulation_t	modulation;  /* modulation type (see above) */
 };
 
 
 struct dvb_ofdm_parameters {
-        fe_bandwidth_t      bandwidth;
-        fe_code_rate_t      code_rate_HP;  /* high priority stream code rate */
-        fe_code_rate_t      code_rate_LP;  /* low priority stream code rate */
-        fe_modulation_t     constellation; /* modulation type (see above) */
-        fe_transmit_mode_t  transmission_mode;
-        fe_guard_interval_t guard_interval;
-        fe_hierarchy_t      hierarchy_information;
+	fe_bandwidth_t      bandwidth;
+	fe_code_rate_t      code_rate_HP;  /* high priority stream code rate */
+	fe_code_rate_t      code_rate_LP;  /* low priority stream code rate */
+	fe_modulation_t     constellation; /* modulation type (see above) */
+	fe_transmit_mode_t  transmission_mode;
+	fe_guard_interval_t guard_interval;
+	fe_hierarchy_t      hierarchy_information;
 };
 
 
 struct dvb_frontend_parameters {
-        __u32 frequency;     /* (absolute) frequency in Hz for QAM/OFDM */
-                                  /* intermediate frequency in kHz for QPSK */
+	__u32 frequency;     /* (absolute) frequency in Hz for QAM/OFDM */
+			     /* intermediate frequency in kHz for QPSK */
 	fe_spectral_inversion_t inversion;
 	union {
 		struct dvb_qpsk_parameters qpsk;
@@ -234,26 +237,26 @@ struct dvb_frontend_event {
 
 
 
-#define FE_GET_INFO                _IOR('o', 61, struct dvb_frontend_info)
+#define FE_GET_INFO		   _IOR('o', 61, struct dvb_frontend_info)
 
 #define FE_DISEQC_RESET_OVERLOAD   _IO('o', 62)
 #define FE_DISEQC_SEND_MASTER_CMD  _IOW('o', 63, struct dvb_diseqc_master_cmd)
 #define FE_DISEQC_RECV_SLAVE_REPLY _IOR('o', 64, struct dvb_diseqc_slave_reply)
 #define FE_DISEQC_SEND_BURST       _IO('o', 65)  /* fe_sec_mini_cmd_t */
 
-#define FE_SET_TONE                _IO('o', 66)  /* fe_sec_tone_mode_t */
-#define FE_SET_VOLTAGE             _IO('o', 67)  /* fe_sec_voltage_t */
+#define FE_SET_TONE		   _IO('o', 66)  /* fe_sec_tone_mode_t */
+#define FE_SET_VOLTAGE		   _IO('o', 67)  /* fe_sec_voltage_t */
 #define FE_ENABLE_HIGH_LNB_VOLTAGE _IO('o', 68)  /* int */
 
-#define FE_READ_STATUS             _IOR('o', 69, fe_status_t)
-#define FE_READ_BER                _IOR('o', 70, __u32)
+#define FE_READ_STATUS		   _IOR('o', 69, fe_status_t)
+#define FE_READ_BER		   _IOR('o', 70, __u32)
 #define FE_READ_SIGNAL_STRENGTH    _IOR('o', 71, __u16)
-#define FE_READ_SNR                _IOR('o', 72, __u16)
+#define FE_READ_SNR		   _IOR('o', 72, __u16)
 #define FE_READ_UNCORRECTED_BLOCKS _IOR('o', 73, __u32)
 
-#define FE_SET_FRONTEND            _IOW('o', 76, struct dvb_frontend_parameters)
-#define FE_GET_FRONTEND            _IOR('o', 77, struct dvb_frontend_parameters)
-#define FE_GET_EVENT               _IOR('o', 78, struct dvb_frontend_event)
+#define FE_SET_FRONTEND		   _IOW('o', 76, struct dvb_frontend_parameters)
+#define FE_GET_FRONTEND		   _IOR('o', 77, struct dvb_frontend_parameters)
+#define FE_GET_EVENT		   _IOR('o', 78, struct dvb_frontend_event)
 
 
 #endif /*_DVBFRONTEND_H_*/
diff -up linux-2.6.9-rc2/include/linux/dvb/net.h linux/include/linux/dvb/net.h
--- linux-2.6.9-rc2/include/linux/dvb/net.h	2004-09-14 10:34:44.000000000 +0200
+++ linux/include/linux/dvb/net.h	2004-09-17 14:56:38.954572019 +0200
@@ -1,4 +1,4 @@
-/* 
+/*
  * net.h
  *
  * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
@@ -36,9 +36,9 @@ struct dvb_net_if {
 };
 
 
-#define NET_ADD_IF                 _IOWR('o', 52, struct dvb_net_if)
-#define NET_REMOVE_IF              _IO('o', 53)
-#define NET_GET_IF                 _IOWR('o', 54, struct dvb_net_if)
+#define NET_ADD_IF    _IOWR('o', 52, struct dvb_net_if)
+#define NET_REMOVE_IF _IO('o', 53)
+#define NET_GET_IF    _IOWR('o', 54, struct dvb_net_if)
 
 
 /* binary compatibility cruft: */
diff -up linux-2.6.9-rc2/include/linux/dvb/osd.h linux/include/linux/dvb/osd.h
--- linux-2.6.9-rc2/include/linux/dvb/osd.h	2004-09-14 10:36:50.000000000 +0200
+++ linux/include/linux/dvb/osd.h	2004-09-17 14:56:38.956571645 +0200
@@ -94,6 +94,7 @@ typedef enum {
   OSD_Text,       // (x0,y0,size,color,text)
   OSD_SetWindow, //  (x0) set window with number 0<x0<8 as current
   OSD_MoveWindow, //  move current window to (x0, y0)  
+  OSD_OpenRaw,	// Open other types of OSD windows
 } OSD_Command;
 
 typedef struct osd_cmd_s {
@@ -106,8 +107,39 @@ typedef struct osd_cmd_s {
         void __user *data;
 } osd_cmd_t;
 
+/* OSD_OpenRaw: set 'color' to desired window type */
+typedef enum {
+        OSD_BITMAP1,           /* 1 bit bitmap */
+        OSD_BITMAP2,           /* 2 bit bitmap */
+        OSD_BITMAP4,           /* 4 bit bitmap */
+        OSD_BITMAP8,           /* 8 bit bitmap */
+        OSD_BITMAP1HR,         /* 1 Bit bitmap half resolution */
+        OSD_BITMAP2HR,         /* 2 bit bitmap half resolution */
+        OSD_BITMAP4HR,         /* 4 bit bitmap half resolution */
+        OSD_BITMAP8HR,         /* 8 bit bitmap half resolution */
+        OSD_YCRCB422,          /* 4:2:2 YCRCB Graphic Display */
+        OSD_YCRCB444,          /* 4:4:4 YCRCB Graphic Display */
+        OSD_YCRCB444HR,        /* 4:4:4 YCRCB graphic half resolution */
+        OSD_VIDEOTSIZE,        /* True Size Normal MPEG Video Display */
+        OSD_VIDEOHSIZE,        /* MPEG Video Display Half Resolution */
+        OSD_VIDEOQSIZE,        /* MPEG Video Display Quarter Resolution */
+        OSD_VIDEODSIZE,        /* MPEG Video Display Double Resolution */
+        OSD_VIDEOTHSIZE,       /* True Size MPEG Video Display Half Resolution */
+        OSD_VIDEOTQSIZE,       /* True Size MPEG Video Display Quarter Resolution*/
+        OSD_VIDEOTDSIZE,       /* True Size MPEG Video Display Double Resolution */
+        OSD_VIDEONSIZE,        /* Full Size MPEG Video Display */
+        OSD_CURSOR             /* Cursor */
+} osd_raw_window_t;
 
-#define OSD_SEND_CMD       _IOW('o', 160, osd_cmd_t)
+typedef struct osd_cap_s {
+        int  cmd;
+#define OSD_CAP_MEMSIZE         1  /* memory size */
+        long val;
+} osd_cap_t;
+
+
+#define OSD_SEND_CMD            _IOW('o', 160, osd_cmd_t)
+#define OSD_GET_CAPABILITY      _IOR('o', 161, osd_cap_t)
 
 #endif
 
diff -up linux-2.6.9-rc2/include/linux/dvb/video.h linux/include/linux/dvb/video.h
--- linux-2.6.9-rc2/include/linux/dvb/video.h	2004-09-14 10:34:45.000000000 +0200
+++ linux/include/linux/dvb/video.h	2004-09-17 14:56:38.958571270 +0200
@@ -35,7 +35,7 @@
 
 
 typedef enum {
-	VIDEO_FORMAT_4_3,     /* Select 4:3 format */ 
+	VIDEO_FORMAT_4_3,     /* Select 4:3 format */
         VIDEO_FORMAT_16_9,    /* Select 16:9 format. */
 	VIDEO_FORMAT_221_1    /* 2.21:1 */
 } video_format_t;
@@ -82,13 +82,13 @@ typedef enum {
 
 struct video_event { 
         int32_t type; 
-#define VIDEO_EVENT_SIZE_CHANGED 1
+#define VIDEO_EVENT_SIZE_CHANGED	1
 #define VIDEO_EVENT_FRAME_RATE_CHANGED	2
         time_t timestamp;
-	union { 
+	union {
 	        video_size_t size;
 		unsigned int frame_rate;	/* in frames per 1000sec */
-	} u; 
+	} u;
 };
 
 
diff -up linux-2.6.9-rc2/include/media/saa7146.h linux/include/media/saa7146.h
--- linux-2.6.9-rc2/include/media/saa7146.h	2004-09-14 10:34:36.000000000 +0200
+++ linux/include/media/saa7146.h	2004-09-17 14:56:38.960570895 +0200
@@ -15,9 +15,21 @@
 #include <linux/vmalloc.h>	/* for vmalloc() */
 #include <linux/mm.h>		/* for vmalloc_to_page() */
 
-/* ugly, but necessary to build the dvb stuff under 2.4. */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,51)
-	#include "dvb_functions.h"
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#ifndef __CRAP_H
+static inline int try_module_get(struct module *mod)
+{
+	if (!MOD_CAN_QUERY(mod))
+		return 0;
+	__MOD_INC_USE_COUNT(mod);
+	return 1;
+}
+
+#define module_put(mod) __MOD_DEC_USE_COUNT(mod)
+#define iminor(xx) minor(xx->i_rdev)
+#define strlcpy strncpy
+#define i2c_get_adapdata(adapter) (struct saa7146_dev*)adapter->data;
+#endif
 #endif
 
 #define SAA7146_VERSION_CODE KERNEL_VERSION(0,5,0)
@@ -91,7 +103,7 @@ struct saa7146_extension
 #define SAA7146_USE_I2C_IRQ	0x1
 #define SAA7146_I2C_SHORT_DELAY	0x2
 	int	flags;
-	
+		
 	/* pairs of subvendor and subdevice ids for
 	   supported devices, last entry 0xffff, 0xfff */
 	struct module *module;
@@ -154,8 +166,8 @@ struct saa7146_dev
 };
 
 /* from saa7146_i2c.c */
-int saa7146_i2c_adapter_prepare(struct saa7146_dev *dev, struct i2c_adapter *i2c_adapter, unsigned int class, u32 bitrate);
-int saa7146_i2c_transfer(struct saa7146_dev *saa, const struct i2c_msg msgs[], int num,  int retries);
+int saa7146_i2c_adapter_prepare(struct saa7146_dev *dev, struct i2c_adapter *i2c_adapter, u32 bitrate);
+int saa7146_i2c_transfer(struct saa7146_dev *saa, const struct i2c_msg msgs[], int num, int retries);
 
 /* from saa7146_core.c */
 extern struct list_head saa7146_devices;
diff -up linux-2.6.9-rc2/include/media/saa7146_vv.h linux/include/media/saa7146_vv.h
--- linux-2.6.9-rc2/include/media/saa7146_vv.h	2004-09-14 10:34:41.000000000 +0200
+++ linux/include/media/saa7146_vv.h	2004-09-17 14:56:38.962570521 +0200
@@ -35,6 +35,7 @@ struct saa7146_format {
 	u32	trans;
 	u8	depth;
 	u8	flags;
+	u8	swap;
 };
 
 struct saa7146_standard
@@ -126,11 +127,11 @@ struct saa7146_vv
 	struct saa7146_format		*ov_fmt;
 	struct saa7146_overlay		*ov_data;
 	struct saa7146_fh		*ov_suspend;
-
+	
 	/* video capture */
 	struct saa7146_dmaqueue		video_q;
 	enum v4l2_field			last_field;
-
+	
 	/* common: fixme? shouldn't this be in saa7146_fh?
 	   (this leads to a more complicated question: shall the driver
 	   store the different settings (for example S_INPUT) for every open
@@ -188,8 +189,8 @@ struct saa7146_use_ops  {
 };
 
 /* from saa7146_fops.c */
-int saa7146_register_device(struct video_device *vid, struct saa7146_dev* dev, char *name, int type);
-int saa7146_unregister_device(struct video_device *vid, struct saa7146_dev* dev);
+int saa7146_register_device(struct video_device **vid, struct saa7146_dev* dev, char *name, int type);
+int saa7146_unregister_device(struct video_device **vid, struct saa7146_dev* dev);
 void saa7146_buffer_finish(struct saa7146_dev *dev, struct saa7146_dmaqueue *q, int state);
 void saa7146_buffer_next(struct saa7146_dev *dev, struct saa7146_dmaqueue *q,int vbi);
 int saa7146_buffer_queue(struct saa7146_dev *dev, struct saa7146_dmaqueue *q, struct saa7146_buf *buf);
