From: Takashi Iwai <tiwai@suse.de>
Subject: [ALSA] hda-intel - Automatic correction to single_cmd mode
Patch-mainline: 2.6.16-git
References: 

[ALSA] hda-intel - Automatic correction to single_cmd mode

Switch to single_cmd mode automatically as a fallback when CORB/RIRB
communication doesn't work well.  It may make the driver working on
some devices with broken BIOS/ACPI support.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
commit dabd8601a0164e4fb1f83eeabbe46f38db53d835
tree ad2819ce0d8941f75a93b99a4d2f64af6686a389
parent ed61ce21fbb82818b7fa43ce852ed10ece94b8d4
author Takashi Iwai <tiwai@suse.de> Thu, 16 Feb 2006 19:17:58 +0100
committer Takashi Iwai <tiwai@suse.de> Thu, 16 Feb 2006 20:54:34 +0100

 sound/pci/hda/hda_codec.c |    6 +++++
 sound/pci/hda/hda_intel.c |   60 ++++++++++++++++++++++++++++++++-------------
 2 files changed, 49 insertions(+), 17 deletions(-)

diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 208a334..0d1566a 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -531,6 +531,12 @@ int snd_hda_codec_new(struct hda_bus *bu
 	bus->caddr_tbl[codec_addr] = codec;
 
 	codec->vendor_id = snd_hda_param_read(codec, AC_NODE_ROOT, AC_PAR_VENDOR_ID);
+	if (codec->vendor_id == -1)
+		/* read again, hopefully the access method was corrected
+		 * in the last read...
+		 */
+		codec->vendor_id = snd_hda_param_read(codec, AC_NODE_ROOT,
+						      AC_PAR_VENDOR_ID);
 	codec->subsystem_id = snd_hda_param_read(codec, AC_NODE_ROOT, AC_PAR_SUBSYSTEM_ID);
 	codec->revision_id = snd_hda_param_read(codec, AC_NODE_ROOT, AC_PAR_REV_ID);
 
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index dbed264..016fbc2 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -446,8 +446,8 @@ static void azx_free_cmd_io(struct azx *
 }
 
 /* send a command */
-static int azx_send_cmd(struct hda_codec *codec, hda_nid_t nid, int direct,
-			unsigned int verb, unsigned int para)
+static int azx_corb_send_cmd(struct hda_codec *codec, hda_nid_t nid, int direct,
+			     unsigned int verb, unsigned int para)
 {
 	struct azx *chip = codec->bus->private_data;
 	unsigned int wp;
@@ -503,18 +503,21 @@ static void azx_update_rirb(struct azx *
 }
 
 /* receive a response */
-static unsigned int azx_get_response(struct hda_codec *codec)
+static unsigned int azx_rirb_get_response(struct hda_codec *codec)
 {
 	struct azx *chip = codec->bus->private_data;
 	int timeout = 50;
 
 	while (chip->rirb.cmds) {
 		if (! --timeout) {
-			if (printk_ratelimit())
-				snd_printk(KERN_ERR
-					"azx_get_response timeout\n");
+			snd_printk(KERN_ERR
+				   "hda_intel: azx_get_response timeout, "
+				   "switching to single_cmd mode...\n");
 			chip->rirb.rp = azx_readb(chip, RIRBWP);
 			chip->rirb.cmds = 0;
+			/* switch to single_cmd mode */
+			chip->single_cmd = 1;
+			azx_free_cmd_io(chip);
 			return -1;
 		}
 		msleep(1);
@@ -578,6 +581,36 @@ static unsigned int azx_single_get_respo
 	return (unsigned int)-1;
 }
 
+/*
+ * The below are the main callbacks from hda_codec.
+ *
+ * They are just the skeleton to call sub-callbacks according to the
+ * current setting of chip->single_cmd.
+ */
+
+/* send a command */
+static int azx_send_cmd(struct hda_codec *codec, hda_nid_t nid,
+			int direct, unsigned int verb,
+			unsigned int para)
+{
+	struct azx *chip = codec->bus->private_data;
+	if (chip->single_cmd)
+		return azx_single_send_cmd(codec, nid, direct, verb, para);
+	else
+		return azx_corb_send_cmd(codec, nid, direct, verb, para);
+}
+
+/* get a response */
+static unsigned int azx_get_response(struct hda_codec *codec)
+{
+	struct azx *chip = codec->bus->private_data;
+	if (chip->single_cmd)
+		return azx_single_get_response(codec);
+	else
+		return azx_rirb_get_response(codec);
+}
+
+
 /* reset codec link */
 static int azx_reset(struct azx *chip)
 {
@@ -900,13 +933,8 @@ static int __devinit azx_codec_create(st
 	bus_temp.private_data = chip;
 	bus_temp.modelname = model;
 	bus_temp.pci = chip->pci;
-	if (chip->single_cmd) {
-		bus_temp.ops.command = azx_single_send_cmd;
-		bus_temp.ops.get_response = azx_single_get_response;
-	} else {
-		bus_temp.ops.command = azx_send_cmd;
-		bus_temp.ops.get_response = azx_get_response;
-	}
+	bus_temp.ops.command = azx_send_cmd;
+	bus_temp.ops.get_response = azx_get_response;
 
 	if ((err = snd_hda_bus_new(chip->card, &bus_temp, &chip->bus)) < 0)
 		return err;
@@ -1308,8 +1336,7 @@ static int azx_suspend(struct pci_dev *p
 	for (i = 0; i < chip->pcm_devs; i++)
 		snd_pcm_suspend_all(chip->pcm[i]);
 	snd_hda_suspend(chip->bus, state);
-	if (! chip->single_cmd)
-		azx_free_cmd_io(chip);
+	azx_free_cmd_io(chip);
 	pci_disable_device(pci);
 	pci_save_state(pci);
 	return 0;
@@ -1347,8 +1374,7 @@ static int azx_free(struct azx *chip)
 		azx_int_clear(chip);
 
 		/* disable CORB/RIRB */
-		if (! chip->single_cmd)
-			azx_free_cmd_io(chip);
+		azx_free_cmd_io(chip);
 
 		/* disable position buffer */
 		azx_writel(chip, DPLBASE, 0);
