From: Tejun Heo <htejun@gmail.com>
Subject: fix atapi_packet_task vs. intr race
Patch-mainline: 
References: 

Interrupts from devices sharing the same IRQ could cause
ata_host_intr to finish commands being processed by atapi_packet_task
if the commands are using ATA_PROT_ATAPI_NODATA or ATA_PROT_ATAPI_DMA
protocol.  This is because libata interrupt handler is unaware that
interrupts are not expected during that period.  This patch adds
ATA_FLAG_NOINTR flag to tell the interrupt handler that we're not
expecting interrupts.

Acked-by: Jens Axboe <axboe@suse.de>
Signed-off-by: 

diff -urp /opt/kernel/linux-2.6.13/drivers/scsi/libata-core.c linux-2.6.13/drivers/scsi/libata-core.c
--- /opt/kernel/linux-2.6.13/drivers/scsi/libata-core.c	2005-09-06 11:43:44.000000000 +0200
+++ linux-2.6.13/drivers/scsi/libata-core.c	2005-09-06 11:46:31.000000000 +0200
@@ -3412,11 +3412,13 @@ int ata_qc_issue_prot(struct ata_queued_
 		break;
 
 	case ATA_PROT_ATAPI_NODATA:
+		ap->flags |= ATA_FLAG_NOINTR;
 		ata_tf_to_host_nolock(ap, &qc->tf);
 		queue_work(ata_wq, &ap->packet_task);
 		break;
 
 	case ATA_PROT_ATAPI_DMA:
+		ap->flags |= ATA_FLAG_NOINTR;
 		ap->ops->tf_load(ap, &qc->tf);	 /* load tf registers */
 		ap->ops->bmdma_setup(qc);	    /* set up bmdma */
 		queue_work(ata_wq, &ap->packet_task);
@@ -3770,7 +3772,8 @@ irqreturn_t ata_interrupt (int irq, void
 		struct ata_port *ap;
 
 		ap = host_set->ports[i];
-		if (ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+		if (ap &&
+		    !(ap->flags & (ATA_FLAG_PORT_DISABLED | ATA_FLAG_NOINTR))) {
 			struct ata_queued_cmd *qc;
 
 			qc = ata_qc_from_tag(ap, ap->active_tag);
@@ -3822,19 +3825,27 @@ static void atapi_packet_task(void *_dat
 	/* send SCSI cdb */
 	DPRINTK("send cdb\n");
 	assert(ap->cdb_len >= 12);
-	ata_data_xfer(ap, qc->cdb, ap->cdb_len, 1);
 
-	/* if we are DMA'ing, irq handler takes over from here */
-	if (qc->tf.protocol == ATA_PROT_ATAPI_DMA)
-		ap->ops->bmdma_start(qc);	    /* initiate bmdma */
-
-	/* non-data commands are also handled via irq */
-	else if (qc->tf.protocol == ATA_PROT_ATAPI_NODATA) {
-		/* do nothing */
-	}
+	if (qc->tf.protocol == ATA_PROT_ATAPI_DMA ||
+	    qc->tf.protocol == ATA_PROT_ATAPI_NODATA) {
+		unsigned long flags;
+
+		/* Once we're done issuing command and kicking bmdma,
+		 * irq handler takes over.  To not lose irq, we need
+		 * to clear NOINTR flag before sending cdb, but
+		 * interrupt handler shouldn't be invoked before we're
+		 * finished.  Hence, the following locking.
+		 */
+		spin_lock_irqsave(&ap->host_set->lock, flags);
+		ap->flags &= ~ATA_FLAG_NOINTR;
+		ata_data_xfer(ap, qc->cdb, ap->cdb_len, 1);
+		if (qc->tf.protocol == ATA_PROT_ATAPI_DMA)
+			ap->ops->bmdma_start(qc);	/* initiate bmdma */
+		spin_unlock_irqrestore(&ap->host_set->lock, flags);
+	} else {
+		ata_data_xfer(ap, qc->cdb, ap->cdb_len, 1);
 
-	/* PIO commands are handled by polling */
-	else {
+		/* PIO commands are handled by polling */
 		ap->pio_task_state = PIO_ST;
 		queue_work(ata_wq, &ap->pio_task);
 	}
diff -urp /opt/kernel/linux-2.6.13/drivers/scsi/sata_nv.c linux-2.6.13/drivers/scsi/sata_nv.c
--- /opt/kernel/linux-2.6.13/drivers/scsi/sata_nv.c	2005-09-06 11:43:44.000000000 +0200
+++ linux-2.6.13/drivers/scsi/sata_nv.c	2005-09-06 11:46:31.000000000 +0200
@@ -278,7 +278,8 @@ static irqreturn_t nv_interrupt (int irq
 		struct ata_port *ap;
 
 		ap = host_set->ports[i];
-		if (ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+		if (ap &&
+		    !(ap->flags & (ATA_FLAG_PORT_DISABLED | ATA_FLAG_NOINTR))) {
 			struct ata_queued_cmd *qc;
 
 			qc = ata_qc_from_tag(ap, ap->active_tag);
diff -urp /opt/kernel/linux-2.6.13/drivers/scsi/sata_promise.c linux-2.6.13/drivers/scsi/sata_promise.c
--- /opt/kernel/linux-2.6.13/drivers/scsi/sata_promise.c	2005-09-06 11:43:44.000000000 +0200
+++ linux-2.6.13/drivers/scsi/sata_promise.c	2005-09-06 11:46:31.000000000 +0200
@@ -445,7 +445,8 @@ static irqreturn_t pdc_interrupt (int ir
 		VPRINTK("port %u\n", i);
 		ap = host_set->ports[i];
 		tmp = mask & (1 << (i + 1));
-		if (tmp && ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+		if (tmp && ap &&
+		    !(ap->flags & (ATA_FLAG_PORT_DISABLED | ATA_FLAG_NOINTR))) {
 			struct ata_queued_cmd *qc;
 
 			qc = ata_qc_from_tag(ap, ap->active_tag);
diff -urp /opt/kernel/linux-2.6.13/drivers/scsi/sata_qstor.c linux-2.6.13/drivers/scsi/sata_qstor.c
--- /opt/kernel/linux-2.6.13/drivers/scsi/sata_qstor.c	2005-09-06 11:43:44.000000000 +0200
+++ linux-2.6.13/drivers/scsi/sata_qstor.c	2005-09-06 11:46:31.000000000 +0200
@@ -392,7 +392,8 @@ static inline unsigned int qs_intr_pkt(s
 			DPRINTK("SFF=%08x%08x: sCHAN=%u sHST=%d sDST=%02x\n",
 					sff1, sff0, port_no, sHST, sDST);
 			handled = 1;
-			if (ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+			if (ap && !(ap->flags &
+				    (ATA_FLAG_PORT_DISABLED|ATA_FLAG_NOINTR))) {
 				struct ata_queued_cmd *qc;
 				struct qs_port_priv *pp = ap->private_data;
 				if (!pp || pp->state != qs_state_pkt)
@@ -423,7 +424,8 @@ static inline unsigned int qs_intr_mmio(
 	for (port_no = 0; port_no < host_set->n_ports; ++port_no) {
 		struct ata_port *ap;
 		ap = host_set->ports[port_no];
-		if (ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+		if (ap &&
+		    !(ap->flags & (ATA_FLAG_PORT_DISABLED | ATA_FLAG_NOINTR))) {
 			struct ata_queued_cmd *qc;
 			struct qs_port_priv *pp = ap->private_data;
 			if (!pp || pp->state != qs_state_mmio)
diff -urp /opt/kernel/linux-2.6.13/drivers/scsi/sata_sx4.c linux-2.6.13/drivers/scsi/sata_sx4.c
--- /opt/kernel/linux-2.6.13/drivers/scsi/sata_sx4.c	2005-09-06 11:43:44.000000000 +0200
+++ linux-2.6.13/drivers/scsi/sata_sx4.c	2005-09-06 11:46:31.000000000 +0200
@@ -828,7 +828,8 @@ static irqreturn_t pdc20621_interrupt (i
 			ap = host_set->ports[port_no];
 		tmp = mask & (1 << i);
 		VPRINTK("seq %u, port_no %u, ap %p, tmp %x\n", i, port_no, ap, tmp);
-		if (tmp && ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+		if (tmp && ap &&
+		    !(ap->flags & (ATA_FLAG_PORT_DISABLED | ATA_FLAG_NOINTR))) {
 			struct ata_queued_cmd *qc;
 
 			qc = ata_qc_from_tag(ap, ap->active_tag);
diff -urp /opt/kernel/linux-2.6.13/drivers/scsi/sata_vsc.c linux-2.6.13/drivers/scsi/sata_vsc.c
--- /opt/kernel/linux-2.6.13/drivers/scsi/sata_vsc.c	2005-09-06 11:43:44.000000000 +0200
+++ linux-2.6.13/drivers/scsi/sata_vsc.c	2005-09-06 11:46:31.000000000 +0200
@@ -173,7 +173,8 @@ static irqreturn_t vsc_sata_interrupt (i
 			struct ata_port *ap;
 
 			ap = host_set->ports[i];
-			if (ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+			if (ap && !(ap->flags &
+				    (ATA_FLAG_PORT_DISABLED|ATA_FLAG_NOINTR))) {
 				struct ata_queued_cmd *qc;
 
 				qc = ata_qc_from_tag(ap, ap->active_tag);
diff -urp /opt/kernel/linux-2.6.13/include/linux/libata.h linux-2.6.13/include/linux/libata.h
--- /opt/kernel/linux-2.6.13/include/linux/libata.h	2005-09-06 11:44:53.000000000 +0200
+++ linux-2.6.13/include/linux/libata.h	2005-09-06 11:43:22.000000000 +0200
@@ -114,6 +114,8 @@ enum {
 	ATA_FLAG_SATA_RESET	= (1 << 7), /* use COMRESET */
 	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
 	ATA_FLAG_SUSPENDED	= (1 << 9), /* port is suspended */
+	ATA_FLAG_NOINTR		= (1 << 10),/* FIXME: Remove this once
+					     * proper HSM is in place. */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
