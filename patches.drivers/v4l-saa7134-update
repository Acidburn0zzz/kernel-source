Subject: [patch] saa7134 update
From: kraxel@suse.de
Patch-mainline: not yet

saa7134 driver update.

Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
Index: linux.merge/drivers/media/video/Kconfig
===================================================================
--- linux.merge.orig/drivers/media/video/Kconfig	2005-01-20 17:24:23.000000000 -0500
+++ linux.merge/drivers/media/video/Kconfig	2005-01-20 17:24:54.000000000 -0500
@@ -248,7 +248,9 @@ config VIDEO_SAA7134
 
 config VIDEO_SAA7134_DVB
 	tristate "DVB Support for saa7134 based TV cards"
-	depends on VIDEO_SAA7134 && DVB_CORE && BROKEN
+	depends on VIDEO_SAA7134 && DVB_CORE
+	select VIDEO_BUF_DVB
+	select DVB_MT352
 	---help---
 	  This adds support for DVB cards based on the
 	  Philips saa7134 chip.
Index: linux.merge/drivers/media/video/saa7134/Makefile
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/Makefile	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/Makefile	2005-01-20 17:24:54.000000000 -0500
@@ -8,3 +8,4 @@ obj-$(CONFIG_VIDEO_SAA7134_DVB) += saa71
 
 EXTRA_CFLAGS += -I$(src)/..
 EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/dvb-core
+EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/frontends
Index: linux.merge/drivers/media/video/saa7134/saa6752hs.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa6752hs.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa6752hs.c	2005-01-20 17:24:54.000000000 -0500
@@ -11,9 +11,14 @@
 #include <linux/types.h>
 #include <linux/videodev.h>
 #include <linux/init.h>
+#include <linux/crc32.h>
 
 #include <media/id.h>
-#include <media/saa6752hs.h>
+
+#define MPEG_VIDEO_TARGET_BITRATE_MAX  27000
+#define MPEG_VIDEO_MAX_BITRATE_MAX     27000
+#define MPEG_TOTAL_TARGET_BITRATE_MAX  27000
+#define MPEG_PID_MAX ((1 << 14) - 1)
 
 /* Addresses to scan */
 static unsigned short normal_i2c[] = {0x20, I2C_CLIENT_END};
@@ -27,6 +32,10 @@ MODULE_LICENSE("GPL");
 static struct i2c_driver driver;
 static struct i2c_client client_template;
 
+struct saa6752hs_state {
+	struct i2c_client             client;
+	struct v4l2_mpeg_compression  params;
+};
 
 enum saa6752hs_command {
 	SAA6752HS_COMMAND_RESET = 0,
@@ -40,7 +49,6 @@ enum saa6752hs_command {
 	SAA6752HS_COMMAND_MAX
 };
 
-
 /* ---------------------------------------------------------------------- */
 
 static u8 PAT[] = {
@@ -64,9 +72,9 @@ static u8 PAT[] = {
 
 	0x00, 0x01, // program_number(1)
 
-	0xe0, 0x10, // PMT PID(0x10)
+	0xe0, 0x00, // PMT PID
 
-	0x76, 0xf1, 0x44, 0xd1 // CRC32
+	0x00, 0x00, 0x00, 0x00 // CRC32
 };
 
 static u8 PMT[] = {
@@ -74,7 +82,7 @@ static u8 PMT[] = {
 	0x01, // table number for encoder
 
 	0x47, // sync
-	0x40, 0x10, // transport_error_indicator(0), payload_unit_start(1), transport_priority(0), pid(0x10)
+	0x40, 0x00, // transport_error_indicator(0), payload_unit_start(1), transport_priority(0), pid
 	0x10, // transport_scrambling_control(00), adaptation_field_control(01), continuity_counter(0)
 
 	0x00, // PSI pointer to start of table
@@ -88,28 +96,51 @@ static u8 PMT[] = {
 
 	0x00, 0x00, // section_number(0), last_section_number(0)
 
-	0xe1, 0x04, // PCR_PID (0x104)
+	0xe0, 0x00, // PCR_PID
 
 	0xf0, 0x00, // program_info_length(0)
 
-	0x02, 0xe1, 0x00, 0xf0, 0x00, // video stream type(2), pid(0x100)
-	0x04, 0xe1, 0x03, 0xf0, 0x00, // audio stream type(4), pid(0x103)
+	0x02, 0xe0, 0x00, 0xf0, 0x00, // video stream type(2), pid
+	0x04, 0xe0, 0x00, 0xf0, 0x00, // audio stream type(4), pid
 
-	0xa1, 0xca, 0x0f, 0x82 // CRC32
+	0x00, 0x00, 0x00, 0x00 // CRC32
 };
 
-static struct mpeg_params mpeg_params_template =
+static struct v4l2_mpeg_compression param_defaults =
 {
-	.bitrate_mode = MPEG_BITRATE_MODE_CBR,
-	.video_target_bitrate = 5000,
-	.audio_bitrate = MPEG_AUDIO_BITRATE_256,
-	.total_bitrate = 6000,
+	.st_type         = V4L2_MPEG_TS_2,
+	.st_bitrate      = {
+		.mode    = V4L2_BITRATE_CBR,
+		.target  = 7000,
+	},
+
+	.ts_pid_pmt      = 16,
+	.ts_pid_video    = 260,
+	.ts_pid_audio    = 256,
+	.ts_pid_pcr      = 259,
+
+	.vi_type         = V4L2_MPEG_VI_2,
+	.vi_aspect_ratio = V4L2_MPEG_ASPECT_4_3,
+	.vi_bitrate      = {
+		.mode    = V4L2_BITRATE_VBR,
+		.target  = 4000,
+		.max     = 6000,
+	},
+
+	.au_type         = V4L2_MPEG_AU_2_II,
+	.au_bitrate      = {
+		.mode    = V4L2_BITRATE_CBR,
+		.target  = 256,
+	},
+
+#if 0
+	/* FIXME: size? via S_FMT? */
+	.video_format = MPEG_VIDEO_FORMAT_D1,
+#endif
 };
 
-
 /* ---------------------------------------------------------------------- */
 
-
 static int saa6752hs_chip_command(struct i2c_client* client,
 				  enum saa6752hs_command command)
 {
@@ -124,7 +155,7 @@ static int saa6752hs_chip_command(struct
 		break;
 
 	case SAA6752HS_COMMAND_STOP:
-		  	buf[0] = 0x03;
+	  	buf[0] = 0x03;
 		break;
 
 	case SAA6752HS_COMMAND_START:
@@ -180,74 +211,117 @@ static int saa6752hs_chip_command(struct
 
 
 static int saa6752hs_set_bitrate(struct i2c_client* client,
-				 struct mpeg_params* params)
+				 struct v4l2_mpeg_compression* params)
 {
   	u8 buf[3];
 
 	// set the bitrate mode
 	buf[0] = 0x71;
-	buf[1] = params->bitrate_mode;
+	buf[1] = (params->vi_bitrate.mode == V4L2_BITRATE_VBR) ? 0 : 1;
 	i2c_master_send(client, buf, 2);
 
 	// set the video bitrate
-	if (params->bitrate_mode == MPEG_BITRATE_MODE_VBR) {
+	if (params->vi_bitrate.mode == V4L2_BITRATE_VBR) {
 		// set the target bitrate
 		buf[0] = 0x80;
-	    	buf[1] = params->video_target_bitrate >> 8;
-	  	buf[2] = params->video_target_bitrate & 0xff;
+	    	buf[1] = params->vi_bitrate.target >> 8;
+	  	buf[2] = params->vi_bitrate.target & 0xff;
 		i2c_master_send(client, buf, 3);
 
 		// set the max bitrate
 		buf[0] = 0x81;
-	    	buf[1] = params->video_max_bitrate >> 8;
-	  	buf[2] = params->video_max_bitrate & 0xff;
+	    	buf[1] = params->vi_bitrate.max >> 8;
+	  	buf[2] = params->vi_bitrate.max & 0xff;
 		i2c_master_send(client, buf, 3);
 	} else {
 		// set the target bitrate (no max bitrate for CBR)
   		buf[0] = 0x81;
-	    	buf[1] = params->video_target_bitrate >> 8;
-	  	buf[2] = params->video_target_bitrate & 0xff;
+	    	buf[1] = params->vi_bitrate.target >> 8;
+	  	buf[2] = params->vi_bitrate.target & 0xff;
 		i2c_master_send(client, buf, 3);
 	}
 
 	// set the audio bitrate
  	buf[0] = 0x94;
-  	buf[1] = params->audio_bitrate;
+	buf[1] = (256 == params->au_bitrate.target) ? 0 : 1;
 	i2c_master_send(client, buf, 2);
 
 	// set the total bitrate
 	buf[0] = 0xb1;
-  	buf[1] = params->total_bitrate >> 8;
-  	buf[2] = params->total_bitrate & 0xff;
+  	buf[1] = params->st_bitrate.target >> 8;
+  	buf[2] = params->st_bitrate.target & 0xff;
 	i2c_master_send(client, buf, 3);
 
+	// return success
 	return 0;
 }
 
 
-static int saa6752hs_init(struct i2c_client* client, struct mpeg_params* params)
+static void saa6752hs_set_params(struct i2c_client* client,
+				 struct v4l2_mpeg_compression* params)
 {
-	unsigned char buf[3];
-	void *data;
+	struct saa6752hs_state *h = i2c_get_clientdata(client);
 
-	// check the bitrate parameters first
-	if (params != NULL) {
-		if (params->bitrate_mode >= MPEG_BITRATE_MODE_MAX)
-			return -EINVAL;
-		if (params->video_target_bitrate >= MPEG_VIDEO_TARGET_BITRATE_MAX)
-			return -EINVAL;
-  		if (params->video_max_bitrate >= MPEG_VIDEO_MAX_BITRATE_MAX)
-			return -EINVAL;
-		if (params->audio_bitrate >= MPEG_AUDIO_BITRATE_MAX)
-			return -EINVAL;
-		if (params->total_bitrate >= MPEG_TOTAL_BITRATE_MAX)
-        		return -EINVAL;
-		if (params->bitrate_mode         == MPEG_BITRATE_MODE_MAX &&
-		    params->video_target_bitrate <= params->video_max_bitrate)
-			return -EINVAL;
-	}
+	/* check PIDs */
+	if (params->ts_pid_pmt <= MPEG_PID_MAX)
+		h->params.ts_pid_pmt = params->ts_pid_pmt;
+	if (params->ts_pid_pcr <= MPEG_PID_MAX)
+		h->params.ts_pid_pcr = params->ts_pid_pcr;
+	if (params->ts_pid_video <= MPEG_PID_MAX)
+		h->params.ts_pid_video = params->ts_pid_video;
+	if (params->ts_pid_audio <= MPEG_PID_MAX)
+		h->params.ts_pid_audio = params->ts_pid_audio;
+
+	/* check bitrate parameters */
+	if ((params->vi_bitrate.mode == V4L2_BITRATE_CBR) ||
+	    (params->vi_bitrate.mode == V4L2_BITRATE_VBR))
+		h->params.vi_bitrate.mode = params->vi_bitrate.mode;
+	if (params->vi_bitrate.mode != V4L2_BITRATE_NONE)
+		h->params.st_bitrate.target = params->st_bitrate.target;
+	if (params->vi_bitrate.mode != V4L2_BITRATE_NONE)
+		h->params.vi_bitrate.target = params->vi_bitrate.target;
+	if (params->vi_bitrate.mode == V4L2_BITRATE_VBR)
+		h->params.vi_bitrate.max = params->vi_bitrate.max;
+	if (params->au_bitrate.mode != V4L2_BITRATE_NONE)
+		h->params.au_bitrate.target = params->au_bitrate.target;
+
+	/* aspect ratio */
+	if (params->vi_aspect_ratio == V4L2_MPEG_ASPECT_4_3 ||
+	    params->vi_aspect_ratio == V4L2_MPEG_ASPECT_16_9)
+		h->params.vi_aspect_ratio = params->vi_aspect_ratio;
+
+	/* range checks */
+	if (h->params.st_bitrate.target > MPEG_TOTAL_TARGET_BITRATE_MAX)
+		h->params.st_bitrate.target = MPEG_TOTAL_TARGET_BITRATE_MAX;
+	if (h->params.vi_bitrate.target > MPEG_VIDEO_TARGET_BITRATE_MAX)
+		h->params.vi_bitrate.target = MPEG_VIDEO_TARGET_BITRATE_MAX;
+	if (h->params.vi_bitrate.max > MPEG_VIDEO_MAX_BITRATE_MAX)
+		h->params.vi_bitrate.max = MPEG_VIDEO_MAX_BITRATE_MAX;
+	if (h->params.au_bitrate.target <= 256)
+		h->params.au_bitrate.target = 256;
+	else
+		h->params.au_bitrate.target = 384;
+}
 
-    	// Set GOP structure {3, 13}
+static int saa6752hs_init(struct i2c_client* client)
+{
+	unsigned char buf[9], buf2[4];
+	struct saa6752hs_state *h;
+	u32 crc;
+	unsigned char localPAT[256];
+	unsigned char localPMT[256];
+
+	h = i2c_get_clientdata(client);
+
+	// Set video format - must be done first as it resets other settings
+	buf[0] = 0x41;
+	buf[1] = 0 /* MPEG_VIDEO_FORMAT_D1 */;
+	i2c_master_send(client, buf, 2);
+
+        // set bitrate
+        saa6752hs_set_bitrate(client, &h->params);
+
+	// Set GOP structure {3, 13}
 	buf[0] = 0x72;
 	buf[1] = 0x03;
 	buf[2] = 0x0D;
@@ -273,25 +347,53 @@ static int saa6752hs_init(struct i2c_cli
 	buf[1] = 0x05;
 	i2c_master_send(client,buf,2);
 
-    	// Set Audio PID {0x103}
+	/* compute PAT */
+	memcpy(localPAT, PAT, sizeof(PAT));
+	localPAT[17] = 0xe0 | ((h->params.ts_pid_pmt >> 8) & 0x0f);
+	localPAT[18] = h->params.ts_pid_pmt & 0xff;
+	crc = crc32_be(~0, &localPAT[7], sizeof(PAT) - 7 - 4);
+	localPAT[sizeof(PAT) - 4] = (crc >> 24) & 0xFF;
+	localPAT[sizeof(PAT) - 3] = (crc >> 16) & 0xFF;
+	localPAT[sizeof(PAT) - 2] = (crc >> 8) & 0xFF;
+	localPAT[sizeof(PAT) - 1] = crc & 0xFF;
+
+	/* compute PMT */
+      	memcpy(localPMT, PMT, sizeof(PMT));
+   	localPMT[3] = 0x40 | ((h->params.ts_pid_pmt >> 8) & 0x0f);
+   	localPMT[4] = h->params.ts_pid_pmt & 0xff;
+	localPMT[15] = 0xE0 | ((h->params.ts_pid_pcr >> 8) & 0x0F);
+	localPMT[16] = h->params.ts_pid_pcr & 0xFF;
+	localPMT[20] = 0xE0 | ((h->params.ts_pid_video >> 8) & 0x0F);
+	localPMT[21] = h->params.ts_pid_video & 0xFF;
+	localPMT[25] = 0xE0 | ((h->params.ts_pid_audio >> 8) & 0x0F);
+	localPMT[26] = h->params.ts_pid_audio & 0xFF;
+	crc = crc32_be(~0, &localPMT[7], sizeof(PMT) - 7 - 4);
+	localPMT[sizeof(PMT) - 4] = (crc >> 24) & 0xFF;
+	localPMT[sizeof(PMT) - 3] = (crc >> 16) & 0xFF;
+	localPMT[sizeof(PMT) - 2] = (crc >> 8) & 0xFF;
+	localPMT[sizeof(PMT) - 1] = crc & 0xFF;
+
+    	// Set Audio PID
 	buf[0] = 0xC1;
-	buf[1] = 0x01;
-	buf[2] = 0x03;
+	buf[1] = (h->params.ts_pid_audio >> 8) & 0xFF;
+	buf[2] = h->params.ts_pid_audio & 0xFF;
 	i2c_master_send(client,buf,3);
 
-        // setup bitrate settings
-	data = i2c_get_clientdata(client);
-	if (params) {
-		saa6752hs_set_bitrate(client, params);
-		memcpy(data, params, sizeof(struct mpeg_params));
-	} else {
-		// parameters were not supplied. use the previous set
-   		saa6752hs_set_bitrate(client, (struct mpeg_params*) data);
-	}
+	// Set Video PID
+	buf[0] = 0xC0;
+	buf[1] = (h->params.ts_pid_video >> 8) & 0xFF;
+	buf[2] = h->params.ts_pid_video & 0xFF;
+	i2c_master_send(client,buf,3);
+
+ 	// Set PCR PID
+	buf[0] = 0xC4;
+	buf[1] = (h->params.ts_pid_pcr >> 8) & 0xFF;
+	buf[2] = h->params.ts_pid_pcr & 0xFF;
+	i2c_master_send(client,buf,3);
 
 	// Send SI tables
-  	i2c_master_send(client,PAT,sizeof(PAT));
-  	i2c_master_send(client,PMT,sizeof(PMT));
+	i2c_master_send(client,localPAT,sizeof(PAT));
+	i2c_master_send(client,localPMT,sizeof(PMT));
 
 	// mute then unmute audio. This removes buzzing artefacts
 	buf[0] = 0xa4;
@@ -303,31 +405,56 @@ static int saa6752hs_init(struct i2c_cli
 	// start it going
 	saa6752hs_chip_command(client, SAA6752HS_COMMAND_START);
 
+	// readout current state
+	buf[0] = 0xE1;
+	buf[1] = 0xA7;
+	buf[2] = 0xFE;
+	buf[3] = 0x82;
+	buf[4] = 0xB0;
+	i2c_master_send(client, buf, 5);
+	i2c_master_recv(client, buf2, 4);
+
+	// change aspect ratio
+	buf[0] = 0xE0;
+	buf[1] = 0xA7;
+	buf[2] = 0xFE;
+	buf[3] = 0x82;
+	buf[4] = 0xB0;
+	buf[5] = buf2[0];
+	switch(h->params.vi_aspect_ratio) {
+	case V4L2_MPEG_ASPECT_16_9:
+		buf[6] = buf2[1] | 0x40;
+		break;
+	case V4L2_MPEG_ASPECT_4_3:
+	default:
+		buf[6] = buf2[1] & 0xBF;
+		break;
+		break;
+	}
+	buf[7] = buf2[2];
+	buf[8] = buf2[3];
+	i2c_master_send(client, buf, 9);
+
+   	// return success
 	return 0;
 }
 
 static int saa6752hs_attach(struct i2c_adapter *adap, int addr, int kind)
 {
-	struct i2c_client *client;
-	struct mpeg_params* params;
-
-        client_template.adapter = adap;
-        client_template.addr = addr;
+	struct saa6752hs_state *h;
 
         printk("saa6752hs: chip found @ 0x%x\n", addr<<1);
 
-        if (NULL == (client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL)))
+        if (NULL == (h = kmalloc(sizeof(*h), GFP_KERNEL)))
                 return -ENOMEM;
-        memcpy(client,&client_template,sizeof(struct i2c_client));
-	strlcpy(client->name, "saa6752hs", sizeof(client->name));
-
-	if (NULL == (params = kmalloc(sizeof(struct mpeg_params), GFP_KERNEL)))
-		return -ENOMEM;
-	memcpy(params,&mpeg_params_template,sizeof(struct mpeg_params));
-	i2c_set_clientdata(client, params);
-
-        i2c_attach_client(client);
+	memset(h,0,sizeof(*h));
+	h->client = client_template;
+	h->params = param_defaults;
+	h->client.adapter = adap;
+	h->client.addr = addr;
 
+	i2c_set_clientdata(&h->client, h);
+        i2c_attach_client(&h->client);
 	return 0;
 }
 
@@ -340,30 +467,39 @@ static int saa6752hs_probe(struct i2c_ad
 
 static int saa6752hs_detach(struct i2c_client *client)
 {
-	void *data;
+	struct saa6752hs_state *h;
 
-	data = i2c_get_clientdata(client);
+	h = i2c_get_clientdata(client);
 	i2c_detach_client(client);
-	kfree(data);
-	kfree(client);
+	kfree(h);
 	return 0;
 }
 
 static int
 saa6752hs_command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
-	struct mpeg_params* init_arg = arg;
+	struct saa6752hs_state *h = i2c_get_clientdata(client);
+	struct v4l2_mpeg_compression *params = arg;
+	int err = 0;
 
         switch (cmd) {
-	case MPEG_SETPARAMS:
-   		return saa6752hs_init(client, init_arg);
-
+	case VIDIOC_S_MPEGCOMP:
+		if (NULL == params) {
+			/* apply settings and start encoder */
+			saa6752hs_init(client);
+			break;
+		}
+		saa6752hs_set_params(client, params);
+		/* fall through */
+	case VIDIOC_G_MPEGCOMP:
+		*params = h->params;
+		break;
 	default:
 		/* nothing */
 		break;
 	}
 
-	return 0;
+	return err;
 }
 
 /* ----------------------------------------------------------------------- */
@@ -380,7 +516,7 @@ static struct i2c_driver driver = {
 
 static struct i2c_client client_template =
 {
-	I2C_DEVNAME("(saa6752hs unset)"),
+	I2C_DEVNAME("saa6752hs"),
 	.flags      = I2C_CLIENT_ALLOW_USE,
         .driver     = &driver,
 };
Index: linux.merge/drivers/media/video/saa7134/saa7134-cards.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-cards.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-cards.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,6 @@
+
 /*
- * $Id: saa7134-cards.c,v 1.35 2004/11/07 14:44:59 kraxel Exp $
+ * $Id: saa7134-cards.c,v 1.48 2005/01/13 17:22:33 kraxel Exp $
  *
  * device driver for philips saa7134 based TV cards
  * card-specific stuff.
@@ -444,11 +445,11 @@ struct saa7134_board saa7134_boards[] = 
 		},{
 			.name   = name_comp1,
 			.vmux   = 0,
-			.amux   = LINE2,
+			.amux   = LINE1,
 		},{
 			.name   = name_svideo,
 			.vmux   = 8,
-			.amux   = LINE2,
+			.amux   = LINE1,
 		}},
 		.radio = {
 			.name   = name_radio,
@@ -749,7 +750,7 @@ struct saa7134_board saa7134_boards[] = 
 		},{
 			.name = name_tv,
 			.vmux = 3,
-			.amux = LINE2,
+			.amux = TV,
 			.tv   = 1,
 		}},
 		.mpeg      = SAA7134_MPEG_EMPRESS,
@@ -828,6 +829,10 @@ struct saa7134_board saa7134_boards[] = 
 			.name = name_radio,
 			.amux = LINE2,
 		},
+		.mute = {
+			.name = name_mute,
+                        .amux = LINE1,
+		},
 	},
 	[SAA7134_BOARD_MANLI_MTV001] = {
 		/* Ognjen Nastic <ognjen@logosoft.ba> UNTESTED */
@@ -975,6 +980,9 @@ struct saa7134_board saa7134_boards[] = 
 		.inputs         = {{
 			.name = name_comp1,
 			.vmux = 3,
+		},{
+			.name = name_svideo,
+			.vmux = 8,
 		}},
 	},
         [SAA7134_BOARD_NOVAC_PRIMETV7133] = {
@@ -995,11 +1003,12 @@ struct saa7134_board saa7134_boards[] = 
                         .vmux = 8,
                 }},
         },
-	[SAA7134_BOARD_AVERMEDIA_305] = {
-		.name           = "AverMedia 305",
+	[SAA7134_BOARD_AVERMEDIA_STUDIO_305] = {
+		.name           = "AverMedia AverTV Studio 305",
 		.audio_clock    = 0x00187de7,
-		.tuner_type     = TUNER_PHILIPS_FM1216ME_MK3,
+		.tuner_type     = TUNER_PHILIPS_FM1256_IH3,
 		.tda9887_conf   = TDA9887_PRESENT,
+		.gpiomask = 0x3,
 		.inputs         = {{
 			.name = name_tv,
 			.vmux = 1,
@@ -1104,23 +1113,23 @@ struct saa7134_board saa7134_boards[] = 
                         .name = name_svideo,
                         .vmux = 8,
                         .amux = LINE1,
-			.gpio = 0x00080
+			.gpio = 0x00080,
                 },{
                         .name = name_comp1,
                         .vmux = 3,
                         .amux = LINE1,
-			.gpio = 0x00080
+			.gpio = 0x00080,
                 },{
                         .name = name_tv,
                         .vmux = 1,
-                        .amux = LINE2,
+                        .amux = LINE2_LEFT,
                         .tv   = 1,
-			.gpio = 0x00080
+			.gpio = 0x00080,
                 }},
 		.radio = {
-			 .name = name_radio,
-			 .amux = LINE2,
-			.gpio = 0x80000
+			.name = name_radio,
+			.amux = LINE2,
+			.gpio = 0x80000,
 		 },
 		.mute = {
 			.name = name_mute,
@@ -1129,21 +1138,20 @@ struct saa7134_board saa7134_boards[] = 
 		},
         },
         [SAA7134_BOARD_SABRENT_SBTTVFM] = {
-		/* Michael Rodriguez-Torrent */
+		/* Michael Rodriguez-Torrent <mrtorrent@asu.edu> */
                 .name           = "Sabrent SBT-TVFM (saa7130)",
                 .audio_clock    = 0x00187de7,
                 .tuner_type     = TUNER_PHILIPS_NTSC_M,
-  		.tda9887_conf   = TDA9887_PRESENT,
                 .inputs         = {{
+			.name = name_comp1,
+			.vmux = 1,
+			.amux = LINE2,
+		},{
                         .name = name_tv,
                         .vmux = 3,
                         .amux = LINE2,
                         .tv   = 1,
                 },{
-                        .name = name_comp1,
-                        .vmux = 1,
-                        .amux = LINE2,
-                },{
                         .name = name_svideo,
                         .vmux = 8,
                         .amux = LINE2,
@@ -1208,32 +1216,41 @@ struct saa7134_board saa7134_boards[] = 
 		 }
 	},
         [SAA7134_BOARD_AVERMEDIA_307] = {
-		/* Nickolay V. Shmyrev <nshmyrev@yandex.ru> */
+		/*
+		Nickolay V. Shmyrev <nshmyrev@yandex.ru>
+		Lots of thanks to Andrey Zolotarev <zolotarev_andrey@mail.ru>
+		*/
 		.name           = "Avermedia AVerTV Studio 307",
 		.audio_clock    = 0x00187de7,
-		.tuner_type     = TUNER_PHILIPS_FM1216ME_MK3,
+		.tuner_type     = TUNER_PHILIPS_FM1256_IH3,
 		.tda9887_conf   = TDA9887_PRESENT,
+		.gpiomask       = 0x03,
 		.inputs         = {{
 			.name = name_tv,
 			.vmux = 1,
 			.amux = TV,
 			.tv   = 1,
+			.gpio = 0x00,
 		},{
 			.name = name_comp1,
 			.vmux = 0,
 			.amux = LINE2,
+			.gpio = 0x00,
 		},{
 			.name = name_comp2,
 			.vmux = 3,
 			.amux = LINE2,
+			.gpio = 0x00,
 		},{
 			.name = name_svideo,
 			.vmux = 8,
 			.amux = LINE2,
+			.gpio = 0x00,
 		}},
 		.radio = {
 			.name = name_radio,
-			.amux = TV,
+			.amux = LINE1,
+			.gpio = 0x01,
 		},
         },
 	[SAA7134_BOARD_AVERMEDIA_CARDBUS] = {
@@ -1263,7 +1280,8 @@ struct saa7134_board saa7134_boards[] = 
 	[SAA7134_BOARD_CINERGY400_CARDBUS] = {
 		.name           = "Terratec Cinergy 400 mobile",
 		.audio_clock    = 0x187de7,
-		.tuner_type     = UNSET /* not supported yet :/ */,
+		.tuner_type     = TUNER_ALPS_TSBE5_PAL,
+  		.tda9887_conf   = TDA9887_PRESENT,
 		.inputs         = {{
        			.name = name_tv,
 			.vmux = 5,
@@ -1278,6 +1296,150 @@ struct saa7134_board saa7134_boards[] = 
                         .amux = LINE1,
 		}},
 	},
+	[SAA7134_BOARD_CINERGY600_MK3] = {
+                .name           = "Terratec Cinergy 600 TV MK3",
+                .audio_clock    = 0x00200000,
+		.tuner_type	= TUNER_PHILIPS_FM1216ME_MK3,
+  		.tda9887_conf   = TDA9887_PRESENT,
+                .inputs         = {{
+                        .name = name_tv,
+                        .vmux = 1,
+                        .amux = TV,
+                        .tv   = 1,
+                },{
+                        .name = name_comp1,
+                        .vmux = 4,
+                        .amux = LINE1,
+                },{
+                        .name = name_svideo,
+                        .vmux = 8,
+                        .amux = LINE1,
+                },{
+                        .name = name_comp2, // CVideo over SVideo Connector
+                        .vmux = 0,
+                        .amux = LINE1,
+                }},
+		.radio = {
+			.name = name_radio,
+			.amux = LINE2,
+               },
+        },
+ 	[SAA7134_BOARD_VIDEOMATE_GOLD_PLUS] = {
+ 		/* Dylan Walkden <dylan_walkden@hotmail.com> */
+ 		.name		= "Compro VideoMate Gold+ Pal",
+ 		.audio_clock	= 0x00187de7,
+ 		.tuner_type	= TUNER_PHILIPS_PAL,
+ 		.gpiomask	= 0x1ce780,
+ 		.inputs		= {{
+ 			.name = name_svideo,
+ 			.vmux = 0,		// CVideo over SVideo Connector - ok?
+ 			.amux = LINE1,
+ 			.gpio = 0x008080,
+ 		},{
+ 			.name = name_comp1,
+ 			.vmux = 3,
+ 			.amux = LINE1,
+ 			.gpio = 0x008080,
+ 		},{
+ 			.name = name_tv,
+ 			.vmux = 1,
+ 			.amux = TV,
+ 			.tv   = 1,
+ 			.gpio = 0x008080,
+ 		}},
+ 		.radio = {
+ 			.name = name_radio,
+ 			.amux = LINE2,
+ 			.gpio = 0x80000,
+ 		},
+ 		.mute = {
+ 			.name = name_mute,
+ 			.amux = LINE2,
+ 			.gpio = 0x0c8000,
+ 		},
+ 	},
+	[SAA7134_BOARD_PINNACLE_300I_DVBT_PAL] = {
+                .name           = "Pinnacle PCTV 300i DVB-T + PAL",
+                .audio_clock    = 0x00187de7,
+                .tuner_type     = TUNER_MT2032,
+                .tda9887_conf   = TDA9887_PRESENT | TDA9887_INTERCARRIER,
+		.mpeg           = SAA7134_MPEG_DVB,
+                .inputs         = {{
+                        .name = name_tv,
+                        .vmux = 3,
+                        .amux = TV,
+                        .tv   = 1,
+                },{
+                        .name = name_comp1,
+                        .vmux = 0,
+                        .amux = LINE2,
+                },{
+                        .name = name_comp2,
+                        .vmux = 1,
+                        .amux = LINE2,
+                },{
+                        .name = name_svideo,
+                        .vmux = 8,
+                        .amux = LINE2,
+                }},
+        },
+	[SAA7134_BOARD_PROVIDEO_PV952] = {
+		/* andreas.kretschmer@web.de */
+		.name		= "ProVideo PV952",
+		.audio_clock	= 0x00187de7,
+		.tuner_type	= TUNER_PHILIPS_FM1216ME_MK3,
+		.tda9887_conf   = TDA9887_PRESENT,
+		.inputs         = {{
+			.name = name_comp1,
+			.vmux = 0,
+			.amux = LINE1,
+		},{
+			.name = name_tv,
+			.vmux = 1,
+			.amux = TV,
+			.tv   = 1,
+		},{
+			.name = name_tv_mono,
+			.vmux = 1,
+			.amux = LINE2,
+			.tv   = 1,
+		}},
+		.radio = {
+			.name = name_radio,
+			.amux = LINE2,
+		},
+	},
+	[SAA7134_BOARD_AVERMEDIA_305] = {
+		/* much like the "studio" version but without radio
+		 * and another tuner (sirspiritus@yandex.ru) */
+		.name           = "AverMedia AverTV/305",
+		.audio_clock    = 0x00187de7,
+		.tuner_type     = TUNER_PHILIPS_FQ1216ME,
+		.tda9887_conf   = TDA9887_PRESENT,
+		.gpiomask = 0x3,
+		.inputs         = {{
+			.name = name_tv,
+			.vmux = 1,
+			.amux = LINE2,
+			.tv   = 1,
+		},{
+			.name = name_comp1,
+			.vmux = 0,
+			.amux = LINE2,
+		},{
+			.name = name_comp2,
+			.vmux = 3,
+			.amux = LINE2,
+		},{
+			.name = name_svideo,
+			.vmux = 8,
+			.amux = LINE2,
+		}},
+		.mute = {
+			 .name = name_mute,
+			 .amux = LINE1,
+		},
+	},
 };
 const unsigned int saa7134_bcount = ARRAY_SIZE(saa7134_boards);
 
@@ -1322,6 +1484,12 @@ struct pci_device_id saa7134_pci_tbl[] =
                 .subdevice    = 0x1143,
                 .driver_data  = SAA7134_BOARD_CINERGY600,
         },{
+                .vendor       = PCI_VENDOR_ID_PHILIPS,
+                .device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
+                .subvendor    = 0x153B,
+                .subdevice    = 0x1158,
+                .driver_data  = SAA7134_BOARD_CINERGY600_MK3,
+        },{
 		.vendor       = PCI_VENDOR_ID_PHILIPS,
 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7133,
 		.subvendor    = 0x153b,
@@ -1452,6 +1620,12 @@ struct pci_device_id saa7134_pci_tbl[] =
 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7130,
                 .subvendor    = 0x1461, /* Avermedia Technologies Inc */
                 .subdevice    = 0x2115,
+		.driver_data  = SAA7134_BOARD_AVERMEDIA_STUDIO_305,
+	},{
+		.vendor       = PCI_VENDOR_ID_PHILIPS,
+		.device       = PCI_DEVICE_ID_PHILIPS_SAA7130,
+                .subvendor    = 0x1461, /* Avermedia Technologies Inc */
+                .subdevice    = 0x2108,
 		.driver_data  = SAA7134_BOARD_AVERMEDIA_305,
 	},{
 		.vendor       = PCI_VENDOR_ID_PHILIPS,
@@ -1483,8 +1657,8 @@ struct pci_device_id saa7134_pci_tbl[] =
                 .vendor       = PCI_VENDOR_ID_PHILIPS,
                 .device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
                 .subvendor    = 0x11bd,
-                .subdevice    = 0x002d, /* 300i DVB-T + PAL */
-                .driver_data  = SAA7134_BOARD_PINNACLE_PCTV_STEREO,
+                .subdevice    = 0x002d,
+                .driver_data  = SAA7134_BOARD_PINNACLE_300I_DVBT_PAL,
         },{
                 .vendor       = PCI_VENDOR_ID_PHILIPS,
                 .device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
@@ -1509,20 +1683,36 @@ struct pci_device_id saa7134_pci_tbl[] =
 		.subvendor    = 0x153B,
 		.subdevice    = 0x1152,
 		.driver_data  = SAA7134_BOARD_CINERGY200,
-
  	},{
 		.vendor       = PCI_VENDOR_ID_PHILIPS,
 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7130,
                 .subvendor    = 0x185b,
                 .subdevice    = 0xc100,
 		.driver_data  = SAA7134_BOARD_VIDEOMATE_TV_PVR,
-
  	},{
 		.vendor       = PCI_VENDOR_ID_PHILIPS,
+		.device       = PCI_DEVICE_ID_PHILIPS_SAA7130,
+                .subvendor    = 0x1131,
+                .subdevice    = 0,
+		.driver_data  = SAA7134_BOARD_SABRENT_SBTTVFM,
+	},{
+		.vendor       = PCI_VENDOR_ID_PHILIPS,
 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
-               .subvendor    = 0x1461, /* Avermedia Technologies Inc */
-               .subdevice    = 0x9715,
+		.subvendor    = 0x1461, /* Avermedia Technologies Inc */
+		.subdevice    = 0x9715,
 		.driver_data  = SAA7134_BOARD_AVERMEDIA_307,
+	},{
+		.vendor       = PCI_VENDOR_ID_PHILIPS,
+		.device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
+		.subvendor    = 0x185b,
+		.subdevice    = 0xc200,
+		.driver_data  = SAA7134_BOARD_VIDEOMATE_GOLD_PLUS,
+        },{
+		.vendor       = PCI_VENDOR_ID_PHILIPS,
+		.device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
+		.subvendor    = 0x1540,
+		.subdevice    = 0x9524,
+		.driver_data  = SAA7134_BOARD_PROVIDEO_PV952,
 
  	},{
 		/* --- boards without eeprom + subsystem ID --- */
@@ -1637,10 +1827,15 @@ int saa7134_board_init1(struct saa7134_d
 		break;
 	case SAA7134_BOARD_CINERGY400:
 	case SAA7134_BOARD_CINERGY600:
+	case SAA7134_BOARD_CINERGY600_MK3:
 	case SAA7134_BOARD_ECS_TVP3XP:
 	case SAA7134_BOARD_ECS_TVP3XP_4CB5:
 	case SAA7134_BOARD_MD2819:
+	case SAA7134_BOARD_AVERMEDIA_STUDIO_305:
+	case SAA7134_BOARD_AVERMEDIA_305:
 	case SAA7134_BOARD_AVERMEDIA_307:
+//	case SAA7134_BOARD_SABRENT_SBTTVFM:  /* not finished yet */
+	case SAA7134_BOARD_VIDEOMATE_TV_PVR:
 		dev->has_remote = 1;
 		break;
 	case SAA7134_BOARD_AVACSSMARTTV:
@@ -1656,8 +1851,13 @@ int saa7134_board_init1(struct saa7134_d
 		/* power-up tuner chip */
 		saa_andorl(SAA7134_GPIO_GPMODE0 >> 2,   0x00040000, 0x00040000);
 		saa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x00040000, 0x00000000);
+		msleep(1);
 		break;
 	}
+	if (dev->has_remote)
+		dev->irq2_mask |= (SAA7134_IRQ2_INTE_GPIO18  |
+				   SAA7134_IRQ2_INTE_GPIO18A |
+				   SAA7134_IRQ2_INTE_GPIO16  );
 	return 0;
 }
 
@@ -1676,6 +1876,7 @@ int saa7134_board_init2(struct saa7134_d
 			: SAA7134_BOARD_BMK_MPEX_TUNER;
 		if (board == dev->board)
 			break;
+		dev->board = board;
 		printk("%s: board type fixup: %s\n", dev->name,
 		       saa7134_boards[dev->board].name);
 		dev->tuner_type = saa7134_boards[dev->board].tuner_type;
Index: linux.merge/drivers/media/video/saa7134/saa7134-core.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-core.c	2005-01-20 17:24:49.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-core.c	2005-01-20 17:24:55.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-core.c,v 1.15 2004/11/07 14:44:59 kraxel Exp $
+ * $Id: saa7134-core.c,v 1.23 2004/12/17 14:18:49 kraxel Exp $
  *
  * device driver for philips saa7134 based TV cards
  * driver core
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/kmod.h>
@@ -87,7 +88,7 @@ MODULE_PARM_DESC(card,     "card type");
 static DECLARE_MUTEX(devlist_lock);
 LIST_HEAD(saa7134_devlist);
 static LIST_HEAD(mops_list);
-unsigned int saa7134_devcount;
+static unsigned int saa7134_devcount;
 
 #define dprintk(fmt, arg...)	if (core_debug) \
 	printk(KERN_DEBUG "%s/core: " fmt, dev->name , ## arg)
@@ -619,7 +620,7 @@ static irqreturn_t saa7134_irq(int irq, 
 			dump_statusregs(dev);
 #endif
 
-		if (report & SAA7134_IRQ_REPORT_INTL)
+		if (report & SAA7134_IRQ_REPORT_RDCAP /* _INTL */)
 			saa7134_irq_video_intl(dev);
 
 		if ((report & SAA7134_IRQ_REPORT_DONE_RA0) &&
@@ -641,8 +642,8 @@ static irqreturn_t saa7134_irq(int irq, 
 			       SAA7134_IRQ_REPORT_GPIO18)) &&
 		    dev->remote)
 			saa7134_input_irq(dev);
+	}
 
-	};
 	if (10 == loop) {
 		print_irqstatus(dev,loop,report,status);
 		if (report & SAA7134_IRQ_REPORT_PE) {
@@ -650,6 +651,13 @@ static irqreturn_t saa7134_irq(int irq, 
 			printk(KERN_WARNING "%s/irq: looping -- "
 			       "clearing PE (parity error!) enable bit\n",dev->name);
 			saa_clearl(SAA7134_IRQ2,SAA7134_IRQ2_INTE_PE);
+		} else if (report & (SAA7134_IRQ_REPORT_GPIO16 |
+				     SAA7134_IRQ_REPORT_GPIO18)) {
+			/* disable gpio IRQs */
+			printk(KERN_WARNING "%s/irq: looping -- "
+			       "clearing GPIO enable bits\n",dev->name);
+			saa_clearl(SAA7134_IRQ2, (SAA7134_IRQ2_INTE_GPIO16 |
+						  SAA7134_IRQ2_INTE_GPIO18));
 		} else {
 			/* disable all irqs */
 			printk(KERN_WARNING "%s/irq: looping -- "
@@ -724,20 +732,7 @@ static int saa7134_hwinit2(struct saa713
 
 	/* enable IRQ's */
 	saa_writel(SAA7134_IRQ1, 0);
-	saa_writel(SAA7134_IRQ2,
-		   SAA7134_IRQ2_INTE_GPIO18  |
-		   SAA7134_IRQ2_INTE_GPIO18A |
-		   SAA7134_IRQ2_INTE_GPIO16  |
-		   SAA7134_IRQ2_INTE_SC2     |
-		   SAA7134_IRQ2_INTE_SC1     |
-		   SAA7134_IRQ2_INTE_SC0     |
-		   /* SAA7134_IRQ2_INTE_DEC5    |  FIXME: TRIG_ERR ??? */
-		   SAA7134_IRQ2_INTE_DEC3    |
-		   SAA7134_IRQ2_INTE_DEC2    |
-		   /* SAA7134_IRQ2_INTE_DEC1    | */
-		   SAA7134_IRQ2_INTE_DEC0    |
-		   SAA7134_IRQ2_INTE_PE      |
-		   SAA7134_IRQ2_INTE_AR);
+	saa_writel(SAA7134_IRQ2, dev->irq2_mask);
 
 	return 0;
 }
@@ -958,6 +953,13 @@ static int __devinit saa7134_initdev(str
 	}
 
 	/* initialize hardware #1 */
+   	dev->irq2_mask =
+		SAA7134_IRQ2_INTE_DEC3    |
+		SAA7134_IRQ2_INTE_DEC2    |
+		SAA7134_IRQ2_INTE_DEC1    |
+		SAA7134_IRQ2_INTE_DEC0    |
+		SAA7134_IRQ2_INTE_PE      |
+		SAA7134_IRQ2_INTE_AR;
 	saa7134_board_init1(dev);
 	saa7134_hwinit1(dev);
 
@@ -1059,6 +1061,9 @@ static int __devinit saa7134_initdev(str
 	}
 	list_add_tail(&dev->devlist,&saa7134_devlist);
 	up(&devlist_lock);
+
+	/* check for signal */
+	saa7134_irq_video_intl(dev);
 	return 0;
 
  fail5:
@@ -1206,6 +1211,8 @@ static int saa7134_init(void)
 
 static void saa7134_fini(void)
 {
+	if (pending_registered)
+		unregister_module_notifier(&pending_notifier);
 	pci_unregister_driver(&saa7134_pci_driver);
 }
 
Index: linux.merge/drivers/media/video/saa7134/saa7134-dvb.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-dvb.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-dvb.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-dvb.c,v 1.4 2004/11/07 14:44:59 kraxel Exp $
+ * $Id: saa7134-dvb.c,v 1.10 2005/01/14 16:40:20 kraxel Exp $
  *
  * (c) 2004 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
  *
@@ -30,35 +30,159 @@
 #include "saa7134-reg.h"
 #include "saa7134.h"
 
+#include "dvb-pll.h"
+#include "mt352.h"
+#include "mt352_priv.h" /* FIXME */
+
 MODULE_AUTHOR("Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]");
 MODULE_LICENSE("GPL");
 
+static unsigned int antenna_pwr = 0;
+module_param(antenna_pwr, int, 0444);
+MODULE_PARM_DESC(antenna_pwr,"enable antenna power (Pinnacle 300i)");
+
 /* ------------------------------------------------------------------ */
 
-static int dvb_init(struct saa7134_dev *dev)
+static int pinnacle_antenna_pwr(struct saa7134_dev *dev, int on)
 {
-	printk("%s: %s\n",dev->name,__FUNCTION__);
+	u32 ok;
+
+	if (!on) {
+		saa_setl(SAA7134_GPIO_GPMODE0 >> 2,     (1 << 26));
+		saa_clearl(SAA7134_GPIO_GPSTATUS0 >> 2, (1 << 26));
+		return 0;
+	}
+
+	saa_setl(SAA7134_GPIO_GPMODE0 >> 2,     (1 << 26));
+	saa_setl(SAA7134_GPIO_GPSTATUS0 >> 2,   (1 << 26));
+	udelay(10);
+
+	saa_setl(SAA7134_GPIO_GPMODE0 >> 2,     (1 << 28));
+	saa_clearl(SAA7134_GPIO_GPSTATUS0 >> 2, (1 << 28));
+	udelay(10);
+	saa_setl(SAA7134_GPIO_GPSTATUS0 >> 2,   (1 << 28));
+	udelay(10);
+	ok = saa_readl(SAA7134_GPIO_GPSTATUS0) & (1 << 27);
+	printk("%s: %s %s\n", dev->name, __FUNCTION__,
+	       ok ? "on" : "off");
+
+	if (!ok)
+		saa_clearl(SAA7134_GPIO_GPSTATUS0 >> 2,   (1 << 26));
+	return ok;
+}
+
+static int mt352_pinnacle_init(struct dvb_frontend* fe)
+{
+	static u8 clock_config []  = { CLOCK_CTL,  0x3d, 0x28 };
+	static u8 reset []         = { RESET,      0x80 };
+	static u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };
+	static u8 agc_cfg []       = { AGC_TARGET, 0x28, 0xa0 };
+	static u8 capt_range_cfg[] = { CAPT_RANGE, 0x31 };
+	static u8 fsm_ctl_cfg[]    = { 0x7b,       0x04 };
+	static u8 gpp_ctl_cfg []   = { GPP_CTL,    0x0f };
+	static u8 scan_ctl_cfg []  = { SCAN_CTL,   0x0d };
+	struct saa7134_dev *dev= fe->dvb->priv;
+
+	printk("%s: %s called\n",dev->name,__FUNCTION__);
+
+	mt352_write(fe, clock_config,   sizeof(clock_config));
+	udelay(200);
+	mt352_write(fe, reset,          sizeof(reset));
+	mt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));
+	mt352_write(fe, agc_cfg,        sizeof(agc_cfg));
+	mt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));
+	mt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));
+
+	mt352_write(fe, fsm_ctl_cfg,    sizeof(fsm_ctl_cfg));
+	mt352_write(fe, scan_ctl_cfg,   sizeof(scan_ctl_cfg));
+	return 0;
+}
+
+static int mt352_pinnacle_pll_set(struct dvb_frontend* fe,
+				  struct dvb_frontend_parameters* params,
+				  u8* pllbuf)
+{
+	static int on  = TDA9887_PRESENT | TDA9887_PORT2_INACTIVE;
+	static int off = TDA9887_PRESENT | TDA9887_PORT2_ACTIVE;
+	struct saa7134_dev *dev = fe->dvb->priv;
+	struct v4l2_frequency f;
+
+	/* set frequency (mt2050) */
+	f.tuner     = 0;
+	f.type      = V4L2_TUNER_DIGITAL_TV;
+	f.frequency = params->frequency / 1000 * 16 / 1000;
+	saa7134_i2c_call_clients(dev,TDA9887_SET_CONFIG,&on);
+	saa7134_i2c_call_clients(dev,VIDIOC_S_FREQUENCY,&f);
+	saa7134_i2c_call_clients(dev,TDA9887_SET_CONFIG,&off);
+
+	pinnacle_antenna_pwr(dev, antenna_pwr);
+
+	/* mt352 setup */
+	mt352_pinnacle_init(fe);
+	pllbuf[0] = 0xc2;
+	pllbuf[1] = 0x00;
+	pllbuf[2] = 0x00;
+	pllbuf[3] = 0x80;
+	pllbuf[4] = 0x00;
+	return 0;
+}
+
+static struct mt352_config pinnacle_300i = {
+	.demod_address = 0x3c >> 1,
+	.adc_clock     = 20333,
+	.if2           = 36150,
+	.no_tuner      = 1,
+	.demod_init    = mt352_pinnacle_init,
+	.pll_set       = mt352_pinnacle_pll_set,
+};
+
+/* ------------------------------------------------------------------ */
 
+static int dvb_init(struct saa7134_dev *dev)
+{
 	/* init struct videobuf_dvb */
+	dev->ts.nr_bufs    = 32;
+	dev->ts.nr_packets = 32*4;
 	dev->dvb.name = dev->name;
 	videobuf_queue_init(&dev->dvb.dvbq, &saa7134_ts_qops,
 			    dev->pci, &dev->slock,
 			    V4L2_BUF_TYPE_VIDEO_CAPTURE,
-			    V4L2_FIELD_TOP,
+			    V4L2_FIELD_ALTERNATE,
 			    sizeof(struct saa7134_buf),
 			    dev);
 
-	/* TODO: init frontend */
-	if (NULL == dev->dvb.frontend)
+	switch (dev->board) {
+	case SAA7134_BOARD_PINNACLE_300I_DVBT_PAL:
+		printk("%s: pinnacle 300i dvb setup\n",dev->name);
+		dev->dvb.frontend = mt352_attach(&pinnacle_300i,
+						 &dev->i2c_adap);
+		break;
+	default:
+		printk("%s: Huh? unknown DVB card?\n",dev->name);
+		break;
+	}
+
+	if (NULL == dev->dvb.frontend) {
+		printk("%s: frontend initialization failed\n",dev->name);
 		return -1;
+	}
 
 	/* register everything else */
-	return videobuf_dvb_register(&dev->dvb);
+	return videobuf_dvb_register(&dev->dvb, THIS_MODULE, dev);
 }
 
 static int dvb_fini(struct saa7134_dev *dev)
 {
+	static int on  = TDA9887_PRESENT | TDA9887_PORT2_INACTIVE;
+
 	printk("%s: %s\n",dev->name,__FUNCTION__);
+
+	switch (dev->board) {
+	case SAA7134_BOARD_PINNACLE_300I_DVBT_PAL:
+		/* otherwise we don't detect the tuner on next insmod */
+		saa7134_i2c_call_clients(dev,TDA9887_SET_CONFIG,&on);
+		break;
+	};
 	videobuf_dvb_unregister(&dev->dvb);
 	return 0;
 }
Index: linux.merge/drivers/media/video/saa7134/saa7134-empress.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-empress.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-empress.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-empress.c,v 1.3 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: saa7134-empress.c,v 1.9 2004/12/10 12:33:39 kraxel Exp $
  *
  * (c) 2004 Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]
  *
@@ -21,6 +21,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
@@ -50,16 +51,21 @@ MODULE_PARM_DESC(debug,"enable debug mes
 
 static void ts_reset_encoder(struct saa7134_dev* dev)
 {
+	if (!dev->empress_started)
+		return;
+
 	saa_writeb(SAA7134_SPECIAL_MODE, 0x00);
 	msleep(10);
    	saa_writeb(SAA7134_SPECIAL_MODE, 0x01);
 	msleep(100);
+	dev->empress_started = 0;
 }
 
-static int ts_init_encoder(struct saa7134_dev* dev, void* arg)
+static int ts_init_encoder(struct saa7134_dev* dev)
 {
 	ts_reset_encoder(dev);
-	saa7134_i2c_call_clients(dev, MPEG_SETPARAMS, arg);
+	saa7134_i2c_call_clients(dev, VIDIOC_S_MPEGCOMP, NULL);
+	dev->empress_started = 1;
  	return 0;
 }
 
@@ -88,7 +94,6 @@ static int ts_open(struct inode *inode, 
 
 	dev->empress_users++;
 	file->private_data = dev;
-	ts_init_encoder(dev, NULL);
 	err = 0;
 
  done:
@@ -105,6 +110,7 @@ static int ts_release(struct inode *inod
 	down(&dev->empress_tsq.lock);
 	if (dev->empress_tsq.reading)
 		videobuf_read_stop(&dev->empress_tsq);
+	videobuf_mmap_free(&dev->empress_tsq);
 	dev->empress_users--;
 
 	/* stop the encoder */
@@ -119,6 +125,9 @@ ts_read(struct file *file, char __user *
 {
 	struct saa7134_dev *dev = file->private_data;
 
+	if (!dev->empress_started)
+		ts_init_encoder(dev);
+
 	return videobuf_read_stream(&dev->empress_tsq,
 				    data, count, ppos, 0,
 				    file->f_flags & O_NONBLOCK);
@@ -281,8 +290,13 @@ static int ts_do_ioctl(struct inode *ino
 	case VIDIOC_S_CTRL:
 		return saa7134_common_ioctl(dev, cmd, arg);
 
-	case MPEG_SETPARAMS:
-		return ts_init_encoder(dev, arg);
+	case VIDIOC_S_MPEGCOMP:
+		saa7134_i2c_call_clients(dev, VIDIOC_S_MPEGCOMP, arg);
+		ts_init_encoder(dev);
+		return 0;
+	case VIDIOC_G_MPEGCOMP:
+		saa7134_i2c_call_clients(dev, VIDIOC_G_MPEGCOMP, arg);
+		return 0;
 
 	default:
 		return -ENOIOCTLCMD;
@@ -320,6 +334,26 @@ static struct video_device saa7134_empre
 	.minor	       = -1,
 };
 
+static void empress_signal_update(void* data)
+{
+	struct saa7134_dev* dev = (struct saa7134_dev*) data;
+
+	if (dev->nosignal) {
+		dprintk("no video signal\n");
+		ts_reset_encoder(dev);
+	} else {
+		dprintk("video signal acquired\n");
+		if (dev->empress_users)
+			ts_init_encoder(dev);
+	}
+}
+
+static void empress_signal_change(struct saa7134_dev *dev)
+{
+	schedule_work(&dev->empress_workqueue);
+}
+
+
 static int empress_init(struct saa7134_dev *dev)
 {
 	int err;
@@ -335,6 +369,8 @@ static int empress_init(struct saa7134_d
 		 "%s empress (%s)", dev->name,
 		 saa7134_boards[dev->board].name);
 
+	INIT_WORK(&dev->empress_workqueue, empress_signal_update, (void*) dev);
+
 	err = video_register_device(dev->empress_dev,VFL_TYPE_GRABBER,
 				    empress_nr[dev->nr]);
 	if (err < 0) {
@@ -353,6 +389,8 @@ static int empress_init(struct saa7134_d
 			    V4L2_FIELD_ALTERNATE,
 			    sizeof(struct saa7134_buf),
 			    dev);
+
+	empress_signal_update(dev);
 	return 0;
 }
 
@@ -362,6 +400,7 @@ static int empress_fini(struct saa7134_d
 
 	if (NULL == dev->empress_dev)
 		return 0;
+	flush_scheduled_work();
 	video_unregister_device(dev->empress_dev);
 	dev->empress_dev = NULL;
 	return 0;
@@ -371,6 +410,7 @@ static struct saa7134_mpeg_ops empress_o
 	.type          = SAA7134_MPEG_EMPRESS,
 	.init          = empress_init,
 	.fini          = empress_fini,
+	.signal_change = empress_signal_change,
 };
 
 static int __init empress_register(void)
Index: linux.merge/drivers/media/video/saa7134/saa7134-i2c.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-i2c.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-i2c.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-i2c.c,v 1.7 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: saa7134-i2c.c,v 1.9 2004/12/10 12:33:39 kraxel Exp $
  *
  * device driver for philips saa7134 based TV cards
  * i2c interface support
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
@@ -248,13 +249,24 @@ static int saa7134_i2c_xfer(struct i2c_a
 		if (!i2c_reset(dev))
 			return -EIO;
 
+	d2printk("start xfer\n");
 	d1printk(KERN_DEBUG "%s: i2c xfer:",dev->name);
 	for (i = 0; i < num; i++) {
 		if (!(msgs[i].flags & I2C_M_NOSTART) || 0 == i) {
 			/* send address */
+			d2printk("send address\n");
 			addr  = msgs[i].addr << 1;
 			if (msgs[i].flags & I2C_M_RD)
 				addr |= 1;
+			if (i > 0 && msgs[i].flags & I2C_M_RD) {
+				/* workaround for a saa7134 i2c bug
+				 * needed to talk to the mt352 demux
+				 * thanks to pinnacle for the hint */
+				int quirk = 0xfd;
+				d1printk(" [%02x quirk]",quirk);
+				i2c_send_byte(dev,START,quirk);
+				i2c_recv_byte(dev);
+			}
 			d1printk(" < %02x", addr);
 			rc = i2c_send_byte(dev,START,addr);
 			if (rc < 0)
@@ -262,6 +274,7 @@ static int saa7134_i2c_xfer(struct i2c_a
 		}
 		if (msgs[i].flags & I2C_M_RD) {
 			/* read bytes */
+			d2printk("read bytes\n");
 			for (byte = 0; byte < msgs[i].len; byte++) {
 				d1printk(" =");
 				rc = i2c_recv_byte(dev);
@@ -272,6 +285,7 @@ static int saa7134_i2c_xfer(struct i2c_a
 			}
 		} else {
 			/* write bytes */
+			d2printk("write bytes\n");
 			for (byte = 0; byte < msgs[i].len; byte++) {
 				data = msgs[i].buf[byte];
 				d1printk(" %02x", data);
@@ -281,6 +295,7 @@ static int saa7134_i2c_xfer(struct i2c_a
 			}
 		}
 	}
+	d2printk("xfer done\n");
 	d1printk(" >");
 	i2c_set_attr(dev,STOP);
 	rc = -EIO;
@@ -313,18 +328,6 @@ static u32 functionality(struct i2c_adap
 	return I2C_FUNC_SMBUS_EMUL;
 }
 
-#ifndef I2C_PEC
-static void inc_use(struct i2c_adapter *adap)
-{
-	MOD_INC_USE_COUNT;
-}
-
-static void dec_use(struct i2c_adapter *adap)
-{
-	MOD_DEC_USE_COUNT;
-}
-#endif
-
 static int attach_inform(struct i2c_client *client)
 {
         struct saa7134_dev *dev = client->adapter->algo_data;
@@ -345,12 +348,7 @@ static struct i2c_algorithm saa7134_algo
 };
 
 static struct i2c_adapter saa7134_adap_template = {
-#ifdef I2C_PEC
 	.owner         = THIS_MODULE,
-#else
-	.inc_use       = inc_use,
-	.dec_use       = dec_use,
-#endif
 #ifdef I2C_CLASS_TV_ANALOG
 	.class         = I2C_CLASS_TV_ANALOG,
 #endif
Index: linux.merge/drivers/media/video/saa7134/saa7134-input.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-input.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-input.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-input.c,v 1.12 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: saa7134-input.c,v 1.16 2004/12/10 12:33:39 kraxel Exp $
  *
  * handle saa7134 IR remotes via linux kernel input layer.
  *
@@ -20,6 +20,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/sched.h>
@@ -258,6 +259,55 @@ static IR_KEYTAB_TYPE md2819_codes[IR_KE
 	[ 17 ] = KEY_CHANNELDOWN,	// CHANNEL/PAGE-
 	[ 49 ] = KEY_CHANNELUP		// CHANNEL/PAGE+
 };
+
+static IR_KEYTAB_TYPE videomate_tv_pvr_codes[IR_KEYTAB_SIZE] = {
+	[ 20 ] = KEY_MUTE,
+	[ 36 ] = KEY_ZOOM,
+
+	[  1 ] = KEY_DVD,
+	[ 35 ] = KEY_RADIO,
+	[  0 ] = KEY_TV,
+
+	[ 10 ] = KEY_REWIND,
+	[  8 ] = KEY_PLAYPAUSE,
+	[ 15 ] = KEY_FORWARD,
+
+	[  2 ] = KEY_PREVIOUS,
+	[  7 ] = KEY_STOP,
+	[  6 ] = KEY_NEXT,
+
+	[ 12 ] = KEY_UP,
+	[ 14 ] = KEY_DOWN,
+	[ 11 ] = KEY_LEFT,
+	[ 13 ] = KEY_RIGHT,
+	[ 17 ] = KEY_OK,
+
+	[  3 ] = KEY_MENU,
+	[  9 ] = KEY_SETUP,
+	[  5 ] = KEY_VIDEO,
+	[ 34 ] = KEY_CHANNEL,
+
+	[ 18 ] = KEY_VOLUMEUP,
+	[ 21 ] = KEY_VOLUMEDOWN,
+	[ 16 ] = KEY_CHANNELUP,
+	[ 19 ] = KEY_CHANNELDOWN,
+
+	[  4 ] = KEY_RECORD,
+
+	[ 22 ] = KEY_KP1,
+	[ 23 ] = KEY_KP2,
+	[ 24 ] = KEY_KP3,
+	[ 25 ] = KEY_KP4,
+	[ 26 ] = KEY_KP5,
+	[ 27 ] = KEY_KP6,
+	[ 28 ] = KEY_KP7,
+	[ 29 ] = KEY_KP8,
+	[ 30 ] = KEY_KP9,
+	[ 31 ] = KEY_KP0,
+
+	[ 32 ] = KEY_LANGUAGE,
+	[ 33 ] = KEY_SLEEP,
+};
 /* ---------------------------------------------------------------------- */
 
 static int build_key(struct saa7134_dev *dev)
@@ -335,6 +385,7 @@ int saa7134_input_init1(struct saa7134_d
 		break;
 	case SAA7134_BOARD_CINERGY400:
 	case SAA7134_BOARD_CINERGY600:
+	case SAA7134_BOARD_CINERGY600_MK3:
 		ir_codes     = cinergy_codes;
 		mask_keycode = 0x00003f;
 		mask_keyup   = 0x040000;
@@ -353,6 +404,7 @@ int saa7134_input_init1(struct saa7134_d
 		polling      = 50; // ms
 		break;
 	case SAA7134_BOARD_MD2819:
+	case SAA7134_BOARD_AVERMEDIA_305:
 	case SAA7134_BOARD_AVERMEDIA_307:
 		ir_codes     = md2819_codes;
 		mask_keycode = 0x0007C8;
@@ -362,6 +414,12 @@ int saa7134_input_init1(struct saa7134_d
 		saa_setb(SAA7134_GPIO_GPMODE0, 0x4);
 		saa_setb(SAA7134_GPIO_GPSTATUS0, 0x4);
 		break;
+	case SAA7134_BOARD_VIDEOMATE_TV_PVR:
+		ir_codes     = videomate_tv_pvr_codes;
+		mask_keycode = 0x00003F;
+		mask_keyup   = 0x400000;
+		polling      = 50; // ms
+		break;
 	}
 	if (NULL == ir_codes) {
 		printk("%s: Oops: IR config error [card=%d]\n",
Index: linux.merge/drivers/media/video/saa7134/saa7134-oss.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-oss.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-oss.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-oss.c,v 1.11 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: saa7134-oss.c,v 1.13 2004/12/10 12:33:39 kraxel Exp $
  *
  * device driver for philips saa7134 based TV cards
  * oss dsp interface
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/soundcard.h>
@@ -543,6 +544,7 @@ mixer_recsrc_7134(struct saa7134_dev *de
 		break;
 	case LINE1:
 	case LINE2:
+	case LINE2_LEFT:
 		analog_io = (LINE1 == dev->oss.input) ? 0x00 : 0x08;
 		rate = (32000 == dev->oss.rate) ? 0x01 : 0x03;
 		saa_andorb(SAA7134_ANALOG_IO_SELECT,  0x08, analog_io);
@@ -566,6 +568,7 @@ mixer_recsrc_7133(struct saa7134_dev *de
 		value = 0xbbbb32;  /* AUX1 */
 		break;
 	case LINE2:
+	case LINE2_LEFT:
 		value = 0xbbbb54;  /* AUX2 */
 		break;
 	}
@@ -608,6 +611,7 @@ mixer_level(struct saa7134_dev *dev, enu
 				   (100 == level) ? 0x00 : 0x10);
 			break;
 		case LINE2:
+		case LINE2_LEFT:
 			saa_andorb(SAA7134_ANALOG_IO_SELECT,  0x20,
 				   (100 == level) ? 0x00 : 0x20);
 			break;
Index: linux.merge/drivers/media/video/saa7134/saa7134-ts.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-ts.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-ts.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-ts.c,v 1.12 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: saa7134-ts.c,v 1.13 2004/12/10 12:33:39 kraxel Exp $
  *
  * device driver for philips saa7134 based TV cards
  * video4linux video interface
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
Index: linux.merge/drivers/media/video/saa7134/saa7134-tvaudio.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-tvaudio.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-tvaudio.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-tvaudio.c,v 1.17 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: saa7134-tvaudio.c,v 1.22 2005/01/07 13:11:19 kraxel Exp $
  *
  * device driver for philips saa7134 based TV cards
  * tv audio decoder (fm stereo, nicam, ...)
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
@@ -237,13 +238,14 @@ static void mute_input_7134(struct saa71
 
 	if (PCI_DEVICE_ID_PHILIPS_SAA7134 == dev->pci->device)
 		/* 7134 mute */
-		saa_writeb(SAA7134_AUDIO_MUTE_CTRL, mute ? 0xff : 0xbb);
+		saa_writeb(SAA7134_AUDIO_MUTE_CTRL, mute ? 0xbf : 0xbb);
 
 	/* switch internal audio mux */
 	switch (in->amux) {
-	case TV:    ausel=0xc0; ics=0x00; ocs=0x02; break;
-	case LINE1: ausel=0x80; ics=0x00; ocs=0x00; break;
-	case LINE2: ausel=0x80; ics=0x08; ocs=0x01; break;
+	case TV:         ausel=0xc0; ics=0x00; ocs=0x02; break;
+	case LINE1:      ausel=0x80; ics=0x00; ocs=0x00; break;
+	case LINE2:      ausel=0x80; ics=0x08; ocs=0x01; break;
+	case LINE2_LEFT: ausel=0x80; ics=0x08; ocs=0x05; break;
 	}
 	saa_andorb(SAA7134_AUDIO_FORMAT_CTRL, 0xc0, ausel);
 	saa_andorb(SAA7134_ANALOG_IO_SELECT, 0x08, ics);
@@ -437,15 +439,16 @@ static int tvaudio_getstereo(struct saa7
 		nicam = saa_readb(SAA7134_NICAM_STATUS);
 		dprintk("getstereo: nicam=0x%x\n",nicam);
 		switch (nicam & 0x0b) {
-		case 0x08:
-			retval = V4L2_TUNER_SUB_MONO;
-			break;
 		case 0x09:
 			retval = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;
 			break;
 		case 0x0a:
 			retval = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
 			break;
+		case 0x08:
+		default:
+			retval = V4L2_TUNER_SUB_MONO;
+			break;
 		}
 		break;
 	}
@@ -748,9 +751,16 @@ static int mute_input_7133(struct saa713
 	int mask;
 
 	switch (dev->input->amux) {
-	case TV:    reg = 0x02; break;
-	case LINE1: reg = 0x00; break;
-	case LINE2: reg = 0x01; break;
+	case TV:
+		reg = 0x02;
+		break;
+	case LINE1:
+		reg = 0x00;
+		break;
+	case LINE2:
+	case LINE2_LEFT:
+		reg = 0x01;
+		break;
 	}
 	if (dev->ctl_mute)
 		reg = 0x07;
@@ -869,6 +879,21 @@ static int tvaudio_thread_ddep(void *dat
 /* ------------------------------------------------------------------ */
 /* common stuff + external entry points                               */
 
+static void saa7134_enable_i2s(struct saa7134_dev *dev)
+{
+	int i2s_format;
+
+	if (!card_is_empress(dev))
+		return;
+	i2s_format = (dev->input->amux == TV) ? 0x00 : 0x01;
+
+	/* enable I2S audio output for the mpeg encoder */
+	saa_writeb(SAA7134_I2S_OUTPUT_SELECT,  0x80);
+	saa_writeb(SAA7134_I2S_OUTPUT_FORMAT,  i2s_format);
+	saa_writeb(SAA7134_I2S_OUTPUT_LEVEL,   0x0F);
+	saa_writeb(SAA7134_I2S_AUDIO_OUTPUT,   0x01);
+}
+
 int saa7134_tvaudio_rx2mode(u32 rx)
 {
 	u32 mode;
@@ -911,6 +936,7 @@ void saa7134_tvaudio_setinput(struct saa
 		mute_input_7133(dev);
 		break;
 	}
+	saa7134_enable_i2s(dev);
 }
 
 void saa7134_tvaudio_setvolume(struct saa7134_dev *dev, int level)
@@ -946,18 +972,6 @@ int saa7134_tvaudio_init2(struct saa7134
 	DECLARE_MUTEX_LOCKED(sem);
 	int (*my_thread)(void *data) = NULL;
 
-	/* enable I2S audio output */
-	if (card_is_empress(dev)) {
-		int i2sform = (48000 == dev->oss.rate)
-			? 0x01 : 0x00;
-
-		/* enable I2S output */
-		saa_writeb(SAA7134_I2S_OUTPUT_SELECT,  0x80);
-		saa_writeb(SAA7134_I2S_OUTPUT_FORMAT,  i2sform);
-		saa_writeb(SAA7134_I2S_OUTPUT_LEVEL,   0x0F);
-		saa_writeb(SAA7134_I2S_AUDIO_OUTPUT,   0x01);
-	}
-
 	switch (dev->pci->device) {
 	case PCI_DEVICE_ID_PHILIPS_SAA7134:
 		my_thread = tvaudio_thread;
@@ -977,9 +991,10 @@ int saa7134_tvaudio_init2(struct saa7134
 		if (dev->thread.pid < 0)
 			printk(KERN_WARNING "%s: kernel_thread() failed\n",
 			       dev->name);
-		wake_up_interruptible(&dev->thread.wq);
+		saa7134_tvaudio_do_scan(dev);
 	}
 
+	saa7134_enable_i2s(dev);
 	return 0;
 }
 
Index: linux.merge/drivers/media/video/saa7134/saa7134-vbi.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-vbi.c	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-vbi.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-vbi.c,v 1.5 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: saa7134-vbi.c,v 1.6 2004/12/10 12:33:39 kraxel Exp $
  *
  * device driver for philips saa7134 based TV cards
  * video4linux video interface
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 
Index: linux.merge/drivers/media/video/saa7134/saa7134-video.c
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134-video.c	2005-01-20 16:52:33.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134-video.c	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134-video.c,v 1.19 2004/11/07 14:44:59 kraxel Exp $
+ * $Id: saa7134-video.c,v 1.25 2004/12/10 12:33:39 kraxel Exp $
  *
  * device driver for philips saa7134 based TV cards
  * video4linux video interface
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 
@@ -443,11 +444,10 @@ void res_free(struct saa7134_dev *dev, s
 
 static void set_tvnorm(struct saa7134_dev *dev, struct saa7134_tvnorm *norm)
 {
-	int luma_control,sync_control,mux,nosignal;
+	int luma_control,sync_control,mux;
 
 	dprintk("set tv norm = %s\n",norm->name);
 	dev->tvnorm = norm;
-        nosignal = (0 == (saa_readb(SAA7134_STATUS_VIDEO1) & 0x03));
 
 	mux = card_in(dev,dev->ctl_input).vmux;
 	luma_control = norm->luma_control;
@@ -455,7 +455,7 @@ static void set_tvnorm(struct saa7134_de
 
 	if (mux > 5)
 		luma_control |= 0x80; /* svideo */
-	if (noninterlaced || nosignal)
+	if (noninterlaced || dev->nosignal)
 		sync_control |= 0x20;
 
 	/* setup cropping */
@@ -1359,6 +1359,9 @@ static int video_release(struct inode *i
 		res_free(dev,fh,RESOURCE_VBI);
 	}
 
+	/* free stuff */
+	videobuf_mmap_free(&fh->cap);
+	videobuf_mmap_free(&fh->vbi);
 	saa7134_pgtable_free(dev->pci,&fh->pt_cap);
 	saa7134_pgtable_free(dev->pci,&fh->pt_vbi);
 
@@ -1472,6 +1475,7 @@ static int saa7134_try_fmt(struct saa713
 			f->fmt.pix.width = maxw;
 		if (f->fmt.pix.height > maxh)
 			f->fmt.pix.height = maxh;
+		f->fmt.pix.width &= ~0x03;
 		f->fmt.pix.bytesperline =
 			(f->fmt.pix.width * fmt->depth) >> 3;
 		f->fmt.pix.sizeimage =
@@ -2267,7 +2271,7 @@ int saa7134_video_init1(struct saa7134_d
 	dev->ctl_hue        = ctrl_by_id(V4L2_CID_HUE)->default_value;
 	dev->ctl_saturation = ctrl_by_id(V4L2_CID_SATURATION)->default_value;
 	dev->ctl_volume     = ctrl_by_id(V4L2_CID_AUDIO_VOLUME)->default_value;
-	dev->ctl_mute       = ctrl_by_id(V4L2_CID_AUDIO_MUTE)->default_value;
+	dev->ctl_mute       = 1; // ctrl_by_id(V4L2_CID_AUDIO_MUTE)->default_value;
 	dev->ctl_invert     = ctrl_by_id(V4L2_CID_PRIVATE_INVERT)->default_value;
 	dev->ctl_automute   = ctrl_by_id(V4L2_CID_PRIVATE_AUTOMUTE)->default_value;
 
@@ -2317,24 +2321,31 @@ int saa7134_video_fini(struct saa7134_de
 void saa7134_irq_video_intl(struct saa7134_dev *dev)
 {
 	static const char *st[] = {
-		"no signal", "found NTSC", "found PAL", "found SECAM" };
-	int norm;
+		"(no signal)", "NTSC", "PAL", "SECAM" };
+	u32 st1,st2;
 
-	norm = saa_readb(SAA7134_STATUS_VIDEO1) & 0x03;
-	dprintk("DCSDT: %s\n",st[norm]);
+	st1 = saa_readb(SAA7134_STATUS_VIDEO1);
+	st2 = saa_readb(SAA7134_STATUS_VIDEO2);
+	dprintk("DCSDT: pll: %s, sync: %s, norm: %s\n",
+		(st1 & 0x40) ? "not locked" : "locked",
+		(st2 & 0x40) ? "no"         : "yes",
+		st[st1 & 0x03]);
+	dev->nosignal = (st1 & 0x40) || (st2 & 0x40);
 
-	if (0 != norm) {
-		/* wake up tvaudio audio carrier scan thread */
-		saa7134_tvaudio_do_scan(dev);
-		if (!noninterlaced)
-			saa_clearb(SAA7134_SYNC_CTRL, 0x20);
-	} else {
+	if (dev->nosignal) {
 		/* no video signal -> mute audio */
 		if (dev->ctl_automute)
 			dev->automute = 1;
 		saa7134_tvaudio_setmute(dev);
 		saa_setb(SAA7134_SYNC_CTRL, 0x20);
+	} else {
+		/* wake up tvaudio audio carrier scan thread */
+		saa7134_tvaudio_do_scan(dev);
+		if (!noninterlaced)
+			saa_clearb(SAA7134_SYNC_CTRL, 0x20);
 	}
+	if (dev->mops && dev->mops->signal_change)
+		dev->mops->signal_change(dev);
 }
 
 void saa7134_irq_video_done(struct saa7134_dev *dev, unsigned long status)
Index: linux.merge/drivers/media/video/saa7134/saa7134.h
===================================================================
--- linux.merge.orig/drivers/media/video/saa7134/saa7134.h	2005-01-04 16:56:54.000000000 -0500
+++ linux.merge/drivers/media/video/saa7134/saa7134.h	2005-01-20 17:24:54.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * $Id: saa7134.h,v 1.27 2004/11/04 11:03:52 kraxel Exp $
+ * $Id: saa7134.h,v 1.35 2005/01/13 17:22:33 kraxel Exp $
  *
  * v4l2 device driver for philips saa7134 based TV cards
  *
@@ -64,6 +64,7 @@ enum saa7134_audio_in {
 	TV    = 1,
 	LINE1 = 2,
 	LINE2 = 3,
+	LINE2_LEFT,
 };
 
 enum saa7134_video_out {
@@ -156,7 +157,7 @@ struct saa7134_format {
 #define SAA7134_BOARD_AVACSSMARTTV     32
 #define SAA7134_BOARD_AVERMEDIA_DVD_EZMAKER 33
 #define SAA7134_BOARD_NOVAC_PRIMETV7133 34
-#define SAA7134_BOARD_AVERMEDIA_305    35
+#define SAA7134_BOARD_AVERMEDIA_STUDIO_305 35
 #define SAA7133_BOARD_UPMOST_PURPLE_TV 36
 #define SAA7134_BOARD_ITEMS_MTV005     37
 #define SAA7134_BOARD_CINERGY200       38
@@ -169,6 +170,11 @@ struct saa7134_format {
 #define SAA7134_BOARD_AVERMEDIA_307    45
 #define SAA7134_BOARD_AVERMEDIA_CARDBUS 46
 #define SAA7134_BOARD_CINERGY400_CARDBUS 47
+#define SAA7134_BOARD_CINERGY600_MK3   48
+#define SAA7134_BOARD_VIDEOMATE_GOLD_PLUS 49
+#define SAA7134_BOARD_PINNACLE_300I_DVBT_PAL 50
+#define SAA7134_BOARD_PROVIDEO_PV952   51
+#define SAA7134_BOARD_AVERMEDIA_305    52
 
 #define SAA7134_MAXBOARDS 8
 #define SAA7134_INPUT_MAX 8
@@ -355,6 +361,7 @@ struct saa7134_mpeg_ops {
 	struct list_head           next;
 	int                        (*init)(struct saa7134_dev *dev);
 	int                        (*fini)(struct saa7134_dev *dev);
+	void                       (*signal_change)(struct saa7134_dev *dev);
 };
 
 /* global device status */
@@ -390,6 +397,7 @@ struct saa7134_dev {
 	unsigned int               tuner_type;
 	unsigned int               tda9887_conf;
 	unsigned int               gpio_value;
+	unsigned int               irq2_mask;
 
 	/* i2c i/o */
 	struct i2c_adapter         i2c_adap;
@@ -437,6 +445,7 @@ struct saa7134_dev {
 	struct saa7134_input       *hw_input;
 	unsigned int               hw_mute;
 	int                        last_carrier;
+	int                        nosignal;
 
 	/* SAA7134_MPEG_* */
 	struct saa7134_ts          ts;
@@ -447,6 +456,8 @@ struct saa7134_dev {
 	struct video_device        *empress_dev;
 	struct videobuf_queue      empress_tsq;
 	unsigned int               empress_users;
+	struct work_struct         empress_workqueue;
+	int                        empress_started;
 
 	/* SAA7134_MPEG_DVB only */
 	struct videobuf_dvb        dvb;
@@ -476,7 +487,6 @@ struct saa7134_dev {
 /* saa7134-core.c                                              */
 
 extern struct list_head  saa7134_devlist;
-extern unsigned int      saa7134_devcount;
 
 void saa7134_print_ioctl(char *name, unsigned int cmd);
 void saa7134_track_gpio(struct saa7134_dev *dev, char *msg);
Index: linux.merge/include/media/saa6752hs.h
===================================================================
--- linux.merge.orig/include/media/saa6752hs.h	2005-01-04 16:57:32.000000000 -0500
+++ linux.merge/include/media/saa6752hs.h	2005-01-20 17:24:54.000000000 -0500
@@ -18,14 +18,14 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-#ifndef _SAA6752HS_H
+#if 0 /* ndef _SAA6752HS_H */
 #define _SAA6752HS_H
 
-enum mpeg_bitrate_mode {
-	MPEG_BITRATE_MODE_VBR = 0, /* Variable bitrate */
-	MPEG_BITRATE_MODE_CBR = 1, /* Constant bitrate */
+enum mpeg_video_bitrate_mode {
+	MPEG_VIDEO_BITRATE_MODE_VBR = 0, /* Variable bitrate */
+	MPEG_VIDEO_BITRATE_MODE_CBR = 1, /* Constant bitrate */
 
-	MPEG_BITRATE_MODE_MAX
+	MPEG_VIDEO_BITRATE_MODE_MAX
 };
 
 enum mpeg_audio_bitrate {
@@ -35,16 +35,33 @@ enum mpeg_audio_bitrate {
 	MPEG_AUDIO_BITRATE_MAX
 };
 
+enum mpeg_video_format {
+	MPEG_VIDEO_FORMAT_D1 = 0,
+	MPEG_VIDEO_FORMAT_2_3_D1 = 1,
+	MPEG_VIDEO_FORMAT_1_2_D1 = 2,
+	MPEG_VIDEO_FORMAT_SIF = 3,
+
+	MPEG_VIDEO_FORMAT_MAX
+};
+
 #define MPEG_VIDEO_TARGET_BITRATE_MAX 27000
 #define MPEG_VIDEO_MAX_BITRATE_MAX 27000
 #define MPEG_TOTAL_BITRATE_MAX 27000
+#define MPEG_PID_MAX ((1 << 14) - 1)
 
 struct mpeg_params {
-	enum mpeg_bitrate_mode bitrate_mode;
+	enum mpeg_video_bitrate_mode video_bitrate_mode;
 	unsigned int video_target_bitrate;
 	unsigned int video_max_bitrate; // only used for VBR
 	enum mpeg_audio_bitrate audio_bitrate;
 	unsigned int total_bitrate;
+
+   	unsigned int pmt_pid;
+	unsigned int video_pid;
+	unsigned int audio_pid;
+	unsigned int pcr_pid;
+
+	enum mpeg_video_format video_format;
 };
 
 #define MPEG_SETPARAMS             _IOW('6',100,struct mpeg_params)
