From: Takashi Iwai <tiwai@suse.de>
Subject: Post-9.3 ALSA update: CVS 2005.06.03
Patch-mainline: 2.6.12-rc-mm
References: 

Post-9.3 ALSA update patch, taken from CVS 2005.06.03.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/memalloc.c linux/sound/core/memalloc.c
--- linux-2.6.11/sound/core/memalloc.c	2005-03-02 08:38:32.000000000 +0100
+++ linux/sound/core/memalloc.c	2005-05-30 19:22:45.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
+#include <asm/uaccess.h>
 #include <linux/dma-mapping.h>
 #include <linux/moduleparam.h>
 #include <asm/semaphore.h>
@@ -46,13 +47,6 @@ MODULE_LICENSE("GPL");
 #define SNDRV_CARDS	8
 #endif
 
-/* FIXME: so far only some PCI devices have the preallocation table */
-#ifdef CONFIG_PCI
-static int enable[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};
-module_param_array(enable, bool, NULL, 0444);
-MODULE_PARM_DESC(enable, "Enable cards to allocate buffers.");
-#endif
-
 /*
  */
 
@@ -451,9 +445,13 @@ size_t snd_dma_get_reserved_buf(struct s
 	list_for_each(p, &mem_list_head) {
 		mem = list_entry(p, struct snd_mem_list, list);
 		if (mem->id == id &&
-		    ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev))) {
+		    (mem->buffer.dev.dev == NULL || dmab->dev.dev == NULL ||
+		     ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev)))) {
+			struct device *dev = dmab->dev.dev;
 			list_del(p);
 			*dmab = mem->buffer;
+			if (dmab->dev.dev == NULL)
+				dmab->dev.dev = dev;
 			kfree(mem);
 			up(&list_mutex);
 			return dmab->bytes;
@@ -508,91 +506,13 @@ static void free_all_reserved_pages(void
 }
 
 
-
-/*
- * allocation of buffers for pre-defined devices
- */
-
-#ifdef CONFIG_PCI
-/* FIXME: for pci only - other bus? */
-struct prealloc_dev {
-	unsigned short vendor;
-	unsigned short device;
-	unsigned long dma_mask;
-	unsigned int size;
-	unsigned int buffers;
-};
-
-#define HAMMERFALL_BUFFER_SIZE    (16*1024*4*(26+1)+0x10000)
-
-static struct prealloc_dev prealloc_devices[] __initdata = {
-	{
-		/* hammerfall */
-		.vendor = 0x10ee,
-		.device = 0x3fc4,
-		.dma_mask = 0xffffffff,
-		.size = HAMMERFALL_BUFFER_SIZE,
-		.buffers = 2
-	},
-	{
-		/* HDSP */
-		.vendor = 0x10ee,
-		.device = 0x3fc5,
-		.dma_mask = 0xffffffff,
-		.size = HAMMERFALL_BUFFER_SIZE,
-		.buffers = 2
-	},
-	{ }, /* terminator */
-};
-
-static void __init preallocate_cards(void)
-{
-	struct pci_dev *pci = NULL;
-	int card;
-
-	card = 0;
-
-	while ((pci = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pci)) != NULL) {
-		struct prealloc_dev *dev;
-		unsigned int i;
-		if (card >= SNDRV_CARDS)
-			break;
-		for (dev = prealloc_devices; dev->vendor; dev++) {
-			if (dev->vendor == pci->vendor && dev->device == pci->device)
-				break;
-		}
-		if (! dev->vendor)
-			continue;
-		if (! enable[card++]) {
-			printk(KERN_DEBUG "snd-page-alloc: skipping card %d, device %04x:%04x\n", card, pci->vendor, pci->device);
-			continue;
-		}
-			
-		if (pci_set_dma_mask(pci, dev->dma_mask) < 0 ||
-		    pci_set_consistent_dma_mask(pci, dev->dma_mask) < 0) {
-			printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", dev->dma_mask, dev->vendor, dev->device);
-			continue;
-		}
-		for (i = 0; i < dev->buffers; i++) {
-			struct snd_dma_buffer dmab;
-			memset(&dmab, 0, sizeof(dmab));
-			if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-						dev->size, &dmab) < 0)
-				printk(KERN_WARNING "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", dev->size);
-			else
-				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));
-		}
-	}
-}
-#else
-#define preallocate_cards()	/* NOP */
-#endif
-
-
 #ifdef CONFIG_PROC_FS
 /*
  * proc file interface
  */
+#define SND_MEM_PROC_FILE	"driver/snd-page-alloc"
+struct proc_dir_entry *snd_mem_proc;
+
 static int snd_mem_proc_read(char *page, char **start, off_t off,
 			     int count, int *eof, void *data)
 {
@@ -621,6 +541,97 @@ static int snd_mem_proc_read(char *page,
 	up(&list_mutex);
 	return len;
 }
+
+/* FIXME: for pci only - other bus? */
+#ifdef CONFIG_PCI
+#define gettoken(bufp) strsep(bufp, " \t\n")
+
+static int snd_mem_proc_write(struct file *file, const char __user *buffer,
+			      unsigned long count, void *data)
+{
+	char buf[128];
+	char *token, *p;
+
+	if (count > ARRAY_SIZE(buf) - 1)
+		count = ARRAY_SIZE(buf) - 1;
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+	buf[ARRAY_SIZE(buf) - 1] = '\0';
+
+	p = buf;
+	token = gettoken(&p);
+	if (! token || *token == '#')
+		return (int)count;
+	if (strcmp(token, "add") == 0) {
+		char *endp;
+		int vendor, device, size, buffers;
+		long mask;
+		int i, alloced;
+		struct pci_dev *pci;
+
+		if ((token = gettoken(&p)) == NULL ||
+		    (vendor = simple_strtol(token, NULL, 0)) <= 0 ||
+		    (token = gettoken(&p)) == NULL ||
+		    (device = simple_strtol(token, NULL, 0)) <= 0 ||
+		    (token = gettoken(&p)) == NULL ||
+		    (mask = simple_strtol(token, NULL, 0)) < 0 ||
+		    (token = gettoken(&p)) == NULL ||
+		    (size = memparse(token, &endp)) < 64*1024 ||
+		    size > 16*1024*1024 /* too big */ ||
+		    (token = gettoken(&p)) == NULL ||
+		    (buffers = simple_strtol(token, NULL, 0)) <= 0 ||
+		    buffers > 4) {
+			printk(KERN_ERR "snd-page-alloc: invalid proc write format\n");
+			return (int)count;
+		}
+		vendor &= 0xffff;
+		device &= 0xffff;
+
+		alloced = 0;
+		pci = NULL;
+		while ((pci = pci_find_device(vendor, device, pci)) != NULL) {
+			if (mask > 0 && mask < 0xffffffff) {
+				if (pci_set_dma_mask(pci, mask) < 0 ||
+				    pci_set_consistent_dma_mask(pci, mask) < 0) {
+					printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", mask, vendor, device);
+					return (int)count;
+				}
+			}
+			for (i = 0; i < buffers; i++) {
+				struct snd_dma_buffer dmab;
+				memset(&dmab, 0, sizeof(dmab));
+				if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+							size, &dmab) < 0) {
+					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
+					return (int)count;
+				}
+				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));
+			}
+			alloced++;
+		}
+		if (! alloced) {
+			for (i = 0; i < buffers; i++) {
+				struct snd_dma_buffer dmab;
+				memset(&dmab, 0, sizeof(dmab));
+				/* FIXME: We can allocate only in ZONE_DMA
+				 * without a device pointer!
+				 */
+				if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, NULL,
+							size, &dmab) < 0) {
+					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
+					break;
+				}
+				snd_dma_reserve_buf(&dmab, (unsigned int)((vendor << 16) | device));
+			}
+		}
+	} else if (strcmp(token, "erase") == 0)
+		/* FIXME: need for releasing each buffer chunk? */
+		free_all_reserved_pages();
+	else
+		printk(KERN_ERR "snd-page-alloc: invalid proc cmd\n");
+	return (int)count;
+}
+#endif /* CONFIG_PCI */
 #endif /* CONFIG_PROC_FS */
 
 /*
@@ -630,15 +641,21 @@ static int snd_mem_proc_read(char *page,
 static int __init snd_mem_init(void)
 {
 #ifdef CONFIG_PROC_FS
-	create_proc_read_entry("driver/snd-page-alloc", 0, NULL, snd_mem_proc_read, NULL);
+	snd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);
+	if (snd_mem_proc) {
+		snd_mem_proc->read_proc = snd_mem_proc_read;
+#ifdef CONFIG_PCI
+		snd_mem_proc->write_proc = snd_mem_proc_write;
+#endif
+	}
 #endif
-	preallocate_cards();
 	return 0;
 }
 
 static void __exit snd_mem_exit(void)
 {
-	remove_proc_entry("driver/snd-page-alloc", NULL);
+	if (snd_mem_proc)
+		remove_proc_entry(SND_MEM_PROC_FILE, NULL);
 	free_all_reserved_pages();
 	if (snd_allocated_pages > 0)
 		printk(KERN_ERR "snd-malloc: Memory leak?  pages not freed = %li\n", snd_allocated_pages);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/oss/pcm_oss.c linux/sound/core/oss/pcm_oss.c
--- linux-2.6.11/sound/core/oss/pcm_oss.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/core/oss/pcm_oss.c	2005-05-31 19:33:13.000000000 +0200
@@ -125,17 +125,26 @@ int snd_pcm_plugin_append(snd_pcm_plugin
 static long snd_pcm_oss_bytes(snd_pcm_substream_t *substream, long frames)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_pcm_uframes_t buffer_size = snd_pcm_lib_buffer_bytes(substream);
-	frames = frames_to_bytes(runtime, frames);
+	long buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	long bytes = frames_to_bytes(runtime, frames);
 	if (buffer_size == runtime->oss.buffer_bytes)
-		return frames;
-	return (runtime->oss.buffer_bytes * frames) / buffer_size;
+		return bytes;
+#if BITS_PER_LONG >= 64
+	return runtime->oss.buffer_bytes * bytes / buffer_size;
+#else
+	{
+		u64 bsize = (u64)runtime->oss.buffer_bytes * (u64)bytes;
+		u32 rem;
+		div64_32(&bsize, buffer_size, &rem);
+		return (long)bsize;
+	}
+#endif
 }
 
 static long snd_pcm_alsa_frames(snd_pcm_substream_t *substream, long bytes)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_pcm_uframes_t buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	long buffer_size = snd_pcm_lib_buffer_bytes(substream);
 	if (buffer_size == runtime->oss.buffer_bytes)
 		return bytes_to_frames(runtime, bytes);
 	return bytes_to_frames(runtime, (buffer_size * bytes) / runtime->oss.buffer_bytes);
@@ -1528,12 +1537,15 @@ static int snd_pcm_oss_get_ptr(snd_pcm_o
 			snd_pcm_oss_simulate_fill(substream, delay);
 		info.bytes = snd_pcm_oss_bytes(substream, runtime->status->hw_ptr) & INT_MAX;
 	} else {
-		delay = snd_pcm_oss_bytes(substream, delay) + fixup;
-		info.blocks = delay / runtime->oss.period_bytes;
-		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		delay = snd_pcm_oss_bytes(substream, delay);
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			info.blocks = (runtime->oss.buffer_bytes - delay - fixup) / runtime->oss.period_bytes;
 			info.bytes = (runtime->oss.bytes - delay) & INT_MAX;
-		else
+		} else {
+			delay += fixup;
+			info.blocks = delay / runtime->oss.period_bytes;
 			info.bytes = (runtime->oss.bytes + delay) & INT_MAX;
+		}
 	}
 	if (copy_to_user(_info, &info, sizeof(info)))
 		return -EFAULT;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/pcm.c linux/sound/core/pcm.c
--- linux-2.6.11/sound/core/pcm.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/core/pcm.c	2005-05-18 18:54:12.000000000 +0200
@@ -1049,7 +1049,6 @@ EXPORT_SYMBOL(snd_pcm_release_substream)
 EXPORT_SYMBOL(snd_pcm_format_name);
   /* pcm_native.c */
 EXPORT_SYMBOL(snd_pcm_link_rwlock);
-EXPORT_SYMBOL(snd_pcm_start);
 #ifdef CONFIG_PM
 EXPORT_SYMBOL(snd_pcm_suspend);
 EXPORT_SYMBOL(snd_pcm_suspend_all);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/pcm_lib.c linux/sound/core/pcm_lib.c
--- linux-2.6.11/sound/core/pcm_lib.c	2005-06-03 15:53:56.000000000 +0200
+++ linux/sound/core/pcm_lib.c	2005-05-24 18:22:55.000000000 +0200
@@ -1143,7 +1143,8 @@ int snd_pcm_hw_constraint_pow2(snd_pcm_r
 #define INT_MIN ((int)((unsigned int)INT_MAX+1))
 #endif
 
-void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var)
+static void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params,
+				  snd_pcm_hw_param_t var)
 {
 	if (hw_is_mask(var)) {
 		snd_mask_any(hw_param_mask(params, var));
@@ -1160,6 +1161,7 @@ void _snd_pcm_hw_param_any(snd_pcm_hw_pa
 	snd_BUG();
 }
 
+#if 0
 /**
  * snd_pcm_hw_param_any
  */
@@ -1169,6 +1171,7 @@ int snd_pcm_hw_param_any(snd_pcm_t *pcm,
 	_snd_pcm_hw_param_any(params, var);
 	return snd_pcm_hw_refine(pcm, params);
 }
+#endif  /*  0  */
 
 void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params)
 {
@@ -1181,6 +1184,7 @@ void _snd_pcm_hw_params_any(snd_pcm_hw_p
 	params->info = ~0U;
 }
 
+#if 0
 /**
  * snd_pcm_hw_params_any
  *
@@ -1191,6 +1195,7 @@ int snd_pcm_hw_params_any(snd_pcm_t *pcm
 	_snd_pcm_hw_params_any(params);
 	return snd_pcm_hw_refine(pcm, params);
 }
+#endif  /*  0  */
 
 /**
  * snd_pcm_hw_param_value
@@ -1198,8 +1203,8 @@ int snd_pcm_hw_params_any(snd_pcm_t *pcm
  * Return the value for field PAR if it's fixed in configuration space 
  *  defined by PARAMS. Return -EINVAL otherwise
  */
-int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var, int *dir)
+static int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
+				  snd_pcm_hw_param_t var, int *dir)
 {
 	if (hw_is_mask(var)) {
 		const snd_mask_t *mask = hw_param_mask_c(params, var);
@@ -1296,6 +1301,7 @@ int _snd_pcm_hw_param_setinteger(snd_pcm
 	return changed;
 }
 	
+#if 0
 /**
  * snd_pcm_hw_param_setinteger
  *
@@ -1317,9 +1323,10 @@ int snd_pcm_hw_param_setinteger(snd_pcm_
 	}
 	return 0;
 }
+#endif  /*  0  */
 
-int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
-			    snd_pcm_hw_param_t var)
+static int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
+				   snd_pcm_hw_param_t var)
 {
 	int changed;
 	if (hw_is_mask(var))
@@ -1345,9 +1352,9 @@ int _snd_pcm_hw_param_first(snd_pcm_hw_p
  * values > minimum. Reduce configuration space accordingly.
  * Return the minimum.
  */
-int snd_pcm_hw_param_first(snd_pcm_t *pcm, 
-			   snd_pcm_hw_params_t *params, 
-			   snd_pcm_hw_param_t var, int *dir)
+static int snd_pcm_hw_param_first(snd_pcm_t *pcm, 
+				  snd_pcm_hw_params_t *params, 
+				  snd_pcm_hw_param_t var, int *dir)
 {
 	int changed = _snd_pcm_hw_param_first(params, var);
 	if (changed < 0)
@@ -1359,8 +1366,8 @@ int snd_pcm_hw_param_first(snd_pcm_t *pc
 	return snd_pcm_hw_param_value(params, var, dir);
 }
 
-int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var)
+static int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
+				  snd_pcm_hw_param_t var)
 {
 	int changed;
 	if (hw_is_mask(var))
@@ -1386,9 +1393,9 @@ int _snd_pcm_hw_param_last(snd_pcm_hw_pa
  * values < maximum. Reduce configuration space accordingly.
  * Return the maximum.
  */
-int snd_pcm_hw_param_last(snd_pcm_t *pcm, 
-			  snd_pcm_hw_params_t *params,
-			  snd_pcm_hw_param_t var, int *dir)
+static int snd_pcm_hw_param_last(snd_pcm_t *pcm, 
+				 snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_param_t var, int *dir)
 {
 	int changed = _snd_pcm_hw_param_last(params, var);
 	if (changed < 0)
@@ -1437,8 +1444,9 @@ int _snd_pcm_hw_param_min(snd_pcm_hw_par
  * values < VAL. Reduce configuration space accordingly.
  * Return new minimum or -EINVAL if the configuration space is empty
  */
-int snd_pcm_hw_param_min(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
-			 snd_pcm_hw_param_t var, unsigned int val, int *dir)
+static int snd_pcm_hw_param_min(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+				snd_pcm_hw_param_t var, unsigned int val,
+				int *dir)
 {
 	int changed = _snd_pcm_hw_param_min(params, var, val, dir ? *dir : 0);
 	if (changed < 0)
@@ -1451,8 +1459,9 @@ int snd_pcm_hw_param_min(snd_pcm_t *pcm,
 	return snd_pcm_hw_param_value_min(params, var, dir);
 }
 
-int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var, unsigned int val, int dir)
+static int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_param_t var, unsigned int val,
+				 int dir)
 {
 	int changed;
 	int open = 0;
@@ -1490,8 +1499,9 @@ int _snd_pcm_hw_param_max(snd_pcm_hw_par
  *  values >= VAL + 1. Reduce configuration space accordingly.
  *  Return new maximum or -EINVAL if the configuration space is empty
  */
-int snd_pcm_hw_param_max(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
-			  snd_pcm_hw_param_t var, unsigned int val, int *dir)
+static int snd_pcm_hw_param_max(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+				snd_pcm_hw_param_t var, unsigned int val,
+				int *dir)
 {
 	int changed = _snd_pcm_hw_param_max(params, var, val, dir ? *dir : 0);
 	if (changed < 0)
@@ -2564,9 +2574,6 @@ snd_pcm_sframes_t snd_pcm_lib_readv(snd_
 EXPORT_SYMBOL(snd_interval_refine);
 EXPORT_SYMBOL(snd_interval_list);
 EXPORT_SYMBOL(snd_interval_ratnum);
-EXPORT_SYMBOL(snd_interval_muldivk);
-EXPORT_SYMBOL(snd_interval_mulkdiv);
-EXPORT_SYMBOL(snd_interval_div);
 EXPORT_SYMBOL(_snd_pcm_hw_params_any);
 EXPORT_SYMBOL(_snd_pcm_hw_param_min);
 EXPORT_SYMBOL(_snd_pcm_hw_param_set);
@@ -2580,7 +2587,6 @@ EXPORT_SYMBOL(snd_pcm_hw_param_last);
 EXPORT_SYMBOL(snd_pcm_hw_param_near);
 EXPORT_SYMBOL(snd_pcm_hw_param_set);
 EXPORT_SYMBOL(snd_pcm_hw_refine);
-EXPORT_SYMBOL(snd_pcm_hw_params);
 EXPORT_SYMBOL(snd_pcm_hw_constraints_init);
 EXPORT_SYMBOL(snd_pcm_hw_constraints_complete);
 EXPORT_SYMBOL(snd_pcm_hw_constraint_list);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/pcm_native.c linux/sound/core/pcm_native.c
--- linux-2.6.11/sound/core/pcm_native.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/core/pcm_native.c	2005-05-31 15:29:42.000000000 +0200
@@ -337,8 +337,8 @@ out:
 	return err;
 }
 
-int snd_pcm_hw_params(snd_pcm_substream_t *substream,
-		      snd_pcm_hw_params_t *params)
+static int snd_pcm_hw_params(snd_pcm_substream_t *substream,
+			     snd_pcm_hw_params_t *params)
 {
 	snd_pcm_runtime_t *runtime;
 	int err;
@@ -1368,43 +1368,32 @@ static int snd_pcm_drain(snd_pcm_substre
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	down_read(&snd_pcm_link_rwsem);
 	snd_power_lock(card);
 	if (runtime->status->state == SNDRV_PCM_STATE_SUSPENDED) {
 		result = snd_power_wait(card, SNDRV_CTL_POWER_D0, substream->ffile);
-		if (result < 0)
-			goto _unlock;
+		if (result < 0) {
+			snd_power_unlock(card);
+			return result;
+		}
 	}
 
 	/* allocate temporary record for drain sync */
+	down_read(&snd_pcm_link_rwsem);
 	if (snd_pcm_stream_linked(substream)) {
 		drec = kmalloc(substream->group->count * sizeof(*drec), GFP_KERNEL);
 		if (! drec) {
-			result = -ENOMEM;
-			goto _unlock;
+			up_read(&snd_pcm_link_rwsem);
+			snd_power_unlock(card);
+			return -ENOMEM;
 		}
 	} else
 		drec = &drec_tmp;
 
-	snd_pcm_stream_lock_irq(substream);
-	/* resume pause */
-	if (runtime->status->state == SNDRV_PCM_STATE_PAUSED)
-		snd_pcm_pause(substream, 0);
-
-	/* pre-start/stop - all running streams are changed to DRAINING state */
-	result = snd_pcm_action(&snd_pcm_action_drain_init, substream, 0);
-	if (result < 0)
-		goto _end;
-
-	/* check streams with PLAYBACK & DRAINING */
+	/* count only playback streams */
 	num_drecs = 0;
 	snd_pcm_group_for_each(pos, substream) {
 		snd_pcm_substream_t *s = snd_pcm_group_substream_entry(pos);
 		runtime = s->runtime;
-		if (runtime->status->state != SNDRV_PCM_STATE_DRAINING) {
-			runtime->status->state = SNDRV_PCM_STATE_SETUP;
-			continue;
-		}
 		if (s->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			d = &drec[num_drecs++];
 			d->substream = s;
@@ -1418,9 +1407,21 @@ static int snd_pcm_drain(snd_pcm_substre
 				runtime->stop_threshold = runtime->buffer_size;
 		}
 	}
-
+	up_read(&snd_pcm_link_rwsem);
 	if (! num_drecs)
-		goto _end;
+		goto _error;
+
+	snd_pcm_stream_lock_irq(substream);
+	/* resume pause */
+	if (runtime->status->state == SNDRV_PCM_STATE_PAUSED)
+		snd_pcm_pause(substream, 0);
+
+	/* pre-start/stop - all running streams are changed to DRAINING state */
+	result = snd_pcm_action(&snd_pcm_action_drain_init, substream, 0);
+	if (result < 0) {
+		snd_pcm_stream_unlock_irq(substream);
+		goto _error;
+	}
 
 	for (;;) {
 		long tout;
@@ -1428,6 +1429,15 @@ static int snd_pcm_drain(snd_pcm_substre
 			result = -ERESTARTSYS;
 			break;
 		}
+		/* all finished? */
+		for (i = 0; i < num_drecs; i++) {
+			runtime = drec[i].substream->runtime;
+			if (runtime->status->state == SNDRV_PCM_STATE_DRAINING)
+				break;
+		}
+		if (i == num_drecs)
+			break; /* yes, all drained */
+
 		set_current_state(TASK_INTERRUPTIBLE);
 		snd_pcm_stream_unlock_irq(substream);
 		snd_power_unlock(card);
@@ -1444,15 +1454,11 @@ static int snd_pcm_drain(snd_pcm_substre
 			}
 			break;
 		}
-		/* all finished? */
-		for (i = 0; i < num_drecs; i++) {
-			runtime = drec[i].substream->runtime;
-			if (runtime->status->state == SNDRV_PCM_STATE_DRAINING)
-				break;
-		}
-		if (i == num_drecs)
-			break;
 	}
+
+	snd_pcm_stream_unlock_irq(substream);
+
+ _error:
 	for (i = 0; i < num_drecs; i++) {
 		d = &drec[i];
 		runtime = d->substream->runtime;
@@ -1460,13 +1466,9 @@ static int snd_pcm_drain(snd_pcm_substre
 		runtime->stop_threshold = d->stop_threshold;
 	}
 
- _end:
-	snd_pcm_stream_unlock_irq(substream);
 	if (drec != &drec_tmp)
 		kfree(drec);
- _unlock:
 	snd_power_unlock(card);
-	up_read(&snd_pcm_link_rwsem);
 
 	return result;
 }
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/seq/oss/seq_oss_synth.c linux/sound/core/seq/oss/seq_oss_synth.c
--- linux-2.6.11/sound/core/seq/oss/seq_oss_synth.c	2005-06-03 15:53:54.000000000 +0200
+++ linux/sound/core/seq/oss/seq_oss_synth.c	2005-05-30 18:28:30.000000000 +0200
@@ -325,14 +325,10 @@ snd_seq_oss_synth_cleanup(seq_oss_devinf
 			}
 			snd_use_lock_free(&rec->use_lock);
 		}
-		if (info->sysex) {
-			kfree(info->sysex);
-			info->sysex = NULL;
-		}
-		if (info->ch) {
-			kfree(info->ch);
-			info->ch = NULL;
-		}
+		kfree(info->sysex);
+		info->sysex = NULL;
+		kfree(info->ch);
+		info->ch = NULL;
 	}
 	dp->synth_opened = 0;
 	dp->max_synthdev = 0;
@@ -418,14 +414,10 @@ snd_seq_oss_synth_reset(seq_oss_devinfo_
 					  dp->file_mode) < 0) {
 			midi_synth_dev.opened--;
 			info->opened = 0;
-			if (info->sysex) {
-				kfree(info->sysex);
-				info->sysex = NULL;
-			}
-			if (info->ch) {
-				kfree(info->ch);
-				info->ch = NULL;
-			}
+			kfree(info->sysex);
+			info->sysex = NULL;
+			kfree(info->ch);
+			info->ch = NULL;
 		}
 		return;
 	}
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/seq/seq_dummy.c linux/sound/core/seq/seq_dummy.c
--- linux-2.6.11/sound/core/seq/seq_dummy.c	2005-06-03 15:53:56.000000000 +0200
+++ linux/sound/core/seq/seq_dummy.c	2005-05-30 18:28:30.000000000 +0200
@@ -140,10 +140,7 @@ dummy_input(snd_seq_event_t *ev, int dir
 static void
 dummy_free(void *private_data)
 {
-	snd_seq_dummy_port_t *p;
-
-	p = private_data;
-	kfree(p);
+	kfree(private_data);
 }
 
 /*
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/seq/seq_midi_event.c linux/sound/core/seq/seq_midi_event.c
--- linux-2.6.11/sound/core/seq/seq_midi_event.c	2005-06-03 15:53:55.000000000 +0200
+++ linux/sound/core/seq/seq_midi_event.c	2005-05-18 18:54:12.000000000 +0200
@@ -171,11 +171,13 @@ void snd_midi_event_reset_decode(snd_mid
 	spin_unlock_irqrestore(&dev->lock, flags);
 }
 
+#if 0
 void snd_midi_event_init(snd_midi_event_t *dev)
 {
 	snd_midi_event_reset_encode(dev);
 	snd_midi_event_reset_decode(dev);
 }
+#endif  /*  0  */
 
 void snd_midi_event_no_status(snd_midi_event_t *dev, int on)
 {
@@ -185,6 +187,7 @@ void snd_midi_event_no_status(snd_midi_e
 /*
  * resize buffer
  */
+#if 0
 int snd_midi_event_resize_buffer(snd_midi_event_t *dev, int bufsize)
 {
 	unsigned char *new_buf, *old_buf;
@@ -204,6 +207,7 @@ int snd_midi_event_resize_buffer(snd_mid
 	kfree(old_buf);
 	return 0;
 }
+#endif  /*  0  */
 
 /*
  *  read bytes and encode to sequencer event if finished
@@ -517,8 +521,6 @@ static int extra_decode_xrpn(snd_midi_ev
  
 EXPORT_SYMBOL(snd_midi_event_new);
 EXPORT_SYMBOL(snd_midi_event_free);
-EXPORT_SYMBOL(snd_midi_event_resize_buffer);
-EXPORT_SYMBOL(snd_midi_event_init);
 EXPORT_SYMBOL(snd_midi_event_reset_encode);
 EXPORT_SYMBOL(snd_midi_event_reset_decode);
 EXPORT_SYMBOL(snd_midi_event_no_status);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/seq/seq_queue.c linux/sound/core/seq/seq_queue.c
--- linux-2.6.11/sound/core/seq/seq_queue.c	2005-06-03 15:53:55.000000000 +0200
+++ linux/sound/core/seq/seq_queue.c	2005-05-18 18:54:12.000000000 +0200
@@ -672,7 +672,8 @@ static void queue_broadcast_event(queue_
  * process a received queue-control event.
  * this function is exported for seq_sync.c.
  */
-void snd_seq_queue_process_event(queue_t *q, snd_seq_event_t *ev, int atomic, int hop)
+static void snd_seq_queue_process_event(queue_t *q, snd_seq_event_t *ev,
+					int atomic, int hop)
 {
 	switch (ev->type) {
 	case SNDRV_SEQ_EVENT_START:
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/seq/seq_queue.h linux/sound/core/seq/seq_queue.h
--- linux-2.6.11/sound/core/seq/seq_queue.h	2005-06-03 15:53:55.000000000 +0200
+++ linux/sound/core/seq/seq_queue.h	2005-05-18 18:54:12.000000000 +0200
@@ -111,7 +111,6 @@ int snd_seq_queue_use(int queueid, int c
 int snd_seq_queue_is_used(int queueid, int client);
 
 int snd_seq_control_queue(snd_seq_event_t *ev, int atomic, int hop);
-void snd_seq_queue_process_event(queue_t *q, snd_seq_event_t *ev, int atomic, int hop);
 
 /*
  * 64bit division - for sync stuff..
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/seq/seq_timer.c linux/sound/core/seq/seq_timer.c
--- linux-2.6.11/sound/core/seq/seq_timer.c	2005-03-02 08:38:38.000000000 +0100
+++ linux/sound/core/seq/seq_timer.c	2005-05-18 18:54:12.000000000 +0200
@@ -36,7 +36,8 @@ extern int seq_default_timer_resolution;
 
 #define SKEW_BASE	0x10000	/* 16bit shift */
 
-void snd_seq_timer_set_tick_resolution(seq_timer_tick_t *tick, int tempo, int ppq, int nticks)
+static void snd_seq_timer_set_tick_resolution(seq_timer_tick_t *tick,
+					      int tempo, int ppq, int nticks)
 {
 	if (tempo < 1000000)
 		tick->resolution = (tempo * 1000) / ppq;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/seq/seq_timer.h linux/sound/core/seq/seq_timer.h
--- linux-2.6.11/sound/core/seq/seq_timer.h	2005-03-02 08:38:13.000000000 +0100
+++ linux/sound/core/seq/seq_timer.h	2005-05-18 18:54:12.000000000 +0200
@@ -64,8 +64,6 @@ extern seq_timer_t *snd_seq_timer_new(vo
 /* delete timer (destructor) */
 extern void snd_seq_timer_delete(seq_timer_t **tmr);
 
-void snd_seq_timer_set_tick_resolution(seq_timer_tick_t *tick, int tempo, int ppq, int nticks);
-
 /* */
 static inline void snd_seq_timer_update_tick(seq_timer_tick_t *tick, unsigned long resolution)
 {
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/seq/seq_virmidi.c linux/sound/core/seq/seq_virmidi.c
--- linux-2.6.11/sound/core/seq/seq_virmidi.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/core/seq/seq_virmidi.c	2005-05-18 18:54:12.000000000 +0200
@@ -110,7 +110,7 @@ static int snd_virmidi_dev_receive_event
  * handler of a remote port which is attached to the virmidi via
  * SNDRV_VIRMIDI_SEQ_ATTACH.
  */
-/* exported */
+#if 0
 int snd_virmidi_receive(snd_rawmidi_t *rmidi, snd_seq_event_t *ev)
 {
 	snd_virmidi_dev_t *rdev;
@@ -118,6 +118,7 @@ int snd_virmidi_receive(snd_rawmidi_t *r
 	rdev = rmidi->private_data;
 	return snd_virmidi_dev_receive_event(rdev, ev);
 }
+#endif  /*  0  */
 
 /*
  * event handler of virmidi port
@@ -548,4 +549,3 @@ module_init(alsa_virmidi_init)
 module_exit(alsa_virmidi_exit)
 
 EXPORT_SYMBOL(snd_virmidi_new);
-EXPORT_SYMBOL(snd_virmidi_receive);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/sound.c linux/sound/core/sound.c
--- linux-2.6.11/sound/core/sound.c	2005-06-03 15:53:56.000000000 +0200
+++ linux/sound/core/sound.c	2005-05-18 18:54:12.000000000 +0200
@@ -431,7 +431,6 @@ EXPORT_SYMBOL(snd_card_pci_resume);
 EXPORT_SYMBOL(snd_device_new);
 EXPORT_SYMBOL(snd_device_register);
 EXPORT_SYMBOL(snd_device_free);
-EXPORT_SYMBOL(snd_device_free_all);
   /* isadma.c */
 #ifdef CONFIG_ISA
 EXPORT_SYMBOL(snd_dma_program);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/timer.c linux/sound/core/timer.c
--- linux-2.6.11/sound/core/timer.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/core/timer.c	2005-05-30 18:28:30.000000000 +0200
@@ -845,7 +845,7 @@ int snd_timer_dev_register(snd_device_t 
 	return 0;
 }
 
-int snd_timer_unregister(snd_timer_t *timer)
+static int snd_timer_unregister(snd_timer_t *timer)
 {
 	struct list_head *p, *n;
 	snd_timer_instance_t *ti;
@@ -946,11 +946,6 @@ struct snd_timer_system_private {
 	unsigned long correction;
 };
 
-unsigned int snd_timer_system_resolution(void)
-{
-	return 1000000000L / HZ;
-}
-
 static void snd_timer_s_function(unsigned long data)
 {
 	snd_timer_t *timer = (snd_timer_t *)data;
@@ -1474,14 +1469,10 @@ static int snd_timer_user_tselect(struct
 	if ((err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid)) < 0)
 		goto __err;
 
-	if (tu->queue) {
-		kfree(tu->queue);
-		tu->queue = NULL;
-	}
-	if (tu->tqueue) {
-		kfree(tu->tqueue);
-		tu->tqueue = NULL;
-	}
+	kfree(tu->queue);
+	tu->queue = NULL;
+	kfree(tu->tqueue);
+	tu->tqueue = NULL;
 	if (tu->tread) {
 		tu->tqueue = (snd_timer_tread_t *)kmalloc(tu->queue_size * sizeof(snd_timer_tread_t), GFP_KERNEL);
 		if (tu->tqueue == NULL)
@@ -1938,4 +1929,3 @@ EXPORT_SYMBOL(snd_timer_global_free);
 EXPORT_SYMBOL(snd_timer_global_register);
 EXPORT_SYMBOL(snd_timer_global_unregister);
 EXPORT_SYMBOL(snd_timer_interrupt);
-EXPORT_SYMBOL(snd_timer_system_resolution);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/drivers/vx/vx_pcm.c linux/sound/drivers/vx/vx_pcm.c
--- linux-2.6.11/sound/drivers/vx/vx_pcm.c	2005-03-02 08:37:48.000000000 +0100
+++ linux/sound/drivers/vx/vx_pcm.c	2005-05-30 18:28:31.000000000 +0200
@@ -1264,14 +1264,10 @@ static void snd_vx_pcm_free(snd_pcm_t *p
 {
 	vx_core_t *chip = pcm->private_data;
 	chip->pcm[pcm->device] = NULL;
-	if (chip->playback_pipes) {
-		kfree(chip->playback_pipes);
-		chip->playback_pipes = NULL;
-	}
-	if (chip->capture_pipes) {
-		kfree(chip->capture_pipes);
-		chip->capture_pipes = NULL;
-	}
+	kfree(chip->playback_pipes);
+	chip->playback_pipes = NULL;
+	kfree(chip->capture_pipes);
+	chip->capture_pipes = NULL;
 }
 
 /*
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/i2c/tea6330t.c linux/sound/i2c/tea6330t.c
--- linux-2.6.11/sound/i2c/tea6330t.c	2005-03-02 08:38:09.000000000 +0100
+++ linux/sound/i2c/tea6330t.c	2005-05-30 18:28:31.000000000 +0200
@@ -266,8 +266,7 @@ TEA6330T_TREBLE("Tone Control - Treble",
 
 static void snd_tea6330_free(snd_i2c_device_t *device)
 {
-	tea6330t_t *tea = device->private_data;
-	kfree(tea);
+	kfree(device->private_data);
 }
                                         
 int snd_tea6330t_update_mixer(snd_card_t * card,
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/Kconfig linux/sound/isa/Kconfig
--- linux-2.6.11/sound/isa/Kconfig	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/isa/Kconfig	2005-05-27 16:01:55.000000000 +0200
@@ -164,6 +164,7 @@ config SND_INTERWAVE
 	select SND_RAWMIDI
 	select SND_CS4231_LIB
 	select SND_GUS_SYNTH
+	select ISAPNP
 	help
 	  Say Y here to include support for AMD InterWave based
 	  soundcards (Gravis UltraSound Plug & Play, STB SoundRage32,
@@ -178,6 +179,7 @@ config SND_INTERWAVE_STB
 	select SND_RAWMIDI
 	select SND_CS4231_LIB
 	select SND_GUS_SYNTH
+	select ISAPNP
 	help
 	  Say Y here to include support for AMD InterWave based
 	  soundcards with a TEA6330T bass and treble regulator
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/cs423x/cs4236.c linux/sound/isa/cs423x/cs4236.c
--- linux-2.6.11/sound/isa/cs423x/cs4236.c	2005-03-02 08:37:48.000000000 +0100
+++ linux/sound/isa/cs423x/cs4236.c	2005-06-03 12:25:54.000000000 +0200
@@ -349,8 +349,7 @@ static int __devinit snd_card_cs4236_pnp
 		pnp_init_resource_table(cfg);
 		if (mpu_port[dev] != SNDRV_AUTO_PORT)
 			pnp_resource_change(&cfg->port_resource[0], mpu_port[dev], 2);
-		if (mpu_irq[dev] != SNDRV_AUTO_IRQ && mpu_irq[dev] >= 0 &&
-		    pnp_irq_valid(pdev, 0))
+		if (mpu_irq[dev] != SNDRV_AUTO_IRQ && mpu_irq[dev] >= 0)
 			pnp_resource_change(&cfg->irq_resource[0], mpu_irq[dev], 1);
 		err = pnp_manual_config_dev(pdev, cfg, 0);
 		if (err < 0)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/gus/gus_io.c linux/sound/isa/gus/gus_io.c
--- linux-2.6.11/sound/isa/gus/gus_io.c	2005-03-02 08:38:38.000000000 +0100
+++ linux/sound/isa/gus/gus_io.c	2005-05-23 11:27:13.000000000 +0200
@@ -244,6 +244,8 @@ unsigned short snd_gf1_i_look16(snd_gus_
 	return res;
 }
 
+#if 0
+
 void snd_gf1_i_adlib_write(snd_gus_card_t * gus,
 		           unsigned char reg,
 		           unsigned char data)
@@ -265,6 +267,8 @@ void snd_gf1_i_write_addr(snd_gus_card_t
 	spin_unlock_irqrestore(&gus->reg_lock, flags);
 }
 
+#endif  /*  0  */
+
 unsigned int snd_gf1_i_read_addr(snd_gus_card_t * gus,
 				 unsigned char reg, short w_16bit)
 {
@@ -329,6 +333,8 @@ unsigned char snd_gf1_peek(snd_gus_card_
 	return res;
 }
 
+#if 0
+
 void snd_gf1_pokew(snd_gus_card_t * gus, unsigned int addr, unsigned short data)
 {
 	unsigned long flags;
@@ -405,9 +411,7 @@ void snd_gf1_dram_setmem(snd_gus_card_t 
 	spin_unlock_irqrestore(&gus->reg_lock, flags);
 }
 
-/*
-
- */
+#endif  /*  0  */
 
 void snd_gf1_select_active_voices(snd_gus_card_t * gus)
 {
@@ -469,6 +473,8 @@ void snd_gf1_print_voice_registers(snd_g
 		printk(" -%i- GF1  pan                    = 0x%x\n", voice, snd_gf1_i_read8(gus, 0x0c));
 }
 
+#if 0
+
 void snd_gf1_print_global_registers(snd_gus_card_t * gus)
 {
 	unsigned char global_mode = 0x00;
@@ -528,4 +534,6 @@ void snd_gf1_peek_print_block(snd_gus_ca
 	}
 }
 
+#endif  /*  0  */
+
 #endif
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/gus/gus_main.c linux/sound/isa/gus/gus_main.c
--- linux-2.6.11/sound/isa/gus/gus_main.c	2005-03-02 08:37:48.000000000 +0100
+++ linux/sound/isa/gus/gus_main.c	2005-05-23 11:27:13.000000000 +0200
@@ -459,7 +459,6 @@ EXPORT_SYMBOL(snd_gf1_write16);
 EXPORT_SYMBOL(snd_gf1_look16);
 EXPORT_SYMBOL(snd_gf1_i_write8);
 EXPORT_SYMBOL(snd_gf1_i_look8);
-EXPORT_SYMBOL(snd_gf1_i_write16);
 EXPORT_SYMBOL(snd_gf1_i_look16);
 EXPORT_SYMBOL(snd_gf1_dram_addr);
 EXPORT_SYMBOL(snd_gf1_write_addr);
@@ -470,8 +469,6 @@ EXPORT_SYMBOL(snd_gf1_alloc_voice);
 EXPORT_SYMBOL(snd_gf1_free_voice);
 EXPORT_SYMBOL(snd_gf1_ctrl_stop);
 EXPORT_SYMBOL(snd_gf1_stop_voice);
-EXPORT_SYMBOL(snd_gf1_start);
-EXPORT_SYMBOL(snd_gf1_stop);
   /* gus_mixer.c */
 EXPORT_SYMBOL(snd_gf1_new_mixer);
   /* gus_pcm.c */
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/gus/gus_mem.c linux/sound/isa/gus/gus_mem.c
--- linux-2.6.11/sound/isa/gus/gus_mem.c	2005-03-02 08:38:07.000000000 +0100
+++ linux/sound/isa/gus/gus_mem.c	2005-05-23 11:27:13.000000000 +0200
@@ -39,8 +39,8 @@ void snd_gf1_mem_lock(snd_gf1_mem_t * al
 	}
 }
 
-snd_gf1_mem_block_t *snd_gf1_mem_xalloc(snd_gf1_mem_t * alloc,
-				        snd_gf1_mem_block_t * block)
+static snd_gf1_mem_block_t *snd_gf1_mem_xalloc(snd_gf1_mem_t * alloc,
+					       snd_gf1_mem_block_t * block)
 {
 	snd_gf1_mem_block_t *pblock, *nblock;
 
@@ -105,8 +105,8 @@ int snd_gf1_mem_xfree(snd_gf1_mem_t * al
 	return 0;
 }
 
-snd_gf1_mem_block_t *snd_gf1_mem_look(snd_gf1_mem_t * alloc,
-				      unsigned int address)
+static snd_gf1_mem_block_t *snd_gf1_mem_look(snd_gf1_mem_t * alloc,
+					     unsigned int address)
 {
 	snd_gf1_mem_block_t *block;
 
@@ -118,8 +118,8 @@ snd_gf1_mem_block_t *snd_gf1_mem_look(sn
 	return NULL;
 }
 
-snd_gf1_mem_block_t *snd_gf1_mem_share(snd_gf1_mem_t * alloc,
-				       unsigned int *share_id)
+static snd_gf1_mem_block_t *snd_gf1_mem_share(snd_gf1_mem_t * alloc,
+					      unsigned int *share_id)
 {
 	snd_gf1_mem_block_t *block;
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/gus/gus_pcm.c linux/sound/isa/gus/gus_pcm.c
--- linux-2.6.11/sound/isa/gus/gus_pcm.c	2005-06-03 15:53:54.000000000 +0200
+++ linux/sound/isa/gus/gus_pcm.c	2005-05-30 18:28:31.000000000 +0200
@@ -656,8 +656,7 @@ static snd_pcm_hardware_t snd_gf1_pcm_ca
 
 static void snd_gf1_pcm_playback_free(snd_pcm_runtime_t *runtime)
 {
-	gus_pcm_private_t * pcmp = runtime->private_data;
-	kfree(pcmp);
+	kfree(runtime->private_data);
 }
 
 static int snd_gf1_pcm_playback_open(snd_pcm_substream_t *substream)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/gus/gus_reset.c linux/sound/isa/gus/gus_reset.c
--- linux-2.6.11/sound/isa/gus/gus_reset.c	2005-06-03 15:53:54.000000000 +0200
+++ linux/sound/isa/gus/gus_reset.c	2005-05-23 11:27:13.000000000 +0200
@@ -161,7 +161,8 @@ void snd_gf1_stop_voice(snd_gus_card_t *
 #endif
 }
 
-void snd_gf1_clear_voices(snd_gus_card_t * gus, unsigned short v_min, unsigned short v_max)
+static void snd_gf1_clear_voices(snd_gus_card_t * gus, unsigned short v_min,
+				 unsigned short v_max)
 {
 	unsigned long flags;
 	unsigned int daddr;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/gus/gus_synth.c linux/sound/isa/gus/gus_synth.c
--- linux-2.6.11/sound/isa/gus/gus_synth.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/isa/gus/gus_synth.c	2005-05-23 11:27:13.000000000 +0200
@@ -99,7 +99,8 @@ static void snd_gus_synth_free_private_i
 	snd_seq_instr_list_free_cond(p->gus->gf1.ilist, &ifree, client, 0);
 }
  
-int snd_gus_synth_event_input(snd_seq_event_t *ev, int direct, void *private_data, int atomic, int hop)
+static int snd_gus_synth_event_input(snd_seq_event_t *ev, int direct,
+				     void *private_data, int atomic, int hop)
 {
 	snd_gus_port_t * p = (snd_gus_port_t *) private_data;
 	
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/gus/gus_tables.h linux/sound/isa/gus/gus_tables.h
--- linux-2.6.11/sound/isa/gus/gus_tables.h	2005-03-02 08:38:10.000000000 +0100
+++ linux/sound/isa/gus/gus_tables.h	2005-05-23 11:27:13.000000000 +0200
@@ -23,6 +23,8 @@
 
 #ifdef __GUS_TABLES_ALLOC__
 
+#if 0
+
 unsigned int snd_gf1_scale_table[SNDRV_GF1_SCALE_TABLE_SIZE] =
 {
       8372,      8870,      9397,      9956,     10548,     11175,
@@ -49,6 +51,8 @@ unsigned int snd_gf1_scale_table[SNDRV_G
   12123977,  12844906
 };
 
+#endif  /*  0  */
+
 unsigned short snd_gf1_atten_table[SNDRV_GF1_ATTEN_TABLE_SIZE] = {
   4095 /* 0   */,1789 /* 1   */,1533 /* 2   */,1383 /* 3   */,1277 /* 4   */,
   1195 /* 5   */,1127 /* 6   */,1070 /* 7   */,1021 /* 8   */,978  /* 9   */,
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/gus/gus_volume.c linux/sound/isa/gus/gus_volume.c
--- linux-2.6.11/sound/isa/gus/gus_volume.c	2005-03-02 08:37:51.000000000 +0100
+++ linux/sound/isa/gus/gus_volume.c	2005-05-23 11:27:13.000000000 +0200
@@ -55,6 +55,8 @@ unsigned short snd_gf1_lvol_to_gvol_raw(
 	return (e << 8) | m;
 }
 
+#if 0
+
 unsigned int snd_gf1_gvol_to_lvol_raw(unsigned short gf1_vol)
 {
 	unsigned int rvol;
@@ -108,6 +110,8 @@ unsigned int snd_gf1_calc_ramp_rate(snd_
 	return (range << 6) | (increment & 0x3f);
 }
 
+#endif  /*  0  */
+
 unsigned short snd_gf1_translate_freq(snd_gus_card_t * gus, unsigned int freq16)
 {
 	freq16 >>= 3;
@@ -120,6 +124,8 @@ unsigned short snd_gf1_translate_freq(sn
 	return ((freq16 << 9) + (gus->gf1.playback_freq >> 1)) / gus->gf1.playback_freq;
 }
 
+#if 0
+
 short snd_gf1_compute_vibrato(short cents, unsigned short fc_register)
 {
 	static short vibrato_table[] =
@@ -208,3 +214,5 @@ unsigned short snd_gf1_compute_freq(unsi
 	}
 	return (unsigned short) fc;
 }
+
+#endif  /*  0  */
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/Kconfig linux/sound/pci/Kconfig
--- linux-2.6.11/sound/pci/Kconfig	2005-06-03 15:53:54.000000000 +0200
+++ linux/sound/pci/Kconfig	2005-06-03 12:21:07.000000000 +0200
@@ -274,6 +274,19 @@ config SND_HDSP
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-hdsp.
 
+config SND_HDSPM
+	tristate "RME Hammerfall DSP MADI"
+	depends on SND
+	select SND_HWDEP
+	select SND_RAWMIDI
+	select SND_PCM
+	help
+	  Say Y here to include support for RME Hammerfall DSP MADI
+	  soundcards.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-hdspm.
+
 config SND_TRIDENT
 	tristate "Trident 4D-Wave DX/NX; SiS 7018"
 	depends on SND
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ac97/ac97_codec.c linux/sound/pci/ac97/ac97_codec.c
--- linux-2.6.11/sound/pci/ac97/ac97_codec.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/ac97/ac97_codec.c	2005-05-30 17:43:09.000000000 +0200
@@ -150,7 +150,7 @@ static const ac97_codec_id_t snd_ac97_co
 { 0x4e534331, 0xffffffff, "LM4549",		NULL,		NULL },
 { 0x4e534350, 0xffffffff, "LM4550",		NULL,		NULL },
 { 0x50534304, 0xffffffff, "UCB1400",		NULL,		NULL },
-{ 0x53494c20, 0xffffffe0, "Si3036,8",		NULL,		mpatch_si3036 },
+{ 0x53494c20, 0xffffffe0, "Si3036,8",		mpatch_si3036,	mpatch_si3036, AC97_MODEM_PATCH },
 { 0x54524102, 0xffffffff, "TR28022",		NULL,		NULL },
 { 0x54524106, 0xffffffff, "TR28026",		NULL,		NULL },
 { 0x54524108, 0xffffffff, "TR28028",		patch_tritech_tr28028,	NULL }, // added by xin jin [07/09/99]
@@ -666,6 +666,11 @@ AC97_SINGLE("LFE Playback Volume", AC97_
 static const snd_kcontrol_new_t snd_ac97_control_eapd =
 AC97_SINGLE("External Amplifier", AC97_POWERDOWN, 15, 1, 1);
 
+static const snd_kcontrol_new_t snd_ac97_controls_modem_switches[2] = {
+AC97_SINGLE("Off-hook Switch", AC97_GPIO_STATUS, 0, 1, 0),
+AC97_SINGLE("Caller ID Switch", AC97_GPIO_STATUS, 2, 1, 0)
+};
+
 /* change the existing EAPD control as inverted */
 static void set_inv_eapd(ac97_t *ac97, snd_kcontrol_t *kctl)
 {
@@ -1526,13 +1531,25 @@ static int snd_ac97_mixer_build(ac97_t *
 
 static int snd_ac97_modem_build(snd_card_t * card, ac97_t * ac97)
 {
-	/* TODO */
+	int err, idx;
+
 	//printk("AC97_GPIO_CFG = %x\n",snd_ac97_read(ac97,AC97_GPIO_CFG));
 	snd_ac97_write(ac97, AC97_GPIO_CFG, 0xffff & ~(AC97_GPIO_LINE1_OH));
 	snd_ac97_write(ac97, AC97_GPIO_POLARITY, 0xffff & ~(AC97_GPIO_LINE1_OH));
 	snd_ac97_write(ac97, AC97_GPIO_STICKY, 0xffff);
 	snd_ac97_write(ac97, AC97_GPIO_WAKEUP, 0x0);
 	snd_ac97_write(ac97, AC97_MISC_AFE, 0x0);
+
+	/* build modem switches */
+	for (idx = 0; idx < ARRAY_SIZE(snd_ac97_controls_modem_switches); idx++)
+		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_modem_switches[idx], ac97))) < 0)
+			return err;
+
+	/* build chip specific controls */
+	if (ac97->build_ops->build_specific)
+		if ((err = ac97->build_ops->build_specific(ac97)) < 0)
+			return err;
+
 	return 0;
 }
 
@@ -2525,11 +2542,11 @@ int snd_ac97_tune_hardware(ac97_t *ac97,
 		return result;
 	}
 
-	for (; quirk->vendor; quirk++) {
-		if (quirk->vendor != ac97->subsystem_vendor)
+	for (; quirk->subvendor; quirk++) {
+		if (quirk->subvendor != ac97->subsystem_vendor)
 			continue;
-		if ((! quirk->mask && quirk->device == ac97->subsystem_device) ||
-		    quirk->device == (quirk->mask & ac97->subsystem_device)) {
+		if ((! quirk->mask && quirk->subdevice == ac97->subsystem_device) ||
+		    quirk->subdevice == (quirk->mask & ac97->subsystem_device)) {
 			if (quirk->codec_id && quirk->codec_id != ac97->id)
 				continue;
 			snd_printdd("ac97 quirk for %s (%04x:%04x)\n", quirk->name, ac97->subsystem_vendor, ac97->subsystem_device);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ac97/ac97_patch.c linux/sound/pci/ac97/ac97_patch.c
--- linux-2.6.11/sound/pci/ac97/ac97_patch.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/ac97/ac97_patch.c	2005-05-30 17:43:09.000000000 +0200
@@ -1604,8 +1604,8 @@ static void ad1985_update_jacks(ac97_t *
 	/* shared Mic */
 	snd_ac97_update_bits(ac97, AC97_AD_MISC, 1 << 11,
 			     is_shared_micin(ac97) ? 0 : 1 << 11);
-	snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 9 << 11,
-			     is_shared_micin(ac97) ? 0 : 9 << 11);
+	snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 1 << 9,
+			     is_shared_micin(ac97) ? 0 : 1 << 9);
 }
 
 static int patch_ad1985_specific(ac97_t *ac97)
@@ -2459,12 +2459,29 @@ int patch_it2646(ac97_t * ac97)
 	return 0;
 }
 
-/* Si3036/8 specific registers */
+/*
+ * Si3036 codec
+ */
+
 #define AC97_SI3036_CHIP_ID     0x5a
+#define AC97_SI3036_LINE_CFG    0x5c
+
+static const snd_kcontrol_new_t snd_ac97_controls_si3036[] = {
+AC97_DOUBLE("Modem Speaker Volume", 0x5c, 14, 12, 3, 1)
+};
+
+static int patch_si3036_specific(ac97_t * ac97)
+{
+	return patch_build_controls(ac97, snd_ac97_controls_si3036, ARRAY_SIZE(snd_ac97_controls_si3036));
+}
+
+static struct snd_ac97_build_ops patch_si3036_ops = {
+	.build_specific	= patch_si3036_specific,
+};
 
 int mpatch_si3036(ac97_t * ac97)
 {
-	//printk("mpatch_si3036: chip id = %x\n", snd_ac97_read(ac97, 0x5a));
+	ac97->build_ops = &patch_si3036_ops;
 	snd_ac97_write_cache(ac97, 0x5c, 0xf210 );
 	snd_ac97_write_cache(ac97, 0x68, 0);
 	return 0;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ali5451/ali5451.c linux/sound/pci/ali5451/ali5451.c
--- linux-2.6.11/sound/pci/ali5451/ali5451.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/ali5451/ali5451.c	2005-05-30 17:43:09.000000000 +0200
@@ -98,6 +98,8 @@ MODULE_PARM_DESC(spdif, "Support SPDIF I
 #define ALI_LEF_CHANNEL		23
 #define ALI_SURR_LEFT_CHANNEL	26
 #define ALI_SURR_RIGHT_CHANNEL	25
+#define ALI_MODEM_IN_CHANNEL    21
+#define ALI_MODEM_OUT_CHANNEL   20
 
 #define	SNDRV_ALI_VOICE_TYPE_PCM	01
 #define SNDRV_ALI_VOICE_TYPE_OTH	02
@@ -122,7 +124,15 @@ MODULE_PARM_DESC(spdif, "Support SPDIF I
 
 #define ALI_SCTRL		0x48
 #define   ALI_SPDIF_OUT_ENABLE		0x20
+#define   ALI_SCTRL_LINE_IN2		(1 << 9)
+#define   ALI_SCTRL_GPIO_IN2		(1 << 13)
+#define   ALI_SCTRL_LINE_OUT_EN 	(1 << 20)
+#define   ALI_SCTRL_GPIO_OUT_EN 	(1 << 23)
+#define   ALI_SCTRL_CODEC1_READY	(1 << 24)
+#define   ALI_SCTRL_CODEC2_READY	(1 << 25)
 #define ALI_AC97_GPIO		0x4c
+#define   ALI_AC97_GPIO_ENABLE		0x8000
+#define   ALI_AC97_GPIO_DATA_SHIFT	16
 #define ALI_SPDIF_CS		0x70
 #define ALI_SPDIF_CTRL		0x74
 #define   ALI_SPDIF_IN_FUNC_ENABLE	0x02
@@ -143,6 +153,7 @@ MODULE_PARM_DESC(spdif, "Support SPDIF I
 	#define TARGET_REACHED		0x00008000
 	#define MIXER_OVERFLOW		0x00000800
 	#define MIXER_UNDERFLOW		0x00000400
+	#define GPIO_IRQ		0x01000000
 #define ALI_SBBL_SBCL           0xc0
 #define ALI_SBCTRL_SBE2R_SBDD   0xc4
 #define ALI_STIMER		0xc8
@@ -162,6 +173,9 @@ MODULE_PARM_DESC(spdif, "Support SPDIF I
 
 #define ALI_REG(codec, x) ((codec)->port + x)
 
+#define MAX_CODECS 2
+
+
 typedef struct snd_stru_ali ali_t;
 typedef struct snd_ali_stru_voice snd_ali_voice_t;
 
@@ -245,7 +259,7 @@ struct snd_stru_ali {
 	struct pci_dev	*pci_m7101;
 
 	snd_card_t	*card;
-	snd_pcm_t	*pcm;
+	snd_pcm_t	*pcm[MAX_CODECS];
 	alidev_t	synth;
 	snd_ali_channel_control_t chregs;
 
@@ -255,8 +269,10 @@ struct snd_stru_ali {
 	unsigned int spurious_irq_count;
 	unsigned int spurious_irq_max_delta;
 
+	unsigned int num_of_codecs;
+
 	ac97_bus_t *ac97_bus;
-	ac97_t *ac97;
+	ac97_t *ac97[MAX_CODECS];
 	unsigned short	ac97_ext_id;
 	unsigned short	ac97_ext_status;
 
@@ -489,7 +505,12 @@ static void snd_ali_codec_write(ac97_t *
 	ali_t *codec = ac97->private_data;
 
 	snd_ali_printk("codec_write: reg=%xh data=%xh.\n", reg, val);
-	snd_ali_codec_poke(codec, 0, reg, val);
+	if(reg == AC97_GPIO_STATUS) {
+		outl((val << ALI_AC97_GPIO_DATA_SHIFT)|ALI_AC97_GPIO_ENABLE,
+			ALI_REG(codec, ALI_AC97_GPIO));
+		return;
+	}
+	snd_ali_codec_poke(codec, ac97->num, reg, val);
 	return ;
 }
 
@@ -499,7 +520,7 @@ static unsigned short snd_ali_codec_read
 	ali_t *codec = ac97->private_data;
 
 	snd_ali_printk("codec_read reg=%xh.\n", reg);
-	return (snd_ali_codec_peek(codec, 0, reg));
+	return (snd_ali_codec_peek(codec, ac97->num, reg));
 }
 
 /*
@@ -1051,7 +1072,7 @@ static irqreturn_t snd_ali_card_interrup
 }
 
 
-static snd_ali_voice_t *snd_ali_alloc_voice(ali_t * codec, int type, int rec)
+static snd_ali_voice_t *snd_ali_alloc_voice(ali_t * codec, int type, int rec, int channel)
 {
 	snd_ali_voice_t *pvoice = NULL;
 	unsigned long flags;
@@ -1061,7 +1082,8 @@ static snd_ali_voice_t *snd_ali_alloc_vo
 
 	spin_lock_irqsave(&codec->voice_alloc, flags);
 	if (type == SNDRV_ALI_VOICE_TYPE_PCM) {
-		idx = snd_ali_find_free_channel(codec,rec);
+		idx = channel > 0 ? snd_ali_alloc_pcm_channel(codec, channel) :
+			snd_ali_find_free_channel(codec,rec);
 		if(idx < 0) {
 			snd_printk("ali_alloc_voice: err.\n");
 			spin_unlock_irqrestore(&codec->voice_alloc, flags);
@@ -1297,7 +1319,7 @@ static int snd_ali_playback_hw_params(sn
 
 	if (params_buffer_size(hw_params)/2 != params_period_size(hw_params)) {
 		if (evoice == NULL) {
-			evoice = snd_ali_alloc_voice(codec, SNDRV_ALI_VOICE_TYPE_PCM, 0);
+			evoice = snd_ali_alloc_voice(codec, SNDRV_ALI_VOICE_TYPE_PCM, 0, -1);
 			if (evoice == NULL)
 				return -ENOMEM;
 			pvoice->extra = evoice;
@@ -1328,13 +1350,13 @@ static int snd_ali_playback_hw_free(snd_
 	return 0;
 }
 
-static int snd_ali_capture_hw_params(snd_pcm_substream_t * substream,
+static int snd_ali_hw_params(snd_pcm_substream_t * substream,
 				 snd_pcm_hw_params_t * hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_ali_capture_hw_free(snd_pcm_substream_t * substream)
+static int snd_ali_hw_free(snd_pcm_substream_t * substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
@@ -1428,7 +1450,7 @@ static int snd_ali_playback_prepare(snd_
 }
 
 
-static int snd_ali_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_ali_prepare(snd_pcm_substream_t * substream)
 {
 	ali_t *codec = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -1446,11 +1468,13 @@ static int snd_ali_capture_prepare(snd_p
 
 	spin_lock_irqsave(&codec->reg_lock, flags);
 
-	snd_ali_printk("capture_prepare...\n");
+	snd_ali_printk("ali_prepare...\n");
 
 	snd_ali_enable_special_channel(codec,pvoice->number);
 
-	Delta = snd_ali_convert_rate(runtime->rate, 1);
+	Delta = (pvoice->number == ALI_MODEM_IN_CHANNEL ||
+		 pvoice->number == ALI_MODEM_OUT_CHANNEL) ? 
+		0x1000 : snd_ali_convert_rate(runtime->rate, pvoice->mode);
 
 	// Prepare capture intr channel
 	if (pvoice->number == ALI_SPDIF_IN_CHANNEL) {
@@ -1534,7 +1558,7 @@ static snd_pcm_uframes_t snd_ali_playbac
 }
 
 
-static snd_pcm_uframes_t snd_ali_capture_pointer(snd_pcm_substream_t *substream)
+static snd_pcm_uframes_t snd_ali_pointer(snd_pcm_substream_t *substream)
 {
 	ali_t *codec = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -1616,7 +1640,8 @@ static void snd_ali_pcm_free_substream(s
 	}
 }
 
-static int snd_ali_playback_open(snd_pcm_substream_t * substream)
+static int snd_ali_open(snd_pcm_substream_t * substream, int rec, int channel,
+		snd_pcm_hardware_t *phw)
 {
 	ali_t *codec = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -1624,7 +1649,7 @@ static int snd_ali_playback_open(snd_pcm
 	unsigned long flags = 0;
 
 	spin_lock_irqsave(&codec->reg_lock, flags);
-	pvoice = snd_ali_alloc_voice(codec, SNDRV_ALI_VOICE_TYPE_PCM, 0);
+	pvoice = snd_ali_alloc_voice(codec, SNDRV_ALI_VOICE_TYPE_PCM, rec, channel);
 	if (pvoice == NULL) {
 		spin_unlock_irqrestore(&codec->reg_lock, flags);
 		return -EAGAIN;
@@ -1636,49 +1661,31 @@ static int snd_ali_playback_open(snd_pcm
 	runtime->private_data = pvoice;
 	runtime->private_free = snd_ali_pcm_free_substream;
 
-	runtime->hw = snd_ali_playback;
+	runtime->hw = *phw;
 	snd_pcm_set_sync(substream);
 	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);
 	return 0;
 }
 
+static int snd_ali_playback_open(snd_pcm_substream_t * substream)
+{
+	return snd_ali_open(substream, 0, -1, &snd_ali_playback);
+}
 
 static int snd_ali_capture_open(snd_pcm_substream_t * substream)
 {
-	ali_t *codec = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_ali_voice_t *pvoice;
-	unsigned long flags;
-
-	spin_lock_irqsave(&codec->reg_lock, flags);
-	pvoice = snd_ali_alloc_voice(codec, SNDRV_ALI_VOICE_TYPE_PCM, 1);
-	if (pvoice == NULL) {
-		spin_unlock_irqrestore(&codec->reg_lock, flags);
-		return -EAGAIN;
-	}
-	pvoice->codec = codec;
-	spin_unlock_irqrestore(&codec->reg_lock, flags);
-
-	pvoice->substream = substream;
-	runtime->private_data = pvoice;
-	runtime->private_free = snd_ali_pcm_free_substream;
-	runtime->hw = snd_ali_capture;
-	snd_pcm_set_sync(substream);
-	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);
-	return 0;
+	return snd_ali_open(substream, 1, -1, &snd_ali_capture);
 }
 
-
 static int snd_ali_playback_close(snd_pcm_substream_t * substream)
 {
 	return 0;
 }
 
-static int snd_ali_capture_close(snd_pcm_substream_t * substream)
+static int snd_ali_close(snd_pcm_substream_t * substream)
 {
 	ali_t *codec = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_ali_voice_t *pvoice = (snd_ali_voice_t *) runtime->private_data;
+	snd_ali_voice_t *pvoice = (snd_ali_voice_t *) substream->runtime->private_data;
 
 	snd_ali_disable_special_channel(codec,pvoice->number);
 
@@ -1698,29 +1705,121 @@ static snd_pcm_ops_t snd_ali_playback_op
 
 static snd_pcm_ops_t snd_ali_capture_ops = {
 	.open =		snd_ali_capture_open,
-	.close =	snd_ali_capture_close,
+	.close =	snd_ali_close,
 	.ioctl =	snd_ali_ioctl,
-	.hw_params =	snd_ali_capture_hw_params,
-	.hw_free =	snd_ali_capture_hw_free,
-	.prepare =	snd_ali_capture_prepare,
+	.hw_params =	snd_ali_hw_params,
+	.hw_free =	snd_ali_hw_free,
+	.prepare =	snd_ali_prepare,
+	.trigger =	snd_ali_trigger,
+	.pointer =	snd_ali_pointer,
+};
+
+/*
+ * Modem PCM
+ */
+
+static int snd_ali_modem_hw_params(snd_pcm_substream_t * substream,
+				 snd_pcm_hw_params_t * hw_params)
+{
+	ali_t *chip = snd_pcm_substream_chip(substream);
+	unsigned int modem_num = chip->num_of_codecs - 1;
+	snd_ac97_write(chip->ac97[modem_num], AC97_LINE1_RATE, params_rate(hw_params));
+	snd_ac97_write(chip->ac97[modem_num], AC97_LINE1_LEVEL, 0);
+	return snd_ali_hw_params(substream, hw_params);
+}
+
+static snd_pcm_hardware_t snd_ali_modem =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_RESUME |
+				 SNDRV_PCM_INFO_SYNC_START),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_KNOT|SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000,
+	.rate_min =		8000,
+	.rate_max =		16000,
+	.channels_min =		1,
+	.channels_max =		1,
+	.buffer_bytes_max =	(256*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(256*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static int snd_ali_modem_open(snd_pcm_substream_t * substream, int rec, int channel)
+{
+	static unsigned int rates [] = {8000,9600,12000,16000};
+	static snd_pcm_hw_constraint_list_t hw_constraint_rates = {
+		.count = ARRAY_SIZE(rates),
+		.list = rates,
+		.mask = 0,
+	};
+	int err = snd_ali_open(substream, rec, channel, &snd_ali_modem);
+	if (err)
+		return err;
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &hw_constraint_rates);
+}
+
+static int snd_ali_modem_playback_open(snd_pcm_substream_t * substream)
+{
+	return snd_ali_modem_open(substream, 0, ALI_MODEM_OUT_CHANNEL);
+}
+
+static int snd_ali_modem_capture_open(snd_pcm_substream_t * substream)
+{
+	return snd_ali_modem_open(substream, 1, ALI_MODEM_IN_CHANNEL);
+}
+
+static snd_pcm_ops_t snd_ali_modem_playback_ops = {
+	.open =		snd_ali_modem_playback_open,
+	.close =	snd_ali_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_ali_modem_hw_params,
+	.hw_free =	snd_ali_hw_free,
+	.prepare =	snd_ali_prepare,
+	.trigger =	snd_ali_trigger,
+	.pointer =	snd_ali_pointer,
+};
+
+static snd_pcm_ops_t snd_ali_modem_capture_ops = {
+	.open =		snd_ali_modem_capture_open,
+	.close =	snd_ali_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_ali_modem_hw_params,
+	.hw_free =	snd_ali_hw_free,
+	.prepare =	snd_ali_prepare,
 	.trigger =	snd_ali_trigger,
-	.pointer =	snd_ali_capture_pointer,
+	.pointer =	snd_ali_pointer,
+};
+
+
+struct ali_pcm_description {
+	char *name;
+	unsigned int playback_num;
+	unsigned int capture_num;
+	snd_pcm_ops_t *playback_ops;
+	snd_pcm_ops_t *capture_ops;
 };
 
 
 static void snd_ali_pcm_free(snd_pcm_t *pcm)
 {
 	ali_t *codec = pcm->private_data;
-	codec->pcm = NULL;
+	codec->pcm[pcm->device] = NULL;
 }
 
-static int __devinit snd_ali_pcm(ali_t * codec, int device, snd_pcm_t ** rpcm)
+
+static int __devinit snd_ali_pcm(ali_t * codec, int device, struct ali_pcm_description *desc)
 {
 	snd_pcm_t *pcm;
 	int err;
 
-	if (rpcm) *rpcm = NULL;
-	err = snd_pcm_new(codec->card, "ALI 5451", device, ALI_CHANNELS, 1, &pcm);
+	err = snd_pcm_new(codec->card, desc->name, device,
+			  desc->playback_num, desc->capture_num, &pcm);
 	if (err < 0) {
 		snd_printk("snd_ali_pcm: err called snd_pcm_new.\n");
 		return err;
@@ -1728,20 +1827,36 @@ static int __devinit snd_ali_pcm(ali_t *
 	pcm->private_data = codec;
 	pcm->private_free = snd_ali_pcm_free;
 	pcm->info_flags = 0;
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ali_playback_ops);
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ali_capture_ops);
+	if (desc->playback_ops)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, desc->playback_ops);
+	if (desc->capture_ops)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, desc->capture_ops);
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 					      snd_dma_pci_data(codec->pci), 64*1024, 128*1024);
 
 	pcm->info_flags = 0;
 	pcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;
-	strcpy(pcm->name, "ALI 5451");
-	codec->pcm = pcm;
-	if (rpcm) *rpcm = pcm;
+	strcpy(pcm->name, desc->name);
+	codec->pcm[0] = pcm;
 	return 0;
 }
 
+struct ali_pcm_description ali_pcms[] = {
+	{ "ALI 5451", ALI_CHANNELS, 1, &snd_ali_playback_ops, &snd_ali_capture_ops },
+	{ "ALI 5451 modem", 1, 1, &snd_ali_modem_playback_ops, &snd_ali_modem_capture_ops }
+};
+
+static int __devinit snd_ali_build_pcms(ali_t *codec)
+{
+	int i, err;
+	for(i = 0 ; i < codec->num_of_codecs && i < ARRAY_SIZE(ali_pcms) ; i++)
+		if((err = snd_ali_pcm(codec, i, &ali_pcms[i])) < 0)
+			return err;
+	return 0;
+}
+
+
 #define ALI5451_SPDIF(xname, xindex, value) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex,\
 .info = snd_ali5451_spdif_info, .get = snd_ali5451_spdif_get, \
@@ -1860,14 +1975,14 @@ static void snd_ali_mixer_free_ac97_bus(
 static void snd_ali_mixer_free_ac97(ac97_t *ac97)
 {
 	ali_t *codec = ac97->private_data;
-	codec->ac97 = NULL;
+	codec->ac97[ac97->num] = NULL;
 }
 
 static int __devinit snd_ali_mixer(ali_t * codec)
 {
 	ac97_template_t ac97;
 	unsigned int idx;
-	int err;
+	int i, err;
 	static ac97_bus_ops_t ops = {
 		.write = snd_ali_codec_write,
 		.read = snd_ali_codec_read,
@@ -1880,10 +1995,16 @@ static int __devinit snd_ali_mixer(ali_t
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = codec;
 	ac97.private_free = snd_ali_mixer_free_ac97;
-	if ((err = snd_ac97_mixer(codec->ac97_bus, &ac97, &codec->ac97)) < 0) {
-		snd_printk("ali mixer creating error.\n");
+
+	for ( i = 0 ; i < codec->num_of_codecs ; i++) {
+		ac97.num = i;
+		if ((err = snd_ac97_mixer(codec->ac97_bus, &ac97, &codec->ac97[i])) < 0) {
+			snd_printk("ali mixer %d creating error.\n", i);
+			if(i == 0)
 		return err;
 	}
+	}
+
 	if (codec->spdif_support) {
 		for(idx = 0; idx < ARRAY_SIZE(snd_ali5451_mixer_spdif); idx++) {
 			err=snd_ctl_add(codec->card, snd_ctl_new1(&snd_ali5451_mixer_spdif[idx], codec));
@@ -1904,8 +2025,12 @@ static int ali_suspend(snd_card_t *card,
 	if (! im)
 		return 0;
 
-	snd_pcm_suspend_all(chip->pcm);
-	snd_ac97_suspend(chip->ac97);
+	for(i = 0 ; i < chip->num_of_codecs ; i++) {
+		if (chip->pcm[i])
+			snd_pcm_suspend_all(chip->pcm[i]);
+		if(chip->ac97[i])
+			snd_ac97_suspend(chip->ac97[i]);
+	}
 
 	spin_lock_irq(&chip->reg_lock);
 	
@@ -1969,7 +2094,9 @@ static int ali_resume(snd_card_t *card)
 	
 	spin_unlock_irq(&chip->reg_lock);
 
-	snd_ac97_resume(chip->ac97);
+	for(i = 0 ; i < chip->num_of_codecs ; i++)
+		if(chip->ac97[i])
+			snd_ac97_resume(chip->ac97[i]);
 	
 	return 0;
 }
@@ -2036,11 +2163,37 @@ static int snd_ali_chip_init(ali_t *code
 		codec->spdif_mask = 0x00000002;
 	}
 
+	codec->num_of_codecs = 1;
+
+	/* secondary codec - modem */
+	if (inl(ALI_REG(codec, ALI_SCTRL)) & ALI_SCTRL_CODEC2_READY) {
+		codec->num_of_codecs++;
+		outl(inl(ALI_REG(codec, ALI_SCTRL)) |
+			(ALI_SCTRL_LINE_IN2|ALI_SCTRL_GPIO_IN2|ALI_SCTRL_LINE_OUT_EN),
+			ALI_REG(codec, ALI_SCTRL));
+	}
+
 	snd_ali_printk("chip initialize succeed.\n");
 	return 0;
 
 }
 
+/* proc for register dump */
+static void snd_ali_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buf)
+{
+	ali_t *codec = entry->private_data;
+	int i;
+	for(i = 0 ; i < 256 ; i+= 4)
+		snd_iprintf(buf, "%02x: %08x\n", i, inl(ALI_REG(codec, i)));
+}
+
+static void __devinit snd_ali_proc_init(ali_t *codec)
+{
+	snd_info_entry_t *entry;
+	if(!snd_card_proc_new(codec->card, "ali5451", &entry))
+		snd_info_set_text_ops(entry, codec, 1024, snd_ali_proc_read);
+}
+
 static int __devinit snd_ali_resources(ali_t *codec)
 {
 	int err;
@@ -2233,11 +2386,13 @@ static int __devinit snd_ali_probe(struc
 	}
 	
 	snd_ali_printk("pcm building ...\n");
-	if ((err = snd_ali_pcm(codec, 0, NULL)) < 0) {
+	if ((err = snd_ali_build_pcms(codec)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
 
+	snd_ali_proc_init(codec);
+
 	strcpy(card->driver, "ALI5451");
 	strcpy(card->shortname, "ALI 5451");
 	
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/als4000.c linux/sound/pci/als4000.c
--- linux-2.6.11/sound/pci/als4000.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/als4000.c	2005-05-27 12:33:37.000000000 +0200
@@ -367,7 +367,7 @@ static irqreturn_t snd_als4000_interrupt
 	if ((gcr_status & 0x40) && (chip->capture_substream)) /* capturing */
 		snd_pcm_period_elapsed(chip->capture_substream);
 	if ((gcr_status & 0x10) && (chip->rmidi)) /* MPU401 interrupt */
-		snd_mpu401_uart_interrupt(irq, chip->rmidi, regs);
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
 	/* release the gcr */
 	outb(gcr_status, chip->alt_port + 0xe);
 	
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/atiixp.c linux/sound/pci/atiixp.c
--- linux-2.6.11/sound/pci/atiixp.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/atiixp.c	2005-05-30 17:43:08.000000000 +0200
@@ -1334,8 +1334,8 @@ static irqreturn_t snd_atiixp_interrupt(
 
 static struct ac97_quirk ac97_quirks[] __devinitdata = {
 	{
-		.vendor = 0x103c,
-		.device = 0x006b,
+		.subvendor = 0x103c,
+		.subdevice = 0x006b,
 		.name = "HP Pavilion ZV5030US",
 		.type = AC97_TUNE_MUTE_LED
 	},
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/atiixp_modem.c linux/sound/pci/atiixp_modem.c
--- linux-2.6.11/sound/pci/atiixp_modem.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/atiixp_modem.c	2005-05-30 17:43:08.000000000 +0200
@@ -463,6 +463,11 @@ static unsigned short snd_atiixp_ac97_re
 static void snd_atiixp_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
 {
 	atiixp_t *chip = ac97->private_data;
+	if (reg == AC97_GPIO_STATUS) {
+		atiixp_write(chip, MODEM_OUT_GPIO,
+			(val << ATI_REG_MODEM_OUT_GPIO_DATA_SHIFT) | ATI_REG_MODEM_OUT_GPIO_EN);
+		return;
+	}
 	snd_atiixp_codec_write(chip, ac97->num, reg, val);
 }
 
@@ -663,44 +668,33 @@ static int snd_atiixp_pcm_trigger(snd_pc
 {
 	atiixp_t *chip = snd_pcm_substream_chip(substream);
 	atiixp_dma_t *dma = (atiixp_dma_t *)substream->runtime->private_data;
-	unsigned int reg = 0;
-	int i;
+	int err = 0;
 
 	snd_assert(dma->ops->enable_transfer && dma->ops->flush_dma, return -EINVAL);
 
-	if (cmd != SNDRV_PCM_TRIGGER_START && cmd != SNDRV_PCM_TRIGGER_STOP)
-		return -EINVAL;
-
 	spin_lock(&chip->reg_lock);
-
-	/* hook off/on: via GPIO_OUT */
-	for (i = 0; i < NUM_ATI_CODECS; i++) {
-		if (chip->ac97[i]) {
-			reg = snd_ac97_read(chip->ac97[i], AC97_GPIO_STATUS);
-			break;
-	}
-	}
-	if(cmd == SNDRV_PCM_TRIGGER_START)
-		reg |= AC97_GPIO_LINE1_OH;
-	else
-		reg &= ~AC97_GPIO_LINE1_OH;
-	reg = (reg << ATI_REG_MODEM_OUT_GPIO_DATA_SHIFT) | ATI_REG_MODEM_OUT_GPIO_EN ;
-	atiixp_write(chip, MODEM_OUT_GPIO, reg);
-
-	if (cmd == SNDRV_PCM_TRIGGER_START) {
+	switch(cmd) {
+	case SNDRV_PCM_TRIGGER_START:
 		dma->ops->enable_transfer(chip, 1);
 		dma->running = 1;
-	} else {
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
 		dma->ops->enable_transfer(chip, 0);
 		dma->running = 0;
+		break;
+	default:
+		err = -EINVAL;
+		break;
 	}
+	if (! err) {
 	snd_atiixp_check_bus_busy(chip);
 	if (cmd == SNDRV_PCM_TRIGGER_STOP) {
 		dma->ops->flush_dma(chip);
 		snd_atiixp_check_bus_busy(chip);
 	}
+	}
 	spin_unlock(&chip->reg_lock);
-	return 0;
+	return err;
 }
 
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ca0106/ca0106.h linux/sound/pci/ca0106/ca0106.h
--- linux-2.6.11/sound/pci/ca0106/ca0106.h	2005-03-02 08:38:08.000000000 +0100
+++ linux/sound/pci/ca0106/ca0106.h	2005-05-30 17:43:10.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
  *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
- *  Version: 0.0.20
+ *  Version: 0.0.21
  *
  *  FEATURES currently supported:
  *    See ca0106_main.c for features.
@@ -45,6 +45,8 @@
  *    Added I2C and SPI registers. Filled in interrupt enable.
  *  0.0.20
  *    Added GPIO info for SB Live 24bit.
+ *  0.0.21
+ *   Implement support for Line-in capture on SB Live 24bit.
  *
  *
  *  This code was initally based on code from ALSA's emu10k1x.c which is:
@@ -475,9 +477,56 @@
 						/* Causes interrupts based on timer intervals. */
 #define SPI			0x7a		/* SPI: Serial Interface Register */
 #define I2C_A			0x7b		/* I2C Address. 32 bit */
-#define I2C_0			0x7c		/* I2C Data Port 0. 32 bit */
-#define I2C_1			0x7d		/* I2C Data Port 1. 32 bit */
-
+#define I2C_D0			0x7c		/* I2C Data Port 0. 32 bit */
+#define I2C_D1			0x7d		/* I2C Data Port 1. 32 bit */
+//I2C values
+#define I2C_A_ADC_ADD_MASK	0x000000fe	//The address is a 7 bit address
+#define I2C_A_ADC_RW_MASK	0x00000001	//bit mask for R/W
+#define I2C_A_ADC_TRANS_MASK	0x00000010  	//Bit mask for I2c address DAC value
+#define I2C_A_ADC_ABORT_MASK	0x00000020	//Bit mask for I2C transaction abort flag
+#define I2C_A_ADC_LAST_MASK	0x00000040	//Bit mask for Last word transaction
+#define I2C_A_ADC_BYTE_MASK	0x00000080	//Bit mask for Byte Mode
+
+#define I2C_A_ADC_ADD		0x00000034	//This is the Device address for ADC 
+#define I2C_A_ADC_READ		0x00000001	//To perform a read operation
+#define I2C_A_ADC_START		0x00000100	//Start I2C transaction
+#define I2C_A_ADC_ABORT		0x00000200	//I2C transaction abort
+#define I2C_A_ADC_LAST		0x00000400	//I2C last transaction
+#define I2C_A_ADC_BYTE		0x00000800	//I2C one byte mode
+
+#define I2C_D_ADC_REG_MASK	0xfe000000  	//ADC address register 
+#define I2C_D_ADC_DAT_MASK	0x01ff0000  	//ADC data register
+
+#define ADC_TIMEOUT		0x00000007	//ADC Timeout Clock Disable
+#define ADC_IFC_CTRL		0x0000000b	//ADC Interface Control
+#define ADC_MASTER		0x0000000c	//ADC Master Mode Control
+#define ADC_POWER		0x0000000d	//ADC PowerDown Control
+#define ADC_ATTEN_ADCL		0x0000000e	//ADC Attenuation ADCL
+#define ADC_ATTEN_ADCR		0x0000000f	//ADC Attenuation ADCR
+#define ADC_ALC_CTRL1		0x00000010	//ADC ALC Control 1
+#define ADC_ALC_CTRL2		0x00000011	//ADC ALC Control 2
+#define ADC_ALC_CTRL3		0x00000012	//ADC ALC Control 3
+#define ADC_NOISE_CTRL		0x00000013	//ADC Noise Gate Control
+#define ADC_LIMIT_CTRL		0x00000014	//ADC Limiter Control
+#define ADC_MUX			0x00000015  	//ADC Mux offset
+
+#if 0
+/* FIXME: Not tested yet. */
+#define ADC_GAIN_MASK		0x000000ff	//Mask for ADC Gain
+#define ADC_ZERODB		0x000000cf	//Value to set ADC to 0dB
+#define ADC_MUTE_MASK		0x000000c0	//Mask for ADC mute
+#define ADC_MUTE		0x000000c0	//Value to mute ADC
+#define ADC_OSR			0x00000008	//Mask for ADC oversample rate select
+#define ADC_TIMEOUT_DISABLE	0x00000008	//Value and mask to disable Timeout clock
+#define ADC_HPF_DISABLE		0x00000100	//Value and mask to disable High pass filter
+#define ADC_TRANWIN_MASK	0x00000070	//Mask for Length of Transient Window
+#endif
+
+#define ADC_MUX_MASK		0x0000000f	//Mask for ADC Mux
+#define ADC_MUX_MIC		0x00000002	//Value to select Mic at ADC Mux
+#define ADC_MUX_LINEIN		0x00000004	//Value to select LineIn at ADC Mux
+#define ADC_MUX_PHONE		0x00000001	//Value to select TAD at ADC Mux (Not used)
+#define ADC_MUX_AUX		0x00000008	//Value to select Aux at ADC Mux
 
 #define SET_CHANNEL 0  /* Testing channel outputs 0=Front, 1=Center/LFE, 2=Unknown, 3=Rear */
 #define PCM_FRONT_CHANNEL 0
@@ -508,9 +557,18 @@ struct snd_ca0106_pcm {
 	unsigned short running;
 };
 
+typedef struct {
+        u32 serial;
+        char * name;
+        int ac97;
+	int gpio_type;
+	int i2c_adc;
+} ca0106_details_t;
+
 // definition of the chip-specific record
 struct snd_ca0106 {
 	snd_card_t *card;
+	ca0106_details_t *details;
 	struct pci_dev *pci;
 
 	unsigned long port;
@@ -531,6 +589,7 @@ struct snd_ca0106 {
 	u32 spdif_bits[4];             /* s/pdif out setup */
 	int spdif_enable;
 	int capture_source;
+	int capture_mic_line_in;
 
 	struct snd_dma_buffer buffer;
 };
@@ -547,3 +606,6 @@ void snd_ca0106_ptr_write(ca0106_t *emu,
 				   unsigned int chn, 
 				   unsigned int data);
 
+int snd_ca0106_i2c_write(ca0106_t *emu, u32 reg, u32 value);
+
+
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ca0106/ca0106_main.c linux/sound/pci/ca0106/ca0106_main.c
--- linux-2.6.11/sound/pci/ca0106/ca0106_main.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/ca0106/ca0106_main.c	2005-05-30 18:28:31.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
  *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
- *  Version: 0.0.22
+ *  Version: 0.0.23
  *
  *  FEATURES currently supported:
  *    Front, Rear and Center/LFE.
@@ -77,6 +77,8 @@
  *    Add SPDIF capture using optional digital I/O module for SB Live 24bit. (Analog capture does not yet work.)
  *  0.0.22
  *    Add support for MSI K8N Diamond Motherboard with onboard SB Live 24bit without AC97. From kiksen, bug #901
+ *  0.0.23
+ *    Implement support for Line-in capture on SB Live 24bit.
  *
  *  BUGS:
  *    Some stability problems when unloading the snd-ca0106 kernel module.
@@ -136,6 +138,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
 #include <sound/core.h>
 #include <sound/initval.h>
 #include <sound/pcm.h>
@@ -161,18 +164,32 @@ MODULE_PARM_DESC(enable, "Enable the CA0
 
 #include "ca0106.h"
 
-typedef struct {
-	u32 serial;
-	char * name;
-} ca0106_names_t;
-
-static ca0106_names_t ca0106_chip_names[] = {
-	 { 0x10021102, "AudigyLS [SB0310]"} , 
-	 { 0x10051102, "AudigyLS [SB0310b]"} , /* Unknown AudigyLS that also says SB0310 on it */
-	 { 0x10061102, "Live! 7.1 24bit [SB0410]"} , /* New Sound Blaster Live! 7.1 24bit. This does not have an AC97. 53SB041000001 */
-	 { 0x10071102, "Live! 7.1 24bit [SB0413]"} , /* New Dell Sound Blaster Live! 7.1 24bit. This does not have an AC97.  */
-	 { 0x10091462, "MSI K8N Diamond MB [SB0438]"}, /* MSI K8N Diamond Motherboard with onboard SB Live 24bit without AC97 */
-	 { 0, "AudigyLS [Unknown]" }
+static ca0106_details_t ca0106_chip_details[] = {
+	 /* AudigyLS[SB0310] */
+	 { .serial = 0x10021102,
+	   .name   = "AudigyLS [SB0310]",
+	   .ac97   = 1 } , 
+	 /* Unknown AudigyLS that also says SB0310 on it */
+	 { .serial = 0x10051102,
+	   .name   = "AudigyLS [SB0310b]",
+	   .ac97   = 1 } ,
+	 /* New Sound Blaster Live! 7.1 24bit. This does not have an AC97. 53SB041000001 */
+	 { .serial = 0x10061102,
+	   .name   = "Live! 7.1 24bit [SB0410]",
+	   .gpio_type = 1,
+	   .i2c_adc = 1 } ,
+	 /* New Dell Sound Blaster Live! 7.1 24bit. This does not have an AC97.  */
+	 { .serial = 0x10071102,
+	   .name   = "Live! 7.1 24bit [SB0413]",
+	   .gpio_type = 1,
+	   .i2c_adc = 1 } ,
+	 /* MSI K8N Diamond Motherboard with onboard SB Live 24bit without AC97 */
+	 { .serial = 0x10091462,
+	   .name   = "MSI K8N Diamond MB [SB0438]",
+	   .gpio_type = 1,
+	   .i2c_adc = 1 } ,
+	 { .serial = 0,
+	   .name   = "AudigyLS [Unknown]" }
 };
 
 /* hardware definition */
@@ -200,10 +217,10 @@ static snd_pcm_hardware_t snd_ca0106_cap
 				 SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				 SNDRV_PCM_INFO_MMAP_VALID),
-	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
-	.rates =		SNDRV_PCM_RATE_48000,
-	.rate_min =		48000,
-	.rate_max =		48000,
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,
+	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000,
+	.rate_min =		44100,
+	.rate_max =		192000,
 	.channels_min =		2,
 	.channels_max =		2,
 	.buffer_bytes_max =	((65536 - 64) * 8),
@@ -246,6 +263,62 @@ void snd_ca0106_ptr_write(ca0106_t *emu,
 	spin_unlock_irqrestore(&emu->emu_lock, flags);
 }
 
+int snd_ca0106_i2c_write(ca0106_t *emu,
+				u32 reg,
+				u32 value)
+{
+	u32 tmp;
+	int timeout=0;
+	int status;
+	int retry;
+	if ((reg > 0x7f) || (value > 0x1ff))
+	{
+                snd_printk("i2c_write: invalid values.\n");
+		return -EINVAL;
+	}
+
+	tmp = reg << 25 | value << 16;
+	/* Not sure what this I2C channel controls. */
+	/* snd_ca0106_ptr_write(emu, I2C_D0, 0, tmp); */
+
+	/* This controls the I2C connected to the WM8775 ADC Codec */
+	snd_ca0106_ptr_write(emu, I2C_D1, 0, tmp);
+
+	for(retry=0;retry<10;retry++)
+	{
+		/* Send the data to i2c */
+		tmp = snd_ca0106_ptr_read(emu, I2C_A, 0);
+		tmp = tmp & ~(I2C_A_ADC_READ|I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD_MASK);
+		tmp = tmp | (I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD);
+		snd_ca0106_ptr_write(emu, I2C_A, 0, tmp);
+
+		/* Wait till the transaction ends */
+		while(1)
+		{
+			status = snd_ca0106_ptr_read(emu, I2C_A, 0);
+                	//snd_printk("I2C:status=0x%x\n", status);
+			timeout++;
+			if((status & I2C_A_ADC_START)==0)
+				break;
+
+			if(timeout>1000)
+				break;
+		}
+		//Read back and see if the transaction is successful
+		if((status & I2C_A_ADC_ABORT)==0)
+			break;
+	}
+
+	if(retry==10)
+	{
+                snd_printk("Writing to ADC failed!\n");
+		return -EINVAL;
+	}
+    
+    	return 0;
+}
+
+
 static void snd_ca0106_intr_enable(ca0106_t *emu, unsigned int intrenb)
 {
 	unsigned long flags;
@@ -259,11 +332,7 @@ static void snd_ca0106_intr_enable(ca010
 
 static void snd_ca0106_pcm_free_substream(snd_pcm_runtime_t *runtime)
 {
-	ca0106_pcm_t *epcm = runtime->private_data;
-  
-	if (epcm) {
-		kfree(epcm);
-	}
+	kfree(runtime->private_data);
 }
 
 /* open_playback callback */
@@ -538,6 +607,61 @@ static int snd_ca0106_pcm_prepare_captur
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	ca0106_pcm_t *epcm = runtime->private_data;
 	int channel = epcm->channel_id;
+	u32 hcfg_mask = HCFG_CAPTURE_S32_LE;
+	u32 hcfg_set = 0x00000000;
+	u32 hcfg;
+	u32 over_sampling=0x2;
+	u32 reg71_mask = 0x0000c000 ; /* Global. Set ADC rate. */
+	u32 reg71_set = 0;
+	u32 reg71;
+	
+        //snd_printk("prepare:channel_number=%d, rate=%d, format=0x%x, channels=%d, buffer_size=%ld, period_size=%ld, periods=%u, frames_to_bytes=%d\n",channel, runtime->rate, runtime->format, runtime->channels, runtime->buffer_size, runtime->period_size, runtime->periods, frames_to_bytes(runtime, 1));
+        //snd_printk("dma_addr=%x, dma_area=%p, table_base=%p\n",runtime->dma_addr, runtime->dma_area, table_base);
+	//snd_printk("dma_addr=%x, dma_area=%p, dma_bytes(size)=%x\n",emu->buffer.addr, emu->buffer.area, emu->buffer.bytes);
+	/* reg71 controls ADC rate. */
+	switch (runtime->rate) {
+	case 44100:
+		reg71_set = 0x00004000;
+		break;
+        case 48000:
+		reg71_set = 0; 
+		break;
+	case 96000:
+		reg71_set = 0x00008000;
+		over_sampling=0xa;
+		break;
+	case 192000:
+		reg71_set = 0x0000c000; 
+		over_sampling=0xa;
+		break;
+	default:
+		reg71_set = 0; 
+		break;
+	}
+	/* Format is a global setting */
+	/* FIXME: Only let the first channel accessed set this. */
+	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		hcfg_set = 0;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		hcfg_set = HCFG_CAPTURE_S32_LE;
+		break;
+	default:
+		hcfg_set = 0;
+		break;
+	}
+	hcfg = inl(emu->port + HCFG) ;
+	hcfg = (hcfg & ~hcfg_mask) | hcfg_set;
+	outl(hcfg, emu->port + HCFG);
+	reg71 = snd_ca0106_ptr_read(emu, 0x71, 0);
+	reg71 = (reg71 & ~reg71_mask) | reg71_set;
+	snd_ca0106_ptr_write(emu, 0x71, 0, reg71);
+        if (emu->details->i2c_adc == 1) { /* The SB0410 and SB0413 use I2C to control ADC. */
+	        snd_ca0106_i2c_write(emu, ADC_MASTER, over_sampling); /* Adjust the over sampler to better suit the capture rate. */
+	}
+
+
         //printk("prepare:channel_number=%d, rate=%d, format=0x%x, channels=%d, buffer_size=%ld, period_size=%ld, frames_to_bytes=%d\n",channel, runtime->rate, runtime->format, runtime->channels, runtime->buffer_size, runtime->period_size,  frames_to_bytes(runtime, 1));
 	snd_ca0106_ptr_write(emu, 0x13, channel, 0);
 	snd_ca0106_ptr_write(emu, CAPTURE_DMA_ADDR, channel, runtime->dma_addr);
@@ -994,6 +1118,7 @@ static int __devinit snd_ca0106_create(s
 					 ca0106_t **rchip)
 {
 	ca0106_t *chip;
+	ca0106_details_t *c;
 	int err;
 	int ch;
 	static snd_device_ops_t ops = {
@@ -1004,8 +1129,8 @@ static int __devinit snd_ca0106_create(s
   
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
-	if (pci_set_dma_mask(pci, 0xffffffffUL) < 0 ||
-	    pci_set_consistent_dma_mask(pci, 0xffffffffUL) < 0) {
+	if (pci_set_dma_mask(pci, DMA_32BIT_MASK) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_32BIT_MASK) < 0) {
 		printk(KERN_ERR "error to set 32bit mask DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
@@ -1055,6 +1180,15 @@ static int __devinit snd_ca0106_create(s
 	printk(KERN_INFO "Model %04x Rev %08x Serial %08x\n", chip->model,
 	       chip->revision, chip->serial);
 #endif
+	strcpy(card->driver, "CA0106");
+	strcpy(card->shortname, "CA0106");
+
+	for (c=ca0106_chip_details; c->serial; c++) {
+		if (c->serial == chip->serial) break;
+	}
+	chip->details = c;
+	sprintf(card->longname, "%s at 0x%lx irq %i",
+		c->name, chip->port, chip->irq);
 
 	outl(0, chip->port + INTE);
 
@@ -1114,7 +1248,7 @@ static int __devinit snd_ca0106_create(s
 	//snd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0xf0f003f); /* OSS drivers set this. */
 	/* Analog or Digital output */
 	snd_ca0106_ptr_write(chip, SPDIF_SELECT1, 0, 0xf);
-	snd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0x000b0000); /* 0x0b000000 for digital, 0x000b0000 for analog, from win2000 drivers */
+	snd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0x000f0000); /* 0x0b000000 for digital, 0x000b0000 for analog, from win2000 drivers. Use 0x000f0000 for surround71 */
 	chip->spdif_enable = 0; /* Set digital SPDIF output off */
 	chip->capture_source = 3; /* Set CAPTURE_SOURCE */
 	//snd_ca0106_ptr_write(chip, 0x45, 0, 0); /* Analogue out */
@@ -1139,13 +1273,11 @@ static int __devinit snd_ca0106_create(s
         snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4); /* Select MIC, Line in, TAD in, AUX in */
 	chip->capture_source = 3; /* Set CAPTURE_SOURCE */
 
-        if ((chip->serial == 0x10061102) || 
-	    (chip->serial == 0x10071102) ||
-	    (chip->serial == 0x10091462)) { /* The SB0410 and SB0413 use GPIO differently. */
+        if (chip->details->gpio_type == 1) { /* The SB0410 and SB0413 use GPIO differently. */
 		/* FIXME: Still need to find out what the other GPIO bits do. E.g. For digital spdif out. */
 		outl(0x0, chip->port+GPIO);
 		//outl(0x00f0e000, chip->port+GPIO); /* Analog */
-		outl(0x005f4300, chip->port+GPIO); /* Analog */
+		outl(0x005f4301, chip->port+GPIO); /* Analog */
 	} else {
 		outl(0x0, chip->port+GPIO);
 		outl(0x005f03a3, chip->port+GPIO); /* Analog */
@@ -1158,6 +1290,10 @@ static int __devinit snd_ca0106_create(s
 	//outl(0x00000009, chip->port+HCFG);
 	outl(HCFG_AC97 | HCFG_AUDIOENABLE, chip->port+HCFG); /* AC97 2.0, Enable outputs. */
 
+        if (chip->details->i2c_adc == 1) { /* The SB0410 and SB0413 use I2C to control ADC. */
+	        snd_ca0106_i2c_write(chip, ADC_MUX, ADC_MUX_LINEIN); /* Enable Line-in capture. MIC in currently untested. */
+	}
+
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
 				  chip, &ops)) < 0) {
 		snd_ca0106_free(chip);
@@ -1173,7 +1309,6 @@ static int __devinit snd_ca0106_probe(st
 	static int dev;
 	snd_card_t *card;
 	ca0106_t *chip;
-	ca0106_names_t *c;
 	int err;
 
 	if (dev >= SNDRV_CARDS)
@@ -1208,9 +1343,7 @@ static int __devinit snd_ca0106_probe(st
 		snd_card_free(card);
 		return err;
 	}
-        if ((chip->serial != 0x10061102) && 
-	    (chip->serial != 0x10071102) && 
-	    (chip->serial != 0x10091462) ) { /* The SB0410 and SB0413 do not have an ac97 chip. */
+        if (chip->details->ac97 == 1) { /* The SB0410 and SB0413 do not have an AC97 chip. */
 		if ((err = snd_ca0106_ac97(chip)) < 0) {
 			snd_card_free(card);
 			return err;
@@ -1223,15 +1356,6 @@ static int __devinit snd_ca0106_probe(st
 
 	snd_ca0106_proc_init(chip);
 
-	strcpy(card->driver, "CA0106");
-	strcpy(card->shortname, "CA0106");
-
-	for (c=ca0106_chip_names; c->serial; c++) {
-		if (c->serial == chip->serial) break;
-	}
-	sprintf(card->longname, "%s at 0x%lx irq %i",
-		c->name, chip->port, chip->irq);
-
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
 		return err;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ca0106/ca0106_mixer.c linux/sound/pci/ca0106/ca0106_mixer.c
--- linux-2.6.11/sound/pci/ca0106/ca0106_mixer.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/ca0106/ca0106_mixer.c	2005-05-30 17:43:10.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
  *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
- *  Version: 0.0.16
+ *  Version: 0.0.17
  *
  *  FEATURES currently supported:
  *    See ca0106_main.c for features.
@@ -37,6 +37,8 @@
  *    Separated ca0106.c into separate functional .c files.
  *  0.0.16
  *    Modified Copyright message.
+ *  0.0.17
+ *    Implement Mic and Line in Capture.
  *
  *  This code was initally based on code from ALSA's emu10k1x.c which is:
  *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
@@ -113,7 +115,7 @@ static int snd_ca0106_shared_spdif_put(s
 		} else {
 			/* Analog */
 			snd_ca0106_ptr_write(emu, SPDIF_SELECT1, 0, 0xf);
-			snd_ca0106_ptr_write(emu, SPDIF_SELECT2, 0, 0x000b0000);
+			snd_ca0106_ptr_write(emu, SPDIF_SELECT2, 0, 0x000f0000);
 			snd_ca0106_ptr_write(emu, CAPTURE_CONTROL, 0,
 				snd_ca0106_ptr_read(emu, CAPTURE_CONTROL, 0) | 0x1000);
 			mask = inl(emu->port + GPIO) | 0x101;
@@ -183,6 +185,65 @@ static snd_kcontrol_new_t snd_ca0106_cap
 	.put =		snd_ca0106_capture_source_put
 };
 
+static int snd_ca0106_capture_mic_line_in_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[2] = { "Line in", "Mic in" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item > 1)
+                uinfo->value.enumerated.item = 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_ca0106_capture_mic_line_in_get(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = emu->capture_mic_line_in;
+	return 0;
+}
+
+static int snd_ca0106_capture_mic_line_in_put(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	ca0106_t *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change = 0;
+	u32 tmp;
+
+	val = ucontrol->value.enumerated.item[0] ;
+	change = (emu->capture_mic_line_in != val);
+	if (change) {
+		emu->capture_mic_line_in = val;
+		if (val) {
+			snd_ca0106_i2c_write(emu, ADC_MUX, ADC_MUX_PHONE); /* Mute input */
+			tmp = inl(emu->port+GPIO) & ~0x400;
+			tmp = tmp | 0x400;
+			outl(tmp, emu->port+GPIO);
+			snd_ca0106_i2c_write(emu, ADC_MUX, ADC_MUX_MIC);
+		} else {
+			snd_ca0106_i2c_write(emu, ADC_MUX, ADC_MUX_PHONE); /* Mute input */
+			tmp = inl(emu->port+GPIO) & ~0x400;
+			outl(tmp, emu->port+GPIO);
+			snd_ca0106_i2c_write(emu, ADC_MUX, ADC_MUX_LINEIN);
+		}
+	}
+        return change;
+}
+
+static snd_kcontrol_new_t snd_ca0106_capture_mic_line_in __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Mic/Line in Capture",
+	.info =		snd_ca0106_capture_mic_line_in_info,
+	.get =		snd_ca0106_capture_mic_line_in_get,
+	.put =		snd_ca0106_capture_mic_line_in_put
+};
+
 static int snd_ca0106_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
@@ -437,7 +498,7 @@ static snd_kcontrol_new_t snd_ca0106_vol
 static snd_kcontrol_new_t snd_ca0106_volume_control_analog_unknown =
 {
         .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
-        .name =         "Analog Unknown Volume",
+        .name =         "Analog Side Volume",
         .info =         snd_ca0106_volume_info,
         .get =          snd_ca0106_volume_get_analog_unknown,
         .put =          snd_ca0106_volume_put_analog_unknown
@@ -620,6 +681,12 @@ int __devinit snd_ca0106_mixer(ca0106_t 
 		return -ENOMEM;
 	if ((err = snd_ctl_add(card, kctl)))
 		return err;
+	if (emu->details->i2c_adc == 1) {
+		if ((kctl = snd_ctl_new1(&snd_ca0106_capture_mic_line_in, emu)) == NULL)
+			return -ENOMEM;
+		if ((err = snd_ctl_add(card, kctl)))
+			return err;
+	}
 	if ((kctl = snd_ctl_new1(&snd_ca0106_spdif_control, emu)) == NULL)
 		return -ENOMEM;
 	if ((err = snd_ctl_add(card, kctl)))
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ca0106/ca0106_proc.c linux/sound/pci/ca0106/ca0106_proc.c
--- linux-2.6.11/sound/pci/ca0106/ca0106_proc.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/ca0106/ca0106_proc.c	2005-05-30 17:43:10.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>
  *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit
- *  Version: 0.0.17
+ *  Version: 0.0.18
  *
  *  FEATURES currently supported:
  *    See ca0106_main.c for features.
@@ -39,7 +39,9 @@
  *    Modified Copyright message.
  *  0.0.17
  *    Add iec958 file in proc file system to show status of SPDIF in.
- *    
+ *  0.0.18
+ *    Implement support for Line-in capture on SB Live 24bit.
+ *
  *  This code was initally based on code from ALSA's emu10k1x.c which is:
  *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
  *
@@ -407,6 +409,20 @@ static void snd_ca0106_proc_reg_write(sn
         }
 }
 
+static void snd_ca0106_proc_i2c_write(snd_info_entry_t *entry, 
+				       snd_info_buffer_t * buffer)
+{
+	ca0106_t *emu = entry->private_data;
+        char line[64];
+        unsigned int reg, val;
+        while (!snd_info_get_line(buffer, line, sizeof(line))) {
+                if (sscanf(line, "%x %x", &reg, &val) != 2)
+                        continue;
+                if ((reg <= 0x7f) || (val <= 0x1ff)) {
+                        snd_ca0106_i2c_write(emu, reg, val);
+		}
+        }
+}
 
 int __devinit snd_ca0106_proc_init(ca0106_t * emu)
 {
@@ -431,6 +447,13 @@ int __devinit snd_ca0106_proc_init(ca010
 		entry->mode |= S_IWUSR;
 //		entry->private_data = emu;
 	}
+	if(! snd_card_proc_new(emu->card, "ca0106_i2c", &entry)) {
+		snd_info_set_text_ops(entry, emu, 1024, snd_ca0106_proc_i2c_write);
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_ca0106_proc_i2c_write;
+		entry->mode |= S_IWUSR;
+//		entry->private_data = emu;
+	}
 	if(! snd_card_proc_new(emu->card, "ca0106_regs2", &entry)) 
 		snd_info_set_text_ops(entry, emu, 1024, snd_ca0106_proc_reg_read2);
 	return 0;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/cs46xx/cs46xx_lib.c linux/sound/pci/cs46xx/cs46xx_lib.c
--- linux-2.6.11/sound/pci/cs46xx/cs46xx_lib.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/cs46xx/cs46xx_lib.c	2005-05-30 18:28:31.000000000 +0200
@@ -1295,8 +1295,7 @@ static snd_pcm_hw_constraint_list_t hw_c
 
 static void snd_cs46xx_pcm_free_substream(snd_pcm_runtime_t *runtime)
 {
-	cs46xx_pcm_t * cpcm = runtime->private_data;
-	kfree(cpcm);
+	kfree(runtime->private_data);
 }
 
 static int _cs46xx_playback_open_channel (snd_pcm_substream_t * substream,int pcm_channel_id)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/emu10k1/emu10k1_main.c linux/sound/pci/emu10k1/emu10k1_main.c
--- linux-2.6.11/sound/pci/emu10k1/emu10k1_main.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/emu10k1/emu10k1_main.c	2005-05-27 13:30:11.000000000 +0200
@@ -700,6 +700,12 @@ static emu_chip_details_t emu_chip_detai
 	 .emu10k2_chip = 1,
 	 .ca0102_chip = 1,
 	 .ac97_chip = 1} ,
+	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x00511102,
+	 .driver = "Audigy", .name = "Audigy 1 [SB0090]", 
+	 .id = "Audigy",
+	 .emu10k2_chip = 1,
+	 .ca0102_chip = 1,
+	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004,
 	 .driver = "Audigy", .name = "Audigy 1 [Unknown]", 
 	 .id = "Audigy",
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/emu10k1/emu10k1x.c linux/sound/pci/emu10k1/emu10k1x.c
--- linux-2.6.11/sound/pci/emu10k1/emu10k1x.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/emu10k1/emu10k1x.c	2005-05-30 18:28:31.000000000 +0200
@@ -361,10 +361,7 @@ static void snd_emu10k1x_gpio_write(emu1
 
 static void snd_emu10k1x_pcm_free_substream(snd_pcm_runtime_t *runtime)
 {
-	emu10k1x_pcm_t *epcm = runtime->private_data;
-  
-	if (epcm)
-		kfree(epcm);
+	kfree(runtime->private_data);
 }
 
 static void snd_emu10k1x_pcm_interrupt(emu10k1x_t *emu, emu10k1x_voice_t *voice)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/emu10k1/emupcm.c linux/sound/pci/emu10k1/emupcm.c
--- linux-2.6.11/sound/pci/emu10k1/emupcm.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/emu10k1/emupcm.c	2005-05-30 18:28:31.000000000 +0200
@@ -991,9 +991,7 @@ static void snd_emu10k1_pcm_efx_mixer_no
 
 static void snd_emu10k1_pcm_free_substream(snd_pcm_runtime_t *runtime)
 {
-	emu10k1_pcm_t *epcm = runtime->private_data;
-
-	kfree(epcm);
+	kfree(runtime->private_data);
 }
 
 static int snd_emu10k1_efx_playback_close(snd_pcm_substream_t * substream)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/es1968.c linux/sound/pci/es1968.c
--- linux-2.6.11/sound/pci/es1968.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/es1968.c	2005-05-23 11:32:09.000000000 +0200
@@ -2559,6 +2559,7 @@ static struct ess_device_list pm_whiteli
 	{ TYPE_MAESTRO2E, 0x103c },
 	{ TYPE_MAESTRO2E, 0x1179 },
 	{ TYPE_MAESTRO2E, 0x14c0 },	/* HP omnibook 4150 */
+	{ TYPE_MAESTRO2E, 0x1558 },
 };
 
 static struct ess_device_list mpu_blacklist[] __devinitdata = {
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/hda/hda_codec.c linux/sound/pci/hda/hda_codec.c
--- linux-2.6.11/sound/pci/hda/hda_codec.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/hda/hda_codec.c	2005-06-03 16:15:04.000000000 +0200
@@ -566,9 +566,10 @@ void snd_hda_codec_setup_stream(struct h
  * amp access functions
  */
 
-#define HDA_HASH_KEY(nid,dir,idx) (u32)((nid) + (idx) * 32 + (dir) * 64)
+/* FIXME: more better hash key? */
+#define HDA_HASH_KEY(nid,dir,idx) (u32)((nid) + ((idx) << 16) + ((dir) << 24))
 #define INFO_AMP_CAPS	(1<<0)
-#define INFO_AMP_VOL	(1<<1)
+#define INFO_AMP_VOL(ch)	(1 << (1 + (ch)))
 
 /* initialize the hash table */
 static void init_amp_hash(struct hda_codec *codec)
@@ -627,28 +628,29 @@ static u32 query_amp_caps(struct hda_cod
 
 /*
  * read the current volume to info
- * if the cache exists, read from the cache.
+ * if the cache exists, read the cache value.
  */
-static void get_vol_mute(struct hda_codec *codec, struct hda_amp_info *info,
+static unsigned int get_vol_mute(struct hda_codec *codec, struct hda_amp_info *info,
 			 hda_nid_t nid, int ch, int direction, int index)
 {
 	u32 val, parm;
 
-	if (info->status & (INFO_AMP_VOL << ch))
-		return;
+	if (info->status & INFO_AMP_VOL(ch))
+		return info->vol[ch];
 
 	parm = ch ? AC_AMP_GET_RIGHT : AC_AMP_GET_LEFT;
 	parm |= direction == HDA_OUTPUT ? AC_AMP_GET_OUTPUT : AC_AMP_GET_INPUT;
 	parm |= index;
 	val = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_AMP_GAIN_MUTE, parm);
 	info->vol[ch] = val & 0xff;
-	info->status |= INFO_AMP_VOL << ch;
+	info->status |= INFO_AMP_VOL(ch);
+	return info->vol[ch];
 }
 
 /*
- * write the current volume in info to the h/w
+ * write the current volume in info to the h/w and update the cache
  */
-static void put_vol_mute(struct hda_codec *codec,
+static void put_vol_mute(struct hda_codec *codec, struct hda_amp_info *info,
 			 hda_nid_t nid, int ch, int direction, int index, int val)
 {
 	u32 parm;
@@ -658,30 +660,34 @@ static void put_vol_mute(struct hda_code
 	parm |= index << AC_AMP_SET_INDEX_SHIFT;
 	parm |= val;
 	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_AMP_GAIN_MUTE, parm);
+	info->vol[ch] = val;
 }
 
 /*
- * read/write AMP value.  The volume is between 0 to 0x7f, 0x80 = mute bit.
+ * read AMP value.  The volume is between 0 to 0x7f, 0x80 = mute bit.
  */
 static int snd_hda_codec_amp_read(struct hda_codec *codec, hda_nid_t nid, int ch, int direction, int index)
 {
 	struct hda_amp_info *info = get_alloc_amp_hash(codec, HDA_HASH_KEY(nid, direction, index));
 	if (! info)
 		return 0;
-	get_vol_mute(codec, info, nid, ch, direction, index);
-	return info->vol[ch];
+	return get_vol_mute(codec, info, nid, ch, direction, index);
 }
 
-static int snd_hda_codec_amp_write(struct hda_codec *codec, hda_nid_t nid, int ch, int direction, int idx, int val)
+/*
+ * update the AMP value, mask = bit mask to set, val = the value
+ */
+static int snd_hda_codec_amp_update(struct hda_codec *codec, hda_nid_t nid, int ch, int direction, int idx, int mask, int val)
 {
 	struct hda_amp_info *info = get_alloc_amp_hash(codec, HDA_HASH_KEY(nid, direction, idx));
+
 	if (! info)
 		return 0;
-	get_vol_mute(codec, info, nid, ch, direction, idx);
+	val &= mask;
+	val |= get_vol_mute(codec, info, nid, ch, direction, idx) & ~mask;
 	if (info->vol[ch] == val && ! codec->in_resume)
 		return 0;
-	put_vol_mute(codec, nid, ch, direction, idx, val);
-	info->vol[ch] = val;
+	put_vol_mute(codec, info, nid, ch, direction, idx, val);
 	return 1;
 }
 
@@ -740,21 +746,15 @@ int snd_hda_mixer_amp_volume_put(snd_kco
 	int chs = get_amp_channels(kcontrol);
 	int dir = get_amp_direction(kcontrol);
 	int idx = get_amp_index(kcontrol);
-	int val;
 	long *valp = ucontrol->value.integer.value;
 	int change = 0;
 
-	if (chs & 1) {
-		val = *valp & 0x7f;
-		val |= snd_hda_codec_amp_read(codec, nid, 0, dir, idx) & 0x80;
-		change = snd_hda_codec_amp_write(codec, nid, 0, dir, idx, val);
-		valp++;
-	}
-	if (chs & 2) {
-		val = *valp & 0x7f;
-		val |= snd_hda_codec_amp_read(codec, nid, 1, dir, idx) & 0x80;
-		change |= snd_hda_codec_amp_write(codec, nid, 1, dir, idx, val);
-	}
+	if (chs & 1)
+		change = snd_hda_codec_amp_update(codec, nid, 0, dir, idx,
+						  0x7f, *valp);
+	if (chs & 2)
+		change |= snd_hda_codec_amp_update(codec, nid, 1, dir, idx,
+						   0x7f, valp[1]);
 	return change;
 }
 
@@ -793,21 +793,15 @@ int snd_hda_mixer_amp_switch_put(snd_kco
 	int chs = get_amp_channels(kcontrol);
 	int dir = get_amp_direction(kcontrol);
 	int idx = get_amp_index(kcontrol);
-	int val;
 	long *valp = ucontrol->value.integer.value;
 	int change = 0;
 
-	if (chs & 1) {
-		val = snd_hda_codec_amp_read(codec, nid, 0, dir, idx) & 0x7f;
-		val |= *valp ? 0 : 0x80;
-		change = snd_hda_codec_amp_write(codec, nid, 0, dir, idx, val);
-		valp++;
-	}
-	if (chs & 2) {
-		val = snd_hda_codec_amp_read(codec, nid, 1, dir, idx) & 0x7f;
-		val |= *valp ? 0 : 0x80;
-		change = snd_hda_codec_amp_write(codec, nid, 1, dir, idx, val);
-	}
+	if (chs & 1)
+		change = snd_hda_codec_amp_update(codec, nid, 0, dir, idx,
+						  0x80, *valp ? 0 : 0x80);
+	if (chs & 2)
+		change |= snd_hda_codec_amp_update(codec, nid, 1, dir, idx,
+						   0x80, valp[1] ? 0 : 0x80);
 	return change;
 }
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/hda/hda_codec.h linux/sound/pci/hda/hda_codec.h
--- linux-2.6.11/sound/pci/hda/hda_codec.h	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/hda/hda_codec.h	2005-05-25 17:38:13.000000000 +0200
@@ -419,7 +419,7 @@ struct hda_bus {
 
 	/* codec linked list */
 	struct list_head codec_list;
-	struct hda_codec *caddr_tbl[HDA_MAX_CODEC_ADDRESS]; /* caddr -> codec */
+	struct hda_codec *caddr_tbl[HDA_MAX_CODEC_ADDRESS + 1]; /* caddr -> codec */
 
 	struct semaphore cmd_mutex;
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/hda/hda_intel.c linux/sound/pci/hda/hda_intel.c
--- linux-2.6.11/sound/pci/hda/hda_intel.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/hda/hda_intel.c	2005-05-30 21:32:06.000000000 +0200
@@ -286,6 +286,7 @@ struct snd_azx {
 
 	/* flags */
 	int position_fix;
+	unsigned int initialized: 1;
 };
 
 /*
@@ -1235,7 +1236,7 @@ static int azx_resume(snd_card_t *card)
  */
 static int azx_free(azx_t *chip)
 {
-	if (chip->remap_addr) {
+	if (chip->initialized) {
 		int i;
 
 		for (i = 0; i < MAX_ICH6_DEV; i++)
@@ -1361,6 +1362,8 @@ static int __devinit azx_create(snd_card
 	/* initialize chip */
 	azx_init_chip(chip);
 
+	chip->initialized = 1;
+
 	/* codec detection */
 	if (! chip->codec_mask) {
 		snd_printk(KERN_ERR SFX "no codecs found!\n");
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/hda/patch_analog.c linux/sound/pci/hda/patch_analog.c
--- linux-2.6.11/sound/pci/hda/patch_analog.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/hda/patch_analog.c	2005-06-03 16:15:04.000000000 +0200
@@ -318,7 +318,7 @@ static int ad1986a_pcm_amp_vol_put(snd_k
 	return change;
 }
 
-#define ad1986a_pcm_amp_sw_info		snd_hda_mixer_amp_volume_info
+#define ad1986a_pcm_amp_sw_info		snd_hda_mixer_amp_switch_info
 
 static int ad1986a_pcm_amp_sw_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/hda/patch_realtek.c linux/sound/pci/hda/patch_realtek.c
--- linux-2.6.11/sound/pci/hda/patch_realtek.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/hda/patch_realtek.c	2005-06-03 16:15:04.000000000 +0200
@@ -78,6 +78,8 @@ struct alc_spec {
 
 	/* PCM information */
 	struct hda_pcm pcm_rec[2];
+
+	struct semaphore bind_mutex;
 };
 
 /* DAC/ADC assignment */
@@ -97,10 +99,20 @@ static hda_nid_t alc880_z71v_dac_nids[1]
 	0x02
 };
 
+#if 0
+/* The datasheet says the node 0x07 is connected from inputs,
+ * but it shows zero connection in the real implementation.
+ */
 static hda_nid_t alc880_adc_nids[3] = {
 	/* ADC0-2 */
 	0x07, 0x08, 0x09,
 };
+#else
+static hda_nid_t alc880_adc_nids[2] = {
+	/* ADC1-2 */
+	0x08, 0x09,
+};
+#endif
 
 #define ALC880_DIGOUT_NID	0x06
 #define ALC880_DIGIN_NID	0x0a
@@ -353,6 +365,73 @@ static int alc880_ch_mode_put(snd_kcontr
 
 
 /*
+ * bound volume controls
+ *
+ * bind multiple volumes (# indices, from 0)
+ */
+
+#define AMP_VAL_IDX_SHIFT	19
+#define AMP_VAL_IDX_MASK	(0x0f<<19)
+
+static int alc_bind_vol_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct alc_spec *spec = codec->spec;
+	unsigned long pval;
+
+	down(&spec->bind_mutex);
+	pval = kcontrol->private_value;
+	kcontrol->private_value = pval & ~AMP_VAL_IDX_MASK; /* index 0 */
+	snd_hda_mixer_amp_volume_info(kcontrol, uinfo);
+	kcontrol->private_value = pval;
+	up(&spec->bind_mutex);
+	return 0;
+}
+
+static int alc_bind_vol_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct alc_spec *spec = codec->spec;
+	unsigned long pval;
+
+	down(&spec->bind_mutex);
+	pval = kcontrol->private_value;
+	kcontrol->private_value = pval & ~AMP_VAL_IDX_MASK; /* index 0 */
+	snd_hda_mixer_amp_volume_get(kcontrol, ucontrol);
+	kcontrol->private_value = pval;
+	up(&spec->bind_mutex);
+	return 0;
+}
+
+static int alc_bind_vol_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct alc_spec *spec = codec->spec;
+	unsigned long pval;
+	int i, indices, change = 0;
+
+	down(&spec->bind_mutex);
+	pval = kcontrol->private_value;
+	indices = (pval & AMP_VAL_IDX_MASK) >> AMP_VAL_IDX_SHIFT;
+	for (i = 0; i < indices; i++) {
+		kcontrol->private_value = (pval & ~AMP_VAL_IDX_MASK) | (i << AMP_VAL_IDX_SHIFT);
+		change |= snd_hda_mixer_amp_volume_put(kcontrol, ucontrol);
+	}
+	kcontrol->private_value = pval;
+	up(&spec->bind_mutex);
+	return change;
+}
+
+#define ALC_BIND_VOL_MONO(xname, nid, channel, indices, direction) \
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0,  \
+	  .info = alc_bind_vol_info, \
+	  .get = alc_bind_vol_get, \
+	  .put = alc_bind_vol_put, \
+	  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, indices, direction) }
+
+#define ALC_BIND_VOL(xname,nid,indices,dir) ALC_BIND_VOL_MONO(xname,nid,3,indices,dir)
+
+/*
  */
 
 /* 3-stack mode
@@ -360,12 +439,12 @@ static int alc880_ch_mode_put(snd_kcontr
  *                 HP=0x19
  */
 static snd_kcontrol_new_t alc880_base_mixer[] = {
-	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Front Playback Volume", 0x0c, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Front Playback Switch", 0x14, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Surround Playback Volume", 0x0f, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Surround Playback Volume", 0x0f, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Surround Playback Switch", 0x1a, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x0e, 1, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x0e, 2, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL_MONO("Center Playback Volume", 0x0e, 1, 2, HDA_OUTPUT),
+	ALC_BIND_VOL_MONO("LFE Playback Volume", 0x0e, 2, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE_MONO("Center Playback Switch", 0x18, 1, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE_MONO("LFE Playback Switch", 0x18, 2, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
@@ -378,12 +457,13 @@ static snd_kcontrol_new_t alc880_base_mi
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x3, HDA_INPUT),
 	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
 	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
-	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Headphone Playback Volume", 0x0d, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Headphone Playback Switch", 0x19, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Capture Volume", 0x07, 0x0, HDA_INPUT),
-	HDA_CODEC_MUTE("Capture Switch", 0x07, 0x0, HDA_INPUT),
-	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x08, 0x0, HDA_INPUT),
-	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x08, 0x0, HDA_INPUT),
+	/* We don't use NID 0x07 - see above */
+	HDA_CODEC_VOLUME("Capture Volume", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x09, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x09, 0x0, HDA_INPUT),
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		/* The multiple "Capture Source" controls confuse alsamixer
@@ -412,15 +492,15 @@ static snd_kcontrol_new_t alc880_base_mi
  *                 Line-In/Side=0x1a, Mic=0x18, F-Mic=0x1b, HP=0x19
  */
 static snd_kcontrol_new_t alc880_five_stack_mixer[] = {
-	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Front Playback Volume", 0x0c, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Front Playback Switch", 0x14, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Surround Playback Volume", 0x0f, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Surround Playback Volume", 0x0f, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Surround Playback Switch", 0x17, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x0e, 1, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x0e, 2, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL_MONO("Center Playback Volume", 0x0e, 1, 2, HDA_OUTPUT),
+	ALC_BIND_VOL_MONO("LFE Playback Volume", 0x0e, 2, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE_MONO("Center Playback Switch", 0x16, 1, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE_MONO("LFE Playback Switch", 0x16, 2, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Side Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Side Playback Volume", 0x0d, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Side Playback Switch", 0x1a, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
 	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
@@ -432,12 +512,13 @@ static snd_kcontrol_new_t alc880_five_st
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x3, HDA_INPUT),
 	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
 	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
-	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	/* HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0d, 0x0, HDA_OUTPUT), */
 	HDA_CODEC_MUTE("Headphone Playback Switch", 0x19, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Capture Volume", 0x07, 0x0, HDA_INPUT),
-	HDA_CODEC_MUTE("Capture Switch", 0x07, 0x0, HDA_INPUT),
-	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x08, 0x0, HDA_INPUT),
-	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x08, 0x0, HDA_INPUT),
+	/* We don't use NID 0x07 - see above */
+	HDA_CODEC_VOLUME("Capture Volume", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x09, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x09, 0x0, HDA_INPUT),
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		/* The multiple "Capture Source" controls confuse alsamixer
@@ -494,9 +575,9 @@ static snd_kcontrol_new_t alc880_w810_ba
 };
 
 static snd_kcontrol_new_t alc880_z71v_mixer[] = {
-	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Front Playback Volume", 0x0c, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Front Playback Switch", 0x14, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Headphone Playback Volume", 0x0d, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Headphone Playback Switch", 0x15, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
 	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
@@ -506,6 +587,8 @@ static snd_kcontrol_new_t alc880_z71v_mi
 	HDA_CODEC_MUTE("Capture Switch", 0x07, 0x0, HDA_INPUT),
 	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x08, 0x0, HDA_INPUT),
 	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME_IDX("Capture Volume", 2, 0x09, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE_IDX("Capture Switch", 2, 0x09, 0x0, HDA_INPUT),
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		/* The multiple "Capture Source" controls confuse alsamixer
@@ -514,7 +597,7 @@ static snd_kcontrol_new_t alc880_z71v_mi
 		 */
 		/* .name = "Capture Source", */
 		.name = "Input Source",
-		.count = 2,
+		.count = 3,
 		.info = alc_mux_enum_info,
 		.get = alc_mux_enum_get,
 		.put = alc_mux_enum_put,
@@ -564,8 +647,16 @@ static struct hda_verb alc880_init_verbs
 	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24},
 	/* unmute amp left and right */
 	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
-	/* set connection select to line in (default select for this ADC) */
-	{0x07, AC_VERB_SET_CONNECT_SEL, 0x02},
+	/* set connection select to mic in */
+	{0x07, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* unmute amp left and right */
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	/* set connection select to mic in */
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* unmute amp left and right */
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	/* set connection select to mic in */
+	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
 	/* unmute front mixer amp left (volume = 0) */
 	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},
 	/* mute pin widget amp left and right (no gain on this amp) */
@@ -639,8 +730,16 @@ static struct hda_verb alc880_init_verbs
 	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24},
 	/* unmute amp left and right */
 	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
-	/* set connection select to line in (default select for this ADC) */
-	{0x07, AC_VERB_SET_CONNECT_SEL, 0x02},
+	/* set connection select to mic in */
+	{0x07, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* unmute amp left and right */
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	/* set connection select to mic in */
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* unmute amp left and right */
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	/* set connection select to mic in */
+	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
 	/* unmute front mixer amp left and right (volume = 0) */
 	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},
 	/* mute pin widget amp left and right (no gain on this amp) */
@@ -798,9 +897,16 @@ static struct hda_verb alc880_z71v_init_
 	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24},
 	/* unmute amp left and right */
 	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
-	/* set connection select to line in (default select for this ADC) */
-	{0x07, AC_VERB_SET_CONNECT_SEL, 0x02},
-
+	/* set connection select to mic in */
+	{0x07, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* unmute amp left and right */
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	/* set connection select to mic in */
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* unmute amp left and right */
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	/* set connection select to mic in */
+	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
 	/* Unmute input amps (CD, Line In, Mic 1 & Mic 2) for mixer
 	 * widget(nid=0x0B) to support the input path of analog loopback
 	 */
@@ -941,7 +1047,9 @@ static struct hda_pcm_stream alc880_pcm_
 	.substreams = 2,
 	.channels_min = 2,
 	.channels_max = 2,
-	.nid = 0x07, /* NID to query formats and rates */
+	.nid = 0x08, /* NID to query formats and rates
+		      * (0x07 might be broken on some devices)
+		      */
 	.ops = {
 		.prepare = alc880_capture_pcm_prepare,
 		.cleanup = alc880_capture_pcm_cleanup
@@ -1176,10 +1284,10 @@ static int alc_test_pin_src_put(snd_kcon
 			}
 
 static snd_kcontrol_new_t alc880_test_mixer[] = {
-	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Surround Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("CLFE Playback Volume", 0x0e, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Side Playback Volume", 0x0f, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Front Playback Volume", 0x0c, 2, HDA_OUTPUT),
+	ALC_BIND_VOL("Surround Playback Volume", 0x0d, 2, HDA_OUTPUT),
+	ALC_BIND_VOL("CLFE Playback Volume", 0x0e, 2, HDA_OUTPUT),
+	ALC_BIND_VOL("Side Playback Volume", 0x0f, 2, HDA_OUTPUT),
 	PIN_CTL_TEST("Front Pin Mode", 0x14),
 	PIN_CTL_TEST("Surround Pin Mode", 0x15),
 	PIN_CTL_TEST("CLFE Pin Mode", 0x16),
@@ -1261,6 +1369,13 @@ static struct hda_verb alc880_test_init_
 	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},
 	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},
 	{0x1b, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},
+	/* ADC set up */
+	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	{0x07, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
 	{ }
 };
 #endif
@@ -1356,6 +1471,7 @@ static int patch_alc880(struct hda_codec
 	if (spec == NULL)
 		return -ENOMEM;
 
+	init_MUTEX(&spec->bind_mutex);
 	codec->spec = spec;
 
 	board_config = snd_hda_check_board_config(codec, alc880_cfg_tbl);
@@ -1505,7 +1621,7 @@ static struct alc_channel_mode alc260_mo
 };
 
 snd_kcontrol_new_t alc260_base_mixer[] = {
-	HDA_CODEC_VOLUME("Front Playback Volume", 0x08, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Front Playback Volume", 0x08, 2, HDA_OUTPUT),
 	/* use LINE2 for the output */
 	/* HDA_CODEC_MUTE("Front Playback Switch", 0x0f, 0x0, HDA_OUTPUT), */
 	HDA_CODEC_MUTE("Front Playback Switch", 0x15, 0x0, HDA_OUTPUT),
@@ -1519,9 +1635,9 @@ snd_kcontrol_new_t alc260_base_mixer[] =
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x07, 0x01, HDA_INPUT),
 	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x07, 0x05, HDA_INPUT),
 	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x07, 0x05, HDA_INPUT),
-	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x09, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Headphone Playback Volume", 0x09, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Headphone Playback Switch", 0x10, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME_MONO("Mono Playback Volume", 0x0a, 1, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL_MONO("Mono Playback Volume", 0x0a, 1, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE_MONO("Mono Playback Switch", 0x11, 1, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("Capture Volume", 0x04, 0x0, HDA_INPUT),
 	HDA_CODEC_MUTE("Capture Switch", 0x04, 0x0, HDA_INPUT),
@@ -1614,6 +1730,7 @@ static int patch_alc260(struct hda_codec
 	if (spec == NULL)
 		return -ENOMEM;
 
+	init_MUTEX(&spec->bind_mutex);
 	codec->spec = spec;
 
 	spec->mixers[spec->num_mixers] = alc260_base_mixer;
@@ -1711,15 +1828,15 @@ static int alc882_mux_enum_put(snd_kcont
  *                 Mic=0x18, Front Mic=0x19, Line-In=0x1a, HP=0x1b
  */
 static snd_kcontrol_new_t alc882_base_mixer[] = {
-	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Front Playback Volume", 0x0c, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Front Playback Switch", 0x14, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Surround Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Surround Playback Volume", 0x0d, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Surround Playback Switch", 0x15, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x0e, 1, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x0e, 2, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL_MONO("Center Playback Volume", 0x0e, 1, 2, HDA_OUTPUT),
+	ALC_BIND_VOL_MONO("LFE Playback Volume", 0x0e, 2, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE_MONO("Center Playback Switch", 0x16, 1, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE_MONO("LFE Playback Switch", 0x16, 2, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Side Playback Volume", 0x0f, 0x0, HDA_OUTPUT),
+	ALC_BIND_VOL("Side Playback Volume", 0x0f, 2, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Side Playback Switch", 0x17, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Headphone Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
@@ -1822,11 +1939,13 @@ static struct hda_verb alc882_init_verbs
 	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, (0x7080 | (0x04 << 8))},
 	/* ADC1: unmute amp left and right */
 	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	{0x07, AC_VERB_SET_CONNECT_SEL, 0x00},
 	/* ADC2: unmute amp left and right */
 	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
 	/* ADC3: unmute amp left and right */
-	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
-
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000},
+	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
 	/* Unmute front loopback */
 	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
 	/* Unmute rear loopback */
@@ -1847,6 +1966,7 @@ static int patch_alc882(struct hda_codec
 	if (spec == NULL)
 		return -ENOMEM;
 
+	init_MUTEX(&spec->bind_mutex);
 	codec->spec = spec;
 
 	spec->mixers[spec->num_mixers] = alc882_base_mixer;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ice1712/amp.c linux/sound/pci/ice1712/amp.c
--- linux-2.6.11/sound/pci/ice1712/amp.c	2005-03-02 08:38:09.000000000 +0100
+++ linux/sound/pci/ice1712/amp.c	2005-05-27 13:05:16.000000000 +0200
@@ -30,16 +30,39 @@
 #include <sound/core.h>
 
 #include "ice1712.h"
+#include "envy24ht.h"
 #include "amp.h"
 
+static void wm_put(ice1712_t *ice, int reg, unsigned short val)
+{
+	unsigned short cval;
+	cval = (reg << 9) | val;
+	snd_vt1724_write_i2c(ice, WM_DEV, cval >> 8, cval & 0xff);
+}
 
 static int __devinit snd_vt1724_amp_init(ice1712_t *ice)
 {
+	static unsigned short wm_inits[] = {
+		WM_ATTEN_L,	0x0000,	/* 0 db */
+		WM_ATTEN_R,	0x0000,	/* 0 db */
+		WM_DAC_CTRL,	0x0008,	/* 24bit I2S */
+		WM_INT_CTRL,	0x0001, /* 24bit I2S */	
+	};
+
+	unsigned int i;
+
 	/* only use basic functionality for now */
 
 	ice->num_total_dacs = 2;	/* only PSDOUT0 is connected */
 	ice->num_total_adcs = 2;
 
+	/* Chaintech AV-710 has another codecs, which need initialization */
+	/* initialize WM8728 codec */
+	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_AV710) {
+		for (i = 0; i < ARRAY_SIZE(wm_inits); i += 2)
+			wm_put(ice, wm_inits[i], wm_inits[i+1]);
+	}
+
 	return 0;
 }
 
@@ -54,6 +77,13 @@ static int __devinit snd_vt1724_amp_add_
 /* entry point */
 struct snd_ice1712_card_info snd_vt1724_amp_cards[] __devinitdata = {
 	{
+		.subvendor = VT1724_SUBDEVICE_AV710,
+		.name = "Chaintech AV-710",
+		.model = "av710",
+		.chip_init = snd_vt1724_amp_init,
+		.build_controls = snd_vt1724_amp_add_controls,
+	},
+	{
 		.subvendor = VT1724_SUBDEVICE_AUDIO2000,
 		.name = "AMP Ltd AUDIO2000",
 		.model = "amp2000",
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ice1712/amp.h linux/sound/pci/ice1712/amp.h
--- linux-2.6.11/sound/pci/ice1712/amp.h	2005-03-02 08:37:30.000000000 +0100
+++ linux/sound/pci/ice1712/amp.h	2005-05-27 13:03:04.000000000 +0200
@@ -24,9 +24,23 @@
  *
  */      
 
-#define  AMP_AUDIO2000_DEVICE_DESC 	       "{AMP Ltd,AUDIO2000},"
+#define  AMP_AUDIO2000_DEVICE_DESC 	       "{AMP Ltd,AUDIO2000},"\
+					       "{Chaintech,AV-710},"
 
+#if 0
 #define VT1724_SUBDEVICE_AUDIO2000	0x12142417	/* Advanced Micro Peripherals Ltd AUDIO2000 */
+#else
+#define VT1724_SUBDEVICE_AUDIO2000	0x00030003	/* a dummy ID for AMP Audio2000 */
+#endif
+#define VT1724_SUBDEVICE_AV710		0x12142417	/* AV710 - the same ID with Audio2000! */
+
+/* WM8728 on I2C for AV710 */
+#define WM_DEV		0x36
+
+#define WM_ATTEN_L	0x00
+#define WM_ATTEN_R	0x01
+#define WM_DAC_CTRL	0x02
+#define WM_INT_CTRL	0x03
 
 extern struct snd_ice1712_card_info  snd_vt1724_amp_cards[];
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ice1712/vt1720_mobo.c linux/sound/pci/ice1712/vt1720_mobo.c
--- linux-2.6.11/sound/pci/ice1712/vt1720_mobo.c	2005-06-03 15:53:55.000000000 +0200
+++ linux/sound/pci/ice1712/vt1720_mobo.c	2005-05-24 14:16:15.000000000 +0200
@@ -110,6 +110,15 @@ struct snd_ice1712_card_info snd_vt1720_
 		.eeprom_size = sizeof(k8x800_eeprom),
 		.eeprom_data = k8x800_eeprom,
 	},
+	{
+		.subvendor = VT1720_SUBDEVICE_SN25P,
+		.name = "Shuttle SN25P",
+		/* identical with k8x800 */
+		.chip_init = k8x800_init,
+		.build_controls = k8x800_add_controls,
+		.eeprom_size = sizeof(k8x800_eeprom),
+		.eeprom_data = k8x800_eeprom,
+	},
 	{ } /* terminator */
 };
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ice1712/vt1720_mobo.h linux/sound/pci/ice1712/vt1720_mobo.h
--- linux-2.6.11/sound/pci/ice1712/vt1720_mobo.h	2005-06-03 15:53:55.000000000 +0200
+++ linux/sound/pci/ice1712/vt1720_mobo.h	2005-05-24 14:38:13.000000000 +0200
@@ -27,12 +27,14 @@
 #define VT1720_MOBO_DEVICE_DESC        "{Albatron,K8X800 Pro II},"\
 				       "{Chaintech,ZNF3-150},"\
 				       "{Chaintech,ZNF3-250},"\
-				       "{Chaintech,9CJS},"
+				       "{Chaintech,9CJS},"\
+				       "{Shuttle,SN25P},"
 
 #define VT1720_SUBDEVICE_K8X800		0xf217052c
 #define VT1720_SUBDEVICE_ZNF3_150	0x0f2741f6
 #define VT1720_SUBDEVICE_ZNF3_250	0x0f2745f6
 #define VT1720_SUBDEVICE_9CJS		0x0f272327
+#define VT1720_SUBDEVICE_SN25P		0x97123650
 
 extern struct snd_ice1712_card_info  snd_vt1720_mobo_cards[];
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/intel8x0.c linux/sound/pci/intel8x0.c
--- linux-2.6.11/sound/pci/intel8x0.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/intel8x0.c	2005-05-31 17:52:00.000000000 +0200
@@ -55,6 +55,7 @@ MODULE_SUPPORTED_DEVICE("{{Intel,82801AA
 		"{Intel,ICH6},"
 		"{Intel,ICH7},"
 		"{Intel,6300ESB},"
+		"{Intel,ESB2},"
 		"{Intel,MX440},"
 		"{SiS,SI7012},"
 		"{NVidia,nForce Audio},"
@@ -446,6 +447,7 @@ static struct pci_device_id snd_intel8x0
 	{ 0x8086, 0x25a6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL_ICH4 }, /* ESB */
 	{ 0x8086, 0x266e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL_ICH4 }, /* ICH6 */
 	{ 0x8086, 0x27de, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL_ICH4 }, /* ICH7 */
+	{ 0x8086, 0x2698, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL_ICH4 }, /* ESB2 */
 	{ 0x8086, 0x7195, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL },	/* 440MX */
 	{ 0x1039, 0x7012, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_SIS },	/* SI7012 */
 	{ 0x10de, 0x01b1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_NFORCE },	/* NFORCE */
@@ -1723,229 +1725,235 @@ static struct ac97_pcm ac97_pcm_defs[] _
 
 static struct ac97_quirk ac97_quirks[] __devinitdata = {
 	{
-		.vendor = 0x0e11,
-		.device = 0x008a,
+		.subvendor = 0x0e11,
+		.subdevice = 0x008a,
 		.name = "Compaq Evo W4000",	/* AD1885 */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x0e11,
-		.device = 0x00b8,
+		.subvendor = 0x0e11,
+		.subdevice = 0x00b8,
 		.name = "Compaq Evo D510C",
 		.type = AC97_TUNE_HP_ONLY
 	},
         {
-		.vendor = 0x0e11,
-		.device = 0x0860,
+		.subvendor = 0x0e11,
+		.subdevice = 0x0860,
 		.name = "HP/Compaq nx7010",
 		.type = AC97_TUNE_MUTE_LED
         },
 	{
-		.vendor = 0x1014,
-		.device = 0x1f00,
+		.subvendor = 0x1014,
+		.subdevice = 0x1f00,
 		.name = "MS-9128",
 		.type = AC97_TUNE_ALC_JACK
 	},
 	{
-		.vendor = 0x1028,
-		.device = 0x00d8,
+		.subvendor = 0x1028,
+		.subdevice = 0x00d8,
 		.name = "Dell Precision 530",	/* AD1885 */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1028,
-		.device = 0x010d,
+		.subvendor = 0x1028,
+		.subdevice = 0x010d,
 		.name = "Dell",	/* which model?  AD1885 */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1028,
-		.device = 0x0126,
+		.subvendor = 0x1028,
+		.subdevice = 0x0126,
 		.name = "Dell Optiplex GX260",	/* AD1981A */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1028,
-		.device = 0x012c,
+		.subvendor = 0x1028,
+		.subdevice = 0x012c,
 		.name = "Dell Precision 650",	/* AD1981A */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1028,
-		.device = 0x012d,
+		.subvendor = 0x1028,
+		.subdevice = 0x012d,
 		.name = "Dell Precision 450",	/* AD1981B*/
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1028,
-		.device = 0x0147,
+		.subvendor = 0x1028,
+		.subdevice = 0x0147,
 		.name = "Dell",	/* which model?  AD1981B*/
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1028,
-		.device = 0x0163,
+		.subvendor = 0x1028,
+		.subdevice = 0x0163,
 		.name = "Dell Unknown",	/* STAC9750/51 */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x103c,
-		.device = 0x006d,
+		.subvendor = 0x103c,
+		.subdevice = 0x006d,
 		.name = "HP zv5000",
 		.type = AC97_TUNE_MUTE_LED	/*AD1981B*/
 	},
 	{	/* FIXME: which codec? */
-		.vendor = 0x103c,
-		.device = 0x00c3,
+		.subvendor = 0x103c,
+		.subdevice = 0x00c3,
 		.name = "HP xw6000",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x103c,
-		.device = 0x088c,
+		.subvendor = 0x103c,
+		.subdevice = 0x088c,
 		.name = "HP nc8000",
 		.type = AC97_TUNE_MUTE_LED
 	},
 	{
-		.vendor = 0x103c,
-		.device = 0x0890,
+		.subvendor = 0x103c,
+		.subdevice = 0x0890,
 		.name = "HP nc6000",
 		.type = AC97_TUNE_MUTE_LED
 	},
 	{
-		.vendor = 0x103c,
-		.device = 0x129d,
+		.subvendor = 0x103c,
+		.subdevice = 0x129d,
 		.name = "HP xw8000",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x103c,
-		.device = 0x12f1,
+		.subvendor = 0x103c,
+		.subdevice = 0x12f1,
 		.name = "HP xw8200",	/* AD1981B*/
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x103c,
-		.device = 0x12f2,
+		.subvendor = 0x103c,
+		.subdevice = 0x12f2,
 		.name = "HP xw6200",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x103c,
-		.device = 0x3008,
+		.subvendor = 0x103c,
+		.subdevice = 0x3008,
 		.name = "HP xw4200",	/* AD1981B*/
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x104d,
-		.device = 0x8197,
+		.subvendor = 0x104d,
+		.subdevice = 0x8197,
 		.name = "Sony S1XP",
 		.type = AC97_TUNE_INV_EAPD
 	},
  	{
-		.vendor = 0x1043,
-		.device = 0x80f3,
+		.subvendor = 0x1043,
+		.subdevice = 0x80f3,
 		.name = "ASUS ICH5/AD1985",
 		.type = AC97_TUNE_AD_SHARING
 	},
 	{
-		.vendor = 0x10cf,
-		.device = 0x11c3,
+		.subvendor = 0x10cf,
+		.subdevice = 0x11c3,
 		.name = "Fujitsu-Siemens E4010",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x10cf,
-		.device = 0x1253,
+		.subvendor = 0x10cf,
+		.subdevice = 0x1225,
+		.name = "Fujitsu-Siemens T3010",
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
+		.subvendor = 0x10cf,
+		.subdevice = 0x1253,
 		.name = "Fujitsu S6210",	/* STAC9750/51 */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x10f1,
-		.device = 0x2665,
+		.subvendor = 0x10f1,
+		.subdevice = 0x2665,
 		.name = "Fujitsu-Siemens Celsius",	/* AD1981? */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x10f1,
-		.device = 0x2885,
+		.subvendor = 0x10f1,
+		.subdevice = 0x2885,
 		.name = "AMD64 Mobo",	/* ALC650 */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x110a,
-		.device = 0x0056,
+		.subvendor = 0x110a,
+		.subdevice = 0x0056,
 		.name = "Fujitsu-Siemens Scenic",	/* AD1981? */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x11d4,
-		.device = 0x5375,
+		.subvendor = 0x11d4,
+		.subdevice = 0x5375,
 		.name = "ADI AD1985 (discrete)",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1462,
-		.device = 0x5470,
+		.subvendor = 0x1462,
+		.subdevice = 0x5470,
 		.name = "MSI P4 ATX 645 Ultra",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1734,
-		.device = 0x0088,
+		.subvendor = 0x1734,
+		.subdevice = 0x0088,
 		.name = "Fujitsu-Siemens D1522",	/* AD1981 */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x8086,
-		.device = 0x2000,
+		.subvendor = 0x8086,
+		.subdevice = 0x2000,
 		.mask = 0xfff0,
 		.name = "Intel ICH5/AD1985",
 		.type = AC97_TUNE_AD_SHARING
 	},
 	{
-		.vendor = 0x8086,
-		.device = 0x4000,
+		.subvendor = 0x8086,
+		.subdevice = 0x4000,
 		.mask = 0xfff0,
 		.name = "Intel ICH5/AD1985",
 		.type = AC97_TUNE_AD_SHARING
 	},
 	{
-		.vendor = 0x8086,
-		.device = 0x4856,
+		.subvendor = 0x8086,
+		.subdevice = 0x4856,
 		.name = "Intel D845WN (82801BA)",
 		.type = AC97_TUNE_SWAP_HP
 	},
 	{
-		.vendor = 0x8086,
-		.device = 0x4d44,
+		.subvendor = 0x8086,
+		.subdevice = 0x4d44,
 		.name = "Intel D850EMV2",	/* AD1885 */
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x8086,
-		.device = 0x4d56,
+		.subvendor = 0x8086,
+		.subdevice = 0x4d56,
 		.name = "Intel ICH/AD1885",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x8086,
-		.device = 0x6000,
+		.subvendor = 0x8086,
+		.subdevice = 0x6000,
 		.mask = 0xfff0,
 		.name = "Intel ICH5/AD1985",
 		.type = AC97_TUNE_AD_SHARING
 	},
 	{
-		.vendor = 0x8086,
-		.device = 0xe000,
+		.subvendor = 0x8086,
+		.subdevice = 0xe000,
 		.mask = 0xfff0,
 		.name = "Intel ICH5/AD1985",
 		.type = AC97_TUNE_AD_SHARING
 	},
 #if 0 /* FIXME: this seems wrong on most boards */
 	{
-		.vendor = 0x8086,
-		.device = 0xa000,
+		.subvendor = 0x8086,
+		.subdevice = 0xa000,
 		.mask = 0xfff0,
 		.name = "Intel ICH5/AD1985",
 		.type = AC97_TUNE_HP_ONLY
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/intel8x0m.c linux/sound/pci/intel8x0m.c
--- linux-2.6.11/sound/pci/intel8x0m.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/intel8x0m.c	2005-05-30 17:43:08.000000000 +0200
@@ -35,7 +35,6 @@
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
 #include <sound/info.h>
-#include <sound/control.h>
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -292,60 +291,9 @@ static struct pci_device_id snd_intel8x0
 #endif
 	{ 0, }
 };
-static int snd_intel8x0m_switch_default_get(snd_kcontrol_t *kcontrol,
-					    snd_ctl_elem_value_t *ucontrol);
-static int snd_intel8x0m_switch_default_put(snd_kcontrol_t *kcontrol,
-					    snd_ctl_elem_value_t *ucontrol);
-static int snd_intel8x0m_switch_default_info(snd_kcontrol_t *kcontrol,
-					     snd_ctl_elem_info_t *uinfo);
-
-#define PRIVATE_VALUE_INITIALIZER(r,m) (((r) & 0xffff) << 16 | ((m) & 0xffff))
-#define PRIVATE_VALUE_MASK(control) ((control)->private_value & 0xffff)
-#define PRIVATE_VALUE_REG(control) (((control)->private_value >> 16) & 0xffff)
-
-static snd_kcontrol_new_t snd_intel8x0m_mixer_switches[] __devinitdata = {
-  { .name  = "Off-hook Switch",
-    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-    .info  = snd_intel8x0m_switch_default_info,
-    .get   = snd_intel8x0m_switch_default_get,
-    .put   = snd_intel8x0m_switch_default_put,
-    .private_value = PRIVATE_VALUE_INITIALIZER(AC97_GPIO_STATUS,AC97_GPIO_LINE1_OH)
-  }
-};
 
 MODULE_DEVICE_TABLE(pci, snd_intel8x0m_ids);
 
-static int snd_intel8x0m_switch_default_info(snd_kcontrol_t *kcontrol,
-					     snd_ctl_elem_info_t *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
-
-static int snd_intel8x0m_switch_default_get(snd_kcontrol_t *kcontrol,
-					    snd_ctl_elem_value_t *ucontrol)
-{
-	unsigned short mask = PRIVATE_VALUE_MASK(kcontrol);
-	unsigned short reg = PRIVATE_VALUE_REG(kcontrol);
-	intel8x0_t *chip = snd_kcontrol_chip(kcontrol);
-	unsigned int status;
-	status = snd_ac97_read(chip->ac97, reg) & mask ? 1 : 0;
-	ucontrol->value.integer.value[0] = status;
-	return 0;
-}
-static int snd_intel8x0m_switch_default_put(snd_kcontrol_t *kcontrol,
-					    snd_ctl_elem_value_t *ucontrol)
-{
-	unsigned short mask = PRIVATE_VALUE_MASK(kcontrol);
-	unsigned short reg = PRIVATE_VALUE_REG(kcontrol);
-	intel8x0_t *chip = snd_kcontrol_chip(kcontrol);
-	unsigned short new_status = ucontrol->value.integer.value[0] ? mask : ~mask;
-	return snd_ac97_update_bits(chip->ac97, reg,
-				    mask, new_status);
-}
 /*
  *  Lowlevel I/O - busmaster
  */
@@ -700,21 +648,6 @@ static snd_pcm_uframes_t snd_intel8x0_pc
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static int snd_intel8x0m_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
-{
-	/* hook off/on on start/stop */
-	/* Moved this to mixer control */
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		break;
-	default:
-		return -EINVAL;
-	}
-	return snd_intel8x0_pcm_trigger(substream,cmd);
-}
-
 static int snd_intel8x0m_pcm_prepare(snd_pcm_substream_t * substream)
 {
 	intel8x0_t *chip = snd_pcm_substream_chip(substream);
@@ -810,7 +743,7 @@ static snd_pcm_ops_t snd_intel8x0m_playb
 	.hw_params =	snd_intel8x0_hw_params,
 	.hw_free =	snd_intel8x0_hw_free,
 	.prepare =	snd_intel8x0m_pcm_prepare,
-	.trigger =	snd_intel8x0m_pcm_trigger,
+	.trigger =	snd_intel8x0_pcm_trigger,
 	.pointer =	snd_intel8x0_pcm_pointer,
 };
 
@@ -821,7 +754,7 @@ static snd_pcm_ops_t snd_intel8x0m_captu
 	.hw_params =	snd_intel8x0_hw_params,
 	.hw_free =	snd_intel8x0_hw_free,
 	.prepare =	snd_intel8x0m_pcm_prepare,
-	.trigger =	snd_intel8x0m_pcm_trigger,
+	.trigger =	snd_intel8x0_pcm_trigger,
 	.pointer =	snd_intel8x0_pcm_pointer,
 };
 
@@ -949,7 +882,6 @@ static int __devinit snd_intel8x0_mixer(
 	ac97_t *x97;
 	int err;
 	unsigned int glob_sta = 0;
-	unsigned int idx;
 	static ac97_bus_ops_t ops = {
 		.write = snd_intel8x0_codec_write,
 		.read = snd_intel8x0_codec_read,
@@ -985,10 +917,6 @@ static int __devinit snd_intel8x0_mixer(
 		chip->ichd[ICHD_MDMIN].ac97 = x97;
 		chip->ichd[ICHD_MDMOUT].ac97 = x97;
 	}
-	for (idx = 0; idx < ARRAY_SIZE(snd_intel8x0m_mixer_switches); idx++) {
-		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_intel8x0m_mixer_switches[idx], chip))) < 0)
-			goto __err;
-	}
 
 	chip->in_ac97_init = 0;
 	return 0;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/maestro3.c linux/sound/pci/maestro3.c
--- linux-2.6.11/sound/pci/maestro3.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/maestro3.c	2005-05-20 19:39:43.000000000 +0200
@@ -779,6 +779,12 @@ struct m3_quirk {
 				   (e.g. for IrDA on Dell Inspirons) */
 };
 
+struct m3_hv_quirk {
+	u16 vendor, device, subsystem_vendor, subsystem_device;
+	u32 config;		/* ALLEGRO_CONFIG hardware volume bits */
+	int is_omnibook;	/* Do HP OmniBook GPIO magic? */
+};
+
 struct m3_list {
 	int curlen;
 	int mem_addr;
@@ -828,6 +834,7 @@ struct snd_m3 {
 
 	struct pci_dev *pci;
 	struct m3_quirk *quirk;
+	struct m3_hv_quirk *hv_quirk;
 
 	int dacs_active;
 	int timer_users;
@@ -856,7 +863,7 @@ struct snd_m3 {
 	snd_kcontrol_t *master_switch;
 	snd_kcontrol_t *master_volume;
 	struct tasklet_struct hwvol_tq;
-	
+
 #ifdef CONFIG_PM
 	u16 *suspend_mem;
 #endif
@@ -973,6 +980,71 @@ static struct m3_quirk m3_quirk_list[] =
 	{ NULL }
 };
 
+/* These values came from the Windows driver. */
+static struct m3_hv_quirk m3_hv_quirk_list[] = {
+	/* Allegro chips */
+	{ 0x125D, 0x1988, 0x0E11, 0x002E, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x0E11, 0x0094, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x0E11, 0xB112, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x0E11, 0xB114, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x103C, 0x0012, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x103C, 0x0018, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x103C, 0x001C, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x103C, 0x001D, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x103C, 0x001E, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x107B, 0x3350, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x10F7, 0x8338, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x10F7, 0x833C, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x10F7, 0x833D, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x10F7, 0x833E, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x10F7, 0x833F, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x13BD, 0x1018, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x13BD, 0x1019, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x13BD, 0x101A, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x14FF, 0x0F03, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x14FF, 0x0F04, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x14FF, 0x0F05, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x156D, 0xB400, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x156D, 0xB795, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x156D, 0xB797, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x156D, 0xC700, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
+	{ 0x125D, 0x1988, 0x1033, 0x80F1, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x103C, 0x001A, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 }, /* HP OmniBook 6100 */
+	{ 0x125D, 0x1988, 0x107B, 0x340A, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x107B, 0x3450, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x109F, 0x3134, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x109F, 0x3161, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x144D, 0x3280, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x144D, 0x3281, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x144D, 0xC002, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x144D, 0xC003, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x1509, 0x1740, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x1610, 0x0010, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x1988, 0x1042, 0x1042, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1988, 0x107B, 0x9500, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1988, 0x14FF, 0x0F06, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1988, 0x1558, 0x8586, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1988, 0x161F, 0x2011, HV_CTRL_ENABLE, 0 },
+	/* Maestro3 chips */
+	{ 0x125D, 0x1998, 0x103C, 0x000E, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x103C, 0x0010, HV_CTRL_ENABLE, 1 }, /* HP OmniBook 6000 */
+	{ 0x125D, 0x1998, 0x103C, 0x0011, HV_CTRL_ENABLE, 1 }, /* HP OmniBook 500 */
+	{ 0x125D, 0x1998, 0x103C, 0x001B, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x104D, 0x80A6, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x104D, 0x80AA, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x107B, 0x5300, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x110A, 0x1998, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x13BD, 0x1015, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x13BD, 0x101C, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x13BD, 0x1802, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x1599, 0x0715, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x1998, 0x5643, 0x5643, HV_CTRL_ENABLE, 0 },
+	{ 0x125D, 0x199A, 0x144D, 0x3260, HV_CTRL_ENABLE | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x199A, 0x144D, 0x3261, HV_CTRL_ENABLE | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x199A, 0x144D, 0xC000, HV_CTRL_ENABLE | REDUCED_DEBOUNCE, 0 },
+	{ 0x125D, 0x199A, 0x144D, 0xC001, HV_CTRL_ENABLE | REDUCED_DEBOUNCE, 0 },
+	{ 0 }
+};
 
 /*
  * lowlevel functions
@@ -2392,21 +2464,27 @@ snd_m3_chip_init(m3_t *chip)
 	       DISABLE_LEGACY);
 	pci_write_config_word(pcidev, PCI_LEGACY_AUDIO_CTRL, w);
 
-	/*
-	 * Volume buttons on some HP OmniBook laptops (500 and 6000 at least)
-	 * don't work correctly. This makes them work for the most part.
-	 * Volume up and down buttons on the laptop side work perfectly.
-	 * Fn+cursor_up (volme up) works, Fn+cursor_down (volume down) doesn't,
-	 * Fn+F8 (mute) works acts as volume up.
-	 */
-	outw(~(GPI_VOL_DOWN|GPI_VOL_UP), io + GPIO_MASK);
-	outw(inw(io + GPIO_DIRECTION) & ~(GPI_VOL_DOWN|GPI_VOL_UP), io + GPIO_DIRECTION);
-	outw((GPI_VOL_DOWN|GPI_VOL_UP), io + GPIO_DATA);
-	outw(0xffff, io + GPIO_MASK);
-
+	if (chip->hv_quirk && chip->hv_quirk->is_omnibook) {
+		/*
+		 * Volume buttons on some HP OmniBook laptops don't work
+		 * correctly. This makes them work for the most part.
+		 *
+		 * Volume up and down buttons on the laptop side work.
+		 * Fn+cursor_up (volme up) works.
+		 * Fn+cursor_down (volume down) doesn't work.
+		 * Fn+F7 (mute) works acts as volume up.
+		 */
+		outw(~(GPI_VOL_DOWN|GPI_VOL_UP), io + GPIO_MASK);
+		outw(inw(io + GPIO_DIRECTION) & ~(GPI_VOL_DOWN|GPI_VOL_UP), io + GPIO_DIRECTION);
+		outw((GPI_VOL_DOWN|GPI_VOL_UP), io + GPIO_DATA);
+		outw(0xffff, io + GPIO_MASK);
+	}
 	pci_read_config_dword(pcidev, PCI_ALLEGRO_CONFIG, &n);
-	n &= ~HV_BUTTON_FROM_GD;
-	n |= HV_CTRL_ENABLE | REDUCED_DEBOUNCE;
+	n &= ~(HV_CTRL_ENABLE | REDUCED_DEBOUNCE | HV_BUTTON_FROM_GD);
+	if (chip->hv_quirk)
+		n |= chip->hv_quirk->config;
+	/* For some reason we must always use reduced debounce. */
+	n |= REDUCED_DEBOUNCE;
 	n |= PM_CTRL_ENABLE | CLK_DIV_BY_49 | USE_PCI_TIMING;
 	pci_write_config_dword(pcidev, PCI_ALLEGRO_CONFIG, n);
 
@@ -2594,7 +2672,7 @@ snd_m3_create(snd_card_t *card, struct p
 	m3_t *chip;
 	int i, err;
 	struct m3_quirk *quirk;
-	u16 subsystem_vendor, subsystem_device;
+	struct m3_hv_quirk *hv_quirk;
 	static snd_device_ops_t ops = {
 		.dev_free =	snd_m3_dev_free,
 	};
@@ -2632,18 +2710,25 @@ snd_m3_create(snd_card_t *card, struct p
 	chip->pci = pci;
 	chip->irq = -1;
 
-	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
-	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &subsystem_device);
-
 	for (quirk = m3_quirk_list; quirk->vendor; quirk++) {
-		if (subsystem_vendor == quirk->vendor &&
-		    subsystem_device == quirk->device) {
+		if (pci->subsystem_vendor == quirk->vendor &&
+		    pci->subsystem_device == quirk->device) {
 			printk(KERN_INFO "maestro3: enabled hack for '%s'\n", quirk->name);
 			chip->quirk = quirk;
 			break;
 		}
 	}
 
+	for (hv_quirk = m3_hv_quirk_list; hv_quirk->vendor; hv_quirk++) {
+		if (pci->vendor == hv_quirk->vendor &&
+		    pci->device == hv_quirk->device &&
+		    pci->subsystem_vendor == hv_quirk->subsystem_vendor &&
+		    pci->subsystem_device == hv_quirk->subsystem_device) {
+			chip->hv_quirk = hv_quirk;
+			break;
+		}
+	}
+
 	chip->external_amp = enable_amp;
 	if (amp_gpio >= 0 && amp_gpio <= 0x0f)
 		chip->amp_gpio = amp_gpio;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/rme9652/Makefile linux/sound/pci/rme9652/Makefile
--- linux-2.6.11/sound/pci/rme9652/Makefile	2005-03-02 08:38:12.000000000 +0100
+++ linux/sound/pci/rme9652/Makefile	2005-06-03 12:21:07.000000000 +0200
@@ -5,7 +5,9 @@
 
 snd-rme9652-objs := rme9652.o
 snd-hdsp-objs := hdsp.o
+snd-hdspm-objs := hdspm.o
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_RME9652) += snd-rme9652.o
 obj-$(CONFIG_SND_HDSP) += snd-hdsp.o
+obj-$(CONFIG_SND_HDSPM) +=snd-hdspm.o
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/rme9652/hdsp.c linux/sound/pci/rme9652/hdsp.c
--- linux-2.6.11/sound/pci/rme9652/hdsp.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/rme9652/hdsp.c	2005-05-30 19:22:46.000000000 +0200
@@ -559,18 +559,22 @@ static int snd_hammerfall_get_buffer(str
 {
 	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 	dmab->dev.dev = snd_dma_pci_data(pci);
-	if (! snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {
-		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-					size, dmab) < 0)
-			return -ENOMEM;
+	if (snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {
+		if (dmab->bytes >= size)
+			return 0;
 	}
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+				size, dmab) < 0)
+		return -ENOMEM;
 	return 0;
 }
 
 static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_dev *pci)
 {
-	if (dmab->area)
+	if (dmab->area) {
+		dmab->dev.dev = NULL; /* make it anonymous */
 		snd_dma_reserve_buf(dmab, snd_dma_pci_buf_id(pci));
+	}
 }
 
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/rme9652/hdspm.c linux/sound/pci/rme9652/hdspm.c
--- linux-2.6.11/sound/pci/rme9652/hdspm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/sound/pci/rme9652/hdspm.c	2005-06-03 12:19:44.000000000 +0200
@@ -0,0 +1,3671 @@
+/*   -*- linux-c -*-
+ *
+ *   ALSA driver for RME Hammerfall DSP MADI audio interface(s)
+ *
+ *      Copyright (c) 2003 Winfried Ritsch (IEM)
+ *      code based on hdsp.c   Paul Davis
+ *                             Marcus Andersson
+ *                             Thomas Charbonnel
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/asoundef.h>
+#include <sound/rawmidi.h>
+#include <sound/hwdep.h>
+#include <sound/initval.h>
+
+#include <sound/hdspm.h>
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	  /* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	  /* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
+
+/* Disable precise pointer at start */
+static int precise_ptr[SNDRV_CARDS];
+
+/* Send all playback to line outs */
+static int line_outs_monitor[SNDRV_CARDS];
+
+/* Enable Analog Outs on Channel 63/64 by default */
+static int enable_monitor[SNDRV_CARDS];
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for RME HDSPM interface.");
+
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for RME HDSPM interface.");
+
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable/disable specific HDSPM soundcards.");
+
+module_param_array(precise_ptr, bool, NULL, 0444);
+MODULE_PARM_DESC(precise_ptr, "Enable precise pointer, or disable.");
+
+module_param_array(line_outs_monitor, bool, NULL, 0444);
+MODULE_PARM_DESC(line_outs_monitor,
+		 "Send playback streams to analog outs by default.");
+
+module_param_array(enable_monitor, bool, NULL, 0444);
+MODULE_PARM_DESC(enable_monitor,
+		 "Enable Analog Out on Channel 63/64 by default.");
+
+MODULE_AUTHOR
+      ("Winfried Ritsch <ritsch_AT_iem.at>, Paul Davis <paul@linuxaudiosystems.com>, "
+       "Marcus Andersson, Thomas Charbonnel <thomas@undata.org>");
+MODULE_DESCRIPTION("RME HDSPM");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
+
+/* --- Write registers. --- 
+  These are defined as byte-offsets from the iobase value.  */
+
+#define HDSPM_controlRegister	     64
+#define HDSPM_interruptConfirmation  96
+#define HDSPM_control2Reg	     256  /* not in specs ???????? */
+#define HDSPM_midiDataOut0  	     352  /* just believe in old code */
+#define HDSPM_midiDataOut1  	     356
+
+/* DMA enable for 64 channels, only Bit 0 is relevant */
+#define HDSPM_outputEnableBase       512  /* 512-767  input  DMA */ 
+#define HDSPM_inputEnableBase        768  /* 768-1023 output DMA */
+
+/* 16 page addresses for each of the 64 channels DMA buffer in and out 
+   (each 64k=16*4k) Buffer must be 4k aligned (which is default i386 ????) */
+#define HDSPM_pageAddressBufferOut       8192
+#define HDSPM_pageAddressBufferIn        (HDSPM_pageAddressBufferOut+64*16*4)
+
+#define HDSPM_MADI_mixerBase    32768	/* 32768-65535 for 2x64x64 Fader */
+
+#define HDSPM_MATRIX_MIXER_SIZE  8192	/* = 2*64*64 * 4 Byte => 32kB */
+
+/* --- Read registers. ---
+   These are defined as byte-offsets from the iobase value */
+#define HDSPM_statusRegister    0
+#define HDSPM_statusRegister2  96
+
+#define HDSPM_midiDataIn0     360
+#define HDSPM_midiDataIn1     364
+
+/* status is data bytes in MIDI-FIFO (0-128) */
+#define HDSPM_midiStatusOut0  384	
+#define HDSPM_midiStatusOut1  388	
+#define HDSPM_midiStatusIn0   392	
+#define HDSPM_midiStatusIn1   396	
+
+
+/* the meters are regular i/o-mapped registers, but offset
+   considerably from the rest. the peak registers are reset
+   when read; the least-significant 4 bits are full-scale counters; 
+   the actual peak value is in the most-significant 24 bits.
+*/
+#define HDSPM_MADI_peakrmsbase 	4096	/* 4096-8191 2x64x32Bit Meters */
+
+/* --- Control Register bits --------- */
+#define HDSPM_Start                (1<<0) /* start engine */
+
+#define HDSPM_Latency0             (1<<1) /* buffer size = 2^n */
+#define HDSPM_Latency1             (1<<2) /* where n is defined */
+#define HDSPM_Latency2             (1<<3) /* by Latency{2,1,0} */
+
+#define HDSPM_ClockModeMaster      (1<<4) /* 1=Master, 0=Slave/Autosync */
+
+#define HDSPM_AudioInterruptEnable (1<<5) /* what do you think ? */
+
+#define HDSPM_Frequency0  (1<<6)  /* 0=44.1kHz/88.2kHz 1=48kHz/96kHz */
+#define HDSPM_Frequency1  (1<<7)  /* 0=32kHz/64kHz */
+#define HDSPM_DoubleSpeed (1<<8)  /* 0=normal speed, 1=double speed */
+#define HDSPM_QuadSpeed   (1<<31) /* quad speed bit, not implemented now */
+
+#define HDSPM_TX_64ch     (1<<10) /* Output 64channel MODE=1,
+				     56channelMODE=0 */
+
+#define HDSPM_AutoInp     (1<<11) /* Auto Input (takeover) == Safe Mode, 
+                                     0=off, 1=on  */
+
+#define HDSPM_InputSelect0 (1<<14) /* Input select 0= optical, 1=coax */
+#define HDSPM_InputSelect1 (1<<15) /* should be 0 */
+
+#define HDSPM_SyncRef0     (1<<16) /* 0=WOrd, 1=MADI */
+#define HDSPM_SyncRef1     (1<<17) /* should be 0 */
+
+#define HDSPM_clr_tms      (1<<19) /* clear track marker, do not use 
+                                      AES additional bits in
+				      lower 5 Audiodatabits ??? */
+
+#define HDSPM_Midi0InterruptEnable (1<<22)
+#define HDSPM_Midi1InterruptEnable (1<<23)
+
+#define HDSPM_LineOut (1<<24) /* Analog Out on channel 63/64 on=1, mute=0 */
+
+
+/* --- bit helper defines */
+#define HDSPM_LatencyMask    (HDSPM_Latency0|HDSPM_Latency1|HDSPM_Latency2)
+#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1)
+#define HDSPM_InputMask      (HDSPM_InputSelect0|HDSPM_InputSelect1)
+#define HDSPM_InputOptical   0
+#define HDSPM_InputCoaxial   (HDSPM_InputSelect0)
+#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1)
+#define HDSPM_SyncRef_Word   0
+#define HDSPM_SyncRef_MADI   (HDSPM_SyncRef0)
+
+#define HDSPM_SYNC_FROM_WORD 0	/* Preferred sync reference */
+#define HDSPM_SYNC_FROM_MADI 1	/* choices - used by "pref_sync_ref" */
+
+#define HDSPM_Frequency32KHz    HDSPM_Frequency0
+#define HDSPM_Frequency44_1KHz  HDSPM_Frequency1
+#define HDSPM_Frequency48KHz   (HDSPM_Frequency1|HDSPM_Frequency0)
+#define HDSPM_Frequency64KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency0)
+#define HDSPM_Frequency88_2KHz (HDSPM_DoubleSpeed|HDSPM_Frequency1)
+#define HDSPM_Frequency96KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency1|HDSPM_Frequency0)
+
+/* --- for internal discrimination */
+#define HDSPM_CLOCK_SOURCE_AUTOSYNC          0	/* Sample Clock Sources */
+#define HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ    1
+#define HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ  2
+#define HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ    3
+#define HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ    4
+#define HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ  5
+#define HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ    6
+#define HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ   7
+#define HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ 8
+#define HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ   9
+
+/* Synccheck Status */
+#define HDSPM_SYNC_CHECK_NO_LOCK 0
+#define HDSPM_SYNC_CHECK_LOCK    1
+#define HDSPM_SYNC_CHECK_SYNC	 2
+
+/* AutoSync References - used by "autosync_ref" control switch */
+#define HDSPM_AUTOSYNC_FROM_WORD      0
+#define HDSPM_AUTOSYNC_FROM_MADI      1
+#define HDSPM_AUTOSYNC_FROM_NONE      2
+
+/* Possible sources of MADI input */
+#define HDSPM_OPTICAL 0		/* optical   */
+#define HDSPM_COAXIAL 1		/* BNC */
+
+#define hdspm_encode_latency(x)       (((x)<<1) & HDSPM_LatencyMask)
+#define hdspm_decode_latency(x)       (((x) & HDSPM_LatencyMask)>>1)
+
+#define hdspm_encode_in(x) (((x)&0x3)<<14)
+#define hdspm_decode_in(x) (((x)>>14)&0x3)
+
+/* --- control2 register bits --- */
+#define HDSPM_TMS             (1<<0)
+#define HDSPM_TCK             (1<<1)
+#define HDSPM_TDI             (1<<2)
+#define HDSPM_JTAG            (1<<3)
+#define HDSPM_PWDN            (1<<4)
+#define HDSPM_PROGRAM	      (1<<5)
+#define HDSPM_CONFIG_MODE_0   (1<<6)
+#define HDSPM_CONFIG_MODE_1   (1<<7)
+/*#define HDSPM_VERSION_BIT     (1<<8) not defined any more*/
+#define HDSPM_BIGENDIAN_MODE  (1<<9)
+#define HDSPM_RD_MULTIPLE     (1<<10)
+
+/* --- Status Register bits --- */
+#define HDSPM_audioIRQPending    (1<<0)	/* IRQ is high and pending */
+#define HDSPM_RX_64ch            (1<<1)	/* Input 64chan. MODE=1, 56chn. MODE=0 */
+#define HDSPM_AB_int             (1<<2)	/* InputChannel Opt=0, Coax=1 (like inp0) */
+#define HDSPM_madiLock           (1<<3)	/* MADI Locked =1, no=0 */
+
+#define HDSPM_BufferPositionMask 0x000FFC0 /* Bit 6..15 : h/w buffer pointer */
+                                           /* since 64byte accurate last 6 bits 
+                                              are not used */
+
+#define HDSPM_madiSync          (1<<18) /* MADI is in sync */
+#define HDSPM_DoubleSpeedStatus (1<<19) /* (input) card in double speed */
+
+#define HDSPM_madiFreq0         (1<<22)	/* system freq 0=error */
+#define HDSPM_madiFreq1         (1<<23)	/* 1=32, 2=44.1 3=48 */
+#define HDSPM_madiFreq2         (1<<24)	/* 4=64, 5=88.2 6=96 */
+#define HDSPM_madiFreq3         (1<<25)	/* 7=128, 8=176.4 9=192 */
+
+#define HDSPM_BufferID          (1<<26)	/* (Double)Buffer ID toggles with Interrupt */
+#define HDSPM_midi0IRQPending   (1<<30)	/* MIDI IRQ is pending  */
+#define HDSPM_midi1IRQPending   (1<<31)	/* and aktiv */
+
+/* --- status bit helpers */
+#define HDSPM_madiFreqMask  (HDSPM_madiFreq0|HDSPM_madiFreq1|HDSPM_madiFreq2|HDSPM_madiFreq3)
+#define HDSPM_madiFreq32    (HDSPM_madiFreq0)
+#define HDSPM_madiFreq44_1  (HDSPM_madiFreq1)
+#define HDSPM_madiFreq48    (HDSPM_madiFreq0|HDSPM_madiFreq1)
+#define HDSPM_madiFreq64    (HDSPM_madiFreq2)
+#define HDSPM_madiFreq88_2  (HDSPM_madiFreq0|HDSPM_madiFreq2)
+#define HDSPM_madiFreq96    (HDSPM_madiFreq1|HDSPM_madiFreq2)
+#define HDSPM_madiFreq128   (HDSPM_madiFreq0|HDSPM_madiFreq1|HDSPM_madiFreq2)
+#define HDSPM_madiFreq176_4 (HDSPM_madiFreq3)
+#define HDSPM_madiFreq192   (HDSPM_madiFreq3|HDSPM_madiFreq0)
+
+/* Status2 Register bits */
+
+#define HDSPM_version0 (1<<0)	/* not realy defined but I guess */
+#define HDSPM_version1 (1<<1)	/* in former cards it was ??? */
+#define HDSPM_version2 (1<<2)
+
+#define HDSPM_wcLock (1<<3)	/* Wordclock is detected and locked */
+#define HDSPM_wcSync (1<<4)	/* Wordclock is in sync with systemclock */
+
+#define HDSPM_wc_freq0 (1<<5)	/* input freq detected via autosync  */
+#define HDSPM_wc_freq1 (1<<6)	/* 001=32, 010==44.1, 011=48, */
+#define HDSPM_wc_freq2 (1<<7)	/* 100=64, 101=88.2, 110=96, */
+/* missing Bit   for               111=128, 1000=176.4, 1001=192 */
+
+#define HDSPM_SelSyncRef0 (1<<8)	/* Sync Source in slave mode */
+#define HDSPM_SelSyncRef1 (1<<9)	/* 000=word, 001=MADI, */
+#define HDSPM_SelSyncRef2 (1<<10)	/* 111=no valid signal */
+
+#define HDSPM_wc_valid (HDSPM_wcLock|HDSPM_wcSync)
+
+#define HDSPM_wcFreqMask  (HDSPM_wc_freq0|HDSPM_wc_freq1|HDSPM_wc_freq2)
+#define HDSPM_wcFreq32    (HDSPM_wc_freq0)
+#define HDSPM_wcFreq44_1  (HDSPM_wc_freq1)
+#define HDSPM_wcFreq48    (HDSPM_wc_freq0|HDSPM_wc_freq1)
+#define HDSPM_wcFreq64    (HDSPM_wc_freq2)
+#define HDSPM_wcFreq88_2  (HDSPM_wc_freq0|HDSPM_wc_freq2)
+#define HDSPM_wcFreq96    (HDSPM_wc_freq1|HDSPM_wc_freq2)
+
+
+#define HDSPM_SelSyncRefMask       (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|HDSPM_SelSyncRef2)
+#define HDSPM_SelSyncRef_WORD      0
+#define HDSPM_SelSyncRef_MADI      (HDSPM_SelSyncRef0)
+#define HDSPM_SelSyncRef_NVALID    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|HDSPM_SelSyncRef2)
+
+/* Mixer Values */
+#define UNITY_GAIN          32768	/* = 65536/2 */
+#define MINUS_INFINITY_GAIN 0
+
+/* PCI info */
+#ifndef PCI_VENDOR_ID_XILINX
+#define PCI_VENDOR_ID_XILINX		0x10ee
+#endif
+#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP
+#define PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP 0x3fc5
+#endif
+#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI
+#define PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI 0x3fc6
+#endif
+
+
+/* Number of channels for different Speed Modes */
+#define MADI_SS_CHANNELS       64
+#define MADI_DS_CHANNELS       32
+#define MADI_QS_CHANNELS       16
+
+/* the size of a substream (1 mono data stream) */
+#define HDSPM_CHANNEL_BUFFER_SAMPLES  (16*1024)
+#define HDSPM_CHANNEL_BUFFER_BYTES    (4*HDSPM_CHANNEL_BUFFER_SAMPLES)
+
+/* the size of the area we need to allocate for DMA transfers. the
+   size is the same regardless of the number of channels, and
+   also the latency to use. 
+   for one direction !!!
+*/
+#define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
+#define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
+
+typedef struct _hdspm hdspm_t;
+typedef struct _hdspm_midi hdspm_midi_t;
+
+struct _hdspm_midi {
+	hdspm_t *hdspm;
+	int id;
+	snd_rawmidi_t *rmidi;
+	snd_rawmidi_substream_t *input;
+	snd_rawmidi_substream_t *output;
+	char istimer;		/* timer in use */
+	struct timer_list timer;
+	spinlock_t lock;
+	int pending;
+};
+
+struct _hdspm {
+        spinlock_t lock;
+        snd_pcm_substream_t *capture_substream;	 /* only one playback */
+        snd_pcm_substream_t *playback_substream; /* and/or capture stream */
+
+	char *card_name;	     /* for procinfo */
+	unsigned short firmware_rev; /* dont know if relevant */
+
+	int precise_ptr;	/* use precise pointers, to be tested */
+	int monitor_outs;	/* set up monitoring outs init flag */
+
+	u32 control_register;	/* cached value */
+	u32 control2_register;	/* cached value */
+
+	hdspm_midi_t midi[2];
+	struct tasklet_struct midi_tasklet;
+
+	size_t period_bytes;
+	unsigned char ss_channels;	/* channels of card in single speed */
+	unsigned char ds_channels;	/* Double Speed */
+	unsigned char qs_channels;	/* Quad Speed */
+
+	unsigned char *playback_buffer;	/* suitably aligned address */
+	unsigned char *capture_buffer;	/* suitably aligned address */
+
+	pid_t capture_pid;	/* process id which uses capture */
+	pid_t playback_pid;	/* process id which uses capture */
+	int running;		/* running status */
+
+	int last_external_sample_rate;	/* samplerate mystic ... */
+	int last_internal_sample_rate;
+	int system_sample_rate;
+
+	char *channel_map;	/* channel map for DS and Quadspeed */
+
+	int dev;		/* Hardware vars... */
+	int irq;
+	unsigned long port;
+	void __iomem *iobase;
+
+	int irq_count;		/* for debug */
+
+	snd_card_t *card;	/* one card */
+	snd_pcm_t *pcm;		/* has one pcm */
+	snd_hwdep_t *hwdep;	/* and a hwdep for additional ioctl */
+	struct pci_dev *pci;	/* and an pci info */
+
+	/* Mixer vars */
+	snd_kcontrol_t *playback_mixer_ctls[HDSPM_MAX_CHANNELS];	/* fast alsa mixer */
+	snd_kcontrol_t *input_mixer_ctls[HDSPM_MAX_CHANNELS];	/* but input to much, so not used */
+	hdspm_mixer_t *mixer;	/* full mixer accessable over mixer ioctl or hwdep-device */
+
+};
+
+/* These tables map the ALSA channels 1..N to the channels that we
+   need to use in order to find the relevant channel buffer. RME
+   refer to this kind of mapping as between "the ADAT channel and
+   the DMA channel." We index it using the logical audio channel,
+   and the value is the DMA channel (i.e. channel buffer number)
+   where the data for that channel can be read/written from/to.
+*/
+
+static char channel_map_madi_ss[HDSPM_MAX_CHANNELS] = {
+   0, 1, 2, 3, 4, 5, 6, 7,
+   8, 9, 10, 11, 12, 13, 14, 15,
+   16, 17, 18, 19, 20, 21, 22, 23,
+   24, 25, 26, 27, 28, 29, 30, 31,
+   32, 33, 34, 35, 36, 37, 38, 39,
+   40, 41, 42, 43, 44, 45, 46, 47,
+   48, 49, 50, 51, 52, 53, 54, 55,
+   56, 57, 58, 59, 60, 61, 62, 63
+};
+
+static char channel_map_madi_ds[HDSPM_MAX_CHANNELS] = {
+  0, 2, 4, 6, 8, 10, 12, 14,
+  16, 18, 20, 22, 24, 26, 28, 30,
+  32, 34, 36, 38, 40, 42, 44, 46,
+  48, 50, 52, 54, 56, 58, 60, 62,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1
+};
+
+static char channel_map_madi_qs[HDSPM_MAX_CHANNELS] = {
+  0,   4,  8, 12, 16, 20, 24,  28,  
+  32, 36, 40, 44, 48, 52, 56,  60
+  -1, -1, -1, -1, -1, -1, -1, -1,  
+  -1, -1, -1, -1, -1, -1, -1, -1,  
+  -1, -1, -1, -1, -1, -1, -1, -1, 
+  -1, -1, -1, -1, -1, -1, -1, -1, 
+  -1, -1, -1, -1, -1, -1, -1, -1, 
+  -1, -1, -1, -1, -1, -1, -1, -1
+};
+
+
+static struct pci_device_id snd_hdspm_ids[] = {
+	{
+	 .vendor = PCI_VENDOR_ID_XILINX,
+	 .device = PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI,
+	 .subvendor = PCI_ANY_ID,
+	 .subdevice = PCI_ANY_ID,
+	 .class = 0,
+	 .class_mask = 0,
+	 .driver_data = 0},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, snd_hdspm_ids);
+
+/* prototypes */
+static int __devinit snd_hdspm_create_alsa_devices(snd_card_t * card,
+						   hdspm_t * hdspm);
+static int __devinit snd_hdspm_create_pcm(snd_card_t * card,
+					  hdspm_t * hdspm);
+
+static inline void snd_hdspm_initialize_midi_flush(hdspm_t * hdspm);
+static int hdspm_update_simple_mixer_controls(hdspm_t * hdspm);
+static int hdspm_autosync_ref(hdspm_t * hdspm);
+static int snd_hdspm_set_defaults(hdspm_t * hdspm);
+static void hdspm_set_sgbuf(hdspm_t * hdspm, struct snd_sg_buf *sgbuf,
+			     unsigned int reg, int channels);
+
+/* Write/read to/from HDSPM with Adresses in Bytes
+   not words but only 32Bit writes are allowed */
+
+static inline void hdspm_write(hdspm_t * hdspm, unsigned int reg,
+			       unsigned int val)
+{
+	writel(val, hdspm->iobase + reg);
+}
+
+static inline unsigned int hdspm_read(hdspm_t * hdspm, unsigned int reg)
+{
+	return readl(hdspm->iobase + reg);
+}
+
+/* for each output channel (chan) I have an Input (in) and Playback (pb) Fader 
+   mixer is write only on hardware so we have to cache him for read 
+   each fader is a u32, but uses only the first 16 bit */
+
+static inline int hdspm_read_in_gain(hdspm_t * hdspm, unsigned int chan,
+				     unsigned int in)
+{
+	if (chan > HDSPM_MIXER_CHANNELS || in > HDSPM_MIXER_CHANNELS)
+		return 0;
+
+	return hdspm->mixer->ch[chan].in[in];
+}
+
+static inline int hdspm_read_pb_gain(hdspm_t * hdspm, unsigned int chan,
+				     unsigned int pb)
+{
+	if (chan > HDSPM_MIXER_CHANNELS || pb > HDSPM_MIXER_CHANNELS)
+		return 0;
+	return hdspm->mixer->ch[chan].pb[pb];
+}
+
+static inline int hdspm_write_in_gain(hdspm_t * hdspm, unsigned int chan,
+				      unsigned int in, unsigned short data)
+{
+	if (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)
+		return -1;
+
+	hdspm_write(hdspm,
+		    HDSPM_MADI_mixerBase +
+		    ((in + 128 * chan) * sizeof(u32)),
+		    (hdspm->mixer->ch[chan].in[in] = data & 0xFFFF));
+	return 0;
+}
+
+static inline int hdspm_write_pb_gain(hdspm_t * hdspm, unsigned int chan,
+				      unsigned int pb, unsigned short data)
+{
+	if (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)
+		return -1;
+
+	hdspm_write(hdspm,
+		    HDSPM_MADI_mixerBase +
+		    ((64 + pb + 128 * chan) * sizeof(u32)),
+		    (hdspm->mixer->ch[chan].pb[pb] = data & 0xFFFF));
+	return 0;
+}
+
+
+/* enable DMA for specific channels, now available for DSP-MADI */
+static inline void snd_hdspm_enable_in(hdspm_t * hdspm, int i, int v)
+{
+	hdspm_write(hdspm, HDSPM_inputEnableBase + (4 * i), v);
+}
+
+static inline void snd_hdspm_enable_out(hdspm_t * hdspm, int i, int v)
+{
+	hdspm_write(hdspm, HDSPM_outputEnableBase + (4 * i), v);
+}
+
+/* check if same process is writing and reading */
+static inline int snd_hdspm_use_is_exclusive(hdspm_t * hdspm)
+{
+	unsigned long flags;
+	int ret = 1;
+
+	spin_lock_irqsave(&hdspm->lock, flags);
+	if ((hdspm->playback_pid != hdspm->capture_pid) &&
+	    (hdspm->playback_pid >= 0) && (hdspm->capture_pid >= 0)) {
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&hdspm->lock, flags);
+	return ret;
+}
+
+/* check for external sample rate */
+static inline int hdspm_external_sample_rate(hdspm_t * hdspm)
+{
+	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
+	unsigned int rate_bits;
+	int rate = 0;
+
+	/* if wordclock has synced freq and wordclock is valid */
+	if ((status2 & HDSPM_wcLock) != 0 &&
+	    (status & HDSPM_SelSyncRef0) == 0) {
+
+		rate_bits = status2 & HDSPM_wcFreqMask;
+
+		switch (rate_bits) {
+		case HDSPM_wcFreq32:
+			rate = 32000;
+			break;
+		case HDSPM_wcFreq44_1:
+			rate = 44100;
+			break;
+		case HDSPM_wcFreq48:
+			rate = 48000;
+			break;
+		case HDSPM_wcFreq64:
+			rate = 64000;
+			break;
+		case HDSPM_wcFreq88_2:
+			rate = 88200;
+			break;
+		case HDSPM_wcFreq96:
+			rate = 96000;
+			break;
+			/* Quadspeed Bit missing ???? */
+		default:
+			rate = 0;
+			break;
+		}
+	}
+
+	/* if rate detected and Syncref is Word than have it, word has priority to MADI */
+	if (rate != 0
+	    && (status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
+		return rate;
+
+	/* maby a madi input (which is taken if sel sync is madi) */
+	if (status & HDSPM_madiLock) {
+		rate_bits = status & HDSPM_madiFreqMask;
+
+		switch (rate_bits) {
+		case HDSPM_madiFreq32:
+			rate = 32000;
+			break;
+		case HDSPM_madiFreq44_1:
+			rate = 44100;
+			break;
+		case HDSPM_madiFreq48:
+			rate = 48000;
+			break;
+		case HDSPM_madiFreq64:
+			rate = 64000;
+			break;
+		case HDSPM_madiFreq88_2:
+			rate = 88200;
+			break;
+		case HDSPM_madiFreq96:
+			rate = 96000;
+			break;
+		case HDSPM_madiFreq128:
+			rate = 128000;
+			break;
+		case HDSPM_madiFreq176_4:
+			rate = 176400;
+			break;
+		case HDSPM_madiFreq192:
+			rate = 192000;
+			break;
+		default:
+			rate = 0;
+			break;
+		}
+	}
+	return rate;
+}
+
+/* Latency function */
+static inline void hdspm_compute_period_size(hdspm_t * hdspm)
+{
+	hdspm->period_bytes =
+	    1 << ((hdspm_decode_latency(hdspm->control_register) + 8));
+}
+
+static snd_pcm_uframes_t hdspm_hw_pointer(hdspm_t * hdspm)
+{
+	int position;
+
+	position = hdspm_read(hdspm, HDSPM_statusRegister);
+
+	if (!hdspm->precise_ptr) {
+		return (position & HDSPM_BufferID) ? (hdspm->period_bytes /
+						      4) : 0;
+	}
+
+	/* hwpointer comes in bytes and is 64Bytes accurate (by docu since PCI Burst)
+	   i have experimented that it is at most 64 Byte to much for playing 
+	   so substraction of 64 byte should be ok for ALSA, but use it only
+	   for application where you know what you do since if you come to
+	   near with record pointer it can be a disaster */
+
+	position &= HDSPM_BufferPositionMask;
+	position = ((position - 64) % (2 * hdspm->period_bytes)) / 4;
+
+	return position;
+}
+
+
+static inline void hdspm_start_audio(hdspm_t * s)
+{
+	s->control_register |= (HDSPM_AudioInterruptEnable | HDSPM_Start);
+	hdspm_write(s, HDSPM_controlRegister, s->control_register);
+}
+
+static inline void hdspm_stop_audio(hdspm_t * s)
+{
+	s->control_register &= ~(HDSPM_Start | HDSPM_AudioInterruptEnable);
+	hdspm_write(s, HDSPM_controlRegister, s->control_register);
+}
+
+/* should I silence all or only opened ones ? doit all for first even is 4MB*/
+static inline void hdspm_silence_playback(hdspm_t * hdspm)
+{
+	int i;
+	int n = hdspm->period_bytes;
+	void *buf = hdspm->playback_buffer;
+
+	snd_assert(buf != NULL, return);
+
+	for (i = 0; i < HDSPM_MAX_CHANNELS; i++) {
+		memset(buf, 0, n);
+		buf += HDSPM_CHANNEL_BUFFER_BYTES;
+	}
+}
+
+static int hdspm_set_interrupt_interval(hdspm_t * s, unsigned int frames)
+{
+	int n;
+
+	spin_lock_irq(&s->lock);
+
+	frames >>= 7;
+	n = 0;
+	while (frames) {
+		n++;
+		frames >>= 1;
+	}
+	s->control_register &= ~HDSPM_LatencyMask;
+	s->control_register |= hdspm_encode_latency(n);
+
+	hdspm_write(s, HDSPM_controlRegister, s->control_register);
+
+	hdspm_compute_period_size(s);
+
+	spin_unlock_irq(&s->lock);
+
+	return 0;
+}
+
+
+/* dummy set rate lets see what happens */
+static int hdspm_set_rate(hdspm_t * hdspm, int rate, int called_internally)
+{
+	int reject_if_open = 0;
+	int current_rate;
+	int rate_bits;
+	int not_set = 0;
+
+	/* ASSUMPTION: hdspm->lock is either set, or there is no need for
+	   it (e.g. during module initialization).
+	 */
+
+	if (!(hdspm->control_register & HDSPM_ClockModeMaster)) {
+
+	        /* SLAVE --- */ 
+		if (called_internally) {
+
+        	  /* request from ctl or card initialization 
+	             just make a warning an remember setting 
+		     for future master mode switching */
+    
+			snd_printk
+			    (KERN_WARNING "HDSPM: Warning: device is not running as a clock master.\n");
+			not_set = 1;
+		} else {
+
+			/* hw_param request while in AutoSync mode */
+			int external_freq =
+			    hdspm_external_sample_rate(hdspm);
+
+			if ((hdspm_autosync_ref(hdspm) ==
+			     HDSPM_AUTOSYNC_FROM_NONE)) {
+
+				snd_printk(KERN_WARNING "HDSPM: Detected no Externel Sync \n");
+				not_set = 1;
+
+			} else if (rate != external_freq) {
+
+				snd_printk
+				    (KERN_WARNING "HDSPM: Warning: No AutoSync source for requested rate\n");
+				not_set = 1;
+			}
+		}
+	}
+
+	current_rate = hdspm->system_sample_rate;
+
+	/* Changing between Singe, Double and Quad speed is not
+	   allowed if any substreams are open. This is because such a change
+	   causes a shift in the location of the DMA buffers and a reduction
+	   in the number of available buffers.
+
+	   Note that a similar but essentially insoluble problem exists for
+	   externally-driven rate changes. All we can do is to flag rate
+	   changes in the read/write routines.  
+	 */
+
+	switch (rate) {
+	case 32000:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency32KHz;
+		break;
+	case 44100:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency44_1KHz;
+		break;
+	case 48000:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency48KHz;
+		break;
+	case 64000:
+		if (current_rate <= 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency64KHz;
+		break;
+	case 88200:
+		if (current_rate <= 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency88_2KHz;
+		break;
+	case 96000:
+		if (current_rate <= 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency96KHz;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (reject_if_open
+	    && (hdspm->capture_pid >= 0 || hdspm->playback_pid >= 0)) {
+		snd_printk
+		    (KERN_ERR "HDSPM: cannot change between single- and double-speed mode (capture PID = %d, playback PID = %d)\n",
+		     hdspm->capture_pid, hdspm->playback_pid);
+		return -EBUSY;
+	}
+
+	hdspm->control_register &= ~HDSPM_FrequencyMask;
+	hdspm->control_register |= rate_bits;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	if (rate > 64000)
+		hdspm->channel_map = channel_map_madi_qs;
+	else if (rate > 48000)
+		hdspm->channel_map = channel_map_madi_ds;
+	else 
+		hdspm->channel_map = channel_map_madi_ss;
+
+	hdspm->system_sample_rate = rate;
+
+	if (not_set != 0)
+		return -1;
+
+	return 0;
+}
+
+/* mainly for init to 0 on load */
+static void all_in_all_mixer(hdspm_t * hdspm, int sgain)
+{
+	int i, j;
+	unsigned int gain =
+	    (sgain > UNITY_GAIN) ? UNITY_GAIN : (sgain < 0) ? 0 : sgain;
+
+	for (i = 0; i < HDSPM_MIXER_CHANNELS; i++)
+		for (j = 0; j < HDSPM_MIXER_CHANNELS; j++) {
+			hdspm_write_in_gain(hdspm, i, j, gain);
+			hdspm_write_pb_gain(hdspm, i, j, gain);
+		}
+}
+
+/*----------------------------------------------------------------------------
+   MIDI
+  ----------------------------------------------------------------------------*/
+
+static inline unsigned char snd_hdspm_midi_read_byte (hdspm_t *hdspm, int id)
+{
+	/* the hardware already does the relevant bit-mask with 0xff */
+	if (id)
+		return hdspm_read(hdspm, HDSPM_midiDataIn1);
+	else
+		return hdspm_read(hdspm, HDSPM_midiDataIn0);
+}
+
+static inline void snd_hdspm_midi_write_byte (hdspm_t *hdspm, int id, int val)
+{
+	/* the hardware already does the relevant bit-mask with 0xff */
+	if (id)
+		return hdspm_write(hdspm, HDSPM_midiDataOut1, val);
+	else
+		return hdspm_write(hdspm, HDSPM_midiDataOut0, val);
+}
+
+static inline int snd_hdspm_midi_input_available (hdspm_t *hdspm, int id)
+{
+	if (id)
+		return (hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xff);
+	else
+		return (hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xff);
+}
+
+static inline int snd_hdspm_midi_output_possible (hdspm_t *hdspm, int id)
+{
+	int fifo_bytes_used;
+
+	if (id)
+		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xff;
+	else
+		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xff;
+
+	if (fifo_bytes_used < 128)
+		return  128 - fifo_bytes_used;
+	else
+		return 0;
+}
+
+static inline void snd_hdspm_flush_midi_input (hdspm_t *hdspm, int id)
+{
+	while (snd_hdspm_midi_input_available (hdspm, id))
+		snd_hdspm_midi_read_byte (hdspm, id);
+}
+
+static int snd_hdspm_midi_output_write (hdspm_midi_t *hmidi)
+{
+	unsigned long flags;
+	int n_pending;
+	int to_write;
+	int i;
+	unsigned char buf[128];
+
+	/* Output is not interrupt driven */
+		
+	spin_lock_irqsave (&hmidi->lock, flags);
+	if (hmidi->output) {
+		if (!snd_rawmidi_transmit_empty (hmidi->output)) {
+			if ((n_pending = snd_hdspm_midi_output_possible (hmidi->hdspm, hmidi->id)) > 0) {
+				if (n_pending > (int)sizeof (buf))
+					n_pending = sizeof (buf);
+				
+				if ((to_write = snd_rawmidi_transmit (hmidi->output, buf, n_pending)) > 0) {
+					for (i = 0; i < to_write; ++i) 
+						snd_hdspm_midi_write_byte (hmidi->hdspm, hmidi->id, buf[i]);
+				}
+			}
+		}
+	}
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+	return 0;
+}
+
+static int snd_hdspm_midi_input_read (hdspm_midi_t *hmidi)
+{
+	unsigned char buf[128]; /* this buffer is designed to match the MIDI input FIFO size */
+	unsigned long flags;
+	int n_pending;
+	int i;
+
+	spin_lock_irqsave (&hmidi->lock, flags);
+	if ((n_pending = snd_hdspm_midi_input_available (hmidi->hdspm, hmidi->id)) > 0) {
+		if (hmidi->input) {
+			if (n_pending > (int)sizeof (buf)) {
+				n_pending = sizeof (buf);
+			}
+			for (i = 0; i < n_pending; ++i) {
+				buf[i] = snd_hdspm_midi_read_byte (hmidi->hdspm, hmidi->id);
+			}
+			if (n_pending) {
+				snd_rawmidi_receive (hmidi->input, buf, n_pending);
+			}
+		} else {
+			/* flush the MIDI input FIFO */
+			while (n_pending--) {
+				snd_hdspm_midi_read_byte (hmidi->hdspm, hmidi->id);
+			}
+		}
+	}
+	hmidi->pending = 0;
+	if (hmidi->id) {
+		hmidi->hdspm->control_register |= HDSPM_Midi1InterruptEnable;
+	} else {
+		hmidi->hdspm->control_register |= HDSPM_Midi0InterruptEnable;
+	}
+	hdspm_write(hmidi->hdspm, HDSPM_controlRegister, hmidi->hdspm->control_register);
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+	return snd_hdspm_midi_output_write (hmidi);
+}
+
+static void snd_hdspm_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	hdspm_t *hdspm;
+	hdspm_midi_t *hmidi;
+	unsigned long flags;
+	u32 ie;
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	hdspm = hmidi->hdspm;
+	ie = hmidi->id ? HDSPM_Midi1InterruptEnable : HDSPM_Midi0InterruptEnable;
+	spin_lock_irqsave (&hdspm->lock, flags);
+	if (up) {
+		if (!(hdspm->control_register & ie)) {
+			snd_hdspm_flush_midi_input (hdspm, hmidi->id);
+			hdspm->control_register |= ie;
+		}
+	} else {
+		hdspm->control_register &= ~ie;
+	}
+
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+	spin_unlock_irqrestore (&hdspm->lock, flags);
+}
+
+static void snd_hdspm_midi_output_timer(unsigned long data)
+{
+	hdspm_midi_t *hmidi = (hdspm_midi_t *) data;
+	unsigned long flags;
+	
+	snd_hdspm_midi_output_write(hmidi);
+	spin_lock_irqsave (&hmidi->lock, flags);
+
+	/* this does not bump hmidi->istimer, because the
+	   kernel automatically removed the timer when it
+	   expired, and we are now adding it back, thus
+	   leaving istimer wherever it was set before.  
+	*/
+
+	if (hmidi->istimer) {
+		hmidi->timer.expires = 1 + jiffies;
+		add_timer(&hmidi->timer);
+	}
+
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+}
+
+static void snd_hdspm_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	hdspm_midi_t *hmidi;
+	unsigned long flags;
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irqsave (&hmidi->lock, flags);
+	if (up) {
+		if (!hmidi->istimer) {
+			init_timer(&hmidi->timer);
+			hmidi->timer.function = snd_hdspm_midi_output_timer;
+			hmidi->timer.data = (unsigned long) hmidi;
+			hmidi->timer.expires = 1 + jiffies;
+			add_timer(&hmidi->timer);
+			hmidi->istimer++;
+		}
+	} else {
+		if (hmidi->istimer && --hmidi->istimer <= 0) {
+			del_timer (&hmidi->timer);
+		}
+	}
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+	if (up)
+		snd_hdspm_midi_output_write(hmidi);
+}
+
+static int snd_hdspm_midi_input_open(snd_rawmidi_substream_t * substream)
+{
+	hdspm_midi_t *hmidi;
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irq (&hmidi->lock);
+	snd_hdspm_flush_midi_input (hmidi->hdspm, hmidi->id);
+	hmidi->input = substream;
+	spin_unlock_irq (&hmidi->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_midi_output_open(snd_rawmidi_substream_t * substream)
+{
+	hdspm_midi_t *hmidi;
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irq (&hmidi->lock);
+	hmidi->output = substream;
+	spin_unlock_irq (&hmidi->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_midi_input_close(snd_rawmidi_substream_t * substream)
+{
+	hdspm_midi_t *hmidi;
+
+	snd_hdspm_midi_input_trigger (substream, 0);
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irq (&hmidi->lock);
+	hmidi->input = NULL;
+	spin_unlock_irq (&hmidi->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_midi_output_close(snd_rawmidi_substream_t * substream)
+{
+	hdspm_midi_t *hmidi;
+
+	snd_hdspm_midi_output_trigger (substream, 0);
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irq (&hmidi->lock);
+	hmidi->output = NULL;
+	spin_unlock_irq (&hmidi->lock);
+
+	return 0;
+}
+
+snd_rawmidi_ops_t snd_hdspm_midi_output =
+{
+	.open =		snd_hdspm_midi_output_open,
+	.close =	snd_hdspm_midi_output_close,
+	.trigger =	snd_hdspm_midi_output_trigger,
+};
+
+snd_rawmidi_ops_t snd_hdspm_midi_input =
+{
+	.open =		snd_hdspm_midi_input_open,
+	.close =	snd_hdspm_midi_input_close,
+	.trigger =	snd_hdspm_midi_input_trigger,
+};
+
+static int __devinit snd_hdspm_create_midi (snd_card_t *card, hdspm_t *hdspm, int id)
+{
+	int err;
+	char buf[32];
+
+	hdspm->midi[id].id = id;
+	hdspm->midi[id].rmidi = NULL;
+	hdspm->midi[id].input = NULL;
+	hdspm->midi[id].output = NULL;
+	hdspm->midi[id].hdspm = hdspm;
+	hdspm->midi[id].istimer = 0;
+	hdspm->midi[id].pending = 0;
+	spin_lock_init (&hdspm->midi[id].lock);
+
+	sprintf (buf, "%s MIDI %d", card->shortname, id+1);
+	if ((err = snd_rawmidi_new (card, buf, id, 1, 1, &hdspm->midi[id].rmidi)) < 0)
+		return err;
+
+	sprintf (hdspm->midi[id].rmidi->name, "%s MIDI %d", card->id, id+1);
+	hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
+
+	snd_rawmidi_set_ops (hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_hdspm_midi_output);
+	snd_rawmidi_set_ops (hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_hdspm_midi_input);
+
+	hdspm->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
+		SNDRV_RAWMIDI_INFO_INPUT |
+		SNDRV_RAWMIDI_INFO_DUPLEX;
+
+	return 0;
+}
+
+
+static void hdspm_midi_tasklet(unsigned long arg)
+{
+	hdspm_t *hdspm = (hdspm_t *)arg;
+	
+	if (hdspm->midi[0].pending)
+		snd_hdspm_midi_input_read (&hdspm->midi[0]);
+	if (hdspm->midi[1].pending)
+		snd_hdspm_midi_input_read (&hdspm->midi[1]);
+} 
+
+
+/*-----------------------------------------------------------------------------
+  Status Interface
+  ----------------------------------------------------------------------------*/
+
+/* get the system sample rate which is set */
+
+#define HDSPM_SYSTEM_SAMPLE_RATE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .info = snd_hdspm_info_system_sample_rate, \
+  .get = snd_hdspm_get_system_sample_rate \
+}
+
+static int snd_hdspm_info_system_sample_rate(snd_kcontrol_t * kcontrol,
+					     snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_system_sample_rate(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_value_t *
+					    ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm->system_sample_rate;
+	return 0;
+}
+
+#define HDSPM_AUTOSYNC_SAMPLE_RATE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .info = snd_hdspm_info_autosync_sample_rate, \
+  .get = snd_hdspm_get_autosync_sample_rate \
+}
+
+static int snd_hdspm_info_autosync_sample_rate(snd_kcontrol_t * kcontrol,
+					       snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "32000", "44100", "48000",
+		"64000", "88200", "96000",
+		"128000", "176400", "192000",
+		"None"
+	};
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 10;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdspm_get_autosync_sample_rate(snd_kcontrol_t * kcontrol,
+					      snd_ctl_elem_value_t *
+					      ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	switch (hdspm_external_sample_rate(hdspm)) {
+	case 32000:
+		ucontrol->value.enumerated.item[0] = 0;
+		break;
+	case 44100:
+		ucontrol->value.enumerated.item[0] = 1;
+		break;
+	case 48000:
+		ucontrol->value.enumerated.item[0] = 2;
+		break;
+	case 64000:
+		ucontrol->value.enumerated.item[0] = 3;
+		break;
+	case 88200:
+		ucontrol->value.enumerated.item[0] = 4;
+		break;
+	case 96000:
+		ucontrol->value.enumerated.item[0] = 5;
+		break;
+	case 128000:
+		ucontrol->value.enumerated.item[0] = 6;
+		break;
+	case 176400:
+		ucontrol->value.enumerated.item[0] = 7;
+		break;
+	case 192000:
+		ucontrol->value.enumerated.item[0] = 8;
+		break;
+
+	default:
+		ucontrol->value.enumerated.item[0] = 9;
+	}
+	return 0;
+}
+
+#define HDSPM_SYSTEM_CLOCK_MODE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .info = snd_hdspm_info_system_clock_mode, \
+  .get = snd_hdspm_get_system_clock_mode, \
+}
+
+
+
+static int hdspm_system_clock_mode(hdspm_t * hdspm)
+{
+        /* Always reflect the hardware info, rme is never wrong !!!! */
+
+	if (hdspm->control_register & HDSPM_ClockModeMaster)
+		return 0;
+	return 1;
+}
+
+static int snd_hdspm_info_system_clock_mode(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "Master", "Slave" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdspm_get_system_clock_mode(snd_kcontrol_t * kcontrol,
+					   snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] =
+	    hdspm_system_clock_mode(hdspm);
+	return 0;
+}
+
+#define HDSPM_CLOCK_SOURCE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_clock_source, \
+  .get = snd_hdspm_get_clock_source, \
+  .put = snd_hdspm_put_clock_source \
+}
+
+static int hdspm_clock_source(hdspm_t * hdspm)
+{
+	if (hdspm->control_register & HDSPM_ClockModeMaster) {
+		switch (hdspm->system_sample_rate) {
+		case 32000:
+			return 1;
+		case 44100:
+			return 2;
+		case 48000:
+			return 3;
+		case 64000:
+			return 4;
+		case 88200:
+			return 5;
+		case 96000:
+			return 6;
+		case 128000:
+			return 7;
+		case 176400:
+			return 8;
+		case 192000:
+			return 9;
+		default:
+			return 3;
+		}
+	} else {
+		return 0;
+	}
+}
+
+static int hdspm_set_clock_source(hdspm_t * hdspm, int mode)
+{
+	int rate;
+	switch (mode) {
+
+	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
+		if (hdspm_external_sample_rate(hdspm) != 0) {
+			hdspm->control_register &= ~HDSPM_ClockModeMaster;
+			hdspm_write(hdspm, HDSPM_controlRegister,
+				    hdspm->control_register);
+			return 0;
+		}
+		return -1;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
+		rate = 32000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
+		rate = 44100;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
+		rate = 48000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
+		rate = 64000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
+		rate = 88200;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
+		rate = 96000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ:
+		rate = 128000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ:
+		rate = 176400;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ:
+		rate = 192000;
+		break;
+
+	default:
+		rate = 44100;
+	}
+	hdspm->control_register |= HDSPM_ClockModeMaster;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+	hdspm_set_rate(hdspm, rate, 1);
+	return 0;
+}
+
+static int snd_hdspm_info_clock_source(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "AutoSync",
+		"Internal 32.0 kHz", "Internal 44.1 kHz",
+		    "Internal 48.0 kHz",
+		"Internal 64.0 kHz", "Internal 88.2 kHz",
+		    "Internal 96.0 kHz",
+		"Internal 128.0 kHz", "Internal 176.4 kHz",
+		    "Internal 192.0 kHz"
+	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 10;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_clock_source(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_clock_source(hdspm);
+	return 0;
+}
+
+static int snd_hdspm_put_clock_source(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.enumerated.item[0];
+	if (val < 0)
+		val = 0;
+	if (val > 6)
+		val = 6;
+	spin_lock_irq(&hdspm->lock);
+	if (val != hdspm_clock_source(hdspm))
+		change = (hdspm_set_clock_source(hdspm, val) == 0) ? 1 : 0;
+	else
+		change = 0;
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_PREF_SYNC_REF(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_pref_sync_ref, \
+  .get = snd_hdspm_get_pref_sync_ref, \
+  .put = snd_hdspm_put_pref_sync_ref \
+}
+
+static int hdspm_pref_sync_ref(hdspm_t * hdspm)
+{
+	/* Notice that this looks at the requested sync source,
+	   not the one actually in use.
+	 */
+	switch (hdspm->control_register & HDSPM_SyncRefMask) {
+	case HDSPM_SyncRef_Word:
+		return HDSPM_SYNC_FROM_WORD;
+	case HDSPM_SyncRef_MADI:
+		return HDSPM_SYNC_FROM_MADI;
+	}
+
+	return HDSPM_SYNC_FROM_WORD;
+}
+
+static int hdspm_set_pref_sync_ref(hdspm_t * hdspm, int pref)
+{
+	hdspm->control_register &= ~HDSPM_SyncRefMask;
+
+	switch (pref) {
+	case HDSPM_SYNC_FROM_MADI:
+		hdspm->control_register |= HDSPM_SyncRef_MADI;
+		break;
+	case HDSPM_SYNC_FROM_WORD:
+		hdspm->control_register |= HDSPM_SyncRef_Word;
+		break;
+	default:
+		return -1;
+	}
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+	return 0;
+}
+
+static int snd_hdspm_info_pref_sync_ref(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "Word", "MADI" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdspm_get_pref_sync_ref(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_pref_sync_ref(hdspm);
+	return 0;
+}
+
+static int snd_hdspm_put_pref_sync_ref(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change, max;
+	unsigned int val;
+
+	max = 2;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+
+	val = ucontrol->value.enumerated.item[0] % max;
+
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_pref_sync_ref(hdspm);
+	hdspm_set_pref_sync_ref(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_AUTOSYNC_REF(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .info = snd_hdspm_info_autosync_ref, \
+  .get = snd_hdspm_get_autosync_ref, \
+}
+
+static int hdspm_autosync_ref(hdspm_t * hdspm)
+{
+	/* This looks at the autosync selected sync reference */
+	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+
+	switch (status2 & HDSPM_SelSyncRefMask) {
+
+	case HDSPM_SelSyncRef_WORD:
+		return HDSPM_AUTOSYNC_FROM_WORD;
+
+	case HDSPM_SelSyncRef_MADI:
+		return HDSPM_AUTOSYNC_FROM_MADI;
+
+	case HDSPM_SelSyncRef_NVALID:
+		return HDSPM_AUTOSYNC_FROM_NONE;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int snd_hdspm_info_autosync_ref(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "WordClock", "MADI", "None" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdspm_get_autosync_ref(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_pref_sync_ref(hdspm);
+	return 0;
+}
+
+#define HDSPM_LINE_OUT(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_line_out, \
+  .get = snd_hdspm_get_line_out, \
+  .put = snd_hdspm_put_line_out \
+}
+
+static int hdspm_line_out(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_LineOut) ? 1 : 0;
+}
+
+
+static int hdspm_set_line_output(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_LineOut;
+	else
+		hdspm->control_register &= ~HDSPM_LineOut;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_line_out(snd_kcontrol_t * kcontrol,
+				   snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_line_out(snd_kcontrol_t * kcontrol,
+				  snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_line_out(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_line_out(snd_kcontrol_t * kcontrol,
+				  snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_line_out(hdspm);
+	hdspm_set_line_output(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_TX_64(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_tx_64, \
+  .get = snd_hdspm_get_tx_64, \
+  .put = snd_hdspm_put_tx_64 \
+}
+
+static int hdspm_tx_64(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_TX_64ch) ? 1 : 0;
+}
+
+static int hdspm_set_tx_64(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_TX_64ch;
+	else
+		hdspm->control_register &= ~HDSPM_TX_64ch;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_tx_64(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_tx_64(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_tx_64(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_tx_64(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_tx_64(hdspm);
+	hdspm_set_tx_64(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_C_TMS(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_c_tms, \
+  .get = snd_hdspm_get_c_tms, \
+  .put = snd_hdspm_put_c_tms \
+}
+
+static int hdspm_c_tms(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_clr_tms) ? 1 : 0;
+}
+
+static int hdspm_set_c_tms(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_clr_tms;
+	else
+		hdspm->control_register &= ~HDSPM_clr_tms;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_c_tms(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_c_tms(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_c_tms(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_c_tms(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_c_tms(hdspm);
+	hdspm_set_c_tms(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_SAFE_MODE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_safe_mode, \
+  .get = snd_hdspm_get_safe_mode, \
+  .put = snd_hdspm_put_safe_mode \
+}
+
+static int hdspm_safe_mode(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
+}
+
+static int hdspm_set_safe_mode(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_AutoInp;
+	else
+		hdspm->control_register &= ~HDSPM_AutoInp;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_safe_mode(snd_kcontrol_t * kcontrol,
+				    snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_safe_mode(snd_kcontrol_t * kcontrol,
+				   snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_safe_mode(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_safe_mode(snd_kcontrol_t * kcontrol,
+				   snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_safe_mode(hdspm);
+	hdspm_set_safe_mode(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_INPUT_SELECT(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_input_select, \
+  .get = snd_hdspm_get_input_select, \
+  .put = snd_hdspm_put_input_select \
+}
+
+static int hdspm_input_select(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;
+}
+
+static int hdspm_set_input_select(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_InputSelect0;
+	else
+		hdspm->control_register &= ~HDSPM_InputSelect0;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_input_select(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "optical", "coaxial" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_input_select(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_input_select(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_input_select(hdspm);
+	hdspm_set_input_select(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+/*           Simple Mixer
+  deprecated since to much faders ???
+  MIXER interface says output (source, destination, value)
+   where source > MAX_channels are playback channels 
+   on MADICARD 
+  - playback mixer matrix: [channelout+64] [output] [value]
+  - input(thru) mixer matrix: [channelin] [output] [value]
+  (better do 2 kontrols for seperation ?)
+*/
+
+#define HDSPM_MIXER(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+		 SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_mixer, \
+  .get = snd_hdspm_get_mixer, \
+  .put = snd_hdspm_put_mixer \
+}
+
+static int snd_hdspm_info_mixer(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 3;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 65535;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_mixer(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int source;
+	int destination;
+
+	source = ucontrol->value.integer.value[0];
+	if (source < 0)
+		source = 0;
+	else if (source >= 2 * HDSPM_MAX_CHANNELS)
+		source = 2 * HDSPM_MAX_CHANNELS - 1;
+
+	destination = ucontrol->value.integer.value[1];
+	if (destination < 0)
+		destination = 0;
+	else if (destination >= HDSPM_MAX_CHANNELS)
+		destination = HDSPM_MAX_CHANNELS - 1;
+
+	spin_lock_irq(&hdspm->lock);
+	if (source >= HDSPM_MAX_CHANNELS)
+		ucontrol->value.integer.value[2] =
+		    hdspm_read_pb_gain(hdspm, destination,
+				       source - HDSPM_MAX_CHANNELS);
+	else
+		ucontrol->value.integer.value[2] =
+		    hdspm_read_in_gain(hdspm, destination, source);
+
+	spin_unlock_irq(&hdspm->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_put_mixer(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	int source;
+	int destination;
+	int gain;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+
+	source = ucontrol->value.integer.value[0];
+	destination = ucontrol->value.integer.value[1];
+
+	if (source < 0 || source >= 2 * HDSPM_MAX_CHANNELS)
+		return -1;
+	if (destination < 0 || destination >= HDSPM_MAX_CHANNELS)
+		return -1;
+
+	gain = ucontrol->value.integer.value[2];
+
+	spin_lock_irq(&hdspm->lock);
+
+	if (source >= HDSPM_MAX_CHANNELS)
+		change = gain != hdspm_read_pb_gain(hdspm, destination,
+						    source -
+						    HDSPM_MAX_CHANNELS);
+	else
+		change =
+		    gain != hdspm_read_in_gain(hdspm, destination, source);
+
+	if (change) {
+		if (source >= HDSPM_MAX_CHANNELS)
+			hdspm_write_pb_gain(hdspm, destination,
+					    source - HDSPM_MAX_CHANNELS,
+					    gain);
+		else
+			hdspm_write_in_gain(hdspm, destination, source,
+					    gain);
+	}
+	spin_unlock_irq(&hdspm->lock);
+
+	return change;
+}
+
+/* The simple mixer control(s) provide gain control for the
+   basic 1:1 mappings of playback streams to output
+   streams. 
+*/
+
+#define HDSPM_PLAYBACK_MIXER \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE | \
+		 SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_playback_mixer, \
+  .get = snd_hdspm_get_playback_mixer, \
+  .put = snd_hdspm_put_playback_mixer \
+}
+
+static int snd_hdspm_info_playback_mixer(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 65536;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_playback_mixer(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int channel;
+	int mapped_channel;
+
+	channel = ucontrol->id.index - 1;
+
+	snd_assert(channel >= 0
+		   || channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+
+	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+		return -EINVAL;
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] =
+	    hdspm_read_pb_gain(hdspm, mapped_channel, mapped_channel);
+	spin_unlock_irq(&hdspm->lock);
+
+	/*    snd_printdd("get pb mixer index %d, channel %d, mapped_channel %d, value %d\n",
+	   ucontrol->id.index,        channel, mapped_channel,  ucontrol->value.integer.value[0]); 
+	 */
+
+	return 0;
+}
+
+static int snd_hdspm_put_playback_mixer(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	int channel;
+	int mapped_channel;
+	int gain;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+
+	channel = ucontrol->id.index - 1;
+
+	snd_assert(channel >= 0
+		   || channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+
+	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+		return -EINVAL;
+
+	gain = ucontrol->value.integer.value[0];
+
+	spin_lock_irq(&hdspm->lock);
+	change =
+	    gain != hdspm_read_pb_gain(hdspm, mapped_channel,
+				       mapped_channel);
+	if (change)
+		hdspm_write_pb_gain(hdspm, mapped_channel, mapped_channel,
+				    gain);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_WC_SYNC_CHECK(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_sync_check, \
+  .get = snd_hdspm_get_wc_sync_check \
+}
+
+static int snd_hdspm_info_sync_check(snd_kcontrol_t * kcontrol,
+				     snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "No Lock", "Lock", "Sync" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int hdspm_wc_sync_check(hdspm_t * hdspm)
+{
+	int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	if (status2 & HDSPM_wcLock) {
+		if (status2 & HDSPM_wcSync)
+			return 2;
+		else
+			return 1;
+	}
+	return 0;
+}
+
+static int snd_hdspm_get_wc_sync_check(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_wc_sync_check(hdspm);
+	return 0;
+}
+
+
+#define HDSPM_MADI_SYNC_CHECK(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_sync_check, \
+  .get = snd_hdspm_get_madisync_sync_check \
+}
+
+static int hdspm_madisync_sync_check(hdspm_t * hdspm)
+{
+	int status = hdspm_read(hdspm, HDSPM_statusRegister);
+	if (status & HDSPM_madiLock) {
+		if (status & HDSPM_madiSync)
+			return 2;
+		else
+			return 1;
+	}
+	return 0;
+}
+
+static int snd_hdspm_get_madisync_sync_check(snd_kcontrol_t * kcontrol,
+					     snd_ctl_elem_value_t *
+					     ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] =
+	    hdspm_madisync_sync_check(hdspm);
+	return 0;
+}
+
+
+
+
+static snd_kcontrol_new_t snd_hdspm_controls[] = {
+
+	HDSPM_MIXER("Mixer", 0),
+/* 'Sample Clock Source' complies with the alsa control naming scheme */
+	HDSPM_CLOCK_SOURCE("Sample Clock Source", 0),
+
+	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
+	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
+	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
+	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
+/* 'External Rate' complies with the alsa control naming scheme */
+	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
+	HDSPM_WC_SYNC_CHECK("Word Clock Lock Status", 0),
+	HDSPM_MADI_SYNC_CHECK("MADI Sync Lock Status", 0),
+	HDSPM_LINE_OUT("Line Out", 0),
+	HDSPM_TX_64("TX 64 channels mode", 0),
+	HDSPM_C_TMS("Clear Track Marker", 0),
+	HDSPM_SAFE_MODE("Safe Mode", 0),
+	HDSPM_INPUT_SELECT("Input Select", 0),
+};
+
+static snd_kcontrol_new_t snd_hdspm_playback_mixer = HDSPM_PLAYBACK_MIXER;
+
+
+static int hdspm_update_simple_mixer_controls(hdspm_t * hdspm)
+{
+	int i;
+
+	for (i = hdspm->ds_channels; i < hdspm->ss_channels; ++i) {
+		if (hdspm->system_sample_rate > 48000) {
+			hdspm->playback_mixer_ctls[i]->vd[0].access =
+			    SNDRV_CTL_ELEM_ACCESS_INACTIVE |
+			    SNDRV_CTL_ELEM_ACCESS_READ |
+			    SNDRV_CTL_ELEM_ACCESS_VOLATILE;
+		} else {
+			hdspm->playback_mixer_ctls[i]->vd[0].access =
+			    SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			    SNDRV_CTL_ELEM_ACCESS_VOLATILE;
+		}
+		snd_ctl_notify(hdspm->card, SNDRV_CTL_EVENT_MASK_VALUE |
+			       SNDRV_CTL_EVENT_MASK_INFO,
+			       &hdspm->playback_mixer_ctls[i]->id);
+	}
+
+	return 0;
+}
+
+
+static int snd_hdspm_create_controls(snd_card_t * card, hdspm_t * hdspm)
+{
+	unsigned int idx, limit;
+	int err;
+	snd_kcontrol_t *kctl;
+
+	/* add control list first */
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls); idx++) {
+		if ((err =
+		     snd_ctl_add(card, kctl =
+				 snd_ctl_new1(&snd_hdspm_controls[idx],
+					      hdspm))) < 0) {
+			return err;
+		}
+	}
+
+	/* Channel playback mixer as default control 
+	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats to big for any alsamixer 
+	   they are accesible via special IOCTL on hwdep
+	   and the mixer 2dimensional mixer control */
+
+	snd_hdspm_playback_mixer.name = "Chn";
+	limit = HDSPM_MAX_CHANNELS;
+
+	/* The index values are one greater than the channel ID so that alsamixer
+	   will display them correctly. We want to use the index for fast lookup
+	   of the relevant channel, but if we use it at all, most ALSA software
+	   does the wrong thing with it ...
+	 */
+
+	for (idx = 0; idx < limit; ++idx) {
+		snd_hdspm_playback_mixer.index = idx + 1;
+		if ((err = snd_ctl_add(card,
+				       kctl =
+				       snd_ctl_new1
+				       (&snd_hdspm_playback_mixer,
+					hdspm)))) {
+			return err;
+		}
+		hdspm->playback_mixer_ctls[idx] = kctl;
+	}
+
+	return 0;
+}
+
+/*------------------------------------------------------------
+   /proc interface 
+ ------------------------------------------------------------*/
+
+static void
+snd_hdspm_proc_read(snd_info_entry_t * entry, snd_info_buffer_t * buffer)
+{
+	hdspm_t *hdspm = (hdspm_t *) entry->private_data;
+	unsigned int status;
+	unsigned int status2;
+	char *pref_sync_ref;
+	char *autosync_ref;
+	char *system_clock_mode;
+	char *clock_source;
+	char *insel;
+	char *syncref;
+	int x, x2;
+
+	status = hdspm_read(hdspm, HDSPM_statusRegister);
+	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+
+	snd_iprintf(buffer, "%s (Card #%d) Rev.%x Status2first3bits: %x\n",
+		    hdspm->card_name, hdspm->card->number + 1,
+		    hdspm->firmware_rev,
+		    (status2 & HDSPM_version0) |
+		    (status2 & HDSPM_version1) | (status2 &
+						  HDSPM_version2));
+
+	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
+		    hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
+
+	snd_iprintf(buffer, "--- System ---\n");
+
+	snd_iprintf(buffer,
+		    "IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",
+		    status & HDSPM_audioIRQPending,
+		    (status & HDSPM_midi0IRQPending) ? 1 : 0,
+		    (status & HDSPM_midi1IRQPending) ? 1 : 0,
+		    hdspm->irq_count);
+	snd_iprintf(buffer,
+		    "HW pointer: id = %d, rawptr = %d (%d->%d) estimated= %ld (bytes)\n",
+		    ((status & HDSPM_BufferID) ? 1 : 0),
+		    (status & HDSPM_BufferPositionMask),
+		    (status & HDSPM_BufferPositionMask) % (2 *
+							   (int)hdspm->
+							   period_bytes),
+		    ((status & HDSPM_BufferPositionMask) -
+		     64) % (2 * (int)hdspm->period_bytes),
+		    (long) hdspm_hw_pointer(hdspm) * 4);
+
+	snd_iprintf(buffer,
+		    "MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",
+		    hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
+	snd_iprintf(buffer,
+		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, status2=0x%x\n",
+		    hdspm->control_register, hdspm->control2_register,
+		    status, status2);
+
+	snd_iprintf(buffer, "--- Settings ---\n");
+
+	x = 1 << (6 +
+		  hdspm_decode_latency(hdspm->
+				       control_register &
+				       HDSPM_LatencyMask));
+
+	snd_iprintf(buffer,
+		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",
+		    x, (unsigned long) hdspm->period_bytes);
+
+	snd_iprintf(buffer, "Line out: %s,   Precise Pointer: %s\n",
+		    (hdspm->
+		     control_register & HDSPM_LineOut) ? "on " : "off",
+		    (hdspm->precise_ptr) ? "on" : "off");
+
+	switch (hdspm->control_register & HDSPM_InputMask) {
+	case HDSPM_InputOptical:
+		insel = "Optical";
+		break;
+	case HDSPM_InputCoaxial:
+		insel = "Coaxial";
+		break;
+	default:
+		insel = "Unkown";
+	}
+
+	switch (hdspm->control_register & HDSPM_SyncRefMask) {
+	case HDSPM_SyncRef_Word:
+		syncref = "WordClock";
+		break;
+	case HDSPM_SyncRef_MADI:
+		syncref = "MADI";
+		break;
+	default:
+		syncref = "Unkown";
+	}
+	snd_iprintf(buffer, "Inputsel = %s, SyncRef = %s\n", insel,
+		    syncref);
+
+	snd_iprintf(buffer,
+		    "ClearTrackMarker = %s, Transmit in %s Channel Mode, Auto Input %s\n",
+		    (hdspm->
+		     control_register & HDSPM_clr_tms) ? "on" : "off",
+		    (hdspm->
+		     control_register & HDSPM_TX_64ch) ? "64" : "56",
+		    (hdspm->
+		     control_register & HDSPM_AutoInp) ? "on" : "off");
+
+	switch (hdspm_clock_source(hdspm)) {
+	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
+		clock_source = "AutoSync";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
+		clock_source = "Internal 32 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
+		clock_source = "Internal 44.1 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
+		clock_source = "Internal 48 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
+		clock_source = "Internal 64 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
+		clock_source = "Internal 88.2 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
+		clock_source = "Internal 96 kHz";
+		break;
+	default:
+		clock_source = "Error";
+	}
+	snd_iprintf(buffer, "Sample Clock Source: %s\n", clock_source);
+	if (!(hdspm->control_register & HDSPM_ClockModeMaster)) {
+		system_clock_mode = "Slave";
+	} else {
+		system_clock_mode = "Master";
+	}
+	snd_iprintf(buffer, "System Clock Mode: %s\n", system_clock_mode);
+
+	switch (hdspm_pref_sync_ref(hdspm)) {
+	case HDSPM_SYNC_FROM_WORD:
+		pref_sync_ref = "Word Clock";
+		break;
+	case HDSPM_SYNC_FROM_MADI:
+		pref_sync_ref = "MADI Sync";
+		break;
+	default:
+		pref_sync_ref = "XXXX Clock";
+		break;
+	}
+	snd_iprintf(buffer, "Preferred Sync Reference: %s\n",
+		    pref_sync_ref);
+
+	snd_iprintf(buffer, "System Clock Frequency: %d\n",
+		    hdspm->system_sample_rate);
+
+
+	snd_iprintf(buffer, "--- Status:\n");
+
+	x = status & HDSPM_madiSync;
+	x2 = status2 & HDSPM_wcSync;
+
+	snd_iprintf(buffer, "Inputs MADI=%s, WordClock=%s\n",
+		    (status & HDSPM_madiLock) ? (x ? "Sync" : "Lock") :
+		    "NoLock",
+		    (status2 & HDSPM_wcLock) ? (x2 ? "Sync" : "Lock") :
+		    "NoLock");
+
+	switch (hdspm_autosync_ref(hdspm)) {
+	case HDSPM_AUTOSYNC_FROM_WORD:
+		autosync_ref = "Word Clock";
+		break;
+	case HDSPM_AUTOSYNC_FROM_MADI:
+		autosync_ref = "MADI Sync";
+		break;
+	case HDSPM_AUTOSYNC_FROM_NONE:
+		autosync_ref = "Input not valid";
+		break;
+	default:
+		autosync_ref = "---";
+		break;
+	}
+	snd_iprintf(buffer,
+		    "AutoSync: Reference= %s, Freq=%d (MADI = %d, Word = %d)\n",
+		    autosync_ref, hdspm_external_sample_rate(hdspm),
+		    (status & HDSPM_madiFreqMask) >> 22,
+		    (status2 & HDSPM_wcFreqMask) >> 5);
+
+	snd_iprintf(buffer, "Input: %s, Mode=%s\n",
+		    (status & HDSPM_AB_int) ? "Coax" : "Optical",
+		    (status & HDSPM_RX_64ch) ? "64 channels" :
+		    "56 channels");
+
+	snd_iprintf(buffer, "\n");
+}
+
+static void __devinit snd_hdspm_proc_init(hdspm_t * hdspm)
+{
+	snd_info_entry_t *entry;
+
+	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry))
+		snd_info_set_text_ops(entry, hdspm, 1024,
+				      snd_hdspm_proc_read);
+}
+
+/*------------------------------------------------------------
+   hdspm intitialize 
+ ------------------------------------------------------------*/
+
+static int snd_hdspm_set_defaults(hdspm_t * hdspm)
+{
+	unsigned int i;
+
+	/* ASSUMPTION: hdspm->lock is either held, or there is no need to
+	   hold it (e.g. during module initalization).
+	 */
+
+	/* set defaults:       */
+
+	hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+	    hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
+	    HDSPM_InputCoaxial |	/* Input Coax not Optical */
+	    HDSPM_SyncRef_MADI |	/* Madi is syncclock */
+	    HDSPM_LineOut |	/* Analog output in */
+	    HDSPM_TX_64ch |	/* transmit in 64ch mode */
+	    HDSPM_AutoInp;	/* AutoInput chossing (takeover) */
+
+	/* ! HDSPM_Frequency0|HDSPM_Frequency1 = 44.1khz */
+	/* !  HDSPM_DoubleSpeed HDSPM_QuadSpeed = normal speed */
+	/* ! HDSPM_clr_tms = do not clear bits in track marks */
+
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+#ifdef SNDRV_BIG_ENDIAN
+	hdspm->control2_register = HDSPM_BIGENDIAN_MODE;
+#else
+	hdspm->control2_register = 0;
+#endif
+
+	hdspm_write(hdspm, HDSPM_control2Reg, hdspm->control2_register);
+	hdspm_compute_period_size(hdspm);
+
+	/* silence everything */
+
+	all_in_all_mixer(hdspm, 0 * UNITY_GAIN);
+
+	if (line_outs_monitor[hdspm->dev]) {
+
+		snd_printk(KERN_INFO "HDSPM: sending all playback streams to line outs.\n");
+
+		for (i = 0; i < HDSPM_MIXER_CHANNELS; i++) {
+			if (hdspm_write_pb_gain(hdspm, i, i, UNITY_GAIN))
+				return -EIO;
+		}
+	}
+
+	/* set a default rate so that the channel map is set up. */
+	hdspm->channel_map = channel_map_madi_ss;
+	hdspm_set_rate(hdspm, 44100, 1);
+
+	return 0;
+}
+
+
+/*------------------------------------------------------------
+   interupt 
+ ------------------------------------------------------------*/
+
+static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id,
+				       struct pt_regs *regs)
+{
+	hdspm_t *hdspm = (hdspm_t *) dev_id;
+	unsigned int status;
+	int audio;
+	int midi0;
+	int midi1;
+	unsigned int midi0status;
+	unsigned int midi1status;
+	int schedule = 0;
+
+	status = hdspm_read(hdspm, HDSPM_statusRegister);
+
+	audio = status & HDSPM_audioIRQPending;
+	midi0 = status & HDSPM_midi0IRQPending;
+	midi1 = status & HDSPM_midi1IRQPending;
+
+	if (!audio && !midi0 && !midi1)
+		return IRQ_NONE;
+
+	hdspm_write(hdspm, HDSPM_interruptConfirmation, 0);
+	hdspm->irq_count++;
+
+	midi0status = hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xff;
+	midi1status = hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xff;
+
+	if (audio) {
+
+		if (hdspm->capture_substream)
+			snd_pcm_period_elapsed(hdspm->pcm->
+					       streams
+					       [SNDRV_PCM_STREAM_CAPTURE].
+					       substream);
+
+		if (hdspm->playback_substream)
+			snd_pcm_period_elapsed(hdspm->pcm->
+					       streams
+					       [SNDRV_PCM_STREAM_PLAYBACK].
+					       substream);
+	}
+
+	if (midi0 && midi0status) {
+		/* we disable interrupts for this input until processing is done */
+		hdspm->control_register &= ~HDSPM_Midi0InterruptEnable;
+		hdspm_write(hdspm, HDSPM_controlRegister,
+			    hdspm->control_register);
+		hdspm->midi[0].pending = 1;
+		schedule = 1;
+	}
+	if (midi1 && midi1status) {
+		/* we disable interrupts for this input until processing is done */
+		hdspm->control_register &= ~HDSPM_Midi1InterruptEnable;
+		hdspm_write(hdspm, HDSPM_controlRegister,
+			    hdspm->control_register);
+		hdspm->midi[1].pending = 1;
+		schedule = 1;
+	}
+	if (schedule)
+		tasklet_hi_schedule(&hdspm->midi_tasklet);
+	return IRQ_HANDLED;
+}
+
+/*------------------------------------------------------------
+   pcm interface 
+  ------------------------------------------------------------*/
+
+
+static snd_pcm_uframes_t snd_hdspm_hw_pointer(snd_pcm_substream_t *
+					      substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	return hdspm_hw_pointer(hdspm);
+}
+
+static char *hdspm_channel_buffer_location(hdspm_t * hdspm,
+					   int stream, int channel)
+{
+	int mapped_channel;
+
+	snd_assert(channel >= 0
+		   || channel < HDSPM_MAX_CHANNELS, return NULL);
+
+	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+		return NULL;
+
+	if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+		return hdspm->capture_buffer +
+		    mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
+	} else {
+		return hdspm->playback_buffer +
+		    mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
+	}
+}
+
+
+/* dont know why need it ??? */
+static int snd_hdspm_playback_copy(snd_pcm_substream_t * substream,
+				   int channel, snd_pcm_uframes_t pos,
+				   void __user *src, snd_pcm_uframes_t count)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
+		   return -EINVAL);
+
+	channel_buf = hdspm_channel_buffer_location(hdspm,
+						    substream->pstr->
+						    stream, channel);
+
+	snd_assert(channel_buf != NULL, return -EIO);
+
+	return copy_from_user(channel_buf + pos * 4, src, count * 4);
+}
+
+static int snd_hdspm_capture_copy(snd_pcm_substream_t * substream,
+				  int channel, snd_pcm_uframes_t pos,
+				  void __user *dst, snd_pcm_uframes_t count)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
+		   return -EINVAL);
+
+	channel_buf = hdspm_channel_buffer_location(hdspm,
+						    substream->pstr->
+						    stream, channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	return copy_to_user(dst, channel_buf + pos * 4, count * 4);
+}
+
+static int snd_hdspm_hw_silence(snd_pcm_substream_t * substream,
+				int channel, snd_pcm_uframes_t pos,
+				snd_pcm_uframes_t count)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	channel_buf =
+	    hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
+					  channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	memset(channel_buf + pos * 4, 0, count * 4);
+	return 0;
+}
+
+static int snd_hdspm_reset(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	snd_pcm_substream_t *other;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		other = hdspm->capture_substream;
+	else
+		other = hdspm->playback_substream;
+
+	if (hdspm->running)
+		runtime->status->hw_ptr = hdspm_hw_pointer(hdspm);
+	else
+		runtime->status->hw_ptr = 0;
+	if (other) {
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_runtime_t *oruntime = other->runtime;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == other) {
+				oruntime->status->hw_ptr =
+				    runtime->status->hw_ptr;
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+static int snd_hdspm_hw_params(snd_pcm_substream_t * substream,
+			       snd_pcm_hw_params_t * params)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	int err;
+	int i;
+	pid_t this_pid;
+	pid_t other_pid;
+	struct snd_sg_buf *sgbuf;
+
+
+	spin_lock_irq(&hdspm->lock);
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		this_pid = hdspm->playback_pid;
+		other_pid = hdspm->capture_pid;
+	} else {
+		this_pid = hdspm->capture_pid;
+		other_pid = hdspm->playback_pid;
+	}
+
+	if ((other_pid > 0) && (this_pid != other_pid)) {
+
+		/* The other stream is open, and not by the same
+		   task as this one. Make sure that the parameters
+		   that matter are the same.
+		 */
+
+		if (params_rate(params) != hdspm->system_sample_rate) {
+			spin_unlock_irq(&hdspm->lock);
+			_snd_pcm_hw_param_setempty(params,
+						   SNDRV_PCM_HW_PARAM_RATE);
+			return -EBUSY;
+		}
+
+		if (params_period_size(params) != hdspm->period_bytes / 4) {
+			spin_unlock_irq(&hdspm->lock);
+			_snd_pcm_hw_param_setempty(params,
+						   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+			return -EBUSY;
+		}
+
+	}
+	/* We're fine. */
+	spin_unlock_irq(&hdspm->lock);
+
+	/* how to make sure that the rate matches an externally-set one ?   */
+
+	spin_lock_irq(&hdspm->lock);
+	if ((err = hdspm_set_rate(hdspm, params_rate(params), 0)) < 0) {
+		spin_unlock_irq(&hdspm->lock);
+		_snd_pcm_hw_param_setempty(params,
+					   SNDRV_PCM_HW_PARAM_RATE);
+		return err;
+	}
+	spin_unlock_irq(&hdspm->lock);
+
+	if ((err =
+	     hdspm_set_interrupt_interval(hdspm,
+					  params_period_size(params))) <
+	    0) {
+		_snd_pcm_hw_param_setempty(params,
+					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+		return err;
+	}
+
+	/* Memory allocation, takashi's method, dont know if we should spinlock  */
+	/* malloc all buffer even if not enabled to get sure */
+	/* malloc only needed bytes */
+	err =
+	    snd_pcm_lib_malloc_pages(substream,
+				     HDSPM_CHANNEL_BUFFER_BYTES *
+				     params_channels(params));
+	if (err < 0)
+		return err;
+
+	sgbuf = snd_pcm_substream_sgbuf(substream);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferOut,
+				params_channels(params));
+
+		for (i = 0; i < params_channels(params); ++i)
+			snd_hdspm_enable_out(hdspm, i, 1);
+
+		hdspm->playback_buffer =
+		    (unsigned char *) substream->runtime->dma_area;
+	} else {
+		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferIn,
+				params_channels(params));
+
+		for (i = 0; i < params_channels(params); ++i)
+			snd_hdspm_enable_in(hdspm, i, 1);
+
+		hdspm->capture_buffer =
+		    (unsigned char *) substream->runtime->dma_area;
+	}
+	return 0;
+}
+
+static int snd_hdspm_hw_free(snd_pcm_substream_t * substream)
+{
+	int i;
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+		/* params_channels(params) should be enough, 
+		   but to get sure in case of error */
+		for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
+			snd_hdspm_enable_out(hdspm, i, 0);
+
+		hdspm->playback_buffer = NULL;
+	} else {
+		for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
+			snd_hdspm_enable_in(hdspm, i, 0);
+
+		hdspm->capture_buffer = NULL;
+
+	}
+
+	snd_pcm_lib_free_pages(substream);
+
+	return 0;
+}
+
+static int snd_hdspm_channel_info(snd_pcm_substream_t * substream,
+				  snd_pcm_channel_info_t * info)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	int mapped_channel;
+
+	snd_assert(info->channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+
+	if ((mapped_channel = hdspm->channel_map[info->channel]) < 0)
+		return -EINVAL;
+
+	info->offset = mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
+	info->first = 0;
+	info->step = 32;
+	return 0;
+}
+
+static int snd_hdspm_ioctl(snd_pcm_substream_t * substream,
+			   unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case SNDRV_PCM_IOCTL1_RESET:
+		{
+			return snd_hdspm_reset(substream);
+		}
+
+	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
+		{
+			snd_pcm_channel_info_t *info = arg;
+			return snd_hdspm_channel_info(substream, info);
+		}
+	default:
+		break;
+	}
+
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+static int snd_hdspm_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	snd_pcm_substream_t *other;
+	int running;
+
+	spin_lock(&hdspm->lock);
+	running = hdspm->running;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		running |= 1 << substream->stream;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		running &= ~(1 << substream->stream);
+		break;
+	default:
+		snd_BUG();
+		spin_unlock(&hdspm->lock);
+		return -EINVAL;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		other = hdspm->capture_substream;
+	else
+		other = hdspm->playback_substream;
+
+	if (other) {
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == other) {
+				snd_pcm_trigger_done(s, substream);
+				if (cmd == SNDRV_PCM_TRIGGER_START)
+					running |= 1 << s->stream;
+				else
+					running &= ~(1 << s->stream);
+				goto _ok;
+			}
+		}
+		if (cmd == SNDRV_PCM_TRIGGER_START) {
+			if (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK))
+			    && substream->stream ==
+			    SNDRV_PCM_STREAM_CAPTURE)
+				hdspm_silence_playback(hdspm);
+		} else {
+			if (running &&
+			    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				hdspm_silence_playback(hdspm);
+		}
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			hdspm_silence_playback(hdspm);
+	}
+      _ok:
+	snd_pcm_trigger_done(substream, substream);
+	if (!hdspm->running && running)
+		hdspm_start_audio(hdspm);
+	else if (hdspm->running && !running)
+		hdspm_stop_audio(hdspm);
+	hdspm->running = running;
+	spin_unlock(&hdspm->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_prepare(snd_pcm_substream_t * substream)
+{
+	return 0;
+}
+
+static unsigned int period_sizes[] =
+    { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static snd_pcm_hardware_t snd_hdspm_playback_subinfo = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_NONINTERLEAVED |
+		 SNDRV_PCM_INFO_SYNC_START | SNDRV_PCM_INFO_DOUBLE),
+	.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	.rates = (SNDRV_PCM_RATE_32000 |
+		  SNDRV_PCM_RATE_44100 |
+		  SNDRV_PCM_RATE_48000 |
+		  SNDRV_PCM_RATE_64000 |
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000),
+	.rate_min = 32000,
+	.rate_max = 96000,
+	.channels_min = 1,
+	.channels_max = HDSPM_MAX_CHANNELS,
+	.buffer_bytes_max =
+	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
+	.period_bytes_min = (64 * 4),
+	.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,
+	.periods_min = 2,
+	.periods_max = 2,
+	.fifo_size = 0
+};
+
+static snd_pcm_hardware_t snd_hdspm_capture_subinfo = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_NONINTERLEAVED |
+		 SNDRV_PCM_INFO_SYNC_START),
+	.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	.rates = (SNDRV_PCM_RATE_32000 |
+		  SNDRV_PCM_RATE_44100 |
+		  SNDRV_PCM_RATE_48000 |
+		  SNDRV_PCM_RATE_64000 |
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000),
+	.rate_min = 32000,
+	.rate_max = 96000,
+	.channels_min = 1,
+	.channels_max = HDSPM_MAX_CHANNELS,
+	.buffer_bytes_max =
+	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
+	.period_bytes_min = (64 * 4),
+	.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,
+	.periods_min = 2,
+	.periods_max = 2,
+	.fifo_size = 0
+};
+
+static snd_pcm_hw_constraint_list_t hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+
+static int snd_hdspm_hw_rule_channels_rate(snd_pcm_hw_params_t * params,
+					   snd_pcm_hw_rule_t * rule)
+{
+	hdspm_t *hdspm = rule->private;
+	snd_interval_t *c =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	snd_interval_t *r =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+
+	if (r->min > 48000) {
+		snd_interval_t t = {
+			.min = 1,
+			.max = hdspm->ds_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	} else if (r->max < 64000) {
+		snd_interval_t t = {
+			.min = 1,
+			.max = hdspm->ss_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	}
+	return 0;
+}
+
+static int snd_hdspm_hw_rule_rate_channels(snd_pcm_hw_params_t * params,
+					   snd_pcm_hw_rule_t * rule)
+{
+	hdspm_t *hdspm = rule->private;
+	snd_interval_t *c =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	snd_interval_t *r =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+
+	if (c->min <= hdspm->ss_channels) {
+		snd_interval_t t = {
+			.min = 32000,
+			.max = 48000,
+			.integer = 1,
+		};
+		return snd_interval_refine(r, &t);
+	} else if (c->max > hdspm->ss_channels) {
+		snd_interval_t t = {
+			.min = 64000,
+			.max = 96000,
+			.integer = 1,
+		};
+
+		return snd_interval_refine(r, &t);
+	}
+	return 0;
+}
+
+static int snd_hdspm_playback_open(snd_pcm_substream_t * substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_printdd("Open device substream %d\n", substream->stream);
+
+	spin_lock_irq(&hdspm->lock);
+
+	snd_pcm_set_sync(substream);
+
+	runtime->hw = snd_hdspm_playback_subinfo;
+
+	if (hdspm->capture_substream == NULL)
+		hdspm_stop_audio(hdspm);
+
+	hdspm->playback_pid = current->pid;
+	hdspm->playback_substream = substream;
+
+	spin_unlock_irq(&hdspm->lock);
+
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+
+	snd_pcm_hw_constraint_list(runtime, 0,
+				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				   &hw_constraints_period_sizes);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			    snd_hdspm_hw_rule_channels_rate, hdspm,
+			    SNDRV_PCM_HW_PARAM_RATE, -1);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			    snd_hdspm_hw_rule_rate_channels, hdspm,
+			    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+
+	return 0;
+}
+
+static int snd_hdspm_playback_release(snd_pcm_substream_t * substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&hdspm->lock);
+
+	hdspm->playback_pid = -1;
+	hdspm->playback_substream = NULL;
+
+	spin_unlock_irq(&hdspm->lock);
+
+	return 0;
+}
+
+
+static int snd_hdspm_capture_open(snd_pcm_substream_t * substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	spin_lock_irq(&hdspm->lock);
+	snd_pcm_set_sync(substream);
+	runtime->hw = snd_hdspm_capture_subinfo;
+
+	if (hdspm->playback_substream == NULL)
+		hdspm_stop_audio(hdspm);
+
+	hdspm->capture_pid = current->pid;
+	hdspm->capture_substream = substream;
+
+	spin_unlock_irq(&hdspm->lock);
+
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	snd_pcm_hw_constraint_list(runtime, 0,
+				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				   &hw_constraints_period_sizes);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			    snd_hdspm_hw_rule_channels_rate, hdspm,
+			    SNDRV_PCM_HW_PARAM_RATE, -1);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			    snd_hdspm_hw_rule_rate_channels, hdspm,
+			    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	return 0;
+}
+
+static int snd_hdspm_capture_release(snd_pcm_substream_t * substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&hdspm->lock);
+
+	hdspm->capture_pid = -1;
+	hdspm->capture_substream = NULL;
+
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_hwdep_dummy_op(snd_hwdep_t * hw, struct file *file)
+{
+	/* we have nothing to initialize but the call is required */
+	return 0;
+}
+
+
+static int snd_hdspm_hwdep_ioctl(snd_hwdep_t * hw, struct file *file,
+				 unsigned int cmd, unsigned long arg)
+{
+	hdspm_t *hdspm = (hdspm_t *) hw->private_data;
+	struct sndrv_hdspm_mixer_ioctl mixer;
+	hdspm_config_info_t info;
+	hdspm_version_t hdspm_version;
+	struct sndrv_hdspm_peak_rms_ioctl rms;
+
+	switch (cmd) {
+
+		
+	case SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:
+		if (copy_from_user(&rms, (void __user *)arg, sizeof(rms)))
+			return -EFAULT;
+		/* maybe there is a chance to memorymap in future so dont touch just copy */
+		if(copy_to_user_fromio((void __user *)rms.peak,
+				       hdspm->iobase+HDSPM_MADI_peakrmsbase,
+				       sizeof(hdspm_peak_rms_t)) != 0 )
+			return -EFAULT;
+
+		break;
+		
+
+	case SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:
+
+		spin_lock_irq(&hdspm->lock);
+		info.pref_sync_ref =
+		    (unsigned char) hdspm_pref_sync_ref(hdspm);
+		info.wordclock_sync_check =
+		    (unsigned char) hdspm_wc_sync_check(hdspm);
+
+		info.system_sample_rate = hdspm->system_sample_rate;
+		info.autosync_sample_rate =
+		    hdspm_external_sample_rate(hdspm);
+		info.system_clock_mode =
+		    (unsigned char) hdspm_system_clock_mode(hdspm);
+		info.clock_source =
+		    (unsigned char) hdspm_clock_source(hdspm);
+		info.autosync_ref =
+		    (unsigned char) hdspm_autosync_ref(hdspm);
+		info.line_out = (unsigned char) hdspm_line_out(hdspm);
+		info.passthru = 0;
+		spin_unlock_irq(&hdspm->lock);
+		if (copy_to_user((void __user *) arg, &info, sizeof(info)))
+			return -EFAULT;
+		break;
+
+	case SNDRV_HDSPM_IOCTL_GET_VERSION:
+		hdspm_version.firmware_rev = hdspm->firmware_rev;
+		if (copy_to_user((void __user *) arg, &hdspm_version,
+				 sizeof(hdspm_version)))
+			return -EFAULT;
+		break;
+
+	case SNDRV_HDSPM_IOCTL_GET_MIXER:
+		if (copy_from_user(&mixer, (void __user *)arg, sizeof(mixer)))
+			return -EFAULT;
+		if (copy_to_user
+		    ((void __user *)mixer.mixer, hdspm->mixer, sizeof(hdspm_mixer_t)))
+			return -EFAULT;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static snd_pcm_ops_t snd_hdspm_playback_ops = {
+	.open = snd_hdspm_playback_open,
+	.close = snd_hdspm_playback_release,
+	.ioctl = snd_hdspm_ioctl,
+	.hw_params = snd_hdspm_hw_params,
+	.hw_free = snd_hdspm_hw_free,
+	.prepare = snd_hdspm_prepare,
+	.trigger = snd_hdspm_trigger,
+	.pointer = snd_hdspm_hw_pointer,
+	.copy = snd_hdspm_playback_copy,
+	.silence = snd_hdspm_hw_silence,
+	.page = snd_pcm_sgbuf_ops_page,
+};
+
+static snd_pcm_ops_t snd_hdspm_capture_ops = {
+	.open = snd_hdspm_capture_open,
+	.close = snd_hdspm_capture_release,
+	.ioctl = snd_hdspm_ioctl,
+	.hw_params = snd_hdspm_hw_params,
+	.hw_free = snd_hdspm_hw_free,
+	.prepare = snd_hdspm_prepare,
+	.trigger = snd_hdspm_trigger,
+	.pointer = snd_hdspm_hw_pointer,
+	.copy = snd_hdspm_capture_copy,
+	.page = snd_pcm_sgbuf_ops_page,
+};
+
+static int __devinit snd_hdspm_create_hwdep(snd_card_t * card,
+					    hdspm_t * hdspm)
+{
+	snd_hwdep_t *hw;
+	int err;
+
+	if ((err = snd_hwdep_new(card, "HDSPM hwdep", 0, &hw)) < 0)
+		return err;
+
+	hdspm->hwdep = hw;
+	hw->private_data = hdspm;
+	strcpy(hw->name, "HDSPM hwdep interface");
+
+	hw->ops.open = snd_hdspm_hwdep_dummy_op;
+	hw->ops.ioctl = snd_hdspm_hwdep_ioctl;
+	hw->ops.release = snd_hdspm_hwdep_dummy_op;
+
+	return 0;
+}
+
+
+/*------------------------------------------------------------
+   memory interface 
+ ------------------------------------------------------------*/
+static int __devinit snd_hdspm_preallocate_memory(hdspm_t * hdspm)
+{
+	int err;
+	snd_pcm_t *pcm;
+	size_t wanted;
+
+	pcm = hdspm->pcm;
+
+	wanted = HDSPM_DMA_AREA_BYTES + 4096;	/* dont know why, but it works */
+
+	if ((err =
+	     snd_pcm_lib_preallocate_pages_for_all(pcm,
+	     					   SNDRV_DMA_TYPE_DEV_SG,
+						   snd_dma_pci_data(hdspm->pci),
+						   wanted,
+						   wanted)) < 0) {
+		snd_printdd("Could not preallocate %d  Bytes\n", wanted);
+
+		return err;
+	} else
+		snd_printdd(" Preallocated %d  Bytes\n", wanted);
+
+	return 0;
+}
+
+static int snd_hdspm_memory_free(hdspm_t * hdspm)
+{
+	snd_printdd("memory_free_for_all %p\n", hdspm->pcm);
+
+	snd_pcm_lib_preallocate_free_for_all(hdspm->pcm);
+	return 0;
+}
+
+
+static void hdspm_set_sgbuf(hdspm_t * hdspm, struct snd_sg_buf *sgbuf,
+			     unsigned int reg, int channels)
+{
+	int i;
+	for (i = 0; i < (channels * 16); i++)
+		hdspm_write(hdspm, reg + 4 * i,
+			    snd_pcm_sgbuf_get_addr(sgbuf,
+						   (size_t) 4096 * i));
+}
+
+/* ------------- ALSA Devices ---------------------------- */
+static int __devinit snd_hdspm_create_pcm(snd_card_t * card,
+					  hdspm_t * hdspm)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(card, hdspm->card_name, 0, 1, 1, &pcm)) < 0)
+		return err;
+
+	hdspm->pcm = pcm;
+	pcm->private_data = hdspm;
+	strcpy(pcm->name, hdspm->card_name);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_hdspm_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&snd_hdspm_capture_ops);
+
+	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+
+	if ((err = snd_hdspm_preallocate_memory(hdspm)) < 0)
+		return err;
+
+	return 0;
+}
+
+static inline void snd_hdspm_initialize_midi_flush(hdspm_t * hdspm)
+{
+	snd_hdspm_flush_midi_input(hdspm, 0);
+	snd_hdspm_flush_midi_input(hdspm, 1);
+}
+
+static int __devinit snd_hdspm_create_alsa_devices(snd_card_t * card,
+						   hdspm_t * hdspm)
+{
+	int err;
+
+	snd_printdd("Create card...\n");
+	if ((err = snd_hdspm_create_pcm(card, hdspm)) < 0)
+		return err;
+
+	if ((err = snd_hdspm_create_midi(card, hdspm, 0)) < 0)
+		return err;
+
+	if ((err = snd_hdspm_create_midi(card, hdspm, 1)) < 0)
+		return err;
+
+	if ((err = snd_hdspm_create_controls(card, hdspm)) < 0)
+		return err;
+
+	if ((err = snd_hdspm_create_hwdep(card, hdspm)) < 0)
+		return err;
+
+	snd_printdd("proc init...\n");
+	snd_hdspm_proc_init(hdspm);
+
+	hdspm->system_sample_rate = -1;
+	hdspm->last_external_sample_rate = -1;
+	hdspm->last_internal_sample_rate = -1;
+	hdspm->playback_pid = -1;
+	hdspm->capture_pid = -1;
+	hdspm->capture_substream = NULL;
+	hdspm->playback_substream = NULL;
+
+	snd_printdd("Set defaults...\n");
+	if ((err = snd_hdspm_set_defaults(hdspm)) < 0)
+		return err;
+
+	snd_printdd("Update mixer controls...\n");
+	hdspm_update_simple_mixer_controls(hdspm);
+
+	snd_printdd("Initializeing complete ???\n");
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_printk(KERN_ERR "HDSPM: error registering card\n");
+		return err;
+	}
+
+	snd_printdd("... yes now\n");
+
+	return 0;
+}
+
+static int __devinit snd_hdspm_create(snd_card_t * card, hdspm_t * hdspm,
+				      int precise_ptr, int enable_monitor)
+{
+	struct pci_dev *pci = hdspm->pci;
+	int err;
+	int i;
+
+	unsigned long io_extent;
+
+	hdspm->irq = -1;
+	hdspm->irq_count = 0;
+
+	hdspm->midi[0].rmidi = NULL;
+	hdspm->midi[1].rmidi = NULL;
+	hdspm->midi[0].input = NULL;
+	hdspm->midi[1].input = NULL;
+	hdspm->midi[0].output = NULL;
+	hdspm->midi[1].output = NULL;
+	spin_lock_init(&hdspm->midi[0].lock);
+	spin_lock_init(&hdspm->midi[1].lock);
+	hdspm->iobase = NULL;
+	hdspm->control_register = 0;
+	hdspm->control2_register = 0;
+
+	hdspm->playback_buffer = NULL;
+	hdspm->capture_buffer = NULL;
+
+	for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
+		hdspm->playback_mixer_ctls[i] = NULL;
+	hdspm->mixer = NULL;
+
+	hdspm->card = card;
+
+	spin_lock_init(&hdspm->lock);
+
+	tasklet_init(&hdspm->midi_tasklet,
+		     hdspm_midi_tasklet, (unsigned long) hdspm);
+
+	pci_read_config_word(hdspm->pci,
+			     PCI_CLASS_REVISION, &hdspm->firmware_rev);
+
+	strcpy(card->driver, "HDSPM");
+	strcpy(card->mixername, "Xilinx FPGA");
+	hdspm->card_name = "RME HDSPM MADI";
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	pci_set_master(hdspm->pci);
+
+	if ((err = pci_request_regions(pci, "hdspm")) < 0)
+		return err;
+
+	hdspm->port = pci_resource_start(pci, 0);
+	io_extent = pci_resource_len(pci, 0);
+
+	snd_printdd("grabbed memory region 0x%lx-0x%lx\n",
+		   hdspm->port, hdspm->port + io_extent - 1);
+
+
+	if ((hdspm->iobase = ioremap_nocache(hdspm->port, io_extent)) == NULL) {
+		snd_printk(KERN_ERR "HDSPM: unable to remap region 0x%lx-0x%lx\n",
+			   hdspm->port, hdspm->port + io_extent - 1);
+		return -EBUSY;
+	}
+	snd_printdd("remapped region (0x%lx) 0x%lx-0x%lx\n",
+		   (unsigned long)hdspm->iobase, hdspm->port,
+		   hdspm->port + io_extent - 1);
+
+	if (request_irq(pci->irq, snd_hdspm_interrupt,
+			SA_INTERRUPT | SA_SHIRQ, "hdspm",
+			(void *) hdspm)) {
+		snd_printk(KERN_ERR "HDSPM: unable to use IRQ %d\n", pci->irq);
+		return -EBUSY;
+	}
+
+	snd_printdd("use IRQ %d\n", pci->irq);
+
+	hdspm->irq = pci->irq;
+	hdspm->precise_ptr = precise_ptr;
+
+	hdspm->monitor_outs = enable_monitor;
+
+	snd_printdd("kmalloc Mixer memory of %d Bytes\n",
+		   sizeof(hdspm_mixer_t));
+	if ((hdspm->mixer =
+	     (hdspm_mixer_t *) kmalloc(sizeof(hdspm_mixer_t), GFP_KERNEL))
+	    == NULL) {
+		snd_printk(KERN_ERR "HDSPM: unable to kmalloc Mixer memory of %d Bytes\n",
+			   (int)sizeof(hdspm_mixer_t));
+		return err;
+	}
+
+	hdspm->ss_channels = MADI_SS_CHANNELS;
+	hdspm->ds_channels = MADI_DS_CHANNELS;
+	hdspm->qs_channels = MADI_QS_CHANNELS;
+
+	snd_printdd("create alsa devices.\n");
+	if ((err = snd_hdspm_create_alsa_devices(card, hdspm)) < 0)
+		return err;
+
+	snd_hdspm_initialize_midi_flush(hdspm);
+
+	return 0;
+}
+
+static int snd_hdspm_free(hdspm_t * hdspm)
+{
+
+	if (hdspm->port) {
+
+		/* stop th audio, and cancel all interrupts */
+		hdspm->control_register &=
+		    ~(HDSPM_Start | HDSPM_AudioInterruptEnable
+		      | HDSPM_Midi0InterruptEnable |
+		      HDSPM_Midi1InterruptEnable);
+		hdspm_write(hdspm, HDSPM_controlRegister,
+			    hdspm->control_register);
+	}
+
+	if (hdspm->irq >= 0)
+		free_irq(hdspm->irq, (void *) hdspm);
+
+
+	if (hdspm->mixer)
+		kfree(hdspm->mixer);
+
+	if (hdspm->iobase)
+		iounmap(hdspm->iobase);
+
+	snd_hdspm_memory_free(hdspm);
+
+	if (hdspm->port)
+		pci_release_regions(hdspm->pci);
+
+	pci_disable_device(hdspm->pci);
+	return 0;
+}
+
+static void snd_hdspm_card_free(snd_card_t * card)
+{
+	hdspm_t *hdspm = (hdspm_t *) card->private_data;
+
+	if (hdspm)
+		snd_hdspm_free(hdspm);
+}
+
+static int __devinit snd_hdspm_probe(struct pci_dev *pci,
+				     const struct pci_device_id *pci_id)
+{
+	static int dev;
+	hdspm_t *hdspm;
+	snd_card_t *card;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	if (!(card = snd_card_new(index[dev], id[dev],
+				  THIS_MODULE, sizeof(hdspm_t))))
+		return -ENOMEM;
+
+	hdspm = (hdspm_t *) card->private_data;
+	card->private_free = snd_hdspm_card_free;
+	hdspm->dev = dev;
+	hdspm->pci = pci;
+
+	if ((err =
+	     snd_hdspm_create(card, hdspm, precise_ptr[dev],
+			      enable_monitor[dev])) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->shortname, "HDSPM MADI");
+	sprintf(card->longname, "%s at 0x%lx, irq %d", hdspm->card_name,
+		hdspm->port, hdspm->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_hdspm_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "RME Hammerfall DSP MADI",
+	.id_table = snd_hdspm_ids,
+	.probe = snd_hdspm_probe,
+	.remove = __devexit_p(snd_hdspm_remove),
+};
+
+
+static int __init alsa_card_hdspm_init(void)
+{
+	return pci_register_driver(&driver);
+}
+
+static void __exit alsa_card_hdspm_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_hdspm_init)
+module_exit(alsa_card_hdspm_exit)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/rme9652/rme9652.c linux/sound/pci/rme9652/rme9652.c
--- linux-2.6.11/sound/pci/rme9652/rme9652.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/rme9652/rme9652.c	2005-05-30 19:22:46.000000000 +0200
@@ -303,18 +303,22 @@ static int snd_hammerfall_get_buffer(str
 {
 	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 	dmab->dev.dev = snd_dma_pci_data(pci);
-	if (! snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {
-		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-					size, dmab) < 0)
-			return -ENOMEM;
+	if (snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {
+		if (dmab->bytes >= size)
+			return 0;
 	}
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+				size, dmab) < 0)
+		return -ENOMEM;
 	return 0;
 }
 
 static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_dev *pci)
 {
-	if (dmab->area)
+	if (dmab->area) {
+		dmab->dev.dev = NULL; /* make it anonymous */
 		snd_dma_reserve_buf(dmab, snd_dma_pci_buf_id(pci));
+	}
 }
 
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/trident/trident.c linux/sound/pci/trident/trident.c
--- linux-2.6.11/sound/pci/trident/trident.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/trident/trident.c	2005-06-03 16:19:49.000000000 +0200
@@ -143,7 +143,8 @@ static int __devinit snd_trident_probe(s
 			return err;
 		}
 	}
-	if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_TRID4DWAVE,
+	if (trident->device != TRIDENT_DEVICE_ID_SI7018 &&
+	    (err = snd_mpu401_uart_new(card, 0, MPU401_HW_TRID4DWAVE,
 				       trident->midi_port, 1,
 				       trident->irq, 0, &trident->rmidi)) < 0) {
 		snd_card_free(card);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/via82xx.c linux/sound/pci/via82xx.c
--- linux-2.6.11/sound/pci/via82xx.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/via82xx.c	2005-05-30 18:28:31.000000000 +0200
@@ -491,10 +491,8 @@ static int clean_via_table(viadev_t *dev
 		snd_dma_free_pages(&dev->table);
 		dev->table.area = NULL;
 	}
-	if (dev->idx_table) {
-		kfree(dev->idx_table);
-		dev->idx_table = NULL;
-	}
+	kfree(dev->idx_table);
+	dev->idx_table = NULL;
 	return 0;
 }
 
@@ -1560,51 +1558,51 @@ static void snd_via82xx_mixer_free_ac97(
 
 static struct ac97_quirk ac97_quirks[] = {
 	{
-		.vendor = 0x1106,
-		.device = 0x4161,
+		.subvendor = 0x1106,
+		.subdevice = 0x4161,
 		.codec_id = 0x56494161, /* VT1612A */
 		.name = "Soltek SL-75DRV5",
 		.type = AC97_TUNE_NONE
 	},
 	{	/* FIXME: which codec? */
-		.vendor = 0x1106,
-		.device = 0x4161,
+		.subvendor = 0x1106,
+		.subdevice = 0x4161,
 		.name = "ASRock K7VT2",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1019,
-		.device = 0x0a81,
+		.subvendor = 0x1019,
+		.subdevice = 0x0a81,
 		.name = "ECS K7VTA3",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1019,
-		.device = 0x0a85,
+		.subvendor = 0x1019,
+		.subdevice = 0x0a85,
 		.name = "ECS L7VMM2",
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
-		.vendor = 0x1849,
-		.device = 0x3059,
+		.subvendor = 0x1849,
+		.subdevice = 0x3059,
 		.name = "ASRock K7VM2",
 		.type = AC97_TUNE_HP_ONLY	/* VT1616 */
 	},
 	{
-		.vendor = 0x14cd,
-		.device = 0x7002,
+		.subvendor = 0x14cd,
+		.subdevice = 0x7002,
 		.name = "Unknown",
 		.type = AC97_TUNE_ALC_JACK
 	},
 	{
-		.vendor = 0x1071,
-		.device = 0x8590,
+		.subvendor = 0x1071,
+		.subdevice = 0x8590,
 		.name = "Mitac Mobo",
 		.type = AC97_TUNE_ALC_JACK
 	},
 	{
-		.vendor = 0x161f,
-		.device = 0x202b,
+		.subvendor = 0x161f,
+		.subdevice = 0x202b,
 		.name = "Arima Notebook",
 		.type = AC97_TUNE_HP_ONLY,
 	},
@@ -1846,7 +1844,7 @@ static void __devinit snd_via82xx_proc_i
  *
  */
 
-static int __devinit snd_via82xx_chip_init(via82xx_t *chip)
+static int snd_via82xx_chip_init(via82xx_t *chip)
 {
 	unsigned int val;
 	int max_count;
@@ -2142,8 +2140,8 @@ static struct via823x_info via823x_cards
  * auto detection of DXS channel supports.
  */
 struct dxs_whitelist {
-	unsigned short vendor;
-	unsigned short device; 
+	unsigned short subvendor;
+	unsigned short subdevice; 
 	unsigned short mask; 
 	short action;	/* new dxs_support value */
 };
@@ -2151,41 +2149,43 @@ struct dxs_whitelist {
 static int __devinit check_dxs_list(struct pci_dev *pci)
 {
 	static struct dxs_whitelist whitelist[] = {
-		{ .vendor = 0x1005, .device = 0x4710, .action = VIA_DXS_ENABLE }, /* Avance Logic Mobo */
-		{ .vendor = 0x1019, .device = 0x0996, .action = VIA_DXS_48K },
-		{ .vendor = 0x1019, .device = 0x0a81, .action = VIA_DXS_NO_VRA }, /* ECS K7VTA3 v8.0 */
-		{ .vendor = 0x1019, .device = 0x0a85, .action = VIA_DXS_NO_VRA }, /* ECS L7VMM2 */
-		{ .vendor = 0x1025, .device = 0x0033, .action = VIA_DXS_NO_VRA }, /* Acer Inspire 1353LM */
-		{ .vendor = 0x1043, .device = 0x8095, .action = VIA_DXS_NO_VRA }, /* ASUS A7V8X (FIXME: possibly VIA_DXS_ENABLE?)*/
-		{ .vendor = 0x1043, .device = 0x80a1, .action = VIA_DXS_NO_VRA }, /* ASUS A7V8-X */
-		{ .vendor = 0x1043, .device = 0x80b0, .action = VIA_DXS_NO_VRA }, /* ASUS A7V600 & K8V*/ 
-		{ .vendor = 0x1043, .device = 0x812a, .action = VIA_DXS_SRC    }, /* ASUS A8V Deluxe */ 
-		{ .vendor = 0x1071, .device = 0x8375, .action = VIA_DXS_NO_VRA }, /* Vobis/Yakumo/Mitac notebook */
-		{ .vendor = 0x10cf, .device = 0x118e, .action = VIA_DXS_ENABLE }, /* FSC laptop */
-		{ .vendor = 0x1106, .device = 0x4161, .action = VIA_DXS_NO_VRA }, /* ASRock K7VT2 */
-		{ .vendor = 0x1106, .device = 0x4552, .action = VIA_DXS_NO_VRA }, /* QDI Kudoz 7X/600-6AL */
-		{ .vendor = 0x1106, .device = 0xaa01, .action = VIA_DXS_NO_VRA }, /* EPIA MII */
-		{ .vendor = 0x1106, .device = 0xc001, .action = VIA_DXS_SRC }, /* Insight P4-ITX */
-		{ .vendor = 0x1297, .device = 0xa232, .action = VIA_DXS_ENABLE }, /* Shuttle ?? */
-		{ .vendor = 0x1297, .device = 0xc160, .action = VIA_DXS_ENABLE }, /* Shuttle SK41G */
-		{ .vendor = 0x1458, .device = 0xa002, .action = VIA_DXS_ENABLE }, /* Gigabyte GA-7VAXP */
-		{ .vendor = 0x1462, .device = 0x0080, .action = VIA_DXS_SRC }, /* MSI K8T Neo-FIS2R */
-		{ .vendor = 0x1462, .device = 0x3800, .action = VIA_DXS_ENABLE }, /* MSI KT266 */
-		{ .vendor = 0x1462, .device = 0x5901, .action = VIA_DXS_NO_VRA }, /* MSI KT6 Delta-SR */
-		{ .vendor = 0x1462, .device = 0x7023, .action = VIA_DXS_NO_VRA }, /* MSI K8T Neo2-FI */
-		{ .vendor = 0x1462, .device = 0x7120, .action = VIA_DXS_ENABLE }, /* MSI KT4V */
-		{ .vendor = 0x147b, .device = 0x1401, .action = VIA_DXS_ENABLE }, /* ABIT KD7(-RAID) */
-		{ .vendor = 0x147b, .device = 0x1411, .action = VIA_DXS_ENABLE }, /* ABIT VA-20 */
-		{ .vendor = 0x147b, .device = 0x1413, .action = VIA_DXS_ENABLE }, /* ABIT KV8 Pro */
-		{ .vendor = 0x147b, .device = 0x1415, .action = VIA_DXS_NO_VRA }, /* Abit AV8 */
-		{ .vendor = 0x14ff, .device = 0x0403, .action = VIA_DXS_ENABLE }, /* Twinhead mobo */
-		{ .vendor = 0x1584, .device = 0x8120, .action = VIA_DXS_ENABLE }, /* Gericom/Targa/Vobis/Uniwill laptop */
-		{ .vendor = 0x1584, .device = 0x8123, .action = VIA_DXS_NO_VRA }, /* Uniwill (Targa Visionary XP-210) */
-		{ .vendor = 0x161f, .device = 0x202b, .action = VIA_DXS_NO_VRA }, /* Amira Note book */
-		{ .vendor = 0x161f, .device = 0x2032, .action = VIA_DXS_48K }, /* m680x machines */
-		{ .vendor = 0x1631, .device = 0xe004, .action = VIA_DXS_ENABLE }, /* Easy Note 3174, Packard Bell */
-		{ .vendor = 0x1695, .device = 0x3005, .action = VIA_DXS_ENABLE }, /* EPoX EP-8K9A */
-		{ .vendor = 0x1849, .device = 0x3059, .action = VIA_DXS_NO_VRA }, /* ASRock K7VM2 */
+		{ .subvendor = 0x1005, .subdevice = 0x4710, .action = VIA_DXS_ENABLE }, /* Avance Logic Mobo */
+		{ .subvendor = 0x1019, .subdevice = 0x0996, .action = VIA_DXS_48K },
+		{ .subvendor = 0x1019, .subdevice = 0x0a81, .action = VIA_DXS_NO_VRA }, /* ECS K7VTA3 v8.0 */
+		{ .subvendor = 0x1019, .subdevice = 0x0a85, .action = VIA_DXS_NO_VRA }, /* ECS L7VMM2 */
+		{ .subvendor = 0x1025, .subdevice = 0x0033, .action = VIA_DXS_NO_VRA }, /* Acer Inspire 1353LM */
+		{ .subvendor = 0x1043, .subdevice = 0x8095, .action = VIA_DXS_NO_VRA }, /* ASUS A7V8X (FIXME: possibly VIA_DXS_ENABLE?)*/
+		{ .subvendor = 0x1043, .subdevice = 0x80a1, .action = VIA_DXS_NO_VRA }, /* ASUS A7V8-X */
+		{ .subvendor = 0x1043, .subdevice = 0x80b0, .action = VIA_DXS_NO_VRA }, /* ASUS A7V600 & K8V*/ 
+		{ .subvendor = 0x1043, .subdevice = 0x812a, .action = VIA_DXS_SRC    }, /* ASUS A8V Deluxe */ 
+		{ .subvendor = 0x1071, .subdevice = 0x8375, .action = VIA_DXS_NO_VRA }, /* Vobis/Yakumo/Mitac notebook */
+		{ .subvendor = 0x1071, .subdevice = 0x8399, .action = VIA_DXS_ENABLE }, /* Umax AB 595T (VIA K8N800A - VT8237) */
+		{ .subvendor = 0x10cf, .subdevice = 0x118e, .action = VIA_DXS_ENABLE }, /* FSC laptop */
+		{ .subvendor = 0x1106, .subdevice = 0x4161, .action = VIA_DXS_NO_VRA }, /* ASRock K7VT2 */
+		{ .subvendor = 0x1106, .subdevice = 0x4552, .action = VIA_DXS_NO_VRA }, /* QDI Kudoz 7X/600-6AL */
+		{ .subvendor = 0x1106, .subdevice = 0xaa01, .action = VIA_DXS_NO_VRA }, /* EPIA MII */
+		{ .subvendor = 0x1106, .subdevice = 0xc001, .action = VIA_DXS_SRC }, /* Insight P4-ITX */
+		{ .subvendor = 0x1297, .subdevice = 0xa232, .action = VIA_DXS_ENABLE }, /* Shuttle ?? */
+		{ .subvendor = 0x1297, .subdevice = 0xc160, .action = VIA_DXS_ENABLE }, /* Shuttle SK41G */
+		{ .subvendor = 0x1458, .subdevice = 0xa002, .action = VIA_DXS_ENABLE }, /* Gigabyte GA-7VAXP */
+		{ .subvendor = 0x1462, .subdevice = 0x0080, .action = VIA_DXS_SRC }, /* MSI K8T Neo-FIS2R */
+		{ .subvendor = 0x1462, .subdevice = 0x3800, .action = VIA_DXS_ENABLE }, /* MSI KT266 */
+		{ .subvendor = 0x1462, .subdevice = 0x5901, .action = VIA_DXS_NO_VRA }, /* MSI KT6 Delta-SR */
+		{ .subvendor = 0x1462, .subdevice = 0x7023, .action = VIA_DXS_NO_VRA }, /* MSI K8T Neo2-FI */
+		{ .subvendor = 0x1462, .subdevice = 0x7120, .action = VIA_DXS_ENABLE }, /* MSI KT4V */
+		{ .subvendor = 0x147b, .subdevice = 0x1401, .action = VIA_DXS_ENABLE }, /* ABIT KD7(-RAID) */
+		{ .subvendor = 0x147b, .subdevice = 0x1411, .action = VIA_DXS_ENABLE }, /* ABIT VA-20 */
+		{ .subvendor = 0x147b, .subdevice = 0x1413, .action = VIA_DXS_ENABLE }, /* ABIT KV8 Pro */
+		{ .subvendor = 0x147b, .subdevice = 0x1415, .action = VIA_DXS_NO_VRA }, /* Abit AV8 */
+		{ .subvendor = 0x14ff, .subdevice = 0x0403, .action = VIA_DXS_ENABLE }, /* Twinhead mobo */
+		{ .subvendor = 0x14ff, .subdevice = 0x0408, .action = VIA_DXS_NO_VRA }, /* Twinhead mobo */
+		{ .subvendor = 0x1584, .subdevice = 0x8120, .action = VIA_DXS_ENABLE }, /* Gericom/Targa/Vobis/Uniwill laptop */
+		{ .subvendor = 0x1584, .subdevice = 0x8123, .action = VIA_DXS_NO_VRA }, /* Uniwill (Targa Visionary XP-210) */
+		{ .subvendor = 0x161f, .subdevice = 0x202b, .action = VIA_DXS_NO_VRA }, /* Amira Note book */
+		{ .subvendor = 0x161f, .subdevice = 0x2032, .action = VIA_DXS_48K }, /* m680x machines */
+		{ .subvendor = 0x1631, .subdevice = 0xe004, .action = VIA_DXS_ENABLE }, /* Easy Note 3174, Packard Bell */
+		{ .subvendor = 0x1695, .subdevice = 0x3005, .action = VIA_DXS_ENABLE }, /* EPoX EP-8K9A */
+		{ .subvendor = 0x1849, .subdevice = 0x3059, .action = VIA_DXS_NO_VRA }, /* ASRock K7VM2 */
 		{ } /* terminator */
 	};
 	struct dxs_whitelist *w;
@@ -2195,14 +2195,14 @@ static int __devinit check_dxs_list(stru
 	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
 	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &subsystem_device);
 
-	for (w = whitelist; w->vendor; w++) {
-		if (w->vendor != subsystem_vendor)
+	for (w = whitelist; w->subvendor; w++) {
+		if (w->subvendor != subsystem_vendor)
 			continue;
 		if (w->mask) {
-			if ((w->mask & subsystem_device) == w->device)
+			if ((w->mask & subsystem_device) == w->subdevice)
 				return w->action;
 		} else {
-			if (subsystem_device == w->device)
+			if (subsystem_device == w->subdevice)
 				return w->action;
 		}
 	}
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/via82xx_modem.c linux/sound/pci/via82xx_modem.c
--- linux-2.6.11/sound/pci/via82xx_modem.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/via82xx_modem.c	2005-05-30 18:28:31.000000000 +0200
@@ -352,10 +352,8 @@ static int clean_via_table(viadev_t *dev
 		snd_dma_free_pages(&dev->table);
 		dev->table.area = NULL;
 	}
-	if (dev->idx_table) {
-		kfree(dev->idx_table);
-		dev->idx_table = NULL;
-	}
+	kfree(dev->idx_table);
+	dev->idx_table = NULL;
 	return 0;
 }
 
@@ -420,7 +418,10 @@ static void snd_via82xx_codec_write(ac97
 {
 	via82xx_t *chip = ac97->private_data;
 	unsigned int xval;
-	
+	if(reg == AC97_GPIO_STATUS) {
+		outl(val, VIAREG(chip, GPI_STATUS));
+		return;
+	}	
 	xval = !ac97->num ? VIA_REG_AC97_CODEC_ID_PRIMARY : VIA_REG_AC97_CODEC_ID_SECONDARY;
 	xval <<= VIA_REG_AC97_CODEC_ID_SHIFT;
 	xval |= reg << VIA_REG_AC97_CMD_SHIFT;
@@ -544,25 +545,6 @@ static int snd_via82xx_pcm_trigger(snd_p
 	return 0;
 }
 
-static int snd_via82xx_modem_pcm_trigger(snd_pcm_substream_t * substream, int cmd)
-{
-	via82xx_t *chip = snd_pcm_substream_chip(substream);
-	unsigned int val = 0;
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		val = snd_ac97_read(chip->ac97, AC97_GPIO_STATUS);
-		outl(val|AC97_GPIO_LINE1_OH, VIAREG(chip, GPI_STATUS));
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		val = snd_ac97_read(chip->ac97, AC97_GPIO_STATUS);
-		outl(val&~AC97_GPIO_LINE1_OH, VIAREG(chip, GPI_STATUS));
-		break;
-	default:
-		break;
-	}
-	return snd_via82xx_pcm_trigger(substream, cmd);
-}
-
 /*
  * pointer callbacks
  */
@@ -806,7 +788,7 @@ static snd_pcm_ops_t snd_via686_playback
 	.hw_params =	snd_via82xx_hw_params,
 	.hw_free =	snd_via82xx_hw_free,
 	.prepare =	snd_via82xx_pcm_prepare,
-	.trigger =	snd_via82xx_modem_pcm_trigger,
+	.trigger =	snd_via82xx_pcm_trigger,
 	.pointer =	snd_via686_pcm_pointer,
 	.page =		snd_pcm_sgbuf_ops_page,
 };
@@ -819,7 +801,7 @@ static snd_pcm_ops_t snd_via686_capture_
 	.hw_params =	snd_via82xx_hw_params,
 	.hw_free =	snd_via82xx_hw_free,
 	.prepare =	snd_via82xx_pcm_prepare,
-	.trigger =	snd_via82xx_modem_pcm_trigger,
+	.trigger =	snd_via82xx_pcm_trigger,
 	.pointer =	snd_via686_pcm_pointer,
 	.page =		snd_pcm_sgbuf_ops_page,
 };
@@ -938,7 +920,7 @@ static void __devinit snd_via82xx_proc_i
  *
  */
 
-static int __devinit snd_via82xx_chip_init(via82xx_t *chip)
+static int snd_via82xx_chip_init(via82xx_t *chip)
 {
 	unsigned int val;
 	int max_count;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ymfpci/ymfpci_main.c linux/sound/pci/ymfpci/ymfpci_main.c
--- linux-2.6.11/sound/pci/ymfpci/ymfpci_main.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/pci/ymfpci/ymfpci_main.c	2005-05-30 18:28:31.000000000 +0200
@@ -829,9 +829,7 @@ static snd_pcm_hardware_t snd_ymfpci_cap
 
 static void snd_ymfpci_pcm_free_substream(snd_pcm_runtime_t *runtime)
 {
-	ymfpci_pcm_t *ypcm = runtime->private_data;
-	
-	kfree(ypcm);
+	kfree(runtime->private_data);
 }
 
 static int snd_ymfpci_playback_open_1(snd_pcm_substream_t * substream)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pcmcia/vx/vx_entry.c linux/sound/pcmcia/vx/vx_entry.c
--- linux-2.6.11/sound/pcmcia/vx/vx_entry.c	2005-06-03 15:53:55.000000000 +0200
+++ linux/sound/pcmcia/vx/vx_entry.c	2005-05-30 18:28:31.000000000 +0200
@@ -68,8 +68,7 @@ static int snd_vxpocket_free(vx_core_t *
 	if (hw)
 		hw->card_list[vxp->index] = NULL;
 	chip->card = NULL;
-	if (chip->dev)
-		kfree(chip->dev);
+	kfree(chip->dev);
 
 	snd_vx_free_firmware(chip);
 	kfree(chip);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/ppc/pmac.c linux/sound/ppc/pmac.c
--- linux-2.6.11/sound/ppc/pmac.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/ppc/pmac.c	2005-05-18 17:31:19.000000000 +0200
@@ -876,7 +876,7 @@ static void __init detect_byte_swap(pmac
  */
 static int __init snd_pmac_detect(pmac_t *chip)
 {
-	struct device_node *sound;
+	struct device_node *sound = NULL;
 	unsigned int *prop, l;
 	struct macio_chip* macio;
 
@@ -906,20 +906,22 @@ static int __init snd_pmac_detect(pmac_t
 		chip->is_pbook_G3 = 1;
 	chip->node = find_devices("awacs");
 	if (chip->node)
-		return 0; /* ok */
+		sound = chip->node;
 
 	/*
 	 * powermac G3 models have a node called "davbus"
 	 * with a child called "sound".
 	 */
-	chip->node = find_devices("davbus");
+	if (!chip->node)
+		chip->node = find_devices("davbus");
 	/*
 	 * if we didn't find a davbus device, try 'i2s-a' since
 	 * this seems to be what iBooks have
 	 */
 	if (! chip->node) {
 		chip->node = find_devices("i2s-a");
-		if (chip->node && chip->node->parent && chip->node->parent->parent) {
+		if (chip->node && chip->node->parent &&
+		    chip->node->parent->parent) {
 			if (device_is_compatible(chip->node->parent->parent,
 						 "K2-Keylargo"))
 				chip->is_k2 = 1;
@@ -928,9 +930,11 @@ static int __init snd_pmac_detect(pmac_t
 	if (! chip->node)
 		return -ENODEV;
 
-	sound = find_devices("sound");
-	while (sound && sound->parent != chip->node)
-		sound = sound->next;
+	if (!sound) {
+		sound = find_devices("sound");
+		while (sound && sound->parent != chip->node)
+			sound = sound->next;
+	}
 	if (! sound)
 		return -ENODEV;
 	prop = (unsigned int *) get_property(sound, "sub-frame", NULL);
@@ -1019,7 +1023,8 @@ static int __init snd_pmac_detect(pmac_t
 		}
 	}
 	if (chip->pdev == NULL)
-		printk(KERN_WARNING "snd-powermac: can't locate macio PCI device !\n");
+		printk(KERN_WARNING "snd-powermac: can't locate macio PCI"
+		       " device !\n");
 
 	detect_byte_swap(chip);
 
@@ -1027,7 +1032,8 @@ static int __init snd_pmac_detect(pmac_t
 	   are available */
 	prop = (unsigned int *) get_property(sound, "sample-rates", &l);
 	if (! prop)
-		prop = (unsigned int *) get_property(sound, "output-frame-rates", &l);
+		prop = (unsigned int *) get_property(sound,
+						     "output-frame-rates", &l);
 	if (prop) {
 		int i;
 		chip->freqs_ok = 0;
@@ -1054,7 +1060,8 @@ static int __init snd_pmac_detect(pmac_t
 /*
  * exported - boolean info callbacks for ease of programming
  */
-int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol,
+				 snd_ctl_elem_info_t *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 2;
@@ -1063,7 +1070,8 @@ int snd_pmac_boolean_stereo_info(snd_kco
 	return 0;
 }
 
-int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol,
+			       snd_ctl_elem_info_t *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/synth/emux/emux_effect.c linux/sound/synth/emux/emux_effect.c
--- linux-2.6.11/sound/synth/emux/emux_effect.c	2005-03-02 08:38:07.000000000 +0100
+++ linux/sound/synth/emux/emux_effect.c	2005-05-30 18:28:31.000000000 +0200
@@ -291,10 +291,8 @@ snd_emux_create_effect(snd_emux_port_t *
 void
 snd_emux_delete_effect(snd_emux_port_t *p)
 {
-	if (p->effect) {
-		kfree(p->effect);
-		p->effect = NULL;
-	}
+	kfree(p->effect);
+	p->effect = NULL;
 }
 
 void
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/usb/usbaudio.c linux/sound/usb/usbaudio.c
--- linux-2.6.11/sound/usb/usbaudio.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/usb/usbaudio.c	2005-05-30 18:28:32.000000000 +0200
@@ -859,10 +859,8 @@ static void release_urb_ctx(snd_urb_ctx_
 		usb_free_urb(u->urb);
 		u->urb = NULL;
 	}
-	if (u->buf) {
-		kfree(u->buf);
-		u->buf = NULL;
-	}
+	kfree(u->buf);
+	u->buf = NULL;
 }
 
 /*
@@ -880,10 +878,8 @@ static void release_substream_urbs(snd_u
 		release_urb_ctx(&subs->dataurb[i]);
 	for (i = 0; i < SYNC_URBS; i++)
 		release_urb_ctx(&subs->syncurb[i]);
-	if (subs->tmpbuf) {
-		kfree(subs->tmpbuf);
-		subs->tmpbuf = NULL;
-	}
+	kfree(subs->tmpbuf);
+	subs->tmpbuf = NULL;
 	subs->nurbs = 0;
 }
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/usb/usbmidi.c linux/sound/usb/usbmidi.c
--- linux-2.6.11/sound/usb/usbmidi.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/usb/usbmidi.c	2005-05-27 16:02:14.000000000 +0200
@@ -287,7 +287,7 @@ static int send_bulk_static_data(snd_usb
 	memcpy(buf, data, len);
 	dump_urb("sending", buf, len);
 	err = usb_bulk_msg(ep->umidi->chip->dev, ep->urb->pipe, buf, len,
-			   NULL, 1000);
+			   NULL, 250);
 	kfree(buf);
 	return err;
 }
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/usb/usbmixer.c linux/sound/usb/usbmixer.c
--- linux-2.6.11/sound/usb/usbmixer.c	2005-06-03 15:54:07.000000000 +0200
+++ linux/sound/usb/usbmixer.c	2005-05-30 18:28:32.000000000 +0200
@@ -623,10 +623,8 @@ static struct usb_feature_control_info a
 /* private_free callback */
 static void usb_mixer_elem_free(snd_kcontrol_t *kctl)
 {
-	if (kctl->private_data) {
-		kfree(kctl->private_data);
-		kctl->private_data = NULL;
-	}
+	kfree(kctl->private_data);
+	kctl->private_data = NULL;
 }
 
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/usb/usx2y/usbusx2yaudio.c linux/sound/usb/usx2y/usbusx2yaudio.c
--- linux-2.6.11/sound/usb/usx2y/usbusx2yaudio.c	2005-06-03 15:53:55.000000000 +0200
+++ linux/sound/usb/usx2y/usbusx2yaudio.c	2005-05-30 18:28:32.000000000 +0200
@@ -401,10 +401,8 @@ static void usX2Y_urbs_release(snd_usX2Y
 	for (i = 0; i < NRURBS; i++)
 		usX2Y_urb_release(subs->urb + i, subs != subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK]);
 
-	if (subs->tmpbuf) {
-		kfree(subs->tmpbuf);
-		subs->tmpbuf = NULL;
-	}
+	kfree(subs->tmpbuf);
+	subs->tmpbuf = NULL;
 }
 /*
  * initialize a substream's urbs
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/ac97_codec.h linux/include/sound/ac97_codec.h
--- linux-2.6.11/include/sound/ac97_codec.h	2005-06-03 15:54:07.000000000 +0200
+++ linux/include/sound/ac97_codec.h	2005-05-30 17:43:06.000000000 +0200
@@ -573,8 +573,8 @@
 };
 
 struct ac97_quirk {
-	unsigned short vendor;	/* PCI vendor id */
-	unsigned short device;	/* PCI device id */
+	unsigned short subvendor; /* PCI subsystem vendor id */
+	unsigned short subdevice; /* PCI sybsystem device id */
 	unsigned short mask;	/* device id bit mask, 0 = accept all */
 	unsigned int codec_id;	/* codec id (if any), 0 = accept all */
 	const char *name;	/* name shown as info */
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/gus.h linux/include/sound/gus.h
--- linux-2.6.11/include/sound/gus.h	2005-06-03 15:53:55.000000000 +0200
+++ linux/include/sound/gus.h	2005-05-23 11:27:13.000000000 +0200
@@ -526,9 +526,6 @@
 extern void snd_gf1_dram_addr(snd_gus_card_t * gus, unsigned int addr);
 extern void snd_gf1_poke(snd_gus_card_t * gus, unsigned int addr, unsigned char data);
 extern unsigned char snd_gf1_peek(snd_gus_card_t * gus, unsigned int addr);
-extern void snd_gf1_pokew(snd_gus_card_t * gus, unsigned int addr, unsigned short data);
-extern unsigned short snd_gf1_peekw(snd_gus_card_t * gus, unsigned int addr);
-extern void snd_gf1_dram_setmem(snd_gus_card_t * gus, unsigned int addr, unsigned short value, unsigned int count);
 extern void snd_gf1_write_addr(snd_gus_card_t * gus, unsigned char reg, unsigned int addr, short w_16bit);
 extern unsigned int snd_gf1_read_addr(snd_gus_card_t * gus, unsigned char reg, short w_16bit);
 extern void snd_gf1_i_ctrl_stop(snd_gus_card_t * gus, unsigned char reg);
@@ -544,9 +541,6 @@
 {
 	return snd_gf1_i_look16(gus, reg | 0x80);
 }
-extern void snd_gf1_i_adlib_write(snd_gus_card_t * gus, unsigned char reg, unsigned char data);
-extern void snd_gf1_i_write_addr(snd_gus_card_t * gus, unsigned char reg, unsigned int addr, short w_16bit);
-extern unsigned int snd_gf1_i_read_addr(snd_gus_card_t * gus, unsigned char reg, short w_16bit);
 
 extern void snd_gf1_select_active_voices(snd_gus_card_t * gus);
 
@@ -580,10 +574,6 @@
 
 void snd_gf1_mem_lock(snd_gf1_mem_t * alloc, int xup);
 int snd_gf1_mem_xfree(snd_gf1_mem_t * alloc, snd_gf1_mem_block_t * block);
-snd_gf1_mem_block_t *snd_gf1_mem_look(snd_gf1_mem_t * alloc,
-				      unsigned int address);
-snd_gf1_mem_block_t *snd_gf1_mem_share(snd_gf1_mem_t * alloc,
-				       unsigned int *share_id);
 snd_gf1_mem_block_t *snd_gf1_mem_alloc(snd_gf1_mem_t * alloc, int owner,
 				       char *name, int size, int w_16,
 				       int align, unsigned int *share_id);
@@ -608,23 +598,13 @@
 /* gus_volume.c */
 
 unsigned short snd_gf1_lvol_to_gvol_raw(unsigned int vol);
-unsigned int snd_gf1_gvol_to_lvol_raw(unsigned short gf1_vol);
-unsigned int snd_gf1_calc_ramp_rate(snd_gus_card_t * gus,
-				    unsigned short start,
-				    unsigned short end,
-				    unsigned int us);
 unsigned short snd_gf1_translate_freq(snd_gus_card_t * gus, unsigned int freq2);
-unsigned short snd_gf1_compute_pitchbend(unsigned short pitchbend, unsigned short sens);
-unsigned short snd_gf1_compute_freq(unsigned int freq,
-				    unsigned int rate,
-				    unsigned short mix_rate);
 
 /* gus_reset.c */
 
 void snd_gf1_set_default_handlers(snd_gus_card_t * gus, unsigned int what);
 void snd_gf1_smart_stop_voice(snd_gus_card_t * gus, unsigned short voice);
 void snd_gf1_stop_voice(snd_gus_card_t * gus, unsigned short voice);
-void snd_gf1_clear_voices(snd_gus_card_t * gus, unsigned short v_min, unsigned short v_max);
 void snd_gf1_stop_voices(snd_gus_card_t * gus, unsigned short v_min, unsigned short v_max);
 snd_gus_voice_t *snd_gf1_alloc_voice(snd_gus_card_t * gus, int type, int client, int port);
 void snd_gf1_free_voice(snd_gus_card_t * gus, snd_gus_voice_t *voice);
@@ -641,9 +621,6 @@
 
 #ifdef CONFIG_SND_DEBUG
 extern void snd_gf1_print_voice_registers(snd_gus_card_t * gus);
-extern void snd_gf1_print_global_registers(snd_gus_card_t * gus);
-extern void snd_gf1_print_setup_registers(snd_gus_card_t * gus);
-extern void snd_gf1_peek_print_block(snd_gus_card_t * gus, unsigned int addr, int count, int w_16bit);
 #endif
 
 /* gus.c */
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/hdspm.h linux/include/sound/hdspm.h
--- linux-2.6.11/include/sound/hdspm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux/include/sound/hdspm.h	2005-06-03 12:19:44.000000000 +0200
@@ -0,0 +1,131 @@
+#ifndef __SOUND_HDSPM_H		/* -*- linux-c -*- */
+#define __SOUND_HDSPM_H
+/*
+ *   Copyright (C) 2003 Winfried Ritsch (IEM)
+ *   based on hdsp.h from Thomas Charbonnel (thomas@undata.org)
+ *                      
+ *    
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* Maximum channels is 64 even on 56Mode you have 64playbacks to matrix */
+#define HDSPM_MAX_CHANNELS      64
+
+/* -------------------- IOCTL Peak/RMS Meters -------------------- */
+
+typedef struct _snd_hdspm_peak_rms hdspm_peak_rms_t;
+
+/* peam rms level structure like we get from hardware 
+  
+   maybe in future we can memory map it so I just copy it
+   to user on ioctl call now an dont change anything
+   rms are made out of low and high values
+   where (long) ????_rms = (????_rms_l >> 8) + ((????_rms_h & 0xFFFFFF00)<<24)
+   (i asume so from the code)
+*/
+
+struct _snd_hdspm_peak_rms {
+
+	unsigned int level_offset[1024];
+
+	unsigned int input_peak[64];
+	unsigned int playback_peak[64];
+	unsigned int output_peak[64];
+	unsigned int xxx_peak[64];	/* not used */
+
+	unsigned int reserved[256];	/* not used */
+
+	unsigned int input_rms_l[64];
+	unsigned int playback_rms_l[64];
+	unsigned int output_rms_l[64];
+	unsigned int xxx_rms_l[64];	/* not used */
+
+	unsigned int input_rms_h[64];
+	unsigned int playback_rms_h[64];
+	unsigned int output_rms_h[64];
+	unsigned int xxx_rms_h[64];	/* not used */
+};
+
+struct sndrv_hdspm_peak_rms_ioctl {
+	hdspm_peak_rms_t *peak;
+};
+
+/* use indirect access due to the limit of ioctl bit size */
+#define SNDRV_HDSPM_IOCTL_GET_PEAK_RMS _IOR('H', 0x40, struct sndrv_hdspm_peak_rms_ioctl)
+
+/* ------------ CONFIG block IOCTL ---------------------- */
+
+typedef struct _snd_hdspm_config_info hdspm_config_info_t;
+
+struct _snd_hdspm_config_info {
+	unsigned char pref_sync_ref;
+	unsigned char wordclock_sync_check;
+	unsigned char madi_sync_check;
+	unsigned int system_sample_rate;
+	unsigned int autosync_sample_rate;
+	unsigned char system_clock_mode;
+	unsigned char clock_source;
+	unsigned char autosync_ref;
+	unsigned char line_out;
+	unsigned int passthru;
+	unsigned int analog_out;
+};
+
+#define SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO _IOR('H', 0x41, hdspm_config_info_t)
+
+
+/* get Soundcard Version */
+
+typedef struct _snd_hdspm_version hdspm_version_t;
+
+struct _snd_hdspm_version {
+	unsigned short firmware_rev;
+};
+
+#define SNDRV_HDSPM_IOCTL_GET_VERSION _IOR('H', 0x43, hdspm_version_t)
+
+
+/* ------------- get Matrix Mixer IOCTL --------------- */
+
+/* MADI mixer: 64inputs+64playback in 64outputs = 8192 => *4Byte = 32768 Bytes */
+
+/* organisation is 64 channelfader in a continous memory block */
+/* equivalent to hardware definition, maybe for future feature of mmap of them */
+/* each of 64 outputs has 64 infader and 64 outfader: 
+   Ins to Outs mixer[out].in[in], Outstreams to Outs mixer[out].pb[pb] */
+
+#define HDSPM_MIXER_CHANNELS HDSPM_MAX_CHANNELS
+
+typedef struct _snd_hdspm_channelfader snd_hdspm_channelfader_t;
+
+struct _snd_hdspm_channelfader {
+	unsigned int in[HDSPM_MIXER_CHANNELS];
+	unsigned int pb[HDSPM_MIXER_CHANNELS];
+};
+
+typedef struct _snd_hdspm_mixer hdspm_mixer_t;
+
+struct _snd_hdspm_mixer {
+	snd_hdspm_channelfader_t ch[HDSPM_MIXER_CHANNELS];
+};
+
+struct sndrv_hdspm_mixer_ioctl {
+	hdspm_mixer_t *mixer;
+};
+
+/* use indirect access due to the limit of ioctl bit size */
+#define SNDRV_HDSPM_IOCTL_GET_MIXER _IOR('H', 0x44, struct sndrv_hdspm_mixer_ioctl)
+
+#endif				/* __SOUND_HDSPM_H */
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/pcm.h linux/include/sound/pcm.h
--- linux-2.6.11/include/sound/pcm.h	2005-06-03 15:54:07.000000000 +0200
+++ linux/include/sound/pcm.h	2005-05-18 18:54:12.000000000 +0200
@@ -848,23 +848,6 @@
 
 void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params);
 void _snd_pcm_hw_param_setempty(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var);
-int snd_pcm_hw_param_min(snd_pcm_substream_t *substream, 
-			 snd_pcm_hw_params_t *params,
-			 snd_pcm_hw_param_t var,
-			 unsigned int val, int *dir);
-int snd_pcm_hw_param_max(snd_pcm_substream_t *substream, 
-			 snd_pcm_hw_params_t *params,
-			 snd_pcm_hw_param_t var,
-			 unsigned int val, int *dir);
-int snd_pcm_hw_param_setinteger(snd_pcm_substream_t *substream, 
-				snd_pcm_hw_params_t *params,
-				snd_pcm_hw_param_t var);
-int snd_pcm_hw_param_first(snd_pcm_substream_t *substream, 
-			   snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var, int *dir);
-int snd_pcm_hw_param_last(snd_pcm_substream_t *substream, 
-			  snd_pcm_hw_params_t *params,
-			  snd_pcm_hw_param_t var, int *dir);
 int snd_pcm_hw_param_near(snd_pcm_substream_t *substream, 
 			  snd_pcm_hw_params_t *params,
 			  snd_pcm_hw_param_t var, 
@@ -876,7 +859,6 @@
 int snd_pcm_hw_params_choose(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
 
 int snd_pcm_hw_refine(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
-int snd_pcm_hw_params(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
 
 int snd_pcm_hw_constraints_init(snd_pcm_substream_t *substream);
 int snd_pcm_hw_constraints_complete(snd_pcm_substream_t *substream);
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/seq_midi_event.h linux/include/sound/seq_midi_event.h
--- linux-2.6.11/include/sound/seq_midi_event.h	2005-03-02 08:37:54.000000000 +0100
+++ linux/include/sound/seq_midi_event.h	2005-05-18 18:54:12.000000000 +0200
@@ -41,9 +41,7 @@
 };
 
 int snd_midi_event_new(int bufsize, snd_midi_event_t **rdev);
-int snd_midi_event_resize_buffer(snd_midi_event_t *dev, int bufsize);
 void snd_midi_event_free(snd_midi_event_t *dev);
-void snd_midi_event_init(snd_midi_event_t *dev);
 void snd_midi_event_reset_encode(snd_midi_event_t *dev);
 void snd_midi_event_reset_decode(snd_midi_event_t *dev);
 void snd_midi_event_no_status(snd_midi_event_t *dev, int on);
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/seq_virmidi.h linux/include/sound/seq_virmidi.h
--- linux-2.6.11/include/sound/seq_virmidi.h	2005-06-03 15:53:55.000000000 +0200
+++ linux/include/sound/seq_virmidi.h	2005-05-18 18:54:12.000000000 +0200
@@ -79,6 +79,5 @@
 #define SNDRV_VIRMIDI_SEQ_DISPATCH	2
 
 int snd_virmidi_new(snd_card_t *card, int device, snd_rawmidi_t **rrmidi);
-int snd_virmidi_receive(snd_rawmidi_t *rmidi, snd_seq_event_t *ev);
 
 #endif /* __SOUND_SEQ_VIRMIDI */
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/timer.h linux/include/sound/timer.h
--- linux-2.6.11/include/sound/timer.h	2005-03-02 08:38:10.000000000 +0100
+++ linux/include/sound/timer.h	2005-05-18 18:54:12.000000000 +0200
@@ -152,6 +152,4 @@
 
 extern void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left);
 
-extern unsigned int snd_timer_system_resolution(void);
-
 #endif /* __SOUND_TIMER_H */
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/version.h linux/include/sound/version.h
--- linux-2.6.11/include/sound/version.h	2005-06-03 15:54:07.000000000 +0200
+++ linux/include/sound/version.h	2005-06-02 14:21:21.000000000 +0200
@@ -1,3 +1,3 @@
 /* include/version.h.  Generated by configure.  */
-#define CONFIG_SND_VERSION "1.0.9rc3"
+#define CONFIG_SND_VERSION "1.0.9a"
 #define CONFIG_SND_DATE ""
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/Documentation/sound/alsa/ALSA-Configuration.txt linux/Documentation/sound/alsa/ALSA-Configuration.txt
--- linux-2.6.11/Documentation/sound/alsa/ALSA-Configuration.txt	2005-06-03 15:54:07.000000000 +0200
+++ linux/Documentation/sound/alsa/ALSA-Configuration.txt	2005-06-03 12:21:07.000000000 +0200
@@ -671,7 +671,19 @@
           module did formerly.  It will allocate the buffers in advance
           when any HDSP cards are found.  To make the buffer
           allocation sure, load snd-page-alloc module in the early
-          stage of boot sequence.
+          stage of boot sequence.  See "Early Buffer Allocation"
+	  section.
+
+  Module snd-hdspm
+  ----------------
+
+    Module for RME HDSP MADI board.
+
+    precise_ptr		- Enable precise pointer, or disable.
+    line_outs_monitor	- Send playback streams to analog outs by default.
+    enable_monitor	- Enable Analog Out on Channel 63/64 by default.
+
+    See hdspm.txt for details.
 
   Module snd-ice1712
   ------------------
@@ -688,15 +700,19 @@
                         * TerraTec EWS 88D
                         * TerraTec EWX 24/96
                         * TerraTec DMX 6Fire
+			* TerraTec Phase 88
                         * Hoontech SoundTrack DSP 24
                         * Hoontech SoundTrack DSP 24 Value
                         * Hoontech SoundTrack DSP 24 Media 7.1
+			* Event Electronics, EZ8
                         * Digigram VX442
+			* Lionstracs, Mediastaton
 
     model       - Use the given board model, one of the following:
 		  delta1010, dio2496, delta66, delta44, audiophile, delta410,
 		  delta1010lt, vx442, ewx2496, ews88mt, ews88mt_new, ews88d,
-		  dmx6fire, dsp24, dsp24_value, dsp24_71, ez8
+		  dmx6fire, dsp24, dsp24_value, dsp24_71, ez8,
+		  phase88, mediastation
     omni	- Omni I/O support for MidiMan M-Audio Delta44/66
     cs8427_timeout - reset timeout for the CS8427 chip (S/PDIF transciever)
                      in msec resolution, default value is 500 (0.5 sec)
@@ -705,20 +721,46 @@
     is not used with all Envy24 based cards (for example in the MidiMan Delta
     serie).
 
+    Note: The supported board is detected by reading EEPROM or PCI
+	  SSID (if EEPROM isn't available).  You can override the
+	  model by passing "model" module option in case that the
+	  driver isn't configured properly or you want to try another
+	  type for testing.
+
   Module snd-ice1724
   ------------------
 
-    Module for Envy24HT (VT/ICE1724) based PCI sound cards.
+    Module for Envy24HT (VT/ICE1724), Envy24PT (VT1720) based PCI sound cards.
 			* MidiMan M Audio Revolution 7.1
 			* AMP Ltd AUDIO2000
-			* TerraTec Aureon Sky-5.1, Space-7.1
+			* TerraTec Aureon 5.1 Sky
+			* TerraTec Aureon 7.1 Space
+			* TerraTec Aureon 7.1 Universe
+			* TerraTec Phase 22
+			* TerraTec Phase 28
+			* AudioTrak Prodigy 7.1
+			* AudioTrak Prodigy 192
+			* Pontis MS300
+			* Albatron K8X800 Pro II 
+			* Chaintech ZNF3-150
+			* Chaintech ZNF3-250
+			* Chaintech 9CJS
+			* Chaintech AV-710
+			* Shuttle SN25P
 
     model       - Use the given board model, one of the following:
-		  revo71, amp2000, prodigy71, aureon51, aureon71,
-		  k8x800
+		  revo71, amp2000, prodigy71, prodigy192, aureon51,
+		  aureon71, universe, k8x800, phase22, phase28, ms300,
+		  av710
 
     Module supports up to 8 cards and autoprobe.
 
+    Note: The supported board is detected by reading EEPROM or PCI
+	  SSID (if EEPROM isn't available).  You can override the
+	  model by passing "model" module option in case that the
+	  driver isn't configured properly or you want to try another
+	  type for testing.
+
   Module snd-intel8x0
   -------------------
 
@@ -1037,7 +1079,8 @@
           module did formerly.  It will allocate the buffers in advance
           when any RME9652 cards are found.  To make the buffer
           allocation sure, load snd-page-alloc module in the early
-          stage of boot sequence.
+          stage of boot sequence.  See "Early Buffer Allocation"
+	  section.
 
   Module snd-sa11xx-uda1341 (on arm only)
   ---------------------------------------
@@ -1258,8 +1301,10 @@
 	  sample rates (e.g. 44.1kHz of mp3 playback), please let us
 	  know the PCI subsystem vendor/device id's (output of
 	  "lspci -nv").
-	  If dxs_support=5 does not work, try dxs_support=1; if it
-	  doesn't work too, try dxs_support=4.  If it still doesn't
+	  If dxs_support=5 does not work, try dxs_support=4; if it
+	  doesn't work too, try dxs_support=1.  (dxs_support=1 is
+	  usually for old motherboards.  The correct implementated
+	  board should work with 4 or 5.)  If it still doesn't
 	  work and the default setting is ok, dxs_support=3 is the
 	  right choice.  If the default setting doesn't work at all,
 	  try dxs_support=2 to disable the DXS channels.
@@ -1513,6 +1558,36 @@
 	   echo "rvplayer 0 0 block" > /proc/asound/card0/pcm0p/oss
 
 
+Early Buffer Allocation
+=======================
+
+Some drivers (e.g. hdsp) require the large contiguous buffers, and
+sometimes it's too late to find such spaces when the driver module is
+actually loaded due to memory fragmentation.  You can pre-allocate the
+PCM buffers by loading snd-page-alloc module and write commands to its
+proc file in prior, for example, in the early boot stage like
+/etc/init.d/*.local scripts.
+
+Reading the proc file /proc/drivers/snd-page-alloc shows the current
+usage of page allocation.  In writing, you can send the following
+commands to the snd-page-alloc driver:
+
+  - add VENDOR DEVICE MASK SIZE BUFFERS
+
+    VENDOR and DEVICE are PCI vendor and device IDs.  They take
+    integer numbers (0x prefix is needed for the hex).
+    MASK is the PCI DMA mask.  Pass 0 if not restricted.
+    SIZE is the size of each buffer to allocate.  You can pass
+    k and m suffix for KB and MB.  The max number is 16MB.
+    BUFFERS is the number of buffers to allocate.  It must be greater
+    than 0.  The max number is 4.
+
+  - erase
+
+    This will erase the all pre-allocated buffers which are not in
+    use.
+
+
 Links
 =====
 
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/Documentation/sound/alsa/CMIPCI.txt linux/Documentation/sound/alsa/CMIPCI.txt
--- linux-2.6.11/Documentation/sound/alsa/CMIPCI.txt	2005-03-02 08:37:47.000000000 +0100
+++ linux/Documentation/sound/alsa/CMIPCI.txt	2005-05-24 11:39:50.000000000 +0200
@@ -89,19 +89,22 @@
 
 There are some control switchs affecting to the speaker connections:
 
-"Line-In As Rear"	- As mentioned above, the line-in jack is used
-	for the rear (3th and 4th channels) output.
-"Line-In As Bass"	- The line-in jack is used for the bass (5th
-	and 6th channels) output.
-"Mic As Center/LFE"	- The mic jack is used for the bass output.
-	If this switch is on, you cannot use a microphone as a capture
-	source, of course.
-
+"Line-In Mode"	- an enum control to change the behavior of line-in
+	jack.  Either "Line-In", "Rear Output" or "Bass Output" can
+	be selected.  The last item is available only with model 039
+	or newer. 
+	When "Rear Output" is chosen, the surround channels 3 and 4
+	are output to line-in jack.
+"Mic-In Mode"	- an enum control to change the behavior of mic-in
+	jack.  Either "Mic-In" or "Center/LFE Output" can be
+	selected. 
+	When "Center/LFE Output" is chosen, the center and bass
+	channels (channels 5 and 6) are output to mic-in jack. 
 
 Digital I/O
 -----------
 
-The CM8x38 provides the excellent SPDIF capability with very chip
+The CM8x38 provides the excellent SPDIF capability with very cheap
 price (yes, that's the reason I bought the card :)
 
 The SPDIF playback and capture are done via the third PCM device
@@ -122,8 +125,9 @@
 simultaneously.
 
 To enable SPDIF output, you need to turn on "IEC958 Output Switch"
-control via mixer or alsactl.  Then you'll see the red light on from
-the card so you know that's working obviously :)
+control via mixer or alsactl ("IEC958" is the official name of
+so-called S/PDIF).  Then you'll see the red light on from the card so
+you know that's working obviously :)
 The SPDIF input is always enabled, so you can hear SPDIF input data
 from line-out with "IEC958 In Monitor" switch at any time (see
 below).
@@ -205,9 +209,10 @@
 MIDI CONTROLLER
 ---------------
 
-The MPU401-UART interface is enabled as default only for the first
-(CMIPCI) card.  You need to set module option "midi_port" properly
-for the 2nd (CMIPCI) card.
+The MPU401-UART interface is disabled as default.  You need to set
+module option "mpu_port" with a valid I/O port address to enable the
+MIDI support.  The valid I/O ports are 0x300, 0x310, 0x320 and 0x330.
+Choose the value which doesn't conflict with other cards.
 
 There is _no_ hardware wavetable function on this chip (except for
 OPL3 synth below).
@@ -229,9 +234,11 @@
 Joystick and Modem
 ------------------
 
-The joystick and modem should be available by enabling the control
-switch "Joystick" and "Modem" respectively.  But I myself have never
-tested them yet.
+The legacy joystick is supported.  To enable the joystick support, pass
+joystick_port=1 module option.  The value 1 means the auto-detection.
+If the auto-detection fails, try to pass the exact I/O address.
+
+The modem is enabled dynamically via a card control switch "Modem".
 
 
 Debugging Information
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/Documentation/sound/alsa/hdspm.txt linux/Documentation/sound/alsa/hdspm.txt
--- linux-2.6.11/Documentation/sound/alsa/hdspm.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux/Documentation/sound/alsa/hdspm.txt	2005-06-03 12:19:44.000000000 +0200
@@ -0,0 +1,362 @@
+Software Interface ALSA-DSP MADI Driver 
+
+(translated from German, so no good English ;-), 
+2004 - winfried ritsch
+
+
+
+ Full functionality has been added to the driver. Since some of
+ the Controls and startup-options  are ALSA-Standard and only the
+ special Controls are described and discussed below.
+
+
+ hardware functionality:
+
+   
+   Audio transmission:
+
+     number of channels --  depends on transmission mode
+
+		The number of channels chosen is from 1..Nmax. The reason to
+		use for a lower number of channels is only resource allocation,
+		since unused DMA channels are disabled and less memory is
+		allocated. So also the throughput of the PCI system can be
+		scaled. (Only important for low performance boards).
+
+       Single Speed -- 1..64 channels 
+
+		 (Note: Choosing the 56channel mode for transmission or as
+		 receiver, only 56 are transmitted/received over the MADI, but
+		 all 64 channels are available for the mixer, so channel count
+		 for the driver)
+
+       Double Speed -- 1..32 channels
+
+		 Note: Choosing the 56-channel mode for
+		 transmission/receive-mode , only 28 are transmitted/received
+		 over the MADI, but all 32 channels are available for the mixer,
+		 so channel count for the driver
+
+
+       Quad Speed -- 1..16 channels 
+
+		 Note: Choosing the 56-channel mode for
+		 transmission/receive-mode , only 14 are transmitted/received
+		 over the MADI, but all 16 channels are available for the mixer,
+		 so channel count for the driver
+
+     Format -- signed 32 Bit Little Endian (SNDRV_PCM_FMTBIT_S32_LE)
+
+     Sample Rates --
+
+       Single Speed -- 32000, 44100, 48000
+
+       Double Speed -- 64000, 88200, 96000 (untested)
+
+       Quad Speed -- 128000, 176400, 192000 (untested)
+
+     access-mode -- MMAP (memory mapped), Not interleaved
+     (PCM_NON-INTERLEAVED)
+
+     buffer-sizes -- 64,128,256,512,1024,2048,8192 Samples
+
+     fragments -- 2
+
+     Hardware-pointer -- 2 Modi
+
+
+		 The Card supports the readout of the actual Buffer-pointer,
+		 where DMA reads/writes. Since of the bulk mode of PCI it is only
+		 64 Byte accurate. SO it is not really usable for the
+		 ALSA-mid-level functions (here the buffer-ID gives a better
+		 result), but if MMAP is used by the application. Therefore it
+		 can be configured at load-time with the parameter
+		 precise-pointer.
+
+
+		 (Hint: Experimenting I found that the pointer is maximum 64 to
+		 large never to small. So if you subtract 64 you always have a
+		 safe pointer for writing, which is used on this mode inside
+		 ALSA. In theory now you can get now a latency as low as 16
+		 Samples, which is a quarter of the interrupt possibilities.)
+
+       Precise Pointer -- off
+					interrupt used for pointer-calculation
+
+       Precise Pointer -- on
+					hardware pointer used.
+
+   Controller:
+
+
+	  Since DSP-MADI-Mixer has 8152 Fader, it does not make sense to
+	  use the standard mixer-controls, since this would break most of
+	  (especially graphic) ALSA-Mixer GUIs. So Mixer control has be
+	  provided by a 2-dimensional controller using the
+	  hwdep-interface. 
+
+     Also all 128+256 Peak and RMS-Meter can be accessed via the
+     hwdep-interface. Since it could be a performance problem always
+     copying and converting Peak and RMS-Levels even if you just need
+     one, I decided to export the hardware structure, so that of
+     needed some driver-guru can implement a memory-mapping of mixer
+     or peak-meters over ioctl, or also to do only copying and no
+     conversion. A test-application shows the usage of the controller.
+
+    Latency Controls --- not implemented !!!
+
+
+	   Note: Within the windows-driver the latency is accessible of a
+	   control-panel, but buffer-sizes are controlled with ALSA from
+	   hwparams-calls and should not be changed in run-state, I did not
+	   implement it here.
+
+
+    System Clock -- suspended !!!!
+
+        Name -- "System Clock Mode"
+
+        Access -- Read Write
+
+        Values -- "Master" "Slave"
+
+
+		  !!!! This is a hardware-function but is in conflict with the
+		  Clock-source controller, which is a kind of ALSA-standard. I
+		  makes sense to set the card to a special mode (master at some
+		  frequency or slave), since even not using an Audio-application
+		  a studio should have working synchronisations setup. So use
+		  Clock-source-controller instead !!!!
+
+    Clock Source  
+
+       Name -- "Sample Clock Source"
+
+       Access -- Read Write
+
+       Values -- "AutoSync", "Internal 32.0 kHz", "Internal 44.1 kHz",
+       "Internal 48.0 kHz", "Internal 64.0 kHz", "Internal 88.2 kHz",
+       "Internal 96.0 kHz"
+
+		 Choose between Master at a specific Frequency and so also the
+		 Speed-mode or Slave (Autosync). Also see  "Preferred Sync Ref"
+
+
+       !!!! This is no pure hardware function but was implemented by
+       ALSA by some ALSA-drivers before, so I use it also. !!!
+
+
+    Preferred Sync Ref
+
+       Name -- "Preferred Sync Reference"
+
+       Access -- Read Write
+
+       Values -- "Word" "MADI"
+
+
+		 Within the Auto-sync-Mode the preferred Sync Source can be
+		 chosen. If it is not available another is used if possible.
+
+		 Note: Since MADI has a much higher bit-rate than word-clock, the
+		 card should synchronise better in MADI Mode. But since the
+		 RME-PLL is very good, there are almost no problems with
+		 word-clock too. I never found a difference.
+
+
+    TX 64 channel --- 
+
+       Name -- "TX 64 channels mode"
+
+       Access -- Read Write
+
+       Values -- 0 1
+
+		 Using 64-channel-modus (1) or 56-channel-modus for
+		 MADI-transmission (0).
+
+
+		 Note: This control is for output only. Input-mode is detected
+		 automatically from hardware sending MADI.
+
+
+    Clear TMS ---
+
+       Name -- "Clear Track Marker"
+
+       Access -- Read Write
+
+       Values -- 0 1
+
+
+		 Don't use to lower 5 Audio-bits on AES as additional Bits.
+        
+
+    Safe Mode oder Auto Input --- 
+
+       Name -- "Safe Mode"
+
+       Access -- Read Write
+
+       Values -- 0 1
+
+       (default on)
+
+		 If on (1), then if either the optical or coaxial connection
+		 has a failure, there is a takeover to the working one, with no
+		 sample failure. Its only useful if you use the second as a
+		 backup connection.
+
+    Input --- 
+
+       Name -- "Input Select"
+
+       Access -- Read Write
+
+       Values -- optical coaxial
+
+
+		 Choosing the Input, optical or coaxial. If Safe-mode is active,
+		 this is the preferred Input.
+
+-------------- Mixer ----------------------
+
+    Mixer
+
+       Name -- "Mixer"
+
+       Access -- Read Write
+
+       Values - <channel-number 0-127> <Value 0-65535>
+
+
+		 Here as a first value the channel-index is taken to get/set the
+		 corresponding mixer channel, where 0-63 are the input to output
+		 fader and 64-127 the playback to outputs fader. Value 0
+		 is channel muted 0 and 32768 an amplification of  1.
+
+    Chn 1-64
+
+       fast mixer for the ALSA-mixer utils. The diagonal of the
+       mixer-matrix is implemented from playback to output.
+       
+
+    Line Out
+
+       Name  -- "Line Out"
+
+       Access -- Read Write
+
+       Values -- 0 1
+
+		 Switching on and off the analog out, which has nothing to do
+		 with mixing or routing. the analog outs reflects channel 63,64.
+
+
+--- information (only read access):
+ 
+    Sample Rate
+
+       Name -- "System Sample Rate"
+
+       Access -- Read-only
+
+		 getting the sample rate.
+
+
+    External Rate measured
+
+       Name -- "External Rate"
+
+       Access -- Read only
+
+
+		 Should be "Autosync Rate", but Name used is
+		 ALSA-Scheme. External Sample frequency liked used on Autosync is
+		 reported.
+
+
+    MADI Sync Status
+
+       Name -- "MADI Sync Lock Status"
+
+       Access -- Read
+
+       Values -- 0,1,2
+
+       MADI-Input is 0=Unlocked, 1=Locked, or 2=Synced.
+
+
+    Word Clock Sync Status
+
+       Name -- "Word Clock Lock Status"
+
+       Access -- Read
+
+       Values -- 0,1,2
+
+       Word Clock Input is 0=Unlocked, 1=Locked, or 2=Synced.
+
+    AutoSync
+
+       Name -- "AutoSync Reference"
+
+       Access -- Read
+
+       Values -- "WordClock", "MADI", "None"
+
+		 Sync-Reference is either "WordClock", "MADI" or none.
+
+   RX 64ch --- noch nicht implementiert
+
+       MADI-Receiver is in 64 channel mode oder 56 channel mode.
+
+
+   AB_inp   --- not tested 
+
+		 Used input for Auto-Input.
+
+
+   actual Buffer Position --- not implemented
+
+	   !!! this is a ALSA internal function, so no control is used !!!
+
+
+
+Calling Parameter:
+
+   index int array (min = 1, max = 8), 
+     "Index value for RME HDSPM interface." card-index within ALSA
+
+     note: ALSA-standard
+
+   id string array (min = 1, max = 8), 
+     "ID string for RME HDSPM interface."
+
+     note: ALSA-standard
+
+   enable int array (min = 1, max = 8), 
+     "Enable/disable specific HDSPM sound-cards."
+
+     note: ALSA-standard
+
+   precise_ptr int array (min = 1, max = 8), 
+     "Enable precise pointer, or disable."
+
+     note: Use only when the application supports this (which is a special case).
+
+   line_outs_monitor int array (min = 1, max = 8), 
+     "Send playback streams to analog outs by default."
+
+
+	  note: each playback channel is mixed to the same numbered output
+	  channel (routed). This is against the ALSA-convention, where all
+	  channels have to be muted on after loading the driver, but was
+	  used before on other cards, so i historically use it again)
+
+
+
+   enable_monitor int array (min = 1, max = 8), 
+     "Enable Analog Out on Channel 63/64 by default."
+
+      note: here the analog output is enabled (but not routed).
\ No newline at end of file
