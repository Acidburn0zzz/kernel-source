# vim: syntax=diff
Path: .
URL: svn://svn.linux1394.org/ieee1394/trunk
Repository UUID: 7adecdd0-3bb7-0310-ba7c-81b663e03c32
Revision: 1206
Node Kind: directory
Schedule: normal
Last Changed Author: bcollins
Last Changed Rev: 1206
Last Changed Date: 2004-04-16 04:03:18 +0200 (Fri, 16 Apr 2004)
Properties Last Updated: 2003-02-28 14:00:09 +0100 (Fri, 28 Feb 2003)

diff -purNbBw linux-2.6.5/drivers/ieee1394/Kconfig linux-2.6.5.ieee1394/drivers/ieee1394/Kconfig
--- linux-2.6.5/drivers/ieee1394/Kconfig	2004-04-04 03:36:14.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/Kconfig	2004-04-06 12:41:22.000000000 +0000
@@ -124,7 +124,7 @@ config IEEE1394_SBP2_PHYS_DMA
 
 config IEEE1394_ETH1394
 	tristate "Ethernet over 1394"
-	depends on IEEE1394 && EXPERIMENTAL
+	depends on IEEE1394 && EXPERIMENTAL && INET
 	select IEEE1394_CONFIG_ROM_IP1394
 	select IEEE1394_EXTRA_CONFIG_ROMS
 	help
diff -purNbBw linux-2.6.5/drivers/ieee1394/amdtp.c linux-2.6.5.ieee1394/drivers/ieee1394/amdtp.c
--- linux-2.6.5/drivers/ieee1394/amdtp.c	2004-04-04 03:37:24.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/amdtp.c	2004-04-05 16:13:16.000000000 +0000
@@ -1266,6 +1266,7 @@ static int __init amdtp_init_module (voi
 {
 	cdev_init(&amdtp_cdev, &amdtp_fops);
 	amdtp_cdev.owner = THIS_MODULE;
+	kobject_set_name(&amdtp_cdev.kobj, "amdtp");
 	if (cdev_add(&amdtp_cdev, IEEE1394_AMDTP_DEV, 16)) {
 		HPSB_ERR("amdtp: unable to add char device");
  		return -EIO;
diff -purNbBw linux-2.6.5/drivers/ieee1394/csr1212.c linux-2.6.5.ieee1394/drivers/ieee1394/csr1212.c
--- linux-2.6.5/drivers/ieee1394/csr1212.c	2004-04-04 03:37:36.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/csr1212.c	2004-04-05 16:13:16.000000000 +0000
@@ -256,8 +256,7 @@ struct csr1212_keyval *csr1212_new_leaf(
 	
 	if (data_len > 0) {
 		kv->value.leaf.data = CSR1212_MALLOC(data_len);
-		if (!kv->value.leaf.data)
-		{
+		if (!kv->value.leaf.data) {
 			CSR1212_FREE(kv);
 			return NULL;
 		}
@@ -788,8 +787,7 @@ static int csr1212_append_new_cache(stru
 		return CSR1212_ENOMEM;
 	}
 
-	if (csr1212_attach_keyval_to_directory(csr->root_kv, cache->ext_rom) != CSR1212_SUCCESS)
-	{
+	if (csr1212_attach_keyval_to_directory(csr->root_kv, cache->ext_rom) != CSR1212_SUCCESS) {
 		csr1212_release_keyval(cache->ext_rom);
 		csr->ops->release_addr(csr_addr, csr->private);
 		CSR1212_FREE(cache);
diff -purNbBw linux-2.6.5/drivers/ieee1394/csr1212.h linux-2.6.5.ieee1394/drivers/ieee1394/csr1212.h
--- linux-2.6.5/drivers/ieee1394/csr1212.h	2004-04-04 03:36:26.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/csr1212.h	2004-04-05 16:13:16.000000000 +0000
@@ -37,6 +37,7 @@
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
+#include <linux/sched.h>
 
 #define CSR1212_MALLOC(size)		kmalloc((size), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL)
 #define CSR1212_FREE(ptr)		kfree(ptr)
diff -purNbBw linux-2.6.5/drivers/ieee1394/dma.c linux-2.6.5.ieee1394/drivers/ieee1394/dma.c
--- linux-2.6.5/drivers/ieee1394/dma.c	2004-04-04 03:37:07.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/dma.c	2004-04-05 17:14:35.000000000 +0000
@@ -196,6 +196,8 @@ void dma_region_sync_for_device(struct d
 	pci_dma_sync_sg_for_device(dma->dev, &dma->sglist[first], last - first + 1, dma->direction);
 }
 
+#ifdef CONFIG_MMU
+
 /* nopage() handler for mmap access */
 
 static struct page*
@@ -251,3 +253,12 @@ int dma_region_mmap(struct dma_region *d
 
 	return 0;
 }
+
+#else /* CONFIG_MMU */
+
+int dma_region_mmap(struct dma_region *dma, struct file *file, struct vm_area_struct *vma)
+{
+	return -EINVAL;
+}
+
+#endif /* CONFIG_MMU */
diff -purNbBw linux-2.6.5/drivers/ieee1394/dv1394-private.h linux-2.6.5.ieee1394/drivers/ieee1394/dv1394-private.h
--- linux-2.6.5/drivers/ieee1394/dv1394-private.h	2004-04-04 03:37:27.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/dv1394-private.h	2004-04-05 16:13:16.000000000 +0000
@@ -511,7 +511,6 @@ struct video_card {
 
 	       The interrupt handler will NEVER advance active_frame to a
 	       frame that is not READY.
-	       
 	*/
 	int active_frame;
 	int first_run;
diff -purNbBw linux-2.6.5/drivers/ieee1394/dv1394.c linux-2.6.5.ieee1394/drivers/ieee1394/dv1394.c
--- linux-2.6.5/drivers/ieee1394/dv1394.c	2004-04-04 03:37:37.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/dv1394.c	2004-04-05 16:13:16.000000000 +0000
@@ -834,8 +834,7 @@ static void start_dma_receive(struct vid
 				printk("RUNNING!\n");
 		}
 #endif
-	} 
-	else if ( reg_read(video->ohci, video->ohci_IsoRcvContextControlSet) &  (1 << 11) ) {
+	} else if ( reg_read(video->ohci, video->ohci_IsoRcvContextControlSet) &  (1 << 11) ) {
 		debug_printk("DEAD, event = %x\n", 
 			     reg_read(video->ohci, video->ohci_IsoRcvContextControlSet) & 0x1F);
 
@@ -1986,8 +1985,6 @@ static void it_tasklet_func(unsigned lon
 				video->dropped_frames++;
 			}
 
-
-		
 		} /* for (each frame) */
 	}
 
@@ -2013,8 +2010,7 @@ static void ir_tasklet_func(unsigned lon
 		goto out;
 	
 	if ( (video->ohci_ir_ctx != -1) &&
-	    (reg_read(video->ohci, video->ohci_IsoRcvContextControlSet) & (1 << 10)) )
-	{ 
+	    (reg_read(video->ohci, video->ohci_IsoRcvContextControlSet) & (1 << 10)) ) {
 
 		int sof=0; /* start-of-frame flag */
 		struct frame *f;
@@ -2616,6 +2612,7 @@ static int __init dv1394_init_module(voi
 
 	cdev_init(&dv1394_cdev, &dv1394_fops);
 	dv1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&dv1394_cdev.kobj, "dv1394");
 	ret = cdev_add(&dv1394_cdev, IEEE1394_DV1394_DEV, 16);
 	if (ret) {
 		printk(KERN_ERR "dv1394: unable to register character device\n");
diff -purNbBw linux-2.6.5/drivers/ieee1394/eth1394.c linux-2.6.5.ieee1394/drivers/ieee1394/eth1394.c
--- linux-2.6.5/drivers/ieee1394/eth1394.c	2004-04-04 03:37:25.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/eth1394.c	2004-04-05 16:13:16.000000000 +0000
@@ -89,7 +89,7 @@
 #define TRACE() printk(KERN_ERR "%s:%s[%d] ---- TRACE\n", driver_name, __FUNCTION__, __LINE__)
 
 static char version[] __devinitdata =
-	"$Rev: 1175 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1198 $ Ben Collins <bcollins@debian.org>";
 
 struct fragment_info {
 	struct list_head list;
@@ -216,7 +216,7 @@ static struct hpsb_highlevel eth1394_hig
 /* This is called after an "ifup" */
 static int ether1394_open (struct net_device *dev)
 {
-	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	struct eth1394_priv *priv = dev->priv;
 	int ret = 0;
 
 	/* Something bad happened, don't even try */
@@ -278,7 +278,7 @@ static void ether1394_tx_timeout (struct
 
 static int ether1394_change_mtu(struct net_device *dev, int new_mtu)
 {
-	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	struct eth1394_priv *priv = dev->priv;
 
 	if ((new_mtu < 68) ||
 	    (new_mtu > min(ETH1394_DATA_LEN,
@@ -479,7 +479,7 @@ static void ether1394_reset_priv (struct
 {
 	unsigned long flags;
 	int i;
-	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	struct eth1394_priv *priv = dev->priv;
 	struct hpsb_host *host = priv->host;
 	u64 guid = *((u64*)&(host->csr.rom->bus_info_data[3]));
 	u16 maxpayload = 1 << (host->csr.max_rec + 1);
@@ -731,14 +731,12 @@ static int ether1394_header(struct sk_bu
 
 	eth->h_proto = htons(type);
 
-	if (dev->flags & (IFF_LOOPBACK|IFF_NOARP)) 
-	{
+	if (dev->flags & (IFF_LOOPBACK|IFF_NOARP)) {
 		memset(eth->h_dest, 0, dev->addr_len);
 		return(dev->hard_header_len);
 	}
 
-	if (daddr)
-	{
+	if (daddr) {
 		memcpy(eth->h_dest,daddr,dev->addr_len);
 		return dev->hard_header_len;
 	}
@@ -760,8 +758,8 @@ static int ether1394_rebuild_header(stru
 	struct eth1394hdr *eth = (struct eth1394hdr *)skb->data;
 	struct net_device *dev = skb->dev;
 
-	switch (eth->h_proto)
-	{
+	switch (eth->h_proto) {
+
 #ifdef CONFIG_INET
 	case __constant_htons(ETH_P_IP):
  		return arp_find((unsigned char*)&eth->h_dest, skb);
@@ -867,7 +865,7 @@ static inline u16 ether1394_parse_encap(
 					nodeid_t srcid, nodeid_t destid,
 					u16 ether_type)
 {
-	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	struct eth1394_priv *priv = dev->priv;
 	u64 dest_hw;
 	unsigned short ret = 0;
 
@@ -1538,7 +1536,6 @@ static inline void ether1394_free_packet
 {
 	if (packet->tcode != TCODE_STREAM_DATA)
 		hpsb_free_tlabel(packet);
-	packet->data = NULL;
 	hpsb_free_packet(packet);
 }
 
@@ -1583,7 +1580,7 @@ static inline void ether1394_dg_complete
 {
 	struct sk_buff *skb = ptask->skb;
 	struct net_device *dev = skb->dev;
-	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	struct eth1394_priv *priv = dev->priv;
         unsigned long flags;
 		
 	/* Statistics */
@@ -1616,8 +1613,7 @@ static void ether1394_complete_cb(void *
 	ether1394_free_packet(packet);
 
 	ptask->outstanding_pkts--;
-	if (ptask->outstanding_pkts > 0 && !fail)
-	{
+	if (ptask->outstanding_pkts > 0 && !fail) {
 		int tx_len;
 
 		/* Add the encapsulation header to the fragment */
@@ -1637,7 +1633,7 @@ static int ether1394_tx (struct sk_buff 
 {
 	int kmflags = in_interrupt() ? GFP_ATOMIC : GFP_KERNEL;
 	struct eth1394hdr *eth;
-	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	struct eth1394_priv *priv = dev->priv;
 	int proto;
 	unsigned long flags;
 	nodeid_t dest_node;
@@ -1797,7 +1793,7 @@ static int ether1394_ethtool_ioctl(struc
 		case ETHTOOL_GDRVINFO: {
 			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
 			strcpy (info.driver, driver_name);
-			strcpy (info.version, "$Rev: 1175 $");
+			strcpy (info.version, "$Rev: 1198 $");
 			/* FIXME XXX provide sane businfo */
 			strcpy (info.bus_info, "ieee1394");
 			if (copy_to_user (useraddr, &info, sizeof (info)))
diff -purNbBw linux-2.6.5/drivers/ieee1394/hosts.c linux-2.6.5.ieee1394/drivers/ieee1394/hosts.c
--- linux-2.6.5/drivers/ieee1394/hosts.c	2004-04-04 03:36:56.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/hosts.c	2004-03-13 14:23:01.000000000 +0000
@@ -126,9 +126,7 @@ struct hpsb_host *hpsb_alloc_host(struct
 	h->hostdata = h + 1;
         h->driver = drv;
 
-        INIT_LIST_HEAD(&h->pending_packets);
-        spin_lock_init(&h->pending_pkt_lock);
-
+	skb_queue_head_init(&h->pending_packet_queue);
 	INIT_LIST_HEAD(&h->addr_space);
 
 	init_timer(&h->delayed_reset);
diff -purNbBw linux-2.6.5/drivers/ieee1394/hosts.h linux-2.6.5.ieee1394/drivers/ieee1394/hosts.h
--- linux-2.6.5/drivers/ieee1394/hosts.h	2004-04-04 03:36:26.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/hosts.h	2004-04-05 16:13:16.000000000 +0000
@@ -5,6 +5,8 @@
 #include <linux/wait.h>
 #include <linux/list.h>
 #include <linux/timer.h>
+#include <linux/skbuff.h>
+
 #include <asm/semaphore.h>
 
 #include "ieee1394_types.h"
@@ -21,8 +23,8 @@ struct hpsb_host {
 
         atomic_t generation;
 
-        struct list_head pending_packets;
-        spinlock_t pending_pkt_lock;
+	struct sk_buff_head pending_packet_queue;
+
 	struct timer_list timeout;
 	unsigned long timeout_interval;
 
diff -purNbBw linux-2.6.5/drivers/ieee1394/ieee1394_core.c linux-2.6.5.ieee1394/drivers/ieee1394/ieee1394_core.c
--- linux-2.6.5/drivers/ieee1394/ieee1394_core.c	2004-04-04 03:36:45.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/ieee1394_core.c	2004-04-05 16:39:46.000000000 +0000
@@ -31,6 +31,8 @@
 #include <linux/moduleparam.h>
 #include <linux/bitops.h>
 #include <linux/kdev_t.h>
+#include <linux/skbuff.h>
+
 #include <asm/byteorder.h>
 #include <asm/semaphore.h>
 
@@ -56,8 +58,6 @@ MODULE_PARM_DESC(disable_nodemgr, "Disab
 /* We are GPL, so treat us special */
 MODULE_LICENSE("GPL");
 
-static kmem_cache_t *hpsb_packet_cache;
-
 /* Some globals used */
 const char *hpsb_speedto_str[] = { "S100", "S200", "S400", "S800", "S1600", "S3200" };
 
@@ -122,30 +122,27 @@ void hpsb_set_packet_complete_task(struc
 struct hpsb_packet *hpsb_alloc_packet(size_t data_size)
 {
 	struct hpsb_packet *packet = NULL;
-	void *data = NULL;
-	int gfp_flags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+	struct sk_buff *skb;
+
+	data_size = ((data_size + 3) & ~3);
 
-	packet = kmem_cache_alloc(hpsb_packet_cache, gfp_flags);
-	if (packet == NULL)
+	skb = alloc_skb(data_size + sizeof(*packet), GFP_ATOMIC);
+	if (skb == NULL)
 		return NULL;
 
-	memset(packet, 0, sizeof(*packet));
+	memset(skb->data, 0, data_size + sizeof(*packet));
+
+	packet = (struct hpsb_packet *)skb->data;
+	packet->skb = skb;
 
 	packet->header = packet->embedded_header;
-	INIT_LIST_HEAD(&packet->list);
 	packet->state = hpsb_unused;
 	packet->generation = -1;
+	INIT_LIST_HEAD(&packet->driver_list);
 	atomic_set(&packet->refcnt, 1);
 
 	if (data_size) {
-		data_size = (data_size + 3) & ~3;
-		data = kmalloc(data_size + 8, gfp_flags);
-		if (data == NULL) {
-			kmem_cache_free(hpsb_packet_cache, packet);
-			return NULL;
-		}
-
-		packet->data = data;
+		packet->data = (quadlet_t *)(skb->data + sizeof(*packet));
 		packet->data_size = data_size;
 	}
 
@@ -162,8 +159,8 @@ struct hpsb_packet *hpsb_alloc_packet(si
 void hpsb_free_packet(struct hpsb_packet *packet)
 {
 	if (packet && atomic_dec_and_test(&packet->refcnt)) {
-		kfree(packet->data);
-		kmem_cache_free(hpsb_packet_cache, packet);
+		BUG_ON(!list_empty(&packet->driver_list));
+		kfree_skb(packet->skb);
 	}
 }
 
@@ -413,7 +410,7 @@ void hpsb_packet_sent(struct hpsb_host *
 
 	if (ackcode != ACK_PENDING || !packet->expect_response) {
 		atomic_dec(&packet->refcnt);
-		list_del(&packet->list);
+		skb_unlink(packet->skb);
 		packet->state = hpsb_complete;
 		queue_packet_complete(packet);
 		return;
@@ -505,17 +502,17 @@ int hpsb_send_packet(struct hpsb_packet 
 
         packet->state = hpsb_queued;
 
-	if (!packet->no_waiter || packet->expect_response) {
-		unsigned long flags;
+	/* This just seems silly to me */
+	WARN_ON(packet->no_waiter && packet->expect_response);
 
+	if (!packet->no_waiter || packet->expect_response) {
 		atomic_inc(&packet->refcnt);
-		spin_lock_irqsave(&host->pending_pkt_lock, flags);
-		list_add_tail(&packet->list, &host->pending_packets);
-		spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+		skb_queue_tail(&host->pending_packet_queue, packet->skb);
 	}
 
-        if (packet->node_id == host->node_id)
-        { /* it is a local request, so handle it locally */
+        if (packet->node_id == host->node_id) {
+		/* it is a local request, so handle it locally */
+
                 quadlet_t *data;
                 size_t size = packet->data_size + packet->header_size;
 
@@ -547,6 +544,7 @@ int hpsb_send_packet(struct hpsb_packet 
                                        + NODEID_TO_NODE(packet->node_id)];
         }
 
+#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
         switch (packet->speed_code) {
         case 2:
                 dump_packet("send packet 400:", packet->header,
@@ -560,6 +558,7 @@ int hpsb_send_packet(struct hpsb_packet 
                 dump_packet("send packet 100:", packet->header,
                             packet->header_size);
         }
+#endif
 
         return host->driver->transmit_packet(host, packet);
 }
@@ -595,80 +594,78 @@ static void send_packet_nocare(struct hp
 }
 
 
-void handle_packet_response(struct hpsb_host *host, int tcode, quadlet_t *data,
-                            size_t size)
+static void handle_packet_response(struct hpsb_host *host, int tcode,
+				   quadlet_t *data, size_t size)
 {
         struct hpsb_packet *packet = NULL;
-        struct list_head *lh;
+	struct sk_buff *skb;
         int tcode_match = 0;
         int tlabel;
         unsigned long flags;
 
         tlabel = (data[0] >> 10) & 0x3f;
 
-        spin_lock_irqsave(&host->pending_pkt_lock, flags);
+	spin_lock_irqsave(&host->pending_packet_queue.lock, flags);
 
-        list_for_each(lh, &host->pending_packets) {
-                packet = list_entry(lh, struct hpsb_packet, list);
+	skb_queue_walk(&host->pending_packet_queue, skb) {
+		packet = (struct hpsb_packet *)skb->data;
                 if ((packet->tlabel == tlabel)
                     && (packet->node_id == (data[1] >> 16))){
                         break;
                 }
+
+		packet = NULL;
         }
 
-        if (lh == &host->pending_packets) {
+	if (packet == NULL) {
                 HPSB_DEBUG("unsolicited response packet received - no tlabel match");
                 dump_packet("contents:", data, 16);
-                spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+		spin_unlock_irqrestore(&host->pending_packet_queue.lock, flags);
                 return;
         }
 
         switch (packet->tcode) {
         case TCODE_WRITEQ:
         case TCODE_WRITEB:
-                if (tcode == TCODE_WRITE_RESPONSE) tcode_match = 1;
+                if (tcode != TCODE_WRITE_RESPONSE)
+			break;
+		tcode_match = 1;
+		memcpy(packet->header, data, 12);
                 break;
         case TCODE_READQ:
-                if (tcode == TCODE_READQ_RESPONSE) tcode_match = 1;
+                if (tcode != TCODE_READQ_RESPONSE)
+			break;
+		tcode_match = 1;
+		memcpy(packet->header, data, 16);
                 break;
         case TCODE_READB:
-                if (tcode == TCODE_READB_RESPONSE) tcode_match = 1;
+                if (tcode != TCODE_READB_RESPONSE)
+			break;
+		tcode_match = 1;
+		BUG_ON(packet->skb->len - sizeof(*packet) < size - 16);
+		memcpy(packet->header, data, 16);
+		memcpy(packet->data, data + 4, size - 16);
                 break;
         case TCODE_LOCK_REQUEST:
-                if (tcode == TCODE_LOCK_RESPONSE) tcode_match = 1;
+                if (tcode != TCODE_LOCK_RESPONSE)
+			break;
+		tcode_match = 1;
+		size = min((size - 16), (size_t)8);
+		BUG_ON(packet->skb->len - sizeof(*packet) < size);
+		memcpy(packet->header, data, 16);
+		memcpy(packet->data, data + 4, size);
                 break;
         }
 
-        if (!tcode_match || (packet->tlabel != tlabel)
-            || (packet->node_id != (data[1] >> 16))) {
+        if (!tcode_match) {
                 HPSB_INFO("unsolicited response packet received - tcode mismatch");
                 dump_packet("contents:", data, 16);
-
-                spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+		spin_unlock_irqrestore(&host->pending_packet_queue.lock, flags);
                 return;
         }
 
-        list_del(&packet->list);
-
-        spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
-
-        /* FIXME - update size fields? */
-        switch (tcode) {
-        case TCODE_WRITE_RESPONSE:
-                memcpy(packet->header, data, 12);
-                break;
-        case TCODE_READQ_RESPONSE:
-                memcpy(packet->header, data, 16);
-                break;
-        case TCODE_READB_RESPONSE:
-                memcpy(packet->header, data, 16);
-                memcpy(packet->data, data + 4, size - 16);
-                break;
-        case TCODE_LOCK_RESPONSE:
-                memcpy(packet->header, data, 16);
-                memcpy(packet->data, data + 4, (size - 16) > 8 ? 8 : size - 16);
-                break;
-        }
+	__skb_unlink(skb, skb->list);
+	spin_unlock_irqrestore(&host->pending_packet_queue.lock, flags);
 
 	if (packet->state == hpsb_queued) {
 		packet->sendtime = jiffies;
@@ -685,10 +682,8 @@ static struct hpsb_packet *create_reply_
 {
         struct hpsb_packet *p;
 
-        dsize += (dsize % 4 ? 4 - (dsize % 4) : 0);
-
         p = hpsb_alloc_packet(dsize);
-        if (p == NULL) {
+        if (unlikely(p == NULL)) {
                 /* FIXME - send data_error response */
                 return NULL;
         }
@@ -702,9 +697,8 @@ static struct hpsb_packet *create_reply_
 
 	p->generation = get_hpsb_generation(host);
 
-        if (dsize % 4) {
+	if (dsize % 4)
                 p->data[dsize / 4] = 0;
-        }
 
         return p;
 }
@@ -941,19 +935,14 @@ void hpsb_packet_received(struct hpsb_ho
 
 void abort_requests(struct hpsb_host *host)
 {
-        unsigned long flags;
-        struct hpsb_packet *packet, *packet_next;
-        LIST_HEAD(llist);
+	struct hpsb_packet *packet;
+	struct sk_buff *skb;
 
         host->driver->devctl(host, CANCEL_REQUESTS, 0);
 
-        spin_lock_irqsave(&host->pending_pkt_lock, flags);
-        list_splice(&host->pending_packets, &llist);
-        INIT_LIST_HEAD(&host->pending_packets);
-        spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+	while ((skb = skb_dequeue(&host->pending_packet_queue)) != NULL) {
+		packet = (struct hpsb_packet *)skb->data;
 
-        list_for_each_entry_safe(packet, packet_next, &llist, list) {
-                list_del(&packet->list);
                 packet->state = hpsb_complete;
                 packet->ack_code = ACKX_ABORTED;
 		queue_packet_complete(packet);
@@ -964,51 +953,57 @@ void abort_timedouts(unsigned long __opa
 {
 	struct hpsb_host *host = (struct hpsb_host *)__opaque;
         unsigned long flags;
-        struct hpsb_packet *packet, *packet_next;
+	struct hpsb_packet *packet;
+	struct sk_buff *skb;
         unsigned long expire;
-        LIST_HEAD(expiredlist);
 
         spin_lock_irqsave(&host->csr.lock, flags);
 	expire = host->csr.expire;
         spin_unlock_irqrestore(&host->csr.lock, flags);
 
-        spin_lock_irqsave(&host->pending_pkt_lock, flags);
-
-	list_for_each_entry_safe(packet, packet_next, &host->pending_packets, list) {
-                if (time_before(packet->sendtime + expire, jiffies)) {
-                        list_del(&packet->list);
-                        list_add(&packet->list, &expiredlist);
-                }
-        }
+	/* Hold the lock around this, since we aren't dequeuing all
+	 * packets, just ones we need. */
+	spin_lock_irqsave(&host->pending_packet_queue.lock, flags);
 
-        if (!list_empty(&host->pending_packets))
-		mod_timer(&host->timeout, jiffies + host->timeout_interval);
+	while (!skb_queue_empty(&host->pending_packet_queue)) {
+		skb = skb_peek(&host->pending_packet_queue);
 
-        spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+		packet = (struct hpsb_packet *)skb->data;
 
-        list_for_each_entry_safe(packet, packet_next, &expiredlist, list) {
-                list_del(&packet->list);
+		if (time_before(packet->sendtime + expire, jiffies)) {
+			__skb_unlink(skb, skb->list);
                 packet->state = hpsb_complete;
                 packet->ack_code = ACKX_TIMEOUT;
 		queue_packet_complete(packet);
+		} else {
+			/* Since packets are added to the tail, the oldest
+			 * ones are first, always. When we get to one that
+			 * isn't timed out, the rest aren't either. */
+			break;
+		}
         }
+
+	if (!skb_queue_empty(&host->pending_packet_queue))
+		mod_timer(&host->timeout, jiffies + host->timeout_interval);
+
+	spin_unlock_irqrestore(&host->pending_packet_queue.lock, flags);
 }
 
+
+/* Kernel thread and vars, which handles packets that are completed. Only
+ * packets that have a "complete" function are sent here. This way, the
+ * completion is run out of kernel context, and doesn't block the rest of
+ * the stack. */
 static int khpsbpkt_pid = -1;
 static DECLARE_COMPLETION(khpsbpkt_complete);
-static LIST_HEAD(hpsbpkt_list);
+struct sk_buff_head hpsbpkt_queue;
 static DECLARE_MUTEX_LOCKED(khpsbpkt_sig);
-static spinlock_t khpsbpkt_lock = SPIN_LOCK_UNLOCKED;
 
 
 static void queue_packet_complete(struct hpsb_packet *packet)
 {
 	if (packet->complete_routine != NULL) {
-		unsigned long flags;
-
-		spin_lock_irqsave(&khpsbpkt_lock, flags);
-		list_add_tail(&packet->list, &hpsbpkt_list);
-		spin_unlock_irqrestore(&khpsbpkt_lock, flags);
+		skb_queue_tail(&hpsbpkt_queue, packet->skb);
 
 		/* Signal the kernel thread to handle this */
 		up(&khpsbpkt_sig);
@@ -1018,24 +1013,24 @@ static void queue_packet_complete(struct
 
 static int hpsbpkt_thread(void *__hi)
 {
-	struct hpsb_packet *packet, *next;
-	unsigned long flags;
+	struct sk_buff *skb;
+	struct hpsb_packet *packet;
+	void (*complete_routine)(void*);
+	void *complete_data;
 
 	daemonize("khpsbpkt");
-	allow_signal(SIGTERM);
 
 	while (!down_interruptible(&khpsbpkt_sig)) {
-		spin_lock_irqsave(&khpsbpkt_lock, flags);
-		list_for_each_entry_safe(packet, next, &hpsbpkt_list, list) {
-			void (*complete_routine)(void*) = packet->complete_routine;
-			void *complete_data = packet->complete_data;
+		while ((skb = skb_dequeue(&hpsbpkt_queue)) != NULL) {
+			packet = (struct hpsb_packet *)skb->data;
+
+			complete_routine = packet->complete_routine;
+			complete_data = packet->complete_data;
 
-			list_del(&packet->list);
 			packet->complete_routine = packet->complete_data = NULL;
 
 			complete_routine(complete_data);
 		}
-		spin_unlock_irqrestore(&khpsbpkt_lock, flags);
 	}
 
 	complete_and_exit(&khpsbpkt_complete, 0);
@@ -1046,6 +1041,8 @@ static int __init ieee1394_init(void)
 {
 	int i;
 
+	skb_queue_head_init(&hpsbpkt_queue);
+
 	if (hpsb_init_config_roms()) {
 		HPSB_ERR("Failed to initialize some config rom entries.\n");
 		HPSB_ERR("Some features may not be available\n");
@@ -1066,9 +1063,6 @@ static int __init ieee1394_init(void)
 
 	devfs_mk_dir("ieee1394");
 
-	hpsb_packet_cache = kmem_cache_create("hpsb_packet", sizeof(struct hpsb_packet),
-					      0, SLAB_HWCACHE_ALIGN, NULL, NULL);
-
 	bus_register(&ieee1394_bus_type);
 	for (i = 0; fw_bus_attrs[i]; i++)
 		bus_create_file(&ieee1394_bus_type, fw_bus_attrs[i]);
@@ -1104,8 +1098,6 @@ static void __exit ieee1394_cleanup(void
 		wait_for_completion(&khpsbpkt_complete);
 	}
 
-	kmem_cache_destroy(hpsb_packet_cache);
-
 	hpsb_cleanup_config_roms();
 
 	unregister_chrdev_region(IEEE1394_CORE_DEV, 256);
diff -purNbBw linux-2.6.5/drivers/ieee1394/ieee1394_core.h linux-2.6.5.ieee1394/drivers/ieee1394/ieee1394_core.h
--- linux-2.6.5/drivers/ieee1394/ieee1394_core.h	2004-04-04 03:36:25.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/ieee1394_core.h	2004-04-05 16:13:16.000000000 +0000
@@ -12,9 +12,13 @@
 struct hpsb_packet {
         /* This struct is basically read-only for hosts with the exception of
          * the data buffer contents and xnext - see below. */
-        struct list_head list;
 
-        /* This can be used for host driver internal linking. */
+	/* This can be used for host driver internal linking.
+	 *
+	 * NOTE: This must be left in init state when the driver is done
+	 * with it (e.g. by using list_del_init()), since the core does
+	 * some sanity checks to make sure the packet is not on a
+	 * driver_list when free'ing it. */
 	struct list_head driver_list;
 
         nodeid_t node_id;
@@ -27,10 +31,9 @@ struct hpsb_packet {
          * queued   = queued for sending
          * pending  = sent, waiting for response
          * complete = processing completed, successful or not
-         * incoming = incoming packet
          */
         enum { 
-                hpsb_unused, hpsb_queued, hpsb_pending, hpsb_complete, hpsb_incoming 
+                hpsb_unused, hpsb_queued, hpsb_pending, hpsb_complete
         } __attribute__((packed)) state;
 
         /* These are core internal. */
@@ -67,6 +70,9 @@ struct hpsb_packet {
 	void (*complete_routine)(void *);
 	void *complete_data;
 
+	/* XXX This is just a hack at the moment */
+	struct sk_buff *skb;
+
         /* Store jiffies for implementing bus timeouts. */
         unsigned long sendtime;
 
diff -purNbBw linux-2.6.5/drivers/ieee1394/ieee1394_transactions.c linux-2.6.5.ieee1394/drivers/ieee1394/ieee1394_transactions.c
--- linux-2.6.5/drivers/ieee1394/ieee1394_transactions.c	2004-04-04 03:36:55.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/ieee1394_transactions.c	2004-04-05 16:13:16.000000000 +0000
@@ -268,7 +268,7 @@ struct hpsb_packet *hpsb_make_readpacket
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet((length + 3) & ~3);
+	packet = hpsb_alloc_packet(length);
 	if (!packet)
 		return NULL;
 
@@ -296,7 +296,7 @@ struct hpsb_packet *hpsb_make_writepacke
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet((length + 3) & ~3);
+	packet = hpsb_alloc_packet(length);
 	if (!packet)
 		return NULL;
 
@@ -330,7 +330,7 @@ struct hpsb_packet *hpsb_make_streampack
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet((length + 3) & ~3);
+	packet = hpsb_alloc_packet(length);
 	if (!packet)
 		return NULL;
 
diff -purNbBw linux-2.6.5/drivers/ieee1394/ieee1394_types.h linux-2.6.5.ieee1394/drivers/ieee1394/ieee1394_types.h
--- linux-2.6.5/drivers/ieee1394/ieee1394_types.h	2004-04-04 03:37:38.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/ieee1394_types.h	2004-04-16 02:03:18.000000000 +0000
@@ -24,7 +24,7 @@ struct hpsb_tlabel_pool {
 
 #define HPSB_TPOOL_INIT(_tp)			\
 do {						\
-	CLEAR_BITMAP((_tp)->pool, 64);		\
+	bitmap_zero((_tp)->pool, 64);		\
 	spin_lock_init(&(_tp)->lock);		\
 	(_tp)->next = 0;			\
 	(_tp)->allocations = 0;			\
diff -purNbBw linux-2.6.5/drivers/ieee1394/nodemgr.c linux-2.6.5.ieee1394/drivers/ieee1394/nodemgr.c
--- linux-2.6.5/drivers/ieee1394/nodemgr.c	2004-04-04 03:37:24.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/nodemgr.c	2004-04-05 17:14:35.000000000 +0000
@@ -356,7 +356,6 @@ static int nodemgr_rescan_bus_thread(voi
 {
 	/* No userlevel access needed */
 	daemonize("kfwrescan");
-	allow_signal(SIGTERM);
 
 	bus_rescan_devices(&ieee1394_bus_type);
 
@@ -1056,13 +1055,14 @@ static int nodemgr_hotplug(struct class_
 
 #define PUT_ENVP(fmt,val) 					\
 do {								\
+    	int printed;						\
 	envp[i++] = buffer;					\
-	length += snprintf(buffer, buffer_size - length,	\
+	printed = snprintf(buffer, buffer_size - length,	\
 			   fmt, val);				\
-	if ((buffer_size - length <= 0) || (i >= num_envp))	\
+	if ((buffer_size - (length+printed) <= 0) || (i >= num_envp))	\
 		return -ENOMEM;					\
-	++length;						\
-	buffer += length;					\
+	length += printed+1;					\
+	buffer += printed+1;					\
 } while (0)
 
 	PUT_ENVP("VENDOR_ID=%06x", ud->vendor_id);
@@ -1382,7 +1381,8 @@ static int nodemgr_do_irm_duties(struct 
 {
 	quadlet_t bc;
         
-	if (!host->is_irm)
+	/* if irm_id == -1 then there is no IRM on this bus */
+	if (!host->is_irm || host->irm_id == (nodeid_t)-1)
 		return 1;
 
 	host->csr.broadcast_channel |= 0x40000000;  /* set validity bit */
@@ -1467,7 +1467,6 @@ static int nodemgr_host_thread(void *__h
 
 	/* No userlevel access needed */
 	daemonize(hi->daemon_name);
-	allow_signal(SIGTERM);
 
 	/* Setup our device-model entries */
 	nodemgr_create_host_dev_files(host);
diff -purNbBw linux-2.6.5/drivers/ieee1394/ohci1394.c linux-2.6.5.ieee1394/drivers/ieee1394/ohci1394.c
--- linux-2.6.5/drivers/ieee1394/ohci1394.c	2004-04-04 03:38:04.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/ohci1394.c	2004-04-06 01:30:49.000000000 +0000
@@ -162,7 +162,7 @@ printk(level "%s: " fmt "\n" , OHCI1394_
 printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, ohci->host->id , ## args)
 
 static char version[] __devinitdata =
-	"$Rev: 1172 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1203 $ Ben Collins <bcollins@debian.org>";
 
 /* Module Parameters */
 static int phys_dma = 1;
@@ -367,32 +367,6 @@ static void ohci_soft_reset(struct ti_oh
 	DBGMSG ("Soft reset finished");
 }
 
-static int run_context(struct ti_ohci *ohci, int reg, char *msg)
-{
-	u32 nodeId;
-
-	/* check that the node id is valid */
-	nodeId = reg_read(ohci, OHCI1394_NodeID);
-	if (!(nodeId&0x80000000)) {
-		PRINT(KERN_ERR,
-		      "Running dma failed because Node ID is not valid");
-		return -1;
-	}
-
-	/* check that the node number != 63 */
-	if ((nodeId&0x3f)==63) {
-		PRINT(KERN_ERR,
-		      "Running dma failed because Node ID == 63");
-		return -1;
-	}
-
-	/* Run the dma context */
-	reg_write(ohci, reg, 0x8000);
-
-	if (msg) PRINT(KERN_DEBUG, "%s", msg);
-
-	return 0;
-}
 
 /* Generate the dma receive prgs and start the context */
 static void initialize_dma_rcv_ctx(struct dma_rcv_ctx *d, int generate_irq)
@@ -620,6 +594,39 @@ static void ohci_initialize(struct ti_oh
 		if (status & 0x20)
 			set_phy_reg(ohci, 8, status & ~1);
 	}
+
+        /* Serial EEPROM Sanity check. */
+        if ((ohci->max_packet_size < 512) ||
+	    (ohci->max_packet_size > 4096)) {
+		/* Serial EEPROM contents are suspect, set a sane max packet
+		 * size and print the raw contents for bug reports if verbose
+		 * debug is enabled. */
+#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
+		int i;
+#endif
+
+		PRINT(KERN_DEBUG, "Serial EEPROM has suspicious values, "
+                      "attempting to setting max_packet_size to 512 bytes");
+		reg_write(ohci, OHCI1394_BusOptions,
+			  (reg_read(ohci, OHCI1394_BusOptions) & 0xf007) | 0x8002);
+		ohci->max_packet_size = 512;
+#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
+		PRINT(KERN_DEBUG, "    EEPROM Present: %d",
+		      (reg_read(ohci, OHCI1394_Version) >> 24) & 0x1);
+		reg_write(ohci, OHCI1394_GUID_ROM, 0x80000000);
+
+		for (i = 0;
+		     ((i < 1000) &&
+		      (reg_read(ohci, OHCI1394_GUID_ROM) & 0x80000000)); i++)
+			udelay(10);
+
+		for (i = 0; i < 0x20; i++) {
+			reg_write(ohci, OHCI1394_GUID_ROM, 0x02000000);
+			PRINT(KERN_DEBUG, "    EEPROM %02x: %02x", i,
+			      (reg_read(ohci, OHCI1394_GUID_ROM) >> 16) & 0xff);
+		}
+#endif
+	}
 }
 
 /* 
@@ -807,45 +814,53 @@ static void insert_packet(struct ti_ohci
  *
  * The function MUST be called with the d->lock held.
  */ 
-static int dma_trm_flush(struct ti_ohci *ohci, struct dma_trm_ctx *d)
+static void dma_trm_flush(struct ti_ohci *ohci, struct dma_trm_ctx *d)
 {
-	struct hpsb_packet *p;
-	int idx,z;
+	struct hpsb_packet *packet, *ptmp;
+	int idx = d->prg_ind;
+	int z = 0;
 
-	if (list_empty(&d->pending_list) || d->free_prgs == 0)
-		return 0;
+	/* insert the packets into the dma fifo */
+	list_for_each_entry_safe(packet, ptmp, &d->pending_list, driver_list) {
+		if (!d->free_prgs)
+			break;
 
-	p = driver_packet(d->pending_list.next);
-	idx = d->prg_ind;
-	z = (p->data_size) ? 3 : 2;
+		/* For the first packet only */
+		if (!z)
+			z = (packet->data_size) ? 3 : 2;
 
-	/* insert the packets into the dma fifo */
-	while (d->free_prgs > 0 && !list_empty(&d->pending_list)) {
-		struct hpsb_packet *p = driver_packet(d->pending_list.next);
-		list_del(&p->driver_list);
-		insert_packet(ohci, d, p);
+		/* Insert the packet */
+		list_del_init(&packet->driver_list);
+		insert_packet(ohci, d, packet);
 	}
 
-	if (d->free_prgs == 0)
-		DBGMSG("Transmit DMA FIFO ctx=%d is full... waiting", d->ctx);
+	/* Nothing must have been done, either no free_prgs or no packets */
+	if (z == 0)
+		return;
 
 	/* Is the context running ? (should be unless it is 
 	   the first packet to be sent in this context) */
 	if (!(reg_read(ohci, d->ctrlSet) & 0x8000)) {
+		u32 nodeId = reg_read(ohci, OHCI1394_NodeID);
+
 		DBGMSG("Starting transmit DMA ctx=%d",d->ctx);
 		reg_write(ohci, d->cmdPtr, d->prg_bus[idx]|z);
-		run_context(ohci, d->ctrlSet, NULL);
-	}
-	else {
+
+		/* Check that the node id is valid, and not 63 */
+		if (!(nodeId & 0x80000000) || (nodeId & 0x3f) == 63)
+			PRINT(KERN_ERR, "Running dma failed because Node ID is not valid");
+		else
+			reg_write(ohci, d->ctrlSet, 0x8000);
+	} else {
 		/* Wake up the dma context if necessary */
-		if (!(reg_read(ohci, d->ctrlSet) & 0x400)) {
+		if (!(reg_read(ohci, d->ctrlSet) & 0x400))
 			DBGMSG("Waking transmit DMA ctx=%d",d->ctx);
-		}
 
 		/* do this always, to avoid race condition */
 		reg_write(ohci, d->ctrlSet, 0x1000);
 	}
-	return 1;
+
+	return;
 }
 
 /* Transmission of an async or iso packet */
@@ -2201,6 +2216,7 @@ static void dma_trm_reset(struct dma_trm
 	unsigned long flags;
 	LIST_HEAD(packet_list);
 	struct ti_ohci *ohci = d->ohci;
+	struct hpsb_packet *packet, *ptmp;
 
 	ohci1394_stop_context(ohci, d->ctrlClear, NULL);
 
@@ -2221,15 +2237,16 @@ static void dma_trm_reset(struct dma_trm
 
 	spin_unlock_irqrestore(&d->lock, flags);
 
-	/* Now process subsystem callbacks for the packets from the
-	 * context. */
+	if (list_empty(&packet_list))
+		return;
 
-	while (!list_empty(&packet_list)) {
-		struct hpsb_packet *p = driver_packet(packet_list.next);
-		PRINT(KERN_INFO,
-		      "AT dma reset ctx=%d, aborting transmission", d->ctx);
-		list_del(&p->driver_list);
-		hpsb_packet_sent(ohci->host, p, ACKX_ABORTED);
+	PRINT(KERN_INFO, "AT dma reset ctx=%d, aborting transmission", d->ctx);
+
+	/* Now process subsystem callbacks for the packets from this
+	 * context. */
+	list_for_each_entry_safe(packet, ptmp, &packet_list, driver_list) {
+		list_del_init(&packet->driver_list);
+		hpsb_packet_sent(ohci->host, packet, ACKX_ABORTED);
 	}
 }
 
@@ -2393,7 +2410,8 @@ static irqreturn_t ohci_irq_handler(int 
 			ohci1394_stop_context(ohci, d->ctrlClear,
 					      "reqTxComplete");
 		else
-			tasklet_schedule(&d->task);
+			dma_trm_tasklet((unsigned long)d);
+			//tasklet_schedule(&d->task);
 		event &= ~OHCI1394_reqTxComplete;
 	}
 	if (event & OHCI1394_respTxComplete) {
@@ -2713,15 +2731,14 @@ static void dma_trm_tasklet (unsigned lo
 {
 	struct dma_trm_ctx *d = (struct dma_trm_ctx*)data;
 	struct ti_ohci *ohci = (struct ti_ohci*)(d->ohci);
-	struct hpsb_packet *packet;
+	struct hpsb_packet *packet, *ptmp;
 	unsigned long flags;
 	u32 status, ack;
         size_t datasize;
 
 	spin_lock_irqsave(&d->lock, flags);
 
-	while (!list_empty(&d->fifo_list)) {
-		packet = driver_packet(d->fifo_list.next);
+	list_for_each_entry_safe(packet, ptmp, &d->fifo_list, driver_list) {
                 datasize = packet->data_size;
 		if (datasize && packet->type != hpsb_raw)
 			status = le32_to_cpu(
@@ -2818,7 +2835,7 @@ static void dma_trm_tasklet (unsigned lo
 			}
 		}
 
-                list_del(&packet->driver_list);
+		list_del_init(&packet->driver_list);
 		hpsb_packet_sent(ohci->host, packet, ack);
 
 		if (datasize) {
diff -purNbBw linux-2.6.5/drivers/ieee1394/pcilynx.c linux-2.6.5.ieee1394/drivers/ieee1394/pcilynx.c
--- linux-2.6.5/drivers/ieee1394/pcilynx.c	2004-04-04 03:36:56.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/pcilynx.c	2004-04-05 16:13:16.000000000 +0000
@@ -484,8 +484,7 @@ static void send_next(struct ti_lynx *ly
         }
 
         packet = driver_packet(d->queue.next);
-        list_del(&packet->driver_list);
-        list_add_tail(&packet->driver_list, &d->pcl_queue);
+	list_move_tail(&packet->driver_list, &d->pcl_queue);
 
         d->header_dma = pci_map_single(lynx->dev, packet->header,
                                        packet->header_size, PCI_DMA_TODEVICE);
@@ -500,11 +499,9 @@ static void send_next(struct ti_lynx *ly
         pcl.next = PCL_NEXT_INVALID;
         pcl.async_error_next = PCL_NEXT_INVALID;
         pcl.pcl_status = 0;
-#ifdef __BIG_ENDIAN
         pcl.buffer[0].control = packet->speed_code << 14 | packet->header_size;
-#else
-        pcl.buffer[0].control = packet->speed_code << 14 | packet->header_size 
-                | PCL_BIGENDIAN;
+#ifdef __BIG_ENDIAN
+        pcl.buffer[0].control |= PCL_BIGENDIAN;
 #endif
         pcl.buffer[0].pointer = d->header_dma;
         pcl.buffer[1].control = PCL_LAST_BUFF | packet->data_size;
@@ -767,7 +764,7 @@ static int lynx_devctl(struct hpsb_host 
                         get_pcl(lynx, lynx->async.pcl, &pcl);
 
                         packet = driver_packet(lynx->async.pcl_queue.next);
-                        list_del(&packet->driver_list);
+			list_del_init(&packet->driver_list);
 
                         pci_unmap_single(lynx->dev, lynx->async.header_dma,
                                          packet->header_size, PCI_DMA_TODEVICE);
@@ -795,7 +792,7 @@ static int lynx_devctl(struct hpsb_host 
 
 		while (!list_empty(&packet_list)) {
 			packet = driver_packet(packet_list.next);
-			list_del(&packet->driver_list);
+			list_del_init(&packet->driver_list);
 			hpsb_packet_sent(host, packet, ACKX_ABORTED);
 		}
 
@@ -1292,7 +1289,7 @@ static irqreturn_t lynx_irq_handler(int 
                         get_pcl(lynx, lynx->async.pcl, &pcl);
 
                         packet = driver_packet(lynx->async.pcl_queue.next);
-                        list_del(&packet->driver_list);
+                        list_del_init(&packet->driver_list);
 
                         pci_unmap_single(lynx->dev, lynx->async.header_dma,
                                          packet->header_size, PCI_DMA_TODEVICE);
@@ -1338,7 +1335,7 @@ static irqreturn_t lynx_irq_handler(int 
                         get_pcl(lynx, lynx->iso_send.pcl, &pcl);
 
                         packet = driver_packet(lynx->iso_send.pcl_queue.next);
-                        list_del(&packet->driver_list);
+                        list_del_init(&packet->driver_list);
 
                         pci_unmap_single(lynx->dev, lynx->iso_send.header_dma,
                                          packet->header_size, PCI_DMA_TODEVICE);
@@ -1460,7 +1457,7 @@ static void remove_card(struct pci_dev *
                 reg_write(lynx, PCI_INT_ENABLE, 0);
                 free_irq(lynx->dev->irq, lynx);
 
-		/* Disable IRM Contender */
+		/* Disable IRM Contender and LCtrl */
 		if (lynx->phyic.reg_1394a)
 			set_phy_reg(lynx, 4, ~0xc0 & get_phy_reg(lynx, 4));
 
@@ -1698,13 +1695,13 @@ static int __devinit add_card(struct pci
 
         pcl.next = PCL_NEXT_INVALID;
         pcl.async_error_next = PCL_NEXT_INVALID;
-#ifdef __BIG_ENDIAN
+
         pcl.buffer[0].control = PCL_CMD_RCV | 16;
-        pcl.buffer[1].control = PCL_LAST_BUFF | 4080;
-#else
-        pcl.buffer[0].control = PCL_CMD_RCV | PCL_BIGENDIAN | 16;
-        pcl.buffer[1].control = PCL_LAST_BUFF | 4080;
+#ifdef __BIG_ENDIAN
+	pcl.buffer[0].control |= PCL_BIGENDIAN;
 #endif
+	pcl.buffer[1].control = PCL_LAST_BUFF | 4080;
+
         pcl.buffer[0].pointer = lynx->rcv_page_dma;
         pcl.buffer[1].pointer = lynx->rcv_page_dma + 16;
         put_pcl(lynx, lynx->rcv_pcl, &pcl);
@@ -1788,12 +1785,12 @@ static int __devinit add_card(struct pci
                 reg_set_bits(lynx, GPIO_CTRL_A, 0x1);
                 reg_write(lynx, GPIO_DATA_BASE + 0x3c, 0x1); 
         } else {
-                /* set the contender bit in the extended PHY register
+                /* set the contender and LCtrl bit in the extended PHY register
                  * set. (Should check that bis 0,1,2 (=0xE0) is set
                  * in register 2?)
                  */
                 i = get_phy_reg(lynx, 4);
-                if (i != -1) set_phy_reg(lynx, 4, i | 0x40);
+                if (i != -1) set_phy_reg(lynx, 4, i | 0xc0);
         }
 
 
diff -purNbBw linux-2.6.5/drivers/ieee1394/raw1394.c linux-2.6.5.ieee1394/drivers/ieee1394/raw1394.c
--- linux-2.6.5/drivers/ieee1394/raw1394.c	2004-04-04 03:36:14.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/raw1394.c	2004-04-05 16:13:16.000000000 +0000
@@ -807,8 +807,7 @@ static int handle_async_send(struct file
         int expect_response = req->req.misc >> 16;
 
         if ((header_length > req->req.length) ||
-            (header_length  < 12))
-        {
+            (header_length  < 12)) {
                 req->req.error = RAW1394_ERROR_INVALID_ARG;
                 req->req.length = 0;
                 queue_complete_req(req);
@@ -2746,9 +2745,9 @@ static int __init init_raw1394(void)
 
 	cdev_init(&raw1394_cdev, &raw1394_fops);
 	raw1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&raw1394_cdev.kobj, RAW1394_DEVICE_NAME);
 	ret = cdev_add(&raw1394_cdev, IEEE1394_RAW1394_DEV, 1);
 	if (ret) {
-		/* jmc: leaves reference to (static) raw1394_cdev */
                 HPSB_ERR("raw1394 failed to register minor device block");
                 devfs_remove(RAW1394_DEVICE_NAME);
                 hpsb_unregister_highlevel(&raw1394_highlevel);
diff -purNbBw linux-2.6.5/drivers/ieee1394/sbp2.c linux-2.6.5.ieee1394/drivers/ieee1394/sbp2.c
--- linux-2.6.5/drivers/ieee1394/sbp2.c	2004-04-04 03:36:24.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/sbp2.c	2004-04-09 13:23:19.000000000 +0000
@@ -78,7 +78,7 @@
 #include "sbp2.h"
 
 static char version[] __devinitdata =
-	"$Rev: 1170 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1205 $ Ben Collins <bcollins@debian.org>";
 
 /*
  * Module load parameter definitions
@@ -658,7 +658,7 @@ static int sbp2_update(struct unit_direc
 		if (sbp2_login_device(scsi_id)) {
 			/* Login failed too, just fail, and the backend
 			 * will call our sbp2_remove for us */
-			SBP2_INFO("sbp2_reconnect_device failed!");
+			SBP2_ERR("Failed to reconnect to sbp2 device!");
 			return -EBUSY;
 		}
 	}
@@ -1314,6 +1313,7 @@ static int sbp2_logout_device(struct scs
 {
 	struct sbp2scsi_host_info *hi = scsi_id->hi;
 	quadlet_t data[2];
+	int error;
 
 	SBP2_DEBUG("sbp2_logout_device");
 
@@ -1354,10 +1354,15 @@ static int sbp2_logout_device(struct scs
 
 	atomic_set(&scsi_id->sbp2_login_complete, 0);
 
-	hpsb_node_write(scsi_id->ne, scsi_id->sbp2_management_agent_addr, data, 8);
+	error = hpsb_node_write(scsi_id->ne,
+	                            scsi_id->sbp2_management_agent_addr,
+	                            data, 8);
+	if (error)
+		return error;
 
 	/* Wait for device to logout...1 second. */
-	sbp2util_down_timeout(&scsi_id->sbp2_login_complete, HZ);
+	if (sbp2util_down_timeout(&scsi_id->sbp2_login_complete, HZ))
+		return -EIO;
 
 	SBP2_INFO("Logged out of SBP-2 device");
 
@@ -1373,6 +1378,7 @@ static int sbp2_reconnect_device(struct 
 {
 	struct sbp2scsi_host_info *hi = scsi_id->hi;
 	quadlet_t data[2];
+	int error;
 
 	SBP2_DEBUG("sbp2_reconnect_device");
 
@@ -1419,7 +1425,11 @@ static int sbp2_reconnect_device(struct 
 
 	atomic_set(&scsi_id->sbp2_login_complete, 0);
 
-	hpsb_node_write(scsi_id->ne, scsi_id->sbp2_management_agent_addr, data, 8);
+	error = hpsb_node_write(scsi_id->ne,
+	                            scsi_id->sbp2_management_agent_addr,
+	                            data, 8);
+	if (error)
+		return error;
 
 	/*
 	 * Wait for reconnect status (up to 1 second)...
@@ -1448,7 +1458,7 @@ static int sbp2_reconnect_device(struct 
 		return(-EIO);
 	}
 
-	SBP2_INFO("Reconnected to SBP-2 device");
+	HPSB_DEBUG("Reconnected to SBP-2 device");
 
 	return(0);
 
@@ -1638,7 +1648,7 @@ static int sbp2_max_speed_and_size(struc
 	scsi_id->max_payload_size = min(sbp2_speedto_max_payload[scsi_id->speed_code],
 					(u8)(hi->host->csr.max_rec - 1));
 
-	SBP2_ERR("Node " NODE_BUS_FMT ": Max speed [%s] - Max payload [%u]",
+	HPSB_DEBUG("Node " NODE_BUS_FMT ": Max speed [%s] - Max payload [%u]",
 		 NODE_BUS_ARGS(hi->host, scsi_id->ne->nodeid),
 		 hpsb_speedto_str[scsi_id->speed_code],
 		 1 << ((u32)scsi_id->max_payload_size + 2));
@@ -2278,7 +2288,6 @@ static void sbp2_check_sbp2_response(str
 				scsi_buf[2] = scsi_buf[3];	/* Device specific parameter */
 				scsi_buf[3] = scsi_buf[7];	/* Block descriptor length */
 				memcpy(scsi_buf + 4, scsi_buf + 8, scsi_buf[0]);
-	
 			}
 
 			break;
diff -purNbBw linux-2.6.5/drivers/ieee1394/video1394.c linux-2.6.5.ieee1394/drivers/ieee1394/video1394.c
--- linux-2.6.5/drivers/ieee1394/video1394.c	2004-04-04 03:36:25.000000000 +0000
+++ linux-2.6.5.ieee1394/drivers/ieee1394/video1394.c	2004-04-05 16:13:16.000000000 +0000
@@ -1438,7 +1438,7 @@ static void __exit video1394_exit_module
 	ret |= unregister_ioctl32_conversion(VIDEO1394_IOC32_TALK_WAIT_BUFFER);
 	ret |= unregister_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_POLL_BUFFER);
 	if (ret)
-		PRINT_G(KERN_INFO, "Error unregistering ioctl32 translations");
+		PRINT_G(KERN_CRIT, "Error unregistering ioctl32 translations");
 #endif
 
 	hpsb_unregister_protocol(&video1394_driver);
@@ -1457,6 +1457,7 @@ static int __init video1394_init_module 
 
 	cdev_init(&video1394_cdev, &video1394_fops);
 	video1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&video1394_cdev.kobj, VIDEO1394_DRIVER_NAME);
 	ret = cdev_add(&video1394_cdev, IEEE1394_VIDEO1394_DEV, 16);
 	if (ret) {
 		PRINT_G(KERN_ERR, "video1394: unable to get minor device block");
