Path: .
URL: svn://svn.linux1394.org/ieee1394/trunk
Repository UUID: 7adecdd0-3bb7-0310-ba7c-81b663e03c32
Revision: 1191
Node Kind: directory
Schedule: normal
Last Changed Author: bcollins
Last Changed Rev: 1191
Last Changed Date: 2004-03-14 23:19:06 +0100 (Sun, 14 Mar 2004)
Properties Last Updated: 2003-02-28 14:00:09 +0100 (Fri, 28 Feb 2003)

diff -purN linux-2.6.4/drivers/ieee1394/eth1394.c linux-2.6.4.ieee1394/drivers/ieee1394/eth1394.c
--- linux-2.6.4/drivers/ieee1394/eth1394.c	2004-02-29 13:40:56.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/eth1394.c	2004-03-14 01:25:59.000000000 +0000
@@ -89,7 +89,7 @@
 #define TRACE() printk(KERN_ERR "%s:%s[%d] ---- TRACE\n", driver_name, __FUNCTION__, __LINE__)
 
 static char version[] __devinitdata =
-	"$Rev: 1175 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1188 $ Ben Collins <bcollins@debian.org>";
 
 struct fragment_info {
 	struct list_head list;
@@ -1538,7 +1538,6 @@ static inline void ether1394_free_packet
 {
 	if (packet->tcode != TCODE_STREAM_DATA)
 		hpsb_free_tlabel(packet);
-	packet->data = NULL;
 	hpsb_free_packet(packet);
 }
 
@@ -1797,7 +1796,7 @@ static int ether1394_ethtool_ioctl(struc
 		case ETHTOOL_GDRVINFO: {
 			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
 			strcpy (info.driver, driver_name);
-			strcpy (info.version, "$Rev: 1175 $");
+			strcpy (info.version, "$Rev: 1188 $");
 			/* FIXME XXX provide sane businfo */
 			strcpy (info.bus_info, "ieee1394");
 			if (copy_to_user (useraddr, &info, sizeof (info)))
diff -purN linux-2.6.4/drivers/ieee1394/hosts.c linux-2.6.4.ieee1394/drivers/ieee1394/hosts.c
--- linux-2.6.4/drivers/ieee1394/hosts.c	2004-02-28 19:16:22.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/hosts.c	2004-03-13 14:23:01.000000000 +0000
@@ -126,9 +126,7 @@ struct hpsb_host *hpsb_alloc_host(struct
 	h->hostdata = h + 1;
         h->driver = drv;
 
-        INIT_LIST_HEAD(&h->pending_packets);
-        spin_lock_init(&h->pending_pkt_lock);
-
+	skb_queue_head_init(&h->pending_packet_queue);
 	INIT_LIST_HEAD(&h->addr_space);
 
 	init_timer(&h->delayed_reset);
diff -purN linux-2.6.4/drivers/ieee1394/hosts.h linux-2.6.4.ieee1394/drivers/ieee1394/hosts.h
--- linux-2.6.4/drivers/ieee1394/hosts.h	2004-02-28 19:16:23.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/hosts.h	2004-03-13 14:23:01.000000000 +0000
@@ -5,6 +5,8 @@
 #include <linux/wait.h>
 #include <linux/list.h>
 #include <linux/timer.h>
+#include <linux/skbuff.h>
+
 #include <asm/semaphore.h>
 
 #include "ieee1394_types.h"
@@ -21,8 +23,8 @@ struct hpsb_host {
 
         atomic_t generation;
 
-        struct list_head pending_packets;
-        spinlock_t pending_pkt_lock;
+	struct sk_buff_head pending_packet_queue;
+
 	struct timer_list timeout;
 	unsigned long timeout_interval;
 
diff -purN linux-2.6.4/drivers/ieee1394/ieee1394_core.c linux-2.6.4.ieee1394/drivers/ieee1394/ieee1394_core.c
--- linux-2.6.4/drivers/ieee1394/ieee1394_core.c	2004-02-29 14:30:15.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/ieee1394_core.c	2004-03-14 22:19:06.000000000 +0000
@@ -31,6 +31,8 @@
 #include <linux/moduleparam.h>
 #include <linux/bitops.h>
 #include <linux/kdev_t.h>
+#include <linux/skbuff.h>
+
 #include <asm/byteorder.h>
 #include <asm/semaphore.h>
 
@@ -56,8 +58,6 @@ MODULE_PARM_DESC(disable_nodemgr, "Disab
 /* We are GPL, so treat us special */
 MODULE_LICENSE("GPL");
 
-static kmem_cache_t *hpsb_packet_cache;
-
 /* Some globals used */
 const char *hpsb_speedto_str[] = { "S100", "S200", "S400", "S800", "S1600", "S3200" };
 
@@ -122,30 +122,28 @@ void hpsb_set_packet_complete_task(struc
 struct hpsb_packet *hpsb_alloc_packet(size_t data_size)
 {
 	struct hpsb_packet *packet = NULL;
-	void *data = NULL;
+	struct sk_buff *skb;
 	int gfp_flags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
 
-	packet = kmem_cache_alloc(hpsb_packet_cache, gfp_flags);
-	if (packet == NULL)
+	data_size = ((data_size + 3) & ~3);
+
+	skb = alloc_skb(data_size + sizeof(*packet), gfp_flags);
+	if (skb == NULL)
 		return NULL;
 
-	memset(packet, 0, sizeof(*packet));
+	memset(skb->data, 0, data_size + sizeof(*packet));
+
+	packet = (struct hpsb_packet *)skb->data;
+	packet->skb = skb;
 
 	packet->header = packet->embedded_header;
-	INIT_LIST_HEAD(&packet->list);
 	packet->state = hpsb_unused;
 	packet->generation = -1;
+	INIT_LIST_HEAD(&packet->driver_list);
 	atomic_set(&packet->refcnt, 1);
 
 	if (data_size) {
-		data_size = (data_size + 3) & ~3;
-		data = kmalloc(data_size + 8, gfp_flags);
-		if (data == NULL) {
-			kmem_cache_free(hpsb_packet_cache, packet);
-			return NULL;
-		}
-
-		packet->data = data;
+		packet->data = (quadlet_t *)(skb->data + sizeof(*packet));
 		packet->data_size = data_size;
 	}
 
@@ -162,8 +160,8 @@ struct hpsb_packet *hpsb_alloc_packet(si
 void hpsb_free_packet(struct hpsb_packet *packet)
 {
 	if (packet && atomic_dec_and_test(&packet->refcnt)) {
-		kfree(packet->data);
-		kmem_cache_free(hpsb_packet_cache, packet);
+		BUG_ON(!list_empty(&packet->driver_list));
+		kfree_skb(packet->skb);
 	}
 }
 
@@ -413,7 +411,7 @@ void hpsb_packet_sent(struct hpsb_host *
 
 	if (ackcode != ACK_PENDING || !packet->expect_response) {
 		atomic_dec(&packet->refcnt);
-		list_del(&packet->list);
+		skb_unlink(packet->skb);
 		packet->state = hpsb_complete;
 		queue_packet_complete(packet);
 		return;
@@ -505,13 +503,12 @@ int hpsb_send_packet(struct hpsb_packet 
 
         packet->state = hpsb_queued;
 
-	if (!packet->no_waiter || packet->expect_response) {
-		unsigned long flags;
+	/* This just seems silly to me */
+	WARN_ON(packet->no_waiter && packet->expect_response);
 
+	if (!packet->no_waiter || packet->expect_response) {
 		atomic_inc(&packet->refcnt);
-		spin_lock_irqsave(&host->pending_pkt_lock, flags);
-		list_add_tail(&packet->list, &host->pending_packets);
-		spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+		skb_queue_tail(&host->pending_packet_queue, packet->skb);
 	}
 
         if (packet->node_id == host->node_id)
@@ -547,6 +544,7 @@ int hpsb_send_packet(struct hpsb_packet 
                                        + NODEID_TO_NODE(packet->node_id)];
         }
 
+#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
         switch (packet->speed_code) {
         case 2:
                 dump_packet("send packet 400:", packet->header,
@@ -560,6 +558,7 @@ int hpsb_send_packet(struct hpsb_packet 
                 dump_packet("send packet 100:", packet->header,
                             packet->header_size);
         }
+#endif
 
         return host->driver->transmit_packet(host, packet);
 }
@@ -595,80 +594,78 @@ static void send_packet_nocare(struct hp
 }
 
 
-void handle_packet_response(struct hpsb_host *host, int tcode, quadlet_t *data,
-                            size_t size)
+static void handle_packet_response(struct hpsb_host *host, int tcode,
+				   quadlet_t *data, size_t size)
 {
         struct hpsb_packet *packet = NULL;
-        struct list_head *lh;
+	struct sk_buff *skb;
         int tcode_match = 0;
         int tlabel;
         unsigned long flags;
 
         tlabel = (data[0] >> 10) & 0x3f;
 
-        spin_lock_irqsave(&host->pending_pkt_lock, flags);
+	spin_lock_irqsave(&host->pending_packet_queue.lock, flags);
 
-        list_for_each(lh, &host->pending_packets) {
-                packet = list_entry(lh, struct hpsb_packet, list);
+	skb_queue_walk(&host->pending_packet_queue, skb) {
+		packet = (struct hpsb_packet *)skb->data;
                 if ((packet->tlabel == tlabel)
                     && (packet->node_id == (data[1] >> 16))){
                         break;
                 }
+
+		packet = NULL;
         }
 
-        if (lh == &host->pending_packets) {
+	if (packet == NULL) {
                 HPSB_DEBUG("unsolicited response packet received - no tlabel match");
                 dump_packet("contents:", data, 16);
-                spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+		spin_unlock_irqrestore(&host->pending_packet_queue.lock, flags);
                 return;
         }
 
         switch (packet->tcode) {
         case TCODE_WRITEQ:
         case TCODE_WRITEB:
-                if (tcode == TCODE_WRITE_RESPONSE) tcode_match = 1;
+                if (tcode != TCODE_WRITE_RESPONSE)
+			break;
+		tcode_match = 1;
+		memcpy(packet->header, data, 12);
                 break;
         case TCODE_READQ:
-                if (tcode == TCODE_READQ_RESPONSE) tcode_match = 1;
+                if (tcode != TCODE_READQ_RESPONSE)
+			break;
+		tcode_match = 1;
+		memcpy(packet->header, data, 16);
                 break;
         case TCODE_READB:
-                if (tcode == TCODE_READB_RESPONSE) tcode_match = 1;
+                if (tcode != TCODE_READB_RESPONSE)
+			break;
+		tcode_match = 1;
+		BUG_ON(packet->skb->len - sizeof(*packet) < size - 16);
+		memcpy(packet->header, data, 16);
+		memcpy(packet->data, data + 4, size - 16);
                 break;
         case TCODE_LOCK_REQUEST:
-                if (tcode == TCODE_LOCK_RESPONSE) tcode_match = 1;
+                if (tcode != TCODE_LOCK_RESPONSE)
+			break;
+		tcode_match = 1;
+		size = min((size - 16), (size_t)8);
+		BUG_ON(packet->skb->len - sizeof(*packet) < size);
+		memcpy(packet->header, data, 16);
+		memcpy(packet->data, data + 4, size);
                 break;
         }
 
-        if (!tcode_match || (packet->tlabel != tlabel)
-            || (packet->node_id != (data[1] >> 16))) {
+        if (!tcode_match) {
                 HPSB_INFO("unsolicited response packet received - tcode mismatch");
                 dump_packet("contents:", data, 16);
-
-                spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+		spin_unlock_irqrestore(&host->pending_packet_queue.lock, flags);
                 return;
         }
 
-        list_del(&packet->list);
-
-        spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
-
-        /* FIXME - update size fields? */
-        switch (tcode) {
-        case TCODE_WRITE_RESPONSE:
-                memcpy(packet->header, data, 12);
-                break;
-        case TCODE_READQ_RESPONSE:
-                memcpy(packet->header, data, 16);
-                break;
-        case TCODE_READB_RESPONSE:
-                memcpy(packet->header, data, 16);
-                memcpy(packet->data, data + 4, size - 16);
-                break;
-        case TCODE_LOCK_RESPONSE:
-                memcpy(packet->header, data, 16);
-                memcpy(packet->data, data + 4, (size - 16) > 8 ? 8 : size - 16);
-                break;
-        }
+	__skb_unlink(skb, skb->list);
+	spin_unlock_irqrestore(&host->pending_packet_queue.lock, flags);
 
 	if (packet->state == hpsb_queued) {
 		packet->sendtime = jiffies;
@@ -685,10 +682,8 @@ static struct hpsb_packet *create_reply_
 {
         struct hpsb_packet *p;
 
-        dsize += (dsize % 4 ? 4 - (dsize % 4) : 0);
-
         p = hpsb_alloc_packet(dsize);
-        if (p == NULL) {
+        if (unlikely(p == NULL)) {
                 /* FIXME - send data_error response */
                 return NULL;
         }
@@ -702,9 +697,8 @@ static struct hpsb_packet *create_reply_
 
 	p->generation = get_hpsb_generation(host);
 
-        if (dsize % 4) {
-                p->data[dsize / 4] = 0;
-        }
+	if (dsize % 4)
+		p->data[dsize / 4] = 0;
 
         return p;
 }
@@ -941,74 +935,75 @@ void hpsb_packet_received(struct hpsb_ho
 
 void abort_requests(struct hpsb_host *host)
 {
-        unsigned long flags;
-        struct hpsb_packet *packet, *packet_next;
-        LIST_HEAD(llist);
+	struct hpsb_packet *packet;
+	struct sk_buff *skb;
 
-        host->driver->devctl(host, CANCEL_REQUESTS, 0);
+	host->driver->devctl(host, CANCEL_REQUESTS, 0);
 
-        spin_lock_irqsave(&host->pending_pkt_lock, flags);
-        list_splice(&host->pending_packets, &llist);
-        INIT_LIST_HEAD(&host->pending_packets);
-        spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
-
-        list_for_each_entry_safe(packet, packet_next, &llist, list) {
-                list_del(&packet->list);
-                packet->state = hpsb_complete;
-                packet->ack_code = ACKX_ABORTED;
+	while ((skb = skb_dequeue(&host->pending_packet_queue)) != NULL) {
+		packet = (struct hpsb_packet *)skb->data;
+
+		packet->state = hpsb_complete;
+		packet->ack_code = ACKX_ABORTED;
 		queue_packet_complete(packet);
-        }
+	}
 }
 
 void abort_timedouts(unsigned long __opaque)
 {
 	struct hpsb_host *host = (struct hpsb_host *)__opaque;
-        unsigned long flags;
-        struct hpsb_packet *packet, *packet_next;
-        unsigned long expire;
-        LIST_HEAD(expiredlist);
+	unsigned long flags;
+	struct hpsb_packet *packet;
+	struct sk_buff *skb;
+	unsigned long expire;
 
-        spin_lock_irqsave(&host->csr.lock, flags);
+	spin_lock_irqsave(&host->csr.lock, flags);
 	expire = host->csr.expire;
-        spin_unlock_irqrestore(&host->csr.lock, flags);
-
-        spin_lock_irqsave(&host->pending_pkt_lock, flags);
+	spin_unlock_irqrestore(&host->csr.lock, flags);
 
-	list_for_each_entry_safe(packet, packet_next, &host->pending_packets, list) {
-                if (time_before(packet->sendtime + expire, jiffies)) {
-                        list_del(&packet->list);
-                        list_add(&packet->list, &expiredlist);
-                }
-        }
+	/* Hold the lock around this, since we aren't dequeuing all
+	 * packets, just ones we need. */
+	spin_lock_irqsave(&host->pending_packet_queue.lock, flags);
+
+	while (!skb_queue_empty(&host->pending_packet_queue)) {
+		skb = skb_peek(&host->pending_packet_queue);
+
+		packet = (struct hpsb_packet *)skb->data;
+
+		if (time_before(packet->sendtime + expire, jiffies)) {
+			__skb_unlink(skb, skb->list);
+			packet->state = hpsb_complete;
+			packet->ack_code = ACKX_TIMEOUT;
+			queue_packet_complete(packet);
+		} else {
+			/* Since packets are added to the tail, the oldest
+			 * ones are first, always. When we get to one that
+			 * isn't timed out, the rest aren't either. */
+			break;
+		}
+	}
 
-        if (!list_empty(&host->pending_packets))
+	if (!skb_queue_empty(&host->pending_packet_queue))
 		mod_timer(&host->timeout, jiffies + host->timeout_interval);
 
-        spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
-
-        list_for_each_entry_safe(packet, packet_next, &expiredlist, list) {
-                list_del(&packet->list);
-                packet->state = hpsb_complete;
-                packet->ack_code = ACKX_TIMEOUT;
-		queue_packet_complete(packet);
-        }
+	spin_unlock_irqrestore(&host->pending_packet_queue.lock, flags);
 }
 
+
+/* Kernel thread and vars, which handles packets that are completed. Only
+ * packets that have a "complete" function are sent here. This way, the
+ * completion is run out of kernel context, and doesn't block the rest of
+ * the stack. */
 static int khpsbpkt_pid = -1;
 static DECLARE_COMPLETION(khpsbpkt_complete);
-static LIST_HEAD(hpsbpkt_list);
+struct sk_buff_head hpsbpkt_queue;
 static DECLARE_MUTEX_LOCKED(khpsbpkt_sig);
-static spinlock_t khpsbpkt_lock = SPIN_LOCK_UNLOCKED;
 
 
 static void queue_packet_complete(struct hpsb_packet *packet)
 {
 	if (packet->complete_routine != NULL) {
-		unsigned long flags;
-
-		spin_lock_irqsave(&khpsbpkt_lock, flags);
-		list_add_tail(&packet->list, &hpsbpkt_list);
-		spin_unlock_irqrestore(&khpsbpkt_lock, flags);
+		skb_queue_tail(&hpsbpkt_queue, packet->skb);
 
 		/* Signal the kernel thread to handle this */
 		up(&khpsbpkt_sig);
@@ -1018,24 +1013,25 @@ static void queue_packet_complete(struct
 
 static int hpsbpkt_thread(void *__hi)
 {
-	struct hpsb_packet *packet, *next;
-	unsigned long flags;
+	struct sk_buff *skb;
+	struct hpsb_packet *packet;
+	void (*complete_routine)(void*);
+	void *complete_data;
 
 	daemonize("khpsbpkt");
 	allow_signal(SIGTERM);
 
 	while (!down_interruptible(&khpsbpkt_sig)) {
-		spin_lock_irqsave(&khpsbpkt_lock, flags);
-		list_for_each_entry_safe(packet, next, &hpsbpkt_list, list) {
-			void (*complete_routine)(void*) = packet->complete_routine;
-			void *complete_data = packet->complete_data;
+		while ((skb = skb_dequeue(&hpsbpkt_queue)) != NULL) {
+			packet = (struct hpsb_packet *)skb->data;
+
+			complete_routine = packet->complete_routine;
+			complete_data = packet->complete_data;
 
-			list_del(&packet->list);
 			packet->complete_routine = packet->complete_data = NULL;
 
 			complete_routine(complete_data);
 		}
-		spin_unlock_irqrestore(&khpsbpkt_lock, flags);
 	}
 
 	complete_and_exit(&khpsbpkt_complete, 0);
@@ -1046,6 +1042,8 @@ static int __init ieee1394_init(void)
 {
 	int i;
 
+	skb_queue_head_init(&hpsbpkt_queue);
+
 	if (hpsb_init_config_roms()) {
 		HPSB_ERR("Failed to initialize some config rom entries.\n");
 		HPSB_ERR("Some features may not be available\n");
@@ -1066,9 +1064,6 @@ static int __init ieee1394_init(void)
 
 	devfs_mk_dir("ieee1394");
 
-	hpsb_packet_cache = kmem_cache_create("hpsb_packet", sizeof(struct hpsb_packet),
-					      0, SLAB_HWCACHE_ALIGN, NULL, NULL);
-
 	bus_register(&ieee1394_bus_type);
 	for (i = 0; fw_bus_attrs[i]; i++)
 		bus_create_file(&ieee1394_bus_type, fw_bus_attrs[i]);
@@ -1104,8 +1099,6 @@ static void __exit ieee1394_cleanup(void
 		wait_for_completion(&khpsbpkt_complete);
 	}
 
-	kmem_cache_destroy(hpsb_packet_cache);
-
 	hpsb_cleanup_config_roms();
 
 	unregister_chrdev_region(IEEE1394_CORE_DEV, 256);
diff -purN linux-2.6.4/drivers/ieee1394/ieee1394_core.h linux-2.6.4.ieee1394/drivers/ieee1394/ieee1394_core.h
--- linux-2.6.4/drivers/ieee1394/ieee1394_core.h	2004-02-26 20:51:29.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/ieee1394_core.h	2004-03-14 22:19:06.000000000 +0000
@@ -12,9 +12,13 @@
 struct hpsb_packet {
         /* This struct is basically read-only for hosts with the exception of
          * the data buffer contents and xnext - see below. */
-        struct list_head list;
 
-        /* This can be used for host driver internal linking. */
+	/* This can be used for host driver internal linking.
+	 *
+	 * NOTE: This must be left in init state when the driver is done
+	 * with it (e.g. by using list_del_init()), since the core does
+	 * some sanity checks to make sure the packet is not on a
+	 * driver_list when free'ing it. */
 	struct list_head driver_list;
 
         nodeid_t node_id;
@@ -27,10 +31,9 @@ struct hpsb_packet {
          * queued   = queued for sending
          * pending  = sent, waiting for response
          * complete = processing completed, successful or not
-         * incoming = incoming packet
          */
         enum { 
-                hpsb_unused, hpsb_queued, hpsb_pending, hpsb_complete, hpsb_incoming 
+                hpsb_unused, hpsb_queued, hpsb_pending, hpsb_complete
         } __attribute__((packed)) state;
 
         /* These are core internal. */
@@ -67,6 +70,9 @@ struct hpsb_packet {
 	void (*complete_routine)(void *);
 	void *complete_data;
 
+	/* XXX This is just a hack at the moment */
+	struct sk_buff *skb;
+
         /* Store jiffies for implementing bus timeouts. */
         unsigned long sendtime;
 
diff -purN linux-2.6.4/drivers/ieee1394/ieee1394_transactions.c linux-2.6.4.ieee1394/drivers/ieee1394/ieee1394_transactions.c
--- linux-2.6.4/drivers/ieee1394/ieee1394_transactions.c	2004-02-28 02:27:01.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/ieee1394_transactions.c	2004-03-14 01:27:33.000000000 +0000
@@ -268,7 +268,7 @@ struct hpsb_packet *hpsb_make_readpacket
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet((length + 3) & ~3);
+	packet = hpsb_alloc_packet(length);
 	if (!packet)
 		return NULL;
 
@@ -296,7 +296,7 @@ struct hpsb_packet *hpsb_make_writepacke
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet((length + 3) & ~3);
+	packet = hpsb_alloc_packet(length);
 	if (!packet)
 		return NULL;
 
@@ -330,7 +330,7 @@ struct hpsb_packet *hpsb_make_streampack
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet((length + 3) & ~3);
+	packet = hpsb_alloc_packet(length);
 	if (!packet)
 		return NULL;
 
diff -purN linux-2.6.4/drivers/ieee1394/ohci1394.c linux-2.6.4.ieee1394/drivers/ieee1394/ohci1394.c
--- linux-2.6.4/drivers/ieee1394/ohci1394.c	2004-02-29 18:29:18.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/ohci1394.c	2004-03-14 22:19:06.000000000 +0000
@@ -162,7 +162,7 @@ printk(level "%s: " fmt "\n" , OHCI1394_
 printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, ohci->host->id , ## args)
 
 static char version[] __devinitdata =
-	"$Rev: 1172 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1191 $ Ben Collins <bcollins@debian.org>";
 
 /* Module Parameters */
 static int phys_dma = 1;
@@ -620,6 +620,39 @@ static void ohci_initialize(struct ti_oh
 		if (status & 0x20)
 			set_phy_reg(ohci, 8, status & ~1);
 	}
+
+        /* Serial EEPROM Sanity check. */
+        if ((ohci->max_packet_size < 512) ||
+	    (ohci->max_packet_size > 4096)) {
+		/* Serial EEPROM contents are suspect, set a sane max packet
+		 * size and print the raw contents for bug reports if verbose
+		 * debug is enabled. */
+#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
+		int i;
+#endif
+
+		PRINT(KERN_DEBUG, "Serial EEPROM has suspicious values, "
+                      "attempting to setting max_packet_size to 512 bytes");
+		reg_write(ohci, OHCI1394_BusOptions,
+			  (reg_read(ohci, OHCI1394_BusOptions) & 0xf007) | 0x8002);
+		ohci->max_packet_size = 512;
+#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
+		PRINT(KERN_DEBUG, "    EEPROM Present: %d",
+		      (reg_read(ohci, OHCI1394_Version) >> 24) & 0x1);
+		reg_write(ohci, OHCI1394_GUID_ROM, 0x80000000);
+
+		for (i = 0; 
+		     ((i < 1000) &&
+		      (reg_read(ohci, OHCI1394_GUID_ROM) & 0x80000000)); i++)
+			udelay(10);
+
+		for (i = 0; i < 0x20; i++) {
+			reg_write(ohci, OHCI1394_GUID_ROM, 0x02000000);
+			PRINT(KERN_DEBUG, "    EEPROM %02x: %02x", i,
+			      (reg_read(ohci, OHCI1394_GUID_ROM) >> 16) & 0xff);
+		}
+#endif
+	}
 }
 
 /* 
@@ -822,7 +855,7 @@ static int dma_trm_flush(struct ti_ohci 
 	/* insert the packets into the dma fifo */
 	while (d->free_prgs > 0 && !list_empty(&d->pending_list)) {
 		struct hpsb_packet *p = driver_packet(d->pending_list.next);
-		list_del(&p->driver_list);
+		list_del_init(&p->driver_list);
 		insert_packet(ohci, d, p);
 	}
 
@@ -2228,7 +2261,7 @@ static void dma_trm_reset(struct dma_trm
 		struct hpsb_packet *p = driver_packet(packet_list.next);
 		PRINT(KERN_INFO,
 		      "AT dma reset ctx=%d, aborting transmission", d->ctx);
-		list_del(&p->driver_list);
+		list_del_init(&p->driver_list);
 		hpsb_packet_sent(ohci->host, p, ACKX_ABORTED);
 	}
 }
@@ -2818,7 +2851,7 @@ static void dma_trm_tasklet (unsigned lo
 			}
 		}
 
-                list_del(&packet->driver_list);
+		list_del_init(&packet->driver_list);
 		hpsb_packet_sent(ohci->host, packet, ack);
 
 		if (datasize) {
diff -purN linux-2.6.4/drivers/ieee1394/pcilynx.c linux-2.6.4.ieee1394/drivers/ieee1394/pcilynx.c
--- linux-2.6.4/drivers/ieee1394/pcilynx.c	2004-02-28 19:16:26.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/pcilynx.c	2004-03-14 22:19:06.000000000 +0000
@@ -767,7 +767,7 @@ static int lynx_devctl(struct hpsb_host 
                         get_pcl(lynx, lynx->async.pcl, &pcl);
 
                         packet = driver_packet(lynx->async.pcl_queue.next);
-                        list_del(&packet->driver_list);
+			list_del_init(&packet->driver_list);
 
                         pci_unmap_single(lynx->dev, lynx->async.header_dma,
                                          packet->header_size, PCI_DMA_TODEVICE);
@@ -795,7 +795,7 @@ static int lynx_devctl(struct hpsb_host 
 
 		while (!list_empty(&packet_list)) {
 			packet = driver_packet(packet_list.next);
-			list_del(&packet->driver_list);
+			list_del_init(&packet->driver_list);
 			hpsb_packet_sent(host, packet, ACKX_ABORTED);
 		}
 
@@ -1292,7 +1292,7 @@ static irqreturn_t lynx_irq_handler(int 
                         get_pcl(lynx, lynx->async.pcl, &pcl);
 
                         packet = driver_packet(lynx->async.pcl_queue.next);
-                        list_del(&packet->driver_list);
+                        list_del_init(&packet->driver_list);
 
                         pci_unmap_single(lynx->dev, lynx->async.header_dma,
                                          packet->header_size, PCI_DMA_TODEVICE);
@@ -1338,7 +1338,7 @@ static irqreturn_t lynx_irq_handler(int 
                         get_pcl(lynx, lynx->iso_send.pcl, &pcl);
 
                         packet = driver_packet(lynx->iso_send.pcl_queue.next);
-                        list_del(&packet->driver_list);
+                        list_del_init(&packet->driver_list);
 
                         pci_unmap_single(lynx->dev, lynx->iso_send.header_dma,
                                          packet->header_size, PCI_DMA_TODEVICE);
@@ -1460,7 +1460,7 @@ static void remove_card(struct pci_dev *
                 reg_write(lynx, PCI_INT_ENABLE, 0);
                 free_irq(lynx->dev->irq, lynx);
 
-		/* Disable IRM Contender */
+		/* Disable IRM Contender and LCtrl */
 		if (lynx->phyic.reg_1394a)
 			set_phy_reg(lynx, 4, ~0xc0 & get_phy_reg(lynx, 4));
 
@@ -1788,12 +1788,12 @@ static int __devinit add_card(struct pci
                 reg_set_bits(lynx, GPIO_CTRL_A, 0x1);
                 reg_write(lynx, GPIO_DATA_BASE + 0x3c, 0x1); 
         } else {
-                /* set the contender bit in the extended PHY register
+                /* set the contender and LCtrl bit in the extended PHY register
                  * set. (Should check that bis 0,1,2 (=0xE0) is set
                  * in register 2?)
                  */
                 i = get_phy_reg(lynx, 4);
-                if (i != -1) set_phy_reg(lynx, 4, i | 0x40);
+                if (i != -1) set_phy_reg(lynx, 4, i | 0xc0);
         }
 
 
diff -purN linux-2.6.4/drivers/ieee1394/sbp2.c linux-2.6.4.ieee1394/drivers/ieee1394/sbp2.c
--- linux-2.6.4/drivers/ieee1394/sbp2.c	2004-02-29 13:40:56.000000000 +0000
+++ linux-2.6.4.ieee1394/drivers/ieee1394/sbp2.c	2004-03-11 21:04:34.000000000 +0000
@@ -78,7 +78,7 @@
 #include "sbp2.h"
 
 static char version[] __devinitdata =
-	"$Rev: 1170 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1183 $ Ben Collins <bcollins@debian.org>";
 
 /*
  * Module load parameter definitions
@@ -658,7 +658,7 @@ static int sbp2_update(struct unit_direc
 		if (sbp2_login_device(scsi_id)) {
 			/* Login failed too, just fail, and the backend
 			 * will call our sbp2_remove for us */
-			SBP2_INFO("sbp2_reconnect_device failed!");
+			SBP2_ERR("Failed to reconnect to sbp2 device!");
 			return -EBUSY;
 		}
 	}
@@ -1448,7 +1448,7 @@ static int sbp2_reconnect_device(struct 
 		return(-EIO);
 	}
 
-	SBP2_INFO("Reconnected to SBP-2 device");
+	HPSB_DEBUG("Reconnected to SBP-2 device");
 
 	return(0);
 
@@ -1638,10 +1638,10 @@ static int sbp2_max_speed_and_size(struc
 	scsi_id->max_payload_size = min(sbp2_speedto_max_payload[scsi_id->speed_code],
 					(u8)(hi->host->csr.max_rec - 1));
 
-	SBP2_ERR("Node " NODE_BUS_FMT ": Max speed [%s] - Max payload [%u]",
-		 NODE_BUS_ARGS(hi->host, scsi_id->ne->nodeid),
-		 hpsb_speedto_str[scsi_id->speed_code],
-		 1 << ((u32)scsi_id->max_payload_size + 2));
+	HPSB_DEBUG("Node " NODE_BUS_FMT ": Max speed [%s] - Max payload [%u]",
+		   NODE_BUS_ARGS(hi->host, scsi_id->ne->nodeid),
+		   hpsb_speedto_str[scsi_id->speed_code],
+		   1 << ((u32)scsi_id->max_payload_size + 2));
 
 	return(0);
 }
