diff -uNr linux-2.6.2/drivers/video/aty/atyfb_base.c linux-2.6.2.new/drivers/video/aty/atyfb_base.c
--- linux-2.6.2/drivers/video/aty/atyfb_base.c	2004-02-03 22:44:05.000000000 -0500
+++ linux-2.6.2.new/drivers/video/aty/atyfb_base.c	2004-02-13 15:33:15.000000000 -0500
@@ -189,6 +189,10 @@
 int atyfb_setup(char *);
 #endif
 
+#ifdef CONFIG_FB_ATY_XL_INIT
+extern int atyfb_xl_init(struct fb_info *info);
+#endif
+
 static struct fb_ops atyfb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_open	= atyfb_open,
@@ -214,6 +218,7 @@
 static u32 default_vram __initdata = 0;
 static int default_pll __initdata = 0;
 static int default_mclk __initdata = 0;
+static int default_xclk __initdata = 0;
 
 #ifndef MODULE
 static char *mode_option __initdata = NULL;
@@ -255,6 +260,8 @@
 static char m64n_gtc_ppl[] __initdata =
     "3D RAGE PRO (PQFP, PCI, limited 3D)";
 static char m64n_xl[] __initdata = "3D RAGE (XL)";
+static char m64n_xl_33[] __initdata = "3D RAGE (XL PCI-33MHz)";
+static char m64n_xl_66[] __initdata = "3D RAGE (XL PCI-66MHz)";
 static char m64n_ltp_a[] __initdata = "3D RAGE LT PRO (AGP)";
 static char m64n_ltp_p[] __initdata = "3D RAGE LT PRO (PCI)";
 static char m64n_mob_p[] __initdata = "3D RAGE Mobility (PCI)";
@@ -265,126 +272,132 @@
 	u16 pci_id, chip_type;
 	u8 rev_mask, rev_val;
 	const char *name;
-	int pll, mclk;
+	int pll, mclk, xclk;
 	u32 features;
 } aty_chips[] __initdata = {
 #ifdef CONFIG_FB_ATY_GX
 	/* Mach64 GX */
 	{
-	0x4758, 0x00d7, 0x00, 0x00, m64n_gx, 135, 50, M64F_GX}, {
-	0x4358, 0x0057, 0x00, 0x00, m64n_cx, 135, 50, M64F_GX},
+	0x4758, 0x00d7, 0x00, 0x00, m64n_gx, 135, 50, 50, M64F_GX}, {
+	0x4358, 0x0057, 0x00, 0x00, m64n_cx, 135, 50, 50, M64F_GX},
 #endif				/* CONFIG_FB_ATY_GX */
 #ifdef CONFIG_FB_ATY_CT
 	    /* Mach64 CT */
 	{
-	0x4354, 0x4354, 0x00, 0x00, m64n_ct, 135, 60,
+	0x4354, 0x4354, 0x00, 0x00, m64n_ct, 135, 60, 60,
 		    M64F_CT | M64F_INTEGRATED | M64F_CT_BUS |
 		    M64F_MAGIC_FIFO}, {
-	0x4554, 0x4554, 0x00, 0x00, m64n_et, 135, 60,
+	0x4554, 0x4554, 0x00, 0x00, m64n_et, 135, 60, 60, 
 		    M64F_CT | M64F_INTEGRATED | M64F_CT_BUS |
 		    M64F_MAGIC_FIFO},
 	    /* Mach64 VT */
 	{
-	0x5654, 0x5654, 0xc7, 0x00, m64n_vta3, 170, 67,
+	0x5654, 0x5654, 0xc7, 0x00, m64n_vta3, 170, 67, 67, 
 		    M64F_VT | M64F_INTEGRATED | M64F_VT_BUS |
 		    M64F_MAGIC_FIFO | M64F_FIFO_24}, {
-	0x5654, 0x5654, 0xc7, 0x40, m64n_vta4, 200, 67,
+	0x5654, 0x5654, 0xc7, 0x40, m64n_vta4, 200, 67, 67,
 		    M64F_VT | M64F_INTEGRATED | M64F_VT_BUS |
 		    M64F_MAGIC_FIFO | M64F_FIFO_24 | M64F_MAGIC_POSTDIV}, {
-	0x5654, 0x5654, 0x00, 0x00, m64n_vtb, 200, 67,
+	0x5654, 0x5654, 0x00, 0x00, m64n_vtb, 200, 67, 67, 
 		    M64F_VT | M64F_INTEGRATED | M64F_VT_BUS |
 		    M64F_GTB_DSP | M64F_FIFO_24}, {
-	0x5655, 0x5655, 0x00, 0x00, m64n_vtb, 200, 67,
+	0x5655, 0x5655, 0x00, 0x00, m64n_vtb, 200, 67, 67, 
 		    M64F_VT | M64F_INTEGRATED | M64F_VT_BUS |
 		    M64F_GTB_DSP | M64F_FIFO_24 | M64F_SDRAM_MAGIC_PLL}, {
-	0x5656, 0x5656, 0x00, 0x00, m64n_vt4, 230, 83,
+	0x5656, 0x5656, 0x00, 0x00, m64n_vt4, 230, 83, 83, 
 		    M64F_VT | M64F_INTEGRATED | M64F_GTB_DSP},
 	    /* Mach64 GT (3D RAGE) */
 	{
-	0x4754, 0x4754, 0x07, 0x00, m64n_gt, 135, 63,
+	0x4754, 0x4754, 0x07, 0x00, m64n_gt, 135, 63, 63,
 		    M64F_GT | M64F_INTEGRATED | M64F_MAGIC_FIFO |
 		    M64F_FIFO_24 | M64F_EXTRA_BRIGHT}, {
-	0x4754, 0x4754, 0x07, 0x01, m64n_gt, 170, 67,
+	0x4754, 0x4754, 0x07, 0x01, m64n_gt, 170, 67, 63, 
 		    M64F_GT | M64F_INTEGRATED | M64F_GTB_DSP |
 		    M64F_FIFO_24 | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT}, {
-	0x4754, 0x4754, 0x07, 0x02, m64n_gt, 200, 67,
+	0x4754, 0x4754, 0x07, 0x02, m64n_gt, 200, 67, 67,
 		    M64F_GT | M64F_INTEGRATED | M64F_GTB_DSP |
 		    M64F_FIFO_24 | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT}, {
-	0x4755, 0x4755, 0x00, 0x00, m64n_gtb, 200, 67,
+	0x4755, 0x4755, 0x00, 0x00, m64n_gtb, 200, 67, 67,
 		    M64F_GT | M64F_INTEGRATED | M64F_GTB_DSP |
 		    M64F_FIFO_24 | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT}, {
-	0x4756, 0x4756, 0x00, 0x00, m64n_iic_p, 230, 83,
+	0x4756, 0x4756, 0x00, 0x00, m64n_iic_p, 230, 83, 83,
 		    M64F_GT | M64F_INTEGRATED | M64F_GTB_DSP |
 		    M64F_FIFO_24 | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT}, {
-	0x4757, 0x4757, 0x00, 0x00, m64n_iic_a, 230, 83,
+	0x4757, 0x4757, 0x00, 0x00, m64n_iic_a, 230, 83, 83,
 		    M64F_GT | M64F_INTEGRATED | M64F_GTB_DSP |
 		    M64F_FIFO_24 | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT}, {
-	0x475a, 0x475a, 0x00, 0x00, m64n_iic_a, 230, 83,
+	0x475a, 0x475a, 0x00, 0x00, m64n_iic_a, 230, 83, 83,
 		    M64F_GT | M64F_INTEGRATED | M64F_GTB_DSP |
 		    M64F_FIFO_24 | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT},
 	    /* Mach64 LT */
 	{
-	0x4c54, 0x4c54, 0x00, 0x00, m64n_lt, 135, 63,
+	0x4c54, 0x4c54, 0x00, 0x00, m64n_lt, 135, 63, 63,
 		    M64F_GT | M64F_INTEGRATED | M64F_GTB_DSP}, {
-	0x4c47, 0x4c47, 0x00, 0x00, m64n_ltg, 230, 63,
+	0x4c47, 0x4c47, 0x00, 0x00, m64n_ltg, 230, 63, 63,
 		    M64F_GT | M64F_INTEGRATED | M64F_GTB_DSP |
 		    M64F_SDRAM_MAGIC_PLL | M64F_EXTRA_BRIGHT |
 		    M64F_LT_SLEEP | M64F_G3_PB_1024x768},
 	    /* Mach64 GTC (3D RAGE PRO) */
 	{
-	0x4742, 0x4742, 0x00, 0x00, m64n_gtc_ba, 230, 100,
+	0x4742, 0x4742, 0x00, 0x00, m64n_gtc_ba, 230, 100, 100,
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT}, {
-	0x4744, 0x4744, 0x00, 0x00, m64n_gtc_ba1, 230, 100,
+	0x4744, 0x4744, 0x00, 0x00, m64n_gtc_ba1, 230, 100, 100,
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT}, {
-	0x4749, 0x4749, 0x00, 0x00, m64n_gtc_bp, 230, 100,
+	0x4749, 0x4749, 0x00, 0x00, m64n_gtc_bp, 230, 100, 100,
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT | M64F_MAGIC_VRAM_SIZE}, {
-	0x4750, 0x4750, 0x00, 0x00, m64n_gtc_pp, 230, 100,
+	0x4750, 0x4750, 0x00, 0x00, m64n_gtc_pp, 230, 100, 100,
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT}, {
-	0x4751, 0x4751, 0x00, 0x00, m64n_gtc_ppl, 230, 100,
+	0x4751, 0x4751, 0x00, 0x00, m64n_gtc_ppl, 230, 100, 100,
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL |
 		    M64F_EXTRA_BRIGHT},
-	    /* 3D RAGE XL */
-	{
-	0x4752, 0x4752, 0x00, 0x00, m64n_xl, 230, 100,
-		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
-		    M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL |
-		    M64F_EXTRA_BRIGHT | M64F_XL_DLL},
+   /* 3D RAGE XL PCI-66/BGA */
+        { 
+	0x474f, 0x474f, 0x00, 0x00, m64n_xl_66, 230, 83, 63, 
+		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D | 
+		    M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL | 
+		    M64F_EXTRA_BRIGHT | M64F_XL_DLL | M64F_MFB_TIMES_4 },
+    /* 3D RAGE XL PCI-33/BGA */
+    	{ 0x4752, 0x4752, 0x00, 0x00, m64n_xl_33, 230, 83, 63, 
+		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D | 
+		    M64F_GTB_DSP | M64F_SDRAM_MAGIC_PLL | 
+		    M64F_EXTRA_BRIGHT | M64F_XL_DLL | M64F_MFB_TIMES_4 },
+
 	    /* Mach64 LT PRO */
 	{
-	0x4c42, 0x4c42, 0x00, 0x00, m64n_ltp_a, 230, 100,
+	0x4c42, 0x4c42, 0x00, 0x00, m64n_ltp_a, 230, 100, 100,
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP}, {
-	0x4c44, 0x4c44, 0x00, 0x00, m64n_ltp_p, 230, 100,
+	0x4c44, 0x4c44, 0x00, 0x00, m64n_ltp_p, 230, 100, 100,
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP}, {
-	0x4c49, 0x4c49, 0x00, 0x00, m64n_ltp_p, 230, 100,
+	0x4c49, 0x4c49, 0x00, 0x00, m64n_ltp_p, 230, 100, 100, 
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP | M64F_EXTRA_BRIGHT |
 		    M64F_G3_PB_1_1 | M64F_G3_PB_1024x768}, {
-	0x4c50, 0x4c50, 0x00, 0x00, m64n_ltp_p, 230, 100,
+	0x4c50, 0x4c50, 0x00, 0x00, m64n_ltp_p, 230, 100, 100, 
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP},
 	    /* 3D RAGE Mobility */
 	{
-	0x4c4d, 0x4c4d, 0x00, 0x00, m64n_mob_p, 230, 50,
+	0x4c4d, 0x4c4d, 0x00, 0x00, m64n_mob_p, 230, 50, 50, 
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP | M64F_MOBIL_BUS}, {
-	0x4c4e, 0x4c4e, 0x00, 0x00, m64n_mob_a, 230, 50,
+	0x4c4e, 0x4c4e, 0x00, 0x00, m64n_mob_a, 230, 50, 50, 
 		    M64F_GT | M64F_INTEGRATED | M64F_RESET_3D |
 		    M64F_GTB_DSP | M64F_MOBIL_BUS},
 #endif				/* CONFIG_FB_ATY_CT */
@@ -1003,7 +1016,10 @@
 	u32 ref_clk_per;
 	u8 pll_ref_div;
 	u8 mclk_fb_div;
+	u8 sclk_fb_div;
 	u8 mclk_post_div;	/* 1,2,3,4,8 */
+	u8 mclk_fb_mult;        /* 2 or 4 */
+	u8 xclk_post_div;       /* 1,2,3,4,8 */
 	u8 vclk_fb_div;
 	u8 vclk_post_div;	/* 1,2,3,4,6,8,12 */
 	u32 dsp_xclks_per_row;	/* 0-16383 */
@@ -1051,14 +1067,17 @@
 			clk.ref_clk_per = par->ref_clk_per;
 			clk.pll_ref_div = pll->ct.pll_ref_div;
 			clk.mclk_fb_div = pll->ct.mclk_fb_div;
+			clk.sclk_fb_div = pll->ct.sclk_fb_div;
 			clk.mclk_post_div = pll->ct.mclk_post_div_real;
+			clk.mclk_fb_mult = pll->ct.mclk_fb_mult;
+		    	clk.xclk_post_div = pll->ct.xclk_post_div_real;
 			clk.vclk_fb_div = pll->ct.vclk_fb_div;
 			clk.vclk_post_div = pll->ct.vclk_post_div_real;
 			clk.dsp_xclks_per_row = dsp_config & 0x3fff;
 			clk.dsp_loop_latency = (dsp_config >> 16) & 0xf;
 			clk.dsp_precision = (dsp_config >> 20) & 7;
-			clk.dsp_on = dsp_on_off & 0x7ff;
-			clk.dsp_off = (dsp_on_off >> 16) & 0x7ff;
+			clk.dsp_off = dsp_on_off & 0x7ff;
+			clk.dsp_on = (dsp_on_off >> 16) & 0x7ff;
 			if (copy_to_user
 			    ((struct atyclk *) arg, &clk, sizeof(clk)))
 				return -EFAULT;
@@ -1075,7 +1094,10 @@
 			par->ref_clk_per = clk.ref_clk_per;
 			pll->ct.pll_ref_div = clk.pll_ref_div;
 			pll->ct.mclk_fb_div = clk.mclk_fb_div;
+			pll->ct.sclk_fb_div = clk.sclk_fb_div;
 			pll->ct.mclk_post_div_real = clk.mclk_post_div;
+			pll->ct.mclk_fb_mult = clk.mclk_fb_mult;
+			pll->ct.xclk_post_div_real = clk.xclk_post_div;
 			pll->ct.vclk_fb_div = clk.vclk_fb_div;
 			pll->ct.vclk_post_div_real = clk.vclk_post_div;
 			pll->ct.dsp_config =
@@ -1086,8 +1108,8 @@
 			    | ((clk.dsp_precision & 7) << 20);
 			pll->ct.dsp_on_off =
 			    (clk.
-			     dsp_on & 0x7ff) | ((clk.
-						 dsp_off & 0x7ff) << 16);
+			     dsp_off & 0x7ff) | ((clk.
+						 dsp_on & 0x7ff) << 16);
 			aty_calc_pll_ct(info, &pll->ct);
 			aty_set_pll_ct(info, pll);
 		} else
@@ -1127,6 +1149,7 @@
 	unsigned long off;
 	int i;
 
+	printk("aty_mmap\n");
 	if (!par->mmap_map)
 		return -ENXIO;
 
@@ -1174,9 +1197,15 @@
 		    ~(par->mmap_map[i].prot_mask);
 		pgprot_val(vma->vm_page_prot) |= par->mmap_map[i].prot_flag;
 
+		printk("calling remap_page_range: start %x offset %x\n",
+				vma->vm_start + page, map_offset);
+
 		if (remap_page_range(vma, vma->vm_start + page, map_offset,
-				     map_size, vma->vm_page_prot))
+				     map_size, vma->vm_page_prot)) {
+			printk("remap failed\n");
 			return -EAGAIN;
+		}
+		printk("remap done\n");
 
 		page += map_size;
 	}
@@ -1495,6 +1524,36 @@
 #endif				/* CONFIG_PMAC_BACKLIGHT */
 
 
+static void __init aty_calc_mem_refresh(struct atyfb_par *par,
+                                        u16 id,
+                                        int xclk)
+{
+        int i, size;
+        const int ragepro_tbl[] = {
+                44, 50, 55, 66, 75, 80, 100
+        };
+        const int ragexl_tbl[] = {
+                50, 66, 75, 83, 90, 95, 100, 105,
+                110, 115, 120, 125, 133, 143, 166
+        };
+        const int *refresh_tbl;
+
+        if (IS_XL(id)) {
+                refresh_tbl = ragexl_tbl;
+                size = sizeof(ragexl_tbl)/sizeof(int);
+        } else {
+                refresh_tbl = ragepro_tbl;
+                size = sizeof(ragepro_tbl)/sizeof(int);
+        }
+
+        for (i=0; i < size; i++) {
+                if (xclk < refresh_tbl[i])
+                        break;
+        }
+        
+        par->mem_refresh_rate = i;
+}
+
 
     /*
      *  Initialisation
@@ -1506,7 +1565,7 @@
 {
 	struct atyfb_par *par = (struct atyfb_par *) info->par;
 	const char *chipname = NULL, *ramname = NULL, *xtal;
-	int j, pll, mclk, gtb_memsize;
+	int j, pll, mclk, xclk, gtb_memsize;
 	struct fb_var_screeninfo var;
 	u32 chip_id, i;
 	u16 type;
@@ -1528,6 +1587,7 @@
 			chipname = aty_chips[j].name;
 			pll = aty_chips[j].pll;
 			mclk = aty_chips[j].mclk;
+			xclk = aty_chips[j].xclk;
 			par->features = aty_chips[j].features;
 			goto found;
 		}
@@ -1602,13 +1662,32 @@
 		}
 	}
 #endif				/* CONFIG_FB_ATY_GX */
+
+
+    if (default_pll)
+        pll = default_pll;
+    if (default_mclk)
+        mclk = default_mclk;
+    if (default_xclk)
+        xclk = default_xclk;
+
+    aty_calc_mem_refresh(par, type, xclk);
+    par->pll_per = 1000000/pll;
+    par->mclk_per = 1000000/mclk;
+    par->xclk_per = 1000000/xclk;
+
 #ifdef CONFIG_FB_ATY_CT
+
 	if (M64_HAS(INTEGRATED)) {
+                par->dac_ops = &aty_dac_ct;
+                par->pll_ops = &aty_pll_ct;
 		par->bus_type = PCI;
+#ifdef CONFIG_FB_ATY_XL_INIT
+        	if (IS_XL(type))
+	                atyfb_xl_init(info);
+#endif  
 		par->ram_type = (aty_ld_le32(CONFIG_STAT0, par) & 0x07);
 		ramname = aty_ct_ram[par->ram_type];
-		par->dac_ops = &aty_dac_ct;
-		par->pll_ops = &aty_pll_ct;
 		/* for many chips, the mclk is 67 MHz for SDRAM, 63 MHz otherwise */
 		if (mclk == 67 && par->ram_type < SDRAM)
 			mclk = 63;
@@ -1724,35 +1803,12 @@
 		info->fix.accel = FB_ACCEL_ATI_MACH64GT;
 	}
 
-	if (default_pll)
-		pll = default_pll;
-	if (default_mclk)
-		mclk = default_mclk;
-
-	printk("%d%c %s, %s MHz XTAL, %d MHz PLL, %d Mhz MCLK\n",
-	       info->fix.smem_len ==
-	       0x80000 ? 512 : (info->fix.smem_len >> 20),
+
+	printk("%d%c %s, %s MHz XTAL, %d MHz PLL, %d Mhz MCLK, %d Mhz XCLK\n",
+	       info->fix.smem_len == 0x80000 ? 512 : (info->fix.smem_len >> 20),
 	       info->fix.smem_len == 0x80000 ? 'K' : 'M', ramname,
-	       xtal, pll, mclk);
+	       xtal, pll, mclk, xclk);
 
-	if (mclk < 44)
-		par->mem_refresh_rate = 0;	/* 000 = 10 Mhz - 43 Mhz */
-	else if (mclk < 50)
-		par->mem_refresh_rate = 1;	/* 001 = 44 Mhz - 49 Mhz */
-	else if (mclk < 55)
-		par->mem_refresh_rate = 2;	/* 010 = 50 Mhz - 54 Mhz */
-	else if (mclk < 66)
-		par->mem_refresh_rate = 3;	/* 011 = 55 Mhz - 65 Mhz */
-	else if (mclk < 75)
-		par->mem_refresh_rate = 4;	/* 100 = 66 Mhz - 74 Mhz */
-	else if (mclk < 80)
-		par->mem_refresh_rate = 5;	/* 101 = 75 Mhz - 79 Mhz */
-	else if (mclk < 100)
-		par->mem_refresh_rate = 6;	/* 110 = 80 Mhz - 100 Mhz */
-	else
-		par->mem_refresh_rate = 7;	/* 111 = 100 Mhz and above */
-	par->pll_per = 1000000 / pll;
-	par->mclk_per = 1000000 / mclk;
 
 #ifdef DEBUG
 	if (M64_HAS(INTEGRATED)) {
@@ -2078,7 +2134,7 @@
 				j++;
 			}
 
-			if (pdev->device != XL_CHIP_ID) {
+			if (!IS_XL(pdev->device)) {
 				/*
 				 * Fix PROMs idea of MEM_CNTL settings...
 				 */
@@ -2204,7 +2260,7 @@
 				 *
 				 * where R is XTALIN (= 14318 or 29498 kHz).
 				 */
-				if (pdev->device == XL_CHIP_ID)
+				if (!IS_XL(pdev->device)) 
 					R = 29498;
 				else
 					R = 14318;
@@ -2391,6 +2447,9 @@
 		else if (!strncmp(this_opt, "mclk:", 5))
 			default_mclk =
 			    simple_strtoul(this_opt + 5, NULL, 0);
+		else if (!strncmp(this_opt, "xclk:", 5))
+			default_xclk = 
+			    simple_strtoul(this_opt+5, NULL, 0);
 #ifdef CONFIG_PPC
 		else if (!strncmp(this_opt, "vmode:", 6)) {
 			unsigned int vmode =
diff -uNr linux-2.6.2/drivers/video/aty/atyfb.h linux-2.6.2.new/drivers/video/aty/atyfb.h
--- linux-2.6.2/drivers/video/aty/atyfb.h	2004-02-03 22:44:04.000000000 -0500
+++ linux-2.6.2.new/drivers/video/aty/atyfb.h	2004-02-13 15:29:01.000000000 -0500
@@ -36,13 +36,17 @@
 	u8 pll_ref_div;
 	u8 pll_gen_cntl;
 	u8 mclk_fb_div;
+        u8 mclk_fb_mult;    /* 2 or 4 */
+	u8 sclk_fb_div;
 	u8 pll_vclk_cntl;
 	u8 vclk_post_div;
 	u8 vclk_fb_div;
 	u8 pll_ext_cntl;
+        u8 spll_cntl2;
 	u32 dsp_config;		/* Mach64 GTB DSP */
 	u32 dsp_on_off;		/* Mach64 GTB DSP */
 	u8 mclk_post_div_real;
+	u8 xclk_post_div_real;
 	u8 vclk_post_div_real;
 };
 
@@ -75,6 +79,7 @@
 	u32 ref_clk_per;
 	u32 pll_per;
 	u32 mclk_per;
+        u32 xclk_per;
 	u8 bus_type;
 	u8 ram_type;
 	u8 mem_refresh_rate;
@@ -118,6 +123,7 @@
 #define M64F_EXTRA_BRIGHT	0x00020000
 #define M64F_LT_SLEEP		0x00040000
 #define M64F_XL_DLL		0x00080000
+#define M64F_MFB_TIMES_4        0x00100000
 
 
     /*
@@ -150,6 +156,33 @@
 	writel(val, par->ati_regbase + regindex);
 #endif
 }
+static inline u16 aty_ld_le16(int regindex,
+			      const struct atyfb_par *par)
+{
+    /* Hack for bloc 1, should be cleanly optimized by compiler */
+    if (regindex >= 0x400)
+    	regindex -= 0x800;
+
+#if defined(__mc68000__)
+    return le16_to_cpu(*((volatile u16 *)(par->ati_regbase+regindex)));
+#else
+    return readw (par->ati_regbase + regindex);
+#endif
+}
+
+static inline void aty_st_le16(int regindex, u16 val,
+                               const struct atyfb_par *par)
+{
+    /* Hack for bloc 1, should be cleanly optimized by compiler */
+    if (regindex >= 0x400)
+        regindex -= 0x800;
+
+#if defined(__mc68000__)
+    *((volatile u16 *)(par->ati_regbase+regindex)) = cpu_to_le16(val);
+#else
+    writew (val, par->ati_regbase + regindex);
+#endif
+}
 
 static inline u8 aty_ld_8(int regindex, const struct atyfb_par *par)
 {
@@ -188,6 +221,19 @@
 	return res;
 }
 
+/*
+ * CT family only.
+ */
+static inline void aty_st_pll(int offset, u8 val,
+                              const struct atyfb_par *par)
+{
+    /* write addr byte */
+    aty_st_8(CLOCK_CNTL + 1, (offset << 2) | PLL_WR_EN, par);
+    /* write the register value */
+    aty_st_8(CLOCK_CNTL + 2, val, par);
+    aty_st_8(CLOCK_CNTL + 1, (offset << 2) & ~PLL_WR_EN, par);
+}
+
 
     /*
      *  DAC operations
diff -uNr linux-2.6.2/drivers/video/aty/mach64_ct.c linux-2.6.2.new/drivers/video/aty/mach64_ct.c
--- linux-2.6.2/drivers/video/aty/mach64_ct.c	2004-02-03 22:43:04.000000000 -0500
+++ linux-2.6.2.new/drivers/video/aty/mach64_ct.c	2004-02-13 15:37:51.000000000 -0500
@@ -4,20 +4,22 @@
  */
 
 #include <linux/fb.h>
+#include <linux/delay.h>
 
 #include <asm/io.h>
 
 #include <video/mach64.h>
 #include "atyfb.h"
 
+#undef DEBUG
+
 
 /* FIXME: remove the FAIL definition */
 #define FAIL(x) do { printk(x "\n"); return -EINVAL; } while (0)
 
-static void aty_st_pll(int offset, u8 val, const struct atyfb_par *par);
 static int aty_valid_pll_ct(const struct fb_info *info, u32 vclk_per,
 			    struct pll_ct *pll);
-static int aty_dsp_gt(const struct fb_info *info, u8 bpp,
+static int aty_dsp_gt(const struct fb_info *info, u32 bpp,
 		      struct pll_ct *pll);
 static int aty_var_to_pll_ct(const struct fb_info *info, u32 vclk_per,
 			     u8 bpp, union aty_pll *pll);
@@ -25,37 +27,34 @@
 			     const union aty_pll *pll);
 
 
-
-static void aty_st_pll(int offset, u8 val, const struct atyfb_par *par)
-{
-	/* write addr byte */
-	aty_st_8(CLOCK_CNTL + 1, (offset << 2) | PLL_WR_EN, par);
-	/* write the register value */
-	aty_st_8(CLOCK_CNTL + 2, val, par);
-	aty_st_8(CLOCK_CNTL + 1, (offset << 2) & ~PLL_WR_EN, par);
-}
-
-
 /* ------------------------------------------------------------------------- */
 
     /*
      *  PLL programming (Mach64 CT family)
      */
 
-static int aty_dsp_gt(const struct fb_info *info, u8 bpp,
+static int aty_dsp_gt(const struct fb_info *info, u32 bpp,
 		      struct pll_ct *pll)
 {
 	struct atyfb_par *par = (struct atyfb_par *) info->par;
 	u32 dsp_xclks_per_row, dsp_loop_latency, dsp_precision, dsp_off,
 	    dsp_on;
-	u32 xclks_per_row, fifo_off, fifo_on, y, fifo_size, page_size;
+	u32 xclks_per_row, fifo_off, fifo_on, y, fifo_size;
+	u32 memcntl, n, t_pfc, t_rp, t_ras, t_rcd, t_crd, t_rcc, t_lat;
+
+#ifdef DEBUG
+	printk(__FUNCTION__ ": mclk_fb_mult=%d\n", pll->mclk_fb_mult);
+#endif
+    
+	/* (64*xclk/vclk/bpp)<<11 = xclocks_per_row<<11 */
+	xclks_per_row = ((u32)pll->mclk_fb_mult * (u32)pll->mclk_fb_div *
+		     (u32)pll->vclk_post_div_real * 64) << 11;
+	xclks_per_row /=
+	    (2 * (u32)pll->vclk_fb_div * (u32)pll->xclk_post_div_real * bpp);
+
 
-	/* xclocks_per_row<<11 */
-	xclks_per_row =
-	    (pll->mclk_fb_div * pll->vclk_post_div_real * 64 << 11) /
-	    (pll->vclk_fb_div * pll->mclk_post_div_real * bpp);
 	if (xclks_per_row < (1 << 11))
-		FAIL("Dotclock to high");
+		FAIL("Dotclock too high");
 	if (M64_HAS(FIFO_24)) {
 		fifo_size = 24;
 		dsp_loop_latency = 0;
@@ -71,35 +70,56 @@
 	}
 	dsp_precision -= 5;
 	/* fifo_off<<6 */
-	fifo_off = ((xclks_per_row * (fifo_size - 1)) >> 5) + (3 << 6);
+	fifo_off = ((xclks_per_row * (fifo_size - 1)) >> 5);// + (3 << 6);
 
 	if (info->fix.smem_len > 1 * 1024 * 1024) {
-		if (par->ram_type >= SDRAM) {
+		switch (par->ram_type) {
+			case WRAM:
+	    		/* >1 MB WRAM */
+	    		dsp_loop_latency += 9;
+	    		n = 4;
+	    		break;
+			case SDRAM:
+			case SGRAM:
 			/* >1 MB SDRAM */
 			dsp_loop_latency += 8;
-			page_size = 8;
-		} else {
+	    		n = 2;
+	    		break;
+			default:
+
 			/* >1 MB DRAM */
 			dsp_loop_latency += 6;
-			page_size = 9;
+	    		n = 3;
+	    		break;
+
 		}
 	} else {
 		if (par->ram_type >= SDRAM) {
 			/* <2 MB SDRAM */
 			dsp_loop_latency += 9;
-			page_size = 10;
+	   		 n = 2;
 		} else {
 			/* <2 MB DRAM */
 			dsp_loop_latency += 8;
-			page_size = 10;
+	    		n = 3;
 		}
 	}
+
+    	memcntl = aty_ld_le32(MEM_CNTL, par);
+    	t_rcd = ((memcntl >> 10) & 0x03) + 1;
+    	t_crd = ((memcntl >> 12) & 0x01);
+    	t_rp  = ((memcntl >>  8) & 0x03) + 1;
+    	t_ras = ((memcntl >> 16) & 0x07) + 1;
+    	t_lat =  (memcntl >>  4) & 0x03;
+    
+    	t_pfc = t_rp + t_rcd + t_crd;
+    
+    	t_rcc = max(t_rp + t_ras, t_pfc + n);
+    
+
 	/* fifo_on<<6 */
-	if (xclks_per_row >= (page_size << 11))
-		fifo_on =
-		    ((2 * page_size + 1) << 6) + (xclks_per_row >> 5);
-	else
-		fifo_on = (3 * page_size + 2) << 6;
+
+    	fifo_on = (2 * t_rcc + t_pfc + n - 1) << 6;
 
 	dsp_xclks_per_row = xclks_per_row >> dsp_precision;
 	dsp_on = fifo_on >> dsp_precision;
@@ -107,13 +127,17 @@
 
 	pll->dsp_config = (dsp_xclks_per_row & 0x3fff) |
 	    ((dsp_loop_latency & 0xf) << 16) | ((dsp_precision & 7) << 20);
-	pll->dsp_on_off = (dsp_on & 0x7ff) | ((dsp_off & 0x7ff) << 16);
+	pll->dsp_on_off = (dsp_off & 0x7ff) | ((dsp_on & 0x7ff) << 16);
 	return 0;
 }
 
 static int aty_valid_pll_ct(const struct fb_info *info, u32 vclk_per,
 			    struct pll_ct *pll)
 {
+#ifdef DEBUG
+    int pllmclk, pllsclk;
+#endif
+
 	struct atyfb_par *par = (struct atyfb_par *) info->par;
 	u32 q, x;		/* x is a workaround for sparc64-linux-gcc */
 	x = x;			/* x is a workaround for sparc64-linux-gcc */
@@ -121,7 +145,10 @@
 	pll->pll_ref_div = par->pll_per * 2 * 255 / par->ref_clk_per;
 
 	/* FIXME: use the VTB/GTB /3 post divider if it's better suited */
-	q = par->ref_clk_per * pll->pll_ref_div * 4 / par->mclk_per;	/* actually 8*q */
+
+	/* actually 8*q */
+	q = par->ref_clk_per*pll->pll_ref_div*4/par->mclk_per;
+
 	if (q < 16 * 8 || q > 255 * 8)
 		FAIL("mclk out of range");
 	else if (q < 32 * 8)
@@ -132,7 +159,40 @@
 		pll->mclk_post_div_real = 2;
 	else
 		pll->mclk_post_div_real = 1;
-	pll->mclk_fb_div = q * pll->mclk_post_div_real / 8;
+    pll->sclk_fb_div = q*pll->mclk_post_div_real/8;
+    
+#ifdef DEBUG
+    pllsclk = (1000000 * 2 * pll->sclk_fb_div) /
+	    (par->ref_clk_per * pll->pll_ref_div);
+    printk(__FUNCTION__ ": pllsclk=%d MHz, mclk=%d MHz\n",
+	   pllsclk, pllsclk / pll->mclk_post_div_real);
+#endif
+    
+    pll->mclk_fb_mult = M64_HAS(MFB_TIMES_4) ? 4 : 2;
+
+    /* actually 8*q */
+    q = par->ref_clk_per * pll->pll_ref_div * 8 /
+	    (pll->mclk_fb_mult * par->xclk_per);
+
+    if (q < 16*8 || q > 255*8)
+	FAIL("mclk out of range");
+    else if (q < 32*8)
+	pll->xclk_post_div_real = 8;
+    else if (q < 64*8)
+	pll->xclk_post_div_real = 4;
+    else if (q < 128*8)
+	pll->xclk_post_div_real = 2;
+    else
+	pll->xclk_post_div_real = 1;
+    pll->mclk_fb_div = q*pll->xclk_post_div_real/8;
+    
+#ifdef DEBUG
+    pllmclk = (1000000 * pll->mclk_fb_mult * pll->mclk_fb_div) /
+	    (info->ref_clk_per * pll->pll_ref_div);
+    printk(__FUNCTION__ ": pllmclk=%d MHz, xclk=%d MHz\n",
+	   pllmclk, pllmclk / pll->xclk_post_div_real);
+#endif
+    
 
 	/* FIXME: use the VTB/GTB /{3,6,12} post dividers if they're better suited */
 	q = par->ref_clk_per * pll->pll_ref_div * 4 / vclk_per;	/* actually 8*q */
@@ -153,13 +213,14 @@
 void aty_calc_pll_ct(const struct fb_info *info, struct pll_ct *pll)
 {
 	struct atyfb_par *par = (struct atyfb_par *) info->par;
+	u8 xpostdiv = 0;
 	u8 mpostdiv = 0;
 	u8 vpostdiv = 0;
 
 	if (M64_HAS(SDRAM_MAGIC_PLL) && (par->ram_type >= SDRAM))
-		pll->pll_gen_cntl = 0x04;
+	    	pll->pll_gen_cntl = 0x64; /* mclk = sclk */
 	else
-		pll->pll_gen_cntl = 0x84;
+		pll->pll_gen_cntl = 0xe4; /* mclk = sclk */
 
 	switch (pll->mclk_post_div_real) {
 	case 1:
@@ -168,9 +229,6 @@
 	case 2:
 		mpostdiv = 1;
 		break;
-	case 3:
-		mpostdiv = 4;
-		break;
 	case 4:
 		mpostdiv = 2;
 		break;
@@ -178,12 +236,36 @@
 		mpostdiv = 3;
 		break;
 	}
-	pll->pll_gen_cntl |= mpostdiv << 4;	/* mclk */
+
+    pll->spll_cntl2 = mpostdiv << 4; /* sclk == pllsclk / mpostdiv */
+    
+    switch (pll->xclk_post_div_real) {
+	case 1:
+	    xpostdiv = 0;
+	    break;
+	case 2:
+	    xpostdiv = 1;
+	    break;
+	case 3:
+	    xpostdiv = 4;
+	    break;
+	case 4:
+	    xpostdiv = 2;
+	    break;
+	case 8:
+	    xpostdiv = 3;
+	    break;
+    }
+
 
 	if (M64_HAS(MAGIC_POSTDIV))
 		pll->pll_ext_cntl = 0;
 	else
-		pll->pll_ext_cntl = mpostdiv;	/* xclk == mclk */
+	pll->pll_ext_cntl = xpostdiv;	/* xclk == pllmclk / xpostdiv */
+
+    if (pll->mclk_fb_mult == 4)
+	    pll->pll_ext_cntl |= 0x08;
+
 
 	switch (pll->vclk_post_div_real) {
 	case 2:
@@ -242,24 +324,57 @@
 {
 	struct atyfb_par *par = (struct atyfb_par *) info->par;
 
+#ifdef DEBUG
+    printk(__FUNCTION__ ": about to program:\n"
+	   "refdiv=%d, extcntl=0x%02x, mfbdiv=%d\n"
+	   "spllcntl2=0x%02x, sfbdiv=%d, gencntl=0x%02x\n"
+	   "vclkcntl=0x%02x, vpostdiv=0x%02x, vfbdiv=%d\n"
+	   "clocksel=%d\n",
+	   pll->ct.pll_ref_div, pll->ct.pll_ext_cntl,
+	   pll->ct.mclk_fb_div, pll->ct.spll_cntl2,
+	   pll->ct.sclk_fb_div, pll->ct.pll_gen_cntl,
+	   pll->ct.pll_vclk_cntl, pll->ct.vclk_post_div,
+	   pll->ct.vclk_fb_div, aty_ld_le32(CLOCK_CNTL, par) & 0x03);
+#endif
+
+
 	aty_st_pll(PLL_REF_DIV, pll->ct.pll_ref_div, par);
+
+    aty_st_pll(PLL_EXT_CNTL, pll->ct.pll_ext_cntl, par);
+    aty_st_pll(MCLK_FB_DIV, pll->ct.mclk_fb_div, par); // for XCLK
+    
+    aty_st_pll(SPLL_CNTL2, pll->ct.spll_cntl2, par);
+    aty_st_pll(SCLK_FB_DIV, pll->ct.sclk_fb_div, par); // for MCLK
+
 	aty_st_pll(PLL_GEN_CNTL, pll->ct.pll_gen_cntl, par);
-	aty_st_pll(MCLK_FB_DIV, pll->ct.mclk_fb_div, par);
+    aty_st_pll(EXT_VPLL_CNTL, 0, par);
+
 	aty_st_pll(PLL_VCLK_CNTL, pll->ct.pll_vclk_cntl, par);
 	aty_st_pll(VCLK_POST_DIV, pll->ct.vclk_post_div, par);
 	aty_st_pll(VCLK0_FB_DIV, pll->ct.vclk_fb_div, par);
-	aty_st_pll(PLL_EXT_CNTL, pll->ct.pll_ext_cntl, par);
 
 	if (M64_HAS(GTB_DSP)) {
+	u8 dll_cntl;
+
 		if (M64_HAS(XL_DLL))
-			aty_st_pll(DLL_CNTL, 0x80, par);
+	    dll_cntl = 0x80;
 		else if (par->ram_type >= SDRAM)
-			aty_st_pll(DLL_CNTL, 0xa6, par);
+	    dll_cntl = 0xa6;
 		else
-			aty_st_pll(DLL_CNTL, 0xa0, par);
+	    dll_cntl = 0xa0;
+	aty_st_pll(DLL_CNTL, dll_cntl, par);
+
 		aty_st_pll(VFC_CNTL, 0x1b, par);
 		aty_st_le32(DSP_CONFIG, pll->ct.dsp_config, par);
 		aty_st_le32(DSP_ON_OFF, pll->ct.dsp_on_off, par);
+
+	mdelay(10);
+	aty_st_pll(DLL_CNTL, dll_cntl, par);
+	mdelay(10);
+	aty_st_pll(DLL_CNTL, dll_cntl | 0x40, par);
+	mdelay(10);
+	aty_st_pll(DLL_CNTL, dll_cntl & ~0x40, par);
+
 	}
 }
 
diff -uNr linux-2.6.2/drivers/video/aty/Makefile linux-2.6.2.new/drivers/video/aty/Makefile
--- linux-2.6.2/drivers/video/aty/Makefile	2004-02-03 22:43:39.000000000 -0500
+++ linux-2.6.2.new/drivers/video/aty/Makefile	2004-02-13 10:30:32.000000000 -0500
@@ -4,4 +4,5 @@
 atyfb-y				:= atyfb_base.o mach64_accel.o
 atyfb-$(CONFIG_FB_ATY_GX)	+= mach64_gx.o
 atyfb-$(CONFIG_FB_ATY_CT)	+= mach64_ct.o mach64_cursor.o
+obj-$(CONFIG_FB_ATY_XL_INIT)    += xlinit.o
 atyfb-objs			:= $(atyfb-y)
diff -uNr linux-2.6.2/include/video/mach64.h linux-2.6.2.new/include/video/mach64.h
--- linux-2.6.2/include/video/mach64.h	2004-02-03 22:43:57.000000000 -0500
+++ linux-2.6.2.new/include/video/mach64.h	2004-02-13 14:56:55.000000000 -0500
@@ -849,7 +849,6 @@
 #define LI_CHIP_ID	0x4c49	/* RAGE LT PRO */
 #define LP_CHIP_ID	0x4c50	/* RAGE LT PRO */
 #define LT_CHIP_ID	0x4c54	/* RAGE LT */
-#define XL_CHIP_ID	0x4752	/* RAGE (XL) */
 #define GT_CHIP_ID	0x4754	/* RAGE (GT) */
 #define GU_CHIP_ID	0x4755	/* RAGE II/II+ (GTB) */
 #define GV_CHIP_ID	0x4756	/* RAGE IIC, PCI */
@@ -864,6 +863,17 @@
 #define LN_CHIP_ID	0x4c4e	/* RAGE Mobility AGP */
 
 
+#define GR_CHIP_ID	0x4752	/* RAGE XL, BGA, PCI33 */
+#define GS_CHIP_ID      0x4753  /* RAGE XL, PQFP, PCI33 */
+#define GM_CHIP_ID      0x474d  /* RAGE XL, BGA, AGP 1x,2x */
+#define GN_CHIP_ID      0x474e  /* RAGE XL, PQFP,AGP 1x,2x */
+#define GO_CHIP_ID      0x474f  /* RAGE XL, BGA, PCI66 */
+#define GL_CHIP_ID      0x474c  /* RAGE XL, PQFP, PCI66 */
+
+#define IS_XL(id) ((id)==GR_CHIP_ID || (id)==GS_CHIP_ID || \
+                   (id)==GM_CHIP_ID || (id)==GN_CHIP_ID || \
+                   (id)==GO_CHIP_ID || (id)==GL_CHIP_ID )
+
 /* Mach64 major ASIC revisions */
 #define MACH64_ASIC_NEC_VT_A3		0x08
 #define MACH64_ASIC_NEC_VT_A4		0x48
