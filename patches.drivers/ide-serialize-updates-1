
From Jens Axboe <axboe@suse.de>

Pin the ide channel before tuning drive speed or dma on/off to avoid
doing so in the middle of a transfer request.

diff -urp /mnt/kscratch/linux-2.6.5/drivers/ide/ide.c linux-2.6.5-SUSE-20040426/drivers/ide/ide.c
--- /mnt/kscratch/linux-2.6.5/drivers/ide/ide.c	2004-04-04 05:36:54.000000000 +0200
+++ linux-2.6.5-SUSE-20040426/drivers/ide/ide.c	2004-04-26 12:37:10.000000000 +0200
@@ -1289,18 +1289,28 @@ static int set_io_32bit(ide_drive_t *dri
 static int set_using_dma (ide_drive_t *drive, int arg)
 {
 #ifdef CONFIG_BLK_DEV_IDEDMA
+	int ret = -EPERM;
+
+	ide_pin_hwgroup(drive);
+
 	if (!drive->id || !(drive->id->capability & 1))
-		return -EPERM;
+		goto out;
 	if (HWIF(drive)->ide_dma_check == NULL)
-		return -EPERM;
+		goto out;
+	ret = -EIO;
 	if (arg) {
-		if (HWIF(drive)->ide_dma_check(drive)) return -EIO;
-		if (HWIF(drive)->ide_dma_on(drive)) return -EIO;
+		if (HWIF(drive)->ide_dma_check(drive))
+			goto out;
+		if (HWIF(drive)->ide_dma_on(drive))
+			goto out;
 	} else {
 		if (__ide_dma_off(drive))
-			return -EIO;
+			goto out;
 	}
-	return 0;
+	ret = 0;
+out:
+	ide_unpin_hwgroup(drive);
+	return ret;
 #else
 	return -EPERM;
 #endif
diff -urp /mnt/kscratch/linux-2.6.5/drivers/ide/ide-io.c linux-2.6.5-SUSE-20040426/drivers/ide/ide-io.c
--- /mnt/kscratch/linux-2.6.5/drivers/ide/ide-io.c	2004-04-27 07:59:23.872021580 +0200
+++ linux-2.6.5-SUSE-20040426/drivers/ide/ide-io.c	2004-04-27 07:53:26.158654176 +0200
@@ -860,6 +860,46 @@ void ide_stall_queue (ide_drive_t *drive
 	drive->sleep = timeout + jiffies;
 }
 
+void ide_unpin_hwgroup(ide_drive_t *drive)
+{
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+
+	if (hwgroup) {
+		spin_lock_irq(&ide_lock);
+		HWGROUP(drive)->busy = 0;
+		drive->blocked = 0;
+		do_ide_request(drive->queue);
+		spin_unlock_irq(&ide_lock);
+	}
+}
+
+void ide_pin_hwgroup(ide_drive_t *drive)
+{
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+
+	/*
+	 * should only happen very early, so not a problem
+	 */
+	if (!hwgroup)
+		return;
+
+	spin_lock_irq(&ide_lock);
+	do {
+		if (!hwgroup->busy && !drive->blocked)
+			break;
+		spin_unlock_irq(&ide_lock);
+		schedule_timeout(HZ/100);
+		spin_lock_irq(&ide_lock);
+	} while (hwgroup->busy || drive->blocked);
+
+	/*
+	 * we've now secured exclusive access to this hwgroup
+	 */
+	hwgroup->busy = 1;
+	drive->blocked = 1;
+	spin_unlock_irq(&ide_lock);
+}
+
 EXPORT_SYMBOL(ide_stall_queue);
 
 #define WAKEUP(drive)	((drive)->service_start + 2 * (drive)->service_time)
diff -urp /mnt/kscratch/linux-2.6.5/drivers/ide/ide-lib.c linux-2.6.5-SUSE-20040426/drivers/ide/ide-lib.c
--- /mnt/kscratch/linux-2.6.5/drivers/ide/ide-lib.c	2004-04-04 05:38:20.000000000 +0200
+++ linux-2.6.5-SUSE-20040426/drivers/ide/ide-lib.c	2004-04-26 12:39:04.000000000 +0200
@@ -436,13 +436,17 @@ EXPORT_SYMBOL(ide_toggle_bounce);
  
 int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 {
+	int ret;
 #ifndef CONFIG_BLK_DEV_IDEDMA
 	rate = min(rate, (u8) XFER_PIO_4);
 #endif
-	if(HWIF(drive)->speedproc)
-		return HWIF(drive)->speedproc(drive, rate);
+	ide_pin_hwgroup(drive);
+	if (HWIF(drive)->speedproc)
+		ret = HWIF(drive)->speedproc(drive, rate);
 	else
-		return -1;
+		ret = -1;
+	ide_unpin_hwgroup(drive);
+	return ret;
 }
 
 EXPORT_SYMBOL_GPL(ide_set_xfer_rate);
diff -urp /mnt/kscratch/linux-2.6.5/include/linux/ide.h linux-2.6.5-SUSE-20040426/include/linux/ide.h
--- /mnt/kscratch/linux-2.6.5/include/linux/ide.h	2004-04-27 07:59:23.890019636 +0200
+++ linux-2.6.5-SUSE-20040426/include/linux/ide.h	2004-04-26 12:35:38.000000000 +0200
@@ -1474,6 +1474,9 @@ extern irqreturn_t ide_intr(int irq, voi
 extern void do_ide_request(request_queue_t *);
 extern void ide_init_subdrivers(void);
 
+extern void ide_pin_hwgroup(ide_drive_t *);
+extern void ide_unpin_hwgroup(ide_drive_t *);
+
 extern struct block_device_operations ide_fops[];
 extern ide_proc_entry_t generic_subdriver_entries[];
 
