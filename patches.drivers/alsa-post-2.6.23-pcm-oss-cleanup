From: Takashi Iwai <tiwai@suse.de>
Subject: [ALSA] PCM OSS emulation cleanup
Patch-mainline: 2.6.24-rc1
References: 

Backport patches from 2.6.24-rc1 to clean up the messy PCM OSS
emulation codes.  Also supports 3-byte 24bit format now.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/core/Makefile         |   15 -
 sound/core/oss/Makefile     |    7 
 sound/core/oss/copy.c       |    5 
 sound/core/oss/io.c         |    5 
 sound/core/oss/linear.c     |   87 +++++-----
 sound/core/oss/mulaw.c      |   88 +++++-----
 sound/core/oss/pcm_oss.c    |   35 ++++
 sound/core/oss/pcm_plugin.c |   61 +++----
 sound/core/oss/plugin_ops.h |  370 --------------------------------------------
 sound/core/oss/rate.c       |    5 
 sound/core/oss/route.c      |    5 
 sound/core/pcm_misc.c       |   32 ---
 12 files changed, 171 insertions(+), 544 deletions(-)

--- a/sound/core/Makefile	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/Makefile	2007-10-31 17:45:00.000000000 -0400
@@ -1,20 +1,17 @@
 #
 # Makefile for ALSA
-# Copyright (c) 1999,2001 by Jaroslav Kysela <perex@suse.cz>
+# Copyright (c) 1999,2001 by Jaroslav Kysela <perex@perex.cz>
 #
 
-snd-objs     := sound.o init.o memory.o info.o control.o misc.o device.o
-ifeq ($(CONFIG_ISA_DMA_API),y)
-snd-objs     += isadma.o
-endif
-ifeq ($(CONFIG_SND_OSSEMUL),y)
-snd-objs     += sound_oss.o info_oss.o
-endif
+snd-y     := sound.o init.o memory.o info.o control.o misc.o device.o
+snd-$(CONFIG_ISA_DMA_API) += isadma.o
+snd-$(CONFIG_SND_OSSEMUL) += sound_oss.o info_oss.o
 
 snd-pcm-objs := pcm.o pcm_native.o pcm_lib.o pcm_timer.o pcm_misc.o \
 		pcm_memory.o
 
-snd-page-alloc-objs := memalloc.o sgbuf.o
+snd-page-alloc-y := memalloc.o
+snd-page-alloc-$(CONFIG_HAS_DMA) += sgbuf.o
 
 snd-rawmidi-objs  := rawmidi.o
 snd-timer-objs    := timer.o
--- a/sound/core/oss/Makefile	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/Makefile	2007-10-31 17:45:00.000000000 -0400
@@ -1,12 +1,13 @@
 #
 # Makefile for ALSA
-# Copyright (c) 1999 by Jaroslav Kysela <perex@suse.cz>
+# Copyright (c) 1999 by Jaroslav Kysela <perex@perex.cz>
 #
 
 snd-mixer-oss-objs := mixer_oss.o
 
-snd-pcm-oss-objs := pcm_oss.o pcm_plugin.o \
-		    io.o copy.o linear.o mulaw.o route.o rate.o
+snd-pcm-oss-y := pcm_oss.o
+snd-pcm-oss-$(CONFIG_SND_PCM_OSS_PLUGINS) += pcm_plugin.o \
+	io.o copy.o linear.o mulaw.o route.o rate.o
 
 obj-$(CONFIG_SND_MIXER_OSS) += snd-mixer-oss.o
 obj-$(CONFIG_SND_PCM_OSS) += snd-pcm-oss.o
--- a/sound/core/oss/copy.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/copy.c	2007-10-31 17:45:00.000000000 -0400
@@ -20,9 +20,6 @@
  */
 
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -88,5 +85,3 @@ int snd_pcm_plugin_build_copy(struct snd
 	*r_plugin = plugin;
 	return 0;
 }
-
-#endif
--- a/sound/core/oss/io.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/io.c	2007-10-31 17:45:00.000000000 -0400
@@ -20,9 +20,6 @@
  */
   
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -135,5 +132,3 @@ int snd_pcm_plugin_build_io(struct snd_p
 	*r_plugin = plugin;
 	return 0;
 }
-
-#endif
--- a/sound/core/oss/linear.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/linear.c	2007-10-31 17:45:00.000000000 -0400
@@ -21,9 +21,6 @@
  */
 
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -34,19 +31,34 @@
  */
  
 struct linear_priv {
-	int conv;
+	int cvt_endian;		/* need endian conversion? */
+	unsigned int src_ofs;	/* byte offset in source format */
+	unsigned int dst_ofs;	/* byte soffset in destination format */
+	unsigned int copy_ofs;	/* byte offset in temporary u32 data */
+	unsigned int dst_bytes;		/* byte size of destination format */
+	unsigned int copy_bytes;	/* bytes to copy per conversion */
+	unsigned int flip; /* MSB flip for signeness, done after endian conv */
 };
 
+static inline void do_convert(struct linear_priv *data,
+			      unsigned char *dst, unsigned char *src)
+{
+	unsigned int tmp = 0;
+	unsigned char *p = (unsigned char *)&tmp;
+
+	memcpy(p + data->copy_ofs, src + data->src_ofs, data->copy_bytes);
+	if (data->cvt_endian)
+		tmp = swab32(tmp);
+	tmp ^= data->flip;
+	memcpy(dst, p + data->dst_ofs, data->dst_bytes);
+}
+
 static void convert(struct snd_pcm_plugin *plugin,
 		    const struct snd_pcm_plugin_channel *src_channels,
 		    struct snd_pcm_plugin_channel *dst_channels,
 		    snd_pcm_uframes_t frames)
 {
-#define CONV_LABELS
-#include "plugin_ops.h"
-#undef CONV_LABELS
 	struct linear_priv *data = (struct linear_priv *)plugin->extra_data;
-	void *conv = conv_labels[data->conv];
 	int channel;
 	int nchannels = plugin->src_format.channels;
 	for (channel = 0; channel < nchannels; ++channel) {
@@ -67,11 +79,7 @@ static void convert(struct snd_pcm_plugi
 		dst_step = dst_channels[channel].area.step / 8;
 		frames1 = frames;
 		while (frames1-- > 0) {
-			goto *conv;
-#define CONV_END after
-#include "plugin_ops.h"
-#undef CONV_END
-		after:
+			do_convert(data, dst, src);
 			src += src_step;
 			dst += dst_step;
 		}
@@ -106,29 +114,36 @@ static snd_pcm_sframes_t linear_transfer
 	return frames;
 }
 
-static int conv_index(int src_format, int dst_format)
+static void init_data(struct linear_priv *data, int src_format, int dst_format)
 {
-	int src_endian, dst_endian, sign, src_width, dst_width;
+	int src_le, dst_le, src_bytes, dst_bytes;
 
-	sign = (snd_pcm_format_signed(src_format) !=
-		snd_pcm_format_signed(dst_format));
-#ifdef SNDRV_LITTLE_ENDIAN
-	src_endian = snd_pcm_format_big_endian(src_format);
-	dst_endian = snd_pcm_format_big_endian(dst_format);
-#else
-	src_endian = snd_pcm_format_little_endian(src_format);
-	dst_endian = snd_pcm_format_little_endian(dst_format);
-#endif
-
-	if (src_endian < 0)
-		src_endian = 0;
-	if (dst_endian < 0)
-		dst_endian = 0;
-
-	src_width = snd_pcm_format_width(src_format) / 8 - 1;
-	dst_width = snd_pcm_format_width(dst_format) / 8 - 1;
-
-	return src_width * 32 + src_endian * 16 + sign * 8 + dst_width * 2 + dst_endian;
+	src_bytes = snd_pcm_format_width(src_format) / 8;
+	dst_bytes = snd_pcm_format_width(dst_format) / 8;
+	src_le = snd_pcm_format_little_endian(src_format) > 0;
+	dst_le = snd_pcm_format_little_endian(dst_format) > 0;
+
+	data->dst_bytes = dst_bytes;
+	data->cvt_endian = src_le != dst_le;
+	data->copy_bytes = src_bytes < dst_bytes ? src_bytes : dst_bytes;
+	if (src_le) {
+		data->copy_ofs = 4 - data->copy_bytes;
+		data->src_ofs = src_bytes - data->copy_bytes;
+	} else
+		data->src_ofs = snd_pcm_format_physical_width(src_format) / 8 -
+			src_bytes;
+	if (dst_le)
+		data->dst_ofs = 4 - data->dst_bytes;
+	else
+		data->dst_ofs = snd_pcm_format_physical_width(dst_format) / 8 -
+			dst_bytes;
+	if (snd_pcm_format_signed(src_format) !=
+	    snd_pcm_format_signed(dst_format)) {
+		if (dst_le)
+			data->flip = cpu_to_le32(0x80000000);
+		else
+			data->flip = cpu_to_be32(0x80000000);
+	}
 }
 
 int snd_pcm_plugin_build_linear(struct snd_pcm_substream *plug,
@@ -154,10 +169,8 @@ int snd_pcm_plugin_build_linear(struct s
 	if (err < 0)
 		return err;
 	data = (struct linear_priv *)plugin->extra_data;
-	data->conv = conv_index(src_format->format, dst_format->format);
+	init_data(data, src_format->format, dst_format->format);
 	plugin->transfer = linear_transfer;
 	*r_plugin = plugin;
 	return 0;
 }
-
-#endif
--- a/sound/core/oss/mulaw.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/mulaw.c	2007-10-31 17:45:00.000000000 -0400
@@ -22,9 +22,6 @@
  */
   
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -149,19 +146,32 @@ typedef void (*mulaw_f)(struct snd_pcm_p
 
 struct mulaw_priv {
 	mulaw_f func;
-	int conv;
+	int cvt_endian;			/* need endian conversion? */
+	unsigned int native_ofs;	/* byte offset in native format */
+	unsigned int copy_ofs;		/* byte offset in s16 format */
+	unsigned int native_bytes;	/* byte size of the native format */
+	unsigned int copy_bytes;	/* bytes to copy per conversion */
+	u16 flip; /* MSB flip for signedness, done after endian conversion */
 };
 
+static inline void cvt_s16_to_native(struct mulaw_priv *data,
+				     unsigned char *dst, u16 sample)
+{
+	sample ^= data->flip;
+	if (data->cvt_endian)
+		sample = swab16(sample);
+	if (data->native_bytes > data->copy_bytes)
+		memset(dst, 0, data->native_bytes);
+	memcpy(dst + data->native_ofs, (char *)&sample + data->copy_ofs,
+	       data->copy_bytes);
+}
+
 static void mulaw_decode(struct snd_pcm_plugin *plugin,
 			const struct snd_pcm_plugin_channel *src_channels,
 			struct snd_pcm_plugin_channel *dst_channels,
 			snd_pcm_uframes_t frames)
 {
-#define PUT_S16_LABELS
-#include "plugin_ops.h"
-#undef PUT_S16_LABELS
 	struct mulaw_priv *data = (struct mulaw_priv *)plugin->extra_data;
-	void *put = put_s16_labels[data->conv];
 	int channel;
 	int nchannels = plugin->src_format.channels;
 	for (channel = 0; channel < nchannels; ++channel) {
@@ -183,30 +193,33 @@ static void mulaw_decode(struct snd_pcm_
 		frames1 = frames;
 		while (frames1-- > 0) {
 			signed short sample = ulaw2linear(*src);
-			goto *put;
-#define PUT_S16_END after
-#include "plugin_ops.h"
-#undef PUT_S16_END
-		after:
+			cvt_s16_to_native(data, dst, sample);
 			src += src_step;
 			dst += dst_step;
 		}
 	}
 }
 
+static inline signed short cvt_native_to_s16(struct mulaw_priv *data,
+					     unsigned char *src)
+{
+	u16 sample = 0;
+	memcpy((char *)&sample + data->copy_ofs, src + data->native_ofs,
+	       data->copy_bytes);
+	if (data->cvt_endian)
+		sample = swab16(sample);
+	sample ^= data->flip;
+	return (signed short)sample;
+}
+
 static void mulaw_encode(struct snd_pcm_plugin *plugin,
 			const struct snd_pcm_plugin_channel *src_channels,
 			struct snd_pcm_plugin_channel *dst_channels,
 			snd_pcm_uframes_t frames)
 {
-#define GET_S16_LABELS
-#include "plugin_ops.h"
-#undef GET_S16_LABELS
 	struct mulaw_priv *data = (struct mulaw_priv *)plugin->extra_data;
-	void *get = get_s16_labels[data->conv];
 	int channel;
 	int nchannels = plugin->src_format.channels;
-	signed short sample = 0;
 	for (channel = 0; channel < nchannels; ++channel) {
 		char *src;
 		char *dst;
@@ -225,11 +238,7 @@ static void mulaw_encode(struct snd_pcm_
 		dst_step = dst_channels[channel].area.step / 8;
 		frames1 = frames;
 		while (frames1-- > 0) {
-			goto *get;
-#define GET_S16_END after
-#include "plugin_ops.h"
-#undef GET_S16_END
-		after:
+			signed short sample = cvt_native_to_s16(data, src);
 			*dst = linear2ulaw(sample);
 			src += src_step;
 			dst += dst_step;
@@ -265,23 +274,25 @@ static snd_pcm_sframes_t mulaw_transfer(
 	return frames;
 }
 
-static int getput_index(int format)
+static void init_data(struct mulaw_priv *data, int format)
 {
-	int sign, width, endian;
-	sign = !snd_pcm_format_signed(format);
-	width = snd_pcm_format_width(format) / 8 - 1;
-	if (width < 0 || width > 3) {
-		snd_printk(KERN_ERR "snd-pcm-oss: invalid format %d\n", format);
-		width = 0;
-	}
 #ifdef SNDRV_LITTLE_ENDIAN
-	endian = snd_pcm_format_big_endian(format);
+	data->cvt_endian = snd_pcm_format_big_endian(format) > 0;
 #else
-	endian = snd_pcm_format_little_endian(format);
+	data->cvt_endian = snd_pcm_format_little_endian(format) > 0;
 #endif
-	if (endian < 0)
-		endian = 0;
-	return width * 4 + endian * 2 + sign;
+	if (!snd_pcm_format_signed(format))
+		data->flip = 0x8000;
+	data->native_bytes = snd_pcm_format_physical_width(format) / 8;
+	data->copy_bytes = data->native_bytes < 2 ? 1 : 2;
+	if (snd_pcm_format_little_endian(format)) {
+		data->native_ofs = data->native_bytes - data->copy_bytes;
+		data->copy_ofs = 2 - data->copy_bytes;
+	} else {
+		/* S24 in 4bytes need an 1 byte offset */
+		data->native_ofs = data->native_bytes -
+			snd_pcm_format_width(format) / 8;
+	}
 }
 
 int snd_pcm_plugin_build_mulaw(struct snd_pcm_substream *plug,
@@ -322,11 +333,8 @@ int snd_pcm_plugin_build_mulaw(struct sn
 		return err;
 	data = (struct mulaw_priv *)plugin->extra_data;
 	data->func = func;
-	data->conv = getput_index(format->format);
-	snd_assert(data->conv >= 0 && data->conv < 4*2*2, return -EINVAL);
+	init_data(data, format->format);
 	plugin->transfer = mulaw_transfer;
 	*r_plugin = plugin;
 	return 0;
 }
-
-#endif
--- a/sound/core/oss/pcm_oss.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/pcm_oss.c	2007-10-31 17:45:00.000000000 -0400
@@ -633,6 +633,22 @@ static long snd_pcm_alsa_frames(struct s
 	return bytes_to_frames(runtime, (buffer_size * bytes) / runtime->oss.buffer_bytes);
 }
 
+/* define extended formats in the recent OSS versions (if any) */
+/* linear formats */
+#define AFMT_S32_LE      0x00001000
+#define AFMT_S32_BE      0x00002000
+#define AFMT_S24_LE      0x00008000
+#define AFMT_S24_BE      0x00010000
+#define AFMT_S24_PACKED  0x00040000
+
+/* other supported formats */
+#define AFMT_FLOAT       0x00004000
+#define AFMT_SPDIF_RAW   0x00020000
+
+/* unsupported formats */
+#define AFMT_AC3         0x00000400
+#define AFMT_VORBIS      0x00000800
+
 static int snd_pcm_oss_format_from(int format)
 {
 	switch (format) {
@@ -646,6 +662,13 @@ static int snd_pcm_oss_format_from(int f
 	case AFMT_U16_LE:	return SNDRV_PCM_FORMAT_U16_LE;
 	case AFMT_U16_BE:	return SNDRV_PCM_FORMAT_U16_BE;
 	case AFMT_MPEG:		return SNDRV_PCM_FORMAT_MPEG;
+	case AFMT_S32_LE:	return SNDRV_PCM_FORMAT_S32_LE;
+	case AFMT_S32_BE:	return SNDRV_PCM_FORMAT_S32_BE;
+	case AFMT_S24_LE:	return SNDRV_PCM_FORMAT_S24_LE;
+	case AFMT_S24_BE:	return SNDRV_PCM_FORMAT_S24_BE;
+	case AFMT_S24_PACKED:	return SNDRV_PCM_FORMAT_S24_3LE;
+	case AFMT_FLOAT:	return SNDRV_PCM_FORMAT_FLOAT;
+	case AFMT_SPDIF_RAW:	return SNDRV_PCM_FORMAT_IEC958_SUBFRAME;
 	default:		return SNDRV_PCM_FORMAT_U8;
 	}
 }
@@ -663,6 +686,13 @@ static int snd_pcm_oss_format_to(int for
 	case SNDRV_PCM_FORMAT_U16_LE:	return AFMT_U16_LE;
 	case SNDRV_PCM_FORMAT_U16_BE:	return AFMT_U16_BE;
 	case SNDRV_PCM_FORMAT_MPEG:		return AFMT_MPEG;
+	case SNDRV_PCM_FORMAT_S32_LE:	return AFMT_S32_LE;
+	case SNDRV_PCM_FORMAT_S32_BE:	return AFMT_S32_BE;
+	case SNDRV_PCM_FORMAT_S24_LE:	return AFMT_S24_LE;
+	case SNDRV_PCM_FORMAT_S24_BE:	return AFMT_S24_BE;
+	case SNDRV_PCM_FORMAT_S24_3LE:	return AFMT_S24_PACKED;
+	case SNDRV_PCM_FORMAT_FLOAT:	return AFMT_FLOAT;
+	case SNDRV_PCM_FORMAT_IEC958_SUBFRAME: return AFMT_SPDIF_RAW;
 	default:			return -EINVAL;
 	}
 }
@@ -1725,7 +1755,10 @@ static int snd_pcm_oss_get_formats(struc
 		return AFMT_MU_LAW | AFMT_U8 |
 		       AFMT_S16_LE | AFMT_S16_BE |
 		       AFMT_S8 | AFMT_U16_LE |
-		       AFMT_U16_BE;
+		       AFMT_U16_BE |
+			AFMT_S32_LE | AFMT_S32_BE |
+			AFMT_S24_LE | AFMT_S24_LE |
+			AFMT_S24_PACKED;
 	params = kmalloc(sizeof(*params), GFP_KERNEL);
 	if (!params)
 		return -ENOMEM;
--- a/sound/core/oss/pcm_plugin.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/pcm_plugin.c	2007-10-31 17:45:00.000000000 -0400
@@ -25,9 +25,6 @@
 #endif
 
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/vmalloc.h>
@@ -267,6 +264,8 @@ static int snd_pcm_plug_formats(struct s
 		       SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
 		       SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_S24_LE |
 		       SNDRV_PCM_FMTBIT_U24_BE | SNDRV_PCM_FMTBIT_S24_BE |
+		       SNDRV_PCM_FMTBIT_U24_3LE | SNDRV_PCM_FMTBIT_S24_3LE |
+		       SNDRV_PCM_FMTBIT_U24_3BE | SNDRV_PCM_FMTBIT_S24_3BE |
 		       SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
 		       SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE);
 	snd_mask_set(&formats, SNDRV_PCM_FORMAT_MU_LAW);
@@ -283,6 +282,10 @@ static int preferred_formats[] = {
 	SNDRV_PCM_FORMAT_S16_BE,
 	SNDRV_PCM_FORMAT_U16_LE,
 	SNDRV_PCM_FORMAT_U16_BE,
+	SNDRV_PCM_FORMAT_S24_3LE,
+	SNDRV_PCM_FORMAT_S24_3BE,
+	SNDRV_PCM_FORMAT_U24_3LE,
+	SNDRV_PCM_FORMAT_U24_3BE,
 	SNDRV_PCM_FORMAT_S24_LE,
 	SNDRV_PCM_FORMAT_S24_BE,
 	SNDRV_PCM_FORMAT_U24_LE,
@@ -297,41 +300,37 @@ static int preferred_formats[] = {
 
 int snd_pcm_plug_slave_format(int format, struct snd_mask *format_mask)
 {
+	int i;
+
 	if (snd_mask_test(format_mask, format))
 		return format;
 	if (! snd_pcm_plug_formats(format_mask, format))
 		return -EINVAL;
 	if (snd_pcm_format_linear(format)) {
-		int width = snd_pcm_format_width(format);
-		int unsignd = snd_pcm_format_unsigned(format);
-		int big = snd_pcm_format_big_endian(format);
-		int format1;
-		int wid, width1=width;
-		int dwidth1 = 8;
-		for (wid = 0; wid < 4; ++wid) {
-			int end, big1 = big;
-			for (end = 0; end < 2; ++end) {
-				int sgn, unsignd1 = unsignd;
-				for (sgn = 0; sgn < 2; ++sgn) {
-					format1 = snd_pcm_build_linear_format(width1, unsignd1, big1);
-					if (format1 >= 0 &&
-					    snd_mask_test(format_mask, format1))
-						goto _found;
-					unsignd1 = !unsignd1;
-				}
-				big1 = !big1;
-			}
-			if (width1 == 32) {
-				dwidth1 = -dwidth1;
-				width1 = width;
+		unsigned int width = snd_pcm_format_width(format);
+		int unsignd = snd_pcm_format_unsigned(format) > 0;
+		int big = snd_pcm_format_big_endian(format) > 0;
+		unsigned int badness, best = -1;
+		int best_format = -1;
+		for (i = 0; i < ARRAY_SIZE(preferred_formats); i++) {
+			int f = preferred_formats[i];
+			unsigned int w;
+			if (!snd_mask_test(format_mask, f))
+				continue;
+			w = snd_pcm_format_width(f);
+			if (w >= width)
+				badness = w - width;
+			else
+				badness = width - w + 32;
+			badness += snd_pcm_format_unsigned(f) != unsignd;
+			badness += snd_pcm_format_big_endian(f) != big;
+			if (badness < best) {
+				best_format = f;
+				best = badness;
 			}
-			width1 += dwidth1;
 		}
-		return -EINVAL;
-	_found:
-		return format1;
+		return best_format >= 0 ? best_format : -EINVAL;
 	} else {
-		unsigned int i;
 		switch (format) {
 		case SNDRV_PCM_FORMAT_MU_LAW:
 			for (i = 0; i < ARRAY_SIZE(preferred_formats); ++i) {
@@ -740,5 +739,3 @@ int snd_pcm_area_copy(const struct snd_p
 	}
 	return 0;
 }
-
-#endif
--- a/sound/core/oss/plugin_ops.h	2007-10-31 17:43:16.000000000 -0400
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,370 +0,0 @@
-/*
- *  Plugin sample operators with fast switch
- *  Copyright (c) 2000 by Jaroslav Kysela <perex@suse.cz>
- *
- *
- *   This library is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU Library General Public License as
- *   published by the Free Software Foundation; either version 2 of
- *   the License, or (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU Library General Public License for more details.
- *
- *   You should have received a copy of the GNU Library General Public
- *   License along with this library; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-
-#define as_u8(ptr) (*(u_int8_t*)(ptr))
-#define as_u16(ptr) (*(u_int16_t*)(ptr))
-#define as_u32(ptr) (*(u_int32_t*)(ptr))
-#define as_u64(ptr) (*(u_int64_t*)(ptr))
-#define as_s8(ptr) (*(int8_t*)(ptr))
-#define as_s16(ptr) (*(int16_t*)(ptr))
-#define as_s32(ptr) (*(int32_t*)(ptr))
-#define as_s64(ptr) (*(int64_t*)(ptr))
-
-#ifdef COPY_LABELS
-static void *copy_labels[4] = {
-	&&copy_8,
-	&&copy_16,
-	&&copy_32,
-	&&copy_64
-};
-#endif
-
-#ifdef COPY_END
-while(0) {
-copy_8: as_s8(dst) = as_s8(src); goto COPY_END;
-copy_16: as_s16(dst) = as_s16(src); goto COPY_END;
-copy_32: as_s32(dst) = as_s32(src); goto COPY_END;
-copy_64: as_s64(dst) = as_s64(src); goto COPY_END;
-}
-#endif
-
-#ifdef CONV_LABELS
-/* src_wid src_endswap sign_toggle dst_wid dst_endswap */
-static void *conv_labels[4 * 2 * 2 * 4 * 2] = {
-	&&conv_xxx1_xxx1,	 /*  8h ->  8h */
-	&&conv_xxx1_xxx1,	 /*  8h ->  8s */
-	&&conv_xxx1_xx10,	 /*  8h -> 16h */
-	&&conv_xxx1_xx01,	 /*  8h -> 16s */
-	&&conv_xxx1_x100,	 /*  8h -> 24h */
-	&&conv_xxx1_001x,	 /*  8h -> 24s */
-	&&conv_xxx1_1000,	 /*  8h -> 32h */
-	&&conv_xxx1_0001,	 /*  8h -> 32s */
-	&&conv_xxx1_xxx9,	 /*  8h ^>  8h */
-	&&conv_xxx1_xxx9,	 /*  8h ^>  8s */
-	&&conv_xxx1_xx90,	 /*  8h ^> 16h */
-	&&conv_xxx1_xx09,	 /*  8h ^> 16s */
-	&&conv_xxx1_x900,	 /*  8h ^> 24h */
-	&&conv_xxx1_009x,	 /*  8h ^> 24s */
-	&&conv_xxx1_9000,	 /*  8h ^> 32h */
-	&&conv_xxx1_0009,	 /*  8h ^> 32s */
-	&&conv_xxx1_xxx1,	 /*  8s ->  8h */
-	&&conv_xxx1_xxx1,	 /*  8s ->  8s */
-	&&conv_xxx1_xx10,	 /*  8s -> 16h */
-	&&conv_xxx1_xx01,	 /*  8s -> 16s */
-	&&conv_xxx1_x100,	 /*  8s -> 24h */
-	&&conv_xxx1_001x,	 /*  8s -> 24s */
-	&&conv_xxx1_1000,	 /*  8s -> 32h */
-	&&conv_xxx1_0001,	 /*  8s -> 32s */
-	&&conv_xxx1_xxx9,	 /*  8s ^>  8h */
-	&&conv_xxx1_xxx9,	 /*  8s ^>  8s */
-	&&conv_xxx1_xx90,	 /*  8s ^> 16h */
-	&&conv_xxx1_xx09,	 /*  8s ^> 16s */
-	&&conv_xxx1_x900,	 /*  8s ^> 24h */
-	&&conv_xxx1_009x,	 /*  8s ^> 24s */
-	&&conv_xxx1_9000,	 /*  8s ^> 32h */
-	&&conv_xxx1_0009,	 /*  8s ^> 32s */
-	&&conv_xx12_xxx1,	 /* 16h ->  8h */
-	&&conv_xx12_xxx1,	 /* 16h ->  8s */
-	&&conv_xx12_xx12,	 /* 16h -> 16h */
-	&&conv_xx12_xx21,	 /* 16h -> 16s */
-	&&conv_xx12_x120,	 /* 16h -> 24h */
-	&&conv_xx12_021x,	 /* 16h -> 24s */
-	&&conv_xx12_1200,	 /* 16h -> 32h */
-	&&conv_xx12_0021,	 /* 16h -> 32s */
-	&&conv_xx12_xxx9,	 /* 16h ^>  8h */
-	&&conv_xx12_xxx9,	 /* 16h ^>  8s */
-	&&conv_xx12_xx92,	 /* 16h ^> 16h */
-	&&conv_xx12_xx29,	 /* 16h ^> 16s */
-	&&conv_xx12_x920,	 /* 16h ^> 24h */
-	&&conv_xx12_029x,	 /* 16h ^> 24s */
-	&&conv_xx12_9200,	 /* 16h ^> 32h */
-	&&conv_xx12_0029,	 /* 16h ^> 32s */
-	&&conv_xx12_xxx2,	 /* 16s ->  8h */
-	&&conv_xx12_xxx2,	 /* 16s ->  8s */
-	&&conv_xx12_xx21,	 /* 16s -> 16h */
-	&&conv_xx12_xx12,	 /* 16s -> 16s */
-	&&conv_xx12_x210,	 /* 16s -> 24h */
-	&&conv_xx12_012x,	 /* 16s -> 24s */
-	&&conv_xx12_2100,	 /* 16s -> 32h */
-	&&conv_xx12_0012,	 /* 16s -> 32s */
-	&&conv_xx12_xxxA,	 /* 16s ^>  8h */
-	&&conv_xx12_xxxA,	 /* 16s ^>  8s */
-	&&conv_xx12_xxA1,	 /* 16s ^> 16h */
-	&&conv_xx12_xx1A,	 /* 16s ^> 16s */
-	&&conv_xx12_xA10,	 /* 16s ^> 24h */
-	&&conv_xx12_01Ax,	 /* 16s ^> 24s */
-	&&conv_xx12_A100,	 /* 16s ^> 32h */
-	&&conv_xx12_001A,	 /* 16s ^> 32s */
-	&&conv_x123_xxx1,	 /* 24h ->  8h */
-	&&conv_x123_xxx1,	 /* 24h ->  8s */
-	&&conv_x123_xx12,	 /* 24h -> 16h */
-	&&conv_x123_xx21,	 /* 24h -> 16s */
-	&&conv_x123_x123,	 /* 24h -> 24h */
-	&&conv_x123_321x,	 /* 24h -> 24s */
-	&&conv_x123_1230,	 /* 24h -> 32h */
-	&&conv_x123_0321,	 /* 24h -> 32s */
-	&&conv_x123_xxx9,	 /* 24h ^>  8h */
-	&&conv_x123_xxx9,	 /* 24h ^>  8s */
-	&&conv_x123_xx92,	 /* 24h ^> 16h */
-	&&conv_x123_xx29,	 /* 24h ^> 16s */
-	&&conv_x123_x923,	 /* 24h ^> 24h */
-	&&conv_x123_329x,	 /* 24h ^> 24s */
-	&&conv_x123_9230,	 /* 24h ^> 32h */
-	&&conv_x123_0329,	 /* 24h ^> 32s */
-	&&conv_123x_xxx3,	 /* 24s ->  8h */
-	&&conv_123x_xxx3,	 /* 24s ->  8s */
-	&&conv_123x_xx32,	 /* 24s -> 16h */
-	&&conv_123x_xx23,	 /* 24s -> 16s */
-	&&conv_123x_x321,	 /* 24s -> 24h */
-	&&conv_123x_123x,	 /* 24s -> 24s */
-	&&conv_123x_3210,	 /* 24s -> 32h */
-	&&conv_123x_0123,	 /* 24s -> 32s */
-	&&conv_123x_xxxB,	 /* 24s ^>  8h */
-	&&conv_123x_xxxB,	 /* 24s ^>  8s */
-	&&conv_123x_xxB2,	 /* 24s ^> 16h */
-	&&conv_123x_xx2B,	 /* 24s ^> 16s */
-	&&conv_123x_xB21,	 /* 24s ^> 24h */
-	&&conv_123x_12Bx,	 /* 24s ^> 24s */
-	&&conv_123x_B210,	 /* 24s ^> 32h */
-	&&conv_123x_012B,	 /* 24s ^> 32s */
-	&&conv_1234_xxx1,	 /* 32h ->  8h */
-	&&conv_1234_xxx1,	 /* 32h ->  8s */
-	&&conv_1234_xx12,	 /* 32h -> 16h */
-	&&conv_1234_xx21,	 /* 32h -> 16s */
-	&&conv_1234_x123,	 /* 32h -> 24h */
-	&&conv_1234_321x,	 /* 32h -> 24s */
-	&&conv_1234_1234,	 /* 32h -> 32h */
-	&&conv_1234_4321,	 /* 32h -> 32s */
-	&&conv_1234_xxx9,	 /* 32h ^>  8h */
-	&&conv_1234_xxx9,	 /* 32h ^>  8s */
-	&&conv_1234_xx92,	 /* 32h ^> 16h */
-	&&conv_1234_xx29,	 /* 32h ^> 16s */
-	&&conv_1234_x923,	 /* 32h ^> 24h */
-	&&conv_1234_329x,	 /* 32h ^> 24s */
-	&&conv_1234_9234,	 /* 32h ^> 32h */
-	&&conv_1234_4329,	 /* 32h ^> 32s */
-	&&conv_1234_xxx4,	 /* 32s ->  8h */
-	&&conv_1234_xxx4,	 /* 32s ->  8s */
-	&&conv_1234_xx43,	 /* 32s -> 16h */
-	&&conv_1234_xx34,	 /* 32s -> 16s */
-	&&conv_1234_x432,	 /* 32s -> 24h */
-	&&conv_1234_234x,	 /* 32s -> 24s */
-	&&conv_1234_4321,	 /* 32s -> 32h */
-	&&conv_1234_1234,	 /* 32s -> 32s */
-	&&conv_1234_xxxC,	 /* 32s ^>  8h */
-	&&conv_1234_xxxC,	 /* 32s ^>  8s */
-	&&conv_1234_xxC3,	 /* 32s ^> 16h */
-	&&conv_1234_xx3C,	 /* 32s ^> 16s */
-	&&conv_1234_xC32,	 /* 32s ^> 24h */
-	&&conv_1234_23Cx,	 /* 32s ^> 24s */
-	&&conv_1234_C321,	 /* 32s ^> 32h */
-	&&conv_1234_123C,	 /* 32s ^> 32s */
-};
-#endif
-
-#ifdef CONV_END
-while(0) {
-conv_xxx1_xxx1: as_u8(dst) = as_u8(src); goto CONV_END;
-conv_xxx1_xx10: as_u16(dst) = (u_int16_t)as_u8(src) << 8; goto CONV_END;
-conv_xxx1_xx01: as_u16(dst) = (u_int16_t)as_u8(src); goto CONV_END;
-conv_xxx1_x100: as_u32(dst) = (u_int32_t)as_u8(src) << 16; goto CONV_END;
-conv_xxx1_001x: as_u32(dst) = (u_int32_t)as_u8(src) << 8; goto CONV_END;
-conv_xxx1_1000: as_u32(dst) = (u_int32_t)as_u8(src) << 24; goto CONV_END;
-conv_xxx1_0001: as_u32(dst) = (u_int32_t)as_u8(src); goto CONV_END;
-conv_xxx1_xxx9: as_u8(dst) = as_u8(src) ^ 0x80; goto CONV_END;
-conv_xxx1_xx90: as_u16(dst) = (u_int16_t)(as_u8(src) ^ 0x80) << 8; goto CONV_END;
-conv_xxx1_xx09: as_u16(dst) = (u_int16_t)(as_u8(src) ^ 0x80); goto CONV_END;
-conv_xxx1_x900: as_u32(dst) = (u_int32_t)(as_u8(src) ^ 0x80) << 16; goto CONV_END;
-conv_xxx1_009x: as_u32(dst) = (u_int32_t)(as_u8(src) ^ 0x80) << 8; goto CONV_END;
-conv_xxx1_9000: as_u32(dst) = (u_int32_t)(as_u8(src) ^ 0x80) << 24; goto CONV_END;
-conv_xxx1_0009: as_u32(dst) = (u_int32_t)(as_u8(src) ^ 0x80); goto CONV_END;
-conv_xx12_xxx1: as_u8(dst) = as_u16(src) >> 8; goto CONV_END;
-conv_xx12_xx12: as_u16(dst) = as_u16(src); goto CONV_END;
-conv_xx12_xx21: as_u16(dst) = swab16(as_u16(src)); goto CONV_END;
-conv_xx12_x120: as_u32(dst) = (u_int32_t)as_u16(src) << 8; goto CONV_END;
-conv_xx12_021x: as_u32(dst) = (u_int32_t)swab16(as_u16(src)) << 8; goto CONV_END;
-conv_xx12_1200: as_u32(dst) = (u_int32_t)as_u16(src) << 16; goto CONV_END;
-conv_xx12_0021: as_u32(dst) = (u_int32_t)swab16(as_u16(src)); goto CONV_END;
-conv_xx12_xxx9: as_u8(dst) = (as_u16(src) >> 8) ^ 0x80; goto CONV_END;
-conv_xx12_xx92: as_u16(dst) = as_u16(src) ^ 0x8000; goto CONV_END;
-conv_xx12_xx29: as_u16(dst) = swab16(as_u16(src)) ^ 0x80; goto CONV_END;
-conv_xx12_x920: as_u32(dst) = (u_int32_t)(as_u16(src) ^ 0x8000) << 8; goto CONV_END;
-conv_xx12_029x: as_u32(dst) = (u_int32_t)(swab16(as_u16(src)) ^ 0x80) << 8; goto CONV_END;
-conv_xx12_9200: as_u32(dst) = (u_int32_t)(as_u16(src) ^ 0x8000) << 16; goto CONV_END;
-conv_xx12_0029: as_u32(dst) = (u_int32_t)(swab16(as_u16(src)) ^ 0x80); goto CONV_END;
-conv_xx12_xxx2: as_u8(dst) = as_u16(src) & 0xff; goto CONV_END;
-conv_xx12_x210: as_u32(dst) = (u_int32_t)swab16(as_u16(src)) << 8; goto CONV_END;
-conv_xx12_012x: as_u32(dst) = (u_int32_t)as_u16(src) << 8; goto CONV_END;
-conv_xx12_2100: as_u32(dst) = (u_int32_t)swab16(as_u16(src)) << 16; goto CONV_END;
-conv_xx12_0012: as_u32(dst) = (u_int32_t)as_u16(src); goto CONV_END; 
-conv_xx12_xxxA: as_u8(dst) = (as_u16(src) ^ 0x80) & 0xff; goto CONV_END;
-conv_xx12_xxA1: as_u16(dst) = swab16(as_u16(src) ^ 0x80); goto CONV_END;
-conv_xx12_xx1A: as_u16(dst) = as_u16(src) ^ 0x80; goto CONV_END;
-conv_xx12_xA10: as_u32(dst) = (u_int32_t)swab16(as_u16(src) ^ 0x80) << 8; goto CONV_END;
-conv_xx12_01Ax: as_u32(dst) = (u_int32_t)(as_u16(src) ^ 0x80) << 8; goto CONV_END;
-conv_xx12_A100: as_u32(dst) = (u_int32_t)swab16(as_u16(src) ^ 0x80) << 16; goto CONV_END;
-conv_xx12_001A: as_u32(dst) = (u_int32_t)(as_u16(src) ^ 0x80); goto CONV_END;
-conv_x123_xxx1: as_u8(dst) = as_u32(src) >> 16; goto CONV_END;
-conv_x123_xx12: as_u16(dst) = as_u32(src) >> 8; goto CONV_END;
-conv_x123_xx21: as_u16(dst) = swab16(as_u32(src) >> 8); goto CONV_END;
-conv_x123_x123: as_u32(dst) = as_u32(src); goto CONV_END;
-conv_x123_321x: as_u32(dst) = swab32(as_u32(src)); goto CONV_END;
-conv_x123_1230: as_u32(dst) = as_u32(src) << 8; goto CONV_END;
-conv_x123_0321: as_u32(dst) = swab32(as_u32(src)) >> 8; goto CONV_END;
-conv_x123_xxx9: as_u8(dst) = (as_u32(src) >> 16) ^ 0x80; goto CONV_END;
-conv_x123_xx92: as_u16(dst) = (as_u32(src) >> 8) ^ 0x8000; goto CONV_END;
-conv_x123_xx29: as_u16(dst) = swab16(as_u32(src) >> 8) ^ 0x80; goto CONV_END;
-conv_x123_x923: as_u32(dst) = as_u32(src) ^ 0x800000; goto CONV_END;
-conv_x123_329x: as_u32(dst) = swab32(as_u32(src)) ^ 0x8000; goto CONV_END;
-conv_x123_9230: as_u32(dst) = (as_u32(src) ^ 0x800000) << 8; goto CONV_END;
-conv_x123_0329: as_u32(dst) = (swab32(as_u32(src)) >> 8) ^ 0x80; goto CONV_END;
-conv_123x_xxx3: as_u8(dst) = (as_u32(src) >> 8) & 0xff; goto CONV_END;
-conv_123x_xx32: as_u16(dst) = swab16(as_u32(src) >> 8); goto CONV_END;
-conv_123x_xx23: as_u16(dst) = (as_u32(src) >> 8) & 0xffff; goto CONV_END;
-conv_123x_x321: as_u32(dst) = swab32(as_u32(src)); goto CONV_END;
-conv_123x_123x: as_u32(dst) = as_u32(src); goto CONV_END;
-conv_123x_3210: as_u32(dst) = swab32(as_u32(src)) << 8; goto CONV_END;
-conv_123x_0123: as_u32(dst) = as_u32(src) >> 8; goto CONV_END;
-conv_123x_xxxB: as_u8(dst) = ((as_u32(src) >> 8) & 0xff) ^ 0x80; goto CONV_END;
-conv_123x_xxB2: as_u16(dst) = swab16((as_u32(src) >> 8) ^ 0x80); goto CONV_END;
-conv_123x_xx2B: as_u16(dst) = ((as_u32(src) >> 8) & 0xffff) ^ 0x80; goto CONV_END;
-conv_123x_xB21: as_u32(dst) = swab32(as_u32(src)) ^ 0x800000; goto CONV_END;
-conv_123x_12Bx: as_u32(dst) = as_u32(src) ^ 0x8000; goto CONV_END;
-conv_123x_B210: as_u32(dst) = swab32(as_u32(src) ^ 0x8000) << 8; goto CONV_END;
-conv_123x_012B: as_u32(dst) = (as_u32(src) >> 8) ^ 0x80; goto CONV_END;
-conv_1234_xxx1: as_u8(dst) = as_u32(src) >> 24; goto CONV_END;
-conv_1234_xx12: as_u16(dst) = as_u32(src) >> 16; goto CONV_END;
-conv_1234_xx21: as_u16(dst) = swab16(as_u32(src) >> 16); goto CONV_END;
-conv_1234_x123: as_u32(dst) = as_u32(src) >> 8; goto CONV_END;
-conv_1234_321x: as_u32(dst) = swab32(as_u32(src)) << 8; goto CONV_END;
-conv_1234_1234: as_u32(dst) = as_u32(src); goto CONV_END;
-conv_1234_4321: as_u32(dst) = swab32(as_u32(src)); goto CONV_END;
-conv_1234_xxx9: as_u8(dst) = (as_u32(src) >> 24) ^ 0x80; goto CONV_END;
-conv_1234_xx92: as_u16(dst) = (as_u32(src) >> 16) ^ 0x8000; goto CONV_END;
-conv_1234_xx29: as_u16(dst) = swab16(as_u32(src) >> 16) ^ 0x80; goto CONV_END;
-conv_1234_x923: as_u32(dst) = (as_u32(src) >> 8) ^ 0x800000; goto CONV_END;
-conv_1234_329x: as_u32(dst) = (swab32(as_u32(src)) ^ 0x80) << 8; goto CONV_END;
-conv_1234_9234: as_u32(dst) = as_u32(src) ^ 0x80000000; goto CONV_END;
-conv_1234_4329: as_u32(dst) = swab32(as_u32(src)) ^ 0x80; goto CONV_END;
-conv_1234_xxx4: as_u8(dst) = as_u32(src) & 0xff; goto CONV_END;
-conv_1234_xx43: as_u16(dst) = swab16(as_u32(src)); goto CONV_END;
-conv_1234_xx34: as_u16(dst) = as_u32(src) & 0xffff; goto CONV_END;
-conv_1234_x432: as_u32(dst) = swab32(as_u32(src)) >> 8; goto CONV_END;
-conv_1234_234x: as_u32(dst) = as_u32(src) << 8; goto CONV_END;
-conv_1234_xxxC: as_u8(dst) = (as_u32(src) & 0xff) ^ 0x80; goto CONV_END;
-conv_1234_xxC3: as_u16(dst) = swab16(as_u32(src) ^ 0x80); goto CONV_END;
-conv_1234_xx3C: as_u16(dst) = (as_u32(src) & 0xffff) ^ 0x80; goto CONV_END;
-conv_1234_xC32: as_u32(dst) = (swab32(as_u32(src)) >> 8) ^ 0x800000; goto CONV_END;
-conv_1234_23Cx: as_u32(dst) = (as_u32(src) ^ 0x80) << 8; goto CONV_END;
-conv_1234_C321: as_u32(dst) = swab32(as_u32(src) ^ 0x80); goto CONV_END;
-conv_1234_123C: as_u32(dst) = as_u32(src) ^ 0x80; goto CONV_END;
-}
-#endif
-
-#ifdef GET_S16_LABELS
-/* src_wid src_endswap unsigned */
-static void *get_s16_labels[4 * 2 * 2] = {
-	&&get_s16_xxx1_xx10,	 /*  8h -> 16h */
-	&&get_s16_xxx1_xx90,	 /*  8h ^> 16h */
-	&&get_s16_xxx1_xx10,	 /*  8s -> 16h */
-	&&get_s16_xxx1_xx90,	 /*  8s ^> 16h */
-	&&get_s16_xx12_xx12,	 /* 16h -> 16h */
-	&&get_s16_xx12_xx92,	 /* 16h ^> 16h */
-	&&get_s16_xx12_xx21,	 /* 16s -> 16h */
-	&&get_s16_xx12_xxA1,	 /* 16s ^> 16h */
-	&&get_s16_x123_xx12,	 /* 24h -> 16h */
-	&&get_s16_x123_xx92,	 /* 24h ^> 16h */
-	&&get_s16_123x_xx32,	 /* 24s -> 16h */
-	&&get_s16_123x_xxB2,	 /* 24s ^> 16h */
-	&&get_s16_1234_xx12,	 /* 32h -> 16h */
-	&&get_s16_1234_xx92,	 /* 32h ^> 16h */
-	&&get_s16_1234_xx43,	 /* 32s -> 16h */
-	&&get_s16_1234_xxC3,	 /* 32s ^> 16h */
-};
-#endif
-
-#ifdef GET_S16_END
-while(0) {
-get_s16_xxx1_xx10: sample = (u_int16_t)as_u8(src) << 8; goto GET_S16_END;
-get_s16_xxx1_xx90: sample = (u_int16_t)(as_u8(src) ^ 0x80) << 8; goto GET_S16_END;
-get_s16_xx12_xx12: sample = as_u16(src); goto GET_S16_END;
-get_s16_xx12_xx92: sample = as_u16(src) ^ 0x8000; goto GET_S16_END;
-get_s16_xx12_xx21: sample = swab16(as_u16(src)); goto GET_S16_END;
-get_s16_xx12_xxA1: sample = swab16(as_u16(src) ^ 0x80); goto GET_S16_END;
-get_s16_x123_xx12: sample = as_u32(src) >> 8; goto GET_S16_END;
-get_s16_x123_xx92: sample = (as_u32(src) >> 8) ^ 0x8000; goto GET_S16_END;
-get_s16_123x_xx32: sample = swab16(as_u32(src) >> 8); goto GET_S16_END;
-get_s16_123x_xxB2: sample = swab16((as_u32(src) >> 8) ^ 0x8000); goto GET_S16_END;
-get_s16_1234_xx12: sample = as_u32(src) >> 16; goto GET_S16_END;
-get_s16_1234_xx92: sample = (as_u32(src) >> 16) ^ 0x8000; goto GET_S16_END;
-get_s16_1234_xx43: sample = swab16(as_u32(src)); goto GET_S16_END;
-get_s16_1234_xxC3: sample = swab16(as_u32(src) ^ 0x80); goto GET_S16_END;
-}
-#endif
-
-#ifdef PUT_S16_LABELS
-/* dst_wid dst_endswap unsigned */
-static void *put_s16_labels[4 * 2 * 2] = {
-	&&put_s16_xx12_xxx1,	 /* 16h ->  8h */
-	&&put_s16_xx12_xxx9,	 /* 16h ^>  8h */
-	&&put_s16_xx12_xxx1,	 /* 16h ->  8s */
-	&&put_s16_xx12_xxx9,	 /* 16h ^>  8s */
-	&&put_s16_xx12_xx12,	 /* 16h -> 16h */
-	&&put_s16_xx12_xx92,	 /* 16h ^> 16h */
-	&&put_s16_xx12_xx21,	 /* 16h -> 16s */
-	&&put_s16_xx12_xx29,	 /* 16h ^> 16s */
-	&&put_s16_xx12_x120,	 /* 16h -> 24h */
-	&&put_s16_xx12_x920,	 /* 16h ^> 24h */
-	&&put_s16_xx12_021x,	 /* 16h -> 24s */
-	&&put_s16_xx12_029x,	 /* 16h ^> 24s */
-	&&put_s16_xx12_1200,	 /* 16h -> 32h */
-	&&put_s16_xx12_9200,	 /* 16h ^> 32h */
-	&&put_s16_xx12_0021,	 /* 16h -> 32s */
-	&&put_s16_xx12_0029,	 /* 16h ^> 32s */
-};
-#endif
-
-#ifdef PUT_S16_END
-while (0) {
-put_s16_xx12_xxx1: as_u8(dst) = sample >> 8; goto PUT_S16_END;
-put_s16_xx12_xxx9: as_u8(dst) = (sample >> 8) ^ 0x80; goto PUT_S16_END;
-put_s16_xx12_xx12: as_u16(dst) = sample; goto PUT_S16_END;
-put_s16_xx12_xx92: as_u16(dst) = sample ^ 0x8000; goto PUT_S16_END;
-put_s16_xx12_xx21: as_u16(dst) = swab16(sample); goto PUT_S16_END;
-put_s16_xx12_xx29: as_u16(dst) = swab16(sample) ^ 0x80; goto PUT_S16_END;
-put_s16_xx12_x120: as_u32(dst) = (u_int32_t)sample << 8; goto PUT_S16_END;
-put_s16_xx12_x920: as_u32(dst) = (u_int32_t)(sample ^ 0x8000) << 8; goto PUT_S16_END;
-put_s16_xx12_021x: as_u32(dst) = (u_int32_t)swab16(sample) << 8; goto PUT_S16_END;
-put_s16_xx12_029x: as_u32(dst) = (u_int32_t)(swab16(sample) ^ 0x80) << 8; goto PUT_S16_END;
-put_s16_xx12_1200: as_u32(dst) = (u_int32_t)sample << 16; goto PUT_S16_END;
-put_s16_xx12_9200: as_u32(dst) = (u_int32_t)(sample ^ 0x8000) << 16; goto PUT_S16_END;
-put_s16_xx12_0021: as_u32(dst) = (u_int32_t)swab16(sample); goto PUT_S16_END;
-put_s16_xx12_0029: as_u32(dst) = (u_int32_t)swab16(sample) ^ 0x80; goto PUT_S16_END;
-}
-#endif
-
-#undef as_u8
-#undef as_u16
-#undef as_u32
-#undef as_s8
-#undef as_s16
-#undef as_s32
--- a/sound/core/oss/rate.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/rate.c	2007-10-31 17:45:00.000000000 -0400
@@ -20,9 +20,6 @@
  */
   
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -340,5 +337,3 @@ int snd_pcm_plugin_build_rate(struct snd
 	*r_plugin = plugin;
 	return 0;
 }
-
-#endif
--- a/sound/core/oss/route.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/oss/route.c	2007-10-31 17:45:00.000000000 -0400
@@ -20,9 +20,6 @@
  */
 
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <sound/core.h>
@@ -108,5 +105,3 @@ int snd_pcm_plugin_build_route(struct sn
 	*r_plugin = plugin;
 	return 0;
 }
-
-#endif
--- a/sound/core/pcm_misc.c	2007-10-31 17:43:16.000000000 -0400
+++ b/sound/core/pcm_misc.c	2007-10-31 17:45:00.000000000 -0400
@@ -422,38 +422,6 @@ int snd_pcm_format_set_silence(snd_pcm_f
 
 EXPORT_SYMBOL(snd_pcm_format_set_silence);
 
-/* [width][unsigned][bigendian] */
-static int linear_formats[4][2][2] = {
-	{{ SNDRV_PCM_FORMAT_S8, SNDRV_PCM_FORMAT_S8},
-	 { SNDRV_PCM_FORMAT_U8, SNDRV_PCM_FORMAT_U8}},
-	{{SNDRV_PCM_FORMAT_S16_LE, SNDRV_PCM_FORMAT_S16_BE},
-	 {SNDRV_PCM_FORMAT_U16_LE, SNDRV_PCM_FORMAT_U16_BE}},
-	{{SNDRV_PCM_FORMAT_S24_LE, SNDRV_PCM_FORMAT_S24_BE},
-	 {SNDRV_PCM_FORMAT_U24_LE, SNDRV_PCM_FORMAT_U24_BE}},
-	{{SNDRV_PCM_FORMAT_S32_LE, SNDRV_PCM_FORMAT_S32_BE},
-	 {SNDRV_PCM_FORMAT_U32_LE, SNDRV_PCM_FORMAT_U32_BE}}
-};
-
-/**
- * snd_pcm_build_linear_format - return the suitable linear format for the given condition
- * @width: the bit-width
- * @unsignd: 1 if unsigned, 0 if signed.
- * @big_endian: 1 if big-endian, 0 if little-endian
- *
- * Returns the suitable linear format for the given condition.
- */
-snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian)
-{
-	if (width & 7)
-		return SND_PCM_FORMAT_UNKNOWN;
-	width = (width / 8) - 1;
-	if (width < 0 || width >= 4)
-		return SND_PCM_FORMAT_UNKNOWN;
-	return linear_formats[width][!!unsignd][!!big_endian];
-}
-
-EXPORT_SYMBOL(snd_pcm_build_linear_format);
-
 /**
  * snd_pcm_limit_hw_rates - determine rate_min/rate_max fields
  * @runtime: the runtime instance
