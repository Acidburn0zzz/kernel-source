diff -purN linux-2.6.4/drivers/scsi/lpfc/lpfcLINUXfcp.c linux-2.6.4.emulex/drivers/scsi/lpfc/lpfcLINUXfcp.c
--- linux-2.6.4/drivers/scsi/lpfc/lpfcLINUXfcp.c	2004-03-21 10:04:58.000000000 +0100
+++ linux-2.6.4.emulex/drivers/scsi/lpfc/lpfcLINUXfcp.c	2004-03-21 10:14:27.000000000 +0100
@@ -37,11 +37,7 @@
 #include <linux/string.h>
 #include <linux/init.h>
 #include <linux/errno.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-#include <linux/blk.h>
-#else
 #include <linux/blkdev.h>
-#endif
 #include <linux/string.h>
 #include <linux/ioport.h>
 #include <linux/pci.h>
@@ -57,13 +53,8 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <asm/irq.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 #include <scsi/scsi_device.h>
 #include <asm/pci.h>
-#else
-/* From drivers/scsi */
-#include "sd.h"
-#endif
 #include "hosts.h"
 
 #include "elx_os.h"
@@ -96,6 +87,7 @@
 
 #ifdef powerpc
 #ifndef BITS_PER_LONG
+#error include types.h
 #define BITS_PER_LONG 64
 #endif
 #endif
@@ -124,36 +116,17 @@ char lpfc_os_name_version[256];
 #define FC_EXTEND_TRANS_A 1
 #define ScsiResult(host_code, scsi_code) (((host_code) << 16) | scsi_code)
 
-/* Linux 2.4 compatibility */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-typedef void irqreturn_t;
-#define IRQ_NONE
-#define IRQ_HANDLED
-#endif				/* < 2.6.0 */
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-int lpfc_detect(Scsi_Host_Template *);
-int lpfc_DetectInstance(int, struct pci_dev *, uint32_t, Scsi_Host_Template *);
-#endif
+
 int lpfc_diag_init(void);
 int lpfc_linux_attach(int, Scsi_Host_Template *, struct pci_dev *);
 int lpfc_get_bind_type(elxHBA_t *);
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-int lpfc_release(struct Scsi_Host *host);
-#endif
 int lpfc_diag_uninit(void);
 int lpfc_linux_detach(int);
 
 const char *lpfc_info(struct Scsi_Host *);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-void lpfc_select_queue_depth(struct Scsi_Host *, Scsi_Device *);
-#else
 static int lpfc_slave_configure(Scsi_Device *);
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static int lpfc_proc_info(struct Scsi_Host *, char *, char **, off_t, int, int);
-#endif
 int lpfc_device_queue_depth(elxHBA_t *, Scsi_Device *);
 irqreturn_t lpfc_intr_handler(int, void *, struct pt_regs *);
 void lpfc_local_timeout(unsigned long);
@@ -178,12 +151,8 @@ extern int elx_idx_dmapool[MAX_ELX_BRDS]
 extern int elx_size_dmapool[MAX_ELX_BRDS];
 extern spinlock_t elx_kmem_lock;
 extern char lpfc_fwrevision[32];
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 extern int elx_biosparam(struct scsi_device *, struct block_device *,
 			 sector_t capacity, int ip[]);
-#else
-extern int elx_biosparam(Disk *, kdev_t, int[]);
-#endif
 extern int elx_pci_getadd(struct pci_dev *, int, unsigned long *);
 extern void elx_scsi_add_timer(Scsi_Cmnd *, int);
 
@@ -196,52 +165,9 @@ int lpfc_mem_poolinit(elxHBA_t *);
 #define LPFC_DRIVER_NAME    "lpfc"
 char *elx_drvr_name = LPFC_DRIVER_NAME;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-#if VARYIO == 20
-#define VARYIO_ENTRY .can_do_varyio = 1,
-#elif VARYIO == 3
-#define VARYIO_ENTRY .vary_io =1,
-#else
-#define VARYIO_ENTRY
-#endif
-
-#if defined CONFIG_HIGHMEM
-#if USE_HIGHMEM_IO ==2		// i386 & Redhat 2.1
-#define HIGHMEM_ENTRY .can_dma_32 = 1,
-#define SINGLE_SG_OK .single_sg_ok = 1,
-#else
-#if USE_HIGHMEM_IO ==3		// Redhat 3.0, Suse
-#define HIGHMEM_ENTRY .highmem_io = 1,
-#define SINGLE_SG_OK
-#else				// any other
-#define HIGHMEM_ENTRY
-#define SINGLE_SG_OK
-#endif
-#endif
-#else				// no highmem config
-#define HIGHMEM_ENTRY
-#define SINGLE_SG_OK
-#endif
-#endif
-
 static Scsi_Host_Template driver_template = {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	.next = NULL,
-	.command = NULL,
-	.slave_attach = NULL,
-	.use_new_eh_code = 1,
-	.proc_info = NULL,
-	.proc_dir = NULL,
-	.detect = lpfc_detect,
-	.release = lpfc_release,
-	VARYIO_ENTRY
-	HIGHMEM_ENTRY
-	SINGLE_SG_OK
-#else
 	.proc_info = lpfc_proc_info,
 	.slave_configure = lpfc_slave_configure,
-#endif
 	.proc_name = LPFC_DRIVER_NAME,
 	.module = THIS_MODULE,
 	.name = LPFC_DRIVER_NAME,
@@ -321,125 +247,8 @@ extern char *lpfc_fcp_bind_DID[];
 /* This is to export entry points needed for IP interface */
 int lpfc_xmit(elxHBA_t *, struct sk_buff *);
 int lpfc_ipioctl(int, void *);
-#ifdef MODVERSIONS
 EXPORT_SYMBOL(lpfc_xmit);
 EXPORT_SYMBOL(lpfc_ipioctl);
-#else
-EXPORT_SYMBOL_NOVERS(lpfc_xmit);
-EXPORT_SYMBOL_NOVERS(lpfc_ipioctl);
-#endif				/* MODVERSIONS */
-
-#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,0)
-
-int
-lpfc_detect(Scsi_Host_Template * tmpt)
-{
-	struct pci_dev *pdev = NULL;
-	int instance = 0;
-	int i;
-	/* To add another, add a line before the last element.
-	 * Leave last element 0.
-	 */
-	uint32_t sType[] = {
-		PCI_DEVICE_ID_VIPER,
-		PCI_DEVICE_ID_THOR,
-		PCI_DEVICE_ID_PEGASUS,
-		PCI_DEVICE_ID_CENTAUR,
-		PCI_DEVICE_ID_DRAGONFLY,
-		PCI_DEVICE_ID_SUPERFLY,
-		PCI_DEVICE_ID_RFLY,
-		PCI_DEVICE_ID_PFLY,
-		PCI_DEVICE_ID_TFLY,
-		PCI_DEVICE_ID_LP101,
-		0
-	};
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-#if VARYIO == 21
-#ifdef SCSI_HOST_VARYIO
-	SCSI_HOST_VARYIO(tmpt) = 1;
-#endif
-#endif
-#endif
-
-	printk("Emulex LightPulse FC SCSI/IP: %s    Osgt: %s\n",
-	       lpfc_release_version, OSGT_DRIVER_VERSION);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-	/* Release the io_request_lock lock and reenable interrupts allowing
-	 * the driver to sleep if necessary.
-	 */
-	spin_unlock(&io_request_lock);
-#endif
-
-	memset((char *)&elxDRVR, 0, sizeof (elxDRVR_t));
-	memset((char *)&lpfcdrvr, 0, sizeof (LINUX_DRVR_t));
-	elxDRVR.pDrvrOSEnv = &lpfcdrvr;
-	for (i = 0; i < MAX_ELX_BRDS; i++) {
-		lpfc_instance[i] = -1;
-	}
-
-	/* Initialize all per Driver locks */
-	elx_clk_init_lock(0);
-
-	/* Search for all Device IDs supported */
-	i = 0;
-	while (sType[i]) {
-		instance = lpfc_DetectInstance(instance, pdev, sType[i], tmpt);
-		i++;
-	}
-
-	if (instance) {
-		lpfc_diag_init();	/* Initialize diagnostic interface */
-	}
-
-	/* This covers the case where the lpfn driver gets loaded before the
-	 * lpfc driver detect completes.
-	 */
-	if (lpfc_detect_called == 2) {
-		lpfc_detect_called = 1;
-		if (lpfn_probe != NULL)
-			lpfn_probe();
-
-	} else
-		lpfc_detect_called = 1;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-	/* reacquire io_request_lock as the midlayer was holding it when it
-	   called us */
-	spin_lock(&io_request_lock);
-#endif
-	return (instance);
-}
-
-int
-lpfc_DetectInstance(int instance,
-		    struct pci_dev *pdev, uint type, Scsi_Host_Template * tmpt)
-{
-
-	/* PCI_SUBSYSTEM_IDS supported */
-	while ((pdev = pci_find_subsys(PCI_VENDOR_ID_EMULEX, type,
-				       PCI_ANY_ID, PCI_ANY_ID, pdev))) {
-		if (pci_enable_device(pdev)) {
-			continue;
-		}
-		if (pci_request_regions(pdev, LPFC_DRIVER_NAME)) {
-			printk("lpfc pci I/O region is already in use. \n");
-			printk
-			    ("a driver for lpfc is already loaded on this system\n");
-			continue;
-		}
-
-		if (lpfc_linux_attach(instance, tmpt, pdev)) {
-			pci_release_regions(pdev);
-			continue;
-		}
-		instance++;
-	}
-
-	return (instance);
-}
-#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) */
 
 int
 lpfc_diag_init(void)
@@ -456,27 +265,6 @@ lpfc_diag_init(void)
 	return (0);
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-int
-lpfc_release(struct Scsi_Host *host)
-{
-	elxHBA_t *phba;
-	int instance;
-	phba = (elxHBA_t *) host->hostdata[0];
-	instance = phba->brd_no;
-
-	/*
-	 * detach the board 
-	 */
-	lpfc_linux_detach(instance);
-
-	lpfc_diag_uninit();
-
-	return (0);
-}
-#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) */
-
 int
 lpfc_diag_uninit(void)
 {
@@ -730,11 +518,7 @@ lpfc_linux_attach(int instance, Scsi_Hos
 	/* 
 	 * Register this board
 	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	host = scsi_register(tmpt, sizeof (unsigned long));
-#else
 	host = scsi_host_alloc(tmpt, sizeof (unsigned long));
-#endif
 	plxhba->host = host;
 
 	host->can_queue = clp[ELX_CFG_DFT_HBA_Q_DEPTH].a_current;
@@ -790,24 +574,13 @@ lpfc_linux_attach(int instance, Scsi_Hos
 	 * Queue depths per lun
 	 */
 	host->cmd_per_lun = 1;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-	host->select_queue_depths = lpfc_select_queue_depth;
-#endif
-
 	/*
 	 * Save a pointer to device control in host and increment board
 	 */
 	host->hostdata[0] = (unsigned long)phba;
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4)) && \
-      LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
-	scsi_set_pci_device(host, pdev);
-#endif
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 	pci_set_drvdata(pdev, host);
 	scsi_add_host(host, &pdev->dev);
 	scsi_scan_host(host);
-#endif
 
 	return (0);
 }
@@ -831,12 +604,8 @@ lpfc_linux_detach(int instance)
 	}
 	plxhba = (LINUX_HBA_t *) phba->pHbaOSEnv;
 	psli = &phba->sli;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	scsi_unregister(plxhba->host);
-#else
 	scsi_remove_host(plxhba->host);
 	scsi_host_put(plxhba->host);
-#endif
 
 	ELX_DRVR_LOCK(phba, iflag);
 	elx_sli_hba_down(phba);	/* Bring down the SLI Layer */
@@ -1175,7 +944,6 @@ lpfc_info(struct Scsi_Host *host)
 	return (buf);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION (2,6,0)
 
 static int
 lpfc_proc_info(struct Scsi_Host *host,
@@ -1190,7 +958,6 @@ lpfc_proc_info(struct Scsi_Host *host,
 		return sprintf(buffer, "%s\n", lpfc_info(host));
 	}
 }
-#endif
 
 uint32_t
 lpfc_register_intr(elxHBA_t * arg)
@@ -1366,20 +1133,9 @@ lpfc_reset_bus_handler(Scsi_Cmnd * cmnd)
 	unsigned long iflag;
 	int rc, tgt, lun;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-	/* release io_request_lock */
-	spin_unlock_irq(&io_request_lock);
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	phba = (elxHBA_t *) cmnd->device->host->hostdata[0];
 	tgt = cmnd->device->id;
 	lun = cmnd->device->lun;
-#else
-	phba = (elxHBA_t *) cmnd->host->hostdata[0];
-	tgt = cmnd->target;
-	lun = cmnd->lun;
-#endif
 	ELX_DRVR_LOCK(phba, iflag);
 
 	rc = 0;
@@ -1395,31 +1151,11 @@ lpfc_reset_bus_handler(Scsi_Cmnd * cmnd)
 		       tgt, lun, rc);	/* end varargs */
 
 	ELX_DRVR_UNLOCK(phba, iflag);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-	/* reacquire io_request_lock for midlayer */
-	spin_lock_irq(&io_request_lock);
-#endif
 
 	return (SUCCESS);
 
 }				/* lpfc_reset_bus_handler */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-void
-lpfc_select_queue_depth(struct Scsi_Host *host, Scsi_Device * scsi_devs)
-{
-	Scsi_Device *device;
-	elxHBA_t *phba;
-
-	phba = (elxHBA_t *) host->hostdata[0];
-	for (device = scsi_devs; device != NULL; device = device->next) {
-		if (device->host == host)
-			lpfc_device_queue_depth(phba, device);
-	}
-}
-#else
 int
 lpfc_slave_configure(Scsi_Device * scsi_devs)
 {
@@ -1428,16 +1164,12 @@ lpfc_slave_configure(Scsi_Device * scsi_
 	lpfc_device_queue_depth(phba, scsi_devs);
 	return 0;
 }
-#endif
 
 int
 lpfc_device_queue_depth(elxHBA_t * phba, Scsi_Device * device)
 {
 
 	if (device->tagged_supported) {
-#if LINUX_VERSION_CODE 	< KERNEL_VERSION(2,6,0)
-		device->tagged_queue = 1;
-#endif
 		device->current_tag = 0;
 		device->queue_depth = 32;	/* Substitute configuration parameter */
 	} else {
@@ -1492,24 +1224,16 @@ lpfcdiag_ioctl(struct inode *inode,
 int
 lpfcdiag_open(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	MOD_INC_USE_COUNT;
-#else
 	if (!try_module_get(THIS_MODULE)) {
 		return (-ENODEV);
 	}
-#endif
 	return (0);
 }
 
 int
 lpfcdiag_release(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	MOD_DEC_USE_COUNT;
-#else
 	module_put(THIS_MODULE);
-#endif
 	return (0);
 }
 
@@ -2966,9 +2690,6 @@ lpfc_ipioctl(int cmd, void *s)
 
 					/* New-style flags */
 					dev->flags = IFF_BROADCAST;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-					dev_init_buffers(dev);
-#endif
 					register_netdevice(dev);
 					rtnl_unlock();
 
@@ -9090,7 +8811,6 @@ fc_get_cfg_param(int brd, int param)
 	return (value);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static struct pci_device_id lpfc_id_table[] __devinitdata = {
 	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_VIPER, PCI_ANY_ID, PCI_ANY_ID, 0,
 	 0, 0UL},
@@ -9208,12 +8928,6 @@ lpfc_exit(void)
 	pci_unregister_driver(&lpfc_driver);
 	lpfc_diag_uninit();
 }
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-#include "scsi_module.c"
-#else
 module_init(lpfc_init);
 module_exit(lpfc_exit);
-#endif
 MODULE_LICENSE("GPL");
diff -purN linux-2.6.4/drivers/scsi/lpfc/lpfcLINUXlan.c linux-2.6.4.emulex/drivers/scsi/lpfc/lpfcLINUXlan.c
--- linux-2.6.4/drivers/scsi/lpfc/lpfcLINUXlan.c	2004-03-21 10:04:58.000000000 +0100
+++ linux-2.6.4.emulex/drivers/scsi/lpfc/lpfcLINUXlan.c	2004-03-21 10:15:43.000000000 +0100
@@ -36,11 +36,7 @@
 #include <linux/string.h>
 #include <linux/init.h>
 #include <linux/errno.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-#include <linux/blk.h>
-#else
 #include <linux/blkdev.h>
-#endif
 #include <linux/string.h>
 #include <linux/ioport.h>
 #include <linux/pci.h>
@@ -56,11 +52,7 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <asm/irq.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
 #include <linux/spinlock.h>
-#else
-#include <asm/spinlock.h>
-#endif
 #include <linux/smp.h>
 #include <asm/byteorder.h>
 
@@ -105,18 +97,10 @@ extern int lpfc_xmit(elxHBA_t *, struct 
 extern int lpfc_ipioctl(int, void *);
 
 void lpfn_receive(elxHBA_t *, void *, uint32_t);
-#ifdef MODVERSIONS
 EXPORT_SYMBOL(lpfn_receive);
-#else
-EXPORT_SYMBOL_NOVERS(lpfn_receive);
-#endif				/* MODVERSIONS */
 
 int lpfn_probe(void);
-#ifdef MODVERSIONS
 EXPORT_SYMBOL(lpfn_probe);
-#else
-EXPORT_SYMBOL_NOVERS(lpfn_probe);
-#endif				/* MODVERSIONS */
 
 static int
 lpfn_open(NETDEVICE * dev)
@@ -300,15 +284,11 @@ lpfn_coalesce_skbuff(elxHBA_t * phba, vo
 		while (tmp_ip_buff) {
 			tmp_skb = (struct sk_buff *)tmp_ip_buff->ipbuf;
 			tmp_ip_buff->ipbuf = NULL;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 			if (in_irq()) {
 				dev_kfree_skb_irq(tmp_skb);
 			} else {
 				dev_kfree_skb(tmp_skb);
 			}
-#else
-			dev_kfree_skb(tmp_skb);
-#endif
 			tmp_ip_buff = (DMABUFIP_t *) tmp_ip_buff->dma.next;
 		}
 		return;
@@ -326,15 +306,11 @@ lpfn_coalesce_skbuff(elxHBA_t * phba, vo
 		tmp_ip_buff = (DMABUFIP_t *) tmp_ip_buff->dma.next;
 
 		/* Free the skb here */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 		if (in_irq()) {
 			dev_kfree_skb_irq(tmp_skb);
 		} else {
 			dev_kfree_skb(tmp_skb);
 		}
-#else
-		dev_kfree_skb(tmp_skb);
-#endif
 
 	}
 
diff -purN linux-2.6.4/drivers/scsi/lpfc/prod_linux.c linux-2.6.4.emulex/drivers/scsi/lpfc/prod_linux.c
--- linux-2.6.4/drivers/scsi/lpfc/prod_linux.c	2004-03-21 10:04:59.000000000 +0100
+++ linux-2.6.4.emulex/drivers/scsi/lpfc/prod_linux.c	2004-03-21 10:19:06.000000000 +0100
@@ -48,12 +48,8 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <asm/irq.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 #include <scsi/scsi_device.h>
 #include <asm/pci.h>
-#else
-#include "sd.h"			/* From drivers/scsi */
-#endif
 
 #include "hosts.h"
 
@@ -356,24 +352,14 @@ elx_printf_log_msgblk(int brdno, msgLogD
 	case ELX_LOG_MSG_TYPE_INFO:
 	case ELX_LOG_MSG_TYPE_WARN:
 		/* These LOG messages appear in LOG file only */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-		printk(KERN_INFO "%s%d:%04d:%s\n", elx_drvr_name, ddiinst,
-		       msg->msgNum, str);
-#else
 		dev_info(&((plxhba->pcidev)->dev), "%d:%04d:%s\n", ddiinst,
 			 msg->msgNum, str);
-#endif
 		break;
 	case ELX_LOG_MSG_TYPE_ERR_CFG:
 	case ELX_LOG_MSG_TYPE_ERR:
 		/* These LOG messages appear on the monitor and in the LOG file */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-		printk(KERN_WARNING "%s%d:%04d:%s\n", elx_drvr_name, ddiinst,
-		       msg->msgNum, str);
-#else
 		dev_warn(&((plxhba->pcidev)->dev), "%d:%04d:%s\n", ddiinst,
 			 msg->msgNum, str);
-#endif
 		break;
 	case ELX_LOG_MSG_TYPE_PANIC:
 		panic("%s%d:%04d:%s\n", elx_drvr_name, ddiinst, msg->msgNum,
@@ -484,15 +470,9 @@ elx_free(elxHBA_t * phba, MBUF_INFO_t * 
 		}
 		break;
 	case ELX_MBUF_PHYSONLY:	/* LNX - convert virtual to dma-able */
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,12)
-		pci_unmap_single(plxhba->pcidev,
-				 buf_info->phys, buf_info->size,
-				 PCI_DMA_BIDIRECTIONAL);
-#else
 		pci_unmap_page(plxhba->pcidev,
 			       buf_info->phys, buf_info->size,
 			       PCI_DMA_BIDIRECTIONAL);
-#endif
 		break;
 	}
 }
@@ -955,18 +935,11 @@ elx_cnt_write_pci(elxHBA_t * phba,
 	}
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 int
 elx_biosparam(struct scsi_device *psdev,
 	      struct block_device *pbdev, sector_t capacity, int ip[])
 {
 	int size = capacity;
-#else
-int
-elx_biosparam(Disk * disk, kdev_t n, int ip[])
-{
-	int size = disk->capacity;
-#endif
 
 	ip[0] = 64;
 	ip[1] = 32;
@@ -1206,26 +1179,8 @@ elx_pci_map(elxHBA_t * phba, void *virt,
 {
 	dma_addr_t physaddr;
 	LINUX_HBA_t *plxhba;
-#ifdef KERNEL_HAS_PCI_MAP_PAGE
-	struct page *page;
-	unsigned long offset;
-
-	plxhba = (LINUX_HBA_t *) phba->pHbaOSEnv;
-
-	page = virt_to_page(virt);
-	offset = ((unsigned long)virt & ~PAGE_MASK);
-	physaddr = 0;
-	while (physaddr == 0) {
-		physaddr =
-		    pci_map_page(plxhba->pcidev, page, offset, size, dir);
-#ifndef powerpc
-		break;
-#endif				/* endif powerpc */
-	}
-#else
 	plxhba = (LINUX_HBA_t *) phba->pHbaOSEnv;
 	physaddr = pci_map_single(plxhba->pcidev, virt, size, dir);
-#endif				/* KERNEL_HAS_PCI_MAP_PAGE */
 	return (uint64_t) physaddr;
 }
 
@@ -1243,10 +1198,6 @@ lpfc_get_pkt_data(void *buf)
 }
 
 /* Includes. */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-#include <linux/blk.h>
-#else
-#endif
 #include <scsi/scsi.h>
 #include <scsi.h>
 
@@ -1656,31 +1607,13 @@ elx_queuecommand(Scsi_Cmnd * cmnd, void 
 	elxCfgParam_t *clp;
 	struct Scsi_Host *host;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	host = cmnd->device->host;
-#else
-	host = cmnd->host;
-#endif
 
 	phba = (elxHBA_t *) host->hostdata[0];
 	clp = &phba->config[0];
 	plxhba = (LINUX_HBA_t *) phba->pHbaOSEnv;
 	ELX_DRVR_LOCK(phba, iflag);
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	/* 
-	   if the hba is in blocked state and the command is a retry 
-	   queue the command and retry success 
-	 */
-	if (plxhba->in_retry) {
-		cmnd->scsi_done = done;
-		cmnd->reset_chain = plxhba->cmnd_retry_list;
-		plxhba->cmnd_retry_list = cmnd;
-		cmnd->host_scribble = 0;
-		ELX_DRVR_UNLOCK(phba, iflag);
-		return (0);
-	}
-#endif
 
 	elx_cmd = elx_get_scsi_buf(phba);
 	if (elx_cmd == 0) {
@@ -1698,15 +1631,9 @@ elx_queuecommand(Scsi_Cmnd * cmnd, void 
 			return (1);
 		}
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	elx_cmd->scsi_bus = cmnd->device->channel;
 	elx_cmd->scsi_target = cmnd->device->id;
 	elx_cmd->scsi_lun = cmnd->device->lun;
-#else
-	elx_cmd->scsi_bus = cmnd->channel;
-	elx_cmd->scsi_target = cmnd->target;
-	elx_cmd->scsi_lun = cmnd->lun;
-#endif
 
 	targetp = lpfc_find_target(phba, elx_cmd->scsi_target);
 	if ((targetp) && (elx_cmd->scsi_lun >= targetp->max_lun)) {
@@ -1797,17 +1724,7 @@ elx_abort_handler(Scsi_Cmnd * cmnd)
 	unsigned long iflag;
 	int rc;
 	LINUX_HBA_t *plxhba;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	Scsi_Cmnd *prev_cmnd;
-
-	/* release io_request_lock */
-	spin_unlock_irq(&io_request_lock);
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	phba = (elxHBA_t *) cmnd->device->host->hostdata[0];
-#else
-	phba = (elxHBA_t *) cmnd->host->hostdata[0];
-#endif
 	plxhba = (LINUX_HBA_t *) phba->pHbaOSEnv;
 
 	ELX_DRVR_LOCK(phba, iflag);
@@ -1819,26 +1736,6 @@ elx_abort_handler(Scsi_Cmnd * cmnd)
 	   list.
 	 */
 	if (!elx_cmd) {
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-		if (plxhba->cmnd_retry_list) {
-			if (plxhba->cmnd_retry_list == cmnd) {
-				plxhba->cmnd_retry_list = cmnd->reset_chain;
-
-			} else {
-				prev_cmnd = plxhba->cmnd_retry_list;
-
-				while ((prev_cmnd->reset_chain != NULL) &&
-				       (prev_cmnd->reset_chain != cmnd))
-					prev_cmnd = prev_cmnd->reset_chain;
-
-				if (prev_cmnd->reset_chain)
-					prev_cmnd->reset_chain =
-					    cmnd->reset_chain;
-			}
-
-		}
-#endif
 		return (0);
 	}
 
@@ -1858,11 +1755,6 @@ elx_abort_handler(Scsi_Cmnd * cmnd)
 		       elx_cmd->scsi_target, elx_cmd->scsi_lun, elx_cmd->status, elx_cmd->result);	/* end varargs */
 
 	ELX_DRVR_UNLOCK(phba, iflag);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-	/* reacquire io_request_lock for midlayer */
-	spin_lock_irq(&io_request_lock);
-#endif
 
 	return ((rc == 0) ? SUCCESS : FAILURE);
 
@@ -1877,16 +1769,7 @@ elx_reset_lun_handler(Scsi_Cmnd * cmnd)
 	ELX_SCSI_BUF_t *elx_cmd;
 	unsigned long iflag;
 	int rc;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-	/* release io_request_lock */
-	spin_unlock_irq(&io_request_lock);
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	phba = (elxHBA_t *) cmnd->device->host->hostdata[0];
-#else
-	phba = (elxHBA_t *) cmnd->host->hostdata[0];
-#endif
 	ELX_DRVR_LOCK(phba, iflag);
 	elx_cmd = (ELX_SCSI_BUF_t *) cmnd->host_scribble;
 
@@ -1908,12 +1791,6 @@ elx_reset_lun_handler(Scsi_Cmnd * cmnd)
 
 	ELX_DRVR_UNLOCK(phba, iflag);
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-
-	/* reacquire io_request_lock for midlayer */
-	spin_lock_irq(&io_request_lock);
-#endif
-
 	return ((rc == 0) ? SUCCESS : FAILURE);
 
 }
@@ -2345,20 +2222,11 @@ elx_iodone(elxHBA_t * phba, ELX_SCSI_BUF
 			     lnx_cmnd->use_sg, scsi_to_pci_dma_dir(datadir));
 	} else if ((lnx_cmnd->request_bufflen)
 		   && (elx_cmd->OS_io_info.nonsg_phys)) {
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,12)
-		pci_unmap_single(plxhba->pcidev,
-				 (uint64_t) ((unsigned long)(elx_cmd->
-							     OS_io_info.
-							     nonsg_phys)),
-				 lnx_cmnd->request_bufflen,
-				 scsi_to_pci_dma_dir(datadir));
-#else
 		pci_unmap_page(plxhba->pcidev,
 			       (uint64_t) ((unsigned long)(elx_cmd->OS_io_info.
 							   nonsg_phys)),
 			       lnx_cmnd->request_bufflen,
 			       scsi_to_pci_dma_dir(datadir));
-#endif
 	}
 
 	elx_free_scsi_buf(elx_cmd);
@@ -2417,27 +2285,8 @@ void
 elx_unblock_requests(elxHBA_t * phba)
 {
 	LINUX_HBA_t *plxhba = (LINUX_HBA_t *) phba->pHbaOSEnv;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	Scsi_Cmnd *cmnd, *next_cmnd;
-#endif
 	unsigned long iflag;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	cmnd = plxhba->cmnd_retry_list;
-	plxhba->in_retry = 0;
-	while (cmnd) {
-		next_cmnd = cmnd->reset_chain;
-		cmnd->reset_chain = 0;
-		cmnd->result = ScsiResult(DID_RESET, 0);
-
-		ELX_DRVR_UNLOCK(phba, iflag);
-		cmnd->scsi_done(cmnd);
-		ELX_DRVR_LOCK(phba, iflag);
-
-		cmnd = next_cmnd;
-	}
-	plxhba->cmnd_retry_list = 0;
-#endif
 	iflag = phba->iflag;
 
 	ELX_DRVR_UNLOCK(phba, iflag);
diff -purN linux-2.6.4/drivers/scsi/lpfc/prod_os.h linux-2.6.4.emulex/drivers/scsi/lpfc/prod_os.h
--- linux-2.6.4/drivers/scsi/lpfc/prod_os.h	2004-03-21 10:04:59.000000000 +0100
+++ linux-2.6.4.emulex/drivers/scsi/lpfc/prod_os.h	2004-03-21 10:20:40.000000000 +0100
@@ -20,15 +20,9 @@
 
 #include "elx_util.h"
 
-#if defined(RED_HAT_LINUX_KERNEL) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9))
-#define KERNEL_HAS_PCI_MAP_PAGE
-#endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,12))
-#define KERNEL_HAS_PCI_MAP_PAGE
-#endif
 
 #ifdef powerpc
-#include <asm/pci_dma.h>
+#include <asm/iommu.h>
 /* On powerpc, 0 is a valid physical address */
 #ifdef NO_TCE
 #define INVALID_PHYS       NO_TCE
@@ -105,22 +99,10 @@ typedef uint32_t elx_lun_t;
 typedef struct sc_buf T_SCSIBUF;
 #define SET_ADAPTER_STATUS(bp, val) bp->general_card_status = val;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
 #define  NETDEVICE struct net_device
-#else
-#define  NETDEVICE struct device
-#endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43)
-#define netif_start_queue(dev)  clear_bit(0, (void*)&dev->tbusy)
-#define netif_stop_queue(dev)   set_bit(0, (void*)&dev->tbusy)
-#define netdevice_start(dev)    dev->start = 1
-#define netdevice_stop(dev)     dev->start = 0
-#define dev_kfree_skb_irq(a)    dev_kfree_skb(a)
-#else
 #define netdevice_start(dev)
 #define netdevice_stop(dev)
-#endif
 
 /* forward declaration for compiler */
 struct elxHBA;
@@ -142,11 +124,5 @@ struct lpfn_probe {
 #define LPFN_DFC    3
 
 /* SCSI Layer io_request locking macros */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
- /* io_request_lock is not present in 2.6.0 */
-#define LPFC_LOCK_SCSI_DONE    spin_lock_irqsave(&io_request_lock, sflag)
-#define LPFC_UNLOCK_SCSI_DONE  spin_unlock_irqrestore(&io_request_lock, sflag)
-#else
 #define LPFC_LOCK_SCSI_DONE    spin_lock_irqsave(host->host_lock, sflag)
 #define LPFC_UNLOCK_SCSI_DONE  spin_unlock_irqrestore(host->host_lock, sflag)
-#endif
