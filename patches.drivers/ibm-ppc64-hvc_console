diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/hvconsole.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/hvconsole.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/hvconsole.c	2004-02-05 21:10:52.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/hvconsole.c	2004-04-22 06:16:00.000000000 +0000
@@ -19,16 +19,232 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
+/* TODO:
+ * finish DTR/CD ioctls
+ * use #defines instead of "16" "12" etc
+ * comment lack of locking
+ */
+
 #include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/time.h>
+#include <linux/ctype.h>
+#include <linux/interrupt.h>
+#include <asm/delay.h>
 #include <asm/hvcall.h>
 #include <asm/prom.h>
 #include <asm/hvconsole.h>
+#include <asm/termios.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#define __ALIGNED__	__attribute__((__aligned__(8)))
+
+#define HVCS_LONG_INVALID	0xFFFFFFFFFFFFFFFF
+
+struct vtty_struct {
+	uint32_t vtermno;
+	int (*get_chars)(struct vtty_struct *vtty, char *buf, int count);
+	int (*put_chars)(struct vtty_struct *vtty, const char *buf, int count);
+	int (*tiocmget)(struct vtty_struct *vtty);
+	int (*tiocmset)(struct vtty_struct *vtty, uint16_t set, uint16_t clear);
+	uint16_t seqno; /* HVSI packet sequence number */
+	uint16_t mctrl;
+	int irq;
+};
+static struct vtty_struct vttys[MAX_NR_HVC_CONSOLES];
+
+#define WAIT_LOOPS 10000
+#define WAIT_USECS 100
+
+#define HVSI_VERSION 1
+
+#define VS_DATA_PACKET_HEADER           0xff
+#define VS_CONTROL_PACKET_HEADER        0xfe
+#define VS_QUERY_PACKET_HEADER          0xfd
+#define VS_QUERY_RESPONSE_PACKET_HEADER 0xfc
+
+/* control verbs */
+#define VSV_SET_MODEM_CTL    1 /* to service processor only */
+#define VSV_MODEM_CTL_UPDATE 2 /* from service processor only */
+#define VSV_CLOSE_PROTOCOL   3
+
+/* query verbs */
+#define VSV_SEND_VERSION_NUMBER 1
+#define VSV_SEND_MODEM_CTL_STATUS 2
+
+/* yes, these masks are not consecutive. */
+#define HVSI_TSDTR 0x1
+#define HVSI_TSCD  0x20
+
+struct hvsi_header {
+	uint8_t  type;
+	uint8_t  len;
+	uint16_t seqno;
+} __attribute__((packed));
+
+struct hvsi_control {
+	uint8_t  type;
+	uint8_t  len;
+	uint16_t seqno;
+	uint16_t verb;
+	/* optional depending on verb: */
+	uint32_t word;
+	uint32_t mask;
+} __attribute__((packed));
+
+struct hvsi_query {
+	uint8_t  type;
+	uint8_t  len;
+	uint16_t seqno;
+	uint16_t verb;
+} __attribute__((packed));
+
+struct hvsi_query_response {
+	uint8_t  type;
+	uint8_t  len;
+	uint16_t seqno;
+	uint16_t verb;
+	uint16_t query_seqno;
+	union {
+		uint8_t  version;
+		uint32_t mctrl_word;
+	} u;
+} __attribute__((packed));
+
+/* ring buffer stuff: */
+struct packet_desc {
+	union {
+		struct hvsi_header hdr;
+		char pkt[256]; /* console_initcall is pre-mem_init(), so no kmalloc */
+	} data;
+	unsigned int want;
+	unsigned int got;
+};
+#define N_PACKETS 4
+static struct packet_desc ring[N_PACKETS];
+static struct packet_desc *write=ring; /* next packet to write to */
+static struct packet_desc *read=ring;  /* next packet to read from */
+
+static struct packet_desc *next_desc(struct packet_desc *cur)
+{
+	if ((cur+1) > ring + (N_PACKETS-1))
+		return ring;
+	return (cur+1);
+}
+
+static int desc_hdr_done(struct packet_desc *desc)
+{
+	if (desc->got < sizeof(struct hvsi_header))
+		return 0;
+	return 1;
+}
+
+static unsigned int desc_want(struct packet_desc *desc)
+{
+	if (desc_hdr_done(desc))
+		return desc->data.hdr.len;
+	else
+		return UINT_MAX;
+}
+
+static int desc_done(struct packet_desc *desc)
+{
+	if (!desc_hdr_done(desc) || (desc->got < desc->want))
+		return 0;
+	return 1;
+}
+
+static int desc_overflow(struct packet_desc *desc)
+{
+	int overflow = desc->got - desc->want;
+	if (desc_hdr_done(desc) && (overflow > 0))
+		return overflow;
+	return 0;
+}
 
-int hvc_get_chars(int index, char *buf, int count)
+static void desc_clear(struct packet_desc *desc)
+{
+	desc->got = desc->want = 0;
+}
+
+/* these only work on well-formed and complete packets */
+
+static inline int hdrlen(const struct hvsi_header *pkt)
+{
+	const int lengths[] = { 4, 6, 6, 8, };
+	int index = VS_DATA_PACKET_HEADER - pkt->type;
+
+	return lengths[index];
+}
+
+static inline uint8_t *payload(const struct hvsi_header *pkt)
+{
+	return (uint8_t *)pkt + hdrlen(pkt);
+}
+
+static inline int len_packet(const struct hvsi_header *pkt)
+{
+	return (int)pkt->len;
+}
+
+static inline int len_payload(const struct hvsi_header *pkt)
+{
+	return len_packet(pkt) - hdrlen(pkt);
+}
+
+static void dump_packet(struct hvsi_header *pkt)
+{
+	int i;
+	char *data = payload(pkt);
+
+	printk("type 0x%x, len %i, seqno %i:", pkt->type, pkt->len, pkt->seqno);
+
+	if (len_payload(pkt))
+		printk("\n     ");
+	for (i=0; i < len_payload(pkt); i++)
+		printk("%.2x", data[i]);
+
+	if (len_payload(pkt))
+		printk("\n     ");
+	for (i=0; i < len_payload(pkt); i++) {
+		if (isprint(data[i]))
+			printk(" %c", data[i]);
+		else
+			printk("..");
+	}
+	printk("\n");
+}
+
+#ifdef DEBUG
+static void dump_ring(void)
+{
+	int i;
+	for (i=0; i < N_PACKETS; i++) {
+		struct packet_desc *desc = &ring[i];
+		if (read == desc)
+			printk("r");
+		else
+			printk(" ");
+		if (write == desc)
+			printk("w");
+		else
+			printk(" ");
+		printk(" ");
+		printk("desc %i: want %i got %i\n", i, desc->want, desc->got);
+		printk("    ");
+		dump_packet(&desc->data.hdr);
+	}
+}
+#endif /* DEBUG */
+
+/* normal hypervisor virtual console code */
+int hvterm_get_chars(uint32_t vtermno, char *buf, int count)
 {
 	unsigned long got;
 
-	if (plpar_hcall(H_GET_TERM_CHAR, index, 0, 0, 0, &got,
+	if (plpar_hcall(H_GET_TERM_CHAR, vtermno, 0, 0, 0, &got,
 		(unsigned long *)buf, (unsigned long *)buf+1) == H_Success) {
 		/*
 		 * Work around a HV bug where it gives us a null
@@ -49,40 +265,685 @@ int hvc_get_chars(int index, char *buf, 
 	}
 	return 0;
 }
+EXPORT_SYMBOL(hvterm_get_chars);
+
+/* wrapper exists just so that hvterm_get_chars() is callable by outside
+ * drivers without a vtty_struct */
+int hvc_hvterm_get_chars(struct vtty_struct *vtty, char *buf, int count)
+{
+	return hvterm_get_chars(vtty->vtermno, buf, count);
+}
 
-int hvc_put_chars(int index, const char *buf, int count)
+int hvterm_put_chars(uint32_t vtermno, const char *buf, int count)
 {
 	unsigned long *lbuf = (unsigned long *) buf;
 	long ret;
 
-	ret = plpar_hcall_norets(H_PUT_TERM_CHAR, index, count, lbuf[0],
+	ret = plpar_hcall_norets(H_PUT_TERM_CHAR, vtermno, count, lbuf[0],
 				 lbuf[1]);
 	if (ret == H_Success)
 		return count;
 	if (ret == H_Busy)
 		return 0;
-	return -1;
+	return -EIO;
+}
+EXPORT_SYMBOL(hvterm_put_chars);
+
+/* wrapper exists just so that hvterm_put_chars() is callable by outside
+ * drivers without a vtty_struct */
+int hvc_hvterm_put_chars(struct vtty_struct *vtty, const char *buf, int count)
+{
+	return hvterm_put_chars(vtty->vtermno, buf, count);
+}
+
+/* Host Virtual Serial Interface (HVSI) code */
+
+static int hvsi_read(struct vtty_struct *vtty, char *buf, int count)
+{
+	unsigned long got;
+
+	if (plpar_hcall(H_GET_TERM_CHAR, vtty->vtermno, 0, 0, 0, &got,
+		(unsigned long *)buf, (unsigned long *)buf+1) == H_Success) {
+		return got;
+	}
+	return 0;
+}
+
+/* like memcpy, but only copy at most a single packet from the src bytestream */
+static int copy_packet(uint8_t *dest, uint8_t *src, uint8_t len)
+{
+	int copylen;
+
+	if (len == 1) {
+		/* we don't have the len header */
+		*dest = *src;
+		return 1;
+	}
+
+	/* if we have more than one packet here, only copy the first */
+	copylen = min(len_packet((struct hvsi_header *)src), (int)len);
+	memcpy(dest, src, copylen);
+	return copylen;
+}
+
+/* load up ring buffers */
+static int hvsi_load_chunk(struct vtty_struct *vtty)
+{
+	struct packet_desc *old = write;
+	unsigned int chunklen;
+	unsigned int overflow;
+
+	/* copy up to 16 bytes into the write buffer */
+	chunklen = hvsi_read(vtty, write->data.pkt + write->got, 16);
+	if (!chunklen)
+		return 0;
+	write->got += chunklen;
+	write->want = desc_want(write);
+
+	overflow = desc_overflow(write);
+	while (overflow) {
+		/* copied too much into 'write'; memcpy it into the next buffers */
+		int nextlen;
+		write = next_desc(write);
+
+		nextlen = copy_packet(write->data.pkt, old->data.pkt + old->want,
+			overflow);
+		write->got = nextlen;
+		write->want = desc_want(write);
+		overflow -= nextlen;
+	}
+	if (desc_done(write))
+		write = next_desc(write);
+	return 1;
+}
+
+/* keep reading from hypervisor until there's no more */
+static void hvsi_load_buffers(struct vtty_struct *vtty)
+{
+	/* XXX perhaps we should limit this */
+	while (hvsi_load_chunk(vtty)) {
+		if (write == read) {
+			/* we've filled all our ring buffers; let the hypervisor queue
+			 * the rest for us */
+			break;
+		}
+	}
+}
+
+static int hvsi_recv_control(struct vtty_struct *vtty, struct hvsi_control *pkt)
+{
+	int ret = 0;
+	
+	//dump_packet((struct hvsi_header *)pkt);
+	
+	switch (pkt->verb) {
+		case VSV_MODEM_CTL_UPDATE:
+			if ((pkt->word & HVSI_TSCD) == 0) {
+				/* CD went away; no more connection */
+				vtty->mctrl &= TIOCM_CD;
+				ret = -EPIPE;
+			}
+			break;
+		case VSV_CLOSE_PROTOCOL:
+			/* XXX handle this by reopening on open/read/write() ? */
+			panic("%s: service processor closed HVSI connection!\n", __FUNCTION__);
+			break;
+		default:
+			printk(KERN_WARNING "unknown HVSI control packet: ");
+			dump_packet((struct hvsi_header *)pkt);
+			break;
+	}
+	return ret;
+}
+
+/* transfer from ring buffers to caller's buffer */
+static int hvsi_deliver(struct vtty_struct *vtty, uint8_t *buf, int buflen)
+{
+	int written = 0;
+	int ret;
+
+	for (; (read != write) && (buflen > 0); read = next_desc(read)) {
+		struct hvsi_header *pkt = &read->data.hdr;
+		int size;
+
+#ifdef DEBUG
+		dump_ring();
+#endif
+
+		switch (pkt->type) {
+			case VS_DATA_PACKET_HEADER:
+				size = min(len_payload(pkt), buflen);
+				memcpy(buf, payload(pkt), size);
+				buf += size;
+				buflen -= size;
+				written += size;
+				break;
+			case VS_CONTROL_PACKET_HEADER:
+				ret = hvsi_recv_control(vtty, (struct hvsi_control *)pkt);
+				/* if we got an error (like CD dropped), stop now.
+				 * otherwise keep dispatching packets */
+				if (ret < 0) {
+					desc_clear(read);
+					read = next_desc(read);
+					return ret;
+				}
+				break;
+			default:
+				printk(KERN_WARNING "unknown HVSI packet: ");
+				dump_packet(pkt);
+				break;
+		}
+		desc_clear(read);
+	}
+
+	return written;
+}
+
+static int hvsi_get_chars(struct vtty_struct *vtty, char *databuf, int count)
+{
+	hvsi_load_buffers(vtty); /* get pending data */
+	return hvsi_deliver(vtty, databuf, count); /* hand it up */
+}
+
+static struct hvsi_header *search_for_packet(struct vtty_struct *vtty, int type)
+{
+	/* bring in queued packets */
+	hvsi_load_buffers(vtty);
+
+	/* look for the version query response packet */
+	for (; read != write; read = next_desc(read)) {
+		struct hvsi_header *pkt = &read->data.hdr;
+
+		if (pkt->type == type) {
+			desc_clear(read);
+			read = next_desc(read);
+			return pkt;
+		}
+		printk("%s: ignoring packet while waiting for type 0x%x:\n",
+			__FUNCTION__, type);
+		dump_packet(pkt);
+	}
+
+	return NULL;
+}
+
+static int wait_for_packet(struct vtty_struct *vtty, struct hvsi_header **hdr,
+	int type)
+{
+	struct hvsi_header *found;
+	int count = 0;
+
+	do {
+		if (count++ > WAIT_LOOPS)
+			return -EIO;
+		udelay(WAIT_USECS);
+		found = search_for_packet(vtty, type);
+	} while (!found);
+
+	*hdr = found;
+	return 0;
+}
+
+static int hvsi_query(struct vtty_struct *vtty, uint16_t verb)
+{
+	struct hvsi_query query __ALIGNED__ = {
+		.type = VS_QUERY_PACKET_HEADER,
+		.len = sizeof(struct hvsi_query),
+	};
+	int wrote;
+
+	query.seqno = vtty->seqno++;
+	query.verb = verb;
+	wrote = hvc_hvterm_put_chars(vtty, (char *)&query, query.len);
+	if (wrote != query.len) {
+		printk(KERN_ERR "%s: couldn't send query!\n", __FUNCTION__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/* respond to service processor's version query */
+static int hvsi_version_respond(struct vtty_struct *vtty, uint16_t query_seqno)
+{
+	struct hvsi_query_response response __ALIGNED__ = {
+		.type = VS_QUERY_RESPONSE_PACKET_HEADER,
+		.len = sizeof(struct hvsi_query_response),
+		.verb = VSV_SEND_VERSION_NUMBER,
+		.u.version = HVSI_VERSION,
+	};
+	int wrote;
+
+	response.seqno = vtty->seqno++;
+	response.query_seqno = query_seqno+1,
+	wrote = hvc_hvterm_put_chars(vtty, (char *)&response, response.len);
+	if (wrote != response.len) {
+		printk(KERN_ERR "%s: couldn't send query response!\n", __FUNCTION__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int hvsi_get_mctrl(struct vtty_struct *vtty)
+{
+	struct hvsi_header *hdr;
+	int ret = 0;
+	uint16_t mctrl;
+
+	if (hvsi_query(vtty, VSV_SEND_MODEM_CTL_STATUS)) {
+		ret = -EIO;
+		goto out;
+	}
+	if (wait_for_packet(vtty, &hdr, VS_QUERY_RESPONSE_PACKET_HEADER)) {
+		ret = -EIO;
+		goto out;
+	}
+	/* XXX see if it's the right response */
+
+	vtty->mctrl = 0;
+
+	mctrl = ((struct hvsi_query_response *)hdr)->u.mctrl_word;
+	if (mctrl & HVSI_TSDTR)
+		vtty->mctrl |= TIOCM_DTR;
+	if (mctrl & HVSI_TSCD)
+		vtty->mctrl |= TIOCM_CD;
+	pr_debug("%s: mctrl 0x%x\n", __FUNCTION__, vtty->mctrl);
+
+out:
+	return ret;
+}
+
+static int hvsi_handshake(struct vtty_struct *vtty)
+{
+	struct hvsi_header *hdr;
+	int ret = 0;
+
+	if (hvsi_query(vtty, VSV_SEND_VERSION_NUMBER)) {
+		ret = -EIO;
+		goto out;
+	}
+	if (wait_for_packet(vtty, &hdr, VS_QUERY_RESPONSE_PACKET_HEADER)) {
+		ret = -EIO;
+		goto out;
+	}
+	/* XXX see if it's the right response */
+
+	if (wait_for_packet(vtty, &hdr, VS_QUERY_PACKET_HEADER)) {
+		ret = -EIO;
+		goto out;
+	}
+	/* XXX see if it's the right query */
+	if (hvsi_version_respond(vtty, hdr->seqno)) {
+		ret = -EIO;
+		goto out;
+	}
+
+	if (hvsi_get_mctrl(vtty)) {
+		ret = -EIO;
+		goto out;
+	}
+
+out:
+	if (ret < 0)
+		printk(KERN_ERR "HVSI handshaking failed\n");
+	return ret;
+}
+
+static int hvsi_put_chars(struct vtty_struct *vtty, const char *buf, int count)
+{
+	char packet[16] __ALIGNED__;
+	uint64_t *lbuf = (uint64_t *)packet;
+	struct hvsi_header *hdr = (struct hvsi_header *)packet;
+	int ret;
+
+	hdr->type = VS_DATA_PACKET_HEADER;
+	hdr->seqno = vtty->seqno++;
+
+	if (count > 12)
+		count = 12; /* we'll leave some chars behind in buf */
+	hdr->len = count + sizeof(struct hvsi_header);
+	memcpy(packet + sizeof(struct hvsi_header), buf, count);
+
+	/* note: we can't use hvc_hvterm_put_chars() here, as it would return
+	 * _packet_ length, not _payload_ length */
+	ret = plpar_hcall_norets(H_PUT_TERM_CHAR, vtty->vtermno, hdr->len,
+			lbuf[0], lbuf[1]);
+	if (ret == H_Success)
+		return count;
+	if (ret == H_Busy)
+		return 0;
+	return -EIO;
+}
+
+/* note that we can only set DTR */
+static int hvsi_set_mctrl(struct vtty_struct *vtty, uint16_t mctrl)
+{
+	struct hvsi_control command __ALIGNED__ = {
+		.type = VS_CONTROL_PACKET_HEADER,
+		.len = sizeof(struct hvsi_control),
+		.verb = VSV_SET_MODEM_CTL,
+		.mask = HVSI_TSDTR,
+	};
+	int wrote;
+
+	command.seqno = vtty->seqno++;
+	if (mctrl & TIOCM_DTR)
+		command.word = HVSI_TSDTR;
+
+	wrote = hvc_hvterm_put_chars(vtty, (char *)&command, command.len);
+	if (wrote != command.len) {
+		printk(KERN_ERR "%s: couldn't set DTR!\n", __FUNCTION__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int hvsi_tiocmset(struct vtty_struct *vtty, uint16_t set, uint16_t clear)
+{
+	uint16_t old_mctrl;
+
+	/* we can only set DTR */
+	if (set & ~TIOCM_DTR)
+		return -EINVAL;
+
+	old_mctrl = vtty->mctrl;
+	vtty->mctrl = (old_mctrl & ~clear) | set;
+
+	pr_debug("%s: new mctrl 0x%x\n", __FUNCTION__, vtty->mctrl);
+	if (old_mctrl != vtty->mctrl) {
+		if (hvsi_set_mctrl(vtty, vtty->mctrl) < 0)
+			return -EIO;
+	} else {
+		pr_debug("  (not writing to SP)\n");
+	}
+
+	return 0;
+}
+
+static int hvsi_tiocmget(struct vtty_struct *vtty)
+{
+	if (hvsi_get_mctrl(vtty))
+		return -EIO;
+	pr_debug("%s: mctrl 0x%x\n", __FUNCTION__, vtty->mctrl);
+	return vtty->mctrl;
+}
+
+/* external (hvc_console.c) interface: */
+
+int hvc_arch_get_chars(int index, char *buf, int count)
+{
+	struct vtty_struct *vtty = &vttys[index];
+
+	if (index >= MAX_NR_HVC_CONSOLES)
+		return -ENODEV;
+
+	return vtty->get_chars(vtty, buf, count);
+}
+
+int hvc_arch_put_chars(int index, const char *buf, int count)
+{
+	struct vtty_struct *vtty = &vttys[index];
+
+	if (index >= MAX_NR_HVC_CONSOLES)
+		return -ENODEV;
+
+	return vtty->put_chars(vtty, buf, count);
+}
+
+int hvc_arch_tiocmset(int index, unsigned int set, unsigned int clear)
+{
+	struct vtty_struct *vtty = &vttys[index];
+
+	if (index >= MAX_NR_HVC_CONSOLES)
+		return -ENODEV;
+
+	if (vtty->tiocmset)
+		return vtty->tiocmset(vtty, set, clear);
+	return -EINVAL;
 }
 
-/* return the number of client vterms present */
-/* XXX this requires an interface change to handle multiple discontiguous
- * vterms */
-int hvc_count(int *start_termno)
+int hvc_arch_tiocmget(int index)
+{
+	struct vtty_struct *vtty = &vttys[index];
+
+	if (index >= MAX_NR_HVC_CONSOLES)
+		return -ENODEV;
+
+	if (vtty->tiocmset)
+		return vtty->tiocmget(vtty);
+	return -EINVAL;
+}
+
+int hvc_arch_find_vterms(void)
 {
 	struct device_node *vty;
-	int num_found = 0;
+	int count = 0;
+	unsigned int *irq_p;
+
+	for (vty = of_find_node_by_name(NULL, "vty"); vty != NULL;
+			vty = of_find_node_by_name(vty, "vty")) {
+		struct vtty_struct *vtty;
+		uint32_t *vtermno;
+
+		vtermno = (uint32_t *)get_property(vty, "reg", NULL);
+		if (!vtermno)
+			continue;
+
+		if (count >= MAX_NR_HVC_CONSOLES)
+			break;
 
-	/* consider only the first vty node.
-	 * we should _always_ be able to find one. */
-	vty = of_find_node_by_name(NULL, "vty");
-	if (vty && device_is_compatible(vty, "hvterm1")) {
-		u32 *termno = (u32 *)get_property(vty, "reg", 0);
+		vtty = &vttys[count];
+		vtty->irq = NO_IRQ;
+		if (device_is_compatible(vty, "hvterm1")) {
+			vtty->vtermno = *vtermno;
+			vtty->get_chars = hvc_hvterm_get_chars;
+			vtty->put_chars = hvc_hvterm_put_chars;
+			vtty->tiocmget = NULL;
+			vtty->tiocmset = NULL;
+			irq_p = (unsigned int *)get_property(vty, "interrupts", 0);
+			if (irq_p) {
+				int virq = virt_irq_create_mapping(*irq_p);
+				if (virq != NO_IRQ)
+					vtty->irq = irq_offset_up(virq);
+			}
+			hvc_instantiate();
+			count++;
+		} else if (device_is_compatible(vty, "hvterm-protocol")) {
+			vtty->vtermno = *vtermno;
+			vtty->seqno = 0;
+			vtty->get_chars = hvsi_get_chars;
+			vtty->put_chars = hvsi_put_chars;
+			vtty->tiocmget = hvsi_tiocmget;
+			vtty->tiocmset = hvsi_tiocmset;
+			if (hvsi_handshake(vtty)) {
+				continue;
+			}
+			vtty->put_chars(vtty, "\nHVSI\n", 6);
+			hvc_instantiate();
+			count++;
+		}
+	}
+
+	return count;
+}
+
+int hvc_interrupt(int index)
+{
+	struct vtty_struct *vtty = &vttys[index];
+
+	/* If not interruptible then it'll return NO_IRQ */
+	return vtty->irq;
+} 
+
+/* Convert arch specific return codes into relevant errnos.  The hvcs
+ * functions aren't performance sensitive, so this conversion isn't an
+ * issue. */
+int hvcs_convert(long to_convert)
+{
+	switch (to_convert) {
+		case H_Success:
+			return 0;
+		case H_Parameter:
+			return -EINVAL;
+		case H_Hardware:
+			return -EIO;
+		case H_Busy:
+			return -EBUSY;
+		case H_Function: /* fall through */
+		default:
+			return -EPERM;
+	}
+}
+
+int hvcs_free_partner_info(struct list_head *head)
+{
+	struct hvcs_partner_info *pi;
+	struct list_head *element;
+
+	if(!head) {
+		return -EINVAL;
+	}
 
-		if (termno && start_termno)
-			*start_termno = *termno;
-		num_found = 1;
-		of_node_put(vty);
+	while (!list_empty(head)) {
+		element = head->next;
+		pi = list_entry(element,struct hvcs_partner_info,node);
+		list_del(element);
+		kfree(pi);
 	}
 
-	return num_found;
+	return 0;
+}
+EXPORT_SYMBOL(hvcs_free_partner_info);
+
+/* Helper function for hvcs_get_partner_info */
+int hvcs_next_partner(unsigned int unit_address, unsigned long last_p_partition_ID, unsigned long last_p_unit_address, unsigned long *pi_buff)
+{
+	long retval;
+	retval = plpar_hcall_norets(H_VTERM_PARTNER_INFO, unit_address,
+			last_p_partition_ID,
+				last_p_unit_address, virt_to_phys(pi_buff));
+	return hvcs_convert(retval);
+}
+
+/* The unit_address parameter is the unit address of the vty-server@ vdevice
+ * in whose partner information the caller is interested.  This function
+ * uses a pointer to a list_head instance in which to store the partner info.
+ * This function returns Non-Zero on success, or if there is no partner info.
+ *
+ * Invocation of this function should always be followed by an invocation of
+ * hvcs_free_partner_info() using a pointer to the SAME list head instance
+ * that was used to store the partner_info list.
+ */
+int hvcs_get_partner_info(unsigned int unit_address, struct list_head *head)
+{
+	/* This is a page sized buffer to be passed to hvcall per invocation.
+	 * NOTE: the first long returned is unit_address.  The second long
+	 * returned is the partition ID and starting with pi_buff[2] are
+	 * HVCS_CLC_LENGTH characters, which are diff size than the unsigned
+	 * long, hence the casting mumbojumbo you see later. */
+	unsigned long	*pi_buff;
+	unsigned long	last_p_partition_ID;
+	unsigned long	last_p_unit_address;
+	struct hvcs_partner_info *next_partner_info = NULL;
+	int more = 1;
+	int retval;
+
+	/* invalid parameters */
+	if (!head)
+		return -EINVAL;
+
+	last_p_partition_ID = last_p_unit_address = HVCS_LONG_INVALID;
+	INIT_LIST_HEAD(head);
+
+	pi_buff = kmalloc(PAGE_SIZE, GFP_KERNEL);
+
+	if(!pi_buff)
+		return -ENOMEM;
+
+	do {
+		retval = hvcs_next_partner(unit_address, last_p_partition_ID,
+				last_p_unit_address, pi_buff);
+		if(retval) {
+			kfree(pi_buff);
+			pi_buff = 0;
+			/* don't indicate that we've failed if we have
+			 * any list elements. */
+			if(!list_empty(head))
+				return 0;
+			return retval;
+		}
+
+		last_p_partition_ID = pi_buff[0];
+		last_p_unit_address = pi_buff[1];
+
+		/* This indicates that there are no further partners */
+		if (last_p_partition_ID == HVCS_LONG_INVALID
+				&& last_p_unit_address == HVCS_LONG_INVALID)
+			break;
+
+		next_partner_info = kmalloc(sizeof(struct hvcs_partner_info),
+				GFP_KERNEL);
+
+		if (!next_partner_info) {
+			printk(KERN_WARNING "HVCONSOLE: kmalloc() failed to"
+				" allocate partner info struct.\n");
+			hvcs_free_partner_info(head);
+			kfree(pi_buff);
+			pi_buff = 0;
+			return -ENOMEM;
+		}
+
+		next_partner_info->unit_address
+			= (unsigned int)last_p_unit_address;
+		next_partner_info->partition_ID
+			= (unsigned int)last_p_partition_ID;
+
+		/* copy the Null-term char too */
+		strncpy(&next_partner_info->location_code[0],
+			(char *)&pi_buff[2],
+			strlen((char *)&pi_buff[2]) + 1);
+
+		list_add_tail(&(next_partner_info->node), head);
+		next_partner_info = NULL;
+
+	} while (more);
+
+	kfree(pi_buff);
+	pi_buff = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL(hvcs_get_partner_info);
+
+/* If this function is called once and -EINVAL is returned it may
+ * indicate that the partner info needs to be refreshed for the
+ * target unit address at which point the caller must invoke
+ * hvcs_get_partner_info() and then call this function again.  If,
+ * for a second time, -EINVAL is returned then it indicates that
+ * there is probably already a partner connection registered to a
+ * different vty-server@ vdevice.  It is also possible that a second
+ * -EINVAL may indicate that one of the parms is not valid, for
+ * instance if the link was removed between the vty-server@ vdevice
+ * and the vty@ vdevice that you are trying to open.  Don't shoot the
+ * messenger.  Firmware implemented it this way.
+ */
+int hvcs_register_connection( unsigned int unit_address, unsigned int p_partition_ID, unsigned int p_unit_address)
+{
+	long retval;
+	retval = plpar_hcall_norets(H_REGISTER_VTERM, unit_address,
+				p_partition_ID, p_unit_address);
+	return hvcs_convert(retval);
+}
+EXPORT_SYMBOL(hvcs_register_connection);
+
+/* If -EBUSY is returned continue to call this function
+ * until 0 is returned */
+int hvcs_free_connection(unsigned int unit_address)
+{
+	long retval;
+	retval = plpar_hcall_norets(H_FREE_VTERM, unit_address);
+	return hvcs_convert(retval);
 }
+EXPORT_SYMBOL(hvcs_free_connection);
diff -purN linux-post-2.6.6-rc2-20040424/drivers/char/hvc_console.c linuxppc64-post-2.6.6-rc2-20040424/drivers/char/hvc_console.c
--- linux-post-2.6.6-rc2-20040424/drivers/char/hvc_console.c	2004-03-16 11:30:38.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/drivers/char/hvc_console.c	2004-04-22 06:16:00.000000000 +0000
@@ -27,31 +27,33 @@
 #include <linux/tty_flip.h>
 #include <linux/sched.h>
 #include <linux/kbd_kern.h>
-#include <asm/uaccess.h>
 #include <linux/spinlock.h>
 #include <linux/cpumask.h>
-
-extern int hvc_count(int *);
-extern int hvc_get_chars(int index, char *buf, int count);
-extern int hvc_put_chars(int index, const char *buf, int count);
+#include <asm/uaccess.h>
+#include <asm/hvconsole.h>
 
 #define HVC_MAJOR	229
 #define HVC_MINOR	0
 
-#define MAX_NR_HVC_CONSOLES	4
-
 #define TIMEOUT		((HZ + 99) / 100)
 
 static struct tty_driver *hvc_driver;
-static int hvc_offset;
+static int hvc_count;
+static int hvc_kicked;
+static wait_queue_head_t hvc_wait_queue;
 #ifdef CONFIG_MAGIC_SYSRQ
 static int sysrq_pressed;
 #endif
 
 #define N_OUTBUF	16
+#define N_INBUF		16
 
 #define __ALIGNED__	__attribute__((__aligned__(8)))
 
+/* This driver speaks only in "indexes", i.e. logical consoles starting at 0.
+ * The ppc64 backend converts those indexes (e.g. hvc0) to whatever the
+ * ultimate "vterm number" that the platform understands. */
+
 struct hvc_struct {
 	spinlock_t lock;
 	int index;
@@ -60,15 +62,34 @@ struct hvc_struct {
 	int do_wakeup;
 	char outbuf[N_OUTBUF] __ALIGNED__;
 	int n_outbuf;
+	int irq_requested;
 };
 
 struct hvc_struct hvc_struct[MAX_NR_HVC_CONSOLES];
 
+static void hvc_kick(void)
+{
+	hvc_kicked = 1;
+	wake_up_interruptible(&hvc_wait_queue);
+}
+
+static irqreturn_t hvc_handle_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	hvc_kick();
+	return IRQ_HANDLED;
+}
+
+static void hvc_unthrottle(struct tty_struct *tty)
+{
+	hvc_kick();
+}
+
 static int hvc_open(struct tty_struct *tty, struct file * filp)
 {
 	int line = tty->index;
 	struct hvc_struct *hp;
 	unsigned long flags;
+	int irq = NO_IRQ;
 
 	if (line < 0 || line >= MAX_NR_HVC_CONSOLES)
 		return -ENODEV;
@@ -78,7 +99,18 @@ static int hvc_open(struct tty_struct *t
 	spin_lock_irqsave(&hp->lock, flags);
 	hp->tty = tty;
 	hp->count++;
+	if (hp->count == 1) {
+		irq = hvc_interrupt(hp->index);
+		if (irq != NO_IRQ)
+			hp->irq_requested = 1;
+	}
 	spin_unlock_irqrestore(&hp->lock, flags);
+	/* XX check error, fallback to non-irq ? */
+	if (irq != NO_IRQ)
+		request_irq(irq, hvc_handle_interrupt, SA_INTERRUPT, "hvc_console", hp);
+
+	/* Force wakeup of the polling thread */
+	hvc_kick();
 
 	return 0;
 }
@@ -87,24 +119,41 @@ static void hvc_close(struct tty_struct 
 {
 	struct hvc_struct *hp = tty->driver_data;
 	unsigned long flags;
+	int irq = NO_IRQ;
 
-	if (tty_hung_up_p(filp))
-		return;
 	spin_lock_irqsave(&hp->lock, flags);
-	if (--hp->count == 0)
+	if (tty_hung_up_p(filp))
+		goto bail;
+
+	if (--hp->count == 0) {
 		hp->tty = NULL;
-	else if (hp->count < 0)
+		if (hp->irq_requested)
+			irq = hvc_interrupt(hp->index);
+		hp->irq_requested = 0;
+	} else if (hp->count < 0)
 		printk(KERN_ERR "hvc_close %lu: oops, count is %d\n",
 		       hp - hvc_struct, hp->count);
+ bail:
 	spin_unlock_irqrestore(&hp->lock, flags);
+	if (irq != NO_IRQ)
+		free_irq(irq, hp);
 }
 
 static void hvc_hangup(struct tty_struct *tty)
 {
 	struct hvc_struct *hp = tty->driver_data;
+	unsigned long flags;
+	int irq = NO_IRQ;
 
+	spin_lock_irqsave(&hp->lock, flags);
 	hp->count = 0;
 	hp->tty = NULL;
+	if (hp->irq_requested)
+		irq = hvc_interrupt(hp->index);
+	hp->irq_requested = 0;
+	spin_unlock_irqrestore(&hp->lock, flags);
+	if (irq != NO_IRQ)
+		free_irq(irq, hp);
 }
 
 /* called with hp->lock held */
@@ -112,7 +161,7 @@ static void hvc_push(struct hvc_struct *
 {
 	int n;
 
-	n = hvc_put_chars(hp->index + hvc_offset, hp->outbuf, hp->n_outbuf);
+	n = hvc_arch_put_chars(hp->index, hp->outbuf, hp->n_outbuf);
 	if (n <= 0) {
 		if (n == 0)
 			return;
@@ -127,69 +176,103 @@ static void hvc_push(struct hvc_struct *
 		hp->do_wakeup = 1;
 }
 
-static int hvc_write(struct tty_struct *tty, int from_user,
-		     const unsigned char *buf, int count)
+static inline int __hvc_write_user(struct hvc_struct *hp,
+				   const unsigned char *buf, int count)
 {
-	struct hvc_struct *hp = tty->driver_data;
 	char *tbuf, *p;
 	int tbsize, rsize, written = 0;
 	unsigned long flags;
 
-	if (from_user) {
-		tbsize = min(count, (int)PAGE_SIZE);
-		if (!(tbuf = kmalloc(tbsize, GFP_KERNEL)))
-			return -ENOMEM;
-
-		while ((rsize = count - written) > 0) {
-			int wsize;
-			if (rsize > tbsize)
-				rsize = tbsize;
-
-			p = tbuf;
-			rsize -= copy_from_user(p, buf, rsize);
-			if (!rsize) {
-				if (written == 0)
-					written = -EFAULT;
-				break;
-			}
-			buf += rsize;
-			written += rsize;
-
-			spin_lock_irqsave(&hp->lock, flags);
-			for (wsize = N_OUTBUF - hp->n_outbuf; rsize && wsize;
-					wsize = N_OUTBUF - hp->n_outbuf) {
-				if (wsize > rsize)
-					wsize = rsize;
-				memcpy(hp->outbuf + hp->n_outbuf, p, wsize);
-				hp->n_outbuf += wsize;
-				hvc_push(hp);
-				rsize -= wsize;
-				p += wsize;
-			}
-			spin_unlock_irqrestore(&hp->lock, flags);
-
-			if (rsize)
-				break;
+	tbsize = min(count, (int)PAGE_SIZE);
+	if (!(tbuf = kmalloc(tbsize, GFP_KERNEL)))
+		return -ENOMEM;
 
-			if (count < tbsize)
-				tbsize = count;
+	while ((rsize = count - written) > 0) {
+		int wsize;
+		if (rsize > tbsize)
+			rsize = tbsize;
+
+		p = tbuf;
+		rsize -= copy_from_user(p, buf, rsize);
+		if (!rsize) {
+			if (written == 0)
+				written = -EFAULT;
+			break;
 		}
+		buf += rsize;
 
-		kfree(tbuf);
-	} else {
 		spin_lock_irqsave(&hp->lock, flags);
-		while (count > 0 && (rsize = N_OUTBUF - hp->n_outbuf) > 0) {
-			if (rsize > count)
-				rsize = count;
-			memcpy(hp->outbuf + hp->n_outbuf, buf, rsize);
-			count -= rsize;
-			buf += rsize;
-			hp->n_outbuf += rsize;
-			written += rsize;
+
+		/* Push pending writes: make some room in buffer */
+		if (hp->n_outbuf > 0)
 			hvc_push(hp);
+
+		for (wsize = N_OUTBUF - hp->n_outbuf; rsize && wsize;
+		     wsize = N_OUTBUF - hp->n_outbuf) {
+			if (wsize > rsize)
+				wsize = rsize;
+			memcpy(hp->outbuf + hp->n_outbuf, p, wsize);
+			hp->n_outbuf += wsize;
+			hvc_push(hp);
+			rsize -= wsize;
+			p += wsize;
+			written += wsize;
 		}
 		spin_unlock_irqrestore(&hp->lock, flags);
+
+		if (rsize)
+			break;
+
+		if (count < tbsize)
+			tbsize = count;
+	}
+
+	kfree(tbuf);
+
+	return written;
+}
+
+static inline int __hvc_write_kernel(struct hvc_struct *hp,
+				   const unsigned char *buf, int count)
+{
+	unsigned long flags;
+	int rsize, written = 0;
+
+	spin_lock_irqsave(&hp->lock, flags);
+
+	/* Push pending writes */
+	if (hp->n_outbuf > 0)
+		hvc_push(hp);
+
+	while (count > 0 && (rsize = N_OUTBUF - hp->n_outbuf) > 0) {
+		if (rsize > count)
+			rsize = count;
+		memcpy(hp->outbuf + hp->n_outbuf, buf, rsize);
+		count -= rsize;
+		buf += rsize;
+		hp->n_outbuf += rsize;
+		written += rsize;
+		hvc_push(hp);
 	}
+	spin_unlock_irqrestore(&hp->lock, flags);
+
+	return written;
+}
+
+static int hvc_write(struct tty_struct *tty, int from_user,
+		     const unsigned char *buf, int count)
+{
+	struct hvc_struct *hp = tty->driver_data;
+	int written;
+
+	if (from_user)
+		written = __hvc_write_user(hp, buf, count);
+	else
+		written = __hvc_write_kernel(hp, buf, count);
+
+	/* Racy, but harmless, kick thread if there are still pending data */
+	if (hp->n_outbuf)
+		hvc_kick();
 
 	return written;
 }
@@ -208,54 +291,106 @@ static int hvc_chars_in_buffer(struct tt
 	return hp->n_outbuf;
 }
 
-static void hvc_poll(int index)
+#define HVC_POLL_READ	0x00000001
+#define HVC_POLL_WRITE	0x00000002
+#define HVC_POLL_QUICK	0x00000004
+
+static int hvc_poll(int index)
 {
 	struct hvc_struct *hp = &hvc_struct[index];
 	struct tty_struct *tty;
-	int i, n;
-	char buf[16] __ALIGNED__;
+	int i, n, poll_mask = 0;
+	char buf[N_INBUF] __ALIGNED__;
 	unsigned long flags;
+	int read_total = 0;
 
 	spin_lock_irqsave(&hp->lock, flags);
 
+	/* Push pending writes */
 	if (hp->n_outbuf > 0)
 		hvc_push(hp);
+	/* Reschedule us if still some write pending */
+	if (hp->n_outbuf > 0)
+		poll_mask |= HVC_POLL_WRITE;
 
+	/* No tty attached, just skip */
 	tty = hp->tty;
-	if (tty) {
-		for (;;) {
-			if (TTY_FLIPBUF_SIZE - tty->flip.count < sizeof(buf))
-				break;
-			n = hvc_get_chars(index + hvc_offset, buf, sizeof(buf));
-			if (n <= 0)
-				break;
-			for (i = 0; i < n; ++i) {
-#ifdef CONFIG_MAGIC_SYSRQ		/* Handle the SysRq Hack */
-				if (buf[i] == '\x0f') {	/* ^O -- should support a sequence */
-					sysrq_pressed = 1;
-					continue;
-				} else if (sysrq_pressed) {
-					handle_sysrq(buf[i], NULL, tty);
-					sysrq_pressed = 0;
-					continue;
-				}
-#endif
-				tty_insert_flip_char(tty, buf[i], 0);
+	if (tty == NULL)
+		goto bail;
+
+	/* Now check if we can get data (are we throttled ?) */
+	if (test_bit(TTY_THROTTLED, &tty->flags))
+		goto throttled;
+
+	/* If we aren't interrupt driven and aren't throttled, we always
+	 * request a reschedule
+	 */
+	if (hvc_interrupt(index) == NO_IRQ)
+		poll_mask |= HVC_POLL_READ;
+
+	/* Read data if any */
+	for (;;) {
+		int count = N_INBUF;
+		if (count > (TTY_FLIPBUF_SIZE - tty->flip.count))
+			count = TTY_FLIPBUF_SIZE - tty->flip.count;
+
+		/* If flip is full, just reschedule a later read */
+		if (count == 0) {
+			poll_mask |= HVC_POLL_READ;
+			break;
+		}
+		
+		n = hvc_arch_get_chars(index, buf, count);
+		if (n <= 0) {
+			/* Hangup the tty when disconnected from host */
+			if (n == -EPIPE) {
+				spin_unlock_irqrestore(&hp->lock, flags);
+				tty_hangup(tty);
+				spin_lock_irqsave(&hp->lock, flags);
 			}
+			break;
 		}
+		for (i = 0; i < n; ++i) {
+#ifdef CONFIG_MAGIC_SYSRQ
+			/* Handle the SysRq Hack */
+			if (buf[i] == '\x0f') {	/* ^O -- should support a sequence */
+				sysrq_pressed = 1;
+				continue;
+			} else if (sysrq_pressed) {
+				handle_sysrq(buf[i], NULL, tty);
+				sysrq_pressed = 0;
+				continue;
+			}
+#endif /* CONFIG_MAGIC_SYSRQ */
+			tty_insert_flip_char(tty, buf[i], 0);
+		}
+
 		if (tty->flip.count)
 			tty_schedule_flip(tty);
 
-		if (hp->do_wakeup) {
-			hp->do_wakeup = 0;
-			if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP))
-			    && tty->ldisc.write_wakeup)
-				(tty->ldisc.write_wakeup)(tty);
-			wake_up_interruptible(&tty->write_wait);
+		/* Account the total amount read in one loop, and if above 64 bytes,
+		 * we do a quick schedule loop to let the tty grok the data and
+		 * eventually throttle us
+		 */
+		read_total += n;
+		if (read_total >= 64) {
+			poll_mask |= HVC_POLL_QUICK;
+			break;
 		}
 	}
-
+ throttled:
+	/* Wakeup write queue if necessary */
+	if (hp->do_wakeup) {
+		hp->do_wakeup = 0;
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP))
+		    && tty->ldisc.write_wakeup)
+			(tty->ldisc.write_wakeup)(tty);
+		wake_up_interruptible(&tty->write_wait);
+	}
+ bail:
 	spin_unlock_irqrestore(&hp->lock, flags);
+
+	return poll_mask;
 }
 
 #if defined(CONFIG_XMON) && defined(CONFIG_SMP)
@@ -267,38 +402,81 @@ static const cpumask_t cpus_in_xmon = CP
 
 int khvcd(void *unused)
 {
-	int i;
+	int i, poll_mask;
 
 	daemonize("khvcd");
 
 	for (;;) {
+		wait_queue_t wait = __WAITQUEUE_INITIALIZER(wait,current);
+
+		poll_mask = 0;
+		hvc_kicked = 0;
+		wmb();
 		if (cpus_empty(cpus_in_xmon)) {
 			for (i = 0; i < MAX_NR_HVC_CONSOLES; ++i)
-				hvc_poll(i);
+				poll_mask |= hvc_poll(i);
+		} else
+			poll_mask |= HVC_POLL_READ;
+		if (hvc_kicked)
+			continue;
+		if (poll_mask & HVC_POLL_QUICK) {
+			yield();
+			continue;
 		}
+		add_wait_queue(&hvc_wait_queue, &wait);
 		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(TIMEOUT);
+		if (!hvc_kicked) {
+			if (poll_mask == 0)
+				schedule();
+			else
+				schedule_timeout(TIMEOUT);
+		}
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&hvc_wait_queue, &wait);
 	}
 }
 
+static int hvc_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct hvc_struct *hp = tty->driver_data;
+	int ret = -EIO;
+
+	if (!file || !tty_hung_up_p(file)) {
+		ret = hvc_arch_tiocmget(hp->index);
+	}
+	return ret;
+}
+
+static int hvc_tiocmset(struct tty_struct *tty, struct file *file,
+	unsigned int set, unsigned int clear)
+{
+	struct hvc_struct *hp = tty->driver_data;
+	int ret = -EIO;
+
+	if (!file || !tty_hung_up_p(file)) {
+		ret = hvc_arch_tiocmset(hp->index, set, clear);
+	}
+
+	return ret;
+}
+
 static struct tty_operations hvc_ops = {
 	.open = hvc_open,
 	.close = hvc_close,
 	.write = hvc_write,
 	.hangup = hvc_hangup,
+	.unthrottle = hvc_unthrottle,
 	.write_room = hvc_write_room,
 	.chars_in_buffer = hvc_chars_in_buffer,
+	.tiocmget = hvc_tiocmget,
+	.tiocmset = hvc_tiocmset,
 };
 
 int __init hvc_init(void)
 {
-	int num = hvc_count(&hvc_offset);
-	int i;
-
-	if (num > MAX_NR_HVC_CONSOLES)
-		num = MAX_NR_HVC_CONSOLES;
+	init_waitqueue_head(&hvc_wait_queue);
 
-	hvc_driver = alloc_tty_driver(num);
+	hvc_driver = alloc_tty_driver(hvc_count);
 	if (!hvc_driver)
 		return -ENOMEM;
 
@@ -312,23 +490,20 @@ int __init hvc_init(void)
 	hvc_driver->init_termios = tty_std_termios;
 	hvc_driver->flags = TTY_DRIVER_REAL_RAW;
 	tty_set_operations(hvc_driver, &hvc_ops);
-	for (i = 0; i < num; i++) {
-		hvc_struct[i].lock = SPIN_LOCK_UNLOCKED;
-		hvc_struct[i].index = i;
-	}
 
 	if (tty_register_driver(hvc_driver))
 		panic("Couldn't register hvc console driver\n");
 
-	if (num > 0)
+	if (hvc_count > 0)
 		kernel_thread(khvcd, NULL, CLONE_KERNEL);
+	else
+		printk(KERN_WARNING "no virtual consoles found\n");
 
 	return 0;
 }
+device_initcall(hvc_init);
 
-static void __exit hvc_exit(void)
-{
-}
+/***** console (not tty) code: *****/
 
 void hvc_console_print(struct console *co, const char *b, unsigned count)
 {
@@ -348,7 +523,7 @@ void hvc_console_print(struct console *c
 				--count;
 			}
 		} else {
-			r = hvc_put_chars(co->index + hvc_offset, c, i);
+			r = hvc_arch_put_chars(co->index, c, i);
 			if (r < 0) {
 				/* throw away chars on error */
 				i = 0;
@@ -370,7 +545,7 @@ static struct tty_driver *hvc_console_de
 static int __init hvc_console_setup(struct console *co, char *options)
 {
 	if (co->index < 0 || co->index >= MAX_NR_HVC_CONSOLES
-	    || co->index >= hvc_count(&hvc_offset))
+	    || co->index >= hvc_count)
 		return -1;
 	return 0;
 }
@@ -384,12 +559,27 @@ struct console hvc_con_driver = {
 	.index		= -1,
 };
 
+/* hvc_instantiate - called once per discovered vterm by hvc_arch_find_vterms */
+int hvc_instantiate(void)
+{
+	struct hvc_struct *hvc;
+
+	if (hvc_count >= MAX_NR_HVC_CONSOLES)
+		return -1;
+
+	hvc = &hvc_struct[hvc_count];
+	hvc->lock = SPIN_LOCK_UNLOCKED;
+	hvc->index = hvc_count;
+
+	hvc_count++;
+
+	return 0;
+}
+
 static int __init hvc_console_init(void)
 {
+	hvc_arch_find_vterms(); /* populate hvc_struct[] early */
 	register_console(&hvc_con_driver);
 	return 0;
 }
 console_initcall(hvc_console_init);
-
-module_init(hvc_init);
-module_exit(hvc_exit);
diff -purN linux-post-2.6.6-rc2-20040424/include/asm-ppc64/hvconsole.h linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/hvconsole.h
--- linux-post-2.6.6-rc2-20040424/include/asm-ppc64/hvconsole.h	2004-02-05 21:10:52.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/hvconsole.h	2004-04-22 06:16:00.000000000 +0000
@@ -22,9 +22,42 @@
 #ifndef _PPC64_HVCONSOLE_H
 #define _PPC64_HVCONSOLE_H
 
-extern int hvc_get_chars(int index, char *buf, int count);
-extern int hvc_put_chars(int index, const char *buf, int count);
-extern int hvc_count(int *start_termno);
+#include <linux/list.h>
+
+#define MAX_NR_HVC_CONSOLES	4
+
+extern int hvc_arch_get_chars(int index, char *buf, int count);
+extern int hvc_arch_put_chars(int index, const char *buf, int count);
+extern int hvc_arch_tiocmset(int index, unsigned int set, unsigned int clear);
+extern int hvc_arch_tiocmget(int index);
+extern int hvc_arch_find_vterms(void);
+
+extern int hvc_instantiate(void);
+
+/* hvterm_get/put_chars() do not work with HVSI console protocol; present only
+ * for HVCS console server driver */
+extern int hvterm_get_chars(uint32_t vtermno, char *buf, int count);
+extern int hvterm_put_chars(uint32_t vtermno, const char *buf, int count);
+
+/* Converged Location Code length */
+#define HVCS_CLC_LENGTH	79
+
+struct hvcs_partner_info {
+	/* list management */
+	struct list_head node;
+	/* partner unit address */
+	unsigned int unit_address;
+	/*partner partition ID */
+	unsigned int partition_ID;
+	/* CLC (79 chars) + 1 Null-term char */
+	char location_code[HVCS_CLC_LENGTH + 1];
+};
+
+extern int hvcs_free_partner_info(struct list_head *head);
+extern int hvcs_get_partner_info(unsigned int unit_address, struct list_head *head);
+extern int hvcs_register_connection(unsigned int unit_address, unsigned int p_partition_ID, unsigned int p_unit_address);
+extern int hvcs_free_connection(unsigned int unit_address);
+extern int hvc_interrupt(int index);
 
 #endif /* _PPC64_HVCONSOLE_H */
 
