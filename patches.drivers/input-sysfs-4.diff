diff -urN linux-2.6.8-inp/drivers/input/evdev.c linux-2.6.8-inp-sysfs/drivers/input/evdev.c
--- linux-2.6.8-inp/drivers/input/evdev.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/evdev.c	2004-09-20 14:23:08.897811493 +0200
@@ -29,8 +29,9 @@
 	char name[16];
 	struct input_handle handle;
 	wait_queue_head_t wait;
-	struct evdev_list *grab;
 	struct list_head list;
+
+	struct evdev_list *grab;
 };
 
 struct evdev_list {
@@ -92,7 +93,7 @@
 static void evdev_free(struct evdev *evdev)
 {
 	devfs_remove("input/event%d", evdev->minor);
-	class_simple_device_remove(MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + evdev->minor));
+	input_class_remove_handle(&evdev->handle);
 	evdev_table[evdev->minor] = NULL;
 	kfree(evdev);
 }
@@ -424,15 +425,18 @@
 	evdev->handle.name = evdev->name;
 	evdev->handle.handler = handler;
 	evdev->handle.private = evdev;
+	evdev->handle.minor_base = EVDEV_MINOR_BASE;
 	sprintf(evdev->name, "event%d", minor);
 
 	evdev_table[minor] = evdev;
 
+	printk(KERN_DEBUG "%s: evdev %p handle %p name %s\n", __FUNCTION__, 
+	       evdev, &evdev->handle, evdev->name);
+
 	devfs_mk_cdev(MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),
 			S_IFCHR|S_IRUGO|S_IWUSR, "input/event%d", minor);
-	class_simple_device_add(input_class,
-				MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),
-				dev->dev, "event%d", minor);
+	
+	input_class_add_handle(&evdev->handle);
 
 	return &evdev->handle;
 }
diff -urN linux-2.6.8-inp/drivers/input/input.c linux-2.6.8-inp-sysfs/drivers/input/input.c
--- linux-2.6.8-inp/drivers/input/input.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/input.c	2004-09-20 14:23:08.898811320 +0200
@@ -25,6 +25,8 @@
 #include <linux/device.h>
 #include <linux/devfs_fs_kernel.h>
 
+#define INPUT_DEBUG
+
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("Input core");
 MODULE_LICENSE("GPL");
@@ -40,7 +42,8 @@
 EXPORT_SYMBOL(input_accept_process);
 EXPORT_SYMBOL(input_flush_device);
 EXPORT_SYMBOL(input_event);
-EXPORT_SYMBOL(input_class);
+EXPORT_SYMBOL(input_class_add_handle);
+EXPORT_SYMBOL(input_class_remove_handle);
 
 #define INPUT_DEVICES	256
 
@@ -340,52 +343,27 @@
 			SPRINTF_BIT_A(bit, name, max); \
 	} while (0)
 
-static void input_call_hotplug(char *verb, struct input_dev *dev)
+static int __input_hotplug(struct input_dev *dev, char **envp, int num_envp,
+			   char *buffer, int buffer_size)
 {
-	char *argv[3], **envp, *buf, *scratch;
-	int i = 0, j, value;
-
-	if (!hotplug_path[0]) {
-		printk(KERN_ERR "input.c: calling hotplug without a hotplug agent defined\n");
-		return;
-	}
-	if (in_interrupt()) {
-		printk(KERN_ERR "input.c: calling hotplug from interrupt\n");
-		return;
-	}
-	if (!current->fs->root) {
-		printk(KERN_WARNING "input.c: calling hotplug without valid filesystem\n");
-		return;
-	}
-	if (!(envp = (char **) kmalloc(20 * sizeof(char *), GFP_KERNEL))) {
-		printk(KERN_ERR "input.c: not enough memory allocating hotplug environment\n");
-		return;
-	}
-	if (!(buf = kmalloc(1024, GFP_KERNEL))) {
-		kfree (envp);
-		printk(KERN_ERR "input.c: not enough memory allocating hotplug environment\n");
-		return;
-	}
-
-	argv[0] = hotplug_path;
-	argv[1] = "input";
-	argv[2] = NULL;
-
-	envp[i++] = "HOME=/";
-	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	char *scratch;
+	int i = 0, j;
+	scratch = buffer;
 
-	scratch = buf;
-
-	envp[i++] = scratch;
-	scratch += sprintf(scratch, "ACTION=%s", verb) + 1;
+	if (!dev)
+		return -ENODEV;
 
 	envp[i++] = scratch;
 	scratch += sprintf(scratch, "PRODUCT=%x/%x/%x/%x",
 		dev->id.bustype, dev->id.vendor, dev->id.product, dev->id.version) + 1;
 
+#ifdef INPUT_DEBUG
+	printk(KERN_DEBUG "%s: PRODUCT %x/%x/%x/%x\n", __FUNCTION__,
+	       dev->id.bustype, dev->id.vendor, dev->id.product, dev->id.version);
+#endif
 	if (dev->name) {
 		envp[i++] = scratch;
-		scratch += sprintf(scratch, "NAME=%s", dev->name) + 1;
+		scratch += sprintf(scratch, "NAME=\"%s\"", dev->name) + 1;
 	}
 
 	if (dev->phys) {
@@ -404,23 +382,120 @@
 
 	envp[i++] = NULL;
 
+	return 0;
+}
+
+int input_hotplug(struct class_device *cdev, char **envp, int num_envp,
+		  char *buffer, int buffer_size)
+{
+	struct input_dev *dev;
+
+	if (!cdev)
+		return -ENODEV;
 #ifdef INPUT_DEBUG
-	printk(KERN_DEBUG "input.c: calling %s %s [%s %s %s %s %s]\n",
-		argv[0], argv[1], envp[0], envp[1], envp[2], envp[3], envp[4]);
+	printk(KERN_DEBUG "%s: entered for dev %p\n", __FUNCTION__, 
+	       &cdev->dev);
 #endif
 
-	value = call_usermodehelper(argv [0], argv, envp, 0);
+	dev = container_of(cdev,struct input_dev,cdev);
 
-	kfree(buf);
-	kfree(envp);
+	return __input_hotplug(dev, envp, num_envp, buffer, buffer_size);
+}
 
-#ifdef INPUT_DEBUG
-	if (value != 0)
-		printk(KERN_DEBUG "input.c: hotplug returned %d\n", value);
 #endif
+
+#define INPUT_ATTR_BIT_B(bit, max) \
+	do { \
+		for (i = NBITS(max) - 1; i >= 0; i--) \
+			if (dev->bit[i]) break; \
+		for (; i >= 0; i--) \
+			len += sprintf(buf + len, "%lx ", dev->bit[i]); \
+		if (len) len += sprintf(buf + len, "\n"); \
+	} while (0)
+
+#define INPUT_ATTR_BIT_B2(bit, max, ev) \
+	do { \
+		if (test_bit(ev, dev->evbit)) \
+			INPUT_ATTR_BIT_B(bit, max); \
+	} while (0)
+
+
+static ssize_t input_class_show_ev(struct class_device *class_dev, char *buf)
+{
+	struct input_dev *dev = container_of(class_dev, struct input_dev,cdev);
+	int i, len = 0;
+
+	INPUT_ATTR_BIT_B(evbit, EV_MAX);
+	return len;
 }
 
-#endif
+#define INPUT_CLASS_ATTR_BIT(_name,_bit) \
+static ssize_t input_class_show_##_bit(struct class_device *class_dev, \
+				       char *buf) \
+{ \
+	struct input_dev *dev = container_of(class_dev,struct input_dev,cdev); \
+        int i, len = 0; \
+\
+	INPUT_ATTR_BIT_B2(_bit##bit, _name##_MAX, EV_##_name); \
+	return len; \
+}
+
+INPUT_CLASS_ATTR_BIT(KEY,key)
+INPUT_CLASS_ATTR_BIT(REL,rel)
+INPUT_CLASS_ATTR_BIT(ABS,abs)
+INPUT_CLASS_ATTR_BIT(MSC,msc)
+INPUT_CLASS_ATTR_BIT(LED,led)
+INPUT_CLASS_ATTR_BIT(SND,snd)
+INPUT_CLASS_ATTR_BIT(FF,ff)
+
+static ssize_t input_class_show_phys(struct class_device *class_dev, char *buf)
+{
+	struct input_dev *dev = container_of(class_dev,struct input_dev,cdev);
+
+	return sprintf(buf, "%s\n", dev->phys ? dev->phys : "(none)" );
+}
+
+static ssize_t input_class_show_name(struct class_device *class_dev, char *buf)
+{
+	struct input_dev *dev = container_of(class_dev,struct input_dev,cdev);
+
+	return sprintf(buf, "%s\n", dev->name ? dev->name : "(none)" );
+}
+
+static ssize_t input_class_show_product(struct class_device *class_dev, char *buf)
+{
+	struct input_dev *dev = container_of(class_dev,struct input_dev,cdev);
+
+	return sprintf(buf, "%x/%x/%x/%x\n", dev->id.bustype, dev->id.vendor, 
+		       dev->id.product, dev->id.version);
+}
+
+static struct class_device_attribute input_device_class_attrs[] = {
+	__ATTR( product, S_IRUGO, input_class_show_product, NULL) ,
+	__ATTR( phys, S_IRUGO, input_class_show_phys, NULL ),
+	__ATTR( name, S_IRUGO, input_class_show_name, NULL) ,
+	__ATTR( ev, S_IRUGO, input_class_show_ev, NULL) ,
+	__ATTR( key, S_IRUGO, input_class_show_key, NULL) ,
+	__ATTR( rel, S_IRUGO, input_class_show_rel, NULL) ,
+	__ATTR( abs, S_IRUGO, input_class_show_abs, NULL) ,
+	__ATTR( msc, S_IRUGO, input_class_show_msc, NULL) ,
+	__ATTR( led, S_IRUGO, input_class_show_led, NULL) ,
+	__ATTR( snd, S_IRUGO, input_class_show_snd, NULL) ,
+	__ATTR( ff, S_IRUGO, input_class_show_ff, NULL) ,
+	__ATTR_NULL,
+};
+
+static void input_device_class_release( struct class_device *class_dev )
+{
+	put_device(class_dev->dev);
+}
+
+static struct class input_device_class = {
+	.name =		"input_device",
+	.hotplug = 	input_hotplug,
+	.release = 	input_device_class_release,
+	.class_dev_attrs = input_device_class_attrs,
+};
 
 void input_register_device(struct input_dev *dev)
 {
@@ -428,6 +503,14 @@
 	struct input_handler *handler;
 	struct input_device_id *id;
 
+	dev->cdev.class = &input_device_class;
+	
+	dev->cdev.dev = get_device(dev->dev);
+	if (class_device_register(&dev->cdev)) {
+		put_device(dev->dev);
+		return;
+	}
+
 	set_bit(EV_SYN, dev->evbit);
 
 	/*
@@ -452,10 +535,6 @@
 				if ((handle = handler->connect(handler, dev, id)))
 					input_link_handle(handle);
 
-#ifdef CONFIG_HOTPLUG
-	input_call_hotplug("add", dev);
-#endif
-
 #ifdef CONFIG_PROC_FS
 	input_devices_state++;
 	wake_up(&input_devices_poll_wait);
@@ -480,12 +559,10 @@
 		handle->handler->disconnect(handle);
 	}
 
-#ifdef CONFIG_HOTPLUG
-	input_call_hotplug("remove", dev);
-#endif
-
 	list_del_init(&dev->node);
 
+	class_device_unregister(&dev->cdev);
+
 #ifdef CONFIG_PROC_FS
 	input_devices_state++;
 	wake_up(&input_devices_poll_wait);
@@ -720,15 +797,85 @@
 static inline int input_proc_init(void) { return 0; }
 #endif
 
-struct class_simple *input_class;
+static ssize_t input_class_show_dev(struct class_device *class_dev, char *buf)
+{
+	dev_t dev;
+	struct input_handle *handle = class_to_handle(class_dev);
+	struct gendev *gdev = to_gendev(handle);
+
+	dev = MKDEV(INPUT_MAJOR,handle->minor_base + gdev->minor);
+	return print_dev_t(buf, dev);
+}
+
+static struct class_device_attribute input_class_attrs[] = {
+	__ATTR( dev, S_IRUGO, input_class_show_dev, NULL),
+	__ATTR_NULL,
+};
+
+static void input_class_release(struct class_device *cdev)
+{
+	put_device(cdev->dev);
+}
+
+static struct class input_class = {
+	.name =		"input",
+	.release = 	input_class_release,
+	.class_dev_attrs = input_class_attrs,
+};
+
+int input_class_add_handle(struct input_handle *handle)
+{
+	struct gendev *gdev = to_gendev(handle);
+	struct device *hdev = NULL;
+	int retval;
+
+#ifdef INPUT_DEBUG
+	printk(KERN_DEBUG "%s: add handle for %s, minor %d (%p, %p)\n", 
+	       __FUNCTION__, gdev->name, gdev->minor,
+	       handle, handle->dev);
+#endif
+	handle->class_dev.class = &input_class;
+	if (handle->dev)
+		hdev = get_device(handle->dev->dev);
+
+#ifdef INPUT_DEBUG
+	if (hdev)
+		printk(KERN_DEBUG "%s: bus %p driver %p\n",
+		       __FUNCTION__, hdev->bus, hdev->driver);
+#endif
+
+	handle->class_dev.dev = hdev;
+	snprintf(handle->class_dev.class_id, BUS_ID_SIZE, "%s", gdev->name);
+	
+	retval = class_device_register(&handle->class_dev);
+	if (retval) {
+		if (hdev)
+			put_device(handle->dev->dev);
+		return retval;
+	}
+	return 0;
+}
+
+void input_class_remove_handle(struct input_handle *handle)
+{
+	put_device(handle->class_dev.dev);
+	class_device_unregister(&handle->class_dev);
+}
 
 static int __init input_init(void)
 {
 	int retval = -ENOMEM;
 
-	input_class = class_simple_create(THIS_MODULE, "input");
-	if (IS_ERR(input_class))
-		return PTR_ERR(input_class);
+	retval = class_register(&input_class);
+	if (retval)
+		return retval;
+
+	retval = class_register(&input_device_class);
+	if (retval) {
+		class_unregister(&input_class);
+		return retval;
+	}
+
 	input_proc_init();
 	retval = register_chrdev(INPUT_MAJOR, "input", &input_fops);
 	if (retval) {
@@ -736,7 +883,8 @@
 		remove_proc_entry("devices", proc_bus_input_dir);
 		remove_proc_entry("handlers", proc_bus_input_dir);
 		remove_proc_entry("input", proc_bus);
-		class_simple_destroy(input_class);
+		class_unregister(&input_device_class);
+		class_unregister(&input_class);
 		return retval;
 	}
 
@@ -746,7 +894,8 @@
 		remove_proc_entry("handlers", proc_bus_input_dir);
 		remove_proc_entry("input", proc_bus);
 		unregister_chrdev(INPUT_MAJOR, "input");
-		class_simple_destroy(input_class);
+		class_unregister(&input_device_class);
+		class_unregister(&input_class);
 	}
 	return retval;
 }
@@ -759,7 +908,8 @@
 
 	devfs_remove("input");
 	unregister_chrdev(INPUT_MAJOR, "input");
-	class_simple_destroy(input_class);
+	class_unregister(&input_device_class);
+	class_unregister(&input_class);
 }
 
 subsys_initcall(input_init);
diff -urN linux-2.6.8-inp/drivers/input/joydev.c linux-2.6.8-inp-sysfs/drivers/input/joydev.c
--- linux-2.6.8-inp/drivers/input/joydev.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/joydev.c	2004-09-20 14:23:08.899811148 +0200
@@ -47,6 +47,7 @@
 	struct input_handle handle;
 	wait_queue_head_t wait;
 	struct list_head list;
+
 	struct js_corr corr[ABS_MAX];
 	struct JS_DATA_SAVE_TYPE glue;
 	int nabs;
@@ -145,7 +146,7 @@
 {
 	devfs_remove("input/js%d", joydev->minor);
 	joydev_table[joydev->minor] = NULL;
-	class_simple_device_remove(MKDEV(INPUT_MAJOR, JOYDEV_MINOR_BASE + joydev->minor));
+	input_class_remove_handle(&joydev->handle);
 	kfree(joydev);
 }
 
@@ -409,6 +410,7 @@
 	joydev->handle.name = joydev->name;
 	joydev->handle.handler = handler;
 	joydev->handle.private = joydev;
+	joydev->handle.minor_base = JOYDEV_MINOR_BASE;
 	sprintf(joydev->name, "js%d", minor);
 
 	for (i = 0; i < ABS_MAX; i++)
@@ -455,9 +457,8 @@
 
 	devfs_mk_cdev(MKDEV(INPUT_MAJOR, JOYDEV_MINOR_BASE + minor),
 			S_IFCHR|S_IRUGO|S_IWUSR, "input/js%d", minor);
-	class_simple_device_add(input_class,
-				MKDEV(INPUT_MAJOR, JOYDEV_MINOR_BASE + minor),
-				dev->dev, "js%d", minor);
+
+	input_class_add_handle(&joydev->handle);
 
 	return &joydev->handle;
 }
diff -urN linux-2.6.8-inp/drivers/input/keyboard/amikbd.c linux-2.6.8-inp-sysfs/drivers/input/keyboard/amikbd.c
--- linux-2.6.8-inp/drivers/input/keyboard/amikbd.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/keyboard/amikbd.c	2004-09-20 14:23:08.899811148 +0200
@@ -222,6 +222,7 @@
 	amikbd_dev.id.vendor = 0x0001;
 	amikbd_dev.id.product = 0x0001;
 	amikbd_dev.id.version = 0x0100;
+	sprintf(amikbd_dev.cdev.class_id,"amikbd");
 
 	input_register_device(&amikbd_dev);
 
diff -urN linux-2.6.8-inp/drivers/input/keyboard/atkbd.c linux-2.6.8-inp-sysfs/drivers/input/keyboard/atkbd.c
--- linux-2.6.8-inp/drivers/input/keyboard/atkbd.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/keyboard/atkbd.c	2004-09-20 14:23:08.900810975 +0200
@@ -175,6 +175,8 @@
 #define ATKBD_FLAG_CMD1		2	/* First byte of command response */
 #define ATKBD_FLAG_ENABLED	3	/* Waining for init to finish */
 
+static int atkbd_num;
+
 /*
  * The atkbd control structure
  */
@@ -802,6 +804,7 @@
 	flush_scheduled_work();
 
 	input_unregister_device(&atkbd->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(atkbd);
 }
@@ -925,6 +928,8 @@
 	atkbd->dev.id.vendor = 0x0001;
 	atkbd->dev.id.product = atkbd->translated ? 1 : atkbd->set;
 	atkbd->dev.id.version = atkbd->id;
+	atkbd->dev.dev = get_device(&serio->dev);
+	sprintf(atkbd->dev.cdev.class_id,"atkbd%d",atkbd_num++);
 
 	for (i = 0; i < 512; i++)
 		if (atkbd->keycode[i] && atkbd->keycode[i] < ATKBD_SPECIAL)
diff -urN linux-2.6.8-inp/drivers/input/keyboard/lkkbd.c linux-2.6.8-inp-sysfs/drivers/input/keyboard/lkkbd.c
--- linux-2.6.8-inp/drivers/input/keyboard/lkkbd.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/keyboard/lkkbd.c	2004-09-20 14:30:49.128355199 +0200
@@ -298,6 +298,8 @@
 	int ctrlclick_volume;
 };
 
+int lkkbd_num;
+
 /*
  * Calculate volume parameter byte for a given volume.
  */
@@ -685,6 +687,8 @@
 	lk->dev.id.vendor = SERIO_LKKBD;
 	lk->dev.id.product = 0;
 	lk->dev.id.version = 0x0100;
+	lk->dev.dev = get_device(&serio->dev);
+	sprintf(lk->dev.cdev.class_id,"lkkbd%d",lkkbd_num++);
 
 	input_register_device (&lk->dev);
 
@@ -701,6 +705,7 @@
 	struct lkkbd *lk = serio->private;
 
 	input_unregister_device (&lk->dev);
+	put_device(&serio->dev);
 	serio_close (serio);
 	kfree (lk);
 }
diff -urN linux-2.6.8-inp/drivers/input/keyboard/maple_keyb.c linux-2.6.8-inp-sysfs/drivers/input/keyboard/maple_keyb.c
--- linux-2.6.8-inp/drivers/input/keyboard/maple_keyb.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/keyboard/maple_keyb.c	2004-09-20 14:23:08.900810975 +0200
@@ -43,6 +43,7 @@
 	int open;
 };
 
+static int dc_kbd_num;
 
 static void dc_scan_kbd(struct dc_kbd *kbd)
 {
@@ -139,6 +140,7 @@
 
 	kbd->dev.name = dev->product_name;
 	kbd->dev.id.bustype = BUS_MAPLE;
+	sprintf(kbd->dev.cdev.class_id,"dckbd%d",dc_kdb_num++);
 
 	input_register_device(&kbd->dev);
 
diff -urN linux-2.6.8-inp/drivers/input/keyboard/newtonkbd.c linux-2.6.8-inp-sysfs/drivers/input/keyboard/newtonkbd.c
--- linux-2.6.8-inp/drivers/input/keyboard/newtonkbd.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/keyboard/newtonkbd.c	2004-09-20 14:23:08.901810802 +0200
@@ -59,6 +59,8 @@
 
 static char *nkbd_name = "Newton Keyboard";
 
+static int nkbd_num;
+
 struct nkbd {
 	unsigned char keycode[128];
 	struct input_dev dev;
@@ -126,6 +128,8 @@
 	nkbd->dev.id.vendor = SERIO_NEWTON;
 	nkbd->dev.id.product = 0x0001;
 	nkbd->dev.id.version = 0x0100;
+	nkbd->dev.dev = get_device(&serio->dev);
+	sprintf(nkbd->dev.cdev.class_id,"nkbd%d",nkbd_num++);
 
 	input_register_device(&nkbd->dev);
 
@@ -136,6 +140,7 @@
 {
 	struct nkbd *nkbd = serio->private;
 	input_unregister_device(&nkbd->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(nkbd);
 }
diff -urN linux-2.6.8-inp/drivers/input/keyboard/sunkbd.c linux-2.6.8-inp-sysfs/drivers/input/keyboard/sunkbd.c
--- linux-2.6.8-inp/drivers/input/keyboard/sunkbd.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/keyboard/sunkbd.c	2004-09-20 14:23:08.901810802 +0200
@@ -70,6 +70,8 @@
 #define SUNKBD_RELEASE		0x80
 #define SUNKBD_KEY		0x7f
 
+static int sunkbd_num;
+
 /*
  * Per-keyboard data.
  */
@@ -285,6 +287,8 @@
 	sunkbd->dev.id.vendor = SERIO_SUNKBD;
 	sunkbd->dev.id.product = sunkbd->type;
 	sunkbd->dev.id.version = 0x0100;
+	sunkbd->dev.dev = get_device(&serio->dev);
+	sprintf(sunkbd->dev.cdev.class_id,"sunkbd%d", sunkbd_num++);
 
 	input_register_device(&sunkbd->dev);
 
@@ -299,6 +303,7 @@
 {
 	struct sunkbd *sunkbd = serio->private;
 	input_unregister_device(&sunkbd->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(sunkbd);
 }
diff -urN linux-2.6.8-inp/drivers/input/keyboard/xtkbd.c linux-2.6.8-inp-sysfs/drivers/input/keyboard/xtkbd.c
--- linux-2.6.8-inp/drivers/input/keyboard/xtkbd.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/keyboard/xtkbd.c	2004-09-20 14:23:08.901810802 +0200
@@ -58,6 +58,8 @@
 
 static char *xtkbd_name = "XT Keyboard";
 
+static int xtkbd_num;
+
 struct xtkbd {
 	unsigned char keycode[256];
 	struct input_dev dev;
@@ -131,6 +133,8 @@
 	xtkbd->dev.id.vendor = 0x0001;
 	xtkbd->dev.id.product = 0x0001;
 	xtkbd->dev.id.version = 0x0100;
+	xtkbd->dev.dev = get_device(&serio->dev);
+	sprintf(xtkbd->dev.cdev.class_id,"xtkbd%d",xtkbd_num++);
 
 	input_register_device(&xtkbd->dev);
 
@@ -141,6 +145,7 @@
 {
 	struct xtkbd *xtkbd = serio->private;
 	input_unregister_device(&xtkbd->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(xtkbd);
 }
diff -urN linux-2.6.8-inp/drivers/input/misc/m68kspkr.c linux-2.6.8-inp-sysfs/drivers/input/misc/m68kspkr.c
--- linux-2.6.8-inp/drivers/input/misc/m68kspkr.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/misc/m68kspkr.c	2004-09-20 14:23:08.902810630 +0200
@@ -66,6 +66,7 @@
 	m68kspkr_dev.id.vendor = 0x001f;
 	m68kspkr_dev.id.product = 0x0001;
 	m68kspkr_dev.id.version = 0x0100;
+	sprintf(m68kspkr_dev.cdev.class_id,"m68kspeaker");
 
 	input_register_device(&m68kspkr_dev);
 
diff -urN linux-2.6.8-inp/drivers/input/misc/pcspkr.c linux-2.6.8-inp-sysfs/drivers/input/misc/pcspkr.c
--- linux-2.6.8-inp/drivers/input/misc/pcspkr.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/misc/pcspkr.c	2004-09-20 14:23:08.902810630 +0200
@@ -78,6 +78,7 @@
 	pcspkr_dev.id.vendor = 0x001f;
 	pcspkr_dev.id.product = 0x0001;
 	pcspkr_dev.id.version = 0x0100;
+	sprintf(pcspkr_dev.cdev.class_id,"pcspeaker");
 
 	input_register_device(&pcspkr_dev);
 
diff -urN linux-2.6.8-inp/drivers/input/misc/sparcspkr.c linux-2.6.8-inp-sysfs/drivers/input/misc/sparcspkr.c
--- linux-2.6.8-inp/drivers/input/misc/sparcspkr.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/misc/sparcspkr.c	2004-09-20 14:23:08.902810630 +0200
@@ -26,6 +26,7 @@
 static char *sparcspkr_ebus_name = "Sparc EBUS Speaker";
 static char *sparcspkr_phys = "sparc/input0";
 static struct input_dev sparcspkr_dev;
+static int sparcspkr_num;
 
 spinlock_t beep_lock = SPIN_LOCK_UNLOCKED;
 
@@ -88,6 +89,7 @@
 
 	sparcspkr_dev.name = sparcspkr_ebus_name;
 	sparcspkr_dev.event = ebus_spkr_event;
+	sprintf(sparcspkr_dev.cdev.class_id,"sparcspeaker%d", sparcspkr_num++);
 
 	input_register_device(&sparcspkr_dev);
 
@@ -142,6 +144,7 @@
 	sparcspkr_dev.name = sparcspkr_isa_name;
 	sparcspkr_dev.event = isa_spkr_event;
 	sparcspkr_dev.id.bustype = BUS_ISA;
+	sprintf(sparcspkr_dev.cdev.class_id,"sparcspeaker%d", sparcspkr_num++);
 
 	input_register_device(&sparcspkr_dev);
 
diff -urN linux-2.6.8-inp/drivers/input/mouse/amimouse.c linux-2.6.8-inp-sysfs/drivers/input/mouse/amimouse.c
--- linux-2.6.8-inp/drivers/input/mouse/amimouse.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/amimouse.c	2004-09-20 14:23:08.902810630 +0200
@@ -121,6 +121,7 @@
 	amimouse_dev.id.vendor = 0x0001;
 	amimouse_dev.id.product = 0x0002;
 	amimouse_dev.id.version = 0x0100;
+	sprintf(amimouse_dev.cdev.class_id,"amimouse");
 
 	input_register_device(&amimouse_dev);
 
diff -urN linux-2.6.8-inp/drivers/input/mouse/inport.c linux-2.6.8-inp-sysfs/drivers/input/mouse/inport.c
--- linux-2.6.8-inp/drivers/input/mouse/inport.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/inport.c	2004-09-20 14:23:08.903810457 +0200
@@ -126,6 +126,9 @@
         	.product = 0x0001,
         	.version = 0x0100,
 	},
+	.cdev = {
+		.class_id = "inport",
+	},
 };
 
 static irqreturn_t inport_interrupt(int irq, void *dev_id, struct pt_regs *regs)
diff -urN linux-2.6.8-inp/drivers/input/mouse/logibm.c linux-2.6.8-inp-sysfs/drivers/input/mouse/logibm.c
--- linux-2.6.8-inp/drivers/input/mouse/logibm.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/logibm.c	2004-09-20 14:23:08.903810457 +0200
@@ -116,6 +116,9 @@
 		.product = 0x0001,
 		.version = 0x0100,
 	},
+	.cdev    = {
+		.class_id  = "logibm",
+	},
 };
 
 static irqreturn_t logibm_interrupt(int irq, void *dev_id, struct pt_regs *regs)
diff -urN linux-2.6.8-inp/drivers/input/mouse/maplemouse.c linux-2.6.8-inp-sysfs/drivers/input/mouse/maplemouse.c
--- linux-2.6.8-inp/drivers/input/mouse/maplemouse.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/maplemouse.c	2004-09-20 14:23:08.903810457 +0200
@@ -20,6 +20,7 @@
 	int open;
 };
 
+static int dc_mouse_num;
 
 static void dc_mouse_callback(struct mapleq *mq)
 {
@@ -83,6 +84,7 @@
 
 	mouse->dev.name = dev->product_name;
 	mouse->dev.id.bustype = BUS_MAPLE;
+	sprintf(mouse->dev.cdev.class_id,"dcmouse%d", dc_mouse_num++);
 	
 	input_register_device(&mouse->dev);
 
diff -urN linux-2.6.8-inp/drivers/input/mouse/pc110pad.c linux-2.6.8-inp-sysfs/drivers/input/mouse/pc110pad.c
--- linux-2.6.8-inp/drivers/input/mouse/pc110pad.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/pc110pad.c	2004-09-20 14:23:08.904810285 +0200
@@ -49,17 +49,35 @@
 #define PC110PAD_OFF	0x30
 #define PC110PAD_ON	0x38
 
+static int pc110pad_open(struct input_dev *dev);
+static void pc110pad_close(struct input_dev *dev);
+
 static int pc110pad_irq = 10;
 static int pc110pad_io = 0x15e0;
 
-static struct input_dev pc110pad_dev;
+static struct input_dev pc110pad_dev = {
+	.evbit	= { BIT(EV_KEY) | BIT(EV_ABS) },
+	.absbit = { BIT(ABS_X) | BIT(ABS_Y) },
+	.keybit = { [LONG(BTN_TOUCH)] = BIT(BTN_TOUCH) },
+	.open	= pc110pad_open,
+	.close	= pc110pad_close,
+	.name	= "IBM PC110 TouchPad",
+	.phys	= "isa15e0/input0",
+	.id	= {
+		.bustype = BUS_ISA,
+		.vendor = 0x0003,
+		.product = 0x0001,
+		.version = 0x0100,
+	},
+	.cdev	= {
+		.class_id	= "pc110pad",
+	},
+};
+
 static int pc110pad_data[3];
 static int pc110pad_count;
 static int pc110pad_used;
 
-static char *pc110pad_name = "IBM PC110 TouchPad";
-static char *pc110pad_phys = "isa15e0/input0";
-
 static irqreturn_t pc110pad_interrupt(int irq, void *ptr, struct pt_regs *regs)
 {
 	int value     = inb_p(pc110pad_io);
@@ -124,27 +142,13 @@
 		return -EBUSY;
 	}
 
-        pc110pad_dev.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
-        pc110pad_dev.absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
-        pc110pad_dev.keybit[LONG(BTN_TOUCH)] = BIT(BTN_TOUCH);
-
 	pc110pad_dev.absmax[ABS_X] = 0x1ff;
 	pc110pad_dev.absmax[ABS_Y] = 0x0ff;
-        
-	pc110pad_dev.open = pc110pad_open;
-        pc110pad_dev.close = pc110pad_close;
-
-	pc110pad_dev.name = pc110pad_name;
-	pc110pad_dev.phys = pc110pad_phys;
-	pc110pad_dev.id.bustype = BUS_ISA;
-	pc110pad_dev.id.vendor = 0x0003;
-	pc110pad_dev.id.product = 0x0001;
-	pc110pad_dev.id.version = 0x0100;
 
 	input_register_device(&pc110pad_dev);	
 
 	printk(KERN_INFO "input: %s at %#x irq %d\n",
-		pc110pad_name, pc110pad_io, pc110pad_irq);
+		pc110pad_dev.name, pc110pad_io, pc110pad_irq);
 	
 	return 0;
 }
diff -urN linux-2.6.8-inp/drivers/input/mouse/psmouse-base.c linux-2.6.8-inp-sysfs/drivers/input/mouse/psmouse-base.c
--- linux-2.6.8-inp/drivers/input/mouse/psmouse-base.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/psmouse-base.c	2004-09-20 14:23:08.904810285 +0200
@@ -57,6 +57,8 @@
 
 static char *psmouse_protocols[] = { "None", "PS/2", "PS2++", "PS2T++", "GenPS/2", "ImPS/2", "ImExPS/2", "SynPS/2"};
 
+static int psmouse_num;
+
 /*
  * psmouse_process_byte() analyzes the PS/2 data stream and reports
  * relevant events to the input module once full packet has arrived.
@@ -725,6 +727,7 @@
 	psmouse_set_state(psmouse, PSMOUSE_IGNORE);
 
 	input_unregister_device(&psmouse->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(psmouse);
 }
@@ -797,6 +800,8 @@
 	psmouse->dev.id.vendor = 0x0002;
 	psmouse->dev.id.product = psmouse->type;
 	psmouse->dev.id.version = psmouse->model;
+	psmouse->dev.dev = get_device(&serio->dev);
+	sprintf(psmouse->dev.cdev.class_id,"psmouse%d", psmouse_num++);
 
 	input_register_device(&psmouse->dev);
 
diff -urN linux-2.6.8-inp/drivers/input/mouse/rpcmouse.c linux-2.6.8-inp-sysfs/drivers/input/mouse/rpcmouse.c
--- linux-2.6.8-inp/drivers/input/mouse/rpcmouse.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/rpcmouse.c	2004-09-20 14:23:08.905810112 +0200
@@ -47,6 +47,9 @@
 		.product = 0x0001,
 		.version = 0x0100,
 	},
+	.cdev	= {
+		.class_id = "rpcmouse",
+	},
 };
 
 static irqreturn_t rpcmouse_irq(int irq, void *dev_id, struct pt_regs *regs)
diff -urN linux-2.6.8-inp/drivers/input/mouse/sermouse.c linux-2.6.8-inp-sysfs/drivers/input/mouse/sermouse.c
--- linux-2.6.8-inp/drivers/input/mouse/sermouse.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/sermouse.c	2004-09-20 14:23:08.905810112 +0200
@@ -47,6 +47,8 @@
 					"Logitech M+ Mouse", "Microsoft MZ Mouse", "Logitech MZ+ Mouse",
 					"Logitech MZ++ Mouse"};
 
+static int sermouse_num;
+
 struct sermouse {
 	struct input_dev dev;
 	signed char buf[8];
@@ -230,6 +232,7 @@
 {
 	struct sermouse *sermouse = serio->private;
 	input_unregister_device(&sermouse->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(sermouse);
 }
@@ -280,6 +283,8 @@
 	sermouse->dev.id.vendor = sermouse->type;
 	sermouse->dev.id.product = c;
 	sermouse->dev.id.version = 0x0100;
+	sermouse->dev.dev = get_device(&serio->dev);
+	sprintf(sermouse->dev.cdev.class_id,"sermouse%d", sermouse_num++);
 
 	if (serio_open(serio, drv)) {
 		kfree(sermouse);
diff -urN linux-2.6.8-inp/drivers/input/mouse/vsxxxaa.c linux-2.6.8-inp-sysfs/drivers/input/mouse/vsxxxaa.c
--- linux-2.6.8-inp/drivers/input/mouse/vsxxxaa.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mouse/vsxxxaa.c	2004-09-20 14:23:08.905810112 +0200
@@ -106,7 +106,7 @@
 #define VSXXXAA_PACKET_POR	0xa0
 #define MATCH_PACKET_TYPE(data, type)	(((data) & VSXXXAA_PACKET_MASK) == type)
 
-
+static int vsxxxaa_num;
 
 struct vsxxxaa {
 	struct input_dev dev;
@@ -479,6 +479,7 @@
 	struct vsxxxaa *mouse = serio->private;
 
 	input_unregister_device (&mouse->dev);
+	put_device(&serio->dev);
 	serio_close (serio);
 	kfree (mouse);
 }
@@ -537,6 +538,9 @@
 	 */
 	mouse->serio->write (mouse->serio, 'T'); /* Test */
 
+	mouse->dev.dev = get_device(&serio->dev);
+	sprintf(mouse->dev.cdev.class_id,"decmouse%d", vsxxxaa_num++);
+
 	input_register_device (&mouse->dev);
 
 	printk (KERN_INFO "input: %s on %s\n", mouse->name, mouse->phys);
diff -urN linux-2.6.8-inp/drivers/input/mousedev.c linux-2.6.8-inp-sysfs/drivers/input/mousedev.c
--- linux-2.6.8-inp/drivers/input/mousedev.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/mousedev.c	2004-09-20 14:23:08.906809939 +0200
@@ -64,9 +64,9 @@
 	int open;
 	int minor;
 	char name[16];
+	struct input_handle handle;
 	wait_queue_head_t wait;
 	struct list_head list;
-	struct input_handle handle;
 
 	struct mousedev_hw_data packet;
 	unsigned int pkt_count;
@@ -330,7 +330,7 @@
 static void mousedev_free(struct mousedev *mousedev)
 {
 	devfs_remove("input/mouse%d", mousedev->minor);
-	class_simple_device_remove(MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + mousedev->minor));
+	input_class_remove_handle(&mousedev->handle);
 	mousedev_table[mousedev->minor] = NULL;
 	kfree(mousedev);
 }
@@ -620,6 +620,7 @@
 	mousedev->handle.name = mousedev->name;
 	mousedev->handle.handler = handler;
 	mousedev->handle.private = mousedev;
+	mousedev->handle.minor_base = MOUSEDEV_MINOR_BASE;
 	sprintf(mousedev->name, "mouse%d", minor);
 
 	if (mousedev_mix.open)
@@ -629,9 +630,8 @@
 
 	devfs_mk_cdev(MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + minor),
 			S_IFCHR|S_IRUGO|S_IWUSR, "input/mouse%d", minor);
-	class_simple_device_add(input_class,
-				MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + minor),
-				dev->dev, "mouse%d", minor);
+
+	input_class_add_handle(&mousedev->handle);
 
 	return &mousedev->handle;
 }
@@ -708,12 +708,14 @@
 	mousedev_table[MOUSEDEV_MIX] = &mousedev_mix;
 	mousedev_mix.exist = 1;
 	mousedev_mix.minor = MOUSEDEV_MIX;
+	mousedev_mix.handle.minor_base = MOUSEDEV_MINOR_BASE;
+	mousedev_mix.handle.name = mousedev_mix.name;
+	sprintf(mousedev_mix.name,"mice");
 
 	devfs_mk_cdev(MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + MOUSEDEV_MIX),
 			S_IFCHR|S_IRUGO|S_IWUSR, "input/mice");
-	class_simple_device_add(input_class, MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + MOUSEDEV_MIX),
-				NULL, "mice");
 
+	input_class_add_handle(&mousedev_mix.handle);
 #ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
 	if (!(psaux_registered = !misc_register(&psaux_mouse)))
 		printk(KERN_WARNING "mice: could not misc_register the device\n");
@@ -731,7 +733,7 @@
 		misc_deregister(&psaux_mouse);
 #endif
 	devfs_remove("input/mice");
-	class_simple_device_remove(MKDEV(INPUT_MAJOR, MOUSEDEV_MINOR_BASE + MOUSEDEV_MIX));
+	input_class_remove_handle(&mousedev_mix.handle);
 	input_unregister_handler(&mousedev_handler);
 }
 
diff -urN linux-2.6.8-inp/drivers/input/serio/i8042.c linux-2.6.8-inp-sysfs/drivers/input/serio/i8042.c
--- linux-2.6.8-inp/drivers/input/serio/i8042.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/serio/i8042.c	2004-09-20 14:23:08.907809767 +0200
@@ -997,7 +997,7 @@
 int __init i8042_init(void)
 {
 	int i;
-	int err;
+	int err, has_aux = 0, has_mux = 0;
 
 	dbg_init();
 
@@ -1025,15 +1025,9 @@
 
 	if (!i8042_noaux && !i8042_check_aux(&i8042_aux_values)) {
 		if (!i8042_nomux && !i8042_check_mux(&i8042_aux_values))
-			for (i = 0; i < I8042_NUM_MUX_PORTS; i++) {
-				i8042_mux_port[i] = i8042_allocate_mux_port(i);
-				if (i8042_mux_port[i])
-					i8042_port_register(i8042_mux_port[i]);
-			}
+			has_mux = 1;
 		else {
-			i8042_aux_port = i8042_allocate_aux_port();
-			if (i8042_aux_port)
-				i8042_port_register(i8042_aux_port);
+			has_aux = 1;
 		}
 	}
 
@@ -1041,6 +1035,19 @@
 	if (i8042_kbd_port)
 		i8042_port_register(i8042_kbd_port);
 
+	if (has_mux)
+		for (i = 0; i < I8042_NUM_MUX_PORTS; i++) {
+			i8042_mux_port[i] = i8042_allocate_mux_port(i);
+			if (i8042_mux_port[i])
+				i8042_port_register(i8042_mux_port[i]);
+		}
+
+	if (has_aux) {
+		i8042_aux_port = i8042_allocate_aux_port();
+		if (i8042_aux_port)
+			i8042_port_register(i8042_aux_port);
+	}
+
 	mod_timer(&i8042_timer, jiffies + I8042_POLL_PERIOD);
 
 	i8042_pm_dev = pm_register(PM_SYS_DEV, PM_SYS_UNKNOWN, i8042_pm_callback);
diff -urN linux-2.6.8-inp/drivers/input/serio/serio.c linux-2.6.8-inp-sysfs/drivers/input/serio/serio.c
--- linux-2.6.8-inp/drivers/input/serio/serio.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/serio/serio.c	2004-09-20 14:23:08.907809767 +0200
@@ -305,8 +305,15 @@
 	return retval;
 }
 
+static ssize_t serio_show_phys(struct device *dev, char *buf)
+{
+	struct serio *serio = to_serio_port(dev);
+	return sprintf(buf, "%s\n", serio->phys ? serio->phys : "(none)");
+}
+
 static struct device_attribute serio_device_attrs[] = {
 	__ATTR(description, S_IRUGO, serio_show_description, NULL),
+	__ATTR(phys, S_IRUGO, serio_show_phys, NULL),
 	__ATTR(driver, S_IWUSR | S_IRUGO, serio_show_driver, serio_rebind_driver),
 	__ATTR(bind_mode, S_IWUSR | S_IRUGO, serio_show_bind_mode, serio_set_bind_mode),
 	__ATTR_NULL
diff -urN linux-2.6.8-inp/drivers/input/tsdev.c linux-2.6.8-inp-sysfs/drivers/input/tsdev.c
--- linux-2.6.8-inp/drivers/input/tsdev.c	2004-09-20 10:33:04.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/input/tsdev.c	2004-09-20 14:23:08.908809594 +0200
@@ -111,10 +111,11 @@
 	int exist;
 	int open;
 	int minor;
-	char name[8];
+	char name[16];
+	struct input_handle handle;
 	wait_queue_head_t wait;
 	struct list_head list;
-	struct input_handle handle;
+
 	int x, y, pressure;
 	struct ts_calibration cal;
 };
@@ -178,7 +179,7 @@
 static void tsdev_free(struct tsdev *tsdev)
 {
 	devfs_remove("input/ts%d", tsdev->minor);
-	class_simple_device_remove(MKDEV(INPUT_MAJOR, TSDEV_MINOR_BASE + tsdev->minor));
+	input_class_remove_handle(&tsdev->handle);
 	tsdev_table[tsdev->minor] = NULL;
 	kfree(tsdev);
 }
@@ -398,6 +399,7 @@
 	tsdev->handle.name = tsdev->name;
 	tsdev->handle.handler = handler;
 	tsdev->handle.private = tsdev;
+	tsdev->handle.minor_base = TSDEV_MINOR_BASE;
 
 	/* Precompute the rough calibration matrix */
 	delta = dev->absmax [ABS_X] - dev->absmin [ABS_X] + 1;
@@ -418,9 +420,8 @@
 			S_IFCHR|S_IRUGO|S_IWUSR, "input/ts%d", minor);
 	devfs_mk_cdev(MKDEV(INPUT_MAJOR, TSDEV_MINOR_BASE + minor + TSDEV_MINORS/2),
 			S_IFCHR|S_IRUGO|S_IWUSR, "input/tsraw%d", minor);
-	class_simple_device_add(input_class, 
-				MKDEV(INPUT_MAJOR, TSDEV_MINOR_BASE + minor),
-				dev->dev, "ts%d", minor);
+
+	input_class_add_handle(&tsdev->handle);
 
 	return &tsdev->handle;
 }
diff -urN linux-2.6.8-inp/drivers/usb/input/hid-input.c linux-2.6.8-inp-sysfs/drivers/usb/input/hid-input.c
--- linux-2.6.8-inp/drivers/usb/input/hid-input.c	2004-09-20 10:33:09.000000000 +0200
+++ linux-2.6.8-inp-sysfs/drivers/usb/input/hid-input.c	2004-09-20 14:23:08.908809594 +0200
@@ -55,6 +55,8 @@
 	150,158,159,128,136,177,178,176,142,152,173,140,unk,unk,unk,unk
 };
 
+static int hidinput_num;
+
 static struct {
 	__s32 x;
 	__s32 y;
@@ -597,6 +599,8 @@
 				hidinput->input.id.product = dev->descriptor.idProduct;
 				hidinput->input.id.version = dev->descriptor.bcdDevice;
 				hidinput->input.dev = &hid->intf->dev;
+				sprintf(hidinput->input.cdev.class_id,"usbhid%d",
+					hidinput_num++);
 			}
 
 			for (i = 0; i < report->maxfield; i++)
diff -urN linux-2.6.8-inp/include/linux/input.h linux-2.6.8-inp-sysfs/include/linux/input.h
--- linux-2.6.8-inp/include/linux/input.h	2004-09-20 14:05:53.000000000 +0200
+++ linux-2.6.8-inp-sysfs/include/linux/input.h	2004-09-20 14:23:08.909809421 +0200
@@ -12,6 +12,7 @@
 #ifdef __KERNEL__
 #include <linux/time.h>
 #include <linux/list.h>
+#include <linux/device.h>
 #else
 #include <sys/time.h>
 #include <sys/ioctl.h>
@@ -829,6 +830,7 @@
 
 	struct input_handle *grab;
 	struct device *dev;
+	struct class_device cdev;
 
 	struct list_head	h_list;
 	struct list_head	node;
@@ -902,10 +904,10 @@
 
 	int open;
 	char *name;
-
+	int minor_base;
 	struct input_dev *dev;
 	struct input_handler *handler;
-
+	struct class_device     class_dev;
 	struct list_head	d_node;
 	struct list_head	h_node;
 };
@@ -914,6 +916,19 @@
 #define to_handler(n) container_of(n,struct input_handler,node);
 #define to_handle(n) container_of(n,struct input_handle,d_node)
 #define to_handle_h(n) container_of(n,struct input_handle,h_node)
+#define class_to_handle(n) container_of(n,struct input_handle, class_dev);
+
+struct gendev {
+	int exist;
+	int open;
+	int minor;
+	char name[16];
+	struct input_handle handle;
+	wait_queue_head_t wait;
+	struct list_head list;
+};
+
+#define to_gendev(n) container_of(n,struct gendev, handle)
 
 static inline void init_input_dev(struct input_dev *dev)
 {
@@ -927,6 +942,9 @@
 void input_register_handler(struct input_handler *);
 void input_unregister_handler(struct input_handler *);
 
+int input_class_add_handle(struct input_handle *handle);
+void input_class_remove_handle(struct input_handle *handle);
+
 int input_grab_device(struct input_handle *);
 void input_release_device(struct input_handle *);
 
@@ -984,7 +1002,5 @@
 	dev->absbit[LONG(axis)] |= BIT(axis);
 }
 
-extern struct class_simple *input_class;
-
 #endif
 #endif
