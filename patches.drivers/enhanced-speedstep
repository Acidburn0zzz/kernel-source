diff -urNp linux-2.6.5/arch/i386/kernel/acpi/boot.c linux-2.6.5.SUSE/arch/i386/kernel/acpi/boot.c
--- linux-2.6.5/arch/i386/kernel/acpi/boot.c	2004-04-30 15:00:02.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/kernel/acpi/boot.c	2004-04-30 15:00:26.000000000 +0200
@@ -72,6 +72,10 @@ static u64 acpi_lapic_addr __initdata = 
 #warning ACPI uses CMPXCHG, i486 and later hardware
 #endif
 
+#define MAX_MADT_ENTRIES	256
+u8 x86_acpiid_to_apicid[MAX_MADT_ENTRIES] =
+			{ [0 ... MAX_MADT_ENTRIES-1] = 0xff };
+
 /* --------------------------------------------------------------------------
                               Boot-time Configuration
    -------------------------------------------------------------------------- */
@@ -212,6 +216,8 @@ acpi_parse_lapic (
 	if (processor->flags.enabled == 0)
 		return 0;
 
+	x86_acpiid_to_apicid[processor->acpi_id] = processor->id;
+
 	mp_register_lapic (
 		processor->id,					   /* APIC ID */
 		processor->flags.enabled);			  /* Enabled? */
diff -urNp linux-2.6.5/arch/i386/kernel/cpu/cpufreq/acpi.c linux-2.6.5.SUSE/arch/i386/kernel/cpu/cpufreq/acpi.c
--- linux-2.6.5/arch/i386/kernel/cpu/cpufreq/acpi.c	2004-04-04 05:36:18.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/kernel/cpu/cpufreq/acpi.c	2004-04-30 15:00:29.000000000 +0200
@@ -34,6 +34,7 @@
 #include <asm/io.h>
 #include <asm/delay.h>
 #include <asm/uaccess.h>
+#include <asm/msr.h>
 
 #include <linux/acpi.h>
 #include <acpi/processor.h>
@@ -58,6 +59,48 @@ struct cpufreq_acpi_io {
 
 static struct cpufreq_acpi_io	*acpi_io_data[NR_CPUS];
 
+enum {
+	FFH_NOT_PRESENT,
+	FFH_INTEL_EST,
+};
+
+static int
+acpi_processor_ffh_capability(unsigned int cpu)
+{
+		struct cpuinfo_x86 *c = cpu_data + cpu;
+
+		if (cpu_has(c, X86_FEATURE_EST))
+			return FFH_INTEL_EST;
+		return FFH_NOT_PRESENT;
+}
+
+
+static int
+acpi_processor_write_ffh_est(
+	u32	msr_addr,
+	u8	bit_width,
+	u32	value)
+{
+	msr_addr = MSR_IA32_PERF_CTL;
+	bit_width = 0x10;
+	wrmsr(msr_addr, value & ((1U << bit_width) - 1), 0);
+	return 0;
+}
+
+
+static int
+acpi_processor_write_ffh(
+	u32	hw_addr,
+	u8	bit_width,
+	u32	value)
+{
+	switch(acpi_processor_ffh_capability(smp_processor_id())) {
+	    case FFH_INTEL_EST:
+		return acpi_processor_write_ffh_est(hw_addr, bit_width, value);
+	}
+	return -ENODEV;
+}
+
 
 static int
 acpi_processor_write_port(
@@ -77,6 +120,55 @@ acpi_processor_write_port(
 	return 0;
 }
 
+
+static int
+acpi_processor_write_pstate(
+	u8	space_id,
+	u64	port,
+	u8	bit_width,
+	u32	value)
+{
+	switch(space_id) {
+	    case ACPI_ADR_SPACE_SYSTEM_IO:
+		return acpi_processor_write_port(port, bit_width, value);
+	    case ACPI_ADR_SPACE_FIXED_HARDWARE:
+		return acpi_processor_write_ffh(port, bit_width, value);
+	    default:
+		return -ENODEV;
+	}
+}
+
+
+static int
+acpi_processor_read_ffh_est(
+	u32	msr_addr,
+	u8	bit_width,
+	u32	*ret)
+{
+	u32 unused_hi;
+
+	msr_addr = MSR_IA32_PERF_STATUS;
+	bit_width = 0x10;
+	rdmsr(msr_addr, *ret, unused_hi);
+	*ret = (*ret) & ((1U << bit_width) - 1);
+	return 0;
+}
+
+
+static int
+acpi_processor_read_ffh(
+	u32	hw_addr,
+	u8	bit_width,
+	u32	*ret)
+{
+	switch(acpi_processor_ffh_capability(smp_processor_id())) {
+	    case FFH_INTEL_EST:
+		return acpi_processor_read_ffh_est(hw_addr, bit_width, ret);
+	}
+	return -ENODEV;
+}
+
+
 static int
 acpi_processor_read_port(
 	u16	port,
@@ -96,25 +188,59 @@ acpi_processor_read_port(
 	return 0;
 }
 
+
+static int
+acpi_processor_read_pstate(
+	u8      space_id,
+	u64     port,
+	u8      bit_width,
+	u32     *ret)
+{
+	switch(space_id) {
+		case ACPI_ADR_SPACE_SYSTEM_IO:
+			return acpi_processor_read_port(port, bit_width, ret);
+		case ACPI_ADR_SPACE_FIXED_HARDWARE:
+			return acpi_processor_read_ffh(port, bit_width, ret);
+		default:
+			return -ENODEV;
+	}
+}
+
+
 static int
 acpi_processor_set_performance (
 	struct cpufreq_acpi_io	*data,
 	unsigned int		cpu,
 	int			state)
 {
-	u16			port = 0;
+	u64			port = 0;
+	u8			space_id;
 	u8			bit_width = 0;
 	int			ret = 0;
 	u32			value = 0;
 	int			i = 0;
 	struct cpufreq_freqs    cpufreq_freqs;
+	cpumask_t		saved_mask;
+	int			retval;
 
 	ACPI_FUNCTION_TRACE("acpi_processor_set_performance");
 
+	/*
+	 * TBD: Use something other than set_cpus_allowed.
+	 * As set_cpus_allowed is a bit racy, 
+	 * with any other set_cpus_allowed for this process.
+	 */
+	saved_mask = current->cpus_allowed;
+	set_cpus_allowed(current, cpumask_of_cpu(cpu));
+	if (smp_processor_id() != cpu) {
+		return_VALUE(-EAGAIN);
+	}
+	
 	if (state == data->acpi_data.state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
 			"Already at target state (P%d)\n", state));
-		return_VALUE(0);
+		retval = 0;
+		goto migrate_end;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Transitioning from P%d to P%d\n",
@@ -133,18 +259,20 @@ acpi_processor_set_performance (
 	 * control_register.
 	 */
 
+	space_id = data->acpi_data.control_register.space_id;
 	port = data->acpi_data.control_register.address;
 	bit_width = data->acpi_data.control_register.bit_width;
 	value = (u32) data->acpi_data.states[state].control;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Writing 0x%08x to port 0x%04x\n", value, port));
+		"Writing 0x%08x to port 0x%Lx\n", value, port));
 
-	ret = acpi_processor_write_port(port, bit_width, value);
+	ret = acpi_processor_write_pstate(space_id, port, bit_width, value);
 	if (ret) {
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-			"Invalid port width 0x%04x\n", bit_width));
-		return_VALUE(ret);
+			"Frequency change attempt failed\n"));
+		retval = ret;
+		goto migrate_end;
 	}
 
 	/*
@@ -154,19 +282,21 @@ acpi_processor_set_performance (
 	 * giving up.
 	 */
 
+	space_id = data->acpi_data.control_register.space_id;
 	port = data->acpi_data.status_register.address;
 	bit_width = data->acpi_data.status_register.bit_width;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Looking for 0x%08x from port 0x%04x\n",
+		"Looking for 0x%x from port 0x%Lx\n",
 		(u32) data->acpi_data.states[state].status, port));
 
 	for (i=0; i<100; i++) {
-		ret = acpi_processor_read_port(port, bit_width, &value);
+		ret = acpi_processor_read_pstate(space_id, port, bit_width, &value);
 		if (ret) {	
 			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				"Invalid port width 0x%04x\n", bit_width));
-			return_VALUE(ret);
+				"Frequency status read attempt failed\n"));
+			retval = ret;
+			goto migrate_end;
 		}
 		if (value == (u32) data->acpi_data.states[state].status)
 			break;
@@ -183,7 +313,8 @@ acpi_processor_set_performance (
 		cpufreq_notify_transition(&cpufreq_freqs, CPUFREQ_PRECHANGE);
 		cpufreq_notify_transition(&cpufreq_freqs, CPUFREQ_POSTCHANGE);
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Transition failed\n"));
-		return_VALUE(-ENODEV);
+		retval = -ENODEV;
+		goto migrate_end;
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
@@ -192,7 +323,10 @@ acpi_processor_set_performance (
 
 	data->acpi_data.state = state;
 
-	return_VALUE(0);
+	retval = 0;
+migrate_end:
+	set_cpus_allowed(current, saved_mask);
+	return_VALUE(retval);
 }
 
 
@@ -222,6 +356,66 @@ acpi_cpufreq_target (
 }
 
 
+static void acpi_processor_cpu_init_pdc_est(struct acpi_processor_performance *perf, unsigned int cpu)
+{
+	struct acpi_object_list *obj_list;
+	union acpi_object *obj;
+	u32 *buf;
+	struct cpuinfo_x86 *c = cpu_data + cpu;
+	ACPI_FUNCTION_TRACE("acpi_processor_est_init_pdc");
+
+	if (!cpu_has(c, X86_FEATURE_EST))
+		return_VOID;
+
+	/* allocate and initialize pdc. It will be used later. */
+	obj_list = (struct acpi_object_list *)kmalloc(sizeof(struct acpi_object_list), GFP_KERNEL);
+	if (!obj_list) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "kmalloc for _PDC failed\n"));
+		return_VOID;
+	}
+
+	obj = (union acpi_object *)kmalloc(sizeof(union acpi_object), GFP_KERNEL);
+	if (!obj) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "kmalloc for _PDC failed\n"));
+		kfree(obj_list);
+		return_VOID;
+	}
+
+	buf = (u32 *)kmalloc(12, GFP_KERNEL);
+	if (!buf) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "kmalloc for _PDC failed\n"));
+		kfree(obj);
+		kfree(obj_list);
+		return_VOID;
+	}
+
+	buf[0] = ACPI_PDC_REVISION_ID;
+	buf[1] = 1;
+	/*
+	 * Refer ACPI _PDC support document for bit definitions
+	 */
+	buf[2] = 0xb;
+	obj->type = ACPI_TYPE_BUFFER;
+	obj->buffer.length = 12;
+	obj->buffer.pointer = (u8 *)buf;
+	obj_list->count = 1;
+	obj_list->pointer = obj;
+	perf->pdc = obj_list;
+	return_VOID;
+}
+ 
+
+/* CPU specific PDC initialization */
+static void acpi_processor_cpu_init_pdc(struct acpi_processor_performance *perf, unsigned int cpu)
+{
+	struct cpuinfo_x86 *c = cpu_data + cpu;
+	ACPI_FUNCTION_TRACE("acpi_processor_cpu_init_pdc");
+	if (cpu_has(c, X86_FEATURE_EST))
+		acpi_processor_cpu_init_pdc_est(perf, cpu);
+	return_VOID;
+}
+
+
 static int
 acpi_cpufreq_verify (
 	struct cpufreq_policy   *policy)
@@ -256,6 +450,8 @@ acpi_cpufreq_cpu_init (
 
 	acpi_io_data[cpu] = data;
 
+	acpi_processor_cpu_init_pdc(&data->acpi_data, cpu);
+
 	result = acpi_processor_register_performance(&data->acpi_data, cpu);
 	if (result)
 		goto err_free;
@@ -268,11 +464,15 @@ acpi_cpufreq_cpu_init (
 	}
 	if ((data->acpi_data.control_register.space_id != ACPI_ADR_SPACE_SYSTEM_IO) ||
 	    (data->acpi_data.status_register.space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unsupported address space [%d, %d]\n",
+		if (!((data->acpi_data.control_register.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE) &&
+	    	      (data->acpi_data.status_register.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE)) && 
+		      (acpi_processor_ffh_capability(cpu) != FFH_NOT_PRESENT)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unsupported address space [%d, %d]\n",
 				  (u32) (data->acpi_data.control_register.space_id),
 				  (u32) (data->acpi_data.status_register.space_id)));
-		result = -ENODEV;
-		goto err_unreg;
+			result = -ENODEV;
+			goto err_unreg;
+		}
 	}
 
 	/* alloc freq_table */
diff -urNp linux-2.6.5/arch/i386/kernel/smpboot.c linux-2.6.5.SUSE/arch/i386/kernel/smpboot.c
--- linux-2.6.5/arch/i386/kernel/smpboot.c	2004-04-30 14:59:56.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/kernel/smpboot.c	2004-04-30 15:00:26.000000000 +0200
@@ -76,6 +76,9 @@ static cpumask_t smp_commenced_mask;
 /* Per CPU bogomips and other parameters */
 struct cpuinfo_x86 cpu_data[NR_CPUS] __cacheline_aligned;
 
+u8 x86_cpu_to_apicid[NR_CPUS] =
+			{ [0 ... NR_CPUS-1] = 0xff };
+
 /* Set when the idlers are all forked */
 int smp_threads_ready;
 
@@ -877,6 +880,7 @@ static int __init do_boot_cpu(int apicid
 			inquire_remote_apic(apicid);
 		}
 	}
+	x86_cpu_to_apicid[cpu] = apicid;
 	if (boot_error) {
 		/* Try to put things back the way they were before ... */
 		unmap_cpu_to_logical_apicid(cpu);
@@ -959,6 +963,7 @@ static void __init smp_boot_cpus(unsigne
 
 	boot_cpu_physical_apicid = GET_APIC_ID(apic_read(APIC_ID));
 	boot_cpu_logical_apicid = logical_smp_processor_id();
+	x86_cpu_to_apicid[0] = boot_cpu_physical_apicid;
 
 	current_thread_info()->cpu = 0;
 	smp_tune_scheduling();
diff -urNp linux-2.6.5/arch/ia64/kernel/acpi.c linux-2.6.5.SUSE/arch/ia64/kernel/acpi.c
--- linux-2.6.5/arch/ia64/kernel/acpi.c	2004-04-30 14:59:55.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ia64/kernel/acpi.c	2004-04-30 15:00:26.000000000 +0200
@@ -62,6 +62,10 @@ void (*pm_power_off) (void);
 unsigned char acpi_kbd_controller_present = 1;
 unsigned char acpi_legacy_devices;
 
+#define MAX_SAPICS 256
+u16 ia64_acpiid_to_sapicid[MAX_SAPICS] =
+	{ [0 ... MAX_SAPICS - 1] = -1 };
+
 const char *
 acpi_get_sysname (void)
 {
@@ -199,6 +203,7 @@ acpi_parse_lsapic (acpi_table_entry_head
 		    == (unsigned int) smp_boot_data.cpu_phys_id[available_cpus])
 			printk(" (BSP)");
 #endif
+		ia64_acpiid_to_sapicid[lsapic->acpi_id] = (lsapic->id << 8) | lsapic->eid;
 		++available_cpus;
 	}
 
diff -urNp linux-2.6.5/arch/x86_64/kernel/cpufreq/Kconfig linux-2.6.5.SUSE/arch/x86_64/kernel/cpufreq/Kconfig
--- linux-2.6.5/arch/x86_64/kernel/cpufreq/Kconfig	2004-04-30 14:59:58.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/kernel/cpufreq/Kconfig	2004-04-30 15:00:29.000000000 +0200
@@ -31,6 +31,19 @@ config CPU_FREQ_TABLE
 comment "CPUFreq processor drivers"
        depends on CPU_FREQ
 
+config X86_ACPI_CPUFREQ
+	tristate "ACPI Processor P-States driver"
+	depends on CPU_FREQ_TABLE && ACPI_PROCESSOR
+	help
+	  This driver adds a CPUFreq driver which utilizes the ACPI
+	  Processor Performance States. This can work with variety
+	  of platforms and support both Intel Speedstep and Intel Enhanced 
+	  Speedstep, as long as BIOS-ACPI provides the P-state information.
+
+	  For details, take a look at <file:Documentation/cpu-freq/>.
+
+	  If in doubt, say N.
+
 config X86_POWERNOW_K8
 	tristate "AMD Opteron/Athlon64 PowerNow! using PST"
 	depends on CPU_FREQ_TABLE
diff -urNp linux-2.6.5/arch/x86_64/kernel/cpufreq/Makefile linux-2.6.5.SUSE/arch/x86_64/kernel/cpufreq/Makefile
--- linux-2.6.5/arch/x86_64/kernel/cpufreq/Makefile	2004-04-04 05:36:55.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/kernel/cpufreq/Makefile	2004-04-30 15:00:29.000000000 +0200
@@ -2,6 +2,11 @@
 # Reuse the i386 cpufreq drivers
 #
 
+obj-$(CONFIG_X86_ACPI_CPUFREQ)  += acpi.o
+
+acpi-objs := ../../../i386/kernel/cpu/cpufreq/acpi.o
+
 obj-$(CONFIG_X86_POWERNOW_K8) += powernow-k8.o
 
 powernow-k8-objs := ../../../i386/kernel/cpu/cpufreq/powernow-k8.o
+
diff -urNp linux-2.6.5/arch/x86_64/kernel/smpboot.c linux-2.6.5.SUSE/arch/x86_64/kernel/smpboot.c
--- linux-2.6.5/arch/x86_64/kernel/smpboot.c	2004-04-30 14:59:55.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/kernel/smpboot.c	2004-04-30 15:00:29.000000000 +0200
@@ -813,6 +813,8 @@ static void __init smp_boot_cpus(unsigne
 
 	x86_cpu_to_apicid[0] = boot_cpu_id;
 
+	x86_cpu_to_apicid[0] = boot_cpu_id;
+
 	/*
 	 * Now scan the CPU present map and fire up the other CPUs.
 	 */
diff -urNp linux-2.6.5/drivers/acpi/executer/exconfig.c linux-2.6.5.SUSE/drivers/acpi/executer/exconfig.c
--- linux-2.6.5/drivers/acpi/executer/exconfig.c	2004-04-04 05:37:23.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/acpi/executer/exconfig.c	2004-04-30 15:00:26.000000000 +0200
@@ -48,6 +48,7 @@
 #include <acpi/acnamesp.h>
 #include <acpi/acevents.h>
 #include <acpi/actables.h>
+#include <acpi/acdispat.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -285,7 +286,7 @@ acpi_ex_load_op (
 	union acpi_operand_object       *ddb_handle;
 	union acpi_operand_object       *buffer_desc = NULL;
 	struct acpi_table_header        *table_ptr = NULL;
-	u8                              *table_data_ptr;
+	acpi_physical_address           address;
 	struct acpi_table_header        table_header;
 	u32                             i;
 
@@ -300,12 +301,27 @@ acpi_ex_load_op (
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Load from Region %p %s\n",
 			obj_desc, acpi_ut_get_object_type_name (obj_desc)));
 
-		/* Get the table header */
+		/*
+		 * If the Region Address and Length have not been previously evaluated,
+		 * evaluate them now and save the results.
+		 */
+		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+			status = acpi_ds_get_region_arguments (obj_desc);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+		}
+
+		/* Get the base physical address of the region */
+
+		address = obj_desc->region.address;
+
+		/* Get the table length from the table header */
 
 		table_header.length = 0;
-		for (i = 0; i < sizeof (struct acpi_table_header); i++) {
+		for (i = 0; i < 8; i++) {
 			status = acpi_ev_address_space_dispatch (obj_desc, ACPI_READ,
-					   (acpi_physical_address) i, 8,
+					   (acpi_physical_address) i + address, 8,
 					   ((u8 *) &table_header) + i);
 			if (ACPI_FAILURE (status)) {
 				return_ACPI_STATUS (status);
@@ -319,17 +335,12 @@ acpi_ex_load_op (
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		/* Copy the header to the buffer */
-
-		ACPI_MEMCPY (table_ptr, &table_header, sizeof (struct acpi_table_header));
-		table_data_ptr = ACPI_PTR_ADD (u8, table_ptr, sizeof (struct acpi_table_header));
-
-		/* Get the table from the op region */
+		/* Get the entire table from the op region */
 
 		for (i = 0; i < table_header.length; i++) {
 			status = acpi_ev_address_space_dispatch (obj_desc, ACPI_READ,
-					   (acpi_physical_address) i, 8,
-					   ((u8 *) table_data_ptr + i));
+					   (acpi_physical_address) i + address, 8,
+					   ((u8 *) table_ptr + i));
 			if (ACPI_FAILURE (status)) {
 				goto cleanup;
 			}
diff -urNp linux-2.6.5/drivers/acpi/processor.c linux-2.6.5.SUSE/drivers/acpi/processor.c
--- linux-2.6.5/drivers/acpi/processor.c	2004-04-30 14:59:58.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/acpi/processor.c	2004-04-30 15:00:29.000000000 +0200
@@ -44,6 +44,9 @@
 #include <asm/system.h>
 #include <asm/delay.h>
 #include <asm/uaccess.h>
+#include <asm/processor.h>
+#include <asm/smp.h>
+#include <asm/acpi.h>
 
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
@@ -859,7 +862,6 @@ static void acpi_processor_ppc_exit(void
  * _PCT and _PSS structures are read out and written into struct
  * acpi_processor_performance.
  */
-
 static int acpi_processor_set_pdc (struct acpi_processor *pr)
 {
 	acpi_status             status = AE_OK;
@@ -1047,6 +1049,8 @@ acpi_processor_get_performance_info (
 	if (!pr || !pr->performance || !pr->handle)
 		return_VALUE(-EINVAL);
 
+	acpi_processor_set_pdc(pr);
+
 	status = acpi_get_handle(pr->handle, "_PCT", &handle);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
@@ -1054,8 +1058,6 @@ acpi_processor_get_performance_info (
 		return_VALUE(-ENODEV);
 	}
 
-	acpi_processor_set_pdc(pr);
-
 	result = acpi_processor_get_performance_control(pr);
 	if (result)
 		return_VALUE(result);
@@ -2135,6 +2137,36 @@ acpi_processor_remove_fs (
 	return_VALUE(0);
 }
 
+#ifdef CONFIG_IA64
+#define arch_acpiid_to_apicid 	ia64_acpiid_to_sapicid
+#define arch_cpu_to_apicid 	ia64_cpu_to_sapicid
+#define ARCH_BAD_APICID		(0xffff)
+#else
+#define arch_acpiid_to_apicid 	x86_acpiid_to_apicid
+#define arch_cpu_to_apicid 	x86_cpu_to_apicid
+#define ARCH_BAD_APICID		(0xff)
+#endif
+
+/* Use the acpiid in MADT to map cpus in case of SMP */
+#ifndef CONFIG_SMP
+#define convert_acpiid_to_cpu(acpi_id) (0)
+#else
+static u8 convert_acpiid_to_cpu(u8 acpi_id)
+{
+	u16 apic_id;
+	int i;
+	
+	apic_id = arch_acpiid_to_apicid[acpi_id];
+	if (apic_id == ARCH_BAD_APICID)
+		return -1;
+
+	for (i = 0; i < NR_CPUS; i++) {
+		if (arch_cpu_to_apicid[i] == apic_id)
+			return i;
+	}
+	return -1;
+}
+#endif
 
 /* --------------------------------------------------------------------------
                                  Driver Interface
@@ -2147,7 +2179,8 @@ acpi_processor_get_info (
 	acpi_status		status = 0;
 	union acpi_object	object = {0};
 	struct acpi_buffer	buffer = {sizeof(union acpi_object), &object};
-	static int		cpu_index = 0;
+	u8			cpu_index;
+	static int		cpu0_initialized;
 
 	ACPI_FUNCTION_TRACE("acpi_processor_get_info");
 
@@ -2157,13 +2190,6 @@ acpi_processor_get_info (
 	if (num_online_cpus() > 1)
 		errata.smp = TRUE;
 
-	/*
-	 *  Extra Processor objects may be enumerated on MP systems with
-	 *  less than the max # of CPUs. They should be ignored.
-	 */
-	if ((cpu_index + 1) > num_online_cpus())
-		return_VALUE(-ENODEV);
-
 	acpi_processor_errata(pr);
 
 	/*
@@ -2195,9 +2221,29 @@ acpi_processor_get_info (
 	 * TBD: Synch processor ID (via LAPIC/LSAPIC structures) on SMP.
 	 *	>>> 'acpi_get_processor_id(acpi_id, &id)' in arch/xxx/acpi.c
 	 */
-	pr->id = cpu_index++;
 	pr->acpi_id = object.processor.proc_id;
 
+	cpu_index = convert_acpiid_to_cpu(pr->acpi_id);
+
+	/* Handle UP system running SMP kernel, that has no LAPIC in MADT */
+	if ( !cpu0_initialized && (cpu_index > num_online_cpus())) {
+		cpu_index = 0;
+	}
+	cpu0_initialized = 1;
+
+	/*
+	 *  Extra Processor objects may be enumerated on MP systems with
+	 *  less than the max # of CPUs. They should be ignored.
+	 */
+	if (cpu_index > num_online_cpus()) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error getting cpuindex for acpiid 0x%x\n",
+			pr->acpi_id));
+		return_VALUE(-ENODEV);
+	}
+
+	pr->id = cpu_index;
+
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d:%d]\n", pr->id, 
 		pr->acpi_id));
 
diff -urNp linux-2.6.5/drivers/cpufreq/Kconfig linux-2.6.5.SUSE/drivers/cpufreq/Kconfig
--- linux-2.6.5/drivers/cpufreq/Kconfig	2004-04-04 05:38:14.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/cpufreq/Kconfig	2004-04-30 15:00:29.000000000 +0200
@@ -69,6 +69,21 @@ config CPU_FREQ_GOV_USERSPACE
 
 	  If in doubt, say Y.
 
+config CPU_FREQ_GOV_ONDEMAND
+	tristate "'ondemand' cpufreq policy governor"
+	depends on CPU_FREQ
+	help
+	  'ondemand' - This driver adds a dynamic cpufreq policy governor.
+	  The governor does a periodic polling and 
+	  changes frequency based on the CPU utilization.
+	  The support for this governor depends on CPU capability to
+	  do fast frequency switching (i.e, very low latency frequency
+	  transitions). 
+
+	  For details, take a look at linux/Documentation/cpu-freq.
+
+	  If in doubt, say N.
+
 config CPU_FREQ_24_API
 	bool "/proc/sys/cpu/ interface (2.4. / OLD)"
 	depends on CPU_FREQ && SYSCTL && CPU_FREQ_GOV_USERSPACE
diff -urNp linux-2.6.5/drivers/cpufreq/Makefile linux-2.6.5.SUSE/drivers/cpufreq/Makefile
--- linux-2.6.5/drivers/cpufreq/Makefile	2004-04-04 05:38:27.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/cpufreq/Makefile	2004-04-30 15:00:29.000000000 +0200
@@ -5,6 +5,7 @@ obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o
 obj-$(CONFIG_CPU_FREQ_GOV_PERFORMANCE)	+= cpufreq_performance.o
 obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
+obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
diff -urNp linux-2.6.5/drivers/cpufreq/cpufreq_ondemand.c linux-2.6.5.SUSE/drivers/cpufreq/cpufreq_ondemand.c
--- linux-2.6.5/drivers/cpufreq/cpufreq_ondemand.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/cpufreq/cpufreq_ondemand.c	2004-04-30 15:00:29.000000000 +0200
@@ -0,0 +1,424 @@
+/*
+ *  drivers/cpufreq/cpufreq_ondemand.c
+ *
+ *  Copyright (C)  2001 Russell King
+ *            (C)  2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
+ *                      Jun Nakajima <jun.nakajima@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ctype.h>
+#include <linux/cpufreq.h>
+#include <linux/sysctl.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/sysfs.h>
+#include <linux/sched.h>
+#include <linux/kmod.h>
+#include <linux/workqueue.h>
+#include <linux/jiffies.h>
+#include <linux/config.h>
+#include <linux/kernel_stat.h>
+#include <linux/percpu.h>
+
+/*
+ * dbs is used in this file as a shortform for demandbased switching
+ * It helps to keep variable names smaller, simpler
+ */
+
+#define DEF_FREQUENCY_UP_THRESHOLD		(80)
+#define MIN_FREQUENCY_UP_THRESHOLD		(0)
+#define MAX_FREQUENCY_UP_THRESHOLD		(100)
+
+#define DEF_FREQUENCY_DOWN_THRESHOLD		(20)
+#define MIN_FREQUENCY_DOWN_THRESHOLD		(0)
+#define MAX_FREQUENCY_DOWN_THRESHOLD		(100)
+
+/* 
+ * The polling frequency of this governor depends on the capability of 
+ * the processor. Default polling frequency is 1000 times the transition
+ * latency of the processor. The governor will work on any processor with 
+ * transition latency <= 10mS, using appropriate sampling 
+ * rate.
+ * For CPUs with transition latency > 10mS (mostly drivers with CPUFREQ_ETERNAL)
+ * this governor will not work.
+ * All times here are in uS.
+ */
+static unsigned int 				def_sampling_rate;
+#define MIN_SAMPLING_RATE			(def_sampling_rate / 2)
+#define MAX_SAMPLING_RATE			(500 * def_sampling_rate)
+#define DEF_SAMPLING_RATE_LATENCY_MULTIPLIER	(1000)
+#define DEF_SAMPLING_DOWN_FACTOR		(10)
+#define TRANSITION_LATENCY_LIMIT		(10 * 1000)
+#define sampling_rate_in_HZ(x)			((x * HZ) / (1000 * 1000))
+
+static void do_dbs_timer(void *data);
+
+struct cpu_dbs_info_s {
+	struct cpufreq_policy 	*cur_policy;
+	unsigned int 		prev_cpu_idle_up;
+	unsigned int 		prev_cpu_idle_down;
+	unsigned int 		enable;
+};
+static DEFINE_PER_CPU(struct cpu_dbs_info_s, cpu_dbs_info);
+
+static unsigned int dbs_enable;	/* number of CPUs using this policy */
+
+static DECLARE_MUTEX 	(dbs_sem);
+static DECLARE_WORK	(dbs_work, do_dbs_timer, NULL);
+
+struct dbs_tuners {
+	unsigned int 		sampling_rate;
+	unsigned int		sampling_down_factor;
+	unsigned int		up_threshold;
+	unsigned int		down_threshold;
+};
+
+struct dbs_tuners dbs_tuners_ins = {
+	.up_threshold 		= DEF_FREQUENCY_UP_THRESHOLD,
+	.down_threshold 	= DEF_FREQUENCY_DOWN_THRESHOLD,
+	.sampling_down_factor 	= DEF_SAMPLING_DOWN_FACTOR,
+};
+
+/************************** sysfs interface ************************/
+static ssize_t show_current_freq(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf (buf, "%u\n", policy->cur);
+}
+
+static ssize_t show_sampling_rate_max(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf (buf, "%u\n", MAX_SAMPLING_RATE);
+}
+
+static ssize_t show_sampling_rate_min(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf (buf, "%u\n", MIN_SAMPLING_RATE);
+}
+
+#define define_one_ro(_name) 					\
+static struct freq_attr _name = { 				\
+	.attr = { .name = __stringify(_name), .mode = 0444 }, 	\
+	.show = show_##_name, 					\
+}
+
+define_one_ro(current_freq);
+define_one_ro(sampling_rate_max);
+define_one_ro(sampling_rate_min);
+
+/* cpufreq_ondemand Governor Tunables */
+#define show_one(file_name, object)					\
+static ssize_t show_##file_name						\
+(struct cpufreq_policy *unused, char *buf)				\
+{									\
+	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
+}
+show_one(sampling_rate, sampling_rate);
+show_one(sampling_down_factor, sampling_down_factor);
+show_one(up_threshold, up_threshold);
+show_one(down_threshold, down_threshold);
+
+static ssize_t store_sampling_down_factor(struct cpufreq_policy *unused, 
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+	down(&dbs_sem);
+	if (ret != 1 )
+		goto out;
+
+	dbs_tuners_ins.sampling_down_factor = input;
+out:
+	up(&dbs_sem);
+	return count;
+}
+
+static ssize_t store_sampling_rate(struct cpufreq_policy *unused, 
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+	down(&dbs_sem);
+	if (ret != 1 || input > MAX_SAMPLING_RATE || input < MIN_SAMPLING_RATE)
+		goto out;
+
+	dbs_tuners_ins.sampling_rate = input;
+out:
+	up(&dbs_sem);
+	return count;
+}
+
+static ssize_t store_up_threshold(struct cpufreq_policy *unused, 
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+	down(&dbs_sem);
+	if (ret != 1 || input > MAX_FREQUENCY_UP_THRESHOLD || 
+			input < MIN_FREQUENCY_UP_THRESHOLD ||
+			input <= dbs_tuners_ins.down_threshold)
+		goto out;
+
+	dbs_tuners_ins.up_threshold = input;
+out:
+	up(&dbs_sem);
+	return count;
+}
+
+static ssize_t store_down_threshold(struct cpufreq_policy *unused, 
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+	down(&dbs_sem);
+	if (ret != 1 || input > MAX_FREQUENCY_DOWN_THRESHOLD || 
+			input < MIN_FREQUENCY_DOWN_THRESHOLD ||
+			input >= dbs_tuners_ins.up_threshold)
+		goto out;
+
+	dbs_tuners_ins.down_threshold = input;
+out:
+	up(&dbs_sem);
+	return count;
+}
+
+#define define_one_rw(_name) 					\
+static struct freq_attr _name = { 				\
+	.attr = { .name = __stringify(_name), .mode = 0644 }, 	\
+	.show = show_##_name, 					\
+	.store = store_##_name, 				\
+}
+
+define_one_rw(sampling_rate);
+define_one_rw(sampling_down_factor);
+define_one_rw(up_threshold);
+define_one_rw(down_threshold);
+
+static struct attribute * dbs_attributes[] = {
+	&current_freq.attr,
+	&sampling_rate_max.attr,
+	&sampling_rate_min.attr,
+	&sampling_rate.attr,
+	&sampling_down_factor.attr,
+	&up_threshold.attr,
+	&down_threshold.attr,
+	NULL
+};
+
+static struct attribute_group dbs_attr_group = {
+	.attrs = dbs_attributes,
+	.name = "ondemand",
+};
+
+/************************** sysfs end ************************/
+
+static void dbs_check_cpu(int cpu)
+{
+	unsigned int idle_ticks, up_idle_ticks, down_idle_ticks;
+	unsigned int freq_down_step;
+	unsigned int freq_down_sampling_rate;
+	static int down_skip[NR_CPUS];
+	struct cpu_dbs_info_s *this_dbs_info;
+
+	this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
+	if (!this_dbs_info->enable)
+		return;
+
+	/* 
+	 * The default safe range is 20% to 80% 
+	 * Every sampling_rate, we check
+	 * 	- If current idle time is less than 20%, then we try to 
+	 * 	  increase frequency
+	 * Every sampling_rate*sampling_down_factor, we check
+	 * 	- If current idle time is more than 80%, then we try to
+	 * 	  decrease frequency
+	 *
+	 * Any frequency increase takes it to the maximum frequency. 
+	 * Frequency reduction happens at minimum steps of 
+	 * 5% of max_frequency 
+	 */
+	/* Check for frequency increase */
+	idle_ticks = kstat_cpu(cpu).cpustat.idle - 
+		this_dbs_info->prev_cpu_idle_up;
+	this_dbs_info->prev_cpu_idle_up = kstat_cpu(cpu).cpustat.idle;
+
+	up_idle_ticks = (100 - dbs_tuners_ins.up_threshold) *
+			sampling_rate_in_HZ(dbs_tuners_ins.sampling_rate) / 100;
+
+	if (idle_ticks < up_idle_ticks) {
+		__cpufreq_driver_target(this_dbs_info->cur_policy,
+			this_dbs_info->cur_policy->max, 
+			CPUFREQ_RELATION_H);
+		down_skip[cpu] = 0;
+		this_dbs_info->prev_cpu_idle_down = kstat_cpu(cpu).cpustat.idle;
+		return;
+	}
+
+	/* Check for frequency decrease */
+	down_skip[cpu]++;
+	if (down_skip[cpu] < dbs_tuners_ins.sampling_down_factor)
+		return;
+
+	idle_ticks = kstat_cpu(cpu).cpustat.idle - 
+		this_dbs_info->prev_cpu_idle_down;
+	down_skip[cpu] = 0;
+	this_dbs_info->prev_cpu_idle_down = kstat_cpu(cpu).cpustat.idle;
+
+	freq_down_sampling_rate = dbs_tuners_ins.sampling_rate *
+		dbs_tuners_ins.sampling_down_factor;
+	down_idle_ticks = (100 - dbs_tuners_ins.down_threshold) *
+			sampling_rate_in_HZ(freq_down_sampling_rate) / 100;
+
+	if (idle_ticks > down_idle_ticks ) {
+		freq_down_step = (5 * this_dbs_info->cur_policy->max) / 100;
+		__cpufreq_driver_target(this_dbs_info->cur_policy,
+			this_dbs_info->cur_policy->cur - freq_down_step, 
+			CPUFREQ_RELATION_H);
+		return;
+	}
+}
+
+static void do_dbs_timer(void *data)
+{ 
+	int i;
+	down(&dbs_sem);
+	for (i = 0; i < NR_CPUS; i++)
+		if (cpu_online(i))
+			dbs_check_cpu(i);
+	schedule_delayed_work(&dbs_work, 
+			sampling_rate_in_HZ(dbs_tuners_ins.sampling_rate));
+	up(&dbs_sem);
+} 
+
+static inline void dbs_timer_init(void)
+{
+	INIT_WORK(&dbs_work, do_dbs_timer, NULL);
+	schedule_work(&dbs_work);
+	return;
+}
+
+static inline void dbs_timer_exit(void)
+{
+	cancel_delayed_work(&dbs_work);
+	return;
+}
+
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+				   unsigned int event)
+{
+	unsigned int cpu = policy->cpu;
+	struct cpu_dbs_info_s *this_dbs_info;
+
+	this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if ((!cpu_online(cpu)) || 
+		    (!policy->cur))
+			return -EINVAL;
+
+		if (policy->cpuinfo.transition_latency >
+				(TRANSITION_LATENCY_LIMIT * 1000))
+			return -EINVAL;
+		if (this_dbs_info->enable) /* Already enabled */
+			break;
+		 
+		down(&dbs_sem);
+		this_dbs_info->cur_policy = policy;
+		
+		this_dbs_info->prev_cpu_idle_up = 
+				kstat_cpu(cpu).cpustat.idle;
+		this_dbs_info->prev_cpu_idle_down = 
+				kstat_cpu(cpu).cpustat.idle;
+		this_dbs_info->enable = 1;
+		sysfs_create_group(&policy->kobj, &dbs_attr_group);
+		dbs_enable++;
+		/*
+		 * Start the timerschedule work, when this governor
+		 * is used for first time
+		 */
+		if (dbs_enable == 1) {
+			/* policy latency is in nS. Convert it to uS first */
+			def_sampling_rate = (policy->cpuinfo.transition_latency / 1000) *
+					DEF_SAMPLING_RATE_LATENCY_MULTIPLIER;
+			dbs_tuners_ins.sampling_rate = def_sampling_rate;
+
+			dbs_timer_init();
+		}
+		
+		up(&dbs_sem);
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		down(&dbs_sem);
+		this_dbs_info->enable = 0;
+		sysfs_remove_group(&policy->kobj, &dbs_attr_group);
+		dbs_enable--;
+		/*
+		 * Stop the timerschedule work, when this governor
+		 * is used for first time
+		 */
+		if (dbs_enable == 0) 
+			dbs_timer_exit();
+		
+		up(&dbs_sem);
+
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+		down(&dbs_sem);
+		if (policy->max < this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(
+					this_dbs_info->cur_policy,
+				       	policy->max, CPUFREQ_RELATION_H);
+		else if (policy->min > this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(
+					this_dbs_info->cur_policy,
+				       	policy->min, CPUFREQ_RELATION_L);
+		up(&dbs_sem);
+		break;
+	}
+	return 0;
+}
+
+struct cpufreq_governor cpufreq_gov_dbs = {
+	.name		= "ondemand",
+	.governor	= cpufreq_governor_dbs,
+	.owner		= THIS_MODULE,
+};
+EXPORT_SYMBOL(cpufreq_gov_dbs);
+
+static int __init cpufreq_gov_dbs_init(void)
+{
+	return cpufreq_register_governor(&cpufreq_gov_dbs);
+}
+
+static void __exit cpufreq_gov_dbs_exit(void)
+{
+	/* Make sure that the scheduled work is indeed not running */
+	flush_scheduled_work();
+
+	cpufreq_unregister_governor(&cpufreq_gov_dbs);
+}
+
+
+MODULE_AUTHOR ("Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>");
+MODULE_DESCRIPTION ("'cpufreq_ondemand' - A dynamic cpufreq governor for "
+		"Low Latency Frequency Transition capable processors");
+MODULE_LICENSE ("GPL");
+
+module_init(cpufreq_gov_dbs_init);
+module_exit(cpufreq_gov_dbs_exit);
diff -urNp linux-2.6.5/include/asm-i386/acpi.h linux-2.6.5.SUSE/include/asm-i386/acpi.h
--- linux-2.6.5/include/asm-i386/acpi.h	2004-04-04 05:38:13.000000000 +0200
+++ linux-2.6.5.SUSE/include/asm-i386/acpi.h	2004-04-30 15:00:26.000000000 +0200
@@ -163,6 +163,8 @@ extern void acpi_reserve_bootmem(void);
 
 #endif /*CONFIG_ACPI_SLEEP*/
 
+extern u8 x86_acpiid_to_apicid[];
+
 #endif /*__KERNEL__*/
 
 #endif /*_ASM_ACPI_H*/
diff -urNp linux-2.6.5/include/asm-i386/smp.h linux-2.6.5.SUSE/include/asm-i386/smp.h
--- linux-2.6.5/include/asm-i386/smp.h	2004-04-30 15:00:01.000000000 +0200
+++ linux-2.6.5.SUSE/include/asm-i386/smp.h	2004-04-30 15:00:26.000000000 +0200
@@ -44,6 +44,7 @@ extern void (*mtrr_hook) (void);
 extern void zap_low_mappings (void);
 
 #define MAX_APICID 256
+extern u8 x86_cpu_to_apicid[];
 
 /*
  * This function is needed by all SMP systems. It must _always_ be valid
diff -urNp linux-2.6.5/include/asm-ia64/acpi.h linux-2.6.5.SUSE/include/asm-ia64/acpi.h
--- linux-2.6.5/include/asm-ia64/acpi.h	2004-04-04 05:38:13.000000000 +0200
+++ linux-2.6.5.SUSE/include/asm-ia64/acpi.h	2004-04-30 15:00:26.000000000 +0200
@@ -105,6 +105,8 @@ extern int __initdata pxm_to_nid_map[MAX
 extern int __initdata nid_to_pxm_map[MAX_NUMNODES];
 #endif
 
+extern u16 ia64_acpiid_to_sapicid[];
+
 #endif /*__KERNEL__*/
 
 #endif /*_ASM_ACPI_H*/
diff -urNp linux-2.6.5/include/asm-x86_64/acpi.h linux-2.6.5.SUSE/include/asm-x86_64/acpi.h
--- linux-2.6.5/include/asm-x86_64/acpi.h	2004-04-04 05:37:36.000000000 +0200
+++ linux-2.6.5.SUSE/include/asm-x86_64/acpi.h	2004-04-30 15:00:26.000000000 +0200
@@ -149,6 +149,8 @@ extern int acpi_disabled;
 #define BROKEN_ACPI_Sx		0x0001
 #define BROKEN_INIT_AFTER_S1	0x0002
 
+extern u8 x86_acpiid_to_apicid[];
+
 #endif /*__KERNEL__*/
 
 #endif /*_ASM_ACPI_H*/
