From: Takashi Iwai <tiwai@suse.de>
Subject: Fix possible MIDI deadlocks
Patch-mainline: not yet
References: 

Fixed the possible MIDI deadlocks.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/core/rawmidi.c linux/sound/core/rawmidi.c
--- linux-2.6.11/sound/core/rawmidi.c	2005-03-08 17:49:41.000000000 +0100
+++ linux/sound/core/rawmidi.c	2005-03-08 16:11:54.000000000 +0100
@@ -85,11 +85,22 @@ static inline int snd_rawmidi_ready_appe
 	       (!substream->append || runtime->avail >= count);
 }
 
-static int snd_rawmidi_init(snd_rawmidi_substream_t *substream)
+static void snd_rawmidi_event_tasklet(unsigned long data)
 {
-	snd_rawmidi_runtime_t *runtime = substream->runtime;
+	snd_rawmidi_substream_t *substream = (snd_rawmidi_substream_t *)data;
+	substream->runtime->event(substream);
+}
+
+static int snd_rawmidi_runtime_create(snd_rawmidi_substream_t * substream)
+{
+	snd_rawmidi_runtime_t *runtime;
+
+	if ((runtime = kcalloc(1, sizeof(*runtime), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
 	spin_lock_init(&runtime->lock);
 	init_waitqueue_head(&runtime->sleep);
+	tasklet_init(&runtime->event_tasklet, snd_rawmidi_event_tasklet,
+		     (unsigned long)substream);
 	runtime->event = NULL;
 	runtime->buffer_size = PAGE_SIZE;
 	runtime->avail_min = 1;
@@ -97,27 +108,37 @@ static int snd_rawmidi_init(snd_rawmidi_
 		runtime->avail = 0;
 	else
 		runtime->avail = runtime->buffer_size;
-	if ((runtime->buffer = kmalloc(runtime->buffer_size, GFP_KERNEL)) == NULL)
+	if ((runtime->buffer = kmalloc(runtime->buffer_size, GFP_KERNEL)) == NULL) {
+		kfree(runtime);
 		return -ENOMEM;
+	}
 	runtime->appl_ptr = runtime->hw_ptr = 0;
+	substream->runtime = runtime;
 	return 0;
 }
 
-static int snd_rawmidi_done_buffer(snd_rawmidi_runtime_t *runtime)
+static int snd_rawmidi_runtime_free(snd_rawmidi_substream_t * substream)
 {
-	if (runtime->buffer) {
-		kfree(runtime->buffer);
-		runtime->buffer = NULL;
-	}
+	snd_rawmidi_runtime_t *runtime = substream->runtime;
+
+	kfree(runtime->buffer);
+	kfree(runtime);
+	substream->runtime = NULL;
 	return 0;
 }
 
+static void snd_rawmidi_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	substream->ops->trigger(substream, up);
+	if (!up && substream->runtime->event)
+		tasklet_kill(&substream->runtime->event_tasklet);
+}
+
 int snd_rawmidi_drop_output(snd_rawmidi_substream_t * substream)
 {
 	snd_rawmidi_runtime_t *runtime = substream->runtime;
 
-	substream->ops->trigger(substream, 0);
-	runtime->trigger = 0;
+	snd_rawmidi_trigger(substream, 0);
 	runtime->drain = 0;
 	/* interrupts are not enabled at this moment,
 	   so spinlock is not required */
@@ -159,8 +180,7 @@ int snd_rawmidi_drain_input(snd_rawmidi_
 {
 	snd_rawmidi_runtime_t *runtime = substream->runtime;
 
-	substream->ops->trigger(substream, 0);
-	runtime->trigger = 0;
+	snd_rawmidi_trigger(substream, 0);
 	runtime->drain = 0;
 	/* interrupts aren't enabled at this moment, so spinlock isn't needed */
 	runtime->appl_ptr = runtime->hw_ptr = 0;
@@ -173,7 +193,7 @@ int snd_rawmidi_kernel_open(int cardnum,
 {
 	snd_rawmidi_t *rmidi;
 	struct list_head *list1, *list2;
-	snd_rawmidi_substream_t *sinput, *soutput;
+	snd_rawmidi_substream_t *sinput = NULL, *soutput = NULL;
 	snd_rawmidi_runtime_t *input = NULL, *output = NULL;
 	int err;
 
@@ -264,20 +284,11 @@ int snd_rawmidi_kernel_open(int cardnum,
 		list2 = list2->next;
 	}
 	if (mode & SNDRV_RAWMIDI_LFLG_INPUT) {
-		input = kcalloc(1, sizeof(*input), GFP_KERNEL);
-		if (input == NULL) {
-			err = -ENOMEM;
+		if ((err = snd_rawmidi_runtime_create(sinput)) < 0)
 			goto __error;
-		}
-		sinput->runtime = input;
-		if (snd_rawmidi_init(sinput) < 0) {
-			err = -ENOMEM;
+		input = sinput->runtime;
+		if ((err = sinput->ops->open(sinput)) < 0)
 			goto __error;
-		}
-		if ((err = sinput->ops->open(sinput)) < 0) {
-			sinput->runtime = NULL;
-			goto __error;
-		}
 		sinput->opened = 1;
 		rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substream_opened++;
 	} else {
@@ -286,26 +297,15 @@ int snd_rawmidi_kernel_open(int cardnum,
 	if (mode & SNDRV_RAWMIDI_LFLG_OUTPUT) {
 		if (soutput->opened)
 			goto __skip_output;
-		output = kcalloc(1, sizeof(*output), GFP_KERNEL);
-		if (output == NULL) {
-			err = -ENOMEM;
-			goto __error;
-		}
-		soutput->runtime = output;
-		if (snd_rawmidi_init(soutput) < 0) {
-			if (mode & SNDRV_RAWMIDI_LFLG_INPUT) {
+		if ((err = snd_rawmidi_runtime_create(soutput)) < 0) {
+			if (mode & SNDRV_RAWMIDI_LFLG_INPUT)
 				sinput->ops->close(sinput);
-				sinput->runtime = NULL;
-			}
-			err = -ENOMEM;
 			goto __error;
 		}
+		output = soutput->runtime;
 		if ((err = soutput->ops->open(soutput)) < 0) {
-			if (mode & SNDRV_RAWMIDI_LFLG_INPUT) {
+			if (mode & SNDRV_RAWMIDI_LFLG_INPUT)
 				sinput->ops->close(sinput);
-				sinput->runtime = NULL;
-			}
-			soutput->runtime = NULL;
 			goto __error;
 		}
 	      __skip_output:
@@ -328,14 +328,10 @@ int snd_rawmidi_kernel_open(int cardnum,
 	return 0;
 
       __error:
-	if (input != NULL) {
-		snd_rawmidi_done_buffer(input);
-		kfree(input);
-	}
-	if (output != NULL) {
-		snd_rawmidi_done_buffer(output);
-		kfree(output);
-	}
+	if (input != NULL)
+		snd_rawmidi_runtime_free(sinput);
+	if (output != NULL)
+		snd_rawmidi_runtime_free(soutput);
 	module_put(rmidi->card->module);
 	if (!(mode & SNDRV_RAWMIDI_LFLG_NOOPENLOCK))
 		up(&rmidi->open_mutex);
@@ -462,14 +458,11 @@ int snd_rawmidi_kernel_release(snd_rawmi
 		substream = rfile->input;
 		rfile->input = NULL;
 		runtime = substream->runtime;
-		runtime->trigger = 0;
-		substream->ops->trigger(substream, 0);
+		snd_rawmidi_trigger(substream, 0);
 		substream->ops->close(substream);
-		snd_rawmidi_done_buffer(runtime);
 		if (runtime->private_free != NULL)
 			runtime->private_free(substream);
-		kfree(runtime);
-		substream->runtime = NULL;
+		snd_rawmidi_runtime_free(substream);
 		substream->opened = 0;
 		rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substream_opened--;
 	}
@@ -484,13 +477,11 @@ int snd_rawmidi_kernel_release(snd_rawmi
 				snd_rawmidi_kernel_write(substream, &buf, 1);
 			}
 			if (snd_rawmidi_drain_output(substream) == -ERESTARTSYS)
-				substream->ops->trigger(substream, 0);
+				snd_rawmidi_trigger(substream, 0);
 			substream->ops->close(substream);
-			snd_rawmidi_done_buffer(runtime);
 			if (runtime->private_free != NULL)
 				runtime->private_free(substream);
-			kfree(runtime);
-			substream->runtime = NULL;
+			snd_rawmidi_runtime_free(substream);
 			substream->opened = 0;
 			substream->append = 0;
 		}
@@ -872,7 +863,7 @@ int snd_rawmidi_receive(snd_rawmidi_subs
 			count1 = count;
 			if (count1 > (int)(runtime->buffer_size - runtime->avail)) {
 				count1 = runtime->buffer_size - runtime->avail;
-				runtime->xruns = count - count1;
+				runtime->xruns += count - count1;
 			}
 			if (count1 > 0) {
 				memcpy(runtime->buffer, buffer, count1);
@@ -882,13 +873,13 @@ int snd_rawmidi_receive(snd_rawmidi_subs
 			}
 		}
 	}
-	if (result > 0 && runtime->event == NULL) {
-		if (snd_rawmidi_ready(substream))
+	if (result > 0) {
+		if (runtime->event)
+			tasklet_hi_schedule(&runtime->event_tasklet);
+		else if (snd_rawmidi_ready(substream))
 			wake_up(&runtime->sleep);
 	}
 	spin_unlock_irqrestore(&runtime->lock, flags);
-	if (result > 0 && runtime->event)
-		runtime->event(substream);
 	return result;
 }
 
@@ -928,8 +919,7 @@ static long snd_rawmidi_kernel_read1(snd
 
 long snd_rawmidi_kernel_read(snd_rawmidi_substream_t *substream, unsigned char *buf, long count)
 {
-	substream->runtime->trigger = 1;
-	substream->ops->trigger(substream, 1);
+	snd_rawmidi_trigger(substream, 1);
 	return snd_rawmidi_kernel_read1(substream, buf, count, 1);
 }
 
@@ -946,8 +936,7 @@ static ssize_t snd_rawmidi_read(struct f
 	if (substream == NULL)
 		return -EIO;
 	runtime = substream->runtime;
-	runtime->trigger = 1;
-	substream->ops->trigger(substream, 1);
+	snd_rawmidi_trigger(substream, 1);
 	result = 0;
 	while (count > 0) {
 		spin_lock_irq(&runtime->lock);
@@ -998,8 +987,6 @@ int snd_rawmidi_transmit_empty(snd_rawmi
 	}
 	spin_lock_irqsave(&runtime->lock, flags);
 	result = runtime->avail >= runtime->buffer_size;
-	if (result)
-		runtime->trigger = 1;
 	spin_unlock_irqrestore(&runtime->lock, flags);
 	return result;		
 }
@@ -1032,7 +1019,6 @@ int snd_rawmidi_transmit_peek(snd_rawmid
 	spin_lock_irqsave(&runtime->lock, flags);
 	if (runtime->avail >= runtime->buffer_size) {
 		/* warning: lowlevel layer MUST trigger down the hardware */
-		runtime->trigger = 0;
 		goto __skip;
 	}
 	if (count == 1) {	/* special case, faster code */
@@ -1047,8 +1033,12 @@ int snd_rawmidi_transmit_peek(snd_rawmid
 		memcpy(buffer, runtime->buffer + runtime->hw_ptr, count1);
 		count -= count1;
 		result += count1;
-		if (count > 0)
+		if (count > 0) {
+			if (count > (int)(runtime->buffer_size - runtime->avail - count1))
+				count = runtime->buffer_size - runtime->avail - count1;
 			memcpy(buffer + count1, runtime->buffer, count);
+			result += count;
+		}
 	}
       __skip:
 	spin_unlock_irqrestore(&runtime->lock, flags);
@@ -1081,15 +1071,14 @@ int snd_rawmidi_transmit_ack(snd_rawmidi
 	runtime->hw_ptr %= runtime->buffer_size;
 	runtime->avail += count;
 	substream->bytes += count;
-	if (runtime->drain)
-		wake_up(&runtime->sleep);
-	else
-		if (count > 0 && runtime->event == NULL)
-			if (snd_rawmidi_ready(substream))
-				wake_up(&runtime->sleep);
+	if (count > 0) {
+		if (runtime->drain ||
+		    (runtime->event == NULL && snd_rawmidi_ready(substream)))
+			wake_up(&runtime->sleep);
+		if (runtime->event)
+			tasklet_hi_schedule(&runtime->event_tasklet);
+	}
 	spin_unlock_irqrestore(&runtime->lock, flags);
-	if (count > 0 && runtime->event)
-		runtime->event(substream);
 	return count;
 }
 
@@ -1154,12 +1143,10 @@ static long snd_rawmidi_kernel_write1(sn
 		count -= count1;
 	}
       __end:
-	if (result > 0)
-		runtime->trigger = 1;
 	count1 = runtime->avail < runtime->buffer_size;
 	spin_unlock_irqrestore(&runtime->lock, flags);
 	if (count1)
-		substream->ops->trigger(substream, 1);
+		snd_rawmidi_trigger(substream, 1);
 	return result;
 }
 
@@ -1244,8 +1231,7 @@ static unsigned int snd_rawmidi_poll(str
 	rfile = file->private_data;
 	if (rfile->input != NULL) {
 		runtime = rfile->input->runtime;
-		runtime->trigger = 1;
-		rfile->input->ops->trigger(rfile->input, 1);
+		snd_rawmidi_trigger(rfile->input, 1);
 		poll_wait(file, &runtime->sleep, wait);
 	}
 	if (rfile->output != NULL) {
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/drivers/mpu401/mpu401_uart.c linux/sound/drivers/mpu401/mpu401_uart.c
--- linux-2.6.11/sound/drivers/mpu401/mpu401_uart.c	2005-03-02 08:38:04.000000000 +0100
+++ linux/sound/drivers/mpu401/mpu401_uart.c	2005-03-08 16:11:54.000000000 +0100
@@ -92,24 +92,21 @@ static void snd_mpu401_uart_clear_rx(mpu
 
 static void _snd_mpu401_uart_interrupt(mpu401_t *mpu)
 {
-	spin_lock(&mpu->input_lock);
+	unsigned long flags;
+
+	spin_lock_irqsave(&mpu->input_lock, flags);
 	if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
-		atomic_dec(&mpu->rx_loop);
 		snd_mpu401_uart_input_read(mpu);
-		atomic_inc(&mpu->rx_loop);
 	} else {
 		snd_mpu401_uart_clear_rx(mpu);
 	}
-	spin_unlock(&mpu->input_lock);
+	spin_unlock_irqrestore(&mpu->input_lock, flags);
  	/* ok. for better Tx performance try do some output when input is done */
 	if (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode) &&
 	    test_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode)) {
-		if (spin_trylock(&mpu->output_lock)) {
-			atomic_dec(&mpu->tx_loop);
-			snd_mpu401_uart_output_write(mpu);
-			atomic_inc(&mpu->tx_loop);
-			spin_unlock(&mpu->output_lock);
-		}
+		spin_lock_irqsave(&mpu->output_lock, flags);
+		snd_mpu401_uart_output_write(mpu);
+		spin_unlock_irqrestore(&mpu->output_lock, flags);
 	}
 }
 
@@ -137,13 +134,14 @@ irqreturn_t snd_mpu401_uart_interrupt(in
  */
 static void snd_mpu401_uart_timer(unsigned long data)
 {
+	unsigned long flags;
 	mpu401_t *mpu = (mpu401_t *)data;
 
-	spin_lock(&mpu->timer_lock);
+	spin_lock_irqsave(&mpu->timer_lock, flags);
 	/*mpu->mode |= MPU401_MODE_TIMER;*/
 	mpu->timer.expires = 1 + jiffies;
 	add_timer(&mpu->timer);
-	spin_unlock(&mpu->timer_lock);
+	spin_unlock_irqrestore(&mpu->timer_lock, flags);
 	if (mpu->rmidi)
 		_snd_mpu401_uart_interrupt(mpu);
 }
@@ -243,7 +241,6 @@ static int snd_mpu401_uart_input_open(sn
 		snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1);
 	}
 	mpu->substream_input = substream;
-	atomic_set(&mpu->rx_loop, 1);
 	set_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);
 	return 0;
 }
@@ -261,7 +258,6 @@ static int snd_mpu401_uart_output_open(s
 		snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1);
 	}
 	mpu->substream_output = substream;
-	atomic_set(&mpu->tx_loop, 1);
 	set_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);
 	return 0;
 }
@@ -314,16 +310,9 @@ static void snd_mpu401_uart_input_trigge
 		}
 		
 		/* read data in advance */
-		/* prevent double enter via rawmidi->event callback */
-		if (atomic_dec_and_test(&mpu->rx_loop)) {
-			local_irq_save(flags);
-			if (spin_trylock(&mpu->input_lock)) {
-				snd_mpu401_uart_input_read(mpu);
-				spin_unlock(&mpu->input_lock);
-			}
-			local_irq_restore(flags);
-		}
-		atomic_inc(&mpu->rx_loop);
+		spin_lock_irqsave(&mpu->input_lock, flags);
+		snd_mpu401_uart_input_read(mpu);
+		spin_unlock_irqrestore(&mpu->input_lock, flags);
 	} else {
 		if (mpu->irq < 0)
 			snd_mpu401_uart_remove_timer(mpu, 1);
@@ -405,16 +394,9 @@ static void snd_mpu401_uart_output_trigg
 		snd_mpu401_uart_add_timer(mpu, 0);
 
 		/* output pending data */
-		/* prevent double enter via rawmidi->event callback */
-		if (atomic_dec_and_test(&mpu->tx_loop)) {
-			local_irq_save(flags);
-			if (spin_trylock(&mpu->output_lock)) {
-				snd_mpu401_uart_output_write(mpu);
-				spin_unlock(&mpu->output_lock);
-			}
-			local_irq_restore(flags);
-		}
-		atomic_inc(&mpu->tx_loop);
+		spin_lock_irqsave(&mpu->output_lock, flags);
+		snd_mpu401_uart_output_write(mpu);
+		spin_unlock_irqrestore(&mpu->output_lock, flags);
 	} else {
 		snd_mpu401_uart_remove_timer(mpu, 0);
 		clear_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/drivers/mtpav.c linux/sound/drivers/mtpav.c
--- linux-2.6.11/sound/drivers/mtpav.c	2005-03-02 08:38:19.000000000 +0100
+++ linux/sound/drivers/mtpav.c	2005-03-08 16:11:54.000000000 +0100
@@ -413,10 +413,11 @@ static void snd_mtpav_input_trigger(snd_
 
 static void snd_mtpav_output_timer(unsigned long data)
 {
+	unsigned long flags;
 	mtpav_t *chip = (mtpav_t *)data;
 	int p;
 
-	spin_lock(&chip->spinlock);
+	spin_lock_irqsave(&chip->spinlock, flags);
 	/* reprogram timer */
 	chip->timer.expires = 1 + jiffies;
 	add_timer(&chip->timer);
@@ -426,7 +427,7 @@ static void snd_mtpav_output_timer(unsig
 		if ((portp->mode & MTPAV_MODE_OUTPUT_TRIGGERED) && portp->output)
 			snd_mtpav_output_port_write(portp, portp->output);
 	}
-	spin_unlock(&chip->spinlock);
+	spin_unlock_irqrestore(&chip->spinlock, flags);
 }
 
 /* spinlock held! */
@@ -514,9 +515,7 @@ static void snd_mtpav_inmidi_process(mtp
 
 	portp = &mcrd->ports[mcrd->inmidiport];
 	if (portp->mode & MTPAV_MODE_INPUT_TRIGGERED) {
-		spin_unlock(&mcrd->spinlock);
 		snd_rawmidi_receive(portp->input, &inbyte, 1);
-		spin_lock(&mcrd->spinlock);
 	}
 }
 
@@ -581,12 +580,13 @@ static void snd_mtpav_read_bytes(mtpav_t
 
 static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id, struct pt_regs *regs)
 {
+	unsigned long flags;
 	mtpav_t *mcard = dev_id;
 
 	//printk("irqh()\n");
-	spin_lock(&mcard->spinlock);
+	spin_lock_irqsave(&mcard->spinlock, flags);
 	snd_mtpav_read_bytes(mcard);
-	spin_unlock(&mcard->spinlock);
+	spin_unlock_irqrestore(&mcard->spinlock, flags);
 	return IRQ_HANDLED;
 }
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/drivers/serial-u16550.c linux/sound/drivers/serial-u16550.c
--- linux-2.6.11/sound/drivers/serial-u16550.c	2005-03-08 17:49:42.000000000 +0100
+++ linux/sound/drivers/serial-u16550.c	2005-03-08 16:11:54.000000000 +0100
@@ -292,30 +292,32 @@ static void snd_uart16550_io_loop(snd_ua
  */
 static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
+	unsigned long flags;
 	snd_uart16550_t *uart;
 
 	uart = (snd_uart16550_t *) dev_id;
-	spin_lock(&uart->open_lock);
+	spin_lock_irqsave(&uart->open_lock, flags);
 	if (uart->filemode == SERIAL_MODE_NOT_OPENED) {
-		spin_unlock(&uart->open_lock);
+		spin_unlock_irqrestore(&uart->open_lock, flags);
 		return IRQ_NONE;
 	}
 	inb(uart->base + UART_IIR);		/* indicate to the UART that the interrupt has been serviced */
 	snd_uart16550_io_loop(uart);
-	spin_unlock(&uart->open_lock);
+	spin_unlock_irqrestore(&uart->open_lock, flags);
 	return IRQ_HANDLED;
 }
 
 /* When the polling mode, this function calls snd_uart16550_io_loop. */
 static void snd_uart16550_buffer_timer(unsigned long data)
 {
+	unsigned long flags;
 	snd_uart16550_t *uart;
 
 	uart = (snd_uart16550_t *)data;
-	spin_lock(&uart->open_lock);
+	spin_lock_irqsave(&uart->open_lock, flags);
 	snd_uart16550_del_timer(uart);
 	snd_uart16550_io_loop(uart);
-	spin_unlock(&uart->open_lock);
+	spin_unlock_irqrestore(&uart->open_lock, flags);
 }
 
 /*
@@ -840,6 +842,16 @@ static int __init snd_uart16550_create(s
 	return 0;
 }
 
+static void __init snd_uart16550_substreams(snd_rawmidi_str_t *stream)
+{
+	struct list_head *list;
+
+	list_for_each(list, &stream->substreams) {
+		snd_rawmidi_substream_t *substream = list_entry(list, snd_rawmidi_substream_t, list);
+		sprintf(substream->name, "Serial MIDI %d", substream->number + 1);
+	}
+}
+
 static int __init snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int outs, int ins, snd_rawmidi_t **rmidi)
 {
 	snd_rawmidi_t *rrawmidi;
@@ -849,7 +861,9 @@ static int __init snd_uart16550_rmidi(sn
 		return err;
 	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_uart16550_input);
 	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_uart16550_output);
-	sprintf(rrawmidi->name, "uart16550 MIDI #%d", device);
+	strcpy(rrawmidi->name, "Serial MIDI");
+	snd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);
+	snd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);
 	rrawmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
 			       SNDRV_RAWMIDI_INFO_INPUT |
 			       SNDRV_RAWMIDI_INFO_DUPLEX;
@@ -906,7 +920,7 @@ static int __init snd_serial_probe(int d
 		return -ENOMEM;
 
 	strcpy(card->driver, "Serial");
-	strcpy(card->shortname, "Serial midi (uart16550A)");
+	strcpy(card->shortname, "Serial MIDI (UART16550A)");
 
 	if ((err = snd_uart16550_create(card,
 					port[dev],
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/sb/sb8_midi.c linux/sound/isa/sb/sb8_midi.c
--- linux-2.6.11/sound/isa/sb/sb8_midi.c	2005-03-02 08:37:47.000000000 +0100
+++ linux/sound/isa/sb/sb8_midi.c	2005-03-08 16:11:57.000000000 +0100
@@ -46,20 +46,16 @@ irqreturn_t snd_sb8dsp_midi_interrupt(sb
 		inb(SBP(chip, DATA_AVAIL));	/* ack interrupt */
 		return IRQ_NONE;
 	}
+	spin_lock(&chip->midi_input_lock);
 	while (max-- > 0) {
-		spin_lock(&chip->midi_input_lock);
 		if (inb(SBP(chip, DATA_AVAIL)) & 0x80) {
 			byte = inb(SBP(chip, READ));
 			if (chip->open & SB_OPEN_MIDI_INPUT_TRIGGER) {
-				spin_unlock(&chip->midi_input_lock);
 				snd_rawmidi_receive(chip->midi_substream_input, &byte, 1);
-			} else {
-				spin_unlock(&chip->midi_input_lock);
 			}
-		} else {
-			spin_unlock(&chip->midi_input_lock);
 		}
 	}
+	spin_unlock(&chip->midi_input_lock);
 	return IRQ_HANDLED;
 }
 
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/isa/wavefront/wavefront_midi.c linux/sound/isa/wavefront/wavefront_midi.c
--- linux-2.6.11/sound/isa/wavefront/wavefront_midi.c	2005-03-02 08:38:26.000000000 +0100
+++ linux/sound/isa/wavefront/wavefront_midi.c	2005-03-08 16:11:57.000000000 +0100
@@ -413,8 +413,8 @@ snd_wavefront_midi_interrupt (snd_wavefr
 		return;
 	}
 
+	spin_lock_irqsave (&midi->virtual, flags);
 	while (--max) {
-		spin_lock_irqsave (&midi->virtual, flags);
 
 		if (input_avail (midi)) {
 			byte = read_data (midi);
@@ -433,21 +433,17 @@ snd_wavefront_midi_interrupt (snd_wavefr
 			}
 
 			if (substream == NULL) {
-				spin_unlock_irqrestore (&midi->virtual, flags);
 				continue;
 			}
 
 			if (midi->mode[mpu] & MPU401_MODE_INPUT_TRIGGER) {
-				spin_unlock_irqrestore (&midi->virtual, flags);
 				snd_rawmidi_receive(substream, &byte, 1);
-			} else {
-				spin_unlock_irqrestore (&midi->virtual, flags);
 			}
 		} else {
-			spin_unlock_irqrestore (&midi->virtual, flags);
 			break;
 		}
 	} 
+	spin_unlock_irqrestore (&midi->virtual, flags);
 
 	snd_wavefront_midi_output_write(card);
 }
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/cs4281.c linux/sound/pci/cs4281.c
--- linux-2.6.11/sound/pci/cs4281.c	2005-03-08 17:49:43.000000000 +0100
+++ linux/sound/pci/cs4281.c	2005-03-08 16:11:58.000000000 +0100
@@ -1848,6 +1848,7 @@ static int __devinit snd_cs4281_midi(cs4
 static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	cs4281_t *chip = dev_id;
+	unsigned long flags;
 	unsigned int status, dma, val;
 	cs4281_dma_t *cdma;
 
@@ -1863,7 +1864,7 @@ static irqreturn_t snd_cs4281_interrupt(
 		for (dma = 0; dma < 4; dma++)
 			if (status & BA0_HISR_DMA(dma)) {
 				cdma = &chip->dma[dma];
-				spin_lock(&chip->reg_lock);
+				spin_lock_irqsave(&chip->reg_lock, flags);
 				/* ack DMA IRQ */
 				val = snd_cs4281_peekBA0(chip, cdma->regHDSR);
 				/* workaround, sometimes CS4281 acknowledges */
@@ -1872,16 +1873,16 @@ static irqreturn_t snd_cs4281_interrupt(
 				if ((val & BA0_HDSR_DHTC) && !(cdma->frag & 1)) {
 					cdma->frag--;
 					chip->spurious_dhtc_irq++;
-					spin_unlock(&chip->reg_lock);
+					spin_unlock_irqrestore(&chip->reg_lock, flags);
 					continue;
 				}
 				if ((val & BA0_HDSR_DTC) && (cdma->frag & 1)) {
 					cdma->frag--;
 					chip->spurious_dtc_irq++;
-					spin_unlock(&chip->reg_lock);
+					spin_unlock_irqrestore(&chip->reg_lock, flags);
 					continue;
 				}
-				spin_unlock(&chip->reg_lock);
+				spin_unlock_irqrestore(&chip->reg_lock, flags);
 				snd_pcm_period_elapsed(cdma->substream);
 			}
 	}
@@ -1889,14 +1890,12 @@ static irqreturn_t snd_cs4281_interrupt(
 	if ((status & BA0_HISR_MIDI) && chip->rmidi) {
 		unsigned char c;
 		
-		spin_lock(&chip->reg_lock);
+		spin_lock_irqsave(&chip->reg_lock, flags);
 		while ((snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_RBE) == 0) {
 			c = snd_cs4281_peekBA0(chip, BA0_MIDRP);
 			if ((chip->midcr & BA0_MIDCR_RIE) == 0)
 				continue;
-			spin_unlock(&chip->reg_lock);
 			snd_rawmidi_receive(chip->midi_input, &c, 1);
-			spin_lock(&chip->reg_lock);
 		}
 		while ((snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_TBF) == 0) {
 			if ((chip->midcr & BA0_MIDCR_TIE) == 0)
@@ -1908,7 +1907,7 @@ static irqreturn_t snd_cs4281_interrupt(
 			}
 			snd_cs4281_pokeBA0(chip, BA0_MIDWP, c);
 		}
-		spin_unlock(&chip->reg_lock);
+		spin_unlock_irqrestore(&chip->reg_lock, flags);
 	}
 
 	/* EOI to the PCI part... reenables interrupts */
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/cs46xx/cs46xx_lib.c linux/sound/pci/cs46xx/cs46xx_lib.c
--- linux-2.6.11/sound/pci/cs46xx/cs46xx_lib.c	2005-03-08 17:49:43.000000000 +0100
+++ linux/sound/pci/cs46xx/cs46xx_lib.c	2005-03-08 16:12:00.000000000 +0100
@@ -1149,6 +1153,7 @@ static int snd_cs46xx_capture_prepare(sn
 
 static irqreturn_t snd_cs46xx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
+	unsigned long flags;
 	cs46xx_t *chip = dev_id;
 	u32 status1;
 #ifdef CONFIG_SND_CS46XX_NEW_DSP
@@ -1212,14 +1217,12 @@ static irqreturn_t snd_cs46xx_interrupt(
 	if ((status1 & HISR_MIDI) && chip->rmidi) {
 		unsigned char c;
 		
-		spin_lock(&chip->reg_lock);
+		spin_lock_irqsave(&chip->reg_lock, flags);
 		while ((snd_cs46xx_peekBA0(chip, BA0_MIDSR) & MIDSR_RBE) == 0) {
 			c = snd_cs46xx_peekBA0(chip, BA0_MIDRP);
 			if ((chip->midcr & MIDCR_RIE) == 0)
 				continue;
-			spin_unlock(&chip->reg_lock);
 			snd_rawmidi_receive(chip->midi_input, &c, 1);
-			spin_lock(&chip->reg_lock);
 		}
 		while ((snd_cs46xx_peekBA0(chip, BA0_MIDSR) & MIDSR_TBF) == 0) {
 			if ((chip->midcr & MIDCR_TIE) == 0)
@@ -1231,7 +1234,7 @@ static irqreturn_t snd_cs46xx_interrupt(
 			}
 			snd_cs46xx_pokeBA0(chip, BA0_MIDWP, c);
 		}
-		spin_unlock(&chip->reg_lock);
+		spin_unlock_irqrestore(&chip->reg_lock, flags);
 	}
 	/*
 	 *  EOI to the PCI part....reenables interrupts
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/emu10k1/emu10k1x.c linux/sound/pci/emu10k1/emu10k1x.c
--- linux-2.6.11/sound/pci/emu10k1/emu10k1x.c	2005-03-02 08:38:09.000000000 +0100
+++ linux/sound/pci/emu10k1/emu10k1x.c	2005-03-08 16:12:00.000000000 +0100
@@ -1265,6 +1265,7 @@ static void mpu401_clear_rx(emu10k1x_t *
 
 static void do_emu10k1x_midi_interrupt(emu10k1x_t *emu, emu10k1x_midi_t *midi, unsigned int status)
 {
+	unsigned long flags;
 	unsigned char byte;
 
 	if (midi->rmidi == NULL) {
@@ -1278,15 +1279,13 @@ static void do_emu10k1x_midi_interrupt(e
 			mpu401_clear_rx(emu, midi);
 		} else {
 			byte = mpu401_read_data(emu, midi);
-			spin_unlock(&midi->input_lock);
 			if (midi->substream_input)
 				snd_rawmidi_receive(midi->substream_input, &byte, 1);
-			spin_lock(&midi->input_lock);
 		}
 	}
 	spin_unlock(&midi->input_lock);
 
-	spin_lock(&midi->output_lock);
+	spin_lock_irqsave(&midi->output_lock, flags);
 	if ((status & midi->ipr_tx) && mpu401_output_ready(emu, midi)) {
 		if (midi->substream_output &&
 		    snd_rawmidi_transmit(midi->substream_output, &byte, 1) == 1) {
@@ -1295,7 +1294,7 @@ static void do_emu10k1x_midi_interrupt(e
 			snd_emu10k1x_intr_disable(emu, midi->tx_enable);
 		}
 	}
-	spin_unlock(&midi->output_lock);
+	spin_unlock_irqrestore(&midi->output_lock, flags);
 }
 
 static void snd_emu10k1x_midi_interrupt(emu10k1x_t *emu, unsigned int status)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/emu10k1/emumpu401.c linux/sound/pci/emu10k1/emumpu401.c
--- linux-2.6.11/sound/pci/emu10k1/emumpu401.c	2005-03-02 08:37:48.000000000 +0100
+++ linux/sound/pci/emu10k1/emumpu401.c	2005-03-08 16:12:00.000000000 +0100
@@ -73,6 +73,7 @@ static void mpu401_clear_rx(emu10k1_t *e
 
 static void do_emu10k1_midi_interrupt(emu10k1_t *emu, emu10k1_midi_t *midi, unsigned int status)
 {
+	unsigned long flags;
 	unsigned char byte;
 
 	if (midi->rmidi == NULL) {
@@ -86,15 +87,13 @@ static void do_emu10k1_midi_interrupt(em
 			mpu401_clear_rx(emu, midi);
 		} else {
 			byte = mpu401_read_data(emu, midi);
-			spin_unlock(&midi->input_lock);
 			if (midi->substream_input)
 				snd_rawmidi_receive(midi->substream_input, &byte, 1);
-			spin_lock(&midi->input_lock);
 		}
 	}
 	spin_unlock(&midi->input_lock);
 
-	spin_lock(&midi->output_lock);
+	spin_lock_irqsave(&midi->output_lock, flags);
 	if ((status & midi->ipr_tx) && mpu401_output_ready(emu, midi)) {
 		if (midi->substream_output &&
 		    snd_rawmidi_transmit(midi->substream_output, &byte, 1) == 1) {
@@ -103,7 +102,7 @@ static void do_emu10k1_midi_interrupt(em
 			snd_emu10k1_intr_disable(emu, midi->tx_enable);
 		}
 	}
-	spin_unlock(&midi->output_lock);
+	spin_unlock_irqrestore(&midi->output_lock, flags);
 }
 
 static void snd_emu10k1_midi_interrupt(emu10k1_t *emu, unsigned int status)
diff -rupN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/sound/pci/ens1370.c linux/sound/pci/ens1370.c
--- linux-2.6.11/sound/pci/ens1370.c	2005-03-08 17:49:43.000000000 +0100
+++ linux/sound/pci/ens1370.c	2005-03-08 16:11:58.000000000 +0100
@@ -2083,27 +2035,26 @@ static int __devinit snd_ensoniq_create(
 
 static void snd_ensoniq_midi_interrupt(ensoniq_t * ensoniq)
 {
+	unsigned long flags;
 	snd_rawmidi_t * rmidi = ensoniq->rmidi;
 	unsigned char status, mask, byte;
 
 	if (rmidi == NULL)
 		return;
 	/* do Rx at first */
-	spin_lock(&ensoniq->reg_lock);
+	spin_lock_irqsave(&ensoniq->reg_lock, flags);
 	mask = ensoniq->uartm & ES_MODE_INPUT ? ES_RXRDY : 0;
 	while (mask) {
 		status = inb(ES_REG(ensoniq, UART_STATUS));
 		if ((status & mask) == 0)
 			break;
 		byte = inb(ES_REG(ensoniq, UART_DATA));
-		spin_unlock(&ensoniq->reg_lock);
 		snd_rawmidi_receive(ensoniq->midi_input, &byte, 1);
-		spin_lock(&ensoniq->reg_lock);
 	}
-	spin_unlock(&ensoniq->reg_lock);
+	spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 
 	/* do Tx at second */
-	spin_lock(&ensoniq->reg_lock);
+	spin_lock_irqsave(&ensoniq->reg_lock, flags);
 	mask = ensoniq->uartm & ES_MODE_OUTPUT ? ES_TXRDY : 0;
 	while (mask) {
 		status = inb(ES_REG(ensoniq, UART_STATUS));
@@ -2117,7 +2068,7 @@ static void snd_ensoniq_midi_interrupt(e
 			outb(byte, ES_REG(ensoniq, UART_DATA));
 		}
 	}
-	spin_unlock(&ensoniq->reg_lock);
+	spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 }
 
 static int snd_ensoniq_midi_input_open(snd_rawmidi_substream_t * substream)
@@ -2284,6 +2235,7 @@ static int __devinit snd_ensoniq_midi(en
 
 static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
+	unsigned long flags;
 	ensoniq_t *ensoniq = dev_id;
 	unsigned int status, sctrl;
 
@@ -2294,7 +2246,7 @@ static irqreturn_t snd_audiopci_interrup
 	if (!(status & ES_INTR))
 		return IRQ_NONE;
 
-	spin_lock(&ensoniq->reg_lock);
+	spin_lock_irqsave(&ensoniq->reg_lock, flags);
 	sctrl = ensoniq->sctrl;
 	if (status & ES_DAC1)
 		sctrl &= ~ES_P1_INT_EN;
@@ -2304,7 +2256,7 @@ static irqreturn_t snd_audiopci_interrup
 		sctrl &= ~ES_R1_INT_EN;
 	outl(sctrl, ES_REG(ensoniq, SERIAL));
 	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
-	spin_unlock(&ensoniq->reg_lock);
+	spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 
 	if (status & ES_UART)
 		snd_ensoniq_midi_interrupt(ensoniq);
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/mpu401.h linux/include/sound/mpu401.h
--- linux-2.6.11/include/sound/mpu401.h	2005-03-02 08:38:25.000000000 +0100
+++ linux/include/sound/mpu401.h	2005-03-08 16:11:56.000000000 +0100
@@ -86,9 +86,6 @@
 	spinlock_t output_lock;
 	spinlock_t timer_lock;
 	
-	atomic_t rx_loop;
-	atomic_t tx_loop;
-
 	struct timer_list timer;
 
 	void (*write) (mpu401_t * mpu, unsigned char data, unsigned long addr);
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/include/sound/rawmidi.h linux/include/sound/rawmidi.h
--- linux-2.6.11/include/sound/rawmidi.h	2005-03-02 08:38:19.000000000 +0100
+++ linux/include/sound/rawmidi.h	2005-03-08 16:11:56.000000000 +0100
@@ -23,6 +23,7 @@
  */
 
 #include <sound/asound.h>
+#include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 #include <asm/semaphore.h>
@@ -65,8 +66,7 @@
 } snd_rawmidi_global_ops_t;
 
 struct _snd_rawmidi_runtime {
-	unsigned int trigger: 1, /* transfer is running */
-		     drain: 1,	/* drain stage */
+	unsigned int drain: 1,	/* drain stage */
 		     oss: 1;	/* OSS compatible mode */
 	/* midi stream buffer */
 	unsigned char *buffer;	/* buffer for MIDI data */
@@ -80,6 +80,7 @@
 	spinlock_t lock;
 	wait_queue_head_t sleep;
 	/* event handler (room [output] or new bytes [input]) */
+	struct tasklet_struct event_tasklet;
 	void (*event)(snd_rawmidi_substream_t *substream);
 	/* private data */
 	void *private_data;
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl linux/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl
--- linux-2.6.11/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl	2005-03-08 17:49:42.000000000 +0100
+++ linux/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl	2005-03-07 15:22:19.000000000 +0100
@@ -18,8 +18,8 @@
       </affiliation>
      </author>
 
-     <date>July 11, 2004</date>
-     <edition>0.3.3</edition>
+     <date>March 6, 2005</date>
+     <edition>0.3.4</edition>
 
     <abstract>
       <para>
@@ -4203,18 +4203,6 @@
       implementation of mpu401 stuff. For example, emu10k1 has its own
       mpu401 routines. 
       </para>
-
-      <para>
-        In this document, I won't explain the rawmidi interface API,
-      which is the basis of MPU401-UART implementation. 
-      </para>
-
-      <para>
-        For details, please check the source,
-      <filename>core/rawmidi.c</filename>, and examples such as
-      <filename>drivers/mpu401/mpu401_uart.c</filename> or
-      <filename>usb/usbmidi.c</filename>. 
-      </para>
     </section>
 
     <section id="midi-interface-constructor">
@@ -4338,6 +4326,356 @@
 
 
 <!-- ****************************************************** -->
+<!-- RawMIDI Interface  -->
+<!-- ****************************************************** -->
+  <chapter id="rawmidi-interface">
+    <title>RawMIDI Interface</title>
+
+    <section id="rawmidi-interface-overview">
+      <title>Overview</title>
+
+      <para>
+      The raw MIDI interface is used for hardware MIDI ports that can
+      be accessed as a byte stream.  It is not used for synthesizer
+      chips that do not directly understand MIDI.
+      </para>
+
+      <para>
+      ALSA handles file and buffer management.  All you have to do is
+      to write some code to move data between the buffer and the
+      hardware.
+      </para>
+
+      <para>
+      The rawmidi API is defined in
+      <filename>&lt;sound/rawmidi.h&gt;</filename>.
+      </para>
+    </section>
+
+    <section id="rawmidi-interface-constructor">
+      <title>Constructor</title>
+
+      <para>
+      To create a rawmidi device, call the
+      <function>snd_rawmidi_new</function> function:
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  snd_rawmidi_t *rmidi;
+  err = snd_rawmidi_new(chip->card, "MyMIDI", 0, outs, ins, &rmidi);
+  if (err < 0)
+          return err;
+  rmidi->private_data = chip;
+  strcpy(rmidi->name, "My MIDI");
+  rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+                      SNDRV_RAWMIDI_INFO_INPUT |
+                      SNDRV_RAWMIDI_INFO_DUPLEX;
+]]>
+          </programlisting>
+        </informalexample>
+      </para>
+
+      <para>
+      The first argument is the card pointer, the second argument is
+      the ID string.
+      </para>
+
+      <para>
+      The third argument is the index of this component.  You can
+      create up to 8 rawmidi devices.
+      </para>
+
+      <para>
+      The fourth and fifth arguments are the number of output and
+      input substreams, respectively, of this device.  (A substream is
+      the equivalent of a MIDI port.)
+      </para>
+
+      <para>
+      Set the <structfield>info_flags</structfield> field to specify
+      the capabilities of the device.
+      Set <constant>SNDRV_RAWMIDI_INFO_OUTPUT</constant> if there is
+      at least one output port,
+      <constant>SNDRV_RAWMIDI_INFO_INPUT</constant> if there is at
+      least one input port,
+      and <constant>SNDRV_RAWMIDI_INFO_DUPLEX</constant> if the device
+      can handle output and input at the same time.
+      </para>
+
+      <para>
+      After the rawmidi device is created, you need to set the
+      operators (callbacks) for each substream.  There are helper
+      functions to set the operators for all substream of a device:
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_mymidi_output_ops);
+  snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_mymidi_input_ops);
+]]>
+          </programlisting>
+        </informalexample>
+      </para>
+
+      <para>
+      The operators are usually defined like this:
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  static snd_rawmidi_ops_t snd_mymidi_output_ops = {
+          .open =    snd_mymidi_output_open,
+          .close =   snd_mymidi_output_close,
+          .trigger = snd_mymidi_output_trigger,
+  };
+]]>
+          </programlisting>
+        </informalexample>
+      These callbacks are explained in the <link
+      linkend="rawmidi-interface-callbacks"><citetitle>Callbacks</citetitle></link>
+      section.
+      </para>
+
+      <para>
+      If there is more than one substream, you should give each one a
+      unique name:
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  struct list_head *list;
+  snd_rawmidi_substream_t *substream;
+  list_for_each(list, &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {
+          substream = list_entry(list, snd_rawmidi_substream_t, list);
+          sprintf(substream->name, "My MIDI Port %d", substream->number + 1);
+  }
+  /* same for SNDRV_RAWMIDI_STREAM_INPUT */
+]]>
+          </programlisting>
+        </informalexample>
+      </para>
+    </section>
+
+    <section id="rawmidi-interface-callbacks">
+      <title>Callbacks</title>
+
+      <para>
+      In all callbacks, the private data that you've set for the
+      rawmidi device can be accessed as
+      substream-&gt;rmidi-&gt;private_data.
+      <!-- <code> isn't available before DocBook 4.3 -->
+      </para>
+
+      <para>
+      If there is more than one port, your callbacks can determine the
+      port index from the snd_rawmidi_substream_t data passed to each
+      callback:
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  snd_rawmidi_substream_t *substream;
+  int index = substream->number;
+]]>
+          </programlisting>
+        </informalexample>
+      </para>
+
+      <section id="rawmidi-interface-op-open">
+      <title><function>open</function> callback</title>
+
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  static int snd_xxx_open(snd_rawmidi_substream_t *substream);
+]]>
+          </programlisting>
+        </informalexample>
+
+        <para>
+        This is called when a substream is opened.
+        You can initialize the hardware here, but you should not yet
+        start transmitting/receiving data.
+        </para>
+      </section>
+
+      <section id="rawmidi-interface-op-close">
+      <title><function>close</function> callback</title>
+
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  static int snd_xxx_close(snd_rawmidi_substream_t *substream);
+]]>
+          </programlisting>
+        </informalexample>
+
+        <para>
+        Guess what.
+        </para>
+
+        <para>
+        The <function>open</function> and <function>close</function>
+        callbacks of a rawmidi device are serialized with a mutex,
+        and can sleep.
+        </para>
+      </section>
+
+      <section id="rawmidi-interface-op-trigger-out">
+      <title><function>trigger</function> callback for output
+      substreams</title>
+
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  static void snd_xxx_output_trigger(snd_rawmidi_substream_t *substream, int up);
+]]>
+          </programlisting>
+        </informalexample>
+
+        <para>
+        This is called with a nonzero <parameter>up</parameter>
+        parameter when there is some data in the substream buffer that
+        must be transmitted.
+        </para>
+
+        <para>
+        To read data from the buffer, call
+        <function>snd_rawmidi_transmit_peek</function>.  It will
+        return the number of bytes that have been read; this will be
+        less than the number of bytes requested when there is no more
+        data in the buffer.
+        After the data has been transmitted successfully, call
+        <function>snd_rawmidi_transmit_ack</function> to remove the
+        data from the substream buffer:
+          <informalexample>
+            <programlisting>
+<![CDATA[
+  unsigned char data;
+  while (snd_rawmidi_transmit_peek(substream, &data, 1) == 1) {
+          if (mychip_try_to_transmit(data))
+                  snd_rawmidi_transmit_ack(substream, 1);
+          else
+                  break; /* hardware FIFO full */
+  }
+]]>
+            </programlisting>
+          </informalexample>
+        </para>
+
+        <para>
+        If you know beforehand that the hardware will accept data, you
+        can use the <function>snd_rawmidi_transmit</function> function
+        which reads some data and removes it from the buffer at once:
+          <informalexample>
+            <programlisting>
+<![CDATA[
+  while (mychip_transmit_possible()) {
+          unsigned char data;
+          if (snd_rawmidi_transmit(substream, &data, 1) != 1)
+                  break; /* no more data */
+          mychip_transmit(data);
+  }
+]]>
+            </programlisting>
+          </informalexample>
+        </para>
+
+        <para>
+        If you know beforehand how many bytes you can accept, you can
+        use a buffer size greater than one with the
+        <function>snd_rawmidi_transmit*</function> functions.
+        </para>
+
+        <para>
+        The <function>trigger</function> callback must not sleep.  If
+        the hardware FIFO is full before the substream buffer has been
+        emptied, you have to continue transmitting data later, either
+        in an interrupt handler, or with a timer if the hardware
+        doesn't have a MIDI transmit interrupt.
+        </para>
+
+        <para>
+        The <function>trigger</function> callback is called with a
+        zero <parameter>up</parameter> parameter when the transmission
+        of data should be aborted.
+        </para>
+
+        <para>
+        The <function>trigger</function> callback may be called from
+        another hardware interrupt handler.  This means that all
+        spinlocks taken in the <function>trigger</function> callback
+        must be taken with <function>spin_lock_irqsave</function>
+        everywhere.
+        </para>
+      </section>
+
+      <section id="rawmidi-interface-op-trigger-in">
+      <title><function>trigger</function> callback for input
+      substreams</title>
+
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  static void snd_xxx_input_trigger(snd_rawmidi_substream_t *substream, int up);
+]]>
+          </programlisting>
+        </informalexample>
+
+        <para>
+        This is called with a nonzero <parameter>up</parameter>
+        parameter to enable receiving data, or with a zero
+        <parameter>up</parameter> parameter do disable receiving data.
+        </para>
+
+        <para>
+        When data reception is enabled, your interrupt handler should
+        call <function>snd_rawmidi_receive</function> for all received
+        data:
+          <informalexample>
+            <programlisting>
+<![CDATA[
+  void snd_mychip_midi_interrupt(...)
+  {
+          while (mychip_midi_available()) {
+                  unsigned char data;
+                  data = mychip_midi_read();
+                  snd_rawmidi_receive(substream, &data, 1);
+          }
+  }
+]]>
+            </programlisting>
+          </informalexample>
+        </para>
+      </section>
+
+      <section id="rawmidi-interface-op-drain">
+      <title><function>drain</function> callback</title>
+
+        <informalexample>
+          <programlisting>
+<![CDATA[
+  static void snd_xxx_drain(snd_rawmidi_substream_t *substream);
+]]>
+          </programlisting>
+        </informalexample>
+
+        <para>
+        This is only used with output substreams.  This function should wait
+        until all data read from the substream buffer has been transmitted.
+        This ensures that the device can be closed and the driver unloaded
+        without losing data.
+        </para>
+
+        <para>
+        This callback is optional.  If you do not set
+        <structfield>drain</structfield> in the snd_rawmidi_ops_t
+        structure, ALSA will simply wait for 50&nbsp;milliseconds
+        instead.
+        </para>
+      </section>
+    </section>
+
+  </chapter>
+
+
+<!-- ****************************************************** -->
 <!-- Miscellaneous Devices  -->
 <!-- ****************************************************** -->
   <chapter id="misc-devices">
diff -ruN --exclude-from=/home/iwai/alsa-kernel-excludes linux-2.6.11/Documentation/sound/alsa/serial-u16550.txt linux/Documentation/sound/alsa/serial-u16550.txt
--- linux-2.6.11/Documentation/sound/alsa/serial-u16550.txt	2005-03-02 08:38:12.000000000 +0100
+++ linux/Documentation/sound/alsa/serial-u16550.txt	2005-03-07 15:22:19.000000000 +0100
@@ -23,12 +23,12 @@
 
 Usage example for simple serial converter:
 
-	/sbin/setserial /dev/ttyS0 none
+	/sbin/setserial /dev/ttyS0 uart none
 	/sbin/modprobe snd-serial-u16550 port=0x3f8 irq=4 speed=115200
 
 Usage example for Roland SoundCanvas with 4 MIDI ports:
 
-	/sbin/setserial /dev/ttyS0 none
+	/sbin/setserial /dev/ttyS0 uart none
 	/sbin/modprobe snd-serial-u16550 port=0x3f8 irq=4 outs=4
 
 In MS-124T mode, one raw MIDI substream is supported (midiCnD0); the outs
@@ -38,7 +38,7 @@
 
 Usage example for MS-124T, with A-B switch in A position:
 
-	/sbin/setserial /dev/ttyS0 none
+	/sbin/setserial /dev/ttyS0 uart none
 	/sbin/modprobe snd-serial-u16550 port=0x3f8 irq=4 adaptor=1 \
 			speed=19200
 
@@ -48,7 +48,7 @@
 
 Usage example for S/A mode:
 
-	/sbin/setserial /dev/ttyS0 none
+	/sbin/setserial /dev/ttyS0 uart none
 	/sbin/modprobe snd-serial-u16550 port=0x3f8 irq=4 adaptor=2
 
 In MS-124W M/B mode, the driver supports 16 ALSA raw MIDI substreams;
@@ -64,7 +64,7 @@
 
 Usage example for M/B mode:
 
-	/sbin/setserial /dev/ttyS0 none
+	/sbin/setserial /dev/ttyS0 uart none
 	/sbin/modprobe snd-serial-u16550 port=0x3f8 irq=4 adaptor=3
 
 The MS-124W hardware's M/A mode is currently not supported. This mode allows
