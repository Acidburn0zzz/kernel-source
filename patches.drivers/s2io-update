diff -u linux-2.6.7/drivers/net/s2io-regs.h~ linux-2.6.7/drivers/net/s2io-regs.h
--- linux-2.6.7/drivers/net/s2io-regs.h~	2004-06-16 07:19:22.000000000 +0200
+++ linux-2.6.7/drivers/net/s2io-regs.h	2004-08-11 15:49:57.645698995 +0200
@@ -289,6 +289,8 @@
 	u64 tda_err_alarm;
 
 	u64 pcc_err_reg;
+#define PCC_FB_ECC_DB_ERR		vBIT(0xFF, 16, 8)
+
 	u64 pcc_err_mask;
 	u64 pcc_err_alarm;
 
@@ -512,6 +514,7 @@
 #define RX_PA_CFG_IGNORE_FRM_ERR           BIT(1)
 #define RX_PA_CFG_IGNORE_SNAP_OUI          BIT(2)
 #define RX_PA_CFG_IGNORE_LLC_CTRL          BIT(3)
+#define RX_PA_CFG_IGNORE_L2_ERR            BIT(6)
 
 	u8 unused12[0x700 - 0x1D8];
 
@@ -773,3 +776,67 @@
 #define	XENA_EEPROM_SPACE (0x01 << 11)
 
 #endif				/* _REGS_H */
+/*
+ *$Log: regs.h,v $
+ *Revision 1.26  2004/05/31 12:21:20  rkoushik
+ *Bug: 986
+ *
+ *In this check in Iam making the fixes listed below,
+ *1. Handling the PCC_FB_ECC_ERR interrupt as specified in the new UG.
+ *2. Also queuing a task to reset the NIC when a serious Error is detected.
+ *3. The rmac_err_reg is cleared immediately in the Intr handler itself instead of the queued task 's2io_set_link'.
+ *
+ *Koushik
+ *
+ *Revision 1.25  2004/05/20 23:06:09  aravi
+ *Bug: 973
+ *Fixed compilation error in 2 buffer mode.
+ *Defined RX_PA_CFG_IGNORE_L2_ERR.
+ *
+ *Revision 1.24  2004/02/10 11:58:41  rkoushik
+ *Bug: 668
+ *Eliminated usage of self declared type 'dmaaddr_t' and also
+ *eliminated the usage of PPC64_ARCH macro which was prevalent in the older code.
+ *Further details in the bug.
+ *
+ *Koushik
+ *
+ *Revision 1.23  2004/02/04 04:52:44  rkoushik
+ *Bug: 667
+ * Indented the code using indent utility. Details of the options
+ *used are specified in bug # 667
+ *
+ *Koushik
+ *
+ *Revision 1.22  2004/01/23 12:08:39  rkoushik
+ *Bug: 549
+ *Added the beacon feature for new celestica cards using GPIO.
+ *test it out using the ethtool utility on both
+ *the new and old cards in both Link Up and Down states.
+ *
+ *Koushik
+ *
+ *Revision 1.21  2004/01/19 09:51:09  rkoushik
+ *Bug: 598
+ * Added GPL notices on the driver source files, namely
+ *s2io.c, s2io.h and regs.h
+ *
+ *Koushik
+ *
+ *Revision 1.20  2003/12/30 13:03:32  rkoushik
+ *Bug: 177
+ *The driver has been updated with support for funtionalities in ethtool
+ *version 1.8. Interrupt moderation has been skipped as the methodology to
+ *set it using ethtool is different to our methodology.
+ *
+ *-Koushik
+ *
+ *Revision 1.19  2003/12/01 22:02:38  ukiran
+ *Bug:510
+ *Cleanup of  chars
+ *
+ *Revision 1.18  2003/11/04 02:06:47  ukiran
+ *Bug:484
+ *Enabling Logs in source code
+ *
+ */
diff -u linux-2.6.7/drivers/net/s2io.c~ linux-2.6.7/drivers/net/s2io.c
--- linux-2.6.7/drivers/net/s2io.c~	2004-08-11 14:04:32.747201463 +0200
+++ linux-2.6.7/drivers/net/s2io.c	2004-08-11 15:51:12.912406870 +0200
@@ -61,16 +61,53 @@
 #include<asm/uaccess.h>
 #include<linux/version.h>
 #include<asm/io.h>
+#include<linux/proc_fs.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include<linux/tqueue.h>
+#else
 #include<linux/workqueue.h>
+#endif
+
+/* Macros to ensure the code is backward compatible with 2.4.x kernels. */
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(a, b)	do {} while(0)
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(x) kfree(x)
+#endif
+
+#ifndef IRQ_NONE
+typedef void irqreturn_t;
+#define	IRQ_NONE
+#define	IRQ_HANDLED
+#define	IRQ_RETVAL(x)
+#endif
 
 /* local include */
 #include "s2io.h"
 #include "s2io-regs.h"
 
+/* VENDOR and DEVICE ID of XENA. */
+#ifndef PCI_VENDOR_ID_S2IO
+#define PCI_VENDOR_ID_S2IO      0x17D5
+#define PCI_DEVICE_ID_S2IO_WIN  0x5731
+#define PCI_DEVICE_ID_S2IO_UNI  0x5831
+#endif
+
 /* S2io Driver name & version. */
 static char s2io_driver_name[] = "s2io";
 static char s2io_driver_version[] = "Version 1.0";
 
+/* Cards with following subsystem_id have a link state indication
+ * problem, 600B, 600C, 600D, 640B, 640C and 640D.
+ * macro below identifies these cards given the subsystem_id.
+ */
+#define CARDS_WITH_FAULTY_LINK_INDICATORS(subid) \
+		(((subid >= 0x600B) && (subid <= 0x600D)) || \
+		 ((subid >= 0x640B) && (subid <= 0x640D))) ? 1 : 0
+
 #define LINK_IS_UP(val64) (!(val64 & (ADAPTER_STATUS_RMAC_REMOTE_FAULT | \
 				      ADAPTER_STATUS_RMAC_LOCAL_FAULT)))
 #define TASKLET_IN_USE test_and_set_bit(0, \
@@ -80,7 +117,7 @@
 static inline int rx_buffer_level(nic_t * sp, int rxb_size, int ring)
 {
 	int level = 0;
-	if ((sp->pkt_cnt[ring] - rxb_size) > 128) {
+	if ((sp->pkt_cnt[ring] - rxb_size) > 16) {
 		level = LOW;
 		if (rxb_size < sp->pkt_cnt[ring] / 8)
 			level = PANIC;
@@ -90,6 +127,9 @@
 }
 
 /* Ethtool related variables and Macros. */
+#ifndef SET_ETHTOOL_OPS
+static int s2io_ethtool(struct net_device *dev, struct ifreq *rq);
+#endif
 static char s2io_gstrings[][ETH_GSTRING_LEN] = {
 	"Register test\t(offline)",
 	"Eeprom test\t(offline)",
@@ -98,50 +138,52 @@
 	"BIST Test\t(offline)"
 };
 
+#ifdef ETHTOOL_GSTATS
 static char ethtool_stats_keys[][ETH_GSTRING_LEN] = {
-	"tmac_frms",
-	"tmac_data_octets",
-	"tmac_drop_frms",
-	"tmac_mcst_frms",
-	"tmac_bcst_frms",
-	"tmac_pause_ctrl_frms",
-	"tmac_any_err_frms",
-	"tmac_vld_ip_octets",
-	"tmac_vld_ip",
-	"tmac_drop_ip",
-	"tmac_icmp",
-	"tmac_rst_tcp",
-	"tmac_tcp",
-	"tmac_udp",
-	"rmac_vld_frms",
-	"rmac_data_octets",
-	"rmac_fcs_err_frms",
-	"rmac_drop_frms",
-	"rmac_vld_mcst_frms",
-	"rmac_vld_bcst_frms",
-	"rmac_in_rng_len_err_frms",
-	"rmac_long_frms",
-	"rmac_pause_ctrl_frms",
-	"rmac_discarded_frms",
-	"rmac_usized_frms",
-	"rmac_osized_frms",
-	"rmac_frag_frms",
-	"rmac_jabber_frms",
-	"rmac_ip",
-	"rmac_ip_octets",
-	"rmac_hdr_err_ip",
-	"rmac_drop_ip",
-	"rmac_icmp",
-	"rmac_tcp",
-	"rmac_udp",
-	"rmac_err_drp_udp",
-	"rmac_pause_cnt",
-	"rmac_accepted_ip",
-	"rmac_err_tcp",
+	{"tmac_frms"},
+	{"tmac_data_octets"},
+	{"tmac_drop_frms"},
+	{"tmac_mcst_frms"},
+	{"tmac_bcst_frms"},
+	{"tmac_pause_ctrl_frms"},
+	{"tmac_any_err_frms"},
+	{"tmac_vld_ip_octets"},
+	{"tmac_vld_ip"},
+	{"tmac_drop_ip"},
+	{"tmac_icmp"},
+	{"tmac_rst_tcp"},
+	{"tmac_tcp"},
+	{"tmac_udp"},
+	{"rmac_vld_frms"},
+	{"rmac_data_octets"},
+	{"rmac_fcs_err_frms"},
+	{"rmac_drop_frms"},
+	{"rmac_vld_mcst_frms"},
+	{"rmac_vld_bcst_frms"},
+	{"rmac_in_rng_len_err_frms"},
+	{"rmac_long_frms"},
+	{"rmac_pause_ctrl_frms"},
+	{"rmac_discarded_frms"},
+	{"rmac_usized_frms"},
+	{"rmac_osized_frms"},
+	{"rmac_frag_frms"},
+	{"rmac_jabber_frms"},
+	{"rmac_ip"},
+	{"rmac_ip_octets"},
+	{"rmac_hdr_err_ip"},
+	{"rmac_drop_ip"},
+	{"rmac_icmp"},
+	{"rmac_tcp"},
+	{"rmac_udp"},
+	{"rmac_err_drp_udp"},
+	{"rmac_pause_cnt"},
+	{"rmac_accepted_ip"},
+	{"rmac_err_tcp"},
 };
 
 #define S2IO_STAT_LEN sizeof(ethtool_stats_keys)/ ETH_GSTRING_LEN
 #define S2IO_STAT_STRINGS_LEN S2IO_STAT_LEN * ETH_GSTRING_LEN
+#endif
 
 #define S2IO_TEST_LEN	sizeof(s2io_gstrings) / ETH_GSTRING_LEN
 #define S2IO_STRINGS_LEN	S2IO_TEST_LEN * ETH_GSTRING_LEN
@@ -188,6 +230,36 @@
 	END_SIGN
 };
 
+#if USE_OLD_PHY
+
+static u64 oldphy_mdio_cfg[] = {
+	0x0018040000000000ULL, 0x00180400000000E0ULL,
+	0x00180400000000ECULL,
+	SWITCH_SIGN,
+	0x0018040000000000ULL, 0x00180400000000E0ULL,
+	0x00180400000000ECULL,
+	END_SIGN
+};
+
+static u64 oldphy_dtx_cfg[] = {
+	0x8000051500000000ULL, 0x80000515000000E0ULL,
+	0x80000515D93500E4ULL, 0x8001051500000000ULL,
+	0x80010515000000E0ULL, 0x80010515001E00E4ULL,
+	0x8002051500000000ULL, 0x80020515000000E0ULL,
+	0x80020515F21000E4ULL, 0x8000051500000000ULL,
+	0x80000515000000E0ULL, 0x80000515D93500ECULL,
+	0x8001051500000000ULL, 0x80010515000000E0ULL,
+	0x80010515000000ECULL, 0x8002051500000000ULL,
+	0x80020515000000E0ULL, 0x80020515000000ECULL,
+	SWITCH_SIGN,
+	0x0000051500000000ULL, 0x00000515604000E0ULL,
+	0x00000515604000E4ULL, 0x00000515204000E4ULL,
+	0x00000515204000ECULL,
+	END_SIGN
+};
+
+#endif
+
 /* Constants for Fixing the MacAddress problem seen mostly on
  * Alpha machines.
  */
@@ -209,15 +281,63 @@
 	END_SIGN
 };
 
-
 /* Module Loadable parameters. */
-static u32 ring_num;
 static u32 frame_len[MAX_RX_RINGS];
-static u32 ring_len[MAX_RX_RINGS];
-static u32 fifo_num;
-static u32 fifo_len[MAX_TX_FIFOS];
 static u32 rx_prio;
 static u32 tx_prio;
+
+static unsigned int lso_enable = 1;
+static unsigned int indicate_max_pkts = 0;
+static unsigned int cksum_offload_enable = 1;
+static unsigned int TxFifoNum = 1;
+static unsigned int TxFIFOLen_0 = DEFAULT_FIFO_LEN;
+static unsigned int TxFIFOLen_1 = 0;
+static unsigned int TxFIFOLen_2 = 0;
+static unsigned int TxFIFOLen_3 = 0;
+static unsigned int TxFIFOLen_4 = 0;
+static unsigned int TxFIFOLen_5 = 0;
+static unsigned int TxFIFOLen_6 = 0;
+static unsigned int TxFIFOLen_7 = 0;
+static unsigned int MaxTxDs = MAX_SKB_FRAGS;
+static unsigned int RxRingNum = 1;
+static unsigned int RxRingSz_0 = SMALL_BLK_CNT;
+static unsigned int RxRingSz_1 = 0;
+static unsigned int RxRingSz_2 = 0;
+static unsigned int RxRingSz_3 = 0;
+static unsigned int RxRingSz_4 = 0;
+static unsigned int RxRingSz_5 = 0;
+static unsigned int RxRingSz_6 = 0;
+static unsigned int RxRingSz_7 = 0;
+static unsigned int Stats_refresh_time = 4;
+static unsigned int rmac_pause_time = 65535;
+static unsigned int mc_pause_threshold_q0q3 = 187;
+static unsigned int mc_pause_threshold_q4q7 = 187;
+static unsigned int shared_splits = 0;
+#if defined(__ia64__)
+static unsigned int max_splits_trans = XENA_THREE_SPLIT_TRANSACTION;
+#else
+static unsigned int max_splits_trans = XENA_TWO_SPLIT_TRANSACTION;
+#endif
+static unsigned int tmac_util_period = 5;
+static unsigned int rmac_util_period = 5;
+static unsigned int tx_timer_val = 0xFFF;
+static unsigned int tx_utilz_periodic = 1;
+static unsigned int rx_timer_val = 0xFFF;
+static unsigned int rx_utilz_periodic = 1;
+static unsigned int tx_urange_a = 0xA;
+static unsigned int tx_ufc_a = 0x10;
+static unsigned int tx_urange_b = 0x10;
+static unsigned int tx_ufc_b = 0x20;
+static unsigned int tx_urange_c = 0x30;
+static unsigned int tx_ufc_c = 0x40;
+static unsigned int tx_ufc_d = 0x80;
+static unsigned int rx_urange_a = 0xA;
+static unsigned int rx_ufc_a = 0x1;
+static unsigned int rx_urange_b = 0x10;
+static unsigned int rx_ufc_b = 0x2;
+static unsigned int rx_urange_c = 0x30;
+static unsigned int rx_ufc_c = 0x40;
+static unsigned int rx_ufc_d = 0x80;
 static u8 latency_timer = 0;
 
 /* 
@@ -241,17 +361,15 @@
       remove:__devexit_p(s2io_rem_nic),
 };
 
-/*  
- *  Input Arguments: 
- *  Device private variable.
- *  Return Value: 
- *  SUCCESS on success and an appropriate -ve value on failure.
- *  Description: 
- *  The function allocates the all memory areas shared 
- *  between the NIC and the driver. This includes Tx descriptors, 
- *  Rx descriptors and the statistics block.
+/**
+ * init_shared_mem - Allocation and Initialization of Memory
+ * @nic: Device private variable.
+ * Description: The function allocates the all memory areas shared 
+ * between the NIC and the driver. This includes Tx descriptors, 
+ * Rx descriptors and the statistics block.
  */
-static int initSharedMem(struct s2io_nic *nic)
+
+static int init_shared_mem(struct s2io_nic *nic)
 {
 	u32 size;
 	void *tmp_v_addr, *tmp_v_addr_next;
@@ -259,11 +377,19 @@
 	RxD_block_t *pre_rxd_blk = NULL;
 	int i, j, blk_cnt;
 	struct net_device *dev = nic->dev;
-
-	mac_info_t *mac_control;
 	struct config_param *config;
-
+#ifdef MAC
+    mac_info_tx_t *mac_control_tx;
+    mac_info_rx_t *mac_control_rx;
+    mac_info_st_t *mac_control_st;
+    mac_control_tx = &nic->mac_control_tx;
+    mac_control_rx = &nic->mac_control_rx;
+    mac_control_st = &nic->mac_control_st;
+#else
+	mac_info_t *mac_control;
 	mac_control = &nic->mac_control;
+#endif
+
 	config = &nic->config;
 
 
@@ -279,8 +405,126 @@
 		DBG_PRINT(ERR_DBG, "that can be used\n");
 		return FAILURE;
 	}
+#ifdef TXDBD
+    size = (size * (sizeof(TxD_t)) * config->MaxTxDs);
+#ifdef MAC
+    mac_control_tx->txd_fifo_mem_sz = size;
+     /* Initialize the put and get information */
+     for (i = 0; i < config->TxFIFONum; i++) {
+              mac_control_tx->tx_curr_put_info[i].block_index = 0;
+              mac_control_tx->tx_curr_put_info[i].offset = 0;
+              mac_control_tx->tx_curr_put_info[i].fifo_len =
+                   config->TxCfg[i].FifoLen ;
+
+          mac_control_tx->tx_curr_get_info[i].block_index = 0;
+          mac_control_tx->tx_curr_get_info[i].offset = 0;
+          mac_control_tx->tx_curr_get_info[i].fifo_len =
+              config->TxCfg[i].FifoLen ;
+          blk_cnt = config->TxCfg[i].FifoLen * config->MaxTxDs/
+                (mac_control_tx->max_txds_per_block);
+              nic->tx_block_count[i] = blk_cnt;
+	  nic->tx_blocks[i] = NULL;
+          nic->tx_blocks[i]=(struct tx_block_info *)kmalloc
+                (sizeof(struct tx_block_info ) * blk_cnt, GFP_KERNEL);
+	  if(!nic->tx_blocks[i])
+	  {
+		for( j= 0; j< i ; ++j)
+		{
+			kfree(nic->tx_blocks[j]);
+			nic->tx_blocks[j] = NULL;
+		}
+		return -ENOMEM;
+	  }
+          for (j = 0; j < blk_cnt; j++) {
+              size = (mac_control_tx->max_txds_per_block ) * (sizeof(TxD_t));
+              tmp_v_addr = pci_alloc_consistent(nic->pdev, size,
+                                 &tmp_p_addr);
+                  if (tmp_v_addr == NULL) {
+                             return -ENOMEM;
+                   }
+                   memset(tmp_v_addr, 0, size);
+                       nic->tx_blocks[i][j].block_virt_addr = tmp_v_addr;
+                       nic->tx_blocks[i][j].block_dma_addr = tmp_p_addr;
+              }
+       }
+
+#else
+    mac_control->txd_fifo_mem_sz = size;
+     /* Initialize the put and get information */
+     for (i = 0; i < config->TxFIFONum; i++) {
+              mac_control->tx_curr_put_info[i].block_index = 0;
+              mac_control->tx_curr_put_info[i].offset = 0;
+              mac_control->tx_curr_put_info[i].fifo_len =
+                   config->TxCfg[i].FifoLen ;
+
+          mac_control->tx_curr_get_info[i].block_index = 0;
+          mac_control->tx_curr_get_info[i].offset = 0;
+          mac_control->tx_curr_get_info[i].fifo_len =
+              config->TxCfg[i].FifoLen ;
+          blk_cnt = config->TxCfg[i].FifoLen * config->MaxTxDs/
+                (mac_control->max_txds_per_block);
+              nic->tx_block_count[i] = blk_cnt;
+	  nic->tx_blocks[i]= NULL;
+          nic->tx_blocks[i]=(struct tx_block_info *)kmalloc
+                (sizeof(struct tx_block_info ) * blk_cnt, GFP_KERNEL);
+	  if(!nic->tx_blocks[i])
+	  {
+		for( j= 0; j< i ; ++j)
+		{
+			kfree(nic->tx_blocks[j]);
+			nic->tx_blocks[j] = NULL;
+		}
+		return -ENOMEM;
+	  }
+          for (j = 0; j < blk_cnt; j++) {
+              size = (mac_control->max_txds_per_block ) * (sizeof(TxD_t));
+              tmp_v_addr = pci_alloc_consistent(nic->pdev, size,
+                                 &tmp_p_addr);
+                  if (tmp_v_addr == NULL) {
+                             return -ENOMEM;
+                   }
+                   memset(tmp_v_addr, 0, size);
+                       nic->tx_blocks[i][j].block_virt_addr = tmp_v_addr;
+                       nic->tx_blocks[i][j].block_dma_addr = tmp_p_addr;
+              }
+       }
+#endif
+#else
 	size *= (sizeof(TxD_t) * config->MaxTxDs);
+#ifdef MAC
+    mac_control_tx->txd_list_mem = pci_alloc_consistent
+        (nic->pdev, size, &mac_control_tx->txd_list_mem_phy);
+    if (!mac_control_tx->txd_list_mem) {
+        return -ENOMEM;
+    }
+    mac_control_tx->txd_list_mem_sz = size;
+
+    tmp_v_addr = mac_control_tx->txd_list_mem;
+    tmp_p_addr = mac_control_tx->txd_list_mem_phy;
+    memset(tmp_v_addr, 0, size);
+
+    DBG_PRINT(INIT_DBG, "%s:List Mem PHY: 0x%llx\n", dev->name,
+          (unsigned long long) tmp_p_addr);
+
+    for (i = 0; i < config->TxFIFONum; i++) {
+        mac_control_tx->txdl_start_phy[i] = tmp_p_addr;
+        mac_control_tx->txdl_start[i] = (TxD_t *) tmp_v_addr;
+        mac_control_tx->tx_curr_put_info[i].offset = 0;
+        mac_control_tx->tx_curr_put_info[i].fifo_len =
+            config->TxCfg[i].FifoLen - 1;
+        mac_control_tx->tx_curr_get_info[i].offset = 0;
+        mac_control_tx->tx_curr_get_info[i].fifo_len =
+            config->TxCfg[i].FifoLen - 1;
+
+        tmp_p_addr +=
+            (config->TxCfg[i].FifoLen * (sizeof(TxD_t)) *
+             config->MaxTxDs);
+        tmp_v_addr +=
+            (config->TxCfg[i].FifoLen * (sizeof(TxD_t)) *
+             config->MaxTxDs);
+    }
 
+#else
 	mac_control->txd_list_mem = pci_alloc_consistent
 	    (nic->pdev, size, &mac_control->txd_list_mem_phy);
 	if (!mac_control->txd_list_mem) {
@@ -312,6 +556,8 @@
 		    (config->TxCfg[i].FifoLen * (sizeof(TxD_t)) *
 		     config->MaxTxDs);
 	}
+#endif
+#endif
 
 	/* Allocation and initialization of RXDs in Rings */
 	size = 0;
@@ -330,6 +576,19 @@
 		    config->RxCfg[i].NumRxd - nic->block_count[i];
 	}
 	size = (size * (sizeof(RxD_t)));
+#ifdef MAC
+    mac_control_rx->rxd_ring_mem_sz = size;
+
+    for (i = 0; i < config->RxRingNum; i++) {
+        mac_control_rx->rx_curr_get_info[i].block_index = 0;
+        mac_control_rx->rx_curr_get_info[i].offset = 0;
+        mac_control_rx->rx_curr_get_info[i].ring_len =
+            config->RxCfg[i].NumRxd - 1;
+        mac_control_rx->rx_curr_put_info[i].block_index = 0;
+        mac_control_rx->rx_curr_put_info[i].offset = 0;
+        mac_control_rx->rx_curr_put_info[i].ring_len =
+            config->RxCfg[i].NumRxd - 1;
+#else
 	mac_control->rxd_ring_mem_sz = size;
 
 	for (i = 0; i < config->RxRingNum; i++) {
@@ -341,15 +600,20 @@
 		mac_control->rx_curr_put_info[i].offset = 0;
 		mac_control->rx_curr_put_info[i].ring_len =
 		    config->RxCfg[i].NumRxd - 1;
+#endif
 		blk_cnt =
 		    config->RxCfg[i].NumRxd / (MAX_RXDS_PER_BLOCK + 1);
 		/*  Allocating all the Rx blocks */
 		for (j = 0; j < blk_cnt; j++) {
+#ifndef CONFIG_2BUFF_MODE
 			size = (MAX_RXDS_PER_BLOCK + 1) * (sizeof(RxD_t));
+#else
+			size = SIZE_OF_BLOCK;
+#endif
 			tmp_v_addr = pci_alloc_consistent(nic->pdev, size,
 							  &tmp_p_addr);
 			if (tmp_v_addr == NULL) {
-				/* In case of failure, freeSharedMem() 
+				/* In case of failure, free_shared_mem() 
 				 * is called, which should free any 
 				 * memory that was alloced till the 
 				 * failure happened.
@@ -377,8 +641,10 @@
 			pre_rxd_blk->reserved_1 = END_OF_BLOCK;	/* last RxD 
 								 * marker.
 								 */
+#ifndef	CONFIG_2BUFF_MODE
 			pre_rxd_blk->reserved_2_pNext_RxD_block =
 			    (unsigned long) tmp_v_addr_next;
+#endif
 			pre_rxd_blk->pNext_RxD_Blk_physical =
 			    (u64) tmp_p_addr_next;
 		}
@@ -386,11 +652,28 @@
 
 	/* Allocation and initialization of Statistics block */
 	size = sizeof(StatInfo_t);
+#ifdef MAC
+    mac_control_st->stats_mem = pci_alloc_consistent
+        (nic->pdev, size, &mac_control_st->stats_mem_phy);
+
+    if (!mac_control_st->stats_mem) {
+        /* In case of failure, free_shared_mem() is called, which 
+         * should free any memory that was alloced till the 
+         * failure happened.
+         */
+        return -ENOMEM;
+    }
+    mac_control_st->stats_mem_sz = size;
+
+    tmp_v_addr = mac_control_st->stats_mem;
+    mac_control_st->StatsInfo = (StatInfo_t *) tmp_v_addr;
+#else
+
 	mac_control->stats_mem = pci_alloc_consistent
 	    (nic->pdev, size, &mac_control->stats_mem_phy);
 
 	if (!mac_control->stats_mem) {
-		/* In case of failure, freeSharedMem() is called, which 
+		/* In case of failure, free_shared_mem() is called, which 
 		 * should free any memory that was alloced till the 
 		 * failure happened.
 		 */
@@ -400,7 +683,27 @@
 
 	tmp_v_addr = mac_control->stats_mem;
 	mac_control->StatsInfo = (StatInfo_t *) tmp_v_addr;
+#endif
 	memset(tmp_v_addr, 0, size);
+#ifdef SNMP_SUPPORT
+#ifdef TXDBD
+#ifdef MAC
+        nic->nMemorySize = mac_control_tx->txd_fifo_mem_sz +
+               mac_control_st->stats_mem_sz + mac_control_rx->rxd_ring_mem_sz;
+#else
+        nic->nMemorySize = mac_control->txd_fifo_mem_sz +
+                 mac_control->stats_mem_sz + mac_control->rxd_ring_mem_sz;
+#endif
+#else
+#ifdef MAC
+        nic->nMemorySize = mac_control_tx->txd_list_mem_sz +
+                 mac_control_st->stats_mem_sz + mac_control_rx->rxd_ring_mem_sz;
+#else
+        nic->nMemorySize = mac_control->txd_list_mem_sz +
+                 mac_control->stats_mem_sz + mac_control->rxd_ring_mem_sz;
+#endif
+#endif
+#endif
 
 	DBG_PRINT(INIT_DBG, "%s:Ring Mem PHY: 0x%llx\n", dev->name,
 		  (unsigned long long) tmp_p_addr);
@@ -408,29 +711,76 @@
 	return SUCCESS;
 }
 
-/*  
- *  Input Arguments: 
- *  Device peivate variable.
- *  Return Value: 
- *  NONE
- *  Description: 
- *  This function is to free all memory locations allocated by
- *  the initSharedMem() function and return it to the kernel.
+/**  
+ * free_shared_mem - Free the allocated Memory 
+ * @nic:  Device private variable.
+ * Description: This function is to free all memory locations allocated by
+ * the init_shared_mem() function and return it to the kernel.
  */
-static void freeSharedMem(struct s2io_nic *nic)
+
+static void free_shared_mem(struct s2io_nic *nic)
 {
 	int i, j, blk_cnt, size;
 	void *tmp_v_addr;
 	dma_addr_t tmp_p_addr;
-	mac_info_t *mac_control;
 	struct config_param *config;
-
+#ifdef MAC
+    mac_info_tx_t *mac_control_tx;
+    mac_info_st_t *mac_control_st;
+#else
+    mac_info_t *mac_control;
+#endif
 
 	if (!nic)
 		return;
 
-	mac_control = &nic->mac_control;
 	config = &nic->config;
+#ifdef MAC
+    mac_control_tx = &nic->mac_control_tx;
+    mac_control_st = &nic->mac_control_st;
+#else
+	mac_control = &nic->mac_control;
+#endif
+#ifdef TXDBD
+#ifdef MAC
+    size = (mac_control_tx->max_txds_per_block) * (sizeof(TxD_t));
+    for (i = 0; i < config->TxFIFONum; i++) {
+          blk_cnt = nic->tx_block_count[i];
+          for (j = 0; j < blk_cnt; j++) {
+              tmp_v_addr = nic->tx_blocks[i][j].block_virt_addr;
+              tmp_p_addr = nic->tx_blocks[i][j].block_dma_addr;
+              if (tmp_v_addr == NULL)
+                      break;
+              pci_free_consistent(nic->pdev, size,
+                   tmp_v_addr, tmp_p_addr);
+          }
+          kfree(nic->tx_blocks[i]);
+     }
+#else
+    size = (mac_control->max_txds_per_block) * (sizeof(TxD_t));
+    for (i = 0; i < config->TxFIFONum; i++) {
+          blk_cnt = nic->tx_block_count[i];
+          for (j = 0; j < blk_cnt; j++) {
+              tmp_v_addr = nic->tx_blocks[i][j].block_virt_addr;
+              tmp_p_addr = nic->tx_blocks[i][j].block_dma_addr;
+              if (tmp_v_addr == NULL)
+                      break;
+              pci_free_consistent(nic->pdev, size,
+                   tmp_v_addr, tmp_p_addr);
+          }
+          kfree(nic->tx_blocks[i]);
+     }
+#endif
+#else
+#ifdef MAC
+    if (mac_control_tx->txd_list_mem) {
+        pci_free_consistent(nic->pdev,
+                    mac_control_tx->txd_list_mem_sz,
+                    mac_control_tx->txd_list_mem,
+                    mac_control_tx->txd_list_mem_phy);
+    }
+
+#else
 
 	if (mac_control->txd_list_mem) {
 		pci_free_consistent(nic->pdev,
@@ -438,8 +788,14 @@
 				    mac_control->txd_list_mem,
 				    mac_control->txd_list_mem_phy);
 	}
+#endif
+#endif
 
+#ifndef CONFIG_2BUFF_MODE
 	size = (MAX_RXDS_PER_BLOCK + 1) * (sizeof(RxD_t));
+#else
+	size = SIZE_OF_BLOCK;
+#endif
 	for (i = 0; i < config->RxRingNum; i++) {
 		blk_cnt = nic->block_count[i];
 		for (j = 0; j < blk_cnt; j++) {
@@ -451,25 +807,34 @@
 					    tmp_v_addr, tmp_p_addr);
 		}
 	}
+#ifdef MAC
+    if (mac_control_st->stats_mem) {
+        pci_free_consistent(nic->pdev,
+                    mac_control_st->stats_mem_sz,
+                    mac_control_st->stats_mem,
+                    mac_control_st->stats_mem_phy);
+    }
 
+#else
 	if (mac_control->stats_mem) {
 		pci_free_consistent(nic->pdev,
 				    mac_control->stats_mem_sz,
 				    mac_control->stats_mem,
 				    mac_control->stats_mem_phy);
 	}
+#endif
 }
 
-/*  
- *  Input Arguments: 
- *  device peivate variable
- *  Return Value: 
- *  SUCCESS on success and '-1' on failure (endian settings incorrect).
- *  Description: 
- *  The function sequentially configures every block 
+/**  
+ *  init_nic - Initialization of hardware 
+ *  @nic: device peivate variable
+ *  Description: The function sequentially configures every block 
  *  of the H/W from their reset values. 
+ *  Returns:  SUCCESS on success and 
+ *  '-1' on failure (endian settings incorrect).
  */
-static int initNic(struct s2io_nic *nic)
+
+static int init_nic(struct s2io_nic *nic)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
 	struct net_device *dev = nic->dev;
@@ -477,14 +842,23 @@
 	void *add;
 	u32 time;
 	int i, j;
+#ifdef MAC
+    mac_info_rx_t *mac_control_rx;
+    mac_info_st_t *mac_control_st;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
 	int mdio_cnt = 0, dtx_cnt = 0;
 	unsigned long long print_var, mem_share;
 
-	mac_control = &nic->mac_control;
 	config = &nic->config;
-
+#ifdef MAC
+    mac_control_rx = &nic->mac_control_rx;
+    mac_control_st = &nic->mac_control_st;
+#else
+	mac_control = &nic->mac_control;
+#endif
 	/*  Set proper endian settings and verify the same by 
 	 *  reading the PIF Feed-back register.
 	 */
@@ -759,14 +1133,20 @@
 	       &bar0->rts_frm_len_n[0]);
 
 	/* Enable statistics */
+#ifdef MAC
+    writeq(mac_control_st->stats_mem_phy, &bar0->stat_addr);
+#else
 	writeq(mac_control->stats_mem_phy, &bar0->stat_addr);
-	val64 = SET_UPDT_PERIOD(8) | STAT_CFG_STAT_RO | STAT_CFG_STAT_EN;
+#endif
+	val64 = SET_UPDT_PERIOD(Stats_refresh_time) |
+	    STAT_CFG_STAT_RO | STAT_CFG_STAT_EN;
 	writeq(val64, &bar0->stat_cfg);
 
 	/* Initializing the sampling rate for the device to calculate the
 	 * bandwidth utilization.
 	 */
-	val64 = MAC_TX_LINK_UTIL_VAL(0x5) | MAC_RX_LINK_UTIL_VAL(0x5);
+	val64 = MAC_TX_LINK_UTIL_VAL(tmac_util_period) |
+	    MAC_RX_LINK_UTIL_VAL(rmac_util_period);
 	writeq(val64, &bar0->mac_link_util);
 
 
@@ -774,14 +1154,18 @@
 	 * Scheme.
 	 */
 	/* TTI Initialization */
-	val64 = TTI_DATA1_MEM_TX_TIMER_VAL(0xFFF) |
-	    TTI_DATA1_MEM_TX_URNG_A(0xA) | TTI_DATA1_MEM_TX_URNG_B(0x10) |
-	    TTI_DATA1_MEM_TX_URNG_C(0x30) | TTI_DATA1_MEM_TX_TIMER_AC_EN;
+	val64 = TTI_DATA1_MEM_TX_TIMER_VAL(tx_timer_val) |
+	    TTI_DATA1_MEM_TX_URNG_A(tx_urange_a) |
+	    TTI_DATA1_MEM_TX_URNG_B(tx_urange_b) |
+	    TTI_DATA1_MEM_TX_URNG_C(tx_urange_c);
+	if (tx_utilz_periodic)
+		val64 |= TTI_DATA1_MEM_TX_TIMER_AC_EN;
 	writeq(val64, &bar0->tti_data1_mem);
 
-	val64 =
-	    TTI_DATA2_MEM_TX_UFC_A(0x10) | TTI_DATA2_MEM_TX_UFC_B(0x20) |
-	    TTI_DATA2_MEM_TX_UFC_C(0x40) | TTI_DATA2_MEM_TX_UFC_D(0x80);
+	val64 = TTI_DATA2_MEM_TX_UFC_A(tx_ufc_a) |
+	    TTI_DATA2_MEM_TX_UFC_B(tx_ufc_b) |
+	    TTI_DATA2_MEM_TX_UFC_C(tx_ufc_c) |
+	    TTI_DATA2_MEM_TX_UFC_D(tx_ufc_d);
 	writeq(val64, &bar0->tti_data2_mem);
 
 	val64 = TTI_CMD_MEM_WE | TTI_CMD_MEM_STROBE_NEW_CMD;
@@ -809,13 +1193,19 @@
 	}
 
 	/* RTI Initialization */
-	val64 = RTI_DATA1_MEM_RX_TIMER_VAL(0xFFF) |
-	    RTI_DATA1_MEM_RX_URNG_A(0xA) | RTI_DATA1_MEM_RX_URNG_B(0x10) |
-	    RTI_DATA1_MEM_RX_URNG_C(0x30) | RTI_DATA1_MEM_RX_TIMER_AC_EN;
+	val64 = RTI_DATA1_MEM_RX_TIMER_VAL(rx_timer_val) |
+	    RTI_DATA1_MEM_RX_URNG_A(rx_urange_a) |
+	    RTI_DATA1_MEM_RX_URNG_B(rx_urange_b) |
+	    RTI_DATA1_MEM_RX_URNG_C(rx_urange_c);
+	if (rx_utilz_periodic)
+		val64 |= RTI_DATA1_MEM_RX_TIMER_AC_EN;
+
 	writeq(val64, &bar0->rti_data1_mem);
 
-	val64 = RTI_DATA2_MEM_RX_UFC_A(0x1) | RTI_DATA2_MEM_RX_UFC_B(0x2) |
-	    RTI_DATA2_MEM_RX_UFC_C(0x40) | RTI_DATA2_MEM_RX_UFC_D(0x80);
+	val64 = RTI_DATA2_MEM_RX_UFC_A(rx_ufc_a) |
+	    RTI_DATA2_MEM_RX_UFC_B(rx_ufc_b) |
+	    RTI_DATA2_MEM_RX_UFC_C(rx_ufc_c) |
+	    RTI_DATA2_MEM_RX_UFC_D(rx_ufc_d);
 	writeq(val64, &bar0->rti_data2_mem);
 
 	val64 = RTI_CMD_MEM_WE | RTI_CMD_MEM_STROBE_NEW_CMD;
@@ -858,22 +1248,81 @@
 	writel((u32) (val64 >> 32), (add + 4));
 	val64 = readq(&bar0->mac_cfg);
 
+	/*Set the time value  to be inserted in the pause frame generated by xena */
+	val64 = readq(&bar0->rmac_pause_cfg);
+	val64 &= ~(RMAC_PAUSE_HG_PTIME(0xffff));
+#ifdef MAC
+    val64 |= RMAC_PAUSE_HG_PTIME(nic->mac_control_rx.rmac_pause_time);
+#else
+	val64 |= RMAC_PAUSE_HG_PTIME(nic->mac_control.rmac_pause_time);
+#endif
+	writeq(val64, &bar0->rmac_pause_cfg);
+
+	/* Set the Threshold Limit for Generating the pause frame
+	 * If the amount of data in any Queue exceeds ratio of
+	 * (mac_control.mc_pause_threshold_q0q3 or q4q7)/256
+	 * pause frame is generated
+	 */
+#ifdef MAC
+    val64 = 0;
+    for (i = 0; i < 4; i++) {
+        val64 |=
+            (((u64) 0xFF00 | nic->mac_control_rx.
+              mc_pause_threshold_q0q3)
+             << (i * 2 * 8));
+    }
+    writeq(val64, &bar0->mc_pause_thresh_q0q3);
+
+    val64 = 0;
+    for (i = 0; i < 4; i++) {
+        val64 |=
+            (((u64) 0xFF00 | nic->mac_control_rx.
+              mc_pause_threshold_q4q7)
+             << (i * 2 * 8));
+    }
+#else
+	val64 = 0;
+	for (i = 0; i < 4; i++) {
+		val64 |=
+		    (((u64) 0xFF00 | nic->mac_control.
+		      mc_pause_threshold_q0q3)
+		     << (i * 2 * 8));
+	}
+	writeq(val64, &bar0->mc_pause_thresh_q0q3);
+
+	val64 = 0;
+	for (i = 0; i < 4; i++) {
+		val64 |=
+		    (((u64) 0xFF00 | nic->mac_control.
+		      mc_pause_threshold_q4q7)
+		     << (i * 2 * 8));
+	}
+#endif
+
+	writeq(val64, &bar0->mc_pause_thresh_q4q7);
+
+	/* TxDMA will stop Read request if the number of read split has exceeded
+	 * the limit pointed by shared_splits
+	 */
+	val64 = readq(&bar0->pic_control);
+	val64 |= PIC_CNTL_SHARED_SPLITS(shared_splits);
+	writeq(val64, &bar0->pic_control);
+
 	return SUCCESS;
 }
 
-/*  
- *  Input Arguments: 
- *  device private variable,
- *  A mask indicating which Intr block must be modified and,
- *  A flag indicating whether to enable or disable the Intrs.
- *  Return Value: 
- *  NONE.
- *  Description: 
- *  This function will either disable or enable the interrupts 
+/**  
+ *  en_dis_able_nicintrs - Enable or Disable the interrupts 
+ *  @nic: device private variable,
+ *  @mask: A mask indicating which Intr block must be modified and,
+ *  @flag: A flag indicating whether to enable or disable the Intrs.
+ *  Description: This function will either disable or enable the interrupts
  *  depending on the flag argument. The mask argument can be used to 
  *  enable/disable any Intr block. 
+ *  Return Value: NONE.
  */
-static void en_dis_able_NicIntrs(struct s2io_nic *nic, u16 mask, int flag)
+
+static void en_dis_able_nic_intrs(struct s2io_nic *nic, u16 mask, int flag)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
 	register u64 val64 = 0, temp64 = 0;
@@ -913,15 +1362,20 @@
 			temp64 = readq(&bar0->general_int_mask);
 			temp64 &= ~((u64) val64);
 			writeq(temp64, &bar0->general_int_mask);
-			/* Disable all interrupts other than PFC interrupt in 
-			 * DMA level.
+			/* Keep all interrupts other than PFC interrupt 
+			 * and PCC interrupt disabled in DMA level.
 			 */
-			val64 = DISABLE_ALL_INTRS & (~TXDMA_PFC_INT_M);
+			val64 = DISABLE_ALL_INTRS & ~(TXDMA_PFC_INT_M | 
+						TXDMA_PCC_INT_M);
 			writeq(val64, &bar0->txdma_int_mask);
 			/* Enable only the MISC error 1 interrupt in PFC block 
 			 */
 			val64 = DISABLE_ALL_INTRS & (~PFC_MISC_ERR_1);
 			writeq(val64, &bar0->pfc_err_mask);
+			/* Enable only the FB_ECC error interrupt in PCC block 
+			 */
+			val64 = DISABLE_ALL_INTRS & (~PCC_FB_ECC_ERR);
+			writeq(val64, &bar0->pcc_err_mask);
 		} else if (flag == DISABLE_INTRS) {
 			/*  Disable TxDMA Intrs in the general intr mask 
 			 *  register */
@@ -1075,17 +1529,19 @@
 	}
 }
 
-/*  
- *  Input Arguments: 
- *   val64 - Value read from adapter status register.
- *   flag - indicates if the adapter enable bit was ever written once before.
- *  Return Value: 
- *   void.
- *  Description: 
- *   Returns whether the H/W is ready to go or not. Depending on whether 
- *   adapter enable bit was written or not the comparison differs and the 
- *   calling function passes the input argument flag to indicate this.
+/**  
+ *  verify_xena_quiescence - Checks whether the H/W is ready 
+ *  @val64 :  Value read from adapter status register.
+ *  @flag : indicates if the adapter enable bit was ever written once
+ *  before.
+ *  Description: Returns whether the H/W is ready to go or not. Depending
+ *  on whether adapter enable bit was written or not the comparison 
+ *  differs and the calling function passes the input argument flag to
+ *  indicate this.
+ *  Return: 1 If xena is quiescence 
+ *          0 If Xena is not quiescence
  */
+
 static int verify_xena_quiescence(u64 val64, int flag)
 {
 	int ret = 0;
@@ -1122,11 +1578,15 @@
 	return ret;
 }
 
-/* 
+/**
+ * fix_mac_address -  Fix for Mac addr problem on Alpha platforms
+ * @sp: Pointer to device specifc structure
+ * Description : 
  * New procedure to clear mac address reading  problems on Alpha platforms
  *
  */
-void FixMacAddress(nic_t * sp)
+
+void fix_mac_address(nic_t * sp)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
 	u64 val64;
@@ -1138,29 +1598,28 @@
 	}
 }
 
-/*  
- *  Input Arguments: 
- *  device private variable.
- *  Return Value: 
- *  SUCCESS on success and -1 on failure.
+/**
+ *  start_nic - Turns the device on   
+ *  @nic : device private variable.
  *  Description: 
- *  This function actually turns the device on. Before this 
- *  function is called, all Registers are configured from their reset states 
+ *  This function actually turns the device on. Before this  function is 
+ *  called,all Registers are configured from their reset states 
  *  and shared memory is allocated but the NIC is still quiescent. On 
  *  calling this function, the device interrupts are cleared and the NIC is
  *  literally switched on by writing into the adapter control register.
+ *  Return Value: 
+ *  SUCCESS on success and -1 on failure.
  */
-static int startNic(struct s2io_nic *nic)
+
+static int start_nic(struct s2io_nic *nic)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
 	struct net_device *dev = nic->dev;
 	register u64 val64 = 0;
 	u16 interruptible, i;
 	u16 subid;
-	mac_info_t *mac_control;
 	struct config_param *config;
 
-	mac_control = &nic->mac_control;
 	config = &nic->config;
 
 	/*  PRC Initialization and configuration */
@@ -1169,10 +1628,21 @@
 		       &bar0->prc_rxd0_n[i]);
 
 		val64 = readq(&bar0->prc_ctrl_n[i]);
+#ifndef CONFIG_2BUFF_MODE
 		val64 |= PRC_CTRL_RC_ENABLED;
+#else
+		val64 |= PRC_CTRL_RC_ENABLED | PRC_CTRL_RING_MODE_3;
+#endif
 		writeq(val64, &bar0->prc_ctrl_n[i]);
 	}
 
+#ifdef CONFIG_2BUFF_MODE
+	/* Enabling 2 buffer mode by writing into Rx_pa_cfg reg. */
+	val64 = readq(&bar0->rx_pa_cfg);
+	val64 |= RX_PA_CFG_IGNORE_L2_ERR;
+	writeq(val64, &bar0->rx_pa_cfg);
+#endif
+
 	/* Enabling MC-RLDRAM. After enabling the device, we timeout
 	 * for around 100ms, which is approximately the time required
 	 * for the device to be ready for operation.
@@ -1211,7 +1681,7 @@
 	/*  Enable select interrupts */
 	interruptible = TX_TRAFFIC_INTR | RX_TRAFFIC_INTR | TX_MAC_INTR |
 	    RX_MAC_INTR;
-	en_dis_able_NicIntrs(nic, interruptible, ENABLE_INTRS);
+	en_dis_able_nic_intrs(nic, interruptible, ENABLE_INTRS);
 
 	/* With some switches, link might be already up at this point.
 	 * Because of this weird behavior, when we enable laser, 
@@ -1250,15 +1720,15 @@
 	return SUCCESS;
 }
 
-/*  
- *  Input Arguments: 
- *   nic - device private variable.
- *  Return Value: 
- *   void.
+/** 
+ *  Free_tx_buffers - Free all queued Tx buffers 
+ *  @nic : device private variable.
  *  Description: 
- *   Free all queued Tx buffers.
- */
-void freeTxBuffers(struct s2io_nic *nic)
+ *  Free all queued Tx buffers.
+ *  Return Value: void 
+*/
+
+void free_tx_buffers(struct s2io_nic *nic)
 {
 	struct net_device *dev = nic->dev;
 	struct sk_buff *skb;
@@ -1267,17 +1737,54 @@
 #if DEBUG_ON
 	int cnt = 0;
 #endif
+#ifdef MAC
+    mac_info_tx_t *mac_control_tx;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
+#ifdef TXDBD
+    u16 off=0;
+    u16 block_no=0;
+#endif
 
-	mac_control = &nic->mac_control;
 	config = &nic->config;
+#ifdef MAC
+	mac_control_tx = &nic->mac_control_tx;
+#else
+	mac_control = &nic->mac_control;
+#endif
 
 	for (i = 0; i < config->TxFIFONum; i++) {
+#ifdef TXDBD
+    block_no = 0;
+#endif
 		for (j = 0; j < config->TxCfg[i].FifoLen - 1; j++) {
+#ifdef TXDBD
+#ifdef MAC
+            off = j % mac_control_tx->max_txds_per_block;
+            txdp = nic->tx_blocks[i][block_no].block_virt_addr + off;
+            if(off == mac_control_tx->max_txds_per_block){
+                j++;
+                block_no++;
+            }
+#else
+            off = j % mac_control->max_txds_per_block;
+            txdp = nic->tx_blocks[i][block_no].block_virt_addr + off;
+            if(off == mac_control->max_txds_per_block){
+                j++;
+                block_no++;
+            }
+#endif
+#else
+#ifdef MAC
+			txdp = mac_control_tx->txdl_start[i] +
+			    (config->MaxTxDs * j);
+#else
 			txdp = mac_control->txdl_start[i] +
 			    (config->MaxTxDs * j);
-
+#endif
+#endif
 			if (!(txdp->Control_1 & TXD_LIST_OWN_XENA)) {
 				/* If owned by host, ignore */
 				continue;
@@ -1302,34 +1809,49 @@
 			  "%s:forcibly freeing %d skbs on FIFO%d\n",
 			  dev->name, cnt, i);
 #endif
+#if LATEST_CHANGES
+#ifdef MAC
+#ifdef TXDBD
+                mac_control_tx->tx_curr_put_info[i].block_index = 0;
+                mac_control_tx->tx_curr_get_info[i].block_index = 0;
+#endif
+                mac_control_tx->tx_curr_put_info[i].offset = 0;
+                mac_control_tx->tx_curr_get_info[i].offset = 0;
+#else
+#ifdef TXDBD
+                mac_control->tx_curr_put_info[i].block_index = 0;
+                mac_control->tx_curr_get_info[i].block_index = 0;
+#endif
+                mac_control->tx_curr_put_info[i].offset = 0;
+                mac_control->tx_curr_get_info[i].offset = 0;
+#endif
+#endif
 	}
 }
 
-/*  
- *  Input Arguments: 
- *   nic - device private variable.
- *  Return Value: 
+/**  
+ *   stop_nic -  To stop the nic  
+ *   @nic ; device private variable.
+ *   Description: 
+ *   This function does exactly the opposite of what the start_nic() 
+ *   function does. This function is called to stop the device.
+ *   Return Value:
  *   void.
- *  Description: 
- *   This function does exactly the opposite of what the startNic() 
- *   function does. This function is called to stop 
- *   the device.
  */
-static void stopNic(struct s2io_nic *nic)
+
+static void stop_nic(struct s2io_nic *nic)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
 	register u64 val64 = 0;
 	u16 interruptible, i;
-	mac_info_t *mac_control;
 	struct config_param *config;
 
-	mac_control = &nic->mac_control;
 	config = &nic->config;
 
 /*  Disable all interrupts */
 	interruptible = TX_TRAFFIC_INTR | RX_TRAFFIC_INTR | TX_MAC_INTR |
 	    RX_MAC_INTR;
-	en_dis_able_NicIntrs(nic, interruptible, DISABLE_INTRS);
+	en_dis_able_nic_intrs(nic, interruptible, DISABLE_INTRS);
 
 /*  Disable PRCs */
 	for (i = 0; i < config->RxRingNum; i++) {
@@ -1339,11 +1861,10 @@
 	}
 }
 
-/*  
- *  Input Arguments: 
- *  device private variable
- *  Return Value: 
- *  SUCCESS on success or an appropriate -ve value on failure.
+/**  
+ *  fill_rx_buffers - Allocates the Rx side skbs 
+ *  @nic:  device private variable
+ *  @ring_no: ring number 
  *  Description: 
  *  The function allocates Rx side skbs and puts the physical
  *  address of these buffers into the RxD buffer pointers, so that the NIC
@@ -1354,9 +1875,13 @@
  *  3. Five buffer modes.
  *  Each mode defines how many fragments the received frame will be split 
  *  up into by the NIC. The frame is split into L3 header, L4 Header, 
- *  L4 payload in three buffer mode and in 5 buffer mode, L4 payload itself 
- *  is split into 3 fragments. As of now only single buffer mode is supported.
+ *  L4 payload in three buffer mode and in 5 buffer mode, L4 payload itself
+ *  is split into 3 fragments. As of now only single buffer mode is
+ *  supported.
+ *   Return Value:
+ *  SUCCESS on success or an appropriate -ve value on failure.
  */
+
 int fill_rx_buffers(struct s2io_nic *nic, int ring_no)
 {
 	struct net_device *dev = nic->dev;
@@ -1367,10 +1892,24 @@
 	u32 alloc_tab = 0;
 	u32 alloc_cnt = nic->pkt_cnt[ring_no] -
 	    atomic_read(&nic->rx_bufs_left[ring_no]);
+#ifdef MAC
+    mac_info_rx_t *mac_control_rx;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
-
+#ifdef CONFIG_2BUFF_MODE
+	RxD_t *rxdpnext;
+	int nextblk;
+	u64 tmp;
+	buffAdd_t *ba;
+	dma_addr_t rxdpphys;
+#endif
+#ifdef  MAC
+    mac_control_rx = &nic->mac_control_rx;
+#else
 	mac_control = &nic->mac_control;
+#endif
 	config = &nic->config;
 
 	if (frame_len[ring_no]) {
@@ -1384,14 +1923,28 @@
 	}
 
 	while (alloc_tab < alloc_cnt) {
+#ifdef MAC
+        block_no = mac_control_rx->rx_curr_put_info[ring_no].
+            block_index;
+        block_no1 = mac_control_rx->rx_curr_get_info[ring_no].
+            block_index;
+        off = mac_control_rx->rx_curr_put_info[ring_no].offset;
+        off1 = mac_control_rx->rx_curr_get_info[ring_no].offset;
+#else
 		block_no = mac_control->rx_curr_put_info[ring_no].
 		    block_index;
 		block_no1 = mac_control->rx_curr_get_info[ring_no].
 		    block_index;
 		off = mac_control->rx_curr_put_info[ring_no].offset;
 		off1 = mac_control->rx_curr_get_info[ring_no].offset;
+#endif
+#ifndef CONFIG_2BUFF_MODE
 		offset = block_no * (MAX_RXDS_PER_BLOCK + 1) + off;
 		offset1 = block_no1 * (MAX_RXDS_PER_BLOCK + 1) + off1;
+#else
+		offset = block_no * (MAX_RXDS_PER_BLOCK) + off;
+		offset1 = block_no1 * (MAX_RXDS_PER_BLOCK) + off1;
+#endif
 
 		rxdp = nic->rx_blocks[ring_no][block_no].
 		    block_virt_addr + off;
@@ -1400,8 +1953,20 @@
 			DBG_PRINT(INTR_DBG, " info equated\n");
 			goto end;
 		}
-
+#ifndef	CONFIG_2BUFF_MODE
 		if (rxdp->Control_1 == END_OF_BLOCK) {
+#ifdef MAC
+            mac_control_rx->rx_curr_put_info[ring_no].
+                block_index++;
+            mac_control_rx->rx_curr_put_info[ring_no].
+                block_index %= nic->block_count[ring_no];
+            block_no = mac_control_rx->rx_curr_put_info
+                [ring_no].block_index;
+            off++;
+            off %= (MAX_RXDS_PER_BLOCK + 1);
+            mac_control_rx->rx_curr_put_info[ring_no].offset =
+                off;
+#else
 			mac_control->rx_curr_put_info[ring_no].
 			    block_index++;
 			mac_control->rx_curr_put_info[ring_no].
@@ -1412,26 +1977,98 @@
 			off %= (MAX_RXDS_PER_BLOCK + 1);
 			mac_control->rx_curr_put_info[ring_no].offset =
 			    off;
+#endif
 			/*rxdp = nic->rx_blocks[ring_no][block_no].
 			   block_virt_addr + off; */
 			rxdp = (RxD_t *) ((unsigned long) rxdp->Control_2);
 			DBG_PRINT(INTR_DBG, "%s: Next block at: %p\n",
 				  dev->name, rxdp);
 		}
+#else
+		if (rxdp->Host_Control == END_OF_BLOCK) {
+#ifdef MAC
+            mac_control_rx->rx_curr_put_info[ring_no].
+                block_index++;
+            mac_control_rx->rx_curr_put_info[ring_no].
+                block_index %= nic->block_count[ring_no];
+            block_no = mac_control_rx->rx_curr_put_info
+                [ring_no].block_index;
+            off = 0;
+            DBG_PRINT(INTR_DBG, "%s: block%d at: 0x%llx\n",
+                  dev->name, block_no,
+                  (unsigned long long) rxdp->Control_1);
+            mac_control_rx->rx_curr_put_info[ring_no].offset =
+                off;
+#else
+			mac_control->rx_curr_put_info[ring_no].
+			    block_index++;
+			mac_control->rx_curr_put_info[ring_no].
+			    block_index %= nic->block_count[ring_no];
+			block_no = mac_control->rx_curr_put_info
+			    [ring_no].block_index;
+			off = 0;
+			DBG_PRINT(INTR_DBG, "%s: block%d at: 0x%llx\n",
+				  dev->name, block_no,
+				  (unsigned long long) rxdp->Control_1);
+			mac_control->rx_curr_put_info[ring_no].offset =
+			    off;
+#endif
+			rxdp = nic->rx_blocks[ring_no][block_no].
+			    block_virt_addr;
+		}
+#endif
 
+#ifndef	CONFIG_2BUFF_MODE
 		if (rxdp->Control_1 & RXD_OWN_XENA) {
+#else
+		if (rxdp->Control_2 & BIT(0)) {
+#endif
+#ifdef MAC
+            mac_control_rx->rx_curr_put_info[ring_no].
+                offset = off;
+#else
 			mac_control->rx_curr_put_info[ring_no].
 			    offset = off;
+#endif
 			goto end;
 		}
+#ifdef	CONFIG_2BUFF_MODE
+		/* RxDs Spanning chachelines will be replenished only 
+		 * if the succeeding RxD is also owned by Host. It 
+		 * will always be the ((8*i)+3) and ((8*i)+6) 
+		 * descriptors for the 48 byte descriptor. The offending 
+		 * decsriptor is of-course the 3rd descriptor.
+		 */
+		rxdpphys = nic->rx_blocks[ring_no][block_no].
+		    block_dma_addr + (off * sizeof(RxD_t));
+		if (((u64) (rxdpphys)) % 128 > 80) {
+			rxdpnext = nic->rx_blocks[ring_no][block_no].
+			    block_virt_addr + (off + 1);
+			if (rxdpnext->Host_Control == END_OF_BLOCK) {
+				nextblk = (block_no + 1) %
+				    (nic->block_count[ring_no]);
+				rxdpnext = nic->rx_blocks[ring_no]
+				    [nextblk].block_virt_addr;
+			}
+			if (rxdpnext->Control_2 & BIT(0))
+				goto end;
+		}
+#endif
 
-		skb = dev_alloc_skb(size + NET_IP_ALIGN);
+#ifndef	CONFIG_2BUFF_MODE
+		skb = dev_alloc_skb(size + HEADER_ALIGN_LAYER_3);
+#else
+		skb =
+		    dev_alloc_skb(dev->mtu + ALIGN_SIZE +
+				  /*BUF0_LEN + */ 22);
+#endif
 		if (!skb) {
 			DBG_PRINT(ERR_DBG, "%s: Out of ", dev->name);
 			DBG_PRINT(ERR_DBG, "memory to allocate SKBs\n");
 			return -ENOMEM;
 		}
-		skb_reserve(skb, NET_IP_ALIGN);
+#ifndef	CONFIG_2BUFF_MODE
+		skb_reserve(skb, HEADER_ALIGN_LAYER_3);
 		memset(rxdp, 0, sizeof(RxD_t));
 		rxdp->Buffer0_ptr = pci_map_single
 		    (nic->pdev, skb->data, size, PCI_DMA_FROMDEVICE);
@@ -1441,7 +2078,61 @@
 		rxdp->Control_1 |= RXD_OWN_XENA;
 		off++;
 		off %= (MAX_RXDS_PER_BLOCK + 1);
+#ifdef MAC
+        mac_control_rx->rx_curr_put_info[ring_no].offset = off;
+#else
+		mac_control->rx_curr_put_info[ring_no].offset = off;
+#endif
+#else
+		ba = &nic->ba[block_no][off];
+		tmp = (u64) skb->data;
+		tmp += ALIGN_SIZE;
+		tmp &= ~ALIGN_SIZE;
+		skb->data = (void *) tmp;
+
+		ba->ba_0_org = (void *)
+		    kmalloc(BUF0_LEN + ALIGN_SIZE, GFP_ATOMIC);
+		if (!ba->ba_0_org)
+			return -ENOMEM;
+		tmp = (u64) ba->ba_0_org;
+		tmp += ALIGN_SIZE;
+		tmp &= ~((u64) ALIGN_SIZE);
+		ba->ba_0 = (void *) tmp;
+
+		ba->ba_1_org = (void *)
+		    kmalloc(BUF1_LEN + ALIGN_SIZE, GFP_ATOMIC);
+		if (!ba->ba_1_org)
+			return -ENOMEM;
+		tmp = (u64) ba->ba_1_org;
+		tmp += ALIGN_SIZE;
+		tmp &= ~((u64) ALIGN_SIZE);
+		ba->ba_1 = (void *) tmp;
+
+		memset(rxdp, 0, sizeof(RxD_t));
+
+		rxdp->Buffer2_ptr = pci_map_single
+		    (nic->pdev, skb->data, dev->mtu + 22,
+		     PCI_DMA_FROMDEVICE);
+		rxdp->Buffer0_ptr =
+		    pci_map_single(nic->pdev, ba->ba_0, BUF0_LEN,
+				   PCI_DMA_FROMDEVICE);
+		rxdp->Buffer1_ptr =
+		    pci_map_single(nic->pdev, ba->ba_1, BUF1_LEN,
+				   PCI_DMA_FROMDEVICE);
+
+		rxdp->Control_2 = SET_BUFFER2_SIZE(dev->mtu + 22);
+		rxdp->Control_2 |= SET_BUFFER0_SIZE(BUF0_LEN);
+		rxdp->Control_2 |= SET_BUFFER1_SIZE(1);	/* dummy. */
+		rxdp->Control_2 |= BIT(0);	/* Set Buffer_Empty bit. */
+		rxdp->Host_Control = (u64) ((unsigned long) (skb));
+		rxdp->Control_1 |= RXD_OWN_XENA;
+		off++;
+#ifdef MAC
+        mac_control_rx->rx_curr_put_info[ring_no].offset = off;
+#else
 		mac_control->rx_curr_put_info[ring_no].offset = off;
+#endif
+#endif
 		atomic_inc(&nic->rx_bufs_left[ring_no]);
 		alloc_tab++;
 	}
@@ -1450,31 +2141,44 @@
 	return SUCCESS;
 }
 
-/*  
- *  Input Arguments: 
- *  device private variable.
- *  Return Value: 
- *  NONE.
+/**
+ *  free_rx_buffers - Frees all Rx buffers   
+ *  @sp: device private variable.
  *  Description: 
  *  This function will free all Rx buffers allocated by host.
+ *  Return Value:
+ *  NONE.
  */
-static void freeRxBuffers(struct s2io_nic *sp)
+
+static void free_rx_buffers(struct s2io_nic *sp)
 {
 	struct net_device *dev = sp->dev;
 	int i, j, blk = 0, off, buf_cnt = 0;
 	RxD_t *rxdp;
 	struct sk_buff *skb;
+#ifdef MAC
+    mac_info_rx_t *mac_control_rx;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
+#ifdef CONFIG_2BUFF_MODE
+	buffAdd_t *ba;
+#endif
 
-	mac_control = &sp->mac_control;
 	config = &sp->config;
+#ifdef MAC
+    mac_control_rx = &sp->mac_control_rx;
+#else
+	mac_control = &sp->mac_control;
+#endif
 
 	for (i = 0; i < config->RxRingNum; i++) {
 		for (j = 0, blk = 0; j < config->RxCfg[i].NumRxd; j++) {
 			off = j % (MAX_RXDS_PER_BLOCK + 1);
 			rxdp = sp->rx_blocks[i][blk].block_virt_addr + off;
 
+#ifndef CONFIG_2BUFF_MODE
 			if (rxdp->Control_1 == END_OF_BLOCK) {
 				rxdp =
 				    (RxD_t *) ((unsigned long) rxdp->
@@ -1482,11 +2186,23 @@
 				j++;
 				blk++;
 			}
+#else
+			if (rxdp->Host_Control == END_OF_BLOCK) {
+				blk++;
+				continue;
+			}
+#endif
+
+			if (!(rxdp->Control_1 & RXD_OWN_XENA)) {
+				memset(rxdp, 0, sizeof(RxD_t));
+				continue;
+			}
 
 			skb =
 			    (struct sk_buff *) ((unsigned long) rxdp->
 						Host_Control);
 			if (skb) {
+#ifndef CONFIG_2BUFF_MODE
 				pci_unmap_single(sp->pdev, (dma_addr_t)
 						 rxdp->Buffer0_ptr,
 						 dev->mtu +
@@ -1494,34 +2210,59 @@
 						 + HEADER_802_2_SIZE +
 						 HEADER_SNAP_SIZE,
 						 PCI_DMA_FROMDEVICE);
-				dev_kfree_skb(skb);
-				atomic_dec(&sp->rx_bufs_left[i]);
-				buf_cnt++;
+#else
+				ba = &sp->ba[blk][off];
+				pci_unmap_single(sp->pdev, (dma_addr_t)
+						 rxdp->Buffer0_ptr,
+						 BUF0_LEN,
+						 PCI_DMA_FROMDEVICE);
+				pci_unmap_single(sp->pdev, (dma_addr_t)
+						 rxdp->Buffer1_ptr,
+						 BUF1_LEN,
+						 PCI_DMA_FROMDEVICE);
+				pci_unmap_single(sp->pdev, (dma_addr_t)
+						 rxdp->Buffer2_ptr,
+						 dev->mtu + 22,
+						 PCI_DMA_FROMDEVICE);
+				kfree(ba->ba_0_org);
+				kfree(ba->ba_1_org);
+#endif
+				dev_kfree_skb(skb);
+				atomic_dec(&sp->rx_bufs_left[i]);
+				buf_cnt++;
 			}
 			memset(rxdp, 0, sizeof(RxD_t));
 		}
+#ifdef MAC
+        mac_control_rx->rx_curr_put_info[i].block_index = 0;
+        mac_control_rx->rx_curr_get_info[i].block_index = 0;
+        mac_control_rx->rx_curr_put_info[i].offset = 0;
+        mac_control_rx->rx_curr_get_info[i].offset = 0;
+#else
 		mac_control->rx_curr_put_info[i].block_index = 0;
 		mac_control->rx_curr_get_info[i].block_index = 0;
 		mac_control->rx_curr_put_info[i].offset = 0;
 		mac_control->rx_curr_get_info[i].offset = 0;
+#endif
 		atomic_set(&sp->rx_bufs_left[i], 0);
 		DBG_PRINT(INIT_DBG, "%s:Freed 0x%x Rx Buffers on ring%d\n",
 			  dev->name, buf_cnt, i);
 	}
 }
 
-/*
- *  Input Argument: 
- *   dev - pointer to the device structure.
- *   budget - The number of packets that were budgeted to be processed during
- *   one pass through the 'Poll" function.
- *  Return value:
- *   0 on success and 1 if there are No Rx packets to be processed.
- *  Description:
- *   Comes into picture only if NAPI support has been incorporated. It does
- *   the same thing that rxIntrHandler does, but not in a interrupt context
- *   also It will process only a given number of packets.
+/**
+ * s2io_poll - Rx interrupt handler for NAPI support
+ * @dev : pointer to the device structure.
+ * @budget : The number of packets that were budgeted to be processed 
+ * during  one pass through the 'Poll" function.
+ * Description:
+ * Comes into picture only if NAPI support has been incorporated. It does
+ * the same thing that rx_intr_handler does, but not in a interrupt context
+ * also It will process only a given number of packets.
+ * Return value:
+ * 0 on success and 1 if there are No Rx packets to be processed.
  */
+
 #ifdef CONFIG_S2IO_NAPI
 static int s2io_poll(struct net_device *dev, int *budget)
 {
@@ -1531,14 +2272,27 @@
 	register u64 val64 = 0;
 	rx_curr_get_info_t offset_info;
 	int i, block_no;
+#ifndef CONFIG_2BUFF_MODE
 	u16 val16, cksum;
+#endif
 	struct sk_buff *skb;
 	RxD_t *rxdp;
+#ifdef MAC
+    mac_info_rx_t *mac_control_rx;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
+#ifdef CONFIG_2BUFF_MODE
+	buffAdd_t *ba;
+#endif
 
-	mac_control = &nic->mac_control;
 	config = &nic->config;
+#ifdef MAC
+    mac_control_rx = &nic->mac_control_rx;
+#else
+	mac_control = &nic->mac_control;
+#endif
 
 	if (pkts_to_process > dev->quota)
 		pkts_to_process = dev->quota;
@@ -1550,10 +2304,15 @@
 		if (--pkts_to_process < 0) {
 			goto no_rx;
 		}
+#ifdef MAC
+        offset_info = mac_control_rx->rx_curr_get_info[i];
+#else
 		offset_info = mac_control->rx_curr_get_info[i];
+#endif
 		block_no = offset_info.block_index;
 		rxdp = nic->rx_blocks[i][block_no].block_virt_addr +
 		    offset_info.offset;
+#ifndef	CONFIG_2BUFF_MODE
 		while (!(rxdp->Control_1 & RXD_OWN_XENA)) {
 			if (rxdp->Control_1 == END_OF_BLOCK) {
 				rxdp =
@@ -1564,10 +2323,17 @@
 				    (MAX_RXDS_PER_BLOCK + 1);
 				block_no++;
 				block_no %= nic->block_count[i];
+#ifdef MAC
+                mac_control_rx->rx_curr_get_info[i].
+                    offset = offset_info.offset;
+                mac_control_rx->rx_curr_get_info[i].
+                    block_index = block_no;
+#else
 				mac_control->rx_curr_get_info[i].
 				    offset = offset_info.offset;
 				mac_control->rx_curr_get_info[i].
 				    block_index = block_no;
+#endif
 				continue;
 			}
 			skb =
@@ -1589,16 +2355,93 @@
 					 HEADER_802_2_SIZE +
 					 HEADER_SNAP_SIZE,
 					 PCI_DMA_FROMDEVICE);
-			rxOsmHandler(nic, val16, rxdp, i);
+			rx_osm_handler(nic, val16, rxdp, i);
 			pkt_cnt++;
 			offset_info.offset++;
 			offset_info.offset %= (MAX_RXDS_PER_BLOCK + 1);
 			rxdp =
 			    nic->rx_blocks[i][block_no].block_virt_addr +
 			    offset_info.offset;
+#ifdef MAC
+            mac_control_rx->rx_curr_get_info[i].offset =
+                offset_info.offset;
+#else
+			mac_control->rx_curr_get_info[i].offset =
+			    offset_info.offset;
+#endif
+			if ((indicate_max_pkts)
+			    && (pkt_cnt > indicate_max_pkts))
+				break;
+		}
+#else
+		while ((!(rxdp->Control_1 & RXD_OWN_XENA)) &&
+		       !(rxdp->Control_2 & BIT(0))) {
+			skb = (struct sk_buff *) ((unsigned long)
+						  rxdp->Host_Control);
+			if (skb == NULL) {
+				DBG_PRINT(ERR_DBG, "%s: The skb is ",
+					  dev->name);
+				DBG_PRINT(ERR_DBG, "Null in Rx Intr\n");
+				return;
+			}
+
+			pci_unmap_single(nic->pdev, (dma_addr_t)
+					 rxdp->Buffer0_ptr,
+					 BUF0_LEN, PCI_DMA_FROMDEVICE);
+			pci_unmap_single(nic->pdev, (dma_addr_t)
+					 rxdp->Buffer1_ptr,
+					 BUF1_LEN, PCI_DMA_FROMDEVICE);
+			pci_unmap_single(nic->pdev, (dma_addr_t)
+					 rxdp->Buffer2_ptr,
+					 dev->mtu + 22,
+					 PCI_DMA_FROMDEVICE);
+			ba = &nic->ba[block_no][offset_info.offset];
+
+			rx_osm_handler(nic, rxdp, i, ba);
+
+			offset_info.offset++;
+#ifdef MAC
+            mac_control_rx->rx_curr_get_info[i].offset =
+                offset_info.offset;
+#else
 			mac_control->rx_curr_get_info[i].offset =
 			    offset_info.offset;
+#endif
+			rxdp =
+			    nic->rx_blocks[i][block_no].block_virt_addr +
+			    offset_info.offset;
+
+			if (offset_info.offset &&
+			    (!(offset_info.offset % MAX_RXDS_PER_BLOCK))) {
+				offset_info.offset = 0;
+#ifdef MAC
+				mac_control_rx->rx_curr_get_info[i].
+				    offset = offset_info.offset;
+#else
+				mac_control->rx_curr_get_info[i].
+				    offset = offset_info.offset;
+#endif
+				block_no++;
+				block_no %= nic->block_count[i];
+#ifdef MAC
+                mac_control_rx->rx_curr_get_info[i].
+                    block_index = block_no;
+#else
+				mac_control->rx_curr_get_info[i].
+				    block_index = block_no;
+#endif
+				rxdp =
+				    nic->rx_blocks[i][block_no].
+				    block_virt_addr;
+			}
+			pkt_cnt++;
+			if ((indicate_max_pkts) &&
+			    (pkt_cnt > indicate_max_pkts))
+				break;
 		}
+#endif
+		if ((indicate_max_pkts) && (pkt_cnt > indicate_max_pkts))
+			break;
 	}
 	if (!pkt_cnt)
 		pkt_cnt = 1;
@@ -1611,7 +2454,7 @@
 	netif_rx_complete(dev);
 
 /* Re enable the Rx interrupts. */
-	en_dis_able_NicIntrs(nic, RX_TRAFFIC_INTR, ENABLE_INTRS);
+	en_dis_able_nic_intrs(nic, RX_TRAFFIC_INTR, ENABLE_INTRS);
 	return 0;
 
       no_rx:
@@ -1622,33 +2465,47 @@
 	return 1;
 }
 #else
-/*  
- *  Input Arguments: 
- *  device private variable.
- *  Return Value: 
- *  NONE.
+/**  
+ *  rx_intr_handler - Rx interrupt handler
+ *  @nic: device private variable.
  *  Description: 
- * If the interrupt is because of a received frame or if the 
- *  receive ring contains fresh as yet un-processed frames, this function is
+ *  If the interrupt is because of a received frame or if the 
+ *  receive ring contains fresh as yet un-processed frames,this function is
  *  called. It picks out the RxD at which place the last Rx processing had 
  *  stopped and sends the skb to the OSM's Rx handler and then increments 
  *  the offset.
+ *  Return Value:
+ *  NONE.
  */
-static void rxIntrHandler(struct s2io_nic *nic)
+
+static void rx_intr_handler(struct s2io_nic *nic)
 {
 	struct net_device *dev = (struct net_device *) nic->dev;
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
 	rx_curr_get_info_t offset_info;
 	RxD_t *rxdp;
 	struct sk_buff *skb;
+#ifndef CONFIG_2BUFF_MODE
 	u16 val16, cksum;
+#endif
 	register u64 val64 = 0;
-	int i, block_no;
+	int i, block_no, pkt_cnt = 0;
+#ifdef MAC
+    mac_info_rx_t *mac_control_rx;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
+#ifdef CONFIG_2BUFF_MODE
+	buffAdd_t *ba;
+#endif
 
-	mac_control = &nic->mac_control;
 	config = &nic->config;
+#ifdef MAC
+    mac_control_rx = &nic->mac_control_rx;
+#else
+	mac_control = &nic->mac_control;
+#endif
 
 #if DEBUG_ON
 	nic->rxint_cnt++;
@@ -1661,10 +2518,15 @@
 	writeq(val64, &bar0->rx_traffic_int);
 
 	for (i = 0; i < config->RxRingNum; i++) {
+#ifdef MAC
+        offset_info = mac_control_rx->rx_curr_get_info[i];
+#else
 		offset_info = mac_control->rx_curr_get_info[i];
+#endif
 		block_no = offset_info.block_index;
 		rxdp = nic->rx_blocks[i][block_no].block_virt_addr +
 		    offset_info.offset;
+#ifndef	CONFIG_2BUFF_MODE
 		while (!(rxdp->Control_1 & RXD_OWN_XENA)) {
 			if (rxdp->Control_1 == END_OF_BLOCK) {
 				rxdp = (RxD_t *) ((unsigned long)
@@ -1674,10 +2536,17 @@
 				    (MAX_RXDS_PER_BLOCK + 1);
 				block_no++;
 				block_no %= nic->block_count[i];
+#ifdef MAC
+                mac_control_rx->rx_curr_get_info[i].
+                    offset = offset_info.offset;
+                mac_control_rx->rx_curr_get_info[i].
+                    block_index = block_no;
+#else
 				mac_control->rx_curr_get_info[i].
 				    offset = offset_info.offset;
 				mac_control->rx_curr_get_info[i].
 				    block_index = block_no;
+#endif
 				continue;
 			}
 			skb = (struct sk_buff *) ((unsigned long)
@@ -1698,31 +2567,109 @@
 					 HEADER_802_2_SIZE +
 					 HEADER_SNAP_SIZE,
 					 PCI_DMA_FROMDEVICE);
-			rxOsmHandler(nic, val16, rxdp, i);
+			rx_osm_handler(nic, val16, rxdp, i);
 			offset_info.offset++;
 			offset_info.offset %= (MAX_RXDS_PER_BLOCK + 1);
 			rxdp =
 			    nic->rx_blocks[i][block_no].block_virt_addr +
 			    offset_info.offset;
+#ifdef MAC
+            mac_control_rx->rx_curr_get_info[i].offset =
+                offset_info.offset;
+#else
+			mac_control->rx_curr_get_info[i].offset =
+			    offset_info.offset;
+#endif
+			pkt_cnt++;
+			if ((indicate_max_pkts)
+			    && (pkt_cnt > indicate_max_pkts))
+				break;
+		}
+#else
+		while ((!(rxdp->Control_1 & RXD_OWN_XENA)) &&
+		       !(rxdp->Control_2 & BIT(0))) {
+			skb = (struct sk_buff *) ((unsigned long)
+						  rxdp->Host_Control);
+			if (skb == NULL) {
+				DBG_PRINT(ERR_DBG, "%s: The skb is ",
+					  dev->name);
+				DBG_PRINT(ERR_DBG, "Null in Rx Intr\n");
+				return;
+			}
+
+			pci_unmap_single(nic->pdev, (dma_addr_t)
+					 rxdp->Buffer0_ptr,
+					 BUF0_LEN, PCI_DMA_FROMDEVICE);
+			pci_unmap_single(nic->pdev, (dma_addr_t)
+					 rxdp->Buffer1_ptr,
+					 BUF1_LEN, PCI_DMA_FROMDEVICE);
+			pci_unmap_single(nic->pdev, (dma_addr_t)
+					 rxdp->Buffer2_ptr,
+					 dev->mtu + 22,
+					 PCI_DMA_FROMDEVICE);
+			ba = &nic->ba[block_no][offset_info.offset];
+
+			rx_osm_handler(nic, rxdp, i, ba);
+
+			offset_info.offset++;
+#ifdef MAC
+            mac_control->rx_curr_get_info[i].offset =
+                offset_info.offset;
+#else
 			mac_control->rx_curr_get_info[i].offset =
 			    offset_info.offset;
+#endif
+			rxdp =
+			    nic->rx_blocks[i][block_no].block_virt_addr +
+			    offset_info.offset;
+
+			if (offset_info.offset &&
+			    (!(offset_info.offset % MAX_RXDS_PER_BLOCK))) {
+				offset_info.offset = 0;
+#ifdef MAC
+                mac_control_rx->rx_curr_get_info[i].
+                    offset = offset_info.offset;
+#else
+				mac_control->rx_curr_get_info[i].
+				    offset = offset_info.offset;
+#endif
+				block_no++;
+				block_no %= nic->block_count[i];
+#ifdef MAC
+                mac_control_rx->rx_curr_get_info[i].
+                    block_index = block_no;
+#else
+				mac_control->rx_curr_get_info[i].
+				    block_index = block_no;
+#endif
+				rxdp =
+				    nic->rx_blocks[i][block_no].
+				    block_virt_addr;
+			}
+			pkt_cnt++;
+			if ((indicate_max_pkts)
+			    && (pkt_cnt > indicate_max_pkts))
+				break;
 		}
+#endif
+		if ((indicate_max_pkts) && (pkt_cnt > indicate_max_pkts))
+			break;
 	}
 }
 #endif
-
-/*  
- *  Input Arguments: 
- *  device private variable
- *  Return Value: 
- *  NONE
+/**  
+ *  tx_intr_handler - Transmit interrupt handler
+ *  @nic : device private variable
  *  Description: 
  *  If an interrupt was raised to indicate DMA complete of the 
- *  Tx packet, this function is called. It identifies the last TxD whose buffer
- *  was freed and frees all skbs whose data have already DMA'ed into the NICs
- *  internal memory.
+ *  Tx packet, this function is called. It identifies the last TxD 
+ *  whose buffer was freed and frees all skbs whose data have already 
+ *  DMA'ed into the NICs internal memory.
+ *  Return Value:
+ *  NONE
  */
-static void txIntrHandler(struct s2io_nic *nic)
+
+static void tx_intr_handler(struct s2io_nic *nic)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
 	struct net_device *dev = (struct net_device *) nic->dev;
@@ -1732,15 +2679,28 @@
 	register u64 val64 = 0;
 	int i;
 	u16 j, frg_cnt;
+#ifdef MAC
+    mac_info_tx_t *mac_control_tx;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
 #if DEBUG_ON
 	int cnt = 0;
 	nic->txint_cnt++;
 #endif
+#ifdef TXDBD
+    u16 off = 0, off1 = 0;
+    u16 offset = 0, offset1 = 0;
+    u16 block_no = 0, block_no1 = 0;
+#endif
 
-	mac_control = &nic->mac_control;
 	config = &nic->config;
+#ifdef MAC
+    mac_control_tx = &nic->mac_control_tx;
+#else
+	mac_control = &nic->mac_control;
+#endif
 
 	/* tx_traffic_int reg is an R1 register, hence we read and write 
 	 * back the samevalue in the register to clear it.
@@ -1749,6 +2709,53 @@
 	writeq(val64, &bar0->tx_traffic_int);
 
 	for (i = 0; i < config->TxFIFONum; i++) {
+#ifdef TXDBD
+#ifdef MAC
+        offset_info = mac_control_tx->tx_curr_get_info[i];
+        offset_info1 = mac_control_tx->tx_curr_put_info[i];
+
+        off = offset_info.offset;
+        off1 = offset_info1.offset;
+
+        block_no = mac_control_tx->tx_curr_get_info[i].block_index;
+        block_no1 = mac_control_tx->tx_curr_put_info[i].block_index;
+
+        offset = block_no * (mac_control_tx->max_txds_per_block) + off ;
+        offset1 = block_no1 * (mac_control_tx->max_txds_per_block) + off1;
+
+        txdlp = nic->tx_blocks[i][block_no].block_virt_addr + off;
+        while ((!(txdlp->Control_1 & TXD_LIST_OWN_XENA)) &&
+               (offset != offset1) &&
+               (txdlp->Host_Control)) {
+#else
+        offset_info = mac_control->tx_curr_get_info[i];
+        offset_info1 = mac_control->tx_curr_put_info[i];
+
+        off = offset_info.offset;
+        off1 = offset_info1.offset;
+
+        block_no = mac_control->tx_curr_get_info[i].block_index;
+        block_no1 = mac_control->tx_curr_put_info[i].block_index;
+
+        offset = block_no * (mac_control->max_txds_per_block) + off ;
+        offset1 = block_no1 * (mac_control->max_txds_per_block) + off1;
+
+        txdlp = nic->tx_blocks[i][block_no].block_virt_addr + off;
+        while ((!(txdlp->Control_1 & TXD_LIST_OWN_XENA)) &&
+               (offset != offset1) &&
+               (txdlp->Host_Control)) {
+#endif
+#else
+#ifdef MAC
+       offset_info = mac_control_tx->tx_curr_get_info[i];
+        offset_info1 = mac_control_tx->tx_curr_put_info[i];
+        txdlp = mac_control_tx->txdl_start[i] +
+            (config->MaxTxDs * offset_info.offset);
+        while ((!(txdlp->Control_1 & TXD_LIST_OWN_XENA)) &&
+               (offset_info.offset != offset_info1.offset) &&
+               (txdlp->Host_Control)) {
+
+#else
 		offset_info = mac_control->tx_curr_get_info[i];
 		offset_info1 = mac_control->tx_curr_put_info[i];
 		txdlp = mac_control->txdl_start[i] +
@@ -1756,6 +2763,8 @@
 		while ((!(txdlp->Control_1 & TXD_LIST_OWN_XENA)) &&
 		       (offset_info.offset != offset_info1.offset) &&
 		       (txdlp->Host_Control)) {
+#endif
+#endif
 			/* Check for TxD errors */
 			if (txdlp->Control_1 & TXD_T_CODE) {
 				unsigned long long err;
@@ -1807,13 +2816,59 @@
 			cnt++;
 #endif
 			dev_kfree_skb_irq(skb);
+#ifdef TXDBD
+#ifdef MAC
+            offset_info.offset += config->MaxTxDs;
+            if( offset_info.offset == mac_control_tx->max_txds_per_block)
+            //if( offset_info.offset == MAX_TXDS_PER_BLOCK)
+             {
+                     mac_control_tx->tx_curr_get_info[i].block_index++;
+                     mac_control_tx->tx_curr_get_info[i].block_index %=
+                                             nic->tx_block_count[i];
+                     offset_info.offset= 0;
+                     block_no = mac_control_tx->tx_curr_get_info[i].block_index;
+             }
+             mac_control_tx->tx_curr_get_info[i].offset =
+                                   offset_info.offset;
+             offset = block_no * (mac_control_tx->max_txds_per_block)
+			 + offset_info.offset ;
+	     txdlp = nic->tx_blocks[i][block_no].block_virt_addr
+                                     +  offset_info.offset;
+#else
+            offset_info.offset += config->MaxTxDs;
+            if( offset_info.offset == mac_control->max_txds_per_block)
+            //if( offset_info.offset == MAX_TXDS_PER_BLOCK)
+             {
+                     mac_control->tx_curr_get_info[i].block_index++;
+                     mac_control->tx_curr_get_info[i].block_index %=
+                                             nic->tx_block_count[i];
+                     offset_info.offset= 0;
+                     block_no = mac_control->tx_curr_get_info[i].block_index;
+             }
+             mac_control->tx_curr_get_info[i].offset =
+                                   offset_info.offset;
+
+             offset = block_no * (mac_control->max_txds_per_block)
+			 + offset_info.offset ;
+             txdlp = nic->tx_blocks[i][block_no].block_virt_addr
+                                     +  offset_info.offset;
+#endif 
+#else
 
 			offset_info.offset++;
 			offset_info.offset %= offset_info.fifo_len + 1;
+#ifdef MAC
+            txdlp = mac_control_tx->txdl_start[i] +
+                (config->MaxTxDs * offset_info.offset);
+            mac_control_tx->tx_curr_get_info[i].offset =
+                offset_info.offset;
+#else
 			txdlp = mac_control->txdl_start[i] +
 			    (config->MaxTxDs * offset_info.offset);
 			mac_control->tx_curr_get_info[i].offset =
 			    offset_info.offset;
+#endif
+#endif
 		}
 #if DEBUG_ON
 		DBG_PRINT(INTR_DBG, "%s: freed %d Tx Pkts\n", dev->name,
@@ -1827,55 +2882,82 @@
 	spin_unlock(&nic->tx_lock);
 }
 
-/*  
- *  Input Arguments: 
- *  device private variable
- *  Return Value: 
+/**  
+ *  alarm_intr_handler - Alarm Interrrupt handler
+ *  @nic: device private variable
+ *  Description: If the interrupt was neither because of Rx packet or Tx 
+ *  complete, this function is called. If the interrupt was to indicate
+ *  a loss of link, the OSM link status handler is invoked for any other 
+ *  alarm interrupt the block that raised the interrupt is displayed 
+ *  and a H/W reset is issued.
+ *  Return Value:
  *  NONE
- *  Description: 
- *  If the interrupt was neither because of Rx packet or Tx 
- *  complete, this function is called. If the interrupt was to indicate a loss
- *  of link, the OSM link status handler is invoked for any other alarm 
- *  interrupt the block that raised the interrupt is displayed and a H/W reset 
- *  is issued.
- */
-static void alarmIntrHandler(struct s2io_nic *nic)
+*/
+
+static void alarm_intr_handler(struct s2io_nic *nic)
 {
 	struct net_device *dev = (struct net_device *) nic->dev;
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
 	register u64 val64 = 0, err_reg = 0;
 
-
 	/* Handling link status change error Intr */
 	err_reg = readq(&bar0->mac_rmac_err_reg);
+	writeq(err_reg, &bar0->mac_rmac_err_reg);
 	if (err_reg & RMAC_LINK_STATE_CHANGE_INT) {
+#ifdef INIT_TQUEUE
+		schedule_task(&nic->set_link_task);
+#else
 		schedule_work(&nic->set_link_task);
+#endif
 	}
 
-	/* Handling SERR errors by stopping device Xmit queue and forcing 
-	 * a H/W reset.
-	 */
+	/* In case of a serious error, the device will be Reset. */
 	val64 = readq(&bar0->serr_source);
 	if (val64 & SERR_SOURCE_ANY) {
 		DBG_PRINT(ERR_DBG, "%s: Device indicates ", dev->name);
 		DBG_PRINT(ERR_DBG, "serious error!!\n");
-		netif_stop_queue(dev);
+#ifdef INIT_TQUEUE
+		schedule_task(&nic->rst_timer_task);
+#else
+		schedule_work(&nic->rst_timer_task);
+#endif
+	}
+
+	/*
+	 * Also as mentioned in the latest Errata sheets if the PCC_FB_ECC
+	 * Error occurs, the adapter will be recycled by disabling the
+	 * adapter enable bit and enabling it again after the device 
+	 * becomes Quiescent.
+	 */
+	val64 = readq(&bar0->pcc_err_reg);
+	writeq(val64, &bar0->pcc_err_reg);
+	if (val64 & PCC_FB_ECC_DB_ERR) {
+		u64 ac = readq(&bar0->adapter_control);
+		ac &= ~(ADAPTER_CNTL_EN);
+		writeq(ac, &bar0->adapter_control);
+		ac = readq(&bar0->adapter_control);
+#ifdef INIT_TQUEUE
+		schedule_task(&nic->set_link_task);
+#else
+		schedule_work(&nic->set_link_task);
+#endif
 	}
+
 /* Other type of interrupts are not being handled now,  TODO*/
 }
 
-/*
- *  Input Argument: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
+/** 
+ *  waitFor Cmd Complete - waits for a command to complete.
+ *  @sp : private member of the device structure, which is a pointer to the 
+ *  s2io_nic structure.
+ *  Description: Function that waits for a command to Write into RMAC 
+ *  ADDR DATA registers to be completed and returns either success or 
+ *  error depending on whether the command was complete or not. 
  *  Return value:
  *   SUCCESS on success and FAILURE on failure.
- *  Description:
- *   Function that waits for a command to Write into RMAC ADDR DATA registers 
- *   to be completed and returns either success or error depending on whether 
- *   the command was complete or not. 
  */
-int waitForCmdComplete(nic_t * sp)
+
+int wait_for_cmd_complete(nic_t * sp)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
 	int ret = FAILURE, cnt = 0;
@@ -1900,17 +2982,16 @@
 	return ret;
 }
 
-/*
- *  Input Argument: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
+/** 
+ *  s2io_reset - Resets the card. 
+ *  @sp : private member of the device structure.
+ *  Description: Function to Reset the card. This function then also
+ *  restores the previously saved PCI configuration space registers as 
+ *  the card reset also resets the Configration space.
  *  Return value:
- *   void.
- *  Description:
- *   Function to Reset the card. This function then also restores the previously
- *   saved PCI configuration space registers as the card reset also resets the
- *   Configration space.
+ *  void.
  */
+
 void s2io_reset(nic_t * sp)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
@@ -1954,16 +3035,16 @@
 	sp->device_enabled_once = FALSE;
 }
 
-/*
- *  Input Argument: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
+/**
+ *  s2io_set_swapper - to set the swapper controle on the card 
+ *  @sp : private member of the device structure, 
+ *  pointer to the s2io_nic structure.
+ *  Description: Function to set the swapper control on the card 
+ *  correctly depending on the 'endianness' of the system.
  *  Return value:
  *  SUCCESS on success and FAILURE on failure.
- *  Description:
- * Function to set the swapper control on the card correctly depending on the
- * 'endianness' of the system.
  */
+
 int s2io_set_swapper(nic_t * sp)
 {
 	struct net_device *dev = sp->dev;
@@ -2041,31 +3122,37 @@
  * Functions defined below concern the OS part of the driver *
  * ********************************************************* */
 
-/*
- *  Input Argument: 
- *  dev - pointer to the device structure.
- *  Return value:
- *  '0' on success and an appropriate (-)ve integer as defined in errno.h
- *   file on failure.
+/**  
+ *  s2io-open - open entry point of the driver
+ *  @dev : pointer to the device structure.
  *  Description:
  *  This function is the open entry point of the driver. It mainly calls a
  *  function to allocate Rx buffers and inserts them into the buffer
  *  descriptors and then enables the Rx part of the NIC. 
- */
+ *  Return value:
+ *  '0' on success and an appropriate (-)ve integer as defined in errno.h
+ *   file on failure.
+*/
+
 int s2io_open(struct net_device *dev)
 {
 	nic_t *sp = dev->priv;
 	int i, ret = 0, err = 0;
-	mac_info_t *mac_control;
 	struct config_param *config;
-
+#ifdef TXDBD
+#ifdef MAC
+	mac_info_tx_t *mac_control_tx;
+#else
+	mac_info_t *mac_control;
+#endif
+#endif
 
 /* Make sure you have link off by default every time Nic is initialized*/
 	netif_carrier_off(dev);
 	sp->last_link_state = LINK_DOWN;
 
 /*  Initialize the H/W I/O registers */
-	if (initNic(sp) != 0) {
+	if (init_nic(sp) != 0) {
 		DBG_PRINT(ERR_DBG, "%s: H/W initialization failed\n",
 			  dev->name);
 		return -ENODEV;
@@ -2087,22 +3174,41 @@
 	}
 
 
+	config = &sp->config;
+
+/* Initialise tx pointers */
+#ifdef TXDBD
+#ifdef MAC
+	mac_control_tx = &sp->mac_control_tx;
+	for (i = 0; i < config->TxFIFONum; i++) {
+	    mac_control_tx->tx_curr_put_info[i].block_index = 0;
+	    mac_control_tx->tx_curr_put_info[i].offset = 0;
+	    mac_control_tx->tx_curr_get_info[i].block_index = 0;
+	    mac_control_tx->tx_curr_get_info[i].offset = 0;
+	}
+#else
+	mac_control = &sp->mac_control;
+	for (i = 0; i < config->TxFIFONum; i++) {
+	    mac_control->tx_curr_put_info[i].block_index = 0;
+	    mac_control->tx_curr_put_info[i].offset = 0;
+	    mac_control->tx_curr_get_info[i].block_index = 0;
+	    mac_control->tx_curr_get_info[i].offset = 0;
+	}
+#endif
+#endif
 /*  Setting its receive mode */
 	s2io_set_multicast(dev);
 
 /*  Initializing the Rx buffers. For now we are considering only 1 Rx ring
  * and initializing buffers into 1016 RxDs or 8 Rx blocks
  */
-	mac_control = &sp->mac_control;
-	config = &sp->config;
-
 	for (i = 0; i < config->RxRingNum; i++) {
 		if ((ret = fill_rx_buffers(sp, i))) {
 			DBG_PRINT(ERR_DBG, "%s: Out of memory in Open\n",
 				  dev->name);
 			s2io_reset(sp);
 			free_irq(dev->irq, dev);
-			freeRxBuffers(sp);
+			free_rx_buffers(sp);
 			return -ENOMEM;
 		}
 		DBG_PRINT(INFO_DBG, "Buf in ring:%d is %d:\n", i,
@@ -2113,12 +3219,12 @@
 	tasklet_init(&sp->task, s2io_tasklet, (unsigned long) dev);
 
 /*  Enable Rx Traffic and interrupts on the NIC */
-	if (startNic(sp)) {
+	if (start_nic(sp)) {
 		DBG_PRINT(ERR_DBG, "%s: Starting NIC failed\n", dev->name);
 		tasklet_kill(&sp->task);
 		s2io_reset(sp);
 		free_irq(dev->irq, dev);
-		freeRxBuffers(sp);
+		free_rx_buffers(sp);
 		return -ENODEV;
 	}
 
@@ -2128,32 +3234,40 @@
 	return 0;
 }
 
-/*
- *  Input Argument/s: 
- *  dev - device pointer.
- *  Return value:
- *  '0' on success and an appropriate (-)ve integer as defined in errno.h
- *  file on failure.
+/**
+ *  s2io_close -close entry point of the driver
+ *  @dev : device pointer.
  *  Description:
  *  This is the stop entry point of the driver. It needs to undo exactly
- *  whatever was done by the open entry point, thus it's usually referred to
- *  as the close function. Among other things this function mainly stops the
+ *  whatever was done by the open entry point,thus it's usually referred to
+ *  as the close function.Among other things this function mainly stops the
  *  Rx side of the NIC and frees all the Rx buffers in the Rx rings.
- */
+ *  Return value:
+ *  '0' on success and an appropriate (-)ve integer as defined in errno.h
+ *  file on failure.
+*/
+
 int s2io_close(struct net_device *dev)
 {
 	nic_t *sp = dev->priv;
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
 	register u64 val64 = 0;
 	u16 cnt = 0;
+	unsigned long flags;
 
-	spin_lock(&sp->isr_lock);
+#if (!LATEST_CHANGES)
+	spin_lock_irqsave(&sp->isr_lock, flags);
+#endif
+#if LATEST_CHANGES
+	spin_lock_irqsave(&sp->tx_lock, flags);
+#endif
 	netif_stop_queue(dev);
 
 /* disable Tx and Rx traffic on the NIC */
-	stopNic(sp);
-
-	spin_unlock(&sp->isr_lock);
+	stop_nic(sp);
+#if (!LATEST_CHANGES)
+	spin_unlock_irqrestore(&sp->isr_lock, flags);
+#endif
 
 /* If the device tasklet is running, wait till its done before killing it */
 	while (atomic_read(&(sp->tasklet_status))) {
@@ -2162,14 +3276,33 @@
 	}
 	tasklet_kill(&sp->task);
 
-/* Check if the device is Quiescent and then Reset the NIC */
-	do {
-		val64 = readq(&bar0->adapter_status);
-		if (verify_xena_quiescence(val64, sp->device_enabled_once)) {
-			break;
-		}
+	/*  Free the Registered IRQ */
+	free_irq(dev->irq, dev);
 
-		set_current_state(TASK_UNINTERRUPTIBLE);
+	/* Flush all scheduled tasks */
+#if LATEST_CHANGES
+	if (sp->task_flag == 1) {
+		DBG_PRINT(INFO_DBG,"%s: Calling close from task\n",
+			dev->name);
+	} else {
+#endif
+#ifdef INIT_TQUEUE
+		flush_scheduled_tasks();
+#else
+		flush_scheduled_work();
+#endif
+#if LATEST_CHANGES
+	}
+#endif
+
+/* Check if the device is Quiescent and then Reset the NIC */
+	do {
+		val64 = readq(&bar0->adapter_status);
+		if (verify_xena_quiescence(val64, sp->device_enabled_once)) {
+			break;
+		}
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(HZ / 20);
 		cnt++;
 		if (cnt == 10) {
@@ -2182,36 +3315,37 @@
 	} while (1);
 	s2io_reset(sp);
 
-/*  Free the Registered IRQ */
-	free_irq(dev->irq, dev);
-
 /* Free all Tx Buffers waiting for transmission */
-	freeTxBuffers(sp);
+	free_tx_buffers(sp);
 
 /*  Free all Rx buffers allocated by host */
-	freeRxBuffers(sp);
+	free_rx_buffers(sp);
 
 	sp->device_close_flag = TRUE;	/* Device is shut down. */
-
+#if LATEST_CHANGES
+	spin_unlock_irqrestore(&sp->tx_lock, flags);
+#endif
 	return 0;
 }
 
-/*
- *  Input Argument/s: 
- *  skb - the socket buffer containing the Tx data.
- *  dev - device pointer.
- *  Return value:
- *  '0' on success & 1 on failure. 
- *  NOTE: when device cant queue the pkt, just the trans_start variable will
- *  not be upadted.
- *  Description:
+/**
+ *  s2io_xmit - Tx entry point of te driver
+ *  @skb : the socket buffer containing the Tx data.
+ *  @dev : device pointer.
+ *  Description :
  *  This function is the Tx entry point of the driver. S2IO NIC supports
  *  certain protocol assist features on Tx side, namely  CSO, S/G, LSO.
- */
+ *  NOTE: when device cant queue the pkt,just the trans_start variable will
+ *  not be upadted.
+ *  Return value:
+ *  '0' on success & 1 on failure.
+*/
+
 int s2io_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	nic_t *sp = dev->priv;
-	u16 off, txd_len, frg_cnt, frg_len, i, queue, off1, queue_len;
+	u16 off, txd_len, frg_cnt, frg_len, i, queue, off1;
+	u16  queue_len;
 	register u64 val64;
 	TxD_t *txdp;
 	TxFIFO_element_t *tx_fifo;
@@ -2219,29 +3353,99 @@
 #ifdef NETIF_F_TSO
 	int mss;
 #endif
+#ifdef TXDBD
+    u32 offset = 0;
+    u32 offset1 = 0;
+    u16 block_no = 0;
+    u16 block_no1 = 0;
+
+#endif
+#ifdef MAC
+    mac_info_tx_t *mac_control_tx;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
+	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
 
-	mac_control = &sp->mac_control;
 	config = &sp->config;
+#ifdef MAC
+    mac_control_tx = &sp->mac_control_tx;
+#else
+	mac_control = &sp->mac_control;
+#endif
 
 	DBG_PRINT(TX_DBG, "%s: In S2IO Tx routine\n", dev->name);
 
 	spin_lock_irqsave(&sp->tx_lock, flags);
+
+#if LATEST_CHANGES
+	if (netif_queue_stopped(dev)) {
+		DBG_PRINT(ERR_DBG, "%s:s2io_xmit: Xmit queue stopped\n",
+				dev->name);
+		dev_kfree_skb(skb);
+		spin_unlock_irqrestore(&sp->tx_lock, flags);
+		return 0;
+	}
+#endif
 	queue = 0;
 	/* Multi FIFO Tx is disabled for now. */
 	if (!queue && tx_prio) {
 		u8 x = (skb->data)[5];
 		queue = x % config->TxFIFONum;
 	}
+#ifdef TXDBD
+#ifdef MAC
+        off = (u16) mac_control_tx->tx_curr_put_info[queue].offset;
+        off1 = (u16) mac_control_tx->tx_curr_get_info[queue].offset;
+        txd_len = mac_control_tx->txdl_len;
+
+        block_no = mac_control_tx->tx_curr_put_info[queue].block_index;
+        block_no1 = mac_control_tx->tx_curr_get_info[queue].block_index;
+
+        offset = block_no * (mac_control_tx->max_txds_per_block) + off ;
+        offset1 = block_no1 * (mac_control_tx->max_txds_per_block) + off1;
+	queue_len = mac_control_tx->tx_curr_put_info[queue].fifo_len + 1;
+#else
+        off = (u16) mac_control->tx_curr_put_info[queue].offset;
+        off1 = (u16) mac_control->tx_curr_get_info[queue].offset;
+        txd_len = mac_control->txdl_len;
+
+        block_no = mac_control->tx_curr_put_info[queue].block_index;
+        block_no1 = mac_control->tx_curr_get_info[queue].block_index;
+
+        offset = block_no * (mac_control->max_txds_per_block) + off ;
+        offset1 = block_no1 * (mac_control->max_txds_per_block) + off1;
+	queue_len = mac_control->tx_curr_put_info[queue].fifo_len + 1;
+#endif
+        txdp = sp->tx_blocks[queue][block_no].block_virt_addr + off;
+        if((txdp->Host_Control) && 
+		//(((offset + config->MaxTxDs) % queue_len) == offset1))
+		(offset == offset1))
+        {
+            DBG_PRINT(ERR_DBG, "Error in xmit, No free TXDs.\n");
+                netif_stop_queue(dev);
+            dev_kfree_skb(skb);
+            spin_unlock_irqrestore(&sp->tx_lock, flags);
+        return 0;
+        }
+#else
+#ifdef MAC
+    off = (u16) mac_control_tx->tx_curr_put_info[queue].offset;
+    off1 = (u16) mac_control_tx->tx_curr_get_info[queue].offset;
+    txd_len = mac_control_tx->txdl_len;
+    txdp = mac_control_tx->txdl_start[queue] + (config->MaxTxDs * off);
 
+    queue_len = mac_control_tx->tx_curr_put_info[queue].fifo_len + 1;
 
+#else
 	off = (u16) mac_control->tx_curr_put_info[queue].offset;
 	off1 = (u16) mac_control->tx_curr_get_info[queue].offset;
 	txd_len = mac_control->txdl_len;
 	txdp = mac_control->txdl_start[queue] + (config->MaxTxDs * off);
 
 	queue_len = mac_control->tx_curr_put_info[queue].fifo_len + 1;
+#endif
 	/* Avoid "put" pointer going beyond "get" pointer */
 	if (txdp->Host_Control || (((off + 1) % queue_len) == off1)) {
 		DBG_PRINT(ERR_DBG, "Error in xmit, No free TXDs.\n");
@@ -2250,7 +3454,7 @@
 		spin_unlock_irqrestore(&sp->tx_lock, flags);
 		return 0;
 	}
-
+#endif
 #ifdef NETIF_F_TSO
 	mss = skb_shinfo(skb)->tso_size;
 	if (mss) {
@@ -2287,10 +3491,27 @@
 		txdp->Control_1 |= TXD_BUFFER0_SIZE(frag->size);
 	}
 	txdp->Control_1 |= TXD_GATHER_CODE_LAST;
-
+#ifdef TXDBD
+#ifdef MAC
+    tx_fifo = mac_control_tx->tx_FIFO_start[queue];
+    val64 = sp->tx_blocks[queue][block_no].block_dma_addr +
+                           (sizeof(TxD_t) * off);
+#else
+    tx_fifo = mac_control->tx_FIFO_start[queue];
+    val64 = sp->tx_blocks[queue][block_no].block_dma_addr +
+                           (sizeof(TxD_t) * off);
+#endif
+#else
+#ifdef MAC
+	tx_fifo = mac_control_tx->tx_FIFO_start[queue];
+	val64 = (mac_control_tx->txdl_start_phy[queue] +
+		 (sizeof(TxD_t) * txd_len * off));
+#else
 	tx_fifo = mac_control->tx_FIFO_start[queue];
 	val64 = (mac_control->txdl_start_phy[queue] +
 		 (sizeof(TxD_t) * txd_len * off));
+#endif
+#endif
 	writeq(val64, &tx_fifo->TxDL_Pointer);
 
 	val64 = (TX_FIFO_LAST_TXD_NUM(frg_cnt) | TX_FIFO_FIRST_LIST |
@@ -2299,55 +3520,101 @@
 	if (mss)
 		val64 |= TX_FIFO_SPECIAL_FUNC;
 #endif
+	/*
+	 * according to the XENA spec:
+	 *
+	 * It is important to note that pointers and list control words are
+	 * always written in pairs: in the first write, the host must write a
+	 * pointer, and in the second write, it must write the list control
+	 * word. Any other access will result in an error. Also, all 16 bytes
+	 * of the pointer/control structure must be written, including any
+	 * reserved bytes.
+	 */
+	wmb();
 	writeq(val64, &tx_fifo->List_Control);
 
+	/* Perform a PCI read to flush previous writes */
+	val64 = readq(&bar0->general_int_status);
+#ifdef TXDBD
+     off += config->MaxTxDs;
+#ifdef MAC
+     if(off == mac_control_tx->max_txds_per_block)
+       {
+               mac_control_tx->tx_curr_put_info[queue].block_index ++;
+               mac_control_tx->tx_curr_put_info[queue].block_index %=
+                   sp->tx_block_count[queue];
+               off = 0;
+       }
+       mac_control_tx->tx_curr_put_info[queue].offset = off;
+#else
+     if(off == mac_control->max_txds_per_block)
+       {
+               mac_control->tx_curr_put_info[queue].block_index ++;
+               mac_control->tx_curr_put_info[queue].block_index %=
+                   sp->tx_block_count[queue];
+               off = 0;
+       }
+       mac_control->tx_curr_put_info[queue].offset = off;
+#endif
+/*    if (offset + 1 == offset1) {
+        DBG_PRINT(TX_DBG,
+          "No free TxDs for xmit, Put: 0x%x Get:0x%x\n",
+          offset, offset1);
+        netif_stop_queue(dev);
+    }
+*/
+
+#else
 	off++;
+#ifdef MAC
+	off %= mac_control_tx->tx_curr_put_info[queue].fifo_len + 1;
+	mac_control_tx->tx_curr_put_info[queue].offset = off;
+#else
 	off %= mac_control->tx_curr_put_info[queue].fifo_len + 1;
 	mac_control->tx_curr_put_info[queue].offset = off;
-
+#endif
 	/* Avoid "put" pointer going beyond "get" pointer */
 	if (((off + 1) % queue_len) == off1) {
-		DBG_PRINT(TX_DBG, 
-		  "No free TxDs for xmit, Put: 0x%x Get:0x%x\n",
-		  off, off1);
+		DBG_PRINT(TX_DBG,
+			  "No free TxDs for xmit, Put: 0x%x Get:0x%x\n",
+			  off, off1);
 		netif_stop_queue(dev);
 	}
-
+#endif
 	dev->trans_start = jiffies;
 	spin_unlock_irqrestore(&sp->tx_lock, flags);
 
 	return 0;
 }
 
-/*
- *  Input Argument/s: 
- *  irq: the irq of the device.
- *  dev_id: a void pointer to the dev structure of the NIC.
- *  ptregs: pointer to the registers pushed on the stack.
+/**
+ *  s2io_isr - ISR handler of the device .
+ *  @irq: the irq of the device.
+ *  @dev_id: a void pointer to the dev structure of the NIC.
+ *  @ptregs: pointer to the registers pushed on the stack.
+ *  Description:  This function is the ISR handler of the device. It 
+ *  identifies the reason for the interrupt and calls the relevant 
+ *  service routines. As a contongency measure, this ISR allocates the 
+ *  recv buffers, if their numbers are below the panic value which is
+ *  presently set to 25% of the original number of rcv buffers allocated.
  *  Return value:
  *  void.
- *  Description:
- *  This function is the ISR handler of the device. It identifies the reason 
- *  for the interrupt and calls the relevant service routines.
- *  As a contongency measure, this ISR allocates the recv buffers, if their 
- *  numbers are below the panic value which is presently set to 25% of the
- *  original number of rcv buffers allocated.
- */
+*/
 
 static irqreturn_t s2io_isr(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct net_device *dev = (struct net_device *) dev_id;
 	nic_t *sp = dev->priv;
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
+	int i, ret;
 	u64 reason = 0, general_mask = 0;
-	mac_info_t *mac_control;
 	struct config_param *config;
 
-	mac_control = &sp->mac_control;
 	config = &sp->config;
 
+#if (!LATEST_CHANGES)
 	spin_lock(&sp->isr_lock);
-
+#endif
 	/* Identify the cause for interrupt and call the appropriate
 	 * interrupt handler. Causes for the interrupt could be;
 	 * 1. Rx of packet.
@@ -2359,7 +3626,9 @@
 
 	if (!reason) {
 		/* The interrupt was not raised by Xena. */
+#if (!LATEST_CHANGES)
 		spin_unlock(&sp->isr_lock);
+#endif
 		return IRQ_NONE;
 	}
 	/* Mask the interrupts on the NIC */
@@ -2372,29 +3641,29 @@
 
 	/* If Intr is because of Tx Traffic */
 	if (reason & GEN_INTR_TXTRAFFIC) {
-		txIntrHandler(sp);
+		tx_intr_handler(sp);
 	}
 
 	/* If Intr is because of an error */
 	if (reason & (GEN_ERROR_INTR))
-		alarmIntrHandler(sp);
+		alarm_intr_handler(sp);
 
 #ifdef CONFIG_S2IO_NAPI
 	if (reason & GEN_INTR_RXTRAFFIC) {
 		if (netif_rx_schedule_prep(dev)) {
-			en_dis_able_NicIntrs(sp, RX_TRAFFIC_INTR,
-					     DISABLE_INTRS);
+			en_dis_able_nic_intrs(sp, RX_TRAFFIC_INTR,
+					      DISABLE_INTRS);
 			/* We retake the snap shot of the general interrupt 
 			 * register.
 			 */
-			general_mask = readq(&bar0->general_int_mask);
+			general_mask |= BIT(40);
 			__netif_rx_schedule(dev);
 		}
 	}
 #else
 	/* If Intr is because of Rx Traffic */
 	if (reason & GEN_INTR_RXTRAFFIC) {
-		rxIntrHandler(sp);
+		rx_intr_handler(sp);
 	}
 #endif
 
@@ -2403,16 +3672,11 @@
  * reallocate the buffers.
  */
 #if 1
-	{
-	int i;
-
 	for (i = 0; i < config->RxRingNum; i++) {
 		int rxb_size = atomic_read(&sp->rx_bufs_left[i]);
 		int level = rx_buffer_level(sp, rxb_size, i);
 
 		if ((level == PANIC) && (!TASKLET_IN_USE)) {
-			int ret;
-
 			DBG_PRINT(ERR_DBG, "%s: Rx BD hit ", dev->name);
 			DBG_PRINT(ERR_DBG, "PANIC levels\n");
 			if ((ret = fill_rx_buffers(sp, i)) == -ENOMEM) {
@@ -2421,7 +3685,9 @@
 				DBG_PRINT(ERR_DBG, " in ISR!!\n");
 				writeq(general_mask,
 				       &bar0->general_int_mask);
+#if (!LATEST_CHANGES)
 				spin_unlock(&sp->isr_lock);
+#endif
 				return IRQ_HANDLED;
 			}
 			clear_bit(0,
@@ -2432,8 +3698,6 @@
 		}
 
 	}
-
-	}
 #else
 	tasklet_schedule(&sp->task);
 #endif
@@ -2441,49 +3705,62 @@
 	/* Unmask all the previously enabled interrupts on the NIC */
 	writeq(general_mask, &bar0->general_int_mask);
 
+#if (!LATEST_CHANGES)
 	spin_unlock(&sp->isr_lock);
+#endif
 	return IRQ_HANDLED;
 }
 
-/*
- *  Input Argument/s: 
- *  dev - pointer to the device structure.
- *  Return value:
- *  pointer to the updated net_device_stats structure.
+/**
+ *  s2io_get_stats - Updates the device statistics structure. 
+ *  @dev : pointer to the device structure.
  *  Description:
  *  This function updates the device statistics structure in the s2io_nic 
  *  structure and returns a pointer to the same.
+ *  Return value:
+ *  pointer to the updated net_device_stats structure.
  */
+
 struct net_device_stats *s2io_get_stats(struct net_device *dev)
 {
 	nic_t *sp = dev->priv;
-	mac_info_t *mac_control;
-	struct config_param *config;
+#ifdef MAC
+    mac_info_st_t *mac_control_st;
 
+    mac_control_st = &sp->mac_control_st;
+
+    sp->stats.tx_errors = mac_control_st->StatsInfo->tmac_any_err_frms;
+    sp->stats.rx_errors = mac_control_st->StatsInfo->rmac_drop_frms;
+    sp->stats.multicast = mac_control_st->StatsInfo->rmac_vld_mcst_frms;
+    sp->stats.rx_length_errors =
+        mac_control_st->StatsInfo->rmac_long_frms;
+#else
+
+	mac_info_t *mac_control;
 	mac_control = &sp->mac_control;
-	config = &sp->config;
 
 	sp->stats.tx_errors = mac_control->StatsInfo->tmac_any_err_frms;
 	sp->stats.rx_errors = mac_control->StatsInfo->rmac_drop_frms;
 	sp->stats.multicast = mac_control->StatsInfo->rmac_vld_mcst_frms;
 	sp->stats.rx_length_errors =
 	    mac_control->StatsInfo->rmac_long_frms;
-
+#endif
 	return (&sp->stats);
 }
 
-/*
- *  Input Argument/s: 
- *  dev - pointer to the device structure
- *  Return value:
- *  void.
+/**
+ *  s2io_set_multicast - entry point for multicast address enable/disable.
+ *  @dev : pointer to the device structure
  *  Description:
  *  This function is a driver entry point which gets called by the kernel 
  *  whenever multicast addresses must be enabled/disabled. This also gets 
  *  called to set/reset promiscuous mode. Depending on the deivce flag, we
  *  determine, if multicast address must be enabled or if promiscuous mode
  *  is to be disabled etc.
+ *  Return value:
+ *  void.
  */
+
 static void s2io_set_multicast(struct net_device *dev)
 {
 	int i, j, prev_cnt;
@@ -2506,7 +3783,7 @@
 		    RMAC_ADDR_CMD_MEM_OFFSET(MAC_MC_ALL_MC_ADDR_OFFSET);
 		writeq(val64, &bar0->rmac_addr_cmd_mem);
 		/* Wait till command completes */
-		waitForCmdComplete(sp);
+		wait_for_cmd_complete(sp);
 
 		sp->m_cast_flg = 1;
 		sp->all_multi_pos = MAC_MC_ALL_MC_ADDR_OFFSET;
@@ -2519,7 +3796,7 @@
 		    RMAC_ADDR_CMD_MEM_OFFSET(sp->all_multi_pos);
 		writeq(val64, &bar0->rmac_addr_cmd_mem);
 		/* Wait till command completes */
-		waitForCmdComplete(sp);
+		wait_for_cmd_complete(sp);
 
 		sp->m_cast_flg = 0;
 		sp->all_multi_pos = 0;
@@ -2582,7 +3859,7 @@
 			writeq(val64, &bar0->rmac_addr_cmd_mem);
 
 			/* Wait for command completes */
-			if (waitForCmdComplete(sp)) {
+			if (wait_for_cmd_complete(sp)) {
 				DBG_PRINT(ERR_DBG, "%s: Adding ",
 					  dev->name);
 				DBG_PRINT(ERR_DBG, "Multicasts failed\n");
@@ -2609,7 +3886,7 @@
 			writeq(val64, &bar0->rmac_addr_cmd_mem);
 
 			/* Wait for command completes */
-			if (waitForCmdComplete(sp)) {
+			if (wait_for_cmd_complete(sp)) {
 				DBG_PRINT(ERR_DBG, "%s: Adding ",
 					  dev->name);
 				DBG_PRINT(ERR_DBG, "Multicasts failed\n");
@@ -2619,17 +3896,16 @@
 	}
 }
 
-/*
- *  Input Argument/s: 
- *  dev - pointer to the device structure.
- *  new_mac - a uchar pointer to the new mac address which is to be set.
- *  Return value:
- *  SUCCESS on success and an appropriate (-)ve integer as defined in errno.h
- *  file on failure.
- *  Description:
- *  This procedure will program the Xframe to receive frames with new
- *  Mac Address
+/**
+ *  s2io_set_mac_address - Programs the Xframe mac address 
+ *  @dev : pointer to the device structure.
+ *  @new_mac : a uchar pointer to the new mac address which is to be set.
+ *  Description : This procedure will program the Xframe to receive 
+ *  frames with new Mac Address
+ *  Return value: SUCCESS on success and an appropriate (-)ve integer 
+ *  as defined in errno.h file on failure.
  */
+
 int s2io_set_mac_addr(struct net_device *dev, u8 * addr)
 {
 	nic_t *sp = dev->priv;
@@ -2655,7 +3931,7 @@
 	    RMAC_ADDR_CMD_MEM_OFFSET(0);
 	writeq(val64, &bar0->rmac_addr_cmd_mem);
 	/* Wait till command completes */
-	if (waitForCmdComplete(sp)) {
+	if (wait_for_cmd_complete(sp)) {
 		DBG_PRINT(ERR_DBG, "%s: set_mac_addr failed\n", dev->name);
 		return FAILURE;
 	}
@@ -2663,18 +3939,21 @@
 	return SUCCESS;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  info - pointer to the structure with parameters given by ethtool to set
- *  link information.
- * Return value:
- *  0 on success.
+/**
+ * s2io_ethtool_sset - Sets different link parameters. 
+ * @sp : private member of the device structure, which is a pointer to the  * s2io_nic structure.
+ * @info: pointer to the structure with parameters given by ethtool to set
+ * link information.
  * Description:
- *  The function sets different link parameters provided by the user onto 
- *  the NIC.
- */
+ * The function sets different link parameters provided by the user onto 
+ * the NIC.
+ * Return value:
+ * 0 on success.
+*/
+
+#ifndef SET_ETHTOOL_OPS
+#define SPEED_10000 10000
+#endif
 static int s2io_ethtool_sset(struct net_device *dev,
 			     struct ethtool_cmd *info)
 {
@@ -2690,17 +3969,18 @@
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  info - pointer to the structure with parameters given by ethtool to return
- *  link information.
- * Return value:
- *  void
+/**
+ * s2io_ethtol_gset - Return link specific information. 
+ * @sp : private member of the device structure, pointer to the
+ *      s2io_nic structure.
+ * @info : pointer to the structure with parameters given by ethtool
+ * to return link information.
  * Description:
- *  Returns link specefic information like speed, duplex etc.. to ethtool.
+ * Returns link specefic information like speed, duplex etc.. to ethtool.
+ * Return value :
+ * void.
  */
+
 int s2io_ethtool_gset(struct net_device *dev, struct ethtool_cmd *info)
 {
 	nic_t *sp = dev->priv;
@@ -2721,17 +4001,18 @@
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  info - pointer to the structure with parameters given by ethtool to return
- *  driver information.
+/**
+ * s2io_ethtool_gdrvinfo - Returns driver specific information. 
+ * @sp : private member of the device structure, which is a pointer to the 
+ * s2io_nic structure.
+ * @info : pointer to the structure with parameters given by ethtool to
+ * return driver information.
+ * Description:
+ * Returns driver specefic information like name, version etc.. to ethtool.
  * Return value:
  *  void
- * Description:
- *  Returns driver specefic information like name, version etc.. to ethtool.
  */
+
 static void s2io_ethtool_gdrvinfo(struct net_device *dev,
 				  struct ethtool_drvinfo *info)
 {
@@ -2745,22 +4026,25 @@
 	info->regdump_len = XENA_REG_SPACE;
 	info->eedump_len = XENA_EEPROM_SPACE;
 	info->testinfo_len = S2IO_TEST_LEN;
+#ifdef ETHTOOL_GSTATS
 	info->n_stats = S2IO_STAT_LEN;
+#endif
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  regs - pointer to the structure with parameters given by ethtool for 
+/**
+ *  s2io_ethtool_gregs - dumps the entire space of Xfame into te buffer.
+ *  @sp: private member of the device structure, which is a pointer to the 
+ *  s2io_nic structure.
+ *  @regs : pointer to the structure with parameters given by ethtool for 
  *  dumping the registers.
- *  reg_space - The input argumnet into which all the registers are dumped.
- * Return value:
- *  void
- * Description:
- *  Dumps the entire register space of xFrame NIC into the user given buffer 
- *  area.
- */
+ *  @reg_space: The input argumnet into which all the registers are dumped.
+ *  Description:
+ *  Dumps the entire register space of xFrame NIC into the user given
+ *  buffer area.
+ * Return value :
+ * void .
+*/
+
 static void s2io_ethtool_gregs(struct net_device *dev,
 			       struct ethtool_regs *regs, void *space)
 {
@@ -2778,17 +4062,15 @@
 	}
 }
 
-/*
- * Input Argument/s: 
- *  data - address of the private member of the device structure, which 
+/**
+ *  s2io_phy_id  - timer function that alternates adapter LED.
+ *  @data : address of the private member of the device structure, which 
  *  is a pointer to the s2io_nic structure, provided as an u32.
- * Return value:
- *  void
- * Description:
- *  This is actually the timer function that alternates the adapter LED bit
- *  of the adapter control bit to set/reset every time on invocation.
- *  The timer is set for 1/2 a second, hence tha NIC blinks once every second.
- */
+ * Description: This is actually the timer function that alternates the 
+ * adapter LED bit of the adapter control bit to set/reset every time on 
+ * invocation. The timer is set for 1/2 a second, hence tha NIC blinks 
+ *  once every second.
+*/
 static void s2io_phy_id(unsigned long data)
 {
 	nic_t *sp = (nic_t *) data;
@@ -2810,28 +4092,30 @@
 	mod_timer(&sp->id_timer, jiffies + HZ / 2);
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  id - pointer to the structure with identification parameters given by 
- *  ethtool.
+/**
+ * s2io_ethtool_idnic - To physically ientify the nic on the system.
+ * @sp : private member of the device structure, which is a pointer to the
+ * s2io_nic structure.
+ * @id : pointer to the structure with identification parameters given by 
+ * ethtool.
+ * Description: Used to physically identify the NIC on the system.
+ * The Link LED will blink for a time specified by the user for 
+ * identification.
+ * NOTE: The Link has to be Up to be able to blink the LED. Hence 
+ * identification is possible only if it's link is up.
  * Return value:
- *  int , returns '0' on success
- * Description:
- *  Used to physically identify the NIC on the system. The Link LED will blink
- *  for a time specified by the user for identification.
- *  NOTE: The Link has to be Up to be able to blink the LED. Hence 
- *  identification is possible only if it's link is up.
+ * int , returns '0' on success
  */
+
 static int s2io_ethtool_idnic(struct net_device *dev, u32 data)
 {
-	u64 val64 = 0;
+	u64 val64 = 0, last_gpio_ctrl_val;
 	nic_t *sp = dev->priv;
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
 	u16 subid;
 
 	subid = sp->pdev->subsystem_device;
+	last_gpio_ctrl_val = readq(&bar0->gpio_control);
 	if ((subid & 0xFF) < 0x07) {
 		val64 = readq(&bar0->adapter_control);
 		if (!(val64 & ADAPTER_CNTL_EN)) {
@@ -2853,19 +4137,23 @@
 		schedule_timeout(MAX_SCHEDULE_TIMEOUT);
 	del_timer_sync(&sp->id_timer);
 
+	if(CARDS_WITH_FAULTY_LINK_INDICATORS(subid)) {
+		writeq(last_gpio_ctrl_val, &bar0->gpio_control);
+		last_gpio_ctrl_val = readq(&bar0->gpio_control);
+	}
+
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  ep - pointer to the structure with pause parameters given by ethtool.
+/**
+ * s2io_ethtool_getpause_data -Pause frame frame generation and reception.
+ * @sp : private member of the device structure, which is a pointer to the  * s2io_nic structure.
+ * @ep : pointer to the structure with pause parameters given by ethtool.
+ * Description:
+ * Returns the Pause frame generation and reception capability of the NIC.
  * Return value:
  *  void
- * Description:
- *  Returns the Pause frame generation and reception capability of the NIC.
- */
+*/
 static void s2io_ethtool_getpause_data(struct net_device *dev,
 				       struct ethtool_pauseparam *ep)
 {
@@ -2881,17 +4169,18 @@
 	ep->autoneg = FALSE;
 }
 
-/*
- * Input Argument/s: 
- * sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- * ep - pointer to the structure with pause parameters given by ethtool.
+/**
+ * s2io_ethtool-setpause_data -  set/reset pause frame generation.
+ * @sp : private member of the device structure, which is a pointer to the 
+ *      s2io_nic structure.
+ * @ep : pointer to the structure with pause parameters given by ethtool.
+ * Description:
+ * It can be used to set or reset Pause frame generation or reception
+ * support of the NIC.
  * Return value:
  * int, returns '0' on Success
- * Description:
- * It can be used to set or reset Pause frame generation or reception support 
- * of the NIC.
- */
+*/
+
 int s2io_ethtool_setpause_data(struct net_device *dev,
 			       struct ethtool_pauseparam *ep)
 {
@@ -2912,21 +4201,22 @@
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  off - offset at which the data must be written
- * Return value:
- *  -1 on failure and the value read from the Eeprom if successful.
+/**
+ * read_eeprom - reads 4 bytes of data from user given offset.
+ * @sp : private member of the device structure, which is a pointer to the 
+ *      s2io_nic structure.
+ * @off : offset at which the data must be written
  * Description:
- *  Will read 4 bytes of data from the user given offset and return the 
- *  read data.
+ * Will read 4 bytes of data from the user given offset and return the 
+ * read data.
  * NOTE: Will allow to read only part of the EEPROM visible through the
- * 	 I2C bus.
- */
+ *   I2C bus.
+ * Return value:
+ *  -1 on failure and the value read from the Eeprom if successful.
+*/
+
 #define S2IO_DEV_ID		5
-static u32 readEeprom(nic_t * sp, int off)
+static u32 read_eeprom(nic_t * sp, int off)
 {
 	u32 data = -1, exit_cnt = 0;
 	u64 val64;
@@ -2951,21 +4241,22 @@
 	return data;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  off - offset at which the data must be written
- *  data - The data that is to be written
- *  cnt - Number of bytes of the data that are actually to be written into 
+/**
+ *  write_eeprom - actually writes the relevant part of the data value.
+ *  @sp : private member of the device structure, which is a pointer to the
+ *       s2io_nic structure.
+ *  @off : offset at which the data must be written
+ *  @data : The data that is to be written
+ *  @cnt : Number of bytes of the data that are actually to be written into 
  *  the Eeprom. (max of 3)
- * Return value:
- *  '0' on success, -1 on failure.
  * Description:
  *  Actually writes the relevant part of the data value into the Eeprom
  *  through the I2C bus.
- */
-static int writeEeprom(nic_t * sp, int off, u32 data, int cnt)
+ * Return value:
+ *  '0' on success, -1 on failure.
+*/
+
+static int write_eeprom(nic_t * sp, int off, u32 data, int cnt)
 {
 	int exit_cnt = 0, ret = -1;
 	u64 val64;
@@ -2991,39 +4282,19 @@
 	return ret;
 }
 
-/* 
- * A helper function used to invert the 4 byte u32 data field
- * byte by byte. This will be used by the Read Eeprom function
- * for display purposes.
- */
-u32 inv(u32 data)
-{
-	static u32 ret = 0;
-
-	if (data) {
-		u8 c = data;
-		ret = ((ret << 8) + c);
-		data >>= 8;
-		inv(data);
-	}
-
-	return ret;
-}
-
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  eeprom - pointer to the user level structure provided by ethtool, 
- *   containing all relevant information.
- *  data_buf - user defined value to be written into Eeprom.
- * Return value:
+/**
+ *  s2io_ethtool_geeprom  - reads the value stored in the Eeprom.
+ *  @sp : private member of the device structure, which is a pointer to the *       s2io_nic structure.
+ *  @eeprom : pointer to the user level structure provided by ethtool, 
+ *  containing all relevant information.
+ *  @data_buf : user defined value to be written into Eeprom.
+ *  Description: Reads the values stored in the Eeprom at given offset
+ *  for a given length. Stores these values int the input argument data
+ *  buffer 'data_buf' and returns these to the caller (ethtool.)
+ *  Return value:
  *  int  '0' on success
- * Description:
- *  Reads the values stored in the Eeprom at given offset for a given length.
- *  Stores these values int the input argument data buffer 'data_buf' and
- *  returns these to the caller (ethtool.)
- */
+*/
+
 int s2io_ethtool_geeprom(struct net_device *dev,
 			 struct ethtool_eeprom *eeprom, u8 * data_buf)
 {
@@ -3036,30 +4307,31 @@
 		eeprom->len = XENA_EEPROM_SPACE - eeprom->offset;
 
 	for (i = 0; i < eeprom->len; i += 4) {
-		data = readEeprom(sp, eeprom->offset + i);
+		data = read_eeprom(sp, eeprom->offset + i);
 		if (data < 0) {
 			DBG_PRINT(ERR_DBG, "Read of EEPROM failed\n");
 			return -EFAULT;
 		}
-		valid = inv(data);
+		valid = INV(data);
 		memcpy((data_buf + i), &valid, 4);
 	}
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  eeprom - pointer to the user level structure provided by ethtool, 
- *   containing all relevant information.
- *  data_buf - user defined value to be written into Eeprom.
- * Return value:
- *  '0' on success, -EFAULT on failure.
- * Description:
+/**
+ *  s2io_ethtool_seeprom - tries to write the user provided value in Eeprom
+ *  @sp : private member of the device structure, which is a pointer to the
+ *  s2io_nic structure.
+ *  @eeprom : pointer to the user level structure provided by ethtool, 
+ *  containing all relevant information.
+ *  @data_buf ; user defined value to be written into Eeprom.
+ *  Description:
  *  Tries to write the user provided value in the Eeprom, at the offset
  *  given by the user.
- */
+ *  Return value:
+ *  '0' on success, -EFAULT on failure.
+*/
+
 static int s2io_ethtool_seeprom(struct net_device *dev,
 				struct ethtool_eeprom *eeprom,
 				u8 * data_buf)
@@ -3083,7 +4355,7 @@
 		} else
 			valid = data;
 
-		if (writeEeprom(sp, (eeprom->offset + cnt), valid, 0)) {
+		if (write_eeprom(sp, (eeprom->offset + cnt), valid, 0)) {
 			DBG_PRINT(ERR_DBG,
 				  "ETHTOOL_WRITE_EEPROM Err: Cannot ");
 			DBG_PRINT(ERR_DBG,
@@ -3097,19 +4369,20 @@
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  data - variable that returns the result of each of the test conducted by 
- *  	the driver.
- * Return value:
- *  '0' on success.
+/**
+ * s2io_register_test - reads and writes into all clock domains. 
+ * @sp : private member of the device structure, which is a pointer to the 
+ * s2io_nic structure.
+ * @data : variable that returns the result of each of the test conducted b
+ * by the driver.
  * Description:
- *  Read and write into all clock domains. The NIC has 3 clock domains,
- *  see that registers in all the three regions are accessible.
- */
-static int s2io_registerTest(nic_t * sp, uint64_t * data)
+ * Read and write into all clock domains. The NIC has 3 clock domains,
+ * see that registers in all the three regions are accessible.
+ * Return value:
+ * '0' on success.
+*/
+
+static int s2io_register_test(nic_t * sp, uint64_t * data)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
 	u64 val64 = 0;
@@ -3159,88 +4432,90 @@
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  data - variable that returns the result of each of the test conducted by 
- *  	the driver.
- * Return value:
- *  '0' on success.
+/**
+ * s2io_eeprom_test - to verify that EEprom in the xena can be programmed. 
+ * @sp : private member of the device structure, which is a pointer to the
+ * s2io_nic structure.
+ * @data:variable that returns the result of each of the test conducted by
+ * the driver.
  * Description:
- *  Verify that EEPROM in the xena can be programmed using I2C_CONTROL 
- *  register.
- */
-static int s2io_eepromTest(nic_t * sp, uint64_t * data)
+ * Verify that EEPROM in the xena can be programmed using I2C_CONTROL 
+ * register.
+ * Return value:
+ * '0' on success.
+*/
+
+static int s2io_eeprom_test(nic_t * sp, uint64_t * data)
 {
 	int fail = 0, ret_data;
 
 	/* Test Write Error at offset 0 */
-	if (!writeEeprom(sp, 0, 0, 3))
+	if (!write_eeprom(sp, 0, 0, 3))
 		fail = 1;
 
 	/* Test Write at offset 4f0 */
-	if (writeEeprom(sp, 0x4F0, 0x01234567, 3))
+	if (write_eeprom(sp, 0x4F0, 0x01234567, 3))
 		fail = 1;
-	if ((ret_data = readEeprom(sp, 0x4f0)) < 0)
+	if ((ret_data = read_eeprom(sp, 0x4f0)) < 0)
 		fail = 1;
 
 	if (ret_data != 0x01234567)
 		fail = 1;
 
 	/* Reset the EEPROM data go FFFF */
-	writeEeprom(sp, 0x4F0, 0xFFFFFFFF, 3);
+	write_eeprom(sp, 0x4F0, 0xFFFFFFFF, 3);
 
 	/* Test Write Request Error at offset 0x7c */
-	if (!writeEeprom(sp, 0x07C, 0, 3))
+	if (!write_eeprom(sp, 0x07C, 0, 3))
 		fail = 1;
 
 	/* Test Write Request at offset 0x7fc */
-	if (writeEeprom(sp, 0x7FC, 0x01234567, 3))
+	if (write_eeprom(sp, 0x7FC, 0x01234567, 3))
 		fail = 1;
-	if ((ret_data = readEeprom(sp, 0x7FC)) < 0)
+	if ((ret_data = read_eeprom(sp, 0x7FC)) < 0)
 		fail = 1;
 
 	if (ret_data != 0x01234567)
 		fail = 1;
 
 	/* Reset the EEPROM data go FFFF */
-	writeEeprom(sp, 0x7FC, 0xFFFFFFFF, 3);
+	write_eeprom(sp, 0x7FC, 0xFFFFFFFF, 3);
 
 	/* Test Write Error at offset 0x80 */
-	if (!writeEeprom(sp, 0x080, 0, 3))
+	if (!write_eeprom(sp, 0x080, 0, 3))
 		fail = 1;
 
 	/* Test Write Error at offset 0xfc */
-	if (!writeEeprom(sp, 0x0FC, 0, 3))
+	if (!write_eeprom(sp, 0x0FC, 0, 3))
 		fail = 1;
 
 	/* Test Write Error at offset 0x100 */
-	if (!writeEeprom(sp, 0x100, 0, 3))
+	if (!write_eeprom(sp, 0x100, 0, 3))
 		fail = 1;
 
 	/* Test Write Error at offset 4ec */
-	if (!writeEeprom(sp, 0x4EC, 0, 3))
+	if (!write_eeprom(sp, 0x4EC, 0, 3))
 		fail = 1;
 
 	*data = fail;
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  data - variable that returns the result of each of the test conducted by 
- *  	the driver.
- * Return value:
- *  '0' on success and -1 on failure.
+/**
+ * s2io_bist_test - invokes the MemBist test of the card .
+ * @sp : private member of the device structure, which is a pointer to the 
+ * s2io_nic structure.
+ * @data:variable that returns the result of each of the test conducted by 
+ * the driver.
  * Description:
- *  This invokes the MemBist test of the card. We give around
- *  2 secs time for the Test to complete. If it's still not complete
- *  within this peiod, we consider that the test failed. 
- */
-static int s2io_bistTest(nic_t * sp, uint64_t * data)
+ * This invokes the MemBist test of the card. We give around
+ * 2 secs time for the Test to complete. If it's still not complete
+ * within this peiod, we consider that the test failed. 
+ * Return value:
+ * '0' on success and -1 on failure.
+*/
+
+static int s2io_bist_test(nic_t * sp, uint64_t * data)
 {
 	u8 bist = 0;
 	int cnt = 0, ret = -1;
@@ -3264,19 +4539,20 @@
 	return ret;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  data - variable that returns the result of each of the test conducted by 
- *  	the driver.
- * Return value:
- *  '0' on success.
+/**
+ * s2io-link_test - verifies the link state of the nic  
+ * @sp ; private member of the device structure, which is a pointer to the 
+ * s2io_nic structure.
+ * @data: variable that returns the result of each of the test conducted by
+ * the driver.
  * Description:
- *  The function verifies the link state of the NIC and updates the input 
- *  argument 'data' appropriately.
- */
-static int s2io_linkTest(nic_t * sp, uint64_t * data)
+ * The function verifies the link state of the NIC and updates the input 
+ * argument 'data' appropriately.
+ * Return value:
+ * '0' on success.
+*/
+
+static int s2io_link_test(nic_t * sp, uint64_t * data)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
 	u64 val64;
@@ -3288,19 +4564,19 @@
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  data - variable that returns the result of each of the test conducted by 
- *  	the driver.
- * Return value:
- *  '0' on success.
+/**
+ * s2io_rldram_test - offline test for access to the RldRam chip on the NIC 
+ * @sp - private member of the device structure, which is a pointer to the  * s2io_nic structure.
+ * @data - variable that returns the result of each of the test 
+ * conducted by the driver.
  * Description:
  *  This is one of the offline test that tests the read and write 
  *  access to the RldRam chip on the NIC.
- */
-static int s2io_rldramTest(nic_t * sp, uint64_t * data)
+ * Return value:
+ *  '0' on success.
+*/
+
+static int s2io_rldram_test(nic_t * sp, uint64_t * data)
 {
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) sp->bar0;
 	u64 val64;
@@ -3395,20 +4671,21 @@
 	return 0;
 }
 
-/*
- * Input Argument/s: 
- *  sp - private member of the device structure, which is a pointer to the 
- *   	s2io_nic structure.
- *  ethtest - pointer to a ethtool command specific structure that will be
- *  	returned to the user.
- *  data - variable that returns the result of each of the test conducted by 
- *  	the driver.
- * Return value:
- *  SUCCESS on success and an appropriate -1 on failure.
+/**
+ *  s2io_ethtool_test - conducts 6 tsets to determine the health of card.
+ *  @sp : private member of the device structure, which is a pointer to the
+ *  s2io_nic structure.
+ *  @ethtest : pointer to a ethtool command specific structure that will be
+ *  returned to the user.
+ *  @data : variable that returns the result of each of the test 
+ * conducted by the driver.
  * Description:
  *  This function conducts 6 tests ( 4 offline and 2 online) to determine
- *  	the health of the card.
- */
+ *  the health of the card.
+  * Return value:
+ *  SUCCESS on success and an appropriate -1 on failure.
+*/
+
 static void s2io_ethtool_test(struct net_device *dev,
 			      struct ethtool_test *ethtest,
 			      uint64_t * data)
@@ -3424,22 +4701,22 @@
 		} else
 			s2io_set_swapper(sp);
 
-		if (s2io_registerTest(sp, &data[0]))
+		if (s2io_register_test(sp, &data[0]))
 			ethtest->flags |= ETH_TEST_FL_FAILED;
 
 		s2io_reset(sp);
 		s2io_set_swapper(sp);
 
-		if (s2io_rldramTest(sp, &data[3]))
+		if (s2io_rldram_test(sp, &data[3]))
 			ethtest->flags |= ETH_TEST_FL_FAILED;
 
 		s2io_reset(sp);
 		s2io_set_swapper(sp);
 
-		if (s2io_eepromTest(sp, &data[1]))
+		if (s2io_eeprom_test(sp, &data[1]))
 			ethtest->flags |= ETH_TEST_FL_FAILED;
 
-		if (s2io_bistTest(sp, &data[4]))
+		if (s2io_bist_test(sp, &data[4]))
 			ethtest->flags |= ETH_TEST_FL_FAILED;
 
 		if (orig_state)
@@ -3459,7 +4736,7 @@
 			data[4] = -1;
 		}
 
-		if (s2io_linkTest(sp, &data[2]))
+		if (s2io_link_test(sp, &data[2]))
 			ethtest->flags |= ETH_TEST_FL_FAILED;
 
 		data[0] = 0;
@@ -3469,13 +4746,18 @@
 	}
 }
 
+#ifdef ETHTOOL_GSTATS
 static void s2io_get_ethtool_stats(struct net_device *dev,
 				   struct ethtool_stats *estats,
 				   u64 * tmp_stats)
 {
 	int i = 0;
 	nic_t *sp = dev->priv;
+#ifdef MAC
+    StatInfo_t *stat_info = sp->mac_control_st.StatsInfo;
+#else
 	StatInfo_t *stat_info = sp->mac_control.StatsInfo;
+#endif
 
 	tmp_stats[i++] = stat_info->tmac_frms;
 	tmp_stats[i++] = stat_info->tmac_data_octets;
@@ -3517,10 +4799,409 @@
 	tmp_stats[i++] = stat_info->rmac_accepted_ip;
 	tmp_stats[i++] = stat_info->rmac_err_tcp;
 }
+#endif
 
-int s2io_ethtool_get_regs_len(struct net_device *dev)
-{
-	return (XENA_REG_SPACE);
+#ifndef SET_ETHTOOL_OPS
+/**
+ * s2io_ethtool -to support all ethtool features .
+ * @dev : device pointer.
+ * @ifr :   An IOCTL specefic structure, that can contain a pointer to
+ * a proprietary structure used to pass information to the driver.
+ * Description:
+ * Function used to support all ethtool fatures except dumping Device stats
+ * as it can be obtained from the util tool for now.
+ * Return value:
+ * '0' on success and an appropriate (-)ve integer as defined in errno.h
+ * file on failure.
+*/
+
+static int s2io_ethtool(struct net_device *dev, struct ifreq *rq)
+{
+	nic_t *sp = dev->priv;
+	void *data = rq->ifr_data;
+	u32 ecmd;
+
+	if (get_user(ecmd, (u32 *) data)) {
+		return -EFAULT;
+	}
+
+	switch (ecmd) {
+	case ETHTOOL_GSET:
+		{
+			struct ethtool_cmd info = { ETHTOOL_GSET };
+			s2io_ethtool_gset(dev, &info);
+			if (copy_to_user(data, &info, sizeof(info)))
+				return -EFAULT;
+			break;
+		}
+	case ETHTOOL_SSET:
+		{
+			struct ethtool_cmd info;
+
+			if (copy_from_user(&info, data, sizeof(info)))
+				return -EFAULT;
+			if (s2io_ethtool_sset(dev, &info))
+				return -EFAULT;
+			break;
+		}
+	case ETHTOOL_GDRVINFO:
+		{
+			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+
+			s2io_ethtool_gdrvinfo(dev, &info);
+			if (copy_to_user(data, &info, sizeof(info)))
+				return -EFAULT;
+			break;
+		}
+	case ETHTOOL_GREGS:
+		{
+			struct ethtool_regs regs = { ETHTOOL_GREGS };
+			u8 *reg_space;
+			int ret = 0;
+
+			regs.version = sp->pdev->subsystem_device;
+
+			reg_space = kmalloc(XENA_REG_SPACE, GFP_KERNEL);
+			if (reg_space == NULL) {
+				DBG_PRINT(ERR_DBG,
+					  "Memory allocation to dump ");
+				DBG_PRINT(ERR_DBG, "registers failed\n");
+				ret = -EFAULT;
+			}
+			memset(reg_space, 0, XENA_REG_SPACE);
+			s2io_ethtool_gregs(dev, &regs, reg_space);
+			if (copy_to_user(data, &regs, sizeof(regs))) {
+				ret = -EFAULT;
+				goto last_gregs;
+			}
+			data += offsetof(struct ethtool_regs, data);
+			if (copy_to_user(data, reg_space, regs.len)) {
+				ret = -EFAULT;
+				goto last_gregs;
+			}
+		      last_gregs:
+			kfree(reg_space);
+			if (ret)
+				return ret;
+			break;
+		}
+	case ETHTOOL_GLINK:
+		{
+			struct ethtool_value link = { ETHTOOL_GLINK };
+
+			link.data = netif_carrier_ok(dev);
+			if (copy_to_user(data, &link, sizeof(link)))
+				return -EFAULT;
+			break;
+		}
+	case ETHTOOL_PHYS_ID:
+		{
+			struct ethtool_value id;
+
+			if (copy_from_user(&id, data, sizeof(id)))
+				return -EFAULT;
+			s2io_ethtool_idnic(dev, id.data);
+			break;
+		}
+	case ETHTOOL_GPAUSEPARAM:
+		{
+			struct ethtool_pauseparam ep =
+			    { ETHTOOL_GPAUSEPARAM };
+
+			s2io_ethtool_getpause_data(dev, &ep);
+			if (copy_to_user(data, &ep, sizeof(ep)))
+				return -EFAULT;
+			break;
+
+		}
+	case ETHTOOL_SPAUSEPARAM:
+		{
+			struct ethtool_pauseparam ep;
+
+			if (copy_from_user(&ep, data, sizeof(ep)))
+				return -EFAULT;
+			s2io_ethtool_setpause_data(dev, &ep);
+			break;
+		}
+	case ETHTOOL_GRXCSUM:
+		{
+			struct ethtool_value ev = { ETHTOOL_GRXCSUM };
+
+			ev.data = sp->rx_csum;
+			if (copy_to_user(data, &ev, sizeof(ev)))
+				return -EFAULT;
+			break;
+		}
+	case ETHTOOL_GTXCSUM:
+		{
+			struct ethtool_value ev = { ETHTOOL_GTXCSUM };
+			ev.data = (dev->features & NETIF_F_IP_CSUM);
+
+			if (copy_to_user(data, &ev, sizeof(ev)))
+				return -EFAULT;
+			break;
+		}
+	case ETHTOOL_GSG:
+		{
+			struct ethtool_value ev = { ETHTOOL_GSG };
+			ev.data = (dev->features & NETIF_F_SG);
+
+			if (copy_to_user(data, &ev, sizeof(ev)))
+				return -EFAULT;
+			break;
+		}
+#ifdef NETIF_F_TSO
+	case ETHTOOL_GTSO:
+		{
+			struct ethtool_value ev = { ETHTOOL_GTSO };
+			ev.data = (dev->features & NETIF_F_TSO);
+
+			if (copy_to_user(data, &ev, sizeof(ev)))
+				return -EFAULT;
+			break;
+		}
+#endif
+	case ETHTOOL_STXCSUM:
+		{
+			struct ethtool_value ev;
+
+			if (copy_from_user(&ev, data, sizeof(ev)))
+				return -EFAULT;
+
+			if (ev.data)
+				dev->features |= NETIF_F_IP_CSUM;
+			else
+				dev->features &= ~NETIF_F_IP_CSUM;
+			break;
+		}
+	case ETHTOOL_SRXCSUM:
+		{
+			struct ethtool_value ev;
+
+			if (copy_from_user(&ev, data, sizeof(ev)))
+				return -EFAULT;
+
+			if (ev.data)
+				sp->rx_csum = 1;
+			else
+				sp->rx_csum = 0;
+
+			break;
+		}
+	case ETHTOOL_SSG:
+		{
+			struct ethtool_value ev;
+
+			if (copy_from_user(&ev, data, sizeof(ev)))
+				return -EFAULT;
+
+			if (ev.data)
+				dev->features |= NETIF_F_SG;
+			else
+				dev->features &= ~NETIF_F_SG;
+			break;
+		}
+#ifdef NETIF_F_TSO
+	case ETHTOOL_STSO:
+		{
+			struct ethtool_value ev;
+
+			if (copy_from_user(&ev, data, sizeof(ev)))
+				return -EFAULT;
+
+			if (ev.data)
+				dev->features |= NETIF_F_TSO;
+			else
+				dev->features &= ~NETIF_F_TSO;
+			break;
+		}
+#endif
+	case ETHTOOL_GEEPROM:
+		{
+			struct ethtool_eeprom eeprom = { ETHTOOL_GEEPROM };
+			char *data_buf;
+			int ret = 0;
+
+			if (copy_from_user(&eeprom, data, sizeof(eeprom)))
+				return -EFAULT;
+
+			if (eeprom.len <= 0)
+				return -EINVAL;
+
+			if (!
+			    (data_buf =
+			     kmalloc(XENA_EEPROM_SPACE, GFP_KERNEL)))
+				return -ENOMEM;
+			s2io_ethtool_geeprom(dev, &eeprom, data_buf);
+
+			if (copy_to_user(data, &eeprom, sizeof(eeprom))) {
+				ret = -EFAULT;
+				goto last_geprom;
+			}
+
+			data += offsetof(struct ethtool_eeprom, data);
+
+			if (copy_to_user
+			    (data, (void *) data_buf, eeprom.len)) {
+				ret = -EFAULT;
+				goto last_geprom;
+			}
+
+		      last_geprom:
+			kfree(data_buf);
+			if (ret)
+				return ret;
+			break;
+		}
+	case ETHTOOL_SEEPROM:
+		{
+			struct ethtool_eeprom eeprom;
+			unsigned char *data_buf;
+			void *ptr;
+			int ret = 0;
+
+			if (copy_from_user(&eeprom, data, sizeof(eeprom)))
+				return -EFAULT;
+
+			if (!(data_buf = kmalloc(eeprom.len, GFP_KERNEL)))
+				return -ENOMEM;
+			ptr = (void *) data_buf;
+
+			data += offsetof(struct ethtool_eeprom, data);
+			if (copy_from_user(ptr, data, eeprom.len)) {
+				ret = -EFAULT;
+				goto last_seprom;
+			}
+
+			if ((eeprom.offset + eeprom.len) >
+			    (XENA_EEPROM_SPACE)) {
+				DBG_PRINT(ERR_DBG, "%s Write ", dev->name);
+				DBG_PRINT(ERR_DBG, "request overshoots ");
+				DBG_PRINT(ERR_DBG, "the EEPROM area\n");
+				ret = -EFAULT;
+				goto last_seprom;
+			}
+			if (s2io_ethtool_seeprom(dev, &eeprom, data_buf)) {
+				ret = -EFAULT;
+				goto last_seprom;
+			}
+
+		      last_seprom:
+			kfree(data_buf);
+			if (ret)
+				return ret;
+			break;
+		}
+	case ETHTOOL_GSTRINGS:
+		{
+			struct ethtool_gstrings gstrings =
+			    { ETHTOOL_GSTRINGS };
+			char *strings = NULL;
+			int ret = 0, mem_sz;
+
+			if (copy_from_user
+			    (&gstrings, data, sizeof(gstrings)))
+				return -EFAULT;
+
+			switch (gstrings.string_set) {
+			case ETH_SS_TEST:
+				gstrings.len = S2IO_TEST_LEN;
+				mem_sz = S2IO_STRINGS_LEN;
+				strings = kmalloc(mem_sz, GFP_KERNEL);
+				if (!strings)
+					return -ENOMEM;
+				memcpy(strings, s2io_gstrings,
+				       S2IO_STRINGS_LEN);
+				break;
+#ifdef ETHTOOL_GSTATS
+			case ETH_SS_STATS:
+				gstrings.len = S2IO_STAT_LEN;
+				mem_sz = S2IO_STAT_STRINGS_LEN;
+				strings = kmalloc(mem_sz, GFP_KERNEL);
+				if (!strings)
+					return -ENOMEM;
+				memcpy(strings,
+				       &ethtool_stats_keys,
+				       sizeof(ethtool_stats_keys));
+				break;
+#endif
+
+			default:
+				return -EOPNOTSUPP;
+			}
+
+			if (copy_to_user
+			    (data, &gstrings, sizeof(gstrings)))
+				ret = -EFAULT;
+			if (!ret) {
+				data +=
+				    offsetof(struct ethtool_gstrings,
+					     data);
+				if (copy_to_user(data, strings, mem_sz))
+					ret = -EFAULT;
+			}
+			kfree(strings);
+			if (ret)
+				return ret;
+			break;
+		}
+	case ETHTOOL_TEST:
+		{
+			struct {
+				struct ethtool_test ethtest;
+				uint64_t data[S2IO_TEST_LEN];
+			} test = { {
+			ETHTOOL_TEST}};
+
+			if (copy_from_user(&test.ethtest, data,
+					   sizeof(test.ethtest)))
+				return -EFAULT;
+
+			s2io_ethtool_test(dev, &test.ethtest, test.data);
+			if (copy_to_user(data, &test, sizeof(test)))
+				return -EFAULT;
+
+			break;
+		}
+#ifdef ETHTOOL_GSTATS
+	case ETHTOOL_GSTATS:
+		{
+			struct ethtool_stats stats;
+			int ret;
+			u64 *stat_mem;
+
+			if (copy_from_user(&stats, data, sizeof(stats)))
+				return -EFAULT;
+			stats.n_stats = S2IO_STAT_LEN;
+			stat_mem =
+			    kmalloc(stats.n_stats * sizeof(u64), GFP_USER);
+			if (!stat_mem)
+				return -ENOMEM;
+
+			s2io_get_ethtool_stats(dev, &stats, stat_mem);
+			ret = 0;
+			if (copy_to_user(data, &stats, sizeof(stats)))
+				ret = -EFAULT;
+			data += sizeof(stats);
+			if (copy_to_user(data, stat_mem,
+					 stats.n_stats * sizeof(u64)))
+				ret = -EFAULT;
+			kfree(stat_mem);
+			return ret;
+		}
+#endif
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+#else
+
+int s2io_ethtool_get_regs_len(struct net_device *dev)
+{
+	return (XENA_REG_SPACE);
 }
 
 
@@ -3567,6 +5248,17 @@
 	return (S2IO_STAT_LEN);
 }
 
+int s2io_ethtool_op_set_tx_csum(struct net_device *dev, u32 data)
+{
+	if (data)
+		dev->features |= NETIF_F_IP_CSUM;
+	else
+		dev->features &= ~NETIF_F_IP_CSUM;
+
+	return 0;
+}
+
+
 static struct ethtool_ops netdev_ethtool_ops = {
 	.get_settings = s2io_ethtool_gset,
 	.set_settings = s2io_ethtool_sset,
@@ -3574,7 +5266,10 @@
 	.get_regs_len = s2io_ethtool_get_regs_len,
 	.get_regs = s2io_ethtool_gregs,
 	.get_link = ethtool_op_get_link,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,00)) || \
+    (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,23))
 	.get_eeprom_len = s2io_get_eeprom_len,
+#endif
 	.get_eeprom = s2io_ethtool_geeprom,
 	.set_eeprom = s2io_ethtool_seeprom,
 	.get_pauseparam = s2io_ethtool_getpause_data,
@@ -3582,7 +5277,7 @@
 	.get_rx_csum = s2io_ethtool_get_rx_csum,
 	.set_rx_csum = s2io_ethtool_set_rx_csum,
 	.get_tx_csum = ethtool_op_get_tx_csum,
-	.set_tx_csum = ethtool_op_set_tx_csum,
+	.set_tx_csum = s2io_ethtool_op_set_tx_csum,
 	.get_sg = ethtool_op_get_sg,
 	.set_sg = ethtool_op_set_sg,
 #ifdef NETIF_F_TSO
@@ -3596,37 +5291,49 @@
 	.get_stats_count = s2io_ethtool_get_stats_count,
 	.get_ethtool_stats = s2io_get_ethtool_stats
 };
-
-/*
- *  Input Argument/s: 
- *  dev -   Device pointer.
- *  ifr -   An IOCTL specefic structure, that can contain a pointer to
- *      a proprietary structure used to pass information to the driver.
- *  cmd -   This is used to distinguish between the different commands that
- *      can be passed to the IOCTL functions.
- *  Return value:
- *  '0' on success and an appropriate (-)ve integer as defined in errno.h
- *  file on failure.
+#endif
+/**
+ *  s2io_ioctl -Entry point for the Ioctl 
+ *  @dev :  Device pointer.
+ *  @ifr :  An IOCTL specefic structure, that can contain a pointer to
+ *  a proprietary structure used to pass information to the driver.
+ *  @cmd :  This is used to distinguish between the different commands that
+ *  can be passed to the IOCTL functions.
  *  Description:
  *  This function has support for ethtool, adding multiple MAC addresses on 
  *  the NIC and some DBG commands for the util tool.
- */
+ *  Return value:
+ *  '0' on success and an appropriate (-)ve integer as defined in errno.h
+ *  file on failure. 
+*/
+
 int s2io_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
-	return -EOPNOTSUPP;
+	switch (cmd) {
+#ifndef SET_ETHTOOL_OPS
+	case SIOCETHTOOL:
+		{
+			return s2io_ethtool(dev, rq);
+		}
+#endif
+	default:
+		{
+			return -EOPNOTSUPP;
+		}
+	}
 }
 
-/*
- *  Input Argument/s: 
- *   dev - device pointer.
- *   new_mtu - the new MTU size for the device.
- *  Return value:
+/**
+ *  s2io_change-mtu - entry point to change MTU size for the device.
+ *   @dev : device pointer.
+ *   @new_mtu : the new MTU size for the device.
+ *   Description: A driver entry point to change MTU size for the device.
+ *   Before changing the MTU the device must be stopped.
+  *  Return value:
  *   '0' on success and an appropriate (-)ve integer as defined in errno.h
  *   file on failure.
- *  Description:
- *   A driver entry point to change MTU size for the device. Before changing
- *   the MTU the device must be stopped.
- */
+*/
+
 int s2io_change_mtu(struct net_device *dev, int new_mtu)
 {
 	nic_t *sp = dev->priv;
@@ -3654,27 +5361,26 @@
 	return 0;
 }
 
-/*
- *  Input Argument/s: 
- *  dev_adr - address of the device structure in dma_addr_t format.
- *  Return value:
- *  void.
+/**
+ *  s2io_tasklet - Bottom half of the ISR.
+ *  @dev_adr : address of the device structure in dma_addr_t format.
  *  Description:
  *  This is the tasklet or the bottom half of the ISR. This is
  *  an extension of the ISR which is scheduled by the scheduler to be run 
  *  when the load on the CPU is low. All low priority tasks of the ISR can
  *  be pushed into the tasklet. For now the tasklet is used only to 
  *  replenish the Rx buffers in the Rx buffer descriptors.
- */
+  *  Return value:
+ *  void.
+*/
+
 static void s2io_tasklet(unsigned long dev_addr)
 {
 	struct net_device *dev = (struct net_device *) dev_addr;
 	nic_t *sp = dev->priv;
 	int i, ret;
-	mac_info_t *mac_control;
 	struct config_param *config;
 
-	mac_control = &sp->mac_control;
 	config = &sp->config;
 
 	if (!TASKLET_IN_USE) {
@@ -3684,30 +5390,33 @@
 				DBG_PRINT(ERR_DBG, "%s: Out of ",
 					  dev->name);
 				DBG_PRINT(ERR_DBG, "memory in tasklet\n");
-				return;
+				break;
 			} else if (ret == -EFILL) {
 				DBG_PRINT(ERR_DBG,
 					  "%s: Rx Ring %d is full\n",
 					  dev->name, i);
-				return;
+				break;
 			}
 		}
 		clear_bit(0, (unsigned long *) (&sp->tasklet_status));
 	}
 }
 
-
-/*
- * Description:
- * 
+/**
+ * s2io_set_link- Set the LInk status
+ * @data: long pointer to device private structue
+ * Description: Sets the link status for the adapter
  */
+
 static void s2io_set_link(unsigned long data)
 {
 	nic_t *nic = (nic_t *) data;
 	struct net_device *dev = nic->dev;
 	XENA_dev_config_t *bar0 = (XENA_dev_config_t *) nic->bar0;
-	register u64 val64, err_reg;
+	register u64 val64;
+	u16 subid;
 
+	subid = nic->pdev->subsystem_device;
 	/* Allow a small delay for the NICs self initiated 
 	 * cleanup to complete.
 	 */
@@ -3716,16 +5425,19 @@
 
 	val64 = readq(&bar0->adapter_status);
 	if (verify_xena_quiescence(val64, nic->device_enabled_once)) {
-		/* Acknowledge interrupt and clear the R1 register */
-		err_reg = readq(&bar0->mac_rmac_err_reg);
-		writeq(err_reg, &bar0->mac_rmac_err_reg);
-
 		if (LINK_IS_UP(val64)) {
 			val64 = readq(&bar0->adapter_control);
 			val64 |= ADAPTER_CNTL_EN;
 			writeq(val64, &bar0->adapter_control);
-			val64 |= ADAPTER_LED_ON;
-			writeq(val64, &bar0->adapter_control);
+			if(CARDS_WITH_FAULTY_LINK_INDICATORS(subid)) {
+				val64 = readq(&bar0->gpio_control);
+				val64 |= GPIO_CTRL_GPIO_0;
+				writeq(val64, &bar0->gpio_control);
+				val64 = readq(&bar0->gpio_control);
+			} else {
+				val64 |= ADAPTER_LED_ON;
+				writeq(val64, &bar0->adapter_control);
+			}
 			val64 = readq(&bar0->adapter_status);
 			if (!LINK_IS_UP(val64)) {
 				DBG_PRINT(ERR_DBG, "%s:", dev->name);
@@ -3739,6 +5451,12 @@
 			}
 			s2io_link(nic, LINK_UP);
 		} else {
+			if(CARDS_WITH_FAULTY_LINK_INDICATORS(subid)) {
+				val64 = readq(&bar0->gpio_control);
+				val64 &= ~GPIO_CTRL_GPIO_0;
+				writeq(val64, &bar0->gpio_control);
+				val64 = readq(&bar0->gpio_control);
+			}
 			s2io_link(nic, LINK_DOWN);
 		}
 	} else {		/* NIC is not Quiescent. */
@@ -3748,70 +5466,92 @@
 	}
 }
 
-/*
+/** 
+ * s2io-restart_nic -Resets the NIC.
+ * @data : long pointer to the device private structure
  * Description:
  * This function is scheduled to be run by the s2io_tx_watchdog
  * function after 0.5 secs to reset the NIC. The idea is to reduce 
  * the run time of the watch dog routine which is run holding a
  * spin lock.
  */
+
 static void s2io_restart_nic(unsigned long data)
 {
 	struct net_device *dev = (struct net_device *) data;
 	nic_t *sp = dev->priv;
 
+#if LATEST_CHANGES
+	sp->task_flag = 1;
+#endif
 	s2io_close(dev);
+#if LATEST_CHANGES
+	sp->task_flag = 0;
+#endif
 	sp->device_close_flag = TRUE;
 	s2io_open(dev);
 	DBG_PRINT(ERR_DBG,
 		  "%s: was reset by Tx watchdog timer.\n", dev->name);
 }
 
-/*
- *  Input Argument/s: 
- *  dev - device pointer.
- *  Return value:
- *  void
+/** 
+ *  s2io_tx_watchdog - Watchdog for transmit side. 
+ *  @dev : Pointer to net device structure
  *  Description:
  *  This function is triggered if the Tx Queue is stopped
  *  for a pre-defined amount of time when the Interface is still up.
  *  If the Interface is jammed in such a situation, the hardware is
  *  reset (by s2io_close) and restarted again (by s2io_open) to
  *  overcome any problem that might have been caused in the hardware.
- */
+ *  Return value:
+ *  void
+*/
+
 static void s2io_tx_watchdog(struct net_device *dev)
 {
 	nic_t *sp = dev->priv;
 
 	if (netif_carrier_ok(dev)) {
+#ifdef INIT_TQUEUE
+		schedule_task(&sp->rst_timer_task);
+#else
 		schedule_work(&sp->rst_timer_task);
+#endif
 	}
 }
 
-/*
- *  Input Argument/s: 
- *   sp - private member of the device structure, which is a pointer to the 
- *   s2io_nic structure.
- *   skb - the socket buffer pointer.
- *   len - length of the packet
- *   cksum - FCS checksum of the frame.
- *  ring_no - the ring from which this RxD was extracted.
- *  Return value:
- *   SUCCESS on success and -1 on failure.
- *  Description: 
- *   This function is called by the Tx interrupt serivce routine to perform 
+/**
+ *   rx_osm_handler - To perform some OS related operations on SKB.
+ *   @sp: private member of the device structure,pointer to s2io_nic structure.
+ *   @skb : the socket buffer pointer.
+ *   @len : length of the packet
+ *   @cksum : FCS checksum of the frame.
+ *   @ring_no : the ring from which this RxD was extracted.
+ *   Description: 
+ *   This function is called by the Tx interrupt serivce routine to perform
  *   some OS related operations on the SKB before passing it to the upper
  *   layers. It mainly checks if the checksum is OK, if so adds it to the
  *   SKBs cksum variable, increments the Rx packet count and passes the SKB
  *   to the upper layer. If the checksum is wrong, it increments the Rx
  *   packet error count, frees the SKB and returns error.
- */
-static int rxOsmHandler(nic_t * sp, u16 len, RxD_t * rxdp, int ring_no)
+ *   Return value:
+ *   SUCCESS on success and -1 on failure.
+*/
+#ifndef CONFIG_2BUFF_MODE
+static int rx_osm_handler(nic_t * sp, u16 len, RxD_t * rxdp, int ring_no)
+#else
+static int rx_osm_handler(nic_t * sp, RxD_t * rxdp, int ring_no,
+			  buffAdd_t * ba)
+#endif
 {
 	struct net_device *dev = (struct net_device *) sp->dev;
 	struct sk_buff *skb =
 	    (struct sk_buff *) ((unsigned long) rxdp->Host_Control);
 	u16 l3_csum, l4_csum;
+#ifdef CONFIG_2BUFF_MODE
+	int buf0_len, buf2_len;
+	struct ethhdr *eth = (struct ethhdr *) ba->ba_0;
+#endif
 
 	l3_csum = RXD_GET_L3_CKSUM(rxdp->Control_1);
 	if ((rxdp->Control_1 & TCP_OR_UDP_FRAME) && (sp->rx_csum)) {
@@ -3833,9 +5573,36 @@
 		skb->ip_summed = CHECKSUM_NONE;
 	}
 
+	if (rxdp->Control_1 & RXD_T_CODE) {
+		unsigned long long err = rxdp->Control_1 & RXD_T_CODE;
+		DBG_PRINT(ERR_DBG, "%s: Rx error Value: 0x%llx\n",
+			  dev->name, err);
+	}
+#ifdef CONFIG_2BUFF_MODE
+	buf0_len = RXD_GET_BUFFER0_SIZE(rxdp->Control_2);
+	buf2_len = RXD_GET_BUFFER2_SIZE(rxdp->Control_2);
+#endif
+
 	skb->dev = dev;
+#ifndef CONFIG_2BUFF_MODE
 	skb_put(skb, len);
 	skb->protocol = eth_type_trans(skb, dev);
+#else
+	skb_put(skb, buf2_len);
+	/* Reproducing eth_type_trans functionality and running
+	 * on the ethernet header 'eth' stripped and given to us
+	 * by the hardware in 2Buff mode.
+	 */
+	if (*eth->h_dest & 1) {
+		if (!memcmp(eth->h_dest, dev->broadcast, ETH_ALEN))
+			skb->pkt_type = PACKET_BROADCAST;
+		else
+			skb->pkt_type = PACKET_MULTICAST;
+	} else if (memcmp(eth->h_dest, dev->dev_addr, ETH_ALEN)) {
+		skb->pkt_type = PACKET_OTHERHOST;
+	}
+	skb->protocol = eth->h_proto;
+#endif
 
 #ifdef CONFIG_S2IO_NAPI
 	netif_receive_skb(skb);
@@ -3843,30 +5610,47 @@
 	netif_rx(skb);
 #endif
 
+#ifdef CONFIG_2BUFF_MODE
+	kfree(ba->ba_0_org);
+	kfree(ba->ba_1_org);
+#endif
+
 	dev->last_rx = jiffies;
 #if DEBUG_ON
 	sp->rxpkt_cnt++;
 #endif
 	sp->rx_pkt_count++;
 	sp->stats.rx_packets++;
+#ifndef CONFIG_2BUFF_MODE
 	sp->stats.rx_bytes += len;
 	sp->rxpkt_bytes += len;
+#else
+	sp->stats.rx_bytes += buf0_len + buf2_len;
+	sp->rxpkt_bytes += buf0_len + buf2_len;
+#endif
 
 	atomic_dec(&sp->rx_bufs_left[ring_no]);
 	rxdp->Host_Control = 0;
 	return SUCCESS;
 }
 
-int check_for_txSpace(nic_t * sp)
+int check_for_tx_space(nic_t * sp)
 {
 	u32 put_off, get_off, queue_len;
 	int ret = TRUE, i;
 
 	for (i = 0; i < sp->config.TxFIFONum; i++) {
+#ifdef MAC
+        queue_len = sp->mac_control_tx.tx_curr_put_info[i].fifo_len
+            + 1;
+        put_off = sp->mac_control_tx.tx_curr_put_info[i].offset;
+        get_off = sp->mac_control_tx.tx_curr_get_info[i].offset;
+#else
 		queue_len = sp->mac_control.tx_curr_put_info[i].fifo_len
 		    + 1;
 		put_off = sp->mac_control.tx_curr_put_info[i].offset;
 		get_off = sp->mac_control.tx_curr_get_info[i].offset;
+#endif
 		if (((put_off + 1) % queue_len) == get_off) {
 			ret = FALSE;
 			break;
@@ -3876,18 +5660,19 @@
 	return ret;
 }
 
-/*
-*  Input Argument/s: 
-*   sp - private member of the device structure, which is a pointer to the 
-*   s2io_nic structure.
-*   link - inidicates whether link is UP/DOWN.
-*  Return value:
-*   void.
+/**
+*  s2io_link - stops/starts the Tx queue.
+*  @sp : private member of the device structure, which is a pointer to the
+*  s2io_nic structure.
+*  @link : inidicates whether link is UP/DOWN.
 *  Description:
-*   This function stops/starts the Tx queue depending on whether the link
-*   status of the NIC is is down or up. This is called by the Alarm interrupt 
-*  handler whenever a link change interrupt comes up. 
+*  This function stops/starts the Tx queue depending on whether the link
+*  status of the NIC is is down or up. This is called by the Alarm 
+*  interrupt handler whenever a link change interrupt comes up. 
+*  Return value:
+*  void.
 */
+
 void s2io_link(nic_t * sp, int link)
 {
 	struct net_device *dev = (struct net_device *) sp->dev;
@@ -3900,7 +5685,7 @@
 		} else {
 			DBG_PRINT(ERR_DBG, "%s: Link Up\n", dev->name);
 			netif_carrier_on(dev);
-			if (check_for_txSpace(sp) == TRUE) {
+			if (check_for_tx_space(sp) == TRUE) {
 				/* Don't wake the queue, if we know there
 				 * are no free TxDs available.
 				 */
@@ -3911,14 +5696,15 @@
 	sp->last_link_state = link;
 }
 
-/*
-*  Input Argument/s: 
-*   pdev - structure containing the PCI related information of the device.
-*  Return value:
-*   returns the revision ID of the device.
+/**
+*  get_xena_rev_id - to identify revision ID of xena. 
+*  @pdev : PCI Dev structure
 *  Description:
-*   Function to identify the Revision ID of xena.
+*  Function to identify the Revision ID of xena.
+*  Return value:
+*  returns the revision ID of the device.
 */
+
 int get_xena_rev_id(struct pci_dev *pdev)
 {
 	u8 id = 0;
@@ -3927,16 +5713,17 @@
 	return id;
 }
 
-/*
-*  Input Argument/s: 
-*   sp - private member of the device structure, which is a pointer to the 
-*   s2io_nic structure.
-*  Return value:
-*   void
+/**
+*  s2io_init_pci -Initialization of PCI and PCI-X configuration registers . 
+*  @sp : private member of the device structure, which is a pointer to the 
+*  s2io_nic structure.
 *  Description:
-*   This function initializes a few of the PCI and PCI-X configuration registers
-*   with recommended values.
+*  This function initializes a few of the PCI and PCI-X configuration registers
+*  with recommended values.
+*  Return value:
+*  void
 */
+
 static void s2io_init_pci(nic_t * sp)
 {
 	u16 pci_cmd = 0;
@@ -3969,43 +5756,90 @@
 	pci_read_config_word(sp->pdev, PCIX_COMMAND_REGISTER,
 			     &(sp->pcix_cmd));
 
-/* Setting Maximum outstanding splits to two for now. */
-	sp->pcix_cmd &= 0xFF1F;
+/*  Setting Maximum outstanding splits based on system type. */
+	sp->pcix_cmd &= 0xFF8F;
 
-	sp->pcix_cmd |=
-	    XENA_MAX_OUTSTANDING_SPLITS(XENA_TWO_SPLIT_TRANSACTION);
+	sp->pcix_cmd |= XENA_MAX_OUTSTANDING_SPLITS(max_splits_trans);
 	pci_write_config_word(sp->pdev, PCIX_COMMAND_REGISTER,
 			      sp->pcix_cmd);
 	pci_read_config_word(sp->pdev, PCIX_COMMAND_REGISTER,
 			     &(sp->pcix_cmd));
 
+#if LATEST_CHANGES
+/* Forcibly disabling Relaxed ordering capability of the card. */
+	sp->pcix_cmd &= ~(0x0002);
+	pci_write_config_word(sp->pdev, PCIX_COMMAND_REGISTER,
+			      sp->pcix_cmd);
+	pci_read_config_word(sp->pdev, PCIX_COMMAND_REGISTER,
+			     &(sp->pcix_cmd));
+#endif
 }
 
 MODULE_AUTHOR("Raghavendra Koushik <raghavendra.koushik@s2io.com>");
 MODULE_LICENSE("GPL");
-MODULE_PARM(ring_num, "1-" __MODULE_STRING(1) "i");
-MODULE_PARM(frame_len, "1-" __MODULE_STRING(8) "i");
-MODULE_PARM(ring_len, "1-" __MODULE_STRING(8) "i");
-MODULE_PARM(fifo_num, "1-" __MODULE_STRING(1) "i");
-MODULE_PARM(fifo_len, "1-" __MODULE_STRING(8) "i");
-MODULE_PARM(rx_prio, "1-" __MODULE_STRING(1) "i");
-MODULE_PARM(tx_prio, "1-" __MODULE_STRING(1) "i");
-MODULE_PARM(latency_timer, "1-" __MODULE_STRING(1) "i");
-
-/*
-*  Input Argument/s: 
-*   pdev - structure containing the PCI related information of the device.
-*   pre -  the List of PCI devices supported by the driver listed in s2io_tbl.
-*  Return value:
-*   returns '0' on success and negative on failure.
+MODULE_PARM(lso_enable, "i");
+MODULE_PARM(indicate_max_pkts, "i");
+MODULE_PARM(cksum_offload_enable, "i");
+MODULE_PARM(TxFifoNum, "i");
+MODULE_PARM(TxFIFOLen_0, "i");
+MODULE_PARM(TxFIFOLen_1, "i");
+MODULE_PARM(TxFIFOLen_2, "i");
+MODULE_PARM(TxFIFOLen_3, "i");
+MODULE_PARM(TxFIFOLen_4, "i");
+MODULE_PARM(TxFIFOLen_5, "i");
+MODULE_PARM(TxFIFOLen_6, "i");
+MODULE_PARM(TxFIFOLen_7, "i");
+MODULE_PARM(MaxTxDs, "i");
+MODULE_PARM(RxRingNum, "i");
+MODULE_PARM(RxRingSz_0, "i");
+MODULE_PARM(RxRingSz_1, "i");
+MODULE_PARM(RxRingSz_2, "i");
+MODULE_PARM(RxRingSz_3, "i");
+MODULE_PARM(RxRingSz_4, "i");
+MODULE_PARM(RxRingSz_5, "i");
+MODULE_PARM(RxRingSz_6, "i");
+MODULE_PARM(RxRingSz_7, "i");
+MODULE_PARM(Stats_refresh_time, "i");
+MODULE_PARM(rmac_pause_time, "i");
+MODULE_PARM(mc_pause_threshold_q0q3, "i");
+MODULE_PARM(mc_pause_threshold_q4q7, "i");
+MODULE_PARM(shared_splits, "i");
+MODULE_PARM(max_splits_trans, "i");
+MODULE_PARM(tmac_util_period, "i");
+MODULE_PARM(rmac_util_period, "i");
+MODULE_PARM(tx_timer_val, "i");
+MODULE_PARM(tx_utilz_periodic, "i");
+MODULE_PARM(rx_timer_val, "i");
+MODULE_PARM(rx_utilz_periodic, "i");
+MODULE_PARM(tx_urange_a, "i");
+MODULE_PARM(tx_ufc_a, "i");
+MODULE_PARM(tx_urange_b, "i");
+MODULE_PARM(tx_ufc_b, "i");
+MODULE_PARM(tx_urange_c, "i");
+MODULE_PARM(tx_ufc_c, "i");
+MODULE_PARM(tx_ufc_d, "i");
+MODULE_PARM(rx_urange_a, "i");
+MODULE_PARM(rx_ufc_a, "i");
+MODULE_PARM(rx_urange_b, "i");
+MODULE_PARM(rx_ufc_b, "i");
+MODULE_PARM(rx_urange_c, "i");
+MODULE_PARM(rx_ufc_c, "i");
+MODULE_PARM(rx_ufc_d, "i");
+MODULE_PARM(latency_timer, "i");
+/**
+*  s2io_init_nic - Initialization of the adapter . 
+*  @pdev : structure containing the PCI related information of the device.
+*  @pre: List of PCI devices supported by the driver listed in s2io_tbl.
 *  Description:
 *  The function initializes an adapter identified by the pci_dec structure.
 *  All OS related initialization including memory and device structure and 
 *  initlaization of the device private variable is done. Also the swapper 
 *  control register is initialized to enable read and write into the I/O 
 *  registers of the device.
-*  
+*  Return value:
+*  returns '0' on success and negative on failure.
 */
+
 static int __devinit
 s2io_init_nic(struct pci_dev *pdev, const struct pci_device_id *pre)
 {
@@ -4018,7 +5852,12 @@
 	u64 val64 = 0, tmp64 = 0;
 	XENA_dev_config_t *bar0 = NULL;
 	u16 subid;
+#ifdef MAC
+    mac_info_tx_t *mac_control_tx;
+    mac_info_rx_t *mac_control_rx;
+#else
 	mac_info_t *mac_control;
+#endif
 	struct config_param *config;
 
 
@@ -4031,6 +5870,8 @@
 	if (!pci_set_dma_mask(pdev, 0xffffffffffffffffULL)) {
 		DBG_PRINT(INIT_DBG, "s2io_init_nic: Using 64bit DMA\n");
 		dma_flag = TRUE;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,00))
 		if (pci_set_consistent_dma_mask
 		    (pdev, 0xffffffffffffffffULL)) {
 			DBG_PRINT(ERR_DBG,
@@ -4039,6 +5880,7 @@
 			pci_disable_device(pdev);
 			return -ENOMEM;
 		}
+#endif
 	} else if (!pci_set_dma_mask(pdev, 0xffffffffUL)) {
 		DBG_PRINT(INIT_DBG, "s2io_init_nic: Using 32bit DMA\n");
 	} else {
@@ -4086,73 +5928,72 @@
 	 * these parameters are not not specified during load time, they 
 	 * are initialized with default values.
 	 */
+#ifdef MAC
+    mac_control_tx = &sp->mac_control_tx;
+    mac_control_rx = &sp->mac_control_rx;
+#else
 	mac_control = &sp->mac_control;
+#endif
 	config = &sp->config;
 
 	/* Tx side parameters. */
-	config->TxFIFONum = fifo_num ? fifo_num : 1;
-
-	if (!fifo_len[0] && (fifo_num > 1)) {
-		printk(KERN_ERR "Fifo Lens not specified for all FIFOs\n");
-		goto init_failed;
-	}
-
-	if (fifo_len[0]) {
-		int cnt;
-
-		for (cnt = 0; fifo_len[cnt]; cnt++);
-		if (fifo_num) {
-			if (cnt < fifo_num) {
-				printk(KERN_ERR
-				       "Fifo Lens not specified for ");
-				printk(KERN_ERR "all FIFOs\n");
-				goto init_failed;
-			}
-		}
-		for (cnt = 0; cnt < config->TxFIFONum; cnt++) {
-			config->TxCfg[cnt].FifoLen = fifo_len[cnt];
-			config->TxCfg[cnt].FifoPriority = cnt;
-		}
-	} else {
-		config->TxCfg[0].FifoLen = DEFAULT_FIFO_LEN;
-		config->TxCfg[0].FifoPriority = 0;
-	}
+	config->TxFIFONum = TxFifoNum;
+	config->TxCfg[0].FifoLen = TxFIFOLen_0;
+	config->TxCfg[0].FifoPriority = 0;
+	config->TxCfg[1].FifoLen = TxFIFOLen_1;
+	config->TxCfg[1].FifoPriority = 1;
+	config->TxCfg[2].FifoLen = TxFIFOLen_2;
+	config->TxCfg[2].FifoPriority = 2;
+	config->TxCfg[3].FifoLen = TxFIFOLen_3;
+	config->TxCfg[3].FifoPriority = 3;
+	config->TxCfg[4].FifoLen = TxFIFOLen_4;
+	config->TxCfg[4].FifoPriority = 4;
+	config->TxCfg[5].FifoLen = TxFIFOLen_5;
+	config->TxCfg[5].FifoPriority = 5;
+	config->TxCfg[6].FifoLen = TxFIFOLen_6;
+	config->TxCfg[6].FifoPriority = 6;
+	config->TxCfg[7].FifoLen = TxFIFOLen_7;
+	config->TxCfg[7].FifoPriority = 7;
 
 	config->TxIntrType = TXD_INT_TYPE_UTILZ;
 	for (i = 0; i < config->TxFIFONum; i++) {
+		config->TxCfg[i].fNoSnoop =
+		    (NO_SNOOP_TXD | NO_SNOOP_TXD_BUFFER);
 		if (config->TxCfg[i].FifoLen < 65) {
 			config->TxIntrType = TXD_INT_TYPE_PER_LIST;
 			break;
 		}
 	}
-
-	config->TxCfg[0].fNoSnoop = (NO_SNOOP_TXD | NO_SNOOP_TXD_BUFFER);
 	config->MaxTxDs = MAX_SKB_FRAGS;
 	config->TxFlow = TRUE;
 
 	/* Rx side parameters. */
-	config->RxRingNum = ring_num ? ring_num : 1;
-
-	if (ring_len[0]) {
-		int cnt;
-		for (cnt = 0; cnt < config->RxRingNum; cnt++) {
-			config->RxCfg[cnt].NumRxd = ring_len[cnt];
-			config->RxCfg[cnt].RingPriority = cnt;
-		}
-	} else {
-		int id;
-		if ((id = get_xena_rev_id(pdev)) == 1) {
-			config->RxCfg[0].NumRxd = LARGE_RXD_CNT;
-
-		} else {
-			config->RxCfg[0].NumRxd = SMALL_RXD_CNT;
-		}
-		config->RxCfg[0].RingPriority = 0;
+	config->RxRingNum = RxRingNum;
+	config->RxCfg[0].NumRxd = RxRingSz_0 * (MAX_RXDS_PER_BLOCK + 1);
+	config->RxCfg[0].RingPriority = 0;
+	config->RxCfg[1].NumRxd = RxRingSz_1 * (MAX_RXDS_PER_BLOCK + 1);
+	config->RxCfg[1].RingPriority = 1;
+	config->RxCfg[2].NumRxd = RxRingSz_2 * (MAX_RXDS_PER_BLOCK + 1);
+	config->RxCfg[2].RingPriority = 2;
+	config->RxCfg[3].NumRxd = RxRingSz_3 * (MAX_RXDS_PER_BLOCK + 1);
+	config->RxCfg[3].RingPriority = 3;
+	config->RxCfg[4].NumRxd = RxRingSz_4 * (MAX_RXDS_PER_BLOCK + 1);
+	config->RxCfg[4].RingPriority = 4;
+	config->RxCfg[5].NumRxd = RxRingSz_5 * (MAX_RXDS_PER_BLOCK + 1);
+	config->RxCfg[5].RingPriority = 5;
+	config->RxCfg[6].NumRxd = RxRingSz_6 * (MAX_RXDS_PER_BLOCK + 1);
+	config->RxCfg[6].RingPriority = 6;
+	config->RxCfg[7].NumRxd = RxRingSz_7 * (MAX_RXDS_PER_BLOCK + 1);
+	config->RxCfg[7].RingPriority = 7;
+
+	for (i = 0; i < RxRingNum; i++) {
+		config->RxCfg[i].RingOrg = RING_ORG_BUFF1;
+		config->RxCfg[i].RxdThresh = DEFAULT_RXD_THRESHOLD;
+		config->RxCfg[i].fNoSnoop =
+		    (NO_SNOOP_RXD | NO_SNOOP_RXD_BUFFER);
+		config->RxCfg[i].RxD_BackOff_Interval = TBD;
 	}
-	config->RxCfg[0].RingOrg = RING_ORG_BUFF1;
-	config->RxCfg[0].RxdThresh = DEFAULT_RXD_THRESHOLD;
-	config->RxCfg[0].fNoSnoop = (NO_SNOOP_RXD | NO_SNOOP_RXD_BUFFER);
-	config->RxCfg[0].RxD_BackOff_Interval = TBD;
+
 	config->RxFlow = TRUE;
 
 	/* Miscellaneous parameters. */
@@ -4161,15 +6002,58 @@
 	config->JumboEnable = FALSE;
 
 	/*  Setting Mac Control parameters */
-	mac_control->txdl_len = MAX_SKB_FRAGS;
-	mac_control->rmac_pause_time = 0;
+#ifdef TXDBD
+#ifdef MAC
+   mac_control_tx->txdl_len = MAX_SKB_FRAGS;
+    mac_control_rx->rmac_pause_time = rmac_pause_time;
+    mac_control_rx->mc_pause_threshold_q0q3 = mc_pause_threshold_q0q3;
+    mac_control_rx->mc_pause_threshold_q4q7 = mc_pause_threshold_q4q7;
+    {
+        int nPow = 1;
+        while(nPow < MAX_SKB_FRAGS){
+            nPow *= 2;
+        }
+        mac_control_tx->txdl_len = nPow;
+        config->MaxTxDs = nPow;
+        mac_control_tx->max_txds_per_block = ( 4 * BLOCK_SIZE) / sizeof(TxD_t);
+
+    }
+#else
+    mac_control->txdl_len = MAX_SKB_FRAGS;
+    mac_control->rmac_pause_time = rmac_pause_time;
+    mac_control->mc_pause_threshold_q0q3 = mc_pause_threshold_q0q3;
+    mac_control->mc_pause_threshold_q4q7 = mc_pause_threshold_q4q7;
+    {
+        int nPow = 1;
+        while(nPow < MAX_SKB_FRAGS){
+            nPow *= 2;
+        }
+        mac_control->txdl_len = nPow;
+        config->MaxTxDs = nPow;
+        mac_control->max_txds_per_block = ( 4 * BLOCK_SIZE) / sizeof(TxD_t);
 
+    }
+#endif
+
+#else
+#ifdef MAC
+	mac_control_tx->txdl_len = MAX_SKB_FRAGS;
+	mac_control_rx->rmac_pause_time = rmac_pause_time;
+	mac_control_rx->mc_pause_threshold_q0q3 = mc_pause_threshold_q0q3;
+	mac_control_rx->mc_pause_threshold_q4q7 = mc_pause_threshold_q4q7;
+#else
+	mac_control->txdl_len = MAX_SKB_FRAGS;
+	mac_control->rmac_pause_time = rmac_pause_time;
+	mac_control->mc_pause_threshold_q0q3 = mc_pause_threshold_q0q3;
+	mac_control->mc_pause_threshold_q4q7 = mc_pause_threshold_q4q7;
+#endif
+#endif
 	/* Initialize Ring buffer parameters. */
 	for (i = 0; i < config->RxRingNum; i++)
 		atomic_set(&sp->rx_bufs_left[i], 0);
 
 	/*  initialize the shared memory used by the NIC and the host */
-	if (initSharedMem(sp)) {
+	if (init_shared_mem(sp)) {
 		DBG_PRINT(ERR_DBG, "%s: Memory allocation failed\n",
 			  dev->name);
 		goto mem_alloc_failed;
@@ -4196,8 +6080,13 @@
 
 	/* Initializing the BAR1 address as the start of the FIFO pointer. */
 	for (j = 0; j < MAX_TX_FIFOS; j++) {
+#ifdef MAC
+        mac_control_tx->tx_FIFO_start[j] = (TxFIFO_element_t *)
+            (sp->bar1 + (j * 0x00020000));
+#else
 		mac_control->tx_FIFO_start[j] = (TxFIFO_element_t *)
 		    (sp->bar1 + (j * 0x00020000));
+#endif
 	}
 
 	/*  Driver entry points */
@@ -4208,35 +6097,42 @@
 	dev->set_multicast_list = &s2io_set_multicast;
 	dev->do_ioctl = &s2io_ioctl;
 	dev->change_mtu = &s2io_change_mtu;
+#ifdef SET_ETHTOOL_OPS
 	SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
-
+#endif
 	/*
 	 * will use eth_mac_addr() for  dev->set_mac_address
 	 * mac address will be set every time dev->open() is called
 	 */
 #ifdef CONFIG_S2IO_NAPI
 	dev->poll = s2io_poll;
-	dev->weight = 128;	/* For now. */
+	dev->weight = 64;	/* For now. */
 #endif
 
-	dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
+	dev->features |= NETIF_F_SG;
+	if (cksum_offload_enable)
+		dev->features |= NETIF_F_IP_CSUM;
 	if (sp->high_dma_flag == TRUE)
 		dev->features |= NETIF_F_HIGHDMA;
 #ifdef NETIF_F_TSO
-	dev->features |= NETIF_F_TSO;
+	if (lso_enable)
+		dev->features |= NETIF_F_TSO;
 #endif
 
 	dev->tx_timeout = &s2io_tx_watchdog;
 	dev->watchdog_timeo = WATCH_DOG_TIMEOUT;
+#ifdef INIT_TQUEUE
+	INIT_TQUEUE(&sp->rst_timer_task,
+		    (void (*)(void *)) s2io_restart_nic, dev);
+	INIT_TQUEUE(&sp->set_link_task,
+		    (void (*)(void *)) s2io_set_link, sp);
+#else
 	INIT_WORK(&sp->rst_timer_task,
 		  (void (*)(void *)) s2io_restart_nic, dev);
 	INIT_WORK(&sp->set_link_task,
 		  (void (*)(void *)) s2io_set_link, sp);
+#endif
 
-	if (register_netdev(dev)) {
-		DBG_PRINT(ERR_DBG, "Device registration failed\n");
-		goto register_failed;
-	}
 
 	pci_save_state(sp->pdev, sp->config_space);
 
@@ -4248,7 +6144,7 @@
 	}
 
 	/* Fix for all "FFs" MAC address problems observed on Alpha platforms */
-	FixMacAddress(sp);
+	fix_mac_address(sp);
 	s2io_reset(sp);
 
 	/* Setting swapper control on the NIC, so the MAC address can be read.
@@ -4267,7 +6163,7 @@
 	val64 = RMAC_ADDR_CMD_MEM_RD | RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD |
 	    RMAC_ADDR_CMD_MEM_OFFSET(0 + MAC_MAC_ADDR_START_OFFSET);
 	writeq(val64, &bar0->rmac_addr_cmd_mem);
-	waitForCmdComplete(sp);
+	wait_for_cmd_complete(sp);
 
 	tmp64 = readq(&bar0->rmac_addr_data0_mem);
 	mac_down = (u32) tmp64;
@@ -4300,7 +6196,9 @@
 
 
 	/* Initialize spinlocks */
+#if (!LATEST_CHANGES)
 	spin_lock_init(&sp->isr_lock);
+#endif
 	spin_lock_init(&sp->tx_lock);
 
 	/* SXE-002: Configure link and activity LED to init state 
@@ -4316,6 +6214,28 @@
 		val64 = readq(&bar0->gpio_control);
 	}
 
+
+	sp->rx_csum = 1;	/* Rx chksum verify enabled by default */
+       #ifdef SNMP_SUPPORT
+        if(!s2io_bdsnmp_init(dev))
+                DBG_PRINT(INIT_DBG,"Error Creating Proc directory for SNMP\n");
+
+        sp->nLinkStatus = 1;
+        #ifdef NETIF_F_TSO
+        sp->nFeature = 1;
+        #endif
+        memcpy(sp->cVersion,s2io_driver_version+8,20);
+        memcpy(sp->cName, s2io_driver_name,20);
+        struct timeval tm;
+        do_gettimeofday(&tm);
+        sp->lDate = tm.tv_sec;
+        #endif
+
+	if (register_netdev(dev)) {
+		DBG_PRINT(ERR_DBG, "Device registration failed\n");
+		goto register_failed;
+	}
+
 	/* Make Link state as off at this point, when the Link change 
 	 * interrupt comes the state will be automatically changed to 
 	 * the right state.
@@ -4323,20 +6243,16 @@
 	netif_carrier_off(dev);
 	sp->last_link_state = LINK_DOWN;
 
-	sp->rx_csum = 1;	/* Rx chksum verify enabled by default */
-
 	return 0;
 
-      set_swap_failed:
-	unregister_netdev(dev);
       register_failed:
+      set_swap_failed:
 	iounmap(sp->bar1);
       bar1_remap_failed:
 	iounmap(sp->bar0);
       bar0_remap_failed:
       mem_alloc_failed:
-	freeSharedMem(sp);
-      init_failed:
+	free_shared_mem(sp);
 	pci_disable_device(pdev);
 	pci_release_regions(pdev);
 	pci_set_drvdata(pdev, NULL);
@@ -4345,16 +6261,15 @@
 	return -ENODEV;
 }
 
-/*
-*  Input Argument/s: 
-*   pdev - structure containing the PCI related information of the device.
-*  Return value:
-*  void
-*  Description:
-*  This function is called by the Pci subsystem to release a PCI device 
-*  and free up all resource held up by the device. This could be in response 
-*  to a Hot plug event or when the driver is to be removed from memory.
+/**
+* s2io_rem_nic - Free the PCI device 
+* @pdev: structure containing the PCI related information of the device.
+* Description: This function is called by the Pci subsystem to release a 
+* PCI device and free up all resource held up by the device. This could
+* be in response to a Hot plug event or when the driver is to be removed 
+* from memory.
 */
+
 static void __devexit s2io_rem_nic(struct pci_dev *pdev)
 {
 	struct net_device *dev =
@@ -4366,23 +6281,39 @@
 		return;
 	}
 	sp = dev->priv;
-	freeSharedMem(sp);
+	free_shared_mem(sp);
 	iounmap(sp->bar0);
 	iounmap(sp->bar1);
 	pci_disable_device(pdev);
 	pci_release_regions(pdev);
 	pci_set_drvdata(pdev, NULL);
+    #ifdef SNMP_SUPPORT
+    s2io_bdsnmp_rem(dev);
+    #endif
 
 	unregister_netdev(dev);
 
 	free_netdev(dev);
 }
 
+/**
+ * s2io_starter - Entry point for the driver
+ * Description: This function is the entry point for the driver. It verifies
+ * the module loadable parameters and initializes PCI configuration space.
+ */
+
 int __init s2io_starter(void)
 {
+	if (verify_load_parm())
+		return -ENODEV;
 	return pci_module_init(&s2io_driver);
 }
 
+/**
+ * s2io_closer - Cleanup routine for the driver 
+ * Description: This function is the cleanup routine for the driver. It unregist * ers the driver.
+ */
+
 void s2io_closer(void)
 {
 	pci_unregister_driver(&s2io_driver);
@@ -4391,3 +6322,966 @@
 
 module_init(s2io_starter);
 module_exit(s2io_closer);
+/**
+ * verify_load_parm -  verifies the module loadable parameters
+ * Descriptions: Verifies the module loadable paramters and initializes the
+ * Tx Fifo, Rx Ring and other paramters.
+ */
+
+int verify_load_parm()
+{
+	int fail = 0;
+	if (!((lso_enable == 0) || (lso_enable == 1))) {
+		printk("lso_enable can be either '1' or '0'\n");
+		fail = 1;
+	}
+	if ((indicate_max_pkts > (0xFFFFFFFF))) {
+		printk
+		    ("indicate_max_pkts can take value greater than zero but less than 2power(32)\n");
+		fail = 1;
+	}
+	if (!((cksum_offload_enable == 0) || (cksum_offload_enable == 1))) {
+		printk("cksum_offload_enable can be only '0' or '1' \n");
+		fail = 1;
+	}
+	if ((TxFifoNum == 0) || (TxFifoNum > 8)) {
+		printk("TxFifoNum can take value from 1 to 8\n");
+		fail = 1;
+	}
+	switch (TxFifoNum) {
+		case 8:
+		if ((TxFIFOLen_7 == 0) || TxFIFOLen_7 > 8192) {
+			printk("TxFIFOLen_7 can take value from 1 to 8192\n");
+			fail = 1;
+		}
+		case 7:
+		if ((TxFIFOLen_6 == 0) || TxFIFOLen_6 > 8192) {
+			printk("TxFIFOLen_6 can take value from 1 to 8192\n");
+			fail = 1;
+		}
+		case 6:	
+		if ((TxFIFOLen_5 == 0) || TxFIFOLen_5 > 8192) {
+			printk("TxFIFOLen_5 can take value from 1 to 8192\n");
+			fail = 1;
+		}	
+		case 5:
+		if ((TxFIFOLen_4 == 0) || TxFIFOLen_4 > 8192) {
+			printk("TxFIFOLen_4 can take value from 1 to 8192\n");
+			fail = 1;
+		}
+		case 4:
+		if ((TxFIFOLen_3 == 0) || TxFIFOLen_3 > 8192) {
+			printk("TxFIFOLen_3 can take value from 1 to 8192\n");
+			fail = 1;
+		}
+		case 3:	
+		if ((TxFIFOLen_2 == 0) || TxFIFOLen_2 > 8192) {
+			printk("TxFIFOLen_2 can take value from 1 to 8192\n");
+			fail = 1;
+		}
+		case 2:
+		if ((TxFIFOLen_1 == 0) || TxFIFOLen_1 > 8192) {
+			printk("TxFIFOLen_1 can take value from 1 to 8192\n");
+			fail = 1;
+		}
+		case 1:
+		if ((TxFIFOLen_0 == 0) || TxFIFOLen_0 > 8192) {
+			printk("TxFIFOLen_0 can take value from 1 to 8192\n");
+			fail = 1;
+		}
+	}
+	if ((MaxTxDs > 32) || (MaxTxDs < 1)) {
+		printk("MaxTxDs can take falue from 1 to 32\n");
+		fail = 1;
+	}
+	if ((RxRingNum > 8) || (RxRingNum < 1)) {
+		printk("RxRingNum can take falue from 1 to 8\n");
+		fail = 1;
+	}
+	switch(RxRingNum) {
+		case 8:
+		if (RxRingSz_7 < 1) {
+			printk("RxRingSz_7 can take value greater than 0\n");
+			fail = 1;
+		}
+		case 7:
+		if (RxRingSz_6 < 1) {
+			printk("RxRingSz_6 can take value greater than 0\n");
+			fail = 1;
+		}
+		case 6:
+		if (RxRingSz_5 < 1) {
+			printk("RxRingSz_5 can take value greater than 0\n");
+			fail = 1;
+		}
+		case 5:
+		if (RxRingSz_4 < 1) {
+			printk("RxRingSz_4 can take value greater than 0\n");
+			fail = 1;
+		}
+		case 4:
+		if (RxRingSz_3 < 1) {
+			printk("RxRingSz_3 can take value greater than 0\n");
+			fail = 1;
+		}
+		case 3:
+		if (RxRingSz_2 < 1) {
+			printk("RxRingSz_2 can take value greater than 0\n");
+			fail = 1;
+		}
+		case 2:
+		if (RxRingSz_1 < 1) {
+			printk("RxRingSz_1 can take value greater than 0\n");
+			fail = 1;
+		}
+		case 1:
+		if (RxRingSz_0 < 1) {
+			printk("RxRingSz_0 can take value greater than 0\n");
+			fail = 1;
+		}
+	}
+	if ((Stats_refresh_time < 1)) {
+		printk
+		    ("Stats_refresh_time cannot be less than 1 second \n");
+		fail = 1;
+	}
+	if (((rmac_pause_time < 0x10) && (rmac_pause_time != 0)) ||
+	    (rmac_pause_time > 0xFFFF)) {
+		printk
+		    ("rmac_pause_time can take value from 16 to 65535\n");
+		fail = 1;
+	}
+	if ((max_splits_trans < 0) || (max_splits_trans > 7)) {
+		printk("max_splits_trans can take value from 0 to 7\n");
+		fail = 1;
+	}
+	if ((mc_pause_threshold_q0q3 > 0xFE)) {
+		printk("mc_pause_threshold_q0q3 cannot exceed 254\n");
+		fail = 1;
+	}
+	if ((mc_pause_threshold_q4q7 > 0xFE)) {
+		printk("mc_pause_threshold_q4q7 cannot exceed 254\n");
+		fail = 1;
+	}
+	if ((latency_timer)
+	    && ((latency_timer < 8) /* || (latency_timer > 255) */ )) {
+		printk("latency_timer can take value from 8 to 255\n");
+		fail = 1;
+	}
+	if ((shared_splits > 31)) {
+		printk("shared_splits can exceed 31\n");
+		fail = 1;
+	}
+	if (rmac_util_period > 0xF) {
+		printk("rmac_util_period can exceed 15\n");
+		fail = 1;
+	}
+	if (tmac_util_period > 0xF) {
+		printk("tmac_util_period can exceed 15\n");
+		fail = 1;
+	}
+	if ((tx_utilz_periodic > 1) || (rx_utilz_periodic > 1)) {
+		printk
+		    ("tx_utilz_periodic & rx_utilz_periodic can be either "
+		     "'0' or '1'\n");
+		fail = 1;
+	}
+	if ((tx_urange_a > 127) || (tx_urange_b > 127)
+	    || (tx_urange_c > 127)) {
+		printk
+		    ("tx_urange_a, tx_urange_b & tx_urange_c can take value "
+		     "from 0 to 127\n");
+		fail = 1;
+	}
+	if ((rx_urange_a > 127) || (rx_urange_b > 127)
+	    || (rx_urange_c > 127)) {
+		printk
+		    ("rx_urange_a, rx_urange_b & rx_urange_c can take value "
+		     "from 0 to 127\n");
+		fail = 1;
+	}
+	if ((tx_ufc_a > 0xffff) || (tx_ufc_b > 0xffff) ||
+	    (tx_ufc_c > 0xffff) || (tx_ufc_d > 0xffff)) {
+		printk
+		    (" tx_ufc_a, tx_ufc_b, tx_ufc_c, tx_ufc_d can take value"
+		     "from 0 to 65535(0xFFFF)\n");
+		fail = 1;
+	}
+	if ((rx_ufc_a > 0xffff) || (rx_ufc_b > 0xffff) ||
+	    (rx_ufc_c > 0xffff) || (rx_ufc_d > 0xffff)) {
+		printk
+		    (" rx_ufc_a, rx_ufc_b, rx_ufc_c, rx_ufc_d can take value"
+		     "from 0 to 65535(0xFFFF)\n");
+		fail = 1;
+	}
+	return fail;
+}
+#ifdef SNMP_SUPPORT
+
+/**
+* fnBaseDrv - Get the driver information
+* @pBaseDrv -Pointer to Base driver structure which contains the offset 
+* and length of each of the field.
+* Description
+* This function copies the driver specific information from the dev structure
+* to the pBaseDrv stucture. It calculates the number of physical adapters by
+* parsing the dev_base global variable maintained by the kernel. This 
+* variable has to read locked before accesing.This function is called by
+* fnBaseReadProc function.
+*   
+*/
+              
+static void fnBaseDrv(struct stBaseDrv *pBaseDrv,struct net_device *dev)
+{
+                struct pci_dev *pdev = NULL;
+        struct net_device *ndev;
+        int nCount =0;
+        nic_t *sp = (nic_t *)dev->priv;
+
+        strncpy(pBaseDrv->m_cName,sp->cName,20);
+        strncpy(pBaseDrv->m_cVersion,sp->cVersion,20);
+        pBaseDrv->m_nStatus = sp->nLinkStatus;
+        pBaseDrv->m_nFeature = sp->nFeature;
+        pBaseDrv->m_nMemorySize = sp->nMemorySize;
+        sprintf(pBaseDrv->m_cDate,"%ld",sp->lDate);
+        /* Find all the ethernet devices on the system using pci_find_class.Get
+        the private data which will be the net_device structure assigned by the
+        driver.
+        */
+        while((pdev = pci_find_class((PCI_CLASS_NETWORK_ETHERNET <<8), pdev)))
+        {
+                ndev = (struct net_device *)pci_get_drvdata(pdev);
+		if(ndev == NULL)
+			break;	
+                memcpy(pBaseDrv->m_stPhyAdap[nCount].m_cName, ndev->name,20);
+                pBaseDrv->m_stPhyAdap[nCount].m_nIndex = ndev->ifindex;
+                nCount ++;
+        }
+        pBaseDrv->m_nPhyCnt = nCount;
+}
+/* 
+*  fnBaseReadProc - Read entry point for the proc file  
+*  @page - Buffer pointer where the data is written
+*  @start- Pointer to buffer ptr . It is used if the data is more than a page
+*  @off- the offset to the page where data is written
+*  @count - number of bytes to write
+*  @eof - to indicate end of file
+*  @data - pointer to device structure.
+*
+* Description - 
+* This function gets   Base driver specific information from the fnBaseDrv func * tion and writes into the BDInfo file. This function is called whenever the use* r reads the file. The length of data written cannot exceed 4kb. If it exceeds * then use the start pointer to write multiple pages                                                                                 
+* Return - the length of the string written to proc file
+*/
+
+static int fnBaseReadProc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+        struct stBaseDrv *pBaseDrv;
+        int nLength = 0;
+        int nCount = 0;
+        struct net_device *dev= (struct net_device *)data;
+        int nIndex =0;
+
+        pBaseDrv= kmalloc(sizeof(struct stBaseDrv),GFP_KERNEL);
+        if(pBaseDrv == NULL)
+        {
+                printk("Error allocating memory\n");
+                return -ENOMEM;
+        }
+        fnBaseDrv(pBaseDrv,dev);
+        sprintf(page + nLength,"%-30s%-20s\n","Base Driver Name",
+            pBaseDrv->m_cName);
+        nLength += 51;
+        if(pBaseDrv->m_nStatus == 1)
+                sprintf(page + nLength,"%-30s%-20s\n","Load Status","Loaded");
+
+        else
+                sprintf(page + nLength,"%-30s%-20s\n","Load Status","UnLoaded");  
+        nLength += 51;
+        sprintf(page + nLength,"%-30s%-20s\n","Base Driver Version",
+            pBaseDrv->m_cVersion);
+        nLength += 51;
+
+        sprintf(page + nLength,"%-30s%-20d\n","Feature Supported",
+            pBaseDrv->m_nFeature);
+        nLength += 51;
+
+        sprintf(page + nLength,"%-30s%-20d\n","Base Driver Memrory in Bytes",
+            pBaseDrv->m_nMemorySize);
+        nLength += 51;
+
+        sprintf(page + nLength,"%-30s%-20s\n","Base Driver Date",
+            pBaseDrv->m_cDate);
+        nLength += 51;
+
+        sprintf(page + nLength,"%-30s%-20d\n","No of Phy Adapter",
+            pBaseDrv->m_nPhyCnt);
+        nLength += 51;
+        sprintf(page + nLength,"%-20s%-20s\n\n","Phy Adapter Index",
+            "Phy Adapter Name");
+        nLength +=42;
+
+        for(nIndex=0,nCount=pBaseDrv->m_nPhyCnt; nCount != 0; nCount--,nIndex++)
+        {
+                sprintf(page + nLength,"%-20d%-20s\n",
+                    pBaseDrv->m_stPhyAdap[nIndex].m_nIndex,
+                    pBaseDrv->m_stPhyAdap[nIndex].m_cName);
+                nLength += 41;
+        }
+
+        *eof =1;
+        kfree(pBaseDrv);
+        return nLength;
+}
+
+/* 
+*  fnPhyAdapReadProc - Read entry point for the proc file  
+*  @page - Buffer pointer where the data is written
+*  @start- Pointer to buffer ptr . It is used if the data is more than a page
+*  @off- the offset to the page where data is written
+*  @count - number of bytes to write
+*  @eof - to indicate end of file
+*  @data - pointer to device structure.
+*
+* Description - 
+* This function gets  physical adapter information. This function is called
+*  whenever the use* r reads the file. The length of data written cannot
+*  exceed 4kb. If it exceeds * then use the start pointer to write multiple page* Return - the length of the string written to proc file
+*/
+static int fnPhyAdapReadProc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+
+        struct stPhyData *pPhyData;
+        pPhyData= kmalloc(sizeof(struct stPhyData),GFP_KERNEL);
+        if(pPhyData == NULL)
+        {
+                printk("Error allocating memory\n");
+                return -ENOMEM;
+        }
+
+        struct net_device *pNetDev;
+        struct net_device_stats *pNetStat;
+        int nLength = 0;
+        unsigned char cMAC[20];
+
+        /* Print the header in the PhyAdap proc file*/
+        sprintf(page + nLength,"%-10s%-22s%-10s%-10s%-22s%-22s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s%-10s\n",
+                        "Index","Description","Mode","Type","Speed",
+                        "MAC","Status","Slot","Bus","IRQ","Colis",
+                        "Multi","RxBytes","RxDrop","RxError","RxPacket",
+                        "TRxBytes","TRxDrop","TxError","TxPacket");
+
+        /* 237 is the lenght of the above string copied in the page  */
+        nLength +=237;
+
+        struct pci_dev *pdev = NULL;
+        /*pci_find_class will return to the pointer to the pdev structure
+         * for all the network devices using PCI_CLASS_NETWORK_ETHERNET 
+         * .The third argument is pointer to previous pdev structure.Initailly
+         * it has to be null*/
+        while((pdev = pci_find_class((PCI_CLASS_NETWORK_ETHERNET <<8), pdev)))
+         {
+                /* Private data will point to the netdevice structure*/
+                pNetDev =(struct net_device *) pci_get_drvdata(pdev);
+                if(pNetDev == NULL)
+                        continue;
+                if(pNetDev->addr_len != 0)
+                {
+                        pNetStat = pNetDev->get_stats(pNetDev);
+                        pPhyData->m_nIndex = pNetDev->ifindex;
+                        memcpy(pPhyData->m_cDesc,pNetDev->name,20);
+                        pPhyData->m_nMode = 0;
+                        pPhyData->m_nType = 0;
+                        switch( pPhyData->m_nType)
+                        {
+                /*              case IFT_ETHER:
+                                    memcpy(pPhyData->m_cSpeed,"10000000",20);
+                                    break;
+
+                                case 9:
+                                    memcpy(pPhyData->m_cSpeed,"4000000",20);
+                                    break;*/
+                                default :
+                                    memcpy(pPhyData->m_cSpeed,"10000000",20);
+                                    break;
+                        }
+                        memcpy(pPhyData->m_cPMAC,pNetDev->dev_addr,ETH_ALEN);
+                        memcpy(pPhyData->m_cCMAC,pNetDev->dev_addr,ETH_ALEN);
+                        pPhyData->m_nLinkStatus=test_bit(__LINK_STATE_START,
+                                        &pNetDev->state);
+                        pPhyData->m_nPCISlot = PCI_SLOT(pdev->devfn);
+                        pPhyData->m_nPCIBus = pdev->bus->number;
+
+                        pPhyData->m_nIRQ =pNetDev->irq;
+                        pPhyData->m_nCollision = pNetStat->collisions;
+                        pPhyData->m_nMulticast = pNetStat->multicast;
+
+                        pPhyData->m_nRxBytes =pNetStat->rx_bytes;
+                        pPhyData->m_nRxDropped =pNetStat->rx_dropped;
+                        pPhyData->m_nRxErrors = pNetStat->rx_errors;
+                        pPhyData->m_nRxPackets = pNetStat->rx_packets;
+
+                        pPhyData->m_nTxBytes =pNetStat->tx_bytes;
+                        pPhyData->m_nTxDropped =pNetStat->tx_dropped;
+                        pPhyData->m_nTxErrors = pNetStat->tx_errors;
+                        pPhyData->m_nTxPackets = pNetStat->tx_packets;
+
+                        sprintf(cMAC,"%02x:%02x:%02x:%02x:%02x:%02x",
+                        pPhyData->m_cPMAC[0],pPhyData->m_cPMAC[1],
+                        pPhyData->m_cPMAC[2],pPhyData->m_cPMAC[3],
+                        pPhyData->m_cPMAC[4],pPhyData->m_cPMAC[5]);
+                        sprintf(page + nLength,"%-10d%-22s%-10d%-10d%-22s%-22s%-10d%-10d%-10d%-10d%-10d%-10d%-10d%-10d%-10d%-10d%-10d%-10d%-10d%-10d\n",
+                                        pPhyData->m_nIndex,
+                                        pPhyData->m_cDesc,pPhyData->m_nMode,
+                                        pPhyData->m_nType, pPhyData->m_cSpeed,
+                                        cMAC, pPhyData->m_nLinkStatus ,
+                                        pPhyData->m_nPCISlot,
+                                        pPhyData->m_nPCIBus, pPhyData->m_nIRQ,
+                                        pPhyData->m_nCollision,
+                                        pPhyData->m_nMulticast,
+                                        pPhyData->m_nRxBytes,
+                                        pPhyData->m_nRxDropped,
+                                        pPhyData->m_nRxErrors,
+                                        pPhyData->m_nRxPackets,
+                                        pPhyData->m_nTxBytes,
+                                        pPhyData->m_nTxDropped,
+                                        pPhyData->m_nTxErrors,
+                                        pPhyData->m_nTxPackets);
+                        nLength +=237;
+          }
+    }
+
+        *eof=1;
+
+        kfree(pPhyData);
+        return nLength;
+}
+
+/* 
+* s2io_bdsnmp_init - Entry point to create proc file
+* @dev-  Pointer to net device structure passed by the driver.
+* Return 
+* Success If creates all the files
+* ERROR_PROC_ENTRY /ERROR_PROC_DIR Error If could not create all the files
+* Description
+* This functon is called when the driver is loaded. It creates the S2IO proc file sys* tem in the /proc/net/ directory. This directory is used to store the info* about the base driver afm driver, lacp, vlan  and nplus.
+* It checks if S2IO directory already exists else creates it and creates the fil* es BDInfo  files and assiciates read funct* ion to each of the files.
+*/
+
+int s2io_bdsnmp_init(struct net_device *dev)
+{
+        struct proc_dir_entry *S2ioDir;
+        struct proc_dir_entry *BaseDrv;
+        struct proc_dir_entry *PhyAdap;
+        int nLength = 0;
+
+        nLength = strlen(S2IODIRNAME);
+        /* IF the directory already exists then just return*/
+        for(S2ioDir=proc_net->subdir; S2ioDir != NULL; S2ioDir = S2ioDir->next)
+        {
+                if((S2ioDir->namelen == nLength) &&
+                 (!memcmp(S2ioDir->name,S2IODIRNAME,nLength)))
+                break;
+        }
+        if(S2ioDir == NULL)
+        /* Create the s2io directory*/
+        if(!(S2ioDir = create_proc_entry(S2IODIRNAME,S_IFDIR,proc_net)))
+        {
+                DBG_PRINT(INIT_DBG,"Error Creating Proc directory for SNMP\n");
+                return ERROR_PROC_DIR;
+        }
+        /* Create the BDInfo file to store driver info and associate read funtion*/
+       if(!(BaseDrv = create_proc_read_entry(BDFILENAME,S_IFREG | S_IRUSR,
+                        S2ioDir,fnBaseReadProc,(void *)dev))){
+                DBG_PRINT(INIT_DBG,"Error Creating Proc File for Base Drvr\n");
+                return ERROR_PROC_ENTRY;
+        }
+       if(!(PhyAdap = create_proc_read_entry(PADAPFILENAME,S_IFREG | S_IRUSR,
+                S2ioDir,fnPhyAdapReadProc, (void *)dev))){
+              DBG_PRINT(INIT_DBG,"Error Creating Proc File for Phys Adap\n");
+               return ERROR_PROC_ENTRY;
+        }
+
+
+        return SUCCESS;
+}
+/* s2io_bdsnmp_rem : Removes the proc file entry
+* @dev - pointer to netdevice structre
+* Return - void
+* Description
+* This functon is called when the driver is Unloaded. It checks if the S2IO dire* ctoy exists and deletes the files in the reverse order of creation.
+*/
+
+void s2io_bdsnmp_rem(struct net_device *dev)
+{
+        int nLength = 0;
+        struct proc_dir_entry *S2ioDir;
+        nLength = strlen(S2IODIRNAME);
+        /* Check if the S2IO directory exists or not and then delete all the files in the S2IO Directory*/
+       for(S2ioDir = proc_net->subdir; S2ioDir != NULL; S2ioDir = S2ioDir->next)
+        {
+                if((S2ioDir->namelen == nLength) &&
+                                 (!memcmp(S2ioDir->name,S2IODIRNAME,nLength)))
+
+                break;
+        }
+        if(S2ioDir == NULL)
+                return;
+        remove_proc_entry(BDFILENAME,S2ioDir);
+        remove_proc_entry(PADAPFILENAME,S2ioDir);
+        if(S2ioDir->subdir == NULL){
+            remove_proc_entry(S2IODIRNAME,proc_net);
+        }
+}
+#endif
+
+                                                              
+/*  To build the driver, 
+gcc -D__KERNEL__ -DMODULE -I/usr/src/linux-2.4/include -Wall -Wstrict-prototypes -O2 -c s2io.c
+*/
+/*
+ *$Log: s2io.c,v $
+ *Revision 1.143.2.11  2004/06/29 07:01:49  arao
+ *Bug:694
+ *Fixed the flood ping problem reported in bug: 1017
+ *
+ *Revision 1.143.2.10  2004/06/24 02:21:28  dyusupov
+ *Bug: 903
+ *piors removed
+ *new makefile to support cross-compiling
+ *
+ *Revision 1.143.2.9  2004/06/23 01:18:56  rvatsava
+ *bug: 941
+ *Proper Tx fifo pointer initialisation is required.
+ *
+ *Revision 1.143.2.8  2004/06/22 22:01:41  rvatsava
+ *bug: 1017
+ *Fixed the IBM platform specific issue. However, due to recent
+ *changes in TX path flood ping is not working properly. So need to revisit
+ *the TX related changes.
+ *
+ *Revision 1.143.2.7  2004/06/22 09:12:37  arao
+ *Bug:902
+ *The mac control structure is split into tx,rx and st in the MAC macro
+ *
+ *Revision 1.143.2.6  2004/06/22 05:54:57  arao
+ *Bug:694
+ *The txd logic has been kept in TXDBD macro.
+ *
+ *Revision 1.143.2.5  2004/06/18 12:01:18  rkoushik
+ *Bug:1018
+ *Fixed NAPI compiler error bug reported by HP. Also changed
+ *"dev->weight" to 64 from 128. In s2io_set_link removed
+ *the conditional check for queue_stopped as this was creating
+ *a problem every time the cable is plugged out and plugged in
+ *again.
+ *Iam looking at any other changes that can be done towards
+ *enhancing NAPI implementation. Will check in again if there
+ *are any new favourable developments.
+ *
+ *-Koushik
+ *
+ *Revision 1.143.2.4  2004/06/14 09:21:08  arao
+ *Bug:921
+ *Added the __devexit_p macro for remove entry point and replaced __exit with __devexit macro for s2io_rem_nic function
+ *
+ *Revision 1.143.2.3  2004/06/11 12:34:14  arao
+ *Bug:576
+ *pci->driver_data not defined in the kernel 2.6 so replacing with pci_get_drvdata function
+ *
+ *Revision 1.143.2.2  2004/06/10 14:07:14  arao
+ *Bug: 576
+ *SNMP Support
+ *
+ *Revision 1.143.2.1  2004/06/08 10:19:02  rkoushik
+ *Bug: 940
+ * Made the changes to sync up the s2io_close function with
+ *s2io_xmit and also the tasks scheduled by the driver which
+ * could be running independently on a different CPU.
+ *Also fixed the issue raised by bug # 867
+ *(disabling relaxed ordering feature.).
+ *
+ *-Koushik
+ *
+ *Revision 1.143  2004/05/31 12:21:16  rkoushik
+ *Bug: 986
+ *
+ *In this check in Iam making the fixes listed below,
+ *1. Handling the PCC_FB_ECC_ERR interrupt as specified in the new UG.
+ *2. Also queuing a task to reset the NIC when a serious Error is detected.
+ *3. The rmac_err_reg is cleared immediately in the Intr handler itself instead of the queued task 's2io_set_link'.
+ *
+ *Koushik
+ *
+ *Revision 1.142  2004/05/24 12:29:39  rkoushik
+ *Bug: 984
+ * free_rx_buffer for 2buffer mode was clearing the END_OF_BLOCK
+ *marker too, which resulted in this error. Also there was an
+ *extra increment of a counter. Both these are fixed in this check-in.
+ *
+ *Koushik
+ *
+ *Revision 1.141  2004/05/20 12:38:37  rkoushik
+ *Bug: 970
+ *Macro was not declared properly in s2io.c and RxD_t structure for
+ *2BUFF mode was declared incorrectly in s2io.h leading to problems.
+ *Both rectified in this checkin.
+ *
+ *-Koushik
+ *
+ *Revision 1.140  2004/05/18 09:52:05  rkoushik
+ *Bug: 935
+ * Updating the 2Buff mode changes and fix for the new Link LED problem
+ *into the CVS head.
+ *
+ *- Koushik
+ *
+ *Revision 1.139  2004/05/14 14:14:23  arao
+ *Bug: 885
+ *KNF standard for function names and comments are updated to generate Html document
+ *
+ *Revision 1.138  2004/05/14 00:59:56  dyusupov
+ *Bug: 922
+ *new fields been added to the ethtool_ops in 2.6.0 and 2.4.23.
+ *Doing appropriate compile time check for this.
+ *
+ *Revision 1.137  2004/05/13 19:30:06  dyusupov
+ *Bug: 943
+ *
+ *REL_1-7-2-3_LX becomes HEAD now.
+ *
+ *Revision 1.119  2004/04/22 02:12:30  rvatsava
+ *bug:878
+ *
+ *Avoiding general Protection Fault when attempt to disable Xena while
+ *running Nttcp.
+ *
+ *Revision 1.118  2004/04/22 01:45:48  rvatsava
+ *bug:883
+ *
+ *Avoiding possible deadlock in s2io_close().
+ *
+ *Revision 1.117  2004/04/19 05:58:16  araju
+ *Bug: 551
+ *Fixed the performance Issue. there was a mistake in RTI programming
+ *
+ *Revision 1.116  2004/04/07 09:58:30  araju
+ *Bug: 551
+ *Loadable Parameters added.
+ *
+ *Revision 1.115  2004/04/07 00:04:07  aravi
+ *Bug: 872
+ *Set outstanding split transactions to 3 for Itanium and 2 for other systems.
+ *
+ *Revision 1.114  2004/04/06 23:52:16  aravi
+ *Bug: 871
+ *Added PCI read at the end of s2io_isr and s2io_xmit to flush previous writes.
+ *Without this, on certain systems(SGI), it would cause "connection loss" on
+ *transmit test.
+ *
+ *Revision 1.113  2004/04/06 18:27:19  aravi
+ *Bug: 813
+ *Fix for ftp failure(out of memory condition).
+ *1. In s2io_tasklet(), clear bit before returning in case of mem alloc failure.
+ *2. In rx_buffer_level(), change threshold for LOW from 128 to 16.
+ *
+ *Revision 1.112  2004/03/30 10:14:01  rkoushik
+ *Bug: 840
+ *Adding #endif in s2io_init_nic
+ *Koushik
+ *
+ *Revision 1.111  2004/03/26 12:38:59  rkoushik
+ *Bug: 832
+ *  In this checkin, I have made a few cosmetic changes to the files
+ *s2io.c and s2io.h with a view to minimize the diffs between the
+ *files in the repository and those given to open source.
+ *
+ *-Koushik
+ *
+ *Revision 1.110  2004/03/19 06:41:10  rkoushik
+ *Bug: 765
+ *
+ *	This checkin fixes the Multiple Link state displays
+ *during link state change, whichwas  happening due to a very small
+ *delay in the alarm Intr handler.
+ *This checkin also addresses the Comment 13 of Jeffs latest set of comments
+ *which provided a new way to identify the No TxD condition in s2io_xmit
+ *routine. This was part of the Bug # 760, which will also be moved to fixed
+ *state.
+ *
+ *Koushik
+ *
+ *Revision 1.109  2004/03/15 07:22:09  rkoushik
+ *Bug: 765
+ *To solve the multiple Link Down displays when the Nic's Link state
+ *changes. further info in the bug.
+ *
+ *Koushik
+ *
+ *Revision 1.108  2004/03/15 05:34:23  rkoushik
+ *Bug: 613
+ *Removed the device capability to drop packets received with L/T field mismatch.
+ *rmac_err_cfg register is no longer being configured to enable this feature.
+ *
+ *Koushik
+ *
+ *Revision 1.107  2004/03/12 04:48:26  araju
+ *Bug: 755
+ *set rx/tx chksum offload independently
+ *
+ *Revision 1.106  2004/03/11 11:57:18  rkoushik
+ *Bug: 760
+ *Has addressed most of the issues with a few exceptions, namely
+ *Issue # 13 - Modifying the no_txd logic in s2io_xmit.
+ *	I will add this by monday after some local testing.
+ *
+ *Issue # 15 - Does get_stats require locking?
+ *	I don't think so, because we just reflect what ever the
+ *	statistics block is reflecting at the current moment.
+ *
+ *Issue # 16 - Reformant the function header comments.
+ *	Does not look like a priority issue. Will address this
+ *	in the next patch along with issue # 20.
+ *
+ *Issue # 20 - Provide a ethtool patch for proper dumping registers and EEPROM.
+ *	Will address this in the next submission patch.
+ *
+ *Koushik
+ *
+ *Revision 1.105  2004/03/03 13:32:24  rkoushik
+ *Bug: 760
+ *	This checkin addresses Bug 5 - 12 (Bug # 0 - 4 is valid only
+ *for distribution code.)
+ *
+ *Koushik
+ *
+ *Revision 1.103  2004/02/27 14:37:36  rkoushik
+ *Bug: 748
+ *Driver submission comments given by Jeff,
+ *details given in the bug.
+ *
+ *Koushik
+ *
+ *Revision 1.102  2004/02/17 00:40:03  aravi
+ *Bug: 724
+ *Removed inclusion of util.h
+ *
+ *Revision 1.101  2004/02/11 17:48:02  aravi
+ *Bug: 669
+ *A comment embedded inside a comment was causing compilation failure.
+ *Fixed this.
+ *
+ *Revision 1.100  2004/02/11 03:00:06  aravi
+ *Bug: 669
+ *The source is modified to reflect the suggested changes with the bug 669.
+ *A few comments which are not incorporated:
+ *        *)      // Enable DTX_Control registers.
+ *                write64(&bar0->dtx_control, 0x8000051500000000);
+ *                udelay(50);
+ *
+ *                -> this is a loop in disguise.
+ *        *)
+ *                if(skb == NULL) {
+ *                                DBG_PRINT(ERR_DBG,"%s: NULL skb ",dev->name);
+ *                                DBG_PRINT(ERR_DBG,"in Tx Int\n");
+ *                                spin_unlock(&nic->tx_lock);
+ *
+ *                -> just goto to the normal spin_unlock and avoid an
+ *extra return
+ *     *) #ifdef AS_A_MODULE
+ *                MODULE_AUTHOR("Raghavendra Koushik <raghavendra.koushik@s2io.com>");
+ *                MODULE_LICENSE("GPL"); MODULE_PARM(ring_num, "1-"
+ *__MODULE_STRING(1) "i");
+ *
+ *Revision 1.99  2004/02/10 11:58:35  rkoushik
+ *Bug: 668
+ *Eliminated usage of self declared type 'dmaaddr_t' and also
+ *eliminated the usage of PPC64_ARCH macro which was prevalent in the older code.
+ *Further details in the bug.
+ *
+ *Koushik
+ *
+ *Revision 1.98  2004/02/09 10:31:34  rkoushik
+ *Bug: 656
+ * Made the changes suggested in Bug # 656.
+ *
+ *Koushik
+ *
+ *Revision 1.97  2004/02/07 02:16:17  gkotlyar
+ *Bug: 682
+ *OST and MMRBC fields of the PCI-X command registerd were overwritten
+ *whenever we called s2io_reset().  In addition, we did not initialiaze the OST bits before writing into it.
+ *
+ *Revision 1.96  2004/02/05 06:08:21  rkoushik
+ *Bug: 693
+ *Added stop_queue & wake_queue in s2io_link and the watchdog timer
+ *resets Nic only if the Link state is up. Details mentioned in Bug # 693.
+ *
+ *Koushik
+ *
+ *Revision 1.95  2004/02/04 04:52:35  rkoushik
+ *Bug: 667
+ * Indented the code using indent utility. Details of the options
+ *used are specified in bug # 667
+ *
+ *Koushik
+ *
+ *Revision 1.94  2004/02/02 12:03:32  rkoushik
+ *Bug: 643
+ *The tx_pkt_ptr variable has been removed. Tx watchdog function now does
+ *a s2io_close followed by s2io_open calls to reset and re-initialise NIC.
+ *The Tx Intr scheme is made dependednt on the size of the Progammed FIFOs.
+ *
+ *-Koushik
+ *
+ *Revision 1.93  2004/01/29 05:41:24  rkoushik
+ *Bug: 657
+ *Loop back test is being removed from the driver as one of ethtool's test
+ *option.
+ *
+ *Koushik
+ *
+ *Revision 1.92  2004/01/29 04:01:48  aravi
+ *Bug: 639
+ *Added code for activity and Link LED
+ *
+ *Revision 1.91  2004/01/28 05:57:36  rkoushik
+ *Bug: 603
+ * The Fix is under a #if 1 macro in the tx_intr_handler function.
+ *Please verify using nttcp stress tests for long duration and confirm if
+ *the fix works on all platforms. If it does I will rid the #if macro
+ *and make it part of the mainstream code.
+ *
+ *Koushik
+ *
+ *Revision 1.90  2004/01/28 05:39:07  rkoushik
+ *Bug: 520
+ * The s2io_set_multicast function was corrected.
+ *The Mac_cfg register was not being written after writing into its key register
+ *hence the NIC was not going into promiscous mode. Also to set All_Multi mode
+ *the RMAC's data0 and data1 registers were being incorrectly written.
+ *Both mistakes were rectified.
+ *
+ *Koushik
+ *
+ *Revision 1.89  2004/01/23 12:08:29  rkoushik
+ *Bug: 549
+ *Added the beacon feature for new celestica cards using GPIO.
+ *test it out using the ethtool utility on both
+ *the new and old cards in both Link Up and Down states.
+ *
+ *Koushik
+ *
+ *Revision 1.88  2004/01/19 21:12:44  aravi
+ *Bug: 599
+ *Got rid of compilation error due to variable declaration after assignment.
+ *
+ *Bug: 593
+ *Fixed Tx Link loss problem by
+ *1. checking for put pointer not going beyond get pointer
+ *2. set default tx descriptors to 4096( done in s2io.h)
+ *3. Set rts_frm_len register to MTU size.
+ *4. Corrected the length used for address unmapping in
+ *    tx intr handler.
+ *
+ *Revision 1.87  2004/01/19 09:50:59  rkoushik
+ *Bug: 598
+ * Added GPL notices on the driver source files, namely
+ *s2io.c, s2io.h and regs.h
+ *
+ *Koushik
+ *
+ *Revision 1.86  2004/01/19 05:21:57  rkoushik
+ *Bug: 614
+ *The XAUI configuration was being done using old values mistakenly.
+ *The init_nic func was modified with the new values for XAUI configuration.
+ *
+ *-Koushik
+ *
+ *Revision 1.85  2004/01/13 13:13:05  rkoushik
+ *Bug: 449
+ * The driver source has been modified to follow most of the suggestion given
+ *by the codingStyle document in the linux Documentation folder.
+ *Also some coding errors identified by Steve Modica mentioned in bug # 536
+ *have also been set right.
+ *
+ *Koushik
+ *
+ *Revision 1.84  2004/01/02 09:43:28  rkoushik
+ *Bug: 581
+ *Resetting Nic after performing RldRam test so as to remove RldRam from
+ *Test Mode.
+ *
+ *-Koushik
+ *
+ *Revision 1.83  2004/01/01 00:19:46  aravi
+ *Bug: 570
+ *Fixed race condition in Transmit path.
+ *
+ *Revision 1.82  2003/12/30 13:03:14  rkoushik
+ *Bug: 177
+ *The driver has been updated with support for funtionalities in ethtool
+ *version 1.8. Interrupt moderation has been skipped as the methodology to
+ *set it using ethtool is different to our methodology.
+ *
+ *-Koushik
+ *
+ *Revision 1.81  2003/12/16 20:43:38  ukiran
+ *Bug:542
+ *Workaround to address TX FIFO full condition
+ *
+ *Revision 1.80  2003/12/15 23:27:47  ukiran
+ *Bug: 536
+ *Changed buffer replenishing algorithm. Initializing receive memory.
+ *
+ *Revision 1.79  2003/12/15 05:08:06  rkoushik
+ *Bug: 516
+ * The Fix is against the problem seen by Lawerence Livermore people.
+ *Further details on the problem and the fix is available in
+ *bug # 516 of bugtrak.
+ *
+ *-Koushik
+ *
+ *Revision 1.78  2003/12/02 19:56:48  ukiran
+ *Bug:524
+ *Fix for all "FFs" MAC address problems on HP/Alpha platforms
+ *
+ *Revision 1.77  2003/12/02 19:53:12  ukiran
+ *Bug:510
+ *Cleanup of 
+ chars
+ *
+ *Revision 1.76  2003/11/19 02:23:02  ukiran
+ *Bug:473
+ *Fix to address link down condition with misbehaving switches
+ *
+ *Revision 1.75  2003/11/14 01:53:36  ukiran
+ *Bug:493
+ *pci_set_consistent_dma_mask() is supported in kernels >2.6.0-test7.
+ *Need to figure out whether it will be backported to 2.4.xx kernels.
+ *
+ *Revision 1.74  2003/11/12 05:32:06  rkoushik
+ *Bug: 493
+ *Added a kernel version check around the pci_set_consistent_dma_mask
+ *function as specified in the latest comment of Bug # 493
+ *
+ *-Koushik
+ *
+ *Revision 1.73  2003/11/08 02:28:56  ukiran
+ *Bug:493
+ *Made the fix suggested by the customer. Added pci_set_consistent_dma_mask() after pci_set_dma_mask(). This might help in resolving pci_alloc_consistent failures at SGI.
+ *we cannot verify this problem in our lab. We will verify at SGI.
+ *Most of the drivers in public domain are not invoking this function.
+ *So this problem exists in their adapters. However, tigon driver has
+ *a fix for it.
+ *
+ *-Uday
+ *
+ *Revision 1.72  2003/11/07 10:22:40  rkoushik
+ *Bug: 492
+ *Changed as per the info provided in Bug # 492.
+ *
+ *Revision 1.71  2003/11/04 02:06:56  ukiran
+ *Bug:484
+ *Enabling Logs in source code
+ *
+ */
diff -u linux-2.6.7/drivers/net/s2io.h~ linux-2.6.7/drivers/net/s2io.h
--- linux-2.6.7/drivers/net/s2io.h~	2004-08-11 14:04:32.748201299 +0200
+++ linux-2.6.7/drivers/net/s2io.h	2004-08-11 15:49:48.554183830 +0200
@@ -13,9 +13,14 @@
 #ifndef _S2IO_H
 #define _S2IO_H
 
+#define TXDBD
+#define MAC
+#define LATEST_CHANGES	1
+#define SNMP_SUPPORT
 #define TBD 0
 #define BIT(loc)		(0x8000000000000000ULL >> (loc))
 #define vBIT(val, loc, sz)	(((u64)val) << (64-loc-sz))
+#define INV(d)  ((d&0xff)<<24) | (((d>>8)&0xff)<<16) | (((d>>16)&0xff)<<8)| ((d>>24)&0xff)
 
 #ifndef BOOL
 #define BOOL    int
@@ -49,6 +54,10 @@
 #define ALIGN_SIZE  			127
 #define	PCIX_COMMAND_REGISTER	0x62
 
+#ifndef SET_ETHTOOL_OPS
+#define SUPPORTED_10000baseT_Full (1 << 12)
+#endif
+
 /*
  * Debug related variables.
  */
@@ -411,6 +420,7 @@
 #define HEADER_802_2_SIZE              3
 #define HEADER_SNAP_SIZE               5
 #define HEADER_VLAN_SIZE               4
+#define HEADER_ALIGN_LAYER_3           2
 
 #define MIN_MTU                       46
 #define MAX_PYLD                    1500
@@ -507,36 +517,80 @@
 #define RXD_GET_L4_CKSUM(val)   ((u16)(val) & 0xFFFF)
 
 	u64 Control_2;
+#ifndef CONFIG_2BUFF_MODE
 #define MASK_BUFFER0_SIZE       vBIT(0xFFFF,0,16)
 #define SET_BUFFER0_SIZE(val)   vBIT(val,0,16)
+#else
+#define MASK_BUFFER0_SIZE       vBIT(0xFF,0,16)
+#define MASK_BUFFER1_SIZE       vBIT(0xFFFF,16,16)
+#define MASK_BUFFER2_SIZE       vBIT(0xFFFF,32,16)
+#define SET_BUFFER0_SIZE(val)   vBIT(val,8,8)
+#define SET_BUFFER1_SIZE(val)   vBIT(val,16,16)
+#define SET_BUFFER2_SIZE(val)   vBIT(val,32,16)
+#endif
+
 #define MASK_VLAN_TAG           vBIT(0xFFFF,48,16)
 #define SET_VLAN_TAG(val)       vBIT(val,48,16)
 #define SET_NUM_TAG(val)       vBIT(val,16,32)
 
+#ifndef CONFIG_2BUFF_MODE
 #define RXD_GET_BUFFER0_SIZE(Control_2) (u64)((Control_2 & vBIT(0xFFFF,0,16)))
-/*    
-#define TXD_GET_BUFFER1_SIZE(Control_2) (u16)((Control_2 & MASK_BUFFER1_SIZE) >> (63-31))  
-#define TXD_GET_BUFFER2_SIZE(Control_2) (u16)((Control_2 & MASK_BUFFER2_SIZE) >> (63-47))  
-*/
+#else
+#define RXD_GET_BUFFER0_SIZE(Control_2) (u8)((Control_2 & MASK_BUFFER0_SIZE) \
+							>> 48)
+#define RXD_GET_BUFFER1_SIZE(Control_2) (u16)((Control_2 & MASK_BUFFER1_SIZE) \
+							>> 32)
+#define RXD_GET_BUFFER2_SIZE(Control_2) (u16)((Control_2 & MASK_BUFFER2_SIZE) \
+							>> 16)
+#define BUF0_LEN	40
+#define BUF1_LEN	1
+#endif
+
 	u64 Buffer0_ptr;
+#ifdef CONFIG_2BUFF_MODE
+	u64 Buffer1_ptr;
+	u64 Buffer2_ptr;
+#endif
 } RxD_t;
 
-
 /* Structure that represents the Rx descriptor block which contains 
  * 128 Rx descriptors.
  */
+#ifndef CONFIG_2BUFF_MODE
 typedef struct _RxD_block {
 #define MAX_RXDS_PER_BLOCK             127
 	RxD_t rxd[MAX_RXDS_PER_BLOCK];
 
 	u64 reserved_0;
 #define END_OF_BLOCK    0xFEFFFFFFFFFFFFFFULL
-	u64 reserved_1;		/* 0xFEFFFFFFFFFFFFFF to mark last Rxd in this blk */
-	u64 reserved_2_pNext_RxD_block;	/*@ Logical ptr to next */
-	u64 pNext_RxD_Blk_physical;	/* Buff0_ptr.
-					   In a 32 bit arch the upper 32 bits 
-					   should be 0 */
+	u64 reserved_1;		/* 0xFEFFFFFFFFFFFFFF to mark last 
+				 * Rxd in this blk */
+	u64 reserved_2_pNext_RxD_block;	/* Logical ptr to next */
+	u64 pNext_RxD_Blk_physical;	/* Buff0_ptr.In a 32 bit arch
+					 * the upper 32 bits should 
+					 * be 0 */
 } RxD_block_t;
+#else
+typedef struct _RxD_block {
+#define MAX_RXDS_PER_BLOCK             85
+	RxD_t rxd[MAX_RXDS_PER_BLOCK];
+
+#define END_OF_BLOCK    0xFEFFFFFFFFFFFFFFULL
+	u64 reserved_1;		/* 0xFEFFFFFFFFFFFFFF to mark last Rxd 
+				 * in this blk */
+	u64 pNext_RxD_Blk_physical;	/* Phy ponter to next blk. */
+} RxD_block_t;
+#define SIZE_OF_BLOCK	4096
+
+/* Structure to hold virtual addresses of Buf0 and Buf1 in 
+ * 2buf mode. */
+typedef struct bufAdd {
+	void *ba_0_org;
+	void *ba_1_org;
+	void *ba_0;
+	void *ba_1;
+} buffAdd_t;
+#endif
 
 /* Structure which stores all the MAC control parameters */
 
@@ -559,6 +613,9 @@
 typedef struct {
 	u32 offset;
 	u32 fifo_len;
+    #ifdef TXDBD
+    u32 block_index;
+    #endif
 } tx_curr_get_info_t;
 
 typedef tx_curr_get_info_t tx_curr_put_info_t;
@@ -566,6 +623,75 @@
 /* Infomation related to the Tx and Rx FIFOs and Rings of Xena
  * is maintained in this structure.
  */
+#ifdef MAC
+typedef struct mac_info_rx {
+/* rx side stuff */
+    u32 rxd_ring_mem_sz;
+
+    /* Put pointer info which indictes which RxD has to be replenished 
+     * with a new buffer.
+     */
+    rx_curr_put_info_t rx_curr_put_info[MAX_RX_RINGS];
+
+    /* Get pointer info which indictes which is the last RxD that was 
+     * processed by the driver.
+     */
+    rx_curr_get_info_t rx_curr_get_info[MAX_RX_RINGS];
+
+    /* this will be used in receive function, this decides which ring would
+       be processed first. eg: ring with priority value 0 (highest) should
+       be processed first. 
+       first 3 LSB bits represent ring number which should be processed 
+      first, similarly next 3 bits represent next ring to be processed.
+       eg: value of _rx_ring_pri_map = 0x0000 003A means 
+       ring #2 would be processed first and #7 would be processed next
+     */
+    u32 _rx_ring_pri_map;
+
+    u16 rmac_pause_time;
+    u16 mc_pause_threshold_q0q3;
+    u16 mc_pause_threshold_q4q7;
+}mac_info_rx_t;
+#ifdef TXDBD
+typedef struct mac_info_tx{
+    u32 max_txds_per_block;
+    u32 txd_fifo_mem_sz;
+    u16 txdl_len;
+
+    TxFIFO_element_t *tx_FIFO_start[MAX_TX_FIFOS];
+    tx_curr_put_info_t tx_curr_put_info[MAX_TX_FIFOS];
+    tx_curr_get_info_t tx_curr_get_info[MAX_TX_FIFOS];
+
+} mac_info_tx_t;
+#else
+typedef struct mac_info_tx{
+    void *txd_list_mem; /* orignal pointer to allocated mem */
+    dma_addr_t txd_list_mem_phy;
+    u32 txd_list_mem_sz;
+
+    /* logical pointer of start of each Tx FIFO */
+    TxFIFO_element_t *tx_FIFO_start[MAX_TX_FIFOS];
+
+    /* logical pointer of start of TxDL which corresponds to each Tx FIFO */
+    TxD_t *txdl_start[MAX_TX_FIFOS];
+
+    /* Same as txdl_start but phy addr */
+    dma_addr_t txdl_start_phy[MAX_TX_FIFOS];
+/* Current offset within tx_FIFO_start, where driver would write new Tx frame*/
+    tx_curr_put_info_t tx_curr_put_info[MAX_TX_FIFOS];
+    tx_curr_get_info_t tx_curr_get_info[MAX_TX_FIFOS];
+
+    u16 txdl_len;       /* length of a TxDL, same for all */
+} mac_info_tx_t;
+#endif
+typedef struct mac_info_st{
+
+    void *stats_mem;    /* orignal pointer to allocated mem */
+    dma_addr_t stats_mem_phy;   /* Physical address of the stat block */
+    u32 stats_mem_sz;
+    StatInfo_t *StatsInfo;  /* Logical address of the stat block */
+} mac_info_st_t;
+#else
 typedef struct mac_info {
 /* rx side stuff */
 	u32 rxd_ring_mem_sz;
@@ -583,6 +709,9 @@
 	rx_curr_get_info_t rx_curr_get_info[MAX_RX_RINGS];
 
 	u16 rmac_pause_time;
+	u16 mc_pause_threshold_q0q3;
+	u16 mc_pause_threshold_q4q7;
+
 
 	/* this will be used in receive function, this decides which ring would
 	   be processed first. eg: ring with priority value 0 (highest) should
@@ -595,6 +724,16 @@
 	u32 _rx_ring_pri_map;
 
 /* tx side stuff */
+#ifdef TXDBD
+    u32 max_txds_per_block;
+    u32 txd_fifo_mem_sz;
+    u16 txdl_len;
+
+    TxFIFO_element_t *tx_FIFO_start[MAX_TX_FIFOS];
+    tx_curr_put_info_t tx_curr_put_info[MAX_TX_FIFOS];
+    tx_curr_get_info_t tx_curr_get_info[MAX_TX_FIFOS];
+
+#else
 	void *txd_list_mem;	/* orignal pointer to allocated mem */
 	dma_addr_t txd_list_mem_phy;
 	u32 txd_list_mem_sz;
@@ -613,12 +752,14 @@
 	tx_curr_get_info_t tx_curr_get_info[MAX_TX_FIFOS];
 
 	u16 txdl_len;		/* length of a TxDL, same for all */
+#endif
 
 	void *stats_mem;	/* orignal pointer to allocated mem */
 	dma_addr_t stats_mem_phy;	/* Physical address of the stat block */
 	u32 stats_mem_sz;
 	StatInfo_t *StatsInfo;	/* Logical address of the stat block */
 } mac_info_t;
+#endif
 
 /* structure representing the user defined MAC addresses */
 typedef struct {
@@ -632,6 +773,20 @@
 	dma_addr_t block_dma_addr;
 } rx_block_info_t;
 
+#ifdef TXDBD
+typedef struct tx_block_info {
+    TxD_t *block_virt_addr;
+    dma_addr_t block_dma_addr;
+} tx_block_info_t;
+#endif
+
+/* Default Tunable parameters of the NIC. */
+#define DEFAULT_FIFO_LEN 4096
+#define SMALL_RXD_CNT	20 * (MAX_RXDS_PER_BLOCK+1)
+#define LARGE_RXD_CNT	100 * (MAX_RXDS_PER_BLOCK+1)
+#define SMALL_BLK_CNT	20
+#define LARGE_BLK_CNT	100
+
 /* Structure representing one instance of the NIC */
 typedef struct s2io_nic {
 #define MAX_MAC_SUPPORTED   16
@@ -644,7 +799,13 @@
 	caddr_t bar0;
 	caddr_t bar1;
 	struct config_param config;
+#ifdef MAC
+    mac_info_tx_t mac_control_tx;
+    mac_info_rx_t mac_control_rx;
+    mac_info_st_t mac_control_st;
+#else
 	mac_info_t mac_control;
+#endif
 	int high_dma_flag;
 	int device_close_flag;
 	int device_enabled_once;
@@ -671,7 +832,9 @@
 	u32 irq;
 	atomic_t rx_bufs_left[MAX_RX_RINGS];
 
+#if (!LATEST_CHANGES)
 	spinlock_t isr_lock;
+#endif
 	spinlock_t tx_lock;
 
 #define PROMISC     1
@@ -700,6 +863,13 @@
 	u64 rxpkt_cnt;
 #endif
 
+#ifdef TXDBD
+/*  struct tx_block_info tx_blocks[MAX_TX_FIFOS][MAX_TX_BLOCKS_PER_FIFO];*/
+    struct tx_block_info *tx_blocks[MAX_TX_FIFOS];
+    int tx_block_count[MAX_TX_FIFOS];
+
+#endif
+
 	/*  Place holders for the virtual and physical addresses of 
 	 *  all the Rx Blocks
 	 */
@@ -737,29 +907,42 @@
 	u16 last_link_state;
 #define	LINK_DOWN	1
 #define	LINK_UP		2
+
+#ifdef CONFIG_2BUFF_MODE
+	/* Buffer Address store. */
+	buffAdd_t ba[SMALL_BLK_CNT][MAX_RXDS_PER_BLOCK + 1];
+#endif
+#if LATEST_CHANGES
+	int task_flag;
+#endif
+#ifdef SNMP_SUPPORT
+        char cName[20];
+    int nMemorySize;
+        int nLinkStatus;
+        int nFeature;
+    char cVersion[20];
+    long lDate;
+#endif
+
 } nic_t;
 
 #define RESET_ERROR 1;
 #define CMD_ERROR   2;
 
-/* Default Tunable parameters of the NIC. */
-#define DEFAULT_FIFO_LEN 4096
-#define SMALL_RXD_CNT	40 * (MAX_RXDS_PER_BLOCK+1)
-#define LARGE_RXD_CNT	100 * (MAX_RXDS_PER_BLOCK+1)
-
 /*  OS related system calls */
 #ifndef readq
 static inline u64 readq(void *addr)
 {
 	u64 ret = 0;
 	ret = readl(addr + 4);
-	ret <<= 32;
-	ret |= readl(addr);
+	(u64) ret <<= 32;
+	(u64) ret |= readl(addr);
 
 	return ret;
 }
 #endif
 
+#if 1
 #ifndef writeq
 static inline void writeq(u64 val, void *addr)
 {
@@ -767,6 +950,17 @@
 	writel((u32) (val >> 32), (addr + 4));
 }
 #endif
+#else
+#ifndef writeq
+static inline void write64(void *addr, u64 val)
+{
+	writel((u32) (val), addr);
+	writel((u32) (val >> 32), (addr + 4));
+}
+#else
+#define write64(addr, ret) writeq(ret,(void *)addr)
+#endif
+#endif
 
 /*  Interrupt related values of Xena */
 
@@ -816,30 +1010,40 @@
 
 /*  DMA level Inressupts */
 #define TXDMA_PFC_INT_M     BIT(0)
-    /*  PFC block interrupts */
+#define TXDMA_PCC_INT_M     BIT(2)
+
+/*  PFC block interrupts */
 #define PFC_MISC_ERR_1      BIT(0)	/* Interrupt to indicate FIFO full */
 
+/* PCC block interrupts. */
+#define	PCC_FB_ECC_ERR	   vBIT(0xff, 16, 8) /* Interrupt to indicate
+						 PCC_FB_ECC Error. */
 /*
  * Prototype declaration.
  */
 static int __devinit s2io_init_nic(struct pci_dev *pdev,
 				   const struct pci_device_id *pre);
 static void __devexit s2io_rem_nic(struct pci_dev *pdev);
-static int initSharedMem(struct s2io_nic *sp);
-static void freeSharedMem(struct s2io_nic *sp);
-static int initNic(struct s2io_nic *nic);
+static int init_shared_mem(struct s2io_nic *sp);
+static void free_shared_mem(struct s2io_nic *sp);
+static int init_nic(struct s2io_nic *nic);
 #ifndef CONFIG_S2IO_NAPI
-static void rxIntrHandler(struct s2io_nic *sp);
+static void rx_intr_handler(struct s2io_nic *sp);
 #endif
-static void txIntrHandler(struct s2io_nic *sp);
-static void alarmIntrHandler(struct s2io_nic *sp);
+static void tx_intr_handler(struct s2io_nic *sp);
+static void alarm_intr_handler(struct s2io_nic *sp);
 
 static int s2io_starter(void);
 void s2io_closer(void);
 static void s2io_tx_watchdog(struct net_device *dev);
 static void s2io_tasklet(unsigned long dev_addr);
 static void s2io_set_multicast(struct net_device *dev);
-static int rxOsmHandler(nic_t * sp, u16 len, RxD_t * rxdp, int ring_no);
+#ifndef CONFIG_2BUFF_MODE
+static int rx_osm_handler(nic_t * sp, u16 len, RxD_t * rxdp, int ring_no);
+#else
+static int rx_osm_handler(nic_t * sp, RxD_t * rxdp, int ring_no,
+			  buffAdd_t * ba);
+#endif
 void s2io_link(nic_t * sp, int link);
 void s2io_reset(nic_t * sp);
 #ifdef CONFIG_S2IO_NAPI
@@ -849,6 +1053,275 @@
 int s2io_set_mac_addr(struct net_device *dev, u8 * addr);
 static irqreturn_t s2io_isr(int irq, void *dev_id, struct pt_regs *regs);
 static int verify_xena_quiescence(u64 val64, int flag);
+int verify_load_parm(void);
+#ifdef SET_ETHTOOL_OPS
 static struct ethtool_ops netdev_ethtool_ops;
+#endif
+static void s2io_set_link(unsigned long data);
+#ifdef SNMP_SUPPORT
+
+#define S2IODIRNAME             "S2IO"
+#define BDFILENAME      "BDInfo"
+#define PADAPFILENAME   "PhyAdap"
+#define ERROR_PROC_DIR          -20
+#define ERROR_PROC_ENTRY        -21
+
+struct stDrvData{
+        struct stBaseDrv *pBaseDrv;
+};
+struct stPhyAdap{
+        int m_nIndex;
+        char m_cName[20];
+};
+struct stBaseDrv{
+        char m_cName[21];
+        int m_nStatus;
+        char m_cVersion[21];
+        int m_nFeature;
+        int m_nMemorySize;
+        char m_cDate[21];
+        int m_nPhyCnt;
+        char m_cPhyIndex[21];
+        struct stPhyAdap m_stPhyAdap[5];
+};
+
+struct stPhyData{
+        int m_nIndex;
+        unsigned char m_cDesc[20];
+        int m_nMode;
+        int m_nType;
+        char m_cSpeed[20];
+        unsigned char m_cPMAC[20];
+        unsigned char m_cCMAC[20];
+        int m_nLinkStatus;
+        int m_nPCISlot;
+        int m_nPCIBus;
+        int m_nIRQ;
+        int m_nCollision;
+        int m_nMulticast;
+
+        int m_nRxBytes;
+        int m_nRxDropped;
+        int m_nRxErrors;
+        int m_nRxPackets;
+       int m_nTxBytes;
+        int m_nTxDropped;
+        int m_nTxErrors;
+        int m_nTxPackets;
+
+
+};
+
+static int s2io_bdsnmp_init(struct net_device *dev);
+static void s2io_bdsnmp_rem(struct net_device  *dev);
+#endif
 
 #endif				/* _S2IO_H */
+/*
+ *$Log: s2io.h,v $
+ *Revision 1.78.2.5  2004/06/22 09:12:42  arao
+ *Bug:902
+ *The mac control structure is split into tx,rx and st in the MAC macro
+ *
+ *Revision 1.78.2.4  2004/06/22 05:55:03  arao
+ *Bug:694
+ *The txd logic has been kept in TXDBD macro.
+ *
+ *Revision 1.78.2.3  2004/06/14 09:21:15  arao
+ *Bug:921
+ *Added the __devexit_p macro for remove entry point and replaced __exit with __devexit macro for s2io_rem_nic function
+ *
+ *Revision 1.78.2.2  2004/06/10 14:07:29  arao
+ *Bug: 576
+ *SNMP Support
+ *
+ *Revision 1.78.2.1  2004/06/08 10:19:09  rkoushik
+ *Bug: 940
+ * Made the changes to sync up the s2io_close function with
+ *s2io_xmit and also the tasks scheduled by the driver which
+ * could be running independently on a different CPU.
+ *Also fixed the issue raised by bug # 867
+ *(disabling relaxed ordering feature.).
+ *
+ *-Koushik
+ *
+ *Revision 1.78  2004/05/31 12:21:21  rkoushik
+ *Bug: 986
+ *
+ *In this check in Iam making the fixes listed below,
+ *1. Handling the PCC_FB_ECC_ERR interrupt as specified in the new UG.
+ *2. Also queuing a task to reset the NIC when a serious Error is detected.
+ *3. The rmac_err_reg is cleared immediately in the Intr handler itself instead of the queued task 's2io_set_link'.
+ *
+ *Koushik
+ *
+ *Revision 1.77  2004/05/20 18:42:36  aravi
+ *Bug: 971
+ *Removed 2 buffer mode as default since it's not yet confirmed
+ *to work well on non-SGI platforms.
+ *
+ *Revision 1.76  2004/05/20 12:38:43  rkoushik
+ *Bug: 970
+ *Macro was not declared properly in s2io.c and RxD_t structure for
+ *2BUFF mode was declared incorrectly in s2io.h leading to problems.
+ *Both rectified in this checkin.
+ *
+ *-Koushik
+ *
+ *Revision 1.75  2004/05/18 09:52:12  rkoushik
+ *Bug: 935
+ * Updating the 2Buff mode changes and fix for the new Link LED problem
+ *into the CVS head.
+ *
+ *- Koushik
+ *
+ *Revision 1.74  2004/05/14 14:14:29  arao
+ *Bug: 885
+ *KNF standard for function names and comments are updated to generate Html document
+ *
+ *Revision 1.73  2004/05/13 19:30:06  dyusupov
+ *Bug: 943
+ *
+ *REL_1-7-2-3_LX becomes HEAD now.
+ *
+ *Revision 1.65  2004/04/07 09:58:36  araju
+ *Bug: 551
+ *Loadable Parameters added.
+ *
+ *Revision 1.64  2004/03/26 12:39:05  rkoushik
+ *Bug: 832
+ *  In this checkin, I have made a few cosmetic changes to the files
+ *s2io.c and s2io.h with a view to minimize the diffs between the
+ *files in the repository and those given to open source.
+ *
+ *-Koushik
+ *
+ *Revision 1.63  2004/03/19 06:41:16  rkoushik
+ *Bug: 765
+ *
+ *	This checkin fixes the Multiple Link state displays
+ *during link state change, whichwas  happening due to a very small
+ *delay in the alarm Intr handler.
+ *This checkin also addresses the Comment 13 of Jeffs latest set of comments
+ *which provided a new way to identify the No TxD condition in s2io_xmit
+ *routine. This was part of the Bug # 760, which will also be moved to fixed
+ *state.
+ *
+ *Koushik
+ *
+ *Revision 1.62  2004/03/15 07:22:14  rkoushik
+ *Bug: 765
+ *To solve the multiple Link Down displays when the Nic's Link state
+ *changes. further info in the bug.
+ *
+ *Koushik
+ *
+ *Revision 1.61  2004/03/12 04:48:32  araju
+ *Bug: 755
+ *set rx/tx chksum offload independently
+ *
+ *Revision 1.60  2004/03/11 11:57:23  rkoushik
+ *Bug: 760
+ *Has addressed most of the issues with a few exceptions, namely
+ *Issue # 13 - Modifying the no_txd logic in s2io_xmit.
+ *	I will add this by monday after some local testing.
+ *
+ *Issue # 15 - Does get_stats require locking?
+ *	I don't think so, because we just reflect what ever the
+ *	statistics block is reflecting at the current moment.
+ *
+ *Issue # 16 - Reformant the function header comments.
+ *	Does not look like a priority issue. Will address this
+ *	in the next patch along with issue # 20.
+ *
+ *Issue # 20 - Provide a ethtool patch for proper dumping registers and EEPROM.
+ *	Will address this in the next submission patch.
+ *
+ *Koushik
+ *
+ *Revision 1.59  2004/02/27 14:37:41  rkoushik
+ *Bug: 748
+ *Driver submission comments given by Jeff,
+ *details given in the bug.
+ *
+ *Koushik
+ *
+ *Revision 1.58  2004/02/10 11:58:42  rkoushik
+ *Bug: 668
+ *Eliminated usage of self declared type 'dmaaddr_t' and also
+ *eliminated the usage of PPC64_ARCH macro which was prevalent in the older code.
+ *Further details in the bug.
+ *
+ *Koushik
+ *
+ *Revision 1.57  2004/02/07 02:17:08  gkotlyar
+ *Bug: 682
+ *Parenthesis in the OST macro.
+ *
+ *Revision 1.56  2004/02/04 04:52:45  rkoushik
+ *Bug: 667
+ * Indented the code using indent utility. Details of the options
+ *used are specified in bug # 667
+ *
+ *Koushik
+ *
+ *Revision 1.55  2004/02/02 12:03:42  rkoushik
+ *Bug: 643
+ *The tx_pkt_ptr variable has been removed. Tx watchdog function now does
+ *a s2io_close followed by s2io_open calls to reset and re-initialise NIC.
+ *The Tx Intr scheme is made dependednt on the size of the Progammed FIFOs.
+ *
+ *-Koushik
+ *
+ *Revision 1.54  2004/01/29 05:41:41  rkoushik
+ *Bug: 657
+ *Loop back test is being removed from the driver as one of ethtool's test
+ *option.
+ *
+ *Koushik
+ *
+ *Revision 1.53  2004/01/20 05:16:01  rkoushik
+ *Bug: 397
+ *TSO is enabled by default if supported by Kernel.
+ *The undef macro to disable TSO was removed from the s2io.h header file.
+ *
+ *Koushik
+ *
+ *Revision 1.52  2004/01/19 21:13:32  aravi
+ *Bug: 593
+ *Fixed Tx Link loss problem by
+ *1. checking for put pointer not going beyond get pointer
+ *2. set default tx descriptors to 4096( done in s2io.h)
+ *3. Set rts_frm_len register to MTU size.
+ *4. Corrected the length used for address unmapping in
+ *    tx intr handler.
+ *
+ *Revision 1.51  2004/01/19 09:51:08  rkoushik
+ *Bug: 598
+ * Added GPL notices on the driver source files, namely
+ *s2io.c, s2io.h and regs.h
+ *
+ *Koushik
+ *
+ *Revision 1.50  2003/12/30 13:03:34  rkoushik
+ *Bug: 177
+ *The driver has been updated with support for funtionalities in ethtool
+ *version 1.8. Interrupt moderation has been skipped as the methodology to
+ *set it using ethtool is different to our methodology.
+ *
+ *-Koushik
+ *
+ *Revision 1.49  2003/12/16 21:15:32  ukiran
+ *Bug:542
+ *Increased default FIFO to 1024 *6
+ *
+ *Revision 1.48  2003/12/01 22:03:08  ukiran
+ *Bug:510
+ *Cleanup of 
+ chars
+ *
+ *Revision 1.47  2003/11/04 02:07:03  ukiran
+ *Bug:484
+ *Enabling Logs in source code
+ *
+ */
