Index: linux-2.6.5/fs/cifs/dir.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/dir.c	2004-06-01 17:01:01.000000000 +0200
+++ linux-2.6.5/fs/cifs/dir.c	2004-06-01 17:01:44.000000000 +0200
@@ -159,6 +159,7 @@
 	struct cifsFileInfo * pCifsFile = NULL;
 	struct cifsInodeInfo * pCifsInode;
 	int disposition = FILE_OVERWRITE_IF;
+	int write_only = FALSE;
 
 	xid = GetXid();
 
@@ -174,9 +175,10 @@
 	if(nd) {
 		if ((nd->intent.open.flags & O_ACCMODE) == O_RDONLY)
 			desiredAccess = GENERIC_READ;
-		else if ((nd->intent.open.flags & O_ACCMODE) == O_WRONLY)
+		else if ((nd->intent.open.flags & O_ACCMODE) == O_WRONLY) {
 			desiredAccess = GENERIC_WRITE;
-		else if ((nd->intent.open.flags & O_ACCMODE) == O_RDWR) {
+			write_only = TRUE;
+		} else if ((nd->intent.open.flags & O_ACCMODE) == O_RDWR) {
 			/* GENERIC_ALL is too much permission to request */
 			/* can cause unnecessary access denied on create */
 			/* desiredAccess = GENERIC_ALL; */
@@ -260,16 +262,25 @@
 				pCifsFile->invalidHandle = FALSE;
 				pCifsFile->closePend     = FALSE;
 				init_MUTEX(&pCifsFile->fh_sem);
-				/* pCifsFile->pfile = file; */ /* put in at open time */
+				/* put the following in at open now */
+				/* pCifsFile->pfile = file; */ 
 				write_lock(&GlobalSMBSeslock);
 				list_add(&pCifsFile->tlist,&pTcon->openFileList);
 				pCifsInode = CIFS_I(newinode);
 				if(pCifsInode) {
-					list_add(&pCifsFile->flist,&pCifsInode->openFileList);
+				/* if readable file instance put first in list*/
+					if (write_only == TRUE) {
+                                        	list_add_tail(&pCifsFile->flist,
+							&pCifsInode->openFileList);
+					} else {
+						list_add(&pCifsFile->flist,
+							&pCifsInode->openFileList);
+					}
 					if((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
 						pCifsInode->clientCanCacheAll = TRUE;
 						pCifsInode->clientCanCacheRead = TRUE;
-						cFYI(1,("Exclusive Oplock granted on inode %p",newinode));
+						cFYI(1,("Exclusive Oplock granted on inode %p",
+							newinode));
 					} else if((oplock & 0xF) == OPLOCK_READ)
 						pCifsInode->clientCanCacheRead = TRUE;
 				}
Index: linux-2.6.5/fs/cifs/file.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/file.c	2004-06-01 17:01:01.000000000 +0200
+++ linux-2.6.5/fs/cifs/file.c	2004-06-01 17:02:02.000000000 +0200
@@ -171,7 +171,14 @@
 			list_add(&pCifsFile->tlist,&pTcon->openFileList);
 			pCifsInode = CIFS_I(file->f_dentry->d_inode);
 			if(pCifsInode) {
-				list_add(&pCifsFile->flist,&pCifsInode->openFileList);
+				/* want handles we can use to read with first */
+				/* in the list so we do not have to walk the */
+				/* list to search for one in prepare_write */
+				if ((file->f_flags & O_ACCMODE) == O_WRONLY) {
+					list_add_tail(&pCifsFile->flist,&pCifsInode->openFileList);
+				} else {
+					list_add(&pCifsFile->flist,&pCifsInode->openFileList);
+				}
 				write_unlock(&GlobalSMBSeslock);
 				write_unlock(&file->f_owner.lock);
 				if(pCifsInode->clientCanCacheRead) {
@@ -910,6 +917,11 @@
 	}
 	open_file = (struct cifsFileInfo *)file->private_data;
 
+	if((file->f_flags & O_ACCMODE) == O_WRONLY) {
+		cFYI(1,("attempting read on write only file instance"));
+	}
+
+
 	for (total_read = 0,current_offset=read_data; read_size > total_read;
 				total_read += bytes_read,current_offset+=bytes_read) {
 		current_read_size = min_t(const int,read_size - total_read,cifs_sb->rsize);
@@ -1145,11 +1157,42 @@
 	return rc;
 }
 
+static int cifs_readpage_worker(struct file *file, struct page *page, loff_t * poffset)
+{
+	char * read_data;
+	int rc;
+
+        page_cache_get(page);
+        read_data = kmap(page);
+        /* for reads over a certain size could initiate async read ahead */
+                                                                                                                           
+        rc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);
+                                                                                                                           
+        if (rc < 0)
+                goto io_error;
+        else {
+                cFYI(1,("Bytes read %d ",rc));
+        }
+                                                                                                                           
+        file->f_dentry->d_inode->i_atime = CURRENT_TIME;
+                                                                                                                           
+        if(PAGE_CACHE_SIZE > rc) {
+                memset(read_data+rc, 0, PAGE_CACHE_SIZE - rc);
+        }
+        flush_dcache_page(page);
+        SetPageUptodate(page);
+        rc = 0;
+                                                                                                                           
+io_error:
+        kunmap(page);
+	page_cache_release(page);
+	return rc;
+}
+
 static int
 cifs_readpage(struct file *file, struct page *page)
 {
 	loff_t offset = (loff_t)page->index << PAGE_CACHE_SHIFT;
-	char * read_data;
 	int rc = -EACCES;
 	int xid;
 
@@ -1160,34 +1203,12 @@
 		return -EBADF;
 	}
 
-	cFYI(0,("readpage %p at offset %d 0x%x\n",page,(int)offset,(int)offset));
+	cFYI(1,("readpage %p at offset %d 0x%x\n",page,(int)offset,(int)offset));
 
-	page_cache_get(page);
-	read_data = kmap(page);
-	/* for reads over a certain size could initiate async read ahead */
+	rc = cifs_readpage_worker(file,page,&offset);
 
-	rc = cifs_read(file, read_data, PAGE_CACHE_SIZE, &offset);
-
-	if (rc < 0)
-		goto io_error;
-	else {
-		cFYI(1,("Bytes read %d ",rc));
-	}
-
-	file->f_dentry->d_inode->i_atime = CURRENT_TIME;
-
-	if(PAGE_CACHE_SIZE > rc) {
-		memset(read_data+rc, 0, PAGE_CACHE_SIZE - rc);
-	}
-	flush_dcache_page(page);
-	SetPageUptodate(page);
-	rc = 0;
-
-io_error:
-	kunmap(page);
 	unlock_page(page);
 
-	page_cache_release(page);
 	FreeXid(xid);
 	return rc;
 }
@@ -1937,17 +1958,30 @@
 int cifs_prepare_write(struct file *file, struct page *page,
 			unsigned from, unsigned to)
 {
+	int rc = 0;
+        loff_t offset = (loff_t)page->index << PAGE_CACHE_SHIFT;
 	cFYI(1,("prepare write for page %p from %d to %d",page,from,to));
 	if (!PageUptodate(page)) {
-		if (to - from != PAGE_CACHE_SIZE) {
+	/*	if (to - from != PAGE_CACHE_SIZE) {
 			void *kaddr = kmap_atomic(page, KM_USER0);
 			memset(kaddr, 0, from);
 			memset(kaddr + to, 0, PAGE_CACHE_SIZE - to);
 			flush_dcache_page(page);
 			kunmap_atomic(kaddr, KM_USER0);
-		}
-		SetPageUptodate(page);
+		} */
+		/* If we are writing a full page it will be up to date,
+		no need to read from the server */
+		if((to==PAGE_CACHE_SIZE) && (from == 0))
+			SetPageUptodate(page);
+
+		/* might as well read a page, it is fast enough */
+		rc = cifs_readpage_worker(file,page,&offset);
+		/* if this returns an error should we try using another
+		file handle if there is one - how would we lock it
+		to prevent close of that handle racing with this read? */
 	}
+
+	/* BB should we pass any errors back? e.g. if we do not have read access to the file */
 	return 0;
 }
 
@@ -1956,8 +1990,7 @@
 	.readpage = cifs_readpage,
 	.readpages = cifs_readpages,
 	.writepage = cifs_writepage,
-	.prepare_write = simple_prepare_write, /* BB fixme BB */
-/*	.prepare_write = cifs_prepare_write, */  /* BB removeme BB */
+	.prepare_write = cifs_prepare_write, 
 	.commit_write = cifs_commit_write,
    /* .sync_page = cifs_sync_page, */
 	/*.direct_IO = */
