From: Tejun Heo <htejun@gmail.com>
Subject: libata doesn't enable IRQ sharing for devices in legacy mode
References: 218742
Patch-Mainline: Yes

There are machines out there which share legacy PCI IDE IRQs w/ other
devices.  libata SFF interrupt/HSM code is ready for shared IRQ and
has been setting IRQF_SHARED for devices in native PCI mode.  Device
in legacy mode is still a PCI device and thus supposedly uses
active-low level triggered IRQ.

Machines with such setup should be quite rare and w/o this flag libata
is likely to fail loading and render the system unuseable.  Also, IDE
driver has been setting IRQF_SHARED for devices in legacy mode for a
looooong time.

Signed-off-by: Tejun Heo <htejun@gmail.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>

---
 drivers/ata/libata-core.c |   11 ++++++++---
 drivers/ata/libata-sff.c  |   12 +++++++++---
 drivers/ata/sata_sil.c    |    5 +++++
 3 files changed, 22 insertions(+), 6 deletions(-)

--- linux-2.6.19.orig/drivers/ata/libata-core.c
+++ linux-2.6.19/drivers/ata/libata-core.c
@@ -4786,6 +4786,7 @@ unsigned int ata_qc_issue_prot(struct at
 inline unsigned int ata_host_intr (struct ata_port *ap,
 				   struct ata_queued_cmd *qc)
 {
+	struct ata_eh_info *ehi = &ap->eh_info;
 	u8 status, host_stat = 0;
 
 	VPRINTK("ata%u: protocol %d task_state %d\n",
@@ -4846,6 +4847,11 @@ inline unsigned int ata_host_intr (struc
 	ap->ops->irq_clear(ap);
 
 	ata_hsm_move(ap, qc, status, 0);
+
+	if (unlikely(qc->err_mask) && (qc->tf.protocol == ATA_PROT_DMA ||
+				       qc->tf.protocol == ATA_PROT_ATAPI_DMA))
+		ata_ehi_push_desc(ehi, "BMDMA stat 0x%x", host_stat);
+
 	return 1;	/* irq handled */
 
 idle_irq:
@@ -5524,9 +5530,8 @@ int ata_device_add(const struct ata_prob
 				ap->ioaddr.bmdma_addr,
 				irq_line);
 
-		ata_chk_status(ap);
-		host->ops->irq_clear(ap);
-		ata_eh_freeze_port(ap);	/* freeze port before requesting IRQ */
+		/* freeze port before requesting IRQ */
+		ata_eh_freeze_port(ap);
 	}
 
 	/* obtain irq, that may be shared between channels */
--- linux-2.6.19.orig/drivers/ata/libata-sff.c
+++ linux-2.6.19/drivers/ata/libata-sff.c
@@ -671,6 +671,14 @@ void ata_bmdma_freeze(struct ata_port *a
 		writeb(ap->ctl, (void __iomem *)ioaddr->ctl_addr);
 	else
 		outb(ap->ctl, ioaddr->ctl_addr);
+
+	/* Under certain circumstances, some controllers raise IRQ on
+	 * ATA_NIEN manipulation.  Also, many controllers fail to mask
+	 * previously pending IRQ on ATA_NIEN assertion.  Clear it.
+	 */
+	ata_chk_status(ap);
+
+	ap->ops->irq_clear(ap);
 }
 
 /**
@@ -714,7 +722,6 @@ void ata_bmdma_drive_eh(struct ata_port 
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 			ata_postreset_fn_t postreset)
 {
-	struct ata_eh_context *ehc = &ap->eh_context;
 	struct ata_queued_cmd *qc;
 	unsigned long flags;
 	int thaw = 0;
@@ -734,8 +741,6 @@ void ata_bmdma_drive_eh(struct ata_port 
 
 		host_stat = ata_bmdma_status(ap);
 
-		ata_ehi_push_desc(&ehc->i, "BMDMA stat 0x%x", host_stat);
-
 		/* BMDMA controllers indicate host bus error by
 		 * setting DMA_ERR bit and timing out.  As it wasn't
 		 * really a timeout event, adjust error mask and
@@ -877,6 +882,7 @@ static struct ata_probe_ent *ata_pci_ini
 		return NULL;
 
 	probe_ent->n_ports = 2;
+	probe_ent->irq_flags = IRQF_SHARED;
 
 	if (port_mask & ATA_PORT_PRIMARY) {
 		probe_ent->irq = ATA_PRIMARY_IRQ;
--- linux-2.6.19.orig/drivers/ata/sata_sil.c
+++ linux-2.6.19/drivers/ata/sata_sil.c
@@ -356,6 +356,7 @@ static void sil_scr_write (struct ata_po
 
 static void sil_host_intr(struct ata_port *ap, u32 bmdma2)
 {
+	struct ata_eh_info *ehi = &ap->eh_info;
 	struct ata_queued_cmd *qc = ata_qc_from_tag(ap, ap->active_tag);
 	u8 status;
 
@@ -428,6 +429,10 @@ static void sil_host_intr(struct ata_por
 	/* kick HSM in the ass */
 	ata_hsm_move(ap, qc, status, 0);
 
+	if (unlikely(qc->err_mask) && (qc->tf.protocol == ATA_PROT_DMA ||
+				       qc->tf.protocol == ATA_PROT_ATAPI_DMA))
+		ata_ehi_push_desc(ehi, "BMDMA2 stat 0x%x", bmdma2);
+
 	return;
 
  err_hsm:
