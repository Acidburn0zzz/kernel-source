diff -Nur cifs-1.0.8/fs/cifs/CHANGES cifs-1.10/fs/cifs/CHANGES
--- cifs-1.0.8/fs/cifs/CHANGES	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/CHANGES	2004-04-23 16:40:32.000000000 +0200
@@ -1,3 +1,17 @@
+Version 1.10
+------------
+Fix reconnection (and certain failed mounts) to properly wake up the
+blocked users thread so it does not seem hung (in some cases was blocked
+until the cifs receive timeout expired). Fix spurious error logging
+to kernel log when application with open network files killed. 
+
+Version 1.09
+------------
+Fix /proc/fs module unload warning message (that could be logged
+to the kernel log). Fix intermittent failure in connectathon
+test7 (hardlink count not immediately refreshed in case in which
+inode metadata can be incorrectly kept cached when time near zero)
+
 Version 1.08
 ------------
 Allow file_mode and dir_mode (specified at mount time) to be enforced
diff -Nur cifs-1.0.8/fs/cifs/cifs_debug.c cifs-1.10/fs/cifs/cifs_debug.c
--- cifs-1.0.8/fs/cifs/cifs_debug.c	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/cifs_debug.c	2004-04-23 16:40:32.000000000 +0200
@@ -310,7 +310,7 @@
 
 	remove_proc_entry("DebugData", proc_fs_cifs);
 	remove_proc_entry("cifsFYI", proc_fs_cifs);
-	remove_proc_entry("TraceSMB", proc_fs_cifs);
+	remove_proc_entry("traceSMB", proc_fs_cifs);
 	remove_proc_entry("SimultaneousOps", proc_fs_cifs);
 	remove_proc_entry("Stats", proc_fs_cifs);
 	remove_proc_entry("MultiuserMount", proc_fs_cifs);
diff -Nur cifs-1.0.8/fs/cifs/cifsfs.c cifs-1.10/fs/cifs/cifsfs.c
--- cifs-1.0.8/fs/cifs/cifsfs.c	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/cifsfs.c	2004-04-23 16:40:32.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/cifsfs.c
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2003
+ *   Copyright (C) International Business Machines  Corp., 2002,2004
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
  *   Common Internet FileSystem (CIFS) client
@@ -375,6 +375,12 @@
 };
 #endif
 
+static int cifs_remount(struct super_block *sb, int *flags, char *data)
+{
+	*flags |= MS_NODIRATIME;
+	return 0;
+}
+
 struct super_operations cifs_super_ops = {
 	.read_inode = cifs_read_inode,
 	.put_super = cifs_put_super,
@@ -387,6 +393,7 @@
    us with the same number of releases (closes) as opens */
 	.show_options = cifs_show_options,
 /*    .umount_begin   = cifs_umount_begin, *//* consider adding in the future */
+	.remount_fs = cifs_remount,
 };
 
 static struct super_block *
@@ -424,7 +431,7 @@
 	else if(file->f_dentry->d_inode == NULL)
 		return -EIO;
 
-	cFYI(1,("In read_wrapper size %d at %lld",read_size,*poffset));
+	cFYI(1,("In read_wrapper size %zd at %lld",read_size,*poffset));
 	if(CIFS_I(file->f_dentry->d_inode)->clientCanCacheRead) {
 		return generic_file_read(file,read_data,read_size,poffset);
 	} else {
@@ -455,7 +462,7 @@
 	else if(file->f_dentry->d_inode == NULL)
 		return -EIO;
 
-	cFYI(1,("In write_wrapper size %d at %lld",write_size,*poffset));
+	cFYI(1,("In write_wrapper size %zd at %lld",write_size,*poffset));
 
 	/* check whether we can cache writes locally */
 	written = generic_file_write(file,write_data,write_size,poffset);
@@ -530,12 +537,18 @@
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
 	.sendfile = generic_file_sendfile,
+#ifdef CIFS_FCNTL
+	.fcntl = cifs_fcntl,
+#endif
 };
 
 struct file_operations cifs_dir_ops = {
 	.readdir = cifs_readdir,
 	.release = cifs_closedir,
 	.read    = generic_read_dir,
+#ifdef CIFS_FCNTL
+	.fcntl   = cifs_fcntl,
+#endif
 };
 
 static void
@@ -640,6 +653,7 @@
 		spin_lock(&GlobalMid_Lock);
 		if(list_empty(&GlobalOplock_Q)) {
 			spin_unlock(&GlobalMid_Lock);
+			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(39*HZ);
 		} else {
 			oplock_item = list_entry(GlobalOplock_Q.next, 
diff -Nur cifs-1.0.8/fs/cifs/cifsfs.h cifs-1.10/fs/cifs/cifsfs.h
--- cifs-1.0.8/fs/cifs/cifsfs.h	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/cifsfs.h	2004-04-23 16:40:32.000000000 +0200
@@ -78,6 +78,7 @@
 extern struct file_operations cifs_dir_ops;
 extern int cifs_dir_open(struct inode *inode, struct file *file);
 extern int cifs_readdir(struct file *file, void *direntry, filldir_t filldir);
+extern long cifs_fcntl(int, unsigned int, unsigned long, struct file *);
 
 /* Functions related to dir entries */
 extern struct dentry_operations cifs_dentry_ops;
diff -Nur cifs-1.0.8/fs/cifs/cifssmb.c cifs-1.10/fs/cifs/cifssmb.c
--- cifs-1.0.8/fs/cifs/cifssmb.c	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/cifssmb.c	2004-04-23 16:40:32.000000000 +0200
@@ -822,7 +822,10 @@
 	rc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,
 			 (struct smb_hdr *) pSMBr, &bytes_returned, 0);
 	if (rc) {
-		cERROR(1, ("Send error in Close = %d", rc));
+		if(rc!=-EINTR) {
+			/* EINTR is expected when user ctl-c to kill app */
+			cERROR(1, ("Send error in Close = %d", rc));
+		}
 	}
 	if (pSMB)
 		cifs_buf_release(pSMB);
diff -Nur cifs-1.0.8/fs/cifs/connect.c cifs-1.10/fs/cifs/connect.c
--- cifs-1.0.8/fs/cifs/connect.c	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/connect.c	2004-04-23 16:40:32.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/connect.c
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2003
+ *   Copyright (C) International Business Machines  Corp., 2002,2004
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
  *   This library is free software; you can redistribute it and/or modify
@@ -36,6 +36,7 @@
 #include "cifs_fs_sb.h"
 #include "ntlmssp.h"
 #include "nterr.h"
+#include "rfc1002pdu.h"
 
 #define CIFS_PORT 445
 #define RFC1001_PORT 139
@@ -222,6 +223,7 @@
 			csocket = server->ssocket;
 			continue;
 		} else if ((length == -ERESTARTSYS) || (length == -EAGAIN)) {
+			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(1); /* minimum sleep to prevent looping
 				allowing socket to clear and app threads to set
 				tcpStatus CifsNeedReconnect if server hung */
@@ -233,12 +235,14 @@
 					smb negprot error in which case reconnecting here is
 					not going to help - return error to mount */
 				server->tcpStatus = CifsExiting;
+				wake_up(&server->response_q);
 				break;
 			}
 
 			cFYI(1,("Reconnecting after unexpected rcvmsg error "));
 			cifs_reconnect(server);
 			csocket = server->ssocket;
+			wake_up(&server->response_q);
 			continue;
 		}
 
@@ -249,23 +253,46 @@
 
 		temp = (char *) smb_buffer;
 		if (length > 3) {
-			if (temp[0] == (char) 0x85) {
+			if (temp[0] == (char) RFC1002_SESSION_KEEP_ALIVE) {
 				iov.iov_base = smb_buffer;
 				iov.iov_len = 4;
 				length = sock_recvmsg(csocket, &smb_msg, 4, 0);
-				cFYI(0,
-				     ("Received 4 byte keep alive packet "));
-			} else if ((temp[0] == (char) 0x83)
+				cFYI(0,("Received 4 byte keep alive packet"));
+			} else if (temp[0] == (char) RFC1002_POSITIVE_SESSION_RESPONSE) {
+				iov.iov_base = smb_buffer;
+					iov.iov_len = 4;
+					length = sock_recvmsg(csocket, &smb_msg, 4, 0);
+					cFYI(1,("Good RFC 1002 session rsp"));
+			} else if ((temp[0] == (char)RFC1002_NEGATIVE_SESSION_RESPONSE)
 				   && (length == 5)) {
 				/* we get this from Windows 98 instead of error on SMB negprot response */
-				cERROR(1,
-				       ("Negative RFC 1002 Session response. Error = 0x%x",
-					temp[4]));
-				break;
-
+				cFYI(1,("Negative RFC 1002 Session Response Error 0x%x)",temp[4]));
+				if(server->tcpStatus == CifsNew) {
+					/* if nack on negprot (rather than 
+					ret of smb negprot error) reconnecting
+					not going to help, ret error to mount */
+					server->tcpStatus = CifsExiting;
+					/* wake up thread doing negprot */
+					wake_up(&server->response_q);
+					break;
+				} else {
+					/* give server a second to
+					clean up before reconnect attempt */
+					set_current_state(TASK_INTERRUPTIBLE);
+					schedule_timeout(HZ);
+					/* always try 445 first on reconnect
+					since we get NACK on some if we ever
+					connected to port 139 (the NACK is 
+					since we do not begin with RFC1001
+					session initialize frame) */
+					server->addr.sockAddr.sin_port = CIFS_PORT;
+					cifs_reconnect(server);
+					csocket = server->ssocket;
+					wake_up(&server->response_q);
+					continue;
+				}
 			} else if (temp[0] != (char) 0) {
-				cERROR(1,
-				       ("Unknown RFC 1001 frame not 0x00 nor 0x85"));
+				cERROR(1,("Unknown RFC 1002 frame"));
 				cifs_dump_mem(" Received Data: ", temp, length);
 				cifs_reconnect(server);
 				csocket = server->ssocket;
@@ -823,6 +850,7 @@
 {
 	int rc = 0;
 	int connected = 0;
+	unsigned short int orig_port = 0;
 
 	if(*csocket == NULL) {
 		rc = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, csocket);
@@ -847,6 +875,10 @@
 	} 
 
 	if(!connected) {
+		/* save original port so we can retry user specified port  
+			later if fall back ports fail this time  */
+		orig_port = psin_server->sin_port;
+
 		/* do not retry on the same port we just failed on */
 		if(psin_server->sin_port != htons(CIFS_PORT)) {
 			psin_server->sin_port = htons(CIFS_PORT);
@@ -869,6 +901,8 @@
 	/* give up here - unless we want to retry on different
 		protocol families some day */
 	if (!connected) {
+		if(orig_port)
+			psin_server->sin_port = orig_port;
 		cFYI(1,("Error %d connecting to server via ipv4",rc));
 		sock_release(*csocket);
 		*csocket = NULL;
@@ -2652,11 +2686,11 @@
 		if(rc == 0)
 			pSesInfo->server->tcpStatus = CifsGood;
 	}
-	pSesInfo->capabilities = pSesInfo->server->capabilities;
-	if(linuxExtEnabled == 0)
-		pSesInfo->capabilities &= (~CAP_UNIX);
-	pSesInfo->sequence_number = 0;
 	if (!rc) {
+		pSesInfo->capabilities = pSesInfo->server->capabilities;
+		if(linuxExtEnabled == 0)
+			pSesInfo->capabilities &= (~CAP_UNIX);
+		pSesInfo->sequence_number = 0;
 		cFYI(1,("Security Mode: 0x%x Capabilities: 0x%x Time Zone: %d",
 			pSesInfo->server->secMode,
 			pSesInfo->server->capabilities,
diff -Nur cifs-1.0.8/fs/cifs/fcntl.c cifs-1.10/fs/cifs/fcntl.c
--- cifs-1.0.8/fs/cifs/fcntl.c	1970-01-01 01:00:00.000000000 +0100
+++ cifs-1.10/fs/cifs/fcntl.c	2004-04-23 16:40:32.000000000 +0200
@@ -0,0 +1,97 @@
+/*
+ *   fs/cifs/fcntl.c
+ *
+ *   vfs operations that deal with the file control API
+ * 
+ *   Copyright (C) International Business Machines  Corp., 2003,2004
+ *   Author(s): Steve French (sfrench@us.ibm.com)
+ *
+ *   This library is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU Lesser General Public License as published
+ *   by the Free Software Foundation; either version 2.1 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU Lesser General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Lesser General Public License
+ *   along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/fcntl.h>
+#include "cifsglob.h"
+#include "cifsproto.h"
+#include "cifs_unicode.h"
+#include "cifs_debug.h"
+
+int cifs_directory_notify(unsigned long arg, struct file * file)
+{
+	int xid;
+	int rc = -EINVAL;
+	struct cifs_sb_info *cifs_sb;
+	struct cifsTconInfo *pTcon;
+	char *full_path = NULL;
+
+	xid = GetXid();
+	cifs_sb = CIFS_SB(file->f_dentry->d_sb);
+	pTcon = cifs_sb->tcon;
+	full_path = build_path_from_dentry(file->f_dentry);
+	cFYI(1,("cifs dir notify on file %s",full_path));
+	/* CIFSSMBNotify */
+	FreeXid(xid);
+	return rc;
+}
+
+
+long cifs_fcntl(int file_desc, unsigned int command, unsigned long arg,
+				struct file * file)
+{
+	/* Few few file control functions need to be specially mapped. So far
+	only:
+		F_NOTIFY (for directory change notification)
+	And eventually:
+		F_GETLEASE
+		F_SETLEASE 
+	need to be mapped here. The others either already are mapped downstream
+	or do not need to go to the server (client only sideeffects):
+		F_DUPFD:
+		F_GETFD:
+		F_SETFD:
+		F_GETFL:
+		F_SETFL:
+		F_GETLK:
+		F_SETLK:
+		F_SETLKW:
+		F_GETOWN:
+		F_SETOWN:
+		F_GETSIG:
+		F_SETSIG:
+	*/
+	long rc = 0;
+
+	cFYI(1,("cifs_fcntl: command %d with arg %lx",command,arg)); /* BB removeme BB */
+
+	switch (command) {
+	case F_NOTIFY:
+		/* let the local call have a chance to fail first */
+		rc = generic_file_fcntl(file_desc,command,arg,file);
+		if(rc)
+			return rc;
+		else {
+			/* local call succeeded try to do remote notify to
+			pick up changes from other clients to server file */
+			cifs_directory_notify(arg, file);
+			/* BB add case to long and return rc from above */
+			return rc;
+		}
+		break;
+	default:
+		break;
+	}
+	return generic_file_fcntl(file_desc,command,arg,file);
+}
+                
diff -Nur cifs-1.0.8/fs/cifs/inode.c cifs-1.10/fs/cifs/inode.c
--- cifs-1.0.8/fs/cifs/inode.c	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/inode.c	2004-04-23 16:40:32.000000000 +0200
@@ -582,12 +582,14 @@
 
 	full_path = build_path_from_dentry(direntry);
 	cFYI(1,
-	     ("Revalidate full path: %s for inode 0x%p with count %d dentry: 0x%p d_time %ld at time %ld ",
+	     ("Revalidate: %s inode 0x%p count %d dentry: 0x%p d_time %ld jiffies %ld",
 	      full_path, direntry->d_inode,
 	      direntry->d_inode->i_count.counter, direntry,
 	      direntry->d_time, jiffies));
 
-	if (time_before(jiffies, cifsInode->time + HZ) && lookupCacheEnabled) {
+	if (cifsInode->time == 0){
+		/* was set to zero previously to force revalidate */
+	} else if (time_before(jiffies, cifsInode->time + HZ) && lookupCacheEnabled) {
 	    if((S_ISREG(direntry->d_inode->i_mode) == 0) || 
 			(direntry->d_inode->i_nlink == 1)) {  
 			if (full_path)
diff -Nur cifs-1.0.8/fs/cifs/Makefile cifs-1.10/fs/cifs/Makefile
--- cifs-1.0.8/fs/cifs/Makefile	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/Makefile	2004-04-23 16:40:32.000000000 +0200
@@ -3,4 +3,4 @@
 #
 obj-$(CONFIG_CIFS) += cifs.o
 
-cifs-objs := cifsfs.o cifssmb.o cifs_debug.o connect.o dir.o file.o inode.o link.o misc.o netmisc.o smbdes.o smbencrypt.o transport.o asn1.o md4.o md5.o cifs_unicode.o nterr.o xattr.o cifsencrypt.o
+cifs-objs := cifsfs.o cifssmb.o cifs_debug.o connect.o dir.o file.o inode.o link.o misc.o netmisc.o smbdes.o smbencrypt.o transport.o asn1.o md4.o md5.o cifs_unicode.o nterr.o xattr.o cifsencrypt.o fcntl.o
diff -Nur cifs-1.0.8/fs/cifs/README cifs-1.10/fs/cifs/README
--- cifs-1.0.8/fs/cifs/README	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/README	2004-04-23 16:40:32.000000000 +0200
@@ -209,9 +209,15 @@
   suid          Allow remote files on this mountpoint with suid enabled to 
 		be executed (default for mounts when executed as root,
 		nosuid is default for user mounts).
-  credentials   (allow valid when the cifs mount helper, mount.cifs, is
-		installed. Specifies the name of the credential file which 
-		will be read to obtain the userid and password.
+  credentials   Although ignored by the cifs kernel component, it is used by 
+		the mount helper, mount.cifs. When mount.cifs is installed it
+		opens and reads the credential file specified in order  
+		to obtain the userid and password arguments which are passed to
+		the cifs vfs.
+  guest         Although ignored by the kernel component, the mount.cifs
+		mount helper will not prompt the user for a password
+		if guest is specified on the mount options.  If no
+		password is specified a null password will be used.
 
 Misc /proc/fs/cifs Flags and Debug Info
 =======================================
diff -Nur cifs-1.0.8/fs/cifs/rfc1002pdu.h cifs-1.10/fs/cifs/rfc1002pdu.h
--- cifs-1.0.8/fs/cifs/rfc1002pdu.h	1970-01-01 01:00:00.000000000 +0100
+++ cifs-1.10/fs/cifs/rfc1002pdu.h	2004-04-23 16:40:32.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ *   fs/cifs/rfc1002pdu.h
+ *
+ *   Protocol Data Unit definitions for RFC 1001/1002 support
+ *
+ *   Copyright (c) International Business Machines  Corp., 2004
+ *   Author(s): Steve French (sfrench@us.ibm.com)
+ *
+ *   This library is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU Lesser General Public License as published
+ *   by the Free Software Foundation; either version 2.1 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU Lesser General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Lesser General Public License
+ *   along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+ */
+
+#pragma pack(1)
+
+/* NB: unlike smb/cifs packets, the RFC1002 structures are big endian */
+
+	/* RFC 1002 session packet types */
+#define RFC1002_SESSION_MESASAGE 0x00
+#define RFC1002_SESSION_REQUEST  0x81
+#define RFC1002_POSITIVE_SESSION_RESPONSE 0x82
+#define RFC1002_NEGATIVE_SESSION_RESPONSE 0x83
+#define RFC1002_RETARGET_SESSION_RESPONSE 0x83
+#define RFC1002_SESSION_KEEP_ALIVE 0x85
+
+	/* RFC 1002 flags (only one defined */
+#define RFC1002_LENGTH_EXTEND 0x80 /* high order bit of length (ie +64K) */
+
+struct rfc1002_session_packet {
+	__u8	type;
+	__u8	flags;
+	__u16	length;
+	union {
+		struct {
+			__u8 called_name[16];
+			__u8 calling_name[16];
+		} session_req;
+		struct {
+			__u32 retarget_ip_addr;
+			__u16 port;
+		} retarget_resp;
+		__u8 neg_ses_resp_error_code;
+		/* POSITIVE_SESSION_RESPONSE packet does not include trailer.
+		SESSION_KEEP_ALIVE packet also does not include a trailer.
+		Trailer for the SESSION_MESSAGE packet is SMB/CIFS header */
+	} trailer;
+};
+
+/* Negative Session Response error codes */
+#define RFC1002_NOT_LISTENING_CALLED  0x80 /* not listening on called name */
+#define RFC1002_NOT_LISTENING_CALLING 0x81 /* not listening on calling name */
+#define RFC1002_NOT_PRESENT           0x82 /* called name not present */
+#define RFC1002_INSUFFICIENT_RESOURCE 0x83
+#define RFC1002_UNSPECIFIED_ERROR     0x8F
+
+/* RFC 1002 Datagram service packets are not defined here as they
+are not needed for the network filesystem client unless we plan on
+implementing broadcast resolution of the server ip address (from
+server netbios name). Currently server names are resolved only via DNS
+(tcp name) or ip address or an /etc/hosts equivalent mapping to ip address.*/
+
+#define DEFAULT_CIFS_CALLED_NAME  "*SMBSERVER      "
+
+#pragma pack()		/* resume default structure packing */
+                                                             
diff -Nur cifs-1.0.8/fs/cifs/transport.c cifs-1.10/fs/cifs/transport.c
--- cifs-1.0.8/fs/cifs/transport.c	2004-04-16 05:18:12.000000000 +0200
+++ cifs-1.10/fs/cifs/transport.c	2004-04-23 16:40:32.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/transport.c
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2003
+ *   Copyright (C) International Business Machines  Corp., 2002,2004
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
  *   This library is free software; you can redistribute it and/or modify
@@ -29,7 +29,7 @@
 #include "cifsglob.h"
 #include "cifsproto.h"
 #include "cifs_debug.h"
-
+  
 extern kmem_cache_t *cifs_mid_cachep;
 extern kmem_cache_t *cifs_oplock_cachep;
 
@@ -151,6 +151,7 @@
 	set_fs(get_ds());
 	rc = sock_sendmsg(ssocket, &smb_msg, smb_buf_length + 4);
 	while((rc == -ENOSPC) || (rc == -EAGAIN)) {
+		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ/2);
 		rc = sock_sendmsg(ssocket, &smb_msg, smb_buf_length + 4);
 	}
@@ -233,15 +234,30 @@
 		timeout = 15 * HZ;
 	/* wait for 15 seconds or until woken up due to response arriving or 
 	   due to last connection to this server being unmounted */
-
-	timeout = wait_event_interruptible_timeout(ses->server->response_q,
-				midQ->
-				midState & MID_RESPONSE_RECEIVED,
-				timeout);
 	if (signal_pending(current)) {
-		cFYI(1, ("CIFS: caught signal"));
+		/* if signal pending do not hold up user for full smb timeout
+		but we still give response a change to complete */
+		if(midQ->midState & MID_REQUEST_SUBMITTED) {
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			timeout = schedule_timeout(2 * HZ);
+		}
+	} else { /* using normal timeout */
+		/* timeout = wait_event_interruptible_timeout(ses->server->response_q,
+			(midQ->midState & MID_RESPONSE_RECEIVED) || 
+			((ses->server->tcpStatus != CifsGood) &&
+			 (ses->server->tcpStatus != CifsNew)),
+			timeout); */ 
+		/* Can not allow user interrupts- wreaks havoc with performance */
+		if(midQ->midState & MID_REQUEST_SUBMITTED) {
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			timeout = schedule_timeout(timeout);
+		}
+	}
+	if (signal_pending(current)) {
+		if (midQ->resp_buf == NULL)
+			rc = -EINTR; /* BB are we supposed to return -ERESTARTSYS ? */
 		DeleteMidQEntry(midQ);
-		return -EINTR;
+		return rc; /* why bother returning an error if it succeeded */
 	} else {  /* BB spinlock protect this against races with demux thread */
 		spin_lock(&GlobalMid_Lock);
 		if (midQ->resp_buf) {
@@ -254,16 +270,18 @@
 				if(ses->server->tcpStatus == CifsExiting)
 					rc = -EHOSTDOWN;
 				else {
-				ses->server->tcpStatus = CifsNeedReconnect;
-				midQ->midState = MID_RETRY_NEEDED;
+					ses->server->tcpStatus = CifsNeedReconnect;
+					midQ->midState = MID_RETRY_NEEDED;
 				}
 			}
 
-			if(midQ->midState == MID_RETRY_NEEDED) {
-				rc = -EAGAIN;
-				cFYI(1,("marking request for retry"));
-			} else {
-				rc = -EIO;
+			if (rc != -EHOSTDOWN) {
+				if(midQ->midState == MID_RETRY_NEEDED) {
+					rc = -EAGAIN;
+					cFYI(1,("marking request for retry"));
+				} else {
+					rc = -EIO;
+				}
 			}
 			spin_unlock(&GlobalMid_Lock);
 			DeleteMidQEntry(midQ);
