From: Hannes Reinecke <hare@suse.de>
Subject: align iscsitarget with open-scsi header definitions

use iscsi_proto.h from open-iscsi instead of the homegrown
iscsi_hdr.h.

diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/digest.c linux-2.6.12/drivers/scsi/iscsitarget/digest.c
--- linux-2.6.orig/drivers/scsi/iscsitarget/digest.c	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/digest.c	2005-08-22 10:25:04.000000000 +0200
@@ -101,7 +101,7 @@ static inline void __dbg_simulate_header
 		printk("\tcmnd: 0x%x, itt 0x%x, sn 0x%x\n",
 		       cmnd_opcode(cmnd),
 		       be32_to_cpu(cmnd->pdu.bhs.itt),
-		       be32_to_cpu(cmnd->pdu.bhs.sn));
+		       be32_to_cpu(cmnd->pdu.bhs.statsn));
 		cmnd->hdigest = ~cmnd->hdigest;
 		/* make things even worse by manipulating header fields */
 		cmnd->pdu.datasize += 8;
@@ -146,7 +146,7 @@ static inline void __dbg_simulate_data_d
 		printk("\tcmnd 0x%x, itt 0x%x, sn 0x%x\n",
 		       cmnd_opcode(cmnd),
 		       be32_to_cpu(cmnd->pdu.bhs.itt),
-		       be32_to_cpu(cmnd->pdu.bhs.sn));
+		       be32_to_cpu(cmnd->pdu.bhs.statsn));
 		cmnd->ddigest = ~cmnd->ddigest;
 		num_errs++;
 		num_cmnds = 0;
@@ -237,10 +237,10 @@ int digest_rx_data(struct iscsi_cmnd *cm
 
 	if (cmnd_opcode(cmnd) == ISCSI_OP_SCSI_DATA_OUT) {
 		struct iscsi_cmnd *scsi_cmnd = cmnd->req;
-		struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *)&cmnd->pdu.bhs;
+		struct iscsi_data *req = (struct iscsi_data *)&cmnd->pdu.bhs;
 
 		tio = scsi_cmnd->tio;
-		offset = be32_to_cpu(req->buffer_offset);
+		offset = be32_to_cpu(req->offset);
 	} else {
 		tio = cmnd->tio;
 		offset = 0;
@@ -259,9 +259,9 @@ int digest_rx_data(struct iscsi_cmnd *cm
 void digest_tx_data(struct iscsi_cmnd *cmnd)
 {
 	struct tio *tio = cmnd->tio;
-	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *)&cmnd->pdu.bhs;
+	struct iscsi_data *req = (struct iscsi_data *)&cmnd->pdu.bhs;
 
 	assert(tio);
 	digest_data(cmnd->conn->tx_digest_tfm, cmnd, tio,
-		    be32_to_cpu(req->buffer_offset), (u8 *) &cmnd->ddigest);
+		    be32_to_cpu(req->offset), (u8 *) &cmnd->ddigest);
 }
diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/event.c linux-2.6.12/drivers/scsi/iscsitarget/event.c
--- linux-2.6.orig/drivers/scsi/iscsitarget/event.c	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/event.c	2005-08-22 10:29:29.000000000 +0200
@@ -7,7 +7,7 @@
  */
 
 #include <net/tcp.h>
-#include "iet_u.h"
+#include "iscsi.h"
 #include "iscsi_dbg.h"
 
 static struct sock *nl;
diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/iscsi.c linux-2.6.12/drivers/scsi/iscsitarget/iscsi.c
--- linux-2.6.orig/drivers/scsi/iscsitarget/iscsi.c	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/iscsi.c	2005-08-22 10:21:22.000000000 +0200
@@ -24,21 +24,21 @@ extern struct file_operations ctr_fops;
 
 static u32 cmnd_write_size(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *hdr = cmnd_hdr(cmnd);
+	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
 
-	if (hdr->flags & ISCSI_CMD_WRITE)
-		return be32_to_cpu(hdr->data_length);
+	if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
+		return ntoh24(hdr->dlength);
 	return 0;
 }
 
 static u32 cmnd_read_size(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *hdr = cmnd_hdr(cmnd);
+	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
 
-	if (hdr->flags & ISCSI_CMD_READ) {
-		if (!(hdr->flags & ISCSI_CMD_WRITE))
-			return be32_to_cpu(hdr->data_length);
-		if (hdr->flags & ISCSI_CMD_READ) {
+	if (hdr->flags & ISCSI_FLAG_CMD_READ) {
+		if (!(hdr->flags & ISCSI_FLAG_CMD_WRITE))
+			return ntoh24(hdr->dlength);
+		if (hdr->flags & ISCSI_FLAG_CMD_READ) {
 			struct iscsi_rlength_ahdr *ahdr =
 				(struct iscsi_rlength_ahdr *)cmnd->pdu.ahs;
 			if (ahdr && ahdr->ahstype == ISCSI_AHSTYPE_RLENGTH)
@@ -60,19 +60,19 @@ static void iscsi_scsi_queuecmnd(struct 
 
 	dprintk(D_GENERIC, "%p\n", cmnd);
 
-	if ((cmnd->pdu.bhs.flags & ISCSI_CMD_ATTR_MASK) != ISCSI_CMD_UNTAGGED &&
-	    (cmnd->pdu.bhs.flags & ISCSI_CMD_ATTR_MASK) != ISCSI_CMD_SIMPLE) {
-		cmnd->pdu.bhs.flags &= ~ISCSI_CMD_ATTR_MASK;
-		cmnd->pdu.bhs.flags |= ISCSI_CMD_UNTAGGED;
+	if ((cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK) != ISCSI_ATTR_UNTAGGED &&
+	    (cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK) != ISCSI_ATTR_SIMPLE) {
+		cmnd->pdu.bhs.flags &= ~ISCSI_FLAG_CMD_ATTR_MASK;
+		cmnd->pdu.bhs.flags |= ISCSI_ATTR_UNTAGGED;
 	}
 
 	spin_lock(&queue->queue_lock);
 
 	set_cmnd_queued(cmnd);
 
-	switch (cmnd->pdu.bhs.flags & ISCSI_CMD_ATTR_MASK) {
-	case ISCSI_CMD_UNTAGGED:
-	case ISCSI_CMD_SIMPLE:
+	switch (cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK) {
+	case ISCSI_ATTR_UNTAGGED:
+	case ISCSI_ATTR_SIMPLE:
 		if (!list_empty(&queue->wait_list) || queue->ordered_cmnd)
 			goto pending;
 		queue->active_cnt++;
@@ -101,14 +101,14 @@ static void iscsi_scsi_dequeuecmnd(struc
 		return;
 	queue = &cmnd->lun->queue;
 	spin_lock(&queue->queue_lock);
-	switch (cmnd->pdu.bhs.flags & ISCSI_CMD_ATTR_MASK) {
-	case ISCSI_CMD_UNTAGGED:
-	case ISCSI_CMD_SIMPLE:
+	switch (cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK) {
+	case ISCSI_ATTR_UNTAGGED:
+	case ISCSI_ATTR_SIMPLE:
 		--queue->active_cnt;
 		break;
-	case ISCSI_CMD_ORDERED:
-	case ISCSI_CMD_HEAD_OF_QUEUE:
-	case ISCSI_CMD_ACA:
+	case ISCSI_ATTR_ORDERED:
+	case ISCSI_ATTR_HEAD_OF_QUEUE:
+	case ISCSI_ATTR_ACA:
 		BUG();
 	default:
 		/* Should the iscsi_scsi_queuecmnd func reject this ? */
@@ -117,16 +117,16 @@ static void iscsi_scsi_dequeuecmnd(struc
 
 	while (!list_empty(&queue->wait_list)) {
 		cmnd = list_entry(queue->wait_list.next, struct iscsi_cmnd, list);
-		switch ((cmnd->pdu.bhs.flags & ISCSI_CMD_ATTR_MASK)) {
-		case ISCSI_CMD_UNTAGGED:
-		case ISCSI_CMD_SIMPLE:
+		switch ((cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK)) {
+		case ISCSI_ATTR_UNTAGGED:
+		case ISCSI_ATTR_SIMPLE:
 			list_del_init(&cmnd->list);
 			queue->active_cnt++;
 			iscsi_device_queue_cmnd(cmnd);
 			break;
-		case ISCSI_CMD_ORDERED:
-		case ISCSI_CMD_HEAD_OF_QUEUE:
-		case ISCSI_CMD_ACA:
+		case ISCSI_ATTR_ORDERED:
+		case ISCSI_ATTR_HEAD_OF_QUEUE:
+		case ISCSI_ATTR_ACA:
 			BUG();
 		}
 	}
@@ -242,8 +242,8 @@ static void do_send_data_rsp(struct iscs
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iscsi_cmnd *data_cmnd;
 	struct tio *tio = cmnd->tio;
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
-	struct iscsi_data_in_hdr *rsp;
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
+	struct iscsi_data_rsp *rsp;
 	u32 pdusize, expsize, scsisize, size, offset, sn;
 	LIST_HEAD(send);
 
@@ -258,24 +258,24 @@ static void do_send_data_rsp(struct iscs
 		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size <= pdusize);
 		tio_get(tio);
 		data_cmnd->tio = tio;
-		rsp = (struct iscsi_data_in_hdr *)&data_cmnd->pdu.bhs;
+		rsp = (struct iscsi_data_rsp *)&data_cmnd->pdu.bhs;
 
 		rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
 		rsp->itt = req->itt;
 		rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-		rsp->buffer_offset = offset;
-		rsp->data_sn = cpu_to_be32(sn);
+		rsp->offset = offset;
+		rsp->datasn = cpu_to_be32(sn);
 
 		if (size <= pdusize) {
 			data_cmnd->pdu.datasize = size;
-			rsp->flags = ISCSI_FLG_FINAL | ISCSI_FLG_STATUS;
+			rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
 
 			scsisize = tio->size;
 			if (scsisize < expsize) {
-				rsp->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+				rsp->flags |= ISCSI_FLAG_DATA_UNDERFLOW;
 				size = expsize - scsisize;
 			} else if (scsisize > expsize) {
-				rsp->flags |= ISCSI_FLG_RESIDUAL_OVERFLOW;
+				rsp->flags |= ISCSI_FLAG_DATA_OVERFLOW;
 				size = scsisize - expsize;
 			} else
 				size = 0;
@@ -300,15 +300,15 @@ static void do_send_data_rsp(struct iscs
 static struct iscsi_cmnd *create_scsi_rsp(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_cmd_hdr *req_hdr = cmnd_hdr(req);
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd_rsp *rsp_hdr;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *)&rsp->pdu.bhs;
-	rsp_hdr->opcode = ISCSI_OP_SCSI_RSP;
-	rsp_hdr->flags = ISCSI_FLG_FINAL;
-	rsp_hdr->response = ISCSI_RESPONSE_COMMAND_COMPLETED;
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp_hdr->cmd_status = SAM_STAT_GOOD;
 	rsp_hdr->itt = req_hdr->itt;
 
@@ -318,13 +318,13 @@ static struct iscsi_cmnd *create_scsi_rs
 void send_scsi_rsp(struct iscsi_cmnd *req, int (*func)(struct iscsi_cmnd *))
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd_rsp *rsp_hdr;
 	u32 size;
 
 	rsp = create_scsi_rsp(req);
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *) &rsp->pdu.bhs;
+	rsp_hdr = (struct iscsi_cmd_rsp *) &rsp->pdu.bhs;
 	if ((size = cmnd_read_size(req)) != 0) {
-		rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+		rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 		rsp_hdr->residual_count = cpu_to_be32(size);
 	}
 
@@ -338,16 +338,16 @@ static struct iscsi_cmnd *create_sense_r
 					   u8 sense_key, u8 asc, u8 ascq)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd_rsp *rsp_hdr;
 	struct tio *tio;
 	struct iscsi_sense_data *sense;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *)&rsp->pdu.bhs;
-	rsp_hdr->opcode = ISCSI_OP_SCSI_RSP;
-	rsp_hdr->flags = ISCSI_FLG_FINAL;
-	rsp_hdr->response = ISCSI_RESPONSE_COMMAND_COMPLETED;
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
@@ -399,16 +399,16 @@ void iscsi_cmnd_remove(struct iscsi_cmnd
 	kfree(cmnd->pdu.ahs);
 
 	if (!list_empty(&cmnd->list)) {
-		struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+		struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
 		eprintk("cmnd %p still on some list?, %x, %x, %x, %x, %x, %x, %x %lx %lx\n",
-			cmnd, req->opcode, req->scb[0], req->flags, req->itt,
-			be32_to_cpu(req->data_length),
-			req->cmd_sn, be32_to_cpu(cmnd->pdu.datasize), cmnd->state, conn->state);
+			cmnd, req->opcode, req->cdb[0], req->flags, req->itt,
+			ntoh24(req->dlength),
+			req->cmdsn, be32_to_cpu(cmnd->pdu.datasize), cmnd->state, conn->state);
 
 		if (cmnd->req) {
-			struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd->req);
-			eprintk("%p %x %u\n", req, req->opcode, req->scb[0]);
+			struct iscsi_cmd *req = cmnd_hdr(cmnd->req);
+			eprintk("%p %x %u\n", req, req->opcode, req->cdb[0]);
 		}
 		dump_stack();
 		BUG();
@@ -434,7 +434,7 @@ static void cmnd_skip_pdu(struct iscsi_c
 	int i;
 
 	eprintk("%x %x %x %u\n", cmnd_itt(cmnd), cmnd_opcode(cmnd),
-		cmnd_hdr(cmnd)->scb[0], cmnd->pdu.datasize);
+		cmnd_hdr(cmnd)->cdb[0], cmnd->pdu.datasize);
 
 	if (!(size = cmnd->pdu.datasize))
 		return;
@@ -462,12 +462,12 @@ static void cmnd_skip_pdu(struct iscsi_c
 static void iscsi_cmnd_reject(struct iscsi_cmnd *req, int reason)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_reject_hdr *rsp_hdr;
+	struct iscsi_reject *rsp_hdr;
 	struct tio *tio;
 	char *addr;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_reject_hdr *)&rsp->pdu.bhs;
+	rsp_hdr = (struct iscsi_reject *)&rsp->pdu.bhs;
 
 	rsp_hdr->opcode = ISCSI_OP_REJECT;
 	rsp_hdr->ffffffff = ISCSI_RESERVED_TAG;
@@ -489,9 +489,9 @@ static void cmnd_set_sn(struct iscsi_cmn
 	struct iscsi_session *sess = conn->session;
 
 	if (set_stat_sn)
-		cmnd->pdu.bhs.sn = cpu_to_be32(conn->stat_sn++);
-	cmnd->pdu.bhs.exp_sn = cpu_to_be32(sess->exp_cmd_sn);
-	cmnd->pdu.bhs.max_sn = cpu_to_be32(sess->exp_cmd_sn + sess->max_queued_cmnds);
+		cmnd->pdu.bhs.statsn = cpu_to_be32(conn->stat_sn++);
+	cmnd->pdu.bhs.exp_statsn = cpu_to_be32(sess->exp_cmd_sn);
+	cmnd->pdu.bhs.max_statsn = cpu_to_be32(sess->exp_cmd_sn + sess->max_queued_cmnds);
 }
 
 static void update_stat_sn(struct iscsi_cmnd *cmnd)
@@ -499,7 +499,7 @@ static void update_stat_sn(struct iscsi_
 	struct iscsi_conn *conn = cmnd->conn;
 	u32 exp_stat_sn;
 
-	cmnd->pdu.bhs.exp_sn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_sn);
+	cmnd->pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_statsn);
 	dprintk(D_GENERIC, "%x,%x\n", cmnd_opcode(cmnd), exp_stat_sn);
 	if ((int)(exp_stat_sn - conn->exp_stat_sn) > 0 &&
 	    (int)(exp_stat_sn - conn->stat_sn) <= 0) {
@@ -513,7 +513,7 @@ static int check_cmd_sn(struct iscsi_cmn
 	struct iscsi_session *session = cmnd->conn->session;
 	u32 cmd_sn;
 
-	cmnd->pdu.bhs.sn = cmd_sn = be32_to_cpu(cmnd->pdu.bhs.sn);
+	cmnd->pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd->pdu.bhs.statsn);
 	dprintk(D_GENERIC, "%d(%d)\n", cmd_sn, session->exp_cmd_sn);
 	if ((s32)(cmd_sn - session->exp_cmd_sn) >= 0)
 		return 0;
@@ -613,28 +613,28 @@ static void cmnd_remove_hash(struct iscs
 static void cmnd_skip_data(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd_rsp *rsp_hdr;
 	u32 size;
 
 	rsp = get_rsp_cmnd(req);
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *)&rsp->pdu.bhs;
-	if (cmnd_opcode(rsp) != ISCSI_OP_SCSI_RSP) {
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	if (cmnd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
 		eprintk("unexpected response command %u\n", cmnd_opcode(rsp));
 		return;
 	}
 
 	size = cmnd_write_size(req);
 	if (size) {
-		rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+		rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 		rsp_hdr->residual_count = cpu_to_be32(size);
 	}
 	size = cmnd_read_size(req);
 	if (size) {
-		if (cmnd_hdr(req)->flags & ISCSI_CMD_WRITE) {
-			rsp_hdr->flags |= ISCSI_FLG_BIRESIDUAL_UNDERFLOW;
+		if (cmnd_hdr(req)->flags & ISCSI_FLAG_CMD_WRITE) {
+			rsp_hdr->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
 			rsp_hdr->bi_residual_count = cpu_to_be32(size);
 		} else {
-			rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+			rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 			rsp_hdr->residual_count = cpu_to_be32(size);
 		}
 	}
@@ -725,7 +725,7 @@ static void set_offset_and_length(struct
 	*len <<= lu->blk_shift;
 }
 
-static u32 translate_lun(u16 * data)
+static u32 translate_lun(u8 * data)
 {
 	u8 *p = (u8 *) data;
 	u32 lun = ~0U;
@@ -750,7 +750,7 @@ static u32 translate_lun(u16 * data)
 static void send_r2t(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_r2t_hdr *rsp_hdr;
+	struct iscsi_r2t_rsp *rsp_hdr;
 	u32 length, offset, burst;
 	LIST_HEAD(send);
 
@@ -762,13 +762,13 @@ static void send_r2t(struct iscsi_cmnd *
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
 		rsp->pdu.bhs.ttt = req->target_task_tag;
 
-		rsp_hdr = (struct iscsi_r2t_hdr *)&rsp->pdu.bhs;
+		rsp_hdr = (struct iscsi_r2t_rsp *)&rsp->pdu.bhs;
 		rsp_hdr->opcode = ISCSI_OP_R2T;
-		rsp_hdr->flags = ISCSI_FLG_FINAL;
+		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 		memcpy(rsp_hdr->lun, cmnd_hdr(req)->lun, 8);
 		rsp_hdr->itt = cmnd_hdr(req)->itt;
-		rsp_hdr->r2t_sn = cpu_to_be32(req->r2t_sn++);
-		rsp_hdr->buffer_offset = cpu_to_be32(offset);
+		rsp_hdr->r2tsn = cpu_to_be32(req->r2t_sn++);
+		rsp_hdr->data_offset = cpu_to_be32(offset);
 		if (length > burst) {
 			rsp_hdr->data_length = cpu_to_be32(burst);
 			length -= burst;
@@ -780,8 +780,8 @@ static void send_r2t(struct iscsi_cmnd *
 
 		dprintk(D_WRITE, "%x %u %u %u %u\n", cmnd_itt(req),
 			be32_to_cpu(rsp_hdr->data_length),
-			be32_to_cpu(rsp_hdr->buffer_offset),
-			be32_to_cpu(rsp_hdr->r2t_sn), req->outstanding_r2t);
+			be32_to_cpu(rsp_hdr->data_offset),
+			be32_to_cpu(rsp_hdr->r2tsn), req->outstanding_r2t);
 
 		list_add_tail(&rsp->list, &send);
 
@@ -883,18 +883,18 @@ static u32 get_next_ttt(struct iscsi_ses
 
 static void scsi_cmnd_start(struct iscsi_conn *conn, struct iscsi_cmnd *req)
 {
-	struct iscsi_scsi_cmd_hdr *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
 
-	dprintk(D_GENERIC, "scsi command: %02x\n", req_hdr->scb[0]);
+	dprintk(D_GENERIC, "scsi command: %02x\n", req_hdr->cdb[0]);
 
 	req->lun = volume_get(conn->session->target, translate_lun(req_hdr->lun));
 	if (!req->lun) {
-		switch (req_hdr->scb[0]) {
+		switch (req_hdr->cdb[0]) {
 		case INQUIRY:
 		case REPORT_LUNS:
 			break;
 		default:
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 			create_sense_rsp(req, ILLEGAL_REQUEST, 0x25, 0x0);
 			cmnd_skip_data(req);
 			goto out;
@@ -902,9 +902,9 @@ static void scsi_cmnd_start(struct iscsi
 	} else
 		set_cmnd_lunit(req);
 
-	switch (req_hdr->scb[0]) {
+	switch (req_hdr->cdb[0]) {
 	case SERVICE_ACTION_IN:
-		if ((req_hdr->scb[1] & 0x1f) != 0x10)
+		if ((req_hdr->cdb[1] & 0x1f) != 0x10)
 			goto error;
 	case INQUIRY:
 	case REPORT_LUNS:
@@ -921,9 +921,9 @@ static void scsi_cmnd_start(struct iscsi
 	case RESERVE_10:
 	case RELEASE_10:
 	{
-		if (!(req_hdr->flags & ISCSI_CMD_FINAL) || req->pdu.datasize) {
+		if (!(req_hdr->flags & ISCSI_FLAG_CMD_FINAL) || req->pdu.datasize) {
 			/* unexpected unsolicited data */
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
 			cmnd_skip_data(req);
 		}
@@ -936,14 +936,14 @@ static void scsi_cmnd_start(struct iscsi
 		loff_t offset;
 		u32 length;
 
-		if (!(req_hdr->flags & ISCSI_CMD_FINAL) || req->pdu.datasize) {
+		if (!(req_hdr->flags & ISCSI_FLAG_CMD_FINAL) || req->pdu.datasize) {
 			/* unexpected unsolicited data */
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
 			cmnd_skip_data(req);
 		}
 
-		set_offset_and_length(req->lun, req_hdr->scb, &offset, &length);
+		set_offset_and_length(req->lun, req_hdr->cdb, &offset, &length);
 		req->tio = tio_alloc(get_pgcnt(length, offset));
 		tio_set(req->tio, length, offset);
 		break;
@@ -958,19 +958,19 @@ static void scsi_cmnd_start(struct iscsi
 		u32 length;
 
 		req->r2t_length = be32_to_cpu(req_hdr->data_length) - req->pdu.datasize;
-		req->is_unsolicited_data = !(req_hdr->flags & ISCSI_CMD_FINAL);
+		req->is_unsolicited_data = !(req_hdr->flags & ISCSI_FLAG_CMD_FINAL);
 		req->target_task_tag = get_next_ttt(conn->session);
 
 		if (!param->immediate_data && req->pdu.datasize)
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 
-		if (param->initial_r2t && !(req_hdr->flags & ISCSI_CMD_FINAL))
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+		if (param->initial_r2t && !(req_hdr->flags & ISCSI_FLAG_CMD_FINAL))
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 
-		if (req_hdr->scb[0] == WRITE_VERIFY && req_hdr->scb[1] & 0x02)
+		if (req_hdr->cdb[0] == WRITE_VERIFY && req_hdr->cdb[1] & 0x02)
 			eprintk("Verification is ignored %x\n", cmnd_itt(req));
 
-		set_offset_and_length(req->lun, req_hdr->scb, &offset, &length);
+		set_offset_and_length(req->lun, req_hdr->cdb, &offset, &length);
 		if (cmnd_write_size(req) != length)
 			eprintk("%x %u %u\n", cmnd_itt(req), cmnd_write_size(req), length);
 
@@ -985,7 +985,7 @@ static void scsi_cmnd_start(struct iscsi
 	}
 	error:
 	default:
-		eprintk("Unsupported %x\n", req_hdr->scb[0]);
+		eprintk("Unsupported %x\n", req_hdr->cdb[0]);
 		create_sense_rsp(req, ILLEGAL_REQUEST, 0x20, 0x0);
 		cmnd_skip_data(req);
 		break;
@@ -997,9 +997,9 @@ out:
 
 static void data_out_start(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *)&cmnd->pdu.bhs;
+	struct iscsi_data *req = (struct iscsi_data *)&cmnd->pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd = NULL;
-	u32 offset = be32_to_cpu(req->buffer_offset);
+	u32 offset = be32_to_cpu(req->offset);
 
 	update_stat_sn(cmnd);
 
@@ -1026,7 +1026,7 @@ static void data_out_start(struct iscsi_
 
 	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		/* unsolicited burst data */
-		if (scsi_cmnd->pdu.bhs.flags & ISCSI_FLG_FINAL) {
+		if (scsi_cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_FINAL) {
 			eprintk("unexpected data from %x %x\n",
 				cmnd_itt(cmnd), cmnd_ttt(cmnd));
 			goto skip_data;
@@ -1048,7 +1048,7 @@ skip_data:
 
 static void data_out_end(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *) &cmnd->pdu.bhs;
+	struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd;
 	u32 offset;
 
@@ -1059,7 +1059,7 @@ static void data_out_end(struct iscsi_co
 	if (conn->read_overflow) {
 		eprintk("%x %u\n", cmnd_itt(cmnd), conn->read_overflow);
 		assert(scsi_cmnd->tio);
-		offset = be32_to_cpu(req->buffer_offset);
+		offset = be32_to_cpu(req->offset);
 		offset += cmnd->pdu.datasize - conn->read_overflow;
 		if (cmnd_recv_pdu(conn, scsi_cmnd->tio, offset, conn->read_overflow) < 0)
 			assert(0);
@@ -1067,17 +1067,17 @@ static void data_out_end(struct iscsi_co
 	}
 
 	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (req->flags & ISCSI_FLG_FINAL) {
+		if (req->flags & ISCSI_FLAG_CMD_FINAL) {
 			scsi_cmnd->is_unsolicited_data = 0;
 			if (!cmnd_pending(scsi_cmnd))
 				scsi_cmnd_exec(scsi_cmnd);
 		}
 	} else {
 		/* TODO : proper error handling */
-		if (!(req->flags & ISCSI_FLG_FINAL) && scsi_cmnd->r2t_length == 0)
+		if (!(req->flags & ISCSI_FLAG_CMD_FINAL) && scsi_cmnd->r2t_length == 0)
 			eprintk("initiator error %x\n", cmnd_itt(scsi_cmnd));
 
-		if (!(req->flags & ISCSI_FLG_FINAL))
+		if (!(req->flags & ISCSI_FLAG_CMD_FINAL))
 			goto out;
 
 		scsi_cmnd->outstanding_r2t--;
@@ -1099,13 +1099,13 @@ static int __cmnd_abort(struct iscsi_cmn
 		cmnd_release(cmnd, 1);
 		return 0;
 	} else
-		return -ISCSI_RESPONSE_UNKNOWN_TASK;
+		return -ISCSI_TMF_RSP_NO_TASK;
 }
 
 static int cmnd_abort(struct iscsi_session *session, u32 itt)
 {
 	struct iscsi_cmnd *cmnd;
-	int err =  -ISCSI_RESPONSE_UNKNOWN_TASK;
+	int err =  -ISCSI_TMF_RSP_NO_TASK;
 
 	if ((cmnd = cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG))) {
 		eprintk("%x %x %x %u %u %u %u\n", cmnd_itt(cmnd), cmnd_opcode(cmnd),
@@ -1161,62 +1161,62 @@ static void execute_task_management(stru
 	struct iscsi_conn *conn = req->conn;
 	struct iscsi_target *target = conn->session->target;
 	struct iscsi_cmnd *rsp;
-	struct iscsi_task_mgt_hdr *req_hdr = (struct iscsi_task_mgt_hdr *)&req->pdu.bhs;
-	struct iscsi_task_rsp_hdr *rsp_hdr;
+	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&req->pdu.bhs;
+	struct iscsi_tm_rsp *rsp_hdr;
 	u32 lun;
-	int err, function = req_hdr->function & ISCSI_FUNCTION_MASK;
+	int err, function = req_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_task_rsp_hdr *)&rsp->pdu.bhs;
+	rsp_hdr = (struct iscsi_tm_rsp *)&rsp->pdu.bhs;
 
-	rsp_hdr->opcode = ISCSI_OP_SCSI_TASK_MGT_RSP;
-	rsp_hdr->flags = ISCSI_FLG_FINAL;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_TMFUNC;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->itt = req_hdr->itt;
-	rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_COMPLETE;
+	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE;
 
 	eprintk("%x %d %x\n", cmnd_itt(req), function, req_hdr->rtt);
 
 	switch (function) {
-	case ISCSI_FUNCTION_ABORT_TASK:
-	case ISCSI_FUNCTION_ABORT_TASK_SET:
-	case ISCSI_FUNCTION_CLEAR_ACA:
-	case ISCSI_FUNCTION_CLEAR_TASK_SET:
-	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET:
+	case ISCSI_TM_FUNC_ABORT_TASK:
+	case ISCSI_TM_FUNC_ABORT_TASK_SET:
+	case ISCSI_TM_FUNC_CLEAR_ACA:
+	case ISCSI_TM_FUNC_CLEAR_TASK_SET:
+	case ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:
 		lun = translate_lun(req_hdr->lun);
 		if (!volume_lookup(target, lun)) {
-			rsp_hdr->response = ISCSI_RESPONSE_UNKNOWN_LUN;
+			rsp_hdr->response = ISCSI_TMF_RSP_NO_LUN;
 			goto out;
 		}
 	}
 
 	switch (function) {
-	case ISCSI_FUNCTION_ABORT_TASK:
+	case ISCSI_TM_FUNC_ABORT_TASK:
 		if ((err = cmnd_abort(conn->session, req_hdr->rtt)) < 0)
 			rsp_hdr->response = -err;
 		break;
-	case ISCSI_FUNCTION_ABORT_TASK_SET:
+	case ISCSI_TM_FUNC_ABORT_TASK_SET:
 		task_set_abort(req);
 		break;
-	case ISCSI_FUNCTION_CLEAR_ACA:
-		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED;
+	case ISCSI_TM_FUNC_CLEAR_ACA:
+		rsp_hdr->response = ISCSI_TMF_RSP_NOT_SUPPORTED;
 		break;
-	case ISCSI_FUNCTION_CLEAR_TASK_SET:
-		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED;
+	case ISCSI_TM_FUNC_CLEAR_TASK_SET:
+		rsp_hdr->response = ISCSI_TMF_RSP_NOT_SUPPORTED;
 		break;
-	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET:
+	case ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:
 		target_reset(req, translate_lun(req_hdr->lun), 0);
 		break;
-	case ISCSI_FUNCTION_TARGET_WARM_RESET:
-	case ISCSI_FUNCTION_TARGET_COLD_RESET:
+	case ISCSI_TM_FUNC_TARGET_WARM_RESET:
+	case ISCSI_TM_FUNC_TARGET_COLD_RESET:
 		target_reset(req, 0, 1);
-		if (function == ISCSI_FUNCTION_TARGET_COLD_RESET)
+		if (function == ISCSI_TM_FUNC_TARGET_COLD_RESET)
 			set_cmnd_close(rsp);
 		break;
-	case ISCSI_FUNCTION_TASK_REASSIGN:
-		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED;
+	case ISCSI_TM_FUNC_TASK_REASSIGN:
+		rsp_hdr->response = ISCSI_TMF_RSP_NOT_SUPPORTED;
 		break;
 	default:
-		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_REJECTED;
+		rsp_hdr->response = ISCSI_TMF_RSP_REJECTED;
 		break;
 	}
 out:
@@ -1226,14 +1226,14 @@ out:
 static void noop_out_exec(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_nop_in_hdr *rsp_hdr;
+	struct iscsi_nopin *rsp_hdr;
 
 	if (cmnd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
-		rsp_hdr = (struct iscsi_nop_in_hdr *)&rsp->pdu.bhs;
+		rsp_hdr = (struct iscsi_nopin *)&rsp->pdu.bhs;
 		rsp_hdr->opcode = ISCSI_OP_NOOP_IN;
-		rsp_hdr->flags = ISCSI_FLG_FINAL;
+		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 		rsp_hdr->itt = req->pdu.bhs.itt;
 		rsp_hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
 
@@ -1256,15 +1256,15 @@ static void noop_out_exec(struct iscsi_c
 
 static void logout_exec(struct iscsi_cmnd *req)
 {
-	struct iscsi_logout_req_hdr *req_hdr;
+	struct iscsi_logout *req_hdr;
 	struct iscsi_cmnd *rsp;
-	struct iscsi_logout_rsp_hdr *rsp_hdr;
+	struct iscsi_logout_rsp *rsp_hdr;
 
-	req_hdr = (struct iscsi_logout_req_hdr *)&req->pdu.bhs;
+	req_hdr = (struct iscsi_logout *)&req->pdu.bhs;
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_logout_rsp_hdr *)&rsp->pdu.bhs;
+	rsp_hdr = (struct iscsi_logout_rsp *)&rsp->pdu.bhs;
 	rsp_hdr->opcode = ISCSI_OP_LOGOUT_RSP;
-	rsp_hdr->flags = ISCSI_FLG_FINAL;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->itt = req_hdr->itt;
 	set_cmnd_close(rsp);
 	iscsi_cmnd_init_write(rsp);
@@ -1272,7 +1272,7 @@ static void logout_exec(struct iscsi_cmn
 
 static void iscsi_cmnd_exec(struct iscsi_cmnd *cmnd)
 {
-	dprintk(D_GENERIC, "%p,%x,%u\n", cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.sn);
+	dprintk(D_GENERIC, "%p,%x,%u\n", cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.statsn);
 
 	switch (cmnd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_OUT:
@@ -1281,17 +1281,17 @@ static void iscsi_cmnd_exec(struct iscsi
 	case ISCSI_OP_SCSI_CMD:
 		scsi_cmnd_exec(cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
+	case ISCSI_OP_SCSI_TMFUNC:
 		execute_task_management(cmnd);
 		break;
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_LOGOUT:
 		logout_exec(cmnd);
 		break;
 	case ISCSI_OP_SCSI_REJECT:
 		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
 		break;
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_SNACK_CMD:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
 		break;
 	default:
 		eprintk("unexpected cmnd op %x\n", cmnd_opcode(cmnd));
@@ -1405,11 +1405,11 @@ void cmnd_tx_start(struct iscsi_cmnd *cm
 		cmnd_set_sn(cmnd, 1);
 		cmnd_send_pdu(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_RSP:
+	case ISCSI_OP_SCSI_CMD_RSP:
 		cmnd_set_sn(cmnd, 1);
 		cmnd_send_pdu(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
 		cmnd_set_sn(cmnd, 1);
 		break;
 	case ISCSI_OP_TEXT_RSP:
@@ -1417,12 +1417,12 @@ void cmnd_tx_start(struct iscsi_cmnd *cm
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
 	{
-		struct iscsi_data_in_hdr *rsp = (struct iscsi_data_in_hdr *)&cmnd->pdu.bhs;
+		struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *)&cmnd->pdu.bhs;
 		u32 offset;
 
-		cmnd_set_sn(cmnd, (rsp->flags & ISCSI_FLG_FINAL) ? 1 : 0);
-		offset = rsp->buffer_offset;
-		rsp->buffer_offset = cpu_to_be32(offset);
+		cmnd_set_sn(cmnd, (rsp->flags & ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
+		offset = rsp->offset;
+		rsp->offset = cpu_to_be32(offset);
 		__cmnd_send_pdu(conn, cmnd->tio, offset, cmnd->pdu.datasize);
 		break;
 	}
@@ -1431,9 +1431,9 @@ void cmnd_tx_start(struct iscsi_cmnd *cm
 		break;
 	case ISCSI_OP_R2T:
 		cmnd_set_sn(cmnd, 0);
-		cmnd->pdu.bhs.sn = cpu_to_be32(conn->stat_sn);
+		cmnd->pdu.bhs.statsn = cpu_to_be32(conn->stat_sn);
 		break;
-	case ISCSI_OP_ASYNC_MSG:
+	case ISCSI_OP_ASYNC_EVENT:
 		cmnd_set_sn(cmnd, 1);
 		break;
 	case ISCSI_OP_REJECT:
@@ -1458,11 +1458,11 @@ void cmnd_tx_end(struct iscsi_cmnd *cmnd
 	dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
 	switch (cmnd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_IN:
-	case ISCSI_OP_SCSI_RSP:
-	case ISCSI_OP_SCSI_TASK_MGT_RSP:
+	case ISCSI_OP_SCSI_CMD_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
 	case ISCSI_OP_TEXT_RSP:
 	case ISCSI_OP_R2T:
-	case ISCSI_OP_ASYNC_MSG:
+	case ISCSI_OP_ASYNC_EVENT:
 	case ISCSI_OP_REJECT:
 	case ISCSI_OP_SCSI_DATA_IN:
 	case ISCSI_OP_LOGOUT_RSP:
@@ -1496,14 +1496,14 @@ static void iscsi_session_push_cmnd(stru
 	u32 cmd_sn;
 
 	dprintk(D_GENERIC, "%p:%x %u,%u\n",
-		cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.sn, session->exp_cmd_sn);
+		cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.statsn, session->exp_cmd_sn);
 
 	if (cmnd->pdu.bhs.opcode & ISCSI_OP_IMMEDIATE) {
 		iscsi_cmnd_exec(cmnd);
 		return;
 	}
 
-	cmd_sn = cmnd->pdu.bhs.sn;
+	cmd_sn = cmnd->pdu.bhs.statsn;
 	if (cmd_sn == session->exp_cmd_sn) {
 		while (1) {
 			session->exp_cmd_sn = ++cmd_sn;
@@ -1512,7 +1512,7 @@ static void iscsi_session_push_cmnd(stru
 			if (list_empty(&session->pending_list))
 				break;
 			cmnd = list_entry(session->pending_list.next, struct iscsi_cmnd, list);
-			if (cmnd->pdu.bhs.sn != cmd_sn)
+			if (cmnd->pdu.bhs.statsn != cmd_sn)
 				break;
 /* 			eprintk("find out-of-order %x %u %u\n", */
 /* 				cmnd_itt(cmnd), cmd_sn, cmnd->pdu.bhs.sn); */
@@ -1532,7 +1532,7 @@ static void iscsi_session_push_cmnd(stru
 
 		list_for_each(entry, &session->pending_list) {
 			struct iscsi_cmnd *tmp = list_entry(entry, struct iscsi_cmnd, list);
-			if (before(cmd_sn, tmp->pdu.bhs.sn))
+			if (before(cmd_sn, tmp->pdu.bhs.statsn))
 				break;
 		}
 
@@ -1578,21 +1578,21 @@ void cmnd_rx_start(struct iscsi_cmnd *cm
 		if (!(err = cmnd_insert_hash(cmnd)))
 			scsi_cmnd_start(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
+	case ISCSI_OP_SCSI_TMFUNC:
 		err = cmnd_insert_hash(cmnd);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		data_out_start(conn, cmnd);
 		break;
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_LOGOUT:
 		err = cmnd_insert_hash(cmnd);
 		break;
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_SNACK_CMD:
-		err = -ISCSI_REASON_UNSUPPORTED_COMMAND;
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
 		break;
 	default:
-		err = -ISCSI_REASON_UNSUPPORTED_COMMAND;
+		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
 		break;
 	}
 
@@ -1611,15 +1611,15 @@ void cmnd_rx_end(struct iscsi_cmnd *cmnd
 	case ISCSI_OP_SCSI_REJECT:
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_CMD:
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_LOGOUT:
 		iscsi_session_push_cmnd(cmnd);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		data_out_end(conn, cmnd);
 		break;
-	case ISCSI_OP_SNACK_CMD:
+	case ISCSI_OP_SNACK:
 		break;
 	case ISCSI_OP_PDU_REJECT:
 		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/iscsi_dbg.h linux-2.6.12/drivers/scsi/iscsitarget/iscsi_dbg.h
--- linux-2.6.orig/drivers/scsi/iscsitarget/iscsi_dbg.h	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/iscsi_dbg.h	2005-08-19 14:22:39.000000000 +0200
@@ -6,10 +6,10 @@
 #define D_GENERIC	(1UL << 2)
 #define D_READ		(1UL << 3)
 #define D_WRITE 	(1UL << 4)
-#define D_IOD		(1UL << 5)
+#define D_IOV		(1UL << 5)
 #define D_THREAD	(1UL << 6)
 #define D_TASK_MGT	(1UL << 7)
-#define D_IOMODE	(1UL << 8)
+#define D_DUMP_PDU	(1UL << 8)
 
 #define D_DATA		(D_READ | D_WRITE)
 
@@ -40,9 +40,9 @@ do {								\
 static inline void iscsi_dump_iov(struct msghdr *msg)
 {
 	int i;
-	printk("%p, %d\n", msg->msg_iov, msg->msg_iovlen);
+	printk("%p, %ld\n", msg->msg_iov, (long)msg->msg_iovlen);
 	for (i = 0; i < min_t(size_t, msg->msg_iovlen, ISCSI_CONN_IOV_MAX); i++)
-		printk("%d: %p,%d\n", i, msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);
+		printk("%d: %p,%ld\n", i, msg->msg_iov[i].iov_base, (long)msg->msg_iov[i].iov_len);
 }
 #else
 #define iscsi_dump_iov(x) do {} while (0)
@@ -84,7 +84,7 @@ static inline void iscsi_dump_pdu(struct
 	int i;
 
 	buf = (void *)&pdu->bhs;
-	printk("BHS: (%p,%d)\n", buf, sizeof(pdu->bhs));
+	printk("BHS: (%p,%lu)\n", buf, sizeof(pdu->bhs));
 	for (i = 0; i < sizeof(pdu->bhs); i++)
 		iscsi_dump_char(*buf++);
 	iscsi_dump_char(-1);
diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/iscsi.h linux-2.6.12/drivers/scsi/iscsitarget/iscsi.h
--- linux-2.6.orig/drivers/scsi/iscsitarget/iscsi.h	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/iscsi.h	2005-08-22 10:32:31.000000000 +0200
@@ -13,7 +13,7 @@
 #include <linux/crypto.h>
 #include <net/sock.h>
 
-#include "iscsi_hdr.h"
+#include <scsi/iscsi_proto.h>
 #include "iet_u.h"
 
 struct iscsi_sess_param {
@@ -254,6 +254,11 @@ struct iscsi_cmnd {
 	struct iscsi_cmnd *req;
 };
 
+struct iscsi_sense_data {
+	u16 length;
+	u8  data[0];
+} __attribute__ ((packed));
+
 #define ISCSI_OP_SCSI_REJECT	ISCSI_OP_VENDOR1_CMD
 #define ISCSI_OP_PDU_REJECT	ISCSI_OP_VENDOR2_CMD
 #define ISCSI_OP_DATA_REJECT	ISCSI_OP_VENDOR3_CMD
@@ -347,34 +352,21 @@ extern void event_exit(void);
 
 static inline void iscsi_cmnd_get_length(struct iscsi_pdu *pdu)
 {
-#if defined(__BIG_ENDIAN)
-	pdu->ahssize = pdu->bhs.length.ahslength * 4;
-	pdu->datasize = pdu->bhs.length.datalength;
-#elif defined(__LITTLE_ENDIAN)
-	pdu->ahssize = (pdu->bhs.length & 0xff) * 4;
-	pdu->datasize = be32_to_cpu(pdu->bhs.length & ~0xff);
-#else
-#error
-#endif
+	pdu->datasize = ntoh24(pdu->bhs.dlength);
+	pdu->ahssize = pdu->bhs.hlength * 4;
 }
 
 static inline void iscsi_cmnd_set_length(struct iscsi_pdu *pdu)
 {
-#if defined(__BIG_ENDIAN)
-	pdu->bhs.length.ahslength = pdu->ahssize / 4;
-	pdu->bhs.length.datalength = pdu->datasize;
-#elif defined(__LITTLE_ENDIAN)
-	pdu->bhs.length = cpu_to_be32(pdu->datasize) | (pdu->ahssize / 4);
-#else
-#error
-#endif
+	hton24(pdu->bhs.dlength, pdu->datasize);
+	pdu->bhs.hlength = pdu->ahssize / 4;
 }
 
-#define cmnd_hdr(cmnd) ((struct iscsi_scsi_cmd_hdr *) (&((cmnd)->pdu.bhs)))
+#define cmnd_hdr(cmnd) ((struct iscsi_cmd *) (&((cmnd)->pdu.bhs)))
 #define cmnd_ttt(cmnd) cpu_to_be32((cmnd)->pdu.bhs.ttt)
 #define cmnd_itt(cmnd) cpu_to_be32((cmnd)->pdu.bhs.itt)
 #define cmnd_opcode(cmnd) ((cmnd)->pdu.bhs.opcode & ISCSI_OPCODE_MASK)
-#define cmnd_scsicode(cmnd) cmnd_hdr(cmnd)->scb[0]
+#define cmnd_scsicode(cmnd) cmnd_hdr(cmnd)->cdb[0]
 
 #define	SECTOR_SIZE_BITS	9
 
diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/iscsi_hdr.h linux-2.6.12/drivers/scsi/iscsitarget/iscsi_hdr.h
--- linux-2.6.orig/drivers/scsi/iscsitarget/iscsi_hdr.h	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/iscsi_hdr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,507 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman@ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#ifndef __ISCSI_HDR_H__
-#define __ISCSI_HDR_H__
-
-#include <linux/types.h>
-#include <asm/byteorder.h>
-
-#define ISCSI_VERSION			0
-
-#define __packed __attribute__ ((packed))
-
-struct iscsi_hdr {
-	u8  opcode;			/* 0 */
-	u8  flags;
-	u8  spec1[2];
-#if defined(__BIG_ENDIAN_BITFIELD)
-	struct {			/* 4 */
-		unsigned ahslength : 8;
-		unsigned datalength : 24;
-	} length;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	u32 length;			/* 4 */
-#endif
-	u16 lun[4];			/* 8 */
-	u32 itt;			/* 16 */
-	u32 ttt;			/* 20 */
-	u32 sn;				/* 24 */
-	u32 exp_sn;			/* 28 */
-	u32 max_sn;			/* 32 */
-	u32 spec3[3];			/* 36 */
-} __packed;				/* 48 */
-
-/* Opcode encoding bits */
-#define ISCSI_OP_RETRY			0x80
-#define ISCSI_OP_IMMEDIATE		0x40
-#define ISCSI_OPCODE_MASK		0x3F
-
-/* Client to Server Message Opcode values */
-#define ISCSI_OP_NOOP_OUT		0x00
-#define ISCSI_OP_SCSI_CMD		0x01
-#define ISCSI_OP_SCSI_TASK_MGT_MSG	0x02
-#define ISCSI_OP_LOGIN_CMD		0x03
-#define ISCSI_OP_TEXT_CMD		0x04
-#define ISCSI_OP_SCSI_DATA_OUT		0x05
-#define ISCSI_OP_LOGOUT_CMD		0x06
-#define ISCSI_OP_SNACK_CMD		0x10
-
-#define ISCSI_OP_VENDOR1_CMD		0x1c
-#define ISCSI_OP_VENDOR2_CMD		0x1d
-#define ISCSI_OP_VENDOR3_CMD		0x1e
-#define ISCSI_OP_VENDOR4_CMD		0x1f
-
-/* Server to Client Message Opcode values */
-#define ISCSI_OP_NOOP_IN		0x20
-#define ISCSI_OP_SCSI_RSP		0x21
-#define ISCSI_OP_SCSI_TASK_MGT_RSP	0x22
-#define ISCSI_OP_LOGIN_RSP		0x23
-#define ISCSI_OP_TEXT_RSP		0x24
-#define ISCSI_OP_SCSI_DATA_IN		0x25
-#define ISCSI_OP_LOGOUT_RSP		0x26
-#define ISCSI_OP_R2T			0x31
-#define ISCSI_OP_ASYNC_MSG		0x32
-#define ISCSI_OP_REJECT			0x3f
-
-struct iscsi_ahs_hdr {
-	u16 ahslength;
-	u8 ahstype;
-} __packed;
-
-#define ISCSI_AHSTYPE_CDB		1
-#define ISCSI_AHSTYPE_RLENGTH		2
-
-union iscsi_sid {
-	struct {
-		u8 isid[6];		/* Initiator Session ID */
-		u16 tsih;		/* Target Session ID */
-	} id;
-	u64 id64;
-} __packed;
-
-struct iscsi_scsi_cmd_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 data_length;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u8  scb[16];
-} __packed;
-
-#define ISCSI_CMD_FINAL		0x80
-#define ISCSI_CMD_READ		0x40
-#define ISCSI_CMD_WRITE		0x20
-#define ISCSI_CMD_ATTR_MASK	0x07
-#define ISCSI_CMD_UNTAGGED	0x00
-#define ISCSI_CMD_SIMPLE	0x01
-#define ISCSI_CMD_ORDERED	0x02
-#define ISCSI_CMD_HEAD_OF_QUEUE	0x03
-#define ISCSI_CMD_ACA		0x04
-
-struct iscsi_cdb_ahdr {
-	u16 ahslength;
-	u8  ahstype;
-	u8  reserved;
-	u8  cdb[0];
-} __packed;
-
-struct iscsi_rlength_ahdr {
-	u16 ahslength;
-	u8  ahstype;
-	u8  reserved;
-	u32 read_length;
-} __packed;
-
-struct iscsi_scsi_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  cmd_status;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd1[2];
-	u32 itt;
-	u32 snack;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 exp_data_sn;
-	u32 bi_residual_count;
-	u32 residual_count;
-} __packed;
-
-#define ISCSI_FLG_RESIDUAL_UNDERFLOW		0x02
-#define ISCSI_FLG_RESIDUAL_OVERFLOW		0x04
-#define ISCSI_FLG_BIRESIDUAL_UNDERFLOW		0x08
-#define ISCSI_FLG_BIRESIDUAL_OVERFLOW		0x10
-
-#define ISCSI_RESPONSE_COMMAND_COMPLETED	0x00
-#define ISCSI_RESPONSE_TARGET_FAILURE		0x01
-
-struct iscsi_sense_data {
-	u16 length;
-	u8  data[0];
-} __packed;
-
-struct iscsi_task_mgt_hdr {
-	u8  opcode;
-	u8  function;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 rtt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 ref_cmd_sn;
-	u32 exp_data_sn;
-	u32 rsvd2[2];
-} __packed;
-
-#define ISCSI_FUNCTION_MASK			0x7f
-
-#define ISCSI_FUNCTION_ABORT_TASK		1
-#define ISCSI_FUNCTION_ABORT_TASK_SET		2
-#define ISCSI_FUNCTION_CLEAR_ACA		3
-#define ISCSI_FUNCTION_CLEAR_TASK_SET		4
-#define ISCSI_FUNCTION_LOGICAL_UNIT_RESET	5
-#define ISCSI_FUNCTION_TARGET_WARM_RESET	6
-#define ISCSI_FUNCTION_TARGET_COLD_RESET	7
-#define ISCSI_FUNCTION_TASK_REASSIGN		8
-
-struct iscsi_task_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd4[3];
-} __packed;
-
-#define ISCSI_RESPONSE_FUNCTION_COMPLETE	0
-#define ISCSI_RESPONSE_UNKNOWN_TASK		1
-#define ISCSI_RESPONSE_UNKNOWN_LUN		2
-#define ISCSI_RESPONSE_TASK_ALLEGIANT		3
-#define ISCSI_RESPONSE_FAILOVER_UNSUPPORTED	4
-#define ISCSI_RESPONSE_FUNCTION_UNSUPPORTED	5
-#define ISCSI_RESPONSE_NO_AUTHORIZATION		6
-#define ISCSI_RESPONSE_FUNCTION_REJECTED	255
-
-struct iscsi_data_out_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 rsvd2;
-	u32 exp_stat_sn;
-	u32 rsvd3;
-	u32 data_sn;
-	u32 buffer_offset;
-	u32 rsvd4;
-} __packed;
-
-struct iscsi_data_in_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  rsvd1;
-	u8  cmd_status;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 data_sn;
-	u32 buffer_offset;
-	u32 residual_count;
-} __packed;
-
-#define ISCSI_FLG_STATUS		0x01
-
-struct iscsi_r2t_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 r2t_sn;
-	u32 buffer_offset;
-	u32 data_length;
-} __packed;
-
-struct iscsi_async_msg_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 ffffffff;
-	u32 rsvd2;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u8  async_event;
-	u8  async_vcode;
-	u16 param1;
-	u16 param2;
-	u16 param3;
-	u32 rsvd3;
-} __packed;
-
-#define ISCSI_ASYNC_SCSI		0
-#define ISCSI_ASYNC_LOGOUT		1
-#define ISCSI_ASYNC_DROP_CONNECTION	2
-#define ISCSI_ASYNC_DROP_SESSION	3
-#define ISCSI_ASYNC_PARAM_REQUEST	4
-#define ISCSI_ASYNC_VENDOR		255
-
-struct iscsi_text_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd3[4];
-} __packed;
-
-struct iscsi_text_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd3[3];
-} __packed;
-
-struct iscsi_login_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  max_version;		/* Max. version supported */
-	u8  min_version;		/* Min. version supported */
-	u8  ahslength;
-	u8  datalength[3];
-	union iscsi_sid sid;
-	u32 itt;			/* Initiator Task Tag */
-	u16 cid;			/* Connection ID */
-	u16 rsvd1;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd2[4];
-} __packed;
-
-struct iscsi_login_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  max_version;		/* Max. version supported */
-	u8  active_version;		/* Active version */
-	u8  ahslength;
-	u8  datalength[3];
-	union iscsi_sid sid;
-	u32 itt;			/* Initiator Task Tag */
-	u32 rsvd1;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u8  status_class;		/* see Login RSP ststus classes below */
-	u8  status_detail;		/* see Login RSP Status details below */
-	u8  rsvd2[10];
-} __packed;
-
-#define ISCSI_FLG_FINAL			0x80
-#define ISCSI_FLG_TRANSIT		0x80
-#define ISCSI_FLG_CSG_SECURITY		0x00
-#define ISCSI_FLG_CSG_LOGIN		0x04
-#define ISCSI_FLG_CSG_FULL_FEATURE	0x0c
-#define ISCSI_FLG_CSG_MASK		0x0c
-#define ISCSI_FLG_NSG_SECURITY		0x00
-#define ISCSI_FLG_NSG_LOGIN		0x01
-#define ISCSI_FLG_NSG_FULL_FEATURE	0x03
-#define ISCSI_FLG_NSG_MASK		0x03
-
-/* Login Status response classes */
-#define ISCSI_STATUS_SUCCESS		0x00
-#define ISCSI_STATUS_REDIRECT		0x01
-#define ISCSI_STATUS_INITIATOR_ERR	0x02
-#define ISCSI_STATUS_TARGET_ERR		0x03
-
-/* Login Status response detail codes */
-/* Class-0 (Success) */
-#define ISCSI_STATUS_ACCEPT		0x00
-
-/* Class-1 (Redirection) */
-#define ISCSI_STATUS_TGT_MOVED_TEMP	0x01
-#define ISCSI_STATUS_TGT_MOVED_PERM	0x02
-
-/* Class-2 (Initiator Error) */
-#define ISCSI_STATUS_INIT_ERR		0x00
-#define ISCSI_STATUS_AUTH_FAILED	0x01
-#define ISCSI_STATUS_TGT_FORBIDDEN	0x02
-#define ISCSI_STATUS_TGT_NOT_FOUND	0x03
-#define ISCSI_STATUS_TGT_REMOVED	0x04
-#define ISCSI_STATUS_NO_VERSION		0x05
-#define ISCSI_STATUS_TOO_MANY_CONN	0x06
-#define ISCSI_STATUS_MISSING_FIELDS	0x07
-#define ISCSI_STATUS_CONN_ADD_FAILED	0x08
-#define ISCSI_STATUS_INV_SESSION_TYPE	0x09
-#define ISCSI_STATUS_SESSION_NOT_FOUND	0x0a
-#define ISCSI_STATUS_INV_REQ_TYPE	0x0b
-
-/* Class-3 (Target Error) */
-#define ISCSI_STATUS_TARGET_ERROR	0x00
-#define ISCSI_STATUS_SVC_UNAVAILABLE	0x01
-#define ISCSI_STATUS_NO_RESOURCES	0x02
-
-struct iscsi_logout_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u16 cid;
-	u16 rsvd3;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd4[4];
-} __packed;
-
-struct iscsi_logout_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd4;
-	u16 time2wait;
-	u16 time2retain;
-	u32 rsvd5;
-} __packed;
-
-struct iscsi_snack_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 rsvd3;
-	u32 exp_stat_sn;
-	u32 rsvd4[2];
-	u32 beg_run;
-	u32 run_length;
-} __packed;
-
-struct iscsi_reject_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  reason;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 ffffffff;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 data_sn;
-	u32 rsvd4[2];
-} __packed;
-
-#define ISCSI_REASON_NO_FULL_FEATURE_PHASE	0x01
-#define ISCSI_REASON_DATA_DIGEST_ERROR		0x02
-#define ISCSI_REASON_DATA_SNACK_REJECT		0x03
-#define ISCSI_REASON_PROTOCOL_ERROR		0x04
-#define ISCSI_REASON_UNSUPPORTED_COMMAND	0x05
-#define ISCSI_REASON_IMMEDIATE_COMMAND_REJECT	0x06
-#define ISCSI_REASON_TASK_IN_PROGRESS		0x07
-#define ISCSI_REASON_INVALID_SNACK		0x08
-#define ISCSI_REASON_NO_BOOKMARK		0x09
-#define ISCSI_REASON_BOOKMARK_REJECT		0x0a
-#define ISCSI_REASON_NEGOTIATION_RESET		0x0b
-#define ISCSI_REASON_WAITING_LOGOUT		0x0c
-
-
-struct iscsi_nop_out_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd2[4];
-} __packed;
-
-struct iscsi_nop_in_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd2[3];
-} __packed;
-
-#define ISCSI_RESERVED_TAG	(0xffffffffU)
-
-#endif	/* __ISCSI_HDR_H__ */
diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/nthread.c linux-2.6.12/drivers/scsi/iscsitarget/nthread.c
--- linux-2.6.orig/drivers/scsi/iscsitarget/nthread.c	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/nthread.c	2005-08-19 13:58:35.000000000 +0200
@@ -134,7 +134,7 @@ static int do_recv(struct iscsi_conn *co
 	}
 
 out:
-	dprintk(D_IOD, "%d\n", res);
+	dprintk(D_IOV, "%d\n", res);
 
 	return res;
 }
diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/target_disk.c linux-2.6.12/drivers/scsi/iscsitarget/target_disk.c
--- linux-2.6.orig/drivers/scsi/iscsitarget/target_disk.c	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/target_disk.c	2005-08-22 10:27:34.000000000 +0200
@@ -75,13 +75,13 @@ static int insert_geo_m_pg(u8 *ptr, u64 
 
 static int build_mode_sense_response(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 	struct tio *tio = cmnd->tio;
-	u8 *data, *scb = req->scb;
+	u8 *data, *scb = req->cdb;
 	int len = 4, err = 0;
 	u8 pcode;
 
-	pcode = req->scb[2] & 0x3f;
+	pcode = req->cdb[2] & 0x3f;
 
 	assert(!tio);
 	tio = cmnd->tio = tio_alloc(1);
@@ -141,13 +141,13 @@ static int build_mode_sense_response(str
 
 static int build_inquiry_response(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 	struct tio *tio = cmnd->tio;
 	u8 *data;
-	u8 *scb = req->scb;
+	u8 *scb = req->cdb;
 	int err = -1;
 
-	if (((req->scb[1] & 0x3) == 0x3) || (!(req->scb[1] & 0x3) && req->scb[2]))
+	if (((req->cdb[1] & 0x3) == 0x3) || (!(req->cdb[1] & 0x3) && req->cdb[2]))
 		return err;
 
 	assert(!tio);
@@ -223,13 +223,13 @@ static int build_inquiry_response(struct
 
 static int build_report_luns_response(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 	struct tio *tio = cmnd->tio;
 	u32 *data, size, len;
 	struct iet_volume *lun;
 	int rest, idx = 0;
 
-	size = be32_to_cpu(*(u32 *)&req->scb[6]);
+	size = be32_to_cpu(*(u32 *)&req->cdb[6]);
 	if (size < 16)
 		return -1;
 
@@ -356,11 +356,11 @@ static int build_generic_response(struct
 
 static int disk_execute_cmnd(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
 	req->opcode &= ISCSI_OPCODE_MASK;
 
-	switch (req->scb[0]) {
+	switch (req->cdb[0]) {
 	case INQUIRY:
 		send_data_rsp(cmnd, build_inquiry_response);
 		break;
diff -purN linux-2.6.orig/drivers/scsi/iscsitarget/wthread.c linux-2.6.12/drivers/scsi/iscsitarget/wthread.c
--- linux-2.6.orig/drivers/scsi/iscsitarget/wthread.c	2005-07-01 14:32:25.000000000 +0200
+++ linux-2.6.12/drivers/scsi/iscsitarget/wthread.c	2005-08-22 10:22:42.000000000 +0200
@@ -14,9 +14,9 @@ void wthread_queue(struct iscsi_cmnd *cm
 	struct worker_thread_info *info = &cmnd->conn->session->target->wthread_info;
 
 	if (!list_empty(&cmnd->list)) {
-		struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+		struct iscsi_cmd *req = cmnd_hdr(cmnd);
 		eprintk("%x %p %x %x %x %x %lx %x\n",
-			cmnd_itt(cmnd), req, req->opcode, req->scb[0], cmnd->pdu.datasize,
+			cmnd_itt(cmnd), req, req->opcode, req->cdb[0], cmnd->pdu.datasize,
 			be32_to_cpu(req->data_length), cmnd->flags, req->flags);
 
 		if (cmnd->lun)
