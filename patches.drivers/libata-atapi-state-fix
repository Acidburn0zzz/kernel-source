From: albertcc@tw.ibm.com
Subject: Prevent command completion before command is sent to device
Patch-mainline: 
References: 80454

Add 2 PIO state to prevent the interrupt handler from completing the command
before the ATAPI CDB is sent to the device.

Acked-by: Jens Axboe <axboe@suse.de>
Signed-off-by: 

--- linux-2.6.11.orig/include/linux/libata.h	2005-04-21 21:26:05.000000000 +0800
+++ linux-2.6.11/include/linux/libata.h	2005-04-25 15:43:04.000000000 +0800
@@ -167,6 +167,8 @@
 	PIO_ST_LAST,
 	PIO_ST_LAST_POLL,
 	PIO_ST_ERR,
+	PIO_ST_PKT,
+	PIO_ST_CDB_SENT,
 };
 
 /* forward declarations */
--- linux-2.6.11/drivers/scsi/libata-core.c.orig	2005-05-11 09:11:15.000000000 +0200
+++ linux-2.6.11/drivers/scsi/libata-core.c	2005-05-11 09:23:06.000000000 +0200
@@ -2658,6 +2658,7 @@ static void ata_qc_timeout(struct ata_qu
 	default:
 		ata_altstatus(ap);
 		drv_stat = ata_chk_status(ap);
+		ap->pio_task_state = PIO_ST_IDLE;
 
 		/* ack bmdma irq events */
 		ap->ops->irq_clear(ap);
@@ -2970,6 +2971,7 @@ int ata_qc_issue_prot(struct ata_queued_
 		ap->ops->tf_load(ap, &qc->tf);
 		ap->ops->exec_command(ap, &qc->tf);
 
+		ap->pio_task_state = PIO_ST_PKT;
 		queue_work(ata_wq, &ap->packet_task);
 		break;
 
@@ -2977,12 +2979,14 @@ int ata_qc_issue_prot(struct ata_queued_
 		ap->ops->tf_load(ap, &qc->tf);
 		ap->ops->exec_command(ap, &qc->tf);
 
+		ap->pio_task_state = PIO_ST_PKT;
 		queue_work(ata_wq, &ap->packet_task);
 		break;
 
 	case ATA_PROT_ATAPI_DMA:
 		ap->ops->tf_load(ap, &qc->tf);	 /* load tf registers */
 		ap->ops->bmdma_setup(qc);	    /* set up bmdma */
+		ap->pio_task_state = PIO_ST_PKT;
 		queue_work(ata_wq, &ap->packet_task);
 		break;
 
@@ -3180,6 +3184,13 @@ inline unsigned int ata_host_intr (struc
 {
 	u8 status, host_stat;
 
+	/* ATAPI: Ignore interrupt if CDB is not sent yet  */
+	if (is_atapi_taskfile(&qc->tf) &&
+	    ap->pio_task_state != PIO_ST_CDB_SENT) {
+		DPRINTK("ata%u: not my atapi interrupt\n", ap->id);
+		goto idle_irq;
+	}
+
 	switch (qc->tf.protocol) {
 
 	case ATA_PROT_DMA:
@@ -3212,6 +3223,8 @@ inline unsigned int ata_host_intr (struc
 		DPRINTK("ata%u: protocol %d (dev_stat 0x%X)\n",
 			ap->id, qc->tf.protocol, status);
 
+		ap->pio_task_state = PIO_ST_IDLE;
+
 		/* ack bmdma irq events */
 		ap->ops->irq_clear(ap);
 
@@ -3297,6 +3310,7 @@ static void atapi_packet_task(void *_dat
 	struct ata_port *ap = _data;
 	struct ata_queued_cmd *qc;
 	u8 status;
+	unsigned long flags;
 
 	qc = ata_qc_from_tag(ap, ap->active_tag);
 	assert(qc != NULL);
@@ -3312,10 +3326,13 @@ static void atapi_packet_task(void *_dat
 	if ((status & (ATA_BUSY | ATA_DRQ)) != ATA_DRQ)
 		goto err_out;
 
+	spin_lock_irqsave(&ap->host_set->lock, flags);
+
 	/* send SCSI cdb */
 	DPRINTK("send cdb\n");
 	assert(ap->cdb_len >= 12);
 	ata_data_xfer(ap, qc->cdb, ap->cdb_len, 1);
+	ap->pio_task_state = PIO_ST_CDB_SENT;
 
 	/* if we are DMA'ing, irq handler takes over from here */
 	if (qc->tf.protocol == ATA_PROT_ATAPI_DMA)
@@ -3332,6 +3349,8 @@ static void atapi_packet_task(void *_dat
 		queue_work(ata_wq, &ap->pio_task);
 	}
 
+	spin_unlock_irqrestore(&ap->host_set->lock, flags);
+
 	return;
 
 err_out:
