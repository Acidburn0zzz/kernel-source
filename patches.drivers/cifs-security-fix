From: Steve French
Subject: Security fixes for CIFS
References: 46501

This patch is a backport from cifs-1.22 that fixes two security
issues:

1) smb_send doesn't decrement the length when repeating a partial
sendmsg(). This can cause random data beyond the iovec to be transmitted.

2) First reconnect in cifs_demultiplex_thread doesn't use htons to 
set the target 445 port. This will cause the first reconnect on a lost
connection to go to a unpriviledged high port. When someone answers there
they can hijack the connection.

Index: linux-2.6.8/fs/cifs/transport.c
===================================================================
--- linux-2.6.8.orig/fs/cifs/transport.c
+++ linux-2.6.8/fs/cifs/transport.c
@@ -123,6 +123,7 @@ smb_send(struct socket *ssocket, struct 
 	int i = 0;
 	struct msghdr smb_msg;
 	struct kvec iov;
+	int len;
 
 	if(ssocket == NULL)
 		return -ENOTSOCK; /* BB eventually add reconnect code here */
@@ -144,8 +145,9 @@ smb_send(struct socket *ssocket, struct 
 	cFYI(1, ("Sending smb of length %d ", smb_buf_length));
 	dump_smb(smb_buffer, smb_buf_length + 4);
 
+	len = smb_buf_length + 4;
 	while(iov.iov_len > 0) {
-		rc = kernel_sendmsg(ssocket, &smb_msg, &iov, 1, smb_buf_length + 4);
+		rc = kernel_sendmsg(ssocket, &smb_msg, &iov, 1, len);
 		if ((rc == -ENOSPC) || (rc == -EAGAIN)) {
 			i++;
 			if(i > 60) {
@@ -163,6 +165,7 @@ smb_send(struct socket *ssocket, struct 
 			break;
 		iov.iov_base += rc;
 		iov.iov_len -= rc;
+		len -= rc;
 	}
 
 	if (rc < 0) {
Index: linux-2.6.8/fs/cifs/connect.c
===================================================================
--- linux-2.6.8.orig/fs/cifs/connect.c
+++ linux-2.6.8/fs/cifs/connect.c
@@ -313,7 +313,7 @@ cifs_demultiplex_thread(struct TCP_Serve
 					connected to port 139 (the NACK is 
 					since we do not begin with RFC1001
 					session initialize frame) */
-					server->addr.sockAddr.sin_port = CIFS_PORT;
+					server->addr.sockAddr.sin_port = htons(CIFS_PORT);
 					cifs_reconnect(server);
 					csocket = server->ssocket;
 					wake_up(&server->response_q);
