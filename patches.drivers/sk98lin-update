Index: linux-2.6.8/Documentation/networking/sk98lin.txt
===================================================================
--- linux-2.6.8.orig/Documentation/networking/sk98lin.txt
+++ linux-2.6.8/Documentation/networking/sk98lin.txt
@@ -1,12 +1,12 @@
 (C)Copyright 1999-2004 Marvell(R).
 All rights reserved
 ===========================================================================
 
-sk98lin.txt created 13-Feb-2004
+sk98lin.txt created 08-Jul-2004
 
-Readme File for sk98lin v6.23
-Marvell Yukon/SysKonnect SK-98xx Gigabit Ethernet Adapter family driver for LINUX
+Readme File for sk98lin v7.04
+Marvell Yukon/SysKonnect SK-98xx Gigabit Ethernet Adapter driver for LINUX
 
 This file contains
  1  Overview
  2  Required Files
@@ -109,15 +109,15 @@ To load the module manually, proceed as 
    which indicates that your adapter has been found and initialized.
    
    NOTE 1: If you have more than one Marvell Yukon or SysKonnect SK-98xx 
            adapter installed, the adapters will be listed as 'eth0', 
-                   'eth1', 'eth2', etc.
-                   For each adapter, repeat steps 3 and 4 below.
+           'eth1', 'eth2', etc.
+           For each adapter, repeat steps 3 and 4 below.
 
    NOTE 2: If you have other Ethernet adapters installed, your Marvell
            Yukon or SysKonnect SK-98xx adapter will be mapped to the 
-                   next available number, e.g. 'eth1'. The mapping is executed 
-                   automatically.
+           next available number, e.g. 'eth1'. The mapping is executed 
+           automatically.
            The module installation message (displayed either in a system
            log file or on the console) prints a line for each adapter 
            found containing the corresponding 'ethX'.
 
@@ -173,9 +173,9 @@ loaded with the command 'modprobe'.
 In some distributions, the configuration tools are able to pass parameters
 to the driver module.
 
 If you use the kernel module loader, you can set driver parameters
-in the file /etc/modprobe.conf (or /etc/modules.conf in 2.4 or earlier).
+in the file /etc/modules.conf (or old name: /etc/conf.modules).
 To set the driver parameters in this file, proceed as follows:
 
 1. Insert a line of the form :
    options sk98lin ...
Index: linux-2.6.8/drivers/net/Kconfig
===================================================================
--- linux-2.6.8.orig/drivers/net/Kconfig
+++ linux-2.6.8/drivers/net/Kconfig
@@ -2060,8 +2060,9 @@ config R8169_NAPI
 	  information.
 
 	  If in doubt, say N.
 
+
 config SK98LIN
 	tristate "Marvell Yukon Chipset / SysKonnect SK-98xx Support"
 	depends on PCI
 	---help---
@@ -2081,31 +2082,59 @@ config SK98LIN
 	    - Belkin Gigabit Desktop Card 10/100/1000Base-T Adapter, Copper RJ-45
 	    - DGE-530T Gigabit Ethernet Adapter
 	    - EG1032 v2 Instant Gigabit Network Adapter
 	    - EG1064 v2 Instant Gigabit Network Adapter
-	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Abit)
-	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Albatron)
-	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Asus)
-	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (ECS)
-	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Epox)
-	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Foxconn)
-	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Gigabyte)
-	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Iwill)
-	    - Marvell 88E8050 Gigabit LOM Ethernet Adapter (Intel)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (Abit)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (Albatron)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (Asus)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (Chaintech)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (ECS)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (Epox)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (Foxconn)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (Gigabyte)
+	    - Marvell 88E8001 Gigabit Ethernet Controller (Iwill)
+	    - Marvell 88E8035 Fast Ethernet Controller (LGE)
+	    - Marvell 88E8035 Fast Ethernet Controller (Toshiba)
+	    - Marvell 88E8036 Fast Ethernet Controller (LGE)
+	    - Marvell 88E8036 Fast Ethernet Controller (Toshiba)
+	    - Marvell 88E8050 Gigabit Ethernet Controller (Intel)
+	    - Marvell 88E8052 Gigabit Ethernet Controller (ASRock)
+	    - Marvell 88E8052 Gigabit Ethernet Controller (Asus)
+	    - Marvell 88E8052 Gigabit Ethernet Controller (Gigabyte)
+	    - Marvell 88E8052 Gigabit Ethernet Controller (MSI)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (ASRock)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Albatron)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Aopen)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Asus)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Chaintech)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Clevo)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (DFI)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Epox)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Gigabyte)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (MSI)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (SOYO)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Toshiba)
+	    - Marvell 88E8053 Gigabit Ethernet Controller (Trigem)
+	    - Marvell RDK-8001 
 	    - Marvell RDK-8001 Adapter
 	    - Marvell RDK-8002 Adapter
+	    - Marvell RDK-8003 
 	    - Marvell RDK-8003 Adapter
 	    - Marvell RDK-8004 Adapter
 	    - Marvell RDK-8006 Adapter
 	    - Marvell RDK-8007 Adapter
 	    - Marvell RDK-8008 Adapter
 	    - Marvell RDK-8009 Adapter
-	    - Marvell RDK-8010 Adapter
+	    - Marvell RDK-8010 
 	    - Marvell RDK-8011 Adapter
 	    - Marvell RDK-8012 Adapter
-	    - Marvell RDK-8052 Adapter
-	    - Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Adapter (32 bit)
-	    - Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Adapter (64 bit)
+	    - Marvell RDK-8035 
+	    - Marvell RDK-8036 
+	    - Marvell RDK-8052 
+	    - Marvell RDK-8053 
+	    - Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Controller (32 bit)
+	    - Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Controller (64 bit)
 	    - N-Way PCI-Bus Giga-Card 1000/100/10Mbps(L)
 	    - SK-9521 10/100/1000Base-T Adapter
 	    - SK-9521 V2.0 10/100/1000Base-T Adapter
 	    - SK-9821 Gigabit Ethernet Server Adapter (SK-NET GE-T)
@@ -2136,10 +2165,18 @@ config SK98LIN
 	      linux@syskonnect.de
 	  
 	  If you want to compile this driver as a module ( = code which can be
 	  inserted in and removed from the running kernel whenever you want),
-	  say M here and read Documentation/kbuild/modules.txt. The module will
-	  be called sk98lin. This is recommended.
+	  say M here and read Documentation/modules.txt. This is recommended.
+	  The module will be called sk98lin. This is recommended.
+
+config SK98LIN_NAPI
+	bool "Use Rx polling (NAPI)"
+	depends on SK98LIN
+	help
+	  NAPI is a new driver API designed to reduce CPU and interrupt load
+	  when the driver is receiving lots of packets from the card.
+
 
 config TIGON3
 	tristate "Broadcom Tigon3 support"
 	depends on PCI
Index: linux-2.6.8/drivers/net/sk98lin/h/lm80.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/lm80.h
+++ linux-2.6.8/drivers/net/sk98lin/h/lm80.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	lm80.h	
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.6 $
- * Date:	$Date: 2003/05/13 17:26:52 $
+ * Version:	$Revision: 2.1 $
+ * Date:	$Date: 2003/10/27 14:16:08 $
  * Purpose:	Contains all defines for the LM80 Chip
  *		(National Semiconductor).
  *
  ******************************************************************************/
Index: linux-2.6.8/drivers/net/sk98lin/h/skaddr.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skaddr.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skaddr.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skaddr.h
  * Project:	Gigabit Ethernet Adapters, ADDR-Modul
- * Version:	$Revision: 1.29 $
- * Date:	$Date: 2003/05/13 16:57:24 $
+ * Version:	$Revision: 2.1 $
+ * Date:	$Date: 2003/10/27 14:16:07 $
  * Purpose:	Header file for Address Management (MC, UC, Prom).
  *
  ******************************************************************************/
 
Index: linux-2.6.8/drivers/net/sk98lin/h/skcsum.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skcsum.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skcsum.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skcsum.h
  * Project:	GEnesis - SysKonnect SK-NET Gigabit Ethernet (SK-98xx)
- * Version:	$Revision: 1.10 $
- * Date:	$Date: 2003/08/20 13:59:57 $
+ * Version:	$Revision: 2.2 $
+ * Date:	$Date: 2003/12/29 15:37:26 $
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
 
@@ -156,11 +156,9 @@ typedef struct s_CsProtocolStatistics {
  */
 typedef struct s_Csum {
 	/* Enabled receive SK_PROTO_XXX bit flags. */
 	unsigned ReceiveFlags[SK_MAX_NETS];
-#ifdef TX_CSUM
 	unsigned TransmitFlags[SK_MAX_NETS];
-#endif /* TX_CSUM */
 
 	/* The protocol statistics structure; one per supported protocol. */
 	SKCS_PROTO_STATS ProtoStats[SK_MAX_NETS][SKCS_NUM_PROTOCOLS];
 } SK_CSUM;
Index: linux-2.6.8/drivers/net/sk98lin/h/skdebug.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skdebug.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skdebug.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skdebug.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.14 $
- * Date:	$Date: 2003/05/13 17:26:00 $
+ * Version:	$Revision: 2.2 $
+ * Date:	$Date: 2004/02/26 16:06:06 $
  * Purpose:	SK specific DEBUG support
  *
  ******************************************************************************/
 
@@ -57,8 +57,11 @@
 #define SK_DBGMOD_CSUM	0x00000040L	/* CSUM module */
 #define SK_DBGMOD_ADDR	0x00000080L	/* ADDR module */
 #define SK_DBGMOD_PECP	0x00000100L	/* PECP module */
 #define SK_DBGMOD_POWM	0x00000200L	/* Power Management module */
+#ifdef SK_ASF
+#define SK_DBGMOD_ASF	0x00000400L	/* ASF module */
+#endif
 
 /* Debug events */
 
 #define SK_DBGCAT_INIT	0x00000001L	/* module/driver initialization */
Index: linux-2.6.8/drivers/net/sk98lin/h/skdrv1st.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skdrv1st.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skdrv1st.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skdrv1st.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:	$Date: 2003/11/12 14:28:14 $
+ * Version:	$Revision: 1.3 $
+ * Date:	$Date: 2004/06/16 08:10:24 $
  * Purpose:	First header file for driver and all other modules
  *
  ******************************************************************************/
 
@@ -57,8 +57,14 @@ typedef struct s_AC	SK_AC;
 #define SK_PNMI_READ_U64(p,v)		memcpy((char*)&(v),(char*)(p),8)
 
 #define SK_ADDR_EQUAL(a1,a2)		(!memcmp(a1,a2,6))
 
+#if !defined(__OPTIMIZE__)  ||  !defined(__KERNEL__)
+#warning  You must compile this file with the correct options!
+#warning  See the last lines of the source file.
+#error You must compile this driver with "-O".
+#endif
+
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/errno.h>
@@ -89,8 +95,12 @@ typedef struct s_AC	SK_AC;
 #include	"h/skdebug.h"
 #include	"h/lm80.h"
 #include	"h/xmac_ii.h"
 
+#ifndef SK_BMU_RX_WM_PEX
+#define SK_BMU_RX_WM_PEX 0x80
+#endif
+
 #ifdef __LITTLE_ENDIAN
 #define SK_LITTLE_ENDIAN
 #else
 #define SK_BIG_ENDIAN
Index: linux-2.6.8/drivers/net/sk98lin/h/skdrv2nd.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skdrv2nd.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skdrv2nd.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skdrv2nd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.10 $
- * Date:	$Date: 2003/12/11 16:04:45 $
+ * Version:	$Revision: 1.21 $
+ * Date:	$Date: 2004/06/19 13:57:24 $
  * Purpose:	Second header file for driver and all other modules
  *
  ******************************************************************************/
 
@@ -41,20 +41,30 @@
 
 #include "h/skqueue.h"
 #include "h/skgehwt.h"
 #include "h/sktimer.h"
-#include "h/ski2c.h"
+#include "h/sktwsi.h"
 #include "h/skgepnmi.h"
 #include "h/skvpd.h"
 #include "h/skgehw.h"
+#include "h/sky2le.h"
 #include "h/skgeinit.h"
 #include "h/skaddr.h"
 #include "h/skgesirq.h"
 #include "h/skcsum.h"
 #include "h/skrlmt.h"
 #include "h/skgedrv.h"
 
+/* Isr return values */
+#define SkIsrRetVar     irqreturn_t
+#define SkIsrRetNone    IRQ_NONE
+#define SkIsrRetHandled IRQ_HANDLED
+
+#define DEV_KFREE_SKB(skb) dev_kfree_skb(skb)
+#define DEV_KFREE_SKB_IRQ(skb) dev_kfree_skb_irq(skb)
+#define DEV_KFREE_SKB_ANY(skb) dev_kfree_skb_any(skb)
 
+/* global function prototypes ******************************************/
 extern SK_MBUF		*SkDrvAllocRlmtMbuf(SK_AC*, SK_IOC, unsigned);
 extern void		SkDrvFreeRlmtMbuf(SK_AC*, SK_IOC, SK_MBUF*);
 extern SK_U64		SkOsGetTime(SK_AC*);
 extern int		SkPciReadCfgDWord(SK_AC*, int, SK_U32*);
@@ -63,13 +73,10 @@ extern int		SkPciReadCfgByte(SK_AC*, int
 extern int		SkPciWriteCfgDWord(SK_AC*, int, SK_U32);
 extern int		SkPciWriteCfgWord(SK_AC*, int, SK_U16);
 extern int		SkPciWriteCfgByte(SK_AC*, int, SK_U8);
 extern int		SkDrvEvent(SK_AC*, SK_IOC IoC, SK_U32, SK_EVPARA);
-
-#ifdef SK_DIAG_SUPPORT
 extern int		SkDrvEnterDiagMode(SK_AC *pAc);
 extern int		SkDrvLeaveDiagMode(SK_AC *pAc);
-#endif
 
 struct s_DrvRlmtMbuf {
 	SK_MBUF		*pNext;		/* Pointer to next RLMT Mbuf. */
 	SK_U8		*pData;		/* Data buffer (virtually contig.). */
@@ -77,9 +84,9 @@ struct s_DrvRlmtMbuf {
 	unsigned	Length;		/* Length of packet (<= Size). */
 	SK_U32		PortIdx;	/* Receiving/transmitting port. */
 #ifdef SK_RLMT_MBUF_PRIVATE
 	SK_RLMT_MBUF	Rlmt;		/* Private part for RLMT. */
-#endif  /* SK_RLMT_MBUF_PRIVATE */
+#endif
 	struct sk_buff	*pOs;		/* Pointer to message block */
 };
 
 
@@ -115,24 +122,29 @@ struct s_DrvRlmtMbuf {
 
 typedef struct s_IOCTL	SK_GE_IOCTL;
 
 struct s_IOCTL {
-	char __user *	pData;
+	char*		pData;
 	unsigned int	Len;
 };
 
 
 /*
  * define sizes of descriptor rings in bytes
  */
+#define		TX_RING_SIZE		(24*1024)
+#define		RX_RING_SIZE		(24*1024)
 
-#define		TX_RING_SIZE	(8*1024)
-#define		RX_RING_SIZE	(24*1024)
+/*
+ * define sizes of buffers (Yukon2)
+ */
+#define		RX_MAX_NBR_BUFFERS	128 /* max number receive buffers */
+#define		TX_MAX_NBR_BUFFERS	128 /* max number receive buffers */
 
 /*
  * Buffer size for ethernet packets
  */
-#define	ETH_BUF_SIZE	1540
+#define	ETH_BUF_SIZE	1560	/* multiples of 8 bytes */
 #define	ETH_MAX_MTU	1514
 #define ETH_MIN_MTU	60
 #define ETH_MULTICAST_BIT	0x01
 #define SK_JUMBO_MTU	9000
@@ -167,8 +179,10 @@ struct s_IOCTL {
 #define	SK_DRV_MODERATION_TIMER		1
 #define SK_DRV_MODERATION_TIMER_LENGTH  1000000  /* 1 second */
 #define SK_DRV_RX_CLEANUP_TIMER		2
 #define SK_DRV_RX_CLEANUP_TIMER_LENGTH	1000000	 /* 100 millisecs */
+#define SK_DRV_TX_POLL_TIMER		3
+#define SK_DRV_TX_POLL_TIMER_LENGTH	10
 
 /*
 ** Definitions regarding transmitting frames 
 ** any calculating any checksum.
@@ -230,49 +244,326 @@ struct s_TxD {
 	TXD		*pNextTxd;	/* Pointer to next Txd */
 	struct sk_buff	*pMBuf;		/* Pointer to Linux' socket buffer */
 };
 
-/* Used interrupt bits in the interrupts source register *********************/
+/* 
+** The following definitions need to be replaced with the ones from
+** the header file sky2le.h!
+*/
+
+#define LE_SIZE sizeof(SK_HWLE)
+
+#define MIN_LEN_OF_LE_TAB		128
+#define MAX_LEN_OF_LE_TAB		4096
+#define MAX_UNUSED_RX_LE_WORKING	8
+#ifdef MAX_FRAG_OVERHEAD
+#undef MAX_FRAG_OVERHEAD
+#define MAX_FRAG_OVERHEAD		4
+#endif
+
+// as we have a maximum of 16 physical fragments,
+// maximum 1 ADDR64 per physical fragment
+// maximum 4 LEs for VLAN, Csum, LargeSend, Packet
+#define MIN_LE_FREE_REQUIRED		((16*2) + 4)
+
+/*
+** The following defines will most likely stay in this
+** file like they are...
+*/
+#define IS_GMAC(pAc)			(!pAc->GIni.GIGenesis)
+#define NUM_FREE_FRAGS(pAC, Port) \
+	(pAC->TxPort[Port][TX_PRIO_LOW].TxFreeFragQueue.NumFragsInQueue)
+
+#if USE_SYNC_TX_QUEUE
+#define TXS_MAX_LE			256
+#else /* !USE_SYNC_TX_QUEUE */
+#define TXS_MAX_LE			0
+#endif
+
+#define ETHER_MAC_HDR_LEN		(6+6+2) // MAC SRC ADDR, MAC DST ADDR, TYPE
+#define IP_HDR_LEN			20
+#define TCP_CSUM_OFFS			0x10
+#define UDP_CSUM_OFFS			0x06
+#define TXA_MAX_LE			256
+#define RX_MAX_LE			256
+#define ST_MAX_LE			(SK_MAX_MACS) * ((3*RX_MAX_LE) + \
+						(TXA_MAX_LE) + (TXS_MAX_LE))
+
+/******************************************************************************
+ *
+ * Structures specific for Yukon-II
+ *
+ ******************************************************************************/
+
+typedef	struct s_frag SK_FRAG;
+struct s_frag {
+ 	SK_FRAG		*pNext;
+ 	char		*pVirt;
+  	SK_U64		 pPhys;
+ 	unsigned int	 FragLen;
+};
+
+typedef	struct s_packet SK_PACKET;
+struct s_packet {
+	/* Common infos */
+	SK_PACKET 	*pNext;       	/* pointer for packet queues          */
+	unsigned int	 PacketLen;	/* length of packet                   */
+	unsigned int	 NumFrags;	/* nbr of fragments (for Rx always 1) */
+	SK_FRAG		*pFrag;		/* fragment list                      */
+	unsigned int	 NextLE;	/* next LE to use for the next packet */
+
+	/* Private infos */
+	struct sk_buff	*pMBuf;		/* Pointer to Linux' socket buffer    */
+};
+
+typedef	struct s_queue SK_PKT_QUEUE;
+struct s_queue {
+ 	SK_PACKET	*pHead;
+ 	SK_PACKET	*pTail;
+	spinlock_t	 QueueLock;	/* serialize packet accesses          */
+};
+
+typedef struct s_frag_queue SK_FRAG_QUEUE;
+struct s_frag_queue {
+	SK_FRAG		*pHead;
+        SK_FRAG		*pTail;
+	spinlock_t	 QueueLock;	/* serialize fragment accesses        */
+	unsigned int	 NumFragsInQueue;
+};
 
-#define DRIVER_IRQS	((IS_IRQ_SW)   | \
-			(IS_R1_F)      |(IS_R2_F)  | \
-			(IS_XS1_F)     |(IS_XA1_F) | \
-			(IS_XS2_F)     |(IS_XA2_F))
-
-#define SPECIAL_IRQS	((IS_HW_ERR)   |(IS_I2C_READY)  | \
-			(IS_EXT_REG)   |(IS_TIMINT)     | \
-			(IS_PA_TO_RX1) |(IS_PA_TO_RX2)  | \
-			(IS_PA_TO_TX1) |(IS_PA_TO_TX2)  | \
-			(IS_MAC1)      |(IS_LNK_SYNC_M1)| \
-			(IS_MAC2)      |(IS_LNK_SYNC_M2)| \
-			(IS_R1_C)      |(IS_R2_C)       | \
-			(IS_XS1_C)     |(IS_XA1_C)      | \
-			(IS_XS2_C)     |(IS_XA2_C))
-
-#define IRQ_MASK	((IS_IRQ_SW)   | \
-			(IS_R1_B)      |(IS_R1_F)     |(IS_R2_B) |(IS_R2_F) | \
-			(IS_XS1_B)     |(IS_XS1_F)    |(IS_XA1_B)|(IS_XA1_F)| \
-			(IS_XS2_B)     |(IS_XS2_F)    |(IS_XA2_B)|(IS_XA2_F)| \
-			(IS_HW_ERR)    |(IS_I2C_READY)| \
-			(IS_EXT_REG)   |(IS_TIMINT)   | \
-			(IS_PA_TO_RX1) |(IS_PA_TO_RX2)| \
-			(IS_PA_TO_TX1) |(IS_PA_TO_TX2)| \
-			(IS_MAC1)      |(IS_MAC2)     | \
-			(IS_R1_C)      |(IS_R2_C)     | \
-			(IS_XS1_C)     |(IS_XA1_C)    | \
-			(IS_XS2_C)     |(IS_XA2_C))
+/*******************************************************************************
+ *
+ * Macros specific for Yukon-II queues
+ *
+ ******************************************************************************/
 
-#define IRQ_HWE_MASK	(IS_ERR_MSK) /* enable all HW irqs */
+#define PLAIN_POP_FIRST_PKT_FROM_QUEUE(pQueue, pPacket)	{	\
+        if ((pQueue)->pHead != NULL) {				\
+		(pPacket)       = (pQueue)->pHead;		\
+		(pQueue)->pHead = (pPacket)->pNext;		\
+		if ((pQueue)->pHead == NULL) {			\
+			(pQueue)->pTail = NULL;			\
+		}						\
+		(pPacket)->pNext = NULL;			\
+	} else {						\
+		(pPacket) = NULL;				\
+	}							\
+}
+
+#define PLAIN_PUSH_PKT_AS_FIRST_IN_QUEUE(pQueue, pPacket) {	\
+	if ((pQueue)->pHead != NULL) {				\
+		(pPacket)->pNext = (pQueue)->pHead;		\
+	} else {						\
+		(pPacket)->pNext = NULL;			\
+		(pQueue)->pTail  = (pPacket);			\
+	}							\
+      	(pQueue)->pHead  = (pPacket);				\
+}
+
+#define PLAIN_PUSH_PKT_AS_LAST_IN_QUEUE(pQueue, pPacket) {	\
+	(pPacket)->pNext = NULL;				\
+	if ((pQueue)->pTail != NULL) {				\
+		(pQueue)->pTail->pNext = (pPacket);		\
+	} else {						\
+		(pQueue)->pHead        = (pPacket);		\
+	}							\
+	(pQueue)->pTail = (pPacket);				\
+}
+
+#define PLAIN_PUSH_MULTIPLE_PKT_AS_LAST_IN_QUEUE(pQueue,pPktGrpStart,pPktGrpEnd) { \
+	if ((pPktGrpStart) != NULL) {					\
+		if ((pQueue)->pTail != NULL) {				\
+			(pQueue)->pTail->pNext = (pPktGrpStart);	\
+		} else {						\
+			(pQueue)->pHead = (pPktGrpStart);		\
+		}							\
+		(pQueue)->pTail = (pPktGrpEnd);				\
+	}								\
+}
+
+#define PLAIN_POP_FIRST_FRAG_FROM_QUEUE(Port, pFrag) {			\
+	(pFrag) = pAC->TxPort[(Port)][0].TxFreeFragQueue.pHead;		\
+	pAC->TxPort[(Port)][0].TxFreeFragQueue.pHead = (pFrag)->pNext;	\
+	if ((pFrag) != NULL) {						\
+		(pFrag)->pNext = NULL;					\
+	}								\
+	if (pAC->TxPort[(Port)][0].TxFreeFragQueue.pHead == NULL) {	\
+		pAC->TxPort[(Port)][0].TxFreeFragQueue.pTail = NULL;	\
+	}								\
+	pAC->TxPort[(Port)][0].TxFreeFragQueue.NumFragsInQueue--;	\
+}
+
+#define PLAIN_PUSH_FRAG_AS_LAST_IN_QUEUE(Port, pFrag, pNextFrag) {	\
+	(pNextFrag)      = (pFrag)->pNext;				\
+	(pFrag)->pNext   = NULL;					\
+	(pFrag)->pVirt   = NULL;					\
+	(pFrag)->pPhys   = (SK_U64) 0;					\
+	(pFrag)->FragLen = 0;						\
+	if (pAC->TxPort[(Port)][0].TxFreeFragQueue.pTail != NULL) {	\
+		pAC->TxPort[(Port)][0].TxFreeFragQueue.pTail->pNext = (pFrag);	\
+	} else {							\
+		pAC->TxPort[(Port)][0].TxFreeFragQueue.pHead = (pFrag);	\
+	}								\
+	pAC->TxPort[(Port)][0].TxFreeFragQueue.pTail = (pFrag);		\
+	pAC->TxPort[(Port)][0].TxFreeFragQueue.NumFragsInQueue++;	\
+}
+
+/* Required: 'Flags' */ 
+#define POP_FIRST_PKT_FROM_QUEUE(pQueue, pPacket)	{	\
+	spin_lock_irqsave(&((pQueue)->QueueLock), Flags);	\
+	if ((pQueue)->pHead != NULL) {				\
+		(pPacket)       = (pQueue)->pHead;		\
+		(pQueue)->pHead = (pPacket)->pNext;		\
+		if ((pQueue)->pHead == NULL) {			\
+			(pQueue)->pTail = NULL;			\
+		}						\
+		(pPacket)->pNext = NULL;			\
+	} else {						\
+		(pPacket) = NULL;				\
+	}							\
+	spin_unlock_irqrestore(&((pQueue)->QueueLock), Flags);	\
+}
+
+/* Required: 'Flags' */
+#define PUSH_PKT_AS_FIRST_IN_QUEUE(pQueue, pPacket)	{	\
+	spin_lock_irqsave(&(pQueue)->QueueLock, Flags);		\
+	if ((pQueue)->pHead != NULL) {				\
+		(pPacket)->pNext = (pQueue)->pHead;		\
+	} else {						\
+		(pPacket)->pNext = NULL;			\
+		(pQueue)->pTail  = (pPacket);			\
+	}							\
+	(pQueue)->pHead = (pPacket);				\
+	spin_unlock_irqrestore(&(pQueue)->QueueLock, Flags);	\
+}
+
+/* Required: 'Flags' */
+#define PUSH_PKT_AS_LAST_IN_QUEUE(pQueue, pPacket)	{	\
+	(pPacket)->pNext = NULL;				\
+	spin_lock_irqsave(&(pQueue)->QueueLock, Flags);		\
+	if ((pQueue)->pTail != NULL) {				\
+		(pQueue)->pTail->pNext = (pPacket);		\
+	} else {						\
+		(pQueue)->pHead = (pPacket);			\
+	}							\
+	(pQueue)->pTail = (pPacket);				\
+	spin_unlock_irqrestore(&(pQueue)->QueueLock, Flags);	\
+}
+
+/* Required: 'Flags' */
+#define PUSH_MULTIPLE_PKT_AS_LAST_IN_QUEUE(pQueue,pPktGrpStart,pPktGrpEnd) {	\
+	if ((pPktGrpStart) != NULL) {					\
+		spin_lock_irqsave(&(pQueue)->QueueLock, Flags);		\
+		if ((pQueue)->pTail != NULL) {				\
+			(pQueue)->pTail->pNext = (pPktGrpStart);	\
+		} else {						\
+			(pQueue)->pHead = (pPktGrpStart);		\
+		}							\
+		(pQueue)->pTail = (pPktGrpEnd);				\
+		spin_unlock_irqrestore(&(pQueue)->QueueLock, Flags);	\
+	}								\
+}
+
+/* Required: 'Flags' */ 
+#define POP_FIRST_FRAG_FROM_QUEUE(Port, pFrag) {						\
+	spin_lock_irqsave(&pAC->TxPort[(Port)][0].TxFreeFragQueue.QueueLock, Flags);		\
+	(pFrag) = pAC->TxPort[(Port)][0].TxFreeFragQueue.pHead;					\
+	pAC->TxPort[(Port)][0].TxFreeFragQueue.pHead = (pFrag)->pNext;				\
+	if ((pFrag) != NULL) {									\
+		(pFrag)->pNext = NULL;								\
+        }											\
+	if (pAC->TxPort[(Port)][0].TxFreeFragQueue.pHead == NULL) {				\
+		pAC->TxPort[(Port)][0].TxFreeFragQueue.pTail = NULL;				\
+	}											\
+	pAC->TxPort[(Port)][0].TxFreeFragQueue.NumFragsInQueue--;				\
+	spin_unlock_irqrestore(&pAC->TxPort[(Port)][0].TxFreeFragQueue.QueueLock, Flags);	\
+}
+
+/* Required: 'Flags' */ 
+#define PUSH_FRAG_AS_LAST_IN_QUEUE(Port, pFrag, pNextFrag) {			\
+	spin_lock_irqsave(&pAC->TxPort[(Port)][0].TxFreeFragQueue.QueueLock, Flags); \
+	(pNextFrag)      = (pFrag)->pNext;						\
+	(pFrag)->pNext   = NULL;						\
+	(pFrag)->pVirt   = NULL;						\
+	(pFrag)->pPhys   = (SK_U64) 0;						\
+	(pFrag)->FragLen = 0;							\
+	if (pAC->TxPort[(Port)][0].TxFreeFragQueue.pTail != NULL) {		\
+		pAC->TxPort[(Port)][0].TxFreeFragQueue.pTail->pNext = (pFrag);	\
+	} else {								\
+		pAC->TxPort[(Port)][0].TxFreeFragQueue.pHead = (pFrag);		\
+	}									\
+	pAC->TxPort[(Port)][0].TxFreeFragQueue.pTail = (pFrag);			\
+	pAC->TxPort[(Port)][0].TxFreeFragQueue.NumFragsInQueue++;		\
+	spin_unlock_irqrestore(&pAC->TxPort[(Port)][0].TxFreeFragQueue.QueueLock, Flags); \
+}
+
+/*******************************************************************************
+ *
+ * Used interrupt bits in the interrupts source register
+ *
+ ******************************************************************************/
+
+#define DRIVER_IRQS	((IS_IRQ_SW) | \
+			 (IS_R1_F)   | (IS_R2_F)  | \
+			 (IS_XS1_F)  | (IS_XA1_F) | \
+			 (IS_XS2_F)  | (IS_XA2_F))
+
+#define TX_COMPL_IRQS	((IS_XS1_B)  | (IS_XS1_F) | \
+			 (IS_XA1_B)  | (IS_XA1_F) | \
+			 (IS_XS2_B)  | (IS_XS2_F) | \
+			 (IS_XA2_B)  | (IS_XA2_F))
+
+#define NAPI_DRV_IRQS	((IS_R1_F)   | (IS_R2_F) | \
+			 (IS_XS1_F)  | (IS_XA1_F)| \
+			 (IS_XS2_F)  | (IS_XA2_F))
+
+#define Y2_DRIVER_IRQS	((Y2_IS_STAT_BMU) | (Y2_IS_IRQ_SW) | (Y2_IS_POLL_CHK))
+
+#define SPECIAL_IRQS	((IS_HW_ERR)    |(IS_I2C_READY)  | \
+			 (IS_EXT_REG)   |(IS_TIMINT)     | \
+			 (IS_PA_TO_RX1) |(IS_PA_TO_RX2)  | \
+			 (IS_PA_TO_TX1) |(IS_PA_TO_TX2)  | \
+			 (IS_MAC1)      |(IS_LNK_SYNC_M1)| \
+			 (IS_MAC2)      |(IS_LNK_SYNC_M2)| \
+			 (IS_R1_C)      |(IS_R2_C)       | \
+			 (IS_XS1_C)     |(IS_XA1_C)      | \
+			 (IS_XS2_C)     |(IS_XA2_C))
+
+#define Y2_SPECIAL_IRQS	((Y2_IS_HW_ERR)   |(Y2_IS_ASF)      | \
+			 (Y2_IS_TWSI_RDY) |(Y2_IS_TIMINT)   | \
+			 (Y2_IS_IRQ_PHY2) |(Y2_IS_IRQ_MAC2) | \
+			 (Y2_IS_CHK_RX2)  |(Y2_IS_CHK_TXS2) | \
+			 (Y2_IS_CHK_TXA2) |(Y2_IS_IRQ_PHY1) | \
+			 (Y2_IS_IRQ_MAC1) |(Y2_IS_CHK_RX1)  | \
+			 (Y2_IS_CHK_TXS1) |(Y2_IS_CHK_TXA1))
+
+#define IRQ_MASK	((IS_IRQ_SW)    | \
+			 (IS_R1_F)      |(IS_R2_F)     | \
+			 (IS_XS1_F)     |(IS_XA1_F)    | \
+			 (IS_XS2_F)     |(IS_XA2_F)    | \
+			 (IS_HW_ERR)    |(IS_I2C_READY)| \
+			 (IS_EXT_REG)   |(IS_TIMINT)   | \
+			 (IS_PA_TO_RX1) |(IS_PA_TO_RX2)| \
+			 (IS_PA_TO_TX1) |(IS_PA_TO_TX2)| \
+			 (IS_MAC1)      |(IS_MAC2)     | \
+			 (IS_R1_C)      |(IS_R2_C)     | \
+			 (IS_XS1_C)     |(IS_XA1_C)    | \
+			 (IS_XS2_C)     |(IS_XA2_C))
+
+#define Y2_IRQ_MASK	((Y2_DRIVER_IRQS) | (Y2_SPECIAL_IRQS))
+
+#define IRQ_HWE_MASK	(IS_ERR_MSK)		/* enable all HW irqs */
+#define Y2_IRQ_HWE_MASK	(Y2_HWE_ALL_MSK)	/* enable all HW irqs */
 
 typedef struct s_DevNet DEV_NET;
 
 struct s_DevNet {
-	struct			proc_dir_entry *proc;
-	int             PortNr;
-	int             NetNr;
-	int             Mtu;
-	int             Up;
-	SK_AC   *pAC;
+	struct		proc_dir_entry *proc;
+	int		PortNr;
+	int		NetNr;
+	int		Mtu;
+	int		Up;
+	SK_AC		*pAC;
 };  
 
 typedef struct s_TxPort		TX_PORT;
 
@@ -282,12 +573,23 @@ struct s_TxPort {
 	SK_U64		VTxDescrRing;	/* descr. area bus virt. addr. */
 	TXD		*pTxdRingHead;	/* Head of Tx rings */
 	TXD		*pTxdRingTail;	/* Tail of Tx rings */
 	TXD		*pTxdRingPrev;	/* descriptor sent previously */
+	int		TxdRingPrevFree;/* previously # of free entrys */
 	int		TxdRingFree;	/* # of free entrys */
 	spinlock_t	TxDesRingLock;	/* serialize descriptor accesses */
 	caddr_t		HwAddr;		/* bmu registers address */
 	int		PortIndex;	/* index number of port (0 or 1) */
+	SK_PACKET	*TransmitPacketTable;
+	SK_FRAG         *TransmitFragmentTable;
+	SK_LE_TABLE	TxALET; 	/* tx (async) list element table */
+	SK_LE_TABLE	TxSLET; 	/* tx (sync) list element table */
+	SK_PKT_QUEUE	TxQ_free;
+	SK_PKT_QUEUE	TxAQ_waiting;
+	SK_PKT_QUEUE	TxSQ_waiting;
+	SK_PKT_QUEUE	TxAQ_working;
+	SK_PKT_QUEUE	TxSQ_working;
+	SK_FRAG_QUEUE   TxFreeFragQueue;
 };
 
 typedef struct s_RxPort		RX_PORT;
 
@@ -302,8 +604,13 @@ struct s_RxPort {
 	spinlock_t	RxDesRingLock;	/* serialize descriptor accesses */
 	int		RxFillLimit;	/* limit for buffers in ring */
 	caddr_t		HwAddr;		/* bmu registers address */
 	int		PortIndex;	/* index number of port (0 or 1) */
+	SK_FRAG 	*ReceiveFragmentTable;
+	SK_PACKET	*ReceivePacketTable;
+	SK_LE_TABLE	RxLET; 		/* rx list element table */
+	SK_PKT_QUEUE	RxQ_working;
+	SK_PKT_QUEUE	RxQ_waiting;
 };
 
 /* Definitions needed for interrupt moderation *******************************/
 
@@ -316,56 +623,64 @@ struct s_RxPort {
 #define IRQ_MASK_SP_RX    ((SPECIAL_IRQS)    | (IRQ_MASK_RX_ONLY))
 #define IRQ_MASK_SP_TX    ((SPECIAL_IRQS)    | (IRQ_MASK_TX_ONLY))
 #define IRQ_MASK_RX_TX_SP ((SPECIAL_IRQS)    | (IRQ_MASK_TX_RX))
 
-#define C_INT_MOD_NONE                 1
-#define C_INT_MOD_STATIC               2
-#define C_INT_MOD_DYNAMIC              4
-
-#define C_CLK_FREQ_GENESIS      53215000 /* shorter: 53.125 MHz  */
-#define C_CLK_FREQ_YUKON        78215000 /* shorter: 78.125 MHz  */
-
-#define C_INTS_PER_SEC_DEFAULT      2000 
-#define C_INT_MOD_ENABLE_PERCENTAGE   50 /* if higher 50% enable */
-#define C_INT_MOD_DISABLE_PERCENTAGE  50 /* if lower 50% disable */
-#define C_INT_MOD_IPS_LOWER_RANGE     30
-#define C_INT_MOD_IPS_UPPER_RANGE     40000
+#define IRQ_MASK_Y2_TX_ONLY  (Y2_IS_STAT_BMU)
+#define IRQ_MASK_Y2_RX_ONLY  (Y2_IS_STAT_BMU)
+#define IRQ_MASK_Y2_SP_ONLY  (SPECIAL_IRQS)
+#define IRQ_MASK_Y2_TX_RX    ((IRQ_MASK_TX_ONLY)| (IRQ_MASK_RX_ONLY))
+#define IRQ_MASK_Y2_SP_RX    ((SPECIAL_IRQS)    | (IRQ_MASK_RX_ONLY))
+#define IRQ_MASK_Y2_SP_TX    ((SPECIAL_IRQS)    | (IRQ_MASK_TX_ONLY))
+#define IRQ_MASK_Y2_RX_TX_SP ((SPECIAL_IRQS)    | (IRQ_MASK_TX_RX))
+
+#define C_INT_MOD_NONE			1
+#define C_INT_MOD_STATIC		2
+#define C_INT_MOD_DYNAMIC		4
+
+#define C_CLK_FREQ_GENESIS		 53215000	/* or:  53.125 MHz */
+#define C_CLK_FREQ_YUKON		 78215000	/* or:  78.125 MHz */
+#define C_CLK_FREQ_YUKON_EC		125000000	/* or: 125.000 MHz */
+
+#define C_Y2_INTS_PER_SEC_DEFAULT	5000 
+#define C_INTS_PER_SEC_DEFAULT		2000 
+#define C_INT_MOD_ENABLE_PERCENTAGE	50 /* if higher 50% enable */
+#define C_INT_MOD_DISABLE_PERCENTAGE	50 /* if lower 50% disable */
+#define C_INT_MOD_IPS_LOWER_RANGE	30
+#define C_INT_MOD_IPS_UPPER_RANGE	40000
 
 
 typedef struct s_DynIrqModInfo  DIM_INFO;
 struct s_DynIrqModInfo {
-	unsigned long   PrevTimeVal;
-	unsigned int    PrevSysLoad;
-	unsigned int    PrevUsedTime;
-	unsigned int    PrevTotalTime;
-	int             PrevUsedDescrRatio;
-	int             NbrProcessedDescr;
-        SK_U64          PrevPort0RxIntrCts;
-        SK_U64          PrevPort1RxIntrCts;
-        SK_U64          PrevPort0TxIntrCts;
-        SK_U64          PrevPort1TxIntrCts;
-	SK_BOOL         ModJustEnabled;     /* Moderation just enabled yes/no */
-
-	int             MaxModIntsPerSec;            /* Moderation Threshold */
-	int             MaxModIntsPerSecUpperLimit;  /* Upper limit for DIM  */
-	int             MaxModIntsPerSecLowerLimit;  /* Lower limit for DIM  */
-
-	long            MaskIrqModeration;   /* ModIrqType (eg. 'TxRx')      */
-	SK_BOOL         DisplayStats;        /* Stats yes/no                 */
-	SK_BOOL         AutoSizing;          /* Resize DIM-timer on/off      */
-	int             IntModTypeSelect;    /* EnableIntMod (eg. 'dynamic') */
+	unsigned long	PrevTimeVal;
+	unsigned int	PrevSysLoad;
+	unsigned int	PrevUsedTime;
+	unsigned int	PrevTotalTime;
+	int		PrevUsedDescrRatio;
+	int		NbrProcessedDescr;
+        SK_U64		PrevPort0RxIntrCts;
+        SK_U64		PrevPort1RxIntrCts;
+        SK_U64		PrevPort0TxIntrCts;
+        SK_U64		PrevPort1TxIntrCts;
+	SK_BOOL		ModJustEnabled;     /* Moderation just enabled yes/no */
+
+	int		MaxModIntsPerSec;            /* Moderation Threshold */
+	int		MaxModIntsPerSecUpperLimit;  /* Upper limit for DIM  */
+	int		MaxModIntsPerSecLowerLimit;  /* Lower limit for DIM  */
+
+	long		MaskIrqModeration;   /* ModIrqType (eg. 'TxRx')      */
+	SK_BOOL		DisplayStats;        /* Stats yes/no                 */
+	SK_BOOL		AutoSizing;          /* Resize DIM-timer on/off      */
+	int		IntModTypeSelect;    /* EnableIntMod (eg. 'dynamic') */
 
-	SK_TIMER        ModTimer; /* just some timer */
+	SK_TIMER	ModTimer; /* just some timer */
 };
 
 typedef struct s_PerStrm	PER_STRM;
 
 #define SK_ALLOC_IRQ	0x00000001
 
-#ifdef SK_DIAG_SUPPORT
 #define	DIAG_ACTIVE		1
 #define	DIAG_NOTACTIVE		0
-#endif
 
 /****************************************************************************
  * Per board structure / Adapter Context structure:
  *	Allocated within attach(9e) and freed within detach(9e).
@@ -396,9 +711,9 @@ struct s_AC  {
 	struct SK_NET_DEVICE	*dev[2];	/* pointer to device struct */
 	char		Name[30];	/* driver name */
 	struct SK_NET_DEVICE	*Next;		/* link all devices (for clearing) */
 	int		RxBufSize;	/* length of receive buffers */
-        struct net_device_stats stats;	/* linux 'netstat -i' statistics */
+	struct net_device_stats stats;	/* linux 'netstat -i' statistics */
 	int		Index;		/* internal board index number */
 
 	/* adapter RAM sizes for queues of active port */
 	int		RxQueueSize;	/* memory used for receive queue */
@@ -423,33 +738,44 @@ struct s_AC  {
 	/* the port structures with descriptor rings */
 	TX_PORT		TxPort[SK_MAX_MACS][2];
 	RX_PORT		RxPort[SK_MAX_MACS];
 
+	/* Yukon2 specific structures and variables start */
+	SK_LE_TABLE 	TxListElement[SK_MAX_MACS][2];
+	SK_LE_TABLE 	RxListElement[SK_MAX_MACS];
+	SK_LE_TABLE 	StatusLETable;		/* Status LETable */
+	unsigned	SizeOfAlignedLETables;	/* evaluated size */
+	spinlock_t	SetPutIndexLock;	/* put index lock */
+	SK_TIMER	TxPollTimer;		/* for TX polling */
+	int		MaxUnusedRxLeWorking;
+	/* Yukon2 specific config variables stop */
+
 	unsigned int	CsOfs1;		/* for checksum calculation */
 	unsigned int	CsOfs2;		/* for checksum calculation */
 	SK_U32		CsOfs;		/* for checksum calculation */
 
 	SK_BOOL		CheckQueue;	/* check event queue soon */
-	SK_TIMER        DrvCleanupTimer;/* to check for pending descriptors */
-	DIM_INFO        DynIrqModInfo;  /* all data related to DIM */
+	SK_TIMER	DrvCleanupTimer;/* to check for pending descriptors */
+	DIM_INFO	DynIrqModInfo;  /* all data related to DIM */
 
 	/* Only for tests */
 	int		PortUp;
 	int		PortDown;
 	int		ChipsetType;	/*  Chipset family type 
 					 *  0 == Genesis family support
 					 *  1 == Yukon family support
 					 */
-#ifdef SK_DIAG_SUPPORT
 	SK_U32		DiagModeActive;		/* is diag active?	*/
 	SK_BOOL		DiagFlowCtrl;		/* for control purposes	*/
 	SK_PNMI_STRUCT_DATA PnmiBackup;		/* backup structure for all Pnmi-Data */
-	SK_BOOL         WasIfUp[SK_MAX_MACS];   /* for OpenClose while 
+	SK_BOOL		WasIfUp[SK_MAX_MACS];   /* for OpenClose while 
 						 * DIAG is busy with NIC 
 						 */
-#endif
-
 };
 
+#endif
 
-#endif /* __INC_SKDRV2ND_H */
-
+/*******************************************************************************
+ *
+ * End of file
+ *
+ ******************************************************************************/
Index: linux-2.6.8/drivers/net/sk98lin/h/skerror.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skerror.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skerror.h
@@ -1,24 +1,23 @@
 /******************************************************************************
  *
  * Name:	skerror.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.7 $
- * Date:	$Date: 2003/05/13 17:25:13 $
+ * Version:	$Revision: 2.2 $
+ * Date:	$Date: 2004/05/24 15:27:19 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
@@ -35,9 +34,8 @@
 #define	SK_ERRCL_SW			(1L<<3)	/* Internal Software error */
 #define	SK_ERRCL_HW			(1L<<4)	/* Hardware Failure */
 #define	SK_ERRCL_COMM		(1L<<5)	/* Communication error */
 
-
 /*
  * Define Error Code Bases
  */
 #define	SK_ERRBASE_RLMT		 100	/* Base Error number for RLMT */
@@ -48,8 +46,10 @@
 #define	SK_ERRBASE_SIRQ		 600	/* Base Error number for Special IRQ */
 #define	SK_ERRBASE_I2C		 700	/* Base Error number for I2C module */
 #define	SK_ERRBASE_QUEUE	 800	/* Base Error number for Scheduler */
 #define	SK_ERRBASE_ADDR		 900	/* Base Error number for Address module */
-#define SK_ERRBASE_PECP		1000    /* Base Error number for PECP */
+#define SK_ERRBASE_PECP		1000	/* Base Error number for PECP */
 #define	SK_ERRBASE_DRV		1100	/* Base Error number for Driver */
+#define SK_ERRBASE_ASF		1200	/* Base Error number for ASF */
 
 #endif	/* _INC_SKERROR_H_ */
+
Index: linux-2.6.8/drivers/net/sk98lin/h/skgedrv.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skgedrv.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skgedrv.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skgedrv.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.10 $
- * Date:	$Date: 2003/07/04 12:25:01 $
+ * Version:	$Revision: 2.1 $
+ * Date:	$Date: 2003/10/27 14:16:08 $
  * Purpose:	Interface with the driver
  *
  ******************************************************************************/
 
Index: linux-2.6.8/drivers/net/sk98lin/h/skgehw.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skgehw.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skgehw.h
@@ -1,24 +1,23 @@
 /******************************************************************************
  *
  * Name:	skgehw.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.56 $
- * Date:	$Date: 2003/09/23 09:01:00 $
+ * Version:	$Revision: 2.38 $
+ * Date:	$Date: 2004/06/03 15:20:57 $
  * Purpose:	Defines and Macros for the Gigabit Ethernet Adapter Product Family
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
@@ -113,8 +112,18 @@ extern "C" {
 #define SHIFT2(x)	((x) << 2)
 #define SHIFT1(x)	((x) << 1)
 #define SHIFT0(x)	((x) << 0)
 
+/* Macro for arbitrary alignment of a given pointer */
+#define ALIGN_ADDR( ADDRESS, GRANULARITY ) { \
+    SK_UPTR addr = (SK_UPTR)(ADDRESS); \
+    if (addr & ((GRANULARITY)-1)) { \
+        addr += (GRANULARITY); \
+        addr &= ~(SK_UPTR)((GRANULARITY)-1); \
+        ADDRESS = (void *)addr; \
+    }\
+}
+
 /*
  * Configuration Space header
  * Since this module is used for different OS', those may be
  * duplicate on some of them (e.g. Linux). But to keep the
@@ -131,14 +140,14 @@ extern "C" {
 #define PCI_HEADER_T	0x0e	/*  8 bit	Header Type */
 #define PCI_BIST		0x0f	/*  8 bit	Built-in selftest */
 #define PCI_BASE_1ST	0x10	/* 32 bit	1st Base address */
 #define PCI_BASE_2ND	0x14	/* 32 bit	2nd Base address */
-	/* Byte 0x18..0x2b:	reserved */
+	/* Bytes 0x18..0x2b:	reserved */
 #define PCI_SUB_VID		0x2c	/* 16 bit	Subsystem Vendor ID */
 #define PCI_SUB_ID		0x2e	/* 16 bit	Subsystem ID */
 #define PCI_BASE_ROM	0x30	/* 32 bit	Expansion ROM Base Address */
 #define PCI_CAP_PTR		0x34	/*  8 bit 	Capabilities Ptr */
-	/* Byte 0x35..0x3b:	reserved */
+	/* Bytes 0x35..0x3b:	reserved */
 #define PCI_IRQ_LINE	0x3c	/*  8 bit	Interrupt Line */
 #define PCI_IRQ_PIN		0x3d	/*  8 bit	Interrupt Pin */
 #define PCI_MIN_GNT		0x3e	/*  8 bit	Min_Gnt */
 #define PCI_MAX_LAT		0x3f	/*  8 bit	Max_Lat */
@@ -146,21 +155,61 @@ extern "C" {
 #define PCI_OUR_REG_1	0x40	/* 32 bit 	Our Register 1 */
 #define PCI_OUR_REG_2	0x44	/* 32 bit 	Our Register 2 */
 	/* Power Management Region */
 #define PCI_PM_CAP_ID	0x48	/*  8 bit 	Power Management Cap. ID */
-#define PCI_PM_NITEM	0x49	/*  8 bit 	Next Item Ptr */
+#define PCI_PM_NITEM	0x49	/*  8 bit 	PM Next Item Pointer */
 #define PCI_PM_CAP_REG	0x4a	/* 16 bit 	Power Management Capabilities */
 #define PCI_PM_CTL_STS	0x4c	/* 16 bit 	Power Manag. Control/Status */
 	/* Byte 0x4e:	reserved */
 #define PCI_PM_DAT_REG	0x4f	/*  8 bit 	Power Manag. Data Register */
 	/* VPD Region */
 #define PCI_VPD_CAP_ID	0x50	/*  8 bit 	VPD Cap. ID */
-#define PCI_VPD_NITEM	0x51	/*  8 bit 	Next Item Ptr */
+#define PCI_VPD_NITEM	0x51	/*  8 bit 	VPD Next Item Pointer */
 #define PCI_VPD_ADR_REG	0x52	/* 16 bit 	VPD Address Register */
 #define PCI_VPD_DAT_REG	0x54	/* 32 bit 	VPD Data Register */
-	/* Byte 0x58..0x59:	reserved */
+	/* Bytes 0x58..0x59:	reserved */
 #define PCI_SER_LD_CTRL	0x5a	/* 16 bit 	SEEPROM Loader Ctrl (YUKON only) */
-	/* Byte 0x5c..0xff:	reserved */
+	/* Bytes 0x5c..0xfc:	used by Yukon-2 */
+#define PCI_MSI_CAP_ID	0x5c	/*  8 bit	MSI Capability ID Register */
+#define PCI_MSI_NITEM	0x5d	/*  8 bit	MSI Next Item Pointer */
+#define PCI_MSI_CTRL	0x5e	/* 16 bit	MSI Message Control */
+#define PCI_MSI_ADR_LO	0x60	/* 32 bit	MSI Message Address (Lower) */
+#define PCI_MSI_ADR_HI	0x64	/* 32 bit	MSI Message Address (Upper) */
+#define PCI_MSI_DATA	0x68	/* 16 bit	MSI Message Data */
+	/* Bytes 0x6a..0x6b:	reserved */
+#define PCI_X_CAP_ID	0x6c	/*  8 bit	PCI-X Capability ID Register */
+#define PCI_X_NITEM		0x6d	/*  8 bit	PCI-X Next Item Pointer */
+#define PCI_X_COMMAND	0x6e	/* 16 bit	PCI-X Command */
+#define PCI_X_PE_STAT	0x70	/* 32 bit	PCI-X / PE Status */
+#define PCI_CAL_CTRL	0x74	/* 16 bit	PCI Calibration Control Register */
+#define PCI_CAL_STAT	0x76	/* 16 bit	PCI Calibration Status Register */
+#define PCI_DISC_CNT	0x78	/* 16 bit	PCI Discard Counter */
+#define PCI_RETRY_CNT	0x7a	/*  8 bit	PCI Retry Counter */
+	/* Byte 0x7b:	reserved */
+#define PCI_OUR_STATUS	0x7c	/* 32 bit 	Adapter Status Register */
+	/* Bytes 0x80..0xdf:	reserved */
+
+/* PCI Express Capability */
+#define PEX_CAP_ID		0xe0	/*  8 bit	PEX Capability ID */
+#define PEX_NITEM		0xe1	/*  8 bit	PEX Next Item Pointer */
+#define PEX_CAP_REG		0xe2	/* 16 bit	PEX Capability Register */
+#define PEX_DEV_CAP		0xe4	/* 32 bit	PEX Device Capabilities */
+#define PEX_DEV_CTRL	0xe8	/* 16 bit	PEX Device Control */
+#define PEX_DEV_STAT	0xea	/* 16 bit	PEX Device Status */
+#define PEX_LNK_CAP		0xec	/* 32 bit	PEX Link Capabilities */
+#define PEX_LNK_CTRL	0xf0	/* 16 bit	PEX Link Control */
+#define PEX_LNK_STAT	0xf2	/* 16 bit	PEX Link Status */
+	/* Bytes 0xf4..0xff:	reserved */
+
+/* PCI Express Extended Capabilities */
+#define PEX_ADV_ERR_REP		0x100	/* 32 bit	PEX Advanced Error Reporting */
+#define PEX_UNC_ERR_STAT	0x104	/* 32 bit	PEX Uncorr. Errors Status */
+#define PEX_UNC_ERR_MASK	0x108	/* 32 bit	PEX Uncorr. Errors Mask */
+#define PEX_UNC_ERR_SEV		0x10c	/* 32 bit	PEX Uncorr. Errors Severity */
+#define PEX_COR_ERR_STAT	0x110	/* 32 bit	PEX Correc. Errors Status */
+#define PEX_COR_ERR_MASK	0x114	/* 32 bit	PEX Correc. Errors Mask */
+#define PEX_ADV_ERR_CAP_C	0x118	/* 32 bit	PEX Advanced Error Cap./Ctrl */
+#define PEX_HEADER_LOG		0x11c	/* 4x32 bit	PEX Header Log Register */
 
 /*
  * I2C Address (PCI Config)
  *
@@ -179,9 +228,9 @@ extern "C" {
 #define PCI_SERREN		BIT_8S		/* SERR enable */
 #define PCI_ADSTEP		BIT_7S		/* Address Stepping */
 #define PCI_PERREN		BIT_6S		/* Parity Report Response enable */
 #define PCI_VGA_SNOOP	BIT_5S		/* VGA palette snoop */
-#define PCI_MWIEN		BIT_4S		/* Memory write an inv cycl ena */
+#define PCI_MWIEN		BIT_4S		/* Memory write an inv cycl enable */
 #define PCI_SCYCEN		BIT_3S		/* Special Cycle enable */
 #define PCI_BMEN		BIT_2S		/* Bus Master enable */
 #define PCI_MEMEN		BIT_1S		/* Memory Space Access enable */
 #define PCI_IOEN		BIT_0S		/* I/O Space Access enable */
@@ -228,35 +277,44 @@ extern "C" {
 /*	PCI_BASE_1ST	32 bit	1st Base address */
 #define PCI_MEMSIZE		0x4000L		/* use 16 kB Memory Base */
 #define PCI_MEMBASE_MSK 0xffffc000L	/* Bit 31..14:	Memory Base Address */
 #define PCI_MEMSIZE_MSK 0x00003ff0L	/* Bit 13.. 4:	Memory Size Req. */
-#define PCI_PREFEN		BIT_3		/* Prefetchable */
-#define PCI_MEM_TYP		(3L<<2)		/* Bit	2.. 1:	Memory Type */
+#define PCI_PREFEN		BIT_3		/* Prefetch enable */
+#define PCI_MEM_TYP_MSK	(3L<<1)		/* Bit	2.. 1:	Memory Type Mask */
+#define PCI_MEMSPACE	BIT_0		/* Memory Space Indicator */
+
 #define PCI_MEM32BIT	(0L<<1)		/* Base addr anywhere in 32 Bit range */
 #define PCI_MEM1M		(1L<<1)		/* Base addr below 1 MegaByte */
 #define PCI_MEM64BIT	(2L<<1)		/* Base addr anywhere in 64 Bit range */
-#define PCI_MEMSPACE	BIT_0		/* Memory Space Indicator */
 
 /*	PCI_BASE_2ND	32 bit	2nd Base address */
 #define PCI_IOBASE		0xffffff00L	/* Bit 31.. 8:	I/O Base address */
 #define PCI_IOSIZE		0x000000fcL	/* Bit	7.. 2:	I/O Size Requirements */
-									/* Bit	1:	reserved */
+								/* Bit	1:	reserved */
 #define PCI_IOSPACE		BIT_0		/* I/O Space Indicator */
 
 /*	PCI_BASE_ROM	32 bit	Expansion ROM Base Address */
 #define PCI_ROMBASE_MSK	0xfffe0000L	/* Bit 31..17:	ROM Base address */
 #define PCI_ROMBASE_SIZ	(0x1cL<<14)	/* Bit 16..14:	Treat as Base or Size */
 #define PCI_ROMSIZE		(0x38L<<11)	/* Bit 13..11:	ROM Size Requirements */
-									/* Bit 10.. 1:	reserved */
+								/* Bit 10.. 1:	reserved */
 #define PCI_ROMEN		BIT_0		/* Address Decode enable */
 
 /* Device Dependent Region */
 /*	PCI_OUR_REG_1		32 bit	Our Register 1 */
-									/* Bit 31..29:	reserved */
+								/* Bit 31..29:	reserved */
 #define PCI_PHY_COMA	BIT_28		/* Set PHY to Coma Mode (YUKON only) */
 #define PCI_TEST_CAL	BIT_27		/* Test PCI buffer calib. (YUKON only) */
 #define PCI_EN_CAL		BIT_26		/* Enable PCI buffer calib. (YUKON only) */
 #define PCI_VIO			BIT_25		/* PCI I/O Voltage, 0 = 3.3V, 1 = 5V */
+/* Yukon-2 */
+#define PCI_Y2_PIG_ENA		BIT_31	/* Enable Plug-in-Go (YUKON-2) */
+#define PCI_Y2_DLL_DIS		BIT_30	/* Disable PCI DLL (YUKON-2) */
+#define PCI_Y2_PHY2_COMA	BIT_29	/* Set PHY 2 to Coma Mode (YUKON-2) */
+#define PCI_Y2_PHY1_COMA	BIT_28	/* Set PHY 1 to Coma Mode (YUKON-2) */
+#define PCI_Y2_PHY2_POWD	BIT_27	/* Set PHY 2 to Power Down (YUKON-2) */
+#define PCI_Y2_PHY1_POWD	BIT_26	/* Set PHY 1 to Power Down (YUKON-2) */
+								/* Bit 25:	reserved */
 #define PCI_DIS_BOOT	BIT_24		/* Disable BOOT via ROM */
 #define PCI_EN_IO		BIT_23		/* Mapping to I/O space */
 #define PCI_EN_FPROM	BIT_22		/* Enable FLASH mapping to memory */
 									/*		1 = Map Flash to memory */
@@ -265,11 +323,12 @@ extern "C" {
 #define PCI_PAGE_16		(0L<<20)	/*		16 k pages	*/
 #define PCI_PAGE_32K	(1L<<20)	/*		32 k pages	*/
 #define PCI_PAGE_64K	(2L<<20)	/*		64 k pages	*/
 #define PCI_PAGE_128K	(3L<<20)	/*		128 k pages	*/
-									/* Bit 19:	reserved	*/
+								/* Bit 19:	reserved	*/
 #define PCI_PAGEREG		(7L<<16)	/* Bit 18..16:	Page Register	*/
 #define PCI_NOTAR		BIT_15		/* No turnaround cycle */
+#define PCI_PEX_LEGNAT	BIT_15		/* PEX PM legacy/native mode (YUKON-2) */
 #define PCI_FORCE_BE	BIT_14		/* Assert all BEs on MR */
 #define PCI_DIS_MRL		BIT_13		/* Disable Mem Read Line */
 #define PCI_DIS_MRM		BIT_12		/* Disable Mem Read Multiple */
 #define PCI_DIS_MWI		BIT_11		/* Disable Mem Write & Invalidate */
@@ -278,14 +337,13 @@ extern "C" {
 #define PCI_DIS_PCI_CLK	BIT_8		/* Disable PCI clock driving */
 #define PCI_SKEW_DAS	(0xfL<<4)	/* Bit	7.. 4:	Skew Ctrl, DAS Ext */
 #define PCI_SKEW_BASE	0xfL		/* Bit	3.. 0:	Skew Ctrl, Base	*/
 
-
 /*	PCI_OUR_REG_2		32 bit	Our Register 2 */
 #define PCI_VPD_WR_THR	(0xffL<<24)	/* Bit 31..24:	VPD Write Threshold */
 #define PCI_DEV_SEL		(0x7fL<<17)	/* Bit 23..17:	EEPROM Device Select */
 #define PCI_VPD_ROM_SZ	(7L<<14)	/* Bit 16..14:	VPD ROM Size	*/
-									/* Bit 13..12:	reserved	*/
+								/* Bit 13..12:	reserved	*/
 #define PCI_PATCH_DIR	(0xfL<<8)	/* Bit 11.. 8:	Ext Patches dir 3..0 */
 #define PCI_PATCH_DIR_3	BIT_11
 #define PCI_PATCH_DIR_2	BIT_10
 #define PCI_PATCH_DIR_1	BIT_9
@@ -296,23 +354,22 @@ extern "C" {
 #define PCI_EXT_PATCH_1	BIT_5
 #define PCI_EXT_PATCH_0	BIT_4
 #define PCI_EN_DUMMY_RD	BIT_3		/* Enable Dummy Read */
 #define PCI_REV_DESC	BIT_2		/* Reverse Desc. Bytes */
-									/* Bit	1:	reserved */
+								/* Bit	1:	reserved */
 #define PCI_USEDATA64	BIT_0		/* Use 64Bit Data bus ext */
 
-
 /* Power Management Region */
 /*	PCI_PM_CAP_REG		16 bit	Power Management Capabilities */
 #define PCI_PME_SUP_MSK	(0x1f<<11)	/* Bit 15..11:	PM Event Support Mask */
-#define PCI_PME_D3C_SUP	BIT_15S		/* PME from D3cold Support (if Vaux) */
+#define PCI_PME_D3C_SUP	BIT_15S		/* PME from D3cold Support (if VAUX) */
 #define PCI_PME_D3H_SUP	BIT_14S		/* PME from D3hot Support */
 #define PCI_PME_D2_SUP	BIT_13S		/* PME from D2 Support */
 #define PCI_PME_D1_SUP	BIT_12S		/* PME from D1 Support */
 #define PCI_PME_D0_SUP	BIT_11S		/* PME from D0 Support */
 #define PCI_PM_D2_SUP	BIT_10S		/* D2 Support in 33 MHz mode */
 #define PCI_PM_D1_SUP	BIT_9S		/* D1 Support */
-									/* Bit	8.. 6:	reserved */
+								/* Bit	8.. 6:	reserved */
 #define PCI_PM_DSI		BIT_5S		/* Device Specific Initialization */
 #define PCI_PM_APS		BIT_4S		/* Auxialiary Power Source */
 #define PCI_PME_CLOCK	BIT_3S		/* PM Event Clock */
 #define PCI_PM_VER_MSK		7		/* Bit	2.. 0:	PM PCI Spec. version */
@@ -321,9 +378,9 @@ extern "C" {
 #define PCI_PME_STATUS	BIT_15S		/* PME Status (YUKON only) */
 #define PCI_PM_DAT_SCL	(3<<13)		/* Bit 14..13:	Data Reg. scaling factor */
 #define PCI_PM_DAT_SEL	(0xf<<9)	/* Bit 12.. 9:	PM data selector field */
 #define PCI_PME_EN		BIT_8S		/* Enable PME# generation (YUKON only) */
-									/* Bit	7.. 2:	reserved */
+								/* Bit	7.. 2:	reserved */
 #define PCI_PM_STATE_MSK	3		/* Bit	1.. 0:	Power Management State */
 
 #define PCI_PM_STATE_D0		0		/* D0:	Operational (default) */
 #define PCI_PM_STATE_D1		1		/* D1:	(YUKON only) */
@@ -332,9 +389,61 @@ extern "C" {
 
 /* VPD Region */
 /*	PCI_VPD_ADR_REG		16 bit	VPD Address Register */
 #define PCI_VPD_FLAG	BIT_15S		/* starts VPD rd/wr cycle */
-#define PCI_VPD_ADR_MSK	0x7fffL		/* Bit 14.. 0:	VPD address mask */
+#define PCI_VPD_ADR_MSK	0x7fffL		/* Bit 14.. 0:	VPD Address Mask */
+
+/* PCI_OUR_STATUS		32 bit 	Adapter Status Register (Yukon-2) */
+#define PCI_OS_PCI64	BIT_31		/* Conventional PCI 64 bits Bus */
+#define PCI_OS_PCIX		BIT_30		/* PCI-X Bus */
+#define PCI_OS_MODE_MSK	(3<<28)		/* Bit 29..28:	PCI-X Bus Mode Mask */
+#define PCI_OS_PCI66	BIT_27		/* PCI 66 MHz Bus */
+#define PCI_OS_PCI_X	BIT_26		/* PCI/PCI-X Bus (0 = PEX)*/
+#define PCI_OS_DLLE_MSK	(3<<24)		/* Bit 25..24:	DLL Status Indication */
+#define PCI_OS_DLLR_MSK	(0xf<<20)	/* Bit 23..20:	DLL Row Counters Values */
+#define PCI_OS_DLLC_MSK	(0xf<<16)	/* Bit 19..16:	DLL Col. Counters Values */
+								/* Bit 15.. 8:	reserved */
+
+#define PCI_OS_SPEED(val)	((val & PCI_OS_MODE_MSK) >> 28)	/* PCI-X Speed */
+/* possible values for the speed field of the register */
+#define PCI_OS_SPD_PCI		0		/* PCI Conventional Bus */
+#define PCI_OS_SPD_X66		1		/* PCI-X 66MHz Bus */
+#define PCI_OS_SPD_X100		2		/* PCI-X 100MHz Bus */
+#define PCI_OS_SPD_X133		3		/* PCI-X 133MHz Bus */
+
+/* PEX_DEV_CTRL			16 bit	PEX Device Control (Yukon-2) */
+								/* Bit 15	reserved */
+#define PEX_DC_MAX_RRS_MSK	(7<<12)	/* Bit 14..12:	Max. Read Request Size */
+#define PEX_DC_EN_NO_SNOOP	BIT_11S	/* Enable No Snoop */
+#define PEX_DC_EN_AUX_POW	BIT_10S	/* Enable AUX Power */
+#define PEX_DC_EN_PHANTOM	BIT_9S	/* Enable Phantom Functions */
+#define PEX_DC_EN_EXT_TAG	BIT_8S	/* Enable Extended Tag Field */
+#define PEX_DC_MAX_PLS_MSK	(7<<5)	/* Bit  7.. 5:	Max. Payload Size Mask */
+#define PEX_DC_EN_REL_ORD	BIT_4S	/* Enable Relaxed Ordering */
+#define PEX_DC_EN_UNS_RQ_RP	BIT_3S	/* Enable Unsupported Request Reporting */
+#define PEX_DC_EN_FAT_ER_RP	BIT_2S	/* Enable Fatal Error Reporting */
+#define PEX_DC_EN_NFA_ER_RP	BIT_1S	/* Enable Non-Fatal Error Reporting */
+#define PEX_DC_EN_COR_ER_RP	BIT_0S	/* Enable Correctable Error Reporting */
+
+#define PEX_DC_MAX_RD_RQ_SIZE(x)	(SHIFT12(x) & PEX_DC_MAX_RRS_MSK)
+
+/* PEX_UNC_ERR_STAT	 PEX Uncorrectable Errors Status Register (Yukon-2) */
+								/* Bit 31..21	reserved */
+#define	PEX_UNSUP_REQ 	BIT_20		/* Unsupported Request Error */
+									/* ECRC Error (not supported) */
+#define PEX_MALFOR_TLP	BIT_18		/* Malformed TLP */
+									/* Receiver Overflow (not supported) */
+#define PEX_UNEXP_COMP	BIT_16		/* Unexpected Completion */
+									/* Completer Abort (not supported) */
+#define PEX_COMP_TO		BIT_14		/* Completion Timeout */
+#define PEX_FLOW_CTRL_P	BIT_13		/* Flow Control Protocol Error */
+#define PEX_POIS_TLP	BIT_12		/* Poisoned TLP */
+								/* Bit 11.. 5:	reserved */
+#define PEX_DATA_LINK_P BIT_4		/* Data Link Protocol Error */
+								/* Bit  3.. 1:	reserved */
+									/* Training Error (not supported) */
+
+#define PEX_FATAL_ERRORS	(PEX_MALFOR_TLP | PEX_FLOW_CTRL_P | PEX_DATA_LINK_P)
 
 /*	Control Register File (Address Map) */
 
 /*
@@ -348,10 +457,16 @@ extern "C" {
 #define B0_ISRC			0x0008	/* 32 bit	Interrupt Source Register */
 #define B0_IMSK			0x000c	/* 32 bit	Interrupt Mask Register */
 #define B0_HWE_ISRC		0x0010	/* 32 bit	HW Error Interrupt Src Reg */
 #define B0_HWE_IMSK		0x0014	/* 32 bit	HW Error Interrupt Mask Reg */
-#define B0_SP_ISRC		0x0018	/* 32 bit	Special Interrupt Source Reg */
-	/* 0x001c:		reserved */
+#define B0_SP_ISRC		0x0018	/* 32 bit	Special Interrupt Source Reg 1 */
+
+/* Special ISR registers (Yukon-2 only) */
+#define B0_Y2_SP_ISRC2	0x001c	/* 32 bit	Special Interrupt Source Reg 2 */
+#define B0_Y2_SP_ISRC3	0x0020	/* 32 bit	Special Interrupt Source Reg 3 */
+#define B0_Y2_SP_EISR	0x0024	/* 32 bit	Enter ISR Reg */
+#define B0_Y2_SP_LISR	0x0028	/* 32 bit	Leave ISR Reg */
+#define B0_Y2_SP_ICR	0x002c	/* 32 bit	Interrupt Control Reg */
 
 /* B0 XMAC 1 registers (GENESIS only) */
 #define B0_XM1_IMSK		0x0020	/* 16 bit r/w	XMAC 1 Interrupt Mask Register*/
 	/* 0x0022 - 0x0027:	reserved */
@@ -400,15 +515,24 @@ extern "C" {
 #define B2_CONN_TYP		0x0118	/*  8 bit	Connector type */
 #define B2_PMD_TYP		0x0119	/*  8 bit	PMD type */
 #define B2_MAC_CFG		0x011a	/*  8 bit	MAC Configuration / Chip Revision */
 #define B2_CHIP_ID		0x011b	/*  8 bit 	Chip Identification Number */
-	/* Eprom registers are currently of no use */
+	/* Eprom registers */
 #define B2_E_0			0x011c	/*  8 bit	EPROM Byte 0 (ext. SRAM size */
+/* Yukon and Genesis */
 #define B2_E_1			0x011d	/*  8 bit	EPROM Byte 1 (PHY type) */
 #define B2_E_2			0x011e	/*  8 bit	EPROM Byte 2 */
+/* Yukon-2 */
+#define B2_Y2_CLK_GATE	0x011d	/*  8 bit	Clock Gating (Yukon-2) */
+#define B2_Y2_HW_RES	0x011e	/*  8 bit	HW Resources (Yukon-2) */
+
 #define B2_E_3			0x011f	/*  8 bit	EPROM Byte 3 */
+
+/* Yukon and Genesis */
 #define B2_FAR			0x0120	/* 32 bit	Flash-Prom Addr Reg/Cnt */
 #define B2_FDP			0x0124	/*  8 bit	Flash-Prom Data Port */
+/* Yukon-2 */
+#define B2_Y2_CLK_DIV	0x0120	/* 32 bit	Clock Divider Register (Yukon-2) */
 	/* 0x0125 - 0x0127:	reserved */
 #define B2_LD_CTRL		0x0128	/*  8 bit	EPROM loader control register */
 #define B2_LD_TEST		0x0129	/*  8 bit	EPROM loader test register */
 	/* 0x012a - 0x012f:	reserved */
@@ -438,8 +562,12 @@ extern "C" {
 #define B2_BSC_VAL		0x0174	/* 32 bit	Blink Source Counter Value */
 #define B2_BSC_CTRL		0x0178	/*  8 bit	Blink Source Counter Control */
 #define B2_BSC_STAT		0x0179	/*  8 bit	Blink Source Counter Status */
 #define B2_BSC_TST		0x017a	/* 16 bit	Blink Source Counter Test Reg */
+	
+/* Yukon-2 */
+#define Y2_PEX_PHY_DATA	0x0170	/* 16 bit	PEX PHY Data Register */
+#define Y2_PEX_PHY_ADDR	0x0172	/* 16 bit	PEX PHY Address Register */
 	/* 0x017c - 0x017f:	reserved */
 
 /*
  *	Bank 3
@@ -447,11 +575,15 @@ extern "C" {
 /* RAM Random Registers */
 #define B3_RAM_ADDR		0x0180	/* 32 bit	RAM Address, to read or write */
 #define B3_RAM_DATA_LO	0x0184	/* 32 bit	RAM Data Word (low dWord) */
 #define B3_RAM_DATA_HI	0x0188	/* 32 bit	RAM Data Word (high dWord) */
-	/* 0x018c - 0x018f:	reserved */
+
+#define SELECT_RAM_BUFFER(rb, addr) (addr | (rb << 6))	/* Yukon-2 only */
+
+    /* 0x018c - 0x018f:	reserved */
 
 /* RAM Interface Registers */
+/* Yukon-2: use SELECT_RAM_BUFFER() to access the RAM buffer */
 /*
  * The HW-Spec. calls this registers Timeout Value 0..11. But this names are
  * not usable in SW. Please notice these are NOT real timeouts, these are
  * the number of qWords transferred continuously.
@@ -516,10 +648,10 @@ extern "C" {
 #define B3_PA_TOVAL_TX1	0x01e8	/* 16 bit	Timeout Val Tx Path MAC 1 */
 	/* 0x01ea - 0x01eb:	reserved */
 #define B3_PA_TOVAL_TX2	0x01ec	/* 16 bit	Timeout Val Tx Path MAC 2 */
 	/* 0x01ee - 0x01ef:	reserved */
-#define B3_PA_CTRL	0x01f0	/* 16 bit	Packet Arbiter Ctrl Register */
-#define B3_PA_TEST	0x01f2	/* 16 bit	Packet Arbiter Test Register */
+#define B3_PA_CTRL		0x01f0	/* 16 bit	Packet Arbiter Ctrl Register */
+#define B3_PA_TEST		0x01f2	/* 16 bit	Packet Arbiter Test Register */
 	/* 0x01f4 - 0x01ff:	reserved */
 
 /*
  *	Bank 4 - 5
@@ -531,9 +663,18 @@ extern "C" {
 #define TXA_LIM_VAL		0x020c	/* 32 bit	Tx Arb Limit Counter Value */
 #define TXA_CTRL		0x0210	/*  8 bit	Tx Arbiter Control Register */
 #define TXA_TEST		0x0211	/*  8 bit	Tx Arbiter Test Register */
 #define TXA_STAT		0x0212	/*  8 bit	Tx Arbiter Status Register */
-	/* 0x0213 - 0x027f:	reserved */
+	/* 0x0213 - 0x021f:	reserved */
+	
+	/* RSS key registers for Yukon-2 Family */
+#define B4_RSS_KEY		0x0220	/* 4x32 bit RSS Key register (Yukon-2) */
+	/* RSS key register offsets */
+#define KEY_IDX_0		0		/* offset for location of KEY 0 */
+#define KEY_IDX_1		4		/* offset for location of KEY 1 */
+#define KEY_IDX_2		8		/* offset for location of KEY 2 */
+#define KEY_IDX_3		12		/* offset for location of KEY 3 */
+		
 	/* 0x0280 - 0x0292:	MAC 2 */
 	/* 0x0213 - 0x027f:	reserved */
 
 /*
@@ -569,10 +710,39 @@ extern "C" {
 #define Q_T1_RD	0x3e	/*  8 bit	Test Register 1 Read Descriptor SM */
 #define Q_T1_SV	0x3f	/*  8 bit	Test Register 1 Supervisor SM */
 #define Q_T2	0x40	/* 32 bit	Test Register 2	*/
 #define Q_T3	0x44	/* 32 bit	Test Register 3	*/
+
+/* Yukon-2 */
+#define Q_DONE	0x24	/* 16 bit	Done Index 		(Yukon-2 only) */
+#define Q_WM	0x40	/* 16 bit	FIFO Watermark */
+#define Q_AL	0x42	/*  8 bit	FIFO Alignment */
+#define Q_RSP	0x44	/* 16 bit	FIFO Read Shadow Pointer */
+#define Q_RSL	0x46	/*  8 bit	FIFO Read Shadow Level */
+#define Q_RP	0x48	/*  8 bit	FIFO Read Pointer */
+#define Q_RL	0x4a	/*  8 bit	FIFO Read Level */
+#define Q_WP	0x4c	/*  8 bit	FIFO Write Pointer */
+#define Q_WSP	0x4d	/*  8 bit	FIFO Write Shadow Pointer */
+#define Q_WL	0x4e	/*  8 bit	FIFO Write Level */
+#define Q_WSL	0x4f	/*  8 bit	FIFO Write Shadow Level */
 	/* 0x48 - 0x7f:	reserved */
 
+/* Queue Prefetch Unit Offsets, use Y2_PREF_Q_ADDR() to address (Yukon-2 only)*/
+#define Y2_B8_PREF_REGS			0x0450
+
+#define PREF_UNIT_CTRL_REG		0x00	/* 32 bit	Prefetch Control register */
+#define PREF_UNIT_LAST_IDX_REG	0x04	/* 16 bit	Last Index */
+#define PREF_UNIT_ADDR_LOW_REG	0x08	/* 32 bit	List start addr, low part */
+#define PREF_UNIT_ADDR_HI_REG	0x0c	/* 32 bit	List start addr, high part*/
+#define PREF_UNIT_GET_IDX_REG	0x10	/* 16 bit	Get Index */
+#define PREF_UNIT_PUT_IDX_REG	0x14	/* 16 bit	Put Index */
+#define PREF_UNIT_FIFO_WP_REG	0x20	/*  8 bit 	FIFO write pointer */
+#define PREF_UNIT_FIFO_RP_REG	0x24	/*  8 bit	FIFO read pointer */
+#define PREF_UNIT_FIFO_WM_REG	0x28	/*  8 bit	FIFO watermark */
+#define PREF_UNIT_FIFO_LEV_REG	0x2c	/*  8 bit	FIFO level */
+
+#define PREF_UNIT_MASK_IDX  0x0fff
+
 /*
  *	Bank 16 - 23
  */
 /* RAM Buffer Registers */
@@ -582,19 +752,19 @@ extern "C" {
 #define RB_START		0x00	/* 32 bit	RAM Buffer Start Address */
 #define RB_END			0x04	/* 32 bit	RAM Buffer End Address */
 #define RB_WP			0x08	/* 32 bit	RAM Buffer Write Pointer */
 #define RB_RP			0x0c	/* 32 bit	RAM Buffer Read Pointer */
-#define RB_RX_UTPP		0x10	/* 32 bit	Rx Upper Threshold, Pause Pack */
-#define RB_RX_LTPP		0x14	/* 32 bit	Rx Lower Threshold, Pause Pack */
+#define RB_RX_UTPP		0x10	/* 32 bit	Rx Upper Threshold, Pause Packet */
+#define RB_RX_LTPP		0x14	/* 32 bit	Rx Lower Threshold, Pause Packet */
 #define RB_RX_UTHP		0x18	/* 32 bit	Rx Upper Threshold, High Prio */
 #define RB_RX_LTHP		0x1c	/* 32 bit	Rx Lower Threshold, High Prio */
 	/* 0x10 - 0x1f:	reserved at Tx RAM Buffer Registers */
 #define RB_PC			0x20	/* 32 bit	RAM Buffer Packet Counter */
 #define RB_LEV			0x24	/* 32 bit	RAM Buffer Level Register */
-#define RB_CTRL			0x28	/*  8 bit	RAM Buffer Control Register */
+#define RB_CTRL			0x28	/* 32 bit	RAM Buffer Control Register */
 #define RB_TST1			0x29	/*  8 bit	RAM Buffer Test Register 1 */
-#define RB_TST2			0x2A	/*  8 bit	RAM Buffer Test Register 2 */
-	/* 0x2c - 0x7f:	reserved */
+#define RB_TST2			0x2a	/*  8 bit	RAM Buffer Test Register 2 */
+	/* 0x2b - 0x7f:	reserved */
 
 /*
  *	Bank 24
  */
@@ -627,15 +797,17 @@ extern "C" {
 	/* 0x0c3a - 0x0c3b:	reserved */
 #define LNK_LED_REG		0x0c3c	/*  8 bit	Link LED Register */
 	/* 0x0c3d - 0x0c3f:	reserved */
 
-/* Receive GMAC FIFO (YUKON only), use MR_ADDR() to access */
+/* Receive GMAC FIFO (YUKON and Yukon-2), use MR_ADDR() to access */
 #define RX_GMF_EA		0x0c40	/* 32 bit	Rx GMAC FIFO End Address */
 #define RX_GMF_AF_THR	0x0c44	/* 32 bit	Rx GMAC FIFO Almost Full Thresh. */
 #define RX_GMF_CTRL_T	0x0c48	/* 32 bit	Rx GMAC FIFO Control/Test */
 #define RX_GMF_FL_MSK	0x0c4c	/* 32 bit	Rx GMAC FIFO Flush Mask */
 #define RX_GMF_FL_THR	0x0c50	/* 32 bit	Rx GMAC FIFO Flush Threshold */
-	/* 0x0c54 - 0x0c5f:	reserved */
+#define RX_GMF_TR_THR	0x0c54	/* 32 bit	Rx Truncation Threshold (Yukon-2) */
+	/* 0x0c58 - 0x0c5b:	reserved */
+#define RX_GMF_VLAN		0x0c5c	/* 32 bit 	Rx VLAN Type Register (Yukon-2) */
 #define RX_GMF_WP		0x0c60	/* 32 bit 	Rx GMAC FIFO Write Pointer */
 	/* 0x0c64 - 0x0c67:	reserved */
 #define RX_GMF_WLEV		0x0c68	/* 32 bit 	Rx GMAC FIFO Write Level */
 	/* 0x0c6c - 0x0c6f:	reserved */
@@ -675,13 +847,14 @@ extern "C" {
 #define TX_LED_CTRL		0x0d28	/*  8 bit	Transmit LED Cnt Control Reg */
 #define TX_LED_TST		0x0d29	/*  8 bit	Transmit LED Cnt Test Reg */
 	/* 0x0d2a - 0x0d3f:	reserved */
 
-/* Transmit GMAC FIFO (YUKON only), use MR_ADDR() to access */
+/* Transmit GMAC FIFO (YUKON and Yukon-2), use MR_ADDR() to access */
 #define TX_GMF_EA		0x0d40	/* 32 bit	Tx GMAC FIFO End Address */
 #define TX_GMF_AE_THR	0x0d44	/* 32 bit	Tx GMAC FIFO Almost Empty Thresh.*/
 #define TX_GMF_CTRL_T	0x0d48	/* 32 bit	Tx GMAC FIFO Control/Test */
-	/* 0x0d4c - 0x0d5f:	reserved */
+	/* 0x0d4c - 0x0d5b:	reserved */
+#define TX_GMF_VLAN		0x0d5c	/* 32 bit 	Tx VLAN Type Register (Yukon-2) */
 #define TX_GMF_WP		0x0d60	/* 32 bit 	Tx GMAC FIFO Write Pointer */
 #define TX_GMF_WSP		0x0d64	/* 32 bit 	Tx GMAC FIFO Write Shadow Ptr. */
 #define TX_GMF_WLEV		0x0d68	/* 32 bit 	Tx GMAC FIFO Write Level */
 	/* 0x0d6c - 0x0d6f:	reserved */
@@ -712,14 +885,86 @@ extern "C" {
 #define GMAC_TI_ST_VAL	0x0e14	/* 32 bit	Time Stamp Timer Curr Val */
 #define GMAC_TI_ST_CTRL	0x0e18	/*  8 bit	Time Stamp Timer Ctrl Reg */
 	/* 0x0e19:	reserved */
 #define GMAC_TI_ST_TST	0x0e1a	/*  8 bit	Time Stamp Timer Test Reg */
-	/* 0x0e1b - 0x0e7f:	reserved */
+	/* 0x0e1b - 0x0e1f:	reserved */
+
+/* Polling Unit Registers (Yukon-2 only) */
+#define POLL_CTRL			0x0e20	/* 32 bit	Polling Unit Control Reg */
+#define POLL_LAST_IDX		0x0e24	/* 16 bit	Polling Unit List Last Index */
+	/* 0x0e26 - 0x0e27:	reserved */
+#define POLL_LIST_ADDR_LO	0x0e28	/* 32 bit	Poll. List Start Addr (low) */
+#define POLL_LIST_ADDR_HI	0x0e2c	/* 32 bit	Poll. List Start Addr (high) */
+	/* 0x0e30 - 0x0e3f:	reserved */
+
+/* ASF Subsystem Registers (Yukon-2 only) */
+#define B28_Y2_SMB_CONFIG	0x0e40	/* 32 bit	ASF SMBus Config Register */
+#define B28_Y2_SMB_CSD_REG	0x0e44	/* 32 bit	ASF SMB Control/Status/Data */
+	/* 0x0e48 - 0x0e5f: reserved */
+#define B28_Y2_ASF_IRQ_V_BASE	0x0e60	/* 32 bit	ASF IRQ Vector Base */
+	/* 0x0e64 - 0x0e67: reserved */
+#define B28_Y2_ASF_STAT_CMD	0x0e68	/* 32 bit	ASF Status and Command Reg */
+#define B28_Y2_ASF_HOST_COM	0x0e6c	/* 32 bit	ASF Host Communication Reg */
+#define B28_Y2_DATA_REG_1	0x0e70	/* 32 bit	ASF/Host Data Register 1 */
+#define B28_Y2_DATA_REG_2	0x0e74	/* 32 bit	ASF/Host Data Register 2 */
+#define B28_Y2_DATA_REG_3	0x0e78	/* 32 bit	ASF/Host Data Register 3 */
+#define B28_Y2_DATA_REG_4	0x0e7c	/* 32 bit	ASF/Host Data Register 4 */
 
 /*
  *	Bank 29
  */
-	/* 0x0e80 - 0x0efc:	reserved */
+
+/* Status BMU Registers (Yukon-2 only)*/
+#define STAT_CTRL			0x0e80	/* 32 bit	Status BMU Control Reg */
+#define STAT_LAST_IDX		0x0e84	/* 16 bit	Status BMU Last Index */
+	/* 0x0e85 - 0x0e86:	reserved */
+#define STAT_LIST_ADDR_LO	0x0e88	/* 32 bit	Status List Start Addr (low) */
+#define STAT_LIST_ADDR_HI	0x0e8c	/* 32 bit	Status List Start Addr (high) */
+#define STAT_TXA1_RIDX		0x0e90	/* 16 bit	Status TxA1 Report Index Reg */
+#define STAT_TXS1_RIDX		0x0e92	/* 16 bit	Status TxS1 Report Index Reg */
+#define STAT_TXA2_RIDX		0x0e94	/* 16 bit	Status TxA2 Report Index Reg */
+#define STAT_TXS2_RIDX		0x0e96	/* 16 bit	Status TxS2 Report Index Reg */
+#define STAT_TX_IDX_TH		0x0e98	/* 16 bit	Status Tx Index Threshold Reg */
+	/* 0x0e9a - 0x0e9b:	reserved */
+#define STAT_PUT_IDX		0x0e9c	/* 16 bit	Status Put Index Reg */
+	/* 0x0e9e - 0x0e9f:	reserved */
+
+/* FIFO Control/Status Registers (Yukon-2 only)*/
+#define STAT_FIFO_WP		0x0ea0	/*  8 bit	Status FIFO Write Pointer Reg */
+	/* 0x0ea1 - 0x0ea3:	reserved */
+#define STAT_FIFO_RP		0x0ea4	/*  8 bit	Status FIFO Read Pointer Reg */
+	/* 0x0ea5:	reserved */
+#define STAT_FIFO_RSP		0x0ea6	/*  8 bit	Status FIFO Read Shadow Ptr */
+	/* 0x0ea7:	reserved */
+#define STAT_FIFO_LEVEL		0x0ea8	/*  8 bit	Status FIFO Level Reg */
+	/* 0x0ea9:	reserved */
+#define STAT_FIFO_SHLVL		0x0eaa	/*  8 bit	Status FIFO Shadow Level Reg */
+	/* 0x0eab:	reserved */
+#define STAT_FIFO_WM		0x0eac	/*  8 bit	Status FIFO Watermark Reg */
+#define STAT_FIFO_ISR_WM	0x0ead	/*  8 bit	Status FIFO ISR Watermark Reg */
+	/* 0x0eae - 0x0eaf:	reserved */
+
+/* Level and ISR Timer Registers (Yukon-2 only)*/
+#define STAT_LEV_TIMER_INI	0x0eb0	/* 32 bit	Level Timer Init. Value Reg */
+#define STAT_LEV_TIMER_CNT	0x0eb4	/* 32 bit	Level Timer Counter Reg */
+#define STAT_LEV_TIMER_CTRL	0x0eb8	/*  8 bit	Level Timer Control Reg */
+#define STAT_LEV_TIMER_TEST	0x0eb9	/*  8 bit	Level Timer Test Reg */
+	/* 0x0eba - 0x0ebf:	reserved */
+#define STAT_TX_TIMER_INI	0x0ec0	/* 32 bit	Tx Timer Init. Value Reg */
+#define STAT_TX_TIMER_CNT	0x0ec4	/* 32 bit	Tx Timer Counter Reg */
+#define STAT_TX_TIMER_CTRL	0x0ec8	/*  8 bit	Tx Timer Control Reg */
+#define STAT_TX_TIMER_TEST	0x0ec9	/*  8 bit	Tx Timer Test Reg */
+	/* 0x0eca - 0x0ecf:	reserved */
+#define STAT_ISR_TIMER_INI	0x0ed0	/* 32 bit	ISR Timer Init. Value Reg */
+#define STAT_ISR_TIMER_CNT	0x0ed4	/* 32 bit	ISR Timer Counter Reg */
+#define STAT_ISR_TIMER_CTRL	0x0ed8	/*  8 bit	ISR Timer Control Reg */
+#define STAT_ISR_TIMER_TEST	0x0ed9	/*  8 bit	ISR Timer Test Reg */
+	/* 0x0eda - 0x0eff:	reserved */
+
+#define ST_LAST_IDX_MASK    0x007f  /* Last Index Mask */
+#define ST_TXRP_IDX_MASK    0x0fff  /* Tx Report Index Mask */
+#define ST_TXTH_IDX_MASK    0x0fff  /* Tx Threshold Index Mask */
+#define ST_WM_IDX_MASK		0x3f	/* FIFO Watermark Index Mask */
 
 /*
  *	Bank 30
  */
@@ -741,13 +986,11 @@ extern "C" {
 #define WOL_MATCH_CTL	0x0f22	/*  8 bit	WOL Match Control Reg */
 #define WOL_MATCH_RES	0x0f23	/*  8 bit	WOL Match Result Reg */
 #define WOL_MAC_ADDR_LO	0x0f24	/* 32 bit	WOL MAC Address Low */
 #define WOL_MAC_ADDR_HI	0x0f28	/* 16 bit	WOL MAC Address High */
-#define WOL_PATT_RPTR	0x0f2c	/*  8 bit	WOL Pattern Read Ptr */
-
-/* use this macro to access above registers */
-#define WOL_REG(Reg)	((Reg) + (pAC->GIni.GIWolOffs))
-
+#define WOL_PATT_PME	0x0f2a	/*  8 bit   WOL PME Match Enable (Yukon-2) */
+#define WOL_PATT_ASFM	0x0f2b	/*  8 bit   WOL ASF Match Enable (Yukon-2) */
+#define WOL_PATT_RPTR	0x0f2c	/*  8 bit	WOL Pattern Read Pointer */
 
 /* WOL Pattern Length Registers (YUKON only) */
 
 #define WOL_PATT_LEN_LO	0x0f30		/* 32 bit	WOL Pattern Length 3..0 */
@@ -763,13 +1006,24 @@ extern "C" {
  *	Bank 31
  */
 /* 0x0f80 - 0x0fff:	reserved */
 
+/* WOL registers link 2 */
+
+/* use this macro to access WOL registers */
+#define WOL_REG(Port, Reg)	((Reg) + ((Port)*0x80) + (pAC->GIni.GIWolOffs))
+
 /*
  *	Bank 32	- 33
  */
 #define WOL_PATT_RAM_1	0x1000	/*  WOL Pattern RAM Link 1 */
+#define WOL_PATT_RAM_2  0x1400  /*  WOL Pattern RAM Link 2 */
+
+/* use this macro to retrieve the pattern ram base address */
+#define WOL_PATT_RAM_BASE(Port) (WOL_PATT_RAM_1 + (Port)*0x400)
 
+/* offset to configuration space on Yukon-2 */
+#define Y2_CFG_SPC 		0x1c00
 /*
  *	Bank 0x22 - 0x3f
  */
 /* 0x1100 - 0x1fff:	reserved */
@@ -801,29 +1055,42 @@ extern "C" {
 /*	B0_RAP		8 bit	Register Address Port */
 								/* Bit 7:	reserved */
 #define RAP_RAP			0x3f	/* Bit 6..0:	0 = block 0,..,6f = block 6f */
 
+/*	B0_CTST			24 bit	Control/Status register */
+								/* Bit 23..18:	reserved */
+#define Y2_VMAIN_AVAIL	BIT_17		/* VMAIN available (YUKON-2 only) */
+#define Y2_VAUX_AVAIL	BIT_16		/* VAUX available (YUKON-2 only) */
+								/* Bit 15..14:	reserved */
+#define Y2_ASF_ENABLE	BIT_13S		/* ASF Unit Enable (YUKON-2 only) */
+#define Y2_ASF_DISABLE	BIT_12S		/* ASF Unit Disable (YUKON-2 only) */
+#define Y2_CLK_RUN_ENA	BIT_11S		/* CLK_RUN Enable  (YUKON-2 only) */
+#define Y2_CLK_RUN_DIS	BIT_10S		/* CLK_RUN Disable (YUKON-2 only) */
+#define Y2_LED_STAT_ON	BIT_9S		/* Status LED On  (YUKON-2 only) */
+#define Y2_LED_STAT_OFF	BIT_8S		/* Status LED Off (YUKON-2 only) */
+								/* Bit  7.. 0:	same as below */
+
 /*	B0_CTST			16 bit	Control/Status register */
 								/* Bit 15..14:	reserved */
-#define CS_CLK_RUN_HOT	BIT_13S		/* CLK_RUN hot m. (YUKON-Lite only) */
-#define CS_CLK_RUN_RST	BIT_12S		/* CLK_RUN reset  (YUKON-Lite only) */
-#define CS_CLK_RUN_ENA	BIT_11S		/* CLK_RUN enable (YUKON-Lite only) */
+#define CS_CLK_RUN_HOT	BIT_13S		/* CLK_RUN Hot m. (YUKON-Lite only) */
+#define CS_CLK_RUN_RST	BIT_12S		/* CLK_RUN Reset  (YUKON-Lite only) */
+#define CS_CLK_RUN_ENA	BIT_11S		/* CLK_RUN Enable (YUKON-Lite only) */
 #define CS_VAUX_AVAIL	BIT_10S		/* VAUX available (YUKON only) */
 #define CS_BUS_CLOCK	BIT_9S		/* Bus Clock 0/1 = 33/66 MHz */
 #define CS_BUS_SLOT_SZ	BIT_8S		/* Slot Size 0/1 = 32/64 bit slot */
 #define CS_ST_SW_IRQ	BIT_7S		/* Set IRQ SW Request */
 #define CS_CL_SW_IRQ	BIT_6S		/* Clear IRQ SW Request */
 #define CS_STOP_DONE	BIT_5S		/* Stop Master is finished */
 #define CS_STOP_MAST	BIT_4S		/* Command Bit to stop the master */
-#define CS_MRST_CLR		BIT_3S		/* Clear Master reset	*/
-#define CS_MRST_SET		BIT_2S		/* Set Master reset	*/
-#define CS_RST_CLR		BIT_1S		/* Clear Software reset	*/
-#define CS_RST_SET		BIT_0S		/* Set   Software reset	*/
+#define CS_MRST_CLR		BIT_3S		/* Clear Master Reset */
+#define CS_MRST_SET		BIT_2S		/* Set   Master Reset */
+#define CS_RST_CLR		BIT_1S		/* Clear Software Reset	*/
+#define CS_RST_SET		BIT_0S		/* Set   Software Reset	*/
 
-/*	B0_LED			 8 Bit	LED register */
+/*	B0_LED			 8 Bit	LED register (GENESIS only)*/
 								/* Bit  7.. 2:	reserved */
-#define LED_STAT_ON		BIT_1S		/* Status LED on	*/
-#define LED_STAT_OFF	BIT_0S		/* Status LED off	*/
+#define LED_STAT_ON		BIT_1S		/* Status LED On	*/
+#define LED_STAT_OFF	BIT_0S		/* Status LED Off	*/
 
 /*	B0_POWER_CTRL	 8 Bit	Power Control reg (YUKON only) */
 #define PC_VAUX_ENA		BIT_7		/* Switch VAUX Enable  */
 #define PC_VAUX_DIS		BIT_6       /* Switch VAUX Disable */
@@ -833,8 +1100,9 @@ extern "C" {
 #define PC_VAUX_OFF		BIT_2       /* Switch VAUX Off */
 #define PC_VCC_ON		BIT_1       /* Switch VCC On  */
 #define PC_VCC_OFF		BIT_0       /* Switch VCC Off */
 
+/* Yukon and Genesis */
 /*	B0_ISRC			32 bit	Interrupt Source Register */
 /*	B0_IMSK			32 bit	Interrupt Mask Register */
 /*	B0_SP_ISRC		32 bit	Special Interrupt Source Reg */
 /*	B2_IRQM_MSK 	32 bit	IRQ Moderation Mask */
@@ -878,14 +1146,53 @@ extern "C" {
 #define IS_XA2_B		BIT_2		/* Q_XA2 End of Buffer */
 #define IS_XA2_F		BIT_1		/* Q_XA2 End of Frame */
 #define IS_XA2_C		BIT_0		/* Q_XA2 Encoding Error */
 
+/*						(Yukon-2)			*/
+/*	B0_ISRC			32 bit	Interrupt Source Register */
+/*	B0_IMSK			32 bit	Interrupt Mask Register */
+/*	B0_SP_ISRC		32 bit	Special Interrupt Source Reg */
+/*	B2_IRQM_MSK 	32 bit	IRQ Moderation Mask */
+/*	B0_Y2_SP_ISRC2	32 bit	Special Interrupt Source Reg 2 */
+/*	B0_Y2_SP_ISRC3	32 bit	Special Interrupt Source Reg 3 */
+/*	B0_Y2_SP_EISR	32 bit	Enter ISR Reg */
+/*	B0_Y2_SP_LISR	32 bit	Leave ISR Reg */
+#define Y2_IS_PORT_MASK(Port, Mask)	((Mask) << (Port*8))
+#define Y2_IS_HW_ERR	BIT_31		/* Interrupt HW Error */
+#define Y2_IS_STAT_BMU	BIT_30		/* Status BMU Interrupt */
+#define Y2_IS_ASF		BIT_29		/* ASF subsystem Interrupt */
+							/* Bit 28: reserved */
+#define Y2_IS_POLL_CHK	BIT_27		/* Check IRQ from polling unit */
+#define Y2_IS_TWSI_RDY	BIT_26		/* IRQ on end of TWSI Tx */
+#define Y2_IS_IRQ_SW	BIT_25		/* SW forced IRQ	*/
+#define Y2_IS_TIMINT	BIT_24		/* IRQ from Timer	*/
+							/* Bit 23..16 reserved */
+						/* Link 2 Interrupts */
+#define Y2_IS_IRQ_PHY2	BIT_12      /* Interrupt from PHY 2 */
+#define Y2_IS_IRQ_MAC2	BIT_11      /* Interrupt from MAC 2 */
+#define Y2_IS_CHK_RX2	BIT_10      /* Descriptor error Rx 2 */
+#define Y2_IS_CHK_TXS2	BIT_9       /* Descriptor error TXS 2 */
+#define Y2_IS_CHK_TXA2	BIT_8       /* Descriptor error TXA 2 */
+							/* Bit  7.. 5 reserved */
+						/* Link 1 interrupts */
+#define Y2_IS_IRQ_PHY1	BIT_4       /* Interrupt from PHY 1 */
+#define Y2_IS_IRQ_MAC1	BIT_3       /* Interrupt from MAC 1 */
+#define Y2_IS_CHK_RX1	BIT_2       /* Descriptor error Rx 1 */
+#define Y2_IS_CHK_TXS1	BIT_1       /* Descriptor error TXS 1 */
+#define Y2_IS_CHK_TXA1	BIT_0       /* Descriptor error TXA 1 */
 
+#define Y2_IS_L1_MASK	0x0000001fUL	/* IRQ Mask for port 1 */	
+
+#define Y2_IS_L2_MASK	0x00001f00UL	/* IRQ Mask for port 2 */	
+
+#define Y2_IS_ALL_MSK	0xef001f1fUL	/* All Interrupt bits */
+
+/* Yukon and Genesis */
 /*	B0_HWE_ISRC		32 bit	HW Error Interrupt Src Reg */
 /*	B0_HWE_IMSK		32 bit	HW Error Interrupt Mask Reg */
 /*	B2_IRQM_HWE_MSK	32 bit	IRQ Moderation HW Error Mask */
 #define IS_ERR_MSK		0x00000fffL	/* 		All Error bits */
-								/* Bit 31..14:	reserved */
+							/* Bit 31..14:	reserved */
 #define IS_IRQ_TIST_OV	BIT_13	/* Time Stamp Timer Overflow (YUKON only) */
 #define IS_IRQ_SENSOR	BIT_12	/* IRQ from Sensor (YUKON only) */
 #define IS_IRQ_MST_ERR	BIT_11	/* IRQ master error detected */
 #define IS_IRQ_STAT		BIT_10	/* IRQ status exception */
@@ -899,29 +1206,91 @@ extern "C" {
 #define IS_M2_PAR_ERR	BIT_2	/* MAC 2 Parity Error */
 #define IS_R1_PAR_ERR	BIT_1	/* Queue R1 Parity Error */
 #define IS_R2_PAR_ERR	BIT_0	/* Queue R2 Parity Error */
 
+						/* Yukon-2 */
+/*	B0_HWE_ISRC		32 bit	HW Error Interrupt Src Reg */
+/*	B0_HWE_IMSK		32 bit	HW Error Interrupt Mask Reg */
+/*	B2_IRQM_HWE_MSK	32 bit	IRQ Moderation HW Error Mask */
+						/* Bit: 31..30 reserved */
+#define Y2_IS_TIST_OV	BIT_29	/* Time Stamp Timer overflow interrupt */
+#define Y2_IS_SENSOR	BIT_28	/* Sensor interrupt */
+#define Y2_IS_MST_ERR	BIT_27	/* Master error interrupt */
+#define Y2_IS_IRQ_STAT	BIT_26	/* Status exception interrupt */
+#define Y2_IS_PCI_EXP	BIT_25	/* PCI-Express interrupt */
+#define Y2_IS_PCI_NEXP	BIT_24	/* PCI-Express error similar to PCI error */
+						/* Bit: 23..14 reserved */
+						/* Link 2 */
+#define Y2_IS_PAR_RD2	BIT_13	/* Read RAM parity error interrupt */
+#define Y2_IS_PAR_WR2	BIT_12	/* Write RAM parity error interrupt */
+#define Y2_IS_PAR_MAC2	BIT_11	/* MAC hardware fault interrupt */
+#define Y2_IS_PAR_RX2	BIT_10	/* Parity Error Rx Queue 2 */
+#define Y2_IS_TCP_TXS2	BIT_9	/* TCP length mismatch sync Tx queue IRQ */
+#define Y2_IS_TCP_TXA2	BIT_8	/* TCP length mismatch async Tx queue IRQ */
+						/* Bit:  9.. 6 reserved */
+						/* Link 1 */
+#define Y2_IS_PAR_RD1	BIT_5	/* Read RAM parity error interrupt */
+#define Y2_IS_PAR_WR1	BIT_4	/* Write RAM parity error interrupt */
+#define Y2_IS_PAR_MAC1	BIT_3	/* MAC hardware fault interrupt */
+#define Y2_IS_PAR_RX1	BIT_2	/* Parity Error Rx Queue 1 */
+#define Y2_IS_TCP_TXS1	BIT_1	/* TCP length mismatch sync Tx queue IRQ */
+#define Y2_IS_TCP_TXA1	BIT_0	/* TCP length mismatch async Tx queue IRQ */
+
+#define Y2_HWE_L1_MASK	(Y2_IS_PAR_RD1 | Y2_IS_PAR_WR1 | Y2_IS_PAR_MAC1 |\
+						 Y2_IS_PAR_RX1 | Y2_IS_TCP_TXS1| Y2_IS_TCP_TXA1)
+#define Y2_HWE_L2_MASK	(Y2_IS_PAR_RD2 | Y2_IS_PAR_WR2 | Y2_IS_PAR_MAC2 |\
+						 Y2_IS_PAR_RX2 | Y2_IS_TCP_TXS2| Y2_IS_TCP_TXA2)
+
+#define Y2_HWE_ALL_MSK	(Y2_IS_TIST_OV | /* Y2_IS_SENSOR | */ Y2_IS_MST_ERR |\
+						 Y2_IS_IRQ_STAT | Y2_IS_PCI_EXP | Y2_IS_PCI_NEXP |\
+						 Y2_HWE_L1_MASK | Y2_HWE_L2_MASK)
+
 /*	B2_CONN_TYP		 8 bit	Connector type */
 /*	B2_PMD_TYP		 8 bit	PMD type */
 /*	Values of connector and PMD type comply to SysKonnect internal std */
 
 /*	B2_MAC_CFG		 8 bit	MAC Configuration / Chip Revision */
 #define CFG_CHIP_R_MSK	(0xf<<4)	/* Bit 7.. 4: Chip Revision */
 									/* Bit 3.. 2:	reserved */
 #define CFG_DIS_M2_CLK	BIT_1S		/* Disable Clock for 2nd MAC */
-#define CFG_SNG_MAC		BIT_0S		/* MAC Config: 0=2 MACs / 1=1 MAC*/
+#define CFG_SNG_MAC		BIT_0S		/* MAC Config: 0 = 2 MACs; 1 = 1 MAC */
 
 /*	B2_CHIP_ID		 8 bit 	Chip Identification Number */
 #define CHIP_ID_GENESIS		0x0a	/* Chip ID for GENESIS */
 #define CHIP_ID_YUKON		0xb0	/* Chip ID for YUKON */
 #define CHIP_ID_YUKON_LITE	0xb1	/* Chip ID for YUKON-Lite (Rev. A1-A3) */
 #define CHIP_ID_YUKON_LP	0xb2	/* Chip ID for YUKON-LP */
+#define CHIP_ID_YUKON_XL	0xb3	/* Chip ID for YUKON-2 XL */
+#define CHIP_ID_YUKON_EC	0xb6	/* Chip ID for YUKON-2 EC */
+#define CHIP_ID_YUKON_FE	0xb7	/* Chip ID for YUKON-2 FE */
 
 #define CHIP_REV_YU_LITE_A1	3		/* Chip Rev. for YUKON-Lite A1,A2 */
 #define CHIP_REV_YU_LITE_A3	7		/* Chip Rev. for YUKON-Lite A3 */
 
+#define CHIP_REV_YU_EC_A1	0		/* Chip Rev. for Yukon-EC A1/A0 */
+#define CHIP_REV_YU_EC_A2	1		/* Chip Rev. for Yukon-EC A2 */
+
+/*	B2_Y2_CLK_GATE	 8 bit	Clock Gating (Yukon-2 only) */
+#define Y2_STATUS_LNK2_INAC	BIT_7S	/* Status Link 1 inactiv (0 = activ) */
+#define Y2_CLK_GAT_LNK2_DIS	BIT_6S	/* Disable clock gating Link 1 */
+#define Y2_COR_CLK_LNK2_DIS	BIT_5S	/* Disable Core clock Link 1 */
+#define Y2_PCI_CLK_LNK2_DIS	BIT_4S	/* Disable PCI clock Link 1 */
+#define Y2_STATUS_LNK1_INAC	BIT_3S	/* Status Link 1 inactiv (0 = activ) */
+#define Y2_CLK_GAT_LNK1_DIS	BIT_2S	/* Disable clock gating Link 1 */
+#define Y2_COR_CLK_LNK1_DIS	BIT_1S	/* Disable Core clock Link 1 */
+#define Y2_PCI_CLK_LNK1_DIS	BIT_0S	/* Disable PCI clock Link 1 */
+
+/*	B2_Y2_HW_RES	8 bit 	HW Resources (Yukon-2 only) */
+#define CFG_DUAL_MAC		0x03	/* dual link setting */
+#define CFG_LED_MODE_MSK	0x1C	/* LED mode mask */
+#define CFG_LED_STD_ACT		0x04	/* standard activity mode */
+#define CFG_LED_BLK_ACT		0x00	/* blink activity mode */
+
+/*	B2_E_3			 8 bit 	lower 4 bits used for HW self test result */
+#define B2_E3_RES_MASK	0x0f
+
 /*	B2_FAR			32 bit	Flash-Prom Addr Reg/Cnt */
-#define FAR_ADDR		0x1ffffL	/* Bit 16.. 0:	FPROM Address mask */
+#define FAR_ADDR		0x1ffffL	/* Bit 16.. 0:	FPROM Address Mask */
 
 /*	B2_LD_CTRL		 8 bit	EPROM loader control register */
 /*	Bits are currently reserved */
 
@@ -959,11 +1328,8 @@ extern "C" {
 								/* Bit  7.. 2:	reserved */
 #define DPT_START		BIT_1S	/* Start Descriptor Poll Timer */
 #define DPT_STOP		BIT_0S	/* Stop  Descriptor Poll Timer */
 
-/*	B2_E_3			 8 bit 	lower 4 bits used for HW self test result */
-#define B2_E3_RES_MASK	0x0f
-
 /*	B2_TST_CTRL1	 8 bit	Test Control Register 1 */
 #define TST_FRC_DPERR_MR	BIT_7S	/* force DATAPERR on MST RD */
 #define TST_FRC_DPERR_MW	BIT_6S	/* force DATAPERR on MST WR */
 #define TST_FRC_DPERR_TR	BIT_5S	/* force DATAPERR on TRG RD */
@@ -981,9 +1347,9 @@ extern "C" {
 #define TST_FRC_APERR_1M64	BIT_1S	/* AddrPERR on 1. phase */
 #define TST_FRC_APERR_2M64	BIT_0S	/* AddrPERR on 2. phase */
 
 /*	B2_GP_IO		32 bit	General Purpose I/O Register */
-							/* Bit 31..26:	reserved */
+						/* Bit 31..26:	reserved */
 #define GP_DIR_9	BIT_25	/* IO_9 direct, 0=In/1=Out */
 #define GP_DIR_8	BIT_24	/* IO_8 direct, 0=In/1=Out */
 #define GP_DIR_7	BIT_23	/* IO_7 direct, 0=In/1=Out */
 #define GP_DIR_6	BIT_22	/* IO_6 direct, 0=In/1=Out */
@@ -1031,12 +1397,10 @@ extern "C" {
 #define I2C_DATA_DIR	BIT_2S		/* direction of I2C_DATA */
 #define I2C_DATA		BIT_1S		/* I2C Data Port	*/
 #define I2C_CLK			BIT_0S		/* I2C Clock Port	*/
 
-/*
- * I2C Address
- */
-#define I2C_SENS_ADDR	LM80_ADDR	/* I2C Sensor Address, (Volt and Temp)*/
+/* I2C Address */
+#define I2C_SENS_ADDR	LM80_ADDR	/* I2C Sensor Address (Volt and Temp) */
 
 
 /*	B2_BSC_CTRL		 8 bit	Blink Source Counter Control */
 							/* Bit  7.. 2:	reserved */
@@ -1051,18 +1415,22 @@ extern "C" {
 #define BSC_T_ON	BIT_2S		/* Test mode on */
 #define BSC_T_OFF	BIT_1S		/* Test mode off */
 #define BSC_T_STEP	BIT_0S		/* Test step */
 
+/*	Y2_PEX_PHY_ADDR/DATA		PEX PHY address and data reg  (Yukon-2 only) */
+#define PEX_RD_ACCESS	BIT_31	/* Access Mode Read = 1, Write = 0 */
+#define PEX_DB_ACCESS	BIT_30	/* Access to debug register */
+
 
 /*	B3_RAM_ADDR		32 bit	RAM Address, to read or write */
 					/* Bit 31..19:	reserved */
 #define RAM_ADR_RAN	0x0007ffffL	/* Bit 18.. 0:	RAM Address Range */
 
 /* RAM Interface Registers */
-/*	B3_RI_CTRL		16 bit	RAM Iface Control Register */
+/*	B3_RI_CTRL		16 bit	RAM Interface Control Register */
 								/* Bit 15..10:	reserved */
-#define RI_CLR_RD_PERR	BIT_9S	/* Clear IRQ RAM Read Parity Err */
-#define RI_CLR_WR_PERR	BIT_8S	/* Clear IRQ RAM Write Parity Err*/
+#define RI_CLR_RD_PERR	BIT_9S	/* Clear IRQ RAM Read  Parity Err */
+#define RI_CLR_WR_PERR	BIT_8S	/* Clear IRQ RAM Write Parity Err */
 								/* Bit	7.. 2:	reserved */
 #define RI_RST_CLR		BIT_1S	/* Clear RAM Interface Reset */
 #define RI_RST_SET		BIT_0S	/* Set   RAM Interface Reset */
 
@@ -1170,9 +1538,9 @@ extern "C" {
 /*	Q_BC			32 bit	Current Byte Counter */
 								/* Bit 31..16:	reserved */
 #define BC_MAX			0xffff	/* Bit 15.. 0:	Byte counter */
 
-/* BMU Control Status Registers */
+/* BMU Control / Status Registers	(Yukon and Genesis) */
 /*	B0_R1_CSR		32 bit	BMU Ctrl/Stat Rx Queue 1 */
 /*	B0_R2_CSR		32 bit	BMU Ctrl/Stat Rx Queue 2 */
 /*	B0_XA1_CSR		32 bit	BMU Ctrl/Stat Sync Tx Queue 1 */
 /*	B0_XS1_CSR		32 bit	BMU Ctrl/Stat Async Tx Queue 1 */
@@ -1211,8 +1579,44 @@ extern "C" {
 #define CSR_CLR_RESET	(CSR_DESC_CLR | CSR_FIFO_CLR | CSR_HPI_RUN |\
 						CSR_SV_RUN | CSR_DREAD_RUN | CSR_DWRITE_RUN |\
 						CSR_TRANS_RUN)
 
+/* Rx BMU Control / Status Registers (Yukon-2) */
+#define BMU_IDLE			BIT_31	/* BMU Idle State */
+#define BMU_RX_TCP_PKT		BIT_30	/* Rx TCP Packet (when RSS Hash enabled) */
+#define BMU_RX_IP_PKT		BIT_29	/* Rx IP  Packet (when RSS Hash enabled) */
+								/* Bit 28..16:	reserved */
+#define BMU_ENA_RX_RSS_HASH	BIT_15	/* Enable  Rx RSS Hash */
+#define BMU_DIS_RX_RSS_HASH	BIT_14	/* Disable Rx RSS Hash */
+#define BMU_ENA_RX_CHKSUM	BIT_13	/* Enable  Rx TCP/IP Checksum Check */
+#define BMU_DIS_RX_CHKSUM	BIT_12	/* Disable Rx TCP/IP Checksum Check */
+#define BMU_CLR_IRQ_PAR		BIT_11	/* Clear IRQ on Parity errors (Rx) */
+#define BMU_CLR_IRQ_TCP		BIT_11	/* Clear IRQ on TCP segmen. error (Tx) */
+									
+#define BMU_CLR_IRQ_CHK		BIT_10	/* Clear IRQ Check */
+#define BMU_STOP			BIT_9   /* Stop  Rx/Tx Queue */
+#define BMU_START			BIT_8	/* Start Rx/Tx Queue */
+#define BMU_FIFO_OP_ON		BIT_7	/* FIFO Operational On */
+#define BMU_FIFO_OP_OFF 	BIT_6	/* FIFO Operational Off */
+#define BMU_FIFO_ENA		BIT_5	/* Enable FIFO */
+#define BMU_FIFO_RST		BIT_4	/* Reset  FIFO */
+#define BMU_OP_ON			BIT_3	/* BMU Operational On */
+#define BMU_OP_OFF			BIT_2	/* BMU Operational Off */
+#define BMU_RST_CLR			BIT_1	/* Clear BMU Reset (Enable) */
+#define BMU_RST_SET			BIT_0	/* Set   BMU Reset */
+
+#define BMU_CLR_RESET		(BMU_FIFO_RST | BMU_OP_OFF | BMU_RST_CLR)
+#define BMU_OPER_INIT		(BMU_CLR_IRQ_PAR | BMU_CLR_IRQ_CHK | BMU_START | \
+							BMU_FIFO_ENA | BMU_OP_ON)
+							
+/* Tx BMU Control / Status Registers (Yukon-2) */
+								/* Bit 31: same as for Rx */
+								/* Bit 30..14:	reserved */
+#define BMU_TX_IPIDINCR_ON	BIT_13	/* Enable  IP ID Increment */
+#define BMU_TX_IPIDINCR_OFF	BIT_12	/* Disable IP ID Increment */
+#define BMU_TX_CLR_IRQ_TCP	BIT_11	/* Clear IRQ on TCP segm. length mism. */
+								/* Bit 10..0: same as for Rx */
+
 /*	Q_F				32 bit	Flag Register */
 									/* Bit 31..28:	reserved */
 #define F_ALM_FULL		BIT_27		/* Rx FIFO: almost full */
 #define F_EMPTY			BIT_27		/* Tx FIFO: empty flag */
@@ -1259,8 +1663,15 @@ extern "C" {
 #define T3_MUX_MSK		(7<<4)	/* Bit  6.. 4:	Mux Position */
 								/* Bit  3:	reserved */
 #define T3_VRAM_MSK		7		/* Bit  2.. 0:	Virtual RAM Buffer Address */
 
+/* Queue Prefetch Unit Offsets, use Y2_PREF_Q_ADDR() to address (Yukon-2 only)*/
+/* PREF_UNIT_CTRL_REG	32 bit	Prefetch Control register */
+#define PREF_UNIT_OP_ON		BIT_3	/* prefetch unit operational */
+#define PREF_UNIT_OP_OFF	BIT_2	/* prefetch unit not operational */
+#define PREF_UNIT_RST_CLR	BIT_1	/* Clear Prefetch Unit Reset */
+#define PREF_UNIT_RST_SET	BIT_0	/* Set   Prefetch Unit Reset */
+
 /* RAM Buffer Register Offsets, use RB_ADDR(Queue, Offs) to access */
 /*	RB_START		32 bit	RAM Buffer Start Address */
 /*	RB_END			32 bit	RAM Buffer End Address */
 /*	RB_WP			32 bit	RAM Buffer Write Pointer */
@@ -1274,33 +1685,48 @@ extern "C" {
 				/* Bit 31..19:	reserved */
 #define RB_MSK	0x0007ffff	/* Bit 18.. 0:	RAM Buffer Pointer Bits */
 
 /*	RB_TST2			 8 bit	RAM Buffer Test Register 2 */
-								/* Bit 7.. 4:	reserved */
-#define RB_PC_DEC		BIT_3S	/* Packet Counter Decrem */
+							/* Bit 7.. 4:	reserved */
+#define RB_PC_DEC		BIT_3S	/* Packet Counter Decrement */
 #define RB_PC_T_ON		BIT_2S	/* Packet Counter Test On */
-#define RB_PC_T_OFF		BIT_1S	/* Packet Counter Tst Off */
-#define RB_PC_INC		BIT_0S	/* Packet Counter Increm */
+#define RB_PC_T_OFF		BIT_1S	/* Packet Counter Test Off */
+#define RB_PC_INC		BIT_0S	/* Packet Counter Increment */
 
 /*	RB_TST1			 8 bit	RAM Buffer Test Register 1 */
 							/* Bit 7:	reserved */
 #define RB_WP_T_ON		BIT_6S	/* Write Pointer Test On */
 #define RB_WP_T_OFF		BIT_5S	/* Write Pointer Test Off */
-#define RB_WP_INC		BIT_4S	/* Write Pointer Increm */
+#define RB_WP_INC		BIT_4S	/* Write Pointer Increment */
 								/* Bit 3:	reserved */
 #define RB_RP_T_ON		BIT_2S	/* Read Pointer Test On */
 #define RB_RP_T_OFF		BIT_1S	/* Read Pointer Test Off */
-#define RB_RP_DEC		BIT_0S	/* Read Pointer Decrement */
+#define RB_RP_INC		BIT_0S	/* Read Pointer Increment */
 
 /*	RB_CTRL			 8 bit	RAM Buffer Control Register */
-								/* Bit 7.. 6:	reserved */
+							/* Bit 7.. 6:	reserved */
 #define RB_ENA_STFWD	BIT_5S	/* Enable  Store & Forward */
 #define RB_DIS_STFWD	BIT_4S	/* Disable Store & Forward */
 #define RB_ENA_OP_MD	BIT_3S	/* Enable  Operation Mode */
 #define RB_DIS_OP_MD	BIT_2S	/* Disable Operation Mode */
 #define RB_RST_CLR		BIT_1S	/* Clear RAM Buf STM Reset */
 #define RB_RST_SET		BIT_0S	/* Set   RAM Buf STM Reset */
 
+/* Yukon-2 */
+							/* Bit 31..20:	reserved */
+#define RB_CNT_DOWN		BIT_19	/* Packet Counter Decrement */
+#define RB_CNT_TST_ON	BIT_18  /* Packet Counter Test On */
+#define RB_CNT_TST_OFF	BIT_17	/* Packet Counter Test Off */
+#define RB_CNT_UP		BIT_16	/* Packet Counter Increment */
+							/* Bit 15:	reserved */
+#define RB_WP_TST_ON	BIT_14  /* Write Pointer Test On */
+#define RB_WP_TST_OFF	BIT_13	/* Write Pointer Test Off */
+#define RB_WP_UP		BIT_12	/* Write Pointer Increment  */
+							/* Bit 11:	reserved */
+#define RB_RP_TST_ON	BIT_10  /* Read Pointer Test On */
+#define RB_RP_TST_OFF	BIT_9	/* Read Pointer Test Off */
+#define RB_RP_UP		BIT_8	/* Read Pointer Increment */
+
 
 /* Receive and Transmit MAC FIFO Registers (GENESIS only) */
 
 /*	RX_MFF_EA		32 bit	Receive MAC FIFO End Address */
@@ -1371,9 +1797,9 @@ extern "C" {
 /*	TX_MFF_TST1	 	 8 bit	Transmit MAC FIFO Test Register 1 */
 					/* Bit 7:	reserved */
 #define MFF_WP_T_ON		BIT_6S	/* Write Pointer Test On */
 #define MFF_WP_T_OFF	BIT_5S	/* Write Pointer Test Off */
-#define MFF_WP_INC		BIT_4S	/* Write Pointer Increm */
+#define MFF_WP_INC		BIT_4S	/* Write Pointer Increment */
 							/* Bit 3:	reserved */
 #define MFF_RP_T_ON		BIT_2S	/* Read Pointer Test On */
 #define MFF_RP_T_OFF	BIT_1S	/* Read Pointer Test Off */
 #define MFF_RP_DEC		BIT_0S	/* Read Pointer Decrement */
@@ -1390,14 +1816,18 @@ extern "C" {
 /*	Link LED Counter Registers (GENESIS only) */
 
 /*	RX_LED_CTRL		 8 bit	Receive LED Cnt Control Reg */
 /*	TX_LED_CTRL		 8 bit	Transmit LED Cnt Control Reg */
+							/* Bit 7.. 3:	reserved */
+#define LED_START		BIT_2S	/* Start Counter */
+#define LED_STOP		BIT_1S	/* Stop Counter */
+#define LED_STATE		BIT_0S	/* Rx/Tx: LED State, 1=LED On */
+
 /*	LNK_SYNC_CTRL	 8 bit	Link Sync Cnt Control Register */
 							/* Bit 7.. 3:	reserved */
-#define LED_START		BIT_2S	/* Start Timer */
-#define LED_STOP		BIT_1S	/* Stop Timer */
-#define LED_STATE		BIT_0S	/* Rx/Tx: LED State, 1=LED on */
-#define LED_CLR_IRQ		BIT_0S	/* Lnk: 	Clear Link IRQ */
+#define LNK_START		BIT_2S	/* Start Counter */
+#define LNK_STOP		BIT_1S	/* Stop Counter */
+#define LNK_CLR_IRQ		BIT_0S	/* Clear Link IRQ */
 
 /*	RX_LED_TST		 8 bit	Receive LED Cnt Test Register */
 /*	TX_LED_TST		 8 bit	Transmit LED Cnt Test Register */
 /*	LNK_SYNC_TST	 8 bit	Link Sync Cnt Test Register */
@@ -1406,15 +1836,15 @@ extern "C" {
 #define LED_T_OFF		BIT_1S	/* LED Counter Test mode Off */
 #define LED_T_STEP		BIT_0S	/* LED Counter Step */
 
 /*	LNK_LED_REG	 	 8 bit	Link LED Register */
-								/* Bit 7.. 6:	reserved */
+							/* Bit 7.. 6:	reserved */
 #define LED_BLK_ON		BIT_5S	/* Link LED Blinking On */
 #define LED_BLK_OFF		BIT_4S	/* Link LED Blinking Off */
 #define LED_SYNC_ON		BIT_3S	/* Use Sync Wire to switch LED */
 #define LED_SYNC_OFF	BIT_2S	/* Disable Sync Wire Input */
-#define LED_ON			BIT_1S	/* switch LED on */
-#define LED_OFF			BIT_0S	/* switch LED off */
+#define LED_ON			BIT_1S	/* Switch LED On */
+#define LED_OFF			BIT_0S	/* Switch LED Off */
 
 /*	Receive and Transmit GMAC FIFO Registers (YUKON only) */
 
 /*	RX_GMF_EA		32 bit	Rx GMAC FIFO End Address */
@@ -1432,57 +1862,108 @@ extern "C" {
 /*	TX_GMF_RSTP		32 bit 	Tx GMAC FIFO Restart Pointer */
 /*	TX_GMF_RLEV		32 bit 	Tx GMAC FIFO Read Level */
 
 /*	RX_GMF_CTRL_T	32 bit	Rx GMAC FIFO Control/Test */
-						/* Bits 31..15:	reserved */
-#define GMF_WP_TST_ON	BIT_14		/* Write Pointer Test On */
-#define GMF_WP_TST_OFF	BIT_13		/* Write Pointer Test Off */
-#define GMF_WP_STEP		BIT_12		/* Write Pointer Step/Increment */
+						/* Bit 31..28 reserved */
+#define RX_TRUNC_ON		BIT_27  /* enable  packet truncation */
+#define RX_TRUNC_OFF	BIT_26	/* disable packet truncation */
+#define RX_VLAN_STRIP_ON	BIT_25	/* enable  VLAN stripping */
+#define RX_VLAN_STRIP_OFF	BIT_24	/* disable VLAN stripping */
+						/* Bit 23..15 reserved */
+#define GMF_WP_TST_ON	BIT_14	/* Write Pointer Test On */
+#define GMF_WP_TST_OFF	BIT_13	/* Write Pointer Test Off */
+#define GMF_WP_STEP		BIT_12	/* Write Pointer Step/Increment */
 						/* Bit 11:	reserved */
-#define GMF_RP_TST_ON	BIT_10		/* Read Pointer Test On */
-#define GMF_RP_TST_OFF	BIT_9		/* Read Pointer Test Off */
-#define GMF_RP_STEP		BIT_8		/* Read Pointer Step/Increment */
-#define GMF_RX_F_FL_ON	BIT_7		/* Rx FIFO Flush Mode On */
-#define GMF_RX_F_FL_OFF	BIT_6		/* Rx FIFO Flush Mode Off */
-#define GMF_CLI_RX_FO	BIT_5		/* Clear IRQ Rx FIFO Overrun */
-#define GMF_CLI_RX_FC	BIT_4		/* Clear IRQ Rx Frame Complete */
-#define GMF_OPER_ON		BIT_3		/* Operational Mode On */
-#define GMF_OPER_OFF	BIT_2		/* Operational Mode Off */
-#define GMF_RST_CLR		BIT_1		/* Clear GMAC FIFO Reset */
-#define GMF_RST_SET		BIT_0		/* Set   GMAC FIFO Reset */
-
-/*	TX_GMF_CTRL_T	32 bit	Tx GMAC FIFO Control/Test */
-						/* Bits 31..19:	reserved */
-#define GMF_WSP_TST_ON	BIT_18		/* Write Shadow Pointer Test On */
-#define GMF_WSP_TST_OFF	BIT_17		/* Write Shadow Pointer Test Off */
-#define GMF_WSP_STEP	BIT_16		/* Write Shadow Pointer Step/Increment */
-						/* Bits 15..7: same as for RX_GMF_CTRL_T */
-#define GMF_CLI_TX_FU	BIT_6		/* Clear IRQ Tx FIFO Underrun */
-#define GMF_CLI_TX_FC	BIT_5		/* Clear IRQ Tx Frame Complete */
-#define GMF_CLI_TX_PE	BIT_4		/* Clear IRQ Tx Parity Error */
+#define GMF_RP_TST_ON	BIT_10	/* Read Pointer Test On */
+#define GMF_RP_TST_OFF	BIT_9	/* Read Pointer Test Off */
+#define GMF_RP_STEP		BIT_8	/* Read Pointer Step/Increment */
+#define GMF_RX_F_FL_ON	BIT_7	/* Rx FIFO Flush Mode On */
+#define GMF_RX_F_FL_OFF	BIT_6	/* Rx FIFO Flush Mode Off */
+#define GMF_CLI_RX_FO	BIT_5	/* Clear IRQ Rx FIFO Overrun */
+#define GMF_CLI_RX_FC	BIT_4	/* Clear IRQ Rx Frame Complete */
+#define GMF_OPER_ON		BIT_3	/* Operational Mode On */
+#define GMF_OPER_OFF	BIT_2	/* Operational Mode Off */
+#define GMF_RST_CLR		BIT_1	/* Clear GMAC FIFO Reset */
+#define GMF_RST_SET		BIT_0	/* Set   GMAC FIFO Reset */
+
+/*	TX_GMF_CTRL_T	32 bit	Tx GMAC FIFO Control/Test (YUKON and Yukon-2) */
+						/* Bits 31..26: reserved */
+#define TX_VLAN_TAG_ON	BIT_25	/* enable  VLAN tagging */
+#define TX_VLAN_TAG_OFF	BIT_24	/* disable VLAN tagging */
+						/* Bits 23..19: reserved */
+#define GMF_WSP_TST_ON	BIT_18	/* Write Shadow Pointer Test On */
+#define GMF_WSP_TST_OFF	BIT_17	/* Write Shadow Pointer Test Off */
+#define GMF_WSP_STEP	BIT_16	/* Write Shadow Pointer Step/Increment */
+						/* Bits 15..8: same as for RX_GMF_CTRL_T */
+						/* Bit 7:	reserved */
+#define GMF_CLI_TX_FU	BIT_6	/* Clear IRQ Tx FIFO Underrun */
+#define GMF_CLI_TX_FC	BIT_5	/* Clear IRQ Tx Frame Complete */
+#define GMF_CLI_TX_PE	BIT_4	/* Clear IRQ Tx Parity Error */
 						/* Bits 3..0: same as for RX_GMF_CTRL_T */
 
 #define GMF_RX_CTRL_DEF		(GMF_OPER_ON | GMF_RX_F_FL_ON)
 #define GMF_TX_CTRL_DEF		GMF_OPER_ON
 
+#define RX_GMF_AF_THR_MIN	0x0c	/* Rx GMAC FIFO Almost Full Thresh. min. */
 #define RX_GMF_FL_THR_DEF	0x0a	/* Rx GMAC FIFO Flush Threshold default */
 
 /*	GMAC_TI_ST_CTRL	 8 bit	Time Stamp Timer Ctrl Reg (YUKON only) */
-								/* Bit 7.. 3:	reserved */
-#define GMT_ST_START	BIT_2S		/* Start Time Stamp Timer */
-#define GMT_ST_STOP		BIT_1S		/* Stop  Time Stamp Timer */
-#define GMT_ST_CLR_IRQ	BIT_0S		/* Clear Time Stamp Timer IRQ */
-
+							/* Bit 7.. 3:	reserved */
+#define GMT_ST_START	BIT_2S	/* Start Time Stamp Timer */
+#define GMT_ST_STOP		BIT_1S	/* Stop  Time Stamp Timer */
+#define GMT_ST_CLR_IRQ	BIT_0S	/* Clear Time Stamp Timer IRQ */
+
+/*  POLL_CTRL		32 bit	Polling Unit control register (Yukon-2 only) */
+							/* Bit 31.. 6:	reserved */
+#define PC_CLR_IRQ_CHK	BIT_5	/* Clear IRQ Check */
+#define PC_POLL_RQ		BIT_4	/* Poll Request Start */
+#define PC_POLL_OP_ON	BIT_3	/* Operational Mode On */
+#define PC_POLL_OP_OFF	BIT_2	/* Operational Mode Off */
+#define PC_POLL_RST_CLR	BIT_1	/* Clear Polling Unit Reset (Enable) */
+#define PC_POLL_RST_SET	BIT_0	/* Set   Polling Unit Reset */
+
+
+/* The bit definition of the following registers is still missing! */
+/* B28_Y2_SMB_CONFIG		32 bit	ASF SMBus Config Register */
+/* B28_Y2_SMB_CSD_REG		32 bit	ASF SMB Control/Status/Data */
+/* B28_Y2_ASF_IRQ_V_BASE	32 bit	ASF IRQ Vector Base */
+
+/* B28_Y2_ASF_STAT_CMD		32 bit	ASF Status and Command Reg */
+/* This register is used by the host driver software */
+						/* Bit 31:5	reserved */
+#define Y2_ASF_OS_PRES	BIT_4	/* ASF operationg system present */
+#define Y2_ASF_UC_STATE (BIT_3|BIT_2)	/* ASF uC State */
+#define Y2_ASF_CLK_HALT 0		/* ASF system clock stopped */
+#define Y2_ASF_RESET	BIT_3	/* ASF system in reset state */
+#define Y2_ASF_RUNNING	BIT_2	/* ASF system operational */
+#define Y2_ASF_CLR_HSTI BIT_1	/* Clear ASF IRQ */
+#define Y2_ASF_IRQ		BIT_0	/* Issue an IRQ to ASF system */
+
+/* B28_Y2_ASF_HOST_COM	32 bit	ASF Host Communication Reg */
+/* This register is used by the ASF firmware */
+						/* Bit 31:2	reserved */
+#define Y2_ASF_CLR_ASFI BIT_1	/* Clear host IRQ */
+#define Y2_ASF_HOST_IRQ BIT_0	/* Issue an IRQ to HOST system */
+
+
+/*  STAT_CTRL		32 bit	Status BMU control register (Yukon-2 only) */
+							/* Bit  7.. 5:	reserved */
+#define SC_STAT_CLR_IRQ	BIT_4	/* Status Burst IRQ clear */
+#define SC_STAT_OP_ON	BIT_3	/* Operational Mode On */
+#define SC_STAT_OP_OFF	BIT_2	/* Operational Mode Off */
+#define SC_STAT_RST_CLR	BIT_1	/* Clear Status Unit Reset (Enable) */
+#define SC_STAT_RST_SET	BIT_0	/* Set   Status Unit Reset */
+	
 /*	GMAC_CTRL		32 bit	GMAC Control Reg (YUKON only) */
 						/* Bits 31.. 8:	reserved */
-#define GMC_H_BURST_ON	BIT_7		/* Half Duplex Burst Mode On */
-#define GMC_H_BURST_OFF	BIT_6		/* Half Duplex Burst Mode Off */
-#define GMC_F_LOOPB_ON	BIT_5		/* FIFO Loopback On */
-#define GMC_F_LOOPB_OFF	BIT_4		/* FIFO Loopback Off */
-#define GMC_PAUSE_ON	BIT_3		/* Pause On */
-#define GMC_PAUSE_OFF	BIT_2		/* Pause Off */
-#define GMC_RST_CLR		BIT_1		/* Clear GMAC Reset */
-#define GMC_RST_SET		BIT_0		/* Set   GMAC Reset */
+#define GMC_H_BURST_ON	BIT_7	/* Half Duplex Burst Mode On */
+#define GMC_H_BURST_OFF	BIT_6	/* Half Duplex Burst Mode Off */
+#define GMC_F_LOOPB_ON	BIT_5	/* FIFO Loopback On */
+#define GMC_F_LOOPB_OFF	BIT_4	/* FIFO Loopback Off */
+#define GMC_PAUSE_ON	BIT_3	/* Pause On */
+#define GMC_PAUSE_OFF	BIT_2	/* Pause Off */
+#define GMC_RST_CLR		BIT_1	/* Clear GMAC Reset */
+#define GMC_RST_SET		BIT_0	/* Set   GMAC Reset */
 
 /*	GPHY_CTRL		32 bit	GPHY Control Reg (YUKON only) */
 						/* Bits 31..29:	reserved */
 #define GPC_SEL_BDT		BIT_28	/* Select Bi-Dir. Transfer for MDC/MDIO */
@@ -1539,16 +2020,16 @@ extern "C" {
 #define GPC_PREF_SLAVE		(GPC_ANEG_1 | GPC_ANEG_0)
 
 /*	GMAC_IRQ_SRC	 8 bit	GMAC Interrupt Source Reg (YUKON only) */
 /*	GMAC_IRQ_MSK	 8 bit	GMAC Interrupt Mask   Reg (YUKON only) */
-#define GM_IS_TX_CO_OV	BIT_5		/* Transmit Counter Overflow IRQ */
-#define GM_IS_RX_CO_OV	BIT_4		/* Receive Counter Overflow IRQ */
-#define GM_IS_TX_FF_UR	BIT_3		/* Transmit FIFO Underrun */
-#define GM_IS_TX_COMPL	BIT_2		/* Frame Transmission Complete */
-#define GM_IS_RX_FF_OR	BIT_1		/* Receive FIFO Overrun */
-#define GM_IS_RX_COMPL	BIT_0		/* Frame Reception Complete */
+#define GM_IS_RX_CO_OV	BIT_5S		/* Receive Counter Overflow IRQ */
+#define GM_IS_TX_CO_OV	BIT_4S		/* Transmit Counter Overflow IRQ */
+#define GM_IS_TX_FF_UR	BIT_3S		/* Transmit FIFO Underrun */
+#define GM_IS_TX_COMPL	BIT_2S		/* Frame Transmission Complete */
+#define GM_IS_RX_FF_OR	BIT_1S		/* Receive FIFO Overrun */
+#define GM_IS_RX_COMPL	BIT_0S		/* Frame Reception Complete */
 
-#define GMAC_DEF_MSK	(GM_IS_TX_CO_OV | GM_IS_RX_CO_OV | \
+#define GMAC_DEF_MSK	(GM_IS_RX_CO_OV | GM_IS_TX_CO_OV | \
 						GM_IS_TX_FF_UR)
 
 /*	GMAC_LINK_CTRL	16 bit	GMAC Link Control Reg (YUKON only) */
 						/* Bits 15.. 2:	reserved */
@@ -1578,17 +2059,21 @@ extern "C" {
 #define WOL_CTL_DIS_PATTERN_UNIT		BIT_0S
 
 #define WOL_CTL_DEFAULT				\
 	(WOL_CTL_DIS_PME_ON_LINK_CHG |	\
-	WOL_CTL_DIS_PME_ON_PATTERN |	\
-	WOL_CTL_DIS_PME_ON_MAGIC_PKT |	\
-	WOL_CTL_DIS_LINK_CHG_UNIT |		\
-	WOL_CTL_DIS_PATTERN_UNIT |		\
-	WOL_CTL_DIS_MAGIC_PKT_UNIT)
+	 WOL_CTL_DIS_PME_ON_PATTERN |	\
+	 WOL_CTL_DIS_PME_ON_MAGIC_PKT |	\
+	 WOL_CTL_DIS_LINK_CHG_UNIT |	\
+	 WOL_CTL_DIS_PATTERN_UNIT |		\
+	 WOL_CTL_DIS_MAGIC_PKT_UNIT)
 
 /*	WOL_MATCH_CTL	 8 bit	WOL Match Control Reg */
 #define WOL_CTL_PATT_ENA(x)				(BIT_0 << (x))
 
+/*	WOL_PATT_PME	8 bit   WOL PME Match Enable (Yukon-2) */
+#define WOL_PATT_FORCE_PME				BIT_7	/* Generates a PME */
+#define WOL_PATT_MATCH_PME_ALL			0x7f
+
 #define SK_NUM_WOL_PATTERN		7
 #define SK_PATTERN_PER_WORD		4
 #define SK_BITMASK_PATTERN		7
 #define SK_POW_PATTERN_LENGTH	128
@@ -1605,19 +2090,19 @@ typedef	struct s_HwTxd {
 	SK_U32	TxNext;			/* Physical Address Pointer to the next TxD */
 	SK_U32	TxAdrLo;		/* Physical Tx Buffer Address lower dword */
 	SK_U32	TxAdrHi;		/* Physical Tx Buffer Address upper dword */
 	SK_U32	TxStat;			/* Transmit Frame Status Word */
-#ifndef	SK_USE_REV_DESC
+#ifndef SK_USE_REV_DESC
 	SK_U16	TxTcpOffs;		/* TCP Checksum Calculation Start Value */
 	SK_U16	TxRes1;			/* 16 bit reserved field */
 	SK_U16	TxTcpWp;		/* TCP Checksum Write Position */
 	SK_U16	TxTcpSp;		/* TCP Checksum Calculation Start Position */
-#else	/* SK_USE_REV_DESC */
+#else  /* SK_USE_REV_DESC */
 	SK_U16	TxRes1;			/* 16 bit reserved field */
 	SK_U16	TxTcpOffs;		/* TCP Checksum Calculation Start Value */
 	SK_U16	TxTcpSp;		/* TCP Checksum Calculation Start Position */
 	SK_U16	TxTcpWp;		/* TCP Checksum Write Position */
-#endif	/* SK_USE_REV_DESC */
+#endif /* SK_USE_REV_DESC */
 	SK_U32  TxRes2;			/* 32 bit reserved field */
 } SK_HWTXD;
 
 /* Receive Descriptor struct */
@@ -1627,31 +2112,261 @@ typedef	struct s_HwRxd {
 	SK_U32	RxAdrLo;		/* Physical Rx Buffer Address lower dword */
 	SK_U32	RxAdrHi;		/* Physical Rx Buffer Address upper dword */
 	SK_U32	RxStat;			/* Receive Frame Status Word */
 	SK_U32	RxTiSt;			/* Receive Time Stamp (from XMAC on GENESIS) */
-#ifndef	SK_USE_REV_DESC
-	SK_U16	RxTcpSum1;		/* TCP Checksum 1 */
-	SK_U16	RxTcpSum2;		/* TCP Checksum 2 */
+#ifndef SK_USE_REV_DESC
+	SK_U16	RxTcpSum1;		/* Rx TCP Checksum 1 */
+	SK_U16	RxTcpSum2;		/* Rx TCP Checksum 2 */
 	SK_U16	RxTcpSp1;		/* TCP Checksum Calculation Start Position 1 */
 	SK_U16	RxTcpSp2;		/* TCP Checksum Calculation Start Position 2 */
-#else	/* SK_USE_REV_DESC */
-	SK_U16	RxTcpSum2;		/* TCP Checksum 2 */
-	SK_U16	RxTcpSum1;		/* TCP Checksum 1 */
+#else  /* SK_USE_REV_DESC */
+	SK_U16	RxTcpSum2;		/* Rx TCP Checksum 2 */
+	SK_U16	RxTcpSum1;		/* Rx TCP Checksum 1 */
 	SK_U16	RxTcpSp2;		/* TCP Checksum Calculation Start Position 2 */
 	SK_U16	RxTcpSp1;		/* TCP Checksum Calculation Start Position 1 */
-#endif	/* SK_USE_REV_DESC */
+#endif /* SK_USE_REV_DESC */
 } SK_HWRXD;
 
 /*
  * Drivers which use the reverse descriptor feature (PCI_OUR_REG_2)
  * should set the define SK_USE_REV_DESC.
- * Structures are 'normaly' not endianess dependent. But in
- * this case the SK_U16 fields are bound to bit positions inside the
- * descriptor. RxTcpSum1 e.g. must start at bit 0 within the 6.th DWord.
+ * Structures are 'normally' not endianess dependent. But in this case
+ * the SK_U16 fields are bound to bit positions inside the descriptor.
+ * RxTcpSum1 e.g. must start at bit 0 within the 7.th DWord.
  * The bit positions inside a DWord are of course endianess dependent and
- * swaps if the DWord is swapped by the hardware.
+ * swap if the DWord is swapped by the hardware.
  */
 
+/* YUKON-2 descriptors ******************************************************/
+
+typedef struct _TxChksum {
+#ifndef SK_USE_REV_DESC
+	SK_U16	TxTcpWp;		/* TCP Checksum Write Position */
+	SK_U16	TxTcpSp;		/* TCP Checksum Calculation Start Position */
+#else  /* SK_USE_REV_DESC */
+	SK_U16	TxTcpSp;		/* TCP Checksum Calculation Start Position */
+	SK_U16	TxTcpWp;		/* TCP Checksum Write Position */
+#endif /* SK_USE_REV_DESC */
+} SK_HWTXCS;
+
+typedef struct _LargeSend {
+#ifndef SK_USE_REV_DESC
+	SK_U16 Length;		/* Large Send Segment Length */
+	SK_U16 Reserved;	/* reserved */
+#else  /* SK_USE_REV_DESC */
+	SK_U16 Reserved;	/* reserved */
+	SK_U16 Length;		/* Large Send Segment Length */
+#endif /* SK_USE_REV_DESC */
+} SK_HWTXLS;
+
+typedef union u_HwTxBuf {
+	SK_U16	BufLen;		/* Tx Buffer Length */
+	SK_U16	VlanTag;	/* VLAN Tag */
+	SK_U16	InitCsum;	/* Init. Checksum */
+} SK_HWTXBUF;
+
+/* Tx List Element structure */
+typedef struct s_HwLeTx {
+    union {
+        SK_U32	BufAddr;	/* Tx LE Buffer Address high/low */
+        SK_HWTXCS ChkSum;	/* Tx LE TCP Checksum parameters */
+		SK_HWTXLS LargeSend;/* Large Send length */
+    } TxUn;
+#ifndef SK_USE_REV_DESC
+    SK_HWTXBUF	Send;
+	SK_U8	ControlFlags;	/* Tx LE Control field or Lock Number */
+    SK_U8	Opcode;		    /* Tx LE Opcode field */
+#else  /* SK_USE_REV_DESC */
+    SK_U8	Opcode;		    /* Tx LE Opcode field */
+    SK_U8	ControlFlags;	/* Tx LE Control field or Lock Number */
+    SK_HWTXBUF	Send;
+#endif /* SK_USE_REV_DESC */
+} SK_HWLETX;
+
+typedef struct _RxChkSum{
+#ifndef SK_USE_REV_DESC
+	SK_U16	RxTcpSp1;		/* TCP Checksum Calculation Start Position 1 */
+	SK_U16	RxTcpSp2;		/* TCP Checksum Calculation Start Position 2 */
+#else  /* SK_USE_REV_DESC */
+	SK_U16	RxTcpSp2;		/* TCP Checksum Calculation Start Position 2 */
+	SK_U16	RxTcpSp1;		/* TCP Checksum Calculation Start Position 1 */
+#endif /* SK_USE_REV_DESC */
+} SK_HWRXCS;
+
+/* Rx List Element structure */
+typedef struct s_HwLeRx {
+    union {
+        SK_U32	BufAddr;	/* Rx LE Buffer Address high/low */
+        SK_HWRXCS ChkSum;	/* Rx LE TCP Checksum parameters */
+    } RxUn;
+#ifndef SK_USE_REV_DESC
+	SK_U16	BufferLength;	/* Rx LE Buffer Length field */
+    SK_U8	ControlFlags;	/* Rx LE Control field */
+    SK_U8	Opcode;		    /* Rx LE Opcode field */
+#else  /* SK_USE_REV_DESC */
+    SK_U8	Opcode;		    /* Rx LE Opcode field */
+    SK_U8	ControlFlags;	/* Rx LE Control field */
+	SK_U16	BufferLength;	/* Rx LE Buffer Length field */
+#endif /* SK_USE_REV_DESC */
+} SK_HWLERX;
+
+typedef struct s_StRxTCPChkSum {
+#ifndef SK_USE_REV_DESC
+	SK_U16	RxTCPSum1;		/* Rx TCP Checksum 1 */
+	SK_U16	RxTCPSum2;		/* Rx TCP Checksum 2 */
+#else  /* SK_USE_REV_DESC */
+	SK_U16	RxTCPSum2;		/* Rx TCP Checksum 2 */
+	SK_U16	RxTCPSum1;		/* Rx TCP Checksum 1 */
+#endif /* SK_USE_REV_DESC */
+} SK_HWSTCS;
+
+typedef struct s_StRxRssFlags {
+#ifndef SK_USE_REV_DESC
+	SK_U8	FlagField;		/* contains TCP and IP flags */
+	SK_U8	reserved;		/* reserved */
+#else  /* SK_USE_REV_DESC */
+	SK_U8	reserved;		/* reserved */
+	SK_U8	FlagField;		/* contains TCP and IP flags */
+#endif /* SK_USE_REV_DESC */
+} SK_HWSTRSS;
+
+/* bit definition of RSS LE bit 32/33 (SK_HWSTRSS.FlagField) */
+								/* bit 7..2 reserved */
+#define RSS_TCP_FLAG	BIT_1S	/* RSS value related to TCP area */
+#define RSS_IP_FLAG		BIT_0S	/* RSS value related to IP area */
+/* StRxRssValue is valid if at least RSS_IP_FLAG is set. */
+/* For protocol errors or other protocols an empty RSS LE is generated. */
+
+typedef union u_HwStBuf {
+	SK_U16	BufLen;		/* Rx Buffer Length */
+	SK_U16	VlanTag;	/* VLAN Tag */
+	SK_U16	StTxStatHi;	/* Tx Queue Status (high) */
+	SK_HWSTRSS	Rss;	/* Flag Field for TCP and IP protocol */
+} SK_HWSTBUF;
+
+/* Status List Element structure */
+typedef struct s_HwLeSt {
+    union {
+        SK_U32	StRxStatWord;	/* Rx Status Dword */
+        SK_U32	StRxTimeStamp;	/* Rx Timestamp */
+		SK_HWSTCS StRxTCPCSum;	/* Rx TCP Checksum */
+        SK_U32	StTxStatLow;	/* Tx Queue Status (low) */
+		SK_U32	StRxRssValue;	/* Rx RSS value */
+    } StUn;
+#ifndef SK_USE_REV_DESC
+    SK_HWSTBUF	Stat;
+    SK_U8	Link;			/* Status LE Link field */
+    SK_U8	Opcode;		    /* Status LE Opcode field */
+#else  /* SK_USE_REV_DESC */
+    SK_U8	Opcode;		    /* Status LE Opcode field */
+    SK_U8	Link;			/* Status LE Link field */
+    SK_HWSTBUF	Stat;
+#endif /* SK_USE_REV_DESC */
+} SK_HWLEST;
+
+/* Special Action List Element */
+typedef struct s_HwLeSa {
+#ifndef SK_USE_REV_DESC
+	SK_U16	TxAIdxVld;		/* Special Action LE TxA Put Index field */
+	SK_U16	TxSIdxVld;      /* Special Action LE TxS Put Index field */
+	SK_U16	RxIdxVld;       /* Special Action LE Rx Put Index field */
+    SK_U8	Link;			/* Special Action LE Link field */
+    SK_U8	Opcode;		    /* Special Action LE Opcode field */
+#else  /* SK_USE_REV_DESC */
+	SK_U16	TxSIdxVld;      /* Special Action LE TxS Put Index field */
+	SK_U16	TxAIdxVld;		/* Special Action LE TxA Put Index field */
+    SK_U8	Opcode;		    /* Special Action LE Opcode field */
+    SK_U8	Link;			/* Special Action LE Link field */
+	SK_U16	RxIdxVld;       /* Special Action LE Rx Put Index field */
+#endif /* SK_USE_REV_DESC */
+} SK_HWLESA;
+
+/* Common List Element union */
+typedef union u_HwLeTxRxSt {
+    /* transmit list element structure */
+    SK_HWLETX Tx;
+    /* receive list element structure */
+    SK_HWLERX Rx;
+    /* status list element structure */
+    SK_HWLEST St;
+    /* special action list element structure */
+    SK_HWLESA Sa;
+} SK_HWLE;
+
+/* mask and shift value to get tx async queue status for port 1 */
+#define STLE_TXA1_MSKL		0x00000fff
+#define STLE_TXA1_SHIFTL	0
+
+/* mask and shift value to get tx sync queue status for port 1 */
+#define STLE_TXS1_MSKL		0x00fff000
+#define STLE_TXS1_SHIFTL	12
+
+/* mask and shift value to get tx async queue status for port 2 */
+#define STLE_TXA2_MSKL		0xff000000
+#define STLE_TXA2_SHIFTL	24
+#define STLE_TXA2_MSKH		0x000f
+/* this one shifts up */
+#define STLE_TXA2_SHIFTH	8
+
+/* mask and shift value to get tx sync queue status for port 2 */
+#define STLE_TXS2_MSKL		0x00000000
+#define STLE_TXS2_SHIFTL	0
+#define STLE_TXS2_MSKH		0xfff0
+#define STLE_TXS2_SHIFTH	4
+
+/* YUKON-2  bit values */
+#define HW_OWNER        BIT_7
+#define SW_OWNER        0
+
+#define PU_PUTIDX_VALID		BIT_12
+
+/* YUKON-2  Control flags */
+#define UDPTCP          BIT_0S
+#define CALSUM          BIT_1S
+#define WR_SUM          BIT_2S
+#define INIT_SUM        BIT_3S
+#define LOCK_SUM		BIT_4S
+#define INS_VLAN		BIT_5S
+#define FRC_STAT		BIT_6S
+#define EOP				BIT_7S
+
+#define TX_LOCK			BIT_8S
+#define BUF_SEND		BIT_9S
+#define PACKET_SEND		BIT_10S
+
+#define NO_UPDATE		BIT_15S
+
+/* YUKON-2  Rx/Tx opcodes defines */
+#define	OP_TCPWRITE		0x11
+#define	OP_TCPSTART		0x12
+#define	OP_TCPINIT		0x14
+#define	OP_TCPLCK		0x18
+#define OP_TCPCHKSUM    OP_TCPSTART
+#define OP_TCPIS        (OP_TCPINIT | OP_TCPSTART)
+#define OP_TCPLW        (OP_TCPLCK | OP_TCPWRITE)
+#define OP_TCPLSW       (OP_TCPLCK | OP_TCPSTART | OP_TCPWRITE)
+#define OP_TCPLISW      (OP_TCPLCK | OP_TCPINIT | OP_TCPSTART | OP_TCPWRITE)
+#define OP_ADDR64       0x21
+#define OP_VLAN         0x22
+#define OP_ADDR64VLAN   (OP_ADDR64 | OP_VLAN)
+#define OP_LRGLEN       0x24
+#define OP_LRGLENVLAN   (OP_LRGLEN | OP_VLAN)
+#define OP_BUFFER       0x40
+#define OP_PACKET       0x41
+#define OP_LARGESEND    0x43
+
+/* YUKON-2  STATUS opcodes defines */
+#define OP_RXSTAT       0x60
+#define OP_RXTIMESTAMP  0x61
+#define OP_RXVLAN       0x62
+#define OP_RXCHKS		0x64
+#define OP_RXCHKSVLAN	( OP_RXCHKS | OP_RXVLAN )
+#define OP_RXTIMEVLAN   ( OP_RXTIMESTAMP | OP_RXVLAN )
+#define OP_RSS_HASH		0x65
+#define OP_TXINDEXLE    0x68
+
+/* YUKON-2  SPECIAL opcodes defines */
+#define OP_PUTIDX       0x70
 
 /* Descriptor Bit Definition */
 /*	TxCtrl		Transmit Buffer Control Field */
 /*	RxCtrl		Receive  Buffer Control Field */
@@ -1684,16 +2399,24 @@ typedef	struct s_HwRxd {
  */
 
 /* macros ********************************************************************/
 
+/* Macro fro accessing the key registers */
+#define RSS_KEY_ADDR(Port, KeyIndex)	\
+		((B4_RSS_KEY | ( ((Port)!=0) ? 0x80 : 0))+(KeyIndex))
+
 /* Receive and Transmit Queues */
 #define Q_R1	0x0000		/* Receive Queue 1 */
 #define Q_R2	0x0080		/* Receive Queue 2 */
 #define Q_XS1	0x0200		/* Synchronous Transmit Queue 1 */
 #define Q_XA1	0x0280		/* Asynchronous Transmit Queue 1 */
 #define Q_XS2	0x0300		/* Synchronous Transmit Queue 2 */
 #define Q_XA2	0x0380		/* Asynchronous Transmit Queue 2 */
 
+#define Q_ASF_R1	0x100	/* ASF Rx Queue 1 */
+#define Q_ASF_R2	0x180	/* ASF Rx Queue 2 */
+#define Q_ASF_T1	0x140	/* ASF Tx Queue 1 */
+#define Q_ASF_T2	0x1c0	/* ASF Tx Queue 2 */
 /*
  *	Macro Q_ADDR()
  *
  *	Use this macro to access the Receive and Transmit Queue Registers.
@@ -1703,13 +2426,29 @@ typedef	struct s_HwRxd {
  *				Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, and Q_XA2
  *	Offs	Queue register offset.
  *				Values: Q_D, Q_DA_L ... Q_T2, Q_T3
  *
- * usage	SK_IN32(pAC, Q_ADDR(Q_R2, Q_BC), pVal)
+ * usage	SK_IN32(IoC, Q_ADDR(Q_R2, Q_BC), pVal)
  */
 #define Q_ADDR(Queue, Offs)	(B8_Q_REGS + (Queue) + (Offs))
 
 /*
+ *	Macro Y2_PREF_Q_ADDR()
+ *
+ *	Use this macro to access the Prefetch Units of the receive and
+ *	transmit queues of Yukon-2.
+ *
+ * para:	
+ *	Queue	Queue to access.
+ *				Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, Q_XA2,
+ *	Offs	Queue register offset.
+ *				Values: PREF_UNIT_CTRL_REG ... PREF_UNIT_FIFO_LEV_REG
+ *
+ * usage	SK_IN16(IoC, Y2_Q_ADDR(Q_R2, PREF_UNIT_GET_IDX_REG), pVal)
+ */
+#define Y2_PREF_Q_ADDR(Queue, Offs)	(Y2_B8_PREF_REGS + (Queue) + (Offs))
+
+/*
  *	Macro RB_ADDR()
  *
  *	Use this macro to access the RAM Buffer Registers.
  *
@@ -1718,16 +2457,16 @@ typedef	struct s_HwRxd {
  *				Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, and Q_XA2
  *	Offs	Queue register offset.
  *				Values: RB_START, RB_END ... RB_LEV, RB_CTRL
  *
- * usage	SK_IN32(pAC, RB_ADDR(Q_R2, RB_RP), pVal)
+ * usage	SK_IN32(IoC, RB_ADDR(Q_R2, RB_RP), pVal)
  */
 #define RB_ADDR(Queue, Offs)	(B16_RAM_REGS + (Queue) + (Offs))
 
 
 /* MAC Related Registers */
-#define MAC_1		0	/* belongs to the port near the slot */
-#define MAC_2		1	/* belongs to the port far away from the slot */
+#define MAC_1		0	/* 1st port */
+#define MAC_2		1	/* 2nd port */
 
 /*
  *	Macro MR_ADDR()
  *
@@ -1739,20 +2478,19 @@ typedef	struct s_HwRxd {
  *	Offs	MAC register offset.
  *				Values: RX_MFF_EA, RX_MFF_WP ... LNK_LED_REG,
  *						TX_MFF_EA, TX_MFF_WP ... TX_LED_TST
  *
- * usage	SK_IN32(pAC, MR_ADDR(MAC_1, TX_MFF_EA), pVal)
+ * usage	SK_IN32(IoC, MR_ADDR(MAC_1, TX_MFF_EA), pVal)
  */
 #define MR_ADDR(Mac, Offs)	(((Mac) << 7) + (Offs))
 
-#ifdef	SK_LITTLE_ENDIAN
+#ifdef SK_LITTLE_ENDIAN
 #define XM_WORD_LO	0
 #define XM_WORD_HI	1
-#else	/* !SK_LITTLE_ENDIAN */
+#else  /* !SK_LITTLE_ENDIAN */
 #define XM_WORD_LO	1
 #define XM_WORD_HI	0
-#endif	/* !SK_LITTLE_ENDIAN */
-
+#endif /* !SK_LITTLE_ENDIAN */
 
 /*
  * macros to access the XMAC (GENESIS only)
  *
@@ -2070,14 +2808,16 @@ typedef	struct s_HwRxd {
  *
  *	Use this macro to access PCI config register from the I/O space.
  *
  * para:
+ *	pAC		Pointer to adapter context
  *	Addr	PCI configuration register to access.
  *			Values:	PCI_VENDOR_ID ... PCI_VPD_ADR_REG,
  *
- * usage	SK_IN16(pAC, PCI_C(PCI_VENDOR_ID), pVal);
+ * usage	SK_IN16(IoC, PCI_C(pAC, PCI_VENDOR_ID), pVal);
  */
-#define PCI_C(Addr)	(B7_CFG_SPC + (Addr))	/* PCI Config Space */
+#define PCI_C(p, Addr)		\
+	(((CHIP_ID_YUKON_2(p)) ? Y2_CFG_SPC : B7_CFG_SPC) + (Addr))
 
 /*
  *	Macro SK_HW_ADDR(Base, Addr)
  *
@@ -2087,9 +2827,9 @@ typedef	struct s_HwRxd {
  *	Base	I/O or memory base address
  *	Addr	Address offset
  *
  * usage:	May be used in SK_INxx and SK_OUTxx macros
- *		#define SK_IN8(pAC, Addr, pVal) ...\
+ *		#define SK_IN8(IoC, Addr, pVal) ...\
  *			*pVal = (SK_U8)inp(SK_HW_ADDR(pAC->Hw.Iop, Addr)))
  */
 #ifdef SK_MEM_MAPPED_IO
 #define SK_HW_ADDR(Base, Addr)	((Base) + (Addr))
@@ -2112,8 +2852,23 @@ typedef	struct s_HwRxd {
  */
 #define SK_HWAC_LINK_LED(pAC, IoC, Port, Mode) \
 	SK_OUT8(IoC, MR_ADDR(Port, LNK_LED_REG), Mode);
 
+#define SK_SET_GPIO(IoC, Bit) { \
+	SK_U32	DWord;				\
+	SK_IN32(IoC, B2_GP_IO, &DWord);						\
+	DWord |= ((GP_DIR_0 << (Bit)) | (GP_IO_0 << (Bit)));\
+	SK_OUT32(IoC, B2_GP_IO, DWord);						\
+}
+	
+#define SK_CLR_GPIO(IoC, Bit) { \
+	SK_U32	DWord;				\
+	SK_IN32(IoC, B2_GP_IO, &DWord);		\
+	DWord &= ~(GP_IO_0 << (Bit));		\
+	SK_OUT32(IoC, B2_GP_IO, DWord);		\
+}
+
+#define SK_GE_PCI_FIFO_SIZE		1600	/* PCI FIFO Size */
 
 /* typedefs *******************************************************************/
 
 
@@ -2123,4 +2878,5 @@ typedef	struct s_HwRxd {
 }
 #endif	/* __cplusplus */
 
 #endif	/* __INC_SKGEHW_H */
+
Index: linux-2.6.8/drivers/net/sk98lin/h/skgehwt.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skgehwt.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skgehwt.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skhwt.h
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision: 1.7 $
- * Date:	$Date: 2003/09/16 12:55:08 $
+ * Version:	$Revision: 2.1 $
+ * Date:	$Date: 2003/10/27 14:16:09 $
  * Purpose:	Defines for the hardware timer functions
  *
  ******************************************************************************/
 
Index: linux-2.6.8/drivers/net/sk98lin/h/skgei2c.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skgei2c.h
+++ /dev/null
@@ -1,210 +0,0 @@
-/******************************************************************************
- *
- * Name:	skgei2c.h
- * Project:	Gigabit Ethernet Adapters, TWSI-Module
- * Version:	$Revision: 1.25 $
- * Date:	$Date: 2003/10/20 09:06:05 $
- * Purpose:	Special defines for TWSI
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
- *	The information in this file is provided "AS IS" without warranty.
- *
- ******************************************************************************/
-
-/*
- * SKGEI2C.H	contains all SK-98xx specific defines for the TWSI handling
- */
-
-#ifndef _INC_SKGEI2C_H_
-#define _INC_SKGEI2C_H_
-
-/*
- * Macros to access the B2_I2C_CTRL
- */
-#define SK_I2C_CTL(IoC, flag, dev, dev_size, reg, burst) \
-	SK_OUT32(IoC, B2_I2C_CTRL,\
-		(flag ? 0x80000000UL : 0x0L) | \
-		(((SK_U32)reg << 16) & I2C_ADDR) | \
-		(((SK_U32)dev << 9) & I2C_DEV_SEL) | \
-		(dev_size & I2C_DEV_SIZE) | \
-		((burst << 4) & I2C_BURST_LEN))
-
-#define SK_I2C_STOP(IoC) {				\
-	SK_U32	I2cCtrl;				\
-	SK_IN32(IoC, B2_I2C_CTRL, &I2cCtrl);		\
-	SK_OUT32(IoC, B2_I2C_CTRL, I2cCtrl | I2C_STOP);	\
-}
-
-#define SK_I2C_GET_CTL(IoC, pI2cCtrl)	SK_IN32(IoC, B2_I2C_CTRL, pI2cCtrl)
-
-/*
- * Macros to access the TWSI SW Registers
- */
-#define SK_I2C_SET_BIT(IoC, SetBits) {			\
-	SK_U8	OrgBits;				\
-	SK_IN8(IoC, B2_I2C_SW, &OrgBits);		\
-	SK_OUT8(IoC, B2_I2C_SW, OrgBits | (SK_U8)(SetBits));	\
-}
-
-#define SK_I2C_CLR_BIT(IoC, ClrBits) {			\
-	SK_U8	OrgBits;				\
-	SK_IN8(IoC, B2_I2C_SW, &OrgBits);		\
-	SK_OUT8(IoC, B2_I2C_SW, OrgBits & ~((SK_U8)(ClrBits)));	\
-}
-
-#define SK_I2C_GET_SW(IoC, pI2cSw)	SK_IN8(IoC, B2_I2C_SW, pI2cSw)
-
-/*
- * define the possible sensor states
- */
-#define	SK_SEN_IDLE		0	/* Idle: sensor not read */
-#define	SK_SEN_VALUE	1	/* Value Read cycle */
-#define	SK_SEN_VALEXT	2	/* Extended Value Read cycle */
-
-/*
- * Conversion factor to convert read Voltage sensor to milli Volt
- * Conversion factor to convert read Temperature sensor to 10th degree Celsius
- */
-#define	SK_LM80_VT_LSB		22	/* 22mV LSB resolution */
-#define	SK_LM80_TEMP_LSB	10	/* 1 degree LSB resolution */
-#define	SK_LM80_TEMPEXT_LSB	 5	/* 0.5 degree LSB resolution for ext. val. */
-
-/*
- * formula: counter = (22500*60)/(rpm * divisor * pulses/2)
- * assuming: 6500rpm, 4 pulses, divisor 1
- */
-#define SK_LM80_FAN_FAKTOR	((22500L*60)/(1*2))
-
-/*
- * Define sensor management data
- * Maximum is reached on Genesis copper dual port and Yukon-64
- * Board specific maximum is in pAC->I2c.MaxSens
- */
-#define	SK_MAX_SENSORS	8	/* maximal no. of installed sensors */
-#define	SK_MIN_SENSORS	5	/* minimal no. of installed sensors */
-
-/*
- * To watch the state machine (SM) use the timer in two ways
- * instead of one as hitherto
- */
-#define	SK_TIMER_WATCH_SM		0	/* Watch the SM to finish in a spec. time */
-#define	SK_TIMER_NEW_GAUGING	1	/* Start a new gauging when timer expires */
-
-/*
- * Defines for the individual thresholds
- */
-
-/* Temperature sensor */
-#define	SK_SEN_TEMP_HIGH_ERR	800	/* Temperature High Err  Threshold */
-#define	SK_SEN_TEMP_HIGH_WARN	700	/* Temperature High Warn Threshold */
-#define	SK_SEN_TEMP_LOW_WARN	100	/* Temperature Low  Warn Threshold */
-#define	SK_SEN_TEMP_LOW_ERR		  0	/* Temperature Low  Err  Threshold */
-
-/* VCC which should be 5 V */
-#define	SK_SEN_PCI_5V_HIGH_ERR		5588	/* Voltage PCI High Err  Threshold */
-#define	SK_SEN_PCI_5V_HIGH_WARN		5346	/* Voltage PCI High Warn Threshold */
-#define	SK_SEN_PCI_5V_LOW_WARN		4664	/* Voltage PCI Low  Warn Threshold */
-#define	SK_SEN_PCI_5V_LOW_ERR		4422	/* Voltage PCI Low  Err  Threshold */
-
-/*
- * VIO may be 5 V or 3.3 V. Initialization takes two parts:
- * 1. Initialize lowest lower limit and highest higher limit.
- * 2. After the first value is read correct the upper or the lower limit to
- *    the appropriate C constant.
- *
- * Warning limits are +-5% of the exepected voltage.
- * Error limits are +-10% of the expected voltage.
- */
-
-/* Bug fix AF: 16.Aug.2001: Correct the init base of LM80 sensor */
-
-#define	SK_SEN_PCI_IO_5V_HIGH_ERR	5566	/* + 10% V PCI-IO High Err Threshold */
-#define	SK_SEN_PCI_IO_5V_HIGH_WARN	5324	/* +  5% V PCI-IO High Warn Threshold */
-					/*		5000	mVolt */
-#define	SK_SEN_PCI_IO_5V_LOW_WARN	4686	/* -  5% V PCI-IO Low Warn Threshold */
-#define	SK_SEN_PCI_IO_5V_LOW_ERR	4444	/* - 10% V PCI-IO Low Err Threshold */
-
-#define	SK_SEN_PCI_IO_RANGE_LIMITER	4000	/* 4000 mV range delimiter */
-
-/* correction values for the second pass */
-#define	SK_SEN_PCI_IO_3V3_HIGH_ERR	3850	/* + 15% V PCI-IO High Err Threshold */
-#define	SK_SEN_PCI_IO_3V3_HIGH_WARN	3674	/* + 10% V PCI-IO High Warn Threshold */
-					/*		3300	mVolt */
-#define	SK_SEN_PCI_IO_3V3_LOW_WARN	2926	/* - 10% V PCI-IO Low Warn Threshold */
-#define	SK_SEN_PCI_IO_3V3_LOW_ERR	2772	/* - 15% V PCI-IO Low Err  Threshold */
-
-/*
- * VDD voltage
- */
-#define	SK_SEN_VDD_HIGH_ERR		3630	/* Voltage ASIC High Err  Threshold */
-#define	SK_SEN_VDD_HIGH_WARN	3476	/* Voltage ASIC High Warn Threshold */
-#define	SK_SEN_VDD_LOW_WARN		3146	/* Voltage ASIC Low  Warn Threshold */
-#define	SK_SEN_VDD_LOW_ERR		2970	/* Voltage ASIC Low  Err  Threshold */
-
-/*
- * PHY PLL 3V3 voltage
- */
-#define	SK_SEN_PLL_3V3_HIGH_ERR		3630	/* Voltage PMA High Err  Threshold */
-#define	SK_SEN_PLL_3V3_HIGH_WARN	3476	/* Voltage PMA High Warn Threshold */
-#define	SK_SEN_PLL_3V3_LOW_WARN		3146	/* Voltage PMA Low  Warn Threshold */
-#define	SK_SEN_PLL_3V3_LOW_ERR		2970	/* Voltage PMA Low  Err  Threshold */
-
-/*
- * VAUX (YUKON only)
- */
-#define	SK_SEN_VAUX_3V3_HIGH_ERR	3630	/* Voltage VAUX High Err Threshold */
-#define	SK_SEN_VAUX_3V3_HIGH_WARN	3476	/* Voltage VAUX High Warn Threshold */
-#define	SK_SEN_VAUX_3V3_LOW_WARN	3146	/* Voltage VAUX Low Warn Threshold */
-#define	SK_SEN_VAUX_3V3_LOW_ERR		2970	/* Voltage VAUX Low Err Threshold */
-#define	SK_SEN_VAUX_0V_WARN_ERR		   0	/* if VAUX not present */
-#define	SK_SEN_VAUX_RANGE_LIMITER	1000	/* 1000 mV range delimiter */
-
-/*
- * PHY 2V5 voltage
- */
-#define	SK_SEN_PHY_2V5_HIGH_ERR		2750	/* Voltage PHY High Err Threshold */
-#define	SK_SEN_PHY_2V5_HIGH_WARN	2640	/* Voltage PHY High Warn Threshold */
-#define	SK_SEN_PHY_2V5_LOW_WARN		2376	/* Voltage PHY Low Warn Threshold */
-#define	SK_SEN_PHY_2V5_LOW_ERR		2222	/* Voltage PHY Low Err Threshold */
-
-/*
- * ASIC Core 1V5 voltage (YUKON only)
- */
-#define	SK_SEN_CORE_1V5_HIGH_ERR	1650	/* Voltage ASIC Core High Err Threshold */
-#define	SK_SEN_CORE_1V5_HIGH_WARN	1575	/* Voltage ASIC Core High Warn Threshold */
-#define	SK_SEN_CORE_1V5_LOW_WARN	1425	/* Voltage ASIC Core Low Warn Threshold */
-#define	SK_SEN_CORE_1V5_LOW_ERR 	1350	/* Voltage ASIC Core Low Err Threshold */
-
-/*
- * FAN 1 speed
- */
-/* assuming: 6500rpm +-15%, 4 pulses,
- * warning at:	80 %
- * error at:	70 %
- * no upper limit
- */
-#define	SK_SEN_FAN_HIGH_ERR		20000	/* FAN Speed High Err Threshold */
-#define	SK_SEN_FAN_HIGH_WARN	20000	/* FAN Speed High Warn Threshold */
-#define	SK_SEN_FAN_LOW_WARN		 5200	/* FAN Speed Low Warn Threshold */
-#define	SK_SEN_FAN_LOW_ERR		 4550	/* FAN Speed Low Err Threshold */
-
-/*
- * Some Voltages need dynamic thresholds
- */
-#define	SK_SEN_DYN_INIT_NONE		 0  /* No dynamic init of thresholds */
-#define	SK_SEN_DYN_INIT_PCI_IO		10  /* Init PCI-IO with new thresholds */
-#define	SK_SEN_DYN_INIT_VAUX		11  /* Init VAUX with new thresholds */
-
-extern	int SkLm80ReadSensor(SK_AC *pAC, SK_IOC IoC, SK_SENSOR *pSen);
-#endif	/* n_INC_SKGEI2C_H */
Index: linux-2.6.8/drivers/net/sk98lin/h/skgeinit.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skgeinit.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skgeinit.h
@@ -1,24 +1,23 @@
 /******************************************************************************
  *
  * Name:	skgeinit.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.83 $
- * Date:	$Date: 2003/09/16 14:07:37 $
+ * Version:	$Revision: 2.28 $
+ * Date:	$Date: 2004/06/15 14:23:14 $
  * Purpose:	Structures and prototypes for the GE Init Module
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
@@ -59,16 +58,18 @@ extern "C" {
 /* Counter and Timer constants, for a host clock of 62.5 MHz */
 #define SK_XMIT_DUR		0x002faf08UL	/*  50 ms */
 #define SK_BLK_DUR		0x01dcd650UL	/* 500 ms */
 
-#define SK_DPOLL_DEF	0x00ee6b28UL	/* 250 ms at 62.5 MHz */
+#define SK_DPOLL_DEF	0x00ee6b28UL	/* 250 ms at 62.5 MHz (Genesis) */
+#define SK_DPOLL_DEF_Y2	0x0000124fUL	/*  75 us (Yukon-2) */
 
 #define SK_DPOLL_MAX	0x00ffffffUL	/* 268 ms at 62.5 MHz */
-										/* 215 ms at 78.12 MHz */
+										/* 215 ms at 78.12 MHz (Yukon) */
 
 #define SK_FACT_62		100			/* is given in percent */
 #define SK_FACT_53		 85         /* on GENESIS:	53.12 MHz */
 #define SK_FACT_78		125			/* on YUKON:	78.12 MHz */
+#define SK_FACT_125		202			/* on YUKON-EC:	125 MHz */
 
 /* Timeout values */
 #define SK_MAC_TO_53	72			/* MAC arbiter timeout */
 #define SK_PKT_TO_53	0x2000		/* Packet arbiter timeout */
@@ -82,12 +83,18 @@ extern "C" {
 #define SK_RB_LLPP_S	(10 * 1024)	/* Lower Level for small Queues */
 #define SK_RB_LLPP_B	(16 * 1024)	/* Lower Level for big Queues */
 
 #ifndef SK_BMU_RX_WM
-#define SK_BMU_RX_WM	0x600		/* BMU Rx Watermark */
+#define SK_BMU_RX_WM		0x600	/* BMU Rx Watermark */
 #endif
+
 #ifndef SK_BMU_TX_WM
-#define SK_BMU_TX_WM	0x600		/* BMU Tx Watermark */
+#define SK_BMU_TX_WM		0x600	/* BMU Tx Watermark */
+#endif
+
+/* performance sensitive drivers should set this define to 0x80 */
+#ifndef SK_BMU_RX_WM_PEX
+#define SK_BMU_RX_WM_PEX	0x600	/* BMU Rx Watermark for PEX */
 #endif
 
 /* XMAC II Rx High Watermark */
 #define SK_XM_RX_HI_WM	0x05aa		/* 1450 */
@@ -103,33 +110,27 @@ extern "C" {
 #define SK_MUL_LINK		2		/* multiple link usage */
 #define SK_JUMBO_LINK	3		/* driver uses jumbo frames */
 
 /* Minimum RAM Buffer Rx Queue Size */
-#define SK_MIN_RXQ_SIZE	16		/* 16 kB */
+#define SK_MIN_RXQ_SIZE	(((pAC)->GIni.GIYukon2) ? 10 : 16)		/* 10/16 kB */
 
 /* Minimum RAM Buffer Tx Queue Size */
-#define SK_MIN_TXQ_SIZE	16		/* 16 kB */
+#define SK_MIN_TXQ_SIZE	(((pAC)->GIni.GIYukon2) ? 10 : 16)		/* 10/16 kB */
 
-/* Queue Size units */
-#define QZ_UNITS		0x7
+/* Queue Size units (Genesis/Yukon) */
+#define QZ_UNITS		7
 #define QZ_STEP			8
 
+/* Queue Size units (Yukon-2) */
+#define QZ_STEP_Y2		1
+
 /* Percentage of queue size from whole memory */
 /* 80 % for receive */
-#define RAM_QUOTA_RX	80L
+#define RAM_QUOTA_RX	80
 /* 0% for sync transfer */
-#define	RAM_QUOTA_SYNC	0L
+#define	RAM_QUOTA_SYNC	0
 /* the rest (20%) is taken for async transfer */
 
-/* Get the rounded queue size in Bytes in 8k steps */
-#define ROUND_QUEUE_SIZE(SizeInBytes)					\
-	((((unsigned long) (SizeInBytes) + (QZ_STEP*1024L)-1) / 1024) &	\
-	~(QZ_STEP-1))
-
-/* Get the rounded queue size in KBytes in 8k steps */
-#define ROUND_QUEUE_SIZE_KB(Kilobytes) \
-	ROUND_QUEUE_SIZE((Kilobytes) * 1024L)
-
 /* Types of RAM Buffer Queues */
 #define SK_RX_SRAM_Q	1	/* small receive queue */
 #define SK_RX_BRAM_Q	2	/* big receive queue */
 #define SK_TX_RAM_Q		3	/* small or big transmit queue */
@@ -265,12 +266,17 @@ extern "C" {
 #define SK_PRT_RUN		3	/* the port has an active link */
 
 /* PHY power down modes */
 #define PHY_PM_OPERATIONAL_MODE		0	/* PHY operational mode */
-#define PHY_PM_DEEP_SLEEP			1	/* coma mode --> minimal power */
+#define PHY_PM_DEEP_SLEEP			1	/* Coma mode --> minimal power */
 #define PHY_PM_IEEE_POWER_DOWN		2	/* IEEE 22.2.4.1.5 compl. power down */
-#define PHY_PM_ENERGY_DETECT		3	/* energy detect */
-#define PHY_PM_ENERGY_DETECT_PLUS	4	/* energy detect plus */
+#define PHY_PM_ENERGY_DETECT		3	/* Energy detect */
+#define PHY_PM_ENERGY_DETECT_PLUS	4	/* Energy detect plus */
+
+/* PCI Bus Types */
+#define SK_PCI_BUS		0x0001		/* normal PCI bus */
+#define SK_PCIX_BUS		0x0002      /* PCI-X bus */
+#define SK_PEX_BUS		0x0004      /* PCI-Express bus */
 
 /* Default receive frame limit for Workaround of XMAC Errata */
 #define SK_DEF_RX_WA_LIM	SK_CONSTU64(100)
 
@@ -289,20 +295,157 @@ extern "C" {
 
 /* Max. Auto-neg. timeouts before link detection in sense mode is reset */
 #define SK_MAX_ANEG_TO	10	/* Max. 10 times the sense mode is reset */
 
+
+/******************************************************************************
+ *
+ * HW_FEATURE() macro
+ */
+
+/* DWORD 0: Features */
+#define HWF_SYNC_TX_SUP			0x00800000UL	/* synch tx queue available */
+#define HWF_SINGLE_PORT_DEVICE	0x00400000UL	/* device has only one LAN IF */
+#define HWF_JUMBO_FRAMES_SUP	0x00200000UL	/* Jumbo frames supported */
+#define HWF_TX_TCP_CSUM_SUP		0x00100000UL	/* TCP tx checksum supported */
+#define HWF_TX_UDP_CSUM_SUP		0x00080000UL	/* UDP tx checksum supported */
+#define HWF_RX_CSUM_SUP			0x00040000UL	/* RX checksum supported */
+#define HWF_TCP_SEGM_SUP		0x00020000UL	/* TCP segmentation supported */
+#define HWF_RSS_HASH_SUP		0x00010000UL	/* RSS Hash supported */
+#define HWF_PORT_VLAN_SUP		0x00008000UL	/* VLAN can be config per port*/
+#define HWF_ROLE_PARAM_SUP		0x00004000UL	/* Role parameter supported */
+#define HWF_LOW_PMODE_SUP		0x00002000UL	/* Low Power Mode supported */
+#define HWF_ENERGIE_DEMO_SUP	0x00001000UL	/* Energie detect mode supp. */
+#define HWF_SPEED1000_SUP		0x00000800UL	/* Line Speed 1000 supported */
+#define HWF_SPEED100_SUP		0x00000400UL	/* Line Speed 100 supported */
+#define HWF_SPEED10_SUP			0x00000200UL	/* Line Speed 10 supported */
+#define HWF_AUTONEGSENSE_SUP	0x00000100UL	/* Autoneg Sense supported */
+#define HWF_PHY_LOOPB_MD_SUP	0x00000080UL	/* PHY loopback mode supp. */
+#define HWF_ASF_SUP				0x00000040UL	/* ASF support possible */
+#define HWF_QS_STEPS_1kB		0x00000020UL	/* The rx/tx queues can be */
+												/* configured in units of 1 kB*/
+#define HWF_OWN_RAM_PER_PORT	0x00000010UL	/* Each port has a separate */
+												/* RAM buffer */
+#define HWF_MIN_LED_IF			0x00000008UL	/* Minimal LED interface */
+												/* (e.g. for Yukon-EC) */
+#define HWF_LIST_ELEMENTS_USED	0x00000004UL	/* HW uses list elements */
+												/* (otherwise desc. are used) */
+#define HWF_GMAC_INSIDE			0x00000002UL	/* device contains GMAC */
+#define HWF_TWSI_PRESENT		0x00000001UL	/* TWSI sensor bus present */
+
+/*-RMV- DWORD 1: Deviations */
+#define HWF_WA_DEV_427			0x10000400UL	/*-RMV- 4.27 (Tx Done Rep) */
+#define HWF_WA_DEV_42			0x10000200UL	/*-RMV- 4.2 (pref unit burst)*/
+#define HWF_WA_DEV_46			0x10000100UL	/*-RMV- 4.6 (CPU crash II) */
+#define HWF_WA_DEV_43_418		0x10000080UL	/*-RMV- 4.3 & 4.18 (PCI unexp */
+												/*-RMV- compl&Stat BMU deadl) */
+#define HWF_WA_DEV_420			0x10000040UL	/*-RMV- 4.20 (Status BMU ov) */
+#define HWF_WA_DEV_423			0x10000020UL	/*-RMV- 4.23 (TCP Segm Hang) */
+#define HWF_WA_DEV_424			0x10000010UL	/*-RMV- 4.24 (MAC reg over wr)*/
+#define HWF_WA_DEV_425			0x10000008UL	/*-RMV- 4.25 (Magic packet */
+												/*-RMV- with odd offset) */
+#define HWF_WA_DEV_428			0x10000004UL	/*-RMV- 4.28 (Poll-U &BigEndi)*/
+#define HWF_WA_FIFO_FLUSH_YLA0	0x10000002UL	/*-RMV- dis Rx GMAC FIFO Flush*/
+												/*-RMV- for Yu-L Rev. A0 only */
+#define HWF_WA_COMA_MODE		0x10000001UL	/*-RMV- Coma Mode WA req */
+
+/* DWORD 2: still unused */
+/* DWORD 3: still unused */
+
+
+/*
+ * HW_FEATURE()	-	returns whether the feature is serviced or not
+ */
+#define HW_FEATURE(pAC, ReqFeature) \
+	(((pAC)->GIni.HwF.Features[((ReqFeature) & 0x30000000UL) >> 28] &\
+	 ((ReqFeature) & 0x0fffffffUL)) != 0)
+
+#define HW_FEAT_LIST	0
+#define HW_DEV_LIST		1
+
+#define SET_HW_FEATURE_MASK(pAC, List, OffMaskValue, OnMaskValue) {	\
+	if ((List) == HW_FEAT_LIST || (List) == HW_DEV_LIST) {			\
+		(pAC)->GIni.HwF.OffMask[List] = (OffMaskValue);				\
+		(pAC)->GIni.HwF.OnMask[List] = (OnMaskValue);				\
+	}																\
+}
+
+/* driver access macros for GIni structure ***********************************/
+
+#define CHIP_ID_YUKON_2(pAC)		((pAC)->GIni.GIYukon2)
+#define HW_SYNC_TX_SUPPORTED(pAC)						\
+		((pAC)->GIni.GIChipId != CHIP_ID_YUKON_EC &&	\
+		 (pAC)->GIni.GIChipId != CHIP_ID_YUKON_FE)
+
+#define HW_MS_TO_TICKS(pAC, MsTime) \
+	((MsTime) * (62500L/100) * (pAC)->GIni.GIHstClkFact)
+
+#if 0
+/* still under construction */
+/* klammern ( ) */
+#define HW_IS_SINGLE_PORT(pAC)		((pAC)->GIni.GIMacsFound == 1)
+#define HW_NUMBER_OF_PORTS(pAC)		((pAC)->GIni.GIMacsFound)
+
+#define HW_TX_UDP_CSUM_SUPPORTED(pAC) \
+	((((pAC)->GIni.GIChipId >= CHIP_ID_YUKON) && ((pAC)->GIni.GIChipRev != 0))
+
+#define HW_DEFAULT_LINESPEED(pAC)	\
+	((!(pAC)->GIni.GIGenesis && (pAC)->GIni.GICopperType) ? \
+	SK_LSPEED_AUTO : SK_LSPEED_1000MBPS)
+
+#define HW_ROLE_PARAM_SUPPORTED(pAC)	(pAC)->GIni.GICopperType
+#define HW_SPEED1000_SUPPORTED(pAC)		(SK_TRUE) /* falsch, Y-EC 10/100 */
+#define HW_SPEED100_SUPPORTED(pAC)		(pAC)->GIni.GICopperType
+#define HW_SPEED10_SUPPORTED(pAC)		(pAC)->GIni.GICopperType
+#define HW_AUTONEGSENSE_SUPPORTED(pAC)  ((pAC)->GIni.GP[0].PhyType==SK_PHY_XMAC)
+
+#define HW_FREQ_TO_CARD_TICKS(pAC, AdapterClkSpeed, Freq) \
+	(((AdapterClkSpeed / 100) * (pAC)->GIni.GIHstClkFact) / Freq)
+
+#define HW_IS_LINK_UP(pAC, Port)		(pAC)->GIni.GP[Port].PHWLinkUp	
+#define HW_GET_LINK_SPEED_USED(pAC, Port) (pAC)->GIni.GP[Port].PLinkSpeedUsed
+#define HW_GET_RAM_SIZE(pAC, RAM_SELECT) /* falsch, nicht a chip ID fest machen */
+	(CHIP_ID_YUKON_2(pAC) ? (pAC)->GIni.GIRamSize : (pAC)->GIni.GIRamSize)
+
+#define HW_ENA_JUMBO_FRAME_SUPPORT(pAC) (pAC)->GIni.GIPortUsage = SK_JUMBO_LINK
+#define HW_DIS_JUMBO_FRAME_SUPPORT(pAC) (pAC)->GIni.GIPortUsage = ????
+#define HW_PHY_LP_MODE_SUPPORTED(pAC)	(pAC0->???
+#define HW_ASF_ACTIVE(pAC)				???
+#define RAWIO_OUT32(pAC, pAC->RegIrqMask, pAC->GIni.GIValIrqMask)...
+
+/* macro to check whether tx csum is supported */
+#define HW_TX_CSUM_SUPPORTED(pAC)	((pAC)->GIni.GIChipId != CHIP_ID_GENESIS)
+
+BMU_UDP_CHECK : BMU_TCP_CHECK;
+
+/* macro for - Own Bit mirrored to DWORD7 (Yukon LP receive descriptor) */
+#endif /* 0 */
+
+
 /* structures *****************************************************************/
 
 /*
+ * HW Feature structure
+ */
+typedef struct s_HwFeatures {
+	SK_U32	Features[4];	/* Feature list */
+	SK_U32	OffMask[4];		/* Off Mask */
+	SK_U32	OnMask[4];		/* On Mask */
+} SK_HW_FEATURES;
+
+/*
  * MAC specific functions
  */
 typedef struct s_GeMacFunc {
-	int  (*pFnMacUpdateStats)(SK_AC *pAC, SK_IOC IoC, unsigned int Port);
-	int  (*pFnMacStatistic)(SK_AC *pAC, SK_IOC IoC, unsigned int Port,
-							SK_U16 StatAddr, SK_U32 SK_FAR *pVal);
-	int  (*pFnMacResetCounter)(SK_AC *pAC, SK_IOC IoC, unsigned int Port);
-	int  (*pFnMacOverflow)(SK_AC *pAC, SK_IOC IoC, unsigned int Port,
-						   SK_U16 IStatus, SK_U64 SK_FAR *pVal);
+	int	(*pFnMacUpdateStats)(SK_AC *, SK_IOC, unsigned int);
+	int	(*pFnMacStatistic)(SK_AC *, SK_IOC, unsigned int, SK_U16, SK_U32 SK_FAR *);
+	int	(*pFnMacResetCounter)(SK_AC *, SK_IOC, unsigned int);
+	int	(*pFnMacOverflow)(SK_AC *, SK_IOC, unsigned int, SK_U16, SK_U64 SK_FAR *);
+	void (*pSkGeSirqIsr)(SK_AC *, SK_IOC, SK_U32);
+#ifdef SK_DIAG
+	int	(*pFnMacPhyRead)(SK_AC *, SK_IOC, int, int, SK_U16 SK_FAR *);
+	int	(*pFnMacPhyWrite)(SK_AC *, SK_IOC, int, int, SK_U16);
+#endif /* SK_DIAG */
 } SK_GEMACFUNC;
 
 /*
  * Port Structure
@@ -310,9 +453,9 @@ typedef struct s_GeMacFunc {
 typedef	struct s_GePort {
 #ifndef SK_DIAG
 	SK_TIMER	PWaTimer;	/* Workaround Timer */
 	SK_TIMER	HalfDupChkTimer;
-#endif /* SK_DIAG */
+#endif /* !SK_DIAG */
 	SK_U32	PPrevShorts;	/* Previous Short Counter checking */
 	SK_U32	PPrevFcs;		/* Previous FCS Error Counter checking */
 	SK_U64	PPrevRx;		/* Previous RxOk Counter checking */
 	SK_U64	PRxLim;			/* Previous RxOk Counter checking */
@@ -366,8 +509,9 @@ typedef	struct s_GePort {
 	int		PMacColThres;	/* MAC Collision Threshold */
 	int		PMacJamLen;		/* MAC Jam length */
 	int		PMacJamIpgVal;	/* MAC Jam IPG */
 	int		PMacJamIpgData;	/* MAC IPG Jam to Data */
+	int		PMacDataBlind;	/* MAC Data Blinder */
 	int		PMacIpgData;	/* MAC Data IPG */
 	SK_BOOL PMacLimit4;		/* reset collision counter and backoff algorithm */
 } SK_GEPORT;
 
@@ -378,29 +522,37 @@ typedef	struct s_GePort {
 typedef	struct s_GeInit {
 	int			GIChipId;		/* Chip Identification Number */
 	int			GIChipRev;		/* Chip Revision Number */
 	SK_U8		GIPciHwRev;		/* PCI HW Revision Number */
+	SK_U8		GIPciBus;		/* PCI Bus Type (PCI / PCIX / PEX)*/
 	SK_BOOL		GIGenesis;		/* Genesis adapter ? */
-	SK_BOOL		GIYukon;		/* YUKON-A1/Bx chip */
+	SK_BOOL		GIYukon;		/* YUKON family (1 and 2) */
 	SK_BOOL		GIYukonLite;	/* YUKON-Lite chip */
+	SK_BOOL		GIYukon2;		/* YUKON-2 or YUKON-EC chip */
+	SK_U8		GIConTyp;		/* Connector Type */
+	SK_U8		GIPmdTyp;		/* PMD Type */
 	SK_BOOL		GICopperType;	/* Copper Type adapter ? */
 	SK_BOOL		GIPciSlot64;	/* 64-bit PCI Slot */
 	SK_BOOL		GIPciClock66;	/* 66 MHz PCI Clock */
 	SK_BOOL		GIVauxAvail;	/* VAUX available (YUKON) */
 	SK_BOOL		GIYukon32Bit;	/* 32-Bit YUKON adapter */
+	SK_BOOL		GIAsfEnabled;	/* ASF subsystem enabled */
 	SK_U16		GILedBlinkCtrl;	/* LED Blink Control */
 	int			GIMacsFound;	/* Number of MACs found on this adapter */
 	int			GIMacType;		/* MAC Type used on this adapter */
-	int			GIHstClkFact;	/* Host Clock Factor (62.5 / HstClk * 100) */
+	int			GIChipCap;		/* Adapter's Capabilities */
+	int			GIHstClkFact;	/* Host Clock Factor (HstClk / 62.5 * 100) */
 	int			GIPortUsage;	/* Driver Port Usage */
 	int			GILevel;		/* Initialization Level completed */
 	int			GIRamSize;		/* The RAM size of the adapter in kB */
 	int			GIWolOffs;		/* WOL Register Offset (HW-Bug in Rev. A) */
 	SK_U32		GIRamOffs;		/* RAM Address Offset for addr calculation */
 	SK_U32		GIPollTimerVal;	/* Descr. Poll Timer Init Val (HstClk ticks) */
 	SK_U32		GIValIrqMask;	/* Value for Interrupt Mask */
+	SK_U32		GIValHwIrqMask;	/* Value for Interrupt Mask */
 	SK_U32		GITimeStampCnt;	/* Time Stamp High Counter (YUKON only) */
 	SK_GEPORT	GP[SK_MAX_MACS];/* Port Dependent Information */
+	SK_HW_FEATURES HwF;			/* HW Features struct */
 	SK_GEMACFUNC GIFunc;		/* MAC depedent functions */
 } SK_GEINIT;
 
 /*
@@ -463,8 +615,26 @@ typedef	struct s_GeInit {
 
 /*
  * public functions in skgeinit.c
  */
+extern void SkGePortVlan(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_BOOL Enable);
+
+extern void SkGeRxRss(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_BOOL	Enable);
+
+extern void SkGeRxCsum(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_BOOL Enable);
+
 extern void	SkGePollRxD(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	int		Port,
@@ -623,30 +793,30 @@ extern void	SkMacHashing(
 	SK_IOC	IoC,
 	int		Port,
 	SK_BOOL	Enable);
 
-extern void	SkXmPhyRead(
+extern int	SkXmPhyRead(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	int		Port,
 	int		Addr,
 	SK_U16	SK_FAR *pVal);
 
-extern void	SkXmPhyWrite(
+extern int	SkXmPhyWrite(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	int		Port,
 	int		Addr,
 	SK_U16	Val);
 
-extern void	SkGmPhyRead(
+extern int	SkGmPhyRead(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	int		Port,
 	int		Addr,
 	SK_U16	SK_FAR *pVal);
 
-extern void	SkGmPhyWrite(
+extern int	SkGmPhyWrite(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	int		Port,
 	int		Addr,
@@ -793,8 +963,11 @@ extern void	SkGeDeInit();
 extern int	SkGeInitPort();
 extern void	SkGeXmitLED();
 extern void	SkGeInitRamIface();
 extern int	SkGeInitAssignRamToQueues();
+extern void SkGePortVlan();
+extern void SkGeRxCsum();
+extern void SkGeRxRss();
 
 /*
  * public functions in skxmac2.c
  */
@@ -813,13 +986,13 @@ extern void	SkMacIrq();
 extern int	SkMacAutoNegDone();
 extern void	SkMacAutoNegLipaPhy();
 extern void SkMacSetRxTxEn();
 extern void	SkXmInitMac();
-extern void	SkXmPhyRead();
-extern void	SkXmPhyWrite();
+extern int	SkXmPhyRead();
+extern int	SkXmPhyWrite();
 extern void	SkGmInitMac();
-extern void	SkGmPhyRead();
-extern void	SkGmPhyWrite();
+extern int	SkGmPhyRead();
+extern int	SkGmPhyWrite();
 extern void	SkXmClrExactAddr();
 extern void	SkXmInitDupMd();
 extern void	SkXmInitPauseMd();
 extern void	SkXmAutoNegLipaXmac();
@@ -843,11 +1016,12 @@ extern void	SkMacCrcGener();
 extern void	SkMacTimeStamp();
 extern void	SkXmSendCont();
 #endif /* SK_DIAG */
 
-#endif	/* SK_KR_PROTO */
+#endif /* SK_KR_PROTO */
 
 #ifdef __cplusplus
 }
 #endif	/* __cplusplus */
 
 #endif	/* __INC_SKGEINIT_H_ */
+
Index: linux-2.6.8/drivers/net/sk98lin/h/skgepnm2.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skgepnm2.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skgepnm2.h
@@ -1,10 +1,10 @@
 /*****************************************************************************
  *
  * Name:	skgepnm2.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.36 $
- * Date:	$Date: 2003/05/23 12:45:13 $
+ * Version:	$Revision: 2.3 $
+ * Date:	$Date: 2004/03/19 16:19:59 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
 
@@ -69,11 +69,11 @@
 
 /*
  * VCT internal status values
  */
-#define SK_PNMI_VCT_PENDING	32
-#define SK_PNMI_VCT_TEST_DONE	64
-#define SK_PNMI_VCT_LINK	128
+#define SK_PNMI_VCT_PENDING		0x20
+#define SK_PNMI_VCT_TEST_DONE	0x40
+#define SK_PNMI_VCT_LINK		0x80
 
 /*
  * Internal table definitions
  */
@@ -322,9 +322,9 @@ typedef struct s_PnmiStatAddr {
 						("PNMI: ERR: %s MacUFlag=%d, RlmtUFlag=%d, SirqUFlag=%d\n", \
 						vSt, \
 						pAC->Pnmi.MacUpdatedFlag, \
 						pAC->Pnmi.RlmtUpdatedFlag, \
-						pAC->Pnmi.SirqUpdatedFlag))}}
+						pAC->Pnmi.SirqUpdatedFlag));}}
 
 #else	/* !DEBUG */
 
 #define SK_PNMI_CHECKFLAGS(vSt)	/* Nothing */
Index: linux-2.6.8/drivers/net/sk98lin/h/skgepnmi.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skgepnmi.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skgepnmi.h
@@ -1,10 +1,10 @@
 /*****************************************************************************
  *
  * Name:	skgepnmi.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.62 $
- * Date:	$Date: 2003/08/15 12:31:52 $
+ * Project:	Gigabit Ethernet Adapters, PNMI-Module
+ * Version:	$Revision: 2.8 $
+ * Date:	$Date: 2004/06/14 06:55:26 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
 
@@ -30,9 +30,9 @@
  */
 #include "h/sktypes.h"
 #include "h/skerror.h"
 #include "h/sktimer.h"
-#include "h/ski2c.h"
+#include "h/sktwsi.h"
 #include "h/skaddr.h"
 #include "h/skrlmt.h"
 #include "h/skvpd.h"
 
@@ -40,9 +40,8 @@
  * Management Database Version
  */
 #define SK_PNMI_MDB_VERSION		0x00030001	/* 3.1 */
 
-
 /*
  * Event definitions
  */
 #define SK_PNMI_EVT_SIRQ_OVERFLOW		1	/* Counter overflow */
@@ -53,18 +52,15 @@
 #define SK_PNMI_EVT_CHG_EST_TIMER		6	/* Timer event for RLMT Chg */
 #define SK_PNMI_EVT_UTILIZATION_TIMER	7	/* Timer event for Utiliza. */
 #define SK_PNMI_EVT_CLEAR_COUNTER		8	/* Clear statistic counters */
 #define SK_PNMI_EVT_XMAC_RESET			9	/* XMAC will be reset */
-
 #define SK_PNMI_EVT_RLMT_PORT_UP		10	/* Port came logically up */
 #define SK_PNMI_EVT_RLMT_PORT_DOWN		11	/* Port went logically down */
 #define SK_PNMI_EVT_RLMT_SEGMENTATION	13	/* Two SP root bridges found */
 #define SK_PNMI_EVT_RLMT_ACTIVE_DOWN	14	/* Port went logically down */
 #define SK_PNMI_EVT_RLMT_ACTIVE_UP		15	/* Port came logically up */
-#define SK_PNMI_EVT_RLMT_SET_NETS		16	/* 1. Parameter is number of nets
-												1 = single net; 2 = dual net */
-#define SK_PNMI_EVT_VCT_RESET		17	/* VCT port reset timer event started with SET. */
-
+#define SK_PNMI_EVT_RLMT_SET_NETS		16	/* Number of nets (1 or 2). */
+#define SK_PNMI_EVT_VCT_RESET			17	/* VCT port reset timer event started with SET. */
 
 /*
  * Return values
  */
@@ -77,29 +73,26 @@
 #define SK_PNMI_ERR_UNKNOWN_INST	6
 #define SK_PNMI_ERR_UNKNOWN_NET 	7
 #define SK_PNMI_ERR_NOT_SUPPORTED	10
 
-
 /*
  * Return values of driver reset function SK_DRIVER_RESET() and
  * driver event function SK_DRIVER_EVENT()
  */
 #define SK_PNMI_ERR_OK			0
 #define SK_PNMI_ERR_FAIL		1
 
-
 /*
  * Return values of driver test function SK_DRIVER_SELFTEST()
  */
 #define SK_PNMI_TST_UNKNOWN		(1 << 0)
-#define SK_PNMI_TST_TRANCEIVER		(1 << 1)
+#define SK_PNMI_TST_TRANCEIVER	(1 << 1)
 #define SK_PNMI_TST_ASIC		(1 << 2)
 #define SK_PNMI_TST_SENSOR		(1 << 3)
-#define SK_PNMI_TST_POWERMGMT		(1 << 4)
+#define SK_PNMI_TST_POWERMGMT	(1 << 4)
 #define SK_PNMI_TST_PCI			(1 << 5)
 #define SK_PNMI_TST_MAC			(1 << 6)
 
-
 /*
  * RLMT specific definitions
  */
 #define SK_PNMI_RLMT_STATUS_STANDBY	1
@@ -351,8 +344,9 @@
 /* Defines for VCT. */
 #define OID_SKGE_VCT_GET				0xFF020200
 #define OID_SKGE_VCT_SET				0xFF020201
 #define OID_SKGE_VCT_STATUS				0xFF020202
+#define OID_SKGE_VCT_CAPABILITIES		0xFF020203
 
 #ifdef SK_DIAG_SUPPORT
 /* Defines for driver DIAG mode. */
 #define OID_SKGE_DIAG_MODE				0xFF020204
@@ -366,32 +360,81 @@
 #define OID_SKGE_VAUXAVAIL				0xFF020214
 #define OID_SKGE_PHY_TYPE				0xFF020215
 #define OID_SKGE_PHY_LP_MODE			0xFF020216
 
+/*
+ * Added for new DualNet IM driver V2
+ * these OIDs should later  be in pnmi.h
+ */
+#define OID_SKGE_MAC_COUNT		0xFF020217
+#define OID_SKGE_DUALNET_MODE		0xFF020218
+#define OID_SKGE_SET_TAGHEADER	0xFF020219
+
+#ifdef SK_ASF
+/* Defines for ASF */
+#define OID_SKGE_ASF                    0xFF02021a
+#define OID_SKGE_ASF_STORE_CONFIG       0xFF02021b
+#define OID_SKGE_ASF_ENA                0xFF02021c
+#define OID_SKGE_ASF_RETRANS            0xFF02021d
+#define OID_SKGE_ASF_RETRANS_INT        0xFF02021e
+#define OID_SKGE_ASF_HB_ENA             0xFF02021f
+#define OID_SKGE_ASF_HB_INT             0xFF020220
+#define OID_SKGE_ASF_WD_ENA             0xFF020221
+#define OID_SKGE_ASF_WD_TIME            0xFF020222
+#define OID_SKGE_ASF_IP_SOURCE          0xFF020223
+#define OID_SKGE_ASF_MAC_SOURCE			0xFF020224
+#define OID_SKGE_ASF_IP_DEST            0xFF020225
+#define OID_SKGE_ASF_MAC_DEST           0xFF020226
+#define OID_SKGE_ASF_COMMUNITY_NAME     0xFF020227
+#define OID_SKGE_ASF_RSP_ENA            0xFF020228  
+#define OID_SKGE_ASF_RETRANS_COUNT_MIN	0xFF020229
+#define OID_SKGE_ASF_RETRANS_COUNT_MAX	0xFF02022a
+#define OID_SKGE_ASF_RETRANS_INT_MIN	0xFF02022b
+#define OID_SKGE_ASF_RETRANS_INT_MAX	0xFF02022c
+#define OID_SKGE_ASF_HB_INT_MIN			0xFF02022d
+#define OID_SKGE_ASF_HB_INT_MAX			0xFF02022e
+#define OID_SKGE_ASF_WD_TIME_MIN		0xFF02022f
+#define OID_SKGE_ASF_WD_TIME_MAX		0xFF020230
+#define OID_SKGE_ASF_HB_CAP				0xFF020231
+#define OID_SKGE_ASF_WD_TIMER_RES		0xFF020232
+#define OID_SKGE_ASF_GUID				0xFF020233
+#define OID_SKGE_ASF_KEY_OP				0xFF020234
+#define OID_SKGE_ASF_KEY_ADM			0xFF020235
+#define OID_SKGE_ASF_KEY_GEN			0xFF020236
+#define OID_SKGE_ASF_CAP				0xFF020237
+#define OID_SKGE_ASF_PAR_1				0xFF020238
+#define OID_SKGE_ASF_OVERALL_OID        0xFF020239
+#endif /* SK_ASF */
+
 /* VCT struct to store a backup copy of VCT data after a port reset. */
 typedef struct s_PnmiVct {
 	SK_U8			VctStatus;
-	SK_U8			PCableLen;
-	SK_U32			PMdiPairLen[4];
-	SK_U8			PMdiPairSts[4];
+	SK_U8			CableLen;
+	SK_U32			MdiPairLen[4];
+	SK_U8			MdiPairSts[4];
 } SK_PNMI_VCT;
 
 
 /* VCT status values (to be given to CPA via OID_SKGE_VCT_STATUS). */
-#define SK_PNMI_VCT_NONE		0
-#define SK_PNMI_VCT_OLD_VCT_DATA	1
-#define SK_PNMI_VCT_NEW_VCT_DATA	2
-#define SK_PNMI_VCT_OLD_DSP_DATA	4
-#define SK_PNMI_VCT_NEW_DSP_DATA	8
-#define SK_PNMI_VCT_RUNNING		16
+#define SK_PNMI_VCT_NONE			0x00
+#define SK_PNMI_VCT_OLD_VCT_DATA	0x01
+#define SK_PNMI_VCT_NEW_VCT_DATA	0x02
+#define SK_PNMI_VCT_OLD_DSP_DATA	0x04
+#define SK_PNMI_VCT_NEW_DSP_DATA	0x08
+#define SK_PNMI_VCT_RUNNING			0x10
 
 
 /* VCT cable test status. */
 #define SK_PNMI_VCT_NORMAL_CABLE		0
 #define SK_PNMI_VCT_SHORT_CABLE			1
 #define SK_PNMI_VCT_OPEN_CABLE			2
 #define SK_PNMI_VCT_TEST_FAIL			3
-#define SK_PNMI_VCT_IMPEDANCE_MISMATCH		4
+#define SK_PNMI_VCT_IMPEDANCE_MISMATCH	4
+#define SK_PNMI_VCT_NOT_PRESENT			5
+
+/* VCT capabilities (needed for OID_SKGE_VCT_CAPABILITIES. */
+#define SK_PNMI_VCT_SUPPORTED			1
+#define SK_PNMI_VCT_NOT_SUPPORTED		0
 
 #define	OID_SKGE_TRAP_SEN_WAR_LOW		500
 #define OID_SKGE_TRAP_SEN_WAR_UPP		501
 #define	OID_SKGE_TRAP_SEN_ERR_LOW		502
@@ -418,9 +461,8 @@ typedef struct s_PnmiVct {
 #define	SK_GET_FULL_MIB			4
 #define	SK_SET_FULL_MIB			5
 #define	SK_PRESET_FULL_MIB		6
 
-
 /*
  * Define error numbers and messages for syslog
  */
 #define SK_PNMI_ERR001		(SK_ERRBASE_PNMI + 1)
@@ -451,9 +493,9 @@ typedef struct s_PnmiVct {
 #define SK_PNMI_ERR013MSG	""
 #define SK_PNMI_ERR014		(SK_ERRBASE_PNMI + 14)
 #define SK_PNMI_ERR014MSG	"Vpd: Cannot read VPD keys"
 #define SK_PNMI_ERR015		(SK_ERRBASE_PNMI + 15)
-#define SK_PNMI_ERR015MSG	"Vpd: Internal array for VPD keys to small"
+#define SK_PNMI_ERR015MSG	"Vpd: Internal array for VPD keys too small"
 #define SK_PNMI_ERR016		(SK_ERRBASE_PNMI + 16)
 #define SK_PNMI_ERR016MSG	"Vpd: Key string too long"
 #define SK_PNMI_ERR017		(SK_ERRBASE_PNMI + 17)
 #define SK_PNMI_ERR017MSG	"Vpd: Invalid VPD status pointer"
@@ -493,11 +535,11 @@ typedef struct s_PnmiVct {
 #define SK_PNMI_ERR035MSG	"Rlmt: Unknown OID"
 #define SK_PNMI_ERR036		(SK_ERRBASE_PNMI + 36)
 #define SK_PNMI_ERR036MSG	""
 #define SK_PNMI_ERR037		(SK_ERRBASE_PNMI + 37)
-#define SK_PNMI_ERR037MSG	"Rlmt: SK_RLMT_MODE_CHANGE event return not 0"
+#define SK_PNMI_ERR037MSG	"Rlmt: SK_RLMT_MODE_CHANGE event returned not 0"
 #define SK_PNMI_ERR038		(SK_ERRBASE_PNMI + 38)
-#define SK_PNMI_ERR038MSG	"Rlmt: SK_RLMT_PREFPORT_CHANGE event return not 0"
+#define SK_PNMI_ERR038MSG	"Rlmt: SK_RLMT_PREFPORT_CHANGE event returned not 0"
 #define SK_PNMI_ERR039		(SK_ERRBASE_PNMI + 39)
 #define SK_PNMI_ERR039MSG	"RlmtStat: Unknown OID"
 #define SK_PNMI_ERR040		(SK_ERRBASE_PNMI + 40)
 #define SK_PNMI_ERR040MSG	"PowerManagement: Unknown OID"
@@ -513,11 +555,11 @@ typedef struct s_PnmiVct {
 #define SK_PNMI_ERR045MSG	"MacPrivateConf: SK_HWEV_SET_SPEED returned not 0"
 #define SK_PNMI_ERR046		(SK_ERRBASE_PNMI + 46)
 #define SK_PNMI_ERR046MSG	"Monitor: Unknown OID"
 #define SK_PNMI_ERR047		(SK_ERRBASE_PNMI + 47)
-#define SK_PNMI_ERR047MSG	"SirqUpdate: Event function returns not 0"
+#define SK_PNMI_ERR047MSG	"SirqUpdate: Event function returned not 0"
 #define SK_PNMI_ERR048		(SK_ERRBASE_PNMI + 48)
-#define SK_PNMI_ERR048MSG	"RlmtUpdate: Event function returns not 0"
+#define SK_PNMI_ERR048MSG	"RlmtUpdate: Event function returned not 0"
 #define SK_PNMI_ERR049		(SK_ERRBASE_PNMI + 49)
 #define SK_PNMI_ERR049MSG	"SkPnmiInit: Invalid size of 'CounterOffset' struct!!"
 #define SK_PNMI_ERR050		(SK_ERRBASE_PNMI + 50)
 #define SK_PNMI_ERR050MSG	"SkPnmiInit: Invalid size of 'StatAddr' table!!"
@@ -825,25 +867,27 @@ typedef struct s_PnmiStrucData {
 	SK_U64			SysUpTime;
 } SK_PNMI_STRUCT_DATA;
 
 #define SK_PNMI_STRUCT_SIZE	(sizeof(SK_PNMI_STRUCT_DATA))
+
+/* The ReturnStatus field must be located before VpdFreeBytes! */
 #define SK_PNMI_MIN_STRUCT_SIZE	((unsigned int)(SK_UPTR)\
 				 &(((SK_PNMI_STRUCT_DATA *)0)->VpdFreeBytes))
-														/*
-														 * ReturnStatus field
-														 * must be located
-														 * before VpdFreeBytes
-														 */
 
 /*
  * Various definitions
  */
+#define SK_PNMI_EVT_TIMER_CHECK		28125000L	/* 28125 ms */
+
+#define SK_PNMI_VCT_TIMER_CHECK		 4000000L	/* 4 sec. */
+
 #define SK_PNMI_MAX_PROTOS		3
 
-#define SK_PNMI_CNT_NO			66	/* Must have the value of the enum
-									 * SK_PNMI_MAX_IDX. Define SK_PNMI_CHECK
-									 * for check while init phase 1
-									 */
+/*
+ * SK_PNMI_CNT_NO must have the value of the enum SK_PNMI_MAX_IDX.
+ * Define SK_PNMI_CHECK to check this during init level SK_INIT_IO.
+ */
+#define SK_PNMI_CNT_NO			66
 
 /*
  * Estimate data structure
  */
@@ -855,16 +899,8 @@ typedef struct s_PnmiEstimate {
 } SK_PNMI_ESTIMATE;
 
 
 /*
- * VCT timer data structure
- */
-typedef struct s_VctTimer {
-	SK_TIMER		VctTimer;
-} SK_PNMI_VCT_TIMER;
-
-
-/*
  * PNMI specific adapter context structure
  */
 typedef struct s_PnmiPort {
 	SK_U64			StatSyncCts;
@@ -932,11 +968,11 @@ typedef struct s_PnmiData {
 	unsigned int	TrapQueueBeg;
 	unsigned int	TrapQueueEnd;
 	unsigned int	TrapBufPad;
 	unsigned int	TrapUnique;
-	SK_U8		VctStatus[SK_MAX_MACS];
-	SK_PNMI_VCT	VctBackup[SK_MAX_MACS];
-	SK_PNMI_VCT_TIMER VctTimeout[SK_MAX_MACS];
+	SK_U8			VctStatus[SK_MAX_MACS];
+	SK_PNMI_VCT		VctBackup[SK_MAX_MACS];
+	SK_TIMER		VctTimeout[SK_MAX_MACS];
 #ifdef SK_DIAG_SUPPORT
 	SK_U32			DiagAttached;
 #endif /* SK_DIAG_SUPPORT */
 } SK_PNMI;
Index: linux-2.6.8/drivers/net/sk98lin/h/skgesirq.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skgesirq.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skgesirq.h
@@ -1,24 +1,23 @@
 /******************************************************************************
  *
  * Name:	skgesirq.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.30 $
- * Date:	$Date: 2003/07/04 12:34:13 $
- * Purpose:	SK specific Gigabit Ethernet special IRQ functions
+ * Version:	$Revision: 2.3 $
+ * Date:	$Date: 2004/05/28 14:42:03 $
+ * Purpose:	Gigabit Ethernet special IRQ functions
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
@@ -43,12 +42,12 @@
 #define SK_HWEV_SET_ROLE		8	/* Set Master/Slave (Role) by PNMI */
 #define SK_HWEV_SET_SPEED		9	/* Set Link Speed by PNMI */
 #define SK_HWEV_HALFDUP_CHK		10	/* Half Duplex Hangup Workaround */
 
-#define SK_WA_ACT_TIME		(5000000UL)	/* 5 sec */
-#define SK_WA_INA_TIME		(100000UL)	/* 100 msec */
+#define SK_WA_ACT_TIME		1000000UL	/* 1000 msec (1 sec) */
+#define SK_WA_INA_TIME		 100000UL	/*  100 msec */
 
-#define SK_HALFDUP_CHK_TIME	(10000UL)	/* 10 msec */
+#define SK_HALFDUP_CHK_TIME	  10000UL	/*   10 msec */
 
 /*
  * Define the error numbers and messages
  */
@@ -101,11 +100,36 @@
 #define SKERR_SIRQ_E024		(SKERR_SIRQ_E023+1)
 #define SKERR_SIRQ_E024MSG	"FIFO overflow error"
 #define SKERR_SIRQ_E025		(SKERR_SIRQ_E024+1)
 #define SKERR_SIRQ_E025MSG	"2 Pair Downshift detected"
+#define SKERR_SIRQ_E026		(SKERR_SIRQ_E025+1)
+#define SKERR_SIRQ_E026MSG	"Uncorrectable PCI Express error"
+#define SKERR_SIRQ_E027		(SKERR_SIRQ_E026+1)
+#define SKERR_SIRQ_E027MSG	"PCI express protocol violation error"
+#define SKERR_SIRQ_E028		(SKERR_SIRQ_E027+1)
+#define SKERR_SIRQ_E028MSG	"Parity error on RAM 1 (read)"
+#define SKERR_SIRQ_E029		(SKERR_SIRQ_E028+1)
+#define SKERR_SIRQ_E029MSG	"Parity error on RAM 1 (write)"
+#define SKERR_SIRQ_E030		(SKERR_SIRQ_E029+1)
+#define SKERR_SIRQ_E030MSG	"Parity error on RAM 2 (read)"
+#define SKERR_SIRQ_E031		(SKERR_SIRQ_E030+1)
+#define SKERR_SIRQ_E031MSG	"Parity error on RAM 2 (write)"
+#define SKERR_SIRQ_E032		(SKERR_SIRQ_E031+1)
+#define SKERR_SIRQ_E032MSG	"TCP segmentation error async. queue 1"
+#define SKERR_SIRQ_E033		(SKERR_SIRQ_E032+1)
+#define SKERR_SIRQ_E033MSG	"TCP segmentation error sync. queue 1"
+#define SKERR_SIRQ_E034		(SKERR_SIRQ_E033+1)
+#define SKERR_SIRQ_E034MSG	"TCP segmentation error async. queue 2"
+#define SKERR_SIRQ_E035		(SKERR_SIRQ_E034+1)
+#define SKERR_SIRQ_E035MSG	"TCP segmentation error sync. queue 2"
+#define SKERR_SIRQ_E036		(SKERR_SIRQ_E035+1)
+#define SKERR_SIRQ_E036MSG	"CHECK failure polling unit"
 
 extern void SkGeSirqIsr(SK_AC *pAC, SK_IOC IoC, SK_U32 Istatus);
 extern int  SkGeSirqEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Para);
 extern void SkHWLinkUp(SK_AC *pAC, SK_IOC IoC, int Port);
 extern void SkHWLinkDown(SK_AC *pAC, SK_IOC IoC, int Port);
+extern void SkGeYuSirqIsr(SK_AC *pAC, SK_IOC IoC, SK_U32 Istatus);
+extern void SkYuk2SirqIsr(SK_AC *pAC, SK_IOC IoC, SK_U32 Istatus);
 
 #endif	/* _INC_SKGESIRQ_H_ */
+
Index: linux-2.6.8/drivers/net/sk98lin/h/skgetwsi.h
===================================================================
--- /dev/null
+++ linux-2.6.8/drivers/net/sk98lin/h/skgetwsi.h
@@ -0,0 +1,210 @@
+/******************************************************************************
+ *
+ * Name:	skgetwsi.h
+ * Project:	Gigabit Ethernet Adapters, TWSI-Module
+ * Version:	$Revision: 1.1 $
+ * Date:	$Date: 2003/12/19 14:02:56 $
+ * Purpose:	Special defines for TWSI
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+/*
+ * SKGETWSI.H	contains all SK-98xx specific defines for the TWSI handling
+ */
+
+#ifndef _INC_SKGETWSI_H_
+#define _INC_SKGETWSI_H_
+
+/*
+ * Macros to access the B2_I2C_CTRL
+ */
+#define SK_I2C_CTL(IoC, flag, dev, dev_size, reg, burst) \
+	SK_OUT32(IoC, B2_I2C_CTRL,\
+		(flag ? 0x80000000UL : 0x0L) | \
+		(((SK_U32)reg << 16) & I2C_ADDR) | \
+		(((SK_U32)dev << 9) & I2C_DEV_SEL) | \
+		(dev_size & I2C_DEV_SIZE) | \
+		((burst << 4) & I2C_BURST_LEN))
+
+#define SK_I2C_STOP(IoC) {				\
+	SK_U32	I2cCtrl;				\
+	SK_IN32(IoC, B2_I2C_CTRL, &I2cCtrl);		\
+	SK_OUT32(IoC, B2_I2C_CTRL, I2cCtrl | I2C_STOP);	\
+}
+
+#define SK_I2C_GET_CTL(IoC, pI2cCtrl)	SK_IN32(IoC, B2_I2C_CTRL, pI2cCtrl)
+
+/*
+ * Macros to access the TWSI SW Registers
+ */
+#define SK_I2C_SET_BIT(IoC, SetBits) {			\
+	SK_U8	OrgBits;				\
+	SK_IN8(IoC, B2_I2C_SW, &OrgBits);		\
+	SK_OUT8(IoC, B2_I2C_SW, OrgBits | (SK_U8)(SetBits));	\
+}
+
+#define SK_I2C_CLR_BIT(IoC, ClrBits) {			\
+	SK_U8	OrgBits;				\
+	SK_IN8(IoC, B2_I2C_SW, &OrgBits);		\
+	SK_OUT8(IoC, B2_I2C_SW, OrgBits & ~((SK_U8)(ClrBits)));	\
+}
+
+#define SK_I2C_GET_SW(IoC, pI2cSw)	SK_IN8(IoC, B2_I2C_SW, pI2cSw)
+
+/*
+ * define the possible sensor states
+ */
+#define	SK_SEN_IDLE		0	/* Idle: sensor not read */
+#define	SK_SEN_VALUE	1	/* Value Read cycle */
+#define	SK_SEN_VALEXT	2	/* Extended Value Read cycle */
+
+/*
+ * Conversion factor to convert read Voltage sensor to milli Volt
+ * Conversion factor to convert read Temperature sensor to 10th degree Celsius
+ */
+#define	SK_LM80_VT_LSB		22	/* 22mV LSB resolution */
+#define	SK_LM80_TEMP_LSB	10	/* 1 degree LSB resolution */
+#define	SK_LM80_TEMPEXT_LSB	 5	/* 0.5 degree LSB resolution for ext. val. */
+
+/*
+ * formula: counter = (22500*60)/(rpm * divisor * pulses/2)
+ * assuming: 6500rpm, 4 pulses, divisor 1
+ */
+#define SK_LM80_FAN_FAKTOR	((22500L*60)/(1*2))
+
+/*
+ * Define sensor management data
+ * Maximum is reached on Genesis copper dual port and Yukon-64
+ * Board specific maximum is in pAC->I2c.MaxSens
+ */
+#define	SK_MAX_SENSORS	8	/* maximal no. of installed sensors */
+#define	SK_MIN_SENSORS	5	/* minimal no. of installed sensors */
+
+/*
+ * To watch the state machine (SM) use the timer in two ways
+ * instead of one as hitherto
+ */
+#define	SK_TIMER_WATCH_SM		0	/* Watch the SM to finish in a spec. time */
+#define	SK_TIMER_NEW_GAUGING	1	/* Start a new gauging when timer expires */
+
+/*
+ * Defines for the individual thresholds
+ */
+
+/* Temperature sensor */
+#define	SK_SEN_TEMP_HIGH_ERR	800	/* Temperature High Err  Threshold */
+#define	SK_SEN_TEMP_HIGH_WARN	700	/* Temperature High Warn Threshold */
+#define	SK_SEN_TEMP_LOW_WARN	100	/* Temperature Low  Warn Threshold */
+#define	SK_SEN_TEMP_LOW_ERR		  0	/* Temperature Low  Err  Threshold */
+
+/* VCC which should be 5 V */
+#define	SK_SEN_PCI_5V_HIGH_ERR		5588	/* Voltage PCI High Err  Threshold */
+#define	SK_SEN_PCI_5V_HIGH_WARN		5346	/* Voltage PCI High Warn Threshold */
+#define	SK_SEN_PCI_5V_LOW_WARN		4664	/* Voltage PCI Low  Warn Threshold */
+#define	SK_SEN_PCI_5V_LOW_ERR		4422	/* Voltage PCI Low  Err  Threshold */
+
+/*
+ * VIO may be 5 V or 3.3 V. Initialization takes two parts:
+ * 1. Initialize lowest lower limit and highest higher limit.
+ * 2. After the first value is read correct the upper or the lower limit to
+ *    the appropriate C constant.
+ *
+ * Warning limits are +-5% of the exepected voltage.
+ * Error limits are +-10% of the expected voltage.
+ */
+
+/* Bug fix AF: 16.Aug.2001: Correct the init base of LM80 sensor */
+
+#define	SK_SEN_PCI_IO_5V_HIGH_ERR	5566	/* + 10% V PCI-IO High Err Threshold */
+#define	SK_SEN_PCI_IO_5V_HIGH_WARN	5324	/* +  5% V PCI-IO High Warn Threshold */
+					/*		5000	mVolt */
+#define	SK_SEN_PCI_IO_5V_LOW_WARN	4686	/* -  5% V PCI-IO Low Warn Threshold */
+#define	SK_SEN_PCI_IO_5V_LOW_ERR	4444	/* - 10% V PCI-IO Low Err Threshold */
+
+#define	SK_SEN_PCI_IO_RANGE_LIMITER	4000	/* 4000 mV range delimiter */
+
+/* correction values for the second pass */
+#define	SK_SEN_PCI_IO_3V3_HIGH_ERR	3850	/* + 15% V PCI-IO High Err Threshold */
+#define	SK_SEN_PCI_IO_3V3_HIGH_WARN	3674	/* + 10% V PCI-IO High Warn Threshold */
+					/*		3300	mVolt */
+#define	SK_SEN_PCI_IO_3V3_LOW_WARN	2926	/* - 10% V PCI-IO Low Warn Threshold */
+#define	SK_SEN_PCI_IO_3V3_LOW_ERR	2772	/* - 15% V PCI-IO Low Err  Threshold */
+
+/*
+ * VDD voltage
+ */
+#define	SK_SEN_VDD_HIGH_ERR		3630	/* Voltage ASIC High Err  Threshold */
+#define	SK_SEN_VDD_HIGH_WARN	3476	/* Voltage ASIC High Warn Threshold */
+#define	SK_SEN_VDD_LOW_WARN		3146	/* Voltage ASIC Low  Warn Threshold */
+#define	SK_SEN_VDD_LOW_ERR		2970	/* Voltage ASIC Low  Err  Threshold */
+
+/*
+ * PHY PLL 3V3 voltage
+ */
+#define	SK_SEN_PLL_3V3_HIGH_ERR		3630	/* Voltage PMA High Err  Threshold */
+#define	SK_SEN_PLL_3V3_HIGH_WARN	3476	/* Voltage PMA High Warn Threshold */
+#define	SK_SEN_PLL_3V3_LOW_WARN		3146	/* Voltage PMA Low  Warn Threshold */
+#define	SK_SEN_PLL_3V3_LOW_ERR		2970	/* Voltage PMA Low  Err  Threshold */
+
+/*
+ * VAUX (YUKON only)
+ */
+#define	SK_SEN_VAUX_3V3_HIGH_ERR	3630	/* Voltage VAUX High Err Threshold */
+#define	SK_SEN_VAUX_3V3_HIGH_WARN	3476	/* Voltage VAUX High Warn Threshold */
+#define	SK_SEN_VAUX_3V3_LOW_WARN	3146	/* Voltage VAUX Low Warn Threshold */
+#define	SK_SEN_VAUX_3V3_LOW_ERR		2970	/* Voltage VAUX Low Err Threshold */
+#define	SK_SEN_VAUX_0V_WARN_ERR		   0	/* if VAUX not present */
+#define	SK_SEN_VAUX_RANGE_LIMITER	1000	/* 1000 mV range delimiter */
+
+/*
+ * PHY 2V5 voltage
+ */
+#define	SK_SEN_PHY_2V5_HIGH_ERR		2750	/* Voltage PHY High Err Threshold */
+#define	SK_SEN_PHY_2V5_HIGH_WARN	2640	/* Voltage PHY High Warn Threshold */
+#define	SK_SEN_PHY_2V5_LOW_WARN		2376	/* Voltage PHY Low Warn Threshold */
+#define	SK_SEN_PHY_2V5_LOW_ERR		2222	/* Voltage PHY Low Err Threshold */
+
+/*
+ * ASIC Core 1V5 voltage (YUKON only)
+ */
+#define	SK_SEN_CORE_1V5_HIGH_ERR	1650	/* Voltage ASIC Core High Err Threshold */
+#define	SK_SEN_CORE_1V5_HIGH_WARN	1575	/* Voltage ASIC Core High Warn Threshold */
+#define	SK_SEN_CORE_1V5_LOW_WARN	1425	/* Voltage ASIC Core Low Warn Threshold */
+#define	SK_SEN_CORE_1V5_LOW_ERR 	1350	/* Voltage ASIC Core Low Err Threshold */
+
+/*
+ * FAN 1 speed
+ */
+/* assuming: 6500rpm +-15%, 4 pulses,
+ * warning at:	80 %
+ * error at:	70 %
+ * no upper limit
+ */
+#define	SK_SEN_FAN_HIGH_ERR		20000	/* FAN Speed High Err Threshold */
+#define	SK_SEN_FAN_HIGH_WARN	20000	/* FAN Speed High Warn Threshold */
+#define	SK_SEN_FAN_LOW_WARN		 5200	/* FAN Speed Low Warn Threshold */
+#define	SK_SEN_FAN_LOW_ERR		 4550	/* FAN Speed Low Err Threshold */
+
+/*
+ * Some Voltages need dynamic thresholds
+ */
+#define	SK_SEN_DYN_INIT_NONE		 0  /* No dynamic init of thresholds */
+#define	SK_SEN_DYN_INIT_PCI_IO		10  /* Init PCI-IO with new thresholds */
+#define	SK_SEN_DYN_INIT_VAUX		11  /* Init VAUX with new thresholds */
+
+extern	int SkLm80ReadSensor(SK_AC *pAC, SK_IOC IoC, SK_SENSOR *pSen);
+#endif	/* n_INC_SKGETWSI_H */
Index: linux-2.6.8/drivers/net/sk98lin/h/ski2c.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/ski2c.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/******************************************************************************
- *
- * Name:	ski2c.h
- * Project:	Gigabit Ethernet Adapters, TWSI-Module
- * Version:	$Revision: 1.35 $
- * Date:	$Date: 2003/10/20 09:06:30 $
- * Purpose:	Defines to access Voltage and Temperature Sensor
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
- *	The information in this file is provided "AS IS" without warranty.
- *
- ******************************************************************************/
-
-/*
- * SKI2C.H	contains all I2C specific defines
- */
-
-#ifndef _SKI2C_H_
-#define _SKI2C_H_
-
-typedef struct  s_Sensor SK_SENSOR;
-
-#include "h/skgei2c.h"
-
-/*
- * Define the I2C events.
- */
-#define SK_I2CEV_IRQ	1	/* IRQ happened Event */
-#define SK_I2CEV_TIM	2	/* Timeout event */
-#define SK_I2CEV_CLEAR	3	/* Clear MIB Values */
-
-/*
- * Define READ and WRITE Constants.
- */
-#define I2C_READ	0
-#define I2C_WRITE	1
-#define I2C_BURST	1
-#define I2C_SINGLE	0
-
-#define SKERR_I2C_E001		(SK_ERRBASE_I2C+0)
-#define SKERR_I2C_E001MSG	"Sensor index unknown"
-#define SKERR_I2C_E002		(SKERR_I2C_E001+1)
-#define SKERR_I2C_E002MSG	"TWSI: transfer does not complete"
-#define SKERR_I2C_E003		(SKERR_I2C_E002+1)
-#define SKERR_I2C_E003MSG	"LM80: NAK on device send"
-#define SKERR_I2C_E004		(SKERR_I2C_E003+1)
-#define SKERR_I2C_E004MSG	"LM80: NAK on register send"
-#define SKERR_I2C_E005		(SKERR_I2C_E004+1)
-#define SKERR_I2C_E005MSG	"LM80: NAK on device (2) send"
-#define SKERR_I2C_E006		(SKERR_I2C_E005+1)
-#define SKERR_I2C_E006MSG	"Unknown event"
-#define SKERR_I2C_E007		(SKERR_I2C_E006+1)
-#define SKERR_I2C_E007MSG	"LM80 read out of state"
-#define SKERR_I2C_E008		(SKERR_I2C_E007+1)
-#define SKERR_I2C_E008MSG	"Unexpected sensor read completed"
-#define SKERR_I2C_E009		(SKERR_I2C_E008+1)
-#define SKERR_I2C_E009MSG	"WARNING: temperature sensor out of range"
-#define SKERR_I2C_E010		(SKERR_I2C_E009+1)
-#define SKERR_I2C_E010MSG	"WARNING: voltage sensor out of range"
-#define SKERR_I2C_E011		(SKERR_I2C_E010+1)
-#define SKERR_I2C_E011MSG	"ERROR: temperature sensor out of range"
-#define SKERR_I2C_E012		(SKERR_I2C_E011+1)
-#define SKERR_I2C_E012MSG	"ERROR: voltage sensor out of range"
-#define SKERR_I2C_E013		(SKERR_I2C_E012+1)
-#define SKERR_I2C_E013MSG	"ERROR: couldn't init sensor"
-#define SKERR_I2C_E014		(SKERR_I2C_E013+1)
-#define SKERR_I2C_E014MSG	"WARNING: fan sensor out of range"
-#define SKERR_I2C_E015		(SKERR_I2C_E014+1)
-#define SKERR_I2C_E015MSG	"ERROR: fan sensor out of range"
-#define SKERR_I2C_E016		(SKERR_I2C_E015+1)
-#define SKERR_I2C_E016MSG	"TWSI: active transfer does not complete"
-
-/*
- * Define Timeout values
- */
-#define SK_I2C_TIM_LONG		2000000L	/* 2 seconds */
-#define SK_I2C_TIM_SHORT	 100000L	/* 100 milliseconds */
-#define SK_I2C_TIM_WATCH	1000000L	/* 1 second */
-
-/*
- * Define trap and error log hold times
- */
-#ifndef	SK_SEN_ERR_TR_HOLD
-#define SK_SEN_ERR_TR_HOLD		(4*SK_TICKS_PER_SEC)
-#endif
-#ifndef	SK_SEN_ERR_LOG_HOLD
-#define SK_SEN_ERR_LOG_HOLD		(60*SK_TICKS_PER_SEC)
-#endif
-#ifndef	SK_SEN_WARN_TR_HOLD
-#define SK_SEN_WARN_TR_HOLD		(15*SK_TICKS_PER_SEC)
-#endif
-#ifndef	SK_SEN_WARN_LOG_HOLD
-#define SK_SEN_WARN_LOG_HOLD	(15*60*SK_TICKS_PER_SEC)
-#endif
-
-/*
- * Defines for SenType
- */
-#define SK_SEN_UNKNOWN	0
-#define SK_SEN_TEMP		1
-#define SK_SEN_VOLT		2
-#define SK_SEN_FAN		3
-
-/*
- * Define for the SenErrorFlag
- */
-#define SK_SEN_ERR_NOT_PRESENT	0	/* Error Flag: Sensor not present */
-#define SK_SEN_ERR_OK			1	/* Error Flag: O.K. */
-#define SK_SEN_ERR_WARN			2	/* Error Flag: Warning */
-#define SK_SEN_ERR_ERR			3	/* Error Flag: Error */
-#define SK_SEN_ERR_FAULTY		4	/* Error Flag: Faulty */
-
-/*
- * Define the Sensor struct
- */
-struct	s_Sensor {
-	char	*SenDesc;			/* Description */
-	int		SenType;			/* Voltage or Temperature */
-	SK_I32	SenValue;			/* Current value of the sensor */
-	SK_I32	SenThreErrHigh;		/* High error Threshhold of this sensor */
-	SK_I32	SenThreWarnHigh;	/* High warning Threshhold of this sensor */
-	SK_I32	SenThreErrLow;		/* Lower error Threshold of the sensor */
-	SK_I32	SenThreWarnLow;		/* Lower warning Threshold of the sensor */
-	int		SenErrFlag;			/* Sensor indicated an error */
-	SK_BOOL	SenInit;			/* Is sensor initialized ? */
-	SK_U64	SenErrCts;			/* Error trap counter */
-	SK_U64	SenWarnCts;			/* Warning trap counter */
-	SK_U64	SenBegErrTS;		/* Begin error timestamp */
-	SK_U64	SenBegWarnTS;		/* Begin warning timestamp */
-	SK_U64	SenLastErrTrapTS;	/* Last error trap timestamp */
-	SK_U64	SenLastErrLogTS;	/* Last error log timestamp */
-	SK_U64	SenLastWarnTrapTS;	/* Last warning trap timestamp */
-	SK_U64	SenLastWarnLogTS;	/* Last warning log timestamp */
-	int		SenState;			/* Sensor State (see HW specific include) */
-	int		(*SenRead)(SK_AC *pAC, SK_IOC IoC, struct s_Sensor *pSen);
-								/* Sensors read function */
-	SK_U16	SenReg;				/* Register Address for this sensor */
-	SK_U8	SenDev;				/* Device Selection for this sensor */
-};
-
-typedef	struct	s_I2c {
-	SK_SENSOR	SenTable[SK_MAX_SENSORS];	/* Sensor Table */
-	int			CurrSens;	/* Which sensor is currently queried */
-	int			MaxSens;	/* Max. number of sensors */
-	int			TimerMode;	/* Use the timer also to watch the state machine */
-	int			InitLevel;	/* Initialized Level */
-#ifndef SK_DIAG
-	int			DummyReads;	/* Number of non-checked dummy reads */
-	SK_TIMER	SenTimer;	/* Sensors timer */
-#endif /* !SK_DIAG */
-} SK_I2C;
-
-extern int SkI2cInit(SK_AC *pAC, SK_IOC IoC, int Level);
-extern int SkI2cWrite(SK_AC *pAC, SK_IOC IoC, SK_U32 Data, int Dev, int Size,
-					   int Reg, int Burst);
-extern int SkI2cReadSensor(SK_AC *pAC, SK_IOC IoC, SK_SENSOR *pSen);
-#ifdef SK_DIAG
-extern	SK_U32 SkI2cRead(SK_AC *pAC, SK_IOC IoC, int Dev, int Size, int Reg,
-						 int Burst);
-#else /* !SK_DIAG */
-extern int SkI2cEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Para);
-extern void SkI2cWaitIrq(SK_AC *pAC, SK_IOC IoC);
-extern void SkI2cIsr(SK_AC *pAC, SK_IOC IoC);
-#endif /* !SK_DIAG */
-#endif /* n_SKI2C_H */
-
Index: linux-2.6.8/drivers/net/sk98lin/h/skqueue.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skqueue.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skqueue.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skqueue.h
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision: 1.16 $
- * Date:	$Date: 2003/09/16 12:50:32 $
+ * Version:	$Revision: 2.3 $
+ * Date:	$Date: 2004/05/14 13:39:15 $
  * Purpose:	Defines for the Event queue
  *
  ******************************************************************************/
 
@@ -44,8 +44,11 @@
 #define	SKGE_LACP	10	/* LACP Aggregation Event Class */
 #define	SKGE_RSF	11	/* RSF Aggregation Event Class */
 #define	SKGE_MARKER	12	/* MARKER Aggregation Event Class */
 #define	SKGE_FD		13	/* FD Distributor Event Class */
+#ifdef SK_ASF
+#define	SKGE_ASF	14	/* ASF Event Class */
+#endif
 
 /*
  * define event queue as circular buffer
  */
@@ -89,6 +92,12 @@ extern	int SkEventDispatcher(SK_AC *pAC,
 #define	SKERR_Q_E001	(SK_ERRBASE_QUEUE+0)
 #define	SKERR_Q_E001MSG	"Event queue overflow"
 #define	SKERR_Q_E002	(SKERR_Q_E001+1)
 #define	SKERR_Q_E002MSG	"Undefined event class"
+#define	SKERR_Q_E003	(SKERR_Q_E001+2)
+#define	SKERR_Q_E003MSG	"Event queued in Init Level 0"
+#define	SKERR_Q_E004	(SKERR_Q_E001+3)
+#define	SKERR_Q_E004MSG	"Error Reported from Event Fuction (Queue Blocked)"
+#define	SKERR_Q_E005	(SKERR_Q_E001+4)
+#define	SKERR_Q_E005MSG	"Event scheduler called in Init Level 0 or 1"
 #endif	/* _SKQUEUE_H_ */
 
Index: linux-2.6.8/drivers/net/sk98lin/h/skrlmt.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skrlmt.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skrlmt.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skrlmt.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.37 $
- * Date:	$Date: 2003/04/15 09:43:43 $
+ * Version:	$Revision: 2.1 $
+ * Date:	$Date: 2003/10/27 14:16:09 $
  * Purpose:	Header file for Redundant Link ManagemenT.
  *
  ******************************************************************************/
 
Index: linux-2.6.8/drivers/net/sk98lin/h/sktimer.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/sktimer.h
+++ linux-2.6.8/drivers/net/sk98lin/h/sktimer.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	sktimer.h
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision: 1.11 $
- * Date:	$Date: 2003/09/16 12:58:18 $
+ * Version:	$Revision: 2.1 $
+ * Date:	$Date: 2003/10/27 14:16:09 $
  * Purpose:	Defines for the timer functions
  *
  ******************************************************************************/
 
Index: linux-2.6.8/drivers/net/sk98lin/h/sktwsi.h
===================================================================
--- /dev/null
+++ linux-2.6.8/drivers/net/sk98lin/h/sktwsi.h
@@ -0,0 +1,177 @@
+/******************************************************************************
+ *
+ * Name:	sktwsi.h
+ * Project:	Gigabit Ethernet Adapters, TWSI-Module
+ * Version:	$Revision: 1.1 $
+ * Date:	$Date: 2003/12/19 14:02:56 $
+ * Purpose:	Defines to access Voltage and Temperature Sensor
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+/*
+ * SKTWSI.H	contains all TWSI specific defines
+ */
+
+#ifndef _SKTWSI_H_
+#define _SKTWSI_H_
+
+typedef struct  s_Sensor SK_SENSOR;
+
+#include "h/skgetwsi.h"
+
+/*
+ * Define the TWSI events.
+ */
+#define SK_I2CEV_IRQ	1	/* IRQ happened Event */
+#define SK_I2CEV_TIM	2	/* Timeout event */
+#define SK_I2CEV_CLEAR	3	/* Clear MIB Values */
+
+/*
+ * Define READ and WRITE Constants.
+ */
+#define I2C_READ	0
+#define I2C_WRITE	1
+#define I2C_BURST	1
+#define I2C_SINGLE	0
+
+#define SKERR_I2C_E001		(SK_ERRBASE_I2C+0)
+#define SKERR_I2C_E001MSG	"Sensor index unknown"
+#define SKERR_I2C_E002		(SKERR_I2C_E001+1)
+#define SKERR_I2C_E002MSG	"TWSI: transfer does not complete"
+#define SKERR_I2C_E003		(SKERR_I2C_E002+1)
+#define SKERR_I2C_E003MSG	"LM80: NAK on device send"
+#define SKERR_I2C_E004		(SKERR_I2C_E003+1)
+#define SKERR_I2C_E004MSG	"LM80: NAK on register send"
+#define SKERR_I2C_E005		(SKERR_I2C_E004+1)
+#define SKERR_I2C_E005MSG	"LM80: NAK on device (2) send"
+#define SKERR_I2C_E006		(SKERR_I2C_E005+1)
+#define SKERR_I2C_E006MSG	"Unknown event"
+#define SKERR_I2C_E007		(SKERR_I2C_E006+1)
+#define SKERR_I2C_E007MSG	"LM80 read out of state"
+#define SKERR_I2C_E008		(SKERR_I2C_E007+1)
+#define SKERR_I2C_E008MSG	"Unexpected sensor read completed"
+#define SKERR_I2C_E009		(SKERR_I2C_E008+1)
+#define SKERR_I2C_E009MSG	"WARNING: temperature sensor out of range"
+#define SKERR_I2C_E010		(SKERR_I2C_E009+1)
+#define SKERR_I2C_E010MSG	"WARNING: voltage sensor out of range"
+#define SKERR_I2C_E011		(SKERR_I2C_E010+1)
+#define SKERR_I2C_E011MSG	"ERROR: temperature sensor out of range"
+#define SKERR_I2C_E012		(SKERR_I2C_E011+1)
+#define SKERR_I2C_E012MSG	"ERROR: voltage sensor out of range"
+#define SKERR_I2C_E013		(SKERR_I2C_E012+1)
+#define SKERR_I2C_E013MSG	"ERROR: couldn't init sensor"
+#define SKERR_I2C_E014		(SKERR_I2C_E013+1)
+#define SKERR_I2C_E014MSG	"WARNING: fan sensor out of range"
+#define SKERR_I2C_E015		(SKERR_I2C_E014+1)
+#define SKERR_I2C_E015MSG	"ERROR: fan sensor out of range"
+#define SKERR_I2C_E016		(SKERR_I2C_E015+1)
+#define SKERR_I2C_E016MSG	"TWSI: active transfer does not complete"
+
+/*
+ * Define Timeout values
+ */
+#define SK_I2C_TIM_LONG		2000000L	/* 2 seconds */
+#define SK_I2C_TIM_SHORT	 100000L	/* 100 milliseconds */
+#define SK_I2C_TIM_WATCH	1000000L	/* 1 second */
+
+/*
+ * Define trap and error log hold times
+ */
+#ifndef	SK_SEN_ERR_TR_HOLD
+#define SK_SEN_ERR_TR_HOLD		(4*SK_TICKS_PER_SEC)
+#endif
+#ifndef	SK_SEN_ERR_LOG_HOLD
+#define SK_SEN_ERR_LOG_HOLD		(60*SK_TICKS_PER_SEC)
+#endif
+#ifndef	SK_SEN_WARN_TR_HOLD
+#define SK_SEN_WARN_TR_HOLD		(15*SK_TICKS_PER_SEC)
+#endif
+#ifndef	SK_SEN_WARN_LOG_HOLD
+#define SK_SEN_WARN_LOG_HOLD	(15*60*SK_TICKS_PER_SEC)
+#endif
+
+/*
+ * Defines for SenType
+ */
+#define SK_SEN_UNKNOWN	0
+#define SK_SEN_TEMP		1
+#define SK_SEN_VOLT		2
+#define SK_SEN_FAN		3
+
+/*
+ * Define for the SenErrorFlag
+ */
+#define SK_SEN_ERR_NOT_PRESENT	0	/* Error Flag: Sensor not present */
+#define SK_SEN_ERR_OK			1	/* Error Flag: O.K. */
+#define SK_SEN_ERR_WARN			2	/* Error Flag: Warning */
+#define SK_SEN_ERR_ERR			3	/* Error Flag: Error */
+#define SK_SEN_ERR_FAULTY		4	/* Error Flag: Faulty */
+
+/*
+ * Define the Sensor struct
+ */
+struct	s_Sensor {
+	char	*SenDesc;			/* Description */
+	int		SenType;			/* Voltage or Temperature */
+	SK_I32	SenValue;			/* Current value of the sensor */
+	SK_I32	SenThreErrHigh;		/* High error Threshhold of this sensor */
+	SK_I32	SenThreWarnHigh;	/* High warning Threshhold of this sensor */
+	SK_I32	SenThreErrLow;		/* Lower error Threshold of the sensor */
+	SK_I32	SenThreWarnLow;		/* Lower warning Threshold of the sensor */
+	int		SenErrFlag;			/* Sensor indicated an error */
+	SK_BOOL	SenInit;			/* Is sensor initialized ? */
+	SK_U64	SenErrCts;			/* Error trap counter */
+	SK_U64	SenWarnCts;			/* Warning trap counter */
+	SK_U64	SenBegErrTS;		/* Begin error timestamp */
+	SK_U64	SenBegWarnTS;		/* Begin warning timestamp */
+	SK_U64	SenLastErrTrapTS;	/* Last error trap timestamp */
+	SK_U64	SenLastErrLogTS;	/* Last error log timestamp */
+	SK_U64	SenLastWarnTrapTS;	/* Last warning trap timestamp */
+	SK_U64	SenLastWarnLogTS;	/* Last warning log timestamp */
+	int		SenState;			/* Sensor State (see HW specific include) */
+	int		(*SenRead)(SK_AC *pAC, SK_IOC IoC, struct s_Sensor *pSen);
+								/* Sensors read function */
+	SK_U16	SenReg;				/* Register Address for this sensor */
+	SK_U8	SenDev;				/* Device Selection for this sensor */
+};
+
+typedef	struct	s_I2c {
+	SK_SENSOR	SenTable[SK_MAX_SENSORS];	/* Sensor Table */
+	int			CurrSens;	/* Which sensor is currently queried */
+	int			MaxSens;	/* Max. number of sensors */
+	int			TimerMode;	/* Use the timer also to watch the state machine */
+	int			InitLevel;	/* Initialized Level */
+#ifndef SK_DIAG
+	int			DummyReads;	/* Number of non-checked dummy reads */
+	SK_TIMER	SenTimer;	/* Sensors timer */
+#endif /* !SK_DIAG */
+} SK_I2C;
+
+extern int SkI2cInit(SK_AC *pAC, SK_IOC IoC, int Level);
+extern int SkI2cWrite(SK_AC *pAC, SK_IOC IoC, SK_U32 Data, int Dev, int Size,
+					   int Reg, int Burst);
+extern int SkI2cReadSensor(SK_AC *pAC, SK_IOC IoC, SK_SENSOR *pSen);
+#ifdef SK_DIAG
+extern	SK_U32 SkI2cRead(SK_AC *pAC, SK_IOC IoC, int Dev, int Size, int Reg,
+						 int Burst);
+#else /* !SK_DIAG */
+extern int SkI2cEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Para);
+extern void SkI2cWaitIrq(SK_AC *pAC, SK_IOC IoC);
+extern void SkI2cIsr(SK_AC *pAC, SK_IOC IoC);
+#endif /* !SK_DIAG */
+#endif /* n_SKTWSI_H */
+
Index: linux-2.6.8/drivers/net/sk98lin/h/sktypes.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/sktypes.h
+++ linux-2.6.8/drivers/net/sk98lin/h/sktypes.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	sktypes.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.2 $
- * Date:	$Date: 2003/10/07 08:16:51 $
+ * Version:	$Revision: 1.1 $
+ * Date:	$Date: 2004/01/28 12:23:29 $
  * Purpose:	Define data types for Linux
  *
  ******************************************************************************/
 
Index: linux-2.6.8/drivers/net/sk98lin/h/skversion.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skversion.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skversion.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	version.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.5 $
- * Date:	$Date: 2003/10/07 08:16:51 $
+ * Version:	$Revision: 1.1 $
+ * Date:	$Date: 2004/01/28 12:23:29 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
 
@@ -21,18 +21,19 @@
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
+ 
 #ifdef	lint
 static const char SysKonnectFileId[] = "@(#) (C) SysKonnect GmbH.";
 static const char SysKonnectBuildNumber[] =
-	"@(#)SK-BUILD: 6.23 PL: 01"; 
+	"@(#)SK-BUILD: 7.04 PL: 07"; 
 #endif	/* !defined(lint) */
 
-#define BOOT_STRING	"sk98lin: Network Device Driver v6.23\n" \
+#define BOOT_STRING	"sk98lin: Network Device Driver v7.04\n" \
 			"(C)Copyright 1999-2004 Marvell(R)."
 
-#define VER_STRING	"6.23"
+#define VER_STRING	"7.04"
 #define DRIVER_FILE_NAME	"sk98lin"
-#define DRIVER_REL_DATE		"Feb-13-2004"
+#define DRIVER_REL_DATE		"Jul-08-2004"
 
 
Index: linux-2.6.8/drivers/net/sk98lin/h/skvpd.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/skvpd.h
+++ linux-2.6.8/drivers/net/sk98lin/h/skvpd.h
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skvpd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.15 $
- * Date:	$Date: 2003/01/13 10:39:38 $
+ * Version:	$Revision: 2.4 $
+ * Date:	$Date: 2004/02/27 13:23:33 $
  * Purpose:	Defines and Macros for VPD handling
  *
  ******************************************************************************/
 
@@ -134,51 +134,51 @@ typedef	struct s_vpd_key {
 #define VPD_IN8(pAC,IoC,Addr,pVal)	(void)SkPciReadCfgByte(pAC,Addr,pVal)
 #define VPD_IN16(pAC,IoC,Addr,pVal)	(void)SkPciReadCfgWord(pAC,Addr,pVal)
 #define VPD_IN32(pAC,IoC,Addr,pVal)	(void)SkPciReadCfgDWord(pAC,Addr,pVal)
 #else	/* VPD_DO_IO */
-#define VPD_OUT8(pAC,IoC,Addr,Val)	SK_OUT8(IoC,PCI_C(Addr),Val)
-#define VPD_OUT16(pAC,IoC,Addr,Val)	SK_OUT16(IoC,PCI_C(Addr),Val)
-#define VPD_OUT32(pAC,IoC,Addr,Val)	SK_OUT32(IoC,PCI_C(Addr),Val)
-#define VPD_IN8(pAC,IoC,Addr,pVal)	SK_IN8(IoC,PCI_C(Addr),pVal)
-#define VPD_IN16(pAC,IoC,Addr,pVal)	SK_IN16(IoC,PCI_C(Addr),pVal)
-#define VPD_IN32(pAC,IoC,Addr,pVal)	SK_IN32(IoC,PCI_C(Addr),pVal)
+#define VPD_OUT8(pAC,IoC,Addr,Val)	SK_OUT8(IoC,PCI_C(pAC,Addr),Val)
+#define VPD_OUT16(pAC,IoC,Addr,Val)	SK_OUT16(IoC,PCI_C(pAC,Addr),Val)
+#define VPD_OUT32(pAC,IoC,Addr,Val)	SK_OUT32(IoC,PCI_C(pAC,Addr),Val)
+#define VPD_IN8(pAC,IoC,Addr,pVal)	SK_IN8(IoC,PCI_C(pAC,Addr),pVal)
+#define VPD_IN16(pAC,IoC,Addr,pVal)	SK_IN16(IoC,PCI_C(pAC,Addr),pVal)
+#define VPD_IN32(pAC,IoC,Addr,pVal)	SK_IN32(IoC,PCI_C(pAC,Addr),pVal)
 #endif	/* VPD_DO_IO */
 #else	/* SKDIAG */
 #define VPD_OUT8(pAC,Ioc,Addr,Val) {			\
 		if ((pAC)->DgT.DgUseCfgCycle)			\
 			SkPciWriteCfgByte(pAC,Addr,Val);	\
 		else									\
-			SK_OUT8(pAC,PCI_C(Addr),Val);		\
+			SK_OUT8(pAC,PCI_C(pAC,Addr),Val);	\
 		}
 #define VPD_OUT16(pAC,Ioc,Addr,Val) {			\
 		if ((pAC)->DgT.DgUseCfgCycle)			\
 			SkPciWriteCfgWord(pAC,Addr,Val);	\
 		else						\
-			SK_OUT16(pAC,PCI_C(Addr),Val);		\
+			SK_OUT16(pAC,PCI_C(pAC,Addr),Val);	\
 		}
 #define VPD_OUT32(pAC,Ioc,Addr,Val) {			\
 		if ((pAC)->DgT.DgUseCfgCycle)			\
 			SkPciWriteCfgDWord(pAC,Addr,Val);	\
 		else						\
-			SK_OUT32(pAC,PCI_C(Addr),Val); 		\
+			SK_OUT32(pAC,PCI_C(pAC,Addr),Val); \
 		}
 #define VPD_IN8(pAC,Ioc,Addr,pVal) {			\
 		if ((pAC)->DgT.DgUseCfgCycle) 			\
 			SkPciReadCfgByte(pAC,Addr,pVal);	\
 		else						\
-			SK_IN8(pAC,PCI_C(Addr),pVal); 		\
+			SK_IN8(pAC,PCI_C(pAC,Addr),pVal);	\
 		}
 #define VPD_IN16(pAC,Ioc,Addr,pVal) {			\
 		if ((pAC)->DgT.DgUseCfgCycle) 			\
 			SkPciReadCfgWord(pAC,Addr,pVal);	\
 		else						\
-			SK_IN16(pAC,PCI_C(Addr),pVal); 		\
+			SK_IN16(pAC,PCI_C(pAC,Addr),pVal); \
 		}
 #define VPD_IN32(pAC,Ioc,Addr,pVal) {			\
 		if ((pAC)->DgT.DgUseCfgCycle)			\
 			SkPciReadCfgDWord(pAC,Addr,pVal);	\
 		else						\
-			SK_IN32(pAC,PCI_C(Addr),pVal);		\
+			SK_IN32(pAC,PCI_C(pAC,Addr),pVal);	\
 		}
 #endif	/* nSKDIAG */
 
 /* function prototypes ********************************************************/
@@ -239,9 +239,14 @@ extern void	VpdErrLog(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
 	char		*msg);
 
-#ifdef	SKDIAG
+int VpdInit(
+	SK_AC		*pAC,
+	SK_IOC		IoC);
+
+#if defined(SKDIAG) || defined(SK_ASF)
+
 extern int	VpdReadBlock(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
 	char		*buf,
@@ -253,9 +258,11 @@ extern int	VpdWriteBlock(
 	SK_IOC		IoC,
 	char		*buf,
 	int			addr,
 	int			len);
-#endif	/* SKDIAG */
+
+#endif	/* SKDIAG || SK_ASF */
+
 #else	/* SK_KR_PROTO */
 extern SK_U32	VpdReadDWord();
 extern int	VpdSetupPara();
 extern SK_VPD_STATUS	*VpdStat();
Index: linux-2.6.8/drivers/net/sk98lin/h/sky2le.h
===================================================================
--- /dev/null
+++ linux-2.6.8/drivers/net/sk98lin/h/sky2le.h
@@ -0,0 +1,872 @@
+/******************************************************************************
+ *
+ * Name:	sky2le.h
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.7 $
+ * Date:	$Date: 2004/03/04 14:20:51 $
+ * Purpose:	Common list element definitions and access macros.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 2003 Marvell.
+ *	All Rights Reserved
+ *
+ *	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF MARVELL
+ *	The copyright notice above does not evidence any
+ *	actual or intended publication of such source code.
+ *
+ *	This Module contains Proprietary Information of Marvell
+ *	and should be treated as Confidential.
+ *
+ *	The information in this file is provided for the exclusive use of
+ *	the licensees of Marvell.
+ *	Such users have the right to use, modify, and incorporate this code
+ *	into products for purposes authorized by the license agreement
+ *	provided they include this notice and the associated copyright notice
+ *	with any such product.
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+#ifndef __INC_SKY2LE_H
+#define __INC_SKY2LE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif	/* __cplusplus */
+
+
+/* defines ********************************************************************/
+
+#define MIN_LEN_OF_LE_TAB	128
+#define MAX_LEN_OF_LE_TAB	4096
+#ifdef USE_POLLING_UNIT
+#define NUM_LE_POLLING_UNIT	2
+#endif
+#define MAX_FRAG_OVERHEAD       10
+
+/* Macro for aligning a given value */
+#define SK_ALIGN_SIZE(Value, Alignment, AlignedVal)	{						\
+	(AlignedVal) = (((Value) + (Alignment) - 1) & (~((Alignment) - 1)));	\
+}
+
+/******************************************************************************
+ *
+ * LE2DWord() - Converts the given Little Endian value to machine order value
+ *
+ * Description:
+ *	This function converts the Little Endian value received as an argument to
+ *  the machine order value.
+ *
+ * Returns:
+ *	The converted value
+ *
+ */
+
+#ifdef SK_LITTLE_ENDIAN
+
+#define LE2DWord(value)	(value)
+
+#else	/* !SK_LITTLE_ENDIAN */
+
+#define LE2DWord(value)				\
+	((((value)<<24L)&0xff000000L) +	\
+	(((value)<< 8L)&0x00ff0000L) +	\
+	(((value)>> 8L)&0x0000ff00L) +	\
+	(((value)>>24L)&0x000000ffL))
+
+#endif	/* !SK_LITTLE_ENDIAN */
+
+/******************************************************************************
+ *
+ * DWord2LE() - Converts the given value to a Little Endian value
+ *
+ * Description:
+ *	This function converts the value received as an argument to a Little Endian
+ *  value on Big Endian machines. If the machine running the code is Little
+ *  Endian, then no conversion is done.
+ *
+ * Returns:
+ *	The converted value
+ *
+ */
+
+#ifdef SK_LITTLE_ENDIAN
+
+#define DWord2LE(value) (value)
+
+#else	/* !SK_LITTLE_ENDIAN */
+
+#define DWord2LE(value) 			\
+	((((value)<<24L)&0xff000000L) +	\
+	(((value)<< 8L)&0x00ff0000L) +	\
+	(((value)>> 8L)&0x0000ff00L) +	\
+	(((value)>>24L)&0x000000ffL))
+
+#endif	/* !SK_LITTLE_ENDIAN */
+
+/******************************************************************************
+ *
+ * LE2Word() - Converts the given Little Endian value to machine order value
+ *
+ * Description:
+ *	This function converts the Little Endian value received as an argument to
+ *  the machine order value.
+ *
+ * Returns:
+ *	The converted value
+ *
+ */
+
+#ifdef SK_LITTLE_ENDIAN
+
+#define LE2Word(value) (value)
+
+#else	/* !SK_LITTLE_ENDIAN */
+
+#define LE2Word(value)			\
+	((((value)<< 8L)&0xff00) +	\
+	(((value)>> 8L)&0x00ff))
+
+#endif	/* !SK_LITTLE_ENDIAN */
+
+/******************************************************************************
+ *
+ * Word2LE() - Converts the given value to a Little Endian value
+ *
+ * Description:
+ *	This function converts the value received as an argument to a Little Endian
+ *  value on Big Endian machines. If the machine running the code is Little
+ *  Endian, then no conversion is done.
+ *
+ * Returns:
+ *	The converted value
+ *
+ */
+
+#ifdef SK_LITTLE_ENDIAN
+
+#define Word2LE(value) (value)
+
+#else	/* !SK_LITTLE_ENDIAN */
+
+#define Word2LE(value) 			\
+	((((value)<< 8L)&0xff00) +	\
+	(((value)>> 8L)&0x00ff))
+
+#endif	/* !SK_LITTLE_ENDIAN */
+
+/******************************************************************************
+ *
+ * Transmit list element macros
+ *
+ */
+
+#define TXLE_SET_ADDR(pLE, Addr)	\
+	((pLE)->Tx.TxUn.BufAddr = DWord2LE(Addr))
+#define TXLE_SET_LSLEN(pLE, Len)	\
+	((pLE)->Tx.TxUn.LargeSend.Length = Word2LE(Len))
+#define TXLE_SET_STACS(pLE, Start)	\
+	((pLE)->Tx.TxUn.ChkSum.TxTcpSp = Word2LE(Start))
+#define TXLE_SET_WRICS(pLE, Write)	\
+	((pLE)->Tx.TxUn.ChkSum.TxTcpWp = Word2LE(Write))
+#define TXLE_SET_INICS(pLE, Ini)	((pLE)->Tx.Send.InitCsum = Word2LE(Ini))
+#define TXLE_SET_LEN(pLE, Len)		((pLE)->Tx.Send.BufLen = Word2LE(Len))
+#define TXLE_SET_VLAN(pLE, Vlan)	((pLE)->Tx.Send.VlanTag = Word2LE(Vlan))
+#define TXLE_SET_LCKCS(pLE, Lock)	((pLE)->Tx.ControlFlags = (Lock))
+#define TXLE_SET_CTRL(pLE, Ctrl)	((pLE)->Tx.ControlFlags = (Ctrl))
+#define TXLE_SET_OPC(pLE, Opc)		((pLE)->Tx.Opcode = (Opc))
+
+
+#define TXLE_GET_ADDR(pLE)		LE2DWord((pLE)->Tx.TxUn.BufAddr)
+#define TXLE_GET_LSLEN(pLE)		LE2Word((pLE)->Tx.TxUn.LargeSend.Length)
+#define TXLE_GET_STACS(pLE)		LE2Word((pLE)->Tx.TxUn.ChkSum.TxTcpSp)
+#define TXLE_GET_WRICS(pLE)		LE2Word((pLE)->Tx.TxUn.ChkSum.TxTcpWp)
+#define TXLE_GET_INICS(pLE)		LE2Word((pLE)->Tx.Send.InitCsum)
+#define TXLE_GET_LEN(pLE) 		LE2Word((pLE)->Tx.Send.BufLen)
+#define TXLE_GET_VLAN(pLE)		LE2Word((pLE)->Tx.Send.VlanTag)
+#define TXLE_GET_LCKCS(pLE)		((pLE)->Tx.ControlFlags)
+#define TXLE_GET_CTRL(pLE)		((pLE)->Tx.ControlFlags)
+#define TXLE_GET_OPC(pLE)		((pLE)->Tx.Opcode)
+
+/******************************************************************************
+ *
+ * Receive list element macros
+ *
+ */
+
+#define RXLE_SET_ADDR(pLE, Addr)	\
+	((pLE)->Rx.RxUn.BufAddr = (SK_U32) DWord2LE(Addr))
+#define RXLE_SET_STACS2(pLE, Offs)	\
+	((pLE)->Rx.RxUn.ChkSum.RxTcpSp2 = Word2LE(Offs))
+#define RXLE_SET_STACS1(pLE, Offs)	\
+	((pLE)->Rx.RxUn.ChkSum.RxTcpSp1 = Word2LE(Offs))
+#define RXLE_SET_LEN(pLE, Len)		((pLE)->Rx.BufferLength = Word2LE(Len))
+#define RXLE_SET_CTRL(pLE, Ctrl)	((pLE)->Rx.ControlFlags = (Ctrl))
+#define RXLE_SET_OPC(pLE, Opc)		((pLE)->Rx.Opcode = (Opc))
+
+
+#define RXLE_GET_ADDR(pLE)		LE2DWord((pLE)->Rx.RxUn.BufAddr)
+#define RXLE_GET_STACS2(pLE)	LE2Word((pLE)->Rx.RxUn.ChkSum.RxTcpSp2)
+#define RXLE_GET_STACS1(pLE)	LE2Word((pLE)->Rx.RxUn.ChkSum.RxTcpSp1)
+#define RXLE_GET_LEN(pLE) 		LE2Word((pLE)->Rx.BufferLength)
+#define RXLE_GET_CTRL(pLE)		((pLE)->Rx.ControlFlags)
+#define RXLE_GET_OPC(pLE)		((pLE)->Rx.Opcode)
+
+/******************************************************************************
+ *
+ * Status list element macros
+ *
+ */
+
+#define STLE_SET_OPC(pLE, Opc)		((pLE)->St.Opcode = (Opc))
+
+#define STLE_GET_FRSTATUS(pLE)	LE2DWord((pLE)->St.StUn.StRxStatWord)
+#define STLE_GET_TIST(pLE)		LE2DWord((pLE)->St.StUn.StRxTimeStamp)
+#define STLE_GET_TCP1(pLE)		LE2Word((pLE)->St.StUn.StRxTCPCSum.RxTCPSum1)
+#define STLE_GET_TCP2(pLE)		LE2Word((pLE)->St.StUn.StRxTCPCSum.RxTCPSum2)
+#define STLE_GET_LEN(pLE)		LE2Word((pLE)->St.Stat.BufLen)
+#define STLE_GET_VLAN(pLE)		LE2Word((pLE)->St.Stat.VlanTag)
+#define STLE_GET_LINK(pLE)		((pLE)->St.Link)
+#define STLE_GET_OPC(pLE)		((pLE)->St.Opcode)
+#define STLE_GET_DONE_IDX(pLE,LowVal,HighVal) {			\
+	(LowVal) = LE2DWord((pLE)->St.StUn.StTxStatLow);	\
+	(HighVal) = LE2Word((pLE)->St.Stat.StTxStatHi);		\
+}
+
+#define STLE_GET_RSS(pLE)		LE2DWord((pLE)->St.StUn.StRxRssValue)
+#define STLE_GET_IPBIT(pLE)		((pLE)->St.Stat.Rss.FlagField & RSS_IP_FLAG)
+#define STLE_GET_TCPBIT(pLE)	((pLE)->St.Stat.Rss.FlagField & RSS_TCP_FLAG)
+
+
+/* I always take both values as a paramter to avoid typos */
+#define STLE_GET_DONE_IDX_TXA1(LowVal,HighVal)			\
+	(((LowVal) & STLE_TXA1_MSKL) >> STLE_TXA1_SHIFTL)
+#define STLE_GET_DONE_IDX_TXS1(LowVal,HighVal)			\
+	((LowVal & STLE_TXS1_MSKL) >> STLE_TXS1_SHIFTL)
+#define STLE_GET_DONE_IDX_TXA2(LowVal,HighVal)			\
+	(((LowVal & STLE_TXA2_MSKL) >> STLE_TXA2_SHIFTL) + 	\
+	((HighVal & STLE_TXA2_MSKH) << STLE_TXA2_SHIFTH))
+#define STLE_GET_DONE_IDX_TXS2(LowVal,HighVal)			\
+	((HighVal & STLE_TXS2_MSKL) >> STLE_TXS2_SHIFTL)
+
+
+#define SK_Y2_RXSTAT_CHECK_PKT(Len, RxStat, IsOk) {				\
+	(IsOk) = (((RxStat) & GMR_FS_RX_OK) == GMR_FS_RX_OK) &&		\
+			 (((RxStat) & GMR_FS_ANY_ERR) == 0);				\
+																\
+	if ((IsOk) && ((SK_U16)(((RxStat) & GMR_FS_LEN_MSK) >>  	\
+		GMR_FS_LEN_SHIFT) != (Len))) {							\
+		/* length in MAC status differs from length in LE */	\
+		(IsOk) = SK_FALSE;										\
+	}															\
+}
+
+
+/******************************************************************************
+ *
+ * Polling unit list element macros
+ *
+ * NOTE: the Idx must be <= 0xfff and PU_PUTIDX_VALID makes them valid
+ *
+ */
+
+#ifdef USE_POLLING_UNIT
+
+#define POLE_SET_OPC(pLE, Opc)		((pLE)->Sa.Opcode = (Opc))
+#define POLE_SET_LINK(pLE, Port)	((pLE)->Sa.Link = (Port))
+#define POLE_SET_RXIDX(pLE, Idx)	((pLE)->Sa.RxIdxVld = Word2LE(Idx))
+#define POLE_SET_TXAIDX(pLE, Idx)	((pLE)->Sa.TxAIdxVld = Word2LE(Idx))
+#define POLE_SET_TXSIDX(pLE, Idx)	((pLE)->Sa.TxSIdxVld = Word2LE(Idx))
+
+#define POLE_GET_OPC(pLE)		((pLE)->Sa.Opcode)
+#define POLE_GET_LINK(pLE)		((pLE)->Sa.Link)
+#define POLE_GET_RXIDX(pLE)		LE2Word((pLE)->Sa.RxIdxVld)
+#define POLE_GET_TXAIDX(pLE)	LE2Word((pLE)->Sa.TxAIdxVld)
+#define POLE_GET_TXSIDX(pLE)	LE2Word((pLE)->Sa.TxSIdxVld)
+
+#endif	/* USE_POLLING_UNIT */
+
+/******************************************************************************
+ *
+ * Debug macros for list elements
+ *
+ */
+
+#ifdef DEBUG
+
+#define SK_DBG_DUMP_RX_LE(pLE)	{										\
+	SK_U8	Opcode;														\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("=== RX_LIST_ELEMENT @addr: %p cont: %02x %02x %02x %02x %02x %02x %02x %02x\n",	\
+		pLE, ((SK_U8 *) pLE)[0], ((SK_U8 *) pLE)[1], ((SK_U8 *) pLE)[2],\
+		((SK_U8 *) pLE)[3], ((SK_U8 *) pLE)[4], ((SK_U8 *) pLE)[5],		\
+		((SK_U8 *) pLE)[6], ((SK_U8 *) pLE)[7])); 						\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\t (16bit) %04x %04x %04x %04x\n",							\
+		((SK_U16 *) pLE)[0], ((SK_U16 *) pLE)[1], ((SK_U16 *) pLE)[2],	\
+		((SK_U16 *) pLE)[3])); 											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\t (32bit) %08x %08x\n",										\
+		((SK_U32 *) pLE)[0], ((SK_U32 *) pLE)[1])); 					\
+	Opcode = RXLE_GET_OPC(pLE);											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					   	\
+		("\tOwn belongs to %s\n", ((Opcode & HW_OWNER) == HW_OWNER) ? 	\
+		 "Hardware" : "Software"));										\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\tOpc: 0x%x ",Opcode));								   		\
+	switch (Opcode & (~HW_OWNER)) {									  	\
+	case OP_BUFFER:														\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   		\
+			("\tOP_BUFFER\n"));									   		\
+		break;															\
+	case OP_PACKET:									  	  	   			\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   		\
+			("\tOP_PACKET\n"));								   			\
+		break;															\
+	case OP_ADDR64:												   		\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_ADDR64\n"));								   			\
+		break;															\
+	case OP_TCPSTART:												   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_TCPPAR\n"));									   		\
+		break;															\
+	case SW_OWNER:														\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   		\
+			("\tunused LE\n"));									   		\
+		break;															\
+	default:														   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tunknown Opcode!!!\n"));								   	\
+		break;															\
+	}																	\
+	if ((Opcode & OP_BUFFER) == OP_BUFFER) {							\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tControl: 0x%x\n", RXLE_GET_CTRL(pLE)));					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tBufLen: 0x%x\n", RXLE_GET_LEN(pLE)));					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tLowAddr: 0x%x\n", RXLE_GET_ADDR(pLE)));					\
+	}																	\
+	if ((Opcode & OP_ADDR64) == OP_ADDR64) {							\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tHighAddr: 0x%x\n", RXLE_GET_ADDR(pLE)));				\
+	}																	\
+	if ((Opcode & OP_TCPSTART) == OP_TCPSTART) {	  		  			\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tTCP Sum Start 1 : 0x%x\n", RXLE_GET_STACS1(pLE)));		\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tTCP Sum Start 2 : 0x%x\n", RXLE_GET_STACS2(pLE)));		\
+	}																	\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("=====================\n"));									\
+}
+
+#define SK_DBG_DUMP_TX_LE(pLE)	{										\
+	SK_U8	Opcode;														\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("=== TX_LIST_ELEMENT @addr: %p cont: %02x %02x %02x %02x %02x %02x %02x %02x\n",	\
+		pLE, ((SK_U8 *) pLE)[0], ((SK_U8 *) pLE)[1], ((SK_U8 *) pLE)[2],\
+		((SK_U8 *) pLE)[3], ((SK_U8 *) pLE)[4], ((SK_U8 *) pLE)[5],		\
+		((SK_U8 *) pLE)[6], ((SK_U8 *) pLE)[7])); 						\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\t (16bit) %04x %04x %04x %04x\n",							\
+		((SK_U16 *) pLE)[0], ((SK_U16 *) pLE)[1], ((SK_U16 *) pLE)[2],	\
+		((SK_U16 *) pLE)[3])); 											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\t (32bit) %08x %08x\n",										\
+		((SK_U32 *) pLE)[0], ((SK_U32 *) pLE)[1])); 					\
+	Opcode = TXLE_GET_OPC(pLE);										   	\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					   	\
+		("\tOwn belongs to %s\n", ((Opcode & HW_OWNER) == HW_OWNER) ? 	\
+		"Hardware" : "Software"));										\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					   	\
+		("\tOpc: 0x%x ",Opcode));								   		\
+	switch (Opcode & (~HW_OWNER)) {									   	\
+	case OP_TCPCHKSUM:										 	      	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_TCPCHKSUM\n"));									   	\
+		break;											   		 		\
+	case OP_TCPIS:										  		  	   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_TCPIS\n"));										   	\
+		break;												  		  	\
+	case OP_TCPLCK:													   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,		   	    	\
+			("\tOP_TCPLCK\n"));								   	    	\
+		break;												   		 	\
+	case OP_TCPLW:													   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,		   	    	\
+			("\tOP_TCPLW\n"));								   	    	\
+		break;															\
+	case OP_TCPLSW:													   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_TCPLSW\n"));										   	\
+		break;															\
+	case OP_TCPLISW:												   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_TCPLISW\n"));						 		   	   	\
+		break;											 		   		\
+	case OP_ADDR64:										 		   	   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,	  	     	   	\
+			("\tOP_ADDR64\n"));										   	\
+		break;															\
+	case OP_VLAN:													   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   		\
+			("\tOP_VLAN\n"));										   	\
+		break;															\
+	case OP_ADDR64VLAN:												   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_ADDR64VLAN\n"));								   		\
+		break;															\
+	case OP_LRGLEN:													   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_LRGLEN\n"));										   	\
+		break;															\
+	case OP_LRGLENVLAN:												   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   		\
+			("\tOP_LRGLENVLAN\n"));									   	\
+		break;															\
+	case OP_BUFFER:													   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_BUFFER\n"));									   		\
+		break;															\
+	case OP_PACKET:												   		\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_PACKET\n"));										   	\
+		break;															\
+	case OP_LARGESEND:													\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   		\
+			("\tOP_LARGESEND\n"));									   	\
+		break;															\
+	case SW_OWNER:														\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   		\
+			("\tunused LE\n"));										   	\
+		break;															\
+	default:														   	\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tunknown Opcode!!!\n"));								   	\
+		break;															\
+	}																	\
+	if ((Opcode & OP_BUFFER) == OP_BUFFER) {							\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tControl: 0x%x\n", TXLE_GET_CTRL(pLE)));					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tBufLen: 0x%x\n", TXLE_GET_LEN(pLE)));					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tLowAddr: 0x%x\n", TXLE_GET_ADDR(pLE)));					\
+	}																	\
+	if ((Opcode & OP_ADDR64) == OP_ADDR64) {							\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tHighAddr: 0x%x\n", TXLE_GET_ADDR(pLE)));				\
+	}																	\
+	if ((Opcode & OP_VLAN) == OP_VLAN) {								\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tVLAN Id: 0x%x\n", TXLE_GET_VLAN(pLE)));					\
+	}																	\
+	if ((Opcode & OP_LRGLEN) == OP_LRGLEN) {				   			\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tLarge send length: 0x%x\n", TXLE_GET_LSLEN(pLE)));		\
+	}																	\
+	if ((Opcode &(~HW_OWNER)) <= OP_ADDR64) {							\
+		if ((Opcode & OP_TCPWRITE) == OP_TCPWRITE) {					\
+			SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				\
+				("\tTCP Sum Write: 0x%x\n", TXLE_GET_WRICS(pLE)));		\
+		}																\
+		if ((Opcode & OP_TCPSTART) == OP_TCPSTART) {					\
+			SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				\
+				("\tTCP Sum Start: 0x%x\n", TXLE_GET_STACS(pLE)));		\
+		}																\
+		if ((Opcode & OP_TCPINIT) == OP_TCPINIT) {					  	\
+			SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				\
+				("\tTCP Sum Init: 0x%x\n", TXLE_GET_INICS(pLE)));		\
+		}																\
+		if ((Opcode & OP_TCPLCK) == OP_TCPLCK) {					  	\
+			SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				\
+				("\tTCP Sum Lock: 0x%x\n", TXLE_GET_LCKCS(pLE)));		\
+		}																\
+	}																	\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("=====================\n"));									\
+}
+	
+#define SK_DBG_DUMP_ST_LE(pLE)	{ 										\
+	SK_U8	Opcode;														\
+	SK_U16	HighVal;													\
+	SK_U32	LowVal;														\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("=== ST_LIST_ELEMENT @addr: %p contains: %02x %02x %02x %02x %02x %02x %02x %02x\n",	\
+		pLE, ((SK_U8 *) pLE)[0], ((SK_U8 *) pLE)[1], ((SK_U8 *) pLE)[2],\
+		((SK_U8 *) pLE)[3], ((SK_U8 *) pLE)[4], ((SK_U8 *) pLE)[5],		\
+		((SK_U8 *) pLE)[6], ((SK_U8 *) pLE)[7])); 						\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\t (16bit) %04x %04x %04x %04x\n",							\
+		((SK_U16 *) pLE)[0], ((SK_U16 *) pLE)[1], ((SK_U16 *) pLE)[2],	\
+		((SK_U16 *) pLE)[3])); 											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\t (32bit) %08x %08x\n",										\
+		((SK_U32 *) pLE)[0], ((SK_U32 *) pLE)[1])); 					\
+	Opcode = STLE_GET_OPC(pLE);											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					   	\
+		("\tOwn belongs to %s\n", ((Opcode & HW_OWNER) == SW_OWNER) ? 	\
+		"Hardware" : "Software"));										\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\tOpc: 0x%x",	Opcode));										\
+	Opcode &= (~HW_OWNER);												\
+	switch (Opcode) {													\
+	case OP_RXSTAT:										 	     		\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_RXSTAT\n"));								   			\
+		break;															\
+	case OP_RXTIMESTAMP:												\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_RXTIMESTAMP\n"));									\
+		break;															\
+	case OP_RXVLAN:											  			\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_RXVLAN\n"));										   	\
+		break;															\
+	case OP_RXCHKS:											  			\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,	 		   	   	\
+			("\tOP_RXCHKS\n"));										   	\
+		break;											 		   		\
+	case OP_RXCHKSVLAN:									 	     		\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,	 		   	   	\
+			("\tOP_RXCHKSVLAN\n"));						 		   	   	\
+		break;											 		   		\
+	case OP_RXTIMEVLAN:									 	     		\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,	   		 	   	\
+			("\tOP_RXTIMEVLAN\n"));						   		 	   	\
+		break;											   		 		\
+	case OP_RSS_HASH:											  		\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_RSS_HASH\n"));									   	\
+		break;															\
+	case OP_TXINDEXLE:											  		\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tOP_TXINDEXLE\n"));						  		  	   	\
+		break;															\
+	case HW_OWNER:											  			\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tunused LE\n"));						  		  	   		\
+		break;															\
+	default:												  			\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tunknown status list element!!!\n"));				   	\
+		break;															\
+	}																	\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\tPort: %c\n", 'A' + STLE_GET_LINK(pLE)));					\
+	if (Opcode == OP_RXSTAT) {											\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tFrameLen: 0x%x\n", STLE_GET_LEN(pLE)));					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tFrameStat: 0x%x\n", STLE_GET_FRSTATUS(pLE)));			\
+	}																	\
+	if ((Opcode & OP_RXVLAN) == OP_RXVLAN) {							\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tVLAN Id: 0x%x\n", STLE_GET_VLAN(pLE)));					\
+	}																	\
+	if ((Opcode & OP_RXTIMESTAMP) == OP_RXTIMESTAMP) {					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tTimestamp: 0x%x\n", STLE_GET_TIST(pLE)));				\
+	}																	\
+	if ((Opcode & OP_RXCHKS) == OP_RXCHKS) {							\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tTCP: 0x%x 0x%x\n", STLE_GET_TCP1(pLE),					\
+			STLE_GET_TCP2(pLE)));										\
+	}																	\
+	if (Opcode == OP_TXINDEXLE) {										\
+		STLE_GET_DONE_IDX(pLE, LowVal, HighVal);						\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tTx Index TxA1: 0x%x\n",									\
+			STLE_GET_DONE_IDX_TXA1(LowVal,HighVal)));					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tTx Index TxS1: 0x%x\n",									\
+			STLE_GET_DONE_IDX_TXS1(LowVal,HighVal)));					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tTx Index TxA2: 0x%x\n",									\
+			STLE_GET_DONE_IDX_TXA2(LowVal,HighVal)));					\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,					\
+			("\tTx Index TxS2: 0x%x\n",									\
+			STLE_GET_DONE_IDX_TXS2(LowVal,HighVal)));					\
+	}																	\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("=====================\n"));									\
+}
+
+#ifdef USE_POLLING_UNIT
+#define SK_DBG_DUMP_PO_LE(pLE)	{										\
+	SK_U8	Opcode;														\
+	SK_U16	Idx;														\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("=== PO_LIST_ELEMENT @addr: %p cont: %02x %02x %02x %02x %02x %02x %02x %02x\n",	\
+		pLE, ((SK_U8 *) pLE)[0], ((SK_U8 *) pLE)[1], ((SK_U8 *) pLE)[2],\
+		((SK_U8 *) pLE)[3], ((SK_U8 *) pLE)[4], ((SK_U8 *) pLE)[5],		\
+		((SK_U8 *) pLE)[6], ((SK_U8 *) pLE)[7])); 						\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\t (16bit) %04x %04x %04x %04x\n",							\
+		((SK_U16 *) pLE)[0], ((SK_U16 *) pLE)[1], ((SK_U16 *) pLE)[2],	\
+		((SK_U16 *) pLE)[3])); 											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("\t (32bit) %08x %08x\n",										\
+		((SK_U32 *) pLE)[0], ((SK_U32 *) pLE)[1])); 					\
+	Opcode = POLE_GET_OPC(pLE);											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		 ("\tOwn belongs to %s\n", ((Opcode & HW_OWNER) == HW_OWNER) ? 	\
+		  "Hardware" : "Software"));									\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		 ("\tOpc: 0x%x ",Opcode));										\
+	if ((Opcode & ~HW_OWNER) == OP_PUTIDX) {							\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   		\
+			("\tOP_PUTIDX\n"));								   			\
+	}																	\
+	else {																\
+		SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,				   	\
+			("\tunknown Opcode!!!\n"));								   	\
+	}																	\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   			\
+		("\tPort %c\n", 'A' + POLE_GET_LINK(pLE)));						\
+	Idx = POLE_GET_TXAIDX(pLE);											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   			\
+		("\tTxA Index is 0x%X and %svalid\n", Idx,						\
+		(Idx & PU_PUTIDX_VALID) ? "" : "not "));						\
+	Idx = POLE_GET_TXSIDX(pLE);											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   			\
+		("\tTxS Index is 0x%X and %svalid\n", Idx,						\
+		(Idx & PU_PUTIDX_VALID) ? "" : "not "));						\
+	Idx = POLE_GET_RXIDX(pLE);											\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,			   			\
+		("\tRx Index is 0x%X and %svalid\n", Idx,						\
+		(Idx & PU_PUTIDX_VALID) ? "" : "not "));						\
+	SK_DBG_MSG(pAc, SK_DBGMOD_HWM, SK_DBGCAT_INIT,						\
+		("=====================\n"));									\
+}
+#endif	/* USE_POLLING_UNIT */
+
+#else	/* !DEBUG */
+
+#define SK_DBG_DUMP_RX_LE(pLE)
+#define SK_DBG_DUMP_TX_LE(pLE)
+#define SK_DBG_DUMP_ST_LE(pLE)
+#define SK_DBG_DUMP_PO_LE(pLE)
+
+#endif	/* !DEBUG */
+
+/******************************************************************************
+ *
+ * Macros for listelement tables
+ *
+ *
+ */
+
+#define LE_SIZE sizeof(SK_HWLE)
+#define LE_TAB_SIZE(NumElements)	((NumElements) * LE_SIZE)
+
+/* Number of unused list elements in table
+ * this macro always returns the number of free listelements - 1
+ * this way we want to guarantee that always one LE remains unused
+ */
+#define NUM_FREE_LE_IN_TABLE(pTable) 									\
+	( ((pTable)->Put >= (pTable)->Done) ?									\
+	(NUM_LE_IN_TABLE(pTable) - (pTable)->Put + (pTable)->Done - 1) :	\
+	((pTable)->Done - (pTable)->Put - 1) )
+
+/* total number of list elements in table */
+#define NUM_LE_IN_TABLE(pTable)		((pTable)->Num)
+	
+/* get next unused rx list element */
+#define GET_RX_LE(pLE, pTable) {										\
+	pLE = &(pTable)->pLETab[(pTable)->Put];								\
+	(pTable)->Put = ((pTable)->Put + 1) % NUM_LE_IN_TABLE(pTable);		\
+}
+	
+/* get next unused tx list element */
+#define GET_TX_LE(pLE, pTable)	GET_RX_LE(pLE, pTable)
+
+/* get next status list element expected to be finished by hw */
+#define GET_ST_LE(pLE, pTable) {										\
+	pLE = &(pTable)->pLETab[(pTable)->Done];							\
+	(pTable)->Done = ((pTable)->Done +1) % NUM_LE_IN_TABLE(pTable);		\
+}
+
+#ifdef USE_POLLING_UNIT
+/* get next polling unit list element for port */
+#define GET_PO_LE(pLE, pTable, Port) {									\
+	pLE = &(pTable)->pLETab[(Port)];									\
+}
+#endif	/* USE_POLLING_UNIT */
+
+#define GET_PUT_IDX(pTable)			((pTable)->Put)
+
+#define UPDATE_HWPUT_IDX(pTable)	{(pTable)->HwPut = (pTable)->Put; }
+
+/*
+ * get own bit of next status LE
+ * if the result is != 0 there has been at least one status LE finished
+ */
+#define OWN_OF_FIRST_LE(pTable)											\
+	(STLE_GET_OPC(&(pTable)->pLETab[(pTable)->Done]) & HW_OWNER)
+
+#define SET_DONE_INDEX(pTable, Idx)	(pTable)->Done = (Idx);
+
+#define GET_DONE_INDEX(pTable)	((pTable)->Done)
+
+#ifdef SAFE_BUT_SLOW
+
+/* check own bit of LE before current done idx */
+#define CHECK_STLE_OVERFLOW(pTable, IsOk) {						\
+		unsigned i;												\
+		if ((i = (pTable)->Done) == 0) {						\
+			i = NUM_LE_IN_TABLE(pTable);						\
+		}														\
+		else {													\
+			i = i - 1; 											\
+		}														\
+		if (STLE_GET_OPC(&(pTable)->pLETab[i]) == HW_OWNER) {	\
+			(IsOk) = SK_TRUE;									\
+		}														\
+		else {													\
+			(IsOk) = SK_FALSE;									\
+		}														\
+	}
+
+
+/*
+ * for Yukon2 the hardware is not polling the list elements, so it
+ * is not necessary to change the own-bit of rx or tx-LEs before
+ * reusing them
+ * but it might make debugging easier if one simply can see whether
+ * a LE has been worked on
+ */
+	
+#define CLEAR_LE_OWN(pTable, Idx)								\
+	STLE_SET_OPC(&(pTable)->pLETab[(Idx)], SW_OWNER)
+
+/*
+ * clear all own bits starting from old done index up to the LE before
+ * the new done index
+ */
+#define CLEAR_LE_OWN_FROM_DONE_TO(pTable, To) {					\
+		int i;													\
+		i = (pTable)->Done;										\
+		while (i != To) {										\
+			CLEAR_LE_OWN(pTable, i);							\
+			i = (i + 1) % NUM_LE_IN_TABLE(pTable);				\
+		}														\
+	}
+
+#else	/* !SAFE_BUT_SLOW */
+
+#define CHECK_STLE_OVERFLOW(pTable, IsOk)
+#define CLEAR_LE_OWN(pTable, Idx)
+#define CLEAR_LE_OWN_FROM_DONE_TO(pTable, To)
+
+#endif	/* !SAFE_BUT_SLOW */
+
+
+/* typedefs *******************************************************************/
+
+typedef struct s_LetRxTx {
+	SK_U16	VlanId;			/* VLAN Id given down last time */
+	SK_U16	TcpWp;			/* TCP Checksum Write Position */
+	SK_U16	TcpSp1;			/* TCP Checksum Calculation Start Position 1 */
+	SK_U16	TcpSp2;			/* TCP Checksum Calculation Start Position 2 */
+	SK_U16	MssValue;		/* Maximum Segment Size */
+	SK_U16	Reserved1;		/* reserved word for furture extensions */
+	SK_U16	Reserved2;		/* reserved word for furture extensions */
+	SK_U16	Reserved3;		/* reserved word for furture extensions */
+} SK_LET_RX_TX;
+
+typedef struct s_LetStat {
+	SK_U32	RxTimeStamp;	/* Receive Timestamp */
+	SK_U32	RssHashValue;	/* RSS Hash Value */
+	SK_BOOL	RssIsIp;		/* RSS Hash Value: IP packet detected */
+	SK_BOOL	RssIsTcp;		/* RSS Hash Value: IP+TCP packet detected */
+	SK_U16	VlanId;			/* VLAN Id given received by Status BMU */
+	SK_U16	TcpSum1;		/* TCP checksum 1 (status BMU) */
+	SK_U16	TcpSum2;		/* TCP checksum 2 (status BMU) */
+} SK_LET_STAT;
+
+
+typedef union s_LetBmuSpec {
+	SK_LET_RX_TX	RxTx;	/* Rx/Tx BMU specific variables */
+	SK_LET_STAT		Stat;	/* Status BMU specific variables */
+} SK_LET_BMU_S;
+
+
+
+typedef	struct s_le_table SK_LE_TABLE;
+
+struct s_le_table {
+	/* all LE's between Done and HWPut are owned by the hardware */
+	/* all LE's between Put and Done can be used from Software */
+	/* all LE's between HWPut and Put are currently processed in DriverSend */
+	unsigned Done;			/* done index - consumed from HW and available */
+	unsigned Put;			/* put index - to be given to hardware */
+	unsigned HwPut;			/* put index actually given to hardware */
+	unsigned Num;			/* total number of list elements */
+	SK_HWLE *pLETab;		/* virtual address of list element table */
+	SK_U32	pPhyLETABLow;	/* physical address of list element table */
+	SK_U32	pPhyLETABHigh;	/* physical address of list element table */
+	/* values to remember in order to save some LEs */
+	SK_U32	BufHighAddr;	/* high addr given down last time */
+	SK_LET_BMU_S Bmu;		/* contains BMU specific information */
+	SK_U32	private;		/* driver private variable free usable */
+	SK_U16	TcpInitCsum;	/* Init. Checksum */
+};
+
+/* function prototypes ********************************************************/
+
+#ifndef	SK_KR_PROTO
+
+/*
+ * public functions in sky2le.c
+ */
+extern void SkGeY2SetPutIndex(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_U32 StartAddrPrefetchUnit,
+	SK_LE_TABLE *pLETab);
+
+extern void SkGeY2InitPrefetchUnit(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Queue,
+	SK_LE_TABLE *pLETab);
+
+extern void SkGeY2InitStatBmu(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_LE_TABLE *pLETab);
+
+extern void SkGeY2InitPollUnit(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_LE_TABLE *pLETab);
+
+extern void SkGeY2InitSingleLETable(
+	SK_AC	*pAC,
+	SK_LE_TABLE *pLETab,
+	unsigned int NumLE,
+	void	*pVMem,
+	SK_U32	PMemLowAddr,
+	SK_U32	PMemHighAddr);
+
+#else	/* SK_KR_PROTO */
+extern void SkGeY2SetPutIndex();
+extern void SkGeY2InitPrefetchUnit();
+extern void SkGeY2InitStatBmu();
+extern void SkGeY2InitPollUnit();
+extern void SkGeY2InitSingleLETable();
+#endif	/* SK_KR_PROTO */
+
+#ifdef __cplusplus
+}
+#endif	/* __cplusplus */
+
+#endif	/* __INC_SKY2LE_H */
+
Index: linux-2.6.8/drivers/net/sk98lin/h/xmac_ii.h
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/h/xmac_ii.h
+++ linux-2.6.8/drivers/net/sk98lin/h/xmac_ii.h
@@ -1,24 +1,23 @@
 /******************************************************************************
  *
  * Name:	xmac_ii.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.52 $
- * Date:	$Date: 2003/10/02 16:35:50 $
+ * Version:	$Revision: 2.5 $
+ * Date:	$Date: 2004/05/18 14:51:43 $
  * Purpose:	Defines and Macros for Gigabit Ethernet Controller
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
@@ -448,9 +447,9 @@ extern "C" {
 
 /*
  * Receive Frame Status Encoding
  */
-#define XMR_FS_LEN	(0x3fffUL<<18)	/* Bit 31..18:	Rx Frame Length */
+#define XMR_FS_LEN_MSK	(0x3fffUL<<18)	/* Bit 31..18:	Rx Frame Length */
 #define XMR_FS_2L_VLAN	(1L<<17)	/* Bit 17:	tagged wh 2Lev VLAN ID*/
 #define XMR_FS_1L_VLAN	(1L<<16)	/* Bit 16:	tagged wh 1Lev VLAN ID*/
 #define XMR_FS_BC		(1L<<15)	/* Bit 15:	Broadcast Frame */
 #define XMR_FS_MC		(1L<<14)	/* Bit 14:	Multicast Frame */
@@ -468,8 +467,10 @@ extern "C" {
 #define XMR_FS_FCS_ERR	(1L<<2)		/* Bit  2:	Frame Check Sequ Err */
 #define XMR_FS_ERR		(1L<<1)		/* Bit  1:	Frame Error */
 #define XMR_FS_MCTRL	(1L<<0)		/* Bit  0:	MAC Control Packet */
 
+#define XMR_FS_LEN_SHIFT	18
+
 /*
  * XMR_FS_ERR will be set if
  *	XMR_FS_FCS_ERR, XMR_FS_LNG_ERR, XMR_FS_RUNT,
  *	XMR_FS_FRA_ERR, XMR_FS_LEN_ERR, or XMR_FS_CEX_ERR
@@ -509,9 +510,9 @@ extern "C" {
 #define PHY_BCOM_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
 #define PHY_BCOM_NEPG		0x07	/* 16 bit r/w	Next Page Register */
 #define PHY_BCOM_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner */
 	/* Broadcom-specific registers */
-#define PHY_BCOM_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Ctrl Reg */
+#define PHY_BCOM_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg */
 #define PHY_BCOM_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
 	/* 0x0b - 0x0e:		reserved */
 #define PHY_BCOM_EXT_STAT	0x0f	/* 16 bit r/o	Extended Status Reg */
 #define PHY_BCOM_P_EXT_CTRL	0x10	/* 16 bit r/w	PHY Extended Ctrl Reg */
@@ -540,9 +541,9 @@ extern "C" {
 #define PHY_MARV_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
 #define PHY_MARV_NEPG		0x07	/* 16 bit r/w	Next Page Register */
 #define PHY_MARV_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner */
 	/* Marvel-specific registers */
-#define PHY_MARV_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Ctrl Reg */
+#define PHY_MARV_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg */
 #define PHY_MARV_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
 	/* 0x0b - 0x0e:		reserved */
 #define PHY_MARV_EXT_STAT	0x0f	/* 16 bit r/o	Extended Status Reg */
 #define PHY_MARV_PHY_CTRL	0x10	/* 16 bit r/w	PHY Specific Ctrl Reg */
@@ -573,9 +574,9 @@ extern "C" {
 #define PHY_LONE_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
 #define PHY_LONE_NEPG		0x07	/* 16 bit r/w	Next Page Register */
 #define PHY_LONE_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner */
 	/* Level One-specific registers */
-#define PHY_LONE_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg*/
+#define PHY_LONE_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg */
 #define PHY_LONE_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
 	/* 0x0b -0x0e:		reserved */
 #define PHY_LONE_EXT_STAT	0x0f	/* 16 bit r/o	Extended Status Reg */
 #define PHY_LONE_PORT_CFG	0x10	/* 16 bit r/w	Port Configuration Reg*/
@@ -617,9 +618,9 @@ extern "C" {
 /*----------------------------------------------------------------------------*/
 
 /*
  * PHY bit definitions
- * Bits defined as PHY_X_..., PHY_B_..., PHY_L_... or PHY_N_... are
+ * Bits defined as PHY_X_..., PHY_B_..., PHY_L_..., PHY_N_... or PHY_M_... are
  * XMAC/Broadcom/LevelOne/National/Marvell-specific.
  * All other are general.
  */
 
@@ -628,16 +629,16 @@ extern "C" {
 /*****  PHY_MARV_CTRL	16 bit r/w	PHY Status Register *****/
 /*****  PHY_LONE_CTRL	16 bit r/w	PHY Control Register *****/
 #define PHY_CT_RESET	(1<<15)	/* Bit 15: (sc)	clear all PHY related regs */
 #define PHY_CT_LOOP		(1<<14)	/* Bit 14:	enable Loopback over PHY */
-#define PHY_CT_SPS_LSB	(1<<13) /* Bit 13: (BC,L1) Speed select, lower bit */
+#define PHY_CT_SPS_LSB	(1<<13) /* Bit 13:  Speed select, lower bit */
 #define PHY_CT_ANE		(1<<12)	/* Bit 12:	Auto-Negotiation Enabled */
-#define PHY_CT_PDOWN	(1<<11)	/* Bit 11: (BC,L1) Power Down Mode */
-#define PHY_CT_ISOL		(1<<10)	/* Bit 10: (BC,L1) Isolate Mode */
+#define PHY_CT_PDOWN	(1<<11)	/* Bit 11:  Power Down Mode */
+#define PHY_CT_ISOL		(1<<10)	/* Bit 10:  Isolate Mode */
 #define PHY_CT_RE_CFG	(1<<9)	/* Bit  9: (sc) Restart Auto-Negotiation */
 #define PHY_CT_DUP_MD	(1<<8)	/* Bit  8:	Duplex Mode */
-#define PHY_CT_COL_TST	(1<<7)	/* Bit  7: (BC,L1) Collision Test enabled */
-#define PHY_CT_SPS_MSB	(1<<6)	/* Bit  6: (BC,L1) Speed select, upper bit */
+#define PHY_CT_COL_TST	(1<<7)	/* Bit  7:  Collision Test enabled */
+#define PHY_CT_SPS_MSB	(1<<6)	/* Bit  6:  Speed select, upper bit */
 								/* Bit  5..0:	reserved */
 
 #define PHY_CT_SP1000	PHY_CT_SPS_MSB	/* enable speed of 1000 Mbps */
 #define PHY_CT_SP100	PHY_CT_SPS_LSB	/* enable speed of  100 Mbps */
@@ -648,17 +649,17 @@ extern "C" {
 /*****  PHY_BCOM_STAT	16 bit r/w	PHY Status Register *****/
 /*****  PHY_MARV_STAT	16 bit r/w	PHY Status Register *****/
 /*****  PHY_LONE_STAT	16 bit r/w	PHY Status Register *****/
 								/* Bit 15..9:	reserved */
-				/*	(BC/L1) 100/10 Mbps cap bits ignored*/
+				/*	(BC/L1) 100/10 Mbps cap bits ignored */
 #define PHY_ST_EXT_ST	(1<<8)	/* Bit  8:	Extended Status Present */
 								/* Bit  7:	reserved */
-#define PHY_ST_PRE_SUP	(1<<6)	/* Bit  6: (BC/L1) preamble suppression */
+#define PHY_ST_PRE_SUP	(1<<6)	/* Bit  6:  Preamble Suppression */
 #define PHY_ST_AN_OVER	(1<<5)	/* Bit  5:	Auto-Negotiation Over */
 #define PHY_ST_REM_FLT	(1<<4)	/* Bit  4:	Remote Fault Condition Occured */
 #define PHY_ST_AN_CAP	(1<<3)	/* Bit  3:	Auto-Negotiation Capability */
 #define PHY_ST_LSYNC	(1<<2)	/* Bit  2:	Link Synchronized */
-#define PHY_ST_JAB_DET	(1<<1)	/* Bit  1: (BC/L1) Jabber Detected */
+#define PHY_ST_JAB_DET	(1<<1)	/* Bit  1:  Jabber Detected */
 #define PHY_ST_EXT_REG	(1<<0)	/* Bit  0:	Extended Register available */
 
 
 /*****	PHY_XMAC_ID1		16 bit r/o	PHY ID1 Register */
@@ -666,9 +667,9 @@ extern "C" {
 /*****	PHY_MARV_ID1		16 bit r/o	PHY ID1 Register */
 /*****	PHY_LONE_ID1		16 bit r/o	PHY ID1 Register */
 #define PHY_I1_OUI_MSK	(0x3f<<10)	/* Bit 15..10:	Organization Unique ID */
 #define PHY_I1_MOD_NUM	(0x3f<<4)	/* Bit  9.. 4:	Model Number */
-#define PHY_I1_REV_MSK	0x0f		/* Bit  3.. 0:	Revision Number */
+#define PHY_I1_REV_MSK	0xf			/* Bit  3.. 0:	Revision Number */
 
 /* different Broadcom PHY Ids */
 #define PHY_BCOM_ID1_A1		0x6041
 #define PHY_BCOM_ID1_B2		0x6043
@@ -980,9 +981,9 @@ extern "C" {
 #define PHY_L_QS_L_STAT		(1<<10)	/* Bit 10:	Link is up */
 #define PHY_L_QS_DUP_MOD	(1<<9)	/* Bit  9:	Full/Half Duplex */
 #define PHY_L_QS_AN			(1<<8)	/* Bit  8:	AutoNeg is On */
 #define PHY_L_QS_AN_C		(1<<7)	/* Bit  7:	AN is Complete */
-#define PHY_L_QS_LLE		(7<<4)	/* Bit  6:	Line Length Estim. */
+#define PHY_L_QS_LLE		(7<<4)	/* Bit  6..4:	Line Length Estim. */
 #define PHY_L_QS_PAUSE		(1<<3)	/* Bit  3:	LP advertised Pause */
 #define PHY_L_QS_AS_PAUSE	(1<<2)	/* Bit  2:	LP adv. asym. Pause */
 #define PHY_L_QS_ISOLATE	(1<<1)	/* Bit  1:	CIM Isolated */
 #define PHY_L_QS_EVENT		(1<<0)	/* Bit  0:	Event has occurred */
@@ -1028,11 +1029,10 @@ extern "C" {
 #define PHY_L_PC_TEN_CRS	(1<<10)	/* Bit 10:	Extend CRS*/
 									/* Bit  9..0:	not described */
 
 /*****  PHY_LONE_CIM		16 bit r/o	CIM Reg *****/
-#define PHY_L_CIM_ISOL		(255<<8)/* Bit 15..8:	Isolate Count */
-#define PHY_L_CIM_FALSE_CAR	(255<<0)/* Bit  7..0:	False Carrier Count */
-
+#define PHY_L_CIM_ISOL		(0xff<<8)	/* Bit 15..8:	Isolate Count */
+#define PHY_L_CIM_FALSE_CAR	0xff		/* Bit  7..0:	False Carrier Count */
 
 /*
  * Pause Bits (PHY_L_AN_ASP and PHY_L_AN_PC) encoding
  */
@@ -1040,9 +1040,8 @@ extern "C" {
 #define PHY_L_P_SYM_MD		(1<<10)	/* Bit 11..10:	symmetric Pause Mode */
 #define PHY_L_P_ASYM_MD		(2<<10)	/* Bit 11..10:	asymmetric Pause Mode */
 #define PHY_L_P_BOTH_MD		(3<<10)	/* Bit 11..10:	both Pause Mode */
 
-
 /*
  * National-Specific
  */
 /*****  PHY_NAT_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
@@ -1085,24 +1084,26 @@ extern "C" {
  * Marvell-Specific
  */
 /*****  PHY_MARV_AUNE_ADV	16 bit r/w	Auto-Negotiation Advertisement *****/
 /*****  PHY_MARV_AUNE_LP	16 bit r/w	Link Part Ability Reg *****/
-#define PHY_M_AN_NXT_PG		BIT_15	/* Request Next Page */
-#define PHY_M_AN_ACK		BIT_14	/* (ro)	Acknowledge Received */
-#define PHY_M_AN_RF			BIT_13	/* Remote Fault */
-									/* Bit 12:	reserved */
-#define PHY_M_AN_ASP		BIT_11	/* Asymmetric Pause */
-#define PHY_M_AN_PC			BIT_10	/* MAC Pause implemented */
-#define PHY_M_AN_100_FD		BIT_8	/* Advertise 100Base-TX Full Duplex */
-#define PHY_M_AN_100_HD		BIT_7	/* Advertise 100Base-TX Half Duplex */
-#define PHY_M_AN_10_FD		BIT_6	/* Advertise 10Base-TX Full Duplex */
-#define PHY_M_AN_10_HD		BIT_5	/* Advertise 10Base-TX Half Duplex */
+#define PHY_M_AN_NXT_PG		BIT_15S	/* Request Next Page */
+#define PHY_M_AN_ACK		BIT_14S	/* (ro)	Acknowledge Received */
+#define PHY_M_AN_RF			BIT_13S	/* Remote Fault */
+								/* Bit 12:	reserved */
+#define PHY_M_AN_ASP		BIT_11S	/* Asymmetric Pause */
+#define PHY_M_AN_PC			BIT_10S	/* MAC Pause implemented */
+#define PHY_M_AN_100_T4		BIT_9S	/* Not cap. 100Base-T4 (always 0) */
+#define PHY_M_AN_100_FD		BIT_8S	/* Advertise 100Base-TX Full Duplex */
+#define PHY_M_AN_100_HD		BIT_7S	/* Advertise 100Base-TX Half Duplex */
+#define PHY_M_AN_10_FD		BIT_6S	/* Advertise 10Base-TX Full Duplex */
+#define PHY_M_AN_10_HD		BIT_5S	/* Advertise 10Base-TX Half Duplex */
+#define PHY_M_AN_SEL_MSK	(0x1f<<4)	/* Bit  4.. 0:	Selector Field Mask */
 
 /* special defines for FIBER (88E1011S only) */
-#define PHY_M_AN_ASP_X		BIT_8	/* Asymmetric Pause */
-#define PHY_M_AN_PC_X		BIT_7	/* MAC Pause implemented */
-#define PHY_M_AN_1000X_AHD	BIT_6	/* Advertise 10000Base-X Half Duplex */
-#define PHY_M_AN_1000X_AFD	BIT_5	/* Advertise 10000Base-X Full Duplex */
+#define PHY_M_AN_ASP_X		BIT_8S	/* Asymmetric Pause */
+#define PHY_M_AN_PC_X		BIT_7S	/* MAC Pause implemented */
+#define PHY_M_AN_1000X_AHD	BIT_6S	/* Advertise 10000Base-X Half Duplex */
+#define PHY_M_AN_1000X_AFD	BIT_5S	/* Advertise 10000Base-X Full Duplex */
 
 /* Pause Bits (PHY_M_AN_ASP_X and PHY_M_AN_PC_X) encoding */
 #define PHY_M_P_NO_PAUSE_X	(0<<7)	/* Bit  8.. 7:	no Pause Mode */
 #define PHY_M_P_SYM_MD_X	(1<<7)	/* Bit  8.. 7:	symmetric Pause Mode */
@@ -1110,83 +1111,85 @@ extern "C" {
 #define PHY_M_P_BOTH_MD_X	(3<<7)	/* Bit  8.. 7:	both Pause Mode */
 
 /*****  PHY_MARV_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
 #define PHY_M_1000C_TEST	(7<<13)	/* Bit 15..13:	Test Modes */
-#define PHY_M_1000C_MSE		(1<<12)	/* Bit 12:	Manual Master/Slave Enable */
-#define PHY_M_1000C_MSC		(1<<11)	/* Bit 11:	M/S Configuration (1=Master) */
-#define PHY_M_1000C_MPD		(1<<10)	/* Bit 10:	Multi-Port Device */
-#define PHY_M_1000C_AFD		(1<<9)	/* Bit  9:	Advertise Full Duplex */
-#define PHY_M_1000C_AHD		(1<<8)	/* Bit  8:	Advertise Half Duplex */
+#define PHY_M_1000C_MSE		BIT_12S	/* Manual Master/Slave Enable */
+#define PHY_M_1000C_MSC		BIT_11S	/* M/S Configuration (1=Master) */
+#define PHY_M_1000C_MPD		BIT_10S	/* Multi-Port Device */
+#define PHY_M_1000C_AFD		BIT_9S	/* Advertise Full Duplex */
+#define PHY_M_1000C_AHD		BIT_8S	/* Advertise Half Duplex */
 									/* Bit  7..0:	reserved */
 
 /*****  PHY_MARV_PHY_CTRL	16 bit r/w	PHY Specific Ctrl Reg *****/
 #define PHY_M_PC_TX_FFD_MSK	(3<<14)	/* Bit 15..14:	Tx FIFO Depth Mask */
 #define PHY_M_PC_RX_FFD_MSK	(3<<12)	/* Bit 13..12:	Rx FIFO Depth Mask */
-#define PHY_M_PC_ASS_CRS_TX	(1<<11)	/* Bit 11:	Assert CRS on Transmit */
-#define PHY_M_PC_FL_GOOD	(1<<10)	/* Bit 10:	Force Link Good */
+#define PHY_M_PC_ASS_CRS_TX	BIT_11S	/* Assert CRS on Transmit */
+#define PHY_M_PC_FL_GOOD	BIT_10S	/* Force Link Good */
 #define PHY_M_PC_EN_DET_MSK	(3<<8)	/* Bit  9.. 8:	Energy Detect Mask */
-#define PHY_M_PC_ENA_EXT_D	(1<<7)	/* Bit  7:	Enable Ext. Distance (10BT) */
+#define PHY_M_PC_ENA_EXT_D	BIT_7S	/* Enable Ext. Distance (10BT) */
 #define PHY_M_PC_MDIX_MSK	(3<<5)	/* Bit  6.. 5:	MDI/MDIX Config. Mask */
-#define PHY_M_PC_DIS_125CLK	(1<<4)	/* Bit  4:	Disable 125 CLK */
-#define PHY_M_PC_MAC_POW_UP	(1<<3)	/* Bit  3:	MAC Power up */
-#define PHY_M_PC_SQE_T_ENA	(1<<2)	/* Bit  2:	SQE Test Enabled */
-#define PHY_M_PC_POL_R_DIS	(1<<1)	/* Bit  1:	Polarity Reversal Disabled */
-#define PHY_M_PC_DIS_JABBER	(1<<0)	/* Bit  0:	Disable Jabber */
+#define PHY_M_PC_DIS_125CLK	BIT_4S	/* Disable 125 CLK */
+#define PHY_M_PC_MAC_POW_UP	BIT_3S	/* MAC Power up */
+#define PHY_M_PC_SQE_T_ENA	BIT_2S	/* SQE Test Enabled */
+#define PHY_M_PC_POL_R_DIS	BIT_1S	/* Polarity Reversal Disabled */
+#define PHY_M_PC_DIS_JABBER	BIT_0S	/* Disable Jabber */
 
 #define PHY_M_PC_EN_DET			SHIFT8(2)	/* Energy Detect (Mode 1) */
 #define PHY_M_PC_EN_DET_PLUS	SHIFT8(3)	/* Energy Detect Plus (Mode 2) */
 
-#define PHY_M_PC_MDI_XMODE(x)	SHIFT5(x)	
+#define PHY_M_PC_MDI_XMODE(x)	(SHIFT5(x) & PHY_M_PC_MDIX_MSK)	
+
 #define PHY_M_PC_MAN_MDI	0    	/* 00 = Manual MDI configuration */
 #define PHY_M_PC_MAN_MDIX	1		/* 01 = Manual MDIX configuration */
 #define PHY_M_PC_ENA_AUTO	3		/* 11 = Enable Automatic Crossover */
 
 /*****  PHY_MARV_PHY_STAT	16 bit r/o	PHY Specific Status Reg *****/
 #define PHY_M_PS_SPEED_MSK	(3<<14)	/* Bit 15..14:	Speed Mask */
-#define PHY_M_PS_SPEED_1000	(1<<15)	/*       10 = 1000 Mbps */
-#define PHY_M_PS_SPEED_100	(1<<14)	/*       01 =  100 Mbps */
+#define PHY_M_PS_SPEED_1000	BIT_15S	/*       10 = 1000 Mbps */
+#define PHY_M_PS_SPEED_100	BIT_14S	/*       01 =  100 Mbps */
 #define PHY_M_PS_SPEED_10	0		/*       00 =   10 Mbps */
-#define PHY_M_PS_FULL_DUP	(1<<13)	/* Bit 13:	Full Duplex */
-#define PHY_M_PS_PAGE_REC	(1<<12)	/* Bit 12:	Page Received */
-#define PHY_M_PS_SPDUP_RES	(1<<11)	/* Bit 11:	Speed & Duplex Resolved */
-#define PHY_M_PS_LINK_UP	(1<<10)	/* Bit 10:	Link Up */
-#define PHY_M_PS_CABLE_MSK	(3<<7)	/* Bit  9.. 7:	Cable Length Mask */
-#define PHY_M_PS_MDI_X_STAT	(1<<6)	/* Bit  6:	MDI Crossover Stat (1=MDIX) */
-#define PHY_M_PS_DOWNS_STAT	(1<<5)	/* Bit  5:	Downshift Status (1=downsh.) */
-#define PHY_M_PS_ENDET_STAT	(1<<4)	/* Bit  4:	Energy Detect Status (1=act) */
-#define PHY_M_PS_TX_P_EN	(1<<3)	/* Bit  3:	Tx Pause Enabled */
-#define PHY_M_PS_RX_P_EN	(1<<2)	/* Bit  2:	Rx Pause Enabled */
-#define PHY_M_PS_POL_REV	(1<<1)	/* Bit  1:	Polarity Reversed */
-#define PHY_M_PC_JABBER		(1<<0)	/* Bit  0:	Jabber */
+#define PHY_M_PS_FULL_DUP	BIT_13S	/* Full Duplex */
+#define PHY_M_PS_PAGE_REC	BIT_12S	/* Page Received */
+#define PHY_M_PS_SPDUP_RES	BIT_11S	/* Speed & Duplex Resolved */
+#define PHY_M_PS_LINK_UP	BIT_10S	/* Link Up */
+#define PHY_M_PS_CABLE_MSK	(7<<7)	/* Bit  9.. 7:  Cable Length Mask */
+#define PHY_M_PS_MDI_X_STAT	BIT_6S	/* MDI Crossover Stat (1=MDIX) */
+#define PHY_M_PS_DOWNS_STAT	BIT_5S	/* Downshift Status (1=downsh.) */
+#define PHY_M_PS_ENDET_STAT	BIT_4S	/* Energy Detect Status (1=act) */
+#define PHY_M_PS_TX_P_EN	BIT_3S	/* Tx Pause Enabled */
+#define PHY_M_PS_RX_P_EN	BIT_2S	/* Rx Pause Enabled */
+#define PHY_M_PS_POL_REV	BIT_1S	/* Polarity Reversed */
+#define PHY_M_PS_JABBER		BIT_0S	/* Jabber */
 
 #define PHY_M_PS_PAUSE_MSK	(PHY_M_PS_TX_P_EN | PHY_M_PS_RX_P_EN)
 
 /*****  PHY_MARV_INT_MASK	16 bit r/w	Interrupt Mask Reg *****/
 /*****  PHY_MARV_INT_STAT	16 bit r/o	Interrupt Status Reg *****/
-#define PHY_M_IS_AN_ERROR	(1<<15)	/* Bit 15:	Auto-Negotiation Error */
-#define PHY_M_IS_LSP_CHANGE	(1<<14)	/* Bit 14:	Link Speed Changed */
-#define PHY_M_IS_DUP_CHANGE	(1<<13)	/* Bit 13:	Duplex Mode Changed */
-#define PHY_M_IS_AN_PR		(1<<12)	/* Bit 12:	Page Received */
-#define PHY_M_IS_AN_COMPL	(1<<11)	/* Bit 11:	Auto-Negotiation Completed */
-#define PHY_M_IS_LST_CHANGE	(1<<10)	/* Bit 10:	Link Status Changed */
-#define PHY_M_IS_SYMB_ERROR	(1<<9)	/* Bit  9:	Symbol Error */
-#define PHY_M_IS_FALSE_CARR	(1<<8)	/* Bit  8:	False Carrier */
-#define PHY_M_IS_FIFO_ERROR	(1<<7)	/* Bit  7:	FIFO Overflow/Underrun Error */
-#define PHY_M_IS_MDI_CHANGE	(1<<6)	/* Bit  6:	MDI Crossover Changed */
-#define PHY_M_IS_DOWNSH_DET	(1<<5)	/* Bit  5:	Downshift Detected */
-#define PHY_M_IS_END_CHANGE	(1<<4)	/* Bit  4:	Energy Detect Changed */
-									/* Bit  3..2:	reserved */
-#define PHY_M_IS_POL_CHANGE	(1<<1)	/* Bit  1:	Polarity Changed */
-#define PHY_M_IS_JABBER		(1<<0)	/* Bit  0:	Jabber */
+#define PHY_M_IS_AN_ERROR	BIT_15S	/* Auto-Negotiation Error */
+#define PHY_M_IS_LSP_CHANGE	BIT_14S	/* Link Speed Changed */
+#define PHY_M_IS_DUP_CHANGE	BIT_13S	/* Duplex Mode Changed */
+#define PHY_M_IS_AN_PR		BIT_12S	/* Page Received */
+#define PHY_M_IS_AN_COMPL	BIT_11S	/* Auto-Negotiation Completed */
+#define PHY_M_IS_LST_CHANGE	BIT_10S	/* Link Status Changed */
+#define PHY_M_IS_SYMB_ERROR	BIT_9S	/* Symbol Error */
+#define PHY_M_IS_FALSE_CARR	BIT_8S	/* False Carrier */
+#define PHY_M_IS_FIFO_ERROR	BIT_7S	/* FIFO Overflow/Underrun Error */
+#define PHY_M_IS_MDI_CHANGE	BIT_6S	/* MDI Crossover Changed */
+#define PHY_M_IS_DOWNSH_DET	BIT_5S	/* Downshift Detected */
+#define PHY_M_IS_END_CHANGE	BIT_4S	/* Energy Detect Changed */
+								/* Bit   3.. 2:	reserved */
+#define PHY_M_IS_POL_CHANGE	BIT_1S	/* Polarity Changed */
+#define PHY_M_IS_JABBER		BIT_0S	/* Jabber */
 
 #define PHY_M_DEF_MSK		(PHY_M_IS_AN_ERROR | PHY_M_IS_AN_PR | \
 							PHY_M_IS_LST_CHANGE | PHY_M_IS_FIFO_ERROR)
 
 /*****  PHY_MARV_EXT_CTRL	16 bit r/w	Ext. PHY Specific Ctrl *****/
-#define PHY_M_EC_M_DSC_MSK	(3<<10)	/* Bit 11..10:	Master downshift counter */
-#define PHY_M_EC_S_DSC_MSK	(3<<8)	/* Bit  9.. 8:	Slave  downshift counter */
+#define PHY_M_EC_M_DSC_MSK	(3<<10)	/* Bit 11..10:	Master Downshift Counter */
+#define PHY_M_EC_S_DSC_MSK	(3<<8)	/* Bit  9.. 8:	Slave  Downshift Counter */
 #define PHY_M_EC_MAC_S_MSK	(7<<4)	/* Bit  6.. 4:	Def. MAC interface speed */
-#define PHY_M_EC_FIB_AN_ENA	(1<<3)	/* Bit  3:	Fiber Auto-Neg. Enable */
+#define PHY_M_EC_FIB_AN_ENA	BIT_3S	/* Fiber Auto-Neg. Enable */
+								/* Bit   2.. 0:	reserved */
 
 #define PHY_M_EC_M_DSC(x)		SHIFT10(x)	/* 00=1x; 01=2x; 10=3x; 11=4x */
 #define PHY_M_EC_S_DSC(x)		SHIFT8(x)	/* 00=dis; 01=1x; 10=2x; 11=3x */
 #define PHY_M_EC_MAC_S(x)		SHIFT4(x)	/* 01X=0; 110=2.5; 111=25 (MHz) */
@@ -1195,19 +1198,19 @@ extern "C" {
 #define MAC_TX_CLK_2_5_MHZ	6
 #define MAC_TX_CLK_25_MHZ	7
 
 /*****  PHY_MARV_LED_CTRL	16 bit r/w	LED Control Reg *****/
-#define PHY_M_LEDC_DIS_LED	(1<<15)	/* Bit 15:	Disable LED */
+#define PHY_M_LEDC_DIS_LED	BIT_15S	/* Disable LED */
 #define PHY_M_LEDC_PULS_MSK	(7<<12)	/* Bit 14..12:  Pulse Stretch Mask */
-#define PHY_M_LEDC_F_INT	(1<<11)	/* Bit 11:	Force Interrupt */
+#define PHY_M_LEDC_F_INT	BIT_11S	/* Force Interrupt */
 #define PHY_M_LEDC_BL_R_MSK	(7<<8)	/* Bit 10.. 8:  Blink Rate Mask */
-									/* Bit  7.. 5:	reserved */
+								/* Bit  7.. 5:	reserved */
 #define PHY_M_LEDC_LINK_MSK	(3<<3)	/* Bit  4.. 3:	Link Control Mask */
-#define PHY_M_LEDC_DP_CTRL	(1<<2)	/* Bit  2:	Duplex Control */
-#define PHY_M_LEDC_RX_CTRL	(1<<1)	/* Bit  1:	Rx activity / Link */
-#define PHY_M_LEDC_TX_CTRL	(1<<0)	/* Bit  0:	Tx activity / Link */
+#define PHY_M_LEDC_DP_CTRL	BIT_2S	/* Duplex Control */
+#define PHY_M_LEDC_RX_CTRL	BIT_1S	/* Rx Activity / Link */
+#define PHY_M_LEDC_TX_CTRL	BIT_0S	/* Tx Activity / Link */
 
-#define PHY_M_LED_PULS_DUR(x)	SHIFT12(x)	/* Pulse Stretch Duration */
+#define PHY_M_LED_PULS_DUR(x)	(SHIFT12(x) & PHY_M_LEDC_PULS_MSK)
 
 #define	PULS_NO_STR		0		/* no pulse stretching */
 #define	PULS_21MS		1		/* 21 ms to 42 ms */
 #define PULS_42MS		2		/* 42 ms to 84 ms */
@@ -1216,9 +1219,9 @@ extern "C" {
 #define PULS_340MS		5		/* 340 ms to 670 ms */
 #define PULS_670MS		6		/* 670 ms to 1.3 s */
 #define PULS_1300MS		7		/* 1.3 s to 2.7 s */
 
-#define PHY_M_LED_BLINK_RT(x)	SHIFT8(x)	/* Blink Rate */
+#define PHY_M_LED_BLINK_RT(x)	(SHIFT8(x) & PHY_M_LEDC_BL_R_MSK)
 
 #define BLINK_42MS		0		/* 42 ms */
 #define BLINK_84MS		1		/* 84 ms */
 #define BLINK_170MS		2		/* 170 ms */
@@ -1239,32 +1242,31 @@ extern "C" {
 #define MO_LED_OFF			2
 #define MO_LED_ON			3
 
 /*****  PHY_MARV_EXT_CTRL_2	16 bit r/w	Ext. PHY Specific Ctrl 2 *****/
-									/* Bit 15.. 7:	reserved */
-#define PHY_M_EC2_FI_IMPED	(1<<6)	/* Bit  6:	Fiber Input  Impedance */
-#define PHY_M_EC2_FO_IMPED	(1<<5)	/* Bit  5:	Fiber Output Impedance */
-#define PHY_M_EC2_FO_M_CLK	(1<<4)	/* Bit  4:	Fiber Mode Clock Enable */
-#define PHY_M_EC2_FO_BOOST	(1<<3)	/* Bit  3:	Fiber Output Boost */
+								/* Bit 15.. 7:	reserved */
+#define PHY_M_EC2_FI_IMPED	BIT_6S	/* Fiber Input  Impedance */
+#define PHY_M_EC2_FO_IMPED	BIT_5S	/* Fiber Output Impedance */
+#define PHY_M_EC2_FO_M_CLK	BIT_4S	/* Fiber Mode Clock Enable */
+#define PHY_M_EC2_FO_BOOST	BIT_3S	/* Fiber Output Boost */
 #define PHY_M_EC2_FO_AM_MSK	7		/* Bit  2.. 0:	Fiber Output Amplitude */
 
 /*****	PHY_MARV_EXT_P_STAT 16 bit r/w	Ext. PHY Specific Status *****/
-#define PHY_M_FC_AUTO_SEL	(1<<15)	/* Bit 15:	Fiber/Copper Auto Sel. dis. */
-#define PHY_M_FC_AN_REG_ACC (1<<14) /* Bit 14:	Fiber/Copper Autoneg. reg acc */
-#define PHY_M_FC_RESULUTION (1<<13)	/* Bit 13:	Fiber/Copper Resulution */
-#define PHY_M_SER_IF_AN_BP  (1<<12) /* Bit 12:	Ser IF autoneg. bypass enable */
-#define PHY_M_SER_IF_BP_ST	(1<<11) /* Bit 11:	Ser IF autoneg. bypass status */
-#define PHY_M_IRQ_POLARITY	(1<<10) /* Bit 10:	IRQ polarity */
-									/* Bit 9..4: reserved */
-#define PHY_M_UNDOC1		(1<< 7) /* undocumented bit !! */
-#define PHY_M_MODE_MASK		(0xf<<0)/* Bit 3..0: copy of HWCFG MODE[3:0] */
-
+#define PHY_M_FC_AUTO_SEL	BIT_15S	/* Fiber/Copper Auto Sel. Dis. */
+#define PHY_M_FC_AN_REG_ACC	BIT_14S	/* Fiber/Copper AN Reg. Access */
+#define PHY_M_FC_RESOLUTION	BIT_13S	/* Fiber/Copper Resolution */
+#define PHY_M_SER_IF_AN_BP	BIT_12S	/* Ser. IF AN Bypass Enable */
+#define PHY_M_SER_IF_BP_ST	BIT_11S	/* Ser. IF AN Bypass Status */
+#define PHY_M_IRQ_POLARITY	BIT_10S	/* IRQ polarity */
+								/* Bit  9.. 4: reserved */
+#define PHY_M_UNDOC1		BIT_7S	/* undocumented bit !! */
+#define PHY_M_MODE_MASK		0xf		/* Bit  3.. 0: copy of HWCFG MODE[3:0] */
 
 /*****  PHY_MARV_CABLE_DIAG	16 bit r/o	Cable Diagnostic Reg *****/
-#define PHY_M_CABD_ENA_TEST	(1<<15)	/* Bit 15:	Enable Test */
-#define PHY_M_CABD_STAT_MSK	(3<<13)	/* Bit 14..13:	Status */
-									/* Bit 12.. 8:	reserved */
-#define PHY_M_CABD_DIST_MSK	0xff	/* Bit  7.. 0:	Distance */
+#define PHY_M_CABD_ENA_TEST	BIT_15S	/* Enable Test */
+#define PHY_M_CABD_STAT_MSK	(3<<13)	/* Bit 14..13:	Status Mask */
+								/* Bit 12.. 8:	reserved */
+#define PHY_M_CABD_DIST_MSK	0xff	/* Bit  7.. 0:	Distance Mask */
 
 /* values for Cable Diagnostic Status (11=fail; 00=OK; 10=open; 01=short) */
 #define CABD_STAT_NORMAL	0
 #define CABD_STAT_SHORT		1
@@ -1430,67 +1432,68 @@ extern "C" {
  *	(r/o)	read only
  */
 
 /*	GM_GP_STAT	16 bit r/o	General Purpose Status Register */
-#define GM_GPSR_SPEED		(1<<15) /* Bit 15:	Port Speed (1 = 100 Mbps) */
-#define GM_GPSR_DUPLEX		(1<<14) /* Bit 14:	Duplex Mode (1 = Full) */
-#define GM_GPSR_FC_TX_DIS	(1<<13) /* Bit 13:	Tx Flow-Control Mode Disabled */
-#define GM_GPSR_LINK_UP		(1<<12)	/* Bit 12:	Link Up Status */
-#define GM_GPSR_PAUSE		(1<<11)	/* Bit 11:	Pause State */
-#define GM_GPSR_TX_ACTIVE	(1<<10)	/* Bit 10:	Tx in Progress */
-#define GM_GPSR_EXC_COL		(1<<9)	/* Bit  9:	Excessive Collisions Occured */
-#define GM_GPSR_LAT_COL		(1<<8)	/* Bit  8:	Late Collisions Occured */
+#define GM_GPSR_SPEED		BIT_15S	/* Port Speed (1 = 100 Mbps) */
+#define GM_GPSR_DUPLEX		BIT_14S	/* Duplex Mode (1 = Full) */
+#define GM_GPSR_FC_TX_DIS	BIT_13S	/* Tx Flow-Control Mode Disabled */
+#define GM_GPSR_LINK_UP		BIT_12S	/* Link Up Status */
+#define GM_GPSR_PAUSE		BIT_11S	/* Pause State */
+#define GM_GPSR_TX_ACTIVE	BIT_10S	/* Tx in Progress */
+#define GM_GPSR_EXC_COL		BIT_9S	/* Excessive Collisions Occured */
+#define GM_GPSR_LAT_COL		BIT_8S	/* Late Collisions Occured */
 								/* Bit  7..6:	reserved */
-#define GM_GPSR_PHY_ST_CH	(1<<5)	/* Bit  5:	PHY Status Change */
-#define GM_GPSR_GIG_SPEED	(1<<4)	/* Bit  4:	Gigabit Speed (1 = 1000 Mbps) */
-#define GM_GPSR_PART_MODE	(1<<3)	/* Bit  3:	Partition mode */
-#define GM_GPSR_FC_RX_DIS	(1<<2)	/* Bit  2:	Rx Flow-Control Mode Disabled */
-#define GM_GPSR_PROM_EN		(1<<1)	/* Bit  1:	Promiscuous Mode Enabled */
+#define GM_GPSR_PHY_ST_CH	BIT_5S	/* PHY Status Change */
+#define GM_GPSR_GIG_SPEED	BIT_4S	/* Gigabit Speed (1 = 1000 Mbps) */
+#define GM_GPSR_PART_MODE	BIT_3S	/* Partition mode */
+#define GM_GPSR_FC_RX_DIS	BIT_2S	/* Rx Flow-Control Mode Disabled */
+#define GM_GPSR_PROM_EN		BIT_1S	/* Promiscuous Mode Enabled */
 								/* Bit  0:	reserved */
 	
 /*	GM_GP_CTRL	16 bit r/w	General Purpose Control Register */
-								/* Bit 15:	reserved */
-#define GM_GPCR_PROM_ENA	(1<<14)	/* Bit 14:	Enable Promiscuous Mode */
-#define GM_GPCR_FC_TX_DIS	(1<<13) /* Bit 13:	Disable Tx Flow-Control Mode */
-#define GM_GPCR_TX_ENA		(1<<12) /* Bit 12:	Enable Transmit */
-#define GM_GPCR_RX_ENA		(1<<11) /* Bit 11:	Enable Receive */
-#define GM_GPCR_BURST_ENA	(1<<10)	/* Bit 10:	Enable Burst Mode */
-#define GM_GPCR_LOOP_ENA	(1<<9)	/* Bit  9:	Enable MAC Loopback Mode */
-#define GM_GPCR_PART_ENA	(1<<8)	/* Bit  8:	Enable Partition Mode */
-#define GM_GPCR_GIGS_ENA	(1<<7)	/* Bit  7:	Gigabit Speed (1000 Mbps) */
-#define GM_GPCR_FL_PASS		(1<<6)	/* Bit  6:	Force Link Pass */
-#define GM_GPCR_DUP_FULL	(1<<5)	/* Bit  5:	Full Duplex Mode */
-#define GM_GPCR_FC_RX_DIS	(1<<4)	/* Bit  4:	Disable Rx Flow-Control Mode */
-#define GM_GPCR_SPEED_100	(1<<3)  /* Bit  3:	Port Speed 100 Mbps */
-#define GM_GPCR_AU_DUP_DIS	(1<<2)	/* Bit  2:	Disable Auto-Update Duplex */
-#define GM_GPCR_AU_FCT_DIS	(1<<1)	/* Bit  1:	Disable Auto-Update Flow-C. */
-#define GM_GPCR_AU_SPD_DIS	(1<<0)	/* Bit  0:	Disable Auto-Update Speed */
+								/* Bit 15..14:	reserved */
+#define GM_GPCR_FC_TX_DIS	BIT_13S	/* Disable Tx Flow-Control Mode */
+#define GM_GPCR_TX_ENA		BIT_12S	/* Enable Transmit */
+#define GM_GPCR_RX_ENA		BIT_11S	/* Enable Receive */
+								/* Bit 10:	reserved */
+#define GM_GPCR_LOOP_ENA	BIT_9S	/* Enable MAC Loopback Mode */
+#define GM_GPCR_PART_ENA	BIT_8S	/* Enable Partition Mode */
+#define GM_GPCR_GIGS_ENA	BIT_7S	/* Gigabit Speed (1000 Mbps) */
+#define GM_GPCR_FL_PASS		BIT_6S	/* Force Link Pass */
+#define GM_GPCR_DUP_FULL	BIT_5S	/* Full Duplex Mode */
+#define GM_GPCR_FC_RX_DIS	BIT_4S	/* Disable Rx Flow-Control Mode */
+#define GM_GPCR_SPEED_100	BIT_3S	/* Port Speed 100 Mbps */
+#define GM_GPCR_AU_DUP_DIS	BIT_2S	/* Disable Auto-Update Duplex */
+#define GM_GPCR_AU_FCT_DIS	BIT_1S	/* Disable Auto-Update Flow-C. */
+#define GM_GPCR_AU_SPD_DIS	BIT_0S	/* Disable Auto-Update Speed */
 
 #define GM_GPCR_SPEED_1000	(GM_GPCR_GIGS_ENA | GM_GPCR_SPEED_100)
 #define GM_GPCR_AU_ALL_DIS	(GM_GPCR_AU_DUP_DIS | GM_GPCR_AU_FCT_DIS |\
 							 GM_GPCR_AU_SPD_DIS)
 	
 /*	GM_TX_CTRL				16 bit r/w	Transmit Control Register */
-#define GM_TXCR_FORCE_JAM	(1<<15)	/* Bit 15:	Force Jam / Flow-Control */
-#define GM_TXCR_CRC_DIS		(1<<14)	/* Bit 14:	Disable insertion of CRC */
-#define GM_TXCR_PAD_DIS		(1<<13)	/* Bit 13:	Disable padding of packets */
-#define GM_TXCR_COL_THR_MSK	(1<<10)	/* Bit 12..10:	Collision Threshold */
+#define GM_TXCR_FORCE_JAM	BIT_15S	/* Force Jam / Flow-Control */
+#define GM_TXCR_CRC_DIS		BIT_14S	/* Disable insertion of CRC */
+#define GM_TXCR_PAD_DIS		BIT_13S	/* Disable padding of packets */
+#define GM_TXCR_COL_THR_MSK	(7<<10)	/* Bit 12..10:	Collision Threshold Mask */
+								/* Bit   9.. 0:	reserved */
 
 #define TX_COL_THR(x)		(SHIFT10(x) & GM_TXCR_COL_THR_MSK)
 
 #define TX_COL_DEF			0x04
 	
 /*	GM_RX_CTRL				16 bit r/w	Receive Control Register */
-#define GM_RXCR_UCF_ENA		(1<<15)	/* Bit 15:	Enable Unicast filtering */
-#define GM_RXCR_MCF_ENA		(1<<14)	/* Bit 14:	Enable Multicast filtering */
-#define GM_RXCR_CRC_DIS		(1<<13)	/* Bit 13:	Remove 4-byte CRC */
-#define GM_RXCR_PASS_FC		(1<<12)	/* Bit 12:	Pass FC packets to FIFO */
+#define GM_RXCR_UCF_ENA		BIT_15S	/* Enable Unicast filtering */
+#define GM_RXCR_MCF_ENA		BIT_14S	/* Enable Multicast filtering */
+#define GM_RXCR_CRC_DIS		BIT_13S	/* Remove 4-byte CRC */
+#define GM_RXCR_PASS_FC		BIT_12S	/* Pass FC packets to FIFO */
+								/* Bit  11.. 0:	reserved */
 	
 /*	GM_TX_PARAM				16 bit r/w	Transmit Parameter Register */
-#define GM_TXPA_JAMLEN_MSK	(0x03<<14)	/* Bit 15..14:	Jam Length */
-#define GM_TXPA_JAMIPG_MSK	(0x1f<<9)	/* Bit 13..9:	Jam IPG */
-#define GM_TXPA_JAMDAT_MSK	(0x1f<<4)	/* Bit  8..4:	IPG Jam to Data */
-								/* Bit  3..0:	reserved */
+#define GM_TXPA_JAMLEN_MSK	(3<<14)		/* Bit 15..14:	Jam Length */
+#define GM_TXPA_JAMIPG_MSK	(0x1f<<9)	/* Bit 13.. 9:	Jam IPG */
+#define GM_TXPA_JAMDAT_MSK	(0x1f<<4)	/* Bit  8.. 4:	IPG Jam to Data */
+								/* Bit   3.. 0:	reserved */
 
 #define TX_JAM_LEN_VAL(x)	(SHIFT14(x) & GM_TXPA_JAMLEN_MSK)
 #define TX_JAM_IPG_VAL(x)	(SHIFT9(x) & GM_TXPA_JAMIPG_MSK)
 #define TX_IPG_JAM_DATA(x)	(SHIFT4(x) & GM_TXPA_JAMDAT_MSK)
@@ -1499,69 +1502,88 @@ extern "C" {
 #define TX_JAM_IPG_DEF		0x0b
 #define TX_IPG_JAM_DEF		0x1c
 
 /*	GM_SERIAL_MODE			16 bit r/w	Serial Mode Register */
-#define GM_SMOD_DATABL_MSK	(0x1f<<11)	/* Bit 15..11:	Data Blinder (r/o) */
-#define GM_SMOD_LIMIT_4		(1<<10)	/* Bit 10:	4 consecutive Tx trials */
-#define GM_SMOD_VLAN_ENA	(1<<9)	/* Bit  9:	Enable VLAN  (Max. Frame Len) */
-#define GM_SMOD_JUMBO_ENA	(1<<8)	/* Bit  8:	Enable Jumbo (Max. Frame Len) */
-								/* Bit  7..5:	reserved */
-#define GM_SMOD_IPG_MSK		0x1f	/* Bit 4..0:	Inter-Packet Gap (IPG) */
+#define GM_SMOD_DATABL_MSK	(0x1f<<11)	/* Bit 15..11:	Data Blinder */
+										/* r/o on Yukon, r/w on Yukon-EC */
+#define GM_SMOD_LIMIT_4		BIT_10S	/* 4 consecutive Tx trials */
+#define GM_SMOD_VLAN_ENA	BIT_9S	/* Enable VLAN  (Max. Frame Len) */
+#define GM_SMOD_JUMBO_ENA	BIT_8S	/* Enable Jumbo (Max. Frame Len) */
+								/* Bit   7.. 5:	reserved */
+#define GM_SMOD_IPG_MSK		0x1f	/* Bit  4.. 0:	Inter-Packet Gap (IPG) */
 	
 #define DATA_BLIND_VAL(x)	(SHIFT11(x) & GM_SMOD_DATABL_MSK)
 #define DATA_BLIND_DEF		0x04
 
-#define IPG_DATA_VAL(x)		(x & GM_SMOD_IPG_MSK)
+#define IPG_DATA_VAL(x)		((x) & GM_SMOD_IPG_MSK)
 #define IPG_DATA_DEF		0x1e
 
 /*	GM_SMI_CTRL				16 bit r/w	SMI Control Register */
 #define GM_SMI_CT_PHY_A_MSK	(0x1f<<11)	/* Bit 15..11:	PHY Device Address */
 #define GM_SMI_CT_REG_A_MSK	(0x1f<<6)	/* Bit 10.. 6:	PHY Register Address */
-#define GM_SMI_CT_OP_RD		(1<<5)	/* Bit  5:	OpCode Read (0=Write)*/
-#define GM_SMI_CT_RD_VAL	(1<<4)	/* Bit  4:	Read Valid (Read completed) */
-#define GM_SMI_CT_BUSY		(1<<3)	/* Bit  3:	Busy (Operation in progress) */
-								/* Bit   2..0:	reserved */
+#define GM_SMI_CT_OP_RD		BIT_5S	/* OpCode Read (0=Write)*/
+#define GM_SMI_CT_RD_VAL	BIT_4S	/* Read Valid (Read completed) */
+#define GM_SMI_CT_BUSY		BIT_3S	/* Busy (Operation in progress) */
+								/* Bit   2.. 0:	reserved */
 	
 #define GM_SMI_CT_PHY_AD(x)	(SHIFT11(x) & GM_SMI_CT_PHY_A_MSK)
 #define GM_SMI_CT_REG_AD(x)	(SHIFT6(x) & GM_SMI_CT_REG_A_MSK)
 
 	/*	GM_PHY_ADDR				16 bit r/w	GPHY Address Register */
-								/* Bit  15..6:	reserved */
-#define GM_PAR_MIB_CLR		(1<<5)	/* Bit  5:	Set MIB Clear Counter Mode */
-#define GM_PAR_MIB_TST		(1<<4)	/* Bit  4:	MIB Load Counter (Test Mode) */
-								/* Bit   3..0:	reserved */
+								/* Bit  15.. 6:	reserved */
+#define GM_PAR_MIB_CLR		BIT_5S	/* Set MIB Clear Counter Mode */
+#define GM_PAR_MIB_TST		BIT_4S	/* MIB Load Counter (Test Mode) */
+								/* Bit   3.. 0:	reserved */
 	
 /* Receive Frame Status Encoding */
-#define GMR_FS_LEN	(0xffffUL<<16)	/* Bit 31..16:	Rx Frame Length */
+#define GMR_FS_LEN_MSK	(0xffffUL<<16)	/* Bit 31..16:	Rx Frame Length */
 								/* Bit  15..14:	reserved */
-#define GMR_FS_VLAN		(1L<<13)	/* Bit 13:	VLAN Packet */
-#define GMR_FS_JABBER	(1L<<12)	/* Bit 12:	Jabber Packet */
-#define GMR_FS_UN_SIZE	(1L<<11)	/* Bit 11:	Undersize Packet */
-#define GMR_FS_MC		(1L<<10)	/* Bit 10:	Multicast Packet */
-#define GMR_FS_BC		(1L<<9)		/* Bit  9:	Broadcast Packet */
-#define GMR_FS_RX_OK	(1L<<8)		/* Bit  8:	Receive OK (Good Packet) */
-#define GMR_FS_GOOD_FC	(1L<<7)		/* Bit  7:	Good Flow-Control Packet */
-#define GMR_FS_BAD_FC	(1L<<6)		/* Bit  6:	Bad  Flow-Control Packet */
-#define GMR_FS_MII_ERR	(1L<<5)		/* Bit  5:	MII Error */
-#define GMR_FS_LONG_ERR	(1L<<4)		/* Bit  4:	Too Long Packet */
-#define GMR_FS_FRAGMENT	(1L<<3)		/* Bit  3:	Fragment */
+#define GMR_FS_VLAN			BIT_13	/* VLAN Packet */
+#define GMR_FS_JABBER		BIT_12	/* Jabber Packet */
+#define GMR_FS_UN_SIZE		BIT_11	/* Undersize Packet */
+#define GMR_FS_MC			BIT_10	/* Multicast Packet */
+#define GMR_FS_BC			BIT_9	/* Broadcast Packet */
+#define GMR_FS_RX_OK		BIT_8	/* Receive OK (Good Packet) */
+#define GMR_FS_GOOD_FC		BIT_7	/* Good Flow-Control Packet */
+#define GMR_FS_BAD_FC		BIT_6	/* Bad  Flow-Control Packet */
+#define GMR_FS_MII_ERR		BIT_5	/* MII Error */
+#define GMR_FS_LONG_ERR		BIT_4	/* Too Long Packet */
+#define GMR_FS_FRAGMENT		BIT_3	/* Fragment */
 								/* Bit  2:	reserved */
-#define GMR_FS_CRC_ERR	(1L<<1)		/* Bit  1:	CRC Error */
-#define GMR_FS_RX_FF_OV	(1L<<0)		/* Bit  0:	Rx FIFO Overflow */
+#define GMR_FS_CRC_ERR		BIT_1	/* CRC Error */
+#define GMR_FS_RX_FF_OV		BIT_0	/* Rx FIFO Overflow */
+
+#define GMR_FS_LEN_SHIFT	16
 
 /*
  * GMR_FS_ANY_ERR (analogous to XMR_FS_ANY_ERR)
  */
-#define GMR_FS_ANY_ERR	(GMR_FS_CRC_ERR | \
+#ifdef SK_DIAG
+#define GMR_FS_ANY_ERR		( \
+			GMR_FS_RX_FF_OV | \
+			GMR_FS_CRC_ERR | \
+			GMR_FS_MII_ERR | \
+			GMR_FS_BAD_FC | \
+			GMR_FS_GOOD_FC | \
+			GMR_FS_JABBER)
+#else
+#define GMR_FS_ANY_ERR		( \
+			GMR_FS_RX_FF_OV | \
+			GMR_FS_CRC_ERR | \
+			GMR_FS_FRAGMENT | \
 			GMR_FS_LONG_ERR | \
 			GMR_FS_MII_ERR | \
 			GMR_FS_BAD_FC | \
 			GMR_FS_GOOD_FC | \
+			GMR_FS_UN_SIZE | \
 			GMR_FS_JABBER)
+#endif
 
 /* Rx GMAC FIFO Flush Mask (default) */
-#define RX_FF_FL_DEF_MSK	(GMR_FS_CRC_ERR | \
+#define RX_FF_FL_DEF_MSK	( \
 			GMR_FS_RX_FF_OV | \
+			GMR_FS_CRC_ERR | \
+			GMR_FS_FRAGMENT | \
 			GMR_FS_MII_ERR | \
 			GMR_FS_BAD_FC | \
 			GMR_FS_GOOD_FC | \
 			GMR_FS_UN_SIZE | \
Index: linux-2.6.8/drivers/net/sk98lin/Makefile
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/Makefile
+++ linux-2.6.8/drivers/net/sk98lin/Makefile
@@ -1,7 +1,53 @@
+#******************************************************************************
 #
-# Makefile for the SysKonnect SK-98xx device driver.
+# Name:	skge.c
+# Project:	GEnesis, PCI Gigabit Ethernet Adapter
+# Version:	$Revision: 1.8 $
+# Date:       	$Date: 2004/06/08 08:39:38 $
+# Purpose:	The main driver source module
 #
+#******************************************************************************
+
+#******************************************************************************
+#
+#	(C)Copyright 1998-2002 SysKonnect GmbH.
+#	(C)Copyright 2002-2003 Marvell.
+#
+#	Makefile for Marvell Yukon chipset and SysKonnect Gigabit Ethernet 
+#	Server Adapter driver. (Kernel 2.6)
+#
+#	Created 10-Feb-1999
+#	Author: Mirko Lindner (mlindner@syskonnect.de)
+#		Ralph Roessler (rroesler@syskonnect.de)
+#
+#	Address all question to: linux@syskonnect.de
+#
+#	This program is free software; you can redistribute it and/or modify
+#	it under the terms of the GNU General Public License as published by
+#	the Free Software Foundation; either version 2 of the License, or
+#	(at your option) any later version.
+#
+#	The information in this file is provided "AS IS" without warranty.
+# 
+#******************************************************************************
+
+#******************************************************************************
+#
+# History:
+#
+#	$Log: Makefile2.6,v $
+#	Revision 1.8  2004/06/08 08:39:38  mlindner
+#	Fix: Add CONFIG_SK98LIN_ZEROCOPY as default
+#	
+#	Revision 1.7  2004/06/03 16:06:56  mlindner
+#	Fix: Added compile flag SK_DIAG_SUPPORT
+#	
+#	Revision 1.6  2004/06/02 08:02:59  mlindner
+#	Add: Changed header information and inserted a GPL statement
+#	
+#
+#******************************************************************************
 
 
 #
 # Standalone driver params
@@ -12,15 +58,17 @@
 
 obj-$(CONFIG_SK98LIN) += sk98lin.o
 sk98lin-objs    :=	\
 		skge.o		\
+		sky2.o		\
+		sky2le.o	\
 		skdim.o		\
 		skaddr.o	\
 		skgehwt.o	\
 		skgeinit.o	\
 		skgepnmi.o	\
 		skgesirq.o	\
-		ski2c.o		\
+		sktwsi.o		\
 		sklm80.o	\
 		skqueue.o	\
 		skrlmt.o	\
 		sktimer.o	\
@@ -75,9 +123,11 @@ endif
 # SK_DBGCAT_DRV_ERROR           0x02000000      error conditions
 # SK_DBGCAT_DRV_INT_SRC         0x04000000      interrupts sources
 # SK_DBGCAT_DRV_EVENT           0x08000000      driver events
 
-EXTRA_CFLAGS += -Idrivers/net/sk98lin -DSK_DIAG_SUPPORT -DSK_USE_CSUM -DGENESIS -DYUKON $(DBGDEF) $(SKPARAM)
+EXTRA_CFLAGS += -Idrivers/net/sk98lin -DSK_USE_CSUM -DSK_DIAG_SUPPORT \
+		-DGENESIS -DYUKON -DYUK2 -DCONFIG_SK98LIN_ZEROCOPY \
+		$(DBGDEF) $(SKPARAM)
 
 clean:
 	rm -f core *.o *.a *.s
 
Index: linux-2.6.8/drivers/net/sk98lin/skaddr.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skaddr.c
+++ linux-2.6.8/drivers/net/sk98lin/skaddr.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skaddr.c
  * Project:	Gigabit Ethernet Adapters, ADDR-Module
- * Version:	$Revision: 1.52 $
- * Date:	$Date: 2003/06/02 13:46:15 $
+ * Version:	$Revision: 2.2 $
+ * Date:	$Date: 2003/11/24 12:22:01 $
  * Purpose:	Manage Addresses (Multicast and Unicast) and Promiscuous Mode.
  *
  ******************************************************************************/
 
@@ -43,9 +43,9 @@
  ******************************************************************************/
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skaddr.c,v 1.52 2003/06/02 13:46:15 tschilli Exp $ (C) Marvell.";
+	"@(#) $Id: skaddr.c,v 2.2 2003/11/24 12:22:01 mkarl Exp $ (C) Marvell.";
 #endif /* DEBUG ||!LINT || !SK_SLIM */
 
 #define __SKADDR_C
 
@@ -212,9 +212,9 @@ int		Level)	/* initialization level */
 					pAC->Addr.Net[i].PermanentMacAddress.a[1],
 					pAC->Addr.Net[i].PermanentMacAddress.a[2],
 					pAC->Addr.Net[i].PermanentMacAddress.a[3],
 					pAC->Addr.Net[i].PermanentMacAddress.a[4],
-					pAC->Addr.Net[i].PermanentMacAddress.a[5]))
+					pAC->Addr.Net[i].PermanentMacAddress.a[5]));
 			
 			SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_INIT,
 				("Logical MAC Address (Net%d): %02X %02X %02X %02X %02X %02X\n",
 					i,
@@ -222,9 +222,9 @@ int		Level)	/* initialization level */
 					pAC->Addr.Net[i].CurrentMacAddress.a[1],
 					pAC->Addr.Net[i].CurrentMacAddress.a[2],
 					pAC->Addr.Net[i].CurrentMacAddress.a[3],
 					pAC->Addr.Net[i].CurrentMacAddress.a[4],
-					pAC->Addr.Net[i].CurrentMacAddress.a[5]))
+					pAC->Addr.Net[i].CurrentMacAddress.a[5]));
 		}
 #endif	/* DEBUG */
 
 		for (i = 0; i < (SK_U32) pAC->GIni.GIMacsFound; i++) {
@@ -265,18 +265,18 @@ int		Level)	/* initialization level */
 					pAPort->PermanentMacAddress.a[1],
 					pAPort->PermanentMacAddress.a[2],
 					pAPort->PermanentMacAddress.a[3],
 					pAPort->PermanentMacAddress.a[4],
-					pAPort->PermanentMacAddress.a[5]))
+					pAPort->PermanentMacAddress.a[5]));
 			
 			SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_INIT,
 				("SkAddrInit: Physical MAC Address: %02X %02X %02X %02X %02X %02X\n",
 					pAPort->CurrentMacAddress.a[0],
 					pAPort->CurrentMacAddress.a[1],
 					pAPort->CurrentMacAddress.a[2],
 					pAPort->CurrentMacAddress.a[3],
 					pAPort->CurrentMacAddress.a[4],
-					pAPort->CurrentMacAddress.a[5]))
+					pAPort->CurrentMacAddress.a[5]));
 #endif /* DEBUG */
 		}
 		/* pAC->Addr.InitDone = SK_INIT_IO; */
 		break;
@@ -338,12 +338,16 @@ int		Flags)		/* permanent/non-perm, sw-o
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
 	
 	if (pAC->GIni.GIGenesis) {
+#ifdef GENESIS
 		ReturnCode = SkAddrXmacMcClear(pAC, IoC, PortNumber, Flags);
+#endif
 	}
 	else {
+#ifdef YUKON
 		ReturnCode = SkAddrGmacMcClear(pAC, IoC, PortNumber, Flags);
+#endif
 	}
 
 	return (ReturnCode);
 
@@ -351,9 +355,9 @@ int		Flags)		/* permanent/non-perm, sw-o
 
 #endif /* !SK_SLIM */
 
 #ifndef SK_SLIM
-
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkAddrXmacMcClear - clear the multicast table
  *
@@ -403,13 +407,13 @@ int		Flags)		/* permanent/non-perm, sw-o
 
 	return (SK_ADDR_SUCCESS);
 	
 }	/* SkAddrXmacMcClear */
-
+#endif	/* GENESIS */
 #endif /* !SK_SLIM */
 
 #ifndef SK_SLIM
-
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkAddrGmacMcClear - clear the multicast table
  *
@@ -446,9 +450,9 @@ int		Flags)		/* permanent/non-perm, sw-o
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[3],
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[4],
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[5],
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[6],
-			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[7]))
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[7]));
 #endif	/* DEBUG */
 
 	/* Clear InexactFilter */
 	for (i = 0; i < 8; i++) {
@@ -488,9 +492,9 @@ int		Flags)		/* permanent/non-perm, sw-o
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[3],
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[4],
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[5],
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[6],
-			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[7]))
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[7]));
 #endif	/* DEBUG */
 	
 	if (!(Flags & SK_MC_SW_ONLY)) {
 		(void) SkAddrGmacMcUpdate(pAC, IoC, PortNumber);
@@ -498,11 +502,12 @@ int		Flags)		/* permanent/non-perm, sw-o
 	
 	return (SK_ADDR_SUCCESS);
 
 }	/* SkAddrGmacMcClear */
+#endif	/* YUKON */
 
 #ifndef SK_ADDR_CHEAT
-
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmacMcHash - hash multicast address
  *
@@ -537,10 +542,11 @@ unsigned char *pMc)	/* Multicast address
 
 	return (Crc & ((1 << HASH_BITS) - 1));
 
 }	/* SkXmacMcHash */
+#endif	/* GENESIS */
 
-
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkGmacMcHash - hash multicast address
  *
@@ -596,9 +602,9 @@ unsigned char *pMc)	/* Multicast address
 	
 	return (Crc & ((1 << HASH_BITS) - 1));
 
 }	/* SkGmacMcHash */
-
+#endif	/* YUKON */
 #endif	/* !SK_ADDR_CHEAT */
 
 /******************************************************************************
  *
@@ -637,19 +643,23 @@ int			Flags)		/* permanent/non-permanent
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
 	
 	if (pAC->GIni.GIGenesis) {
+#ifdef GENESIS
 		ReturnCode = SkAddrXmacMcAdd(pAC, IoC, PortNumber, pMc, Flags);
+#endif
 	}
 	else {
+#ifdef YUKON
 		ReturnCode = SkAddrGmacMcAdd(pAC, IoC, PortNumber, pMc, Flags);
+#endif
 	}
 
 	return (ReturnCode);
 
 }	/* SkAddrMcAdd */
 
-
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkAddrXmacMcAdd - add a multicast address to a port
  *
@@ -757,10 +767,11 @@ int		Flags)		/* permanent/non-permanent 
 		return (SK_MC_FILTERING_INEXACT);
 	}
 
 }	/* SkAddrXmacMcAdd */
+#endif	/* GENESIS */
 
-
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkAddrGmacMcAdd - add a multicast address to a port
  *
@@ -820,9 +831,9 @@ int		Flags)		/* permanent/non-permanent 
 			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[3],
 			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[4],
 			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[5],
 			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[6],
-			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[7]))
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[7]));
 #endif	/* DEBUG */
 	}
 	else {	/* not permanent => DRV */
 		
@@ -844,9 +855,9 @@ int		Flags)		/* permanent/non-permanent 
 			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[3],
 			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[4],
 			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[5],
 			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[6],
-			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[7]))
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[7]));
 #endif	/* DEBUG */
 	}
 	
 #else	/* SK_ADDR_CHEAT */
@@ -859,9 +870,9 @@ int		Flags)		/* permanent/non-permanent 
 		
 	return (SK_MC_FILTERING_INEXACT);
 	
 }	/* SkAddrGmacMcAdd */
-
+#endif	/* YUKON */
 #endif /* !SK_SLIM */
 
 /******************************************************************************
  *
@@ -891,9 +902,9 @@ int	SkAddrMcUpdate(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* I/O context */
 SK_U32	PortNumber)	/* Port Number */
 {
-	int ReturnCode = 0;
+	int ReturnCode;
 #if (!defined(SK_SLIM) || defined(DEBUG))
 	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
@@ -947,15 +958,15 @@ SK_U32	PortNumber)	/* Port Number */
 	SK_U16		*OutAddr;
 	SK_ADDR_PORT	*pAPort;
 
 	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
-		("SkAddrXmacMcUpdate on Port %u.\n", PortNumber))
+		("SkAddrXmacMcUpdate on Port %u.\n", PortNumber));
 	
 	pAPort = &pAC->Addr.Port[PortNumber];
 
 #ifdef DEBUG
 	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
-		("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]))
+		("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]));
 #endif /* DEBUG */
 
 	/* Start with 0 to also program the logical MAC address. */
 	for (i = 0; i < pAPort->NextExactMatchRlmt; i++) {
@@ -1042,9 +1053,9 @@ SK_U32	PortNumber)	/* Port Number */
 				pAPort->Exact[i].a[1],
 				pAPort->Exact[i].a[2],
 				pAPort->Exact[i].a[3],
 				pAPort->Exact[i].a[4],
-				pAPort->Exact[i].a[5]))
+				pAPort->Exact[i].a[5]));
 	}
 #endif /* DEBUG */
 
 	/* Determine return value. */
@@ -1094,15 +1105,15 @@ SK_U32	PortNumber)	/* Port Number */
 	SK_U16		*OutAddr;
 	SK_ADDR_PORT	*pAPort;
 
 	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
-		("SkAddrGmacMcUpdate on Port %u.\n", PortNumber))
+		("SkAddrGmacMcUpdate on Port %u.\n", PortNumber));
 	
 	pAPort = &pAC->Addr.Port[PortNumber];
 
 #ifdef DEBUG
 	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
-		("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]))
+		("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]));
 #endif /* DEBUG */
 	
 #ifndef SK_SLIM
 	for (Inexact = 0, i = 0; i < 8; i++) {
@@ -1156,18 +1167,18 @@ SK_U32	PortNumber)	/* Port Number */
 			pAPort->Exact[0].a[1],
 			pAPort->Exact[0].a[2],
 			pAPort->Exact[0].a[3],
 			pAPort->Exact[0].a[4],
-			pAPort->Exact[0].a[5]))
+			pAPort->Exact[0].a[5]));
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
 		("SkAddrGmacMcUpdate: Physical MAC Address: %02X %02X %02X %02X %02X %02X\n",
 			pAPort->CurrentMacAddress.a[0],
 			pAPort->CurrentMacAddress.a[1],
 			pAPort->CurrentMacAddress.a[2],
 			pAPort->CurrentMacAddress.a[3],
 			pAPort->CurrentMacAddress.a[4],
-			pAPort->CurrentMacAddress.a[5]))
+			pAPort->CurrentMacAddress.a[5]));
 #endif /* DEBUG */
 	
 #ifndef SK_SLIM
 	/* Determine return value. */
@@ -1372,18 +1383,18 @@ int			Flags)				/* logical/physical MAC 
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[1],
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[2],
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[3],
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[4],
-				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[5]))
+				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[5]));
 		
 		SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
 			("SkAddrOverride: New logical MAC Address: %02X %02X %02X %02X %02X %02X\n",
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[0],
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[1],
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[2],
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[3],
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[4],
-				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[5]))
+				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[5]));
 #endif /* DEBUG */
 
         /* Write address to first exact match entry of active port. */
 		(void) SkAddrMcUpdate(pAC, IoC, PortNumber);
@@ -1423,9 +1434,9 @@ SK_AC	*pAC,			/* adapter context */
 SK_IOC	IoC,			/* I/O context */
 SK_U32	PortNumber,		/* port whose promiscuous mode changes */
 int		NewPromMode)	/* new promiscuous mode */
 {
-	int ReturnCode = 0;
+	int ReturnCode;
 #if (!defined(SK_SLIM) || defined(DEBUG))
 	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
Index: linux-2.6.8/drivers/net/sk98lin/skcsum.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skcsum.c
+++ linux-2.6.8/drivers/net/sk98lin/skcsum.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skcsum.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12 $
- * Date:	$Date: 2003/08/20 13:55:53 $
+ * Version:	$Revision: 2.1 $
+ * Date:	$Date: 2003/10/27 14:16:08 $
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
 
@@ -24,9 +24,9 @@
 #ifdef SK_USE_CSUM	/* Check if CSUM is to be used. */
 
 #ifndef lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skcsum.c,v 1.12 2003/08/20 13:55:53 mschmid Exp $ (C) SysKonnect.";
+	"@(#) $Id: skcsum.c,v 2.1 2003/10/27 14:16:08 amock Exp $ (C) SysKonnect.";
 #endif	/* !lint */
 
 /******************************************************************************
  *
Index: linux-2.6.8/drivers/net/sk98lin/skdim.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skdim.c
+++ linux-2.6.8/drivers/net/sk98lin/skdim.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skdim.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.5 $
- * Date:	$Date: 2003/11/28 12:55:40 $
+ * Version:	$Revision: 1.2 $
+ * Date:	$Date: 2004/05/25 09:13:58 $
  * Purpose:	All functions to maintain interrupt moderation
  *
  ******************************************************************************/
 
@@ -37,9 +37,9 @@
  ******************************************************************************/
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skdim.c,v 1.5 2003/11/28 12:55:40 rroesler Exp $ (C) SysKonnect.";
+	"@(#) $Id: skdim.c,v 1.2 2004/05/25 09:13:58 rroesler Exp $ (C) SysKonnect.";
 #endif
 
 #define __SKADDR_C
 
@@ -494,8 +494,10 @@ EnableIntMod(SK_AC *pAC) {
     unsigned long ModBase;
 
     if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
        ModBase = C_CLK_FREQ_GENESIS / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    } else if (pAC->GIni.GIChipId == CHIP_ID_YUKON_EC) {
+       ModBase = C_CLK_FREQ_YUKON_EC / pAC->DynIrqModInfo.MaxModIntsPerSec;
     } else {
        ModBase = C_CLK_FREQ_YUKON / pAC->DynIrqModInfo.MaxModIntsPerSec;
     }
 
Index: linux-2.6.8/drivers/net/sk98lin/skge.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skge.c
+++ linux-2.6.8/drivers/net/sk98lin/skge.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skge.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.45 $
- * Date:       	$Date: 2004/02/12 14:41:02 $
+ * Version:	$Revision: 1.50 $
+ * Date:       	$Date: 2004/07/08 08:30:21 $
  * Purpose:	The main driver source module
  *
  ******************************************************************************/
 
@@ -18,9 +18,9 @@
  *
  *	Created 10-Feb-1999, based on Linux' acenic.c, 3c59x.c and
  *	SysKonnects GEnesis Solaris driver
  *	Author: Christoph Goos (cgoos@syskonnect.de)
- *	        Mirko Lindner (mlindner@syskonnect.de)
+ *		Mirko Lindner (mlindner@syskonnect.de)
  *
  *	Address all question to: linux@syskonnect.de
  *
  *	The technical manual for the adapters is available from SysKonnect's
@@ -93,9 +93,9 @@
  *      "h/skdrv2nd.h"
  *		"h/skqueue.h"
  *		"h/skgehwt.h"
  *		"h/sktimer.h"
- *		"h/ski2c.h"
+ *		"h/sktwsi.h"
  *		"h/skgepnmi.h"
  *		"h/skvpd.h"
  *		"h/skgehw.h"
  *		"h/skgeinit.h"
@@ -129,13 +129,17 @@
 
 /* use the receive hw checksum driver functionality */
 #define USE_SK_RX_CHECKSUM
 
+/* do not wait for TX interrupts, but poll instead */
+// #define YK2_TX_POLLING
+
 /* use the scatter-gather functionality with sendfile() */
-#define SK_ZEROCOPY
+/* The CONFIG_SK98LIN_ZEROCOPY define is handled be the installer or the kernel */
+/* #define CONFIG_SK98LIN_ZEROCOPY */
 
 /* use of a transmit complete interrupt */
-#define USE_TX_COMPLETE
+// #define USE_TX_COMPLETE
 
 /*
  * threshold for copying small receive frames
  * set to 0 to avoid copying, set to 9001 to copy all frames
@@ -144,10 +148,8 @@
 
 /* number of adapters that can be configured via command line params */
 #define SK_MAX_CARD_PARAM	16
 
-
-
 /*
  * use those defines for a compile-in version of the driver instead
  * of command line parameters
  */
@@ -164,37 +166,31 @@
 // #define PREF_PORT	{"A", }
 // #define CON_TYPE 	{"Auto", }
 // #define RLMT_MODE	{"CheckLinkState", }
 
-#define DEV_KFREE_SKB(skb) dev_kfree_skb(skb)
-#define DEV_KFREE_SKB_IRQ(skb) dev_kfree_skb_irq(skb)
-#define DEV_KFREE_SKB_ANY(skb) dev_kfree_skb_any(skb)
-
-
 /* Set blink mode*/
 #define OEM_CONFIG_VALUE (	SK_ACT_LED_BLINK | \
 				SK_DUP_LED_NORMAL | \
 				SK_LED_LINK100_ON)
 
-
-/* Isr return value */
-#define SkIsrRetVar	irqreturn_t
-#define SkIsrRetNone	IRQ_NONE
-#define SkIsrRetHandled	IRQ_HANDLED
+#define CLEAR_AND_START_RX(Port) SK_OUT8(pAC->IoBase, RxQueueAddr[(Port)]+Q_CSR, CSR_START | CSR_IRQ_CL_F)
+#define CLEAR_TX_IRQ(Port,Prio) SK_OUT8(pAC->IoBase, TxQueueAddr[(Port)][(Prio)]+Q_CSR, CSR_IRQ_CL_F)
 
 
 /*******************************************************************************
  *
  * Local Function Prototypes
  *
  ******************************************************************************/
 
+static int 	__devinit sk98lin_init_device(struct pci_dev *pdev, const struct pci_device_id *ent);
+static void 	sk98lin_remove_device(struct pci_dev *pdev);
 static void	FreeResources(struct SK_NET_DEVICE *dev);
 static int	SkGeBoardInit(struct SK_NET_DEVICE *dev, SK_AC *pAC);
 static SK_BOOL	BoardAllocMem(SK_AC *pAC);
 static void	BoardFreeMem(SK_AC *pAC);
 static void	BoardInitMem(SK_AC *pAC);
-static void	SetupRing(SK_AC*, void*, uintptr_t, RXD**, RXD**, RXD**, int*, SK_BOOL);
+static void	SetupRing(SK_AC*, void*, uintptr_t, RXD**, RXD**, RXD**, int*, int*, SK_BOOL);
 static SkIsrRetVar	SkGeIsr(int irq, void *dev_id, struct pt_regs *ptregs);
 static SkIsrRetVar	SkGeIsrOnePort(int irq, void *dev_id, struct pt_regs *ptregs);
 static int	SkGeOpen(struct SK_NET_DEVICE *dev);
 static int	SkGeClose(struct SK_NET_DEVICE *dev);
@@ -208,36 +204,50 @@ static void	ProductStr(SK_AC*);
 static int	XmitFrame(SK_AC*, TX_PORT*, struct sk_buff*);
 static void	FreeTxDescriptors(SK_AC*pAC, TX_PORT*);
 static void	FillRxRing(SK_AC*, RX_PORT*);
 static SK_BOOL	FillRxDescriptor(SK_AC*, RX_PORT*);
+#ifdef CONFIG_SK98LIN_NAPI
+static int	SkGePoll(struct net_device *dev, int *budget);
+static void	ReceiveIrq(SK_AC*, RX_PORT*, SK_BOOL, int*, int);
+#else
 static void	ReceiveIrq(SK_AC*, RX_PORT*, SK_BOOL);
-static void	ClearAndStartRx(SK_AC*, int);
-static void	ClearTxIrq(SK_AC*, int, int);
+#endif
 static void	ClearRxRing(SK_AC*, RX_PORT*);
 static void	ClearTxRing(SK_AC*, TX_PORT*);
 static int	SkGeChangeMtu(struct SK_NET_DEVICE *dev, int new_mtu);
 static void	PortReInitBmu(SK_AC*, int);
 static int	SkGeIocMib(DEV_NET*, unsigned int, int);
 static int	SkGeInitPCI(SK_AC *pAC);
-static void	StartDrvCleanupTimer(SK_AC *pAC);
-static void	StopDrvCleanupTimer(SK_AC *pAC);
-static int	XmitFrameSG(SK_AC*, TX_PORT*, struct sk_buff*);
-
-#ifdef SK_DIAG_SUPPORT
 static SK_U32   ParseDeviceNbrFromSlotName(const char *SlotName);
 static int      SkDrvInitAdapter(SK_AC *pAC, int devNbr);
 static int      SkDrvDeInitAdapter(SK_AC *pAC, int devNbr);
-#endif
+static int	XmitFrameSG(SK_AC*, TX_PORT*, struct sk_buff*);
 
 /*******************************************************************************
  *
  * Extern Function Prototypes
  *
  ******************************************************************************/
 
+extern SK_BOOL SkY2AllocateResources(SK_AC *pAC);
+extern void SkY2FreeResources(SK_AC *pAC);
+extern void SkY2AllocateRxBuffers(SK_AC *pAC,SK_IOC IoC,int Port);
+extern void SkY2FreeRxBuffers(SK_AC *pAC,SK_IOC IoC,int Port);
+extern void SkY2FreeTxBuffers(SK_AC *pAC,SK_IOC IoC,int Port);
+extern SkIsrRetVar SkY2Isr(int irq,void *dev_id,struct pt_regs *ptregs);
+extern int SkY2Xmit(struct sk_buff *skb,struct SK_NET_DEVICE *dev);
+extern void SkY2PortStop(SK_AC *pAC,SK_IOC IoC,int Port,int Dir,int RstMode);
+extern void SkY2PortStart(SK_AC *pAC,SK_IOC IoC,int Port);
+extern int SkY2RlmtSend(SK_AC *pAC,int PortNr,struct sk_buff *pMessage);
+extern void SkY2RestartStatusUnit(SK_AC *pAC);
+#ifdef CONFIG_SK98LIN_NAPI
+extern int SkY2Poll(struct net_device *dev, int *budget);
+#endif
+
+
 #ifdef CONFIG_PROC_FS
 static const char 	SK_Root_Dir_entry[] = "sk98lin";
-static struct		proc_dir_entry *pSkRootDir;
+static struct		proc_dir_entry *pSkRootDir = NULL;
 extern struct	file_operations sk_proc_fops;
 #endif
 
 extern void SkDimEnableModerationIfNeeded(SK_AC *pAC);	
@@ -251,14 +261,356 @@ static void	DumpData(char*, int);
 static void	DumpLong(char*, int);
 #endif
 
 /* global variables *********************************************************/
+static const char *BootString = BOOT_STRING;
 struct SK_NET_DEVICE *SkGeRootDev = NULL;
 static SK_BOOL DoPrintInterfaceChange = SK_TRUE;
 
 /* local variables **********************************************************/
 static uintptr_t TxQueueAddr[SK_MAX_MACS][2] = {{0x680, 0x600},{0x780, 0x700}};
 static uintptr_t RxQueueAddr[SK_MAX_MACS] = {0x400, 0x480};
+static int sk98lin_max_boards_found = 0;
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry	*pSkRootDir;
+#endif
+
+
+
+static struct pci_device_id sk98lin_pci_tbl[] __devinitdata = {
+/*	{ pci_vendor_id, pci_device_id, * SAMPLE ENTRY! *
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL }, */
+	{ 0x10b7, 0x1700, /* 3Com (10b7), Gigabit Ethernet Adapter */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x1148, 0x4300, /* SysKonnect (1148), SK-98xx Gigabit Ethernet Server Adapter */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x1148, 0x4320, /* SysKonnect (1148), SK-98xx V2.0 Gigabit Ethernet Adapter */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x1148, 0x9E00, /* SysKonnect (1148), SK-9Exx 10/100/1000Base-T Adapter */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x1186, 0x4c00, /* D-Link (1186), Gigabit Ethernet Adapter */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x11ab, 0x4320, /* Marvell (11ab), Gigabit Ethernet Controller */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x11ab, 0x4350, /* Marvell (11ab), Fast Ethernet Controller */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x11ab, 0x4351, /* Marvell (11ab), Fast Ethernet Controller */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x11ab, 0x4360, /* Marvell (11ab), Gigabit Ethernet Controller */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x11ab, 0x4361, /* Marvell (11ab), Gigabit Ethernet Controller */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x11ab, 0x4362, /* Marvell (11ab), Gigabit Ethernet Controller */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x11ab, 0x5005, /* Marvell (11ab), Belkin */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x1371, 0x434e, /* CNet (1371), GigaCard Network Adapter */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x1737, 0x1032, /* Linksys (1737), Gigabit Network Adapter */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0x1737, 0x1064, /* Linksys (1737), Gigabit Network Adapter */
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, sk98lin_pci_tbl);
+
+static struct pci_driver sk98lin_driver = {
+	.name		= DRIVER_FILE_NAME,
+	.id_table	= sk98lin_pci_tbl,
+	.probe		= sk98lin_init_device,
+	.remove		= __devexit_p(sk98lin_remove_device)
+/*	.suspend	= sk98lin_suspend,	DRIVER SUSPEND	*/
+/*	.resume		= sk98lin_resume  	DRIVER RESUME	*/
+};
+
+
+/*****************************************************************************
+ *
+ * 	sk98lin_init_device - initialize the adapter
+ *
+ * Description:
+ *	This function initializes the adapter. Resources for
+ *	the adapter are allocated and the adapter is brought into Init 1
+ *	state.
+ *
+ * Returns:
+ *	0, if everything is ok
+ *	!=0, on error
+ */
+static int __devinit sk98lin_init_device(struct pci_dev *pdev,
+				  const struct pci_device_id *ent)
+{
+	static SK_BOOL 		sk98lin_boot_string = SK_FALSE;
+	static SK_BOOL 		sk98lin_proc_entry = SK_FALSE;
+	static int		sk98lin_boards_found = 0;
+	SK_AC			*pAC;
+	DEV_NET			*pNet = NULL;
+	struct SK_NET_DEVICE *dev = NULL;
+	int			retval;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry	*pProcFile;
+#endif
+
+	retval = pci_enable_device(pdev);
+	if (retval) {
+		printk(KERN_ERR "Cannot enable PCI device, "
+			"aborting.\n");
+		return retval;
+	}
+
+	dev = NULL;
+	pNet = NULL;
+
+
+	/* INSERT * We have to find the power-management capabilities */
+	/* Find power-management capability. */
+
+
+
+	/* Configure DMA attributes. */
+	retval = pci_set_dma_mask(pdev, (u64) 0xffffffffffffffffULL);
+	if (!retval) {
+		retval = pci_set_dma_mask(pdev, (u64) 0xffffffff);
+		if (retval)
+			return retval;
+	} else {
+		return retval;
+	}
+
+
+	if ((dev = alloc_etherdev(sizeof(DEV_NET))) == NULL) {
+		printk(KERN_ERR "Unable to allocate etherdev "
+			"structure!\n");
+		return -ENODEV;
+	}
+
+	pNet = dev->priv;
+	pNet->pAC = kmalloc(sizeof(SK_AC), GFP_KERNEL);
+	if (pNet->pAC == NULL){
+		free_netdev(dev);
+		printk(KERN_ERR "Unable to allocate adapter "
+			"structure!\n");
+		return -ENODEV;
+	}
+
+
+	/* Print message */
+	if (!sk98lin_boot_string) {
+		/* set display flag to TRUE so that */
+		/* we only display this string ONCE */
+		sk98lin_boot_string = SK_TRUE;
+		printk("%s\n", BootString);
+	}
+
+	memset(pNet->pAC, 0, sizeof(SK_AC));
+	pAC = pNet->pAC;
+	pAC->PciDev = pdev;
+	pAC->PciDevId = pdev->device;
+	pAC->dev[0] = dev;
+	pAC->dev[1] = dev;
+	sprintf(pAC->Name, "SysKonnect SK-98xx");
+	pAC->CheckQueue = SK_FALSE;
+
+	pNet->Mtu = 1500;
+	pNet->Up = 0;
+	dev->irq = pdev->irq;
+	retval = SkGeInitPCI(pAC);
+	if (retval) {
+		printk("SKGE: PCI setup failed: %i\n", retval);
+		free_netdev(dev);
+		return -ENODEV;
+	}
+
+	SET_MODULE_OWNER(dev);
+
+	dev->open =		&SkGeOpen;
+	dev->stop =		&SkGeClose;
+	dev->get_stats =	&SkGeStats;
+	//dev->last_stats =	&SkGeStats;
+	dev->set_multicast_list = &SkGeSetRxMode;
+	dev->set_mac_address =	&SkGeSetMacAddr;
+	dev->do_ioctl =		&SkGeIoctl;
+	dev->change_mtu =	&SkGeChangeMtu;
+	dev->flags &= 		~IFF_RUNNING;
+
+	pAC->Index = sk98lin_boards_found;
+
+	if (SkGeBoardInit(dev, pAC)) {
+		free_netdev(dev);
+		return -ENODEV;
+	}
+
+	/* shifter to later moment in time... */
+	if (CHIP_ID_YUKON_2(pAC)) {
+		dev->hard_start_xmit =	&SkY2Xmit;
+	} else {
+		dev->hard_start_xmit =	&SkGeXmit;
+	}
+
+#ifdef CONFIG_SK98LIN_ZEROCOPY
+#ifdef USE_SK_TX_CHECKSUM
+	if (pAC->ChipsetType) {
+#ifdef CONFIG_SMP
+		/* using SG on 'real' SMP systems slows down sendfile() */ 
+		if (num_online_cpus() == 1) {
+#endif
+			dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
+#ifdef CONFIG_SMP
+		}
+#endif
+	}
+#endif
+#endif
+
+
+	/* Save the hardware revision */
+	pAC->HWRevision = (((pAC->GIni.GIPciHwRev >> 4) & 0x0F)*10) +
+		(pAC->GIni.GIPciHwRev & 0x0F);
+
+	/* Set driver globals */
+	pAC->Pnmi.pDriverFileName    = DRIVER_FILE_NAME;
+	pAC->Pnmi.pDriverReleaseDate = DRIVER_REL_DATE;
+
+	SK_MEMSET(&(pAC->PnmiBackup), 0, sizeof(SK_PNMI_STRUCT_DATA));
+	SK_MEMCPY(&(pAC->PnmiBackup), &(pAC->PnmiStruct), 
+			sizeof(SK_PNMI_STRUCT_DATA));
+
+	/* Register net device */
+	retval = register_netdev(dev);
+	if (retval) {
+		printk(KERN_ERR "SKGE: Could not register device.\n");
+		FreeResources(dev);
+		free_netdev(dev);
+		return retval;
+	}
+
+	/* Print adapter specific string from vpd */
+	ProductStr(pAC);
+	printk("%s: %s\n", dev->name, pAC->DeviceStr);
+
+	/* Print configuration settings */
+	printk("      PrefPort:%c  RlmtMode:%s\n",
+		'A' + pAC->Rlmt.Net[0].Port[pAC->Rlmt.Net[0].PrefPort]->PortNumber,
+		(pAC->RlmtMode==0)  ? "Check Link State" :
+		((pAC->RlmtMode==1) ? "Check Link State" :
+		((pAC->RlmtMode==3) ? "Check Local Port" :
+		((pAC->RlmtMode==7) ? "Check Segmentation" :
+		((pAC->RlmtMode==17) ? "Dual Check Link State" :"Error")))));
+
+	SkGeYellowLED(pAC, pAC->IoBase, 1);
+
+	memcpy((caddr_t) &dev->dev_addr,
+		(caddr_t) &pAC->Addr.Net[0].CurrentMacAddress, 6);
+
+	/* First adapter... Create proc and print message */
+#ifdef CONFIG_PROC_FS
+	if (!sk98lin_proc_entry) {
+		sk98lin_proc_entry = SK_TRUE;
+		SK_MEMCPY(&SK_Root_Dir_entry, BootString,
+			sizeof(SK_Root_Dir_entry) - 1);
+
+		/*Create proc (directory)*/
+		if(!pSkRootDir) {
+			pSkRootDir = proc_mkdir(SK_Root_Dir_entry, proc_net);
+			if (!pSkRootDir) {
+				printk(KERN_WARNING "%s: Unable to create /proc/net/%s",
+					dev->name, SK_Root_Dir_entry);
+			} else {
+				pSkRootDir->owner = THIS_MODULE;
+			}
+		}
+	}
+
+	/* Create proc file */
+	if (pSkRootDir && 
+		(pProcFile = create_proc_entry(dev->name, S_IRUGO,
+			pSkRootDir))) {
+		pProcFile->proc_fops = &sk_proc_fops;
+		pProcFile->data      = dev;
+	}
+
+#endif
+
+	pNet->PortNr = 0;
+	pNet->NetNr  = 0;
+
+	sk98lin_boards_found++;
+	pci_set_drvdata(pdev, dev);
+
+	/* More then one port found */
+	if ((pAC->GIni.GIMacsFound == 2 ) && (pAC->RlmtNets == 2)) {
+		if ((dev = alloc_etherdev(sizeof(DEV_NET))) == 0) {
+			printk(KERN_ERR "Unable to allocate etherdev "
+				"structure!\n");
+			return -ENODEV;
+		}
+
+		pAC->dev[1]   = dev;
+		pNet          = dev->priv;
+		pNet->PortNr  = 1;
+		pNet->NetNr   = 1;
+		pNet->pAC     = pAC;
+		pNet->Mtu     = 1500;
+		pNet->Up      = 0;
+
+		if (CHIP_ID_YUKON_2(pAC)) {
+			dev->hard_start_xmit = &SkY2Xmit;
+		} else {
+			dev->hard_start_xmit = &SkGeXmit;
+		}
+		dev->open               = &SkGeOpen;
+		dev->stop               = &SkGeClose;
+		dev->get_stats          = &SkGeStats;
+		//dev->last_stats	= &SkGeStats;
+		dev->set_multicast_list = &SkGeSetRxMode;
+		dev->set_mac_address    = &SkGeSetMacAddr;
+		dev->do_ioctl           = &SkGeIoctl;
+		dev->change_mtu         = &SkGeChangeMtu;
+		dev->flags             &= ~IFF_RUNNING;
+
+#ifdef CONFIG_SK98LIN_ZEROCOPY
+#ifdef USE_SK_TX_CHECKSUM
+		if (pAC->ChipsetType) {
+#ifdef CONFIG_SMP
+			/* using SG on 'real' SMP systems slows down sendfile() */ 
+			if (num_online_cpus() == 1) {
+#endif
+				dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
+#ifdef CONFIG_SMP
+			}
+#endif
+		}
+#endif
+#endif
+
+		if (register_netdev(dev)) {
+			printk(KERN_ERR "SKGE: Could not register device.\n");
+			free_netdev(dev);
+			pAC->dev[1] = pAC->dev[0];
+		} else {
+#ifdef CONFIG_PROC_FS
+		if (pSkRootDir 
+		    && (pProcFile = create_proc_entry(dev->name, 
+						S_IRUGO, pSkRootDir))) {
+			pProcFile->proc_fops = &sk_proc_fops;
+			pProcFile->data      = dev;
+		}
+#endif
+
+		memcpy((caddr_t) &dev->dev_addr,
+		(caddr_t) &pAC->Addr.Net[1].CurrentMacAddress, 6);
+	
+		printk("%s: %s\n", dev->name, pAC->DeviceStr);
+		printk("      PrefPort:B  RlmtMode:Dual Check Link State\n");
+		}
+	}
+
+	pAC->Index = sk98lin_boards_found;
+	sk98lin_max_boards_found = sk98lin_boards_found;
+	return 0;
+}
 
 /*****************************************************************************
  *
  * 	SkGeInitPCI - Init the PCI resources
@@ -372,9 +724,8 @@ MODULE_PARM(Role_A,	"1-" __MODULE_STRING
 MODULE_PARM(Role_B,	"1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(ConType,	"1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(PrefPort,   "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(RlmtMode,   "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
-/* used for interrupt moderation */
 MODULE_PARM(IntsPerSec,     "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "i");
 MODULE_PARM(Moderation,     "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(Stats,          "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(ModerationMask, "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
@@ -452,19 +803,113 @@ static char *PrefPort[SK_MAX_CARD_PARAM]
 #else
 static char *PrefPort[SK_MAX_CARD_PARAM] = {"", };
 #endif
 
-#ifdef RLMT_MODE
-static char *RlmtMode[SK_MAX_CARD_PARAM] = RLMT_MODE;
-#else
-static char *RlmtMode[SK_MAX_CARD_PARAM] = {"", };
+#ifdef RLMT_MODE
+static char *RlmtMode[SK_MAX_CARD_PARAM] = RLMT_MODE;
+#else
+static char *RlmtMode[SK_MAX_CARD_PARAM] = {"", };
+#endif
+
+static int   IntsPerSec[SK_MAX_CARD_PARAM];
+static char *Moderation[SK_MAX_CARD_PARAM];
+static char *ModerationMask[SK_MAX_CARD_PARAM];
+static char *AutoSizing[SK_MAX_CARD_PARAM];
+static char *Stats[SK_MAX_CARD_PARAM];
+
+
+
+/*****************************************************************************
+ *
+ * 	sk98lin_remove_device - device deinit function
+ *
+ * Description:
+ *	Disable adapter if it is still running, free resources,
+ *	free device struct.
+ *
+ * Returns: N/A
+ */
+
+static void sk98lin_remove_device(struct pci_dev *pdev)
+{
+DEV_NET		*pNet;
+SK_AC		*pAC;
+struct SK_NET_DEVICE *next;
+unsigned long Flags;
+SK_EVPARA EvPara;
+struct net_device *dev = pci_get_drvdata(pdev);
+
+
+	/* Device not available. Return. */
+	if (!dev)
+		return;
+
+	pNet = (DEV_NET*) dev->priv;
+	pAC = pNet->pAC;
+	next = pAC->Next;
+
+	netif_stop_queue(dev);
+	SkGeYellowLED(pAC, pAC->IoBase, 0);
+
+	if(pAC->BoardLevel == SK_INIT_RUN) {
+		/* board is still alive */
+		spin_lock_irqsave(&pAC->SlowPathLock, Flags);
+		EvPara.Para32[0] = 0;
+		EvPara.Para32[1] = -1;
+		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
+		EvPara.Para32[0] = 1;
+		EvPara.Para32[1] = -1;
+		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
+		SkEventDispatcher(pAC, pAC->IoBase);
+		/* disable interrupts */
+		SK_OUT32(pAC->IoBase, B0_IMSK, 0);
+		SkGeDeInit(pAC, pAC->IoBase);
+		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
+		pAC->BoardLevel = SK_INIT_DATA;
+		/* We do NOT check here, if IRQ was pending, of course*/
+	}
+
+	if(pAC->BoardLevel == SK_INIT_IO) {
+		/* board is still alive */
+		SkGeDeInit(pAC, pAC->IoBase);
+		pAC->BoardLevel = SK_INIT_DATA;
+	}
+
+	if ((pAC->GIni.GIMacsFound == 2) && pAC->RlmtNets == 2){
+		unregister_netdev(pAC->dev[1]);
+		free_netdev(pAC->dev[1]);
+	}
+
+	FreeResources(dev);
+
+#ifdef CONFIG_PROC_FS
+	/* Remove the sk98lin procfs device entries */
+	if ((pAC->GIni.GIMacsFound == 2) && pAC->RlmtNets == 2){
+		remove_proc_entry(pAC->dev[1]->name, pSkRootDir);
+	}
+	remove_proc_entry(dev->name, pSkRootDir);
+#endif
+
+	dev->get_stats = NULL;
+	/*
+	 * otherwise unregister_netdev calls get_stats with
+	 * invalid IO ...  :-(
+	 */
+	unregister_netdev(dev);
+	free_netdev(dev);
+	kfree(pAC);
+	sk98lin_max_boards_found--;
+
+#ifdef CONFIG_PROC_FS
+	/* Remove all Proc entries if last device */
+	if (sk98lin_max_boards_found == 0) {
+		/* clear proc-dir */
+		remove_proc_entry(pSkRootDir->name, proc_net);
+	}
 #endif
 
-static int   IntsPerSec[SK_MAX_CARD_PARAM];
-static char *Moderation[SK_MAX_CARD_PARAM];
-static char *ModerationMask[SK_MAX_CARD_PARAM];
-static char *AutoSizing[SK_MAX_CARD_PARAM];
-static char *Stats[SK_MAX_CARD_PARAM];
+}
+
 
 /*****************************************************************************
  *
  * 	SkGeBoardInit - do level 0 and 1 initialization
@@ -500,9 +945,11 @@ SK_BOOL	DualNet;
 	for (i=0; i<SK_MAX_MACS; i++) {
 		spin_lock_init(&pAC->TxPort[i][0].TxDesRingLock);
 		spin_lock_init(&pAC->RxPort[i].RxDesRingLock);
 	}
+
 	spin_lock_init(&pAC->SlowPathLock);
+	spin_lock_init(&pAC->SetPutIndexLock);	/* for Yukon2 chipsets */
 
 	/* level 0 init common modules here */
 	
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
@@ -541,51 +988,81 @@ SK_BOOL	DualNet;
 	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_IO);
 	SkTimerInit(pAC, pAC->IoBase, SK_INIT_IO);
 
 	/* Set chipset type support */
-	pAC->ChipsetType = 0;
 	if ((pAC->GIni.GIChipId == CHIP_ID_YUKON) ||
-		(pAC->GIni.GIChipId == CHIP_ID_YUKON_LITE)) {
-		pAC->ChipsetType = 1;
+		(pAC->GIni.GIChipId == CHIP_ID_YUKON_LITE) ||
+		(pAC->GIni.GIChipId == CHIP_ID_YUKON_LP)) {
+		pAC->ChipsetType = 1;	/* Yukon chipset (descriptor logic) */
+	} else if (CHIP_ID_YUKON_2(pAC)) {
+		pAC->ChipsetType = 2;	/* Yukon2 chipset (list logic) */
+	} else {
+		pAC->ChipsetType = 0;	/* Genesis chipset (descriptor logic) */
 	}
 
 	GetConfiguration(pAC);
 	if (pAC->RlmtNets == 2) {
-		pAC->GIni.GIPortUsage = SK_MUL_LINK;
+ 		pAC->GIni.GIPortUsage = SK_MUL_LINK;
 	}
 
 	pAC->BoardLevel = SK_INIT_IO;
 	spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 
-	if (pAC->GIni.GIMacsFound == 2) {
-		 Ret = request_irq(dev->irq, SkGeIsr, SA_SHIRQ, pAC->Name, dev);
-	} else if (pAC->GIni.GIMacsFound == 1) {
-		Ret = request_irq(dev->irq, SkGeIsrOnePort, SA_SHIRQ,
-			pAC->Name, dev);
-	} else {
-		printk(KERN_WARNING "sk98lin: Illegal number of ports: %d\n",
-		       pAC->GIni.GIMacsFound);
-		return -EAGAIN;
+	if (!CHIP_ID_YUKON_2(pAC)) {
+#ifdef CONFIG_SK98LIN_NAPI
+		dev->poll =  &SkGePoll;
+		dev->weight = 64;
+#endif
+		if (pAC->GIni.GIMacsFound == 2) {
+			Ret = request_irq(dev->irq, SkGeIsr, SA_SHIRQ, pAC->Name, dev);
+		} else if (pAC->GIni.GIMacsFound == 1) {
+			Ret = request_irq(dev->irq, SkGeIsrOnePort, SA_SHIRQ, pAC->Name, dev);
+		} else {
+			printk(KERN_WARNING "sk98lin: Illegal number of ports: %d\n",
+				pAC->GIni.GIMacsFound);
+			return -EAGAIN;
+		}
+	}
+	else {
+		Ret = request_irq(dev->irq, SkY2Isr, SA_SHIRQ, pAC->Name, dev);
+#ifdef CONFIG_SK98LIN_NAPI
+		dev->poll =  &SkY2Poll;
+		dev->weight = 64;
+#endif
 	}
 
 	if (Ret) {
 		printk(KERN_WARNING "sk98lin: Requested IRQ %d is busy.\n",
-		       dev->irq);
+			dev->irq);
 		return -EAGAIN;
 	}
 	pAC->AllocFlag |= SK_ALLOC_IRQ;
 
-	/* Alloc memory for this board (Mem for RxD/TxD) : */
-	if(!BoardAllocMem(pAC)) {
-		printk("No memory for descriptor rings.\n");
-       		return(-EAGAIN);
+	/* 
+	** Alloc descriptor/LETable memory for this board (both RxD/TxD)
+	*/
+	if (CHIP_ID_YUKON_2(pAC)) {
+		if (!SkY2AllocateResources(pAC)) {
+			printk("No memory for Yukon2 settings\n");
+			return(-EAGAIN);
+		}
+	} else {
+		if(!BoardAllocMem(pAC)) {
+			printk("No memory for descriptor rings.\n");
+			return(-EAGAIN);
+		}
 	}
 
+#ifdef SK_USE_CSUM
 	SkCsSetReceiveFlags(pAC,
 		SKCS_PROTO_IP | SKCS_PROTO_TCP | SKCS_PROTO_UDP,
 		&pAC->CsOfs1, &pAC->CsOfs2, 0);
 	pAC->CsOfs = (pAC->CsOfs2 << 16) | pAC->CsOfs1;
+#endif
 
+	/*
+	** Function BoardInitMem() for Yukon dependent settings...
+	*/
 	BoardInitMem(pAC);
 	/* tschilling: New common function with minimum size check. */
 	DualNet = SK_FALSE;
 	if (pAC->RlmtNets == 2) {
@@ -695,8 +1172,14 @@ SK_AC		*pAC)
 size_t		AllocLength;	/* length of complete descriptor area */
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("BoardFreeMem\n"));
+
+	if (CHIP_ID_YUKON_2(pAC)) {
+		SkY2FreeResources(pAC);
+		return;
+	}
+
 #if (BITS_PER_LONG == 32)
 	AllocLength = (RX_RING_SIZE + TX_RING_SIZE) * pAC->GIni.GIMacsFound + 8;
 #else
 	AllocLength = (RX_RING_SIZE + TX_RING_SIZE) * pAC->GIni.GIMacsFound
@@ -713,9 +1196,9 @@ size_t		AllocLength;	/* length of comple
  *
  * 	BoardInitMem - initiate the descriptor rings
  *
  * Description:
- *	This function sets the descriptor rings up in memory.
+ *	This function sets the descriptor rings or LETables up in memory.
  *	The adapter is initialized with the descriptor start addresses.
  *
  * Returns:	N/A
  */
@@ -728,36 +1211,39 @@ int	TxDescrSize;	/* the size of a tx des
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("BoardInitMem\n"));
 
-	RxDescrSize = (((sizeof(RXD) - 1) / DESCR_ALIGN) + 1) * DESCR_ALIGN;
-	pAC->RxDescrPerRing = RX_RING_SIZE / RxDescrSize;
-	TxDescrSize = (((sizeof(TXD) - 1) / DESCR_ALIGN) + 1) * DESCR_ALIGN;
-	pAC->TxDescrPerRing = TX_RING_SIZE / RxDescrSize;
+	if (!pAC->GIni.GIYukon2) {
+		RxDescrSize = (((sizeof(RXD) - 1) / DESCR_ALIGN) + 1) * DESCR_ALIGN;
+		pAC->RxDescrPerRing = RX_RING_SIZE / RxDescrSize;
+		TxDescrSize = (((sizeof(TXD) - 1) / DESCR_ALIGN) + 1) * DESCR_ALIGN;
+		pAC->TxDescrPerRing = TX_RING_SIZE / RxDescrSize;
 	
-	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		SetupRing(
-			pAC,
-			pAC->TxPort[i][0].pTxDescrRing,
-			pAC->TxPort[i][0].VTxDescrRing,
-			(RXD**)&pAC->TxPort[i][0].pTxdRingHead,
-			(RXD**)&pAC->TxPort[i][0].pTxdRingTail,
-			(RXD**)&pAC->TxPort[i][0].pTxdRingPrev,
-			&pAC->TxPort[i][0].TxdRingFree,
-			SK_TRUE);
-		SetupRing(
-			pAC,
-			pAC->RxPort[i].pRxDescrRing,
-			pAC->RxPort[i].VRxDescrRing,
-			&pAC->RxPort[i].pRxdRingHead,
-			&pAC->RxPort[i].pRxdRingTail,
-			&pAC->RxPort[i].pRxdRingPrev,
-			&pAC->RxPort[i].RxdRingFree,
-			SK_FALSE);
+		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
+			SetupRing(
+				pAC,
+				pAC->TxPort[i][0].pTxDescrRing,
+				pAC->TxPort[i][0].VTxDescrRing,
+				(RXD**)&pAC->TxPort[i][0].pTxdRingHead,
+				(RXD**)&pAC->TxPort[i][0].pTxdRingTail,
+				(RXD**)&pAC->TxPort[i][0].pTxdRingPrev,
+				&pAC->TxPort[i][0].TxdRingFree,
+				&pAC->TxPort[i][0].TxdRingPrevFree,
+				SK_TRUE);
+			SetupRing(
+				pAC,
+				pAC->RxPort[i].pRxDescrRing,
+				pAC->RxPort[i].VRxDescrRing,
+				&pAC->RxPort[i].pRxdRingHead,
+				&pAC->RxPort[i].pRxdRingTail,
+				&pAC->RxPort[i].pRxdRingPrev,
+				&pAC->RxPort[i].RxdRingFree,
+				&pAC->RxPort[i].RxdRingFree,
+				SK_FALSE);
+		}
 	}
 } /* BoardInitMem */
 
-
 /*****************************************************************************
  *
  * 	SetupRing - create one descriptor ring
  *
@@ -775,8 +1261,9 @@ uintptr_t	VMemArea,	/* the virtual bus a
 RXD		**ppRingHead,	/* address where the head should be written */
 RXD		**ppRingTail,	/* address where the tail should be written */
 RXD		**ppRingPrev,	/* address where the tail should be written */
 int		*pRingFree,	/* address where the # of free descr. goes */
+int		*pRingPrevFree,	/* address where the # of free descr. goes */
 SK_BOOL		IsTx)		/* flag: is this a tx ring */
 {
 int	i;		/* loop counter */
 int	DescrSize;	/* the size of a descriptor rounded up to alignment*/
@@ -817,13 +1304,14 @@ uintptr_t VNextDescr;	/* the virtual bus
 		VNextDescr += DescrSize;
 	}
 	pPrevDescr->pNextRxd = (RXD*) pMemArea;
 	pPrevDescr->VNextRxd = VMemArea;
-	pDescr = (RXD*) pMemArea;
-	*ppRingHead = (RXD*) pMemArea;
-	*ppRingTail = *ppRingHead;
-	*ppRingPrev = pPrevDescr;
-	*pRingFree = DescrNum;
+	pDescr               = (RXD*) pMemArea;
+	*ppRingHead          = (RXD*) pMemArea;
+	*ppRingTail          = *ppRingHead;
+	*ppRingPrev          = pPrevDescr;
+	*pRingFree           = DescrNum;
+	*pRingPrevFree       = DescrNum;
 } /* SetupRing */
 
 
 /*****************************************************************************
@@ -897,8 +1385,31 @@ SK_U32		IntSrc;		/* interrupts source re
 	if (IntSrc == 0) {
 		return SkIsrRetNone;
 	}
 
+#ifdef CONFIG_SK98LIN_NAPI
+	if (netif_rx_schedule_prep(dev)) {
+		pAC->GIni.GIValIrqMask &= ~(NAPI_DRV_IRQS);
+		SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
+		__netif_rx_schedule(dev);
+	}
+	if (IntSrc & IS_R1_F) {
+		CLEAR_AND_START_RX(0);
+	}
+	if (IntSrc & IS_R2_F) {
+		CLEAR_AND_START_RX(1);
+	}
+#ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
+	if (IntSrc & IS_XA1_F) {
+		CLEAR_TX_IRQ(0, TX_PRIO_LOW);
+	}
+	if (IntSrc & IS_XA2_F) {
+		CLEAR_TX_IRQ(1, TX_PRIO_LOW);
+	}
+#endif
+
+
+#else
 	while (((IntSrc & IRQ_MASK) & ~SPECIAL_IRQS) != 0) {
 #if 0 /* software irq currently not used */
 		if (IntSrc & IS_IRQ_SW) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
@@ -909,23 +1420,26 @@ SK_U32		IntSrc;		/* interrupts source re
 		if (IntSrc & IS_R1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX1 IRQ\n"));
+			CLEAR_AND_START_RX(0);
 			ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
 			SK_PNMI_CNT_RX_INTR(pAC, 0);
 		}
 		if (IntSrc & IS_R2_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX2 IRQ\n"));
+			CLEAR_AND_START_RX(1);
 			ReceiveIrq(pAC, &pAC->RxPort[1], SK_TRUE);
 			SK_PNMI_CNT_RX_INTR(pAC, 1);
 		}
 #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
 		if (IntSrc & IS_XA1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX1 IRQ\n"));
+			CLEAR_TX_IRQ(0, TX_PRIO_LOW);
 			SK_PNMI_CNT_TX_INTR(pAC, 0);
 			spin_lock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
 			FreeTxDescriptors(pAC, &pAC->TxPort[0][TX_PRIO_LOW]);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
@@ -933,8 +1447,9 @@ SK_U32		IntSrc;		/* interrupts source re
 		if (IntSrc & IS_XA2_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX2 IRQ\n"));
+			CLEAR_TX_IRQ(1, TX_PRIO_LOW);
 			SK_PNMI_CNT_TX_INTR(pAC, 1);
 			spin_lock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
 			FreeTxDescriptors(pAC, &pAC->TxPort[1][TX_PRIO_LOW]);
 			spin_unlock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
@@ -943,40 +1458,30 @@ SK_U32		IntSrc;		/* interrupts source re
 		if (IntSrc & IS_XS1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX1 IRQ\n"));
+			CLEAR_TX_IRQ(0, TX_PRIO_HIGH);
 			SK_PNMI_CNT_TX_INTR(pAC, 1);
 			spin_lock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
 			FreeTxDescriptors(pAC, 0, TX_PRIO_HIGH);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
-			ClearTxIrq(pAC, 0, TX_PRIO_HIGH);
 		}
 		if (IntSrc & IS_XS2_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX2 IRQ\n"));
+			CLEAR_TX_IRQ(1, TX_PRIO_HIGH);
 			SK_PNMI_CNT_TX_INTR(pAC, 1);
 			spin_lock(&pAC->TxPort[1][TX_PRIO_HIGH].TxDesRingLock);
 			FreeTxDescriptors(pAC, 1, TX_PRIO_HIGH);
 			spin_unlock(&pAC->TxPort[1][TX_PRIO_HIGH].TxDesRingLock);
-			ClearTxIrq(pAC, 1, TX_PRIO_HIGH);
 		}
 #endif
 #endif
 
-		/* do all IO at once */
-		if (IntSrc & IS_R1_F)
-			ClearAndStartRx(pAC, 0);
-		if (IntSrc & IS_R2_F)
-			ClearAndStartRx(pAC, 1);
-#ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
-		if (IntSrc & IS_XA1_F)
-			ClearTxIrq(pAC, 0, TX_PRIO_LOW);
-		if (IntSrc & IS_XA2_F)
-			ClearTxIrq(pAC, 1, TX_PRIO_LOW);
-#endif
 		SK_IN32(pAC->IoBase, B0_ISRC, &IntSrc);
 	} /* while (IntSrc & IRQ_MASK != 0) */
+#endif
 
 	IntSrc &= pAC->GIni.GIValIrqMask;
 	if ((IntSrc & SPECIAL_IRQS) || pAC->CheckQueue) {
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
@@ -988,20 +1493,8 @@ SK_U32		IntSrc;		/* interrupts source re
 
 		SkEventDispatcher(pAC, pAC->IoBase);
 		spin_unlock(&pAC->SlowPathLock);
 	}
-	/*
-	 * do it all again is case we cleared an interrupt that
-	 * came in after handling the ring (OUTs may be delayed
-	 * in hardware buffers, but are through after IN)
-	 *
-	 * rroesler: has been commented out and shifted to
-	 *           SkGeDrvEvent(), because it is timer
-	 *           guarded now
-	 *
-	ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
-	ReceiveIrq(pAC, &pAC->RxPort[1], SK_TRUE);
-	 */
 
 	if (pAC->CheckQueue) {
 		pAC->CheckQueue = SK_FALSE;
 		spin_lock(&pAC->SlowPathLock);
@@ -1046,8 +1539,26 @@ SK_U32		IntSrc;		/* interrupts source re
 	if (IntSrc == 0) {
 		return SkIsrRetNone;
 	}
 	
+#ifdef CONFIG_SK98LIN_NAPI
+	if (netif_rx_schedule_prep(dev)) {
+		// CLEAR_AND_START_RX(0);
+		// CLEAR_TX_IRQ(0, TX_PRIO_LOW);
+		pAC->GIni.GIValIrqMask &= ~(NAPI_DRV_IRQS);
+		SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
+		__netif_rx_schedule(dev);
+	} 
+
+	if (IntSrc & IS_R1_F) {
+		CLEAR_AND_START_RX(0);
+	}
+#ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
+	if (IntSrc & IS_XA1_F) {
+		CLEAR_TX_IRQ(0, TX_PRIO_LOW);
+	}
+#endif
+#else
 	while (((IntSrc & IRQ_MASK) & ~SPECIAL_IRQS) != 0) {
 #if 0 /* software irq currently not used */
 		if (IntSrc & IS_IRQ_SW) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
@@ -1058,16 +1569,18 @@ SK_U32		IntSrc;		/* interrupts source re
 		if (IntSrc & IS_R1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX1 IRQ\n"));
+			CLEAR_AND_START_RX(0);
 			ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
 			SK_PNMI_CNT_RX_INTR(pAC, 0);
 		}
 #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
 		if (IntSrc & IS_XA1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX1 IRQ\n"));
+			CLEAR_TX_IRQ(0, TX_PRIO_LOW);
 			SK_PNMI_CNT_TX_INTR(pAC, 0);
 			spin_lock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
 			FreeTxDescriptors(pAC, &pAC->TxPort[0][TX_PRIO_LOW]);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
@@ -1076,26 +1589,20 @@ SK_U32		IntSrc;		/* interrupts source re
 		if (IntSrc & IS_XS1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX1 IRQ\n"));
+			CLEAR_TX_IRQ(0, TX_PRIO_HIGH);
 			SK_PNMI_CNT_TX_INTR(pAC, 0);
 			spin_lock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
 			FreeTxDescriptors(pAC, 0, TX_PRIO_HIGH);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
-			ClearTxIrq(pAC, 0, TX_PRIO_HIGH);
 		}
 #endif
 #endif
 
-		/* do all IO at once */
-		if (IntSrc & IS_R1_F)
-			ClearAndStartRx(pAC, 0);
-#ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
-		if (IntSrc & IS_XA1_F)
-			ClearTxIrq(pAC, 0, TX_PRIO_LOW);
-#endif
 		SK_IN32(pAC->IoBase, B0_ISRC, &IntSrc);
 	} /* while (IntSrc & IRQ_MASK != 0) */
+#endif
 	
 	IntSrc &= pAC->GIni.GIValIrqMask;
 	if ((IntSrc & SPECIAL_IRQS) || pAC->CheckQueue) {
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
@@ -1107,27 +1614,15 @@ SK_U32		IntSrc;		/* interrupts source re
 
 		SkEventDispatcher(pAC, pAC->IoBase);
 		spin_unlock(&pAC->SlowPathLock);
 	}
-	/*
-	 * do it all again is case we cleared an interrupt that
-	 * came in after handling the ring (OUTs may be delayed
-	 * in hardware buffers, but are through after IN)
-	 *
-	 * rroesler: has been commented out and shifted to
-	 *           SkGeDrvEvent(), because it is timer
-	 *           guarded now
-	 *
-	ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
-	 */
 
 	/* IRQ is processed - Enable IRQs again*/
 	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 
 		return SkIsrRetHandled;
 } /* SkGeIsrOnePort */
 
-
 /****************************************************************************
  *
  *	SkGeOpen - handle start of initialized adapter
  *
@@ -1157,15 +1652,13 @@ struct SK_NET_DEVICE	*dev)
 	
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeOpen: pAC=0x%lX:\n", (unsigned long)pAC));
 
-#ifdef SK_DIAG_SUPPORT
 	if (pAC->DiagModeActive == DIAG_ACTIVE) {
 		if (pAC->Pnmi.DiagAttached == SK_DIAG_RUNNING) {
 			return (-1);   /* still in use by diag; deny actions */
 		} 
 	}
-#endif
 
 	if (!try_module_get(THIS_MODULE)) {
 		return (-1);	/* increase of usage count not possible */
 	}
@@ -1204,21 +1697,33 @@ struct SK_NET_DEVICE	*dev)
 		SkRlmtInit	(pAC, pAC->IoBase, SK_INIT_RUN);
 		SkTimerInit	(pAC, pAC->IoBase, SK_INIT_RUN);
 		pAC->BoardLevel = SK_INIT_RUN;
 	}
-
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		/* Enable transmit descriptor polling. */
-		SkGePollTxD(pAC, pAC->IoBase, i, SK_TRUE);
-		FillRxRing(pAC, &pAC->RxPort[i]);
+		if (CHIP_ID_YUKON_2(pAC)) {
+			SkY2PortStart(pAC, pAC->IoBase, pNet->PortNr);
+		} else {
+			/* Enable transmit descriptor polling. */
+			SkGePollTxD(pAC, pAC->IoBase, i, SK_TRUE);
+			FillRxRing(pAC, &pAC->RxPort[i]);
+		}
 	}
-	SkGeYellowLED(pAC, pAC->IoBase, 1);
 
-	StartDrvCleanupTimer(pAC);
+	SkGeYellowLED(pAC, pAC->IoBase, 1);
 	SkDimEnableModerationIfNeeded(pAC);	
 	SkDimDisplayModerationSettings(pAC);
 
-	pAC->GIni.GIValIrqMask &= IRQ_MASK;
+	if (!CHIP_ID_YUKON_2(pAC)) {
+		/*
+		** Has been setup already at SkGeInit(SK_INIT_IO),
+		** but additional masking added for Genesis & Yukon
+		** chipsets -> modify it...
+		*/
+		pAC->GIni.GIValIrqMask &= IRQ_MASK;
+#ifndef USE_TX_COMPLETE
+		pAC->GIni.GIValIrqMask &= ~(TX_COMPL_IRQS);
+#endif
+	}
 
 	/* enable Interrupts */
 	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 	SK_OUT32(pAC->IoBase, B0_HWE_IMSK, IRQ_HWE_MASK);
@@ -1248,8 +1753,10 @@ struct SK_NET_DEVICE	*dev)
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeOpen suceeded\n"));
 
+	SkMacRxTxEnable(pAC, pAC->IoBase, pNet->PortNr);
+
 	return (0);
 } /* SkGeOpen */
 
 
@@ -1274,16 +1781,18 @@ struct SK_NET_DEVICE	*dev)
 	unsigned long	Flags;		/* for spin lock */
 	int		i;
 	int		PortIdx;
 	SK_EVPARA	EvPara;
-
+#ifdef CONFIG_SK98LIN_NAPI
+	int		WorkToDo = 1; // min(*budget, dev->quota);
+	int		WorkDone = 0;
+#endif
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeClose: pAC=0x%lX ", (unsigned long)pAC));
 
 	pNet = (DEV_NET*) dev->priv;
 	pAC = pNet->pAC;
 
-#ifdef SK_DIAG_SUPPORT
 	if (pAC->DiagModeActive == DIAG_ACTIVE) {
 		if (pAC->DiagFlowCtrl == SK_FALSE) {
 			module_put(THIS_MODULE);
 			/* 
@@ -1301,19 +1810,16 @@ struct SK_NET_DEVICE	*dev)
 		} else {
 			pAC->DiagFlowCtrl = SK_FALSE;
 		}
 	}
-#endif
 
 	netif_stop_queue(dev);
 
 	if (pAC->RlmtNets == 1)
 		PortIdx = pAC->ActivePort;
 	else
 		PortIdx = pNet->NetNr;
 
-        StopDrvCleanupTimer(pAC);
-
 	/*
 	 * Clear multicast table, promiscuous mode ....
 	 */
 	SkAddrMcClear(pAC, pAC->IoBase, PortIdx, 0);
@@ -1329,10 +1835,16 @@ struct SK_NET_DEVICE	*dev)
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
 		SkEventDispatcher(pAC, pAC->IoBase);
 		SK_OUT32(pAC->IoBase, B0_IMSK, 0);
 		/* stop the hardware */
-		SkGeDeInit(pAC, pAC->IoBase);
-		pAC->BoardLevel = SK_INIT_DATA;
+		/* SkGeDeInit(pAC, pAC->IoBase);	*/
+		/* pAC->BoardLevel = SK_INIT_DATA;	*/
+		if (CHIP_ID_YUKON_2(pAC)) {
+			SkY2PortStop(pAC, pAC->IoBase, 0, SK_STOP_ALL, SK_HARD_RST);
+		}
+		else {
+			SkGeStopPort(pAC, pAC->IoBase, 0, SK_STOP_ALL, SK_HARD_RST);
+		}
 		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 	} else {
 
 		spin_lock_irqsave(&pAC->SlowPathLock, Flags);
@@ -1345,26 +1857,54 @@ struct SK_NET_DEVICE	*dev)
 		
 		/* Stop port */
 		spin_lock_irqsave(&pAC->TxPort[pNet->PortNr]
 			[TX_PRIO_LOW].TxDesRingLock, Flags);
-		SkGeStopPort(pAC, pAC->IoBase, pNet->PortNr,
-			SK_STOP_ALL, SK_HARD_RST);
+		if (CHIP_ID_YUKON_2(pAC)) {
+			SkY2PortStop(pAC, pAC->IoBase, pNet->PortNr,
+				SK_STOP_ALL, SK_HARD_RST);
+		}
+		else {
+			SkGeStopPort(pAC, pAC->IoBase, pNet->PortNr,
+				SK_STOP_ALL, SK_HARD_RST);
+		}
 		spin_unlock_irqrestore(&pAC->TxPort[pNet->PortNr]
 			[TX_PRIO_LOW].TxDesRingLock, Flags);
 	}
 
 	if (pAC->RlmtNets == 1) {
 		/* clear all descriptor rings */
 		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-			ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE);
-			ClearRxRing(pAC, &pAC->RxPort[i]);
-			ClearTxRing(pAC, &pAC->TxPort[i][TX_PRIO_LOW]);
+			if (!CHIP_ID_YUKON_2(pAC)) {
+#ifdef CONFIG_SK98LIN_NAPI
+				WorkToDo = 1;
+				ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE, &WorkDone, WorkToDo);
+#else
+				ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE);
+#endif
+				ClearRxRing(pAC, &pAC->RxPort[i]);
+				ClearTxRing(pAC, &pAC->TxPort[i][TX_PRIO_LOW]);
+			}
+			else {
+				SkY2FreeRxBuffers(pAC, pAC->IoBase, i);
+				SkY2FreeTxBuffers(pAC, pAC->IoBase, i);
+			}
 		}
 	} else {
 		/* clear port descriptor rings */
-		ReceiveIrq(pAC, &pAC->RxPort[pNet->PortNr], SK_TRUE);
-		ClearRxRing(pAC, &pAC->RxPort[pNet->PortNr]);
-		ClearTxRing(pAC, &pAC->TxPort[pNet->PortNr][TX_PRIO_LOW]);
+		if (!CHIP_ID_YUKON_2(pAC)) {
+#ifdef CONFIG_SK98LIN_NAPI
+			WorkToDo = 1;
+			ReceiveIrq(pAC, &pAC->RxPort[pNet->PortNr], SK_TRUE, &WorkDone, WorkToDo);
+#else
+			ReceiveIrq(pAC, &pAC->RxPort[pNet->PortNr], SK_TRUE);
+#endif
+			ClearRxRing(pAC, &pAC->RxPort[pNet->PortNr]);
+			ClearTxRing(pAC, &pAC->TxPort[pNet->PortNr][TX_PRIO_LOW]);
+		}
+		else {
+			SkY2FreeRxBuffers(pAC, pAC->IoBase, pNet->PortNr);
+			SkY2FreeTxBuffers(pAC, pAC->IoBase, pNet->PortNr);
+		}
 	}
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeClose: done "));
@@ -1433,11 +1973,13 @@ int			Rc;	/* return code of XmitFrame */
 				skb);
 	}
 
 	/* Transmitter out of resources? */
+#ifdef USE_TX_COMPLETE
 	if (Rc <= 0) {
 		netif_stop_queue(dev);
 	}
+#endif
 
 	/* If not taken, give buffer ownership back to the
 	 * queueing layer.
 	 */
@@ -1447,8 +1989,55 @@ int			Rc;	/* return code of XmitFrame */
 	dev->trans_start = jiffies;
 	return (0);
 } /* SkGeXmit */
 
+#ifdef CONFIG_SK98LIN_NAPI
+/*****************************************************************************
+ *
+ * 	SkGePoll - NAPI Rx polling callback for GEnesis and Yukon chipsets
+ *
+ * Description:
+ *	Called by the Linux system in case NAPI polling is activated
+ *
+ * Returns:
+ *	The number of work data still to be handled
+ */
+static int SkGePoll(struct net_device *dev, int *budget) 
+{
+SK_AC	*pAC = ((DEV_NET*)(dev->priv))->pAC; /* pointer to adapter context */
+int	WorkToDo = min(*budget, dev->quota);
+int	WorkDone = 0;
+
+	if (pAC->dev[0] != pAC->dev[1]) {
+#ifdef USE_TX_COMPLETE
+		spin_lock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
+		FreeTxDescriptors(pAC, &pAC->TxPort[1][TX_PRIO_LOW]);
+		spin_unlock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
+#endif
+		ReceiveIrq(pAC, &pAC->RxPort[1], SK_TRUE, &WorkDone, WorkToDo);
+	}
+#ifdef USE_TX_COMPLETE
+	spin_lock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
+	FreeTxDescriptors(pAC, &pAC->TxPort[0][TX_PRIO_LOW]);
+	spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
+#endif
+	ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE, &WorkDone, WorkToDo);
+
+	*budget -= WorkDone;
+	dev->quota -= WorkDone;
+
+	if(WorkDone < WorkToDo) {
+		netif_rx_complete(dev);
+		/* enable interrupts again */
+		pAC->GIni.GIValIrqMask |= (NAPI_DRV_IRQS);
+#ifndef USE_TX_COMPLETE
+		pAC->GIni.GIValIrqMask &= ~(TX_COMPL_IRQS);
+#endif
+		SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
+	}
+	return (WorkDone >= WorkToDo);
+} /* SkGePoll */
+#endif
 
 /*****************************************************************************
  *
  * 	XmitFrame - fill one socket buffer into the transmit ring
@@ -1471,9 +2060,9 @@ int			Rc;	/* return code of XmitFrame */
  *		the ring is full ( -> set tbusy)
  *	< 0 - on failure: other problems ( -> return failure to upper layers)
  */
 static int XmitFrame(
-SK_AC 		*pAC,		/* pointer to adapter context           */
+SK_AC 		*pAC,		/* pointer to adapter context	        */
 TX_PORT		*pTxPort,	/* pointer to struct of port to send to */
 struct sk_buff	*pMessage)	/* pointer to send-message              */
 {
 	TXD		*pTxd;		/* the rxd to fill */
@@ -1487,13 +2076,16 @@ struct sk_buff	*pMessage)	/* pointer to 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS, ("X"));
 
 	spin_lock_irqsave(&pTxPort->TxDesRingLock, Flags);
 #ifndef USE_TX_COMPLETE
-	FreeTxDescriptors(pAC, pTxPort);
+	if ((pTxPort->TxdRingPrevFree - pTxPort->TxdRingFree) > 6)  {
+		FreeTxDescriptors(pAC, pTxPort);
+		pTxPort->TxdRingPrevFree = pTxPort->TxdRingFree;
+	}
 #endif
 	if (pTxPort->TxdRingFree == 0) {
 		/* 
-		** no enough free descriptors in ring at the moment.
+		** not enough free descriptors in ring at the moment.
 		** Maybe free'ing some old one help?
 		*/
 		FreeTxDescriptors(pAC, pTxPort);
 		if (pTxPort->TxdRingFree == 0) {
@@ -1519,9 +2111,8 @@ struct sk_buff	*pMessage)	/* pointer to 
 	** This is to resolve faulty padding by the HW with 0xaa bytes.
 	*/
 	if (BytesSend < C_LEN_ETHERNET_MINSIZE) {
 		if ((pMessage = skb_padto(pMessage, C_LEN_ETHERNET_MINSIZE)) == NULL) {
-			spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
 			return 0;
 		}
 		pMessage->len = C_LEN_ETHERNET_MINSIZE;
 	}
@@ -1577,9 +2168,9 @@ struct sk_buff	*pMessage)	/* pointer to 
 #ifdef USE_TX_COMPLETE
 				   BMU_IRQ_EOF |
 #endif
 				   pMessage->len;
-        } else {
+	} else {
 		pTxd->TBControl = BMU_OWN | BMU_STF | BMU_CHECK | 
 				  BMU_SW  | BMU_EOF |
 #ifdef USE_TX_COMPLETE
 				   BMU_IRQ_EOF |
@@ -1997,11 +2588,20 @@ SK_U16		Length;		/* data fragment length
  *
  * Returns:	N/A
  */
 static void ReceiveIrq(
+#ifdef CONFIG_SK98LIN_NAPI
+	SK_AC		*pAC,		/* pointer to adapter context */
+	RX_PORT		*pRxPort,	/* pointer to receive port struct */
+	SK_BOOL		SlowPathLock,	/* indicates if SlowPathLock is needed */
+	int		*WorkDone,
+	int		WorkToDo)
+#else
 	SK_AC		*pAC,			/* pointer to adapter context */
 	RX_PORT		*pRxPort,		/* pointer to receive port struct */
 	SK_BOOL		SlowPathLock)	/* indicates if SlowPathLock is needed */
+
+#endif
 {
 RXD				*pRxd;			/* pointer to receive descriptors */
 SK_U32			Control;		/* control field of descriptor */
 struct sk_buff	*pMsg;			/* pointer to message holding frame */
@@ -2045,17 +2645,24 @@ rx_start:	
 		 */
 
 		Control = pRxd->RBControl;
 	
+#ifdef CONFIG_SK98LIN_NAPI
+		if (*WorkDone >= WorkToDo) {
+			break;
+		}
+		(*WorkDone)++;
+#endif
+
 		/* check if this descriptor is ready */
 		if ((Control & BMU_OWN) != 0) {
 			/* this descriptor is not yet ready */
 			/* This is the usual end of the loop */
 			/* We don't need to start the ring again */
 			FillRxRing(pAC, pRxPort);
 			return;
 		}
-                pAC->DynIrqModInfo.NbrProcessedDescr++;
+		pAC->DynIrqModInfo.NbrProcessedDescr++;
 
 		/* get length of frame and check it */
 		FrameLength = Control & BMU_BBC;
 		if (FrameLength > pAC->RxBufSize) {
@@ -2072,10 +2679,10 @@ rx_start:	
 
 		FrameStat = pRxd->FrameStat;
 
 		/* check for frame length mismatch */
-#define XMR_FS_LEN_SHIFT        18
-#define GMR_FS_LEN_SHIFT        16
+#define XMR_FS_LEN_SHIFT	18
+#define GMR_FS_LEN_SHIFT	16
 		if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
 			if (FrameLength != (SK_U32) (FrameStat >> XMR_FS_LEN_SHIFT)) {
 				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 					SK_DBGCAT_DRV_RX_PROGRESS,
@@ -2127,8 +2734,14 @@ rx_start:	
 				("skge: Error in received frame, dropped!\n"
 				"Control: %x\nRxStat: %x\n",
 				Control, FrameStat));
 
+			PhysAddr = ((SK_U64) pRxd->VDataHigh) << (SK_U64)32;
+			PhysAddr |= (SK_U64) pRxd->VDataLow;
+			pci_dma_sync_single(pAC->PciDev,
+						(dma_addr_t) PhysAddr,
+						FrameLength,
+						PCI_DMA_FROMDEVICE);
 			ReQueueRxBuffer(pAC, pRxPort, pMsg,
 				pRxd->VDataHigh, pRxd->VDataLow);
 
 			continue;
@@ -2147,18 +2760,14 @@ rx_start:	
 			skb_put(pNewMsg, FrameLength);
 			PhysAddr = ((SK_U64) pRxd->VDataHigh) << (SK_U64)32;
 			PhysAddr |= (SK_U64) pRxd->VDataLow;
 
-			pci_dma_sync_single_for_cpu(pAC->PciDev,
-						    (dma_addr_t) PhysAddr,
-						    FrameLength,
-						    PCI_DMA_FROMDEVICE);
+			pci_dma_sync_single(pAC->PciDev,
+						(dma_addr_t) PhysAddr,
+						FrameLength,
+						PCI_DMA_FROMDEVICE);
 			eth_copy_and_sum(pNewMsg, pMsg->data,
 				FrameLength, 0);
-			pci_dma_sync_single_for_device(pAC->PciDev,
-						       (dma_addr_t) PhysAddr,
-						       FrameLength,
-						       PCI_DMA_FROMDEVICE);
 			ReQueueRxBuffer(pAC, pRxPort, pMsg,
 				pRxd->VDataHigh, pRxd->VDataLow);
 
 			pMsg = pNewMsg;
@@ -2339,12 +2948,8 @@ rx_start:	
 	} /* for ... scanning the RXD ring */
 
 	/* RXD ring is empty -> fill and restart */
 	FillRxRing(pAC, pRxPort);
-	/* do not start if called from Close */
-	if (pAC->BoardLevel > SK_INIT_DATA) {
-		ClearAndStartRx(pAC, PortIndex);
-	}
 	return;
 
 rx_failed:
 	/* remove error frame */
@@ -2366,51 +2971,8 @@ rx_failed:
 	goto rx_start;
 
 } /* ReceiveIrq */
 
-
-/*****************************************************************************
- *
- * 	ClearAndStartRx - give a start receive command to BMU, clear IRQ
- *
- * Description:
- *	This function sends a start command and a clear interrupt
- *	command for one receive queue to the BMU.
- *
- * Returns: N/A
- *	none
- */
-static void ClearAndStartRx(
-SK_AC	*pAC,		/* pointer to the adapter context */
-int	PortIndex)	/* index of the receive port (XMAC) */
-{
-	SK_OUT8(pAC->IoBase,
-		RxQueueAddr[PortIndex]+Q_CSR,
-		CSR_START | CSR_IRQ_CL_F);
-} /* ClearAndStartRx */
-
-
-/*****************************************************************************
- *
- * 	ClearTxIrq - give a clear transmit IRQ command to BMU
- *
- * Description:
- *	This function sends a clear tx IRQ command for one
- *	transmit queue to the BMU.
- *
- * Returns: N/A
- */
-static void ClearTxIrq(
-SK_AC	*pAC,		/* pointer to the adapter context */
-int	PortIndex,	/* index of the transmit port (XMAC) */
-int	Prio)		/* priority or normal queue */
-{
-	SK_OUT8(pAC->IoBase, 
-		TxQueueAddr[PortIndex][Prio]+Q_CSR,
-		CSR_IRQ_CL_F);
-} /* ClearTxIrq */
-
-
 /*****************************************************************************
  *
  * 	ClearRxRing - remove all buffers from the receive ring
  *
@@ -2622,8 +3184,12 @@ DEV_NET		*pOtherNet;
 SK_AC		*pAC;
 unsigned long	Flags;
 int		i;
 SK_EVPARA 	EvPara;
+#ifdef CONFIG_SK98LIN_NAPI
+int		WorkToDo = 1; // min(*budget, dev->quota);
+int		WorkDone = 0;
+#endif
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeChangeMtu starts now...\n"));
 
@@ -2637,25 +3203,26 @@ SK_EVPARA 	EvPara;
 	if(pAC->BoardLevel != SK_INIT_RUN) {
 		return -EINVAL;
 	}
 
-#ifdef SK_DIAG_SUPPORT
 	if (pAC->DiagModeActive == DIAG_ACTIVE) {
 		if (pAC->DiagFlowCtrl == SK_FALSE) {
 			return -1; /* still in use, deny any actions of MTU */
 		} else {
 			pAC->DiagFlowCtrl = SK_FALSE;
 		}
 	}
-#endif
 
 	pNet->Mtu = NewMtu;
 	pOtherNet = (DEV_NET*)pAC->dev[1 - pNet->NetNr]->priv;
 	if ((pOtherNet->Mtu>1500) && (NewMtu<=1500) && (pOtherNet->Up==1)) {
 		return(0);
 	}
 
 	pAC->RxBufSize = NewMtu + 32;
+	while (pAC->RxBufSize % 8) { /* RxBufSize must be a multiple of 8 */
+		pAC->RxBufSize = pAC->RxBufSize + 1;
+	}
 	dev->mtu = NewMtu;
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("New MTU: %d\n", NewMtu));
@@ -2686,9 +3253,10 @@ SK_EVPARA 	EvPara;
 	*/
 	SkEventDispatcher(pAC, pAC->IoBase);
 
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		spin_lock(&pAC->TxPort[i][TX_PRIO_LOW].TxDesRingLock);
+		spin_lock_irqsave(
+			&pAC->TxPort[i][TX_PRIO_LOW].TxDesRingLock, Flags);
 		netif_stop_queue(pAC->dev[i]);
 
 	}
 
@@ -2737,9 +3305,8 @@ SK_EVPARA 	EvPara;
 	/*
 	** enable/disable hardware support for long frames
 	*/
 	if (NewMtu > 1500) {
-// pAC->JumboActivated = SK_TRUE; /* is never set back !!! */
 		pAC->GIni.GIPortUsage = SK_JUMBO_LINK;
 	} else {
 	    if ((pAC->GIni.GIMacsFound == 2 ) && (pAC->RlmtNets == 2)) {
 		pAC->GIni.GIPortUsage = SK_MUL_LINK;
@@ -2754,11 +3321,10 @@ SK_EVPARA 	EvPara;
 	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_IO);
 	SkAddrInit( pAC, pAC->IoBase, SK_INIT_IO);
 	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_IO);
 	SkTimerInit(pAC, pAC->IoBase, SK_INIT_IO);
-	
+
 	/*
-	** tschilling:
 	** Speed and others are set back to default in level 1 init!
 	*/
 	GetConfiguration(pAC);
 	
@@ -2770,21 +3336,34 @@ SK_EVPARA 	EvPara;
 	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_RUN);
 	SkTimerInit(pAC, pAC->IoBase, SK_INIT_RUN);
 
 	/*
-	** clear and reinit the rx rings here
+	** clear and reinit the rx rings here, because of new MTU size
 	*/
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE);
-		ClearRxRing(pAC, &pAC->RxPort[i]);
-		FillRxRing(pAC, &pAC->RxPort[i]);
+		if (CHIP_ID_YUKON_2(pAC)) {
+			SkY2FreeRxBuffers(pAC, pAC->IoBase, i);
+			SkY2FreeTxBuffers(pAC, pAC->IoBase, i);
+			SkY2AllocateRxBuffers(pAC, pAC->IoBase, i);
+			SkY2RestartStatusUnit(pAC);
+			SkY2PortStart(pAC, pAC->IoBase, i);
+		} else {
+#ifdef CONFIG_SK98LIN_NAPI
+			WorkToDo = 1;
+			ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE, &WorkDone, WorkToDo);
+#else
+			ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE);
+#endif
+			ClearRxRing(pAC, &pAC->RxPort[i]);
+			FillRxRing(pAC, &pAC->RxPort[i]);
 
-		/* 
-		** Enable transmit descriptor polling
-		*/
-		SkGePollTxD(pAC, pAC->IoBase, i, SK_TRUE);
-		FillRxRing(pAC, &pAC->RxPort[i]);
-	};
+			/* 
+			** Enable transmit descriptor polling
+			*/
+			SkGePollTxD(pAC, pAC->IoBase, i, SK_TRUE);
+			FillRxRing(pAC, &pAC->RxPort[i]);
+		}
+	}
 
 	SkGeYellowLED(pAC, pAC->IoBase, 1);
 	SkDimEnableModerationIfNeeded(pAC);	
 	SkDimDisplayModerationSettings(pAC);
@@ -2856,44 +3435,40 @@ SK_EVPARA 	EvPara;
 static struct net_device_stats *SkGeStats(struct SK_NET_DEVICE *dev)
 {
 DEV_NET *pNet = (DEV_NET*) dev->priv;
 SK_AC	*pAC = pNet->pAC;
-SK_PNMI_STRUCT_DATA *pPnmiStruct;       /* structure for all Pnmi-Data */
-SK_PNMI_STAT    *pPnmiStat;             /* pointer to virtual XMAC stat. data */
-SK_PNMI_CONF    *pPnmiConf;             /* pointer to virtual link config. */
-unsigned int    Size;                   /* size of pnmi struct */
+SK_PNMI_STRUCT_DATA *pPnmiStruct;	/* structure for all Pnmi-Data */
+SK_PNMI_STAT    *pPnmiStat;		/* pointer to virtual XMAC stat. data */
+SK_PNMI_CONF    *pPnmiConf;		/* pointer to virtual link config. */
+unsigned int    Size;			/* size of pnmi struct */
 unsigned long	Flags;			/* for spin lock */
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeStats starts now...\n"));
 	pPnmiStruct = &pAC->PnmiStruct;
 
-#ifdef SK_DIAG_SUPPORT
-        if ((pAC->DiagModeActive == DIAG_NOTACTIVE) &&
-                (pAC->BoardLevel == SK_INIT_RUN)) {
-#endif
-        SK_MEMSET(pPnmiStruct, 0, sizeof(SK_PNMI_STRUCT_DATA));
-        spin_lock_irqsave(&pAC->SlowPathLock, Flags);
-        Size = SK_PNMI_STRUCT_SIZE;
-		SkPnmiGetStruct(pAC, pAC->IoBase, pPnmiStruct, &Size, pNet->NetNr);
-        spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
-#ifdef SK_DIAG_SUPPORT
+	if ((pAC->DiagModeActive == DIAG_NOTACTIVE) &&
+		(pAC->BoardLevel == SK_INIT_RUN)) {
+		SK_MEMSET(pPnmiStruct, 0, sizeof(SK_PNMI_STRUCT_DATA));
+		spin_lock_irqsave(&pAC->SlowPathLock, Flags);
+		Size = SK_PNMI_STRUCT_SIZE;
+			SkPnmiGetStruct(pAC, pAC->IoBase, pPnmiStruct, &Size, pNet->NetNr);
+		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 	}
-#endif
 
-        pPnmiStat = &pPnmiStruct->Stat[0];
-        pPnmiConf = &pPnmiStruct->Conf[0];
+	pPnmiStat = &pPnmiStruct->Stat[0];
+	pPnmiConf = &pPnmiStruct->Conf[0];
 
 	pAC->stats.rx_packets = (SK_U32) pPnmiStruct->RxDeliveredCts & 0xFFFFFFFF;
 	pAC->stats.tx_packets = (SK_U32) pPnmiStat->StatTxOkCts & 0xFFFFFFFF;
 	pAC->stats.rx_bytes = (SK_U32) pPnmiStruct->RxOctetsDeliveredCts;
 	pAC->stats.tx_bytes = (SK_U32) pPnmiStat->StatTxOctetsOkCts;
 	
-        if (pNet->Mtu <= 1500) {
-                pAC->stats.rx_errors = (SK_U32) pPnmiStruct->InErrorsCts & 0xFFFFFFFF;
-        } else {
-                pAC->stats.rx_errors = (SK_U32) ((pPnmiStruct->InErrorsCts -
-                        pPnmiStat->StatRxTooLongCts) & 0xFFFFFFFF);
+	if (pNet->Mtu <= 1500) {
+		pAC->stats.rx_errors = (SK_U32) pPnmiStruct->InErrorsCts & 0xFFFFFFFF;
+	} else {
+		pAC->stats.rx_errors = (SK_U32) ((pPnmiStruct->InErrorsCts -
+			pPnmiStat->StatRxTooLongCts) & 0xFFFFFFFF);
 	}
 
 
 	if (pAC->GIni.GP[0].PhyType == SK_PHY_XMAC && pAC->HWRevision < 12)
@@ -2945,9 +3520,9 @@ void		*pMemBuf;
 struct pci_dev  *pdev = NULL;
 SK_GE_IOCTL	Ioctl;
 unsigned int	Err = 0;
 int		Size = 0;
-int             Ret = 0;
+int		Ret = 0;
 unsigned int	Length = 0;
 int		HeaderLength = sizeof(SK_U32) + sizeof(SK_U32);
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
@@ -3008,10 +3583,9 @@ int		HeaderLength = sizeof(SK_U32) + siz
 		}
 fault_gen:
 		kfree(pMemBuf); /* cleanup everything */
 		break;
-#ifdef SK_DIAG_SUPPORT
-       case SK_IOCTL_DIAG:
+	case SK_IOCTL_DIAG:
 		if (!capable(CAP_NET_ADMIN)) return -EPERM;
 		if (Ioctl.Len < (sizeof(pAC->PnmiStruct) + HeaderLength)) {
 			Length = Ioctl.Len;
 		} else {
@@ -3046,9 +3620,8 @@ fault_gen:
 		}
 fault_diag:
 		kfree(pMemBuf); /* cleanup everything */
 		break;
-#endif
 	default:
 		Err = -EOPNOTSUPP;
 	}
 
@@ -3126,19 +3699,20 @@ SK_AC	*pAC)	/* pointer to the adapter co
 {
 SK_I32	Port;		/* preferred port */
 SK_BOOL	AutoSet;
 SK_BOOL DupSet;
-int	LinkSpeed          = SK_LSPEED_AUTO;	/* Link speed */
-int	AutoNeg            = 1;			/* autoneg off (0) or on (1) */
-int	DuplexCap          = 0;			/* 0=both,1=full,2=half */
-int	FlowCtrl           = SK_FLOW_MODE_SYM_OR_REM;	/* FlowControl  */
-int	MSMode             = SK_MS_MODE_AUTO;	/* master/slave mode    */
-
-SK_BOOL IsConTypeDefined   = SK_TRUE;
-SK_BOOL IsLinkSpeedDefined = SK_TRUE;
-SK_BOOL IsFlowCtrlDefined  = SK_TRUE;
-SK_BOOL IsRoleDefined      = SK_TRUE;
-SK_BOOL IsModeDefined      = SK_TRUE;
+int	LinkSpeed		= SK_LSPEED_AUTO;	/* Link speed */
+int	AutoNeg			= 1;			/* autoneg off (0) or on (1) */
+int	DuplexCap		= 0;			/* 0=both,1=full,2=half */
+int	FlowCtrl		= SK_FLOW_MODE_SYM_OR_REM;	/* FlowControl  */
+int	MSMode			= SK_MS_MODE_AUTO;	/* master/slave mode    */
+int	IrqModMaskOffset	= 6;			/* all ints moderated=default */
+
+SK_BOOL IsConTypeDefined	= SK_TRUE;
+SK_BOOL IsLinkSpeedDefined	= SK_TRUE;
+SK_BOOL IsFlowCtrlDefined	= SK_TRUE;
+SK_BOOL IsRoleDefined		= SK_TRUE;
+SK_BOOL IsModeDefined		= SK_TRUE;
 /*
  *	The two parameters AutoNeg. and DuplexCap. map to one configuration
  *	parameter. The mapping is described by this table:
  *	DuplexCap ->	|	both	|	full	|	half	|
@@ -3154,8 +3728,17 @@ int	Capabilities[3][3] =
 		{ {                -1, SK_LMODE_FULL     , SK_LMODE_HALF     },
 		  {SK_LMODE_AUTOBOTH , SK_LMODE_AUTOFULL , SK_LMODE_AUTOHALF },
 		  {SK_LMODE_AUTOSENSE, SK_LMODE_AUTOSENSE, SK_LMODE_AUTOSENSE} };
 
+SK_U32	IrqModMask[7][2] =
+		{ { IRQ_MASK_RX_ONLY , Y2_DRIVER_IRQS  },
+		  { IRQ_MASK_TX_ONLY , Y2_DRIVER_IRQS  },
+		  { IRQ_MASK_SP_ONLY , Y2_SPECIAL_IRQS },
+		  { IRQ_MASK_SP_RX   , Y2_IRQ_MASK     },
+		  { IRQ_MASK_TX_RX   , Y2_DRIVER_IRQS  },
+		  { IRQ_MASK_SP_TX   , Y2_IRQ_MASK     },
+		  { IRQ_MASK_RX_TX_SP, Y2_IRQ_MASK     } };
+
 #define DC_BOTH	0
 #define DC_FULL 1
 #define DC_HALF 2
 #define AN_OFF	0
@@ -3193,9 +3776,9 @@ int	Capabilities[3][3] =
 	**  10HD      Half      Off       None      <ignored>    10
 	** 
 	** This ConType parameter is used for all ports of the adapter!
 	*/
-        if ( (ConType != NULL)                && 
+	if ( (ConType != NULL)                && 
 	     (pAC->Index < SK_MAX_CARD_PARAM) &&
 	     (ConType[pAC->Index] != NULL) ) {
 
 			/* Check chipset family */
@@ -3219,42 +3802,42 @@ int	Capabilities[3][3] =
 			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_SYM_OR_REM;
 			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
 			M_CurrPort.PLinkSpeed    = SK_LSPEED_AUTO;
 		    }
-                } else if (strcmp(ConType[pAC->Index],"100FD")==0) {
+		} else if (strcmp(ConType[pAC->Index],"100FD")==0) {
 		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
 			M_CurrPort.PLinkModeConf = Capabilities[AN_OFF][DC_FULL];
 			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_NONE;
 			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
 			M_CurrPort.PLinkSpeed    = SK_LSPEED_100MBPS;
 		    }
-                } else if (strcmp(ConType[pAC->Index],"100HD")==0) {
+		} else if (strcmp(ConType[pAC->Index],"100HD")==0) {
 		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
 			M_CurrPort.PLinkModeConf = Capabilities[AN_OFF][DC_HALF];
 			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_NONE;
 			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
 			M_CurrPort.PLinkSpeed    = SK_LSPEED_100MBPS;
 		    }
-                } else if (strcmp(ConType[pAC->Index],"10FD")==0) {
+		} else if (strcmp(ConType[pAC->Index],"10FD")==0) {
 		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
 			M_CurrPort.PLinkModeConf = Capabilities[AN_OFF][DC_FULL];
 			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_NONE;
 			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
 			M_CurrPort.PLinkSpeed    = SK_LSPEED_10MBPS;
 		    }
-                } else if (strcmp(ConType[pAC->Index],"10HD")==0) {
+		} else if (strcmp(ConType[pAC->Index],"10HD")==0) {
 		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
 			M_CurrPort.PLinkModeConf = Capabilities[AN_OFF][DC_HALF];
 			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_NONE;
 			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
 			M_CurrPort.PLinkSpeed    = SK_LSPEED_10MBPS;
 		    }
-                } else { 
+		} else { 
 		    printk("sk98lin: Illegal value \"%s\" for ConType\n", 
 			ConType[pAC->Index]);
 		    IsConTypeDefined = SK_FALSE; /* Wrong ConType defined */
 		}
-        } else {
+	} else {
 	    IsConTypeDefined = SK_FALSE; /* No ConType defined */
 	}
 
 	/*
@@ -3271,16 +3854,32 @@ int	Capabilities[3][3] =
 		    LinkSpeed = SK_LSPEED_10MBPS;
 		} else if (strcmp(Speed_A[pAC->Index],"100")==0) {
 		    LinkSpeed = SK_LSPEED_100MBPS;
 		} else if (strcmp(Speed_A[pAC->Index],"1000")==0) {
-		    LinkSpeed = SK_LSPEED_1000MBPS;
+		    if ((pAC->PciDev->vendor == 0x11ab ) &&
+		    	(pAC->PciDev->device == 0x4350)) {
+				LinkSpeed = SK_LSPEED_100MBPS;
+				printk("sk98lin: Illegal value \"%s\" for Speed_A.\n"
+					"Gigabit speed not possible with this chip revision!",
+					Speed_A[pAC->Index]);
+			} else {
+				LinkSpeed = SK_LSPEED_1000MBPS;
+		    }
 		} else {
 		    printk("sk98lin: Illegal value \"%s\" for Speed_A\n",
 			Speed_A[pAC->Index]);
 		    IsLinkSpeedDefined = SK_FALSE;
 		}
 	} else {
-	    IsLinkSpeedDefined = SK_FALSE;
+		if ((pAC->PciDev->vendor == 0x11ab ) && 
+			(pAC->PciDev->device == 0x4350)) {
+			/* Gigabit speed not supported
+			 * Swith to speed 100
+			 */
+			LinkSpeed = SK_LSPEED_100MBPS;
+		} else {
+			IsLinkSpeedDefined = SK_FALSE;
+		}
 	}
 
 	/* 
 	** Check speed parameter: 
@@ -3373,11 +3972,8 @@ int	Capabilities[3][3] =
 		DuplexCap = DC_FULL;
 	}
 	
 	if (!AutoSet && DupSet) {
-		printk("sk98lin: Port A: Duplex setting not"
-			" possible in\n    default AutoNegotiation mode"
-			" (Sense).\n    Using AutoNegotiation On\n");
 		AutoNeg = AN_ON;
 	}
 	
 	/* 
@@ -3403,9 +3999,9 @@ int	Capabilities[3][3] =
 		} else if (strcmp(FlowCtrl_A[pAC->Index],"None")==0) {
 		    FlowCtrl = SK_FLOW_MODE_NONE;
 		} else {
 		    printk("sk98lin: Illegal value \"%s\" for FlowCtrl_A\n",
-                        FlowCtrl_A[pAC->Index]);
+			FlowCtrl_A[pAC->Index]);
 		    IsFlowCtrlDefined = SK_FALSE;
 		}
 	} else {
 	   IsFlowCtrlDefined = SK_FALSE;
@@ -3495,9 +4091,9 @@ int	Capabilities[3][3] =
 	/*      
 	** Decide whether to set new config value if somethig valid has
 	** been received.
 	*/
-        if (IsLinkSpeedDefined) {
+	if (IsLinkSpeedDefined) {
 	    pAC->GIni.GP[1].PLinkSpeed = LinkSpeed;
 	}
 
 	/* 
@@ -3571,11 +4167,8 @@ int	Capabilities[3][3] =
 		DuplexCap = DC_FULL;
 	}
 	
 	if (!AutoSet && DupSet) {
-		printk("sk98lin: Port B: Duplex setting not"
-			" possible in\n    default AutoNegotiation mode"
-			" (Sense).\n    Using AutoNegotiation On\n");
 		AutoNeg = AN_ON;
 	}
 
 	/* 
@@ -3717,8 +4310,9 @@ int	Capabilities[3][3] =
 	
 	/*
 	** Check the interrupt moderation parameters
 	*/
+	pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
 	if (Moderation[pAC->Index] != NULL) {
 		if (strcmp(Moderation[pAC->Index], "") == 0) {
 			pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
 		} else if (strcmp(Moderation[pAC->Index], "Static") == 0) {
@@ -3730,88 +4324,78 @@ int	Capabilities[3][3] =
 		} else {
 	   		printk("sk98lin: Illegal value \"%s\" for Moderation.\n"
 				"      Disable interrupt moderation.\n",
 				Moderation[pAC->Index]);
-			pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
 		}
 	} else {
-		pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+/* Set interrupt moderation if wished */
+#ifdef CONFIG_SK98LIN_STATINT
+		pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_STATIC;
+#endif
 	}
 
+	pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
 	if (Stats[pAC->Index] != NULL) {
 		if (strcmp(Stats[pAC->Index], "Yes") == 0) {
 			pAC->DynIrqModInfo.DisplayStats = SK_TRUE;
-		} else {
-			pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
 		}
-	} else {
-		pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
 	}
 
 	if (ModerationMask[pAC->Index] != NULL) {
 		if (strcmp(ModerationMask[pAC->Index], "Rx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
+			IrqModMaskOffset = 0;
 		} else if (strcmp(ModerationMask[pAC->Index], "Tx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_ONLY;
+			IrqModMaskOffset = 1;
 		} else if (strcmp(ModerationMask[pAC->Index], "Sp") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_ONLY;
+			IrqModMaskOffset = 2;
 		} else if (strcmp(ModerationMask[pAC->Index], "RxSp") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
+			IrqModMaskOffset = 3;
 		} else if (strcmp(ModerationMask[pAC->Index], "SpRx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
+			IrqModMaskOffset = 3;
 		} else if (strcmp(ModerationMask[pAC->Index], "RxTx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+			IrqModMaskOffset = 4;
 		} else if (strcmp(ModerationMask[pAC->Index], "TxRx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+			IrqModMaskOffset = 4;
 		} else if (strcmp(ModerationMask[pAC->Index], "TxSp") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
+			IrqModMaskOffset = 5;
 		} else if (strcmp(ModerationMask[pAC->Index], "SpTx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
-		} else if (strcmp(ModerationMask[pAC->Index], "RxTxSp") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-		} else if (strcmp(ModerationMask[pAC->Index], "RxSpTx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-		} else if (strcmp(ModerationMask[pAC->Index], "TxRxSp") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-		} else if (strcmp(ModerationMask[pAC->Index], "TxSpRx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-		} else if (strcmp(ModerationMask[pAC->Index], "SpTxRx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-		} else if (strcmp(ModerationMask[pAC->Index], "SpRxTx") == 0) {
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-		} else { /* some rubbish */
-			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
+			IrqModMaskOffset = 5;
+		} else { /* some rubbish stated */
+			// IrqModMaskOffset = 6; ->has been initialized
+			// already at the begin of this function...
 		}
-	} else {  /* operator has stated nothing */
-		pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+	}
+	if (!CHIP_ID_YUKON_2(pAC)) {
+		pAC->DynIrqModInfo.MaskIrqModeration = IrqModMask[IrqModMaskOffset][0];
+	} else {
+		pAC->DynIrqModInfo.MaskIrqModeration = IrqModMask[IrqModMaskOffset][1];
 	}
 
+	pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
 	if (AutoSizing[pAC->Index] != NULL) {
 		if (strcmp(AutoSizing[pAC->Index], "On") == 0) {
 			pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
-		} else {
-			pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
-		}
-	} else {  /* operator has stated nothing */
-		pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+		} 
 	}
 
+	if (!CHIP_ID_YUKON_2(pAC)) {
+		pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
+	} else {
+		pAC->DynIrqModInfo.MaxModIntsPerSec = C_Y2_INTS_PER_SEC_DEFAULT;
+	}
 	if (IntsPerSec[pAC->Index] != 0) {
 		if ((IntsPerSec[pAC->Index]< C_INT_MOD_IPS_LOWER_RANGE) || 
 			(IntsPerSec[pAC->Index] > C_INT_MOD_IPS_UPPER_RANGE)) {
 	   		printk("sk98lin: Illegal value \"%d\" for IntsPerSec. (Range: %d - %d)\n"
 				"      Using default value of %i.\n", 
 				IntsPerSec[pAC->Index],
 				C_INT_MOD_IPS_LOWER_RANGE,
 				C_INT_MOD_IPS_UPPER_RANGE,
-				C_INTS_PER_SEC_DEFAULT);
-			pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
+				pAC->DynIrqModInfo.MaxModIntsPerSec);
 		} else {
 			pAC->DynIrqModInfo.MaxModIntsPerSec = IntsPerSec[pAC->Index];
 		}
-	} else {
-		pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
-	}
+	} 
 
 	/*
 	** Evaluate upper and lower moderation threshold
 	*/
@@ -3823,10 +4407,8 @@ int	Capabilities[3][3] =
 		pAC->DynIrqModInfo.MaxModIntsPerSec -
 		(pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
 
 	pAC->DynIrqModInfo.PrevTimeVal = jiffies;  /* initial value */
-
-
 } /* GetConfiguration */
 
 
 /*****************************************************************************
@@ -3859,47 +4441,8 @@ unsigned long Flags;
 		pAC->DeviceStr[0] = '\0';
 	}
 } /* ProductStr */
 
-/*****************************************************************************
- *
- *      StartDrvCleanupTimer - Start timer to check for descriptors which
- *                             might be placed in descriptor ring, but
- *                             havent been handled up to now
- *
- * Description:
- *      This function requests a HW-timer fo the Yukon card. The actions to
- *      perform when this timer expires, are located in the SkDrvEvent().
- *
- * Returns: N/A
- */
-static void
-StartDrvCleanupTimer(SK_AC *pAC) {
-    SK_EVPARA    EventParam;   /* Event struct for timer event */
-
-    SK_MEMSET((char *) &EventParam, 0, sizeof(EventParam));
-    EventParam.Para32[0] = SK_DRV_RX_CLEANUP_TIMER;
-    SkTimerStart(pAC, pAC->IoBase, &pAC->DrvCleanupTimer,
-                 SK_DRV_RX_CLEANUP_TIMER_LENGTH,
-                 SKGE_DRV, SK_DRV_TIMER, EventParam);
-}
-
-/*****************************************************************************
- *
- *      StopDrvCleanupTimer - Stop timer to check for descriptors
- *
- * Description:
- *      This function requests a HW-timer fo the Yukon card. The actions to
- *      perform when this timer expires, are located in the SkDrvEvent().
- *
- * Returns: N/A
- */
-static void
-StopDrvCleanupTimer(SK_AC *pAC) {
-    SkTimerStop(pAC, pAC->IoBase, &pAC->DrvCleanupTimer);
-    SK_MEMSET((char *) &pAC->DrvCleanupTimer, 0, sizeof(SK_TIMER));
-}
-
 /****************************************************************************/
 /* functions for common modules *********************************************/
 /****************************************************************************/
 
@@ -3986,9 +4529,11 @@ SK_MBUF		*pNextMbuf;
  */
 SK_U64 SkOsGetTime(SK_AC *pAC)
 {
 	SK_U64	PrivateJiffies;
+
 	SkOsGetTimeCurrent(pAC, &PrivateJiffies);
+
 	return PrivateJiffies;
 } /* SkOsGetTime */
 
 
@@ -4154,8 +4699,12 @@ int		ToPort;		/* the port we switch to *
 SK_EVPARA	NewPara;	/* parameter for further events */
 int		Stat;
 unsigned long	Flags;
 SK_BOOL		DualNet;
+#ifdef CONFIG_SK98LIN_NAPI
+int		WorkToDo = 1; // min(*budget, dev->quota);
+int		WorkDone = 0;
+#endif
 
 	switch (Event) {
 	case SK_DRV_ADAP_FAIL:
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_EVENT,
@@ -4185,35 +4734,49 @@ SK_BOOL		DualNet;
 		SkPnmiEvent(pAC, IoC, SK_PNMI_EVT_XMAC_RESET, NewPara);
 		spin_lock_irqsave(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
-
-		SkGeStopPort(pAC, IoC, FromPort, SK_STOP_ALL, SK_HARD_RST);
+		if (CHIP_ID_YUKON_2(pAC)) {
+			SkY2PortStop(pAC, IoC, FromPort, SK_STOP_ALL, SK_HARD_RST);
+		}
+		else {
+			SkGeStopPort(pAC, IoC, FromPort, SK_STOP_ALL, SK_HARD_RST);
+		}
 		pAC->dev[Param.Para32[0]]->flags &= ~IFF_RUNNING;
 		spin_unlock_irqrestore(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 		
-		/* clear rx ring from received frames */
-		ReceiveIrq(pAC, &pAC->RxPort[FromPort], SK_FALSE);
-		
-		ClearTxRing(pAC, &pAC->TxPort[FromPort][TX_PRIO_LOW]);
+		if (!CHIP_ID_YUKON_2(pAC)) {
+#ifdef CONFIG_SK98LIN_NAPI
+			WorkToDo = 1;
+			ReceiveIrq(pAC, &pAC->RxPort[FromPort], SK_FALSE, &WorkDone, WorkToDo);
+#else
+			ReceiveIrq(pAC, &pAC->RxPort[FromPort], SK_FALSE);
+#endif
+			ClearTxRing(pAC, &pAC->TxPort[FromPort][TX_PRIO_LOW]);
+		}
 		spin_lock_irqsave(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 		
-		/* tschilling: Handling of return value inserted. */
-		if (SkGeInitPort(pAC, IoC, FromPort)) {
-			if (FromPort == 0) {
-				printk("%s: SkGeInitPort A failed.\n", pAC->dev[0]->name);
-			} else {
-				printk("%s: SkGeInitPort B failed.\n", pAC->dev[1]->name);
+		if (CHIP_ID_YUKON_2(pAC)) {
+			SkY2PortStart(pAC, IoC, FromPort);
+		}
+		else {
+			/* tschilling: Handling of return value inserted. */
+			if (SkGeInitPort(pAC, IoC, FromPort)) {
+				if (FromPort == 0) {
+					printk("%s: SkGeInitPort A failed.\n", pAC->dev[0]->name);
+				} else {
+					printk("%s: SkGeInitPort B failed.\n", pAC->dev[1]->name);
+				}
 			}
+			SkAddrMcUpdate(pAC,IoC, FromPort);
+			PortReInitBmu(pAC, FromPort);
+			SkGePollTxD(pAC, IoC, FromPort, SK_TRUE);
+			CLEAR_AND_START_RX(FromPort);
 		}
-		SkAddrMcUpdate(pAC,IoC, FromPort);
-		PortReInitBmu(pAC, FromPort);
-		SkGePollTxD(pAC, IoC, FromPort, SK_TRUE);
-		ClearAndStartRx(pAC, FromPort);
 		spin_unlock_irqrestore(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 		break;
@@ -4300,9 +4863,9 @@ SK_BOOL		DualNet;
 		else
 			printk("    irq moderation:  disabled\n");
 
 
-#ifdef SK_ZEROCOPY
+#ifdef CONFIG_SK98LIN_ZEROCOPY
 		if (pAC->ChipsetType)
 #ifdef USE_SK_TX_CHECKSUM
 			printk("    scatter-gather:  enabled\n");
 #else
@@ -4317,11 +4880,15 @@ SK_BOOL		DualNet;
 #ifndef USE_SK_RX_CHECKSUM
 			printk("    rx-checksum:     disabled\n");
 #endif
 
+#ifdef CONFIG_SK98LIN_NAPI
+			printk("    rx-polling:      enabled\n");
+#endif
+
 		} else {
-                        DoPrintInterfaceChange = SK_TRUE;
-                }
+			DoPrintInterfaceChange = SK_TRUE;
+		}
 	
 		if ((Param.Para32[0] != pAC->ActivePort) &&
 			(pAC->RlmtNets == 1)) {
 			NewPara.Para32[0] = pAC->ActivePort;
@@ -4330,8 +4897,9 @@ SK_BOOL		DualNet;
 				NewPara);
 		}
 
 		/* Inform the world that link protocol is up. */
+		netif_wake_queue(pAC->dev[0]);
 		pAC->dev[Param.Para32[0]]->flags |= IFF_RUNNING;
 
 		break;
 	case SK_DRV_NET_DOWN:	 /* SK_U32 Reason */
@@ -4365,25 +4933,43 @@ SK_BOOL		DualNet;
 		SkPnmiEvent(pAC, IoC, SK_PNMI_EVT_XMAC_RESET, NewPara);
 		spin_lock_irqsave(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
-		spin_lock(&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock);
-		SkGeStopPort(pAC, IoC, FromPort, SK_STOP_ALL, SK_SOFT_RST);
-		SkGeStopPort(pAC, IoC, ToPort, SK_STOP_ALL, SK_SOFT_RST);
-		spin_unlock(&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock);
+		spin_lock_irqsave(
+			&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock, Flags);
+		if (CHIP_ID_YUKON_2(pAC)) {
+			SkY2PortStop(pAC, IoC, FromPort, SK_STOP_ALL, SK_HARD_RST);
+			SkY2PortStop(pAC, IoC, ToPort, SK_STOP_ALL, SK_HARD_RST);
+		}
+		else {
+			SkGeStopPort(pAC, IoC, FromPort, SK_STOP_ALL, SK_SOFT_RST);
+			SkGeStopPort(pAC, IoC, ToPort, SK_STOP_ALL, SK_SOFT_RST);
+		}
+		spin_unlock_irqrestore(
+			&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock, Flags);
 		spin_unlock_irqrestore(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 
-		ReceiveIrq(pAC, &pAC->RxPort[FromPort], SK_FALSE); /* clears rx ring */
-		ReceiveIrq(pAC, &pAC->RxPort[ToPort], SK_FALSE); /* clears rx ring */
 		
-		ClearTxRing(pAC, &pAC->TxPort[FromPort][TX_PRIO_LOW]);
-		ClearTxRing(pAC, &pAC->TxPort[ToPort][TX_PRIO_LOW]);
+		if (!CHIP_ID_YUKON_2(pAC)) {
+#ifdef CONFIG_SK98LIN_NAPI
+			WorkToDo = 1;
+			ReceiveIrq(pAC, &pAC->RxPort[FromPort], SK_FALSE, &WorkDone, WorkToDo);
+			ReceiveIrq(pAC, &pAC->RxPort[ToPort], SK_FALSE, &WorkDone, WorkToDo);
+#else
+			ReceiveIrq(pAC, &pAC->RxPort[FromPort], SK_FALSE); /* clears rx ring */
+			ReceiveIrq(pAC, &pAC->RxPort[ToPort], SK_FALSE); /* clears rx ring */
+#endif
+			ClearTxRing(pAC, &pAC->TxPort[FromPort][TX_PRIO_LOW]);
+			ClearTxRing(pAC, &pAC->TxPort[ToPort][TX_PRIO_LOW]);
+		} 
+
 		spin_lock_irqsave(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
-		spin_lock(&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock);
+		spin_lock_irqsave(
+			&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock, Flags);
 		pAC->ActivePort = ToPort;
 #if 0
 		SetQueueSizes(pAC);
 #else
@@ -4396,35 +4982,47 @@ SK_BOOL		DualNet;
 		if (SkGeInitAssignRamToQueues(
 			pAC,
 			pAC->ActivePort,
 			DualNet)) {
-			spin_unlock(&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock);
+			spin_unlock_irqrestore(
+				&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock, Flags);
 			spin_unlock_irqrestore(
 				&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 				Flags);
 			printk("SkGeInitAssignRamToQueues failed.\n");
 			break;
 		}
 #endif
-		/* tschilling: Handling of return values inserted. */
-		if (SkGeInitPort(pAC, IoC, FromPort) ||
-			SkGeInitPort(pAC, IoC, ToPort)) {
-			printk("%s: SkGeInitPort failed.\n", pAC->dev[0]->name);
+
+		if (!CHIP_ID_YUKON_2(pAC)) {
+			/* tschilling: Handling of return values inserted. */
+			if (SkGeInitPort(pAC, IoC, FromPort) ||
+				SkGeInitPort(pAC, IoC, ToPort)) {
+				printk("%s: SkGeInitPort failed.\n", pAC->dev[0]->name);
+			}
 		}
 		if (Event == SK_DRV_SWITCH_SOFT) {
 			SkMacRxTxEnable(pAC, IoC, FromPort);
 		}
+
 		SkMacRxTxEnable(pAC, IoC, ToPort);
 		SkAddrSwap(pAC, IoC, FromPort, ToPort);
 		SkAddrMcUpdate(pAC, IoC, FromPort);
 		SkAddrMcUpdate(pAC, IoC, ToPort);
-		PortReInitBmu(pAC, FromPort);
-		PortReInitBmu(pAC, ToPort);
-		SkGePollTxD(pAC, IoC, FromPort, SK_TRUE);
-		SkGePollTxD(pAC, IoC, ToPort, SK_TRUE);
-		ClearAndStartRx(pAC, FromPort);
-		ClearAndStartRx(pAC, ToPort);
-		spin_unlock(&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock);
+
+		if (!CHIP_ID_YUKON_2(pAC)) {
+			PortReInitBmu(pAC, FromPort);
+			PortReInitBmu(pAC, ToPort);
+			SkGePollTxD(pAC, IoC, FromPort, SK_TRUE);
+			SkGePollTxD(pAC, IoC, ToPort, SK_TRUE);
+			CLEAR_AND_START_RX(FromPort);
+			CLEAR_AND_START_RX(ToPort);
+		} else {
+			SkY2PortStart(pAC, IoC, FromPort);
+			SkY2PortStart(pAC, IoC, ToPort);
+		}
+		spin_unlock_irqrestore(
+			&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock, Flags);
 		spin_unlock_irqrestore(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 		break;
@@ -4433,12 +5031,16 @@ SK_BOOL		DualNet;
 			("RLS "));
 		pRlmtMbuf = (SK_MBUF*) Param.pParaPtr;
 		pMsg = (struct sk_buff*) pRlmtMbuf->pOs;
 		skb_put(pMsg, pRlmtMbuf->Length);
-		if (XmitFrame(pAC, &pAC->TxPort[pRlmtMbuf->PortIdx][TX_PRIO_LOW],
-			pMsg) < 0)
-
+		if (!CHIP_ID_YUKON_2(pAC)) {
+			if (XmitFrame(pAC, &pAC->TxPort[pRlmtMbuf->PortIdx][TX_PRIO_LOW],
+				pMsg) < 0)
+			DEV_KFREE_SKB_ANY(pMsg);
+		} else {
+			if (SkY2RlmtSend(pAC, pRlmtMbuf->PortIdx, pMsg) < 0)
 			DEV_KFREE_SKB_ANY(pMsg);
+		}
 		break;
 	case SK_DRV_TIMER:
 		if (Param.Para32[0] == SK_DRV_MODERATION_TIMER) {
 			/*
@@ -4446,21 +5048,28 @@ SK_BOOL		DualNet;
 			** dynamic moderation is to be applied
 			*/
 			SkDimStartModerationTimer(pAC);
 			SkDimModerate(pAC);
-                        if (pAC->DynIrqModInfo.DisplayStats) {
+			if (pAC->DynIrqModInfo.DisplayStats) {
 			    SkDimDisplayModerationSettings(pAC);
-                        }
-                } else if (Param.Para32[0] == SK_DRV_RX_CLEANUP_TIMER) {
+			}
+#ifdef YK2_TX_POLLING
+		} else if (Param.Para32[0] == SK_DRV_TX_POLL_TIMER) {
 			/*
-			** check if we need to check for descriptors which
-			** haven't been handled the last millisecs
+			** in case of TX polling on Yukon2 chipsets:
+			** check if new XmitTimer needs to be started
 			*/
-			StartDrvCleanupTimer(pAC);
-			if (pAC->GIni.GIMacsFound == 2) {
-				ReceiveIrq(pAC, &pAC->RxPort[1], SK_FALSE);
+			if (pAC->TxPort[Param.Para32[1]][0].TxALET.Done != 
+				pAC->TxPort[Param.Para32[1]][0].TxALET.Put) {
+				NewPara.Para32[0] = SK_DRV_TX_POLL_TIMER;
+				NewPara.Para32[1] = Param.Para32[1]; // port 
+				SkTimerStart(pAC, pAC->IoBase,
+                       			    	&pAC->TxPollTimer, 
+						SK_DRV_TX_POLL_TIMER_LENGTH,
+						SKGE_DRV, SK_DRV_TIMER,
+						NewPara);
 			}
-			ReceiveIrq(pAC, &pAC->RxPort[0], SK_FALSE);
+#endif
 		} else {
 			printk("Expiration of unknown timer\n");
 		}
 		break;
@@ -4522,10 +5131,8 @@ char	ClassStr[80];
 		ClassStr, ErrNum, pErrorMsg);
 
 } /* SkErrorLog */
 
-#ifdef SK_DIAG_SUPPORT
-
 /*****************************************************************************
  *
  *	SkDrvEnterDiagMode - handles DIAG attach request
  *
@@ -4591,18 +5198,18 @@ SK_AC   *pAc)   /* pointer to adapter co
 	SK_MEMCPY(&(pAc->PnmiStruct), &(pAc->PnmiBackup), 
 			sizeof(SK_PNMI_STRUCT_DATA));
 	pAc->DiagModeActive    = DIAG_NOTACTIVE;
 	pAc->Pnmi.DiagAttached = SK_DIAG_IDLE;
-        if (pAc->WasIfUp[0] == SK_TRUE) {
-                pAc->DiagFlowCtrl = SK_TRUE; /* for SkGeClose */
+	if (pAc->WasIfUp[0] == SK_TRUE) {
+		pAc->DiagFlowCtrl = SK_TRUE; /* for SkGeClose */
 		DoPrintInterfaceChange = SK_FALSE;
-                SkDrvInitAdapter(pAc, 0);    /* first device  */
-        }
-        if (pAc->WasIfUp[1] == SK_TRUE) {
-                pAc->DiagFlowCtrl = SK_TRUE; /* for SkGeClose */
+		SkDrvInitAdapter(pAc, 0);    /* first device  */
+	}
+	if (pAc->WasIfUp[1] == SK_TRUE) {
+		pAc->DiagFlowCtrl = SK_TRUE; /* for SkGeClose */
 		DoPrintInterfaceChange = SK_FALSE;
-                SkDrvInitAdapter(pAc, 1);    /* second device */
-        }
+		SkDrvInitAdapter(pAc, 1);    /* second device */
+	}
 	return(0);
 }
 
 /*****************************************************************************
@@ -4745,9 +5352,21 @@ int      devNbr)	/* what device is to be
 	return (0);
 
 } /* SkDrvInitAdapter */
 
-#endif
+static int __init sk98lin_init(void)
+{
+	return pci_module_init(&sk98lin_driver);
+}
+
+static void __exit sk98lin_cleanup(void)
+{
+	pci_unregister_driver(&sk98lin_driver);
+}
+
+module_init(sk98lin_init);
+module_exit(sk98lin_cleanup);
+
 
 #ifdef DEBUG
 /****************************************************************************/
 /* "debug only" section *****************************************************/
@@ -4777,8 +5396,10 @@ static void DumpMsg(struct sk_buff *skb,
 		printk("DumpMsg(): Message empty\n");
 		return;
 	}
 
+	printk("DumpMsg: PhysPage: %x\n", page_address(virt_to_page(skb->data)));
+
 	msglen = skb->len;
 	if (msglen > 64)
 		msglen = 64;
 
@@ -4897,318 +5518,9 @@ int	l;
 } /* DumpLong */
 
 #endif
 
-static int __devinit skge_probe_one(struct pci_dev *pdev,
-		const struct pci_device_id *ent)
-{
-	SK_AC			*pAC;
-	DEV_NET			*pNet = NULL;
-	struct net_device	*dev = NULL;
-#ifdef CONFIG_PROC_FS
-	struct proc_dir_entry	*pProcFile;
-#endif
-	static int boards_found = 0;
-	int error = -ENODEV;
-
-	if (pci_enable_device(pdev))
-		goto out;
- 
-	/* Configure DMA attributes. */
-	if (pci_set_dma_mask(pdev, (u64) 0xffffffffffffffffULL) &&
-	    pci_set_dma_mask(pdev, (u64) 0xffffffff))
-		goto out_disable_device;
-
-
-	if ((dev = alloc_etherdev(sizeof(DEV_NET))) == NULL) {
-		printk(KERN_ERR "Unable to allocate etherdev "
-		       "structure!\n");
-		goto out_disable_device;
-	}
-
-	pNet = dev->priv;
-	pNet->pAC = kmalloc(sizeof(SK_AC), GFP_KERNEL);
-	if (!pNet->pAC) {
-		printk(KERN_ERR "Unable to allocate adapter "
-		       "structure!\n");
-		goto out_free_netdev;
-	}
-
-	memset(pNet->pAC, 0, sizeof(SK_AC));
-	pAC = pNet->pAC;
-	pAC->PciDev = pdev;
-	pAC->PciDevId = pdev->device;
-	pAC->dev[0] = dev;
-	pAC->dev[1] = dev;
-	sprintf(pAC->Name, "SysKonnect SK-98xx");
-	pAC->CheckQueue = SK_FALSE;
-
-	pNet->Mtu = 1500;
-	pNet->Up = 0;
-	dev->irq = pdev->irq;
-	error = SkGeInitPCI(pAC);
-	if (error) {
-		printk("SKGE: PCI setup failed: %i\n", error);
-		goto out_free_netdev;
-	}
-
-	SET_MODULE_OWNER(dev);
-	dev->open =		&SkGeOpen;
-	dev->stop =		&SkGeClose;
-	dev->hard_start_xmit =	&SkGeXmit;
-	dev->get_stats =	&SkGeStats;
-	dev->set_multicast_list = &SkGeSetRxMode;
-	dev->set_mac_address =	&SkGeSetMacAddr;
-	dev->do_ioctl =		&SkGeIoctl;
-	dev->change_mtu =	&SkGeChangeMtu;
-	dev->flags &= 		~IFF_RUNNING;
-	SET_NETDEV_DEV(dev, &pdev->dev);
-
-#ifdef SK_ZEROCOPY
-#ifdef USE_SK_TX_CHECKSUM
-	if (pAC->ChipsetType) {
-		/* Use only if yukon hardware */
-		/* SK and ZEROCOPY - fly baby... */
-		dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
-	}
-#endif
-#endif
-
-	pAC->Index = boards_found++;
-
-	if (SkGeBoardInit(dev, pAC))
-		goto out_free_netdev;
-
-	/* Register net device */
-	if (register_netdev(dev)) {
-		printk(KERN_ERR "SKGE: Could not register device.\n");
-		goto out_free_resources;
-	}
-
-	/* Print adapter specific string from vpd */
-	ProductStr(pAC);
-	printk("%s: %s\n", dev->name, pAC->DeviceStr);
-
-	/* Print configuration settings */
-	printk("      PrefPort:%c  RlmtMode:%s\n",
-		'A' + pAC->Rlmt.Net[0].Port[pAC->Rlmt.Net[0].PrefPort]->PortNumber,
-		(pAC->RlmtMode==0)  ? "Check Link State" :
-		((pAC->RlmtMode==1) ? "Check Link State" :
-		((pAC->RlmtMode==3) ? "Check Local Port" :
-		((pAC->RlmtMode==7) ? "Check Segmentation" :
-		((pAC->RlmtMode==17) ? "Dual Check Link State" :"Error")))));
-
-	SkGeYellowLED(pAC, pAC->IoBase, 1);
-
-
-	memcpy(&dev->dev_addr, &pAC->Addr.Net[0].CurrentMacAddress, 6);
-
-#ifdef CONFIG_PROC_FS
-	pProcFile = create_proc_entry(dev->name, S_IRUGO, pSkRootDir);
-	if (pProcFile) {
-		pProcFile->proc_fops = &sk_proc_fops;
-		pProcFile->data = dev;
-		pProcFile->owner = THIS_MODULE;
-	}
-#endif
-
-	pNet->PortNr = 0;
-	pNet->NetNr  = 0;
-
-	boards_found++;
-
-	/* More then one port found */
-	if ((pAC->GIni.GIMacsFound == 2 ) && (pAC->RlmtNets == 2)) {
-		if ((dev = alloc_etherdev(sizeof(DEV_NET))) == 0) {
-			printk(KERN_ERR "Unable to allocate etherdev "
-				"structure!\n");
-			goto out;
-		}
-
-		pAC->dev[1]   = dev;
-		pNet          = dev->priv;
-		pNet->PortNr  = 1;
-		pNet->NetNr   = 1;
-		pNet->pAC     = pAC;
-		pNet->Mtu     = 1500;
-		pNet->Up      = 0;
-
-		dev->open               = &SkGeOpen;
-		dev->stop               = &SkGeClose;
-		dev->hard_start_xmit    = &SkGeXmit;
-		dev->get_stats          = &SkGeStats;
-		dev->set_multicast_list = &SkGeSetRxMode;
-		dev->set_mac_address    = &SkGeSetMacAddr;
-		dev->do_ioctl           = &SkGeIoctl;
-		dev->change_mtu         = &SkGeChangeMtu;
-		dev->flags             &= ~IFF_RUNNING;
-
-#ifdef SK_ZEROCOPY
-#ifdef USE_SK_TX_CHECKSUM
-		if (pAC->ChipsetType) {
-			/* SG and ZEROCOPY - fly baby... */
-			dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
-		}
-#endif
-#endif
-
-		if (register_netdev(dev)) {
-			printk(KERN_ERR "SKGE: Could not register device.\n");
-			free_netdev(dev);
-			pAC->dev[1] = pAC->dev[0];
-		} else {
-#ifdef CONFIG_PROC_FS
-			pProcFile = create_proc_entry(dev->name, S_IRUGO,
-					pSkRootDir);
-			if (pProcFile) {
-				pProcFile->proc_fops = &sk_proc_fops;
-				pProcFile->data = dev;
-				pProcFile->owner = THIS_MODULE;
-			}
-#endif
-
-			memcpy(&dev->dev_addr,
-					&pAC->Addr.Net[1].CurrentMacAddress, 6);
-	
-			printk("%s: %s\n", dev->name, pAC->DeviceStr);
-			printk("      PrefPort:B  RlmtMode:Dual Check Link State\n");
-		}
-	}
-
-	/* Save the hardware revision */
-	pAC->HWRevision = (((pAC->GIni.GIPciHwRev >> 4) & 0x0F)*10) +
-		(pAC->GIni.GIPciHwRev & 0x0F);
-
-	/* Set driver globals */
-	pAC->Pnmi.pDriverFileName    = DRIVER_FILE_NAME;
-	pAC->Pnmi.pDriverReleaseDate = DRIVER_REL_DATE;
-
-	memset(&pAC->PnmiBackup, 0, sizeof(SK_PNMI_STRUCT_DATA));
-	memcpy(&pAC->PnmiBackup, &pAC->PnmiStruct, sizeof(SK_PNMI_STRUCT_DATA));
-
-	pci_set_drvdata(pdev, dev);
-	return 0;
-
- out_free_resources:
-	FreeResources(dev);
- out_free_netdev:
-	free_netdev(dev);
- out_disable_device:
-	pci_disable_device(pdev);
- out:
-	return error;
-}
-
-static void __devexit skge_remove_one(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	DEV_NET *pNet = (DEV_NET *) dev->priv;
-	SK_AC *pAC = pNet->pAC;
-	int have_second_mac = 0;
-
-	if ((pAC->GIni.GIMacsFound == 2) && pAC->RlmtNets == 2)
-		have_second_mac = 1;
-
-	remove_proc_entry(dev->name, pSkRootDir);
-	unregister_netdev(dev);
-	if (have_second_mac) {
-		remove_proc_entry(pAC->dev[1]->name, pSkRootDir);
-		unregister_netdev(pAC->dev[1]);
-	}
-
-	SkGeYellowLED(pAC, pAC->IoBase, 0);
-
-	if (pAC->BoardLevel == SK_INIT_RUN) {
-		SK_EVPARA EvPara;
-		unsigned long Flags;
-
-		/* board is still alive */
-		spin_lock_irqsave(&pAC->SlowPathLock, Flags);
-		EvPara.Para32[0] = 0;
-		EvPara.Para32[1] = -1;
-		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
-		EvPara.Para32[0] = 1;
-		EvPara.Para32[1] = -1;
-		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
-		SkEventDispatcher(pAC, pAC->IoBase);
-		/* disable interrupts */
-		SK_OUT32(pAC->IoBase, B0_IMSK, 0);
-		SkGeDeInit(pAC, pAC->IoBase);
-		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
-		pAC->BoardLevel = SK_INIT_DATA;
-		/* We do NOT check here, if IRQ was pending, of course*/
-	}
-
-	if (pAC->BoardLevel == SK_INIT_IO) {
-		/* board is still alive */
-		SkGeDeInit(pAC, pAC->IoBase);
-		pAC->BoardLevel = SK_INIT_DATA;
-	}
-
-	FreeResources(dev);
-	free_netdev(dev);
-	if (have_second_mac)
-		free_netdev(pAC->dev[1]);
-	kfree(pAC);
-}
-
-static struct pci_device_id skge_pci_tbl[] = {
-	{ PCI_VENDOR_ID_3COM, 0x1700, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_3COM, 0x80eb, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_SYSKONNECT, 0x4300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_SYSKONNECT, 0x4320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_DLINK, 0x4c00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_MARVELL, 0x4320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-#if 0	/* don't handle Yukon2 cards at the moment -- mlindner@syskonnect.de */
-	{ PCI_VENDOR_ID_MARVELL, 0x4360, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_MARVELL, 0x4361, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-#endif
-	{ PCI_VENDOR_ID_MARVELL, 0x5005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_CNET, 0x434e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_LINKSYS, 0x1032, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_LINKSYS, 0x1064, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ 0, }
-};
-
-static struct pci_driver skge_driver = {
-	.name		= "skge",
-	.id_table	= skge_pci_tbl,
-	.probe		= skge_probe_one,
-	.remove		= __devexit_p(skge_remove_one),
-};
-
-static int __init skge_init(void)
-{
-	int error;
-
-#ifdef CONFIG_PROC_FS
-	memcpy(&SK_Root_Dir_entry, BOOT_STRING, sizeof(SK_Root_Dir_entry) - 1);
-
-	pSkRootDir = proc_mkdir(SK_Root_Dir_entry, proc_net);
-	if (!pSkRootDir) {
-		printk(KERN_WARNING "Unable to create /proc/net/%s",
-				SK_Root_Dir_entry);
-		return -ENOMEM;
-	}
-	pSkRootDir->owner = THIS_MODULE;
-#endif
-
-	error = pci_module_init(&skge_driver);
-	if (error) {
-#ifdef CONFIG_PROC_FS
-		remove_proc_entry(pSkRootDir->name, proc_net);
-#endif
-	}
-
-	return error;
-}
-
-static void __exit skge_exit(void)
-{
-	 pci_unregister_driver(&skge_driver);
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(pSkRootDir->name, proc_net);
-#endif
-}
-
-module_init(skge_init);
-module_exit(skge_exit);
+/*******************************************************************************
+ *
+ * End of file
+ *
+ ******************************************************************************/
Index: linux-2.6.8/drivers/net/sk98lin/skgehwt.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skgehwt.c
+++ linux-2.6.8/drivers/net/sk98lin/skgehwt.c
@@ -1,18 +1,18 @@
 /******************************************************************************
  *
  * Name:	skgehwt.c
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision: 1.15 $
- * Date:	$Date: 2003/09/16 13:41:23 $
+ * Version:	$Revision: 2.2 $
+ * Date:	$Date: 2004/05/28 13:39:04 $
  * Purpose:	Hardware Timer
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect GmbH.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
@@ -26,9 +26,9 @@
  *	Event queue and dispatcher
  */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgehwt.c,v 1.15 2003/09/16 13:41:23 rschmidt Exp $ (C) Marvell.";
+	"@(#) $Id: skgehwt.c,v 2.2 2004/05/28 13:39:04 rschmidt Exp $ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
@@ -43,12 +43,12 @@ intro()
 
 /*
  * Prototypes of local functions.
  */
-#define	SK_HWT_MAX	(65000)
+#define	SK_HWT_MAX	65000UL * 160		/* ca. 10 sec. */
 
 /* correction factor */
-#define	SK_HWT_FAC	(1000 * (SK_U32)pAC->GIni.GIHstClkFact / 100)
+#define	SK_HWT_FAC	(10 * (SK_U32)pAC->GIni.GIHstClkFact / 16)
 
 /*
  * Initialize hardware timer.
  *
@@ -72,31 +72,23 @@ SK_IOC	Ioc)	/* IoContext */
  */
 void	SkHwtStart(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	Ioc,	/* IoContext */
-SK_U32	Time)	/* Time in units of 16us to load the timer with. */
+SK_U32	Time)	/* Time in usec to load the timer */
 {
-	SK_U32	Cnt;
-
 	if (Time > SK_HWT_MAX)
 		Time = SK_HWT_MAX;
 
 	pAC->Hwt.TStart = Time;
 	pAC->Hwt.TStop = 0L;
 
-	Cnt = Time;
-
-	/*
-	 * if time < 16 us
-	 *	time = 16 us
-	 */
-	if (!Cnt) {
-		Cnt++;
+	if (!Time) {
+		Time = 1L;
 	}
 
-	SK_OUT32(Ioc, B2_TI_INI, Cnt * SK_HWT_FAC);
-	
-	SK_OUT16(Ioc, B2_TI_CTRL, TIM_START);	/* Start timer. */
+	SK_OUT32(Ioc, B2_TI_INI, Time * SK_HWT_FAC);
+
+	SK_OUT16(Ioc, B2_TI_CTRL, TIM_START);	/* Start timer */
 
 	pAC->Hwt.TActive = SK_TRUE;
 }
 
@@ -108,15 +100,14 @@ void	SkHwtStop(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	Ioc)	/* IoContext */
 {
 	SK_OUT16(Ioc, B2_TI_CTRL, TIM_STOP);
-	
+
 	SK_OUT16(Ioc, B2_TI_CTRL, TIM_CLR_IRQ);
 
 	pAC->Hwt.TActive = SK_FALSE;
 }
 
-
 /*
  *	Stop hardware timer and read time elapsed since last start.
  *
  * returns
@@ -128,8 +119,11 @@ SK_AC	*pAC,	/* Adapters context */
 SK_IOC	Ioc)	/* IoContext */
 {
 	SK_U32	TRead;
 	SK_U32	IStatus;
+	SK_U32	TimerInt;
+
+	TimerInt = CHIP_ID_YUKON_2(pAC) ? Y2_IS_TIMINT : IS_TIMINT;
 
 	if (pAC->Hwt.TActive) {
 		
 		SkHwtStop(pAC, Ioc);
@@ -138,17 +132,17 @@ SK_IOC	Ioc)	/* IoContext */
 		TRead /= SK_HWT_FAC;
 
 		SK_IN32(Ioc, B0_ISRC, &IStatus);
 
-		/* Check if timer expired (or wraped around) */
-		if ((TRead > pAC->Hwt.TStart) || (IStatus & IS_TIMINT)) {
-			
+		/* Check if timer expired (or wrapped around) */
+		if ((TRead > pAC->Hwt.TStart) || ((IStatus & TimerInt) != 0)) {
+
 			SkHwtStop(pAC, Ioc);
-			
+
 			pAC->Hwt.TStop = pAC->Hwt.TStart;
 		}
 		else {
-			
+
 			pAC->Hwt.TStop = pAC->Hwt.TStart - TRead;
 		}
 	}
 	return(pAC->Hwt.TStop);
@@ -161,11 +155,11 @@ void	SkHwtIsr(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	Ioc)	/* IoContext */
 {
 	SkHwtStop(pAC, Ioc);
-	
+
 	pAC->Hwt.TStop = pAC->Hwt.TStart;
-	
+
 	SkTimerDone(pAC, Ioc);
 }
 
 /* End of file */
Index: linux-2.6.8/drivers/net/sk98lin/skgeinit.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skgeinit.c
+++ linux-2.6.8/drivers/net/sk98lin/skgeinit.c
@@ -1,24 +1,23 @@
 /******************************************************************************
  *
  * Name:	skgeinit.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.97 $
- * Date:	$Date: 2003/10/02 16:45:31 $
+ * Version:	$Revision: 2.48 $
+ * Date:	$Date: 2004/06/15 14:58:33 $
  * Purpose:	Contains functions to initialize the adapter
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
@@ -30,9 +29,9 @@
 /* local variables ************************************************************/
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgeinit.c,v 1.97 2003/10/02 16:45:31 rschmidt Exp $ (C) Marvell.";
+	"@(#) $Id: skgeinit.c,v 2.48 2004/06/15 14:58:33 malthoff Exp $ (C) Marvell.";
 #endif
 
 struct s_QOffTab {
 	int	RxQOff;		/* Receive Queue Address Offset */
@@ -58,8 +57,103 @@ static struct s_Config OemConfig = {
 };
 
 /******************************************************************************
  *
+ *	SkGePortVlan() -	Enable / Disable VLAN support
+ *
+ * Description:
+ *	Enable or disable the VLAN support of the selected port.
+ *	The new configuration is *not* saved over any SkGeStopPort() and
+ *	SkGeInitPort() calls.
+ *	Currently this function is only supported on Yukon-2/EC adapters.
+ *
+ * Returns:
+ *	nothing
+ */
+void SkGePortVlan(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
+int		Port,	/* Port number */
+SK_BOOL	Enable)	/* Flag */
+{
+	if (CHIP_ID_YUKON_2(pAC)) {
+		if (Enable) {
+			SK_OUT32(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), RX_VLAN_STRIP_ON);
+			SK_OUT32(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), TX_VLAN_TAG_ON);
+		}
+		else {
+			SK_OUT32(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), RX_VLAN_STRIP_OFF);
+			SK_OUT32(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), TX_VLAN_TAG_OFF);
+		}
+	}
+}
+
+
+/******************************************************************************
+ *
+ *	SkGeRxRss() -	Enable / Disable RSS Hash Calculation
+ *
+ * Description:
+ *	Enable or disable the RSS hash calculation of the selected port.
+ *	The new configuration is *not* saved over any SkGeStopPort() and
+ *	SkGeInitPort() calls.
+ *	Currently this function is only supported on Yukon-2/EC adapters.
+ *
+ * Returns:
+ *	nothing
+ */
+void SkGeRxRss(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
+int		Port,	/* Port number */
+SK_BOOL	Enable)	/* Flag */
+{
+	if (CHIP_ID_YUKON_2(pAC)) {
+		if (Enable) {
+			SK_OUT32(IoC, Q_ADDR(pAC->GIni.GP[Port].PRxQOff, Q_CSR),
+				BMU_ENA_RX_RSS_HASH);
+		}
+		else {
+			SK_OUT32(IoC, Q_ADDR(pAC->GIni.GP[Port].PRxQOff, Q_CSR),
+				BMU_DIS_RX_RSS_HASH);
+		}
+	}
+}
+
+/******************************************************************************
+ *
+ *	SkGeRxCsum() -	Enable / Disable Receive Checksum
+ *
+ * Description:
+ *	Enable or disable the checksum of the selected port.
+ *	The new configuration is *not* saved over any SkGeStopPort() and
+ *	SkGeInitPort() calls.
+ *	Currently this function is only supported on Yukon-2/EC adapters.
+ *
+ * Returns:
+ *	nothing
+ */
+void SkGeRxCsum(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
+int		Port,	/* Port number */
+SK_BOOL	Enable)	/* Flag */
+{
+	if (CHIP_ID_YUKON_2(pAC)) {
+		if (Enable) {
+			SK_OUT32(IoC, Q_ADDR(pAC->GIni.GP[Port].PRxQOff, Q_CSR),
+				BMU_ENA_RX_CHKSUM);
+		}
+		else {
+			SK_OUT32(IoC, Q_ADDR(pAC->GIni.GP[Port].PRxQOff, Q_CSR),
+				BMU_DIS_RX_CHKSUM);
+		}
+	}
+}
+
+
+/******************************************************************************
+ *
  *	SkGePollRxD() - Enable / Disable Descriptor Polling of RxD Ring
  *
  * Description:
  *	Enable or disable the descriptor polling of the receive descriptor
@@ -70,19 +164,19 @@ static struct s_Config OemConfig = {
  * Returns:
  *	nothing
  */
 void SkGePollRxD(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL PollRxD)	/* SK_TRUE (enable pol.), SK_FALSE (disable pol.) */
 {
 	SK_GEPORT *pPrt;
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), (PollRxD) ?
-		CSR_ENA_POL : CSR_DIS_POL);
+	SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), (SK_U32)((PollRxD) ?
+		CSR_ENA_POL : CSR_DIS_POL));
 }	/* SkGePollRxD */
 
 
 /******************************************************************************
@@ -98,10 +192,10 @@ SK_BOOL PollRxD)	/* SK_TRUE (enable pol.
  * Returns:
  *	nothing
  */
 void SkGePollTxD(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL PollTxD)	/* SK_TRUE (enable pol.), SK_FALSE (disable pol.) */
 {
 	SK_GEPORT *pPrt;
@@ -113,9 +207,9 @@ SK_BOOL PollTxD)	/* SK_TRUE (enable pol.
 
 	if (pPrt->PXSQSize != 0) {
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), DWord);
 	}
-	
+
 	if (pPrt->PXAQSize != 0) {
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), DWord);
 	}
 }	/* SkGePollTxD */
@@ -134,10 +228,10 @@ SK_BOOL PollTxD)	/* SK_TRUE (enable pol.
  * Returns:
  *	nothing
  */
 void SkGeYellowLED(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		State)		/* yellow LED state, 0 = OFF, 0 != ON */
 {
 	if (State == 0) {
 		/* Switch yellow LED OFF */
@@ -168,10 +262,10 @@ int		State)		/* yellow LED state, 0 = OF
  * Returns:
  *	nothing
  */
 void SkGeXmitLED(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Led,		/* offset to the LED Init Value register */
 int		Mode)		/* Mode may be SK_LED_DIS, SK_LED_ENA, SK_LED_TST */
 {
 	SK_U32	LedIni;
@@ -196,9 +290,9 @@ int		Mode)		/* Mode may be SK_LED_DIS, S
 		SK_OUT32(IoC, Led + XMIT_LED_CNT, 0);
 		SK_OUT8(IoC, Led + XMIT_LED_TST, LED_T_OFF);
 		break;
 	}
-			
+
 	/*
 	 * 1000BT: The Transmit LED is driven by the PHY.
 	 * But the default LED configuration is used for
 	 * Level One and Broadcom PHYs.
@@ -226,9 +320,9 @@ int		Mode)		/* Mode may be SK_LED_DIS, S
  *	0:	success
  *	1:	configuration error
  */
 static int DoCalcAddr(
-SK_AC		*pAC, 				/* adapter context */
+SK_AC		*pAC, 				/* Adapter Context */
 SK_GEPORT	SK_FAR *pPrt,		/* port index */
 int			QuSize,				/* size of the queue to configure in kB */
 SK_U32		SK_FAR *StartVal,	/* start value for address calculation */
 SK_U32		SK_FAR *QuStartAddr,/* start addr to calculate */
@@ -263,14 +357,42 @@ SK_U32		SK_FAR *QuEndAddr)	/* end addres
 }	/* DoCalcAddr */
 
 /******************************************************************************
  *
+ *	SkGeRoundQueueSize() - Round the given queue size to the adpaters QZ units
+ *
+ * Description:
+ *	This function rounds the given queue size in kBs to adapter specific
+ *	queue size units (Genesis and Yukon: 8kB, Yukon-2/EC 1kB).
+ *
+ * Returns:
+ *	the rounded queue size in kB	
+ */
+static int SkGeRoundQueueSize(
+SK_AC	*pAC,		/* Adapter Context */
+int	QueueSizeKB)	/* Queue size in kB */
+{
+	int QueueSizeSteps;
+
+	if (CHIP_ID_YUKON_2(pAC)) {
+		QueueSizeSteps = QZ_STEP_Y2;
+	}
+	else {
+		QueueSizeSteps = QZ_STEP;
+	}
+
+	return ((QueueSizeKB + QueueSizeSteps-1) & ~(QueueSizeSteps-1));
+}	/* SkGeRoundQueueSize */
+
+
+/******************************************************************************
+ *
  *	SkGeInitAssignRamToQueues() - allocate default queue sizes
  *
  * Description:
  *	This function assigns the memory to the different queues and ports.
  *	When DualNet is set to SK_TRUE all ports get the same amount of memory.
- *  Otherwise the first port gets most of the memory and all the
+ *	Otherwise the first port gets most of the memory and all the
  *	other ports just the required minimum.
  *	This function can only be called when pAC->GIni.GIRamSize and
  *	pAC->GIni.GIMacsFound have been initialized, usually this happens
  *	at init level 1
@@ -281,30 +403,40 @@ SK_U32		SK_FAR *QuEndAddr)	/* end addres
  *	2 - not enough memory
  */
 
 int SkGeInitAssignRamToQueues(
-SK_AC	*pAC,			/* Adapter context */
+SK_AC	*pAC,			/* Adapter Context */
 int		ActivePort,		/* Active Port in RLMT mode */
-SK_BOOL	DualNet)		/* adapter context */
+SK_BOOL	DualNet)		/* Dual Net active */
 {
 	int	i;
 	int	UsedKilobytes;			/* memory already assigned */
 	int	ActivePortKilobytes;	/* memory available for active port */
+	int MinQueueSize;			/* min. memory for queues */
 	SK_GEPORT *pGePort;
 
 	UsedKilobytes = 0;
 
 	if (ActivePort >= pAC->GIni.GIMacsFound) {
+
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
 			("SkGeInitAssignRamToQueues: ActivePort (%d) invalid\n",
 			ActivePort));
 		return(1);
 	}
-	if (((pAC->GIni.GIMacsFound * (SK_MIN_RXQ_SIZE + SK_MIN_TXQ_SIZE)) +
-		((RAM_QUOTA_SYNC == 0) ? 0 : SK_MIN_TXQ_SIZE)) > pAC->GIni.GIRamSize) {
+
+	MinQueueSize = SK_MIN_RXQ_SIZE + SK_MIN_TXQ_SIZE;
+
+	if (MinQueueSize > pAC->GIni.GIRamSize) {
+		MinQueueSize = pAC->GIni.GIRamSize;
+	}
+
+	if ((pAC->GIni.GIMacsFound * MinQueueSize +
+		 RAM_QUOTA_SYNC * SK_MIN_TXQ_SIZE) > pAC->GIni.GIRamSize) {
+
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
 			("SkGeInitAssignRamToQueues: Not enough memory (%d)\n",
-			 pAC->GIni.GIRamSize));
+			pAC->GIni.GIRamSize));
 		return(2);
 	}
 
 	if (DualNet) {
@@ -312,28 +444,28 @@ SK_BOOL	DualNet)		/* adapter context */
 		ActivePortKilobytes = pAC->GIni.GIRamSize / pAC->GIni.GIMacsFound;
 		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 
 			pGePort = &pAC->GIni.GP[i];
-			
+
 			/* take away the minimum memory for active queues */
-			ActivePortKilobytes -= (SK_MIN_RXQ_SIZE + SK_MIN_TXQ_SIZE);
+			ActivePortKilobytes -= MinQueueSize;
 
 			/* receive queue gets the minimum + 80% of the rest */
-			pGePort->PRxQSize = (int) (ROUND_QUEUE_SIZE_KB((
-				ActivePortKilobytes * (unsigned long) RAM_QUOTA_RX) / 100))
+			pGePort->PRxQSize = SkGeRoundQueueSize(pAC,
+				(int)((long)ActivePortKilobytes * RAM_QUOTA_RX) / 100)
 				+ SK_MIN_RXQ_SIZE;
 
 			ActivePortKilobytes -= (pGePort->PRxQSize - SK_MIN_RXQ_SIZE);
 
 			/* synchronous transmit queue */
 			pGePort->PXSQSize = 0;
 
 			/* asynchronous transmit queue */
-			pGePort->PXAQSize = (int) ROUND_QUEUE_SIZE_KB(ActivePortKilobytes +
-				SK_MIN_TXQ_SIZE);
+			pGePort->PXAQSize = SkGeRoundQueueSize(pAC,
+				ActivePortKilobytes + SK_MIN_TXQ_SIZE);
 		}
 	}
-	else {	
+	else {
 		/* Rlmt Mode or single link adapter */
 
 		/* Set standby queue size defaults for all standby ports */
 		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
@@ -353,32 +485,30 @@ SK_BOOL	DualNet)		/* adapter context */
 		ActivePortKilobytes = pAC->GIni.GIRamSize - UsedKilobytes;
 
 		/* assign it to the active port */
 		/* first take away the minimum memory */
-		ActivePortKilobytes -= (SK_MIN_RXQ_SIZE + SK_MIN_TXQ_SIZE);
+		ActivePortKilobytes -= MinQueueSize;
 		pGePort = &pAC->GIni.GP[ActivePort];
 
 		/* receive queue get's the minimum + 80% of the rest */
-		pGePort->PRxQSize = (int) (ROUND_QUEUE_SIZE_KB((ActivePortKilobytes *
-			(unsigned long) RAM_QUOTA_RX) / 100)) + SK_MIN_RXQ_SIZE;
+		pGePort->PRxQSize = SkGeRoundQueueSize(pAC,
+			(int)((long)ActivePortKilobytes * RAM_QUOTA_RX) / 100) +
+			MinQueueSize/2;
 
-		ActivePortKilobytes -= (pGePort->PRxQSize - SK_MIN_RXQ_SIZE);
+		ActivePortKilobytes -= (pGePort->PRxQSize - MinQueueSize/2);
 
 		/* synchronous transmit queue */
 		pGePort->PXSQSize = 0;
 
 		/* asynchronous transmit queue */
-		pGePort->PXAQSize = (int) ROUND_QUEUE_SIZE_KB(ActivePortKilobytes) +
-			SK_MIN_TXQ_SIZE;
+		pGePort->PXAQSize = SkGeRoundQueueSize(pAC, ActivePortKilobytes) +
+			MinQueueSize/2;
 	}
-#ifdef VCPU
-	VCPUprintf(0, "PRxQSize=%u, PXSQSize=%u, PXAQSize=%u\n",
-		pGePort->PRxQSize, pGePort->PXSQSize, pGePort->PXAQSize);
-#endif /* VCPU */
 
 	return(0);
 }	/* SkGeInitAssignRamToQueues */
 
+
 /******************************************************************************
  *
  *	SkGeCheckQSize() - Checks the Adapters Queue Size Configuration
  *
@@ -387,14 +517,14 @@ SK_BOOL	DualNet)		/* adapter context */
  *	in the variables PRxQSize, PXSQSize, and PXAQSize of all
  *	used ports.
  *	This requirements must be fullfilled to have a valid configuration:
  *		- The size of all queues must not exceed GIRamSize.
- *		- The queue sizes must be specified in units of 8 kB.
+ *		- The queue sizes must be specified in units of 8 kB (Genesis & Yukon).
  *		- The size of Rx queues of available ports must not be
- *		  smaller than 16 kB.
+ *		  smaller than 16 kB (Genesis & Yukon) resp. 10 kB (Yukon-2).
  *		- The size of at least one Tx queue (synch. or asynch.)
- *        of available ports must not be smaller than 16 kB
- *        when Jumbo Frames are used.
+ *		  of available ports must not be smaller than 16 kB (Genesis & Yukon),
+ *		  resp. 10 kB (Yukon-2) when Jumbo Frames are used.
  *		- The RAM start and end addresses must not be changed
  *		  for ports which are already initialized.
  *	Furthermore SkGeCheckQSize() defines the Start and End Addresses
  *  of all ports and stores them into the HWAC port	structure.
@@ -403,9 +533,9 @@ SK_BOOL	DualNet)		/* adapter context */
  *	0:	Queue Size Configuration valid
  *	1:	Queue Size Configuration invalid
  */
 static int SkGeCheckQSize(
-SK_AC	 *pAC,		/* adapter context */
+SK_AC	 *pAC,		/* Adapter Context */
 int		 Port)		/* port index */
 {
 	SK_GEPORT *pPrt;
 	int	i;
@@ -413,46 +543,53 @@ int		 Port)		/* port index */
 	int	Rtv2;
 	SK_U32	StartAddr;
 #ifndef SK_SLIM
 	int	UsedMem;	/* total memory used (max. found ports) */
-#endif	
+#endif
 
 	Rtv = 0;
-	
+
 #ifndef SK_SLIM
 
 	UsedMem = 0;
+	Rtv = 0;
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 		pPrt = &pAC->GIni.GP[i];
 
-		if ((pPrt->PRxQSize & QZ_UNITS) != 0 ||
-			(pPrt->PXSQSize & QZ_UNITS) != 0 ||
-			(pPrt->PXAQSize & QZ_UNITS) != 0) {
+		if (CHIP_ID_YUKON_2(pAC)) {
+			UsedMem = 0;
+		}
+		else if (((pPrt->PRxQSize & QZ_UNITS) != 0 ||
+				  (pPrt->PXSQSize & QZ_UNITS) != 0 ||
+				  (pPrt->PXAQSize & QZ_UNITS) != 0)) {
 
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E012, SKERR_HWI_E012MSG);
 			return(1);
 		}
 
-		if (i == Port && pPrt->PRxQSize < SK_MIN_RXQ_SIZE) {
+#ifndef SK_DIAG
+		if (i == Port && pAC->GIni.GIRamSize > SK_MIN_RXQ_SIZE &&
+			pPrt->PRxQSize < SK_MIN_RXQ_SIZE) {
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E011, SKERR_HWI_E011MSG);
 			return(1);
 		}
-		
+
 		/*
 		 * the size of at least one Tx queue (synch. or asynch.) has to be > 0.
 		 * if Jumbo Frames are used, this size has to be >= 16 kB.
 		 */
 		if ((i == Port && pPrt->PXSQSize == 0 && pPrt->PXAQSize == 0) ||
 			(pAC->GIni.GIPortUsage == SK_JUMBO_LINK &&
-            ((pPrt->PXSQSize > 0 && pPrt->PXSQSize < SK_MIN_TXQ_SIZE) ||
+			((pPrt->PXSQSize > 0 && pPrt->PXSQSize < SK_MIN_TXQ_SIZE) ||
 			 (pPrt->PXAQSize > 0 && pPrt->PXAQSize < SK_MIN_TXQ_SIZE)))) {
 				SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E023, SKERR_HWI_E023MSG);
 				return(1);
 		}
-		
+#endif /* !SK_DIAG */
+
 		UsedMem += pPrt->PRxQSize + pPrt->PXSQSize + pPrt->PXAQSize;
 	}
-	
+
 	if (UsedMem > pAC->GIni.GIRamSize) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E012, SKERR_HWI_E012MSG);
 		return(1);
 	}
@@ -462,8 +599,16 @@ int		 Port)		/* port index */
 	StartAddr = pAC->GIni.GIRamOffs;
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 		pPrt = &pAC->GIni.GP[i];
 
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+			("Port %d: RxQSize=%u, TxAQSize=%u, TxSQSize=%u\n",
+			i, pPrt->PRxQSize, pPrt->PXAQSize, pPrt->PXSQSize));
+
+		if (CHIP_ID_YUKON_2(pAC)) {
+			StartAddr = 0;
+		}
+
 		/* Calculate/Check values for the receive queue */
 		Rtv2 = DoCalcAddr(pAC, pPrt, pPrt->PRxQSize, &StartAddr,
 			&pPrt->PRxQRamStart, &pPrt->PRxQRamEnd);
 		Rtv |= Rtv2;
@@ -501,10 +646,10 @@ int		 Port)		/* port index */
  * Returns:
  *	nothing
  */
 static void SkGeInitMacArb(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC)		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
 {
 	/* release local reset */
 	SK_OUT16(IoC, B3_MA_TO_CTRL, MA_RST_CLR);
 
@@ -541,10 +686,10 @@ SK_IOC	IoC)		/* IO context */
  * Returns:
  *	nothing
  */
 static void SkGeInitPktArb(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC)		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
 {
 	/* release local reset */
 	SK_OUT16(IoC, B3_PA_CTRL, PA_RST_CLR);
 
@@ -581,80 +726,79 @@ SK_IOC	IoC)		/* IO context */
  * Returns:
  *	nothing
  */
 static void SkGeInitMacFifo(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_U16	Word;
-#ifdef VCPU
-	SK_U32	DWord;
-#endif /* VCPU */
 	/*
 	 * For each FIFO:
 	 *	- release local reset
 	 *	- use default value for MAC FIFO size
 	 *	- setup defaults for the control register
 	 *	- enable the FIFO
 	 */
-	
+
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* Configure Rx MAC FIFO */
 		SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_RST_CLR);
 		SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_RX_CTRL_DEF);
 		SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_ENA_OP_MD);
-	
+
 		/* Configure Tx MAC FIFO */
 		SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_RST_CLR);
 		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_TX_CTRL_DEF);
 		SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_ENA_OP_MD);
-	
+
 		/* Enable frame flushing if jumbo frames used */
 		if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
 			SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_ENA_FLUSH);
 		}
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		/* set Rx GMAC FIFO Flush Mask */
-		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_MSK), (SK_U16)RX_FF_FL_DEF_MSK);
-		
+
 		Word = (SK_U16)GMF_RX_CTRL_DEF;
 
 		/* disable Rx GMAC FIFO Flush for YUKON-Lite Rev. A0 only */
 		if (pAC->GIni.GIYukonLite && pAC->GIni.GIChipId == CHIP_ID_YUKON) {
 
 			Word &= ~GMF_RX_F_FL_ON;
 		}
-		
-		/* Configure Rx MAC FIFO */
+
+		/* Configure Rx GMAC FIFO */
 		SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_RST_CLR);
 		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), Word);
-		
-		/* set Rx GMAC FIFO Flush Threshold (default: 0x0a -> 56 bytes) */
-		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_THR), RX_GMF_FL_THR_DEF);
-		
-		/* Configure Tx MAC FIFO */
+
+		/* set Rx GMAC FIFO Flush Mask (after clearing reset) */
+		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_MSK), (SK_U16)RX_FF_FL_DEF_MSK);
+
+		Word = (SK_U16)RX_GMF_FL_THR_DEF;	/* default: 0x0a -> 56 bytes) */
+
+		if (pAC->GIni.GIAsfEnabled) {
+			Word -= 2;						/* for ASF: 0x08 -> 40 bytes) */
+		}
+
+		/* set Rx GMAC FIFO Flush Threshold (after clearing reset) */
+		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_THR), Word);
+
+		/* Configure Tx GMAC FIFO */
 		SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U8)GMF_RST_CLR);
 		SK_OUT16(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U16)GMF_TX_CTRL_DEF);
-		
-#ifdef VCPU
-		SK_IN32(IoC, MR_ADDR(Port, RX_GMF_AF_THR), &DWord);
-		SK_IN32(IoC, MR_ADDR(Port, TX_GMF_AE_THR), &DWord);
-#endif /* VCPU */
-		
+
 		/* set Tx GMAC FIFO Almost Empty Threshold */
 /*		SK_OUT32(IoC, MR_ADDR(Port, TX_GMF_AE_THR), 0); */
 	}
 #endif /* YUKON */
 
 }	/* SkGeInitMacFifo */
 
-#ifdef	SK_LNK_SYNC_CNT
+#ifdef SK_LNK_SYNC_CNT
 /******************************************************************************
  *
  *	SkGeLoadLnkSyncCnt() - Load the Link Sync Counter and starts counting
  *
@@ -673,10 +817,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkGeLoadLnkSyncCnt(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_U32	CntVal)		/* Counter value */
 {
 	SK_U32	OrgIMsk;
@@ -684,9 +828,9 @@ SK_U32	CntVal)		/* Counter value */
 	SK_U32	ISrc;
 	SK_BOOL	IrqPend;
 
 	/* stop counter */
-	SK_OUT8(IoC, MR_ADDR(Port, LNK_SYNC_CTRL), LED_STOP);
+	SK_OUT8(IoC, MR_ADDR(Port, LNK_SYNC_CTRL), LNK_STOP);
 
 	/*
 	 * ASIC problem:
 	 * Each time starting the Link Sync Counter an IRQ is generated
@@ -697,8 +841,9 @@ SK_U32	CntVal)		/* Counter value */
 	 */
 	IrqPend = SK_FALSE;
 	SK_IN32(IoC, B0_ISRC, &ISrc);
 	SK_IN32(IoC, B0_IMSK, &OrgIMsk);
+	
 	if (Port == MAC_1) {
 		NewIMsk = OrgIMsk & ~IS_LNK_SYNC_M1;
 		if ((ISrc & IS_LNK_SYNC_M1) != 0) {
 			IrqPend = SK_TRUE;
@@ -709,25 +854,28 @@ SK_U32	CntVal)		/* Counter value */
 		if ((ISrc & IS_LNK_SYNC_M2) != 0) {
 			IrqPend = SK_TRUE;
 		}
 	}
+
 	if (!IrqPend) {
 		SK_OUT32(IoC, B0_IMSK, NewIMsk);
 	}
 
 	/* load counter */
 	SK_OUT32(IoC, MR_ADDR(Port, LNK_SYNC_INI), CntVal);
 
 	/* start counter */
-	SK_OUT8(IoC, MR_ADDR(Port, LNK_SYNC_CTRL), LED_START);
+	SK_OUT8(IoC, MR_ADDR(Port, LNK_SYNC_CTRL), LNK_START);
 
 	if (!IrqPend) {
-		/* clear the unexpected IRQ, and restore the interrupt mask */
-		SK_OUT8(IoC, MR_ADDR(Port, LNK_SYNC_CTRL), LED_CLR_IRQ);
+		/* clear the unexpected IRQ */
+		SK_OUT8(IoC, MR_ADDR(Port, LNK_SYNC_CTRL), LNK_CLR_IRQ);
+		
+		/* restore the interrupt mask */
 		SK_OUT32(IoC, B0_IMSK, OrgIMsk);
 	}
 }	/* SkGeLoadLnkSyncCnt*/
-#endif	/* SK_LNK_SYNC_CNT */
+#endif /* SK_LNK_SYNC_CNT */
 
 #if defined(SK_DIAG) || defined(SK_CFG_SYNC)
 /******************************************************************************
  *
@@ -757,10 +905,10 @@ SK_U32	CntVal)		/* Counter value */
  *	2:	try to configure quality of service although no
  *		synchronous queue is configured
  */
 int SkGeCfgSync(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_U32	IntTime,	/* Interval Timer Value in units of 8ns */
 SK_U32	LimCount,	/* Number of bytes to transfer during IntTime */
 int		SyncMode)	/* Sync Mode: TXA_ENA_ALLOC | TXA_DIS_ALLOC | 0 */
@@ -776,18 +924,18 @@ int		SyncMode)	/* Sync Mode: TXA_ENA_ALL
 
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E010, SKERR_HWI_E010MSG);
 		return(1);
 	}
-	
+
 	if (pAC->GIni.GP[Port].PXSQSize == 0) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E009, SKERR_HWI_E009MSG);
 		return(2);
 	}
-	
+
 	/* calculate register values */
 	IntTime = (IntTime / 2) * pAC->GIni.GIHstClkFact / 100;
 	LimCount = LimCount / 8;
-	
+
 	if (IntTime > TXA_MAX_VAL || LimCount > TXA_MAX_VAL) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E010, SKERR_HWI_E010MSG);
 		return(1);
 	}
@@ -803,15 +951,15 @@ int		SyncMode)	/* Sync Mode: TXA_ENA_ALL
 	 *   if Interval Timer or Limit Counter not zero.
 	 */
 	SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
 		TXA_ENA_FSYNC | TXA_DIS_ALLOC | TXA_STOP_RC);
-	
+
 	SK_OUT32(IoC, MR_ADDR(Port, TXA_ITI_INI), IntTime);
 	SK_OUT32(IoC, MR_ADDR(Port, TXA_LIM_INI), LimCount);
-	
+
 	SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
 		(SK_U8)(SyncMode & (TXA_ENA_ALLOC | TXA_DIS_ALLOC)));
-	
+
 	if (IntTime != 0 || LimCount != 0) {
 		SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL), TXA_DIS_FSYNC | TXA_START_RC);
 	}
 
@@ -830,12 +978,12 @@ int		SyncMode)	/* Sync Mode: TXA_ENA_ALL
  *
  * Returns:
  *	nothing
  */
-static void DoInitRamQueue(
-SK_AC	*pAC,			/* adapter context */
-SK_IOC	IoC,			/* IO context */
-int		QuIoOffs,		/* Queue IO Address Offset */
+void DoInitRamQueue(
+SK_AC	*pAC,			/* Adapter Context */
+SK_IOC	IoC,			/* I/O Context */
+int		QuIoOffs,		/* Queue I/O Address Offset */
 SK_U32	QuStartAddr,	/* Queue Start Address */
 SK_U32	QuEndAddr,		/* Queue End Address */
 int		QuType)			/* Queue Type (SK_RX_SRAM_Q|SK_RX_BRAM_Q|SK_TX_RAM_Q) */
 {
@@ -866,10 +1014,9 @@ int		QuType)			/* Queue Type (SK_RX_SRAM
 			RxLoThresVal += (SK_RB_LLPP_B - SK_RB_LLPP_S) / 8;
 
 			/* continue with SK_RX_BRAM_Q */
 		case SK_RX_BRAM_Q:
-			/* write threshold for Rx Queue */
-
+			/* write threshold for Rx Queue (Pause packets) */
 			SK_OUT32(IoC, RB_ADDR(QuIoOffs, RB_RX_UTPP), RxUpThresVal);
 			SK_OUT32(IoC, RB_ADDR(QuIoOffs, RB_RX_LTPP), RxLoThresVal);
 
 			/* the high priority threshold not used */
@@ -910,30 +1057,30 @@ int		QuType)			/* Queue Type (SK_RX_SRAM
  * Returns:
  *	nothing
  */
 static void SkGeInitRamBufs(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT *pPrt;
 	int RxQType;
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	if (pPrt->PRxQSize == SK_MIN_RXQ_SIZE) {
+	if (pPrt->PRxQSize <= SK_MIN_RXQ_SIZE) {
 		RxQType = SK_RX_SRAM_Q; 	/* small Rx Queue */
 	}
 	else {
 		RxQType = SK_RX_BRAM_Q;		/* big Rx Queue */
 	}
 
 	DoInitRamQueue(pAC, IoC, pPrt->PRxQOff, pPrt->PRxQRamStart,
 		pPrt->PRxQRamEnd, RxQType);
-	
+
 	DoInitRamQueue(pAC, IoC, pPrt->PXsQOff, pPrt->PXsQRamStart,
 		pPrt->PXsQRamEnd, SK_TX_RAM_Q);
-	
+
 	DoInitRamQueue(pAC, IoC, pPrt->PXaQOff, pPrt->PXaQRamStart,
 		pPrt->PXaQRamEnd, SK_TX_RAM_Q);
 
 }	/* SkGeInitRamBufs */
@@ -952,28 +1099,39 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkGeInitRamIface(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC)		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
 {
-	/* release local reset */
-	SK_OUT16(IoC, B3_RI_CTRL, RI_RST_CLR);
+	int i;
+	int RamBuffers;
 
-	/* configure timeout values */
-	SK_OUT8(IoC, B3_RI_WTO_R1, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_WTO_XA1, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_WTO_XS1, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_RTO_R1, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_RTO_XA1, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_RTO_XS1, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_WTO_R2, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_WTO_XA2, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_WTO_XS2, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_RTO_R2, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_RTO_XA2, SK_RI_TO_53);
-	SK_OUT8(IoC, B3_RI_RTO_XS2, SK_RI_TO_53);
+	if (CHIP_ID_YUKON_2(pAC)) {
+		RamBuffers = pAC->GIni.GIMacsFound;
+	}
+	else {
+		RamBuffers = 1;
+	}
+	
+	for (i = 0; i < RamBuffers; i++) {
+		/* release local reset */
+		SK_OUT16(IoC, SELECT_RAM_BUFFER(i, B3_RI_CTRL), RI_RST_CLR);
 
+		/* configure timeout values */
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_WTO_R1), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_WTO_XA1), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_WTO_XS1), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_RTO_R1), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_RTO_XA1), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_RTO_XS1), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_WTO_R2), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_WTO_XA2), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_WTO_XS2), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_RTO_R2), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_RTO_XA2), SK_RI_TO_53);
+		SK_OUT8(IoC, SELECT_RAM_BUFFER(i, B3_RI_RTO_XS2), SK_RI_TO_53);
+	}
 }	/* SkGeInitRamIface */
 
 
 /******************************************************************************
@@ -986,10 +1144,10 @@ SK_IOC	IoC)		/* IO context */
  * Returns:
  *	nothing
  */
 static void SkGeInitBmu(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U32		RxWm;
@@ -998,31 +1156,65 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	pPrt = &pAC->GIni.GP[Port];
 
 	RxWm = SK_BMU_RX_WM;
 	TxWm = SK_BMU_TX_WM;
-	
-	if (!pAC->GIni.GIPciSlot64 && !pAC->GIni.GIPciClock66) {
-		/* for better performance */
-		RxWm /= 2;
-		TxWm /= 2;
-	}
 
-	/* Rx Queue: Release all local resets and set the watermark */
-	SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_CLR_RESET);
-	SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_F), RxWm);
+	if (CHIP_ID_YUKON_2(pAC)) {
 
-	/*
-	 * Tx Queue: Release all local resets if the queue is used !
-	 * 		set watermark
-	 */
-	if (pPrt->PXSQSize != 0) {
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_CLR_RESET);
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_F), TxWm);
+		if (pAC->GIni.GIPciBus == SK_PEX_BUS) {
+			/* for better performance set it to 128 */
+			RxWm = SK_BMU_RX_WM_PEX;		
+		}
+
+		/* Rx Queue: Release all local resets and set the watermark */
+		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), BMU_CLR_RESET);
+		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), BMU_OPER_INIT);
+		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), BMU_FIFO_OP_ON);
+		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_WM), RxWm);
+
+		/*
+		 * Tx Queue: Release all local resets if the queue is used !
+		 * 		set watermark
+		 */
+		if (pPrt->PXSQSize != 0 && HW_SYNC_TX_SUPPORTED(pAC)) {
+			/* Yukon-EC doesn't have a synchronous Tx queue */
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), BMU_CLR_RESET);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), BMU_OPER_INIT);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), BMU_FIFO_OP_ON);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_WM), TxWm);
+		}
+		
+		if (pPrt->PXAQSize != 0) {
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), BMU_CLR_RESET);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), BMU_OPER_INIT);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), BMU_FIFO_OP_ON);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_WM), TxWm);
+		}
 	}
-	
-	if (pPrt->PXAQSize != 0) {
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_CLR_RESET);
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_F), TxWm);
+	else {
+		if (!pAC->GIni.GIPciSlot64 && !pAC->GIni.GIPciClock66) {
+			/* for better performance */
+			RxWm /= 2;
+			TxWm /= 2;
+		}
+
+		/* Rx Queue: Release all local resets and set the watermark */
+		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_CLR_RESET);
+		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_F), RxWm);
+
+		/*
+		 * Tx Queue: Release all local resets if the queue is used !
+		 * 		set watermark
+		 */
+		if (pPrt->PXSQSize != 0) {
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_CLR_RESET);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_F), TxWm);
+		}
+
+		if (pPrt->PXAQSize != 0) {
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_CLR_RESET);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_F), TxWm);
+		}
 	}
 	/*
 	 * Do NOT enable the descriptor poll timers here, because
 	 * the descriptor addresses are not specified yet.
@@ -1044,22 +1236,31 @@ int		Port)		/* Port Index (MAC_1 + n) */
  *	The queues control status register
  */
 static SK_U32 TestStopBit(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO Context */
-int		QuIoOffs)	/* Queue IO Address Offset */
+SK_IOC	IoC,		/* I/O Context */
+int		QuIoOffs)	/* Queue I/O Address Offset */
 {
 	SK_U32	QuCsr;	/* CSR contents */
 
 	SK_IN32(IoC, Q_ADDR(QuIoOffs, Q_CSR), &QuCsr);
 	
-	if ((QuCsr & (CSR_STOP | CSR_SV_IDLE)) == 0) {
-		/* Stop Descriptor overridden by start command */
-		SK_OUT32(IoC, Q_ADDR(QuIoOffs, Q_CSR), CSR_STOP);
+	if (CHIP_ID_YUKON_2(pAC)) {
+		if ((QuCsr & (BMU_STOP | BMU_IDLE)) == 0) {
+			/* Stop Descriptor overridden by start command */
+			SK_OUT32(IoC, Q_ADDR(QuIoOffs, Q_CSR), BMU_STOP);
 
-		SK_IN32(IoC, Q_ADDR(QuIoOffs, Q_CSR), &QuCsr);
+			SK_IN32(IoC, Q_ADDR(QuIoOffs, Q_CSR), &QuCsr);
+		}
+	}
+	else {
+		if ((QuCsr & (CSR_STOP | CSR_SV_IDLE)) == 0) {
+			/* Stop Descriptor overridden by start command */
+			SK_OUT32(IoC, Q_ADDR(QuIoOffs, Q_CSR), CSR_STOP);
+
+			SK_IN32(IoC, Q_ADDR(QuIoOffs, Q_CSR), &QuCsr);
+		}
 	}
-	
 	return(QuCsr);
 }	/* TestStopBit */
 
 
@@ -1141,126 +1342,183 @@ int		QuIoOffs)	/* Queue IO Address Offse
  *	o This function may be called during the driver states RESET_PORT and
  *	  SWITCH_PORT.
  */
 void SkGeStopPort(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* I/O context */
-int		Port,	/* port to stop (MAC_1 + n) */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
+int		Port,	/* Port to stop (MAC_1 + n) */
 int		Dir,	/* Direction to Stop (SK_STOP_RX, SK_STOP_TX, SK_STOP_ALL) */
 int		RstMode)/* Reset Mode (SK_SOFT_RST, SK_HARD_RST) */
 {
-#ifndef SK_DIAG
-	SK_EVPARA Para;
-#endif /* !SK_DIAG */
 	SK_GEPORT *pPrt;
-	SK_U32	DWord;
+	SK_U32	RxCsr;
 	SK_U32	XsCsr;
 	SK_U32	XaCsr;
 	SK_U64	ToutStart;
+	SK_U32	CsrStart;
+	SK_U32	CsrStop;
+	SK_U32	CsrIdle;
+	SK_U32	CsrTest;
+	SK_U8 	rsl;	/* FIFO read shadow level */
+	SK_U8	rl;		/* FIFO read level */
 	int		i;
 	int		ToutCnt;
 
 	pPrt = &pAC->GIni.GP[Port];
 
+	/* set the proper values of Q_CSR register layout depending on the chip id */
+	if (CHIP_ID_YUKON_2(pAC)) {
+		CsrStart = BMU_START;
+		CsrStop = BMU_STOP;
+		CsrIdle = BMU_IDLE;
+		CsrTest = BMU_IDLE;
+	}
+	else {
+		CsrStart = CSR_START;
+		CsrStop = CSR_STOP;
+		CsrIdle = CSR_SV_IDLE;
+		CsrTest = CSR_SV_IDLE | CSR_STOP;
+	}
+
 	if ((Dir & SK_STOP_TX) != 0) {
-		/* disable receiver and transmitter */
-		SkMacRxTxDisable(pAC, IoC, Port);
-		
+
+		if (!pAC->GIni.GIAsfEnabled) {
+			/* disable receiver and transmitter */
+			SkMacRxTxDisable(pAC, IoC, Port);
+		}
+
 		/* stop both transmit queues */
 		/*
 		 * If the BMU is in the reset state CSR_STOP will terminate
 		 * immediately.
 		 */
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_STOP);
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_STOP);
+		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CsrStop);
+		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CsrStop);
 
 		ToutStart = SkOsGetTime(pAC);
 		ToutCnt = 0;
 		do {
-			/*
-			 * Clear packet arbiter timeout to make sure
-			 * this loop will terminate.
-			 */
-			SK_OUT16(IoC, B3_PA_CTRL, (SK_U16)((Port == MAC_1) ?
-				PA_CLR_TO_TX1 : PA_CLR_TO_TX2));
-
-			/*
-			 * If the transfer stucks at the MAC the STOP command will not
-			 * terminate if we don't flush the XMAC's transmit FIFO !
-			 */
-			SkMacFlushTxFifo(pAC, IoC, Port);
+#ifdef GENESIS
+			if (pAC->GIni.GIGenesis) {
+				/* Clear Tx packet arbiter timeout IRQ */
+				SK_OUT16(IoC, B3_PA_CTRL, (SK_U16)((Port == MAC_1) ?
+					PA_CLR_TO_TX1 : PA_CLR_TO_TX2));
 
-			XsCsr = TestStopBit(pAC, IoC, pPrt->PXsQOff);
+				/*
+				 * If the transfer stucks at the MAC the STOP command will not
+				 * terminate if we don't flush the XMAC's transmit FIFO !
+				 */
+				SkMacFlushTxFifo(pAC, IoC, Port);
+			}
+#endif /* GENESIS */
+			
 			XaCsr = TestStopBit(pAC, IoC, pPrt->PXaQOff);
 
+			if (HW_SYNC_TX_SUPPORTED(pAC)) {
+				XsCsr = TestStopBit(pAC, IoC, pPrt->PXsQOff);
+			}
+			else {
+				XsCsr = XaCsr;
+			}
+
 			if (SkOsGetTime(pAC) - ToutStart > (SK_TICKS_PER_SEC / 18)) {
 				/*
 				 * Timeout of 1/18 second reached.
 				 * This needs to be checked at 1/18 sec only.
 				 */
 				ToutCnt++;
 				if (ToutCnt > 1) {
-					/* Might be a problem when the driver event handler
-					 * calls StopPort again. XXX.
+					/*
+					 * If BMU stop doesn't terminate, we assume
+					 * we have a stable state and can reset the
+					 * BMU, Pref Unit, and RAM buffer now.
 					 */
-
-					/* Fatal Error, Loop aborted */
-					SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_HWI_E018,
-						SKERR_HWI_E018MSG);
-#ifndef SK_DIAG
-					Para.Para64 = Port;
-					SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
-#endif /* !SK_DIAG */
-					return;
+					break;				/* ====> leave do/while loop here */
 				}
 				/*
 				 * Cache incoherency workaround: Assume a start command
 				 * has been lost while sending the frame.
 				 */
 				ToutStart = SkOsGetTime(pAC);
 
-				if ((XsCsr & CSR_STOP) != 0) {
-					SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_START);
+				if ((XsCsr & CsrStop) != 0) {
+					SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CsrStart);
+				}
+				if ((XaCsr & CsrStop) != 0) {
+					SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CsrStart);
+				}
+
+				/*
+				 * After the previous operations the X(s|a)Csr does no
+				 * longer contain the proper values
+				 */
+				XaCsr = TestStopBit(pAC, IoC, pPrt->PXaQOff);
+
+				if (HW_SYNC_TX_SUPPORTED(pAC)) {
+					XsCsr = TestStopBit(pAC, IoC, pPrt->PXsQOff);
 				}
-				if ((XaCsr & CSR_STOP) != 0) {
-					SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_START);
+				else {
+					XsCsr = XaCsr;
 				}
 			}
 
 			/*
 			 * Because of the ASIC problem report entry from 21.08.1998 it is
 			 * required to wait until CSR_STOP is reset and CSR_SV_IDLE is set.
+			 * (valid for GENESIS only)
 			 */
-		} while ((XsCsr & (CSR_STOP | CSR_SV_IDLE)) != CSR_SV_IDLE ||
-				 (XaCsr & (CSR_STOP | CSR_SV_IDLE)) != CSR_SV_IDLE);
+		} while (((XsCsr & CsrTest) != CsrIdle ||
+				  (XaCsr & CsrTest) != CsrIdle));
+
+		if (pAC->GIni.GIAsfEnabled) {
 
-		/* Reset the MAC depending on the RstMode */
-		if (RstMode == SK_SOFT_RST) {
-			SkMacSoftRst(pAC, IoC, Port);
+			pPrt->PState = (RstMode == SK_SOFT_RST) ? SK_PRT_STOP :
+				SK_PRT_RESET;
 		}
 		else {
-			SkMacHardRst(pAC, IoC, Port);
+			/* Reset the MAC depending on the RstMode */
+			if (RstMode == SK_SOFT_RST) {
+				SkMacSoftRst(pAC, IoC, Port);
+			}
+			else {
+				SkMacHardRst(pAC, IoC, Port);
+			}
 		}
- 		
+
 		/* Disable Force Sync bit and Enable Alloc bit */
 		SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
 			TXA_DIS_FSYNC | TXA_DIS_ALLOC | TXA_STOP_RC);
-		
+
 		/* Stop Interval Timer and Limit Counter of Tx Arbiter */
 		SK_OUT32(IoC, MR_ADDR(Port, TXA_ITI_INI), 0L);
 		SK_OUT32(IoC, MR_ADDR(Port, TXA_LIM_INI), 0L);
 
 		/* Perform a local reset of the port's Tx path */
+		if (CHIP_ID_YUKON_2(pAC)) {
+			/* Reset the PCI FIFO of the async Tx queue */
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR),
+				BMU_RST_SET | BMU_FIFO_RST);
+			/* Reset the PCI FIFO of the sync Tx queue */
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR),
+				BMU_RST_SET | BMU_FIFO_RST);
+			/* Reset the Tx prefetch units */
+			SK_OUT32(IoC, Y2_PREF_Q_ADDR(pPrt->PXaQOff, PREF_UNIT_CTRL_REG),
+				PREF_UNIT_RST_SET);
+			SK_OUT32(IoC, Y2_PREF_Q_ADDR(pPrt->PXsQOff, PREF_UNIT_CTRL_REG),
+				PREF_UNIT_RST_SET);
+		}
+		else {
+			/* Reset the PCI FIFO of the async Tx queue */
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_SET_RESET);
+			/* Reset the PCI FIFO of the sync Tx queue */
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_SET_RESET);
+		}
 
-		/* Reset the PCI FIFO of the async Tx queue */
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_SET_RESET);
-		/* Reset the PCI FIFO of the sync Tx queue */
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_SET_RESET);
 		/* Reset the RAM Buffer async Tx queue */
 		SK_OUT8(IoC, RB_ADDR(pPrt->PXaQOff, RB_CTRL), RB_RST_SET);
 		/* Reset the RAM Buffer sync Tx queue */
 		SK_OUT8(IoC, RB_ADDR(pPrt->PXsQOff, RB_CTRL), RB_RST_SET);
-		
+
 		/* Reset Tx MAC FIFO */
 #ifdef GENESIS
 		if (pAC->GIni.GIGenesis) {
 			/* Note: MFF_RST_SET does NOT reset the XMAC ! */
@@ -1270,73 +1528,116 @@ int		RstMode)/* Reset Mode (SK_SOFT_RST,
 			/* Link LED is switched off by the RLMT and the Diag itself */
 			SkGeXmitLED(pAC, IoC, MR_ADDR(Port, TX_LED_INI), SK_LED_DIS);
 		}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
-		if (pAC->GIni.GIYukon) {
-			/* Reset TX MAC FIFO */
+		if (pAC->GIni.GIYukon && !pAC->GIni.GIAsfEnabled) {
+			/* Reset Tx MAC FIFO */
 			SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U8)GMF_RST_SET);
 		}
+
+		/* set Pause Off */
+		SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_PAUSE_OFF);
 #endif /* YUKON */
 	}
 
 	if ((Dir & SK_STOP_RX) != 0) {
-		/*
-		 * The RX Stop Command will not terminate if no buffers
-		 * are queued in the RxD ring. But it will always reach
-		 * the Idle state. Therefore we can use this feature to
-		 * stop the transfer of received packets.
-		 */
-		/* stop the port's receive queue */
-		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_STOP);
 		
-		i = 100;
-		do {
+		if (CHIP_ID_YUKON_2(pAC)) {
 			/*
-			 * Clear packet arbiter timeout to make sure
-			 * this loop will terminate
+			 * The RX Stop command will not work for Yukon-2 if the BMU does not
+			 * reach the end of packet and since we can't make sure that we have
+			 * incoming data, we must reset the BMU while it is not during a DMA
+			 * transfer. Since it is possible that the RX path is still active,
+			 * the RX RAM buffer will be stopped first, so any possible incoming
+			 * data will not trigger a DMA. After the RAM buffer is stopped, the
+			 * BMU is polled until any DMA in progress is ended and only then it
+			 * will be reset.
 			 */
-			SK_OUT16(IoC, B3_PA_CTRL, (SK_U16)((Port == MAC_1) ?
-				PA_CLR_TO_RX1 : PA_CLR_TO_RX2));
 
-			DWord = TestStopBit(pAC, IoC, pPrt->PRxQOff);
+			/* Disable the RAM Buffer receive queue */
+			SK_OUT8(IoC, RB_ADDR(pPrt->PRxQOff, RB_CTRL), RB_DIS_OP_MD);
+
+			i = 0xffff;
+			while (--i) {
+				SK_IN8(IoC, RB_ADDR(pPrt->PRxQOff, Q_RSL), &rsl);
+				SK_IN8(IoC, RB_ADDR(pPrt->PRxQOff, Q_RL), &rl);
+				
+				if (rsl == rl) {
+					break;
+				}
+			}
 
-			/* timeout if i==0 (bug fix for #10748) */
-			if (--i == 0) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_HWI_E024,
-					SKERR_HWI_E024MSG);
-				break;
-			}
 			/*
-			 * because of the ASIC problem report entry from 21.08.98
-			 * it is required to wait until CSR_STOP is reset and
-			 * CSR_SV_IDLE is set.
+			 * If the rx side is blocked the above loop
+			 * cannot terminate. But, if there was any traffic
+			 * it should be terminated, now. However, stop the
+			 * RX BMU and prefetch unit!
 			 */
-		} while ((DWord & (CSR_STOP | CSR_SV_IDLE)) != CSR_SV_IDLE);
+			SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR),
+				BMU_RST_SET | BMU_FIFO_RST);
+			/* reset the Rx prefetch unit */
+			SK_OUT32(IoC, Y2_PREF_Q_ADDR(pPrt->PRxQOff, PREF_UNIT_CTRL_REG),
+				PREF_UNIT_RST_SET);
+		}
+		else {
+			/*
+			 * The RX Stop Command will not terminate if no buffers
+			 * are queued in the RxD ring. But it will always reach
+			 * the Idle state. Therefore we can use this feature to
+			 * stop the transfer of received packets.
+			 */
+			/* stop the port's receive queue */
+			SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CsrStop);
+
+			i = 100;
+			do {
+#ifdef GENESIS
+				if (pAC->GIni.GIGenesis) {
+					/* Clear Rx packet arbiter timeout IRQ */
+					SK_OUT16(IoC, B3_PA_CTRL, (SK_U16)((Port == MAC_1) ?
+						PA_CLR_TO_RX1 : PA_CLR_TO_RX2));
+				}
+#endif /* GENESIS */
 
-		/* The path data transfer activity is fully stopped now */
+				RxCsr = TestStopBit(pAC, IoC, pPrt->PRxQOff);
 
-		/* Perform a local reset of the port's Rx path */
+				/* timeout if i==0 (bug fix for #10748) */
+				if (--i == 0) {
+					SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_HWI_E024,
+						SKERR_HWI_E024MSG);
+					break;
+				}
+			/*
+			 * Because of the ASIC problem report entry from 21.08.1998 it is
+			 * required to wait until CSR_STOP is reset and CSR_SV_IDLE is set.
+			 * (valid for GENESIS only)
+			 */
+			} while ((RxCsr & CsrTest) != CsrIdle);
+			/* The path data transfer activity is fully stopped now */
+
+			/* Perform a local reset of the port's Rx path */
+			/*	Reset the PCI FIFO of the Rx queue */
+			SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_SET_RESET);
+		}
 
-		 /*	Reset the PCI FIFO of the Rx queue */
-		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_SET_RESET);
 		/* Reset the RAM Buffer receive queue */
 		SK_OUT8(IoC, RB_ADDR(pPrt->PRxQOff, RB_CTRL), RB_RST_SET);
 
 		/* Reset Rx MAC FIFO */
 #ifdef GENESIS
 		if (pAC->GIni.GIGenesis) {
-			
+
 			SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_RST_SET);
 
 			/* switch Rx LED off, stop the LED counter */
 			SkGeXmitLED(pAC, IoC, MR_ADDR(Port, RX_LED_INI), SK_LED_DIS);
 		}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
-		if (pAC->GIni.GIYukon) {
+		if (pAC->GIni.GIYukon && !pAC->GIni.GIAsfEnabled) {
 			/* Reset Rx MAC FIFO */
 			SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_RST_SET);
 		}
 #endif /* YUKON */
@@ -1354,10 +1655,10 @@ int		RstMode)/* Reset Mode (SK_SOFT_RST,
  * Returns:
  *	nothing
  */
 static void SkGeInit0(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC)		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
 {
 	int i;
 	SK_GEPORT *pPrt;
 
@@ -1398,20 +1699,26 @@ SK_IOC	IoC)		/* IO context */
 		pPrt->PMacColThres = TX_COL_DEF;
 		pPrt->PMacJamLen = TX_JAM_LEN_DEF;
 		pPrt->PMacJamIpgVal	= TX_JAM_IPG_DEF;
 		pPrt->PMacJamIpgData = TX_IPG_JAM_DEF;
+		pPrt->PMacDataBlind = DATA_BLIND_DEF;
 		pPrt->PMacIpgData = IPG_DATA_DEF;
 		pPrt->PMacLimit4 = SK_FALSE;
 	}
 
 	pAC->GIni.GIPortUsage = SK_RED_LINK;
 	pAC->GIni.GILedBlinkCtrl = (SK_U16)OemConfig.Value;
-	pAC->GIni.GIValIrqMask = IS_ALL_MSK;
+	pAC->GIni.GIChipCap = 0;
+
+	for (i = 0; i < 4; i++) {
+		pAC->GIni.HwF.Features[i]= 0x00000000;
+		pAC->GIni.HwF.OnMask[i]	 = 0x00000000;
+		pAC->GIni.HwF.OffMask[i] = 0x00000000;
+	}
 
 }	/* SkGeInit0*/
 
 #ifdef SK_PCI_RESET
-
 /******************************************************************************
  *
  *	SkGePciReset() - Reset PCI interface
  *
@@ -1425,10 +1732,10 @@ SK_IOC	IoC)		/* IO context */
  *	0:	Success.
  *	1:	Power state could not be changed to 3.
  */
 static int SkGePciReset(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC)		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
 {
 	int		i;
 	SK_U16	PmCtlSts;
 	SK_U32	Bp1;
@@ -1449,9 +1756,9 @@ SK_IOC	IoC)		/* IO context */
 
 	/* We know the RAM Interface Arbiter is enabled. */
 	SkPciWriteCfgWord(pAC, PCI_PM_CTL_STS, PCI_PM_STATE_D3);
 	SkPciReadCfgWord(pAC, PCI_PM_CTL_STS, &PmCtlSts);
-	
+
 	if ((PmCtlSts & PCI_PM_STATE_MSK) != PCI_PM_STATE_D3) {
 		return(1);
 	}
 
@@ -1459,22 +1766,35 @@ SK_IOC	IoC)		/* IO context */
 	SkPciWriteCfgWord(pAC, PCI_PM_CTL_STS, PCI_PM_STATE_D0);
 
 	/* Check for D0 state. */
 	SkPciReadCfgWord(pAC, PCI_PM_CTL_STS, &PmCtlSts);
-	
+
 	if ((PmCtlSts & PCI_PM_STATE_MSK) != PCI_PM_STATE_D0) {
 		return(1);
 	}
 
 	/* Check PCI Config Registers. */
 	SkPciReadCfgWord(pAC, PCI_COMMAND, &PciCmd);
 	SkPciReadCfgByte(pAC, PCI_CACHE_LSZ, &Cls);
 	SkPciReadCfgDWord(pAC, PCI_BASE_1ST, &Bp1);
-	SkPciReadCfgDWord(pAC, PCI_BASE_2ND, &Bp2);
+
+	/*
+	 * Compute the location in PCI config space of BAR2
+	 * relativ to the location of BAR1
+	 */
+	if ((Bp1 & PCI_MEM_TYP_MSK) == PCI_MEM64BIT) {
+		/* BAR1 is 64 bits wide */
+		i = 8;
+	}
+	else {
+		i = 4;
+	}
+
+	SkPciReadCfgDWord(pAC, PCI_BASE_1ST + i, &Bp2);
 	SkPciReadCfgByte(pAC, PCI_LAT_TIM, &Lat);
-	
-	if (PciCmd != 0 || Cls != (SK_U8)0 || Lat != (SK_U8)0 ||
-		(Bp1 & 0xfffffff0L) != 0 || Bp2 != 1) {
+
+	if (PciCmd != 0 || Cls != 0 || (Bp1 & 0xfffffff0L) != 0 || Bp2 != 1 ||
+		Lat != 0) {
 		return(1);
 	}
 
 	/* Restore PCI Config Space. */
@@ -1483,11 +1803,62 @@ SK_IOC	IoC)		/* IO context */
 	}
 
 	return(0);
 }	/* SkGePciReset */
-
 #endif /* SK_PCI_RESET */
 
+
+/******************************************************************************
+ *
+ *	SkGeSetUpSupFeatures() - Collect Feature List for HW_FEATURE Macro
+ *
+ * Description:
+ *	This function collects the available features and required
+ *	deviation services of the Adapter and provides these
+ *	information in the GIHwF struct. Theses information is used as
+ *	default value and may be overritten by the driver using the
+ *	SET_HW_FEATURE_MASK() macro in its Init0 phase.
+ *
+ * Notice:
+ *	Unsing the On and Off mask: Never switch on the same bit in both
+ *	masks simultaneously. However, if doing the Off mask will win.
+ *	
+ * Returns:
+ *	nothing
+ */
+static void SkGeSetUpSupFeatures(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
+{
+	int i;
+
+	switch (pAC->GIni.GIChipId) {
+	case CHIP_ID_YUKON_EC:
+		if (pAC->GIni.GIChipRev == CHIP_REV_YU_EC_A1) {
+			/* A0/A1 */
+			pAC->GIni.HwF.Features[HW_DEV_LIST] = 	
+				HWF_WA_DEV_42  | HWF_WA_DEV_46 | HWF_WA_DEV_43_418 |
+				HWF_WA_DEV_420 | HWF_WA_DEV_423 |
+				HWF_WA_DEV_424 | HWF_WA_DEV_425 | HWF_WA_DEV_427 |
+				HWF_WA_DEV_428;
+		}
+		else if (pAC->GIni.GIChipRev == CHIP_REV_YU_EC_A2) {
+			/* A2 */
+			pAC->GIni.HwF.Features[HW_DEV_LIST] =
+				HWF_WA_DEV_424 | HWF_WA_DEV_425 | HWF_WA_DEV_427 |
+				HWF_WA_DEV_428;
+		}
+		break;
+	}
+
+	for (i = 0; i < 4; i++) {
+		pAC->GIni.HwF.Features[i] =
+			(pAC->GIni.HwF.Features[i] | pAC->GIni.HwF.OnMask[i]) &
+				~pAC->GIni.HwF.OffMask[i];
+	}
+}	/* SkGeSetUpSupFeatures */
+
+
 /******************************************************************************
  *
  *	SkGeInit1() - Level 1 Initialization
  *
@@ -1508,75 +1879,171 @@ SK_IOC	IoC)		/* IO context */
  *	5:	Unexpected PHY type detected
  *	6:	HW self test failed
  */
 static int SkGeInit1(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC)		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
 {
 	SK_U8	Byte;
 	SK_U16	Word;
-	SK_U16	CtrlStat;
+	SK_U32	CtrlStat;
+	SK_U32	VauxAvail;
 	SK_U32	DWord;
+	SK_GEPORT *pPrt;
 	int	RetVal;
 	int	i;
 
 	RetVal = 0;
 
-	/* save CLK_RUN bits (YUKON-Lite) */
-	SK_IN16(IoC, B0_CTST, &CtrlStat);
+	/* save CLK_RUN & ASF_ENABLE bits (YUKON-Lite, YUKON-EC) */
+	SK_IN32(IoC, B0_CTST, &CtrlStat);
 
 #ifdef SK_PCI_RESET
 	(void)SkGePciReset(pAC, IoC);
 #endif /* SK_PCI_RESET */
 
-	/* do the SW-reset */
-	SK_OUT8(IoC, B0_CTST, CS_RST_SET);
-
 	/* release the SW-reset */
+	/* Important: SW-reset has to be cleared here, to ensure
+	 * the CHIP_ID can be read IO-mapped based, too -
+	 * remember the RAP register can only be written if
+	 * SW-reset is cleared.
+	 */
 	SK_OUT8(IoC, B0_CTST, CS_RST_CLR);
 
+	/* read Chip Identification Number */
+	SK_IN8(IoC, B2_CHIP_ID, &Byte);
+	pAC->GIni.GIChipId = Byte;
+
+	pAC->GIni.GIAsfEnabled = SK_FALSE;
+
+	/* ASF support only for Yukon-2 */
+	if ((pAC->GIni.GIChipId >= CHIP_ID_YUKON_XL) &&
+		(pAC->GIni.GIChipId <= CHIP_ID_YUKON_EC)) {
+#ifdef SK_ASF
+		if ((CtrlStat & Y2_ASF_ENABLE) != 0) {
+			/* do the SW-reset only if ASF is not enabled */
+			pAC->GIni.GIAsfEnabled = SK_TRUE;
+		}
+#else /* !SK_ASF */
+		/* Put ASF system in reset state */
+		SK_OUT32(IoC, B28_Y2_ASF_STAT_CMD, Y2_ASF_RESET);
+
+		/* Disable ASF Unit */
+		SK_OUT16(IoC, B0_CTST, Y2_ASF_DISABLE);
+#endif /* !SK_ASF */
+	}
+
+	if (!pAC->GIni.GIAsfEnabled) {
+		/* do the SW-reset */
+		SK_OUT8(IoC, B0_CTST, CS_RST_SET);
+
+		/* release the SW-reset */
+		SK_OUT8(IoC, B0_CTST, CS_RST_CLR);
+	}
+
 	/* reset all error bits in the PCI STATUS register */
 	/*
 	 * Note: PCI Cfg cycles cannot be used, because they are not
 	 *		 available on some platforms after 'boot time'.
 	 */
-	SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
-	
+	SK_IN16(IoC, PCI_C(pAC, PCI_STATUS), &Word);
+
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-	SK_OUT16(IoC, PCI_C(PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
+	SK_OUT16(IoC, PCI_C(pAC, PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
 	/* release Master Reset */
 	SK_OUT8(IoC, B0_CTST, CS_MRST_CLR);
 
 #ifdef CLK_RUN
 	CtrlStat |= CS_CLK_RUN_ENA;
-#endif /* CLK_RUN */
 
 	/* restore CLK_RUN bits */
 	SK_OUT16(IoC, B0_CTST, (SK_U16)(CtrlStat &
 		(CS_CLK_RUN_HOT | CS_CLK_RUN_RST | CS_CLK_RUN_ENA)));
+#endif /* CLK_RUN */
+
+	if ((pAC->GIni.GIChipId >= CHIP_ID_YUKON_XL) &&
+		(pAC->GIni.GIChipId <= CHIP_ID_YUKON_FE)) {
+
+		pAC->GIni.GIYukon2 = SK_TRUE;
+		pAC->GIni.GIValIrqMask = Y2_IS_ALL_MSK;
+		pAC->GIni.GIValHwIrqMask = Y2_HWE_ALL_MSK;
+
+		VauxAvail = Y2_VAUX_AVAIL;
+
+		SK_IN32(IoC, PCI_C(pAC, PCI_OUR_STATUS), &DWord);
+
+		if ((DWord & PCI_OS_PCI_X) != 0) {
+			/* this is a PCI/PCIX bus */
+			pAC->GIni.GIPciBus = (SK_U8)(((DWord & PCI_OS_PCIX) != 0) ?
+				SK_PCIX_BUS : SK_PCI_BUS);
+		}
+		else {
+			/* this is a PEX bus */
+			pAC->GIni.GIPciBus = SK_PEX_BUS;
+
+			/* Clear any PEX errors */
+			SK_OUT32(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+			SK_OUT32(IoC, PCI_C(pAC, PEX_UNC_ERR_STAT), 0xffffffffUL);
+			SK_OUT32(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
+		}
+		/*
+		 * Yukon-2 chips family has a different way of providing
+		 * the number of MACs available
+		 */
+		SK_IN8(IoC, B2_Y2_HW_RES, &Byte);
+
+		pAC->GIni.GIMacsFound = ((Byte & CFG_DUAL_MAC) == CFG_DUAL_MAC) ? 2 : 1;
+
+		if (pAC->GIni.GIChipId == CHIP_ID_YUKON_EC) {
+			/*
+			 * OEM config value is overwritten and should not
+			 * be used for Yukon-2
+			 */
+			if ((Byte & CFG_LED_MODE_MSK) == CFG_LED_STD_ACT) {
+				pAC->GIni.GILedBlinkCtrl &= ~SK_ACT_LED_BLINK;
+			}
+			else {
+				pAC->GIni.GILedBlinkCtrl |= SK_ACT_LED_BLINK;
+			}
+		}
+#ifdef VCPU
+		/* temporary WA for reported number of links */
+		if (pAC->GIni.GIChipId == CHIP_ID_YUKON_XL) {
+
+			pAC->GIni.GIMacsFound = 2;
+		}
+#endif /* VCPU */
+
+		/* read Chip Revision */
+		SK_IN8(IoC, B2_MAC_CFG, &Byte);
+
+		pAC->GIni.GIChipCap = Byte & 0x0f;
+	}
+	else {
+		pAC->GIni.GIYukon2 = SK_FALSE;
+		pAC->GIni.GIValIrqMask = IS_ALL_MSK;
+		pAC->GIni.GIValHwIrqMask = 0;	/* not activated */
+
+		VauxAvail = CS_VAUX_AVAIL;
+
+		/* read number of MACs and Chip Revision */
+		SK_IN8(IoC, B2_MAC_CFG, &Byte);
+
+		pAC->GIni.GIMacsFound = (Byte & CFG_SNG_MAC) ? 1 : 2;
+	}
 
-	/* read Chip Identification Number */
-	SK_IN8(IoC, B2_CHIP_ID, &Byte);
-	pAC->GIni.GIChipId = Byte;
-	
-	/* read number of MACs */
-	SK_IN8(IoC, B2_MAC_CFG, &Byte);
-	pAC->GIni.GIMacsFound = (Byte & CFG_SNG_MAC) ? 1 : 2;
-	
 	/* get Chip Revision Number */
 	pAC->GIni.GIChipRev = (SK_U8)((Byte & CFG_CHIP_R_MSK) >> 4);
 
-	/* get diff. PCI parameters */
-	SK_IN16(IoC, B0_CTST, &CtrlStat);
-	
 	/* read the adapters RAM size */
 	SK_IN8(IoC, B2_E_0, &Byte);
-	
+
 	pAC->GIni.GIGenesis = SK_FALSE;
 	pAC->GIni.GIYukon = SK_FALSE;
 	pAC->GIni.GIYukonLite = SK_FALSE;
+	pAC->GIni.GIVauxAvail = SK_FALSE;
 
 #ifdef GENESIS
 	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
 
@@ -1590,130 +2057,159 @@ SK_IOC	IoC)		/* IO context */
 		else {
 			pAC->GIni.GIRamSize = (int)Byte * 512;
 			pAC->GIni.GIRamOffs = 0;
 		}
-		/* all GE adapters work with 53.125 MHz host clock */
+		/* all GENESIS adapters work with 53.125 MHz host clock */
 		pAC->GIni.GIHstClkFact = SK_FACT_53;
-		
+
 		/* set Descr. Poll Timer Init Value to 250 ms */
 		pAC->GIni.GIPollTimerVal =
 			SK_DPOLL_DEF * (SK_U32)pAC->GIni.GIHstClkFact / 100;
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIChipId != CHIP_ID_GENESIS) {
-		
+
 		pAC->GIni.GIYukon = SK_TRUE;
-		
+
 		pAC->GIni.GIRamSize = (Byte == (SK_U8)0) ? 128 : (int)Byte * 4;
-		
+
 		pAC->GIni.GIRamOffs = 0;
-		
-		/* WA for chip Rev. A */
+
+		/* WA for Yukon chip Rev. A */
 		pAC->GIni.GIWolOffs = (pAC->GIni.GIChipId == CHIP_ID_YUKON &&
 			pAC->GIni.GIChipRev == 0) ? WOL_REG_OFFS : 0;
-		
+
 		/* get PM Capabilities of PCI config space */
-		SK_IN16(IoC, PCI_C(PCI_PM_CAP_REG), &Word);
+		SK_IN16(IoC, PCI_C(pAC, PCI_PM_CAP_REG), &Word);
 
 		/* check if VAUX is available */
-		if (((CtrlStat & CS_VAUX_AVAIL) != 0) &&
+		if (((CtrlStat & VauxAvail) != 0) &&
 			/* check also if PME from D3cold is set */
 			((Word & PCI_PME_D3C_SUP) != 0)) {
 			/* set entry in GE init struct */
 			pAC->GIni.GIVauxAvail = SK_TRUE;
 		}
-		
-		if (pAC->GIni.GIChipId == CHIP_ID_YUKON_LITE) {
-			/* this is Rev. A1 */
-			pAC->GIni.GIYukonLite = SK_TRUE;
-		}
-		else {
-			/* save Flash-Address Register */
-			SK_IN32(IoC, B2_FAR, &DWord);
 
-			/* test Flash-Address Register */
-			SK_OUT8(IoC, B2_FAR + 3, 0xff);
-			SK_IN8(IoC, B2_FAR + 3, &Byte);
+		if (!CHIP_ID_YUKON_2(pAC)) {
 
-			if (Byte != 0) {
-				/* this is Rev. A0 */
+			if (pAC->GIni.GIChipId == CHIP_ID_YUKON_LITE) {
+				/* this is Rev. A1 */
 				pAC->GIni.GIYukonLite = SK_TRUE;
+			}
+			else {
+				/* save Flash-Address Register */
+				SK_IN32(IoC, B2_FAR, &DWord);
+
+				/* test Flash-Address Register */
+				SK_OUT8(IoC, B2_FAR + 3, 0xff);
+				SK_IN8(IoC, B2_FAR + 3, &Byte);
+
+				if (Byte != 0) {
+					/* this is Rev. A0 */
+					pAC->GIni.GIYukonLite = SK_TRUE;
 
-				/* restore Flash-Address Register */
-				SK_OUT32(IoC, B2_FAR, DWord);
+					/* restore Flash-Address Register */
+					SK_OUT32(IoC, B2_FAR, DWord);
+				}
 			}
 		}
 
 		/* switch power to VCC (WA for VAUX problem) */
 		SK_OUT8(IoC, B0_POWER_CTRL, (SK_U8)(PC_VAUX_ENA | PC_VCC_ENA |
 			PC_VAUX_OFF | PC_VCC_ON));
 
-		/* read the Interrupt source */
-		SK_IN32(IoC, B0_ISRC, &DWord);
-		
-		if ((DWord & IS_HW_ERR) != 0) {
-			/* read the HW Error Interrupt source */
-			SK_IN32(IoC, B0_HWE_ISRC, &DWord);
-			
-			if ((DWord & IS_IRQ_SENSOR) != 0) {
-				/* disable HW Error IRQ */
-				pAC->GIni.GIValIrqMask &= ~IS_HW_ERR;
+		if (!pAC->GIni.GIAsfEnabled) {
+
+			for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+				/* set GMAC Link Control reset */
+				SK_OUT16(IoC, MR_ADDR(i, GMAC_LINK_CTRL), GMLC_RST_SET);
+
+				/* clear GMAC Link Control reset */
+				SK_OUT16(IoC, MR_ADDR(i, GMAC_LINK_CTRL), GMLC_RST_CLR);
 			}
 		}
-		
-		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
-			/* set GMAC Link Control reset */
-			SK_OUT16(IoC, MR_ADDR(i, GMAC_LINK_CTRL), GMLC_RST_SET);
 
-			/* clear GMAC Link Control reset */
-			SK_OUT16(IoC, MR_ADDR(i, GMAC_LINK_CTRL), GMLC_RST_CLR);
+		if (CHIP_ID_YUKON_2(pAC)) {
+			/* In PCI-Express the PCI_CLK is substituted by the core clock */
+			if (pAC->GIni.GIPciBus == SK_PEX_BUS) {
+				/* PEX adapters work with 125 MHz host clock */
+				pAC->GIni.GIHstClkFact = SK_FACT_125;
+			}
+			else {
+				/* non-PEX adapters work with 156 MHz host clock */
+				pAC->GIni.GIHstClkFact = 2 * SK_FACT_78;
+			}
+
+			pAC->GIni.GIPollTimerVal =		/* ca. 75 us */
+				SK_DPOLL_DEF_Y2 * (SK_U32)pAC->GIni.GIHstClkFact / 100;
+		}
+		else {
+			/* YUKON adapters work with 78 MHz host clock */
+			pAC->GIni.GIHstClkFact = SK_FACT_78;
+
+			pAC->GIni.GIPollTimerVal = SK_DPOLL_MAX;	/* 215 ms */
+
+			/* read the Interrupt source */
+			SK_IN32(IoC, B0_ISRC, &DWord);
+
+			if ((DWord & IS_HW_ERR) != 0) {
+				/* read the HW Error Interrupt source */
+				SK_IN32(IoC, B0_HWE_ISRC, &DWord);
+
+				if ((DWord & IS_IRQ_SENSOR) != 0) {
+					/* disable HW Error IRQ */
+					pAC->GIni.GIValIrqMask &= ~IS_HW_ERR;
+				}
+			}
 		}
-		/* all YU chips work with 78.125 MHz host clock */
-		pAC->GIni.GIHstClkFact = SK_FACT_78;
-		
-		pAC->GIni.GIPollTimerVal = SK_DPOLL_MAX;	/* 215 ms */
 	}
 #endif /* YUKON */
 
 	/* check if 64-bit PCI Slot is present */
 	pAC->GIni.GIPciSlot64 = (SK_BOOL)((CtrlStat & CS_BUS_SLOT_SZ) != 0);
-	
+
 	/* check if 66 MHz PCI Clock is active */
 	pAC->GIni.GIPciClock66 = (SK_BOOL)((CtrlStat & CS_BUS_CLOCK) != 0);
 
 	/* read PCI HW Revision Id. */
-	SK_IN8(IoC, PCI_C(PCI_REV_ID), &Byte);
+	SK_IN8(IoC, PCI_C(pAC, PCI_REV_ID), &Byte);
 	pAC->GIni.GIPciHwRev = Byte;
 
+	/* read connector type */
+	SK_IN8(IoC, B2_CONN_TYP, &pAC->GIni.GIConTyp);
+
 	/* read the PMD type */
-	SK_IN8(IoC, B2_PMD_TYP, &Byte);
-	pAC->GIni.GICopperType = (SK_U8)(Byte == 'T');
+	SK_IN8(IoC, B2_PMD_TYP, &pAC->GIni.GIPmdTyp);
+
+	pAC->GIni.GICopperType = (SK_U8)(pAC->GIni.GIPmdTyp == 'T');
 
-	/* read the PHY type */
+	/* read the PHY type (Yukon and Genesis) */
 	SK_IN8(IoC, B2_E_1, &Byte);
 
 	Byte &= 0x0f;	/* the PHY type is stored in the lower nibble */
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
-		
+
+		pPrt = &pAC->GIni.GP[i];
+
 #ifdef GENESIS
 		if (pAC->GIni.GIGenesis) {
 			switch (Byte) {
 			case SK_PHY_XMAC:
-				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_XMAC;
+				pPrt->PhyAddr = PHY_ADDR_XMAC;
 				break;
 			case SK_PHY_BCOM:
-				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_BCOM;
-				pAC->GIni.GP[i].PMSCap = (SK_U8)(SK_MS_CAP_AUTO |
+				pPrt->PhyAddr = PHY_ADDR_BCOM;
+				pPrt->PMSCap = (SK_U8)(SK_MS_CAP_AUTO |
 					SK_MS_CAP_MASTER | SK_MS_CAP_SLAVE);
 				break;
 #ifdef OTHER_PHY
 			case SK_PHY_LONE:
-				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_LONE;
+				pPrt->PhyAddr = PHY_ADDR_LONE;
 				break;
 			case SK_PHY_NAT:
-				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_NAT;
+				pPrt->PhyAddr = PHY_ADDR_NAT;
 				break;
 #endif /* OTHER_PHY */
 			default:
 				/* ERROR: unexpected PHY type detected */
@@ -1721,67 +2217,99 @@ SK_IOC	IoC)		/* IO context */
 				break;
 			}
 		}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 		if (pAC->GIni.GIYukon) {
-			
-			if (Byte < (SK_U8)SK_PHY_MARV_COPPER) {
+
+			if ((Byte < (SK_U8)SK_PHY_MARV_COPPER) || CHIP_ID_YUKON_2(pAC)) {
 				/* if this field is not initialized */
 				Byte = (SK_U8)SK_PHY_MARV_COPPER;
-				
+
 				pAC->GIni.GICopperType = SK_TRUE;
 			}
-			
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_MARV;
-			
+
+			pPrt->PhyAddr = PHY_ADDR_MARV;
+
 			if (pAC->GIni.GICopperType) {
 
-				pAC->GIni.GP[i].PLinkSpeedCap = (SK_U8)(SK_LSPEED_CAP_AUTO |
-					SK_LSPEED_CAP_10MBPS | SK_LSPEED_CAP_100MBPS |
-					SK_LSPEED_CAP_1000MBPS);
-				
-				pAC->GIni.GP[i].PLinkSpeed = (SK_U8)SK_LSPEED_AUTO;
-				
-				pAC->GIni.GP[i].PMSCap = (SK_U8)(SK_MS_CAP_AUTO |
+				if (pAC->GIni.GIChipId == CHIP_ID_YUKON_FE ||
+					(pAC->GIni.GIChipId == CHIP_ID_YUKON_EC &&
+					pAC->GIni.GIChipCap == 2)) {
+
+					pPrt->PLinkSpeedCap = (SK_U8)(SK_LSPEED_CAP_100MBPS |
+						SK_LSPEED_CAP_10MBPS);
+
+					pAC->GIni.GIRamSize = 4;
+				}
+				else {
+					pPrt->PLinkSpeedCap = (SK_U8)(SK_LSPEED_CAP_1000MBPS |
+						SK_LSPEED_CAP_100MBPS | SK_LSPEED_CAP_10MBPS |
+						SK_LSPEED_CAP_AUTO);
+				}
+
+				pPrt->PLinkSpeed = (SK_U8)SK_LSPEED_AUTO;
+
+				pPrt->PMSCap = (SK_U8)(SK_MS_CAP_AUTO |
 					SK_MS_CAP_MASTER | SK_MS_CAP_SLAVE);
 			}
 			else {
 				Byte = (SK_U8)SK_PHY_MARV_FIBER;
 			}
 		}
+
+		/* Clear I2C IRQ */
+		SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
+
 #endif /* YUKON */
-		
-		pAC->GIni.GP[i].PhyType = (int)Byte;
-		
+
+		pPrt->PhyType = (int)Byte;
+
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
-			("PHY type: %d  PHY addr: %04x\n", Byte,
-			pAC->GIni.GP[i].PhyAddr));
+			("PHY type: %d  PHY addr: %04x\n",
+			Byte, pPrt->PhyAddr));
 	}
-	
+
 	/* get MAC Type & set function pointers dependent on */
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		pAC->GIni.GIMacType = SK_MAC_XMAC;
 
 		pAC->GIni.GIFunc.pFnMacUpdateStats	= SkXmUpdateStats;
 		pAC->GIni.GIFunc.pFnMacStatistic	= SkXmMacStatistic;
 		pAC->GIni.GIFunc.pFnMacResetCounter	= SkXmResetCounter;
 		pAC->GIni.GIFunc.pFnMacOverflow		= SkXmOverflowStatus;
+#ifdef SK_DIAG
+		pAC->GIni.GIFunc.pFnMacPhyRead		= SkXmPhyRead;
+		pAC->GIni.GIFunc.pFnMacPhyWrite		= SkXmPhyWrite;
+#else	/* SK_DIAG */
+		pAC->GIni.GIFunc.pSkGeSirqIsr		= SkGeYuSirqIsr;
+#endif /* !SK_DIAG */
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		pAC->GIni.GIMacType = SK_MAC_GMAC;
 
 		pAC->GIni.GIFunc.pFnMacUpdateStats	= SkGmUpdateStats;
 		pAC->GIni.GIFunc.pFnMacStatistic	= SkGmMacStatistic;
 		pAC->GIni.GIFunc.pFnMacResetCounter	= SkGmResetCounter;
 		pAC->GIni.GIFunc.pFnMacOverflow		= SkGmOverflowStatus;
+#ifdef SK_DIAG
+		pAC->GIni.GIFunc.pFnMacPhyRead		= SkGmPhyRead;
+		pAC->GIni.GIFunc.pFnMacPhyWrite		= SkGmPhyWrite;
+#else	/* SK_DIAG */
+		if (CHIP_ID_YUKON_2(pAC)) {
+			pAC->GIni.GIFunc.pSkGeSirqIsr	= SkYuk2SirqIsr;
+		}
+		else {
+			pAC->GIni.GIFunc.pSkGeSirqIsr	= SkGeYuSirqIsr;
+		}
+#endif /* !SK_DIAG */
 
 #ifdef SPECIAL_HANDLING
 		if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
 			/* check HW self test result */
@@ -1792,9 +2320,11 @@ SK_IOC	IoC)		/* IO context */
 		}
 #endif
 	}
 #endif /* YUKON */
-	
+
+	SkGeSetUpSupFeatures(pAC, IoC);
+
 	return(RetVal);
 }	/* SkGeInit1 */
 
 
@@ -1813,11 +2343,14 @@ SK_IOC	IoC)		/* IO context */
  * Returns:
  *	nothing
  */
 static void SkGeInit2(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC)		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
 {
+#ifdef YUKON
+	SK_U16	Word;
+#endif /* YUKON */
 #ifdef GENESIS
 	SK_U32	DWord;
 #endif /* GENESIS */
 	int		i;
@@ -1849,15 +2382,15 @@ SK_IOC	IoC)		/* IO context */
 
 		SkGeInitPktArb(pAC, IoC);
 	}
 #endif /* GENESIS */
-	
-#ifdef YUKON
+
+#ifdef xSK_DIAG
 	if (pAC->GIni.GIYukon) {
 		/* start Time Stamp Timer */
 		SK_OUT8(IoC, GMAC_TI_ST_CTRL, (SK_U8)GMT_ST_START);
 	}
-#endif /* YUKON */
+#endif /* SK_DIAG */
 
 	/* enable the Tx Arbiters */
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 		SK_OUT8(IoC, MR_ADDR(i, TXA_CTRL), TXA_ENA_ARB);
@@ -1865,10 +2398,36 @@ SK_IOC	IoC)		/* IO context */
 
 	/* enable the RAM Interface Arbiter */
 	SkGeInitRamIface(pAC, IoC);
 
+#ifdef YUKON
+	if (CHIP_ID_YUKON_2(pAC)) {
+
+		if (pAC->GIni.GIPciBus == SK_PEX_BUS) {
+
+			SK_IN16(IoC, PCI_C(pAC, PEX_DEV_CTRL), &Word);
+
+			/* change Max. Read Request Size to 2048 bytes */
+			Word &= ~PEX_DC_MAX_RRS_MSK;
+			Word |= PEX_DC_MAX_RD_RQ_SIZE(4);
+
+			SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+
+			SK_OUT16(IoC, PCI_C(pAC, PEX_DEV_CTRL), Word);
+
+			SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
+		}
+
+		/*
+		 * Writing the HW Error Mask Reg. will not generate an
+		 * IRQ as long as the B0_IMSK is not set by the driver.
+		 */
+		SK_OUT32(IoC, B0_HWE_IMSK, pAC->GIni.GIValHwIrqMask);
+	}
+#endif /* YUKON */
 }	/* SkGeInit2 */
 
+
 /******************************************************************************
  *
  *	SkGeInit() - Initialize the GE Adapter with the specified level.
  *
@@ -1888,25 +2447,25 @@ SK_IOC	IoC)		/* IO context */
  *			o return an error
  *				if Number of MACs > SK_MAX_MACS
  *
  *			After returning from Level 0 the adapter
- *			may be accessed with IO operations.
+ *			may be accessed with I/O operations.
  *
  *	Level	2:	start the Blink Source Counter
  *
  * Returns:
  *	0:	success
  *	1:	Number of MACs exceeds SK_MAX_MACS	(after level 1)
  *	2:	Adapter not present or not accessible
  *	3:	Illegal initialization level
- *	4:	Initialization Level 1 Call missing
+ *	4:	Initialization level 1 call missing
  *	5:	Unexpected PHY type detected
  *	6:	HW self test failed
  */
 int	SkGeInit(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-int		Level)		/* initialization level */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+int		Level)		/* Initialization Level */
 {
 	int		RetVal;		/* return value */
 	SK_U32	DWord;
 
@@ -1919,9 +2478,9 @@ int		Level)		/* initialization level */
 		/* Initialization Level 0 */
 		SkGeInit0(pAC, IoC);
 		pAC->GIni.GILevel = SK_INIT_DATA;
 		break;
-	
+
 	case SK_INIT_IO:
 		/* Initialization Level 1 */
 		RetVal = SkGeInit1(pAC, IoC);
 		if (RetVal != 0) {
@@ -1931,24 +2490,26 @@ int		Level)		/* initialization level */
 		/* check if the adapter seems to be accessible */
 		SK_OUT32(IoC, B2_IRQM_INI, SK_TEST_VAL);
 		SK_IN32(IoC, B2_IRQM_INI, &DWord);
 		SK_OUT32(IoC, B2_IRQM_INI, 0L);
-		
+
 		if (DWord != SK_TEST_VAL) {
 			RetVal = 2;
 			break;
 		}
 
+#ifdef DEBUG
 		/* check if the number of GIMacsFound matches SK_MAX_MACS */
 		if (pAC->GIni.GIMacsFound > SK_MAX_MACS) {
 			RetVal = 1;
 			break;
 		}
+#endif /* DEBUG */
 
 		/* Level 1 successfully passed */
 		pAC->GIni.GILevel = SK_INIT_IO;
 		break;
-	
+
 	case SK_INIT_RUN:
 		/* Initialization Level 2 */
 		if (pAC->GIni.GILevel != SK_INIT_IO) {
 #ifndef SK_DIAG
@@ -1956,14 +2517,15 @@ int		Level)		/* initialization level */
 #endif /* !SK_DIAG */
 			RetVal = 4;
 			break;
 		}
+
 		SkGeInit2(pAC, IoC);
 
 		/* Level 2 successfully passed */
 		pAC->GIni.GILevel = SK_INIT_RUN;
 		break;
-	
+
 	default:
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E003, SKERR_HWI_E003MSG);
 		RetVal = 3;
 		break;
@@ -1984,79 +2546,81 @@ int		Level)		/* initialization level */
  * Returns:
  *	nothing
  */
 void SkGeDeInit(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC)		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC)		/* I/O Context */
 {
 	int	i;
 	SK_U16	Word;
 
 #ifdef SK_PHY_LP_MODE
-	SK_U8	Byte;
 	SK_U16	PmCtlSts;
 #endif /* SK_PHY_LP_MODE */
 
 #if (!defined(SK_SLIM) && !defined(VCPU))
 	/* ensure I2C is ready */
 	SkI2cWaitIrq(pAC, IoC);
-#endif	
+#endif
 
-	/* stop all current transfer activity */
-	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
-		if (pAC->GIni.GP[i].PState != SK_PRT_STOP &&
-			pAC->GIni.GP[i].PState != SK_PRT_RESET) {
+	if (!pAC->GIni.GIAsfEnabled) {
+		/* stop all current transfer activity */
+		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+			if (pAC->GIni.GP[i].PState != SK_PRT_STOP &&
+				pAC->GIni.GP[i].PState != SK_PRT_RESET) {
 
-			SkGeStopPort(pAC, IoC, i, SK_STOP_ALL, SK_HARD_RST);
+				SkGeStopPort(pAC, IoC, i, SK_STOP_ALL, SK_HARD_RST);
+			}
 		}
 	}
 
-#ifdef SK_PHY_LP_MODE
-    /*
+#ifdef SK_PHY_LP_MODE_DEEP_SLEEP
+	/*
 	 * for power saving purposes within mobile environments
 	 * we set the PHY to coma mode and switch to D3 power state.
 	 */
 	if (pAC->GIni.GIYukonLite &&
 		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
 
 		/* for all ports switch PHY to coma mode */
 		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
-			
+
 			SkGmEnterLowPowerMode(pAC, IoC, i, PHY_PM_DEEP_SLEEP);
 		}
 
 		if (pAC->GIni.GIVauxAvail) {
 			/* switch power to VAUX */
-			Byte = PC_VAUX_ENA | PC_VCC_ENA | PC_VAUX_ON | PC_VCC_OFF;
-
-			SK_OUT8(IoC, B0_POWER_CTRL, Byte);
+			SK_OUT8(IoC, B0_POWER_CTRL, (SK_U8)(PC_VAUX_ENA | PC_VCC_ENA |
+				PC_VAUX_ON | PC_VCC_OFF));
 		}
-		
+
 		/* switch to D3 state */
-		SK_IN16(IoC, PCI_C(PCI_PM_CTL_STS), &PmCtlSts);
+		SK_IN16(IoC, PCI_C(pAC, PCI_PM_CTL_STS), &PmCtlSts);
 
 		PmCtlSts |= PCI_PM_STATE_D3;
 
 		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
 
-		SK_OUT16(IoC, PCI_C(PCI_PM_CTL_STS), PmCtlSts);
+		SK_OUT16(IoC, PCI_C(pAC, PCI_PM_CTL_STS), PmCtlSts);
 	}
-#endif /* SK_PHY_LP_MODE */
+#endif /* SK_PHY_LP_MODE_DEEP_SLEEP */
 
 	/* Reset all bits in the PCI STATUS register */
 	/*
 	 * Note: PCI Cfg cycles cannot be used, because they are not
 	 *	 available on some platforms after 'boot time'.
 	 */
-	SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
-	
+	SK_IN16(IoC, PCI_C(pAC, PCI_STATUS), &Word);
+
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-	SK_OUT16(IoC, PCI_C(PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
+	SK_OUT16(IoC, PCI_C(pAC, PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
-	/* do the reset, all LEDs are switched off now */
-	SK_OUT8(IoC, B0_CTST, CS_RST_SET);
-	
+	if (!pAC->GIni.GIAsfEnabled) {
+		/* do the reset, all LEDs are switched off now */
+		SK_OUT8(IoC, B0_CTST, CS_RST_SET);
+	}
+
 	pAC->GIni.GILevel = SK_INIT_DATA;
 }	/* SkGeDeInit */
 
 
@@ -2088,10 +2652,10 @@ SK_IOC	IoC)		/* IO context */
  *		An error log entry was generated.
  *	2:	The port has to be stopped before it can be initialized again.
  */
 int SkGeInitPort(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port to configure */
 {
 	SK_GEPORT *pPrt;
 
@@ -2100,10 +2664,10 @@ int		Port)		/* Port to configure */
 	if (SkGeCheckQSize(pAC, Port) != 0) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E004, SKERR_HWI_E004MSG);
 		return(1);
 	}
-	
-	if (pPrt->PState == SK_PRT_INIT || pPrt->PState == SK_PRT_RUN) {
+
+	if (pPrt->PState >= SK_PRT_INIT) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E005, SKERR_HWI_E005MSG);
 		return(2);
 	}
 
@@ -2118,34 +2682,35 @@ int		Port)		/* Port to configure */
 		 */
 		SkGeXmitLED(pAC, IoC, MR_ADDR(Port, TX_LED_INI), SK_LED_ENA);
 		SkGeXmitLED(pAC, IoC, MR_ADDR(Port, RX_LED_INI), SK_LED_ENA);
 		/* The Link LED is initialized by RLMT or Diagnostics itself */
-		
+
 		SkXmInitMac(pAC, IoC, Port);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
 
 		SkGmInitMac(pAC, IoC, Port);
 	}
 #endif /* YUKON */
-	
+
 	/* do NOT initialize the Link Sync Counter */
 
 	SkGeInitMacFifo(pAC, IoC, Port);
-	
+
 	SkGeInitRamBufs(pAC, IoC, Port);
-	
+
 	if (pPrt->PXSQSize != 0) {
 		/* enable Force Sync bit if synchronous queue available */
 		SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL), TXA_ENA_FSYNC);
 	}
-	
+
 	SkGeInitBmu(pAC, IoC, Port);
 
 	/* mark port as initialized */
 	pPrt->PState = SK_PRT_INIT;
 
 	return(0);
 }	/* SkGeInitPort */
+
Index: linux-2.6.8/drivers/net/sk98lin/skgemib.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skgemib.c
+++ linux-2.6.8/drivers/net/sk98lin/skgemib.c
@@ -1,10 +1,10 @@
 /*****************************************************************************
  *
  * Name:	skgemib.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.11 $
- * Date:	$Date: 2003/09/15 13:38:12 $
+ * Version:	$Revision: 2.6 $
+ * Date:	$Date: 2004/06/14 06:51:42 $
  * Purpose:	Private Network Management Interface Management Database
  *
  ****************************************************************************/
 
@@ -250,8 +250,170 @@ PNMI_STATIC const SK_PNMI_TAB_ENTRY IdTa
 		0,
 		0,
 		SK_PNMI_RW, DiagActions, 0},
 #endif /* SK_DIAG_SUPPORT */
+#ifdef SK_ASF
+    {OID_SKGE_ASF,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_STORE_CONFIG,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_ENA,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_RETRANS,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_RETRANS_INT,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_HB_ENA,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_HB_INT,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_WD_ENA,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_WD_TIME,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_IP_SOURCE,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_MAC_SOURCE,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_IP_DEST,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_MAC_DEST,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_COMMUNITY_NAME,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_RSP_ENA,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_RETRANS_COUNT_MIN,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_RETRANS_COUNT_MAX,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_RETRANS_INT_MIN,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_RETRANS_INT_MAX,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_HB_INT_MIN,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_HB_INT_MAX,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_WD_TIME_MIN,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_WD_TIME_MAX,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_HB_CAP,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_WD_TIMER_RES,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_GUID,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_KEY_OP,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_KEY_ADM,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_KEY_GEN,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_CAP,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_PAR_1,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+    {OID_SKGE_ASF_OVERALL_OID,
+        0,
+        0,
+        0,
+        SK_PNMI_RW, Asf, 0},
+#endif /* SK_ASF */
 	{OID_SKGE_MDB_VERSION,
 		1,
 		0,
 		SK_PNMI_MAI_OFF(MgmtDBVersion),
@@ -1072,8 +1234,13 @@ PNMI_STATIC const SK_PNMI_TAB_ENTRY IdTa
 		0,
 		0,
 		0,
 		SK_PNMI_RO, Vct, 0},
+	{OID_SKGE_VCT_CAPABILITIES,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Vct, 0},
 	{OID_SKGE_BOARDLEVEL,
 		0,
 		0,
 		0,
Index: linux-2.6.8/drivers/net/sk98lin/skgepnmi.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skgepnmi.c
+++ linux-2.6.8/drivers/net/sk98lin/skgepnmi.c
@@ -1,10 +1,10 @@
 /*****************************************************************************
  *
  * Name:	skgepnmi.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.111 $
- * Date:	$Date: 2003/09/15 13:35:35 $
+ * Project:	Gigabit Ethernet Adapters, PNMI-Module
+ * Version:	$Revision: 2.13 $
+ * Date:	$Date: 2004/06/14 06:50:30 $
  * Purpose:	Private Network Management Interface
  *
  ****************************************************************************/
 
@@ -21,13 +21,12 @@
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
-
-#ifndef _lint
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgepnmi.c,v 1.111 2003/09/15 13:35:35 tschilli Exp $ (C) Marvell.";
-#endif /* !_lint */
+	"@(#) $Id: skgepnmi.c,v 2.13 2004/06/14 06:50:30 tschilli Exp $ (C) Marvell.";
+#endif
 
 #include "h/skdrv1st.h"
 #include "h/sktypes.h"
 #include "h/xmac_ii.h"
@@ -37,14 +36,16 @@ static const char SysKonnectFileId[] =
 #include "h/skgesirq.h"
 #include "h/skcsum.h"
 #include "h/skvpd.h"
 #include "h/skgehw.h"
+#include "h/sky2le.h"
 #include "h/skgeinit.h"
 #include "h/skdrv2nd.h"
 #include "h/skgepnm2.h"
 #ifdef SK_POWER_MGMT
 #include "h/skgepmgt.h"
-#endif
+#endif /* SK_POWER_MGMT */
+
 /* defines *******************************************************************/
 
 #ifndef DEBUG
 #define PNMI_STATIC	static
@@ -71,9 +72,8 @@ int SkPnmiSetStruct(SK_AC *pAC, SK_IOC I
 int SkPnmiEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Param);
 int SkPnmiGenIoctl(SK_AC *pAC, SK_IOC IoC, void * pBuf,
 	unsigned int * pLen, SK_U32 NetIndex);
 
-
 /*
  * Private Function prototypes
  */
 
@@ -111,8 +111,14 @@ PNMI_STATIC int SirqUpdate(SK_AC *pAC, S
 PNMI_STATIC void VirtualConf(SK_AC *pAC, SK_IOC IoC, SK_U32 Id, char *pBuf);
 PNMI_STATIC int Vct(SK_AC *pAC, SK_IOC IoC, int Action, SK_U32 Id, char *pBuf,
 	unsigned int *pLen, SK_U32 Instance, unsigned int TableIndex, SK_U32 NetIndex);
 PNMI_STATIC void CheckVctStatus(SK_AC *, SK_IOC, char *, SK_U32, SK_U32);
+PNMI_STATIC void VctGetResults(SK_AC *, SK_IOC, SK_U32);
+#ifdef SK_ASF
+PNMI_STATIC int Asf(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+    char *pBuf, unsigned int *pLen, SK_U32 Instance,
+    unsigned int TableIndex, SK_U32 NetIndex);
+#endif /* SK_ASF */
 
 /*
  * Table to correlate OID with handler function and index to
  * hardware register stored in StatAddress if applicable.
@@ -352,30 +358,28 @@ PNMI_STATIC const SK_PNMI_STATADDR StatA
  * Returns:
  *	Always 0
  */
 int SkPnmiInit(
-SK_AC *pAC,		/* Pointer to adapter context */
-SK_IOC IoC,		/* IO context handle */
-int Level)		/* Initialization level */
+SK_AC	*pAC,		/* Pointer to adapter context */
+SK_IOC	IoC,		/* IO context handle */
+int		Level)		/* Initialization level */
 {
 	unsigned int	PortMax;	/* Number of ports */
 	unsigned int	PortIndex;	/* Current port index in loop */
-	SK_U16		Val16;		/* Multiple purpose 16 bit variable */
-	SK_U8		Val8;		/* Mulitple purpose 8 bit variable */
-	SK_EVPARA	EventParam;	/* Event struct for timer event */
-	SK_PNMI_VCT	*pVctBackupData;
-
+	SK_EVPARA		EventParam;	/* Event struct for timer event */
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 		("PNMI: SkPnmiInit: Called, level=%d\n", Level));
 
 	switch (Level) {
 
 	case SK_INIT_DATA:
 		SK_MEMSET((char *)&pAC->Pnmi, 0, sizeof(pAC->Pnmi));
+		
 		pAC->Pnmi.TrapBufFree = SK_PNMI_TRAP_QUEUE_LEN;
 		pAC->Pnmi.StartUpTime = SK_PNMI_HUNDREDS_SEC(SkOsGetTime(pAC));
 		pAC->Pnmi.RlmtChangeThreshold = SK_PNMI_DEF_RLMT_CHG_THRES;
+		
 		for (PortIndex = 0; PortIndex < SK_MAX_MACS; PortIndex ++) {
 
 			pAC->Pnmi.Port[PortIndex].ActiveFlag = SK_FALSE;
 			pAC->Pnmi.DualNetActiveFlag = SK_FALSE;
@@ -407,53 +411,44 @@ int Level)		/* Initialization level */
 #endif /* SK_PNMI_CHECK */
 		break;
 
 	case SK_INIT_IO:
-		/*
-		 * Reset MAC counters
-		 */
+
+		/* Reset MAC counters. */
 		PortMax = pAC->GIni.GIMacsFound;
 
 		for (PortIndex = 0; PortIndex < PortMax; PortIndex ++) {
 
 			pAC->GIni.GIFunc.pFnMacResetCounter(pAC, IoC, PortIndex);
 		}
-		
+
 		/* Initialize DSP variables for Vct() to 0xff => Never written! */		
 		for (PortIndex = 0; PortIndex < PortMax; PortIndex ++) {
 			pAC->GIni.GP[PortIndex].PCableLen = 0xff;
-			pVctBackupData = &pAC->Pnmi.VctBackup[PortIndex];
-			pVctBackupData->PCableLen = 0xff;
+			pAC->Pnmi.VctBackup[PortIndex].CableLen = 0xff;
 		}
-		
-		/*
-		 * Get pci bus speed
-		 */
-		SK_IN16(IoC, B0_CTST, &Val16);
-		if ((Val16 & CS_BUS_CLOCK) == 0) {
 
-			pAC->Pnmi.PciBusSpeed = 33;
+		/* Get PCI bus speed. */
+		if (pAC->GIni.GIPciClock66) {
+
+			pAC->Pnmi.PciBusSpeed = 66;
 		}
 		else {
-			pAC->Pnmi.PciBusSpeed = 66;
+			pAC->Pnmi.PciBusSpeed = 33;
 		}
 
-		/*
-		 * Get pci bus width
-		 */
-		SK_IN16(IoC, B0_CTST, &Val16);
-		if ((Val16 & CS_BUS_SLOT_SZ) == 0) {
+		/* Get PCI bus width. */
+		if (pAC->GIni.GIPciSlot64) {
 
-			pAC->Pnmi.PciBusWidth = 32;
+			pAC->Pnmi.PciBusWidth = 64;
 		}
 		else {
-			pAC->Pnmi.PciBusWidth = 64;
+			pAC->Pnmi.PciBusWidth = 32;
 		}
 
-		/*
-		 * Get chipset
-		 */
+		/* Get chipset. */
 		switch (pAC->GIni.GIChipId) {
+		
 		case CHIP_ID_GENESIS:
 			pAC->Pnmi.Chipset = SK_PNMI_CHIPSET_XMAC;
 			break;
 
@@ -464,68 +459,45 @@ int Level)		/* Initialization level */
 		default:
 			break;
 		}
 
-		/*
-		 * Get PMD and DeviceType
-		 */
-		SK_IN8(IoC, B2_PMD_TYP, &Val8);
-		switch (Val8) {
+		/* Get PMD and Device Type. */
+		switch (pAC->GIni.GIPmdTyp) {
+		
 		case 'S':
 			pAC->Pnmi.PMD = 3;
-			if (pAC->GIni.GIMacsFound > 1) {
-
-				pAC->Pnmi.DeviceType = 0x00020002;
-			}
-			else {
-				pAC->Pnmi.DeviceType = 0x00020001;
-			}
+			pAC->Pnmi.DeviceType = 0x00020001;
 			break;
 
 		case 'L':
 			pAC->Pnmi.PMD = 2;
-			if (pAC->GIni.GIMacsFound > 1) {
-
-				pAC->Pnmi.DeviceType = 0x00020004;
-			}
-			else {
-				pAC->Pnmi.DeviceType = 0x00020003;
-			}
+			pAC->Pnmi.DeviceType = 0x00020003;
 			break;
 
 		case 'C':
 			pAC->Pnmi.PMD = 4;
-			if (pAC->GIni.GIMacsFound > 1) {
-
-				pAC->Pnmi.DeviceType = 0x00020006;
-			}
-			else {
-				pAC->Pnmi.DeviceType = 0x00020005;
-			}
+			pAC->Pnmi.DeviceType = 0x00020005;
 			break;
 
 		case 'T':
 			pAC->Pnmi.PMD = 5;
-			if (pAC->GIni.GIMacsFound > 1) {
-
-				pAC->Pnmi.DeviceType = 0x00020008;
-			}
-			else {
-				pAC->Pnmi.DeviceType = 0x00020007;
-			}
+			pAC->Pnmi.DeviceType = 0x00020007;
 			break;
 
 		default :
 			pAC->Pnmi.PMD = 1;
 			pAC->Pnmi.DeviceType = 0;
 			break;
 		}
 
-		/*
-		 * Get connector
-		 */
-		SK_IN8(IoC, B2_CONN_TYP, &Val8);
-		switch (Val8) {
+		if (pAC->GIni.GIMacsFound > 1) {
+
+			pAC->Pnmi.DeviceType++;
+		}
+		
+		/* Get connector type. */
+		switch (pAC->GIni.GIConTyp) {
+		
 		case 'C':
 			pAC->Pnmi.Connector = 2;
 			break;
 
@@ -551,19 +523,19 @@ int Level)		/* Initialization level */
 		}
 		break;
 
 	case SK_INIT_RUN:
-		/*
-		 * Start timer for RLMT change counter
-		 */
+
+		/* Start timer for RLMT change counter. */
 		SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
+		
 		SkTimerStart(pAC, IoC, &pAC->Pnmi.RlmtChangeEstimate.EstTimer,
-			28125000, SKGE_PNMI, SK_PNMI_EVT_CHG_EST_TIMER,
+			SK_PNMI_EVT_TIMER_CHECK, SKGE_PNMI, SK_PNMI_EVT_CHG_EST_TIMER,
 			EventParam);
 		break;
 
 	default:
-		break; /* Nothing todo */
+		break; /* Nothing to do. */
 	}
 
 	return (0);
 }
@@ -641,9 +613,8 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 		("PNMI: SkPnmiPreSetVar: Called, Id=0x%x, BufLen=%d, Instance=%d, NetIndex=%d\n",
 			Id, *pLen, Instance, NetIndex));
 
-
 	return (PnmiVar(pAC, IoC, SK_PNMI_PRESET, Id, (char *)pBuf, pLen,
 		Instance, NetIndex));
 }
 
@@ -723,33 +694,29 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	SK_U32		Instance;
 	unsigned int	TmpLen;
 	char		KeyArr[SK_PNMI_VPD_ENTRIES][SK_PNMI_VPD_KEY_SIZE];
 
-
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 		("PNMI: SkPnmiGetStruct: Called, BufLen=%d, NetIndex=%d\n",
 			*pLen, NetIndex));
 
 	if (*pLen < SK_PNMI_STRUCT_SIZE) {
 
 		if (*pLen >= SK_PNMI_MIN_STRUCT_SIZE) {
 
-			SK_PNMI_SET_STAT(pBuf, SK_PNMI_ERR_TOO_SHORT,
-				(SK_U32)(-1));
+			SK_PNMI_SET_STAT(pBuf, SK_PNMI_ERR_TOO_SHORT, (SK_U32)(-1));
 		}
 
 		*pLen = SK_PNMI_STRUCT_SIZE;
 		return (SK_PNMI_ERR_TOO_SHORT);
 	}
 
-    /*
-     * Check NetIndex
-     */
+	/* Check NetIndex. */
 	if (NetIndex >= pAC->Rlmt.NumNets) {
 		return (SK_PNMI_ERR_UNKNOWN_NET);
 	}
 
-	/* Update statistic */
+	/* Update statistics. */
 	SK_PNMI_CHECKFLAGS("SkPnmiGetStruct: On call");
 
 	if ((Ret = MacUpdate(pAC, IoC, 0, pAC->GIni.GIMacsFound - 1)) !=
 		SK_PNMI_ERR_OK) {
@@ -772,17 +739,14 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = SK_PNMI_MIN_STRUCT_SIZE;
 		return (Ret);
 	}
 
-	/*
-	 * Increment semaphores to indicate that an update was
-	 * already done
-	 */
+	/* Increment semaphores to indicate that an update was already done. */
 	pAC->Pnmi.MacUpdatedFlag ++;
 	pAC->Pnmi.RlmtUpdatedFlag ++;
 	pAC->Pnmi.SirqUpdatedFlag ++;
 
-	/* Get vpd keys for instance calculation */
+	/* Get VPD keys for instance calculation. */
 	Ret = GetVpdKeyArr(pAC, IoC, &KeyArr[0][0], sizeof(KeyArr), &TmpLen);
 	if (Ret != SK_PNMI_ERR_OK) {
 
 		pAC->Pnmi.MacUpdatedFlag --;
@@ -794,15 +758,15 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = SK_PNMI_MIN_STRUCT_SIZE;
 		return (SK_PNMI_ERR_GENERAL);
 	}
 
-	/* Retrieve values */
+	/* Retrieve values. */
 	SK_MEMSET((char *)pBuf, 0, SK_PNMI_STRUCT_SIZE);
+	
 	for (TableIndex = 0; TableIndex < ID_TABLE_SIZE; TableIndex ++) {
 
 		InstanceNo = IdTable[TableIndex].InstanceNo;
-		for (InstanceCnt = 1; InstanceCnt <= InstanceNo;
-			InstanceCnt ++) {
+		for (InstanceCnt = 1; InstanceCnt <= InstanceNo; InstanceCnt ++) {
 
 			DstOffset = IdTable[TableIndex].Offset +
 				(InstanceCnt - 1) *
 				IdTable[TableIndex].StructSize;
@@ -997,9 +961,8 @@ SK_EVPARA Param)	/* Event dependent para
 {
 	unsigned int	PhysPortIndex;
     unsigned int	MaxNetNumber;
 	int			CounterIndex;
-	int			Ret;
 	SK_U16		MacStatus;
 	SK_U64		OverflowStatus;
 	SK_U64		Mask;
 	int			MacType;
@@ -1011,14 +974,9 @@ SK_EVPARA Param)	/* Event dependent para
 	SK_U64		OldestValue;
 	SK_U64		Delta;
 	SK_PNMI_ESTIMATE *pEst;
 	SK_U32		NetIndex;
-	SK_GEPORT	*pPrt;
-	SK_PNMI_VCT	*pVctBackupData;
 	SK_U32		RetCode;
-	int		i;
-	SK_U32		CableLength;
-
 
 #ifdef DEBUG
 	if (Event != SK_PNMI_EVT_XMAC_RESET) {
 
@@ -1047,11 +1005,9 @@ SK_EVPARA Param)	/* Event dependent para
 		}
 #endif /* DEBUG */
 		OverflowStatus = 0;
 
-		/*
-		 * Check which source caused an overflow interrupt.
-		 */
+		/* Check which source caused an overflow interrupt. */
 		if ((pAC->GIni.GIFunc.pFnMacOverflow(pAC, IoC, PhysPortIndex,
 				MacStatus, &OverflowStatus) != 0) ||
 			(OverflowStatus == 0)) {
 
@@ -1067,9 +1023,8 @@ SK_EVPARA Param)	/* Event dependent para
 			CounterIndex ++) {
 
 			Mask = (SK_U64)1 << CounterIndex;
 			if ((OverflowStatus & Mask) == 0) {
-
 				continue;
 			}
 
 			switch (StatOvrflwBit[CounterIndex][MacType]) {
@@ -1099,11 +1054,9 @@ SK_EVPARA Param)	/* Event dependent para
 			case SK_PNMI_HRX_OCTETLOW:
 			case SK_PNMI_HRX_IRLENGTH:
 			case SK_PNMI_HRX_RESERVED:
 			
-			/*
-			 * the following counters aren't be handled (id > 63)
-			 */
+			/* The following counters aren't be handled (id > 63). */
 			case SK_PNMI_HTX_SYNC:
 			case SK_PNMI_HTX_SYNC_OCTET:
 				break;
 
@@ -1188,9 +1141,9 @@ SK_EVPARA Param)	/* Event dependent para
 #ifdef DEBUG
 		if ((unsigned int)Param.Para64 >= (unsigned int)pAC->I2c.MaxSens) {
 
 			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
-				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_ERR_UPP parameter wrong, SensorIndex=%d\n",
+				("PNMI: ERR: SK_PNMI_EVT_SEN_ERR_UPP parameter wrong, SensorIndex=%d\n",
 				(unsigned int)Param.Para64));
 			return (0);
 		}
 #endif /* DEBUG */
@@ -1207,18 +1160,16 @@ SK_EVPARA Param)	/* Event dependent para
 
 	case SK_PNMI_EVT_CHG_EST_TIMER:
 		/*
 		 * Calculate port switch average on a per hour basis
-		 *   Time interval for check       : 28125 ms
+		 *   Time interval for check       : 28125 ms (SK_PNMI_EVT_TIMER_CHECK)
 		 *   Number of values for average  : 8
 		 *
 		 * Be careful in changing these values, on change check
 		 *   - typedef of SK_PNMI_ESTIMATE (Size of EstValue
 		 *     array one less than value number)
 		 *   - Timer initialization SkTimerStart() in SkPnmiInit
-		 *   - Delta value below must be multiplicated with
-		 *     power of 2
-		 *
+		 *   - Delta value below must be multiplicated with power of 2
 		 */
 		pEst = &pAC->Pnmi.RlmtChangeEstimate;
 		CounterIndex = pEst->EstValueIndex + 1;
 		if (CounterIndex == 7) {
@@ -1239,9 +1190,9 @@ SK_EVPARA Param)	/* Event dependent para
 
 			Delta = NewestValue - OldestValue;
 		}
 		else {
-			/* Overflow situation */
+			/* Overflow situation. */
 			Delta = (SK_U64)(0 - OldestValue) + NewestValue;
 		}
 
 		/*
@@ -1265,10 +1216,11 @@ SK_EVPARA Param)	/* Event dependent para
 			(void)SK_DRIVER_SENDEVENT(pAC, IoC);
 		}
 
 		SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
+		
 		SkTimerStart(pAC, IoC, &pAC->Pnmi.RlmtChangeEstimate.EstTimer,
-			28125000, SKGE_PNMI, SK_PNMI_EVT_CHG_EST_TIMER,
+			SK_PNMI_EVT_TIMER_CHECK, SKGE_PNMI, SK_PNMI_EVT_CHG_EST_TIMER,
 			EventParam);
 		break;
 
 	case SK_PNMI_EVT_CLEAR_COUNTER:
@@ -1310,31 +1262,27 @@ SK_EVPARA Param)	/* Event dependent para
 				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_XMAC_RESET parameter wrong, PhysPortIndex=%d\n",
 				(unsigned int)Param.Para64));
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
+
 		PhysPortIndex = (unsigned int)Param.Para64;
 
-		/*
-		 * Update XMAC statistic to get fresh values
-		 */
-		Ret = MacUpdate(pAC, IoC, 0, pAC->GIni.GIMacsFound - 1);
-		if (Ret != SK_PNMI_ERR_OK) {
+		/* Update XMAC statistic to get fresh values. */
+		if (MacUpdate(pAC, IoC, 0, pAC->GIni.GIMacsFound - 1) !=
+			SK_PNMI_ERR_OK) {
 
 			SK_PNMI_CHECKFLAGS("SkPnmiEvent: On return");
 			return (0);
 		}
-		/*
-		 * Increment semaphore to indicate that an update was
-		 * already done
-		 */
+
+		/* Increment semaphore to indicate that an update was already done. */
 		pAC->Pnmi.MacUpdatedFlag ++;
 
 		for (CounterIndex = 0; CounterIndex < SK_PNMI_MAX_IDX;
 			CounterIndex ++) {
 
 			if (!StatAddr[CounterIndex][MacType].GetOffset) {
-
 				continue;
 			}
 
 			pAC->Pnmi.Port[PhysPortIndex].CounterOffset[CounterIndex] =
@@ -1365,16 +1313,17 @@ SK_EVPARA Param)	/* Event dependent para
 		 */
 		QueueRlmtPortTrap(pAC, OID_SKGE_TRAP_RLMT_PORT_UP, PhysPortIndex);
 		(void)SK_DRIVER_SENDEVENT(pAC, IoC);
 
-		/* Bugfix for XMAC errata (#10620)*/
+		/* Bugfix for XMAC errata (#10620). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Add incremental difference to offset (#10620)*/
+			/* Add incremental difference to offset (#10620). */
 			(void)pAC->GIni.GIFunc.pFnMacStatistic(pAC, IoC, PhysPortIndex,
 				XM_RXE_SHT_ERR, &Val32);
 			
 			Value = (((SK_U64)pAC->Pnmi.Port[PhysPortIndex].
 				 CounterHigh[SK_PNMI_HRX_SHORTS] << 32) | (SK_U64)Val32);
+			
 			pAC->Pnmi.Port[PhysPortIndex].CounterOffset[SK_PNMI_HRX_SHORTS] +=
 				Value - pAC->Pnmi.Port[PhysPortIndex].RxShortZeroMark;
 		}
 		
@@ -1402,9 +1351,9 @@ SK_EVPARA Param)	/* Event dependent para
 		 */
 		QueueRlmtPortTrap(pAC, OID_SKGE_TRAP_RLMT_PORT_DOWN, PhysPortIndex);
 		(void)SK_DRIVER_SENDEVENT(pAC, IoC);
 
-		/* Bugfix #10620 - get zero level for incremental difference */
+		/* Bugfix #10620 - get zero level for incremental difference. */
 		if (MacType == SK_MAC_XMAC) {
 
 			(void)pAC->GIni.GIFunc.pFnMacStatistic(pAC, IoC, PhysPortIndex,
 				XM_RXE_SHT_ERR, &Val32);
@@ -1434,19 +1383,15 @@ SK_EVPARA Param)	/* Event dependent para
 				NetIndex));
 		}
 #endif /* DEBUG */
 
-		/*
-		 * For now, ignore event if NetIndex != 0.
-		 */
+		/* For now, ignore event if NetIndex != 0. */
 		if (Param.Para32[1] != 0) {
 
 			return (0);
 		}
 
-		/*
-		 * Nothing to do if port is already inactive
-		 */
+		/* Nothing to do if port is already inactive. */
 		if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
 
 			return (0);
 		}
@@ -1475,20 +1420,17 @@ SK_EVPARA Param)	/* Event dependent para
 		for (CounterIndex = 0; CounterIndex < SK_PNMI_MAX_IDX;
 			CounterIndex ++) {
 
 			if (!StatAddr[CounterIndex][MacType].GetOffset) {
-
 				continue;
 			}
 
 			Value = GetPhysStatVal(pAC, IoC, PhysPortIndex, CounterIndex);
 
 			pAC->Pnmi.VirtualCounterOffset[CounterIndex] += Value;
 		}
 
-		/*
-		 * Set port to inactive
-		 */
+		/* Set port to inactive. */
 		pAC->Pnmi.Port[PhysPortIndex].ActiveFlag = SK_FALSE;
 
 		pAC->Pnmi.MacUpdatedFlag --;
 		break;
@@ -1512,27 +1454,21 @@ SK_EVPARA Param)	/* Event dependent para
 				NetIndex));
 		}
 #endif /* DEBUG */
 
-		/*
-		 * For now, ignore event if NetIndex != 0.
-		 */
+		/* For now, ignore event if NetIndex != 0. */
 		if (Param.Para32[1] != 0) {
 
 			return (0);
 		}
 
-		/*
-		 * Nothing to do if port is already active
-		 */
+		/* Nothing to do if port is already inactive. */
 		if (pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
 
 			return (0);
 		}
 
-		/*
-		 * Statistic maintenance
-		 */
+		/* Statistic maintenance. */
 		pAC->Pnmi.RlmtChangeCts ++;
 		pAC->Pnmi.RlmtChangeTime = SK_PNMI_HUNDREDS_SEC(SkOsGetTime(pAC));
 
 		/*
@@ -1564,27 +1500,24 @@ SK_EVPARA Param)	/* Event dependent para
 		for (CounterIndex = 0; CounterIndex < SK_PNMI_MAX_IDX;
 			CounterIndex ++) {
 
 			if (!StatAddr[CounterIndex][MacType].GetOffset) {
-
 				continue;
 			}
 
 			Value = GetPhysStatVal(pAC, IoC, PhysPortIndex, CounterIndex);
 
 			pAC->Pnmi.VirtualCounterOffset[CounterIndex] -= Value;
 		}
 
-		/* Set port to active */
+		/* Set port to active. */
 		pAC->Pnmi.Port[PhysPortIndex].ActiveFlag = SK_TRUE;
 
 		pAC->Pnmi.MacUpdatedFlag --;
 		break;
 
 	case SK_PNMI_EVT_RLMT_SEGMENTATION:
-		/*
-		 * Para.Para32[0] contains the NetIndex.
-		 */
+		/* Para.Para32[0] contains the NetIndex. */
 
 		/*
 		 * Store a trap message in the trap buffer and generate an event for
 		 * user space applications with the SK_DRIVER_SENDEVENT macro.
@@ -1597,73 +1530,55 @@ SK_EVPARA Param)	/* Event dependent para
 		/*
 		 *  Param.Para32[0] contains the number of Nets.
 		 *  Param.Para32[1] is reserved, contains -1.
 		 */
-	    /*
-    	 * Check number of nets
-		 */
+	    /* Check number of nets. */
 		MaxNetNumber = pAC->GIni.GIMacsFound;
-		if (((unsigned int)Param.Para32[0] < 1)
-			|| ((unsigned int)Param.Para32[0] > MaxNetNumber)) {
+		
+		if (((unsigned int)Param.Para32[0] < 1) ||
+			((unsigned int)Param.Para32[0] > MaxNetNumber)) {
+			
 			return (SK_PNMI_ERR_UNKNOWN_NET);
 		}
 
-        if ((unsigned int)Param.Para32[0] == 1) { /* single net mode */
+        if ((unsigned int)Param.Para32[0] == 1) { /* SingleNet mode. */
         	pAC->Pnmi.DualNetActiveFlag = SK_FALSE;
         }
-        else { /* dual net mode */
+        else { /* DualNet mode. */
         	pAC->Pnmi.DualNetActiveFlag = SK_TRUE;
         }
         break;
 
     case SK_PNMI_EVT_VCT_RESET:
 		PhysPortIndex = Param.Para32[0];
-		pPrt = &pAC->GIni.GP[PhysPortIndex];
-		pVctBackupData = &pAC->Pnmi.VctBackup[PhysPortIndex];
 		
 		if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING) {
+			
 			RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_FALSE);
+			
 			if (RetCode == 2) {
 				/*
 				 * VCT test is still running.
 				 * Start VCT timer counter again.
 				 */
-				SK_MEMSET((char *) &Param, 0, sizeof(Param));
+				SK_MEMSET((char *)&Param, 0, sizeof(Param));
+				
 				Param.Para32[0] = PhysPortIndex;
 				Param.Para32[1] = -1;
-				SkTimerStart(pAC, IoC,
-					&pAC->Pnmi.VctTimeout[PhysPortIndex].VctTimer,
-				4000000, SKGE_PNMI, SK_PNMI_EVT_VCT_RESET, Param);
+				
+				SkTimerStart(pAC, IoC, &pAC->Pnmi.VctTimeout[PhysPortIndex],
+					SK_PNMI_VCT_TIMER_CHECK, SKGE_PNMI, SK_PNMI_EVT_VCT_RESET, Param);
+				
 				break;
 			}
-			pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_PENDING;
-			pAC->Pnmi.VctStatus[PhysPortIndex] |=
-				(SK_PNMI_VCT_NEW_VCT_DATA | SK_PNMI_VCT_TEST_DONE);
 			
-			/* Copy results for later use to PNMI struct. */
-			for (i = 0; i < 4; i++)  {
-				if (pPrt->PMdiPairSts[i] == SK_PNMI_VCT_NORMAL_CABLE) {
-					if ((pPrt->PMdiPairLen[i] > 35) &&
-						(pPrt->PMdiPairLen[i] < 0xff)) {
-						pPrt->PMdiPairSts[i] = SK_PNMI_VCT_IMPEDANCE_MISMATCH;
-					}
-				}
-				if ((pPrt->PMdiPairLen[i] > 35) &&
-					(pPrt->PMdiPairLen[i] != 0xff)) {
-					CableLength = 1000 *
-						(((175 * pPrt->PMdiPairLen[i]) / 210) - 28);
-				}
-				else {
-					CableLength = 0;
-				}
-				pVctBackupData->PMdiPairLen[i] = CableLength;
-				pVctBackupData->PMdiPairSts[i] = pPrt->PMdiPairSts[i];
-			}
+			VctGetResults(pAC, IoC, PhysPortIndex);
 			
-			Param.Para32[0] = PhysPortIndex;
-			Param.Para32[1] = -1;
-			SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_RESET, Param);
-			SkEventDispatcher(pAC, IoC);
+			EventParam.Para32[0] = PhysPortIndex;
+			EventParam.Para32[1] = -1;
+			SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_RESET, EventParam);
+
+			/* SkEventDispatcher(pAC, IoC); */
 		}
 		
 		break;
 
@@ -1709,16 +1624,15 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 {
 	unsigned int	TableIndex;
 	int		Ret;
 
-
 	if ((TableIndex = LookupId(Id)) == (unsigned int)(-1)) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_OID);
 	}
 	
-    /* Check NetIndex */
+    /* Check NetIndex. */
 	if (NetIndex >= pAC->Rlmt.NumNets) {
 		return (SK_PNMI_ERR_UNKNOWN_NET);
 	}
 
@@ -1766,24 +1680,22 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	unsigned int	InstanceCnt;
 	SK_U32		Instance;
 	SK_U32		Id;
 
-
-	/* Check if the passed buffer has the right size */
+	/* Check if the passed buffer has the right size. */
 	if (*pLen < SK_PNMI_STRUCT_SIZE) {
 
-		/* Check if we can return the error within the buffer */
+		/* Check if we can return the error within the buffer. */
 		if (*pLen >= SK_PNMI_MIN_STRUCT_SIZE) {
 
-			SK_PNMI_SET_STAT(pBuf, SK_PNMI_ERR_TOO_SHORT,
-				(SK_U32)(-1));
+			SK_PNMI_SET_STAT(pBuf, SK_PNMI_ERR_TOO_SHORT, (SK_U32)(-1));
 		}
 
 		*pLen = SK_PNMI_STRUCT_SIZE;
 		return (SK_PNMI_ERR_TOO_SHORT);
 	}
 	
-    /* Check NetIndex */
+    /* Check NetIndex. */
 	if (NetIndex >= pAC->Rlmt.NumNets) {
 		return (SK_PNMI_ERR_UNKNOWN_NET);
 	}
 	
@@ -1809,14 +1721,13 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 	pAC->Pnmi.RlmtUpdatedFlag ++;
 	pAC->Pnmi.SirqUpdatedFlag ++;
 
-	/* Preset/Set values */
+	/* PRESET/SET values. */
 	for (TableIndex = 0; TableIndex < ID_TABLE_SIZE; TableIndex ++) {
 
 		if ((IdTable[TableIndex].Access != SK_PNMI_RW) &&
 			(IdTable[TableIndex].Access != SK_PNMI_WO)) {
-
 			continue;
 		}
 
 		InstanceNo = IdTable[TableIndex].InstanceNo;
@@ -1825,10 +1736,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		for (InstanceCnt = 1; InstanceCnt <= InstanceNo;
 			InstanceCnt ++) {
 
 			DstOffset = IdTable[TableIndex].Offset +
-				(InstanceCnt - 1) *
-				IdTable[TableIndex].StructSize;
+				(InstanceCnt - 1) * IdTable[TableIndex].StructSize;
 
 			/*
 			 * Because VPD multiple instance variables are
 			 * not setable we do not need to evaluate VPD
@@ -1836,11 +1746,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			 * calculation in SkPnmiGetStruct().
 			 */
 			Instance = (SK_U32)InstanceCnt;
 
-			/*
-			 * Evaluate needed buffer length
-			 */
+			/* Evaluate needed buffer length. */
 			Len = 0;
 			Ret = IdTable[TableIndex].Func(pAC, IoC,
 				SK_PNMI_GET, IdTable[TableIndex].Id,
 				NULL, &Len, Instance, TableIndex, NetIndex);
@@ -1854,10 +1762,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				pAC->Pnmi.RlmtUpdatedFlag --;
 				pAC->Pnmi.SirqUpdatedFlag --;
 
 				SK_PNMI_CHECKFLAGS("PnmiStruct: On return");
-				SK_PNMI_SET_STAT(pBuf,
-					SK_PNMI_ERR_GENERAL, DstOffset);
+				SK_PNMI_SET_STAT(pBuf, SK_PNMI_ERR_GENERAL, DstOffset);
 				*pLen = SK_PNMI_MIN_STRUCT_SIZE;
 				return (SK_PNMI_ERR_GENERAL);
 			}
 			if (Id == OID_SKGE_VPD_ACTION) {
@@ -1877,9 +1784,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					break;
 				}
 			}
 
-			/* Call the OID handler function */
+			/* Call the OID handler function. */
 			Ret = IdTable[TableIndex].Func(pAC, IoC, Action,
 				IdTable[TableIndex].Id, pBuf + DstOffset,
 				&Len, Instance, TableIndex, NetIndex);
 
@@ -1888,10 +1795,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				pAC->Pnmi.RlmtUpdatedFlag --;
 				pAC->Pnmi.SirqUpdatedFlag --;
 
 				SK_PNMI_CHECKFLAGS("PnmiStruct: On return");
-				SK_PNMI_SET_STAT(pBuf, SK_PNMI_ERR_BAD_VALUE,
-					DstOffset);
+				SK_PNMI_SET_STAT(pBuf, SK_PNMI_ERR_BAD_VALUE, DstOffset);
 				*pLen = SK_PNMI_MIN_STRUCT_SIZE;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
 		}
@@ -1923,9 +1829,9 @@ SK_U32 Id)		/* Object identifier to be s
 	for (i = 0; i < ID_TABLE_SIZE; i++) {
 
 		if (IdTable[i].Id == Id) {
 
-			return i;
+			return (i);
 		}
 	}
 
 	return (-1);
@@ -1964,18 +1870,15 @@ unsigned int TableIndex, /* Index to the
 SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	if (Id != OID_SKGE_ALL_DATA) {
 
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR003,
-			SK_PNMI_ERR003MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR003, SK_PNMI_ERR003MSG);
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_GENERAL);
 	}
 
-	/*
-	 * Check instance. We only handle single instance variables
-	 */
+	/* Check instance. We only handle single instance variables. */
 	if (Instance != (SK_U32)(-1) && Instance != 1) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_INST);
@@ -2032,12 +1935,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 {
 	int	Ret;
 	SK_U32	ActionOp;
 
-
-	/*
-	 * Check instance. We only handle single instance variables
-	 */
+	/* Check instance. We only handle single instance variables. */
 	if (Instance != (SK_U32)(-1) && Instance != 1) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_INST);
@@ -2048,26 +1948,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U32);
 		return (SK_PNMI_ERR_TOO_SHORT);
 	}
 
-	/* Check if a get should be performed */
+	/* Check if a GET should be performed. */
 	if (Action == SK_PNMI_GET) {
 
-		/* A get is easy. We always return the same value */
+		/* A GET is easy. We always return the same value. */
 		ActionOp = (SK_U32)SK_PNMI_ACT_IDLE;
 		SK_PNMI_STORE_U32(pBuf, ActionOp);
 		*pLen = sizeof(SK_U32);
 
 		return (SK_PNMI_ERR_OK);
 	}
 
-	/* Continue with PRESET/SET action */
+	/* Continue with PRESET/SET action. */
 	if (*pLen > sizeof(SK_U32)) {
 
 		return (SK_PNMI_ERR_BAD_VALUE);
 	}
 
-	/* Check if the command is a known one */
+	/* Check if the command is a known one. */
 	SK_PNMI_READ_U32(pBuf, ActionOp);
 	if (*pLen > sizeof(SK_U32) ||
 		(ActionOp != SK_PNMI_ACT_IDLE &&
 		ActionOp != SK_PNMI_ACT_RESET &&
@@ -2077,30 +1977,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = 0;
 		return (SK_PNMI_ERR_BAD_VALUE);
 	}
 
-	/* A preset ends here */
+	/* A PRESET ends here. */
 	if (Action == SK_PNMI_PRESET) {
 
 		return (SK_PNMI_ERR_OK);
 	}
 
 	switch (ActionOp) {
 
 	case SK_PNMI_ACT_IDLE:
-		/* Nothing to do */
+		/* Nothing to do. */
 		break;
 
 	case SK_PNMI_ACT_RESET:
-		/*
-		 * Perform a driver reset or something that comes near
-		 * to this.
-		 */
+		/* Perform a driver reset or something that comes near to this. */
 		Ret = SK_DRIVER_RESET(pAC, IoC);
 		if (Ret != 0) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR005,
-				SK_PNMI_ERR005MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR005, SK_PNMI_ERR005MSG);
 
 			return (SK_PNMI_ERR_GENERAL);
 		}
 		break;
@@ -2115,15 +2011,14 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		pAC->Pnmi.TestResult = Ret;
 		break;
 
 	case SK_PNMI_ACT_RESETCNT:
-		/* Set all counters and timestamps to zero */
+		/* Set all counters and timestamps to zero. */
 		ResetCounter(pAC, IoC, NetIndex);
 		break;
 
 	default:
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR006,
-			SK_PNMI_ERR006MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR006, SK_PNMI_ERR006MSG);
 
 		return (SK_PNMI_ERR_GENERAL);
 	}
 
@@ -2165,27 +2060,23 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	SK_U64  StatVal;
 	SK_U32  StatVal32;
 	SK_BOOL Is64BitReq = SK_FALSE;
 
-	/*
-	 * Only the active Mac is returned
-	 */
+	/* Only the active MAC is returned. */
 	if (Instance != (SK_U32)(-1) && Instance != 1) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_INST);
 	}
 
-	/*
-	 * Check action type
-	 */
+	/* Check action type. */
 	if (Action != SK_PNMI_GET) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/* Check length */
+	/* Check length. */
 	switch (Id) {
 
 	case OID_802_3_PERMANENT_ADDRESS:
 	case OID_802_3_CURRENT_ADDRESS:
@@ -2204,14 +2095,14 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 
 #else /* SK_NDIS_64BIT_CTR */
 
-		/* for compatibility, at least 32bit are required for OID */
+		/* For compatibility, at least 32 bits are required for OID. */
 		if (*pLen < sizeof(SK_U32)) {
 			/*
-			* but indicate handling for 64bit values,
-			* if insufficient space is provided
-			*/
+			 * Indicate handling for 64 bit values,
+			 * if insufficient space is provided.
+			 */
 			*pLen = sizeof(SK_U64);
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
 
@@ -2225,18 +2116,16 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	 * consists of multiple physical statistics and increment semaphore
 	 * to indicate that an update was already done.
 	 */
 	Ret = MacUpdate(pAC, IoC, 0, pAC->GIni.GIMacsFound - 1);
-	if ( Ret != SK_PNMI_ERR_OK) {
+	if (Ret != SK_PNMI_ERR_OK) {
 
 		*pLen = 0;
 		return (Ret);
 	}
 	pAC->Pnmi.MacUpdatedFlag ++;
 
-	/*
-	 * Get value (MAC Index 0 identifies the virtual MAC)
-	 */
+	/* Get value (MAC index 0 identifies the virtual MAC). */
 	switch (Id) {
 
 	case OID_802_3_PERMANENT_ADDRESS:
 		CopyMac(pBuf, &pAC->Addr.Net[NetIndex].PermanentMacAddress);
@@ -2250,9 +2139,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 	default:
 		StatVal = GetStatVal(pAC, IoC, 0, IdTable[TableIndex].Param, NetIndex);
 
-		/* by default 32bit values are evaluated */
+		/* By default 32 bit values are evaluated. */
 		if (!Is64BitReq) {
 			StatVal32 = (SK_U32)StatVal;
 			SK_PNMI_STORE_U32(pBuf, StatVal32);
 			*pLen = sizeof(SK_U32);
@@ -2304,23 +2193,21 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	unsigned int	Offset;
 	int				MacType;
 	int				Ret;
 	SK_U64			StatVal;
-	
-	
 
-	/* Calculate instance if wished. MAC index 0 is the virtual MAC */
+	/* Calculate instance if wished. MAC index 0 is the virtual MAC. */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
 	
 	MacType = pAC->GIni.GIMacType;
 
-	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* Dual net mode */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* DualNet mode. */
 		LogPortMax--;
 	}
 
-	if ((Instance != (SK_U32)(-1))) { /* Only one specific instance is queried */
-		/* Check instance range */
+	if ((Instance != (SK_U32)(-1))) { /* Only one specific instance is queried. */
+		/* Check instance range. */
 		if ((Instance < 1) || (Instance > LogPortMax)) {
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_UNKNOWN_INST);
@@ -2328,22 +2215,22 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		LogPortIndex = SK_PNMI_PORT_INST2LOG(Instance);
 		Limit = LogPortIndex + 1;
 	}
 
-	else { /* Instance == (SK_U32)(-1), get all Instances of that OID */
+	else { /* Instance == (SK_U32)(-1), get all Instances of that OID. */
 
 		LogPortIndex = 0;
 		Limit = LogPortMax;
 	}
 
-	/* Check action */
+	/* Check action. */
 	if (Action != SK_PNMI_GET) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/* Check length */
+	/* Check length. */
 	if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U64)) {
 
 		*pLen = (Limit - LogPortIndex) * sizeof(SK_U64);
 		return (SK_PNMI_ERR_TOO_SHORT);
@@ -2360,9 +2247,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		return (Ret);
 	}
 	pAC->Pnmi.MacUpdatedFlag ++;
 
-	/* Get value */
+	/* Get value. */
 	Offset = 0;
 	for (; LogPortIndex < Limit; LogPortIndex ++) {
 
 		switch (Id) {
@@ -2466,50 +2353,43 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	unsigned int	PhysPortIndex;
 	unsigned int	Limit;
 	unsigned int	Offset = 0;
 
-	/*
-	 * Calculate instance if wished. MAC index 0 is the virtual
-	 * MAC.
-	 */
+	/* Calculate instance if wished. MAC index 0 is the virtual MAC. */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
 
-	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* Dual net mode */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* DualNet mode. */
 		LogPortMax--;
 	}
 
-	if ((Instance != (SK_U32)(-1))) { /* Only one specific instance is queried */
-		/* Check instance range */
+	if ((Instance != (SK_U32)(-1))) { /* Only one specific instance is queried. */
+		/* Check instance range. */
 		if ((Instance < 1) || (Instance > LogPortMax)) {
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_UNKNOWN_INST);
 		}
 		LogPortIndex = SK_PNMI_PORT_INST2LOG(Instance);
 		Limit = LogPortIndex + 1;
 	}
-	else { /* Instance == (SK_U32)(-1), get all Instances of that OID */
+	else { /* Instance == (SK_U32)(-1), get all Instances of that OID. */
 
 		LogPortIndex = 0;
 		Limit = LogPortMax;
 	}
 
-	/*
-	 * Perform Action
-	 */
+	/* Perform action. */
 	if (Action == SK_PNMI_GET) {
 
-		/* Check length */
+		/* Check length. */
 		if (*pLen < (Limit - LogPortIndex) * 6) {
 
 			*pLen = (Limit - LogPortIndex) * 6;
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
 
-		/*
-		 * Get value
-		 */
+		/* Get value. */
 		for (; LogPortIndex < Limit; LogPortIndex ++) {
 
 			switch (Id) {
 
@@ -2531,20 +2411,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					CopyMac(pBuf + Offset,
 						&pAC->Addr.Net[NetIndex].PermanentMacAddress);
 				}
 				else {
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
+					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
 
 					CopyMac(pBuf + Offset,
 						&pAC->Addr.Port[PhysPortIndex].PermanentMacAddress);
 				}
 				Offset += 6;
 				break;
 
 			default:
-				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR008,
-					SK_PNMI_ERR008MSG);
+				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR008, SK_PNMI_ERR008MSG);
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_GENERAL);
 			}
@@ -2553,30 +2431,27 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = Offset;
 	}
 	else {
 		/*
-		 * The logical MAC address may not be changed only
-		 * the physical ones
+		 * The logical MAC address may not be changed,
+		 * only the physical ones.
 		 */
 		if (Id == OID_SKGE_PHYS_FAC_ADDR) {
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_READ_ONLY);
 		}
 
-		/*
-		 * Only the current address may be changed
-		 */
+		/* Only the current address may be changed. */
 		if (Id != OID_SKGE_PHYS_CUR_ADDR) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR009,
-				SK_PNMI_ERR009MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR009, SK_PNMI_ERR009MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
-		/* Check length */
+		/* Check length. */
 		if (*pLen < (Limit - LogPortIndex) * 6) {
 
 			*pLen = (Limit - LogPortIndex) * 6;
 			return (SK_PNMI_ERR_TOO_SHORT);
@@ -2586,34 +2461,28 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = 0;
 			return (SK_PNMI_ERR_BAD_VALUE);
 		}
 
-		/*
-		 * Check Action
-		 */
+		/* Check action. */
 		if (Action == SK_PNMI_PRESET) {
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_OK);
 		}
 
-		/*
-		 * Set OID_SKGE_MAC_CUR_ADDR
-		 */
+		/* Set OID_SKGE_MAC_CUR_ADDR.  */
 		for (; LogPortIndex < Limit; LogPortIndex ++, Offset += 6) {
 
 			/*
 			 * A set to virtual port and set of broadcast
-			 * address will be ignored
+			 * address will be ignored.
 			 */
 			if (LogPortIndex == 0 || SK_MEMCMP(pBuf + Offset,
 				"\xff\xff\xff\xff\xff\xff", 6) == 0) {
-
 				continue;
 			}
 
-			PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC,
-				LogPortIndex);
+			PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
 
 			Ret = SkAddrOverride(pAC, IoC, PhysPortIndex,
 				(SK_MAC_ADDR *)(pBuf + Offset),
 				(LogPortIndex == 0 ? SK_ADDR_VIRTUAL_ADDRESS :
@@ -2664,12 +2533,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	unsigned int	Limit;
 	unsigned int	Offset = 0;
 	SK_U64		StatVal;
 
-
-	/*
-	 * Calculate instance if wished
-	 */
+	/* Calculate instance if wished. */
 	if (Instance != (SK_U32)(-1)) {
 
 		if ((Instance < 1) || (Instance > SKCS_NUM_PROTOCOLS)) {
 
@@ -2683,27 +2549,23 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		Index = 0;
 		Limit = SKCS_NUM_PROTOCOLS;
 	}
 
-	/*
-	 * Check action
-	 */
+	/* Check action. */
 	if (Action != SK_PNMI_GET) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/* Check length */
+	/* Check length. */
 	if (*pLen < (Limit - Index) * sizeof(SK_U64)) {
 
 		*pLen = (Limit - Index) * sizeof(SK_U64);
 		return (SK_PNMI_ERR_TOO_SHORT);
 	}
 
-	/*
-	 * Get value
-	 */
+	/* Get value. */
 	for (; Index < Limit; Index ++) {
 
 		switch (Id) {
 
@@ -2727,10 +2589,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			StatVal = pAC->Csum.ProtoStats[NetIndex][Index].TxUnableCts;
 			break;
 
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR010,
-				SK_PNMI_ERR010MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR010, SK_PNMI_ERR010MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -2738,11 +2599,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		SK_PNMI_STORE_U64(pBuf + Offset, StatVal);
 		Offset += sizeof(SK_U64);
 	}
 
-	/*
-	 * Store used buffer space
-	 */
+	/* Store used buffer space. */
 	*pLen = Offset;
 
 	return (SK_PNMI_ERR_OK);
 }
@@ -2783,12 +2642,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	unsigned int	Len;
 	SK_U32		Val32;
 	SK_U64		Val64;
 
-
-	/*
-	 * Calculate instance if wished
-	 */
+	/* Calculate instance if wished. */
 	if ((Instance != (SK_U32)(-1))) {
 
 		if ((Instance < 1) || (Instance > (SK_U32)pAC->I2c.MaxSens)) {
 
@@ -2803,18 +2659,16 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		Index = 0;
 		Limit = (unsigned int) pAC->I2c.MaxSens;
 	}
 
-	/*
-	 * Check action
-	 */
+	/* Check action. */
 	if (Action != SK_PNMI_GET) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/* Check length */
+	/* Check length. */
 	switch (Id) {
 
 	case OID_SKGE_SENSOR_VALUE:
 	case OID_SKGE_SENSOR_WAR_THRES_LOW:
@@ -2871,40 +2725,35 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 		break;
 
 	default:
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR012,
-			SK_PNMI_ERR012MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR012, SK_PNMI_ERR012MSG);
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_GENERAL);
 
 	}
 
-	/*
-	 * Get value
-	 */
+	/* Get value. */
 	for (Offset = 0; Index < Limit; Index ++) {
 
 		switch (Id) {
 
 		case OID_SKGE_SENSOR_INDEX:
 			*(pBuf + Offset) = (char)Index;
-			Offset += sizeof(char);
+			Offset ++;
 			break;
 
 		case OID_SKGE_SENSOR_DESCR:
 			Len = SK_STRLEN(pAC->I2c.SenTable[Index].SenDesc);
-			SK_MEMCPY(pBuf + Offset + 1,
-				pAC->I2c.SenTable[Index].SenDesc, Len);
+			SK_MEMCPY(pBuf + Offset + 1, pAC->I2c.SenTable[Index].SenDesc, Len);
 			*(pBuf + Offset) = (char)Len;
 			Offset += Len + 1;
 			break;
 
 		case OID_SKGE_SENSOR_TYPE:
-			*(pBuf + Offset) =
-				(char)pAC->I2c.SenTable[Index].SenType;
-			Offset += sizeof(char);
+			*(pBuf + Offset) = (char)pAC->I2c.SenTable[Index].SenType;
+			Offset ++;
 			break;
 
 		case OID_SKGE_SENSOR_VALUE:
 			Val32 = (SK_U32)pAC->I2c.SenTable[Index].SenValue;
@@ -2939,11 +2788,10 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			Offset += sizeof(SK_U32);
 			break;
 
 		case OID_SKGE_SENSOR_STATUS:
-			*(pBuf + Offset) =
-				(char)pAC->I2c.SenTable[Index].SenErrFlag;
-			Offset += sizeof(char);
+			*(pBuf + Offset) = (char)pAC->I2c.SenTable[Index].SenErrFlag;
+			Offset ++;
 			break;
 
 		case OID_SKGE_SENSOR_WAR_CTS:
 			Val64 = pAC->I2c.SenTable[Index].SenWarnCts;
@@ -2978,11 +2826,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			return (SK_PNMI_ERR_GENERAL);
 		}
 	}
 
-	/*
-	 * Store used buffer space
-	 */
+	/* Store used buffer space. */
 	*pLen = Offset;
 
 	return (SK_PNMI_ERR_OK);
 }
@@ -3034,11 +2880,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	unsigned int	Len;
 	int		Ret;
 	SK_U32		Val32;
 
-	/*
-	 * Get array of all currently stored VPD keys
-	 */
+	/* Get array of all currently stored VPD keys. */
 	Ret = GetVpdKeyArr(pAC, IoC, &KeyArr[0][0], sizeof(KeyArr), &KeyNo);
 	if (Ret != SK_PNMI_ERR_OK) {
 		*pLen = 0;
 		return (Ret);
@@ -3081,23 +2925,21 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			return (SK_PNMI_ERR_UNKNOWN_INST);
 		}
 	}
 
-	/*
-	 * Get value, if a query should be performed
-	 */
+	/* Get value, if a query should be performed. */
 	if (Action == SK_PNMI_GET) {
 
 		switch (Id) {
 
 		case OID_SKGE_VPD_FREE_BYTES:
-			/* Check length of buffer */
+			/* Check length of buffer. */
 			if (*pLen < sizeof(SK_U32)) {
 
 				*pLen = sizeof(SK_U32);
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
-			/* Get number of free bytes */
+			/* Get number of free bytes. */
 			pVpdStatus = VpdStat(pAC, IoC);
 			if (pVpdStatus == NULL) {
 
 				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR017,
@@ -3120,9 +2962,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = sizeof(SK_U32);
 			break;
 
 		case OID_SKGE_VPD_ENTRIES_LIST:
-			/* Check length */
+			/* Check length. */
 			for (Len = 0, Index = 0; Index < KeyNo; Index ++) {
 
 				Len += SK_STRLEN(KeyArr[Index]) + 1;
 			}
@@ -3131,9 +2973,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				*pLen = Len;
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
 
-			/* Get value */
+			/* Get value. */
 			*(pBuf) = (char)Len - 1;
 			for (Offset = 1, Index = 0; Index < KeyNo; Index ++) {
 
 				Len = SK_STRLEN(KeyArr[Index]);
@@ -3150,9 +2992,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = Offset;
 			break;
 
 		case OID_SKGE_VPD_ENTRIES_NUMBER:
-			/* Check length */
+			/* Check length. */
 			if (*pLen < sizeof(SK_U32)) {
 
 				*pLen = sizeof(SK_U32);
 				return (SK_PNMI_ERR_TOO_SHORT);
@@ -3163,9 +3005,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = sizeof(SK_U32);
 			break;
 
 		case OID_SKGE_VPD_KEY:
-			/* Check buffer length, if it is large enough */
+			/* Check buffer length, if it is large enough. */
 			for (Len = 0, Index = FirstIndex;
 				Index < LastIndex; Index ++) {
 
 				Len += SK_STRLEN(KeyArr[Index]) + 1;
@@ -3179,33 +3021,29 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			/*
 			 * Get the key to an intermediate buffer, because
 			 * we have to prepend a length byte.
 			 */
-			for (Offset = 0, Index = FirstIndex;
-				Index < LastIndex; Index ++) {
+			for (Offset = 0, Index = FirstIndex; Index < LastIndex; Index ++) {
 
 				Len = SK_STRLEN(KeyArr[Index]);
 
 				*(pBuf + Offset) = (char)Len;
-				SK_MEMCPY(pBuf + Offset + 1, KeyArr[Index],
-					Len);
+				SK_MEMCPY(pBuf + Offset + 1, KeyArr[Index], Len);
 				Offset += Len + 1;
 			}
 			*pLen = Offset;
 			break;
 
 		case OID_SKGE_VPD_VALUE:
-			/* Check the buffer length if it is large enough */
-			for (Offset = 0, Index = FirstIndex;
-				Index < LastIndex; Index ++) {
+			/* Check the buffer length if it is large enough. */
+			for (Offset = 0, Index = FirstIndex; Index < LastIndex; Index ++) {
 
 				BufLen = 256;
 				if (VpdRead(pAC, IoC, KeyArr[Index], Buf,
 					(int *)&BufLen) > 0 ||
 					BufLen >= SK_PNMI_VPD_DATALEN) {
 
-					SK_ERR_LOG(pAC, SK_ERRCL_SW,
-						SK_PNMI_ERR021,
+					SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR021,
 						SK_PNMI_ERR021MSG);
 
 					return (SK_PNMI_ERR_GENERAL);
 				}
@@ -3220,18 +3058,16 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			/*
 			 * Get the value to an intermediate buffer, because
 			 * we have to prepend a length byte.
 			 */
-			for (Offset = 0, Index = FirstIndex;
-				Index < LastIndex; Index ++) {
+			for (Offset = 0, Index = FirstIndex; Index < LastIndex; Index ++) {
 
 				BufLen = 256;
 				if (VpdRead(pAC, IoC, KeyArr[Index], Buf,
 					(int *)&BufLen) > 0 ||
 					BufLen >= SK_PNMI_VPD_DATALEN) {
 
-					SK_ERR_LOG(pAC, SK_ERRCL_SW,
-						SK_PNMI_ERR022,
+					SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR022,
 						SK_PNMI_ERR022MSG);
 
 					*pLen = 0;
 					return (SK_PNMI_ERR_GENERAL);
@@ -3250,10 +3086,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				*pLen = LastIndex - FirstIndex;
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
 
-			for (Offset = 0, Index = FirstIndex;
-				Index < LastIndex; Index ++) {
+			for (Offset = 0, Index = FirstIndex; Index < LastIndex; Index ++) {
 
 				if (VpdMayWrite(KeyArr[Index])) {
 
 					*(pBuf + Offset) = SK_PNMI_VPD_RW;
@@ -3277,17 +3112,16 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = Offset;
 			break;
 
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR023,
-				SK_PNMI_ERR023MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR023, SK_PNMI_ERR023MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
 	}
 	else {
-		/* The only OID which can be set is VPD_ACTION */
+		/* The only OID which can be set is VPD_ACTION. */
 		if (Id != OID_SKGE_VPD_ACTION) {
 
 			if (Id == OID_SKGE_VPD_FREE_BYTES ||
 				Id == OID_SKGE_VPD_ENTRIES_LIST ||
@@ -3299,10 +3133,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				*pLen = 0;
 				return (SK_PNMI_ERR_READ_ONLY);
 			}
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR024,
-				SK_PNMI_ERR024MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR024, SK_PNMI_ERR024MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -3316,16 +3149,13 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = 1;
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
 
-		/*
-		 * The first byte contains the VPD action type we should
-		 * perform.
-		 */
+		/* The first byte contains the VPD action type we should perform. */
 		switch (*pBuf) {
 
 		case SK_PNMI_VPD_IGNORE:
-			/* Nothing to do */
+			/* Nothing to do. */
 			break;
 
 		case SK_PNMI_VPD_CREATE:
 			/*
@@ -3355,15 +3185,15 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 			SK_MEMCPY(Buf, pBuf + 4, Offset);
 			Buf[Offset] = 0;
 
-			/* A preset ends here */
+			/* A PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				return (SK_PNMI_ERR_OK);
 			}
 
-			/* Write the new entry or modify an existing one */
+			/* Write the new entry or modify an existing one .*/
 			Ret = VpdWrite(pAC, IoC, KeyStr, Buf);
 			if (Ret == SK_PNMI_VPD_NOWRITE ) {
 
 				*pLen = 0;
@@ -3393,9 +3223,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			}
 			break;
 
 		case SK_PNMI_VPD_DELETE:
-			/* Check if the buffer size is plausible */
+			/* Check if the buffer size is plausible. */
 			if (*pLen < 3) {
 
 				*pLen = 3;
 				return (SK_PNMI_ERR_TOO_SHORT);
@@ -3408,16 +3238,17 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			KeyStr[0] = pBuf[1];
 			KeyStr[1] = pBuf[2];
 			KeyStr[2] = 0;
 
-			/* Find the passed key in the array */
+			/* Find the passed key in the array. */
 			for (Index = 0; Index < KeyNo; Index ++) {
 
 				if (SK_STRCMP(KeyStr, KeyArr[Index]) == 0) {
 
 					break;
 				}
 			}
+
 			/*
 			 * If we cannot find the key it is wrong, so we
 			 * return an appropriate error value.
 			 */
@@ -3431,9 +3262,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 				return (SK_PNMI_ERR_OK);
 			}
 
-			/* Ok, you wanted it and you will get it */
+			/* Ok, you wanted it and you will get it. */
 			Ret = VpdDelete(pAC, IoC, KeyStr);
 			if (Ret != SK_PNMI_VPD_OK) {
 
 				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR027,
@@ -3509,31 +3340,25 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	SK_BOOL		Is64BitReq = SK_FALSE;
 	char		Buf[256];
 	int			MacType;
 
-	/*
-	 * Check instance. We only handle single instance variables.
-	 */
+	/* Check instance. We only handle single instance variables. */
 	if (Instance != (SK_U32)(-1) && Instance != 1) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_INST);
 	}
 
-	/*
-	 * Check action. We only allow get requests.
-	 */
+	/* Check action. We only allow get requests. */
 	if (Action != SK_PNMI_GET) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 	
 	MacType = pAC->GIni.GIMacType;
 	
-	/*
-	 * Check length for the various supported OIDs
-	 */
+	/* Check length for the various supported OIDs. */
 	switch (Id) {
 
 	case OID_GEN_XMIT_ERROR:
 	case OID_GEN_RCV_ERROR:
@@ -3545,16 +3370,14 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 
 #else /* SK_NDIS_64BIT_CTR */
 
-		/*
-		 * for compatibility, at least 32bit are required for oid
-		 */
+		/* For compatibility, at least 32bit are required for OID. */
 		if (*pLen < sizeof(SK_U32)) {
 			/*
-			* but indicate handling for 64bit values,
-			* if insufficient space is provided
-			*/
+			 * Indicate handling for 64bit values,
+			 * if insufficient space is provided.
+			 */
 			*pLen = sizeof(SK_U64);
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
 
@@ -3623,21 +3446,22 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 		break;
 
 	default:
-		/* Checked later */
+		/* Checked later. */
 		break;
 	}
 
-	/* Update statistic */
+	/* Update statistics. */
 	if (Id == OID_SKGE_RX_HW_ERROR_CTS ||
 		Id == OID_SKGE_TX_HW_ERROR_CTS ||
 		Id == OID_SKGE_IN_ERRORS_CTS ||
 		Id == OID_SKGE_OUT_ERROR_CTS ||
 		Id == OID_GEN_XMIT_ERROR ||
 		Id == OID_GEN_RCV_ERROR) {
 
-		/* Force the XMAC to update its statistic counters and
+		/*
+		 * Force the XMAC to update its statistic counters and
 		 * Increment semaphore to indicate that an update was
 		 * already done.
 		 */
 		Ret = MacUpdate(pAC, IoC, 0, pAC->GIni.GIMacsFound - 1);
@@ -3684,11 +3508,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			break;
 		}
 	}
 
-	/*
-	 * Retrieve value
-	 */
+	/* Retrieve value. */
 	switch (Id) {
 
 	case OID_SKGE_SUPPORTED_LIST:
 		Len = ID_TABLE_SIZE * sizeof(SK_U32);
@@ -3696,13 +3518,13 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 			*pLen = Len;
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
-		for (Offset = 0, Index = 0; Offset < Len;
-			Offset += sizeof(SK_U32), Index ++) {
+		for (Offset = 0, Index = 0; Offset < Len; Index ++) {
 
 			Val32 = (SK_U32)IdTable[Index].Id;
 			SK_PNMI_STORE_U32(pBuf + Offset, Val32);
+			Offset += sizeof(SK_U32);
 		}
 		*pLen = Len;
 		break;
 
@@ -3726,20 +3548,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 	case OID_SKGE_DRIVER_DESCR:
 		if (pAC->Pnmi.pDriverDescription == NULL) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR007,
-				SK_PNMI_ERR007MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR007, SK_PNMI_ERR007MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
 		Len = SK_STRLEN(pAC->Pnmi.pDriverDescription) + 1;
 		if (Len > SK_PNMI_STRINGLEN1) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR029,
-				SK_PNMI_ERR029MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR029, SK_PNMI_ERR029MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -3756,20 +3576,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 	case OID_SKGE_DRIVER_VERSION:
 		if (pAC->Pnmi.pDriverVersion == NULL) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR030,
-				SK_PNMI_ERR030MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR030, SK_PNMI_ERR030MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
 		Len = SK_STRLEN(pAC->Pnmi.pDriverVersion) + 1;
 		if (Len > SK_PNMI_STRINGLEN1) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR031,
-				SK_PNMI_ERR031MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR031, SK_PNMI_ERR031MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -3786,20 +3604,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 	case OID_SKGE_DRIVER_RELDATE:
 		if (pAC->Pnmi.pDriverReleaseDate == NULL) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR030,
-				SK_PNMI_ERR053MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR053, SK_PNMI_ERR053MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
 		Len = SK_STRLEN(pAC->Pnmi.pDriverReleaseDate) + 1;
 		if (Len > SK_PNMI_STRINGLEN1) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR031,
-				SK_PNMI_ERR054MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR054, SK_PNMI_ERR054MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -3816,20 +3632,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 	case OID_SKGE_DRIVER_FILENAME:
 		if (pAC->Pnmi.pDriverFileName == NULL) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR030,
-				SK_PNMI_ERR055MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR055, SK_PNMI_ERR055MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
 		Len = SK_STRLEN(pAC->Pnmi.pDriverFileName) + 1;
 		if (Len > SK_PNMI_STRINGLEN1) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR031,
-				SK_PNMI_ERR056MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR056, SK_PNMI_ERR056MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -3853,19 +3667,17 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		 */
 		Len = 256;
 		if (VpdRead(pAC, IoC, VPD_NAME, Buf, (int *)&Len) > 0) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR032,
-				SK_PNMI_ERR032MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR032, SK_PNMI_ERR032MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
 		Len ++;
 		if (Len > SK_PNMI_STRINGLEN1) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR033,
-				SK_PNMI_ERR033MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR033, SK_PNMI_ERR033MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -3879,20 +3691,19 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = Len;
 		break;
 
 	case OID_SKGE_HW_VERSION:
-		/* Oh, I love to do some string manipulation */
 		if (*pLen < 5) {
 
 			*pLen = 5;
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
 		Val8 = (SK_U8)pAC->GIni.GIPciHwRev;
 		pBuf[0] = 4;
 		pBuf[1] = 'v';
-		pBuf[2] = (char)(0x30 | ((Val8 >> 4) & 0x0F));
+		pBuf[2] = (char)('0' | ((Val8 >> 4) & 0x0f));
 		pBuf[3] = '.';
-		pBuf[4] = (char)(0x30 | (Val8 & 0x0F));
+		pBuf[4] = (char)('0' | (Val8 & 0x0f));
 		*pLen = 5;
 		break;
 
 	case OID_SKGE_CHIPSET:
@@ -3913,14 +3724,14 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U32);
 		break;
 
 	case OID_SKGE_VAUXAVAIL:
-		*pBuf = (char) pAC->GIni.GIVauxAvail;
+		*pBuf = (char)pAC->GIni.GIVauxAvail;
 		*pLen = sizeof(char);
 		break;
 
 	case OID_SKGE_BUS_TYPE:
-		*pBuf = (char) SK_PNMI_BUS_PCI;
+		*pBuf = (char)SK_PNMI_BUS_PCI;
 		*pLen = sizeof(char);
 		break;
 
 	case OID_SKGE_BUS_SPEED:
@@ -3967,33 +3778,33 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = Len;
 		break;
 
 	case OID_SKGE_RLMT_MONITOR_NUMBER:
-/* XXX Not yet implemented by RLMT therefore we return zero elements */
+		/* Not yet implemented by RLMT, therefore we return zero elements. */
 		Val32 = 0;
 		SK_PNMI_STORE_U32(pBuf, Val32);
 		*pLen = sizeof(SK_U32);
 		break;
 
 	case OID_SKGE_TX_SW_QUEUE_LEN:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].TxSwQueueLen;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].TxSwQueueLen +
 					pAC->Pnmi.BufPort[1].TxSwQueueLen;
 			}			
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].TxSwQueueLen;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].TxSwQueueLen +
 					pAC->Pnmi.Port[1].TxSwQueueLen;
 			}			
@@ -4003,26 +3814,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		break;
 
 
 	case OID_SKGE_TX_SW_QUEUE_MAX:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].TxSwQueueMax;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].TxSwQueueMax +
 					pAC->Pnmi.BufPort[1].TxSwQueueMax;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].TxSwQueueMax;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].TxSwQueueMax +
 					pAC->Pnmi.Port[1].TxSwQueueMax;
 			}
@@ -4031,26 +3842,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_TX_RETRY:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].TxRetryCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].TxRetryCts +
 					pAC->Pnmi.BufPort[1].TxRetryCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].TxRetryCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].TxRetryCts +
 					pAC->Pnmi.Port[1].TxRetryCts;
 			}
@@ -4059,26 +3870,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_RX_INTR_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].RxIntrCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].RxIntrCts +
 					pAC->Pnmi.BufPort[1].RxIntrCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].RxIntrCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].RxIntrCts +
 					pAC->Pnmi.Port[1].RxIntrCts;
 			}
@@ -4087,26 +3898,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_TX_INTR_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].TxIntrCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].TxIntrCts +
 					pAC->Pnmi.BufPort[1].TxIntrCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].TxIntrCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].TxIntrCts +
 					pAC->Pnmi.Port[1].TxIntrCts;
 			}
@@ -4115,26 +3926,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_RX_NO_BUF_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].RxNoBufCts +
 					pAC->Pnmi.BufPort[1].RxNoBufCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].RxNoBufCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].RxNoBufCts +
 					pAC->Pnmi.Port[1].RxNoBufCts;
 			}
@@ -4143,26 +3954,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_TX_NO_BUF_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].TxNoBufCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].TxNoBufCts +
 					pAC->Pnmi.BufPort[1].TxNoBufCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].TxNoBufCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].TxNoBufCts +
 					pAC->Pnmi.Port[1].TxNoBufCts;
 			}
@@ -4171,26 +3982,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_TX_USED_DESCR_NO:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].TxUsedDescrNo;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].TxUsedDescrNo +
 					pAC->Pnmi.BufPort[1].TxUsedDescrNo;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].TxUsedDescrNo;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].TxUsedDescrNo +
 					pAC->Pnmi.Port[1].TxUsedDescrNo;
 			}
@@ -4199,26 +4010,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_RX_DELIVERED_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].RxDeliveredCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].RxDeliveredCts +
 					pAC->Pnmi.BufPort[1].RxDeliveredCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].RxDeliveredCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].RxDeliveredCts +
 					pAC->Pnmi.Port[1].RxDeliveredCts;
 			}
@@ -4227,26 +4038,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_RX_OCTETS_DELIV_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].RxOctetsDeliveredCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].RxOctetsDeliveredCts +
 					pAC->Pnmi.BufPort[1].RxOctetsDeliveredCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].RxOctetsDeliveredCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].RxOctetsDeliveredCts +
 					pAC->Pnmi.Port[1].RxOctetsDeliveredCts;
 			}
@@ -4265,27 +4076,27 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_IN_ERRORS_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = Val64RxHwErrs + pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = Val64RxHwErrs +
 					pAC->Pnmi.BufPort[0].RxNoBufCts +
 					pAC->Pnmi.BufPort[1].RxNoBufCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = Val64RxHwErrs + pAC->Pnmi.Port[NetIndex].RxNoBufCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = Val64RxHwErrs +
 					pAC->Pnmi.Port[0].RxNoBufCts +
 					pAC->Pnmi.Port[1].RxNoBufCts;
@@ -4295,27 +4106,27 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_OUT_ERROR_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = Val64TxHwErrs + pAC->Pnmi.BufPort[NetIndex].TxNoBufCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = Val64TxHwErrs +
 					pAC->Pnmi.BufPort[0].TxNoBufCts +
 					pAC->Pnmi.BufPort[1].TxNoBufCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = Val64TxHwErrs + pAC->Pnmi.Port[NetIndex].TxNoBufCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = Val64TxHwErrs +
 					pAC->Pnmi.Port[0].TxNoBufCts +
 					pAC->Pnmi.Port[1].TxNoBufCts;
@@ -4325,26 +4136,26 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_ERR_RECOVERY_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.BufPort[NetIndex].ErrRecoveryCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.BufPort[0].ErrRecoveryCts +
 					pAC->Pnmi.BufPort[1].ErrRecoveryCts;
 			}
 		}
 		else {
-			/* Dual net mode */
+			/* DualNet mode. */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 				Val64 = pAC->Pnmi.Port[NetIndex].ErrRecoveryCts;
 			}
-			/* Single net mode */
+			/* SingleNet mode. */
 			else {
 				Val64 = pAC->Pnmi.Port[0].ErrRecoveryCts +
 					pAC->Pnmi.Port[1].ErrRecoveryCts;
 			}
@@ -4366,18 +4177,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U32);
 		break;
 
 	case OID_GEN_RCV_ERROR:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
 			Val64 = Val64RxHwErrs + pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
 		}
 		else {
 			Val64 = Val64RxHwErrs + pAC->Pnmi.Port[NetIndex].RxNoBufCts;
 		}
 
 		/*
-		 * by default 32bit values are evaluated
+		 * By default 32bit values are evaluated.
 		 */
 		if (!Is64BitReq) {
 			Val32 = (SK_U32)Val64;
 			SK_PNMI_STORE_U32(pBuf, Val32);
@@ -4389,18 +4200,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 		break;
 
 	case OID_GEN_XMIT_ERROR:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
 			Val64 = Val64TxHwErrs + pAC->Pnmi.BufPort[NetIndex].TxNoBufCts;
 		}
 		else {
 			Val64 = Val64TxHwErrs + pAC->Pnmi.Port[NetIndex].TxNoBufCts;
 		}
 
 		/*
-		 * by default 32bit values are evaluated
+		 * By default 32bit values are evaluated.
 		 */
 		if (!Is64BitReq) {
 			Val32 = (SK_U32)Val64;
 			SK_PNMI_STORE_U32(pBuf, Val32);
@@ -4412,18 +4223,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 		break;
 
 	case OID_GEN_RCV_NO_BUFFER:
-		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 		if (MacType == SK_MAC_XMAC) {
 			Val64 = pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
 		}
 		else {
 			Val64 = pAC->Pnmi.Port[NetIndex].RxNoBufCts;
 		}
 
 		/*
-		 * by default 32bit values are evaluated
+		 * By default 32bit values are evaluated.
 		 */
 		if (!Is64BitReq) {
 			Val32 = (SK_U32)Val64;
 			SK_PNMI_STORE_U32(pBuf, Val32);
@@ -4441,10 +4252,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U32);
 		break;
 
 	default:
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR034,
-			SK_PNMI_ERR034MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR034, SK_PNMI_ERR034MSG);
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_GENERAL);
 	}
@@ -4499,27 +4309,19 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	SK_EVPARA	EventParam;
 	SK_U32		Val32;
 	SK_U64		Val64;
 
-
-	/*
-	 * Check instance. Only single instance OIDs are allowed here.
-	 */
+	/* Check instance. Only single instance OIDs are allowed here. */
 	if (Instance != (SK_U32)(-1) && Instance != 1) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_INST);
 	}
 
-	/*
-	 * Perform the requested action.
-	 */
+	/* Perform the requested action. */
 	if (Action == SK_PNMI_GET) {
 
-		/*
-		 * Check if the buffer length is large enough.
-		 */
-
+		/* Check if the buffer length is large enough. */
 		switch (Id) {
 
 		case OID_SKGE_RLMT_MODE:
 		case OID_SKGE_RLMT_PORT_ACTIVE:
@@ -4550,10 +4352,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			}
 			break;
 
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR035,
-				SK_PNMI_ERR035MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR035, SK_PNMI_ERR035MSG);
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -4570,11 +4371,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			return (Ret);
 		}
 		pAC->Pnmi.RlmtUpdatedFlag ++;
 
-		/*
-		 * Retrieve Value
-		*/
+		/* Retrieve value. */
 		switch (Id) {
 
 		case OID_SKGE_RLMT_MODE:
 			*pBuf = (char)pAC->Rlmt.Net[0].RlmtMode;
@@ -4650,62 +4449,67 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 		pAC->Pnmi.RlmtUpdatedFlag --;
 	}
 	else {
-		/* Perform a preset or set */
+		/* Perform a PRESET or SET. */
 		switch (Id) {
 
 		case OID_SKGE_RLMT_MODE:
-			/* Check if the buffer length is plausible */
+			/* Check if the buffer length is plausible. */
 			if (*pLen < sizeof(char)) {
 
 				*pLen = sizeof(char);
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
-			/* Check if the value range is correct */
+			/* Check if the value range is correct. */
 			if (*pLen != sizeof(char) ||
 				(*pBuf & SK_PNMI_RLMT_MODE_CHK_LINK) == 0 ||
 				*(SK_U8 *)pBuf > 15) {
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
-			/* The preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_OK);
 			}
-			/* Send an event to RLMT to change the mode */
+			/* Send an event to RLMT to change the mode. */
 			SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
+			
 			EventParam.Para32[0] |= (SK_U32)(*pBuf);
 			EventParam.Para32[1] = 0;
 			if (SkRlmtEvent(pAC, IoC, SK_RLMT_MODE_CHANGE,
 				EventParam) > 0) {
 
-				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR037,
-					SK_PNMI_ERR037MSG);
+				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR037, SK_PNMI_ERR037MSG);
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_GENERAL);
 			}
 			break;
 
 		case OID_SKGE_RLMT_PORT_PREFERRED:
-			/* Check if the buffer length is plausible */
+			/* PRESET/SET action makes no sense in Dual Net mode. */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				break;
+			}
+			
+			/* Check if the buffer length is plausible. */
 			if (*pLen < sizeof(char)) {
 
 				*pLen = sizeof(char);
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
-			/* Check if the value range is correct */
+			/* Check if the value range is correct. */
 			if (*pLen != sizeof(char) || *(SK_U8 *)pBuf >
 				(SK_U8)pAC->GIni.GIMacsFound) {
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
-			/* The preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_OK);
@@ -4716,38 +4520,36 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			 * A param of -1 means automatic mode. RLMT will
 			 * make the decision which is the preferred port.
 			 */
 			SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
+			
 			EventParam.Para32[0] = (SK_U32)(*pBuf) - 1;
 			EventParam.Para32[1] = NetIndex;
 			if (SkRlmtEvent(pAC, IoC, SK_RLMT_PREFPORT_CHANGE,
 				EventParam) > 0) {
 
-				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR038,
-					SK_PNMI_ERR038MSG);
+				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR038, SK_PNMI_ERR038MSG);
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_GENERAL);
 			}
 			break;
 
 		case OID_SKGE_RLMT_CHANGE_THRES:
-			/* Check if the buffer length is plausible */
+			/* Check if the buffer length is plausible. */
 			if (*pLen < sizeof(SK_U64)) {
 
 				*pLen = sizeof(SK_U64);
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
-			/*
-			 * There are not many restrictions to the
-			 * value range.
-			 */
+			
+			/* There are not many restrictions to the value range. */
 			if (*pLen != sizeof(SK_U64)) {
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
-			/* A preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				*pLen = 0;
 				return (SK_PNMI_ERR_OK);
@@ -4760,9 +4562,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			pAC->Pnmi.RlmtChangeThreshold = Val64;
 			break;
 
 		default:
-			/* The other OIDs are not be able for set */
+			/* The other OIDs are not be able for set. */
 			*pLen = 0;
 			return (SK_PNMI_ERR_READ_ONLY);
 		}
 	}
@@ -4805,56 +4607,51 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	int		Ret;
 	SK_U32		Val32;
 	SK_U64		Val64;
 
-	/*
-	 * Calculate the port indexes from the instance.
-	 */
+
+	/* Calculate the port indexes from the instance. */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 
 	if ((Instance != (SK_U32)(-1))) {
-		/* Check instance range */
+		/* Check instance range. */
 		if ((Instance < 1) || (Instance > PhysPortMax)) {
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_UNKNOWN_INST);
 		}
 
-		/* Single net mode */
+		/* SingleNet mode. */
 		PhysPortIndex = Instance - 1;
 
-		/* Dual net mode */
+		/* DualNet mode. */
 		if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 			PhysPortIndex = NetIndex;
 		}
 
-		/* Both net modes */
+		/* Both net modes. */
 		Limit = PhysPortIndex + 1;
 	}
 	else {
-		/* Single net mode */
+		/* SingleNet mode. */
 		PhysPortIndex = 0;
 		Limit = PhysPortMax;
 
-		/* Dual net mode */
+		/* DualNet mode. */
 		if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 			PhysPortIndex = NetIndex;
 			Limit = PhysPortIndex + 1;
 		}
 	}
 
-	/*
-	 * Currently only get requests are allowed.
-	 */
+	/* Currently only GET requests are allowed. */
 	if (Action != SK_PNMI_GET) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check if the buffer length is large enough.
-	 */
+	/* Check if the buffer length is large enough. */
 	switch (Id) {
 
 	case OID_SKGE_RLMT_PORT_INDEX:
 	case OID_SKGE_RLMT_STATUS:
@@ -4876,10 +4673,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 		break;
 
 	default:
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR039,
-			SK_PNMI_ERR039MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR039, SK_PNMI_ERR039MSG);
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_GENERAL);
 
@@ -4895,11 +4691,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		return (Ret);
 	}
 	pAC->Pnmi.RlmtUpdatedFlag ++;
 
-	/*
-	 * Get value
-	 */
+	/* Get value. */
 	Offset = 0;
 	for (; PhysPortIndex < Limit; PhysPortIndex ++) {
 
 		switch (Id) {
@@ -5010,21 +4804,23 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	char 		*pBufPtr;
 	int			Ret;
 	SK_EVPARA	EventParam;
 	SK_U32		Val32;
+#ifdef SK_PHY_LP_MODE
+	SK_U8	CurrentPhyPowerState;
+#endif /* SK_PHY_LP_MODE */
 
-	/*
-	 * Calculate instance if wished. MAC index 0 is the virtual MAC.
-	 */
+
+	/* Calculate instance if wished. MAC index 0 is the virtual MAC. */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
 
-	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* Dual net mode */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* DualNet mode. */
 		LogPortMax--;
 	}
 
-	if ((Instance != (SK_U32)(-1))) { /* Only one specific instance is queried */
-		/* Check instance range */
+	if ((Instance != (SK_U32)(-1))) { /* Only one specific instance is queried. */
+		/* Check instance range. */
 		if ((Instance < 1) || (Instance > LogPortMax)) {
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_UNKNOWN_INST);
@@ -5032,20 +4828,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		LogPortIndex = SK_PNMI_PORT_INST2LOG(Instance);
 		Limit = LogPortIndex + 1;
 	}
 
-	else { /* Instance == (SK_U32)(-1), get all Instances of that OID */
+	else { /* Instance == (SK_U32)(-1), get all Instances of that OID. */
 
 		LogPortIndex = 0;
 		Limit = LogPortMax;
 	}
 
-	/*
-	 * Perform action
-	 */
+	/* Perform action. */
 	if (Action == SK_PNMI_GET) {
 
-		/* Check length */
+		/* Check length. */
 		switch (Id) {
 
 		case OID_SKGE_PMD:
 		case OID_SKGE_CONNECTOR:
@@ -5081,10 +4875,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			}
 			break;
 
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR041,
-				SK_PNMI_ERR041MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR041, SK_PNMI_ERR041MSG);
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
@@ -5098,11 +4891,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			return (Ret);
 		}
 		pAC->Pnmi.SirqUpdatedFlag ++;
 
-		/*
-		 * Get value
-		 */
+		/* Get value. */
 		Offset = 0;
 		for (; LogPortIndex < Limit; LogPortIndex ++) {
 
 			pBufPtr = pBuf + Offset;
@@ -5110,257 +4901,249 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			switch (Id) {
 
 			case OID_SKGE_PMD:
 				*pBufPtr = pAC->Pnmi.PMD;
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_CONNECTOR:
 				*pBufPtr = pAC->Pnmi.Connector;
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_PHY_TYPE:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
 						continue;
 					}
-					else {
-						/* Get value for physical ports */
-						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-							pAC, LogPortIndex);
-						Val32 = pAC->GIni.GP[PhysPortIndex].PhyType;
-						SK_PNMI_STORE_U32(pBufPtr, Val32);
-					}
+					/* Get value for physical port. */
+					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
+					Val32 = pAC->GIni.GP[PhysPortIndex].PhyType;
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 					
 					Val32 = pAC->GIni.GP[NetIndex].PhyType;
-					SK_PNMI_STORE_U32(pBufPtr, Val32);
 				}
+				SK_PNMI_STORE_U32(pBufPtr, Val32);
 				Offset += sizeof(SK_U32);
 				break;
 
 #ifdef SK_PHY_LP_MODE
 			case OID_SKGE_PHY_LP_MODE:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
 						continue;
 					}
-					else {
-						/* Get value for physical ports */
-						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
-						Val8 = (SK_U8) pAC->GIni.GP[PhysPortIndex].PPhyPowerState;
-						*pBufPtr = Val8;
-					}
+					/* Get value for physical port. */
+					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
+					*pBufPtr = (SK_U8)pAC->GIni.GP[PhysPortIndex].PPhyPowerState;
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 					
-					Val8 = (SK_U8) pAC->GIni.GP[PhysPortIndex].PPhyPowerState;
-					*pBufPtr = Val8;
+					*pBufPtr = (SK_U8)pAC->GIni.GP[NetIndex].PPhyPowerState;
 				}
 				Offset += sizeof(SK_U8);
 				break;
 #endif
 
 			case OID_SKGE_LINK_CAP:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical ports */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkCap;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 					
 					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkCap;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_LINK_MODE:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical ports */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkModeConf;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 				
 					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkModeConf;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_LINK_MODE_STATUS:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical port */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 
 						*pBufPtr =
 							CalculateLinkModeStatus(pAC, IoC, PhysPortIndex);
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 					
 					*pBufPtr = CalculateLinkModeStatus(pAC, IoC, NetIndex);
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_LINK_STATUS:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical ports */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = CalculateLinkStatus(pAC, IoC, PhysPortIndex);
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 
 					*pBufPtr = CalculateLinkStatus(pAC, IoC, NetIndex);
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_FLOWCTRL_CAP:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical ports */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlCap;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 				
 					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlCap;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_FLOWCTRL_MODE:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical port */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlMode;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 
 					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlMode;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_FLOWCTRL_STATUS:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical port */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlStatus;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 
 					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlStatus;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_PHY_OPERATION_CAP:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet Mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical ports */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSCap;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 				
 					*pBufPtr = pAC->GIni.GP[NetIndex].PMSCap;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_PHY_OPERATION_MODE:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical port */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSMode;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 				
 					*pBufPtr = pAC->GIni.GP[NetIndex].PMSMode;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_PHY_OPERATION_STATUS:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical port */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSStatus;
@@ -5369,72 +5152,72 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				else {
 				
 					*pBufPtr = pAC->GIni.GP[NetIndex].PMSStatus;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_SPEED_CAP:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical ports */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeedCap;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 				
 					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeedCap;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_SPEED_MODE:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical port */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeed;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 
 					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeed;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 
 			case OID_SKGE_SPEED_STATUS:
-				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 					if (LogPortIndex == 0) {
-						/* Get value for virtual port */
+						/* Get value for virtual port. */
 						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
-						/* Get value for physical port */
+						/* Get value for physical port. */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
 						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed;
 					}
 				}
-				else { /* DualNetMode */
+				else { /* DualNet mode. */
 
 					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeedUsed;
 				}
-				Offset += sizeof(char);
+				Offset ++;
 				break;
 			
 			case OID_SKGE_MTU:
 				Val32 = SK_DRIVER_GET_MTU(pAC, IoC, NetIndex);
@@ -5485,42 +5268,35 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = Limit - LogPortIndex;
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
 		break;
-#endif
+#endif /* SK_PHY_LP_MODE */
 
 	case OID_SKGE_MTU:
-		if (*pLen < sizeof(SK_U32)) {
+		if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U32)) {
 
-			*pLen = sizeof(SK_U32);
+			*pLen = (Limit - LogPortIndex) * sizeof(SK_U32);
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
-		if (*pLen != sizeof(SK_U32)) {
-
-			*pLen = 0;
-			return (SK_PNMI_ERR_BAD_VALUE);
-		}
 		break;
-
+	
     default:
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Perform preset or set
-	 */
+	/* Perform PRESET or SET. */
 	Offset = 0;
 	for (; LogPortIndex < Limit; LogPortIndex ++) {
 
+		Val8 = *(pBuf + Offset);
+
 		switch (Id) {
 
 		case OID_SKGE_LINK_MODE:
-			/* Check the value range */
-			Val8 = *(pBuf + Offset);
+			/* Check the value range. */
 			if (Val8 == 0) {
-
-				Offset += sizeof(char);
+				Offset++;
 				break;
 			}
 			if (Val8 < SK_LMODE_HALF ||
 				(LogPortIndex != 0 && Val8 > SK_LMODE_AUTOSENSE) ||
@@ -5529,53 +5305,70 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				*pLen = 0;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
 
-			/* The preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				return (SK_PNMI_ERR_OK);
 			}
 
-			if (LogPortIndex == 0) {
-
-				/*
-				 * The virtual port consists of all currently
-				 * active ports. Find them and send an event
-				 * with the new link mode to SIRQ.
-				 */
-				for (PhysPortIndex = 0;
-					PhysPortIndex < PhysPortMax;
-					PhysPortIndex ++) {
-
-					if (!pAC->Pnmi.Port[PhysPortIndex].
-						ActiveFlag) {
-
-						continue;
-					}
+			if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
+				if (LogPortIndex == 0) {
+					/*
+					 * The virtual port consists of all currently
+					 * active ports. Find them and send an event
+					 * with the new link mode to SIRQ.
+					 */
+					for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax;
+						PhysPortIndex ++) {
 
-					EventParam.Para32[0] = PhysPortIndex;
+						if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
+							continue;
+						}
+						
+						EventParam.Para32[0] = PhysPortIndex;
+						EventParam.Para32[1] = (SK_U32)Val8;
+						if (SkGeSirqEvent(pAC, IoC,
+							SK_HWEV_SET_LMODE,
+							EventParam) > 0) {
+							
+							SK_ERR_LOG(pAC, SK_ERRCL_SW,
+								SK_PNMI_ERR043,
+								SK_PNMI_ERR043MSG);
+							
+							*pLen = 0;
+							return (SK_PNMI_ERR_GENERAL);
+						}
+					} /* for */
+				}
+				else {
+					/*
+					 * Send an event with the new link mode to
+					 * the SIRQ module.
+					 */
+					EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
+						pAC, LogPortIndex);
 					EventParam.Para32[1] = (SK_U32)Val8;
-					if (SkGeSirqEvent(pAC, IoC,
-						SK_HWEV_SET_LMODE,
+					if (SkGeSirqEvent(pAC, IoC, SK_HWEV_SET_LMODE,
 						EventParam) > 0) {
-
+						
 						SK_ERR_LOG(pAC, SK_ERRCL_SW,
 							SK_PNMI_ERR043,
 							SK_PNMI_ERR043MSG);
-
+						
 						*pLen = 0;
 						return (SK_PNMI_ERR_GENERAL);
 					}
 				}
 			}
-			else {
+			else { /* DualNet mode. */
+
 				/*
 				 * Send an event with the new link mode to
 				 * the SIRQ module.
 				 */
-				EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
-					pAC, LogPortIndex);
+				EventParam.Para32[0] = NetIndex;
 				EventParam.Para32[1] = (SK_U32)Val8;
 				if (SkGeSirqEvent(pAC, IoC, SK_HWEV_SET_LMODE,
 					EventParam) > 0) {
 
@@ -5586,17 +5379,15 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					*pLen = 0;
 					return (SK_PNMI_ERR_GENERAL);
 				}
 			}
-			Offset += sizeof(char);
+			Offset++;
 			break;
 
 		case OID_SKGE_FLOWCTRL_MODE:
-			/* Check the value range */
-			Val8 = *(pBuf + Offset);
+			/* Check the value range. */
 			if (Val8 == 0) {
-
-				Offset += sizeof(char);
+				Offset++;
 				break;
 			}
 			if (Val8 < SK_FLOW_MODE_NONE ||
 				(LogPortIndex != 0 && Val8 > SK_FLOW_MODE_SYM_OR_REM) ||
@@ -5605,32 +5396,50 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				*pLen = 0;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
 
-			/* The preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				return (SK_PNMI_ERR_OK);
 			}
 
-			if (LogPortIndex == 0) {
+			if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
+				if (LogPortIndex == 0) {
+					/*
+					 * The virtual port consists of all currently
+					 * active ports. Find them and send an event
+					 * with the new flow control mode to SIRQ.
+					 */
+					for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax;
+						PhysPortIndex ++) {
 
-				/*
-				 * The virtual port consists of all currently
-				 * active ports. Find them and send an event
-				 * with the new flow control mode to SIRQ.
-				 */
-				for (PhysPortIndex = 0;
-					PhysPortIndex < PhysPortMax;
-					PhysPortIndex ++) {
+						if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
+							continue;
+						}
 
-					if (!pAC->Pnmi.Port[PhysPortIndex].
-						ActiveFlag) {
+						EventParam.Para32[0] = PhysPortIndex;
+						EventParam.Para32[1] = (SK_U32)Val8;
+						if (SkGeSirqEvent(pAC, IoC,
+							SK_HWEV_SET_FLOWMODE,
+							EventParam) > 0) {
+
+							SK_ERR_LOG(pAC, SK_ERRCL_SW,
+								SK_PNMI_ERR044,
+								SK_PNMI_ERR044MSG);
 
-						continue;
+							*pLen = 0;
+							return (SK_PNMI_ERR_GENERAL);
+						}
 					}
-
-					EventParam.Para32[0] = PhysPortIndex;
+				}
+				else {
+					/*
+					 * Send an event with the new flow control
+					 * mode to the SIRQ module.
+					 */
+					EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
+						pAC, LogPortIndex);
 					EventParam.Para32[1] = (SK_U32)Val8;
 					if (SkGeSirqEvent(pAC, IoC,
 						SK_HWEV_SET_FLOWMODE,
 						EventParam) > 0) {
@@ -5643,19 +5452,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 						return (SK_PNMI_ERR_GENERAL);
 					}
 				}
 			}
-			else {
+			else { /* DualNet mode. */
+				
 				/*
-				 * Send an event with the new flow control
-				 * mode to the SIRQ module.
+				 * Send an event with the new link mode to
+				 * the SIRQ module.
 				 */
-				EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
-					pAC, LogPortIndex);
+				EventParam.Para32[0] = NetIndex;
 				EventParam.Para32[1] = (SK_U32)Val8;
-				if (SkGeSirqEvent(pAC, IoC,
-					SK_HWEV_SET_FLOWMODE, EventParam)
-					> 0) {
+				if (SkGeSirqEvent(pAC, IoC, SK_HWEV_SET_FLOWMODE,
+					EventParam) > 0) {
 
 					SK_ERR_LOG(pAC, SK_ERRCL_SW,
 						SK_PNMI_ERR044,
 						SK_PNMI_ERR044MSG);
@@ -5663,17 +5471,16 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					*pLen = 0;
 					return (SK_PNMI_ERR_GENERAL);
 				}
 			}
-			Offset += sizeof(char);
+			Offset++;
 			break;
 
 		case OID_SKGE_PHY_OPERATION_MODE :
-			/* Check the value range */
-			Val8 = *(pBuf + Offset);
+			/* Check the value range. */
 			if (Val8 == 0) {
-				/* mode of this port remains unchanged */
-				Offset += sizeof(char);
+				/* Mode of this port remains unchanged. */
+				Offset++;
 				break;
 			}
 			if (Val8 < SK_MS_MODE_AUTO ||
 				(LogPortIndex != 0 && Val8 > SK_MS_MODE_SLAVE) ||
@@ -5682,36 +5489,53 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				*pLen = 0;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
 
-			/* The preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				return (SK_PNMI_ERR_OK);
 			}
 
-			if (LogPortIndex == 0) {
+			if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
+				if (LogPortIndex == 0) {
+					/*
+					 * The virtual port consists of all currently
+					 * active ports. Find them and send an event
+					 * with new master/slave (role) mode to SIRQ.
+					 */
+					for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax;
+						PhysPortIndex ++) {
 
-				/*
-				 * The virtual port consists of all currently
-				 * active ports. Find them and send an event
-				 * with new master/slave (role) mode to SIRQ.
-				 */
-				for (PhysPortIndex = 0;
-					PhysPortIndex < PhysPortMax;
-					PhysPortIndex ++) {
+						if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
+							continue;
+						}
 
-					if (!pAC->Pnmi.Port[PhysPortIndex].
-						ActiveFlag) {
+						EventParam.Para32[0] = PhysPortIndex;
+						EventParam.Para32[1] = (SK_U32)Val8;
+						if (SkGeSirqEvent(pAC, IoC,
+							SK_HWEV_SET_ROLE,
+							EventParam) > 0) {
+
+							SK_ERR_LOG(pAC, SK_ERRCL_SW,
+								SK_PNMI_ERR042,
+								SK_PNMI_ERR042MSG);
 
-						continue;
+							*pLen = 0;
+							return (SK_PNMI_ERR_GENERAL);
+						}
 					}
-
-					EventParam.Para32[0] = PhysPortIndex;
+				}
+				else {
+					/*
+					 * Send an event with the new master/slave
+					 * (role) mode to the SIRQ module.
+					 */
+					EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
+						pAC, LogPortIndex);
 					EventParam.Para32[1] = (SK_U32)Val8;
 					if (SkGeSirqEvent(pAC, IoC,
-						SK_HWEV_SET_ROLE,
-						EventParam) > 0) {
+						SK_HWEV_SET_ROLE, EventParam) > 0) {
 
 						SK_ERR_LOG(pAC, SK_ERRCL_SW,
 							SK_PNMI_ERR042,
 							SK_PNMI_ERR042MSG);
@@ -5720,18 +5544,18 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 						return (SK_PNMI_ERR_GENERAL);
 					}
 				}
 			}
-			else {
+			else { /* DualNet mode. */
+
 				/*
-				 * Send an event with the new master/slave
-				 * (role) mode to the SIRQ module.
+				 * Send an event with the new link mode to
+				 * the SIRQ module.
 				 */
-				EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
-					pAC, LogPortIndex);
+				EventParam.Para32[0] = NetIndex;
 				EventParam.Para32[1] = (SK_U32)Val8;
-				if (SkGeSirqEvent(pAC, IoC,
-					SK_HWEV_SET_ROLE, EventParam) > 0) {
+				if (SkGeSirqEvent(pAC, IoC, SK_HWEV_SET_ROLE,
+					EventParam) > 0) {
 
 					SK_ERR_LOG(pAC, SK_ERRCL_SW,
 						SK_PNMI_ERR042,
 						SK_PNMI_ERR042MSG);
@@ -5739,18 +5563,15 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					*pLen = 0;
 					return (SK_PNMI_ERR_GENERAL);
 				}
 			}
-
-			Offset += sizeof(char);
+			Offset++;
 			break;
 
 		case OID_SKGE_SPEED_MODE:
-			/* Check the value range */
-			Val8 = *(pBuf + Offset);
+			/* Check the value range. */
 			if (Val8 == 0) {
-
-				Offset += sizeof(char);
+				Offset++;
 				break;
 			}
 			if (Val8 < (SK_LSPEED_AUTO) ||
 				(LogPortIndex != 0 && Val8 > (SK_LSPEED_1000MBPS)) ||
@@ -5759,31 +5580,51 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				*pLen = 0;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
 
-			/* The preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				return (SK_PNMI_ERR_OK);
 			}
 
-			if (LogPortIndex == 0) {
+			if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
+				if (LogPortIndex == 0) {
 
-				/*
-				 * The virtual port consists of all currently
-				 * active ports. Find them and send an event
-				 * with the new flow control mode to SIRQ.
-				 */
-				for (PhysPortIndex = 0;
-					PhysPortIndex < PhysPortMax;
-					PhysPortIndex ++) {
+					/*
+					 * The virtual port consists of all currently
+					 * active ports. Find them and send an event
+					 * with the new flow control mode to SIRQ.
+					 */
+					for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax;
+						PhysPortIndex ++) {
 
-					if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
+						if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
+							continue;
+						}
 
-						continue;
-					}
+						EventParam.Para32[0] = PhysPortIndex;
+						EventParam.Para32[1] = (SK_U32)Val8;
+						if (SkGeSirqEvent(pAC, IoC,
+							SK_HWEV_SET_SPEED,
+							EventParam) > 0) {
+
+							SK_ERR_LOG(pAC, SK_ERRCL_SW,
+								SK_PNMI_ERR045,
+								SK_PNMI_ERR045MSG);
 
-					EventParam.Para32[0] = PhysPortIndex;
+							*pLen = 0;
+							return (SK_PNMI_ERR_GENERAL);
+						}
+					}
+				}
+				else {
+					/*
+					 * Send an event with the new flow control
+					 * mode to the SIRQ module.
+					 */
+					EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
+						pAC, LogPortIndex);
 					EventParam.Para32[1] = (SK_U32)Val8;
 					if (SkGeSirqEvent(pAC, IoC,
 						SK_HWEV_SET_SPEED,
 						EventParam) > 0) {
@@ -5796,18 +5637,17 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 						return (SK_PNMI_ERR_GENERAL);
 					}
 				}
 			}
-			else {
+			else { /* DualNet mode. */
+				
 				/*
-				 * Send an event with the new flow control
-				 * mode to the SIRQ module.
+				 * Send an event with the new link mode to
+				 * the SIRQ module.
 				 */
-				EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
-					pAC, LogPortIndex);
+				EventParam.Para32[0] = NetIndex;
 				EventParam.Para32[1] = (SK_U32)Val8;
-				if (SkGeSirqEvent(pAC, IoC,
-					SK_HWEV_SET_SPEED,
+				if (SkGeSirqEvent(pAC, IoC, SK_HWEV_SET_SPEED,
 					EventParam) > 0) {
 
 					SK_ERR_LOG(pAC, SK_ERRCL_SW,
 						SK_PNMI_ERR045,
@@ -5816,25 +5656,27 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					*pLen = 0;
 					return (SK_PNMI_ERR_GENERAL);
 				}
 			}
-			Offset += sizeof(char);
+			Offset++;
 			break;
 
-		case OID_SKGE_MTU :
-			/* Check the value range */
-			Val32 = *(SK_U32*)(pBuf + Offset);
+		case OID_SKGE_MTU:
+			/* Check the value range. */
+			SK_PNMI_READ_U32((pBuf + Offset), Val32);
+
 			if (Val32 == 0) {
-				/* mtu of this port remains unchanged */
+				/* MTU of this port remains unchanged. */
 				Offset += sizeof(SK_U32);
 				break;
 			}
+
 			if (SK_DRIVER_PRESET_MTU(pAC, IoC, NetIndex, Val32) != 0) {
 				*pLen = 0;
 				return (SK_PNMI_ERR_BAD_VALUE);
 			}
 
-			/* The preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 				return (SK_PNMI_ERR_OK);
 			}
 
@@ -5843,118 +5685,71 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			}
 
 			Offset += sizeof(SK_U32);
 			break;
-		
+
 #ifdef SK_PHY_LP_MODE
 		case OID_SKGE_PHY_LP_MODE:
-			/* The preset ends here */
+			/* The PRESET ends here. */
 			if (Action == SK_PNMI_PRESET) {
 
 				return (SK_PNMI_ERR_OK);
 			}
 
-			if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+			if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNet mode. */
 				if (LogPortIndex == 0) {
 					Offset = 0;
 					continue;
 				}
-				else {
-					/* Set value for physical ports */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
-
-					switch (*(pBuf + Offset)) {
-						case 0:
-							/* If LowPowerMode is active, we can leave it. */
-							if (pAC->GIni.GP[PhysPortIndex].PPhyPowerState) {
-
-								Val32 = SkGmLeaveLowPowerMode(pAC, IoC, PhysPortIndex);
-								
-								if (pAC->GIni.GP[PhysPortIndex].PPhyPowerState < 3)	{
-									
-									SkDrvInitAdapter(pAC);
-								}
-								break;
-							}
-							else {
-								*pLen = 0;
-								return (SK_PNMI_ERR_GENERAL);
-							}
-						case 1:
-						case 2:
-						case 3:
-						case 4:
-							/* If no LowPowerMode is active, we can enter it. */
-							if (!pAC->GIni.GP[PhysPortIndex].PPhyPowerState) {
-
-								if ((*(pBuf + Offset)) < 3)	{
-								
-									SkDrvDeInitAdapter(pAC);
-								}
-
-								Val32 = SkGmEnterLowPowerMode(pAC, IoC, PhysPortIndex, *pBuf);
-								break;
-							}
-							else {
-								*pLen = 0;
-								return (SK_PNMI_ERR_GENERAL);
-							}
-						default:
-							*pLen = 0;
-							return (SK_PNMI_ERR_BAD_VALUE);
-					}
-				}
 			}
-			else { /* DualNetMode */
-				
-				switch (*(pBuf + Offset)) {
-					case 0:
-						/* If we are in a LowPowerMode, we can leave it. */
-						if (pAC->GIni.GP[PhysPortIndex].PPhyPowerState) {
+			/* Set value for physical port. */
+			PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
+			CurrentPhyPowerState = pAC->GIni.GP[PhysPortIndex].PPhyPowerState;
 
-							Val32 = SkGmLeaveLowPowerMode(pAC, IoC, PhysPortIndex);
-							
-							if (pAC->GIni.GP[PhysPortIndex].PPhyPowerState < 3)	{
+			switch (Val8) {
+				case PHY_PM_OPERATIONAL_MODE:
+					/* If LowPowerMode is active, we can leave it. */
+					if (CurrentPhyPowerState) {
 
-								SkDrvInitAdapter(pAC);
-							}
-							break;
-						}
-						else {
-							*pLen = 0;
-							return (SK_PNMI_ERR_GENERAL);
-						}
-					
-					case 1:
-					case 2:
-					case 3:
-					case 4:
-						/* If we are not already in LowPowerMode, we can enter it. */
-						if (!pAC->GIni.GP[PhysPortIndex].PPhyPowerState) {
-
-							if ((*(pBuf + Offset)) < 3)	{
-
-								SkDrvDeInitAdapter(pAC);
-							}
-							else {
-
-								Val32 = SkGmEnterLowPowerMode(pAC, IoC, PhysPortIndex, *pBuf);
-							}
-							break;
-						}
-						else {
-							*pLen = 0;
-							return (SK_PNMI_ERR_GENERAL);
+						Val32 = SkGmLeaveLowPowerMode(pAC, IoC, PhysPortIndex);
+						
+						if ((CurrentPhyPowerState == PHY_PM_DEEP_SLEEP) ||
+							(CurrentPhyPowerState == PHY_PM_IEEE_POWER_DOWN)) {
+							
+							SkDrvInitAdapter(pAC);
 						}
-					
-					default:
+						break;
+					}
+					else {
 						*pLen = 0;
-						return (SK_PNMI_ERR_BAD_VALUE);
-				}
+						return (SK_PNMI_ERR_GENERAL);
+					}
+				case PHY_PM_DEEP_SLEEP:
+				case PHY_PM_IEEE_POWER_DOWN:
+					/* If no LowPowerMode is active, we can enter it. */
+					if (!CurrentPhyPowerState) {
+						SkDrvDeInitAdapter(pAC);
+					}
+
+				case PHY_PM_ENERGY_DETECT:
+				case PHY_PM_ENERGY_DETECT_PLUS:
+					/* If no LowPowerMode is active, we can enter it. */
+					if (!CurrentPhyPowerState) {
+
+						Val32 = SkGmEnterLowPowerMode(pAC, IoC, PhysPortIndex, *pBuf);
+						break;
+					}
+					else {
+						*pLen = 0;
+						return (SK_PNMI_ERR_GENERAL);
+					}
+				default:
+					*pLen = 0;
+					return (SK_PNMI_ERR_BAD_VALUE);
 			}
-			Offset += sizeof(SK_U8);
+			Offset++;
 			break;
-#endif
+#endif /* SK_PHY_LP_MODE */
 
 		default:
             SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_ERR,
                 ("MacPrivateConf: Unknown OID should be handled before set"));
@@ -6002,16 +5797,13 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	unsigned int	Index;
 	unsigned int	Limit;
 	unsigned int	Offset;
 	unsigned int	Entries;
-
 	
-	/*
-	 * Calculate instance if wished.
-	 */
-	/* XXX Not yet implemented. Return always an empty table. */
+	/* Not implemented yet. Return always an empty table. */
 	Entries = 0;
 
+	/* Calculate instance if wished. */
 	if ((Instance != (SK_U32)(-1))) {
 
 		if ((Instance < 1) || (Instance > Entries)) {
 
@@ -6026,14 +5818,12 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		Index = 0;
 		Limit = Entries;
 	}
 
-	/*
-	 * Get/Set value
-	*/
+	/* GET/SET value. */
 	if (Action == SK_PNMI_GET) {
 
-		for (Offset=0; Index < Limit; Index ++) {
+		for (Offset = 0; Index < Limit; Index ++) {
 
 			switch (Id) {
 
 			case OID_SKGE_RLMT_MONITOR_INDEX:
@@ -6053,34 +5843,31 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 		*pLen = Offset;
 	}
 	else {
-		/* Only MONITOR_ADMIN can be set */
+		/* Only MONITOR_ADMIN can be set. */
 		if (Id != OID_SKGE_RLMT_MONITOR_ADMIN) {
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_READ_ONLY);
 		}
 
-		/* Check if the length is plausible */
+		/* Check if the length is plausible. */
 		if (*pLen < (Limit - Index)) {
 
 			return (SK_PNMI_ERR_TOO_SHORT);
 		}
-		/* Okay, we have a wide value range */
+		/* Okay, we have a wide value range. */
 		if (*pLen != (Limit - Index)) {
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_BAD_VALUE);
 		}
-/*
-		for (Offset=0; Index < Limit; Index ++) {
-		}
-*/
-/*
- * XXX Not yet implemented. Return always BAD_VALUE, because the table
- * is empty.
- */
+
+		/*
+		 * Not yet implemented. Return always BAD_VALUE,
+		 * because the table is empty.
+		 */
 		*pLen = 0;
 		return (SK_PNMI_ERR_BAD_VALUE);
 	}
 
@@ -6119,30 +5906,29 @@ char *pBuf)		/* Buffer used for the mana
 	*pBuf = 0;
 	PortActiveFlag = SK_FALSE;
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	
-	for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax;
-		PhysPortIndex ++) {
+	for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax; PhysPortIndex ++) {
 
 		pPrt = &pAC->GIni.GP[PhysPortIndex];
 
-		/* Check if the physical port is active */
+		/* Check if the physical port is active. */
 		if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
-
 			continue;
 		}
 
 		PortActiveFlag = SK_TRUE;
 
 		switch (Id) {
 
 		case OID_SKGE_PHY_TYPE:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 				Val32 = pPrt->PhyType;
 				SK_PNMI_STORE_U32(pBuf, Val32);
 				continue;
 			}
+			break;
 
 		case OID_SKGE_LINK_CAP:
 
 			/*
@@ -6154,74 +5940,69 @@ char *pBuf)		/* Buffer used for the mana
 			*pBuf |= pPrt->PLinkCap;
 			break;
 
 		case OID_SKGE_LINK_MODE:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PLinkModeConf;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different link
-			 * mode than the first one we return a value that
-			 * indicates that the link mode is indeterminated.
+			 * If we find an active port with a different link mode
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != pPrt->PLinkModeConf) {
 
 				*pBuf = SK_LMODE_INDETERMINATED;
 			}
 			break;
 
 		case OID_SKGE_LINK_MODE_STATUS:
-			/* Get the link mode of the physical port */
+			/* Get the link mode of the physical port. */
 			Val8 = CalculateLinkModeStatus(pAC, IoC, PhysPortIndex);
 
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = Val8;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different link
-			 * mode status than the first one we return a value
-			 * that indicates that the link mode status is
-			 * indeterminated.
+			 * If we find an active port with a different link mode status
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != Val8) {
 
 				*pBuf = SK_LMODE_STAT_INDETERMINATED;
 			}
 			break;
 
 		case OID_SKGE_LINK_STATUS:
-			/* Get the link status of the physical port */
+			/* Get the link status of the physical port. */
 			Val8 = CalculateLinkStatus(pAC, IoC, PhysPortIndex);
 
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = Val8;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different link
-			 * status than the first one, we return a value
-			 * that indicates that the link status is
-			 * indeterminated.
+			 * If we find an active port with a different link status
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != Val8) {
 
 				*pBuf = SK_PNMI_RLMT_LSTAT_INDETERMINATED;
 			}
 			break;
 
 		case OID_SKGE_FLOWCTRL_CAP:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PFlowCtrlCap;
 				continue;
@@ -6234,48 +6015,45 @@ char *pBuf)		/* Buffer used for the mana
 			*pBuf |= pPrt->PFlowCtrlCap;
 			break;
 
 		case OID_SKGE_FLOWCTRL_MODE:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PFlowCtrlMode;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different flow
-			 * control mode than the first one, we return a value
-			 * that indicates that the mode is indeterminated.
+			 * If we find an active port with a different flow-control mode
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != pPrt->PFlowCtrlMode) {
 
 				*pBuf = SK_FLOW_MODE_INDETERMINATED;
 			}
 			break;
 
 		case OID_SKGE_FLOWCTRL_STATUS:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PFlowCtrlStatus;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different flow
-			 * control status than the first one, we return a
-			 * value that indicates that the status is
-			 * indeterminated.
+			 * If we find an active port with a different flow-control status
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != pPrt->PFlowCtrlStatus) {
 
 				*pBuf = SK_FLOW_STAT_INDETERMINATED;
 			}
 			break;
 		
 		case OID_SKGE_PHY_OPERATION_CAP:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PMSCap;
 				continue;
@@ -6288,78 +6066,72 @@ char *pBuf)		/* Buffer used for the mana
 			*pBuf |= pPrt->PMSCap;
 			break;
 
 		case OID_SKGE_PHY_OPERATION_MODE:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PMSMode;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different master/
-			 * slave mode than the first one, we return a value
-			 * that indicates that the mode is indeterminated.
+			 * If we find an active port with a different master/slave mode
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != pPrt->PMSMode) {
 
 				*pBuf = SK_MS_MODE_INDETERMINATED;
 			}
 			break;
 
 		case OID_SKGE_PHY_OPERATION_STATUS:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PMSStatus;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different master/
-			 * slave status than the first one, we return a
-			 * value that indicates that the status is
-			 * indeterminated.
+			 * If we find an active port with a different master/slave status
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != pPrt->PMSStatus) {
 
 				*pBuf = SK_MS_STAT_INDETERMINATED;
 			}
 			break;
 		
 		case OID_SKGE_SPEED_MODE:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PLinkSpeed;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different flow
-			 * control mode than the first one, we return a value
-			 * that indicates that the mode is indeterminated.
+			 * If we find an active port with a different link speed
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != pPrt->PLinkSpeed) {
 
 				*pBuf = SK_LSPEED_INDETERMINATED;
 			}
 			break;
 		
 		case OID_SKGE_SPEED_STATUS:
-			/* Check if it is the first active port */
+			/* Check if it is the first active port. */
 			if (*pBuf == 0) {
 
 				*pBuf = pPrt->PLinkSpeedUsed;
 				continue;
 			}
 
 			/*
-			 * If we find an active port with a different flow
-			 * control status than the first one, we return a
-			 * value that indicates that the status is
-			 * indeterminated.
+			 * If we find an active port with a different link speed used
+			 * than the first one we return indeterminated.
 			 */
 			if (*pBuf != pPrt->PLinkSpeedUsed) {
 
 				*pBuf = SK_LSPEED_STAT_INDETERMINATED;
@@ -6367,11 +6139,9 @@ char *pBuf)		/* Buffer used for the mana
 			break;
 		}
 	}
 
-	/*
-	 * If no port is active return an indeterminated answer
-	 */
+	/* If no port is active return an indeterminated answer. */
 	if (!PortActiveFlag) {
 
 		switch (Id) {
 
@@ -6486,18 +6256,17 @@ SK_IOC IoC,			/* IO context handle */
 unsigned int PhysPortIndex)	/* Physical port index */
 {
 	SK_U8	Result;
 
-	/* Get the current mode, which can be full or half duplex */
+	/* Get the current mode, which can be full or half duplex. */
 	Result = pAC->GIni.GP[PhysPortIndex].PLinkModeStatus;
 
-	/* Check if no valid mode could be found (link is down) */
+	/* Check if no valid mode could be found (link is down). */
 	if (Result < SK_LMODE_STAT_HALF) {
 
 		Result = SK_LMODE_STAT_UNKNOWN;
 	}
 	else if (pAC->GIni.GP[PhysPortIndex].PLinkMode >= SK_LMODE_AUTOHALF) {
-
 		/*
 		 * Auto-negotiation was used to bring up the link. Change
 		 * the already found duplex status that it indicates
 		 * auto-negotiation was involved.
@@ -6540,37 +6309,33 @@ unsigned int *pKeyNo)	/* Number of keys 
 	unsigned int		Offset;
 	int			Index;
 	int			Ret;
 
-
 	SK_MEMSET(pKeyArr, 0, KeyArrLen);
 
-	/*
-	 * Get VPD key list
-	 */
+	/* Get VPD key list. */
 	Ret = VpdKeys(pAC, IoC, (char *)&BufKeys, (int *)&BufKeysLen,
 		(int *)pKeyNo);
+	
 	if (Ret > 0) {
 
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR014,
-			SK_PNMI_ERR014MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR014, SK_PNMI_ERR014MSG);
 
 		return (SK_PNMI_ERR_GENERAL);
 	}
-	/* If no keys are available return now */
+	/* If no keys are available return now. */
 	if (*pKeyNo == 0 || BufKeysLen == 0) {
 
 		return (SK_PNMI_ERR_OK);
 	}
 	/*
 	 * If the key list is too long for us trunc it and give a
 	 * errorlog notification. This case should not happen because
-	 * the maximum number of keys is limited due to RAM limitations
+	 * the maximum number of keys is limited due to RAM limitations.
 	 */
 	if (*pKeyNo > SK_PNMI_VPD_ENTRIES) {
 
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR015,
-			SK_PNMI_ERR015MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR015, SK_PNMI_ERR015MSG);
 
 		*pKeyNo = SK_PNMI_VPD_ENTRIES;
 	}
 
@@ -6581,16 +6346,14 @@ unsigned int *pKeyNo)	/* Number of keys 
 	for (Index = 0, StartOffset = 0, Offset = 0; Offset < BufKeysLen;
 		Offset ++) {
 
 		if (BufKeys[Offset] != 0) {
-
 			continue;
 		}
 
 		if (Offset - StartOffset > SK_PNMI_VPD_KEY_SIZE) {
 
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR016,
-				SK_PNMI_ERR016MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR016, SK_PNMI_ERR016MSG);
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
 		SK_STRNCPY(pKeyArr + Index * SK_PNMI_VPD_KEY_SIZE,
@@ -6599,9 +6362,9 @@ unsigned int *pKeyNo)	/* Number of keys 
 		Index ++;
 		StartOffset = Offset + 1;
 	}
 
-	/* Last key not zero terminated? Get it anyway */
+	/* Last key not zero terminated? Get it anyway. */
 	if (StartOffset < Offset) {
 
 		SK_STRNCPY(pKeyArr + Index * SK_PNMI_VPD_KEY_SIZE,
 			&BufKeys[StartOffset], SK_PNMI_VPD_KEY_SIZE);
@@ -6628,21 +6391,20 @@ SK_AC *pAC,	/* Pointer to adapter contex
 SK_IOC IoC)	/* IO context handle */
 {
 	SK_EVPARA	EventParam;
 
-
 	/* Was the module already updated during the current PNMI call? */
 	if (pAC->Pnmi.SirqUpdatedFlag > 0) {
 
 		return (SK_PNMI_ERR_OK);
 	}
 
-	/* Send an synchronuous update event to the module */
+	/* Send an synchronuous update event to the module. */
 	SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
-	if (SkGeSirqEvent(pAC, IoC, SK_HWEV_UPDATE_STAT, EventParam) > 0) {
+	
+	if (SkGeSirqEvent(pAC, IoC, SK_HWEV_UPDATE_STAT, EventParam)) {
 
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR047,
-			SK_PNMI_ERR047MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR047, SK_PNMI_ERR047MSG);
 
 		return (SK_PNMI_ERR_GENERAL);
 	}
 
@@ -6668,23 +6430,21 @@ SK_IOC IoC,	/* IO context handle */
 SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
 {
 	SK_EVPARA	EventParam;
 
-
 	/* Was the module already updated during the current PNMI call? */
 	if (pAC->Pnmi.RlmtUpdatedFlag > 0) {
 
 		return (SK_PNMI_ERR_OK);
 	}
 
-	/* Send an synchronuous update event to the module */
+	/* Send an synchronuous update event to the module. */
 	SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
 	EventParam.Para32[0] = NetIndex;
 	EventParam.Para32[1] = (SK_U32)-1;
 	if (SkRlmtEvent(pAC, IoC, SK_RLMT_STATS_UPDATE, EventParam) > 0) {
 
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR048,
-			SK_PNMI_ERR048MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR048, SK_PNMI_ERR048MSG);
 
 		return (SK_PNMI_ERR_GENERAL);
 	}
 
@@ -6720,22 +6480,22 @@ unsigned int LastMac)	/* Index of the la
 
 		return (SK_PNMI_ERR_OK);
 	}
 
-	/* Send an update command to all MACs specified */
+	/* Send an update command to all MACs specified. */
 	for (MacIndex = FirstMac; MacIndex <= LastMac; MacIndex ++) {
 
 		/*
 		 * 2002-09-13 pweber:	Freeze the current SW counters.
 		 *                      (That should be done as close as
 		 *                      possible to the update of the
-		 *                      HW counters)
+		 *                      HW counters).
 		 */
 		if (pAC->GIni.GIMacType == SK_MAC_XMAC) {
 			pAC->Pnmi.BufPort[MacIndex] = pAC->Pnmi.Port[MacIndex];
 		}
 			
-		/* 2002-09-13 pweber:  Update the HW counter  */
+		/* 2002-09-13 pweber:  Update the HW counter.  */
 		if (pAC->GIni.GIFunc.pFnMacUpdateStats(pAC, IoC, MacIndex) != 0) {
 
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -6771,21 +6531,21 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	unsigned int	PhysPortMax;
 	SK_U64			Val = 0;
 
 
-	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {	/* Dual net mode */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {	/* DualNet mode. */
 
 		PhysPortIndex = NetIndex;
 		
 		Val = GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
 	}
-	else {	/* Single Net mode */
+	else {	/* SingleNet mode. */
 
 		if (LogPortIndex == 0) {
 
 			PhysPortMax = pAC->GIni.GIMacsFound;
 
-			/* Add counter of all active ports */
+			/* Add counter of all active ports. */
 			for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax;
 				PhysPortIndex ++) {
 
 				if (pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
@@ -6793,13 +6553,13 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					Val += GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
 				}
 			}
 
-			/* Correct value because of port switches */
+			/* Correct value because of port switches. */
 			Val += pAC->Pnmi.VirtualCounterOffset[StatIndex];
 		}
 		else {
-			/* Get counter value of physical port */
+			/* Get counter value of physical port. */
 			PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
 			
 			Val = GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
 		}
@@ -6843,9 +6603,9 @@ unsigned int StatIndex)		/* Index to sta
 	pPrt = &pAC->GIni.GP[PhysPortIndex];
 	
 	MacType = pAC->GIni.GIMacType;
 	
-	/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+	/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort). */
 	if (MacType == SK_MAC_XMAC) {
 		pPnmiPrt = &pAC->Pnmi.BufPort[PhysPortIndex];
 	}
 	else {
@@ -6911,9 +6671,9 @@ unsigned int StatIndex)		/* Index to sta
 
 	case SK_PNMI_HTX_BURST:
 	case SK_PNMI_HTX_EXCESS_DEF:
 	case SK_PNMI_HTX_CARRIER:
-		/* Not supported by GMAC */
+		/* Not supported by GMAC. */
 		if (MacType == SK_MAC_GMAC) {
 			return (Val);
 		}
 
@@ -6923,9 +6683,9 @@ unsigned int StatIndex)		/* Index to sta
 		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 
 	case SK_PNMI_HTX_MACC:
-		/* GMAC only supports PAUSE MAC control frames */
+		/* GMAC only supports PAUSE MAC control frames. */
 		if (MacType == SK_MAC_GMAC) {
 			HelpIndex = SK_PNMI_HTX_PMACC;
 		}
 		else {
@@ -6940,9 +6700,9 @@ unsigned int StatIndex)		/* Index to sta
 		break;
 
 	case SK_PNMI_HTX_COL:
 	case SK_PNMI_HRX_UNDERSIZE:
-		/* Not supported by XMAC */
+		/* Not supported by XMAC. */
 		if (MacType == SK_MAC_XMAC) {
 			return (Val);
 		}
 
@@ -6952,9 +6712,9 @@ unsigned int StatIndex)		/* Index to sta
 		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 
 	case SK_PNMI_HTX_DEFFERAL:
-		/* Not supported by GMAC */
+		/* Not supported by GMAC. */
 		if (MacType == SK_MAC_GMAC) {
 			return (Val);
 		}
 		
@@ -6970,18 +6730,18 @@ unsigned int StatIndex)		/* Index to sta
 			LowVal = 0;
 			HighVal = 0;
 		}
 		else {
-			/* Otherwise get contents of hardware register */
+			/* Otherwise get contents of hardware register. */
 			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
 										  StatAddr[StatIndex][MacType].Reg,
 										  &LowVal);
 			HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		}
 		break;
 
 	case SK_PNMI_HRX_BADOCTET:
-		/* Not supported by XMAC */
+		/* Not supported by XMAC. */
 		if (MacType == SK_MAC_XMAC) {
 			return (Val);
 		}
 
@@ -6998,9 +6758,9 @@ unsigned int StatIndex)		/* Index to sta
 	case SK_PNMI_HRX_BADOCTETLOW:
 		return (Val);
 
 	case SK_PNMI_HRX_LONGFRAMES:
-		/* For XMAC the SW counter is managed by PNMI */
+		/* For XMAC the SW counter is managed by PNMI. */
 		if (MacType == SK_MAC_XMAC) {
 			return (pPnmiPrt->StatRxLongFrameCts);
 		}
 		
@@ -7018,9 +6778,9 @@ unsigned int StatIndex)		/* Index to sta
 		
 		Val = (((SK_U64)HighVal << 32) | (SK_U64)LowVal);
 
 		if (MacType == SK_MAC_GMAC) {
-			/* For GMAC the SW counter is additionally managed by PNMI */
+			/* For GMAC the SW counter is additionally managed by PNMI. */
 			Val += pPnmiPrt->StatRxFrameTooLongCts;
 		}
 		else {
 			/*
@@ -7036,22 +6796,21 @@ unsigned int StatIndex)		/* Index to sta
 		HighVal = (SK_U32)(Val >> 32);
 		break;
 		
 	case SK_PNMI_HRX_SHORTS:
-		/* Not supported by GMAC */
+		/* Not supported by GMAC. */
 		if (MacType == SK_MAC_GMAC) {
 			/* GM_RXE_FRAG?? */
 			return (Val);
 		}
 		
 		/*
-		 * XMAC counts short frame errors even if link down (#10620)
-		 *
-		 * If link-down the counter remains constant
+		 * XMAC counts short frame errors even if link down (#10620).
+		 * If the link is down, the counter remains constant.
 		 */
 		if (pPrt->PLinkModeStatus != SK_LMODE_STAT_UNKNOWN) {
 
-			/* Otherwise get incremental difference */
+			/* Otherwise get incremental difference. */
 			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
 										  StatAddr[StatIndex][MacType].Reg,
 										  &LowVal);
 			HighVal = pPnmiPrt->CounterHigh[StatIndex];
@@ -7072,9 +6831,9 @@ unsigned int StatIndex)		/* Index to sta
 	case SK_PNMI_HRX_CARRIER:
 	case SK_PNMI_HRX_IRLENGTH:
 	case SK_PNMI_HRX_SYMBOL:
 	case SK_PNMI_HRX_CEXT:
-		/* Not supported by GMAC */
+		/* Not supported by GMAC. */
 		if (MacType == SK_MAC_GMAC) {
 			return (Val);
 		}
 
@@ -7084,9 +6843,9 @@ unsigned int StatIndex)		/* Index to sta
 		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 
 	case SK_PNMI_HRX_PMACC_ERR:
-		/* For GMAC the SW counter is managed by PNMI */
+		/* For GMAC the SW counter is managed by PNMI. */
 		if (MacType == SK_MAC_GMAC) {
 			return (pPnmiPrt->StatRxPMaccErr);
 		}
 		
@@ -7095,33 +6854,35 @@ unsigned int StatIndex)		/* Index to sta
 									  &LowVal);
 		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 
-	/* SW counter managed by PNMI */
+	/* SW counter managed by PNMI. */
 	case SK_PNMI_HTX_SYNC:
 		LowVal = (SK_U32)pPnmiPrt->StatSyncCts;
 		HighVal = (SK_U32)(pPnmiPrt->StatSyncCts >> 32);
 		break;
 
-	/* SW counter managed by PNMI */
+	/* SW counter managed by PNMI. */
 	case SK_PNMI_HTX_SYNC_OCTET:
 		LowVal = (SK_U32)pPnmiPrt->StatSyncOctetsCts;
 		HighVal = (SK_U32)(pPnmiPrt->StatSyncOctetsCts >> 32);
 		break;
 
 	case SK_PNMI_HRX_FCS:
 		/*
-		 * Broadcom filters FCS errors and counts it in
-		 * Receive Error Counter register
+		 * Broadcom filters FCS errors and counts them in
+		 * Receive Error Counter register.
 		 */
 		if (pPrt->PhyType == SK_PHY_BCOM) {
-			/* do not read while not initialized (PHY_READ hangs!)*/
+#ifdef GENESIS
+			/* Do not read while not initialized (PHY_READ hangs!). */
 			if (pPrt->PState != SK_PRT_RESET) {
 				SkXmPhyRead(pAC, IoC, PhysPortIndex, PHY_BCOM_RE_CTR, &Word);
 				
 				LowVal = Word;
 			}
 			HighVal = pPnmiPrt->CounterHigh[StatIndex];
+#endif /* GENESIS */
 		}
 		else {
 			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
 										  StatAddr[StatIndex][MacType].Reg,
@@ -7139,9 +6900,9 @@ unsigned int StatIndex)		/* Index to sta
 	}
 
 	Val = (((SK_U64)HighVal << 32) | (SK_U64)LowVal);
 
-	/* Correct value because of possible XMAC reset. XMAC Errata #2 */
+	/* Correct value because of possible XMAC reset (XMAC Errata #2). */
 	Val += pPnmiPrt->CounterOffset[StatIndex];
 
 	return (Val);
 }
@@ -7164,32 +6925,31 @@ SK_U32 NetIndex)
 {
 	unsigned int	PhysPortIndex;
 	SK_EVPARA	EventParam;
 
-
 	SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
 
-	/* Notify sensor module */
+	/* Notify sensor module. */
 	SkEventQueue(pAC, SKGE_I2C, SK_I2CEV_CLEAR, EventParam);
 
-	/* Notify RLMT module */
+	/* Notify RLMT module. */
 	EventParam.Para32[0] = NetIndex;
 	EventParam.Para32[1] = (SK_U32)-1;
 	SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STATS_CLEAR, EventParam);
 	EventParam.Para32[1] = 0;
 
-	/* Notify SIRQ module */
+	/* Notify SIRQ module. */
 	SkEventQueue(pAC, SKGE_HWAC, SK_HWEV_CLEAR_STAT, EventParam);
 
-	/* Notify CSUM module */
+	/* Notify CSUM module. */
 #ifdef SK_USE_CSUM
 	EventParam.Para32[0] = NetIndex;
 	EventParam.Para32[1] = (SK_U32)-1;
 	SkEventQueue(pAC, SKGE_CSUM, SK_CSUM_EVENT_CLEAR_PROTO_STATS,
 		EventParam);
 #endif /* SK_USE_CSUM */
 	
-	/* Clear XMAC statistic */
+	/* Clear XMAC statistics. */
 	for (PhysPortIndex = 0; PhysPortIndex <
 		(unsigned int)pAC->GIni.GIMacsFound; PhysPortIndex ++) {
 
 		(void)pAC->GIni.GIFunc.pFnMacResetCounter(pAC, IoC, PhysPortIndex);
@@ -7214,15 +6974,15 @@ SK_U32 NetIndex)
 				  StatRxPMaccErr, 0, sizeof(pAC->Pnmi.Port[
 			PhysPortIndex].StatRxPMaccErr));
 	}
 
-	/*
-	 * Clear local statistics
-	 */
+	/* Clear local statistics. */
 	SK_MEMSET((char *)&pAC->Pnmi.VirtualCounterOffset, 0,
 		  sizeof(pAC->Pnmi.VirtualCounterOffset));
+	
 	pAC->Pnmi.RlmtChangeCts = 0;
 	pAC->Pnmi.RlmtChangeTime = 0;
+	
 	SK_MEMSET((char *)&pAC->Pnmi.RlmtChangeEstimate.EstValue[0], 0,
 		sizeof(pAC->Pnmi.RlmtChangeEstimate.EstValue));
 	pAC->Pnmi.RlmtChangeEstimate.EstValueIndex = 0;
 	pAC->Pnmi.RlmtChangeEstimate.Estimate = 0;
@@ -7257,25 +7017,23 @@ PNMI_STATIC char* GetTrapEntry(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_U32 TrapId,		/* SNMP ID of the trap */
 unsigned int Size)	/* Space needed for trap entry */
 {
-	unsigned int		BufPad = pAC->Pnmi.TrapBufPad;
-	unsigned int		BufFree = pAC->Pnmi.TrapBufFree;
-	unsigned int		Beg = pAC->Pnmi.TrapQueueBeg;
-	unsigned int		End = pAC->Pnmi.TrapQueueEnd;
+	unsigned int	BufPad = pAC->Pnmi.TrapBufPad;
+	unsigned int	BufFree = pAC->Pnmi.TrapBufFree;
+	unsigned int	Beg = pAC->Pnmi.TrapQueueBeg;
+	unsigned int	End = pAC->Pnmi.TrapQueueEnd;
 	char			*pBuf = &pAC->Pnmi.TrapBuf[0];
 	int			Wrap;
-	unsigned int		NeededSpace;
-	unsigned int		EntrySize;
+	unsigned int	NeededSpace;
+	unsigned int	EntrySize;
 	SK_U32			Val32;
 	SK_U64			Val64;
 
-
-	/* Last byte of entry will get a copy of the entry length */
+	/* Last byte of entry will get a copy of the entry length. */
 	Size ++;
 
-	/*
-	 * Calculate needed buffer space */
+	/* Calculate needed buffer space. */
 	if (Beg >= Size) {
 
 		NeededSpace = Size;
 		Wrap = SK_FALSE;
@@ -7288,9 +7046,9 @@ unsigned int Size)	/* Space needed for t
 	/*
 	 * Check if enough buffer space is provided. Otherwise
 	 * free some entries. Leave one byte space between begin
 	 * and end of buffer to make it possible to detect whether
-	 * the buffer is full or empty
+	 * the buffer is full or empty.
 	 */
 	while (BufFree < NeededSpace + 1) {
 
 		if (End == 0) {
@@ -7327,15 +7085,15 @@ unsigned int Size)	/* Space needed for t
 		Beg = Beg - Size;
 	}
 	BufFree -= NeededSpace;
 
-	/* Save the current offsets */
+	/* Save the current offsets. */
 	pAC->Pnmi.TrapQueueBeg = Beg;
 	pAC->Pnmi.TrapQueueEnd = End;
 	pAC->Pnmi.TrapBufPad = BufPad;
 	pAC->Pnmi.TrapBufFree = BufFree;
 
-	/* Initialize the trap entry */
+	/* Initialize the trap entry. */
 	*(pBuf + Beg + Size - 1) = (char)Size;
 	*(pBuf + Beg) = (char)Size;
 	Val32 = (pAC->Pnmi.TrapUnique) ++;
 	SK_PNMI_STORE_U32(pBuf + Beg + 1, Val32);
@@ -7368,9 +7126,8 @@ char *pDstBuf)		/* Buffer to which the q
 	char		*pBuf = &pAC->Pnmi.TrapBuf[0];
 	unsigned int	Len;
 	unsigned int	DstOff = 0;
 
-
 	while (Trap != End) {
 
 		Len = (unsigned int)*(pBuf + Trap);
 
@@ -7413,9 +7170,8 @@ unsigned int *pEntries)	/* Returns numbe
 	unsigned int	Len;
 	unsigned int	Entries = 0;
 	unsigned int	TotalLen = 0;
 
-
 	while (Trap != End) {
 
 		Len = (unsigned int)*(pBuf + Trap);
 		TotalLen += Len - 1;
@@ -7470,16 +7226,16 @@ unsigned int SensorIndex)	/* Index of se
 	unsigned int	Offset;
 	unsigned int	DescrLen;
 	SK_U32		Val32;
 
-
-	/* Get trap buffer entry */
+	/* Get trap buffer entry. */
 	DescrLen = SK_STRLEN(pAC->I2c.SenTable[SensorIndex].SenDesc);
+	
 	pBuf = GetTrapEntry(pAC, TrapId,
 		SK_PNMI_TRAP_SENSOR_LEN_BASE + DescrLen);
 	Offset = SK_PNMI_TRAP_SIMPLE_LEN;
 
-	/* Store additionally sensor trap related data */
+	/* Store additionally sensor trap related data. */
 	Val32 = OID_SKGE_SENSOR_INDEX;
 	SK_PNMI_STORE_U32(pBuf + Offset, Val32);
 	*(pBuf + Offset + 4) = 4;
 	Val32 = (SK_U32)SensorIndex;
@@ -7522,9 +7278,8 @@ unsigned int ActiveMac)	/* Index (0..n) 
 {
 	char	*pBuf;
 	SK_U32	Val32;
 
-
 	pBuf = GetTrapEntry(pAC, OID_SKGE_TRAP_RLMT_CHANGE_PORT,
 		SK_PNMI_TRAP_RLMT_CHANGE_LEN);
 
 	Val32 = OID_SKGE_RLMT_PORT_ACTIVE;
@@ -7550,9 +7305,8 @@ unsigned int PortIndex)	/* Index of the 
 {
 	char	*pBuf;
 	SK_U32	Val32;
 
-
 	pBuf = GetTrapEntry(pAC, TrapId, SK_PNMI_TRAP_RLMT_PORT_LEN);
 
 	Val32 = OID_SKGE_RLMT_PORT_INDEX;
 	SK_PNMI_STORE_U32(pBuf + SK_PNMI_TRAP_SIMPLE_LEN, Val32);
@@ -7570,14 +7324,13 @@ unsigned int PortIndex)	/* Index of the 
  * Returns:
  *	Nothing
  */
 PNMI_STATIC void CopyMac(
-char *pDst,		/* Pointer to destination buffer */
+char		*pDst,	/* Pointer to destination buffer */
 SK_MAC_ADDR *pMac)	/* Pointer of Source */
 {
 	int	i;
 
-
 	for (i = 0; i < sizeof(SK_MAC_ADDR); i ++) {
 
 		*(pDst + i) = pMac->a[i];
 	}
@@ -7615,19 +7368,16 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 {
 	
 	SK_U32	RetCode = SK_PNMI_ERR_GENERAL;
 
-	/*
-	 * Check instance. We only handle single instance variables
-	 */
+	/* Check instance. We only handle single instance variables. */
 	if (Instance != (SK_U32)(-1) && Instance != 1) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_INST);
 	}
 	
-    
-    /* Check length */
+    /* Check length. */
     switch (Id) {
 
     case OID_PNP_CAPABILITIES:
         if (*pLen < sizeof(SK_PNP_CAPABILITIES)) {
@@ -7663,35 +7413,34 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
         }
         break;
     }
 	
-    /*
-	 * Perform action
-	 */
+	/* Perform action. */
 	if (Action == SK_PNMI_GET) {
 
-		/*
-		 * Get value
-		 */
+		/* Get value. */
 		switch (Id) {
 
 		case OID_PNP_CAPABILITIES:
 			RetCode = SkPowerQueryPnPCapabilities(pAC, IoC, pBuf, pLen);
 			break;
 
 		case OID_PNP_QUERY_POWER:
-			/* The Windows DDK describes: An OID_PNP_QUERY_POWER requests
-			 the miniport to indicate whether it can transition its NIC
-			 to the low-power state.
-			 A miniport driver must always return NDIS_STATUS_SUCCESS
-			 to a query of OID_PNP_QUERY_POWER. */
-			*pLen = sizeof(SK_DEVICE_POWER_STATE);
+			/*
+			 * The Windows DDK describes: An OID_PNP_QUERY_POWER requests
+			 * the miniport to indicate whether it can transition its NIC
+			 * to the low-power state.
+			 * A miniport driver must always return NDIS_STATUS_SUCCESS
+			 * to a query of OID_PNP_QUERY_POWER.
+			 */
+			*pLen = sizeof(SK_DEVICE_POWER_STATE);;
             RetCode = SK_PNMI_ERR_OK;
 			break;
 
-			/* NDIS handles these OIDs as write-only.
+			/*
+			 * NDIS handles these OIDs as write-only.
 			 * So in case of get action the buffer with written length = 0
-			 * is returned
+			 * is returned.
 			 */
 		case OID_PNP_SET_POWER:
 		case OID_PNP_ADD_WAKE_UP_PATTERN:
 		case OID_PNP_REMOVE_WAKE_UP_PATTERN:
@@ -7710,15 +7459,13 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 		return (RetCode);
 	}
 	
-
-	/*
-	 * Perform preset or set
-	 */
+	/* Perform PRESET or SET. */
 	
-	/* POWER module does not support PRESET action */
+	/* The POWER module does not support PRESET action. */
 	if (Action == SK_PNMI_PRESET) {
+
 		return (SK_PNMI_ERR_OK);
 	}
 
 	switch (Id) {
@@ -7748,9 +7495,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 #ifdef SK_DIAG_SUPPORT
 /*****************************************************************************
  *
- * DiagActions - OID handler function of Diagnostic driver 
+ * DiagActions - OID handler function of Diagnostic driver
  *
  * Description:
  *	The code is simple. No description necessary.
  *
@@ -7775,24 +7522,19 @@ unsigned int *pLen,	/* On call: pBuf buf
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
 SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
-
 	SK_U32	DiagStatus;
 	SK_U32	RetCode = SK_PNMI_ERR_GENERAL;
 
-	/*
-	 * Check instance. We only handle single instance variables.
-	 */
+	/* Check instance. We only handle single instance variables. */
 	if (Instance != (SK_U32)(-1) && Instance != 1) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_INST);
 	}
 
-	/*
-	 * Check length.
-	 */
+    /* Check length. */
 	switch (Id) {
 
 	case OID_SKGE_DIAG_MODE:
 		if (*pLen < sizeof(SK_U32)) {
@@ -7808,12 +7550,11 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		return (SK_PNMI_ERR_GENERAL);
 	}
 
 	/* Perform action. */
-
-	/* GET value. */
 	if (Action == SK_PNMI_GET) {
 
+		/* Get value. */
 		switch (Id) {
 
 		case OID_SKGE_DIAG_MODE:
 			DiagStatus = pAC->Pnmi.DiagAttached;
@@ -7826,16 +7567,17 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = 0;	
 			RetCode = SK_PNMI_ERR_GENERAL;
 			break;
 		}
-		return (RetCode); 
+		return (RetCode);
 	}
 
 	/* From here SET or PRESET value. */
 	
 	/* PRESET value is not supported. */
 	if (Action == SK_PNMI_PRESET) {
-		return (SK_PNMI_ERR_OK); 
+
+		return (SK_PNMI_ERR_OK);
 	}
 
 	/* SET value. */
 	switch (Id) {
@@ -7845,9 +7587,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			switch (*pBuf) {
 
 				/* Attach the DIAG to this adapter. */
 				case SK_DIAG_ATTACHED:
-					/* Check if we come from running */
+					/* Check if we come from running. */
 					if (pAC->Pnmi.DiagAttached == SK_DIAG_RUNNING) {
 
 						RetCode = SkDrvLeaveDiagMode(pAC);
 
@@ -7880,9 +7622,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					if (pAC->Pnmi.DiagAttached == SK_DIAG_ATTACHED) {
 						/* If DiagMode is not active, we can enter it. */
 						if (!pAC->DiagModeActive) {
 
-							RetCode = SkDrvEnterDiagMode(pAC); 
+							RetCode = SkDrvEnterDiagMode(pAC);
 						}
 						else {
 
 							RetCode = SK_PNMI_ERR_GENERAL;
@@ -7899,9 +7641,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 					}
 					break;
 
 				case SK_DIAG_IDLE:
-					/* Check if we come from running */
+					/* Check if we come from running. */
 					if (pAC->Pnmi.DiagAttached == SK_DIAG_RUNNING) {
 
 						RetCode = SkDrvLeaveDiagMode(pAC);
 
@@ -7945,9 +7687,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 #endif /* SK_DIAG_SUPPORT */
 
 /*****************************************************************************
  *
- * Vct - OID handler function of  OIDs
+ * Vct - OID handler function of OIDs for Virtual Cable Tester (VCT)
  *
  * Description:
  *	The code is simple. No description necessary.
  *
@@ -7981,17 +7723,15 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	SK_U32		PhysPortMax;
 	SK_U32		PhysPortIndex;
 	SK_U32		Limit;
 	SK_U32		Offset;
-	SK_BOOL		Link;
-	SK_U32		RetCode = SK_PNMI_ERR_GENERAL;
-	int		i;
+	SK_U32		RetCode;
+	int			i;
 	SK_EVPARA	Para;
-	SK_U32		CableLength;
 	
-	/*
-	 * Calculate the port indexes from the instance.
-	 */
+	RetCode = SK_PNMI_ERR_GENERAL;
+	
+	/* Calculate the port indexes from the instance. */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
 	
 	/* Dual net mode? */
@@ -7999,9 +7739,13 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		LogPortMax--;
 	}
 	
 	if ((Instance != (SK_U32) (-1))) {
-		/* Check instance range. */
+		/*
+		 * Get one instance of that OID, so check the instance range:
+		 * There is no virtual port with an Instance == 1, so we get
+		 * the values from one physical port only.
+		 */
 		if ((Instance < 2) || (Instance > LogPortMax)) {
 			*pLen = 0;
 			return (SK_PNMI_ERR_UNKNOWN_INST);
 		}
@@ -8015,36 +7759,28 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		Limit = PhysPortIndex + 1;
 	}
 	else {
 		/*
-		 * Instance == (SK_U32) (-1), get all Instances of that OID.
-		 *
-		 * Not implemented yet. May be used in future releases.
+		 * Instance == (SK_U32) (-1), so get all instances of that OID.
+		 * There is no virtual port with an Instance == 1, so we get
+		 * the values from all physical ports.
 		 */
 		PhysPortIndex = 0;
 		Limit = PhysPortMax;
 	}
 	
 	pPrt = &pAC->GIni.GP[PhysPortIndex];
-	if (pPrt->PHWLinkUp) {
-		Link = SK_TRUE;
-	}
-	else {
-		Link = SK_FALSE;
-	}
 	
-	/* Check MAC type */
-	if (pPrt->PhyType != SK_PHY_MARV_COPPER) {
+	/* Check MAC type. */
+	if ((Id != OID_SKGE_VCT_CAPABILITIES) &&
+		(pPrt->PhyType != SK_PHY_MARV_COPPER)) {
 		*pLen = 0;
-		return (SK_PNMI_ERR_GENERAL);
+		return (SK_PNMI_ERR_NOT_SUPPORTED);
 	}
 	
-	/* Initialize backup data pointer. */
-	pVctBackupData = &pAC->Pnmi.VctBackup[PhysPortIndex];
-	
-	/* Check action type */
+	/* Check action type. */
 	if (Action == SK_PNMI_GET) {
-		/* Check length */
+		/* Check length. */
 		switch (Id) {
 		
 		case OID_SKGE_VCT_GET:
 			if (*pLen < (Limit - PhysPortIndex) * sizeof(SK_PNMI_VCT)) {
@@ -8053,8 +7789,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			}
 			break;
 		
 		case OID_SKGE_VCT_STATUS:
+		case OID_SKGE_VCT_CAPABILITIES:
 			if (*pLen < (Limit - PhysPortIndex) * sizeof(SK_U8)) {
 				*pLen = (Limit - PhysPortIndex) * sizeof(SK_U8);
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
@@ -8064,72 +7801,75 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}	
 		
-		/* Get value */
+		/* Get value. */
 		Offset = 0;
 		for (; PhysPortIndex < Limit; PhysPortIndex++) {
+			
 			switch (Id) {
 			
 			case OID_SKGE_VCT_GET:
-				if ((Link == SK_FALSE) &&
+				if (!pPrt->PHWLinkUp &&
 					(pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING)) {
+
 					RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_FALSE);
+					
 					if (RetCode == 0) {
-						pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_PENDING;
-						pAC->Pnmi.VctStatus[PhysPortIndex] |=
-							(SK_PNMI_VCT_NEW_VCT_DATA | SK_PNMI_VCT_TEST_DONE);
 						
-						/* Copy results for later use to PNMI struct. */
-						for (i = 0; i < 4; i++)  {
-							if (pPrt->PMdiPairSts[i] == SK_PNMI_VCT_NORMAL_CABLE) {
-								if ((pPrt->PMdiPairLen[i] > 35) && (pPrt->PMdiPairLen[i] < 0xff)) {
-									pPrt->PMdiPairSts[i] = SK_PNMI_VCT_IMPEDANCE_MISMATCH;
-								}
-							}
-							if ((pPrt->PMdiPairLen[i] > 35) && (pPrt->PMdiPairLen[i] != 0xff)) {
-								CableLength = 1000 * (((175 * pPrt->PMdiPairLen[i]) / 210) - 28);
-							}
-							else {
-								CableLength = 0;
-							}
-							pVctBackupData->PMdiPairLen[i] = CableLength;
-							pVctBackupData->PMdiPairSts[i] = pPrt->PMdiPairSts[i];
-						}
+						/* VCT test is finished, so save the data. */
+						VctGetResults(pAC, IoC, PhysPortIndex);
 
 						Para.Para32[0] = PhysPortIndex;
 						Para.Para32[1] = -1;
 						SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_RESET, Para);
-						SkEventDispatcher(pAC, IoC);
-					}
-					else {
-						; /* VCT test is running. */
+
+						/* SkEventDispatcher(pAC, IoC); */
 					}
 				}
 				
+				/* Initialize backup data pointer. */
+				pVctBackupData = &pAC->Pnmi.VctBackup[PhysPortIndex];
+				
 				/* Get all results. */
 				CheckVctStatus(pAC, IoC, pBuf, Offset, PhysPortIndex);
-				Offset += sizeof(SK_U8);
+				
+				Offset++;
 				*(pBuf + Offset) = pPrt->PCableLen;
-				Offset += sizeof(SK_U8);
+				Offset++;
 				for (i = 0; i < 4; i++)  {
-					SK_PNMI_STORE_U32((pBuf + Offset), pVctBackupData->PMdiPairLen[i]);
+
+					SK_PNMI_STORE_U32((pBuf + Offset), pVctBackupData->MdiPairLen[i]);
 					Offset += sizeof(SK_U32);
 				}
 				for (i = 0; i < 4; i++)  {
-					*(pBuf + Offset) = pVctBackupData->PMdiPairSts[i];
-					Offset += sizeof(SK_U8);
+
+					*(pBuf + Offset) = pVctBackupData->MdiPairSts[i];
+					Offset++;
 				}
 				
 				RetCode = SK_PNMI_ERR_OK;
 				break;
-		
+
 			case OID_SKGE_VCT_STATUS:
 				CheckVctStatus(pAC, IoC, pBuf, Offset, PhysPortIndex);
-				Offset += sizeof(SK_U8);
+
+				Offset++;
 				RetCode = SK_PNMI_ERR_OK;
 				break;
-			
+
+			case OID_SKGE_VCT_CAPABILITIES:
+				if (pPrt->PhyType != SK_PHY_MARV_COPPER) {
+					*(pBuf + Offset) = SK_PNMI_VCT_NOT_SUPPORTED;
+				}
+				else {
+					*(pBuf + Offset) = SK_PNMI_VCT_SUPPORTED;
+				}
+				Offset++;
+
+				RetCode = SK_PNMI_ERR_OK;
+				break;
+
 			default:
 				*pLen = 0;
 				return (SK_PNMI_ERR_GENERAL);
 			}
@@ -8143,9 +7883,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	 * From here SET or PRESET action. Check if the passed
 	 * buffer length is plausible.
 	 */
 	
-	/* Check length */
+	/* Check length. */
 	switch (Id) {
 	case OID_SKGE_VCT_SET:
 		if (*pLen < (Limit - PhysPortIndex) * sizeof(SK_U32)) {
 			*pLen = (Limit - PhysPortIndex) * sizeof(SK_U32);
@@ -8157,38 +7897,41 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = 0;
 		return (SK_PNMI_ERR_GENERAL);
 	}
 	
-	/*
-	 * Perform preset or set.
-	 */
+	/* Perform PRESET or SET. */
 	
 	/* VCT does not support PRESET action. */
 	if (Action == SK_PNMI_PRESET) {
+
 		return (SK_PNMI_ERR_OK);
 	}
 	
 	Offset = 0;
 	for (; PhysPortIndex < Limit; PhysPortIndex++) {
+
+		pPrt = &pAC->GIni.GP[PhysPortIndex];
+
 		switch (Id) {
 		case OID_SKGE_VCT_SET: /* Start VCT test. */
-			if (Link == SK_FALSE) {
+			if (!pPrt->PHWLinkUp) {
 				SkGeStopPort(pAC, IoC, PhysPortIndex, SK_STOP_ALL, SK_SOFT_RST);
 				
 				RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_TRUE);
+				
 				if (RetCode == 0) { /* RetCode: 0 => Start! */
 					pAC->Pnmi.VctStatus[PhysPortIndex] |= SK_PNMI_VCT_PENDING;
-					pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_NEW_VCT_DATA;
-					pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_LINK;
+					pAC->Pnmi.VctStatus[PhysPortIndex] &=
+						~(SK_PNMI_VCT_NEW_VCT_DATA | SK_PNMI_VCT_LINK);
 					
-					/*
-					 * Start VCT timer counter.
-					 */
-					SK_MEMSET((char *) &Para, 0, sizeof(Para));
+					/* Start VCT timer counter. */
+					SK_MEMSET((char *)&Para, 0, sizeof(Para));
 					Para.Para32[0] = PhysPortIndex;
 					Para.Para32[1] = -1;
-					SkTimerStart(pAC, IoC, &pAC->Pnmi.VctTimeout[PhysPortIndex].VctTimer,
-						4000000, SKGE_PNMI, SK_PNMI_EVT_VCT_RESET, Para);
+					
+					SkTimerStart(pAC, IoC, &pAC->Pnmi.VctTimeout[PhysPortIndex],
+						SK_PNMI_VCT_TIMER_CHECK, SKGE_PNMI, SK_PNMI_EVT_VCT_RESET, Para);
+					
 					SK_PNMI_STORE_U32((pBuf + Offset), RetCode);
 					RetCode = SK_PNMI_ERR_OK;
 				}
 				else { /* RetCode: 2 => Running! */
@@ -8214,8 +7957,59 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 } /* Vct */
 
 
+PNMI_STATIC void VctGetResults(
+SK_AC		*pAC,
+SK_IOC		IoC,
+SK_U32		Port)
+{
+	SK_GEPORT	*pPrt;
+	int			i;
+	SK_U8		PairLen;
+	SK_U8		PairSts;
+	SK_U32		CableLength;
+	
+	pPrt = &pAC->GIni.GP[Port];
+
+	/* Copy results for later use to PNMI struct. */
+	for (i = 0; i < 4; i++)  {
+
+		PairLen = pPrt->PMdiPairLen[i];
+
+		if (((pPrt->PLinkSpeedCap & SK_LSPEED_CAP_1000MBPS) == 0) && (i > 1)) {
+			PairSts = SK_PNMI_VCT_NOT_PRESENT;
+		}
+		else {
+			PairSts = pPrt->PMdiPairSts[i];
+		}
+
+		if ((PairSts == SK_PNMI_VCT_NORMAL_CABLE) &&
+			(PairLen > 28) && (PairLen < 0xff)) {
+
+			PairSts = SK_PNMI_VCT_IMPEDANCE_MISMATCH;
+		}
+
+		/* Ignore values <= 35, the linear factor is 4/5 (trend line). */
+		if ((PairLen > 35) && (PairLen < 0xff)) {
+			
+			CableLength = 1000UL * (PairLen - 35) * 4 / 5;
+		}
+		else {
+			/* No cable or short cable. */
+			CableLength = 0;
+		}
+
+		pAC->Pnmi.VctBackup[Port].MdiPairLen[i] = CableLength;
+		pAC->Pnmi.VctBackup[Port].MdiPairSts[i] = PairSts;
+	}
+
+	pAC->Pnmi.VctStatus[Port] &= ~SK_PNMI_VCT_PENDING;
+	pAC->Pnmi.VctStatus[Port] |= (SK_PNMI_VCT_NEW_VCT_DATA |
+		SK_PNMI_VCT_TEST_DONE);
+
+} /* GetVctResults */
+
 PNMI_STATIC void CheckVctStatus(
 SK_AC		*pAC,
 SK_IOC		IoC,
 char		*pBuf,
@@ -8223,20 +8017,23 @@ SK_U32		Offset,
 SK_U32		PhysPortIndex)
 {
 	SK_GEPORT 	*pPrt;
 	SK_PNMI_VCT	*pVctData;
+	SK_U8		VctStatus;
 	SK_U32		RetCode;
 	
 	pPrt = &pAC->GIni.GP[PhysPortIndex];
 	
 	pVctData = (SK_PNMI_VCT *) (pBuf + Offset);
 	pVctData->VctStatus = SK_PNMI_VCT_NONE;
 	
+	VctStatus = pAC->Pnmi.VctStatus[PhysPortIndex];
+	
 	if (!pPrt->PHWLinkUp) {
 		
 		/* Was a VCT test ever made before? */
-		if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_TEST_DONE) {
-			if ((pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_LINK)) {
+		if (VctStatus & SK_PNMI_VCT_TEST_DONE) {
+			if (VctStatus & SK_PNMI_VCT_LINK) {
 				pVctData->VctStatus |= SK_PNMI_VCT_OLD_VCT_DATA;
 			}
 			else {
 				pVctData->VctStatus |= SK_PNMI_VCT_NEW_VCT_DATA;
@@ -8244,13 +8041,14 @@ SK_U32		PhysPortIndex)
 		}
 		
 		/* Check VCT test status. */
 		RetCode = SkGmCableDiagStatus(pAC,IoC, PhysPortIndex, SK_FALSE);
+		
 		if (RetCode == 2) { /* VCT test is running. */
 			pVctData->VctStatus |= SK_PNMI_VCT_RUNNING;
 		}
 		else { /* VCT data was copied to pAC here. Check PENDING state. */
-			if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING) {
+			if (VctStatus & SK_PNMI_VCT_PENDING) {
 				pVctData->VctStatus |= SK_PNMI_VCT_NEW_VCT_DATA;
 			}
 		}
 		
@@ -8258,18 +8056,16 @@ SK_U32		PhysPortIndex)
 			pVctData->VctStatus |= SK_PNMI_VCT_OLD_DSP_DATA;
 		}
 	}
 	else {
-		
 		/* Was a VCT test ever made before? */
-		if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_TEST_DONE) {
+		if (VctStatus & SK_PNMI_VCT_TEST_DONE) {
 			pVctData->VctStatus &= ~SK_PNMI_VCT_NEW_VCT_DATA;
 			pVctData->VctStatus |= SK_PNMI_VCT_OLD_VCT_DATA;
 		}
 		
 		/* DSP only valid in 100/1000 modes. */
-		if (pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed !=
-			SK_LSPEED_STAT_10MBPS) {	
+		if (pPrt->PLinkSpeedUsed != SK_LSPEED_STAT_10MBPS) {
 			pVctData->VctStatus |= SK_PNMI_VCT_NEW_DSP_DATA;
 		}
 	}
 } /* CheckVctStatus */
@@ -8313,31 +8109,31 @@ int 	HeaderLength;	/* Length of desired 
 
 	ReturnCode = SK_PNMI_ERR_GENERAL;
 	
 	SK_MEMCPY(&Mode, pBuf, sizeof(SK_I32));
-	SK_MEMCPY(&Oid, (char *) pBuf + sizeof(SK_I32), sizeof(SK_U32));
+	SK_MEMCPY(&Oid, (char *)pBuf + sizeof(SK_I32), sizeof(SK_U32));
 	HeaderLength = sizeof(SK_I32) + sizeof(SK_U32);
 	*pLen = *pLen - HeaderLength;
-	SK_MEMCPY((char *) pBuf + sizeof(SK_I32), (char *) pBuf + HeaderLength, *pLen);
+	SK_MEMCPY((char *)pBuf + sizeof(SK_I32), (char *)pBuf + HeaderLength, *pLen);
 	
 	switch(Mode) {
 	case SK_GET_SINGLE_VAR:
-		ReturnCode = SkPnmiGetVar(pAC, IoC, Oid, 
-				(char *) pBuf + sizeof(SK_I32), pLen,
+		ReturnCode = SkPnmiGetVar(pAC, IoC, Oid,
+				(char *)pBuf + sizeof(SK_I32), pLen,
 				((SK_U32) (-1)), NetIndex);
 		SK_PNMI_STORE_U32(pBuf, ReturnCode);
 		*pLen = *pLen + sizeof(SK_I32);
 		break;
 	case SK_PRESET_SINGLE_VAR:
-		ReturnCode = SkPnmiPreSetVar(pAC, IoC, Oid, 
-				(char *) pBuf + sizeof(SK_I32), pLen,
+		ReturnCode = SkPnmiPreSetVar(pAC, IoC, Oid,
+				(char *)pBuf + sizeof(SK_I32), pLen,
 				((SK_U32) (-1)), NetIndex);
 		SK_PNMI_STORE_U32(pBuf, ReturnCode);
 		*pLen = *pLen + sizeof(SK_I32);
 		break;
 	case SK_SET_SINGLE_VAR:
-		ReturnCode = SkPnmiSetVar(pAC, IoC, Oid, 
-				(char *) pBuf + sizeof(SK_I32), pLen,
+		ReturnCode = SkPnmiSetVar(pAC, IoC, Oid,
+				(char *)pBuf + sizeof(SK_I32), pLen,
 				((SK_U32) (-1)), NetIndex);
 		SK_PNMI_STORE_U32(pBuf, ReturnCode);
 		*pLen = *pLen + sizeof(SK_I32);
 		break;
@@ -8356,4 +8152,87 @@ int 	HeaderLength;	/* Length of desired 
 	
 	return (ReturnCode);
 
 } /* SkGeIocGen */
+
+#ifdef SK_ASF
+/*****************************************************************************
+ *
+ * Asf
+ *
+ * Description:
+ *  The code is simple. No description necessary.
+ *
+ * Returns:
+ *  SK_PNMI_ERR_OK           The request was successfully performed.
+ *  SK_PNMI_ERR_GENERAL      A general severe internal error occured.
+ *  SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain
+ *                           the correct data (e.g. a 32bit value is
+ *                           needed, but a 16 bit value was passed).
+ *  SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
+ *                           exist (e.g. port instance 3 on a two port
+ *                           adapter.
+ */
+
+PNMI_STATIC int Asf(
+SK_AC *pAC,     /* Pointer to adapter context */
+SK_IOC IoC,     /* IO context handle */
+int Action,     /* GET/PRESET/SET action */
+SK_U32 Id,      /* Object ID that is to be processed */
+char *pBuf,     /* Buffer used for the management data transfer */
+unsigned int *pLen, /* On call: pBuf buffer length. On return: used buffer */
+SK_U32 Instance,    /* Instance (1..n) that is to be queried or -1 */
+unsigned int TableIndex, /* Index to the Id table */
+SK_U32 NetIndex)    /* NetIndex (0..n), in single net mode always zero */
+{
+    SK_U32  RetCode = SK_PNMI_ERR_GENERAL;
+
+    /*
+     * Check instance. We only handle single instance variables.
+     */
+    if (Instance != (SK_U32)(-1) && Instance != 1) {
+
+        *pLen = 0;
+        return (SK_PNMI_ERR_UNKNOWN_INST);
+    }
+
+    /* Perform action. */
+    /* GET value. */
+    if (Action == SK_PNMI_GET) {
+        switch (Id) {
+            case OID_SKGE_ASF:  
+                RetCode = SkAsfGet(pAC, IoC, (SK_U8 *) pBuf, pLen);
+                break;
+            default:
+                RetCode = SkAsfGetOid( pAC, IoC, Id, Instance, (SK_U8 *) pBuf, pLen );
+                break;
+        }
+
+        return (RetCode); 
+    }
+
+    /* PRESET value. */
+    if (Action == SK_PNMI_PRESET) { 
+        switch (Id) {
+            case OID_SKGE_ASF:
+                RetCode = SkAsfPreSet(pAC, IoC, (SK_U8 *) pBuf, pLen);
+                break;
+            default:
+                RetCode = SkAsfPreSetOid( pAC, IoC, Id, Instance, (SK_U8 *) pBuf, pLen );
+                break;
+        }
+    }
+
+    /* SET value. */
+    if (Action == SK_PNMI_SET) {
+        switch (Id) {
+            case OID_SKGE_ASF:
+                RetCode = SkAsfSet(pAC, IoC, (SK_U8 *) pBuf, pLen);
+                break;
+            default:
+                RetCode = SkAsfSetOid( pAC, IoC, Id, Instance, (SK_U8 *) pBuf, pLen );
+                break;
+        }
+    }
+    return (RetCode);
+}
+#endif /* SK_ASF */
Index: linux-2.6.8/drivers/net/sk98lin/skgesirq.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skgesirq.c
+++ linux-2.6.8/drivers/net/sk98lin/skgesirq.c
@@ -1,24 +1,23 @@
 /******************************************************************************
  *
  * Name:	skgesirq.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.92 $
- * Date:	$Date: 2003/09/16 14:37:07 $
+ * Version:	$Revision: 2.15 $
+ * Date:	$Date: 2004/05/28 14:25:30 $
  * Purpose:	Special IRQ module
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
@@ -45,20 +44,22 @@
  *	However, the MAC Interrupt status registers are read in a while loop.
  *
  */
 
-#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
-static const char SysKonnectFileId[] =
-	"@(#) $Id: skgesirq.c,v 1.92 2003/09/16 14:37:07 rschmidt Exp $ (C) Marvell.";
-#endif
-
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #ifndef SK_SLIM
 #include "h/skgepnmi.h"		/* PNMI Definitions */
 #include "h/skrlmt.h"		/* RLMT Definitions */
 #endif
 #include "h/skdrv2nd.h"		/* Adapter Control and Driver specific Def. */
 
+/* local variables ************************************************************/
+
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
+static const char SysKonnectFileId[] =
+	"@(#) $Id: skgesirq.c,v 2.15 2004/05/28 14:25:30 rschmidt Exp $ (C) Marvell.";
+#endif
+
 /* local function prototypes */
 #ifdef GENESIS
 static int	SkGePortCheckUpXmac(SK_AC*, SK_IOC, int, SK_BOOL);
 static int	SkGePortCheckUpBcom(SK_AC*, SK_IOC, int, SK_BOOL);
@@ -108,10 +109,10 @@ intro()
  *
  * Returns: N/A
  */
 static void SkHWInitDefSense(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
@@ -144,30 +145,30 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Note:
  *
  */
 static SK_U8 SkHWSenseGetNext(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	pPrt->PAutoNegTimeOut = 0;
 
-    if (pPrt->PLinkModeConf != (SK_U8)SK_LMODE_AUTOSENSE) {
+	if (pPrt->PLinkModeConf != (SK_U8)SK_LMODE_AUTOSENSE) {
 		/* Leave all as configured */
 		return(pPrt->PLinkModeConf);
 	}
 
-    if (pPrt->PLinkMode == (SK_U8)SK_LMODE_AUTOFULL) {
+	if (pPrt->PLinkMode == (SK_U8)SK_LMODE_AUTOFULL) {
 		/* Return next mode AUTOBOTH */
-        return ((SK_U8)SK_LMODE_AUTOBOTH);
+		return((SK_U8)SK_LMODE_AUTOBOTH);
 	}
 
 	/* Return default autofull */
-    return ((SK_U8)SK_LMODE_AUTOFULL);
+	return((SK_U8)SK_LMODE_AUTOFULL);
 }	/* SkHWSenseGetNext */
 
 
 /******************************************************************************
@@ -178,10 +179,10 @@ int		Port)	/* Port Index (MAC_1 + n) */
  *
  * Returns: N/A
  */
 static void SkHWSenseSetNext(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_U8	NewMode)	/* New Mode to be written in sense mode */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
@@ -189,9 +190,9 @@ SK_U8	NewMode)	/* New Mode to be written
 	pPrt = &pAC->GIni.GP[Port];
 
 	pPrt->PAutoNegTimeOut = 0;
 
-    if (pPrt->PLinkModeConf != (SK_U8)SK_LMODE_AUTOSENSE) {
+	if (pPrt->PLinkModeConf != (SK_U8)SK_LMODE_AUTOSENSE) {
 		return;
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
@@ -213,10 +214,10 @@ SK_U8	NewMode)	/* New Mode to be written
  *
  * Returns: N/A
  */
 void SkHWLinkDown(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
@@ -226,13 +227,13 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	SkMacIrqDisable(pAC, IoC, Port);
 
 	/* Disable Receiver and Transmitter */
 	SkMacRxTxDisable(pAC, IoC, Port);
-	
+
 	/* Init default sense mode */
 	SkHWInitDefSense(pAC, IoC, Port);
 
-	if (pPrt->PHWLinkUp == SK_FALSE) {
+	if (!pPrt->PHWLinkUp) {
 		return;
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
@@ -241,10 +242,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	/* Set Link to DOWN */
 	pPrt->PHWLinkUp = SK_FALSE;
 
 	/* Reset Port stati */
-    pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
-    pPrt->PFlowCtrlStatus = (SK_U8)SK_FLOW_STAT_NONE;
+	pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
+	pPrt->PFlowCtrlStatus = (SK_U8)SK_FLOW_STAT_NONE;
 	pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_INDETERMINATED;
 
 	/* Re-init Phy especially when the AutoSense default is set now */
 	SkMacInitPhy(pAC, IoC, Port, SK_FALSE);
@@ -265,10 +266,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  *
  * Returns: N/A
  */
 void SkHWLinkUp(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
@@ -280,13 +281,13 @@ int		Port)	/* Port Index (MAC_1 + n) */
 	}
 
 	pPrt->PHWLinkUp = SK_TRUE;
 	pPrt->PAutoNegFail = SK_FALSE;
-    pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
+	pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
 
-    if (pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOHALF &&
-        pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOFULL &&
-        pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOBOTH) {
+	if (pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOHALF &&
+		pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOFULL &&
+		pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOBOTH) {
 		/* Link is up and no Auto-negotiation should be done */
 
 		/* Link speed should be the configured one */
 		switch (pPrt->PLinkSpeed) {
@@ -307,16 +308,16 @@ int		Port)	/* Port Index (MAC_1 + n) */
 		if (pPrt->PLinkMode == SK_LMODE_FULL) {
 			pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_FULL;
 		}
 		else {
-            pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_HALF;
+			pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_HALF;
 		}
 
 		/* No flow control without auto-negotiation */
-        pPrt->PFlowCtrlStatus = (SK_U8)SK_FLOW_STAT_NONE;
+		pPrt->PFlowCtrlStatus = (SK_U8)SK_FLOW_STAT_NONE;
 
 		/* enable Rx/Tx */
-        (void)SkMacRxTxEnable(pAC, IoC, Port);
+		(void)SkMacRxTxEnable(pAC, IoC, Port);
 	}
 }	/* SkHWLinkUp */
 
 
@@ -328,16 +329,18 @@ int		Port)	/* Port Index (MAC_1 + n) */
  *
  * Returns: N/A
  */
 static void SkMacParity(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
-int		Port)	/* Port Index of the port failed */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O context */
+int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_EVPARA	Para;
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	SK_U32		TxMax;		/* Tx Max Size Counter */
 
+	TxMax = 0;
+	
 	pPrt = &pAC->GIni.GP[Port];
 
 	/* Clear IRQ Tx Parity Error */
 #ifdef GENESIS
@@ -354,9 +357,9 @@ int		Port)	/* Port Index of the port fai
 			(SK_U8)((pAC->GIni.GIChipId == CHIP_ID_YUKON &&
 			pAC->GIni.GIChipRev == 0) ? GMF_CLI_TX_FC : GMF_CLI_TX_PE));
 	}
 #endif /* YUKON */
-	
+
 	if (pPrt->PCheckPar) {
 
 		if (Port == MAC_1) {
 			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E016, SKERR_SIRQ_E016MSG);
@@ -365,9 +368,9 @@ int		Port)	/* Port Index of the port fai
 			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E017, SKERR_SIRQ_E017MSG);
 		}
 		Para.Para64 = Port;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
-		
+
 		Para.Para32[0] = Port;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 
 		return;
@@ -377,9 +380,9 @@ int		Port)	/* Port Index of the port fai
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* Snap statistic counters */
 		(void)SkXmUpdateStats(pAC, IoC, Port);
-		
+
 		(void)SkXmMacStatistic(pAC, IoC, Port, XM_TXF_MAX_SZ, &TxMax);
 	}
 #endif /* GENESIS */
 	
@@ -398,17 +401,17 @@ int		Port)	/* Port Index of the port fai
 
 
 /******************************************************************************
  *
- *	SkGeHwErr() - Hardware Error service routine
+ *	SkGeYuHwErr() - Hardware Error service routine (Genesis and Yukon)
  *
  * Description: handles all HW Error interrupts
  *
  * Returns: N/A
  */
-static void SkGeHwErr(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+static void SkGeYuHwErr(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O context */
 SK_U32	HwStatus)	/* Interrupt status word */
 {
 	SK_EVPARA	Para;
 	SK_U16		Word;
@@ -422,12 +425,12 @@ SK_U32	HwStatus)	/* Interrupt status wor
 			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E012, SKERR_SIRQ_E012MSG);
 		}
 
 		/* Reset all bits in the PCI STATUS register */
-		SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
+		SK_IN16(IoC, PCI_C(pAC, PCI_STATUS), &Word);
 		
 		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-        SK_OUT16(IoC, PCI_C(PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
+		SK_OUT16(IoC, PCI_C(pAC, PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
 		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
 		Para.Para64 = 0;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
@@ -483,16 +486,20 @@ SK_U32	HwStatus)	/* Interrupt status wor
 	}
 #endif /* YUKON */
 
 	if ((HwStatus & IS_RAM_RD_PAR) != 0) {
+
 		SK_OUT16(IoC, B3_RI_CTRL, RI_CLR_RD_PERR);
+		
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E014, SKERR_SIRQ_E014MSG);
 		Para.Para64 = 0;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
 	}
 
 	if ((HwStatus & IS_RAM_WR_PAR) != 0) {
+		
 		SK_OUT16(IoC, B3_RI_CTRL, RI_CLR_WR_PERR);
+		
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E015, SKERR_SIRQ_E015MSG);
 		Para.Para64 = 0;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
 	}
@@ -511,9 +518,9 @@ SK_U32	HwStatus)	/* Interrupt status wor
 
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E018, SKERR_SIRQ_E018MSG);
 		Para.Para64 = MAC_1;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
-		
+
 		Para.Para32[0] = MAC_1;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
@@ -523,26 +530,246 @@ SK_U32	HwStatus)	/* Interrupt status wor
 
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E019, SKERR_SIRQ_E019MSG);
 		Para.Para64 = MAC_2;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
-		
+
 		Para.Para32[0] = MAC_2;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
-}	/* SkGeHwErr */
+}	/* SkGeYuHwErr */
 
+#ifdef YUK2
+/******************************************************************************
+ *
+ *	SkYuk2HwPortErr() - Service HW Errors for specified port (Yukon-2 only)
+ *
+ * Description: handles the HW Error interrupts for a specific port.
+ *
+ * Returns: N/A
+ */
+static void SkYuk2HwPortErr(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+SK_U32	HwStatus,	/* Interrupt status word */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
+	int Queue;
+	SK_EVPARA	Para;
+
+	if (Port == MAC_2) {
+		HwStatus >>= 8;
+	}
+
+	if ((HwStatus & Y2_HWE_L1_MASK) == 0) {
+		return;
+	}
+
+	if ((HwStatus & Y2_IS_PAR_RD1) != 0) {
+		/* Clear IRQ */
+		SK_OUT16(IoC, SELECT_RAM_BUFFER(Port, B3_RI_CTRL), RI_CLR_RD_PERR);
+
+		if (Port == MAC_1) {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E028, SKERR_SIRQ_E028MSG);
+		}
+		else {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E030, SKERR_SIRQ_E030MSG);
+		}
+	}
+
+	if ((HwStatus & Y2_IS_PAR_WR1) != 0) {
+		/* Clear IRQ */
+		SK_OUT16(IoC, SELECT_RAM_BUFFER(Port, B3_RI_CTRL), RI_CLR_WR_PERR);
+
+		if (Port == MAC_1) {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E029, SKERR_SIRQ_E029MSG);
+		}
+		else {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E031, SKERR_SIRQ_E031MSG);
+		}
+	}
+
+	if ((HwStatus & Y2_IS_PAR_MAC1) != 0) {
+		/* Clear IRQ */
+		SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), GMF_CLI_TX_PE);
+
+		if (Port == MAC_1) {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E016, SKERR_SIRQ_E016MSG);
+		}
+		else {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E017, SKERR_SIRQ_E017MSG);
+		}
+	}
+
+	if ((HwStatus & Y2_IS_PAR_RX1) != 0) {
+		if (Port == MAC_1) {
+			Queue = Q_R1;
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E018, SKERR_SIRQ_E018MSG);
+		}
+		else {
+			Queue = Q_R2;
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E019, SKERR_SIRQ_E019MSG);
+		}
+		/* Clear IRQ */
+		SK_OUT32(IoC, Q_ADDR(Queue, Q_CSR), BMU_CLR_IRQ_PAR);
+	}
+
+	if ((HwStatus & Y2_IS_TCP_TXS1) != 0) {
+		if (Port == MAC_1) {
+			Queue = Q_XS1;
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E033, SKERR_SIRQ_E033MSG);
+		}
+		else {
+			Queue = Q_XS2;
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E035, SKERR_SIRQ_E035MSG);
+		}
+		/* Clear IRQ */
+		SK_OUT32(IoC, Q_ADDR(Queue, Q_CSR), BMU_CLR_IRQ_TCP);
+	}
+
+	if ((HwStatus & Y2_IS_TCP_TXA1) != 0) {
+		if (Port == MAC_1) {
+			Queue = Q_XA1;
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E032, SKERR_SIRQ_E032MSG);
+		}
+		else {
+			Queue = Q_XA2;
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E034, SKERR_SIRQ_E034MSG);
+		}
+		/* Clear IRQ */
+		SK_OUT32(IoC, Q_ADDR(Queue, Q_CSR), BMU_CLR_IRQ_TCP);
+	}
+
+	Para.Para64 = Port;
+	SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
+
+	Para.Para32[0] = Port;
+	SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
+
+}	/* SkYuk2HwPortErr */
 
 /******************************************************************************
  *
- *	SkGeSirqIsr() - Special Interrupt Service Routine
+ *	SkYuk2HwErr() - Hardware Error service routine (Yukon-2 only)
  *
- * Description: handles all non data transfer specific interrupts (slow path)
+ * Description: handles all HW Error interrupts
+ *
+ * Returns: N/A
+ */
+static void SkYuk2HwErr(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+SK_U32	HwStatus)	/* Interrupt status word */
+{
+	SK_EVPARA	Para;
+	SK_U16		Word;
+	SK_U32		DWord;
+	int			i;
+
+	/* This is necessary only for Rx timing measurements */
+	if ((HwStatus & Y2_IS_TIST_OV) != 0) {
+		/* increment Time Stamp Timer counter (high) */
+		pAC->GIni.GITimeStampCnt++;
+
+		/* Clear Time Stamp Timer IRQ */
+		SK_OUT8(IoC, GMAC_TI_ST_CTRL, (SK_U8)GMT_ST_CLR_IRQ);
+	}
+
+	/* Evaluate Y2_IS_PCI_NEXP before Y2_IS_MST_ERR or Y2_IS_IRQ_STAT */
+	if ((HwStatus & Y2_IS_PCI_NEXP) != 0) {
+		/* PCI-Express Error occured which is not described in PEX spec. */
+		/*
+		 * This error is also mapped either to Master Abort (Y2_IS_MST_ERR)
+		 * or Target Abort (Y2_IS_IRQ_STAT) bit and can only be cleared there.
+		 * Therefore handle this event just by printing an error log entry.
+		 */
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E027, SKERR_SIRQ_E027MSG);
+	}
+
+	if ((HwStatus & (Y2_IS_MST_ERR | Y2_IS_IRQ_STAT)) != 0) {
+		/* PCI Errors occured */
+		if ((HwStatus & Y2_IS_IRQ_STAT) != 0) {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E013, SKERR_SIRQ_E013MSG);
+		}
+		else {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E012, SKERR_SIRQ_E012MSG);
+		}
+
+		/* Reset all bits in the PCI STATUS register */
+		SK_IN16(IoC, PCI_C(pAC,PCI_STATUS), &Word);
+
+		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+		SK_OUT16(IoC, PCI_C(pAC,PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
+		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
+
+		Para.Para64 = 0;
+		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
+	}
+
+	if ((HwStatus & Y2_IS_PCI_EXP) != 0) {
+		/* PCI-Express uncorrectable Error occured */
+		/*
+		 * On PCI-Express bus bridges are called root complexes.
+		 * PCI-Express errors are recognized by the root complex too,
+		 * which requests the system to handle the problem. After error
+		 * occurence it may be that no access to the adapter may be performed
+		 * any longer.
+		 */
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E026, SKERR_SIRQ_E026MSG);
+
+		/* Save uncorrectable error status */
+		SK_IN32(IoC, PCI_C(pAC, PEX_UNC_ERR_STAT), &DWord);
+
+		/* clear the interrupt */
+		SK_OUT32(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+		SK_OUT32(IoC, PCI_C(pAC, PEX_UNC_ERR_STAT), 0xffffffffUL);
+		SK_OUT32(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
+
+		if ((DWord & PEX_FATAL_ERRORS) != 0) {
+			/* Stop only, if the uncorrectable error is fatal */	
+			Para.Para64 = 0;
+			SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
+
+			pAC->GIni.GIValHwIrqMask &= ~Y2_IS_PCI_EXP;
+			/* Rewrite HW IRQ mask */
+			SK_OUT32(IoC, B0_HWE_IMSK, pAC->GIni.GIValHwIrqMask);
+		}
+	}
+
+	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+
+		SkYuk2HwPortErr(pAC, IoC, HwStatus, i);
+	}
+
+}	/* SkYuk2HwErr */
+#endif /* YUK2 */
+
+/******************************************************************************
+ *
+ *	SkGeSirqIsr() - Wrapper for Special Interrupt Service Routine
+ *
+ * Description: calls the preselected special ISR (slow path)
  *
  * Returns: N/A
  */
 void SkGeSirqIsr(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O context */
+SK_U32	Istatus)	/* Interrupt status word */
+{
+	pAC->GIni.GIFunc.pSkGeSirqIsr(pAC, IoC, Istatus);
+}
+
+/******************************************************************************
+ *
+ *	SkGeYuSirqIsr() - Special Interrupt Service Routine
+ *
+ * Description: handles all non data transfer specific interrupts (slow path)
+ *
+ * Returns: N/A
+ */
+void SkGeYuSirqIsr(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 SK_U32	Istatus)	/* Interrupt status word */
 {
 	SK_EVPARA	Para;
 	SK_U32		RegVal32;	/* Read register value */
@@ -552,10 +779,10 @@ SK_U32	Istatus)	/* Interrupt status word
 
 	if (((Istatus & IS_HW_ERR) & pAC->GIni.GIValIrqMask) != 0) {
 		/* read the HW Error Interrupt source */
 		SK_IN32(IoC, B0_HWE_ISRC, &RegVal32);
-		
-		SkGeHwErr(pAC, IoC, RegVal32);
+
+		SkGeYuHwErr(pAC, IoC, RegVal32);
 	}
 
 	/*
 	 * Packet Timeout interrupts
@@ -589,9 +816,9 @@ SK_U32	Istatus)	/* Interrupt status word
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_RX2);
 	}
 
 	if ((Istatus & IS_PA_TO_TX1) != 0) {
-		
+
 		pPrt = &pAC->GIni.GP[0];
 
 		/* May be a normal situation in a server with a slow network */
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_TX1);
@@ -616,22 +843,22 @@ SK_U32	Istatus)	/* Interrupt status word
 				Len = sizeof(SK_U64);
 				SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
 					&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, 0),
 					pAC->Rlmt.Port[0].Net->NetNumber);
-				
+
 				pPrt->LastOctets = Octets;
 #endif /* XXX */
 				/* Snap statistic counters */
 				(void)SkXmUpdateStats(pAC, IoC, 0);
 
 				(void)SkXmMacStatistic(pAC, IoC, 0, XM_TXO_OK_HI, &RegVal32);
 
 				pPrt->LastOctets = (SK_U64)RegVal32 << 32;
-				
+
 				(void)SkXmMacStatistic(pAC, IoC, 0, XM_TXO_OK_LO, &RegVal32);
 
 				pPrt->LastOctets += RegVal32;
-				
+
 				Para.Para32[0] = 0;
 				SkTimerStart(pAC, IoC, &pPrt->HalfDupChkTimer, SK_HALFDUP_CHK_TIME,
 					SKGE_HWAC, SK_HWEV_HALFDUP_CHK, Para);
 			}
@@ -639,9 +866,9 @@ SK_U32	Istatus)	/* Interrupt status word
 #endif /* GENESIS */
 	}
 
 	if ((Istatus & IS_PA_TO_TX2) != 0) {
-		
+
 		pPrt = &pAC->GIni.GP[1];
 
 		/* May be a normal situation in a server with a slow network */
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_TX2);
@@ -657,22 +884,22 @@ SK_U32	Istatus)	/* Interrupt status word
 				Len = sizeof(SK_U64);
 				SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
 					&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, 1),
 					pAC->Rlmt.Port[1].Net->NetNumber);
-				
+
 				pPrt->LastOctets = Octets;
 #endif /* XXX */
 				/* Snap statistic counters */
 				(void)SkXmUpdateStats(pAC, IoC, 1);
 
 				(void)SkXmMacStatistic(pAC, IoC, 1, XM_TXO_OK_HI, &RegVal32);
 
 				pPrt->LastOctets = (SK_U64)RegVal32 << 32;
-				
+
 				(void)SkXmMacStatistic(pAC, IoC, 1, XM_TXO_OK_LO, &RegVal32);
 
 				pPrt->LastOctets += RegVal32;
-				
+
 				Para.Para32[0] = 1;
 				SkTimerStart(pAC, IoC, &pPrt->HalfDupChkTimer, SK_HALFDUP_CHK_TIME,
 					SKGE_HWAC, SK_HWEV_HALFDUP_CHK, Para);
 			}
@@ -683,8 +910,9 @@ SK_U32	Istatus)	/* Interrupt status word
 	/* Check interrupts of the particular queues */
 	if ((Istatus & IS_R1_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_R1_CSR, CSR_IRQ_CL_C);
+
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E006,
 			SKERR_SIRQ_E006MSG);
 		Para.Para64 = MAC_1;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
@@ -694,8 +922,9 @@ SK_U32	Istatus)	/* Interrupt status word
 
 	if ((Istatus & IS_R2_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_R2_CSR, CSR_IRQ_CL_C);
+
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E007,
 			SKERR_SIRQ_E007MSG);
 		Para.Para64 = MAC_2;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
@@ -705,8 +934,9 @@ SK_U32	Istatus)	/* Interrupt status word
 
 	if ((Istatus & IS_XS1_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_XS1_CSR, CSR_IRQ_CL_C);
+
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E008,
 			SKERR_SIRQ_E008MSG);
 		Para.Para64 = MAC_1;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
@@ -716,8 +946,9 @@ SK_U32	Istatus)	/* Interrupt status word
 
 	if ((Istatus & IS_XA1_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_XA1_CSR, CSR_IRQ_CL_C);
+
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E009,
 			SKERR_SIRQ_E009MSG);
 		Para.Para64 = MAC_1;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
@@ -727,8 +958,9 @@ SK_U32	Istatus)	/* Interrupt status word
 
 	if ((Istatus & IS_XS2_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_XS2_CSR, CSR_IRQ_CL_C);
+
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E010,
 			SKERR_SIRQ_E010MSG);
 		Para.Para64 = MAC_2;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
@@ -738,8 +970,9 @@ SK_U32	Istatus)	/* Interrupt status word
 
 	if ((Istatus & IS_XA2_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_XA2_CSR, CSR_IRQ_CL_C);
+
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E011,
 			SKERR_SIRQ_E011MSG);
 		Para.Para64 = MAC_2;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
@@ -750,41 +983,39 @@ SK_U32	Istatus)	/* Interrupt status word
 	/* External reg interrupt */
 	if ((Istatus & IS_EXT_REG) != 0) {
 		/* Test IRQs from PHY */
 		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
-			
+
 			pPrt = &pAC->GIni.GP[i];
-			
+
 			if (pPrt->PState == SK_PRT_RESET) {
 				continue;
 			}
-			
+
 #ifdef GENESIS
 			if (pAC->GIni.GIGenesis) {
-				
+
 				switch (pPrt->PhyType) {
-				
+
 				case SK_PHY_XMAC:
 					break;
-				
+
 				case SK_PHY_BCOM:
 					SkXmPhyRead(pAC, IoC, i, PHY_BCOM_INT_STAT, &PhyInt);
-	
+
 					if ((PhyInt & ~PHY_B_DEF_MSK) != 0) {
 						SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-							("Port %d Bcom Int: 0x%04X\n",
-							i, PhyInt));
+							("Port %d PHY Int: 0x%04X\n", i, PhyInt));
 						SkPhyIsrBcom(pAC, IoC, i, PhyInt);
 					}
 					break;
 #ifdef OTHER_PHY
 				case SK_PHY_LONE:
 					SkXmPhyRead(pAC, IoC, i, PHY_LONE_INT_STAT, &PhyInt);
-					
+
 					if ((PhyInt & PHY_L_DEF_MSK) != 0) {
 						SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-							("Port %d Lone Int: %x\n",
-							i, PhyInt));
+							("Port %d PHY Int: 0x%04X\n", i, PhyInt));
 						SkPhyIsrLone(pAC, IoC, i, PhyInt);
 					}
 					break;
 #endif /* OTHER_PHY */
@@ -798,24 +1029,23 @@ SK_U32	Istatus)	/* Interrupt status word
 				SkGmPhyRead(pAC, IoC, i, PHY_MARV_INT_STAT, &PhyInt);
 
 				if ((PhyInt & PHY_M_DEF_MSK) != 0) {
 					SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-						("Port %d Marv Int: 0x%04X\n",
-						i, PhyInt));
+						("Port %d PHY Int: 0x%04X\n", i, PhyInt));
 					SkPhyIsrGmac(pAC, IoC, i, PhyInt);
 				}
 			}
 #endif /* YUKON */
 		}
 	}
 
-	/* I2C Ready interrupt */
+	/* TWSI Ready interrupt */
 	if ((Istatus & IS_I2C_READY) != 0) {
 #ifdef SK_SLIM
-        SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
-#else		
+		SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
+#else
 		SkI2cIsr(pAC, IoC);
-#endif		
+#endif
 	}
 
 	/* SW forced interrupt */
 	if ((Istatus & IS_IRQ_SW) != 0) {
@@ -828,9 +1058,9 @@ SK_U32	Istatus)	/* Interrupt status word
 		 * We do NOT need the Link Sync interrupt, because it shows
 		 * us only a link going down.
 		 */
 		/* clear interrupt */
-		SK_OUT8(IoC, MR_ADDR(MAC_1, LNK_SYNC_CTRL), LED_CLR_IRQ);
+		SK_OUT8(IoC, MR_ADDR(MAC_1, LNK_SYNC_CTRL), LNK_CLR_IRQ);
 	}
 
 	/* Check MAC after link sync counter */
 	if ((Istatus & IS_MAC1) != 0) {
@@ -843,9 +1073,9 @@ SK_U32	Istatus)	/* Interrupt status word
 		 * We do NOT need the Link Sync interrupt, because it shows
 		 * us only a link going down.
 		 */
 		/* clear interrupt */
-		SK_OUT8(IoC, MR_ADDR(MAC_2, LNK_SYNC_CTRL), LED_CLR_IRQ);
+		SK_OUT8(IoC, MR_ADDR(MAC_2, LNK_SYNC_CTRL), LNK_CLR_IRQ);
 	}
 
 	/* Check MAC after link sync counter */
 	if ((Istatus & IS_MAC2) != 0) {
@@ -859,15 +1089,191 @@ SK_U32	Istatus)	/* Interrupt status word
 		if (((Istatus & IS_HW_ERR) & ~pAC->GIni.GIValIrqMask) != 0) {
 			/* read the HW Error Interrupt source */
 			SK_IN32(IoC, B0_HWE_ISRC, &RegVal32);
 
-			SkGeHwErr(pAC, IoC, RegVal32);
+			SkGeYuHwErr(pAC, IoC, RegVal32);
 		}
 
 		SkHwtIsr(pAC, IoC);
 	}
 
-}	/* SkGeSirqIsr */
+}	/* SkGeYuSirqIsr */
+
+#ifdef YUK2
+/******************************************************************************
+ *
+ *	SkYuk2PortSirq() - Service HW Errors for specified port (Yukon-2 only)
+ *
+ * Description: handles the HW Error interrupts for a specific port.
+ *
+ * Returns: N/A
+ */
+static void SkYuk2PortSirq(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+SK_U32	IStatus,	/* Interrupt status word */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
+	SK_EVPARA	Para;
+	int Queue;
+	SK_U16	PhyInt;
+
+	if (Port == MAC_2) {
+		IStatus >>= 8;
+	}
+
+	/* Interrupt from PHY */
+	if ((IStatus & Y2_IS_IRQ_PHY1) != 0) {
+		/* Read PHY Interrupt Status */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_INT_STAT, &PhyInt);
+
+		if ((PhyInt & PHY_M_DEF_MSK) != 0) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+				("Port %d PHY Int: 0x%04X\n", Port, PhyInt));
+			SkPhyIsrGmac(pAC, IoC, Port, PhyInt);
+		}
+	}
+
+	/* Interrupt from MAC */
+	if ((IStatus & Y2_IS_IRQ_MAC1) != 0) {
+		SkMacIrq(pAC, IoC, Port);
+	}
+
+	if ((IStatus & (Y2_IS_CHK_RX1 | Y2_IS_CHK_TXS1 | Y2_IS_CHK_TXA1)) != 0) {
+		if ((IStatus & Y2_IS_CHK_RX1) != 0) {
+			if (Port == MAC_1) {
+				Queue = Q_R1;
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E006,
+					SKERR_SIRQ_E006MSG);
+			}
+			else {
+				Queue = Q_R2;
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E007,
+					SKERR_SIRQ_E007MSG);
+			}
+			/* Clear IRQ */
+			SK_OUT32(IoC, Q_ADDR(Queue, Q_CSR), BMU_CLR_IRQ_CHK);
+		}
+
+		if ((IStatus & Y2_IS_CHK_TXS1) != 0) {
+			if (Port == MAC_1) {
+				Queue = Q_XS1;
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E008,
+					SKERR_SIRQ_E008MSG);
+			}
+			else {
+				Queue = Q_XS2;
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E010,
+					SKERR_SIRQ_E010MSG);
+			}
+			/* Clear IRQ */
+			SK_OUT32(IoC, Q_ADDR(Queue, Q_CSR), BMU_CLR_IRQ_CHK);
+		}
+
+		if ((IStatus & Y2_IS_CHK_TXA1) != 0) {
+			if (Port == MAC_1) {
+				Queue = Q_XA1;
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E009,
+					SKERR_SIRQ_E009MSG);
+			}
+			else {
+				Queue = Q_XA2;
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E011,
+					SKERR_SIRQ_E011MSG);
+			}
+			/* Clear IRQ */
+			SK_OUT32(IoC, Q_ADDR(Queue, Q_CSR), BMU_CLR_IRQ_CHK);
+		}
+
+		Para.Para64 = Port;
+		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
+
+		Para.Para32[0] = Port;
+		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
+	}
+}	/* SkYuk2PortSirq */
+#endif /* YUK2 */
+
+/******************************************************************************
+ *
+ *	SkYuk2SirqIsr() - Special Interrupt Service Routine	(Yukon-2 only)
+ *
+ * Description: handles all non data transfer specific interrupts (slow path)
+ *
+ * Returns: N/A
+ */
+void SkYuk2SirqIsr(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+SK_U32	Istatus)	/* Interrupt status word */
+{
+#ifdef YUK2
+	SK_EVPARA	Para;
+	SK_U32		RegVal32;	/* Read register value */
+	SK_U32		DwValue;
+
+	/* HW Error indicated ? */
+	if (((Istatus & Y2_IS_HW_ERR) & pAC->GIni.GIValIrqMask) != 0) {
+		/* read the HW Error Interrupt source */
+		SK_IN32(IoC, B0_HWE_ISRC, &RegVal32);
+
+		SkYuk2HwErr(pAC, IoC, RegVal32);
+	}
+
+	/* Interrupt from ASF Subsystem */
+	if ((Istatus & Y2_IS_ASF) != 0) {
+		/* clear IRQ */
+		/* later on clearing should be done in ASF ISR handler */
+		SK_IN32(IoC, B28_Y2_ASF_STAT_CMD, &DwValue);
+		DwValue |= Y2_ASF_CLR_HSTI;
+		SK_OUT32(IoC, B28_Y2_ASF_STAT_CMD, DwValue);
+		/* Call IRQ handler in ASF Module */
+		/* TBD */
+	}
+
+	/* Check IRQ from polling unit */
+	if ((Istatus & Y2_IS_POLL_CHK) != 0) {
+		/* Clear IRQ */
+		SK_OUT32(IoC, POLL_CTRL, PC_CLR_IRQ_CHK);
+
+		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E036,
+			SKERR_SIRQ_E036MSG);
+		Para.Para64 = 0;
+		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
+	}
+
+	/* TWSI Ready interrupt */
+	if ((Istatus & Y2_IS_TWSI_RDY) != 0) {
+#ifdef SK_SLIM
+		SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
+#else
+		SkI2cIsr(pAC, IoC);
+#endif
+	}
+
+	/* SW forced interrupt */
+	if ((Istatus & Y2_IS_IRQ_SW) != 0) {
+		/* clear the software IRQ */
+		SK_OUT8(IoC, B0_CTST, CS_CL_SW_IRQ);
+	}
+
+	if ((Istatus & Y2_IS_L1_MASK) != 0) {
+		SkYuk2PortSirq(pAC, IoC, Istatus, MAC_1);
+	}
+
+	if ((Istatus & Y2_IS_L2_MASK) != 0) {
+		SkYuk2PortSirq(pAC, IoC, Istatus, MAC_2);
+	}
+
+	/* Timer interrupt (served last) */
+	if ((Istatus & Y2_IS_TIMINT) != 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+			("Timer Int: 0x%08X\n", Istatus));
+		SkHwtIsr(pAC, IoC);
+	}
+#endif	/* YUK2 */
+
+}	/* SkYuk2SirqIsr */
 
 
 #ifdef GENESIS
 /******************************************************************************
@@ -879,10 +1285,10 @@ SK_U32	Istatus)	/* Interrupt status word
  *	1	Restart needed on this port
  */
 static int SkGePortCheckShorts(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO Context */
-int		Port)		/* Which port should be checked */
+SK_IOC	IoC,		/* I/O Context */
+int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_U32		Shorts;			/* Short Event Counter */
 	SK_U32		CheckShorts;	/* Check value for Short Event Counter */
 	SK_U64		RxCts;			/* Rx Counter (packets on network) */
@@ -927,12 +1333,12 @@ int		Port)		/* Which port should be chec
 		/* If link is up check for 2 */
 		CheckShorts = 2;
 
 		(void)SkXmMacStatistic(pAC, IoC, Port, XM_RXF_FCS_ERR, &FcsErrCts);
-		
+
 		if (pPrt->PLinkModeConf == SK_LMODE_AUTOSENSE &&
-		    pPrt->PLipaAutoNeg == SK_LIPA_UNKNOWN &&
-		    (pPrt->PLinkMode == SK_LMODE_HALF ||
+			pPrt->PLipaAutoNeg == SK_LIPA_UNKNOWN &&
+			(pPrt->PLinkMode == SK_LMODE_HALF ||
 			 pPrt->PLinkMode == SK_LMODE_FULL)) {
 			/*
 			 * This is autosensing and we are in the fallback
 			 * manual full/half duplex mode.
@@ -940,18 +1346,18 @@ int		Port)		/* Which port should be chec
 			if (RxCts == pPrt->PPrevRx) {
 				/* Nothing received, restart link */
 				pPrt->PPrevFcs = FcsErrCts;
 				pPrt->PPrevShorts = Shorts;
-				
+
 				return(SK_HW_PS_RESTART);
 			}
 			else {
 				pPrt->PLipaAutoNeg = SK_LIPA_MANUAL;
 			}
 		}
 
 		if (((RxCts - pPrt->PPrevRx) > pPrt->PRxLim) ||
-		    (!(FcsErrCts - pPrt->PPrevFcs))) {
+			(!(FcsErrCts - pPrt->PPrevFcs))) {
 			/*
 			 * Note: The compare with zero above has to be done the way shown,
 			 * otherwise the Linux driver will have a problem.
 			 */
@@ -994,17 +1400,17 @@ int		Port)		/* Which port should be chec
  *	2	Link came up
  */
 static int SkGePortCheckUp(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO Context */
-int		Port)		/* Which port should be checked */
+SK_IOC	IoC,		/* I/O Context */
+int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
 	int			Rtv;		/* Return value */
 
 	Rtv = SK_HW_PS_NONE;
-	
+
 	pPrt = &pAC->GIni.GP[Port];
 
 	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 		AutoNeg = SK_FALSE;
@@ -1016,9 +1422,9 @@ int		Port)		/* Which port should be chec
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 
 		switch (pPrt->PhyType) {
-		
+
 		case SK_PHY_XMAC:
 			Rtv = SkGePortCheckUpXmac(pAC, IoC, Port, AutoNeg);
 			break;
 		case SK_PHY_BCOM:
@@ -1037,9 +1443,9 @@ int		Port)		/* Which port should be chec
 #endif /* GENESIS */
 	
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		Rtv = SkGePortCheckUpGmac(pAC, IoC, Port, AutoNeg);
 	}
 #endif /* YUKON */
 
@@ -1058,10 +1464,10 @@ int		Port)		/* Which port should be chec
  *	2	Link came up
  */
 static int SkGePortCheckUpXmac(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO Context */
-int		Port,		/* Which port should be checked */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	SK_U32		Shorts;		/* Short Event Counter */
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
@@ -1097,9 +1503,9 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 			/* The Link is in sync */
 			XM_IN16(IoC, Port, XM_ISRC, &Isrc);
 			IsrcSum |= Isrc;
 			SkXmAutoNegLipaXmac(pAC, IoC, Port, IsrcSum);
-			
+
 			if ((Isrc & XM_IS_INP_ASS) == 0) {
 				/* It has been in sync since last time */
 				/* Restart the PORT */
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
@@ -1123,23 +1529,23 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 				 *  we do NOT restart the active link and
 				 *  check whether the link is now o.k.
 				 */
 				pPrt->PLinkResCt++;
-				
+
 				pPrt->PAutoNegTimeOut = 0;
 
 				if (pPrt->PLinkResCt < SK_MAX_LRESTART) {
 					return(SK_HW_PS_RESTART);
 				}
 
 				pPrt->PLinkResCt = 0;
-				
+
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("Do NOT restart on Port %d %x %x\n", Port, Isrc, IsrcSum));
 			}
 			else {
 				pPrt->PIsave = (SK_U16)(IsrcSum & XM_IS_AND);
-				
+
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("Save Sync/nosync Port %d %x %x\n", Port, Isrc, IsrcSum));
 
 				/* Do nothing more if link is broken */
@@ -1216,12 +1622,12 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 			if (Done != SK_AND_OK) {
 				/* Get PHY parameters, for debugging only */
 				SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_AUNE_LP, &LpAb);
 				SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_RES_ABI, &ResAb);
-				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 					("AutoNeg FAIL Port %d (LpAb %x, ResAb %x)\n",
 					 Port, LpAb, ResAb));
-					
+
 				/* Try next possible mode */
 				NextMode = SkHWSenseGetNext(pAC, IoC, Port);
 				SkHWLinkDown(pAC, IoC, Port);
 				if (Done == SK_AND_DUP_CAP) {
@@ -1235,12 +1641,12 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 			 * Dummy Read extended status to prevent extra link down/ups
 			 * (clear Page Received bit if set)
 			 */
 			SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_AUNE_EXP, &ExtStat);
-			
+
 			return(SK_HW_PS_LINK);
 		}
-		
+
 		/* AutoNeg not done, but HW link is up. Check for timeouts */
 		pPrt->PAutoNegTimeOut++;
 		if (pPrt->PAutoNegTimeOut >= SK_AND_MAX_TO) {
 			/* Increase the Timeout counter */
@@ -1282,16 +1688,16 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 	else {
 		/* Link is up and we don't need more */
 #ifdef DEBUG
 		if (pPrt->PLipaAutoNeg == SK_LIPA_AUTO) {
-			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 				("ERROR: Lipa auto detected on port %d\n", Port));
 		}
 #endif /* DEBUG */
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 			("Link sync(GP), Port %d\n", Port));
 		SkHWLinkUp(pAC, IoC, Port);
-		
+
 		/*
 		 * Link sync (GP) and so assume a good connection. But if not received
 		 * a bunch of frames received in a time slot (maybe broken tx cable)
 		 * the port is restart.
@@ -1313,10 +1719,10 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
  *	2	Link came up
  */
 static int SkGePortCheckUpBcom(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO Context */
-int		Port,		/* Which port should be checked */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	int			Done;
@@ -1333,76 +1739,8 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 
 	/* Check for No HCD Link events (#10523) */
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_STAT, &Isrc);
 
-#ifdef xDEBUG
-	if ((Isrc & ~(PHY_B_IS_HCT | PHY_B_IS_LCT) ==
-		(PHY_B_IS_SCR_S_ER | PHY_B_IS_RRS_CHANGE | PHY_B_IS_LRS_CHANGE)) {
-
-		SK_U32	Stat1, Stat2, Stat3;
-
-		Stat1 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_MASK, &Stat1);
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"CheckUp1 - Stat: %x, Mask: %x",
-			(void *)Isrc,
-			(void *)Stat1);
-
-		Stat1 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_CTRL, &Stat1);
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_STAT, &Stat2);
-		Stat1 = Stat1 << 16 | Stat2;
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_ADV, &Stat2);
-		Stat3 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_LP, &Stat3);
-		Stat2 = Stat2 << 16 | Stat3;
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"Ctrl/Stat: %x, AN Adv/LP: %x",
-			(void *)Stat1,
-			(void *)Stat2);
-
-		Stat1 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_EXP, &Stat1);
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_EXT_STAT, &Stat2);
-		Stat1 = Stat1 << 16 | Stat2;
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_CTRL, &Stat2);
-		Stat3 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &Stat3);
-		Stat2 = Stat2 << 16 | Stat3;
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"AN Exp/IEEE Ext: %x, 1000T Ctrl/Stat: %x",
-			(void *)Stat1,
-			(void *)Stat2);
-
-		Stat1 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_P_EXT_CTRL, &Stat1);
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_P_EXT_STAT, &Stat2);
-		Stat1 = Stat1 << 16 | Stat2;
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &Stat2);
-		Stat3 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_STAT, &Stat3);
-		Stat2 = Stat2 << 16 | Stat3;
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"PHY Ext Ctrl/Stat: %x, Aux Ctrl/Stat: %x",
-			(void *)Stat1,
-			(void *)Stat2);
-	}
-#endif /* DEBUG */
-
 	if ((Isrc & (PHY_B_IS_NO_HDCL /* | PHY_B_IS_NO_HDC */)) != 0) {
 		/*
 		 * Workaround BCom Errata:
 		 *	enable and disable loopback mode if "NO HCD" occurs.
@@ -1413,16 +1751,8 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 		SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_CTRL,
 			(SK_U16)(Ctrl & ~PHY_CT_LOOP));
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("No HCD Link event, Port %d\n", Port));
-#ifdef xDEBUG
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"No HCD link event, port %d.",
-			(void *)Port,
-			(void *)NULL);
-#endif /* DEBUG */
 	}
 
 	/* Not obsolete: link status bit is latched to 0 and autoclearing! */
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_STAT, &PhyStat);
@@ -1430,172 +1760,79 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 	if (pPrt->PHWLinkUp) {
 		return(SK_HW_PS_NONE);
 	}
 
-#ifdef xDEBUG
-	{
-		SK_U32	Stat1, Stat2, Stat3;
-
-		Stat1 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_MASK, &Stat1);
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"CheckUp1a - Stat: %x, Mask: %x",
-			(void *)Isrc,
-			(void *)Stat1);
-
-		Stat1 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_CTRL, &Stat1);
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_STAT, &PhyStat);
-		Stat1 = Stat1 << 16 | PhyStat;
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_ADV, &Stat2);
-		Stat3 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_LP, &Stat3);
-		Stat2 = Stat2 << 16 | Stat3;
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"Ctrl/Stat: %x, AN Adv/LP: %x",
-			(void *)Stat1,
-			(void *)Stat2);
-
-		Stat1 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_EXP, &Stat1);
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_EXT_STAT, &Stat2);
-		Stat1 = Stat1 << 16 | Stat2;
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_CTRL, &Stat2);
-		Stat3 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
-		Stat2 = Stat2 << 16 | ResAb;
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"AN Exp/IEEE Ext: %x, 1000T Ctrl/Stat: %x",
-			(void *)Stat1,
-			(void *)Stat2);
-
-		Stat1 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_P_EXT_CTRL, &Stat1);
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_P_EXT_STAT, &Stat2);
-		Stat1 = Stat1 << 16 | Stat2;
-		Stat2 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &Stat2);
-		Stat3 = 0;
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_STAT, &Stat3);
-		Stat2 = Stat2 << 16 | Stat3;
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"PHY Ext Ctrl/Stat: %x, Aux Ctrl/Stat: %x",
-			(void *)Stat1,
-			(void *)Stat2);
-	}
-#endif /* DEBUG */
-
 	/*
 	 * Here we usually can check whether the link is in sync and
 	 * auto-negotiation is done.
 	 */
 
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_STAT, &PhyStat);
 
 	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
-	
+
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("CheckUp Port %d, PhyStat: 0x%04X\n", Port, PhyStat));
 
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
 
 	if ((ResAb & PHY_B_1000S_MSF) != 0) {
 		/* Error */
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Master/Slave Fault port %d\n", Port));
-		
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
+			("Master/Slave Fault, ResAb: 0x%04X\n", ResAb));
+
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
-		
+
 		return(SK_HW_PS_RESTART);
 	}
 
 	if ((PhyStat & PHY_ST_LSYNC) == 0) {
 		return(SK_HW_PS_NONE);
 	}
-	
+
 	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
 		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
-	
+
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Port %d, ResAb: 0x%04X\n", Port, ResAb));
 
 	if (AutoNeg) {
 		if ((PhyStat & PHY_ST_AN_OVER) != 0) {
 			
 			SkHWLinkUp(pAC, IoC, Port);
-			
+
 			Done = SkMacAutoNegDone(pAC, IoC, Port);
-			
+
 			if (Done != SK_AND_OK) {
 #ifdef DEBUG
 				/* Get PHY parameters, for debugging only */
 				SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_LP, &LpAb);
 				SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ExtStat);
-				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 					("AutoNeg FAIL Port %d (LpAb %x, 1000TStat %x)\n",
 					Port, LpAb, ExtStat));
 #endif /* DEBUG */
 				return(SK_HW_PS_RESTART);
 			}
 			else {
-#ifdef xDEBUG
-				/* Dummy read ISR to prevent extra link downs/ups */
-				SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_STAT, &ExtStat);
-
-				if ((ExtStat & ~(PHY_B_IS_HCT | PHY_B_IS_LCT)) != 0) {
-					CMSMPrintString(
-						pAC->pConfigTable,
-						MSG_TYPE_RUNTIME_INFO,
-						"CheckUp2 - Stat: %x",
-						(void *)ExtStat,
-						(void *)NULL);
-				}
-#endif /* DEBUG */
 				return(SK_HW_PS_LINK);
 			}
 		}
 	}
 	else {	/* !AutoNeg */
 		/* Link is up and we don't need more. */
 #ifdef DEBUG
 		if (pPrt->PLipaAutoNeg == SK_LIPA_AUTO) {
-			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 				("ERROR: Lipa auto detected on port %d\n", Port));
 		}
 #endif /* DEBUG */
 
-#ifdef xDEBUG
-		/* Dummy read ISR to prevent extra link downs/ups */
-		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_STAT, &ExtStat);
-
-		if ((ExtStat & ~(PHY_B_IS_HCT | PHY_B_IS_LCT)) != 0) {
-			CMSMPrintString(
-				pAC->pConfigTable,
-				MSG_TYPE_RUNTIME_INFO,
-				"CheckUp3 - Stat: %x",
-				(void *)ExtStat,
-				(void *)NULL);
-		}
-#endif /* DEBUG */
-		
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 			("Link sync(GP), Port %d\n", Port));
 		SkHWLinkUp(pAC, IoC, Port);
-		
+
 		return(SK_HW_PS_LINK);
 	}
 
 	return(SK_HW_PS_NONE);
@@ -1614,16 +1851,15 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
  *	2	Link came up
  */
 static int SkGePortCheckUpGmac(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO Context */
-int		Port,		/* Which port should be checked */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	int			Done;
-	SK_U16		PhyIsrc;	/* PHY Interrupt source */
-	SK_U16		PhyStat;	/* PPY Status */
+	SK_U16		PhyStat;	/* PHY Status */
 	SK_U16		PhySpecStat;/* PHY Specific Status */
 	SK_U16		ResAb;		/* Master/Slave resolution */
 	SK_EVPARA	Para;
 #ifdef DEBUG
@@ -1641,104 +1877,96 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("CheckUp Port %d, PhyStat: 0x%04X\n", Port, PhyStat));
 
-	/* Read PHY Interrupt Status */
-	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_INT_STAT, &PhyIsrc);
-
-	if ((PhyIsrc & PHY_M_IS_AN_COMPL) != 0) {
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Auto-Negotiation Completed, PhyIsrc: 0x%04X\n", PhyIsrc));
-	}
-
-	if ((PhyIsrc & PHY_M_IS_LSP_CHANGE) != 0) {
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Link Speed Changed, PhyIsrc: 0x%04X\n", PhyIsrc));
-	}
-
 	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
-	
+
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_1000T_STAT, &ResAb);
 
 	if ((ResAb & PHY_B_1000S_MSF) != 0) {
 		/* Error */
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Master/Slave Fault port %d\n", Port));
-		
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
+			("Master/Slave Fault, ResAb: 0x%04X\n", ResAb));
+
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
-		
+
 		return(SK_HW_PS_RESTART);
 	}
 
 	/* Read PHY Specific Status */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &PhySpecStat);
-	
+
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Phy1000BT: 0x%04X, PhySpecStat: 0x%04X\n", ResAb, PhySpecStat));
 
 #ifdef DEBUG
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_EXP, &Word);
 
-	if ((PhyIsrc & PHY_M_IS_AN_PR) != 0 || (Word & PHY_ANE_RX_PG) != 0 ||
+	if ((Word & PHY_ANE_RX_PG) != 0 ||
 		(PhySpecStat & PHY_M_PS_PAGE_REC) != 0)  {
 		/* Read PHY Next Page Link Partner */
 		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_NEPG_LP, &Word);
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Page Received, NextPage: 0x%04X\n", Word));
+			("Page received, NextPage: 0x%04X\n", Word));
 	}
 #endif /* DEBUG */
 
 	if ((PhySpecStat & PHY_M_PS_LINK_UP) == 0) {
+		/* Link down */
 		return(SK_HW_PS_NONE);
 	}
-	
-	if ((PhySpecStat & PHY_M_PS_DOWNS_STAT) != 0 ||
-		(PhyIsrc & PHY_M_IS_DOWNSH_DET) != 0) {
+
+	if ((PhySpecStat & PHY_M_PS_DOWNS_STAT) != 0) {
 		/* Downshift detected */
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E025, SKERR_SIRQ_E025MSG);
-		
+
 		Para.Para64 = Port;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_DOWNSHIFT_DET, Para);
-		
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Downshift detected, PhySpecStat: 0x%04X\n", PhySpecStat));
+	}
+
+	if ((PhySpecStat & PHY_M_PS_MDI_X_STAT) != 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Downshift detected, PhyIsrc: 0x%04X\n", PhyIsrc));
+			("MDI Xover detected, PhyStat: 0x%04X\n", PhySpecStat));
 	}
 
 	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
 		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
-	
+
 	pPrt->PCableLen = (SK_U8)((PhySpecStat & PHY_M_PS_CABLE_MSK) >> 7);
-	
+
 	if (AutoNeg) {
 		/* Auto-Negotiation Over ? */
 		if ((PhyStat & PHY_ST_AN_OVER) != 0) {
-			
+
 			SkHWLinkUp(pAC, IoC, Port);
-			
+
 			Done = SkMacAutoNegDone(pAC, IoC, Port);
-			
+
 			if (Done != SK_AND_OK) {
 				return(SK_HW_PS_RESTART);
 			}
-			
+
 			return(SK_HW_PS_LINK);
 		}
 	}
 	else {	/* !AutoNeg */
 		/* Link is up and we don't need more */
 #ifdef DEBUG
 		if (pPrt->PLipaAutoNeg == SK_LIPA_AUTO) {
-			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 				("ERROR: Lipa auto detected on port %d\n", Port));
 		}
 #endif /* DEBUG */
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 			("Link sync, Port %d\n", Port));
 		SkHWLinkUp(pAC, IoC, Port);
-		
+
 		return(SK_HW_PS_LINK);
 	}
 
 	return(SK_HW_PS_NONE);
@@ -1757,10 +1985,10 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
  *	2	Link came up
  */
 static int SkGePortCheckUpLone(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO Context */
-int		Port,		/* Which port should be checked */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	int			Done;
@@ -1808,9 +2036,9 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 			if (Done != SK_AND_OK) {
 				/* Get PHY parameters, for debugging only */
 				SkXmPhyRead(pAC, IoC, Port, PHY_LONE_AUNE_LP, &LpAb);
 				SkXmPhyRead(pAC, IoC, Port, PHY_LONE_1000T_STAT, &ExtStat);
-				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 					("AutoNeg FAIL Port %d (LpAb %x, 1000TStat %x)\n",
 					 Port, LpAb, ExtStat));
 					
 				/* Try next possible mode */
@@ -1832,9 +2060,9 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 				SkXmPhyRead(pAC, IoC, Port, PHY_LONE_INT_STAT, &ExtStat);
 				return(SK_HW_PS_LINK);
 			}
 		}
-		
+
 		/* AutoNeg not done, but HW link is up. Check for timeouts */
 		pPrt->PAutoNegTimeOut++;
 		if (pPrt->PAutoNegTimeOut >= SK_AND_MAX_TO) {
 			/* Timeout occured */
@@ -1855,9 +2083,9 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 	else {
 		/* Link is up and we don't need more */
 #ifdef DEBUG
 		if (pPrt->PLipaAutoNeg == SK_LIPA_AUTO) {
-			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 				("ERROR: Lipa auto detected on port %d\n", Port));
 		}
 #endif /* DEBUG */
 
@@ -1888,10 +2116,10 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
  *	2	Link came up
  */
 static int SkGePortCheckUpNat(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO Context */
-int		Port,		/* Which port should be checked */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	/* todo: National */
 	return(SK_HW_PS_NONE);
@@ -1908,9 +2136,9 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
  * Notes:
  */
 int	SkGeSirqEvent(
 SK_AC		*pAC,		/* Adapter Context */
-SK_IOC		IoC,		/* Io Context */
+SK_IOC		IoC,		/* I/O Context */
 SK_U32		Event,		/* Module specific Event */
 SK_EVPARA	Para)		/* Event specific Parameter */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
@@ -1927,9 +2155,9 @@ SK_EVPARA	Para)		/* Event specific Param
 
 	switch (Event) {
 	case SK_HWEV_WATIM:
 		if (pPrt->PState == SK_PRT_RESET) {
-		
+
 			PortStat = SK_HW_PS_NONE;
 		}
 		else {
 			/* Check whether port came up */
@@ -1957,21 +2185,25 @@ SK_EVPARA	Para)		/* Event specific Param
 			/* Signal to RLMT */
 			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_UP, Para);
 			break;
 		}
-		
+
 		/* Start again the check Timer */
 		if (pPrt->PHWLinkUp) {
+			
 			Val32 = SK_WA_ACT_TIME;
 		}
 		else {
 			Val32 = SK_WA_INA_TIME;
-		}
 
-		/* Todo: still needed for non-XMAC PHYs??? */
+			if (pAC->GIni.GIYukon) {
+				Val32 *= 5;
+			}
+		}
 		/* Start workaround Errata #2 timer */
 		SkTimerStart(pAC, IoC, &pPrt->PWaTimer, Val32,
 			SKGE_HWAC, SK_HWEV_WATIM, Para);
+
 		break;
 
 	case SK_HWEV_PORT_START:
 		if (pPrt->PHWLinkUp) {
@@ -1989,8 +2221,9 @@ SK_EVPARA	Para)		/* Event specific Param
 
 		/* Start workaround Errata #2 timer */
 		SkTimerStart(pAC, IoC, &pPrt->PWaTimer, SK_WA_INA_TIME,
 			SKGE_HWAC, SK_HWEV_WATIM, Para);
+
 		break;
 
 	case SK_HWEV_PORT_STOP:
 		if (pPrt->PHWLinkUp) {
@@ -2096,22 +2329,22 @@ SK_EVPARA	Para)		/* Event specific Param
 
 				(void)SkXmMacStatistic(pAC, IoC, Port, XM_TXO_OK_HI, &Val32);
 
 				Octets = (SK_U64)Val32 << 32;
-				
+
 				(void)SkXmMacStatistic(pAC, IoC, Port, XM_TXO_OK_LO, &Val32);
 
 				Octets += Val32;
-				
+
 				if (pPrt->LastOctets == Octets) {
 					/* Tx hanging, a FIFO flush restarts it */
 					SkMacFlushTxFifo(pAC, IoC, Port);
 				}
 			}
 		}
 		break;
 #endif /* GENESIS */
-	
+
 	default:
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_SIRQ_E001, SKERR_SIRQ_E001MSG);
 		break;
 	}
@@ -2130,10 +2363,10 @@ SK_EVPARA	Para)		/* Event specific Param
  * Returns: N/A
  */
 static void SkPhyIsrBcom(
 SK_AC		*pAC,		/* Adapter Context */
-SK_IOC		IoC,		/* Io Context */
-int			Port,		/* Port Num = PHY Num */
+SK_IOC		IoC,		/* I/O Context */
+int			Port,		/* Port Index (MAC_1 + n) */
 SK_U16		IStatus)	/* Interrupt Status */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	SK_EVPARA	Para;
@@ -2144,9 +2377,9 @@ SK_U16		IStatus)	/* Interrupt Status */
 		/* Incorrectable pair swap error */
 		SK_ERR_LOG(pAC, SK_ERRCL_HW | SK_ERRCL_INIT, SKERR_SIRQ_E022,
 			SKERR_SIRQ_E022MSG);
 	}
-	
+
 	if ((IStatus & (PHY_B_IS_AN_PR | PHY_B_IS_LST_CHANGE)) != 0) {
 
 		SkHWLinkDown(pAC, IoC, Port);
 
@@ -2173,49 +2406,73 @@ SK_U16		IStatus)	/* Interrupt Status */
  * Returns: N/A
  */
 static void SkPhyIsrGmac(
 SK_AC		*pAC,		/* Adapter Context */
-SK_IOC		IoC,		/* Io Context */
-int			Port,		/* Port Num = PHY Num */
+SK_IOC		IoC,		/* I/O Context */
+int			Port,		/* Port Index (MAC_1 + n) */
 SK_U16		IStatus)	/* Interrupt Status */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	SK_EVPARA	Para;
 	SK_U16		Word;
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	if ((IStatus & (PHY_M_IS_AN_PR | PHY_M_IS_LST_CHANGE)) != 0) {
-
-		SkHWLinkDown(pAC, IoC, Port);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("PHY IRQ, PhyIsrc: 0x%04X\n", IStatus));
 
-		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_ADV, &Word);
+	if ((IStatus & PHY_M_IS_LST_CHANGE) != 0) {
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("AutoNeg.Adv: 0x%04X\n", Word));
-		
-		/* Set Auto-negotiation advertisement */
-		if (pPrt->PFlowCtrlMode == SK_FLOW_MODE_SYM_OR_REM) {
-			/* restore Asymmetric Pause bit */
-			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_AUNE_ADV,
-				(SK_U16)(Word | PHY_M_AN_ASP));
-		}
-		
+			("Link Status changed\n", IStatus));
+
 		Para.Para32[0] = (SK_U32)Port;
-		/* Signal to RLMT */
-		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
+
+		if (pPrt->PHWLinkUp) {
+			
+			SkHWLinkDown(pAC, IoC, Port);
+
+			SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_ADV, &Word);
+
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+				("AutoNeg.Adv: 0x%04X\n", Word));
+
+			/* Set Auto-negotiation advertisement */
+			if (pPrt->PFlowCtrlMode == SK_FLOW_MODE_SYM_OR_REM) {
+				/* restore Asymmetric Pause bit */
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_AUNE_ADV,
+					(SK_U16)(Word | PHY_M_AN_ASP));
+			}
+
+			/* Signal to RLMT */
+			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
+		}
+		else {
+
+			if ((IStatus & PHY_M_IS_AN_COMPL) != 0) {
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+					("Auto-Negotiation completed\n"));
+			}
+
+			if ((IStatus & PHY_M_IS_LSP_CHANGE) != 0) {
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+					("Link Speed changed\n"));
+			}
+
+			SkEventQueue(pAC, SKGE_HWAC, SK_HWEV_WATIM, Para);
+		}
 	}
-	
+
 	if ((IStatus & PHY_M_IS_AN_ERROR) != 0) {
 		/* Auto-Negotiation Error */
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E023, SKERR_SIRQ_E023MSG);
 	}
-	
+
 	if ((IStatus & PHY_M_IS_FIFO_ERROR) != 0) {
 		/* FIFO Overflow/Underrun Error */
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E024, SKERR_SIRQ_E024MSG);
 	}
-	
+
 }	/* SkPhyIsrGmac */
 #endif /* YUKON */
 
 
@@ -2229,10 +2486,10 @@ SK_U16		IStatus)	/* Interrupt Status */
  * Returns: N/A
  */
 static void SkPhyIsrLone(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* Io Context */
-int		Port,		/* Port Num = PHY Num */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
 SK_U16	IStatus)	/* Interrupt Status */
 {
 	SK_EVPARA	Para;
 
Index: linux-2.6.8/drivers/net/sk98lin/ski2c.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/ski2c.c
+++ /dev/null
@@ -1,1296 +0,0 @@
-/******************************************************************************
- *
- * Name:	ski2c.c
- * Project:	Gigabit Ethernet Adapters, TWSI-Module
- * Version:	$Revision: 1.59 $
- * Date:	$Date: 2003/10/20 09:07:25 $
- * Purpose:	Functions to access Voltage and Temperature Sensor
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
- *	The information in this file is provided "AS IS" without warranty.
- *
- ******************************************************************************/
-
-/*
- *	I2C Protocol
- */
-#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
-static const char SysKonnectFileId[] =
-	"@(#) $Id: ski2c.c,v 1.59 2003/10/20 09:07:25 rschmidt Exp $ (C) Marvell. ";
-#endif
-
-#include "h/skdrv1st.h"		/* Driver Specific Definitions */
-#include "h/lm80.h"
-#include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
-
-#ifdef __C2MAN__
-/*
-	I2C protocol implementation.
-
-	General Description:
-
-	The I2C protocol is used for the temperature sensors and for
-	the serial EEPROM which hold the configuration.
-
-	This file covers functions that allow to read write and do
-	some bulk requests a specified I2C address.
-
-	The Genesis has 2 I2C buses. One for the EEPROM which holds
-	the VPD Data and one for temperature and voltage sensor.
-	The following picture shows the I2C buses, I2C devices and
-	their control registers.
-
-	Note: The VPD functions are in skvpd.c
-.
-.	PCI Config I2C Bus for VPD Data:
-.
-.		      +------------+
-.		      | VPD EEPROM |
-.		      +------------+
-.			     |
-.			     | <-- I2C
-.			     |
-.		 +-----------+-----------+
-.		 |			 |
-.	+-----------------+	+-----------------+
-.	| PCI_VPD_ADR_REG |	| PCI_VPD_DAT_REG |
-.	+-----------------+	+-----------------+
-.
-.
-.	I2C Bus for LM80 sensor:
-.
-.			+-----------------+
-.			| Temperature and |
-.			| Voltage Sensor  |
-.			| 	LM80	  |
-.			+-----------------+
-.				|
-.				|
-.			I2C --> |
-.				|
-.			     +----+
-.	     +-------------->| OR |<--+
-.	     |		     +----+   |
-.     +------+------+		      |
-.     |		    |		      |
-. +--------+	+--------+	+----------+
-. | B2_I2C |	| B2_I2C |	|  B2_I2C  |
-. | _CTRL  |	| _DATA  |	|   _SW    |
-. +--------+	+--------+	+----------+
-.
-	The I2C bus may be driven by the B2_I2C_SW or by the B2_I2C_CTRL
-	and B2_I2C_DATA registers.
-	For driver software it is recommended to use the I2C control and
-	data register, because I2C bus timing is done by the ASIC and
-	an interrupt may be received when the I2C request is completed.
-
-	Clock Rate Timing:			MIN	MAX	generated by
-		VPD EEPROM:			50 kHz	100 kHz		HW
-		LM80 over I2C Ctrl/Data reg.	50 kHz	100 kHz		HW
-		LM80 over B2_I2C_SW register	0	400 kHz		SW
-
-	Note:	The clock generated by the hardware is dependend on the
-		PCI clock. If the PCI bus clock is 33 MHz, the I2C/VPD
-		clock is 50 kHz.
- */
-intro()
-{}
-#endif
-
-#ifdef SK_DIAG
-/*
- * I2C Fast Mode timing values used by the LM80.
- * If new devices are added to the I2C bus the timing values have to be checked.
- */
-#ifndef I2C_SLOW_TIMING
-#define	T_CLK_LOW			1300L	/* clock low time in ns */
-#define	T_CLK_HIGH		 	 600L	/* clock high time in ns */
-#define T_DATA_IN_SETUP		 100L	/* data in Set-up Time */
-#define T_START_HOLD		 600L	/* start condition hold time */
-#define T_START_SETUP		 600L	/* start condition Set-up time */
-#define	T_STOP_SETUP		 600L	/* stop condition Set-up time */
-#define T_BUS_IDLE			1300L	/* time the bus must free after Tx */
-#define	T_CLK_2_DATA_OUT	 900L	/* max. clock low to data output valid */
-#else	/* I2C_SLOW_TIMING */
-/* I2C Standard Mode Timing */
-#define	T_CLK_LOW			4700L	/* clock low time in ns */
-#define	T_CLK_HIGH			4000L	/* clock high time in ns */
-#define T_DATA_IN_SETUP		 250L	/* data in Set-up Time */
-#define T_START_HOLD		4000L	/* start condition hold time */
-#define T_START_SETUP		4700L	/* start condition Set-up time */
-#define	T_STOP_SETUP		4000L	/* stop condition Set-up time */
-#define T_BUS_IDLE			4700L	/* time the bus must free after Tx */
-#endif	/* !I2C_SLOW_TIMING */
-
-#define NS2BCLK(x)	(((x)*125)/10000)
-
-/*
- * I2C Wire Operations
- *
- * About I2C_CLK_LOW():
- *
- * The Data Direction bit (I2C_DATA_DIR) has to be set to input when setting
- * clock to low, to prevent the ASIC and the I2C data client from driving the
- * serial data line simultaneously (ASIC: last bit of a byte = '1', I2C client
- * send an 'ACK'). See also Concentrator Bugreport No. 10192.
- */
-#define I2C_DATA_HIGH(IoC)	SK_I2C_SET_BIT(IoC, I2C_DATA)
-#define	I2C_DATA_LOW(IoC)	SK_I2C_CLR_BIT(IoC, I2C_DATA)
-#define	I2C_DATA_OUT(IoC)	SK_I2C_SET_BIT(IoC, I2C_DATA_DIR)
-#define	I2C_DATA_IN(IoC)	SK_I2C_CLR_BIT(IoC, I2C_DATA_DIR | I2C_DATA)
-#define	I2C_CLK_HIGH(IoC)	SK_I2C_SET_BIT(IoC, I2C_CLK)
-#define	I2C_CLK_LOW(IoC)	SK_I2C_CLR_BIT(IoC, I2C_CLK | I2C_DATA_DIR)
-#define	I2C_START_COND(IoC)	SK_I2C_CLR_BIT(IoC, I2C_CLK)
-
-#define NS2CLKT(x)	((x*125L)/10000)
-
-/*--------------- I2C Interface Register Functions --------------- */
-
-/*
- * sending one bit
- */
-void SkI2cSndBit(
-SK_IOC	IoC,	/* I/O Context */
-SK_U8	Bit)	/* Bit to send */
-{
-	I2C_DATA_OUT(IoC);
-	if (Bit) {
-		I2C_DATA_HIGH(IoC);
-	}
-	else {
-		I2C_DATA_LOW(IoC);
-	}
-	SkDgWaitTime(IoC, NS2BCLK(T_DATA_IN_SETUP));
-	I2C_CLK_HIGH(IoC);
-	SkDgWaitTime(IoC, NS2BCLK(T_CLK_HIGH));
-	I2C_CLK_LOW(IoC);
-}	/* SkI2cSndBit*/
-
-
-/*
- * Signal a start to the I2C Bus.
- *
- * A start is signaled when data goes to low in a high clock cycle.
- *
- * Ends with Clock Low.
- *
- * Status: not tested
- */
-void SkI2cStart(
-SK_IOC	IoC)	/* I/O Context */
-{
-	/* Init data and Clock to output lines */
-	/* Set Data high */
-	I2C_DATA_OUT(IoC);
-	I2C_DATA_HIGH(IoC);
-	/* Set Clock high */
-	I2C_CLK_HIGH(IoC);
-
-	SkDgWaitTime(IoC, NS2BCLK(T_START_SETUP));
-
-	/* Set Data Low */
-	I2C_DATA_LOW(IoC);
-
-	SkDgWaitTime(IoC, NS2BCLK(T_START_HOLD));
-
-	/* Clock low without Data to Input */
-	I2C_START_COND(IoC);
-
-	SkDgWaitTime(IoC, NS2BCLK(T_CLK_LOW));
-}	/* SkI2cStart */
-
-
-void SkI2cStop(
-SK_IOC	IoC)	/* I/O Context */
-{
-	/* Init data and Clock to output lines */
-	/* Set Data low */
-	I2C_DATA_OUT(IoC);
-	I2C_DATA_LOW(IoC);
-
-	SkDgWaitTime(IoC, NS2BCLK(T_CLK_2_DATA_OUT));
-
-	/* Set Clock high */
-	I2C_CLK_HIGH(IoC);
-
-	SkDgWaitTime(IoC, NS2BCLK(T_STOP_SETUP));
-
-	/*
-	 * Set Data High:	Do it by setting the Data Line to Input.
-	 *			Because of a pull up resistor the Data Line
-	 *			floods to high.
-	 */
-	I2C_DATA_IN(IoC);
-
-	/*
-	 *	When I2C activity is stopped
-	 *	 o	DATA should be set to input and
-	 *	 o	CLOCK should be set to high!
-	 */
-	SkDgWaitTime(IoC, NS2BCLK(T_BUS_IDLE));
-}	/* SkI2cStop */
-
-
-/*
- * Receive just one bit via the I2C bus.
- *
- * Note:	Clock must be set to LOW before calling this function.
- *
- * Returns The received bit.
- */
-int SkI2cRcvBit(
-SK_IOC	IoC)	/* I/O Context */
-{
-	int	Bit;
-	SK_U8	I2cSwCtrl;
-
-	/* Init data as input line */
-	I2C_DATA_IN(IoC);
-
-	SkDgWaitTime(IoC, NS2BCLK(T_CLK_2_DATA_OUT));
-
-	I2C_CLK_HIGH(IoC);
-
-	SkDgWaitTime(IoC, NS2BCLK(T_CLK_HIGH));
-
-	SK_I2C_GET_SW(IoC, &I2cSwCtrl);
-	
-	Bit = (I2cSwCtrl & I2C_DATA) ? 1 : 0;
-
-	I2C_CLK_LOW(IoC);
-	SkDgWaitTime(IoC, NS2BCLK(T_CLK_LOW-T_CLK_2_DATA_OUT));
-
-	return(Bit);
-}	/* SkI2cRcvBit */
-
-
-/*
- * Receive an ACK.
- *
- * returns	0 If acknowledged
- *		1 in case of an error
- */
-int SkI2cRcvAck(
-SK_IOC	IoC)	/* I/O Context */
-{
-	/*
-	 * Received bit must be zero.
-	 */
-	return(SkI2cRcvBit(IoC) != 0);
-}	/* SkI2cRcvAck */
-
-
-/*
- * Send an NACK.
- */
-void SkI2cSndNAck(
-SK_IOC	IoC)	/* I/O Context */
-{
-	/*
-	 * Received bit must be zero.
-	 */
-	SkI2cSndBit(IoC, 1);
-}	/* SkI2cSndNAck */
-
-
-/*
- * Send an ACK.
- */
-void SkI2cSndAck(
-SK_IOC IoC)	/* I/O Context */
-{
-	/*
-	 * Received bit must be zero.
-	 */
-	SkI2cSndBit(IoC, 0);
-}	/* SkI2cSndAck */
-
-
-/*
- * Send one byte to the I2C device and wait for ACK.
- *
- * Return acknowleged status.
- */
-int SkI2cSndByte(
-SK_IOC	IoC,	/* I/O Context */
-int		Byte)	/* byte to send */
-{
-	int	i;
-
-	for (i = 0; i < 8; i++) {
-		if (Byte & (1<<(7-i))) {
-			SkI2cSndBit(IoC, 1);
-		}
-		else {
-			SkI2cSndBit(IoC, 0);
-		}
-	}
-
-	return(SkI2cRcvAck(IoC));
-}	/* SkI2cSndByte */
-
-
-/*
- * Receive one byte and ack it.
- *
- * Return byte.
- */
-int SkI2cRcvByte(
-SK_IOC	IoC,	/* I/O Context */
-int		Last)	/* Last Byte Flag */
-{
-	int	i;
-	int	Byte = 0;
-
-	for (i = 0; i < 8; i++) {
-		Byte <<= 1;
-		Byte |= SkI2cRcvBit(IoC);
-	}
-
-	if (Last) {
-		SkI2cSndNAck(IoC);
-	}
-	else {
-		SkI2cSndAck(IoC);
-	}
-
-	return(Byte);
-}	/* SkI2cRcvByte */
-
-
-/*
- * Start dialog and send device address
- *
- * Return 0 if acknowleged, 1 in case of an error
- */
-int	SkI2cSndDev(
-SK_IOC	IoC,	/* I/O Context */
-int		Addr,	/* Device Address */
-int		Rw)		/* Read / Write Flag */
-{
-	SkI2cStart(IoC);
-	Rw = ~Rw;
-	Rw &= I2C_WRITE;
-	return(SkI2cSndByte(IoC, (Addr<<1) | Rw));
-}	/* SkI2cSndDev */
-
-#endif /* SK_DIAG */
-
-/*----------------- I2C CTRL Register Functions ----------*/
-
-/*
- * waits for a completion of an I2C transfer
- *
- * returns	0:	success, transfer completes
- *			1:	error,	 transfer does not complete, I2C transfer
- *						 killed, wait loop terminated.
- */
-int	SkI2cWait(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC,	/* I/O Context */
-int		Event)	/* complete event to wait for (I2C_READ or I2C_WRITE) */
-{
-	SK_U64	StartTime;
-	SK_U64	CurrentTime;
-	SK_U32	I2cCtrl;
-
-	StartTime = SkOsGetTime(pAC);
-	
-	do {
-		CurrentTime = SkOsGetTime(pAC);
-
-		if (CurrentTime - StartTime > SK_TICKS_PER_SEC / 8) {
-			
-			SK_I2C_STOP(IoC);
-#ifndef SK_DIAG
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E002, SKERR_I2C_E002MSG);
-#endif /* !SK_DIAG */
-			return(1);
-		}
-		
-		SK_I2C_GET_CTL(IoC, &I2cCtrl);
-
-#ifdef xYUKON_DBG
-		printf("StartTime=%lu, CurrentTime=%lu\n",
-			StartTime, CurrentTime);
-		if (kbhit()) {
-			return(1);
-		}
-#endif /* YUKON_DBG */
-	
-	} while ((I2cCtrl & I2C_FLAG) == (SK_U32)Event << 31);
-
-	return(0);
-}	/* SkI2cWait */
-
-
-/*
- * waits for a completion of an I2C transfer
- *
- * Returns
- *	Nothing
- */
-void SkI2cWaitIrq(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC)	/* I/O Context */
-{
-	SK_SENSOR	*pSen;
-	SK_U64		StartTime;
-	SK_U32		IrqSrc;
-
-	pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
-
-	if (pSen->SenState == SK_SEN_IDLE) {
-		return;
-	}
-
-	StartTime = SkOsGetTime(pAC);
-	
-	do {
-		if (SkOsGetTime(pAC) - StartTime > SK_TICKS_PER_SEC / 8) {
-			
-			SK_I2C_STOP(IoC);
-#ifndef SK_DIAG
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E016, SKERR_I2C_E016MSG);
-#endif /* !SK_DIAG */
-			return;
-		}
-		
-		SK_IN32(IoC, B0_ISRC, &IrqSrc);
-
-	} while ((IrqSrc & IS_I2C_READY) == 0);
-
-	pSen->SenState = SK_SEN_IDLE;
-	return;
-}	/* SkI2cWaitIrq */
-
-/*
- * writes a single byte or 4 bytes into the I2C device
- *
- * returns	0:	success
- *			1:	error
- */
-int SkI2cWrite(
-SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* I/O Context */
-SK_U32	I2cData,	/* I2C Data to write */
-int		I2cDev,		/* I2C Device Address */
-int		I2cDevSize, /* I2C Device Size (e.g. I2C_025K_DEV or I2C_2K_DEV) */
-int		I2cReg,		/* I2C Device Register Address */
-int		I2cBurst)	/* I2C Burst Flag */
-{
-	SK_OUT32(IoC, B2_I2C_DATA, I2cData);
-	
-	SK_I2C_CTL(IoC, I2C_WRITE, I2cDev, I2cDevSize, I2cReg, I2cBurst);
-	
-	return(SkI2cWait(pAC, IoC, I2C_WRITE));
-}	/* SkI2cWrite*/
-
-
-#ifdef	SK_DIAG
-/*
- * reads a single byte or 4 bytes from the I2C device
- *
- * returns	the word read
- */
-SK_U32 SkI2cRead(
-SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* I/O Context */
-int		I2cDev,		/* I2C Device Address */
-int		I2cDevSize, /* I2C Device Size (e.g. I2C_025K_DEV or I2C_2K_DEV) */
-int		I2cReg,		/* I2C Device Register Address */
-int		I2cBurst)	/* I2C Burst Flag */
-{
-	SK_U32	Data;
-
-	SK_OUT32(IoC, B2_I2C_DATA, 0);
-	SK_I2C_CTL(IoC, I2C_READ, I2cDev, I2cDevSize, I2cReg, I2cBurst);
-	
-	if (SkI2cWait(pAC, IoC, I2C_READ) != 0) {
-		w_print("%s\n", SKERR_I2C_E002MSG);
-	}
-	
-	SK_IN32(IoC, B2_I2C_DATA, &Data);
-	
-	return(Data);
-}	/* SkI2cRead */
-#endif /* SK_DIAG */
-
-
-/*
- * read a sensor's value
- *
- * This function reads a sensor's value from the I2C sensor chip. The sensor
- * is defined by its index into the sensors database in the struct pAC points
- * to.
- * Returns
- *		1 if the read is completed
- *		0 if the read must be continued (I2C Bus still allocated)
- */
-int	SkI2cReadSensor(
-SK_AC		*pAC,	/* Adapter Context */
-SK_IOC		IoC,	/* I/O Context */
-SK_SENSOR	*pSen)	/* Sensor to be read */
-{
-    if (pSen->SenRead != NULL) {
-        return((*pSen->SenRead)(pAC, IoC, pSen));
-    }
-	else {
-        return(0); /* no success */
-	}
-}	/* SkI2cReadSensor */
-
-/*
- * Do the Init state 0 initialization
- */
-static int SkI2cInit0(
-SK_AC	*pAC)	/* Adapter Context */
-{
-	int	i;
-
-	/* Begin with first sensor */
-	pAC->I2c.CurrSens = 0;
-	
-	/* Begin with timeout control for state machine */
-	pAC->I2c.TimerMode = SK_TIMER_WATCH_SM;
-	
-	/* Set sensor number to zero */
-	pAC->I2c.MaxSens = 0;
-
-#ifndef SK_DIAG
-	/* Initialize Number of Dummy Reads */
-	pAC->I2c.DummyReads = SK_MAX_SENSORS;
-#endif
-
-	for (i = 0; i < SK_MAX_SENSORS; i++) {
-		pAC->I2c.SenTable[i].SenDesc = "unknown";
-		pAC->I2c.SenTable[i].SenType = SK_SEN_UNKNOWN;
-		pAC->I2c.SenTable[i].SenThreErrHigh = 0;
-		pAC->I2c.SenTable[i].SenThreErrLow = 0;
-		pAC->I2c.SenTable[i].SenThreWarnHigh = 0;
-		pAC->I2c.SenTable[i].SenThreWarnLow = 0;
-		pAC->I2c.SenTable[i].SenReg = LM80_FAN2_IN;
-		pAC->I2c.SenTable[i].SenInit = SK_SEN_DYN_INIT_NONE;
-		pAC->I2c.SenTable[i].SenValue = 0;
-		pAC->I2c.SenTable[i].SenErrFlag = SK_SEN_ERR_NOT_PRESENT;
-		pAC->I2c.SenTable[i].SenErrCts = 0;
-		pAC->I2c.SenTable[i].SenBegErrTS = 0;
-		pAC->I2c.SenTable[i].SenState = SK_SEN_IDLE;
-		pAC->I2c.SenTable[i].SenRead = NULL;
-		pAC->I2c.SenTable[i].SenDev = 0;
-	}
-
-	/* Now we are "INIT data"ed */
-	pAC->I2c.InitLevel = SK_INIT_DATA;
-	return(0);
-}	/* SkI2cInit0*/
-
-
-/*
- * Do the init state 1 initialization
- *
- * initialize the following register of the LM80:
- * Configuration register:
- * - START, noINT, activeLOW, noINT#Clear, noRESET, noCI, noGPO#, noINIT
- *
- * Interrupt Mask Register 1:
- * - all interrupts are Disabled (0xff)
- *
- * Interrupt Mask Register 2:
- * - all interrupts are Disabled (0xff) Interrupt modi doesn't matter.
- *
- * Fan Divisor/RST_OUT register:
- * - Divisors set to 1 (bits 00), all others 0s.
- *
- * OS# Configuration/Temperature resolution Register:
- * - all 0s
- *
- */
-static int SkI2cInit1(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC)	/* I/O Context */
-{
-    int i;
-    SK_U8 I2cSwCtrl;
-	SK_GEPORT *pPrt;	/* GIni Port struct pointer */
-
-	if (pAC->I2c.InitLevel != SK_INIT_DATA) {
-		/* ReInit not needed in I2C module */
-		return(0);
-	}
-
-    /* Set the Direction of I2C-Data Pin to IN */
-    SK_I2C_CLR_BIT(IoC, I2C_DATA_DIR | I2C_DATA);
-    /* Check for 32-Bit Yukon with Low at I2C-Data Pin */
-	SK_I2C_GET_SW(IoC, &I2cSwCtrl);
-
-	if ((I2cSwCtrl & I2C_DATA) == 0) {
-		/* this is a 32-Bit board */
-		pAC->GIni.GIYukon32Bit = SK_TRUE;
-        return(0);
-    }
-
-	/* Check for 64 Bit Yukon without sensors */
-	if (SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_CFG, 0) != 0) {
-        return(0);
-    }
-
-	(void)SkI2cWrite(pAC, IoC, 0xffUL, LM80_ADDR, I2C_025K_DEV, LM80_IMSK_1, 0);
-	
-	(void)SkI2cWrite(pAC, IoC, 0xffUL, LM80_ADDR, I2C_025K_DEV, LM80_IMSK_2, 0);
-	
-	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_FAN_CTRL, 0);
-	
-	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_TEMP_CTRL, 0);
-	
-	(void)SkI2cWrite(pAC, IoC, (SK_U32)LM80_CFG_START, LM80_ADDR, I2C_025K_DEV,
-		LM80_CFG, 0);
-	
-	/*
-	 * MaxSens has to be updated here, because PhyType is not
-	 * set when performing Init Level 0
-	 */
-    pAC->I2c.MaxSens = 5;
-	
-	pPrt = &pAC->GIni.GP[0];
-	
-	if (pAC->GIni.GIGenesis) {
-		if (pPrt->PhyType == SK_PHY_BCOM) {
-			if (pAC->GIni.GIMacsFound == 1) {
-				pAC->I2c.MaxSens += 1;
-			}
-			else {
-				pAC->I2c.MaxSens += 3;
-			}
-		}
-	}
-	else {
-		pAC->I2c.MaxSens += 3;
-	}
-	
-	for (i = 0; i < pAC->I2c.MaxSens; i++) {
-		switch (i) {
-		case 0:
-			pAC->I2c.SenTable[i].SenDesc = "Temperature";
-			pAC->I2c.SenTable[i].SenType = SK_SEN_TEMP;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_TEMP_HIGH_ERR;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_TEMP_HIGH_WARN;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_TEMP_LOW_WARN;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_TEMP_LOW_ERR;
-			pAC->I2c.SenTable[i].SenReg = LM80_TEMP_IN;
-			break;
-		case 1:
-			pAC->I2c.SenTable[i].SenDesc = "Voltage PCI";
-			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PCI_5V_HIGH_ERR;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PCI_5V_HIGH_WARN;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PCI_5V_LOW_WARN;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PCI_5V_LOW_ERR;
-			pAC->I2c.SenTable[i].SenReg = LM80_VT0_IN;
-			break;
-		case 2:
-			pAC->I2c.SenTable[i].SenDesc = "Voltage PCI-IO";
-			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PCI_IO_5V_HIGH_ERR;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PCI_IO_5V_HIGH_WARN;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PCI_IO_3V3_LOW_WARN;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PCI_IO_3V3_LOW_ERR;
-			pAC->I2c.SenTable[i].SenReg = LM80_VT1_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_SEN_DYN_INIT_PCI_IO;
-			break;
-		case 3:
-			pAC->I2c.SenTable[i].SenDesc = "Voltage ASIC";
-			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_VDD_HIGH_ERR;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_VDD_HIGH_WARN;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VDD_LOW_WARN;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VDD_LOW_ERR;
-			pAC->I2c.SenTable[i].SenReg = LM80_VT2_IN;
-			break;
-		case 4:
-			if (pAC->GIni.GIGenesis) {
-				if (pPrt->PhyType == SK_PHY_BCOM) {
-					pAC->I2c.SenTable[i].SenDesc = "Voltage PHY A PLL";
-					pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
-					pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
-					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
-					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
-				}
-				else {
-					pAC->I2c.SenTable[i].SenDesc = "Voltage PMA";
-					pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
-					pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
-					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
-					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
-				}
-			}
-			else {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage VAUX";
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_VAUX_3V3_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_VAUX_3V3_HIGH_WARN;
-				if (pAC->GIni.GIVauxAvail) {
-					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VAUX_3V3_LOW_WARN;
-					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VAUX_3V3_LOW_ERR;
-				}
-				else {
-					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VAUX_0V_WARN_ERR;
-					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VAUX_0V_WARN_ERR;
-				}
-			}
-			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenReg = LM80_VT3_IN;
-			break;
-		case 5:
-			if (pAC->GIni.GIGenesis) {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
-				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
-				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
-			}
-			else {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage Core 1V5";
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_CORE_1V5_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_CORE_1V5_HIGH_WARN;
-				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_CORE_1V5_LOW_WARN;
-				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_CORE_1V5_LOW_ERR;
-			}
-			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenReg = LM80_VT4_IN;
-			break;
-		case 6:
-			if (pAC->GIni.GIGenesis) {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY B PLL";
-			}
-			else {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 3V3";
-			}
-			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
-			pAC->I2c.SenTable[i].SenReg = LM80_VT5_IN;
-			break;
-		case 7:
-			if (pAC->GIni.GIGenesis) {
-				pAC->I2c.SenTable[i].SenDesc = "Speed Fan";
-				pAC->I2c.SenTable[i].SenType = SK_SEN_FAN;
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_FAN_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_FAN_HIGH_WARN;
-				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_FAN_LOW_WARN;
-				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_FAN_LOW_ERR;
-				pAC->I2c.SenTable[i].SenReg = LM80_FAN2_IN;
-			}
-			else {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
-				pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
-				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
-				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
-				pAC->I2c.SenTable[i].SenReg = LM80_VT6_IN;
-			}
-			break;
-		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_INIT | SK_ERRCL_SW,
-				SKERR_I2C_E001, SKERR_I2C_E001MSG);
-			break;
-		}
-
-		pAC->I2c.SenTable[i].SenValue = 0;
-		pAC->I2c.SenTable[i].SenErrFlag = SK_SEN_ERR_OK;
-		pAC->I2c.SenTable[i].SenErrCts = 0;
-		pAC->I2c.SenTable[i].SenBegErrTS = 0;
-		pAC->I2c.SenTable[i].SenState = SK_SEN_IDLE;
-		pAC->I2c.SenTable[i].SenRead = SkLm80ReadSensor;
-		pAC->I2c.SenTable[i].SenDev = LM80_ADDR;
-	}
-
-#ifndef SK_DIAG
-	pAC->I2c.DummyReads = pAC->I2c.MaxSens;
-#endif /* !SK_DIAG */
-	
-	/* Clear I2C IRQ */
-	SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
-	
-	/* Now we are I/O initialized */
-	pAC->I2c.InitLevel = SK_INIT_IO;
-	return(0);
-}	/* SkI2cInit1 */
-
-
-/*
- * Init level 2: Start first sensor read.
- */
-static int SkI2cInit2(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC)	/* I/O Context */
-{
-	int		ReadComplete;
-	SK_SENSOR	*pSen;
-
-	if (pAC->I2c.InitLevel != SK_INIT_IO) {
-		/* ReInit not needed in I2C module */
-		/* Init0 and Init2 not permitted */
-		return(0);
-	}
-
-	pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
-	ReadComplete = SkI2cReadSensor(pAC, IoC, pSen);
-
-	if (ReadComplete) {
-		SK_ERR_LOG(pAC, SK_ERRCL_INIT, SKERR_I2C_E008, SKERR_I2C_E008MSG);
-	}
-
-	/* Now we are correctly initialized */
-	pAC->I2c.InitLevel = SK_INIT_RUN;
-
-	return(0);
-}	/* SkI2cInit2*/
-
-
-/*
- * Initialize I2C devices
- *
- * Get the first voltage value and discard it.
- * Go into temperature read mode. A default pointer is not set.
- *
- * The things to be done depend on the init level in the parameter list:
- * Level 0:
- *	Initialize only the data structures. Do NOT access hardware.
- * Level 1:
- *	Initialize hardware through SK_IN / SK_OUT commands. Do NOT use interrupts.
- * Level 2:
- *	Everything is possible. Interrupts may be used from now on.
- *
- * return:
- *	0 = success
- *	other = error.
- */
-int	SkI2cInit(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC,	/* I/O Context needed in levels 1 and 2 */
-int		Level)	/* Init Level */
-{
-
-	switch (Level) {
-	case SK_INIT_DATA:
-		return(SkI2cInit0(pAC));
-	case SK_INIT_IO:
-		return(SkI2cInit1(pAC, IoC));
-	case SK_INIT_RUN:
-		return(SkI2cInit2(pAC, IoC));
-	default:
-		break;
-	}
-
-	return(0);
-}	/* SkI2cInit */
-
-
-#ifndef SK_DIAG
-
-/*
- * Interrupt service function for the I2C Interface
- *
- * Clears the Interrupt source
- *
- * Reads the register and check it for sending a trap.
- *
- * Starts the timer if necessary.
- */
-void SkI2cIsr(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC)	/* I/O Context */
-{
-	SK_EVPARA	Para;
-
-	/* Clear I2C IRQ */
-	SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
-
-	Para.Para64 = 0;
-	SkEventQueue(pAC, SKGE_I2C, SK_I2CEV_IRQ, Para);
-}	/* SkI2cIsr */
-
-
-/*
- * Check this sensors Value against the threshold and send events.
- */
-static void SkI2cCheckSensor(
-SK_AC		*pAC,	/* Adapter Context */
-SK_SENSOR	*pSen)
-{
-	SK_EVPARA	ParaLocal;
-	SK_BOOL		TooHigh;	/* Is sensor too high? */
-	SK_BOOL		TooLow;		/* Is sensor too low? */
-	SK_U64		CurrTime;	/* Current Time */
-	SK_BOOL		DoTrapSend;	/* We need to send a trap */
-	SK_BOOL		DoErrLog;	/* We need to log the error */
-	SK_BOOL		IsError;	/* We need to log the error */
-
-	/* Check Dummy Reads first */
-	if (pAC->I2c.DummyReads > 0) {
-		pAC->I2c.DummyReads--;
-		return;
-	}
-
-	/* Get the current time */
-	CurrTime = SkOsGetTime(pAC);
-
-	/* Set para to the most useful setting: The current sensor. */
-	ParaLocal.Para64 = (SK_U64)pAC->I2c.CurrSens;
-
-	/* Check the Value against the thresholds. First: Error Thresholds */
-	TooHigh = (pSen->SenValue > pSen->SenThreErrHigh);
-	TooLow = (pSen->SenValue < pSen->SenThreErrLow);
-		
-	IsError = SK_FALSE;
-	if (TooHigh || TooLow) {
-		/* Error condition is satisfied */
-		DoTrapSend = SK_TRUE;
-		DoErrLog = SK_TRUE;
-
-		/* Now error condition is satisfied */
-		IsError = SK_TRUE;
-
-		if (pSen->SenErrFlag == SK_SEN_ERR_ERR) {
-			/* This state is the former one */
-
-			/* So check first whether we have to send a trap */
-			if (pSen->SenLastErrTrapTS + SK_SEN_ERR_TR_HOLD >
-			    CurrTime) {
-				/*
-				 * Do NOT send the Trap. The hold back time
-				 * has to run out first.
-				 */
-				DoTrapSend = SK_FALSE;
-			}
-
-			/* Check now whether we have to log an Error */
-			if (pSen->SenLastErrLogTS + SK_SEN_ERR_LOG_HOLD >
-			    CurrTime) {
-				/*
-				 * Do NOT log the error. The hold back time
-				 * has to run out first.
-				 */
-				DoErrLog = SK_FALSE;
-			}
-		}
-		else {
-			/* We came from a different state -> Set Begin Time Stamp */
-			pSen->SenBegErrTS = CurrTime;
-			pSen->SenErrFlag = SK_SEN_ERR_ERR;
-		}
-
-		if (DoTrapSend) {
-			/* Set current Time */
-			pSen->SenLastErrTrapTS = CurrTime;
-			pSen->SenErrCts++;
-
-			/* Queue PNMI Event */
-			SkEventQueue(pAC, SKGE_PNMI, (TooHigh ?
-				SK_PNMI_EVT_SEN_ERR_UPP :
-				SK_PNMI_EVT_SEN_ERR_LOW),
-				ParaLocal);
-		}
-
-		if (DoErrLog) {
-			/* Set current Time */
-			pSen->SenLastErrLogTS = CurrTime;
-
-			if (pSen->SenType == SK_SEN_TEMP) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E011, SKERR_I2C_E011MSG);
-			}
-			else if (pSen->SenType == SK_SEN_VOLT) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E012, SKERR_I2C_E012MSG);
-			}
-			else {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E015, SKERR_I2C_E015MSG);
-			}
-		}
-	}
-
-	/* Check the Value against the thresholds */
-	/* 2nd: Warning thresholds */
-	TooHigh = (pSen->SenValue > pSen->SenThreWarnHigh);
-	TooLow = (pSen->SenValue < pSen->SenThreWarnLow);
-		
-	if (!IsError && (TooHigh || TooLow)) {
-		/* Error condition is satisfied */
-		DoTrapSend = SK_TRUE;
-		DoErrLog = SK_TRUE;
-
-		if (pSen->SenErrFlag == SK_SEN_ERR_WARN) {
-			/* This state is the former one */
-
-			/* So check first whether we have to send a trap */
-			if (pSen->SenLastWarnTrapTS + SK_SEN_WARN_TR_HOLD > CurrTime) {
-				/*
-				 * Do NOT send the Trap. The hold back time
-				 * has to run out first.
-				 */
-				DoTrapSend = SK_FALSE;
-			}
-
-			/* Check now whether we have to log an Error */
-			if (pSen->SenLastWarnLogTS + SK_SEN_WARN_LOG_HOLD > CurrTime) {
-				/*
-				 * Do NOT log the error. The hold back time
-				 * has to run out first.
-				 */
-				DoErrLog = SK_FALSE;
-			}
-		}
-		else {
-			/* We came from a different state -> Set Begin Time Stamp */
-			pSen->SenBegWarnTS = CurrTime;
-			pSen->SenErrFlag = SK_SEN_ERR_WARN;
-		}
-
-		if (DoTrapSend) {
-			/* Set current Time */
-			pSen->SenLastWarnTrapTS = CurrTime;
-			pSen->SenWarnCts++;
-
-			/* Queue PNMI Event */
-			SkEventQueue(pAC, SKGE_PNMI, (TooHigh ?
-				SK_PNMI_EVT_SEN_WAR_UPP :
-				SK_PNMI_EVT_SEN_WAR_LOW),
-				ParaLocal);
-		}
-
-		if (DoErrLog) {
-			/* Set current Time */
-			pSen->SenLastWarnLogTS = CurrTime;
-
-			if (pSen->SenType == SK_SEN_TEMP) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E009, SKERR_I2C_E009MSG);
-			}
-			else if (pSen->SenType == SK_SEN_VOLT) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E010, SKERR_I2C_E010MSG);
-			}
-			else {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E014, SKERR_I2C_E014MSG);
-			}
-		}
-	}
-
-	/* Check for NO error at all */
-	if (!IsError && !TooHigh && !TooLow) {
-		/* Set o.k. Status if no error and no warning condition */
-		pSen->SenErrFlag = SK_SEN_ERR_OK;
-	}
-
-	/* End of check against the thresholds */
-
-	/* Bug fix AF: 16.Aug.2001: Correct the init base
-	 * of LM80 sensor.
-	 */
-	if (pSen->SenInit == SK_SEN_DYN_INIT_PCI_IO) {
-
-        pSen->SenInit = SK_SEN_DYN_INIT_NONE;
-
-		if (pSen->SenValue > SK_SEN_PCI_IO_RANGE_LIMITER) {
-			/* 5V PCI-IO Voltage */
-			pSen->SenThreWarnLow = SK_SEN_PCI_IO_5V_LOW_WARN;
-			pSen->SenThreErrLow = SK_SEN_PCI_IO_5V_LOW_ERR;
-		}
-		else {
-			/* 3.3V PCI-IO Voltage */
-			pSen->SenThreWarnHigh = SK_SEN_PCI_IO_3V3_HIGH_WARN;
-			pSen->SenThreErrHigh = SK_SEN_PCI_IO_3V3_HIGH_ERR;
-		}
-	}
-	
-#ifdef TEST_ONLY
-    /* Dynamic thresholds also for VAUX of LM80 sensor */
-	if (pSen->SenInit == SK_SEN_DYN_INIT_VAUX) {
-
-        pSen->SenInit = SK_SEN_DYN_INIT_NONE;
-
-		/* 3.3V VAUX Voltage */
-		if (pSen->SenValue > SK_SEN_VAUX_RANGE_LIMITER) {
-			pSen->SenThreWarnLow = SK_SEN_VAUX_3V3_LOW_WARN;
-			pSen->SenThreErrLow = SK_SEN_VAUX_3V3_LOW_ERR;
-		}
-		/* 0V VAUX Voltage */
-		else {
-			pSen->SenThreWarnHigh = SK_SEN_VAUX_0V_WARN_ERR;
-			pSen->SenThreErrHigh = SK_SEN_VAUX_0V_WARN_ERR;
-		}
-	}
-
-	/*
-	 * Check initialization state:
-	 * The VIO Thresholds need adaption
-	 */
-	if (!pSen->SenInit && pSen->SenReg == LM80_VT1_IN &&
-	     pSen->SenValue > SK_SEN_WARNLOW2C &&
-	     pSen->SenValue < SK_SEN_WARNHIGH2) {
-		pSen->SenThreErrLow = SK_SEN_ERRLOW2C;
-		pSen->SenThreWarnLow = SK_SEN_WARNLOW2C;
-		pSen->SenInit = SK_TRUE;
-	}
-
-	if (!pSen->SenInit && pSen->SenReg == LM80_VT1_IN &&
-	     pSen->SenValue > SK_SEN_WARNLOW2 &&
-	     pSen->SenValue < SK_SEN_WARNHIGH2C) {
-		pSen->SenThreErrHigh = SK_SEN_ERRHIGH2C;
-		pSen->SenThreWarnHigh = SK_SEN_WARNHIGH2C;
-		pSen->SenInit = SK_TRUE;
-	}
-#endif
-
-	if (pSen->SenInit != SK_SEN_DYN_INIT_NONE) {
-		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E013, SKERR_I2C_E013MSG);
-	}
-}	/* SkI2cCheckSensor */
-
-
-/*
- * The only Event to be served is the timeout event
- *
- */
-int	SkI2cEvent(
-SK_AC		*pAC,	/* Adapter Context */
-SK_IOC		IoC,	/* I/O Context */
-SK_U32		Event,	/* Module specific Event */
-SK_EVPARA	Para)	/* Event specific Parameter */
-{
-	int			ReadComplete;
-	SK_SENSOR	*pSen;
-	SK_U32		Time;
-	SK_EVPARA	ParaLocal;
-	int			i;
-
-	/* New case: no sensors */
-	if (pAC->I2c.MaxSens == 0) {
-		return(0);
-	}
-
-	switch (Event) {
-	case SK_I2CEV_IRQ:
-		pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
-		ReadComplete = SkI2cReadSensor(pAC, IoC, pSen);
-
-		if (ReadComplete) {
-			/* Check sensor against defined thresholds */
-			SkI2cCheckSensor(pAC, pSen);
-
-			/* Increment Current sensor and set appropriate Timeout */
-			pAC->I2c.CurrSens++;
-			if (pAC->I2c.CurrSens >= pAC->I2c.MaxSens) {
-				pAC->I2c.CurrSens = 0;
-				Time = SK_I2C_TIM_LONG;
-			}
-			else {
-				Time = SK_I2C_TIM_SHORT;
-			}
-
-			/* Start Timer */
-			ParaLocal.Para64 = (SK_U64)0;
-
-			pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
-			
-			SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
-				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
-		}
-        else {
-			/* Start Timer */
-			ParaLocal.Para64 = (SK_U64)0;
-
-			pAC->I2c.TimerMode = SK_TIMER_WATCH_SM;
-
-            SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, SK_I2C_TIM_WATCH,
-				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
-		}
-		break;
-	case SK_I2CEV_TIM:
-		if (pAC->I2c.TimerMode == SK_TIMER_NEW_GAUGING) {
-
-			ParaLocal.Para64 = (SK_U64)0;
-			SkTimerStop(pAC, IoC, &pAC->I2c.SenTimer);
-
-			pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
-			ReadComplete = SkI2cReadSensor(pAC, IoC, pSen);
-
-			if (ReadComplete) {
-				/* Check sensor against defined thresholds */
-				SkI2cCheckSensor(pAC, pSen);
-
-				/* Increment Current sensor and set appropriate Timeout */
-				pAC->I2c.CurrSens++;
-				if (pAC->I2c.CurrSens == pAC->I2c.MaxSens) {
-					pAC->I2c.CurrSens = 0;
-					Time = SK_I2C_TIM_LONG;
-				}
-				else {
-					Time = SK_I2C_TIM_SHORT;
-				}
-
-				/* Start Timer */
-				ParaLocal.Para64 = (SK_U64)0;
-
-				pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
-
-				SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
-					SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
-			}
-		}
-		else {
-			pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
-			pSen->SenErrFlag = SK_SEN_ERR_FAULTY;
-			SK_I2C_STOP(IoC);
-
-			/* Increment Current sensor and set appropriate Timeout */
-			pAC->I2c.CurrSens++;
-			if (pAC->I2c.CurrSens == pAC->I2c.MaxSens) {
-				pAC->I2c.CurrSens = 0;
-				Time = SK_I2C_TIM_LONG;
-			}
-			else {
-				Time = SK_I2C_TIM_SHORT;
-			}
-
-			/* Start Timer */
-			ParaLocal.Para64 = (SK_U64)0;
-
-			pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
-
-			SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
-				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
-		}
-		break;
-	case SK_I2CEV_CLEAR:
-		for (i = 0; i < SK_MAX_SENSORS; i++) {
-			pAC->I2c.SenTable[i].SenErrFlag = SK_SEN_ERR_OK;
-			pAC->I2c.SenTable[i].SenErrCts = 0;
-			pAC->I2c.SenTable[i].SenWarnCts = 0;
-			pAC->I2c.SenTable[i].SenBegErrTS = 0;
-			pAC->I2c.SenTable[i].SenBegWarnTS = 0;
-			pAC->I2c.SenTable[i].SenLastErrTrapTS = (SK_U64)0;
-			pAC->I2c.SenTable[i].SenLastErrLogTS = (SK_U64)0;
-			pAC->I2c.SenTable[i].SenLastWarnTrapTS = (SK_U64)0;
-			pAC->I2c.SenTable[i].SenLastWarnLogTS = (SK_U64)0;
-		}
-		break;
-	default:
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E006, SKERR_I2C_E006MSG);
-	}
-
-	return(0);
-}	/* SkI2cEvent*/
-
-#endif /* !SK_DIAG */
Index: linux-2.6.8/drivers/net/sk98lin/sklm80.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/sklm80.c
+++ linux-2.6.8/drivers/net/sk98lin/sklm80.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	sklm80.c
  * Project:	Gigabit Ethernet Adapters, TWSI-Module
- * Version:	$Revision: 1.22 $
- * Date:	$Date: 2003/10/20 09:08:21 $
+ * Version:	$Revision: 1.1 $
+ * Date:	$Date: 2003/12/19 14:02:31 $
  * Purpose:	Functions to access Voltage and Temperature Sensor (LM80)
  *
  ******************************************************************************/
 
@@ -26,9 +26,9 @@
 	LM80 functions
 */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: sklm80.c,v 1.22 2003/10/20 09:08:21 rschmidt Exp $ (C) Marvell. ";
+	"@(#) $Id: sklm80.c,v 1.1 2003/12/19 14:02:31 mschmid Exp $ (C) Marvell. ";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/lm80.h"
@@ -110,14 +110,14 @@ int		Reg)		/* register to read */
 
 /*
  * read a sensors value (LM80 specific)
  *
- * This function reads a sensors value from the I2C sensor chip LM80.
+ * This function reads a sensors value from the TWSI sensor chip LM80.
  * The sensor is defined by its index into the sensors database in the struct
  * pAC points to.
  *
  * Returns	1 if the read is completed
- *		0 if the read must be continued (I2C Bus still allocated)
+ *		0 if the read must be continued (TWSI Bus still allocated)
  */
 int SkLm80ReadSensor(
 SK_AC		*pAC,	/* Adapter Context */
 SK_IOC		IoC,	/* I/O Context needed in level 1 and 2 */
Index: linux-2.6.8/drivers/net/sk98lin/skproc.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skproc.c
+++ linux-2.6.8/drivers/net/sk98lin/skproc.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skproc.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.11 $
- * Date:	$Date: 2003/12/11 16:03:57 $
+ * Version:	$Revision: 1.9 $
+ * Date:	$Date: 2004/06/23 12:04:55 $
  * Purpose:	Funktions to display statictic data
  *
  ******************************************************************************/
  
@@ -30,8 +30,13 @@
 #include "h/skdrv1st.h"
 #include "h/skdrv2nd.h"
 #include "h/skversion.h"
 
+/*
+ * Enable for advanced statistic counter
+ */
+/*#define ADVANCED_STATISTIC_OUTPUT = 1; */
+
 extern struct SK_NET_DEVICE *SkGeRootDev;
 static int sk_proc_print(void *writePtr, char *format, ...);
 static void sk_gen_browse(void *buffer);
 int len;
@@ -61,15 +66,17 @@ struct net_device *currDev = NULL;
 static void sk_gen_browse(void *buffer)
 {
 	struct SK_NET_DEVICE	*SkgeProcDev = SkGeRootDev;
 	struct SK_NET_DEVICE	*next;
+	SK_BOOL			DisableStatistic = 0;
 	SK_PNMI_STRUCT_DATA 	*pPnmiStruct;
 	SK_PNMI_STAT		*pPnmiStat;
 	unsigned long		Flags;	
 	unsigned int		Size;
 	DEV_NET			*pNet;
 	SK_AC			*pAC;
 	char			sens_msg[50];
+	int 			card_type;
 	int			MaxSecurityCount = 0;
 	int 			t;
 	int 			i;
 
@@ -90,24 +97,24 @@ static void sk_gen_browse(void *buffer)
 				t--;
 
 			spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 			Size = SK_PNMI_STRUCT_SIZE;
-#ifdef SK_DIAG_SUPPORT
+			DisableStatistic = 0;
 			if (pAC->BoardLevel == SK_INIT_DATA) {
 				SK_MEMCPY(&(pAC->PnmiStruct), &(pAC->PnmiBackup), sizeof(SK_PNMI_STRUCT_DATA));
 				if (pAC->DiagModeActive == DIAG_NOTACTIVE) {
 					pAC->Pnmi.DiagAttached = SK_DIAG_IDLE;
 				}
 			} else {
 				SkPnmiGetStruct(pAC, pAC->IoBase, pPnmiStruct, &Size, t-1);
 			}
-#else
-			SkPnmiGetStruct(pAC, pAC->IoBase, 
-				pPnmiStruct, &Size, t-1);
-#endif
 			spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
-	
 			if (strcmp(pAC->dev[t-1]->name, currDev->name) == 0) {
+				if (!pAC->GIni.GIYukon32Bit)
+					card_type = 64;
+				else
+					card_type = 32;
+
 				pPnmiStat = &pPnmiStruct->Stat[0];
 				len = sk_proc_print(buffer, 
 					"\nDetailed statistic for device %s\n",
 					pAC->dev[t-1]->name);
@@ -117,187 +124,236 @@ static void sk_gen_browse(void *buffer)
 				/* Board statistics */
 				len += sk_proc_print(buffer, 
 					"\nBoard statistics\n\n");
 				len += sk_proc_print(buffer,
+					"Card name                      %s\n",
+					pAC->DeviceStr);
+				len += sk_proc_print(buffer,
+					"Vendor/Device ID               %x/%x\n",
+					pAC->PciDev->vendor,
+					pAC->PciDev->device);
+				len += sk_proc_print(buffer,
+					"Card type (Bit)                %d\n",
+					card_type);
+					
+				len += sk_proc_print(buffer,
 					"Active Port                    %c\n",
 					'A' + pAC->Rlmt.Net[t-1].Port[pAC->Rlmt.
 					Net[t-1].PrefPort]->PortNumber);
 				len += sk_proc_print(buffer,
 					"Preferred Port                 %c\n",
 					'A' + pAC->Rlmt.Net[t-1].Port[pAC->Rlmt.
 					Net[t-1].PrefPort]->PortNumber);
 
-				len += sk_proc_print(buffer,
-					"Bus speed (MHz)                %d\n",
-					pPnmiStruct->BusSpeed);
-
-				len += sk_proc_print(buffer,
-					"Bus width (Bit)                %d\n",
-					pPnmiStruct->BusWidth);
+				if (pAC->DynIrqModInfo.IntModTypeSelect == C_INT_MOD_STATIC)
+					len += sk_proc_print(buffer,
+					"Interrupt Moderation           static (%d ints/sec)\n",
+					pAC->DynIrqModInfo.MaxModIntsPerSec);
+				else if (pAC->DynIrqModInfo.IntModTypeSelect == C_INT_MOD_DYNAMIC)
+					len += sk_proc_print(buffer,
+					"Interrupt Moderation           dynamic (%d ints/sec)\n",
+					pAC->DynIrqModInfo.MaxModIntsPerSec);
+				else
+					len += sk_proc_print(buffer,
+					"Interrupt Moderation           disabled\n");
+
+				if (CHIP_ID_YUKON_2(pAC)) {
+					len += sk_proc_print(buffer,
+						"Bus type                       PCI Express\n",
+						pPnmiStruct->BusSpeed);
+				} else {
+					len += sk_proc_print(buffer,
+						"Bus speed (MHz)                %d\n",
+						pPnmiStruct->BusSpeed);
+					len += sk_proc_print(buffer,
+						"Bus width (Bit)                %d\n",
+						pPnmiStruct->BusWidth);
+				}
 				len += sk_proc_print(buffer,
 					"Driver version                 %s\n",
 					VER_STRING);
 				len += sk_proc_print(buffer,
+					"Driver release date            %s\n",
+					pAC->Pnmi.pDriverReleaseDate);
+				len += sk_proc_print(buffer,
 					"Hardware revision              v%d.%d\n",
 					(pAC->GIni.GIPciHwRev >> 4) & 0x0F,
 					pAC->GIni.GIPciHwRev & 0x0F);
 
-				/* Print sensor informations */
-				for (i=0; i < pAC->I2c.MaxSens; i ++) {
-					/* Check type */
-					switch (pAC->I2c.SenTable[i].SenType) {
-					case 1:
-						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
-						strcat(sens_msg, " (C)");
-						len += sk_proc_print(buffer,
-							"%-25s      %d.%02d\n",
-							sens_msg,
-							pAC->I2c.SenTable[i].SenValue / 10,
-							pAC->I2c.SenTable[i].SenValue % 10);
-
-						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
-						strcat(sens_msg, " (F)");
-						len += sk_proc_print(buffer,
-							"%-25s      %d.%02d\n",
-							sens_msg,
-							((((pAC->I2c.SenTable[i].SenValue)
-							*10)*9)/5 + 3200)/100,
-							((((pAC->I2c.SenTable[i].SenValue)
-							*10)*9)/5 + 3200) % 10);
-						break;
-					case 2:
-						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
-						strcat(sens_msg, " (V)");
-						len += sk_proc_print(buffer,
-							"%-25s      %d.%03d\n",
-							sens_msg,
-							pAC->I2c.SenTable[i].SenValue / 1000,
-							pAC->I2c.SenTable[i].SenValue % 1000);
-						break;
-					case 3:
-						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
-						strcat(sens_msg, " (rpm)");
-						len += sk_proc_print(buffer,
-							"%-25s      %d\n",
-							sens_msg,
-							pAC->I2c.SenTable[i].SenValue);
-						break;
-					default:
-						break;
-					}
+				if (pAC->BoardLevel < 2) {
+					len += sk_proc_print(buffer,
+						"\n      Device %s is down.\n"
+						"      Therefore no statistics are available.\n"
+						"      After bringing the device up (ifconfig)"
+						" statistics will\n"
+						"      be displayed.\n",
+						pAC->dev[t-1]->name);
+					DisableStatistic = 1;
 				}
-				
-				/*Receive statistics */
-				len += sk_proc_print(buffer, 
-				"\nReceive statistics\n\n");
 
-				len += sk_proc_print(buffer,
-					"Received bytes                 %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxOctetsOkCts);
-				len += sk_proc_print(buffer,
-					"Received packets               %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxOkCts);
+				/* Display only if statistic info available */
+				/* Print sensor informations */
+				if (!DisableStatistic) {
+					for (i=0; i < pAC->I2c.MaxSens; i ++) {
+						/* Check type */
+						switch (pAC->I2c.SenTable[i].SenType) {
+						case 1:
+							strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+							strcat(sens_msg, " (C)");
+							len += sk_proc_print(buffer,
+								"%-25s      %d.%02d\n",
+								sens_msg,
+								pAC->I2c.SenTable[i].SenValue / 10,
+								pAC->I2c.SenTable[i].SenValue %
+								10);
+
+							strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+							strcat(sens_msg, " (F)");
+							len += sk_proc_print(buffer,
+								"%-25s      %d.%02d\n",
+								sens_msg,
+								((((pAC->I2c.SenTable[i].SenValue)
+								*10)*9)/5 + 3200)/100,
+								((((pAC->I2c.SenTable[i].SenValue)
+								*10)*9)/5 + 3200) % 10);
+							break;
+						case 2:
+							strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+							strcat(sens_msg, " (V)");
+							len += sk_proc_print(buffer,
+								"%-25s      %d.%03d\n",
+								sens_msg,
+								pAC->I2c.SenTable[i].SenValue / 1000,
+								pAC->I2c.SenTable[i].SenValue % 1000);
+							break;
+						case 3:
+							strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+							strcat(sens_msg, " (rpm)");
+							len += sk_proc_print(buffer,
+								"%-25s      %d\n",
+								sens_msg,
+								pAC->I2c.SenTable[i].SenValue);
+							break;
+						default:
+							break;
+						}
+					}
+			
+					/*Receive statistics */
+					len += sk_proc_print(buffer, 
+					"\nReceive statistics\n\n");
+
+					len += sk_proc_print(buffer,
+						"Received bytes                 %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxOctetsOkCts);
+					len += sk_proc_print(buffer,
+						"Received packets               %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxOkCts);
 #if 0
-				if (pAC->GIni.GP[0].PhyType == SK_PHY_XMAC && 
-					pAC->HWRevision < 12) {
-					pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts - 
-						pPnmiStat->StatRxShortsCts;
-					pPnmiStat->StatRxShortsCts = 0;
-				}
+					if (pAC->GIni.GP[0].PhyType == SK_PHY_XMAC && 
+						pAC->HWRevision < 12) {
+						pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts - 
+							pPnmiStat->StatRxShortsCts;
+						pPnmiStat->StatRxShortsCts = 0;
+					}
+#endif
+					if (pNet->Mtu > 1500) 
+						pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts -
+							pPnmiStat->StatRxTooLongCts;
+
+					len += sk_proc_print(buffer,
+						"Receive errors                 %Lu\n",
+						(unsigned long long) pPnmiStruct->InErrorsCts);
+					len += sk_proc_print(buffer,
+						"Receive dropped                %Lu\n",
+						(unsigned long long) pPnmiStruct->RxNoBufCts);
+					len += sk_proc_print(buffer,
+						"Received multicast             %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxMulticastOkCts);
+#ifdef ADVANCED_STATISTIC_OUTPUT
+					len += sk_proc_print(buffer,
+						"Receive error types\n");
+					len += sk_proc_print(buffer,
+						"   length                      %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxRuntCts);
+					len += sk_proc_print(buffer,
+						"   buffer overflow             %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxFifoOverflowCts);
+					len += sk_proc_print(buffer,
+						"   bad crc                     %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxFcsCts);
+					len += sk_proc_print(buffer,
+						"   framing                     %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxFramingCts);
+					len += sk_proc_print(buffer,
+						"   missed frames               %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxMissedCts);
+
+					if (pNet->Mtu > 1500)
+						pPnmiStat->StatRxTooLongCts = 0;
+
+					len += sk_proc_print(buffer,
+						"   too long                    %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxTooLongCts);					
+					len += sk_proc_print(buffer,
+						"   carrier extension           %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxCextCts);				
+					len += sk_proc_print(buffer,
+						"   too short                   %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxShortsCts);				
+					len += sk_proc_print(buffer,
+						"   symbol                      %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxSymbolCts);				
+					len += sk_proc_print(buffer,
+						"   LLC MAC size                %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxIRLengthCts);				
+					len += sk_proc_print(buffer,
+						"   carrier event               %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxCarrierCts);				
+					len += sk_proc_print(buffer,
+						"   jabber                      %Lu\n",
+						(unsigned long long) pPnmiStat->StatRxJabberCts);				
 #endif
-				if (pNet->Mtu > 1500) 
-					pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts -
-						pPnmiStat->StatRxTooLongCts;
-
-				len += sk_proc_print(buffer,
-					"Receive errors                 %Lu\n",
-					(unsigned long long) pPnmiStruct->InErrorsCts);
-				len += sk_proc_print(buffer,
-					"Receive dropped                %Lu\n",
-					(unsigned long long) pPnmiStruct->RxNoBufCts);
-				len += sk_proc_print(buffer,
-					"Received multicast             %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxMulticastOkCts);
-				len += sk_proc_print(buffer,
-					"Receive error types\n");
-				len += sk_proc_print(buffer,
-					"   length                      %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxRuntCts);
-				len += sk_proc_print(buffer,
-					"   buffer overflow             %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxFifoOverflowCts);
-				len += sk_proc_print(buffer,
-					"   bad crc                     %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxFcsCts);
-				len += sk_proc_print(buffer,
-					"   framing                     %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxFramingCts);
-				len += sk_proc_print(buffer,
-					"   missed frames               %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxMissedCts);
-
-				if (pNet->Mtu > 1500)
-					pPnmiStat->StatRxTooLongCts = 0;
-
-				len += sk_proc_print(buffer,
-					"   too long                    %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxTooLongCts);					
-				len += sk_proc_print(buffer,
-					"   carrier extension           %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxCextCts);				
-				len += sk_proc_print(buffer,
-					"   too short                   %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxShortsCts);				
-				len += sk_proc_print(buffer,
-					"   symbol                      %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxSymbolCts);				
-				len += sk_proc_print(buffer,
-					"   LLC MAC size                %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxIRLengthCts);				
-				len += sk_proc_print(buffer,
-					"   carrier event               %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxCarrierCts);				
-				len += sk_proc_print(buffer,
-					"   jabber                      %Lu\n",
-					(unsigned long long) pPnmiStat->StatRxJabberCts);				
-
 
-				/*Transmit statistics */
-				len += sk_proc_print(buffer, 
-				"\nTransmit statistics\n\n");
+					/*Transmit statistics */
+					len += sk_proc_print(buffer, 
+					"\nTransmit statistics\n\n");
 				
-				len += sk_proc_print(buffer,
-					"Transmited bytes               %Lu\n",
-					(unsigned long long) pPnmiStat->StatTxOctetsOkCts);
-				len += sk_proc_print(buffer,
-					"Transmited packets             %Lu\n",
-					(unsigned long long) pPnmiStat->StatTxOkCts);
-				len += sk_proc_print(buffer,
-					"Transmit errors                %Lu\n",
-					(unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
-				len += sk_proc_print(buffer,
-					"Transmit dropped               %Lu\n",
-					(unsigned long long) pPnmiStruct->TxNoBufCts);
-				len += sk_proc_print(buffer,
-					"Transmit collisions            %Lu\n",
-					(unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
-				len += sk_proc_print(buffer,
-					"Transmit error types\n");
-				len += sk_proc_print(buffer,
-					"   excessive collision         %ld\n",
-					pAC->stats.tx_aborted_errors);
-				len += sk_proc_print(buffer,
-					"   carrier                     %Lu\n",
-					(unsigned long long) pPnmiStat->StatTxCarrierCts);
-				len += sk_proc_print(buffer,
-					"   fifo underrun               %Lu\n",
-					(unsigned long long) pPnmiStat->StatTxFifoUnderrunCts);
-				len += sk_proc_print(buffer,
-					"   heartbeat                   %Lu\n",
-					(unsigned long long) pPnmiStat->StatTxCarrierCts);
-				len += sk_proc_print(buffer,
-					"   window                      %ld\n",
-					pAC->stats.tx_window_errors);
+					len += sk_proc_print(buffer,
+						"Transmited bytes               %Lu\n",
+						(unsigned long long) pPnmiStat->StatTxOctetsOkCts);
+					len += sk_proc_print(buffer,
+						"Transmited packets             %Lu\n",
+						(unsigned long long) pPnmiStat->StatTxOkCts);
+					len += sk_proc_print(buffer,
+						"Transmit errors                %Lu\n",
+						(unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
+					len += sk_proc_print(buffer,
+						"Transmit dropped               %Lu\n",
+						(unsigned long long) pPnmiStruct->TxNoBufCts);
+					len += sk_proc_print(buffer,
+						"Transmit collisions            %Lu\n",
+						(unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
+#ifdef ADVANCED_STATISTIC_OUTPUT
+					len += sk_proc_print(buffer,
+						"Transmit error types\n");
+					len += sk_proc_print(buffer,
+						"   excessive collision         %ld\n",
+						pAC->stats.tx_aborted_errors);
+					len += sk_proc_print(buffer,
+						"   carrier                     %Lu\n",
+						(unsigned long long) pPnmiStat->StatTxCarrierCts);
+					len += sk_proc_print(buffer,
+						"   fifo underrun               %Lu\n",
+						(unsigned long long) pPnmiStat->StatTxFifoUnderrunCts);
+					len += sk_proc_print(buffer,
+						"   heartbeat                   %Lu\n",
+						(unsigned long long) pPnmiStat->StatTxCarrierCts);
+					len += sk_proc_print(buffer,
+						"   window                      %ld\n",
+						pAC->stats.tx_window_errors);
+#endif
+				} /* if (!DisableStatistic) */
 				
 			} /* if (strcmp(pACname, currDeviceName) == 0) */
 		}
 		SkgeProcDev = next;
Index: linux-2.6.8/drivers/net/sk98lin/skqueue.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skqueue.c
+++ linux-2.6.8/drivers/net/sk98lin/skqueue.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skqueue.c
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision: 1.20 $
- * Date:	$Date: 2003/09/16 13:44:00 $
+ * Version:	$Revision: 2.3 $
+ * Date:	$Date: 2004/05/14 13:28:18 $
  * Purpose:	Management of an event queue.
  *
  ******************************************************************************/
 
@@ -27,9 +27,9 @@
  *	Event queue and dispatcher
  */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skqueue.c,v 1.20 2003/09/16 13:44:00 rschmidt Exp $ (C) Marvell.";
+	"@(#) $Id: skqueue.c,v 2.3 2004/05/14 13:28:18 malthoff Exp $ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skqueue.h"		/* Queue Definitions */
@@ -47,12 +47,18 @@ intro()
 #endif
 
 #define PRINTF(a,b,c)
 
-/*
- * init event queue management
+/******************************************************************************
+ *
+ *	SkEventInit() - init event queue management
  *
- * Must be called during init level 0.
+ * Description:
+ * 	This function initializes event queue management.
+ *	It must be called during init level 0.
+ *
+ * Returns:
+ *	nothing
  */
 void	SkEventInit(
 SK_AC	*pAC,	/* Adapter context */
 SK_IOC	Ioc,	/* IO context */
@@ -66,37 +72,65 @@ int		Level)	/* Init level */
 		break;
 	}
 }
 
-/*
- * add event to queue
+/******************************************************************************
+ *
+ *	SkEventQueue()	-	add event to queue
+ *
+ * Description:
+ *	This function adds an event to the event queue.
+ *	At least Init Level 1 is required to queue events,
+ *	but will be scheduled add Init Level 2.
+ *
+ * returns:
+ *	nothing
  */
 void	SkEventQueue(
 SK_AC		*pAC,	/* Adapters context */
 SK_U32		Class,	/* Event Class */
 SK_U32		Event,	/* Event to be queued */
 SK_EVPARA	Para)	/* Event parameter */
 {
-	pAC->Event.EvPut->Class = Class;
-	pAC->Event.EvPut->Event = Event;
-	pAC->Event.EvPut->Para = Para;
+
+	if (pAC->GIni.GILevel == SK_INIT_DATA) {
+		SK_ERR_LOG(pAC, SK_ERRCL_NORES, SKERR_Q_E003, SKERR_Q_E003MSG);
+	}
+	else {
+		pAC->Event.EvPut->Class = Class;
+		pAC->Event.EvPut->Event = Event;
+		pAC->Event.EvPut->Para = Para;
 	
-	if (++pAC->Event.EvPut == &pAC->Event.EvQueue[SK_MAX_EVENT])
-		pAC->Event.EvPut = pAC->Event.EvQueue;
+		if (++pAC->Event.EvPut == &pAC->Event.EvQueue[SK_MAX_EVENT])
+			pAC->Event.EvPut = pAC->Event.EvQueue;
 
-	if (pAC->Event.EvPut == pAC->Event.EvGet) {
-		SK_ERR_LOG(pAC, SK_ERRCL_NORES, SKERR_Q_E001, SKERR_Q_E001MSG);
+		if (pAC->Event.EvPut == pAC->Event.EvGet) {
+			SK_ERR_LOG(pAC, SK_ERRCL_NORES, SKERR_Q_E001, SKERR_Q_E001MSG);
+		}
 	}
 }
 
-/*
- * event dispatcher
- *	while event queue is not empty
- *		get event from queue
- *		send command to state machine
- *	end
- *	return error reported by individual Event function
- *		0 if no error occured.
+/******************************************************************************
+ *
+ *	SkEventDispatcher() -	 Event Dispatcher
+ *
+ * Description:
+ *	The event dispatcher performs the following operations:
+ *		o while event queue is not empty
+ *			- get event from queue
+ *			- send event to state machine
+ *		  end
+ *
+ * CAUTION:
+ *	The event functions MUST report an error if performing a reinitialization
+ *	of the event queue, e.g. performing level Init 0..2 while in dispatcher
+ *	call!
+ *  ANY OTHER return value delays scheduling the other events in the
+ *	queue. In this case the event blocks the queue until
+ *  the error condition is cleared!
+ *
+ * Returns:
+ *	The return value error reported by individual event function
  */
 int	SkEventDispatcher(
 SK_AC	*pAC,	/* Adapters Context */
 SK_IOC	Ioc)	/* Io context */
@@ -104,8 +138,12 @@ SK_IOC	Ioc)	/* Io context */
 	SK_EVENTELEM	*pEv;	/* pointer into queue */
 	SK_U32			Class;
 	int			Rtv;
 
+	if (pAC->GIni.GILevel != SK_INIT_RUN) {
+		SK_ERR_LOG(pAC, SK_ERRCL_NORES, SKERR_Q_E005, SKERR_Q_E005MSG);
+	}
+
 	pEv = pAC->Event.EvGet;
 	
 	PRINTF("dispatch get %x put %x\n", pEv, pAC->Event.ev_put);
 	
@@ -151,8 +189,13 @@ SK_IOC	Ioc)	/* Io context */
 		case SKGE_FD :
 			Rtv = SkFdEvent(pAC, Ioc, pEv->Event, pEv->Para);
 			break;
 #endif /* SK_USE_LAC_EV */
+#ifdef SK_ASF
+		case SKGE_ASF :
+			Rtv = SkAsfEvent(pAC,Ioc,pEv->Event,pEv->Para);
+			break ;
+#endif
 #ifdef	SK_USE_CSUM
 		case SKGE_CSUM :
 			Rtv = SkCsEvent(pAC, Ioc, pEv->Event, pEv->Para);
 			break;
@@ -162,8 +205,22 @@ SK_IOC	Ioc)	/* Io context */
 			Rtv = 0;
 		}
 
 		if (Rtv != 0) {
+			/* 
+			 * Special Case: See CAUTION statement above.
+			 * We assume the event queue is reset.
+			 */
+			if (pAC->Event.EvGet != pAC->Event.EvQueue &&
+				pAC->Event.EvGet != pEv) {
+				/*
+				 * Create an error log entry if the
+				 * event queue isn't reset.
+				 * In this case it may be blocked.
+				 */
+				SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_Q_E004, SKERR_Q_E004MSG);
+			}
+
 			return(Rtv);
 		}
 
 		if (++pEv == &pAC->Event.EvQueue[SK_MAX_EVENT])
Index: linux-2.6.8/drivers/net/sk98lin/skrlmt.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skrlmt.c
+++ linux-2.6.8/drivers/net/sk98lin/skrlmt.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skrlmt.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.69 $
- * Date:	$Date: 2003/04/15 09:39:22 $
+ * Version:	$Revision: 2.2 $
+ * Date:	$Date: 2003/11/24 12:27:57 $
  * Purpose:	Manage links on SK-NET Adapters, esp. redundant ones.
  *
  ******************************************************************************/
 
@@ -38,9 +38,9 @@
  ******************************************************************************/
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skrlmt.c,v 1.69 2003/04/15 09:39:22 tschilli Exp $ (C) Marvell.";
+	"@(#) $Id: skrlmt.c,v 2.2 2003/11/24 12:27:57 mkarl Exp $ (C) Marvell.";
 #endif	/* !defined(lint) */
 
 #define __SKRLMT_C
 
@@ -349,9 +349,9 @@ int		Level)	/* Initialization Level */
     SK_BOOL		VirtualMacAddressSet;
     SK_BOOL		PhysicalAMacAddressSet;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_INIT,
-		("RLMT Init level %d.\n", Level))
+		("RLMT Init level %d.\n", Level));
 
 	switch (Level) {
 	case SK_INIT_DATA:	/* Initialize data structures. */
 		SK_MEMSET((char *)&pAC->Rlmt, 0, sizeof(SK_RLMT));
@@ -389,9 +389,9 @@ int		Level)	/* Initialization Level */
 		break;
 
 	case SK_INIT_IO:	/* GIMacsFound first available here. */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_INIT,
-			("RLMT: %d MACs were detected.\n", pAC->GIni.GIMacsFound))
+			("RLMT: %d MACs were detected.\n", pAC->GIni.GIMacsFound));
 
 		pAC->Rlmt.Net[0].NumPorts = pAC->GIni.GIMacsFound;
 
 		/* Initialize HW registers? */
@@ -511,9 +511,9 @@ SK_U32	NetIdx)	/* Net Number */
 		return;	/* Done. */
 	}
 			
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SkRlmtBuildCheckChain.\n"))
+		("SkRlmtBuildCheckChain.\n"));
 
 	NumMacsUp = 0;
 
 	for (i = 0; i < pAC->Rlmt.Net[NetIdx].NumPorts; i++) {
@@ -557,9 +557,9 @@ SK_U32	NetIdx)	/* Net Number */
 	for (i = 0; i < pAC->Rlmt.Net[NetIdx].NumPorts; i++) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 			("Port %d checks %d other ports: %2X.\n", i,
 				pAC->Rlmt.Net[NetIdx].Port[i]->PortsChecked,
-				pAC->Rlmt.Net[NetIdx].Port[i]->PortCheck[0].CheckAddr.a[5]))
+				pAC->Rlmt.Net[NetIdx].Port[i]->PortCheck[0].CheckAddr.a[5]));
 	}
 #endif	/* DEBUG */
 
 	return;
@@ -603,9 +603,9 @@ SK_MAC_ADDR	*DestAddr)	/* Destination ad
 
 	if ((CheckSrc == 0) || (CheckDest == 0)) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_ERR,
 			("SkRlmtBuildPacket: Invalid %s%saddr.\n",
-			 (CheckSrc == 0 ? "Src" : ""), (CheckDest == 0 ? "Dest" : "")))
+			 (CheckSrc == 0 ? "Src" : ""), (CheckDest == 0 ? "Dest" : "")));
 	}
 #endif
 
 	if ((pMb = SkDrvAllocRlmtMbuf(pAC, IoC, SK_RLMT_MAX_PACKET_SIZE)) != NULL) {
@@ -795,9 +795,9 @@ SK_U32	PortNumber)	/* Sending port */
 			pRPort->RootIdSet = SK_FALSE;
 
 			SkEventQueue(pAC, SKGE_DRV, SK_DRV_RLMT_SEND, Para);
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_TX,
-				("SkRlmtSend: BPDU Packet on Port %u.\n", PortNumber))
+				("SkRlmtSend: BPDU Packet on Port %u.\n", PortNumber));
 		}
 	}
 	return;
 }	/* SkRlmtSend */
@@ -834,9 +834,9 @@ SK_U32	PortNumber)		/* Port to check */
 		 * Port is marked down (rx), but received a non-BPDU packet.
 		 * Bring it up.
 		 */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-			("SkRlmtPacketReceive: Received on PortDown.\n"))
+			("SkRlmtPacketReceive: Received on PortDown.\n"));
 
 		pRPort->PortState = SK_RLMT_PS_GOING_UP;
 		pRPort->GuTimeStamp = SkOsGetTime(pAC);
 		Para.Para32[0] = PortNumber;
@@ -848,9 +848,9 @@ SK_U32	PortNumber)		/* Port to check */
 		SkRlmtCheckSwitch(pAC, IoC, pRPort->Net->NetNumber);
 	}	/* PortDown && !SuspectTx */
 	else if (pRPort->CheckingState & SK_RLMT_PCS_RX) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-			("SkRlmtPacketReceive: Stop bringing port down.\n"))
+			("SkRlmtPacketReceive: Stop bringing port down.\n"));
 		SkTimerStop(pAC, IoC, &pRPort->DownRxTimer);
 		pRPort->CheckingState &= ~SK_RLMT_PCS_RX;
 		/* pAC->Rlmt.CheckSwitch = SK_TRUE; */
 		SkRlmtCheckSwitch(pAC, IoC, pRPort->Net->NetNumber);
@@ -895,9 +895,9 @@ SK_MBUF	*pMb)	/* Received packet */
 	pAPort = &pAC->Addr.Port[PortNumber];
 	pRPort = &pAC->Rlmt.Port[PortNumber];
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-		("SkRlmtPacketReceive: PortNumber == %d.\n", PortNumber))
+		("SkRlmtPacketReceive: PortNumber == %d.\n", PortNumber));
 
 	pRPacket = (SK_RLMT_PACKET*)pMb->pData;
 	pSPacket = (SK_SPTREE_PACKET*)pRPacket;
 
@@ -916,9 +916,9 @@ SK_MBUF	*pMb)	/* Received packet */
 		!SK_ADDR_EQUAL(BridgeMcAddr.a, pRPacket->DstAddr)) {
 
 		/* Not sent to current MAC or registered MC address => Trash it. */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-			("SkRlmtPacketReceive: Not for me.\n"))
+			("SkRlmtPacketReceive: Not for me.\n"));
 
 		SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
 		return;
 	}
@@ -954,17 +954,17 @@ SK_MBUF	*pMb)	/* Received packet */
 			pRPacket->Indicator[4] == SK_RLMT_INDICATOR4 &&
 			pRPacket->Indicator[5] == SK_RLMT_INDICATOR5 &&
 			pRPacket->Indicator[6] == SK_RLMT_INDICATOR6) {
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-				("SkRlmtPacketReceive: Duplicate MAC Address.\n"))
+				("SkRlmtPacketReceive: Duplicate MAC Address.\n"));
 
 			/* Error Log entry. */
 			SK_ERR_LOG(pAC, SK_ERRCL_COMM, SKERR_RLMT_E006, SKERR_RLMT_E006_MSG);
 		}
 		else {
 			/* Simply trash it. */
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-				("SkRlmtPacketReceive: Sent by me.\n"))
+				("SkRlmtPacketReceive: Sent by me.\n"));
 		}
 
 		SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
 		return;
@@ -1006,17 +1006,17 @@ SK_MBUF	*pMb)	/* Received packet */
 			SkRlmtBuildCheckChain(pAC);
 #endif	/* 0 */
 
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-				("SkRlmtPacketReceive: Announce.\n"))
+				("SkRlmtPacketReceive: Announce.\n"));
 
 			SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
 			break;
 
 		case SK_PACKET_ALIVE:
 			if (pRPacket->SSap & LLC_COMMAND_RESPONSE_BIT) {
 				SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-					("SkRlmtPacketReceive: Alive Reply.\n"))
+					("SkRlmtPacketReceive: Alive Reply.\n"));
 
 				if (!(pAC->Addr.Port[PortNumber].PromMode & SK_PROM_MODE_LLC) ||
 					SK_ADDR_EQUAL(
 						pRPacket->DstAddr, pAPort->CurrentMacAddress.a)) {
@@ -1045,9 +1045,9 @@ SK_MBUF	*pMb)	/* Received packet */
 				SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
 			}
 			else {	/* Alive Request Packet. */
 				SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-					("SkRlmtPacketReceive: Alive Request.\n"))
+					("SkRlmtPacketReceive: Alive Request.\n"));
 
 				pRPort->RxHelloCts++;
 
 				/* Answer. */
@@ -1064,9 +1064,9 @@ SK_MBUF	*pMb)	/* Received packet */
 			break;
 
 		case SK_PACKET_CHECK_TX:
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-				("SkRlmtPacketReceive: Check your tx line.\n"))
+				("SkRlmtPacketReceive: Check your tx line.\n"));
 
 			/* A port checking us requests us to check our tx line. */
 			pRPort->CheckingState |= SK_RLMT_PCS_TX;
 
@@ -1087,18 +1087,18 @@ SK_MBUF	*pMb)	/* Received packet */
 			break;
 
 		case SK_PACKET_ADDR_CHANGED:
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-				("SkRlmtPacketReceive: Address Change.\n"))
+				("SkRlmtPacketReceive: Address Change.\n"));
 
 			/* Build the check chain. */
 			SkRlmtBuildCheckChain(pAC, pRPort->Net->NetNumber);
 			SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
 			break;
 
 		default:
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-				("SkRlmtPacketReceive: Unknown RLMT packet.\n"))
+				("SkRlmtPacketReceive: Unknown RLMT packet.\n"));
 
 			/* RA;:;: ??? */
 			SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
 		}
@@ -1106,9 +1106,9 @@ SK_MBUF	*pMb)	/* Received packet */
 	else if (pSPacket->DSap == SK_RLMT_SPT_DSAP &&
 		pSPacket->Ctrl == SK_RLMT_SPT_CTRL &&
 		(pSPacket->SSap & ~LLC_COMMAND_RESPONSE_BIT) == SK_RLMT_SPT_SSAP) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-			("SkRlmtPacketReceive: BPDU Packet.\n"))
+			("SkRlmtPacketReceive: BPDU Packet.\n"));
 
 		/* Spanning Tree packet. */
 		pRPort->RxSpHelloCts++;
 
@@ -1138,9 +1138,9 @@ SK_MBUF	*pMb)	/* Received packet */
 					PortNumber,
 					pRPort->Root.Id[0], pRPort->Root.Id[1],
 					pRPort->Root.Id[2], pRPort->Root.Id[3],
 					pRPort->Root.Id[4], pRPort->Root.Id[5],
-					pRPort->Root.Id[6], pRPort->Root.Id[7]))
+					pRPort->Root.Id[6], pRPort->Root.Id[7]));
 		}
 
 		SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
 		if ((pAC->Rlmt.Port[PortNumber].Net->CheckingState &
@@ -1149,9 +1149,9 @@ SK_MBUF	*pMb)	/* Received packet */
 		}
 	}
 	else {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_RX,
-			("SkRlmtPacketReceive: Unknown Packet Type.\n"))
+			("SkRlmtPacketReceive: Unknown Packet Type.\n"));
 
 		/* Unknown packet. */
 		SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
 	}
@@ -1231,9 +1231,9 @@ SK_U32	PortNumber)	/* Port to check */
 
 	if ((pRPort->PacketsPerTimeSlot - pRPort->BpduPacketsPerTimeSlot) == 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 			("SkRlmtCheckPort %d: No (%d) receives in last time slot.\n",
-				PortNumber, pRPort->PacketsPerTimeSlot))
+				PortNumber, pRPort->PacketsPerTimeSlot));
 
 		/*
 		 * Check segmentation if there was no receive at least twice
 		 * in a row (PortNoRx is already set) and the segmentation
@@ -1248,9 +1248,9 @@ SK_U32	PortNumber)	/* Port to check */
 		}
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 			("SkRlmtCheckPort: PortsSuspect %d, PcsRx %d.\n",
-				pRPort->PortsSuspect, pRPort->CheckingState & SK_RLMT_PCS_RX))
+				pRPort->PortsSuspect, pRPort->CheckingState & SK_RLMT_PCS_RX));
 
 		if (pRPort->PortState != SK_RLMT_PS_DOWN) {
 			NewTimeout = TO_SHORTEN(pAC->Rlmt.Port[PortNumber].Net->TimeoutValue);
 			if (NewTimeout < SK_RLMT_MIN_TO_VAL) {
@@ -1294,9 +1294,9 @@ SK_U32	PortNumber)	/* Port to check */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 			("SkRlmtCheckPort %d: %d (%d) receives in last time slot.\n",
 				PortNumber,
 				pRPort->PacketsPerTimeSlot - pRPort->BpduPacketsPerTimeSlot,
-				pRPort->PacketsPerTimeSlot))
+				pRPort->PacketsPerTimeSlot));
 		
 		SkRlmtPortReceives(pAC, IoC, PortNumber);
 		if (pAC->Rlmt.CheckSwitch) {
 			SkRlmtCheckSwitch(pAC, IoC, pRPort->Net->NetNumber);
@@ -1344,9 +1344,9 @@ SK_U32	*pSelect)	/* New active port */
 			("TimeStamp Port %d (Down: %d, NoRx: %d): %08x %08x.\n",
 				i,
    				pAC->Rlmt.Port[i].PortDown, pAC->Rlmt.Port[i].PortNoRx,
 				*((SK_U32*)(&pAC->Rlmt.Port[i].BcTimeStamp) + OFFS_HI32),
-				*((SK_U32*)(&pAC->Rlmt.Port[i].BcTimeStamp) + OFFS_LO32)))
+				*((SK_U32*)(&pAC->Rlmt.Port[i].BcTimeStamp) + OFFS_LO32)));
 
 		if (!pAC->Rlmt.Port[i].PortDown && !pAC->Rlmt.Port[i].PortNoRx) {
 			if (!PortFound || pAC->Rlmt.Port[i].BcTimeStamp > BcTimeStamp) {
 				BcTimeStamp = pAC->Rlmt.Port[i].BcTimeStamp;
@@ -1357,9 +1357,9 @@ SK_U32	*pSelect)	/* New active port */
 	}
 
 	if (PortFound) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Port %d received the last broadcast.\n", *pSelect))
+			("Port %d received the last broadcast.\n", *pSelect));
 
 		/* Look if another port's time stamp is similar. */
 		for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
 			if (i == *pSelect) {
@@ -1372,9 +1372,9 @@ SK_U32	*pSelect)	/* New active port */
 				 SK_RLMT_BC_DELTA > BcTimeStamp)) {
 				PortFound = SK_FALSE;
 				
 				SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-					("Port %d received a broadcast at a similar time.\n", i))
+					("Port %d received a broadcast at a similar time.\n", i));
 				break;
 			}
 		}
 	}
@@ -1384,9 +1384,9 @@ SK_U32	*pSelect)	/* New active port */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 			("SK_RLMT_SELECT_BCRX found Port %d receiving the substantially "
 			 "latest broadcast (%u).\n",
 				*pSelect,
-				BcTimeStamp - pAC->Rlmt.Port[1 - *pSelect].BcTimeStamp))
+				BcTimeStamp - pAC->Rlmt.Port[1 - *pSelect].BcTimeStamp));
 	}
 #endif	/* DEBUG */
 
 	return (PortFound);
@@ -1433,9 +1433,9 @@ SK_U32	*pSelect)	/* New active port */
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 				("SK_RLMT_SELECT_NOTSUSPECT found Port %d up and not check RX.\n",
-					*pSelect))
+					*pSelect));
 			break;
 		}
 	}
 	return (PortFound);
@@ -1482,9 +1482,9 @@ SK_BOOL	AutoNegDone)	/* Successfully aut
 				*pSelect = PrefPort;
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_SELECT_UP found Port %d up.\n", *pSelect))
+				("SK_RLMT_SELECT_UP found Port %d up.\n", *pSelect));
 			break;
 		}
 	}
 	return (PortFound);
@@ -1543,9 +1543,9 @@ SK_BOOL	AutoNegDone)	/* Successfully aut
 		}
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_SELECT_GOINGUP found Port %d going up.\n", *pSelect))
+		("SK_RLMT_SELECT_GOINGUP found Port %d going up.\n", *pSelect));
 	return (SK_TRUE);
 }	/* SkRlmtSelectGoingUp */
 
 
@@ -1589,9 +1589,9 @@ SK_BOOL	AutoNegDone)	/* Successfully aut
 				*pSelect = PrefPort;
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_SELECT_DOWN found Port %d down.\n", *pSelect))
+				("SK_RLMT_SELECT_DOWN found Port %d down.\n", *pSelect));
 			break;
 		}
 	}
 	return (PortFound);
@@ -1787,9 +1787,9 @@ SK_U32	NetIdx)	/* Net index */
 		if (PortFound) {
 
 			if (Para.Para32[1] != Active) {
 				SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-					("Active: %d, Para1: %d.\n", Active, Para.Para32[1]))
+					("Active: %d, Para1: %d.\n", Active, Para.Para32[1]));
 				pAC->Rlmt.Net[NetIdx].ActivePort = Para.Para32[1];
 				Para.Para32[0] = pAC->Rlmt.Net[NetIdx].
 					Port[Para.Para32[0]]->PortNumber;
 				Para.Para32[1] = pAC->Rlmt.Net[NetIdx].
@@ -1867,9 +1867,9 @@ SK_U32	NetIdx)	/* Net number */
 			("Root ID %d: %02x %02x %02x %02x %02x %02x %02x %02x.\n", i,
 				pNet->Port[i]->Root.Id[0], pNet->Port[i]->Root.Id[1],
 				pNet->Port[i]->Root.Id[2], pNet->Port[i]->Root.Id[3],
 				pNet->Port[i]->Root.Id[4], pNet->Port[i]->Root.Id[5],
-				pNet->Port[i]->Root.Id[6], pNet->Port[i]->Root.Id[7]))
+				pNet->Port[i]->Root.Id[6], pNet->Port[i]->Root.Id[7]));
 
 		if (!pNet->RootIdSet) {
 			pNet->Root = pNet->Port[i]->Root;
 			pNet->RootIdSet = SK_TRUE;
@@ -1962,15 +1962,15 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 {
 	SK_U32			i;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PORTSTART_TIMEOUT Port %d Event BEGIN.\n", Para.Para32[0]))
+		("SK_RLMT_PORTSTART_TIMEOUT Port %d Event BEGIN.\n", Para.Para32[0]));
 
 		if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_PORTSTART_TIMEOUT Event EMPTY.\n"))
+			("SK_RLMT_PORTSTART_TIMEOUT Event EMPTY.\n"));
 		return;
 	}
 
 	/*
@@ -1989,9 +1989,9 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 		}
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PORTSTART_TIMEOUT Event END.\n"))
+		("SK_RLMT_PORTSTART_TIMEOUT Event END.\n"));
 }	/* SkRlmtEvtPortStartTim */
 
 
 /******************************************************************************
@@ -2017,23 +2017,23 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 	SK_RLMT_PORT	*pRPort;
 	SK_EVPARA		Para2;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_LINK_UP Port %d Event BEGIN.\n", Para.Para32[0]))
+		("SK_RLMT_LINK_UP Port %d Event BEGIN.\n", Para.Para32[0]));
 
 	pRPort = &pAC->Rlmt.Port[Para.Para32[0]];
 	if (!pRPort->PortStarted) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_RLMT_E008, SKERR_RLMT_E008_MSG);
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_LINK_UP Event EMPTY.\n"))
+				("SK_RLMT_LINK_UP Event EMPTY.\n"));
 		return;
 	}
 
 	if (!pRPort->LinkDown) {
 		/* RA;:;: Any better solution? */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_LINK_UP Event EMPTY.\n"))
+			("SK_RLMT_LINK_UP Event EMPTY.\n"));
 		return;
 	}
 
 	SkTimerStop(pAC, IoC, &pRPort->UpTimer);
@@ -2109,9 +2109,9 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 		}
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_LINK_UP Event END.\n"))
+		("SK_RLMT_LINK_UP Event END.\n"));
 }	/* SkRlmtEvtLinkUp */
 
 
 /******************************************************************************
@@ -2135,22 +2135,22 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 {
 	SK_RLMT_PORT	*pRPort;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PORTUP_TIM Port %d Event BEGIN.\n", Para.Para32[0]))
+		("SK_RLMT_PORTUP_TIM Port %d Event BEGIN.\n", Para.Para32[0]));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_PORTUP_TIM Event EMPTY.\n"))
+			("SK_RLMT_PORTUP_TIM Event EMPTY.\n"));
 		return;
 	}
 
 	pRPort = &pAC->Rlmt.Port[Para.Para32[0]];
 	if (pRPort->LinkDown || (pRPort->PortState == SK_RLMT_PS_UP)) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_PORTUP_TIM Port %d Event EMPTY.\n", Para.Para32[0]))
+			("SK_RLMT_PORTUP_TIM Port %d Event EMPTY.\n", Para.Para32[0]));
 		return;
 	}
 
 	pRPort->PortDown = SK_FALSE;
@@ -2163,9 +2163,9 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 		SkEventQueue(pAC, SKGE_PNMI, SK_PNMI_EVT_RLMT_PORT_UP, Para);
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PORTUP_TIM Event END.\n"))
+		("SK_RLMT_PORTUP_TIM Event END.\n"));
 }	/* SkRlmtEvtPortUpTim */
 
 
 /******************************************************************************
@@ -2191,23 +2191,23 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 	SK_RLMT_PORT	*pRPort;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 		("SK_RLMT_PORTDOWN* Port %d Event (%d) BEGIN.\n",
-			Para.Para32[0], Event))
+			Para.Para32[0], Event));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_PORTDOWN* Event EMPTY.\n"))
+			("SK_RLMT_PORTDOWN* Event EMPTY.\n"));
 		return;
 	}
 
 	pRPort = &pAC->Rlmt.Port[Para.Para32[0]];
 	if (!pRPort->PortStarted || (Event == SK_RLMT_PORTDOWN_TX_TIM &&
 		!(pRPort->CheckingState & SK_RLMT_PCS_TX))) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_PORTDOWN* Event (%d) EMPTY.\n", Event))
+			("SK_RLMT_PORTDOWN* Event (%d) EMPTY.\n", Event));
 		return;
 	}
 	
 	/* Stop port's timers. */
@@ -2242,9 +2242,9 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 		}
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PORTDOWN* Event (%d) END.\n", Event))
+		("SK_RLMT_PORTDOWN* Event (%d) END.\n", Event));
 }	/* SkRlmtEvtPortDownX */
 
 
 /******************************************************************************
@@ -2269,9 +2269,9 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 	SK_RLMT_PORT	*pRPort;
 
 	pRPort = &pAC->Rlmt.Port[Para.Para32[0]];
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_LINK_DOWN Port %d Event BEGIN.\n", Para.Para32[0]))
+		("SK_RLMT_LINK_DOWN Port %d Event BEGIN.\n", Para.Para32[0]));
 
 	if (!pAC->Rlmt.Port[Para.Para32[0]].LinkDown) {
 		pRPort->Net->LinksUp--;
 		pRPort->LinkDown = SK_TRUE;
@@ -2288,9 +2288,9 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 		(void)SkRlmtEvent(pAC, IoC, SK_RLMT_PORTDOWN, Para);
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_LINK_DOWN Event END.\n"))
+		("SK_RLMT_LINK_DOWN Event END.\n"));
 }	/* SkRlmtEvtLinkDown */
 
 
 /******************************************************************************
@@ -2317,15 +2317,15 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 	SK_MAC_ADDR		*pOldMacAddr;
 	SK_MAC_ADDR		*pNewMacAddr;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PORT_ADDR Port %d Event BEGIN.\n", Para.Para32[0]))
+		("SK_RLMT_PORT_ADDR Port %d Event BEGIN.\n", Para.Para32[0]));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_PORT_ADDR Event EMPTY.\n"))
+			("SK_RLMT_PORT_ADDR Event EMPTY.\n"));
 		return;
 	}
 
 	/* Port's physical MAC address changed. */
@@ -2347,9 +2347,9 @@ SK_EVPARA	Para)	/* SK_U32 PortNumber; SK
 		}
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_PORT_ADDR Event END.\n"))
+			("SK_RLMT_PORT_ADDR Event END.\n"));
 }	/* SkRlmtEvtPortAddr */
 
 
 /******************************************************************************
@@ -2375,37 +2375,37 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 	SK_U32		PortIdx;
 	SK_U32		PortNumber;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_START Net %d Event BEGIN.\n", Para.Para32[0]))
+		("SK_RLMT_START Net %d Event BEGIN.\n", Para.Para32[0]));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_START Event EMPTY.\n"))
+			("SK_RLMT_START Event EMPTY.\n"));
 		return;
 	}
 
 	if (Para.Para32[0] >= pAC->Rlmt.NumNets) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad NetNumber %d.\n", Para.Para32[0]))
+			("Bad NetNumber %d.\n", Para.Para32[0]));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_START Event EMPTY.\n"))
+			("SK_RLMT_START Event EMPTY.\n"));
 		return;
 	}
 
 	if (pAC->Rlmt.Net[Para.Para32[0]].RlmtState != SK_RLMT_RS_INIT) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_START Event EMPTY.\n"))
+			("SK_RLMT_START Event EMPTY.\n"));
 		return;
 	}
 
 	if (pAC->Rlmt.NetsStarted >= pAC->Rlmt.NumNets) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("All nets should have been started.\n"))
+			("All nets should have been started.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_START Event EMPTY.\n"))
+			("SK_RLMT_START Event EMPTY.\n"));
 		return;
 	}
 
 	if (pAC->Rlmt.Net[Para.Para32[0]].PrefPort >=
@@ -2437,9 +2437,9 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 
 	pAC->Rlmt.NetsStarted++;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_START Event END.\n"))
+			("SK_RLMT_START Event END.\n"));
 }	/* SkRlmtEvtStart */
 
 
 /******************************************************************************
@@ -2465,37 +2465,37 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 	SK_U32		PortNumber;
 	SK_U32		i;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_STOP Net %d Event BEGIN.\n", Para.Para32[0]))
+		("SK_RLMT_STOP Net %d Event BEGIN.\n", Para.Para32[0]));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_STOP Event EMPTY.\n"))
+			("SK_RLMT_STOP Event EMPTY.\n"));
 		return;
 	}
 
 	if (Para.Para32[0] >= pAC->Rlmt.NumNets) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad NetNumber %d.\n", Para.Para32[0]))
+			("Bad NetNumber %d.\n", Para.Para32[0]));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_STOP Event EMPTY.\n"))
+			("SK_RLMT_STOP Event EMPTY.\n"));
 		return;
 	}
 
 	if (pAC->Rlmt.Net[Para.Para32[0]].RlmtState == SK_RLMT_RS_INIT) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_STOP Event EMPTY.\n"))
+			("SK_RLMT_STOP Event EMPTY.\n"));
 		return;
 	}
 
 	if (pAC->Rlmt.NetsStarted == 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("All nets are stopped.\n"))
+			("All nets are stopped.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_STOP Event EMPTY.\n"))
+			("SK_RLMT_STOP Event EMPTY.\n"));
 		return;
 	}
 
 	/* Stop RLMT timers. */
@@ -2528,9 +2528,9 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 
 	pAC->Rlmt.NetsStarted--;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_STOP Event END.\n"))
+		("SK_RLMT_STOP Event END.\n"));
 }	/* SkRlmtEvtStop */
 
 
 /******************************************************************************
@@ -2558,15 +2558,15 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 	SK_U32			PortNumber;
 	SK_U32			i;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_TIM Event BEGIN.\n"))
+		("SK_RLMT_TIM Event BEGIN.\n"));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_TIM Event EMPTY.\n"))
+			("SK_RLMT_TIM Event EMPTY.\n"));
 		return;
 	}
 
 	if ((pAC->Rlmt.Net[Para.Para32[0]].RlmtMode & SK_RLMT_CHECK_OTHERS) == 0 ||
@@ -2636,9 +2636,9 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 			SK_RLMT_RCS_SEG | SK_RLMT_RCS_REPORT_SEG;
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_TIM Event END.\n"))
+			("SK_RLMT_TIM Event END.\n"));
 }	/* SkRlmtEvtTim */
 
 
 /******************************************************************************
@@ -2664,15 +2664,15 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 	int j;
 #endif	/* DEBUG */
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_SEG_TIM Event BEGIN.\n"))
+		("SK_RLMT_SEG_TIM Event BEGIN.\n"));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_SEG_TIM Event EMPTY.\n"))
+			("SK_RLMT_SEG_TIM Event EMPTY.\n"));
 		return;
 	}
 
 #ifdef xDEBUG
@@ -2694,17 +2694,17 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 					InAddr8[0], InAddr8[1], InAddr8[2],
 					InAddr8[3], InAddr8[4], InAddr8[5],
 					pAPort->Exact[k].a[0], pAPort->Exact[k].a[1],
 					pAPort->Exact[k].a[2], pAPort->Exact[k].a[3],
-					pAPort->Exact[k].a[4], pAPort->Exact[k].a[5]))
+					pAPort->Exact[k].a[4], pAPort->Exact[k].a[5]));
 		}
 	}
 #endif	/* xDEBUG */
 				
 	SkRlmtCheckSeg(pAC, IoC, Para.Para32[0]);
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_SEG_TIM Event END.\n"))
+			("SK_RLMT_SEG_TIM Event END.\n"));
 }	/* SkRlmtEvtSegTim */
 
 
 /******************************************************************************
@@ -2731,20 +2731,20 @@ SK_EVPARA	Para)	/* SK_MBUF *pMb */
 	SK_U32	NetNumber;
 
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PACKET_RECEIVED Event BEGIN.\n"))
+		("SK_RLMT_PACKET_RECEIVED Event BEGIN.\n"));
 
 	/* Should we ignore frames during port switching? */
 
 #ifdef DEBUG
 	pMb = Para.pParaPtr;
 	if (pMb == NULL) {
-		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL, ("No mbuf.\n"))
+		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL, ("No mbuf.\n"));
 	}
 	else if (pMb->pNext != NULL) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("More than one mbuf or pMb->pNext not set.\n"))
+			("More than one mbuf or pMb->pNext not set.\n"));
 	}
 #endif	/* DEBUG */
 
 	for (pMb = Para.pParaPtr; pMb != NULL; pMb = pNextMb) {
@@ -2760,9 +2760,9 @@ SK_EVPARA	Para)	/* SK_MBUF *pMb */
 		}
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PACKET_RECEIVED Event END.\n"))
+		("SK_RLMT_PACKET_RECEIVED Event END.\n"));
 }	/* SkRlmtEvtPacketRx */
 
 
 /******************************************************************************
@@ -2787,23 +2787,23 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 	SK_U32			i;
 	SK_RLMT_PORT	*pRPort;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_STATS_CLEAR Event BEGIN.\n"))
+		("SK_RLMT_STATS_CLEAR Event BEGIN.\n"));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_STATS_CLEAR Event EMPTY.\n"))
+			("SK_RLMT_STATS_CLEAR Event EMPTY.\n"));
 		return;
 	}
 
 	if (Para.Para32[0] >= pAC->Rlmt.NumNets) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad NetNumber %d.\n", Para.Para32[0]))
+			("Bad NetNumber %d.\n", Para.Para32[0]));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_STATS_CLEAR Event EMPTY.\n"))
+			("SK_RLMT_STATS_CLEAR Event EMPTY.\n"));
 		return;
 	}
 
 	/* Clear statistics for logical and physical ports. */
@@ -2816,9 +2816,9 @@ SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_
 		pRPort->RxSpHelloCts = 0;
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_STATS_CLEAR Event END.\n"))
+		("SK_RLMT_STATS_CLEAR Event END.\n"));
 }	/* SkRlmtEvtStatsClear */
 
 
 /******************************************************************************
@@ -2840,30 +2840,30 @@ SK_AC		*pAC,	/* Adapter Context */
 SK_IOC		IoC,	/* I/O Context */
 SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_U32 -1 */
 {
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_STATS_UPDATE Event BEGIN.\n"))
+		("SK_RLMT_STATS_UPDATE Event BEGIN.\n"));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_STATS_UPDATE Event EMPTY.\n"))
+			("SK_RLMT_STATS_UPDATE Event EMPTY.\n"));
 		return;
 	}
 
 	if (Para.Para32[0] >= pAC->Rlmt.NumNets) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad NetNumber %d.\n", Para.Para32[0]))
+			("Bad NetNumber %d.\n", Para.Para32[0]));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_STATS_UPDATE Event EMPTY.\n"))
+			("SK_RLMT_STATS_UPDATE Event EMPTY.\n"));
 		return;
 	}
 
 	/* Update statistics - currently always up-to-date. */
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_STATS_UPDATE Event END.\n"))
+		("SK_RLMT_STATS_UPDATE Event END.\n"));
 }	/* SkRlmtEvtStatsUpdate */
 
 
 /******************************************************************************
@@ -2885,15 +2885,15 @@ SK_AC		*pAC,	/* Adapter Context */
 SK_IOC		IoC,	/* I/O Context */
 SK_EVPARA	Para)	/* SK_U32 PortIndex; SK_U32 NetNumber */
 {
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PREFPORT_CHANGE to Port %d Event BEGIN.\n", Para.Para32[0]))
+		("SK_RLMT_PREFPORT_CHANGE to Port %d Event BEGIN.\n", Para.Para32[0]));
 
 	if (Para.Para32[1] >= pAC->Rlmt.NumNets) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad NetNumber %d.\n", Para.Para32[1]))
+			("Bad NetNumber %d.\n", Para.Para32[1]));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_PREFPORT_CHANGE Event EMPTY.\n"))
+			("SK_RLMT_PREFPORT_CHANGE Event EMPTY.\n"));
 		return;
 	}
 
 	/* 0xFFFFFFFF == auto-mode. */
@@ -2904,9 +2904,9 @@ SK_EVPARA	Para)	/* SK_U32 PortIndex; SK_
 		if (Para.Para32[0] >= pAC->Rlmt.Net[Para.Para32[1]].NumPorts) {
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_RLMT_E010, SKERR_RLMT_E010_MSG);
 
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_PREFPORT_CHANGE Event EMPTY.\n"))
+				("SK_RLMT_PREFPORT_CHANGE Event EMPTY.\n"));
 			return;
 		}
 
 		pAC->Rlmt.Net[Para.Para32[1]].PrefPort = Para.Para32[0];
@@ -2918,9 +2918,9 @@ SK_EVPARA	Para)	/* SK_U32 PortIndex; SK_
 		SkRlmtCheckSwitch(pAC, IoC, Para.Para32[1]);
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_PREFPORT_CHANGE Event END.\n"))
+		("SK_RLMT_PREFPORT_CHANGE Event END.\n"));
 }	/* SkRlmtEvtPrefportChange */
 
 
 /******************************************************************************
@@ -2944,39 +2944,39 @@ SK_EVPARA	Para)	/* SK_U32 NumNets; SK_U3
 {
 	int i;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_SET_NETS Event BEGIN.\n"))
+		("SK_RLMT_SET_NETS Event BEGIN.\n"));
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad Parameter.\n"))
+			("Bad Parameter.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_SET_NETS Event EMPTY.\n"))
+			("SK_RLMT_SET_NETS Event EMPTY.\n"));
 		return;
 	}
 
 	if (Para.Para32[0] == 0 || Para.Para32[0] > SK_MAX_NETS ||
 		Para.Para32[0] > (SK_U32)pAC->GIni.GIMacsFound) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad number of nets: %d.\n", Para.Para32[0]))
+			("Bad number of nets: %d.\n", Para.Para32[0]));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_SET_NETS Event EMPTY.\n"))
+			("SK_RLMT_SET_NETS Event EMPTY.\n"));
 		return;
 	}
 
 	if (Para.Para32[0] == pAC->Rlmt.NumNets) {	/* No change. */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_SET_NETS Event EMPTY.\n"))
+			("SK_RLMT_SET_NETS Event EMPTY.\n"));
 		return;
 	}
 
 	/* Entering and leaving dual mode only allowed while nets are stopped. */
 	if (pAC->Rlmt.NetsStarted > 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Changing dual mode only allowed while all nets are stopped.\n"))
+			("Changing dual mode only allowed while all nets are stopped.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_SET_NETS Event EMPTY.\n"))
+			("SK_RLMT_SET_NETS Event EMPTY.\n"));
 		return;
 	}
 
 	if (Para.Para32[0] == 1) {
@@ -3005,9 +3005,9 @@ SK_EVPARA	Para)	/* SK_U32 NumNets; SK_U3
 
 		SkEventQueue(pAC, SKGE_PNMI, SK_PNMI_EVT_RLMT_SET_NETS, Para);
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("RLMT: Changed to one net with two ports.\n"))
+			("RLMT: Changed to one net with two ports.\n"));
 	}
 	else if (Para.Para32[0] == 2) {
 		pAC->Rlmt.Port[1].Net= &pAC->Rlmt.Net[1];
 		pAC->Rlmt.Net[1].NumPorts = pAC->GIni.GIMacsFound - 1;
@@ -3034,21 +3034,21 @@ SK_EVPARA	Para)	/* SK_U32 NumNets; SK_U3
 
 		SkEventQueue(pAC, SKGE_PNMI, SK_PNMI_EVT_RLMT_SET_NETS, Para);
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("RLMT: Changed to two nets with one port each.\n"))
+			("RLMT: Changed to two nets with one port each.\n"));
 	}
 	else {
 		/* Not implemented for more than two nets. */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SetNets not implemented for more than two nets.\n"))
+			("SetNets not implemented for more than two nets.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_SET_NETS Event EMPTY.\n"))
+			("SK_RLMT_SET_NETS Event EMPTY.\n"));
 		return;
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_SET_NETS Event END.\n"))
+		("SK_RLMT_SET_NETS Event END.\n"));
 }	/* SkRlmtSetNets */
 
 
 /******************************************************************************
@@ -3074,15 +3074,15 @@ SK_EVPARA	Para)	/* SK_U32 NewMode; SK_U3
 	SK_U32		i;
 	SK_U32		PrevRlmtMode;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_MODE_CHANGE Event BEGIN.\n"))
+		("SK_RLMT_MODE_CHANGE Event BEGIN.\n"));
 
 	if (Para.Para32[1] >= pAC->Rlmt.NumNets) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Bad NetNumber %d.\n", Para.Para32[1]))
+			("Bad NetNumber %d.\n", Para.Para32[1]));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_MODE_CHANGE Event EMPTY.\n"))
+			("SK_RLMT_MODE_CHANGE Event EMPTY.\n"));
 		return;
 	}
 
 	Para.Para32[0] |= SK_RLMT_CHECK_LINK;
@@ -3090,11 +3090,11 @@ SK_EVPARA	Para)	/* SK_U32 NewMode; SK_U3
 	if ((pAC->Rlmt.Net[Para.Para32[1]].NumPorts == 1) &&
 		Para.Para32[0] != SK_RLMT_MODE_CLS) {
 		pAC->Rlmt.Net[Para.Para32[1]].RlmtMode = SK_RLMT_MODE_CLS;
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Forced RLMT mode to CLS on single port net.\n"))
+			("Forced RLMT mode to CLS on single port net.\n"));
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_MODE_CHANGE Event EMPTY.\n"))
+			("SK_RLMT_MODE_CHANGE Event EMPTY.\n"));
 		return;
 	}
 
 	/* Update RLMT mode. */
@@ -3158,9 +3158,9 @@ SK_EVPARA	Para)	/* SK_U32 NewMode; SK_U3
 		}
 	}	/* SK_RLMT_CHECK_SEG bit changed. */
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_MODE_CHANGE Event END.\n"))
+			("SK_RLMT_MODE_CHANGE Event END.\n"));
 }	/* SkRlmtEvtModeChange */
 
 
 /******************************************************************************
@@ -3244,9 +3244,9 @@ SK_EVPARA	Para)	/* Event-specific parame
 	/* ----- Unknown events ----- */
 
 	default:	/* Create error log entry. */
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Unknown RLMT Event %d.\n", Event))
+			("Unknown RLMT Event %d.\n", Event));
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_RLMT_E003, SKERR_RLMT_E003_MSG);
 		break;
 	}	/* switch() */
 
Index: linux-2.6.8/drivers/net/sk98lin/sktimer.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/sktimer.c
+++ linux-2.6.8/drivers/net/sk98lin/sktimer.c
@@ -1,18 +1,18 @@
 /******************************************************************************
  *
  * Name:	sktimer.c
  * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
- * Version:	$Revision: 1.14 $
- * Date:	$Date: 2003/09/16 13:46:51 $
+ * Version:	$Revision: 2.2 $
+ * Date:	$Date: 2004/05/28 13:44:39 $
  * Purpose:	High level timer functions.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect GmbH.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
@@ -21,15 +21,14 @@
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
-
 /*
  *	Event queue and dispatcher
  */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: sktimer.c,v 1.14 2003/09/16 13:46:51 rschmidt Exp $ (C) Marvell.";
+	"@(#) $Id: sktimer.c,v 2.2 2004/05/28 13:44:39 rschmidt Exp $ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
@@ -61,9 +60,9 @@ SK_IOC	Ioc,		/* IoContext */
 int		Level)		/* Init Level */
 {
 	switch (Level) {
 	case SK_INIT_DATA:
-		pAC->Tim.StQueue = NULL;
+		pAC->Tim.StQueue = 0;
 		break;
 	case SK_INIT_IO:
 		SkHwtInit(pAC, Ioc);
 		SkTimerDone(pAC, Ioc);
@@ -84,24 +83,22 @@ SK_TIMER	*pTimer)	/* Timer Pointer to be
 {
 	SK_TIMER	**ppTimPrev;
 	SK_TIMER	*pTm;
 
-	/*
-	 * remove timer from queue
-	 */
+	/* remove timer from queue */
 	pTimer->TmActive = SK_FALSE;
-	
+
 	if (pAC->Tim.StQueue == pTimer && !pTimer->TmNext) {
 		SkHwtStop(pAC, Ioc);
 	}
-	
+
 	for (ppTimPrev = &pAC->Tim.StQueue; (pTm = *ppTimPrev);
 		ppTimPrev = &pTm->TmNext ) {
-		
+
 		if (pTm == pTimer) {
 			/*
 			 * Timer found in queue
-			 * - dequeue it and
+			 * - dequeue it
 			 * - correct delta of the next timer
 			 */
 			*ppTimPrev = pTm->TmNext;
 
@@ -120,55 +117,45 @@ SK_TIMER	*pTimer)	/* Timer Pointer to be
 void	SkTimerStart(
 SK_AC		*pAC,		/* Adapters context */
 SK_IOC		Ioc,		/* IoContext */
 SK_TIMER	*pTimer,	/* Timer Pointer to be started */
-SK_U32		Time,		/* Time value */
+SK_U32		Time,		/* Time Value (in microsec.) */
 SK_U32		Class,		/* Event Class for this timer */
 SK_U32		Event,		/* Event Value for this timer */
 SK_EVPARA	Para)		/* Event Parameter for this timer */
 {
 	SK_TIMER	**ppTimPrev;
 	SK_TIMER	*pTm;
 	SK_U32		Delta;
 
-	Time /= 16;		/* input is uS, clock ticks are 16uS */
-	
-	if (!Time)
-		Time = 1;
-
 	SkTimerStop(pAC, Ioc, pTimer);
 
 	pTimer->TmClass = Class;
 	pTimer->TmEvent = Event;
 	pTimer->TmPara = Para;
 	pTimer->TmActive = SK_TRUE;
 
 	if (!pAC->Tim.StQueue) {
-		/* First Timer to be started */
+		/* first Timer to be started */
 		pAC->Tim.StQueue = pTimer;
-		pTimer->TmNext = NULL;
+		pTimer->TmNext = 0;
 		pTimer->TmDelta = Time;
-		
+
 		SkHwtStart(pAC, Ioc, Time);
-		
+
 		return;
 	}
 
-	/*
-	 * timer correction
-	 */
+	/* timer correction */
 	timer_done(pAC, Ioc, 0);
 
-	/*
-	 * find position in queue
-	 */
+	/* find position in queue */
 	Delta = 0;
 	for (ppTimPrev = &pAC->Tim.StQueue; (pTm = *ppTimPrev);
 		ppTimPrev = &pTm->TmNext ) {
-		
+
 		if (Delta + pTm->TmDelta > Time) {
-			/* Position found */
-			/* Here the timer needs to be inserted. */
+			/* the timer needs to be inserted here */
 			break;
 		}
 		Delta += pTm->TmDelta;
 	}
@@ -178,11 +165,9 @@ SK_EVPARA	Para)		/* Event Parameter for 
 	pTimer->TmNext = pTm;
 	pTimer->TmDelta = Time - Delta;
 
 	if (pTm) {
-		/* There is a next timer
-		 * -> correct its Delta value.
-		 */
+		/* there is a next timer:  correct its Delta value */
 		pTm->TmDelta -= pTimer->TmDelta;
 	}
 
 	/* restart with first */
@@ -209,9 +194,9 @@ int		Restart)	/* Do we need to restart t
 	SK_TIMER	**ppLast;	/* Next field of Last timer to be deq */
 	int		Done = 0;
 
 	Delta = SkHwtRead(pAC, Ioc);
-	
+
 	ppLast = &pAC->Tim.StQueue;
 	pTm = pAC->Tim.StQueue;
 	while (pTm && !Done) {
 		if (Delta >= pTm->TmDelta) {
@@ -227,15 +212,15 @@ int		Restart)	/* Do we need to restart t
 			Delta = 0;
 			Done = 1;
 		}
 	}
-	*ppLast = NULL;
+	*ppLast = 0;
 	/*
 	 * pTm points to the first Timer that did not run out.
 	 * StQueue points to the first Timer that run out.
 	 */
 
-	for ( pTComp = pAC->Tim.StQueue; pTComp; pTComp = pTComp->TmNext) {
+	for (pTComp = pAC->Tim.StQueue; pTComp; pTComp = pTComp->TmNext) {
 		SkEventQueue(pAC,pTComp->TmClass, pTComp->TmEvent, pTComp->TmPara);
 	}
 
 	/* Set head of timer queue to the first timer that did not run out */
Index: linux-2.6.8/drivers/net/sk98lin/sktwsi.c
===================================================================
--- /dev/null
+++ linux-2.6.8/drivers/net/sk98lin/sktwsi.c
@@ -0,0 +1,1309 @@
+/******************************************************************************
+ *
+ * Name:	sktwsi.c
+ * Project:	Gigabit Ethernet Adapters, TWSI-Module
+ * Version:	$Revision: 1.4 $
+ * Date:	$Date: 2004/01/15 15:03:07 $
+ * Purpose:	Functions to access Voltage and Temperature Sensor
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+/*
+ *	TWSI Protocol
+ */
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
+static const char SysKonnectFileId[] =
+	"@(#) $Id: sktwsi.c,v 1.4 2004/01/15 15:03:07 malthoff Exp $ (C) Marvell. ";
+#endif
+
+#include "h/skdrv1st.h"		/* Driver Specific Definitions */
+#include "h/lm80.h"
+#include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
+
+#ifdef __C2MAN__
+/*
+	TWSI protocol implementation.
+
+	General Description:
+
+	The TWSI protocol is used for the temperature sensors and for
+	the serial EEPROM which hold the configuration.
+
+	This file covers functions that allow to read write and do
+	some bulk requests a specified TWSI address.
+
+	The Genesis has 2 TWSI buses. One for the EEPROM which holds
+	the VPD Data and one for temperature and voltage sensor.
+	The following picture shows the TWSI buses, TWSI devices and
+	their control registers.
+
+	Note: The VPD functions are in skvpd.c
+.
+.	PCI Config TWSI Bus for VPD Data:
+.
+.		      +------------+
+.		      | VPD EEPROM |
+.		      +------------+
+.			     |
+.			     | <-- TWSI
+.			     |
+.		 +-----------+-----------+
+.		 |			 |
+.	+-----------------+	+-----------------+
+.	| PCI_VPD_ADR_REG |	| PCI_VPD_DAT_REG |
+.	+-----------------+	+-----------------+
+.
+.
+.	TWSI Bus for LM80 sensor:
+.
+.			+-----------------+
+.			| Temperature and |
+.			| Voltage Sensor  |
+.			| 	LM80	  |
+.			+-----------------+
+.				|
+.				|
+.			TWSI --> |
+.				|
+.			     +----+
+.	     +-------------->| OR |<--+
+.	     |		     +----+   |
+.     +------+------+		      |
+.     |		    |		      |
+. +--------+	+--------+	+----------+
+. | B2_I2C |	| B2_I2C |	|  B2_I2C  |
+. | _CTRL  |	| _DATA  |	|   _SW    |
+. +--------+	+--------+	+----------+
+.
+	The TWSI bus may be driven by the B2_I2C_SW or by the B2_I2C_CTRL
+	and B2_I2C_DATA registers.
+	For driver software it is recommended to use the TWSI control and
+	data register, because TWSI bus timing is done by the ASIC and
+	an interrupt may be received when the TWSI request is completed.
+
+	Clock Rate Timing:			MIN	MAX	generated by
+		VPD EEPROM:			50 kHz	100 kHz		HW
+		LM80 over TWSI Ctrl/Data reg.	50 kHz	100 kHz		HW
+		LM80 over B2_I2C_SW register	0	400 kHz		SW
+
+	Note:	The clock generated by the hardware is dependend on the
+		PCI clock. If the PCI bus clock is 33 MHz, the I2C/VPD
+		clock is 50 kHz.
+ */
+intro()
+{}
+#endif
+
+#ifdef SK_DIAG
+/*
+ * TWSI Fast Mode timing values used by the LM80.
+ * If new devices are added to the TWSI bus the timing values have to be checked.
+ */
+#ifndef I2C_SLOW_TIMING
+#define	T_CLK_LOW			1300L	/* clock low time in ns */
+#define	T_CLK_HIGH		 	 600L	/* clock high time in ns */
+#define T_DATA_IN_SETUP		 100L	/* data in Set-up Time */
+#define T_START_HOLD		 600L	/* start condition hold time */
+#define T_START_SETUP		 600L	/* start condition Set-up time */
+#define	T_STOP_SETUP		 600L	/* stop condition Set-up time */
+#define T_BUS_IDLE			1300L	/* time the bus must free after Tx */
+#define	T_CLK_2_DATA_OUT	 900L	/* max. clock low to data output valid */
+#else	/* I2C_SLOW_TIMING */
+/* TWSI Standard Mode Timing */
+#define	T_CLK_LOW			4700L	/* clock low time in ns */
+#define	T_CLK_HIGH			4000L	/* clock high time in ns */
+#define T_DATA_IN_SETUP		 250L	/* data in Set-up Time */
+#define T_START_HOLD		4000L	/* start condition hold time */
+#define T_START_SETUP		4700L	/* start condition Set-up time */
+#define	T_STOP_SETUP		4000L	/* stop condition Set-up time */
+#define T_BUS_IDLE			4700L	/* time the bus must free after Tx */
+#endif	/* !I2C_SLOW_TIMING */
+
+#define NS2BCLK(x)	(((x)*125)/10000)
+
+/*
+ * TWSI Wire Operations
+ *
+ * About I2C_CLK_LOW():
+ *
+ * The Data Direction bit (I2C_DATA_DIR) has to be set to input when setting
+ * clock to low, to prevent the ASIC and the TWSI data client from driving the
+ * serial data line simultaneously (ASIC: last bit of a byte = '1', TWSI client
+ * send an 'ACK'). See also Concentrator Bugreport No. 10192.
+ */
+#define I2C_DATA_HIGH(IoC)	SK_I2C_SET_BIT(IoC, I2C_DATA)
+#define	I2C_DATA_LOW(IoC)	SK_I2C_CLR_BIT(IoC, I2C_DATA)
+#define	I2C_DATA_OUT(IoC)	SK_I2C_SET_BIT(IoC, I2C_DATA_DIR)
+#define	I2C_DATA_IN(IoC)	SK_I2C_CLR_BIT(IoC, I2C_DATA_DIR | I2C_DATA)
+#define	I2C_CLK_HIGH(IoC)	SK_I2C_SET_BIT(IoC, I2C_CLK)
+#define	I2C_CLK_LOW(IoC)	SK_I2C_CLR_BIT(IoC, I2C_CLK | I2C_DATA_DIR)
+#define	I2C_START_COND(IoC)	SK_I2C_CLR_BIT(IoC, I2C_CLK)
+
+#define NS2CLKT(x)	((x*125L)/10000)
+
+/*--------------- TWSI Interface Register Functions --------------- */
+
+/*
+ * sending one bit
+ */
+void SkI2cSndBit(
+SK_IOC	IoC,	/* I/O Context */
+SK_U8	Bit)	/* Bit to send */
+{
+	I2C_DATA_OUT(IoC);
+	if (Bit) {
+		I2C_DATA_HIGH(IoC);
+	}
+	else {
+		I2C_DATA_LOW(IoC);
+	}
+	SkDgWaitTime(IoC, NS2BCLK(T_DATA_IN_SETUP));
+	I2C_CLK_HIGH(IoC);
+	SkDgWaitTime(IoC, NS2BCLK(T_CLK_HIGH));
+	I2C_CLK_LOW(IoC);
+}	/* SkI2cSndBit*/
+
+
+/*
+ * Signal a start to the TWSI Bus.
+ *
+ * A start is signaled when data goes to low in a high clock cycle.
+ *
+ * Ends with Clock Low.
+ *
+ * Status: not tested
+ */
+void SkI2cStart(
+SK_IOC	IoC)	/* I/O Context */
+{
+	/* Init data and Clock to output lines */
+	/* Set Data high */
+	I2C_DATA_OUT(IoC);
+	I2C_DATA_HIGH(IoC);
+	/* Set Clock high */
+	I2C_CLK_HIGH(IoC);
+
+	SkDgWaitTime(IoC, NS2BCLK(T_START_SETUP));
+
+	/* Set Data Low */
+	I2C_DATA_LOW(IoC);
+
+	SkDgWaitTime(IoC, NS2BCLK(T_START_HOLD));
+
+	/* Clock low without Data to Input */
+	I2C_START_COND(IoC);
+
+	SkDgWaitTime(IoC, NS2BCLK(T_CLK_LOW));
+}	/* SkI2cStart */
+
+
+void SkI2cStop(
+SK_IOC	IoC)	/* I/O Context */
+{
+	/* Init data and Clock to output lines */
+	/* Set Data low */
+	I2C_DATA_OUT(IoC);
+	I2C_DATA_LOW(IoC);
+
+	SkDgWaitTime(IoC, NS2BCLK(T_CLK_2_DATA_OUT));
+
+	/* Set Clock high */
+	I2C_CLK_HIGH(IoC);
+
+	SkDgWaitTime(IoC, NS2BCLK(T_STOP_SETUP));
+
+	/*
+	 * Set Data High:	Do it by setting the Data Line to Input.
+	 *			Because of a pull up resistor the Data Line
+	 *			floods to high.
+	 */
+	I2C_DATA_IN(IoC);
+
+	/*
+	 *	When TWSI activity is stopped
+	 *	 o	DATA should be set to input and
+	 *	 o	CLOCK should be set to high!
+	 */
+	SkDgWaitTime(IoC, NS2BCLK(T_BUS_IDLE));
+}	/* SkI2cStop */
+
+
+/*
+ * Receive just one bit via the TWSI bus.
+ *
+ * Note:	Clock must be set to LOW before calling this function.
+ *
+ * Returns The received bit.
+ */
+int SkI2cRcvBit(
+SK_IOC	IoC)	/* I/O Context */
+{
+	int	Bit;
+	SK_U8	I2cSwCtrl;
+
+	/* Init data as input line */
+	I2C_DATA_IN(IoC);
+
+	SkDgWaitTime(IoC, NS2BCLK(T_CLK_2_DATA_OUT));
+
+	I2C_CLK_HIGH(IoC);
+
+	SkDgWaitTime(IoC, NS2BCLK(T_CLK_HIGH));
+
+	SK_I2C_GET_SW(IoC, &I2cSwCtrl);
+	
+	Bit = (I2cSwCtrl & I2C_DATA) ? 1 : 0;
+
+	I2C_CLK_LOW(IoC);
+	SkDgWaitTime(IoC, NS2BCLK(T_CLK_LOW-T_CLK_2_DATA_OUT));
+
+	return(Bit);
+}	/* SkI2cRcvBit */
+
+
+/*
+ * Receive an ACK.
+ *
+ * returns	0 If acknowledged
+ *		1 in case of an error
+ */
+int SkI2cRcvAck(
+SK_IOC	IoC)	/* I/O Context */
+{
+	/*
+	 * Received bit must be zero.
+	 */
+	return(SkI2cRcvBit(IoC) != 0);
+}	/* SkI2cRcvAck */
+
+
+/*
+ * Send an NACK.
+ */
+void SkI2cSndNAck(
+SK_IOC	IoC)	/* I/O Context */
+{
+	/*
+	 * Received bit must be zero.
+	 */
+	SkI2cSndBit(IoC, 1);
+}	/* SkI2cSndNAck */
+
+
+/*
+ * Send an ACK.
+ */
+void SkI2cSndAck(
+SK_IOC IoC)	/* I/O Context */
+{
+	/*
+	 * Received bit must be zero.
+	 */
+	SkI2cSndBit(IoC, 0);
+}	/* SkI2cSndAck */
+
+
+/*
+ * Send one byte to the TWSI device and wait for ACK.
+ *
+ * Return acknowleged status.
+ */
+int SkI2cSndByte(
+SK_IOC	IoC,	/* I/O Context */
+int		Byte)	/* byte to send */
+{
+	int	i;
+
+	for (i = 0; i < 8; i++) {
+		if (Byte & (1<<(7-i))) {
+			SkI2cSndBit(IoC, 1);
+		}
+		else {
+			SkI2cSndBit(IoC, 0);
+		}
+	}
+
+	return(SkI2cRcvAck(IoC));
+}	/* SkI2cSndByte */
+
+
+/*
+ * Receive one byte and ack it.
+ *
+ * Return byte.
+ */
+int SkI2cRcvByte(
+SK_IOC	IoC,	/* I/O Context */
+int		Last)	/* Last Byte Flag */
+{
+	int	i;
+	int	Byte = 0;
+
+	for (i = 0; i < 8; i++) {
+		Byte <<= 1;
+		Byte |= SkI2cRcvBit(IoC);
+	}
+
+	if (Last) {
+		SkI2cSndNAck(IoC);
+	}
+	else {
+		SkI2cSndAck(IoC);
+	}
+
+	return(Byte);
+}	/* SkI2cRcvByte */
+
+
+/*
+ * Start dialog and send device address
+ *
+ * Return 0 if acknowleged, 1 in case of an error
+ */
+int	SkI2cSndDev(
+SK_IOC	IoC,	/* I/O Context */
+int		Addr,	/* Device Address */
+int		Rw)		/* Read / Write Flag */
+{
+	SkI2cStart(IoC);
+	Rw = ~Rw;
+	Rw &= I2C_WRITE;
+	return(SkI2cSndByte(IoC, (Addr<<1) | Rw));
+}	/* SkI2cSndDev */
+
+#endif /* SK_DIAG */
+
+/*----------------- TWSI CTRL Register Functions ----------*/
+
+/*
+ * waits for a completion of an TWSI transfer
+ *
+ * returns	0:	success, transfer completes
+ *			1:	error,	 transfer does not complete, TWSI transfer
+ *						 killed, wait loop terminated.
+ */
+int	SkI2cWait(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
+int		Event)	/* complete event to wait for (I2C_READ or I2C_WRITE) */
+{
+	SK_U64	StartTime;
+	SK_U64	CurrentTime;
+	SK_U32	I2cCtrl;
+
+	StartTime = SkOsGetTime(pAC);
+	
+	do {
+		CurrentTime = SkOsGetTime(pAC);
+
+		if (CurrentTime - StartTime > SK_TICKS_PER_SEC / 8) {
+			
+			SK_I2C_STOP(IoC);
+#ifndef SK_DIAG
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E002, SKERR_I2C_E002MSG);
+#endif /* !SK_DIAG */
+			return(1);
+		}
+		
+		SK_I2C_GET_CTL(IoC, &I2cCtrl);
+
+#ifdef xYUKON_DBG
+		printf("StartTime=%lu, CurrentTime=%lu\n",
+			StartTime, CurrentTime);
+		if (kbhit()) {
+			return(1);
+		}
+#endif /* YUKON_DBG */
+	
+	} while ((I2cCtrl & I2C_FLAG) == (SK_U32)Event << 31);
+
+	return(0);
+}	/* SkI2cWait */
+
+
+/*
+ * waits for a completion of an TWSI transfer
+ *
+ * Returns
+ *	Nothing
+ */
+void SkI2cWaitIrq(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC)	/* I/O Context */
+{
+	SK_SENSOR	*pSen;
+	SK_U64		StartTime;
+	SK_U32		IrqSrc;
+	SK_U32		IsTwsiReadyBit;
+
+	if (CHIP_ID_YUKON_2(pAC)) {
+		IsTwsiReadyBit = Y2_IS_TWSI_RDY;
+	}
+	else {
+		IsTwsiReadyBit = IS_I2C_READY;
+	}
+
+	pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
+
+	if (pSen->SenState == SK_SEN_IDLE) {
+		return;
+	}
+
+	StartTime = SkOsGetTime(pAC);
+	
+	do {
+		if (SkOsGetTime(pAC) - StartTime > SK_TICKS_PER_SEC / 8) {
+			
+			SK_I2C_STOP(IoC);
+#ifndef SK_DIAG
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E016, SKERR_I2C_E016MSG);
+#endif /* !SK_DIAG */
+			return;
+		}
+		
+		SK_IN32(IoC, B0_ISRC, &IrqSrc);
+
+	} while ((IrqSrc & IsTwsiReadyBit) == 0);
+
+	pSen->SenState = SK_SEN_IDLE;
+	return;
+}	/* SkI2cWaitIrq */
+
+/*
+ * writes a single byte or 4 bytes into the TWSI device
+ *
+ * returns	0:	success
+ *			1:	error
+ */
+int SkI2cWrite(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+SK_U32	I2cData,	/* TWSI Data to write */
+int		I2cDev,		/* TWSI Device Address */
+int		I2cDevSize, /* TWSI Device Size (e.g. I2C_025K_DEV or I2C_2K_DEV) */
+int		I2cReg,		/* TWSI Device Register Address */
+int		I2cBurst)	/* TWSI Burst Flag */
+{
+	SK_OUT32(IoC, B2_I2C_DATA, I2cData);
+	
+	SK_I2C_CTL(IoC, I2C_WRITE, I2cDev, I2cDevSize, I2cReg, I2cBurst);
+	
+	return(SkI2cWait(pAC, IoC, I2C_WRITE));
+}	/* SkI2cWrite*/
+
+
+#ifdef	SK_DIAG
+/*
+ * reads a single byte or 4 bytes from the TWSI device
+ *
+ * returns	the word read
+ */
+SK_U32 SkI2cRead(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+int		I2cDev,		/* TWSI Device Address */
+int		I2cDevSize, /* TWSI Device Size (e.g. I2C_025K_DEV or I2C_2K_DEV) */
+int		I2cReg,		/* TWSI Device Register Address */
+int		I2cBurst)	/* TWSI Burst Flag */
+{
+	SK_U32	Data;
+
+	SK_OUT32(IoC, B2_I2C_DATA, 0);
+	SK_I2C_CTL(IoC, I2C_READ, I2cDev, I2cDevSize, I2cReg, I2cBurst);
+	
+	if (SkI2cWait(pAC, IoC, I2C_READ) != 0) {
+		w_print("%s\n", SKERR_I2C_E002MSG);
+	}
+	
+	SK_IN32(IoC, B2_I2C_DATA, &Data);
+	
+	return(Data);
+}	/* SkI2cRead */
+#endif /* SK_DIAG */
+
+
+/*
+ * read a sensor's value
+ *
+ * This function reads a sensor's value from the TWSI sensor chip. The sensor
+ * is defined by its index into the sensors database in the struct pAC points
+ * to.
+ * Returns
+ *		1 if the read is completed
+ *		0 if the read must be continued (TWSI Bus still allocated)
+ */
+int	SkI2cReadSensor(
+SK_AC		*pAC,	/* Adapter Context */
+SK_IOC		IoC,	/* I/O Context */
+SK_SENSOR	*pSen)	/* Sensor to be read */
+{
+    if (pSen->SenRead != NULL) {
+        return((*pSen->SenRead)(pAC, IoC, pSen));
+    }
+	else {
+        return(0); /* no success */
+	}
+}	/* SkI2cReadSensor */
+
+/*
+ * Do the Init state 0 initialization
+ */
+static int SkI2cInit0(
+SK_AC	*pAC)	/* Adapter Context */
+{
+	int	i;
+
+	/* Begin with first sensor */
+	pAC->I2c.CurrSens = 0;
+	
+	/* Begin with timeout control for state machine */
+	pAC->I2c.TimerMode = SK_TIMER_WATCH_SM;
+	
+	/* Set sensor number to zero */
+	pAC->I2c.MaxSens = 0;
+
+#ifndef SK_DIAG
+	/* Initialize Number of Dummy Reads */
+	pAC->I2c.DummyReads = SK_MAX_SENSORS;
+#endif
+
+	for (i = 0; i < SK_MAX_SENSORS; i++) {
+		pAC->I2c.SenTable[i].SenDesc = "unknown";
+		pAC->I2c.SenTable[i].SenType = SK_SEN_UNKNOWN;
+		pAC->I2c.SenTable[i].SenThreErrHigh = 0;
+		pAC->I2c.SenTable[i].SenThreErrLow = 0;
+		pAC->I2c.SenTable[i].SenThreWarnHigh = 0;
+		pAC->I2c.SenTable[i].SenThreWarnLow = 0;
+		pAC->I2c.SenTable[i].SenReg = LM80_FAN2_IN;
+		pAC->I2c.SenTable[i].SenInit = SK_SEN_DYN_INIT_NONE;
+		pAC->I2c.SenTable[i].SenValue = 0;
+		pAC->I2c.SenTable[i].SenErrFlag = SK_SEN_ERR_NOT_PRESENT;
+		pAC->I2c.SenTable[i].SenErrCts = 0;
+		pAC->I2c.SenTable[i].SenBegErrTS = 0;
+		pAC->I2c.SenTable[i].SenState = SK_SEN_IDLE;
+		pAC->I2c.SenTable[i].SenRead = NULL;
+		pAC->I2c.SenTable[i].SenDev = 0;
+	}
+
+	/* Now we are "INIT data"ed */
+	pAC->I2c.InitLevel = SK_INIT_DATA;
+	return(0);
+}	/* SkI2cInit0*/
+
+
+/*
+ * Do the init state 1 initialization
+ *
+ * initialize the following register of the LM80:
+ * Configuration register:
+ * - START, noINT, activeLOW, noINT#Clear, noRESET, noCI, noGPO#, noINIT
+ *
+ * Interrupt Mask Register 1:
+ * - all interrupts are Disabled (0xff)
+ *
+ * Interrupt Mask Register 2:
+ * - all interrupts are Disabled (0xff) Interrupt modi doesn't matter.
+ *
+ * Fan Divisor/RST_OUT register:
+ * - Divisors set to 1 (bits 00), all others 0s.
+ *
+ * OS# Configuration/Temperature resolution Register:
+ * - all 0s
+ *
+ */
+static int SkI2cInit1(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC)	/* I/O Context */
+{
+    int i;
+    SK_U8 I2cSwCtrl;
+	SK_GEPORT *pPrt;	/* GIni Port struct pointer */
+
+	if (pAC->I2c.InitLevel != SK_INIT_DATA) {
+		/* Re-init not needed in TWSI module */
+		return(0);
+	}
+
+	if (pAC->GIni.GIChipId == CHIP_ID_YUKON_EC) {
+		/* No sensors on Yukon-EC */
+		return(0);
+	}
+
+    /* Set the Direction of TWSI-Data Pin to IN */
+    SK_I2C_CLR_BIT(IoC, I2C_DATA_DIR | I2C_DATA);
+    /* Check for 32-Bit Yukon with Low at TWSI-Data Pin */
+	SK_I2C_GET_SW(IoC, &I2cSwCtrl);
+
+	if ((I2cSwCtrl & I2C_DATA) == 0) {
+		/* this is a 32-Bit board */
+		pAC->GIni.GIYukon32Bit = SK_TRUE;
+        return(0);
+    }
+
+	/* Check for 64 Bit Yukon without sensors */
+	if (SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_CFG, 0) != 0) {
+        return(0);
+    }
+
+	(void)SkI2cWrite(pAC, IoC, 0xffUL, LM80_ADDR, I2C_025K_DEV, LM80_IMSK_1, 0);
+	
+	(void)SkI2cWrite(pAC, IoC, 0xffUL, LM80_ADDR, I2C_025K_DEV, LM80_IMSK_2, 0);
+	
+	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_FAN_CTRL, 0);
+	
+	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_TEMP_CTRL, 0);
+	
+	(void)SkI2cWrite(pAC, IoC, (SK_U32)LM80_CFG_START, LM80_ADDR, I2C_025K_DEV,
+		LM80_CFG, 0);
+	
+	/*
+	 * MaxSens has to be updated here, because PhyType is not
+	 * set when performing Init Level 0
+	 */
+    pAC->I2c.MaxSens = 5;
+	
+	pPrt = &pAC->GIni.GP[0];
+	
+	if (pAC->GIni.GIGenesis) {
+		if (pPrt->PhyType == SK_PHY_BCOM) {
+			if (pAC->GIni.GIMacsFound == 1) {
+				pAC->I2c.MaxSens += 1;
+			}
+			else {
+				pAC->I2c.MaxSens += 3;
+			}
+		}
+	}
+	else {
+		pAC->I2c.MaxSens += 3;
+	}
+	
+	for (i = 0; i < pAC->I2c.MaxSens; i++) {
+		switch (i) {
+		case 0:
+			pAC->I2c.SenTable[i].SenDesc = "Temperature";
+			pAC->I2c.SenTable[i].SenType = SK_SEN_TEMP;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_TEMP_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_TEMP_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_TEMP_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_TEMP_LOW_ERR;
+			pAC->I2c.SenTable[i].SenReg = LM80_TEMP_IN;
+			break;
+		case 1:
+			pAC->I2c.SenTable[i].SenDesc = "Voltage PCI";
+			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PCI_5V_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PCI_5V_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PCI_5V_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PCI_5V_LOW_ERR;
+			pAC->I2c.SenTable[i].SenReg = LM80_VT0_IN;
+			break;
+		case 2:
+			pAC->I2c.SenTable[i].SenDesc = "Voltage PCI-IO";
+			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PCI_IO_5V_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PCI_IO_5V_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PCI_IO_3V3_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PCI_IO_3V3_LOW_ERR;
+			pAC->I2c.SenTable[i].SenReg = LM80_VT1_IN;
+			pAC->I2c.SenTable[i].SenInit = SK_SEN_DYN_INIT_PCI_IO;
+			break;
+		case 3:
+			pAC->I2c.SenTable[i].SenDesc = "Voltage ASIC";
+			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_VDD_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_VDD_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VDD_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VDD_LOW_ERR;
+			pAC->I2c.SenTable[i].SenReg = LM80_VT2_IN;
+			break;
+		case 4:
+			if (pAC->GIni.GIGenesis) {
+				if (pPrt->PhyType == SK_PHY_BCOM) {
+					pAC->I2c.SenTable[i].SenDesc = "Voltage PHY A PLL";
+					pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
+					pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
+				}
+				else {
+					pAC->I2c.SenTable[i].SenDesc = "Voltage PMA";
+					pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
+					pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
+				}
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage VAUX";
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_VAUX_3V3_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_VAUX_3V3_HIGH_WARN;
+				if (pAC->GIni.GIVauxAvail) {
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VAUX_3V3_LOW_WARN;
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VAUX_3V3_LOW_ERR;
+				}
+				else {
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VAUX_0V_WARN_ERR;
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VAUX_0V_WARN_ERR;
+				}
+			}
+			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+			pAC->I2c.SenTable[i].SenReg = LM80_VT3_IN;
+			break;
+		case 5:
+			if (pAC->GIni.GIGenesis) {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage Core 1V5";
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_CORE_1V5_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_CORE_1V5_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_CORE_1V5_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_CORE_1V5_LOW_ERR;
+			}
+			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+			pAC->I2c.SenTable[i].SenReg = LM80_VT4_IN;
+			break;
+		case 6:
+			if (pAC->GIni.GIGenesis) {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY B PLL";
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 3V3";
+			}
+			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
+			pAC->I2c.SenTable[i].SenReg = LM80_VT5_IN;
+			break;
+		case 7:
+			if (pAC->GIni.GIGenesis) {
+				pAC->I2c.SenTable[i].SenDesc = "Speed Fan";
+				pAC->I2c.SenTable[i].SenType = SK_SEN_FAN;
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_FAN_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_FAN_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_FAN_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_FAN_LOW_ERR;
+				pAC->I2c.SenTable[i].SenReg = LM80_FAN2_IN;
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
+				pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
+				pAC->I2c.SenTable[i].SenReg = LM80_VT6_IN;
+			}
+			break;
+		default:
+			SK_ERR_LOG(pAC, SK_ERRCL_INIT | SK_ERRCL_SW,
+				SKERR_I2C_E001, SKERR_I2C_E001MSG);
+			break;
+		}
+
+		pAC->I2c.SenTable[i].SenValue = 0;
+		pAC->I2c.SenTable[i].SenErrFlag = SK_SEN_ERR_OK;
+		pAC->I2c.SenTable[i].SenErrCts = 0;
+		pAC->I2c.SenTable[i].SenBegErrTS = 0;
+		pAC->I2c.SenTable[i].SenState = SK_SEN_IDLE;
+		pAC->I2c.SenTable[i].SenRead = SkLm80ReadSensor;
+		pAC->I2c.SenTable[i].SenDev = LM80_ADDR;
+	}
+
+#ifndef SK_DIAG
+	pAC->I2c.DummyReads = pAC->I2c.MaxSens;
+#endif /* !SK_DIAG */
+	
+	/* Clear TWSI IRQ */
+	SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
+	
+	/* Now we are I/O initialized */
+	pAC->I2c.InitLevel = SK_INIT_IO;
+	return(0);
+}	/* SkI2cInit1 */
+
+
+/*
+ * Init level 2: Start first sensor read.
+ */
+static int SkI2cInit2(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC)	/* I/O Context */
+{
+	int		ReadComplete;
+	SK_SENSOR	*pSen;
+
+	if (pAC->I2c.InitLevel != SK_INIT_IO) {
+		/* ReInit not needed in TWSI module */
+		/* Init0 and Init2 not permitted */
+		return(0);
+	}
+
+	pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
+	ReadComplete = SkI2cReadSensor(pAC, IoC, pSen);
+
+	if (ReadComplete) {
+		SK_ERR_LOG(pAC, SK_ERRCL_INIT, SKERR_I2C_E008, SKERR_I2C_E008MSG);
+	}
+
+	/* Now we are correctly initialized */
+	pAC->I2c.InitLevel = SK_INIT_RUN;
+
+	return(0);
+}	/* SkI2cInit2*/
+
+
+/*
+ * Initialize TWSI devices
+ *
+ * Get the first voltage value and discard it.
+ * Go into temperature read mode. A default pointer is not set.
+ *
+ * The things to be done depend on the init level in the parameter list:
+ * Level 0:
+ *	Initialize only the data structures. Do NOT access hardware.
+ * Level 1:
+ *	Initialize hardware through SK_IN / SK_OUT commands. Do NOT use interrupts.
+ * Level 2:
+ *	Everything is possible. Interrupts may be used from now on.
+ *
+ * return:
+ *	0 = success
+ *	other = error.
+ */
+int	SkI2cInit(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context needed in levels 1 and 2 */
+int		Level)	/* Init Level */
+{
+
+	switch (Level) {
+	case SK_INIT_DATA:
+		return(SkI2cInit0(pAC));
+	case SK_INIT_IO:
+		return(SkI2cInit1(pAC, IoC));
+	case SK_INIT_RUN:
+		return(SkI2cInit2(pAC, IoC));
+	default:
+		break;
+	}
+
+	return(0);
+}	/* SkI2cInit */
+
+
+#ifndef SK_DIAG
+
+/*
+ * Interrupt service function for the TWSI Interface
+ *
+ * Clears the Interrupt source
+ *
+ * Reads the register and check it for sending a trap.
+ *
+ * Starts the timer if necessary.
+ */
+void SkI2cIsr(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC)	/* I/O Context */
+{
+	SK_EVPARA	Para;
+
+	/* Clear TWSI IRQ */
+	SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
+
+	Para.Para64 = 0;
+	SkEventQueue(pAC, SKGE_I2C, SK_I2CEV_IRQ, Para);
+}	/* SkI2cIsr */
+
+
+/*
+ * Check this sensors Value against the threshold and send events.
+ */
+static void SkI2cCheckSensor(
+SK_AC		*pAC,	/* Adapter Context */
+SK_SENSOR	*pSen)
+{
+	SK_EVPARA	ParaLocal;
+	SK_BOOL		TooHigh;	/* Is sensor too high? */
+	SK_BOOL		TooLow;		/* Is sensor too low? */
+	SK_U64		CurrTime;	/* Current Time */
+	SK_BOOL		DoTrapSend;	/* We need to send a trap */
+	SK_BOOL		DoErrLog;	/* We need to log the error */
+	SK_BOOL		IsError;	/* We need to log the error */
+
+	/* Check Dummy Reads first */
+	if (pAC->I2c.DummyReads > 0) {
+		pAC->I2c.DummyReads--;
+		return;
+	}
+
+	/* Get the current time */
+	CurrTime = SkOsGetTime(pAC);
+
+	/* Set para to the most useful setting: The current sensor. */
+	ParaLocal.Para64 = (SK_U64)pAC->I2c.CurrSens;
+
+	/* Check the Value against the thresholds. First: Error Thresholds */
+	TooHigh = (pSen->SenValue > pSen->SenThreErrHigh);
+	TooLow = (pSen->SenValue < pSen->SenThreErrLow);
+		
+	IsError = SK_FALSE;
+	if (TooHigh || TooLow) {
+		/* Error condition is satisfied */
+		DoTrapSend = SK_TRUE;
+		DoErrLog = SK_TRUE;
+
+		/* Now error condition is satisfied */
+		IsError = SK_TRUE;
+
+		if (pSen->SenErrFlag == SK_SEN_ERR_ERR) {
+			/* This state is the former one */
+
+			/* So check first whether we have to send a trap */
+			if (pSen->SenLastErrTrapTS + SK_SEN_ERR_TR_HOLD >
+			    CurrTime) {
+				/*
+				 * Do NOT send the Trap. The hold back time
+				 * has to run out first.
+				 */
+				DoTrapSend = SK_FALSE;
+			}
+
+			/* Check now whether we have to log an Error */
+			if (pSen->SenLastErrLogTS + SK_SEN_ERR_LOG_HOLD >
+			    CurrTime) {
+				/*
+				 * Do NOT log the error. The hold back time
+				 * has to run out first.
+				 */
+				DoErrLog = SK_FALSE;
+			}
+		}
+		else {
+			/* We came from a different state -> Set Begin Time Stamp */
+			pSen->SenBegErrTS = CurrTime;
+			pSen->SenErrFlag = SK_SEN_ERR_ERR;
+		}
+
+		if (DoTrapSend) {
+			/* Set current Time */
+			pSen->SenLastErrTrapTS = CurrTime;
+			pSen->SenErrCts++;
+
+			/* Queue PNMI Event */
+			SkEventQueue(pAC, SKGE_PNMI, (TooHigh ?
+				SK_PNMI_EVT_SEN_ERR_UPP :
+				SK_PNMI_EVT_SEN_ERR_LOW),
+				ParaLocal);
+		}
+
+		if (DoErrLog) {
+			/* Set current Time */
+			pSen->SenLastErrLogTS = CurrTime;
+
+			if (pSen->SenType == SK_SEN_TEMP) {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E011, SKERR_I2C_E011MSG);
+			}
+			else if (pSen->SenType == SK_SEN_VOLT) {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E012, SKERR_I2C_E012MSG);
+			}
+			else {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E015, SKERR_I2C_E015MSG);
+			}
+		}
+	}
+
+	/* Check the Value against the thresholds */
+	/* 2nd: Warning thresholds */
+	TooHigh = (pSen->SenValue > pSen->SenThreWarnHigh);
+	TooLow = (pSen->SenValue < pSen->SenThreWarnLow);
+		
+	if (!IsError && (TooHigh || TooLow)) {
+		/* Error condition is satisfied */
+		DoTrapSend = SK_TRUE;
+		DoErrLog = SK_TRUE;
+
+		if (pSen->SenErrFlag == SK_SEN_ERR_WARN) {
+			/* This state is the former one */
+
+			/* So check first whether we have to send a trap */
+			if (pSen->SenLastWarnTrapTS + SK_SEN_WARN_TR_HOLD > CurrTime) {
+				/*
+				 * Do NOT send the Trap. The hold back time
+				 * has to run out first.
+				 */
+				DoTrapSend = SK_FALSE;
+			}
+
+			/* Check now whether we have to log an Error */
+			if (pSen->SenLastWarnLogTS + SK_SEN_WARN_LOG_HOLD > CurrTime) {
+				/*
+				 * Do NOT log the error. The hold back time
+				 * has to run out first.
+				 */
+				DoErrLog = SK_FALSE;
+			}
+		}
+		else {
+			/* We came from a different state -> Set Begin Time Stamp */
+			pSen->SenBegWarnTS = CurrTime;
+			pSen->SenErrFlag = SK_SEN_ERR_WARN;
+		}
+
+		if (DoTrapSend) {
+			/* Set current Time */
+			pSen->SenLastWarnTrapTS = CurrTime;
+			pSen->SenWarnCts++;
+
+			/* Queue PNMI Event */
+			SkEventQueue(pAC, SKGE_PNMI, (TooHigh ?
+				SK_PNMI_EVT_SEN_WAR_UPP :
+				SK_PNMI_EVT_SEN_WAR_LOW),
+				ParaLocal);
+		}
+
+		if (DoErrLog) {
+			/* Set current Time */
+			pSen->SenLastWarnLogTS = CurrTime;
+
+			if (pSen->SenType == SK_SEN_TEMP) {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E009, SKERR_I2C_E009MSG);
+			}
+			else if (pSen->SenType == SK_SEN_VOLT) {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E010, SKERR_I2C_E010MSG);
+			}
+			else {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E014, SKERR_I2C_E014MSG);
+			}
+		}
+	}
+
+	/* Check for NO error at all */
+	if (!IsError && !TooHigh && !TooLow) {
+		/* Set o.k. Status if no error and no warning condition */
+		pSen->SenErrFlag = SK_SEN_ERR_OK;
+	}
+
+	/* End of check against the thresholds */
+
+	/* Bug fix AF: 16.Aug.2001: Correct the init base
+	 * of LM80 sensor.
+	 */
+	if (pSen->SenInit == SK_SEN_DYN_INIT_PCI_IO) {
+
+        pSen->SenInit = SK_SEN_DYN_INIT_NONE;
+
+		if (pSen->SenValue > SK_SEN_PCI_IO_RANGE_LIMITER) {
+			/* 5V PCI-IO Voltage */
+			pSen->SenThreWarnLow = SK_SEN_PCI_IO_5V_LOW_WARN;
+			pSen->SenThreErrLow = SK_SEN_PCI_IO_5V_LOW_ERR;
+		}
+		else {
+			/* 3.3V PCI-IO Voltage */
+			pSen->SenThreWarnHigh = SK_SEN_PCI_IO_3V3_HIGH_WARN;
+			pSen->SenThreErrHigh = SK_SEN_PCI_IO_3V3_HIGH_ERR;
+		}
+	}
+	
+#ifdef TEST_ONLY
+    /* Dynamic thresholds also for VAUX of LM80 sensor */
+	if (pSen->SenInit == SK_SEN_DYN_INIT_VAUX) {
+
+        pSen->SenInit = SK_SEN_DYN_INIT_NONE;
+
+		/* 3.3V VAUX Voltage */
+		if (pSen->SenValue > SK_SEN_VAUX_RANGE_LIMITER) {
+			pSen->SenThreWarnLow = SK_SEN_VAUX_3V3_LOW_WARN;
+			pSen->SenThreErrLow = SK_SEN_VAUX_3V3_LOW_ERR;
+		}
+		/* 0V VAUX Voltage */
+		else {
+			pSen->SenThreWarnHigh = SK_SEN_VAUX_0V_WARN_ERR;
+			pSen->SenThreErrHigh = SK_SEN_VAUX_0V_WARN_ERR;
+		}
+	}
+
+	/*
+	 * Check initialization state:
+	 * The VIO Thresholds need adaption
+	 */
+	if (!pSen->SenInit && pSen->SenReg == LM80_VT1_IN &&
+	     pSen->SenValue > SK_SEN_WARNLOW2C &&
+	     pSen->SenValue < SK_SEN_WARNHIGH2) {
+		pSen->SenThreErrLow = SK_SEN_ERRLOW2C;
+		pSen->SenThreWarnLow = SK_SEN_WARNLOW2C;
+		pSen->SenInit = SK_TRUE;
+	}
+
+	if (!pSen->SenInit && pSen->SenReg == LM80_VT1_IN &&
+	     pSen->SenValue > SK_SEN_WARNLOW2 &&
+	     pSen->SenValue < SK_SEN_WARNHIGH2C) {
+		pSen->SenThreErrHigh = SK_SEN_ERRHIGH2C;
+		pSen->SenThreWarnHigh = SK_SEN_WARNHIGH2C;
+		pSen->SenInit = SK_TRUE;
+	}
+#endif
+
+	if (pSen->SenInit != SK_SEN_DYN_INIT_NONE) {
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E013, SKERR_I2C_E013MSG);
+	}
+}	/* SkI2cCheckSensor */
+
+
+/*
+ * The only Event to be served is the timeout event
+ *
+ */
+int	SkI2cEvent(
+SK_AC		*pAC,	/* Adapter Context */
+SK_IOC		IoC,	/* I/O Context */
+SK_U32		Event,	/* Module specific Event */
+SK_EVPARA	Para)	/* Event specific Parameter */
+{
+	int			ReadComplete;
+	SK_SENSOR	*pSen;
+	SK_U32		Time;
+	SK_EVPARA	ParaLocal;
+	int			i;
+
+	/* New case: no sensors */
+	if (pAC->I2c.MaxSens == 0) {
+		return(0);
+	}
+
+	switch (Event) {
+	case SK_I2CEV_IRQ:
+		pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
+		ReadComplete = SkI2cReadSensor(pAC, IoC, pSen);
+
+		if (ReadComplete) {
+			/* Check sensor against defined thresholds */
+			SkI2cCheckSensor(pAC, pSen);
+
+			/* Increment Current sensor and set appropriate Timeout */
+			pAC->I2c.CurrSens++;
+			if (pAC->I2c.CurrSens >= pAC->I2c.MaxSens) {
+				pAC->I2c.CurrSens = 0;
+				Time = SK_I2C_TIM_LONG;
+			}
+			else {
+				Time = SK_I2C_TIM_SHORT;
+			}
+
+			/* Start Timer */
+			ParaLocal.Para64 = (SK_U64)0;
+
+			pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
+			
+			SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
+				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
+		}
+        else {
+			/* Start Timer */
+			ParaLocal.Para64 = (SK_U64)0;
+
+			pAC->I2c.TimerMode = SK_TIMER_WATCH_SM;
+
+            SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, SK_I2C_TIM_WATCH,
+				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
+		}
+		break;
+	case SK_I2CEV_TIM:
+		if (pAC->I2c.TimerMode == SK_TIMER_NEW_GAUGING) {
+
+			ParaLocal.Para64 = (SK_U64)0;
+			SkTimerStop(pAC, IoC, &pAC->I2c.SenTimer);
+
+			pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
+			ReadComplete = SkI2cReadSensor(pAC, IoC, pSen);
+
+			if (ReadComplete) {
+				/* Check sensor against defined thresholds */
+				SkI2cCheckSensor(pAC, pSen);
+
+				/* Increment Current sensor and set appropriate Timeout */
+				pAC->I2c.CurrSens++;
+				if (pAC->I2c.CurrSens == pAC->I2c.MaxSens) {
+					pAC->I2c.CurrSens = 0;
+					Time = SK_I2C_TIM_LONG;
+				}
+				else {
+					Time = SK_I2C_TIM_SHORT;
+				}
+
+				/* Start Timer */
+				ParaLocal.Para64 = (SK_U64)0;
+
+				pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
+
+				SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
+					SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
+			}
+		}
+		else {
+			pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
+			pSen->SenErrFlag = SK_SEN_ERR_FAULTY;
+			SK_I2C_STOP(IoC);
+
+			/* Increment Current sensor and set appropriate Timeout */
+			pAC->I2c.CurrSens++;
+			if (pAC->I2c.CurrSens == pAC->I2c.MaxSens) {
+				pAC->I2c.CurrSens = 0;
+				Time = SK_I2C_TIM_LONG;
+			}
+			else {
+				Time = SK_I2C_TIM_SHORT;
+			}
+
+			/* Start Timer */
+			ParaLocal.Para64 = (SK_U64)0;
+
+			pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
+
+			SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
+				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
+		}
+		break;
+	case SK_I2CEV_CLEAR:
+		for (i = 0; i < SK_MAX_SENSORS; i++) {
+			pAC->I2c.SenTable[i].SenErrFlag = SK_SEN_ERR_OK;
+			pAC->I2c.SenTable[i].SenErrCts = 0;
+			pAC->I2c.SenTable[i].SenWarnCts = 0;
+			pAC->I2c.SenTable[i].SenBegErrTS = 0;
+			pAC->I2c.SenTable[i].SenBegWarnTS = 0;
+			pAC->I2c.SenTable[i].SenLastErrTrapTS = (SK_U64)0;
+			pAC->I2c.SenTable[i].SenLastErrLogTS = (SK_U64)0;
+			pAC->I2c.SenTable[i].SenLastWarnTrapTS = (SK_U64)0;
+			pAC->I2c.SenTable[i].SenLastWarnLogTS = (SK_U64)0;
+		}
+		break;
+	default:
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E006, SKERR_I2C_E006MSG);
+	}
+
+	return(0);
+}	/* SkI2cEvent*/
+
+#endif /* !SK_DIAG */
Index: linux-2.6.8/drivers/net/sk98lin/skvpd.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skvpd.c
+++ linux-2.6.8/drivers/net/sk98lin/skvpd.c
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skvpd.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.37 $
- * Date:	$Date: 2003/01/13 10:42:45 $
+ * Version:	$Revision: 2.3 $
+ * Date:	$Date: 2004/02/27 13:24:38 $
  * Purpose:	Shared software to read and write VPD data
  *
  ******************************************************************************/
 
@@ -24,9 +24,9 @@
 /*
 	Please refer skvpd.txt for infomation how to include this module
  */
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skvpd.c,v 1.37 2003/01/13 10:42:45 rschmidt Exp $ (C) SK";
+	"@(#)$Id: skvpd.c,v 2.3 2004/02/27 13:24:38 malthoff Exp $ (C) SK";
 
 #include "h/skdrv1st.h"
 #include "h/sktypes.h"
 #include "h/skdebug.h"
@@ -373,9 +373,10 @@ int		dir)	/* transfer direction may be V
 
 	return(Rtv);
 }
 
-#ifdef SKDIAG
+#if defined (SKDIAG) || defined (SK_ASF)
+//#ifdef SKDIAG
 
 /*
  *	Read 'len' bytes of VPD data, starting at 'addr'.
  *
@@ -406,18 +407,26 @@ int		len)	/* number of bytes to write */
 	return(VpdTransferBlock(pAC, IoC, buf, addr, len, VPD_WRITE));
 }
 #endif	/* SKDIAG */
 
-/*
- * (re)initialize the VPD buffer
+/******************************************************************************
  *
- * Reads the VPD data from the EEPROM into the VPD buffer.
- * Get the remaining read only and read / write space.
+ *	VpdInit() - (re)initialize the VPD buffer
  *
- * return	0:	success
- *		1:	fatal VPD error
+ * Description:
+ *	Reads the VPD data from the EEPROM into the VPD buffer.
+ *	Get the remaining read only and read / write space.
+ *
+ * Note:
+ *	This is a local function and should be used locally only.
+ *	However, the ASF module needs to use this function also.
+ *	Therfore it has been published.
+ *
+ * Returns:
+ *	0:	success
+ *	1:	fatal VPD error
  */
-static int VpdInit(
+int VpdInit(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	IoC)	/* IO Context */
 {
 	SK_VPD_PARA *r, rp;	/* RW or RV */
@@ -467,19 +476,8 @@ SK_IOC	IoC)	/* IO Context */
 	}
 	
 	pAC->vpd.vpd_size = vpd_size;
 
-	/* Asus K8V Se Deluxe bugfix. Correct VPD content */
-	/* MBo April 2004 */
-	if (((unsigned char)pAC->vpd.vpd_buf[0x3f] == 0x38) &&
-	    ((unsigned char)pAC->vpd.vpd_buf[0x40] == 0x3c) &&
-	    ((unsigned char)pAC->vpd.vpd_buf[0x41] == 0x45)) {
-		printk("sk98lin: Asus mainboard with buggy VPD? "
-				"Correcting data.\n");
-		pAC->vpd.vpd_buf[0x40] = 0x38;
-	}
-
-
 	/* find the end tag of the RO area */
 	if (!(r = vpd_find_para(pAC, VPD_RV, &rp))) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
 			("Encoding Error: RV Tag not found\n"));
@@ -555,9 +553,9 @@ SK_VPD_PARA *p)		/* parameter descriptio
 	/* check mandatory resource type ID string (Product Name) */
 	if (*v != (char)RES_ID) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
 			("Error: 0x%x missing\n", RES_ID));
-		return NULL;
+		return(0);
 	}
 
 	if (strcmp(key, VPD_NAME) == 0) {
 		p->p_len = VPD_GET_RES_LEN(v);
@@ -599,9 +597,9 @@ SK_VPD_PARA *p)		/* parameter descriptio
 		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
 			("Key/Len Encoding error\n"));
 	}
 #endif /* DEBUG */
-	return NULL;
+	return(0);
 }
 
 /*
  *	Move 'n' bytes. Begin with the last byte if 'n' is > 0,
@@ -750,9 +748,9 @@ int		op)			/* operation to do: ADD_KEY o
 	
 	vpd_size = pAC->vpd.vpd_size;
 
 	rtv = 0;
-	ip = NULL;
+	ip = 0;
 	if (type == VPD_RW_KEY) {
 		/* end tag is "RW" */
 		free = pAC->vpd.v.vpd_free_rw;
 		etp = pAC->vpd.vpd_buf + (vpd_size - free - 1 - 3);
Index: linux-2.6.8/drivers/net/sk98lin/skxmac2.c
===================================================================
--- linux-2.6.8.orig/drivers/net/sk98lin/skxmac2.c
+++ linux-2.6.8/drivers/net/sk98lin/skxmac2.c
@@ -1,24 +1,23 @@
 /******************************************************************************
  *
  * Name:	skxmac2.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.102 $
- * Date:	$Date: 2003/10/02 16:53:58 $
+ * Version:	$Revision: 2.19 $
+ * Date:	$Date: 2004/06/03 15:04:19 $
  * Purpose:	Contains functions to initialize the MACs and PHYs
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect.
- *	(C)Copyright 2002-2003 Marvell.
+ *	(C)Copyright 2002-2004 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
 
@@ -36,9 +35,9 @@ typedef struct s_PhyHack {
 /* local variables ************************************************************/
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skxmac2.c,v 1.102 2003/10/02 16:53:58 rschmidt Exp $ (C) Marvell.";
+	"@(#) $Id: skxmac2.c,v 2.19 2004/06/03 15:04:19 malthoff Exp $ (C) Marvell.";
 #endif
 
 #ifdef GENESIS
 BCOM_HACK BcomRegA1Hack[] = {
@@ -82,9 +81,9 @@ static int	SkXmAutoNegDoneNat (SK_AC*, S
  *
  * Returns:
  *	nothing
  */
-void SkXmPhyRead(
+int SkXmPhyRead(
 SK_AC	*pAC,			/* Adapter Context */
 SK_IOC	IoC,			/* I/O Context */
 int		Port,			/* Port Index (MAC_1 + n) */
 int		PhyReg,			/* Register Address (Offset) */
@@ -93,15 +92,15 @@ SK_U16	SK_FAR *pVal)	/* Pointer to Value
 	SK_U16		Mmu;
 	SK_GEPORT	*pPrt;
 
 	pPrt = &pAC->GIni.GP[Port];
-	
+
 	/* write the PHY register's address */
 	XM_OUT16(IoC, Port, XM_PHY_ADDR, PhyReg | pPrt->PhyAddr);
-	
+
 	/* get the PHY register's value */
 	XM_IN16(IoC, Port, XM_PHY_DATA, pVal);
-	
+
 	if (pPrt->PhyType != SK_PHY_XMAC) {
 		do {
 			XM_IN16(IoC, Port, XM_MMU_CMD, &Mmu);
 			/* wait until 'Ready' is set */
@@ -109,8 +108,10 @@ SK_U16	SK_FAR *pVal)	/* Pointer to Value
 
 		/* get the PHY register's value */
 		XM_IN16(IoC, Port, XM_PHY_DATA, pVal);
 	}
+
+	return(0);
 }	/* SkXmPhyRead */
 
 
 /******************************************************************************
@@ -121,9 +122,9 @@ SK_U16	SK_FAR *pVal)	/* Pointer to Value
  *
  * Returns:
  *	nothing
  */
-void SkXmPhyWrite(
+int SkXmPhyWrite(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		PhyReg,		/* Register Address (Offset) */
@@ -132,28 +133,30 @@ SK_U16	Val)		/* Value */
 	SK_U16		Mmu;
 	SK_GEPORT	*pPrt;
 
 	pPrt = &pAC->GIni.GP[Port];
-	
+
 	if (pPrt->PhyType != SK_PHY_XMAC) {
 		do {
 			XM_IN16(IoC, Port, XM_MMU_CMD, &Mmu);
 			/* wait until 'Busy' is cleared */
 		} while ((Mmu & XM_MMU_PHY_BUSY) != 0);
 	}
-	
+
 	/* write the PHY register's address */
 	XM_OUT16(IoC, Port, XM_PHY_ADDR, PhyReg | pPrt->PhyAddr);
-	
+
 	/* write the PHY register's value */
 	XM_OUT16(IoC, Port, XM_PHY_DATA, Val);
-	
+
 	if (pPrt->PhyType != SK_PHY_XMAC) {
 		do {
 			XM_IN16(IoC, Port, XM_MMU_CMD, &Mmu);
 			/* wait until 'Busy' is cleared */
 		} while ((Mmu & XM_MMU_PHY_BUSY) != 0);
 	}
+
+	return(0);
 }	/* SkXmPhyWrite */
 #endif /* GENESIS */
 
 
@@ -166,63 +169,97 @@ SK_U16	Val)		/* Value */
  *
  * Returns:
  *	nothing
  */
-void SkGmPhyRead(
+int SkGmPhyRead(
 SK_AC	*pAC,			/* Adapter Context */
 SK_IOC	IoC,			/* I/O Context */
 int		Port,			/* Port Index (MAC_1 + n) */
 int		PhyReg,			/* Register Address (Offset) */
 SK_U16	SK_FAR *pVal)	/* Pointer to Value */
 {
 	SK_U16	Ctrl;
 	SK_GEPORT	*pPrt;
+	SK_U32	StartTime;
+	SK_U32	CurrTime;
+	SK_U32	Delta;
 #ifdef VCPU
 	u_long SimCyle;
 	u_long SimLowTime;
-	
+
 	VCPUgetTime(&SimCyle, &SimLowTime);
 	VCPUprintf(0, "SkGmPhyRead(%u), SimCyle=%u, SimLowTime=%u\n",
 		PhyReg, SimCyle, SimLowTime);
 #endif /* VCPU */
-	
+
 	pPrt = &pAC->GIni.GP[Port];
-	
+
 	/* set PHY-Register offset and 'Read' OpCode (= 1) */
 	*pVal = (SK_U16)(GM_SMI_CT_PHY_AD(pPrt->PhyAddr) |
 		GM_SMI_CT_REG_AD(PhyReg) | GM_SMI_CT_OP_RD);
 
 	GM_OUT16(IoC, Port, GM_SMI_CTRL, *pVal);
 
-	GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
-	
+#ifdef DEBUG
 	/* additional check for MDC/MDIO activity */
-	if ((Ctrl & GM_SMI_CT_BUSY) == 0) {
+	GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
+
+	if ((Ctrl & GM_SMI_CT_OP_RD) == 0) {
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
+			("PHY read impossible on Port %d (Ctrl=0x%04x)\n", Port, Ctrl));
+
 		*pVal = 0;
-		return;
+		return(1);
 	}
+#endif /* DEBUG */
 
 	*pVal |= GM_SMI_CT_BUSY;
-	
-	do {
+
+	SK_IN32(IoC, GMAC_TI_ST_VAL, &StartTime);
+
+	do {	/* wait until 'Busy' is cleared and 'ReadValid' is set */
 #ifdef VCPU
 		VCPUwaitTime(1000);
 #endif /* VCPU */
 
+		SK_IN32(IoC, GMAC_TI_ST_VAL, &CurrTime);
+
+		if (CurrTime >= StartTime) {
+			Delta = CurrTime - StartTime;
+		}
+		else {
+			Delta = CurrTime + ~StartTime + 1;
+		}
+
+		if (Delta > SK_PHY_ACC_TO) {
+
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
+				("PHY read timeout on Port %d (Ctrl=0x%04x)\n", Port, Ctrl));
+			return(1);
+		}
+
 		GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
 
-	/* wait until 'ReadValid' is set */
-	} while (Ctrl == *pVal);
-	
-	/* get the PHY register's value */
+		/* Error on reading SMI Control Register */
+		if (Ctrl == 0xffff) {
+			return(1);
+		}
+
+	} while ((Ctrl ^ *pVal) != (GM_SMI_CT_RD_VAL | GM_SMI_CT_BUSY));
+
 	GM_IN16(IoC, Port, GM_SMI_DATA, pVal);
 
+	/* dummy read after GM_IN16() */
+	SK_IN32(IoC, GMAC_TI_ST_VAL, &CurrTime);
+
 #ifdef VCPU
 	VCPUgetTime(&SimCyle, &SimLowTime);
 	VCPUprintf(0, "VCPUgetTime(), SimCyle=%u, SimLowTime=%u\n",
 		SimCyle, SimLowTime);
 #endif /* VCPU */
 
+	return(0);
 }	/* SkGmPhyRead */
 
 
 /******************************************************************************
@@ -233,65 +270,95 @@ SK_U16	SK_FAR *pVal)	/* Pointer to Value
  *
  * Returns:
  *	nothing
  */
-void SkGmPhyWrite(
+int SkGmPhyWrite(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		PhyReg,		/* Register Address (Offset) */
 SK_U16	Val)		/* Value */
 {
 	SK_U16	Ctrl;
 	SK_GEPORT	*pPrt;
+	SK_U32	StartTime;
+	SK_U32	CurrTime;
+	SK_U32	Delta;
 #ifdef VCPU
-	SK_U32	DWord;
 	u_long	SimCyle;
 	u_long	SimLowTime;
-	
+
 	VCPUgetTime(&SimCyle, &SimLowTime);
 	VCPUprintf(0, "SkGmPhyWrite(Reg=%u, Val=0x%04x), SimCyle=%u, SimLowTime=%u\n",
 		PhyReg, Val, SimCyle, SimLowTime);
 #endif /* VCPU */
-	
+
 	pPrt = &pAC->GIni.GP[Port];
-	
+
 	/* write the PHY register's value */
 	GM_OUT16(IoC, Port, GM_SMI_DATA, Val);
-	
-	/* set PHY-Register offset and 'Write' OpCode (= 0) */
-	Val = GM_SMI_CT_PHY_AD(pPrt->PhyAddr) | GM_SMI_CT_REG_AD(PhyReg);
 
-	GM_OUT16(IoC, Port, GM_SMI_CTRL, Val);
-
-	GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
-	
+#ifdef DEBUG
 	/* additional check for MDC/MDIO activity */
-	if ((Ctrl & GM_SMI_CT_BUSY) == 0) {
-		return;
+	GM_IN16(IoC, Port, GM_SMI_DATA, &Ctrl);
+
+	if (Ctrl != Val) {
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
+			("PHY write impossible on Port %d (Val=0x%04x)\n", Port, Ctrl));
+
+		return(1);
 	}
-	
-	Val |= GM_SMI_CT_BUSY;
+#endif /* DEBUG */
 
-	do {
-#ifdef VCPU
-		/* read Timer value */
-		SK_IN32(IoC, B2_TI_VAL, &DWord);
+	/* set PHY-Register offset and 'Write' OpCode (= 0) */
+	Ctrl = (SK_U16)(GM_SMI_CT_PHY_AD(pPrt->PhyAddr) |
+		GM_SMI_CT_REG_AD(PhyReg));
 
+	GM_OUT16(IoC, Port, GM_SMI_CTRL, Ctrl);
+
+	SK_IN32(IoC, GMAC_TI_ST_VAL, &StartTime);
+
+	do {	/* wait until 'Busy' is cleared */
+#ifdef VCPU
 		VCPUwaitTime(1000);
 #endif /* VCPU */
 
+		SK_IN32(IoC, GMAC_TI_ST_VAL, &CurrTime);
+
+		if (CurrTime >= StartTime) {
+			Delta = CurrTime - StartTime;
+		}
+		else {
+			Delta = CurrTime + ~StartTime + 1;
+		}
+
+		if (Delta > SK_PHY_ACC_TO) {
+
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
+				("PHY write timeout on Port %d (Ctrl=0x%04x)\n", Port, Ctrl));
+			return(1);
+		}
+
 		GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
 
-	/* wait until 'Busy' is cleared */
-	} while (Ctrl == Val);
+		/* Error on reading SMI Control Register */
+		if (Ctrl == 0xffff) {
+			return(1);
+		}
 	
+	} while ((Ctrl & GM_SMI_CT_BUSY) != 0);
+
+	/* dummy read after GM_IN16() */
+	SK_IN32(IoC, GMAC_TI_ST_VAL, &CurrTime);
+
 #ifdef VCPU
 	VCPUgetTime(&SimCyle, &SimLowTime);
 	VCPUprintf(0, "VCPUgetTime(), SimCyle=%u, SimLowTime=%u\n",
 		SimCyle, SimLowTime);
 #endif /* VCPU */
 
+	return(0);
 }	/* SkGmPhyWrite */
 #endif /* YUKON */
 
 
@@ -311,18 +378,10 @@ SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		PhyReg,		/* Register Address (Offset) */
 SK_U16	*pVal)		/* Pointer to Value */
 {
-	void (*r_func)(SK_AC *pAC, SK_IOC IoC, int Port, int Reg, SK_U16 *pVal);
 
-	if (pAC->GIni.GIGenesis) {
-		r_func = SkXmPhyRead;
-	}
-	else {
-		r_func = SkGmPhyRead;
-	}
-	
-	r_func(pAC, IoC, Port, PhyReg, pVal);
+	pAC->GIni.GIFunc.pFnMacPhyRead(pAC, IoC, Port, PhyReg, pVal);
 }	/* SkGePhyRead */
 
 
 /******************************************************************************
@@ -340,18 +399,10 @@ SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		PhyReg,		/* Register Address (Offset) */
 SK_U16	Val)		/* Value */
 {
-	void (*w_func)(SK_AC *pAC, SK_IOC IoC, int Port, int Reg, SK_U16 Val);
 
-	if (pAC->GIni.GIGenesis) {
-		w_func = SkXmPhyWrite;
-	}
-	else {
-		w_func = SkGmPhyWrite;
-	}
-	
-	w_func(pAC, IoC, Port, PhyReg, Val);
+	pAC->GIni.GIFunc.pFnMacPhyWrite(pAC, IoC, Port, PhyReg, Val);
 }	/* SkGePhyWrite */
 #endif /* SK_DIAG */
 
 
@@ -360,29 +411,29 @@ SK_U16	Val)		/* Value */
  *	SkMacPromiscMode() - Enable / Disable Promiscuous Mode
  *
  * Description:
  *   enables / disables promiscuous mode by setting Mode Register (XMAC) or
- *   Receive Control Register (GMAC) dep. on board type   	
+ *   Receive Control Register (GMAC) dep. on board type
  *
  * Returns:
  *	nothing
  */
 void SkMacPromiscMode(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port,	/* Port Index (MAC_1 + n) */
 SK_BOOL	Enable)	/* Enable / Disable */
 {
 #ifdef YUKON
 	SK_U16	RcReg;
 #endif
 #ifdef GENESIS
 	SK_U32	MdReg;
-#endif	
+#endif
 
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		XM_IN32(IoC, Port, XM_MODE, &MdReg);
 		/* enable or disable promiscuous mode */
 		if (Enable) {
 			MdReg |= XM_MD_ENA_PROM;
@@ -393,14 +444,14 @@ SK_BOOL	Enable)	/* Enable / Disable */
 		/* setup Mode Register */
 		XM_OUT32(IoC, Port, XM_MODE, MdReg);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		GM_IN16(IoC, Port, GM_RX_CTRL, &RcReg);
-		
+
 		/* enable or disable unicast and multicast filtering */
 		if (Enable) {
 			RcReg &= ~(GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA);
 		}
@@ -420,29 +471,29 @@ SK_BOOL	Enable)	/* Enable / Disable */
  *	SkMacHashing() - Enable / Disable Hashing
  *
  * Description:
  *   enables / disables hashing by setting Mode Register (XMAC) or
- *   Receive Control Register (GMAC) dep. on board type		
+ *   Receive Control Register (GMAC) dep. on board type
  *
  * Returns:
  *	nothing
  */
 void SkMacHashing(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port,	/* Port Index (MAC_1 + n) */
 SK_BOOL	Enable)	/* Enable / Disable */
 {
 #ifdef YUKON
 	SK_U16	RcReg;
-#endif	
+#endif
 #ifdef GENESIS
 	SK_U32	MdReg;
 #endif
 
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		XM_IN32(IoC, Port, XM_MODE, &MdReg);
 		/* enable or disable hashing */
 		if (Enable) {
 			MdReg |= XM_MD_ENA_HASH;
@@ -453,14 +504,14 @@ SK_BOOL	Enable)	/* Enable / Disable */
 		/* setup Mode Register */
 		XM_OUT32(IoC, Port, XM_MODE, MdReg);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		GM_IN16(IoC, Port, GM_RX_CTRL, &RcReg);
-		
+
 		/* enable or disable multicast filtering */
 		if (Enable) {
 			RcReg |= GM_RXCR_MCF_ENA;
 		}
@@ -498,10 +549,10 @@ SK_BOOL	Enable)	/* Enable / Disable */
  * Returns:
  *	nothing
  */
 static void SkXmSetRxCmd(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		Mode)		/* Mode is SK_STRIP_FCS_ON/OFF, SK_STRIP_PAD_ON/OFF,
 					   SK_LENERR_OK_ON/OFF, or SK_BIG_PK_OK_ON/OFF */
 {
@@ -510,9 +561,9 @@ int		Mode)		/* Mode is SK_STRIP_FCS_ON/O
 
 	XM_IN16(IoC, Port, XM_RX_CMD, &OldRxCmd);
 
 	RxCmd = OldRxCmd;
-	
+
 	switch (Mode & (SK_STRIP_FCS_ON | SK_STRIP_FCS_OFF)) {
 	case SK_STRIP_FCS_ON:
 		RxCmd |= XM_RX_STRIP_FCS;
 		break;
@@ -583,51 +634,42 @@ int		Mode)		/* Mode is SK_STRIP_FCS_ON/O
  * Returns:
  *	nothing
  */
 static void SkGmSetRxCmd(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		Mode)		/* Mode is SK_STRIP_FCS_ON/OFF, SK_STRIP_PAD_ON/OFF,
 					   SK_LENERR_OK_ON/OFF, or SK_BIG_PK_OK_ON/OFF */
 {
-	SK_U16	OldRxCmd;
 	SK_U16	RxCmd;
 
 	if ((Mode & (SK_STRIP_FCS_ON | SK_STRIP_FCS_OFF)) != 0) {
-		
-		GM_IN16(IoC, Port, GM_RX_CTRL, &OldRxCmd);
 
-		RxCmd = OldRxCmd;
+		GM_IN16(IoC, Port, GM_RX_CTRL, &RxCmd);
 
 		if ((Mode & SK_STRIP_FCS_ON) != 0) {
 			RxCmd |= GM_RXCR_CRC_DIS;
 		}
 		else {
 			RxCmd &= ~GM_RXCR_CRC_DIS;
 		}
-		/* Write the new mode to the Rx control register if required */
-		if (OldRxCmd != RxCmd) {
-			GM_OUT16(IoC, Port, GM_RX_CTRL, RxCmd);
-		}
+		/* Write the new mode to the Rx Control register */
+		GM_OUT16(IoC, Port, GM_RX_CTRL, RxCmd);
 	}
 
 	if ((Mode & (SK_BIG_PK_OK_ON | SK_BIG_PK_OK_OFF)) != 0) {
-		
-		GM_IN16(IoC, Port, GM_SERIAL_MODE, &OldRxCmd);
 
-		RxCmd = OldRxCmd;
+		GM_IN16(IoC, Port, GM_SERIAL_MODE, &RxCmd);
 
 		if ((Mode & SK_BIG_PK_OK_ON) != 0) {
 			RxCmd |= GM_SMOD_JUMBO_ENA;
 		}
 		else {
 			RxCmd &= ~GM_SMOD_JUMBO_ENA;
 		}
-		/* Write the new mode to the Rx control register if required */
-		if (OldRxCmd != RxCmd) {
-			GM_OUT16(IoC, Port, GM_SERIAL_MODE, RxCmd);
-		}
+		/* Write the new mode to the Serial Mode register */
+		GM_OUT16(IoC, Port, GM_SERIAL_MODE, RxCmd);
 	}
 }	/* SkGmSetRxCmd */
 
 
@@ -640,19 +682,19 @@ int		Mode)		/* Mode is SK_STRIP_FCS_ON/O
  * Returns:
  *	nothing
  */
 void SkMacSetRxCmd(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		Mode)		/* Rx Mode */
 {
 	if (pAC->GIni.GIGenesis) {
-		
+
 		SkXmSetRxCmd(pAC, IoC, Port, Mode);
 	}
 	else {
-		
+
 		SkGmSetRxCmd(pAC, IoC, Port, Mode);
 	}
 
 }	/* SkMacSetRxCmd */
@@ -667,17 +709,17 @@ int		Mode)		/* Rx Mode */
  * Returns:
  *	nothing
  */
 void SkMacCrcGener(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port,	/* Port Index (MAC_1 + n) */
 SK_BOOL	Enable)	/* Enable / Disable */
 {
 	SK_U16	Word;
 
 	if (pAC->GIni.GIGenesis) {
-		
+
 		XM_IN16(IoC, Port, XM_TX_CMD, &Word);
 
 		if (Enable) {
 			Word &= ~XM_TX_NO_CRC;
@@ -688,11 +730,11 @@ SK_BOOL	Enable)	/* Enable / Disable */
 		/* setup Tx Command Register */
 		XM_OUT16(IoC, Port, XM_TX_CMD, Word);
 	}
 	else {
-		
+
 		GM_IN16(IoC, Port, GM_TX_CTRL, &Word);
-		
+
 		if (Enable) {
 			Word &= ~GM_TXCR_CRC_DIS;
 		}
 		else {
@@ -720,16 +762,16 @@ SK_BOOL	Enable)	/* Enable / Disable */
  * Returns:
  *	nothing
  */
 void SkXmClrExactAddr(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		StartNum,	/* Begin with this Address Register Index (0..15) */
 int		StopNum)	/* Stop after finished with this Register Idx (0..15) */
 {
 	int		i;
-	SK_U16	ZeroAddr[3] = {0x0000, 0x0000, 0x0000};
+	SK_U16	ZeroAddr[3] = {0, 0, 0};
 
 	if ((unsigned)StartNum > 15 || (unsigned)StopNum > 15 ||
 		StartNum > StopNum) {
 
@@ -737,9 +779,9 @@ int		StopNum)	/* Stop after finished wit
 		return;
 	}
 
 	for (i = StartNum; i <= StopNum; i++) {
-		XM_OUTADDR(IoC, Port, XM_EXM(i), &ZeroAddr[0]);
+		XM_OUTADDR(IoC, Port, XM_EXM(i), ZeroAddr);
 	}
 }	/* SkXmClrExactAddr */
 #endif /* GENESIS */
 
@@ -754,23 +796,23 @@ int		StopNum)	/* Stop after finished wit
  * Returns:
  *	nothing
  */
 void SkMacFlushTxFifo(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 #ifdef GENESIS
 	SK_U32	MdReg;
 
 	if (pAC->GIni.GIGenesis) {
-		
+
 		XM_IN32(IoC, Port, XM_MODE, &MdReg);
 
 		XM_OUT32(IoC, Port, XM_MODE, MdReg | XM_MD_FTF);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
 		/* no way to flush the FIFO we have to issue a reset */
 		/* TBD */
@@ -790,10 +832,10 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkMacFlushRxFifo(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 #ifdef GENESIS
 	SK_U32	MdReg;
@@ -804,9 +846,9 @@ int		Port)	/* Port Index (MAC_1 + n) */
 
 		XM_OUT32(IoC, Port, XM_MODE, MdReg | XM_MD_FRF);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
 		/* no way to flush the FIFO we have to issue a reset */
 		/* TBD */
@@ -852,25 +894,25 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 static void SkXmSoftRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
-	SK_U16	ZeroAddr[4] = {0x0000, 0x0000, 0x0000, 0x0000};
-	
+	SK_U16	ZeroAddr[4] = {0, 0, 0, 0};
+
 	/* reset the statistics module */
 	XM_OUT32(IoC, Port, XM_GP_PORT, XM_GP_RES_STAT);
 
 	/* disable all XMAC IRQs */
 	XM_OUT16(IoC, Port, XM_IMSK, 0xffff);
-	
+
 	XM_OUT32(IoC, Port, XM_MODE, 0);		/* clear Mode Reg */
-	
+
 	XM_OUT16(IoC, Port, XM_TX_CMD, 0);		/* reset TX CMD Reg */
 	XM_OUT16(IoC, Port, XM_RX_CMD, 0);		/* reset RX CMD Reg */
-	
+
 	/* disable all PHY IRQs */
 	switch (pAC->GIni.GP[Port].PhyType) {
 	case SK_PHY_BCOM:
 			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_INT_MASK, 0xffff);
@@ -886,15 +928,15 @@ int		Port)	/* Port Index (MAC_1 + n) */
 #endif /* OTHER_PHY */
 	}
 
 	/* clear the Hash Register */
-	XM_OUTHASH(IoC, Port, XM_HSM, &ZeroAddr);
+	XM_OUTHASH(IoC, Port, XM_HSM, ZeroAddr);
 
 	/* clear the Exact Match Address registers */
 	SkXmClrExactAddr(pAC, IoC, Port, 0, 15);
-	
+
 	/* clear the Source Check Address registers */
-	XM_OUTHASH(IoC, Port, XM_SRC_CHK, &ZeroAddr);
+	XM_OUTHASH(IoC, Port, XM_SRC_CHK, ZeroAddr);
 
 }	/* SkXmSoftRst */
 
 
@@ -915,10 +957,10 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 static void SkXmHardRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_U32	Reg;
 	int		i;
@@ -939,19 +981,19 @@ int		Port)	/* Port Index (MAC_1 + n) */
 				return;
 			}
 
 			SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_SET_MAC_RST);
-			
+
 			SK_IN16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), &Word);
-		
+
 		} while ((Word & MFF_SET_MAC_RST) == 0);
 	}
 
 	/* For external PHYs there must be special handling */
 	if (pAC->GIni.GP[Port].PhyType != SK_PHY_XMAC) {
-		
+
 		SK_IN32(IoC, B2_GP_IO, &Reg);
-		
+
 		if (Port == 0) {
 			Reg |= GP_DIR_0; 	/* set to output */
 			Reg &= ~GP_IO_0;	/* set PHY reset (active low) */
 		}
@@ -977,14 +1019,14 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 static void SkXmClearRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_U32	DWord;
-	
+
 	/* clear HW reset */
 	SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_CLR_MAC_RST);
 
 	if (pAC->GIni.GP[Port].PhyType != SK_PHY_XMAC) {
@@ -1019,31 +1061,30 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 static void SkGmSoftRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_U16	EmptyHash[4] = {0x0000, 0x0000, 0x0000, 0x0000};
 	SK_U16  RxCtrl;
 
 	/* reset the statistics module */
 
 	/* disable all GMAC IRQs */
-	SK_OUT8(IoC, GMAC_IRQ_MSK, 0);
-	
+	SK_OUT8(IoC, MR_ADDR(Port, GMAC_IRQ_MSK), 0);
+
 	/* disable all PHY IRQs */
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK, 0);
-	
+
 	/* clear the Hash Register */
 	GM_OUTHASH(IoC, Port, GM_MC_ADDR_H1, EmptyHash);
 
 	/* Enable Unicast and Multicast filtering */
 	GM_IN16(IoC, Port, GM_RX_CTRL, &RxCtrl);
-	
-	GM_OUT16(IoC, Port, GM_RX_CTRL,
-		(SK_U16)(RxCtrl | GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA));
+
+	GM_OUT16(IoC, Port, GM_RX_CTRL, RxCtrl | GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA);
 
 }	/* SkGmSoftRst */
 
 
@@ -1056,18 +1097,18 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 static void SkGmHardRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_U32	DWord;
-	
+
 	/* WA code for COMA mode */
 	if (pAC->GIni.GIYukonLite &&
 		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
-		
+
 		SK_IN32(IoC, B2_GP_IO, &DWord);
 
 		DWord |= (GP_DIR_9 | GP_IO_9);
 
@@ -1075,12 +1116,12 @@ int		Port)	/* Port Index (MAC_1 + n) */
 		SK_OUT32(IoC, B2_GP_IO, DWord);
 	}
 
 	/* set GPHY Control reset */
-	SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), GPC_RST_SET);
+	SK_OUT8(IoC, MR_ADDR(Port, GPHY_CTRL), (SK_U8)GPC_RST_SET);
 
 	/* set GMAC Control reset */
-	SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
+	SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_RST_SET);
 
 }	/* SkGmHardRst */
 
 
@@ -1093,26 +1134,26 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 static void SkGmClearRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_U32	DWord;
-	
+
 #ifdef XXX
 		/* clear GMAC Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_CLR);
+		SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_RST_CLR);
 
 		/* set GMAC Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
+		SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_RST_SET);
 #endif /* XXX */
 
 	/* WA code for COMA mode */
 	if (pAC->GIni.GIYukonLite &&
 		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
-		
+
 		SK_IN32(IoC, B2_GP_IO, &DWord);
 
 		DWord |= GP_DIR_9;		/* set to output */
 		DWord &= ~GP_IO_9;		/* clear PHY reset (active high) */
@@ -1120,32 +1161,54 @@ int		Port)	/* Port Index (MAC_1 + n) */
 		/* clear PHY reset */
 		SK_OUT32(IoC, B2_GP_IO, DWord);
 	}
 
-	/* set HWCFG_MODE */
-	DWord = GPC_INT_POL_HI | GPC_DIS_FC | GPC_DIS_SLEEP |
-		GPC_ENA_XC | GPC_ANEG_ADV_ALL_M | GPC_ENA_PAUSE |
-		(pAC->GIni.GICopperType ? GPC_HWCFG_GMII_COP :
-		GPC_HWCFG_GMII_FIB);
+#ifdef VCPU
+	/* Set MAC Reset before PHY reset is set */
+	SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_RST_SET);
+#endif /* VCPU */
 
-	/* set GPHY Control reset */
-	SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_SET);
+	if (CHIP_ID_YUKON_2(pAC)) {
+		/* set GPHY Control reset */
+		SK_OUT8(IoC, MR_ADDR(Port, GPHY_CTRL), (SK_U8)GPC_RST_SET);
 
-	/* release GPHY Control reset */
-	SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_CLR);
+		/* release GPHY Control reset */
+		SK_OUT8(IoC, MR_ADDR(Port, GPHY_CTRL), (SK_U8)GPC_RST_CLR);
+	}
+	else {
+		/* set HWCFG_MODE */
+		DWord = GPC_INT_POL_HI | GPC_DIS_FC | GPC_DIS_SLEEP |
+			GPC_ENA_XC | GPC_ANEG_ADV_ALL_M | GPC_ENA_PAUSE |
+			(pAC->GIni.GICopperType ? GPC_HWCFG_GMII_COP :
+			GPC_HWCFG_GMII_FIB);
+		
+		/* set GPHY Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_SET);
 
+		/* release GPHY Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_CLR);
+	}
+	
 #ifdef VCPU
+    /* wait for internal initialization of GPHY */
+    VCPUprintf(0, "Waiting until PHY %d is ready to initialize\n", Port);
+	VCpuWait(10000);
+
+	/* release GMAC reset */
+    SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_RST_CLR);
+
+    /* wait for stable GMAC clk */
 	VCpuWait(9000);
 #endif /* VCPU */
 
 	/* clear GMAC Control reset */
-	SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_PAUSE_ON | GMC_RST_CLR);
+	SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_RST_CLR);
 
 #ifdef VCPU
 	VCpuWait(2000);
-	
+
 	SK_IN32(IoC, MR_ADDR(Port, GPHY_CTRL), &DWord);
-			
+
 	SK_IN32(IoC, B0_ISRC, &DWord);
 #endif /* VCPU */
 
 }	/* SkGmClearRst */
@@ -1161,10 +1224,10 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkMacSoftRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 
@@ -1174,23 +1237,23 @@ int		Port)	/* Port Index (MAC_1 + n) */
 	SkMacRxTxDisable(pAC, IoC, Port);
 
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		SkXmSoftRst(pAC, IoC, Port);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		SkGmSoftRst(pAC, IoC, Port);
 	}
 #endif /* YUKON */
 
 	/* flush the MAC's Rx and Tx FIFOs */
 	SkMacFlushTxFifo(pAC, IoC, Port);
-	
+
 	SkMacFlushRxFifo(pAC, IoC, Port);
 
 	pPrt->PState = SK_PRT_STOP;
 
@@ -1206,23 +1269,23 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkMacHardRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
-	
+
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		SkXmHardRst(pAC, IoC, Port);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		SkGmHardRst(pAC, IoC, Port);
 	}
 #endif /* YUKON */
 
@@ -1240,23 +1303,23 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkMacClearRst(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
-	
+
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		SkXmClearRst(pAC, IoC, Port);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		SkGmClearRst(pAC, IoC, Port);
 	}
 #endif /* YUKON */
 
@@ -1278,10 +1341,10 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkXmInitMac(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	int			i;
@@ -1314,9 +1377,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 			 * Optimize MDIO transfer by suppressing preamble.
 			 * Must be done AFTER first access to BCOM chip.
 			 */
 			XM_IN16(IoC, Port, XM_MMU_CMD, &SWord);
-			
+
 			XM_OUT16(IoC, Port, XM_MMU_CMD, SWord | XM_MMU_NO_PRE);
 
 			if (pPrt->PhyId1 == PHY_BCOM_ID1_C0) {
 				/*
@@ -1347,18 +1410,18 @@ int		Port)		/* Port Index (MAC_1 + n) */
 			 * Workaround BCOM Errata (#10523) for all BCom PHYs.
 			 * Disable Power Management after reset.
 			 */
 			SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &SWord);
-			
+
 			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUX_CTRL,
 				(SK_U16)(SWord | PHY_B_AC_DIS_PM));
 
 			/* PHY LED initialization is done in SkGeXmitLED() */
 		}
 
 		/* Dummy read the Interrupt source register */
 		XM_IN16(IoC, Port, XM_ISRC, &SWord);
-		
+
 		/*
 		 * The auto-negotiation process starts immediately after
 		 * clearing the reset. The auto-negotiation process should be
 		 * started by the SIRQ, therefore stop it here immediately.
@@ -1382,9 +1445,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		 * The following 2 statements are together endianess
 		 * independent. Remember this when changing.
 		 */
 		SK_IN16(IoC, (B2_MAC_2 + Port * 8 + i * 2), &SWord);
-		
+
 		XM_OUT16(IoC, Port, (XM_SA + i * 2), SWord);
 	}
 
 	/* Tx Inter Packet Gap (XM_TX_IPG):	use default */
@@ -1435,9 +1498,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		 * on frames received
 		 */
 		SWord |= XM_RX_DIS_CEXT;
 	}
-	
+
 	XM_OUT16(IoC, Port, XM_RX_CMD, SWord);
 
 	/*
 	 * setup register defaults for the Mode Register
@@ -1492,10 +1555,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkGmInitMac(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	int			i;
@@ -1507,9 +1570,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	if (pPrt->PState == SK_PRT_STOP) {
 		/* Port State: SK_PRT_STOP */
 		/* Verify that the reset bit is cleared */
 		SK_IN32(IoC, MR_ADDR(Port, GMAC_CTRL), &DWord);
-		
+
 		if ((DWord & GMC_RST_SET) != 0) {
 			/* PState does not match HW state */
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E006, SKERR_HWI_E006MSG);
 			/* Correct it */
@@ -1517,13 +1580,13 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		}
 	}
 
 	if (pPrt->PState == SK_PRT_RESET) {
-		
+
 		SkGmHardRst(pAC, IoC, Port);
 
 		SkGmClearRst(pAC, IoC, Port);
-		
+
 		/* Auto-negotiation ? */
 		if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 			/* Auto-negotiation disabled */
 
@@ -1531,12 +1594,12 @@ int		Port)		/* Port Index (MAC_1 + n) */
 			GM_IN16(IoC, Port, GM_GP_CTRL, &SWord);
 
 			/* disable auto-update for speed, duplex and flow-control */
 			SWord |= GM_GPCR_AU_ALL_DIS;
-			
+
 			/* setup General Purpose Control Register */
 			GM_OUT16(IoC, Port, GM_GP_CTRL, SWord);
-			
+
 			SWord = GM_GPCR_AU_ALL_DIS;
 		}
 		else {
 			SWord = 0;
@@ -1545,9 +1608,12 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		/* speed settings */
 		switch (pPrt->PLinkSpeed) {
 		case SK_LSPEED_AUTO:
 		case SK_LSPEED_1000MBPS:
-			SWord |= GM_GPCR_SPEED_1000 | GM_GPCR_SPEED_100;
+			if ((pPrt->PLinkSpeedCap & SK_LSPEED_CAP_1000MBPS) != 0) {
+
+				SWord |= GM_GPCR_SPEED_1000 | GM_GPCR_SPEED_100;
+			}
 			break;
 		case SK_LSPEED_100MBPS:
 			SWord |= GM_GPCR_SPEED_100;
 			break;
@@ -1563,10 +1629,8 @@ int		Port)		/* Port Index (MAC_1 + n) */
 
 		/* flow-control settings */
 		switch (pPrt->PFlowCtrlMode) {
 		case SK_FLOW_MODE_NONE:
-			/* set Pause Off */
-			SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_PAUSE_OFF);
 			/* disable Tx & Rx flow-control */
 			SWord |= GM_GPCR_FC_TX_DIS | GM_GPCR_FC_RX_DIS | GM_GPCR_AU_FCT_DIS;
 			break;
 		case SK_FLOW_MODE_LOC_SEND:
@@ -1582,26 +1646,26 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		/* setup General Purpose Control Register */
 		GM_OUT16(IoC, Port, GM_GP_CTRL, SWord);
 
 		/* dummy read the Interrupt Source Register */
-		SK_IN16(IoC, GMAC_IRQ_SRC, &SWord);
-		
+		SK_IN16(IoC, MR_ADDR(Port, GMAC_IRQ_SRC), &SWord);
+
 #ifndef VCPU
 		/* read Id from PHY */
 		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_ID1, &pPrt->PhyId1);
-		
+
 		SkGmInitPhyMarv(pAC, IoC, Port, SK_FALSE);
 #endif /* VCPU */
 	}
 
 	(void)SkGmResetCounter(pAC, IoC, Port);
 
 	/* setup Transmit Control Register */
-	GM_OUT16(IoC, Port, GM_TX_CTRL, TX_COL_THR(pPrt->PMacColThres));
+	GM_OUT16(IoC, Port, GM_TX_CTRL, (SK_U16)TX_COL_THR(pPrt->PMacColThres));
 
 	/* setup Receive Control Register */
-	GM_OUT16(IoC, Port, GM_RX_CTRL, GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA |
-		GM_RXCR_CRC_DIS);
+	GM_OUT16(IoC, Port, GM_RX_CTRL, GM_RXCR_UCF_ENA |
+		GM_RXCR_MCF_ENA | GM_RXCR_CRC_DIS);
 
 	/* setup Transmit Flow Control Register */
 	GM_OUT16(IoC, Port, GM_TX_FLOW_CTRL, 0xffff);
 
@@ -1609,20 +1673,21 @@ int		Port)		/* Port Index (MAC_1 + n) */
 #ifdef VCPU
 	GM_IN16(IoC, Port, GM_TX_PARAM, &SWord);
 #endif /* VCPU */
 
-    SWord = TX_JAM_LEN_VAL(pPrt->PMacJamLen) |
-			TX_JAM_IPG_VAL(pPrt->PMacJamIpgVal) |
-			TX_IPG_JAM_DATA(pPrt->PMacJamIpgData);
-	
+	SWord = (SK_U16)(TX_JAM_LEN_VAL(pPrt->PMacJamLen) |
+		TX_JAM_IPG_VAL(pPrt->PMacJamIpgVal) |
+		TX_IPG_JAM_DATA(pPrt->PMacJamIpgData));
+
 	GM_OUT16(IoC, Port, GM_TX_PARAM, SWord);
 
 	/* configure the Serial Mode Register */
 #ifdef VCPU
 	GM_IN16(IoC, Port, GM_SERIAL_MODE, &SWord);
 #endif /* VCPU */
-	
-	SWord = GM_SMOD_VLAN_ENA | IPG_DATA_VAL(pPrt->PMacIpgData);
+
+	SWord = (SK_U16)(DATA_BLIND_VAL(pPrt->PMacDataBlind) |
+		GM_SMOD_VLAN_ENA | IPG_DATA_VAL(pPrt->PMacIpgData));
 
 	if (pPrt->PMacLimit4) {
 		/* reset of collision counter after 4 consecutive collisions */
 		SWord |= GM_SMOD_LIMIT_4;
@@ -1631,11 +1696,11 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
 		/* enable jumbo mode (Max. Frame Length = 9018) */
 		SWord |= GM_SMOD_JUMBO_ENA;
 	}
-	
+
 	GM_OUT16(IoC, Port, GM_SERIAL_MODE, SWord);
-	
+
 	/*
 	 * configure the GMACs Station Addresses
 	 * in PROM you can find our addresses at:
 	 * B2_MAC_1 = xx xx xx xx xx x0 virtual address
@@ -1662,17 +1727,17 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		}
 		else {
 			GM_OUT16(IoC, Port, (GM_SRC_ADDR_1L + i * 4), SWord);
 		}
-#else		
+#else
 		GM_OUT16(IoC, Port, (GM_SRC_ADDR_1L + i * 4), SWord);
 #endif /* WA_DEV_16 */
-		
+
 		/* virtual address: will be used for data */
 		SK_IN16(IoC, (B2_MAC_1 + Port * 8 + i * 2), &SWord);
 
 		GM_OUT16(IoC, Port, (GM_SRC_ADDR_2L + i * 4), SWord);
-		
+
 		/* reset Multicast filtering Hash registers 1-3 */
 		GM_OUT16(IoC, Port, GM_MC_ADDR_H1 + 4*i, 0);
 	}
 
@@ -1683,20 +1748,8 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	GM_OUT16(IoC, Port, GM_TX_IRQ_MSK, 0);
 	GM_OUT16(IoC, Port, GM_RX_IRQ_MSK, 0);
 	GM_OUT16(IoC, Port, GM_TR_IRQ_MSK, 0);
 
-#if defined(SK_DIAG) || defined(DEBUG)
-	/* read General Purpose Status */
-	GM_IN16(IoC, Port, GM_GP_STAT, &SWord);
-	
-	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("MAC Stat Reg.=0x%04X\n", SWord));
-#endif /* SK_DIAG || DEBUG */
-
-#ifdef SK_DIAG
-	c_print("MAC Stat Reg=0x%04X\n", SWord);
-#endif /* SK_DIAG */
-
 }	/* SkGmInitMac */
 #endif /* YUKON */
 
 
@@ -1713,10 +1766,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkXmInitDupMd(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	switch (pAC->GIni.GP[Port].PLinkModeStatus) {
 	case SK_LMODE_STAT_AUTOHALF:
@@ -1761,10 +1814,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkXmInitPauseMd(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U32		DWord;
@@ -1772,9 +1825,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
-	
+
 	if (pPrt->PFlowCtrlStatus == SK_FLOW_STAT_NONE ||
 		pPrt->PFlowCtrlStatus == SK_FLOW_STAT_LOC_SEND) {
 
 		/* Disable Pause Frame Reception */
@@ -1786,10 +1839,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		 * because the XMAC is not reset if the link is going down
 		 */
 		/* Enable Pause Frame Reception */
 		Word &= ~XM_MMU_IGN_PF;
-	}	
-	
+	}
+
 	XM_OUT16(IoC, Port, XM_MMU_CMD, Word);
 
 	XM_IN32(IoC, Port, XM_MODE, &DWord);
 
@@ -1827,9 +1880,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 
 		/* Disable Pause Mode in MAC Rx FIFO */
 		SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_DIS_PAUSE);
 	}
-	
+
 	XM_OUT32(IoC, Port, XM_MODE, DWord);
 }	/* SkXmInitPauseMd*/
 
 
@@ -1844,19 +1897,19 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 static void SkXmInitPhyXmac(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		Ctrl;
 
 	pPrt = &pAC->GIni.GP[Port];
 	Ctrl = 0;
-	
+
 	/* Auto-negotiation ? */
 	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("InitPhyXmac: no auto-negotiation Port %d\n", Port));
@@ -1938,10 +1991,10 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
  * Returns:
  *	nothing
  */
 static void SkXmInitPhyBcom(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
@@ -1961,9 +2014,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 
 	/* manually Master/Slave ? */
 	if (pPrt->PMSMode != SK_MS_MODE_AUTO) {
 		Ctrl2 |= PHY_B_1000C_MSE;
-		
+
 		if (pPrt->PMSMode == SK_MS_MODE_MASTER) {
 			Ctrl2 |= PHY_B_1000C_MSC;
 		}
 	}
@@ -1996,9 +2049,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 		 * 1000Base-T Link Acquisition Failure in Slave Mode
 		 * Set Repeater/DTE bit 10 of the 1000Base-T Control Register
 		 */
 		Ctrl2 |= PHY_B_1000C_RD;
-		
+
 		 /* Set Full/half duplex capabilities */
 		switch (pPrt->PLinkMode) {
 		case SK_LMODE_AUTOHALF:
 			Ctrl2 |= PHY_B_1000C_AHD;
@@ -2035,23 +2088,23 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 
 		/* Restart Auto-negotiation */
 		Ctrl1 |= PHY_CT_ANE | PHY_CT_RE_CFG;
 	}
-	
+
 	/* Initialize LED register here? */
 	/* No. Please do it in SkDgXmitLed() (if required) and swap
 	   init order of LEDs and XMAC. (MAl) */
-	
+
 	/* Write 1000Base-T Control Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_1000T_CTRL, Ctrl2);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Set 1000B-T Ctrl Reg=0x%04X\n", Ctrl2));
-	
+
 	/* Write AutoNeg Advertisement Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUNE_ADV, Ctrl3);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Set Auto-Neg.Adv.Reg=0x%04X\n", Ctrl3));
-	
+
 	if (DoLoop) {
 		/* Set the Phy Loopback bit, too */
 		Ctrl1 |= PHY_CT_LOOP;
 	}
@@ -2067,9 +2120,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	}
 
 	/* Configure LED Traffic Mode and Jumbo Frame usage if specified */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_P_EXT_CTRL, Ctrl4);
-	
+
 	/* Write to the Phy control register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_CTRL, Ctrl1);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("PHY Control Reg=0x%04X\n", Ctrl1));
@@ -2082,14 +2135,14 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 /******************************************************************************
  *
  *	SkGmEnterLowPowerMode()
  *
- * Description:	
+ * Description:
  *	This function sets the Marvell Alaska PHY to the low power mode
  *	given by parameter mode.
  *	The following low power modes are available:
- *		
- *		- Coma Mode (Deep Sleep):
+ *
+ *		- COMA Mode (Deep Sleep):
  *			Power consumption: ~15 - 30 mW
  *			The PHY cannot wake up on its own.
  *
  *		- IEEE 22.2.4.1.5 compatible power down mode
@@ -2114,116 +2167,128 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
  *		0: ok
  *		1: error
  */
 int SkGmEnterLowPowerMode(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (e.g. MAC_1) */
 SK_U8	Mode)		/* low power mode */
 {
 	SK_U16	Word;
 	SK_U32	DWord;
+	SK_U32	PowerDownBit;
 	SK_U8	LastMode;
 	int		Ret = 0;
 
-	if (pAC->GIni.GIYukonLite &&
-	    pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
+	if (!(CHIP_ID_YUKON_2(pAC) || (pAC->GIni.GIYukonLite &&
+		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3))) {
 
-		/* save current power mode */
-		LastMode = pAC->GIni.GP[Port].PPhyPowerState;
-		pAC->GIni.GP[Port].PPhyPowerState = Mode;
-
-		switch (Mode) {
-			/* coma mode (deep sleep) */
-			case PHY_PM_DEEP_SLEEP:
-				/* setup General Purpose Control Register */
-				GM_OUT16(IoC, 0, GM_GP_CTRL, GM_GPCR_FL_PASS |
-					GM_GPCR_SPEED_100 | GM_GPCR_AU_ALL_DIS);
-
-				/* apply COMA mode workaround */
-				SkGmPhyWrite(pAC, IoC, Port, 29, 0x001f);
-				SkGmPhyWrite(pAC, IoC, Port, 30, 0xfff3);
-
-				SK_IN32(IoC, PCI_C(PCI_OUR_REG_1), &DWord);
-
-				SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-				
-				/* Set PHY to Coma Mode */
-				SK_OUT32(IoC, PCI_C(PCI_OUR_REG_1), DWord | PCI_PHY_COMA);
-				
-				SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
-
-			break;
-			
-			/* IEEE 22.2.4.1.5 compatible power down mode */
-			case PHY_PM_IEEE_POWER_DOWN:
-				/*
-				 * - disable MAC 125 MHz clock
-				 * - allow MAC power down
-				 */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
-				Word |= PHY_M_PC_DIS_125CLK;
-				Word &=	~PHY_M_PC_MAC_POW_UP;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+		return(1);
+	}
 
-				/*
-				 * register changes must be followed by a software
-				 * reset to take effect
-				 */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
-				Word |= PHY_CT_RESET;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
-
-				/* switch IEEE compatible power down mode on */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
-				Word |= PHY_CT_PDOWN;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
-			break;
+	/* save current power mode */
+	LastMode = pAC->GIni.GP[Port].PPhyPowerState;
+	pAC->GIni.GP[Port].PPhyPowerState = Mode;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_POWM, SK_DBGCAT_CTRL,
+		("SkGmEnterLowPowerMode: %u\n", Mode));
+
+	switch (Mode) {
+	/* COMA mode (deep sleep) */
+	case PHY_PM_DEEP_SLEEP:
+		/* setup General Purpose Control Register */
+		GM_OUT16(IoC, Port, GM_GP_CTRL, GM_GPCR_FL_PASS |
+			GM_GPCR_SPEED_100 | GM_GPCR_AU_ALL_DIS);
 
-			/* energy detect and energy detect plus mode */
-			case PHY_PM_ENERGY_DETECT:
-			case PHY_PM_ENERGY_DETECT_PLUS:
-				/*
-				 * - disable MAC 125 MHz clock
-				 */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
-				Word |= PHY_M_PC_DIS_125CLK;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
-				
-				/* activate energy detect mode 1 */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
-
-				/* energy detect mode */
-				if (Mode == PHY_PM_ENERGY_DETECT) {
-					Word |= PHY_M_PC_EN_DET;
-				}
-				/* energy detect plus mode */
-				else {
-					Word |= PHY_M_PC_EN_DET_PLUS;
-				}
+		if (CHIP_ID_YUKON_2(pAC)) {
+			/* set power down bit */
+			PowerDownBit = (Port == MAC_1) ? PCI_Y2_PHY1_POWD :
+				PCI_Y2_PHY2_POWD;
+		}
+		else {
+			/* apply COMA mode workaround */
+			SkGmPhyWrite(pAC, IoC, Port, 29, 0x001f);
 
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+			SkGmPhyWrite(pAC, IoC, Port, 30, 0xfff3);
 
-				/*
-				 * reinitialize the PHY to force a software reset
-				 * which is necessary after the register settings
-				 * for the energy detect modes.
-				 * Furthermore reinitialisation prevents that the
-				 * PHY is running out of a stable state.
-				 */
-				SkGmInitPhyMarv(pAC, IoC, Port, SK_FALSE);
-			break;
+			PowerDownBit = PCI_PHY_COMA;
+		}
 
-			/* don't change current power mode */
-			default:
-				pAC->GIni.GP[Port].PPhyPowerState = LastMode;
-				Ret = 1;
-			break;
+		SK_IN32(IoC, PCI_C(pAC, PCI_OUR_REG_1), &DWord);
+
+		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+
+		/* Set PHY to PowerDown/COMA Mode */
+		SK_OUT32(IoC, PCI_C(pAC, PCI_OUR_REG_1), DWord | PowerDownBit);
+
+		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
+
+		break;
+
+	/* IEEE 22.2.4.1.5 compatible power down mode */
+	case PHY_PM_IEEE_POWER_DOWN:
+		/*
+		 * - disable MAC 125 MHz clock
+		 * - allow MAC power down
+		 */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+		Word |= PHY_M_PC_DIS_125CLK;
+		Word &=	~PHY_M_PC_MAC_POW_UP;
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+		/*
+		 * register changes must be followed by a software
+		 * reset to take effect
+		 */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
+		Word |= PHY_CT_RESET;
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
+
+		/* switch IEEE compatible power down mode on */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
+		Word |= PHY_CT_PDOWN;
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
+		
+		break;
+
+	/* energy detect and energy detect plus mode */
+	case PHY_PM_ENERGY_DETECT:
+	case PHY_PM_ENERGY_DETECT_PLUS:
+
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+
+		if (!CHIP_ID_YUKON_2(pAC)) {
+			/* disable MAC 125 MHz clock */
+			Word |= PHY_M_PC_DIS_125CLK;
 		}
-	}
-	/* low power modes are not supported by this chip */
-	else {
+
+		/* energy detect mode */
+		if (Mode == PHY_PM_ENERGY_DETECT) {
+			Word |= PHY_M_PC_EN_DET;
+		}
+		/* energy detect plus mode */
+		else {
+			Word |= PHY_M_PC_EN_DET_PLUS;
+		}
+
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+		/*
+		 * reinitialize the PHY to force a software reset
+		 * which is necessary after the register settings
+		 * for the energy detect modes.
+		 * Furthermore reinitialisation prevents that the
+		 * PHY is running out of a stable state.
+		 */
+		SkGmInitPhyMarv(pAC, IoC, Port, SK_FALSE);
+
+		break;
+
+	/* don't change current power mode */
+	default:
+		pAC->GIni.GP[Port].PPhyPowerState = LastMode;
 		Ret = 1;
+		break;
 	}
 
 	return(Ret);
 
@@ -2232,9 +2297,9 @@ SK_U8	Mode)		/* low power mode */
 /******************************************************************************
  *
  *	SkGmLeaveLowPowerMode()
  *
- * Description:	
+ * Description:
  *	Leave the current low power mode and switch to normal mode
  *
  * Note:
  *
@@ -2242,110 +2307,127 @@ SK_U8	Mode)		/* low power mode */
  *		0:	ok
  *		1:	error
  */
 int SkGmLeaveLowPowerMode(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (e.g. MAC_1) */
 {
 	SK_U32	DWord;
+	SK_U32	PowerDownBit;
 	SK_U16	Word;
 	SK_U8	LastMode;
 	int		Ret = 0;
 
-	if (pAC->GIni.GIYukonLite &&
-		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
+	if (!(CHIP_ID_YUKON_2(pAC) || (pAC->GIni.GIYukonLite &&
+		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3))) {
 
-		/* save current power mode */
-		LastMode = pAC->GIni.GP[Port].PPhyPowerState;
-		pAC->GIni.GP[Port].PPhyPowerState = PHY_PM_OPERATIONAL_MODE;
-
-		switch (LastMode) {
-			/* coma mode (deep sleep) */
-			case PHY_PM_DEEP_SLEEP:
-				SK_IN32(IoC, PCI_C(PCI_OUR_REG_1), &DWord);
-
-				SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-				
-				/* Release PHY from Coma Mode */
-				SK_OUT32(IoC, PCI_C(PCI_OUR_REG_1), DWord & ~PCI_PHY_COMA);
-				
-				SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
-				
-				SK_IN32(IoC, B2_GP_IO, &DWord);
-
-				/* set to output */
-				DWord |= (GP_DIR_9 | GP_IO_9);
-
-				/* set PHY reset */
-				SK_OUT32(IoC, B2_GP_IO, DWord);
-
-				DWord &= ~GP_IO_9; /* clear PHY reset (active high) */
-
-				/* clear PHY reset */
-				SK_OUT32(IoC, B2_GP_IO, DWord);
-			break;
-			
-			/* IEEE 22.2.4.1.5 compatible power down mode */
-			case PHY_PM_IEEE_POWER_DOWN:
-				/*
-				 * - enable MAC 125 MHz clock
-				 * - set MAC power up
-				 */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
-				Word &= ~PHY_M_PC_DIS_125CLK;
-				Word |=	PHY_M_PC_MAC_POW_UP;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+		return(1);
+	}
 
-				/*
-				 * register changes must be followed by a software
-				 * reset to take effect
-				 */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
-				Word |= PHY_CT_RESET;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
-
-				/* switch IEEE compatible power down mode off */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
-				Word &= ~PHY_CT_PDOWN;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
-			break;
+	/* save current power mode */
+	LastMode = pAC->GIni.GP[Port].PPhyPowerState;
+	pAC->GIni.GP[Port].PPhyPowerState = PHY_PM_OPERATIONAL_MODE;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_POWM, SK_DBGCAT_CTRL,
+		("SkGmLeaveLowPowerMode: %u\n", LastMode));
+
+	switch (LastMode) {
+	/* COMA mode (deep sleep) */
+	case PHY_PM_DEEP_SLEEP:
+		if (CHIP_ID_YUKON_2(pAC)) {
+			/* set power down bit */
+			PowerDownBit = (Port == MAC_1) ? PCI_Y2_PHY1_POWD :
+				PCI_Y2_PHY2_POWD;
+		}
+		else {
+			PowerDownBit = PCI_PHY_COMA;
+		}
 
-			/* energy detect and energy detect plus mode */
-			case PHY_PM_ENERGY_DETECT:
-			case PHY_PM_ENERGY_DETECT_PLUS:
-				/*
-				 * - enable MAC 125 MHz clock
-				 */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
-				Word &= ~PHY_M_PC_DIS_125CLK;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
-				
-				/* disable energy detect mode */
-				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
-				Word &= ~PHY_M_PC_EN_DET_MSK;
-				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+		SK_IN32(IoC, PCI_C(pAC, PCI_OUR_REG_1), &DWord);
 
-				/*
-				 * reinitialize the PHY to force a software reset
-				 * which is necessary after the register settings
-				 * for the energy detect modes.
-				 * Furthermore reinitialisation prevents that the
-				 * PHY is running out of a stable state.
-				 */
-				SkGmInitPhyMarv(pAC, IoC, Port, SK_FALSE);
-			break;
+		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
 
-			/* don't change current power mode */
-			default:
-				pAC->GIni.GP[Port].PPhyPowerState = LastMode;
-				Ret = 1;
-			break;
+		/* Release PHY from PowerDown/COMA Mode */
+		SK_OUT32(IoC, PCI_C(pAC, PCI_OUR_REG_1), DWord & ~PowerDownBit);
+
+		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
+
+		if (!CHIP_ID_YUKON_2(pAC)) {
+
+			SK_IN32(IoC, B2_GP_IO, &DWord);
+
+			/* set to output */
+			DWord |= (GP_DIR_9 | GP_IO_9);
+
+			/* set PHY reset */
+			SK_OUT32(IoC, B2_GP_IO, DWord);
+
+			DWord &= ~GP_IO_9; /* clear PHY reset (active high) */
+
+			/* clear PHY reset */
+			SK_OUT32(IoC, B2_GP_IO, DWord);
 		}
-	}
-	/* low power modes are not supported by this chip */
-	else {
+
+		break;
+
+	/* IEEE 22.2.4.1.5 compatible power down mode */
+	case PHY_PM_IEEE_POWER_DOWN:
+		/*
+		 * - enable MAC 125 MHz clock
+		 * - set MAC power up
+		 */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+		Word &= ~PHY_M_PC_DIS_125CLK;
+		Word |=	PHY_M_PC_MAC_POW_UP;
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+		/*
+		 * register changes must be followed by a software
+		 * reset to take effect
+		 */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
+		Word |= PHY_CT_RESET;
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
+
+		/* switch IEEE compatible power down mode off */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
+		Word &= ~PHY_CT_PDOWN;
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
+
+		break;
+
+	/* energy detect and energy detect plus mode */
+	case PHY_PM_ENERGY_DETECT:
+	case PHY_PM_ENERGY_DETECT_PLUS:
+		/*
+		 * - enable MAC 125 MHz clock
+		 */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+		Word &= ~PHY_M_PC_DIS_125CLK;
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+		/* disable energy detect mode */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+		Word &= ~PHY_M_PC_EN_DET_MSK;
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+		/*
+		 * reinitialize the PHY to force a software reset
+		 * which is necessary after the register settings
+		 * for the energy detect modes.
+		 * Furthermore reinitialisation prevents that the
+		 * PHY is running out of a stable state.
+		 */
+		SkGmInitPhyMarv(pAC, IoC, Port, SK_FALSE);
+
+		break;
+
+	/* don't change current power mode */
+	default:
+		pAC->GIni.GP[Port].PPhyPowerState = LastMode;
 		Ret = 1;
+		break;
 	}
 
 	return(Ret);
 
@@ -2364,25 +2446,28 @@ int		Port)		/* Port Index (e.g. MAC_1) *
  * Returns:
  *	nothing
  */
 static void SkGmInitPhyMarv(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
+	SK_BOOL		AutoNeg;
 	SK_U16		PhyCtrl;
 	SK_U16		C1000BaseT;
 	SK_U16		AutoNegAdv;
+#ifndef VCPU
 	SK_U16		ExtPhyCtrl;
 	SK_U16		LedCtrl;
-	SK_BOOL		AutoNeg;
+	SK_U16		LedOver;
 #if defined(SK_DIAG) || defined(DEBUG)
 	SK_U16		PhyStat;
 	SK_U16		PhyStat1;
 	SK_U16		PhySpecStat;
 #endif /* SK_DIAG || DEBUG */
+#endif /* VCPU */
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	/* Auto-negotiation ? */
@@ -2391,37 +2476,46 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	}
 	else {
 		AutoNeg = SK_TRUE;
 	}
-	
+
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("InitPhyMarv: Port %d, auto-negotiation %s\n",
 		 Port, AutoNeg ? "ON" : "OFF"));
 
-#ifdef VCPU
-	VCPUprintf(0, "SkGmInitPhyMarv(), Port=%u, DoLoop=%u\n",
-		Port, DoLoop);
-#else /* VCPU */
+#ifndef VCPU
 	if (DoLoop) {
 		/* Set 'MAC Power up'-bit, set Manual MDI configuration */
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL,
 			PHY_M_PC_MAC_POW_UP);
 	}
 	else if (AutoNeg && pPrt->PLinkSpeed == SK_LSPEED_AUTO) {
 		/* Read Ext. PHY Specific Control */
 		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_EXT_CTRL, &ExtPhyCtrl);
-		
+
 		ExtPhyCtrl &= ~(PHY_M_EC_M_DSC_MSK | PHY_M_EC_S_DSC_MSK |
 			PHY_M_EC_MAC_S_MSK);
-		
+
 		ExtPhyCtrl |= PHY_M_EC_MAC_S(MAC_TX_CLK_25_MHZ) |
 			PHY_M_EC_M_DSC(0) | PHY_M_EC_S_DSC(1);
-	
+
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_CTRL, ExtPhyCtrl);
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("Set Ext. PHY Ctrl=0x%04X\n", ExtPhyCtrl));
 	}
 
+	if (CHIP_ID_YUKON_2(pAC)) {
+		/* Read PHY Specific Control */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &PhyCtrl);
+		/* Disable Energy Detect Mode, Reset MDI/MDIX bits */
+		PhyCtrl &= ~(PHY_M_PC_EN_DET_MSK | PHY_M_PC_MDIX_MSK);
+
+		/* Enable Automatic Crossover */
+		PhyCtrl |= (SK_U16)PHY_M_PC_MDI_XMODE(PHY_M_PC_ENA_AUTO);
+
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, PhyCtrl);
+	}
+
 	/* Read PHY Control */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &PhyCtrl);
 
 	if (!AutoNeg) {
@@ -2441,17 +2535,17 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	/* manually Master/Slave ? */
 	if (pPrt->PMSMode != SK_MS_MODE_AUTO) {
 		/* enable Manual Master/Slave */
 		C1000BaseT |= PHY_M_1000C_MSE;
-		
+
 		if (pPrt->PMSMode == SK_MS_MODE_MASTER) {
 			C1000BaseT |= PHY_M_1000C_MSC;	/* set it to Master */
 		}
 	}
-	
+
 	/* Auto-negotiation ? */
 	if (!AutoNeg) {
-		
+
 		if (pPrt->PLinkMode == SK_LMODE_FULL) {
 			/* Set Full Duplex Mode */
 			PhyCtrl |= PHY_CT_DUP_MD;
 		}
@@ -2464,9 +2558,10 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 		/* Set Speed */
 		switch (pPrt->PLinkSpeed) {
 		case SK_LSPEED_AUTO:
 		case SK_LSPEED_1000MBPS:
-			PhyCtrl |= PHY_CT_SP1000;
+			PhyCtrl |= (((pPrt->PLinkSpeedCap & SK_LSPEED_CAP_1000MBPS) != 0) ?
+						PHY_CT_SP1000 : PHY_CT_SP100);
 			break;
 		case SK_LSPEED_100MBPS:
 			PhyCtrl |= PHY_CT_SP100;
 			break;
@@ -2476,33 +2571,61 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E019,
 				SKERR_HWI_E019MSG);
 		}
 
+		if ((pPrt->PFlowCtrlMode == SK_FLOW_STAT_NONE) ||
+			/* disable Pause also for 10/100 Mbps in half duplex mode */
+			((pPrt->PLinkMode == SK_LMODE_HALF) &&
+			 ((pPrt->PLinkSpeed == SK_LSPEED_STAT_100MBPS) ||
+			  (pPrt->PLinkSpeed == SK_LSPEED_STAT_10MBPS)))) {
+
+			/* set Pause Off */
+			SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_PAUSE_OFF);
+		}
+		else {
+			/* set Pause On */
+			SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_PAUSE_ON);
+		}
+
 		if (!DoLoop) {
 			PhyCtrl |= PHY_CT_RESET;
 		}
 	}
 	else {
 		/* Set Auto-negotiation advertisement */
-		
+
 		if (pAC->GIni.GICopperType) {
 			/* Set Speed capabilities */
 			switch (pPrt->PLinkSpeed) {
 			case SK_LSPEED_AUTO:
-				C1000BaseT |= PHY_M_1000C_AHD | PHY_M_1000C_AFD;
+				if ((pPrt->PLinkSpeedCap & SK_LSPEED_CAP_1000MBPS) != 0) {
+					C1000BaseT |= PHY_M_1000C_AFD;
+#ifdef SK_DIAG
+					C1000BaseT |= PHY_M_1000C_AHD;
+#endif /* SK_DIAG */
+				}
 				AutoNegAdv |= PHY_M_AN_100_FD | PHY_M_AN_100_HD |
 					PHY_M_AN_10_FD | PHY_M_AN_10_HD;
 				break;
 			case SK_LSPEED_1000MBPS:
-				C1000BaseT |= PHY_M_1000C_AHD | PHY_M_1000C_AFD;
+				if ((pPrt->PLinkSpeedCap & SK_LSPEED_CAP_1000MBPS) != 0) {
+					C1000BaseT |= PHY_M_1000C_AFD;
+#ifdef SK_DIAG
+					C1000BaseT |= PHY_M_1000C_AHD;
+#endif /* SK_DIAG */
+				}
 				break;
 			case SK_LSPEED_100MBPS:
-				AutoNegAdv |= PHY_M_AN_100_FD | PHY_M_AN_100_HD |
-					/* advertise 10Base-T also */
-					PHY_M_AN_10_FD | PHY_M_AN_10_HD;
+				if ((pPrt->PLinkSpeedCap & SK_LSPEED_CAP_100MBPS) != 0) {
+					AutoNegAdv |= PHY_M_AN_100_FD | PHY_M_AN_100_HD |
+						/* advertise 10Base-T also */
+						PHY_M_AN_10_FD | PHY_M_AN_10_HD;
+				}
 				break;
 			case SK_LSPEED_10MBPS:
-				AutoNegAdv |= PHY_M_AN_10_FD | PHY_M_AN_10_HD;
+				if ((pPrt->PLinkSpeedCap & SK_LSPEED_CAP_10MBPS) != 0) {
+					AutoNegAdv |= PHY_M_AN_10_FD | PHY_M_AN_10_HD;
+				}
 				break;
 			default:
 				SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E019,
 					SKERR_HWI_E019MSG);
@@ -2523,9 +2646,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 			default:
 				SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E015,
 					SKERR_HWI_E015MSG);
 			}
-			
+
 			/* Set Flow-control capabilities */
 			switch (pPrt->PFlowCtrlMode) {
 			case SK_FLOW_MODE_NONE:
 				AutoNegAdv |= PHY_B_P_NO_PAUSE;
@@ -2544,9 +2667,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 					SKERR_HWI_E016MSG);
 			}
 		}
 		else {	/* special defines for FIBER (88E1011S only) */
-			
+
 			/* Set Full/half duplex capabilities */
 			switch (pPrt->PLinkMode) {
 			case SK_LMODE_AUTOHALF:
 				AutoNegAdv |= PHY_M_AN_1000X_AHD;
@@ -2560,9 +2683,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 			default:
 				SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E015,
 					SKERR_HWI_E015MSG);
 			}
-			
+
 			/* Set Flow-control capabilities */
 			switch (pPrt->PFlowCtrlMode) {
 			case SK_FLOW_MODE_NONE:
 				AutoNegAdv |= PHY_M_P_NO_PAUSE_X;
@@ -2586,48 +2709,46 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 			/* Restart Auto-negotiation */
 			PhyCtrl |= PHY_CT_ANE | PHY_CT_RE_CFG;
 		}
 	}
-	
+
 #ifdef VCPU
 	/*
 	 * E-mail from Gu Lin (08-03-2002):
 	 */
-	
+
 	/* Program PHY register 30 as 16'h0708 for simulation speed up */
 	SkGmPhyWrite(pAC, IoC, Port, 30, 0x0700 /* 0x0708 */);
-	
+
 	VCpuWait(2000);
 
 #else /* VCPU */
-	
+
 	/* Write 1000Base-T Control Register */
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_1000T_CTRL, C1000BaseT);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Set 1000B-T Ctrl =0x%04X\n", C1000BaseT));
-	
+
 	/* Write AutoNeg Advertisement Register */
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_AUNE_ADV, AutoNegAdv);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Set Auto-Neg.Adv.=0x%04X\n", AutoNegAdv));
 #endif /* VCPU */
-	
+
 	if (DoLoop) {
 		/* Set the PHY Loopback bit */
 		PhyCtrl |= PHY_CT_LOOP;
 
 #ifdef XXX
 		/* Program PHY register 16 as 16'h0400 to force link good */
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, PHY_M_PC_FL_GOOD);
-#endif /* XXX */
 
-#ifndef VCPU
 		if (pPrt->PLinkSpeed != SK_LSPEED_AUTO) {
 			/* Write Ext. PHY Specific Control */
 			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_CTRL,
 				(SK_U16)((pPrt->PLinkSpeed + 2) << 4));
 		}
-#endif /* VCPU */
+#endif /* XXX */
 	}
 #ifdef TEST_ONLY
 	else if (pPrt->PLinkSpeed == SK_LSPEED_10MBPS) {
 			/* Write PHY Specific Control */
@@ -2646,27 +2767,37 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 #else
 
 	LedCtrl = PHY_M_LED_PULS_DUR(PULS_170MS) | PHY_M_LED_BLINK_RT(BLINK_84MS);
 
-	if ((pAC->GIni.GILedBlinkCtrl & SK_ACT_LED_BLINK) != 0) {
-		LedCtrl |= PHY_M_LEDC_RX_CTRL | PHY_M_LEDC_TX_CTRL;
+	LedOver = 0;
+
+	if ((pAC->GIni.GILedBlinkCtrl & SK_ACT_LED_BLINK) != 0)  {
+		/* set Tx LED (LED_TX) to blink mode on Rx OR Tx activity */
+		LedCtrl |= PHY_M_LEDC_TX_CTRL;
+		/* turn off the Rx LED (LED_RX) */
+		LedOver |= PHY_M_LED_MO_RX(MO_LED_OFF);
 	}
 
 	if ((pAC->GIni.GILedBlinkCtrl & SK_DUP_LED_NORMAL) != 0) {
+		/* disable blink mode (LED_DUPLEX) on collisions */
 		LedCtrl |= PHY_M_LEDC_DP_CTRL;
 	}
-	
+
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_CTRL, LedCtrl);
 
 	if ((pAC->GIni.GILedBlinkCtrl & SK_LED_LINK100_ON) != 0) {
 		/* only in forced 100 Mbps mode */
 		if (!AutoNeg && pPrt->PLinkSpeed == SK_LSPEED_100MBPS) {
-
-			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_OVER,
-				PHY_M_LED_MO_100(MO_LED_ON));
+			/* turn on 100 Mbps LED (LED_LINK100) */
+			LedOver |= PHY_M_LED_MO_100(MO_LED_ON);
 		}
 	}
 
+	if (LedOver != 0) {
+		/* set Manual LED Override */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_OVER, LedOver);
+	}
+
 #ifdef SK_DIAG
 	c_print("Set PHY Ctrl=0x%04X\n", PhyCtrl);
 	c_print("Set 1000 B-T=0x%04X\n", C1000BaseT);
 	c_print("Set Auto-Neg=0x%04X\n", AutoNegAdv);
@@ -2677,32 +2808,33 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	/* Read PHY Control */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &PhyCtrl);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("PHY Ctrl Reg.=0x%04X\n", PhyCtrl));
-	
+
 	/* Read 1000Base-T Control Register */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_1000T_CTRL, &C1000BaseT);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("1000B-T Ctrl =0x%04X\n", C1000BaseT));
-	
+
 	/* Read AutoNeg Advertisement Register */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_ADV, &AutoNegAdv);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Auto-Neg.Adv.=0x%04X\n", AutoNegAdv));
-	
+
 	/* Read Ext. PHY Specific Control */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_EXT_CTRL, &ExtPhyCtrl);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Ext. PHY Ctrl=0x%04X\n", ExtPhyCtrl));
-	
+
 	/* Read PHY Status */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("PHY Stat Reg.=0x%04X\n", PhyStat));
+
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat1);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("PHY Stat Reg.=0x%04X\n", PhyStat1));
-	
+
 	/* Read PHY Specific Status */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &PhySpecStat);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("PHY Spec Stat=0x%04X\n", PhySpecStat));
@@ -2717,8 +2849,11 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	c_print("PHY Stat Reg=0x%04X\n", PhyStat1);
 	c_print("PHY Spec Reg=0x%04X\n", PhySpecStat);
 #endif /* SK_DIAG */
 
+	/* Enable all PHY interrupts */
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK,
+		(SK_U16)PHY_M_DEF_MSK);
 #endif /* VCPU */
 
 }	/* SkGmInitPhyMarv */
 #endif /* YUKON */
@@ -2736,10 +2871,10 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
  * Returns:
  *	nothing
  */
 static void SkXmInitPhyLone(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
@@ -2755,9 +2890,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 
 	/* manually Master/Slave ? */
 	if (pPrt->PMSMode != SK_MS_MODE_AUTO) {
 		Ctrl2 |= PHY_L_1000C_MSE;
-		
+
 		if (pPrt->PMSMode == SK_MS_MODE_MASTER) {
 			Ctrl2 |= PHY_L_1000C_MSC;
 		}
 	}
@@ -2777,9 +2912,8 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 		/* Determine Master/Slave manually if not already done */
 		if (pPrt->PMSMode == SK_MS_MODE_AUTO) {
 			Ctrl2 |= PHY_L_1000C_MSE;	/* set it to Slave */
 		}
-
 		/*
 		 * Do NOT enable Auto-negotiation here. This would hold
 		 * the link down because no IDLES are transmitted
 		 */
@@ -2826,14 +2960,14 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 
 		/* Restart Auto-negotiation */
 		Ctrl1 = PHY_CT_ANE | PHY_CT_RE_CFG;
 	}
-	
+
 	/* Write 1000Base-T Control Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_1000T_CTRL, Ctrl2);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("1000B-T Ctrl Reg=0x%04X\n", Ctrl2));
-	
+
 	/* Write AutoNeg Advertisement Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_AUNE_ADV, Ctrl3);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Auto-Neg.Adv.Reg=0x%04X\n", Ctrl3));
@@ -2861,10 +2995,10 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
  * Returns:
  *	nothing
  */
 static void SkXmInitPhyNat(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 /* todo: National */
@@ -2883,10 +3017,10 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
  * Returns:
  *	nothing
  */
 void SkMacInitPhy(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
@@ -2894,9 +3028,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	pPrt = &pAC->GIni.GP[Port];
 
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		switch (pPrt->PhyType) {
 		case SK_PHY_XMAC:
 			SkXmInitPhyXmac(pAC, IoC, Port, DoLoop);
 			break;
@@ -2913,12 +3047,12 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 #endif /* OTHER_PHY */
 		}
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		SkGmInitPhyMarv(pAC, IoC, Port, DoLoop);
 	}
 #endif /* YUKON */
 
@@ -2938,10 +3072,10 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
 static int SkXmAutoNegDoneXmac(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		ResAb;		/* Resolved Ability */
@@ -2957,12 +3091,12 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_RES_ABI, &ResAb);
 
 	if ((LPAb & PHY_X_AN_RFB) != 0) {
 		/* At least one of the remote fault bit is set */
-		/* Error */
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("AutoNegFail: Remote fault bit set Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
+
 		return(SK_AND_OTHER);
 	}
 
 	/* Check Duplex mismatch */
@@ -2973,9 +3107,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOHALF;
 	}
 	else {
 		/* Error */
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("AutoNegFail: Duplex mode mismatch Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		return(SK_AND_DUP_CAP);
 	}
@@ -2989,14 +3123,14 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		/* Symmetric PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_SYMMETRIC;
 	}
 	else if (pPrt->PFlowCtrlMode == SK_FLOW_MODE_SYM_OR_REM &&
-		   (LPAb & PHY_X_RS_PAUSE) == PHY_X_P_ASYM_MD) {
+		     (LPAb & PHY_X_RS_PAUSE) == PHY_X_P_ASYM_MD) {
 		/* Enable PAUSE receive, disable PAUSE transmit */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_REM_SEND;
 	}
 	else if (pPrt->PFlowCtrlMode == SK_FLOW_MODE_LOC_SEND &&
-		   (LPAb & PHY_X_RS_PAUSE) == PHY_X_P_BOTH_MD) {
+		     (LPAb & PHY_X_RS_PAUSE) == PHY_X_P_BOTH_MD) {
 		/* Disable PAUSE receive, enable PAUSE transmit */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_LOC_SEND;
 	}
 	else {
@@ -3021,10 +3155,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
 static int SkXmAutoNegDoneBcom(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		LPAb;		/* Link Partner Ability */
@@ -3044,14 +3178,14 @@ int		Port)		/* Port Index (MAC_1 + n) */
 #ifdef TEST_ONLY
 01-Sep-2000 RA;:;:
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
 #endif	/* 0 */
-	
+
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_STAT, &AuxStat);
 
 	if ((LPAb & PHY_B_AN_RF) != 0) {
 		/* Remote fault bit is set: Error */
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("AutoNegFail: Remote fault bit set Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		return(SK_AND_OTHER);
 	}
@@ -3064,25 +3198,25 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOHALF;
 	}
 	else {
 		/* Error */
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("AutoNegFail: Duplex mode mismatch Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		return(SK_AND_DUP_CAP);
 	}
-	
+
 #ifdef TEST_ONLY
 01-Sep-2000 RA;:;:
 	/* Check Master/Slave resolution */
 	if ((ResAb & PHY_B_1000S_MSF) != 0) {
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("Master/Slave Fault Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
 		return(SK_AND_OTHER);
 	}
-	
+
 	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
 		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
 #endif	/* 0 */
 
@@ -3124,10 +3258,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
 static int SkGmAutoNegDoneMarv(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		LPAb;		/* Link Partner Ability */
@@ -3141,50 +3275,49 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	/* Get PHY parameters */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_LP, &LPAb);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("Link P.Abil.=0x%04X\n", LPAb));
-	
+
 	if ((LPAb & PHY_M_AN_RF) != 0) {
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("AutoNegFail: Remote fault bit set Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		return(SK_AND_OTHER);
 	}
 
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_1000T_STAT, &ResAb);
-	
+
 	/* Check Master/Slave resolution */
 	if ((ResAb & PHY_B_1000S_MSF) != 0) {
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("Master/Slave Fault Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
 		return(SK_AND_OTHER);
 	}
-	
+
 	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
 		(SK_U8)SK_MS_STAT_MASTER : (SK_U8)SK_MS_STAT_SLAVE;
-	
+
 	/* Read PHY Specific Status */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &AuxStat);
-	
+
 	/* Check Speed & Duplex resolved */
 	if ((AuxStat & PHY_M_PS_SPDUP_RES) == 0) {
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("AutoNegFail: Speed & Duplex not resolved, Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
 		return(SK_AND_DUP_CAP);
 	}
-	
+
 	if ((AuxStat & PHY_M_PS_FULL_DUP) != 0) {
 		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOFULL;
 	}
 	else {
 		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOHALF;
 	}
-	
-	/* Check PAUSE mismatch ??? */
+
 	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
 	if ((AuxStat & PHY_M_PS_PAUSE_MSK) == PHY_M_PS_PAUSE_MSK) {
 		/* Symmetric PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_SYMMETRIC;
@@ -3200,9 +3333,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	else {
 		/* PAUSE mismatch -> no PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
 	}
-	
+
 	/* set used link speed */
 	switch ((unsigned)(AuxStat & PHY_M_PS_SPEED_MSK)) {
 	case (unsigned)PHY_M_PS_SPEED_1000:
 		pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_1000MBPS;
@@ -3213,8 +3346,20 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	default:
 		pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_10MBPS;
 	}
 
+	if ((pPrt->PFlowCtrlStatus == SK_FLOW_STAT_NONE) ||
+		/* disable Pause also for 10/100 Mbps in half duplex mode */
+		((pPrt->PLinkSpeedUsed < (SK_U8)SK_LSPEED_STAT_1000MBPS) &&
+		 pPrt->PLinkModeStatus == (SK_U8)SK_LMODE_STAT_AUTOHALF)) {
+		/* set Pause Off */
+		SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_PAUSE_OFF);
+	}
+	else {
+		/* set Pause On */
+		SK_OUT8(IoC, MR_ADDR(Port, GMAC_CTRL), (SK_U8)GMC_PAUSE_ON);
+	}
+
 	return(SK_AND_OK);
 }	/* SkGmAutoNegDoneMarv */
 #endif /* YUKON */
 
@@ -3232,10 +3377,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
 static int SkXmAutoNegDoneLone(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		ResAb;		/* Resolved Ability */
@@ -3252,10 +3397,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	SkXmPhyRead(pAC, IoC, Port, PHY_LONE_Q_STAT, &QuickStat);
 
 	if ((LPAb & PHY_L_AN_RF) != 0) {
 		/* Remote fault bit is set */
-		/* Error */
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("AutoNegFail: Remote fault bit set Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		return(SK_AND_OTHER);
 	}
@@ -3266,13 +3410,13 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	}
 	else {
 		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOHALF;
 	}
-	
+
 	/* Check Master/Slave resolution */
 	if ((ResAb & PHY_L_1000S_MSF) != 0) {
 		/* Error */
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("Master/Slave Fault Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
 		return(SK_AND_OTHER);
@@ -3287,9 +3431,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	/* Check PAUSE mismatch */
 	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
 	/* we must manually resolve the abilities here */
 	pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
-	
+
 	switch (pPrt->PFlowCtrlMode) {
 	case SK_FLOW_MODE_NONE:
 		/* default */
 		break;
@@ -3320,9 +3464,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	default:
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E016,
 			SKERR_HWI_E016MSG);
 	}
-	
+
 	return(SK_AND_OK);
 }	/* SkXmAutoNegDoneLone */
 
 
@@ -3338,10 +3482,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
 static int SkXmAutoNegDoneNat(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 /* todo: National */
 	return(SK_AND_OK);
@@ -3360,10 +3504,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
 int	SkMacAutoNegDone(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	int	Rtv;
@@ -3373,11 +3517,11 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	pPrt = &pAC->GIni.GP[Port];
 
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		switch (pPrt->PhyType) {
-		
+
 		case SK_PHY_XMAC:
 			Rtv = SkXmAutoNegDoneXmac(pAC, IoC, Port);
 			break;
 		case SK_PHY_BCOM:
@@ -3395,28 +3539,28 @@ int		Port)		/* Port Index (MAC_1 + n) */
 			return(SK_AND_OTHER);
 		}
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		Rtv = SkGmAutoNegDoneMarv(pAC, IoC, Port);
 	}
 #endif /* YUKON */
-	
+
 	if (Rtv != SK_AND_OK) {
 		return(Rtv);
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("AutoNeg done Port %d\n", Port));
-	
+
 	/* We checked everything and may now enable the link */
 	pPrt->PAutoNegFail = SK_FALSE;
 
 	SkMacRxTxEnable(pAC, IoC, Port);
-	
+
 	return(SK_AND_OK);
 }	/* SkMacAutoNegDone */
 
 
@@ -3432,9 +3576,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns: N/A
  */
 static void SkXmSetRxTxEn(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		Para)		/* Parameter to set: MAC or PHY LoopBack, Duplex Mode */
 {
 	SK_U16	Word;
@@ -3457,18 +3601,18 @@ int		Para)		/* Parameter to set: MAC or 
 	case SK_PHY_LOOPB_OFF:
 		Word &= ~XM_MMU_GMII_LOOP;
 		break;
 	}
-	
+
 	switch (Para & (SK_PHY_FULLD_ON | SK_PHY_FULLD_OFF)) {
 	case SK_PHY_FULLD_ON:
 		Word |= XM_MMU_GMII_FD;
 		break;
 	case SK_PHY_FULLD_OFF:
 		Word &= ~XM_MMU_GMII_FD;
 		break;
 	}
-	
+
 	XM_OUT16(IoC, Port, XM_MMU_CMD, Word | XM_MMU_ENA_RX | XM_MMU_ENA_TX);
 
 	/* dummy read to ensure writing */
 	XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
@@ -3489,14 +3633,14 @@ int		Para)		/* Parameter to set: MAC or 
  * Returns: N/A
  */
 static void SkGmSetRxTxEn(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		Para)		/* Parameter to set: MAC LoopBack, Duplex Mode */
 {
 	SK_U16	Ctrl;
-	
+
 	GM_IN16(IoC, Port, GM_GP_CTRL, &Ctrl);
 
 	switch (Para & (SK_MAC_LOOPB_ON | SK_MAC_LOOPB_OFF)) {
 	case SK_MAC_LOOPB_ON:
@@ -3514,14 +3658,15 @@ int		Para)		/* Parameter to set: MAC Loo
 	case SK_PHY_FULLD_OFF:
 		Ctrl &= ~GM_GPCR_DUP_FULL;
 		break;
 	}
-	
-    GM_OUT16(IoC, Port, GM_GP_CTRL, (SK_U16)(Ctrl | GM_GPCR_RX_ENA |
-		GM_GPCR_TX_ENA));
 
+	GM_OUT16(IoC, Port, GM_GP_CTRL, Ctrl | GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);
+
+#ifdef XXX
 	/* dummy read to ensure writing */
 	GM_IN16(IoC, Port, GM_GP_CTRL, &Ctrl);
+#endif /* XXX */
 
 }	/* SkGmSetRxTxEn */
 #endif /* YUKON */
 
@@ -3536,22 +3681,22 @@ int		Para)		/* Parameter to set: MAC Loo
  * Returns: N/A
  */
 void SkMacSetRxTxEn(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 int		Para)
 {
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		SkXmSetRxTxEn(pAC, IoC, Port, Para);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		SkGmSetRxTxEn(pAC, IoC, Port, Para);
 	}
 #endif /* YUKON */
 
@@ -3569,10 +3714,10 @@ int		Para)
  *	0	o.k.
  *	!= 0	Error happened
  */
 int SkMacRxTxEnable(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		Reg;		/* 16-bit register value */
@@ -3588,22 +3733,22 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		return(0);
 	}
 
 	if ((pPrt->PLinkMode == SK_LMODE_AUTOHALF ||
-	     pPrt->PLinkMode == SK_LMODE_AUTOFULL ||
-	     pPrt->PLinkMode == SK_LMODE_AUTOBOTH) &&
-	     pPrt->PAutoNegFail) {
+		 pPrt->PLinkMode == SK_LMODE_AUTOFULL ||
+		 pPrt->PLinkMode == SK_LMODE_AUTOBOTH) &&
+		 pPrt->PAutoNegFail) {
 		/* Auto-negotiation is not done or failed */
 		return(0);
 	}
 
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* set Duplex Mode and Pause Mode */
 		SkXmInitDupMd(pAC, IoC, Port);
-		
+
 		SkXmInitPauseMd(pAC, IoC, Port);
-	
+
 		/*
 		 * Initialize the Interrupt Mask Register. Default IRQs are...
 		 *	- Link Asynchronous Event
 		 *	- Link Partner requests config
@@ -3617,25 +3762,25 @@ int		Port)		/* Port Index (MAC_1 + n) */
 #ifdef DEBUG
 		/* add IRQ for Receive FIFO Overflow */
 		IntMask &= ~XM_IS_RXF_OV;
 #endif /* DEBUG */
-		
+
 		if (pPrt->PhyType != SK_PHY_XMAC) {
 			/* disable GP0 interrupt bit */
 			IntMask |= XM_IS_INP_ASS;
 		}
 		XM_OUT16(IoC, Port, XM_IMSK, IntMask);
-	
+
 		/* get MMU Command Reg. */
 		XM_IN16(IoC, Port, XM_MMU_CMD, &Reg);
-		
+
 		if (pPrt->PhyType != SK_PHY_XMAC &&
 			(pPrt->PLinkModeStatus == SK_LMODE_STAT_FULL ||
 			 pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOFULL)) {
 			/* set to Full Duplex */
 			Reg |= XM_MMU_GMII_FD;
 		}
-		
+
 		switch (pPrt->PhyType) {
 		case SK_PHY_BCOM:
 			/*
 			 * Workaround BCOM Errata (#10523) for all BCom Phys
@@ -3643,9 +3788,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 			 */
 			SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &SWord);
 			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUX_CTRL,
 				(SK_U16)(SWord & ~PHY_B_AC_DIS_PM));
-            SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_INT_MASK,
+			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_INT_MASK,
 				(SK_U16)PHY_B_DEF_MSK);
 			break;
 #ifdef OTHER_PHY
 		case SK_PHY_LONE:
@@ -3657,14 +3802,14 @@ int		Port)		/* Port Index (MAC_1 + n) */
 			/* no interrupts possible from National ??? */
 			break;
 #endif /* OTHER_PHY */
 		}
-		
+
 		/* enable Rx/Tx */
 		XM_OUT16(IoC, Port, XM_MMU_CMD, Reg | XM_MMU_ENA_RX | XM_MMU_ENA_TX);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
 		/*
 		 * Initialize the Interrupt Mask Register. Default IRQs are...
@@ -3677,32 +3822,30 @@ int		Port)		/* Port Index (MAC_1 + n) */
 #ifdef DEBUG
 		/* add IRQ for Receive FIFO Overrun */
 		IntMask |= GM_IS_RX_FF_OR;
 #endif /* DEBUG */
-		
-		SK_OUT8(IoC, GMAC_IRQ_MSK, (SK_U8)IntMask);
-		
+
+		SK_OUT8(IoC, MR_ADDR(Port, GMAC_IRQ_MSK), (SK_U8)IntMask);
+
 		/* get General Purpose Control */
 		GM_IN16(IoC, Port, GM_GP_CTRL, &Reg);
-		
+
 		if (pPrt->PLinkModeStatus == SK_LMODE_STAT_FULL ||
 			pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOFULL) {
 			/* set to Full Duplex */
 			Reg |= GM_GPCR_DUP_FULL;
 		}
-		
+
 		/* enable Rx/Tx */
-        GM_OUT16(IoC, Port, GM_GP_CTRL, (SK_U16)(Reg | GM_GPCR_RX_ENA |
-			GM_GPCR_TX_ENA));
+		GM_OUT16(IoC, Port, GM_GP_CTRL, Reg | GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);
 
-#ifndef VCPU
-		/* Enable all PHY interrupts */
-        SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK,
-			(SK_U16)PHY_M_DEF_MSK);
-#endif /* VCPU */
+#ifdef XXX
+		/* dummy read to ensure writing */
+		GM_IN16(IoC, Port, GM_GP_CTRL, &Reg);
+#endif /* XXX */
 	}
 #endif /* YUKON */
-					
+
 	return(0);
 
 }	/* SkMacRxTxEnable */
 
@@ -3716,35 +3859,40 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns: N/A
  */
 void SkMacRxTxDisable(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_U16	Word;
 
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
-		
-		XM_OUT16(IoC, Port, XM_MMU_CMD, Word & ~(XM_MMU_ENA_RX | XM_MMU_ENA_TX));
-	
+
+		Word &= ~(XM_MMU_ENA_RX | XM_MMU_ENA_TX);
+
+		XM_OUT16(IoC, Port, XM_MMU_CMD, Word);
+
 		/* dummy read to ensure writing */
 		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
-		
+
 		GM_IN16(IoC, Port, GM_GP_CTRL, &Word);
 
-        GM_OUT16(IoC, Port, GM_GP_CTRL, (SK_U16)(Word & ~(GM_GPCR_RX_ENA |
-			GM_GPCR_TX_ENA)));
+		Word &= ~(GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);
+
+		GM_OUT16(IoC, Port, GM_GP_CTRL, Word);
 
+#ifdef XXX
 		/* dummy read to ensure writing */
 		GM_IN16(IoC, Port, GM_GP_CTRL, &Word);
+#endif /* XXX */
 	}
 #endif /* YUKON */
 
 }	/* SkMacRxTxDisable */
@@ -3759,9 +3907,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns: N/A
  */
 void SkMacIrqDisable(
 SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* IO context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 #ifdef GENESIS
@@ -3771,12 +3919,12 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	pPrt = &pAC->GIni.GP[Port];
 
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		
+
 		/* disable all XMAC IRQs */
-		XM_OUT16(IoC, Port, XM_IMSK, 0xffff);	
-		
+		XM_OUT16(IoC, Port, XM_IMSK, 0xffff);
+
 		/* Disable all PHY interrupts */
 		switch (pPrt->PhyType) {
 			case SK_PHY_BCOM:
 				/* Make sure that PHY is initialized */
@@ -3801,14 +3949,14 @@ int		Port)		/* Port Index (MAC_1 + n) */
 #endif /* OTHER_PHY */
 		}
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
 		/* disable all GMAC IRQs */
-		SK_OUT8(IoC, GMAC_IRQ_MSK, 0);
-		
+		SK_OUT8(IoC, MR_ADDR(Port, GMAC_IRQ_MSK), 0);
+
 #ifndef VCPU
 		/* Disable all PHY interrupts */
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK, 0);
 #endif /* VCPU */
@@ -3828,10 +3976,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkXmSendCont(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port,	/* Port Index (MAC_1 + n) */
 SK_BOOL	Enable)	/* Enable / Disable */
 {
 	SK_U32	MdReg;
@@ -3859,10 +4007,10 @@ SK_BOOL	Enable)	/* Enable / Disable */
  * Returns:
  *	nothing
  */
 void SkMacTimeStamp(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* I/O Context */
 int		Port,	/* Port Index (MAC_1 + n) */
 SK_BOOL	Enable)	/* Enable / Disable */
 {
 	SK_U32	MdReg;
@@ -3905,10 +4053,10 @@ SK_BOOL	Enable)	/* Enable / Disable */
  *	Auto-negotiating interrupt bits are set, the PLipaAutoNeg variable
  *	is set true.
  */
 void SkXmAutoNegLipaXmac(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_U16	IStatus)	/* Interrupt Status word to analyse */
 {
 	SK_GEPORT	*pPrt;
@@ -3935,10 +4083,10 @@ SK_U16	IStatus)	/* Interrupt Status word
  *  If any of the Auto-negotiating bits are set, the PLipaAutoNeg variable
  *	is set true.
  */
 void SkMacAutoNegLipaPhy(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_U16	PhyStat)	/* PHY Status word to analyse */
 {
 	SK_GEPORT	*pPrt;
@@ -3976,24 +4124,24 @@ SK_U16	PhyStat)	/* PHY Status word to an
  * Returns:
  *	nothing
  */
 void SkXmIrq(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_EVPARA	Para;
 	SK_U16		IStatus;	/* Interrupt status read from the XMAC */
 	SK_U16		IStatus2;
 #ifdef SK_SLIM
     SK_U64      OverflowStatus;
-#endif	
+#endif
 
 	pPrt = &pAC->GIni.GP[Port];
-	
+
 	XM_IN16(IoC, Port, XM_ISRC, &IStatus);
-	
+
 	/* LinkPartner Auto-negable? */
 	if (pPrt->PhyType == SK_PHY_XMAC) {
 		SkXmAutoNegLipaXmac(pAC, IoC, Port, IStatus);
 	}
@@ -4002,9 +4150,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		IStatus &= ~(XM_IS_LNK_AE | XM_IS_LIPA_RC |
 			XM_IS_RX_PAGE | XM_IS_TX_PAGE |
 			XM_IS_AND | XM_IS_INP_ASS);
 	}
-	
+
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 		("XmacIrq Port %d Isr 0x%04X\n", Port, IStatus));
 
 	if (!pPrt->PHWLinkUp) {
@@ -4112,42 +4260,42 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkGmIrq(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U8		IStatus;	/* Interrupt status */
 #ifdef SK_SLIM
-    SK_U64      OverflowStatus;
+	SK_U64		OverflowStatus;
 #else
 	SK_EVPARA	Para;
-#endif	
+#endif
 
 	pPrt = &pAC->GIni.GP[Port];
-	
-	SK_IN8(IoC, GMAC_IRQ_SRC, &IStatus);
-	
+
+	SK_IN8(IoC, MR_ADDR(Port, GMAC_IRQ_SRC), &IStatus);
+
 #ifdef XXX
 	/* LinkPartner Auto-negable? */
 	SkMacAutoNegLipaPhy(pAC, IoC, Port, IStatus);
 #endif /* XXX */
-	
+
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-		("GmacIrq Port %d Isr 0x%04X\n", Port, IStatus));
+		("GmacIrq Port %d Isr 0x%02X\n", Port, IStatus));
 
 	/* Combined Tx & Rx Counter Overflow SIRQ Event */
 	if (IStatus & (GM_IS_RX_CO_OV | GM_IS_TX_CO_OV)) {
 		/* these IRQs will be cleared by reading GMACs register */
 #ifdef SK_SLIM
-        SkGmOverflowStatus(pAC, IoC, Port, IStatus, &OverflowStatus);
+		SkGmOverflowStatus(pAC, IoC, Port, (SK_U16)IStatus, &OverflowStatus);
 #else
 		Para.Para32[0] = (SK_U32)Port;
 		Para.Para32[1] = (SK_U32)IStatus;
 		SkPnmiEvent(pAC, IoC, SK_PNMI_EVT_SIRQ_OVERFLOW, Para);
-#endif		
+#endif
 	}
 
 	if (IStatus & GM_IS_RX_FF_OR) {
 		/* clear GMAC Rx FIFO Overrun IRQ */
@@ -4184,19 +4332,19 @@ int		Port)		/* Port Index (MAC_1 + n) */
  * Returns:
  *	nothing
  */
 void SkMacIrq(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* IRQ from XMAC */
 		SkXmIrq(pAC, IoC, Port);
 	}
 #endif /* GENESIS */
-	
+
 #ifdef YUKON
 	if (pAC->GIni.GIYukon) {
 		/* IRQ from GMAC */
 		SkGmIrq(pAC, IoC, Port);
@@ -4221,10 +4369,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
  *	0:  success
  *	1:  something went wrong
  */
 int SkXmUpdateStats(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 unsigned int Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		StatReg;
@@ -4244,17 +4392,17 @@ unsigned int Port)	/* Port Index (MAC_1 
 	 */
 	do {
 
 		XM_IN16(IoC, Port, XM_STAT_CMD, &StatReg);
-		
+
 		if (++WaitIndex > 10) {
 
 			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_HWI_E021, SKERR_HWI_E021MSG);
 
 			return(1);
 		}
 	} while ((StatReg & (XM_SC_SNP_TXC | XM_SC_SNP_RXC)) != 0);
-	
+
 	return(0);
 }	/* SkXmUpdateStats */
 
 
@@ -4271,21 +4419,21 @@ unsigned int Port)	/* Port Index (MAC_1 
  *	0:  success
  *	1:  something went wrong
  */
 int SkXmMacStatistic(
-SK_AC	*pAC,			/* adapter context */
-SK_IOC	IoC,			/* IO context */
+SK_AC	*pAC,			/* Adapter Context */
+SK_IOC	IoC,			/* I/O Context */
 unsigned int Port,		/* Port Index (MAC_1 + n) */
 SK_U16	StatAddr,		/* MIB counter base address */
-SK_U32	SK_FAR *pVal)	/* ptr to return statistic value */
+SK_U32	SK_FAR *pVal)	/* Pointer to return statistic value */
 {
 	if ((StatAddr < XM_TXF_OK) || (StatAddr > XM_RXF_MAX_SZ)) {
-		
+
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E022, SKERR_HWI_E022MSG);
-		
+
 		return(1);
 	}
-	
+
 	XM_IN32(IoC, Port, StatAddr, pVal);
 
 	return(0);
 }	/* SkXmMacStatistic */
@@ -4302,14 +4450,14 @@ SK_U32	SK_FAR *pVal)	/* ptr to return st
  *	0:  success
  *	1:  something went wrong
  */
 int SkXmResetCounter(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 unsigned int Port)	/* Port Index (MAC_1 + n) */
 {
 	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_CLR_RXC | XM_SC_CLR_TXC);
-	/* Clear two times according to Errata #3 */
+	/* Clear two times according to XMAC Errata #3 */
 	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_CLR_RXC | XM_SC_CLR_TXC);
 
 	return(0);
 }	/* SkXmResetCounter */
@@ -4334,13 +4482,13 @@ unsigned int Port)	/* Port Index (MAC_1 
  *	0:  success
  *	1:  something went wrong
  */
 int SkXmOverflowStatus(
-SK_AC	*pAC,				/* adapter context */
-SK_IOC	IoC,				/* IO context */
+SK_AC	*pAC,				/* Adapter Context */
+SK_IOC	IoC,				/* I/O Context */
 unsigned int Port,			/* Port Index (MAC_1 + n) */
-SK_U16	IStatus,			/* Interupt Status from MAC */
-SK_U64	SK_FAR *pStatus)	/* ptr for return overflow status value */
+SK_U16	IStatus,			/* Interrupt Status from MAC */
+SK_U64	SK_FAR *pStatus)	/* Pointer for return overflow status value */
 {
 	SK_U64	Status;	/* Overflow status */
 	SK_U32	RegVal;
 
@@ -4350,9 +4498,9 @@ SK_U64	SK_FAR *pStatus)	/* ptr for retur
 
 		XM_IN32(IoC, Port, XM_RX_CNT_EV, &RegVal);
 		Status |= (SK_U64)RegVal << 32;
 	}
-	
+
 	if ((IStatus & XM_IS_TXC_OV) != 0) {
 
 		XM_IN32(IoC, Port, XM_TX_CNT_EV, &RegVal);
 		Status |= (SK_U64)RegVal;
@@ -4377,10 +4525,10 @@ SK_U64	SK_FAR *pStatus)	/* ptr for retur
  *	0:  success
  *	1:  something went wrong
  */
 int SkGmUpdateStats(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 unsigned int Port)	/* Port Index (MAC_1 + n) */
 {
 	return(0);
 }
@@ -4399,26 +4547,29 @@ unsigned int Port)	/* Port Index (MAC_1 
  *	0:  success
  *	1:  something went wrong
  */
 int SkGmMacStatistic(
-SK_AC	*pAC,			/* adapter context */
-SK_IOC	IoC,			/* IO context */
+SK_AC	*pAC,			/* Adapter Context */
+SK_IOC	IoC,			/* I/O Context */
 unsigned int Port,		/* Port Index (MAC_1 + n) */
 SK_U16	StatAddr,		/* MIB counter base address */
-SK_U32	SK_FAR *pVal)	/* ptr to return statistic value */
+SK_U32	SK_FAR *pVal)	/* Pointer to return statistic value */
 {
 
 	if ((StatAddr < GM_RXF_UC_OK) || (StatAddr > GM_TXE_FIFO_UR)) {
-		
+
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E022, SKERR_HWI_E022MSG);
-		
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
 			("SkGmMacStat: wrong MIB counter 0x%04X\n", StatAddr));
 		return(1);
 	}
-		
+
 	GM_IN32(IoC, Port, StatAddr, pVal);
 
+	/* dummy read */
+	SK_IN16(IoC, B0_RAP, &StatAddr);
+
 	return(0);
 }	/* SkGmMacStatistic */
 
 
@@ -4433,10 +4584,10 @@ SK_U32	SK_FAR *pVal)	/* ptr to return st
  *	0:  success
  *	1:  something went wrong
  */
 int SkGmResetCounter(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
 unsigned int Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_U16	Reg;	/* Phy Address Register */
 	SK_U16	Word;
@@ -4445,18 +4596,18 @@ unsigned int Port)	/* Port Index (MAC_1 
 	GM_IN16(IoC, Port, GM_PHY_ADDR, &Reg);
 
 	/* set MIB Clear Counter Mode */
 	GM_OUT16(IoC, Port, GM_PHY_ADDR, Reg | GM_PAR_MIB_CLR);
-	
+
 	/* read all MIB Counters with Clear Mode set */
 	for (i = 0; i < GM_MIB_CNT_SIZE; i++) {
 		/* the reset is performed only when the lower 16 bits are read */
 		GM_IN16(IoC, Port, GM_MIB_CNT_BASE + 8*i, &Word);
 	}
-	
+
 	/* clear MIB Clear Counter Mode */
 	GM_OUT16(IoC, Port, GM_PHY_ADDR, Reg);
-	
+
 	return(0);
 }	/* SkGmResetCounter */
 
 
@@ -4468,50 +4619,64 @@ unsigned int Port)	/* Port Index (MAC_1 
  *	Checks the source causing an counter overflow interrupt. On success the
  *	resulting counter overflow status is written to <pStatus>, whereas the
  *	the following bit coding is used:
  *	63:56 - unused
- *	55:48 - TxRx interrupt register bit7:0
- *	32:47 - Rx interrupt register
+ *	55:48 - TxRx interrupt register bit 7:0
+ *	47:32 - Rx interrupt register
  *	31:24 - unused
- *	23:16 - TxRx interrupt register bit15:8
- *	15:0  - Tx interrupt register
+ *	23:16 - TxRx interrupt register bit 15:8
+ *	15: 0 - Tx interrupt register
  *
  * Returns:
  *	0:  success
  *	1:  something went wrong
  */
 int SkGmOverflowStatus(
-SK_AC	*pAC,				/* adapter context */
-SK_IOC	IoC,				/* IO context */
+SK_AC	*pAC,				/* Adapter Context */
+SK_IOC	IoC,				/* I/O Context */
 unsigned int Port,			/* Port Index (MAC_1 + n) */
-SK_U16	IStatus,			/* Interupt Status from MAC */
-SK_U64	SK_FAR *pStatus)	/* ptr for return overflow status value */
+SK_U16	IStatus,			/* Interrupt Status from MAC */
+SK_U64	SK_FAR *pStatus)	/* Pointer for return overflow status value */
 {
-	SK_U64	Status;		/* Overflow status */
 	SK_U16	RegVal;
+#ifndef SK_SLIM
+	SK_U64	Status;		/* Overflow status */
 
 	Status = 0;
+#endif /* !SK_SLIM */
 
 	if ((IStatus & GM_IS_RX_CO_OV) != 0) {
 		/* this register is self-clearing after read */
 		GM_IN16(IoC, Port, GM_RX_IRQ_SRC, &RegVal);
+
+#ifndef SK_SLIM
 		Status |= (SK_U64)RegVal << 32;
+#endif /* !SK_SLIM */
 	}
-	
+
 	if ((IStatus & GM_IS_TX_CO_OV) != 0) {
 		/* this register is self-clearing after read */
 		GM_IN16(IoC, Port, GM_TX_IRQ_SRC, &RegVal);
+
+#ifndef SK_SLIM
 		Status |= (SK_U64)RegVal;
+#endif /* !SK_SLIM */
 	}
-	
+
 	/* this register is self-clearing after read */
 	GM_IN16(IoC, Port, GM_TR_IRQ_SRC, &RegVal);
+
+#ifndef SK_SLIM
 	/* Rx overflow interrupt register bits (LoByte)*/
 	Status |= (SK_U64)((SK_U8)RegVal) << 48;
 	/* Tx overflow interrupt register bits (HiByte)*/
 	Status |= (SK_U64)(RegVal >> 8) << 16;
 
 	*pStatus = Status;
+#endif /* !SK_SLIM */
+
+	/* dummy read */
+	SK_IN16(IoC, B0_RAP, &RegVal);
 
 	return(0);
 }	/* SkGmOverflowStatus */
 
@@ -4525,17 +4690,17 @@ SK_U64	SK_FAR *pStatus)	/* ptr for retur
  *  starts the cable diagnostic test if 'StartTest' is true
  *  gets the results if 'StartTest' is true
  *
  * NOTE:	this test is meaningful only when link is down
- *	
+ *
  * Returns:
  *	0:  success
  *	1:	no YUKON copper
  *	2:	test in progress
  */
 int SkGmCableDiagStatus(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,   		/* IO context */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,   		/* I/O Context */
 int		Port,		/* Port Index (MAC_1 + n) */
 SK_BOOL	StartTest)	/* flag for start / get result */
 {
 	int		i;
@@ -4544,18 +4709,19 @@ SK_BOOL	StartTest)	/* flag for start / g
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	if (pPrt->PhyType != SK_PHY_MARV_COPPER) {
-		
+
 		return(1);
 	}
 
 	if (StartTest) {
 		/* only start the cable test */
-		if ((pPrt->PhyId1 & PHY_I1_REV_MSK) < 4) {
-			/* apply TDR workaround from Marvell */
+		if ((((pPrt->PhyId1 & PHY_I1_MOD_NUM) >> 4) == 2) &&
+			 ((pPrt->PhyId1 & PHY_I1_REV_MSK) < 4)) {
+			/* apply TDR workaround for model 2, rev. < 4 */
 			SkGmPhyWrite(pAC, IoC, Port, 29, 0x001e);
-			
+
 			SkGmPhyWrite(pAC, IoC, Port, 30, 0xcc00);
 			SkGmPhyWrite(pAC, IoC, Port, 30, 0xc800);
 			SkGmPhyWrite(pAC, IoC, Port, 30, 0xc400);
 			SkGmPhyWrite(pAC, IoC, Port, 30, 0xc000);
@@ -4567,15 +4733,16 @@ SK_BOOL	StartTest)	/* flag for start / g
 
 		/* Read Cable Diagnostic Reg */
 		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CABLE_DIAG, &RegVal);
 
+		RegVal |= PHY_M_CABD_ENA_TEST;
+
 		/* start Cable Diagnostic Test */
-		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CABLE_DIAG,
-			(SK_U16)(RegVal | PHY_M_CABD_ENA_TEST));
-	
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CABLE_DIAG, RegVal);
+
 		return(0);
 	}
-	
+
 	/* Read Cable Diagnostic Reg */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CABLE_DIAG, &RegVal);
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
@@ -4604,4 +4771,5 @@ SK_BOOL	StartTest)	/* flag for start / g
 #endif /* !SK_SLIM */
 #endif /* YUKON */
 
 /* End of file */
+
Index: linux-2.6.8/drivers/net/sk98lin/sky2.c
===================================================================
--- /dev/null
+++ linux-2.6.8/drivers/net/sk98lin/sky2.c
@@ -0,0 +1,2555 @@
+/******************************************************************************
+ *
+ * Name:	sky2.c
+ * Project:	Yukon2 specific functions and implementations
+ * Version:	$Revision: 1.25 $
+ * Date:       	$Date: 2004/06/15 10:49:23 $
+ * Purpose:	The main driver source module
+ *
+ *****************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
+ *
+ *	Driver for Marvell Yukon/2 chipset and SysKonnect Gigabit Ethernet 
+ *      Server Adapters.
+ *
+ *	Created 26-jan-2004
+ *	Author: Ralph Roesler (rroesler@syskonnect.de)
+ *	        Mirko Lindner (mlindner@syskonnect.de)
+ *
+ *	Address all question to: linux@syskonnect.de
+ *
+ *	The technical manual for the adapters is available from SysKonnect's
+ *	web pages: www.syskonnect.com
+ *	
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ *****************************************************************************/
+
+#include	"h/skdrv1st.h"
+#include	"h/skdrv2nd.h"
+
+/******************************************************************************
+ *
+ * Defines
+ *
+ *****************************************************************************/
+
+/* use the transmit hw checksum driver functionality */
+#define USE_SK_TX_CHECKSUM
+
+/* use the receive hw checksum driver functionality */
+#define USE_SK_RX_CHECKSUM
+
+/******************************************************************************
+ *
+ * Local Function Prototypes
+ *
+ *****************************************************************************/
+
+static void InitPacketQueues(SK_AC *pAC,int Port);
+static void GiveRxBufferToHw(SK_AC *pAC,SK_IOC IoC,int Port,SK_PACKET *pPacket);
+static void FillReceiveTableYukon2(SK_AC *pAC,SK_IOC IoC,int Port);
+static SK_BOOL HandleReceives(SK_AC *pAC,int Port,SK_U16 Len,SK_U32 FrameStatus,SK_U16 Tcp1,SK_U16 Tcp2,SK_U32 Tist,SK_U16 Vlan);
+static void CheckForSendComplete(SK_AC *pAC,SK_IOC IoC,int Port,SK_PKT_QUEUE *pPQ,SK_LE_TABLE *pLETab,unsigned int Done);
+static void UnmapAndFreeTxPktBuffer(SK_AC *pAC,SK_PACKET *pSkPacket,int TxPort);
+static SK_BOOL AllocateAndInitLETables(SK_AC *pAC);
+static SK_BOOL AllocatePacketBuffersYukon2(SK_AC *pAC);
+static void FreeLETables(SK_AC *pAC);
+static void FreePacketBuffers(SK_AC *pAC);
+static SK_BOOL AllocAndMapRxBuffer(SK_AC *pAC,SK_PACKET *pSkPacket,int Port);
+#ifdef CONFIG_SK98LIN_NAPI
+static SK_BOOL HandleStatusLEs(SK_AC *pAC,int *WorkDone,int WorkToDo);
+#else
+static SK_BOOL HandleStatusLEs(SK_AC *pAC);
+#endif
+
+/******************************************************************************
+ *
+ * Local Variables
+ *
+ *****************************************************************************/
+
+#define MAX_NBR_RX_BUFFERS_IN_HW	0x15
+static SK_U8 NbrRxBuffersInHW;
+
+#if defined(__i386__) || defined(__x86_64__)
+// Investigate faster method, because using 'wbinvd' costs too much time...
+// #define FLUSH_OPC(le)   asm volatile ("wbinvd":::"memory");
+#define FLUSH_OPC(le)
+#else
+#define FLUSH_OPC(le) 
+#endif
+
+/******************************************************************************
+ *
+ * Extern Function Prototypes
+ *
+ *****************************************************************************/
+
+/******************************************************************************
+ *
+ * Extern Variables
+ *
+ *****************************************************************************/
+
+/******************************************************************************
+ *
+ * Global Functions
+ *
+ *****************************************************************************/
+
+int SkY2Xmit( struct sk_buff *skb, struct SK_NET_DEVICE *dev); 
+
+/*****************************************************************************
+ *
+ * 	SkY2RestartStatusUnit - restarts teh status unit
+ *
+ * Description:
+ *	Reenables the status unit after any De-Init (e.g. when altering 
+ *	the sie of the MTU via 'ifconfig a.b.c.d mtu xxx')
+ *
+ * Returns:	N/A
+ */
+
+void SkY2RestartStatusUnit(
+SK_AC	*pAC)   /* pointer to adapter control context */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("==> SkY2RestartStatusUnit\n"));
+
+	/*
+	** It might be that the TX timer is not started. Therefore
+	** it is initialized here -> to be more investigated!
+	*/
+	SK_OUT32(pAC->IoBase, STAT_TX_TIMER_INI, HW_MS_TO_TICKS(pAC,10));
+
+	pAC->StatusLETable.Done  = 0;
+	pAC->StatusLETable.Put   = 0;
+	pAC->StatusLETable.HwPut = 0;
+	SkGeY2InitStatBmu(pAC, pAC->IoBase, &pAC->StatusLETable);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("<== SkY2RestartStatusUnit\n"));
+}
+
+/*****************************************************************************
+ *
+ * 	SkY2RlmtSend - sends out a single RLMT notification
+ *
+ * Description:
+ *	This function sends out an RLMT frame
+ *
+ * Returns:	
+ *	> 0 - on succes: the number of bytes in the message
+ *	= 0 - on resource shortage: this frame sent or dropped, now
+ *	      the ring is full ( -> set tbusy)
+ *	< 0 - on failure: other problems ( -> return failure to upper layers)
+ */
+
+int SkY2RlmtSend (
+SK_AC          *pAC,       /* pointer to adapter control context           */
+int             PortNr,    /* index of port the packet(s) shall be send to */
+struct sk_buff *pMessage)  /* pointer to send-message                      */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("=== SkY2RlmtSend\n"));
+	return -1;   // temporarily do not send out RLMT frames
+#if 0
+	return(SkY2Xmit(pMessage, pAC->dev[PortNr])); SkY2Xmit needs device
+#endif
+}
+
+/*****************************************************************************
+ *
+ * 	SkY2AllocateResources - Allocates all required resources for Yukon2
+ *
+ * Description:
+ *	This function allocates all memory needed for the Yukon2. 
+ *	It maps also RX buffers to the LETables and initializes the
+ *	status list element table.
+ *
+ * Returns:	
+ *	SK_TRUE, if all resources could be allocated and setup succeeded
+ *	SK_FALSE, if an error 
+ */
+SK_BOOL SkY2AllocateResources (
+SK_AC   *pAC)   /* pointer to adapter control context */
+{
+	int i;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("==> SkY2AllocateResources\n"));
+
+	/*
+	** Initialize the packet queue variables first
+	*/
+	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
+		InitPacketQueues(pAC, i);
+	}
+
+	/* 
+	** Get sufficient memory for the LETables
+	*/
+	if (!AllocateAndInitLETables(pAC)) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+			SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+			("No memory for LETable.\n"));
+		return(SK_FALSE);
+	}
+
+	/*
+	** Allocate and intialize memory for both RX and TX 
+	** packet and fragment buffers. On an error, free 
+	** previously allocated LETable memory and quit.
+	*/
+	if (!AllocatePacketBuffersYukon2(pAC)) {
+		FreeLETables(pAC);
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+			SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+			("No memory for Packetbuffers.\n"));
+		return(SK_FALSE);
+	}
+
+	/* 
+	** Rx and Tx LE tables will be initialized in SkGeOpen() 
+	**
+	** It might be that the TX timer is not started. Therefore
+	** it is initialized here -> to be more investigated!
+	*/
+	SK_OUT32(pAC->IoBase, STAT_TX_TIMER_INI, HW_MS_TO_TICKS(pAC,10));
+	SkGeY2InitStatBmu(pAC, pAC->IoBase, &pAC->StatusLETable);
+
+	pAC->MaxUnusedRxLeWorking = MAX_UNUSED_RX_LE_WORKING;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("<== SkY2AllocateResources\n"));
+
+	return (SK_TRUE);
+}
+
+/*****************************************************************************
+ *
+ * 	SkY2FreeResources - Frees previously allocated resources of Yukon2
+ *
+ * Description:
+ *	This function frees all previously allocated memory of the Yukon2. 
+ *
+ * Returns: N/A
+ */
+void SkY2FreeResources (
+SK_AC   *pAC)   /* pointer to adapter control context */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("==> SkY2FreeResources\n"));
+
+	FreeLETables(pAC);
+	FreePacketBuffers(pAC);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("<== SkY2FreeResources\n"));
+}
+
+/*****************************************************************************
+ *
+ * 	SkY2AllocateRxBuffers - Allocates the receive buffers for a port
+ *
+ * Description:
+ *	This function allocated all the RX buffers of the Yukon2. 
+ *
+ * Returns: N/A
+ */
+void SkY2AllocateRxBuffers (
+SK_AC    *pAC,   /* pointer to adapter control context */
+SK_IOC    IoC,	 /* I/O control context                */
+int       Port)	 /* port index of RX                   */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("==> SkY2AllocateRxBuffers (Port %c)\n", Port));
+
+	FillReceiveTableYukon2(pAC, IoC, Port);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("<== SkY2AllocateRxBuffers\n"));
+}
+
+/*****************************************************************************
+ *
+ * 	SkY2FreeRxBuffers - Free's all allocates RX buffers of
+ *
+ * Description:
+ *	This function frees all RX buffers of the Yukon2 for a single port
+ *
+ * Returns: N/A
+ */
+void SkY2FreeRxBuffers (
+SK_AC    *pAC,   /* pointer to adapter control context */
+SK_IOC    IoC,	 /* I/O control context                */
+int       Port)	 /* port index of RX                   */
+{
+	SK_PACKET	*pSkPacket;
+	unsigned long	 Flags;		/* for macro spinlocks */
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("==> SkY2FreeRxBuffers (Port %c)\n", Port));
+
+	if ((pAC->RxPort[Port].ReceivePacketTable   != NULL) && 
+	    (pAC->RxPort[Port].ReceiveFragmentTable != NULL)) {
+		POP_FIRST_PKT_FROM_QUEUE(&pAC->RxPort[Port].RxQ_working, pSkPacket);
+		while (pSkPacket != NULL) {
+			if ((pSkPacket->pFrag) != NULL) {
+				pci_unmap_page(pAC->PciDev,
+				(dma_addr_t) pSkPacket->pFrag->pPhys,
+				pSkPacket->pFrag->FragLen - 2,
+				PCI_DMA_FROMDEVICE);
+
+				DEV_KFREE_SKB_ANY(pSkPacket->pMBuf);
+				pSkPacket->pMBuf        = NULL;
+				pSkPacket->pFrag->pPhys = (SK_U64) 0;
+				pSkPacket->pFrag->pVirt = NULL;
+			}
+			PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pSkPacket);
+			POP_FIRST_PKT_FROM_QUEUE(&pAC->RxPort[Port].RxQ_working, pSkPacket);
+		}
+	}
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("<== SkY2FreeRxBuffers\n"));
+}
+
+/*****************************************************************************
+ *
+ * 	SkY2FreeTxBuffers - Free's any currently maintained Tx buffer
+ *
+ * Description:
+ *	This function frees the TX buffers of the Yukon2 for a single port
+ *	which might be in use by a transmit action
+ *
+ * Returns: N/A
+ */
+void SkY2FreeTxBuffers (
+SK_AC    *pAC,   /* pointer to adapter control context */
+SK_IOC    IoC,	 /* I/O control context                */
+int       Port)	 /* port index of TX                   */
+{
+	SK_PACKET	*pSkPacket;
+	SK_FRAG		*pSkFrag;
+	unsigned long	 Flags;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("==> SkY2FreeTxBuffers (Port %c)\n", Port));
+ 
+	if (pAC->TxPort[Port][0].TransmitPacketTable != NULL) {
+		POP_FIRST_PKT_FROM_QUEUE(&pAC->TxPort[Port][0].TxAQ_working, pSkPacket);
+		while (pSkPacket != NULL) {
+			if ((pSkFrag = pSkPacket->pFrag) != NULL) {
+				UnmapAndFreeTxPktBuffer(pAC, pSkPacket, Port);
+			}
+			PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->TxPort[Port][0].TxAQ_waiting, pSkPacket);
+			POP_FIRST_PKT_FROM_QUEUE(&pAC->TxPort[Port][0].TxAQ_working, pSkPacket);
+		}
+#if USE_SYNC_TX_QUEUE
+		POP_FIRST_PKT_FROM_QUEUE(&pAC->TxPort[Port][0].TxSQ_working, pSkPacket);
+		while (pSkPacket != NULL) {
+			if ((pSkFrag = pSkPacket->pFrag) != NULL) {
+				UnmapAndFreeTxPktBuffer(pAC, pSkPacket, Port);
+			}
+			PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->TxPort[Port][0].TxSQ_waiting, pSkPacket);
+			POP_FIRST_PKT_FROM_QUEUE(&pAC->TxPort[Port][0].TxSQ_working, pSkPacket);
+		}
+#endif
+	}
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("<== SkY2FreeTxBuffers\n"));
+}
+
+/*****************************************************************************
+ *
+ * 	SkY2Isr - handle a receive IRQ for all yukon2 cards
+ *
+ * Description:
+ *	This function is called when a receive IRQ is set. (only for yukon2)
+ *	HandleReceives does the deferred processing of all outstanding
+ *	interrupt operations.
+ *
+ * Returns:	N/A
+ */
+SkIsrRetVar SkY2Isr (
+int              irq,     /* the irq we have received (might be shared!) */
+void            *dev_id,  /* current device id                           */
+struct  pt_regs *ptregs)  /* not used by our driver                      */
+{
+	struct SK_NET_DEVICE	*dev	= (struct SK_NET_DEVICE *)dev_id;
+	DEV_NET			*pNet	= (DEV_NET*) dev->priv;
+	SK_AC			*pAC	= pNet->pAC;
+	SK_U32			IntSrc;
+	unsigned long		Flags;
+#ifndef CONFIG_SK98LIN_NAPI
+	SK_BOOL			handledStatLE = SK_FALSE;
+#endif
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+		("==> SkY2Isr\n"));
+
+	SK_IN32(pAC->IoBase, B0_Y2_SP_ISRC2, &IntSrc);
+
+	if (IntSrc == 0) {
+		SK_OUT32(pAC->IoBase, B0_Y2_SP_ICR, 2);
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+			("No Interrupt\n ==> SkY2Isr\n"));
+		return SkIsrRetNone;
+
+	}
+
+#ifdef CONFIG_SK98LIN_NAPI
+	if (netif_rx_schedule_prep(dev)) {
+		pAC->GIni.GIValIrqMask &= ~(Y2_IS_STAT_BMU);
+		SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
+		__netif_rx_schedule(dev);
+	}
+#else
+	handledStatLE = HandleStatusLEs(pAC);
+#endif
+
+	/* 
+	** Check for Special Interrupts 
+	*/
+	if (IntSrc & ~Y2_IS_STAT_BMU) {
+		spin_lock_irqsave(&pAC->SlowPathLock, Flags);
+		SkGeSirqIsr(pAC, pAC->IoBase, IntSrc);
+		SkEventDispatcher(pAC, pAC->IoBase);
+		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
+	}
+
+	/* Speed enhancement for a2 chipsets */
+	if (HW_FEATURE(pAC, HWF_WA_DEV_42)) {
+		spin_lock_irqsave(&pAC->SetPutIndexLock, Flags);
+		SkGeY2SetPutIndex(pAC, pAC->IoBase, Y2_PREF_Q_ADDR(Q_XA1,0), &pAC->TxPort[0][0].TxALET);
+		SkGeY2SetPutIndex(pAC, pAC->IoBase, Y2_PREF_Q_ADDR(Q_R1,0), &pAC->RxPort[0].RxLET);
+		spin_unlock_irqrestore(&pAC->SetPutIndexLock, Flags);
+	} 
+
+	/* 
+	** Reenable interrupts and signal end of ISR 
+	*/
+	SK_OUT32(pAC->IoBase, B0_Y2_SP_ICR, 2);
+			
+	/*
+	** Stop and restart TX timer in case a Status LE was handled
+	*/
+#ifndef CONFIG_SK98LIN_NAPI
+	if ((HW_FEATURE(pAC, HWF_WA_DEV_43_418)) && (handledStatLE)) {
+		SK_OUT8(pAC->IoBase, STAT_TX_TIMER_CTRL, TIM_STOP);
+		SK_OUT8(pAC->IoBase, STAT_TX_TIMER_CTRL, TIM_START);
+	}
+#endif
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+		("<== SkY2Isr\n"));
+
+	return SkIsrRetHandled;
+}	/* SkY2Isr */
+
+/*****************************************************************************
+ *
+ *	SkY2Xmit - Linux frame transmit function for Yukon2
+ *
+ * Description:
+ *	The system calls this function to send frames onto the wire.
+ *	It puts the frame in the tx descriptor ring. If the ring is
+ *	full then, the 'tbusy' flag is set.
+ *
+ * Returns:
+ *	0, if everything is ok
+ *	!=0, on error
+ *
+ * WARNING: 
+ *	returning 1 in 'tbusy' case caused system crashes (double
+ *	allocated skb's) !!!
+ */
+int SkY2Xmit(
+struct sk_buff *skb,        /* socket buffer to be sent */
+struct SK_NET_DEVICE *dev)  /* via which device?        */
+{
+	DEV_NET		*pNet	= (DEV_NET*) dev->priv;
+	SK_AC		*pAC	= pNet->pAC;
+
+	SK_HWLE		*pLE;
+	SK_PACKET	*pSkPacket;
+	SK_FRAG		*pFrag;
+	SK_FRAG		*PrevFrag;
+	SK_FRAG		*CurrFrag;
+	SK_PKT_QUEUE	*pWorkQueue;	/* corresponding TX queue	*/
+	SK_PKT_QUEUE	*pFreeQueue; 
+	SK_LE_TABLE	*pLETab;	/* corresponding LETable	*/ 
+	skb_frag_t	*sk_frag;
+
+	SK_U64		 PhysAddr;
+	SK_BOOL		 SetOpcodePacketFlag;
+	SK_U32		 PrefetchReg;		/* register for Put idx	*/
+	SK_U32		 StartAddrPrefetchUnit;	/* begin prefetch unit	*/
+	SK_U32		 HighAddress;
+	SK_U32		 LowAddress;
+	SK_U16		 TcpSumStart; 
+	SK_U16		 TcpSumWrite;
+	SK_U8		 OpCode;
+	SK_U8		 Ctrl;
+
+	unsigned long	 Flags;
+	unsigned int	 Port;
+	int		 CurrFragCtr;
+	int		 Protocol;
+
+#if 0 // YK2_TX_POLLING
+	SK_EVPARA	 NewPara;
+#endif
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("==> SkY2Xmit\n"));
+
+	if (pAC->RlmtNets == 2) {
+		Port = pNet->PortNr;
+	} else {
+		Port = pAC->ActivePort;
+	}
+
+	/*
+	** Put any new packet to be sent in the waiting queue and 
+	** handle also any possible fragment of that packet.
+	*/
+	pWorkQueue = &(pAC->TxPort[Port][TX_PRIO_LOW].TxAQ_working);
+	pFreeQueue = &(pAC->TxPort[Port][TX_PRIO_LOW].TxQ_free);
+	pLETab     = &(pAC->TxPort[Port][TX_PRIO_LOW].TxALET);
+
+	if (Port == 0) {
+		PrefetchReg = Y2_PREF_Q_ADDR(Q_XA1, PREF_UNIT_PUT_IDX_REG);
+		StartAddrPrefetchUnit = Y2_PREF_Q_ADDR(Q_XA1, 0);
+	} else {
+		PrefetchReg = Y2_PREF_Q_ADDR(Q_XA2, PREF_UNIT_PUT_IDX_REG);
+		StartAddrPrefetchUnit = Y2_PREF_Q_ADDR(Q_XA1, 0);
+	}
+
+	spin_lock_irqsave(&pAC->TxPort[Port][TX_PRIO_LOW].TxDesRingLock, Flags);
+	PLAIN_POP_FIRST_PKT_FROM_QUEUE(pFreeQueue, pSkPacket);
+	if(pSkPacket == NULL) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+			SK_DBGCAT_DRV_TX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+			("Could not obtain free packet used for xmit\n"));
+		spin_unlock_irqrestore(&pAC->TxPort[Port][TX_PRIO_LOW].TxDesRingLock, Flags);
+		netif_stop_queue(dev);
+
+		return 1; /* zero bytes sent! */
+	} else {
+		if(pFreeQueue->pHead == NULL) {
+			PLAIN_PUSH_PKT_AS_FIRST_IN_QUEUE(pFreeQueue, pSkPacket);
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV,
+				SK_DBGCAT_DRV_TX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+				("avoid using all packets for send xmit\n"));
+			spin_unlock_irqrestore(&pAC->TxPort[Port][TX_PRIO_LOW].TxDesRingLock, Flags);
+			netif_stop_queue(dev);
+			return 1; /* zero bytes sent! */
+		}
+	} 
+
+	/*
+	** Normal send operations require only one fragment,
+	** because only one sk_buff data area is passed. 
+	** In contradiction to this, scatter-gather (zerocopy)
+	** send operations might pass one or more additional 
+	** fragments where each fragment needs a separate
+	** fragment info packet.
+	*/
+	if (((skb_shinfo(skb)->nr_frags + 1) * MAX_FRAG_OVERHEAD) > 
+					NUM_FREE_LE_IN_TABLE(pLETab)) {
+		PLAIN_PUSH_PKT_AS_FIRST_IN_QUEUE(pFreeQueue, pSkPacket);
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+			SK_DBGCAT_DRV_TX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+			("Not enough LE available for send\n"));
+		spin_unlock_irqrestore(&pAC->TxPort[Port][TX_PRIO_LOW].TxDesRingLock, Flags);
+		return 1; /* zero bytes sent! */
+	}
+	
+	if ((skb_shinfo(skb)->nr_frags + 1) > NUM_FREE_FRAGS(pAC, Port)) {
+		PLAIN_PUSH_PKT_AS_FIRST_IN_QUEUE(pFreeQueue, pSkPacket);
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+			SK_DBGCAT_DRV_TX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+			("Not even one fragment available for send\n"));
+		spin_unlock_irqrestore(&pAC->TxPort[Port][TX_PRIO_LOW].TxDesRingLock, Flags);
+		return 1; /* zero bytes sent! */
+	}
+
+	PLAIN_POP_FIRST_FRAG_FROM_QUEUE(Port, pSkPacket->pFrag);
+		
+	/* 
+	** map the sk_buff to be available for the adapter 
+	*/
+	PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
+			virt_to_page(skb->data),
+			((unsigned long) skb->data & ~PAGE_MASK),
+			skb->len, 
+			PCI_DMA_TODEVICE);
+	pSkPacket->pMBuf	= skb;
+	pSkPacket->pFrag->pPhys = PhysAddr;
+	// pSkPacket->pFrag->pVirt = skb->data;
+	pSkPacket->pFrag->FragLen = skb_headlen(skb);
+	pSkPacket->NumFrags	= skb_shinfo(skb)->nr_frags + 1;
+
+	// BytesSend = skb_headlen(skb);
+	PrevFrag = pSkPacket->pFrag;
+
+	/*
+	** Each scatter-gather fragment need to be mapped...
+	*/
+        for (	CurrFragCtr = 0; 
+		CurrFragCtr < skb_shinfo(skb)->nr_frags;
+		CurrFragCtr++) {
+		sk_frag = &skb_shinfo(skb)->frags[CurrFragCtr];
+		PLAIN_POP_FIRST_FRAG_FROM_QUEUE(Port, CurrFrag);
+
+                /* 
+		** map the sk_buff to be available for the adapter 
+		*/
+		PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
+				sk_frag->page,
+		 		sk_frag->page_offset,
+		 		sk_frag->size,
+		 		PCI_DMA_TODEVICE);
+
+		CurrFrag->pPhys   = PhysAddr;
+ 		// CurrFrag->pVirt   = (void *) sk_frag->page;
+ 		CurrFrag->FragLen = sk_frag->size;
+ 		// BytesSend         = BytesSend + sk_frag->size;
+
+		/*
+		** Add the new fragment to the list of fragments
+		*/
+		PrevFrag->pNext = CurrFrag;
+		PrevFrag = CurrFrag;
+	}
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("\tWe have a packet to send %p\n", pSkPacket));
+
+	/* 
+	** the first frag of a packet gets opcode OP_PACKET 
+	*/
+	SetOpcodePacketFlag	= SK_TRUE;
+	pFrag			= pSkPacket->pFrag;
+
+	/* 
+	** fill list elements with data from fragments 
+	*/
+	while (pFrag != NULL) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+			("\tGet LE\n"));
+
+		GET_TX_LE(pLE, pLETab);
+		Ctrl	= 0;
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+			("\tGot empty LE %p idx %d\n", pLE, GET_PUT_IDX(pLETab)));
+
+		SK_DBG_DUMP_TX_LE(pLE);
+
+		LowAddress  = (SK_U32) (pFrag->pPhys & 0xffffffff);
+		HighAddress = (SK_U32) (pFrag->pPhys >> 32);
+		if (HighAddress != pLETab->BufHighAddr) {
+			/* set opcode high part of the address in one LE */
+			OpCode = OP_ADDR64 | HW_OWNER;
+
+			/* Set now the 32 high bits of the address */
+			TXLE_SET_ADDR( pLE, HighAddress);
+
+			/* Set the opcode into the LE */
+			TXLE_SET_OPC(pLE, OpCode);
+
+			/* Flush the LE to memory */
+			FLUSH_OPC(pLE);
+
+			/* remember the HighAddress we gave to the Hardware */
+			pLETab->BufHighAddr = HighAddress;
+			
+			/* get a new LE because we filled one with high address */
+			GET_TX_LE(pLE, pLETab);
+		}
+
+		/*
+		** TCP checksum offload
+		*/
+
+		if ((pSkPacket->pMBuf->ip_summed == CHECKSUM_HW) && 
+		    (SetOpcodePacketFlag         == SK_TRUE)) {
+			Protocol = ((SK_U8)pSkPacket->pMBuf->data[C_OFFSET_IPPROTO] & 0xff);
+			// if (Protocol & C_PROTO_ID_IP) {
+			//	Ctrl = 0;
+			// }
+			if (Protocol & C_PROTO_ID_TCP) {
+				Ctrl = CALSUM | WR_SUM | INIT_SUM | LOCK_SUM;
+				/* TCP Checksum Calculation Start Position */
+				TcpSumStart = C_LEN_ETHERMAC_HEADER + IP_HDR_LEN;
+				/* TCP Checksum Write Position */
+				TcpSumWrite = TcpSumStart + TCP_CSUM_OFFS;
+			} else {
+				Ctrl = UDPTCP | CALSUM | WR_SUM | INIT_SUM | LOCK_SUM;
+				/* TCP Checksum Calculation Start Position */
+				TcpSumStart = ETHER_MAC_HDR_LEN + IP_HDR_LEN;
+				/* UDP Checksum Write Position */
+				TcpSumWrite = TcpSumStart + UDP_CSUM_OFFS;
+			}
+
+			if ((Ctrl) && (pLETab->Bmu.RxTx.TcpWp != TcpSumWrite)) {
+				/* Update the last value of the write position */
+				pLETab->Bmu.RxTx.TcpWp = TcpSumWrite;
+
+				/* Set the Lock field for this LE: */
+				/* Checksum calculation for one packet only */
+				TXLE_SET_LCKCS(pLE, 1);
+
+				/* Set the start position for checksum. */
+				TXLE_SET_STACS(pLE, TcpSumStart);
+
+				/* Set the position where the checksum will be writen */
+				TXLE_SET_WRICS(pLE, TcpSumWrite);
+
+				/* Set the initial value for checksum */
+				/* PseudoHeader CS passed from Linux -> 0! */
+				TXLE_SET_INICS(pLE, 0);
+
+				/* Set the opcode for tcp checksum */
+				TXLE_SET_OPC(pLE, OP_TCPLISW | HW_OWNER);
+
+				/* Flush the LE to memory */
+				FLUSH_OPC(pLE);
+
+				/* get a new LE because we filled one with data for checksum */
+				GET_TX_LE(pLE, pLETab);
+			}
+		} /* end TCP offload handling */
+
+		TXLE_SET_ADDR(pLE, LowAddress);
+		TXLE_SET_LEN(pLE, pFrag->FragLen);
+
+		if (SetOpcodePacketFlag){
+			// New frame starts always with opcode OP_PACKET
+			OpCode = OP_PACKET| HW_OWNER;
+			SetOpcodePacketFlag = SK_FALSE;
+		} else {
+			// Follow packet in a sequence has always OP_BUFFER
+			OpCode = OP_BUFFER | HW_OWNER;
+		}
+
+		pFrag = pFrag->pNext;
+		if (pFrag == NULL) {
+			/* mark last fragment */
+			Ctrl |= EOP;
+		}
+		TXLE_SET_CTRL(pLE, Ctrl);
+		TXLE_SET_OPC(pLE, OpCode);
+		FLUSH_OPC(pLE);
+		SK_DBG_DUMP_TX_LE(pLE);
+	}
+
+	/* 
+	** Remember next LE for tx complete 
+	*/
+	pSkPacket->NextLE = GET_PUT_IDX(pLETab);
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("\tNext LE for pkt %p is %d\n", pSkPacket, pSkPacket->NextLE));
+
+	/* 
+	** Add packet to working packets queue 
+	*/
+	PLAIN_PUSH_PKT_AS_LAST_IN_QUEUE(pWorkQueue, pSkPacket);
+
+	/* 
+	** give transmit start command
+	*/
+	if (HW_FEATURE(pAC, HWF_WA_DEV_42)) {
+		spin_lock(&pAC->SetPutIndexLock);
+		SkGeY2SetPutIndex(pAC, pAC->IoBase, Y2_PREF_Q_ADDR(Q_XA1,0), &pAC->TxPort[0][0].TxALET);
+		spin_unlock(&pAC->SetPutIndexLock);
+	} else {
+		/* write put index */
+		if (pNet->PortNr == 0) { 
+			SK_OUT32(pAC->IoBase, Y2_PREF_Q_ADDR(Q_XA1, PREF_UNIT_PUT_IDX_REG), GET_PUT_IDX(&pAC->TxPort[0][0].TxALET)); 
+			UPDATE_HWPUT_IDX(&pAC->TxPort[0][0].TxALET);
+		} else {
+			SK_OUT32(pAC->IoBase, Y2_PREF_Q_ADDR(Q_XA2, PREF_UNIT_PUT_IDX_REG), GET_PUT_IDX(&pAC->TxPort[1][0].TxALET)); 
+			UPDATE_HWPUT_IDX(&pAC->TxPort[1][0].TxALET);
+		}
+	}
+
+	dev->trans_start = jiffies;
+	spin_unlock_irqrestore(&pAC->TxPort[Port][TX_PRIO_LOW].TxDesRingLock, Flags);
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("<== SkY2Xmit(return 0)\n"));
+	return (0);
+}	/* SkY2Xmit */
+
+#ifdef CONFIG_SK98LIN_NAPI
+/*****************************************************************************
+ *
+ *	SkY2Poll - NAPI Rx polling callback for Yukon2 chipsets
+ *
+ * Description:
+ *	Called by the Linux system in case NAPI polling is activated
+ *
+ * Returns
+ *	The number of work data still to be handled
+ */
+int SkY2Poll(
+struct net_device *dev,
+int               *budget)
+{
+	SK_AC	*pAC          = ((DEV_NET*)(dev->priv))->pAC;
+	int	WorkToDo      = min(*budget, dev->quota);
+	int	WorkDone      = 0;
+	SK_BOOL handledStatLE = SK_FALSE;
+
+	handledStatLE = HandleStatusLEs(pAC, &WorkDone, WorkToDo);
+
+	*budget -= WorkDone;
+	dev->quota -= WorkDone;
+
+	if(WorkDone < WorkToDo) {
+		netif_rx_complete(dev);
+		pAC->GIni.GIValIrqMask |= (Y2_IS_STAT_BMU);
+		SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
+		if ((HW_FEATURE(pAC, HWF_WA_DEV_43_418)) && (handledStatLE)) {
+			SK_OUT8(pAC->IoBase, STAT_TX_TIMER_CTRL, TIM_STOP);
+			SK_OUT8(pAC->IoBase, STAT_TX_TIMER_CTRL, TIM_START);
+		}
+	}
+	return (WorkDone >= WorkToDo);
+}	/* SkY2Poll */
+#endif
+
+/******************************************************************************
+ *
+ *	SkY2PortStop - stop a port on Yukon2
+ *
+ * Description:
+ *	This function stops a port of the Yukon2 chip. This stop 
+ *	stop needs to be performed in a specific order:
+ * 
+ *	a) Stop the Prefetch unit
+ *	b) Stop the Port (MAC, PHY etc.)
+ *
+ * Returns: N/A
+ */
+void SkY2PortStop(
+SK_AC   *pAC,      /* adapter control context                             */
+SK_IOC   IoC,      /* I/O control context (address of adapter registers)  */
+int      Port,     /* port to stop (MAC_1 + n)                            */
+int      Dir,      /* StopDirection (SK_STOP_RX, SK_STOP_TX, SK_STOP_ALL) */
+int      RstMode)  /* Reset Mode (SK_SOFT_RST, SK_HARD_RST)               */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("==> SkY2PortStop (Port %c)\n", 'A' + Port));
+
+	/*
+	** Stop the HW
+	*/
+	SkGeStopPort(pAC, IoC, Port, Dir, RstMode);
+
+	/*
+	** Move any TX packet from work queues into the free queue again
+	*/
+	SkY2FreeTxBuffers(pAC, pAC->IoBase, Port);
+
+	/*
+	** Move any RX packet from work queue into the waiting queue
+	*/
+	SkY2FreeRxBuffers(pAC, pAC->IoBase, Port);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("<== SkY2PortStop()\n"));
+}
+
+/******************************************************************************
+ *
+ *	SkY2PortStart - start a port on Yukon2
+ *
+ * Description:
+ *	This function starts a port of the Yukon2 chip. This start 
+ *	action needs to be performed in a specific order:
+ * 
+ *	a) Initialize the LET indices (PUT/GET to 0)
+ *	b) Initialize the LET in HW (enables also prefetch unit)
+ *	c) Move all RX buffers from waiting queue to working queue
+ *	   which involves also setting up of RX list elements
+ *	d) Initialize the FIFO settings of Yukon2 (Watermark etc.)
+ *	e) Initialize the Port (MAC, PHY etc.)
+ *	f) Initialize the MC addresses
+ *
+ * Returns:	N/A
+ */
+void SkY2PortStart(
+SK_AC   *pAC,    /* adapter control context                            */
+SK_IOC   IoC,    /* I/O control context (address of adapter registers) */
+int      Port)   /* port to start                                      */
+{
+	SK_U32	DWord;
+	SK_HWLE	*pLE;
+	SK_U32	PrefetchReg;	/* register for Put index  */
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("==> SkY2PortStart (Port %c)\n", 'A' + Port));
+
+	/*
+	** Initialize the LET indices
+	*/
+	pAC->RxPort[Port].RxLET.Done                = 0; 
+	pAC->RxPort[Port].RxLET.Put                 = 0;
+	pAC->RxPort[Port].RxLET.HwPut               = 0;
+	pAC->TxPort[Port][TX_PRIO_LOW].TxALET.Done  = 0;    
+	pAC->TxPort[Port][TX_PRIO_LOW].TxALET.Put   = 0;
+	pAC->TxPort[Port][TX_PRIO_LOW].TxALET.HwPut = 0;
+	if (HW_SYNC_TX_SUPPORTED(pAC)) {
+		pAC->TxPort[Port][TX_PRIO_LOW].TxSLET.Done  = 0;    
+		pAC->TxPort[Port][TX_PRIO_LOW].TxSLET.Put   = 0;
+		pAC->TxPort[Port][TX_PRIO_LOW].TxSLET.HwPut = 0;
+	}
+	
+	if (HW_FEATURE(pAC, HWF_WA_DEV_420)) {
+		/*
+		** It might be that we have to limit the RX buffers 
+		** effectively passed to HW. Initialize the start
+		** value in that case...
+		*/
+		NbrRxBuffersInHW = 0;
+	}
+
+	/*
+	** TODO on dual net adapters we need to check if
+	** StatusLETable need to be set...
+	** 
+	** pAC->StatusLETable.Done  = 0;
+	** pAC->StatusLETable.Put   = 0;
+	** pAC->StatusLETable.HwPut = 0;
+	** SkGeY2InitPrefetchUnit(pAC, pAC->IoBase, Q_ST, &pAC->StatusLETable);
+	*/
+
+	/*
+	** Initialize the LET in HW (enables also prefetch unit)
+	*/
+	SkGeY2InitPrefetchUnit(pAC, IoC,(Port == 0) ? Q_R1 : Q_R2,
+			&pAC->RxPort[Port].RxLET);
+	SkGeY2InitPrefetchUnit( pAC, IoC,(Port == 0) ? Q_XA1 : Q_XA2, 
+			&pAC->TxPort[Port][TX_PRIO_LOW].TxALET);
+	if (HW_SYNC_TX_SUPPORTED(pAC)) {
+		SkGeY2InitPrefetchUnit( pAC, IoC, (Port == 0) ? Q_XS1 : Q_XS2,
+				&pAC->TxPort[Port][TX_PRIO_HIGH].TxSLET);
+	}
+
+	/*
+	** Using default values for the watermarks and the timer inis
+	** degrades the performance a lot! Therefore use own values 
+	** instead.
+	*/
+
+	/*
+	** SK_OUT8(IoC, STAT_FIFO_WM, 1);
+	** SK_OUT8(IoC, STAT_FIFO_ISR_WM, 1);
+	** SK_OUT32(IoC, STAT_LEV_TIMER_INI, 50);
+	** SK_OUT32(IoC, STAT_ISR_TIMER_INI, 10);
+	*/
+
+	/*
+	** Initialize the Port (MAC, PHY etc.)
+	*/
+	if (SkGeInitPort(pAC, IoC, Port)) {
+		if (Port == 0) {
+			printk("%s: SkGeInitPort A failed.\n",pAC->dev[0]->name);
+		} else {
+			printk("%s: SkGeInitPort B failed.\n",pAC->dev[1]->name);
+		}
+	}
+	
+	if (IS_GMAC(pAC)) {
+		/* disable Rx GMAC FIFO Flush Mode */
+		SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8) GMF_RX_F_FL_OFF);
+	}
+
+	/*
+	** Initialize the MC addresses
+	*/
+	SkAddrMcUpdate(pAC,IoC, Port);
+
+	SkMacRxTxEnable(pAC, IoC,Port);
+				
+#ifdef USE_SK_RX_CHECKSUM
+	/*
+	**
+	*/
+	SkGeRxCsum(pAC, IoC, Port, SK_TRUE);
+	
+	GET_RX_LE(pLE, &pAC->RxPort[Port].RxLET);
+	RXLE_SET_STACS1(pLE, pAC->CsOfs1);
+	RXLE_SET_STACS2(pLE, pAC->CsOfs2);
+	RXLE_SET_CTRL(pLE, 0);
+
+	RXLE_SET_OPC(pLE, OP_TCPSTART | HW_OWNER);
+	FLUSH_OPC(pLE);
+	if (Port == 0) {
+		PrefetchReg = Y2_PREF_Q_ADDR(Q_R1, PREF_UNIT_PUT_IDX_REG);
+	} else {
+		PrefetchReg = Y2_PREF_Q_ADDR(Q_R2, PREF_UNIT_PUT_IDX_REG);
+	}
+	DWord = GET_PUT_IDX(&pAC->RxPort[Port].RxLET);
+	SK_OUT32(IoC, PrefetchReg, DWord);
+	UPDATE_HWPUT_IDX(&pAC->RxPort[Port].RxLET);
+#endif
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("<== SkY2PortStart()\n"));
+}
+
+/******************************************************************************
+ *
+ * Local Functions
+ *
+ *****************************************************************************/
+
+/*****************************************************************************
+ *
+ *	InitPacketQueues - initialize SW settings of packet queues
+ *
+ * Description:
+ *	This function will initialize the packet queues for a port.
+ *
+ * Returns: N/A
+ */
+static void InitPacketQueues(
+SK_AC  *pAC,   /* pointer to adapter control context */
+int     Port)  /* index of port to be initialized    */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("==> InitPacketQueues(Port %c)\n", 'A' + Port));
+	
+	pAC->RxPort[Port].RxQ_working.pHead = NULL;
+	pAC->RxPort[Port].RxQ_working.pTail = NULL;
+	spin_lock_init(&pAC->RxPort[Port].RxQ_working.QueueLock);
+	
+	pAC->RxPort[Port].RxQ_waiting.pHead = NULL;
+	pAC->RxPort[Port].RxQ_waiting.pTail = NULL;
+	spin_lock_init(&pAC->RxPort[Port].RxQ_waiting.QueueLock);
+	
+	pAC->TxPort[Port][TX_PRIO_LOW].TxQ_free.pHead = NULL;
+	pAC->TxPort[Port][TX_PRIO_LOW].TxQ_free.pTail = NULL;
+	spin_lock_init(&pAC->TxPort[Port][TX_PRIO_LOW].TxQ_free.QueueLock);
+
+	pAC->TxPort[Port][TX_PRIO_LOW].TxAQ_working.pHead = NULL;
+	pAC->TxPort[Port][TX_PRIO_LOW].TxAQ_working.pTail = NULL;
+	spin_lock_init(&pAC->TxPort[Port][TX_PRIO_LOW].TxAQ_working.QueueLock);
+	
+	pAC->TxPort[Port][TX_PRIO_LOW].TxAQ_waiting.pHead = NULL;
+	pAC->TxPort[Port][TX_PRIO_LOW].TxAQ_waiting.pTail = NULL;
+	spin_lock_init(&pAC->TxPort[Port][TX_PRIO_LOW].TxAQ_waiting.QueueLock);
+	
+#if USE_SYNC_TX_QUEUE
+	pAC->TxPort[Port][TX_PRIO_LOW].TxSQ_working.pHead = NULL;
+	pAC->TxPort[Port][TX_PRIO_LOW].TxSQ_working.pTail = NULL;
+	spin_lock_init(&pAC->TxPort[Port][TX_PRIO_LOW].TxSQ_working.QueueLock);
+
+	pAC->TxPort[Port][TX_PRIO_LOW].TxSQ_waiting.pHead = NULL;
+	pAC->TxPort[Port][TX_PRIO_LOW].TxSQ_waiting.pTail = NULL;
+	spin_lock_init(&pAC->TxPort[Port][TX_PRIO_LOW].TxSQ_waiting.QueueLock);
+#endif
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("<== InitPacketQueues(Port %c)\n", 'A' + Port));
+}	/* InitPacketQueues */
+
+/***********************************************************************
+ *
+ *	GiveRxBufferToHw - commits a previously allocated DMA area to HW
+ *
+ * Description:
+ *	This functions gives receive buffers to HW. If no list elements
+ *	are available the buffers will be queued. 
+ *
+ * Notes:
+ *       This function can run only once in a system at one time.
+ *
+ * Returns: N/A
+ */
+static void GiveRxBufferToHw(
+SK_AC      *pAC,       /* pointer to adapter control context         */
+SK_IOC      IoC,       /* I/O control context (address of registers) */
+int         Port,      /* port index for which the buffer is used    */
+SK_PACKET  *pPacket)   /* receive buffer(s)                          */
+{
+	SK_HWLE		*pLE;
+	SK_LE_TABLE	*pLETab;
+
+	SK_BOOL		Done = SK_FALSE;	/* at least on LE changed? */
+	SK_U32		LowAddress;
+	SK_U32		HighAddress;
+	SK_U32		PrefetchReg;		/* register for Put index  */
+	SK_U8		OpCode;
+	SK_U8		Ctrl;
+
+	unsigned	NumFree;
+	unsigned	Required;
+	unsigned long	Flags;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("==> GiveRxBufferToHw(Port %c, Packet %p)\n", 'A' + Port,
+		pPacket));
+
+	pLETab	= &pAC->RxPort[Port].RxLET;
+
+	if (Port == 0) {
+		PrefetchReg = Y2_PREF_Q_ADDR(Q_R1, PREF_UNIT_PUT_IDX_REG);
+	} else {
+		PrefetchReg = Y2_PREF_Q_ADDR(Q_R2, PREF_UNIT_PUT_IDX_REG);
+	} 
+
+	if (pPacket != NULL) {
+		/*
+		** For the time being, we have only one packet passed
+		** to this function which might be changed in future!
+		*/
+		PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pPacket);
+	}
+
+	/* 
+	** now pPacket contains the very first waiting packet
+	*/
+	POP_FIRST_PKT_FROM_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pPacket);
+	while (pPacket != NULL) {
+		if (HW_FEATURE(pAC, HWF_WA_DEV_420)) {
+			if (NbrRxBuffersInHW >= MAX_NBR_RX_BUFFERS_IN_HW) {
+				PUSH_PKT_AS_FIRST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pPacket);
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+					("<== GiveRxBufferToHw()\n"));
+				return;
+			} 
+			NbrRxBuffersInHW++;
+		}
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+			("Try to add packet %p\n", pPacket));
+
+		/* 
+		** Check whether we have enough listelements:
+		**
+		** we have to take into account that each fragment 
+		** may need an additional list element for the high 
+		** part of the address here I simplified it by 
+		** using MAX_FRAG_OVERHEAD maybe it's worth to split 
+		** this constant for Rx and Tx or to calculate the
+		** real number of needed LE's
+		*/
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+			("\tNum %d Put %d Done %d Free %d %d\n",
+			pLETab->Num, pLETab->Put, pLETab->Done,
+			NUM_FREE_LE_IN_TABLE(pLETab),
+			(NUM_FREE_LE_IN_TABLE(pLETab))));
+
+		Required = pPacket->NumFrags + MAX_FRAG_OVERHEAD;
+		NumFree = NUM_FREE_LE_IN_TABLE(pLETab);
+		if (NumFree) {
+			NumFree--;
+		}
+
+		if (Required > NumFree ) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+				SK_DBGCAT_DRV_RX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+				("\tOut of LEs have %d need %d\n",
+				NumFree, Required));
+
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+				("\tWaitQueue starts with packet %p\n", pPacket));
+			PUSH_PKT_AS_FIRST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pPacket);
+			if (Done) {
+				/*
+				** write Put index to BMU or Polling Unit and make the LE's
+				** available for the hardware
+				*/
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+					("\tWrite new Put Idx\n"));
+
+				SK_OUT32(IoC, PrefetchReg, GET_PUT_IDX(pLETab));
+				UPDATE_HWPUT_IDX(pLETab);
+			}
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+				("<== GiveRxBufferToHw()\n"));
+			return;
+		} else {
+			if (!AllocAndMapRxBuffer(pAC, pPacket, Port)) {
+				/*
+				** Failure while allocating sk_buff might
+				** be due to temporary short of resources
+				** Maybe next time buffers are available.
+				** Until this, the packet remains in the 
+				** RX waiting queue...
+				*/
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+					SK_DBGCAT_DRV_RX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+					("Failed to allocate Rx buffer\n"));
+
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+					("WaitQueue starts with packet %p\n", pPacket));
+				PUSH_PKT_AS_FIRST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pPacket);
+				if (Done) {
+					/*
+					** write Put index to BMU or Polling 
+					** Unit and make the LE's
+					** available for the hardware
+					*/
+					SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+						("\tWrite new Put Idx\n"));
+	
+					SK_OUT32(IoC, PrefetchReg, GET_PUT_IDX(pLETab));
+					UPDATE_HWPUT_IDX(pLETab);
+				}
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+					("<== GiveRxBufferToHw()\n"));
+				return;
+			}
+		}
+		Done = SK_TRUE;
+
+		/*
+		** :;:; TODO
+		** here we have to check for the 64 bit part of the address first
+		** and use a ADDR64-LE in case of change
+		**
+		** so this is simplified model without csum offload and with
+		** 32 bit phys addresses
+		*/
+		OpCode = OP_PACKET | HW_OWNER;
+		Ctrl = 0;
+
+		/*
+		** Begin fragment processing: On the receive side we always have 
+		** one fragment belonging to one packet.
+		*/
+		GET_RX_LE(pLE, pLETab);
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+			("=== LE empty\n"));
+
+		SK_DBG_DUMP_RX_LE(pLE);
+
+		/* 
+		** Fill data into listelement 
+		*/
+		LowAddress = (SK_U32) (pPacket->pFrag->pPhys & 0xffffffff);
+		HighAddress = (SK_U32) (pPacket->pFrag->pPhys >> 32);
+
+		RXLE_SET_ADDR(pLE, LowAddress);
+		RXLE_SET_LEN(pLE, pPacket->pFrag->FragLen);
+		RXLE_SET_CTRL(pLE, Ctrl);
+		RXLE_SET_OPC(pLE, OpCode);
+		FLUSH_OPC(pLE);
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+			("=== LE filled\n"));
+
+		SK_DBG_DUMP_RX_LE(pLE);
+
+		/* 
+		** Change OpCode for the following fragments 
+		** of a receive buffer. End of fragment processing.
+		*/
+		OpCode = OP_BUFFER | HW_OWNER;
+
+		/* 
+		** Remember next LE for rx complete 
+		*/
+		pPacket->NextLE = GET_PUT_IDX(pLETab);
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+			("\tPackets Next LE is %d\n", pPacket->NextLE));
+
+		/* 
+		** Add packet to working receive buffer queue and get
+		** any next packet out of the waiting queue
+		*/
+		PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[Port].RxQ_working, pPacket);
+		POP_FIRST_PKT_FROM_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pPacket);
+	}
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("\tWaitQueue is empty\n"));
+
+	if (Done) {
+		/*
+		** write Put index to BMU or Polling Unit and make the LE's
+		** available for the hardware
+		*/
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+			("\tWrite new Put Idx\n"));
+
+		spin_lock_irqsave(&pAC->SetPutIndexLock, Flags);
+		/* Speed enhancement for a2 chipsets */
+		if (HW_FEATURE(pAC, HWF_WA_DEV_42)) {
+			SkGeY2SetPutIndex(pAC, pAC->IoBase, Y2_PREF_Q_ADDR(Q_R1,0), pLETab);
+		} else {
+			/* write put index */
+			if (Port == 0) { 
+				SK_OUT32(IoC, Y2_PREF_Q_ADDR(Q_R1, PREF_UNIT_PUT_IDX_REG), GET_PUT_IDX(pLETab)); 
+			} else {
+				SK_OUT32(IoC, Y2_PREF_Q_ADDR(Q_R2, PREF_UNIT_PUT_IDX_REG), GET_PUT_IDX(pLETab)); 
+			}
+
+			/* Update put index */
+			UPDATE_HWPUT_IDX(pLETab);
+		}
+		spin_unlock_irqrestore(&pAC->SetPutIndexLock, Flags);
+	}
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("<== GiveRxBufferToHw()\n"));
+}       /* GiveRxBufferToHw */
+
+/***********************************************************************
+ *
+ *	FillReceiveTableYukon2 - map any waiting RX buffers to HW
+ *
+ * Description:
+ *	If the list element table contains more empty elements than 
+ *	specified this function tries to refill them.
+ *
+ * Notes:
+ *       This function can run only once per port in a system at one time.
+ *
+ * Returns: N/A
+ */
+static void FillReceiveTableYukon2(
+SK_AC    *pAC,	 /* pointer to adapter control context */
+SK_IOC    IoC,	 /* I/O control context                */
+int       Port)	 /* port index of RX                   */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("==> FillReceiveTableYukon2 (Port %c)\n", 'A' + Port));
+
+	if (NUM_FREE_LE_IN_TABLE(&pAC->RxPort[Port].RxLET) >
+		pAC->MaxUnusedRxLeWorking) {
+
+		/* 
+		** Give alle waiting receive buffers down 
+		** The queue holds all RX packets that
+		** need a fresh allocation of the sk_buff.
+		*/
+		if (pAC->RxPort[Port].RxQ_waiting.pHead != NULL) {
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+			("Waiting queue is not empty -> give it to HW"));
+			GiveRxBufferToHw(pAC, IoC, Port, NULL);
+		}
+	}
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("<== FillReceiveTableYukon2 ()\n"));
+}	/* FillReceiveTableYukon2 */
+
+/******************************************************************************
+ *
+ *
+ *	HandleReceives - will pass any ready RX packet to kernel
+ *
+ * Description:
+ *	This functions handles a received packet. It checks wether it is
+ *	valid, updates the receive list element table and gives the receive
+ *	buffer to Linux
+ *
+ * Notes:
+ *	This function can run only once per port at one time in the system.
+ *
+ * Returns: N/A
+ */
+
+static SK_BOOL HandleReceives(
+SK_AC  *pAC,          /* adapter control context                     */
+int     Port,         /* port on which a packet has been received    */
+SK_U16  Len,          /* number of bytes which was actually received */
+SK_U32  FrameStatus,  /* MAC frame status word                       */
+SK_U16  Tcp1,         /* first hw checksum                           */
+SK_U16  Tcp2,         /* second hw checksum                          */
+SK_U32  Tist,         /* timestamp                                   */
+SK_U16  Vlan)         /* Vlan Id                                     */
+{
+
+	SK_PACKET	*pSkPacket;
+	SK_LE_TABLE	*pLETab;
+	SK_MBUF		*pRlmtMbuf;	/* buffer for giving RLMT frame */
+	struct sk_buff	*pMsg;		/* ptr to message holding frame	*/
+
+	SK_BOOL		SlowPathLock = SK_TRUE;
+	SK_BOOL		IsGoodPkt;
+	SK_BOOL		IsBc;
+	SK_BOOL		IsMc;
+	SK_EVPARA	EvPara;		/* an event parameter union	*/
+	SK_I16		LenToFree;	/* must be signed integer	*/
+
+	unsigned long	Flags;		/* for spin lock		*/
+	unsigned int	ForRlmt;
+	unsigned short	Csum1;
+	unsigned short	Csum2;
+	unsigned short	Type;
+	int		IpFrameLength;
+	int		FrameLength;	/* total length of recvd frame	*/
+	int		NumBytes; 
+	int		Result;
+	int		Offset = 0; 
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("==> HandleReceives (Port %c)\n", 'A' + Port));
+
+	/* 
+	** initialize vars for selected port 
+	*/
+	pLETab = &pAC->RxPort[Port].RxLET;
+
+	/* 
+	** check whether we want to receive this packet 
+	*/
+	SK_Y2_RXSTAT_CHECK_PKT(Len, FrameStatus, IsGoodPkt);
+
+	/*
+	** Remember length to free (in case of RxBuffer overruns;
+	** unlikely, but might happen once in a while)
+	*/
+	LenToFree = (SK_I16) Len;
+
+	/* 
+	** maybe we put these two checks into the SK_RXDESC_CHECK_PKT macro too 
+	*/
+	if (Len > pAC->RxBufSize) {
+		IsGoodPkt = SK_FALSE;
+	}
+
+	/*
+	** take first receive buffer out of working queue 
+	*/
+	POP_FIRST_PKT_FROM_QUEUE(&pAC->RxPort[Port].RxQ_working, pSkPacket);
+	if (HW_FEATURE(pAC, HWF_WA_DEV_420)) {
+		NbrRxBuffersInHW--;
+	}
+
+	/* 
+	** Verify the received length of the frame! Note that having 
+	** multiple RxBuffers being aware of one single receive packet
+	** (one packet spread over multiple RxBuffers) is not supported 
+	** by this driver!
+	*/
+	if ((Len > pAC->RxBufSize) || (Len > (SK_U16) pSkPacket->PacketLen)) {
+		IsGoodPkt = SK_FALSE;
+	}
+
+	/* 
+	** Reset own bit in LE's between old and new Done index
+	** This is not really necessary but makes debugging easier 
+	*/
+	CLEAR_LE_OWN_FROM_DONE_TO(pLETab, pSkPacket->NextLE);
+
+	/* 
+	** Free the list elements for new Rx buffers 
+	*/
+	SET_DONE_INDEX(pLETab, pSkPacket->NextLE);
+	pMsg = pSkPacket->pMBuf;
+	FrameLength = Len;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("Received frame of length %d on port %d\n",
+		FrameLength, Port));
+
+	if (!IsGoodPkt) {
+		/* 
+		** release the DMA mapping 
+		*/
+		pci_dma_sync_single(pAC->PciDev,
+				(dma_addr_t) pSkPacket->pFrag->pPhys,
+				pSkPacket->pFrag->FragLen,
+				PCI_DMA_FROMDEVICE); 
+
+		DEV_KFREE_SKB_ANY(pSkPacket->pMBuf);
+		PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pSkPacket);
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+			("<== HandleReceives (Port %c)\n", 'A' + Port));
+
+		/*
+		** Sanity check for RxBuffer overruns...
+		*/
+		LenToFree = LenToFree - (pSkPacket->pFrag->FragLen);
+		while (LenToFree > 0) {
+			POP_FIRST_PKT_FROM_QUEUE(&pAC->RxPort[Port].RxQ_working, pSkPacket);
+			if (HW_FEATURE(pAC, HWF_WA_DEV_420)) {
+				NbrRxBuffersInHW--;
+			}
+			CLEAR_LE_OWN_FROM_DONE_TO(pLETab, pSkPacket->NextLE);
+			SET_DONE_INDEX(pLETab, pSkPacket->NextLE);
+			pci_dma_sync_single(pAC->PciDev,
+					(dma_addr_t) pSkPacket->pFrag->pPhys,
+					pSkPacket->pFrag->FragLen,
+					PCI_DMA_FROMDEVICE); 
+
+			DEV_KFREE_SKB_ANY(pSkPacket->pMBuf);
+			PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pSkPacket);
+			LenToFree = LenToFree - ((SK_I16)(pSkPacket->pFrag->FragLen));
+			
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV,
+				SK_DBGCAT_DRV_RX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+				("<== HandleReceives (Port %c) drop faulty len pkt (2)\n", 'A' + Port));
+		}
+		return(SK_TRUE);
+	} else {
+		/* 
+		** if short frame then copy data to reduce memory waste ++++ 
+		*/
+
+		/*
+		** if large frame, or SKB allocation failed, pass
+		** the SKB directly to the networking
+		*/
+
+		/* 
+		** Release the DMA mapping 
+		*/
+		pci_unmap_single(pAC->PciDev,
+				 pSkPacket->pFrag->pPhys,
+				 pAC->RxBufSize - 2,
+				 PCI_DMA_FROMDEVICE);
+
+		/* set length in message */
+		skb_put(pMsg, FrameLength);
+		/* hardware checksum */
+		Type = ntohs(*((short*)&pMsg->data[12]));
+
+#ifdef USE_SK_RX_CHECKSUM
+		if (Type == 0x800) {
+			Csum1=Tcp1;  /* le16_to_cpu(pRxd->TcpSums & 0xffff); */
+			Csum2=Tcp2;  /* le16_to_cpu((pRxd->TcpSums >> 16) & 0xffff); */
+			*((char *)&(IpFrameLength)) = pMsg->data[16];
+			*(((char *)&(IpFrameLength))+1) = pMsg->data[17];
+			IpFrameLength = ntohs(IpFrameLength);
+			/*
+			 * Test: If frame is padded, a check is not possible!
+			 * Frame not padded? Length difference must be 14 (0xe)!
+			 */
+			if ((FrameLength - IpFrameLength) != 0xe) {
+					/* Frame padded => TCP offload not possible! */
+					pMsg->ip_summed = CHECKSUM_NONE;
+			} else {
+			/* Frame not padded => TCP offload! */
+				if ((((Csum1 & 0xfffe) && (Csum2 & 0xfffe)) &&
+					(pAC->GIni.GIChipId == CHIP_ID_GENESIS)) ||
+				(pAC->ChipsetType)) {
+					Result = SkCsGetReceiveInfo(pAC,
+						&pMsg->data[14],
+						Csum1, Csum2, Port);
+
+					if (Result ==
+						SKCS_STATUS_IP_FRAGMENT ||
+						Result ==
+						SKCS_STATUS_IP_CSUM_OK ||
+						Result ==
+						SKCS_STATUS_TCP_CSUM_OK ||
+						Result ==
+						SKCS_STATUS_UDP_CSUM_OK) {
+							pMsg->ip_summed =
+							CHECKSUM_UNNECESSARY;
+					} else if (Result ==
+						SKCS_STATUS_TCP_CSUM_ERROR ||
+						Result ==
+						SKCS_STATUS_UDP_CSUM_ERROR ||
+						Result ==
+						SKCS_STATUS_IP_CSUM_ERROR_UDP ||
+						Result ==
+						SKCS_STATUS_IP_CSUM_ERROR_TCP ||
+						Result ==
+						SKCS_STATUS_IP_CSUM_ERROR ) {
+						/* HW Checksum error */
+						SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+							SK_DBGCAT_DRV_RX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+							("skge: CRC error. Frame dropped!\n"));
+						DEV_KFREE_SKB_ANY(pMsg);
+						PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pSkPacket);
+						SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+								SK_DBGCAT_DRV_RX_PROGRESS,
+							("<== HandleReceives (Port %c)\n", 'A' + Port));
+						return(SK_TRUE);
+					} else {
+						pMsg->ip_summed = CHECKSUM_NONE;
+					}
+				}/* checksumControl calculation valid */
+			} /* Frame length check */
+		} /* IP frame */
+#else
+		pMsg->ip_summed = CHECKSUM_NONE;	
+#endif
+		/* } * frame > SK_COPY_TRESHOLD */
+		
+		SK_DBG_MSG(NULL, SK_DBGMOD_DRV,	1,("V"));
+		ForRlmt = SK_RLMT_RX_PROTOCOL;
+
+		IsBc = (FrameStatus & XMR_FS_BC)==XMR_FS_BC;
+		SK_RLMT_PRE_LOOKAHEAD(pAC, Port, FrameLength,
+			IsBc, &Offset, &NumBytes);
+		if (NumBytes != 0) {
+			IsMc = (FrameStatus & XMR_FS_MC)==XMR_FS_MC;
+			SK_RLMT_LOOKAHEAD(pAC, Port,
+				&pMsg->data[Offset],
+				IsBc, IsMc, &ForRlmt);
+		}
+
+		if (ForRlmt == SK_RLMT_RX_PROTOCOL) {
+					SK_DBG_MSG(NULL, SK_DBGMOD_DRV,	1,("W"));
+			/* send up only frames from active port */
+			if ((Port == pAC->ActivePort) ||
+				(pAC->RlmtNets == 2)) {
+				/* frame for upper layer */
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 1,("U"));
+#ifdef xDEBUG
+				DumpMsg(pMsg, "Rx");
+#endif
+				SK_PNMI_CNT_RX_OCTETS_DELIVERED(pAC,
+					FrameLength, Port);
+
+				pMsg->dev = pAC->dev[Port];
+				pMsg->protocol = eth_type_trans(pMsg,
+					pAC->dev[Port]);
+				netif_rx(pMsg);
+				pAC->dev[Port]->last_rx = jiffies;
+			} else {
+				/* drop frame */
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+					SK_DBGCAT_DRV_RX_PROGRESS,
+					("D"));
+				DEV_KFREE_SKB_ANY(pMsg);
+			}
+			PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pSkPacket);
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+				("<== HandleReceives (Port %c)\n", 'A' + Port));
+			return(SK_TRUE);
+			
+		} else { /* if not for rlmt */
+			/* packet for rlmt */
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+				SK_DBGCAT_DRV_RX_PROGRESS, ("R"));
+			pRlmtMbuf = SkDrvAllocRlmtMbuf(pAC,
+				pAC->IoBase, FrameLength);
+			if (pRlmtMbuf != NULL) {
+				pRlmtMbuf->pNext = NULL;
+				pRlmtMbuf->Length = FrameLength;
+				pRlmtMbuf->PortIdx = Port;
+				EvPara.pParaPtr = pRlmtMbuf;
+				memcpy((char*)(pRlmtMbuf->pData),
+					   (char*)(pMsg->data),
+					   FrameLength);
+
+				/* SlowPathLock needed? */
+				if (SlowPathLock == SK_TRUE) {
+					spin_lock_irqsave(&pAC->SlowPathLock, Flags);
+					SkEventQueue(pAC, SKGE_RLMT,
+						SK_RLMT_PACKET_RECEIVED,
+						EvPara);
+					pAC->CheckQueue = SK_TRUE;
+					spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
+				} else {
+					SkEventQueue(pAC, SKGE_RLMT,
+						SK_RLMT_PACKET_RECEIVED,
+						EvPara);
+					pAC->CheckQueue = SK_TRUE;
+				}
+
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+					SK_DBGCAT_DRV_RX_PROGRESS,
+					("Q"));
+			}
+			if ((pAC->dev[Port]->flags &
+				(IFF_PROMISC | IFF_ALLMULTI)) != 0 ||
+				(ForRlmt & SK_RLMT_RX_PROTOCOL) ==
+				SK_RLMT_RX_PROTOCOL) {
+				pMsg->dev = pAC->dev[Port];
+				pMsg->protocol = eth_type_trans(pMsg,
+					pAC->dev[Port]);
+				netif_rx(pMsg);
+				pAC->dev[Port]->last_rx = jiffies;
+			} else {
+				DEV_KFREE_SKB_ANY(pMsg);
+			}
+			PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[Port].RxQ_waiting, pSkPacket);
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+				("<== HandleReceives (Port %c)\n", 'A' + Port));
+			return(SK_TRUE);
+
+		} /* if packet for rlmt */
+	} /* end if-else (IsGoodPkt) */
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("<== HandleReceives (Port %c)\n", 'A' + Port));
+	return(SK_TRUE);
+
+}	/* HandleReceives */
+
+/***********************************************************************
+ *
+ * CheckForSendComplete
+ *
+ * Description:
+ *	This function checks the queues of a port for completed send
+ *	packets and returns these packets back to the OS.
+ *
+ * Notes:
+ *	This function can run simultaneously for both ports if
+ *	the OS function OSReturnPacket() can handle this,
+ *
+ *	Such a send complete does not mean, that the packet is really
+ *	out on the wire. We just know that the adapter has copied it
+ *	into its internal memory and the buffer in the systems memory
+ *	is no longer needed.
+ *
+ * Returns: N/A
+ */
+static void CheckForSendComplete(
+SK_AC         *pAC,     /* pointer to adapter control context  */
+SK_IOC         IoC,     /* I/O control context                 */
+int            Port,    /* port index                          */
+SK_PKT_QUEUE  *pPQ,     /* tx working packet queue to check    */
+SK_LE_TABLE   *pLETab,  /* corresponding list element table    */
+unsigned int   Done)    /* done index reported for this LET    */
+{
+	SK_PACKET	*pSkPacket;
+	SK_FRAG		*pNextFrag;
+	SK_PKT_QUEUE	 SendCmplPktQ = { NULL, NULL, SPIN_LOCK_UNLOCKED };
+	SK_BOOL          DoWakeQueue  = SK_FALSE;
+	unsigned long	 Flags;
+	unsigned	 Put;
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("==> CheckForSendComplete(Port %c)\n", 'A' + Port));
+
+	/* 
+	** Reset own bit in LE's between old and new Done index
+	** This is not really necessairy but makes debugging easier 
+	*/
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("Clear Own Bits in TxTable from %d to %d\n",
+		pLETab->Done, (Done == 0) ?
+		NUM_LE_IN_TABLE(pLETab) :
+		(Done - 1)));
+
+	spin_lock_irqsave(&pAC->TxPort[Port][0].TxDesRingLock, Flags);
+
+	CLEAR_LE_OWN_FROM_DONE_TO(pLETab, Done);
+
+	Put = GET_PUT_IDX(pLETab);
+
+	/* 
+	** Check whether some packets have been completed 
+	*/
+	PLAIN_POP_FIRST_PKT_FROM_QUEUE(pPQ, pSkPacket);
+	while (pSkPacket != NULL) {
+		
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+			("Check Completion of Tx packet %p\n", pSkPacket));
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+			("Put %d NewDone %d NextLe of Packet %d\n", Put, Done,
+			pSkPacket->NextLE));
+
+		if ((Put > Done) &&
+			((pSkPacket->NextLE > Put) || (pSkPacket->NextLE <= Done))) {
+			PLAIN_PUSH_PKT_AS_LAST_IN_QUEUE(&SendCmplPktQ, pSkPacket);
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+				("Packet finished (a)\n"));
+		} else if ((Done > Put) &&
+			(pSkPacket->NextLE > Put) && (pSkPacket->NextLE <= Done)) {
+			PLAIN_PUSH_PKT_AS_LAST_IN_QUEUE(&SendCmplPktQ, pSkPacket);
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+				("Packet finished (b)\n"));
+		} else if ((Done == TXA_MAX_LE-1) && (Put == 0) && (pSkPacket->NextLE == 0)) {
+			PLAIN_PUSH_PKT_AS_LAST_IN_QUEUE(&SendCmplPktQ, pSkPacket);
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+				("Packet finished (b)\n"));
+			DoWakeQueue = SK_TRUE;
+		} else if (Done == Put) {
+			/* all packets have been sent */
+			PLAIN_PUSH_PKT_AS_LAST_IN_QUEUE(&SendCmplPktQ, pSkPacket);
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+				("Packet finished (c)\n"));
+		} else {
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+				("Packet not yet finished\n"));
+			PLAIN_PUSH_PKT_AS_FIRST_IN_QUEUE(pPQ, pSkPacket);
+			break;
+		}
+		PLAIN_POP_FIRST_PKT_FROM_QUEUE(pPQ, pSkPacket);
+	}
+
+	/* 
+	** Set new done index in list element table
+	*/
+	SET_DONE_INDEX(pLETab, Done);
+	 
+	/*
+	** All TX packets that are send complete should be added to
+	** the free queue again for new sents to come
+	*/
+	pSkPacket = SendCmplPktQ.pHead;
+	while (pSkPacket != NULL) {
+		while (pSkPacket->pFrag != NULL) {
+			pci_unmap_page(pAC->PciDev,
+					(dma_addr_t) pSkPacket->pFrag->pPhys,
+					pSkPacket->pFrag->FragLen,
+					PCI_DMA_FROMDEVICE);
+			PLAIN_PUSH_FRAG_AS_LAST_IN_QUEUE(Port, pSkPacket->pFrag, pNextFrag);
+			pSkPacket->pFrag = pNextFrag;
+		}
+
+		DEV_KFREE_SKB_ANY(pSkPacket->pMBuf);
+		pSkPacket->pMBuf	= NULL;
+		pSkPacket = pSkPacket->pNext; /* get next packet */
+	}
+
+	/*
+	** Append the available TX packets back to free queue
+	**
+	** May be replaced with macro:
+	**
+	** PUSH_MULTIPLE_PKT_AS_LAST_IN_QUEUE(&pAC->TxPort[Port][0].TxQ_free, 
+	**		SendCmplPktQ.pHead, SendCmplPktQ.pTail);
+	*/
+	if (SendCmplPktQ.pHead != NULL) { 
+		spin_lock_irqsave(&(pAC->TxPort[Port][0].TxQ_free.QueueLock), Flags);
+		if (pAC->TxPort[Port][0].TxQ_free.pTail != NULL) {
+			pAC->TxPort[Port][0].TxQ_free.pTail->pNext = SendCmplPktQ.pHead;
+			pAC->TxPort[Port][0].TxQ_free.pTail        = SendCmplPktQ.pTail;
+			if (pAC->TxPort[Port][0].TxQ_free.pHead->pNext == NULL) {
+                                netif_wake_queue(pAC->dev[Port]);
+                        }
+		} else {
+			pAC->TxPort[Port][0].TxQ_free.pHead = SendCmplPktQ.pHead;
+			pAC->TxPort[Port][0].TxQ_free.pTail = SendCmplPktQ.pTail; 
+			netif_wake_queue(pAC->dev[Port]);
+		}
+		if (Done == Put) {
+                        netif_wake_queue(pAC->dev[Port]);
+                }
+                if (DoWakeQueue) {
+                        netif_wake_queue(pAC->dev[Port]);
+                        DoWakeQueue = SK_FALSE;
+                }
+		spin_unlock_irqrestore(&pAC->TxPort[Port][0].TxQ_free.QueueLock, Flags);
+	}
+	spin_unlock_irqrestore(&pAC->TxPort[Port][0].TxDesRingLock, Flags);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("<== CheckForSendComplete()\n"));
+
+	return;
+}	/* CheckForSendComplete */
+
+/*****************************************************************************
+ *
+ *	UnmapAndFreeTxPktBuffer
+ *
+ * Description:
+ *      This function free any allocated space of receive buffers
+ *
+ * Arguments:
+ *      pAC - A pointer to the adapter context struct.
+ *
+ */
+static void UnmapAndFreeTxPktBuffer(
+SK_AC       *pAC,       /* pointer to adapter context             */
+SK_PACKET   *pSkPacket,	/* pointer to port struct of ring to fill */
+int          TxPort)    /* TX port index                          */
+{
+	SK_FRAG		*pFrag = pSkPacket->pFrag;
+	SK_FRAG		*pNextFrag;
+	unsigned long	Flags;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("--> UnmapAndFreeTxPktBuffer\n"));
+
+#define TxLock pAC->TxPort[TxPort][TX_PRIO_LOW].TxDesRingLock
+	spin_lock_irqsave(&TxLock,Flags);
+
+	while (pFrag != NULL) {
+		pci_unmap_page(pAC->PciDev,
+				(dma_addr_t) pFrag->pPhys,
+				pFrag->FragLen,
+				PCI_DMA_FROMDEVICE);
+		PUSH_FRAG_AS_LAST_IN_QUEUE(TxPort, pFrag, pNextFrag);
+		pFrag = pNextFrag;
+	}
+
+	DEV_KFREE_SKB_ANY(pSkPacket->pMBuf);
+	pSkPacket->pMBuf	= NULL;
+
+	spin_unlock_irqrestore(&TxLock,Flags);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
+		("<-- UnmapAndFreeTxPktBuffer\n"));
+}
+
+/*****************************************************************************
+ *
+ * 	HandleStatusLEs
+ *
+ * Description:
+ *	This function checks for any new status LEs that may have been 
+  *	received. Those status LEs may either be Rx or Tx ones.
+ *
+ * Returns:	N/A
+ */
+static SK_BOOL HandleStatusLEs(
+#ifdef CONFIG_SK98LIN_NAPI
+SK_AC *pAC,       /* pointer to adapter context   */
+int   *WorkDone,  /* Done counter needed for NAPI */
+int    WorkToDo)  /* ToDo counter for NAPI        */
+#else
+SK_AC *pAC)       /* pointer to adapter context   */
+#endif
+{
+	int	 DoneTxA[SK_MAX_MACS];
+	int	 DoneTxS[SK_MAX_MACS];
+	int	 Port;
+	SK_BOOL	 handledStatLE	= SK_FALSE;
+	SK_BOOL	 NewDone	= SK_FALSE;
+	SK_HWLE	*pLE;
+	SK_U16	 HighVal;
+	SK_U32	 LowVal;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+		("==> HandleStatusLEs\n"));
+
+	do {
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+			("Check next Own Bit of ST-LE[%d]: 0x%li \n",
+			(pAC->StatusLETable.Done + 1) % NUM_LE_IN_TABLE(&pAC->StatusLETable),
+			 OWN_OF_FIRST_LE(&pAC->StatusLETable)));
+
+		while (OWN_OF_FIRST_LE(&pAC->StatusLETable) == HW_OWNER) {
+			GET_ST_LE(pLE, &pAC->StatusLETable);
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+				("Working on finished status LE[%d]:\n",
+				GET_DONE_INDEX(&pAC->StatusLETable)));
+			SK_DBG_DUMP_ST_LE(pLE);
+			handledStatLE = SK_TRUE;
+			switch (STLE_GET_OPC(pLE) & ~HW_OWNER) {
+			case OP_RXSTAT:
+				if (pAC->StatusLETable.private) {
+					/* 
+					** This is always the last Status LE belonging
+					** to a received packet -> handle it...
+					*/
+					HandleReceives(
+						pAC,
+						STLE_GET_LINK(pLE),
+						STLE_GET_LEN(pLE),
+						STLE_GET_FRSTATUS(pLE),
+						pAC->StatusLETable.Bmu.Stat.TcpSum1,
+						pAC->StatusLETable.Bmu.Stat.TcpSum2,
+						pAC->StatusLETable.Bmu.Stat.RxTimeStamp,
+						pAC->StatusLETable.Bmu.Stat.VlanId);
+					pAC->StatusLETable.private = SK_FALSE;
+#ifdef CONFIG_SK98LIN_NAPI
+					if (*WorkDone >= WorkToDo) {
+						break;
+					}
+					(*WorkDone)++;
+#endif
+				} else {
+					pAC->StatusLETable.Bmu.Stat.TcpSum1 = STLE_GET_TCP1(pLE);
+					pAC->StatusLETable.Bmu.Stat.TcpSum2 = STLE_GET_TCP2(pLE);
+					pAC->StatusLETable.private = SK_TRUE;
+				}
+				break;
+			case OP_RXVLAN:
+				/* this value will be used for next RXSTAT */
+				pAC->StatusLETable.Bmu.Stat.VlanId = STLE_GET_VLAN(pLE);
+				break;
+			case OP_RXTIMEVLAN:
+				/* this value will be used for next RXSTAT */
+				pAC->StatusLETable.Bmu.Stat.VlanId = STLE_GET_VLAN(pLE);
+				/* fall through */
+			case OP_RXTIMESTAMP:
+				/* this value will be used for next RXSTAT */
+				pAC->StatusLETable.Bmu.Stat.RxTimeStamp = STLE_GET_TIST(pLE);
+				break;
+			case OP_RXCHKSVLAN:
+				/* this value will be used for next RXSTAT */
+				pAC->StatusLETable.Bmu.Stat.VlanId = STLE_GET_VLAN(pLE);
+				/* fall through */
+			case OP_RXCHKS:
+				/* this value will be used for next RXSTAT */
+				pAC->StatusLETable.Bmu.Stat.TcpSum1 = STLE_GET_TCP1(pLE);
+				pAC->StatusLETable.Bmu.Stat.TcpSum2 = STLE_GET_TCP2(pLE);
+				pAC->StatusLETable.private = SK_TRUE;
+				break;
+			case OP_RSS_HASH:
+				/* this value will be used for next RXSTAT */
+#if 0
+				pAC->StatusLETable.Bmu.Stat.RssHashValue = STLE_GET_RSS(pLE);
+#endif
+				break;
+			case OP_TXINDEXLE:
+				/*
+				** :;:; TODO
+				** it would be possible to check for which queues
+				** the index has been changed and call 
+				** CheckForSendComplete() only for such queues
+				*/
+				STLE_GET_DONE_IDX(pLE,LowVal,HighVal);
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+					("LowVal: 0x%x HighVal: 0x%x\n", LowVal, HighVal));
+
+				/*
+				** It would be possible to check whether we really
+				** need the values for second port or sync queue, 
+				** but I think checking whether we need them is 
+				** more expensive than the calculation
+				*/
+				DoneTxA[0] = STLE_GET_DONE_IDX_TXA1(LowVal,HighVal);
+				DoneTxS[0] = STLE_GET_DONE_IDX_TXS1(LowVal,HighVal);
+				DoneTxA[1] = STLE_GET_DONE_IDX_TXA2(LowVal,HighVal);
+				DoneTxS[1] = STLE_GET_DONE_IDX_TXS2(LowVal,HighVal);
+
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+					("DoneTxa1 0x%x DoneTxS1: 0x%x DoneTxa2 0x%x DoneTxS2: 0x%x\n",
+					DoneTxA[0], DoneTxS[0], DoneTxA[1], DoneTxS[1]));
+
+				NewDone = SK_TRUE;
+				break;
+			default:
+				/* 
+				** We have to handle the illegal Opcode in 
+				** Status LE 
+				*/
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+					("Unexpected OpCode\n"));
+				break;
+			}
+
+			/* 
+			** Reset own bit we have to do this in order to detect a overflow 
+			*/
+			STLE_SET_OPC(pLE, SW_OWNER);
+		}
+
+		/* 
+		** Now handle any new transmit complete 
+		*/
+		if (NewDone) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+				("Done Index for Tx BMU has been changed\n"));
+			for (Port = 0; Port < pAC->GIni.GIMacsFound; Port++) {
+				/* 
+				** Do we have a new Done idx ? 
+				*/
+				if (DoneTxA[Port] != GET_DONE_INDEX(&pAC->TxPort[Port][0].TxALET)) {
+					SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+						("Check TxA%d\n", Port + 1));
+					CheckForSendComplete(pAC, pAC->IoBase, Port,
+						&(pAC->TxPort[Port][0].TxAQ_working),
+						&pAC->TxPort[Port][0].TxALET,
+						DoneTxA[Port]);
+				} else {
+					SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+						("No changes for TxA%d\n", Port + 1));
+				}
+#if USE_SYNC_TX_QUEUE
+				if (HW_SYNC_TX_SUPPORTED(pAC)) {
+					/* 
+					** Do we have a new Done idx ? 
+					*/
+					if (DoneTxS[Port] !=
+						GET_DONE_INDEX(&pAC->TxPort[Port][0].TxSLET)) {
+						SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+							SK_DBGCAT_DRV_INT_SRC,
+							("Check TxS%d\n", Port));
+						CheckForSendComplete(pAC, pAC->IoBase, Port,
+							&(pAC->TxPort[Port][0].TxSQ_working),
+							&pAC->TxPort[Port][0].TxSLET,
+							DoneTxS[Port]);
+					} else {
+						SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+							SK_DBGCAT_DRV_INT_SRC,
+							("No changes for TxS%d\n", Port));
+					}
+				}
+#endif
+			}
+		}
+		NewDone = SK_FALSE;
+
+		/* 
+		** Check whether we have to refill our RX table  
+		*/
+		if (HW_FEATURE(pAC, HWF_WA_DEV_420)) {
+			if (NbrRxBuffersInHW < MAX_NBR_RX_BUFFERS_IN_HW) {
+				for (Port = 0; Port < pAC->GIni.GIMacsFound; Port++) {
+					SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+						("Check for refill of RxBuffers on Port %c\n", 'A' + Port));
+					FillReceiveTableYukon2(pAC, pAC->IoBase, Port);
+				}
+			}
+		} else {
+			for (Port = 0; Port < pAC->GIni.GIMacsFound; Port++) {
+				SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
+					("Check for refill of RxBuffers on Port %c\n", 'A' + Port));
+				if (NUM_FREE_LE_IN_TABLE(&pAC->RxPort[Port].RxLET) >= 64) {
+					FillReceiveTableYukon2(pAC, pAC->IoBase, Port);
+				}
+			}
+		}
+#ifdef CONFIG_SK98LIN_NAPI
+		if (*WorkDone >= WorkToDo) {
+			break;
+		}
+#endif
+	} while (OWN_OF_FIRST_LE(&pAC->StatusLETable) == HW_OWNER);
+
+	/* 
+	** Clear status BMU 
+	*/
+	SK_OUT32(pAC->IoBase, STAT_CTRL, SC_STAT_CLR_IRQ);
+
+	return(handledStatLE);
+}	/* HandleStatusLEs */
+
+/*****************************************************************************
+ *
+ *	AllocateAndInitLETables - allocate memory for the LETable and init
+ *
+ * Description:
+ *	This function will allocate space for the LETable and will also  
+ *	initialize them. The size of the tables must have been specified 
+ *	before.
+ *
+ * Arguments:
+ *	pAC - A pointer to the adapter context struct.
+ *
+ * Returns:
+ *	SK_TRUE  - all LETables initialized
+ *	SK_FALSE - failed
+ */
+static SK_BOOL AllocateAndInitLETables(
+SK_AC  *pAC) /* pointer to adapter context */
+{
+	unsigned	i;	/* for loops */
+	char 		*pVirtMemAddr;
+	dma_addr_t	pPhysMemAddr;
+	unsigned	Size;
+	unsigned	Aligned;
+	unsigned	Alignment;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("==> AllocateAndInitLETables()\n"));
+	/*
+	 * :;:; TODO
+	 * the alignment stuff is not ellegant nor optimized
+	 * its just a short hack to make it working
+	 */
+	Alignment = MAX_LEN_OF_LE_TAB;
+	/* find out how much memory we need */
+	Size = 0;
+	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+		SK_ALIGN_SIZE(LE_TAB_SIZE(RX_MAX_LE), Alignment, Aligned);
+		Size += Aligned;
+		SK_ALIGN_SIZE(LE_TAB_SIZE(TXA_MAX_LE), Alignment, Aligned);
+		Size += Aligned;
+		SK_ALIGN_SIZE(LE_TAB_SIZE(TXS_MAX_LE), Alignment, Aligned);
+		Size += Aligned;
+	}
+	SK_ALIGN_SIZE(LE_TAB_SIZE(ST_MAX_LE), Alignment, Aligned);
+	Size += Aligned;
+	/* if we dont start aligned */
+	Size += Alignment;
+	pAC->SizeOfAlignedLETables = Size;
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("We need %08x Bytes\n", Size));
+	
+	pVirtMemAddr = pci_alloc_consistent(pAC->PciDev, Size, &pPhysMemAddr);
+	if (pVirtMemAddr == NULL) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+			SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+			("AllocateAndInitLETables: kernel malloc failed!\n"));
+		return (SK_FALSE); 
+	}
+	/* pAC->pVirtMemAddr = pVirtMemAddr; */
+
+	/* initialize memory */
+	SK_MEMSET(pVirtMemAddr, 0, Size);
+	ALIGN_ADDR(pVirtMemAddr, Alignment); /* Macro defined in skgew.h */
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("Virtual address of LETab is %8p!\n", pVirtMemAddr));
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("Phys address of LETab is %8p!\n", (void *) pPhysMemAddr));
+
+	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+		/* Rx list element table */
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+			("RxLeTable for Port %c", 'A' + i));
+		SkGeY2InitSingleLETable(
+			pAC,
+			&pAC->RxPort[i].RxLET,
+			RX_MAX_LE,
+			pVirtMemAddr,
+			(SK_U32) (pPhysMemAddr & 0xffffffff),
+			(SK_U32) (((SK_U64) pPhysMemAddr) >> 32));
+
+		SK_ALIGN_SIZE(LE_TAB_SIZE(RX_MAX_LE), Alignment, Aligned);
+		pVirtMemAddr += Aligned;
+		pPhysMemAddr += Aligned;
+
+		/* tx async list element table */
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+			("TxALeTable for Port %c", 'A' + i));
+		SkGeY2InitSingleLETable(
+			pAC,
+			&pAC->TxPort[i][0].TxALET,
+			TXA_MAX_LE,
+			pVirtMemAddr,
+			(SK_U32) (pPhysMemAddr & 0xffffffff),
+			(SK_U32) (((SK_U64) pPhysMemAddr) >> 32));
+
+		SK_ALIGN_SIZE(LE_TAB_SIZE(TXA_MAX_LE), Alignment, Aligned);
+		pVirtMemAddr += Aligned;
+		pPhysMemAddr += Aligned;
+		/* they are now all initialized with 0 which is sufficient */
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+			("TxSLeTable for Port %c", 'A' + i));
+		SkGeY2InitSingleLETable(
+			pAC,
+			&pAC->TxPort[i][0].TxSLET,
+			TXS_MAX_LE,
+			pVirtMemAddr,
+			(SK_U32) (pPhysMemAddr & 0xffffffff),
+			(SK_U32) (((SK_U64) pPhysMemAddr) >> 32));
+
+		SK_ALIGN_SIZE(LE_TAB_SIZE(TXS_MAX_LE), Alignment, Aligned);
+		pVirtMemAddr += Aligned;
+		pPhysMemAddr += Aligned;
+		/* they are now all initialized with 0 which is sufficient */
+	}
+	/* Status list element table */
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("StLeTable"));
+
+	SkGeY2InitSingleLETable(
+		pAC,
+		&pAC->StatusLETable,
+		ST_MAX_LE,
+		pVirtMemAddr,
+		(SK_U32) (pPhysMemAddr & 0xffffffff),
+		(SK_U32) (((SK_U64) pPhysMemAddr) >> 32));
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT, 
+		("<== AllocateAndInitLETables(OK)\n"));
+	return(SK_TRUE);
+}	/* AllocateAndInitLETables */
+
+/*****************************************************************************
+ *
+ *	AllocatePacketBuffersYukon2 - allocate packet and fragment buffers
+ *
+ * Description:
+ *      This function will allocate space for the packets and fragments
+ *
+ * Arguments:
+ *      pAC - A pointer to the adapter context struct.
+ *
+ * Returns:
+ *      SK_TRUE  - Memory was allocated correctly
+ *      SK_FALSE - An error occured
+ */
+
+static SK_BOOL AllocatePacketBuffersYukon2(
+SK_AC   *pAC)   /* pointer to adapter context */
+{
+	SK_PACKET	*pRxPacket;
+	SK_PACKET	*pTxPacket;
+	SK_FRAG		*pRxFrag;
+	SK_FRAG		*pTxFrag;
+	SK_FRAG		*pTxJunkFrag;
+
+	unsigned long	 Flags;
+	unsigned int	 NumberOfBuffers;
+	unsigned int	 i;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("==> AllocatePacketBuffersYukon2()"));
+
+	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+		/* 
+		** Allocate RX packet space, initilize the packets and
+		** add them to the RX waiting queue. Waiting queue means 
+		** that packet and fragment are initialized, but no sk_buff
+		** has been assigned to it yet.
+		*/
+		pAC->RxPort[i].ReceivePacketTable = 
+			kmalloc((RX_MAX_NBR_BUFFERS * sizeof(SK_PACKET)), GFP_KERNEL);
+
+		if (pAC->RxPort[i].ReceivePacketTable == NULL) {
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+					SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+				("no space for ReceivePacketTable (port %i)", i));
+			break;
+		} else {
+			SK_MEMSET(pAC->RxPort[i].ReceivePacketTable, 0, 
+				(RX_MAX_NBR_BUFFERS * sizeof(SK_PACKET)));
+		}
+
+		/*
+		** Allocate space for the receive fragment table
+		*/
+		pAC->RxPort[i].ReceiveFragmentTable = 
+			kmalloc((RX_MAX_NBR_BUFFERS * sizeof(SK_FRAG)), GFP_KERNEL);
+
+		if (pAC->RxPort[i].ReceiveFragmentTable == NULL) {
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+					SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+				("no space for ReceiveFragmentTable (port %i)", i));
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+					SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+				("<== AllocatePacketBuffersYukon2 (FAILURE)\n"));
+			kfree(pAC->RxPort[i].ReceivePacketTable);
+			return(SK_FALSE);
+		}
+
+		pRxFrag   = pAC->RxPort[i].ReceiveFragmentTable;
+		pRxPacket = pAC->RxPort[i].ReceivePacketTable;
+
+		for (   NumberOfBuffers = 0;
+			NumberOfBuffers < RX_MAX_NBR_BUFFERS;
+			NumberOfBuffers++) {
+			PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->RxPort[i].RxQ_waiting, pRxPacket);
+			pRxPacket->pFrag = pRxFrag;
+			pRxFrag++;
+			pRxPacket++;
+		}
+
+		/*
+		** Allocate TX packet space, initialize the packets and
+		** add them to the TX free queue. Free queue means that
+		** packet is available and initialized, but no fragment
+		** has been assigned to it. (Must be done at TX side)
+		*/
+		pAC->TxPort[i][0].TransmitPacketTable = 
+			kmalloc((TX_MAX_NBR_BUFFERS * sizeof(SK_PACKET)), GFP_KERNEL);
+
+		if (pAC->TxPort[i][0].TransmitPacketTable == NULL) {
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+					SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+				("no space for TransmitPacketTable (port %i)", i));
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+					SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+				("<== AllocatePacketBuffersYukon2 (FAILURE)\n"));
+			kfree(pAC->RxPort[i].ReceiveFragmentTable);
+			kfree(pAC->RxPort[i].ReceivePacketTable);
+			return(SK_FALSE);
+		} else {
+			SK_MEMSET(pAC->TxPort[i][0].TransmitPacketTable, 0, 
+				(TX_MAX_NBR_BUFFERS * sizeof(SK_PACKET)));
+		}
+		
+		pTxPacket = pAC->TxPort[i][0].TransmitPacketTable;
+
+		for (	NumberOfBuffers = 0; 
+			NumberOfBuffers < TX_MAX_NBR_BUFFERS; 
+			NumberOfBuffers++) {
+			PUSH_PKT_AS_LAST_IN_QUEUE(&pAC->TxPort[i][0].TxQ_free, pTxPacket);
+			pTxPacket++;
+		}
+
+		/*
+		** Allocate space for the transmit fragments and add
+		** each fragment in the free fragment queue, so that they
+		** can be used in any transmit action.
+		*/
+		pAC->TxPort[i][0].TransmitFragmentTable = 
+			kmalloc(2* (TX_MAX_NBR_BUFFERS * sizeof(SK_FRAG)), GFP_KERNEL);
+
+		if (pAC->TxPort[i][0].TransmitFragmentTable == NULL) {
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 
+					SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+				("no space for TransmitFragmentTable (port %i)", i));
+			SK_DBG_MSG(pAC, SK_DBGMOD_DRV, 
+					SK_DBGCAT_INIT | SK_DBGCAT_DRV_ERROR,
+				("<== AllocatePacketBuffersYukon2 (FAILURE)\n"));
+			kfree(pAC->RxPort[i].ReceivePacketTable);
+			kfree(pAC->RxPort[i].ReceiveFragmentTable);
+			kfree(pAC->TxPort[i][0].TransmitPacketTable);
+			return(SK_FALSE);
+		} else {
+			SK_MEMSET(pAC->TxPort[i][0].TransmitFragmentTable, 0, 
+				(2 * (TX_MAX_NBR_BUFFERS * sizeof(SK_PACKET))));
+		}
+
+		pTxFrag = pAC->TxPort[i][0].TransmitFragmentTable;
+		spin_lock_init(&pAC->TxPort[i][0].TxFreeFragQueue.QueueLock);
+
+		for (	NumberOfBuffers = 0; 
+			NumberOfBuffers < (2 * TX_MAX_NBR_BUFFERS); 
+			NumberOfBuffers++) {
+			/*
+			** pTxJunkFrag provided as return value,
+			** but is not used at allocation time...
+			*/
+			PUSH_FRAG_AS_LAST_IN_QUEUE(i, pTxFrag, pTxJunkFrag);
+			pTxFrag++;
+		}
+	} /* end for (i = 0; i < pAC->GIni.GIMacsFound; i++) */
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_INIT,
+		("<== AllocatePacketBuffersYukon2 (OK)\n"));
+	return(SK_TRUE);
+
+}	/* AllocatePacketBuffersYukon2 */
+
+/*****************************************************************************
+ *
+ *	FreeLETables - release allocated memory of LETables
+ *
+ * Description:
+ *      This function will free all resources of the LETables
+ *
+ * Arguments:
+ *      pAC - A pointer to the adapter context struct.
+ *
+ * Returns: N/A
+ */
+
+static void FreeLETables(
+SK_AC   *pAC)   /* pointer to adapter control context */
+{
+	dma_addr_t		pPhysMemAddr;
+	char *			pVirtMemAddr;
+	/* int			Rtv  = 0; */
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("==> FreeLETables()\n"));
+	
+	/*
+	** The RxLETable is the first of all LET. 
+	** Therefore we can use its address for the input 
+	** of the free function.
+	*/
+	pVirtMemAddr = (char *) pAC->RxPort[0].RxLET.pLETab;
+	pPhysMemAddr = (((SK_U64) pAC->RxPort[0].RxLET.pPhyLETABHigh << (SK_U64) 32) | 
+			((SK_U64) pAC->RxPort[0].RxLET.pPhyLETABLow));
+
+	/* free continuous memory */
+	pci_free_consistent(pAC->PciDev, pAC->SizeOfAlignedLETables,
+			    pVirtMemAddr, pPhysMemAddr);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("<== FreeLETables()\n"));
+}	/* FreeLETables */
+
+/*****************************************************************************
+ *
+ *	FreePacketBuffers - free's all packet buffers of an adapter
+ *
+ * Description:
+ *      This function will free all previously allocated memory of the 
+ *	packet buffers.
+ *
+ * Arguments:
+ *      pAC - A pointer to the adapter context struct.
+ *
+ * Returns: N/A
+ */
+static void FreePacketBuffers(
+SK_AC   *pAC)   /* pointer to adapter control context */
+{
+	int Port;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("==> FreePacketBuffers()\n"));
+	
+	for (Port = 0; Port < pAC->GIni.GIMacsFound; Port++) {
+		kfree(pAC->RxPort[Port].ReceiveFragmentTable);
+		kfree(pAC->RxPort[Port].ReceivePacketTable);
+		kfree(pAC->TxPort[Port][0].TransmitPacketTable);
+		kfree(pAC->TxPort[Port][0].TransmitFragmentTable);
+	}
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_DRV, SK_DBGCAT_DRV_MSG,
+		("<== FreePacketBuffers()\n"));
+}	/* FreePacketBuffers */
+
+/*****************************************************************************
+ *
+ * 	AllocAndMapRxBuffer - fill one buffer into the receive packet/fragment
+ *
+ * Description:
+ *	The function allocates a new receive buffer and assigns it to the
+ *	the passsed receive packet/fragment
+ *
+ * Returns:
+ *	SK_TRUE - a buffer was allocated and assigned
+ *	SK_FALSE - a buffer could not be added
+ */
+static SK_BOOL AllocAndMapRxBuffer(
+SK_AC      *pAC,        /* pointer to the adapter control context */
+SK_PACKET  *pSkPacket,  /* pointer to packet that is to fill      */
+int         Port)       /* port the packet belongs to             */
+{
+	struct sk_buff	*pMsgBlock;	/* pointer to a new message block */
+	SK_U64		PhysAddr;	/* physical address of a rx buffer */
+
+	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("--> AllocAndMapRxBuffer (Port: %i)\n", Port));
+
+	pMsgBlock = alloc_skb(pAC->RxBufSize, GFP_ATOMIC);
+	if (pMsgBlock == NULL) {
+		SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+			SK_DBGCAT_DRV_RX_PROGRESS | SK_DBGCAT_DRV_ERROR,
+			("%s: Allocation of rx buffer failed !\n",
+			pAC->dev[Port]->name));
+		SK_PNMI_CNT_NO_RX_BUF(pAC, pAC->RxPort[Port].PortIndex);
+		return(SK_FALSE);
+	} 
+	/* Alignment for IP frames has been removed, because latest 
+	   common module requires 8 byte alignment of data buffer...
+	else {
+		SK_MEMSET(pMsgBlock->data, 0x00, pAC->RxBufSize);
+	}
+	skb_reserve(pMsgBlock, 2); * to align IP frames *
+	*/
+
+	PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
+		virt_to_page(pMsgBlock->data),
+		((unsigned long) pMsgBlock->data &
+		~PAGE_MASK),
+		pAC->RxBufSize - 2,
+		PCI_DMA_FROMDEVICE);
+
+	pSkPacket->pFrag->pVirt		= pMsgBlock->data;
+	pSkPacket->pFrag->pPhys		= PhysAddr;
+	pSkPacket->pFrag->FragLen	= pAC->RxBufSize - 2; /* for correct unmap later */
+	pSkPacket->pMBuf		= pMsgBlock;	
+	pSkPacket->NumFrags		= 1;
+	pSkPacket->PacketLen		= pAC->RxBufSize - 2;
+
+	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_RX_PROGRESS,
+		("<-- AllocAndMapRxBuffer\n"));
+
+	return (SK_TRUE);
+}	/* AllocAndMapRxBuffer */
+
+/*******************************************************************************
+ *
+ * End of file
+ *
+ ******************************************************************************/
Index: linux-2.6.8/drivers/net/sk98lin/sky2le.c
===================================================================
--- /dev/null
+++ linux-2.6.8/drivers/net/sk98lin/sky2le.c
@@ -0,0 +1,470 @@
+/*****************************************************************************
+ *
+ *	Name:		sky2le.c
+ *	Project:	Gigabit Ethernet Adapters, Common Modules
+ *	Version:	$Revision: 1.8 $
+ *	Date:		$Date: 2004/06/03 15:09:29 $
+ *	Purpose: 	Functions for handling List Element Tables
+ *
+ *****************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 2002-2004 Marvell.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
+static const char SysKonnectFileId[] = "@(#)"
+	"$Id: sky2le.c,v 1.8 2004/06/03 15:09:29 malthoff Exp $ (C) Marvell.";
+#endif /* DEBUG || (!LINT && !SK_SLIM) */
+
+/*****************************************************************************
+ *
+ * Description:
+ *
+ * This module contains the code necessary for handling List Elements.
+ *
+ * Supported Gigabit Ethernet Chipsets:
+ *	Yukon-2 (PCI, PCI-X, PCI-Express)
+ *
+ * Include File Hierarchy:
+ *
+ *
+ *****************************************************************************/
+#include "h/skdrv1st.h"
+#include "h/skdrv2nd.h"
+
+/* defines *******************************************************************/
+/* typedefs ******************************************************************/
+/* global variables **********************************************************/
+/* local variables ***********************************************************/
+/* function prototypes *******************************************************/
+
+/*****************************************************************************
+ *
+ * SkGeY2InitSingleLETable() - initializes a list element table
+ *
+ * Description:
+ *	This function will initialize the selected list element table.
+ *	Should be called once during DriverInit. No InitLevel required.
+ *
+ * Arguments:
+ *	pAC			- pointer to the adapter context struct.
+ *	pLETab		- pointer to list element table structure
+ *	NumLE		- number of list elements in this table
+ *	pVMem		- virtual address of memory allocated for this LE table
+ *	PMemLowAddr - physical address of memory to be used for the LE table
+ *	PMemHighAddr
+ *
+ * Returns:
+ *	nothing
+ */
+void SkGeY2InitSingleLETable(
+SK_AC	*pAC,			/* pointer to adapter context */
+SK_LE_TABLE	*pLETab,	/* pointer to list element table to be initialized */
+unsigned int NumLE,		/* number of list elements to be filled in tab */
+void	*pVMem,			/* virtual address of memory used for list elements */
+SK_U32	PMemLowAddr,	/* physical addr of mem used for LE */
+SK_U32	PMemHighAddr)
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("==> SkGeY2InitSingleLETable()\n"));
+
+#ifdef DEBUG
+	if (NumLE != 2) {	/* not table for polling unit */
+		if ((NumLE % MIN_LEN_OF_LE_TAB) != 0 || NumLE > MAX_LEN_OF_LE_TAB) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
+				("ERROR: Illegal number of list elements %d\n", NumLE));
+		}
+	}
+#endif /* DEBUG */
+
+	/* special case: unused list element table */
+	if (NumLE == 0) {
+		PMemLowAddr = 0;
+		PMemHighAddr = 0;
+		pVMem = 0;
+	}
+
+	/* set addresses */
+	pLETab->pPhyLETABLow = PMemLowAddr;
+	pLETab->pPhyLETABHigh = PMemHighAddr;
+	pLETab->pLETab = (void *)pVMem;
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("contains %d LEs", NumLE));
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		(" and starts at virt %08p and phys %08lx:%08lx\n",
+		pVMem, PMemHighAddr, PMemLowAddr));
+
+	/* initialize indexes */
+	pLETab->Done = 0;
+	pLETab->Put = 0;
+	pLETab->HwPut = 0;
+	/* initialize size */
+	pLETab->Num = NumLE;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("<== SkGeY2InitSingleLETable()\n"));
+}	/* SkGeY2InitSingleLETable */
+
+/*****************************************************************************
+ *
+ * SkGeY2InitPrefetchUnit() - Initialize a Prefetch Unit
+ *
+ * Description:
+ *	Calling this function requires an already configured list element
+ *	table. The prefetch unit to be configured is specified in the parameter
+ *	'Queue'. The function is able to initialze the prefetch units of
+ *	the following queues: Q_R1, Q_R2, Q_XS1, Q_XS2, Q_XA1, Q_XA2.
+ *	The funcution should be called before SkGeInitPort().
+ *
+ * Arguments:
+ *	pAC - pointer to the adapter context struct.
+ *	IoC - I/O context.
+ *	Queue - I/O offset of queue e.g. Q_XA1.
+ *	pLETab - pointer to list element table to be initialized
+ *
+ * Returns: N/A
+ */
+void SkGeY2InitPrefetchUnit(
+SK_AC	*pAC,			/* pointer to adapter context */
+SK_IOC	IoC,			/* I/O context */
+unsigned int Queue,		/* Queue offset for finding the right registers */
+SK_LE_TABLE	*pLETab)	/* pointer to list element table to be initialized */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("==> SkGeY2InitPrefetchUnit()\n"));
+
+#ifdef DEBUG
+	if (Queue != Q_R1 && Queue != Q_R2 && Queue != Q_XS1 &&
+		Queue != Q_XS2 && Queue != Q_XA1 && Queue != Q_XA2) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_ERR,
+			("ERROR: Illegal queue identifier %x\n", Queue));
+	}
+#endif /* DEBUG */
+
+	/* disable the prefetch unit */
+	SK_OUT32(IoC, Y2_PREF_Q_ADDR(Queue, PREF_UNIT_CTRL_REG), PREF_UNIT_RST_SET);
+	SK_OUT32(IoC, Y2_PREF_Q_ADDR(Queue, PREF_UNIT_CTRL_REG), PREF_UNIT_RST_CLR);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Base address: %08lx:%08lx\n", pLETab->pPhyLETABHigh,
+		pLETab->pPhyLETABLow));
+
+	/* Set the list base address  high part*/
+	SK_OUT32(IoC, Y2_PREF_Q_ADDR(Queue, PREF_UNIT_ADDR_HI_REG),
+		pLETab->pPhyLETABHigh);
+
+	/* Set the list base address low part */
+	SK_OUT32(IoC, Y2_PREF_Q_ADDR(Queue, PREF_UNIT_ADDR_LOW_REG),
+		pLETab->pPhyLETABLow);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Last index: %d\n", pLETab->Num-1));
+
+	/* Set the list last index */
+	SK_OUT16(IoC, Y2_PREF_Q_ADDR(Queue, PREF_UNIT_LAST_IDX_REG),
+		(SK_U16)(pLETab->Num - 1));
+
+	/* turn on prefetch unit */
+	SK_OUT32(IoC, Y2_PREF_Q_ADDR(Queue, PREF_UNIT_CTRL_REG), PREF_UNIT_OP_ON);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("<== SkGeY2InitPrefetchUnit()\n"));
+}	/* SkGeY2InitPrefetchUnit */
+
+
+/*****************************************************************************
+ *
+ * SkGeY2InitStatBmu() -	Initialize the Status BMU
+ *
+ * Description:
+ *	Calling this function requires an already configured list element
+ *	table. Ensure the status BMU is only initialized once during
+ *  DriverInit - InitLevel2 required.
+ *
+ * Arguments:
+ *	pAC - pointer to the adapter context struct.
+ *	IoC - I/O context.
+ *	pLETab - pointer to status LE table to be initialized
+ *
+ * Returns: N/A
+ */
+void SkGeY2InitStatBmu(
+SK_AC	*pAC,			/* pointer to adapter context */
+SK_IOC	IoC,			/* I/O context */
+SK_LE_TABLE	*pLETab)	/* pointer to status LE table */
+{
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("==> SkGeY2InitStatBmu()\n"));
+
+	/* disable the prefetch unit */
+	SK_OUT32(IoC, STAT_CTRL, SC_STAT_RST_SET);
+	SK_OUT32(IoC, STAT_CTRL, SC_STAT_RST_CLR);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Base address Low: %08lX\n", pLETab->pPhyLETABLow));
+
+	/* Set the list base address */
+	SK_OUT32(IoC, STAT_LIST_ADDR_LO, pLETab->pPhyLETABLow);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Base address High: %08lX\n", pLETab->pPhyLETABHigh));
+
+	SK_OUT32(IoC, STAT_LIST_ADDR_HI, pLETab->pPhyLETABHigh);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Last index: %d\n", pLETab->Num - 1));
+
+	/* Set the list last index */
+	SK_OUT16(IoC, STAT_LAST_IDX, (SK_U16)(pLETab->Num - 1));
+
+	if (HW_FEATURE(pAC, HWF_WA_DEV_43_418)) {
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+			("Set Tx index threshold\n"));
+		/* WA for dev. #4.3 */
+		SK_OUT16(IoC, STAT_TX_IDX_TH, ST_TXTH_IDX_MASK);
+
+		/* set Status-FIFO watermark */
+		SK_OUT8(IoC, STAT_FIFO_WM, 0x21);		/* WA for dev. #4.18 */
+
+		/* set Status-FIFO ISR watermark */
+		SK_OUT8(IoC, STAT_FIFO_ISR_WM, 0x07);	/* WA for dev. #4.18 */
+
+		/* WA for dev. #4.3 and #4.18 */
+		/* set Status-FIFO Tx timer init value */
+		SK_OUT32(IoC, STAT_TX_TIMER_INI, HW_MS_TO_TICKS(pAC, 10));
+	}
+	else {
+		/*
+		 * Further settings may be added if required...
+		 * 1) Status-FIFO watermark (STAT_FIFO_WM, STAT_FIFO_ISR_WM)
+		 * 2) Status-FIFO timer values (STAT_TX_TIMER_INI,
+		 *		STAT_LEV_TIMER_INI and STAT_ISR_TIMER_INI)
+		 * but tests shows that the default values give the best results,
+		 * therefore the defaults are used.
+		 */
+
+		/*
+		 * Theses settings should avoid the
+		 * temporary hanging of the status BMU.
+		 * May be not all required... still under investigation...
+		 */
+		SK_OUT16(IoC, STAT_TX_IDX_TH, 0x000a);
+
+		/* set Status-FIFO watermark */
+		SK_OUT8(IoC, STAT_FIFO_WM, 0x10);
+		/* set Status-FIFO ISR watermark */
+		SK_OUT8(IoC, STAT_FIFO_ISR_WM, 0x04);
+																
+		SK_OUT32(IoC, STAT_ISR_TIMER_INI, 0x0190);
+	}
+
+	/* start Status-FIFO timer */
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Start Status FiFo timer\n"));
+
+	/* enable the prefetch unit */
+	/* operational bit not functional for Yukon-EC, but fixed in Yukon-2 */
+	SK_OUT32(IoC, STAT_CTRL, SC_STAT_OP_ON);
+
+	/* start Status-FIFO timer */
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Start Status FiFo timer\n"));
+
+	SK_OUT8(IoC, STAT_TX_TIMER_CTRL, TIM_START);
+	SK_OUT8(IoC, STAT_LEV_TIMER_CTRL, TIM_START);
+	SK_OUT8(IoC, STAT_ISR_TIMER_CTRL, TIM_START);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("<== SkGeY2InitStatBmu()\n"));
+}	/* SkGeY2InitStatBmu */
+
+#ifdef USE_POLLING_UNIT
+/*****************************************************************************
+ *
+ * SkGeY2InitPollUnit() -	Initialize the Polling Unit
+ *
+ * Description:
+ *	This function will write the data of one polling LE table into the
+ *  adapter.
+ *
+ * Arguments:
+ *	pAC - pointer to the adapter context struct.
+ *	IoC - I/O context.
+ *	pLETab - pointer to polling LE table to be initialized
+ *
+ * Returns: N/A
+ */
+void SkGeY2InitPollUnit(
+SK_AC	*pAC,			/* pointer to adapter context */
+SK_IOC	IoC,			/* I/O context */
+SK_LE_TABLE	*pLETab)	/* pointer to polling LE table */
+{
+	SK_HWLE	*pLE;
+	int	i;
+#ifdef VCPU
+	VCPU_VARS();
+#endif /* VCPU */
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("==> SkGeY2InitPollUnit()\n"));
+
+#ifdef VCPU
+	for (i = 0; i < SK_MAX_MACS; i++) {
+		GET_PO_LE(pLE, pLETab, i);
+		VCPU_START_AND_COPY_LE();
+		/* initialize polling LE but leave indexes invalid */
+		POLE_SET_OPC(pLE, OP_PUTIDX | HW_OWNER);
+		POLE_SET_LINK(pLE, i);
+		POLE_SET_RXIDX(pLE, 0);
+		POLE_SET_TXAIDX(pLE, 0);
+		POLE_SET_TXSIDX(pLE, 0);
+		VCPU_WRITE_LE();
+		SK_DBG_DUMP_PO_LE(pLE);
+	}
+#endif	/* VCPU */
+
+	/* disable the polling unit */
+	SK_OUT32(IoC, POLL_CTRL, PC_POLL_RST_SET);
+	SK_OUT32(IoC, POLL_CTRL, PC_POLL_RST_CLR);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Base address Low: %08lX\n", pLETab->pPhyLETABLow));
+
+	/* Set the list base address */
+	SK_OUT32(IoC, POLL_LIST_ADDR_LO, pLETab->pPhyLETABLow);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("Base address High: %08lX\n", pLETab->pPhyLETABHigh));
+
+	SK_OUT32(IoC, POLL_LIST_ADDR_HI, pLETab->pPhyLETABHigh);
+
+	/* we don't need to write the last index - it is hardwired to 1 */
+
+	/* enable the prefetch unit */
+	SK_OUT32(IoC, POLL_CTRL, PC_POLL_OP_ON);
+
+	/*
+	 * now we have to start the descriptor poll timer because it triggers
+	 * the polling unit
+	 */
+
+	/*
+	 * ;:;:
+	 * still playing with the value (timer runs at 125 MHz)
+	 * descriptor poll timer is enabled by GeInit
+	 */
+	SK_OUT32(IoC, B28_DPT_INI,
+		(SK_DPOLL_DEF_Y2 * (SK_U32)pAC->GIni.GIHstClkFact / 100));
+
+	SK_OUT8(IoC, B28_DPT_CTRL, TIM_START);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+		("<== SkGeY2InitPollUnit()\n"));
+}	/* SkGeY2InitPollUnit */
+#endif	/* USE_POLLING_UNIT */
+
+
+/******************************************************************************
+ *
+ * SkGeY2SetPutIndex
+ *
+ * Description:
+ *   This function is writing the Done index of a transmit
+ *   list element table.
+ *
+ * Notes:
+ *	Dev. Issue 4.2
+ *
+ * Returns: N/A
+ */
+void SkGeY2SetPutIndex(
+SK_AC	*pAC,					/* pointer to adapter context */
+SK_IOC	IoC,					/* pointer to the IO context */
+SK_U32	StartAddrPrefetchUnit,	/* start address of the prefetch unit */
+SK_LE_TABLE	*pLETab)			/* list element table to work with */
+{
+	unsigned int Put;
+	SK_U16 EndOfListIndex;
+	SK_U16 HwGetIndex;
+	SK_U16 HwPutIndex;
+
+	/* set put index we would like to write */
+	Put = GET_PUT_IDX(pLETab);
+
+	/*
+	 * in this case we wrap around
+	 * new put is lower than last put given to hw
+	 */
+	if (Put < pLETab->HwPut) {
+
+		/* set put index = last index of list */
+		EndOfListIndex = (NUM_LE_IN_TABLE(pLETab)-1);
+
+		/* read get index of hw prefetch unit */
+		SK_IN16(IoC, (StartAddrPrefetchUnit + PREF_UNIT_GET_IDX_REG),
+			&HwGetIndex);
+
+		/* read put index of hw prefetch unit */
+		SK_IN16(IoC, (StartAddrPrefetchUnit + PREF_UNIT_PUT_IDX_REG),
+			&HwPutIndex);
+
+		/* prefetch unit reached end of list */
+		/* prefetch unit reached first list element */
+		if (HwGetIndex == 0) {
+			/* restore watermark */
+			SK_OUT8(IoC, StartAddrPrefetchUnit + PREF_UNIT_FIFO_WM_REG, 0xe0U);
+			/* write put index */
+			SK_OUT16(IoC, StartAddrPrefetchUnit + PREF_UNIT_PUT_IDX_REG,
+				(SK_U16)Put);
+
+			/* remember put index  we wrote to hw */
+			pLETab->HwPut = Put;
+		}
+		else if (HwGetIndex == EndOfListIndex) {
+			/* set watermark to one list element */
+			SK_OUT8(IoC, StartAddrPrefetchUnit + PREF_UNIT_FIFO_WM_REG, 8);
+			/* set put index to first list element */
+			SK_OUT16(IoC, StartAddrPrefetchUnit + PREF_UNIT_PUT_IDX_REG, 0);
+		}
+		/* prefetch unit did not reach end of list yet */
+		/* and we did not write put index to end of list yet */
+		else if ((HwPutIndex != EndOfListIndex) &&
+				 (HwGetIndex != EndOfListIndex)) {
+			/* write put index */
+			SK_OUT16(IoC, StartAddrPrefetchUnit + PREF_UNIT_PUT_IDX_REG,
+				EndOfListIndex);
+		}
+		else {
+			/* do nothing */
+		}
+	}
+	else {
+#ifdef XXX		/* leads in to problems in the Windows Driver */
+		if (Put != pLETab->HwPut) {
+			/* write put index */
+			SK_OUT16(IoC, StartAddrPrefetchUnit + PREF_UNIT_PUT_IDX_REG,
+				(SK_U16)Put);
+			/* update put index */
+			UPDATE_HWPUT_IDX(pLETab);
+		}
+#else
+		/* write put index */
+		SK_OUT16(IoC, StartAddrPrefetchUnit + PREF_UNIT_PUT_IDX_REG,
+			(SK_U16)Put);
+		/* update put index */
+		UPDATE_HWPUT_IDX(pLETab);
+#endif
+	}
+}	/* SkGeY2SetPutIndex */
+
