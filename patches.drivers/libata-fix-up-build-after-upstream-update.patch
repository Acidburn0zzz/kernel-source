From 54ee7cd26c5e438dc15d13b60c9f8a54ca05e3fb Mon Sep 17 00:00:00 2001
From: Tejun Heo <htejun@gmail.com>
Date: Fri, 3 Aug 2007 02:21:51 +0900
Subject: [PATCH] libata: fix up build after upstream update
References: 288078

Signed-off-by: Tejun Heo <htejun@gmail.com>
Signed-off-by: Tejun Heo <teheo@suse.de>
---
 drivers/ata/ata_piix.c         |    6 ++++--
 drivers/ata/pata_ali.c         |   32 +++++++++++++++++---------------
 drivers/ata/pata_amd.c         |    4 +++-
 drivers/ata/pata_cs5530.c      |    2 +-
 drivers/ata/pata_it821x.c      |    3 ++-
 drivers/ata/pata_serverworks.c |    5 ++++-
 drivers/ata/pata_sis.c         |    8 ++++++--
 drivers/ata/pata_sl82c105.c    |    5 ++++-
 drivers/ata/pata_via.c         |    6 ++++--
 drivers/ata/sata_mv.c          |   17 +++++++++++------
 10 files changed, 56 insertions(+), 32 deletions(-)

--- a/drivers/ata/ata_piix.c	2007-10-31 17:44:32.000000000 -0400
+++ b/drivers/ata/ata_piix.c	2007-10-31 17:44:32.000000000 -0400
@@ -1146,17 +1146,19 @@ static int __devinit piix_check_450nx_er
 {
 	struct pci_dev *pdev = NULL;
 	u16 cfg;
+	u8 rev;
 	int no_piix_dma = 0;
 
 	while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82454NX, pdev)) != NULL) {
 		/* Look for 450NX PXB. Check for problem configurations
 		   A PCI quirk checks bit 6 already */
+		pci_read_config_byte(pdev, PCI_REVISION_ID, &rev);
 		pci_read_config_word(pdev, 0x41, &cfg);
 		/* Only on the original revision: IDE DMA can hang */
-		if (pdev->revision == 0x00)
+		if (rev == 0x00)
 			no_piix_dma = 1;
 		/* On all revisions below 5 PXB bus lock must be disabled for IDE */
-		else if (cfg & (1<<14) && pdev->revision < 5)
+		else if (cfg & (1<<14) && rev < 5)
 			no_piix_dma = 2;
 	}
 	if (no_piix_dma)
--- a/drivers/ata/pata_ali.c	2007-10-31 17:43:27.000000000 -0400
+++ b/drivers/ata/pata_ali.c	2007-10-31 17:44:32.000000000 -0400
@@ -462,7 +462,7 @@ static struct ata_port_operations ali_c5
 
 static void ali_init_chipset(struct pci_dev *pdev)
 {
-	u8 tmp;
+	u8 rev, tmp;
 	struct pci_dev *north, *isa_bridge;
 
 	/*
@@ -470,13 +470,13 @@ static void ali_init_chipset(struct pci_
 	 * mode data.
 	 */
 
-	if (pdev->revision >= 0x20 && pdev->revision < 0xC2) {
+	if (rev >= 0x20 && rev < 0xC2) {
 		/* 1543-E/F, 1543C-C, 1543C-D, 1543C-E */
 		pci_read_config_byte(pdev, 0x4B, &tmp);
 		/* Clear CD-ROM DMA write bit */
 		tmp &= 0x7F;
 		pci_write_config_byte(pdev, 0x4B, tmp);
-	} else if (pdev->revision >= 0xC2) {
+	} else if (rev >= 0xC2) {
 		/* Enable cable detection logic */
 		pci_read_config_byte(pdev, 0x4B, &tmp);
 		pci_write_config_byte(pdev, 0x4B, tmp | 0x08);
@@ -488,21 +488,21 @@ static void ali_init_chipset(struct pci_
 		/* Configure the ALi bridge logic. For non ALi rely on BIOS.
 		   Set the south bridge enable bit */
 		pci_read_config_byte(isa_bridge, 0x79, &tmp);
-		if (pdev->revision == 0xC2)
+		if (rev == 0xC2)
 			pci_write_config_byte(isa_bridge, 0x79, tmp | 0x04);
-		else if (pdev->revision > 0xC2 && pdev->revision < 0xC5)
+		else if (rev > 0xC2 && rev < 0xC5)
 			pci_write_config_byte(isa_bridge, 0x79, tmp | 0x02);
 	}
-	if (pdev->revision >= 0x20) {
+	if (rev >= 0x20) {
 		/*
 		 * CD_ROM DMA on (0x53 bit 0). Enable this even if we want
 		 * to use PIO. 0x53 bit 1 (rev 20 only) - enable FIFO control
 		 * via 0x54/55.
 		 */
 		pci_read_config_byte(pdev, 0x53, &tmp);
-		if (pdev->revision <= 0x20)
+		if (rev <= 0x20)
 			tmp &= ~0x02;
-		if (pdev->revision >= 0xc7)
+		if (rev >= 0xc7)
 			tmp |= 0x03;
 		else
 			tmp |= 0x01;	/* CD_ROM enable for DMA */
@@ -584,23 +584,25 @@ static int ali_init_one(struct pci_dev *
 	};
 
 	const struct ata_port_info *ppi[] = { NULL, NULL };
-	u8 tmp;
+	u8 rev, tmp;
 	struct pci_dev *isa_bridge;
 
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev);
+
 	/*
 	 * The chipset revision selects the driver operations and
 	 * mode data.
 	 */
 
-	if (pdev->revision < 0x20) {
+	if (rev < 0x20) {
 		ppi[0] = &info_early;
-	} else if (pdev->revision < 0xC2) {
+	} else if (rev < 0xC2) {
         	ppi[0] = &info_20;
-	} else if (pdev->revision == 0xC2) {
+	} else if (rev == 0xC2) {
         	ppi[0] = &info_c2;
-	} else if (pdev->revision == 0xC3) {
+	} else if (rev == 0xC3) {
         	ppi[0] = &info_c3;
-	} else if (pdev->revision == 0xC4) {
+	} else if (rev == 0xC4) {
         	ppi[0] = &info_c4;
 	} else
         	ppi[0] = &info_c5;
@@ -608,7 +610,7 @@ static int ali_init_one(struct pci_dev *
 	ali_init_chipset(pdev);
 
 	isa_bridge = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, NULL);
-	if (isa_bridge && pdev->revision >= 0x20 && pdev->revision < 0xC2) {
+	if (isa_bridge && rev >= 0x20 && rev < 0xC2) {
 		/* Are we paired with a UDMA capable chip */
 		pci_read_config_byte(isa_bridge, 0x5E, &tmp);
 		if ((tmp & 0x1E) == 0x12)
--- a/drivers/ata/pata_amd.c	2007-10-31 17:43:27.000000000 -0400
+++ b/drivers/ata/pata_amd.c	2007-10-31 17:44:32.000000000 -0400
@@ -623,15 +623,17 @@ static int amd_init_one(struct pci_dev *
 	const struct ata_port_info *ppi[] = { NULL, NULL };
 	static int printed_version;
 	int type = id->driver_data;
+	u8 rev;
 	u8 fifo;
 
 	if (!printed_version++)
 		dev_printk(KERN_DEBUG, &pdev->dev, "version " DRV_VERSION "\n");
 
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev);
 	pci_read_config_byte(pdev, 0x41, &fifo);
 
 	/* Check for AMD7409 without swdma errata and if found adjust type */
-	if (type == 1 && pdev->revision > 0x7)
+	if (type == 1 && rev > 0x7)
 		type = 2;
 
 	/* Check for AMD7411 */
--- a/drivers/ata/pata_cs5530.c	2007-10-31 17:43:27.000000000 -0400
+++ b/drivers/ata/pata_cs5530.c	2007-10-31 17:44:32.000000000 -0400
@@ -266,7 +266,7 @@ static int cs5530_init_chip(void)
 	}
 
 	pci_set_master(cs5530_0);
-	pci_try_set_mwi(cs5530_0);
+	pci_set_mwi(cs5530_0);
 
 	/*
 	 * Set PCI CacheLineSize to 16-bytes:
--- a/drivers/ata/pata_it821x.c	2007-10-31 17:43:27.000000000 -0400
+++ b/drivers/ata/pata_it821x.c	2007-10-31 17:44:32.000000000 -0400
@@ -591,7 +591,8 @@ static int it821x_port_start(struct ata_
 	itdev->want[1][1] = ATA_ANY;
 	itdev->last_device = -1;
 
-	if (pdev->revision == 0x10) {
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &conf);
+	if (conf == 0x10) {
 		itdev->timing10 = 1;
 		/* Need to disable ATAPI DMA for this case */
 		if (!itdev->smart)
--- a/drivers/ata/pata_serverworks.c	2007-10-31 17:43:27.000000000 -0400
+++ b/drivers/ata/pata_serverworks.c	2007-10-31 17:44:32.000000000 -0400
@@ -410,8 +410,11 @@ static int serverworks_fixup_osb4(struct
 
 static int serverworks_fixup_csb(struct pci_dev *pdev)
 {
+	u8 rev;
 	u8 btr;
 
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev);
+
 	/* Third Channel Test */
 	if (!(PCI_FUNC(pdev->devfn) & 1)) {
 		struct pci_dev * findev = NULL;
@@ -453,7 +456,7 @@ static int serverworks_fixup_csb(struct 
 	if (!(PCI_FUNC(pdev->devfn) & 1))
 		btr |= 0x2;
 	else
-		btr |= (pdev->revision >= SVWKS_CSB5_REVISION_NEW) ? 0x3 : 0x2;
+		btr |= (rev >= SVWKS_CSB5_REVISION_NEW) ? 0x3 : 0x2;
 	pci_write_config_byte(pdev, 0x5A, btr);
 
 	return btr;
--- a/drivers/ata/pata_sis.c	2007-10-31 17:43:27.000000000 -0400
+++ b/drivers/ata/pata_sis.c	2007-10-31 17:44:32.000000000 -0400
@@ -931,7 +931,9 @@ static int sis_init_one (struct pci_dev 
 		if (host != NULL) {
 			chipset = sets;			/* Match found */
 			if (sets->device == 0x630) {	/* SIS630 */
-				if (host->revision >= 0x30)	/* 630 ET */
+				u8 host_rev;
+				pci_read_config_byte(host, PCI_REVISION_ID, &host_rev);
+				if (host_rev >= 0x30)	/* 630 ET */
 					chipset = &sis100_early;
 			}
 			break;
@@ -975,6 +977,7 @@ static int sis_init_one (struct pci_dev 
 		u16 trueid;
 		u8 prefctl;
 		u8 idecfg;
+		u8 sbrev;
 
 		/* Try the second unmasking technique */
 		pci_read_config_byte(pdev, 0x4a, &idecfg);
@@ -987,10 +990,11 @@ static int sis_init_one (struct pci_dev 
 			lpc_bridge = pci_get_slot(pdev->bus, 0x10); /* Bus 0 Dev 2 Fn 0 */
 			if (lpc_bridge == NULL)
 				break;
+			pci_read_config_byte(lpc_bridge, PCI_REVISION_ID, &sbrev);
 			pci_read_config_byte(pdev, 0x49, &prefctl);
 			pci_dev_put(lpc_bridge);
 
-			if (lpc_bridge->revision == 0x10 && (prefctl & 0x80)) {
+			if (sbrev == 0x10 && (prefctl & 0x80)) {
 				chipset = &sis133_early;
 				break;
 			}
--- a/drivers/ata/pata_sl82c105.c	2007-10-31 17:43:27.000000000 -0400
+++ b/drivers/ata/pata_sl82c105.c	2007-10-31 17:44:32.000000000 -0400
@@ -270,6 +270,7 @@ static struct ata_port_operations sl82c1
 static int sl82c105_bridge_revision(struct pci_dev *pdev)
 {
 	struct pci_dev *bridge;
+	u8 rev;
 
 	/*
 	 * The bridge should be part of the same device, but function 0.
@@ -291,8 +292,10 @@ static int sl82c105_bridge_revision(stru
 	/*
 	 * We need to find function 0's revision, not function 1
 	 */
+	pci_read_config_byte(bridge, PCI_REVISION_ID, &rev);
+
 	pci_dev_put(bridge);
-	return bridge->revision;
+	return rev;
 }
 
 
--- a/drivers/ata/pata_via.c	2007-10-31 17:43:27.000000000 -0400
+++ b/drivers/ata/pata_via.c	2007-10-31 17:44:32.000000000 -0400
@@ -517,6 +517,7 @@ static int via_init_one(struct pci_dev *
 	struct pci_dev *isa = NULL;
 	const struct via_isa_bridge *config;
 	static int printed_version;
+	u8 t;
 	u8 enable;
 	u32 timing;
 
@@ -530,8 +531,9 @@ static int via_init_one(struct pci_dev *
 			!!(config->flags & VIA_BAD_ID),
 			config->id, NULL))) {
 
-			if (isa->revision >= config->rev_min &&
-			    isa->revision <= config->rev_max)
+			pci_read_config_byte(isa, PCI_REVISION_ID, &t);
+			if (t >= config->rev_min &&
+			    t <= config->rev_max)
 				break;
 			pci_dev_put(isa);
 		}
--- a/drivers/ata/sata_mv.c	2007-10-31 17:43:46.000000000 -0400
+++ b/drivers/ata/sata_mv.c	2007-10-31 17:44:32.000000000 -0400
@@ -1811,9 +1811,12 @@ static int mv5_scr_write(struct ata_port
 
 static void mv5_reset_bus(struct pci_dev *pdev, void __iomem *mmio)
 {
+	u8 rev_id;
 	int early_5080;
 
-	early_5080 = (pdev->device == 0x5080) && (pdev->revision == 0);
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+
+	early_5080 = (pdev->device == 0x5080) && (rev_id == 0);
 
 	if (!early_5080) {
 		u32 tmp = readl(mmio + MV_PCI_EXP_ROM_BAR_CTL);
@@ -2446,14 +2449,17 @@ static int mv_chip_id(struct ata_host *h
 {
 	struct pci_dev *pdev = to_pci_dev(host->dev);
 	struct mv_host_priv *hpriv = host->private_data;
+	u8 rev_id;
 	u32 hp_flags = hpriv->hp_flags;
 
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+
 	switch (board_idx) {
 	case chip_5080:
 		hpriv->ops = &mv5xxx_ops;
 		hp_flags |= MV_HP_GEN_I;
 
-		switch (pdev->revision) {
+		switch (rev_id) {
 		case 0x1:
 			hp_flags |= MV_HP_ERRATA_50XXB0;
 			break;
@@ -2473,7 +2479,7 @@ static int mv_chip_id(struct ata_host *h
 		hpriv->ops = &mv5xxx_ops;
 		hp_flags |= MV_HP_GEN_I;
 
-		switch (pdev->revision) {
+		switch (rev_id) {
 		case 0x0:
 			hp_flags |= MV_HP_ERRATA_50XXB0;
 			break;
@@ -2493,7 +2499,7 @@ static int mv_chip_id(struct ata_host *h
 		hpriv->ops = &mv6xxx_ops;
 		hp_flags |= MV_HP_GEN_II;
 
-		switch (pdev->revision) {
+		switch (rev_id) {
 		case 0x7:
 			hp_flags |= MV_HP_ERRATA_60X1B2;
 			break;
@@ -2513,7 +2519,7 @@ static int mv_chip_id(struct ata_host *h
 		hpriv->ops = &mv6xxx_ops;
 		hp_flags |= MV_HP_GEN_IIE;
 
-		switch (pdev->revision) {
+		switch (rev_id) {
 		case 0x0:
 			hp_flags |= MV_HP_ERRATA_XX42A0;
 			break;
@@ -2728,7 +2734,6 @@ static int mv_init_one(struct pci_dev *p
 	mv_print_info(host);
 
 	pci_set_master(pdev);
-	pci_try_set_mwi(pdev);
 	return ata_host_activate(host, pdev->irq, mv_interrupt, IRQF_SHARED,
 				 IS_GEN_I(hpriv) ? &mv5_sht : &mv6_sht);
 }
