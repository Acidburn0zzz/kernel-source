From: Gray Hade <garyhade@us.ibm.com>
Date: Wed, 7 Feb 2007 12:37:41 -0800
Subject: [PATCH] libata: add waits for GoVault
References: 246451

Iomega GoVault drives need specific waits here and there.  Upstream
approach hasn't been determined yet.  This is temp solution from Gary
Hade.  Read the following thread for details.

http://thread.gmane.org/gmane.linux.ide/14545/focus=14663

Signed-off-by: Tejun Heo <htejun@gmail.com>
---
 drivers/ata/libata-core.c |   27 +++++++++++++++++++++++++--
 1 file changed, 25 insertions(+), 2 deletions(-)

Index: linux-2.6.22/drivers/ata/libata-core.c
===================================================================
--- linux-2.6.22.orig/drivers/ata/libata-core.c
+++ linux-2.6.22/drivers/ata/libata-core.c
@@ -3105,6 +3105,8 @@ static int ata_bus_softreset(struct ata_
 			     unsigned long deadline)
 {
 	struct ata_ioports *ioaddr = &ap->ioaddr;
+	unsigned long timeout;
+	u8 status;
 
 	DPRINTK("ata%u: bus reset via SRST\n", ap->print_id);
 
@@ -3127,11 +3129,22 @@ static int ata_bus_softreset(struct ata_
 	 */
 	msleep(150);
 
+	/* For those controllers where the status could start out at
+	 * 0xFF even though the device is present we wait up to 2 seconds
+	 * longer for slower removable media devices to respond.
+	 */
+	status = ata_chk_status(ap);
+	timeout = jiffies + 2*HZ;
+	while (status == 0xFF && time_before(jiffies, timeout)) {
+		msleep(50);
+		status = ata_chk_status(ap);
+	}
+
 	/* Before we perform post reset processing we want to see if
 	 * the bus shows 0xFF because the odd clown forgets the D7
 	 * pulldown resistor.
 	 */
-	if (ata_check_status(ap) == 0xFF)
+	if (status == 0xFF)
 		return -ENODEV;
 
 	return ata_bus_post_reset(ap, devmask, deadline);
@@ -3379,7 +3392,9 @@ int ata_std_prereset(struct ata_link *li
 	}
 
 	/* Wait for !BSY if the controller can wait for the first D2H
-	 * Reg FIS and we don't know that no device is attached.
+	 * Reg FIS and we don't know that no device is attached.  For
+	 * other controllers a brief wait (up to 3 secs) may be needed
+	 * for some devices.
 	 */
 	if (!(link->flags & ATA_LFLAG_SKIP_D2H_BSY) && !ata_link_offline(link)) {
 		rc = ata_wait_ready(ap, deadline);
@@ -3388,6 +3403,14 @@ int ata_std_prereset(struct ata_link *li
 					"(errno=%d), forcing hardreset\n", rc);
 			ehc->i.action |= ATA_EH_HARDRESET;
 		}
+	} else {
+		unsigned long timeout = jiffies + 3*HZ;
+		u8 status = ata_chk_status(ap);
+
+		while ((status & ATA_BUSY) && time_before(jiffies, timeout)) {
+			msleep(50);
+			status = ata_chk_status(ap);
+		}
 	}
 
 	return 0;
