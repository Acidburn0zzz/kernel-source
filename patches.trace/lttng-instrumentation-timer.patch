From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Subject: LTTng instrumentation - timer

Original patch header:
  LTTng instrumentation - timer
  
  Instrument timer activity (timer set, expired, current time updates) to keep
  information about the "real time" flow within the kernel. It can be used by a
  trace analysis tool to synchronize information coming from various sources, e.g.
  to merge traces with system logs.
  
  Those tracepoints are used by LTTng.
  
  About the performance impact of tracepoints (which is comparable to markers),
  even without immediate values optimizations, tests done by Hideo Aoki on ia64
  show no regression. His test case was using hackbench on a kernel where
  scheduler instrumentation (about 5 events in code scheduler code) was added.
  See the "Tracepoints" patch header for performance result detail.
  
  Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
  CC: 'Ingo Molnar' <mingo@elte.hu>
  CC: "David S. Miller" <davem@davemloft.net>
  CC: Masami Hiramatsu <mhiramat@redhat.com>
  CC: 'Peter Zijlstra' <peterz@infradead.org>
  CC: "Frank Ch. Eigler" <fche@redhat.com>
  CC: 'Hideo AOKI' <haoki@redhat.com>
  CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
  CC: 'Steven Rostedt' <rostedt@goodmis.org>
  CC: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>

Acked-by: Jan Blunck <jblunck@suse.de>
--- 
---
 include/trace/timer.h |   24 ++++++++++++++++++++++++
 kernel/itimer.c       |    8 ++++++++
 kernel/timer.c        |   12 +++++++++++-
 3 files changed, 43 insertions(+), 1 deletion(-)

--- /dev/null
+++ b/include/trace/timer.h
@@ -0,0 +1,24 @@
+#ifndef _TRACE_TIMER_H
+#define _TRACE_TIMER_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_TRACE(timer_itimer_expired,
+	TPPROTO(struct signal_struct *sig),
+	TPARGS(sig));
+DECLARE_TRACE(timer_itimer_set,
+	TPPROTO(int which, struct itimerval *value),
+	TPARGS(which, value));
+DECLARE_TRACE(timer_set,
+	TPPROTO(struct timer_list *timer),
+	TPARGS(timer));
+/*
+ * xtime_lock is taken when kernel_timer_update_time tracepoint is reached.
+ */
+DECLARE_TRACE(timer_update_time,
+	TPPROTO(struct timespec *_xtime, struct timespec *_wall_to_monotonic),
+	TPARGS(_xtime, _wall_to_monotonic));
+DECLARE_TRACE(timer_timeout,
+	TPPROTO(struct task_struct *p),
+	TPARGS(p));
+#endif
--- a/kernel/itimer.c
+++ b/kernel/itimer.c
@@ -12,6 +12,7 @@
 #include <linux/time.h>
 #include <linux/posix-timers.h>
 #include <linux/hrtimer.h>
+#include <trace/timer.h>
 
 #include <asm/uaccess.h>
 
@@ -123,6 +124,8 @@ enum hrtimer_restart it_real_fn(struct h
 	struct signal_struct *sig =
 		container_of(timer, struct signal_struct, real_timer);
 
+	trace_timer_itimer_expired(sig);
+
 	kill_pid_info(SIGALRM, SEND_SIG_PRIV, sig->leader_pid);
 
 	return HRTIMER_NORESTART;
@@ -148,6 +151,8 @@ int do_setitimer(int which, struct itime
 	    !timeval_valid(&value->it_interval))
 		return -EINVAL;
 
+	trace_timer_itimer_set(which, value);
+
 	switch (which) {
 	case ITIMER_REAL:
 again:
@@ -280,3 +285,6 @@ SYSCALL_DEFINE3(setitimer, int, which, s
 		return -EFAULT;
 	return 0;
 }
+
+DEFINE_TRACE(timer_itimer_expired);
+DEFINE_TRACE(timer_itimer_set);
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -37,12 +37,14 @@
 #include <linux/delay.h>
 #include <linux/tick.h>
 #include <linux/kallsyms.h>
+#include <trace/timer.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 #include <asm/div64.h>
 #include <asm/timex.h>
 #include <asm/io.h>
+#include <asm/irq_regs.h>
 
 u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;
 
@@ -357,6 +359,7 @@ static void internal_add_timer(struct tv
 		i = (expires >> (TVR_BITS + 3 * TVN_BITS)) & TVN_MASK;
 		vec = base->tv5.vec + i;
 	}
+	trace_timer_set(timer);
 	/*
 	 * Timers are FIFO:
 	 */
@@ -1121,6 +1124,7 @@ void do_timer(unsigned long ticks)
 {
 	jiffies_64 += ticks;
 	update_times(ticks);
+	trace_timer_update_time(&xtime, &wall_to_monotonic);
 }
 
 #ifdef __ARCH_WANT_SYS_ALARM
@@ -1202,7 +1206,9 @@ SYSCALL_DEFINE0(getegid)
 
 static void process_timeout(unsigned long __data)
 {
-	wake_up_process((struct task_struct *)__data);
+	struct task_struct *task = (struct task_struct *)__data;
+	trace_timer_timeout(task);
+	wake_up_process(task);
 }
 
 /**
@@ -1581,3 +1587,7 @@ unsigned long msleep_interruptible(unsig
 }
 
 EXPORT_SYMBOL(msleep_interruptible);
+
+DEFINE_TRACE(timer_set);
+DEFINE_TRACE(timer_update_time);
+DEFINE_TRACE(timer_timeout);
