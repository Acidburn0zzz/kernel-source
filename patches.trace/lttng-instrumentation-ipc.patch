From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Subject: LTTng instrumentation - ipc

Original patch header:
  LTTng instrumentation - ipc
  
  Interprocess communication, core events.
  
  Added tracepoints :
  
  ipc_msg_create
  ipc_sem_create
  ipc_shm_create
  
  Those tracepoints are used by LTTng.
  
  About the performance impact of tracepoints (which is comparable to markers),
  even without immediate values optimizations, tests done by Hideo Aoki on ia64
  show no regression. His test case was using hackbench on a kernel where
  scheduler instrumentation (about 5 events in code scheduler code) was added.
  See the "Tracepoints" patch header for performance result detail.
  
  Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
  CC: Masami Hiramatsu <mhiramat@redhat.com>
  CC: 'Peter Zijlstra' <peterz@infradead.org>
  CC: "Frank Ch. Eigler" <fche@redhat.com>
  CC: 'Ingo Molnar' <mingo@elte.hu>
  CC: 'Hideo AOKI' <haoki@redhat.com>
  CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
  CC: 'Steven Rostedt' <rostedt@goodmis.org>
  CC: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>

Acked-by: Jan Blunck <jblunck@suse.de>
--- 
---
 include/trace/ipc.h |   15 +++++++++++++++
 ipc/msg.c           |    7 ++++++-
 ipc/sem.c           |    7 ++++++-
 ipc/shm.c           |    7 ++++++-
 4 files changed, 33 insertions(+), 3 deletions(-)

--- /dev/null
+++ b/include/trace/ipc.h
@@ -0,0 +1,15 @@
+#ifndef _TRACE_IPC_H
+#define _TRACE_IPC_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_TRACE(ipc_msg_create,
+	TPPROTO(long id, int flags),
+	TPARGS(id, flags));
+DECLARE_TRACE(ipc_sem_create,
+	TPPROTO(long id, int flags),
+	TPARGS(id, flags));
+DECLARE_TRACE(ipc_shm_create,
+	TPPROTO(long id, int flags),
+	TPARGS(id, flags));
+#endif
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -38,6 +38,7 @@
 #include <linux/rwsem.h>
 #include <linux/nsproxy.h>
 #include <linux/ipc_namespace.h>
+#include <trace/ipc.h>
 
 #include <asm/current.h>
 #include <asm/uaccess.h>
@@ -314,6 +315,7 @@ SYSCALL_DEFINE2(msgget, key_t, key, int,
 	struct ipc_namespace *ns;
 	struct ipc_ops msg_ops;
 	struct ipc_params msg_params;
+	long ret;
 
 	ns = current->nsproxy->ipc_ns;
 
@@ -324,7 +326,9 @@ SYSCALL_DEFINE2(msgget, key_t, key, int,
 	msg_params.key = key;
 	msg_params.flg = msgflg;
 
-	return ipcget(ns, &msg_ids(ns), &msg_ops, &msg_params);
+	ret = ipcget(ns, &msg_ids(ns), &msg_ops, &msg_params);
+	trace_ipc_msg_create(ret, msgflg);
+	return ret;
 }
 
 static inline unsigned long
@@ -942,3 +946,4 @@ static int sysvipc_msg_proc_show(struct
 			msq->q_ctime);
 }
 #endif
+DEFINE_TRACE(ipc_msg_create);
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -83,6 +83,7 @@
 #include <linux/rwsem.h>
 #include <linux/nsproxy.h>
 #include <linux/ipc_namespace.h>
+#include <trace/ipc.h>
 
 #include <asm/uaccess.h>
 #include "util.h"
@@ -313,6 +314,7 @@ SYSCALL_DEFINE3(semget, key_t, key, int,
 	struct ipc_namespace *ns;
 	struct ipc_ops sem_ops;
 	struct ipc_params sem_params;
+	long err;
 
 	ns = current->nsproxy->ipc_ns;
 
@@ -327,7 +329,9 @@ SYSCALL_DEFINE3(semget, key_t, key, int,
 	sem_params.flg = semflg;
 	sem_params.u.nsems = nsems;
 
-	return ipcget(ns, &sem_ids(ns), &sem_ops, &sem_params);
+	err = ipcget(ns, &sem_ids(ns), &sem_ops, &sem_params);
+	trace_ipc_sem_create(err, semflg);
+	return err;
 }
 
 /*
@@ -1378,3 +1382,4 @@ static int sysvipc_sem_proc_show(struct
 			  sma->sem_ctime);
 }
 #endif
+DEFINE_TRACE(ipc_sem_create);
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -39,6 +39,7 @@
 #include <linux/nsproxy.h>
 #include <linux/mount.h>
 #include <linux/ipc_namespace.h>
+#include <trace/ipc.h>
 
 #include <asm/uaccess.h>
 
@@ -447,6 +448,7 @@ SYSCALL_DEFINE3(shmget, key_t, key, size
 	struct ipc_namespace *ns;
 	struct ipc_ops shm_ops;
 	struct ipc_params shm_params;
+	long err;
 
 	ns = current->nsproxy->ipc_ns;
 
@@ -458,7 +460,9 @@ SYSCALL_DEFINE3(shmget, key_t, key, size
 	shm_params.flg = shmflg;
 	shm_params.u.size = size;
 
-	return ipcget(ns, &shm_ids(ns), &shm_ops, &shm_params);
+	err = ipcget(ns, &shm_ids(ns), &shm_ops, &shm_params);
+	trace_ipc_shm_create(err, shmflg);
+	return err;
 }
 
 static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)
@@ -1086,3 +1090,4 @@ static int sysvipc_shm_proc_show(struct
 			  shp->shm_ctim);
 }
 #endif
+DEFINE_TRACE(ipc_shm_create);
