From: John Johansen <jjohansen@suse.de>
Subject: Fix __d_path to allow for old and new behavior bnc#380763

Fix __d_path so that it can be told whether or not to connect
disconnect path to the root.  This is easier and more efficient
than trying to reconnect these paths for d_path and get_cwd
after the fact.

Signed-off-by: John Johansen <jjohansen@suse.de>

---
 fs/dcache.c            |   26 +++++++-------------------
 fs/namespace.c         |    2 +-
 fs/seq_file.c          |    2 +-
 include/linux/dcache.h |    3 ++-
 4 files changed, 11 insertions(+), 22 deletions(-)

--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -1764,6 +1764,7 @@ static int prepend(char **buffer, int *b
  * @buffer: buffer to return value in
  * @buflen: buffer length
  * @fail_deleted: what to return for deleted files
+ * @disconnect: don't return a path starting with / when disconnected
  *
  * Convert a dentry into an ASCII path name. If the entry has been deleted,
  * then if @fail_deleted is true, ERR_PTR(-ENOENT) is returned. Otherwise,
@@ -1776,7 +1777,7 @@ static int prepend(char **buffer, int *b
  * case will be relative (i.e., it will not start with a slash).
  */
 char *__d_path(const struct path *path, struct path *root,
-	       char *buffer, int buflen, int fail_deleted)
+	       char *buffer, int buflen, int fail_deleted, int disconnect)
 {
 	struct dentry *dentry = path->dentry;
 	struct vfsmount *vfsmnt = path->mnt;
@@ -1840,7 +1841,7 @@ global_root:
 	 * unconnected dentry, or the file is on a pseudo filesystem.
 	 */
 	is_slash = (dentry->d_name.len == 1 && *dentry->d_name.name == '/');
-	if (is_slash || (dentry->d_sb->s_flags & MS_NOUSER)) {
+	if (disconnect && (is_slash || (dentry->d_sb->s_flags & MS_NOUSER))) {
 		/*
 		 * Make sure we won't return a pathname starting with '/'.
 		 *
@@ -1855,6 +1856,8 @@ global_root:
 		}
 		if (is_slash)
 			goto out;
+	} else if (is_slash && *buffer == '/') {
+		goto out;
 	}
 	if (prepend(&buffer, &buflen, dentry->d_name.name,
 		    dentry->d_name.len) != 0)
@@ -1870,19 +1873,6 @@ Elong:
 	goto out;
 }
 
-static char *__connect_d_path(char *path, char *buffer, struct dentry *dentry)
-{
-	if (!IS_ERR(path) && *path != '/' &&
-	    !(dentry->d_sb->s_flags & MS_NOUSER)) {
-		/* Pretend that disconnected paths are hanging off the root. */
-		if (path == buffer)
-			path = ERR_PTR(-ENAMETOOLONG);
-		else
-			*--path = '/';
-	}
-	return path;
-}
-
 /**
  * d_path - return the path of a dentry
  * @path: path to report
@@ -1917,8 +1907,7 @@ char *d_path(struct path *path, char *bu
 	path_get(&root);
 	read_unlock(&current->fs->lock);
 	tmp = root;
-	res = __d_path(path, &tmp, buf, buflen, 0);
-	res = __connect_d_path(res, buf, path->dentry);
+	res = __d_path(path, &tmp, buf, buflen, 0, 0);
 	path_put(&root);
 	return res;
 }
@@ -2020,8 +2009,7 @@ asmlinkage long sys_getcwd(char __user *
 	path_get(&root);
 	read_unlock(&current->fs->lock);
 
-	cwd = __d_path(&pwd, &root, page, PAGE_SIZE, 1);
-	cwd = __connect_d_path(cwd, page, pwd.dentry);
+	cwd = __d_path(&pwd, &root, page, PAGE_SIZE, 1, 0);
 	error = PTR_ERR(cwd);
 	if (IS_ERR(cwd))
 		goto out;
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -2369,7 +2369,7 @@ char *d_namespace_path(struct dentry *de
 	if (ns_root.mnt)
 		ns_root.dentry = dget(ns_root.mnt->mnt_root);
 	spin_unlock(&vfsmount_lock);
-	res = __d_path(&path, &ns_root, buf, buflen, 1);
+	res = __d_path(&path, &ns_root, buf, buflen, 1, 1);
 	path_put(&root);
 	path_put(&ns_root);
 
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -406,7 +406,7 @@ int seq_path_root(struct seq_file *m, st
 		char *p;
 
 		spin_lock(&dcache_lock);
-		p = __d_path(path, root, s, m->size - m->count, 0);
+		p = __d_path(path, root, s, m->size - m->count, 0, 0);
 		spin_unlock(&dcache_lock);
 		err = PTR_ERR(p);
 		if (!IS_ERR(p)) {
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -299,7 +299,8 @@ extern int d_validate(struct dentry *, s
  */
 extern char *dynamic_dname(struct dentry *, char *, int, const char *, ...);
 
-extern char *__d_path(const struct path *path, struct path *root, char *, int, int);
+extern char *__d_path(const struct path *path, struct path *root, char *,
+		      int, int, int);
 extern char *d_path(struct path *, char *, int);
 extern char *dentry_path(struct dentry *, char *, int);
 
