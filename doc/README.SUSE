WORKING WITH THE SUSE KERNEL SOURCES

Andreas Gruenbacher <agruen@suse.de>, SUSE Labs, 2003-2004


This document gives an overview of how SUSE Linux kernels are
created, and describes tasks like building individual kernels
and creating external kernel modules.

A companion Update Media HOWTO that describes how to build driver update
disks (among other things) is available at:

    ftp://ftp.suse.com/pub/people/hvogel/Update-Media-HOWTO.


TABLE OF CONTENTS

  Overview
  Compiling your own kernel
  Building external modules
  Supported vs. unsupported modules
  Patch selection mechanism
  Where to find configuration files
  How to configure the kernel sources
  Module load paths
  Trigger scripts


OVERVIEW

The kernels for SUSE are generated from the vanilla Linux kernel sources
found at http://ftp.kernel.org, on top of which a number of patches are
applied. The resulting kernel source tree is configured and built,
resulting in a binary kernel.

Internally, the add-on patches and configuration files are maintained in
a CVS repository. The repository files are packed up for processing by
RPM. RPM then builds four kinds of packages from these sources:

  *  kernel-source

     The kernel source tree, generated by unpacking the vanilla kernel
     sources and applying the patches. The kernel sources are used by
     a number of other packages. They can also be used for compiling
     additional kernel modules.

  *  kernel-$FLAVOR

     A number of binary kernels (for example, kernel-default for
     uniprocessor machines, kernel-smp for smp machines, etc.). These
     packages are all generated from the same kernel sources, and
     differ in the kernel configurations used.

  *  kernel-syms

     Kernel symbol version information for compiling external modules:
     Functions and data structures that the kernel exports have version
     information attached. When loading kernel modules, this version
     information is used to make sure that the modules match the running
     kernel.

  *  kernel-dummy

     This package is relevant inside the SUSE build system only. We use
     it to synchronize release numbers among the kernel packages. When
     building packages locally, the kernel-dummy package can safely be
     ignored.


				  +------------+
				  | Kernel CVS |
				  +-----+------+
					|
					|
				+----------------+
				| kernel-source/ |
				+-------+--------+
					|
		+-----------------------------+--------------------+
		|			      |                    |
   +-------------------------+   +--------------------------+   +-----+
   | kernel-source.$ARCH.rpm |   | kernel-$FLAVOR.$ARCH.rpm |   | ... |
   +-------------------------+   +--------------------------+   +-----+


The CVS repository contains the configuration files (.config) for all
SUSE kernel flavors. All configuration files are included in the
kernel-source package (see WHERE TO FIND CONFIGURATION FILES below).

The binary kernel packages are build in build environments in which a
number of packages containing additional kernel modules are installed.
These packages all have a name prefix of ``km_''. These packages
install the sources for additional kernel modules below
/usr/src/kernel-modules/. When the binary kernels are built, all modules
below /usr/src/kernel-modules/ are included.

Usually, km_* packages get built from a package that contains some
kernel modules and the associated user space components. The pcmcia
package is one example.


			      +---------+
			      | pcmcia/ |
			      +----+----+
				   |
				   |
			+---------------------+
			|  km_pcmcia.i586.rpm |
			+---------------------+


In the installed system, the kernel-source package installs files in the
following directories:


  *  /usr/src/linux-$VERSION-$RELEASE/

     The kernel sources.
     
  *  /usr/src/linux

     A symbolic link to /usr/src/linux-$VERSION-$RELEASE.

  *  /usr/src/linux-$VERSION-$RELEASE-obj/$ARCH/$FLAVOR/

     Kernel build object files for one kernel flavor. These
     files are used for compiling additional kernel modules.

  *  /usr/src/linux-obj

     A symbolic link to /usr/src/linux-$VERSION-$RELEASE-obj/$ARCH/$FLAVOR.

  *  /usr/share/doc/packages/kernel-source/

     This document and an external kernel module example.

  *  /etc/init.d/running-kernel

     Init script that adapts the kernel sources in /usr/src/linux to
     the running kernel.


COMPILING YOUR OWN KERNEL

The kernel sources are found in the kernel-source.$ARCH.rpm package. The
recommended way to produce a binary kernel is:

  (1)  Install kernel-source.$ARCH.rpm. Change to the /usr/src/linux
       directory.

  (2)  Configure the kernel (for example, ``make oldconfig'' or ``make
       cloneconfig'', see HOW TO CONFIGURE THE KERNEL SOURCES).

  (3)  Build the static kernel image (for example, ``make bzImage'').

  (4)  Build the modules in the kernel source tree by running
       ``make modules''.

  (5)  Install the kernel and the modules (``make install'' and
       ``make modules_install'').

  (6)  Run mkinitrd for the new kernel (see ``mkinitrd -h'').

  (7)  Add the kernel to the boot manager. When using lilo, run ``lilo''
       to update the boot map.

Step (3) differs slightly among different architectures. Here is a list
of commands for bilding the static kernel image:

   Architecture                 Command
   ------------			-------
   axp				make boot
   ia32 (x86)			make bzImage
   ia64				make compressed
   ppc, ppc64			ake zImage
   s390, s390x			make image
   x86_64 (amd64, em64t)	make bzImage
   User Mode Linux (ia32)	make linux ARCH=um


For building kernel modules from one or more of the km_* packages,
install the km_* packages. Each km_* package installes the module
source files into a directory below /usr/src/kernel-modules.

Some of the km_* packages look for the kernel sources in /usr/src/linux,
while others follow the symbolic link /lib/modules/$(uname -r)/build.
For consistent results, boot into the kernel for which you want to build
modules, and then make distclean, cloneconfig, and dep in
/usr/src/linux. Then, do the following for each such directory:

  (1)  Change into /usr/src/kernel-modules/$DIR/.

  (2)  Build the module(s) by typing
       ``make modules KERNEL_SOURCE=/usr/src/linux''.

  (3)  Install the module(s) by typing
       ``make install KERNEL_SOURCE=/usr/src/linux''.


Instead of building binary kernels by hand, you can also build
one of the kernel-$FLAVOR packages using RPM.


BUILDING EXTERNAL MODULES

Additional kernel modules for one of the SUSE kernel flavors can be
built in two different ways, either by configuring the kernel sources in
/usr/src/linux (or a copy, see HOW TO CONFIGURE THE KERNEL SOURCES), or
by using one of the configurations in /usr/src/linux-obj/$ARCH/$FLAVOR.
When building modules for update media, we recommend the latter.

The first method involves the following steps:

  (1)  Install kernel-source.$ARCH.rpm.
  
  (2)  Change to the /usr/src/linux directory.  Configure the kernel
       (for example, ``make oldconfig'' or ``make cloneconfig'', see
       HOW TO CONFIGURE THE KERNEL SOURCES).

  (3)  Compile the module(s) by changing into the module source directory
       and typing ``make -C /usr/src/linux M=`pwd` modules''.

  (4)  Install the module(s) by typing
       ``make -C /usr/src/linux M=`pwd` modules_install''.


The second method involves the following steps:

  (1)  Install kernel-source.$ARCH.rpm.

  (2)  Install kernel-syms.$ARCH.rpm. This package is necessary for
       symbol version information (CONFIG_MODVERSIONS).

  (3)  Compile the module(s) by changing into the module source directory
       and typing ``make -C /usr/src/linux
	  O=/usr/src/linux-obj/$ARCH/$FLAVOR M=`pwd` modules''.
	  Substitute $ARCH and $FLAVOR with the architecture and flavor
	  for which to build the module(s).

  (4)  Install he module(s) by typing ``make -C /usr/src/linux
	  O=/usr/src/linux-obj/$ARCH/$FLAVOR M=`pwd` modules_install''.


Whenever building modules, please use the kernel build infrastructure as
much as possible, and do not try to circumvent it. The
Documentation/kbuild directory in the kernel sources describes what
makefiles for the kernel build infrastructure must contain. 

Please take a look at the demo module installed under
/usr/share/doc/packages/kernel-source for a simple example of an
external module.


SUPPORTED VS. UNSUPPORTED MODULES

As an extension to the mainline kernel, modules can be tagged as
supported (directly by SUSE, or indirectly by a third party) or
unsupported. Modules which are known to be flakey or for which SUSE does
not have the necessary expertise are marked as unsupported.  Modules for
which SUSE has third-party support agreements are marked as externally
supported. Modules for which SUSE provides direct support are marked as
supported.

The support status of a module can be queried with the modinfo tool.
Modinfo will report one of the following:

  - direct support by SUSE: "supported: yes"
  - third-party support: "supported: external"
  - unsupported modules: no supported tag.

At runtime, the setting of the" unsupported" kernel command line
parameter and /proc/sys/kernel/unsupported determines whether
unsupported modules can be loaded or not, and whether or not loading an
unsupported module causes a warning in the system log:

  0 = only allow supported modules,
  1 = warn when loading unsupported modules,
  2 = don't warn.

Irrespective of this setting, loading an externally supported or unsupported
module both set a kernel taint flag. The taint flags are included in
Oopses. The taint status of the kernel can be inspected in
/proc/sys/kernel/tainted: Bits 0 to 4 have the following meanings:

  bit 0 = a module with a GPL-incompatible license was loaded (tainted & 1),
  bit 1 = module load was enforced (tainted & 2),
  bit 2 = an SMP-unsafe module was loaded (tainted & 4),
  bit 3 = (reserved),
  bit 4 = an unsupported module was loaded (tainted & 16),
  bit 5 = a module with third-party support was loaded (tainted & 32).

The corresponding codes for the taint flags in Oopses are (x = unknown):

  - "Pxxx" if bit 0 set or else
    "Gxxx" if bit 0 unset,
  
  - "xFxx" if bit 1 set or else
    "x xx" if bit 1 unset,
  
  - "xxSx" if set or else
    "xx x" if bit 2 unset,
  
  - "xxxU" if bit 4 set or else
    "xxxX" if bit 5 set or else
    "xxx ".

By default, external modules will not have the supported flag (that is,
they wil be marked as unsupported). For building externally supported
modules, please get in touch with Kurt Garloff <garloff@suse.de>.


PATCH SELECTION MECHANISM

The SUSE kernels consist of the vanilla kernel sources on top of which a
number of patches is applied. Almost all of these patches are applied on
all architectures; a few patches are only used on a subset of
architectures. The file series.conf determines which patches are applied
on which architectures. A script named "guards" converts series.conf
into a plain list of patch files to be applied. Guards decides which
patches to include and exclude based on a list of symbols. The symbols
used by default are computed by the helper script "arch-symbols". From
the kernel-source.src.rpm package, a fully patched kernel source tree
can be generated from vanilla sources + patches like this:

    # Install the package:

      $ rpm -i kernel-source.src.rpm

    # Unpack the patches and the kernel sources:
    
      $ cd /usr/src/packages/SOURCES
      $ for f in patches.*.tar.bz2; do		\
	  tar xfj $f || break;			\
	done
      $ tar xfj linux-2.6.5.tar.bz2

    # Apply the patches

      $ for p in $(./guards $(./arch-symbols) < series.conf); do
	  patch -d linux-2.6.5 -p1 < $p || break
	done

The configuration script config.conf which is similar to series.conf is
used for configuration file selection.  See the section WHERE TO FIND
CONFIGURATION FILES.

The file format of series.conf and config.conf should be obvious from
the comments in series.conf, and from the guards(1) manual page. (The
guards(1) manual page can be generated by running pod2man on the guards
script.)


WHERE TO FIND CONFIGURATION FILES

Kernel configuration files are stored in the kernel CVS repository. When
packing up the repository, they end up in config.tar.bz.  When
kernel-source.$ARCH.rpm is built, the config files are copied from
config/$ARCH/$FLAVOR to arch/$ARCH/defconfig.$FLAVOR in the kernel
source tree (for eaxmple, arch/i386/defconfig.default).

The kernel-$FLAVOR packages are based on arch/$ARCH/defconfig.$FLAVOR
(kernel-default is based on arch/$ARCH/defconfig.default, for example).
The kernel-$FLAVOR packages install their configuration files as
/boot/config-$VER_STR (for example, boot/config-2.6.5-99-default).

In addition, the running kernel exposes a gzip compressed version of its
configuration file as /proc/config.gz. The kernel sources can be
configured based on /proc/config.gz with ``make cleneconfig''.


HOW TO CONFIGURE THE KERNEL SOURCES

Before a binary kernel is built or an additional loadable module
for an existing kernel is created the kernel must be configured.

In order for a loadable module to work with an existing kernel, it must
be created with a configuration that is identical (or at least very
close) to the kernel's configuration. Each configuration is contained in
a single file.  The kernel-source package contains configurations for
all standard SUSE kernel variants, so for building only external kernel
modules it is not necessary to configure the kernel sources.

Configuring the kernel sources for a specific configuration is
straightfoward:

  - Locate the configuration file you want to use. (See WHERE TO FIND
    CONFIGURATION FILES above).

  - Copy the configuration to the file .config in the kernel source
    tree. The kernel-source package installs its source tree in
    /usr/src/linux.

  - Run the following commands in sequence to apply the configuration,
    generate version information files, etc.:

	make clean
	make oldconfig
	make dep

    Alternatively to ``make oldconfig'', you can also use ``make
    menuconfig'' for a text menu oriented user interface. If the kernel
    sources do not match the configuration file exactly, ``make
    oldconfig'' will prompt for settings that are undefined.

    For configuring the kernel to match the running kernel, there is a
    shortcut ``make cloneconfig'' that expands the file /proc/config.gz
    into .config, and then runs ``make oldconfig''.


MODULE LOAD PATHS

Modules that belong to a specific kernel release are installed in
/lib/modules/2.6.5-99-smp and similar. Note that this path contains the
kernel package release number.  This would be a problem for external
kernel modules; with each minor kernel update the module path would
change, and the external modules would get lost. Therefore, a path that
spans multiple kernel releases was added (in or example,
/lib/modules/2.6.5-override-smp). The module utilities search for
modules in this path before the more specific path. Modules in the
*-override-* directory take precedence over modules in the *-$RELEASE-*
directory.

NOTE: Modules in the override path are not removed automatically. This
      means that broken or outdated modules in that path will fail to
      load, or may even cause the kernel to crash, even if the more
      specific module path contains a correct module. It is the
      administrator's responsibility to remove obsolete modules from the
      override path.


TRIGGER SCRIPTS

Trigger scripts are a mechanism for triggering actions on installation,
update or removal of k_* packages. This mechanism is currently used by
the nVIDIA kernel module, which is linked at kernel install time.

When a k_* package is installed, all executable files in
/lib/modules/scripts are invoked from the %pre, %preun, %post, and
%postun RPM scripts. These scripts are passed the following parameters:

  $1 = "--pre", "--post", "--preun", or "--postun", the calling RPM
       script.
  $2 = The kernel release name (for example, 2.4.21-99-smp).
  $3 = The number of instances of the k_* package that are currently
       installed.

The RPM scripts are called in the following order:

  - If a package is being installed or updated:

    (1) pre-install script of the package being installed.
        $3 == 1  -->  installation
	$3 == 2  -->  update

    (2) post-install script of the package being installed
        $3 == 1  -->  installation
	$3 == 2  -->  update

  - If a package is being updated or uninstalled:

    (3) pre-uninstall script of the package being removed
	$3 == 0  -->  uninstall
        $3 == 1  -->  update

    (4) post-uninstall script of the package being removed
	$3 == 0  -->  uninstall
        $3 == 1  -->  update


REFERENCES

General

  Documentation in the kernel source tree.

  Linux Documentation Project, http://www.tldp.org/

  Linux Weekly News, http://lwn.net

  Rusty's Remarkably Unreliable Guides (Kernel Hacking
    and Kernel Locking guides),
    http://www.netfilter.org/unreliable-guides/

  Kernel newbies, http://www.kernelnewbies.org/


Loadable Kernel Modules

  Peter Jay Salzman and Ori Pomerantz: Linux Kernel Module
    Programming Guide, Version 2.4, April 2003,
    http://www.tldp.org/guides.html
