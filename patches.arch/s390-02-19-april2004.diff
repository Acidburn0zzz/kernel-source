- Description: qeth: HiperSockets device naming problem
  Symptom:     Invalid hsi device names (e.g. hsi-1) may be assigned. After
               removing a hsi device it may happen that the next new hsi device
               gets a name that is already assigned to another hsi device,
               which will fail.
  Problem:     Internal hsi device name book keeping broken.
  Solution:    Use stack's device naming. Set device name of hsi device to
               "hsi%d" -> stack will assign next free number for hsi device.
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 11:00:07 -0000	1.77.2.11
+++ linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 11:27:02 -0000	1.77.2.12
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.11 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.12 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.11 $	 $Date: 2004/05/14 11:00:07 $
+ *    $Revision: 1.77.2.12 $	 $Date: 2004/05/14 11:27:02 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.11 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.12 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -104,8 +104,6 @@
 static void qeth_send_control_data_cb(struct qeth_channel *,
 				      struct qeth_cmd_buffer *); 
 
-static atomic_t qeth_hsi_count;
-
 /**
  * here we go with function implementation
  */
@@ -481,8 +479,6 @@
 		card->use_hard_stop = 1;
 		qeth_set_offline(cgdev);
 	}
-	if (card->info.type == QETH_CARD_TYPE_IQD)
-		atomic_dec(&qeth_hsi_count);
 	/* remove form our internal list */
 	write_lock_irqsave(&qeth_card_list.rwlock, flags);
 	list_del(&card->list);
@@ -3146,20 +3142,6 @@
 	return rc;	
 }
 
-static void
-qeth_set_device_name(struct qeth_card *card)
-{
-	char buf[IF_NAME_LEN];
-
-	memset(buf, 0, IF_NAME_LEN);
-	if (card->info.type == QETH_CARD_TYPE_IQD) {
-		sprintf(buf,"hsi%d", atomic_read(&qeth_hsi_count));
-		atomic_inc(&qeth_hsi_count);
-		memcpy(card->dev->name,buf,IF_NAME_LEN);
-	}
-
-}
-
 static struct net_device *
 qeth_get_netdevice(enum qeth_card_types type, enum qeth_link_types linktype) 
 {
@@ -3179,6 +3161,8 @@
 		}
 		break;
 	case QETH_CARD_TYPE_IQD:
+		dev = alloc_netdev(0, "hsi%d", ether_setup);
+		break;
 	default:
 		dev = alloc_etherdev(0);
 	}
@@ -4211,7 +4195,6 @@
 		return -ENODEV;
 
 	switch (cmd){
-	case SIOCDEVPRIVATE:
 	case SIOC_QETH_ARP_SET_NO_ENTRIES:
 		if (!capable(CAP_NET_ADMIN)){
 			rc = -EPERM;
@@ -4219,7 +4202,6 @@
 		}
 		rc = qeth_arp_set_no_entries(card, rq->ifr_ifru.ifru_ivalue);
 		break;
-	case SIOCDEVPRIVATE+1:
 	case SIOC_QETH_ARP_QUERY_INFO:
 		if (!capable(CAP_NET_ADMIN)){
 			rc = -EPERM;
@@ -4227,7 +4209,6 @@
 		}
 		rc = qeth_arp_query(card, rq->ifr_ifru.ifru_data);
 		break;
-	case SIOCDEVPRIVATE+2:
 	case SIOC_QETH_ARP_ADD_ENTRY:
 		if (!capable(CAP_NET_ADMIN)){
 			rc = -EPERM;
@@ -4239,7 +4220,6 @@
 		else
 			rc = qeth_arp_add_entry(card, &arp_entry);
 		break;
-	case SIOCDEVPRIVATE+3:
 	case SIOC_QETH_ARP_REMOVE_ENTRY:
 		if (!capable(CAP_NET_ADMIN)){
 			rc = -EPERM;
@@ -4251,7 +4231,6 @@
 		else
 			rc = qeth_arp_remove_entry(card, &arp_entry);
 		break;
-	case SIOCDEVPRIVATE+4:
 	case SIOC_QETH_ARP_FLUSH_CACHE:
 		if (!capable(CAP_NET_ADMIN)){
 			rc = -EPERM;
@@ -4259,10 +4238,8 @@
 		}
 		rc = qeth_arp_flush_cache(card);
 		break;
-	case SIOCDEVPRIVATE+5:
 	case SIOC_QETH_ADP_SET_SNMP_CONTROL:
 		break;
-	case SIOCDEVPRIVATE+6:
 	case SIOC_QETH_GET_CARD_TYPE:
 		break;
 	case SIOCGMIIPHY:
@@ -4295,6 +4272,8 @@
 	default:
 		rc = -EOPNOTSUPP;
 	}
+	if (rc)
+		QETH_DBF_TEXT_(trace, 2, "ioce%d", rc);
 	return rc;
 }
 
@@ -5012,7 +4991,6 @@
 			QETH_DBF_TEXT_(setup, 2, "6err%d", rc);
 			goto out;
 		}
-		qeth_set_device_name(card);
 		card->dev->priv = card;
 		card->dev->type = qeth_get_arphdr_type(card->info.type,
 						       card->info.link_type);
@@ -6917,7 +6895,6 @@
 	INIT_LIST_HEAD(&qeth_card_list.list);
 	rwlock_init(&qeth_card_list.rwlock);
 
-	atomic_set(&qeth_hsi_count, 0);
 	if (qeth_register_dbf_views())
 		goto out_err;
 	if (qeth_sysfs_register())

