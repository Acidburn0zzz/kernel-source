From: Keith Mannthey
Subject: Reserve SRAT hotadd memory on x86-64 
Acked-by: ak@suse.de
Suse-bugzilla: 142035

Index: linux-2.6.15/arch/x86_64/mm/numa.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/mm/numa.c
+++ linux-2.6.15/arch/x86_64/mm/numa.c
@@ -143,6 +143,9 @@ void __init setup_node_bootmem(int nodei
 
 	reserve_bootmem_node(NODE_DATA(nodeid), nodedata_phys, pgdat_size); 
 	reserve_bootmem_node(NODE_DATA(nodeid), bootmap_start, bootmap_pages<<PAGE_SHIFT);
+#ifdef CONFIG_ACPI_NUMA
+	srat_reserve_add_area(nodeid);
+#endif
 	node_set_online(nodeid);
 } 
 
Index: linux-2.6.15/arch/x86_64/mm/srat.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/mm/srat.c
+++ linux-2.6.15/arch/x86_64/mm/srat.c
@@ -15,6 +15,7 @@
 #include <linux/bitmap.h>
 #include <linux/module.h>
 #include <linux/topology.h>
+#include <linux/bootmem.h>
 #include <asm/proto.h>
 #include <asm/numa.h>
 #include <asm/e820.h>
@@ -24,6 +25,8 @@ static struct acpi_table_slit *acpi_slit
 static nodemask_t nodes_parsed __initdata;
 static nodemask_t nodes_found __initdata;
 static struct node nodes[MAX_NUMNODES] __initdata;
+struct node nodes_add[MAX_NUMNODES] __initdata;
+static int found_add_area __initdata;
 static u8 pxm2node[256] = { [0 ... 255] = 0xff };
 
 /* Too small nodes confuse the VM badly. Usually they result
@@ -181,10 +184,6 @@ acpi_numa_memory_affinity_init(struct ac
 		bad_srat();
 		return;
 	}
-	/* It is fine to add this area to the nodes data it will be used later*/
-	if (ma->flags.hot_pluggable == 1)
-		printk(KERN_INFO "SRAT: hot plug zone found %lx - %lx \n",
-				start, end);
 	i = conflicting_nodes(start, end);
 	if (i == node) {
 		printk(KERN_WARNING
@@ -208,6 +207,28 @@ acpi_numa_memory_affinity_init(struct ac
 		if (nd->end < end)
 			nd->end = end;
 	}
+ 
+ 	/* 
+ 	 * It is fine to add this area to the nodes data it will be used later
+ 	 * This code supports one contigious hot add area per node.
+ 	 */
+ 	if (ma->flags.hot_pluggable == 1) {
+ 		found_add_area = 1;
+ 		if (nodes_add[node].start == nodes_add[node].end) {
+ 			nodes_add[node].start = start;
+ 			nodes_add[node].end = end;	
+ 		} else {
+ 			if (nodes_add[node].start == end)
+ 				nodes_add[node].start = start;
+ 			if (nodes_add[node].end == start)
+ 				nodes_add[node].end = end;
+ 		}
+ 		if ((nodes_add[node].end >> PAGE_SHIFT) > end_pfn)
+ 			end_pfn = nodes_add[node].end >> PAGE_SHIFT;
+ 		printk(KERN_INFO "SRAT: hot plug zone found %Lx - %Lx\n",
+ 				nodes_add[node].start, nodes_add[node].end);
+ 	}
+
 	printk(KERN_INFO "SRAT: Node %u PXM %u %Lx-%Lx\n", node, pxm,
 	       nd->start, nd->end);
 }
@@ -257,7 +278,8 @@ int __init acpi_scan_nodes(unsigned long
 
 	/* First clean up the node list */
 	for (i = 0; i < MAX_NUMNODES; i++) { 
-		cutoff_node(i, start, end);
+ 		if (!found_add_area)
+ 			cutoff_node(i, start, end);
 		if ((nodes[i].end - nodes[i].start) < NODE_MIN_SIZE) 
 			unparse_node(i);
 	}
@@ -302,6 +324,18 @@ static int node_to_pxm(int n)
        return 0;
 }
 
+void __init srat_reserve_add_area(int nodeid)
+{
+	if (found_add_area && nodes_add[nodeid].end) {
+		printk ("Reserving hot-add memory space node %d pages %08Lx to" 
+			" %08Lx\n", nodeid, nodes_add[nodeid].start, 
+			nodes_add[nodeid].end);
+
+		reserve_bootmem_node(NODE_DATA(nodeid), nodes_add[nodeid].start,
+			       nodes_add[nodeid].end - nodes_add[nodeid].start);
+	}
+}
+
 int __node_distance(int a, int b)
 {
 	int index;
@@ -311,5 +345,4 @@ int __node_distance(int a, int b)
 	index = acpi_slit->localities * node_to_pxm(a);
 	return acpi_slit->entry[index + node_to_pxm(b)];
 }
-
 EXPORT_SYMBOL(__node_distance);
Index: linux-2.6.15/include/asm-x86_64/numa.h
===================================================================
--- linux-2.6.15.orig/include/asm-x86_64/numa.h
+++ linux-2.6.15/include/asm-x86_64/numa.h
@@ -18,6 +18,7 @@ extern void numa_init_array(void);
 extern int numa_off;
 
 extern void numa_set_node(int cpu, int node);
+extern void srat_reserve_add_area(int nodeid);
 
 extern unsigned char apicid_to_node[256];
 #ifdef CONFIG_NUMA
