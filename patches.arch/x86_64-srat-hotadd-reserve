From: Keith Mannthey
Subject: Reserve SRAT hotadd memory on x86-64 
Acked-by: ak@suse.de
References: 142035 148522 149117

Implement memory hotadd without sparsemem. The memory in the SRAT
hotadd area is just preserved instead and can be activated later.
Originally from Keith Mannthey, with several hacks and changes by AK.


Index: linux-2.6.15/arch/x86_64/mm/numa.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/mm/numa.c
+++ linux-2.6.15/arch/x86_64/mm/numa.c
@@ -143,6 +143,9 @@ void __init setup_node_bootmem(int nodei
 
 	reserve_bootmem_node(NODE_DATA(nodeid), nodedata_phys, pgdat_size); 
 	reserve_bootmem_node(NODE_DATA(nodeid), bootmap_start, bootmap_pages<<PAGE_SHIFT);
+#ifdef CONFIG_ACPI_NUMA
+	srat_reserve_add_area(nodeid);
+#endif
 	node_set_online(nodeid);
 } 
 
@@ -326,6 +329,8 @@ __init int numa_setup(char *opt) 
 #ifdef CONFIG_ACPI_NUMA
  	if (!strncmp(opt,"noacpi",6))
  		acpi_numa = -1;
+	if (!strncmp(opt,"ignorehotadd",13))
+		ignore_hotadd = 1;
 #endif
 	return 1;
 } 
Index: linux-2.6.15/arch/x86_64/mm/srat.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/mm/srat.c
+++ linux-2.6.15/arch/x86_64/mm/srat.c
@@ -15,6 +15,8 @@
 #include <linux/bitmap.h>
 #include <linux/module.h>
 #include <linux/topology.h>
+#include <linux/bootmem.h>
+#include <linux/mm.h>
 #include <asm/proto.h>
 #include <asm/numa.h>
 #include <asm/e820.h>
@@ -24,6 +26,9 @@ static struct acpi_table_slit *acpi_slit
 static nodemask_t nodes_parsed __initdata;
 static nodemask_t nodes_found __initdata;
 static struct node nodes[MAX_NUMNODES] __initdata;
+struct node nodes_add[MAX_NUMNODES] __initdata;
+static int found_add_area __initdata;
+int ignore_hotadd __initdata;
 static u8 pxm2node[256] = { [0 ... 255] = 0xff };
 
 /* Too small nodes confuse the VM badly. Usually they result
@@ -90,6 +95,8 @@ static __init void bad_srat(void)
 	acpi_numa = -1;
 	for (i = 0; i < MAX_LOCAL_APIC; i++)
 		apicid_to_node[i] = NUMA_NO_NODE;
+	for (i = 0; i < MAX_NUMNODES; i++)
+		nodes_add[i].start = nodes[i].end = 0;
 }
 
 static __init inline int srat_disabled(void)
@@ -181,10 +188,6 @@ acpi_numa_memory_affinity_init(struct ac
 		bad_srat();
 		return;
 	}
-	/* It is fine to add this area to the nodes data it will be used later*/
-	if (ma->flags.hot_pluggable == 1)
-		printk(KERN_INFO "SRAT: hot plug zone found %lx - %lx \n",
-				start, end);
 	i = conflicting_nodes(start, end);
 	if (i == node) {
 		printk(KERN_WARNING
@@ -208,6 +211,42 @@ acpi_numa_memory_affinity_init(struct ac
 		if (nd->end < end)
 			nd->end = end;
 	}
+
+ 	/*
+ 	 * It is fine to add this area to the nodes data it will be used later
+ 	 * This code supports one contigious hot add area per node.
+ 	 * The signed cast is intentional to catch underflows.
+ 	 */
+ 	if (ma->flags.hot_pluggable == 1 && !ignore_hotadd) {
+		unsigned long s_pfn = start >> PAGE_SHIFT;
+		unsigned long e_pfn = end >> PAGE_SHIFT;
+
+		/* Sorry guys - if you want working memory hotplug write correct SRATs */
+		if ((signed long)(end - start) < NODE_MIN_SIZE ||
+		    e820_hole_size(s_pfn, e_pfn) != e_pfn - s_pfn) { 
+			printk(KERN_ERR 
+	"SRAT: Hotplug area %lx-%lx too small or overlaps with real memory\n",
+				start, end);
+			bad_srat();
+			return;
+		}
+
+ 		found_add_area = 1;
+ 		if (nodes_add[node].start == nodes_add[node].end) {
+ 			nodes_add[node].start = start;
+ 			nodes_add[node].end = end;
+ 		} else {
+ 			if (nodes_add[node].start == end)
+ 				nodes_add[node].start = start;
+ 			if (nodes_add[node].end == start)
+ 				nodes_add[node].end = end;
+ 		}
+ 		if ((nodes_add[node].end >> PAGE_SHIFT) > end_pfn)
+ 			end_pfn = nodes_add[node].end >> PAGE_SHIFT;
+ 		printk(KERN_INFO "SRAT: hot plug zone found %Lx - %Lx\n",
+ 				nodes_add[node].start, nodes_add[node].end);
+ 	}
+
 	printk(KERN_INFO "SRAT: Node %u PXM %u %Lx-%Lx\n", node, pxm,
 	       nd->start, nd->end);
 }
@@ -225,6 +264,9 @@ static int nodes_cover_memory(void)
 		unsigned long e = nodes[i].end >> PAGE_SHIFT;
 		pxmram += e - s;
 		pxmram -= e820_hole_size(s, e);
+		pxmram -= nodes_add[i].end - nodes_add[i].start;
+		if ((long)pxmram < 0)
+			pxmram = 0;
 	}
 
 	e820ram = end_pfn - e820_hole_size(0, end_pfn);
@@ -258,7 +300,8 @@ int __init acpi_scan_nodes(unsigned long
 
 	/* First clean up the node list */
 	for (i = 0; i < MAX_NUMNODES; i++) {
-		cutoff_node(i, start, end);
+ 		if (!found_add_area)
+ 			cutoff_node(i, start, end);
 		if ((nodes[i].end - nodes[i].start) < NODE_MIN_SIZE)
 			unparse_node(i);
 	}
@@ -303,6 +346,22 @@ static int node_to_pxm(int n)
        return 0;
 }
 
+void __init srat_reserve_add_area(int nodeid)
+{
+	if (found_add_area && nodes_add[nodeid].end) {
+		printk(KERN_INFO 
+	"SRAT: Reserving hot-add memory space for node %d at %Lx-%Lx\n", 
+			nodeid, nodes_add[nodeid].start, nodes_add[nodeid].end);
+		printk(KERN_INFO 
+	"SRAT: This will cost you %Lu MB of pre-allocated memory.\n", 
+		(((nodes_add[nodeid].end - 
+			nodes_add[nodeid].start)/PAGE_SIZE)*sizeof(struct page)) >> 20);
+
+		reserve_bootmem_node(NODE_DATA(nodeid), nodes_add[nodeid].start,
+			       nodes_add[nodeid].end - nodes_add[nodeid].start);
+	}
+}
+
 int __node_distance(int a, int b)
 {
 	int index;
Index: linux-2.6.15/include/asm-x86_64/numa.h
===================================================================
--- linux-2.6.15.orig/include/asm-x86_64/numa.h
+++ linux-2.6.15/include/asm-x86_64/numa.h
@@ -18,6 +18,8 @@ extern void numa_init_array(void);
 extern int numa_off;
 
 extern void numa_set_node(int cpu, int node);
+extern void srat_reserve_add_area(int nodeid);
+extern int ignore_hotadd;
 
 extern unsigned char apicid_to_node[256];
 #ifdef CONFIG_NUMA
Index: linux-2.6.15/Documentation/x86_64/boot-options.txt
===================================================================
--- linux-2.6.15.orig/Documentation/x86_64/boot-options.txt
+++ linux-2.6.15/Documentation/x86_64/boot-options.txt
@@ -151,6 +151,9 @@ NUMA
 
   numa=fake=X   Fake X nodes and ignore NUMA setup of the actual machine.
 
+  numa=ignorehotadd Ignore hot add memory in SRAT. This will disable memory
+                hotplug      [SUSE extension for now]
+
 ACPI
 
   acpi=off	Don't enable ACPI
Index: linux-2.6.15/arch/x86_64/mm/init.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/mm/init.c
+++ linux-2.6.15/arch/x86_64/mm/init.c
@@ -479,7 +479,6 @@ void __init clear_kernel_mapping(unsigne
 
 /*
  * Memory hotplug specific functions
- * These are only for non-NUMA machines right now.
  */
 #ifdef CONFIG_ACPI_HOTPLUG_MEMORY
 
