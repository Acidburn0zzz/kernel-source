diff -u linux-2.6.5-i386/arch/i386/kernel/cpu/common.c-o linux-2.6.5-i386/arch/i386/kernel/cpu/common.c
--- linux-2.6.5-i386/arch/i386/kernel/cpu/common.c-o	2004-03-21 21:12:03.000000000 +0100
+++ linux-2.6.5-i386/arch/i386/kernel/cpu/common.c	2004-04-21 17:05:06.000000000 +0200
@@ -137,8 +137,7 @@
 }
 
 
-
-void __init get_cpu_vendor(struct cpuinfo_x86 *c)
+void __init get_cpu_vendor(struct cpuinfo_x86 *c, int early)
 {
 	char *v = c->x86_vendor_id;
 	int i;
@@ -149,7 +148,8 @@
 			    (cpu_devs[i]->c_ident[1] && 
 			     !strcmp(v,cpu_devs[i]->c_ident[1]))) {
 				c->x86_vendor = i;
-				this_cpu = cpu_devs[i];
+				if (!early) 
+					this_cpu = cpu_devs[i];
 				break;
 			}
 		}
@@ -193,6 +193,44 @@
 	return flag_is_changeable_p(X86_EFLAGS_ID);
 }
 
+/* Do minimum CPU detection early. 
+   Fields really needed: vendor, cpuid_level, family, model, mask, cache alignment.
+   The others are not touched to avoid unwanted side effects. */
+void __init early_cpu_detect(void) 
+{ 
+	struct cpuinfo_x86 *c = &boot_cpu_data;
+
+	if (!have_cpuid_p())
+		return;
+
+	/* Get vendor name */
+	cpuid(0x00000000, &c->cpuid_level,
+	      (int *)&c->x86_vendor_id[0],
+	      (int *)&c->x86_vendor_id[8],
+	      (int *)&c->x86_vendor_id[4]);
+	
+	get_cpu_vendor(c, 1);
+
+	c->x86 = 4;
+	c->x86_cache_alignment = 32;
+
+	if (c->cpuid_level >= 0x00000001) {
+		u32 junk, tfms, cap0, misc;
+		cpuid(0x00000001, &tfms, &misc, &junk, &cap0);
+		c->x86 = (tfms >> 8) & 15;
+		c->x86_model = (tfms >> 4) & 15;
+		if (c->x86 == 0xf) {
+			c->x86 += (tfms >> 20) & 0xff;
+			c->x86_model += ((tfms >> 16) & 0xF) << 4;
+		} 
+		c->x86_mask = tfms & 15;
+		if (cap0 & (1<<19)) 
+			c->x86_cache_alignment = ((misc >> 8) & 0xff) * 8;
+	}
+
+	early_intel_workaround(c); 
+} 
+
 void __init generic_identify(struct cpuinfo_x86 * c)
 {
 	u32 tfms, xlvl;
@@ -205,7 +243,7 @@
 		      (int *)&c->x86_vendor_id[8],
 		      (int *)&c->x86_vendor_id[4]);
 		
-		get_cpu_vendor(c);
+		get_cpu_vendor(c, 0);
 		/* Initialize the standard set of capabilities */
 		/* Note that the vendor-specific code below might override */
 	
@@ -383,7 +421,6 @@
  
 void __init dodgy_tsc(void)
 {
-	get_cpu_vendor(&boot_cpu_data);
 	if (( boot_cpu_data.x86_vendor == X86_VENDOR_CYRIX ) ||
 	    ( boot_cpu_data.x86_vendor == X86_VENDOR_NSC   ))
 		cpu_devs[X86_VENDOR_CYRIX]->c_init(&boot_cpu_data);
@@ -431,9 +468,11 @@
 extern int rise_init_cpu(void);
 extern int nexgen_init_cpu(void);
 extern int umc_init_cpu(void);
+void early_cpu_detect(void);
 
 void __init early_cpu_init(void)
 {
+	early_cpu_detect();
 	intel_cpu_init();
 	cyrix_init_cpu();
 	nsc_init_cpu();
diff -u linux-2.6.5-i386/arch/i386/kernel/cpu/cpu.h-o linux-2.6.5-i386/arch/i386/kernel/cpu/cpu.h
--- linux-2.6.5-i386/arch/i386/kernel/cpu/cpu.h-o	2004-03-21 21:12:03.000000000 +0100
+++ linux-2.6.5-i386/arch/i386/kernel/cpu/cpu.h	2004-04-21 14:53:41.000000000 +0200
@@ -26,3 +26,6 @@
 
 extern void generic_identify(struct cpuinfo_x86 * c);
 extern int have_cpuid_p(void);
+
+extern void early_intel_workaround(struct cpuinfo_x86 *c);
+
diff -u linux-2.6.5-i386/arch/i386/kernel/cpu/intel.c-o linux-2.6.5-i386/arch/i386/kernel/cpu/intel.c
--- linux-2.6.5-i386/arch/i386/kernel/cpu/intel.c-o	1970-01-01 01:12:51.000000000 +0100
+++ linux-2.6.5-i386/arch/i386/kernel/cpu/intel.c	2004-04-21 17:06:00.000000000 +0200
@@ -28,6 +28,15 @@
 struct movsl_mask movsl_mask;
 #endif
 
+void __init early_intel_workaround(struct cpuinfo_x86 *c)
+{
+	if (c->x86_vendor != X86_VENDOR_INTEL)
+		return; 
+	/* Netburst reports 64 bytes clflush size, but does IO in 128 bytes */
+	if (c->x86 == 15 && c->x86_cache_alignment == 64) 
+		c->x86_cache_alignment = 128;
+}
+
 /*
  *	Early probe support logic for ppro memory erratum #50
  *
--- linux-2.6.5/include/asm-i386/processor.h	2004-04-23 12:54:45.000000000 +0200
+++ linux-2.6.5.ix86/include/asm-i386/processor.h	2004-04-23 13:29:33.000000000 +0200
@@ -62,6 +62,7 @@
 	int	fdiv_bug;
 	int	f00f_bug;
 	int	coma_bug;
+	int	x86_cache_alignment;
 	unsigned long loops_per_jiffy;
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
 
