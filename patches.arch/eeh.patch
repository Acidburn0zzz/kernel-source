ChangeSet
  1.1524 04/03/26 10:36:38 nfont@threadlp13.austin.ibm.com +4 -0
  Create the ability to hotplug disable ethernet devices that receive
  an EEH event rather than panic the system.  This is done through
  the registration of a "disable slot" routine (rpaphp_disable_slot)
  with EEH that can be called to (hotplug) disable a slot that
  receives an EEH event.

  drivers/pci/hotplug/rpaphp_pci.c
    1.6 04/03/26 10:32:44 nfont@threadlp13.austin.ibm.com +16 -0
    Add rpaphp_find_hotplug_slot().

  drivers/pci/hotplug/rpaphp_core.c
    1.10 04/03/26 10:32:44 nfont@threadlp13.austin.ibm.com +14 -0
    Add rpaphp_disable_slot routine and code to register this function
    with EEH.

  drivers/pci/hotplug/rpaphp.h
    1.8 04/03/26 10:32:44 nfont@threadlp13.austin.ibm.com +1 -0
    Add declaration for rpaphp_find_hotplug_slot()

  arch/ppc64/kernel/eeh.c
    1.25 04/03/26 10:32:44 nfont@threadlp13.austin.ibm.com +127 -51
    Enable ethernet devices to be hotplug dsiabled on EEH events
    instead of having the system panic.

diff -Nru a/arch/ppc64/kernel/eeh.c b/arch/ppc64/kernel/eeh.c
--- a/arch/ppc64/kernel/eeh.c	Fri Mar 26 21:16:52 2004
+++ b/arch/ppc64/kernel/eeh.c	Fri Mar 26 21:16:52 2004
@@ -50,6 +50,24 @@
 static char *eeh_opts;
 static int eeh_opts_last;
 
+/* Buffer for reporting slot-error-detail rtas calls */
+static unsigned char slot_errbuf[RTAS_ERROR_LOG_MAX];
+
+/* Workqueue data for EEH event device removal */
+struct eeh_event {
+	struct list_head	list;
+	struct pci_dev		*dev;
+	struct device_node	*dn;
+	unsigned long		reset_state;
+};
+
+static spinlock_t eeh_eventlist_lock = SPIN_LOCK_UNLOCKED;
+LIST_HEAD(eeh_eventlist);
+static void eeh_event_handler(void *);
+DECLARE_WORK(eeh_event_wq, eeh_event_handler, NULL);
+
+int (*eeh_disable_slot)(struct pci_dev *) = NULL;
+
 /* System monitoring statistics */
 static DEFINE_PER_CPU(unsigned long, total_mmio_ffs);
 static DEFINE_PER_CPU(unsigned long, false_positives);
@@ -347,6 +365,88 @@
 }
 
 /**
+ * eeh_panic - call panic() for an eeh event that cannot be handled
+ * @dev pci device that had an eeh event
+ * @reset_state current reset state of the device slot
+ */
+static void eeh_panic(struct pci_dev *dev, unsigned long reset_state)
+{
+	/*
+	 * XXX We should create a seperate sysctl for this.
+	 *
+	 * Since the panic_on_oops sysctl is used to halt the system
+	 * in light of potential corruption, we can use it here.
+	 */
+	if (panic_on_oops)
+		panic("EEH: MMIO failure (%ld) on device:%s %s\n", reset_state,
+		      pci_name(dev), pci_pretty_name(dev));
+	else {
+		__get_cpu_var(ignored_failures)++;
+		printk(KERN_INFO "EEH: MMIO failure (%ld) on device:%s %s\n",
+		       reset_state, pci_name(dev), pci_pretty_name(dev));
+	}
+}
+
+/**
+ * eeh_register_disable_func - allows the rpaphp module to let us know
+ *				they're there.
+ * @func - pointer to rpaphp disable slot routine
+ */
+void eeh_register_disable_func(int (*func)(struct pci_dev *))
+{
+	eeh_disable_slot = func;
+}
+
+/**
+ * eeh_event_handler - handle any eeh events to see if we can disable
+ *		       the device
+ * @dummy - unused
+ */
+static void eeh_event_handler(void *dummy)
+{
+	struct list_head	*tmp, *n;
+	struct eeh_event	*event;
+	unsigned long		log_event;
+	int			rc;
+
+	spin_lock(&eeh_eventlist_lock);
+
+	memset(slot_errbuf, 0, RTAS_ERROR_LOG_MAX);
+
+	list_for_each_safe(tmp, n, &eeh_eventlist) {
+		event = list_entry(tmp, struct eeh_event, list);
+		rc = 1;
+
+		log_event = rtas_call(rtas_token("ibm,slot-error-detail"), 8, 1, NULL,
+				      event->dn->eeh_config_addr,
+				      BUID_HI(event->dn->phb->buid),
+				      BUID_LO(event->dn->phb->buid), NULL, 0,
+				      virt_to_phys(slot_errbuf), RTAS_ERROR_LOG_MAX,
+				      2 /* Permanent Error */);
+		if (log_event)
+			log_error(slot_errbuf, ERR_TYPE_RTAS_LOG, 0);
+
+		if (strcmp(event->dn->name, "ethernet") == 0) {
+			if (eeh_disable_slot != NULL)
+				rc = eeh_disable_slot(event->dev);
+		}
+
+		if (rc != 0)
+			eeh_panic(event->dev, event->reset_state);
+		else
+			printk(KERN_INFO "EEH: MMIO failure (%ld) has caused device "
+				"%s %s to be removed\n", event->reset_state,
+				pci_name(event->dev), pci_pretty_name(event->dev));
+
+		pci_dev_put(event->dev);
+		list_del(&event->list);
+		kfree(event);
+	}
+
+	spin_unlock(&eeh_eventlist_lock);
+}
+
+/**
  * eeh_check_failure - check if all 1's data is due to EEH slot freeze
  * @token i/o token, should be address in the form 0xA....
  * @val value, should be all 1's (XXX why do we need this arg??)
@@ -366,10 +466,6 @@
 	struct pci_dev *dev;
 	struct device_node *dn;
 	unsigned long ret, rets[2];
-	static spinlock_t lock = SPIN_LOCK_UNLOCKED;
-	/* dont want this on the stack */
-	static unsigned char slot_err_buf[RTAS_ERROR_LOG_MAX];
-	unsigned long flags;
 
 	__get_cpu_var(total_mmio_ffs)++;
 
@@ -383,28 +479,20 @@
 		return val;
 
 	dn = pci_device_to_OF_node(dev);
-	if (!dn) {
-		pci_dev_put(dev);
-		return val;
-	}
+	if (!dn) 
+		goto ok_return;
 
 	/* Access to IO BARs might get this far and still not want checking. */
 	if (!(dn->eeh_mode & EEH_MODE_SUPPORTED) ||
-	    dn->eeh_mode & EEH_MODE_NOCHECK) {
-		pci_dev_put(dev);
-		return val;
-	}
+	    dn->eeh_mode & EEH_MODE_NOCHECK) 
+		goto ok_return;
 
         /* Make sure we aren't ISA */
-        if (!strcmp(dn->type, "isa")) {
-                pci_dev_put(dev);
-                return val;
-        }
+        if (!strcmp(dn->type, "isa")) 
+                goto ok_return;
 
-	if (!dn->eeh_config_addr) {
-		pci_dev_put(dev);
-		return val;
-	}
+	if (!dn->eeh_config_addr) 
+		goto ok_return;
 
 	/*
 	 * Now test for an EEH failure.  This is VERY expensive.
@@ -418,43 +506,31 @@
 			BUID_LO(dn->phb->buid));
 
 	if (ret == 0 && rets[1] == 1 && rets[0] >= 2) {
-		unsigned long slot_err_ret;
+		struct eeh_event 	*event;
 
-		spin_lock_irqsave(&lock, flags);
-		memset(slot_err_buf, 0, RTAS_ERROR_LOG_MAX);
-		slot_err_ret = rtas_call(rtas_token("ibm,slot-error-detail"),
-					 8, 1, NULL, dn->eeh_config_addr,
-					 BUID_HI(dn->phb->buid),
-					 BUID_LO(dn->phb->buid), NULL, 0,
-					 __pa(slot_err_buf),
-					 RTAS_ERROR_LOG_MAX,
-					 2 /* Permanent Error */);
-
-		if (slot_err_ret == 0)
-			log_error(slot_err_buf, ERR_TYPE_RTAS_LOG,
-				  1 /* Fatal */);
-
-		spin_unlock_irqrestore(&lock, flags);
-
-		/*
-		 * XXX We should create a separate sysctl for this.
-		 *
-		 * Since the panic_on_oops sysctl is used to halt
-		 * the system in light of potential corruption, we
-		 * can use it here.
-		 */
-		if (panic_on_oops) {
-			panic("EEH: MMIO failure (%ld) on device:%s %s\n",
-			      rets[0], pci_name(dev), pci_pretty_name(dev));
-		} else {
-			__get_cpu_var(ignored_failures)++;
-			printk(KERN_INFO "EEH: MMIO failure (%ld) on device:%s %s\n",
-			       rets[0], pci_name(dev), pci_pretty_name(dev));
+		/* prevent repeated reports of this failure */
+		dn->eeh_mode |= EEH_MODE_NOCHECK;
+
+		event = kmalloc(sizeof(*event), GFP_ATOMIC);
+		if (event == NULL) {
+			eeh_panic(dev, rets[0]);
+			goto ok_return;
 		}
+
+		event->dev = dev;
+		event->dn = dn;
+		event->reset_state = rets[0];
+
+		spin_lock(&eeh_eventlist_lock);
+		list_add(&event->list, &eeh_eventlist);
+		spin_unlock(&eeh_eventlist_lock);
+
+		schedule_work(&eeh_event_wq);
 	} else {
 		__get_cpu_var(false_positives)++;
 	}
 
+ok_return:
 	pci_dev_put(dev);
 	return val;
 }
diff -Nru a/drivers/pci/hotplug/rpaphp.h b/drivers/pci/hotplug/rpaphp.h
--- a/drivers/pci/hotplug/rpaphp.h	Fri Mar 26 21:16:52 2004
+++ b/drivers/pci/hotplug/rpaphp.h	Fri Mar 26 21:16:52 2004
@@ -112,6 +112,7 @@
 extern int register_pci_slot(struct slot *slot);
 extern int rpaphp_unconfig_pci_adapter(struct slot *slot);
 extern int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value);
+extern struct hotplug_slot *rpaphp_find_hotplug_slot(struct pci_dev *dev);
 
 /* rpaphp_core.c */
 extern int rpaphp_add_slot(struct device_node *dn);
diff -Nru a/drivers/pci/hotplug/rpaphp_core.c b/drivers/pci/hotplug/rpaphp_core.c
--- a/drivers/pci/hotplug/rpaphp_core.c	Fri Mar 26 21:16:52 2004
+++ b/drivers/pci/hotplug/rpaphp_core.c	Fri Mar 26 21:16:52 2004
@@ -54,6 +54,8 @@
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
+void eeh_register_disable_func(int (*)(struct pci_dev *));
+
 module_param(debug, int, 0644);
 
 static int enable_slot(struct hotplug_slot *slot);
@@ -64,6 +66,7 @@
 static int get_adapter_status(struct hotplug_slot *slot, u8 * value);
 static int get_max_bus_speed(struct hotplug_slot *hotplug_slot, enum pci_bus_speed *value);
 static int get_cur_bus_speed(struct hotplug_slot *hotplug_slot, enum pci_bus_speed *value);
+static int rpaphp_disable_slot(struct pci_dev *dev);
 
 struct hotplug_slot_ops rpaphp_hotplug_slot_ops = {
 	.owner = THIS_MODULE,
@@ -398,12 +401,18 @@
 {
 	info(DRIVER_DESC " version: " DRIVER_VERSION "\n");
 
+	/* let EEH know they can use hotplug */
+	eeh_register_disable_func(&rpaphp_disable_slot);
+
 	/* read all the PRA info from the system */
 	return init_rpa();
 }
 
 static void __exit rpaphp_exit(void)
 {
+	/* let EEH know we are going away */
+	eeh_register_disable_func(NULL);
+
 	cleanup_slots();
 }
 
@@ -436,6 +445,11 @@
       exit:
 	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
 	return retval;
+}
+
+static int rpaphp_disable_slot(struct pci_dev *dev)
+{
+	return disable_slot(rpaphp_find_hotplug_slot(dev));
 }
 
 static int disable_slot(struct hotplug_slot *hotplug_slot)
diff -Nru a/drivers/pci/hotplug/rpaphp_pci.c b/drivers/pci/hotplug/rpaphp_pci.c
--- a/drivers/pci/hotplug/rpaphp_pci.c	Fri Mar 26 21:16:52 2004
+++ b/drivers/pci/hotplug/rpaphp_pci.c	Fri Mar 26 21:16:52 2004
@@ -398,3 +398,19 @@
 	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
 	return retval;
 }
+
+struct hotplug_slot *rpaphp_find_hotplug_slot(struct pci_dev *dev)
+{
+	struct list_head	*tmp, *n;
+	struct slot		*slot;
+
+	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
+		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+		if (slot->dev.pci_dev == dev)
+			return slot->hotplug_slot;
+	}
+
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(rpaphp_find_hotplug_slot);
.........................................................................
# vim: syntax=diff

