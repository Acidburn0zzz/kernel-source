diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/ia32_binfmt.c linux-2.5.73-amd64/arch/x86_64/ia32/ia32_binfmt.c
--- linux/arch/x86_64/ia32/ia32_binfmt.c	2003-05-27 03:00:21.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/ia32/ia32_binfmt.c	2003-06-26 11:32:32.000000000 +0200
@@ -30,10 +30,12 @@
 #define AT_SYSINFO 32
 #define AT_SYSINFO_EHDR		33
 
+#if 0 /* disabled for now because the code has still problems */
 #define ARCH_DLINFO do {  \
 	NEW_AUX_ENT(AT_SYSINFO, (u32)(u64)VSYSCALL32_VSYSCALL); \
 	NEW_AUX_ENT(AT_SYSINFO_EHDR, VSYSCALL32_BASE);    \
 } while(0)
+#endif
 
 struct file;
 struct elf_phdr; 
diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/ia32_ioctl.c linux-2.5.73-amd64/arch/x86_64/ia32/ia32_ioctl.c
--- linux/arch/x86_64/ia32/ia32_ioctl.c	2003-06-14 23:42:45.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/ia32/ia32_ioctl.c	2003-06-26 11:31:44.000000000 +0200
@@ -552,7 +552,7 @@ static int do_usbdevfs_reapurb(unsigned 
 	set_fs(old_fs);
 
 	if (err >= 0 &&
-	    put_user(((u32)(long)kptr), compat_ptr(arg)))
+	    put_user((u32)(u64)kptr, (u32 *)arg))
 		err = -EFAULT;
 
 	return err;
diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/ptrace32.c linux-2.5.73-amd64/arch/x86_64/ia32/ptrace32.c
--- linux/arch/x86_64/ia32/ptrace32.c	2003-05-27 03:00:27.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/ia32/ptrace32.c	2003-06-19 10:42:44.000000000 +0200
@@ -210,6 +210,7 @@ static struct task_struct *find_target(i
 		return child; 
 	} 
  out:
+	if (child)
 	put_task_struct(child);
 	return NULL; 
 	
diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/sys_ia32.c linux-2.5.73-amd64/arch/x86_64/ia32/sys_ia32.c
--- linux/arch/x86_64/ia32/sys_ia32.c	2003-06-17 15:52:48.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/ia32/sys_ia32.c	2003-06-25 14:01:47.000000000 +0200
@@ -946,10 +946,30 @@ sys32_sysinfo(struct sysinfo32 *info)
 	struct sysinfo s;
 	int ret;
 	mm_segment_t old_fs = get_fs ();
+	int bitcount = 0;
 	
 	set_fs (KERNEL_DS);
 	ret = sys_sysinfo(&s);
 	set_fs (old_fs);
+
+        /* Check to see if any memory value is too large for 32-bit and scale
+	 *  down if needed
+	 */
+	if ((s.totalram >> 32) || (s.totalswap >> 32)) {
+		while (s.mem_unit < PAGE_SIZE) {
+			s.mem_unit <<= 1;
+			bitcount++;
+		}
+		s.totalram >>= bitcount;
+		s.freeram >>= bitcount;
+		s.sharedram >>= bitcount;
+		s.bufferram >>= bitcount;
+		s.totalswap >>= bitcount;
+		s.freeswap >>= bitcount;
+		s.totalhigh >>= bitcount;
+		s.freehigh >>= bitcount;
+	}
+
 	if (verify_area(VERIFY_WRITE, info, sizeof(struct sysinfo32)) ||
 	    __put_user (s.uptime, &info->uptime) ||
 	    __put_user (s.loads[0], &info->loads[0]) ||
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/acpi/boot.c linux-2.5.73-amd64/arch/x86_64/kernel/acpi/boot.c
--- linux/arch/x86_64/kernel/acpi/boot.c	2003-06-14 23:42:45.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/kernel/acpi/boot.c	2003-06-17 16:45:32.000000000 +0200
@@ -100,7 +100,7 @@ acpi_parse_madt (
 	if (madt->lapic_address)
 		acpi_lapic_addr = (u64) madt->lapic_address;
 
-	printk(KERN_INFO PREFIX "Local APIC address 0x%08x\n",
+	printk(KERN_INFO PREFIX "Local APIC address 0x%016x\n",
 		madt->lapic_address);
 
 	return 0;
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/i8259.c linux-2.5.73-amd64/arch/x86_64/kernel/i8259.c
--- linux/arch/x86_64/kernel/i8259.c	2003-06-14 23:42:45.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/kernel/i8259.c	2003-06-17 16:45:32.000000000 +0200
@@ -26,9 +26,6 @@
 
 #include <linux/irq.h>
 
-/* When we have things working, we can switch to always use
-   IOAPIC. --pavel */
-
 /*
  * Common place to define all x86 IRQ vectors
  *
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/module.c linux-2.5.73-amd64/arch/x86_64/kernel/module.c
--- linux/arch/x86_64/kernel/module.c	2003-05-27 03:00:56.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/kernel/module.c	2003-06-17 16:45:32.000000000 +0200
@@ -31,9 +31,6 @@
 
 #define DEBUGP(fmt...) 
  
-/* TODO this should be in vmlist, but we must fix get_vm_area first to 
-   handle out of bounds entries properly. 
-   Also need to fix /proc/kcore, /dev/kmem */
 static struct vm_struct *mod_vmlist;
 
 void module_free(struct module *mod, void *module_region)
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/nmi.c linux-2.5.73-amd64/arch/x86_64/kernel/nmi.c
--- linux/arch/x86_64/kernel/nmi.c	2003-06-17 15:52:49.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/kernel/nmi.c	2003-06-20 14:13:12.000000000 +0200
@@ -34,7 +34,7 @@
 
 extern void default_do_nmi(struct pt_regs *);
 
-unsigned int nmi_watchdog = NMI_LOCAL_APIC;
+unsigned int nmi_watchdog = NMI_IO_APIC;
 static unsigned int nmi_hz = HZ;
 unsigned int nmi_perfctr_msr;	/* the MSR to reset in NMI handler */
 int nmi_watchdog_disabled;
@@ -153,17 +153,19 @@ void enable_lapic_nmi_watchdog(void)
 
 #include <linux/device.h>
 
+static int nmi_pm_active; /* nmi_active before suspend */
+
 static int lapic_nmi_suspend(struct sys_device *dev, u32 state)
 {
+	nmi_pm_active = nmi_active;
 	disable_lapic_nmi_watchdog();
 	return 0;
 }
 
 static int lapic_nmi_resume(struct sys_device *dev)
 {
-#if 0
+	if (nmi_pm_active > 0)
 	enable_lapic_nmi_watchdog();
-#endif
 	return 0;
 }
 
@@ -235,6 +237,8 @@ void setup_apic_nmi_watchdog (void)
 	case X86_VENDOR_AMD:
 		if (boot_cpu_data.x86 < 6)
 			return;
+		if (strstr(boot_cpu_data.x86_model_id, "Screwdriver"))
+			return;
 		setup_k7_watchdog();
 		break;
 	default:
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/pci-gart.c linux-2.5.73-amd64/arch/x86_64/kernel/pci-gart.c
--- linux/arch/x86_64/kernel/pci-gart.c	2003-06-17 15:52:49.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/kernel/pci-gart.c	2003-06-24 15:35:16.000000000 +0200
@@ -236,7 +236,7 @@ void dump_leak(void)
 	static int dump; 
 	if (dump || !iommu_leak_tab) return;
 	dump = 1;
-	show_stack(NULL);
+	show_stack(NULL,NULL);
 	/* Very crude. dump some from the end of the table too */ 
 	printk("Dumping %d pages from end of IOMMU:\n", iommu_leak_pages); 
 	for (i = 0; i < iommu_leak_pages; i+=2) {
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/suspend.c linux-2.5.73-amd64/arch/x86_64/kernel/suspend.c
--- linux/arch/x86_64/kernel/suspend.c	2003-06-14 23:42:45.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/kernel/suspend.c	2003-06-25 20:40:33.000000000 +0200
@@ -121,11 +121,12 @@ void fix_processor_context(void)
 	struct tss_struct * t = init_tss + cpu;
 
 	set_tss_desc(cpu,t);	/* This just modifies memory; should not be neccessary. But... This is neccessary, because 386 hardware has concept of busy TSS or some similar stupidity. */
-        ((struct n_desc_struct *) &cpu_gdt_table[cpu][GDT_ENTRY_TSS])->b &= 0xfffffdff;
+
+	cpu_gdt_table[cpu][GDT_ENTRY_TSS].type = 9;
 
 	syscall_init();                         /* This sets MSR_*STAR and related */
 	load_TR_desc();				/* This does ltr */
-	load_LDT(&current->mm->context);	/* This does lldt */
+	load_LDT(&current->active_mm->context);	/* This does lldt */
 
 	/*
 	 * Now maybe reload the debug registers
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/time.c linux-2.5.73-amd64/arch/x86_64/kernel/time.c
--- linux/arch/x86_64/kernel/time.c	2003-06-17 15:52:49.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/kernel/time.c	2003-06-24 15:31:58.000000000 +0200
@@ -47,6 +47,7 @@ unsigned long hpet_period;				/* fsecs /
 unsigned long hpet_tick;				/* HPET clocks / interrupt */
 unsigned long vxtime_hz = 1193182;
 int report_lost_ticks;				/* command line option */
+unsigned long long monotonic_base;
 
 struct vxtime_data __vxtime __section_vxtime;	/* for vsyscalls */
 
@@ -137,6 +138,18 @@ int do_settimeofday(struct timespec *tv)
 		tv->tv_sec--;
 	}
 
+	wall_to_monotonic.tv_sec += xtime.tv_sec - tv->tv_sec;
+	wall_to_monotonic.tv_nsec += xtime.tv_nsec - tv->tv_nsec;
+
+	if (wall_to_monotonic.tv_nsec > NSEC_PER_SEC) {
+		wall_to_monotonic.tv_nsec -= NSEC_PER_SEC;
+		wall_to_monotonic.tv_sec++;
+	}
+	if (wall_to_monotonic.tv_nsec < 0) {
+		wall_to_monotonic.tv_nsec += NSEC_PER_SEC;
+		wall_to_monotonic.tv_sec--;
+	}
+
 	xtime.tv_sec = tv->tv_sec;
 	xtime.tv_nsec = tv->tv_nsec;
 
@@ -219,6 +232,47 @@ static void set_rtc_mmss(unsigned long n
 	spin_unlock(&rtc_lock);
 }
 
+
+/* monotonic_clock(): returns # of nanoseconds passed since time_init()
+ *		Note: This function is required to return accurate
+ *		time even in the absence of multiple timer ticks.
+ */
+unsigned long long monotonic_clock(void)
+{
+	unsigned long seq;
+ 	u32 last_offset, this_offset, offset;
+	unsigned long long base;
+
+	if (vxtime.mode == VXTIME_HPET) {
+		do {
+			seq = read_seqbegin(&xtime_lock);
+
+			last_offset = vxtime.last;
+			base = monotonic_base;
+			this_offset = hpet_readl(HPET_T0_CMP) - hpet_tick;
+
+		} while (read_seqretry(&xtime_lock, seq));
+		offset = (this_offset - last_offset);
+		offset *=(NSEC_PER_SEC/HZ)/hpet_tick;
+		return base + offset;
+	}else{
+		do {
+			seq = read_seqbegin(&xtime_lock);
+
+			last_offset = vxtime.last_tsc;
+			base = monotonic_base;
+		} while (read_seqretry(&xtime_lock, seq));
+		sync_core();
+		rdtscll(this_offset);
+		offset = (this_offset - last_offset)*1000/cpu_khz; 
+		return base + offset;
+	}
+
+
+}
+EXPORT_SYMBOL(monotonic_clock);
+
+
 static irqreturn_t timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	static unsigned long rtc_update = 0;
@@ -253,6 +307,9 @@ static irqreturn_t timer_interrupt(int i
 			lost = (offset - vxtime.last) / hpet_tick - 1;
 		}
 
+		monotonic_base += 
+			(offset - vxtime.last)*(NSEC_PER_SEC/HZ) / hpet_tick;
+
 		vxtime.last = offset;
 	} else {
 		offset = (((tsc - vxtime.last_tsc) *
@@ -266,6 +323,8 @@ static irqreturn_t timer_interrupt(int i
 			offset %= (USEC_PER_SEC / HZ);
 		}
 
+		monotonic_base += (tsc - vxtime.last_tsc)*1000000/cpu_khz ;
+
 		vxtime.last_tsc = tsc - vxtime.quot * delay / vxtime.tsc_quot;
 
 		if ((((tsc - vxtime.last_tsc) *
@@ -544,6 +603,9 @@ void __init time_init(void)
 	xtime.tv_sec = get_cmos_time();
 	xtime.tv_nsec = 0;
 
+	wall_to_monotonic.tv_sec = -xtime.tv_sec;
+	wall_to_monotonic.tv_nsec = -xtime.tv_nsec;
+
 	if (!hpet_init()) {
                 vxtime_hz = (1000000000000000L + hpet_period / 2) /
 			hpet_period;
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/traps.c linux-2.5.73-amd64/arch/x86_64/kernel/traps.c
--- linux/arch/x86_64/kernel/traps.c	2003-06-17 15:52:49.000000000 +0200
+++ linux-2.5.73-amd64/arch/x86_64/kernel/traps.c	2003-06-24 15:03:35.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -206,7 +207,7 @@ void show_trace_task(struct task_struct 
 	show_trace((unsigned long *)rsp);
 }
 
-void show_stack(unsigned long * rsp)
+void show_stack(struct task_struct *tsk, unsigned long * rsp)
 {
 	unsigned long *stack;
 	int i;
@@ -214,7 +215,7 @@ void show_stack(unsigned long * rsp)
 	unsigned long *irqstack_end = (unsigned long *) (cpu_pda[cpu].irqstackptr);
 	unsigned long *irqstack = (unsigned long *) (cpu_pda[cpu].irqstackptr - IRQSTACKSIZE);    
 
-	// debugging aid: "show_stack(NULL);" prints the
+	// debugging aid: "show_stack(NULL, NULL);" prints the
 	// back trace for this cpu.
 
 	if(rsp==NULL)
@@ -269,7 +270,7 @@ void show_registers(struct pt_regs *regs
 	if (in_kernel) {
 
 		printk("Stack: ");
-		show_stack((unsigned long*)rsp);
+		show_stack(NULL, (unsigned long*)rsp);
 
 		printk("\nCode: ");
 		if(regs->rip < PAGE_OFFSET)
@@ -831,3 +832,4 @@ void __init trap_init(void)
 	 */
 	cpu_init();
 }
+
diff -burpN -X ../KDIFX linux/drivers/acpi/osl.c linux-2.5.73-amd64/drivers/acpi/osl.c
--- linux/drivers/acpi/osl.c	2003-06-24 14:57:02.000000000 +0200
+++ linux-2.5.73-amd64/drivers/acpi/osl.c	2003-06-26 11:41:45.000000000 +0200
@@ -933,8 +933,8 @@ acpi_os_get_line(char *buffer)
 }
 
 /* Assumes no unreadable holes inbetween */
-BOOLEAN
-acpi_os_readable(void *ptr, u32 len)
+u8
+acpi_os_readable(void *ptr, acpi_size len)
 {
 #if defined(__i386__) || defined(__x86_64__) 
 	char tmp;
@@ -943,8 +943,8 @@ acpi_os_readable(void *ptr, u32 len)
 	return 1;
 }
 
-BOOLEAN
-acpi_os_writable(void *ptr, u32 len)
+u8
+acpi_os_writable(void *ptr, acpi_size len)
 {
 	/* could do dummy write (racy) or a kernel page table lookup.
 	   The later may be difficult at early boot when kmap doesn't work yet. */
diff -burpN -X ../KDIFX linux/drivers/acpi/processor.c linux-2.5.73-amd64/drivers/acpi/processor.c
--- linux/drivers/acpi/processor.c	2003-06-14 23:42:45.000000000 +0200
+++ linux-2.5.73-amd64/drivers/acpi/processor.c	2003-06-24 15:45:20.000000000 +0200
@@ -1351,7 +1351,7 @@ static int acpi_processor_throttling_ope
 						PDE(inode)->data);
 }
 
-static int
+static ssize_t
 acpi_processor_write_throttling (
         struct file		*file,
         const char		*buffer,
@@ -1414,7 +1414,7 @@ static int acpi_processor_limit_open_fs(
 						PDE(inode)->data);
 }
 
-static int
+static ssize_t
 acpi_processor_write_limit (
 	struct file		*file,
 	const char		*buffer,
diff -burpN -X ../KDIFX linux/drivers/acpi/thermal.c linux-2.5.73-amd64/drivers/acpi/thermal.c
--- linux/drivers/acpi/thermal.c	2003-06-14 23:42:45.000000000 +0200
+++ linux-2.5.73-amd64/drivers/acpi/thermal.c	2003-06-24 15:48:16.000000000 +0200
@@ -84,11 +84,11 @@ static int acpi_thermal_remove (struct a
 static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file);
 static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_write_trip_points (struct file*,const char *,size_t,loff_t *);
+static ssize_t acpi_thermal_write_trip_points (struct file*,const char *,size_t,loff_t *);
 static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_write_cooling_mode (struct file*,const char *,size_t,loff_t *);
+static ssize_t acpi_thermal_write_cooling_mode (struct file*,const char *,size_t,loff_t *);
 static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file);
-static int acpi_thermal_write_polling(struct file*,const char *,size_t,loff_t *);
+static ssize_t acpi_thermal_write_polling(struct file*,const char *,size_t,loff_t *);
 
 static struct acpi_driver acpi_thermal_driver = {
 	.name =		ACPI_THERMAL_DRIVER_NAME,
@@ -881,7 +881,7 @@ static int acpi_thermal_trip_open_fs(str
 	return single_open(file, acpi_thermal_trip_seq_show, PDE(inode)->data);
 }
 
-static int
+static ssize_t
 acpi_thermal_write_trip_points (
         struct file		*file,
         const char		*buffer,
@@ -950,7 +950,7 @@ static int acpi_thermal_cooling_open_fs(
 							PDE(inode)->data);
 }
 
-static int
+static ssize_t
 acpi_thermal_write_cooling_mode (
 	struct file		*file,
 	const char		*buffer,
@@ -1011,7 +1011,7 @@ static int acpi_thermal_polling_open_fs(
 							PDE(inode)->data);
 }
 
-static int
+static ssize_t
 acpi_thermal_write_polling (
 	struct file		*file,
 	const char		*buffer,
diff -burpN -X ../KDIFX linux/drivers/ide/Kconfig linux-2.5.73-amd64/drivers/ide/Kconfig
--- linux/drivers/ide/Kconfig	2003-06-17 15:52:49.000000000 +0200
+++ linux-2.5.73-amd64/drivers/ide/Kconfig	2003-06-26 11:31:20.000000000 +0200
@@ -267,7 +267,7 @@ config BLK_DEV_IDESCSI
 
 config IDE_TASK_IOCTL
 	bool "IDE Taskfile Access"
-	depends on BLK_DEV_IDE
+	depends on BLK_DEV_IDE && BROKEN
 	help
 	  This is a direct raw access to the media.  It is a complex but
 	  elegant solution to test and validate the domain of the hardware and
diff -burpN -X ../KDIFX linux/drivers/video/vesafb.c linux-2.5.73-amd64/drivers/video/vesafb.c
--- linux/drivers/video/vesafb.c	2003-05-27 03:00:22.000000000 +0200
+++ linux-2.5.73-amd64/drivers/video/vesafb.c	2003-06-17 16:45:32.000000000 +0200
@@ -51,7 +51,11 @@ static struct fb_info fb_info;
 static u32 pseudo_palette[17];
 
 static int             inverse   = 0;
+#ifndef CONFIG_ISA
+static int             mtrr      = 1;
+#else
 static int             mtrr      = 0;
+#endif
 
 static int             pmi_setpal = 0;	/* pmi for palette changes ??? */
 static int             ypan       = 0;  /* 0..nothing, 1..ypan, 2..ywrap */
diff -burpN -X ../KDIFX linux/fs/Kconfig.binfmt linux-2.5.73-amd64/fs/Kconfig.binfmt
--- linux/fs/Kconfig.binfmt	2003-06-24 14:57:04.000000000 +0200
+++ linux-2.5.73-amd64/fs/Kconfig.binfmt	2003-06-24 15:34:21.000000000 +0200
@@ -43,7 +43,7 @@ config BINFMT_ZFLAT
 
 config BINFMT_AOUT
 	tristate "Kernel support for a.out and ECOFF binaries"
-	depends on X86 || ALPHA || ARM || M68K || MIPS || SPARC
+	depends on (X86 && !X86_64) || ALPHA || ARM || M68K || MIPS || SPARC
 	---help---
 	  A.out (Assembler.OUTput) is a set of formats for libraries and
 	  executables used in the earliest versions of UNIX.  Linux used
diff -burpN -X ../KDIFX linux/fs/compat_ioctl.c linux-2.5.73-amd64/fs/compat_ioctl.c
--- linux/fs/compat_ioctl.c	2003-06-17 15:52:51.000000000 +0200
+++ linux-2.5.73-amd64/fs/compat_ioctl.c	2003-06-25 23:54:55.000000000 +0200
@@ -2277,7 +2277,7 @@ struct mtd_oob_buf32 {
 #define MEMWRITEOOB32 	_IOWR('M',3,struct mtd_oob_buf32)
 #define MEMREADOOB32 	_IOWR('M',4,struct mtd_oob_buf32)
 
-static int mtd_rw_oob(unsigned int fd, unsigned int cmd, unsigned long arg)
+int mtd_rw_oob(unsigned int fd, unsigned int cmd, unsigned long arg)
 {
 	struct mtd_oob_buf	*buf = compat_alloc_user_space(sizeof(*buf));
 	struct mtd_oob_buf32	*buf32 = (struct mtd_oob_buf32 *) arg;
diff -burpN -X ../KDIFX linux/include/asm-x86_64/floppy.h linux-2.5.73-amd64/include/asm-x86_64/floppy.h
--- linux/include/asm-x86_64/floppy.h	2003-05-27 03:00:26.000000000 +0200
+++ linux-2.5.73-amd64/include/asm-x86_64/floppy.h	2003-06-17 16:45:32.000000000 +0200
@@ -22,7 +22,7 @@
  * floppy accesses go through the track buffer.
  */
 #define _CROSS_64KB(a,s,vdma) \
-(!vdma && ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64))
+(!(vdma) && ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64))
 
 #define CROSS_64KB(a,s) _CROSS_64KB(a,s,use_virtual_dma & 1)
 
@@ -62,10 +62,8 @@ static irqreturn_t floppy_hardint(int ir
 	static int bytes=0;
 	static int dma_wait=0;
 #endif
-	if(!doing_pdma) {
-		floppy_interrupt(irq, dev_id, regs);
-		return IRQ_HANDLED;
-	}
+	if (!doing_pdma)
+		return floppy_interrupt(irq, dev_id, regs);
 
 #ifdef TRACE_FLPY_INT
 	if(!calls)
@@ -115,7 +113,6 @@ static irqreturn_t floppy_hardint(int ir
 	if(!virtual_dma_count)
 		dma_wait++;
 #endif
-
 	return IRQ_HANDLED;
 }
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/mtrr.h linux-2.5.73-amd64/include/asm-x86_64/mtrr.h
--- linux/include/asm-x86_64/mtrr.h	2003-05-27 03:00:25.000000000 +0200
+++ linux-2.5.73-amd64/include/asm-x86_64/mtrr.h	2003-06-17 16:45:32.000000000 +0200
@@ -104,7 +104,7 @@ static __inline__ int mtrr_del_page (int
     return -ENODEV;
 }
 
-static __inline__ void mtrr_centaur_report_mcr(int mcr, u32 lo, u32 hi) {;}
+static __inline__ void mtrr_centaur_report_mcr(int mcr, u32 lo, u32 hi) {}
 
 #  endif
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/pgtable.h linux-2.5.73-amd64/include/asm-x86_64/pgtable.h
--- linux/include/asm-x86_64/pgtable.h	2003-06-17 15:52:51.000000000 +0200
+++ linux-2.5.73-amd64/include/asm-x86_64/pgtable.h	2003-06-19 00:16:50.000000000 +0200
@@ -401,6 +401,9 @@ extern int kern_addr_valid(unsigned long
 #define pgtable_cache_init()   do { } while (0)
 #define check_pgt_cache()      do { } while (0)
 
+#define PAGE_AGP    PAGE_KERNEL_NOCACHE
+#define HAVE_PAGE_AGP 1
+
 /* fs/proc/kcore.c */
 #define	kc_vaddr_to_offset(v) ((v) & __VIRTUAL_MASK)
 #define	kc_offset_to_vaddr(o) \
diff -burpN -X ../KDIFX linux/include/asm-x86_64/proto.h linux-2.5.73-amd64/include/asm-x86_64/proto.h
--- linux/include/asm-x86_64/proto.h	2003-06-17 15:52:51.000000000 +0200
+++ linux-2.5.73-amd64/include/asm-x86_64/proto.h	2003-06-24 15:02:39.000000000 +0200
@@ -52,7 +52,6 @@ extern unsigned long end_pfn_map; 
 
 extern unsigned long cpu_initialized;
 
-extern void show_stack(unsigned long * rsp);
 extern void show_trace(unsigned long * rsp);
 extern void show_registers(struct pt_regs *regs);
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/unistd.h linux-2.5.73-amd64/include/asm-x86_64/unistd.h
--- linux/include/asm-x86_64/unistd.h	2003-05-27 03:00:43.000000000 +0200
+++ linux-2.5.73-amd64/include/asm-x86_64/unistd.h	2003-06-26 11:36:41.000000000 +0200
@@ -486,10 +486,10 @@ __SYSCALL(__NR_get_thread_area, sys_ni_s
 __SYSCALL(__NR_lookup_dcookie, sys_lookup_dcookie)
 #define __NR_epoll_create	213
 __SYSCALL(__NR_epoll_create, sys_epoll_create)
-#define __NR_epoll_ctl	214
-__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
-#define __NR_epoll_wait	215
-__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
+#define __NR_epoll_ctl_old	214
+__SYSCALL(__NR_epoll_ctl_old, sys_ni_syscall)
+#define __NR_epoll_wait_old	215
+__SYSCALL(__NR_epoll_wait_old, sys_ni_syscall)
 #define __NR_remap_file_pages	216
 __SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)
 #define __NR_getdents64	217
@@ -522,8 +522,12 @@ __SYSCALL(__NR_clock_getres, sys_clock_g
 __SYSCALL(__NR_clock_nanosleep, sys_clock_nanosleep)
 #define __NR_exit_group		231
 __SYSCALL(__NR_exit_group, sys_exit_group)
+#define __NR_epoll_wait		232
+__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
+#define __NR_epoll_ctl		233
+__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
 
-#define __NR_syscall_max __NR_exit_group
+#define __NR_syscall_max __NR_epoll_ctl
 #ifndef __NO_STUBS
 
 /* user-visible error numbers are in the range -1 - -4095 */
diff -burpN -X ../KDIFX linux/include/linux/eventpoll.h linux-2.5.73-amd64/include/linux/eventpoll.h
--- linux/include/linux/eventpoll.h	2003-05-27 03:00:39.000000000 +0200
+++ linux-2.5.73-amd64/include/linux/eventpoll.h	2003-06-24 13:44:30.000000000 +0200
@@ -23,10 +23,20 @@
 /* Set the Edge Triggered behaviour for the target file descriptor */
 #define EPOLLET (1 << 31)
 
+/* 
+ * On x86-64 make the 64bit structure have the same alignment as the
+ * 32bit structure. This makes 32bit emulation easier.
+ */
+#ifdef __x86_64__
+#define EPOLL_PACKED __attribute__((packed))
+#else
+#define EPOLL_PACKED
+#endif
+
 struct epoll_event {
 	__u32 events;
 	__u64 data;
-};
+} EPOLL_PACKED;
 
 #ifdef __KERNEL__
 
diff -burpN -X ../KDIFX linux/kernel/printk.c linux-2.5.73-amd64/kernel/printk.c
--- linux/kernel/printk.c	2003-05-27 03:01:01.000000000 +0200
+++ linux-2.5.73-amd64/kernel/printk.c	2003-06-20 09:18:51.000000000 +0200
@@ -186,16 +186,19 @@ int do_syslog(int type, char __user * bu
 			goto out;
 		i = 0;
 		spin_lock_irq(&logbuf_lock);
-		while ((log_start != log_end) && i < len) {
+		error = 0;
+		while (!error && (log_start != log_end) && i < len) {
 			c = LOG_BUF(log_start);
 			log_start++;
 			spin_unlock_irq(&logbuf_lock);
-			__put_user(c,buf);
+			error |= __put_user(c,buf);
 			buf++;
 			i++;
 			spin_lock_irq(&logbuf_lock);
 		}
 		spin_unlock_irq(&logbuf_lock);
+		if (error)
+			break;
 		error = i;
 		break;
 	case 4:		/* Read/clear last kernel messages */
@@ -232,20 +235,24 @@ int do_syslog(int type, char __user * bu
 				break;
 			c = LOG_BUF(j);
 			spin_unlock_irq(&logbuf_lock);
-			__put_user(c,&buf[count-1-i]);
+			error |= __put_user(c,&buf[count-1-i]);
 			spin_lock_irq(&logbuf_lock);
 		}
 		spin_unlock_irq(&logbuf_lock);
+		if (error)
+			break;
 		error = i;
 		if(i != count) {
 			int offset = count-error;
 			/* buffer overflow during copy, correct user buffer. */
 			for(i=0;i<error;i++) {
-				__get_user(c,&buf[i+offset]);
-				__put_user(c,&buf[i]);
+				if (__get_user(c,&buf[i+offset]) ||
+				    __put_user(c,&buf[i])) { 
+					error = -EFAULT;
+					break;
+				}					
 			}
 		}
-
 		break;
 	case 5:		/* Clear ring buffer */
 		logged_chars = 0;
