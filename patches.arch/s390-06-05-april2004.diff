- Description: qeth: too many qeth_reg_ip kernel threads
               when registering hundreds ip addresses
  Symptom:     registering hundreds ip addresses causes hundreds of
               waiting kernel threads
  Problem:     creating hundreds of useless kernel threads is just wasteful
  Solution:    don't start a new kernel thread for every new ip address
               to be registered/deleted, when one kernel thread is already
               running, it's enough to start yet another thread and put it
               into the wait queue for the remaining IP addresses
  Problem-ID:  9634
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_main.c	21 Jun 2004 01:01:28 -0000	1.77.2.20
+++ linux-2.5/drivers/s390/net/qeth_main.c	25 Jun 2004 14:37:24 -0000	1.77.2.21
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.20 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.21 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.20 $	 $Date: 2004/06/21 01:01:28 $
+ *    $Revision: 1.77.2.21 $	 $Date: 2004/06/25 14:37:24 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.20 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.21 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -818,14 +818,20 @@
 static void qeth_add_multicast_ipv6(struct qeth_card *);
 #endif
 
-static void
+static inline int
 qeth_set_thread_start_bit(struct qeth_card *card, unsigned long thread)
 {
 	unsigned long flags;
-
+	
 	spin_lock_irqsave(&card->thread_mask_lock, flags);
+	if ( !(card->thread_allowed_mask & thread) ||
+	      (card->thread_start_mask & thread) ) {
+		spin_unlock_irqrestore(&card->thread_mask_lock, flags);
+		return -EPERM;
+	}
 	card->thread_start_mask |= thread;
 	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
+	return 0;
 }
 
 static void
@@ -952,8 +958,8 @@
 {
 	QETH_DBF_TEXT(trace,2,"startrec");
 	
-	qeth_set_thread_start_bit(card, QETH_RECOVER_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+	if (qeth_set_thread_start_bit(card, QETH_RECOVER_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 }
 
 static int
@@ -1568,9 +1574,9 @@
 	QETH_DBF_TEXT(trace, 2, "rstipadd");
 
 	qeth_clear_ip_list(card, 0, 1);
-	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
-	qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+	if ( (qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD) == 0) ||
+	     (qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD) == 0) )
+		schedule_work(&card->kernel_thread_starter);
 }
 
 static struct qeth_ipa_cmd * 
@@ -4723,10 +4729,9 @@
 	if (card->vlangrp)
 		card->vlangrp->vlan_devices[vid] = NULL;
 	spin_unlock_irqrestore(&card->vlanlock, flags);
-	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
-	/* delete mc addresses for this vlan dev */
-	qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+ 	if ( (qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD) == 0) ||
+	     (qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD) == 0) )
+		schedule_work(&card->kernel_thread_starter);
 }
 #endif
 
@@ -4955,8 +4960,8 @@
 	QETH_DBF_TEXT(trace,3,"setmulti");
 	card = (struct qeth_card *) dev->priv;
 	
-	qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+	if (qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 }
 
 static void
@@ -6427,8 +6432,8 @@
 	rtnl_lock();
 	dev_open(card->dev);
 	rtnl_unlock();
-	qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+ 	if (qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 }
 
 static int 
@@ -6814,8 +6819,8 @@
 	}
 	if (!qeth_add_ip(card, ipaddr))
 		kfree(ipaddr);
-	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+ 	if (qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 	return rc;
 }
 
@@ -6843,8 +6848,8 @@
 		return;
 	if (!qeth_delete_ip(card, ipaddr))
 		kfree(ipaddr);
-	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+ 	if (qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 }
 
 /*
@@ -6887,8 +6892,8 @@
 	}
 	if (!qeth_add_ip(card, ipaddr))
 		kfree(ipaddr);
-	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+ 	if (qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 	return 0;
 }
 
@@ -6916,8 +6921,8 @@
 		return;
 	if (!qeth_delete_ip(card, ipaddr))
 		kfree(ipaddr);
-	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+ 	if (qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 }
 
 /**
@@ -6957,8 +6962,8 @@
 	default:
 		break;
 	}
-	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+	if (qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 out:	
 	return NOTIFY_DONE;
 }
@@ -7032,8 +7037,8 @@
 	default:
 		break;
 	}
-	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
-	schedule_work(&card->kernel_thread_starter);
+ 	if (qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD) == 0)
+		schedule_work(&card->kernel_thread_starter);
 out:
 	return NOTIFY_DONE;
 }

