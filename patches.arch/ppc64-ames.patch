diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/Kconfig linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/Kconfig
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/Kconfig	2004-04-12 17:54:05.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/Kconfig	2004-04-13 17:25:57.000000000 +0000
@@ -89,6 +89,16 @@ config PPC_PMAC
 	bool "Apple PowerMac G5 support"
 	select ADB_PMU
 
+config PPC_SPLPAR
+	depends on PPC_PSERIES
+	bool "Support for shared-processor logical partitions"
+	default n
+	help
+	  Enabling this option will make the kernel run more efficiently
+	  on logically-partitioned pSeries systems which use shared
+	  processors, that is, which share physical processors between
+	  two or more partitions.
+
 config PMAC_DART
 	bool "Enable DART/IOMMU on PowerMac (allow >2G of RAM)"
 	depends on PPC_PMAC
@@ -203,10 +213,21 @@ config SCANLOG
 	depends on PPC_RTAS
 
 config LPARCFG
-	bool "LPAR Configuration Data"
+	tristate "LPAR Configuration Data"
 	help
 	Provide system capacity information via human readable 
 	<key word>=<value> pairs through a /proc/ppc64/lparcfg interface.
+	LPARCFG uses the "Virtual Processor Utilization Values" framework for PURR 
+	support. 
+
+config PPC_VPURR
+	bool "Virtual Processor Utilization Values"
+	default n
+	depends on PPC_PSERIES
+	help
+	Provide framework to collect virtual processor utilization
+	periodically.  This function is used by "LPAR Configuration Data" for PURR support.  
+	If unsure say NO.
 
 endmenu
 
@@ -371,17 +392,46 @@ config DEBUGGER
 	  Include in-kernel hooks for kernel debuggers. Unless you are
 	  intending to debug the kernel, say N here.
 
-config XMON
-	bool "Include xmon kernel debugger"
+choice
+	optional
 	depends on DEBUGGER
+	prompt "Kernel Debugger"
+
+config XMON
+	bool "XMON"
 	help
 	  Include in-kernel hooks for the xmon kernel monitor/debugger.
 	  Unless you are intending to debug the kernel, say N here.
 
+config KDB
+	bool "KDB"
+	help
+	  Include in-kernel hooks for the kdb kernel monitor/debugger.
+	  Unless you are intending to debug the kernel, say N here.
+
+config KDB_MODULES
+	bool "Enable additional KDB modules"
+	depends on KDB
+	help
+	  Include additional KDB support for viewing buffer heads,
+	  pages, inodes, dentrys, vm areas and scsi devices and
+	  scsi commands.
+
+endchoice
+
+
 config XMON_DEFAULT
 	bool "Enable xmon by default"
 	depends on XMON
 
+config KDB_OFF
+	bool "Turn KDB off as default."
+	depends on KDB
+
+	help
+ 	   KDB will remain built into the kernel, but will be turned off. 
+	   "cat 1 > /proc/sys/kernel/kdb" to turn it on. 
+
 config PPCDBG
 	bool "Include PPCDBG realtime debugging"
 	depends on DEBUG_KERNEL
@@ -394,6 +444,13 @@ config DEBUG_INFO
 	  debugging info resulting in a larger kernel image.
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
+
+config DEBUG_SPINLOCK_SLEEP
+	bool "Sleep-inside-spinlock checking"
+	depends on DEBUG_KERNEL
+	help
+	  If you say Y here, various routines which may sleep will become very
+	  noisy if they are called with a spinlock held.
 	  
 endmenu
 
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/LparData.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/LparData.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/LparData.c	2004-01-19 06:28:30.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/LparData.c	2004-04-16 23:30:39.000000000 +0000
@@ -10,6 +10,7 @@
 #include <asm/page.h>
 #include <stddef.h>
 #include <linux/threads.h>
+#include <linux/module.h>
 #include <asm/processor.h>
 #include <asm/ptrace.h>
 #include <asm/naca.h>
@@ -123,12 +124,14 @@ struct ItLpNaca itLpNaca = {
 		(u64)InstructionAccessSLB_Iseries /* 0x480 I-SLB */
 	}
 };
+EXPORT_SYMBOL(itLpNaca);
 
 /* May be filled in by the hypervisor so cannot end up in the BSS */
 struct ItIplParmsReal xItIplParmsReal __attribute__((__section__(".data"))); 
 
 /* May be filled in by the hypervisor so cannot end up in the BSS */
 struct ItExtVpdPanel xItExtVpdPanel __attribute__((__section__(".data")));
+EXPORT_SYMBOL(xItExtVpdPanel);
 
 #define maxPhysicalProcessors 32
 
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/Makefile linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/Makefile
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/Makefile	2004-04-12 17:54:10.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/Makefile	2004-04-13 17:25:58.000000000 +0000
@@ -44,6 +44,7 @@ obj-$(CONFIG_PPC_RTAS)		+= rtas-proc.o
 obj-$(CONFIG_SCANLOG)		+= scanlog.o
 obj-$(CONFIG_VIOPATH)		+= viopath.o
 obj-$(CONFIG_LPARCFG)		+= lparcfg.o
+obj-$(CONFIG_PPC_VPURR)		+= vpurr.o
 obj-$(CONFIG_HVC_CONSOLE)	+= hvconsole.o
 obj-$(CONFIG_BOOTX_TEXT)	+= btext.o
 
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/btext.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/btext.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/btext.c	2004-02-12 03:47:48.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/btext.c	2004-04-24 05:30:52.000000000 +0000
@@ -47,8 +47,6 @@ int force_printk_to_btext = 0;
 
 boot_infos_t disp_bi;
 
-extern char *klimit;
-
 /* This function will enable the early boot text when doing OF booting. This
  * way, xmon output should work too
  */
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/chrp_setup.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/chrp_setup.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/chrp_setup.c	2004-04-12 17:54:06.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/chrp_setup.c	2004-04-24 05:42:08.000000000 +0000
@@ -31,7 +31,6 @@
 #include <linux/interrupt.h>
 #include <linux/reboot.h>
 #include <linux/init.h>
-#include <linux/initrd.h>
 #include <linux/ioport.h>
 #include <linux/console.h>
 #include <linux/pci.h>
@@ -136,15 +135,10 @@ chrp_setup_arch(void)
 	/* init to some ~sane value until calibrate_delay() runs */
 	loops_per_jiffy = 50000000;
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	/* this is fine for chrp */
-	initrd_below_start_ok = 1;
-	
-	if (initrd_start)
-		ROOT_DEV = Root_RAM0;
-	else
-#endif
-	ROOT_DEV = Root_SDA2;
+ 	if (ROOT_DEV == 0) {
+ 		printk("No ramdisk, default root is /dev/sda2\n");
+ 		ROOT_DEV = Root_SDA2;
+ 	}
 
 	printk("Boot arguments: %s\n", cmd_line);
 
@@ -239,17 +233,6 @@ chrp_init(unsigned long r3, unsigned lon
 	char * hypertas;
 	unsigned int len;
 
-#if 0 /* PPPBBB remove this later... -Peter */
-#ifdef CONFIG_BLK_DEV_INITRD
-	/* take care of initrd if we have one */
-	if ( r6 )
-	{
-		initrd_start = __va(r6);
-		initrd_end = __va(r6 + r7);
-	}
-#endif /* CONFIG_BLK_DEV_INITRD */
-#endif
-
 	ppc_md.setup_arch     = chrp_setup_arch;
 	ppc_md.get_cpuinfo    = chrp_get_cpuinfo;
 	if (naca->interrupt_controller == IC_OPEN_PIC) {
@@ -280,8 +263,13 @@ chrp_init(unsigned long r3, unsigned lon
          * using contents of device-tree/ibm,hypertas-functions.
          * Ultimately this functionality may be moved into prom.c prom_init().
          */
-	dn = of_find_node_by_path("/rtas");
 	cur_cpu_spec->firmware_features = 0;
+	dn = of_find_node_by_path("/rtas");
+	if (dn == NULL) {
+		printk(KERN_ERR "WARNING ! Cannot find RTAS in device-tree !\n");
+		goto no_rtas;
+	}
+
 	hypertas = get_property(dn, "ibm,hypertas-functions", &len);
 	if (hypertas) {
 		while (len > 0){
@@ -303,6 +291,7 @@ chrp_init(unsigned long r3, unsigned lon
 	}
 
 	of_node_put(dn);
+ no_rtas:
 	printk(KERN_INFO "firmware_features = 0x%lx\n", 
 	       cur_cpu_spec->firmware_features);
 }
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/eeh.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/eeh.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/eeh.c	2004-04-12 17:54:04.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/eeh.c	2004-04-23 03:44:47.000000000 +0000
@@ -49,6 +49,25 @@ static int eeh_subsystem_enabled;
 #define EEH_MAX_OPTS 4096
 static char *eeh_opts;
 static int eeh_opts_last;
+static int eeh_error_buf_size;
+
+/* Buffer for reporting slot-error-detail rtas calls */
+static unsigned char slot_errbuf[RTAS_ERROR_LOG_MAX];
+
+/* Workqueue data for EEH event device removal */
+struct eeh_event {
+	struct list_head	list;
+	struct pci_dev		*dev;
+	struct device_node	*dn;
+	unsigned long		reset_state;
+};
+
+static spinlock_t eeh_eventlist_lock = SPIN_LOCK_UNLOCKED;
+LIST_HEAD(eeh_eventlist);
+static void eeh_event_handler(void *);
+DECLARE_WORK(eeh_event_wq, eeh_event_handler, NULL);
+
+int (*eeh_disable_slot)(struct pci_dev *) = NULL;
 
 /* System monitoring statistics */
 static DEFINE_PER_CPU(unsigned long, total_mmio_ffs);
@@ -347,6 +366,89 @@ static unsigned long eeh_token_to_phys(u
 }
 
 /**
+ * eeh_panic - call panic() for an eeh event that cannot be handled
+ * @dev pci device that had an eeh event
+ * @reset_state current reset state of the device slot
+ */
+static void eeh_panic(struct pci_dev *dev, unsigned long reset_state)
+{
+	/*
+	 * XXX We should create a seperate sysctl for this.
+	 *
+	 * Since the panic_on_oops sysctl is used to halt the system
+	 * in light of potential corruption, we can use it here.
+	 */
+	if (panic_on_oops)
+		panic("EEH: MMIO failure (%ld) on device:%s %s\n", reset_state,
+		      pci_name(dev), pci_pretty_name(dev));
+	else {
+		__get_cpu_var(ignored_failures)++;
+		printk(KERN_INFO "EEH: MMIO failure (%ld) on device:%s %s\n",
+		       reset_state, pci_name(dev), pci_pretty_name(dev));
+	}
+}
+
+/**
+ * eeh_register_disable_func - allows the rpaphp module to let us know
+ *				they're there.
+ * @func - pointer to rpaphp disable slot routine
+ */
+void eeh_register_disable_func(int (*func)(struct pci_dev *))
+{
+	eeh_disable_slot = func;
+}
+EXPORT_SYMBOL(eeh_register_disable_func);
+
+/**
+ * eeh_event_handler - handle any eeh events to see if we can disable
+ *		       the device
+ * @dummy - unused
+ */
+static void eeh_event_handler(void *dummy)
+{
+	struct list_head	*tmp, *n;
+	struct eeh_event	*event;
+	unsigned long		log_event;
+	int			rc;
+
+	spin_lock(&eeh_eventlist_lock);
+
+	memset(slot_errbuf, 0, eeh_error_buf_size);
+
+	list_for_each_safe(tmp, n, &eeh_eventlist) {
+		event = list_entry(tmp, struct eeh_event, list);
+		rc = 1;
+
+		log_event = rtas_call(rtas_token("ibm,slot-error-detail"), 8, 1, NULL,
+				      event->dn->eeh_config_addr,
+				      BUID_HI(event->dn->phb->buid),
+				      BUID_LO(event->dn->phb->buid), NULL, 0,
+				      virt_to_phys(slot_errbuf), eeh_error_buf_size,
+				      2 /* Permanent Error */);
+		if (log_event)
+			log_error(slot_errbuf, ERR_TYPE_RTAS_LOG, 0);
+
+		if (strcmp(event->dn->name, "ethernet") == 0) {
+			if (eeh_disable_slot != NULL)
+				rc = eeh_disable_slot(event->dev);
+		}
+
+		if (rc != 0)
+			eeh_panic(event->dev, event->reset_state);
+		else
+			printk(KERN_INFO "EEH: MMIO failure (%ld) has caused device "
+				"%s %s to be removed\n", event->reset_state,
+				pci_name(event->dev), pci_pretty_name(event->dev));
+
+		pci_dev_put(event->dev);
+		list_del(&event->list);
+		kfree(event);
+	}
+
+	spin_unlock(&eeh_eventlist_lock);
+}
+
+/**
  * eeh_check_failure - check if all 1's data is due to EEH slot freeze
  * @token i/o token, should be address in the form 0xA....
  * @val value, should be all 1's (XXX why do we need this arg??)
@@ -366,10 +468,6 @@ unsigned long eeh_check_failure(void *to
 	struct pci_dev *dev;
 	struct device_node *dn;
 	unsigned long ret, rets[2];
-	static spinlock_t lock = SPIN_LOCK_UNLOCKED;
-	/* dont want this on the stack */
-	static unsigned char slot_err_buf[RTAS_ERROR_LOG_MAX];
-	unsigned long flags;
 
 	__get_cpu_var(total_mmio_ffs)++;
 
@@ -383,28 +481,20 @@ unsigned long eeh_check_failure(void *to
 		return val;
 
 	dn = pci_device_to_OF_node(dev);
-	if (!dn) {
-		pci_dev_put(dev);
-		return val;
-	}
+	if (!dn) 
+		goto ok_return;
 
 	/* Access to IO BARs might get this far and still not want checking. */
 	if (!(dn->eeh_mode & EEH_MODE_SUPPORTED) ||
-	    dn->eeh_mode & EEH_MODE_NOCHECK) {
-		pci_dev_put(dev);
-		return val;
-	}
+	    dn->eeh_mode & EEH_MODE_NOCHECK) 
+		goto ok_return;
 
         /* Make sure we aren't ISA */
-        if (!strcmp(dn->type, "isa")) {
-                pci_dev_put(dev);
-                return val;
-        }
+        if (!strcmp(dn->type, "isa")) 
+                goto ok_return;
 
-	if (!dn->eeh_config_addr) {
-		pci_dev_put(dev);
-		return val;
-	}
+	if (!dn->eeh_config_addr) 
+		goto ok_return;
 
 	/*
 	 * Now test for an EEH failure.  This is VERY expensive.
@@ -418,43 +508,31 @@ unsigned long eeh_check_failure(void *to
 			BUID_LO(dn->phb->buid));
 
 	if (ret == 0 && rets[1] == 1 && rets[0] >= 2) {
-		unsigned long slot_err_ret;
+		struct eeh_event 	*event;
 
-		spin_lock_irqsave(&lock, flags);
-		memset(slot_err_buf, 0, RTAS_ERROR_LOG_MAX);
-		slot_err_ret = rtas_call(rtas_token("ibm,slot-error-detail"),
-					 8, 1, NULL, dn->eeh_config_addr,
-					 BUID_HI(dn->phb->buid),
-					 BUID_LO(dn->phb->buid), NULL, 0,
-					 __pa(slot_err_buf),
-					 RTAS_ERROR_LOG_MAX,
-					 2 /* Permanent Error */);
-
-		if (slot_err_ret == 0)
-			log_error(slot_err_buf, ERR_TYPE_RTAS_LOG,
-				  1 /* Fatal */);
-
-		spin_unlock_irqrestore(&lock, flags);
-
-		/*
-		 * XXX We should create a separate sysctl for this.
-		 *
-		 * Since the panic_on_oops sysctl is used to halt
-		 * the system in light of potential corruption, we
-		 * can use it here.
-		 */
-		if (panic_on_oops) {
-			panic("EEH: MMIO failure (%ld) on device:%s %s\n",
-			      rets[0], pci_name(dev), pci_pretty_name(dev));
-		} else {
-			__get_cpu_var(ignored_failures)++;
-			printk(KERN_INFO "EEH: MMIO failure (%ld) on device:%s %s\n",
-			       rets[0], pci_name(dev), pci_pretty_name(dev));
+		/* prevent repeated reports of this failure */
+		dn->eeh_mode |= EEH_MODE_NOCHECK;
+
+		event = kmalloc(sizeof(*event), GFP_ATOMIC);
+		if (event == NULL) {
+			eeh_panic(dev, rets[0]);
+			goto ok_return;
 		}
+
+		event->dev = dev;
+		event->dn = dn;
+		event->reset_state = rets[0];
+
+		spin_lock(&eeh_eventlist_lock);
+		list_add(&event->list, &eeh_eventlist);
+		spin_unlock(&eeh_eventlist_lock);
+
+		schedule_work(&eeh_event_wq);
 	} else {
 		__get_cpu_var(false_positives)++;
 	}
 
+ok_return:
 	pci_dev_put(dev);
 	return val;
 }
@@ -568,10 +646,28 @@ static void *early_enable_eeh(struct dev
  */
 void __init eeh_init(void)
 {
-	struct device_node *phb;
+	struct device_node *phb, *np;
 	struct eeh_early_enable_info info;
+	u32 *prop;
 	char *eeh_force_off = strstr(saved_command_line, "eeh-force-off");
 
+	np = of_find_node_by_path("/rtas");
+	if (np == NULL) {
+		printk(KERN_WARNING "EEH: RTAS not found !\n");
+		return;
+	}
+	prop = (u32 *)get_property(np, "rtas-error-log-max", NULL);
+	if (prop == NULL) {
+		printk(KERN_WARNING "EEH: Can't fint rtas-error-log-max !\n");
+		eeh_error_buf_size = 1024;
+	} else
+		eeh_error_buf_size = (int)*prop;
+	if (eeh_error_buf_size > RTAS_ERROR_LOG_MAX) {
+		printk(KERN_WARNING "EEH: rtas-error-log-max is bigger than allocated "
+		       "buffer ! (%d vs %d)", eeh_error_buf_size, RTAS_ERROR_LOG_MAX);
+		eeh_error_buf_size = RTAS_ERROR_LOG_MAX;
+	}
+
 	ibm_set_eeh_option = rtas_token("ibm,set-eeh-option");
 	ibm_set_slot_reset = rtas_token("ibm,set-slot-reset");
 	ibm_read_slot_reset_state = rtas_token("ibm,read-slot-reset-state");
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/iSeries_setup.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/iSeries_setup.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/iSeries_setup.c	2004-03-30 15:45:59.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/iSeries_setup.c	2004-04-01 02:08:56.000000000 +0000
@@ -298,7 +298,6 @@ void __init iSeries_init_early(void)
 		initrd_start = (unsigned long)__va(naca->xRamDisk);
 		initrd_end = initrd_start + naca->xRamDiskSize * PAGE_SIZE;
 		initrd_below_start_ok = 1;	// ramdisk in kernel space
-		ROOT_DEV = Root_RAM0;
 		if (((rd_size * 1024) / PAGE_SIZE) < naca->xRamDiskSize)
 			rd_size = (naca->xRamDiskSize * PAGE_SIZE) / 1024;
 	} else
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/lparcfg.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/lparcfg.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/lparcfg.c	2004-02-27 05:33:08.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/lparcfg.c	2004-04-23 19:03:50.000000000 +0000
@@ -5,6 +5,7 @@
  *    Copyright (c) 2003 Dave Engebretsen
  * Will Schmidt willschm@us.ibm.com
  *    SPLPAR updates, Copyright (c) 2003 Will Schmidt IBM Corporation.
+ *    seq_file updates, Copyright (c) 2004 Will Schmidt IBM Corporation.
  * Nathan Lynch nathanl@austin.ibm.com
  *    Added lparcfg_write, Copyright (C) 2004 Nathan Lynch IBM Corporation.
  *
@@ -23,15 +24,40 @@
 #include <linux/errno.h>
 #include <linux/proc_fs.h>
 #include <linux/init.h>
+#include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include <asm/iSeries/HvLpConfig.h>
 #include <asm/iSeries/ItLpPaca.h>
+#include <asm/iSeries/LparData.h>
 #include <asm/hvcall.h>
 #include <asm/cputable.h>
+#include "vpurr.h"
 
-#define MODULE_VERS "1.0"
+#define MODULE_VERS "1.2"
 #define MODULE_NAME "lparcfg"
 
+/* #define LPARCFG_DEBUG */
+
+/* find a better place for this function... */
+void log_plpar_hcall_return(unsigned long rc,char * tag)
+{
+	if (rc==0) /* success, return */
+		return;
+/* check for null tag ? */
+	if (rc == H_Hardware)
+		printk(KERN_INFO "plpar-hcall (%s) failed with hardware fault\n",tag);
+	else if (rc == H_Function)
+		printk(KERN_INFO "plpar-hcall (%s) failed; function not allowed\n",tag);
+	else if (rc == H_Authority)
+		printk(KERN_INFO "plpar-hcall (%s) failed; not authorized to this function\n",tag);
+	else if (rc == H_Parameter)
+		printk(KERN_INFO "plpar-hcall (%s) failed; Bad parameter(s)\n",tag);
+	else
+		printk(KERN_INFO "plpar-hcall (%s) failed with unexpected rc(0x%lx)\n",tag,rc);
+
+}
+
+
 static struct proc_dir_entry *proc_ppc64_lparcfg;
 #define LPARCFG_BUFF_SIZE 4096
 
@@ -39,103 +65,20 @@ static struct proc_dir_entry *proc_ppc64
 
 #define lparcfg_write NULL
 
-static unsigned char e2a(unsigned char x)
-{
-        switch (x) {
-        case 0xF0:
-                return '0';
-        case 0xF1:
-                return '1';
-        case 0xF2:
-                return '2';
-        case 0xF3:
-                return '3';
-        case 0xF4:
-                return '4';
-        case 0xF5:
-                return '5';
-        case 0xF6:
-                return '6';
-        case 0xF7:
-                return '7';
-        case 0xF8:
-                return '8';
-        case 0xF9:
-                return '9';
-        case 0xC1:
-                return 'A';
-        case 0xC2:
-                return 'B';
-        case 0xC3:
-                return 'C';
-        case 0xC4:
-                return 'D';
-        case 0xC5:
-                return 'E';
-        case 0xC6:
-                return 'F';
-        case 0xC7:
-                return 'G';
-        case 0xC8:
-                return 'H';
-        case 0xC9:
-                return 'I';
-        case 0xD1:
-                return 'J';
-        case 0xD2:
-                return 'K';
-        case 0xD3:
-                return 'L';
-        case 0xD4:
-                return 'M';
-        case 0xD5:
-                return 'N';
-        case 0xD6:
-                return 'O';
-        case 0xD7:
-                return 'P';
-        case 0xD8:
-                return 'Q';
-        case 0xD9:
-                return 'R';
-        case 0xE2:
-                return 'S';
-        case 0xE3:
-                return 'T';
-        case 0xE4:
-                return 'U';
-        case 0xE5:
-                return 'V';
-        case 0xE6:
-                return 'W';
-        case 0xE7:
-                return 'X';
-        case 0xE8:
-                return 'Y';
-        case 0xE9:
-                return 'Z';
-        }
-        return ' ';
-}
+extern unsigned char e2a(unsigned char);
 
 /* 
  * Methods used to fetch LPAR data when running on an iSeries platform.
  */
-static int lparcfg_data(unsigned char *buf, unsigned long size)
+static int lparcfg_data(struct seq_file *m,void *v)
 {
-	unsigned long n = 0, pool_id, lp_index; 
+	unsigned long pool_id, lp_index; 
 	int shared, entitled_capacity, max_entitled_capacity;
 	int processors, max_processors;
 	struct paca_struct *lpaca = get_paca();
 
-	if((buf == NULL) || (size > LPARCFG_BUFF_SIZE)) {
-		return -EFAULT;
-	}
-	memset(buf, 0, size); 
-
 	shared = (int)(lpaca->xLpPacaPtr->xSharedProc);
-	n += scnprintf(buf, LPARCFG_BUFF_SIZE - n,
-		      "serial_number=%c%c%c%c%c%c%c\n", 
+	seq_printf(m, "serial_number=%c%c%c%c%c%c%c\n", 
 		      e2a(xItExtVpdPanel.mfgID[2]),
 		      e2a(xItExtVpdPanel.mfgID[3]),
 		      e2a(xItExtVpdPanel.systemSerial[1]),
@@ -144,32 +87,26 @@ static int lparcfg_data(unsigned char *b
 		      e2a(xItExtVpdPanel.systemSerial[4]),
 		      e2a(xItExtVpdPanel.systemSerial[5])); 
 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "system_type=%c%c%c%c\n",
+	seq_printf(m, "system_type=%c%c%c%c\n",
 		      e2a(xItExtVpdPanel.machineType[0]),
 		      e2a(xItExtVpdPanel.machineType[1]),
 		      e2a(xItExtVpdPanel.machineType[2]),
 		      e2a(xItExtVpdPanel.machineType[3])); 
 
 	lp_index = HvLpConfig_getLpIndex(); 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_id=%d\n", (int)lp_index); 
+	seq_printf(m, "partition_id=%d\n", (int)lp_index); 
 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "system_active_processors=%d\n", 
+	seq_printf(m, "system_active_processors=%d\n", 
 		      (int)HvLpConfig_getSystemPhysicalProcessors()); 
 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "system_potential_processors=%d\n", 
+	seq_printf(m, "system_potential_processors=%d\n", 
 		      (int)HvLpConfig_getSystemPhysicalProcessors()); 
 
 	processors = (int)HvLpConfig_getPhysicalProcessors(); 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_active_processors=%d\n", processors);  
+	seq_printf(m, "partition_active_processors=%d\n", processors);  
 
 	max_processors = (int)HvLpConfig_getMaxPhysicalProcessors(); 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_potential_processors=%d\n", max_processors);  
+	seq_printf(m, "partition_potential_processors=%d\n", max_processors);  
 
 	if(shared) {
 		entitled_capacity = HvLpConfig_getSharedProcUnits(); 
@@ -178,23 +115,18 @@ static int lparcfg_data(unsigned char *b
 		entitled_capacity = processors * 100; 
 		max_entitled_capacity = max_processors * 100; 
 	}
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_entitled_capacity=%d\n", entitled_capacity);
+	seq_printf(m, "partition_entitled_capacity=%d\n", entitled_capacity);
 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_max_entitled_capacity=%d\n", 
+	seq_printf(m, "partition_max_entitled_capacity=%d\n", 
 		      max_entitled_capacity);
 
 	if(shared) {
 		pool_id = HvLpConfig_getSharedPoolIndex(); 
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n, "pool=%d\n",
-			      (int)pool_id); 
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "pool_capacity=%d\n", (int)(HvLpConfig_getNumProcsInSharedPool(pool_id)*100)); 
+		seq_printf(m, "pool=%d\n", (int)pool_id); 
+		seq_printf(m, "pool_capacity=%d\n", (int)(HvLpConfig_getNumProcsInSharedPool(pool_id)*100)); 
 	}
 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "shared_processor_mode=%d\n", shared);
+	seq_printf(m, "shared_processor_mode=%d\n", shared);
 
 	return 0;
 }
@@ -217,7 +149,7 @@ static int lparcfg_data(unsigned char *b
  *          XXXX - reserved (0)
  *              XXXX - Group Number
  *                  XXXX - Pool Number.
- *  R7 (PPOONNMMLLKKJJII)
+ *  R7 (IIJJKKLLMMNNOOPP).
  *      XX - reserved. (0)
  *        XX - bit 0-6 reserved (0).   bit 7 is Capped indicator.
  *          XX - variable processor Capacity Weight
@@ -225,168 +157,259 @@ static int lparcfg_data(unsigned char *b
  *              XXXX - Active processors in Physical Processor Pool.
  *                  XXXX  - Processors active on platform. 
  */
-unsigned int h_get_ppp(unsigned long *entitled,unsigned long  *unallocated,unsigned long *aggregation,unsigned long *resource)
+static unsigned int h_get_ppp(unsigned long *entitled,unsigned long  *unallocated,unsigned long *aggregation,unsigned long *resource)
 {
 	unsigned long rc;
 	rc = plpar_hcall_4out(H_GET_PPP,0,0,0,0,entitled,unallocated,aggregation,resource);
-	return 0;
+
+	log_plpar_hcall_return(rc,"H_GET_PPP");
+
+	return rc;
+}
+
+static void h_pic(unsigned long *pool_idle_time,unsigned long *num_procs)
+{
+	unsigned long rc;
+	unsigned long dummy;
+	rc = plpar_hcall(H_PIC,0,0,0,0,pool_idle_time,num_procs,&dummy);
+
+	log_plpar_hcall_return(rc,"H_PIC");
+}
+
+static unsigned long get_purr(void);
+/* get sum of purr across all processors.  if PPC_VPURR is not enabled, return zero. */
+/* this utilizes the existing functionality from vpurr.c */
+static unsigned long get_purr()
+{
+	unsigned long sum_purr=0;
+#ifdef CONFIG_PPC_VPURR	
+	int cpu;
+	struct cpu_util_store * cus;
+
+	for_each_online_cpu(cpu){
+		cus =   &per_cpu (cpu_util_sampler, cpu);
+		sum_purr += cus->current_purr;
+#ifdef PURR_DEBUG
+	printk(KERN_INFO "get_purr for cpu (%x) has value (%lx) \n",cpu,cus->current_purr);
+#endif
+                }
+#endif
+	return sum_purr;
 }
 
-/*
- * get_splpar_potential_characteristics().
- * Retrieve the potential_processors and max_entitled_capacity values
- * through the get-system-parameter rtas call.
- */
 #define SPLPAR_CHARACTERISTICS_TOKEN 20
 #define SPLPAR_MAXLENGTH 1026*(sizeof(char))
-unsigned int get_splpar_potential_characteristics(void)
+
+/*
+ * parse_system_parameter_string()
+ * Retrieve the potential_processors, max_entitled_capacity and friends 
+ * through the get-system-parameter rtas call.  Replace keyword strings as
+ * necessary.
+ */
+static void parse_system_parameter_string(struct seq_file *m)
 {
-	/* return 0 for now.  Underlying rtas functionality is not yet complete. 12/01/2003*/
-	return 0; 
-#if 0 
 	long call_status;
 	unsigned long ret[2];
 
-	char * buffer = kmalloc(SPLPAR_MAXLENGTH, GFP_KERNEL);
-
-	printk("token for ibm,get-system-parameter (0x%x)\n",rtas_token("ibm,get-system-parameter"));
+	char * local_buffer = kmalloc(SPLPAR_MAXLENGTH, GFP_KERNEL);
+	if (!local_buffer) {
+		printk(KERN_ERR "%s %s kmalloc failure at line %d \n",__FILE__,__FUNCTION__,__LINE__);
+		return;
+	}
 
+	spin_lock(&rtas_data_buf_lock);
+	memset(rtas_data_buf, 0, SPLPAR_MAXLENGTH); 
 	call_status = rtas_call(rtas_token("ibm,get-system-parameter"), 3, 1,
 				NULL,
 				SPLPAR_CHARACTERISTICS_TOKEN,
-				&buffer,
+				__pa(rtas_data_buf),
 				SPLPAR_MAXLENGTH,
 				(void *)&ret);
+	memcpy(local_buffer,rtas_data_buf, SPLPAR_MAXLENGTH);
+	spin_unlock(&rtas_data_buf_lock);
 
 	if (call_status!=0) {
-		printk("Error calling get-system-parameter (0x%lx)\n",call_status);
-		kfree(buffer);
-		return -1;
+		printk(KERN_INFO "%s %s Error calling get-system-parameter (0x%lx)\n",__FILE__,__FUNCTION__,call_status);
 	} else {
-		printk("get-system-parameter (%s)\n",buffer);
-		kfree(buffer);
-		/* TODO: Add code here to parse out value for system_potential_processors and partition_max_entitled_capacity */
-		return 1;
+		int splpar_strlen;
+		int idx,w_idx;
+		char * workbuffer = kmalloc(SPLPAR_MAXLENGTH, GFP_KERNEL);
+		if (!workbuffer) {
+			printk(KERN_ERR "%s %s kmalloc failure at line %d \n",__FILE__,__FUNCTION__,__LINE__);
+			return;
+		}
+
+#ifdef LPARCFG_DEBUG
+		printk(KERN_INFO "success calling get-system-parameter \n");
+#endif
+		splpar_strlen=local_buffer[0]*16+local_buffer[1];
+		local_buffer+=2; /* step over strlen value */
+
+		memset(workbuffer, 0, SPLPAR_MAXLENGTH);
+		w_idx=0; idx=0;
+		while ((*local_buffer) && (idx<splpar_strlen)) {
+			workbuffer[w_idx++]=local_buffer[idx++];
+			if ((local_buffer[idx]==',')||(local_buffer[idx]=='\0')) {
+				workbuffer[w_idx]='\0';
+				if (w_idx) /* avoid the empty string */
+				{
+					seq_printf(m, "%s\n",workbuffer);
+				}
+				memset(workbuffer, 0, SPLPAR_MAXLENGTH);
+				idx++; /* skip the comma */
+				w_idx=0;
+			} else if (local_buffer[idx]=='=') {
+				/* code here to replace workbuffer contents
+				 with different keyword strings */
+				if (0==strcmp(workbuffer,"MaxEntCap")) {
+					strcpy(workbuffer,"partition_max_entitled_capacity\0");
+					w_idx=strlen(workbuffer);
+				}
+				if (0==strcmp(workbuffer,"MaxPlatProcs")) {
+					strcpy(workbuffer,"system_potential_processors\0");
+					w_idx=strlen(workbuffer);
+				}
+			}
+		}
+		kfree(workbuffer);
+		local_buffer-=2; /* back up over strlen value */
 	}
+	kfree(local_buffer);
+	return;
+}
+
+static int lparcfg_count_active_processors(void);
+
+static int lparcfg_count_active_processors()
+{
+	struct device_node *cpus_dn = NULL;
+	int count=0;
+	for (cpus_dn = of_find_node_by_type(NULL, "cpu");
+		cpus_dn;
+		cpus_dn = of_find_node_by_type(cpus_dn, "cpu")) {
+#ifdef LPARCFG_DEBUG
+		printk(KERN_ERR "cpus_dn %p \n",cpus_dn);
 #endif
+		count++;
+		}
+	of_node_put(cpus_dn);
+	return count;
 }
 
-static int lparcfg_data(unsigned char *buf, unsigned long size)
+static int lparcfg_data(struct seq_file *m, void *v)
 {
-	unsigned long n = 0;
-	int shared, max_entitled_capacity;
-	int processors, system_active_processors, system_potential_processors;
-	struct device_node *root;
+	int system_active_processors;
+	struct device_node *rootdn;
 	const char *model = "";
 	const char *system_id = "";
 	unsigned int *lp_index_ptr, lp_index = 0;
 	struct device_node *rtas_node;
-	int *ip;
-	unsigned long h_entitled,h_unallocated,h_aggregation,h_resource;
+	int *lrdrp;
 
-	if((buf == NULL) || (size > LPARCFG_BUFF_SIZE)) {
-		return -EFAULT;
+	rootdn = find_path_device("/");
+	if (rootdn) {
+		model = get_property(rootdn, "model", NULL);
+		system_id = get_property(rootdn, "system-id", NULL);
+		lp_index_ptr = (unsigned int *)get_property(rootdn, "ibm,partition-no", NULL);
+		if (lp_index_ptr) lp_index = *lp_index_ptr;
 	}
-	memset(buf, 0, size); 
 
-	root = find_path_device("/");
-	if (root) {
-		model = get_property(root, "model", NULL);
-		system_id = get_property(root, "system-id", NULL);
-		lp_index_ptr = (unsigned int *)get_property(root, "ibm,partition-no", NULL);
-		if(lp_index_ptr) lp_index = *lp_index_ptr;
-	}
 
-	n  = scnprintf(buf, LPARCFG_BUFF_SIZE - n,
-		      "serial_number=%s\n", system_id); 
+	seq_printf(m,"%s %s \n",MODULE_NAME,MODULE_VERS);
+
+	seq_printf(m,"serial_number=%s\n", system_id); 
 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "system_type=%s\n", model); 
+	seq_printf(m,"system_type=%s\n", model); 
 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_id=%d\n", (int)lp_index); 
+	seq_printf(m,"partition_id=%d\n", (int)lp_index); 
 
 	rtas_node = find_path_device("/rtas");
-	ip = (int *)get_property(rtas_node, "ibm,lrdr-capacity", NULL);
-	if (ip == NULL) {
+	lrdrp = (int *)get_property(rtas_node, "ibm,lrdr-capacity", NULL);
+
+	if (lrdrp == NULL) {
 		system_active_processors = systemcfg->processorCount; 
 	} else {
-		system_active_processors = *(ip + 4);
-	}
+		system_active_processors = *(lrdrp + 4);
+	} 
 
 	if (cur_cpu_spec->firmware_features & FW_FEATURE_SPLPAR) {
+		unsigned long h_entitled,h_unallocated,h_aggregation,h_resource;
+		unsigned long pool_idle_time,pool_procs;
+		unsigned long purr;
+
 		h_get_ppp(&h_entitled,&h_unallocated,&h_aggregation,&h_resource);
-#ifdef DEBUG
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "R4=0x%lx\n", h_entitled);
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "R5=0x%lx\n", h_unallocated);
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "R6=0x%lx\n", h_aggregation);
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "R7=0x%lx\n", h_resource);
-#endif /* DEBUG */
-	}
 
-	if (cur_cpu_spec->firmware_features & FW_FEATURE_SPLPAR) {
-		system_potential_processors =  get_splpar_potential_characteristics();
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "system_active_processors=%ld\n", 
+		seq_printf(m, "R4=0x%lx\n", h_entitled);
+		seq_printf(m, "R5=0x%lx\n", h_unallocated);
+		seq_printf(m, "R6=0x%lx\n", h_aggregation);
+		seq_printf(m, "R7=0x%lx\n", h_resource);
+
+		h_pic(&pool_idle_time,&pool_procs);
+
+		purr = get_purr();
+
+		/* this call handles the ibm,get-system-parameter contents */
+		parse_system_parameter_string(m);
+
+		seq_printf(m, "partition_entitled_capacity=%ld\n",
+			      h_entitled);
+
+		seq_printf(m, "pool=%ld\n",
+			      (h_aggregation >> 0*8) & 0xffff);
+
+		seq_printf(m, "group=%ld\n",
+			      (h_aggregation >> 2*8) & 0xffff);
+
+		seq_printf(m, "system_active_processors=%ld\n", 
 			      (h_resource >> 2*8) & 0xffff);
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "system_potential_processors=%d\n", 
-			      system_potential_processors);
-	} else {
-		system_potential_processors = system_active_processors;
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "system_active_processors=%d\n", 
-			      system_active_processors);
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "system_potential_processors=%d\n", 
-			      system_potential_processors);
-	}
 
-	processors = systemcfg->processorCount;
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_active_processors=%d\n", processors);  
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_potential_processors=%d\n",
-		      system_active_processors);
+		seq_printf(m, "pool_capacity=%ld\n",
+			      (h_resource >> 3*8) & 0xffff);
 
-	/* max_entitled_capacity will come out of get_splpar_potential_characteristics() when that function is complete */
-	max_entitled_capacity = system_active_processors * 100; 
-	if (cur_cpu_spec->firmware_features & FW_FEATURE_SPLPAR) {
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "partition_entitled_capacity=%ld\n", h_entitled);
-	} else {
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "partition_entitled_capacity=%d\n", system_active_processors*100);
-	}
+		seq_printf(m, "capacity_weight=%ld\n",
+			      (h_resource>>5*8) & 0xFF);
 
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "partition_max_entitled_capacity=%d\n", 
-		      max_entitled_capacity);
+		seq_printf(m, "capped=%ld\n",
+			      (h_resource >> 6*8) & 0x40);
 
-	shared = 0;
-	n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-		      "shared_processor_mode=%d\n", shared);
+		seq_printf(m, "unallocated_variable_weight=%ld\n",
+			      (h_resource>>7*8) & 0xFF);
 
-	if (cur_cpu_spec->firmware_features & FW_FEATURE_SPLPAR) {
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "pool=%ld\n", (h_aggregation >> 0*8)&0xffff);
+		seq_printf(m, "unallocated_capacity=%ld\n",
+			      h_unallocated);
 
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "pool_capacity=%ld\n", (h_resource >> 3*8) &0xffff);
+		seq_printf(m, "pool_idle_time=%ld\n",
+			      pool_idle_time);
 
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "group=%ld\n", (h_aggregation >> 2*8)&0xffff);
+		seq_printf(m, "pool_num_procs=%ld\n",
+			      pool_procs);
+
+		seq_printf(m, "purr=%ld\n",
+			      purr);
+
+	} else /* non SPLPAR case */ {
+		seq_printf(m, "system_active_processors=%d\n",
+			      system_active_processors);
+
+		seq_printf(m, "system_potential_processors=%d\n",
+			      system_active_processors);
 
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "capped=%ld\n", (h_resource >> 6*8)&0x40);
+		seq_printf(m, "partition_max_entitled_capacity=%d\n",
+			      100*system_active_processors);
 
-		n += scnprintf(buf+n, LPARCFG_BUFF_SIZE - n,
-			      "capacity_weight=%d\n", (int)(h_resource>>5*8)&0xFF);
+		seq_printf(m, "partition_entitled_capacity=%d\n",
+			      system_active_processors*100);
 	}
+
+	seq_printf(m, "partition_active_processors=%d\n",
+			(int) lparcfg_count_active_processors());
+
+	seq_printf(m, "partition_potential_processors=%d\n",
+			system_active_processors);
+
+	seq_printf(m, "shared_processor_mode=%d\n",
+			paca[0].xLpPaca.xSharedProc);
+
 	return 0;
 }
 
@@ -484,58 +507,16 @@ out:
 
 #endif /* CONFIG_PPC_PSERIES */
 
-
-static ssize_t lparcfg_read(struct file *file, char *buf,
-			    size_t count, loff_t *ppos)
-{
-	struct proc_dir_entry *dp = PDE(file->f_dentry->d_inode);
-	unsigned long *data = (unsigned long *)dp->data;
-	unsigned long p;
-	ssize_t read;
-	char * pnt;
-
-	if (!data) {
-		printk(KERN_ERR "lparcfg: read failed no data\n");
-		return -EIO;
-	}
-
-	if(ppos) {
-		p = *ppos;
-	} else {
-		return -EFAULT;
-	}
-
-	if (p >= LPARCFG_BUFF_SIZE) return 0;
-
-	lparcfg_data((unsigned char *)data, LPARCFG_BUFF_SIZE); 
-	if (count > (strlen((char *)data) - p))
-		count = (strlen((char *)data)) - p;
-	read = 0;
-
-	pnt = (char *)(data) + p;
-	copy_to_user(buf, (void *)pnt, count);
-	read += count;
-	*ppos += read;
-	return read;
-}
-
 static int lparcfg_open(struct inode * inode, struct file * file)
 {
-	struct proc_dir_entry *dp = PDE(file->f_dentry->d_inode);
-	unsigned int *data = (unsigned int *)dp->data;
-
-	if (!data) {
-		printk(KERN_ERR "lparcfg: open failed no data\n");
-		return -EIO;
-	}
-
-	return 0;
+	return single_open(file,lparcfg_data,NULL);
 }
 
 struct file_operations lparcfg_fops = {
 	owner:		THIS_MODULE,
-	read:		lparcfg_read,
+	read:		seq_read,
 	open:		lparcfg_open,
+	release:	single_release,
 };
 
 int __init lparcfg_init(void)
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/open_pic_u3.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/open_pic_u3.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/open_pic_u3.c	2004-02-12 03:47:52.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/open_pic_u3.c	2004-02-26 10:56:03.000000000 +0000
@@ -251,6 +251,14 @@ static inline void openpic2_set_sense(u_
 				 (sense ? OPENPIC_SENSE_LEVEL : 0));
 }
 
+#if 0	/* not used */
+static int openpic2_get_sense(u_int irq)
+{
+	return openpic2_readfield(&GET_ISU(irq).Vector_Priority,
+				  OPENPIC_SENSE_LEVEL) != 0;
+}
+#endif
+
 static void openpic2_end_irq(unsigned int irq_nr)
 {
 	openpic2_eoi();
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/pSeries_iommu.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/pSeries_iommu.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/pSeries_iommu.c	2004-04-12 17:54:09.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/pSeries_iommu.c	2004-04-13 03:00:57.000000000 +0000
@@ -211,6 +211,7 @@ static void iommu_table_setparms(struct 
 	tbl->it_index = 0;
 	tbl->it_entrysize = sizeof(union tce_entry);
 	tbl->it_blocksize = 16;
+	tbl->it_type = TCE_PCI;
 }
 
 /*
@@ -246,6 +247,7 @@ static void iommu_table_setparms_lpar(st
 	tbl->it_index  = dma_window[0];
 	tbl->it_entrysize = sizeof(union tce_entry);
 	tbl->it_blocksize  = 16;
+	tbl->it_type = TCE_PCI;
 }
 
 
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/process.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/process.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/process.c	2004-04-22 08:40:31.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/process.c	2004-04-24 05:42:08.000000000 +0000
@@ -65,9 +65,6 @@ struct mm_struct ioremap_mm = {
 	.page_table_lock = SPIN_LOCK_UNLOCKED,
 };
 
-char *sysmap = NULL;
-unsigned long sysmap_size = 0;
-
 void enable_kernel_fp(void)
 {
 #ifdef CONFIG_SMP
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/prom.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/prom.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/prom.c	2004-04-16 16:00:53.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/prom.c	2004-04-24 05:42:58.000000000 +0000
@@ -32,6 +32,7 @@
 #include <linux/proc_fs.h>
 #include <linux/stringify.h>
 #include <linux/delay.h>
+#include <linux/initrd.h>
 #include <asm/prom.h>
 #include <asm/rtas.h>
 #include <asm/lmb.h>
@@ -123,12 +124,7 @@ struct pci_intr_map {
 
 
 typedef unsigned long interpret_func(struct device_node *, unsigned long,
-				     int, int);
-static interpret_func interpret_pci_props;
-static interpret_func interpret_isa_props;
-static interpret_func interpret_root_props;
-static interpret_func interpret_dbdma_props;
-static interpret_func interpret_macio_props;
+				     int, int, int);
 
 #ifndef FB_MAX			/* avoid pulling in all of the fb stuff */
 #define FB_MAX	8
@@ -142,6 +138,9 @@ phandle prom_display_nodes[FB_MAX] __ini
 unsigned int prom_num_displays = 0;
 char *of_stdout_device = 0;
 
+static int iommu_force_on;
+int ppc64_iommu_off;
+
 extern struct rtas_t rtas;
 extern unsigned long klimit;
 extern struct lmb lmb;
@@ -161,29 +160,6 @@ struct device_node *allnodes = 0;
  */
 static rwlock_t devtree_lock = RW_LOCK_UNLOCKED;
 
-static unsigned long call_prom(const char *service, int nargs, int nret, ...);
-static void prom_panic(const char *reason);
-static unsigned long copy_device_tree(unsigned long);
-static unsigned long inspect_node(phandle, struct device_node *, unsigned long,
-				  unsigned long, struct device_node ***);
-static unsigned long finish_node(struct device_node *, unsigned long,
-				 interpret_func *, int, int);
-static unsigned long finish_node_interrupts(struct device_node *, unsigned long);
-static unsigned long check_display(unsigned long);
-static int prom_next_node(phandle *);
-static struct bi_record * prom_bi_rec_verify(struct bi_record *);
-static unsigned long prom_bi_rec_reserve(unsigned long);
-static struct device_node *find_phandle(phandle);
-static void of_node_cleanup(struct device_node *);
-static struct device_node *derive_parent(const char *);
-static void add_node_proc_entries(struct device_node *);
-static void remove_node_proc_entries(struct device_node *);
-static int of_finish_dynamic_node(struct device_node *);
-
-#ifdef DEBUG_PROM
-void prom_dump_lmb(void);
-#endif
-
 extern unsigned long reloc_offset(void);
 
 extern void enter_prom(struct prom_args *args);
@@ -208,8 +184,9 @@ char testString[] = "LINUX\n"; 
  * mode when we do.  We switch back to 64b mode upon return.
  */
 
-static unsigned long __init
-call_prom(const char *service, int nargs, int nret, ...)
+#define PROM_ERROR	(0x00000000fffffffful)
+
+static unsigned long __init call_prom(const char *service, int nargs, int nret, ...)
 {
 	int i;
 	unsigned long offset = reloc_offset();
@@ -235,30 +212,7 @@ call_prom(const char *service, int nargs
 }
 
 
-static void __init
-prom_panic(const char *reason)
-{
-	unsigned long offset = reloc_offset();
-
-	prom_print(reason);
-	/* ToDo: should put up an SRC here */
-	call_prom(RELOC("exit"), 0, 0);
-
-	for (;;)			/* should never get here */
-		;
-}
-
-void __init
-prom_enter(void)
-{
-	unsigned long offset = reloc_offset();
-
-	call_prom(RELOC("enter"), 0, 0);
-}
-
-
-void __init
-prom_print(const char *msg)
+static void __init prom_print(const char *msg)
 {
 	const char *p, *q;
 	unsigned long offset = reloc_offset();
@@ -281,8 +235,8 @@ prom_print(const char *msg)
 	}
 }
 
-void
-prom_print_hex(unsigned long val)
+
+static void __init prom_print_hex(unsigned long val)
 {
         int i, nibbles = sizeof(val)*2;
         char buf[sizeof(val)*2+1];
@@ -297,16 +251,47 @@ prom_print_hex(unsigned long val)
 	prom_print(buf);
 }
 
-void
-prom_print_nl(void)
+
+static void __init prom_print_nl(void)
 {
 	unsigned long offset = reloc_offset();
 	prom_print(RELOC("\n"));
 }
 
 
-static unsigned long
-prom_initialize_naca(unsigned long mem)
+static void __init prom_panic(const char *reason)
+{
+	unsigned long offset = reloc_offset();
+
+	prom_print(reason);
+	/* ToDo: should put up an SRC here */
+	call_prom(RELOC("exit"), 0, 0);
+
+	for (;;)			/* should never get here */
+		;
+}
+
+
+static int __init prom_next_node(phandle *nodep)
+{
+	phandle node;
+	unsigned long offset = reloc_offset();
+
+	if ((node = *nodep) != 0
+	    && (*nodep = call_prom(RELOC("child"), 1, 1, node)) != 0)
+		return 1;
+	if ((*nodep = call_prom(RELOC("peer"), 1, 1, node)) != 0)
+		return 1;
+	for (;;) {
+		if ((node = call_prom(RELOC("parent"), 1, 1, node)) == 0)
+			return 0;
+		if ((*nodep = call_prom(RELOC("peer"), 1, 1, node)) != 0)
+			return 1;
+	}
+}
+
+
+static void __init prom_initialize_naca(void)
 {
 	phandle node;
 	char type[64];
@@ -521,14 +506,10 @@ prom_initialize_naca(unsigned long mem)
 
 	prom_print(RELOC("prom_initialize_naca: end...\n"));
 #endif
-
-	return mem;
 }
 
-static int iommu_force_on;
-int ppc64_iommu_off;
 
-static void early_cmdline_parse(void)
+static void __init early_cmdline_parse(void)
 {
 	unsigned long offset = reloc_offset();
 	char *opt;
@@ -558,8 +539,58 @@ static void early_cmdline_parse(void)
 #endif
 }
 
-static unsigned long __init
-prom_initialize_lmb(unsigned long mem)
+#ifdef DEBUG_PROM
+void prom_dump_lmb(void)
+{
+        unsigned long i;
+        unsigned long offset = reloc_offset();
+	struct lmb *_lmb  = PTRRELOC(&lmb);
+
+        prom_print(RELOC("\nprom_dump_lmb:\n"));
+        prom_print(RELOC("    memory.cnt                  = 0x"));
+        prom_print_hex(_lmb->memory.cnt);
+	prom_print_nl();
+        prom_print(RELOC("    memory.size                 = 0x"));
+        prom_print_hex(_lmb->memory.size);
+	prom_print_nl();
+        for (i=0; i < _lmb->memory.cnt ;i++) {
+                prom_print(RELOC("    memory.region[0x"));
+		prom_print_hex(i);
+		prom_print(RELOC("].base       = 0x"));
+                prom_print_hex(_lmb->memory.region[i].base);
+		prom_print_nl();
+                prom_print(RELOC("                      .physbase = 0x"));
+                prom_print_hex(_lmb->memory.region[i].physbase);
+		prom_print_nl();
+                prom_print(RELOC("                      .size     = 0x"));
+                prom_print_hex(_lmb->memory.region[i].size);
+		prom_print_nl();
+        }
+
+	prom_print_nl();
+        prom_print(RELOC("    reserved.cnt                  = 0x"));
+        prom_print_hex(_lmb->reserved.cnt);
+	prom_print_nl();
+        prom_print(RELOC("    reserved.size                 = 0x"));
+        prom_print_hex(_lmb->reserved.size);
+	prom_print_nl();
+        for (i=0; i < _lmb->reserved.cnt ;i++) {
+                prom_print(RELOC("    reserved.region[0x"));
+		prom_print_hex(i);
+		prom_print(RELOC("].base       = 0x"));
+                prom_print_hex(_lmb->reserved.region[i].base);
+		prom_print_nl();
+                prom_print(RELOC("                      .physbase = 0x"));
+                prom_print_hex(_lmb->reserved.region[i].physbase);
+		prom_print_nl();
+                prom_print(RELOC("                      .size     = 0x"));
+                prom_print_hex(_lmb->reserved.region[i].size);
+		prom_print_nl();
+        }
+}
+#endif /* DEBUG_PROM */
+
+static void __init prom_initialize_lmb(void)
 {
 	phandle node;
 	char type[64];
@@ -621,8 +652,6 @@ prom_initialize_lmb(unsigned long mem)
 #ifdef DEBUG_PROM
 	prom_dump_lmb();
 #endif /* DEBUG_PROM */
-
-	return mem;
 }
 
 static char hypertas_funcs[1024];
@@ -642,13 +671,15 @@ prom_instantiate_rtas(void)
 #endif
 	prom_rtas = (ihandle)call_prom(RELOC("finddevice"), 1, 1, RELOC("/rtas"));
 	if (prom_rtas != (ihandle) -1) {
-		int  rc; 
-		
-		if ((rc = call_prom(RELOC("getprop"), 
+		unsigned long x;
+		x = call_prom(RELOC("getprop"), 
 				  4, 1, prom_rtas,
 				  RELOC("ibm,hypertas-functions"), 
 				  hypertas_funcs, 
-				  sizeof(hypertas_funcs))) > 0) {
+			      sizeof(hypertas_funcs));
+
+		if (x != PROM_ERROR) {
+			prom_print(RELOC("Hypertas detected, assuming LPAR !\n"));
 			_systemcfg->platform = PLATFORM_PSERIES_LPAR;
 		}
 
@@ -670,6 +701,7 @@ prom_instantiate_rtas(void)
 				struct lmb *_lmb  = PTRRELOC(&lmb);
 				rtas_region = min(_lmb->rmo_size, RTAS_INSTANTIATE_MAX);
 			}
+
 			_rtas->base = lmb_alloc_base(_rtas->size, PAGE_SIZE, rtas_region);
 
 			prom_print(RELOC(" at 0x"));
@@ -679,10 +711,10 @@ prom_instantiate_rtas(void)
 					      	1, 1, RELOC("/rtas"));
 			prom_print(RELOC("..."));
 
-			if ((long)call_prom(RELOC("call-method"), 3, 2,
+			if (call_prom(RELOC("call-method"), 3, 2,
 						      RELOC("instantiate-rtas"),
 						      prom_rtas,
-						      _rtas->base) >= 0) {
+						      _rtas->base) != PROM_ERROR) {
 				_rtas->entry = (long)_prom->args.rets[1];
 			}
 			RELOC(rtas_rmo_buf)
@@ -713,74 +745,9 @@ prom_instantiate_rtas(void)
 #endif
 }
 
-unsigned long prom_strtoul(const char *cp)
-{
-	unsigned long result = 0,value;
-
-	while (*cp) {
-		value = *cp-'0';
-		result = result*10 + value;
-		cp++;
-	} 
-
-	return result;
-}
-
-#ifdef DEBUG_PROM
-void
-prom_dump_lmb(void)
-{
-        unsigned long i;
-        unsigned long offset = reloc_offset();
-	struct lmb *_lmb  = PTRRELOC(&lmb);
-
-        prom_print(RELOC("\nprom_dump_lmb:\n"));
-        prom_print(RELOC("    memory.cnt                  = 0x"));
-        prom_print_hex(_lmb->memory.cnt);
-	prom_print_nl();
-        prom_print(RELOC("    memory.size                 = 0x"));
-        prom_print_hex(_lmb->memory.size);
-	prom_print_nl();
-        for (i=0; i < _lmb->memory.cnt ;i++) {
-                prom_print(RELOC("    memory.region[0x"));
-		prom_print_hex(i);
-		prom_print(RELOC("].base       = 0x"));
-                prom_print_hex(_lmb->memory.region[i].base);
-		prom_print_nl();
-                prom_print(RELOC("                      .physbase = 0x"));
-                prom_print_hex(_lmb->memory.region[i].physbase);
-		prom_print_nl();
-                prom_print(RELOC("                      .size     = 0x"));
-                prom_print_hex(_lmb->memory.region[i].size);
-		prom_print_nl();
-        }
-
-	prom_print_nl();
-        prom_print(RELOC("    reserved.cnt                  = 0x"));
-        prom_print_hex(_lmb->reserved.cnt);
-	prom_print_nl();
-        prom_print(RELOC("    reserved.size                 = 0x"));
-        prom_print_hex(_lmb->reserved.size);
-	prom_print_nl();
-        for (i=0; i < _lmb->reserved.cnt ;i++) {
-                prom_print(RELOC("    reserved.region[0x"));
-		prom_print_hex(i);
-		prom_print(RELOC("].base       = 0x"));
-                prom_print_hex(_lmb->reserved.region[i].base);
-		prom_print_nl();
-                prom_print(RELOC("                      .physbase = 0x"));
-                prom_print_hex(_lmb->reserved.region[i].physbase);
-		prom_print_nl();
-                prom_print(RELOC("                      .size     = 0x"));
-                prom_print_hex(_lmb->reserved.region[i].size);
-		prom_print_nl();
-        }
-}
-#endif /* DEBUG_PROM */
-
 
 #ifdef CONFIG_PMAC_DART
-void prom_initialize_dart_table(void)
+static void __init prom_initialize_dart_table(void)
 {
 	unsigned long offset = reloc_offset();
 	extern unsigned long dart_tablebase;
@@ -797,7 +764,7 @@ void prom_initialize_dart_table(void)
 	/* 16MB (1 << 24) alignment. We allocate a full 16Mb chuck since we
 	 * will blow up an entire large page anyway in the kernel mapping
 	 */
-	RELOC(dart_tablebase) =
+	RELOC(dart_tablebase) = (unsigned long)
 		abs_to_virt(lmb_alloc_base(1UL<<24, 1UL<<24, 0x80000000L));
 
 	prom_print(RELOC("Dart at: "));
@@ -806,9 +773,7 @@ void prom_initialize_dart_table(void)
 }
 #endif /* CONFIG_PMAC_DART */
 
-
-void
-prom_initialize_tce_table(void)
+static void __init prom_initialize_tce_table(void)
 {
 	phandle node;
 	ihandle phb_node;
@@ -864,13 +829,13 @@ prom_initialize_tce_table(void)
 
 		if (call_prom(RELOC("getprop"), 4, 1, node, 
 			     RELOC("tce-table-minalign"), &minalign, 
-			     sizeof(minalign)) < 0) {
+			     sizeof(minalign)) == PROM_ERROR) {
 			minalign = 0;
 		}
 
 		if (call_prom(RELOC("getprop"), 4, 1, node, 
 			     RELOC("tce-table-minsize"), &minsize, 
-			     sizeof(minsize)) < 0) {
+			     sizeof(minsize)) == PROM_ERROR) {
 			minsize = 4UL << 20;
 		}
 
@@ -939,7 +904,7 @@ prom_initialize_tce_table(void)
 		memset(path, 0, sizeof(path));
 		/* Call OF to setup the TCE hardware */
 		if (call_prom(RELOC("package-to-path"), 3, 1, node,
-                             path, sizeof(path)-1) <= 0) {
+                             path, sizeof(path)-1) == PROM_ERROR) {
                         prom_print(RELOC("package-to-path failed\n"));
                 } else {
                         prom_print(RELOC("opening PHB "));
@@ -992,8 +957,7 @@ prom_initialize_tce_table(void)
  *
  * -- Cort
  */
-static void
-prom_hold_cpus(unsigned long mem)
+static void __init prom_hold_cpus(unsigned long mem)
 {
 	unsigned long i;
 	unsigned int reg;
@@ -1103,7 +1067,7 @@ prom_hold_cpus(unsigned long mem)
 		path = (char *) mem;
 		memset(path, 0, 256);
 		if ((long) call_prom(RELOC("package-to-path"), 3, 1,
-				     node, path, 255) < 0)
+				     node, path, 255) == PROM_ERROR)
 			continue;
 
 #ifdef DEBUG_PROM
@@ -1249,8 +1213,7 @@ next:
 #endif
 }
 
-static void
-smt_setup(void)
+static void __init smt_setup(void)
 {
 	char *p, *q;
 	char my_smt_enabled = SMT_DYNAMIC;
@@ -1441,222 +1404,56 @@ static int __init prom_find_machine_type
 	return PLATFORM_PSERIES;
 }
 
-/*
- * We enter here early on, when the Open Firmware prom is still
- * handling exceptions and the MMU hash table for us.
- */
-
-unsigned long __init
-prom_init(unsigned long r3, unsigned long r4, unsigned long pp,
-	  unsigned long r6, unsigned long r7)
+static int __init prom_set_color(ihandle ih, int i, int r, int g, int b)
 {
-	unsigned long mem;
-	ihandle prom_cpu;
-	phandle cpu_pkg;
 	unsigned long offset = reloc_offset();
-	long l;
-	char *p, *d;
-	unsigned long phys;
-	u32 getprop_rval;
-	struct systemcfg *_systemcfg;
-	struct paca_struct *_xPaca = PTRRELOC(&paca[0]);
-	struct prom_t *_prom = PTRRELOC(&prom);
-
-	/* First zero the BSS -- use memset, some arches don't have
-	 * caches on yet */
-	memset(PTRRELOC(&__bss_start), 0, __bss_stop - __bss_start);
-
-	/* Setup systemcfg and NACA pointers now */
-	RELOC(systemcfg) = _systemcfg = (struct systemcfg *)(SYSTEMCFG_VIRT_ADDR - offset);
-	RELOC(naca) = (struct naca_struct *)(NACA_VIRT_ADDR - offset);
 
-	/* Init interface to Open Firmware and pickup bi-recs */
-	prom_init_client_services(pp);
+	return (int)(long)call_prom(RELOC("call-method"), 6, 1,
+		                    RELOC("color!"),
+                                    ih,
+                                    (void *)(long) i,
+                                    (void *)(long) b,
+                                    (void *)(long) g,
+                                    (void *)(long) r );
+}
 
-	/* Init prom stdout device */
-	prom_init_stdout();
+/*
+ * If we have a display that we don't know how to drive,
+ * we will want to try to execute OF's open method for it
+ * later.  However, OF will probably fall over if we do that
+ * we've taken over the MMU.
+ * So we check whether we will need to open the display,
+ * and if so, open it now.
+ */
+static unsigned long __init check_display(unsigned long mem)
+{
+	phandle node;
+	ihandle ih;
+	int i, j;
+	unsigned long offset = reloc_offset();
+        struct prom_t *_prom = PTRRELOC(&prom);
+	char type[16], *path;
+	static unsigned char default_colors[] = {
+		0x00, 0x00, 0x00,
+		0x00, 0x00, 0xaa,
+		0x00, 0xaa, 0x00,
+		0x00, 0xaa, 0xaa,
+		0xaa, 0x00, 0x00,
+		0xaa, 0x00, 0xaa,
+		0xaa, 0xaa, 0x00,
+		0xaa, 0xaa, 0xaa,
+		0x55, 0x55, 0x55,
+		0x55, 0x55, 0xff,
+		0x55, 0xff, 0x55,
+		0x55, 0xff, 0xff,
+		0xff, 0x55, 0x55,
+		0xff, 0x55, 0xff,
+		0xff, 0xff, 0x55,
+		0xff, 0xff, 0xff
+	};
+	const unsigned char *clut;
 
-	/* check out if we have bi_recs */
-	_prom->bi_recs = prom_bi_rec_verify((struct bi_record *)r6);
-	if ( _prom->bi_recs != NULL )
-		RELOC(klimit) = PTRUNRELOC((unsigned long)_prom->bi_recs +
-					   _prom->bi_recs->data[1]);
-
-	/* Default machine type. */
-	_systemcfg->platform = prom_find_machine_type();
-
-	/* On pSeries, copy the CPU hold code */
-	if (_systemcfg->platform == PLATFORM_PSERIES)
-		copy_and_flush(0, KERNELBASE - offset, 0x100, 0);
-
-	/* Start storing things at klimit */
-      	mem = RELOC(klimit) - offset; 
-
-	/* Get the full OF pathname of the stdout device */
-	p = (char *) mem;
-	memset(p, 0, 256);
-	call_prom(RELOC("instance-to-path"), 3, 1, _prom->stdout, p, 255);
-	RELOC(of_stdout_device) = PTRUNRELOC(p);
-	mem += strlen(p) + 1;
-
-	getprop_rval = 1;
-	call_prom(RELOC("getprop"), 4, 1,
-		  _prom->root, RELOC("#size-cells"),
-		  &getprop_rval, sizeof(getprop_rval));
-	_prom->encode_phys_size = (getprop_rval == 1) ? 32 : 64;
-
-	/* Determine which cpu is actually running right _now_ */
-        if ((long)call_prom(RELOC("getprop"), 4, 1, _prom->chosen,
-			    RELOC("cpu"), &getprop_rval,
-			    sizeof(getprop_rval)) <= 0)
-                prom_panic(RELOC("cannot find boot cpu"));
-
-	prom_cpu = (ihandle)(unsigned long)getprop_rval;
-	cpu_pkg = call_prom(RELOC("instance-to-package"), 1, 1, prom_cpu);
-	call_prom(RELOC("getprop"), 4, 1,
-		cpu_pkg, RELOC("reg"),
-		&getprop_rval, sizeof(getprop_rval));
-	_prom->cpu = (int)(unsigned long)getprop_rval;
-	_xPaca[0].xHwProcNum = _prom->cpu;
-
-	RELOC(boot_cpuid) = 0;
-
-#ifdef DEBUG_PROM
-  	prom_print(RELOC("Booting CPU hw index = 0x"));
-  	prom_print_hex(_prom->cpu);
-  	prom_print_nl();
-#endif
-
-	/* Get the boot device and translate it to a full OF pathname. */
-	p = (char *) mem;
-	l = (long) call_prom(RELOC("getprop"), 4, 1, _prom->chosen,
-			    RELOC("bootpath"), p, 1<<20);
-	if (l > 0) {
-		p[l] = 0;	/* should already be null-terminated */
-		RELOC(bootpath) = PTRUNRELOC(p);
-		mem += l + 1;
-		d = (char *) mem;
-		*d = 0;
-		call_prom(RELOC("canon"), 3, 1, p, d, 1<<20);
-		RELOC(bootdevice) = PTRUNRELOC(d);
-		mem = DOUBLEWORD_ALIGN(mem + strlen(d) + 1);
-	}
-
-	RELOC(cmd_line[0]) = 0;
-	if ((long)_prom->chosen > 0) {
-		call_prom(RELOC("getprop"), 4, 1, _prom->chosen, 
-			  RELOC("bootargs"), p, sizeof(cmd_line));
-		if (p != NULL && p[0] != 0)
-			strlcpy(RELOC(cmd_line), p, sizeof(cmd_line));
-	}
-
-	early_cmdline_parse();
-
-	mem = prom_initialize_lmb(mem);
-
-	mem = prom_bi_rec_reserve(mem);
-
-	mem = check_display(mem);
-
-	if (_systemcfg->platform != PLATFORM_POWERMAC)
-		prom_instantiate_rtas();
-        
-        /* Initialize some system info into the Naca early... */
-        mem = prom_initialize_naca(mem);
-
-	smt_setup();
-	
-        /* If we are on an SMP machine, then we *MUST* do the
-         * following, regardless of whether we have an SMP
-         * kernel or not.
-         */
-	prom_hold_cpus(mem);
-
-#ifdef DEBUG_PROM
-	prom_print(RELOC("copying OF device tree...\n"));
-#endif
-	mem = copy_device_tree(mem);
-
-	RELOC(klimit) = mem + offset;
-
-	lmb_reserve(0, __pa(RELOC(klimit)));
-
-	if (_systemcfg->platform == PLATFORM_PSERIES)
-		prom_initialize_tce_table();
-
-#ifdef CONFIG_PMAC_DART
-	if (_systemcfg->platform == PLATFORM_POWERMAC)
-		prom_initialize_dart_table();
-#endif
-
-#ifdef CONFIG_BOOTX_TEXT
-	if(_prom->disp_node) {
-		prom_print(RELOC("Setting up bi display...\n"));
-		setup_disp_fake_bi(_prom->disp_node);
-	}
-#endif /* CONFIG_BOOTX_TEXT */
-
-	prom_print(RELOC("Calling quiesce ...\n"));
-	call_prom(RELOC("quiesce"), 0, 0);
-	phys = KERNELBASE - offset;
-
-	prom_print(RELOC("returning from prom_init\n"));
-	return phys;
-}
-
-
-static int
-prom_set_color(ihandle ih, int i, int r, int g, int b)
-{
-	unsigned long offset = reloc_offset();
-
-	return (int)(long)call_prom(RELOC("call-method"), 6, 1,
-		                    RELOC("color!"),
-                                    ih,
-                                    (void *)(long) i,
-                                    (void *)(long) b,
-                                    (void *)(long) g,
-                                    (void *)(long) r );
-}
-
-/*
- * If we have a display that we don't know how to drive,
- * we will want to try to execute OF's open method for it
- * later.  However, OF will probably fall over if we do that
- * we've taken over the MMU.
- * So we check whether we will need to open the display,
- * and if so, open it now.
- */
-static unsigned long __init
-check_display(unsigned long mem)
-{
-	phandle node;
-	ihandle ih;
-	int i, j;
-	unsigned long offset = reloc_offset();
-        struct prom_t *_prom = PTRRELOC(&prom);
-	char type[16], *path;
-	static unsigned char default_colors[] = {
-		0x00, 0x00, 0x00,
-		0x00, 0x00, 0xaa,
-		0x00, 0xaa, 0x00,
-		0x00, 0xaa, 0xaa,
-		0xaa, 0x00, 0x00,
-		0xaa, 0x00, 0xaa,
-		0xaa, 0xaa, 0x00,
-		0xaa, 0xaa, 0xaa,
-		0x55, 0x55, 0x55,
-		0x55, 0x55, 0xff,
-		0x55, 0xff, 0x55,
-		0x55, 0xff, 0xff,
-		0xff, 0x55, 0x55,
-		0xff, 0x55, 0xff,
-		0xff, 0xff, 0x55,
-		0xff, 0xff, 0xff
-	};
-	const unsigned char *clut;
-
-	_prom->disp_node = 0;
+	_prom->disp_node = 0;
 
 	prom_print(RELOC("Looking for displays\n"));
 	if (RELOC(of_stdout_device) != 0) {
@@ -1742,52 +1539,44 @@ check_display(unsigned long mem)
 	return DOUBLEWORD_ALIGN(mem);
 }
 
-
-static int __init
-prom_next_node(phandle *nodep)
+/* Return (relocated) pointer to this much memory: moves initrd if reqd. */
+static void __init *__make_room(unsigned long *mem_start, unsigned long *mem_end,
+				unsigned long needed, unsigned long align)
 {
-	phandle node;
+	void *ret;
 	unsigned long offset = reloc_offset();
 
-	if ((node = *nodep) != 0
-	    && (*nodep = call_prom(RELOC("child"), 1, 1, node)) != 0)
-		return 1;
-	if ((*nodep = call_prom(RELOC("peer"), 1, 1, node)) != 0)
-		return 1;
-	for (;;) {
-		if ((node = call_prom(RELOC("parent"), 1, 1, node)) == 0)
-			return 0;
-		if ((*nodep = call_prom(RELOC("peer"), 1, 1, node)) != 0)
-			return 1;
-	}
-}
+	*mem_start = ALIGN(*mem_start, align);
+	if (*mem_start + needed > *mem_end) {
+		/* FIXME: Apple OF doesn't map unclaimed mem.  If this
+		 * ever happened on G5, we'd need to fix. */
+		unsigned long initrd_len;
 
-/*
- * Make a copy of the device tree from the PROM.
- */
-static unsigned long __init
-copy_device_tree(unsigned long mem_start)
-{
-	phandle root;
-	unsigned long new_start;
-	struct device_node **allnextp;
-	unsigned long offset = reloc_offset();
-	unsigned long mem_end = mem_start + (8<<20);
+		if (*mem_end != RELOC(initrd_start))
+			prom_panic(RELOC("No memory for copy_device_tree"));
 
-	root = call_prom(RELOC("peer"), 1, 1, (phandle)0);
-	if (root == (phandle)0) {
-		prom_panic(RELOC("couldn't get device tree root\n"));
+		prom_print("Huge device_tree: moving initrd\n");
+		/* Move by 4M. */
+		initrd_len = RELOC(initrd_end) - RELOC(initrd_start);
+		*mem_end = RELOC(initrd_start) + 4 * 1024 * 1024;
+		memmove((void *)*mem_end, (void *)RELOC(initrd_start),
+			initrd_len);
+		RELOC(initrd_start) = *mem_end;
+		RELOC(initrd_end) = RELOC(initrd_start) + initrd_len;
 	}
-	allnextp = &RELOC(allnodes);
-	mem_start = DOUBLEWORD_ALIGN(mem_start);
-	new_start = inspect_node(root, 0, mem_start, mem_end, &allnextp);
-	*allnextp = 0;
-	return new_start;
+
+	ret = (void *)*mem_start;
+	*mem_start += needed;
+
+	return ret;
 }
 
-static unsigned long __init
+#define make_room(startp, endp, type) \
+	__make_room(startp, endp, sizeof(type), __alignof__(type))
+
+static void __init
 inspect_node(phandle node, struct device_node *dad,
-	     unsigned long mem_start, unsigned long mem_end,
+	     unsigned long *mem_start, unsigned long *mem_end,
 	     struct device_node ***allnextpp)
 {
 	int l;
@@ -1798,9 +1587,9 @@ inspect_node(phandle node, struct device
 	unsigned char *valp;
 	unsigned long offset = reloc_offset();
 
-	np = (struct device_node *) mem_start;
-	mem_start += sizeof(struct device_node);
+	np = make_room(mem_start, mem_end, struct device_node);
 	memset(np, 0, sizeof(*np));
+	
 	np->node = node;
 	**allnextpp = PTRUNRELOC(np);
 	*allnextpp = &np->allnext;
@@ -1818,19 +1607,22 @@ inspect_node(phandle node, struct device
 	prev_propp = &np->properties;
 	prev_name = RELOC("");
 	for (;;) {
-		pp = (struct property *) mem_start;
-		namep = (char *) (pp + 1);
-		pp->name = PTRUNRELOC(namep);
+		/* 32 is max len of name including nul. */
+		namep = make_room(mem_start, mem_end, char[32]);
 		if ((long) call_prom(RELOC("nextprop"), 3, 1, node, prev_name,
-				    namep) <= 0)
+				     namep) <= 0) {
+			/* No more nodes: unwind alloc */
+			*mem_start = (unsigned long)namep;
 			break;
-		mem_start = DOUBLEWORD_ALIGN((unsigned long)namep + strlen(namep) + 1);
+		}
+		/* Trim off some if we can */
+		*mem_start = DOUBLEWORD_ALIGN((unsigned long)namep
+					     + strlen(namep) + 1);
+		pp = make_room(mem_start, mem_end, struct property);
+		pp->name = PTRUNRELOC(namep);
 		prev_name = namep;
-		valp = (unsigned char *) mem_start;
-		pp->value = PTRUNRELOC(valp);
-		pp->length = (int)(long)
-			call_prom(RELOC("getprop"), 4, 1, node, namep,
-				  valp, mem_end - mem_start);
+
+		pp->length = call_prom(RELOC("getproplen"), 2, 1, node, namep);
 		if (pp->length < 0)
 			continue;
 		if (pp->length > MAX_PROPERTY_LENGTH) {
@@ -1849,7 +1641,9 @@ inspect_node(phandle node, struct device
 
 			continue;
 		}
-		mem_start = DOUBLEWORD_ALIGN(mem_start + pp->length);
+		valp = __make_room(mem_start, mem_end, pp->length, 1);
+		pp->value = PTRUNRELOC(valp);
+		call_prom(RELOC("getprop"), 4, 1, node, namep,valp,pp->length);
 		*prev_propp = PTRUNRELOC(pp);
 		prev_propp = &pp->next;
 	}
@@ -1873,109 +1667,387 @@ inspect_node(phandle node, struct device
 	*prev_propp = 0;
 
 	/* get the node's full name */
+	namep = (char *)*mem_start;
 	l = (long) call_prom(RELOC("package-to-path"), 3, 1, node,
-			    (char *) mem_start, mem_end - mem_start);
+			     namep, *mem_end - *mem_start);
 	if (l >= 0) {
-		np->full_name = PTRUNRELOC((char *) mem_start);
-		*(char *)(mem_start + l) = 0;
-		mem_start = DOUBLEWORD_ALIGN(mem_start + l + 1);
+		/* Didn't fit?  Get more room. */
+		if (l+1 > *mem_end - *mem_start) {
+			namep = __make_room(mem_start, mem_end, l+1, 1);
+			call_prom(RELOC("package-to-path"),3,1,node,namep,l);
+		}
+		np->full_name = PTRUNRELOC(namep);
+		namep[l] = '\0';
+		*mem_start = DOUBLEWORD_ALIGN(*mem_start + l + 1);
 	}
 
 	/* do all our children */
 	child = call_prom(RELOC("child"), 1, 1, node);
 	while (child != (phandle)0) {
-		mem_start = inspect_node(child, np, mem_start, mem_end,
+		inspect_node(child, np, mem_start, mem_end,
 					 allnextpp);
 		child = call_prom(RELOC("peer"), 1, 1, child);
 	}
-
-	return mem_start;
 }
 
 /*
- * finish_device_tree is called once things are running normally
- * (i.e. with text and data mapped to the address they were linked at).
- * It traverses the device tree and fills in the name, type,
- * {n_}addrs and {n_}intrs fields of each node.
+ * Make a copy of the device tree from the PROM.
  */
-void __init
-finish_device_tree(void)
+static unsigned long __init
+copy_device_tree(unsigned long mem_start)
 {
-	unsigned long mem = klimit;
+	phandle root;
+	struct device_node **allnextp;
+	unsigned long offset = reloc_offset();
+	unsigned long mem_end = RELOC(initrd_start);
 
-	virt_irq_init();
+	/* We pass mem_end-mem_start to OF: keep it well under 32-bit */
+	if (!mem_end)
+		mem_end = mem_start + 1024*1024*1024;
+
+	root = call_prom(RELOC("peer"), 1, 1, (phandle)0);
+	if (root == (phandle)0) {
+		prom_panic(RELOC("couldn't get device tree root\n"));
+	}
+	allnextp = &RELOC(allnodes);
+	inspect_node(root, 0, &mem_start, &mem_end, &allnextp);
+	*allnextp = 0;
+	return mem_start;
+}
+
+/* Verify bi_recs are good */
+static struct bi_record * __init prom_bi_rec_verify(struct bi_record *bi_recs)
+{
+	struct bi_record *first, *last;
+#ifdef DEBUG_PROM
+	unsigned long offset = reloc_offset();
 
-	mem = finish_node(allnodes, mem, NULL, 0, 0);
-	dev_tree_size = mem - (unsigned long) allnodes;
+  	prom_print(RELOC("birec_verify: r6=0x"));
+  	prom_print_hex((unsigned long)bi_recs);
+  	prom_print_nl();
+	if (bi_recs != NULL) {
+		prom_print(RELOC("  tag=0x"));
+		prom_print_hex(bi_recs->tag);
+		prom_print_nl();
+	}
+#endif /* DEBUG_PROM */
 
-	mem = _ALIGN(mem, PAGE_SIZE);
-	lmb_reserve(__pa(klimit), mem-klimit);
+	if ( bi_recs == NULL || bi_recs->tag != BI_FIRST )
+		return NULL;
 
-	klimit = mem;
+	last = (struct bi_record *)(long)bi_recs->data[0];
 
-	rtas.dev = of_find_node_by_name(NULL, "rtas");
+#ifdef DEBUG_PROM
+  	prom_print(RELOC("  last=0x"));
+  	prom_print_hex((unsigned long)last);
+  	prom_print_nl();
+	if (last != NULL) {
+		prom_print(RELOC("  last_tag=0x"));
+		prom_print_hex(last->tag);
+		prom_print_nl();
+	}
+#endif /* DEBUG_PROM */
+
+	if ( last == NULL || last->tag != BI_LAST )
+		return NULL;
+
+	first = (struct bi_record *)(long)last->data[0];
+#ifdef DEBUG_PROM
+  	prom_print(RELOC("  first=0x"));
+  	prom_print_hex((unsigned long)first);
+  	prom_print_nl();
+#endif /* DEBUG_PROM */
+
+	if ( first == NULL || first != bi_recs )
+		return NULL;
+
+	return bi_recs;
 }
 
-static unsigned long __init
-finish_node(struct device_node *np, unsigned long mem_start,
-	    interpret_func *ifunc, int naddrc, int nsizec)
+static void __init prom_bi_rec_reserve(void)
 {
-	struct device_node *child;
-	int *ip;
+	unsigned long offset = reloc_offset();
+	struct prom_t *_prom = PTRRELOC(&prom);
+	struct bi_record *rec;
 
-	np->name = get_property(np, "name", 0);
-	np->type = get_property(np, "device_type", 0);
+	if ( _prom->bi_recs != NULL) {
 
-	if (!np->name)
-		np->name = "<NULL>";
-	if (!np->type)
-		np->type = "<NULL>";
+		for ( rec=_prom->bi_recs;
+		      rec->tag != BI_LAST;
+		      rec=bi_rec_next(rec) ) {
+#ifdef DEBUG_PROM
+			prom_print(RELOC("bi: 0x"));
+			prom_print_hex(rec->tag);
+			prom_print_nl();
+#endif /* DEBUG_PROM */
+			switch (rec->tag) {
+#ifdef CONFIG_BLK_DEV_INITRD
+			case BI_INITRD:
+				RELOC(initrd_start) = (unsigned long)(rec->data[0]);
+				RELOC(initrd_end) = RELOC(initrd_start) + rec->data[1];
+				break;
+#endif /* CONFIG_BLK_DEV_INITRD */
+			}
+		}
+		/* The next use of this field will be after relocation
+	 	 * is enabled, so convert this physical address into a
+	 	 * virtual address.
+	 	 */
+		_prom->bi_recs = PTRUNRELOC(_prom->bi_recs);
+	}
+}
 
-	/* get the device addresses and interrupts */
-	if (ifunc != NULL)
-		mem_start = ifunc(np, mem_start, naddrc, nsizec);
+/*
+ * We enter here early on, when the Open Firmware prom is still
+ * handling exceptions and the MMU hash table for us.
+ */
+
+unsigned long __init
+prom_init(unsigned long r3, unsigned long r4, unsigned long pp,
+	  unsigned long r6, unsigned long r7)
+{
+	unsigned long mem;
+	ihandle prom_cpu;
+	phandle cpu_pkg;
+	unsigned long offset = reloc_offset();
+	long l;
+	char *p, *d;
+	unsigned long phys;
+	u32 getprop_rval;
+	struct systemcfg *_systemcfg;
+	struct paca_struct *_xPaca = PTRRELOC(&paca[0]);
+	struct prom_t *_prom = PTRRELOC(&prom);
+
+	/* First zero the BSS -- use memset, some arches don't have
+	 * caches on yet */
+	memset(PTRRELOC(&__bss_start), 0, __bss_stop - __bss_start);
+
+	/* Setup systemcfg and NACA pointers now */
+	RELOC(systemcfg) = _systemcfg = (struct systemcfg *)(SYSTEMCFG_VIRT_ADDR - offset);
+	RELOC(naca) = (struct naca_struct *)(NACA_VIRT_ADDR - offset);
+
+	/* Init interface to Open Firmware and pickup bi-recs */
+	prom_init_client_services(pp);
+
+	/* Init prom stdout device */
+	prom_init_stdout();
+
+#ifdef DEBUG_PROM
+  	prom_print(RELOC("klimit=0x"));
+  	prom_print_hex(RELOC(klimit));
+  	prom_print_nl();
+  	prom_print(RELOC("offset=0x"));
+  	prom_print_hex(offset);
+  	prom_print_nl();
+  	prom_print(RELOC("->mem=0x"));
+  	prom_print_hex(RELOC(klimit) - offset);
+  	prom_print_nl();
+#endif /* DEBUG_PROM */
+
+	/* check out if we have bi_recs */
+	_prom->bi_recs = prom_bi_rec_verify((struct bi_record *)r6);
+	if ( _prom->bi_recs != NULL ) {
+		RELOC(klimit) = PTRUNRELOC((unsigned long)_prom->bi_recs +
+					   _prom->bi_recs->data[1]);
+#ifdef DEBUG_PROM
+		prom_print(RELOC("bi_recs=0x"));
+		prom_print_hex((unsigned long)_prom->bi_recs);
+		prom_print_nl();
+		prom_print(RELOC("new mem=0x"));
+		prom_print_hex(RELOC(klimit) - offset);
+		prom_print_nl();
+#endif /* DEBUG_PROM */
+	}
+
+	/* If we don't have birec's or didn't find them, check for an initrd
+	 * using the "yaboot" way
+	 */
+#ifdef CONFIG_BLK_DEV_INITRD
+	if ( _prom->bi_recs == NULL && r3 && r4 && r4 != 0xdeadbeef) {
+		RELOC(initrd_start) = (r3 >= KERNELBASE) ? __pa(r3) : r3;
+		RELOC(initrd_end) = RELOC(initrd_start) + r4;
+		RELOC(initrd_below_start_ok) = 1;
+	}
+#endif /* CONFIG_BLK_DEV_INITRD */
+
+	/* Default machine type. */
+	_systemcfg->platform = prom_find_machine_type();
+
+	/* On pSeries, copy the CPU hold code */
+	if (_systemcfg->platform == PLATFORM_PSERIES)
+		copy_and_flush(0, KERNELBASE - offset, 0x100, 0);
+
+	/* Start storing things at klimit */
+      	mem = RELOC(klimit) - offset; 
+
+	/* Get the full OF pathname of the stdout device */
+	p = (char *) mem;
+	memset(p, 0, 256);
+	call_prom(RELOC("instance-to-path"), 3, 1, _prom->stdout, p, 255);
+	RELOC(of_stdout_device) = PTRUNRELOC(p);
+	mem += strlen(p) + 1;
+
+	getprop_rval = 1;
+	call_prom(RELOC("getprop"), 4, 1,
+		  _prom->root, RELOC("#size-cells"),
+		  &getprop_rval, sizeof(getprop_rval));
+	_prom->encode_phys_size = (getprop_rval == 1) ? 32 : 64;
+
+	/* Determine which cpu is actually running right _now_ */
+        if ((long)call_prom(RELOC("getprop"), 4, 1, _prom->chosen,
+			    RELOC("cpu"), &getprop_rval,
+			    sizeof(getprop_rval)) <= 0)
+                prom_panic(RELOC("cannot find boot cpu"));
+
+	prom_cpu = (ihandle)(unsigned long)getprop_rval;
+	cpu_pkg = call_prom(RELOC("instance-to-package"), 1, 1, prom_cpu);
+	call_prom(RELOC("getprop"), 4, 1,
+		cpu_pkg, RELOC("reg"),
+		&getprop_rval, sizeof(getprop_rval));
+	_prom->cpu = (int)(unsigned long)getprop_rval;
+	_xPaca[0].xHwProcNum = _prom->cpu;
+
+	RELOC(boot_cpuid) = 0;
+
+#ifdef DEBUG_PROM
+  	prom_print(RELOC("Booting CPU hw index = 0x"));
+  	prom_print_hex(_prom->cpu);
+  	prom_print_nl();
+#endif
+
+	/* Get the boot device and translate it to a full OF pathname. */
+	p = (char *) mem;
+	l = (long) call_prom(RELOC("getprop"), 4, 1, _prom->chosen,
+			    RELOC("bootpath"), p, 1<<20);
+	if (l > 0) {
+		p[l] = 0;	/* should already be null-terminated */
+		RELOC(bootpath) = PTRUNRELOC(p);
+		mem += l + 1;
+		d = (char *) mem;
+		*d = 0;
+		call_prom(RELOC("canon"), 3, 1, p, d, 1<<20);
+		RELOC(bootdevice) = PTRUNRELOC(d);
+		mem = DOUBLEWORD_ALIGN(mem + strlen(d) + 1);
+	}
+
+	RELOC(cmd_line[0]) = 0;
+	if ((long)_prom->chosen > 0) {
+		call_prom(RELOC("getprop"), 4, 1, _prom->chosen, 
+			  RELOC("bootargs"), p, sizeof(cmd_line));
+		if (p != NULL && p[0] != 0)
+			strlcpy(RELOC(cmd_line), p, sizeof(cmd_line));
+	}
+
+	early_cmdline_parse();
+
+	prom_initialize_lmb();
+
+	prom_bi_rec_reserve();
+
+	mem = check_display(mem);
+
+	if (_systemcfg->platform != PLATFORM_POWERMAC)
+		prom_instantiate_rtas();
+        
+        /* Initialize some system info into the Naca early... */
+        prom_initialize_naca();
+
+	smt_setup();
+	
+        /* If we are on an SMP machine, then we *MUST* do the
+         * following, regardless of whether we have an SMP
+         * kernel or not.
+         */
+	prom_hold_cpus(mem);
+
+#ifdef DEBUG_PROM
+  	prom_print(RELOC("after basic inits, mem=0x"));
+  	prom_print_hex(mem);
+  	prom_print_nl();
+	prom_print(RELOC("initrd_start=0x"));
+	prom_print_hex(RELOC(initrd_start));
+	prom_print_nl();
+	prom_print(RELOC("initrd_end=0x"));
+	prom_print_hex(RELOC(initrd_end));
+	prom_print_nl();
+	prom_print(RELOC("copying OF device tree...\n"));
+#endif /* DEBUG_PROM */
+	mem = copy_device_tree(mem);
+
+	RELOC(klimit) = mem + offset;
+
+#ifdef DEBUG_PROM
+	prom_print(RELOC("new klimit is\n"));
+  	prom_print(RELOC("klimit=0x"));
+  	prom_print_hex(RELOC(klimit));
+	prom_print(RELOC(" ->mem=0x\n"));
+  	prom_print(RELOC("klimit=0x"));
+  	prom_print_hex(mem);
+  	prom_print_nl();
+#endif /* DEBUG_PROM */
+
+	lmb_reserve(0, __pa(RELOC(klimit)));
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (RELOC(initrd_start)) {
+		unsigned long initrd_len;
+		initrd_len = RELOC(initrd_end) - RELOC(initrd_start);
+
+		/* Move initrd if it's where we're going to copy kernel. */
+		if (RELOC(initrd_start) < __pa(RELOC(klimit))) {
+			memmove((void *)mem, (void *)RELOC(initrd_start),
+				initrd_len);
+			RELOC(initrd_start) = mem;
+			RELOC(initrd_end) = mem + initrd_len;
+		}
+
+		lmb_reserve(RELOC(initrd_start), initrd_len);
+	}
+#endif /* CONFIG_BLK_DEV_INITRD */
+
+	if (_systemcfg->platform == PLATFORM_PSERIES)
+		prom_initialize_tce_table();
+
+#ifdef CONFIG_PMAC_DART
+	if (_systemcfg->platform == PLATFORM_POWERMAC)
+		prom_initialize_dart_table();
+#endif
 
-	mem_start = finish_node_interrupts(np, mem_start);
+#ifdef CONFIG_BOOTX_TEXT
+	if(_prom->disp_node) {
+		prom_print(RELOC("Setting up bi display...\n"));
+		setup_disp_fake_bi(_prom->disp_node);
+	}
+#endif /* CONFIG_BOOTX_TEXT */
 
-	/* Look for #address-cells and #size-cells properties. */
-	ip = (int *) get_property(np, "#address-cells", 0);
-	if (ip != NULL)
-		naddrc = *ip;
-	ip = (int *) get_property(np, "#size-cells", 0);
-	if (ip != NULL)
-		nsizec = *ip;
+	prom_print(RELOC("Calling quiesce ...\n"));
+	call_prom(RELOC("quiesce"), 0, 0);
+	phys = KERNELBASE - offset;
 
-	/* the f50 sets the name to 'display' and 'compatible' to what we
-	 * expect for the name -- Cort
-	 */
-	if (!strcmp(np->name, "display"))
-		np->name = get_property(np, "compatible", 0);
+#ifdef CONFIG_BLK_DEV_INITRD
+	/* If we had an initrd, we convert its address to virtual */
+	if (RELOC(initrd_start)) {
+		RELOC(initrd_start) = (unsigned long)__va(RELOC(initrd_start));
+		RELOC(initrd_end) = (unsigned long)__va(RELOC(initrd_end));
+	}
+#endif /* CONFIG_BLK_DEV_INITRD */
 
-	if (!strcmp(np->name, "device-tree") || np->parent == NULL)
-		ifunc = interpret_root_props;
-	else if (np->type == 0)
-		ifunc = NULL;
-	else if (!strcmp(np->type, "pci") || !strcmp(np->type, "vci"))
-		ifunc = interpret_pci_props;
-	else if (!strcmp(np->type, "dbdma"))
-		ifunc = interpret_dbdma_props;
-	else if (!strcmp(np->type, "mac-io") || ifunc == interpret_macio_props)
-		ifunc = interpret_macio_props;
-	else if (!strcmp(np->type, "isa"))
-		ifunc = interpret_isa_props;
-	else if (!strcmp(np->name, "uni-n") || !strcmp(np->name, "u3"))
-		ifunc = interpret_root_props;
-	else if (!((ifunc == interpret_dbdma_props
-		    || ifunc == interpret_macio_props)
-		   && (!strcmp(np->type, "escc")
-		       || !strcmp(np->type, "media-bay"))))
-		ifunc = NULL;
+	prom_print(RELOC("returning from prom_init\n"));
+	return phys;
+}
 
-	for (child = np->child; child != NULL; child = child->sibling)
-		mem_start = finish_node(child, mem_start, ifunc,
-					naddrc, nsizec);
+/*
+ * Find the device_node with a given phandle.
+ */
+static struct device_node * __devinit
+find_phandle(phandle ph)
+{
+	struct device_node *np;
 
-	return mem_start;
+	for (np = allnodes; np != 0; np = np->allnext)
+		if (np->linux_phandle == ph)
+			return np;
+	return NULL;
 }
 
 /*
@@ -2118,11 +2190,9 @@ map_interrupt(unsigned int **irq, struct
 	return nintrc;
 }
 
-/*
- * New version of finish_node_interrupts.
- */
 static unsigned long __init
-finish_node_interrupts(struct device_node *np, unsigned long mem_start)
+finish_node_interrupts(struct device_node *np, unsigned long mem_start,
+		       int measure_only)
 {
 	unsigned int *ints;
 	int intlen, intrcells;
@@ -2139,6 +2209,9 @@ finish_node_interrupts(struct device_nod
 	np->intrs = (struct interrupt_info *) mem_start;
 	mem_start += intlen * sizeof(struct interrupt_info);
 
+	if (measure_only)
+		return mem_start;
+
 	for (i = 0; i < intlen; ++i) {
 		np->intrs[i].line = 0;
 		np->intrs[i].sense = 1;
@@ -2173,39 +2246,9 @@ finish_node_interrupts(struct device_nod
 	return mem_start;
 }
 
-int
-prom_n_addr_cells(struct device_node* np)
-{
-	int* ip;
-	do {
-		if (np->parent)
-			np = np->parent;
-		ip = (int *) get_property(np, "#address-cells", 0);
-		if (ip != NULL)
-			return *ip;
-	} while (np->parent);
-	/* No #address-cells property for the root node, default to 1 */
-	return 1;
-}
-
-int
-prom_n_size_cells(struct device_node* np)
-{
-	int* ip;
-	do {
-		if (np->parent)
-			np = np->parent;
-		ip = (int *) get_property(np, "#size-cells", 0);
-		if (ip != NULL)
-			return *ip;
-	} while (np->parent);
-	/* No #size-cells property for the root node, default to 1 */
-	return 1;
-}
-
 static unsigned long __init
 interpret_pci_props(struct device_node *np, unsigned long mem_start,
-		    int naddrc, int nsizec)
+		    int naddrc, int nsizec, int measure_only)
 {
 	struct address_range *adr;
 	struct pci_reg_property *pci_addrs;
@@ -2217,9 +2260,11 @@ interpret_pci_props(struct device_node *
 		i = 0;
 		adr = (struct address_range *) mem_start;
 		while ((l -= sizeof(struct pci_reg_property)) >= 0) {
-			adr[i].space = pci_addrs[i].addr.a_hi;
-			adr[i].address = pci_addrs[i].addr.a_lo;
-			adr[i].size = pci_addrs[i].size_lo;
+ 			if (!measure_only) {
+				adr[i].space = pci_addrs[i].addr.a_hi;
+				adr[i].address = pci_addrs[i].addr.a_lo;
+				adr[i].size = pci_addrs[i].size_lo;
+			}
 			++i;
 		}
 		np->addrs = adr;
@@ -2231,7 +2276,7 @@ interpret_pci_props(struct device_node *
 
 static unsigned long __init
 interpret_dbdma_props(struct device_node *np, unsigned long mem_start,
-		      int naddrc, int nsizec)
+		      int naddrc, int nsizec, int measure_only)
 {
 	struct reg_property32 *rp;
 	struct address_range *adr;
@@ -2240,10 +2285,12 @@ interpret_dbdma_props(struct device_node
 	struct device_node *db;
 
 	base_address = 0;
-	for (db = np->parent; db != NULL; db = db->parent) {
-		if (!strcmp(db->type, "dbdma") && db->n_addrs != 0) {
-			base_address = db->addrs[0].address;
-			break;
+	if (!measure_only) {
+		for (db = np->parent; db != NULL; db = db->parent) {
+			if (!strcmp(db->type, "dbdma") && db->n_addrs != 0) {
+				base_address = db->addrs[0].address;
+				break;
+			}
 		}
 	}
 
@@ -2252,9 +2299,11 @@ interpret_dbdma_props(struct device_node
 		i = 0;
 		adr = (struct address_range *) mem_start;
 		while ((l -= sizeof(struct reg_property32)) >= 0) {
-			adr[i].space = 2;
-			adr[i].address = rp[i].address + base_address;
-			adr[i].size = rp[i].size;
+ 			if (!measure_only) {
+				adr[i].space = 2;
+				adr[i].address = rp[i].address + base_address;
+				adr[i].size = rp[i].size;
+			}
 			++i;
 		}
 		np->addrs = adr;
@@ -2267,7 +2316,7 @@ interpret_dbdma_props(struct device_node
 
 static unsigned long __init
 interpret_macio_props(struct device_node *np, unsigned long mem_start,
-		      int naddrc, int nsizec)
+		      int naddrc, int nsizec, int measure_only)
 {
 	struct reg_property32 *rp;
 	struct address_range *adr;
@@ -2276,10 +2325,12 @@ interpret_macio_props(struct device_node
 	struct device_node *db;
 
 	base_address = 0;
-	for (db = np->parent; db != NULL; db = db->parent) {
-		if (!strcmp(db->type, "mac-io") && db->n_addrs != 0) {
-			base_address = db->addrs[0].address;
-			break;
+	if (!measure_only) {
+		for (db = np->parent; db != NULL; db = db->parent) {
+			if (!strcmp(db->type, "mac-io") && db->n_addrs != 0) {
+				base_address = db->addrs[0].address;
+				break;
+			}
 		}
 	}
 
@@ -2288,9 +2339,11 @@ interpret_macio_props(struct device_node
 		i = 0;
 		adr = (struct address_range *) mem_start;
 		while ((l -= sizeof(struct reg_property32)) >= 0) {
-			adr[i].space = 2;
-			adr[i].address = rp[i].address + base_address;
-			adr[i].size = rp[i].size;
+ 			if (!measure_only) {
+				adr[i].space = 2;
+				adr[i].address = rp[i].address + base_address;
+				adr[i].size = rp[i].size;
+			}
 			++i;
 		}
 		np->addrs = adr;
@@ -2303,7 +2356,7 @@ interpret_macio_props(struct device_node
 
 static unsigned long __init
 interpret_isa_props(struct device_node *np, unsigned long mem_start,
-		    int naddrc, int nsizec)
+		    int naddrc, int nsizec, int measure_only)
 {
 	struct isa_reg_property *rp;
 	struct address_range *adr;
@@ -2314,9 +2367,11 @@ interpret_isa_props(struct device_node *
 		i = 0;
 		adr = (struct address_range *) mem_start;
 		while ((l -= sizeof(struct reg_property)) >= 0) {
-			adr[i].space = rp[i].space;
-			adr[i].address = rp[i].address;
-			adr[i].size = rp[i].size;
+ 			if (!measure_only) {
+				adr[i].space = rp[i].space;
+				adr[i].address = rp[i].address;
+				adr[i].size = rp[i].size;
+			}
 			++i;
 		}
 		np->addrs = adr;
@@ -2329,7 +2384,7 @@ interpret_isa_props(struct device_node *
 
 static unsigned long __init
 interpret_root_props(struct device_node *np, unsigned long mem_start,
-		     int naddrc, int nsizec)
+		     int naddrc, int nsizec, int measure_only)
 {
 	struct address_range *adr;
 	int i, l;
@@ -2341,9 +2396,11 @@ interpret_root_props(struct device_node 
 		i = 0;
 		adr = (struct address_range *) mem_start;
 		while ((l -= rpsize) >= 0) {
-			adr[i].space = 0;
-			adr[i].address = rp[naddrc - 1];
-			adr[i].size = rp[naddrc + nsizec - 1];
+ 			if (!measure_only) {
+				adr[i].space = 0;
+				adr[i].address = rp[naddrc - 1];
+				adr[i].size = rp[naddrc + nsizec - 1];
+			}
 			++i;
 			rp += naddrc + nsizec;
 		}
@@ -2355,6 +2412,119 @@ interpret_root_props(struct device_node 
 	return mem_start;
 }
 
+static unsigned long __init
+finish_node(struct device_node *np, unsigned long mem_start,
+	    interpret_func *ifunc, int naddrc, int nsizec, int measure_only)
+{
+	struct device_node *child;
+	int *ip;
+
+	np->name = get_property(np, "name", 0);
+	np->type = get_property(np, "device_type", 0);
+
+	if (!np->name)
+		np->name = "<NULL>";
+	if (!np->type)
+		np->type = "<NULL>";
+
+	/* get the device addresses and interrupts */
+	if (ifunc != NULL)
+		mem_start = ifunc(np, mem_start, naddrc, nsizec, measure_only);
+
+	mem_start = finish_node_interrupts(np, mem_start, measure_only);
+
+	/* Look for #address-cells and #size-cells properties. */
+	ip = (int *) get_property(np, "#address-cells", 0);
+	if (ip != NULL)
+		naddrc = *ip;
+	ip = (int *) get_property(np, "#size-cells", 0);
+	if (ip != NULL)
+		nsizec = *ip;
+
+	/* the f50 sets the name to 'display' and 'compatible' to what we
+	 * expect for the name -- Cort
+	 */
+	if (!strcmp(np->name, "display"))
+		np->name = get_property(np, "compatible", 0);
+
+	if (!strcmp(np->name, "device-tree") || np->parent == NULL)
+		ifunc = interpret_root_props;
+	else if (np->type == 0)
+		ifunc = NULL;
+	else if (!strcmp(np->type, "pci") || !strcmp(np->type, "vci"))
+		ifunc = interpret_pci_props;
+	else if (!strcmp(np->type, "dbdma"))
+		ifunc = interpret_dbdma_props;
+	else if (!strcmp(np->type, "mac-io") || ifunc == interpret_macio_props)
+		ifunc = interpret_macio_props;
+	else if (!strcmp(np->type, "isa"))
+		ifunc = interpret_isa_props;
+	else if (!strcmp(np->name, "uni-n") || !strcmp(np->name, "u3"))
+		ifunc = interpret_root_props;
+	else if (!((ifunc == interpret_dbdma_props
+		    || ifunc == interpret_macio_props)
+		   && (!strcmp(np->type, "escc")
+		       || !strcmp(np->type, "media-bay"))))
+		ifunc = NULL;
+
+	for (child = np->child; child != NULL; child = child->sibling)
+		mem_start = finish_node(child, mem_start, ifunc,
+					naddrc, nsizec, measure_only);
+
+	return mem_start;
+}
+
+/*
+ * finish_device_tree is called once things are running normally
+ * (i.e. with text and data mapped to the address they were linked at).
+ * It traverses the device tree and fills in the name, type,
+ * {n_}addrs and {n_}intrs fields of each node.
+ */
+void __init
+finish_device_tree(void)
+{
+	unsigned long mem = klimit;
+
+	virt_irq_init();
+
+	dev_tree_size = finish_node(allnodes, 0, NULL, 0, 0, 1);
+	mem = (long)abs_to_virt(lmb_alloc(dev_tree_size,
+					  __alignof__(struct device_node)));
+	if (finish_node(allnodes, mem, NULL, 0, 0, 0) != mem + dev_tree_size)
+		BUG();
+	rtas.dev = of_find_node_by_name(NULL, "rtas");
+}
+
+int
+prom_n_addr_cells(struct device_node* np)
+{
+	int* ip;
+	do {
+		if (np->parent)
+			np = np->parent;
+		ip = (int *) get_property(np, "#address-cells", 0);
+		if (ip != NULL)
+			return *ip;
+	} while (np->parent);
+	/* No #address-cells property for the root node, default to 1 */
+	return 1;
+}
+
+int
+prom_n_size_cells(struct device_node* np)
+{
+	int* ip;
+	do {
+		if (np->parent)
+			np = np->parent;
+		ip = (int *) get_property(np, "#size-cells", 0);
+		if (ip != NULL)
+			return *ip;
+	} while (np->parent);
+	/* No #size-cells property for the root node, default to 1 */
+	return 1;
+}
+
 /*
  * Work out the sense (active-low level / active-high edge)
  * of each interrupt from the device tree.
@@ -2724,30 +2894,6 @@ struct device_node *of_node_get(struct d
 EXPORT_SYMBOL(of_node_get);
 
 /**
- *	of_node_put - Decrement refcount of a node
- *	@node:	Node to dec refcount, NULL is supported to
- *		simplify writing of callers
- *
- */
-void of_node_put(struct device_node *node)
-{
-	if (!node)
-		return;
-
-	WARN_ON(0 == atomic_read(&node->_users));
-
-	if (OF_IS_STALE(node)) {
-		if (atomic_dec_and_test(&node->_users)) {
-			of_node_cleanup(node);
-			return;
-		}
-	}
-	else
-		atomic_dec(&node->_users);
-}
-EXPORT_SYMBOL(of_node_put);
-
-/**
  *	of_node_cleanup - release a dynamically allocated node
  *	@arg:  Node to be released
  */
@@ -2764,11 +2910,35 @@ static void of_node_cleanup(struct devic
 		kfree(prop);
 		prop = next;
 	}
-	kfree(node->intrs);
-	kfree(node->addrs);
-	kfree(node->full_name);
-	kfree(node);
+	kfree(node->intrs);
+	kfree(node->addrs);
+	kfree(node->full_name);
+	kfree(node);
+}
+
+/**
+ *	of_node_put - Decrement refcount of a node
+ *	@node:	Node to dec refcount, NULL is supported to
+ *		simplify writing of callers
+ *
+ */
+void of_node_put(struct device_node *node)
+{
+	if (!node)
+		return;
+
+	WARN_ON(0 == atomic_read(&node->_users));
+
+	if (OF_IS_STALE(node)) {
+		if (atomic_dec_and_test(&node->_users)) {
+			of_node_cleanup(node);
+			return;
+		}
+	}
+	else
+		atomic_dec(&node->_users);
 }
+EXPORT_SYMBOL(of_node_put);
 
 /**
  *	derive_parent - basically like dirname(1)
@@ -2803,104 +2973,6 @@ static struct device_node *derive_parent
 /*
  * Routines for "runtime" addition and removal of device tree nodes.
  */
-
-/*
- * Given a path and a property list, construct an OF device node, add
- * it to the device tree and global list, and place it in
- * /proc/device-tree.  This function may sleep.
- */
-int of_add_node(const char *path, struct property *proplist)
-{
-	struct device_node *np;
-	int err = 0;
-
-	np = kmalloc(sizeof(struct device_node), GFP_KERNEL);
-	if (!np)
-		return -ENOMEM;
-
-	memset(np, 0, sizeof(*np));
-
-	np->full_name = kmalloc(strlen(path) + 1, GFP_KERNEL);
-	if (!np->full_name) {
-		kfree(np);
-		return -ENOMEM;
-	}
-	strcpy(np->full_name, path);
-
-	np->properties = proplist;
-	OF_MARK_DYNAMIC(np);
-	of_node_get(np);
-	np->parent = derive_parent(path);
-	if (!np->parent) {
-		kfree(np);
-		return -EINVAL; /* could also be ENOMEM, though */
-	}
-
-	if (0 != (err = of_finish_dynamic_node(np))) {
-		kfree(np);
-		return err;
-	}
-
-	write_lock(&devtree_lock);
-	np->sibling = np->parent->child;
-	np->allnext = allnodes;
-	np->parent->child = np;
-	allnodes = np;
-	write_unlock(&devtree_lock);
-
-	add_node_proc_entries(np);
-
-	of_node_put(np->parent);
-	of_node_put(np);
-	return 0;
-}
-
-/*
- * Remove an OF device node from the system.
- * Caller should have already "gotten" np.
- */
-int of_remove_node(struct device_node *np)
-{
-	struct device_node *parent, *child;
-
-	parent = of_get_parent(np);
-	if (!parent)
-		return -EINVAL;
-
-	if ((child = of_get_next_child(np, NULL))) {
-		of_node_put(child);
-		return -EBUSY;
-	}
-
-	write_lock(&devtree_lock);
-	OF_MARK_STALE(np);
-	remove_node_proc_entries(np);
-	if (allnodes == np)
-		allnodes = np->allnext;
-	else {
-		struct device_node *prev;
-		for (prev = allnodes;
-		     prev->allnext != np;
-		     prev = prev->allnext)
-			;
-		prev->allnext = np->allnext;
-	}
-
-	if (parent->child == np)
-		parent->child = np->sibling;
-	else {
-		struct device_node *prevsib;
-		for (prevsib = np->parent->child;
-		     prevsib->sibling != np;
-		     prevsib = prevsib->sibling)
-			;
-		prevsib->sibling = np->sibling;
-	}
-	write_unlock(&devtree_lock);
-	of_node_put(parent);
-	return 0;
-}
-
 #ifdef CONFIG_PROC_DEVICETREE
 /*
  * Add a node to /proc/device-tree.
@@ -3092,17 +3164,100 @@ out:
 }
 
 /*
- * Find the device_node with a given phandle.
+ * Given a path and a property list, construct an OF device node, add
+ * it to the device tree and global list, and place it in
+ * /proc/device-tree.  This function may sleep.
  */
-static struct device_node * __devinit
-find_phandle(phandle ph)
+int of_add_node(const char *path, struct property *proplist)
 {
 	struct device_node *np;
+	int err = 0;
 
-	for (np = allnodes; np != 0; np = np->allnext)
-		if (np->linux_phandle == ph)
-			return np;
-	return NULL;
+	np = kmalloc(sizeof(struct device_node), GFP_KERNEL);
+	if (!np)
+		return -ENOMEM;
+
+	memset(np, 0, sizeof(*np));
+
+	np->full_name = kmalloc(strlen(path) + 1, GFP_KERNEL);
+	if (!np->full_name) {
+		kfree(np);
+		return -ENOMEM;
+	}
+	strcpy(np->full_name, path);
+
+	np->properties = proplist;
+	OF_MARK_DYNAMIC(np);
+	of_node_get(np);
+	np->parent = derive_parent(path);
+	if (!np->parent) {
+		kfree(np);
+		return -EINVAL; /* could also be ENOMEM, though */
+	}
+
+	if (0 != (err = of_finish_dynamic_node(np))) {
+		kfree(np);
+		return err;
+	}
+
+	write_lock(&devtree_lock);
+	np->sibling = np->parent->child;
+	np->allnext = allnodes;
+	np->parent->child = np;
+	allnodes = np;
+	write_unlock(&devtree_lock);
+
+	add_node_proc_entries(np);
+
+	of_node_put(np->parent);
+	of_node_put(np);
+	return 0;
+}
+
+/*
+ * Remove an OF device node from the system.
+ * Caller should have already "gotten" np.
+ */
+int of_remove_node(struct device_node *np)
+{
+	struct device_node *parent, *child;
+
+	parent = of_get_parent(np);
+	if (!parent)
+		return -EINVAL;
+
+	if ((child = of_get_next_child(np, NULL))) {
+		of_node_put(child);
+		return -EBUSY;
+	}
+
+	write_lock(&devtree_lock);
+	OF_MARK_STALE(np);
+	remove_node_proc_entries(np);
+	if (allnodes == np)
+		allnodes = np->allnext;
+	else {
+		struct device_node *prev;
+		for (prev = allnodes;
+		     prev->allnext != np;
+		     prev = prev->allnext)
+			;
+		prev->allnext = np->allnext;
+	}
+
+	if (parent->child == np)
+		parent->child = np->sibling;
+	else {
+		struct device_node *prevsib;
+		for (prevsib = np->parent->child;
+		     prevsib->sibling != np;
+		     prevsib = prevsib->sibling)
+			;
+		prevsib->sibling = np->sibling;
+	}
+	write_unlock(&devtree_lock);
+	of_node_put(parent);
+	return 0;
 }
 
 /*
@@ -3188,55 +3343,3 @@ print_properties(struct device_node *np)
 	}
 }
 #endif
-
-
-/* Verify bi_recs are good */
-static struct bi_record *
-prom_bi_rec_verify(struct bi_record *bi_recs)
-{
-	struct bi_record *first, *last;
-
-	if ( bi_recs == NULL || bi_recs->tag != BI_FIRST )
-		return NULL;
-
-	last = (struct bi_record *)(long)bi_recs->data[0];
-	if ( last == NULL || last->tag != BI_LAST )
-		return NULL;
-
-	first = (struct bi_record *)(long)last->data[0];
-	if ( first == NULL || first != bi_recs )
-		return NULL;
-
-	return bi_recs;
-}
-
-static unsigned long
-prom_bi_rec_reserve(unsigned long mem)
-{
-	unsigned long offset = reloc_offset();
-	struct prom_t *_prom = PTRRELOC(&prom);
-	struct bi_record *rec;
-
-	if ( _prom->bi_recs != NULL) {
-
-		for ( rec=_prom->bi_recs;
-		      rec->tag != BI_LAST;
-		      rec=bi_rec_next(rec) ) {
-			switch (rec->tag) {
-#ifdef CONFIG_BLK_DEV_INITRD
-			case BI_INITRD:
-				lmb_reserve(rec->data[0], rec->data[1]);
-				break;
-#endif /* CONFIG_BLK_DEV_INITRD */
-			}
-		}
-		/* The next use of this field will be after relocation
-	 	 * is enabled, so convert this physical address into a
-	 	 * virtual address.
-	 	 */
-		_prom->bi_recs = PTRUNRELOC(_prom->bi_recs);
-	}
-
-	return mem;
-}
-
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/setup.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/setup.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/setup.c	2004-04-12 17:54:06.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/setup.c	2004-04-24 05:42:09.000000000 +0000
@@ -188,30 +188,32 @@ void setup_system(unsigned long r3, unsi
 #ifdef CONFIG_PPC_PSERIES
 	case PLATFORM_PSERIES:
 		pSeries_init_early();
-#ifdef CONFIG_BLK_DEV_INITRD
-		initrd_start = initrd_end = 0;
-#endif
 		parse_bootinfo();
 		break;
 
 	case PLATFORM_PSERIES_LPAR:
 		pSeriesLP_init_early();
-#ifdef CONFIG_BLK_DEV_INITRD
-		initrd_start = initrd_end = 0;
-#endif
 		parse_bootinfo();
 		break;
 #endif /* CONFIG_PPC_PSERIES */
 #ifdef CONFIG_PPC_PMAC
 	case PLATFORM_POWERMAC:
 		pmac_init_early();
-#ifdef CONFIG_BLK_DEV_INITRD
-		initrd_start = initrd_end = 0;
-#endif
 		parse_bootinfo();
 #endif /* CONFIG_PPC_PMAC */
 	}
 
+	/* If we were passed an initrd, set the ROOT_DEV properly if the values
+	 * look sensible. If not, clear initrd reference.
+	 */
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start >= KERNELBASE && initrd_end >= KERNELBASE &&
+	    initrd_end > initrd_start)
+		ROOT_DEV = Root_RAM0;
+	else
+		initrd_start = initrd_end = 0;
+#endif /* CONFIG_BLK_DEV_INITRD */
+
 #ifdef CONFIG_BOOTX_TEXT
 	map_boot_text();
 	if (systemcfg->platform == PLATFORM_POWERMAC) {
@@ -425,15 +427,6 @@ struct seq_operations cpuinfo_op = {
 void parse_cmd_line(unsigned long r3, unsigned long r4, unsigned long r5,
 		  unsigned long r6, unsigned long r7)
 {
-#ifdef CONFIG_BLK_DEV_INITRD
-	if ((initrd_start == 0) && r3 && r4 && r4 != 0xdeadbeef) {
-		initrd_start = (r3 >= KERNELBASE) ? r3 : (unsigned long)__va(r3);
-		initrd_end = initrd_start + r4;
-		ROOT_DEV = Root_RAM0;
-		initrd_below_start_ok = 1;
-	}
-#endif
-
 	cmd_line[0] = 0;
 
 #ifdef CONFIG_CMDLINE
@@ -533,8 +526,6 @@ console_initcall(set_preferred_console);
 int parse_bootinfo(void)
 {
 	struct bi_record *rec;
-	extern char *sysmap;
-	extern unsigned long sysmap_size;
 
 	rec = prom.bi_recs;
 
@@ -546,18 +537,6 @@ int parse_bootinfo(void)
 		case BI_CMD_LINE:
 			strlcpy(cmd_line, (void *)rec->data, sizeof(cmd_line));
 			break;
-		case BI_SYSMAP:
-			sysmap = __va(rec->data[0]);
-			sysmap_size = rec->data[1];
-			break;
-#ifdef CONFIG_BLK_DEV_INITRD
-		case BI_INITRD:
-			initrd_start = (unsigned long)__va(rec->data[0]);
-			initrd_end = initrd_start + rec->data[1];
-			ROOT_DEV = Root_RAM0;
-			initrd_below_start_ok = 1;
-			break;
-#endif /* CONFIG_BLK_DEV_INITRD */
 		}
 	}
 
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/smp.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/smp.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/smp.c	2004-04-12 17:54:07.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/smp.c	2004-04-14 16:04:29.000000000 +0000
@@ -53,6 +53,10 @@
 #include <asm/cputable.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_KDB
+#include <linux/kdb.h>
+#endif
+
 int smp_threads_ready;
 unsigned long cache_decay_ticks;
 
@@ -75,6 +79,23 @@ void smp_call_function_interrupt(void);
 extern long register_vpa(unsigned long flags, unsigned long proc,
 			 unsigned long vpa);
 
+#ifdef CONFIG_KDB
+	/* save regs here before calling kdb_ipi */
+struct pt_regs *kdb_smp_regs[NR_CPUS];
+	
+/* called for each processor.. drop each into kdb. */
+static void smp_kdb_stop_proc(void *dummy)
+{
+    kdb_ipi(kdb_smp_regs[smp_processor_id()], NULL);
+}
+	
+void smp_kdb_stop(void)
+{
+    int ret=0;
+    ret = smp_call_function(smp_kdb_stop_proc, NULL, 1, 0);
+}
+#endif
+
 /* Low level assembly function used to backup CPU 0 state */
 extern void __save_cpu_setup(void);
 
@@ -306,6 +327,7 @@ void __cpu_die(unsigned int cpu)
 void cpu_die(void)
 {
 	local_irq_disable();
+	pSeriesLP_cppr_info(0, 0);
 	rtas_stop_self();
 	/* Should never get here... */
 	BUG();
@@ -605,6 +627,9 @@ void smp_message_recv(int msg, struct pt
 {
 	switch(msg) {
 	case PPC_MSG_CALL_FUNCTION:
+#ifdef CONFIG_KDB
+	        kdb_smp_regs[smp_processor_id()]=regs;
+#endif
 		smp_call_function_interrupt();
 		break;
 	case PPC_MSG_RESCHEDULE: 
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/viopath.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/viopath.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/viopath.c	2004-03-19 07:10:24.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/viopath.c	2004-04-16 23:30:39.000000000 +0000
@@ -108,7 +108,7 @@ static vio_event_handler_t *vio_handler[
 #define VIOPATH_KERN_WARN	KERN_WARNING "viopath: "
 #define VIOPATH_KERN_INFO	KERN_INFO "viopath: "
 
-static unsigned char e2a(unsigned char x)
+unsigned char e2a(unsigned char x)
 {
 	switch (x) {
 	case 0xF0:
@@ -186,6 +186,7 @@ static unsigned char e2a(unsigned char x
 	}
 	return ' ';
 }
+EXPORT_SYMBOL(e2a);
 
 static int proc_viopath_show(struct seq_file *m, void *v)
 {
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/vpurr.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/vpurr.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/vpurr.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/vpurr.c	2004-03-20 10:56:41.000000000 +0000
@@ -0,0 +1,101 @@
+/*
+ * PPC64 Cpu util performace monitoring.
+ *
+ * Manish Ahuja mahuja@us.ibm.com
+ *    Copyright (c) 2004 Manish Ahuja IBM CORP.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *	This file will also report many of the perf values for 2.6 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/hvcall.h>
+#include <asm/cputable.h>
+#include "vpurr.h"
+
+#define SAMPLE_TICK HZ
+
+DEFINE_PER_CPU(struct cpu_util_store, cpu_util_sampler);
+
+static void collect_startpurr(int cpu);
+
+/*
+ * This is a timer handler.  There is on per CPU. It gets scheduled
+ * every SAMPLE_TICK ticks.
+ */
+
+static void util_timer_func(unsigned long data)
+{
+	struct cpu_util_store * cus = &__get_cpu_var(cpu_util_sampler);
+	struct timer_list *tl = &cus->cpu_util_timer;
+
+	cus->current_purr = mfspr(PURR);
+	cus->tb = mftb();
+
+	/*printk(KERN_INFO "PURR VAL %ld %lld %lld\n", data, cus->current_purr, cus->tb);*/
+
+	mod_timer(tl, jiffies + SAMPLE_TICK);
+}
+
+/*
+ * One time function that gets called when all the cpu's are online 
+ * to start collection. It adds the timer to each cpu on the system.
+ * start_purr is collected during smp_init time in __cpu_up code
+ */
+
+static void start_util_timer(int cpu)
+{
+	struct cpu_util_store * cus = &per_cpu(cpu_util_sampler, cpu);
+	struct timer_list *tl = &cus->cpu_util_timer;
+
+	if (tl->function != NULL)
+		return;
+
+	init_timer(tl);
+	tl->expires = jiffies + SAMPLE_TICK;
+	tl->data = cpu;
+	tl->function = util_timer_func;
+	add_timer_on(tl, cpu);
+}
+
+static int __init cpu_util_init(void)
+{
+	int cpu;
+
+	if (PVR_VER(systemcfg->processor) == PV_POWER5) {
+		for_each_online_cpu(cpu){
+			collect_startpurr(cpu);
+			start_util_timer(cpu);
+		}
+	}
+
+	return 0;
+}
+
+__initcall(cpu_util_init);
+
+/* Collect starting purr, to collect starting purr from the
+ * cpu in question, we make a call to get that cpu and then run
+ */
+
+static void collect_startpurr(int cpu)
+{
+	struct cpu_util_store * cus = &per_cpu(cpu_util_sampler, cpu);	
+
+	set_cpus_allowed(current, cpumask_of_cpu(cpu));
+	BUG_ON(smp_processor_id() != cpu);
+
+	cus->start_purr = mfspr(PURR);
+	cus->tb = mftb();
+}
+
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/vpurr.h linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/vpurr.h
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/vpurr.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/vpurr.h	2004-04-07 16:48:30.000000000 +0000
@@ -0,0 +1,24 @@
+/*
+ *    Copyright (c) 2004 Manish Ahuja <mahuja@us.ibm.com> IBM CORP.
+ *
+ *    Module name: vpurr.h
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      tracking purr utilization and other performace features in coming 
+ * 	releases for splpar/smt machines.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+DECLARE_PER_CPU(struct cpu_util_store, cpu_util_sampler);
+
+struct cpu_util_store {
+        struct timer_list cpu_util_timer;
+        u64 start_purr;
+        u64 current_purr;
+        u64 tb;
+};
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/xics.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/xics.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/kernel/xics.c	2004-04-12 17:54:11.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/kernel/xics.c	2004-04-14 16:04:29.000000000 +0000
@@ -190,7 +190,7 @@ static void pSeriesLP_xirr_info_set(int 
 		      val64); 
 }
 
-static void pSeriesLP_cppr_info(int n_cpu, u8 value)
+void pSeriesLP_cppr_info(int n_cpu, u8 value)
 {
 	unsigned long lpar_rc;
 
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/lib/Makefile linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/lib/Makefile
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/lib/Makefile	2003-06-10 13:09:57.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/lib/Makefile	2004-03-19 03:01:36.000000000 +0000
@@ -4,3 +4,6 @@
 
 lib-y := checksum.o dec_and_lock.o string.o strcase.o
 lib-y += copypage.o memcpy.o copyuser.o
+
+lib-$(CONFIG_PPC_ISERIES) += locks.o
+lib-$(CONFIG_PPC_SPLPAR)  += locks.o
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/lib/locks.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/lib/locks.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/lib/locks.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/lib/locks.c	2004-03-19 02:52:48.000000000 +0000
@@ -0,0 +1,90 @@
+/*
+ * Slow paths for spin and read/write lock operations.
+ *
+ * Copyright (C) 2001 Paul Mackerras <paulus@au.ibm.com>, IBM
+ * Copyright (C) 2001 Anton Blanchard <anton@au.ibm.com>, IBM
+ * Copyright (C) 2002 Dave Engebretsen <engebret@us.ibm.com>, IBM
+ *   Rework to support virtual processors
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <asm/hvcall.h>
+#include <asm/iSeries/HvCall.h>
+
+/*
+ * On a system with shared processors (that is, where a physical
+ * processor is multiplexed between several virtual processors),
+ * there is no point spinning on a lock if the holder of the lock
+ * isn't currently scheduled on a physical processor.  Instead
+ * we detect this situation and ask the hypervisor to give the
+ * rest of our timeslice to the lock holder.
+ */
+
+/* waiting for a spinlock... */
+void __spin_yield(spinlock_t *lock)
+{
+	unsigned int lock_value, holder_cpu, yield_count;
+	struct paca_struct *holder_paca;
+
+	lock_value = lock->lock;
+	if (lock_value == 0)
+		return;
+	holder_cpu = lock_value & 0xffff;
+	BUG_ON(holder_cpu >= NR_CPUS);
+	holder_paca = &paca[holder_cpu];
+	yield_count = holder_paca->xLpPaca.xYieldCount;
+	if ((yield_count & 1) == 0)
+		return;		/* virtual cpu is currently running */
+	rmb();
+	if (lock->lock != lock_value)
+		return;		/* something has changed */
+#ifdef CONFIG_PPC_ISERIES
+	HvCall2(HvCallBaseYieldProcessor, HvCall_YieldToProc,
+		((u64)holder_cpu << 32) | yield_count);
+#else
+	plpar_hcall_norets(H_CONFER, holder_cpu, yield_count);
+#endif
+}
+
+EXPORT_SYMBOL(__spin_yield);
+
+/*
+ * Waiting for a read lock or a write lock on a rwlock...
+ * This turns out to be the same for read and write locks, since
+ * we only know the holder if it is write-locked.
+ */
+void __rw_yield(rwlock_t *rw)
+{
+	int lock_value;
+	unsigned int holder_cpu, yield_count;
+	struct paca_struct *holder_paca;
+
+	lock_value = rw->lock;
+	if (lock_value >= 0)
+		return;		/* no write lock at present */
+	holder_cpu = lock_value & 0xffff;
+	BUG_ON(holder_cpu >= NR_CPUS);
+	holder_paca = &paca[holder_cpu];
+	yield_count = holder_paca->xLpPaca.xYieldCount;
+	if ((yield_count & 1) == 0)
+		return;		/* virtual cpu is currently running */
+	rmb();
+	if (rw->lock != lock_value)
+		return;		/* something has changed */
+#ifdef CONFIG_PPC_ISERIES
+	HvCall2(HvCallBaseYieldProcessor, HvCall_YieldToProc,
+		((u64)holder_cpu << 32) | yield_count);
+#else
+	plpar_hcall_norets(H_CONFER, holder_cpu, yield_count);
+#endif
+}
+
+EXPORT_SYMBOL(__rw_yield);
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/mm/init.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/mm/init.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/mm/init.c	2004-04-12 17:54:08.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/mm/init.c	2004-04-24 05:42:09.000000000 +0000
@@ -621,8 +621,6 @@ module_init(setup_kcore);
 void __init mem_init(void)
 {
 #ifndef CONFIG_DISCONTIGMEM
-	extern char *sysmap; 
-	extern unsigned long sysmap_size;
 	unsigned long addr;
 #endif
 	int codepages = 0;
@@ -656,12 +654,6 @@ void __init mem_init(void)
 
 	totalram_pages += free_all_bootmem();
 
-	if ( sysmap_size )
-		for (addr = (unsigned long)sysmap;
-		     addr < PAGE_ALIGN((unsigned long)sysmap+sysmap_size) ;
-		     addr += PAGE_SIZE)
-			SetPageReserved(virt_to_page(addr));
-	
 	for (addr = KERNELBASE; addr <= (unsigned long)__va(lmb_end_of_DRAM());
 	     addr += PAGE_SIZE) {
 		if (!PageReserved(virt_to_page(addr)))
diff -purN linux-post-2.6.6-rc2-20040424/arch/ppc64/mm/numa.c linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/mm/numa.c
--- linux-post-2.6.6-rc2-20040424/arch/ppc64/mm/numa.c	2004-04-12 17:54:46.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/arch/ppc64/mm/numa.c	2004-04-13 03:01:02.000000000 +0000
@@ -143,6 +143,7 @@ static int __init parse_numa_properties(
 		unsigned long size = 0;
 		int numa_domain;
 		int ranges;
+		int propsize;
 
 		tmp1 = (int *)get_property(memory, "reg", NULL);
 		if (!tmp1)
@@ -169,10 +170,21 @@ new_range:
 		if ((start + size) > MAX_MEMORY)
 			BUG();
 
+		/* Some versions of OF sometimes have an empty property for
+		 * associativity, so we need to get the size too.
+		 */
 		tmp2 = (int *)get_property(memory, "ibm,associativity",
-					   NULL);
+					   &propsize);
 		if (!tmp2)
 			continue;
+
+		if (!propsize) {
+			printk(KERN_INFO "Buggy OF? Empty ibm,associativity "
+			       "property for %s. Disabling NUMA.\n",
+			       memory->full_name);
+			goto err;
+		}
+
 		numa_domain = tmp2[depth];
 
 		/* FIXME */
diff -purN linux-post-2.6.6-rc2-20040424/drivers/pci/hotplug/rpaphp_core.c linuxppc64-post-2.6.6-rc2-20040424/drivers/pci/hotplug/rpaphp_core.c
--- linux-post-2.6.6-rc2-20040424/drivers/pci/hotplug/rpaphp_core.c	2004-04-11 19:11:18.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/drivers/pci/hotplug/rpaphp_core.c	2004-04-19 01:12:40.000000000 +0000
@@ -54,6 +54,8 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
+void eeh_register_disable_func(int (*)(struct pci_dev *));
+
 module_param(debug, int, 0644);
 
 static int enable_slot(struct hotplug_slot *slot);
@@ -64,6 +66,7 @@ static int get_attention_status(struct h
 static int get_adapter_status(struct hotplug_slot *slot, u8 * value);
 static int get_max_bus_speed(struct hotplug_slot *hotplug_slot, enum pci_bus_speed *value);
 static int get_cur_bus_speed(struct hotplug_slot *hotplug_slot, enum pci_bus_speed *value);
+static int rpaphp_disable_slot(struct pci_dev *dev);
 
 struct hotplug_slot_ops rpaphp_hotplug_slot_ops = {
 	.owner = THIS_MODULE,
@@ -388,12 +391,18 @@ static int __init rpaphp_init(void)
 {
 	info(DRIVER_DESC " version: " DRIVER_VERSION "\n");
 
+	/* let EEH know they can use hotplug */
+	eeh_register_disable_func(&rpaphp_disable_slot);
+
 	/* read all the PRA info from the system */
 	return init_rpa();
 }
 
 static void __exit rpaphp_exit(void)
 {
+	/* let EEH know we are going away */
+	eeh_register_disable_func(NULL);
+
 	cleanup_slots();
 }
 
@@ -428,6 +437,11 @@ static int enable_slot(struct hotplug_sl
 	return retval;
 }
 
+static int rpaphp_disable_slot(struct pci_dev *dev)
+{
+	return disable_slot(rpaphp_find_hotplug_slot(dev));
+}
+
 static int disable_slot(struct hotplug_slot *hotplug_slot)
 {
 	int retval;
diff -purN linux-post-2.6.6-rc2-20040424/drivers/pci/hotplug/rpaphp_pci.c linuxppc64-post-2.6.6-rc2-20040424/drivers/pci/hotplug/rpaphp_pci.c
--- linux-post-2.6.6-rc2-20040424/drivers/pci/hotplug/rpaphp_pci.c	2004-03-30 18:50:32.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/drivers/pci/hotplug/rpaphp_pci.c	2004-04-19 01:12:40.000000000 +0000
@@ -397,3 +397,19 @@ int rpaphp_enable_pci_slot(struct slot *
 	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
 	return retval;
 }
+
+struct hotplug_slot *rpaphp_find_hotplug_slot(struct pci_dev *dev)
+{
+	struct list_head	*tmp, *n;
+	struct slot		*slot;
+
+	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
+		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+		if (slot->dev.pci_dev == dev)
+			return slot->hotplug_slot;
+	}
+
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(rpaphp_find_hotplug_slot);
diff -purN linux-post-2.6.6-rc2-20040424/include/asm-ppc64/hardirq.h linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/hardirq.h
--- linux-post-2.6.6-rc2-20040424/include/asm-ppc64/hardirq.h	2003-09-11 04:07:58.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/hardirq.h	2004-02-18 06:28:00.000000000 +0000
@@ -80,7 +80,8 @@ typedef struct {
 
 #define irq_enter()		(preempt_count() += HARDIRQ_OFFSET)
 
-#ifdef CONFIG_PREEMPT
+#if defined(CONFIG_PREEMPT) || defined(CONFIG_DEBUG_SPINLOCK_SLEEP)
+#include <linux/smp_lock.h>
 # define in_atomic()	((preempt_count() & ~PREEMPT_ACTIVE) != kernel_locked())
 # define IRQ_EXIT_OFFSET (HARDIRQ_OFFSET-1)
 #else
diff -purN linux-post-2.6.6-rc2-20040424/include/asm-ppc64/prom.h linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/prom.h
--- linux-post-2.6.6-rc2-20040424/include/asm-ppc64/prom.h	2004-03-19 05:59:30.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/prom.h	2004-04-24 05:37:46.000000000 +0000
@@ -260,7 +260,6 @@ extern int of_remove_node(struct device_
 /* Other Prototypes */
 extern unsigned long prom_init(unsigned long, unsigned long, unsigned long,
 	unsigned long, unsigned long);
-extern void prom_print(const char *msg);
 extern void relocate_nodes(void);
 extern void finish_device_tree(void);
 extern int device_is_compatible(struct device_node *device, const char *);
diff -purN linux-post-2.6.6-rc2-20040424/include/asm-ppc64/spinlock.h linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/spinlock.h
--- linux-post-2.6.6-rc2-20040424/include/asm-ppc64/spinlock.h	2002-09-10 09:50:15.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/spinlock.h	2004-03-19 03:01:36.000000000 +0000
@@ -4,7 +4,7 @@
 /*
  * Simple spin lock operations.  
  *
- * Copyright (C) 2001 Paul Mackerras <paulus@au.ibm.com>, IBM
+ * Copyright (C) 2001-2004 Paul Mackerras <paulus@au.ibm.com>, IBM
  * Copyright (C) 2001 Anton Blanchard <anton@au.ibm.com>, IBM
  *
  * Type of int is used as a full 64b word is not necessary.
@@ -14,56 +14,72 @@
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  */
+#include <linux/config.h>
+#include <linux/compiler.h>
+#include <linux/threads.h>
+#include <asm/memory.h>
+
 typedef struct {
 	volatile unsigned int lock;
 } spinlock_t;
 
+/*
+ * When we have shared processors, we need to be able to tell
+ * which virtual processor holds the lock, so we can tell the
+ * hypervisor to give our timeslice to them if they are not
+ * currently scheduled on a real processor.  To do this,
+ * we put paca->xPacaIndex + 0x10000 in the lock when it is
+ * held.
+ */
+
 #ifdef __KERNEL__
 #define SPIN_LOCK_UNLOCKED	(spinlock_t) { 0 }
 
 #define spin_is_locked(x)	((x)->lock != 0)
 
-static __inline__ int _raw_spin_trylock(spinlock_t *lock)
+/*
+ * This returns the old value in the lock, so we succeeded
+ * in getting the lock if the return value is 0.
+ */
+static __inline__ int __spin_trylock(spinlock_t *lock)
 {
-	unsigned int tmp;
+	unsigned int tmp, tmp2;
 
 	__asm__ __volatile__(
-"1:	lwarx		%0,0,%1		# spin_trylock\n\
+"1:	lwarx		%0,0,%2		# __spin_trylock\n\
 	cmpwi		0,%0,0\n\
-	li		%0,0\n\
 	bne-		2f\n\
-	li		%0,1\n\
-	stwcx.		%0,0,%1\n\
+	lhz		%1,24(13)\n\
+	oris		%1,%1,1\n\
+	stwcx.		%1,0,%2\n\
 	bne-		1b\n\
 	isync\n\
-2:"	: "=&r"(tmp)
-	: "r"(&lock->lock)
+2:"	: "=&r" (tmp), "=&r" (tmp2)
+	: "r" (&lock->lock)
 	: "cr0", "memory");
 
 	return tmp;
 }
 
-static __inline__ void _raw_spin_lock(spinlock_t *lock)
+static __inline__ int _raw_spin_trylock(spinlock_t *lock)
 {
-	unsigned int tmp;
+	return __spin_trylock(lock) == 0;
+}
 
-	__asm__ __volatile__(
-	"b		2f		# spin_lock\n\
-1:"
-	HMT_LOW
-"	lwzx		%0,0,%1\n\
-	cmpwi		0,%0,0\n\
-	bne+		1b\n"
-	HMT_MEDIUM
-"2:	lwarx		%0,0,%1\n\
-	cmpwi		0,%0,0\n\
-	bne-		1b\n\
-	stwcx.		%2,0,%1\n\
-	bne-		2b\n\
-	isync"
-	: "=&r"(tmp)
-	: "r"(&lock->lock), "r"(1)
-	: "cr0", "memory");
+extern void __spin_yield(spinlock_t *);
+#if !defined(CONFIG_PPC_ISERIES) && !defined(CONFIG_PPC_SPLPAR)
+#define __spin_yield(x)		do { } while (0)
+#endif
+
+static __inline__ void _raw_spin_lock(spinlock_t *lock)
+{
+	while (unlikely(__spin_trylock(lock) != 0)) {
+		do {
+			HMT_low();
+			__spin_yield(lock);
+		} while (likely(lock->lock != 0));
+		HMT_medium();
+	}
 }
 
 static __inline__ void _raw_spin_unlock(spinlock_t *lock)
@@ -81,6 +97,10 @@ static __inline__ void _raw_spin_unlock(
  * can "mix" irq-safe locks - any writer needs to get a
  * irq-safe write-lock, but readers can get non-irqsafe
  * read-locks.
+ *
+ * For a write lock, we store 0x80000000 | paca->xPacaIndex,
+ * so that we can tell who holds the lock, which we need
+ * to know if we are running on shared processors.
  */
 typedef struct {
 	volatile signed int lock;
@@ -88,50 +108,48 @@ typedef struct {
 
 #define RW_LOCK_UNLOCKED (rwlock_t) { 0 }
 
-static __inline__ int _raw_read_trylock(rwlock_t *rw)
+/*
+ * This returns the old value in the lock + 1,
+ * so we got a read lock if the return value is > 0.
+ */
+static __inline__ int __read_trylock(rwlock_t *rw)
 {
-	unsigned int tmp;
-	unsigned int ret;
+	int tmp;
 
 	__asm__ __volatile__(
-"1:	lwarx		%0,0,%2		# read_trylock\n\
-	li		%1,0\n\
+"1:	lwarx		%0,0,%1		# read_trylock\n\
 	extsw		%0,%0\n\
 	addic.		%0,%0,1\n\
 	ble-		2f\n\
-	stwcx.		%0,0,%2\n\
+	stwcx.		%0,0,%1\n\
 	bne-		1b\n\
-	li		%1,1\n\
 	isync\n\
-2:"	: "=&r"(tmp), "=&r"(ret)
-	: "r"(&rw->lock)
-	: "cr0", "memory");
+2:"	: "=&r" (tmp)
+	: "r" (&rw->lock)
+	: "cr0", "xer", "memory");
 
-	return ret;
+	return tmp;
 }
 
-static __inline__ void _raw_read_lock(rwlock_t *rw)
+static __inline__ int _raw_read_trylock(rwlock_t *rw)
 {
-	unsigned int tmp;
+	return __read_trylock(rw) > 0;
+}
 
-	__asm__ __volatile__(
-	"b		2f		# read_lock\n\
-1:"
-	HMT_LOW
-"	lwax		%0,0,%1\n\
-	cmpwi		0,%0,0\n\
-	blt+		1b\n"
-	HMT_MEDIUM
-"2:	lwarx		%0,0,%1\n\
-	extsw		%0,%0\n\
-	addic.		%0,%0,1\n\
-	ble-		1b\n\
-	stwcx.		%0,0,%1\n\
-	bne-		2b\n\
-	isync"
-	: "=&r"(tmp)
-	: "r"(&rw->lock)
-	: "cr0", "memory");
+extern void __rw_yield(rwlock_t *);
+#if !defined(CONFIG_PPC_ISERIES) && !defined(CONFIG_PPC_SPLPAR)
+#define __rw_yield(x)		do { } while (0)
+#endif
+
+static __inline__ void _raw_read_lock(rwlock_t *rw)
+{
+	while (unlikely(__read_trylock(rw) <= 0)) {
+		do {
+			HMT_low();
+			__rw_yield(rw);
+		} while (likely(rw->lock < 0));
+		HMT_medium();
+	}
 }
 
 static __inline__ void _raw_read_unlock(rwlock_t *rw)
@@ -149,48 +167,44 @@ static __inline__ void _raw_read_unlock(
 	: "cr0", "memory");
 }
 
-static __inline__ int _raw_write_trylock(rwlock_t *rw)
+/*
+ * This returns the old value in the lock,
+ * so we got the write lock if the return value is 0.
+ */
+static __inline__ int __write_trylock(rwlock_t *rw)
 {
-	unsigned int tmp;
-	unsigned int ret;
+	int tmp, tmp2;
 
 	__asm__ __volatile__(
 "1:	lwarx		%0,0,%2		# write_trylock\n\
 	cmpwi		0,%0,0\n\
-	li		%1,0\n\
 	bne-		2f\n\
-	stwcx.		%3,0,%2\n\
+	lhz		%1,24(13)\n\
+	oris		%1,%1,0x8000\n\
+	stwcx.		%1,0,%2\n\
 	bne-		1b\n\
-	li		%1,1\n\
 	isync\n\
-2:"	: "=&r"(tmp), "=&r"(ret)
-	: "r"(&rw->lock), "r"(-1)
+2:"	: "=&r" (tmp), "=&r" (tmp2)
+	: "r" (&rw->lock)
 	: "cr0", "memory");
 
-	return ret;
+	return tmp;
 }
 
-static __inline__ void _raw_write_lock(rwlock_t *rw)
+static __inline__ int _raw_write_trylock(rwlock_t *rw)
 {
-	unsigned int tmp;
+	return __write_trylock(rw) == 0;
+}
 
-	__asm__ __volatile__(
-	"b		2f		# write_lock\n\
-1:"
-	HMT_LOW
-	"lwax		%0,0,%1\n\
-	cmpwi		0,%0,0\n\
-	bne+		1b\n"
-	HMT_MEDIUM
-"2:	lwarx		%0,0,%1\n\
-	cmpwi		0,%0,0\n\
-	bne-		1b\n\
-	stwcx.		%2,0,%1\n\
-	bne-		2b\n\
-	isync"
-	: "=&r"(tmp)
-	: "r"(&rw->lock), "r"(-1)
-	: "cr0", "memory");
+static __inline__ void _raw_write_lock(rwlock_t *rw)
+{
+	while (unlikely(__write_trylock(rw) != 0)) {
+		do {
+			HMT_low();
+			__rw_yield(rw);
+		} while (likely(rw->lock != 0));
+		HMT_medium();
+	}
 }
 
 static __inline__ void _raw_write_unlock(rwlock_t *rw)
diff -purN linux-post-2.6.6-rc2-20040424/include/asm-ppc64/xics.h linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/xics.h
--- linux-post-2.6.6-rc2-20040424/include/asm-ppc64/xics.h	2003-03-28 06:31:06.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/include/asm-ppc64/xics.h	2004-04-14 16:04:29.000000000 +0000
@@ -19,6 +19,9 @@ int xics_get_irq(struct pt_regs *);
 void xics_setup_cpu(void);
 void xics_cause_IPI(int cpu);
 
+/* first argument is ignored */
+void pSeriesLP_cppr_info(int n_cpu, u8 value);
+
 struct xics_ipi_struct {
 	volatile unsigned long value;
 } ____cacheline_aligned;
diff -purN linux-post-2.6.6-rc2-20040424/include/linux/preempt.h linuxppc64-post-2.6.6-rc2-20040424/include/linux/preempt.h
--- linux-post-2.6.6-rc2-20040424/include/linux/preempt.h	2004-02-25 10:42:02.000000000 +0000
+++ linuxppc64-post-2.6.6-rc2-20040424/include/linux/preempt.h	2004-02-26 05:42:10.000000000 +0000
@@ -25,6 +25,17 @@ do { \
 
 asmlinkage void preempt_schedule(void);
 
+#define preempt_check_resched() \
+do { \
+	if (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \
+		preempt_schedule(); \
+} while (0)
+#else
+#define preempt_check_resched()		do { } while (0)
+#endif
+
+#if defined(CONFIG_PREEMPT) || defined(CONFIG_DEBUG_SPINLOCK_SLEEP)
+
 #define preempt_disable() \
 do { \
 	inc_preempt_count(); \
@@ -37,12 +48,6 @@ do { \
 	dec_preempt_count(); \
 } while (0)
 
-#define preempt_check_resched() \
-do { \
-	if (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \
-		preempt_schedule(); \
-} while (0)
-
 #define preempt_enable() \
 do { \
 	preempt_enable_no_resched(); \
