Index: linux/arch/ia64/sn/io/sn2/ml_SN_intr.c
===================================================================
--- linux.orig/arch/ia64/sn/io/sn2/ml_SN_intr.c	2004-05-12 11:36:39.000000000 -0500
+++ linux/arch/ia64/sn/io/sn2/ml_SN_intr.c	2004-05-12 11:38:20.000000000 -0500
@@ -12,6 +12,7 @@
 #include <asm/smp.h>
 #include <asm/irq.h>
 #include <asm/hw_irq.h>
+#include <asm/topology.h>
 #include <asm/sn/sgi.h>
 #include <asm/sn/iograph.h>
 #include <asm/sn/hcl.h>
@@ -43,7 +44,6 @@
 	sh_ii_int0_config_u_t		ii_int_config;
 	cpuid_t				cpu;
 	cpuid_t				cpu0, cpu1;
-	nodepda_t			*lnodepda;
 	sh_ii_int0_enable_u_t		ii_int_enable;
 	sh_int_node_id_config_u_t	node_id_config;
 	sh_local_int5_config_u_t	local5_config;
@@ -60,15 +60,13 @@
 		HUB_S((unsigned long *)GLOBAL_MMR_ADDR(nasid, SH_INT_NODE_ID_CONFIG),
 			node_id_config.sh_int_node_id_config_regval);
 		cnode = nasid_to_cnodeid(master_nasid);
-		lnodepda = NODEPDA(cnode);
-		cpu = lnodepda->node_first_cpu;
+		cpu = first_cpu(node_to_cpumask(cnode));
 		cpu = cpu_physical_id(cpu);
 		SAL_CALL(ret_stuff, SN_SAL_REGISTER_CE, nasid, cpu, master_nasid,0,0,0,0);
 		if (ret_stuff.status < 0)
 			printk("%s: SN_SAL_REGISTER_CE SAL_CALL failed\n",__FUNCTION__);
 	} else {
-		lnodepda = NODEPDA(node);
-		cpu = lnodepda->node_first_cpu;
+		cpu = first_cpu(node_to_cpumask(node));
 		cpu = cpu_physical_id(cpu);
 	}
 
Index: linux/arch/ia64/sn/kernel/setup.c
===================================================================
--- linux.orig/arch/ia64/sn/kernel/setup.c	2004-05-12 11:36:39.000000000 -0500
+++ linux/arch/ia64/sn/kernel/setup.c	2004-05-12 11:38:10.000000000 -0500
@@ -457,10 +457,6 @@
 	}
 	pda->shub_1_1_found = shub_1_1_found;
 	
-	if (local_node_data->active_cpu_count == 1)
-		nodepda->node_first_cpu = cpuid;
-
-
 
 	/*
 	 * We must use different memory allocators for first cpu (bootmem 
@@ -480,7 +476,7 @@
 	pda->mem_write_status_addr = (volatile u64 *)
 			LOCAL_MMR_ADDR((slice < 2 ? SH_MEMORY_WRITE_STATUS_0 : SH_MEMORY_WRITE_STATUS_1 ) );
 
-	if (nodepda->node_first_cpu == cpuid) {
+	if (local_node_data->active_cpu_count++ == 0) {
 		int	buddy_nasid;
 		buddy_nasid = cnodeid_to_nasid(numa_node_id() == numnodes-1 ? 0 : numa_node_id()+ 1);
 		pda->pio_shub_war_cam_addr = (volatile unsigned long*)GLOBAL_MMR_ADDR(nasid, SH_PI_CAM_CONTROL);
Index: linux/drivers/char/sn_serial.c
===================================================================
--- linux.orig/drivers/char/sn_serial.c	2004-05-12 11:36:39.000000000 -0500
+++ linux/drivers/char/sn_serial.c	2004-05-12 11:38:20.000000000 -0500
@@ -537,7 +537,7 @@
 	int result;
 
 	console_nasid = ia64_sn_get_console_nasid();
-	intr_cpuid = NODEPDA(NASID_TO_COMPACT_NODEID(console_nasid))->node_first_cpu;
+	intr_cpuid = first_cpu(node_to_cpumask(NASID_TO_COMPACT_NODEID(console_nasid)));
 	intr_cpuloc = cpu_physical_id(intr_cpuid);
 	console_irq = CPU_VECTOR_TO_IRQ(intr_cpuloc, SGI_UART_VECTOR);
 
Index: linux/include/asm-ia64/sn/arch.h
===================================================================
--- linux.orig/include/asm-ia64/sn/arch.h	2004-05-12 11:36:39.000000000 -0500
+++ linux/include/asm-ia64/sn/arch.h	2004-05-12 11:38:20.000000000 -0500
@@ -21,8 +21,6 @@
 typedef u64	mmr_t;
 typedef u64	nic_t;
 
-#define CNODE_TO_CPU_BASE(_cnode)	(NODEPDA(_cnode)->node_first_cpu)
-
 #define NASID_TO_COMPACT_NODEID(nasid)  (nasid_to_cnodeid(nasid))
 #define COMPACT_TO_NASID_NODEID(cnode)  (cnodeid_to_nasid(cnode))
 
@@ -35,9 +33,7 @@
 #define	INVALID_PARTID		((partid_t)-1)
 
 extern cpuid_t cnodetocpu(cnodeid_t);
-void   sn_flush_all_caches(long addr, long bytes);
-
-extern int     is_fine_dirmode(void);
-
+extern void sn_flush_all_caches(long addr, long bytes);
+extern int is_fine_dirmode(void);
 
 #endif /* _ASM_IA64_SN_ARCH_H */
Index: linux/include/asm-ia64/sn/nodepda.h
===================================================================
--- linux.orig/include/asm-ia64/sn/nodepda.h	2004-05-12 11:36:39.000000000 -0500
+++ linux/include/asm-ia64/sn/nodepda.h	2004-05-12 11:38:10.000000000 -0500
@@ -36,13 +36,6 @@
 
 
 struct nodepda_s {
-
-
-	cpuid_t         node_first_cpu; /* Starting cpu number for node */
-					/* WARNING: no guarantee that   */
-					/*  the second cpu on a node is */
-					/*  node_first_cpu+1.           */
-
 	vertex_hdl_t 	xbow_vhdl;
 	nasid_t		xbow_peer;	/* NASID of our peer hub on xbow */
 	struct semaphore xbow_sema;	/* Sema for xbow synchronization */
