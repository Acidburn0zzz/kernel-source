# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
# This patch format is intended for GNU patch command version 2.5 or higher.
# This patch includes the following deltas:
#	           ChangeSet	1.1510  -> 1.1515 
#	arch/i386/kernel/process.c	1.51.1.6 -> 1.57   
#	include/asm-x86_64/agp.h	1.2     -> 1.4    
#	arch/ppc64/kernel/signal.c	1.28    -> 1.29   
#	drivers/input/serio/i8042-io.h	1.4.1.1 -> 1.6    
#	include/asm-parisc/unistd.h	1.8.1.1 -> 1.11   
#	arch/sparc/kernel/module.c	1.11    -> 1.12   
#	include/asm-ppc64/page.h	1.19.1.1 -> 1.22   
#	include/asm-i386/agp.h	1.1.1.1 -> 1.4    
#	include/asm-generic/sections.h	1.2     -> 1.3    
#	arch/alpha/kernel/module.c	1.5     -> 1.6    
#	include/asm-ppc64/unistd.h	1.20.1.2 -> 1.26   
#	arch/ppc64/kernel/entry.S	1.26.1.1 -> 1.29   
#	include/asm-mips/unistd.h	1.6.1.2 -> 1.10   
#	include/asm-alpha/agp.h	1.2     -> 1.4    
#	         fs/select.c	1.20.1.1 -> 1.22   
#	include/linux/timex.h	1.5.1.3 -> 1.11   
#	include/asm-alpha/hw_irq.h	1.2     -> 1.4    
#	  include/linux/mm.h	1.121.1.12 -> 1.127  
#	include/linux/init.h	1.26.1.1 -> 1.28   
#	arch/arm/kernel/module.c	1.7     -> 1.8    
#	drivers/serial/8250.c	1.34.1.6 -> 1.36   
#	include/asm-ia64/io.h	1.13.1.4 -> 1.19   
#	arch/ppc64/kernel/udbg.c	1.8     -> 1.10   
#	include/asm-ppc64/processor.h	1.30.1.2 -> 1.33   
#	include/asm-i386/ptrace.h	1.5     -> 1.7    
#	include/asm-sparc/unistd.h	1.20.1.6 -> 1.26   
#	 arch/ia64/defconfig	1.19.1.1 -> 1.21   
#	drivers/char/drm/i830_dma.c	1.18.1.1 -> 1.20   
#	       kernel/fork.c	1.124.1.20 -> 1.132  
#	include/linux/sched.h	1.151.1.19 -> 1.162  
#	net/sunrpc/svcsock.c	1.62    -> 1.63   
#	include/asm-ppc64/module.h	1.4     -> 1.6    
#	        kernel/sys.c	1.43.1.20 -> 1.52   
#	     kernel/sysctl.c	1.46.1.9 -> 1.52   
#	include/asm-ia64/unistd.h	1.36    -> 1.37   
#	include/asm-ppc64/thread_info.h	1.7.1.1 -> 1.9    
#	include/asm-ppc64/ucontext.h	1.3     -> 1.5    
#	include/asm-sparc64/agp.h	1.1     -> 1.3    
#	arch/ppc64/kernel/chrp_setup.c	1.29.1.2 -> 1.33   
#	include/asm-i386/thread_info.h	1.11.1.2 -> 1.14   
#	arch/ppc64/kernel/rtas.c	1.11.1.1 -> 1.14   
#	drivers/char/drm/r128_cce.c	1.12.1.3 -> 1.16   
#	drivers/char/drm/drm_memory_debug.h	1.1.1.4 -> 1.5    
#	include/asm-sparc64/unistd.h	1.19.1.6 -> 1.25   
#	arch/i386/kernel/traps.c	1.52.1.8 -> 1.58   
#	drivers/char/drm/drm_memory.h	1.8.1.6 -> 1.13   
#	arch/i386/kernel/Makefile	1.44.1.8 -> 1.50   
#	drivers/char/drm/radeon_cp.c	1.20.1.1 -> 1.22   
#	include/asm-ppc/unistd.h	1.23.1.3 -> 1.27   
#	include/asm-ia64/sn/nodepda.h	1.9     -> 1.10   
#	include/asm-ppc64/sigcontext.h	1.4     -> 1.6    
#	include/linux/serial.h	1.8.1.1 -> 1.10   
#	include/asm-ppc/pgtable.h	1.23.1.3 -> 1.26   
#	include/asm-ppc/thread_info.h	1.7.1.3 -> 1.11   
#	       kernel/time.c	1.11.1.6 -> 1.18   
#	drivers/char/drm/drm_bufs.h	1.14.1.2 -> 1.17   
#	    kernel/softirq.c	1.39.1.8 -> 1.44   
#	arch/ppc64/kernel/LparData.c	1.9     -> 1.11   
#	arch/ia64/sn/kernel/setup.c	1.19    -> 1.20   
#	drivers/net/tulip/media.c	1.11    -> 1.12   
#	arch/ppc/kernel/module.c	1.9.1.1 -> 1.11   
#	drivers/acpi/pci_root.c	1.13.1.3 -> 1.17   
#	include/asm-ppc64/types.h	1.3     -> 1.5    
#	arch/ppc64/kernel/ras.c	1.5     -> 1.7    
#	include/asm-ia64/uaccess.h	1.12    -> 1.13   
#	include/asm-parisc/thread_info.h	1.2.1.1 -> 1.4    
#	include/asm-um/thread_info.h	1.3.1.1 -> 1.5    
#	drivers/char/drm/i810_dma.c	1.26.1.4 -> 1.31   
#	include/asm-h8300/thread_info.h	1.1.1.2 -> 1.4    
#	include/asm-ia64/numa.h	1.9     -> 1.10   
#	include/linux/nfs_fs.h	1.45.1.6 -> 1.49   
#	drivers/media/video/Makefile	1.18.1.3 -> 1.22   
#	include/asm-v850/thread_info.h	1.2.1.1 -> 1.4    
#	include/asm-ppc64/proc_fs.h	1.2     -> 1.4    
#	           mm/swap.c	1.52.1.1 -> 1.55   
#	drivers/acpi/tables.c	1.14.1.2 -> 1.17   
#	include/linux/pci_ids.h	1.103.1.20 -> 1.110  
#	 include/linux/irq.h	1.6.1.3 -> 1.12   
#	include/linux/moduleloader.h	1.6     -> 1.7    
#	include/asm-alpha/unistd.h	1.18.1.4 -> 1.23   
#	 arch/ia64/mm/init.c	1.48    -> 1.49   
#	include/asm-m68knommu/thread_info.h	1.2.1.1 -> 1.4    
#	arch/ppc64/kernel/irq.c	1.30.1.3 -> 1.33   
#	drivers/acpi/pci_irq.c	1.16.1.6 -> 1.23   
#	         mm/memory.c	1.123.1.16 -> 1.134  
#	include/linux/moduleparam.h	1.3.1.1 -> 1.5    
#	arch/ppc64/kernel/rtas-proc.c	1.6     -> 1.8    
#	arch/ppc64/kernel/setup.c	1.28.1.3 -> 1.32   
#	 include/linux/pci.h	1.90.1.18 -> 1.98   
#	include/asm-arm/thread_info.h	1.6.1.2 -> 1.9    
#	arch/ia64/kernel/process.c	1.39.1.7 -> 1.47   
#	include/asm-m68k/unistd.h	1.8     -> 1.10   
#	arch/i386/kernel/module.c	1.11    -> 1.12   
#	arch/ia64/kernel/acpi.c	1.52    -> 1.53   
#	drivers/serial/Makefile	1.14.1.6 -> 1.22   
#	include/asm-ppc64/naca.h	1.6     -> 1.8    
#	include/asm-h8300/unistd.h	1.1.1.1 -> 1.4    
#	include/linux/acpi_serial.h	1.2.1.1 -> 1.4    
#	  drivers/char/mem.c	1.42.1.2 -> 1.45   
#	arch/ppc64/kernel/traps.c	1.19.1.1 -> 1.21   
#	include/asm-m68knommu/unistd.h	1.2     -> 1.4    
#	kernel/posix-timers.c	1.19.1.2 -> 1.22   
#	arch/ppc64/kernel/head.S	1.36.1.2 -> 1.39   
#	arch/ia64/mm/hugetlbpage.c	1.14    -> 1.15   
#	include/asm-ppc64/xics.h	1.5     -> 1.7    
#	include/linux/sunrpc/svc.h	1.20.1.5 -> 1.26   
#	include/linux/sysctl.h	1.47.1.5 -> 1.52   
#	arch/ppc64/kernel/xics.c	1.25.1.3 -> 1.28   
#	   drivers/net/tg3.c	1.72.1.35 -> 1.78   
#	 include/linux/smp.h	1.22.1.4 -> 1.25   
#	        usr/Makefile	1.6.1.3 -> 1.10   
#	arch/v850/kernel/module.c	1.5     -> 1.6    
#	drivers/media/radio/Makefile	1.9     -> 1.10   
#	arch/ppc64/kernel/htab.c	1.34.1.2 -> 1.37   
#	arch/ppc64/mm/init.c	1.46.1.6 -> 1.53   
#	arch/ppc64/kernel/open_pic.c	1.15.1.1 -> 1.17   
#	drivers/char/agp/i460-agp.c	1.25.1.3 -> 1.30   
#	arch/ppc64/kernel/process.c	1.35.1.6 -> 1.40   
#	arch/ppc64/kernel/pci_dma.c	1.16    -> 1.17   
#	arch/ia64/ia32/sys_ia32.c	1.79    -> 1.82   
#	           mm/mmap.c	1.85.1.7 -> 1.90   
#	      fs/proc/base.c	1.42.1.17 -> 1.51   
#	include/linux/time.h	1.16.1.5 -> 1.20   
#	arch/sparc64/kernel/module.c	1.14.1.2 -> 1.16   
#	arch/ppc64/kernel/open_pic_defs.h	1.2     -> 1.4    
#	include/asm-i386/unistd.h	1.25.1.5 -> 1.31   
#	sound/oss/cs4281/cs4281pm-24.c	1.3.1.1 -> 1.5    
#	arch/ppc64/kernel/asm-offsets.c	1.14.1.1 -> 1.17   
#	include/asm-m68k/thread_info.h	1.4.1.1 -> 1.6    
#	            Makefile	1.410.1.25 -> 1.422  
#	          fs/fcntl.c	1.28.1.3 -> 1.31   
#	include/asm-s390/thread_info.h	1.4.1.1 -> 1.6    
#	include/asm-x86_64/unistd.h	1.14.1.4 -> 1.20   
#	include/asm-ppc64/mmu.h	1.7.1.1 -> 1.10   
#	arch/ppc64/mm/numa.c	1.7.1.3 -> 1.10   
#	drivers/char/agp/backend.c	1.83.1.7 -> 1.87   
#	arch/ppc64/kernel/syscalls.c	1.11.1.2 -> 1.15   
#	include/asm-x86_64/thread_info.h	1.12.1.1 -> 1.14   
#	include/asm-ppc64/ptrace.h	1.2     -> 1.4    
#	arch/ppc64/kernel/sys_ppc32.c	1.66.1.4 -> 1.68   
#	include/asm-sparc64/thread_info.h	1.10.1.2 -> 1.13   
#	arch/ppc64/kernel/prom.c	1.28.1.3 -> 1.33   
#	     kernel/module.c	1.86.1.7 -> 1.93   
#	include/asm-x86_64/pgtable.h	1.21.1.2 -> 1.24   
#	arch/ppc64/kernel/iSeries_setup.c	1.15.1.1 -> 1.18   
#	arch/ppc64/kernel/smp.c	1.40.1.2 -> 1.43   
#	drivers/char/drm/drmP.h	1.23.1.6 -> 1.28   
#	arch/ia64/sn/io/sn2/ml_SN_intr.c	1.6     -> 1.7    
#	include/asm-i386/pgtable.h	1.35.1.3 -> 1.39   
#	net/ipv4/tcp_input.c	1.39.1.7 -> 1.44   
#	arch/ppc64/mm/fault.c	1.10.1.2 -> 1.14   
#	include/linux/highmem.h	1.25.1.2 -> 1.28   
#	arch/ppc64/kernel/pacaData.c	1.7.1.1 -> 1.10   
#	arch/ia64/sn/io/machvec/pci_bus_cvlink.c	1.13    -> 1.14   
#	           mm/slab.c	1.93.1.14 -> 1.100  
#	include/linux/module.h	1.66.1.2 -> 1.70   
#	      kernel/sched.c	1.193.1.27 -> 1.203  
#	drivers/char/agp/hp-agp.c	1.24.1.3 -> 1.30   
#	  drivers/acpi/osl.c	1.37.1.5 -> 1.43   
#	 include/linux/jbd.h	1.21.1.17 -> 1.25   
#	arch/alpha/kernel/traps.c	1.24.1.3 -> 1.28   
#	drivers/char/drm/drm_drv.h	1.20.1.5 -> 1.25   
#	      kernel/timer.c	1.59.1.9 -> 1.68   
#	drivers/scsi/sym53c8xx_2/sym_malloc.c	1.2     -> 1.4    
#	arch/ppc64/xmon/xmon.c	1.26.1.3 -> 1.30   
#	arch/ppc64/kernel/pci.c	1.33.1.2 -> 1.37   
#	include/asm-sh/unistd.h	1.5.1.1 -> 1.8    
#	include/asm-m68k/pgtable.h	1.8.1.1 -> 1.10   
#	arch/ppc64/kernel/misc.S	1.62    -> 1.63   
#	drivers/char/drm/mga_dma.c	1.13.1.1 -> 1.15   
#	arch/s390/kernel/module.c	1.8.1.2 -> 1.11   
#	drivers/char/drm/mga_drv.h	1.13.1.1 -> 1.15   
#	arch/x86_64/kernel/module.c	1.9.1.2 -> 1.12   
#	arch/arm/kernel/process.c	1.28.1.4 -> 1.31   
#	include/linux/percpu.h	1.5.1.2 -> 1.7    
#	include/asm-alpha/thread_info.h	1.5.1.1 -> 1.7    
#	arch/ppc64/kernel/signal32.c	1.40    -> 1.42   
#	include/asm-cris/unistd.h	1.10.1.1 -> 1.13   
#	drivers/serial/Kconfig	1.8.1.11 -> 1.17   
#	drivers/char/drm/gamma_dma.c	1.12.1.4 -> 1.16   
#	arch/ppc64/kernel/rtas_flash.c	1.5     -> 1.7    
#	    net/sunrpc/svc.c	1.21.1.1 -> 1.23   
#	include/linux/irq_cpustat.h	1.7.1.3 -> 1.10   
#	include/asm-arm/unistd.h	1.16.1.2 -> 1.20   
#	   arch/ia64/Kconfig	1.38.1.8 -> 1.44   
#	include/asm-ppc64/pgtable.h	1.23.1.2 -> 1.25   
#	include/asm-ppc64/mmzone.h	1.11.1.2 -> 1.14   
#	include/asm-sparc/thread_info.h	1.4.1.1 -> 1.6    
#	include/asm-ppc64/io.h	1.8     -> 1.10   
#	drivers/video/radeonfb.c	1.26.1.4 -> 1.29   
#	include/asm-v850/unistd.h	1.6     -> 1.8    
#	include/asm-ppc64/topology.h	1.8.1.1 -> 1.10   
#	   kernel/kallsyms.c	1.11.1.3 -> 1.15   
#	arch/ppc64/kernel/Makefile	1.27.1.1 -> 1.30   
#	arch/ppc64/kernel/module.c	1.6     -> 1.7    
#	include/asm-ppc64/rtas.h	1.6.1.1 -> 1.9    
#	include/asm-i386/hw_irq.h	1.21.1.3 -> 1.26   
#	sound/oss/cs4281/cs4281m.c	1.21.1.5 -> 1.25   
#	arch/ppc64/kernel/align.c	1.10    -> 1.11   
#	     kernel/printk.c	1.25.1.3 -> 1.30   
#	arch/ppc64/kernel/ioctl32.c	1.35.1.3 -> 1.39   
#	drivers/scsi/qla1280.c	1.38.1.12 -> 1.43   
#	arch/ppc64/kernel/pSeries_lpar.c	1.21.1.1 -> 1.24   
#	drivers/char/drm/drm_vm.h	1.23.1.2 -> 1.26   
#	include/asm-s390/unistd.h	1.16.1.1 -> 1.19   
#	arch/parisc/kernel/module.c	1.5.1.3 -> 1.8    
#	drivers/scsi/sym53c8xx_2/sym_glue.c	1.23.1.15 -> 1.29   
#	               (new)	        -> 1.1     drivers/media/video/dummy.c
#	               (new)	        -> 1.1     drivers/media/radio/dummy.c
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 03/10/08	janetmor@us.ibm.com	1.1217.8.34
# [PATCH] ia64: sys_ia32.c fix for epoll
# 
# I ran into some bugs testing epoll in ia32-emulation mode on ia64.
# The attached patch fixes the problems and is well tested.
# Here is a summary of the changes:
# 
# Changes to sys32_epoll_ctl() and sys32_epoll_wait():
# - changed epoll_event32.data to an array (this is subjective, but seems
# to make the code more readable)
# 
# Changes to sys32_epoll_wait():
# - added call to __get_free_pages if kmalloc(epoll_event array) fails.  This
#   provides needed scalability and fixes the -ENOMEM failure during
# epoll-pipetest.
# - deleted copy-in of epoll_event array since this is not a user-inputsyscall
# - changed to check numevents > 0 as indicator of success on call to
#   sys_epoll_wait.
# - changed to loop on numevents not maxevents when copying out to userspace.
# --------------------------------------------
# 03/10/09	jbarnes@sgi.com	1.1511
# [PATCH] ia64: fix NUMA page table allocation to get memory from the right node
# 
# --------------------------------------------
# 03/10/09	jbarnes@sgi.com	1.1217.8.35
# [PATCH] ia64: fix SN2 code for GENERIC builds
# 
# Don't try to use the sn2 I/O code if we're not on sn2 or we may get into
# trouble.  Only makes a difference for generic kernels.
# --------------------------------------------
# 03/10/09	jbarnes@sgi.com	1.1217.8.36
# [PATCH] ia64: fix is_headless_node() for systems w/<64p
# 
# I didn't realize that any_online_cpu() wouldn't work for
# is_headless_node(), so this patch reverts the function back to using the
# node_to_cpu_mask[] array, fixing sn2 for systems with less than 64p.
# --------------------------------------------
# 03/10/09	jbarnes@sgi.com	1.1217.8.37
# [PATCH] ia64: early SN setup fix
# 
# Small fix to build early_sn_setup even if early printk is turned off.
# --------------------------------------------
# 03/10/09	jbarnes@sgi.com	1.1217.8.38
# [PATCH] ia64: deal with lack of SRAT in GENERIC kernels
# 
# n platforms without an SRAT (e.g. zx1), the cpu_to_node_map will get
# built incorrectly without this fix, making generic kernels fail when
# they try to alloc_pages_node() from a nodeid of -1.
# --------------------------------------------
# 03/10/09	kenneth.w.chen@intel.com	1.1217.8.39
# [PATCH] ia64: fix NUMA hugetlb support
# 
# Here is a patch that adds numa support for hugetlb page on ia64.  It is
# taken from x86 numa implementation.  The low level hugetlb page
# pre-allocation is done in round robin fashion on each numa node and
# allocation for user level code is node local aware.
# --------------------------------------------
# 03/10/09	davidm@tiger.hpl.hp.com	1.1512
# Merge tiger.hpl.hp.com:/data1/bk/vanilla/linux-2.5
# into tiger.hpl.hp.com:/data1/bk/lia64/to-linus-2.5
# --------------------------------------------
# 03/10/09	davidm@tiger.hpl.hp.com	1.1513
# Merge with 2.6.0-test7.
# --------------------------------------------
# 03/10/09	peterc@chubb.wattle.id.au	1.1512.1.1
# [PATCH] ia64: drop stale check for GAS_HAS_LOCAL_TAGS
# 
# GAS_HAS_LOCAL_TAGS was removed a long time ago, but uaccess.h never got
# updated.  Without this fix, bad syscall args may cause a SEGFAULT instead
# of failing gracefully.
# --------------------------------------------
# 03/10/09	davidm@tiger.hpl.hp.com	1.1514
# Merge tiger.hpl.hp.com:/data1/bk/lia64/to-linus-2.5
# into tiger.hpl.hp.com:/data1/bk/lia64/linux-ia64-2.5
# --------------------------------------------
# 03/10/09	arun.sharma@intel.com	1.1512.1.2
# [PATCH] ia64: fix ia32 epoll emulation warnings
# 
# --------------------------------------------
# 03/10/10	arun.sharma@intel.com	1.1512.1.3
# [PATCH] ia64: Fix unaligned faults in IA-32 putstat64
# 
# This seems to be introduced by recent changes in 2.6.0-test series.
# --------------------------------------------
# 03/10/10	jbarnes@sgi.com	1.1512.1.4
# [PATCH] ia64: fix SN2 interrupt allocation
# 
# Patch from Christoph.  Fixes interrupt allocation code for sn2.
# --------------------------------------------
# 03/10/10	schwab@suse.de	1.1512.1.5
# [PATCH] ia64: fix misnamed syscalls
# 
# This fixes a misnomer of some syscalls in 2.6.0-test[567].  Glibc wants
# them without the sys_ infix.
# --------------------------------------------
# 03/10/10	davidm@tiger.hpl.hp.com	1.1515
# Merge tiger.hpl.hp.com:/data1/bk/lia64/to-linus-2.5
# into tiger.hpl.hp.com:/data1/bk/lia64/linux-ia64-2.5
# --------------------------------------------
#
diff -Nru a/arch/ia64/Kconfig b/arch/ia64/Kconfig
--- a/arch/ia64/Kconfig	Sat Oct 11 00:44:48 2003
+++ b/arch/ia64/Kconfig	Sat Oct 11 00:44:48 2003
@@ -637,6 +637,33 @@
 	  keys are documented in <file:Documentation/sysrq.txt>. Don't say Y
 	  unless you really know what this hack does.
 
+config IA64_EARLY_PRINTK
+	bool "Early printk support"
+	depends on DEBUG_KERNEL && !IA64_GENERIC
+	help
+	  Selecting this option uses the VGA screen or serial console for
+	  printk() output before the consoles are initialised.  It is useful
+	  for debugging problems early in the boot process, but only if you
+	  have a suitable VGA/serial console attached.  If you're unsure,
+	  select N.
+
+config IA64_EARLY_PRINTK_UART
+	bool "Early printk on MMIO serial port"
+	depends on IA64_EARLY_PRINTK
+
+config IA64_EARLY_PRINTK_UART_BASE
+	hex "UART MMIO base address"
+	depends on IA64_EARLY_PRINTK_UART
+	default "ff5e0000"
+
+config IA64_EARLY_PRINTK_VGA
+	bool "Early printk on VGA"
+	depends on IA64_EARLY_PRINTK
+
+config IA64_EARLY_PRINTK_SGI_SN
+	bool "Early printk on SGI SN serial console"
+	depends on IA64_EARLY_PRINTK && (IA64_GENERIC || IA64_SGI_SN2)
+
 config DEBUG_SLAB
 	bool "Debug memory allocations"
 	depends on DEBUG_KERNEL
diff -Nru a/arch/ia64/ia32/sys_ia32.c b/arch/ia64/ia32/sys_ia32.c
--- a/arch/ia64/ia32/sys_ia32.c	Sat Oct 11 00:44:48 2003
+++ b/arch/ia64/ia32/sys_ia32.c	Sat Oct 11 00:44:48 2003
@@ -2486,11 +2486,14 @@
 putstat64 (struct stat64 *ubuf, struct kstat *kbuf)
 {
 	int err;
+	u64 hdev;
 
 	if (clear_user(ubuf, sizeof(*ubuf)))
 		return -EFAULT;
 
-	err  = __put_user(huge_encode_dev(kbuf->dev), &ubuf->st_dev);
+	hdev = huge_encode_dev(kbuf->dev);
+	err  = __put_user(hdev, (u32*)&ubuf->st_dev);
+	err |= __put_user(hdev >> 32, ((u32*)&ubuf->st_dev) + 1);
 	err |= __put_user(kbuf->ino, &ubuf->__st_ino);
 	err |= __put_user(kbuf->ino, &ubuf->st_ino_lo);
 	err |= __put_user(kbuf->ino >> 32, &ubuf->st_ino_hi);
@@ -2498,7 +2501,9 @@
 	err |= __put_user(kbuf->nlink, &ubuf->st_nlink);
 	err |= __put_user(kbuf->uid, &ubuf->st_uid);
 	err |= __put_user(kbuf->gid, &ubuf->st_gid);
-	err |= __put_user(huge_encode_dev(kbuf->rdev), &ubuf->st_rdev);
+	hdev = huge_encode_dev(kbuf->rdev);
+	err  = __put_user(hdev, (u32*)&ubuf->st_rdev);
+	err |= __put_user(hdev >> 32, ((u32*)&ubuf->st_rdev) + 1);
 	err |= __put_user(kbuf->size, &ubuf->st_size_lo);
 	err |= __put_user((kbuf->size >> 32), &ubuf->st_size_hi);
 	err |= __put_user(kbuf->atime.tv_sec, &ubuf->st_atime);
@@ -2724,8 +2729,8 @@
 struct epoll_event32
 {
 	u32 events;
-	u64 data;
-} __attribute__((packed));
+	u32 data[2];
+}; 
 
 asmlinkage long
 sys32_epoll_ctl(int epfd, int op, int fd, struct epoll_event32 *event)
@@ -2740,10 +2745,10 @@
 		return error;
 
 	__get_user(event64.events, &event->events);
-	__get_user(data_halfword, (u32*)(&event->data));
+	__get_user(data_halfword, &event->data[0]);
 	event64.data = data_halfword;
-	__get_user(data_halfword, ((u32*)(&event->data) + 1));
- 	event64.data |= ((u64)data_halfword) << 32;
+	__get_user(data_halfword, &event->data[1]);
+ 	event64.data |= (u64)data_halfword << 32;
 
 	set_fs(KERNEL_DS);
 	error = sys_epoll_ctl(epfd, op, fd, &event64);
@@ -2758,8 +2763,9 @@
 {
 	struct epoll_event *events64 = NULL;
 	mm_segment_t old_fs = get_fs();
-	int error;
+	int error, numevents, size;
 	int evt_idx;
+	int do_free_pages = 0;
 
 	if (maxevents <= 0) {
 		return -EINVAL;
@@ -2770,43 +2776,45 @@
 				 maxevents * sizeof(struct epoll_event32))))
 		return error;
 
-	/* Allocate the space needed for the intermediate copy */
-	events64 = kmalloc(maxevents * sizeof(struct epoll_event), GFP_KERNEL);
+	/* 
+ 	 * Allocate space for the intermediate copy.  If the space needed 
+	 * is large enough to cause kmalloc to fail, then try again with
+	 * __get_free_pages.
+	 */
+	size = maxevents * sizeof(struct epoll_event);
+	events64 = kmalloc(size, GFP_KERNEL);
 	if (events64 == NULL) {
-		return -ENOMEM;
-	}
-
-	/* Expand the 32-bit structures into the 64-bit structures */
-	for (evt_idx = 0; evt_idx < maxevents; evt_idx++) {
-		u32 data_halfword;
-		__get_user(events64[evt_idx].events, &events[evt_idx].events);
-		__get_user(data_halfword, (u32*)(&events[evt_idx].data));
-		events64[evt_idx].data = data_halfword;
-		__get_user(data_halfword, ((u32*)(&events[evt_idx].data) + 1));
-		events64[evt_idx].data |= ((u64)data_halfword) << 32;
+		events64 = (struct epoll_event *)
+				__get_free_pages(GFP_KERNEL, get_order(size));
+		if (events64 == NULL) 
+			return -ENOMEM;
+		do_free_pages = 1;
 	}
 
 	/* Do the system call */
 	set_fs(KERNEL_DS); /* copy_to/from_user should work on kernel mem*/
-	error = sys_epoll_wait(epfd, events64, maxevents, timeout);
+	numevents = sys_epoll_wait(epfd, events64, maxevents, timeout);
 	set_fs(old_fs);
 
 	/* Don't modify userspace memory if we're returning an error */
-	if (!error) {
+	if (numevents > 0) {
 		/* Translate the 64-bit structures back into the 32-bit
 		   structures */
-		for (evt_idx = 0; evt_idx < maxevents; evt_idx++) {
+		for (evt_idx = 0; evt_idx < numevents; evt_idx++) {
 			__put_user(events64[evt_idx].events,
 				   &events[evt_idx].events);
-			__put_user((u32)(events64[evt_idx].data),
-				   (u32*)(&events[evt_idx].data));
+			__put_user((u32)events64[evt_idx].data,
+				   &events[evt_idx].data[0]);
 			__put_user((u32)(events64[evt_idx].data >> 32),
-				   ((u32*)(&events[evt_idx].data) + 1));
+				   &events[evt_idx].data[1]);
 		}
 	}
 
-	kfree(events64);
-	return error;
+	if (do_free_pages)
+		free_pages((unsigned long) events64, get_order(size));
+	else
+		kfree(events64);
+	return numevents;
 }
 
 #ifdef	NOTYET  /* UNTESTED FOR IA64 FROM HERE DOWN */
diff -Nru a/arch/ia64/kernel/acpi.c b/arch/ia64/kernel/acpi.c
--- a/arch/ia64/kernel/acpi.c	Sat Oct 11 00:44:48 2003
+++ b/arch/ia64/kernel/acpi.c	Sat Oct 11 00:44:48 2003
@@ -454,6 +454,12 @@
 {
 	int i, j, node_from, node_to;
 
+	/* If there's no SRAT, fix the phys_id */
+	if (srat_num_cpus == 0) {
+		node_cpuid[0].phys_id = hard_smp_processor_id();
+		return;
+	}
+
 	/* calculate total number of nodes in system from PXM bitmap */
 	numnodes = 0;		/* init total nodes in system */
 
@@ -614,6 +620,12 @@
 
 	smp_build_cpu_map();
 # ifdef CONFIG_NUMA
+	if (srat_num_cpus == 0) {
+		int cpu, i = 1;
+		for (cpu = 0; cpu < smp_boot_data.cpu_count; cpu++)
+			if (smp_boot_data.cpu_phys_id[cpu] != hard_smp_processor_id())
+				node_cpuid[i++].phys_id = smp_boot_data.cpu_phys_id[cpu];
+	}
 	build_cpu_to_node_map();
 # endif
 #endif
diff -Nru a/arch/ia64/mm/hugetlbpage.c b/arch/ia64/mm/hugetlbpage.c
--- a/arch/ia64/mm/hugetlbpage.c	Sat Oct 11 00:44:48 2003
+++ b/arch/ia64/mm/hugetlbpage.c	Sat Oct 11 00:44:48 2003
@@ -20,13 +20,46 @@
 
 #define TASK_HPAGE_BASE (REGION_HPAGE << REGION_SHIFT)
 
-static long    htlbpagemem;
-int     htlbpage_max;
-static long    htlbzone_pages;
+static long	htlbpagemem;
+int		htlbpage_max;
+static long	htlbzone_pages;
 
-static LIST_HEAD(htlbpage_freelist);
+static struct list_head hugepage_freelists[MAX_NUMNODES];
 static spinlock_t htlbpage_lock = SPIN_LOCK_UNLOCKED;
 
+static void enqueue_huge_page(struct page *page)
+{
+	list_add(&page->list,
+		&hugepage_freelists[page_zone(page)->zone_pgdat->node_id]);
+}
+
+static struct page *dequeue_huge_page(void)
+{
+	int nid = numa_node_id();
+	struct page *page = NULL;
+
+	if (list_empty(&hugepage_freelists[nid])) {
+		for (nid = 0; nid < MAX_NUMNODES; ++nid)
+			if (!list_empty(&hugepage_freelists[nid]))
+				break;
+	}
+	if (nid >= 0 && nid < MAX_NUMNODES &&
+	    !list_empty(&hugepage_freelists[nid])) {
+		page = list_entry(hugepage_freelists[nid].next, struct page, list);
+		list_del(&page->list);
+	}
+	return page;
+}
+
+static struct page *alloc_fresh_huge_page(void)
+{
+	static int nid = 0;
+	struct page *page;
+	page = alloc_pages_node(nid, GFP_HIGHUSER, HUGETLB_PAGE_ORDER);
+	nid = (nid + 1) % numnodes;
+	return page;
+}
+
 void free_huge_page(struct page *page);
 
 static struct page *alloc_hugetlb_page(void)
@@ -35,13 +68,11 @@
 	struct page *page;
 
 	spin_lock(&htlbpage_lock);
-	if (list_empty(&htlbpage_freelist)) {
+	page = dequeue_huge_page();
+	if (!page) {
 		spin_unlock(&htlbpage_lock);
 		return NULL;
 	}
-
-	page = list_entry(htlbpage_freelist.next, struct page, list);
-	list_del(&page->list);
 	htlbpagemem--;
 	spin_unlock(&htlbpage_lock);
 	set_page_count(page, 1);
@@ -228,7 +259,7 @@
 	INIT_LIST_HEAD(&page->list);
 
 	spin_lock(&htlbpage_lock);
-	list_add(&page->list, &htlbpage_freelist);
+	enqueue_huge_page(page);
 	htlbpagemem++;
 	spin_unlock(&htlbpage_lock);
 }
@@ -371,7 +402,7 @@
 
 	map = NULL;
 	spin_lock(&htlbpage_lock);
-	list_for_each(p, &htlbpage_freelist) {
+	list_for_each(p, &hugepage_freelists[0]) {
 		if (map) {
 			list_del(&map->list);
 			update_and_free_page(map);
@@ -408,11 +439,11 @@
 		return (int)htlbzone_pages;
 	if (lcount > 0) {	/* Increase the mem size. */
 		while (lcount--) {
-			page = alloc_pages(__GFP_HIGHMEM, HUGETLB_PAGE_ORDER);
+			page = alloc_fresh_huge_page();
 			if (page == NULL)
 				break;
 			spin_lock(&htlbpage_lock);
-			list_add(&page->list, &htlbpage_freelist);
+			enqueue_huge_page(page);
 			htlbpagemem++;
 			htlbzone_pages++;
 			spin_unlock(&htlbpage_lock);
@@ -449,17 +480,18 @@
 
 static int __init hugetlb_init(void)
 {
-	int i, j;
+	int i;
 	struct page *page;
 
+	for (i = 0; i < MAX_NUMNODES; ++i)
+		INIT_LIST_HEAD(&hugepage_freelists[i]);
+
 	for (i = 0; i < htlbpage_max; ++i) {
-		page = alloc_pages(__GFP_HIGHMEM, HUGETLB_PAGE_ORDER);
+		page = alloc_fresh_huge_page();
 		if (!page)
 			break;
-		for (j = 0; j < HPAGE_SIZE/PAGE_SIZE; ++j)
-			SetPageReserved(&page[j]);
 		spin_lock(&htlbpage_lock);
-		list_add(&page->list, &htlbpage_freelist);
+		enqueue_huge_page(page);
 		spin_unlock(&htlbpage_lock);
 	}
 	htlbpage_max = htlbpagemem = htlbzone_pages = i;
diff -Nru a/arch/ia64/mm/init.c b/arch/ia64/mm/init.c
--- a/arch/ia64/mm/init.c	Sat Oct 11 00:44:48 2003
+++ b/arch/ia64/mm/init.c	Sat Oct 11 00:44:48 2003
@@ -24,6 +24,7 @@
 #include <asm/ia32.h>
 #include <asm/io.h>
 #include <asm/machvec.h>
+#include <asm/numa.h>
 #include <asm/patch.h>
 #include <asm/pgalloc.h>
 #include <asm/sal.h>
@@ -342,6 +343,7 @@
 {
 	unsigned long address, start_page, end_page;
 	struct page *map_start, *map_end;
+	int node;
 	pgd_t *pgd;
 	pmd_t *pmd;
 	pte_t *pte;
@@ -351,19 +353,20 @@
 
 	start_page = (unsigned long) map_start & PAGE_MASK;
 	end_page = PAGE_ALIGN((unsigned long) map_end);
+	node = paddr_to_nid(__pa(start));
 
 	for (address = start_page; address < end_page; address += PAGE_SIZE) {
 		pgd = pgd_offset_k(address);
 		if (pgd_none(*pgd))
-			pgd_populate(&init_mm, pgd, alloc_bootmem_pages(PAGE_SIZE));
+			pgd_populate(&init_mm, pgd, alloc_bootmem_pages_node(NODE_DATA(node), PAGE_SIZE));
 		pmd = pmd_offset(pgd, address);
 
 		if (pmd_none(*pmd))
-			pmd_populate_kernel(&init_mm, pmd, alloc_bootmem_pages(PAGE_SIZE));
+			pmd_populate_kernel(&init_mm, pmd, alloc_bootmem_pages_node(NODE_DATA(node), PAGE_SIZE));
 		pte = pte_offset_kernel(pmd, address);
 
 		if (pte_none(*pte))
-			set_pte(pte, pfn_pte(__pa(alloc_bootmem_pages(PAGE_SIZE)) >> PAGE_SHIFT,
+			set_pte(pte, pfn_pte(__pa(alloc_bootmem_pages_node(NODE_DATA(node), PAGE_SIZE)) >> PAGE_SHIFT,
 					     PAGE_KERNEL));
 	}
 	return 0;
diff -Nru a/arch/ia64/sn/io/machvec/pci_bus_cvlink.c b/arch/ia64/sn/io/machvec/pci_bus_cvlink.c
--- a/arch/ia64/sn/io/machvec/pci_bus_cvlink.c	Sat Oct 11 00:44:48 2003
+++ b/arch/ia64/sn/io/machvec/pci_bus_cvlink.c	Sat Oct 11 00:44:48 2003
@@ -867,6 +867,9 @@
 	int i = 0;
 	struct pci_controller *controller;
 
+	if (!ia64_platform_is("sn2"))
+	    return 0;
+
 	/*
 	 * set pci_raw_ops, etc.
 	 */
diff -Nru a/arch/ia64/sn/io/sn2/ml_SN_intr.c b/arch/ia64/sn/io/sn2/ml_SN_intr.c
--- a/arch/ia64/sn/io/sn2/ml_SN_intr.c	Sat Oct 11 00:44:48 2003
+++ b/arch/ia64/sn/io/sn2/ml_SN_intr.c	Sat Oct 11 00:44:48 2003
@@ -285,7 +285,6 @@
 cpuid_t intr_heuristic(vertex_hdl_t dev, int req_bit, int *resp_bit)
 {
 	cpuid_t		cpuid;
-	cpuid_t		candidate = CPU_NONE;
 	vertex_hdl_t	pconn_vhdl;
 	pcibr_soft_t	pcibr_soft;
 	int 		bit;
@@ -293,30 +292,32 @@
 	/* XXX: gross layering violation.. */
 	if (hwgraph_edge_get(dev, EDGE_LBL_PCI, &pconn_vhdl) == GRAPH_SUCCESS) {
 		pcibr_soft = pcibr_soft_get(pconn_vhdl);
-		if (pcibr_soft && pcibr_soft->bsi_err_intr)
-			candidate = ((hub_intr_t)pcibr_soft->bsi_err_intr)->i_cpuid;
-	}
-
-	if (candidate != CPU_NONE) {
-		/*
-		 * The cpu was chosen already when we assigned
-		 * the error interrupt.
-		 */
-		bit = intr_reserve_level(candidate, req_bit);
-		if (bit >= 0) {
-			*resp_bit = bit;
-			return candidate;
+		if (pcibr_soft && pcibr_soft->bsi_err_intr) {
+			/*
+			 * The cpu was chosen already when we assigned
+			 * the error interrupt.
+			 */
+			cpuid = ((hub_intr_t)pcibr_soft->bsi_err_intr)->i_cpuid;
+			goto done;
 		}
-
-		printk("Cannot target interrupt to target node (%ld).\n",candidate);
-		return CPU_NONE;
 	}
 
 	/*
 	 * Need to choose one.  Try the controlling c-brick first.
 	 */
 	cpuid = intr_cpu_choose_from_node(master_node_get(dev));
-	if (cpuid != CPU_NONE)
-		return cpuid;
-	return intr_cpu_choose_node();
+	if (cpuid == CPU_NONE)
+		cpuid = intr_cpu_choose_node();
+
+ done:
+	if (cpuid != CPU_NONE) {
+		bit = intr_reserve_level(cpuid, req_bit);
+		if (bit >= 0) {
+			*resp_bit = bit;
+			return cpuid;
+		}
+	}
+
+	printk("Cannot target interrupt to target cpu (%ld).\n", cpuid);
+	return CPU_NONE;
 }
diff -Nru a/arch/ia64/sn/kernel/setup.c b/arch/ia64/sn/kernel/setup.c
--- a/arch/ia64/sn/kernel/setup.c	Sat Oct 11 00:44:48 2003
+++ b/arch/ia64/sn/kernel/setup.c	Sat Oct 11 00:44:48 2003
@@ -147,7 +147,6 @@
  * Sets up an initial console to aid debugging.  Intended primarily
  * for bringup.  See start_kernel() in init/main.c.
  */
-#if defined(CONFIG_IA64_EARLY_PRINTK_SGI_SN) || defined(CONFIG_IA64_SGI_SN_SIM)
 
 void __init
 early_sn_setup(void)
@@ -189,7 +188,6 @@
 		printk(KERN_DEBUG "early_sn_setup: setting master_node_bedrock_address to 0x%lx\n", master_node_bedrock_address);
 	}
 }
-#endif /* CONFIG_IA64_EARLY_PRINTK_SGI_SN */
 
 #ifdef CONFIG_IA64_MCA
 extern int platform_intr_list[];
diff -Nru a/drivers/acpi/tables.c b/drivers/acpi/tables.c
--- a/drivers/acpi/tables.c	Sat Oct 11 00:44:48 2003
+++ b/drivers/acpi/tables.c	Sat Oct 11 00:44:48 2003
@@ -262,10 +262,17 @@
 
 	/* Map the DSDT header via the pointer in the FADT */
 	if (id == ACPI_DSDT) {
-		struct acpi_table_fadt *fadt = (struct acpi_table_fadt *) *header;
+		struct fadt_descriptor_rev2 *fadt = (struct fadt_descriptor_rev2 *) *header;
+
+		if (fadt->header.revision == 3 && fadt->Xdsdt) {
+			*header = (void *) __acpi_map_table(fadt->Xdsdt,
+					sizeof(struct acpi_table_header));
+		} else if (fadt->V1_dsdt) {
+			*header = (void *) __acpi_map_table(fadt->V1_dsdt,
+					sizeof(struct acpi_table_header));
+		} else
+			*header = 0;
 
-		*header = (void *) __acpi_map_table(fadt->dsdt_addr,
-				sizeof(struct acpi_table_header));
 		if (!*header) {
 			printk(KERN_WARNING PREFIX "Unable to map DSDT\n");
 			return -ENODEV;
diff -Nru a/drivers/media/radio/Makefile b/drivers/media/radio/Makefile
--- a/drivers/media/radio/Makefile	Sat Oct 11 00:44:48 2003
+++ b/drivers/media/radio/Makefile	Sat Oct 11 00:44:48 2003
@@ -2,6 +2,8 @@
 # Makefile for the kernel character device drivers.
 #
 
+obj-y		:= dummy.o
+
 miropcm20-objs	:= miropcm20-rds-core.o miropcm20-radio.o
 
 obj-$(CONFIG_RADIO_AZTECH) += radio-aztech.o
diff -Nru a/drivers/media/radio/dummy.c b/drivers/media/radio/dummy.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/media/radio/dummy.c	Sat Oct 11 00:44:48 2003
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -Nru a/drivers/media/video/Makefile b/drivers/media/video/Makefile
--- a/drivers/media/video/Makefile	Sat Oct 11 00:44:48 2003
+++ b/drivers/media/video/Makefile	Sat Oct 11 00:44:48 2003
@@ -7,6 +7,7 @@
 zoran-objs      :=	zr36120.o zr36120_i2c.o zr36120_mem.o
 zr36067-objs	:=	zoran_procfs.o zoran_device.o \
 			zoran_driver.o zoran_card.o
+obj-y		:=	dummy.o
 
 obj-$(CONFIG_VIDEO_DEV) += videodev.o v4l2-common.o v4l1-compat.o
 
diff -Nru a/drivers/media/video/dummy.c b/drivers/media/video/dummy.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/media/video/dummy.c	Sat Oct 11 00:44:48 2003
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -Nru a/drivers/net/tulip/media.c b/drivers/net/tulip/media.c
--- a/drivers/net/tulip/media.c	Sat Oct 11 00:44:48 2003
+++ b/drivers/net/tulip/media.c	Sat Oct 11 00:44:48 2003
@@ -278,6 +278,10 @@
 				for (i = 0; i < init_length; i++)
 					outl(init_sequence[i], ioaddr + CSR12);
 			}
+
+			(void) inl(ioaddr + CSR6); /* flush CSR12 writes */
+			udelay(500);		/* Give MII time to recover */
+
 			tmp_info = get_u16(&misc_info[1]);
 			if (tmp_info)
 				tp->advertising[phy_num] = tmp_info | 1;
diff -Nru a/include/asm-ia64/numa.h b/include/asm-ia64/numa.h
--- a/include/asm-ia64/numa.h	Sat Oct 11 00:44:48 2003
+++ b/include/asm-ia64/numa.h	Sat Oct 11 00:44:48 2003
@@ -61,6 +61,10 @@
 
 #define local_nodeid (cpu_to_node_map[smp_processor_id()])
 
+#else /* !CONFIG_NUMA */
+
+#define paddr_to_nid(addr)	0
+
 #endif /* CONFIG_NUMA */
 
 #endif /* _ASM_IA64_NUMA_H */
diff -Nru a/include/asm-ia64/sn/nodepda.h b/include/asm-ia64/sn/nodepda.h
--- a/include/asm-ia64/sn/nodepda.h	Sat Oct 11 00:44:48 2003
+++ b/include/asm-ia64/sn/nodepda.h	Sat Oct 11 00:44:48 2003
@@ -128,7 +128,7 @@
  * Check if given a compact node id the corresponding node has all the
  * cpus disabled. 
  */
-#define is_headless_node(cnode)		(!any_online_cpu(node_to_cpumask(cnode)))
+#define is_headless_node(cnode)		(!node_to_cpu_mask[cnode])
 
 /*
  * Check if given a node vertex handle the corresponding node has all the
diff -Nru a/include/asm-ia64/uaccess.h b/include/asm-ia64/uaccess.h
--- a/include/asm-ia64/uaccess.h	Sat Oct 11 00:44:48 2003
+++ b/include/asm-ia64/uaccess.h	Sat Oct 11 00:44:48 2003
@@ -408,11 +408,7 @@
 extern void handle_exception (struct pt_regs *regs, const struct exception_table_entry *e);
 extern const struct exception_table_entry *search_exception_tables (unsigned long addr);
 
-#ifdef GAS_HAS_LOCAL_TAGS
 # define SEARCH_EXCEPTION_TABLE(regs) search_exception_tables(regs->cr_iip + ia64_psr(regs)->ri)
-#else
-# define SEARCH_EXCEPTION_TABLE(regs) search_exception_tables(regs->cr_iip)
-#endif
 
 static inline int
 done_with_exception (struct pt_regs *regs)
diff -Nru a/include/asm-ia64/unistd.h b/include/asm-ia64/unistd.h
--- a/include/asm-ia64/unistd.h	Sat Oct 11 00:44:48 2003
+++ b/include/asm-ia64/unistd.h	Sat Oct 11 00:44:48 2003
@@ -237,17 +237,17 @@
 #define __NR_epoll_wait			1245
 #define __NR_restart_syscall		1246
 #define __NR_semtimedop			1247
-#define __NR_sys_timer_create		1248
-#define __NR_sys_timer_settime		1249
-#define __NR_sys_timer_gettime		1250
-#define __NR_sys_timer_getoverrun	1251
-#define __NR_sys_timer_delete		1252
-#define __NR_sys_clock_settime		1253
-#define __NR_sys_clock_gettime		1254
-#define __NR_sys_clock_getres		1255
-#define __NR_sys_clock_nanosleep	1256
-#define __NR_sys_fstatfs64		1257
-#define __NR_sys_statfs64		1258
+#define __NR_timer_create		1248
+#define __NR_timer_settime		1249
+#define __NR_timer_gettime		1250
+#define __NR_timer_getoverrun		1251
+#define __NR_timer_delete		1252
+#define __NR_clock_settime		1253
+#define __NR_clock_gettime		1254
+#define __NR_clock_getres		1255
+#define __NR_clock_nanosleep		1256
+#define __NR_fstatfs64			1257
+#define __NR_statfs64			1258
 
 #ifdef __KERNEL__
 
diff -Nru a/include/linux/module.h b/include/linux/module.h
--- a/include/linux/module.h	Sat Oct 11 00:44:48 2003
+++ b/include/linux/module.h	Sat Oct 11 00:44:48 2003
@@ -60,10 +60,11 @@
 #define __module_cat(a,b) ___module_cat(a,b)
 #define __MODULE_INFO(tag, name, info)					  \
 static const char __module_cat(name,__LINE__)[]				  \
+  __attribute_used__							  \
   __attribute__((section(".modinfo"),unused)) = __stringify(tag) "=" info
 
-#define MODULE_GENERIC_TABLE(gtype,name)			\
-extern const struct gtype##_id __mod_##gtype##_table		\
+#define MODULE_GENERIC_TABLE(gtype,name)		\
+extern const struct gtype##_id __mod_##gtype##_table	\
   __attribute__ ((unused, alias(__stringify(name))))
 
 #define THIS_MODULE (&__this_module)
@@ -142,6 +143,7 @@
 #define __CRC_SYMBOL(sym, sec)					\
 	extern void *__crc_##sym __attribute__((weak));		\
 	static const unsigned long __kcrctab_##sym		\
+	__attribute_used__					\
 	__attribute__((section("__kcrctab" sec), unused))	\
 	= (unsigned long) &__crc_##sym;
 #else
@@ -155,6 +157,7 @@
 	__attribute__((section("__ksymtab_strings")))		\
 	= MODULE_SYMBOL_PREFIX #sym;                    	\
 	static const struct kernel_symbol __ksymtab_##sym	\
+	__attribute_used__					\
 	__attribute__((section("__ksymtab" sec), unused))	\
 	= { (unsigned long)&sym, __kstrtab_##sym }
 
diff -Nru a/include/linux/moduleparam.h b/include/linux/moduleparam.h
--- a/include/linux/moduleparam.h	Sat Oct 11 00:44:48 2003
+++ b/include/linux/moduleparam.h	Sat Oct 11 00:44:48 2003
@@ -52,6 +52,7 @@
 #define __module_param_call(prefix, name, set, get, arg, perm)		\
 	static char __param_str_##name[] __initdata = prefix #name;	\
 	static struct kernel_param const __param_##name			\
+	__attribute_used__						\
     __attribute__ ((unused,__section__ ("__param"),aligned(sizeof(void *)))) \
 	= { __param_str_##name, perm, set, get, arg }
 
diff -Nru a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
--- a/include/linux/nfs_fs.h	Sat Oct 11 00:44:48 2003
+++ b/include/linux/nfs_fs.h	Sat Oct 11 00:44:48 2003
@@ -403,7 +403,7 @@
 nfs_size_to_loff_t(__u64 size)
 {
 	loff_t maxsz = (((loff_t) ULONG_MAX) << PAGE_CACHE_SHIFT) + PAGE_CACHE_SIZE - 1;
-	if (size > maxsz)
+	if (size > (__u64) maxsz)
 		return maxsz;
 	return (loff_t) size;
 }
diff -Nru a/include/linux/sysctl.h b/include/linux/sysctl.h
--- a/include/linux/sysctl.h	Sat Oct 11 00:44:48 2003
+++ b/include/linux/sysctl.h	Sat Oct 11 00:44:48 2003
@@ -127,6 +127,7 @@
 	KERN_PANIC_ON_OOPS=57,  /* int: whether we will panic on an oops */
 	KERN_HPPA_PWRSW=58,	/* int: hppa soft-power enable */
 	KERN_HPPA_UNALIGNED=59,	/* int: hppa unaligned-trap enable */
+	KERN_CACHEDECAYTICKS=60,/* ulong: value for cache_decay_ticks (EXPERIMENTAL!) */
 };
 
 
diff -Nru a/kernel/printk.c b/kernel/printk.c
--- a/kernel/printk.c	Sat Oct 11 00:44:48 2003
+++ b/kernel/printk.c	Sat Oct 11 00:44:48 2003
@@ -361,6 +361,12 @@
 			__call_console_drivers(start, end);
 		}
 	}
+#ifdef CONFIG_IA64_EARLY_PRINTK
+	if (!console_drivers) {
+		void early_printk (const char *str, size_t len);
+		early_printk(&LOG_BUF(start), end - start);
+	}
+#endif
 }
 
 /*
@@ -678,7 +684,11 @@
 		 * for us.
 		 */
 		spin_lock_irqsave(&logbuf_lock, flags);
+#ifdef CONFIG_IA64_EARLY_PRINTK
+		con_start = log_end;
+#else
 		con_start = log_start;
+#endif
 		spin_unlock_irqrestore(&logbuf_lock, flags);
 	}
 	release_console_sem();
@@ -731,3 +741,117 @@
 		tty->driver->write(tty, 0, msg, strlen(msg));
 	return;
 }
+
+#ifdef CONFIG_IA64_EARLY_PRINTK
+
+#include <asm/io.h>
+
+# ifdef CONFIG_IA64_EARLY_PRINTK_VGA
+
+
+#define VGABASE		((char *)0xc0000000000b8000)
+#define VGALINES	24
+#define VGACOLS		80
+
+static int current_ypos = VGALINES, current_xpos = 0;
+
+static void
+early_printk_vga (const char *str, size_t len)
+{
+	char c;
+	int  i, k, j;
+
+	while (len-- > 0) {
+		c = *str++;
+		if (current_ypos >= VGALINES) {
+			/* scroll 1 line up */
+			for (k = 1, j = 0; k < VGALINES; k++, j++) {
+				for (i = 0; i < VGACOLS; i++) {
+					writew(readw(VGABASE + 2*(VGACOLS*k + i)),
+					       VGABASE + 2*(VGACOLS*j + i));
+				}
+			}
+			for (i = 0; i < VGACOLS; i++) {
+				writew(0x720, VGABASE + 2*(VGACOLS*j + i));
+			}
+			current_ypos = VGALINES-1;
+		}
+		if (c == '\n') {
+			current_xpos = 0;
+			current_ypos++;
+		} else if (c != '\r')  {
+			writew(((0x7 << 8) | (unsigned short) c),
+			       VGABASE + 2*(VGACOLS*current_ypos + current_xpos++));
+			if (current_xpos >= VGACOLS) {
+				current_xpos = 0;
+				current_ypos++;
+			}
+		}
+	}
+}
+
+# endif /* CONFIG_IA64_EARLY_PRINTK_VGA */
+
+# ifdef CONFIG_IA64_EARLY_PRINTK_UART
+
+#include <linux/serial_reg.h>
+#include <asm/system.h>
+
+static void early_printk_uart(const char *str, size_t len)
+{
+	static char *uart = NULL;
+	unsigned long uart_base;
+	char c;
+
+	if (!uart) {
+		uart_base = 0;
+#  ifdef CONFIG_SERIAL_8250_HCDP
+		{
+			extern unsigned long hcdp_early_uart(void);
+			uart_base = hcdp_early_uart();
+		}
+#  endif
+#  if CONFIG_IA64_EARLY_PRINTK_UART_BASE
+		if (!uart_base)
+			uart_base = CONFIG_IA64_EARLY_PRINTK_UART_BASE;
+#  endif
+		if (!uart_base)
+			return;
+
+		uart = ioremap(uart_base, 64);
+		if (!uart)
+			return;
+	}
+
+	while (len-- > 0) {
+		c = *str++;
+		while ((readb(uart + UART_LSR) & UART_LSR_TEMT) == 0)
+			cpu_relax(); /* spin */
+
+		writeb(c, uart + UART_TX);
+
+		if (c == '\n')
+			writeb('\r', uart + UART_TX);
+	}
+}
+
+# endif /* CONFIG_IA64_EARLY_PRINTK_UART */
+
+#ifdef CONFIG_IA64_EARLY_PRINTK_SGI_SN
+extern int early_printk_sn_sal(const char *str, int len);
+#endif
+
+void early_printk(const char *str, size_t len)
+{
+#ifdef CONFIG_IA64_EARLY_PRINTK_UART
+	early_printk_uart(str, len);
+#endif
+#ifdef CONFIG_IA64_EARLY_PRINTK_VGA
+	early_printk_vga(str, len);
+#endif
+#ifdef CONFIG_IA64_EARLY_PRINTK_SGI_SN
+ 	early_printk_sn_sal(str, len);
+#endif
+}
+
+#endif /* CONFIG_IA64_EARLY_PRINTK */
diff -Nru a/kernel/sysctl.c b/kernel/sysctl.c
--- a/kernel/sysctl.c	Sat Oct 11 00:44:48 2003
+++ b/kernel/sysctl.c	Sat Oct 11 00:44:48 2003
@@ -579,6 +579,16 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#ifdef CONFIG_SMP
+	{
+		.ctl_name	= KERN_CACHEDECAYTICKS,
+		.procname	= "cache_decay_ticks",
+		.data		= &cache_decay_ticks,
+		.maxlen		= sizeof(cache_decay_ticks),
+		.mode		= 0644,
+		.proc_handler	= &proc_doulongvec_minmax,
+	},
+#endif
 	{ .ctl_name = 0 }
 };
 
diff -Nru a/mm/memory.c b/mm/memory.c
--- a/mm/memory.c	Sat Oct 11 00:44:48 2003
+++ b/mm/memory.c	Sat Oct 11 00:44:48 2003
@@ -121,8 +121,10 @@
 	}
 	pmd = pmd_offset(dir, 0);
 	pgd_clear(dir);
-	for (j = 0; j < PTRS_PER_PMD ; j++)
+	for (j = 0; j < PTRS_PER_PMD ; j++) {
+		prefetchw(pmd + j + PREFETCH_STRIDE/sizeof(*pmd));
 		free_one_pmd(tlb, pmd+j);
+	}
 	pmd_free_tlb(tlb, pmd);
 }
 
