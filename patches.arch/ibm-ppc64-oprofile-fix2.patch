diff -rauN -X dontdiff linux-2.6.5-20040511-clean/arch/ppc64/oprofile/common.c linux-2.6.5-20040511/arch/ppc64/oprofile/common.c
--- linux-2.6.5-20040511-clean/arch/ppc64/oprofile/common.c	2004-05-11 07:57:00.000000000 -0700
+++ linux-2.6.5-20040511/arch/ppc64/oprofile/common.c	2004-05-11 14:07:54.000000000 -0700
@@ -90,6 +90,13 @@
 {
 	int i;
 
+        /* There is one mmcr0, mmcr1 and mmcra for setting the events for all of the
+	   counters.
+	*/
+	oprofilefs_create_ulong(sb, root, "mmcr0", &sys.mmcr0);
+	oprofilefs_create_ulong(sb, root, "mmcr1", &sys.mmcr1);
+	oprofilefs_create_ulong(sb, root, "mmcra", &sys.mmcra);
+
 	for (i = 0; i < model->num_counters; ++i) {
 		struct dentry *dir;
 		char buf[3];
diff -rauN -X dontdiff linux-2.6.5-20040511-clean/arch/ppc64/oprofile/op_impl.h linux-2.6.5-20040511/arch/ppc64/oprofile/op_impl.h
--- linux-2.6.5-20040511-clean/arch/ppc64/oprofile/op_impl.h	2004-05-11 07:56:58.000000000 -0700
+++ linux-2.6.5-20040511/arch/ppc64/oprofile/op_impl.h	2004-05-11 19:01:32.000000000 -0700
@@ -46,6 +46,11 @@
 /* enable sampling */
 #define MMCRA_SAMPLE_ENABLE	(1UL << (63 - 63))
 
+#define POWER4_MMCR0_KERNEL_DISABLE (1UL << (30))   /* Freeze in Supervisor state */
+#define POWER4_MMCR0_PROBLEM_DISABLE (1UL << (29))  /* Freeze in problem state */
+
+
+
 /* Per-counter configuration as set via oprofilefs.  */
 struct op_counter_config {
 	unsigned long valid;
@@ -60,6 +65,9 @@
 
 /* System-wide configuration as set via oprofilefs.  */
 struct op_system_config {
+	unsigned long mmcr0;
+	u64           mmcr1;
+	unsigned long mmcra;
 	unsigned long enable_kernel;
 	unsigned long enable_user;
 };
diff -rauN -X dontdiff linux-2.6.5-20040511-clean/arch/ppc64/oprofile/op_model_power4.c linux-2.6.5-20040511/arch/ppc64/oprofile/op_model_power4.c
--- linux-2.6.5-20040511-clean/arch/ppc64/oprofile/op_model_power4.c	2004-05-11 07:57:00.000000000 -0700
+++ linux-2.6.5-20040511/arch/ppc64/oprofile/op_model_power4.c	2004-05-11 19:11:23.000000000 -0700
@@ -27,6 +27,11 @@
 static int oprofile_running;
 static int mmcra_has_sihv;
 
+/* mmcr values are set in power4_reg_setup, used in power4_cpu_setup */
+static u32 mmcr0_val;
+static u64 mmcr1_val;
+static u32 mmcra_val;
+
 static void power4_reg_setup(struct op_counter_config *ctr,
 			     struct op_system_config *sys,
 			     int num_ctrs)
@@ -45,6 +50,13 @@
 	if (!(__is_processor(PV_POWER4) || __is_processor(PV_POWER4p)))
 		mmcra_has_sihv = 1;
 
+	/* The performance counter event settings are given in the mmcr0, mmcr1 and mmcra
+	   values passed from the user in the op_system_config structure (sys variable).
+	*/
+	mmcr0_val = sys->mmcr0;
+	mmcr1_val = sys->mmcr1;
+	mmcra_val = sys->mmcra;
+
 	for (i = 0; i < num_counters; ++i)
 		reset_value[i] = 0x80000000UL - ctr[i].count;
 
@@ -55,9 +67,9 @@
 
 static void power4_cpu_setup(void *unused)
 {
-	unsigned int mmcr0 = mfspr(SPRN_MMCR0);
-	unsigned long mmcra = mfspr(SPRN_MMCRA);
-
+	unsigned int mmcr0 = mmcr0_val;
+	unsigned long mmcra = mmcra_val;
+        unsigned long hid0;
 	ppc64_enable_pmcs();
 
 	/* set the freeze bit */
@@ -68,6 +80,8 @@
 	mmcr0 |= MMCR0_PMC1INTCONTROL|MMCR0_PMCNINTCONTROL;
 	mtspr(SPRN_MMCR0, mmcr0);
 
+	mtspr(SPRN_MMCR1, mmcr1_val);
+
 	mmcra |= MMCRA_SAMPLE_ENABLE;
 	mtspr(SPRN_MMCRA, mmcra);
 
@@ -77,12 +91,30 @@
 	    mfspr(SPRN_MMCR1));
 	dbg("setup on cpu %d, mmcra %lx\n", smp_processor_id(),
 	    mfspr(SPRN_MMCRA));
+
+	/* set the debug bus to extended mode */
+	hid0 = mfspr(HID0);
+	hid0 &= ~(1UL<<(63-17));
+	hid0 |= (1UL<<(63-20));
+
+	__asm__ __volatile__("sync");
+	mtspr(HID0, hid0);
+	hid0 = mfspr(HID0);
+	hid0 = mfspr(HID0);
+	hid0 = mfspr(HID0);
+	hid0 = mfspr(HID0);
+	hid0 = mfspr(HID0);
+	hid0 = mfspr(HID0);
+	__asm__ __volatile__("isync");
+
 }
 
 static void power4_start(struct op_counter_config *ctr)
 {
 	int i;
 	unsigned int mmcr0;
+	int kernel_mode = 0;
+	int user_mode = 0;
 
 	/* set the PMM bit (see comment below) */
 	mtmsrd(mfmsr() | MSR_PMM);
@@ -90,6 +122,16 @@
 	for (i = 0; i < num_counters; ++i) {
 		if (ctr[i].enabled) {
 			ctr_write(i, reset_value[i]);
+
+			if (ctr[i].kernel == 1) {
+				/* All counters will be set the same for kernel
+				   and user counting */
+				kernel_mode = 1;
+			}
+
+			if (ctr[i].user == 1) {
+				user_mode = 1;
+			}
 		} else {
 			ctr_write(i, 0);
 		}
@@ -104,6 +146,23 @@
 	mmcr0 &= ~MMCR0_PMAO;
 
 	/*
+	* Set the user and kernel modes
+	*/
+	if (kernel_mode == 1)
+		/* count in supervisor mode */
+		mmcr0 &= ~POWER4_MMCR0_KERNEL_DISABLE;
+
+	else
+		mmcr0 |= POWER4_MMCR0_KERNEL_DISABLE;
+	
+	if (user_mode == 1)
+		/* count in problem mode */
+		mmcr0 &= ~POWER4_MMCR0_PROBLEM_DISABLE;
+	
+	else
+		mmcr0 |= POWER4_MMCR0_PROBLEM_DISABLE;
+
+	/*
 	 * now clear the freeze bit, counting will not start until we
 	 * rfid from this excetion, because only at that point will
 	 * the PMM bit be cleared
