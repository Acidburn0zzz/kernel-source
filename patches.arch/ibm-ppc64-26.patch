ChangeSet
  1.1549 04/04/01 15:11:54 anton@samba.org +10 -0
  From: Stephen Rothwell <sfr@canb.auug.org.au>
  
  This creates DMA_ERROR_CODE and uses it everywhere instead of
  PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
  a single error code.  Also we now have dma_mapping_error and
  vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
  just call the former.

  include/asm-ppc64/vio.h
    1.14 04/04/01 15:11:35 anton@samba.org +9 -3
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  include/asm-ppc64/pci.h
    1.30 04/04/01 15:11:35 anton@samba.org +2 -2
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  include/asm-ppc64/dma-mapping.h
    1.6 04/04/01 15:11:35 anton@samba.org +7 -0
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  drivers/scsi/ibmvscsi/rpa_vscsi.c
    1.17 04/04/01 15:11:35 anton@samba.org +1 -1
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  drivers/scsi/ibmvscsi/ibmvscsis.c
    1.6 04/04/01 15:11:35 anton@samba.org +1 -1
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  drivers/scsi/ibmvscsi/ibmvscsi.c
    1.17 04/04/01 15:11:34 anton@samba.org +5 -5
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  drivers/net/ibmveth.c
    1.11 04/04/01 15:11:34 anton@samba.org +7 -6
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  arch/ppc64/kernel/vio.c
    1.24 04/04/01 15:11:34 anton@samba.org +4 -3
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  arch/ppc64/kernel/pci_iommu.c
    1.4 04/04/01 15:11:34 anton@samba.org +5 -4
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

  arch/ppc64/kernel/iommu.c
    1.5 04/04/01 15:11:34 anton@samba.org +8 -7
    From: Stephen Rothwell <sfr@canb.auug.org.au>
    
    This creates DMA_ERROR_CODE and uses it everywhere instead of
    PCI_DMA_ERROR_CODE as we really want the three DMA mapping API's to return
    a single error code.  Also we now have dma_mapping_error and
    vio_dma_mapping_error - and this latter and pci_dma_mapping_error both
    just call the former.

diff -Nru a/arch/ppc64/kernel/iommu.c b/arch/ppc64/kernel/iommu.c
--- a/arch/ppc64/kernel/iommu.c	Fri Apr  2 02:02:36 2004
+++ b/arch/ppc64/kernel/iommu.c	Fri Apr  2 02:02:36 2004
@@ -32,6 +32,7 @@
 #include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <linux/init.h>
 #include <asm/io.h>
 #include <asm/prom.h>
@@ -73,7 +74,7 @@
 	if (unlikely(npages) == 0) {
 		if (printk_ratelimit())
 			WARN_ON(1);
-		return PCI_DMA_ERROR_CODE;
+		return DMA_ERROR_CODE;
 	}
 
 	if (handle && *handle)
@@ -110,7 +111,7 @@
 			goto again;
 		} else {
 			/* Third failure, give up */
-			return PCI_DMA_ERROR_CODE;
+			return DMA_ERROR_CODE;
 		}
 	}
 
@@ -144,15 +145,15 @@
 		       unsigned int npages, int direction)
 {
 	unsigned long entry, flags;
-	dma_addr_t ret = PCI_DMA_ERROR_CODE;
+	dma_addr_t ret = DMA_ERROR_CODE;
 	
 	spin_lock_irqsave(&(tbl->it_lock), flags);
 
 	entry = iommu_range_alloc(tbl, npages, NULL);
 
-	if (unlikely(entry == PCI_DMA_ERROR_CODE)) {
+	if (unlikely(entry == DMA_ERROR_CODE)) {
 		spin_unlock_irqrestore(&(tbl->it_lock), flags);
-		return PCI_DMA_ERROR_CODE;
+		return DMA_ERROR_CODE;
 	}
 
 	entry += tbl->it_offset;	/* Offset into real TCE table */
@@ -263,7 +264,7 @@
 		DBG("  - vaddr: %lx, size: %lx\n", vaddr, slen);
 
 		/* Handle failure */
-		if (unlikely(entry == PCI_DMA_ERROR_CODE)) {
+		if (unlikely(entry == DMA_ERROR_CODE)) {
 			if (printk_ratelimit())
 				printk(KERN_INFO "iommu_alloc failed, tbl %p vaddr %lx"
 				       " npages %lx\n", tbl, vaddr, npages);
@@ -327,7 +328,7 @@
 	 */
 	if (outcount < nelems) {
 		outs++;
-		outs->dma_address = PCI_DMA_ERROR_CODE;
+		outs->dma_address = DMA_ERROR_CODE;
 		outs->dma_length = 0;
 	}
 	return outcount;
diff -Nru a/arch/ppc64/kernel/pci_iommu.c b/arch/ppc64/kernel/pci_iommu.c
--- a/arch/ppc64/kernel/pci_iommu.c	Fri Apr  2 02:02:37 2004
+++ b/arch/ppc64/kernel/pci_iommu.c	Fri Apr  2 02:02:37 2004
@@ -31,6 +31,7 @@
 #include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <asm/io.h>
 #include <asm/prom.h>
 #include <asm/iommu.h>
@@ -82,7 +83,7 @@
 	if (order >= IOMAP_MAX_ORDER) {
 		printk("PCI_DMA: pci_alloc_consistent size too large: 0x%lx\n",
 			size);
-		return (void *)PCI_DMA_ERROR_CODE;
+		return (void *)DMA_ERROR_CODE;
 	}
 
 	tbl = devnode_table(hwdev); 
@@ -101,7 +102,7 @@
 	/* Set up tces to cover the allocated range */
 	mapping = iommu_alloc(tbl, ret, npages, PCI_DMA_BIDIRECTIONAL);
 
-	if (mapping == PCI_DMA_ERROR_CODE) {
+	if (mapping == DMA_ERROR_CODE) {
 		free_pages((unsigned long)ret, order);
 		ret = NULL;
 	} else
@@ -139,7 +140,7 @@
 				size_t size, int direction)
 {
 	struct iommu_table * tbl;
-	dma_addr_t dma_handle = PCI_DMA_ERROR_CODE;
+	dma_addr_t dma_handle = DMA_ERROR_CODE;
 	unsigned long uaddr;
 	unsigned int npages;
 
@@ -153,7 +154,7 @@
 
 	if (tbl) {
 		dma_handle = iommu_alloc(tbl, vaddr, npages, direction);
-		if (dma_handle == PCI_DMA_ERROR_CODE) {
+		if (dma_handle == DMA_ERROR_CODE) {
 			if (printk_ratelimit())  {
 				printk(KERN_INFO "iommu_alloc failed, tbl %p vaddr %p npages %d\n",
 				       tbl, vaddr, npages);
diff -Nru a/arch/ppc64/kernel/vio.c b/arch/ppc64/kernel/vio.c
--- a/arch/ppc64/kernel/vio.c	Fri Apr  2 02:02:36 2004
+++ b/arch/ppc64/kernel/vio.c	Fri Apr  2 02:02:37 2004
@@ -19,6 +19,7 @@
 #include <linux/module.h>
 #include <linux/kobject.h>
 #include <linux/mm.h>
+#include <linux/dma-mapping.h>
 #include <asm/rtas.h>
 #include <asm/iommu.h>
 #include <asm/dma.h>
@@ -418,7 +419,7 @@
 			  size_t size, int direction )
 {
 	struct iommu_table *tbl;
-	dma_addr_t dma_handle = PCI_DMA_ERROR_CODE;
+	dma_addr_t dma_handle = DMA_ERROR_CODE;
 	unsigned long uaddr;
 	unsigned int npages;
 
@@ -503,7 +504,7 @@
 	/* It is easier to debug here for the drivers than in the tce tables.*/
  	if(order >= IOMAP_MAX_ORDER) {
  		printk("VIO_DMA: vio_alloc_consistent size to large: 0x%lx \n", size);
- 		return (void *)PCI_DMA_ERROR_CODE;
+ 		return (void *)DMA_ERROR_CODE;
  	}
 
 	tbl = dev->iommu_table;
@@ -516,7 +517,7 @@
 			memset(ret, 0, npages << PAGE_SHIFT);
 			/* Set up tces to cover the allocated range */
 			tce = iommu_alloc(tbl, ret, npages, PCI_DMA_BIDIRECTIONAL);
-			if (tce == PCI_DMA_ERROR_CODE) {
+			if (tce == DMA_ERROR_CODE) {
 				PPCDBG(PPCDBG_TCE, "vio_alloc_consistent: iommu_alloc failed\n" );
 				free_pages((unsigned long)ret, order);
 				ret = NULL;
diff -Nru a/drivers/net/ibmveth.c b/drivers/net/ibmveth.c
--- a/drivers/net/ibmveth.c	Fri Apr  2 02:02:36 2004
+++ b/drivers/net/ibmveth.c	Fri Apr  2 02:02:36 2004
@@ -40,6 +40,7 @@
 #include <linux/errno.h>
 #include <linux/ioport.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -406,7 +407,7 @@
 	if(adapter->buffer_list_addr != NULL) {
 		if(!pci_dma_mapping_error(adapter->buffer_list_dma)) {
 			vio_unmap_single(adapter->vdev, adapter->buffer_list_dma, 4096, PCI_DMA_BIDIRECTIONAL);
-			adapter->buffer_list_dma = PCI_DMA_ERROR_CODE;
+			adapter->buffer_list_dma = DMA_ERROR_CODE;
 		}
 		free_page((unsigned long)adapter->buffer_list_addr);
 		adapter->buffer_list_addr = NULL;
@@ -415,7 +416,7 @@
 	if(adapter->filter_list_addr != NULL) {
 		if(!pci_dma_mapping_error(adapter->filter_list_dma)) {
 			vio_unmap_single(adapter->vdev, adapter->filter_list_dma, 4096, PCI_DMA_BIDIRECTIONAL);
-			adapter->filter_list_dma = PCI_DMA_ERROR_CODE;
+			adapter->filter_list_dma = DMA_ERROR_CODE;
 		}
 		free_page((unsigned long)adapter->filter_list_addr);
 		adapter->filter_list_addr = NULL;
@@ -424,7 +425,7 @@
 	if(adapter->rx_queue.queue_addr != NULL) {
 		if(!pci_dma_mapping_error(adapter->rx_queue.queue_dma)) {
 			vio_unmap_single(adapter->vdev, adapter->rx_queue.queue_dma, adapter->rx_queue.queue_len, PCI_DMA_BIDIRECTIONAL);
-			adapter->rx_queue.queue_dma = PCI_DMA_ERROR_CODE;
+			adapter->rx_queue.queue_dma = DMA_ERROR_CODE;
 		}
 		kfree(adapter->rx_queue.queue_addr);
 		adapter->rx_queue.queue_addr = NULL;
@@ -944,9 +945,9 @@
 
 	INIT_WORK(&adapter->replenish_task, (void*)ibmveth_replenish_task, (void*)adapter);
 
-	adapter->buffer_list_dma = PCI_DMA_ERROR_CODE;
-	adapter->filter_list_dma = PCI_DMA_ERROR_CODE;
-	adapter->rx_queue.queue_dma = PCI_DMA_ERROR_CODE;
+	adapter->buffer_list_dma = DMA_ERROR_CODE;
+	adapter->filter_list_dma = DMA_ERROR_CODE;
+	adapter->rx_queue.queue_dma = DMA_ERROR_CODE;
 
 	atomic_set(&adapter->not_replenishing, 1);
 
diff -Nru a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
--- a/drivers/scsi/ibmvscsi/ibmvscsi.c	Fri Apr  2 02:02:36 2004
+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c	Fri Apr  2 02:02:36 2004
@@ -66,7 +66,6 @@
  * layer.
  */
 
-#include <linux/pci.h>		/* needed only for pci_dma_mapping_error */
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>
@@ -341,9 +340,10 @@
 	    (struct memory_descriptor *)srp_cmd->additional_data;
 	struct indirect_descriptor *indirect =
 	    (struct indirect_descriptor *)data;
+
 	sg_mapped = dma_map_sg(dev, sg, cmd->use_sg, DMA_BIDIRECTIONAL);
 
-	if (pci_dma_mapping_error(sg_dma_address(&sg[0])))
+	if (sg_mapped == 0)
 		return 0;
 
 	/* special case; we can use a single direct descriptor */
@@ -407,7 +407,7 @@
 	    (u64) (unsigned long)dma_map_single(dev, cmd->request_buffer,
 						cmd->request_bufflen,
 						DMA_BIDIRECTIONAL);
-	if (pci_dma_mapping_error(data->virtual_address)) {
+	if (dma_mapping_error(data->virtual_address)) {
 		printk(KERN_ERR
 		       "ibmvscsi: Unable to map request_buffer for command!\n");
 		return 0;
@@ -690,7 +690,7 @@
 				    &hostdata->madapter_info,
 				    sizeof(hostdata->madapter_info),
 				    DMA_BIDIRECTIONAL);
-	if (pci_dma_mapping_error(req.buffer)) {
+	if (dma_mapping_error(req.buffer)) {
 		printk(KERN_ERR
 		       "ibmvscsi: Unable to map request_buffer "
 		       "for adapter_info!\n");
@@ -1075,7 +1075,7 @@
 	host_config.buffer = dma_map_single(hostdata->dev, buffer, length,
 					    DMA_BIDIRECTIONAL);
 
-	if (pci_dma_mapping_error(host_config.buffer)) {
+	if (dma_mapping_error(host_config.buffer)) {
 		printk(KERN_ERR
 		       "ibmvscsi: dma_mapping error " "getting host config\n");
 		rc = -1;
diff -Nru a/drivers/scsi/ibmvscsi/ibmvscsis.c b/drivers/scsi/ibmvscsi/ibmvscsis.c
--- a/drivers/scsi/ibmvscsi/ibmvscsis.c	Fri Apr  2 02:02:37 2004
+++ b/drivers/scsi/ibmvscsi/ibmvscsis.c	Fri Apr  2 02:02:37 2004
@@ -1863,7 +1863,7 @@
 					  queue->size * sizeof(*queue->msgs),
 					  PCI_DMA_BIDIRECTIONAL);
 
-	if (pci_dma_mapping_error(queue->msg_token))
+	if (vio_dma_mapping_error(queue->msg_token))
 		goto map_failed;
 
 	rc = plpar_hcall_norets(H_REG_CRQ, adapter->dma_dev->unit_address, queue->msg_token, PAGE_SIZE);
diff -Nru a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
--- a/drivers/scsi/ibmvscsi/rpa_vscsi.c	Fri Apr  2 02:02:37 2004
+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c	Fri Apr  2 02:02:37 2004
@@ -174,7 +174,7 @@
 					  queue->size * sizeof(*queue->msgs),
 					  PCI_DMA_BIDIRECTIONAL);
 
-	if (pci_dma_mapping_error(queue->msg_token))
+	if (dma_mapping_error(queue->msg_token))
 		goto map_failed;
 
 	rc = plpar_hcall_norets(H_REG_CRQ,
diff -Nru a/include/asm-ppc64/dma-mapping.h b/include/asm-ppc64/dma-mapping.h
--- a/include/asm-ppc64/dma-mapping.h	Fri Apr  2 02:02:37 2004
+++ b/include/asm-ppc64/dma-mapping.h	Fri Apr  2 02:02:37 2004
@@ -15,6 +15,8 @@
 #include <asm/scatterlist.h>
 #include <asm/bug.h>
 
+#define DMA_ERROR_CODE		(~(dma_addr_t)0x0)
+
 extern int dma_supported(struct device *dev, u64 mask);
 extern int dma_set_mask(struct device *dev, u64 dma_mask);
 extern void *dma_alloc_coherent(struct device *dev, size_t size,
@@ -70,6 +72,11 @@
 	 * but if you get this on a platform, you should convert the platform
 	 * to using the generic device DMA API */
 	BUG();
+}
+
+static inline int dma_mapping_error(dma_addr_t dma_addr)
+{
+	return (dma_addr == DMA_ERROR_CODE);
 }
 
 #endif	/* _ASM_DMA_MAPPING_H */
diff -Nru a/include/asm-ppc64/pci.h b/include/asm-ppc64/pci.h
--- a/include/asm-ppc64/pci.h	Fri Apr  2 02:02:37 2004
+++ b/include/asm-ppc64/pci.h	Fri Apr  2 02:02:37 2004
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/dma-mapping.h>
 #include <asm/scatterlist.h>
 #include <asm/io.h>
 #include <asm/prom.h>
@@ -169,10 +170,9 @@
 	return 0;
 }
 
-#define PCI_DMA_ERROR_CODE      (~(dma_addr_t)0x0)
 static inline int pci_dma_mapping_error(dma_addr_t dma_addr)
 {
-	return (dma_addr == PCI_DMA_ERROR_CODE);
+	return dma_mapping_error(dma_addr);
 }
 
 extern int pci_domain_nr(struct pci_bus *bus);
diff -Nru a/include/asm-ppc64/vio.h b/include/asm-ppc64/vio.h
--- a/include/asm-ppc64/vio.h	Fri Apr  2 02:02:37 2004
+++ b/include/asm-ppc64/vio.h	Fri Apr  2 02:02:37 2004
@@ -11,13 +11,14 @@
  *      2 of the License, or (at your option) any later version.
  */
 
-#ifndef _VIO_H
-#define _VIO_H
+#ifndef _ASM_VIO_H
+#define _ASM_VIO_H
 
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/device.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <asm/hvcall.h>
 #include <asm/prom.h>
 #include <asm/scatterlist.h>
@@ -137,4 +138,9 @@
 	return container_of(dev, struct vio_dev, dev);
 }
 
-#endif /* _PHYP_H */
+static inline int vio_dma_mapping_error(dma_addr_t dma_addr)
+{
+	return dma_mapping_error(dma_addr);
+}
+
+#endif /* _ASM_VIO_H */
.........................................................................
# vim: syntax=diff

