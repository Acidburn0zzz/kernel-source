- Description: qeth: problems when querying ARP cache with larger number of
               entries
  Symptom:     If a device's ARP cache contains a large number of entries,
               query ARP (qetharp -nq) results in an "unknown error" and fails.
  Problem:     User space buffer to receive ARP entries is 20000 bytes and can
               only hold 454/526 entries (for OSA/HiperSockets).
  Solution:    Each entry contains 32 bytes of "media specific information" which
               is not used. Added an option to strip off these unused bytes before
               copying to user space. This "STRIP_ENTRIES" option can be set by
               the qetharp user tool. Now it is possible to receive 1666/3333
               entries.
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/include/asm-s390/qeth.h	14 May 2004 11:16:22 -0000	1.2.2.1
+++ linux-2.5/include/asm-s390/qeth.h	24 May 2004 16:06:18 -0000	1.2.2.2
@@ -8,8 +8,8 @@
  * Author(s):	Thomas Spatzier <tspat@de.ibm.com>
  *
  */
-#ifndef __ASM_S390_IOCTL_H__
-#define __ASM_S390_IOCTL_H__
+#ifndef __ASM_S390_QETH_IOCTL_H__
+#define __ASM_S390_QETH_IOCTL_H__
 #include <linux/ioctl.h>
 
 #define SIOC_QETH_ARP_SET_NO_ENTRIES    (SIOCDEVPRIVATE)
@@ -35,6 +35,13 @@
 	__u8 ipaddr[4];
 } __attribute__((packed));
 
+struct qeth_arp_qi_entry7_short {
+	__u8 macaddr_type;
+	__u8 ipaddr_type;
+	__u8 macaddr[6];
+	__u8 ipaddr[4];
+} __attribute__((packed));
+
 struct qeth_arp_qi_entry5 {
 	__u8 media_specific[32];
 	__u8 macaddr_type;
@@ -42,6 +49,19 @@
 	__u8 ipaddr[4];
 } __attribute__((packed));
 
+struct qeth_arp_qi_entry5_short {
+	__u8 macaddr_type;
+	__u8 ipaddr_type;
+	__u8 ipaddr[4];
+} __attribute__((packed));
+
+/*
+ * can be set by user if no "media specific information" is wanted
+ * -> saves a lot of space in user space buffer
+ */
+#define QETH_QARP_STRIP_ENTRIES  0x8000
+#define QETH_QARP_REQUEST_MASK   0x00ff
+
 /* data sent to user space as result of query arp ioctl */
 #define QETH_QARP_USER_DATA_SIZE 20000
 #define QETH_QARP_MASK_OFFSET    4
@@ -55,4 +75,4 @@
 	char *entries;
 } __attribute__((packed));
 
-#endif /* __ASM_S390_IOCTL_H__ */
+#endif /* __ASM_S390_QETH_IOCTL_H__ */

--- linux-2.5/drivers/s390/net/qeth_main.c	24 May 2004 15:46:48 -0000	1.77.2.15
+++ linux-2.5/drivers/s390/net/qeth_main.c	24 May 2004 16:06:47 -0000	1.77.2.16
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.15 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.16 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.15 $	 $Date: 2004/05/24 15:46:48 $
+ *    $Revision: 1.77.2.16 $	 $Date: 2004/05/24 16:06:47 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.15 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.16 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -3977,6 +3977,25 @@
 	return rc;
 }
 
+static inline void
+qeth_copy_arp_entries_stripped(struct qeth_arp_query_info *qinfo,
+		               struct qeth_arp_query_data *qdata,
+			       int entry_size, int uentry_size)
+{
+	char *entry_ptr;
+	char *uentry_ptr;
+	int i;
+
+	entry_ptr = (char *)&qdata->data;
+	uentry_ptr = (char *)(qinfo->udata + qinfo->udata_offset);
+	for (i = 0; i < qdata->no_entries; ++i){
+		/* strip off 32 bytes "media specific information" */
+		memcpy(uentry_ptr, (entry_ptr + 32), entry_size - 32);
+		entry_ptr += entry_size;
+		uentry_ptr += uentry_size;
+	}
+}
+
 static int
 qeth_arp_query_cb(struct qeth_card *card, struct qeth_reply *reply,
 		  unsigned long data)
@@ -3985,6 +4004,7 @@
 	struct qeth_arp_query_data *qdata;
 	struct qeth_arp_query_info *qinfo;
 	int entry_size;
+	int uentry_size;
 	int i;
 
 	QETH_DBF_TEXT(trace,4,"arpquecb");
@@ -4003,37 +4023,54 @@
 	qdata = &cmd->data.setassparms.data.query_arp;
 	switch(qdata->reply_bits){
 	case 5:
-		entry_size = sizeof(struct qeth_arp_qi_entry5);
+		uentry_size = entry_size = sizeof(struct qeth_arp_qi_entry5);
+		if (qinfo->mask_bits & QETH_QARP_STRIP_ENTRIES)
+			uentry_size = sizeof(struct qeth_arp_qi_entry5_short);
 		break;
 	case 7:
-		entry_size = sizeof(struct qeth_arp_qi_entry7);
-		break;
+		/* fall through to default */
 	default:
 		/* tr is the same as eth -> entry7 */
-		entry_size = sizeof(struct qeth_arp_qi_entry7);
+		uentry_size = entry_size = sizeof(struct qeth_arp_qi_entry7);
+		if (qinfo->mask_bits & QETH_QARP_STRIP_ENTRIES)
+			uentry_size = sizeof(struct qeth_arp_qi_entry7_short);
 		break;
 	}
 	/* check if there is enough room in userspace */
 	if ((qinfo->udata_len - qinfo->udata_offset) <
-			qdata->no_entries * entry_size){
+			qdata->no_entries * uentry_size){
 		QETH_DBF_TEXT_(trace, 4, "qaer3%i", -ENOMEM);
 		cmd->hdr.return_code = -ENOMEM;
+		PRINT_WARN("query ARP user space buffer is too small for "
+			   "the returned number of ARP entries. "
+			   "Aborting query!\n");
 		goto out_error;
 	}	
 	QETH_DBF_TEXT_(trace, 4, "anore%i",
 		       cmd->data.setassparms.hdr.number_of_replies);
 	QETH_DBF_TEXT_(trace, 4, "aseqn%i", cmd->data.setassparms.hdr.seq_no);
 	QETH_DBF_TEXT_(trace, 4, "anoen%i", qdata->no_entries);
+
+	if (qinfo->mask_bits & QETH_QARP_STRIP_ENTRIES) {
+		/* strip off "media specific information" */
+		qeth_copy_arp_entries_stripped(qinfo, qdata, entry_size,
+					       uentry_size);
+	} else
 	/*copy entries to user buffer*/
 		memcpy(qinfo->udata + qinfo->udata_offset,
-	       (char *)&qdata->data, qdata->no_entries*entry_size);
+		       (char *)&qdata->data, qdata->no_entries*uentry_size);
+
 	qinfo->no_entries += qdata->no_entries;
-	qinfo->udata_offset += (qdata->no_entries*entry_size);
+	qinfo->udata_offset += (qdata->no_entries*uentry_size);
 	/* check if all replies received ... */
 	if (cmd->data.setassparms.hdr.seq_no <
 	    cmd->data.setassparms.hdr.number_of_replies)
 		return 1;
 	memcpy(qinfo->udata, &qinfo->no_entries, 4);
+	/* keep STRIP_ENTRIES flag so the user program can distinguish
+	 * stripped entries from normal ones */
+	if (qinfo->mask_bits & QETH_QARP_STRIP_ENTRIES)
+		qdata->reply_bits |= QETH_QARP_STRIP_ENTRIES;
 	memcpy(qinfo->udata + QETH_QARP_MASK_OFFSET,&qdata->reply_bits,2);
 	return 0;
 out_error:
@@ -4088,8 +4125,8 @@
 			   "on %s!\n", card->info.if_name);
 		return -EOPNOTSUPP;
 	}
-
-	if (copy_from_user(&qinfo.udata_len, udata, 4))
+	/* get size of userspace buffer and mask_bits -> 6 bytes */
+	if (copy_from_user(&qinfo, udata, 6))
 		return -EFAULT;
 	if (!(qinfo.udata = kmalloc(qinfo.udata_len, GFP_KERNEL)))
 		return -ENOMEM;

--- linux-2.5/drivers/s390/net/qeth_mpc.h	24 May 2004 15:46:48 -0000	1.27.2.4
+++ linux-2.5/drivers/s390/net/qeth_mpc.h	24 May 2004 16:06:48 -0000	1.27.2.5
@@ -14,7 +14,7 @@
 
 #include <asm/qeth.h>
 
-#define VERSION_QETH_MPC_H "$Revision: 1.27.2.4 $"
+#define VERSION_QETH_MPC_H "$Revision: 1.27.2.5 $"
 
 extern const char *VERSION_QETH_MPC_C;
 
@@ -258,6 +258,7 @@
 /* used as parameter for arp_query reply */
 struct qeth_arp_query_info {
 	__u32 udata_len;
+	__u16 mask_bits;
 	__u32 udata_offset;
 	__u32 no_entries;
 	char *udata;

