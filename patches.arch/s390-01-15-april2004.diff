- Description: qeth: query ARP on HiperSockets overwrites HiperSockets device
               memory
  Symptom:     after a qetharp -q on a HiperSockets device, a subsequent
               operation (e.g. shutdown of the device) causes all HiperSockets
               devices on the same CHPID to be recovered
  Problem:     size of IPA PDU for the query ARP command is too large and causes
               HiperSockets memory to be overwritten
  Solution:    fix size of IPA PDU
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_main.c	21 Apr 2004 15:24:04 -0000	1.77.2.2
+++ linux-2.5/drivers/s390/net/qeth_main.c	22 Apr 2004 10:40:18 -0000	1.77.2.3
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.2 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.3 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.2 $	 $Date: 2004/04/21 15:24:04 $
+ *    $Revision: 1.77.2.3 $	 $Date: 2004/04/22 10:40:18 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.2 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.3 $"
 static const char *version = "qeth S/390 OSA-Express driver ("
 	VERSION_QETH_C "/" VERSION_QETH_H "/" VERSION_QETH_MPC_H
 	QETH_VERSION_IPV6 QETH_VERSION_VLAN ")";
@@ -3922,20 +3922,24 @@
 	struct qeth_cmd_buffer *iob;
 	struct qeth_ipa_arp_cmd *cmd;
 	u16 s1, s2;
-	
+
 	QETH_DBF_TEXT(trace,4,"getarpcm");
 	iob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETASSPARMS, proto);
 
 	memcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);
-	/* adjust sizes in IPA_PDU_HEADER */
-	s1 = (u32) IPA_PDU_HEADER_SIZE + QETH_ARP_CMD_BASE_LEN + data_len;
-	s2 = (u32) QETH_ARP_CMD_BASE_LEN + data_len;
-	memcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);
-	memcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);
-	memcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);
-	memcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);
+	
+	if ((IPA_PDU_HEADER_SIZE + QETH_ARP_CMD_BASE_LEN + data_len) > 256) {
+		/* adjust sizes in IPA_PDU_HEADER */
+		s1 = (u32) IPA_PDU_HEADER_SIZE + QETH_ARP_CMD_BASE_LEN +
+			   data_len;
+		s2 = (u32) QETH_ARP_CMD_BASE_LEN + data_len;
+		memcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);
+		memcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);
+		memcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);
+		memcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);
+	}
 
-	cmd = (struct qeth_ipa_arp_cmd *)(iob->data+IPA_PDU_HEADER_SIZE); 
+	cmd = (struct qeth_ipa_arp_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
 	cmd->shdr.assist_no = IPA_ARP_PROCESSING;
 	cmd->shdr.length = 8 + data_len;
 	cmd->shdr.command_code = cmd_code;
@@ -3999,9 +4003,11 @@
 		return -ENOMEM;
 	}
 	memset(qdata, 0, sizeof(struct qeth_arp_query_data));
+	/* do not give sizeof(struct qeth_arp_query_data) to next command;
+	 * this would cause the IPA PDU size to be set to a value of > 256
+	 * and this is to much for HiperSockets */
 	iob = qeth_get_ipa_arp_cmd_buffer(card, IPA_CMD_ASS_ARP_QUERY_INFO,
-					  sizeof(struct qeth_arp_query_data),
-					  QETH_PROT_IPV4);
+					  0, QETH_PROT_IPV4);
 	rc = qeth_send_ipa_arp_cmd(card, iob,
 				   (char *) qdata,
 				   sizeof(struct qeth_arp_query_data),

