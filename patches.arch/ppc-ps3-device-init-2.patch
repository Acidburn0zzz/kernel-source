patches/ps3-wip/ps3-device-init-2.patch
patches/ps3-wip/ps3-device-init-rework.patch
patches/ps3-wip/ps3-system-bus-uevent.diff
patches/ps3-wip/ps3-system-bus-add-modinfo-attribute.diff

---
 arch/powerpc/platforms/ps3/Makefile      |    1 
 arch/powerpc/platforms/ps3/device-init.c |  459 +++++++++++++++++++++++++++++++
 arch/powerpc/platforms/ps3/system-bus.c  |   50 +++
 3 files changed, 506 insertions(+), 4 deletions(-)

Index: b/arch/powerpc/platforms/ps3/Makefile
===================================================================
--- a/arch/powerpc/platforms/ps3/Makefile
+++ b/arch/powerpc/platforms/ps3/Makefile
@@ -1,6 +1,7 @@
 obj-y += setup.o mm.o time.o hvcall.o htab.o repository.o
 obj-y += interrupt.o exports.o os-area.o
 obj-y += system-bus.o
+obj-y += device-init.o
 
 obj-$(CONFIG_SMP) += smp.o
 obj-$(CONFIG_SPU_BASE) += spu.o
Index: b/arch/powerpc/platforms/ps3/device-init.c
===================================================================
--- /dev/null
+++ b/arch/powerpc/platforms/ps3/device-init.c
@@ -0,0 +1,459 @@
+/*
+ *  PS3 device init routines.
+ *
+ *  Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *  Copyright 2006 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define DEBUG 1
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include "platform.h"
+
+static int __devinit
+ps3_register_gelic (void)
+{
+	int result;
+	struct ps3_system_bus_device *dev;
+	struct ps3_repository_device repo;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	dev = kzalloc(sizeof(struct ps3_system_bus_device)
+		+ sizeof(struct ps3_dma_region), GFP_KERNEL);
+
+	dev->match_id = PS3_MATCH_ID_GELIC;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_GELIC, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_first_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	dev->did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_EVENT_PORT, &dev->interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	BUG_ON(dev->interrupt_id != 0);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_get_interrupt_id failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	dev->d_region = (struct ps3_dma_region *)((char*)dev
+		+ sizeof(struct ps3_system_bus_device));
+
+	ps3_dma_region_init(dev->d_region, &dev->did, PS3_DMA_64K,
+		PS3_DMA_OTHER);
+
+	result = ps3_system_bus_device_register(dev);
+
+	if (result) {
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(dev, 0xad, sizeof(struct ps3_system_bus_device)
+		+ sizeof(struct ps3_dma_region));
+#endif
+	kfree(dev);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ohci_0 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ohci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ohci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_OHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_OHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_OHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 16);
+	BUG_ON(bus_addr != 0x3010000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ohci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ohci_1 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ohci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ohci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_OHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	result = ps3_repository_find_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_OHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_OHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 17);
+	BUG_ON(bus_addr != 0x3020000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ohci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ehci_0 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ehci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ehci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_EHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_EHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_EHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 10);
+	BUG_ON(bus_addr != 0x3810000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ehci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ehci_1 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ehci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ehci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_EHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	result = ps3_repository_find_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_EHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_EHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 11);
+	BUG_ON(bus_addr != 0x3820000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ehci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_sys_manager (void)
+{
+	int result;
+	static struct ps3_vuart_port_device dev = {
+		.match_id = PS3_MATCH_ID_SYSTEM_MANAGER,
+	};
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	result = ps3_vuart_port_device_register(&dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_vuart_port_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+int __init
+ps3_register_known_devices (void)
+{
+	int result;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	//ps3_repository_dump_bus_info();
+
+	result = ps3_register_ohci_0();
+	result = ps3_register_ehci_0();
+	result = ps3_register_ohci_1();
+	result = ps3_register_ehci_1();
+#if defined(CONFIG_PS3_SYS_MANAGER)
+	result = ps3_register_sys_manager();
+#endif
+	result = ps3_register_gelic();
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+device_initcall(ps3_register_known_devices);
Index: b/arch/powerpc/platforms/ps3/system-bus.c
===================================================================
--- a/arch/powerpc/platforms/ps3/system-bus.c
+++ b/arch/powerpc/platforms/ps3/system-bus.c
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -30,6 +32,10 @@
 
 #include "platform.h"
 
+static struct device ps3_system_bus = {
+        .bus_id         = "ps3_system",
+};
+
 #define dump_mmio_region(_a) _dump_mmio_region(_a, __func__, __LINE__)
 static void _dump_mmio_region(const struct ps3_mmio_region* r,
 	const char* func, int line)
@@ -99,9 +105,10 @@ static int ps3_system_bus_probe(struct d
 
 	result = lv1_open_device(dev->did.bus_id, dev->did.dev_id, 0);
 
-	if (result) {
-		pr_debug("%s:%d: lv1_open_device failed (%d)\n",
-			__func__, __LINE__, result);
+	if (result && (result != LV1_BUSY || (dev->match_id != PS3_MATCH_ID_EHCI
+		&& dev->match_id != PS3_MATCH_ID_OHCI))) {
+		pr_debug("%s:%d: lv1_open_device failed: %s\n",
+			__func__, __LINE__, ps3_result(result));
 		result = -EACCES;
 		goto clean_none;
 	}
@@ -160,11 +167,42 @@ static int ps3_system_bus_remove(struct 
 	return 0;
 }
 
+static int ps3_system_bus_uevent(struct device *_dev, char **envp,
+				 int num_envp, char *buffer, int buffer_size)
+{
+	struct ps3_system_bus_device *dev = to_ps3_system_bus_device(_dev);
+	int i=0, length = 0;
+
+	if (add_uevent_var(envp, num_envp, &i, buffer, buffer_size,
+			   &length, "MODALIAS=ps3:%d",
+			   dev->match_id))
+		return -ENOMEM;
+
+	envp[i] = NULL;
+	return 0;
+}
+
+static ssize_t modalias_show(struct device *_dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct ps3_system_bus_device *dev = to_ps3_system_bus_device(_dev);
+        int len = snprintf(buf, PAGE_SIZE, "ps3:%d\n", dev->match_id);
+
+        return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute ps3_system_bus_dev_attrs[] = {
+        __ATTR_RO(modalias),
+        __ATTR_NULL,
+};
+
 struct bus_type ps3_system_bus_type = {
 	.name = "ps3_system_bus",
 	.match = ps3_system_bus_match,
 	.probe = ps3_system_bus_probe,
 	.remove = ps3_system_bus_remove,
+	.uevent = ps3_system_bus_uevent,
+	.dev_attrs = ps3_system_bus_dev_attrs,
 };
 
 int __init ps3_system_bus_init(void)
@@ -173,7 +211,8 @@ int __init ps3_system_bus_init(void)
 
 	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
 		return -ENODEV;
-
+	result = device_register(&ps3_system_bus);
+	BUG_ON(result);
 	result = bus_register(&ps3_system_bus_type);
 	BUG_ON(result);
 	return result;
@@ -353,6 +392,9 @@ int ps3_system_bus_device_register(struc
 	dev->core.archdata.dma_ops = &ps3_dma_ops;
 	dev->core.archdata.numa_node = 0;
 
+	if (!dev->core.parent)
+		dev->core.parent = &ps3_system_bus;
+
 	snprintf(dev->core.bus_id, sizeof(dev->core.bus_id), "sb_%02x",
 		dev_count++);
 
