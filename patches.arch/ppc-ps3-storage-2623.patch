PS3 storage, mainline status as of 2.6.23-rc1
Signed-off-by: Olaf Hering <olh@suse.de>
---
 drivers/block/ps3disk.c |   51 +++++++++++++++++++++++------------------
 drivers/char/ps3flash.c |   59 ++++++++++++++++++++++++++++--------------------
 drivers/scsi/ps3rom.c   |   24 ++++++++-----------
 3 files changed, 74 insertions(+), 60 deletions(-)

--- a/drivers/block/ps3disk.c
+++ b/drivers/block/ps3disk.c
@@ -33,8 +33,6 @@
 #define PS3DISK_MAX_DISKS	16
 #define PS3DISK_MINORS		16
 
-#define KERNEL_SECTOR_SIZE	512
-
 
 #define PS3DISK_NAME		"ps3d%c"
 
@@ -48,7 +46,6 @@ struct ps3disk_private {
 	u64 raw_capacity;
 	unsigned char model[ATA_ID_PROD_LEN+1];
 };
-#define ps3disk_priv(dev)	((dev)->sbd.core.driver_data)
 
 
 #define LV1_STORAGE_SEND_ATA_COMMAND	(2)
@@ -93,7 +90,7 @@ static struct block_device_operations ps
 static void ps3disk_scatter_gather(struct ps3_storage_device *dev,
 				   struct request *req, int gather)
 {
-	unsigned int sectors = 0, offset = 0;
+	unsigned int offset = 0;
 	struct bio *bio;
 	sector_t sector;
 	struct bio_vec *bvec;
@@ -108,16 +105,16 @@ static void ps3disk_scatter_gather(struc
 			__func__, __LINE__, i, bio_segments(bio),
 			bio_sectors(bio), sector);
 		bio_for_each_segment(bvec, bio, j) {
-			size = bio_cur_sectors(bio)*KERNEL_SECTOR_SIZE;
-			buf = __bio_kmap_atomic(bio, j, KM_USER0);
+			size = bvec->bv_len;
+			buf = __bio_kmap_atomic(bio, j, KM_IRQ0);
 			if (gather)
 				memcpy(dev->bounce_buf+offset, buf, size);
 			else
 				memcpy(buf, dev->bounce_buf+offset, size);
 			offset += size;
-			__bio_kunmap_atomic(bio, KM_USER0);
+			flush_kernel_dcache_page(bio_iovec_idx(bio, j)->bv_page);
+			__bio_kunmap_atomic(bio, KM_IRQ0);
 		}
-		sectors += bio_sectors(bio);
 		i++;
 	}
 }
@@ -125,7 +122,7 @@ static void ps3disk_scatter_gather(struc
 static int ps3disk_submit_request_sg(struct ps3_storage_device *dev,
 				     struct request *req)
 {
-	struct ps3disk_private *priv = ps3disk_priv(dev);
+	struct ps3disk_private *priv = dev->sbd.core.driver_data;
 	int write = rq_data_dir(req), res;
 	const char *op = write ? "write" : "read";
 	u64 start_sector, sectors;
@@ -134,6 +131,7 @@ static int ps3disk_submit_request_sg(str
 #ifdef DEBUG
 	unsigned int n = 0;
 	struct bio *bio;
+
 	rq_for_each_bio(bio, req)
 		n++;
 	dev_dbg(&dev->sbd.core,
@@ -142,8 +140,8 @@ static int ps3disk_submit_request_sg(str
 		req->hard_nr_sectors);
 #endif
 
-	start_sector = req->sector*priv->blocking_factor;
-	sectors = req->nr_sectors*priv->blocking_factor;
+	start_sector = req->sector * priv->blocking_factor;
+	sectors = req->nr_sectors * priv->blocking_factor;
 	dev_dbg(&dev->sbd.core, "%s:%u: %s %lu sectors starting at %lu\n",
 		__func__, __LINE__, op, sectors, start_sector);
 
@@ -172,7 +170,7 @@ static int ps3disk_submit_request_sg(str
 static int ps3disk_submit_flush_request(struct ps3_storage_device *dev,
 					struct request *req)
 {
-	struct ps3disk_private *priv = ps3disk_priv(dev);
+	struct ps3disk_private *priv = dev->sbd.core.driver_data;
 	u64 res;
 
 	dev_dbg(&dev->sbd.core, "%s:%u: flush request\n", __func__, __LINE__);
@@ -216,7 +214,7 @@ static void ps3disk_do_request(struct ps
 static void ps3disk_request(request_queue_t *q)
 {
 	struct ps3_storage_device *dev = q->queuedata;
-	struct ps3disk_private *priv = ps3disk_priv(dev);
+	struct ps3disk_private *priv = dev->sbd.core.driver_data;
 
 	if (priv->req) {
 		dev_dbg(&dev->sbd.core, "%s:%u busy\n", __func__, __LINE__);
@@ -249,7 +247,7 @@ static irqreturn_t ps3disk_interrupt(int
 		return IRQ_HANDLED;
 	}
 
-	priv = ps3disk_priv(dev);
+	priv = dev->sbd.core.driver_data;
 	req = priv->req;
 	if (!req) {
 		dev_dbg(&dev->sbd.core,
@@ -373,7 +371,7 @@ static void ata_id_c_string(const u16 *i
 
 static int ps3disk_identify(struct ps3_storage_device *dev)
 {
-	struct ps3disk_private *priv = ps3disk_priv(dev);
+	struct ps3disk_private *priv = dev->sbd.core.driver_data;
 	struct lv1_ata_cmnd_block ata_cmnd;
 	u16 *id = dev->bounce_buf;
 	u64 res;
@@ -438,6 +436,8 @@ static int ps3disk_issue_flush(request_q
 
 static unsigned long ps3disk_mask;
 
+static DEFINE_MUTEX(ps3disk_mask_mutex);
+
 static int __devinit ps3disk_probe(struct ps3_system_bus_device *_dev)
 {
 	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
@@ -447,7 +447,7 @@ static int __devinit ps3disk_probe(struc
 	struct request_queue *queue;
 	struct gendisk *gendisk;
 
-	if (dev->blk_size < KERNEL_SECTOR_SIZE) {
+	if (dev->blk_size < 512) {
 		dev_err(&dev->sbd.core,
 			"%s:%u: cannot handle block size %lu\n", __func__,
 			__LINE__, dev->blk_size);
@@ -455,13 +455,16 @@ static int __devinit ps3disk_probe(struc
 	}
 
 	BUILD_BUG_ON(PS3DISK_MAX_DISKS > BITS_PER_LONG);
+	mutex_lock(&ps3disk_mask_mutex);
 	devidx = find_first_zero_bit(&ps3disk_mask, PS3DISK_MAX_DISKS);
 	if (devidx >= PS3DISK_MAX_DISKS) {
 		dev_err(&dev->sbd.core, "%s:%u: Too many disks\n", __func__,
 			__LINE__);
+		mutex_unlock(&ps3disk_mask_mutex);
 		return -ENOSPC;
 	}
 	__set_bit(devidx, &ps3disk_mask);
+	mutex_unlock(&ps3disk_mask_mutex);
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
@@ -469,7 +472,7 @@ static int __devinit ps3disk_probe(struc
 		goto fail;
 	}
 
-	ps3disk_priv(dev) = priv;
+	dev->sbd.core.driver_data = priv;
 	spin_lock_init(&priv->lock);
 
 	dev->bounce_size = BOUNCE_SIZE;
@@ -498,7 +501,7 @@ static int __devinit ps3disk_probe(struc
 
 	blk_queue_bounce_limit(queue, BLK_BOUNCE_HIGH);
 
-	blk_queue_max_sectors(queue, dev->bounce_size/KERNEL_SECTOR_SIZE);
+	blk_queue_max_sectors(queue, dev->bounce_size >> 9);
 	blk_queue_segment_boundary(queue, -1UL);
 	blk_queue_dma_alignment(queue, dev->blk_size-1);
 	blk_queue_hardsect_size(queue, dev->blk_size);
@@ -528,7 +531,7 @@ static int __devinit ps3disk_probe(struc
 	gendisk->driverfs_dev = &dev->sbd.core;
 	snprintf(gendisk->disk_name, sizeof(gendisk->disk_name), PS3DISK_NAME,
 		 devidx+'a');
-	priv->blocking_factor = dev->blk_size/KERNEL_SECTOR_SIZE;
+	priv->blocking_factor = dev->blk_size >> 9;
 	set_capacity(gendisk,
 		     dev->regions[dev->region_idx].size*priv->blocking_factor);
 
@@ -548,19 +551,23 @@ fail_free_bounce:
 	kfree(dev->bounce_buf);
 fail_free_priv:
 	kfree(priv);
-	ps3disk_priv(dev) = NULL;
+	dev->sbd.core.driver_data = NULL;
 fail:
+	mutex_lock(&ps3disk_mask_mutex);
 	__clear_bit(devidx, &ps3disk_mask);
+	mutex_unlock(&ps3disk_mask_mutex);
 	return error;
 }
 
 static int ps3disk_remove(struct ps3_system_bus_device *_dev)
 {
 	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
-	struct ps3disk_private *priv = ps3disk_priv(dev);
+	struct ps3disk_private *priv = dev->sbd.core.driver_data;
 
+	mutex_lock(&ps3disk_mask_mutex);
 	__clear_bit(priv->gendisk->first_minor / PS3DISK_MINORS,
 		    &ps3disk_mask);
+	mutex_unlock(&ps3disk_mask_mutex);
 	del_gendisk(priv->gendisk);
 	blk_cleanup_queue(priv->queue);
 	put_disk(priv->gendisk);
@@ -569,7 +576,7 @@ static int ps3disk_remove(struct ps3_sys
 	ps3stor_teardown(dev);
 	kfree(dev->bounce_buf);
 	kfree(priv);
-	ps3disk_priv(dev) = NULL;
+	dev->sbd.core.driver_data = NULL;
 	return 0;
 }
 
--- a/drivers/char/ps3flash.c
+++ b/drivers/char/ps3flash.c
@@ -34,7 +34,6 @@
 struct ps3flash_private {
 	struct mutex mutex;	/* Bounce buffer mutex */
 };
-#define ps3flash_priv(dev)	((dev)->sbd.core.driver_data)
 
 static struct ps3_storage_device *ps3flash_dev;
 
@@ -81,28 +80,35 @@ static ssize_t ps3flash_write_chunk(stru
 static loff_t ps3flash_llseek(struct file *file, loff_t offset, int origin)
 {
 	struct ps3_storage_device *dev = ps3flash_dev;
-	u64 size = dev->regions[dev->region_idx].size*dev->blk_size;
+	loff_t res;
 
+	mutex_lock(&file->f_mapping->host->i_mutex);
 	switch (origin) {
 	case 1:
 		offset += file->f_pos;
 		break;
 	case 2:
-		offset += size;
+		offset += dev->regions[dev->region_idx].size*dev->blk_size;
 		break;
 	}
-	if (offset < 0)
-		return -EINVAL;
+	if (offset < 0) {
+		res = -EINVAL;
+		goto out;
+	}
 
 	file->f_pos = offset;
-	return file->f_pos;
+	res = file->f_pos;
+
+out:
+	mutex_unlock(&file->f_mapping->host->i_mutex);
+	return res;
 }
 
 static ssize_t ps3flash_read(struct file *file, char __user *buf, size_t count,
 			     loff_t *pos)
 {
 	struct ps3_storage_device *dev = ps3flash_dev;
-	struct ps3flash_private *priv = ps3flash_priv(dev);
+	struct ps3flash_private *priv = dev->sbd.core.driver_data;
 	u64 size, start_sector, end_sector, offset;
 	ssize_t sectors_read;
 	size_t remaining, n;
@@ -115,15 +121,16 @@ static ssize_t ps3flash_read(struct file
 	if (*pos >= size || !count)
 		return 0;
 
-	if (*pos+count > size) {
+	if (*pos + count > size) {
 		dev_dbg(&dev->sbd.core,
 			"%s:%u Truncating count from %zu to %llu\n", __func__,
 			__LINE__, count, size - *pos);
 		count = size - *pos;
 	}
 
-	start_sector = do_div_llr(*pos, dev->blk_size, &offset);
-	end_sector = DIV_ROUND_UP(*pos+count, dev->blk_size);
+	start_sector = *pos / dev->blk_size;
+	offset = *pos % dev->blk_size;
+	end_sector = DIV_ROUND_UP(*pos + count, dev->blk_size);
 
 	remaining = count;
 	do {
@@ -134,7 +141,7 @@ static ssize_t ps3flash_read(struct file
 						     0);
 		if (sectors_read < 0) {
 			mutex_unlock(&priv->mutex);
-			return sectors_read;
+			goto fail;
 		}
 
 		n = min(remaining, sectors_read*dev->blk_size-offset);
@@ -143,7 +150,8 @@ static ssize_t ps3flash_read(struct file
 			__func__, __LINE__, n, dev->bounce_buf+offset, buf);
 		if (copy_to_user(buf, dev->bounce_buf+offset, n)) {
 			mutex_unlock(&priv->mutex);
-			return -EFAULT;
+			sectors_read = -EFAULT;
+			goto fail;
 		}
 
 		mutex_unlock(&priv->mutex);
@@ -156,13 +164,16 @@ static ssize_t ps3flash_read(struct file
 	} while (remaining > 0);
 
 	return count;
+
+fail:
+	return sectors_read;
 }
 
 static ssize_t ps3flash_write(struct file *file, const char __user *buf,
 			      size_t count, loff_t *pos)
 {
 	struct ps3_storage_device *dev = ps3flash_dev;
-	struct ps3flash_private *priv = ps3flash_priv(dev);
+	struct ps3flash_private *priv = dev->sbd.core.driver_data;
 	u64 size, chunk_sectors, start_write_sector, end_write_sector,
 	    end_read_sector, start_read_sector, head, tail, offset;
 	ssize_t res;
@@ -177,7 +188,7 @@ static ssize_t ps3flash_write(struct fil
 	if (*pos >= size || !count)
 		return 0;
 
-	if (*pos+count > size) {
+	if (*pos + count > size) {
 		dev_dbg(&dev->sbd.core,
 			"%s:%u Truncating count from %zu to %llu\n", __func__,
 			__LINE__, count, size - *pos);
@@ -186,13 +197,13 @@ static ssize_t ps3flash_write(struct fil
 
 	chunk_sectors = dev->bounce_size / dev->blk_size;
 
-	start_write_sector = do_div_llr(*pos, dev->bounce_size, &offset) *
-			     chunk_sectors;
-	end_write_sector = DIV_ROUND_UP(*pos+count, dev->bounce_size) *
+	start_write_sector = *pos / dev->bounce_size * chunk_sectors;
+	offset = *pos % dev->bounce_size;
+	end_write_sector = DIV_ROUND_UP(*pos + count, dev->bounce_size) *
 			   chunk_sectors;
 
 	end_read_sector = DIV_ROUND_UP(*pos, dev->blk_size);
-	start_read_sector = (*pos+count) / dev->blk_size;
+	start_read_sector = (*pos + count) / dev->blk_size;
 
 	/*
 	 * As we have to write in 256 KiB chunks, while we can read in blk_size
@@ -204,8 +215,8 @@ static ssize_t ps3flash_write(struct fil
 	 * All of this is complicated by using only one 256 KiB bounce buffer.
 	 */
 
-	head = end_read_sector-start_write_sector;
-	tail = end_write_sector-start_read_sector;
+	head = end_read_sector - start_write_sector;
+	tail = end_write_sector - start_read_sector;
 
 	remaining = count;
 	do {
@@ -355,7 +366,7 @@ static int __devinit ps3flash_probe(stru
 		goto fail;
 	}
 
-	ps3flash_priv(dev) = priv;
+	dev->sbd.core.driver_data = priv;
 	mutex_init(&priv->mutex);
 
 	dev->bounce_size = ps3flash_bounce_buffer.size;
@@ -381,7 +392,7 @@ fail_teardown:
 	ps3stor_teardown(dev);
 fail_free_priv:
 	kfree(priv);
-	ps3flash_priv(dev) = NULL;
+	dev->sbd.core.driver_data = NULL;
 fail:
 	ps3flash_dev = NULL;
 	return error;
@@ -393,8 +404,8 @@ static int ps3flash_remove(struct ps3_sy
 
 	misc_deregister(&ps3flash_misc);
 	ps3stor_teardown(dev);
-	kfree(ps3flash_priv(dev));
-	ps3flash_priv(dev) = NULL;
+	kfree(dev->sbd.core.driver_data);
+	dev->sbd.core.driver_data = NULL;
 	ps3flash_dev = NULL;
 	return 0;
 }
--- a/drivers/scsi/ps3rom.c
+++ b/drivers/scsi/ps3rom.c
@@ -42,7 +42,6 @@ struct ps3rom_private {
 	struct ps3_storage_device *dev;
 	struct scsi_cmnd *curr_cmd;
 };
-#define ps3rom_priv(dev)	((dev)->sbd.core.driver_data)
 
 
 #define LV1_STORAGE_SEND_ATAPI_COMMAND	(1)
@@ -112,16 +111,15 @@ static int fill_from_dev_buffer(struct s
 	active = 1;
 	for (k = 0, req_len = 0, act_len = 0; k < cmd->use_sg; ++k, ++sgpnt) {
 		if (active) {
-			kaddr = kmap_atomic(sgpnt->page, KM_USER0);
-			if (!kaddr)
-				return -1;
+			kaddr = kmap_atomic(sgpnt->page, KM_IRQ0);
 			len = sgpnt->length;
 			if ((req_len + len) > buflen) {
 				active = 0;
 				len = buflen - req_len;
 			}
 			memcpy(kaddr + sgpnt->offset, buf + req_len, len);
-			kunmap_atomic(kaddr, KM_USER0);
+			flush_kernel_dcache_page(sgpnt->page);
+			kunmap_atomic(kaddr, KM_IRQ0);
 			act_len += len;
 		}
 		req_len += sgpnt->length;
@@ -149,16 +147,14 @@ static int fetch_to_dev_buffer(struct sc
 
 	sgpnt = cmd->request_buffer;
 	for (k = 0, req_len = 0, fin = 0; k < cmd->use_sg; ++k, ++sgpnt) {
-		kaddr = kmap_atomic(sgpnt->page, KM_USER0);
-		if (!kaddr)
-			return -1;
+		kaddr = kmap_atomic(sgpnt->page, KM_IRQ0);
 		len = sgpnt->length;
 		if ((req_len + len) > buflen) {
 			len = buflen - req_len;
 			fin = 1;
 		}
 		memcpy(buf + req_len, kaddr + sgpnt->offset, len);
-		kunmap_atomic(kaddr, KM_USER0);
+		kunmap_atomic(kaddr, KM_IRQ0);
 		if (fin)
 			return req_len + len;
 		req_len += sgpnt->length;
@@ -378,7 +374,7 @@ static irqreturn_t ps3rom_interrupt(int 
 		return IRQ_HANDLED;
 	}
 
-	host = ps3rom_priv(dev);
+	host = dev->sbd.core.driver_data;
 	priv = shost_priv(host);
 	cmd = priv->curr_cmd;
 
@@ -468,7 +464,7 @@ static int __devinit ps3rom_probe(struct
 	}
 
 	priv = shost_priv(host);
-	ps3rom_priv(dev) = host;
+	dev->sbd.core.driver_data = host;
 	priv->dev = dev;
 
 	/* One device/LUN per SCSI bus */
@@ -488,7 +484,7 @@ static int __devinit ps3rom_probe(struct
 
 fail_host_put:
 	scsi_host_put(host);
-	ps3rom_priv(dev) = NULL;
+	dev->sbd.core.driver_data = NULL;
 fail_teardown:
 	ps3stor_teardown(dev);
 fail_free_bounce:
@@ -499,12 +495,12 @@ fail_free_bounce:
 static int ps3rom_remove(struct ps3_system_bus_device *_dev)
 {
 	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
-	struct Scsi_Host *host = ps3rom_priv(dev);
+	struct Scsi_Host *host = dev->sbd.core.driver_data;
 
 	scsi_remove_host(host);
 	ps3stor_teardown(dev);
 	scsi_host_put(host);
-	ps3rom_priv(dev) = NULL;
+	dev->sbd.core.driver_data = NULL;
 	kfree(dev->bounce_buf);
 	return 0;
 }
