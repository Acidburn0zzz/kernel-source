- Description: improved handling of unsolicited interrupts
  Symptom:     exceptional device conditions are not detected correctly,
               resulting in unexpected behaviour of the device driver
  Problem:     A device deferred condition code 1 should always be
               reported as solicited, but is detected as unsolicited.
               After an unsolicited unit check without concurrent sense
               data, no sense data is reported to the driver
  Solution:    Move the check for unsolicited interrupts to a proper
               place
  Problem-ID:  9973
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/cio/device_status.c	1 Mar 2004 14:26:42 -0000	1.23
+++ linux-2.5/drivers/s390/cio/device_status.c	14 Jul 2004 13:32:42 -0000	1.23.2.1
@@ -216,8 +216,9 @@
 	/*
 	 * Don't accumulate unsolicited interrupts.
 	 */
-	if (irb->scsw.stctl ==
-	    (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS))
+	if ((irb->scsw.stctl ==
+	     (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) &&
+	    (!irb->scsw.cc))
 		return;
 
 	cdev_irb = &cdev->private->irb;

--- linux-2.5/drivers/s390/cio/device_fsm.c	14 Jul 2004 09:27:59 -0000	1.85.2.6
+++ linux-2.5/drivers/s390/cio/device_fsm.c	14 Jul 2004 13:32:42 -0000	1.85.2.7
@@ -675,8 +675,20 @@
 
 	irb = (struct irb *) __LC_IRB;
 	/* Check for unsolicited interrupt. */
-	if (irb->scsw.stctl ==
-	    		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
+	if ((irb->scsw.stctl ==
+	    		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS))
+	    && (!irb->scsw.cc)) {
+		if ((irb->scsw.dstat & DEV_STAT_UNIT_CHECK) &&
+		    !irb->esw.esw0.erw.cons) {
+			/* Unit check but no sense data. Need basic sense. */
+			if (ccw_device_do_sense(cdev, irb) != 0)
+				goto call_handler_unsol;
+			memcpy(irb, &cdev->private->irb, sizeof(struct irb));
+			cdev->private->state = DEV_STATE_W4SENSE;
+			cdev->private->intparm = 0;
+			return;
+		}
+call_handler_unsol:
 		if (cdev->handler)
 			cdev->handler (cdev, 0, irb);
 		return;
@@ -738,11 +750,15 @@
 	/* Check for unsolicited interrupt. */
 	if (irb->scsw.stctl ==
 	    		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
-		if (cdev->handler)
-			cdev->handler (cdev, 0, irb);
 		if (irb->scsw.cc == 1)
 			/* Basic sense hasn't started. Try again. */
 			ccw_device_do_sense(cdev, irb);
+		else {
+			printk("Huh? %s(%s): unsolicited interrupt...\n",
+			       __FUNCTION__, cdev->dev.bus_id);
+			if (cdev->handler)
+				cdev->handler (cdev, 0, irb);
+		}
 		return;
 	}
 	/* Add basic sense info to irb. */
@@ -765,13 +781,6 @@
 	struct irb *irb;
 
 	irb = (struct irb *) __LC_IRB;
-	/* Check for unsolicited interrupt. */
-	if (irb->scsw.stctl ==
-	    		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
-		if (cdev->handler)
-			cdev->handler (cdev, 0, irb);
-		return;
-	}
 	/* Accumulate status. We don't do basic sense. */
 	ccw_device_accumulate_irb(cdev, irb);
 	/* Try to start delayed device verification. */
@@ -837,15 +846,6 @@
 	struct subchannel *sch;
 
 	irb = (struct irb *) __LC_IRB;
-	/* Check for unsolicited interrupt. */
-	if (irb->scsw.stctl ==
-	    		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
-		if (cdev->handler)
-			cdev->handler (cdev, 0, irb);
-		if (irb->scsw.cc == 1)
-			goto call_handler;
-		return;
-	}
 	/*
 	 * Accumulate status and find out if a basic sense is needed.
 	 * This is fine since we have already adapted the lpm.
@@ -857,7 +857,7 @@
 		}
 		return;
 	}
-call_handler:
+
 	/* Iff device is idle, reset timeout. */
 	sch = to_subchannel(cdev->dev.parent);
 	if (!stsch(sch->irq, &sch->schib))
@@ -926,8 +926,9 @@
 	case DEV_EVENT_INTERRUPT:
 		irb = (struct irb *) __LC_IRB;
 		/* Check for unsolicited interrupt. */
-		if (irb->scsw.stctl ==
-		    (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS))
+		if ((irb->scsw.stctl ==
+		     (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) &&
+		    (!irb->scsw.cc))
 			/* FIXME: we should restart stlck here, but this
 			 * is extremely unlikely ... */
 			goto out_wakeup;

--- linux-2.5/drivers/s390/cio/device_id.c	19 Feb 2004 20:43:19 -0000	1.21
+++ linux-2.5/drivers/s390/cio/device_id.c	14 Jul 2004 13:32:42 -0000	1.21.2.1
@@ -303,15 +303,14 @@
 
 	sch = to_subchannel(cdev->dev.parent);
 	irb = (struct irb *) __LC_IRB;
-	/*
-	 * Unsolicited interrupts may pertain to an earlier status pending or
-	 * busy condition on the subchannel. Retry sense id.
-	 */
+	/* Retry sense id for cc=1. */
 	if (irb->scsw.stctl ==
 	    (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
-		ret = __ccw_device_sense_id_start(cdev);
-		if (ret && ret != -EBUSY)
-			ccw_device_sense_id_done(cdev, ret);
+		if (irb->scsw.cc == 1) {
+			ret = __ccw_device_sense_id_start(cdev);
+			if (ret && ret != -EBUSY)
+				ccw_device_sense_id_done(cdev, ret);
+		}
 		return;
 	}
 	if (ccw_device_accumulate_and_sense(cdev, irb) != 0)

--- linux-2.5/drivers/s390/cio/device_pgid.c	14 May 2004 11:27:49 -0000	1.21.2.2
+++ linux-2.5/drivers/s390/cio/device_pgid.c	14 Jul 2004 13:32:42 -0000	1.21.2.3
@@ -143,15 +143,14 @@
 	int ret;
 
 	irb = (struct irb *) __LC_IRB;
-	/*
-	 * Unsolicited interrupts may pertain to an earlier status pending or
-	 * busy condition on the subchannel. Retry sense pgid.
-	 */
+	/* Retry sense pgid for cc=1. */
 	if (irb->scsw.stctl ==
 	    (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
-		ret = __ccw_device_sense_pgid_start(cdev);
-		if (ret && ret != -EBUSY)
-			ccw_device_sense_pgid_done(cdev, ret);
+		if (irb->scsw.cc == 1) {
+			ret = __ccw_device_sense_pgid_start(cdev);
+			if (ret && ret != -EBUSY)
+				ccw_device_sense_pgid_done(cdev, ret);
+		}
 		return;
 	}
 	if (ccw_device_accumulate_and_sense(cdev, irb) != 0)
@@ -310,13 +309,11 @@
 	struct irb *irb;
 
 	irb = (struct irb *) __LC_IRB;
-	/*
-	 * Unsolicited interrupts may pertain to an earlier status pending or
-	 * busy condition on the subchannel. Restart path verification.
-	 */
+	/* Retry set pgid for cc=1. */
 	if (irb->scsw.stctl ==
 	    (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
-		__ccw_device_verify_start(cdev);
+		if (irb->scsw.cc == 1)
+			__ccw_device_verify_start(cdev);
 		return;
 	}
 	if (ccw_device_accumulate_and_sense(cdev, irb) != 0)
@@ -397,10 +394,13 @@
 	int ret;
 
 	irb = (struct irb *) __LC_IRB;
-	/* Ignore unsolicited interrupts. */
+	/* Retry set pgid for cc=1. */
 	if (irb->scsw.stctl ==
-	    		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS))
+	    (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
+		if (irb->scsw.cc == 1)
+			__ccw_device_disband_start(cdev);
 		return;
+	}
 	if (ccw_device_accumulate_and_sense(cdev, irb) != 0)
 		return;
 	sch = to_subchannel(cdev->dev.parent);

