- Description: dasd: Enhanced IRB handling.
  Symptom:     Rare IO error postings due to memory pressure.
  Problem:     Unnecessary kmalloc in dasd int_handler to store the IRB.
               This might prevent ERP handling because of allocation failure.
  Solution:    Integrate the irb struct directly into the ccw_request structure.
  Problem-ID:  9792
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/block/dasd_erp.c	6 May 2004 15:04:53 -0000	1.10.8.1
+++ linux-2.5/drivers/s390/block/dasd_erp.c	2 Jul 2004 14:01:48 -0000	1.10.8.2
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision: 1.10.8.1 $
+ * $Revision: 1.10.8.2 $
  */
 
 #include <linux/config.h>
@@ -77,8 +77,6 @@
 {
 	unsigned long flags;
 
-	if (cqr->dstat != NULL)
-		kfree(cqr->dstat);
 	debug_text_event(dasd_debug_area, 1, "FREE");
 	debug_int_event(dasd_debug_area, 1, (long) cqr);
 	spin_lock_irqsave(&device->mem_lock, flags);

--- linux-2.5/drivers/s390/block/dasd_int.h	2 Jul 2004 13:51:18 -0000	1.56.2.3
+++ linux-2.5/drivers/s390/block/dasd_int.h	2 Jul 2004 14:01:48 -0000	1.56.2.4
@@ -6,7 +6,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.56.2.3 $
+ * $Revision: 1.56.2.4 $
  */
 
 #ifndef DASD_INT_H
@@ -168,7 +168,7 @@
 	void *data;			/* pointer to data area */
 
 	/* these are important for recovering erroneous requests          */
-	struct irb *dstat;		/* device status in case of an error */
+	struct irb irb;			/* device status in case of an error */
 	struct dasd_ccw_req *refers;	/* ERP-chain queueing. */
 	void *function; 		/* originating ERP action */
 

--- linux-2.5/drivers/s390/block/dasd.c	2 Jul 2004 13:51:18 -0000	1.137.2.7
+++ linux-2.5/drivers/s390/block/dasd.c	2 Jul 2004 14:01:48 -0000	1.137.2.8
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision: 1.137.2.7 $
+ * $Revision: 1.137.2.8 $
  */
 
 #include <linux/config.h>
@@ -623,8 +623,6 @@
 		clear_normalized_cda(ccw);
 	} while (ccw++->flags & (CCW_FLAG_CC | CCW_FLAG_DC));
 #endif
-	if (cqr->dstat != NULL)
-		kfree(cqr->dstat);
 	debug_text_event ( dasd_debug_area, 1, "FREE");
 	debug_int_event ( dasd_debug_area, 1, (long) cqr);
 	if (cqr->cpaddr != NULL)
@@ -640,8 +638,6 @@
 {
 	unsigned long flags;
 
-	if (cqr->dstat != NULL)
-		kfree(cqr->dstat);
 	debug_text_event(dasd_debug_area, 1, "FREE");
 	debug_int_event(dasd_debug_area, 1, (long) cqr);
 	spin_lock_irqsave(&device->mem_lock, flags);
@@ -997,13 +993,7 @@
 			}
 		}
 	} else {		/* error */
-		if (cqr->dstat == NULL)
-			cqr->dstat = kmalloc(sizeof(struct irb), GFP_ATOMIC);
-		if (cqr->dstat)
-			memcpy(cqr->dstat, irb, sizeof (struct irb));
-		else
-			DEV_MESSAGE(KERN_ERR, device, "%s",
-				    "no memory for dstat...ignoring");
+		memcpy(&cqr->irb, irb, sizeof (struct irb));
 #ifdef ERP_DEBUG
 		/* dump sense data */
 		dasd_log_sense(cqr, irb);
@@ -1078,11 +1068,11 @@
 		/*  Process requests with DASD_CQR_ERROR */
 		if (cqr->status == DASD_CQR_ERROR) {
 			cqr->retries--;
-			if (cqr->dstat->scsw.fctl & SCSW_FCTL_HALT_FUNC) {
+			if (cqr->irb.scsw.fctl & SCSW_FCTL_HALT_FUNC) {
 				cqr->status = DASD_CQR_FAILED;
 				cqr->stopclk = get_clock();
 			} else {
-				if (cqr->dstat->esw.esw0.erw.cons) {
+				if (cqr->irb.esw.esw0.erw.cons) {
 					erp_fn = device->discipline->erp_action(cqr);
 					erp_fn(cqr);
 				} else

--- linux-2.5/drivers/s390/block/dasd_3990_erp.c	20 Apr 2004 13:28:03 -0000	1.29.2.2
+++ linux-2.5/drivers/s390/block/dasd_3990_erp.c	2 Jul 2004 14:01:48 -0000	1.29.2.3
@@ -5,7 +5,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000, 2001
  *
- * $Revision: 1.29.2.2 $
+ * $Revision: 1.29.2.3 $
  */
 
 #include <linux/timer.h>
@@ -301,15 +301,15 @@
 	opm = ccw_device_get_path_mask(device->cdev);
 	//FIXME: start with get_opm ?
 	if (erp->lpm == 0)
-		erp->lpm = LPM_ANYPATH & ~(erp->dstat->esw.esw0.sublog.lpum);
+		erp->lpm = LPM_ANYPATH & ~(erp->irb.esw.esw0.sublog.lpum);
 	else
-		erp->lpm &= ~(erp->dstat->esw.esw0.sublog.lpum);
+		erp->lpm &= ~(erp->irb.esw.esw0.sublog.lpum);
 
 	if ((erp->lpm & opm) != 0x00) {
 
 		DEV_MESSAGE(KERN_DEBUG, device,
 			    "try alternate lpm=%x (lpum=%x / opm=%x)",
-			    erp->lpm, erp->dstat->esw.esw0.sublog.lpum, opm);
+			    erp->lpm, erp->irb.esw.esw0.sublog.lpum, opm);
 
 		/* reset status to queued to handle the request again... */
 		if (erp->status > DASD_CQR_QUEUED)
@@ -319,7 +319,7 @@
 		DEV_MESSAGE(KERN_ERR, device,
 			    "No alternate channel path left (lpum=%x / "
 			    "opm=%x) -> permanent error",
-			    erp->dstat->esw.esw0.sublog.lpum, opm);
+			    erp->irb.esw.esw0.sublog.lpum, opm);
 
 		/* post request with permanent error */
 		if (erp->status > DASD_CQR_QUEUED)
@@ -1677,7 +1677,7 @@
 
 	/* determine the address of the CCW to be restarted */
 	/* Imprecise ending is not set -> addr from IRB-SCSW */
-	cpa = default_erp->refers->dstat->scsw.cpa;
+	cpa = default_erp->refers->irb.scsw.cpa;
 
 	if (cpa == 0) {
 
@@ -1823,7 +1823,7 @@
 
 	/* determine the address of the CCW to be restarted */
 	/* Imprecise ending is not set -> addr from IRB-SCSW */
-	cpa = previous_erp->dstat->scsw.cpa;
+	cpa = previous_erp->irb.scsw.cpa;
 
 	if (cpa == 0) {
 
@@ -2233,7 +2233,7 @@
 	struct dasd_ccw_req *erp_new = NULL;
 	/* sense data are located in the refers record of the */
 	/* already set up new ERP !			      */
-	char *sense = erp->refers->dstat->ecw;
+	char *sense = erp->refers->irb.ecw;
 
 	/* distinguish between 24 and 32 byte sense data */
 	if (sense[27] & DASD_SENSE_BIT_0) {
@@ -2369,14 +2369,14 @@
 {
 
 	/* check failed CCW */
-	if (cqr1->dstat->scsw.cpa != cqr2->dstat->scsw.cpa) {
+	if (cqr1->irb.scsw.cpa != cqr2->irb.scsw.cpa) {
 		//	return 0;	/* CCW doesn't match */
 	}
 
 	/* check sense data; byte 0-2,25,27 */
-	if (!((memcmp (cqr1->dstat->ecw, cqr2->dstat->ecw, 3) == 0) &&
-	      (cqr1->dstat->ecw[27] == cqr2->dstat->ecw[27]) &&
-	      (cqr1->dstat->ecw[25] == cqr2->dstat->ecw[25]))) {
+	if (!((memcmp (cqr1->irb.ecw, cqr2->irb.ecw, 3) == 0) &&
+	      (cqr1->irb.ecw[27] == cqr2->irb.ecw[27]) &&
+	      (cqr1->irb.ecw[25] == cqr2->irb.ecw[25]))) {
 
 		return 0;	/* sense doesn't match */
 	}
@@ -2449,7 +2449,7 @@
 {
 
 	struct dasd_device *device = erp->device;
-	char *sense = erp->dstat->ecw;
+	char *sense = erp->irb.ecw;
 
 	/* check for 24 byte sense ERP */
 	if ((erp->function == dasd_3990_erp_bus_out) ||
@@ -2562,7 +2562,7 @@
 
 	if (erp->retries > 0) {
 
-		char *sense = erp->refers->dstat->ecw;
+		char *sense = erp->refers->irb.ecw;
 
 		/* check for special retries */
 		if (erp->function == dasd_3990_erp_action_4) {
@@ -2620,7 +2620,7 @@
 
 	struct dasd_ccw_req *erp = NULL;
 	struct dasd_device *device = cqr->device;
-	__u32 cpa = cqr->dstat->scsw.cpa;
+	__u32 cpa = cqr->irb.scsw.cpa;
 
 #ifdef ERP_DEBUG
 	/* print current erp_chain */
@@ -2641,8 +2641,8 @@
 #endif				/* ERP_DEBUG */
 
 	/* double-check if current erp/cqr was successfull */
-	if ((cqr->dstat->scsw.cstat == 0x00) &&
-	    (cqr->dstat->scsw.dstat == (DEV_STAT_CHN_END|DEV_STAT_DEV_END))) {
+	if ((cqr->irb.scsw.cstat == 0x00) &&
+	    (cqr->irb.scsw.dstat == (DEV_STAT_CHN_END|DEV_STAT_DEV_END))) {
 
 		DEV_MESSAGE(KERN_DEBUG, device,
 			    "ERP called for successful request %p"
@@ -2653,7 +2653,7 @@
 		return cqr;
 	}
 	/* check if sense data are available */
-	if (!cqr->dstat->ecw) {
+	if (!cqr->irb.ecw) {
 		DEV_MESSAGE(KERN_DEBUG, device,
 			    "ERP called witout sense data avail ..."
 			    "request %p - NO ERP possible", cqr);

