- Description: qeth: setting router type for qeth device in ccwgroup.conf not
               possible
  Symptom:     if the route4 or route6 attribute is defined in ccwgroup.conf
               the startup of the corresponding qeth device fails
  Problem:     when router type is written in sysfs attribute by ccwgroup script
               it is tried to send the SETRTG IPA command which fails, since
               the qeth device is not yet brought up
  Solution:    don't send IPA command if card is not in state SOFTSETUP or UP
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_sys.c	2 Apr 2004 13:59:01 -0000	1.19
+++ linux-2.5/drivers/s390/net/qeth_sys.c	22 Apr 2004 15:12:55 -0000	1.19.2.1
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19 $)
+ * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19.2.1 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to sysfs.
@@ -356,45 +356,32 @@
 
 	if (!strcmp(tmp, "no_router")){
 		route->type = NO_ROUTER;
-		goto check_reset;
-	}
-
-	if (card->info.type == QETH_CARD_TYPE_IQD) {
-		if (!strcmp(tmp, "primary_connector")) {
+	} else if (!strcmp(tmp, "primary_connector")) {
 			route->type = PRIMARY_CONNECTOR;
 		} else if (!strcmp(tmp, "secondary_connector")) {
 			route->type = SECONDARY_CONNECTOR;
 		} else if (!strcmp(tmp, "multicast_router")) {
 			route->type = MULTICAST_ROUTER;
-		} else
-			goto out_inval;
-	} else {
-		if (!strcmp(tmp, "primary_router")) {
+	} else if (!strcmp(tmp, "primary_router")) {
 			route->type = PRIMARY_ROUTER;
 		} else if (!strcmp(tmp, "secondary_router")) {
 			route->type = SECONDARY_ROUTER;
 		} else if (!strcmp(tmp, "multicast_router")) {
-			if (qeth_is_ipafunc_supported(card, prot,
-						      IPA_OSA_MC_ROUTER))
 				route->type = MULTICAST_ROUTER;
-			else
-				goto out_inval;
-		} else
-			goto out_inval;
+	} else {
+		PRINT_WARN("Invalid routing type '%s'.\n", tmp);
+		return -EINVAL;
 	}		
-check_reset:
-	if (old_route_type != route->type){
+	if (((card->state == CARD_STATE_SOFTSETUP) ||
+	     (card->state == CARD_STATE_UP_LAN_OFFLINE) ||
+	     (card->state == CARD_STATE_UP_LAN_ONLINE)) &&
+	    (old_route_type != route->type)){
 		if (prot == QETH_PROT_IPV4)
 			rc = qeth_setrouting_v4(card);
 		else if (prot == QETH_PROT_IPV6)
 			rc = qeth_setrouting_v6(card);
 	}
 	return count;
-out_inval:
-	PRINT_WARN("Routing type '%s' not supported for interface %s.\n"
-		   "Router status not changed.\n",
-		   tmp, card->info.if_name);
-	return -EINVAL;
 }
 
 static ssize_t

--- linux-2.5/drivers/s390/net/qeth_main.c	22 Apr 2004 10:40:18 -0000	1.77.2.3
+++ linux-2.5/drivers/s390/net/qeth_main.c	22 Apr 2004 15:20:46 -0000	1.77.2.4
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.3 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.4 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.3 $	 $Date: 2004/04/22 10:40:18 $
+ *    $Revision: 1.77.2.4 $	 $Date: 2004/04/22 15:20:46 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.3 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.4 $"
 static const char *version = "qeth S/390 OSA-Express driver ("
 	VERSION_QETH_C "/" VERSION_QETH_H "/" VERSION_QETH_MPC_H
 	QETH_VERSION_IPV6 QETH_VERSION_VLAN ")";
@@ -485,7 +485,8 @@
 	write_lock_irqsave(&qeth_card_list.rwlock, flags);
 	list_del(&card->list);
 	write_unlock_irqrestore(&qeth_card_list.rwlock, flags);
-	unregister_netdev(card->dev);
+	if (card->dev)
+		unregister_netdev(card->dev);
 	qeth_remove_device_attributes(&cgdev->dev);
 	qeth_free_card(card);
 	cgdev->dev.driver_data = NULL;
@@ -5559,6 +5560,47 @@
 	
 }
 
+static void
+qeth_correct_routing_type(struct qeth_card *card, enum qeth_routing_types *type,
+			enum qeth_prot_versions prot)
+{
+	if (card->info.type == QETH_CARD_TYPE_IQD) {
+		switch (*type) {
+		case NO_ROUTER:
+		case PRIMARY_CONNECTOR:
+		case SECONDARY_CONNECTOR:
+		case MULTICAST_ROUTER:
+			return;
+		default:
+			goto out_inval;
+		}
+	} else {
+		switch (*type) {
+		case NO_ROUTER:
+		case PRIMARY_ROUTER:
+		case SECONDARY_ROUTER:
+			return;
+		case MULTICAST_ROUTER:
+			if (qeth_is_ipafunc_supported(card, prot,
+						      IPA_OSA_MC_ROUTER))
+				return;
+		default:
+			goto out_inval;
+		}
+	}
+out_inval:
+	PRINT_WARN("Routing type '%s' not supported for interface %s.\n"
+		   "Router status set to 'no router'.\n",
+		   ((*type == PRIMARY_ROUTER)? "primary router" :
+		    (*type == SECONDARY_ROUTER)? "secondary router" :
+		    (*type == PRIMARY_CONNECTOR)? "primary connector" :
+		    (*type == SECONDARY_CONNECTOR)? "secondary connector" :
+		    (*type == MULTICAST_ROUTER)? "multicast router" :
+		    "unknown"),
+		   card->dev->name);
+	*type = NO_ROUTER;
+}
+
 int 
 qeth_setrouting_v4(struct qeth_card *card)
 {
@@ -5566,8 +5608,8 @@
 
 	QETH_DBF_TEXT(trace,3,"setrtg4");
 
-	if (card->options.route4.type == NO_ROUTER)
-		return 0;
+	qeth_correct_routing_type(card, &card->options.route4.type,
+				  QETH_PROT_IPV4);
 
 	rc = qeth_send_setrouting(card, card->options.route4.type,
 				  QETH_PROT_IPV4);
@@ -5588,6 +5630,9 @@
 	QETH_DBF_TEXT(trace,3,"setrtg6");
 #ifdef CONFIG_QETH_IPV6
 	
+	qeth_correct_routing_type(card, &card->options.route6.type,
+				  QETH_PROT_IPV6);
+
 	if ((card->options.route6.type == NO_ROUTER) ||
 	    ((card->info.type == QETH_CARD_TYPE_OSAE) &&
 	     (card->options.route6.type == MULTICAST_ROUTER) &&

