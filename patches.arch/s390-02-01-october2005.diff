From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: IBM Codedrop 2006-01-09 - linux-2.6.15-s390-02-01-october2005.diff

  Description: kernel: magic sysrq-t addressing exception
  Symptom:     After submitting the magic sysrq key "t" the kernel hangs.
  Problem:     The show_task function walks the kernel stack backchain of
               processes assuming that the processes are not running. Since
               this assumption is not correct walking the backchain can lead
               to an addressing exception and therefore to a kernel hang.
  Solution:    Verify that all read accesses are within the bounds of the
               kernel stack before performing them.
  Problem-ID:  20475
  Archs:       s390-31, s390-64

Acked-by: Hannes Reinecke <hare@suse.de>

--- linux-2.5/arch/s390/kernel/process.c	4 Jan 2006 12:20:22 -0000	1.39
+++ linux-2.5/arch/s390/kernel/process.c	5 Jan 2006 18:07:21 -0000	1.39.2.1
@@ -58,10 +58,19 @@
  */
 unsigned long thread_saved_pc(struct task_struct *tsk)
 {
-	struct stack_frame *sf;
+	struct stack_frame *sf, *low, *high;
 
-	sf = (struct stack_frame *) tsk->thread.ksp;
-	sf = (struct stack_frame *) sf->back_chain;
+	if (!tsk || !tsk->thread_info)
+		return 0;
+	low = (struct stack_frame *) tsk->thread_info;
+	high = (struct stack_frame *)
+		((unsigned long) tsk->thread_info + THREAD_SIZE) - 1;
+	sf = (struct stack_frame *) (tsk->thread.ksp & PSW_ADDR_INSN);
+	if (sf <= low || sf > high)
+		return 0;
+	sf = (struct stack_frame *) (sf->back_chain & PSW_ADDR_INSN);
+	if (sf <= low || sf > high)
+		return 0;
 	return sf->gprs[8];
 }
 

