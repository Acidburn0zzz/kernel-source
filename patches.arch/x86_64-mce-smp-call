
Remove bogus WARN_ON

Otherwise machine check panic fails.

 Call Trace:<ffffffff8011cb33>{smp_call_function+115} <ffffffff8011cbf9>{smp_send_stop+25}
 <ffffffff80138012>{panic+274} <ffffffff801187e0>{do_machine_check+0}
 <ffffffff80118c3a>{do_machine_check+1114} <ffffffff80111663>{machine_check+127}
 <ffffffff803434d7>{net_rx_action+215}  <EOE> <IRQ> <ffffffff8013c8e3>{__do_softirq+83} 
   <ffffffff8013c975>{do_softirq+53} <ffffffff80113cdd>{do_IRQ+317}
 <<ffffffff8010f3b0>{default_idle+0} <ffffffff80110b81>{ret_from_intr+0}
     <EOI> <ffffffff8010f3d0>{default_idle+32} <ffffffff8010f86a>{cpu_idle+26}
  <ffffffff8058f886>{start_kernel+502} <ffffffff8058f1e0>{_sinittext+48

Index: linux/arch/x86_64/kernel/smp.c
===================================================================
--- linux.orig/arch/x86_64/kernel/smp.c	2004-08-29 01:07:45.%N +0200
+++ linux/arch/x86_64/kernel/smp.c	2004-08-30 18:40:34.%N +0200
@@ -298,6 +298,7 @@
  *
  * You must not call this function with disabled interrupts or from a
  * hardware interrupt handler or from a bottom half handler.
+ * Actually there are a few legal cases, like panic. 
  */
 {
 	struct call_data_struct data;
@@ -306,9 +307,6 @@
 	if (!cpus)
 		return 0;
 
-	/* Can deadlock when called with interrupts disabled */
-	WARN_ON(irqs_disabled());
-
 	data.func = func;
 	data.info = info;
 	atomic_set(&data.started, 0);
