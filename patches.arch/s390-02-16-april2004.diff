- Description: qeth: session hangs when removing a vlan device
  Symptom:     When doing a vconfig rem to remove a vlan device the session
               can hang waiting for references on the vlan device to be released.
  Problem:     We keep references for all skbs that are related to outbound qdio
               buffers. These references are free as soon as we get a PCI for
               these buffers. Because of our PCI avoidance algorithm we do not get
               PCIs for each single buffer. As a result, skb references are not
               freed immediately.
  Solution:    On removal of vlan device release all skbs that are enqueued in our
               qdio buffers.
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 08:30:14 -0000	1.77.2.9
+++ linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 08:42:46 -0000	1.77.2.10
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.9 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.10 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.9 $	 $Date: 2004/05/14 08:30:14 $
+ *    $Revision: 1.77.2.10 $	 $Date: 2004/05/14 08:42:46 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.9 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.10 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -153,6 +153,10 @@
 
 static int 
 qeth_set_online(struct ccwgroup_device *);
+
+static struct qeth_ipaddr *
+qeth_get_addr_buffer(enum qeth_prot_versions);
+
 /**
  * free channel command buffers
  */ 
@@ -4334,27 +4338,124 @@
 qeth_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
 {
 	struct qeth_card *card;
+	unsigned long flags;
 	
 	QETH_DBF_TEXT(trace,4,"vlanreg");
 	
 	card = (struct qeth_card *) dev->priv;
-	spin_lock_irq(&card->vlanlock);
+	spin_lock_irqsave(&card->vlanlock, flags);
 	card->vlangrp = grp;
-	spin_unlock_irq(&card->vlanlock);
+	spin_unlock_irqrestore(&card->vlanlock, flags);
+}
+
+static inline void
+qeth_free_vlan_buffer(struct qeth_card *card, struct qeth_qdio_out_buffer *buf,
+		      unsigned short vid)
+{
+	int i;
+	struct sk_buff *skb;
+	struct sk_buff_head tmp_list;
+
+	skb_queue_head_init(&tmp_list);
+	for(i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i){
+		while ((skb = skb_dequeue(&buf->skb_list))){
+			if (vlan_tx_tag_present(skb) &&
+			    (vlan_tx_tag_get(skb) == vid)) {
+				atomic_dec(&skb->users);
+				dev_kfree_skb(skb);
+			} else
+				skb_queue_tail(&tmp_list, skb);
+		}
+	}
+	while ((skb = skb_dequeue(&tmp_list)))
+		skb_queue_tail(&buf->skb_list, skb);
+}
+
+static void
+qeth_free_vlan_skbs(struct qeth_card *card, unsigned short vid)
+{
+	int i, j;
+
+	QETH_DBF_TEXT(trace, 4, "frvlskbs");
+	for (i = 0; i < card->qdio.no_out_queues; ++i){
+		for (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j)
+			qeth_free_vlan_buffer(card, &card->qdio.
+					      out_qs[i]->bufs[j], vid);
+	}
+}
+
+static void
+qeth_free_vlan_addresses4(struct qeth_card *card, unsigned short vid)
+{
+	struct in_device *in_dev;
+	struct in_ifaddr *ifa;
+	struct qeth_ipaddr *addr;
+
+	QETH_DBF_TEXT(trace, 4, "frvaddr4");
+	if (!card->vlangrp)
+		return;
+	in_dev = in_dev_get(card->vlangrp->vlan_devices[vid]);
+	if (!in_dev)
+		return;
+	for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next){
+		addr = qeth_get_addr_buffer(QETH_PROT_IPV4);
+		if (addr){
+			addr->u.a4.addr = ifa->ifa_address;
+			addr->u.a4.mask = ifa->ifa_mask;
+			addr->type = QETH_IP_TYPE_NORMAL;
+			if (!qeth_delete_ip(card, addr))
+				kfree(addr);
+		}
+	}
+	in_dev_put(in_dev);
+}
+
+static void
+qeth_free_vlan_addresses6(struct qeth_card *card, unsigned short vid)
+{
+	struct inet6_dev *in6_dev;
+	struct inet6_ifaddr *ifa;
+	struct qeth_ipaddr *addr;
+
+	QETH_DBF_TEXT(trace, 4, "frvaddr6");
+	if (!card->vlangrp)
+		return;
+	in6_dev = in6_dev_get(card->vlangrp->vlan_devices[vid]);
+	if (!in6_dev)
+		return;
+	for (ifa = in6_dev->addr_list; ifa; ifa = ifa->lst_next){
+		addr = qeth_get_addr_buffer(QETH_PROT_IPV6);
+		if (addr){
+			memcpy(&addr->u.a6.addr, &ifa->addr,
+			       sizeof(struct in6_addr));
+			addr->u.a6.pfxlen = ifa->prefix_len;
+			addr->type = QETH_IP_TYPE_NORMAL;
+			if (!qeth_delete_ip(card, addr))
+				kfree(addr);
+		}
+	}
+	in6_dev_put(in6_dev);
 }
 
 static void
 qeth_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
 {
 	struct qeth_card *card;
+	unsigned long flags;
 	
 	QETH_DBF_TEXT(trace,4,"vlkilvid");
 	
 	card = (struct qeth_card *) dev->priv;
-	spin_lock_irq(&card->vlanlock);
+	/* free all skbs for the vlan device */
+	qeth_free_vlan_skbs(card, vid);
+	spin_lock_irqsave(&card->vlanlock, flags);
+	/* unregister IP addresses of vlan device */
+	qeth_free_vlan_addresses4(card, vid);
+	qeth_free_vlan_addresses6(card, vid);
 	if (card->vlangrp)
 		card->vlangrp->vlan_devices[vid] = NULL;
-	spin_unlock_irq(&card->vlanlock);
+	spin_unlock_irqrestore(&card->vlanlock, flags);
+	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
 	/* delete mc addresses for this vlan dev */
 	qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD);
 	schedule_work(&card->kernel_thread_starter);
@@ -4410,10 +4511,6 @@
 	memset(addr,0,sizeof(struct qeth_ipaddr));
 	addr->type = QETH_IP_TYPE_NORMAL;
 	addr->proto = prot;
-	addr->is_multicast = 0;
-	addr->users = 0;
-	addr->set_flags = 0;
-	addr->del_flags = 0;
 	return addr;
 }
 

