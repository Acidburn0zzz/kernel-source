ChangeSet
  1.1587.1.2 04/04/28 15:32:01 dgibson@sneetch.ozlabs.ibm.com +2 -0
  POWER5 < DD2.1 has a problem where slbie's need to be repeated under some
  circumstances.  Apply workaround.

  arch/ppc64/kernel/stab.c
    1.34 04/04/28 15:31:54 dgibson@sneetch.ozlabs.ibm.com +16 -5
    POWER5 < DD2.1 has a problem where slbie's need to be repeated under some
    circumstances.  Apply workaround.

  arch/ppc64/kernel/entry.S
    1.43 04/04/28 15:31:54 dgibson@sneetch.ozlabs.ibm.com +1 -0
    POWER5 < DD2.1 has a problem where slbie's need to be repeated under some
    circumstances.  Apply workaround.

.........................................................................
diff -Nru a/arch/ppc64/kernel/entry.S b/arch/ppc64/kernel/entry.S
--- a/arch/ppc64/kernel/entry.S	Wed Apr 28 11:33:18 2004
+++ b/arch/ppc64/kernel/entry.S	Wed Apr 28 11:33:18 2004
@@ -311,6 +311,7 @@
 	beq	2f		/* if yes, don't slbie it */
 	oris	r6,r6,0x0800	/* set C (class) bit */
 	slbie	r6
+	slbie	r6		/* Workaround POWER5 < DD2.1 issue */
 2:
 END_FTR_SECTION_IFSET(CPU_FTR_SLB)
 	clrrdi	r7,r8,THREAD_SHIFT	/* base of new stack */
diff -Nru a/arch/ppc64/kernel/stab.c b/arch/ppc64/kernel/stab.c
--- a/arch/ppc64/kernel/stab.c	Wed Apr 28 11:33:18 2004
+++ b/arch/ppc64/kernel/stab.c	Wed Apr 28 11:33:18 2004
@@ -474,14 +474,14 @@
 void flush_slb(struct task_struct *tsk, struct mm_struct *mm)
 {
 	unsigned long offset = __get_cpu_var(stab_cache_ptr);
+	union {
+		unsigned long word0;
+		slb_dword0 data;
+	} esid_data;
+
 
 	if (offset <= NR_STAB_CACHE_ENTRIES) {
 		int i;
-		union {
-			unsigned long word0;
-			slb_dword0 data;
-		} esid_data;
-
 		asm volatile("isync" : : : "memory");
 		for (i = 0; i < offset; i++) {
 			esid_data.word0 = 0;
@@ -491,6 +491,17 @@
 		asm volatile("isync" : : : "memory");
 	} else {
 		asm volatile("isync; slbia; isync" : : : "memory");
+	}
+
+	/* Workaround POWER5 < DD2.1 issue */
+	if (offset == 1 || offset > NR_STAB_CACHE_ENTRIES) {
+		/* 
+		 * flush segment in EEH region, we dont normally access
+		 * addresses in this region.
+		 */
+		esid_data.word0 = 0;
+		esid_data.data.esid = EEH_REGION_ID;
+		asm volatile("slbie %0" : : "r" (esid_data));
 	}
 
 	__get_cpu_var(stab_cache_ptr) = 0;
.........................................................................
# vim: syntax=diff

