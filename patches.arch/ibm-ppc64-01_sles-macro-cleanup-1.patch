==============================
01_sles-macro-cleanup-1.patch:
==============================
Corresponds to BK revision 1.1713.31.15
[PATCH] ppc64: Fix bug in hugepage support

From: David Gibson <david@gibson.dropbear.id.au>

The PPC64 version of is_aligned_hugepage_range() is buggy.  It is supposed to
test not only that the given range is hugepage aligned, but that it lies
within the address space allowed for hugepages.  We were checking only that
the given range intersected the hugepage range, not that it lay entirely
within it.  This patch fixes the problem and changes the name of some macros
to make it less likely to make that misunderstanding again.


diff -purN SLES9-cvs-current/arch/ppc64/mm/hugetlbpage.c SLES9-cvs-current-work/arch/ppc64/mm/hugetlbpage.c
--- SLES9-cvs-current/arch/ppc64/mm/hugetlbpage.c	Thu Apr 15 10:22:53 2004
+++ SLES9-cvs-current-work/arch/ppc64/mm/hugetlbpage.c	Thu Apr 15 11:05:51 2004
@@ -229,7 +229,8 @@ int is_aligned_hugepage_range(unsigned l
 		return -EINVAL;
 	if (addr & ~HPAGE_MASK)
 		return -EINVAL;
-	if (! is_hugepage_only_range(addr, len))
+	if (! (within_hugepage_low_range(addr, len)
+	       || within_hugepage_high_range(addr, len)) )
 		return -EINVAL;
 	return 0;
 }
@@ -299,9 +300,9 @@ static int open_32bit_htlbpage_range(str
 
 int prepare_hugepage_range(unsigned long addr, unsigned long len)
 {
-	if (is_hugepage_high_range(addr, len))
+	if (within_hugepage_high_range(addr, len))
 		return 0;
-	else if (is_hugepage_low_range(addr, len))
+	else if (within_hugepage_low_range(addr, len))
 		return open_32bit_htlbpage_range(current->mm);
 
 	return -EINVAL;
diff -purN SLES9-cvs-current/include/asm-ppc64/page.h SLES9-cvs-current-work/include/asm-ppc64/page.h
--- SLES9-cvs-current/include/asm-ppc64/page.h	Sat Apr  3 19:36:14 2004
+++ SLES9-cvs-current-work/include/asm-ppc64/page.h	Thu Apr 15 11:05:51 2004
@@ -40,15 +40,19 @@
 #define ARCH_HAS_HUGEPAGE_ONLY_RANGE
 #define ARCH_HAS_PREPARE_HUGEPAGE_RANGE
 
-#define is_hugepage_low_range(addr, len) \
+#define touches_hugepage_low_range(addr, len) \
 	(((addr) > (TASK_HPAGE_BASE_32-(len))) && ((addr) < TASK_HPAGE_END_32))
-#define is_hugepage_high_range(addr, len) \
+#define touches_hugepage_high_range(addr, len) \
 	(((addr) > (TASK_HPAGE_BASE-(len))) && ((addr) < TASK_HPAGE_END))
+#define within_hugepage_low_range(addr, len) (((addr) >= TASK_HPAGE_BASE_32) \
+	  && ((addr)+(len) <= TASK_HPAGE_END_32) && ((addr)+(len) >= (addr)))
+#define within_hugepage_high_range(addr, len) (((addr) >= TASK_HPAGE_BASE) \
+	  && ((addr)+(len) <= TASK_HPAGE_END) && ((addr)+(len) >= (addr)))
 
 #define is_hugepage_only_range(addr, len) \
-	(is_hugepage_high_range((addr), (len)) || \
+	(touches_hugepage_high_range((addr), (len)) || \
 	 (current->mm->context.low_hpages \
-	  && is_hugepage_low_range((addr), (len))))
+	  && touches_hugepage_low_range((addr), (len))))
 #define hugetlb_free_pgtables free_pgtables
 #define HAVE_ARCH_HUGETLB_UNMAPPED_AREA
 
