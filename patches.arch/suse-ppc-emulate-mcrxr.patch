diff -purNX /tmp/kernel_exclude.txt linux-2.6.5.orig/arch/ppc/kernel/traps.c linux-2.6.5/arch/ppc/kernel/traps.c
--- linux-2.6.5.orig/arch/ppc/kernel/traps.c	2004-05-21 16:28:38.000000000 +0000
+++ linux-2.6.5/arch/ppc/kernel/traps.c	2004-05-23 22:13:28.000000000 +0000
@@ -44,6 +44,7 @@
 
 extern int fix_alignment(struct pt_regs *);
 extern void bad_page_fault(struct pt_regs *, unsigned long, int sig);
+extern int emulate_altivec(struct pt_regs *regs);
 
 #ifdef CONFIG_XMON
 void (*debugger)(struct pt_regs *regs) = xmon;
@@ -303,7 +304,7 @@ RunModeException(struct pt_regs *regs)
 
 /* Illegal instruction emulation support.  Originally written to
  * provide the PVR to user applications using the mfspr rd, PVR.
- * Return non-zero if we can't emulate, or EFAULT if the associated
+ * Return non-zero if we can't emulate, or -EFAULT if the associated
  * memory access caused an access fault.  Return zero on success.
  *
  * There are a couple of ways to do this, either "decode" the instruction
@@ -314,6 +315,12 @@ RunModeException(struct pt_regs *regs)
 #define INST_MFSPR_PVR		0x7c1f42a6
 #define INST_MFSPR_PVR_MASK	0xfc1fffff
 
+#define INST_DCBA             0x7c0005ec
+#define INST_DCBA_MASK                0x7c0007fe
+
+#define INST_MCRXR            0x7c000400
+#define INST_MCRXR_MASK               0x7c0007fe
+
 static int
 emulate_instruction(struct pt_regs *regs)
 {
@@ -338,6 +345,24 @@ emulate_instruction(struct pt_regs *regs
 		retval = 0;
 		regs->nip += 4;
 	}
+ 
+       /* Emulating the dcba insn is just a no-op.  */
+       if ((instword & INST_DCBA_MASK) == INST_DCBA) {
+		regs->nip += 4;
+		retval = 0;
+       }
+ 
+	/* Emulate the mcrxr insn.  */
+	if ((instword & INST_MCRXR_MASK) == INST_MCRXR) {
+		field_shift = (instword >> 21) & 0x1c;
+		regs->ccr &= ~(0xf0000000 >> field_shift);
+		regs->ccr |= (regs->xer & 0xf0000000) >> field_shift;
+		regs->xer &= ~0xf0000000UL;
+ 
+		regs->nip += 4;
+		retval = 0;
+	}
+ 
 	return retval;
 }
 
@@ -477,6 +502,13 @@ ProgramCheckException(struct pt_regs *re
 		return;
 	}
 
+	if ((reason & REASON_ILLEGAL) && !(reason & REASON_PRIVILEGED)) {
+		if (emulate_instruction(regs) == 0)
+			return;
+		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
+		return;
+	}
+
 	if (reason & REASON_PRIVILEGED) {
 		/* Try to emulate it if we should. */
 		if (emulate_instruction(regs) == 0) {
diff -purNX /tmp/kernel_exclude.txt linux-2.6.5.orig/arch/ppc64/kernel/traps.c linux-2.6.5/arch/ppc64/kernel/traps.c
--- linux-2.6.5.orig/arch/ppc64/kernel/traps.c	2004-05-21 16:28:37.000000000 +0000
+++ linux-2.6.5/arch/ppc64/kernel/traps.c	2004-05-21 17:15:11.000000000 +0000
@@ -369,6 +369,64 @@ static void parse_fpe(struct pt_regs *re
 	_exception(SIGFPE, &info, regs);
 }
 
+/* Illegal instruction emulation support.  Return non-zero if we can't
+ * emulate, or -EFAULT if the associated memory access caused an access
+ * fault.  Return zero on success.
+ */
+
+#define INST_DCBA             0x7c0005ec
+#define INST_DCBA_MASK                0x7c0007fe
+
+#define INST_MCRXR            0x7c000400
+#define INST_MCRXR_MASK               0x7c0007fe
+
+static int
+emulate_instruction(struct pt_regs *regs)
+{
+      uint    instword;
+
+      if (!user_mode(regs))
+              return -EINVAL;
+
+      CHECK_FULL_REGS(regs);
+
+      if (get_user(instword, (uint __user *)(regs->nip)))
+              return -EFAULT;
+
+      /* Emulating the dcba insn is just a no-op.  */
+      if ((instword & INST_DCBA_MASK) == INST_DCBA) {
+              static long last_dcba_pid;
+
+              if (last_dcba_pid != current->pid)
+                      printk(KERN_WARNING
+                              "process %d using obsolete 'dcba' insn\n",
+                              current->pid);
+              last_dcba_pid = current->pid;
+              retval = 0;
+      }
+
+      /* Emulate the mcrxr insn.  */
+      if ((instword & INST_MCRXR_MASK) == INST_MCRXR) {
+              static long last_mcrxr_pid;
+              uint field_shift;
+
+              if (last_mcrxr_pid != current->pid)
+                      printk(KERN_WARNING
+                              "process %d using obsolete 'mcrxr' insn\n",
+                              current->pid);
+              last_mcrxr_pid = current->pid;
+
+              field_shift = (inst_word >> 21) & 0x1c;
+              regs->ccr &= ~(0xf0000000 >> field_shift);
+              regs->ccr |= (regs->xer & 0xf0000000) >> field_shift;
+              regs->xer &= ~0xf0000000UL;
+
+              retval = 0;
+      }
+
+      return retval;
+}
+
 /*
  * Look through the list of trap instructions that are used for BUG(),
  * BUG_ON() and WARN_ON() and see if we hit one.  At this point we know
@@ -453,13 +511,29 @@ ProgramCheckException(struct pt_regs *re
 		info.si_addr = (void *)regs->nip;
 		_exception(SIGTRAP, &info, regs);
 	} else {
-		/* Illegal instruction */
+              /* Illegal instruction; try to emulate it.  */
 
-		info.si_signo = SIGILL;
-		info.si_errno = 0;
-		info.si_code = ILL_ILLTRP;
-		info.si_addr = (void *)regs->nip;
-		_exception(SIGILL, &info, regs);
+              switch (emulate_instruction(regs)) {
+                      case 0:
+                              regs->nip += 4;
+                              break;
+
+                      case -EFAULT:
+                              info.si_signo = SIGBUS;
+                              info.si_errno = 0;
+                              info.si_code = BUS_ADRERR;
+                              info.si_addr = (void *)regs->nip;
+                              _exception(SIGBUS, &info, regs);
+                              break;
+
+                      default:
+                              info.si_signo = SIGILL;
+                              info.si_errno = 0;
+                              info.si_code = ILL_ILLTRP;
+                              info.si_addr = (void *)regs->nip;
+                              _exception(SIGILL, &info, regs);
+                              break;
+              }
 	}
 }
 
