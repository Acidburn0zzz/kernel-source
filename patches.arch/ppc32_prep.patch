--- a/arch/ppc/boot/Makefile	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/Makefile	Tue Mar  2 11:56:57 2004
@@ -16,13 +16,12 @@
 BOOT_TARGETS	= zImage zImage.initrd znetboot znetboot.initrd
 
 bootdir-y			:= simple
-bootdir-$(CONFIG_PPC_OF)	:= openfirmware
-bootdir-$(CONFIG_PPC_PREP)	+= prep
+bootdir-$(CONFIG_PPC_OF)	+= openfirmware
 subdir-y			:= lib/ common/ images/
 subdir-$(CONFIG_PPC_OF)		+= of1275/
 
 # for cleaning
-subdir-				+= simple/ openfirmware/ prep/
+subdir-				+= simple/ openfirmware/
 
 host-progs := $(addprefix utils/, addnote mknote hack-coff mkprep mkbugboot mktree)
 
--- a/arch/ppc/boot/common/Makefile	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/common/Makefile	Tue Mar  2 11:56:57 2004
@@ -9,8 +9,5 @@
 #
 
 lib-y					:= string.o util.o misc-common.o \
-						serial_stub.o
-lib-$(CONFIG_PPC_PREP)			+= mpc10x_memory.o
-lib-$(CONFIG_LOPEC)			+= mpc10x_memory.o
-lib-$(CONFIG_PAL4)			+= cpc700_memory.o
+						serial_stub.o bootinfo.o
 lib-$(CONFIG_SERIAL_8250_CONSOLE)	+= ns16550.o
--- a/arch/ppc/boot/common/util.S	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/common/util.S	Tue Mar  2 11:56:57 2004
@@ -14,7 +14,7 @@
  *	   trini@mvista.com
  * Derived from arch/ppc/boot/prep/head.S (Cort Dougan, many others).
  *
- * 2001-2003 (c) MontaVista, Software, Inc.  This file is licensed under
+ * 2001-2004 (c) MontaVista, Software, Inc.  This file is licensed under
  * the terms of the GNU General Public License version 2.  This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
@@ -36,6 +36,13 @@
 	 */
 	li	r8,MSR_IP|MSR_FP
 	mtmsr	r8
+	isync
+
+	/* Test for a 601 */
+	mfpvr	r10
+	srwi	r10,r10,16
+	cmpi	0,r10,1		/* 601 ? */
+	beq	.clearbats_601
 
 	/* Clear BATs */
 	li	r8,0
@@ -47,6 +54,7 @@
 	mtspr	DBAT2L,r8
 	mtspr	DBAT3U,r8
 	mtspr	DBAT3L,r8
+.clearbats_601:
 	mtspr	IBAT0U,r8
 	mtspr	IBAT0L,r8
 	mtspr	IBAT1U,r8
@@ -68,6 +76,7 @@
 	addi	r8,r8,0x111	/* increment VSID */
 	addis	r10,r10,0x1000	/* address of next segment */
 	bdnz	3b
+	blr
 
 	.globl	disable_6xx_l1cache
 disable_6xx_l1cache:
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/arch/ppc/boot/include/iso_font.h	Tue Mar  2 11:56:57 2004
@@ -0,0 +1,257 @@
+static const unsigned char font[] = {
+/* 0x00 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x01 */ 0x00,0x00,0x7E,0x81,0xA5,0x81,0x81,0xBD,0x99,0x81,0x81,0x7E,0x00,0x00,0x00,0x00,
+/* 0x02 */ 0x00,0x00,0x7E,0xFF,0xDB,0xFF,0xFF,0xC3,0xC3,0xE7,0xFF,0x7E,0x00,0x00,0x00,0x00,
+/* 0x03 */ 0x00,0x00,0x00,0x00,0x6C,0xFE,0xFE,0xFE,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00,
+/* 0x04 */ 0x00,0x00,0x00,0x00,0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00,0x00,
+/* 0x05 */ 0x00,0x00,0x00,0x18,0x3C,0x3C,0xE7,0xE7,0xE7,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x06 */ 0x00,0x00,0x00,0x18,0x3C,0x7E,0xFF,0xFF,0x7E,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x07 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x08 */ 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC3,0xC3,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+/* 0x09 */ 0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x42,0x42,0x66,0x3C,0x00,0x00,0x00,0x00,0x00,
+/* 0x0A */ 0xFF,0xFF,0xFF,0xFF,0xFF,0xC3,0x99,0xBD,0xBD,0x99,0xC3,0xFF,0xFF,0xFF,0xFF,0xFF,
+/* 0x0B */ 0x00,0x00,0x3E,0x0E,0x1A,0x32,0x78,0xCC,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00,
+/* 0x0C */ 0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x3C,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x0D */ 0x00,0x00,0x30,0x38,0x3C,0x36,0x33,0x30,0x30,0x70,0xF0,0xE0,0x00,0x00,0x00,0x00,
+/* 0x0E */ 0x00,0x00,0x7F,0x63,0x7F,0x63,0x63,0x63,0x63,0x67,0xE7,0xE6,0xC0,0x00,0x00,0x00,
+/* 0x0F */ 0x00,0x00,0x00,0x18,0x18,0xDB,0x3C,0xE7,0x3C,0xDB,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x10 */ 0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFE,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,
+/* 0x11 */ 0x00,0x02,0x06,0x0E,0x1E,0x3E,0xFE,0x3E,0x1E,0x0E,0x06,0x02,0x00,0x00,0x00,0x00,
+/* 0x12 */ 0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,
+/* 0x13 */ 0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x00,0x00,
+/* 0x14 */ 0x00,0x00,0x7F,0xDB,0xDB,0xDB,0x7B,0x1B,0x1B,0x1B,0x1B,0x1B,0x00,0x00,0x00,0x00,
+/* 0x15 */ 0x00,0x7C,0xC6,0x60,0x38,0x6C,0xC6,0xC6,0x6C,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,
+/* 0x16 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFE,0xFE,0xFE,0x00,0x00,0x00,0x00,
+/* 0x17 */ 0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x7E,0x3C,0x18,0x7E,0x00,0x00,0x00,0x00,
+/* 0x18 */ 0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x19 */ 0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00,
+/* 0x1A */ 0x00,0x00,0x00,0x00,0x00,0x18,0x0C,0xFE,0x0C,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x1B */ 0x00,0x00,0x00,0x00,0x00,0x30,0x60,0xFE,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x1C */ 0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x1D */ 0x00,0x00,0x00,0x00,0x00,0x28,0x6C,0xFE,0x6C,0x28,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x1E */ 0x00,0x00,0x00,0x00,0x10,0x38,0x38,0x7C,0x7C,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00,
+/* 0x1F */ 0x00,0x00,0x00,0x00,0xFE,0xFE,0x7C,0x7C,0x38,0x38,0x10,0x00,0x00,0x00,0x00,0x00,
+/* 0x20 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x21 */ 0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x22 */ 0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x23 */ 0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00,
+/* 0x24 */ 0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06,0x06,0x86,0xC6,0x7C,0x18,0x18,0x00,0x00,
+/* 0x25 */ 0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00,
+/* 0x26 */ 0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x27 */ 0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x28 */ 0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,
+/* 0x29 */ 0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00,
+/* 0x2A */ 0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x2B */ 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x2C */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00,
+/* 0x2D */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x2E */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x2F */ 0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,
+/* 0x30 */ 0x00,0x00,0x38,0x6C,0xC6,0xC6,0xD6,0xD6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00,
+/* 0x31 */ 0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,
+/* 0x32 */ 0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00,
+/* 0x33 */ 0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x34 */ 0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,
+/* 0x35 */ 0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x36 */ 0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x37 */ 0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,
+/* 0x38 */ 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x39 */ 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00,
+/* 0x3A */ 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
+/* 0x3B */ 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00,
+/* 0x3C */ 0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,
+/* 0x3D */ 0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x3E */ 0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,
+/* 0x3F */ 0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x40 */ 0x00,0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00,0x00,
+/* 0x41 */ 0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0x42 */ 0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00,
+/* 0x43 */ 0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00,
+/* 0x44 */ 0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00,
+/* 0x45 */ 0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00,
+/* 0x46 */ 0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
+/* 0x47 */ 0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00,
+/* 0x48 */ 0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0x49 */ 0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x4A */ 0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00,
+/* 0x4B */ 0x00,0x00,0xE6,0x66,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
+/* 0x4C */ 0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00,
+/* 0x4D */ 0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0x4E */ 0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0x4F */ 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x50 */ 0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
+/* 0x51 */ 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00,
+/* 0x52 */ 0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
+/* 0x53 */ 0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x54 */ 0x00,0x00,0x7E,0x7E,0x5A,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x55 */ 0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x56 */ 0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00,
+/* 0x57 */ 0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00,
+/* 0x58 */ 0x00,0x00,0xC6,0xC6,0x6C,0x7C,0x38,0x38,0x7C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0x59 */ 0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x5A */ 0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00,
+/* 0x5B */ 0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,
+/* 0x5C */ 0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x06,0x02,0x00,0x00,0x00,0x00,
+/* 0x5D */ 0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,
+/* 0x5E */ 0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x5F */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,
+/* 0x60 */ 0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x61 */ 0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x62 */ 0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,
+/* 0x63 */ 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x64 */ 0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x65 */ 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x66 */ 0x00,0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
+/* 0x67 */ 0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,
+/* 0x68 */ 0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
+/* 0x69 */ 0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x6A */ 0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,
+/* 0x6B */ 0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00,
+/* 0x6C */ 0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x6D */ 0x00,0x00,0x00,0x00,0x00,0x6C,0xFE,0xD6,0xD6,0xD6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0x6E */ 0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
+/* 0x6F */ 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x70 */ 0x00,0x00,0x00,0x00,0x00,0xFC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00,
+/* 0x71 */ 0x00,0x00,0x00,0x00,0x00,0x7E,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00,
+/* 0x72 */ 0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
+/* 0x73 */ 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x74 */ 0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00,
+/* 0x75 */ 0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x76 */ 0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,
+/* 0x77 */ 0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00,
+/* 0x78 */ 0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,
+/* 0x79 */ 0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00,
+/* 0x7A */ 0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00,
+/* 0x7B */ 0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,
+/* 0x7C */ 0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x7D */ 0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,
+/* 0x7E */ 0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0x7F */ 0x00,0x00,0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xC6,0xFE,0x00,0x00,0x00,0x00,0x00,
+/* 0x80 */ 0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x0C,0x06,0x7C,0x00,0x00,
+/* 0x81 */ 0x00,0x00,0xCC,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x82 */ 0x00,0x0C,0x18,0x30,0x00,0x7C,0xC6,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x83 */ 0x00,0x10,0x38,0x6C,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x84 */ 0x00,0x00,0xCC,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x85 */ 0x00,0x60,0x30,0x18,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x86 */ 0x00,0x38,0x6C,0x38,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x87 */ 0x00,0x00,0x00,0x00,0x3C,0x66,0x60,0x60,0x66,0x3C,0x0C,0x06,0x3C,0x00,0x00,0x00,
+/* 0x88 */ 0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x89 */ 0x00,0x00,0xC6,0x00,0x00,0x7C,0xC6,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x8A */ 0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x8B */ 0x00,0x00,0x66,0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x8C */ 0x00,0x18,0x3C,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x8D */ 0x00,0x60,0x30,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0x8E */ 0x00,0xC6,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0x8F */ 0x38,0x6C,0x38,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0x90 */ 0x18,0x30,0x60,0x00,0xFE,0x66,0x60,0x7C,0x60,0x60,0x66,0xFE,0x00,0x00,0x00,0x00,
+/* 0x91 */ 0x00,0x00,0x00,0x00,0x00,0xCC,0x76,0x36,0x7E,0xD8,0xD8,0x6E,0x00,0x00,0x00,0x00,
+/* 0x92 */ 0x00,0x00,0x3E,0x6C,0xCC,0xCC,0xFE,0xCC,0xCC,0xCC,0xCC,0xCE,0x00,0x00,0x00,0x00,
+/* 0x93 */ 0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x94 */ 0x00,0x00,0xC6,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x95 */ 0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x96 */ 0x00,0x30,0x78,0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x97 */ 0x00,0x60,0x30,0x18,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0x98 */ 0x00,0x00,0xC6,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00,
+/* 0x99 */ 0x00,0xC6,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x9A */ 0x00,0xC6,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0x9B */ 0x00,0x18,0x18,0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x9C */ 0x00,0x38,0x6C,0x64,0x60,0xF8,0x60,0x60,0x60,0x60,0xE6,0xFC,0x00,0x00,0x00,0x00,
+/* 0x9D */ 0x00,0x00,0x66,0x66,0x3C,0x18,0x7E,0x18,0x7E,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0x9E */ 0x00,0xF8,0xCC,0xCC,0xF8,0xC4,0xCC,0xDE,0xCC,0xCC,0xCC,0xC6,0x00,0x00,0x00,0x00,
+/* 0x9F */ 0x00,0x0E,0x1B,0x18,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x18,0xD8,0x70,0x00,0x00,
+/* 0xA0 */ 0x00,0x18,0x30,0x60,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0xA1 */ 0x00,0x0C,0x18,0x30,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
+/* 0xA2 */ 0x00,0x18,0x30,0x60,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0xA3 */ 0x00,0x18,0x30,0x60,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
+/* 0xA4 */ 0x00,0x00,0x76,0xDC,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
+/* 0xA5 */ 0x76,0xDC,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0xA6 */ 0x00,0x3C,0x6C,0x6C,0x3E,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xA7 */ 0x00,0x38,0x6C,0x6C,0x38,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xA8 */ 0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x60,0xC0,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
+/* 0xA9 */ 0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,
+/* 0xAA */ 0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,0x00,
+/* 0xAB */ 0x00,0xC0,0xC0,0xC2,0xC6,0xCC,0x18,0x30,0x60,0xDC,0x86,0x0C,0x18,0x3E,0x00,0x00,
+/* 0xAC */ 0x00,0xC0,0xC0,0xC2,0xC6,0xCC,0x18,0x30,0x66,0xCE,0x9E,0x3E,0x06,0x06,0x00,0x00,
+/* 0xAD */ 0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x18,0x3C,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00,
+/* 0xAE */ 0x00,0x00,0x00,0x00,0x00,0x36,0x6C,0xD8,0x6C,0x36,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xAF */ 0x00,0x00,0x00,0x00,0x00,0xD8,0x6C,0x36,0x6C,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xB0 */ 0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,
+/* 0xB1 */ 0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,
+/* 0xB2 */ 0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,
+/* 0xB3 */ 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xB4 */ 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xB5 */ 0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xB6 */ 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xB7 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xB8 */ 0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xB9 */ 0x36,0x36,0x36,0x36,0x36,0xF6,0x06,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xBA */ 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xBB */ 0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xBC */ 0x36,0x36,0x36,0x36,0x36,0xF6,0x06,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xBD */ 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xBE */ 0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xBF */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xC0 */ 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xC1 */ 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xC2 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xC3 */ 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xC4 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xC5 */ 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xC6 */ 0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xC7 */ 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xC8 */ 0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xC9 */ 0x00,0x00,0x00,0x00,0x00,0x3F,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xCA */ 0x36,0x36,0x36,0x36,0x36,0xF7,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xCB */ 0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xF7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xCC */ 0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xCD */ 0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xCE */ 0x36,0x36,0x36,0x36,0x36,0xF7,0x00,0xF7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xCF */ 0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xD0 */ 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xD1 */ 0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xD2 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xD3 */ 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xD4 */ 0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xD5 */ 0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xD6 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xD7 */ 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFF,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+/* 0xD8 */ 0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xD9 */ 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xDA */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xDB */ 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+/* 0xDC */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+/* 0xDD */ 0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,
+/* 0xDE */ 0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
+/* 0xDF */ 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xE0 */ 0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0xD8,0xD8,0xD8,0xDC,0x76,0x00,0x00,0x00,0x00,
+/* 0xE1 */ 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xFC,0xC6,0xC6,0xC6,0xC6,0xDC,0xC0,0xC0,0x00,0x00,
+/* 0xE2 */ 0x00,0x00,0xFE,0xC6,0xC6,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,
+/* 0xE3 */ 0x00,0x00,0x00,0x00,0x00,0xFE,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,
+/* 0xE4 */ 0x00,0x00,0xFE,0xC6,0x60,0x30,0x18,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00,
+/* 0xE5 */ 0x00,0x00,0x00,0x00,0x00,0x7E,0xD8,0xD8,0xD8,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00,
+/* 0xE6 */ 0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0xC0,0x00,0x00,0x00,
+/* 0xE7 */ 0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
+/* 0xE8 */ 0x00,0x00,0x7E,0x18,0x3C,0x66,0x66,0x66,0x66,0x3C,0x18,0x7E,0x00,0x00,0x00,0x00,
+/* 0xE9 */ 0x00,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00,
+/* 0xEA */ 0x00,0x00,0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x6C,0x6C,0x6C,0xEE,0x00,0x00,0x00,0x00,
+/* 0xEB */ 0x00,0x00,0x1E,0x30,0x18,0x0C,0x3E,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,
+/* 0xEC */ 0x00,0x00,0x00,0x00,0x00,0x7E,0xDB,0xDB,0xDB,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xED */ 0x00,0x00,0x00,0x03,0x06,0x7E,0xDB,0xDB,0xF3,0x7E,0x60,0xC0,0x00,0x00,0x00,0x00,
+/* 0xEE */ 0x00,0x00,0x1C,0x30,0x60,0x60,0x7C,0x60,0x60,0x60,0x30,0x1C,0x00,0x00,0x00,0x00,
+/* 0xEF */ 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
+/* 0xF0 */ 0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,
+/* 0xF1 */ 0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
+/* 0xF2 */ 0x00,0x00,0x00,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00,0x7E,0x00,0x00,0x00,0x00,
+/* 0xF3 */ 0x00,0x00,0x00,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,0x7E,0x00,0x00,0x00,0x00,
+/* 0xF4 */ 0x00,0x0E,0x1B,0x1B,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+/* 0xF5 */ 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xD8,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00,
+/* 0xF6 */ 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x7E,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
+/* 0xF7 */ 0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xF8 */ 0x00,0x38,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xF9 */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xFA */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xFB */ 0x00,0x0F,0x0C,0x0C,0x0C,0x0C,0x0C,0xEC,0x6C,0x6C,0x3C,0x1C,0x00,0x00,0x00,0x00,
+/* 0xFC */ 0x00,0xD8,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xFD */ 0x00,0x70,0xD8,0x30,0x60,0xC8,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/* 0xFE */ 0x00,0x00,0x00,0x00,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x00,0x00,0x00,0x00,0x00,
+};
--- a/arch/ppc/boot/lib/Makefile	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/lib/Makefile	Tue Mar  2 11:56:57 2004
@@ -2,4 +2,7 @@
 # Makefile for some libs needed by zImage.
 #
 
+CFLAGS_kbd.o	+= -Idrivers/char
+
 lib-y := zlib.o div64.o
+lib-$(CONFIG_VGA_CONSOLE) += vreset.o kbd.o
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/arch/ppc/boot/lib/kbd.c	Tue Mar  2 11:56:57 2004
@@ -0,0 +1,248 @@
+#include <linux/keyboard.h>
+
+#include "defkeymap.c"	/* yeah I know it's bad -- Cort */
+
+
+unsigned char shfts, ctls, alts, caps;
+
+#define	KBDATAP		0x60	/* kbd data port */
+#define	KBSTATUSPORT	0x61	/* kbd status */
+#define	KBSTATP		0x64	/* kbd status port */
+#define	KBINRDY		0x01
+#define	KBOUTRDY	0x02
+
+extern unsigned char inb(int port);
+extern void outb(int port, char val);
+extern void puts(const char *);
+extern void puthex(unsigned long val);
+extern void udelay(long x);
+
+static int kbd(int noblock)
+{
+	unsigned char dt, brk, val;
+	unsigned code;
+loop:
+	if (noblock) {
+	    if ((inb(KBSTATP) & KBINRDY) == 0)
+		return (-1);
+	} else while((inb(KBSTATP) & KBINRDY) == 0) ;
+
+	dt = inb(KBDATAP);
+
+	brk = dt & 0x80;	/* brk == 1 on key release */
+	dt = dt & 0x7f;		/* keycode */
+
+	if (shfts)
+	    code = shift_map[dt];
+	else if (ctls)
+	    code = ctrl_map[dt];
+	else
+	    code = plain_map[dt];
+
+	val = KVAL(code);
+	switch (KTYP(code) & 0x0f) {
+	    case KT_LATIN:
+		if (brk)
+		    break;
+		if (alts)
+		    val |= 0x80;
+		if (val == 0x7f)	/* map delete to backspace */
+		    val = '\b';
+		return val;
+
+	    case KT_LETTER:
+		if (brk)
+		    break;
+		if (caps)
+		    val -= 'a'-'A';
+		return val;
+
+	    case KT_SPEC:
+		if (brk)
+		    break;
+		if (val == KVAL(K_CAPS))
+		    caps = !caps;
+		else if (val == KVAL(K_ENTER)) {
+enter:		    /* Wait for key up */
+		    while (1) {
+			while((inb(KBSTATP) & KBINRDY) == 0) ;
+			dt = inb(KBDATAP);
+			if (dt & 0x80) /* key up */ break;
+		    }
+		    return 10;
+		}
+		break;
+
+	    case KT_PAD:
+		if (brk)
+		    break;
+		if (val < 10)
+		    return val;
+		if (val == KVAL(K_PENTER))
+		    goto enter;
+		break;
+
+	    case KT_SHIFT:
+		switch (val) {
+		    case KG_SHIFT:
+		    case KG_SHIFTL:
+		    case KG_SHIFTR:
+			shfts = brk ? 0 : 1;
+			break;
+		    case KG_ALT:
+		    case KG_ALTGR:
+			alts = brk ? 0 : 1;
+			break;
+		    case KG_CTRL:
+		    case KG_CTRLL:
+		    case KG_CTRLR:
+			ctls = brk ? 0 : 1;
+			break;
+		}
+		break;
+
+	    case KT_LOCK:
+		switch (val) {
+		    case KG_SHIFT:
+		    case KG_SHIFTL:
+		    case KG_SHIFTR:
+			if (brk)
+			    shfts = !shfts;
+			break;
+		    case KG_ALT:
+		    case KG_ALTGR:
+			if (brk)
+			    alts = !alts;
+			break;
+		    case KG_CTRL:
+		    case KG_CTRLL:
+		    case KG_CTRLR:
+			if (brk)
+			    ctls = !ctls;
+			break;
+		}
+		break;
+	}
+	if (brk) return (-1);  /* Ignore initial 'key up' codes */
+	goto loop;
+}
+
+static int __kbdreset(void)
+{
+	unsigned char c;
+	int i, t;
+
+	/* flush input queue */
+	t = 2000;
+	while ((inb(KBSTATP) & KBINRDY))
+	{
+		(void)inb(KBDATAP);
+		if (--t == 0)
+			return 1;
+	}
+	/* Send self-test */
+	t = 20000;
+	while (inb(KBSTATP) & KBOUTRDY)
+		if (--t == 0)
+			return 2;
+	outb(KBSTATP,0xAA);
+	t = 200000;
+	while ((inb(KBSTATP) & KBINRDY) == 0)	/* wait input ready */
+		if (--t == 0)
+			return 3;
+	if ((c = inb(KBDATAP)) != 0x55)
+	{
+		puts("Keyboard self test failed - result:");
+		puthex(c);
+		puts("\n");
+	}
+	/* Enable interrupts and keyboard controller */
+	t = 20000;
+	while (inb(KBSTATP) & KBOUTRDY)
+		if (--t == 0) return 4;
+	outb(KBSTATP,0x60);
+	t = 20000;
+	while (inb(KBSTATP) & KBOUTRDY)
+		if (--t == 0) return 5;
+	outb(KBDATAP,0x45);
+	for (i = 0;  i < 10000;  i++) udelay(1);
+
+	t = 20000;
+	while (inb(KBSTATP) & KBOUTRDY)
+		if (--t == 0) return 6;
+	outb(KBSTATP,0x20);
+	t = 200000;
+	while ((inb(KBSTATP) & KBINRDY) == 0)	/* wait input ready */
+		if (--t == 0) return 7;
+	if (! (inb(KBDATAP) & 0x40)) {
+		/*
+		 * Quote from PS/2 System Reference Manual:
+		 *
+		 * "Address hex 0060 and address hex 0064 should be
+		 * written only when the input-buffer-full bit and
+		 * output-buffer-full bit in the Controller Status
+		 * register are set 0." (KBINRDY and KBOUTRDY)
+		 */
+		t = 200000;
+		while (inb(KBSTATP) & (KBINRDY | KBOUTRDY))
+			if (--t == 0) return 8;
+		outb(KBDATAP,0xF0);
+		t = 200000;
+		while (inb(KBSTATP) & (KBINRDY | KBOUTRDY))
+			if (--t == 0) return 9;
+		outb(KBDATAP,0x01);
+	}
+	t = 20000;
+	while (inb(KBSTATP) & KBOUTRDY)
+		if (--t == 0) return 10;
+	outb(KBSTATP,0xAE);
+	return 0;
+}
+
+static void kbdreset(void)
+{
+	int ret = __kbdreset();
+
+	if (ret) {
+		puts("__kbdreset failed: ");
+		puthex(ret);
+		puts("\n");
+	}
+}
+
+/* We have to actually read the keyboard when CRT_tstc is called,
+ * since the pending data might be a key release code, and therefore
+ * not valid data.  In this case, kbd() will return -1, even though there's
+ * data to be read.  Of course, we might actually read a valid key press,
+ * in which case it gets queued into key_pending for use by CRT_getc.
+ */
+
+static int kbd_reset = 0;
+
+static int key_pending = -1;
+
+int CRT_getc(void)
+{
+	int c;
+	if (!kbd_reset) {kbdreset(); kbd_reset++; }
+
+        if (key_pending != -1) {
+                c = key_pending;
+                key_pending = -1;
+                return c;
+        } else {
+	while ((c = kbd(0)) == 0) ;
+                return c;
+        }
+}
+
+int CRT_tstc(void)
+{
+	if (!kbd_reset) {kbdreset(); kbd_reset++; }
+
+        while (key_pending == -1 && ((inb(KBSTATP) & KBINRDY) != 0)) {
+                key_pending = kbd(1);
+        }
+
+        return (key_pending != -1);
+}
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/arch/ppc/boot/lib/vreset.c	Tue Mar  2 11:56:57 2004
@@ -0,0 +1,805 @@
+/*
+ * vreset.c
+ *
+ * Initialize the VGA control registers to 80x25 text mode.
+ *
+ * Adapted from a program by:
+ *                                      Steve Sellgren
+ *                                      San Francisco Indigo Company
+ *                                      sfindigo!sellgren@uunet.uu.net
+ *
+ * Original concept by:
+ *                                      Gary Thomas <gdt@linuxppc.org>
+ * Adapted for Moto boxes by:
+ *                                      Pat Kane & Mark Scott, 1996
+ * Adapted for IBM portables by:
+ *                                      Takeshi Ishimoto
+ * Multi-console support:
+ *                                      Terje Malmedal <terje.malmedal@usit.uio.no>
+ */
+
+#include "iso_font.h"
+#include "nonstdio.h"
+
+extern char *vidmem;
+extern int lines, cols;
+struct VaRegs;
+
+/*
+ * VGA Register
+ */
+struct VgaRegs
+{
+	unsigned short io_port;
+	unsigned char  io_index;
+	unsigned char  io_value;
+};
+
+void unlockVideo(int slot);
+void setTextRegs(struct VgaRegs *svp);
+void setTextCLUT(int shift);
+void clearVideoMemory(void);
+void loadFont(unsigned char *ISA_mem);
+
+static void mdelay(int ms)
+{
+	for (; ms > 0; --ms)
+		udelay(1000);
+}
+
+/*
+ * Default console text mode registers  used to reset
+ * graphics adapter.
+ */
+#define NREGS 54
+#define ENDMK  0xFFFF  /* End marker */
+
+#define S3Vendor	0x5333
+#define CirrusVendor    0x1013
+#define DiamondVendor   0x100E
+#define MatroxVendor    0x102B
+#define ParadiseVendor  0x101C
+
+struct VgaRegs GenVgaTextRegs[NREGS+1] = {
+	/* port		index	value  */
+	/* SR Regs */
+	{ 0x3c4,	0x1,	0x0 },
+	{ 0x3c4,	0x2,	0x3 },
+	{ 0x3c4,	0x3,	0x0 },
+	{ 0x3c4,	0x4,	0x2 },
+	 /* CR Regs */
+	{ 0x3d4,	0x0,	0x5f },
+	{ 0x3d4,	0x1,	0x4f },
+	{ 0x3d4,	0x2,	0x50 },
+	{ 0x3d4,	0x3,	0x82 },
+	{ 0x3d4,	0x4,	0x55 },
+	{ 0x3d4,	0x5,	0x81 },
+	{ 0x3d4,	0x6,	0xbf },
+	{ 0x3d4,	0x7,	0x1f },
+	{ 0x3d4,	0x8,	0x00 },
+	{ 0x3d4,	0x9,	0x4f },
+	{ 0x3d4,	0xa,	0x0d },
+	{ 0x3d4,	0xb,	0x0e },
+	{ 0x3d4,	0xc,	0x00 },
+	{ 0x3d4,	0xd,	0x00 },
+	{ 0x3d4,	0xe,	0x00 },
+	{ 0x3d4,	0xf,	0x00 },
+	{ 0x3d4,	0x10,	0x9c },
+	{ 0x3d4,	0x11,	0x8e },
+	{ 0x3d4,	0x12,	0x8f },
+	{ 0x3d4,	0x13,	0x28 },
+	{ 0x3d4,	0x14,	0x1f },
+	{ 0x3d4,	0x15,	0x96 },
+	{ 0x3d4,	0x16,	0xb9 },
+	{ 0x3d4,	0x17,	0xa3 },
+	 /* GR Regs */
+	{ 0x3ce,	0x0,	0x0 },
+	{ 0x3ce,	0x1,	0x0 },
+	{ 0x3ce,	0x2,	0x0 },
+	{ 0x3ce,	0x3,	0x0 },
+	{ 0x3ce,	0x4,	0x0 },
+	{ 0x3ce,	0x5,	0x10 },
+	{ 0x3ce,	0x6,	0xe },
+	{ 0x3ce,	0x7,	0x0 },
+	{ 0x3ce,	0x8,	0xff },
+	{ ENDMK }
+};
+
+struct RGBColors
+{
+  unsigned char r, g, b;
+};
+
+/*
+ * Default console text mode color table.
+ * These values were obtained by booting Linux with
+ * text mode firmware & then dumping the registers.
+ */
+struct RGBColors TextCLUT[256] =
+{
+	/* red	green	blue  */
+	{ 0x0,	0x0,	0x0 },
+	{ 0x0,	0x0,	0x2a },
+	{ 0x0,	0x2a,	0x0 },
+	{ 0x0,	0x2a,	0x2a },
+	{ 0x2a,	0x0,	0x0 },
+	{ 0x2a,	0x0,	0x2a },
+	{ 0x2a,	0x2a,	0x0 },
+	{ 0x2a,	0x2a,	0x2a },
+	{ 0x0,	0x0,	0x15 },
+	{ 0x0,	0x0,	0x3f },
+	{ 0x0,	0x2a,	0x15 },
+	{ 0x0,	0x2a,	0x3f },
+	{ 0x2a,	0x0,	0x15 },
+	{ 0x2a,	0x0,	0x3f },
+	{ 0x2a,	0x2a,	0x15 },
+	{ 0x2a,	0x2a,	0x3f },
+	{ 0x0,	0x15,	0x0 },
+	{ 0x0,	0x15,	0x2a },
+	{ 0x0,	0x3f,	0x0 },
+	{ 0x0,	0x3f,	0x2a },
+	{ 0x2a,	0x15,	0x0 },
+	{ 0x2a,	0x15,	0x2a },
+	{ 0x2a,	0x3f,	0x0 },
+	{ 0x2a,	0x3f,	0x2a },
+	{ 0x0,	0x15,	0x15 },
+	{ 0x0,	0x15,	0x3f },
+	{ 0x0,	0x3f,	0x15 },
+	{ 0x0,	0x3f,	0x3f },
+	{ 0x2a,	0x15,	0x15 },
+	{ 0x2a,	0x15,	0x3f },
+	{ 0x2a,	0x3f,	0x15 },
+	{ 0x2a,	0x3f,	0x3f },
+	{ 0x15,	0x0,	0x0 },
+	{ 0x15,	0x0,	0x2a },
+	{ 0x15,	0x2a,	0x0 },
+	{ 0x15,	0x2a,	0x2a },
+	{ 0x3f,	0x0,	0x0 },
+	{ 0x3f,	0x0,	0x2a },
+	{ 0x3f,	0x2a,	0x0 },
+	{ 0x3f,	0x2a,	0x2a },
+	{ 0x15,	0x0,	0x15 },
+	{ 0x15,	0x0,	0x3f },
+	{ 0x15,	0x2a,	0x15 },
+	{ 0x15,	0x2a,	0x3f },
+	{ 0x3f,	0x0,	0x15 },
+	{ 0x3f,	0x0,	0x3f },
+	{ 0x3f,	0x2a,	0x15 },
+	{ 0x3f,	0x2a,	0x3f },
+	{ 0x15,	0x15,	0x0 },
+	{ 0x15,	0x15,	0x2a },
+	{ 0x15,	0x3f,	0x0 },
+	{ 0x15,	0x3f,	0x2a },
+	{ 0x3f,	0x15,	0x0 },
+	{ 0x3f,	0x15,	0x2a },
+	{ 0x3f,	0x3f,	0x0 },
+	{ 0x3f,	0x3f,	0x2a },
+	{ 0x15,	0x15,	0x15 },
+	{ 0x15,	0x15,	0x3f },
+	{ 0x15,	0x3f,	0x15 },
+	{ 0x15,	0x3f,	0x3f },
+	{ 0x3f,	0x15,	0x15 },
+	{ 0x3f,	0x15,	0x3f },
+	{ 0x3f,	0x3f,	0x15 },
+	{ 0x3f,	0x3f,	0x3f },
+	{ 0x39,	0xc,	0x5 },
+	{ 0x15,	0x2c,	0xf },
+	{ 0x26,	0x10,	0x3d },
+	{ 0x29,	0x29,	0x38 },
+	{ 0x4,	0x1a,	0xe },
+	{ 0x2,	0x1e,	0x3a },
+	{ 0x3c,	0x25,	0x33 },
+	{ 0x3c,	0xc,	0x2c },
+	{ 0x3f,	0x3,	0x2b },
+	{ 0x1c,	0x9,	0x13 },
+	{ 0x25,	0x2a,	0x35 },
+	{ 0x1e,	0xa,	0x38 },
+	{ 0x24,	0x8,	0x3 },
+	{ 0x3,	0xe,	0x36 },
+	{ 0xc,	0x6,	0x2a },
+	{ 0x26,	0x3,	0x32 },
+	{ 0x5,	0x2f,	0x33 },
+	{ 0x3c,	0x35,	0x2f },
+	{ 0x2d,	0x26,	0x3e },
+	{ 0xd,	0xa,	0x10 },
+	{ 0x25,	0x3c,	0x11 },
+	{ 0xd,	0x4,	0x2e },
+	{ 0x5,	0x19,	0x3e },
+	{ 0xc,	0x13,	0x34 },
+	{ 0x2b,	0x6,	0x24 },
+	{ 0x4,	0x3,	0xd },
+	{ 0x2f,	0x3c,	0xc },
+	{ 0x2a,	0x37,	0x1f },
+	{ 0xf,	0x12,	0x38 },
+	{ 0x38,	0xe,	0x2a },
+	{ 0x12,	0x2f,	0x19 },
+	{ 0x29,	0x2e,	0x31 },
+	{ 0x25,	0x13,	0x3e },
+	{ 0x33,	0x3e,	0x33 },
+	{ 0x1d,	0x2c,	0x25 },
+	{ 0x15,	0x15,	0x5 },
+	{ 0x32,	0x25,	0x39 },
+	{ 0x1a,	0x7,	0x1f },
+	{ 0x13,	0xe,	0x1d },
+	{ 0x36,	0x17,	0x34 },
+	{ 0xf,	0x15,	0x23 },
+	{ 0x2,	0x35,	0xd },
+	{ 0x15,	0x3f,	0xc },
+	{ 0x14,	0x2f,	0xf },
+	{ 0x19,	0x21,	0x3e },
+	{ 0x27,	0x11,	0x2f },
+	{ 0x38,	0x3f,	0x3c },
+	{ 0x36,	0x2d,	0x15 },
+	{ 0x16,	0x17,	0x2 },
+	{ 0x1,	0xa,	0x3d },
+	{ 0x1b,	0x11,	0x3f },
+	{ 0x21,	0x3c,	0xd },
+	{ 0x1a,	0x39,	0x3d },
+	{ 0x8,	0xe,	0xe },
+	{ 0x22,	0x21,	0x23 },
+	{ 0x1e,	0x30,	0x5 },
+	{ 0x1f,	0x22,	0x3d },
+	{ 0x1e,	0x2f,	0xa },
+	{ 0x0,	0x1c,	0xe },
+	{ 0x0,	0x1c,	0x15 },
+	{ 0x0,	0x1c,	0x1c },
+	{ 0x0,	0x15,	0x1c },
+	{ 0x0,	0xe,	0x1c },
+	{ 0x0,	0x7,	0x1c },
+	{ 0xe,	0xe,	0x1c },
+	{ 0x11,	0xe,	0x1c },
+	{ 0x15,	0xe,	0x1c },
+	{ 0x18,	0xe,	0x1c },
+	{ 0x1c,	0xe,	0x1c },
+	{ 0x1c,	0xe,	0x18 },
+	{ 0x1c,	0xe,	0x15 },
+	{ 0x1c,	0xe,	0x11 },
+	{ 0x1c,	0xe,	0xe },
+	{ 0x1c,	0x11,	0xe },
+	{ 0x1c,	0x15,	0xe },
+	{ 0x1c,	0x18,	0xe },
+	{ 0x1c,	0x1c,	0xe },
+	{ 0x18,	0x1c,	0xe },
+	{ 0x15,	0x1c,	0xe },
+	{ 0x11,	0x1c,	0xe },
+	{ 0xe,	0x1c,	0xe },
+	{ 0xe,	0x1c,	0x11 },
+	{ 0xe,	0x1c,	0x15 },
+	{ 0xe,	0x1c,	0x18 },
+	{ 0xe,	0x1c,	0x1c },
+	{ 0xe,	0x18,	0x1c },
+	{ 0xe,	0x15,	0x1c },
+	{ 0xe,	0x11,	0x1c },
+	{ 0x14,	0x14,	0x1c },
+	{ 0x16,	0x14,	0x1c },
+	{ 0x18,	0x14,	0x1c },
+	{ 0x1a,	0x14,	0x1c },
+	{ 0x1c,	0x14,	0x1c },
+	{ 0x1c,	0x14,	0x1a },
+	{ 0x1c,	0x14,	0x18 },
+	{ 0x1c,	0x14,	0x16 },
+	{ 0x1c,	0x14,	0x14 },
+	{ 0x1c,	0x16,	0x14 },
+	{ 0x1c,	0x18,	0x14 },
+	{ 0x1c,	0x1a,	0x14 },
+	{ 0x1c,	0x1c,	0x14 },
+	{ 0x1a,	0x1c,	0x14 },
+	{ 0x18,	0x1c,	0x14 },
+	{ 0x16,	0x1c,	0x14 },
+	{ 0x14,	0x1c,	0x14 },
+	{ 0x14,	0x1c,	0x16 },
+	{ 0x14,	0x1c,	0x18 },
+	{ 0x14,	0x1c,	0x1a },
+	{ 0x14,	0x1c,	0x1c },
+	{ 0x14,	0x1a,	0x1c },
+	{ 0x14,	0x18,	0x1c },
+	{ 0x14,	0x16,	0x1c },
+	{ 0x0,	0x0,	0x10 },
+	{ 0x4,	0x0,	0x10 },
+	{ 0x8,	0x0,	0x10 },
+	{ 0xc,	0x0,	0x10 },
+	{ 0x10,	0x0,	0x10 },
+	{ 0x10,	0x0,	0xc },
+	{ 0x10,	0x0,	0x8 },
+	{ 0x10,	0x0,	0x4 },
+	{ 0x10,	0x0,	0x0 },
+	{ 0x10,	0x4,	0x0 },
+	{ 0x10,	0x8,	0x0 },
+	{ 0x10,	0xc,	0x0 },
+	{ 0x10,	0x10,	0x0 },
+	{ 0xc,	0x10,	0x0 },
+	{ 0x8,	0x10,	0x0 },
+	{ 0x4,	0x10,	0x0 },
+	{ 0x0,	0x10,	0x0 },
+	{ 0x0,	0x10,	0x4 },
+	{ 0x0,	0x10,	0x8 },
+	{ 0x0,	0x10,	0xc },
+	{ 0x0,	0x10,	0x10 },
+	{ 0x0,	0xc,	0x10 },
+	{ 0x0,	0x8,	0x10 },
+	{ 0x0,	0x4,	0x10 },
+	{ 0x8,	0x8,	0x10 },
+	{ 0xa,	0x8,	0x10 },
+	{ 0xc,	0x8,	0x10 },
+	{ 0xe,	0x8,	0x10 },
+	{ 0x10,	0x8,	0x10 },
+	{ 0x10,	0x8,	0xe },
+	{ 0x10,	0x8,	0xc },
+	{ 0x10,	0x8,	0xa },
+	{ 0x10,	0x8,	0x8 },
+	{ 0x10,	0xa,	0x8 },
+	{ 0x10,	0xc,	0x8 },
+	{ 0x10,	0xe,	0x8 },
+	{ 0x10,	0x10,	0x8 },
+	{ 0xe,	0x10,	0x8 },
+	{ 0xc,	0x10,	0x8 },
+	{ 0xa,	0x10,	0x8 },
+	{ 0x8,	0x10,	0x8 },
+	{ 0x8,	0x10,	0xa },
+	{ 0x8,	0x10,	0xc },
+	{ 0x8,	0x10,	0xe },
+	{ 0x8,	0x10,	0x10 },
+	{ 0x8,	0xe,	0x10 },
+	{ 0x8,	0xc,	0x10 },
+	{ 0x8,	0xa,	0x10 },
+	{ 0xb,	0xb,	0x10 },
+	{ 0xc,	0xb,	0x10 },
+	{ 0xd,	0xb,	0x10 },
+	{ 0xf,	0xb,	0x10 },
+	{ 0x10,	0xb,	0x10 },
+	{ 0x10,	0xb,	0xf },
+	{ 0x10,	0xb,	0xd },
+	{ 0x10,	0xb,	0xc },
+	{ 0x10,	0xb,	0xb },
+	{ 0x10,	0xc,	0xb },
+	{ 0x10,	0xd,	0xb },
+	{ 0x10,	0xf,	0xb },
+	{ 0x10,	0x10,	0xb },
+	{ 0xf,	0x10,	0xb },
+	{ 0xd,	0x10,	0xb },
+	{ 0xc,	0x10,	0xb },
+	{ 0xb,	0x10,	0xb },
+	{ 0xb,	0x10,	0xc },
+	{ 0xb,	0x10,	0xd },
+	{ 0xb,	0x10,	0xf },
+	{ 0xb,	0x10,	0x10 },
+	{ 0xb,	0xf,	0x10 },
+	{ 0xb,	0xd,	0x10 },
+	{ 0xb,	0xc,	0x10 },
+	{ 0x0,	0x0,	0x0 },
+	{ 0x0,	0x0,	0x0 },
+	{ 0x0,	0x0,	0x0 },
+	{ 0x0,	0x0,	0x0 },
+	{ 0x0,	0x0,	0x0 },
+	{ 0x0,	0x0,	0x0 },
+	{ 0x0,	0x0,	0x0 }
+};
+
+unsigned char AC[21] = {
+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
+    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
+    0x0C, 0x00, 0x0F, 0x08, 0x00};
+
+static int scanPCI(int start_slt);
+static int PCIVendor(int);
+#ifdef DEBUG
+static void printslots(void);
+#endif
+extern void puthex(unsigned long);
+extern void puts(const char *);
+static void unlockS3(void);
+
+static inline void
+outw(int port, unsigned short val)
+{
+	outb(port, val >> 8);
+	outb(port+1, val);
+}
+
+int
+vga_init(unsigned char *ISA_mem)
+{
+	int slot;
+	struct VgaRegs *VgaTextRegs;
+
+	/* See if VGA already in TEXT mode - exit if so! */
+	outb(0x3CE, 0x06);
+	if ((inb(0x3CF) & 0x01) == 0){
+		puts("VGA already in text mode\n");
+		return 0;
+	}
+
+	/* If no VGA responding in text mode, then we have some work to do...
+	 */
+	slot = -1;
+	while((slot = scanPCI(slot)) > -1) { /* find video card in use  */
+		unlockVideo(slot);           /* enable I/O to card      */
+		VgaTextRegs = GenVgaTextRegs;
+
+		switch (PCIVendor(slot)) {
+		default:
+			break;
+		case(S3Vendor):
+			unlockS3();
+			break;
+
+		case(CirrusVendor):
+			outw(0x3C4, 0x0612);       /* unlock ext regs */
+			outw(0x3C4, 0x0700);       /* reset ext sequence mode */
+			break;
+
+		case(ParadiseVendor):                 /* IBM Portable 850 */
+			outw(0x3ce, 0x0f05);      /* unlock pardise registers */
+			outw(0x3c4, 0x0648);
+			outw(0x3d4, 0x2985);
+			outw(0x3d4, 0x34a6);
+			outb(0x3ce, 0x0b);       /* disable linear addressing */
+			outb(0x3cf, inb(0x3cf) & ~0x30);
+			outw(0x3c4, 0x1400);
+			outb(0x3ce, 0x0e);       /* disable 256 color mode */
+			outb(0x3cf, inb(0x3cf) & ~0x01);
+			outb(0xd00, 0xff);       /* enable auto-centering */
+			if (!(inb(0xd01) & 0x03)) {
+				outb(0x3d4, 0x33);
+				outb(0x3d5, inb(0x3d5) & ~0x90);
+				outb(0x3d4, 0x32);
+				outb(0x3d5, inb(0x3d5) | 0x04);
+				outw(0x3d4, 0x0250);
+				outw(0x3d4, 0x07ba);
+				outw(0x3d4, 0x0900);
+				outw(0x3d4, 0x15e7);
+				outw(0x3d4, 0x2a95);
+			}
+			outw(0x3d4, 0x34a0);
+			break;
+
+	#if 0 /* Untested - probably doesn't work */
+		case(MatroxVendor):
+		case(DiamondVendor):
+			puts("VGA Chip Vendor ID: ");
+			puthex(PCIVendor(slot));
+			puts("\n");
+			mdelay(1000);
+	#endif
+		};
+
+		outw(0x3C4, 0x0120);           /* disable video              */
+		setTextRegs(VgaTextRegs);      /* initial register setup     */
+		setTextCLUT(0);                /* load color lookup table    */
+		loadFont(ISA_mem);             /* load font                  */
+		setTextRegs(VgaTextRegs);      /* reload registers           */
+		outw(0x3C4, 0x0100);           /* re-enable video            */
+		clearVideoMemory();
+
+		if (PCIVendor(slot) == S3Vendor) {
+			outb(0x3c2, 0x63);                  /* MISC */
+		} /* endif */
+
+	#ifdef DEBUG
+		printslots();
+		mdelay(5000);
+	#endif
+
+		mdelay(1000);	/* give time for the video monitor to come up */
+        }
+	return (1);  /* 'CRT' I/O supported */
+}
+
+/*
+ * Write to VGA Attribute registers.
+ */
+void
+writeAttr(unsigned char index, unsigned char data, unsigned char videoOn)
+{
+	unsigned char v;
+	v = inb(0x3da);   /* reset attr. address toggle */
+	if (videoOn)
+		outb(0x3c0, (index & 0x1F) | 0x20);
+	else
+		outb(0x3c0, (index & 0x1F));
+	outb(0x3c0, data);
+}
+
+void
+setTextRegs(struct VgaRegs *svp)
+{
+	int i;
+
+	/*
+	 *  saved settings
+	 */
+	while( svp->io_port != ENDMK ) {
+		outb(svp->io_port,   svp->io_index);
+		outb(svp->io_port+1, svp->io_value);
+		svp++;
+	}
+
+	outb(0x3c2, 0x67);  /* MISC */
+	outb(0x3c6, 0xff);  /* MASK */
+
+	for ( i = 0; i < 0x10; i++)
+		writeAttr(i, AC[i], 0);  /* pallete */
+	writeAttr(0x10, 0x0c, 0);    /* text mode */
+	writeAttr(0x11, 0x00, 0);    /* overscan color (border) */
+	writeAttr(0x12, 0x0f, 0);    /* plane enable */
+	writeAttr(0x13, 0x08, 0);    /* pixel panning */
+	writeAttr(0x14, 0x00, 1);    /* color select; video on  */
+}
+
+void
+setTextCLUT(int shift)
+{
+	int i;
+
+	outb(0x3C6, 0xFF);
+	i = inb(0x3C7);
+	outb(0x3C8, 0);
+	i = inb(0x3C7);
+
+	for ( i = 0; i < 256; i++) {
+		outb(0x3C9, TextCLUT[i].r << shift);
+		outb(0x3C9, TextCLUT[i].g << shift);
+		outb(0x3C9, TextCLUT[i].b << shift);
+	}
+}
+
+void
+loadFont(unsigned char *ISA_mem)
+{
+	int i, j;
+	unsigned char *font_page = (unsigned char *) &ISA_mem[0xA0000];
+
+	outb(0x3C2, 0x67);
+	/*
+	 * Load font
+	 */
+	i = inb(0x3DA);  /* Reset Attr toggle */
+
+	outb(0x3C0,0x30);
+	outb(0x3C0, 0x01);      /* graphics mode */
+
+	outw(0x3C4, 0x0001);    /* reset sequencer */
+	outw(0x3C4, 0x0204);    /* write to plane 2 */
+	outw(0x3C4, 0x0406);    /* enable plane graphics */
+	outw(0x3C4, 0x0003);    /* reset sequencer */
+	outw(0x3CE, 0x0402);    /* read plane 2 */
+	outw(0x3CE, 0x0500);    /* write mode 0, read mode 0 */
+	outw(0x3CE, 0x0605);    /* set graphics mode */
+
+	for (i = 0;  i < sizeof(font);  i += 16) {
+		for (j = 0;  j < 16;  j++) {
+			__asm__ volatile("eieio");
+			font_page[(2*i)+j] = font[i+j];
+		}
+	}
+}
+
+static void
+unlockS3(void)
+{
+        int s3_device_id;
+	outw(0x3d4, 0x3848);
+	outw(0x3d4, 0x39a5);
+	outb(0x3d4, 0x2d);
+	s3_device_id = inb(0x3d5) << 8;
+	outb(0x3d4, 0x2e);
+	s3_device_id |= inb(0x3d5);
+
+	if (s3_device_id != 0x8812) {
+		/* From the S3 manual */
+		outb(0x46E8, 0x10);  /* Put into setup mode */
+		outb(0x3C3, 0x10);
+		outb(0x102, 0x01);   /* Enable registers */
+		outb(0x46E8, 0x08);  /* Enable video */
+		outb(0x3C3, 0x08);
+		outb(0x4AE8, 0x00);
+
+#if 0
+		outb(0x42E8, 0x80);  /* Reset graphics engine? */
+#endif
+
+		outb(0x3D4, 0x38);  /* Unlock all registers */
+		outb(0x3D5, 0x48);
+		outb(0x3D4, 0x39);
+		outb(0x3D5, 0xA5);
+		outb(0x3D4, 0x40);
+		outb(0x3D5, inb(0x3D5)|0x01);
+		outb(0x3D4, 0x33);
+		outb(0x3D5, inb(0x3D5)&~0x52);
+		outb(0x3D4, 0x35);
+		outb(0x3D5, inb(0x3D5)&~0x30);
+		outb(0x3D4, 0x3A);
+		outb(0x3D5, 0x00);
+		outb(0x3D4, 0x53);
+		outb(0x3D5, 0x00);
+		outb(0x3D4, 0x31);
+		outb(0x3D5, inb(0x3D5)&~0x4B);
+		outb(0x3D4, 0x58);
+
+		outb(0x3D5, 0);
+
+		outb(0x3D4, 0x54);
+		outb(0x3D5, 0x38);
+		outb(0x3D4, 0x60);
+		outb(0x3D5, 0x07);
+		outb(0x3D4, 0x61);
+		outb(0x3D5, 0x80);
+		outb(0x3D4, 0x62);
+		outb(0x3D5, 0xA1);
+		outb(0x3D4, 0x69);  /* High order bits for cursor address */
+		outb(0x3D5, 0);
+
+		outb(0x3D4, 0x32);
+		outb(0x3D5, inb(0x3D5)&~0x10);
+	} else {
+                outw(0x3c4, 0x0806);            /* IBM Portable 860 */
+                outw(0x3c4, 0x1041);
+                outw(0x3c4, 0x1128);
+                outw(0x3d4, 0x4000);
+                outw(0x3d4, 0x3100);
+                outw(0x3d4, 0x3a05);
+                outw(0x3d4, 0x6688);
+                outw(0x3d4, 0x5800);            /* disable linear addressing */
+                outw(0x3d4, 0x4500);            /* disable H/W cursor */
+                outw(0x3c4, 0x5410);            /* enable auto-centering */
+                outw(0x3c4, 0x561f);
+                outw(0x3c4, 0x1b80);            /* lock DCLK selection */
+                outw(0x3d4, 0x3900);            /* lock S3 registers */
+                outw(0x3d4, 0x3800);
+	} /* endif */
+}
+
+/*
+ * cursor() sets an offset (0-1999) into the 80x25 text area.
+ */
+void
+cursor(int x, int y)
+{
+	int pos = (y*cols)+x;
+	outb(0x3D4, 14);
+	outb(0x3D5, pos >> 8);
+	outb(0x3D4, 15);
+	outb(0x3D5, pos);
+}
+
+void
+clearVideoMemory(void)
+{
+	int i, j;
+	for (i = 0;  i < lines;  i++) {
+		for (j = 0;  j < cols;  j++) {
+			vidmem[((i*cols)+j)*2] = 0x20;	/* fill with space character */
+			vidmem[((i*cols)+j)*2+1] = 0x07;  /* set bg & fg attributes */
+		}
+	}
+}
+
+/* ============ */
+
+
+#define NSLOTS 8
+#define NPCIREGS  5
+
+
+/*
+ should use devfunc number/indirect method to be totally safe on
+ all machines, this works for now on 3 slot Moto boxes
+*/
+
+struct PCI_ConfigInfo {
+  unsigned long * config_addr;
+  unsigned long regs[NPCIREGS];
+} PCI_slots [NSLOTS] = {
+
+    { (unsigned long *)0x80808000, {0xDEADBEEF,} },   /* onboard */
+    { (unsigned long *)0x80800800, {0xDEADBEEF,} },   /* onboard */
+    { (unsigned long *)0x80801000, {0xDEADBEEF,} },   /* onboard */
+    { (unsigned long *)0x80802000, {0xDEADBEEF,} },   /* onboard */
+    { (unsigned long *)0x80804000, {0xDEADBEEF,} },   /* onboard */
+    { (unsigned long *)0x80810000, {0xDEADBEEF,} },   /* slot A/1 */
+    { (unsigned long *)0x80820000, {0xDEADBEEF,} },   /* slot B/2 */
+    { (unsigned long *)0x80840000, {0xDEADBEEF,} }    /* slot C/3 */
+};
+
+
+
+/*
+ * The following code modifies the PCI Command register
+ * to enable memory and I/O accesses.
+ */
+void
+unlockVideo(int slot)
+{
+       volatile unsigned char * ppci;
+
+        ppci =  (unsigned char * )PCI_slots[slot].config_addr;
+	ppci[4] = 0x0003;         /* enable memory and I/O accesses */
+	ppci[0x10] = 0x00000;     /* turn off memory mapping */
+	ppci[0x11] = 0x00000;     /* mem_base = 0 */
+	ppci[0x12] = 0x00000;
+	ppci[0x13] = 0x00000;
+	__asm__ volatile("eieio");
+
+	outb(0x3d4, 0x11);
+	outb(0x3d5, 0x0e);   /* unlock CR0-CR7 */
+}
+
+long
+SwapBytes(long lv)   /* turn little endian into big indian long */
+{
+    long t;
+    t  = (lv&0x000000FF) << 24;
+    t |= (lv&0x0000FF00) << 8;
+    t |= (lv&0x00FF0000) >> 8;
+    t |= (lv&0xFF000000) >> 24;
+    return(t);
+}
+
+
+#define DEVID   0
+#define CMD     1
+#define CLASS   2
+#define MEMBASE 4
+
+int
+scanPCI(int start_slt)
+{
+	int slt, r;
+	struct PCI_ConfigInfo *pslot;
+	int theSlot = -1;
+	int highVgaSlot = 0;
+
+	for ( slt = start_slt + 1; slt < NSLOTS; slt++) {
+		pslot = &PCI_slots[slt];
+		for ( r = 0; r < NPCIREGS; r++) {
+			pslot->regs[r] = SwapBytes ( pslot->config_addr[r] );
+		}
+		/* card in slot ? */
+		if ( pslot->regs[DEVID] != 0xFFFFFFFF ) {
+			/* VGA ? */
+			if ( ((pslot->regs[CLASS] & 0xFFFFFF00) == 0x03000000) ||
+			     ((pslot->regs[CLASS] & 0xFFFFFF00) == 0x00010000)) {
+				highVgaSlot = slt;
+				/* did firmware enable it ? */
+				if ( (pslot->regs[CMD] & 0x03) ) {
+					theSlot = slt;
+					break;
+				}
+			}
+		}
+	}
+
+	return ( theSlot );
+}
+
+/* return Vendor ID of card in the slot */
+static
+int PCIVendor(int slotnum) {
+ struct PCI_ConfigInfo *pslot;
+
+ pslot = &PCI_slots[slotnum];
+
+return (pslot->regs[DEVID] & 0xFFFF);
+}
+
+#ifdef DEBUG
+static
+void printslots(void)
+{
+	int i;
+#if 0
+	struct PCI_ConfigInfo *pslot;
+#endif
+	for(i=0; i < NSLOTS; i++) {
+#if 0
+		pslot = &PCI_slots[i];
+		printf("Slot: %d, Addr: %x, Vendor: %08x, Class: %08x\n",
+		       i, pslot->config_addr, pslot->regs[0], pslot->regs[2]);
+#else
+		puts("PCI Slot number: "); puthex(i);
+		puts(" Vendor ID: ");
+		puthex(PCIVendor(i)); puts("\n");
+#endif
+	}
+}
+#endif /* DEBUG */
--- a/arch/ppc/boot/simple/Makefile	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/simple/Makefile	Tue Mar  2 11:56:57 2004
@@ -26,11 +26,12 @@
 utils				:= $(boot)/utils
 bootlib				:= $(boot)/lib
 images				:= $(boot)/images
+of1275				:= $(boot)/of1275
 tftpboot			:= /tftpboot
 
 # Normally, we use the 'misc.c' file for decompress_kernel and
 # whatnot.  Sometimes we need to override this however.
-misc-y	:= misc.o ../common/bootinfo.o
+misc-y	:= misc.o
 
 # Normally, we have our images end in .elf, but something we want to
 # change this.
@@ -96,6 +98,12 @@
          end-$(pcore)			:= pcore
    cacheflag-$(pcore)			:= -include $(clear_L2_L3)
 
+      zimage-$(CONFIG_PPC_PREP)		:= zImage-PPLUS
+zimageinitrd-$(CONFIG_PPC_PREP)		:= zImage.initrd-PPLUS
+     extra.o-$(CONFIG_PPC_PREP)		:= legacy.o
+        misc-$(CONFIG_PPC_PREP)		+= misc-prep.o mpc10x_memory.o
+         end-$(CONFIG_PPC_PREP)		:= prep
+
          end-$(CONFIG_SANDPOINT)	:= sandpoint
    cacheflag-$(CONFIG_SANDPOINT)	:= -include $(clear_L2_L3)
 
@@ -138,6 +146,9 @@
 endif
 
 LIBS				:= $(common)/lib.a $(bootlib)/lib.a
+ifeq ($(CONFIG_PPC_PREP),y)
+LIBS 				+= $(of1275)/lib.a
+endif
 
 OBJS				:= $(addprefix $(obj)/,$(boot-y))
 
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/arch/ppc/boot/simple/cpc700_memory.c	Tue Mar  2 11:56:57 2004
@@ -0,0 +1,36 @@
+/*
+ * arch/ppc/boot/common/cpc700_memory.c
+ *
+ * Find memory based upon settings in the CPC700 bridge
+ *
+ * Author: Dan Cox
+ *
+ * 2001-2002 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <asm/types.h>
+#include <asm/io.h>
+#include "cpc700.h"
+
+unsigned long
+cpc700_get_mem_size(void)
+{
+	int i;
+	unsigned long len, amt;
+
+	/* Start at MB1EA, since MB0EA will most likely be the ending address
+	   for ROM space. */
+	for(len = 0, i = CPC700_MB1EA; i <= CPC700_MB4EA; i+=4) {
+		amt = cpc700_read_memreg(i);
+		if (amt == 0)
+			break;
+		len = amt;
+	}
+
+	return len;
+}
+
+
--- a/arch/ppc/boot/simple/head.S	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/simple/head.S	Tue Mar  2 11:56:57 2004
@@ -7,7 +7,7 @@
  *	   trini@mvista.com
  * Derived from arch/ppc/boot/prep/head.S (Cort Dougan, many others).
  *
- * 2001-2003 (c) MontaVista, Software, Inc.  This file is licensed under
+ * 2001-2004 (c) MontaVista, Software, Inc.  This file is licensed under
  * the terms of the GNU General Public License version 2.  This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
@@ -57,10 +57,11 @@
 	isync
 #endif
 
-#if defined(CONFIG_MBX) || defined(CONFIG_RPX6)
+#if defined(CONFIG_MBX) || defined(CONFIG_RPX6) || defined(CONFIG_PPC_PREP)
 	mr	r29,r3	/* On the MBX860, r3 is the board info pointer.
-			 * On the RPXSUPER, r3 points to the
-			 * NVRAM configuration keys.
+			 * On the RPXSUPER, r3 points to the NVRAM
+			 * configuration keys.
+			 * On PReP, r3 is the pointer to the residual data.
 			 */
 #endif
 
@@ -69,7 +70,36 @@
 	/* The following functions we call must not modify r3 or r4.....
 	*/
 #ifdef CONFIG_6xx
+	/* On PReP we must look at the OpenFirmware pointer and sanity
+	 * test it.  On other platforms, we disable the MMU right now
+	 * and other bits.
+	 */
+#ifdef CONFIG_PPC_PREP
+/*
+ * Save the OF pointer to r25, but only if the entry point is in a sane
+ * location; if not we store 0.  If there is no entry point, or it is
+ * invalid, we establish the default MSR value immediately.  Otherwise,
+ * we defer doing that, to allow OF functions to be called, until we
+ * begin uncompressing the kernel.
+ */
+	lis	r8,0x0fff		/* r8 = 0x0fffffff */
+	ori	r8,r8,0xffff
+
+	subc	r8,r8,r5		/* r8 = (r5 <= r8) ? ~0 : 0 */
+	subfe	r8,r8,r8
+	nand	r8,r8,r8
+
+	and.	r5,r5,r8		/* r5 will be cleared if (r5 > r8) */
+	bne+	haveOF
+
+	li	r8,MSR_IP|MSR_FP	/* Not OF: set MSR immediately */
+  	mtmsr	r8
+	isync
+haveOF:
+	mr	r25,r5
+#else
 	bl	disable_6xx_mmu
+#endif
 	bl	disable_6xx_l1cache
 
 	CLEAR_CACHES
@@ -99,7 +129,7 @@
 	mr	r3, r29
 #endif
 
-#if defined(CONFIG_MBX) || defined(CONFIG_RPX6)
+#if defined(CONFIG_MBX) || defined(CONFIG_RPX6) || defined(CONFIG_PPC_PREP)
 	mr	r4,r29	/* put the board info pointer where the relocate
 			 * routine will find it
 			 */
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/arch/ppc/boot/simple/misc-prep.c	Tue Mar  2 11:56:57 2004
@@ -0,0 +1,211 @@
+/*
+ * arch/ppc/boot/simple/misc-prep.c
+ *
+ * Maintainer: Tom Rini <trini@kernel.crashing.org>
+ *
+ * In the past: Gary Thomas, Cort Dougan <cort@cs.nmt.edu>
+ */
+
+#include <linux/config.h>
+#include <linux/pci_ids.h>
+#include <linux/types.h>
+#include <asm/residual.h>
+#include <asm/string.h>
+#include <asm/byteorder.h>
+#include "mpc10x.h"
+#include "of1275.h"
+#include "nonstdio.h"
+
+extern int keyb_present;	/* keyboard controller is present by default */
+RESIDUAL hold_resid_buf;
+RESIDUAL *hold_residual = &hold_resid_buf;
+static void *OFW_interface;	/* Pointer to OF, if available. */
+
+#ifdef CONFIG_VGA_CONSOLE
+char *vidmem = (char *)0xC00B8000;
+int lines = 25, cols = 80;
+int orig_x, orig_y = 24;
+#endif /* CONFIG_VGA_CONSOLE */
+
+extern int CRT_tstc(void);
+extern int vga_init(unsigned char *ISA_mem);
+extern void gunzip(void *, int, unsigned char *, int *);
+extern unsigned long serial_init(int chan, void *ignored);
+extern void serial_fixups(void);
+extern struct bi_record *decompress_kernel(unsigned long load_addr,
+		int num_words, unsigned long cksum);
+extern void disable_6xx_mmu(void);
+extern unsigned long mpc10x_get_mem_size(void);
+
+static void
+writel(unsigned int val, unsigned int address)
+{
+	/* Ensure I/O operations complete */
+	__asm__ volatile("eieio");
+	*(unsigned int *)address = cpu_to_le32(val);
+}
+
+#define PCI_CFG_ADDR(dev,off)	((0x80<<24) | (dev<<8) | (off&0xfc))
+#define PCI_CFG_DATA(off)	(MPC10X_MAPA_CNFG_DATA+(off&3))
+
+static void
+pci_read_config_32(unsigned char devfn,
+		unsigned char offset,
+		unsigned int *val)
+{
+	/* Ensure I/O operations complete */
+	__asm__ volatile("eieio");
+	*(unsigned int *)PCI_CFG_ADDR(devfn,offset) =
+		cpu_to_le32(MPC10X_MAPA_CNFG_ADDR);
+	/* Ensure I/O operations complete */
+	__asm__ volatile("eieio");
+	*val = le32_to_cpu(*(unsigned int *)PCI_CFG_DATA(offset));
+	return;
+}
+
+#ifdef CONFIG_VGA_CONSOLE
+void
+scroll(void)
+{
+	int i;
+
+	memcpy ( vidmem, vidmem + cols * 2, ( lines - 1 ) * cols * 2 );
+	for ( i = ( lines - 1 ) * cols * 2; i < lines * cols * 2; i += 2 )
+		vidmem[i] = ' ';
+}
+#endif /* CONFIG_VGA_CONSOLE */
+
+unsigned long
+load_kernel(unsigned long load_addr, int num_words, unsigned long cksum,
+		  RESIDUAL *residual, void *OFW)
+{
+	int start_multi = 0;
+	unsigned int pci_viddid, pci_did, tulip_pci_base, tulip_base;
+
+	/* If we have Open Firmware, initialise it immediately */
+	if (OFW) {
+		OFW_interface = OFW;
+		ofinit(OFW_interface);
+	}
+
+#if defined(CONFIG_VGA_CONSOLE)
+	vga_init((unsigned char *)0xC0000000);
+#endif /* CONFIG_VGA_CONSOLE */
+
+	if (residual) {
+		/* Is this Motorola PPCBug? */
+		if ((1 & residual->VitalProductData.FirmwareSupports) &&
+		    (1 == residual->VitalProductData.FirmwareSupplier)) {
+			unsigned char base_mod;
+			unsigned char board_type = inb(0x801) & 0xF0;
+
+			/*
+			 * Reset the onboard 21x4x Ethernet
+			 * Motorola Ethernet is at IDSEL 14 (devfn 0x70)
+			 */
+			pci_read_config_32(0x70, 0x00, &pci_viddid);
+			pci_did = (pci_viddid & 0xffff0000) >> 16;
+			/* Be sure we've really found a 21x4x chip */
+			if (((pci_viddid & 0xffff) == PCI_VENDOR_ID_DEC) &&
+				((pci_did == PCI_DEVICE_ID_DEC_TULIP_FAST) ||
+				(pci_did == PCI_DEVICE_ID_DEC_TULIP) ||
+				(pci_did == PCI_DEVICE_ID_DEC_TULIP_PLUS) ||
+				(pci_did == PCI_DEVICE_ID_DEC_21142))) {
+				pci_read_config_32(0x70,
+						0x10,
+						&tulip_pci_base);
+				/* Get the physical base address */
+				tulip_base =
+					(tulip_pci_base & ~0x03UL) + 0x80000000;
+				/* Strobe the 21x4x reset bit in CSR0 */
+				writel(0x1, tulip_base);
+			}
+
+			/* If this is genesis 2 board then check for no
+			 * keyboard controller and more than one processor.
+			 */
+			if (board_type == 0xe0) {
+				base_mod = inb(0x803);
+				/* if a MVME2300/2400 or a Sitka then no keyboard */
+				if((base_mod == 0xFA) || (base_mod == 0xF9) ||
+				   (base_mod == 0xE1)) {
+					keyb_present = 0;	/* no keyboard */
+				}
+			}
+			/* If this is a multiprocessor system then
+			 * park the other processor so that the
+			 * kernel knows where to find them.
+			 */
+			if (residual->MaxNumCpus > 1)
+				start_multi = 1;
+		}
+		memcpy(hold_residual,residual,sizeof(RESIDUAL));
+        }
+
+	/* Call decompress_kernel */
+	decompress_kernel(load_addr, num_words, cksum);
+
+	if (start_multi) {
+		residual->VitalProductData.SmpIar = (unsigned long)0xc0;
+		residual->Cpus[1].CpuState = CPU_GOOD;
+		hold_residual->VitalProductData.Reserved5 = 0xdeadbeef;
+	}
+
+	/* Now go and clear out the BATs and ensure that our MSR is
+	 * correct .*/
+	disable_6xx_mmu();
+
+	/* Make r3 be a pointer to the residual data. */
+	return (unsigned long)hold_residual;
+}
+
+unsigned long
+get_mem_size(void)
+{
+	unsigned int pci_viddid, pci_did;
+
+	/* First, figure out what kind of host bridge we are on.  If it's
+	 * an MPC10x, we can ask it directly how much memory it has.
+	 * Otherwise, see if the residual data has anything.  This isn't
+	 * the best way, but it can be the only way.  If there's nothing,
+	 * assume 32MB. -- Tom.
+	 */
+	/* See what our host bridge is. */
+	pci_read_config_32(0x00, 0x00, &pci_viddid);
+	pci_did = (pci_viddid & 0xffff0000) >> 16;
+	/* See if we are on an MPC10x. */
+	if (((pci_viddid & 0xffff) == PCI_VENDOR_ID_MOTOROLA)
+			&& ((pci_did == PCI_DEVICE_ID_MOTOROLA_MPC105)
+				|| (pci_did == PCI_DEVICE_ID_MOTOROLA_MPC106)
+				|| (pci_did == PCI_DEVICE_ID_MOTOROLA_MPC107)))
+		return mpc10x_get_mem_size();
+	/* If it's not, see if we have anything in the residual data. */
+	else if (hold_residual && hold_residual->TotalMemory)
+		return hold_residual->TotalMemory;
+	else if (OFW_interface) {
+		/*
+		 * This is a 'best guess' check.  We want to make sure
+		 * we don't try this on a PReP box without OF
+		 *     -- Cort
+		 */
+		while (OFW_interface)
+		{
+			phandle dev_handle;
+			int mem_info[2];
+
+			/* get handle to memory description */
+			if (!(dev_handle = finddevice("/memory@0")))
+				break;
+
+			/* get the info */
+			if (getprop(dev_handle, "reg", mem_info,
+						sizeof(mem_info)) != 8)
+				break;
+
+			return mem_info[1];
+		}
+	}
+
+	/* Fall back to hard-coding 32MB. */
+	return 32*1024*1024;
+}
--- a/arch/ppc/boot/simple/misc-spruce.c	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/simple/misc-spruce.c	Tue Mar  2 11:56:57 2004
@@ -174,7 +174,8 @@
 }
 
 unsigned long
-load_kernel(unsigned long load_addr, int num_words, unsigned long cksum)
+load_kernel(unsigned long load_addr, int num_words, unsigned long cksum,
+		void *ign1, void *ign2)
 {
 	int csr0;
 	int csr_id;
--- a/arch/ppc/boot/simple/misc.c	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/simple/misc.c	Tue Mar  2 11:56:57 2004
@@ -99,7 +99,9 @@
 	unsigned long initrd_loc, TotalMemory = 0;
 
 	serial_fixups();
+#ifdef CONFIG_SERIAL_8250_CONSOLE
 	com_port = serial_init(0, NULL);
+#endif
 
 #ifdef CONFIG_44x
 	/* Reset MAL */
@@ -269,7 +271,8 @@
 
 /* Allow decompress_kernel to be hooked into.  This is the default. */
 void * __attribute__ ((weak))
-load_kernel(unsigned long load_addr, int num_words, unsigned long cksum)
+load_kernel(unsigned long load_addr, int num_words, unsigned long cksum,
+		void *ign1, void *ign2)
 {
 		return decompress_kernel(load_addr, num_words, cksum);
 }
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/arch/ppc/boot/simple/mpc10x_memory.c	Tue Mar  2 11:56:57 2004
@@ -0,0 +1,111 @@
+/*
+ * arch/ppc/boot/common/mpc10x_common.c
+ *
+ * A routine to find out how much memory the machine has.
+ *
+ * Based on:
+ * arch/ppc/kernel/mpc10x_common.c
+ *
+ * Author: Mark A. Greer
+ *         mgreer@mvista.com
+ *
+ * 2001-2002 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/pci.h>
+#include <asm/types.h>
+#include <asm/io.h>
+#include "mpc10x.h"
+
+/*
+ * *** WARNING - A BAT MUST be set to access the PCI config addr/data regs ***
+ */
+
+/*
+ * PCI config space macros, similar to indirect_xxx and early_xxx macros.
+ * We assume bus 0.
+ */
+#define MPC10X_CFG_read(val, addr, type, op)	*val = op((type)(addr))
+#define MPC10X_CFG_write(val, addr, type, op)	op((type *)(addr), (val))
+
+#define MPC10X_PCI_OP(rw, size, type, op, mask)			 	\
+static void								\
+mpc10x_##rw##_config_##size(unsigned int *cfg_addr, 			\
+		unsigned int *cfg_data, int devfn, int offset,		\
+		type val)						\
+{									\
+	out_be32(cfg_addr, 						\
+		 ((offset & 0xfc) << 24) | (devfn << 16)		\
+		 | (0 << 8) | 0x80);					\
+	MPC10X_CFG_##rw(val, cfg_data + (offset & mask), type, op);	\
+	return;    					 		\
+}
+
+MPC10X_PCI_OP(read, byte,  u8 *, in_8, 3)
+MPC10X_PCI_OP(read, dword, u32 *, in_le32, 0)
+
+/*
+ * Read the memory controller registers to determine the amount of memory in
+ * the system.  This assumes that the firmware has correctly set up the memory
+ * controller registers.  On CONFIG_PPC_PREP, we know we are being called
+ * under a PReP memory map. On all other machines, we assume we are under
+ * a CHRP memory map.  Further, on CONFIG_PPC_MULTIPLATFORM we must rename
+ * this function.
+ */
+#ifdef CONFIG_PPC_MULTIPLATFORM
+#define get_mem_size mpc10x_get_mem_size
+#endif
+unsigned long
+get_mem_size(void)
+{
+	unsigned int *config_addr, *config_data, val;
+	unsigned long start, end, total, offset;
+	int i;
+	unsigned char bank_enables;
+
+#ifdef CONFIG_PPC_PREP
+	config_addr = (unsigned int *)MPC10X_MAPA_CNFG_ADDR;
+	config_data = (unsigned int *)MPC10X_MAPA_CNFG_DATA;
+#else
+	config_addr = (unsigned int *)MPC10X_MAPB_CNFG_ADDR;
+	config_data = (unsigned int *)MPC10X_MAPB_CNFG_DATA;
+#endif
+
+	mpc10x_read_config_byte(config_addr, config_data, PCI_DEVFN(0,0),
+			MPC10X_MCTLR_MEM_BANK_ENABLES, &bank_enables);
+
+	total = 0;
+
+	for (i = 0; i < 8; i++) {
+		if (bank_enables & (1 << i)) {
+			offset = MPC10X_MCTLR_MEM_START_1 + ((i > 3) ? 4 : 0);
+			mpc10x_read_config_dword(config_addr, config_data,
+					PCI_DEVFN(0,0), offset, &val);
+			start = (val >> ((i & 3) << 3)) & 0xff;
+
+			offset = MPC10X_MCTLR_EXT_MEM_START_1 + ((i>3) ? 4 : 0);
+			mpc10x_read_config_dword(config_addr, config_data,
+					PCI_DEVFN(0,0), offset, &val);
+			val = (val >> ((i & 3) << 3)) & 0x03;
+			start = (val << 28) | (start << 20);
+
+			offset = MPC10X_MCTLR_MEM_END_1 + ((i > 3) ? 4 : 0);
+			mpc10x_read_config_dword(config_addr, config_data,
+					PCI_DEVFN(0,0), offset, &val);
+			end = (val >> ((i & 3) << 3)) & 0xff;
+
+			offset = MPC10X_MCTLR_EXT_MEM_END_1 + ((i > 3) ? 4 : 0);
+			mpc10x_read_config_dword(config_addr, config_data,
+					PCI_DEVFN(0,0), offset, &val);
+			val = (val >> ((i & 3) << 3)) & 0x03;
+			end = (val << 28) | (end << 20) | 0xfffff;
+
+			total += (end - start + 1);
+		}
+	}
+
+	return total;
+}
--- a/arch/ppc/boot/simple/relocate.S	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/boot/simple/relocate.S	Tue Mar  2 11:56:57 2004
@@ -9,7 +9,7 @@
  *	   trini@mvista.com
  * Derived from arch/ppc/boot/prep/head.S (Cort Dougan, many others).
  *
- * 2001-2002 (c) MontaVista, Software, Inc.  This file is licensed under
+ * 2001-2004 (c) MontaVista, Software, Inc.  This file is licensed under
  * the terms of the GNU General Public License version 2.  This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
@@ -102,7 +102,7 @@
 	GETSYM(r5, do_relocate)
 
 	sub	r4,r5,r4	/* Get entry point for do_relocate in
-	add	r6,r6,r4       * relocated section */
+	add	r6,r6,r4	* relocated section */
 
 	/* This will return to the relocated do_relocate */
 	mtlr	r6
@@ -182,6 +182,7 @@
 	mr	r4,r7		/* Program length */
 	mr	r5,r6		/* Checksum */
 	mr	r6,r11		/* Residual data */
+	mr	r7,r25		/* Validated OFW interface */
 	bl	load_kernel
 
 	/*
@@ -195,8 +196,18 @@
 	/*
 	 * Start at the begining.
 	 */
-	li	r9,0x0000
+	li	r9,0xc
 	mtlr	r9
+#ifdef CONFIG_PPC_MULTIPLATFORM
+	/* tell kernel we're prep, by putting 0xdeadc0de at KERNELLOAD,
+	 * and tell the kernel to start on the 4th instruction since we
+	 * overwrite the first 3 sometimes (which are 'nop').
+	 */
+	lis	r10,0xdeadc0de@h
+	ori	r10,r10,0xdeadc0de@l
+	li	r9,0
+	stw	r10,0(r9)
+#endif
 	blr
 
 	.comm	.stack,4096*2,4
--- a/arch/ppc/platforms/prep_setup.c	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/platforms/prep_setup.c	Tue Mar  2 11:56:57 2004
@@ -49,6 +49,7 @@
 #include <asm/cache.h>
 #include <asm/dma.h>
 #include <asm/machdep.h>
+#include <asm/mc146818rtc.h>
 #include <asm/mk48t59.h>
 #include <asm/prep_nvram.h>
 #include <asm/raven.h>
@@ -1023,8 +1024,10 @@
 
 	ppc_md.time_init      = todc_time_init;
 	if (_prep_type == _PREP_IBM) {
-		TODC_INIT(TODC_TYPE_MC146818, PREP_NVRAM_AS0, PREP_NVRAM_AS1,
-				PREP_NVRAM_DATA, 8);
+		ppc_md.rtc_read_val = todc_mc146818_read_val;
+		ppc_md.rtc_write_val = todc_mc146818_write_val;
+		TODC_INIT(TODC_TYPE_MC146818, RTC_PORT(0), NULL, RTC_PORT(1),
+				8);
 	} else {
 		TODC_INIT(TODC_TYPE_MK48T59, PREP_NVRAM_AS0, PREP_NVRAM_AS1,
 				PREP_NVRAM_DATA, 8);
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/arch/ppc/platforms/spruce.c	Tue Mar  2 11:56:57 2004
@@ -0,0 +1,330 @@
+/*
+ * arch/ppc/platforms/spruce.c
+ *
+ * Board and PCI setup routines for IBM Spruce
+ *
+ * Author: MontaVista Software <source@mvista.com>
+ *
+ * 2000-2004 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/config.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/major.h>
+#include <linux/initrd.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/ide.h>
+#include <linux/root_dev.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial_core.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/time.h>
+#include <asm/todc.h>
+#include <asm/bootinfo.h>
+#include <asm/kgdb.h>
+
+#include <syslib/cpc700.h>
+
+#include "spruce.h"
+
+static inline int
+spruce_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+		/*
+		 * 	PCI IDSEL/INTPIN->INTLINE
+		 * 	A	B	C	D
+		 */
+	{
+		{23, 24, 25, 26},	/* IDSEL 1 - PCI slot 3 */
+		{24, 25, 26, 23},	/* IDSEL 2 - PCI slot 2 */
+		{25, 26, 23, 24},	/* IDSEL 3 - PCI slot 1 */
+		{26, 23, 24, 25},	/* IDSEL 4 - PCI slot 0 */
+	};
+
+	const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+}
+
+static void __init
+spruce_setup_hose(void)
+{
+	struct pci_controller *hose;
+
+	/* Setup hose */
+	hose = pcibios_alloc_controller();
+	if (!hose)
+		return;
+
+	hose->first_busno = 0;
+	hose->last_busno = 0xff;
+
+	pci_init_resource(&hose->io_resource,
+			SPRUCE_PCI_LOWER_IO,
+			SPRUCE_PCI_UPPER_IO,
+			IORESOURCE_IO,
+			"PCI host bridge");
+
+	pci_init_resource(&hose->mem_resources[0],
+			SPRUCE_PCI_LOWER_MEM,
+			SPRUCE_PCI_UPPER_MEM,
+			IORESOURCE_MEM,
+			"PCI host bridge");
+
+	hose->io_space.start = SPRUCE_PCI_LOWER_IO;
+	hose->io_space.end = SPRUCE_PCI_UPPER_IO;
+	hose->mem_space.start = SPRUCE_PCI_LOWER_MEM;
+	hose->mem_space.end = SPRUCE_PCI_UPPER_MEM;
+	hose->io_base_virt = (void *)SPRUCE_ISA_IO_BASE;
+
+	setup_indirect_pci(hose,
+			SPRUCE_PCI_CONFIG_ADDR,
+			SPRUCE_PCI_CONFIG_DATA);
+
+	hose->last_busno = pciauto_bus_scan(hose, hose->first_busno);
+
+	ppc_md.pci_swizzle = common_swizzle;
+	ppc_md.pci_map_irq = spruce_map_irq;
+}
+
+/*
+ * CPC700 PIC interrupt programming table
+ *
+ * First entry is the sensitivity (level/edge), second is the polarity.
+ */
+unsigned int cpc700_irq_assigns[32][2] = {
+	{ 1, 1 },       /* IRQ  0: ECC Correctable Error - rising edge */
+	{ 1, 1 },       /* IRQ  1: PCI Write Mem Range   - rising edge */
+	{ 0, 1 },       /* IRQ  2: PCI Write Command Reg - active high */
+	{ 0, 1 },       /* IRQ  3: UART 0                - active high */
+	{ 0, 1 },       /* IRQ  4: UART 1                - active high */
+	{ 0, 1 },       /* IRQ  5: ICC 0                 - active high */
+	{ 0, 1 },       /* IRQ  6: ICC 1                 - active high */
+	{ 0, 1 },       /* IRQ  7: GPT Compare 0         - active high */
+	{ 0, 1 },       /* IRQ  8: GPT Compare 1         - active high */
+	{ 0, 1 },       /* IRQ  9: GPT Compare 2         - active high */
+	{ 0, 1 },       /* IRQ 10: GPT Compare 3         - active high */
+	{ 0, 1 },       /* IRQ 11: GPT Compare 4         - active high */
+	{ 0, 1 },       /* IRQ 12: GPT Capture 0         - active high */
+	{ 0, 1 },       /* IRQ 13: GPT Capture 1         - active high */
+	{ 0, 1 },       /* IRQ 14: GPT Capture 2         - active high */
+	{ 0, 1 },       /* IRQ 15: GPT Capture 3         - active high */
+	{ 0, 1 },       /* IRQ 16: GPT Capture 4         - active high */
+	{ 0, 0 },       /* IRQ 17: Reserved */
+	{ 0, 0 },       /* IRQ 18: Reserved */
+	{ 0, 0 },       /* IRQ 19: Reserved */
+	{ 0, 1 },       /* IRQ 20: FPGA EXT_IRQ0         - active high */
+	{ 1, 1 },       /* IRQ 21: Mouse                 - rising edge */
+	{ 1, 1 },       /* IRQ 22: Keyboard              - rising edge */
+	{ 0, 0 },       /* IRQ 23: PCI Slot 3            - active low */
+	{ 0, 0 },       /* IRQ 24: PCI Slot 2            - active low */
+	{ 0, 0 },       /* IRQ 25: PCI Slot 1            - active low */
+	{ 0, 0 },       /* IRQ 26: PCI Slot 0            - active low */
+};
+
+static void __init
+spruce_calibrate_decr(void)
+{
+	int freq, divisor = 4;
+
+	/* determine processor bus speed */
+	freq = SPRUCE_BUS_SPEED;
+	tb_ticks_per_jiffy = freq / HZ / divisor;
+	tb_to_us = mulhwu_scale_factor(freq/divisor, 1000000);
+}
+
+static int
+spruce_show_cpuinfo(struct seq_file *m)
+{
+	seq_printf(m, "vendor\t\t: IBM\n");
+	seq_printf(m, "machine\t\t: Spruce\n");
+
+	return 0;
+}
+
+static void __init
+spruce_early_serial_map(void)
+{
+	u32 uart_clk;
+	struct uart_port serial_req;
+
+	if (SPRUCE_UARTCLK_IS_33M(readb(SPRUCE_FPGA_REG_A)))
+		uart_clk = SPRUCE_BAUD_33M * 16;
+	else
+		uart_clk = SPRUCE_BAUD_30M * 16;
+
+	/* Setup serial port access */
+	memset(&serial_req, 0, sizeof(serial_req));
+	serial_req.uartclk = uart_clk;
+	serial_req.irq = UART0_INT;
+	serial_req.flags = ASYNC_BOOT_AUTOCONF;
+	serial_req.iotype = SERIAL_IO_MEM;
+	serial_req.membase = (u_char *)UART0_IO_BASE;
+	serial_req.regshift = 0;
+
+#if defined(CONFIG_KGDB) || defined(CONFIG_SERIAL_TEXT_DEBUG)
+	gen550_init(0, &serial_req);
+#endif
+#ifdef CONFIG_SERIAL_8250
+	if (early_serial_setup(&serial_req) != 0)
+		printk("Early serial init of port 0 failed\n");
+#endif
+
+	/* Assume early_serial_setup() doesn't modify serial_req */
+	serial_req.line = 1;
+	serial_req.irq = UART1_INT;
+	serial_req.membase = (u_char *)UART1_IO_BASE;
+
+#if defined(CONFIG_KGDB) || defined(CONFIG_SERIAL_TEXT_DEBUG)
+	gen550_init(1, &serial_req);
+#endif
+#ifdef CONFIG_SERIAL_8250
+	if (early_serial_setup(&serial_req) != 0)
+		printk("Early serial init of port 1 failed\n");
+#endif
+}
+
+TODC_ALLOC();
+
+static void __init
+spruce_setup_arch(void)
+{
+	/* Setup TODC access */
+	TODC_INIT(TODC_TYPE_DS1643, 0, 0, SPRUCE_RTC_BASE_ADDR, 8);
+
+	/* init to some ~sane value until calibrate_delay() runs */
+	loops_per_jiffy = 50000000 / HZ;
+
+	/* Setup PCI host bridge */
+	spruce_setup_hose();
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start)
+		ROOT_DEV = Root_RAM0;
+	else
+#endif
+#ifdef CONFIG_ROOT_NFS
+		ROOT_DEV = Root_NFS;
+#else
+		ROOT_DEV = Root_SDA1;
+#endif
+
+#ifdef CONFIG_VT
+	conswitchp = &dummy_con;
+#endif
+
+
+	/* Identify the system */
+	printk(KERN_INFO "System Identification: IBM Spruce\n");
+	printk(KERN_INFO "Port by MontaVista Software, Inc. (source@mvista.com)\n");
+}
+
+static void
+spruce_restart(char *cmd)
+{
+	local_irq_disable();
+
+	/* SRR0 has system reset vector, SRR1 has default MSR value */
+	/* rfi restores MSR from SRR1 and sets the PC to the SRR0 value */
+	__asm__ __volatile__
+	("\n\
+	lis	3,0xfff0	\n\
+	ori	3,3,0x0100	\n\
+	mtspr	26,3		\n\
+	li	3,0		\n\
+	mtspr	27,3		\n\
+	rfi			\n\
+	");
+	for(;;);
+}
+
+static void
+spruce_power_off(void)
+{
+	for(;;);
+}
+
+static void
+spruce_halt(void)
+{
+	spruce_restart(NULL);
+}
+
+static void __init
+spruce_map_io(void)
+{
+	io_block_mapping(SPRUCE_PCI_IO_BASE, SPRUCE_PCI_PHY_IO_BASE,
+			 0x08000000, _PAGE_IO);
+}
+
+/*
+ * Set BAT 3 to map 0xf8000000 to end of physical memory space 1-to-1.
+ */
+static __inline__ void
+spruce_set_bat(void)
+{
+	mb();
+	mtspr(DBAT1U, 0xf8000ffe);
+	mtspr(DBAT1L, 0xf800002a);
+	mb();
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	parse_bootinfo(find_bootinfo());
+
+	/* Map in board regs, etc. */
+	spruce_set_bat();
+
+	isa_io_base = SPRUCE_ISA_IO_BASE;
+	pci_dram_offset = SPRUCE_PCI_SYS_MEM_BASE;
+
+	ppc_md.setup_arch = spruce_setup_arch;
+	ppc_md.show_cpuinfo = spruce_show_cpuinfo;
+	ppc_md.init_IRQ = cpc700_init_IRQ;
+	ppc_md.get_irq = cpc700_get_irq;
+
+	ppc_md.setup_io_mappings = spruce_map_io;
+
+	ppc_md.restart = spruce_restart;
+	ppc_md.power_off = spruce_power_off;
+	ppc_md.halt = spruce_halt;
+
+	ppc_md.time_init = todc_time_init;
+	ppc_md.set_rtc_time = todc_set_rtc_time;
+	ppc_md.get_rtc_time = todc_get_rtc_time;
+	ppc_md.calibrate_decr = spruce_calibrate_decr;
+
+	ppc_md.nvram_read_val = todc_direct_read_val;
+	ppc_md.nvram_write_val = todc_direct_write_val;
+
+	spruce_early_serial_map();
+
+#ifdef CONFIG_SERIAL_TEXT_DEBUG
+	ppc_md.progress = gen550_progress;
+#endif /* CONFIG_SERIAL_TEXT_DEBUG */
+#ifdef CONFIG_KGDB
+	ppc_md.kgdb_map_scc = gen550_kgdb_map_scc;
+#endif
+}
--- a/arch/ppc/syslib/gen550_dbg.c	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/syslib/gen550_dbg.c	Tue Mar  2 11:56:57 2004
@@ -151,7 +151,7 @@
 gen550_init(int i, struct uart_port *serial_req)
 {
 	rs_table[i].io_type = serial_req->iotype;
-	rs_table[i].port = serial_req->line;
+	rs_table[i].port = serial_req->iobase;
 	rs_table[i].iomem_base = serial_req->membase;
 	rs_table[i].iomem_reg_shift = serial_req->regshift;
 }
--- a/arch/ppc/syslib/todc_time.c	Tue Mar  2 11:56:57 2004
+++ b/arch/ppc/syslib/todc_time.c	Tue Mar  2 11:56:57 2004
@@ -7,7 +7,7 @@
  * Author: Mark A. Greer
  *         mgreer@mvista.com
  *
- * 2001 (c) MontaVista, Software, Inc.  This file is licensed under
+ * 2001-2004 (c) MontaVista, Software, Inc.  This file is licensed under
  * the terms of the GNU General Public License version 2.  This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
@@ -31,15 +31,13 @@
  * 'nvram_data' to the base address of your nvram and leave 'nvram_as0' and
  * 'nvram_as1' NULL.  If your board uses address/data regs to access nvram,
  * set 'nvram_as0' to the address of the lower byte, set 'nvram_as1' to the
- * address of the upper byte (leave NULL if using mv146818), and set
+ * address of the upper byte (leave NULL if using mc146818), and set
  * 'nvram_data' to the address of the 8-bit data register.
  *
- * You also need to set 'ppc_md.nvram_read_val' and 'ppc_md.nvram_write_val' to
- * the proper routines.  There are standard ones defined further down in
- * this file that you can use.
- *
- * There is a built in assumption that the RTC and NVRAM are accessed by the
- * same mechanism (i.e., ppc_md.nvram_read_val, etc works for both).
+ * In order to break the assumption that the RTC and NVRAM are accessed by
+ * the same mechanism, you need to explicitly set 'ppc_md.rtc_read_val' and
+ * 'ppc_md.rtc_write_val', otherwise the values of 'ppc_md.rtc_read_val'
+ * and 'ppc_md.rtc_write_val' will be used.
  *
  * Note: Even though the documentation for the various RTC chips say that it
  * 	 take up to a second before it starts updating once the 'R' bit is
@@ -50,6 +48,8 @@
  * 	 					--MAG
  */
 
+extern spinlock_t	rtc_lock;
+
 /*
  * 'todc_info' should be initialized in your *_setup.c file to
  * point to a fully initialized 'todc_info_t' structure.
@@ -114,16 +114,63 @@
 u_char
 todc_mc146818_read_val(int addr)
 {
-	outb(addr, todc_info->nvram_as0);
-	return inb(todc_info->nvram_data);
+	outb_p(addr, todc_info->nvram_as0);
+	return inb_p(todc_info->nvram_data);
 }
 
 void
 todc_mc146818_write_val(int addr, unsigned char val)
 {
-	outb(addr, todc_info->nvram_as0);
-   	outb(val, todc_info->nvram_data);
-	return;
+	outb_p(addr, todc_info->nvram_as0);
+   	outb_p(val, todc_info->nvram_data);
+}
+
+
+/*
+ * Routines to make RTC chips with NVRAM buried behind an addr/data pair
+ * have the NVRAM and clock regs appear at the same level.
+ * The NVRAM will appear to start at addr 0 and the clock regs will appear
+ * to start immediately after the NVRAM (actually, start at offset
+ * todc_info->nvram_size).
+ */
+static inline u_char
+todc_read_val(int addr)
+{
+	u_char	val;
+
+	if (todc_info->sw_flags & TODC_FLAG_2_LEVEL_NVRAM) {
+		if (addr < todc_info->nvram_size) { /* NVRAM */
+			ppc_md.rtc_write_val(todc_info->nvram_addr_reg, addr);
+			val = ppc_md.rtc_read_val(todc_info->nvram_data_reg);
+		}
+		else { /* Clock Reg */
+			addr -= todc_info->nvram_size;
+			val = ppc_md.rtc_read_val(addr);
+		}
+	}
+	else {
+		val = ppc_md.rtc_read_val(addr);
+	}
+
+	return val;
+}
+
+static inline void
+todc_write_val(int addr, u_char val)
+{
+	if (todc_info->sw_flags & TODC_FLAG_2_LEVEL_NVRAM) {
+		if (addr < todc_info->nvram_size) { /* NVRAM */
+			ppc_md.rtc_write_val(todc_info->nvram_addr_reg, addr);
+			ppc_md.rtc_write_val(todc_info->nvram_data_reg, val);
+		}
+		else { /* Clock Reg */
+			addr -= todc_info->nvram_size;
+			ppc_md.rtc_write_val(addr, val);
+		}
+	}
+	else {
+		ppc_md.rtc_write_val(addr, val);
+	}
 }
 
 /*
@@ -142,77 +189,80 @@
 long __init
 todc_time_init(void)
 {
-	static u_char	not_initialized = 1;
-
-	/* Make sure clocks are running */
-	if (not_initialized) {
-		u_char	cntl_b;
+	u_char	cntl_b;
 
-		cntl_b = ppc_md.nvram_read_val(todc_info->control_b);
+	if (!ppc_md.rtc_read_val)
+		ppc_md.rtc_read_val = ppc_md.nvram_read_val;
+	if (!ppc_md.rtc_write_val)
+		ppc_md.rtc_write_val = ppc_md.nvram_write_val;
+	
+	cntl_b = todc_read_val(todc_info->control_b);
 
-		if (todc_info->rtc_type == TODC_TYPE_MC146818) {
-			if ((cntl_b & 0x70) != 0x20) {
-				printk(KERN_INFO "TODC %s %s\n",
-					"real-time-clock was stopped.",
-					"Now starting...");
-				cntl_b &= ~0x70;
-				cntl_b |= 0x20;
-			}
-
-			ppc_md.nvram_write_val(todc_info->control_b, cntl_b);
+	if (todc_info->rtc_type == TODC_TYPE_MC146818) {
+		if ((cntl_b & 0x70) != 0x20) {
+			printk(KERN_INFO "TODC %s %s\n",
+				"real-time-clock was stopped.",
+				"Now starting...");
+			cntl_b &= ~0x70;
+			cntl_b |= 0x20;
 		}
-		else if (todc_info->rtc_type == TODC_TYPE_DS1501) {
-			u_char	month;
-
-			todc_info->enable_read = TODC_DS1501_CNTL_B_TE;
-			todc_info->enable_write = TODC_DS1501_CNTL_B_TE;
-
-			month = ppc_md.nvram_read_val(todc_info->month);
 
-			if ((month & 0x80) == 0x80) {
-				printk(KERN_INFO "TODC %s %s\n",
-					"real-time-clock was stopped.",
-					"Now starting...");
-				month &= ~0x80;
-				ppc_md.nvram_write_val(todc_info->month, month);
-			}
-
-			cntl_b &= ~TODC_DS1501_CNTL_B_TE;
-			ppc_md.nvram_write_val(todc_info->control_b, cntl_b);
+		todc_write_val(todc_info->control_b, cntl_b);
+	} else if (todc_info->rtc_type == TODC_TYPE_DS17285) {
+		u_char mode;
+
+		mode = todc_read_val(TODC_TYPE_DS17285_CNTL_A);
+		/* Make sure countdown clear is not set */
+		mode &= ~0x40;
+		/* Enable oscillator, extended register set */
+		mode |= 0x30;
+		todc_write_val(TODC_TYPE_DS17285_CNTL_A, mode);
+
+	} else if (todc_info->rtc_type == TODC_TYPE_DS1501) {
+		u_char	month;
+
+		todc_info->enable_read = TODC_DS1501_CNTL_B_TE;
+		todc_info->enable_write = TODC_DS1501_CNTL_B_TE;
+
+		month = todc_read_val(todc_info->month);
+
+		if ((month & 0x80) == 0x80) {
+			printk(KERN_INFO "TODC %s %s\n",
+				"real-time-clock was stopped.",
+				"Now starting...");
+			month &= ~0x80;
+			todc_write_val(todc_info->month, month);
 		}
-		else { /* must be a m48txx type */
-			u_char	cntl_a;
-
-			todc_info->enable_read = TODC_MK48TXX_CNTL_A_R;
-			todc_info->enable_write = TODC_MK48TXX_CNTL_A_W;
-
-			cntl_a = ppc_md.nvram_read_val(todc_info->control_a);
 
-			/* Check & clear STOP bit in control B register */
-			if (cntl_b & TODC_MK48TXX_DAY_CB) {
-				printk(KERN_INFO "TODC %s %s\n",
-					"real-time-clock was stopped.",
-					"Now starting...");
+		cntl_b &= ~TODC_DS1501_CNTL_B_TE;
+		todc_write_val(todc_info->control_b, cntl_b);
+	} else { /* must be a m48txx type */
+		u_char	cntl_a;
+
+		todc_info->enable_read = TODC_MK48TXX_CNTL_A_R;
+		todc_info->enable_write = TODC_MK48TXX_CNTL_A_W;
+
+		cntl_a = todc_read_val(todc_info->control_a);
+
+		/* Check & clear STOP bit in control B register */
+		if (cntl_b & TODC_MK48TXX_DAY_CB) {
+			printk(KERN_INFO "TODC %s %s\n",
+				"real-time-clock was stopped.",
+				"Now starting...");
 
-				cntl_a |= todc_info->enable_write;
-				cntl_b &= ~TODC_MK48TXX_DAY_CB;/* Start Oscil */
+			cntl_a |= todc_info->enable_write;
+			cntl_b &= ~TODC_MK48TXX_DAY_CB;/* Start Oscil */
 
-				ppc_md.nvram_write_val(todc_info->control_a,
-						       cntl_a);
-				ppc_md.nvram_write_val(todc_info->control_b,
-						       cntl_b);
-			}
-
-			/* Make sure READ & WRITE bits are cleared. */
-			cntl_a &= ~(todc_info->enable_write |
-				    todc_info->enable_read);
-			ppc_md.nvram_write_val(todc_info->control_a, cntl_a);
+			todc_write_val(todc_info->control_a, cntl_a);
+			todc_write_val(todc_info->control_b, cntl_b);
 		}
 
-		not_initialized = 0;
+		/* Make sure READ & WRITE bits are cleared. */
+		cntl_a &= ~(todc_info->enable_write |
+			    todc_info->enable_read);
+		todc_write_val(todc_info->control_a, cntl_a);
 	}
 
-
 	return 0;
 }
 
@@ -231,7 +281,8 @@
 	uint	limit, i;
 	u_char	save_control, uip;
 
-	save_control = ppc_md.nvram_read_val(todc_info->control_a);
+	spin_lock(&rtc_lock);
+	save_control = todc_read_val(todc_info->control_a);
 
 	if (todc_info->rtc_type != TODC_TYPE_MC146818) {
 		limit = 1;
@@ -241,9 +292,10 @@
 			case TODC_TYPE_DS1743:
 			case TODC_TYPE_DS1746:	/* XXXX BAD HACK -> FIX */
 			case TODC_TYPE_DS1747:
+			case TODC_TYPE_DS17285:
 				break;
 			default:
-				ppc_md.nvram_write_val(todc_info->control_a,
+				todc_write_val(todc_info->control_a,
 				       (save_control | todc_info->enable_read));
 		}
 	}
@@ -253,19 +305,18 @@
 
 	for (i=0; i<limit; i++) {
 		if (todc_info->rtc_type == TODC_TYPE_MC146818) {
-			uip = ppc_md.nvram_read_val(todc_info->RTC_FREQ_SELECT);
+			uip = todc_read_val(todc_info->RTC_FREQ_SELECT);
 		}
 
-		sec = ppc_md.nvram_read_val(todc_info->seconds) & 0x7f;
-		min = ppc_md.nvram_read_val(todc_info->minutes) & 0x7f;
-		hour = ppc_md.nvram_read_val(todc_info->hours) & 0x3f;
-		day = ppc_md.nvram_read_val(todc_info->day_of_month) & 0x3f;
-		mon = ppc_md.nvram_read_val(todc_info->month) & 0x1f;
-		year = ppc_md.nvram_read_val(todc_info->year) & 0xff;
+		sec = todc_read_val(todc_info->seconds) & 0x7f;
+		min = todc_read_val(todc_info->minutes) & 0x7f;
+		hour = todc_read_val(todc_info->hours) & 0x3f;
+		day = todc_read_val(todc_info->day_of_month) & 0x3f;
+		mon = todc_read_val(todc_info->month) & 0x1f;
+		year = todc_read_val(todc_info->year) & 0xff;
 
 		if (todc_info->rtc_type == TODC_TYPE_MC146818) {
-			uip |= ppc_md.nvram_read_val(
-					todc_info->RTC_FREQ_SELECT);
+			uip |= todc_read_val(todc_info->RTC_FREQ_SELECT);
 			if ((uip & RTC_UIP) == 0) break;
 		}
 	}
@@ -276,13 +327,15 @@
 			case TODC_TYPE_DS1743:
 			case TODC_TYPE_DS1746:	/* XXXX BAD HACK -> FIX */
 			case TODC_TYPE_DS1747:
+			case TODC_TYPE_DS17285:
 				break;
 			default:
 				save_control &= ~(todc_info->enable_read);
-				ppc_md.nvram_write_val(todc_info->control_a,
+				todc_write_val(todc_info->control_a,
 						       save_control);
 		}
 	}
+	spin_unlock(&rtc_lock);
 
 	if ((todc_info->rtc_type != TODC_TYPE_MC146818) ||
 	    ((save_control & RTC_DM_BINARY) == 0) ||
@@ -310,19 +363,19 @@
 	struct rtc_time	tm;
 	u_char		save_control, save_freq_select;
 
+	spin_lock(&rtc_lock);
 	to_tm(nowtime, &tm);
 
-	save_control = ppc_md.nvram_read_val(todc_info->control_a);
+	save_control = todc_read_val(todc_info->control_a);
 
 	/* Assuming MK48T59_RTC_CA_WRITE & RTC_SET are equal */
-	ppc_md.nvram_write_val(todc_info->control_a,
+	todc_write_val(todc_info->control_a,
 			       (save_control | todc_info->enable_write));
 	save_control &= ~(todc_info->enable_write); /* in case it was set */
 
 	if (todc_info->rtc_type == TODC_TYPE_MC146818) {
-		save_freq_select =
-			ppc_md.nvram_read_val(todc_info->RTC_FREQ_SELECT);
-		ppc_md.nvram_write_val(todc_info->RTC_FREQ_SELECT,
+		save_freq_select = todc_read_val(todc_info->RTC_FREQ_SELECT);
+		todc_write_val(todc_info->RTC_FREQ_SELECT,
 				       save_freq_select | RTC_DIV_RESET2);
 	}
 
@@ -341,19 +394,19 @@
 		BIN_TO_BCD(tm.tm_year);
 	}
 
-	ppc_md.nvram_write_val(todc_info->seconds,      tm.tm_sec);
-	ppc_md.nvram_write_val(todc_info->minutes,      tm.tm_min);
-	ppc_md.nvram_write_val(todc_info->hours,        tm.tm_hour);
-	ppc_md.nvram_write_val(todc_info->month,        tm.tm_mon);
-	ppc_md.nvram_write_val(todc_info->day_of_month, tm.tm_mday);
-	ppc_md.nvram_write_val(todc_info->year,         tm.tm_year);
+	todc_write_val(todc_info->seconds,      tm.tm_sec);
+	todc_write_val(todc_info->minutes,      tm.tm_min);
+	todc_write_val(todc_info->hours,        tm.tm_hour);
+	todc_write_val(todc_info->month,        tm.tm_mon);
+	todc_write_val(todc_info->day_of_month, tm.tm_mday);
+	todc_write_val(todc_info->year,         tm.tm_year);
 
-	ppc_md.nvram_write_val(todc_info->control_a, save_control);
+	todc_write_val(todc_info->control_a, save_control);
 
 	if (todc_info->rtc_type == TODC_TYPE_MC146818) {
-		ppc_md.nvram_write_val(todc_info->RTC_FREQ_SELECT,
-				       save_freq_select);
+		todc_write_val(todc_info->RTC_FREQ_SELECT, save_freq_select);
 	}
+	spin_unlock(&rtc_lock);
 
 	return 0;
 }
@@ -367,30 +420,28 @@
 
 	switch (todc_info->rtc_type) {
 		case TODC_TYPE_DS1557:
-		case TODC_TYPE_DS1743:
 		case TODC_TYPE_DS1746:	/* XXXX BAD HACK -> FIX */
 		case TODC_TYPE_DS1747:
+		case TODC_TYPE_DS17285:
 		case TODC_TYPE_MC146818:
 			break;
 		default:
-			save_control =
-				ppc_md.nvram_read_val(todc_info->control_a);
-			ppc_md.nvram_write_val(todc_info->control_a,
+			save_control = todc_read_val(todc_info->control_a);
+			todc_write_val(todc_info->control_a,
 				       (save_control | todc_info->enable_read));
 	}
-	val = ppc_md.nvram_read_val(addr);
+	val = todc_read_val(addr);
 
 	switch (todc_info->rtc_type) {
 		case TODC_TYPE_DS1557:
-		case TODC_TYPE_DS1743:
 		case TODC_TYPE_DS1746:	/* XXXX BAD HACK -> FIX */
 		case TODC_TYPE_DS1747:
+		case TODC_TYPE_DS17285:
 		case TODC_TYPE_MC146818:
 			break;
 		default:
 			save_control &= ~(todc_info->enable_read);
-			ppc_md.nvram_write_val(todc_info->control_a,
-					       save_control);
+			todc_write_val(todc_info->control_a, save_control);
 	}
 
 	return val;
@@ -412,7 +463,7 @@
 
 	/*
 	 * Actually this is bad for precision, we should have a loop in
-	 * which we only read the seconds counter. nvram_read_val writes
+	 * which we only read the seconds counter. todc_read_val writes
 	 * the address bytes on every call and this takes a lot of time.
 	 * Perhaps an nvram_wait_change method returning a time
 	 * stamp with a loop count as parameter would be the solution.
--- a/include/asm-ppc/io.h	Tue Mar  2 11:56:57 2004
+++ b/include/asm-ppc/io.h	Tue Mar  2 11:56:57 2004
@@ -82,7 +82,6 @@
 #define insl(port, buf, nl)	_insl_ns((u32 *)((port)+_IO_BASE), (buf), (nl))
 #define outsl(port, buf, nl)	_outsl_ns((u32 *)((port)+_IO_BASE), (buf), (nl))
 
-#ifdef CONFIG_PPC_PMAC
 /*
  * On powermacs, we will get a machine check exception if we
  * try to read data from a non-existent I/O port.  Because the
@@ -94,7 +93,7 @@
  * all PPC implementations tested so far.  The twi and isync are
  * needed on the 601 (in fact twi; sync works too), the isync and
  * nop are needed on 604[e|r], and any of twi, sync or isync will
- * work on 603[e], 750, 74x0.
+ * work on 603[e], 750, 74xx.
  * The twi creates an explicit data dependency on the returned
  * value which seems to be needed to make the 601 wait for the
  * load to finish.
@@ -140,27 +139,17 @@
 }
 
 __do_in_asm(inb, "lbzx")
+__do_out_asm(outb, "stbx")
+#ifdef CONFIG_APUS
+__do_in_asm(inw, "lhz%U1%X1")
+__do_in_asm(inl, "lwz%U1%X1")
+__do_out_asm(outl,"stw%U0%X0")
+__do_out_asm(outw, "sth%U0%X0")
+#else
 __do_in_asm(inw, "lhbrx")
 __do_in_asm(inl, "lwbrx")
-__do_out_asm(outb, "stbx")
 __do_out_asm(outw, "sthbrx")
 __do_out_asm(outl, "stwbrx")
-
-#elif defined(CONFIG_APUS)
-#define inb(port)		in_8((u8 *)((port)+_IO_BASE))
-#define outb(val, port)		out_8((u8 *)((port)+_IO_BASE), (val))
-#define inw(port)		in_be16((u16 *)((port)+_IO_BASE))
-#define outw(val, port)		out_be16((u16 *)((port)+_IO_BASE), (val))
-#define inl(port)		in_be32((u32 *)((port)+_IO_BASE))
-#define outl(val, port)		out_be32((u32 *)((port)+_IO_BASE), (val))
-
-#else /* not APUS or PMAC */
-#define inb(port)		in_8((u8 *)((port)+_IO_BASE))
-#define outb(val, port)		out_8((u8 *)((port)+_IO_BASE), (val))
-#define inw(port)		in_le16((u16 *)((port)+_IO_BASE))
-#define outw(val, port)		out_le16((u16 *)((port)+_IO_BASE), (val))
-#define inl(port)		in_le32((u32 *)((port)+_IO_BASE))
-#define outl(val, port)		out_le32((u32 *)((port)+_IO_BASE), (val))
 #endif
 
 #define inb_p(port)		inb((port))
@@ -291,12 +280,19 @@
 
 /*
  * 8, 16 and 32 bit, big and little endian I/O operations, with barrier.
+ *
+ * Read operations have additional twi & isync to make sure the read
+ * is actually performed (i.e. the data has come back) before we start
+ * executing any following instructions.
  */
 extern inline int in_8(volatile unsigned char *addr)
 {
 	int ret;
 
-	__asm__ __volatile__("lbz%U1%X1 %0,%1; eieio" : "=r" (ret) : "m" (*addr));
+	__asm__ __volatile__(
+		"lbz%U1%X1 %0,%1;\n"
+		"twi 0,%0,0;\n"
+		"isync" : "=r" (ret) : "m" (*addr));
 	return ret;
 }
 
@@ -309,7 +305,9 @@
 {
 	int ret;
 
-	__asm__ __volatile__("lhbrx %0,0,%1; eieio" : "=r" (ret) :
+	__asm__ __volatile__("lhbrx %0,0,%1;\n"
+			     "twi 0,%0,0;\n"
+			     "isync" : "=r" (ret) :
 			      "r" (addr), "m" (*addr));
 	return ret;
 }
@@ -318,7 +316,9 @@
 {
 	int ret;
 
-	__asm__ __volatile__("lhz%U1%X1 %0,%1; eieio" : "=r" (ret) : "m" (*addr));
+	__asm__ __volatile__("lhz%U1%X1 %0,%1;\n"
+			     "twi 0,%0,0;\n"
+			     "isync" : "=r" (ret) : "m" (*addr));
 	return ret;
 }
 
@@ -337,7 +337,9 @@
 {
 	unsigned ret;
 
-	__asm__ __volatile__("lwbrx %0,0,%1; eieio" : "=r" (ret) :
+	__asm__ __volatile__("lwbrx %0,0,%1;\n"
+			     "twi 0,%0,0;\n"
+			     "isync" : "=r" (ret) :
 			     "r" (addr), "m" (*addr));
 	return ret;
 }
@@ -346,7 +348,9 @@
 {
 	unsigned ret;
 
-	__asm__ __volatile__("lwz%U1%X1 %0,%1; eieio" : "=r" (ret) : "m" (*addr));
+	__asm__ __volatile__("lwz%U1%X1 %0,%1;\n"
+			     "twi 0,%0,0;\n"
+			     "isync" : "=r" (ret) : "m" (*addr));
 	return ret;
 }
 
--- a/include/asm-ppc/machdep.h	Tue Mar  2 11:56:57 2004
+++ b/include/asm-ppc/machdep.h	Tue Mar  2 11:56:57 2004
@@ -43,6 +43,8 @@
 	long		(*time_init)(void); /* Optional, may be NULL */
 	int		(*set_rtc_time)(unsigned long nowtime);
 	unsigned long	(*get_rtc_time)(void);
+	unsigned char 	(*rtc_read_val)(int addr);
+	void		(*rtc_write_val)(int addr, unsigned char val);
 	void		(*calibrate_decr)(void);
 
 	void		(*heartbeat)(void);
--- a/include/asm-ppc/todc.h	Tue Mar  2 11:56:57 2004
+++ b/include/asm-ppc/todc.h	Tue Mar  2 11:56:57 2004
@@ -29,9 +29,9 @@
 	 * Following are the addresses of the AS0, AS1, and DATA registers
 	 * of these chips.  Note that these are board-specific.
 	 */
-	unsigned char *nvram_as0;
-	unsigned char *nvram_as1;
-	unsigned char *nvram_data;
+	unsigned int nvram_as0;
+	unsigned int nvram_as1;
+	unsigned int nvram_data;
 
 	/*
 	 * Define bits to stop external set of regs from changing so
@@ -46,6 +46,9 @@
 	 */
 	int as0_bits;
 
+	int nvram_size;	/* Size of NVRAM on chip */
+	int sw_flags;	/* Software control flags */
+
 	/* Following are the register offsets for the particular chip */
 	int year;
 	int month;
@@ -64,6 +67,14 @@
 	int alarm_seconds;
 	int century;
 	int flags;
+
+	/*
+	 * Some RTC chips have their NVRAM buried behind a addr/data pair of
+	 * regs on the first level/clock registers.  The following fields
+	 * are the addresses for those addr/data regs.
+	 */
+	int nvram_addr_reg;
+	int nvram_data_reg;
 } todc_info_t;
 
 /*
@@ -86,7 +97,8 @@
 #define TODC_TYPE_DS1643		9	/* Dallas DS1643 RTC */
 #define TODC_TYPE_PC97307		10	/* PC97307 internal RTC */
 #define TODC_TYPE_DS1557		11	/* Dallas DS1557 RTC */
-#define	TODC_TYPE_MC146818		100	/* Leave room for more m48txx's */
+#define TODC_TYPE_DS17285		12	/* Dallas DS17285 RTC */
+#define	TODC_TYPE_MC146818		100	/* Leave room for m48txx's */
 
 /*
  * Bit to clear/set to enable reads/writes to the chip
@@ -98,9 +110,18 @@
 #define	TODC_DS1501_CNTL_B_TE		0x80
 
 /*
+ * Define flag bits used by todc routines.
+ */
+#define	TODC_FLAG_2_LEVEL_NVRAM		0x00000001
+
+/*
  * Define the values for the various RTC's that should to into the todc_info
  * table.
+ * Note: The XXX_NVRAM_SIZE, XXX_NVRAM_ADDR_REG, and XXX_NVRAM_DATA_REG only
+ * matter if XXX_SW_FLAGS has TODC_FLAG_2_LEVEL_NVRAM set.
  */
+#define	TODC_TYPE_MK48T35_NVRAM_SIZE		0x7ff8
+#define	TODC_TYPE_MK48T35_SW_FLAGS		0
 #define	TODC_TYPE_MK48T35_YEAR			0x7fff
 #define	TODC_TYPE_MK48T35_MONTH			0x7ffe
 #define	TODC_TYPE_MK48T35_DOM			0x7ffd	/* Day of Month */
@@ -118,7 +139,11 @@
 #define	TODC_TYPE_MK48T35_ALARM_SECONDS		0x0000
 #define	TODC_TYPE_MK48T35_CENTURY		0x0000
 #define	TODC_TYPE_MK48T35_FLAGS			0x0000
+#define	TODC_TYPE_MK48T35_NVRAM_ADDR_REG	0
+#define	TODC_TYPE_MK48T35_NVRAM_DATA_REG	0
 
+#define	TODC_TYPE_MK48T37_NVRAM_SIZE		0x7ff0
+#define	TODC_TYPE_MK48T37_SW_FLAGS		0
 #define	TODC_TYPE_MK48T37_YEAR			0x7fff
 #define	TODC_TYPE_MK48T37_MONTH			0x7ffe
 #define	TODC_TYPE_MK48T37_DOM			0x7ffd	/* Day of Month */
@@ -136,7 +161,11 @@
 #define	TODC_TYPE_MK48T37_ALARM_SECONDS		0x7ff2
 #define	TODC_TYPE_MK48T37_CENTURY		0x7ff1
 #define	TODC_TYPE_MK48T37_FLAGS			0x7ff0
+#define	TODC_TYPE_MK48T37_NVRAM_ADDR_REG	0
+#define	TODC_TYPE_MK48T37_NVRAM_DATA_REG	0
 
+#define	TODC_TYPE_MK48T59_NVRAM_SIZE		0x1ff0
+#define	TODC_TYPE_MK48T59_SW_FLAGS		0
 #define	TODC_TYPE_MK48T59_YEAR			0x1fff
 #define	TODC_TYPE_MK48T59_MONTH			0x1ffe
 #define	TODC_TYPE_MK48T59_DOM			0x1ffd	/* Day of Month */
@@ -154,25 +183,33 @@
 #define	TODC_TYPE_MK48T59_ALARM_SECONDS		0x1fff
 #define	TODC_TYPE_MK48T59_CENTURY		0x1fff
 #define	TODC_TYPE_MK48T59_FLAGS			0x1fff
+#define	TODC_TYPE_MK48T59_NVRAM_ADDR_REG	0
+#define	TODC_TYPE_MK48T59_NVRAM_DATA_REG	0
 
-#define	TODC_TYPE_DS1501_YEAR			0x06
-#define	TODC_TYPE_DS1501_MONTH			0x05
-#define	TODC_TYPE_DS1501_DOM			0x04	/* Day of Month */
-#define	TODC_TYPE_DS1501_DOW			0x03	/* Day of Week */
-#define	TODC_TYPE_DS1501_HOURS			0x02
-#define	TODC_TYPE_DS1501_MINUTES		0x01
-#define	TODC_TYPE_DS1501_SECONDS		0x00
-#define	TODC_TYPE_DS1501_CNTL_B			0x0f
-#define	TODC_TYPE_DS1501_CNTL_A			0x0f
-#define	TODC_TYPE_DS1501_WATCHDOG		0xff
-#define	TODC_TYPE_DS1501_INTERRUPTS		0xff
-#define	TODC_TYPE_DS1501_ALARM_DATE		0x0b
-#define	TODC_TYPE_DS1501_ALARM_HOUR		0x0a
-#define	TODC_TYPE_DS1501_ALARM_MINUTES		0x09
-#define	TODC_TYPE_DS1501_ALARM_SECONDS		0x08
-#define	TODC_TYPE_DS1501_CENTURY		0x07
-#define	TODC_TYPE_DS1501_FLAGS			0xff
+#define	TODC_TYPE_DS1501_NVRAM_SIZE	0x100
+#define	TODC_TYPE_DS1501_SW_FLAGS	TODC_FLAG_2_LEVEL_NVRAM
+#define	TODC_TYPE_DS1501_YEAR		(TODC_TYPE_DS1501_NVRAM_SIZE + 0x06)
+#define	TODC_TYPE_DS1501_MONTH		(TODC_TYPE_DS1501_NVRAM_SIZE + 0x05)
+#define	TODC_TYPE_DS1501_DOM		(TODC_TYPE_DS1501_NVRAM_SIZE + 0x04)
+#define	TODC_TYPE_DS1501_DOW		(TODC_TYPE_DS1501_NVRAM_SIZE + 0x03)
+#define	TODC_TYPE_DS1501_HOURS		(TODC_TYPE_DS1501_NVRAM_SIZE + 0x02)
+#define	TODC_TYPE_DS1501_MINUTES	(TODC_TYPE_DS1501_NVRAM_SIZE + 0x01)
+#define	TODC_TYPE_DS1501_SECONDS	(TODC_TYPE_DS1501_NVRAM_SIZE + 0x00)
+#define	TODC_TYPE_DS1501_CNTL_B		(TODC_TYPE_DS1501_NVRAM_SIZE + 0x0f)
+#define	TODC_TYPE_DS1501_CNTL_A		(TODC_TYPE_DS1501_NVRAM_SIZE + 0x0f)
+#define	TODC_TYPE_DS1501_WATCHDOG	(TODC_TYPE_DS1501_NVRAM_SIZE + 0xff)
+#define	TODC_TYPE_DS1501_INTERRUPTS	(TODC_TYPE_DS1501_NVRAM_SIZE + 0xff)
+#define	TODC_TYPE_DS1501_ALARM_DATE	(TODC_TYPE_DS1501_NVRAM_SIZE + 0x0b)
+#define	TODC_TYPE_DS1501_ALARM_HOUR	(TODC_TYPE_DS1501_NVRAM_SIZE + 0x0a)
+#define	TODC_TYPE_DS1501_ALARM_MINUTES	(TODC_TYPE_DS1501_NVRAM_SIZE + 0x09)
+#define	TODC_TYPE_DS1501_ALARM_SECONDS	(TODC_TYPE_DS1501_NVRAM_SIZE + 0x08)
+#define	TODC_TYPE_DS1501_CENTURY	(TODC_TYPE_DS1501_NVRAM_SIZE + 0x07)
+#define	TODC_TYPE_DS1501_FLAGS		(TODC_TYPE_DS1501_NVRAM_SIZE + 0xff)
+#define	TODC_TYPE_DS1501_NVRAM_ADDR_REG	0x10
+#define	TODC_TYPE_DS1501_NVRAM_DATA_REG	0x13
 
+#define	TODC_TYPE_DS1557_NVRAM_SIZE		0x7fff0
+#define	TODC_TYPE_DS1557_SW_FLAGS		0
 #define	TODC_TYPE_DS1557_YEAR			0x7ffff
 #define	TODC_TYPE_DS1557_MONTH			0x7fffe
 #define	TODC_TYPE_DS1557_DOM			0x7fffd	/* Day of Month */
@@ -190,7 +227,11 @@
 #define	TODC_TYPE_DS1557_ALARM_SECONDS		0x7fff2
 #define	TODC_TYPE_DS1557_CENTURY		0x7fff8
 #define	TODC_TYPE_DS1557_FLAGS			0x7fff0
+#define	TODC_TYPE_DS1557_NVRAM_ADDR_REG		0
+#define	TODC_TYPE_DS1557_NVRAM_DATA_REG		0
 
+#define	TODC_TYPE_DS1643_NVRAM_SIZE		0x1ff8
+#define	TODC_TYPE_DS1643_SW_FLAGS		0
 #define	TODC_TYPE_DS1643_YEAR			0x1fff
 #define	TODC_TYPE_DS1643_MONTH			0x1ffe
 #define	TODC_TYPE_DS1643_DOM			0x1ffd	/* Day of Month */
@@ -208,7 +249,11 @@
 #define	TODC_TYPE_DS1643_ALARM_SECONDS		0x1fff
 #define	TODC_TYPE_DS1643_CENTURY		0x1ff8
 #define	TODC_TYPE_DS1643_FLAGS			0x1fff
+#define	TODC_TYPE_DS1643_NVRAM_ADDR_REG		0
+#define	TODC_TYPE_DS1643_NVRAM_DATA_REG		0
 
+#define	TODC_TYPE_DS1693_NVRAM_SIZE		0 /* Not handled yet */
+#define	TODC_TYPE_DS1693_SW_FLAGS		0
 #define	TODC_TYPE_DS1693_YEAR			0x09
 #define	TODC_TYPE_DS1693_MONTH			0x08
 #define	TODC_TYPE_DS1693_DOM			0x07	/* Day of Month */
@@ -226,7 +271,11 @@
 #define	TODC_TYPE_DS1693_ALARM_SECONDS		0x01
 #define	TODC_TYPE_DS1693_CENTURY		0x48
 #define	TODC_TYPE_DS1693_FLAGS			0xff
+#define	TODC_TYPE_DS1693_NVRAM_ADDR_REG		0
+#define	TODC_TYPE_DS1693_NVRAM_DATA_REG		0
 
+#define	TODC_TYPE_DS1743_NVRAM_SIZE		0x1ff8
+#define	TODC_TYPE_DS1743_SW_FLAGS		0
 #define	TODC_TYPE_DS1743_YEAR			0x1fff
 #define	TODC_TYPE_DS1743_MONTH			0x1ffe
 #define	TODC_TYPE_DS1743_DOM			0x1ffd	/* Day of Month */
@@ -244,7 +293,11 @@
 #define	TODC_TYPE_DS1743_ALARM_SECONDS		0x1fff
 #define	TODC_TYPE_DS1743_CENTURY		0x1ff8
 #define	TODC_TYPE_DS1743_FLAGS			0x1fff
+#define	TODC_TYPE_DS1743_NVRAM_ADDR_REG		0
+#define	TODC_TYPE_DS1743_NVRAM_DATA_REG		0
 
+#define	TODC_TYPE_DS1746_NVRAM_SIZE		0x1fff8
+#define	TODC_TYPE_DS1746_SW_FLAGS		0
 #define	TODC_TYPE_DS1746_YEAR			0x1ffff
 #define	TODC_TYPE_DS1746_MONTH			0x1fffe
 #define	TODC_TYPE_DS1746_DOM			0x1fffd	/* Day of Month */
@@ -262,16 +315,20 @@
 #define	TODC_TYPE_DS1746_ALARM_SECONDS		0x00000
 #define	TODC_TYPE_DS1746_CENTURY		0x00000
 #define	TODC_TYPE_DS1746_FLAGS			0x00000
+#define	TODC_TYPE_DS1746_NVRAM_ADDR_REG		0
+#define	TODC_TYPE_DS1746_NVRAM_DATA_REG		0
 
-#define	TODC_TYPE_DS1747_YEAR			0x1ffff
-#define	TODC_TYPE_DS1747_MONTH			0x1fffe
-#define	TODC_TYPE_DS1747_DOM			0x1fffd	/* Day of Month */
-#define	TODC_TYPE_DS1747_DOW			0x1fffc	/* Day of Week */
-#define	TODC_TYPE_DS1747_HOURS			0x1fffb
-#define	TODC_TYPE_DS1747_MINUTES		0x1fffa
-#define	TODC_TYPE_DS1747_SECONDS		0x1fff9
-#define	TODC_TYPE_DS1747_CNTL_B			0x1fff9
-#define	TODC_TYPE_DS1747_CNTL_A			0x1fff8	/* control_a R/W regs */
+#define	TODC_TYPE_DS1747_NVRAM_SIZE		0x7fff8
+#define	TODC_TYPE_DS1747_SW_FLAGS		0
+#define	TODC_TYPE_DS1747_YEAR			0x7ffff
+#define	TODC_TYPE_DS1747_MONTH			0x7fffe
+#define	TODC_TYPE_DS1747_DOM			0x7fffd	/* Day of Month */
+#define	TODC_TYPE_DS1747_DOW			0x7fffc	/* Day of Week */
+#define	TODC_TYPE_DS1747_HOURS			0x7fffb
+#define	TODC_TYPE_DS1747_MINUTES		0x7fffa
+#define	TODC_TYPE_DS1747_SECONDS		0x7fff9
+#define	TODC_TYPE_DS1747_CNTL_B			0x7fff9
+#define	TODC_TYPE_DS1747_CNTL_A			0x7fff8	/* control_a R/W regs */
 #define	TODC_TYPE_DS1747_WATCHDOG		0x00000
 #define	TODC_TYPE_DS1747_INTERRUPTS		0x00000
 #define	TODC_TYPE_DS1747_ALARM_DATE		0x00000
@@ -280,7 +337,35 @@
 #define	TODC_TYPE_DS1747_ALARM_SECONDS		0x00000
 #define	TODC_TYPE_DS1747_CENTURY		0x00000
 #define	TODC_TYPE_DS1747_FLAGS			0x00000
+#define	TODC_TYPE_DS1747_NVRAM_ADDR_REG		0
+#define	TODC_TYPE_DS1747_NVRAM_DATA_REG		0
 
+#define TODC_TYPE_DS17285_NVRAM_SIZE		(0x1000-0x80)    /* 4Kx8 NVRAM (minus RTC regs) */
+#define TODC_TYPE_DS17285_SW_FLAGS		TODC_FLAG_2_LEVEL_NVRAM
+#define TODC_TYPE_DS17285_SECONDS		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x00)
+#define TODC_TYPE_DS17285_ALARM_SECONDS		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x01)
+#define TODC_TYPE_DS17285_MINUTES		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x02)
+#define TODC_TYPE_DS17285_ALARM_MINUTES		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x03)
+#define TODC_TYPE_DS17285_HOURS			(TODC_TYPE_DS17285_NVRAM_SIZE + 0x04)
+#define TODC_TYPE_DS17285_ALARM_HOUR		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x05)
+#define TODC_TYPE_DS17285_DOW			(TODC_TYPE_DS17285_NVRAM_SIZE + 0x06)
+#define TODC_TYPE_DS17285_DOM			(TODC_TYPE_DS17285_NVRAM_SIZE + 0x07)
+#define TODC_TYPE_DS17285_MONTH			(TODC_TYPE_DS17285_NVRAM_SIZE + 0x08)
+#define TODC_TYPE_DS17285_YEAR			(TODC_TYPE_DS17285_NVRAM_SIZE + 0x09)
+#define TODC_TYPE_DS17285_CNTL_A		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x0A)
+#define TODC_TYPE_DS17285_CNTL_B		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x0B)
+#define TODC_TYPE_DS17285_CNTL_C		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x0C)
+#define TODC_TYPE_DS17285_CNTL_D		(TODC_TYPE_DS17285_NVRAM_SIZE + 0x0D)
+#define TODC_TYPE_DS17285_WATCHDOG		0
+#define TODC_TYPE_DS17285_INTERRUPTS		0
+#define TODC_TYPE_DS17285_ALARM_DATE		0
+#define TODC_TYPE_DS17285_CENTURY		0
+#define TODC_TYPE_DS17285_FLAGS			0
+#define TODC_TYPE_DS17285_NVRAM_ADDR_REG	0x50
+#define TODC_TYPE_DS17285_NVRAM_DATA_REG	0x53
+ 
+#define	TODC_TYPE_MC146818_NVRAM_SIZE		0	/* XXXX */
+#define	TODC_TYPE_MC146818_SW_FLAGS		0
 #define	TODC_TYPE_MC146818_YEAR			0x09
 #define	TODC_TYPE_MC146818_MONTH		0x08
 #define	TODC_TYPE_MC146818_DOM			0x07	/* Day of Month */
@@ -298,7 +383,11 @@
 #define	TODC_TYPE_MC146818_ALARM_SECONDS	0x01
 #define	TODC_TYPE_MC146818_CENTURY		0xff
 #define	TODC_TYPE_MC146818_FLAGS		0xff
-
+#define	TODC_TYPE_MC146818_NVRAM_ADDR_REG	0
+#define	TODC_TYPE_MC146818_NVRAM_DATA_REG	0
+  
+#define	TODC_TYPE_PC97307_NVRAM_SIZE		0	/* No NVRAM? */
+#define	TODC_TYPE_PC97307_SW_FLAGS		0
 #define	TODC_TYPE_PC97307_YEAR			0x09
 #define	TODC_TYPE_PC97307_MONTH			0x08
 #define	TODC_TYPE_PC97307_DOM			0x07	/* Day of Month */
@@ -316,6 +405,8 @@
 #define	TODC_TYPE_PC97307_ALARM_SECONDS		0x01
 #define	TODC_TYPE_PC97307_CENTURY		0xff
 #define	TODC_TYPE_PC97307_FLAGS			0xff
+#define	TODC_TYPE_PC97307_NVRAM_ADDR_REG	0
+#define	TODC_TYPE_PC97307_NVRAM_DATA_REG	0
 
 /*
  * Define macros to allocate and init the todc_info_t table that will
@@ -328,29 +419,35 @@
 #define	TODC_INIT(clock_type, as0, as1, data, bits) {			\
 	todc_info->rtc_type = clock_type;				\
 									\
-	todc_info->nvram_as0  = (unsigned char *)(as0);			\
-	todc_info->nvram_as1  = (unsigned char *)(as1);			\
-	todc_info->nvram_data = (unsigned char *)(data);			\
+	todc_info->nvram_as0  = (unsigned int)(as0);			\
+	todc_info->nvram_as1  = (unsigned int)(as1);			\
+	todc_info->nvram_data = (unsigned int)(data);			\
 									\
 	todc_info->as0_bits = (bits);					\
 									\
-	todc_info->year          = clock_type ##_YEAR;			\
-	todc_info->month         = clock_type ##_MONTH;			\
-	todc_info->day_of_month  = clock_type ##_DOM;			\
-	todc_info->day_of_week   = clock_type ##_DOW;			\
-	todc_info->hours         = clock_type ##_HOURS;			\
-	todc_info->minutes       = clock_type ##_MINUTES;		\
-	todc_info->seconds       = clock_type ##_SECONDS;		\
-	todc_info->control_b     = clock_type ##_CNTL_B;		\
-	todc_info->control_a     = clock_type ##_CNTL_A;		\
-	todc_info->watchdog      = clock_type ##_WATCHDOG;		\
-	todc_info->interrupts    = clock_type ##_INTERRUPTS;		\
-	todc_info->alarm_date    = clock_type ##_ALARM_DATE;		\
-	todc_info->alarm_hour    = clock_type ##_ALARM_HOUR;		\
-	todc_info->alarm_minutes = clock_type ##_ALARM_MINUTES;		\
-	todc_info->alarm_seconds = clock_type ##_ALARM_SECONDS;		\
-	todc_info->century       = clock_type ##_CENTURY;		\
-	todc_info->flags         = clock_type ##_FLAGS;			\
+	todc_info->nvram_size     = clock_type ##_NVRAM_SIZE;		\
+	todc_info->sw_flags       = clock_type ##_SW_FLAGS;		\
+									\
+	todc_info->year           = clock_type ##_YEAR;			\
+	todc_info->month          = clock_type ##_MONTH;		\
+	todc_info->day_of_month   = clock_type ##_DOM;			\
+	todc_info->day_of_week    = clock_type ##_DOW;			\
+	todc_info->hours          = clock_type ##_HOURS;		\
+	todc_info->minutes        = clock_type ##_MINUTES;		\
+	todc_info->seconds        = clock_type ##_SECONDS;		\
+	todc_info->control_b      = clock_type ##_CNTL_B;		\
+	todc_info->control_a      = clock_type ##_CNTL_A;		\
+	todc_info->watchdog       = clock_type ##_WATCHDOG;		\
+	todc_info->interrupts     = clock_type ##_INTERRUPTS;		\
+	todc_info->alarm_date     = clock_type ##_ALARM_DATE;		\
+	todc_info->alarm_hour     = clock_type ##_ALARM_HOUR;		\
+	todc_info->alarm_minutes  = clock_type ##_ALARM_MINUTES;	\
+	todc_info->alarm_seconds  = clock_type ##_ALARM_SECONDS;	\
+	todc_info->century        = clock_type ##_CENTURY;		\
+	todc_info->flags          = clock_type ##_FLAGS;		\
+									\
+	todc_info->nvram_addr_reg = clock_type ##_NVRAM_ADDR_REG;	\
+	todc_info->nvram_data_reg = clock_type ##_NVRAM_DATA_REG;	\
 }
 
 extern todc_info_t *todc_info;
