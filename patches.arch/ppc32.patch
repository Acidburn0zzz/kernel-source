diff -p -purN linux-2.5/arch/ppc/boot/simple/Makefile linuxppc-2.5/arch/ppc/boot/simple/Makefile
--- linux-2.5/arch/ppc/boot/simple/Makefile	2003-09-15 10:01:24.000000000 +0200
+++ linuxppc-2.5/arch/ppc/boot/simple/Makefile	2003-09-15 10:52:02.000000000 +0200
@@ -44,6 +44,12 @@ zimageinitrd-$(CONFIG_IBM_OPENBIOS)	:= z
    tftpimage-$(CONFIG_IBM_OPENBIOS)	:= /tftpboot/zImage.$(end-y)
         misc-$(CONFIG_IBM_OPENBIOS)	:= misc-embedded.o
 
+      zimage-$(CONFIG_IBM_PIBS)		:= zImage-TREE
+zimageinitrd-$(CONFIG_IBM_PIBS)		:= zImage.initrd-TREE
+         end-$(CONFIG_IBM_PIBS)		:= treeboot
+   tftpimage-$(CONFIG_IBM_PIBS)		:= /tftpboot/zImage.$(end-y)
+        misc-$(CONFIG_IBM_PIBS)		:= misc-embedded.o
+
    tftpimage-$(CONFIG_EMBEDDEDBOOT)	:=  /tftpboot/zImage.embedded
         misc-$(CONFIG_EMBEDDEDBOOT)	:= misc-embedded.o
 
@@ -59,7 +65,7 @@ zimageinitrd-$(CONFIG_OCOTEA)		:= zImage
   entrypoint-$(CONFIG_OCOTEA)		:= 0x01000000
    tftpimage-$(CONFIG_OCOTEA)		:= /tftpboot/zImage.$(end-y)
 
-     extra.o-$(CONFIG_EV64260)		:= direct.o misc-ev64260.o
+     extra.o-$(CONFIG_EV64260)		:= misc-ev64260.o
    tftpimage-$(CONFIG_EV64260)		:= /tftpboot/zImage.ev64260
    cacheflag-$(CONFIG_EV64260)		:= -include $(clear_L2_L3)
 
diff -p -purN linux-2.5/arch/ppc/boot/simple/embed_config.c linuxppc-2.5/arch/ppc/boot/simple/embed_config.c
--- linux-2.5/arch/ppc/boot/simple/embed_config.c	2003-08-21 19:17:00.000000000 +0200
+++ linuxppc-2.5/arch/ppc/boot/simple/embed_config.c	2003-08-21 19:57:59.000000000 +0200
@@ -657,6 +657,20 @@ embed_config(bd_t **bdp)
 #endif /* WILLOW */
 
 #ifdef CONFIG_XILINX_ML300
+/* SAATODO: Remove this when CONFIG_XILINX_ML300_MACADDR is removed. */
+static int
+char2dec(char c)
+{
+	if ('0' <= c && c <= '9')
+		return c - '0';
+	else if ('a' <= c && c <= 'f')
+		return c - 'a' + 10;
+	else if ('A' <= c && c <= 'F')
+		return c - 'A' + 10;
+	else
+		return -1;
+}
+
 void
 embed_config(bd_t ** bdp)
 {
@@ -689,6 +703,36 @@ embed_config(bd_t ** bdp)
 	bd->bi_memsize = XPAR_DDR_0_SIZE;
 	bd->bi_intfreq = XPAR_CORE_CLOCK_FREQ_HZ;
 	bd->bi_busfreq = XPAR_PLB_CLOCK_FREQ_HZ;
+
+	/* SAATODO: Use board's MAC address once that is defined. */
+	if (1) {
+		char MAC_string[] = CONFIG_XILINX_ML300_MACADDR;
+		int good_addr = 1;
+
+		if (sizeof (MAC_string) != 13)
+			good_addr = 0;
+		else {
+			char *s = MAC_string;
+			cp = bd->bi_enetaddr;
+
+			while (s < MAC_string + 12) {
+				int msn, lsn;
+				msn = char2dec(*s++);
+				lsn = char2dec(*s++);
+				if (msn < 0 || lsn < 0) {
+					good_addr = 0;
+					break;
+				}
+				*cp++ = msn << 4 | lsn;
+			}
+		}
+		if (!good_addr) {
+			cp = (u_char *) def_enet_addr;
+			for (i = 0; i < 6; i++) {
+				bd->bi_enetaddr[i] = *cp++;
+			}
+		}
+	}
 }
 #endif /* CONFIG_XILINX_ML300 */
 
@@ -774,6 +818,52 @@ embed_config(bd_t **bdp)
 #endif /* CONFIG_BEECH */
 #endif /* CONFIG_IBM_OPENBIOS */
 
+#ifdef CONFIG_ARCTIC2
+/* Several bootloaders have been used on the Arctic.  We assume either
+ * SSX or PIBS */
+
+#define SSX_BIOS_ADDR 		0xFFFF0000
+#define SSX_BIOS_GET_BOARD_INFO 0
+#define	PIBS_BOARD_INFO_VECTOR	0xFFF62004
+
+struct ssx_bios_id {
+	unsigned int boot_branch;	/* Branch to bootcode */
+	char ssx_bios[8];		/* "SSX BIOS" (no \0) */
+	void (*bios_entry_point)(unsigned int, bd_t *); /* Call bios_entry_point(cmd, &data) */
+};
+
+extern int memcmp(const void *s1, const void *s2, size_t n);
+
+static void get_board_info(bd_t **bdp)
+{
+	struct ssx_bios_id *ssx = (struct ssx_bios_id *)SSX_BIOS_ADDR;
+
+	/* Check for SSX signature */
+
+	if (memcmp(&ssx->ssx_bios, "SSX BIOS", 8) == 0) {
+		ssx->bios_entry_point(SSX_BIOS_GET_BOARD_INFO, *bdp);
+	} else {
+		/* It's not SSX, so assume PIBS */
+		typedef void (*PFV)(bd_t *bd);
+		((PFV)(*(unsigned long *)PIBS_BOARD_INFO_VECTOR))(*bdp);
+	}
+}
+
+void embed_config(bd_t **bdp)
+{
+        *bdp = &bdinfo;
+	get_board_info(bdp);
+#if 0
+	/* Enable RefClk/4 mode for both UARTs */
+	mtdcr(DCRN_CPC0_CR0, mfdcr(DCRN_CPC0_CR0) | 0x30000000);
+#endif
+#if 0
+	timebase_period_ns = 1000000000 / bdinfo.bi_tbfreq;
+#endif
+}
+
+#endif
+
 #ifdef CONFIG_EP405
 #include <linux/serial_reg.h>
 
diff -p -purN linux-2.5/arch/ppc/configs/ebony_defconfig linuxppc-2.5/arch/ppc/configs/ebony_defconfig
--- linux-2.5/arch/ppc/configs/ebony_defconfig	2003-10-06 14:04:59.000000000 +0200
+++ linuxppc-2.5/arch/ppc/configs/ebony_defconfig	2003-10-06 14:33:36.000000000 +0200
@@ -12,7 +12,7 @@ CONFIG_PPC32=y
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
-# CONFIG_STANDALONE is not set
+CONFIG_STANDALONE=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
@@ -24,7 +24,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_IKCONFIG is not set
-# CONFIG_EMBEDDED is not set
+CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
@@ -65,7 +65,10 @@ CONFIG_440=y
 CONFIG_PIN_TLB=y
 CONFIG_BOOKE=y
 CONFIG_IBM_OCP=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_OCP=y
 # CONFIG_PM is not set
+CONFIG_GEN550_KGDB=y
 CONFIG_NOT_COHERENT_CACHE=y
 
 #
@@ -126,6 +129,7 @@ CONFIG_BOOT_LOAD=0x01000000
 #
 # Block devices
 #
+# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -256,6 +260,16 @@ CONFIG_NETDEVICES=y
 # Ethernet (10 or 100Mbit)
 #
 # CONFIG_NET_ETHERNET is not set
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+CONFIG_IBM_OCP_MAL_CNT=1
+CONFIG_IBM_OCP_ZMII=y
+CONFIG_CRC32=y
 
 #
 # Ethernet (1000 Mbit)
@@ -308,11 +322,6 @@ CONFIG_NETDEVICES=y
 # CONFIG_IRDA is not set
 
 #
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
 # ISDN subsystem
 #
 # CONFIG_ISDN_BOOL is not set
@@ -323,48 +332,25 @@ CONFIG_NETDEVICES=y
 # CONFIG_FB is not set
 
 #
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-# CONFIG_MDA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-
-#
 # Input device support
 #
-CONFIG_INPUT=y
+# CONFIG_INPUT is not set
 
 #
 # Userland interfaces
 #
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_EVBUG is not set
 
 #
 # Input I/O drivers
 #
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
+# CONFIG_SERIO is not set
 # CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
 
 #
 # Input Device Drivers
 #
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
 
 #
 # Macintosh device drivers
@@ -373,9 +359,7 @@ CONFIG_SERIO=y
 #
 # Character devices
 #
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
+# CONFIG_VT is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
@@ -383,7 +367,6 @@ CONFIG_HW_CONSOLE=y
 #
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
 CONFIG_SERIAL_8250_EXTENDED=y
 CONFIG_SERIAL_8250_MANY_PORTS=y
 CONFIG_SERIAL_8250_SHARE_IRQ=y
@@ -405,10 +388,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_I2C is not set
 
 #
-# I2C Algorithms
-#
-
-#
 # I2C Hardware Bus support
 #
 
@@ -437,6 +416,7 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
+# CONFIG_IBM_GPIO is not set
 
 #
 # Ftape, the floppy tape device driver
@@ -492,6 +472,7 @@ CONFIG_PROC_KCORE=y
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
 
@@ -548,9 +529,13 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_USB_GADGET is not set
 
 #
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
 # Library routines
 #
-CONFIG_CRC32=y
 
 #
 # Kernel hacking
@@ -565,7 +550,6 @@ CONFIG_DEBUG_KERNEL=y
 CONFIG_BDI_SWITCH=y
 # CONFIG_DEBUG_INFO is not set
 # CONFIG_SERIAL_TEXT_DEBUG is not set
-CONFIG_OCP=y
 
 #
 # Security options
diff -p -purN linux-2.5/arch/ppc/configs/ocotea_defconfig linuxppc-2.5/arch/ppc/configs/ocotea_defconfig
--- linux-2.5/arch/ppc/configs/ocotea_defconfig	2003-10-06 14:04:59.000000000 +0200
+++ linuxppc-2.5/arch/ppc/configs/ocotea_defconfig	2003-10-06 14:33:36.000000000 +0200
@@ -12,7 +12,7 @@ CONFIG_PPC32=y
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
-# CONFIG_STANDALONE is not set
+CONFIG_STANDALONE=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
@@ -24,7 +24,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_IKCONFIG is not set
-# CONFIG_EMBEDDED is not set
+CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
@@ -67,6 +67,8 @@ CONFIG_PIN_TLB=y
 CONFIG_BOOKE=y
 CONFIG_IBM_OCP=y
 CONFIG_IBM_EMAC4=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_OCP=y
 # CONFIG_PM is not set
 CONFIG_NOT_COHERENT_CACHE=y
 
@@ -128,6 +130,7 @@ CONFIG_BOOT_LOAD=0x01000000
 #
 # Block devices
 #
+# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -257,19 +260,17 @@ CONFIG_NETDEVICES=y
 #
 # Ethernet (10 or 100Mbit)
 #
-CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
-# CONFIG_OAKNET is not set
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
-
-#
-# Tulip family network device support
-#
-# CONFIG_NET_TULIP is not set
-# CONFIG_HP100 is not set
-# CONFIG_NET_PCI is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+CONFIG_IBM_OCP_MAL_CNT=1
+CONFIG_IBM_OCP_ZMII=y
+CONFIG_CRC32=y
 
 #
 # Ethernet (1000 Mbit)
@@ -322,11 +323,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_IRDA is not set
 
 #
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
 # ISDN subsystem
 #
 # CONFIG_ISDN_BOOL is not set
@@ -337,13 +333,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_FB is not set
 
 #
-# Console display driver support
-#
-CONFIG_VGA_CONSOLE=y
-# CONFIG_MDA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-
-#
 # Input device support
 #
 CONFIG_INPUT=y
@@ -366,8 +355,8 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
 
@@ -387,9 +376,7 @@ CONFIG_SERIO=y
 #
 # Character devices
 #
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
+# CONFIG_VT is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
@@ -397,7 +384,6 @@ CONFIG_HW_CONSOLE=y
 #
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
 CONFIG_SERIAL_8250_EXTENDED=y
 CONFIG_SERIAL_8250_MANY_PORTS=y
 CONFIG_SERIAL_8250_SHARE_IRQ=y
@@ -419,10 +405,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_I2C is not set
 
 #
-# I2C Algorithms
-#
-
-#
 # I2C Hardware Bus support
 #
 
@@ -451,6 +433,7 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
+# CONFIG_IBM_GPIO is not set
 
 #
 # Ftape, the floppy tape device driver
@@ -506,6 +489,7 @@ CONFIG_PROC_KCORE=y
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
 
@@ -562,9 +546,13 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_USB_GADGET is not set
 
 #
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
 # Library routines
 #
-CONFIG_CRC32=y
 
 #
 # Kernel hacking
@@ -579,7 +567,6 @@ CONFIG_DEBUG_KERNEL=y
 CONFIG_BDI_SWITCH=y
 CONFIG_DEBUG_INFO=y
 # CONFIG_SERIAL_TEXT_DEBUG is not set
-CONFIG_OCP=y
 
 #
 # Security options
diff -p -purN linux-2.5/arch/ppc/configs/sandpoint_defconfig linuxppc-2.5/arch/ppc/configs/sandpoint_defconfig
--- linux-2.5/arch/ppc/configs/sandpoint_defconfig	2003-07-03 02:44:13.000000000 +0200
+++ linuxppc-2.5/arch/ppc/configs/sandpoint_defconfig	2003-07-03 03:57:38.000000000 +0200
@@ -455,6 +455,7 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_PS2_SYNAPTICS is not set
 # CONFIG_MOUSE_SERIAL is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
diff -p -purN linux-2.5/arch/ppc/kernel/ocp.c linuxppc-2.5/arch/ppc/kernel/ocp.c
--- linux-2.5/arch/ppc/kernel/ocp.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/kernel/ocp.c	2003-01-06 10:11:42.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ * ocp.c
+ *
+ *	The is drived from pci.c
+ *
+ * 	Current Maintainer
+ *      Armin Kuster akuster@pacbell.net
+ *      Jan, 2002
+ *
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <asm/ocp.h>
+
+
+static int __init
+ocparch_init(void)
+{
+	struct ocp_bus *bus;
+	int next_hostno, max_hostno;
+
+	printk(KERN_INFO "OCP: Probing OCP hardware\n");
+	max_hostno = 1;
+	/* Scan all of the recorded OCP controllers.  */
+	for (next_hostno = 0;next_hostno < max_hostno; next_hostno++) {
+		bus = ocp_scan_bus(next_hostno, NULL);
+	}
+	return 0;
+}
+
+subsys_initcall(ocparch_init);
+
diff -p -purN linux-2.5/arch/ppc/kernel/pci.c linuxppc-2.5/arch/ppc/kernel/pci.c
--- linux-2.5/arch/ppc/kernel/pci.c	2003-09-12 18:26:52.000000000 +0200
+++ linuxppc-2.5/arch/ppc/kernel/pci.c	2003-09-12 19:39:39.000000000 +0200
@@ -179,7 +179,8 @@ pcibios_fixup_cardbus(struct pci_dev* de
 	}
 	if (dev->device == PCI_DEVICE_ID_TI_1210 ||
 	    dev->device == PCI_DEVICE_ID_TI_1211 ||
-	    dev->device == PCI_DEVICE_ID_TI_1410) {
+	    dev->device == PCI_DEVICE_ID_TI_1410 ||
+	    dev->device == PCI_DEVICE_ID_TI_1510) {
 		u8 val;
 		/* 0x8c == TI122X_IRQMUX, 2 says to route the INTA
 		   signal out the MFUNC0 pin */
diff -p -purN linux-2.5/arch/ppc/kernel/ppc_ksyms.c linuxppc-2.5/arch/ppc/kernel/ppc_ksyms.c
--- linux-2.5/arch/ppc/kernel/ppc_ksyms.c	2003-10-11 15:53:42.000000000 +0200
+++ linuxppc-2.5/arch/ppc/kernel/ppc_ksyms.c	2003-10-14 13:33:50.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/irq.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
+#include <linux/vmalloc.h>
 #include <linux/ide.h>
 #include <linux/pm.h>
 
@@ -380,6 +381,10 @@ EXPORT_SYMBOL(intercept_table);
 #endif /* CONFIG_PPC_STD_MMU */
 EXPORT_SYMBOL(cur_cpu_spec);
 #ifdef CONFIG_PPC_PMAC
+extern int map_page(unsigned long va, unsigned long pa, int flags);
+
+EXPORT_SYMBOL(map_page);
+EXPORT_SYMBOL(get_vm_area);
 extern unsigned long agp_special_page;
 EXPORT_SYMBOL_NOVERS(agp_special_page);
 #endif
diff -p -purN linux-2.5/arch/ppc/kernel/vmlinux.lds.S linuxppc-2.5/arch/ppc/kernel/vmlinux.lds.S
--- linux-2.5/arch/ppc/kernel/vmlinux.lds.S	2003-09-12 18:26:52.000000000 +0200
+++ linuxppc-2.5/arch/ppc/kernel/vmlinux.lds.S	2003-10-14 13:42:20.000000000 +0200
@@ -47,13 +47,17 @@ SECTIONS
 
   .fixup   : { *(.fixup) }
 
-  __start___ex_table = .;
-  __ex_table : { *(__ex_table) }
-  __stop___ex_table = .;
-
-  __start___bug_table = .;
-  __bug_table : { *(__bug_table) }
-  __stop___bug_table = .;
+	__ex_table : {
+		__start___ex_table = .;
+		*(__ex_table)
+		__stop___ex_table = .;
+	}
+
+	__bug_table : {
+		__start___bug_table = .;
+		*(__bug_table)
+		__stop___bug_table = .;
+	}
 
   /* Read-write section, merged into data segment: */
   . = ALIGN(4096);
diff -p -purN linux-2.5/arch/ppc/ocp/ocp-hotplug.c linuxppc-2.5/arch/ppc/ocp/ocp-hotplug.c
--- linux-2.5/arch/ppc/ocp/ocp-hotplug.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/ocp/ocp-hotplug.c	2003-01-10 06:30:56.000000000 +0100
@@ -0,0 +1,99 @@
+#include <asm/ocp.h>
+#include <linux/module.h>
+#include <linux/kmod.h>		/* for hotplug_path */
+
+#ifndef FALSE
+#define FALSE	(0)
+#define TRUE	(!FALSE)
+#endif
+
+static void
+run_sbin_hotplug(struct ocp_device *pdev, int insert)
+{
+	int i;
+	char *argv[3], *envp[8];
+	char id[20], sub_id[24], bus_id[24], class_id[20];
+
+	if (!hotplug_path[0])
+		return;
+#if 0
+	sprintf(class_id, "PCI_CLASS=%04X", pdev->class);
+	sprintf(id, "PCI_ID=%04X:%04X", pdev->vendor, pdev->device);
+	sprintf(sub_id, "PCI_SUBSYS_ID=%04X:%04X", pdev->subsystem_vendor, pdev->subsystem_device);
+	sprintf(bus_id, "PCI_SLOT_NAME=%s", pdev->slot_name);
+#endif
+	i = 0;
+	argv[i++] = hotplug_path;
+	argv[i++] = "ocp";
+	argv[i] = 0;
+
+	i = 0;
+	/* minimal command environment */
+	envp[i++] = "HOME=/";
+	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	
+	/* other stuff we want to pass to /sbin/hotplug */
+	envp[i++] = class_id;
+	envp[i++] = id;
+	envp[i++] = sub_id;
+	envp[i++] = bus_id;
+	if (insert)
+		envp[i++] = "ACTION=add";
+	else
+		envp[i++] = "ACTION=remove";
+	envp[i] = 0;
+
+	call_usermodehelper (argv [0], argv, envp);
+}
+
+/**
+ * ocp_insert_device - insert a hotplug device
+ * @dev: the device to insert
+ * @bus: where to insert it
+ *
+ * Add a new device to the device lists and notify userspace (/sbin/hotplug).
+ */
+void
+ocp_insert_device(struct ocp_device *dev, struct ocp_bus *bus)
+{
+	list_add_tail(&dev->bus_list, &bus->devices);
+	list_add_tail(&dev->global_list, &ocp_devices);
+	/* notify userspace of new hotplug device */
+	run_sbin_hotplug(dev, TRUE);
+}
+
+#if 0
+static void
+ocp_free_resources(struct ocp_device *dev)
+{
+	int i;
+
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		struct resource *res = dev->resource + i;
+		if (res->parent)
+			release_resource(res);
+	}
+}
+#endif
+
+/**
+ * ocp_remove_device - remove a hotplug device
+ * @dev: the device to remove
+ *
+ * Delete the device structure from the device lists and 
+ * notify userspace (/sbin/hotplug).
+ */
+void
+ocp_remove_device(struct ocp_device *dev)
+{
+	put_device(&dev->dev);
+	list_del(&dev->bus_list);
+	list_del(&dev->global_list);
+//	ocp_free_resources(dev);
+
+	/* notify userspace of hotplug device removal */
+	run_sbin_hotplug(dev, FALSE);
+}
+
+EXPORT_SYMBOL(ocp_insert_device);
+EXPORT_SYMBOL(ocp_remove_device);
diff -p -purN linux-2.5/arch/ppc/ocp/ocp-power.c linuxppc-2.5/arch/ppc/ocp/ocp-power.c
--- linux-2.5/arch/ppc/ocp/ocp-power.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/ocp/ocp-power.c	2003-01-10 06:30:56.000000000 +0100
@@ -0,0 +1,195 @@
+/*
+ * FILE NAME: ocp-power.c
+ *
+ * BRIEF MODULE DESCRIPTION: 
+ * Based on drivers/pci/power, Copyright (c) 1997--1999 Martin Mares
+ *
+ * Maintained by: Armin <akuster@mvista.com>
+ *
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <asm/ocp.h>
+#include <linux/pm.h>
+#include <linux/init.h>
+
+/*
+ * OCP Power management..
+ *
+ * This needs to be done centralized, so that we power manage OCP
+ * devices in the right order: we should not shut down OCP bridges
+ * before we've shut down the devices behind them, and we should
+ * not wake up devices before we've woken up the bridge to the
+ * device.
+ *
+ * We do not touch devices that don't have a driver that exports
+ * a suspend/resume function. That is just too dangerous. If the default
+ * OCP suspend/resume functions work for a device, the driver can
+ * easily implement them (ie just have a suspend function that calls
+ * the ocp_set_power_state() function).
+ */
+
+static int ocp_pm_save_state_device(struct ocp_device *dev, u32 state)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_driver *driver = dev->driver;
+		if (driver && driver->save_state) 
+			error = driver->save_state(dev,state);
+	}
+	return error;
+}
+
+static int ocp_pm_suspend_device(struct ocp_device *dev, u32 state)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_driver *driver = dev->driver;
+		if (driver && driver->suspend)
+			error = driver->suspend(dev,state);
+	}
+	return error;
+}
+
+static int ocp_pm_resume_device(struct ocp_device *dev)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_driver *driver = dev->driver;
+		if (driver && driver->resume)
+			error = driver->resume(dev);
+	}
+	return error;
+}
+
+static int ocp_pm_save_state_bus(struct ocp_bus *bus, u32 state)
+{
+	struct list_head *list;
+	int error = 0;
+
+	list_for_each(list, &bus->children) {
+		error = ocp_pm_save_state_bus(ocp_bus_b(list),state);
+		if (error) return error;
+	}
+	list_for_each(list, &bus->devices) {
+		error = ocp_pm_save_state_device(ocp_dev_b(list),state);
+		if (error) return error;
+	}
+	return 0;
+}
+
+static int ocp_pm_suspend_bus(struct ocp_bus *bus, u32 state)
+{
+	struct list_head *list;
+
+	/* Walk the bus children list */
+	list_for_each(list, &bus->children) 
+		ocp_pm_suspend_bus(ocp_bus_b(list),state);
+
+	/* Walk the device children list */
+	list_for_each(list, &bus->devices)
+		ocp_pm_suspend_device(ocp_dev_b(list),state);
+	return 0;
+}
+
+static int ocp_pm_resume_bus(struct ocp_bus *bus)
+{
+	struct list_head *list;
+
+	/* Walk the device children list */
+	list_for_each(list, &bus->devices)
+		ocp_pm_resume_device(ocp_dev_b(list));
+
+	/* And then walk the bus children */
+	list_for_each(list, &bus->children)
+		ocp_pm_resume_bus(ocp_bus_b(list));
+	return 0;
+}
+
+static int ocp_pm_save_state(u32 state)
+{
+	struct list_head *list;
+	struct ocp_bus *bus;
+	int error = 0;
+
+	list_for_each(list, &ocp_root_buses) {
+		bus = ocp_bus_b(list);
+		error = ocp_pm_save_state_bus(bus,state);
+		if (!error)
+			error = ocp_pm_save_state_device(bus->self,state);
+	}
+	return error;
+}
+
+static int ocp_pm_suspend(u32 state)
+{
+	struct list_head *list;
+	struct ocp_bus *bus;
+
+	list_for_each(list, &ocp_root_buses) {
+		bus = ocp_bus_b(list);
+		ocp_pm_suspend_bus(bus,state);
+		ocp_pm_suspend_device(bus->self,state);
+	}
+	return 0;
+}
+
+static int ocp_pm_resume(void)
+{
+	struct list_head *list;
+	struct ocp_bus *bus;
+
+	list_for_each(list, &ocp_root_buses) {
+		bus = ocp_bus_b(list);
+		ocp_pm_resume_device(bus->self);
+		ocp_pm_resume_bus(bus);
+	}
+	return 0;
+}
+
+static int 
+ocp_pm_callback(struct pm_dev *pm_device, pm_request_t rqst, void *data)
+{
+	int error = 0;
+
+	switch (rqst) {
+	case PM_SAVE_STATE:
+		error = ocp_pm_save_state((unsigned long)data);
+		break;
+	case PM_SUSPEND:
+		error = ocp_pm_suspend((unsigned long)data);
+		break;
+	case PM_RESUME:
+		error = ocp_pm_resume();
+		break;
+	default: break;
+	}
+	return error;
+}
+
+static int __init ocp_pm_init(void)
+{
+	pm_register(PM_OCP_DEV, 0, ocp_pm_callback);
+	return 0;
+}
+
+subsys_initcall(ocp_pm_init);
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/Kconfig linuxppc-2.5/arch/ppc/platforms/4xx/Kconfig
--- linux-2.5/arch/ppc/platforms/4xx/Kconfig	2003-09-17 18:03:24.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/Kconfig	2003-09-26 18:56:20.000000000 +0200
@@ -11,6 +11,9 @@ choice
 	depends on 40x
 	default WALNUT
 
+config ARCTIC2
+	bool "Arctic II"
+
 config ASH
 	bool "Ash"
 
@@ -36,6 +39,9 @@ config OAK
 	  More information on these boards is available at:
 	  <http://www.chips.ibm.com/products/powerpc/tools/evk_pn.html#GCX>.
 
+config RAINIER
+	bool "Rainier"
+
 config REDWOOD_4
 	bool "Redwood-4"
 
@@ -133,7 +139,7 @@ config BOOKE
 
 config IBM_OCP
 	bool
-	depends on ASH || BEECH || CEDAR || CPCI405 || EBONY || EP405 || OCOTEA || REDWOOD_4 || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+	depends on ARCTIC || ASH || BEECH || CEDAR || CPCI405 || EBONY || EP405 || OCOTEA || REDWOOD_4 || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
 config IBM_EMAC4
@@ -167,7 +173,8 @@ config 405GPR
 
 config 405LP
 	bool
-	depends on CEDAR
+	depends on ARCTIC2 || BEECH
+	default y
 
 config STB03xxx
 	bool
@@ -176,7 +183,7 @@ config STB03xxx
 
 config EMBEDDEDBOOT
 	bool
-	depends on EP405
+	depends on EP405 || RAINIER
 	default y
 
 config IBM_OPENBIOS
@@ -184,6 +191,30 @@ config IBM_OPENBIOS
 	depends on ASH || BEECH || CEDAR || REDWOOD_4 || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
+config IBM_PIBS
+	bool
+	depends on ARCTIC2
+	default y
+
+config PPC4xx_DMA
+	bool "PPC4xx DMA controller support"
+	depends on 4xx
+
+config STBXXX_DMA
+	bool
+	depends on STB03xxx && PPC4xx_DMA
+	default y
+
+config PPC4xx_EDMA
+	bool
+	depends on !STB03xxx && PPC4xx_DMA
+	default y
+
+config OCP
+	bool
+	depends on IBM_OCP
+	default y
+
 config 405_DMA
 	bool "Blue Logic DMA"
 	depends on 40x
@@ -205,6 +236,11 @@ config UART0_TTYS1
 
 endchoice
 
+config GEN550_KGDB
+	bool
+	depends on EBONY
+	default y
+
 config SERIAL_SICC
 	bool "SICC Serial port support"
 	depends on STB03xxx
@@ -218,4 +254,10 @@ config SERIAL_SICC_CONSOLE
 	bool
 	depends on SERIAL_SICC && UART0_TTYS1
 	default y
+
+config 405LP_PM_BUTTON
+	bool
+	depends on 405LP
+	default y
+
 endmenu
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/Makefile linuxppc-2.5/arch/ppc/platforms/4xx/Makefile
--- linux-2.5/arch/ppc/platforms/4xx/Makefile	2003-09-12 18:26:53.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/Makefile	2003-09-12 19:39:40.000000000 +0200
@@ -1,6 +1,7 @@
 #
 # Makefile for the PowerPC 4xx linux kernel.
 
+obj-$(CONFIG_ARCTIC2)		+= arctic2.o subzero.o
 obj-$(CONFIG_ASH)		+= ash.o
 obj-$(CONFIG_BEECH)		+= beech.o
 obj-$(CONFIG_CEDAR)		+= cedar.o
@@ -9,6 +10,7 @@ obj-$(CONFIG_EBONY)		+= ebony.o
 obj-$(CONFIG_EP405)		+= ep405.o
 obj-$(CONFIG_OAK)		+= oak.o
 obj-$(CONFIG_OCOTEA)		+= ocotea.o
+obj-$(CONFIG_RAINIER)		+= rainier.o 
 obj-$(CONFIG_REDWOOD_4)		+= redwood.o
 obj-$(CONFIG_REDWOOD_5)		+= redwood5.o
 obj-$(CONFIG_REDWOOD_6)		+= redwood6.o
@@ -26,3 +28,4 @@ obj-$(CONFIG_405LP)		+= ibm405lp.o
 obj-$(CONFIG_EBONY)		+= ibm440gp.o
 obj-$(CONFIG_OCOTEA)		+= ibm440gx.o
 obj-$(CONFIG_405GPR)		+= ibm405gpr.o
+obj-$(CONFIG_VIRTEX_II_PRO)	+= virtex-ii_pro.o
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/arctic2.c linuxppc-2.5/arch/ppc/platforms/4xx/arctic2.c
--- linux-2.5/arch/ppc/platforms/4xx/arctic2.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/arctic2.c	2003-06-13 00:26:52.000000000 +0200
@@ -0,0 +1,236 @@
+/*
+ * arch/ppc/platforms/arctic2.c  Platform setup for the IBM Arctic-2 reference platform
+ *					with the Subzero core card and Beech personality card
+ * 				      Based on beech.c by Bishop Brock 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * Ken Inoue 
+ * IBM Thomas J. Watson Research Center
+ * keninoue@us.ibm.com
+ *
+ * David Gibson
+ * IBM Ozlabs, Canberra, Australia
+ * arctic@gibson.dropbear.id.au
+ */
+
+#include <linux/blk.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/rtc.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+#include <platforms/4xx/arctic2.h>
+
+/* Virtual address of the PCCF macro, which needs to be ioremap()ed
+ * and initialized by the board setup code. */
+volatile u16 *pccf_4xx_macro_vaddr;
+unsigned long pccf_4xx_io_base;
+unsigned long pccf_4xx_mem_base;
+EXPORT_SYMBOL(pccf_4xx_macro_vaddr);
+EXPORT_SYMBOL(pccf_4xx_io_base);
+EXPORT_SYMBOL(pccf_4xx_mem_base);
+
+volatile u8 *arctic2_fpga_regs;
+EXPORT_SYMBOL(arctic2_fpga_regs);
+
+/* Different Arctic2 versions have different capabilities in terms of dynamic
+   and static power control.  Older units do not support the APM peripheral or
+   voltage scaling. The unit's capabilities are determined at boot and recorded
+   in these variables.  Run-time rather than compile-time control is used to
+   simplify kernel distribution. */
+
+int arctic2_supports_apm = 0;
+int arctic2_supports_dvs = 0;
+
+#define GPIO0_OR 	((u32 *)(GPIO0_BASE + 0))
+#define GPIO0_TCR	((u32 *)(GPIO0_BASE + 4))
+#define GPIO0_ODR	((u32 *)(GPIO0_BASE + 8))
+#define GPIO0_IR	((u32 *)(GPIO0_BASE + 12))
+
+void __init
+board_setup_irq(void)
+{
+	ibm405lp_setup_apm_pic();
+
+	/*
+	 * Set USB interrupt edge-triggered polarity=rising edge.
+	 */
+
+	mtdcr(DCRN_UIC0_TR, mfdcr(DCRN_UIC0_TR) | (1 << (31 - UIC_IRQ_EIR0)));
+	mtdcr(DCRN_UIC0_PR, mfdcr(DCRN_UIC0_PR) | (1 << (31 - UIC_IRQ_EIR0)));
+}
+
+void
+arctic2_poweroff(void)
+{
+	if (! arctic2_fpga_regs)
+		BUG();
+
+	cli();
+
+	writeb(1, ARCTIC2_FPGA_POWERDOWN);
+	eieio();
+
+	while (1)
+		;
+}
+
+void
+arctic2_set_lcdpower(int on)
+{
+	iobarrier_rw(); 
+	if (on)
+		out_be32(GPIO0_TCR, in_be32(GPIO0_TCR) | 0x80000000 );
+	else
+		out_be32(GPIO0_TCR, in_be32(GPIO0_TCR) & ~0x80000000);
+	iobarrier_rw(); 
+	udelay(100); /* KI guard time */
+}
+
+EXPORT_SYMBOL(arctic2_poweroff);
+EXPORT_SYMBOL(arctic2_set_lcdpower);
+
+/* Units that support APM/DVS pull GPIO3 low as a strap. On older units this
+   GPIO is pulled high. After boot this can be used as a trace/debug signal, as
+   it has no other purpose on the board. */
+
+static void __init
+check_apm_dvs_support(void)
+{
+	u32 gpio3 = 0x10000000;
+
+	iobarrier_rw();
+	out_be32(GPIO0_TCR, in_be32(GPIO0_TCR) & ~gpio3);
+	out_be32(GPIO0_ODR, in_be32(GPIO0_ODR) & ~gpio3);
+	iobarrier_rw();
+	arctic2_supports_apm = ((in_be32(GPIO0_IR) & gpio3) == 0);
+	arctic2_supports_dvs = arctic2_supports_apm;
+}
+
+void __init
+arctic_setup_arch(void)
+{
+	cpc0_cgcr1_t	cgcr1;
+	u32 cfg;
+
+	ppc4xx_setup_arch();
+
+#ifdef CONFIG_GEN_RTC
+	ppc_md.time_init = ibm405lp_time_init;
+	ppc_md.set_rtc_time = ibm405lp_set_rtc_time;
+	ppc_md.get_rtc_time = ibm405lp_get_rtc_time;
+#endif
+	ppc_md.power_off = arctic2_poweroff;
+
+	/* Set up the EBC, then Disable the LCD controller, which may have been
+	   left on by the BIOS. */
+
+	subzero_core_ebc_setup();
+
+	/* Turn on PerClk, so that the SDIO chip works */
+	/* FIXME: This is bad for power usage - this will want to be
+	 * fixed to turn the clock on "on demand" when we merge with
+	 * the DPM code. */
+	cgcr1.reg=mfdcr(DCRN_CPC0_CGCR1);
+	cgcr1.fields.csel=CPC0_CGCR1_CSEL_PERCLK;
+	mtdcr(DCRN_CPC0_CGCR1, cgcr1.reg);
+
+	/* Configure the Arctic-II specific EBC banks */
+
+	/* Bank 1: 16-bit FPGA peripherals (ethernet data, SDIO, USB, DOC)
+	 * 1MB, RW, 16-bit at 0xf9000000-0xf90fffff */
+	/* The access parameters are programmed assuming a 33Mhz EBC
+	   clock, which is true for nearly all the operating points we
+	   have defined:
+	   	BME=0, TWT=5, CSN=0, OEN=1, WBN=1, WBF=1 TH=4
+		RE=1, SOR=0, BEM=0, PEN=0
+	 */
+	mtdcri(DCRN_EBC0, BnAP(1), 0x02815900);
+	mtdcri(DCRN_EBC0, BnCR(1), ARCTIC2_FPGA16_PADDR | 0x1a000);
+
+	/* Bank 2: 8-bit FPGA peripherals (switch/control, ethernet regs, TCPA)
+	 * 1MB, RW, 8-bit at 0xf8000000-0xf80fffff */
+	mtdcri(DCRN_EBC0, BnAP(2), 0x02815580);
+	mtdcri(DCRN_EBC0, BnCR(2), ARCTIC2_FPGA8_PADDR | 0x18000);
+
+	mtdcri(DCRN_LCD0, DER, 0);
+
+	/* Data access of the Arctic2 debug sled ethernet chip will time out
+	   under certain conditions unless the EBC ready wait is extended. The
+	   data sheet doesn't give a bound on this, so we allow a generous
+	   amount of time. Note that this problem is normally masked by the
+	   PCMCIA setup, which sets an even longer timeout. */
+
+	cfg = mfdcri(DCRN_EBC0, CFG);
+	if ((cfg & EBC_CFG_RTC) < EBC_CFG_RTC_128)
+		mtdcri(DCRN_EBC0, CFG, (cfg & ~EBC_CFG_RTC) | EBC_CFG_RTC_128);
+}
+
+
+void __init
+arctic_map_io(void)
+{
+	ppc4xx_map_io();
+	ibm405lp_setup_pccf(&pccf_4xx_macro_vaddr, &pccf_4xx_io_base,
+			    &pccf_4xx_mem_base);
+
+#if 0
+	if (! request_mem_region(ARCTIC2_FPGA8_PADDR,
+				 ARCTIC2_FPGA_REGS_EXTENT,
+				 "Arctic-2 FPGA Control Registers"))
+		BUG(); /* If someone's grabbed these addresses
+			* already, something's seriously wrong */
+#endif
+
+	arctic2_fpga_regs = ioremap(ARCTIC2_FPGA8_PADDR,
+				    ARCTIC2_FPGA_REGS_EXTENT);
+	if (!arctic2_fpga_regs)
+		BUG();
+
+	check_apm_dvs_support();
+	return;
+}
+
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = arctic_setup_arch;
+	ppc_md.setup_io_mappings = arctic_map_io;
+}
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End: */
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/arctic2.h linuxppc-2.5/arch/ppc/platforms/4xx/arctic2.h
--- linux-2.5/arch/ppc/platforms/4xx/arctic2.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/arctic2.h	2003-06-13 00:26:52.000000000 +0200
@@ -0,0 +1,148 @@
+/*
+ * arch/ppc/platforms/arctic2.h   Platform definitions for the IBM Arctic-II
+ *				based on beech.h by Bishop Brock
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * Ken Inoue 
+ * IBM Thomas J. Watson Research Center
+ * keninoue@us.ibm.com
+ *
+ * David Gibson
+ * IBM Ozlabs, Canberra, Australia
+ * arctic@gibson.dropbear.id.au
+ * 
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_ARCTIC2_H__
+#define __ASM_ARCTIC2_H__
+
+#include <platforms/4xx/subzero.h>
+
+#ifndef __ASSEMBLY__
+
+/* Physical address for the 8-bit peripheral bank */
+#define ARCTIC2_FPGA8_PADDR	(0xf8000000)
+
+/* Physical address for the 16-bit peripheral bank */
+#define ARCTIC2_FPGA16_PADDR	(0xf9000000)
+
+/* Virtual address of the FPGA control registers */
+extern volatile u8 *arctic2_fpga_regs;
+
+#define ARCTIC2_FPGA_REGS_EXTENT	(0xf)
+#define ARCTIC2_FPGA_POWERDOWN		(arctic2_fpga_regs + 0x0)
+#define ARCTIC2_FPGA_BUTTONS		(arctic2_fpga_regs + 0x1)
+#define ARCTIC2_FPGA_MULTIWAY		(arctic2_fpga_regs + 0x2)
+#define ARCTIC2_FPGA_IRQ_ENABLE		(arctic2_fpga_regs + 0x3)
+#define ARCTIC2_FPGA_PCCF_POWER		(arctic2_fpga_regs + 0x4)
+#define ARCTIC2_FPGA_JACKET		(arctic2_fpga_regs + 0x5)
+#define ARCTIC2_FPGA_SDIO_CTRL		(arctic2_fpga_regs + 0x6)
+#define ARCTIC2_FPGA_USB_CTRL		(arctic2_fpga_regs + 0x7)
+#define ARCTIC2_FPGA_MDOC_CTRL		(arctic2_fpga_regs + 0x8)
+#define ARCTIC2_FPGA_CHARGER		(arctic2_fpga_regs + 0x9)
+#define ARCTIC2_FPGA_CRYO		(arctic2_fpga_regs + 0xa)
+#define ARCTIC2_FPGA_LED_DATA_HI        (arctic2_fpga_regs + 0xc)
+#define ARCTIC2_FPGA_LED_DATA_LOW       (arctic2_fpga_regs + 0xd)
+#define ARCTIC2_FPGA_LED_ADDR           (arctic2_fpga_regs + 0xe)
+#define ARCTIC2_FPGA_LED_CTRL           (arctic2_fpga_regs + 0xf)
+
+#define ARCTIC2_FPGA_BTN_PWR		0x20
+#define ARCTIC2_FPGA_BTN_MIC		0x10
+
+#define ARCTIC2_FPGA_MULTIWAY_PUSH	0x01
+#define ARCTIC2_FPGA_MULTIWAY_NE	0x02
+#define ARCTIC2_FPGA_MULTIWAY_SE	0x04
+#define ARCTIC2_FPGA_MULTIWAY_SW	0x08
+#define ARCTIC2_FPGA_MULTIWAY_NW	0x10
+
+#define ARCTIC2_FPGA_MULTIWAY_N		0x12
+#define ARCTIC2_FPGA_MULTIWAY_E		0x06
+#define ARCTIC2_FPGA_MULTIWAY_S		0x0c
+#define ARCTIC2_FPGA_MULTIWAY_W		0x18
+
+#define ARCTIC2_FPGA_IRQ_PWR		0x10
+#define ARCTIC2_FPGA_IRQ_TCPA		0x08
+#define ARCTIC2_FPGA_IRQ_JACKET		0x04
+#define ARCTIC2_FPGA_IRQ_MIC		0x02
+#define ARCTIC2_FPGA_IRQ_BTN		0x01
+
+#define ARCTIC2_FPGA_PCCF_POWER_5V	0x01
+
+/* Arctic II uses the internal clock for UART. Note that the OPB
+   frequency must be more than 2x the UART clock frequency. At OPB
+   frequencies less than this the serial port will not function due to
+   the way that SerClk is sampled.  We use 11.1111MHz as the frequency
+   because it can be generated from a wide range of OPB frequencies we
+   want to use. */
+
+#define PPC4xx_SERCLK_FREQ 11111111
+
+#define BASE_BAUD (PPC4xx_SERCLK_FREQ / 16)
+
+#define RTC_DVBITS	RTC_DVBITS_33KHZ	/* 33kHz RTC */
+
+#define PPC4xx_MACHINE_NAME	"IBM Arctic II"
+
+#include <asm/pccf_4xx.h>
+#define _IO_BASE		(pccf_4xx_io_base)
+#define _ISA_MEM_BASE		(pccf_4xx_mem_base)
+
+void arctic2_poweroff(void) __attribute__ ((noreturn));
+void arctic2_set_lcdpower(int on);
+
+extern int arctic2_supports_apm;
+extern int arctic2_supports_dvs;
+
+/*****************************************************************************
+ * Serial port definitions
+ *****************************************************************************/
+
+/*
+ * Arctic UART1 is touchscreen handled by separate driver, not included in
+ * standard serial defines.
+ */
+
+#define UART0_INT	UIC_IRQ_U0
+#define UART1_INT	UIC_IRQ_U1
+#define UART0_IO_BASE	0xEF600300
+#define UART1_IO_BASE	0xEF600400
+
+#define RS_TABLE_SIZE	2
+
+#define STD_UART_OP(num)					\
+	{ 0, BASE_BAUD, 0, UART##num##_INT,			\
+		(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),	\
+		iomem_base:(u8 *) UART##num##_IO_BASE,		\
+		io_type: SERIAL_IO_MEM},
+
+#define SERIAL_DEBUG_IO_BASE    UART0_IO_BASE
+#define SERIAL_PORT_DFNS        \
+        STD_UART_OP(0)
+
+/* PM Button support */
+
+#ifdef CONFIG_405LP_PM_BUTTON
+#define IBM405LP_PM_IRQ      APM0_IRQ_WUI0
+#define IBM405LP_PM_POLARITY 1
+#endif
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_ARCTIC2_H__ */
+#endif /* __KERNEL__ */
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/ash.h linuxppc-2.5/arch/ppc/platforms/4xx/ash.h
--- linux-2.5/arch/ppc/platforms/4xx/ash.h	2003-02-12 00:48:52.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/ash.h	2003-07-18 03:36:49.000000000 +0200
@@ -27,14 +27,16 @@
  */
 
 typedef struct board_info {
-	unsigned char	 bi_s_version[4];	/* Version of this structure */
-	unsigned char	 bi_r_version[30];	/* Version of the IBM ROM */
-	unsigned int	 bi_memsize;		/* DRAM installed, in bytes */
-	unsigned char	 bi_enetaddr[4][6];	/* Local Ethernet MAC address */
-	unsigned char	 bi_pci_enetaddr[6];
-	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
-	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
-	unsigned int	 bi_pci_busfreq;	/* PCI speed in Hz */
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned char	bi_enetaddr[4][6];	/* Local Ethernet MAC address */
+	unsigned char	bi_pci_enetaddr[6];
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int	bi_pci_busfreq;		/* PCI speed in Hz */
+	unsigned int  	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/beech.h linuxppc-2.5/arch/ppc/platforms/4xx/beech.h
--- linux-2.5/arch/ppc/platforms/4xx/beech.h	2003-09-12 18:26:53.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/beech.h	2003-09-12 19:39:40.000000000 +0200
@@ -42,17 +42,18 @@
  */
 
 typedef struct board_info {
-	unsigned char bi_s_version[4];	/* Version of this structure */
-	unsigned long bi_tbfreq;	/* Frequency of SysTmrClk */
-	unsigned char bi_r_version[30];	/* Version of the IBM ROM */
-	unsigned int bi_memsize;	/* DRAM installed, in bytes */
-	unsigned long sysclock_period;	/* SysClk period in ns */
-	unsigned long sys_speed;	/* SysCLk frequency in Hz */
-	unsigned long bi_intfreq;	/* Processor speed, in Hz */
-	unsigned long vco_speed;	/* PLL VCO speed, in Hz */
-	unsigned long bi_busfreq;	/* PLB Bus speed, in Hz */
-	unsigned long opb_speed;	/* OPB Bus speed, in Hz */
-	unsigned long ebc_speed;	/* EBC Bus speed, in Hz */
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned long	bi_tbfreq;		/* Frequency of SysTmrClk */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned long	sysclock_period;	/* SysClk period in ns */
+	unsigned long	sys_speed;		/* SysCLk frequency in Hz */
+	unsigned long	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned long	vco_speed;		/* PLL VCO speed, in Hz */
+	unsigned long	bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int  	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	unsigned long	bi_ebc_busfreq;		/* EBC Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
 } bd_t;
 
 /* See beech.c for a concise diagram of the Beech physical memory map. */
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/cedar.h linuxppc-2.5/arch/ppc/platforms/4xx/cedar.h
--- linux-2.5/arch/ppc/platforms/4xx/cedar.h	2003-09-12 18:26:53.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/cedar.h	2003-09-12 19:39:40.000000000 +0200
@@ -34,6 +34,8 @@ typedef struct board_info {
 	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
 	unsigned int	 bi_pci_busfreq;	/* PCI speed in Hz */
+	unsigned int	 bi_opb_busfreq;	/* OPB Bus speed, in Hz */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/ep405.h linuxppc-2.5/arch/ppc/platforms/4xx/ep405.h
--- linux-2.5/arch/ppc/platforms/4xx/ep405.h	2003-02-12 00:48:52.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/ep405.h	2003-07-18 03:36:49.000000000 +0200
@@ -30,6 +30,8 @@ typedef struct board_info {
 	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
 	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
 	unsigned int	 bi_nvramsize;		/* Size of the NVRAM/RTC */
+	unsigned int	 bi_opb_busfreq;	/* OPB Bus speed, in Hz */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/ibm405lp.c linuxppc-2.5/arch/ppc/platforms/4xx/ibm405lp.c
--- linux-2.5/arch/ppc/platforms/4xx/ibm405lp.c	2003-09-12 18:26:53.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/ibm405lp.c	2003-09-12 19:39:40.000000000 +0200
@@ -32,6 +32,8 @@
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
 #include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/bcd.h>
 
 #include <asm/delay.h>
 #include <asm/hardirq.h>
@@ -43,6 +45,7 @@
 #include <asm/time.h>
 #include <asm/uaccess.h>
 #include <asm/ocp.h>
+#include <asm/pccf_4xx.h>
 
 struct ocp_def core_ocp[]  __initdata = {
 	{OCP_VENDOR_IBM, OCP_FUNC_OPB, OPB0_BASE, OCP_IRQ_NA, OCP_CPM_NA},
@@ -204,7 +207,7 @@ ibm405lp_setup_cpm(void)
 	mtdcr(DCRN_CPMFR, force);
 	mtdcr(DCRN_CPMER, enable);
 }
-#endif
+#endif /* CONFIG_PM */
 
 /* This routine is included here because the framebuffer driver needs a way to
    tell the system the Pixel clock frequency it needs, regardless of whether
@@ -237,7 +240,7 @@ int
 ibm405lp_set_pixclk(unsigned pixclk_min, unsigned pixclk_max)
 {
 	unsigned divider;
-	bd_t *bip = (bd_t *) __res;
+	bd_t *bip = &__res;
 	unsigned plb_khz = bip->bi_busfreq / 1000;
 	cpc0_cgcr1_t cgcr1;
 
@@ -264,3 +267,476 @@ ibm405lp_set_pixclk(unsigned pixclk_min,
 		return 0;
 	}
 }
+
+/* Somewhat misleading name, as well as the EBC, this sets up the UIC
+   and CPC ready for PCMCIA operation */
+static void
+pccf_ebc_setup(void)
+{
+	/* Set up EBC bank 4 as per PCCF docs., assuming 66 MHz EBC bus. The
+	   ready timeout is set for 1024 cycles (~ 15 us at 66 MHz), unless
+	   someone else has already set it for 2048.  In the event of a
+	   timeout we'll get a Data Machine Check. */
+
+	unsigned long bits, mask, flags;
+
+	save_flags(flags);
+	cli();
+
+	/* Program EBC0_CFG for ready timeout */
+
+	mtdcr(DCRN_EBC0_CFGADDR, DCRN_EBC0_CFG);
+	bits = mfdcr(DCRN_EBC0_CFGDATA);
+	if ((bits & EBC_CFG_RTC) != EBC_CFG_RTC_2048)
+		mtdcr(DCRN_EBC0_CFGDATA, (bits & ~EBC_CFG_RTC) | EBC_CFG_RTC_1024);
+
+	/* Program EBC bank properties : 32 MB, 16-bit RW bank; 
+	   BME = 0, TWT = 22, CSN = 2, OEN = 3, WBN = WBF = 0, TH = 5, 
+	   RE = 1, SOR = 0, BEM = 1 */
+
+	mtdcr(DCRN_EBC0_CFGADDR, DCRN_EBC0_B4CR);
+	mtdcr(DCRN_EBC0_CFGDATA, (PCCF_4XX_PADDR & 0xfff00000) | 0x000ba000);
+	mtdcr(DCRN_EBC0_CFGADDR, DCRN_EBC0_B4AP);
+	mtdcr(DCRN_EBC0_CFGDATA, 0x0b0b0b40);
+
+	/* Program the UIC for active-high, level-triggered interrupts.  Note
+	   that the active-low PCMCIA interrupt pin is inverted by the PCCF
+	   macro.  */
+
+	mask = (0x80000000 >> PCCF_4XX_MACRO_IRQ) | 
+		(0x80000000 >> PCCF_4XX_CARD_IRQ);
+
+	bits = mfdcr(DCRN_UIC0_PR);
+	bits |= mask;
+	mtdcr(DCRN_UIC0_PR, bits);
+
+	bits = mfdcr(DCRN_UIC0_TR);
+	bits &= ~mask;
+	mtdcr(DCRN_UIC0_TR, bits);
+
+	/* Clear CPC0_CR0[PCMD] to enable the PCMCIA controller */
+
+	mtdcr(DCRN_CPC0_CR0, mfdcr(DCRN_CPC0_CR0) & ~0x00000200);
+
+	restore_flags(flags);
+}
+
+/* Map the PCCF controller's memory windows.
+ *
+ * HACK ALERT: Logically this belongs in the pccf_4xx driver itself,
+ * however that causes problems because it happens so late in
+ * initialization.  We want to use some ISA-ish drivers (notably
+ * 8390.c) on memory mapped devices by using the
+ * ioaddr=(memaddr-_IO_BASE) hack.  If _IO_BASE is the PCMCIA ISA IO
+ * space (which we want so PC Card drivers using ISA IO work) but is
+ * not initialized until the pccf_4xx driver starts, this could well
+ * be after drivers like 8390 have initialized and computed a fake
+ * "IO" address which is now incorrect.  Putting the ioremap()ing of
+ * the PCCF macro in the chip/board setup code works around this
+ * problem. */
+int
+ibm405lp_setup_pccf(volatile u16 **vaddr, unsigned long *io_base,
+		    unsigned long *mem_base)
+{
+	pccf_ebc_setup();
+
+	*vaddr = ioremap(PCCF_4XX_MACRO_PADDR, PCCF_4XX_MACRO_WINSIZE);
+
+	if (*vaddr == NULL) {
+		printk(KERN_ERR "pccf_4xx: ioremap macro at 0x%lx failed.\n",
+		       PCCF_4XX_MACRO_PADDR);
+		return -EBUSY;
+	}
+
+	printk("ibm405lp_setup_pcmcia:  phys addr = %lx,  virt addr = %p\n",
+	       PCCF_4XX_MACRO_PADDR, *vaddr);
+
+	*io_base = (unsigned long) ioremap(PCCF_4XX_IO_PADDR,
+					   PCCF_4XX_IO_WINSIZE);
+	if (*io_base == 0) {
+		printk(KERN_ERR "pccf_4xx: ioremap io at 0x%lx failed.\n",
+		       PCCF_4XX_IO_PADDR);
+		return -EBUSY;
+	}
+
+	*mem_base = (unsigned long) ioremap(PCCF_4XX_MEM_PADDR,
+					    PCCF_4XX_MEM_WINSIZE);
+	if (*mem_base == 0) {
+		printk(KERN_ERR "pccf_4xx: ioremap mem at 0x%lx failed.\n",
+		       PCCF_4XX_MEM_PADDR);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+
+/****************************************************************************
+ * TODC
+ ****************************************************************************/
+
+/*
+ * The 405LP includes an MC146818-equivalent core accessed via a DCR
+ * wrapper.  The 405LP does not implement the NVRAM.
+ */
+
+long __init ibm405lp_time_init(void)
+{
+	static int not_initialized = 1;
+
+	/* Make sure clocks are running */
+	if (not_initialized) {
+		/* Reset the core and ensure it's enabled. */
+		mtdcr(DCRN_RTC0_WRAP, 0);		/* toggle NRST & NMR */
+		mtdcr(DCRN_RTC0_WRAP, 3);
+		mtdcr(DCRN_RTC0_CR0, 0x60);		/* No divider chain, No square wave */
+		mtdcr(DCRN_RTC0_CR1, 0x80);		/* Disable update cycles/interrupts*/
+		mtdcr(DCRN_RTC0_WRAP, 0);       /* toggle NRST & NMR */
+		mtdcr(DCRN_RTC0_WRAP, 3);
+
+		/* if necessary, set the input clock frequency */
+		if ((mfdcr(DCRN_RTC0_CR0) >> 4) != RTC_DVBITS) {
+			printk(KERN_WARNING "Warning: RTC frequency was incorrect\n");
+			mtdcr(DCRN_RTC0_CR0,
+					 ((RTC_DVBITS & 0x7) << 4) | (mfdcr(DCRN_RTC0_CR0) & 0xf));
+		}
+
+		mtdcr(DCRN_RTC0_CR1, mfdcr(DCRN_RTC0_CR1) & 0x7f);	/* allow updates */
+
+		not_initialized = 0;
+	}
+
+	return 0;
+}
+
+unsigned long ibm405lp_get_rtc_time(void)
+{
+	uint	year, mon, day, hour, min, sec;
+	uint	i, pm;
+	u_char	save_control, uip;
+
+	spin_lock(&rtc_lock);
+	save_control = mfdcr(DCRN_RTC0_CR1);
+
+	for (i=0; i<100000000; i++) {
+		uip = mfdcr(DCRN_RTC0_CR0);
+		sec = mfdcr(DCRN_RTC0_SEC) & 0x7f;
+		min = mfdcr(DCRN_RTC0_MIN) & 0x7f;
+		hour = mfdcr(DCRN_RTC0_HR) & 0xff;
+		day = mfdcr(DCRN_RTC0_DOM) & 0x3f;
+		mon = mfdcr(DCRN_RTC0_MONTH) & 0x1f;
+		year = mfdcr(DCRN_RTC0_YEAR) & 0xff;
+
+		uip |= mfdcr(DCRN_RTC0_CR0);
+		if ((uip & RTC_UIP) == 0) break;
+	}
+
+	spin_unlock(&rtc_lock);
+
+	pm = hour & 0x80;
+	hour = hour & 0x3f;
+
+	if (((save_control & RTC_DM_BINARY) == 0) ||
+	    RTC_ALWAYS_BCD) {
+
+		BCD_TO_BIN(sec);
+		BCD_TO_BIN(min);
+		BCD_TO_BIN(hour);
+		BCD_TO_BIN(day);
+		BCD_TO_BIN(mon);
+		BCD_TO_BIN(year);
+	}
+
+	
+	/* 11:59 AM -> 12:00 PM ->-> 1:00 PM ->-> 11:59 PM -> 12:00 AM */
+	if (!(save_control & RTC_24H)) {
+		if (pm && (hour != 12))
+			hour += 12;
+		if (!pm && (hour == 12))
+			hour = 0;
+	}
+
+	year = year + 1900;
+	if (year < 1970) {
+		year += 100;
+	}
+
+	return mktime(year, mon, day, hour, min, sec);
+}
+
+int ibm405lp_set_rtc_time(unsigned long nowtime)
+{
+	struct rtc_time	tm;
+	u_char		save_control, save_freq_select, pm = 0;
+
+	spin_lock(&rtc_lock);
+	to_tm(nowtime, &tm);
+
+	save_control = mfdcr(DCRN_RTC0_CR1);
+	save_freq_select = mfdcr(DCRN_RTC0_CR0);
+	mtdcr(DCRN_RTC0_CR0, save_freq_select | RTC_DIV_RESET2);
+
+        tm.tm_year = (tm.tm_year - 1900) % 100;
+
+	/* 11:59 AM -> 12:00 PM ->-> 1:00 PM ->-> 11:59 PM -> 12:00 AM */
+	if (!(save_control & RTC_24H)) {
+		if (tm.tm_hour == 0)
+			tm.tm_hour = 12;
+		else if (tm.tm_hour >= 12) {
+			pm = 0x80;
+			if (tm.tm_hour > 12) 
+				tm.tm_hour -= 12;
+		}
+	}
+
+	if (((save_control & RTC_DM_BINARY) == 0) ||
+	    RTC_ALWAYS_BCD) {
+
+		BIN_TO_BCD(tm.tm_sec);
+		BIN_TO_BCD(tm.tm_min);
+		BIN_TO_BCD(tm.tm_hour);
+		BIN_TO_BCD(tm.tm_mon);
+		BIN_TO_BCD(tm.tm_mday);
+		BIN_TO_BCD(tm.tm_year);
+	}
+
+	tm.tm_hour |= pm;
+
+	mtdcr(DCRN_RTC0_SEC,   tm.tm_sec);
+	mtdcr(DCRN_RTC0_MIN,   tm.tm_min);
+	mtdcr(DCRN_RTC0_HR,    tm.tm_hour);
+	mtdcr(DCRN_RTC0_MONTH, tm.tm_mon);
+	mtdcr(DCRN_RTC0_DOM,   tm.tm_mday);
+	mtdcr(DCRN_RTC0_YEAR,  tm.tm_year);
+	mtdcr(DCRN_RTC0_WRAP, 0); /* Reset divider chain */ 
+	mtdcr(DCRN_RTC0_WRAP, 3);
+	mtdcr(DCRN_RTC0_CR0, save_freq_select);
+
+	spin_unlock(&rtc_lock);
+	return 0;
+}
+
+/* ibm405lp_set_rtc_sqw()
+ * Set the RTC squarewave frequency and enable SQW output. This is needed to
+ * drive the APM watchdog.
+ */
+void ibm405lp_set_rtc_sqw(unsigned long rsbits)
+{
+	/* set RS field */
+	mtdcr(DCRN_RTC0_CR0, (mfdcr(DCRN_RTC0_CR0) & 0xf0) | (rsbits & 0xf));
+
+	/* set SQWE (enable squarewave output) */
+	mtdcr(DCRN_RTC0_CR1, mfdcr(DCRN_RTC0_CR1) | 0x08);
+}
+
+/* The RTC only has a 24-hour alarm capability, so only the hours, minutes and
+ * seconds fields of the rtc_time struct are used in alarm functions.  This
+ * implementation converts all out-of-range inputs to 'don't cares' (0xff), and
+ * returns 'don't cares' verbatim.  Somewhat inspired by drivers/char/rtc.c
+ */
+
+static inline int
+dont_care(uint value)
+{
+	return (value & 0xc0) == 0xc0;
+}
+
+void ibm405lp_get_rtc_alm_time(struct rtc_time *alm_tm)
+{
+	uint   hour, min, sec, pm;
+	u_char save_control;
+
+	spin_lock_irq(&rtc_lock);
+	sec = mfdcr(DCRN_RTC0_SECAL);
+	min = mfdcr(DCRN_RTC0_MINAL);
+	hour = mfdcr(DCRN_RTC0_HRAL);
+	save_control = mfdcr(DCRN_RTC0_CR1);
+	spin_unlock_irq(&rtc_lock);
+
+	if (!dont_care(hour)) {
+		pm = hour & 0x80;
+		hour = hour & 0x3f;
+	}
+
+	if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		if (!dont_care(sec)) BCD_TO_BIN(sec);
+		if (!dont_care(min)) BCD_TO_BIN(min);
+		if (!dont_care(hour)) BCD_TO_BIN(hour);
+	}
+
+	/* 11:59 AM -> 12:00 PM ->-> 1:00 PM ->-> 11:59 PM -> 12:00 AM */
+	if (!dont_care(hour) && !(save_control & RTC_24H)) {
+		if (pm && (hour != 12))
+			hour += 12;
+		if (!pm && (hour == 12))
+			hour = 0;
+	}
+
+	alm_tm->tm_hour = hour;
+	alm_tm->tm_min = min;
+	alm_tm->tm_sec = sec;
+}
+
+void ibm405lp_set_rtc_alm_time(struct rtc_time *alm_tm)
+{
+	uint   hour, min, sec, pm = 0;
+	u_char save_control;
+
+	hour = alm_tm->tm_hour;
+	min = alm_tm->tm_min;
+	sec = alm_tm->tm_sec;
+
+	if (hour > 23) hour = 0xff;
+	if (min > 59) min = 0xff;
+	if (sec > 59) sec = 0xff;
+
+	spin_lock_irq(&rtc_lock);
+
+	save_control = mfdcr(DCRN_RTC0_CR1);
+
+	/* 11:59 AM -> 12:00 PM ->-> 1:00 PM ->-> 11:59 PM -> 12:00 AM */
+	if (!dont_care(hour) && !(save_control & RTC_24H)) {
+		if (hour == 0)
+			hour = 12;
+		else if (hour >= 12) {
+			pm = 0x80;
+			if (hour > 12) 
+				hour -= 12;
+		}
+	}
+
+	if (((save_control & RTC_DM_BINARY) == 0) || RTC_ALWAYS_BCD) {
+		if (!dont_care(sec)) BIN_TO_BCD(sec);
+		if (!dont_care(min)) BIN_TO_BCD(min);
+		if (!dont_care(hour)) BIN_TO_BCD(hour);
+	}
+
+	mtdcr(DCRN_RTC0_HRAL, hour | pm);
+	mtdcr(DCRN_RTC0_MINAL, min);
+	mtdcr(DCRN_RTC0_SECAL, sec);
+
+	spin_unlock_irq(&rtc_lock);
+}
+
+/****************************************************************************
+ * APM Unit PIC
+ ****************************************************************************/
+
+/* The 405LP "APM" unit implements a hierarchical interrupt controller.  This
+   controller is buried in the APM unit, and is not part of the UIC. Three
+   special "wakeup" interrupts and the RTC interrupt are handled here. These
+   interrupts and this controller are special for several reasons:
+
+   1) They are the only interrupts that can wake the system from an
+   APM-controlled low-power state. 
+
+   2) The APM DCRs actually function at the RTC frequency.  Writes to these
+   registers do not take effect for several RTC cycles, and must be done with
+   the 'mtdcr_interlock()' protocol as they all have 'valid' bits.
+
+   3) The function of this unit is predictable, but difficult to understand.
+
+   In this implementation, RTC and wakeup IRQ handlers will attach to the APM
+   interrupt using the shared interrupt protocol.  The individual handlers are
+   responsible for setting up their polarity and triggers and clearing the
+   interrupt conditions they service, using the routines defined here. This
+   seemed simpler than going into ppc4xx_pic.c and implementing a new type of
+   cascaded IRQ service, esp. given that that this structure is unique to the
+   405LP and has such an unusual specification. 
+
+   Hardware Notes: Wakeup input trigger and level conditions are programmable
+   just like in the UIC, and the "wakeup" interrupts can be used for any
+   purpose.  Unfortunately there's no way to determine the input level of a
+   "wakeup" input other than by generating interrupt status. The APM interrupt
+   controller ORs the enabled status of the 4 interrupts it controls and
+   presents a single, active-high, level-triggered interrupt to the UIC.  This
+   signal is also used as the wakeup indication when the device is asleep.
+
+   The function of the APM0_IER and APM0_ISR are reversed from their usage in
+   the UIC.  Rather than IER masking status in ISR, status for _all_ bits in
+   ISR only appears when _any_ bit in IER is set.  The interrupt signal is the
+   correct reduced OR of IER & ISR, however.  Furthermore, the ISR will only
+   generate new status if the final value written to it is 0 after any status
+   clearing operations. 
+
+   The RTC0_CR1 and RTC0_ISR registers will be cleared during unpowered sleep
+   states (power-down, standby, hibernate). The device will still generate RTC
+   alarm interrupts correctly though, so the clearing must take place on power
+   up. */
+
+void
+ibm405lp_apm_dcr_delay(void)
+{
+  udelay(153);			/* 5 RTC cycles at 32768 Hz */
+}
+
+void
+ibm405lp_apm_irq_enable(unsigned apm_irq)
+{
+	u32 ier = mfdcr(DCRN_APM0_IER);
+
+	mtdcr_interlock(DCRN_APM0_IER, ier | (1 << (31 - apm_irq)), 
+			APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+}
+
+void
+ibm405lp_apm_irq_disable(unsigned apm_irq)
+{
+	u32 ier = mfdcr(DCRN_APM0_IER);
+
+	mtdcr_interlock(DCRN_APM0_IER, ier & ~(1 << (31 - apm_irq)),
+			APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+}
+
+void
+ibm405lp_apm_irq_ack(unsigned apm_irq)
+{
+	mtdcr_interlock(DCRN_APM0_ISR, 1 << (31 - apm_irq), APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+
+	mtdcr(DCRN_APM0_ISR, 0);
+	ibm405lp_apm_dcr_delay();
+}
+
+int
+ibm405lp_apm_irq_status(unsigned apm_irq)
+{
+	return mfdcr(DCRN_APM0_ISR) & mfdcr(DCRN_APM0_IER) & 
+		(1 << (31 - apm_irq));
+}
+
+/* Setup should be called with the APM IRQ disabled.  Since changing parameters
+   may cause status to be asserted, it is always ack'ed before returning. */
+
+void
+ibm405lp_apm_irq_setup(unsigned apm_irq, unsigned trigger, unsigned polarity)
+{
+	u32 itr, ipr;
+
+	itr = mfdcr(DCRN_APM0_ITR) | ((trigger ? 1 : 0) << (31 - apm_irq));
+	mtdcr_interlock(DCRN_APM0_ITR, itr, APM0_IRQ_MASK);
+	ipr = mfdcr(DCRN_APM0_IPR) | ((polarity ? 1 : 0) << (31 - apm_irq));
+	mtdcr_interlock(DCRN_APM0_IPR, ipr, APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+	ibm405lp_apm_irq_ack(apm_irq);
+}
+
+/* The RTC interrupt is always level-triggered, active high.  Others are board
+   dependent. */
+
+void __init
+ibm405lp_setup_apm_pic(void)
+{
+	mtdcr_interlock(DCRN_APM0_IER, 0, APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+	ibm405lp_apm_irq_setup(APM0_IRQ_RTC, 0, 1);
+}
+
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/ibm405lp.h linuxppc-2.5/arch/ppc/platforms/4xx/ibm405lp.h
--- linux-2.5/arch/ppc/platforms/4xx/ibm405lp.h	2003-09-12 18:26:53.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/ibm405lp.h	2003-09-12 19:45:00.000000000 +0200
@@ -32,6 +32,15 @@
 #include <linux/config.h>
 #include <asm/ibm4xx.h>
 
+/* See beech.c for a concise diagram of the Beech physical memory map. */
+
+#define PPC4xx_ONB_IO_PADDR    ((uint)0xef600000)
+#define PPC4xx_ONB_IO_VADDR    PPC4xx_ONB_IO_PADDR
+#define PPC4xx_ONB_IO_SIZE     ((uint)4*1024)
+#define PVR_405LP     0x41F10000
+#define PVR_405LP_1_0 (PVR_405LP | 0x0890)
+#define PVR_405LP_1_1 (PVR_405LP | 0x0991)
+
 /* Machine-specific register naming for the 4xx processors is a mess. It seems
    that everyone had a different idea on how to prefix/abbreviate/configure the
    DCR numbers and MMIO addresses.  I'm no different! For the 405LP we have
@@ -197,6 +206,16 @@
 #define DCRN_EBC0_BnCR(bank) (bank)
 #define DCRN_EBC0_BnAP(bank) (0x10 + (bank))
 
+#define EBC_CFG_RTC		0x38000000
+#define EBC_CFG_RTC_16		0x00000000
+#define EBC_CFG_RTC_32		0x08000000
+#define EBC_CFG_RTC_64		0x10000000
+#define EBC_CFG_RTC_128		0x18000000
+#define EBC_CFG_RTC_256		0x20000000
+#define EBC_CFG_RTC_512		0x28000000
+#define EBC_CFG_RTC_1024	0x30000000
+#define EBC_CFG_RTC_2048	0x38000000
+
 /* Offsets for LCD Controller DCRs */
 
 #define DCRN_LCD0_DER    0x80010000	/* Display Enable Regsiter */
@@ -310,6 +329,15 @@
 
 #define TDES0_IO_BASE  0xef600b00
 
+/* The PCMCIA controller driver 4xx_pccf.c is responsible for the EBC setup of
+   PCMCIA.  Externally, EBC bank selects 3..7 take on PCMCIA functions when
+   PCMCIA is enabled. */
+
+#define PCCF_4XX_PADDR		(0xf0000000UL)
+#define PCCF_4XX_SIZE		(32 * 1024 * 1024)
+#define PCCF_4XX_MACRO_IRQ	UIC_IRQ_EIR5
+#define PCCF_4XX_CARD_IRQ	UIC_IRQ_EIR6
+
 /*****************************************************************************
  * CPM bits for the 405LP.
  *****************************************************************************/
@@ -375,45 +403,14 @@
 #define UIC_IRQ_EIR5  30	/* External IRQ 5 */
 #define UIC_IRQ_EIR6  31	/* External IRQ 6 */
 
-/*****************************************************************************
- * Serial port definitions
- *****************************************************************************/
-
-#ifdef CONFIG_SERIAL_MANY_PORTS
-#define RS_TABLE_SIZE	64
-#else
-#define RS_TABLE_SIZE	4
-#endif
-
-#define UART0_INT	UIC_IRQ_U0
-#define UART1_INT	UIC_IRQ_U1
-#define UART0_IO_BASE	0xEF600300
-#define UART1_IO_BASE	0xEF600400
-
-#define STD_UART_OP(num)					\
-	{ 0, BASE_BAUD, 0, UART##num##_INT,			\
-		(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),	\
-		iomem_base:(u8 *) UART##num##_IO_BASE,		\
-		io_type: SERIAL_IO_MEM},
-
-#if defined(CONFIG_UART0_TTYS0)
-#define SERIAL_DEBUG_IO_BASE    UART0_IO_BASE
-#define SERIAL_PORT_DFNS        \
-        STD_UART_OP(0)          \
-        STD_UART_OP(1)
-#endif
-
-#if defined(CONFIG_UART0_TTYS1)
-#define SERIAL_DEBUG_IO_BASE    UART1_IO_BASE
-#define SERIAL_PORT_DFNS        \
-        STD_UART_OP(1)          \
-        STD_UART_OP(0)
-#endif
+/* Serial port definitions are per-board. */
 
 #ifndef __ASSEMBLY__
 
 #include <linux/types.h>
+#include <linux/rtc.h>
 #include <asm/system.h>
+#include <platforms/4xx/ibm405lp_pm.h>
 
 /****************************************************************************
  * DCR type structures and field definitions for DCRs manipulated by the 405LP
@@ -422,10 +419,15 @@
 
 /* APM0_CFG - APM Configuration Register */
 
+/* Three bits were added in 405LP 1.1.  The new defs. *should* work for 1.0 if
+   we're careful - and we really shouldn't be using 1.0 for APM anyway. */
+
 typedef union {
 	u32 reg;
 	struct {
-		unsigned int rsvd:17;
+		unsigned int rsvd:14;
+		unsigned int rtcmd:2;	/* RTC mode - Don't Change it! */
+		unsigned int rst:1;	/* Reset after Cryo sleep */
 		unsigned int isp:1;	/* Initiate Sleep */
 		unsigned int ewt:1;	/* Enable Watchdog Timer */
 		unsigned int sm:2;	/* Sleep Mode */
@@ -436,92 +438,38 @@ typedef union {
 	} fields;
 } apm0_cfg_t;
 
-#define APM0_CFG_MASK 0xffff8000	/* AND to clear all non-reserved fields */
+#define APM0_CFG_MASK 0xfffc0000 /* AND to clear all non-reserved fields */
+
+/* DPM can only set the power control bit and initiate sleep bit.
+   The initiate sleep bit is included so that we can be sure it's clear
+   whenever changing voltages. */
+
+#define APM0_CFG_DPM_MASK 0xffffbf7f
+
+#define APM0_CFG_SM_CLOCK_SUSPEND	0
+#define APM0_CFG_SM_POWER_DOWN		1
+#define APM0_CFG_SM_CRYO_STANDBY	2
 
 /* APM0_SR - APM Status Register */
 
 typedef union {
 	u32 reg;
 	struct {
-		unsigned int rsvd:17;
+		unsigned int rsvd0:20;
 		unsigned int cdet:1;	/* Clock Detect */
 		unsigned int en:1;	/* APM Enable Indicator */
-		unsigned int rset:1;	/* Processor Reset by APM? */
 		unsigned int pfr:1;	/* Power Fail Reset? */
+		unsigned int rset:1;	/* Processor Reset by APM? */
 		unsigned int rsrt:1;	/* Restart Successful? */
 		unsigned int sdwn:1;	/* Shutdown Complete */
-		unsigned int errc:8;	/* Error Code */
+	        unsigned int sigm:1;	/* Signature mismatch */
+	        unsigned int pap:1;	/* Previous APM phase */
+                unsigned int rsvd1:3;
 		unsigned int v:1;	/* Valid Bit */
 	} fields;
 } apm0_sr_t;
 
-#define APM0_SR_MASK 0xffff8000	/* AND to clear all non-reserved fields */
-
-/* APM0_IER -- APM Interrupt Enable Register
-   APM0_IPR -- APM Interrupt Polarity Register
-   APM0_ISR -- APM Interrupt Status Register
-   APM0_ITR -- APM Interrupt Trigger Register
-
-   The interrupts are also accessed via standard interrupt numbers:
-
-   59 : Wake-up Input 0
-   60 : Wake-up Input 1
-   61 : Wake-up Input 2
-   62 : Real-Time Clock Interrupt
-*/
-
-typedef union {
-	u32 reg;
-	struct {
-		unsigned int rsvd:27;
-		unsigned int wi0e:1;
-		unsigned int wi1e:1;
-		unsigned int wi2e:1;
-		unsigned int cie:1;
-		unsigned int v:1;
-	} fields;
-} apm0_ier_t;
-
-typedef union {
-	u32 reg;
-	struct {
-		unsigned int rsvd:27;
-		unsigned int wi0p:1;
-		unsigned int wi1p:1;
-		unsigned int wi2p:1;
-		unsigned int cip:1;
-		unsigned int v:1;
-	} fields;
-} apm0_ipr_t;
-
-typedef union {
-	u32 reg;
-	struct {
-		unsigned int rsvd:27;
-		unsigned int wi0s:1;
-		unsigned int wi1s:1;
-		unsigned int wi2s:1;
-		unsigned int cis:1;
-		unsigned int v:1;
-	} fields;
-} apm0_isr_t;
-
-typedef union {
-	u32 reg;
-	struct {
-		unsigned int rsvd:27;
-		unsigned int wi0t:1;
-		unsigned int wi1t:1;
-		unsigned int wi2t:1;
-		unsigned int cit:1;
-		unsigned int v:1;
-	} fields;
-} apm0_itr_t;
-
-#define APM0_IER_MASK 0xffffffe0	/* AND to clear all non-reserved fields */
-#define APM0_IPR_MASK 0xffffffe0	/* AND to clear all non-reserved fields */
-#define APM0_ISR_MASK 0xffffffe0	/* AND to clear all non-reserved fields */
-#define APM0_ITR_MASK 0xffffffe0	/* AND to clear all non-reserved fields */
+#define APM0_SR_MASK 0xfffff00e	/* AND to clear all non-reserved fields */
 
 /* CPC0_PLLMR - PLL Mode Register */
 
@@ -530,16 +478,17 @@ typedef union {
 	struct {
 		unsigned int pmul:5;	/* PLL Multiplier */
 		unsigned int pdiv:5;	/* PLL Divider */
-		unsigned int tun:10;	/* PLL Tuning Control */
+		unsigned int tun:1;	/* PLL Tuning Control */
+		unsigned int bps:1;     /* Bypass SysClk through PLL Divider */
+                unsigned int rsvd0:8;   /* Reserved */
 		unsigned int db2:1;	/* Divide VCO by 2 Select */
 		unsigned int csel:2;	/* PLL Clock Output Select */
-		unsigned int rsvd:8;	/* Reserved */
+		unsigned int rsvd1:8;	/* Reserved */
 		unsigned int v:1;	/* Valid bit */
 	} fields;
 } cpc0_pllmr_t;
 
-#define CPC0_PLLMR_MASK 0x000001fe	/* AND to clear all non-reserved fields */
-#define CPC0_PLLMR_RTVFS_MASK CPC0_PLLMR_MASK	/* All bits controlled by RTVFS */
+#define CPC0_PLLMR_MASK 0x000ff1fe	/* AND to clear all non-reserved fields */
 
 /* The PLL multiplier/divider are always multiples of 4. */
 
@@ -547,13 +496,13 @@ typedef union {
 #define CPC0_PLLMR_MULDIV_DECODE(n) (((n) + 1) * 4)
 #define CPC0_PLLMR_MULDIV_MAX 128
 
-#define CPC0_PLLMR_TUN_HIGH 0x200	/* High-band tuning */
-#define CPC0_PLLMR_TUN_LOW  0x000	/* Low-band tuning */
+#define CPC0_PLLMR_TUN_HIGH 0x1  	/* High-band tuning */
+#define CPC0_PLLMR_TUN_LOW  0x0 	/* Low-band tuning */
 
 #define CPC0_PLLMR_CSEL_REFCLK  0	/* System Reference Clock */
 #define CPC0_PLLMR_CSEL_PLLVCO  1	/* PLL VCO */
 #define CPC0_PLLMR_CSEL_RTC     2	/* RTC */
-#define CPC0_PLLMR_CSEL_EBCPLB5 3	/* EBC-PLB divisor is 5 ??? */
+#define CPC0_PLLMR_CSEL_RSVD    3	/* Reserved */
 
 /* CPC0_CGCR0 - Clock Generation and Control Register 0 */
 
@@ -571,8 +520,6 @@ typedef union {
 } cpc0_cgcr0_t;
 
 #define CPC0_CGCR0_MASK 0x00001fff	/* AND to clear all non-reserved fields */
-#define CPC0_CGCR0_RTVFS_MASK 0x0001ffff	/* AND to clear all rtvfs-modified
-						   fields */
 
 #define CPC0_CGCR0_SCSEL_OFF  0	/* SysClkOut driven low (low power) */
 #define CPC0_CGCR0_SCSEL_CPU  1	/* Select CPU clock as SysClkOut */
@@ -593,8 +540,6 @@ typedef union {
 } cpc0_cgcr1_t;
 
 #define CPC0_CGCR1_MASK 0x00007fff	/* AND to clear all non-reserved fields */
-#define CPC0_CGCR1_RTVFS_MASK 0x0001ffff	/* AND to clear all rtvfs-modified
-						   fields */
 
 /* 5-bit clock dividers are directly encoded, except that an encoding of 0
    indicates divide-by-32. */
@@ -808,7 +753,6 @@ typedef union {
 } sdram0_rtr_t;
 
 #define SDRAM0_RTR_MASK 0xc007ffff	/* AND to clear non-reserved fields */
-#define SDRAM0_RTR_RTVFS_MASK SDRAM0_RTR_MASK
 
 #define SDRAM0_RTR_IV(n) (((n) & 0x3ff8) >> 2)
 
@@ -830,7 +774,6 @@ typedef union {
 } sdram0_tr_t;
 
 #define SDRAM0_TR_MASK 0xfe703fe0	/* AND to clear non-reserved fields */
-#define SDRAM0_TR_RTVFS_MASK SDRAM0_TR_MASK
 
 #define SDRAM0_TR_ENCODE(n) ((n) - 1)
 #define SDRAM0_TR_ENCODE_RFTA(n) ((n) - 4)
@@ -849,6 +792,11 @@ typedef union {
 
 #define SLA0_SLPMD_MASK 0x07dfffff	/* AND to clear all non-reserved fields */
 
+/* these defines are for the DV bits of RTC0_CR0 */
+#define RTC_DVBITS_4MHZ		0	/* 4.194304 MHz */
+#define RTC_DVBITS_1MHZ		1	/* 1.048576 MHz */
+#define RTC_DVBITS_33KHZ	2	/*   32.768 kHz */
+
 /* Several direct-write DCRs on the 405LP have an interlock requirement,
    implemented by a "valid" bit in the low-order bit.  This routine handles the
    handshaking for these registers, by
@@ -885,13 +833,40 @@ do {                                    
  ****************************************************************************/
 
 int ibm405lp_set_pixclk(unsigned pixclk_min, unsigned pixclk_max);
-
-void ibm405lp_reset_sdram(u32 new_rtr, u32 new_tr);
+int ibm405lp_setup_pccf(volatile u16 **vaddr, unsigned long *io_base,
+			unsigned long *mem_base);
+void ibm405lp_setup_cpm(void);
 
 extern int (*set_pixclk_hook) (unsigned pixclk_min, unsigned pixclk_max);
 extern unsigned last_pixclk_min;
 extern unsigned last_pixclk_max;
 
+extern long ibm405lp_time_init(void);
+extern unsigned long ibm405lp_get_rtc_time(void);
+extern int ibm405lp_set_rtc_time(unsigned long nowtime);
+extern void ibm405lp_set_rtc_sqw(unsigned long rsbits);
+extern void ibm405lp_set_rtc_alm_time(struct rtc_time *alm_time);
+extern void ibm405lp_get_rtc_alm_time(struct rtc_time *alm_time);
+
+/* APM0 interrupt routines are in ibm405lp.c */
+
+#define APM0_IRQ_MASK 0xffffffe0 /* AND to clear all non-reserved fields */
+
+#define APM0_IRQ_WUI0 27
+#define APM0_IRQ_WUI1 28
+#define APM0_IRQ_WUI2 29
+#define APM0_IRQ_RTC  30
+
+void ibm405lp_apm_dcr_delay(void);
+#define ibm405lp_rtc_dcr_delay() ibm405lp_apm_dcr_delay();
+void ibm405lp_apm_irq_ack(unsigned apm_irq);
+void ibm405lp_apm_irq_setup(unsigned apm_irq,
+			    unsigned trigger, unsigned polarity);
+void ibm405lp_apm_irq_enable(unsigned apm_irq);
+void ibm405lp_apm_irq_disable(unsigned apm_irq);
+int ibm405lp_apm_irq_status(unsigned apm_irq);
+void ibm405lp_setup_apm_pic(void);
+
 #endif				/* __ASSEMBLY__ */
 
 #include <asm/ibm405.h>
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/ibm405lp_pm.h linuxppc-2.5/arch/ppc/platforms/4xx/ibm405lp_pm.h
--- linux-2.5/arch/ppc/platforms/4xx/ibm405lp_pm.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/ibm405lp_pm.h	2003-06-13 00:25:46.000000000 +0200
@@ -0,0 +1,55 @@
+#ifndef IBM405LP_PM_H
+#define IBM405LP_PM_H
+
+#include <asm/types.h>
+
+#ifndef __ASSEMBLY__
+
+/* sysctl numbers */
+
+/* top-level number for the 405LP sleep sysctl()s
+ *
+ * This is picked at random out of thin air, hoping that it won't
+ * clash with someone.  That's really ugly, but appears to be
+ * "standard" practice (!?).  Oh well, with any luck we can throw
+ * these away and replace them with sysfs parameters, in the
+ * not-too-distant future...
+ */
+#define CTL_PM_405LP 0xbc17
+
+/* sleep sysctls */
+enum
+{
+	PM_405LP_SLEEP_CMD=1,
+	PM_405LP_SLEEP_MODE=2,
+	PM_405LP_SLEEP_ALARM=3,
+	PM_405LP_SLEEP_DEBUG_CDIV=4,
+	PM_405LP_SLEEP_DEBUG_WATCHDOG=5
+};
+
+/* Used to tell firmware where to return control to Linux on
+ * wake. Currently only the first two words are used by firmware; the
+ * rest are Linux convenience.
+ */
+struct ibm405lp_wakeup_info {
+	/* physical address of wakeup function */
+	void (*wakeup_func_phys)(unsigned long apm0_cfg,
+				 unsigned long apm0_sr);
+	u32 magic;
+
+	/* private to Linux: */
+	unsigned long wakeup_stack_phys; /* physical stack pointer */
+};
+
+#endif /* __ASSEMBLY__ */
+
+#define IBM405LP_WAKEUP_MAGIC	(0x31415926)
+
+/* These values are ORed into RTC0_CEN before APM power-down modes as a
+ * signal to the firmware as to which type of wakeup is required. */
+
+#define IBM405LP_POWERDOWN_REBOOT    0x00 /* Reboot the system */
+#define IBM405LP_POWERDOWN_SUSPEND   0x40 /* Suspend-to-RAM */
+#define IBM405LP_POWERDOWN_HIBERNATE 0x80 /* Hibernate to device 0 */
+
+#endif /* IBM405LP_PM_H */
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/ibmstb4.c linuxppc-2.5/arch/ppc/platforms/4xx/ibmstb4.c
--- linux-2.5/arch/ppc/platforms/4xx/ibmstb4.c	2003-02-12 00:48:52.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/ibmstb4.c	2003-06-03 23:59:10.000000000 +0200
@@ -15,13 +15,13 @@
 #include <asm/ocp.h>
 
 struct ocp_def core_ocp[] = {
-	{UART, UART0_IO_BASE, UART0_INT,IBM_CPM_UART0},
-	{UART, UART1_IO_BASE, UART1_INT, IBM_CPM_UART1},
-	{UART, UART2_IO_BASE, UART2_INT, IBM_CPM_UART2},
-	{IIC, IIC0_BASE, IIC0_IRQ, IBM_CPM_IIC0},
-	{IIC, IIC1_BASE, IIC1_IRQ, IBM_CPM_IIC1},
-	{GPIO, GPIO0_BASE, OCP_IRQ_NA, IBM_CPM_GPIO0},
-	{IDE, IDE0_BASE, IDE0_IRQ, OCP_CPM_NA},
-	{USB, USB0_BASE, USB0_IRQ, IBM_CPM_USB0},
-	{OCP_NULL_TYPE, 0x0, OCP_IRQ_NA, OCP_CPM_NA},
+	{OCP_VENDOR_IBM, OCP_FUNC_16550, UART0_IO_BASE, UART0_INT,IBM_CPM_UART0},
+	{OCP_VENDOR_IBM, OCP_FUNC_16550, UART1_IO_BASE, UART1_INT, IBM_CPM_UART1},
+	{OCP_VENDOR_IBM, OCP_FUNC_16550, UART2_IO_BASE, UART2_INT, IBM_CPM_UART2},
+	{OCP_VENDOR_IBM, OCP_FUNC_IIC, IIC0_BASE, IIC0_IRQ, IBM_CPM_IIC0},
+	{OCP_VENDOR_IBM, OCP_FUNC_IIC, IIC1_BASE, IIC1_IRQ, IBM_CPM_IIC1},
+	{OCP_VENDOR_IBM, OCP_FUNC_GPIO, GPIO0_BASE, OCP_IRQ_NA, IBM_CPM_GPIO0},
+	{OCP_VENDOR_IBM, OCP_FUNC_IDE, IDE0_BASE, IDE0_IRQ, OCP_CPM_NA},
+	{OCP_VENDOR_IBM, OCP_FUNC_USB, USB0_BASE, USB0_IRQ, IBM_CPM_USB0},
+	{OCP_VENDOR_INVALID, OCP_FUNC_INVALID, 0x0, OCP_IRQ_NA, OCP_CPM_NA},
 };
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/ibmstb4.h linuxppc-2.5/arch/ppc/platforms/4xx/ibmstb4.h
--- linux-2.5/arch/ppc/platforms/4xx/ibmstb4.h	2003-02-12 00:48:52.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/ibmstb4.h	2003-06-03 23:59:11.000000000 +0200
@@ -14,7 +14,6 @@
 #define __ASM_IBMSTB4_H__
 
 #include <linux/config.h>
-#include <platforms/4xx/ibm_ocp.h>
 
 /* serial port defines */
 #define STB04xxx_IO_BASE	((uint)0xe0000000)
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/rainier.c linuxppc-2.5/arch/ppc/platforms/4xx/rainier.c
--- linux-2.5/arch/ppc/platforms/4xx/rainier.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/rainier.c	2003-06-21 03:52:18.000000000 +0200
@@ -0,0 +1,229 @@
+/*
+ *
+ *
+ *    Copyright 2000-2002 MontaVista Software Inc.
+ *      Author: MontaVista Software, Inc.
+ *      	akuster@mvista.com <source@mvista.com>
+ *
+ *    Module name: rainier.c
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      IBM PowerPC 4xx based boards. Adapted from original
+ *      code from walnut.c
+ *
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/pci.h>
+#include <linux/rtc.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <platforms/ibm_ocp.h>
+#include <asm/todc.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+void *rainier_rtc_base;
+unsigned int rainier_io_page;
+
+void
+*locate_rainier_io(void)
+{
+	unsigned int temp;
+
+	temp = in_le32((void*)PPC405_PCI_CONFIG_ADDR) & PCI_CONFIG_ADDR_MASK;
+	out_le32((void*)PPC405_PCI_CONFIG_ADDR,
+			temp | PCI_CONFIG_CYCLE_ENABLE |PCI_BASE_ADDRESS_2);
+	temp = in_le32((void*)PPC405_PCI_CONFIG_DATA);
+
+	if (temp == (PCI_BASE_ADDRESS_MEM_CARD2 | PCI_BASE_ADDRESS_MEM_PREFETCH))
+		return PPC_405RAINIER2_IO_PAGE;
+	else
+		return PPC_405RAINIER1_IO_PAGE;
+}
+
+int __init
+ppc405_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	    /*
+	     *      PCI IDSEL/INTPIN->INTLINE
+	     *      A       B       C       D
+	     */
+	{
+		{28, 28, 28, 28},	/* IDSEL 1 - PCI slot 1 */
+		{29, 29, 29, 29},	/* IDSEL 2 - PCI slot 2 */
+		{30, 30, 30, 30},	/* IDSEL 3 - PCI slot 3 */
+		{31, 31, 31, 31},	/* IDSEL 4 - PCI slot 4 */
+	};
+
+	const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+
+void __init
+raininer_setup_arch(void)
+{
+	struct uart_port port;
+
+	ppc4xx_setup_arch();
+
+	port.membase = (void*)PPC405_UART0_IO_BASE;
+	port.membase += rainier_io_page;
+	port.irq = PPC405_UART0_INT;
+	port.uartclk = BASE_BAUD * 16;
+	port.iotype = SERIAL_IO_MEM;
+	port.flags = STD_COM_FLAGS;
+	port.line = 0;
+
+        early_serial_setup(&port);
+
+	/* RTC step for the rainier */
+	rainier_rtc_base = (void *) WALNUT_RTC_VADDR;
+	TODC_INIT(TODC_TYPE_DS1743, rainier_rtc_base, rainier_rtc_base,
+		  rainier_rtc_base, 8);
+}
+
+void __init
+bios_fixup(struct pci_controller *hose, struct pcil0_regs *pcip)
+{
+	/*
+	 * Expected PCI mapping:
+	 *
+	 *  PLB addr             PCI memory addr
+	 *  ---------------------       ---------------------
+	 *  0000'0000 - 7fff'ffff <---  0000'0000 - 7fff'ffff
+	 *  8000'0000 - Bfff'ffff --->  8000'0000 - Bfff'ffff
+	 *
+	 *  PLB addr             PCI io addr
+	 *  ---------------------       ---------------------
+	 *  e800'0000 - e800'ffff --->  0000'0000 - 0001'0000
+	 *
+	 * The following code is simplified by assuming that the bootrom
+	 * has been well behaved in following this mapping.
+	 */
+
+#ifdef DEBUG
+	int i;
+
+	printk("ioremap PCLIO_BASE = 0x%x\n", pcip);
+	printk("PCI bridge regs before fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+
+	/* Disable region first */
+	out_le32((void *) &(pcip->pmm[0].ma), 0x00000000);
+	/* PLB starting addr, PCI: 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].la), 0x80000000);
+	/* PCI start addr, 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].pcila), PPC405_PCI_MEM_BASE);
+	/* 512MB range of PLB to PCI */
+	out_le32((void *) &(pcip->pmm[0].pciha), 0x00000000);
+	/* Enable no pre-fetch, enable region */
+	out_le32((void *) &(pcip->pmm[0].ma), ((0xffffffff -
+						(PPC405_PCI_UPPER_MEM -
+						 PPC405_PCI_MEM_BASE)) | 0x01));
+
+	/*region one used bu rainier*/
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].la), 0x80000000);
+	out_le32((void *) &(pcip->pmm[1].pcila), 0x80000000);
+	out_le32((void *) &(pcip->pmm[1].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].ma), 0xFFFF8001);
+	out_le32((void *) &(pcip->ptm1ms), 0x00000000);
+
+	/* Disable region two */
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm2ms), 0x00000000);
+
+	/* end work arround */
+
+#ifdef DEBUG
+	printk("PCI bridge regs after fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+}
+
+void __init
+rainier_map_io(void)
+{
+	ppc4xx_map_io();
+
+	io_block_mapping(RAINIER_IO_PAGE_INTERPOSER_PADDR,
+			 RAINIER_IO_PAGE_INTERPOSER_VADDR,PAGE_SIZE , _PAGE_IO);
+
+	io_block_mapping(RAINIER_IO_PAGE_PCI_PADDR,
+			 RAINIER_IO_PAGE_PCI_VADDR,PAGE_SIZE , _PAGE_IO);
+	
+	io_block_mapping(RAINIER_RTC_VADDR,
+			 RAINIER_RTC_PADDR, RAINIER_RTC_SIZE, _PAGE_IO);
+
+	rainier_io_page = locate_rainier_io();
+       
+	io_block_mapping(rainier_io_page ,
+			 rainier_io_page , PAGE_SIZE, _PAGE_IO);
+
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = rainier_setup_arch;
+	ppc_md.setup_io_mappings = rainier_map_io;
+
+	ppc_md.time_init	 	= m48t3x_time_init;
+	ppc_md.set_rtc_time	 	= m48t3x_set_rtc_time;
+	ppc_md.get_rtc_time	 	= m48t3x_get_rtc_time;
+	ppc_md.time_init = todc_time_init;
+	ppc_md.nvram_read_val = todc_direct_read_val;
+	ppc_md.nvram_write_val = todc_direct_write_val;
+}
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/rainier.h linuxppc-2.5/arch/ppc/platforms/4xx/rainier.h
--- linux-2.5/arch/ppc/platforms/4xx/rainier.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/rainier.h	2002-12-05 03:30:44.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ *    Copyright 2002 MontaVista Software Inc.
+ *	NP405GS modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	Akuster@mvista.com or source@mvista.com
+ *
+ *    Module name: rainier.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      Network processor based boards.
+ *
+ *      This includes:
+ *
+ *         NP405GS "Rainier" evaluation board
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_RAINIER_H__
+#define __ASM_RAINIER_H__
+
+/* We have a N405GS core */
+#include <platforms/ibmnp4gs.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * Data structure defining board information maintained 
+ * manuals since the rainer uses vxworks
+ */
+
+typedef struct board_info {
+	unsigned char bi_s_version[4];		/* Version of this structure */
+	unsigned char bi_r_version[30];		/* Version of the IBM ROM */
+	unsigned int bi_memsize;		/* DRAM installed, in bytes */
+	unsigned char bi_enetaddr[6];		/* Local Ethernet MAC address */
+	unsigned char bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
+	unsigned int bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int bi_pci_busfreq;		/* PCI Bus speed, in Hz */
+} bd_t;
+
+#define bi_tbfreq bi_intfreq
+
+extern void *rainer_rtc_base;
+#define RAINIER_RTC_PADDR	((uint)0xf0000000)
+#define RAINIER_RTC_VADDR	RAINIER_RTC_PADDR
+#define RAINIER_RTC_SIZE	((uint)8*1024)
+
+#define BASE_BAUD		115200
+
+#define PPC4xx_MACHINE_NAME	"IBM Rainier"
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_RAINIER_H__ */
+#endif /* __KERNEL__ */
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/redwood.h linuxppc-2.5/arch/ppc/platforms/4xx/redwood.h
--- linux-2.5/arch/ppc/platforms/4xx/redwood.h	2003-09-12 18:26:53.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/redwood.h	2003-09-12 19:39:40.000000000 +0200
@@ -28,6 +28,8 @@ typedef struct board_info {
 	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
 	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[2];		/* Use fast i2c mode */
 } bd_t;
 #define bi_tbfreq bi_intfreq
 
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/redwood5.h linuxppc-2.5/arch/ppc/platforms/4xx/redwood5.h
--- linux-2.5/arch/ppc/platforms/4xx/redwood5.h	2003-04-02 22:04:29.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/redwood5.h	2003-07-18 03:36:49.000000000 +0200
@@ -29,6 +29,8 @@ typedef struct board_info {
 	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
 	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[2];		/* Use fast i2c mode */
 } bd_t;
 #endif /* !__ASSEMBLY__ */
 
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/redwood6.h linuxppc-2.5/arch/ppc/platforms/4xx/redwood6.h
--- linux-2.5/arch/ppc/platforms/4xx/redwood6.h	2003-04-02 22:04:29.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/4xx/redwood6.h	2003-07-18 03:36:49.000000000 +0200
@@ -21,14 +21,16 @@
 
 #ifndef __ASSEMBLY__
 typedef struct board_info {
-	unsigned char bi_s_version[4];	/* Version of this structure */
-	unsigned char bi_r_version[30];	/* Version of the IBM ROM */
-	unsigned int bi_memsize;	/* DRAM installed, in bytes */
-	unsigned int bi_dummy;	/* field shouldn't exist */
-	unsigned char bi_enetaddr[6];	/* Ethernet MAC address */
-	unsigned int bi_intfreq;	/* Processor speed, in Hz */
-	unsigned int bi_busfreq;	/* Bus speed, in Hz */
-	unsigned int bi_tbfreq;	/* Software timebase freq */
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
 } bd_t;
 #endif				/* !__ASSEMBLY__ */
 
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/subzero.c linuxppc-2.5/arch/ppc/platforms/4xx/subzero.c
--- linux-2.5/arch/ppc/platforms/4xx/subzero.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/subzero.c	2003-06-13 00:26:52.000000000 +0200
@@ -0,0 +1,96 @@
+/*
+ * arch/ppc/platforms/subzero.c  Platform setup for the IBM Subzero CPU core card.
+ *
+ *				Based on arctic1.c by Ken Inoue, which
+ *				was based on beech.c by Bishop Brock
+ *
+ * The source code contained herein is licensed under the IBM Public License
+ * Version 1.0, which has been approved by the Open Source Initiative.
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * David Gibson
+ * IBM OzLabs, Canberra, Australia
+ * <dwg@au1.ibm.com>
+ */
+
+#include <linux/blk.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/rtc.h>
+#include <linux/string.h>
+
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+/* 
+   Subzero core card physical memory map:
+
+   Main Memory (Initialized by the BIOS)
+   =======================================================================
+
+   SDRAM (32 MB)     0x00000000 - 0x02000000
+
+   OPB Space: (Mapped virtual = physical in ppc4xx_setup.c)
+   =======================================================================
+
+   UART0               	      0xEF600300
+   UART1               	      0xEF600400
+   IIC                 	      0xEF600500
+   OPB Arbiter         	      0xEF600600
+   GPIO Controller     	      0xEF600700
+   CODEC Interface            0xEF600900
+   Touch Panel Controller     0xEF600A00
+   DES Controller             0xEF600B00
+
+   
+   EBC Space: (Mapped virtual = physical in board_io_mapping())
+	      (EBC setup for personality cards left to individual card setups) 
+   Space             EBC Bank    Physical Addresses  EBC Base Address
+   =========================================================================
+   Boot/Linux Flash      0       FF000000 - FFFFFFFF  FF000000 (16MB)
+
+*/
+
+
+/****************************************************************************
+ * EBC Setup
+ ****************************************************************************/
+
+/* The EBC is set up for Arctic1.  This may simply replicate the setup already
+   done by the IBM BIOS for Arctic1 (possibly with some address map changes), or
+   may be the first initialization if the board is booting from another BIOS.
+   Virtually all that is required to boot Linux on Subzero is that the BIOS
+   enable the memory controller, load a Linux image from flash, and run it.
+
+   For optimal dynamic frequency scaling the EBC settings will also vary as the
+   frequency varies.
+*/
+
+void __init
+subzero_core_ebc_setup(void)
+{
+	ebc0_bnap_t ap;
+
+	/* Set EBC bank 0 for the boot/data flash.
+
+	   Access parameters assume 150ns Intel flash @ 66.66 MHz maximum bus
+	   speed = 10 cycle access with 2 turnaround cycles (30 ns).
+
+	   NB: IBM BIOS sets this bank to burst, however bursting will never
+	   happen in Linux because this region is mapped non-cacheable and
+	   guarded, so it is set non-burst here. */
+	ap.reg = mfdcri(DCRN_EBC0, BnAP(0)) & EBC0_BnAP_MASK;
+	ap.fields.twt = 10;
+	ap.fields.th = 2;
+	mtdcri(DCRN_EBC0, BnAP(0), ap.reg);
+
+}
+
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/subzero.h linuxppc-2.5/arch/ppc/platforms/4xx/subzero.h
--- linux-2.5/arch/ppc/platforms/4xx/subzero.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/subzero.h	2003-07-18 03:36:49.000000000 +0200
@@ -0,0 +1,100 @@
+/*
+ * arch/ppc/platforms/subzero.h   Platform definitions for the IBM 
+ *				Subzero card, based on beech.h by Bishop Brock
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * David Gibson
+ * IBM OzLabs, Canberra, Australia
+ * <arctic@gibson.dropbear.id.au>
+ *
+ * Ken Inoue 
+ * IBM Thomas J. Watson Research Center
+ * <keninoue@us.ibm.com>
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_SUBZERO_CORE_H__
+#define __ASM_SUBZERO_CORE_H__
+
+#include <platforms/4xx/ibm405lp.h>
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+
+/*
+ * Data structure defining board information maintained by the standard boot
+ * ROM on the IBM Subzero card. An effort has been made to
+ * keep the field names consistent with the 8xx 'bd_t' board info
+ * structures.
+ * 
+ * Original Beech BIOS Definition:
+ * 
+ * typedef struct board_cfg_data {
+ *    unsigned char     usr_config_ver[4];
+ *    unsigned long     timerclk_freq;
+ *    unsigned char     rom_sw_ver[30];
+ *    unsigned int      mem_size;
+ *    unsigned long     sysclock_period;
+ *    unsigned long     sys_speed;
+ *    unsigned long     cpu_speed;
+ *    unsigned long     vco_speed;
+ *    unsigned long     plb_speed;
+ *    unsigned long     opb_speed;
+ *    unsigned long     ebc_speed;
+ *  } bd_t;
+ */
+
+typedef struct board_info {
+	unsigned char     bi_s_version[4];  /* Version of this structure */
+	unsigned long     bi_tbfreq;        /* Frequency of SysTmrClk */
+	unsigned char     bi_r_version[30]; /* Version of the IBM ROM */
+	unsigned int      bi_memsize;       /* DRAM installed, in bytes */
+	unsigned long     sysclock_period;  /* SysClk period in ns */
+	unsigned long     sys_speed;        /* SysCLk frequency in Hz */
+	unsigned long     bi_intfreq;       /* Processor speed, in Hz */
+	unsigned long     vco_speed;        /* PLL VCO speed, in Hz */
+	unsigned long     bi_busfreq;       /* PLB Bus speed, in Hz */
+	unsigned long     bi_opb_busfreq;   /* OPB Bus speed, in Hz */
+	unsigned long     bi_ebc_busfreq;   /* EBC Bus speed, in Hz */
+	int		  bi_iic_fast[1];   /* Use fast i2c mode */
+} bd_t;
+
+/* EBC Bank 0 controls the boot flash
+ *
+ * FIXME? these values assume that there is 16MB of flash on the
+ * personality card, in addition to the 16MB on the subzero card
+ * itself */
+#define SUBZERO_BANK0_PADDR      ((uint)0xfe000000)
+#define SUBZERO_BANK0_EBC_SIZE   EBC0_BnCR_BS_32MB
+
+#define SUBZERO_BOOTFLASH_PADDR  (SUBZERO_BANK0_PADDR)
+#define SUBZERO_BOOTFLASH_SIZE   ((uint)(32 * 1024 * 1024))
+
+#define PCI_DRAM_OFFSET		0
+
+void *beech_sram_alloc(size_t size);
+int beech_sram_free(void *p);
+
+void subzero_core_ebc_setup(void);
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_SUBZERO_CORE_H__ */
+#endif /* __KERNEL__ */
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/sycamore.h linuxppc-2.5/arch/ppc/platforms/4xx/sycamore.h
--- linux-2.5/arch/ppc/platforms/4xx/sycamore.h	2003-02-12 00:48:53.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/sycamore.h	2003-07-18 03:36:49.000000000 +0200
@@ -35,6 +35,8 @@ typedef struct board_info {
 	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
 	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+	unsigned long	 bi_opb_busfreq;	/* OPB Bus speed, in Hz */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.c linuxppc-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.c
--- linux-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.c	2002-12-05 03:30:44.000000000 +0100
@@ -0,0 +1,61 @@
+/*
+ *
+ *    Copyright 2000-2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *	Current maintainer
+ *      Armin Kuster akuster@mvista.com
+ *
+ *    Module name: virtex-ii_pro.c
+ *Xilinx Manua Loa 2 evaluation board initialization
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/ocp.h>
+#include "virtex-ii_pro.h"
+
+/* Have OCP take care of the serial ports. */
+struct ocp_def core_ocp[] = {
+#ifdef XPAR_UARTNS550_0_BASEADDR
+	{UART, XPAR_UARTNS550_0_BASEADDR, 31 - XPAR_INTC_0_UARTNS550_0_VEC_ID,
+	 OCP_CPM_NA},
+#ifdef XPAR_UARTNS550_1_BASEADDR
+	{UART, XPAR_UARTNS550_1_BASEADDR, 31 - XPAR_INTC_0_UARTNS550_1_VEC_ID,
+	 OCP_CPM_NA},
+#ifdef XPAR_UARTNS550_2_BASEADDR
+	{UART, XPAR_UARTNS550_2_BASEADDR, 31 - XPAR_INTC_0_UARTNS550_2_VEC_ID,
+	 OCP_CPM_NA},
+#ifdef XPAR_UARTNS550_3_BASEADDR
+	{UART, XPAR_UARTNS550_3_BASEADDR, 31 - XPAR_INTC_0_UARTNS550_3_VEC_ID,
+	 OCP_CPM_NA},
+#ifdef XPAR_UARTNS550_4_BASEADDR
+#error Edit this file to add more devices.
+#endif				/* 4 */
+#endif				/* 3 */
+#endif				/* 2 */
+#endif				/* 1 */
+#endif				/* 0 */
+	{OCP_NULL_TYPE, 0x0, OCP_IRQ_NA, OCP_CPM_NA}
+};
+
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.h linuxppc-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.h
--- linux-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.h	2002-11-07 08:07:25.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ * virtex-ii_pro.h
+ *
+ * Include file that defines the Xilinx Virtex-II Pro processor
+ *
+ * Author: MontaVista Software, Inc.
+ *         source@mvista.com
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_VIRTEXIIPRO_H__
+#define __ASM_VIRTEXIIPRO_H__
+
+#include <linux/config.h>
+#include <asm/xilinx_ocp.h>
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+# define RS_TABLE_SIZE  64
+#else
+# define RS_TABLE_SIZE  4
+#endif
+
+#define DCRN_CPMFR_BASE	0
+
+#include <asm/ibm405.h>
+
+#endif				/* __ASM_VIRTEXIIPRO_H__ */
+#endif				/* __KERNEL__ */
diff -p -purN linux-2.5/arch/ppc/platforms/4xx/walnut.h linuxppc-2.5/arch/ppc/platforms/4xx/walnut.h
--- linux-2.5/arch/ppc/platforms/4xx/walnut.h	2003-02-12 00:48:53.000000000 +0100
+++ linuxppc-2.5/arch/ppc/platforms/4xx/walnut.h	2003-07-18 03:36:49.000000000 +0200
@@ -40,6 +40,8 @@ typedef struct board_info {
 	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
 	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+	unsigned long	 bi_opb_busfreq;	/* OPB Bus speed, in Hz */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -p -purN linux-2.5/arch/ppc/platforms/Makefile linuxppc-2.5/arch/ppc/platforms/Makefile
--- linux-2.5/arch/ppc/platforms/Makefile	2003-07-03 02:44:14.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/Makefile	2003-07-03 03:57:40.000000000 +0200
@@ -11,6 +11,10 @@ endif
 
 # Extra CFLAGS so we don't have to do relative includes
 CFLAGS_pmac_setup.o	+= -Iarch/$(ARCH)/mm
+CFLAGS_spruce_setup.o	+= -Iarch/$(ARCH)/kernel
+CFLAGS_spruce_pci.o	+= -Iarch/$(ARCH)/kernel
+CFLAGS_pal4_setup.o	+= -Iarch/$(ARCH)/kernel
+CFLAGS_pal4_pci.o	+= -Iarch/$(ARCH)/kernel
 
 obj-$(CONFIG_APUS)		+= apus_setup.o
 ifeq ($(CONFIG_APUS),y)
diff -p -purN linux-2.5/arch/ppc/platforms/ev64260_setup.c linuxppc-2.5/arch/ppc/platforms/ev64260_setup.c
--- linux-2.5/arch/ppc/platforms/ev64260_setup.c	2003-09-12 18:26:53.000000000 +0200
+++ linuxppc-2.5/arch/ppc/platforms/ev64260_setup.c	2003-09-12 19:39:39.000000000 +0200
@@ -35,6 +35,7 @@
 #if	!defined(CONFIG_GT64260_CONSOLE)
 #include <linux/serial.h>
 #endif
+#include <linux/serial_core.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -184,7 +185,7 @@ static void __init
 ev64260_setup_arch(void)
 {
 #if	!defined(CONFIG_GT64260_CONSOLE)
-	struct serial_struct	serial_req;
+	struct uart_port port;
 #endif
 
 	if ( ppc_md.progress )
@@ -228,27 +229,25 @@ ev64260_setup_arch(void)
 	TODC_INIT(TODC_TYPE_DS1501, 0, 0, ioremap(EV64260_TODC_BASE,0x20), 8);
 
 #if	!defined(CONFIG_GT64260_CONSOLE)
-	memset(&serial_req, 0, sizeof(serial_req));
-	serial_req.line = 0;
-	serial_req.baud_base = BASE_BAUD;
-	serial_req.port = 0;
-	serial_req.irq = 85;
-	serial_req.flags = STD_COM_FLAGS;
-	serial_req.io_type = SERIAL_IO_MEM;
-	serial_req.iomem_base = ioremap(EV64260_SERIAL_0, 0x20);
-	serial_req.iomem_reg_shift = 2;
+	memset(&port, 0, sizeof(port));
+	port.membase = ioremap(EV64260_SERIAL_0, 0x20);
+	port.irq = 85;
+	port.uartclk = BASE_BAUD * 16;
+	port.regshift = 2;
+	port.flags = STD_COM_FLAGS;
+	port.iotype = SERIAL_IO_MEM;
+	port.line = 0;
 
-	if (early_serial_setup(&serial_req) != 0) {
+	if (early_serial_setup(&port) != 0) {
 		printk("Early serial init of port 0 failed\n");
 	}
 
 	/* Assume early_serial_setup() doesn't modify serial_req */
-	serial_req.line = 1;
-	serial_req.port = 1;
-	serial_req.irq = 86;
-	serial_req.iomem_base = ioremap(EV64260_SERIAL_1, 0x20);
+	port.membase = ioremap(EV64260_SERIAL_1, 0x20);
+	port.irq = 86;
+	port.line = 1;
 
-	if (early_serial_setup(&serial_req) != 0) {
+	if (early_serial_setup(&port) != 0) {
 		printk("Early serial init of port 1 failed\n");
 	}
 #endif
diff -p -purN linux-2.5/arch/ppc/syslib/Makefile linuxppc-2.5/arch/ppc/syslib/Makefile
--- linux-2.5/arch/ppc/syslib/Makefile	2003-09-03 14:16:34.000000000 +0200
+++ linuxppc-2.5/arch/ppc/syslib/Makefile	2003-09-03 14:58:45.000000000 +0200
@@ -20,6 +20,9 @@ obj-$(CONFIG_4xx)		+= ppc4xx_pic.o
 obj-$(CONFIG_40x)		+= ppc4xx_setup.o
 obj-$(CONFIG_GEN_RTC)		+= todc_time.o
 obj-$(CONFIG_KGDB)		+= ppc4xx_kgdb.o
+obj-$(CONFIG_PPC4xx_EDMA)	+= ppc4xx_sgdma.o
+obj-$(CONFIG_STBXXX_DMA)	+= ppc4xx_stbdma.o
+obj-$(CONFIG_PPC4xx_DMA)	+= ppc4xx_dma.o
 ifeq ($(CONFIG_40x),y)
 obj-$(CONFIG_KGDB)		+= ppc4xx_kgdb.o
 obj-$(CONFIG_PCI)		+= indirect_pci.o pci_auto.o ppc405_pci.o
diff -p -purN linux-2.5/arch/ppc/syslib/cpc700.h linuxppc-2.5/arch/ppc/syslib/cpc700.h
--- linux-2.5/arch/ppc/syslib/cpc700.h	2003-09-12 18:26:55.000000000 +0200
+++ linuxppc-2.5/arch/ppc/syslib/cpc700.h	2003-09-12 19:39:40.000000000 +0200
@@ -17,13 +17,14 @@
  * memory controller, PIC, UARTs, IIC, and Timers.
  */
 
-#ifndef	_ASMPPC_CPC700_H
-#define	_ASMPPC_CPC700_H
+#ifndef	__PPC_SYSLIB_CPC700_H__
+#define	__PPC_SYSLIB_CPC700_H__
 
 #include <linux/stddef.h>
 #include <linux/types.h>
 #include <linux/init.h>
 
+/* XXX no barriers? not even any volatiles?  -- paulus */
 #define CPC700_OUT_32(a,d)  (*(u_int *)a = d)
 #define CPC700_IN_32(a)     (*(u_int *)a)
 
@@ -33,21 +34,26 @@
 #define CPC700_PCI_CONFIG_ADDR          0xfec00000
 #define CPC700_PCI_CONFIG_DATA          0xfec00004
 
-#define CPC700_PMM0_LOCAL		0xff400000
-#define CPC700_PMM0_MASK_ATTR		0xff400004
-#define CPC700_PMM0_PCI_LOW		0xff400008
-#define CPC700_PMM0_PCI_HIGH		0xff40000c
+/* CPU -> PCI memory window 0 */
+#define CPC700_PMM0_LOCAL		0xff400000	/* CPU physical addr */
+#define CPC700_PMM0_MASK_ATTR		0xff400004	/* size and attrs */
+#define CPC700_PMM0_PCI_LOW		0xff400008	/* PCI addr, low word */
+#define CPC700_PMM0_PCI_HIGH		0xff40000c	/* PCI addr, high wd */
+/* CPU -> PCI memory window 1 */
 #define CPC700_PMM1_LOCAL		0xff400010
 #define CPC700_PMM1_MASK_ATTR		0xff400014
 #define CPC700_PMM1_PCI_LOW		0xff400018
 #define CPC700_PMM1_PCI_HIGH		0xff40001c
+/* CPU -> PCI memory window 2 */
 #define CPC700_PMM2_LOCAL		0xff400020
 #define CPC700_PMM2_MASK_ATTR		0xff400024
 #define CPC700_PMM2_PCI_LOW		0xff400028
 #define CPC700_PMM2_PCI_HIGH		0xff40002c
-#define CPC700_PTM1_MEMSIZE		0xff400030
-#define CPC700_PTM1_LOCAL		0xff400034
-#define CPC700_PTM2_MEMSIZE		0xff400038
+/* PCI memory -> CPU window 1 */
+#define CPC700_PTM1_MEMSIZE		0xff400030	/* window size */
+#define CPC700_PTM1_LOCAL		0xff400034	/* CPU phys addr */
+/* PCI memory -> CPU window 2 */
+#define CPC700_PTM2_MEMSIZE		0xff400038	/* size and enable */
 #define CPC700_PTM2_LOCAL		0xff40003c
 
 /*
@@ -89,4 +95,4 @@ extern unsigned int cpc700_irq_assigns[3
 extern void __init cpc700_init_IRQ(void);
 extern int cpc700_get_irq(struct pt_regs *);
 
-#endif	/* _ASMPPC_CPC700_H */
+#endif	/* __PPC_SYSLIB_CPC700_H__ */
diff -p -purN linux-2.5/arch/ppc/syslib/open_pic.c linuxppc-2.5/arch/ppc/syslib/open_pic.c
--- linux-2.5/arch/ppc/syslib/open_pic.c	2003-09-12 18:26:55.000000000 +0200
+++ linuxppc-2.5/arch/ppc/syslib/open_pic.c	2003-09-12 19:39:40.000000000 +0200
@@ -611,11 +611,14 @@ void openpic_request_IPIs(void)
 void __devinit do_openpic_setup_cpu(void)
 {
  	int i;
-	u32 msk = 1 << smp_hw_index[smp_processor_id()];
-
+#ifdef CONFIG_IRQ_ALL_CPUS
+	u32 msk;
+#endif
 	spin_lock(&openpic_setup_lock);
 
 #ifdef CONFIG_IRQ_ALL_CPUS
+	msk = 1 << smp_hw_index[smp_processor_id()];
+
  	/* let the openpic know we want intrs. default affinity
  	 * is 0xffffffff until changed via /proc
  	 * That's how it's done on x86. If we want it differently, then
diff -p -purN linux-2.5/arch/ppc/syslib/ppc4xx_dma.c linuxppc-2.5/arch/ppc/syslib/ppc4xx_dma.c
--- linux-2.5/arch/ppc/syslib/ppc4xx_dma.c	2003-09-12 18:26:55.000000000 +0200
+++ linuxppc-2.5/arch/ppc/syslib/ppc4xx_dma.c	2003-09-12 19:45:00.000000000 +0200
@@ -1,42 +1,586 @@
 /*
- * Author: Pete Popov <ppopov@mvista.com> or source@mvista.com
+ * arch/ppc/kernel/ppc4xx_dma.c
  *
- * arch/ppc/kernel/ppc405_dma.c
+ * IBM PPC4xx DMA engine core library
  *
- * 2000 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
+ * Copyright 2000-2003 MontaVista Software Inc.
  *
- * IBM 405 DMA Controller Functions
+ * Cleaned by Matt Porter <mporter@mvista.com>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <asm/system.h>
-#include <asm/io.h>
 #include <linux/mm.h>
 #include <linux/miscdevice.h>
 #include <linux/init.h>
 #include <linux/module.h>
 
-#include <asm/ppc405_dma.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_dma.h>
+
+ppc_dma_ch_t dma_channels[MAX_PPC4xx_DMA_CHANNELS];
+
+int
+ppc4xx_get_dma_status(void)
+{
+	return (mfdcr(DCRN_DMASR));
+}
+
+void
+ppc4xx_set_src_addr(int dmanr, phys_addr_t src_addr)
+{
+	switch (dmanr) {
+		case 0:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMASAH0, (u32)(src_addr >> 32));
+#endif
+			mtdcr(DCRN_DMASA0, (u32)src_addr);
+			break;
+		case 1:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMASAH1, (u32)(src_addr >> 32));
+#endif
+			mtdcr(DCRN_DMASA1, (u32)src_addr);
+			break;
+		case 2:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMASAH2, (u32)(src_addr >> 32));
+#endif
+			mtdcr(DCRN_DMASA2, (u32)src_addr);
+			break;
+		case 3:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMASAH3, (u32)(src_addr >> 32));
+#endif
+			mtdcr(DCRN_DMASA3, (u32)src_addr);
+			break;
+		default:
+			if (dmanr >= MAX_PPC4xx_DMA_CHANNELS)
+				printk("set_src_addr: bad channel: %d\n", dmanr);
+	}
+}
+
+void
+ppc4xx_set_dst_addr(int dmanr, phys_addr_t dst_addr)
+{
+	switch (dmanr) {
+		case 0:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMADAH0, (u32)(dst_addr >> 32));
+#endif
+			mtdcr(DCRN_DMADA0, (u32)dst_addr);
+			break;
+		case 1:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMADAH1, (u32)(dst_addr >> 32));
+#endif
+			mtdcr(DCRN_DMADA1, (u32)dst_addr);
+			break;
+		case 2:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMADAH2, (u32)(dst_addr >> 32));
+#endif
+			mtdcr(DCRN_DMADA2, (u32)dst_addr);
+			break;
+		case 3:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMADAH3, (u32)(dst_addr >> 32));
+#endif
+			mtdcr(DCRN_DMADA3, (u32)dst_addr);
+			break;
+		default:
+			if (dmanr >= MAX_PPC4xx_DMA_CHANNELS)
+				printk("set_dst_addr: bad channel: %d\n", dmanr);
+	}
+}
+
+
+void
+ppc4xx_enable_dma(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	unsigned int status_bits[] = { DMA_CS0 | DMA_TS0 | DMA_CH0_ERR,
+				       DMA_CS1 | DMA_TS1 | DMA_CH1_ERR,
+				       DMA_CS2 | DMA_TS2 | DMA_CH2_ERR,
+				       DMA_CS3 | DMA_TS3 | DMA_CH3_ERR};
+
+	if (p_dma_ch->in_use) {
+		printk("enable_dma: channel %d in use\n", dmanr);
+		return;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("enable_dma: bad channel: %d\n", dmanr);
+		return;
+	}
+
+	if (p_dma_ch->mode == DMA_MODE_READ) {
+		/* peripheral to memory */
+		ppc4xx_set_src_addr(dmanr, 0);
+		ppc4xx_set_dst_addr(dmanr, p_dma_ch->addr);
+	} else if (p_dma_ch->mode == DMA_MODE_WRITE) {
+		/* memory to peripheral */
+		ppc4xx_set_src_addr(dmanr, p_dma_ch->addr);
+		ppc4xx_set_dst_addr(dmanr, 0);
+	}
+
+	/* for other xfer modes, the addresses are already set */
+	switch (dmanr) {
+		case 0:
+			control = mfdcr(DCRN_DMACR0);
+			break;
+		case 1:
+			control = mfdcr(DCRN_DMACR1);
+			break;
+		case 2:
+			control = mfdcr(DCRN_DMACR2);
+			break;
+		case 3:
+			control = mfdcr(DCRN_DMACR3);
+			break;
+		default:
+			printk("enable_dma: bad channel: %d\n", dmanr);
+	}
+
+	control &= ~(DMA_TM_MASK | DMA_TD);	/* clear all mode bits */
+	if (p_dma_ch->mode == DMA_MODE_MM) {
+		/* software initiated memory to memory */
+		control |= DMA_ETD_OUTPUT | DMA_TCE_ENABLE;
+	}
+
+	switch (dmanr) {
+		case 0:
+			mtdcr(DCRN_DMACR0, control);
+			break;
+		case 1:
+			mtdcr(DCRN_DMACR1, control);
+			break;
+		case 2:
+			mtdcr(DCRN_DMACR2, control);
+			break;
+		case 3:
+			mtdcr(DCRN_DMACR3, control);
+			break;
+		default:
+			printk("enable_dma: bad channel: %d\n", dmanr);
+	}
+
+	/*
+	 * Clear the CS, TS, RI bits for the channel from DMASR.  This
+	 * has been observed to happen correctly only after the mode and
+	 * ETD/DCE bits in DMACRx are set above.  Must do this before
+	 * enabling the channel.
+	 */
+
+	mtdcr(DCRN_DMASR, status_bits[dmanr]);
+
+	/*
+	 * For device-paced transfers, Terminal Count Enable apparently
+	 * must be on, and this must be turned on after the mode, etc.
+	 * bits are cleared above (at least on Redwood-6).
+	 */
+
+	if ((p_dma_ch->mode == DMA_MODE_MM_DEVATDST) ||
+	    (p_dma_ch->mode == DMA_MODE_MM_DEVATSRC))
+		control |= DMA_TCE_ENABLE;
+
+	/*
+	 * Now enable the channel.
+	 */
+
+	control |= (p_dma_ch->mode | DMA_CE_ENABLE);
+
+	switch (dmanr) {
+		case 0:
+			mtdcr(DCRN_DMACR0, control);
+			break;
+		case 1:
+			mtdcr(DCRN_DMACR1, control);
+			break;
+		case 2:
+			mtdcr(DCRN_DMACR2, control);
+			break;
+		case 3:
+			mtdcr(DCRN_DMACR3, control);
+			break;
+		default:
+			printk("enable_dma: bad channel: %d\n", dmanr);
+	}
+
+	p_dma_ch->in_use = 1;
+}
+
+void
+ppc4xx_disable_dma(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (!p_dma_ch->in_use) {
+		printk("disable_dma: channel %d not in use\n", dmanr);
+		return;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("disable_dma: bad channel: %d\n", dmanr);
+		return;
+	}
+
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		control &= ~DMA_CE_ENABLE;
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		control &= ~DMA_CE_ENABLE;
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		control &= ~DMA_CE_ENABLE;
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		control &= ~DMA_CE_ENABLE;
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		printk("disable_dma: bad channel: %d\n", dmanr);
+	}
+
+	p_dma_ch->in_use = 0;
+}
+
+/*
+ * Sets the dma mode for single DMA transfers only.
+ * For scatter/gather transfers, the mode is passed to the
+ * alloc_dma_handle() function as one of the parameters.
+ *
+ * The mode is simply saved and used later.  This allows
+ * the driver to call set_dma_mode() and set_dma_addr() in
+ * any order.
+ *
+ * Valid mode values are:
+ *
+ * DMA_MODE_READ          peripheral to memory
+ * DMA_MODE_WRITE         memory to peripheral
+ * DMA_MODE_MM            memory to memory
+ * DMA_MODE_MM_DEVATSRC   device-paced memory to memory, device at src
+ * DMA_MODE_MM_DEVATDST   device-paced memory to memory, device at dst
+ */
+int
+ppc4xx_set_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("set_dma_mode: bad channel 0x%x\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	p_dma_ch->mode = mode;
+
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Sets the DMA Count register. Note that 'count' is in bytes.
+ * However, the DMA Count register counts the number of "transfers",
+ * where each transfer is equal to the bus width.  Thus, count
+ * MUST be a multiple of the bus width.
+ */
+void
+ppc4xx_set_dma_count(unsigned int dmanr, unsigned int count)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if (count & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if (count & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if (count & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("set_dma_count: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return;
+		}
+		if (error)
+			printk
+			    ("Warning: set_dma_count count 0x%x bus width %d\n",
+			     count, p_dma_ch->pwidth);
+	}
+#endif
+
+	count = count >> p_dma_ch->shift;
+	switch (dmanr) {
+	case 0:
+		mtdcr(DCRN_DMACT0, count);
+		break;
+	case 1:
+		mtdcr(DCRN_DMACT1, count);
+		break;
+	case 2:
+		mtdcr(DCRN_DMACT2, count);
+		break;
+	case 3:
+		mtdcr(DCRN_DMACT3, count);
+		break;
+	default:
+		printk("ppc4xx_set_dma_count: bad channel: %d\n", dmanr);
+	}
+}
+
+/*
+ *   Returns the number of bytes left to be transfered.
+ *   After a DMA transfer, this should return zero.
+ *   Reading this while a DMA transfer is still in progress will return
+ *   unpredictable results.
+ */
+int
+ppc4xx_get_dma_residue(unsigned int dmanr)
+{
+	unsigned int count;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	switch (dmanr) {
+	case 0:
+		count = mfdcr(DCRN_DMACT0);
+		break;
+	case 1:
+		count = mfdcr(DCRN_DMACT1);
+		break;
+	case 2:
+		count = mfdcr(DCRN_DMACT2);
+		break;
+	case 3:
+		count = mfdcr(DCRN_DMACT3);
+		break;
+	default:
+		printk("ppc4xx_get_dma_residue: bad channel: %d\n", dmanr);
+		return 0;
+	}
+
+	return (count << p_dma_ch->shift);
+}
+
+/*
+ * Sets the DMA address for a memory to peripheral or peripheral
+ * to memory transfer.  The address is just saved in the channel
+ * structure for now and used later in enable_dma().
+ */
+void
+ppc4xx_set_dma_addr(unsigned int dmanr, phys_addr_t addr)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_set_dma_addr: bad channel: %d\n", dmanr);
+		return;
+	}
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if ((unsigned) addr & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if ((unsigned) addr & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if ((unsigned) addr & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("ppc4xx_set_dma_addr: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return;
+		}
+		if (error)
+			printk("Warning: ppc4xx_set_dma_addr addr 0x%x bus width %d\n",
+			       addr, p_dma_ch->pwidth);
+	}
+#endif
+
+	/* save dma address and program it later after we know the xfer mode */
+	p_dma_ch->addr = addr;
+}
+
+/*
+ * Sets both DMA addresses for a memory to memory transfer.
+ * For memory to peripheral or peripheral to memory transfers
+ * the function set_dma_addr() should be used instead.
+ */
+void
+ppc4xx_set_dma_addr2(unsigned int dmanr, phys_addr_t src_dma_addr,
+		     phys_addr_t dst_dma_addr)
+{
+#ifdef DEBUG_4xxDMA
+	{
+		ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+			case PW_8:
+				break;
+			case PW_16:
+				if (((unsigned) src_dma_addr & 0x1) ||
+						((unsigned) dst_dma_addr & 0x1)
+				   )
+					error = 1;
+				break;
+			case PW_32:
+				if (((unsigned) src_dma_addr & 0x3) ||
+						((unsigned) dst_dma_addr & 0x3)
+				   )
+					error = 1;
+				break;
+			case PW_64:
+				if (((unsigned) src_dma_addr & 0x7) ||
+						((unsigned) dst_dma_addr & 0x7)
+				   )
+					error = 1;
+				break;
+			default:
+				printk("ppc4xx_set_dma_addr2: invalid bus width: 0x%x\n",
+						p_dma_ch->pwidth);
+				return;
+		}
+		if (error)
+			printk
+				("Warning: ppc4xx_set_dma_addr2 src 0x%x dst 0x%x bus width %d\n",
+				 src_dma_addr, dst_dma_addr, p_dma_ch->pwidth);
+	}
+#endif
 
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_set_dma_addr2: bad channel: %d\n", dmanr);
+	}
+	else {
+		ppc4xx_set_src_addr(dmanr, src_dma_addr);
+		ppc4xx_set_dst_addr(dmanr, dst_dma_addr);
+	}
+}
 
 /*
- * Function prototypes
+ * Enables the channel interrupt.
+ *
+ * If performing a scatter/gatter transfer, this function
+ * MUST be called before calling alloc_dma_handle() and building
+ * the sgl list.  Otherwise, interrupts will not be enabled, if
+ * they were previously disabled.
  */
+int
+ppc4xx_enable_dma_interrupt(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
 
-int hw_init_dma_channel(unsigned int,  ppc_dma_ch_t *);
-int init_dma_channel(unsigned int);
-int get_channel_config(unsigned int, ppc_dma_ch_t *);
-int set_channel_priority(unsigned int, unsigned int);
-unsigned int get_peripheral_width(unsigned int);
-int alloc_dma_handle(sgl_handle_t *, unsigned int, unsigned int);
-void free_dma_handle(sgl_handle_t);
+	p_dma_ch->int_enable = 1;
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		control |= DMA_CIE_ENABLE;	/* Channel Interrupt Enable */
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		control |= DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		control |= DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		control |= DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		printk("ppc4xx_enable_dma_interrupt: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
 
+/*
+ * Disables the channel interrupt.
+ *
+ * If performing a scatter/gatter transfer, this function
+ * MUST be called before calling alloc_dma_handle() and building
+ * the sgl list.  Otherwise, interrupts will not be disabled, if
+ * they were previously enabled.
+ */
+int
+ppc4xx_disable_dma_interrupt(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
 
-ppc_dma_ch_t dma_channels[MAX_405GP_DMA_CHANNELS];
+	p_dma_ch->int_enable = 0;
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		control &= ~DMA_CIE_ENABLE;	/* Channel Interrupt Enable */
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		control &= ~DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		control &= ~DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		control &= ~DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		printk("ppc4xx_disable_dma_interrupt: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * Configures a DMA channel, including the peripheral bus width, if a
@@ -47,166 +591,155 @@ ppc_dma_ch_t dma_channels[MAX_405GP_DMA_
  * called from platform specific init code.  The driver should not need to
  * call this function.
  */
-int hw_init_dma_channel(unsigned int dmanr,  ppc_dma_ch_t *p_init)
+int
+ppc4xx_init_dma_channel(unsigned int dmanr, ppc_dma_ch_t * p_init)
 {
-    unsigned int polarity;
-    uint32_t control = 0;
-    ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-#ifdef DEBUG_405DMA
-    if (!p_init) {
-        printk("hw_init_dma_channel: NULL p_init\n");
-        return DMA_STATUS_NULL_POINTER;
-    }
-    if (dmanr >= MAX_405GP_DMA_CHANNELS) {
-        printk("hw_init_dma_channel: bad channel %d\n", dmanr);
-        return DMA_STATUS_BAD_CHANNEL;
-    }
-#endif
+	unsigned int polarity;
+	uint32_t control = 0;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	DMA_MODE_READ = (unsigned long) DMA_TD;	/* Peripheral to Memory */
+	DMA_MODE_WRITE = 0;	/* Memory to Peripheral */
+
+	if (!p_init) {
+		printk("ppc4xx_init_dma_channel: NULL p_init\n");
+		return DMA_STATUS_NULL_POINTER;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_init_dma_channel: bad channel %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
 #if DCRN_POL > 0
-    polarity = mfdcr(DCRN_POL);
+	polarity = mfdcr(DCRN_POL);
 #else
-    polarity = 0;
+	polarity = 0;
 #endif
 
-    /* Setup the control register based on the values passed to
-     * us in p_init.  Then, over-write the control register with this
-     * new value.
-     */
-
-    control |= (
-                SET_DMA_CIE_ENABLE(p_init->int_enable) | /* interrupt enable         */
-                SET_DMA_BEN(p_init->buffer_enable)     | /* buffer enable            */
-                SET_DMA_ETD(p_init->etd_output)        | /* end of transfer pin      */
-                SET_DMA_TCE(p_init->tce_enable)        | /* terminal count enable    */
-                SET_DMA_PL(p_init->pl)                 | /* peripheral location      */
-                SET_DMA_DAI(p_init->dai)               | /* dest addr increment      */
-                SET_DMA_SAI(p_init->sai)               | /* src addr increment       */
-                SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */
-                SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */
-                SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */
-                SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */
-                SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */
-                SET_DMA_PREFETCH(p_init->pf)              /* read prefetch           */
-                );
-
-    switch (dmanr) {
-        case 0:
-            /* clear all polarity signals and then "or" in new signal levels */
-            polarity &= ~(DMAReq0_ActiveLow | DMAAck0_ActiveLow | EOT0_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+	/* Setup the control register based on the values passed to
+	 * us in p_init.  Then, over-write the control register with this
+	 * new value.
+	 */
+	control |= SET_DMA_CONTROL;
+
+	switch (dmanr) {
+	case 0:
+		/* clear all polarity signals and then "or" in new signal levels */
+		polarity &= ~GET_DMA_POLARITY(0);
+		polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+		mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR0, control);
-            break;
-        case 1:
-            polarity &= ~(DMAReq1_ActiveLow | DMAAck1_ActiveLow | EOT1_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		polarity &= ~GET_DMA_POLARITY(1);
+		polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+		mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR1, control);
-            break;
-        case 2:
-            polarity &= ~(DMAReq2_ActiveLow | DMAAck2_ActiveLow | EOT2_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		polarity &= ~GET_DMA_POLARITY(2);
+		polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+		mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR2, control);
-            break;
-        case 3:
-            polarity &= ~(DMAReq3_ActiveLow | DMAAck3_ActiveLow | EOT3_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		polarity &= ~GET_DMA_POLARITY(3);
+		polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+		mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR3, control);
-            break;
-        default:
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    /* save these values in our dma channel structure */
-    memcpy(p_dma_ch, p_init, sizeof(ppc_dma_ch_t));
-
-    /*
-     * The peripheral width values written in the control register are:
-     *   PW_8                 0
-     *   PW_16                1
-     *   PW_32                2
-     *   PW_64                3
-     *
-     *   Since the DMA count register takes the number of "transfers",
-     *   we need to divide the count sent to us in certain
-     *   functions by the appropriate number.  It so happens that our
-     *   right shift value is equal to the peripheral width value.
-     */
-    p_dma_ch->shift = p_init->pwidth;
-
-    /*
-     * Save the control word for easy access.
-     */
-    p_dma_ch->control = control;
-
-    mtdcr(DCRN_DMASR, 0xffffffff); /* clear status register */
-    return DMA_STATUS_GOOD;
-}
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
+	/* save these values in our dma channel structure */
+	memcpy(p_dma_ch, p_init, sizeof (ppc_dma_ch_t));
 
+	/*
+	 * The peripheral width values written in the control register are:
+	 *   PW_8                 0
+	 *   PW_16                1
+	 *   PW_32                2
+	 *   PW_64                3
+	 *
+	 *   Since the DMA count register takes the number of "transfers",
+	 *   we need to divide the count sent to us in certain
+	 *   functions by the appropriate number.  It so happens that our
+	 *   right shift value is equal to the peripheral width value.
+	 */
+	p_dma_ch->shift = p_init->pwidth;
+
+	/*
+	 * Save the control word for easy access.
+	 */
+	p_dma_ch->control = control;
 
+	mtdcr(DCRN_DMASR, 0xffffffff);	/* clear status register */
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * This function returns the channel configuration.
  */
-int get_channel_config(unsigned int dmanr, ppc_dma_ch_t *p_dma_ch)
+int
+ppc4xx_get_channel_config(unsigned int dmanr, ppc_dma_ch_t * p_dma_ch)
 {
-    unsigned int polarity;
-    unsigned int control;
+	unsigned int polarity;
+	unsigned int control;
 
 #if DCRN_POL > 0
-    polarity = mfdcr(DCRN_POL);
+	polarity = mfdcr(DCRN_POL);
 #else
-    polarity = 0;
+	polarity = 0;
 #endif
 
-    switch (dmanr) {
-        case 0:
-            p_dma_ch->polarity =
-                polarity & (DMAReq0_ActiveLow | DMAAck0_ActiveLow | EOT0_ActiveLow);
-            control = mfdcr(DCRN_DMACR0);
-            break;
-        case 1:
-            p_dma_ch->polarity =
-                polarity & (DMAReq1_ActiveLow | DMAAck1_ActiveLow | EOT1_ActiveLow);
-            control = mfdcr(DCRN_DMACR1);
-            break;
-        case 2:
-            p_dma_ch->polarity =
-                polarity & (DMAReq2_ActiveLow | DMAAck2_ActiveLow | EOT2_ActiveLow);
-            control = mfdcr(DCRN_DMACR2);
-            break;
-        case 3:
-            p_dma_ch->polarity =
-                polarity & (DMAReq3_ActiveLow | DMAAck3_ActiveLow | EOT3_ActiveLow);
-            control = mfdcr(DCRN_DMACR3);
-            break;
-        default:
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    p_dma_ch->cp = GET_DMA_PRIORITY(control);
-    p_dma_ch->pwidth = GET_DMA_PW(control);
-    p_dma_ch->psc = GET_DMA_PSC(control);
-    p_dma_ch->pwc = GET_DMA_PWC(control);
-    p_dma_ch->phc = GET_DMA_PHC(control);
-    p_dma_ch->pf = GET_DMA_PREFETCH(control);
-    p_dma_ch->int_enable = GET_DMA_CIE_ENABLE(control);
-    p_dma_ch->shift = GET_DMA_PW(control);
+	switch (dmanr) {
+	case 0:
+		p_dma_ch->polarity = polarity & GET_DMA_POLARITY(0);
+		control = mfdcr(DCRN_DMACR0);
+		break;
+	case 1:
+		p_dma_ch->polarity = polarity & GET_DMA_POLARITY(1);
+		control = mfdcr(DCRN_DMACR1);
+		break;
+	case 2:
+		p_dma_ch->polarity = polarity & GET_DMA_POLARITY(2);
+		control = mfdcr(DCRN_DMACR2);
+		break;
+	case 3:
+		p_dma_ch->polarity = polarity & GET_DMA_POLARITY(3);
+		control = mfdcr(DCRN_DMACR3);
+		break;
+	default:
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
-    return DMA_STATUS_GOOD;
+	p_dma_ch->cp = GET_DMA_PRIORITY(control);
+	p_dma_ch->pwidth = GET_DMA_PW(control);
+	p_dma_ch->psc = GET_DMA_PSC(control);
+	p_dma_ch->pwc = GET_DMA_PWC(control);
+	p_dma_ch->phc = GET_DMA_PHC(control);
+	p_dma_ch->ce = GET_DMA_CE_ENABLE(control);
+	p_dma_ch->int_enable = GET_DMA_CIE_ENABLE(control);
+	p_dma_ch->shift = GET_DMA_PW(control);
+
+#ifdef CONFIG_PPC4xx_EDMA
+	p_dma_ch->pf = GET_DMA_PREFETCH(control);
+#else
+	p_dma_ch->ch_enable = GET_DMA_CH(control);
+	p_dma_ch->ece_enable = GET_DMA_ECE(control);
+	p_dma_ch->tcd_disable = GET_DMA_TCD(control);
+#endif
+	return DMA_STATUS_GOOD;
 }
 
 /*
@@ -222,50 +755,44 @@ int get_channel_config(unsigned int dman
  * PRIORITY_HIGH
  *
  */
-int set_channel_priority(unsigned int dmanr, unsigned int priority)
+int
+ppc4xx_set_channel_priority(unsigned int dmanr, unsigned int priority)
 {
-    unsigned int control;
-
-#ifdef DEBUG_405DMA
-    if ( (priority != PRIORITY_LOW) &&
-            (priority != PRIORITY_MID_LOW) &&
-            (priority != PRIORITY_MID_HIGH) &&
-            (priority != PRIORITY_HIGH)) {
-        printk("set_channel_priority: bad priority: 0x%x\n", priority);
-    }
-#endif
-
-    switch (dmanr) {
-        case 0:
-            control = mfdcr(DCRN_DMACR0);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR0, control);
-            break;
-        case 1:
-            control = mfdcr(DCRN_DMACR1);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR1, control);
-            break;
-        case 2:
-            control = mfdcr(DCRN_DMACR2);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR2, control);
-            break;
-        case 3:
-            control = mfdcr(DCRN_DMACR3);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR3, control);
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("set_channel_priority: bad channel: %d\n", dmanr);
-#endif
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-    return DMA_STATUS_GOOD;
-}
+	unsigned int control;
 
+	if ((priority != PRIORITY_LOW) &&
+	    (priority != PRIORITY_MID_LOW) &&
+	    (priority != PRIORITY_MID_HIGH) && (priority != PRIORITY_HIGH)) {
+		printk("ppc4xx_set_channel_priority: bad priority: 0x%x\n", priority);
+	}
 
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		control |= SET_DMA_PRIORITY(priority);
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		control |= SET_DMA_PRIORITY(priority);
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		control |= SET_DMA_PRIORITY(priority);
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		control |= SET_DMA_PRIORITY(priority);
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		printk("ppc4xx_set_channel_priority: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * Returns the width of the peripheral attached to this channel. This assumes
@@ -280,213 +807,46 @@ int set_channel_priority(unsigned int dm
  *
  *   The function returns 0 on error.
  */
-unsigned int get_peripheral_width(unsigned int dmanr)
+unsigned int
+ppc4xx_get_peripheral_width(unsigned int dmanr)
 {
-    unsigned int control;
-
-    switch (dmanr) {
-        case 0:
-            control = mfdcr(DCRN_DMACR0);
-            break;
-        case 1:
-            control = mfdcr(DCRN_DMACR1);
-            break;
-        case 2:
-            control = mfdcr(DCRN_DMACR2);
-            break;
-        case 3:
-            control = mfdcr(DCRN_DMACR3);
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("get_peripheral_width: bad channel: %d\n", dmanr);
-#endif
-            return 0;
-    }
-    return(GET_DMA_PW(control));
-}
-
-
-
-
-/*
- *   Create a scatter/gather list handle.  This is simply a structure which
- *   describes a scatter/gather list.
- *
- *   A handle is returned in "handle" which the driver should save in order to
- *   be able to access this list later.  A chunk of memory will be allocated
- *   to be used by the API for internal management purposes, including managing
- *   the sg list and allocating memory for the sgl descriptors.  One page should
- *   be more than enough for that purpose.  Perhaps it's a bit wasteful to use
- *   a whole page for a single sg list, but most likely there will be only one
- *   sg list per channel.
- *
- *   Interrupt notes:
- *   Each sgl descriptor has a copy of the DMA control word which the DMA engine
- *   loads in the control register.  The control word has a "global" interrupt
- *   enable bit for that channel. Interrupts are further qualified by a few bits
- *   in the sgl descriptor count register.  In order to setup an sgl, we have to
- *   know ahead of time whether or not interrupts will be enabled at the completion
- *   of the transfers.  Thus, enable_dma_interrupt()/disable_dma_interrupt() MUST
- *   be called before calling alloc_dma_handle().  If the interrupt mode will never
- *   change after powerup, then enable_dma_interrupt()/disable_dma_interrupt()
- *   do not have to be called -- interrupts will be enabled or disabled based
- *   on how the channel was configured after powerup by the hw_init_dma_channel()
- *   function.  Each sgl descriptor will be setup to interrupt if an error occurs;
- *   however, only the last descriptor will be setup to interrupt. Thus, an
- *   interrupt will occur (if interrupts are enabled) only after the complete
- *   sgl transfer is done.
- */
-int alloc_dma_handle(sgl_handle_t *phandle, unsigned int mode, unsigned int dmanr)
-{
-    sgl_list_info_t *psgl;
-    dma_addr_t dma_addr;
-    ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-    uint32_t sg_command;
-    void *ret;
-
-#ifdef DEBUG_405DMA
-    if (!phandle) {
-            printk("alloc_dma_handle: null handle pointer\n");
-            return DMA_STATUS_NULL_POINTER;
-    }
-    switch (mode) {
-        case DMA_MODE_READ:
-        case DMA_MODE_WRITE:
-        case DMA_MODE_MM:
-        case DMA_MODE_MM_DEVATSRC:
-        case DMA_MODE_MM_DEVATDST:
-            break;
-        default:
-            printk("alloc_dma_handle: bad mode 0x%x\n", mode);
-            return DMA_STATUS_BAD_MODE;
-    }
-    if (dmanr >= MAX_405GP_DMA_CHANNELS) {
-        printk("alloc_dma_handle: invalid channel 0x%x\n", dmanr);
-        return DMA_STATUS_BAD_CHANNEL;
-    }
-#endif
-
-    /* Get a page of memory, which is zeroed out by pci_alloc_consistent() */
-
-/* wrong not a pci device - armin */
-    /* psgl = (sgl_list_info_t *) pci_alloc_consistent(NULL, SGL_LIST_SIZE, &dma_addr);
-*/
-
-	ret = consistent_alloc(GFP_ATOMIC |GFP_DMA, SGL_LIST_SIZE, &dma_addr);
-	if (ret != NULL) {
-		memset(ret, 0,SGL_LIST_SIZE );
-		psgl = (sgl_list_info_t *) ret;
-	}
-
-
-    if (psgl == NULL) {
-        *phandle = (sgl_handle_t)NULL;
-        return DMA_STATUS_OUT_OF_MEMORY;
-    }
-
-    psgl->dma_addr = dma_addr;
-    psgl->dmanr = dmanr;
-
-    /*
-     * Modify and save the control word. These word will get written to each sgl
-     * descriptor.  The DMA engine then loads this control word into the control
-     * register every time it reads a new descriptor.
-     */
-    psgl->control = p_dma_ch->control;
-    psgl->control &= ~(DMA_TM_MASK | DMA_TD);  /* clear all "mode" bits first               */
-    psgl->control |= (mode | DMA_CH_ENABLE);   /* save the control word along with the mode */
-
-    if (p_dma_ch->int_enable) {
-        psgl->control |= DMA_CIE_ENABLE;       /* channel interrupt enabled                 */
-    }
-    else {
-        psgl->control &= ~DMA_CIE_ENABLE;
-    }
-
-#if DCRN_ASGC > 0
-    sg_command = mfdcr(DCRN_ASGC);
-    switch (dmanr) {
-        case 0:
-            sg_command |= SSG0_MASK_ENABLE;
-            break;
-        case 1:
-            sg_command |= SSG1_MASK_ENABLE;
-            break;
-        case 2:
-            sg_command |= SSG2_MASK_ENABLE;
-            break;
-        case 3:
-            sg_command |= SSG3_MASK_ENABLE;
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("alloc_dma_handle: bad channel: %d\n", dmanr);
-#endif
-            free_dma_handle((sgl_handle_t)psgl);
-            *phandle = (sgl_handle_t)NULL;
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    mtdcr(DCRN_ASGC, sg_command);  /* enable writing to this channel's sgl control bits */
-#else
-   (void)sg_command;
-#endif
-    psgl->sgl_control = SG_ERI_ENABLE | SG_LINK;   /* sgl descriptor control bits */
-
-    if (p_dma_ch->int_enable) {
-        if (p_dma_ch->tce_enable)
-            psgl->sgl_control |= SG_TCI_ENABLE;
-        else
-            psgl->sgl_control |= SG_ETI_ENABLE;
-    }
-
-    *phandle = (sgl_handle_t)psgl;
-    return DMA_STATUS_GOOD;
-}
-
-
-
-/*
- * Destroy a scatter/gather list handle that was created by alloc_dma_handle().
- * The list must be empty (contain no elements).
- */
-void free_dma_handle(sgl_handle_t handle)
-{
-    sgl_list_info_t *psgl = (sgl_list_info_t *)handle;
-
-    if (!handle) {
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: got NULL\n");
-#endif
-        return;
-    }
-    else if (psgl->phead) {
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: list not empty\n");
-#endif
-        return;
-    }
-    else if (!psgl->dma_addr) { /* should never happen */
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: no dma address\n");
-#endif
-        return;
-    }
-
-  /* wrong not a PCI device -armin */
-  /*  pci_free_consistent(NULL, SGL_LIST_SIZE, (void *)psgl, psgl->dma_addr); */
-	//	free_pages((unsigned long)psgl, get_order(SGL_LIST_SIZE));
-    	consistent_free((void *)psgl);
-
+	unsigned int control;
 
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		break;
+	default:
+		printk("ppc4xx_get_peripheral_width: bad channel: %d\n", dmanr);
+		return 0;
+	}
+	return (GET_DMA_PW(control));
 }
 
 
-EXPORT_SYMBOL(hw_init_dma_channel);
-EXPORT_SYMBOL(get_channel_config);
-EXPORT_SYMBOL(set_channel_priority);
-EXPORT_SYMBOL(get_peripheral_width);
-EXPORT_SYMBOL(alloc_dma_handle);
-EXPORT_SYMBOL(free_dma_handle);
+EXPORT_SYMBOL(ppc4xx_init_dma_channel);
+EXPORT_SYMBOL(ppc4xx_get_channel_config);
+EXPORT_SYMBOL(ppc4xx_set_channel_priority);
+EXPORT_SYMBOL(ppc4xx_get_peripheral_width);
 EXPORT_SYMBOL(dma_channels);
+EXPORT_SYMBOL(ppc4xx_set_src_addr);
+EXPORT_SYMBOL(ppc4xx_set_dst_addr);
+EXPORT_SYMBOL(ppc4xx_set_dma_addr);
+EXPORT_SYMBOL(ppc4xx_set_dma_addr2);
+EXPORT_SYMBOL(ppc4xx_enable_dma);
+EXPORT_SYMBOL(ppc4xx_disable_dma);
+EXPORT_SYMBOL(ppc4xx_set_dma_mode);
+EXPORT_SYMBOL(ppc4xx_set_dma_count);
+EXPORT_SYMBOL(ppc4xx_get_dma_residue);
+EXPORT_SYMBOL(ppc4xx_enable_dma_interrupt);
+EXPORT_SYMBOL(ppc4xx_disable_dma_interrupt);
+EXPORT_SYMBOL(ppc4xx_get_dma_status);
diff -p -purN linux-2.5/arch/ppc/syslib/ppc4xx_pic.c linuxppc-2.5/arch/ppc/syslib/ppc4xx_pic.c
--- linux-2.5/arch/ppc/syslib/ppc4xx_pic.c	2003-09-12 18:26:55.000000000 +0200
+++ linuxppc-2.5/arch/ppc/syslib/ppc4xx_pic.c	2003-09-12 19:45:00.000000000 +0200
@@ -40,7 +40,7 @@
 struct hw_interrupt_type *ppc4xx_pic;
 /*
  * We define 4xxIRQ_InitSenses table thusly:
- * bit 0x1: sense, 1 for edge and 0 for level.
+ * bit 0x1: sense, 0 for edge and 1 for level.
  * bit 0x2: polarity, 0 for negative, 1 for positive.
  */
 unsigned int ibm4xxPIC_NumInitSenses __initdata = 0;
@@ -225,10 +225,14 @@ ppc405_uic_disable_and_ack(unsigned int 
 		mtdcr(DCRN_UIC_ER(UIC0), ppc_cached_irq_mask[word]);
 		mtdcr(DCRN_UIC_SR(UIC0), (1 << (31 - bit)));
 		break;
+#if NR_UICS > 1
 	case 1:
 		mtdcr(DCRN_UIC_ER(UIC1), ppc_cached_irq_mask[word]);
 		mtdcr(DCRN_UIC_SR(UIC1), (1 << (31 - bit)));
+		/* ACK cascaded interrupt in UIC0 */
+		mtdcr(DCRN_UIC_SR(UIC0), (1 << (31 - UIC0_UIC1NC)));
 		break;
+#endif
 	}
 }
 
@@ -260,9 +264,13 @@ ppc405_uic_end(unsigned int irq)
 		case 0:
 			mtdcr(DCRN_UIC_SR(UIC0), 1 << (31 - bit));
 			break;
+#if NR_UICS > 1
 		case 1:
 			mtdcr(DCRN_UIC_SR(UIC1), 1 << (31 - bit));
+			/* ACK cascaded interrupt in UIC0 */
+			mtdcr(DCRN_UIC_SR(UIC0), (1 << (31 - UIC0_UIC1NC)));
 			break;
+#endif
 		}
 	}
 
@@ -340,14 +348,6 @@ ppc405_pic_get_irq(struct pt_regs *regs)
 void __init
 ppc4xx_extpic_init(void)
 {
-	/* set polarity
-	 * 1 = default/pos/rising  , 0= neg/falling internal
-	 * 1 = neg/falling , 0= pos/rising external
-	 * Sense
-	 * 0 = default level internal
-	 * 0 = level, 1 = edge external
-	 */
-
 	unsigned int sense, irq;
 	int bit, word;
 	unsigned long ppc_cached_sense_mask[NR_MASK_WORDS];
@@ -362,15 +362,15 @@ ppc4xx_extpic_init(void)
 		bit = irq & 0x1f;
 		word = irq >> 5;
 
-		sense =
-		    (irq <
-		     ibm4xxPIC_NumInitSenses) ? ibm4xxPIC_InitSenses[irq] : 3;
+		sense = (irq < ibm4xxPIC_NumInitSenses) ?
+			ibm4xxPIC_InitSenses[irq] :
+			IRQ_SENSE_EDGE | IRQ_POLARITY_POSITIVE;
 #ifdef PPC4xx_PIC_DEBUG
 		printk("PPC4xx_picext %d word:%x bit:%x sense:%x", irq, word,
 		       bit, sense);
 #endif
 		ppc_cached_sense_mask[word] |=
-		    (sense & IRQ_SENSE_MASK) << (31 - bit);
+		    (~sense & IRQ_SENSE_MASK) << (31 - bit);
 		ppc_cached_pol_mask[word] |=
 		    ((sense & IRQ_POLARITY_MASK) >> 1) << (31 - bit);
 		switch (word) {
diff -p -purN linux-2.5/arch/ppc/syslib/ppc4xx_pm.c linuxppc-2.5/arch/ppc/syslib/ppc4xx_pm.c
--- linux-2.5/arch/ppc/syslib/ppc4xx_pm.c	2003-02-12 00:48:53.000000000 +0100
+++ linuxppc-2.5/arch/ppc/syslib/ppc4xx_pm.c	2003-02-13 02:00:41.000000000 +0100
@@ -12,36 +12,154 @@
 
 #include <linux/config.h>
 #include <linux/init.h>
-
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/pm.h>
 #include <asm/ibm4xx.h>
+#include <asm/ibm_ocp.h>
+#include <linux/interrupt.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+
+#ifdef CONFIG_APM
+/*
+ * OCP Power management..
+ *
+ * This needs to be done centralized, so that we power manage PCI
+ * devices in the right order: we should not shut down PCI bridges
+ * before we've shut down the devices behind them, and we should
+ * not wake up devices before we've woken up the bridge to the
+ * device.. Eh?
+ *
+ * We do not touch devices that don't have a driver that exports
+ * a suspend/resume function. That is just too dangerous. If the default
+ * PCI suspend/resume functions work for a device, the driver can
+ * easily implement them (ie just have a suspend function that calls
+ * the pci_set_power_state() function).
+ */
+
+static int ocp_pm_save_state_device(struct ocp_dev *dev, u32 state)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_dev *driver = dev->driver;
+		if (driver && driver->save_state)
+			error = driver->save_state(dev,state);
+	}
+	return error;
+}
+
+static int ocp_pm_suspend_device(struct ocp_dev *dev, u32 state)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_dev *driver = dev->driver;
+		if (driver && driver->suspend)
+			error = driver->suspend(dev,state);
+	}
+	return error;
+}
+
+static int ocp_pm_resume_device(struct ocp_dev *dev)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_dev *driver = dev->driver;
+		if (driver && driver->resume)
+			error = driver->resume(dev);
+	}
+	return error;
+}
+
+static int
+ocp_pm_callback(struct pm_dev *pm_device, pm_request_t rqst, void *data)
+{
+	int error = 0;
+
+	switch (rqst) {
+	case PM_SAVE_STATE:
+		error = ocp_pm_save_state_device((u32)data);
+		break;
+	case PM_SUSPEND:
+		error = ocp_pm_suspend_device((u32)data);
+		break;
+	case PM_RESUME:
+		error = ocp_pm_resume_device((u32)data);
+		break;
+	default: break;
+	}
+	return error;
+}
+/**
+ * ocp_register_driver - register a new ocp driver
+ * @drv: the driver structure to register
+ *
+ * Adds the driver structure to the list of registered drivers
+ * Returns the number of ocp devices which were claimed by the driver
+ * during registration.  The driver remains registered even if the
+ * return value is zero.
+ */
+int
+ocp_register_driver(struct ocp_dev *drv)
+{
+	struct ocp_dev *dev;
+	struct ocp_
+	list_add_tail(&drv->node, &ocp_devs);
+	return 0;
+}
+
+EXPORT_SYMBOL(ocp_register_driver);
+#endif
+
+/* When bits are "1" then the given clock is
+ * stopped therefore saving power 
+ *
+ * The objected is to turn off all unneccessary 
+ * clocks and have the drivers enable/disable
+ * them when in use.  We set the default
+ * in the <core>.h file
+ */
 
 void __init
 ppc4xx_pm_init(void)
 {
-
-	unsigned int value = 0;
+	
+	mtdcr(DCRN_CPMFR, 0);
 
 	/* turn off unused hardware to save power */
-#ifdef CONFIG_405GP
-	value |= CPM_DCP;	/* CodePack */
-#endif
 
-#if !defined(CONFIG_IBM_OCP_GPIO)
-	value |= CPM_GPIO0;
-#endif
+	printk(KERN_INFO "OCP 4xx power management enabled\n");
+	mtdcr(DCRN_CPMFR, DFLT_IBM4xx_PM);
 
-#if !defined(CONFIG_PPC405_I2C_ADAP)
-	value |= CPM_IIC0;
-#ifdef CONFIG_STB03xxx
-	value |= CPM_IIC1;
-#endif
+#ifdef CONFIG_APM
+	pm_gpio = pm_register(PM_SYS_DEV, 0, ocp_pm_callback);
 #endif
+}
+__initcall(ppc4xx_pm_init);
 
+/* Force/unforce power down for CPM Class 1 devices */
 
-#if !defined(CONFIG_405_DMA)
-	value |= CPM_DMA;
-#endif
+void
+ppc4xx_cpm_fr(u32 bits, int val)
+{
+	unsigned long flags;
 
-	mtdcr(DCRN_CPMFR, value);
+	save_flags(flags);
+	cli();
 
+	if (val)
+		mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | bits);
+	else
+		mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~bits);
+
+	restore_flags(flags);
 }
+
diff -p -purN linux-2.5/arch/ppc/syslib/ppc4xx_serial.c linuxppc-2.5/arch/ppc/syslib/ppc4xx_serial.c
--- linux-2.5/arch/ppc/syslib/ppc4xx_serial.c	2003-09-12 18:26:55.000000000 +0200
+++ linuxppc-2.5/arch/ppc/syslib/ppc4xx_serial.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,171 +0,0 @@
-/*
- * arch/ppc/syslib/ppc405_serial.c
- *
- * Author: MontaVista Software, Inc.
- *         	frank_rowand@mvista.com or source@mvista.com
- * 	   	debbie_chu@mvista.com
- *
- * This is a fairly standard 165xx type device that will eventually
- * be merged with other similar processor/boards.	-- Dan
- *
- * 2000 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- *
- * Console I/O support for Early kernel bringup.
- */
-
-#include <linux/config.h>
-
-#if defined(CONFIG_IBM405GP) || defined(CONFIG_IBM405CR)
-
-#ifdef CONFIG_KGDB
-#include <asm/kgdb.h>
-#include <linux/init.h>
-#endif
-
-#ifdef CONFIG_DEBUG_BRINGUP
-
-#include <linux/console.h>
-
-extern void ftr_reset_preferred_console(void);
-
-
-static int ppc405_sercons_setup(struct console *co, char *options)
-{
-#ifdef CONFIG_UART0_DEBUG_CONSOLE
-    volatile unsigned char *uart_dll  = (char *)0xef600300;
-    volatile unsigned char *uart_fcr  = (char *)0xef600302;
-    volatile unsigned char *uart_lcr  = (char *)0xef600303;
-#endif
-
-#ifdef CONFIG_UART1_DEBUG_CONSOLE
-    volatile unsigned char *uart_dll  = (char *)0xef600400;
-    volatile unsigned char *uart_fcr  = (char *)0xef600402;
-    volatile unsigned char *uart_lcr  = (char *)0xef600403;
-#endif
-
-    *uart_lcr = *uart_lcr | 0x80;   /* DLAB on  */
-
-/* ftr revisit - there is no config option for this
-**  also see include/asm-ppc/ppc405_serial.h
-**
-** #define CONFIG_IBM405GP_INTERNAL_CLOCK
-*/
-
-
-#ifdef  CONFIG_IBM405GP_INTERNAL_CLOCK
-    /* ftr revisit
-    ** why is bit 19 of chcr0 (0x1000) being set?
-    */
-    /* 0x2a results in data corruption, kgdb works with 0x28 */
-    *uart_dll = 0x28;		    /* 9600 baud */
-    _put_CHCR0((_get_CHCR0() & 0xffffe000) | 0x103e);
-#else
-    *uart_dll = 0x48;		    /* 9600 baud */
-#endif
-    *uart_lcr = *uart_lcr & 0x7f;   /* DLAB off */
-
-    return 0;
-}
-
-
-/*
- * This is a bringup hack, writing directly to uart0 or uart1
- */
-
-static void
-ppc405_sercons_write(struct console *co, const char *ptr,
-            unsigned nb)
-{
-    int i;
-
-#ifdef CONFIG_UART0_DEBUG_CONSOLE
-    volatile unsigned char *uart_xmit = (char *)0xef600300;
-    volatile unsigned char *uart_lsr  = (char *)0xef600305;
-#endif
-
-#ifdef CONFIG_UART1_DEBUG_CONSOLE
-    volatile unsigned char *uart_xmit = (char *)0xef600400;
-    volatile unsigned char *uart_lsr  = (char *)0xef600405;
-#endif
-
-    for (i = 0; i < nb; ++i) {
-
-	/* wait for transmit reg (possibly fifo) to empty */
-	while ((*uart_lsr & 0x40) == 0)
-	    ;
-
-	*uart_xmit = (ptr[i] & 0xff);
-
-	if (ptr[i] == '\n') {
-
-	    /* add a carriage return */
-
-	    /* wait for transmit reg (possibly fifo) to empty */
-	    while ((*uart_lsr & 0x40) == 0)
-		;
-
-	    *uart_xmit = '\r';
-	}
-    }
-
-    return;
-}
-
-
-static int
-ppc405_sercons_read(struct console *co, char *ptr, unsigned nb)
-{
-#ifdef CONFIG_UART0_DEBUG_CONSOLE
-    volatile unsigned char *uart_rcv  = (char *)0xef600300;
-    volatile unsigned char *uart_lsr  = (char *)0xef600305;
-#endif
-
-#ifdef CONFIG_UART1_DEBUG_CONSOLE
-    volatile unsigned char *uart_rcv  = (char *)0xef600400;
-    volatile unsigned char *uart_lsr  = (char *)0xef600405;
-#endif
-
-
-    /* ftr revisit: not tested */
-
-    if (nb == 0)
-	return(0);
-
-    if (!ptr)
-	return(-1);
-
-    /* wait for receive reg (possibly fifo) to contain data */
-    while ((*uart_lsr & 0x01) == 0)
-	;
-
-    *ptr = *uart_rcv;
-
-    return(1);
-}
-
-static struct console ppc405_sercons = {
-	.name =		"dbg_cons",
-	.write =	ppc405_console_write,
-	.setup =	ppc405_console_setup,
-	.flags =	CON_PRINTBUFFER,
-	.index =	-1,
-};
-
-void
-register_debug_console(void)
-{
-	register_console(&ppc405_sercons);
-}
-
-void
-unregister_debug_console(void)
-{
-	unregister_console(&ppc405_sercons);
-}
-
-#endif	/* CONFIG_DEBUG_BRINGUP */
-
-#endif	/* #if defined(CONFIG_IBM405GP) || defined(CONFIG_IBM405CR) */
diff -p -purN linux-2.5/arch/ppc/syslib/ppc4xx_sgdma.c linuxppc-2.5/arch/ppc/syslib/ppc4xx_sgdma.c
--- linux-2.5/arch/ppc/syslib/ppc4xx_sgdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/syslib/ppc4xx_sgdma.c	2003-07-18 22:39:24.000000000 +0200
@@ -0,0 +1,536 @@
+/*
+ * arch/ppc/kernel/ppc4xx_sgdma.c
+ *
+ * IBM PPC4xx DMA engine scatter/gather library 
+ *
+ * Copyright 2002-2003 MontaVista Software Inc.
+ *
+ * Cleaned by Matt Porter <mporter@mvista.com>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *   
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_dma.h>
+
+static __inline__ void
+ppc4xx_set_sg_addr(int dmanr, phys_addr_t sg_addr)
+{
+	switch (dmanr) {
+		case 0:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_ASGH0, (u32)(sg_addr >> 32));
+#endif			
+			mtdcr(DCRN_ASG0, (u32)sg_addr);
+			break;
+		case 1:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_ASGH1, (u32)(sg_addr >> 32));
+#endif			
+			mtdcr(DCRN_ASG1, (u32)sg_addr);
+			break;
+		case 2:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_ASGH2, (u32)(sg_addr >> 32));
+#endif			
+			mtdcr(DCRN_ASG2, sg_addr);
+			break;
+		case 3:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_ASGH3, (u32)(sg_addr >> 32));
+#endif			
+			mtdcr(DCRN_ASG3, (u32)sg_addr);
+			break;
+	}
+}
+
+
+/*
+ *   Add a new sgl descriptor to the end of a scatter/gather list 
+ *   which was created by alloc_dma_handle(). 
+ *
+ *   For a memory to memory transfer, both dma addresses must be
+ *   valid. For a peripheral to memory transfer, one of the addresses
+ *   must be set to NULL, depending on the direction of the transfer:
+ *   memory to peripheral: set dst_addr to NULL,
+ *   peripheral to memory: set src_addr to NULL.
+ */
+static __inline__ int
+ppc4xx_add_dma_sgl(sgl_handle_t handle, phys_addr_t src_addr, phys_addr_t dst_addr,
+		   unsigned int count)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+
+	if (!handle) {
+		printk("ppc4xx_add_dma_sgl: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	}
+
+	if (psgl->dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_add_dma_sgl: bad channel: %d\n", psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	p_dma_ch = &dma_channels[psgl->dmanr];
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		unsigned int aligned =
+		    (unsigned) src_addr | (unsigned) dst_addr | count;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if (aligned & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if (aligned & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if (aligned & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("ppc4xx_add_dma_sgl: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return DMA_STATUS_GENERAL_ERROR;
+		}
+		if (error)
+			printk
+			    ("Alignment warning: ppc4xx_add_dma_sgl src 0x%x dst 0x%x count 0x%x bus width var %d\n",
+			     src_addr, dst_addr, count, p_dma_ch->pwidth);
+
+	}
+#endif
+
+	if ((unsigned) (psgl->ptail + 1) >= ((unsigned) psgl + SGL_LIST_SIZE)) {
+		printk("sgl handle out of memory \n");
+		return DMA_STATUS_OUT_OF_MEMORY;
+	}
+
+	if (!psgl->ptail) {
+		psgl->phead = (ppc_sgl_t *)
+		    ((unsigned) psgl + sizeof (sgl_list_info_t));
+		psgl->ptail = psgl->phead;
+	} else {
+		psgl->ptail->next = iopa((unsigned long)(psgl->ptail + 1));
+		psgl->ptail++;
+	}
+
+	psgl->ptail->control = psgl->control;
+	psgl->ptail->src_addr = src_addr;
+	psgl->ptail->dst_addr = dst_addr;
+	psgl->ptail->control_count = (count >> p_dma_ch->shift) |
+	    psgl->sgl_control;
+	psgl->ptail->next = (uint32_t) NULL;
+
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Enable (start) the DMA described by the sgl handle.
+ */
+static __inline__ void
+ppc4xx_enable_dma_sgl(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+	uint32_t sg_command;
+
+	if (!handle) {
+		printk("ppc4xx_enable_dma_sgl: null handle\n");
+		return;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_enable_dma_sgl: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return;
+	} else if (!psgl->phead) {
+		printk("ppc4xx_enable_dma_sgl: sg list empty\n");
+		return;
+	}
+
+	p_dma_ch = &dma_channels[psgl->dmanr];
+	psgl->ptail->control_count &= ~SG_LINK;	/* make this the last dscrptr */
+	sg_command = mfdcr(DCRN_ASGC);
+
+	ppc4xx_set_sg_addr(psgl->dmanr, iopa((unsigned long)psgl->phead));
+
+	switch (psgl->dmanr) {
+	case 0:
+		sg_command |= SSG0_ENABLE;
+		break;
+	case 1:
+		sg_command |= SSG1_ENABLE;
+		break;
+	case 2:
+		sg_command |= SSG2_ENABLE;
+		break;
+	case 3:
+		sg_command |= SSG3_ENABLE;
+		break;
+	default:
+		printk("ppc4xx_enable_dma_sgl: bad channel: %d\n", psgl->dmanr);
+	}
+
+	mtdcr(DCRN_ASGC, sg_command);	/* start transfer */
+}
+
+/*
+ * Halt an active scatter/gather DMA operation.
+ */
+static __inline__ void
+ppc4xx_disable_dma_sgl(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	uint32_t sg_command;
+
+	if (!handle) {
+		printk("ppc4xx_enable_dma_sgl: null handle\n");
+		return;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_enable_dma_sgl: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return;
+	}
+
+	sg_command = mfdcr(DCRN_ASGC);
+	switch (psgl->dmanr) {
+	case 0:
+		sg_command &= ~SSG0_ENABLE;
+		break;
+	case 1:
+		sg_command &= ~SSG1_ENABLE;
+		break;
+	case 2:
+		sg_command &= ~SSG2_ENABLE;
+		break;
+	case 3:
+		sg_command &= ~SSG3_ENABLE;
+		break;
+	default:
+		printk("ppc4xx_enable_dma_sgl: bad channel: %d\n", psgl->dmanr);
+	}
+
+	mtdcr(DCRN_ASGC, sg_command);	/* stop transfer */
+}
+
+/*
+ *  Returns number of bytes left to be transferred from the entire sgl list.
+ *  *src_addr and *dst_addr get set to the source/destination address of
+ *  the sgl descriptor where the DMA stopped.
+ *
+ *  An sgl transfer must NOT be active when this function is called.
+ */
+static __inline__ int
+ppc4xx_get_dma_sgl_residue(sgl_handle_t handle, phys_addr_t * src_addr,
+			   phys_addr_t * dst_addr)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+	ppc_sgl_t *pnext, *sgl_addr;
+	uint32_t count_left;
+
+	if (!handle) {
+		printk("ppc4xx_get_dma_sgl_residue: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_get_dma_sgl_residue: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	switch (psgl->dmanr) {
+	case 0:
+		sgl_addr = (ppc_sgl_t *) bus_to_virt(mfdcr(DCRN_ASG0));
+		count_left = mfdcr(DCRN_DMACT0);
+		break;
+	case 1:
+		sgl_addr = (ppc_sgl_t *) bus_to_virt(mfdcr(DCRN_ASG1));
+		count_left = mfdcr(DCRN_DMACT1);
+		break;
+	case 2:
+		sgl_addr = (ppc_sgl_t *) bus_to_virt(mfdcr(DCRN_ASG2));
+		count_left = mfdcr(DCRN_DMACT2);
+		break;
+	case 3:
+		sgl_addr = (ppc_sgl_t *) bus_to_virt(mfdcr(DCRN_ASG3));
+		count_left = mfdcr(DCRN_DMACT3);
+		break;
+	default:
+		printk("ppc4xx_get_dma_sgl_residue: bad channel %d\n", psgl->dmanr);
+		goto error;
+	}
+
+	if (!sgl_addr) {
+		printk("ppc4xx_get_dma_sgl_residue: sgl addr register is null\n");
+		goto error;
+	}
+
+	pnext = psgl->phead;
+	while (pnext &&
+	       ((unsigned) pnext < ((unsigned) psgl + SGL_LIST_SIZE) &&
+		(pnext != sgl_addr))
+	    ) {
+		pnext++;
+	}
+
+	if (pnext == sgl_addr) {	/* found the sgl descriptor */
+
+		*src_addr = pnext->src_addr;
+		*dst_addr = pnext->dst_addr;
+
+		/*
+		 * Now search the remaining descriptors and add their count.
+		 * We already have the remaining count from this descriptor in
+		 * count_left.
+		 */
+		pnext++;
+
+		while ((pnext != psgl->ptail) &&
+		       ((unsigned) pnext < ((unsigned) psgl + SGL_LIST_SIZE))
+		    ) {
+			count_left += pnext->control_count & SG_COUNT_MASK;
+		}
+
+		if (pnext != psgl->ptail) {	/* should never happen */
+			printk
+			    ("ppc4xx_get_dma_sgl_residue error (1) psgl->ptail 0x%x handle 0x%x\n",
+			     (unsigned int) psgl->ptail, (unsigned int) handle);
+			goto error;
+		}
+
+		/* success */
+		p_dma_ch = &dma_channels[psgl->dmanr];
+		return (count_left << p_dma_ch->shift);	/* count in bytes */
+
+	} else {
+		/* this shouldn't happen */
+		printk
+		    ("get_dma_sgl_residue, unable to match current address 0x%x, handle 0x%x\n",
+		     (unsigned int) sgl_addr, (unsigned int) handle);
+
+	}
+
+      error:
+	*src_addr = (phys_addr_t) NULL;
+	*dst_addr = (phys_addr_t) NULL;
+	return 0;
+}
+
+/*
+ * Returns the address(es) of the buffer(s) contained in the head element of
+ * the scatter/gather list.  The element is removed from the scatter/gather
+ * list and the next element becomes the head.
+ *
+ * This function should only be called when the DMA is not active.
+ */
+static __inline__ int
+ppc4xx_delete_dma_sgl_element(sgl_handle_t handle, phys_addr_t * src_dma_addr,
+			      phys_addr_t * dst_dma_addr)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+
+	if (!handle) {
+		printk("ppc4xx_delete_sgl_element: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_delete_sgl_element: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	if (!psgl->phead) {
+		printk("ppc4xx_delete_sgl_element: sgl list empty\n");
+		*src_dma_addr = (phys_addr_t) NULL;
+		*dst_dma_addr = (phys_addr_t) NULL;
+		return DMA_STATUS_SGL_LIST_EMPTY;
+	}
+
+	*src_dma_addr = (phys_addr_t) psgl->phead->src_addr;
+	*dst_dma_addr = (phys_addr_t) psgl->phead->dst_addr;
+
+	if (psgl->phead == psgl->ptail) {
+		/* last descriptor on the list */
+		psgl->phead = NULL;
+		psgl->ptail = NULL;
+	} else {
+		psgl->phead++;
+	}
+
+	return DMA_STATUS_GOOD;
+}
+
+
+/*
+ *   Create a scatter/gather list handle.  This is simply a structure which
+ *   describes a scatter/gather list.
+ *
+ *   A handle is returned in "handle" which the driver should save in order to 
+ *   be able to access this list later.  A chunk of memory will be allocated 
+ *   to be used by the API for internal management purposes, including managing 
+ *   the sg list and allocating memory for the sgl descriptors.  One page should 
+ *   be more than enough for that purpose.  Perhaps it's a bit wasteful to use 
+ *   a whole page for a single sg list, but most likely there will be only one 
+ *   sg list per channel.
+ *
+ *   Interrupt notes:
+ *   Each sgl descriptor has a copy of the DMA control word which the DMA engine
+ *   loads in the control register.  The control word has a "global" interrupt 
+ *   enable bit for that channel. Interrupts are further qualified by a few bits
+ *   in the sgl descriptor count register.  In order to setup an sgl, we have to
+ *   know ahead of time whether or not interrupts will be enabled at the completion
+ *   of the transfers.  Thus, enable_dma_interrupt()/disable_dma_interrupt() MUST
+ *   be called before calling alloc_dma_handle().  If the interrupt mode will never
+ *   change after powerup, then enable_dma_interrupt()/disable_dma_interrupt() 
+ *   do not have to be called -- interrupts will be enabled or disabled based
+ *   on how the channel was configured after powerup by the hw_init_dma_channel()
+ *   function.  Each sgl descriptor will be setup to interrupt if an error occurs;
+ *   however, only the last descriptor will be setup to interrupt. Thus, an 
+ *   interrupt will occur (if interrupts are enabled) only after the complete
+ *   sgl transfer is done.
+ */
+int
+ppc4xx_alloc_dma_handle(sgl_handle_t * phandle, unsigned int mode, unsigned int dmanr)
+{
+	sgl_list_info_t *psgl;
+	dma_addr_t dma_addr;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	uint32_t sg_command;
+	void *ret;
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_alloc_dma_handle: invalid channel 0x%x\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	if (!phandle) {
+		printk("ppc4xx_alloc_dma_handle: null handle pointer\n");
+		return DMA_STATUS_NULL_POINTER;
+	}
+
+	/* Get a page of memory, which is zeroed out by consistent_alloc() */
+	ret = consistent_alloc(GFP_KERNEL, DMA_PPC4xx_SIZE, &dma_addr);
+	if (ret != NULL) {
+		memset(ret, 0, DMA_PPC4xx_SIZE);
+		psgl = (sgl_list_info_t *) ret;
+	}
+
+	if (psgl == NULL) {
+		*phandle = (sgl_handle_t) NULL;
+		return DMA_STATUS_OUT_OF_MEMORY;
+	}
+
+	psgl->dma_addr = dma_addr;
+	psgl->dmanr = dmanr;
+
+	/*
+	 * Modify and save the control word. These words will be
+	 * written to each sgl descriptor.  The DMA engine then
+	 * loads this control word into the control register
+	 * every time it reads a new descriptor.
+	 */
+	psgl->control = p_dma_ch->control;
+	/* Clear all mode bits */
+	psgl->control &= ~(DMA_TM_MASK | DMA_TD);
+	/* Save control word and mode */
+	psgl->control |= (mode | DMA_CE_ENABLE);
+
+	/* In MM mode, we must set ETD/TCE */
+	if (mode == DMA_MODE_MM)
+		psgl->control |= DMA_ETD_OUTPUT | DMA_TCE_ENABLE;
+
+	if (p_dma_ch->int_enable) {
+		/* Enable channel interrupt */
+		psgl->control |= DMA_CIE_ENABLE;
+	} else {
+		psgl->control &= ~DMA_CIE_ENABLE;
+	}
+
+	sg_command = mfdcr(DCRN_ASGC);
+	switch (dmanr) {
+	case 0:
+		sg_command |= SSG0_MASK_ENABLE;
+		break;
+	case 1:
+		sg_command |= SSG1_MASK_ENABLE;
+		break;
+	case 2:
+		sg_command |= SSG2_MASK_ENABLE;
+		break;
+	case 3:
+		sg_command |= SSG3_MASK_ENABLE;
+		break;
+	default:
+		printk("ppc4xx_alloc_dma_handle: bad channel: %d\n", dmanr);
+		ppc4xx_free_dma_handle((sgl_handle_t) psgl);
+		*phandle = (sgl_handle_t) NULL;
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	/* Enable SGL control access */
+	mtdcr(DCRN_ASGC, sg_command);
+	psgl->sgl_control = SG_ERI_ENABLE | SG_LINK;
+
+	if (p_dma_ch->int_enable) {
+		if (p_dma_ch->tce_enable)
+			psgl->sgl_control |= SG_TCI_ENABLE;
+		else
+			psgl->sgl_control |= SG_ETI_ENABLE;
+	}
+
+	*phandle = (sgl_handle_t) psgl;
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Destroy a scatter/gather list handle that was created by alloc_dma_handle().
+ * The list must be empty (contain no elements).
+ */
+void
+ppc4xx_free_dma_handle(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+
+	if (!handle) {
+		printk("ppc4xx_free_dma_handle: got NULL\n");
+		return;
+	} else if (psgl->phead) {
+		printk("ppc4xx_free_dma_handle: list not empty\n");
+		return;
+	} else if (!psgl->dma_addr) {	/* should never happen */
+		printk("ppc4xx_free_dma_handle: no dma address\n");
+		return;
+	}
+
+	consistent_free((void *) psgl);
+}
+
+EXPORT_SYMBOL(ppc4xx_alloc_dma_handle);
+EXPORT_SYMBOL(ppc4xx_free_dma_handle);
+EXPORT_SYMBOL(ppc4xx_add_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_delete_dma_sgl_element);
+EXPORT_SYMBOL(ppc4xx_enable_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_disable_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_get_dma_sgl_residue);
diff -p -purN linux-2.5/arch/ppc/syslib/ppc4xx_stbdma.c linuxppc-2.5/arch/ppc/syslib/ppc4xx_stbdma.c
--- linux-2.5/arch/ppc/syslib/ppc4xx_stbdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/arch/ppc/syslib/ppc4xx_stbdma.c	2003-02-25 02:41:01.000000000 +0100
@@ -0,0 +1,135 @@
+/*
+ * arch/ppc/syslib/ppc4xx_stbdma.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	IBM PPC4xx STBxxxx DMA Controller Functions
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         Armin Kuster <akuster@mvista.com>
+ *   
+ * Based on ppc4xx_dma.c by
+ *         ppopov@mvista.com or source@mvista.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <asm/ppc4xx_dma.h>
+
+int
+clr_dma_status(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	p_dma_ch->int_enable = 1;
+
+	control = mfdcr(DCRN_DMASR);
+	switch (dmanr) {
+	case 0:
+		control |= DMA_CS0 & DMA_CH0_ERR & DMA_CT0;	
+		break;
+	case 1:
+		control |= DMA_CS1 & DMA_CH1_ERR & DMA_CT1;
+		break;
+	case 2:
+		control |= DMA_CS2 & DMA_CH2_ERR & DMA_CT2;
+		break;
+	case 3:
+		control |= DMA_CS3 & DMA_CH3_ERR & DMA_CT3;
+		break;
+	default:
+#ifdef DEBUG_4xxDMA
+		printk("clr_dma_status: bad channel: %d\n", dmanr);
+#endif
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	mtdcr(DCRN_DMASR, control);
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Maps a given port to a one of the dma
+ * channels
+ */
+int
+map_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan)
+{
+	unsigned int map;
+	int connect_port_to_chan, select; 
+
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	
+	connect_port_to_chan = ((ocp_dma & 0x7)*4);
+	
+	select = ocp_dma >> 3;
+	switch (select) {
+	case 0:
+		map = mfdcr(DCRN_DMAS1);
+		map |= (connect_port_to_chan << dma_chan);	/* */
+		mtdcr(DCRN_DMAS1, map);
+		break;
+	case 1:
+		map = mfdcr(DCRN_DMAS2);
+		map |= (connect_port_to_chan << dma_chan);
+		mtdcr(DCRN_DMAS2, map);
+		break;
+	default:
+#ifdef DEBUG_4xxDMA
+		printk("map_dma_port: bad channel: %d\n", dmanr);
+#endif
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
+
+int
+disable_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan)
+{
+	unsigned int map;
+	int connect_port_to_chan, select; 
+
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	
+	connect_port_to_chan = ((ocp_dma & 0x7)*4);
+	
+	select = ocp_dma >> 3;
+	switch (select) {
+	case 0:
+		map = mfdcr(DCRN_DMAS1);
+		map &= ~(connect_port_to_chan << dma_chan);	/* */
+		mtdcr(DCRN_DMAS1, map);
+		break;
+	case 1:
+		map = mfdcr(DCRN_DMAS2);
+		map &= ~(connect_port_to_chan << dma_chan);
+		mtdcr(DCRN_DMAS2, map);
+		break;
+	default:
+#ifdef DEBUG_4xxDMA
+		printk("disable_dma_port: bad channel: %d\n", dmanr);
+#endif
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
+
+EXPORT_SYMBOL(disable_dma_port);
+EXPORT_SYMBOL(map_dma_port);
+EXPORT_SYMBOL(clr_dma_status);
diff -p -purN linux-2.5/drivers/char/Kconfig linuxppc-2.5/drivers/char/Kconfig
--- linux-2.5/drivers/char/Kconfig	2003-10-09 00:33:16.000000000 +0200
+++ linuxppc-2.5/drivers/char/Kconfig	2003-10-09 14:25:50.000000000 +0200
@@ -862,6 +862,9 @@ config SONYPI
 	  To compile this driver as a module, choose M here: the
 	  module will be called sonypi.
 
+config IBM_GPIO
+	tristate "IBM GPIO"
+	depends on IBM_OCP
 
 menu "Ftape, the floppy tape device driver"
 
diff -p -purN linux-2.5/drivers/char/Makefile linuxppc-2.5/drivers/char/Makefile
--- linux-2.5/drivers/char/Makefile	2003-09-24 08:15:15.000000000 +0200
+++ linuxppc-2.5/drivers/char/Makefile	2003-09-24 19:10:03.000000000 +0200
@@ -52,6 +52,7 @@ obj-$(CONFIG_DTLK) += dtlk.o
 obj-$(CONFIG_R3964) += n_r3964.o
 obj-$(CONFIG_APPLICOM) += applicom.o
 obj-$(CONFIG_SONYPI) += sonypi.o
+obj-$(CONFIG_IBM_GPIO) += ibm_gpio.o
 obj-$(CONFIG_RTC) += rtc.o
 obj-$(CONFIG_GEN_RTC) += genrtc.o
 obj-$(CONFIG_EFI_RTC) += efirtc.o
diff -p -purN linux-2.5/drivers/char/drm/drmP.h linuxppc-2.5/drivers/char/drm/drmP.h
--- linux-2.5/drivers/char/drm/drmP.h	2003-09-25 17:56:58.000000000 +0200
+++ linuxppc-2.5/drivers/char/drm/drmP.h	2003-09-26 00:12:01.000000000 +0200
@@ -52,9 +52,10 @@
 #include <linux/file.h>
 #include <linux/pci.h>
 #include <linux/version.h>
-#include <linux/jiffies.h>
+#include <linux/sched.h>
 #include <linux/smp_lock.h>	/* For (un)lock_kernel */
 #include <linux/mm.h>
+#include <linux/pagemap.h>
 #if defined(__alpha__) || defined(__powerpc__)
 #include <asm/pgtable.h> /* For pte_wrprotect */
 #endif
@@ -197,11 +198,7 @@ static inline struct page * vmalloc_to_p
 }
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#define DRM_RPR_ARG(vma)
-#else
 #define DRM_RPR_ARG(vma) vma,
-#endif
 
 #define VM_OFFSET(vma) ((vma)->vm_pgoff << PAGE_SHIFT)
 
diff -p -purN linux-2.5/drivers/char/drm/drm_drv.h linuxppc-2.5/drivers/char/drm/drm_drv.h
--- linux-2.5/drivers/char/drm/drm_drv.h	2003-09-23 06:16:26.000000000 +0200
+++ linuxppc-2.5/drivers/char/drm/drm_drv.h	2003-09-24 19:10:03.000000000 +0200
@@ -344,6 +344,7 @@ static int DRM(setup)( drm_device_t *dev
 	dev->last_context = 0;
 	dev->last_switch = 0;
 	dev->last_checked = 0;
+	init_timer( &dev->timer );
 	init_waitqueue_head( &dev->context_wait );
 
 	dev->ctx_start = 0;
@@ -623,7 +624,6 @@ static int __init drm_init( void )
 		dev = &(DRM(device)[i]);
 		memset( (void *)dev, 0, sizeof(*dev) );
 		dev->count_lock = SPIN_LOCK_UNLOCKED;
-		init_timer( &dev->timer );
 		sema_init( &dev->struct_sem, 1 );
 
 		if ((DRM(minor)[i] = DRM(stub_register)(DRIVER_NAME, &DRM(fops),dev)) < 0)
diff -p -purN linux-2.5/drivers/char/drm/r128_cce.c linuxppc-2.5/drivers/char/drm/r128_cce.c
--- linux-2.5/drivers/char/drm/r128_cce.c	2003-09-25 01:41:22.000000000 +0200
+++ linuxppc-2.5/drivers/char/drm/r128_cce.c	2003-09-27 14:05:22.000000000 +0200
@@ -81,6 +81,8 @@ static u32 r128_cce_microcode[] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 
+int r128_do_wait_for_idle( drm_r128_private_t *dev_priv );
+
 int R128_READ_PLL(drm_device_t *dev, int addr)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
@@ -149,7 +151,7 @@ static int r128_do_wait_for_fifo( drm_r1
 	return DRM_ERR(EBUSY);
 }
 
-static int r128_do_wait_for_idle( drm_r128_private_t *dev_priv )
+int r128_do_wait_for_idle( drm_r128_private_t *dev_priv )
 {
 	int i, ret;
 
@@ -212,7 +214,7 @@ int r128_do_cce_idle( drm_r128_private_t
 	int i;
 
 	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		if ( GET_RING_HEAD( &dev_priv->ring ) == dev_priv->ring.tail ) {
+		if ( GET_RING_HEAD( dev_priv ) == dev_priv->ring.tail ) {
 			int pm4stat = R128_READ( R128_PM4_STAT );
 			if ( ( (pm4stat & R128_PM4_FIFOCNT_MASK) >=
 			       dev_priv->cce_fifo_size ) &&
@@ -238,7 +240,8 @@ static void r128_do_cce_start( drm_r128_
 	r128_do_wait_for_idle( dev_priv );
 
 	R128_WRITE( R128_PM4_BUFFER_CNTL,
-		    dev_priv->cce_mode | dev_priv->ring.size_l2qw );
+		    dev_priv->cce_mode | dev_priv->ring.size_l2qw
+		    | R128_PM4_BUFFER_CNTL_NOUPDATE );
 	R128_READ( R128_PM4_BUFFER_ADDR ); /* as per the sample code */
 	R128_WRITE( R128_PM4_MICRO_CNTL, R128_PM4_MICRO_FREERUN );
 
@@ -253,7 +256,6 @@ static void r128_do_cce_reset( drm_r128_
 {
 	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, 0 );
 	R128_WRITE( R128_PM4_BUFFER_DL_RPTR, 0 );
-	SET_RING_HEAD( &dev_priv->ring, 0 );
 	dev_priv->ring.tail = 0;
 }
 
@@ -264,7 +266,8 @@ static void r128_do_cce_reset( drm_r128_
 static void r128_do_cce_stop( drm_r128_private_t *dev_priv )
 {
 	R128_WRITE( R128_PM4_MICRO_CNTL, 0 );
-	R128_WRITE( R128_PM4_BUFFER_CNTL, R128_PM4_NONPM4 );
+	R128_WRITE( R128_PM4_BUFFER_CNTL,
+		    R128_PM4_NONPM4 | R128_PM4_BUFFER_CNTL_NOUPDATE );
 
 	dev_priv->cce_running = 0;
 }
@@ -333,26 +336,6 @@ static void r128_cce_init_ring_buffer( d
 	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, 0 );
 	R128_WRITE( R128_PM4_BUFFER_DL_RPTR, 0 );
 
-	/* DL_RPTR_ADDR is a physical address in AGP space. */
-	SET_RING_HEAD( &dev_priv->ring, 0 );
-
-	if ( !dev_priv->is_pci ) {
-		R128_WRITE( R128_PM4_BUFFER_DL_RPTR_ADDR,
-			    dev_priv->ring_rptr->offset );
-	} else {
-		drm_sg_mem_t *entry = dev->sg;
-		unsigned long tmp_ofs, page_ofs;
-
-		tmp_ofs = dev_priv->ring_rptr->offset - dev->sg->handle;
-		page_ofs = tmp_ofs >> PAGE_SHIFT;
-
-		R128_WRITE( R128_PM4_BUFFER_DL_RPTR_ADDR,
-     			    entry->busaddr[page_ofs]);
-		DRM_DEBUG( "ring rptr: offset=0x%08lx handle=0x%08lx\n",
-			   (unsigned long) entry->busaddr[page_ofs],
-     			   entry->handle + tmp_ofs );
-	}
-
 	/* Set watermark control */
 	R128_WRITE( R128_PM4_BUFFER_WM_CNTL,
 		    ((R128_WATERMARK_L/4) << R128_WMA_SHIFT)
@@ -567,9 +550,6 @@ static int r128_do_init_cce( drm_device_
 #endif
 		dev_priv->cce_buffers_offset = dev->sg->handle;
 
-	dev_priv->ring.head = ((__volatile__ u32 *)
-			       dev_priv->ring_rptr->handle);
-
 	dev_priv->ring.start = (u32 *)dev_priv->cce_ring->handle;
 	dev_priv->ring.end = ((u32 *)dev_priv->cce_ring->handle
 			      + init->ring_size / sizeof(u32));
@@ -580,7 +560,6 @@ static int r128_do_init_cce( drm_device_
 		(dev_priv->ring.size / sizeof(u32)) - 1;
 
 	dev_priv->ring.high_mark = 128;
-	dev_priv->ring.ring_rptr = dev_priv->ring_rptr;
 
 	dev_priv->sarea_priv->last_frame = 0;
 	R128_WRITE( R128_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame );
@@ -589,8 +568,9 @@ static int r128_do_init_cce( drm_device_
 	R128_WRITE( R128_LAST_DISPATCH_REG,
 		    dev_priv->sarea_priv->last_dispatch );
 
-#if __REALLY_HAVE_SG
+#if __REALLY_HAVE_AGP
 	if ( dev_priv->is_pci ) {
+#endif
 		if (!DRM(ati_pcigart_init)( dev, &dev_priv->phys_pci_gart,
      					    &dev_priv->bus_pci_gart) ) {
 			DRM_ERROR( "failed to init PCI GART!\n" );
@@ -599,6 +579,7 @@ static int r128_do_init_cce( drm_device_
 			return DRM_ERR(ENOMEM);
 		}
 		R128_WRITE( R128_PCI_GART_PAGE, dev_priv->bus_pci_gart );
+#if __REALLY_HAVE_AGP
 	}
 #endif
 
@@ -901,7 +882,7 @@ int r128_wait_ring( drm_r128_private_t *
 	int i;
 
 	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		r128_update_ring_snapshot( ring );
+		r128_update_ring_snapshot( dev_priv );
 		if ( ring->space >= n )
 			return 0;
 		DRM_UDELAY( 1 );
diff -p -purN linux-2.5/drivers/char/drm/r128_drv.h linuxppc-2.5/drivers/char/drm/r128_drv.h
--- linux-2.5/drivers/char/drm/r128_drv.h	2003-08-02 04:51:32.000000000 +0200
+++ linuxppc-2.5/drivers/char/drm/r128_drv.h	2003-09-27 14:05:22.000000000 +0200
@@ -34,8 +34,7 @@
 #ifndef __R128_DRV_H__
 #define __R128_DRV_H__
 
-#define GET_RING_HEAD(ring)		DRM_READ32(  (ring)->ring_rptr, 0 ) /* (ring)->head */
-#define SET_RING_HEAD(ring,val)		DRM_WRITE32( (ring)->ring_rptr, 0, (val) ) /* (ring)->head */
+#define GET_RING_HEAD(dev_priv)		R128_READ( R128_PM4_BUFFER_DL_RPTR )
 
 typedef struct drm_r128_freelist {
    	unsigned int age;
@@ -50,13 +49,11 @@ typedef struct drm_r128_ring_buffer {
 	int size;
 	int size_l2qw;
 
-	volatile u32 *head;
 	u32 tail;
 	u32 tail_mask;
 	int space;
 
 	int high_mark;
-	drm_local_map_t *ring_rptr;
 } drm_r128_ring_buffer_t;
 
 typedef struct drm_r128_private {
@@ -132,14 +129,6 @@ extern drm_buf_t *r128_freelist_get( drm
 
 extern int r128_wait_ring( drm_r128_private_t *dev_priv, int n );
 
-static __inline__ void
-r128_update_ring_snapshot( drm_r128_ring_buffer_t *ring )
-{
-	ring->space = (GET_RING_HEAD( ring ) - ring->tail) * sizeof(u32);
-	if ( ring->space <= 0 )
-		ring->space += ring->size;
-}
-
 extern int r128_do_cce_idle( drm_r128_private_t *dev_priv );
 extern int r128_do_cleanup_cce( drm_device_t *dev );
 extern int r128_do_cleanup_pageflip( drm_device_t *dev );
@@ -279,6 +268,7 @@ extern int r128_cce_indirect( DRM_IOCTL_
 #	define R128_PM4_64PIO_64VCBM_64INDBM	(7  << 28)
 #	define R128_PM4_64BM_64VCBM_64INDBM	(8  << 28)
 #	define R128_PM4_64PIO_64VCPIO_64INDPIO	(15 << 28)
+#	define R128_PM4_BUFFER_CNTL_NOUPDATE	(1 << 27)
 
 #define R128_PM4_BUFFER_WM_CNTL		0x0708
 #	define R128_WMA_SHIFT			0
@@ -403,6 +393,15 @@ extern int R128_READ_PLL(drm_device_t *d
 					 (pkt) | ((n) << 16))
 
 
+static __inline__ void
+r128_update_ring_snapshot( drm_r128_private_t *dev_priv )
+{
+	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
+	ring->space = (GET_RING_HEAD( dev_priv ) - ring->tail) * sizeof(u32);
+	if ( ring->space <= 0 )
+		ring->space += ring->size;
+}
+
 /* ================================================================
  * Misc helper macros
  */
@@ -412,7 +411,7 @@ do {									\
 	drm_r128_ring_buffer_t *ring = &dev_priv->ring; int i;		\
 	if ( ring->space < ring->high_mark ) {				\
 		for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {	\
-			r128_update_ring_snapshot( ring );		\
+			r128_update_ring_snapshot( dev_priv );		\
 			if ( ring->space >= ring->high_mark )		\
 				goto __ring_space_done;			\
 			DRM_UDELAY(1);				\
@@ -445,17 +444,10 @@ do {									\
  * Ring control
  */
 
-#if defined(__powerpc__)
-#define r128_flush_write_combine()	(void) GET_RING_HEAD( &dev_priv->ring )
-#else
-#define r128_flush_write_combine()	DRM_WRITEMEMORYBARRIER()
-#endif
-
-
 #define R128_VERBOSE	0
 
 #define RING_LOCALS							\
-	int write; unsigned int tail_mask; volatile u32 *ring;
+	int write, _nr; unsigned int tail_mask; volatile u32 *ring;
 
 #define BEGIN_RING( n ) do {						\
 	if ( R128_VERBOSE ) {						\
@@ -463,9 +455,10 @@ do {									\
 			   (n), __FUNCTION__ );				\
 	}								\
 	if ( dev_priv->ring.space <= (n) * sizeof(u32) ) {		\
+		COMMIT_RING();						\
 		r128_wait_ring( dev_priv, (n) * sizeof(u32) );		\
 	}								\
-	dev_priv->ring.space -= (n) * sizeof(u32);			\
+	_nr = n; dev_priv->ring.space -= (n) * sizeof(u32);		\
 	ring = dev_priv->ring.start;					\
 	write = dev_priv->ring.tail;					\
 	tail_mask = dev_priv->ring.tail_mask;				\
@@ -488,9 +481,23 @@ do {									\
 			dev_priv->ring.start,				\
 			write * sizeof(u32) );				\
 	}								\
-	r128_flush_write_combine();					\
-	dev_priv->ring.tail = write;					\
-	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, write );			\
+	if (((dev_priv->ring.tail + _nr) & tail_mask) != write) {	\
+		DRM_ERROR( 						\
+			"ADVANCE_RING(): mismatch: nr: %x write: %x line: %d\n",	\
+			((dev_priv->ring.tail + _nr) & tail_mask),	\
+			write, __LINE__);				\
+	} else								\
+		dev_priv->ring.tail = write;				\
+} while (0)
+
+#define COMMIT_RING() do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "COMMIT_RING() tail=0x%06x\n",		\
+			dev_priv->ring.tail );				\
+	}								\
+	DRM_MEMORYBARRIER();						\
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, dev_priv->ring.tail );	\
+	R128_READ( R128_PM4_BUFFER_DL_WPTR );				\
 } while (0)
 
 #define OUT_RING( x ) do {						\
diff -p -purN linux-2.5/drivers/char/drm/r128_state.c linuxppc-2.5/drivers/char/drm/r128_state.c
--- linux-2.5/drivers/char/drm/r128_state.c	2003-08-02 04:51:32.000000000 +0200
+++ linuxppc-2.5/drivers/char/drm/r128_state.c	2003-09-27 14:05:22.000000000 +0200
@@ -45,7 +45,7 @@ static void r128_emit_clip_rects( drm_r1
 	RING_LOCALS;
 	DRM_DEBUG( "    %s\n", __FUNCTION__ );
 
-	BEGIN_RING( 17 );
+	BEGIN_RING( (count < 3? count: 3) * 5 + 2 );
 
 	if ( count >= 1 ) {
 		OUT_RING( CCE_PACKET0( R128_AUX1_SC_LEFT, 3 ) );
@@ -1269,6 +1269,7 @@ int r128_cce_clear( DRM_IOCTL_ARGS )
 		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
 
 	r128_cce_dispatch_clear( dev, &clear );
+	COMMIT_RING();
 
 	/* Make sure we restore the 3D state next time.
 	 */
@@ -1304,8 +1305,10 @@ int r128_do_cleanup_pageflip( drm_device
 	R128_WRITE( R128_CRTC_OFFSET,      dev_priv->crtc_offset );
 	R128_WRITE( R128_CRTC_OFFSET_CNTL, dev_priv->crtc_offset_cntl );
 
-	if (dev_priv->current_page != 0)
+	if (dev_priv->current_page != 0) {
 		r128_cce_dispatch_flip( dev );
+		COMMIT_RING();
+	}
 
 	dev_priv->page_flipping = 0;
 	return 0;
@@ -1330,6 +1333,7 @@ int r128_cce_flip( DRM_IOCTL_ARGS )
 
 	r128_cce_dispatch_flip( dev );
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1351,6 +1355,7 @@ int r128_cce_swap( DRM_IOCTL_ARGS )
 	dev_priv->sarea_priv->dirty |= (R128_UPLOAD_CONTEXT |
 					R128_UPLOAD_MASKS);
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1410,6 +1415,7 @@ int r128_cce_vertex( DRM_IOCTL_ARGS )
 
 	r128_cce_dispatch_vertex( dev, buf );
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1481,6 +1487,7 @@ int r128_cce_indices( DRM_IOCTL_ARGS )
 
 	r128_cce_dispatch_indices( dev, buf, elts.start, elts.end, count );
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1490,6 +1497,7 @@ int r128_cce_blit( DRM_IOCTL_ARGS )
 	drm_device_dma_t *dma = dev->dma;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_blit_t blit;
+	int ret;
 
 	LOCK_TEST_WITH_RETURN( dev, filp );
 
@@ -1507,7 +1515,10 @@ int r128_cce_blit( DRM_IOCTL_ARGS )
 	RING_SPACE_TEST_WITH_RETURN( dev_priv );
 	VB_AGE_TEST_WITH_RETURN( dev_priv );
 
-	return r128_cce_dispatch_blit( filp, dev, &blit );
+	ret = r128_cce_dispatch_blit( filp, dev, &blit );
+
+	COMMIT_RING();
+	return ret;
 }
 
 int r128_cce_depth( DRM_IOCTL_ARGS )
@@ -1515,6 +1526,7 @@ int r128_cce_depth( DRM_IOCTL_ARGS )
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_depth_t depth;
+	int ret;
 
 	LOCK_TEST_WITH_RETURN( dev, filp );
 
@@ -1523,18 +1535,20 @@ int r128_cce_depth( DRM_IOCTL_ARGS )
 
 	RING_SPACE_TEST_WITH_RETURN( dev_priv );
 
+	ret = DRM_ERR(EINVAL);
 	switch ( depth.func ) {
 	case R128_WRITE_SPAN:
-		return r128_cce_dispatch_write_span( dev, &depth );
+		ret = r128_cce_dispatch_write_span( dev, &depth );
 	case R128_WRITE_PIXELS:
-		return r128_cce_dispatch_write_pixels( dev, &depth );
+		ret = r128_cce_dispatch_write_pixels( dev, &depth );
 	case R128_READ_SPAN:
-		return r128_cce_dispatch_read_span( dev, &depth );
+		ret = r128_cce_dispatch_read_span( dev, &depth );
 	case R128_READ_PIXELS:
-		return r128_cce_dispatch_read_pixels( dev, &depth );
+		ret = r128_cce_dispatch_read_pixels( dev, &depth );
 	}
 
-	return DRM_ERR(EINVAL);
+	COMMIT_RING();
+	return ret;
 }
 
 int r128_cce_stipple( DRM_IOCTL_ARGS )
@@ -1557,6 +1571,7 @@ int r128_cce_stipple( DRM_IOCTL_ARGS )
 
 	r128_cce_dispatch_stipple( dev, mask );
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1632,6 +1647,7 @@ int r128_cce_indirect( DRM_IOCTL_ARGS )
 	 */
 	r128_cce_dispatch_indirect( dev, buf, indirect.start, indirect.end );
 
+	COMMIT_RING();
 	return 0;
 }
 
diff -p -purN linux-2.5/drivers/char/ibm_gpio.c linuxppc-2.5/drivers/char/ibm_gpio.c
--- linux-2.5/drivers/char/ibm_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/char/ibm_gpio.c	2003-07-22 00:46:25.000000000 +0200
@@ -0,0 +1,380 @@
+/*
+ * FILE NAME ibm_ocp_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  API for IBM PowerPC 4xx GPIO device.
+ *  Driver for IBM PowerPC 4xx GPIO device.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *          Debbie Chu   <debbie_chu@mvista.com>
+ *
+ * Copyright 2000,2001,2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *	TODO: devfs
+ *
+ *	Version: 02/01/12 - Armin
+ *			 converted to ocp and using ioremap
+ *
+ *	1.2 02/21/01 - Armin
+ *		minor compiler warning fixes
+ *
+ *	1.3 02/22/01 - Armin
+ *		added apm
+ *
+ *	1.4 05/07/02 - Armin/David Mueller
+ *		coverted to core_ocp[];
+ *
+ *	1.5 05/25/02 - Armin
+ *	 name change from *_driver to *_dev
+ *
+ *	1.6 06/04/02 - Matt Porter
+ *	ioremap paddr. Comment as 4xx generic driver.
+ *	Fix header to be userland safe and locate in
+ *	an accessible area.  Add ioctl to configure
+ *	multiplexed GPIO pins.
+ *
+ *	1.7 07/25/02 - Armin
+ *	added CPM to enable/disable in init/exit
+ *
+ */
+
+#define VUFX "07.25.02"
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/pm.h>
+#include <linux/ibm_gpio.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/ocp.h>
+
+struct miscdevice ibm_gpio_miscdev;
+static struct gpio_regs *gpiop;
+
+#ifdef CONFIG_PM
+static struct pm_dev *pm_gpio;
+
+static int
+gpio_save_state(u32 state)
+{
+	return 0;
+}
+
+static int
+gpio_suspend(u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | state);
+	return 0;
+}
+
+static int
+gpio_resume(u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~state);
+	return 0;
+}
+#endif
+
+int
+ibm_gpio_config(__u32 device, __u32 mask, __u32 data)
+{
+	u32 cfg_reg;
+
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+
+#ifdef CONFIG_40x
+#ifdef DCRN_CHCR0
+	/*
+	 * PPC405 uses CPC0_CR0 to select multiplexed GPIO pins.
+	 */
+	cfg_reg = mfdcr(DCRN_CHCR0);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	mtdcr(DCRN_CHCR0, cfg_reg);
+#endif
+#elif CONFIG_440GP
+	/*
+	 * PPC440GP uses CPC0_GPIO to select multiplexed GPIO pins.
+	 */
+	cfg_reg = mfdcr(DCRN_CPC0_GPIO);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	mtdcr(DCRN_CPC0_GPIO, cfg_reg);
+#elif CONFIG_440GX
+	/*
+	 * PPC440GX uses SDR0_PFC0 to select multiplexed GPIO pins
+	 */
+	cfg_reg = SDR_READ(DCRN_SDR_PFC0);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	SDR_WRITE(DCRN_SDR_PFC0, cfg_reg);
+#else
+#error This driver is only supported on PPC40x and PPC440 CPUs
+#endif
+
+	return 0;
+}
+
+int
+ibm_gpio_tristate(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->tcr = (gpiop->tcr & ~mask) | (data & mask);
+	return 0;
+}
+
+int
+ibm_gpio_open_drain(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->odr = (gpiop->odr & ~mask) | (data & mask);
+
+	return 0;
+}
+
+int
+ibm_gpio_in(__u32 device, __u32 mask, volatile __u32 * data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->tcr = gpiop->tcr & ~mask;
+	eieio();
+
+	/*
+	   ** If the previous state was OUT, and gpiop->ir is read once, then the
+	   ** data that was being OUTput will be read.  One way to get the right
+	   ** data is to read gpiop->ir twice.
+	 */
+
+	*data = gpiop->ir;
+	*data = gpiop->ir & mask;
+	eieio();
+	return 0;
+}
+
+int
+ibm_gpio_out(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->or = (gpiop->or & ~mask) | (data & mask);
+	eieio();
+	gpiop->tcr = gpiop->tcr | mask;
+	eieio();
+	return 0;
+}
+
+static int
+ibm_gpio_open(struct inode *inode, struct file *file)
+{
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static int
+ibm_gpio_release(struct inode *inode, struct file *file)
+{
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int
+ibm_gpio_ioctl(struct inode *inode, struct file *file,
+	       unsigned int cmd, unsigned long arg)
+{
+	static struct ibm_gpio_ioctl_data ioctl_data;
+	int status;
+
+	switch (cmd) {
+	case IBMGPIO_IN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		status = ibm_gpio_in(ioctl_data.device,
+				     ioctl_data.mask, &ioctl_data.data);
+		if (status != 0)
+			return status;
+
+		if (copy_to_user((struct ibm_gpio_ioctl_data *) arg,
+				 &ioctl_data, sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		break;
+
+	case IBMGPIO_OUT:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ibm_gpio_out(ioctl_data.device,
+				    ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_OPEN_DRAIN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ibm_gpio_open_drain(ioctl_data.device,
+					   ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_TRISTATE:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ibm_gpio_tristate(ioctl_data.device,
+					 ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_CFG:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ibm_gpio_config(ioctl_data.device,
+				ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+
+	}
+	return 0;
+}
+
+static struct file_operations ibm_gpio_fops = {
+	owner:THIS_MODULE,
+	ioctl:ibm_gpio_ioctl,
+	open:ibm_gpio_open,
+	release:ibm_gpio_release,
+};
+
+static int __init
+ibm_gpio_probe(struct ocp_device *ocp)
+{
+	printk("IBM GPIO driver version %s\n", VUFX);
+
+	ibm_gpio_miscdev.minor = 185;
+	ibm_gpio_miscdev.name = ocp->name;
+	ibm_gpio_miscdev.fops = &ibm_gpio_fops;
+	misc_register(&ibm_gpio_miscdev);
+
+	gpiop = (struct gpio_regs *) ioremap(ocp->paddr,
+			sizeof(struct gpio_regs));
+	printk("GPIO #%d at 0x%lx\n", ocp->num,
+			(unsigned long) gpiop);
+
+
+	return 0;
+}
+
+static void __exit
+ibm_gpio_remove(struct ocp_device *ocp)
+{
+	misc_deregister(&ibm_gpio_miscdev);
+}
+
+static struct ocp_device_id ibm_gpio_ids[] __devinitdata =
+{
+	{ .vendor = OCP_VENDOR_IBM, .device = OCP_FUNC_GPIO },
+	{ .vendor = OCP_VENDOR_INVALID }
+};
+
+static struct ocp_driver ibm_gpio_driver =
+{
+	.name           = "ibm_gpio",
+	.id_table       = ibm_gpio_ids,
+	.probe          = ibm_gpio_probe,
+	.remove         = __devexit_p(ibm_gpio_remove),
+#if defined(CONFIG_PM)
+	.suspend        = NULL,
+	.resume         = NULL,
+#endif
+};
+
+static int __init
+ibm_gpio_init(void)
+{
+	printk("IBM GPIO driver version %s\n", VUFX);
+	return ocp_module_init(&ibm_gpio_driver);
+}
+
+static void __exit
+ibm_gpio_exit(void)
+{
+	ocp_unregister_driver(&ibm_gpio_driver);
+}
+
+module_init(ibm_gpio_init);
+module_exit(ibm_gpio_exit);
+
+EXPORT_SYMBOL(ibm_gpio_tristate);
+EXPORT_SYMBOL(ibm_gpio_open_drain);
+EXPORT_SYMBOL(ibm_gpio_in);
+EXPORT_SYMBOL(ibm_gpio_out);
+
+MODULE_LICENSE("GPL");
diff -p -purN linux-2.5/drivers/ide/Kconfig linuxppc-2.5/drivers/ide/Kconfig
--- linux-2.5/drivers/ide/Kconfig	2003-10-05 08:50:55.000000000 +0200
+++ linuxppc-2.5/drivers/ide/Kconfig	2003-10-06 03:25:16.000000000 +0200
@@ -990,6 +990,15 @@ config IDE_EXT_DIRECT
 
 endchoice
 
+config BLK_DEV_IDE_STB04xxx
+	bool "STB04xxx (Redwood-5) IDE support"
+	depends on BLK_DEV_IDE && REDWOOD_5
+	help
+	  This option provides support for IDE on IBM STB04xxx Redwood-5
+	  systems.
+
+	  If unsure, say N.
+
 # no isa -> no vlb
 config IDE_CHIPSETS
 	bool "Other IDE chipset support"
diff -p -purN linux-2.5/drivers/ide/ide.c linuxppc-2.5/drivers/ide/ide.c
--- linux-2.5/drivers/ide/ide.c	2003-10-17 17:22:22.000000000 +0200
+++ linuxppc-2.5/drivers/ide/ide.c	2003-10-18 15:35:37.000000000 +0200
@@ -2280,6 +2280,12 @@ static void __init probe_for_hwifs (void
 		pnpide_init(1);
 	}
 #endif /* CONFIG_BLK_DEV_IDEPNP */
+#ifdef CONFIG_BLK_DEV_STD
+	{
+		extern void std_ide_cntl_scan(void);
+		std_ide_cntl_scan();
+	}
+#endif /* CONFIG_BLK_DEV_STD */
 }
 
 void __init ide_init_builtin_drivers (void)
diff -p -purN linux-2.5/drivers/ide/ppc/Makefile linuxppc-2.5/drivers/ide/ppc/Makefile
--- linux-2.5/drivers/ide/ppc/Makefile	2002-12-14 13:38:56.000000000 +0100
+++ linuxppc-2.5/drivers/ide/ppc/Makefile	2003-06-03 23:59:11.000000000 +0200
@@ -2,5 +2,6 @@
 obj-$(CONFIG_BLK_DEV_MPC8xx_IDE)	+= mpc8xx.o
 obj-$(CONFIG_BLK_DEV_IDE_PMAC)		+= pmac.o
 obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
+obj-$(CONFIG_BLK_DEV_IDE_STB04xxx)	+= ibm_ocp_ide.o
 
 EXTRA_CFLAGS	:= -Idrivers/ide
diff -p -purN linux-2.5/drivers/ide/ppc/ibm_ocp_ide.c linuxppc-2.5/drivers/ide/ppc/ibm_ocp_ide.c
--- linux-2.5/drivers/ide/ppc/ibm_ocp_ide.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/ide/ppc/ibm_ocp_ide.c	2003-06-03 23:59:11.000000000 +0200
@@ -0,0 +1,903 @@
+/*
+ *    Copyright 2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: Armin Kuster <akuster@mvista.com>
+ *      MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: ibm_ocp_ide.c
+ *
+ *    Description:
+ *
+ *    Based on ocp_stbxxxx.c
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/hdreg.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include "../ide-timing.h"
+#include <asm/ocp.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+#include <asm/ppc4xx_dma.h>
+
+#include "ide_modes.h"
+
+#define IDE_VER			"2.0"
+ppc_dma_ch_t dma_ch;
+
+/* use DMA channel 2 for IDE DMA operations */
+#define IDE_DMACH	2	/* 2nd DMA channel */
+#define IDE_DMA_INT	6	/* IDE dma channel 2 interrupt */
+
+#define WMODE	0		/* default to DMA line mode */
+#define PIOMODE	0
+
+#define MK_TIMING(AS, DIOP, DIOY, DH) \
+	((FIT((AS),    0, 15) << 27) | \
+	 (FIT((DIOP),  0, 63) << 20) | \
+	 (FIT((DIOY),  0, 63) << 13) | \
+	 (FIT((DH),    0,  7) << 9))
+
+#define UTIMING_SETHLD	(EZ(20 /*tACK*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_ENV	(EZ(20 /*tENV*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_SS	(EZ(50 /*tSS */, SYS_CLOCK_NS) - 3 /*fixed cycles*/)
+#define MK_UTIMING(CYC, RP) \
+	((FIT(UTIMING_SETHLD, 0, 15) << 27) | \
+	 (FIT(UTIMING_ENV,    0, 15) << 22) | \
+	 (FIT((CYC),          0, 15) << 17) | \
+	 (FIT((RP),           0, 63) << 10) | \
+	 (FIT(UTIMING_SS,     0, 15) << 5)  | \
+	 1 /* Turn on Ultra DMA */)
+
+/* Define the period of the STB clock used to generate the
+ * IDE bus timing.  The clock is actually 63 MHz, but it
+ * get rounded in a favorable direction.
+ */
+#define IDE_SYS_FREQ	63	/* MHz */
+#define SYS_CLOCK_NS	(1000 / IDE_SYS_FREQ)
+
+struct whold_timing {
+	short mode;
+	short whold;
+};
+
+static struct whold_timing whold_timing[] = {
+
+	{XFER_UDMA_5, 0},
+	{XFER_UDMA_4, 0},
+	{XFER_UDMA_3, 0},
+
+	{XFER_UDMA_2, 0},
+	{XFER_UDMA_1, 0},
+	{XFER_UDMA_0, 0},
+
+	{XFER_UDMA_SLOW, 0},
+
+	{XFER_MW_DMA_2, 0},
+	{XFER_MW_DMA_1, 0},
+	{XFER_MW_DMA_0, 0},
+
+	{XFER_SW_DMA_2, 0},
+	{XFER_SW_DMA_1, 0},
+	{XFER_SW_DMA_0, 10},
+
+	{XFER_PIO_5, 10},
+	{XFER_PIO_4, 10},
+	{XFER_PIO_3, 15},
+
+	{XFER_PIO_2, 20},
+	{XFER_PIO_1, 30},
+	{XFER_PIO_0, 50},
+
+	{XFER_PIO_SLOW,},
+
+	{-1}
+};
+
+/* The interface doesn't have register/PIO timing for each device,
+ * but rather "fast" and "slow" timing.  We have to determeine
+ * which is the "fast" device based upon their capability.
+ */
+static int pio_mode[2];
+
+/* Structure of the memory mapped IDE control.
+*/
+typedef struct ide_regs {
+	unsigned int si_stat;	/* IDE status */
+	unsigned int si_intenable;	/* IDE interrupt enable */
+	unsigned int si_control;	/* IDE control */
+	unsigned int pad0[0x3d];
+	unsigned int si_c0rt;	/* Chan 0 Register transfer timing */
+	unsigned int si_c0fpt;	/* Chan 0 Fast PIO transfer timing */
+	unsigned int si_c0timo;	/* Chan 0 timeout */
+	unsigned int pad1[2];
+	unsigned int si_c0d0u;	/* Chan 0 UDMA transfer timing */
+#define si_c0d0m si_c0d0u	/* Chan 0 Multiword DMA timing */
+	unsigned int pad2;
+	unsigned int si_c0d1u;	/* Chan 0 dev 1 UDMA timing */
+#define si_c0d1m si_c0d1u	/* Chan 0 dev 1 Multiword DMA timing */
+	unsigned int si_c0c;	/* Chan 0 Control */
+	unsigned int si_c0s0;	/* Chan 0 Status 0 */
+	unsigned int si_c0ie;	/* Chan 0 Interrupt Enable */
+	unsigned int si_c0s1;	/* Chan 0 Status 0 */
+	unsigned int pad4[4];
+	unsigned int si_c0dcm;	/* Chan 0 DMA Command */
+	unsigned int si_c0tb;	/* Chan 0 PRD Table base address */
+	unsigned int si_c0dct;	/* Chan 0 DMA Count */
+	unsigned int si_c0da;	/* Chan 0 DMA Address */
+	unsigned int si_c0sr;	/* Chan 0 Slew Rate Output Control */
+	unsigned char pad5[0xa2];
+	unsigned short si_c0adc;	/* Chan 0 Alt status/control */
+	unsigned char si_c0d;	/* Chan 0 data */
+	unsigned char si_c0ef;	/* Chan 0 error/features */
+	unsigned char si_c0sct;	/* Chan 0 sector count */
+	unsigned char si_c0sn;	/* Chan 0 sector number */
+	unsigned char si_c0cl;	/* Chan 0 cylinder low */
+	unsigned char si_c0ch;	/* Chan 0 cylinder high */
+	unsigned char si_c0dh;	/* Chan 0 device/head */
+	unsigned char si_c0scm;	/* Chan 0 status/command */
+} ide_t;
+
+/* The structure of the PRD entry.  The address must be word aligned,
+ * and the count must be an even number of bytes.
+ */
+typedef struct {
+	unsigned int prd_physptr;
+	unsigned int prd_count;	/* Count only in lower 16 bits */
+} prd_entry_t;
+#define PRD_EOT		(uint)0x80000000	/* Set in prd_count */
+
+/* The number of PRDs required in a single transfer from the upper IDE
+ * functions.  I believe the maximum number is 128, but most seem to
+ * code to 256.  It's probably best to keep this under one page......
+ */
+#define NUM_PRD	256
+
+static volatile ide_t *idp;
+/* Virtual and physical address of the PRD page.
+*/
+static prd_entry_t *prd_table;
+static dma_addr_t prd_phys;
+
+/* Function Prototypes */
+static void ocp_ide_tune_drive(ide_drive_t *, byte);
+static int ocp_ide_dma_off(ide_drive_t * drive);
+
+/* The STB04 has a fixed number of cycles that get added in
+ * regardless.  Adjust an ide_timing struct to accommodate that.
+ */
+static void
+ocp_ide_adjust_timing(struct ide_timing *t)
+{
+	t->setup -= 2;
+	t->act8b -= 1;
+	t->rec8b -= 1;
+	t->active -= 1;
+	t->recover -= 1;
+}
+
+/* this iis barrowed from ide_timing_find_mode so we can find the proper 
+ * whold parameter 
+ */
+
+static short
+whold_timing_find_mode(short speed)
+{
+	struct whold_timing *t;
+
+	for (t = whold_timing; t->mode != speed; t++)
+		if (t->mode < 0)
+			return 0;
+	return t->whold;
+}
+
+static int
+ocp_ide_set_drive(ide_drive_t * drive, unsigned char speed)
+{
+	ide_drive_t *peer;
+	struct ide_timing d, p, merge, *fast;
+	int fast_device;
+	unsigned int ctl;
+	volatile unsigned int *dtiming;
+
+	if (speed != XFER_PIO_SLOW && speed != drive->current_speed)
+		if (ide_config_drive_speed(drive, speed))
+			printk(KERN_WARNING
+			       "ide%d: Drive %d didn't accept speed setting. Oh, well.\n",
+			       drive->dn >> 1, drive->dn & 1);
+
+	ide_timing_compute(drive, speed, &d, SYS_CLOCK_NS, SYS_CLOCK_NS);
+	ocp_ide_adjust_timing(&d);
+
+	/* This should be set somewhere else, but it isn't.....
+	 */
+	drive->dn = ((drive->select.all & 0x10) != 0);
+	peer = HWIF(drive)->drives + (~drive->dn & 1);
+
+	if (peer->present) {
+		ide_timing_compute(peer, peer->current_speed, &p,
+				   SYS_CLOCK_NS, SYS_CLOCK_NS);
+		ocp_ide_adjust_timing(&p);
+		ide_timing_merge(&p, &d, &merge,
+				 IDE_TIMING_8BIT | IDE_TIMING_SETUP);
+	} else {
+		merge = d;
+	}
+
+	if (!drive->init_speed)
+		drive->init_speed = speed;
+	drive->current_speed = speed;
+
+	/* Now determine which drive is faster, and set up the
+	 * interface timing.  It would sure be nice if they would
+	 * have just had the timing registers for each device......
+	 */
+	if (drive->dn & 1)
+		pio_mode[1] = (int) speed;
+	else
+		pio_mode[0] = (int) speed;
+
+	if (pio_mode[0] > pio_mode[1])
+		fast_device = 0;
+	else
+		fast_device = 1;
+
+	/* Now determine which of the drives
+	 * the first call we only know one device, and on subsequent
+	 * calls the user may manually change drive parameters.
+	 * Make timing[0] the fast device and timing[1] the slow.
+	 */
+	if (fast_device == (drive->dn & 1))
+		fast = &d;
+	else
+		fast = &p;
+
+	/* Now we know which device is the fast one and which is
+	 * the slow one.  The merged timing goes into the "regular"
+	 * timing registers and represents the slower of both times.
+	 */
+
+	idp->si_c0rt = MK_TIMING(merge.setup, merge.act8b,
+				 merge.rec8b,
+				 whold_timing_find_mode(merge.mode));
+
+	idp->si_c0fpt = MK_TIMING(fast->setup, fast->act8b,
+				  fast->rec8b,
+				  whold_timing_find_mode(fast->mode));
+
+	/* Tell the interface which drive is the fast one.
+	 */
+	ctl = idp->si_c0c;	/* Chan 0 Control */
+	ctl &= ~0x10000000;
+	ctl |= fast_device << 28;
+	idp->si_c0c = ctl;
+
+	/* Set up DMA timing.
+	 */
+	if ((speed & XFER_MODE) != XFER_PIO) {
+		/* NOTE: si_c0d0m and si_c0d0u are two different names
+		 * for the same register.  Whether it is used for
+		 * Multi-word DMA timings or Ultra DMA timings is
+		 * determined by the LSB written into it.  This is also
+		 * true for si_c0d1m and si_c0d1u.  */
+		if (drive->dn & 1)
+			dtiming = &(idp->si_c0d1m);
+		else
+			dtiming = &(idp->si_c0d0m);
+
+		if ((speed & XFER_MODE) == XFER_UDMA) {
+			static const int tRP[] = {
+				EZ(160, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(125, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(85, SYS_CLOCK_NS) - 2	/*fixed cycles */
+			};
+			static const int NUMtRP =
+			    (sizeof (tRP) / sizeof (tRP[0]));
+			*dtiming =
+			    MK_UTIMING(d.udma,
+				       tRP[FIT(speed & 0xf, 0, NUMtRP - 1)]);
+		} else {
+			/* Multi-word DMA.  Note that d.recover/2 is an
+			 * approximation of MAX(tH, MAX(tJ, tN)) */
+			*dtiming = MK_TIMING(d.setup, d.active,
+					     d.recover, d.recover / 2);
+		}
+		drive->using_dma = 1;
+	}
+
+	return 0;
+}
+
+static void
+ocp_ide_tune_drive(ide_drive_t * drive, byte pio)
+{
+	pio = ide_get_best_pio_mode(drive, pio, 5, NULL);
+}
+
+/*
+ * Fill in the next PRD entry.
+ */
+
+static int ocp_ide_build_prd_entry(prd_entry_t **table, unsigned int paddr, 
+				   unsigned int size, int *count)
+{
+
+	/*
+	 * Note that one PRD entry can transfer
+	 * at most 65535 bytes.
+	 */
+
+	while (size) {
+		unsigned int tc = (size < 0xfe00) ? size : 0xfe00;
+
+		if (++(*count) >= NUM_PRD) {
+		  printk(KERN_WARNING "DMA table too small\n");
+			return 0;	/* revert to PIO for this request */
+		}
+		(*table)->prd_physptr = (paddr & 0xfffffffe);
+
+		if ((*table)->prd_physptr & 0xF) {
+			printk(KERN_WARNING "DMA buffer not 16 byte aligned.\n");
+			return 0;	/* revert to PIO for this request */
+		}
+		
+		(*table)->prd_count = (tc & 0xfffe);
+		paddr += tc;
+		size -= tc;
+		++(*table);
+	}
+
+	return 1;
+}
+
+
+static int
+ocp_ide_build_dmatable(ide_drive_t * drive, int wr)
+{
+	prd_entry_t *table;
+	int count = 0;
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned long size, vaddr, paddr;
+	unsigned long prd_size, prd_paddr = 0;
+	struct bio_vec *bvec, *bvprv;
+	struct bio *bio;
+	int i;
+
+	table = prd_table;
+
+	bvprv = NULL;
+	rq_for_each_bio(bio, rq) {
+		bio_for_each_segment(bvec, bio, i) {
+			paddr = bvec_to_phys(bvec);
+			vaddr = (unsigned long) __va(paddr);
+			size = bvec->bv_len;
+			if (wr)
+				consistent_sync((void *)vaddr, 
+						size, PCI_DMA_TODEVICE);
+			else
+				consistent_sync((void *)vaddr,
+						size, PCI_DMA_FROMDEVICE);
+
+			if (!BIOVEC_PHYS_MERGEABLE(bvprv, bvec)) {
+				if (ocp_ide_build_prd_entry(&table, 
+							    prd_paddr,
+							    prd_size,
+							    &count) == 0)
+					return 0; /* use PIO */
+				prd_paddr = 0;
+			}
+
+			if (prd_paddr == 0) {
+				prd_paddr = paddr;
+				prd_size = size;
+			} else {
+			  prd_size += size;
+			}
+
+			bvprv = bvec;
+		} /* segments in bio */
+	} /* bios in rq */
+
+	if (prd_paddr) {
+		if (ocp_ide_build_prd_entry(&table, 
+					    prd_paddr,
+					    prd_size,
+					    &count) == 0)
+			return 0; /* use PIO */
+	}
+
+	/* Add the EOT to the last table entry.
+	 */
+	if (count) {
+		table--;
+		table->prd_count |= PRD_EOT;
+	} else {
+		printk(KERN_DEBUG "%s: empty DMA table?\n", drive->name);
+	}
+
+	return 1;
+}
+
+/*
+ * ocp_ide_dma_intr() is the handler for disk read/write DMA interrupts
+ * This is taken directly from ide-dma.c, which we can't use because
+ * it requires PCI support.
+ */
+ide_startstop_t
+ocp_ide_dma_intr(ide_drive_t * drive)
+{
+	int i;
+	byte stat, dma_stat;
+
+	dma_stat = HWIF(drive)->ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);	/* get drive status */
+	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT)) {
+		if (!dma_stat) {
+			struct request *rq = HWGROUP(drive)->rq;
+			rq = HWGROUP(drive)->rq;
+			for (i = rq->nr_sectors; i > 0;) {
+				i -= rq->current_nr_sectors;
+				ide_end_request(drive, 1, 
+						rq->current_nr_sectors );
+			}
+			return ide_stopped;
+		}
+		printk("%s: dma_intr: bad DMA status (dma_stat=%x)\n",
+		       drive->name, dma_stat);
+	}
+	return ide_error(drive, "dma_intr", stat);
+}
+
+/* ....and another one....
+*/
+int
+report_drive_dmaing(ide_drive_t * drive)
+{
+	struct hd_driveid *id = drive->id;
+
+	if ((id->field_valid & 4) && (eighty_ninty_three(drive)) &&
+	    (id->dma_ultra & (id->dma_ultra >> 11) & 7)) {
+		if ((id->dma_ultra >> 13) & 1) {
+			printk(", UDMA(100)");	/* UDMA BIOS-enabled! */
+		} else if ((id->dma_ultra >> 12) & 1) {
+			printk(", UDMA(66)");	/* UDMA BIOS-enabled! */
+		} else {
+			printk(", UDMA(44)");	/* UDMA BIOS-enabled! */
+		}
+	} else if ((id->field_valid & 4) &&
+		   (id->dma_ultra & (id->dma_ultra >> 8) & 7)) {
+		if ((id->dma_ultra >> 10) & 1) {
+			printk(", UDMA(33)");	/* UDMA BIOS-enabled! */
+		} else if ((id->dma_ultra >> 9) & 1) {
+			printk(", UDMA(25)");	/* UDMA BIOS-enabled! */
+		} else {
+			printk(", UDMA(16)");	/* UDMA BIOS-enabled! */
+		}
+	} else if (id->field_valid & 4) {
+		printk(", (U)DMA");	/* Can be BIOS-enabled! */
+	} else {
+		printk(", DMA");
+	}
+	return 1;
+}
+
+static int
+ocp_ide_check_dma(ide_drive_t * drive)
+{
+	struct hd_driveid *id = drive->id;
+	int enable = 1;
+	int speed;
+
+	drive->using_dma = 0;
+
+	if (drive->media == ide_floppy)
+		enable = 0;
+
+	/* Check timing here, we may be able to include XFER_UDMA_66
+	 * and XFER_UDMA_100.  This basically tells the 'best_mode'
+	 * function to also consider UDMA3 to UDMA5 device timing.
+	 */
+	if (enable) {
+		/* Section 1.6.2.6 "IDE Controller, ATA/ATAPI-5" in the STB04xxx
+		 * Datasheet says the following modes are supported:
+		 *   PIO modes 0 to 4
+		 *   Multiword DMA modes 0 to 2
+		 *   UltraDMA modes 0 to 4
+		 */
+		int map = XFER_PIO | XFER_EPIO | XFER_MWDMA | XFER_UDMA;
+		/* XFER_EPIO includes both PIO modes 4 and 5.  Mode 5 is not
+		 * valid for the STB04, so mask it out of consideration just
+		 * in case some drive sets it...
+		 */
+		id->eide_pio_modes &= ~4;
+
+		/* Allow UDMA_66 only if an 80 conductor cable is connected. */
+		if (eighty_ninty_three(drive))
+			map |= XFER_UDMA_66;
+
+		speed = ide_find_best_mode(drive, map);
+		ocp_ide_set_drive(drive, speed);
+
+		if (HWIF(drive)->autodma &&
+		    (((speed & XFER_MODE) == XFER_PIO) ||
+		     ((speed & XFER_MODE) == XFER_EPIO))) {
+			drive->using_dma = 0;
+		}
+	}
+
+	return 0;
+}
+
+static int ocp_ide_dma_off_quietly(ide_drive_t * drive)
+{
+	drive->using_dma = 0;
+	return 0;
+}
+
+static int ocp_ide_dma_off(ide_drive_t * drive)
+{
+	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
+	return ocp_ide_dma_off_quietly(drive);
+}
+
+static int ocp_ide_dma_on(ide_drive_t * drive)
+{
+	return ocp_ide_check_dma(drive);
+}
+
+static int ocp_ide_dma_check(ide_drive_t * drive)
+{
+	return ocp_ide_dma_on(drive);
+}
+
+static int __ocp_ide_dma_begin(ide_drive_t * drive, int writing)
+{
+	idp->si_c0tb = (unsigned int) prd_phys;
+	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
+	idp->si_c0ie = 0x90000000;	/* Enable all intr */
+	idp->si_c0dcm = 0;
+	idp->si_c0dcm =
+		(writing ? 0x09000000 : 0x01000000);
+	return 0;
+}
+
+static int ocp_ide_dma_begin(ide_drive_t * drive)
+{
+	idp->si_c0tb = (unsigned int) prd_phys;
+	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
+	idp->si_c0ie = 0x90000000;	/* Enable all intr */
+	idp->si_c0dcm = 0;
+	idp->si_c0dcm =	0x01000000;
+	return 0;
+}
+
+static int ocp_ide_dma_io(ide_drive_t * drive, int writing)
+{
+	if (!ocp_ide_build_dmatable(drive, writing))
+		return 1;
+
+	drive->waiting_for_dma = 1;
+	if (drive->media != ide_disk)
+		return 0;
+	ide_set_handler(drive, &ocp_ide_dma_intr, WAIT_CMD, NULL);
+	HWIF(drive)->OUTB(writing ? WIN_WRITEDMA : WIN_READDMA,
+		 IDE_COMMAND_REG);
+	return __ocp_ide_dma_begin(drive, writing);
+}
+
+static int ocp_ide_dma_read(ide_drive_t * drive)
+{
+	return ocp_ide_dma_io(drive, 0);
+}
+
+static int ocp_ide_dma_write(ide_drive_t * drive)
+{
+	return ocp_ide_dma_io(drive, 1);
+}
+
+static int ocp_ide_dma_end(ide_drive_t * drive)
+{
+	unsigned int dstat;
+
+	drive->waiting_for_dma = 0;
+	dstat = idp->si_c0s1;
+	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
+	/* verify good dma status */
+	return (dstat & 0x80000000);
+}
+
+static int ocp_ide_dma_test_irq(ide_drive_t * drive)
+{
+	return idp->si_c0s0 & 0x10000000 ? 1 : 0;
+}
+
+static int ocp_ide_dma_verbose(ide_drive_t * drive)
+{
+	return report_drive_dmaing(drive);
+}
+
+static unsigned int
+ocp_ide_spinup(int index)
+{
+	int i, ret;
+	ide_ioreg_t *io_ports;
+
+	ret = 1;
+	printk("OCP ide: waiting for drive spinup");
+	printk("ioports for drive %d @ %p\n",index,ide_hwifs[index].io_ports);
+	io_ports = ide_hwifs[index].io_ports;
+	printk(".");
+	
+	/* wait until drive is not busy (it may be spinning up) */
+	for (i = 0; i < 30; i++) {
+		unsigned char stat;
+		stat = inb_p(io_ports[7]);
+		/* wait for !busy & ready */
+		if ((stat & 0x80) == 0) {
+			break;
+		}
+		udelay(1000 * 1000);	/* 1 second */
+	}
+
+	printk(".");
+
+	/* select slave */
+	outb_p(0xa0 | 0x10, io_ports[6]);
+
+	for (i = 0; i < 30; i++) {
+		unsigned char stat;
+		stat = inb_p(io_ports[7]);
+		/* wait for !busy & ready */
+		if ((stat & 0x80) == 0) {
+			break;
+		}
+		udelay(1000 * 1000);	/* 1 second */
+	}
+	if( i < 30){
+		outb_p(0xa0, io_ports[6]);
+		printk("Drive spun up \n");
+	} else {
+		printk("Drive spin up Failed !\n");
+		ret = 0;
+	}
+	return (ret);
+}
+
+int
+ocp_ide_default_irq(ide_ioreg_t base)
+{
+	return IDE0_IRQ;
+}
+
+/*
+ * setup_ocp_ide()
+ * Completes the setup of a on-chip ide controller card, once found.
+ */
+int __init setup_ocp_ide (struct ocp_device *pdev)
+{
+	ide_hwif_t	*hwif;
+	unsigned int uicdcr;
+	
+	hwif = &ide_hwifs[pdev->num];
+	hwif->index = pdev->num;
+#ifdef WMODE
+   /*Word Mode psc(11-12)=00,pwc(13-18)=000110, phc(19-21)=010, 22=1, 30=1  ----  0xCB02*/
+
+    dma_ch.mode	=TM_S_MM;	  /* xfer from peripheral to mem */
+    dma_ch.pwidth = PW_16;
+    dma_ch.pwc = 6;                     /* set the max wait cycles  */
+#else
+/*Line Mode psc(11-12)=00,pwc(13-18)=000001, phc(19-21)=010, 22=1, 30=1  ----  0x2B02*/
+
+    dma_ch.mode	=DMA_MODE_MM_DEVATSRC;	  /* xfer from peripheral to mem */
+    dma_ch.pwidth = PW_64;		/* Line mode on stbs */
+    dma_ch.pwc = 1;                     /* set the max wait cycles  */
+#endif
+
+    dma_ch.td	= DMA_TD;
+    dma_ch.buffer_enable = 0;
+    dma_ch.tce_enable = 0;
+    dma_ch.etd_output = 0;
+    dma_ch.pce = 0;
+    dma_ch.pl = EXTERNAL_PERIPHERAL;    /* no op */
+    dma_ch.dai = 1;
+    dma_ch.sai = 0;
+    dma_ch.psc = 0;                      /* set the max setup cycles */
+    dma_ch.phc = 2;                      /* set the max hold cycles  */
+    dma_ch.cp = PRIORITY_LOW;
+    dma_ch.int_enable = 0;
+    dma_ch.ch_enable = 0;		/* No chaining */
+    dma_ch.tcd_disable = 1;		/* No chaining */
+
+    if (hw_init_dma_channel(IDE_DMACH, &dma_ch) != DMA_STATUS_GOOD)
+        return -EBUSY;
+
+    /* init CIC select2 reg to connect external DMA port 3 to internal
+     * DMA channel 2
+     */
+    map_dma_port(IDE_DMACH,EXT_DMA_3,DMA_CHAN_2); 
+
+    /* Enable the interface.
+     */
+    idp->si_control = 0x80000000;
+    idp->si_c0s0 = 0xdc800000;	/* Clear all status */
+    idp->si_intenable = 0x80000000;
+
+    /* Per the STB04 data sheet:
+     *  1)  tTO = ((8*RDYT) + 1) * SYS_CLK
+     * and:
+     *  2)  tTO >= 1250 + (2 * SYS_CLK) - t2
+     * Solving the first equation for RDYT:
+     *             (tTO/SYS_CLK) - 1
+     *  3)  RDYT = -----------------
+     *                     8
+     * Substituting equation 2) for tTO in equation 3:
+     *             ((1250 + (2 * SYS_CLK) - t2)/SYS_CLK) - 1
+     *  3)  RDYT = -----------------------------------------
+     *                                8
+     * It's just the timeout so having it too long isn't too
+     * significant, so we'll just assume t2 is zero.  All this math
+     * is handled by the compiler and RDYT ends up being 11 assuming
+     * that SYS_CLOCK_NS is 15.
+     */
+    idp->si_c0timo = (EZ(EZ(1250 + 2 * SYS_CLOCK_NS, SYS_CLOCK_NS) - 1, 8)) << 23;	/* Chan 0 timeout */
+
+    /* Stuff some slow default PIO timing.
+     */
+    idp->si_c0rt = MK_TIMING(6, 19, 15, 2);
+    idp->si_c0fpt = MK_TIMING(6, 19, 15, 2);
+    
+    /* We should probably have UIC functions to set external
+     * interrupt level/edge.
+     */
+    uicdcr = mfdcr(DCRN_UIC_PR(UIC0));
+    uicdcr &= ~(0x80000000 >> IDE0_IRQ);
+    mtdcr(DCRN_UIC_PR(UIC0), uicdcr);
+    mtdcr(DCRN_UIC_TR(UIC0), 0x80000000 >> IDE0_IRQ);
+
+    /* Grab a page for the PRD Table.
+     */
+    prd_table = (prd_entry_t *) consistent_alloc(GFP_KERNEL,
+						 NUM_PRD *
+						 sizeof
+						 (prd_entry_t),
+						 &prd_phys);
+
+
+    if(!ocp_ide_spinup(hwif->index))
+	    return 0;
+    
+    return 1;
+}
+
+
+static int __devinit ocp_ide_probe(struct ocp_device *pdev)
+{
+	int i;
+	unsigned int index;
+	hw_regs_t * hw;
+	unsigned char *ip;
+
+	printk("IBM STB04xxx IDE driver version %s\n", IDE_VER);
+
+	hw = kmalloc(sizeof(*hw), GFP_KERNEL);
+	if (!hw)
+		return 0;
+	memset(hw, 0, sizeof(*hw));
+
+	if (!request_region(pdev->paddr, IDE0_SIZE, "IDE")) {
+		printk(KERN_WARNING "ocp_ide: failed request_region\n");
+		return -1;
+	}
+
+	if ((idp = (ide_t *) ioremap(pdev->paddr,
+				     IDE0_SIZE)) == NULL) {
+		printk(KERN_WARNING "ocp_ide: failed ioremap\n");
+		return -1;
+	}
+
+	pdev->dev.driver_data = (void *) idp;
+
+	pdev->ocpdev  = (void *) hw;
+	index = pdev->num;
+	ip = (unsigned char *) (&(idp->si_c0d));	/* Chan 0 data */
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = (unsigned long) (ip++);
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = (unsigned long) (&(idp->si_c0adc));
+	hw->irq = pdev->irq;
+
+	/* use DMA channel 2 for IDE DMA operations */
+	hw->dma = IDE_DMACH;
+
+	ide_hwifs[index].tuneproc = &ocp_ide_tune_drive;
+	ide_hwifs[index].drives[0].autotune = 1;
+	ide_hwifs[index].autodma = 1;
+	ide_hwifs[index].ide_dma_off = &ocp_ide_dma_off;
+	ide_hwifs[index].ide_dma_off_quietly = &ocp_ide_dma_off_quietly;
+	ide_hwifs[index].ide_dma_host_off = &ocp_ide_dma_off_quietly;
+	ide_hwifs[index].ide_dma_on = &ocp_ide_dma_on;
+	ide_hwifs[index].ide_dma_host_on = &ocp_ide_dma_on;
+	ide_hwifs[index].ide_dma_check = &ocp_ide_dma_check;
+	ide_hwifs[index].ide_dma_read = &ocp_ide_dma_read;
+	ide_hwifs[index].ide_dma_write = &ocp_ide_dma_write;
+	ide_hwifs[index].ide_dma_begin = &ocp_ide_dma_begin;
+	ide_hwifs[index].ide_dma_end = &ocp_ide_dma_end;
+	ide_hwifs[index].ide_dma_test_irq = &ocp_ide_dma_test_irq;
+	ide_hwifs[index].ide_dma_verbose = &ocp_ide_dma_verbose;
+	ide_hwifs[index].speedproc = &ocp_ide_set_drive;
+	ide_hwifs[index].noprobe = 0;
+
+	memcpy(ide_hwifs[index].io_ports, hw->io_ports, sizeof (hw->io_ports));
+	ide_hwifs[index].irq = pdev->irq;
+
+	ocp_force_power_on(pdev);
+	return 1;
+}
+
+static void __devexit ocp_ide_remove_one (struct ocp_device *pdev)
+{
+	ocp_force_power_off(pdev);
+}
+
+static struct ocp_device_id ocp_ide_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_IDE},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_ide_id_tbl );
+
+static struct ocp_driver ocp_ide_driver = {
+	.name		= "ocp_ide",
+	.id_table	= ocp_ide_id_tbl,
+	.probe		= ocp_ide_probe,
+	.remove		= __devexit_p(ocp_ide_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_generic_suspend,
+	.resume		= ocp_generic_resume,
+#endif /* CONFIG_PM */
+};
+
+
+void __init std_ide_cntl_scan(void)
+{
+	struct ocp_device *dev;
+	int i, max;
+	printk("OCP ide ver:%s\n", IDE_VER);
+
+	ocp_module_init(&ocp_ide_driver);
+	max = ocp_get_num(OCP_FUNC_IDE);
+	for(i = 0; i < max; i++){
+		dev = ocp_get_dev(OCP_FUNC_IDE,i);
+		if(!dev)	
+		  setup_ocp_ide(dev);
+	}
+}
+#if 0
+#if defined (CONFIG_MODULE)
+static int __init
+ocp_ide_init(void)
+{
+	printk("OCP ide ver:%s\n", IDE_VER);
+	return ocp_module_init(&ocp_ide_driver);
+}
+
+void __exit
+ocp_ide_fini(void)
+{
+	ocp_unregister_driver(&ocp_ide_driver);
+}
+
+module_init(ocp_ide_init);
+module_exit(ocp_ide_fini);
+#endif
+#endif
+
diff -p -purN linux-2.5/drivers/ide/ppc/ocp_stbxxxxx.c linuxppc-2.5/drivers/ide/ppc/ocp_stbxxxxx.c
--- linux-2.5/drivers/ide/ppc/ocp_stbxxxxx.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/ide/ppc/ocp_stbxxxxx.c	2003-01-08 05:34:25.000000000 +0100
@@ -0,0 +1,578 @@
+/*
+ *    Copyright 2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: Armin Kuster <akuster@mvista.com>
+ *      MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: ocp_stbxxxx.c
+ *
+ *    Description:
+ *
+ *    Based on stb03xxx.c
+ */
+
+#include <linux/types.h>
+#include <linux/hdreg.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <asm/ocp.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+#include <asm/ppc4xx_dma.h>
+
+#include "ide_modes.h"
+
+#define IDE_VER			"2.0"
+ppc_dma_ch_t dma_ch;
+
+/* use DMA channel 2 for IDE DMA operations */
+#define IDE_DMACH	2	/* 2nd DMA channel */
+#define IDE_DMA_INT	6	/* IDE dma channel 2 interrupt */
+
+extern char *ide_dmafunc_verbose(ide_dma_action_t dmafunc);
+
+#define WMODE	0		/* default to DMA line mode */
+#define PIOMODE	0
+static volatile unsigned long dmastat;
+
+/* Function Prototypes */
+static void ocp_ide_tune_drive(ide_drive_t *, byte);
+static byte ocp_ide_dma_2_pio(byte);
+static int ocp_ide_tune_chipset(ide_drive_t *, byte);
+static int ocp_ide_dmaproc(ide_dma_action_t, ide_drive_t *);
+
+static void
+ocp_ide_tune_drive(ide_drive_t * drive, byte pio)
+{
+	pio = ide_get_best_pio_mode(drive, pio, 5, NULL);
+}
+
+static byte
+ocp_ide_dma_2_pio(byte xfer_rate)
+{
+	switch (xfer_rate) {
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+	case XFER_MW_DMA_2:
+	case XFER_PIO_4:
+		return 4;
+	case XFER_MW_DMA_1:
+	case XFER_PIO_3:
+		return 3;
+	case XFER_SW_DMA_2:
+	case XFER_PIO_2:
+		return 2;
+	case XFER_MW_DMA_0:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+	case XFER_PIO_SLOW:
+	default:
+		return 0;
+	}
+}
+
+static int
+ocp_ide_tune_chipset(ide_drive_t * drive, byte speed)
+{
+	int err = 0;
+
+	ocp_ide_tune_drive(drive, ocp_ide_dma_2_pio(speed));
+
+	if (!drive->init_speed)
+		drive->init_speed = speed;
+	err = ide_config_drive_speed(drive, speed);
+	drive->current_speed = speed;
+	return err;
+}
+
+static int
+redwood_config_drive_for_dma(ide_drive_t * drive)
+{
+	struct hd_driveid *id = drive->id;
+	byte speed;
+	int func = ide_dma_off;
+
+	/*
+	 * Enable DMA on any drive that has multiword DMA
+	 */
+	if (id->field_valid & 2) {
+		if (id->dma_mword & 0x0004) {
+			speed = XFER_MW_DMA_2;
+			func = ide_dma_on;
+		} else if (id->dma_mword & 0x0002) {
+			speed = XFER_MW_DMA_1;
+			func = ide_dma_on;
+		} else if (id->dma_mword & 1) {
+			speed = XFER_MW_DMA_0;
+			func = ide_dma_on;
+		} else if (id->dma_1word & 0x0004) {
+			speed = XFER_SW_DMA_2;
+			func = ide_dma_on;
+		} else {
+			speed = XFER_PIO_0 +
+			    ide_get_best_pio_mode(drive, 255, 5, NULL);
+		}
+	}
+
+	ocp_ide_tune_drive(drive, ocp_ide_dma_2_pio(speed));
+	return ocp_ide_dmaproc(func, drive);
+}
+
+ide_startstop_t
+ocp_ide_intr(ide_drive_t * drive)
+{
+	int i;
+	byte dma_stat;
+	unsigned int nsect;
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	struct request *rq = hwgroup->rq;
+	unsigned long block, b1, b2, b3, b4;
+
+	nsect = rq->current_nr_sectors;
+
+	dma_stat = HWIF(drive)->dmaproc(ide_dma_end, drive);
+
+	rq->sector += nsect;
+	rq->buffer += nsect << 9;
+	rq->errors = 0;
+	i = (rq->nr_sectors -= nsect);
+	ide_end_request(1, HWGROUP(drive));
+	if (i > 0) {
+		b1 = IN_BYTE(IDE_SECTOR_REG);
+		b2 = IN_BYTE(IDE_LCYL_REG);
+		b3 = IN_BYTE(IDE_HCYL_REG);
+		b4 = IN_BYTE(IDE_SELECT_REG);
+		block = ((b4 & 0x0f) << 24) + (b3 << 16) + (b2 << 8) + (b1);
+		block++;
+		if (drive->select.b.lba) {
+			OUT_BYTE(block, IDE_SECTOR_REG);
+			OUT_BYTE(block >>= 8, IDE_LCYL_REG);
+			OUT_BYTE(block >>= 8, IDE_HCYL_REG);
+			OUT_BYTE(((block >> 8) & 0x0f) | drive->select.all,
+				 IDE_SELECT_REG);
+		} else {
+			unsigned int sect, head, cyl, track;
+			track = block / drive->sect;
+			sect = block % drive->sect + 1;
+			OUT_BYTE(sect, IDE_SECTOR_REG);
+			head = track % drive->head;
+			cyl = track / drive->head;
+			OUT_BYTE(cyl, IDE_LCYL_REG);
+			OUT_BYTE(cyl >> 8, IDE_HCYL_REG);
+			OUT_BYTE(head | drive->select.all, IDE_SELECT_REG);
+		}
+
+		if (rq->cmd == READ)
+			dma_stat = HWIF(drive)->dmaproc(ide_dma_read, drive);
+		else
+			dma_stat = HWIF(drive)->dmaproc(ide_dma_write, drive);
+		return ide_started;
+	}
+	return ide_stopped;
+}
+
+void
+ocp_ide_dma_intr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	dmastat = get_dma_status();
+#if WMODE
+	if (dmastat & 0x1000) {
+		//This should not happen at least in Word Mode, I have noticed this. Is it some timing problem ?
+		printk
+		    ("ocp_ide_dma_intr dma req pending from external device\n");
+	}
+#endif
+
+	clr_dma_status(IDE_DMACH);
+}
+
+static int
+ocp_ide_dmaproc(ide_dma_action_t func, ide_drive_t * drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int i, reading = 0;
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned long flags;
+	unsigned long length;
+
+	switch (func) {
+	case ide_dma_off:
+	case ide_dma_off_quietly:
+		/*disable_dma */
+		return 0;
+
+	case ide_dma_on:
+#if PIOMODE
+		return 1;
+#endif
+
+		mtdcr(DCRN_DMACR2, 0);
+		clr_dma_status(IDE_DMACH);
+
+		save_flags(flags);
+		cli();
+		if (ide_request_irq
+		    (IDE_DMA_INT, &ocp_ide_dma_intr, SA_INTERRUPT,
+		     hwif->name, hwif->hwgroup)) {
+			printk("ide_redwood: ide_request_irq failed int=%d\n",
+			       IDE_DMA_INT);
+			restore_flags(flags);
+			return 1;
+		}
+		restore_flags(flags);
+
+		drive->using_dma = (func == ide_dma_on);
+#if WMODE
+		mtdcr(DCRN_DCRXBCR, 0);
+		mtdcr(DCRN_CICCR, mfdcr(DCRN_CICCR) | 0x00000400);
+#else
+		/* Configure CIC reg for line mode dma */
+		mtdcr(DCRN_CICCR, mfdcr(DCRN_CICCR) & ~0x00000400);
+#endif
+		return 0;
+
+	case ide_dma_check:
+		return redwood_config_drive_for_dma(drive);
+	case ide_dma_read:
+		reading = 1;
+	case ide_dma_write:
+		if (drive->media != ide_disk)
+			return -1;
+
+		if (get_channel_config(IDE_DMACH, &dma_ch) & DMA_CHANNEL_BUSY )	/* DMA is busy? */
+			return -1;
+
+
+		if (reading) {
+			dma_cache_inv((unsigned long) rq->buffer,
+				      rq->current_nr_sectors * 512);
+#if WMODE
+			set_src_addr(IDE_DMACH, 0);
+#else
+			set_src_addr(IDE_DMACH, 0xfce00000);
+#endif
+			set_dst_addr(IDE_DMACH, virt_to_bus(rq->buffer));
+		} else {
+			dma_cache_wback_inv((unsigned long) rq->buffer,
+					    rq->current_nr_sectors * 512);
+			set_src_addr(IDE_DMACH, virt_to_bus(rq->buffer));
+#if WMODE
+			set_dst_addr(2, 0);
+#else
+			set_dst_addr(IDE_DMACH, 0xfce00000);
+#endif
+		}
+
+#if WMODE
+		length = rq->current_nr_sectors * 512 / 2;
+#else
+		length = rq->current_nr_sectors * 512 / 16;
+#endif
+		OUT_BYTE(rq->current_nr_sectors, IDE_NSECTOR_REG);
+		set_dma_count(IDE_DMACH, length);
+
+		/* CE=0 disable DMA */
+		/* Set up the Line Buffer Control Register
+		 * 11d1xxxx0.. - 11=Mode 2 (120 ns cycle), d=1/0(read/write)
+		 * 1=active, 0=1X clock mode.
+		 */
+
+		if (reading) {
+#if WMODE
+			set_dma_mode(IDE_DMACH,DMA_TD | TM_S_MM);
+#else
+		mtdcr(DCRN_DCRXBCR, 0x90000000);
+		set_dma_mode(IDE_DMACH,SET_DMA_DAI(1) | SET_DMA_SAI(0) | DMA_MODE_MM_DEVATDST);
+#endif
+		} else {
+#if WMODE
+			set_dma_mode(IDE_DMACH,DMA_TD | TM_S_MM);
+#else
+			mtdcr(DCRN_DCRXBCR, 0xB0000000);
+			set_dma_mode(IDE_DMACH,SET_DMA_DAI(0) | SET_DMA_SAI(1) | DMA_MODE_MM_DEVATDST);
+#endif
+		}
+
+		set_dma_mode(hwif->hw.dma, reading
+			     ? DMA_MODE_READ : DMA_MODE_WRITE);
+		drive->waiting_for_dma = 1;
+		ide_set_handler(drive, &ocp_ide_intr, WAIT_CMD, NULL);
+		OUT_BYTE(reading ? WIN_READDMA : WIN_WRITEDMA, IDE_COMMAND_REG);
+
+	case ide_dma_begin:
+		/* enable DMA */
+		enable_dma_interrupt(IDE_DMACH);
+		/* wait for dma to complete (channel 2 terminal count) */
+		for (i = 0; i < 5000000; i++) {
+			if (dmastat & DMA_CS2)
+				break;
+		}
+		dmastat = 0;
+		return 0;
+
+	case ide_dma_end:
+		drive->waiting_for_dma = 0;
+
+		/* disable DMA */
+		disable_dma_interrupt(IDE_DMACH);
+		return 0;
+
+	case ide_dma_test_irq:
+		return 1;	/* returns 1 if dma irq issued, 0 otherwise */
+
+	case ide_dma_bad_drive:
+	case ide_dma_good_drive:
+	case ide_dma_verbose:
+	case ide_dma_timeout:
+	case ide_dma_retune:
+	case ide_dma_lostirq:
+		printk("ide_dmaproc: chipset supported %s func only: %d\n",
+		       ide_dmafunc_verbose(func), func);
+		return 1;
+	default:
+		printk("ide_dmaproc: unsupported %s func: %d\n",
+		       ide_dmafunc_verbose(func), func);
+		return 1;
+
+	}
+
+}
+void
+ibm4xx_ide_spinup(int index)
+{
+	int i;
+	ide_ioreg_t *io_ports;
+
+	printk("ide_redwood: waiting for drive ready..");
+	io_ports = ide_hwifs[index].io_ports;
+
+	/* wait until drive is not busy (it may be spinning up) */
+	for (i = 0; i < 30; i++) {
+		unsigned char stat;
+		stat = inb_p(io_ports[7]);
+		/* wait for !busy & ready */
+		if ((stat & 0x80) == 0) {
+			break;
+		}
+
+		udelay(1000 * 1000);	/* 1 second */
+	}
+
+	printk("..");
+
+	/* select slave */
+	outb_p(0xa0 | 0x10, io_ports[6]);
+
+	for (i = 0; i < 30; i++) {
+		unsigned char stat;
+		stat = inb_p(io_ports[7]);
+		/* wait for !busy & ready */
+		if ((stat & 0x80) == 0) {
+			break;
+		}
+
+		udelay(1000 * 1000);	/* 1 second */
+	}
+
+	printk("..");
+
+	outb_p(0xa0, io_ports[6]);
+	printk("Drive spun up \n");
+}
+
+int
+nonpci_ide_default_irq(ide_ioreg_t base)
+{
+	return IDE0_IRQ;
+}
+/*
+ * setup_ocp_ide()
+ * Completes the setup of a on-chip ide controller card, once found.
+ */
+int __init setup_ocp_ide (ide_hwif_t *hwif)
+{
+
+	unsigned long ioaddr;
+	int i, index;
+	
+	ide_drive_t *drive;
+	ide_hwif_t *hwif2;
+	struct dc_ident ident;
+	ide_startstop_t startstop;
+	
+	if (!hwif) return 0;
+
+
+	if (!request_region(REDWOOD_IDE_CMD, 0x10, "IDE"))
+		return;
+
+	if (!request_region(REDWOOD_IDE_CTRL, 2, "IDE")) {
+		release_region(REDWOOD_IDE_CMD, 0x10);
+		return;
+	}
+
+	ioaddr = (unsigned long) ioremap(REDWOOD_IDE_CMD, 0x10);
+
+	hw->irq = IDE0_IRQ;
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = ioaddr;
+		ioaddr += 2;
+	}
+	hw->io_ports[IDE_CONTROL_OFFSET] =
+	    (unsigned long) ioremap(REDWOOD_IDE_CTRL, 2);
+
+	/* use DMA channel 2 for IDE DMA operations */
+	hw->dma = IDE_DMACH;
+#ifdef WMODE
+   /*Word Mode psc(11-12)=00,pwc(13-18)=000110, phc(19-21)=010, 22=1, 30=1  ----  0xCB02*/
+
+    dma_ch.mode	=TM_S_MM;	  /* xfer from peripheral to mem */
+    dma_ch.td	= DMA_TD;
+    dma_ch.buffer_enable = FALSE;
+    dma_ch.tce_enable = FALSE;
+    dma_ch.etd_output = FALSE;
+    dma_ch.pce = FALSE;
+    dma_ch.pl = EXTERNAL_PERIPHERAL;    /* no op */
+    dma_ch.pwidth = PW_16;
+    dma_ch.dai = TRUE;
+    dma_ch.sai = FALSE;
+    dma_ch.psc = 0;                      /* set the max setup cycles */
+    dma_ch.pwc = 6;                     /* set the max wait cycles  */
+    dma_ch.phc = 2;                      /* set the max hold cycles  */
+    dma_ch.cp = PRIORITY_LOW;
+    dma_ch.int_enable = FALSE;
+    dma_ch.ch_enable = FALSE;		/* No chaining */
+    dma_ch.tcd_disable = TRUE;		/* No chaining */
+#else
+/*Line Mode psc(11-12)=00,pwc(13-18)=000001, phc(19-21)=010, 22=1, 30=1  ----  0x2B02*/
+
+   dma_ch.mode	=DMA_MODE_MM_DEVATSRC;	  /* xfer from peripheral to mem */
+   dma_ch.td	= DMA_TD;
+   dma_ch.buffer_enable = FALSE;
+    dma_ch.tce_enable = FALSE;
+    dma_ch.etd_output = FALSE;
+    dma_ch.pce = FALSE;
+    dma_ch.pl = EXTERNAL_PERIPHERAL;    /* no op */
+    dma_ch.pwidth = PW_64;		/* Line mode on stbs */
+    dma_ch.dai = TRUE;
+    dma_ch.sai = FALSE;
+    dma_ch.psc = 0;                      /* set the max setup cycles */
+    dma_ch.pwc = 1;                     /* set the max wait cycles  */
+    dma_ch.phc = 2;                      /* set the max hold cycles  */
+    dma_ch.cp = PRIORITY_LOW;
+    dma_ch.int_enable = FALSE;
+    dma_ch.ch_enable = FALSE;		/* No chaining */
+    dma_ch.tcd_disable = TRUE;		/* No chaining */
+
+#endif
+    if (hw_init_dma_channel(IDE_DMACH, &dma_ch) != DMA_STATUS_GOOD)
+        return -EBUSY;
+
+	/* init CIC select2 reg to connect external DMA port 3 to internal
+	 * DMA channel 2
+	 */
+       map_dma_port(IDE_DMACH,EXT_DMA_3,DMA_CHAN_2); 
+
+	index = 0;
+
+	ide_hwifs[index].tuneproc = &ocp_ide_tune_drive;
+	ide_hwifs[index].drives[0].autotune = 1;
+#ifdef CONFIG_BLK_DEV_IDEDMA
+	ide_hwifs[index].autodma = 1;
+	ide_hwifs[index].dmaproc = &ocp_ide_dmaproc;
+#endif
+	ide_hwifs[index].speedproc = &ocp_ide_tune_chipset;
+	ide_hwifs[index].noprobe = 0;
+
+	memcpy(ide_hwifs[index].io_ports, hw->io_ports, sizeof (hw->io_ports));
+	ide_hwifs[index].irq = hw->irq;
+	ibm4xx_ide_spinup(index);
+}
+
+void __init ocp_ide_init(void)
+{
+	unsigned int	index;
+	ide_hwif_t	*hwif;
+
+	for (index = 0; index < MAX_HWIFS; index++) {
+		hwif = &ide_hwifs[index];
+			setup_ocp_ide(hwif);
+	}
+}
+
+static int __devinit ocp_ide_probe(struct ocp_device *pdev)
+{
+	printk("IBM IDE driver version %s\n", IDEVR);
+
+	DBG("Vendor:%x Device:%x.%d @%p irq:%d\n",pdev->vendor, pdev->device,pdev->num,pdev->paddr,pdev->irq);
+
+	ocp_force_power_on(pdev);
+	return 1;
+}
+static void __devexit ocp_ide_remove_one (struct ocp_device *pdev)
+{
+	ocp_force_power_off(pdev);
+}
+
+static struct ocp_device_id ocp_ide_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_IDE},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_ide_id_tbl );
+
+static struct ocp_driver ocp_ide_driver = {
+	.name		= "ocp_ide",
+	.id_table	= ocp_ide_id_tbl,
+	.probe		= ocp_ide_probe,
+	.remove		= __devexit_p(ocp_ide_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_generic_suspend,
+	.resume		= ocp_generic_resume,
+#endif /* CONFIG_PM */
+};
+
+void __init ide_scan_ocpdev (struct ocp_device *dev)
+{
+
+}
+
+void __init ide_scan_ocpbus (int scan_direction)
+{
+	struct ocp_device *dev;
+
+	if (!scan_direction) {
+		ocp_for_each_dev(dev) {
+			ide_scan_ocpdev(dev);
+		}
+	} else {
+		ocp_for_each_dev_reverse(dev) {
+			ide_scan_ocpdev(dev);
+		}
+	}
+}
+
+static int __init
+ocp_ide_init(void)
+{
+	printk("OCP ide ver:%s\n", IDE_VER);
+	return ocp_module_init(&ocp_ide_driver);
+}
+
+void __exit
+ocp_ide_fini(void)
+{
+	ocp_unregister_driver(&ocp_ide_driver);
+}
+
+module_init(ocp_ide_init);
+module_exit(ocp_ide_fini);
+
+
diff -p -purN linux-2.5/drivers/macintosh/Makefile linuxppc-2.5/drivers/macintosh/Makefile
--- linux-2.5/drivers/macintosh/Makefile	2003-08-09 18:39:19.000000000 +0200
+++ linuxppc-2.5/drivers/macintosh/Makefile	2003-08-11 00:33:15.000000000 +0200
@@ -4,6 +4,7 @@
 
 # Each configuration option enables a list of files.
 
+# Turn that into a separate config option
 obj-$(CONFIG_PPC_PMAC)		+= macio_asic.o
 
 obj-$(CONFIG_PMAC_PBOOK)	+= mediabay.o
diff -p -purN linux-2.5/drivers/media/video/planb.c linuxppc-2.5/drivers/media/video/planb.c
--- linux-2.5/drivers/media/video/planb.c	2003-09-30 02:22:14.000000000 +0200
+++ linuxppc-2.5/drivers/media/video/planb.c	2003-10-06 03:25:17.000000000 +0200
@@ -422,6 +422,16 @@ static void planb_prepare_close(struct p
 /* overlay support functions */
 /*****************************/
 
+static inline int overlay_is_active(struct planb *pb)
+{
+	unsigned int size = pb->tab_size * sizeof(struct dbdma_cmd);
+	unsigned int caddr = (unsigned)in_le32(&pb->planb_base->ch1.cmdptr);
+
+	return (in_le32(&pb->overlay_last1->cmd_dep) == pb->ch1_cmd_phys)
+			&& (caddr < (pb->ch1_cmd_phys + size))
+			&& (caddr >= (unsigned)pb->ch1_cmd_phys);
+}
+
 static void overlay_start(struct planb *pb)
 {
 
@@ -853,16 +863,6 @@ static int palette2fmt[] = {
 
 #define PLANB_PALETTE_MAX 15
 
-static inline int overlay_is_active(struct planb *pb)
-{
-	unsigned int size = pb->tab_size * sizeof(struct dbdma_cmd);
-	unsigned int caddr = (unsigned)in_le32(&pb->planb_base->ch1.cmdptr);
-
-	return (in_le32(&pb->overlay_last1->cmd_dep) == pb->ch1_cmd_phys)
-			&& (caddr < (pb->ch1_cmd_phys + size))
-			&& (caddr >= (unsigned)pb->ch1_cmd_phys);
-}
-
 static int vgrab(struct planb *pb, struct video_mmap *mp)
 {
 	unsigned int fr = mp->frame;
diff -p -purN linux-2.5/drivers/misc/ChanageLog.misc linuxppc-2.5/drivers/misc/ChanageLog.misc
--- linux-2.5/drivers/misc/ChanageLog.misc	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/misc/ChanageLog.misc	2002-09-05 23:46:12.000000000 +0200
@@ -0,0 +1,5 @@
+Thu,  5 Sep 12:22:47 2002  Armin Kuster <akuster@mvista.com>
+	
+	* fixed compiler error in line 308.  missed indirection in parm 
+ 
+
diff -p -purN linux-2.5/drivers/misc/Makefile linuxppc-2.5/drivers/misc/Makefile
--- linux-2.5/drivers/misc/Makefile	2002-12-14 13:38:56.000000000 +0100
+++ linuxppc-2.5/drivers/misc/Makefile	2003-05-14 11:01:16.000000000 +0200
@@ -1,4 +1,7 @@
 #
 # Makefile for misc devices that really don't fit anywhere else.
 #
+
+obj-$(CONFIG_IBM_OCP_GPIO) += ibm_ocp_gpio.o
+
 obj- := misc.o	# Dummy rule to force built-in.o to be made
diff -p -purN linux-2.5/drivers/misc/ibm_ocp_gpio.c linuxppc-2.5/drivers/misc/ibm_ocp_gpio.c
--- linux-2.5/drivers/misc/ibm_ocp_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/misc/ibm_ocp_gpio.c	2003-06-06 22:09:22.000000000 +0200
@@ -0,0 +1,296 @@
+/*
+ * FILE NAME ibm_ocp_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  API for IBM PowerPC 4xx GPIO device.
+ *  Driver for IBM PowerPC 4xx GPIO device.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *          Debbie Chu   <debbie_chu@mvista.com>
+ *
+ * Copyright 2000,2001,2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define VUFX "09.06.02"
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/pm.h>
+#include <asm/ibm_ocp_gpio.h>
+#include <asm/ocp.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+
+
+typedef struct gpio_regs {
+	u32 or;
+	u32 tcr;
+	u32 pad[4];
+	u32 odr;
+	u32 ir;
+} gpio_t;
+
+static struct gpio_regs *gpiop;
+
+int
+ocp_gpio_config(__u32 device, __u32 mask, __u32 data)
+{
+	u32 cfg_reg;
+
+	if (device != 0)
+		return -ENXIO;
+
+#ifdef CONFIG_40x
+	/*
+	 * PPC405 uses CPC0_CR0 to select multiplexed GPIO pins.
+	 */
+	cfg_reg = mfdcr(DCRN_CHCR0);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	mtdcr(DCRN_CHCR0, cfg_reg);
+#elif CONFIG_44x
+	/*
+	 * PPC440 uses CPC0_GPIO to select multiplexed GPIO pins.
+	 */
+	cfg_reg = mfdcr(DCRN_CPC0_GPIO);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	mtdcr(DCRN_CPC0_GPIO, cfg_reg);
+#else
+#error This driver is only supported on PPC40x and PPC440 CPUs
+#endif
+
+	return 0;
+}
+
+int
+ocp_gpio_tristate(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+	gpiop->tcr = (gpiop->tcr & ~mask) | (data & mask);
+	return 0;
+}
+
+int
+ocp_gpio_open_drain(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+	gpiop->odr = (gpiop->odr & ~mask) | (data & mask);
+
+	return 0;
+}
+
+int
+ocp_gpio_in(__u32 device, __u32 mask, volatile __u32 * data)
+{
+	if (device != 0)
+		return -ENXIO;
+	gpiop->tcr = gpiop->tcr & ~mask;
+	eieio();
+
+	/*
+	   ** If the previous state was OUT, and gpiop->ir is read once, then the
+	   ** data that was being OUTput will be read.  One way to get the right
+	   ** data is to read gpiop->ir twice.
+	 */
+
+	*data = gpiop->ir;
+	*data = gpiop->ir & mask;
+	eieio();
+	return 0;
+}
+
+int
+ocp_gpio_out(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+	gpiop->or = (gpiop->or & ~mask) | (data & mask);
+	eieio();
+	gpiop->tcr = gpiop->tcr | mask;
+	eieio();
+	return 0;
+}
+
+static int
+ocp_gpio_ioctl(struct inode *inode, struct file *file,
+	       unsigned int cmd, unsigned long arg)
+{
+	static struct ocp_gpio_ioctl_data ioctl_data;
+	int status;
+
+	switch (cmd) {
+	case IBMGPIO_IN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		status = ocp_gpio_in(ioctl_data.device,
+				     ioctl_data.mask, &ioctl_data.data);
+		if (status != 0)
+			return status;
+
+		if (copy_to_user((struct ocp_gpio_ioctl_data *) arg,
+				 &ioctl_data, sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		break;
+
+	case IBMGPIO_OUT:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ocp_gpio_out(ioctl_data.device,
+				    ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_OPEN_DRAIN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ocp_gpio_open_drain(ioctl_data.device,
+					   ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_TRISTATE:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ocp_gpio_tristate(ioctl_data.device,
+					 ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_CFG:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ocp_gpio_config(ioctl_data.device,
+				ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+
+	}
+	return 0;
+}
+
+static struct file_operations ocp_gpio_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= ocp_gpio_ioctl,
+};
+
+struct miscdevice ocp_gpio_miscdev = {
+	.minor		= 185,	/*GPIO_MINOR; */
+	.name		= "IBM4xx ocp gpio",
+	.fops		= &ocp_gpio_fops,
+};
+
+static int __devinit ocp_gpio_probe(struct ocp_device *pdev)
+{
+	printk("IBM gpio driver version %s\n", VUFX);
+
+	misc_register(&ocp_gpio_miscdev);	/*ocp_gpio_miscdev); */
+
+	pdev->vaddr = ioremap(pdev->paddr, sizeof (struct gpio_regs));
+	gpiop = (struct gpio_regs *)pdev->vaddr;
+	printk("GPIO #%d at 0x%lx\n", pdev->num, (unsigned long) gpiop);
+
+	ocp_force_power_on(pdev);
+	return 1;
+}
+
+static void __devexit ocp_gpio_remove_one (struct ocp_device *pdev)
+{
+	ocp_force_power_off(pdev);
+	misc_deregister(&ocp_gpio_miscdev);
+}
+
+static struct ocp_device_id ocp_gpio_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_GPIO},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_gpio_id_tbl );
+
+static struct ocp_driver ocp_gpio_driver = {
+	.name		= "ocp_gpio",
+	.id_table	= ocp_gpio_id_tbl,
+	.probe		= ocp_gpio_probe,
+	.remove		= __devexit_p(ocp_gpio_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_generic_suspend,
+	.resume		= ocp_generic_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init
+ocp_gpio_init(void)
+{
+	printk("IBM gpio driver version %s\n", VUFX);
+	return ocp_module_init(&ocp_gpio_driver);
+}
+
+void __exit
+ocp_gpio_fini(void)
+{
+	ocp_unregister_driver(&ocp_gpio_driver);
+}
+
+module_init(ocp_gpio_init);
+module_exit(ocp_gpio_fini);
+
+EXPORT_SYMBOL(ocp_gpio_tristate);
+EXPORT_SYMBOL(ocp_gpio_open_drain);
+EXPORT_SYMBOL(ocp_gpio_in);
+EXPORT_SYMBOL(ocp_gpio_out);
+
diff -p -purN linux-2.5/drivers/mtd/maps/Kconfig linuxppc-2.5/drivers/mtd/maps/Kconfig
--- linux-2.5/drivers/mtd/maps/Kconfig	2003-08-18 20:25:06.000000000 +0200
+++ linuxppc-2.5/drivers/mtd/maps/Kconfig	2003-08-20 01:30:59.000000000 +0200
@@ -296,12 +296,20 @@ config MTD_ARCTIC
 
 config MTD_EBONY
 	tristate "CFI Flash device mapped on IBM 440GP Ebony"
-	depends on MTD_CFI && PPC32 && 440 && EBONY
+	depends on MTD_CFI && PPC32 && 44x && EBONY
 	help
 	  This enables access routines for the flash chips on the IBM 440GP
 	  Ebony board. If you have one of these boards and would like to
 	  use the flash chips on it, say 'Y'.
 
+config MTD_OCOTEA
+	tristate "CFI Flash device mapped on IBM 440GX Ocotea"
+	depends on MTD_CFI && PPC32 && 44x && OCOTEA
+	help
+	  This enables access routines for the flash chips on the IBM 440GX
+	  Ocotea board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
 config MTD_REDWOOD
 	tristate "CFI Flash devices mapped on IBM Redwood"
 	depends on MTD_CFI && PPC32 && 4xx && 40x && ( REDWOOD_4 || REDWOOD_5 || REDWOOD_6 )
diff -p -purN linux-2.5/drivers/mtd/maps/Makefile linuxppc-2.5/drivers/mtd/maps/Makefile
--- linux-2.5/drivers/mtd/maps/Makefile	2003-05-28 17:01:02.000000000 +0200
+++ linuxppc-2.5/drivers/mtd/maps/Makefile	2003-08-02 02:04:32.000000000 +0200
@@ -52,6 +52,7 @@ obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
 obj-$(CONFIG_MTD_EBONY)		+= ebony.o
+obj-$(CONFIG_MTD_OCOTEA)	+= ocotea.o
 obj-$(CONFIG_MTD_BEECH)		+= beech-mtd.o
 obj-$(CONFIG_MTD_ARCTIC)	+= arctic-mtd.o
 obj-$(CONFIG_MTD_H720X)		+= h720x-flash.o
diff -p -purN linux-2.5/drivers/mtd/maps/ebony.c linuxppc-2.5/drivers/mtd/maps/ebony.c
--- linux-2.5/drivers/mtd/maps/ebony.c	2003-06-23 14:34:05.000000000 +0200
+++ linuxppc-2.5/drivers/mtd/maps/ebony.c	2003-06-27 01:07:07.000000000 +0200
@@ -1,11 +1,11 @@
 /*
  * $Id: ebony.c,v 1.8 2003/06/23 11:48:18 dwmw2 Exp $
- * 
+ *
  * Mapping for Ebony user flash
  *
  * Matt Porter <mporter@mvista.com>
  *
- * Copyright 2002 MontaVista Software Inc.
+ * Copyright 2002-2003 MontaVista Software Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -22,8 +22,8 @@
 #include <linux/mtd/partitions.h>
 #include <linux/config.h>
 #include <asm/io.h>
-#include <asm/ibm440.h>
-#include <platforms/ebony.h>
+#include <asm/ibm44x.h>
+#include <platforms/4xx/ebony.h>
 
 static struct mtd_info *flash;
 
@@ -71,7 +71,7 @@ int __init init_ebony(void)
 		return -ENOMEM;
 
 	fpga0_reg = readb(fpga0_adr);
-	iounmap64(fpga0_adr);
+	iounmap(fpga0_adr);
 
 	if (EBONY_BOOT_SMALL_FLASH(fpga0_reg) &&
 			!EBONY_FLASH_SEL(fpga0_reg))
diff -p -purN linux-2.5/drivers/mtd/maps/ocotea.c linuxppc-2.5/drivers/mtd/maps/ocotea.c
--- linux-2.5/drivers/mtd/maps/ocotea.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/mtd/maps/ocotea.c	2003-08-02 02:04:00.000000000 +0200
@@ -0,0 +1,155 @@
+/*
+ * Mapping for Ocotea user flash
+ *
+ * Matt Porter <mporter@mvista.com>
+ *
+ * Copyright 2002-2003 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/ibm44x.h>
+#include <platforms/4xx/ocotea.h>
+
+static struct mtd_info *flash;
+
+static struct map_info ocotea_small_map = {
+	.name =		"Ocotea small flash",
+	.size =		OCOTEA_SMALL_FLASH_SIZE,
+	.buswidth =	1,
+};
+
+static struct map_info ocotea_large_map = {
+	.name =		"Ocotea large flash",
+	.size =		OCOTEA_LARGE_FLASH_SIZE,
+	.buswidth =	1,
+};
+
+static struct mtd_partition ocotea_small_partitions[] = {
+	{
+		.name =   "pibs",
+		.offset = 0x0,
+		.size =   0x100000,
+	}
+};
+
+static struct mtd_partition ocotea_large_partitions[] = {
+	{
+		.name =   "fs",
+		.offset = 0,
+		.size =   0x300000,
+	},
+	{
+		.name =   "firmware",
+		.offset = 0x300000,
+		.size =   0x100000,
+	}
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+int __init init_ocotea(void)
+{
+	u8 fpga0_reg;
+	void * fpga0_adr;
+	unsigned long long small_flash_base, large_flash_base;
+
+	fpga0_adr = ioremap64(OCOTEA_FPGA_ADDR, 16);
+	if (!fpga0_adr)
+		return -ENOMEM;
+
+	fpga0_reg = readb((unsigned long)fpga0_adr);
+	iounmap(fpga0_adr);
+
+	if (OCOTEA_BOOT_LARGE_FLASH(fpga0_reg)) {
+		small_flash_base = OCOTEA_SMALL_FLASH_HIGH;
+		large_flash_base = OCOTEA_LARGE_FLASH_LOW;
+	}
+	else {
+		small_flash_base = OCOTEA_SMALL_FLASH_LOW;
+		large_flash_base = OCOTEA_LARGE_FLASH_HIGH;
+	}
+
+	ocotea_small_map.phys = small_flash_base;
+	ocotea_small_map.virt =
+		(unsigned long)ioremap64(small_flash_base,
+					 ocotea_small_map.size);
+
+	if (!ocotea_small_map.virt) {
+		printk("Failed to ioremap flash\n");
+		return -EIO;
+	}
+
+	simple_map_init(&ocotea_small_map);
+
+	flash = do_map_probe("map_rom", &ocotea_small_map);
+	if (flash) {
+		flash->owner = THIS_MODULE;
+		add_mtd_partitions(flash, ocotea_small_partitions,
+					NB_OF(ocotea_small_partitions));
+	} else {
+		printk("map probe failed for flash\n");
+		return -ENXIO;
+	}
+
+	ocotea_large_map.phys = large_flash_base;
+	ocotea_large_map.virt =
+		(unsigned long)ioremap64(large_flash_base,
+					 ocotea_large_map.size);
+
+	if (!ocotea_large_map.virt) {
+		printk("Failed to ioremap flash\n");
+		return -EIO;
+	}
+
+	simple_map_init(&ocotea_large_map);
+
+	flash = do_map_probe("cfi_probe", &ocotea_large_map);
+	if (flash) {
+		flash->owner = THIS_MODULE;
+		add_mtd_partitions(flash, ocotea_large_partitions,
+					NB_OF(ocotea_large_partitions));
+	} else {
+		printk("map probe failed for flash\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_ocotea(void)
+{
+	if (flash) {
+		del_mtd_partitions(flash);
+		map_destroy(flash);
+	}
+
+	if (ocotea_small_map.virt) {
+		iounmap((void *)ocotea_small_map.virt);
+		ocotea_small_map.virt = 0;
+	}
+
+	if (ocotea_large_map.virt) {
+		iounmap((void *)ocotea_large_map.virt);
+		ocotea_large_map.virt = 0;
+	}
+}
+
+module_init(init_ocotea);
+module_exit(cleanup_ocotea);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Matt Porter <mporter@mvista.com>");
+MODULE_DESCRIPTION("MTD map and partitions for IBM 440GX Ocotea boards");
diff -p -purN linux-2.5/drivers/net/Kconfig linuxppc-2.5/drivers/net/Kconfig
--- linux-2.5/drivers/net/Kconfig	2003-12-02 17:20:59.000000000 +0100
+++ linuxppc-2.5/drivers/net/Kconfig	2003-10-15 21:41:16.000000000 +0200
@@ -198,6 +198,8 @@ config MII
 
 source "drivers/net/arm/Kconfig"
 
+source "drivers/net/ibm_ocp/Kconfig"
+
 config MACE
 	tristate "MACE (Power Mac ethernet) support"
 	depends on NET_ETHERNET && PPC_PMAC
@@ -242,6 +244,17 @@ config OAKNET
 	  To compile this driver as a module, choose M here: the module
 	  will be called oaknet.
 
+config ARCTIC_ENET
+	tristate "Arctic-III development sled ethernet support"
+	depends on NET_ETHERNET && ARCTIC2
+	help
+	  
+	  If you have an IBM Arctic III with an RTL8019AS ethernet
+	  chip on the development sled, say Y.  Otherwise, say N.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called arctic_enet.
+
 config ARIADNE
 	tristate "Ariadne support"
 	depends on NET_ETHERNET && ZORRO
diff -p -purN linux-2.5/drivers/net/Makefile linuxppc-2.5/drivers/net/Makefile
--- linux-2.5/drivers/net/Makefile	2003-09-27 12:23:28.000000000 +0200
+++ linuxppc-2.5/drivers/net/Makefile	2003-10-06 03:25:17.000000000 +0200
@@ -95,6 +95,7 @@ obj-$(CONFIG_LNE390) += lne390.o 8390.o
 obj-$(CONFIG_NE3210) += ne3210.o 8390.o
 obj-$(CONFIG_NET_SB1250_MAC) += sb1250-mac.o
 obj-$(CONFIG_B44) += b44.o
+obj-$(CONFIG_ARCTIC_ENET) += arctic_enet.o 8390.o
 
 obj-$(CONFIG_PPP) += ppp_generic.o slhc.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
@@ -187,4 +188,4 @@ obj-$(CONFIG_NET_WIRELESS) += wireless/
 obj-$(CONFIG_NET_TULIP) += tulip/
 obj-$(CONFIG_HAMRADIO) += hamradio/
 obj-$(CONFIG_IRDA) += irda/
-
+obj-$(CONFIG_OCP_NET)	+= ibm_ocp/
diff -p -purN linux-2.5/drivers/net/arctic_enet.c linuxppc-2.5/drivers/net/arctic_enet.c
--- linux-2.5/drivers/net/arctic_enet.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/arctic_enet.c	2003-06-13 00:26:06.000000000 +0200
@@ -0,0 +1,652 @@
+/*
+ *  IPE405 (IBM IAP 405 chip evaluation board) Debug Support Board
+ *    Ehernet Driver
+ *  (C) Copyright 2001 by S.nishino (jl04348@jp.ibm.com)  IBM-Japan
+ *
+ * ---------- Strategy ----------
+ *
+ *  This NIC is RTL8019AS, simply connected to External Bus Controller
+ *  of IAP 405 chip. As many folks of 8390 based NIC, 8390 core driver
+ *  is usable.  luckily, the following driver is already available for
+ *  Amiga zorro bus (however I don't know this architecture beyond
+ *  below), this is modified based on this driver (ariadne2).
+ *
+ * ---------- original header ----------
+ *  Amiga Linux/m68k Ariadne II Ethernet Driver
+ *
+ *  (C) Copyright 1998 by some Elitist 680x0 Users(TM)
+ *
+ *  ---------------------------------------------------------------------------
+ *
+ *  This program is based on all the other NE2000 drivers for Linux
+ *
+ *  ---------------------------------------------------------------------------
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of the Linux
+ *  distribution for more details.  */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/irq.h>
+
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/ppc4xx_pic.h>
+#if defined(CONFIG_ARCTIC2)
+#include <platforms/4xx/arctic2.h>
+#else
+#error The driver only works on Arctic
+#endif
+
+#include "8390.h"
+
+
+#define ARCTIC_ENET_BASE8	(ARCTIC2_FPGA8_PADDR + 256*1024)
+#define ARCTIC_ENET_BASE16	(ARCTIC2_FPGA16_PADDR + 0)
+
+#define ARCTIC_ENET_IOBASE	0x0300	/* io base offset from NIC region */
+
+#define ARCTIC_ENET_IRQ		29	/* irq number in UIC */
+#define ARCTIC_ENET_IRQ_MASK	(0x80000000 >> ARCTIC_ENET_IRQ)
+
+#define NE_BASE         (ARCTIC_ENET_BASE8 + ARCTIC_ENET_IOBASE)
+#define NE_BASE16       (ARCTIC_ENET_BASE16 + ARCTIC_ENET_IOBASE)
+
+/* 8390 register address */
+#define NE_CMD          (0x00)
+#define NE_DATAPORT     (0x10)	/* NatSemi-defined port window offset. */
+#define NE_DATAPORT16	(NE_DATAPORT / sizeof(u16))
+#define NE_RESET        (0x1f)	/* Issue a read to reset, a write to clear. */
+#define NE_IO_EXTENT    (0x20)	/* region extent */
+
+#define NE_EN0_ISR      (0x07)
+#define NE_EN0_DCFG     (0x0e)
+
+#define NE_EN0_RSARLO   (0x08)
+#define NE_EN0_RSARHI   (0x09)
+#define NE_EN0_RCNTLO   (0x0a)
+#define NE_EN0_RXCR     (0x0c)
+#define NE_EN0_TXCR     (0x0d)
+#define NE_EN0_RCNTHI   (0x0b)
+#define NE_EN0_IMR      (0x0f)
+
+/* 8390 packet buffer page number */
+#define NESM_START_PG   0x40	/* First page of TX buffer */
+#define NESM_STOP_PG    0x80	/* Last page +1 of RX ring */
+
+static u8 *iobase8;
+static u16 *iobase16;
+
+static int arctic_enet_probe(struct net_device *dev);
+static int arctic_enet_init(struct net_device *dev);
+
+static int arctic_enet_open(struct net_device *dev);
+static int arctic_enet_close(struct net_device *dev);
+
+static void arctic_enet_reset_8390(struct net_device *dev);
+static void arctic_enet_get_8390_hdr(struct net_device *dev,
+				    struct e8390_pkt_hdr *hdr,
+				    int ring_page);
+static void arctic_enet_block_input(struct net_device *dev, int count,
+				   struct sk_buff *skb, int ring_offset);
+static void arctic_enet_block_output(struct net_device *dev,
+				    const int count,
+				    const unsigned char *buf,
+				    const int start_page);
+
+/* These macros will do something on Arctic-I if we ever add support
+ * for it back in */
+#define switch_16bit_bank()	do { } while (0)
+#define switch_8bit_bank()	do { } while (0)
+
+void p_dump(unsigned char *p, int sz)
+{
+	int i;
+	unsigned char *wp;
+	
+	wp = p;
+	
+	printk("------ PACKET START :  %d Bytes  ------ \n", sz);
+	
+	for (i = 0; i < sz; i++) {
+		if (i % 16 == 0) {
+			printk("\n %04X: %02X ", i, *wp);
+		} else if (i % 16 == 15) {
+			printk("%02X", *wp);
+		} else {
+			printk("%02X ", *wp);
+		}
+		wp++;
+	}
+
+	printk("------ PACKET END   ------ \n");
+}
+
+/* Code for reading the MAC address from the Arctic ethernet based on
+ * similar code in PIBS */
+
+static void __init writereg_9346(volatile u8 *iobase, u8 value)
+{
+	/* Switch to register page 3 */
+	writeb(readb(iobase + NE_CMD) | 0xc0, iobase + NE_CMD);
+	writeb(value, iobase + 0x01);
+}
+
+static u8 __init readreg_9346(volatile u8 *iobase)
+{
+	/* Switch to register page 3 */
+	writeb(readb(iobase + NE_CMD) | 0xc0, iobase + NE_CMD);
+	return readb(iobase + 0x01);
+}
+
+static void __init write_bit_9346(volatile u8 *iobase, u8 bit)
+{
+	u8 mask = ~0x06;
+	
+	writereg_9346(iobase, (readreg_9346(iobase) & mask) | bit);
+	udelay(1000);
+	writereg_9346(iobase, (readreg_9346(iobase) & mask) | bit | 0x04);
+	udelay(1000);
+}
+
+static u8 __init read_bit_9346(volatile u8 *iobase)
+{
+	u8 bit;
+	u8 mask = ~0x05;
+	
+	mask = ~0x05;
+	writereg_9346(iobase, readreg_9346(iobase) & mask);
+	udelay(1000);
+	writereg_9346(iobase, (readreg_9346(iobase) & mask) | 0x04);
+	bit = readreg_9346(iobase) & 0x01;
+	udelay(1000);
+
+	return bit;
+}
+
+static u16 __init arctic_read_9346(volatile u8 *iobase, unsigned long addr)
+{
+	unsigned long flags;
+	int i;
+	u16 data;
+
+	local_irq_save(flags);
+
+	/* Put the chip into 8390 programming mode */
+	writereg_9346(iobase, (readreg_9346(iobase) & ~0xc0) | 0x80);
+	udelay(1000);
+
+	/* Send command (read 16-bit value) to EEPROM */
+	/* Bring CS Low */
+	writereg_9346(iobase, readreg_9346(iobase) & ~0x0f);
+	udelay(1000);
+	/* Bring CS High */
+	writereg_9346(iobase, (readreg_9346(iobase) & ~0x0f) | 0x08);
+	udelay(1000);
+
+	/* Send a 1 */
+	write_bit_9346(iobase, 0x02);
+	/* Send opcode 0b10 */
+	write_bit_9346(iobase, 0x02);
+	write_bit_9346(iobase, 0x00);
+	/* Send address to read */
+	for (i = 0; i < 6; i++) {
+		if (addr & 0x20)
+			write_bit_9346(iobase, 0x02);
+		else
+			write_bit_9346(iobase, 0x00);
+		addr <<= 1;
+	}
+
+	/* Read the value back, bit by bit */
+	data = 0;
+	for (i = 0; i < 16; i++) {
+		data <<= 1;
+		if (read_bit_9346(iobase))
+			data |= 0x1;
+	}
+
+	/* Bring CS Low */
+	writereg_9346(iobase, readreg_9346(iobase) & ~0x0f);
+	udelay(1000);
+	/* Bring the chip out of 8390 programming mode */
+	writereg_9346(iobase, readreg_9346(iobase) & ~0xc0);
+	udelay(1000);
+
+	/* Return to register page 0 */
+	writeb(readb(iobase + NE_CMD) & ~0xc0, iobase + NE_CMD);
+	udelay(1000);
+
+	local_irq_restore(flags);
+	
+	return data;
+}
+
+static void __init arctic_get_macaddr(struct net_device *dev)
+{
+	u16 t0, t1, t2, v0, v1;
+
+	t0 = arctic_read_9346(iobase8, 0);
+	t1 = arctic_read_9346(iobase8, 2);
+	t2 = arctic_read_9346(iobase8, 4);
+	v0 = arctic_read_9346(iobase8, 6);
+	v1 = arctic_read_9346(iobase8, 8);
+
+	if ( (v0 != 0x4d50) || (v1 != 0x5400) ) {
+		printk(KERN_WARNING "%s: MAC address is not set in EEPROM\n", dev->name);
+		return;
+	}
+
+	dev->dev_addr[0] = t0 >> 8;
+	dev->dev_addr[1] = t0 & 0xff;
+	dev->dev_addr[2] = t1 >> 8;
+	dev->dev_addr[3] = t1 & 0xff;
+	dev->dev_addr[4] = t2 >> 8;
+	dev->dev_addr[5] = t2 & 0xff;
+}
+
+int __init arctic_enet_probe(struct net_device *dev)
+{
+	unsigned long reset_start_time;
+
+	switch_8bit_bank();
+	/* Reset card. Who knows what dain-bramaged state it was left in. */
+	reset_start_time = jiffies;
+	
+	writeb(readb(iobase8 + NE_RESET), iobase8 + NE_RESET);
+
+	while ((readb(iobase8 + NE_EN0_ISR) & ENISR_RESET) == 0)
+		if (jiffies - reset_start_time > 2 * HZ / 100) {
+			printk("arctic_enet: not found (no reset ack).\n");
+			return -ENODEV;
+		}
+	
+	writeb(0xff, iobase8 + NE_EN0_ISR);	/* Ack all intr. */
+
+	arctic_get_macaddr(dev);
+
+	printk("arctic_enet: found at 0x%08x/0x%08x, MAC address "
+	       "%02x:%02x:%02x:%02x:%02x:%02x\n",
+	       NE_BASE, NE_BASE16,
+	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	/* Hack to let 8390.c work properly - it assumes IO space
+	 * addresses */
+	dev->base_addr = (unsigned long)iobase8 - _IO_BASE;
+	dev->irq = ARCTIC_ENET_IRQ;
+
+	return 0;
+}
+
+static int __init arctic_enet_init(struct net_device *dev)
+{
+	static u32 arctic_enet_offsets[16] = {
+		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	};
+
+	/* Since this irq is connected to uic as edge interrupt, its pending must be cleared. */
+	/* FIXME: it would be nice to get rid of the direct reference
+	 * to the 4xx irq structure */
+	ppc4xx_pic->ack(dev->irq);
+
+	/* Install the Interrupt handler */
+	if (request_irq(dev->irq, ei_interrupt, SA_SHIRQ, dev->name, dev))
+		return -EAGAIN;
+
+	/* Allocate dev->priv and fill in 8390 specific dev fields. */
+	if (ethdev_init(dev)) {
+		printk(" Unable to get memory for dev->priv.\n");
+		return -ENOMEM;
+	}
+	
+	/*
+	 * Fill 8390 specific member for 8390 core driver
+	 */
+	ei_status.name = "RTL8019AS";
+	ei_status.tx_start_page = NESM_START_PG;
+	ei_status.stop_page = NESM_STOP_PG;
+	ei_status.word16 = 1;
+	ei_status.rx_start_page = NESM_START_PG + TX_PAGES;
+	
+	ei_status.reset_8390 = &arctic_enet_reset_8390;
+	ei_status.block_input = &arctic_enet_block_input;
+	ei_status.block_output = &arctic_enet_block_output;
+	ei_status.get_8390_hdr = &arctic_enet_get_8390_hdr;
+	ei_status.reg_offset = arctic_enet_offsets;
+
+	NS8390_init(dev, 0);
+	return 0;
+}
+
+static int arctic_enet_open(struct net_device *dev)
+{
+	int err;
+	err = ei_open(dev);
+	if (err)
+		return err;
+
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static int arctic_enet_close(struct net_device *dev)
+{
+	int err;
+
+	err = ei_close(dev);
+	if (err)
+		return err;
+
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/* Hard reset the card.  This used to pause for the same period that a
+   8390 reset command required, but that shouldn't be necessary. */
+static void arctic_enet_reset_8390(struct net_device *dev)
+{
+	unsigned long reset_start_time = jiffies;
+
+	if (ei_debug > 1)
+		printk("resetting the 8390 t=%ld...", jiffies);
+
+	writeb(readb(iobase8 + NE_RESET), iobase8 + NE_RESET);
+
+	ei_status.txing = 0;
+	ei_status.dmaing = 0;
+
+	/* This check _should_not_ be necessary, omit eventually. */
+	while ((readb(iobase8 + NE_EN0_ISR) & ENISR_RESET) == 0)
+		if (jiffies - reset_start_time > 2 * HZ / 100) {
+			printk("%s: ne_reset_8390() did not complete.\n",
+			       dev->name);
+			break;
+		}
+	writeb(ENISR_RESET, iobase8 + NE_EN0_ISR);	/* Ack intr. */
+}
+
+/* Grab the 8390 specific header. Similar to the block_input routine, but
+   we don't need to be concerned with ring wrap as the header will be at
+   the start of a page, so we optimize accordingly. */
+
+static void arctic_enet_get_8390_hdr(struct net_device *dev,
+				    struct e8390_pkt_hdr *hdr,
+				    int ring_page)
+{
+	int cnt;
+	u16 *ptrs;
+	unsigned char *ptrc;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing) {
+		printk("%s: DMAing conflict in ne_get_8390_hdr "
+		       "[DMAstat:%d][irqlock:%d].\n", dev->name,
+		       ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+
+	ei_status.dmaing |= 0x01;
+	writeb(E8390_NODMA + E8390_PAGE0 + E8390_START, iobase8 + NE_CMD);
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);
+	writeb(sizeof(struct e8390_pkt_hdr), iobase8 + NE_EN0_RCNTLO);
+	writeb(0, iobase8 + NE_EN0_RCNTHI);
+	writeb(0, iobase8 + NE_EN0_RSARLO);	/* On page boundary */
+	writeb(ring_page, iobase8 + NE_EN0_RSARHI);
+	writeb(E8390_RREAD + E8390_START, iobase8 + NE_CMD);
+
+	if (ei_status.word16) {
+		switch_16bit_bank();
+		ptrs = (u16 *) hdr;
+		for (cnt = 0; cnt < (sizeof(struct e8390_pkt_hdr) >> 1);
+		     cnt++)
+			*ptrs++ = in_be16((u16 *) (iobase16 + NE_DATAPORT16));
+		switch_8bit_bank();
+	} else {
+
+		ptrc = (unsigned char *) hdr;
+		for (cnt = 0; cnt < sizeof(struct e8390_pkt_hdr); cnt++)
+			*ptrc++ = readb(iobase8 + NE_DATAPORT);
+	}
+
+
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);	/* Ack intr. */
+
+	/* I am Big Endian, but received byte count is Little Endian. */
+	hdr->count = le16_to_cpu(hdr->count);
+
+	ei_status.dmaing &= ~0x01;
+}
+
+/* Block input and output, similar to the Crynwr packet driver.  If you
+   are porting to a new ethercard, look at the packet driver source for hints.
+   The NEx000 doesn't share the on-board packet memory -- you have to put
+   the packet out through the "remote DMA" dataport using writeb. */
+
+static void arctic_enet_block_input(struct net_device *dev, int count,
+				   struct sk_buff *skb, int ring_offset)
+{
+	char *buf = skb->data;
+	u16 *ptrs;
+	unsigned char *ptrc;
+
+	int cnt;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing) {
+		printk("%s: DMAing conflict in ne_block_input "
+		       "[DMAstat:%d][irqlock:%d].\n",
+		       dev->name, ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+	ei_status.dmaing |= 0x01;
+	writeb(E8390_NODMA + E8390_PAGE0 + E8390_START, iobase8 + NE_CMD);
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);
+	writeb(count & 0xff, iobase8 + NE_EN0_RCNTLO);
+	writeb(count >> 8, iobase8 + NE_EN0_RCNTHI);
+	writeb(ring_offset & 0xff, iobase8 + NE_EN0_RSARLO);
+	writeb(ring_offset >> 8, iobase8 + NE_EN0_RSARHI);
+	writeb(E8390_RREAD + E8390_START, iobase8 + NE_CMD);
+
+
+	if (ei_status.word16) {
+
+		switch_16bit_bank();
+
+		ptrs = (u16 *) buf;
+		for (cnt = 0; cnt < (count >> 1); cnt++)
+			/* At 16 bits mode, bus acts as Little Endian mode
+			   That's swap is needed ??? */
+			*ptrs++ = in_be16((u16 *) (iobase16 + NE_DATAPORT16));
+		switch_8bit_bank();
+
+		if (count & 0x01)
+			buf[count - 1] = readb(iobase8 + NE_DATAPORT);
+
+	} else {
+
+
+		ptrc = (unsigned char *) buf;
+		for (cnt = 0; cnt < count; cnt++)
+			*ptrc++ = readb(iobase8 + NE_DATAPORT);
+	}
+
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+}
+
+static void arctic_enet_block_output(struct net_device *dev, int count,
+				    const unsigned char *buf,
+				    const int start_page)
+{
+	unsigned long dma_start;
+	u16 *ptrs;
+	unsigned char *ptrc;
+	int cnt;
+
+	/* Round the count up for word writes.  Do we need to do this?
+	   What effect will an odd byte count have on the 8390?
+	   I should check someday. */
+	if (count & 0x01)
+		count++;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing) {
+		printk("%s: DMAing conflict in ne_block_output."
+		       "[DMAstat:%d][irqlock:%d]\n", dev->name,
+		       ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+	ei_status.dmaing |= 0x01;
+
+#if 1 /* FIXME: not sure what this is for -dwg */
+	writeb(0x42, iobase8 + EN0_RCNTLO);
+	writeb(0x00, iobase8 + EN0_RCNTHI);
+	writeb(0x42, iobase8 + EN0_RSARLO);
+	writeb(0x00, iobase8 + EN0_RSARHI);
+#endif
+	/* We should already be in page 0, but to be safe... */
+	writeb(E8390_PAGE0 + E8390_START + E8390_NODMA, iobase8 + NE_CMD);
+
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);
+
+	/* Now the normal output. */
+	writeb(count & 0xff, iobase8 + NE_EN0_RCNTLO);
+	writeb(count >> 8, iobase8 + NE_EN0_RCNTHI);
+	writeb(0x00, iobase8 + NE_EN0_RSARLO);
+	writeb(start_page, iobase8 + NE_EN0_RSARHI);
+
+	writeb(E8390_RWRITE + E8390_START, iobase8 + NE_CMD);
+
+	if (ei_status.word16) {
+		switch_16bit_bank();
+
+		ptrs = (u16 *) buf;
+		for (cnt = 0; cnt < count >> 1; cnt++) {
+			/* At 16 bits mode, bus acts as Little Endian mode
+			   That's swap is needed ??? */
+			out_be16((u16 *) (iobase16 + NE_DATAPORT16),
+				 *ptrs);
+			ptrs++;
+		}
+
+		switch_8bit_bank();
+
+	} else {
+		ptrc = (unsigned char *) buf;
+		for (cnt = 0; cnt < count; cnt++)
+			writeb(*ptrc++, iobase8 + NE_DATAPORT);
+	}
+
+	dma_start = jiffies;
+
+	while ((readb(iobase8 + NE_EN0_ISR) & ENISR_RDC) == 0)
+		if (jiffies - dma_start > 2 * HZ / 100) {	/* 20ms */
+			printk("%s: timeout waiting for Tx RDC.\n",
+			       dev->name);
+			arctic_enet_reset_8390(dev);
+			NS8390_init(dev, 1);
+			break;
+		}
+
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+	return;
+}
+
+static struct net_device arctic_enet_dev = {
+	.init	= arctic_enet_init,
+	.open	= arctic_enet_open,
+	.stop	= arctic_enet_close,
+};
+
+int init_arctic_enet(void)
+{
+	struct net_device *dev = &arctic_enet_dev;
+	int rsvd8 = 0;
+	int rsvd16 = 0;
+	int err;
+
+	/* First set up our IO regions */
+	if (! request_mem_region(NE_BASE, NE_IO_EXTENT, "arctic_enet"))
+		goto fail;
+	rsvd8 = 1;
+
+	iobase8 = ioremap(NE_BASE, NE_IO_EXTENT);
+	if (! iobase8) {
+		err = -EBUSY;
+		goto fail;
+	}
+	
+	if (NE_BASE16 != NE_BASE) {
+		if (! request_mem_region(NE_BASE16, NE_IO_EXTENT, "arctic_enet"))
+			goto fail;
+		rsvd16 = 1;
+	}
+
+	iobase16 = ioremap(NE_BASE16, NE_IO_EXTENT);
+	if (! iobase16) {
+		err = -EBUSY;
+		goto fail;
+	}	
+
+	/* Configure IRQ */
+	cli();
+	mtdcr(DCRN_UIC0_TR, mfdcr(DCRN_UIC0_TR) | ARCTIC_ENET_IRQ_MASK);
+	mtdcr(DCRN_UIC0_PR, mfdcr(DCRN_UIC0_PR) | ARCTIC_ENET_IRQ_MASK);
+	mtdcr(DCRN_UIC0_SR, ARCTIC_ENET_IRQ_MASK);
+	sti();
+
+	err = arctic_enet_probe(dev);
+	if (err) {
+		printk(KERN_ERR "arctic_enet: No Arctic ethernet card found.\n");
+		goto fail;
+	}
+
+	err = register_netdev(dev);
+	if (err)
+		goto fail;
+
+	return 0;
+
+ fail:
+	if (iobase16)
+		iounmap(iobase16);
+	if (rsvd16)
+		release_mem_region(NE_BASE16, NE_IO_EXTENT);
+	if (iobase8)
+		iounmap(iobase8);
+	if (rsvd8)
+		release_mem_region(NE_BASE, NE_IO_EXTENT);
+
+	return err;
+	
+}
+
+void remove_arctic_enet(void)
+{
+	unregister_netdev(&arctic_enet_dev);
+	free_irq(ARCTIC_ENET_IRQ, &arctic_enet_dev);
+
+	if (iobase16) {
+		iounmap(iobase16);
+		release_mem_region(NE_BASE16, NE_IO_EXTENT);
+	}
+	if (iobase8) {
+		iounmap(iobase8);
+		release_mem_region(NE_BASE, NE_IO_EXTENT);
+	}
+}
+
+module_init(init_arctic_enet);
+module_exit(remove_arctic_enet);
diff -p -purN linux-2.5/drivers/net/ibm_ocp/Kconfig linuxppc-2.5/drivers/net/ibm_ocp/Kconfig
--- linux-2.5/drivers/net/ibm_ocp/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/Kconfig	2003-06-06 22:09:22.000000000 +0200
@@ -0,0 +1,48 @@
+config IBM_OCP_ENET
+	bool "IBM on-chip ethernet"
+	depends on IBM_OCP
+
+config IBM_OCP_ENET_ERROR_MSG
+	bool "Verbose error messages"
+	depends on IBM_OCP_ENET
+	default n
+
+config IBM_OCP_ENET_RX_BUFF
+	int "Number of receive buffers"
+	depends on IBM_OCP_ENET
+	default 64
+
+config IBM_OCP_ENET_TX_BUFF
+	int "Number of transmit buffers"
+	depends on IBM_OCP_ENET
+	default 8
+
+config IBM_OCP_ENET_GAP
+	int "Frame gap"
+	depends on IBM_OCP_ENET
+	default 8
+
+config IBM_OCP_ENET_SKB_RES
+	int "Skb reserve amount"
+	depends on IBM_OCP_ENET
+	default 0
+
+config OCP_NET
+	bool
+	depends on IBM_OCP_ENET
+	default y
+
+config IBM_OCP_MAL_CNT
+	int
+	depends on IBM_OCP_ENET && ( NP405H || NP405L || 44x )
+	default 1
+
+config IBM_OCP_ZMII
+	bool
+	depends on IBM_OCP_ENET && ( NP405H || NP405L || 44x )
+	default y
+
+config CRC32
+	bool
+	depends on IBM_OCP_ENET
+	default y
diff -p -purN linux-2.5/drivers/net/ibm_ocp/Makefile linuxppc-2.5/drivers/net/ibm_ocp/Makefile
--- linux-2.5/drivers/net/ibm_ocp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/Makefile	2003-06-06 22:09:22.000000000 +0200
@@ -0,0 +1,20 @@
+#
+# Makefile for the IBM 4xx on-chip  ethernet drivers
+#
+
+# Module support doesn't work yet.
+export-objs     := 
+
+obj-$(CONFIG_IBM_OCP_ENET) += ibm_ocp.o
+
+# NB! Link order matters
+
+ibm_ocp-objs := ibm_ocp_mal.o ibm_ocp_enet.o ibm_ocp_phy.o
+
+# These chips have a ZMII
+ibm_ocp-$(CONFIG_NP405L)			+= ibm_ocp_zmii.o
+ibm_ocp-$(CONFIG_NP405H)			+= ibm_ocp_zmii.o
+ibm_ocp-$(CONFIG_44x)				+= ibm_ocp_zmii.o
+
+# Only need this if you want to see additional debug messages
+ibm_ocp-$(CONFIG_IBM_OCP_ENET_ERROR_MSG)	+= ibm_ocp_debug.o
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_debug.c linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_debug.c
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_debug.c	2002-09-20 09:23:30.000000000 +0200
@@ -0,0 +1,264 @@
+/*
+ * ibm_ocp_debug.c
+ *
+ * This has all the debug routines that where in *_enet.c
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      April , 2002
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * TODO: 
+ *
+ * Version 1.0: (04/15/02)
+ * 	initial release 
+ * 	These are all the debug routines from *_enet.c and a few new ones. 
+ * 	this was done to reduce the *_enet.c code.
+ *
+ * Version 1.1: 04/24/02
+ * 	fixed missind EMAC_DEV macros - Todd
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+#include "ibm_ocp_enet.h"
+#include "ibm_ocp_mal.h"
+
+int ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value);
+
+void ppc405_phy_dump(struct net_device *dev)
+{
+	unsigned long i;
+	uint data;
+
+	printk(KERN_DEBUG " Prepare for Phy dump....\n");
+	for (i = 0; i < 0x1A; i++) {
+		if (ocp_enet_mdio_read(dev, mk_mii_read(i), &data))
+			return;
+
+		printk(KERN_DEBUG "Phy reg 0x%lx ==> %4x\n", i, data);
+
+		if (i == 0x07)
+			i = 0x0f;
+	}
+}
+
+void
+ppc405_eth_desc_dump(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	int curr_slot;
+
+	printk(KERN_DEBUG "dumping the receive descriptors:  current slot is %d\n",
+	       fep->rx_slot);
+	for (curr_slot = 0; curr_slot < NUM_RX_BUFF; curr_slot++) {
+		printk(KERN_DEBUG "Desc %02d: status 0x%04x, length %3d, addr 0x%x\n",
+		       curr_slot,
+		       fep->rx_desc[curr_slot].ctrl,
+		       fep->rx_desc[curr_slot].data_len,
+		       (unsigned int) fep->rx_desc[curr_slot].data_ptr);
+	}
+}
+
+void
+ppc405_eth_emac_dump(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	printk(KERN_DEBUG "EMAC DEBUG ********** \n");
+	printk(KERN_DEBUG "EMAC_M0  ==> 0x%x\n", in_be32(&emacp->em0mr0));
+	printk(KERN_DEBUG "EMAC_M1  ==> 0x%x\n", in_be32(&emacp->em0mr1));
+	printk(KERN_DEBUG "EMAC_TXM0==> 0x%x\n", in_be32(&emacp->em0tmr0));
+	printk(KERN_DEBUG "EMAC_TXM1==> 0x%x\n", in_be32(&emacp->em0tmr1));
+	printk(KERN_DEBUG "EMAC_RXM ==> 0x%x\n", in_be32(&emacp->em0rmr));
+	printk(KERN_DEBUG "EMAC_ISR ==> 0x%x\n", in_be32(&emacp->em0isr));
+	printk(KERN_DEBUG "EMAC_IER ==> 0x%x\n", in_be32(&emacp->em0iser));
+	printk(KERN_DEBUG "EMAC_IAH ==> 0x%x\n", in_be32(&emacp->em0iahr));
+	printk(KERN_DEBUG "EMAC_IAL ==> 0x%x\n", in_be32(&emacp->em0ialr));
+	printk(KERN_DEBUG "EMAC_VLAN_TPID_REG ==> 0x%x\n", in_be32(&emacp->em0vtpid));
+}
+
+void
+ppc405_eth_mal_dump(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+
+	printk(KERN_DEBUG " MAL DEBUG ********** \n");
+	printk(KERN_DEBUG " MCR      ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALCR));
+	printk(KERN_DEBUG " ESR      ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALESR));
+	printk(KERN_DEBUG " IER      ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALIER));
+#ifdef CONFIG_40x
+	printk(KERN_DEBUG " DBR      ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALDBR));
+#endif				/* CONFIG_40x */
+	printk(KERN_DEBUG " TXCASR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCASR));
+	printk(KERN_DEBUG " TXCARR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCARR));
+	printk(KERN_DEBUG " TXEOBISR ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXEOBISR));
+	printk(KERN_DEBUG " TXDEIR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXDEIR));
+	printk(KERN_DEBUG " RXCASR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXCASR));
+	printk(KERN_DEBUG " RXCARR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXCARR));
+	printk(KERN_DEBUG " RXEOBISR ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXEOBISR));
+	printk(KERN_DEBUG " RXDEIR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXDEIR));
+	printk(KERN_DEBUG " TXCTP0R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCTP0R));
+	printk(KERN_DEBUG " TXCTP1R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCTP1R));
+	printk(KERN_DEBUG " TXCTP2R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCTP2R));
+	printk(KERN_DEBUG " TXCTP3R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCTP3R));
+	printk(KERN_DEBUG " RXCTP0R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXCTP0R));
+	printk(KERN_DEBUG " RXCTP1R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXCTP1R));
+	printk(KERN_DEBUG " RCBS0    ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRCBS0));
+	printk(KERN_DEBUG " RCBS1    ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRCBS1));
+}
+
+void
+ppc405_serr_dump_0(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	unsigned long int mal_error, plb_error, plb_addr;
+
+	mal_error = get_mal_dcrn(fep->mal, DCRN_MALESR);
+	printk(KERN_DEBUG "ppc405_eth_serr: %s channel %ld \n",
+	       (mal_error & 0x40000000) ? "Receive" :
+	       "Transmit", (mal_error & 0x3e000000) >> 25);
+	printk(KERN_DEBUG "  -----  latched error  -----\n");
+	if (mal_error & MALESR_DE)
+		printk(KERN_DEBUG "  DE: descriptor error\n");
+	if (mal_error & MALESR_OEN)
+		printk(KERN_DEBUG
+		       "  ONE: OPB non-fullword error\n");
+	if (mal_error & MALESR_OTE)
+		printk(KERN_DEBUG "  OTE: OPB timeout error\n");
+	if (mal_error & MALESR_OSE)
+		printk(KERN_DEBUG "  OSE: OPB slave error\n");
+	
+	if (mal_error & MALESR_PEIN) {
+		plb_error = mfdcr(DCRN_PLB0_BESR);
+		printk(KERN_DEBUG
+		       "  PEIN: PLB error, PLB0_BESR is 0x%x\n",
+		       (unsigned int) plb_error);
+		plb_addr = mfdcr(DCRN_PLB0_BEAR);
+		printk(KERN_DEBUG
+		       "  PEIN: PLB error, PLB0_BEAR is 0x%x\n",
+		       (unsigned int) plb_addr);
+	}
+}
+
+void
+ppc405_serr_dump_1(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	int mal_error = get_mal_dcrn(fep->mal, DCRN_MALESR);
+
+	printk(KERN_DEBUG "  -----  cumulative errors  -----\n");
+	if (mal_error & MALESR_DEI)
+		printk(KERN_DEBUG
+		       "  DEI: descriptor error interrupt\n");
+	if (mal_error & MALESR_ONEI)
+		printk(KERN_DEBUG
+		       "  OPB non-fullword error interrupt\n");
+	if (mal_error & MALESR_OTEI)
+		printk(KERN_DEBUG
+		       "  OTEI: timeout error interrupt\n");
+	if (mal_error & MALESR_OSEI)
+		printk(KERN_DEBUG
+		       "  OSEI: slave error interrupt\n");
+	if (mal_error & MALESR_PBEI)
+		printk(KERN_DEBUG
+		       "  PBEI: PLB bus error interrupt\n");
+}
+
+void
+ppc405_bl_mac_eth_dump(struct net_device *dev, int em0isr)
+{
+	printk(KERN_DEBUG "%s: on-chip ethernet error:\n", dev->name);
+	
+	if (em0isr & EMAC_ISR_OVR)
+		printk(KERN_DEBUG "  OVR: overrun\n");
+	if (em0isr & EMAC_ISR_PP)
+		printk(KERN_DEBUG "  PP: control pause packet\n");
+	if (em0isr & EMAC_ISR_BP)
+		printk(KERN_DEBUG "  BP: packet error\n");
+	if (em0isr & EMAC_ISR_RP)
+		printk(KERN_DEBUG "  RP: runt packet\n");
+	if (em0isr & EMAC_ISR_SE)
+		printk(KERN_DEBUG "  SE: short event\n");
+	if (em0isr & EMAC_ISR_ALE)
+		printk(KERN_DEBUG
+		       "  ALE: odd number of nibbles in packet\n");
+	if (em0isr & EMAC_ISR_BFCS)
+		printk(KERN_DEBUG "  BFCS: bad FCS\n");
+	if (em0isr & EMAC_ISR_PTLE)
+		printk(KERN_DEBUG "  PTLE: oversized packet\n");
+	if (em0isr & EMAC_ISR_ORE)
+		printk(KERN_DEBUG
+		       "  ORE: packet length field > max allowed LLC\n");
+	if (em0isr & EMAC_ISR_IRE)
+		printk(KERN_DEBUG "  IRE: In Range error\n");
+	if (em0isr & EMAC_ISR_DBDM)
+		printk(KERN_DEBUG "  DBDM: xmit error or SQE\n");
+	if (em0isr & EMAC_ISR_DB0)
+		printk(KERN_DEBUG
+		       "  DB0: xmit error or SQE on TX channel 0\n");
+	if (em0isr & EMAC_ISR_SE0)
+		printk(KERN_DEBUG
+		       "  SE0: Signal Quality Error test failure from TX channel 0\n");
+	if (em0isr & EMAC_ISR_TE0)
+		printk(KERN_DEBUG "  TE0: xmit channel 0 aborted\n");
+	if (em0isr & EMAC_ISR_DB1)
+		printk(KERN_DEBUG
+		       "  DB1: xmit error or SQE on TX channel \n");
+	if (em0isr & EMAC_ISR_SE1)
+		printk(KERN_DEBUG
+		       "  SE1: Signal Quality Error test failure from TX channel 1\n");
+	if (em0isr & EMAC_ISR_TE1)
+		printk(KERN_DEBUG "  TE1: xmit channel 1 aborted\n");
+	if (em0isr & EMAC_ISR_MOS)
+		printk(KERN_DEBUG "  MOS\n");
+	if (em0isr & EMAC_ISR_MOF)
+		printk(KERN_DEBUG "  MOF\n");
+	
+	ppc405_eth_emac_dump(dev);
+	ppc405_eth_mal_dump(dev);
+}
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_emac.h linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_emac.h
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_emac.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_emac.h	2003-07-19 03:01:21.000000000 +0200
@@ -0,0 +1,192 @@
+/*
+ * ibm_ocp_emac.h
+ *
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      June, 2002
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Version: 1.0: 06/02/02 - armin
+ *  	pulled all emac defined out od enet.h
+ *
+ */
+
+#ifndef _IBM_OCP_EMAC_H_
+#define _IBM_OCP_EMAC_H_
+/* General defines needed for the driver */
+
+/* MODE REG 0 */
+#define EMAC_M0_RXI			0x80000000
+#define EMAC_M0_TXI			0x40000000
+#define EMAC_M0_SRST			0x20000000
+#define EMAC_M0_TXE			0x10000000
+#define EMAC_M0_RXE			0x08000000
+#define EMAC_M0_WKE			0x04000000
+
+/* MODE Reg 1 */
+#define EMAC_M1_FDE			0x80000000
+#define EMAC_M1_ILE			0x40000000
+#define EMAC_M1_VLE			0x20000000
+#define EMAC_M1_EIFC			0x10000000
+#define EMAC_M1_APP			0x08000000
+#define EMAC_M1_AEMI			0x02000000
+#define EMAC_M1_IST			0x01000000
+#define EMAC_M1_MF_1000MBPS		0x00800000	/* 0's for 10MBPS */
+#define EMAC_M1_MF_100MBPS		0x00400000
+#ifdef CONFIG_IBM_EMAC4
+#define EMAC_M1_RFS_16K                 0x00280000	/* 000 for 512 byte */
+#define EMAC_M1_RFS_8K                  0x00200000
+#define EMAC_M1_RFS_4K                  0x00180000
+#define EMAC_M1_RFS_2K                  0x00100000
+#define EMAC_M1_RFS_1K                  0x00080000
+#define EMAC_M1_TX_FIFO_16K             0x00050000	/* 0's for 512 byte */
+#define EMAC_M1_TX_FIFO_8K              0x00040000
+#define EMAC_M1_TX_FIFO_4K              0x00030000
+#define EMAC_M1_TX_FIFO_2K              0x00020000
+#define EMAC_M1_TX_FIFO_1K              0x00010000
+#define EMAC_M1_TX_TR                   0x00008000
+#define EMAC_M1_TX_MWSW                 0x00001000	/* 0 wait for status */
+#define EMAC_M1_JUMBO_ENABLE            0x00000800	/* Upt to 9Kr status */
+#define EMAC_M1_OPB_CLK_66              0x00000010	/* 66Mhz */
+#define EMAC_M1_OPB_CLK_83              0x00000008	/* 83hz */
+#define EMAC_M1_OPB_CLK_100             0x00000018	/* 100Mhz */
+#define EMAC_M1_OPB_CLK_100P            0x00000020	/* 100Mhz+ */
+#else
+#define EMAC_M1_RFS_4K			0x00300000	/* ~4k for 512 byte */
+#define EMAC_M1_RFS_2K			0x00200000
+#define EMAC_M1_RFS_1K			0x00100000
+#define EMAC_M1_TX_FIFO_2K		0x00080000	/* 0 for 512 byte */
+#define EMAC_M1_TX_FIFO_1K		0x00040000
+#define EMAC_M1_TR0_DEPEND		0x00010000	/* 0 for one packet */
+#define EMAC_M1_TR0_MULTI		0x00008000
+#define EMAC_M1_TR1_DEPEND		0x00004000
+#define EMAC_M1_TR1_MULTI		0x00002000
+#define EMAC_M1_JUMBO_ENABLE		0x00001000
+#endif /* CONFIG_IBM_EMAC4 */
+
+/* Transmit Mode Register 0 */
+#define EMAC_TXM0_GNP0			0x80000000
+#define EMAC_TXM0_GNP1			0x40000000
+#define EMAC_TXM0_GNPD			0x20000000
+#define EMAC_TXM0_FC			0x10000000
+
+/* Receive Mode Register */
+#define EMAC_RMR_SP			0x80000000
+#define EMAC_RMR_SFCS			0x40000000
+#define EMAC_RMR_ARRP			0x20000000
+#define EMAC_RMR_ARP			0x10000000
+#define EMAC_RMR_AROP			0x08000000
+#define EMAC_RMR_ARPI			0x04000000
+#define EMAC_RMR_PPP			0x02000000
+#define EMAC_RMR_PME			0x01000000
+#define EMAC_RMR_PMME			0x00800000
+#define EMAC_RMR_IAE			0x00400000
+#define EMAC_RMR_MIAE			0x00200000
+#define EMAC_RMR_BAE			0x00100000
+#define EMAC_RMR_MAE			0x00080000
+
+/* Interrupt Status & enable Regs */
+#define EMAC_ISR_OVR			0x02000000
+#define EMAC_ISR_PP			0x01000000
+#define EMAC_ISR_BP			0x00800000
+#define EMAC_ISR_RP			0x00400000
+#define EMAC_ISR_SE			0x00200000
+#define EMAC_ISR_ALE			0x00100000
+#define EMAC_ISR_BFCS			0x00080000
+#define EMAC_ISR_PTLE			0x00040000
+#define EMAC_ISR_ORE			0x00020000
+#define EMAC_ISR_IRE			0x00010000
+#define EMAC_ISR_DBDM			0x00000200
+#define EMAC_ISR_DB0			0x00000100
+#define EMAC_ISR_SE0			0x00000080
+#define EMAC_ISR_TE0			0x00000040
+#define EMAC_ISR_DB1			0x00000020
+#define EMAC_ISR_SE1			0x00000010
+#define EMAC_ISR_TE1			0x00000008
+#define EMAC_ISR_MOS			0x00000002
+#define EMAC_ISR_MOF			0x00000001
+
+/* STA CONTROL REG */
+#define EMAC_STACR_OC			0x00008000
+#define EMAC_STACR_PHYE			0x00004000
+#define EMAC_STACR_WRITE		0x00002000
+#define EMAC_STACR_READ			0x00001000
+#define EMAC_STACR_CLK_83MHZ		0x00000800	/* 0's for 50Mhz */
+#define EMAC_STACR_CLK_66MHZ		0x00000400
+#define EMAC_STACR_CLK_100MHZ		0x00000C00
+
+/* Transmit Request Threshold Register */
+#define EMAC_TRTR_1600			0x18000000	/* 0's for 64 Bytes */
+#define EMAC_TRTR_256			0x03000000
+#define EMAC_TRTR_192			0x10000000
+#define EMAC_TRTR_128			0x01000000
+
+
+#define EMAC_TX_CTRL_GFCS		0x0200
+#define EMAC_TX_CTRL_GP			0x0100
+#define EMAC_TX_CTRL_ISA		0x0080
+#define EMAC_TX_CTRL_RSA		0x0040
+#define EMAC_TX_CTRL_IVT		0x0020
+#define EMAC_TX_CTRL_RVT		0x0010
+
+#define EMAC_TX_CTRL_DFLT ( \
+	MAL_TX_CTRL_LAST | MAL_TX_CTRL_READY | MAL_TX_CTRL_INTR | \
+	EMAC_TX_CTRL_GFCS | EMAC_TX_CTRL_GP )
+
+/* madmal transmit status / Control bits */
+#define EMAC_TX_ST_BFCS			0x0200
+#define EMAC_TX_ST_BPP			0x0100
+#define EMAC_TX_ST_LCS			0x0080
+#define EMAC_TX_ST_ED			0x0040
+#define EMAC_TX_ST_EC			0x0020
+#define EMAC_TX_ST_LC			0x0010
+#define EMAC_TX_ST_MC			0x0008
+#define EMAC_TX_ST_SC			0x0004
+#define EMAC_TX_ST_UR			0x0002
+#define EMAC_TX_ST_SQE			0x0001
+
+/* madmal receive status / Control bits */
+#define EMAC_RX_ST_OE			0x0200
+#define EMAC_RX_ST_PP			0x0100
+#define EMAC_RX_ST_BP			0x0080
+#define EMAC_RX_ST_RP			0x0040
+#define EMAC_RX_ST_SE			0x0020
+#define EMAC_RX_ST_AE			0x0010
+#define EMAC_RX_ST_BFCS			0x0008
+#define EMAC_RX_ST_PTL			0x0004
+#define EMAC_RX_ST_ORE			0x0002
+#define EMAC_RX_ST_IRE			0x0001
+#define EMAC_BAD_RX_PACKET		0x02ff
+
+/* all the errors we care about */
+#define EMAC_RX_ERRORS			0x03FF
+
+/* phy seed setup */
+#define AUTO				99
+#define _100BASET			100
+#define _10BASET			10
+#define HALF				22
+#define FULL				44
+
+#endif
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.c linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.c
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.c	2003-07-19 03:01:21.000000000 +0200
@@ -0,0 +1,975 @@
+/*
+ * ibm_ocp_enet.c
+ *
+ * Ethernet driver for the built in ethernet on the IBM 4xx PowerPC
+ * processors.
+ * 
+ * Added support for multiple PHY's and use of MII for PHY control
+ * configurable and bug fixes.
+ *
+ * Based on  the Fast Ethernet Controller (FEC) driver for
+ * Motorola MPC8xx and other contributions, see driver for contributers.
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Sept, 2001
+ *
+ *      Original driver
+ * 	Author: Johnnie Peters
+ *	jpeters@mvista.com
+ *
+ * Copyright 2000 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+
+#include <asm/ocp.h>
+#include <asm/processor.h>	/* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/crc32.h>
+
+#include "ocp_zmii.h"
+#include "ibm_ocp_enet.h"
+#include "ibm_ocp_mal.h"
+
+/* Forward declarations of some structures to support different PHYs */
+
+static int emac_open(struct net_device *);
+static int emac_start_xmit(struct sk_buff *, struct net_device *);
+static struct net_device_stats *ppc405_enet_stats(struct net_device *);
+static int ppc405_enet_close(struct net_device *);
+static void ppc405_enet_set_multicast_list(struct net_device *);
+
+static irqreturn_t ppc405_eth_wakeup(int, void *, struct pt_regs *);
+static void ppc405_eth_txeob_dev(void *, u32);
+static void ppc405_eth_rxeob_dev(void *, u32);
+static void ppc405_eth_txde_dev(void *, u32);
+static void ppc405_eth_rxde_dev(void *, u32);
+static irqreturn_t ppc405_eth_mac(int, void *, struct pt_regs *);
+static void ppc405_rx_fill(struct net_device *, int);
+static int ppc405_rx_clean(struct net_device *);
+
+int ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value);
+int ocp_enet_mdio_write(struct net_device *dev, int reg);
+int ocp_enet_ioctl(struct net_device *, struct ifreq *rq, int cmd);
+
+static struct net_device *emac_dev[EMAC_NUMS];
+
+mii_list_t mii_cmds[NMII];
+
+int emac_max;
+
+static int skb_res = SKB_RES;
+MODULE_PARM(skb_res, "i");
+MODULE_PARM_DESC(skb_res, "Amount of data to reserve on skb buffs\n"
+		 "The 405 handles a misaligned IP header fine but\n"
+		 "this can help if you are routing to a tunnel or a\n"
+		 "device that needs aligned data");
+
+
+static void disable_mal_chan(struct ocp_enet_private *fep)
+{
+	mal_disable_tx_channels(fep->mal, fep->commac.tx_chan_mask);
+	mal_disable_rx_channels(fep->mal, fep->commac.rx_chan_mask);
+}
+
+static void enable_mal_chan(struct ocp_enet_private *fep)
+{
+	mal_enable_tx_channels(fep->mal, fep->commac.tx_chan_mask);
+	mal_enable_rx_channels(fep->mal, fep->commac.rx_chan_mask);
+}
+
+static void init_rings(struct net_device *dev)
+{
+	struct ocp_enet_private *ep = dev->priv;
+	int loop;
+
+	ep->tx_desc = (struct mal_descriptor *) ((char *) ep->mal->tx_virt_addr +
+				      (ep->mal_tx_chan * MAL_DT_ALIGN));
+	ep->rx_desc = (struct mal_descriptor *) ((char *) ep->mal->rx_virt_addr +
+				      (ep->mal_rx_chan * MAL_DT_ALIGN));
+
+	/* Fill in the transmit descriptor ring. */
+	for (loop = 0; loop < NUM_TX_BUFF; loop++) {
+		ep->tx_skb[loop] = (struct sk_buff *) NULL;
+		ep->tx_desc[loop].ctrl = 0;
+		ep->tx_desc[loop].data_len = 0;
+		ep->tx_desc[loop].data_ptr = NULL;
+	}
+	ep->tx_desc[loop - 1].ctrl |= MAL_TX_CTRL_WRAP;
+
+	/* Format the receive descriptor ring. */
+	ep->rx_slot = 0;
+	ppc405_rx_fill(dev, 0);
+	if (ep->rx_slot != 0) {
+		printk(KERN_ERR
+		       "%s: Not enough mem for RxChain durning Open?\n",
+		       dev->name);
+		/*We couldn't fill the ring at startup?
+		 *We could clean up and fail to open but right now we will try to
+		 *carry on. It may be a sign of a bad NUM_RX_BUFF value
+		 */
+	}
+
+	ep->tx_cnt = 0;
+	ep->tx_slot = 0;
+	ep->ack_slot = 0;
+}
+
+static int emac_open(struct net_device *dev)
+{
+	unsigned long mode_reg;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+	unsigned long emac_ier;
+
+	if (!fep->link) {
+		printk(KERN_NOTICE "%s: Cannot open interface without phy\n",
+		       dev->name);
+		return -ENODEV;
+	}
+	disable_mal_chan(fep);
+	mal_set_rcbs(fep->mal, fep->mal_rx_chan, DESC_BUF_SIZE_REG);
+
+	/* set the high address */
+	out_be32(&emacp->em0iahr, (dev->dev_addr[0] << 8) | dev->dev_addr[1]);
+
+	/* set the low address */
+	out_be32(&emacp->em0ialr,
+		 (dev->dev_addr[2] << 24) | (dev->dev_addr[3] << 16)
+		 | (dev->dev_addr[4] << 8) | dev->dev_addr[5]);
+
+	mii_do_cmd(dev, fep->phy->ack_int);
+	mii_do_cmd(dev, fep->phy->config);
+	process_mii_queue(dev);
+
+	mii_display_status(dev);
+
+	/* set receive fifo to 4k and tx fifo to 2k */
+	mode_reg = EMAC_M1_RFS_4K | EMAC_M1_TX_FIFO_2K | EMAC_M1_APP;
+
+	/* set speed (default is 10Mb) */
+	if (fep->phy_speed == _100BASET) {
+		mode_reg = mode_reg | EMAC_M1_MF_100MBPS;
+		zmii_set_port_speed(100, dev);
+	} else {
+		mode_reg = mode_reg & ~EMAC_M1_MF_100MBPS;	/* 10 MBPS */
+		zmii_set_port_speed(10, dev);
+	}
+
+	if (fep->phy_duplex == FULL)
+		mode_reg = mode_reg | EMAC_M1_FDE | EMAC_M1_EIFC | EMAC_M1_IST;
+	else
+		mode_reg = mode_reg & ~(EMAC_M1_FDE | EMAC_M1_EIFC | EMAC_M1_ILE);	/* half duplex */
+
+#ifdef CONFIG_IBM_EMAC4
+	/* enable broadcast and individual address */
+	out_be32(&emacp->em0rmr, EMAC_RMR_IAE | EMAC_RMR_BAE | 0x00000007);
+	/* set transmit request threshold register */
+	out_be32(&emacp->em0trtr, EMAC_TRTR_256);
+	/* mode register settings */
+	mode_reg |= EMAC_M1_OPB_CLK_66 | 0x00009000;
+#else
+	out_be32(&emacp->em0rmr, EMAC_RMR_IAE | EMAC_RMR_BAE);
+	out_be32(&emacp->em0trtr, EMAC_TRTR_1600);
+	mode_reg |= EMAC_M1_TR0_MULTI;
+#endif
+
+	out_be32(&emacp->em0mr1, mode_reg);
+
+#if defined(CONFIG_440GP)
+	/* set receive low/high water mark register */
+	out_be32(&emacp->em0rwmr, 0x80009000);
+	out_be32(&emacp->em0tmr1, 0xf8640000);
+#elif defined(CONFIG_440GX)
+	out_be32(&emacp->em0rwmr, 0x1000a200);
+	out_be32(&emacp->em0tmr0, 0x00000007);
+	out_be32(&emacp->em0tmr1, 0x88810000);
+#else
+	out_be32(&emacp->em0rwmr, 0x0f002000);
+#endif /* CONFIG_440GP */
+
+	/* set frame gap */
+	out_be32(&emacp->em0ipgvr, CONFIG_IBM_OCP_ENET_GAP);
+
+	emac_ier = EMAC_ISR_PP | EMAC_ISR_BP | EMAC_ISR_RP |
+	    EMAC_ISR_SE | EMAC_ISR_PTLE | EMAC_ISR_ALE |
+	    EMAC_ISR_BFCS | EMAC_ISR_ORE | EMAC_ISR_IRE;
+
+	out_be32(&emacp->em0iser, emac_ier);
+
+	/* FIXME: check failures */
+	request_irq(dev->irq, ppc405_eth_mac, 0, dev->name, dev);
+	request_irq(fep->wol_irq, ppc405_eth_wakeup, SA_SHIRQ, "EMAC WOL", dev);
+
+	/* init buffer descriptors rings */
+	init_rings(dev);
+
+	/* enable all MAL transmit and receive channels */
+	enable_mal_chan(fep);
+
+	/* set transmit and receive enable */
+	out_be32(&emacp->em0mr0, EMAC_M0_TXE | EMAC_M0_RXE);
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int
+emac_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	unsigned short ctrl;
+	unsigned long flags;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	save_flags(flags);
+	cli();
+	if (netif_queue_stopped(dev) || (fep->tx_cnt == NUM_TX_BUFF)) {
+
+		fep->stats.tx_dropped++;
+		restore_flags(flags);
+		return -EBUSY;
+	}
+
+	if (++fep->tx_cnt == NUM_TX_BUFF)
+		netif_stop_queue(dev);
+
+	/* Store the skb buffer for later ack by the transmit end of buffer
+	 * interrupt.
+	 */
+	fep->tx_skb[fep->tx_slot] = skb;
+	consistent_sync((void *) skb->data, skb->len, PCI_DMA_TODEVICE);
+
+	ctrl = EMAC_TX_CTRL_DFLT;
+	if ((NUM_TX_BUFF - 1) == fep->tx_slot)
+		ctrl |= MAL_TX_CTRL_WRAP;
+
+	fep->tx_desc[fep->tx_slot].data_ptr = (char *) virt_to_phys(skb->data);
+	fep->tx_desc[fep->tx_slot].data_len = (short) skb->len;
+	fep->tx_desc[fep->tx_slot].ctrl = ctrl;
+
+	/* Send the packet out. */
+#ifdef CONFIG_IBM_EMAC4
+	out_be32(&emacp->em0tmr0, EMAC_TXM0_GNP0 | 0x00000007);
+#else
+	out_be32(&emacp->em0tmr0, EMAC_TXM0_GNP0);
+#endif
+
+	if (++fep->tx_slot == NUM_TX_BUFF)
+		fep->tx_slot = 0;
+
+	fep->stats.tx_packets++;
+	fep->stats.tx_bytes += skb->len;
+
+	restore_flags(flags);
+
+	return 0;
+}
+
+static int
+ppc405_enet_close(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	disable_mal_chan(fep);
+
+	out_be32(&emacp->em0mr0, EMAC_M0_SRST);
+	udelay(10);
+
+	if (emacp->em0mr0 & EMAC_M0_SRST) {
+		/*not sure what to do here hopefully it clears before another open */
+		printk(KERN_ERR "%s: Phy SoftReset didn't clear, no link?\n",
+		       dev->name);
+	}
+
+	/* Free the irq's */
+	free_irq(dev->irq, dev);
+	free_irq(fep->wol_irq, dev);
+
+	free_phy(dev);
+	return 0;
+}
+
+static void
+ppc405_enet_set_multicast_list(struct net_device *dev)
+{
+	struct ocp_enet_private *ep = dev->priv;
+	volatile emac_t *emacp = ep->emacp;
+
+	if (dev->flags & IFF_PROMISC) {
+
+		/* If promiscuous mode is set then we do not need anything else */
+		out_be32(&emacp->em0rmr, EMAC_RMR_PME);
+
+	} else if (dev->flags & IFF_ALLMULTI || 32 < dev->mc_count) {
+
+		/* Must be setting up to use multicast.  Now check for promiscuous
+		 * multicast
+		 */
+		out_be32(&emacp->em0rmr,
+			 EMAC_RMR_IAE | EMAC_RMR_BAE | EMAC_RMR_PMME);
+	} else if (dev->flags & IFF_MULTICAST && 0 < dev->mc_count) {
+
+		unsigned short em0gaht[4] = { 0, 0, 0, 0 };
+		struct dev_mc_list *dmi;
+
+		/* Need to hash on the multicast address. */
+		for (dmi = dev->mc_list; dmi; dmi = dmi->next) {
+			unsigned long mc_crc;
+			unsigned int bit_number;
+
+			mc_crc = ether_crc(6, (char *) dmi->dmi_addr);
+			bit_number = 63 - (mc_crc >> 26);	/* MSB: 0 LSB: 63 */
+			em0gaht[bit_number >> 4] |=
+			    0x8000 >> (bit_number & 0x0f);
+		}
+		emacp->em0gaht1 = em0gaht[0];
+		emacp->em0gaht2 = em0gaht[1];
+		emacp->em0gaht3 = em0gaht[2];
+		emacp->em0gaht4 = em0gaht[3];
+
+		/* Turn on multicast addressing */
+		out_be32(&emacp->em0rmr,
+			 EMAC_RMR_IAE | EMAC_RMR_BAE | EMAC_RMR_MAE);
+
+	} else {
+		/* If multicast mode is not set then we are 
+		 * turning it off at this point 
+		 */
+		out_be32(&emacp->em0rmr, EMAC_RMR_IAE | EMAC_RMR_BAE);
+
+	}
+
+	return;
+}
+
+static struct net_device_stats *
+ppc405_enet_stats(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	return &fep->stats;
+}
+
+static void  __devexit ocp_emac_remove_one (struct ocp_device *pdev)
+{
+	struct net_device *dev = ocp_get_drvdata(pdev);
+	printk("removing net dev \n");
+	ocp_force_power_off(pdev);
+	unregister_netdev(dev);
+}
+
+struct mal_commac_ops emac_commac_ops = {
+	.txeob = &ppc405_eth_txeob_dev,
+	.txde = &ppc405_eth_txde_dev,
+	.rxeob = &ppc405_eth_rxeob_dev,
+	.rxde = &ppc405_eth_rxde_dev,
+};
+
+static int __devinit ocp_emac_probe(struct ocp_device *pdev)
+{
+	int err = 0;
+	int i;
+	struct net_device *dev;
+	struct ocp_enet_private *ep;
+	int emac_num = pdev->num;
+
+	dev = init_etherdev(NULL, sizeof (struct ocp_enet_private));
+	if (dev == NULL) {
+		printk(KERN_ERR
+		       "ibm_ocp_enet: Could not allocate ethernet device.\n");
+		return -1;
+	}
+
+	ep = dev->priv;
+	ep->ocpdev = pdev;
+	ocp_set_drvdata(pdev, dev);
+
+	ep->mal = &mal_table[0];
+	/* FIXME: need a better way of determining these */
+#ifdef CONFIG_440GX
+	ep->mal_tx_chan = emac_num;
+#else
+	ep->mal_tx_chan = emac_num * 2;
+#endif
+	ep->mal_rx_chan = emac_num;
+
+	ep->emacp = __ioremap(pdev->paddr, sizeof (emac_t), _PAGE_NO_CACHE);
+
+	zmii_init(ZMII_AUTO, dev);
+	find_phy(dev);
+	if (!ep->phy)
+		return -1;
+
+	ep->link = 1;
+	dev->irq = pdev->irq;
+	ep->wol_irq = BL_MAC_WOL; /* FIXME: need a better way to get this */
+
+	/* read the MAC Address */
+	for (i = 0; i < 6; i++)
+		dev->dev_addr[i] = __res.BD_EMAC_ADDR(emac_num, i);	/* Marco to disques array */
+
+	ep->commac.ops = &emac_commac_ops;
+	ep->commac.dev = dev;
+	ep->commac.tx_chan_mask = MAL_CHAN_MASK(ep->mal_tx_chan);
+	ep->commac.rx_chan_mask = MAL_CHAN_MASK(ep->mal_rx_chan);
+	err = mal_register_commac(ep->mal, &ep->commac);
+	if (err)
+		return err; /* FIXME: cleanup needed? */
+	
+
+	/* Fill in the driver function table */
+	dev->open = &emac_open;
+	dev->hard_start_xmit = &emac_start_xmit;
+	dev->stop = &ppc405_enet_close;
+	dev->get_stats = &ppc405_enet_stats;
+	dev->set_multicast_list = &ppc405_enet_set_multicast_list;
+	dev->do_ioctl = &ocp_enet_ioctl;
+	emac_dev[emac_num] = dev;
+
+	/* Reset the EMAC */
+	out_be32(&ep->emacp->em0mr0, EMAC_M0_SRST);
+	udelay(10);
+
+	if (in_be32(&ep->emacp->em0mr0) & EMAC_M0_SRST) {
+		printk(KERN_NOTICE "%s: Cannot open interface without Link\n",
+		       dev->name);
+		return -1;
+	}
+
+	printk("IBM EMAC: %s: ", dev->name);
+	printk("MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
+			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	return 0;
+
+}
+
+static struct ocp_device_id ocp_emac_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_EMAC},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_emac_id_tbl );
+
+static struct ocp_driver ocp_emac_driver = {
+	.name		= "ocp_emac",
+	.id_table	= ocp_emac_id_tbl,
+	.probe		= ocp_emac_probe,
+	.remove		= __devexit_p(ocp_emac_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_emac_suspend,
+	.resume		= ocp_emac_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init
+init_ppc405_enet(void)
+{
+	int i;
+
+	for (i = 0; i < NMII - 1; i++)
+		mii_cmds[i].mii_next = &mii_cmds[i + 1];
+	mii_free = mii_cmds;
+
+	return ocp_module_init(&ocp_emac_driver);
+}
+
+/*
+ * int ocp_enet_mdio_read()
+ *
+ * Description:
+ *   This routine reads from a specified register on a PHY over the MII
+ *   Management Interface.
+ *
+ * Input(s):
+ *   phy    - The address of the PHY to read from. May be 0 through 31.
+ *   reg    - The PHY register to read. May be 0 through 31.
+ *   *value - Storage for the value to read from the PHY register.
+ *
+ * Output(s):
+ *   *value - The value read from the PHY register.
+ *
+ * Returns:
+ *   0 if OK, otherwise -1 on error.
+ *
+ */
+int
+ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value)
+{
+	register int i;
+	uint32_t stacr;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	/* Wait for data transfer complete bit */
+	zmii_enable_port(dev);
+	for (i = 0; i < OCP_RESET_DELAY; ++i) {
+		if (emacp->em0stacr & EMAC_STACR_OC)
+			break;
+		udelay(MDIO_DELAY);	/* changed to 2 with new scheme -armin */
+	}
+	if ((emacp->em0stacr & EMAC_STACR_OC) == 0) {
+		printk("OCP Reset timeout #1!\n");
+		return -1;
+	}
+
+	/* Clear the speed bits and make a read request to the PHY */
+
+	stacr = reg | ((fep->phy_addr & 0x1F) << 5);
+
+	out_be32(&emacp->em0stacr, stacr);
+	stacr = in_be32(&emacp->em0stacr);
+	/* Wait for data transfer complete bit */
+	for (i = 0; i < OCP_RESET_DELAY; ++i) {
+		if ((stacr = in_be32(&emacp->em0stacr)) & EMAC_STACR_OC)
+			break;
+		udelay(MDIO_DELAY);
+	}
+	if ((stacr & EMAC_STACR_OC) == 0) {
+		printk("OCP Reset timeout #2!\n");
+		return -1;
+	}
+
+	/* Check for a read error */
+	if (stacr & EMAC_STACR_PHYE) {
+		return -1;
+	}
+	*value = (stacr >> 16);
+	return 0;
+}
+
+/*
+ * int ocp_enet_mdio_write()
+ *
+ * Description:
+ *   This routine reads from a specified register on a PHY over the MII
+ *   Management Interface.
+ *
+ * Input(s):
+ *   phy    - The address of the PHY to read from. May be 0 through 31.
+ *   reg    - The PHY register to read. May be 0 through 31.
+ *
+ * Output(s):
+ *   value - The value writing to the PHY register.
+ *
+ * Returns:
+ *   0 if OK, otherwise -1 on error.
+ *
+ */
+int
+ocp_enet_mdio_write(struct net_device *dev, int reg)
+{
+	register int i = 0;
+	uint32_t stacr;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	zmii_enable_port(dev);
+	/* Wait for data transfer complete bit */
+	for (i = 0; i < OCP_RESET_DELAY; ++i) {
+		if (emacp->em0stacr & EMAC_STACR_OC)
+			break;
+		udelay(MDIO_DELAY);	/* changed to 2 with new scheme -armin */
+	}
+	if ((emacp->em0stacr & EMAC_STACR_OC) == 0) {
+		printk("OCP Reset timeout!\n");
+		return -1;
+	}
+
+	/* Clear the speed bits and make a read request to the PHY */
+
+	stacr = reg | ((fep->phy_addr & 0x1F) << 5);
+	out_be32(&emacp->em0stacr, stacr);
+
+	/* Wait for data transfer complete bit */
+	for (i = 0; i < OCP_RESET_DELAY; ++i) {
+		if ((stacr = emacp->em0stacr) & EMAC_STACR_OC)
+			break;
+		udelay(MDIO_DELAY);
+	}
+	if ((emacp->em0stacr & EMAC_STACR_OC) == 0) {
+		printk("OCP Reset timeout!\n");
+		return -1;
+	}
+
+	/* Check for a read error */
+	if ((stacr & EMAC_STACR_PHYE) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * int ocp_enet_ioctl()
+ *
+ * Description:
+ *   This routine performs the specified I/O control command on the
+ *   specified net device.
+ *
+ * Input(s):
+ *   *dev - Pointer to the device structure for this driver.
+ *   *rq  - Pointer to data to be written and/or storage for return data.
+ *    cmd - I/O control command to perform.
+ *
+ *
+ * Output(s):
+ *   *rq  - If OK, pointer to return data for a read command.
+ *
+ * Returns:
+ *   0 if OK, otherwise an error number on error.
+ *
+ */
+int
+ocp_enet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	uint *data = (uint *) & rq->ifr_data;
+
+	switch (cmd) {
+
+	case SIOCDEVPRIVATE:
+		data[0] = fep->phy_addr;
+	 /*FALLTHRU*/ case SIOCDEVPRIVATE + 1:
+		if (ocp_enet_mdio_read(dev, mk_mii_read(data[1]), &data[3]) < 0)
+			return -EIO;
+
+		return 0;
+
+	case SIOCDEVPRIVATE + 2:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		if (ocp_enet_mdio_write(dev, mk_mii_write(data[1], data[2])) <
+		    0)
+			return -EIO;
+
+		return 0;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static irqreturn_t
+ppc405_eth_wakeup(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	/* On Linux the 405 ethernet will always be active if configured
+	 * in.  This interrupt should never occur.
+	 */
+	printk(KERN_INFO "IBM EMAC: interrupt ppc405_eth_wakeup\n");
+	return IRQ_HANDLED;
+}
+
+
+static void ppc405_eth_txeob_dev(void *p, u32 chanmask)
+{
+	struct net_device *dev = p;
+	struct ocp_enet_private *fep = dev->priv;
+
+	while (fep->tx_cnt &&
+		!(fep->tx_desc[fep->ack_slot].ctrl & MAL_TX_CTRL_READY)) {
+
+		/* Tell the system the transmit completed. */
+		dev_kfree_skb_irq(fep->tx_skb[fep->ack_slot]);
+
+		if (fep->tx_desc[fep->ack_slot].ctrl &
+		    (EMAC_TX_ST_EC | EMAC_TX_ST_MC | EMAC_TX_ST_SC))
+			fep->stats.collisions++;
+
+		fep->tx_skb[fep->ack_slot] = (struct sk_buff *) NULL;
+		if (++fep->ack_slot == NUM_TX_BUFF)
+			fep->ack_slot = 0;
+
+		fep->tx_cnt--;
+
+		netif_wake_queue(dev);
+	}
+
+	return;
+}
+
+/*
+  Fill/Re-fill the rx chain with valid ctrl/ptrs.
+  This function will fill from rx_slot up to the parm end.
+  So to completely fill the chain pre-set rx_slot to 0 and
+  pass in an end of 0.
+ */
+static void
+ppc405_rx_fill(struct net_device *dev, int end)
+{
+	int i;
+	struct ocp_enet_private *fep = dev->priv;
+	unsigned char *ptr;
+
+	i = fep->rx_slot;
+	do {
+		if (fep->rx_skb[i] != NULL) {
+			/*We will trust the skb is still in a good state */
+			ptr = (char *) virt_to_phys(fep->rx_skb[i]->data);
+		} else {
+
+			fep->rx_skb[i] =
+			    dev_alloc_skb(DESC_RX_BUF_SIZE + skb_res);
+
+			if (fep->rx_skb[i] == NULL) {
+				/* Keep rx_slot here, the next time clean/fill is called
+				 * we will try again before the MAL wraps back here
+				 * If the MAL tries to use this descriptor with
+				 * the EMPTY bit off it will cause the
+				 * rxde interrupt.  That is where we will
+				 * try again to allocate an sk_buff.
+				 */
+				break;
+
+			}
+
+			if (skb_res)
+				skb_reserve(fep->rx_skb[i], skb_res);
+
+			consistent_sync((void *) fep->rx_skb[i]->
+					data, DESC_RX_BUF_SIZE,
+					PCI_DMA_BIDIRECTIONAL);
+			ptr = (char *) virt_to_phys(fep->rx_skb[i]->data);
+		}
+		fep->rx_desc[i].ctrl = MAL_RX_CTRL_EMPTY | MAL_RX_CTRL_INTR |	/*could be smarter about this to avoid ints at high loads */
+		    (i == (NUM_RX_BUFF - 1) ? MAL_RX_CTRL_WRAP : 0);
+
+		fep->rx_desc[i].data_ptr = ptr;
+		/*
+		   * 440GP uses the previously reserved bits in the
+		   * data_len to encode the upper 4-bits of the buffer
+		   * physical address (ERPN). Initialize these.
+		 */
+		fep->rx_desc[i].data_len = 0;
+	} while ((i = (i + 1) % NUM_RX_BUFF) != end);
+
+	fep->rx_slot = i;
+}
+
+static int
+ppc405_rx_clean(struct net_device *dev)
+{
+	int i;
+	int error, frame_length;
+	struct ocp_enet_private *fep = dev->priv;
+	unsigned short ctrl;
+
+	i = fep->rx_slot;
+
+	do {
+		if (fep->rx_skb[i] == NULL)
+			continue;	/*we have already handled the packet but haved failed to alloc */
+		/* 
+		   since rx_desc is in uncached mem we don't keep reading it directly 
+		   we pull out a local copy of ctrl and do the checks on the copy.
+		 */
+		ctrl = fep->rx_desc[i].ctrl;
+		if (ctrl & MAL_RX_CTRL_EMPTY)
+			break;	/*we don't have any more ready packets */
+
+		if (ctrl & EMAC_BAD_RX_PACKET) {
+
+			fep->stats.rx_errors++;
+			fep->stats.rx_dropped++;
+
+			if (ctrl & EMAC_RX_ST_OE)
+				fep->stats.rx_fifo_errors++;
+			if (ctrl & EMAC_RX_ST_AE)
+				fep->stats.rx_frame_errors++;
+			if (ctrl & EMAC_RX_ST_BFCS)
+				fep->stats.rx_crc_errors++;
+			if (ctrl & (EMAC_RX_ST_RP | EMAC_RX_ST_PTL |
+				    EMAC_RX_ST_ORE | EMAC_RX_ST_IRE))
+				fep->stats.rx_length_errors++;
+		} else {
+
+			/* Send the skb up the chain. */
+			frame_length = fep->rx_desc[i].data_len - 4;
+
+			skb_put(fep->rx_skb[i], frame_length);
+			fep->rx_skb[i]->dev = dev;
+			fep->rx_skb[i]->protocol =
+			    eth_type_trans(fep->rx_skb[i], dev);
+
+			error = netif_rx(fep->rx_skb[i]);
+			if ((error == NET_RX_DROP) || (error == NET_RX_BAD)) {
+				fep->stats.rx_dropped++;
+			} else {
+				fep->stats.rx_packets++;
+				fep->stats.rx_bytes += frame_length;
+			}
+			fep->rx_skb[i] = NULL;
+		}
+	} while ((i = (i + 1) % NUM_RX_BUFF) != fep->rx_slot);
+	return i;
+}
+
+static void ppc405_eth_rxeob_dev(void *p, u32 chanmask)
+{
+	struct net_device *dev = p;
+	int n;
+	
+	n = ppc405_rx_clean(dev);
+	ppc405_rx_fill(dev, n);
+}
+
+/*
+ * This interrupt should never occurr, we don't program
+ * the MAL for contiunous mode.
+ */
+static void ppc405_eth_txde_dev(void *p, u32 chanmask)
+{
+	struct net_device *dev = p;
+	struct ocp_enet_private *fep = dev->priv;
+
+	printk(KERN_WARNING "%s: Tx descriptor error\n", dev->name);
+
+	ppc405_eth_emac_dump(dev);
+	ppc405_eth_mal_dump(dev);
+
+	/* Reenable the transmit channel */
+	mal_enable_tx_channels(fep->mal, fep->commac.tx_chan_mask);
+	return;
+}
+
+/*
+ * This interrupt should be very rare at best.  This occurs when
+ * the hardware has a problem with the receive descriptors.  The manual
+ * states that it occurs when the hardware cannot the receive descriptor
+ * empty bit is not set.  The recovery mechanism will be to
+ * traverse through the descriptors, handle any that are marked to be
+ * handled and reinitialize each along the way.  At that point the driver
+ * will be restarted.
+ */
+static void ppc405_eth_rxde_dev(void *p, u32 chanmask)
+{
+	struct net_device *dev = p;
+	struct ocp_enet_private *fep = dev->priv;
+
+	printk(KERN_WARNING "%s: Rx descriptor error\n", dev->name);
+
+	ppc405_eth_emac_dump(dev);
+	ppc405_eth_mal_dump(dev);
+	ppc405_eth_desc_dump(dev);
+
+
+	fep->stats.rx_errors++;
+
+	/* so do we have any good packets still? */
+	ppc405_rx_clean(dev);
+	
+	/* When the interface is restarted it resets processing to the
+	 * first descriptor in the table.  */
+	fep->rx_slot = 0;
+	ppc405_rx_fill(dev, 0);
+	
+	set_mal_dcrn(fep->mal, DCRN_MALRXEOBISR, MAL_CHAN_MASK(fep->mal_rx_chan));
+
+	/* Clear the interrupt */
+	set_mal_dcrn(fep->mal, DCRN_MALRXDEIR, MAL_CHAN_MASK(fep->mal_rx_chan));
+
+	/* Reenable the receive channel */
+	mal_enable_rx_channels(fep->mal, fep->commac.rx_chan_mask);
+}
+
+static irqreturn_t
+ppc405_eth_mac(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	unsigned long tmp_em0isr;
+	struct net_device *dev = dev_instance;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	/* EMAC interrupt */
+	tmp_em0isr = in_be32(&emacp->em0isr);
+	if (tmp_em0isr & (EMAC_ISR_TE0 | EMAC_ISR_TE1)) {
+		/* This error is a hard transmit error - could retransmit */
+		fep->stats.tx_errors++;
+
+		/* Reenable the transmit channel */
+		mal_enable_tx_channels(fep->mal, fep->commac.tx_chan_mask);
+	} else {
+		fep->stats.rx_errors++;
+	}
+
+/*	if (tmp_em0isr & EMAC_ISR_OVR ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_PP ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_BP ) fep->stats.ZZZ++;		*/
+	if (tmp_em0isr & EMAC_ISR_RP)
+		fep->stats.rx_length_errors++;
+/*	if (tmp_em0isr & EMAC_ISR_SE ) fep->stats.ZZZ++;		*/
+	if (tmp_em0isr & EMAC_ISR_ALE)
+		fep->stats.rx_frame_errors++;
+	if (tmp_em0isr & EMAC_ISR_BFCS)
+		fep->stats.rx_crc_errors++;
+	if (tmp_em0isr & EMAC_ISR_PTLE)
+		fep->stats.rx_length_errors++;
+	if (tmp_em0isr & EMAC_ISR_ORE)
+		fep->stats.rx_length_errors++;
+/*	if (tmp_em0isr & EMAC_ISR_IRE ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_DBDM) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_DB0 ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_SE0 ) fep->stats.ZZZ++;		*/
+	if (tmp_em0isr & EMAC_ISR_TE0)
+		fep->stats.tx_aborted_errors++;
+/*	if (tmp_em0isr & EMAC_ISR_DB1 ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_SE1 ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_TE1) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_MOS ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_MOF ) fep->stats.ZZZ++;		*/
+
+	ppc405_bl_mac_eth_dump(dev, tmp_em0isr);
+
+	out_be32(&emacp->em0isr, tmp_em0isr);
+	
+	return IRQ_HANDLED;
+}
+
+static void __exit
+exit_ppc405_enet(void)
+{
+}
+
+module_init(init_ppc405_enet);
+module_exit(exit_ppc405_enet);
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.h linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.h
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.h	2003-07-19 03:01:21.000000000 +0200
@@ -0,0 +1,173 @@
+/*
+ * ibm_ocp_enet.h
+ *
+ * Ethernet driver for the built in ethernet on the IBM 405 PowerPC
+ * processor.
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Sept, 2001
+ *
+ *      Orignial driver
+ *         Johnnie Peters
+ *         jpeters@mvista.com
+ *
+ * Copyright 2000 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _IBM_OCP_ENET_H_
+#define _IBM_OCP_ENET_H_
+
+#include <linux/netdevice.h>
+#include <asm/ocp.h>
+#include <asm/mmu.h>		/* For phys_addr_t */
+#include "ocp_zmii.h"
+#include "ibm_ocp_emac.h"
+#include "ibm_ocp_phy.h"
+#include "ibm_ocp_mal.h"
+
+#ifndef CONFIG_IBM_OCP_ENET_TX_BUFF
+#define NUM_TX_BUFF		6
+#define NUM_RX_BUFF		64
+#else
+#define NUM_TX_BUFF		CONFIG_IBM_OCP_ENET_TX_BUFF
+#define NUM_RX_BUFF		CONFIG_IBM_OCP_ENET_RX_BUFF
+#endif
+
+/* This does 16 byte alignment, exactly what we need.
+ * The packet length includes FCS, but we don't want to
+ * include that when passing upstream as it messes up
+ * bridging applications.
+ */
+#ifndef CONFIG_IBM_OCP_ENET_SKB_RES
+#define SKB_RES 2
+#else
+#define SKB_RES CONFIG_IBM_OCP_ENET_SKB_RES
+#endif
+
+#define MAX_NUM_BUF_DESC	255
+#define DECS_TX_BUF_SIZE	2048
+#define DESC_RX_BUF_SIZE	2048	/* max 4096-16 */
+#define DESC_BUF_SIZE		2048
+#define DESC_BUF_SIZE_REG	(DESC_RX_BUF_SIZE / 16)
+
+
+#define MIN_PHY_ADDR            0x01
+#define MAX_PHY_ADDR            0x1f
+/* Transmitter timeout. */
+#define TX_TIMEOUT		(2*HZ)
+#define OCP_RESET_DELAY		50
+#define MDIO_DELAY		2
+#define NMII				20
+
+
+#ifdef CONFIG_IBM_OCP_ENET_ERROR_MSG
+void ppc405_serr_dump_0(struct net_device *dev);
+void ppc405_serr_dump_1(struct net_device *dev);
+void ppc405_bl_mac_eth_dump(struct net_device *dev, int em0isr);
+void  ppc405_phy_dump(struct net_device *);
+void ppc405_eth_desc_dump(struct net_device *);
+void ppc405_eth_emac_dump(struct net_device *);
+void ppc405_eth_mal_dump(struct net_device *);
+#else
+#define ppc405_serr_dump_0(dev) do { } while (0)
+#define ppc405_serr_dump_1(dev) do { } while (0)
+#define ppc405_bl_mac_eth_dump(dev,x) do { } while (0)
+#define ppc405_phy_dump(dev) do { } while (0)
+#define ppc405_eth_desc_dump(dev) do { } while (0)
+#define ppc405_eth_emac_dump(dev) do { } while (0)
+#define ppc405_eth_mal_dump(dev) do { } while (0)
+#endif
+
+#define mk_mii_read(REG)		((EMAC_STACR_READ| (REG & 0x1f)) & \
+						~EMAC_STACR_CLK_100MHZ)
+#define mk_mii_write(REG,VAL)		(((EMAC_STACR_WRITE | (REG & 0x1f)) & \
+						~EMAC_STACR_CLK_100MHZ) | \
+						((VAL & 0xffff) << 16))
+/* Emac */
+typedef struct emac_regs {
+	volatile u32 em0mr0;
+	volatile u32 em0mr1;
+	volatile u32 em0tmr0;
+	volatile u32 em0tmr1;
+	volatile u32 em0rmr;
+	volatile u32 em0isr;
+	volatile u32 em0iser;
+	volatile u32 em0iahr;
+	volatile u32 em0ialr;
+	volatile u32 em0vtpid;
+	volatile u32 em0vtci;
+	volatile u32 em0ptr;
+	volatile u32 em0iaht1;
+	volatile u32 em0iaht2;
+	volatile u32 em0iaht3;
+	volatile u32 em0iaht4;
+	volatile u32 em0gaht1;
+	volatile u32 em0gaht2;
+	volatile u32 em0gaht3;
+	volatile u32 em0gaht4;
+	volatile u32 em0lsal;
+	volatile u32 em0lsah;
+	volatile u32 em0ipgvr;
+	volatile u32 em0stacr;
+	volatile u32 em0trtr;
+	volatile u32 em0rwmr;
+} emac_t;
+
+struct ocp_enet_private {
+	struct sk_buff *tx_skb[NUM_TX_BUFF];
+	struct sk_buff *rx_skb[NUM_RX_BUFF];
+	struct mal_descriptor *tx_desc;
+	struct mal_descriptor *rx_desc;
+	struct mal_descriptor *rx_dirty;
+	struct net_device_stats stats;
+	int tx_cnt;
+	int rx_slot;
+	int dirty_rx;
+	int tx_slot;
+	int ack_slot;
+	uint phy_id;
+	uint phy_id_done;
+	uint phy_status;
+	uint phy_speed;
+	uint phy_duplex;
+	phy_info_t *phy;
+	uint phy_addr;
+	int link;
+	int old_link;
+	int full_duplex;
+
+	zmii_t *zmii_base;
+	int zmii_mode;
+	struct ocp_device *zmii_ocpdev;
+
+	struct ibm_ocp_mal *mal;
+	int mal_tx_chan, mal_rx_chan;
+	struct mal_commac commac;
+
+	volatile emac_t *emacp;
+	int wol_irq;
+	struct ocp_device *ocpdev;
+};
+
+
+#endif				/* _IBM_OCP_ENET_H_ */
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.c linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.c
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.c	2003-08-23 17:04:02.000000000 +0200
@@ -0,0 +1,410 @@
+/*
+ * ibm_ocp_mal.c
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Juen, 2002
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/ocp.h>
+
+#include "ibm_ocp_mal.h"
+
+struct ibm_ocp_mal mal_table[NUM_MALS]; /* = 0 */
+
+static void __exit exit_mal(struct ibm_ocp_mal *mal);
+
+int mal_register_commac(struct ibm_ocp_mal *mal, struct mal_commac *commac)
+{
+	/* FIXME: locking? */
+
+	/* Don't let multiple commacs claim the same channel */
+	if ( (mal->tx_chan_mask & commac->tx_chan_mask) ||
+	     (mal->rx_chan_mask & commac->rx_chan_mask) )
+		return -EBUSY;
+
+	mal->tx_chan_mask |= commac->tx_chan_mask;
+	mal->rx_chan_mask |= commac->rx_chan_mask;
+
+	list_add(&commac->list, &mal->commac);
+
+	return 0;
+}
+
+int mal_set_rcbs(struct ibm_ocp_mal *mal, int channel, unsigned long size)
+{
+	switch (channel) {
+	case 0:
+		set_mal_dcrn(mal, DCRN_MALRCBS0, size);
+		break;
+#ifdef DCRN_MALRCBS1
+	case 1:
+		set_mal_dcrn(mal, DCRN_MALRCBS1, size);
+		break;
+#endif
+#ifdef DCRN_MALRCBS2
+	case 2:
+		set_mal_dcrn(mal, DCRN_MALRCBS2, size);
+		break;
+#endif
+#ifdef DCRN_MALRCBS3
+	case 3:
+		set_mal_dcrn(mal, DCRN_MALRCBS3, size);
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static irqreturn_t mal_serr(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	unsigned long mal_error;
+
+	/*
+	 * This SERR applies to one of the devices on the MAL, here we charge
+	 * it against the first EMAC registered for the MAL.
+	 */
+
+	mal_error = get_mal_dcrn(mal, DCRN_MALESR);
+
+	printk(KERN_ERR "%s: System Error (MALESR=%lx)\n", 
+	       "MAL" /* FIXME: get the name right */, mal_error);
+
+	/* FIXME: decipher error */
+	/* DIXME: distribute to commacs, if possible */
+
+	/* Clear the error status register */
+	set_mal_dcrn(mal, DCRN_MALESR, mal_error);
+	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mal_txeob(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	struct list_head *l;
+	unsigned long isr;
+
+	/* Loop to better handle lots of interrupts */
+
+	isr = get_mal_dcrn(mal, DCRN_MALTXEOBISR);
+	set_mal_dcrn(mal, DCRN_MALTXEOBISR, isr);
+
+	list_for_each(l, &mal->commac) {
+		struct mal_commac *mc = list_entry(l, struct mal_commac, list);
+
+		if (isr & mc->tx_chan_mask) {
+			mc->ops->txeob(mc->dev, isr & mc->tx_chan_mask);
+		}
+	}
+	/* What if we don't get a hit in the list? */
+	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mal_rxeob(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	struct list_head *l;
+	unsigned long isr;
+
+	/*
+	 * Protect against mal_rxde() modifying data structures this
+	 * function is using. FIXME: synchronisation should move within
+	 * the client drivers */
+	disable_irq(mal->rxde_irq);
+
+
+	/* FIXME: Loop to better handle lots of interrupts? */
+
+	isr = get_mal_dcrn(mal, DCRN_MALRXEOBISR);
+	set_mal_dcrn(mal, DCRN_MALRXEOBISR, isr);
+
+	list_for_each(l, &mal->commac) {
+		struct mal_commac *mc = list_entry(l, struct mal_commac, list);
+
+		if (isr & mc->rx_chan_mask) {
+			mc->ops->rxeob(mc->dev, isr & mc->rx_chan_mask);
+		}
+	}
+	/* FIXME: What if we don't get a hit in the list? */
+
+	enable_irq(mal->rxde_irq);
+	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mal_txde(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	struct list_head *l;
+	unsigned long deir;
+
+	deir = get_mal_dcrn(mal, DCRN_MALTXDEIR);
+
+	/* FIXME: print which MAL correctly */
+	printk(KERN_WARNING "%s: Tx descriptor error (MALTXDEIR=%lx)\n",
+	       "MAL", deir);
+
+	list_for_each(l, &mal->commac) {
+		struct mal_commac *mc = list_entry(l, struct mal_commac, list);
+
+		if (deir & mc->tx_chan_mask) {
+			mc->ops->txde(mc->dev, deir & mc->tx_chan_mask);
+		}
+	}
+	/* What if there is no match in the list? */
+	
+	return IRQ_HANDLED;
+}
+
+/*
+ * This interrupt should be very rare at best.  This occurs when
+ * the hardware has a problem with the receive descriptors.  The manual
+ * states that it occurs when the hardware cannot the receive descriptor
+ * empty bit is not set.  The recovery mechanism will be to
+ * traverse through the descriptors, handle any that are marked to be
+ * handled and reinitialize each along the way.  At that point the driver
+ * will be restarted.
+ */
+static irqreturn_t mal_rxde(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	struct list_head *l;
+	unsigned long deir;
+
+	deir = get_mal_dcrn(mal, DCRN_MALRXDEIR);
+
+	/*
+	 * This really is needed.  This case encountered in stress testing.
+	 */
+	if (deir == 0)
+		return IRQ_HANDLED;
+
+	/* FIXME: print which MAL correctly */
+	printk(KERN_WARNING "%s: Rx descriptor error (MALRXDEIR=%lx)\n",
+	       "MAL", deir);
+
+
+	/*
+	 * Protect against ppc405_eth_rxeob modifying these same
+	 * structures.  If an rxde interrupt occurs the hardware will
+	 * have disabled that EMAC, but since there may be multiple
+	 * EMACs on the same MAL another rxeob interrupt could occur
+	 * for another EMAC prior to ppc405_eth_rxde() re-enabling
+	 * EMACs below.  FIXME: this looks bogus
+	 */
+	disable_irq(BL_MAL_RXEOB);
+
+	list_for_each(l, &mal->commac) {
+		struct mal_commac *mc = list_entry(l, struct mal_commac, list);
+
+		if (deir & mc->rx_chan_mask) {
+			mc->ops->rxde(mc->dev, deir & mc->rx_chan_mask);
+		}
+	}
+
+	enable_irq(BL_MAL_RXEOB);
+	
+	return IRQ_HANDLED;
+}
+
+static int __init init_mal(int n)
+{
+	struct ibm_ocp_mal *mal;
+	int err;
+
+	mal = &mal_table[n];
+
+
+	switch (n) {
+	case 0:
+		mal->dcrbase = DCRN_MAL_BASE;
+		break;
+#ifdef DCRN_MAL1_BASE
+	case 1:
+		mal->dcrbase = DCRN_MAL1_BASE;
+		break;
+#endif
+	default:
+		BUG();
+	}
+	mal->serr_irq = BL_MAL_SERR;
+	mal->txde_irq = BL_MAL_TXDE;
+	mal->txeob_irq = BL_MAL_TXEOB;
+	mal->rxde_irq = BL_MAL_RXDE;
+	mal->rxeob_irq = BL_MAL_RXEOB;
+	
+	/* Wrong in general, but the best we have for now: */
+	mal->num_tx_channels = 2*EMAC_NUMS;
+	mal->num_rx_channels = EMAC_NUMS;
+
+	/**************************/
+
+	INIT_LIST_HEAD(&mal->commac);
+
+
+	set_mal_dcrn(mal, DCRN_MALRXCARR, 0xFFFFFFFF);
+	set_mal_dcrn(mal, DCRN_MALTXCARR, 0xFFFFFFFF);
+
+	set_mal_dcrn(mal, DCRN_MALCR, MALCR_MMSR);	/* 384 */
+	/* FIXME: Add delay */
+
+	/* Set the MAL configuration register */
+	set_mal_dcrn(mal, DCRN_MALCR,
+		     MALCR_PLBB | MALCR_OPBBL | MALCR_LEA |
+		     MALCR_PLBLT_DEFAULT);
+
+	/* It would be nice to allocate buffers separately for each
+	 * channel, but we can't because the channels share the upper
+	 * 13 bits of address lines.  Each channels buffer must also
+	 * be 4k aligned, so we allocate 4k for each channel.  This is
+	 * inefficient FIXME: do better, if possible */
+
+	mal->tx_virt_addr = consistent_alloc(GFP_KERNEL,
+					     MAL_DT_ALIGN * mal->num_tx_channels,
+					     &mal->tx_phys_addr);
+
+	/* God, oh, god, I hate DCRs */
+	set_mal_dcrn(mal, DCRN_MALTXCTP0R, mal->tx_phys_addr);
+#ifdef DCRN_MALTXCTP1R
+	set_mal_dcrn(mal, DCRN_MALTXCTP1R, mal->tx_phys_addr + MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP1R */
+#ifdef DCRN_MALTXCTP2R
+	set_mal_dcrn(mal, DCRN_MALTXCTP2R, mal->tx_phys_addr + 2*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP2R */
+#ifdef DCRN_MALTXCTP3R
+	set_mal_dcrn(mal, DCRN_MALTXCTP3R, mal->tx_phys_addr + 3*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP3R */
+#ifdef DCRN_MALTXCTP4R
+	set_mal_dcrn(mal, DCRN_MALTXCTP4R, mal->tx_phys_addr + 4*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP4R */
+#ifdef DCRN_MALTXCTP5R
+	set_mal_dcrn(mal, DCRN_MALTXCTP5R, mal->tx_phys_addr + 5*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP5R */
+#ifdef DCRN_MALTXCTP6R
+	set_mal_dcrn(mal, DCRN_MALTXCTP6R, mal->tx_phys_addr + 6*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP6R */
+#ifdef DCRN_MALTXCTP7R
+	set_mal_dcrn(mal, DCRN_MALTXCTP7R, mal->tx_phys_addr + 7*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP7R */
+
+	mal->rx_virt_addr = consistent_alloc(GFP_KERNEL,
+					     MAL_DT_ALIGN * mal->num_rx_channels,
+					     &mal->rx_phys_addr);
+
+	set_mal_dcrn(mal, DCRN_MALRXCTP0R, mal->rx_phys_addr);
+#ifdef DCRN_MALRXCTP1R
+	set_mal_dcrn(mal, DCRN_MALRXCTP1R, mal->rx_phys_addr + MAL_DT_ALIGN);
+#endif /* DCRN_MALRXCTP1R */
+#ifdef DCRN_MALRXCTP2R
+	set_mal_dcrn(mal, DCRN_MALRXCTP2R, mal->rx_phys_addr + 2*MAL_DT_ALIGN);
+#endif /* DCRN_MALRXCTP2R */
+#ifdef DCRN_MALRXCTP3R
+	set_mal_dcrn(mal, DCRN_MALRXCTP3R, mal->rx_phys_addr + 3*MAL_DT_ALIGN);
+#endif /* DCRN_MALRXCTP3R */
+	
+	err = request_irq(mal->serr_irq, mal_serr, 0 ,"MAL SERR", mal);
+	if (err)
+		goto fail;
+	err = request_irq(mal->txde_irq, mal_txde,0, "MAL TX DE ", mal);
+	if (err)
+		goto fail;
+	err = request_irq(mal->txeob_irq, mal_txeob, 0, "MAL TX EOB", mal);
+	if (err)
+		goto fail;
+	err = request_irq(mal->rxde_irq, mal_rxde, 0, "MAL RX DE", mal);
+	if (err)
+		goto fail;
+	err = request_irq(mal->rxeob_irq, mal_rxeob, 0, "MAL RX EOB", mal);
+	if (err)
+		goto fail;
+
+	set_mal_dcrn(mal, DCRN_MALIER,
+		     MALIER_DE | MALIER_NE | MALIER_TE |
+		     MALIER_OPBE | MALIER_PLBE);
+
+	return 0;
+
+ fail:
+	exit_mal(mal);
+	return err;
+}
+
+static void __exit exit_mal(struct ibm_ocp_mal *mal)
+{
+	/* FIXME: shut down the MAL */
+	free_irq(mal->serr_irq, mal);
+	free_irq(mal->txde_irq, mal);
+	free_irq(mal->txeob_irq, mal);
+	free_irq(mal->rxde_irq, mal);
+	free_irq(mal->rxeob_irq, mal);
+	
+	if (mal->tx_virt_addr)
+		consistent_free(mal->tx_virt_addr);
+	if (mal->rx_virt_addr)
+		consistent_free(mal->rx_virt_addr);
+
+	memset(mal, 0, sizeof(*mal));
+}
+
+static int __init init_mals(void)
+{
+	int i;
+	int err;
+
+	printk(KERN_DEBUG "init_mals()\n");
+
+	for (i = 0; i < NUM_MALS; i++) {
+		err = init_mal(i);
+		if (err)
+			return err; /* FIXME: cleanup initalized MALs */
+	}
+
+	return 0;
+}
+
+static void __exit exit_mals(void)
+{
+	int i;
+
+	for (i = 0; i < NUM_MALS; i++)
+		exit_mal(&mal_table[i]);
+}
+
+module_init(init_mals);
+module_exit(exit_mals);
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.h linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.h
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.h	2003-01-16 03:37:15.000000000 +0100
@@ -0,0 +1,145 @@
+/*
+ * 06/02/02 -Armin
+ *    added new mal functions and defines from ibm_ocp_enet.h
+ */
+
+#ifndef _IBM_OCP_MAL_H
+#define _IBM_OCP_MAL_H
+
+#include <linux/list.h>
+
+#define MAL_DT_ALIGN	(4096)	/* Alignment for each channel's descriptor table */
+
+#define MAL_CHAN_MASK(chan)	(0x80000000 >> (chan))
+
+/* MAL Buffer Descriptor structure */
+struct mal_descriptor {
+	volatile unsigned short ctrl;	/* MAL / Commac status control bits */
+	volatile short data_len;	/* Max length is 4K-1 (12 bits)     */
+	unsigned char *data_ptr;	/* pointer to actual data buffer    */
+} __attribute__((packed));
+
+/* the following defines are for the MadMAL status and control registers. */
+/* MADMAL transmit and receive status/control bits  */
+#define MAL_RX_CTRL_EMPTY		0x8000
+#define MAL_RX_CTRL_WRAP		0x4000
+#define MAL_RX_CTRL_CM			0x2000
+#define MAL_RX_CTRL_LAST		0x1000
+#define MAL_RX_CTRL_FIRST		0x0800
+#define MAL_RX_CTRL_INTR		0x0400
+
+#define MAL_TX_CTRL_READY		0x8000
+#define MAL_TX_CTRL_WRAP		0x4000
+#define MAL_TX_CTRL_CM			0x2000
+#define MAL_TX_CTRL_LAST		0x1000
+#define MAL_TX_CTRL_INTR		0x0400
+
+struct mal_commac_ops {
+	void (*txeob)(void *dev, u32 chanmask);
+	void (*txde)(void *dev, u32 chanmask);
+	void (*rxeob)(void *dev, u32 chanmask);
+	void (*rxde)(void *dev, u32 chanmask);
+};
+
+struct mal_commac {
+	struct mal_commac_ops *ops;
+	void *dev;
+	u32 tx_chan_mask, rx_chan_mask;
+	struct list_head list;
+};
+
+/* FIXME: Work this out better */
+#define MAL_MAX_TX_CHANNELS	(EMAC_NUMS*2)
+#define MAL_MAX_RX_CHANNELS	(EMAC_NUMS)
+
+struct ibm_ocp_mal {
+	int dcrbase;
+	int serr_irq, txeob_irq, txde_irq, rxeob_irq, rxde_irq;
+
+	struct list_head commac;
+	u32 tx_chan_mask, rx_chan_mask;
+
+	int num_tx_channels;
+	dma_addr_t tx_phys_addr;
+	struct mal_descriptor *tx_virt_addr;
+
+	int num_rx_channels;
+	dma_addr_t rx_phys_addr;
+	struct mal_descriptor *rx_virt_addr;
+};
+
+#ifdef DCRN_MAL1_BASE
+#define NUM_MALS	2
+#else
+#define	NUM_MALS	1
+#endif
+
+extern struct ibm_ocp_mal mal_table[NUM_MALS];
+
+#define GET_MAL_STANZA(base,dcrn) \
+	case base: \
+		x = mfdcr(dcrn(base)); \
+		break;
+
+#define SET_MAL_STANZA(base,dcrn, val) \
+	case base: \
+		mtdcr(dcrn(base), (val)); \
+		break;
+
+#define GET_MAL0_STANZA(dcrn) GET_MAL_STANZA(DCRN_MAL_BASE,dcrn)
+#define SET_MAL0_STANZA(dcrn,val) SET_MAL_STANZA(DCRN_MAL_BASE,dcrn,val)
+
+#ifdef DCRN_MAL1_BASE
+#define GET_MAL1_STANZA(dcrn) GET_MAL_STANZA(DCRN_MAL1_BASE,dcrn)
+#define SET_MAL1_STANZA(dcrn,val) SET_MAL_STANZA(DCRN_MAL1_BASE,dcrn,val)
+#else /* ! DCRN_MAL1_BASE */
+#define GET_MAL1_STANZA(dcrn) 
+#define SET_MAL1_STANZA(dcrn,val)
+#endif
+
+
+#define get_mal_dcrn(mal, dcrn) ({ \
+	u32 x; \
+	switch ((mal)->dcrbase) { \
+		GET_MAL0_STANZA(dcrn) \
+		GET_MAL1_STANZA(dcrn) \
+	default: \
+		BUG(); \
+	} \
+x; })
+
+#define set_mal_dcrn(mal, dcrn, val) do { \
+	switch ((mal)->dcrbase) { \
+		SET_MAL0_STANZA(dcrn,val) \
+		SET_MAL1_STANZA(dcrn,val) \
+	default: \
+		BUG(); \
+	} } while (0)
+
+
+static inline void mal_enable_tx_channels(struct ibm_ocp_mal *mal, u32 chanmask)
+{
+	set_mal_dcrn(mal, DCRN_MALTXCASR,
+		     get_mal_dcrn(mal, DCRN_MALTXCASR) | chanmask);
+}
+
+static inline void mal_disable_tx_channels(struct ibm_ocp_mal *mal, u32 chanmask)
+{
+	set_mal_dcrn(mal, DCRN_MALTXCARR, chanmask);
+}
+
+static inline void mal_enable_rx_channels(struct ibm_ocp_mal *mal, u32 chanmask)
+{
+	set_mal_dcrn(mal, DCRN_MALRXCASR,
+		     get_mal_dcrn(mal, DCRN_MALRXCASR) | chanmask);
+}
+
+static inline void mal_disable_rx_channels(struct ibm_ocp_mal *mal, u32 chanmask)
+{
+	set_mal_dcrn(mal, DCRN_MALRXCARR, chanmask);
+}
+
+extern int mal_register_commac(struct ibm_ocp_mal *mal, struct mal_commac *commac);
+extern int mal_set_rcbs(struct ibm_ocp_mal *mal, int channel, unsigned long size);
+
+#endif /* _IBM_OCP_MAL_H */
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.c linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.c
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.c	2002-11-11 22:59:05.000000000 +0100
@@ -0,0 +1,1054 @@
+/*
+ * ibm_ocp_phy.c
+ *
+ * Ethernet PHY routines and database for IBM 4xx PowerPC processors.
+ *
+ * Based on  the Fast Ethernet Controller (FEC) driver for
+ * Motorola MPC8xx and other contributions, see driver for contributers.
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Sept, 2001
+ *
+ * Copyright 2000 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * TODO: mii queue process
+ *
+ * Version 1.0 (01/09/28) by Armin kuster
+ *	added find_phy to auto discover phy adder
+ *	and phy type.
+ * Version 1.1 (01/10/05) Armin Kuster
+ *	Use dev->base_addr for EMAC reg addr
+ *
+ * Version 1.2 (01/10/17) Armin
+ *      removed unused emac from process_mii_queue & mii_enet_mii
+ *      switch 10HD w/ 100FD in  mii_parse_dp83843_pcr via Dimitrios Michailidiss
+ *      general clean-up
+ *      added proccess_mii_queue & mii_queue_schedule
+ *      added support for National DP83846A PHY
+ *
+ * Vesrion: 1.3 (01/11/13) Armin
+ * 	fixed mii_parse_dp83843_pcr, decode 100FDX & 10HDX wrong./
+ *
+ * Version: 1.4 (01/12/26) Armin & Kim Young-Han
+ * 		added BCM5221 phy support, Kim
+ * 		added Am79C875 phy support, armin
+ * Version: 1.5 (02/05/02) Armin
+ * 		Name change
+ * Version: 1.6 (02/12/02) Andrew, David, Stefan
+ * 		fixed find_phy
+ * Version: 1.7 (03/01/02) Andrew May
+ * 		Improved find_phy
+ * 		added Am79C874
+ * Version: 1.8 (03/25/02) Andrew May 
+ *		Fix bad Partner Link check for the Am79C874 phy
+ *
+ * Version: 1.9 (04/04/02) Matt Porter
+ * 		Added Am79C875A phy support
+ * 		Message cleanup
+ * Version: 2.0 (04/15/02) Todd Poynor
+ * 	redid ANLPAR parser for Am79c875* to select proper speed
+ *
+ * Version: 2.0 (04/18/02) - Armin
+ * 	shifted  Am79c865 id by 4 and changed shift to 4 (Ash suppport)
+ *
+ * Version: 2.1 (04/25/02) - Armin
+ *  	using zmii_phyid_adj() to adjust phy addrs on those cpus
+ *  	that use a zmii bridge
+ *  	fixed find_phy for zmii bridge support
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/netdevice.h>
+
+#include <asm/processor.h>	/* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+
+#include "ibm_ocp_enet.h"
+static int next_phy_available = MIN_PHY_ADDR;
+
+/* Forward declarations of some structures to support different PHYs */
+
+/* Interrupt events/masks. */
+#define FEC_ENET_HBERR	((uint)0x80000000)	/* Heartbeat error */
+#define FEC_ENET_BABR	((uint)0x40000000)	/* Babbling receiver */
+#define FEC_ENET_BABT	((uint)0x20000000)	/* Babbling transmitter */
+#define FEC_ENET_GRA	((uint)0x10000000)	/* Graceful stop complete */
+#define FEC_ENET_TXF	((uint)0x08000000)	/* Full frame transmitted */
+#define FEC_ENET_TXB	((uint)0x04000000)	/* A buffer was transmitted */
+#define FEC_ENET_RXF	((uint)0x02000000)	/* Full frame received */
+#define FEC_ENET_RXB	((uint)0x01000000)	/* A buffer was received */
+#define FEC_ENET_MII	((uint)0x00800000)	/* MII interrupt */
+#define FEC_ENET_EBERR	((uint)0x00400000)	/* SDMA bus error */
+
+#define FEC_ECNTRL_PINMUX	0x00000004
+#define FEC_ECNTRL_ETHER_EN	0x00000002
+#define FEC_ECNTRL_RESET	0x00000001
+
+#define FEC_RCNTRL_BC_REJ	0x00000010
+#define FEC_RCNTRL_PROM		0x00000008
+#define FEC_RCNTRL_MII_MODE	0x00000004
+#define FEC_RCNTRL_DRT		0x00000002
+#define FEC_RCNTRL_LOOP		0x00000001
+
+#define FEC_TCNTRL_FDEN		0x00000004
+#define FEC_TCNTRL_HBC		0x00000002
+#define FEC_TCNTRL_GTS		0x00000001
+
+void ocp_enet_mii(struct net_device *dev);
+extern int ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value);
+extern int ocp_enet_mdio_write(struct net_device *dev, int reg);
+
+/* Make MII read/write commands for the OCP. */
+
+/* MII processing.  We keep this as simple as possible.  Requests are
+ * placed on the list (if there is room).  When the request is finished
+ * by the MII, an optional function may be called.
+ */
+static int mii_queue(struct net_device *dev, int request,
+		     void (*func) (uint, struct net_device *));
+
+/* Register definitions for the PHY. */
+
+#define MII_REG_CR		0	/* Control Register */
+#define MII_REG_SR		1	/* Status Register */
+#define MII_REG_PHYIR1		2	/* PHY Identification Register 1 */
+#define MII_REG_PHYIR2		3	/* PHY Identification Register 2 */
+#define MII_REG_ANAR		4	/* A-N Advertisement Register */
+#define MII_REG_ANLPAR		5	/* A-N Link Partner Ability Register */
+#define MII_REG_ANER		6	/* A-N Expansion Register */
+#define MII_REG_ANNPTR		7	/* A-N Next Page Transmit Register */
+#define MII_REG_ANLPRNPR	8	/* A-N Link Partner Received Next Page Reg. */
+
+/* values for phy_status */
+
+#define PHY_CONF_ANE		0x0001	/* 1 auto-negotiation enabled */
+#define PHY_CONF_LOOP		0x0002	/* 1 loopback mode enabled */
+#define PHY_CONF_SPMASK		0x01E0	/* mask for speed */
+#define PHY_CONF_10HDX		0x0010	/* 10 Mbit half duplex supported */
+#define PHY_CONF_10FDX		0x0020	/* 10 Mbit full duplex supported */
+#define PHY_CONF_100HDX		0x0040	/* 100 Mbit half duplex supported */
+#define PHY_CONF_100FDX		0x0080	/* 100 Mbit full duplex supported */
+
+#define PHY_STAT_LINK		0x0100	/* 1 up - 0 down */
+#define PHY_STAT_FAULT		0x0200	/* 1 remote fault */
+#define PHY_STAT_ANC		0x0400	/* 1 auto-negotiation complete */
+#define PHY_STAT_SPMASK		0xf000	/* mask for speed */
+#define PHY_STAT_10HDX		0x1000	/* 10 Mbit half duplex selected */
+#define PHY_STAT_10FDX		0x2000	/* 10 Mbit full duplex selected */
+#define PHY_STAT_100HDX		0x4000	/* 100 Mbit half duplex selected */
+#define PHY_STAT_100FDX		0x8000	/* 100 Mbit full duplex selected */
+
+mii_list_t *mii_free;
+mii_list_t *mii_head;
+mii_list_t *mii_tail;
+
+/* mii routines */
+
+/* 	Manually process all queued commands */
+
+void
+process_mii_queue(struct net_device *dev)
+{
+	mii_list_t *mip;
+	uint mii_reg = 0;
+
+	while ((mip = mii_head) != NULL) {
+
+		if (mip->mii_func != NULL) {
+			ocp_enet_mdio_read(dev, mip->mii_regval, &mii_reg);
+			(*(mip->mii_func)) (mii_reg, dev);
+		} else {
+			if (mip->mii_regval & EMAC_STACR_READ)
+				ocp_enet_mdio_read(dev, mip->mii_regval,
+						   &mii_reg);
+			else
+				ocp_enet_mdio_write(dev, mip->mii_regval);
+		}
+
+		mii_head = mip->mii_next;
+		mip->mii_next = mii_free;
+		mii_free = mip;
+	}
+}
+
+static int
+mii_queue(struct net_device *dev, int regval,
+	  void (*func) (uint, struct net_device *))
+{
+	unsigned long flags;
+	mii_list_t *mip;
+	int retval;
+
+	retval = 0;
+	save_flags(flags);
+	cli();
+
+	if ((mip = mii_free) != NULL) {
+		mii_free = mip->mii_next;
+		mip->mii_regval = regval;
+		mip->mii_func = func;
+		mip->mii_next = NULL;
+		if (mii_head) {
+			mii_tail->mii_next = mip;
+			mii_tail = mip;
+		} else {
+			mii_head = mii_tail = mip;
+		}
+	} else
+		retval = 1;
+
+	restore_flags(flags);
+
+	return retval;
+}
+
+void
+mii_do_cmd(struct net_device *dev, const phy_cmd_t * c)
+{
+	int k;
+
+	if (!c)
+		return;
+
+	for (k = 0; (c + k)->mii_data != mk_mii_end; k++)
+		mii_queue(dev, (c + k)->mii_data, (c + k)->funct);
+}
+
+static void
+mii_parse_sr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_LINK | PHY_STAT_FAULT | PHY_STAT_ANC);
+
+	if (mii_reg & 0x0004)
+		*s |= PHY_STAT_LINK;
+	if (mii_reg & 0x0010)
+		*s |= PHY_STAT_FAULT;
+	if (mii_reg & 0x0020)
+		*s |= PHY_STAT_ANC;
+}
+
+static void
+mii_parse_cr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_CONF_ANE | PHY_CONF_LOOP);
+
+	if (mii_reg & 0x1000)
+		*s |= PHY_CONF_ANE;
+	if (mii_reg & 0x4000)
+		*s |= PHY_CONF_LOOP;
+}
+
+static void
+mii_parse_anar(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	if (mii_reg & 0x0020)
+		*s |= PHY_CONF_10HDX;
+	if (mii_reg & 0x0040)
+		*s |= PHY_CONF_10FDX;
+	if (mii_reg & 0x0080)
+		*s |= PHY_CONF_100HDX;
+	if (mii_reg & 0x00100)
+		*s |= PHY_CONF_100FDX;
+
+}
+
+/* ------------------------------------------------------------------------- */
+/* The National Semiconductor DP83843  is used on the IBM Walnut	     */
+
+/* register definitions */
+
+#define MII_DP83843_PHYSTS	0x10	/* Phy Status Register */
+#define MII_DP83843_MIPSCR	0x11	/* MII int PHY spec. Register */
+#define MII_DP83843_MIPGSR	0x12	/* MII int generic status Register */
+#define MII_DP83843_DCR		0x13	/* Disconnect Counter Register */
+#define MII_DP83843_FCSCR	0x14	/* False Carrier Sense Register */
+#define MII_DP83843_RECS	0x15	/* Receive counter Reg. */
+#define MII_DP83843_PCSR	0x16	/* PCS Sub-layer Config & status Reg. */
+#define MII_DP83843_LBR		0x17	/* Loopback & bypass Reg. */
+#define MII_DP83843_10BTSCR	0x18	/* 10BASE-T status & cntl Reg. */
+#define MII_DP83843_PHYCTRL	0x19	/* PHY cntl Reg. */
+
+static void
+mii_parse_dp83843_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch ((mii_reg >> 1) & 3) {
+	case 0:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 1:
+		*s |= PHY_STAT_10HDX;
+		break;
+	case 2:
+		*s |= PHY_STAT_100FDX;
+		break;
+	case 3:
+		*s |= PHY_STAT_10FDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_dp83843 = {
+	0x20005c10,
+	"DP83843",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_DP83843_MIPSCR, 0x0001), NULL},
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     /* we need to read ISR, SR and ANER to acknowledge */
+
+			     {mk_mii_read(MII_DP83843_MIPGSR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+
+			     /* read pcr to get info */
+
+			     {mk_mii_read(MII_DP83843_PHYSTS),
+			      mii_parse_dp83843_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_DP83843_MIPSCR, 0x0000), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The Intel LXT971A is used on the esd CPCI-405 and EP 405 */
+
+/* register definitions */
+
+#define MII_LXT971A_SR2		17	/* PHY status Register #2 */
+#define MII_LXT971A_IER		18	/* PHY interrupt enable Register */
+#define MII_LXT971A_ISR		19	/* PHY interrupt status Register */
+
+static void
+mii_parse_lxt971a_sr2(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch (mii_reg & 0x4200) {
+	case 0x4200:
+		*s |= PHY_STAT_100FDX;
+		break;
+	case 0x4000:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 0x0200:
+		*s |= PHY_STAT_10FDX;
+		break;
+	case 0x0000:
+		*s |= PHY_STAT_10HDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_lxt971a = {
+	0x0001378e,
+	"LXT971A",
+	4,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_LXT971A_IER, 0x00f2), NULL},	/* enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     /* we need to read ISR, SR and ANAR to acknowledge */
+
+			     {mk_mii_read(MII_LXT971A_ISR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+
+			     /* read sr2 to get info */
+
+			     {mk_mii_read(MII_LXT971A_SR2),
+			      mii_parse_lxt971a_sr2},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_LXT971A_IER, 0x0000), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The Cirrus Logic CS8952 (CrystalLAN) is used on the MPL PIP405	     */
+
+/* register definitions */
+
+#define MII_CS8952_IMR		0x10	/* Interrupt Mask Reg. */
+#define MII_CS8952_ISR		0x11	/* Interrupt Status Reg. */
+#define MII_CS8952_DCR		0x12	/* Disconnect Counter Reg. */
+#define MII_CS8952_FCSCR	0x13	/* False Carrier Counter Reg. */
+#define MII_CS8952_SKIR		0x14	/* Scrambler Key Init Reg. */
+#define MII_CS8952_RECR		0x15	/* Receive Error Counter Reg. */
+#define MII_CS8952_DKIR		0x16	/* Descrambler Key Init Register */
+#define MII_CS8952_PCSR		0x17	/* PCS Sub-layer Config & status Reg. */
+#define MII_CS8952_LBR		0x18	/* Loopback & bypass Reg. */
+#define MII_CS8952_SSR		0x19	/* Self Status Reg. */
+#define MII_CS8952_10BTSR	0x1B	/* 10BASE-T Status Reg. */
+#define MII_CS8952_10BTCR	0x1C	/* 10BASE-T Control Reg. */
+
+static void
+mii_parse_cs8952_ssr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch ((mii_reg >> 6) & 3) {
+	case 0:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 1:
+		*s |= PHY_STAT_10HDX;
+		break;
+	case 2:
+		*s |= PHY_STAT_100FDX;
+		break;
+	case 3:
+		*s |= PHY_STAT_10FDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_cs8952 = {
+	0x001a2205,
+	"CS8952",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+			     /* parse cr and anar to get some info */
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_CS8952_IMR, 0xFFFE), NULL},
+			     /* auto-negotiate */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+			     /* we need to read ISR, SR and ANER to acknowledge */
+			     {mk_mii_read(MII_CS8952_ISR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     /* read ssr to get more info */
+			     {mk_mii_read(MII_CS8952_SSR),
+			      mii_parse_cs8952_ssr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_CS8952_IMR, 0x0000), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The National Semiconductor DP83846A 	*/
+
+/* register definitions */
+
+#define MII_DP83846A_PHYSTS	0x10	/* Phy Status Register */
+#define MII_DP83846A_FCSCR	0x14	/* False Carrier Sense Register */
+#define MII_DP83846A_RECS	0x15	/* Receive Error Counter Reg. */
+#define MII_DP83846A_PCSR	0x16	/* PCS Sub-layer Config/status Reg. */
+#define MII_DP83846A_PHYCTRL	0x19	/* PHY cntl Reg. */
+
+static void
+mii_parse_dp83846A_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch ((mii_reg >> 1) & 3) {
+	case 0:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 1:
+		*s |= PHY_STAT_10HDX;
+		break;
+	case 2:
+		*s |= PHY_STAT_100FDX;
+		break;
+	case 3:
+		*s |= PHY_STAT_10FDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_dp83846A = {
+	0x20005c23,
+	"DP83846A",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+			     /* 83846A doesn't have interrupts but ack_int is also used to
+			        get initial status so here it goes. */
+
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+
+			     /* read pcr to get info */
+
+			     {mk_mii_read(MII_DP83846A_PHYSTS),
+			      mii_parse_dp83846A_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - nothing */
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The Lucent Technologies LU3X31FT */
+
+/* register definitions */
+
+#define MII_LU3X31FT_PHYCTRLSTS	0x17	/* PHY Control/Status Register */
+#define MII_LU3X31FT_IER	0x1D	/* PHY interrupt enable Register */
+#define MII_LU3X31FT_ISR	0x1E	/* PHY interrupt status Register */
+
+static void
+mii_parse_lu3x31ft_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch ((mii_reg >> 8) & 3) {
+	case 0:
+		*s |= PHY_STAT_10HDX;
+		break;
+	case 1:
+		*s |= PHY_STAT_10FDX;
+		break;
+	case 2:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 3:
+		*s |= PHY_STAT_100FDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_lu3x31ft = {
+	0x90307421,
+	"LU3X31FT",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {
+			     /* startup - enable interrupts */
+			     {mk_mii_write(MII_LU3X31FT_IER, 0x0000), NULL},
+			     /* autonegotiate */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     /* we need to read ISR, SR and ANER to acknowledge */
+			     {mk_mii_read(MII_LU3X31FT_ISR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+
+			     /* read pcr to get info */
+			     {mk_mii_read(MII_LU3X31FT_PHYCTRLSTS),
+			      mii_parse_lu3x31ft_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_LU3X31FT_IER, 0xff80), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The AMD Am79C875 */
+
+/* register definitions */
+
+#define MII_AM79C875_MFR	0x10	/* Mics. Feature Register */
+#define MII_AM79C875_ICR	0x11	/* Interrupt Cntl/Status Register */
+#define MII_AM79C875_DIAG	0x18	/* Diag Reg. */
+#define MII_AM79C875_TEST	0x13	/* Test Reg. */
+#define MII_AM79C875_MFR2	0x14	/* Mics. Feature 2 Register */
+#define MII_AM79C875_RCR	0x15	/* Recv. Error counter */
+#define MII_AM79C875_MCR	0x18	/* Mode contl reg */
+
+static void
+mii_parse_Am79C875_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_CONF_SPMASK);
+
+	if (mii_reg & 0x0100) {
+		*s |= PHY_STAT_100FDX;
+	} else if (mii_reg & 0x0080) {
+		*s |= PHY_STAT_100HDX;
+	} else if (mii_reg & 0x0040) {
+		*s |= PHY_STAT_10FDX;
+	} else if (mii_reg & 0x0020) {
+		*s |= PHY_STAT_10HDX;
+	} else {
+		*s |= PHY_STAT_10HDX;
+	}
+}
+
+static phy_info_t phy_info_Am79C875 = {
+	/*0x00137886,*/
+	0x00013788,
+	"Am79c875",
+	4,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_AUTON), NULL},	/* Auto neg. on */
+//              { mk_mii_write(MII_AM79C875_MFR, 0x4000), NULL}, /* int 1 to signle interrupt */
+//              { mk_mii_write(MII_AM79C875_ICR, 0x00ff), NULL }, /* enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     {mk_mii_read(MII_AM79C875_ICR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_read(MII_REG_ANLPAR),
+			      mii_parse_Am79C875_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - nothing */
+			     {mk_mii_end,}
+			     },
+};
+
+static phy_info_t phy_info_Am79C875A = {
+	0x00225541,
+	"Am79c875A",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_AUTON), NULL},	/* Auto neg. on */
+//              { mk_mii_write(MII_AM79C875_MFR, 0x4000), NULL}, /* int 1 to signle interrupt */
+//              { mk_mii_write(MII_AM79C875_ICR, 0x00ff), NULL }, /* enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_read(MII_REG_ANLPAR),
+			      mii_parse_Am79C875_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     {mk_mii_read(MII_AM79C875_ICR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_read(MII_REG_ANLPAR),
+			      mii_parse_Am79C875_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - nothing */
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The Broadcom BCM5221 */
+
+/* register definitions */
+
+#define MII_BCM5221_IER 0x1a
+#define MII_BCM5221_ISR 0x1a
+#define MII_BCM5221_SR  0x19
+#define MII_BCM5221_CSR 0x18
+
+void
+mii_parse_bcm5221_sr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_LINK | PHY_STAT_FAULT | PHY_STAT_ANC);
+
+	if (mii_reg & 0x0004)
+		*s |= PHY_STAT_LINK;
+	if (mii_reg & 0x0040)
+		*s |= PHY_STAT_FAULT;
+	if (mii_reg & 0x8000)
+		*s |= PHY_STAT_ANC;
+}
+
+void
+mii_parse_bcm5221_csr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	if (mii_reg & 0x0002) {
+		if (mii_reg & 0x0001)
+			*s |= PHY_STAT_100FDX;
+		else
+			*s |= PHY_STAT_100HDX;
+	} else {
+		if (mii_reg & 0x0001)
+			*s |= PHY_STAT_10FDX;
+		else
+			*s |= PHY_STAT_10HDX;
+	}
+}
+
+static phy_info_t phy_info_bcm5221 = {
+	0x0004061e,
+	"BCM5221",
+	4,
+	(const phy_cmd_t[]) {	/* config */
+			     {mk_mii_write(MII_REG_CR, 0x8000), NULL},	/* reset */
+			     {mk_mii_read(MII_BCM5221_SR), NULL},
+			     {mk_mii_read(MII_BCM5221_ISR), NULL},
+			     {mk_mii_read(MII_BCM5221_CSR), NULL},
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_read(MII_BCM5221_SR), NULL},
+			     {mk_mii_read(MII_BCM5221_ISR), NULL},
+			     {mk_mii_read(MII_BCM5221_CSR), NULL},
+
+#if 0
+			     {mk_mii_write(MII_BCM5221_IER, 0x4000), NULL},
+#endif
+			     {mk_mii_write(MII_REG_CR, 0x1200), NULL},	/*
+									   autonegotiate */
+			     {mk_mii_read(MII_BCM5221_SR),
+			      mii_parse_bcm5221_sr},
+			     {mk_mii_read(MII_BCM5221_SR),
+			      mii_parse_bcm5221_sr},
+			     {mk_mii_read(MII_BCM5221_CSR),
+			      mii_parse_bcm5221_csr},
+
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+			     /* read SR and ISR to acknowledge */
+			     {mk_mii_read(MII_BCM5221_SR),
+			      mii_parse_bcm5221_sr},
+			     {mk_mii_read(MII_BCM5221_SR),
+			      mii_parse_bcm5221_sr},
+			     {mk_mii_read(MII_BCM5221_ISR), NULL},
+			     /* find out the current status */
+			     {mk_mii_read(MII_BCM5221_CSR),
+			      mii_parse_bcm5221_csr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_BCM5221_IER, 0x0000), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The AMD Am79C874 NetPHY-1LP same as AC101                                 */
+/* This is a hackish copy of the 75 right now. It works for now.             */
+/* It has 100FX support that I have not been able to add/test yet            */
+/*                                                                Andrew May */
+/* Using the same register definitions same as Am79c875*/
+
+static void
+mii_parse_Am79C874_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_CONF_SPMASK);
+	mii_reg = mii_reg >> 5;
+	if (mii_reg & 0x10) {
+		/*100Base-T4 this phy doesn't support this */
+	}
+	/*
+	 * pick the best one since a partner can advertise all
+	 * anyone want 10FD over 100HD ?
+	 */
+	if (mii_reg & 0x08) {
+		*s |= PHY_STAT_100FDX;
+	} else if (mii_reg & 0x04) {
+		*s |= PHY_STAT_100HDX;
+	} else if (mii_reg & 0x02) {
+		*s |= PHY_STAT_10FDX;
+	} else if (mii_reg & 0x01) {
+		*s |= PHY_STAT_10HDX;
+	} else {
+		*s |= PHY_STAT_10HDX;
+	}
+}
+
+static phy_info_t phy_info_Am79C874 = {
+	0x0022561b,
+	"Am79c874",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_AUTON), NULL},	/* Auto neg. on */
+/*{ mk_mii_write(MII_AM79C875_MFR, 0x4000), NULL}, *//* int 1 to signle interrupt */
+/*{ mk_mii_write(MII_AM79C875_ICR, 0x00ff), NULL }, *//* enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     {mk_mii_read(MII_AM79C875_ICR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_read(MII_REG_ANLPAR),
+			      mii_parse_Am79C874_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - nothing */
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+
+static phy_info_t *phy_info[] = {
+
+	&phy_info_dp83843,
+	&phy_info_lxt971a,
+	&phy_info_cs8952,
+	&phy_info_dp83846A,
+	&phy_info_lu3x31ft,
+	&phy_info_Am79C875,
+	&phy_info_bcm5221,
+	&phy_info_Am79C874,
+	&phy_info_Am79C875A,
+	NULL
+};
+
+void
+mii_display_status(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+	fep->phy_speed = _10BASET;
+	fep->phy_duplex = HALF;
+
+	/* Link is still down - don't print anything */
+	if (!fep->link && !fep->old_link)
+		return;
+
+	printk("IBM EMAC: %s: ", dev->name);
+
+	if (!fep->link)
+		printk("link down");
+	else {
+		printk("link up");
+
+		switch (*s & PHY_STAT_SPMASK) {
+		case PHY_STAT_100FDX:
+			printk(", 100 Mbps FDX");
+			fep->phy_speed = _100BASET;
+			fep->phy_duplex = FULL;
+			break;
+		case PHY_STAT_100HDX:
+			printk(", 100 Mbps HDX");
+			fep->phy_speed = _100BASET;
+			break;
+		case PHY_STAT_10FDX:
+			printk(", 10 Mbps FDX");
+			fep->phy_duplex = FULL;
+			break;
+		case PHY_STAT_10HDX:
+			printk(", 10 Mbps HDX");
+			break;
+		default:
+			printk(", Unknown speed/duplex");
+		}
+
+		if (*s & PHY_STAT_ANC)
+			printk(", auto-negotiation complete");
+		printk(".\n");
+	}
+
+	if (*s & PHY_STAT_FAULT)
+		printk(", remote fault.\n");
+}
+
+/*
+ * Check if there is a valid PHY connected at address phnum.
+ */
+static int check_phy(struct net_device *dev, int phnum)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	uint phy_reg;
+	int i;
+
+	fep->phy_addr = phnum;
+	if (ocp_enet_mdio_read(dev, mk_mii_read(MII_REG_PHYIR1), &phy_reg))
+		return 0;
+
+	ppc405_phy_dump(dev);
+
+	/* Got 2nd part of ID, now get remainder. */
+	fep->phy_id = (phy_reg & 0xffff) << 16;
+
+	if (ocp_enet_mdio_read(dev, mk_mii_read(MII_REG_PHYIR2), &phy_reg)) {
+		if (phnum == MIN_PHY_ADDR)
+			printk(KERN_ERR "%s: Got bad Phy Read, missing MDIO pullup?\n",
+			       dev->name);
+		return 0;
+	}
+
+	fep->phy_id |= (phy_reg & 0xffff);
+
+	for (i = 0; phy_info[i]; i++)
+		if (phy_info[i]->id == (fep->phy_id >> phy_info[i]->shift))
+			break;
+	if (!phy_info[i]) {
+		printk(KERN_ERR "%s: PHY id 0x%08x is not supported!\n",
+		       dev->name, fep->phy_id);
+		return 0;
+	}
+
+	fep->phy = phy_info[i];
+
+	printk("IBM EMAC: %s: Phy @ 0x%x, type %s (0x%08x)\n",
+	       dev->name, fep->phy_addr, fep->phy->name, fep->phy_id);
+	return 1;
+}
+
+/* Scan all valid PHY addresses looking for someone to respond
+ * with a valid ID.  This usually happens quickly. This eliminated
+ * the need to pass in the addr & PHY name
+ */
+void
+find_phy(struct net_device *dev)
+{
+	int i;
+
+	for (i = next_phy_available; i <= MAX_PHY_ADDR; i++)
+		if (check_phy(dev, i)){
+			next_phy_available = i + 1;
+			return;
+		}
+	printk("%s: No PHY device found.\n", dev->name);
+}
+/*	this decreaments the next_phy_available 
+ *	This is a temp work arround
+ *	armin
+ */
+int
+free_phy(struct net_device *dev)
+{
+	if (next_phy_available-- == MIN_PHY_ADDR)
+		next_phy_available =  MIN_PHY_ADDR;
+	return(next_phy_available);
+
+}
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.h linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.h
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.h	2002-09-20 09:16:31.000000000 +0200
@@ -0,0 +1,156 @@
+
+/*
+ * ibm_ocp_phy.h
+ *
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      June, 2002
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Version: 1.0: armin
+ *  moved phy defines out of enet.h
+ *
+ */
+
+#ifndef _IBM_OCP_PHY_H_
+#define _IBM_OCP_PHY_H_
+
+#define mk_mii_end			0
+
+typedef struct mii_list {
+	uint mii_regval;
+	void (*mii_func) (uint val, struct net_device * dev);
+	struct mii_list *mii_next;
+} mii_list_t;
+
+typedef struct {
+	uint mii_data;
+	void (*funct) (uint mii_reg, struct net_device * dev);
+} phy_cmd_t;
+
+typedef struct {
+	uint id;
+	char *name;
+	uint shift;
+	const phy_cmd_t *config;
+	const phy_cmd_t *startup;
+	const phy_cmd_t *ack_int;
+	const phy_cmd_t *shutdown;
+} phy_info_t;
+
+extern void process_mii_queue(struct net_device *dev);
+extern void mii_do_cmd(struct net_device *dev, const phy_cmd_t * c);
+extern void mii_display_status(struct net_device *dev);
+extern void find_phy(struct net_device *dev);
+extern int free_phy(struct net_device *dev);
+extern mii_list_t *mii_free;
+extern mii_list_t *mii_nead;
+extern mii_list_t *mii_tail;
+
+/* phy register offsets */
+#define PHY_BMCR			0x00
+#define PHY_BMS				0x01
+#define PHY_PHY1DR1			0x02
+#define PHY_PHYIDR2			0x03
+#define PHY_ANAR			0x04
+#define PHY_ANLPAR			0x05
+#define PHY_ANER			0x06
+#define PHY_ANNPTR			0x07
+#define PHY_PHYSTS			0x10
+#define PHY_MIPSCR			0x11
+#define PHY_MIPGSR			0x12
+#define PHY_DCR				0x13
+#define PHY_FCSCR			0x14
+#define PHY_RECR			0x15
+#define PHY_PCSR			0x16
+#define PHY_LBR				0x17
+#define PHY_10BTSCR			0x18
+#define PHY_PHYCTRL			0x19
+
+/* PHY BMCR */
+#define PHY_BMCR_RESET			0x8000
+#define PHY_BMCR_LOOP			0x4000
+#define PHY_BMCR_100MB			0x2000
+#define PHY_BMCR_AUTON			0x1000
+#define PHY_BMCR_POWD			0x0800
+#define PHY_BMCR_ISO			0x0400
+#define PHY_BMCR_RST_NEG		0x0200
+#define PHY_BMCR_DPLX			0x0100
+#define PHY_BMCR_COL_TST		0x0080
+
+/* phy BMSR */
+#define PHY_BMSR_100T4			0x8000
+#define PHY_BMSR_100TXF			0x4000
+#define PHY_BMSR_100TXH			0x2000
+#define PHY_BMSR_10TF			0x1000
+#define PHY_BMSR_10TH			0x0800
+#define PHY_BMSR_PRE_SUP		0x0040
+#define PHY_BMSR_AUTN_COMP		0x0020
+#define PHY_BMSR_RF			0x0010
+#define PHY_BMSR_AUTN_ABLE		0x0008
+#define PHY_BMSR_LS			0x0004
+#define PHY_BMSR_JD			0x0002
+#define PHY_BMSR_EXT			0x0001
+
+/* phy ANAR */
+#define PHY_ANAR_NP			0x8000	/* Next page indication */
+#define PHY_ANAR_RF			0x2000	/* Remote Fault */
+#define PHY_ANAR_FDFC			0x0400	/* Full Duplex control */
+#define PHY_ANAR_T4			0x0200	/* 100BASE-T4 supported */
+#define PHY_ANAR_TX_FD			0x0100	/* 100BASE-TX Full duplex supported */
+#define PHY_ANAR_TX			0x0080	/* 100BASE-TX supported */
+#define PHY_ANAR_10_FD			0x0040	/* 10BASE-T Full duplex supported */
+#define PHY_ANAR_10			0x0020	/* 10BASE-T Supported */
+#define PHY_ANAR_SEL			0x0010	/* Protocol selection bits  */
+
+/* phy ANLPAR */
+#define PHY_ANLPAR_NP			0x8000
+#define PHY_ANLPAR_ACK			0x4000
+#define PHY_ANLPAR_RF			0x2000
+#define PHY_ANLPAR_T4			0x0200
+#define PHY_ANLPAR_TXFD			0x0100
+#define PHY_ANLPAR_TX			0x0080
+#define PHY_ANLPAR_10FD			0x0040
+#define PHY_ANLPAR_10			0x0020
+#define PHY_ANLPAR_100			0x0380	/* we can run at 100 */
+
+/* phy status PHYSTS */
+
+#define PHY_PHYSTS_RLE			0x8000	/* Receive error latch 1: rx error */
+#define PHY_PHYSTS_CIM			0x4000	/* Carrier Integrity 1: False carrier */
+#define PHY_PHYSTS_FC 			0x2000	/* False carrier 1: false carrier */
+#define PHY_PHYSTS_DR 			0x0800	/* Device ready 1: ready 0: not */
+#define PHY_PHYSTS_PR 			0x0400	/* Page received 1: new page code */
+#define PHY_PHYSTS_AN 			0x0200	/* Auto Negociate Enabled 1: enabled 0: disabled  */
+#define PHY_PHYSTS_MI 			0x0100	/* MII interrupt pending */
+#define PHY_PHYSTS_RF 			0x0080	/* Remote fault 1: fault 0: no falut */
+#define PHY_PHYSTS_JD 			0x0040	/* Jabber detect 1:jabber 0: no jabber */
+#define PHY_PHYSTS_NWC			0x0020	/* Auto negociate complete 1: done 0:not */
+#define PHY_PHYSTS_RS	 		0x0010	/* Reset Status 1: in progress 0: normal */
+#define PHY_PHYSTS_LBS			0x0008	/* Loopback 1:LB enabled 0:disabled */
+#define PHY_PHYSTS_DS 			0x0004	/* Duplex status 1:FD 0: HD */
+#define PHY_PHYSTS_SS 			0x0002	/* Speed status 1:10 0:100 */
+#define PHY_PHYSTS_LS 			0x0001	/* Link status 1: valid 0: no link */
+
+#endif				/* _IBM_OCP_PHY_H_ */
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ibm_ocp_zmii.c linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_zmii.c
--- linux-2.5/drivers/net/ibm_ocp/ibm_ocp_zmii.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ibm_ocp_zmii.c	2003-01-06 10:11:42.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * ibm_ocp_zmii.c
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Sept, 2001
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/netdevice.h>
+
+#include <asm/ocp.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+
+#include "ocp_zmii.h"
+#include "ibm_ocp_enet.h"
+
+static unsigned int zmii_enable[][4] = {
+	{ZMII_SMII0, ZMII_RMII0, ZMII_MII0,
+	 ~(ZMII_MDI1 | ZMII_MDI2 | ZMII_MDI3)},
+	{ZMII_SMII1, ZMII_RMII1, ZMII_MII1,
+	 ~(ZMII_MDI0 | ZMII_MDI2 | ZMII_MDI3)},
+	{ZMII_SMII2, ZMII_RMII2, ZMII_MII2,
+	 ~(ZMII_MDI0 | ZMII_MDI1 | ZMII_MDI3)},
+	{ZMII_SMII3, ZMII_RMII3, ZMII_MII3, ~(ZMII_MDI0 | ZMII_MDI1 | ZMII_MDI2)}
+};
+static unsigned int mdi_enable[] =
+    { ZMII_MDI0, ZMII_MDI1, ZMII_MDI2, ZMII_MDI3 };
+
+static unsigned int zmii_speed = 0x0;
+static unsigned int zmii_speed100[] = { ZMII_MII0_100MB, ZMII_MII1_100MB };
+
+void
+zmii_enable_port(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	zmii_t *zmiip = fep->zmii_base;
+	int emac_num = (fep->ocpdev)->num;
+	unsigned int mask;
+
+	mask = in_be32(&zmiip->fer);
+
+	mask &= zmii_enable[emac_num][MDI];	/* turn all non enable MDI's off */
+	mask |= zmii_enable[emac_num][fep->zmii_mode]
+	    | mdi_enable[emac_num];
+	out_be32(&zmiip->fer, mask);
+
+#ifdef EMAC_DEBUG
+	printk("EMAC# %d zmiip 0x%x  = 0x%x\n", emac_num, zmiip,
+	       zmiip->fer);
+#endif
+}
+
+void
+zmii_set_port_speed(int speed, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	int emac_num = (fep->ocpdev)->num;
+	zmii_t *zmiip = fep->zmii_base;
+
+	if (speed == 100)
+		zmii_speed |= zmii_speed100[emac_num];
+
+	out_be32(&zmiip->ssr, zmii_speed);
+	return;
+}
+
+int
+zmii_init(int mode, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	struct zmii_regs *zmiip;
+	char *mode_name[] = { "SMII", "RMII", "MII" };
+
+	/*
+	 * FIXME: Need to handle multiple ZMII case that worked
+	 * in the older code.  This is a kludge.
+	 */
+	fep->zmii_ocpdev = ocp_get_dev(OCP_FUNC_ZMII, 0);
+
+	zmiip = (struct zmii_regs *)
+	    __ioremap((fep->zmii_ocpdev)->paddr, sizeof (*zmiip), _PAGE_NO_CACHE);
+
+	fep->zmii_base = zmiip;
+	fep->zmii_mode = mode;
+	if (mode == ZMII_AUTO) {
+		if (zmiip->fer & (ZMII_MII0 | ZMII_MII1 | 
+				  ZMII_MII2 | ZMII_MII3))
+			fep->zmii_mode = MII;
+		if (zmiip->fer & (ZMII_RMII0 | ZMII_RMII1 |
+				  ZMII_RMII2 | ZMII_RMII3))
+			fep->zmii_mode = RMII;
+		if (zmiip->fer & (ZMII_SMII0 | ZMII_SMII1 |
+				  ZMII_SMII2 | ZMII_SMII3))
+			fep->zmii_mode = SMII;
+
+		/* Failsafe: ZMII_AUTO is invalid index into the arrays,
+		   so force SMII if all else fails. */
+
+		if (fep->zmii_mode == ZMII_AUTO)
+			fep->zmii_mode = SMII;
+	}
+
+	printk(KERN_NOTICE "IBM ZMII: %s mode\n",
+			mode_name[fep->zmii_mode]);
+	return (fep->zmii_mode);
+}
diff -p -purN linux-2.5/drivers/net/ibm_ocp/ocp_zmii.h linuxppc-2.5/drivers/net/ibm_ocp/ocp_zmii.h
--- linux-2.5/drivers/net/ibm_ocp/ocp_zmii.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/ibm_ocp/ocp_zmii.h	2002-11-07 21:31:58.000000000 +0100
@@ -0,0 +1,113 @@
+/*
+ * ocp_zmii.h
+ *
+ * Defines for the IBM ZMII bridge
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Dec, 2001
+ *
+ * Copyright 2001 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  V 1.2 (04/19/02 ) - Armin
+ *    added support for emac 2 & 3
+ */
+
+#ifndef _OCP_ZMII_H_
+#define _OCP_ZMII_H_
+
+#include <linux/config.h>
+
+#ifdef CONFIG_IBM_OCP_ZMII
+int zmii_init(int, struct net_device *);
+void zmii_enable_port(struct net_device *);
+void zmii_set_port_speed(int speed, struct net_device *);
+#else
+#define zmii_init(x,y)
+#define zmii_enable_port(x)
+#define zmii_set_port_speed(x,y)
+#endif
+
+/* ZMII bridge */
+typedef struct zmii_regs {
+	u32 fer;		/* Function enable reg */
+	u32 ssr;		/* Spedd select reg */
+	u32 smiirs;		/* SMII status reg */
+} zmii_t;
+
+
+/* Fuctional Enable Reg */
+
+#define ZMII_MDI0	0x80000000
+#define ZMII_SMII0	0x40000000
+#define ZMII_RMII0	0x20000000
+#define ZMII_MII0	0x10000000
+#define ZMII_MDI1	0x08000000
+#define ZMII_SMII1	0x04000000
+#define ZMII_RMII1	0x02000000
+#define ZMII_MII1	0x01000000
+#define ZMII_MDI2	0x00800000
+#define ZMII_SMII2	0x00400000
+#define ZMII_RMII2	0x00200000
+#define ZMII_MII2	0x00100000
+#define ZMII_MDI3	0x00080000
+#define ZMII_SMII3	0x00040000
+#define ZMII_RMII3	0x00020000
+#define ZMII_MII3	0x00010000
+
+/* Speed Selection reg */
+
+#define ZMII_SCI0	0x40000000
+#define ZMII_FSS0	0x20000000
+#define ZMII_SP0	0x10000000
+#define ZMII_SCI1	0x04000000
+#define ZMII_FSS1	0x02000000
+#define ZMII_SP1	0x01000000
+#define ZMII_SCI2	0x00400000
+#define ZMII_FSS2	0x00200000
+#define ZMII_SP2	0x00100000
+#define ZMII_SCI3	0x00040000
+#define ZMII_FSS3	0x00020000
+#define ZMII_SP3	0x00010000
+
+#define ZMII_MII0_100MB	ZMII_SP0
+#define ZMII_MII0_10MB	~ZMII_SP0
+#define ZMII_MII1_100MB	ZMII_SP1
+#define ZMII_MII1_10MB	~ZMII_SP1
+#define ZMII_MII2_100MB	ZMII_SP2
+#define ZMII_MII2_10MB	~ZMII_SP2
+#define ZMII_MII3_100MB	ZMII_SP3
+#define ZMII_MII3_10MB	~ZMII_SP3
+
+/* SMII Status reg */
+
+#define ZMII_STS0 0xFF000000	/* EMAC0 smii status mask */
+#define ZMII_STS1 0x00FF0000	/* EMAC1 smii status mask */
+
+
+#define SMII	0
+#define RMII	1
+#define MII	2
+#define MDI	3
+#define ZMII_AUTO 4
+
+#endif				/* _OCP_ZMII_H_ */
diff -p -purN linux-2.5/drivers/net/pcnet32.c linuxppc-2.5/drivers/net/pcnet32.c
--- linux-2.5/drivers/net/pcnet32.c	2003-09-04 09:36:29.000000000 +0200
+++ linuxppc-2.5/drivers/net/pcnet32.c	2003-09-09 03:06:59.000000000 +0200
@@ -541,7 +541,9 @@ pcnet32_probe1(unsigned long ioaddr, uns
 	pcnet32_dwio_reset(ioaddr);
 	if (pcnet32_dwio_read_csr(ioaddr, 0) == 4 && pcnet32_dwio_check(ioaddr)) {
 	    a = &pcnet32_dwio;
-	} else
+	} else {
+		printk(KERN_INFO "pcnet32: probe at %lx failed\n", ioaddr);
 		goto err_release_region;
+	}
     }
 
diff -p -purN linux-2.5/drivers/net/smc91111.c linuxppc-2.5/drivers/net/smc91111.c
--- linux-2.5/drivers/net/smc91111.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/smc91111.c	2002-08-27 16:33:38.000000000 +0200
@@ -0,0 +1,3693 @@
+/*------------------------------------------------------------------------
+ . smc91111.c
+ . This is a driver for SMSC's 91C111 single-chip Ethernet device.
+ .
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .       Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+ .
+ . "Features" of the SMC chip:
+ .   Integrated PHY/MAC for 10/100BaseT Operation
+ .   Supports internal and external MII
+ .   Integrated 8K packet memory
+ .   EEPROM interface for configuration
+ .
+ . Arguments:
+ . 	io	= for the base address
+ .	irq	= for the IRQ
+ .	nowait	= 0 for normal wait states, 1 eliminates additional wait states
+ .
+ . author:
+ . 	Erik Stahlman				( erik@vt.edu )
+ . 	Daris A Nevil				( dnevil@snmc.com )
+ . contributors:
+ .      Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ .
+ . Hardware multicast code from Peter Cammaert ( pc@denkart.be )
+ .
+ . Sources:
+ .    o   SMSC LAN91C111 databook (www.smsc.com)
+ .    o   smc9194.c by Erik Stahlman
+ .    o   skeleton.c by Donald Becker ( becker@scyld.com )
+ .
+ . History:
+ .      08/20/00  Arnaldo Melo   fix kfree(skb) in smc_hardware_send_packet
+ .      12/15/00  Christian Jullien fix "Warning: kfree_skb on hard IRQ"
+ .	04/25/01  Daris A Nevil  Initial public release through SMSC
+ .	03/16/01  Daris A Nevil  Modified smc9194.c for use with LAN91C111
+ .	08/22/01  Scott Anderson Merge changes from smc9194 to smc91111
+ ----------------------------------------------------------------------------*/
+
+// Use power-down feature of the chip
+#define POWER_DOWN	1
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+#ifndef SMC_DEBUG
+#define SMC_DEBUG 0
+#endif
+
+static const char version[] =
+	"smc91111.c:v1.0saa 08/22/01 by Daris A Nevil (dnevil@snmc.com)\n";
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#ifdef CONFIG_SYSCTL
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+#endif
+
+#include "smc91111.h"
+
+#ifdef CONFIG_ISA
+
+/*
+ .the LAN91C111 can be at any of the following port addresses.  To change,
+ .for a slightly different card, you can add it to the array.  Keep in
+ .mind that the array must end in zero.
+*/
+static unsigned int smc_portlist[] __initdata = {
+	0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0,
+	0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0, 0
+};
+
+#endif  /* CONFIG_ISA */
+
+static struct net_device *global_dev = NULL;
+#ifndef SMC91111_BASE_ADDR
+# define SMC91111_BASE_ADDR -1
+#endif
+static int io = SMC91111_BASE_ADDR;
+#ifndef SMC91111_IRQ
+# define SMC91111_IRQ -1
+#endif
+static int irq = SMC91111_IRQ;
+static int nowait = 0;
+
+MODULE_PARM(io, "i");
+MODULE_PARM(irq, "i");
+MODULE_PARM(nowait, "i");
+MODULE_PARM_DESC(io, "SMC 91111 I/O base address");
+MODULE_PARM_DESC(irq, "SMC 91111 IRQ number");
+
+/*
+ . Wait time for memory to be free.  This probably shouldn't be
+ . tuned that much, as waiting for this means nothing else happens
+ . in the system
+*/
+#define MEMORY_WAIT_TIME 16
+
+#if SMC_DEBUG > 2
+#define PRINTK3(args...) printk(args)
+#else
+#define PRINTK3(args...)
+#endif
+
+#if SMC_DEBUG > 1
+#define PRINTK2(args...) printk(args)
+#else
+#define PRINTK2(args...)
+#endif
+
+#if SMC_DEBUG > 0
+#define PRINTK(args...) printk(args)
+#else
+#define PRINTK(args...)
+#endif
+
+
+/*------------------------------------------------------------------------
+ .
+ . The internal workings of the driver.  If you are changing anything
+ . here with the SMC stuff, you should have the datasheet and know
+ . what you are doing.
+ .
+ -------------------------------------------------------------------------*/
+#define CARDNAME "LAN91C111"
+
+// Memory sizing constant
+#define LAN91C111_MEMORY_MULTIPLIER	(1024*2)
+
+/* store this information for the driver.. */
+struct smc_local {
+
+ 	// these are things that the kernel wants me to keep, so users
+	// can find out semi-useless statistics of how well the card is
+	// performing
+	struct net_device_stats stats;
+
+	// If I have to wait until memory is available to send
+	// a packet, I will store the skbuff here, until I get the
+	// desired memory.  Then, I'll send it out and free it.
+	struct sk_buff * saved_skb;
+
+ 	// This keeps track of how many packets that I have
+ 	// sent out.  When an TX_EMPTY interrupt comes, I know
+	// that all of these have been sent.
+	int	packets_waiting;
+
+	// Set to true during the auto-negotiation sequence
+	int	autoneg_active;
+
+	// Address of our PHY port
+	word	phyaddr;
+
+	// Type of PHY
+	word	phytype;
+
+	// Last contents of PHY Register 18
+	word	lastPhy18;
+
+	// Contains the current active transmission mode
+	word	tcr_cur_mode;
+
+	// Contains the current active receive mode
+	word	rcr_cur_mode;
+
+	// Contains the current active receive/phy mode
+	word	rpc_cur_mode;
+
+
+#ifdef CONFIG_SYSCTL
+
+	// Root directory /proc/sys/dev
+	// Second entry must be null to terminate the table
+	ctl_table root_table[2];
+
+	// Directory for this device /proc/sys/dev/ethX
+	// Again the second entry must be zero to terminate
+	ctl_table eth_table[2];
+
+	// This is the parameters (file) table
+	ctl_table param_table[CTL_SMC_LAST_ENTRY];
+
+	// Saves the sysctl header returned by register_sysctl_table()
+	// we send this to unregister_sysctl_table()
+	struct ctl_table_header *sysctl_header;
+
+	// Parameter variables (files) go here
+	char ctl_info[1024];
+	int ctl_swfdup;
+	int ctl_ephloop;
+	int ctl_miiop;
+	int ctl_autoneg;
+	int ctl_rfduplx;
+	int ctl_rspeed;
+	int ctl_afduplx;
+	int ctl_aspeed;
+	int ctl_lnkfail;
+	int ctl_forcol;
+	int ctl_filtcar;
+	int ctl_freemem;
+	int ctl_totmem;
+	int ctl_leda;
+	int ctl_ledb;
+	int ctl_chiprev;
+#if SMC_DEBUG > 0
+	int ctl_reg_bsr;
+	int ctl_reg_tcr;
+	int ctl_reg_esr;
+	int ctl_reg_rcr;
+	int ctl_reg_ctrr;
+	int ctl_reg_mir;
+	int ctl_reg_rpcr;
+	int ctl_reg_cfgr;
+	int ctl_reg_bar;
+	int ctl_reg_iar0;
+	int ctl_reg_iar1;
+	int ctl_reg_iar2;
+	int ctl_reg_gpr;
+	int ctl_reg_ctlr;
+	int ctl_reg_mcr;
+	int ctl_reg_pnr;
+	int ctl_reg_fpr;
+	int ctl_reg_ptr;
+	int ctl_reg_dr;
+	int ctl_reg_isr;
+	int ctl_reg_mtr1;
+	int ctl_reg_mtr2;
+	int ctl_reg_mtr3;
+	int ctl_reg_mtr4;
+	int ctl_reg_miir;
+	int ctl_reg_revr;
+	int ctl_reg_ercvr;
+	int ctl_reg_extr;
+	int ctl_phy_ctrl;
+	int ctl_phy_stat;
+	int ctl_phy_id1;
+	int ctl_phy_id2;
+	int ctl_phy_adc;
+	int ctl_phy_remc;
+	int ctl_phy_cfg1;
+	int ctl_phy_cfg2;
+	int ctl_phy_int;
+	int ctl_phy_mask;
+#endif // SMC_DEBUG > 0
+
+
+#endif // CONFIG_SYSCTL
+
+};
+
+
+/*-----------------------------------------------------------------
+ .
+ .  The driver can be entered at any of the following entry points.
+ .
+ .------------------------------------------------------------------  */
+
+/*
+ . The kernel calls this function when someone wants to use the device,
+ . typically 'ifconfig ethX up'.
+*/
+static int smc_open(struct net_device *dev);
+
+/*
+ . Our watchdog timed out. Called by the networking layer
+*/
+static void smc_timeout(struct net_device *dev);
+
+/*
+ . This is called by the kernel in response to 'ifconfig ethX down'.  It
+ . is responsible for cleaning up everything that the open routine
+ . does, and maybe putting the card into a powerdown state.
+*/
+static int smc_close(struct net_device *dev);
+
+/*
+ . This routine allows the proc file system to query the driver's
+ . statistics.
+*/
+static struct net_device_stats * smc_query_statistics( struct net_device *dev);
+
+/*
+ . Finally, a call to set promiscuous mode ( for TCPDUMP and related
+ . programs ) and multicast modes.
+*/
+static void smc_set_multicast_list(struct net_device *dev);
+
+/*
+ . CRC compute
+ */
+static int crc32( char * s, int length );
+
+/*
+ . Configures the PHY through the MII Management interface
+*/
+static void smc_phy_configure(struct net_device* dev);
+
+/*---------------------------------------------------------------
+ .
+ . Interrupt level calls..
+ .
+ ----------------------------------------------------------------*/
+
+/*
+ . Handles the actual interrupt
+*/
+static void smc_interrupt(int irq, void *, struct pt_regs *regs);
+/*
+ . This is a separate procedure to handle the receipt of a packet, to
+ . leave the interrupt code looking slightly cleaner
+*/
+inline static void smc_rcv( struct net_device *dev );
+/*
+ . This handles a TX interrupt, which is only called when an error
+ . relating to a packet is sent.
+*/
+inline static void smc_tx( struct net_device * dev );
+
+/*
+ . This handles interrupts generated from PHY register 18
+*/
+static void smc_phy_interrupt(struct net_device* dev);
+
+/*
+ ------------------------------------------------------------
+ .
+ . Internal routines
+ .
+ ------------------------------------------------------------
+*/
+
+/*
+ . Test if a given location contains a chip, trying to cause as
+ . little damage as possible if it's not a SMC chip.
+*/
+static int smc_probe(struct net_device *dev, unsigned long ioaddr);
+
+/*
+ . A rather simple routine to print out a packet for debugging purposes.
+*/
+#if SMC_DEBUG > 2
+static void print_packet( byte *, int );
+#endif
+
+#define tx_done(dev) 1
+
+/* this is called to actually send the packet to the chip */
+static void smc_hardware_send_packet( struct net_device * dev );
+
+/* Since I am not sure if I will have enough room in the chip's ram
+ . to store the packet, I call this routine, which either sends it
+ . now, or generates an interrupt when the card is ready for the
+ . packet */
+static int  smc_wait_to_send_packet( struct sk_buff * skb, struct net_device *dev );
+
+/* this does a soft reset on the device */
+static void smc_reset( struct net_device* dev );
+
+/* Enable Interrupts, Receive, and Transmit */
+static void smc_enable( struct net_device *dev );
+
+/* this puts the device in an inactive state */
+static void smc_shutdown( unsigned long ioaddr );
+
+/* This routine will find the IRQ of the driver if one is not
+ . specified in the input to the device.  */
+static int smc_findirq( unsigned long ioaddr );
+
+/* Routines to Read and Write the PHY Registers across the
+   MII Management Interface
+*/
+
+static word smc_read_phy_register(unsigned long ioaddr,
+				  byte phyaddr, byte phyreg);
+static void smc_write_phy_register(unsigned long ioaddr,
+	byte phyaddr, byte phyreg, word phydata);
+
+/*
+  Initilizes our device's sysctl proc filesystem
+*/
+
+#ifdef CONFIG_SYSCTL
+static void smc_sysctl_register(struct net_device *dev);
+static void smc_sysctl_unregister(struct net_device *dev);
+#endif /* CONFIG_SYSCTL */
+
+/*
+ . Function: smc_reset( struct net_device* dev )
+ . Purpose:
+ .  	This sets the SMC91111 chip to its normal state, hopefully from whatever
+ . 	mess that any other DOS driver has put it in.
+ .
+ . Maybe I should reset more registers to defaults in here?  SOFTRST  should
+ . do that for me.
+ .
+ . Method:
+ .	1.  send a SOFT RESET
+ .	2.  wait for it to finish
+ .	3.  enable autorelease mode
+ .	4.  reset the memory management unit
+ .	5.  clear all interrupts
+ .
+*/
+static void smc_reset( struct net_device* dev )
+{
+	//struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	unsigned long ioaddr = dev->base_addr;
+
+	PRINTK2("%s:smc_reset\n", dev->name);
+
+	/* This resets the registers mostly to defaults, but doesn't
+	   affect EEPROM.  That seems unnecessary */
+	SMC_SELECT_BANK( 0 );
+	SMC_SET_RCR( RCR_SOFTRST );
+
+	/* Setup the Configuration Register */
+	/* This is necessary because the CONFIG_REG is not affected */
+	/* by a soft reset */
+
+	SMC_SELECT_BANK( 1 );
+	SMC_SET_CONFIG( CONFIG_DEFAULT );
+
+	/* Setup for fast accesses if requested */
+	/* If the card/system can't handle it then there will */
+	/* be no recovery except for a hard reset or power cycle */
+
+	if (dev->dma)
+		SMC_SET_CONFIG( SMC_GET_CONFIG() | CONFIG_NO_WAIT );
+
+#ifdef POWER_DOWN
+	/* Release from possible power-down state */
+	/* Configuration register is not affected by Soft Reset */
+	SMC_SELECT_BANK( 1 );
+	SMC_SET_CONFIG( SMC_GET_CONFIG() | CONFIG_EPH_POWER_EN );
+#endif
+
+	SMC_SELECT_BANK( 0 );
+
+	/* this should pause enough for the chip to be happy */
+	mdelay(10);
+
+	/* Disable transmit and receive functionality */
+	SMC_SET_RCR( RCR_CLEAR );
+	SMC_SET_TCR( TCR_CLEAR );
+
+	/* set the control register to automatically
+	   release successfully transmitted packets, to make the best
+	   use out of our limited memory */
+	SMC_SELECT_BANK( 1 );
+	SMC_SET_CTL( SMC_GET_CTL() | CTL_AUTO_RELEASE );
+
+	/* Reset the MMU */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_MMU_CMD( MC_RESET );
+
+	/* Note:  It doesn't seem that waiting for the MMU busy is needed here,
+	   but this is a place where future chipsets _COULD_ break.  Be wary
+ 	   of issuing another MMU command right after this */
+
+	/* Disable all interrupts */
+	SMC_SET_INT_MASK( 0 );
+}
+
+/*
+ . Function: smc_enable
+ . Purpose: let the chip talk to the outside work
+ . Method:
+ .	1.  Enable the transmitter
+ .	2.  Enable the receiver
+ .	3.  Enable interrupts
+*/
+static void smc_enable( struct net_device *dev )
+{
+	unsigned long ioaddr 	= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+
+	PRINTK2("%s:smc_enable\n", dev->name);
+
+	SMC_SELECT_BANK( 0 );
+	/* see the header file for options in TCR/RCR DEFAULT*/
+	SMC_SET_TCR( lp->tcr_cur_mode );
+	SMC_SET_RCR( lp->rcr_cur_mode );
+
+	/* now, enable interrupts */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_INT_MASK( SMC_INTERRUPT_MASK );
+}
+
+/*
+ . Function: smc_shutdown
+ . Purpose:  closes down the SMC91xxx chip.
+ . Method:
+ .	1. zero the interrupt mask
+ .	2. clear the enable receive flag
+ .	3. clear the enable xmit flags
+ .
+ . TODO:
+ .   (1) maybe utilize power down mode.
+ .	Why not yet?  Because while the chip will go into power down mode,
+ .	the manual says that it will wake up in response to any I/O requests
+ .	in the register space.   Empirical results do not show this working.
+*/
+static void smc_shutdown( unsigned long ioaddr )
+{
+	PRINTK2(CARDNAME ":smc_shutdown\n");
+
+	/* no more interrupts for me */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_INT_MASK( 0 );
+
+	/* and tell the card to stay away from that nasty outside world */
+	SMC_SELECT_BANK( 0 );
+	SMC_SET_RCR( RCR_CLEAR );
+	SMC_SET_TCR( TCR_CLEAR );
+
+#ifdef POWER_DOWN
+	/* finally, shut the chip down */
+	SMC_SELECT_BANK( 1 );
+	SMC_SET_CONFIG( SMC_GET_CONFIG() & ~CONFIG_EPH_POWER_EN );
+#endif
+}
+
+
+/*
+ . Function: smc_setmulticast( int ioaddr, int count, dev_mc_list * adds )
+ . Purpose:
+ .    This sets the internal hardware table to filter out unwanted multicast
+ .    packets before they take up memory.
+ .
+ .    The SMC chip uses a hash table where the high 6 bits of the CRC of
+ .    address are the offset into the table.  If that bit is 1, then the
+ .    multicast packet is accepted.  Otherwise, it's dropped silently.
+ .
+ .    To use the 6 bits as an offset into the table, the high 3 bits are the
+ .    number of the 8 bit register, while the low 3 bits are the bit within
+ .    that register.
+ .
+ . This routine is based very heavily on the one provided by Peter Cammaert.
+*/
+
+
+static void smc_setmulticast( unsigned long ioaddr, int count,
+			      struct dev_mc_list * addrs ) {
+	int			i;
+	unsigned char		multicast_table[ 8 ];
+	struct dev_mc_list	* cur_addr;
+	/* table for flipping the order of 3 bits */
+	unsigned char invert3[] = { 0, 4, 2, 6, 1, 5, 3, 7 };
+
+	PRINTK2(CARDNAME ":smc_setmulticast\n");
+
+	/* start with a table of all zeros: reject all */
+	memset( multicast_table, 0, sizeof( multicast_table ) );
+
+	cur_addr = addrs;
+	for ( i = 0; i < count ; i ++, cur_addr = cur_addr->next  ) {
+		int position;
+
+		/* do we have a pointer here? */
+		if ( !cur_addr )
+			break;
+		/* make sure this is a multicast address - shouldn't this
+		   be a given if we have it here ? */
+		if ( !( *cur_addr->dmi_addr & 1 ) )
+			continue;
+
+		/* only use the low order bits */
+		position = crc32( cur_addr->dmi_addr, 6 ) & 0x3f;
+
+		/* do some messy swapping to put the bit in the right spot */
+		multicast_table[invert3[position&7]] |=
+					(1<<invert3[(position>>3)&7]);
+
+	}
+	/* now, the table can be loaded into the chipset */
+	SMC_SELECT_BANK( 3 );
+	SMC_SET_MCAST( multicast_table );
+}
+
+/*
+  Finds the CRC32 of a set of bytes.
+  Again, from Peter Cammaert's code.
+*/
+static int crc32( char * s, int length ) {
+	/* indices */
+	int perByte;
+	int perBit;
+	/* crc polynomial for Ethernet */
+	const unsigned long poly = 0xedb88320;
+	/* crc value - preinitialized to all 1's */
+	unsigned long crc_value = 0xffffffff;
+
+	for ( perByte = 0; perByte < length; perByte ++ ) {
+		unsigned char	c;
+
+		c = *(s++);
+		for ( perBit = 0; perBit < 8; perBit++ ) {
+			crc_value = (crc_value>>1)^
+				(((crc_value^c)&0x01)?poly:0);
+			c >>= 1;
+		}
+	}
+	return	crc_value;
+}
+
+
+/*
+ . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * )
+ . Purpose:
+ .    Attempt to allocate memory for a packet, if chip-memory is not
+ .    available, then tell the card to generate an interrupt when it
+ .    is available.
+ .
+ . Algorithm:
+ .
+ . o	if the saved_skb is not currently null, then drop this packet
+ .	on the floor.  This should never happen, because of TBUSY.
+ . o	if the saved_skb is null, then replace it with the current packet,
+ . o	See if I can sending it now.
+ . o 	(NO): Enable interrupts and let the interrupt handler deal with it.
+ . o	(YES):Send it now.
+*/
+static int smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * dev )
+{
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	unsigned long ioaddr 	= dev->base_addr;
+	word 			length;
+	unsigned short 		numPages;
+	word			time_out;
+	word			status;
+
+	PRINTK3("%s:smc_wait_to_send_packet\n", dev->name);
+
+	netif_stop_queue(dev);
+	/* Well, I want to send the packet.. but I don't know
+	   if I can send it right now...  */
+
+	if ( lp->saved_skb) {
+		/* THIS SHOULD NEVER HAPPEN. */
+		lp->stats.tx_aborted_errors++;
+		printk("%s: Bad Craziness - sent packet while busy.\n",
+			dev->name);
+		return 1;
+	}
+	lp->saved_skb = skb;
+
+	length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;
+
+
+	/*
+	** The MMU wants the number of pages to be the number of 256 bytes
+	** 'pages', minus 1 ( since a packet can't ever have 0 pages :) )
+	**
+	** The 91C111 ignores the size bits, but the code is left intact
+	** for backwards and future compatibility.
+	**
+	** Pkt size for allocating is data length +6 (for additional status
+	** words, length and ctl!)
+	**
+	** If odd size then last byte is included in this header.
+	*/
+	numPages =   ((length & 0xfffe) + 6);
+	numPages >>= 8; // Divide by 256
+
+	if (numPages > 7 ) {
+		printk("%s: Far too big packet error. \n", dev->name);
+		/* freeing the packet is a good thing here... but should
+		 . any packets of this size get down here?   */
+		dev_kfree_skb (skb);
+		lp->saved_skb = NULL;
+		/* this IS an error, but, i don't want the skb saved */
+		netif_wake_queue(dev);
+		return 0;
+	}
+	/* either way, a packet is waiting now */
+	lp->packets_waiting++;
+
+	/* now, try to allocate the memory */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_MMU_CMD( MC_ALLOC | numPages );
+	/*
+ 	. Performance Hack
+	.
+ 	. wait a short amount of time.. if I can send a packet now, I send
+	. it now.  Otherwise, I enable an interrupt and wait for one to be
+	. available.
+	.
+	. I could have handled this a slightly different way, by checking to
+	. see if any memory was available in the FREE MEMORY register.  However,
+	. either way, I need to generate an allocation, and the allocation works
+	. no matter what, so I saw no point in checking free memory.
+	*/
+	time_out = MEMORY_WAIT_TIME;
+	do {
+		status = SMC_GET_INT();
+		if ( status & IM_ALLOC_INT ) {
+			/* acknowledge the interrupt */
+			SMC_ACK_INT( IM_ALLOC_INT );
+  			break;
+		}
+   	} while ( -- time_out );
+
+   	if ( !time_out ) {
+		/* oh well, wait until the chip finds memory later */
+		SMC_ENABLE_INT( IM_ALLOC_INT );
+
+		/* Check the status bit one more time just in case */
+		/* it snuk in between the time we last checked it */
+		/* and when we set the interrupt bit */
+		status = SMC_GET_INT();
+		if ( !(status & IM_ALLOC_INT) ) {
+      			PRINTK2("%s: memory allocation deferred. \n",
+				dev->name);
+			/* it's deferred, but I'll handle it later */
+      			return 0;
+			}
+
+		/* Looks like it did sneak in, so disable */
+		/* the interrupt */
+		SMC_DISABLE_INT( IM_ALLOC_INT );
+   	}
+	/* or YES! I can send the packet now.. */
+	smc_hardware_send_packet(dev);
+	netif_wake_queue(dev);
+	return 0;
+}
+
+/*
+ . Function:  smc_hardware_send_packet(struct net_device * )
+ . Purpose:
+ .	This sends the actual packet to the SMC9xxx chip.
+ .
+ . Algorithm:
+ . 	First, see if a saved_skb is available.
+ .		( this should NOT be called if there is no 'saved_skb'
+ .	Now, find the packet number that the chip allocated
+ .	Point the data pointers at it in memory
+ .	Set the length word in the chip's memory
+ .	Dump the packet to chip memory
+ .	Check if a last byte is needed ( odd length packet )
+ .		if so, set the control flag right
+ . 	Tell the card to send it
+ .	Enable the transmit interrupt, so I know if it failed
+ . 	Free the kernel data if I actually sent it.
+*/
+static void smc_hardware_send_packet( struct net_device * dev )
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte	 		packet_no;
+	struct sk_buff * 	skb = lp->saved_skb;
+	word			length;
+	unsigned long		ioaddr;
+	byte			* buf;
+
+	PRINTK3("%s:smc_hardware_send_packet\n", dev->name);
+
+	ioaddr = dev->base_addr;
+
+	if ( !skb ) {
+		PRINTK("%s: In XMIT with no packet to send \n", dev->name);
+		return;
+	}
+	length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;
+	buf = skb->data;
+
+	/* If I get here, I _know_ there is a packet slot waiting for me */
+	packet_no = SMC_GET_AR();
+	if ( packet_no & AR_FAILED ) {
+		/* or isn't there?  BAD CHIP! */
+		printk(KERN_DEBUG "%s: Memory allocation failed. \n",
+			dev->name);
+		dev_kfree_skb_any(skb);
+		lp->saved_skb = NULL;
+		netif_wake_queue(dev);
+		return;
+	}
+
+	/* we have a packet address, so tell the card to use it */
+	SMC_SET_PN( packet_no );
+
+	/* point to the beginning of the packet */
+	SMC_SET_PTR( PTR_AUTOINC );
+
+   	PRINTK3("%s: Trying to xmit packet of length %x\n",
+		dev->name, length);
+
+#if SMC_DEBUG > 2
+	printk("Transmitting Packet\n");
+	print_packet( buf, length );
+#endif
+
+	/* send the packet length ( +6 for status, length and ctl byte )
+ 	   and the status word ( set to zeros ) */
+#ifdef CONFIG_SMC91111_USE_32_BIT
+	SMC_outl(  (length +6 ) << 16 , ioaddr + DATA_REG );
+#else
+	SMC_outw( 0, ioaddr + DATA_REG );
+	/* send the packet length ( +6 for status words, length, and ctl*/
+	SMC_outw( (length+6), ioaddr + DATA_REG );
+#endif
+
+	/* send the actual data
+	 . I _think_ it's faster to send the longs first, and then
+	 . mop up by sending the last word.  It depends heavily
+ 	 . on alignment, at least on the 486.  Maybe it would be
+ 	 . a good idea to check which is optimal?  But that could take
+	 . almost as much time as is saved?
+	*/
+#ifdef CONFIG_SMC91111_USE_32_BIT
+	SMC_outsl(ioaddr + DATA_REG, buf,  length >> 2 );
+	if ( length & 0x2  )
+		SMC_outw(*((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +
+				DATA_REG);
+#else
+	SMC_outsw(ioaddr + DATA_REG , buf, (length ) >> 1);
+#endif // CONFIG_SMC91111_USE_32_BIT
+
+	/* Send the last byte, if there is one.   */
+	if ( (length & 1) == 0 ) {
+		SMC_outw( 0, ioaddr + DATA_REG );
+	} else {
+		SMC_outw( 0x2000 | buf[length -1 ], ioaddr + DATA_REG );
+	}
+
+	/* enable the interrupts */
+	SMC_ENABLE_INT( (IM_TX_INT | IM_TX_EMPTY_INT) );
+
+	/* and let the chipset deal with it */
+	SMC_SET_MMU_CMD( MC_ENQUEUE );
+
+	PRINTK2("%s: Sent packet of length %d \n", dev->name, length);
+
+	lp->saved_skb = NULL;
+	dev_kfree_skb_any (skb);
+
+	dev->trans_start = jiffies;
+
+	/* we can send another packet */
+	netif_wake_queue(dev);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------
+ |
+ | smc_init( void )
+ |   Input parameters:
+ |	dev->base_addr == 0, try to find all possible locations
+ |	dev->base_addr > 0x1ff, this is the address to check
+ |	dev->base_addr == <anything else>, return failure code
+ |
+ |   Output:
+ |	0 --> there is a device
+ |	anything else, error
+ |
+ ---------------------------------------------------------------------------
+*/
+static int __init smc_init( void )
+{
+	int rtn;
+
+	PRINTK2(CARDNAME ":smc_init\n");
+
+#ifdef MODULE
+	if (io == -1)
+		printk(KERN_WARNING
+		CARDNAME": You shouldn't use auto-probing with insmod!\n" );
+#endif
+
+	if (global_dev) {
+		printk(CARDNAME ": already initialized.\n");
+		return -EBUSY;
+	}
+
+	global_dev = init_etherdev(0, sizeof(struct smc_local));
+	if (!global_dev) {
+		printk(CARDNAME ": could not allocate device.\n");
+		return -ENODEV;
+	}
+	SET_MODULE_OWNER(global_dev);
+
+	/* copy the parameters from insmod into the device structure */
+	if (io != -1)
+		global_dev->base_addr	= io;
+	if (irq != -1)
+		global_dev->irq	= irq;
+	global_dev->dma		= nowait; // Use DMA field for nowait
+
+#ifdef CONFIG_ISA
+	/*  try a specific location */
+	if (global_dev->base_addr > 0x1ff)
+		rtn = smc_probe(global_dev, global_dev->base_addr);
+	else if (global_dev->base_addr != 0)
+		rtn = -ENXIO;
+	else {
+		int i;
+
+		/* check every ethernet address */
+		for (i = 0; smc_portlist[i]; i++) {
+			rtn = smc_probe(global_dev, smc_portlist[i]);
+			if (rtn == 0)
+				break;
+		}
+	}
+#else
+	if (global_dev->base_addr == -1) {
+		printk(KERN_WARNING
+		CARDNAME": SMC91111_BASE_ADDR not set!\n" );
+		rtn = -ENXIO;
+	}
+	else
+		rtn = smc_probe(global_dev,
+				(int)ioremap(global_dev->base_addr,
+					     SMC_IO_EXTENT));
+#endif
+
+	if (rtn != 0) {
+		printk(CARDNAME ": not found.\n");
+		/* couldn't find anything */
+#ifndef CONFIG_ISA
+		iounmap((void *)global_dev->base_addr);
+#endif
+		kfree(global_dev->priv);
+		unregister_netdev(global_dev);
+		kfree(global_dev);
+	}
+
+	return rtn;
+}
+
+/*----------------------------------------------------------------------
+ . smc_findirq
+ .
+ . This routine has a simple purpose -- make the SMC chip generate an
+ . interrupt, so an auto-detect routine can detect it, and find the IRQ,
+ ------------------------------------------------------------------------
+*/
+int __init smc_findirq( unsigned long ioaddr )
+{
+	int	timeout = 20;
+	unsigned long cookie;
+
+	PRINTK2(CARDNAME ":smc_findirq\n");
+
+	/* I have to do a STI() here, because this is called from
+	   a routine that does an CLI during this process, making it
+	   rather difficult to get interrupts for auto detection */
+	sti();
+
+	cookie = probe_irq_on();
+
+	/*
+	 * What I try to do here is trigger an ALLOC_INT. This is done
+	 * by allocating a small chunk of memory, which will give an interrupt
+	 * when done.
+	 */
+
+
+	SMC_SELECT_BANK(2);
+	/* enable ALLOCation interrupts ONLY */
+	SMC_SET_INT_MASK( IM_ALLOC_INT );
+
+	/*
+ 	 . Allocate 512 bytes of memory.  Note that the chip was just
+	 . reset so all the memory is available
+	*/
+	SMC_SET_MMU_CMD( MC_ALLOC | 1 );
+
+	/*
+	 . Wait until positive that the interrupt has been generated
+	*/
+	while ( timeout ) {
+		byte	int_status;
+
+		int_status = SMC_GET_INT();
+
+		if ( int_status & IM_ALLOC_INT )
+			break;		/* got the interrupt */
+		timeout--;
+	}
+
+	/* there is really nothing that I can do here if timeout fails,
+	   as autoirq_report will return a 0 anyway, which is what I
+	   want in this case.   Plus, the clean up is needed in both
+	   cases.  */
+
+	/* DELAY HERE!
+	   On a fast machine, the status might change before the interrupt
+	   is given to the processor.  This means that the interrupt was
+	   never detected, and autoirq_report fails to report anything.
+	   This should fix autoirq_* problems.
+	*/
+	mdelay(10);
+
+	/* and disable all interrupts again */
+	SMC_SET_INT_MASK( 0 );
+
+	/* clear hardware interrupts again, because that's how it
+	   was when I was called... */
+	cli();
+
+	/* and return what I found */
+	return probe_irq_off(cookie);
+}
+
+/*----------------------------------------------------------------------
+ . Function: smc_probe( unsigned long ioaddr )
+ .
+ . Purpose:
+ .	Tests to see if a given ioaddr points to an SMC91111 chip.
+ .	Returns a 0 on success
+ .
+ . Algorithm:
+ .	(1) see if the high byte of BANK_SELECT is 0x33
+ . 	(2) compare the ioaddr with the base register's address
+ .	(3) see if I recognize the chip ID in the appropriate register
+ .
+ .---------------------------------------------------------------------
+ */
+/*---------------------------------------------------------------
+ . Here I do typical initialization tasks.
+ .
+ . o  Initialize the structure if needed
+ . o  print out my vanity message if not done so already
+ . o  print out what type of hardware is detected
+ . o  print out the ethernet address
+ . o  find the IRQ
+ . o  set up my private data
+ . o  configure the dev structure with my subroutines
+ . o  actually GRAB the irq.
+ . o  GRAB the region
+ .-----------------------------------------------------------------
+*/
+static int __init smc_probe(struct net_device *dev, unsigned long ioaddr)
+{
+	int i, memory, retval;
+	static unsigned version_printed;
+	unsigned int	bank;
+
+	const char *version_string;
+	const char *if_string;
+
+	/* registers */
+	word	revision_register;
+	word  base_address_register;
+	word memory_info_register;
+
+	PRINTK2(CARDNAME ":smc_probe\n");
+
+	/* Grab the region so that no one else tries to probe our ioports. */
+	if (!request_region(ioaddr, SMC_IO_EXTENT, dev->name))
+		return -EBUSY;
+
+	/* First, see if the high byte is 0x33 */
+	bank = SMC_CURRENT_BANK();
+	if ( (bank & 0xFF00) != 0x3300 ) {
+		if ( (bank & 0xFF) == 0x33 ) {
+			printk(CARDNAME
+			       ": Detected possible byte-swapped interface"
+			       " at IOADDR %lx\n", ioaddr);
+		}
+		retval = -ENODEV;
+		goto err_out;
+	}
+	/* The above MIGHT indicate a device, but I need to write to further
+ 	 	test this.  */
+	SMC_SELECT_BANK(0);
+	bank = SMC_CURRENT_BANK();
+	if ( (bank & 0xFF00 ) != 0x3300 ) {
+		retval = -ENODEV;
+		goto err_out;
+	}
+	/* well, we've already written once, so hopefully another time won't
+ 	   hurt.  This time, I need to switch the bank register to bank 1,
+	   so I can access the base address register */
+	SMC_SELECT_BANK(1);
+	base_address_register = SMC_GET_BASE();
+	base_address_register = ((base_address_register & 0xE000)
+				 | ((base_address_register & 0x1F00) >> 3));
+	if ( (ioaddr & (PAGE_SIZE-1)) != base_address_register )  {
+		printk(CARDNAME ": IOADDR %lx doesn't match configuration (%x)."
+			"Probably not a SMC chip\n",
+			ioaddr, base_address_register );
+		/* well, the base address register didn't match.  Must not have
+		   been a SMC chip after all. */
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/*  check if the revision register is something that I recognize.
+	    These might need to be added to later, as future revisions
+	    could be added.  */
+	SMC_SELECT_BANK(3);
+	revision_register  = SMC_GET_REV();
+	if ( !chip_ids[ ( revision_register  >> 4 ) & 0xF  ] ) {
+		/* I don't recognize this chip, so... */
+		printk(CARDNAME ": IO %lx: Unrecognized revision register:"
+			" %x, Contact author. \n",
+			ioaddr, revision_register );
+
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/* at this point I'll assume that the chip is an SMC9xxx.
+	   It might be prudent to check a listing of MAC addresses
+	   against the hardware address, or do some other tests. */
+
+	if (version_printed++ == 0)
+		printk("%s", version);
+
+	/* fill in some of the fields */
+	dev->base_addr = ioaddr;
+
+	/*
+ 	 . Get the MAC address ( bank 1, regs 4 - 9 )
+	*/
+	SMC_SELECT_BANK( 1 );
+	for ( i = 0; i < 6; i += 2 ) {
+		word	address;
+
+		address = SMC_inw( ioaddr + ADDR0_REG + i  );
+		dev->dev_addr[ i + 1] = address >> 8;
+		dev->dev_addr[ i ] = address & 0xFF;
+	}
+
+	/* get the memory information */
+
+	SMC_SELECT_BANK( 0 );
+	memory_info_register = SMC_GET_MIR();
+	memory = memory_info_register & (word)0x00ff;
+	memory *= LAN91C111_MEMORY_MULTIPLIER;
+
+	/*
+	 Now, I want to find out more about the chip.  This is sort of
+ 	 redundant, but it's cleaner to have it in both, rather than having
+ 	 one VERY long probe procedure.
+	*/
+	SMC_SELECT_BANK(3);
+	revision_register  = SMC_GET_REV();
+	version_string = chip_ids[ ( revision_register  >> 4 ) & 0xF  ];
+	if ( !version_string ) {
+		/* I shouldn't get here because this call was done before.... */
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+
+	/* now, reset the chip, and put it into a known state */
+	smc_reset( dev );
+
+	/*
+	 . If dev->irq is 0, then the device has to be banged on to see
+	 . what the IRQ is.
+ 	 .
+	 . This banging doesn't always detect the IRQ, for unknown reasons.
+	 . a workaround is to reset the chip and try again.
+	 .
+	 . Interestingly, the DOS packet driver *SETS* the IRQ on the card to
+	 . be what is requested on the command line.   I don't do that, mostly
+	 . because the card that I have uses a non-standard method of accessing
+	 . the IRQs, and because this _should_ work in most configurations.
+	 .
+	 . Specifying an IRQ is done with the assumption that the user knows
+	 . what (s)he is doing.  No checking is done!!!!
+ 	 .
+	*/
+	if ( dev->irq < 2 ) {
+		int	trials;
+
+		trials = 3;
+		while ( trials-- ) {
+			dev->irq = smc_findirq( ioaddr );
+			if ( dev->irq )
+				break;
+			/* kick the card and try again */
+			smc_reset( dev );
+		}
+	}
+	if (dev->irq == 0 ) {
+		printk("%s: Couldn't autodetect your IRQ. Use irq=xx.\n",
+			dev->name);
+		retval = -ENODEV;
+		goto err_out;
+	}
+	if (dev->irq == 2) {
+		/* Fixup for users that don't know that IRQ 2 is really IRQ 9,
+		 * or don't know which one to set.
+		 */
+		dev->irq = 9;
+	}
+
+	/* now, print out the card info, in a short format.. */
+
+	printk("%s: %s(r:%d) at %#lx IRQ:%d\n", dev->name,
+	       version_string, revision_register & 0xF, ioaddr, dev->irq );
+	printk(" INTF:%s MEM:%db NOWAIT:%d", if_string, memory, dev->dma );
+	/*
+	 . Print the Ethernet address
+	*/
+	printk("  ADDR ");
+	for (i = 0; i < 5; i++)
+		printk("%2.2x:", dev->dev_addr[i] );
+	printk("%2.2x \n", dev->dev_addr[5] );
+
+	/* set the private data to zero by default */
+	memset(dev->priv, 0, sizeof(struct smc_local));
+
+	/* Fill in the fields of the device structure with ethernet values. */
+	ether_setup(dev);
+
+	/* Grab the IRQ */
+      	retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
+      	if (retval) {
+  	  	goto err_out;
+      	}
+
+	dev->open		        = smc_open;
+	dev->stop		        = smc_close;
+	dev->hard_start_xmit    	= smc_wait_to_send_packet;
+	dev->tx_timeout		    	= smc_timeout;
+	dev->watchdog_timeo		= HZ/20;
+	dev->get_stats			= smc_query_statistics;
+	dev->set_multicast_list 	= smc_set_multicast_list;
+
+	return 0;
+
+err_out:
+	release_region(ioaddr, SMC_IO_EXTENT);
+	return retval;
+}
+
+#if SMC_DEBUG > 2
+static void print_packet( byte * buf, int length )
+{
+#if 1
+#if SMC_DEBUG > 3
+	int i;
+	int remainder;
+	int lines;
+#endif
+
+	printk("Packet of length %d \n", length );
+
+#if SMC_DEBUG > 3
+	lines = length / 16;
+	remainder = length % 16;
+
+	for ( i = 0; i < lines ; i ++ ) {
+		int cur;
+
+		for ( cur = 0; cur < 8; cur ++ ) {
+			byte a, b;
+
+			a = *(buf ++ );
+			b = *(buf ++ );
+			printk("%02x%02x ", a, b );
+		}
+		printk("\n");
+	}
+	for ( i = 0; i < remainder/2 ; i++ ) {
+		byte a, b;
+
+		a = *(buf ++ );
+		b = *(buf ++ );
+		printk("%02x%02x ", a, b );
+	}
+	printk("\n");
+#endif
+#endif
+}
+#endif
+
+
+/*
+ * Open and Initialize the board
+ *
+ * Set up everything, reset the card, etc ..
+ *
+ */
+static int smc_open(struct net_device *dev)
+{
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	unsigned long ioaddr	= dev->base_addr;
+	int	i;	/* used to set hw ethernet address */
+
+	PRINTK2("%s:smc_open\n", dev->name);
+
+	/* clear out all the junk that was put here before... */
+	memset(dev->priv, 0, sizeof(struct smc_local));
+
+	// Setup the default Register Modes
+	lp->tcr_cur_mode = TCR_DEFAULT;
+	lp->rcr_cur_mode = RCR_DEFAULT;
+	lp->rpc_cur_mode = RPC_DEFAULT;
+
+	// Set default parameters (files)
+	lp->ctl_swfdup = 0;
+	lp->ctl_ephloop = 0;
+	lp->ctl_miiop = 0;
+	lp->ctl_autoneg = 1;
+	lp->ctl_rfduplx = 1;
+	lp->ctl_rspeed = 100;
+	lp->ctl_afduplx = 1;
+	lp->ctl_aspeed = 100;
+	lp->ctl_lnkfail = 1;
+	lp->ctl_forcol = 0;
+	lp->ctl_filtcar = 0;
+
+	/* reset the hardware */
+
+	smc_reset( dev );
+	smc_enable( dev );
+
+	/* Configure the PHY */
+	smc_phy_configure(dev);
+
+	/*
+  		According to Becker, I have to set the hardware address
+		at this point, because the (l)user can set it with an
+		ioctl.  Easily done...
+	*/
+	SMC_SELECT_BANK( 1 );
+	for ( i = 0; i < 6; i += 2 ) {
+		word	address;
+
+		address = dev->dev_addr[ i + 1 ] << 8 ;
+		address  |= dev->dev_addr[ i ];
+		SMC_outw( address, ioaddr + ADDR0_REG + i );
+	}
+
+#ifdef CONFIG_SYSCTL
+	smc_sysctl_register(dev);
+#endif /* CONFIG_SYSCTL */
+
+	netif_start_queue(dev);
+	return 0;
+}
+
+/*--------------------------------------------------------
+ . Called by the kernel to send a packet out into the void
+ . of the net.  This routine is largely based on
+ . skeleton.c, from Becker.
+ .--------------------------------------------------------
+*/
+static void smc_timeout(struct net_device *dev)
+{
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+
+	PRINTK3("%s:smc_timeout\n", dev->name);
+
+	/* If we get here, some higher level has decided we are broken.
+	   There should really be a "kick me" function call instead. */
+	printk(KERN_WARNING "%s: transmit timed out, %s?\n",
+		dev->name, tx_done(dev) ? "IRQ conflict" :
+		"network cable problem");
+	/* "kick" the adaptor */
+	smc_reset( dev );
+	smc_enable( dev );
+
+#if 0
+	/* Reconfiguring the PHY doesn't seem like a bad idea here, but
+	 * it introduced a problem.  Now that this is a timeout routine,
+	 * we are getting called from within an interrupt context.
+	 * smc_phy_configure() calls smc_wait_ms() which calls
+	 * schedule_timeout() which calls schedule().  When schedule()
+	 * is called from an interrupt context, it prints out
+	 * "Scheduling in interrupt" and then calls BUG().  This is
+	 * obviously not desirable.  This was worked around by removing
+	 * the call to smc_phy_configure() here because it didn't seem
+	 * absolutely necessary.  Ultimately, if smc_wait_ms() is
+	 * supposed to be usable from an interrupt context (which it
+	 * looks like it thinks it should handle), it should be fixed.
+	 */
+	/* Reconfigure the PHY */
+	smc_phy_configure(dev);
+#endif
+	dev->trans_start = jiffies;
+	/* clear anything saved */
+	if (lp->saved_skb != NULL) {
+		dev_kfree_skb (lp->saved_skb);
+		lp->saved_skb = NULL;
+	}
+	((struct smc_local *)dev->priv)->saved_skb = NULL;
+	netif_wake_queue(dev);
+}
+
+/*--------------------------------------------------------------------
+ .
+ . This is the main routine of the driver, to handle the device when
+ . it needs some attention.
+ .
+ . So:
+ .   first, save state of the chipset
+ .   branch off into routines to handle each case, and acknowledge
+ .	    each to the interrupt register
+ .   and finally restore state.
+ .
+ ---------------------------------------------------------------------*/
+static void smc_interrupt(int irq, void * dev_id,  struct pt_regs * regs)
+{
+	struct net_device *dev 	= dev_id;
+	unsigned long ioaddr	= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+
+	byte	status;
+	word	card_stats;
+	byte	mask;
+	int	timeout;
+	/* state registers */
+	word	saved_bank;
+	word	saved_pointer;
+
+	PRINTK3("%s: SMC interrupt started \n", dev->name);
+
+	if (dev == NULL) {
+		printk(KERN_WARNING "%s: irq %d for unknown device.\n",
+			dev->name, irq);
+		return;
+	}
+
+	saved_bank = SMC_CURRENT_BANK();
+
+	SMC_SELECT_BANK(2);
+	saved_pointer = SMC_GET_PTR();
+
+	/* read the interrupt mask register */
+	mask = SMC_GET_INT_MASK();
+
+	/* disable all interrupts */
+	SMC_SET_INT_MASK( 0 );
+
+	/* set a timeout value, so I don't stay here forever */
+	timeout = 4;
+
+	PRINTK2(KERN_WARNING "%s: MASK IS %x \n", dev->name, mask);
+	do {
+		/* read the status flag, and mask it */
+		status = SMC_GET_INT() & mask;
+		if (!status )
+			break;
+
+		PRINTK3(KERN_WARNING "%s: Handling interrupt status %x \n",
+			dev->name, status);
+
+		if (status & IM_RCV_INT) {
+			/* Got a packet(s). */
+			PRINTK2(KERN_WARNING
+				"%s: Receive Interrupt\n", dev->name);
+			smc_rcv(dev);
+		} else if (status & IM_TX_INT ) {
+			PRINTK2(KERN_WARNING "%s: TX ERROR handled\n",
+				dev->name);
+			smc_tx(dev);
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_TX_INT );
+		} else if (status & IM_TX_EMPTY_INT ) {
+			/* update stats */
+			SMC_SELECT_BANK( 0 );
+			card_stats = SMC_GET_COUNTER();
+			/* single collisions */
+			lp->stats.collisions += card_stats & 0xF;
+			card_stats >>= 4;
+			/* multiple collisions */
+			lp->stats.collisions += card_stats & 0xF;
+
+			/* these are for when linux supports these statistics */
+
+			SMC_SELECT_BANK( 2 );
+			PRINTK2(KERN_WARNING "%s: TX_BUFFER_EMPTY handled\n",
+				dev->name);
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_TX_EMPTY_INT );
+			mask &= ~IM_TX_EMPTY_INT;
+			lp->stats.tx_packets += lp->packets_waiting;
+			lp->packets_waiting = 0;
+
+		} else if (status & IM_ALLOC_INT ) {
+			PRINTK2(KERN_DEBUG "%s: Allocation interrupt \n",
+				dev->name);
+			/* clear this interrupt so it doesn't happen again */
+			mask &= ~IM_ALLOC_INT;
+
+			smc_hardware_send_packet( dev );
+
+			/* enable xmit interrupts based on this */
+			mask |= ( IM_TX_EMPTY_INT | IM_TX_INT );
+
+			/* and let the card send more packets to me */
+			netif_wake_queue(dev);
+
+			PRINTK2("%s: Handoff done successfully.\n",
+				dev->name);
+		} else if (status & IM_RX_OVRN_INT ) {
+			lp->stats.rx_errors++;
+			lp->stats.rx_fifo_errors++;
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_RX_OVRN_INT );
+		} else if (status & IM_EPH_INT ) {
+			PRINTK("%s: UNSUPPORTED: EPH INTERRUPT \n",
+				dev->name);
+		} else if (status & IM_MDINT ) {
+			smc_phy_interrupt(dev);
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_MDINT );
+		} else if (status & IM_ERCV_INT ) {
+			PRINTK("%s: UNSUPPORTED: ERCV INTERRUPT \n",
+				dev->name);
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_ERCV_INT );
+		}
+	} while ( timeout -- );
+
+
+	/* restore register states */
+
+	SMC_SELECT_BANK( 2 );
+
+	SMC_SET_INT_MASK( mask );
+
+	PRINTK3( KERN_WARNING "%s: MASK is now %x \n", dev->name, mask);
+	SMC_SET_PTR( saved_pointer );
+
+	SMC_SELECT_BANK( saved_bank );
+
+	PRINTK3("%s: Interrupt done\n", dev->name);
+	return;
+}
+
+/*-------------------------------------------------------------
+ .
+ . smc_rcv -  receive a packet from the card
+ .
+ . There is ( at least ) a packet waiting to be read from
+ . chip-memory.
+ .
+ . o Read the status
+ . o If an error, record it
+ . o otherwise, read in the packet
+ --------------------------------------------------------------
+*/
+static void smc_rcv(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	unsigned long ioaddr  = dev->base_addr;
+	int 	packet_number;
+	word	status;
+	word	packet_length;
+
+	PRINTK3("%s:smc_rcv\n", dev->name);
+
+	/* assume bank 2 */
+
+	packet_number = SMC_GET_RXFIFO();
+
+	if ( packet_number & RXFIFO_REMPTY ) {
+
+		/* we got called , but nothing was on the FIFO */
+		PRINTK("%s: WARNING: smc_rcv with nothing on FIFO. \n",
+			dev->name);
+		/* don't need to restore anything */
+		return;
+	}
+
+	/*  start reading from the start of the packet */
+	SMC_SET_PTR( PTR_READ | PTR_RCV | PTR_AUTOINC );
+
+	/* First two words are status and packet_length */
+	status 		= SMC_inw( ioaddr + DATA_REG );
+	packet_length 	= SMC_inw( ioaddr + DATA_REG );
+
+	packet_length &= 0x07ff;  /* mask off top bits */
+
+	PRINTK2("RCV: STATUS %4x LENGTH %4x\n", status, packet_length );
+
+	if ( !(status & RS_ERRORS ) ){
+		/* do stuff to make a new packet */
+		struct sk_buff  * skb;
+		byte		* data;
+
+		/* set multicast stats */
+		if ( status & RS_MULTICAST )
+			lp->stats.multicast++;
+
+		// Allocate enough memory for entire receive frame, to be safe
+		skb = dev_alloc_skb( packet_length );
+
+		/* Adjust for having already read the first two words */
+		packet_length -= 4;
+
+		if ( skb == NULL ) {
+			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
+				dev->name);
+			lp->stats.rx_dropped++;
+			goto done;
+		}
+
+		/*
+		 ! This should work without alignment, but it could be
+		 ! in the worse case
+		*/
+
+		skb_reserve( skb, 2 );   /* 16 bit alignment */
+
+		skb->dev = dev;
+
+		// set odd length for bug in LAN91C111,
+		// which never sets RS_ODDFRAME
+		data = skb_put( skb, packet_length + 1 );
+
+#ifdef CONFIG_SMC91111_USE_32_BIT
+		PRINTK3(" Reading %d dwords (and %d bytes) \n",
+			packet_length >> 2, packet_length & 3 );
+		/* QUESTION:  Like in the TX routine, do I want
+		   to send the DWORDs or the bytes first, or some
+		   mixture.  A mixture might improve already slow PIO
+		   performance  */
+		SMC_insl(ioaddr + DATA_REG , data, packet_length >> 2 );
+		/* read the left over bytes */
+#ifdef CONFIG_SMC91111_USE_8_BIT
+		SMC_insb( ioaddr + DATA_REG, data + (packet_length & 0xFFFFFC),
+			  packet_length & 0x3  );
+#else
+		if (packet_length & 0x3)
+		{
+			unsigned long remaining_data;
+			insl(ioaddr + DATA_REG , &remaining_data, 1);
+			memcpy(data + (packet_length & 0xFFFFFC),
+			       &remaining_data, packet_length & 0x3  );
+		}
+#endif // CONFIG_SMC91111_USE_8_BIT
+#else
+		PRINTK3(" Reading %d words and %d byte(s) \n",
+			(packet_length >> 1 ), packet_length & 1 );
+		SMC_insw(ioaddr + DATA_REG , data, packet_length >> 1);
+
+#endif // CONFIG_SMC91111_USE_32_BIT
+
+#if	SMC_DEBUG > 2
+		printk("Receiving Packet\n");
+		print_packet( data, packet_length );
+#endif
+
+		skb->protocol = eth_type_trans(skb, dev );
+		netif_rx(skb);
+		dev->last_rx = jiffies;
+		lp->stats.rx_packets++;
+		lp->stats.rx_bytes += packet_length;
+	} else {
+		/* error ... */
+		lp->stats.rx_errors++;
+
+		if ( status & RS_ALGNERR )  lp->stats.rx_frame_errors++;
+		if ( status & (RS_TOOSHORT | RS_TOOLONG ) )
+			lp->stats.rx_length_errors++;
+		if ( status & RS_BADCRC)	lp->stats.rx_crc_errors++;
+	}
+
+	while ( SMC_GET_MMU_CMD() & MC_BUSY )
+		udelay(1); // Wait until not busy
+
+done:
+	/*  error or good, tell the card to get rid of this packet */
+	SMC_SET_MMU_CMD( MC_RELEASE );
+}
+
+
+/*************************************************************************
+ . smc_tx
+ .
+ . Purpose:  Handle a transmit error message.   This will only be called
+ .   when an error, because of the AUTO_RELEASE mode.
+ .
+ . Algorithm:
+ .	Save pointer and packet no
+ .	Get the packet no from the top of the queue
+ .	check if it's valid ( if not, is this an error??? )
+ .	read the status word
+ .	record the error
+ .	( resend?  Not really, since we don't want old packets around )
+ .	Restore saved values
+ ************************************************************************/
+static void smc_tx( struct net_device * dev )
+{
+	unsigned long  ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte saved_packet;
+	byte packet_no;
+	word tx_status;
+
+
+	PRINTK3("%s:smc_tx\n", dev->name);
+
+	/* assume bank 2  */
+
+	saved_packet = SMC_GET_PN();
+	packet_no = SMC_GET_RXFIFO();
+	packet_no &= 0x7F;
+
+	/* If the TX FIFO is empty then nothing to do */
+	if ( packet_no & TXFIFO_TEMPTY )
+		return;
+
+	/* select this as the packet to read from */
+	SMC_SET_PN( packet_no );
+
+	/* read the first word (status word) from this packet */
+	SMC_SET_PTR( PTR_AUTOINC | PTR_READ );
+
+	tx_status = SMC_inw( ioaddr + DATA_REG );
+	PRINTK3("%s: TX DONE STATUS: %4x \n", dev->name, tx_status);
+
+	lp->stats.tx_errors++;
+	if ( tx_status & TS_LOSTCAR ) lp->stats.tx_carrier_errors++;
+	if ( tx_status & TS_LATCOL  ) {
+		printk(KERN_DEBUG
+			"%s: Late collision occurred on last xmit.\n",
+			dev->name);
+		lp->stats.tx_window_errors++;
+		lp->ctl_forcol = 0; // Reset forced collsion
+	}
+#if 0
+	if ( tx_status & TS_16COL ) { ... }
+#endif
+
+	if ( tx_status & TS_SUCCESS ) {
+		printk("%s: Successful packet caused interrupt \n", dev->name);
+	}
+	/* re-enable transmit */
+	SMC_SELECT_BANK( 0 );
+	SMC_SET_TCR( SMC_GET_TCR() | TCR_ENABLE );
+
+	/* kill the packet */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_MMU_CMD( MC_FREEPKT );
+
+	/* one less packet waiting for me */
+	lp->packets_waiting--;
+
+	/* Don't change Packet Number Reg until busy bit is cleared */
+	/* Per LAN91C111 Spec, Page 50 */
+	while ( SMC_GET_MMU_CMD() & MC_BUSY );
+
+	SMC_SET_PN( saved_packet );
+	return;
+}
+
+
+/*----------------------------------------------------
+ . smc_close
+ .
+ . this makes the board clean up everything that it can
+ . and not talk to the outside world.   Caused by
+ . an 'ifconfig ethX down'
+ .
+ -----------------------------------------------------*/
+static int smc_close(struct net_device *dev)
+{
+	PRINTK2("%s:smc_close\n", dev->name);
+
+	netif_stop_queue(dev);
+
+#ifdef CONFIG_SYSCTL
+	smc_sysctl_unregister(dev);
+#endif /* CONFIG_SYSCTL */
+
+	/* clear everything */
+	smc_shutdown( dev->base_addr );
+
+	/* Update the statistics here. */
+	return 0;
+}
+
+/*------------------------------------------------------------
+ . Get the current statistics.
+ . This may be called with the card open or closed.
+ .-------------------------------------------------------------*/
+static struct net_device_stats* smc_query_statistics(struct net_device *dev) {
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+
+	PRINTK2("%s:smc_query_statistics\n", dev->name);
+
+	return &lp->stats;
+}
+
+/*-----------------------------------------------------------
+ . smc_set_multicast_list
+ .
+ . This routine will, depending on the values passed to it,
+ . either make it accept multicast packets, go into
+ . promiscuous mode ( for TCPDUMP and cousins ) or accept
+ . a select set of multicast packets
+*/
+static void smc_set_multicast_list(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+
+	PRINTK2("%s:smc_set_multicast_list\n", dev->name);
+
+	SMC_SELECT_BANK(0);
+	if ( dev->flags & IFF_PROMISC ) {
+		PRINTK2("%s:smc_set_multicast_list:RCR_PRMS\n", dev->name);
+		SMC_SET_RCR( SMC_GET_RCR() | RCR_PRMS );
+	}
+
+/* BUG?  I never disable promiscuous mode if multicasting was turned on.
+   Now, I turn off promiscuous mode, but I don't do anything to multicasting
+   when promiscuous mode is turned on.
+*/
+
+	/* Here, I am setting this to accept all multicast packets.
+	   I don't need to zero the multicast table, because the flag is
+	   checked before the table is
+	*/
+	else if (dev->flags & IFF_ALLMULTI) {
+		SMC_SET_RCR( SMC_GET_RCR() | RCR_ALMUL );
+		PRINTK2("%s:smc_set_multicast_list:RCR_ALMUL\n", dev->name);
+	}
+
+	/* We just get all multicast packets even if we only want them
+	 . from one source.  This will be changed at some future
+	 . point. */
+	else if (dev->mc_count )  {
+		/* support hardware multicasting */
+
+		/* be sure I get rid of flags I might have set */
+		SMC_SET_RCR( SMC_GET_RCR() & ~(RCR_PRMS | RCR_ALMUL) );
+		/* NOTE: this has to set the bank, so make sure it is the
+		   last thing called.  The bank is set to zero at the top */
+		smc_setmulticast( ioaddr, dev->mc_count, dev->mc_list );
+	} else  {
+		PRINTK2("%s:smc_set_multicast_list:~(RCR_PRMS|RCR_ALMUL)\n",
+			dev->name);
+		SMC_SET_RCR( SMC_GET_RCR() & ~(RCR_PRMS | RCR_ALMUL) );
+
+		/*
+		  since I'm disabling all multicast entirely, I need to
+		  clear the multicast list
+		*/
+		SMC_SELECT_BANK( 3 );
+		SMC_CLEAR_MCAST();
+	}
+}
+
+/*------------------------------------------------------------
+ . Cleanup when module is removed with rmmod
+ .-------------------------------------------------------------*/
+static void __exit smc_cleanup(void)
+{
+	/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
+	unregister_netdev(global_dev);
+
+	free_irq(global_dev->irq, global_dev);
+	release_region(global_dev->base_addr, SMC_IO_EXTENT);
+
+#ifndef CONFIG_ISA
+	iounmap((void *)global_dev->base_addr);
+#endif
+
+	kfree(global_dev);
+	global_dev = NULL;
+}
+
+module_init(smc_init);
+module_exit(smc_cleanup);
+
+
+#ifdef CONFIG_SYSCTL
+/*------------------------------------------------------------
+ . Modify a bit in the LAN91C111 register set
+ .-------------------------------------------------------------*/
+static word smc_modify_regbit(int bank, unsigned long ioaddr, int reg,
+	unsigned int bit, int val)
+{
+	word regval;
+
+	SMC_SELECT_BANK( bank );
+
+	regval = SMC_inw( ioaddr+reg );
+	if (val)
+		regval |= bit;
+	else
+		regval &= ~bit;
+
+	SMC_outw( regval, ioaddr );
+	return(regval);
+}
+
+
+/*------------------------------------------------------------
+ . Retrieve a bit in the LAN91C111 register set
+ .-------------------------------------------------------------*/
+static int smc_get_regbit(int bank, unsigned long ioaddr,
+			  int reg, unsigned int bit)
+{
+	SMC_SELECT_BANK( bank );
+	if ( SMC_inw( ioaddr+reg ) & bit)
+		return(1);
+	else
+		return(0);
+}
+
+
+/*------------------------------------------------------------
+ . Modify a LAN91C111 register (word access only)
+ .-------------------------------------------------------------*/
+static void smc_modify_reg(int bank, unsigned long ioaddr,
+			   int reg, word val)
+{
+	SMC_SELECT_BANK( bank );
+	SMC_outw( val, ioaddr+reg );
+}
+
+
+/*------------------------------------------------------------
+ . Retrieve a LAN91C111 register (word access only)
+ .-------------------------------------------------------------*/
+static int smc_get_reg(int bank, unsigned long ioaddr,
+		       int reg)
+{
+	SMC_SELECT_BANK( bank );
+	return(SMC_inw( ioaddr+reg ));
+}
+
+
+static const char smc_info_string[] =
+"\n"
+"info           Provides this information blurb\n"
+"swver          Prints the software version information of this driver\n"
+"autoneg        Auto-negotiate Mode = 1\n"
+"rspeed         Requested Speed, 100=100Mbps, 10=10Mpbs\n"
+"rfduplx        Requested Full Duplex Operation\n"
+"aspeed         Actual Speed, 100=100Mbps, 10=10Mpbs\n"
+"afduplx        Actual Full Duplex Operation\n"
+"lnkfail        PHY Link Failure when 1\n"
+"miiop          External MII when 1, Internal PHY when 0\n"
+"swfdup         Switched Full Duplex Mode (allowed only in MII operation)\n"
+"ephloop        EPH Block Loopback\n"
+"forcol         Force a collision\n"
+"filtcar        Filter leading edge of carrier sense for 12 bit times\n"
+"freemem        Free buffer memory in bytes\n"
+"totmem         Total buffer memory in bytes\n"
+"leda           Output of LED-A (green)\n"
+"ledb           Output of LED-B (yellow)\n"
+"chiprev        Revision ID of the LAN91C111 chip\n"
+"";
+
+/*------------------------------------------------------------
+ . Sysctl handler for all integer parameters
+ .-------------------------------------------------------------*/
+static int smc_sysctl_handler(ctl_table *ctl, int write, struct file * filp,
+				void *buffer, size_t *lenp)
+{
+	struct net_device *dev = (struct net_device*)ctl->extra1;
+	struct smc_local *lp = (struct smc_local *)ctl->extra2;
+	unsigned long ioaddr = dev->base_addr;
+	int *valp = ctl->data;
+	int val;
+	int ret;
+
+	// Update parameters from the real registers
+	switch (ctl->ctl_name)
+	{
+	case CTL_SMC_FORCOL:
+		*valp = smc_get_regbit(0, ioaddr, TCR_REG, TCR_FORCOL);
+		break;
+
+	case CTL_SMC_FREEMEM:
+		*valp = ( (word)smc_get_reg(0, ioaddr, MIR_REG) >> 8 )
+			* LAN91C111_MEMORY_MULTIPLIER;
+		break;
+
+
+	case CTL_SMC_TOTMEM:
+		*valp = ( smc_get_reg(0, ioaddr, MIR_REG) & (word)0x00ff )
+			* LAN91C111_MEMORY_MULTIPLIER;
+		break;
+
+	case CTL_SMC_CHIPREV:
+		*valp = smc_get_reg(3, ioaddr, REV_REG);
+		break;
+
+	case CTL_SMC_AFDUPLX:
+		*valp = (lp->lastPhy18 & PHY_INT_DPLXDET) ? 1 : 0;
+		break;
+
+	case CTL_SMC_ASPEED:
+		*valp = (lp->lastPhy18 & PHY_INT_SPDDET) ? 100 : 10;
+		break;
+
+	case CTL_SMC_LNKFAIL:
+		*valp = (lp->lastPhy18 & PHY_INT_LNKFAIL) ? 1 : 0;
+		break;
+
+	case CTL_SMC_LEDA:
+		*valp = (lp->rpc_cur_mode >> RPC_LSXA_SHFT) & (word)0x0007;
+		break;
+
+	case CTL_SMC_LEDB:
+		*valp = (lp->rpc_cur_mode >> RPC_LSXB_SHFT) & (word)0x0007;
+		break;
+
+	case CTL_SMC_MIIOP:
+		*valp = smc_get_regbit(1, ioaddr, CONFIG_REG, CONFIG_EXT_PHY);
+		break;
+
+#if SMC_DEBUG > 1
+	case CTL_SMC_REG_BSR:	// Bank Select
+		*valp = smc_get_reg(0, ioaddr, BSR_REG);
+		break;
+
+	case CTL_SMC_REG_TCR:	// Transmit Control
+		*valp = smc_get_reg(0, ioaddr, TCR_REG);
+		break;
+
+	case CTL_SMC_REG_ESR:	// EPH Status
+		*valp = smc_get_reg(0, ioaddr, EPH_STATUS_REG);
+		break;
+
+	case CTL_SMC_REG_RCR:	// Receive Control
+		*valp = smc_get_reg(0, ioaddr, RCR_REG);
+		break;
+
+	case CTL_SMC_REG_CTRR:	// Counter
+		*valp = smc_get_reg(0, ioaddr, COUNTER_REG);
+		break;
+
+	case CTL_SMC_REG_MIR:	// Memory Information
+		*valp = smc_get_reg(0, ioaddr, MIR_REG);
+		break;
+
+	case CTL_SMC_REG_RPCR:	// Receive/Phy Control
+		*valp = smc_get_reg(0, ioaddr, RPC_REG);
+		break;
+
+	case CTL_SMC_REG_CFGR:	// Configuration
+		*valp = smc_get_reg(1, ioaddr, CONFIG_REG);
+		break;
+
+	case CTL_SMC_REG_BAR:	// Base Address
+		*valp = smc_get_reg(1, ioaddr, BASE_REG);
+		break;
+
+	case CTL_SMC_REG_IAR0:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR0_REG);
+		break;
+
+	case CTL_SMC_REG_IAR1:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR1_REG);
+		break;
+
+	case CTL_SMC_REG_IAR2:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR2_REG);
+		break;
+
+	case CTL_SMC_REG_GPR:	// General Purpose
+		*valp = smc_get_reg(1, ioaddr, GP_REG);
+		break;
+
+	case CTL_SMC_REG_CTLR:	// Control
+		*valp = smc_get_reg(1, ioaddr, CTL_REG);
+		break;
+
+	case CTL_SMC_REG_MCR:	// MMU Command
+		*valp = smc_get_reg(2, ioaddr, MMU_CMD_REG);
+		break;
+
+	case CTL_SMC_REG_PNR:	// Packet Number
+		*valp = smc_get_reg(2, ioaddr, PN_REG);
+		break;
+
+	case CTL_SMC_REG_FPR:	// Allocation Result/FIFO Ports
+		*valp = smc_get_reg(2, ioaddr, RXFIFO_REG);
+		break;
+
+	case CTL_SMC_REG_PTR:	// Pointer
+		*valp = smc_get_reg(2, ioaddr, PTR_REG);
+		break;
+
+	case CTL_SMC_REG_DR:	// Data
+		*valp = smc_get_reg(2, ioaddr, DATA_REG);
+		break;
+
+	case CTL_SMC_REG_ISR:	// Interrupt Status/Mask
+		*valp = smc_get_reg(2, ioaddr, INT_REG);
+		break;
+
+	case CTL_SMC_REG_MTR1:	// Multicast Table Entry 1
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG1);
+		break;
+
+	case CTL_SMC_REG_MTR2:	// Multicast Table Entry 2
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG2);
+		break;
+
+	case CTL_SMC_REG_MTR3:	// Multicast Table Entry 3
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG3);
+		break;
+
+	case CTL_SMC_REG_MTR4:	// Multicast Table Entry 4
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG4);
+		break;
+
+	case CTL_SMC_REG_MIIR:	// Management Interface
+		*valp = smc_get_reg(3, ioaddr, MII_REG);
+		break;
+
+	case CTL_SMC_REG_REVR:	// Revision
+		*valp = smc_get_reg(3, ioaddr, REV_REG);
+		break;
+
+	case CTL_SMC_REG_ERCVR:	// Early RCV
+		*valp = smc_get_reg(3, ioaddr, ERCV_REG);
+		break;
+
+	case CTL_SMC_REG_EXTR:	// External
+		*valp = smc_get_reg(7, ioaddr, EXT_REG);
+		break;
+
+	case CTL_SMC_PHY_CTRL:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CNTL_REG);
+		break;
+
+	case CTL_SMC_PHY_STAT:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_STAT_REG);
+		break;
+
+	case CTL_SMC_PHY_ID1:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_ID1_REG);
+		break;
+
+	case CTL_SMC_PHY_ID2:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_ID2_REG);
+		break;
+
+	case CTL_SMC_PHY_ADC:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_AD_REG);
+		break;
+
+	case CTL_SMC_PHY_REMC:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_RMT_REG);
+		break;
+
+	case CTL_SMC_PHY_CFG1:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CFG1_REG);
+		break;
+
+	case CTL_SMC_PHY_CFG2:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CFG2_REG);
+		break;
+
+	case CTL_SMC_PHY_INT:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_INT_REG);
+		break;
+
+	case CTL_SMC_PHY_MASK:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_MASK_REG);
+		break;
+
+#endif // SMC_DEBUG > 1
+
+	default:
+		// Just ignore unsupported parameters
+		break;
+	}
+
+	// Save old state
+	val = *valp;
+
+	// Perform the generic integer operation
+	if ((ret = proc_dointvec(ctl, write, filp, buffer, lenp)) != 0)
+		return(ret);
+
+	// Write changes out to the registers
+	if (write && *valp != val) {
+
+		val = *valp;
+		switch (ctl->ctl_name) {
+
+		case CTL_SMC_SWFDUP:
+			if (val)
+				lp->tcr_cur_mode |= TCR_SWFDUP;
+			else
+				lp->tcr_cur_mode &= ~TCR_SWFDUP;
+
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_SWFDUP, val);
+			break;
+
+		case CTL_SMC_EPHLOOP:
+			if (val)
+				lp->tcr_cur_mode |= TCR_EPH_LOOP;
+			else
+				lp->tcr_cur_mode &= ~TCR_EPH_LOOP;
+
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_EPH_LOOP, val);
+			break;
+
+		case CTL_SMC_FORCOL:
+			if (val)
+				lp->tcr_cur_mode |= TCR_FORCOL;
+			else
+				lp->tcr_cur_mode &= ~TCR_FORCOL;
+
+			// Update the EPH block
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_FORCOL, val);
+			break;
+
+		case CTL_SMC_FILTCAR:
+			if (val)
+				lp->rcr_cur_mode |= RCR_FILT_CAR;
+			else
+				lp->rcr_cur_mode &= ~RCR_FILT_CAR;
+
+			// Update the EPH block
+			smc_modify_regbit(0, ioaddr, RCR_REG, RCR_FILT_CAR, val);
+			break;
+
+		case CTL_SMC_RFDUPLX:
+			// Disallow changes if in auto-negotiation mode
+			if (lp->ctl_autoneg)
+				break;
+
+			if (val)
+				lp->rpc_cur_mode |= RPC_DPLX;
+			else
+				lp->rpc_cur_mode &= ~RPC_DPLX;
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_RSPEED:
+			// Disallow changes if in auto-negotiation mode
+			if (lp->ctl_autoneg)
+				break;
+
+			if (val > 10)
+				lp->rpc_cur_mode |= RPC_SPEED;
+			else
+				lp->rpc_cur_mode &= ~RPC_SPEED;
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_AUTONEG:
+			if (val)
+				lp->rpc_cur_mode |= RPC_ANEG;
+			else
+				lp->rpc_cur_mode &= ~RPC_ANEG;
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_LEDA:
+			val &= 0x07; // Restrict to 3 ls bits
+			lp->rpc_cur_mode &= ~(word)(0x07<<RPC_LSXA_SHFT);
+			lp->rpc_cur_mode |= (word)(val<<RPC_LSXA_SHFT);
+
+			// Update the Internal PHY block
+			smc_modify_reg(0, ioaddr, RPC_REG, lp->rpc_cur_mode);
+			break;
+
+		case CTL_SMC_LEDB:
+			val &= 0x07; // Restrict to 3 ls bits
+			lp->rpc_cur_mode &= ~(word)(0x07<<RPC_LSXB_SHFT);
+			lp->rpc_cur_mode |= (word)(val<<RPC_LSXB_SHFT);
+
+			// Update the Internal PHY block
+			smc_modify_reg(0, ioaddr, RPC_REG, lp->rpc_cur_mode);
+			break;
+
+		case CTL_SMC_MIIOP:
+			// Update the Internal PHY block
+			smc_modify_regbit(1, ioaddr, CONFIG_REG,
+				CONFIG_EXT_PHY, val);
+			break;
+
+#if SMC_DEBUG > 1
+		case CTL_SMC_REG_BSR:	// Bank Select
+			smc_modify_reg(0, ioaddr, BSR_REG, val);
+			break;
+
+		case CTL_SMC_REG_TCR:	// Transmit Control
+			smc_modify_reg(0, ioaddr, TCR_REG, val);
+			break;
+
+		case CTL_SMC_REG_ESR:	// EPH Status
+			smc_modify_reg(0, ioaddr, EPH_STATUS_REG, val);
+			break;
+
+		case CTL_SMC_REG_RCR:	// Receive Control
+			smc_modify_reg(0, ioaddr, RCR_REG, val);
+			break;
+
+		case CTL_SMC_REG_CTRR:	// Counter
+			smc_modify_reg(0, ioaddr, COUNTER_REG, val);
+			break;
+
+		case CTL_SMC_REG_MIR:	// Memory Information
+			smc_modify_reg(0, ioaddr, MIR_REG, val);
+			break;
+
+		case CTL_SMC_REG_RPCR:	// Receive/Phy Control
+			smc_modify_reg(0, ioaddr, RPC_REG, val);
+			break;
+
+		case CTL_SMC_REG_CFGR:	// Configuration
+			smc_modify_reg(1, ioaddr, CONFIG_REG, val);
+			break;
+
+		case CTL_SMC_REG_BAR:	// Base Address
+			smc_modify_reg(1, ioaddr, BASE_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR0:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR0_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR1:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR1_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR2:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR2_REG, val);
+			break;
+
+		case CTL_SMC_REG_GPR:	// General Purpose
+			smc_modify_reg(1, ioaddr, GP_REG, val);
+			break;
+
+		case CTL_SMC_REG_CTLR:	// Control
+			smc_modify_reg(1, ioaddr, CTL_REG, val);
+			break;
+
+		case CTL_SMC_REG_MCR:	// MMU Command
+			smc_modify_reg(2, ioaddr, MMU_CMD_REG, val);
+			break;
+
+		case CTL_SMC_REG_PNR:	// Packet Number
+			smc_modify_reg(2, ioaddr, PN_REG, val);
+			break;
+
+		case CTL_SMC_REG_FPR:	// Allocation Result/FIFO Ports
+			smc_modify_reg(2, ioaddr, RXFIFO_REG, val);
+			break;
+
+		case CTL_SMC_REG_PTR:	// Pointer
+			smc_modify_reg(2, ioaddr, PTR_REG, val);
+			break;
+
+		case CTL_SMC_REG_DR:	// Data
+			smc_modify_reg(2, ioaddr, DATA_REG, val);
+			break;
+
+		case CTL_SMC_REG_ISR:	// Interrupt Status/Mask
+			smc_modify_reg(2, ioaddr, INT_REG, val);
+			break;
+
+		case CTL_SMC_REG_MTR1:	// Multicast Table Entry 1
+			smc_modify_reg(3, ioaddr, MCAST_REG1, val);
+			break;
+
+		case CTL_SMC_REG_MTR2:	// Multicast Table Entry 2
+			smc_modify_reg(3, ioaddr, MCAST_REG2, val);
+			break;
+
+		case CTL_SMC_REG_MTR3:	// Multicast Table Entry 3
+			smc_modify_reg(3, ioaddr, MCAST_REG3, val);
+			break;
+
+		case CTL_SMC_REG_MTR4:	// Multicast Table Entry 4
+			smc_modify_reg(3, ioaddr, MCAST_REG4, val);
+			break;
+
+		case CTL_SMC_REG_MIIR:	// Management Interface
+			smc_modify_reg(3, ioaddr, MII_REG, val);
+			break;
+
+		case CTL_SMC_REG_REVR:	// Revision
+			smc_modify_reg(3, ioaddr, REV_REG, val);
+			break;
+
+		case CTL_SMC_REG_ERCVR:	// Early RCV
+			smc_modify_reg(3, ioaddr, ERCV_REG, val);
+			break;
+
+		case CTL_SMC_REG_EXTR:	// External
+			smc_modify_reg(7, ioaddr, EXT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CTRL:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CNTL_REG, val);
+			break;
+
+		case CTL_SMC_PHY_STAT:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_STAT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ID1:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_ID1_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ID2:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_ID2_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ADC:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_AD_REG, val);
+			break;
+
+		case CTL_SMC_PHY_REMC:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_RMT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CFG1:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CFG1_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CFG2:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CFG2_REG, val);
+			break;
+
+		case CTL_SMC_PHY_INT:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_INT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_MASK:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_MASK_REG, val);
+			break;
+
+#endif // SMC_DEBUG > 1
+
+		default:
+			// Just ignore unsupported parameters
+			break;
+		} // end switch
+
+	} // end if
+
+        return ret;
+}
+
+
+#ifdef MODULE
+/*
+ * This is called as the fill_inode function when an inode
+ * is going into (fill = 1) or out of service (fill = 0).
+ * We use it here to manage the module use counts.
+ *
+ * Note: only the top-level directory needs to do this; if
+ * a lower level is referenced, the parent will be as well.
+ */
+static void smc_procfs_modcount(struct inode *inode, int fill)
+{
+	if (fill)
+		MOD_INC_USE_COUNT;
+	else
+		MOD_DEC_USE_COUNT;
+}
+#endif // MODULE
+
+/*------------------------------------------------------------
+ . Sysctl registration function for all parameters (files)
+ .-------------------------------------------------------------*/
+static void smc_sysctl_register(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	static int ctl_name = CTL_SMC;
+	ctl_table* ct;
+	int i;
+
+	// Make sure the ctl_tables start out as all zeros
+	memset(lp->root_table, 0, sizeof lp->root_table);
+	memset(lp->eth_table, 0, sizeof lp->eth_table);
+	memset(lp->param_table, 0, sizeof lp->param_table);
+
+	// Initialize the root table
+	ct = lp->root_table;
+	ct->ctl_name = CTL_DEV;
+	ct->procname = "dev";
+	ct->maxlen = 0;
+	ct->mode = 0555;
+	ct->child = lp->eth_table;
+	// remaining fields are zero
+
+	// Initialize the ethX table (this device's table)
+	ct = lp->eth_table;
+	ct->ctl_name = ctl_name++; // Must be unique
+	ct->procname = dev->name;
+	ct->maxlen = 0;
+	ct->mode = 0555;
+	ct->child = lp->param_table;
+	// remaining fields are zero
+
+	// Initialize the parameter (files) table
+	// Make sure the last entry remains null
+	ct = lp->param_table;
+	for (i = 0; i < (CTL_SMC_LAST_ENTRY-1); ++i) {
+		// Initialize fields common to all table entries
+		ct[i].proc_handler = smc_sysctl_handler;
+		ct[i].extra1 = (void*)dev; // Save our device pointer
+		ct[i].extra2 = (void*)lp;  // Save our smc_local data pointer
+	}
+
+	// INFO - this is our only string parameter
+	i = 0;
+	ct[i].proc_handler = proc_dostring; // use default handler
+	ct[i].ctl_name = CTL_SMC_INFO;
+	ct[i].procname = "info";
+	ct[i].data = (void*)smc_info_string;
+	ct[i].maxlen = sizeof smc_info_string;
+	ct[i].mode = 0444; // Read only
+
+	// SWVER
+	++i;
+	ct[i].proc_handler = proc_dostring; // use default handler
+	ct[i].ctl_name = CTL_SMC_SWVER;
+	ct[i].procname = "swver";
+	ct[i].data = (void*)version;
+	ct[i].maxlen = sizeof version;
+	ct[i].mode = 0444; // Read only
+
+	// SWFDUP
+	++i;
+	ct[i].ctl_name = CTL_SMC_SWFDUP;
+	ct[i].procname = "swfdup";
+	ct[i].data = (void*)&(lp->ctl_swfdup);
+	ct[i].maxlen = sizeof lp->ctl_swfdup;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// EPHLOOP
+	++i;
+	ct[i].ctl_name = CTL_SMC_EPHLOOP;
+	ct[i].procname = "ephloop";
+	ct[i].data = (void*)&(lp->ctl_ephloop);
+	ct[i].maxlen = sizeof lp->ctl_ephloop;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// MIIOP
+	++i;
+	ct[i].ctl_name = CTL_SMC_MIIOP;
+	ct[i].procname = "miiop";
+	ct[i].data = (void*)&(lp->ctl_miiop);
+	ct[i].maxlen = sizeof lp->ctl_miiop;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// AUTONEG
+	++i;
+	ct[i].ctl_name = CTL_SMC_AUTONEG;
+	ct[i].procname = "autoneg";
+	ct[i].data = (void*)&(lp->ctl_autoneg);
+	ct[i].maxlen = sizeof lp->ctl_autoneg;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// RFDUPLX
+	++i;
+	ct[i].ctl_name = CTL_SMC_RFDUPLX;
+	ct[i].procname = "rfduplx";
+	ct[i].data = (void*)&(lp->ctl_rfduplx);
+	ct[i].maxlen = sizeof lp->ctl_rfduplx;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// RSPEED
+	++i;
+	ct[i].ctl_name = CTL_SMC_RSPEED;
+	ct[i].procname = "rspeed";
+	ct[i].data = (void*)&(lp->ctl_rspeed);
+	ct[i].maxlen = sizeof lp->ctl_rspeed;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// AFDUPLX
+	++i;
+	ct[i].ctl_name = CTL_SMC_AFDUPLX;
+	ct[i].procname = "afduplx";
+	ct[i].data = (void*)&(lp->ctl_afduplx);
+	ct[i].maxlen = sizeof lp->ctl_afduplx;
+	ct[i].mode = 0444; // Read only
+
+	// ASPEED
+	++i;
+	ct[i].ctl_name = CTL_SMC_ASPEED;
+	ct[i].procname = "aspeed";
+	ct[i].data = (void*)&(lp->ctl_aspeed);
+	ct[i].maxlen = sizeof lp->ctl_aspeed;
+	ct[i].mode = 0444; // Read only
+
+	// LNKFAIL
+	++i;
+	ct[i].ctl_name = CTL_SMC_LNKFAIL;
+	ct[i].procname = "lnkfail";
+	ct[i].data = (void*)&(lp->ctl_lnkfail);
+	ct[i].maxlen = sizeof lp->ctl_lnkfail;
+	ct[i].mode = 0444; // Read only
+
+	// FORCOL
+	++i;
+	ct[i].ctl_name = CTL_SMC_FORCOL;
+	ct[i].procname = "forcol";
+	ct[i].data = (void*)&(lp->ctl_forcol);
+	ct[i].maxlen = sizeof lp->ctl_forcol;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// FILTCAR
+	++i;
+	ct[i].ctl_name = CTL_SMC_FILTCAR;
+	ct[i].procname = "filtcar";
+	ct[i].data = (void*)&(lp->ctl_filtcar);
+	ct[i].maxlen = sizeof lp->ctl_filtcar;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// FREEMEM
+	++i;
+	ct[i].ctl_name = CTL_SMC_FREEMEM;
+	ct[i].procname = "freemem";
+	ct[i].data = (void*)&(lp->ctl_freemem);
+	ct[i].maxlen = sizeof lp->ctl_freemem;
+	ct[i].mode = 0444; // Read only
+
+	// TOTMEM
+	++i;
+	ct[i].ctl_name = CTL_SMC_TOTMEM;
+	ct[i].procname = "totmem";
+	ct[i].data = (void*)&(lp->ctl_totmem);
+	ct[i].maxlen = sizeof lp->ctl_totmem;
+	ct[i].mode = 0444; // Read only
+
+	// LEDA
+	++i;
+	ct[i].ctl_name = CTL_SMC_LEDA;
+	ct[i].procname = "leda";
+	ct[i].data = (void*)&(lp->ctl_leda);
+	ct[i].maxlen = sizeof lp->ctl_leda;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// LEDB
+	++i;
+	ct[i].ctl_name = CTL_SMC_LEDB;
+	ct[i].procname = "ledb";
+	ct[i].data = (void*)&(lp->ctl_ledb);
+	ct[i].maxlen = sizeof lp->ctl_ledb;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// CHIPREV
+	++i;
+	ct[i].ctl_name = CTL_SMC_CHIPREV;
+	ct[i].procname = "chiprev";
+	ct[i].data = (void*)&(lp->ctl_chiprev);
+	ct[i].maxlen = sizeof lp->ctl_chiprev;
+	ct[i].mode = 0444; // Read only
+
+#if SMC_DEBUG > 1
+	// REG_BSR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_BSR;
+	ct[i].procname = "reg_bsr";
+	ct[i].data = (void*)&(lp->ctl_reg_bsr);
+	ct[i].maxlen = sizeof lp->ctl_reg_bsr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_TCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_TCR;
+	ct[i].procname = "reg_tcr";
+	ct[i].data = (void*)&(lp->ctl_reg_tcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_tcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ESR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ESR;
+	ct[i].procname = "reg_esr";
+	ct[i].data = (void*)&(lp->ctl_reg_esr);
+	ct[i].maxlen = sizeof lp->ctl_reg_esr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_RCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_RCR;
+	ct[i].procname = "reg_rcr";
+	ct[i].data = (void*)&(lp->ctl_reg_rcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_rcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CTRR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CTRR;
+	ct[i].procname = "reg_ctrr";
+	ct[i].data = (void*)&(lp->ctl_reg_ctrr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ctrr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MIR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MIR;
+	ct[i].procname = "reg_mir";
+	ct[i].data = (void*)&(lp->ctl_reg_mir);
+	ct[i].maxlen = sizeof lp->ctl_reg_mir;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_RPCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_RPCR;
+	ct[i].procname = "reg_rpcr";
+	ct[i].data = (void*)&(lp->ctl_reg_rpcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_rpcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CFGR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CFGR;
+	ct[i].procname = "reg_cfgr";
+	ct[i].data = (void*)&(lp->ctl_reg_cfgr);
+	ct[i].maxlen = sizeof lp->ctl_reg_cfgr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_BAR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_BAR;
+	ct[i].procname = "reg_bar";
+	ct[i].data = (void*)&(lp->ctl_reg_bar);
+	ct[i].maxlen = sizeof lp->ctl_reg_bar;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR0
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR0;
+	ct[i].procname = "reg_iar0";
+	ct[i].data = (void*)&(lp->ctl_reg_iar0);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar0;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR1
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR1;
+	ct[i].procname = "reg_iar1";
+	ct[i].data = (void*)&(lp->ctl_reg_iar1);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR2
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR2;
+	ct[i].procname = "reg_iar2";
+	ct[i].data = (void*)&(lp->ctl_reg_iar2);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_GPR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_GPR;
+	ct[i].procname = "reg_gpr";
+	ct[i].data = (void*)&(lp->ctl_reg_gpr);
+	ct[i].maxlen = sizeof lp->ctl_reg_gpr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CTLR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CTLR;
+	ct[i].procname = "reg_ctlr";
+	ct[i].data = (void*)&(lp->ctl_reg_ctlr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ctlr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MCR;
+	ct[i].procname = "reg_mcr";
+	ct[i].data = (void*)&(lp->ctl_reg_mcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_mcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_PNR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_PNR;
+	ct[i].procname = "reg_pnr";
+	ct[i].data = (void*)&(lp->ctl_reg_pnr);
+	ct[i].maxlen = sizeof lp->ctl_reg_pnr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_FPR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_FPR;
+	ct[i].procname = "reg_fpr";
+	ct[i].data = (void*)&(lp->ctl_reg_fpr);
+	ct[i].maxlen = sizeof lp->ctl_reg_fpr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_PTR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_PTR;
+	ct[i].procname = "reg_ptr";
+	ct[i].data = (void*)&(lp->ctl_reg_ptr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ptr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_DR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_DR;
+	ct[i].procname = "reg_dr";
+	ct[i].data = (void*)&(lp->ctl_reg_dr);
+	ct[i].maxlen = sizeof lp->ctl_reg_dr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ISR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ISR;
+	ct[i].procname = "reg_isr";
+	ct[i].data = (void*)&(lp->ctl_reg_isr);
+	ct[i].maxlen = sizeof lp->ctl_reg_isr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR1
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR1;
+	ct[i].procname = "reg_mtr1";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr1);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR2
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR2;
+	ct[i].procname = "reg_mtr2";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr2);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR3
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR3;
+	ct[i].procname = "reg_mtr3";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr3);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr3;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR4
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR4;
+	ct[i].procname = "reg_mtr4";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr4);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr4;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MIIR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MIIR;
+	ct[i].procname = "reg_miir";
+	ct[i].data = (void*)&(lp->ctl_reg_miir);
+	ct[i].maxlen = sizeof lp->ctl_reg_miir;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_REVR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_REVR;
+	ct[i].procname = "reg_revr";
+	ct[i].data = (void*)&(lp->ctl_reg_revr);
+	ct[i].maxlen = sizeof lp->ctl_reg_revr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ERCVR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ERCVR;
+	ct[i].procname = "reg_ercvr";
+	ct[i].data = (void*)&(lp->ctl_reg_ercvr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ercvr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_EXTR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_EXTR;
+	ct[i].procname = "reg_extr";
+	ct[i].data = (void*)&(lp->ctl_reg_extr);
+	ct[i].maxlen = sizeof lp->ctl_reg_extr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Control
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CTRL;
+	ct[i].procname = "phy_ctrl";
+	ct[i].data = (void*)&(lp->ctl_phy_ctrl);
+	ct[i].maxlen = sizeof lp->ctl_phy_ctrl;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Status
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_STAT;
+	ct[i].procname = "phy_stat";
+	ct[i].data = (void*)&(lp->ctl_phy_stat);
+	ct[i].maxlen = sizeof lp->ctl_phy_stat;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY ID1
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ID1;
+	ct[i].procname = "phy_id1";
+	ct[i].data = (void*)&(lp->ctl_phy_id1);
+	ct[i].maxlen = sizeof lp->ctl_phy_id1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY ID2
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ID2;
+	ct[i].procname = "phy_id2";
+	ct[i].data = (void*)&(lp->ctl_phy_id2);
+	ct[i].maxlen = sizeof lp->ctl_phy_id2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Advertise Capabilities
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ADC;
+	ct[i].procname = "phy_adc";
+	ct[i].data = (void*)&(lp->ctl_phy_adc);
+	ct[i].maxlen = sizeof lp->ctl_phy_adc;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Remote Capabilities
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_REMC;
+	ct[i].procname = "phy_remc";
+	ct[i].data = (void*)&(lp->ctl_phy_remc);
+	ct[i].maxlen = sizeof lp->ctl_phy_remc;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Configuration 1
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CFG1;
+	ct[i].procname = "phy_cfg1";
+	ct[i].data = (void*)&(lp->ctl_phy_cfg1);
+	ct[i].maxlen = sizeof lp->ctl_phy_cfg1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Configuration 2
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CFG2;
+	ct[i].procname = "phy_cfg2";
+	ct[i].data = (void*)&(lp->ctl_phy_cfg2);
+	ct[i].maxlen = sizeof lp->ctl_phy_cfg2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Interrupt/Status Output
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_INT;
+	ct[i].procname = "phy_int";
+	ct[i].data = (void*)&(lp->ctl_phy_int);
+	ct[i].maxlen = sizeof lp->ctl_phy_int;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Interrupt/Status Mask
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_MASK;
+	ct[i].procname = "phy_mask";
+	ct[i].data = (void*)&(lp->ctl_phy_mask);
+	ct[i].maxlen = sizeof lp->ctl_phy_mask;
+	ct[i].mode = 0644; // Read by all, write by root
+
+#endif // SMC_DEBUG > 1
+
+	// Register /proc/sys/dev/ethX
+	lp->sysctl_header = register_sysctl_table(lp->root_table, 1);
+
+#ifdef MODULE
+	// Register our modcount function which adjusts the module count
+	lp->root_table->child->de->fill_inode = smc_procfs_modcount;
+#endif // MODULE
+
+}
+
+
+/*------------------------------------------------------------
+ . Sysctl unregistration when driver is closed
+ .-------------------------------------------------------------*/
+static void smc_sysctl_unregister(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+
+	unregister_sysctl_table(lp->sysctl_header);
+}
+
+#endif /* endif CONFIG_SYSCTL */
+
+
+//---PHY CONTROL AND CONFIGURATION-----------------------------------------
+
+#if (SMC_DEBUG > 2 )
+
+/*------------------------------------------------------------
+ . Debugging function for viewing MII Management serial bitstream
+ .-------------------------------------------------------------*/
+static void smc_dump_mii_stream(byte* bits, int size)
+{
+	int i;
+
+	printk("BIT#:");
+	for (i = 0; i < size; ++i)
+		printk("%d", i%10);
+
+	printk("\nMDOE:");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDOE)
+			printk("1");
+		else
+			printk("0");
+	}
+
+	printk("\nMDO :");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDO)
+			printk("1");
+		else
+			printk("0");
+	}
+
+	printk("\nMDI :");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDI)
+			printk("1");
+		else
+			printk("0");
+	}
+
+	printk("\n");
+}
+#endif
+
+/*------------------------------------------------------------
+ . Reads a register from the MII Management serial interface
+ .-------------------------------------------------------------*/
+static word smc_read_phy_register(unsigned long ioaddr,
+				  byte phyaddr, byte phyreg)
+{
+	int oldBank;
+	int i;
+	byte mask;
+	word mii_reg;
+	byte bits[64];
+	int clk_idx = 0;
+	int input_idx;
+	word phydata;
+
+	// 32 consecutive ones on MDO to establish sync
+	for (i = 0; i < 32; ++i)
+		bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Start code <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Read command <10>
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+	bits[clk_idx++] = MII_MDOE;
+
+	// Output the PHY address, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyaddr & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Output the phy register number, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyreg & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Tristate and turnaround (2 bit times)
+	bits[clk_idx++] = 0;
+	//bits[clk_idx++] = 0;
+
+	// Input starts at this bit time
+	input_idx = clk_idx;
+
+	// Will input 16 bits
+	for (i = 0; i < 16; ++i)
+		bits[clk_idx++] = 0;
+
+	// Final clock bit
+	bits[clk_idx++] = 0;
+
+	// Save the current bank
+	oldBank = SMC_CURRENT_BANK();
+
+	// Select bank 3
+	SMC_SELECT_BANK( 3 );
+
+	// Get the current MII register value
+	mii_reg = SMC_GET_MII();
+
+	// Turn off all MII Interface bits
+	mii_reg &= ~(MII_MDOE|MII_MCLK|MII_MDI|MII_MDO);
+
+	// Clock all 64 cycles
+	for (i = 0; i < sizeof bits; ++i) {
+		// Clock Low - output data
+		SMC_SET_MII( mii_reg | bits[i] );
+		udelay(50);
+
+
+		// Clock Hi - input data
+		SMC_SET_MII( mii_reg | bits[i] | MII_MCLK );
+		udelay(50);
+		bits[i] |= SMC_GET_MII() & MII_MDI;
+	}
+
+	// Return to idle state
+	// Set clock to low, data to low, and output tristated
+	SMC_SET_MII( mii_reg );
+	udelay(50);
+
+	// Restore original bank select
+	SMC_SELECT_BANK( oldBank );
+
+	// Recover input data
+	phydata = 0;
+	for (i = 0; i < 16; ++i) {
+		phydata <<= 1;
+
+		if (bits[input_idx++] & MII_MDI)
+			phydata |= 0x0001;
+	}
+
+#if (SMC_DEBUG > 2 )
+	printk("smc_read_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x\n",
+		phyaddr, phyreg, phydata);
+	smc_dump_mii_stream(bits, sizeof bits);
+#endif
+
+	return(phydata);
+}
+
+
+/*------------------------------------------------------------
+ . Writes a register to the MII Management serial interface
+ .-------------------------------------------------------------*/
+static void smc_write_phy_register(unsigned long ioaddr,
+	byte phyaddr, byte phyreg, word phydata)
+{
+	int oldBank;
+	int i;
+	word mask;
+	word mii_reg;
+	byte bits[65];
+	int clk_idx = 0;
+
+	// 32 consecutive ones on MDO to establish sync
+	for (i = 0; i < 32; ++i)
+		bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Start code <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Write command <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Output the PHY address, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyaddr & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Output the phy register number, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyreg & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Tristate and turnaround (2 bit times)
+	bits[clk_idx++] = 0;
+	bits[clk_idx++] = 0;
+
+	// Write out 16 bits of data, msb first
+	mask = 0x8000;
+	for (i = 0; i < 16; ++i) {
+		if (phydata & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Final clock bit (tristate)
+	bits[clk_idx++] = 0;
+
+	// Save the current bank
+	oldBank = SMC_CURRENT_BANK();
+
+	// Select bank 3
+	SMC_SELECT_BANK( 3 );
+
+	// Get the current MII register value
+	mii_reg = SMC_GET_MII();
+
+	// Turn off all MII Interface bits
+	mii_reg &= ~(MII_MDOE|MII_MCLK|MII_MDI|MII_MDO);
+
+	// Clock all cycles
+	for (i = 0; i < sizeof bits; ++i) {
+		// Clock Low - output data
+		SMC_SET_MII( mii_reg | bits[i] );
+		udelay(50);
+
+
+		// Clock Hi - input data
+		SMC_SET_MII( mii_reg | bits[i] | MII_MCLK );
+		udelay(50);
+		bits[i] |= SMC_GET_MII() & MII_MDI;
+	}
+
+	// Return to idle state
+	// Set clock to low, data to low, and output tristated
+	SMC_SET_MII( mii_reg );
+	udelay(50);
+
+	// Restore original bank select
+	SMC_SELECT_BANK( oldBank );
+
+#if (SMC_DEBUG > 2 )
+	printk("smc_write_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x\n",
+		phyaddr, phyreg, phydata);
+	smc_dump_mii_stream(bits, sizeof bits);
+#endif
+}
+
+
+/*------------------------------------------------------------
+ . Finds and reports the PHY address
+ .-------------------------------------------------------------*/
+static int smc_detect_phy(struct net_device* dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	unsigned long ioaddr = dev->base_addr;
+	word phy_id1;
+	word phy_id2;
+	int phyaddr;
+	int found = 0;
+
+	PRINTK3("%s:smc_detect_phy()\n", dev->name);
+
+	// Scan all 32 PHY addresses if necessary
+	for (phyaddr = 0; phyaddr < 32; ++phyaddr) {
+		// Read the PHY identifiers
+		phy_id1  = smc_read_phy_register(ioaddr, phyaddr, PHY_ID1_REG);
+		phy_id2  = smc_read_phy_register(ioaddr, phyaddr, PHY_ID2_REG);
+
+		PRINTK3("%s: phy_id1=%x, phy_id2=%x\n",
+			dev->name, phy_id1, phy_id2);
+
+		// Make sure it is a valid identifier
+		if ((phy_id2 > 0x0000) && (phy_id2 < 0xffff) &&
+		    (phy_id1 > 0x0000) && (phy_id1 < 0xffff)) {
+			if ((phy_id1 != 0x8000) && (phy_id2 != 0x8000)) {
+				// Save the PHY's address
+				lp->phyaddr = phyaddr;
+				found = 1;
+				break;
+			}
+		}
+	}
+
+	if (!found) {
+		PRINTK("%s: No PHY found\n", dev->name);
+		return(0);
+	}
+
+	// Set the PHY type
+	if ( (phy_id1 == 0x0016) && ((phy_id2 & 0xFFF0) == 0xF840 ) ) {
+		lp->phytype = PHY_LAN83C183;
+		PRINTK("%s: PHY=LAN83C183 (LAN91C111 Internal)\n", dev->name);
+	}
+
+	if ( (phy_id1 == 0x0282) && ((phy_id2 & 0xFFF0) == 0x1C50) ) {
+		lp->phytype = PHY_LAN83C180;
+		PRINTK("%s: PHY=LAN83C180\n", dev->name);
+	}
+
+	return(1);
+}
+
+/*------------------------------------------------------------
+ . Waits the specified number of milliseconds - kernel friendly
+ .-------------------------------------------------------------*/
+static void smc_wait_ms(unsigned int ms)
+{
+
+	if (!in_interrupt()) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 + ms * HZ / 1000);
+	} else {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1 + ms * HZ / 1000);
+		set_current_state(TASK_RUNNING);
+	}
+}
+
+/*------------------------------------------------------------
+ . Sets the PHY to a configuration as determined by the user
+ .-------------------------------------------------------------*/
+static int smc_phy_fixed(struct net_device* dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte phyaddr = lp->phyaddr;
+	word my_fixed_caps;
+	word cfg1;
+
+	PRINTK3("%s:smc_phy_fixed()\n", dev->name);
+
+	// Enter Link Disable state
+	cfg1 = smc_read_phy_register(ioaddr, phyaddr, PHY_CFG1_REG);
+	cfg1 |= PHY_CFG1_LNKDIS;
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CFG1_REG, cfg1);
+
+	// Set our fixed capabilities
+	// Disable auto-negotiation
+	my_fixed_caps = 0;
+
+	if (lp->ctl_rfduplx)
+		my_fixed_caps |= PHY_CNTL_DPLX;
+
+	if (lp->ctl_rspeed == 100)
+		my_fixed_caps |= PHY_CNTL_SPEED;
+
+	// Write our capabilities to the phy control register
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CNTL_REG, my_fixed_caps);
+
+	// Re-Configure the Receive/Phy Control register
+	SMC_SET_RPC( lp->rpc_cur_mode );
+
+	// Success
+	return(1);
+}
+
+
+/*------------------------------------------------------------
+ . Configures the specified PHY using Autonegotiation. Calls
+ . smc_phy_fixed() if the user has requested a certain config.
+ .-------------------------------------------------------------*/
+static void smc_phy_configure(struct net_device* dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	int timeout;
+	byte phyaddr;
+	word my_phy_caps; // My PHY capabilities
+	word my_ad_caps; // My Advertised capabilities
+	word status;
+	int failed = 0;
+
+	PRINTK3("%s:smc_program_phy()\n", dev->name);
+
+	// Set the blocking flag
+	lp->autoneg_active = 1;
+
+	// Find the address and type of our phy
+	if (!smc_detect_phy(dev))
+		goto smc_phy_configure_exit;
+
+	// Get the detected phy address
+	phyaddr = lp->phyaddr;
+
+	// Reset the PHY, setting all other bits to zero
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CNTL_REG, PHY_CNTL_RST);
+
+	// Wait for the reset to complete, or time out
+	timeout = 6; // Wait up to 3 seconds
+	while (timeout--) {
+		if (!(smc_read_phy_register(ioaddr, phyaddr, PHY_CNTL_REG)
+		    & PHY_CNTL_RST))
+			// reset complete
+			break;
+		smc_wait_ms(500); // wait 500 millisecs
+		if (signal_pending(current)) { // Exit anyway if signaled
+			PRINTK2("%s:PHY reset interrupted by signal\n",
+				dev->name);
+			timeout = 0;
+			break;
+		}
+	}
+
+	if (timeout < 1) {
+		printk("%s:PHY reset timed out\n", dev->name);
+		goto smc_phy_configure_exit;
+	}
+
+	// Read PHY Register 18, Status Output
+	lp->lastPhy18 = smc_read_phy_register(ioaddr, phyaddr, PHY_INT_REG);
+
+	// Enable PHY Interrupts (for register 18)
+	// Interrupts listed here are disabled
+	smc_write_phy_register(ioaddr, phyaddr, PHY_MASK_REG,
+		PHY_INT_LOSSSYNC | PHY_INT_CWRD | PHY_INT_SSD |
+		PHY_INT_ESD | PHY_INT_RPOL | PHY_INT_JAB |
+		PHY_INT_SPDDET | PHY_INT_DPLXDET);
+
+	/* Configure the Receive/Phy Control register */
+	SMC_SELECT_BANK( 0 );
+	SMC_SET_RPC( lp->rpc_cur_mode );
+
+	// Copy our capabilities from PHY_STAT_REG to PHY_AD_REG
+	my_phy_caps = smc_read_phy_register(ioaddr, phyaddr, PHY_STAT_REG);
+	my_ad_caps  = PHY_AD_CSMA; // I am CSMA capable
+
+	if (my_phy_caps & PHY_STAT_CAP_T4)
+		my_ad_caps |= PHY_AD_T4;
+
+	if (my_phy_caps & PHY_STAT_CAP_TXF)
+		my_ad_caps |= PHY_AD_TX_FDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TXH)
+		my_ad_caps |= PHY_AD_TX_HDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TF)
+		my_ad_caps |= PHY_AD_10_FDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TH)
+		my_ad_caps |= PHY_AD_10_HDX;
+
+	// Disable capabilities not selected by our user
+	if (lp->ctl_rspeed != 100)
+		my_ad_caps &= ~(PHY_AD_T4|PHY_AD_TX_FDX|PHY_AD_TX_HDX);
+
+	if (!lp->ctl_rfduplx)
+		my_ad_caps &= ~(PHY_AD_TX_FDX|PHY_AD_10_FDX);
+
+	// Update our Auto-Neg Advertisement Register
+	smc_write_phy_register(ioaddr, phyaddr, PHY_AD_REG, my_ad_caps);
+
+	// Read the register back.  Without this, it appears that when
+	// auto-negotiation is restarted, sometimes it isn't ready and
+	// the link does not come up.
+	status = smc_read_phy_register(ioaddr, phyaddr, PHY_AD_REG);
+
+	PRINTK2("%s:phy caps=%x\n", dev->name, my_phy_caps);
+	PRINTK2("%s:phy advertised caps=%x\n", dev->name, my_ad_caps);
+
+	// If the user requested no auto neg, then go set his request
+	if (!(lp->ctl_autoneg)) {
+		smc_phy_fixed(dev);
+		goto smc_phy_configure_exit;
+	}
+
+	// Restart auto-negotiation process in order to advertise my caps
+	smc_write_phy_register( ioaddr, phyaddr, PHY_CNTL_REG,
+		PHY_CNTL_ANEG_EN | PHY_CNTL_ANEG_RST );
+
+	// Wait for the auto-negotiation to complete.  This may take from
+	// 2 to 3 seconds.
+	// Wait for the reset to complete, or time out
+	timeout = 20; // Wait up to 10 seconds
+	while (timeout--) {
+		status = smc_read_phy_register(ioaddr, phyaddr, PHY_STAT_REG);
+		if (status & PHY_STAT_ANEG_ACK)
+			// auto-negotiate complete
+			break;
+
+		smc_wait_ms(500); // wait 500 millisecs
+		if (signal_pending(current)) { // Exit anyway if signaled
+			printk(KERN_DEBUG
+				"%s:PHY auto-negotiate interrupted by signal\n",
+				dev->name);
+			timeout = 0;
+			break;
+		}
+
+		// Restart auto-negotiation if remote fault
+		if (status & PHY_STAT_REM_FLT) {
+			PRINTK2("%s:PHY remote fault detected\n", dev->name);
+
+			// Restart auto-negotiation
+			PRINTK2("%s:PHY restarting auto-negotiation\n",
+				dev->name);
+			smc_write_phy_register( ioaddr, phyaddr, PHY_CNTL_REG,
+				PHY_CNTL_ANEG_EN | PHY_CNTL_ANEG_RST |
+				PHY_CNTL_SPEED | PHY_CNTL_DPLX);
+		}
+	}
+
+	if (timeout < 1) {
+		printk(KERN_DEBUG "%s:PHY auto-negotiate timed out\n",
+			dev->name);
+		PRINTK2("%s:PHY auto-negotiate timed out\n", dev->name);
+		failed = 1;
+	}
+
+	// Fail if we detected an auto-negotiate remote fault
+	if (status & PHY_STAT_REM_FLT) {
+		printk(KERN_DEBUG "%s:PHY remote fault detected\n", dev->name);
+		PRINTK2("%s:PHY remote fault detected\n", dev->name);
+		failed = 1;
+	}
+
+	// The smc_phy_interrupt() routine will be called to update lastPhy18
+
+	// Set our sysctl parameters to match auto-negotiation results
+	if ( lp->lastPhy18 & PHY_INT_SPDDET ) {
+		PRINTK2("%s:PHY 100BaseT\n", dev->name);
+		lp->rpc_cur_mode |= RPC_SPEED;
+	} else {
+		PRINTK2("%s:PHY 10BaseT\n", dev->name);
+		lp->rpc_cur_mode &= ~RPC_SPEED;
+	}
+
+	if ( lp->lastPhy18 & PHY_INT_DPLXDET ) {
+		PRINTK2("%s:PHY Full Duplex\n", dev->name);
+		lp->rpc_cur_mode |= RPC_DPLX;
+	} else {
+		PRINTK2("%s:PHY Half Duplex\n", dev->name);
+		lp->rpc_cur_mode &= ~RPC_DPLX;
+	}
+
+	// Re-Configure the Receive/Phy Control register
+	SMC_SET_RPC( lp->rpc_cur_mode );
+
+smc_phy_configure_exit:
+	// Exit auto-negotiation
+	lp->autoneg_active = 0;
+}
+
+
+
+/*************************************************************************
+ . smc_phy_interrupt
+ .
+ . Purpose:  Handle interrupts relating to PHY register 18. This is
+ .  called from the "hard" interrupt handler.
+ .
+ ************************************************************************/
+static void smc_phy_interrupt(struct net_device* dev)
+{
+	unsigned long ioaddr	= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	byte phyaddr = lp->phyaddr;
+	word phy18;
+
+	PRINTK2("%s: smc_phy_interrupt\n", dev->name);
+
+	for(;;) {
+		// Read PHY Register 18, Status Output
+		phy18 = smc_read_phy_register(ioaddr, phyaddr, PHY_INT_REG);
+
+		// Exit if not more changes
+		if (phy18 == lp->lastPhy18)
+			break;
+
+#if (SMC_DEBUG > 1 )
+		PRINTK2("%s:     phy18=0x%x\n", dev->name, phy18);
+		PRINTK2("%s: lastPhy18=0x%x\n", dev->name, lp->lastPhy18);
+
+		// Handle events
+		if ((phy18 & PHY_INT_LNKFAIL) !=
+				(lp->lastPhy18 & PHY_INT_LNKFAIL))
+			PRINTK2("%s: PHY Link Fail=%x\n", dev->name,
+					phy18 & PHY_INT_LNKFAIL);
+
+		if ((phy18 & PHY_INT_LOSSSYNC) !=
+				(lp->lastPhy18 & PHY_INT_LOSSSYNC))
+			PRINTK2("%s: PHY LOSS SYNC=%x\n", dev->name,
+					phy18 & PHY_INT_LOSSSYNC);
+
+		if ((phy18 & PHY_INT_CWRD) != (lp->lastPhy18 & PHY_INT_CWRD))
+			PRINTK2("%s: PHY INVALID 4B5B code=%x\n", dev->name,
+					phy18 & PHY_INT_CWRD);
+
+		if ((phy18 & PHY_INT_SSD) != (lp->lastPhy18 & PHY_INT_SSD))
+			PRINTK2("%s: PHY No Start Of Stream=%x\n", dev->name,
+					phy18 & PHY_INT_SSD);
+
+		if ((phy18 & PHY_INT_ESD) != (lp->lastPhy18 & PHY_INT_ESD))
+
+			PRINTK2("%s: PHY No End Of Stream=%x\n", dev->name,
+					phy18 & PHY_INT_ESD);
+
+		if ((phy18 & PHY_INT_RPOL) != (lp->lastPhy18 & PHY_INT_RPOL))
+			PRINTK2("%s: PHY Reverse Polarity Detected=%x\n",
+					dev->name, phy18 & PHY_INT_RPOL);
+
+		if ((phy18 & PHY_INT_JAB) != (lp->lastPhy18 & PHY_INT_JAB))
+			PRINTK2("%s: PHY Jabber Detected=%x\n", dev->name,
+					phy18 & PHY_INT_JAB);
+
+		if ((phy18 & PHY_INT_SPDDET) !=
+				(lp->lastPhy18 & PHY_INT_SPDDET))
+			PRINTK2("%s: PHY Speed Detect=%x\n", dev->name,
+					phy18 & PHY_INT_SPDDET);
+
+		if ((phy18 & PHY_INT_DPLXDET) !=
+				(lp->lastPhy18 & PHY_INT_DPLXDET))
+			PRINTK2("%s: PHY Duplex Detect=%x\n", dev->name,
+					phy18 & PHY_INT_DPLXDET);
+#endif
+		// Update the last phy 18 variable
+		lp->lastPhy18 = phy18;
+	}
+}
diff -p -purN linux-2.5/drivers/net/smc91111.h linuxppc-2.5/drivers/net/smc91111.h
--- linux-2.5/drivers/net/smc91111.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/net/smc91111.h	2002-08-27 16:33:39.000000000 +0200
@@ -0,0 +1,712 @@
+/*------------------------------------------------------------------------
+ . smc91111.h - macros for the LAN91C111 Ethernet Driver
+ .
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .       Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . This file contains register information and access macros for
+ . the LAN91C111 single chip ethernet controller.  It is a modified
+ . version of the smc9194.h file.
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+ . Authors
+ . 	Erik Stahlman				( erik@vt.edu )
+ .	Daris A Nevil				( dnevil@snmc.com )
+ .
+ . History
+ . 03/16/01		Daris A Nevil	Modified for use with LAN91C111 device
+ .
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC91111_H_
+#define _SMC91111_H_
+
+/* I want some simple types */
+
+typedef unsigned char			byte;
+typedef unsigned short			word;
+typedef unsigned long int 		dword;
+
+
+/*
+ . Do you want to use 8 bit xfers?  This should work on all chips, as the
+ . chipset is designed to accommodate them, although some hardware engineers
+ . do not connect byte enables so 8 bit xfers can not be used.
+*/
+#ifdef CONFIG_SMC91111_USE_8_BIT
+#define SMC_inb(port)		inb(port)
+#define SMC_insb(port,buf,ns)	insb((port),(buf),(ns))
+#define SMC_outb(val,port)	outb((val),(port))
+#define SMC_outsb(port,buf,ns)	outsb((port),(buf),(ns))
+#endif /* CONFIG_SMC91111_USE_8_BIT */
+
+/* Define 16 bit xfers. */
+#ifdef CONFIG_SMC91111_BYTE_SWAP
+#define SMC_inw(port)		swab16(inw(port))
+#define SMC_insw(port,buf,ns) 						\
+	do {								\
+		unsigned long __port = (port);				\
+		word *__buf = (word *)(buf);				\
+		int __ns = (ns);					\
+		insw(__port,__buf,__ns);				\
+		while (__ns > 0) {					\
+			*__buf = swab16(*__buf);			\
+			__buf++;					\
+			__ns--;						\
+		}							\
+	} while (0)
+#define SMC_outw(val,port)	outw(swab16(val),(port))
+#define SMC_outsw(port,buf,ns) 						\
+	do {								\
+		unsigned long __port = (port);				\
+		word *__buf = (word *)(buf);				\
+		int __ns = (ns);					\
+		while (__ns > 0) {					\
+			/* Believe it or not, the swab isn't needed. */	\
+			outw( /* swab16 */ (*__buf++), __port);		\
+			__ns--;						\
+		}							\
+	} while (0)
+#else /* CONFIG_SMC91111_BYTE_SWAP is not defined */
+#define SMC_inw(port)		inw(port)
+#define SMC_insw(port,buf,ns)	insw((port),(buf),(ns))
+#define SMC_outw(val,port)	outw((val),(port))
+#define SMC_outsw(port,buf,ns)	outsw((port),(buf),(ns))
+#endif /* CONFIG_SMC91111_BYTE_SWAP */
+
+/*
+ . Do you want to use 32 bit xfers?  This should work on all chips, as the
+ . chipset is designed to accommodate them, although some hardware engineers
+ . do not connect all 32 data bits so 32 bit xfers can not be used.
+*/
+#ifdef CONFIG_SMC91111_USE_32_BIT
+#ifdef CONFIG_SMC91111_BYTE_SWAP
+#define SMC_inl(port)		swab32(inl(port))
+#define SMC_insl(port,buf,ns) 						\
+	do {								\
+		unsigned long __port = (port);				\
+		dword *__buf = (dword *)(buf);				\
+		int __ns = (ns);					\
+		insl(__port,__buf,__ns);				\
+		while (__ns > 0) {					\
+			*__buf = swab32(*__buf);			\
+			__buf++;					\
+			__ns--;						\
+		}							\
+	} while (0)
+#define SMC_outl(val,port)	outl(swab32(val),(port))
+#define SMC_outsl(port,buf,ns) 						\
+	do {								\
+		unsigned long __port = (port);				\
+		dword *__buf = (dword *)(buf);				\
+		int __ns = (ns);					\
+		while (__ns > 0) {					\
+			/* Believe it or not, the swab isn't needed. */	\
+			outl( /* swab32 */ (*__buf++), __port);		\
+			__ns--;						\
+		}							\
+	} while (0)
+#else /* CONFIG_SMC91111_BYTE_SWAP is not defined */
+#define SMC_inl(port)		inl(port)
+#define SMC_insl(port,buf,ns)	insl((port),(buf),(ns))
+#define SMC_outl(val,port)	outl((val),(port))
+#define SMC_outsl(port,buf,ns)	outsl((port),(buf),(ns))
+#endif /* CONFIG_SMC91111_BYTE_SWAP */
+#endif /* CONFIG_SMC91111_USE_32_BIT */
+
+
+/* Because of bank switching, the LAN91xxx uses only 16 I/O ports */
+
+#define SMC_IO_EXTENT	16
+
+
+/*---------------------------------------------------------------
+ .
+ . A description of the SMSC registers is probably in order here,
+ . although for details, the SMC datasheet is invaluable.
+ .
+ . Basically, the chip has 4 banks of registers ( 0 to 3 ), which
+ . are accessed by writing a number into the BANK_SELECT register
+ . ( I also use a SMC_SELECT_BANK macro for this ).
+ .
+ . The banks are configured so that for most purposes, bank 2 is all
+ . that is needed for simple run time tasks.
+ -----------------------------------------------------------------------*/
+
+/*
+ . Bank Select Register:
+ .
+ .		yyyy yyyy 0000 00xx
+ .		xx 		= bank number
+ .		yyyy yyyy	= 0x33, for identification purposes.
+*/
+#define BANK_SELECT		14
+
+// Transmit Control Register
+/* BANK 0  */
+#define TCR_REG 	0x0000 	// transmit control register
+#define TCR_ENABLE	0x0001	// When 1 we can transmit
+#define TCR_LOOP	0x0002	// Controls output pin LBK
+#define TCR_FORCOL	0x0004	// When 1 will force a collision
+#define TCR_PAD_EN	0x0080	// When 1 will pad tx frames < 64 bytes w/0
+#define TCR_NOCRC	0x0100	// When 1 will not append CRC to tx frames
+#define TCR_MON_CSN	0x0400	// When 1 tx monitors carrier
+#define TCR_FDUPLX    	0x0800  // When 1 enables full duplex operation
+#define TCR_STP_SQET	0x1000	// When 1 stops tx if Signal Quality Error
+#define TCR_EPH_LOOP	0x2000	// When 1 enables EPH block loopback
+#define TCR_SWFDUP	0x8000	// When 1 enables Switched Full Duplex mode
+
+#define TCR_CLEAR	0	/* do NOTHING */
+/* the default settings for the TCR register : */
+/* QUESTION: do I want to enable padding of short packets ? */
+#define TCR_DEFAULT  	TCR_ENABLE
+
+
+// EPH Status Register
+/* BANK 0  */
+#define EPH_STATUS_REG	0x0002
+#define ES_TX_SUC	0x0001	// Last TX was successful
+#define ES_SNGL_COL	0x0002	// Single collision detected for last tx
+#define ES_MUL_COL	0x0004	// Multiple collisions detected for last tx
+#define ES_LTX_MULT	0x0008	// Last tx was a multicast
+#define ES_16COL	0x0010	// 16 Collisions Reached
+#define ES_SQET		0x0020	// Signal Quality Error Test
+#define ES_LTXBRD	0x0040	// Last tx was a broadcast
+#define ES_TXDEFR	0x0080	// Transmit Deferred
+#define ES_LATCOL	0x0200	// Late collision detected on last tx
+#define ES_LOSTCARR	0x0400	// Lost Carrier Sense
+#define ES_EXC_DEF	0x0800	// Excessive Deferral
+#define ES_CTR_ROL	0x1000	// Counter Roll Over indication
+#define ES_LINK_OK	0x4000	// Driven by inverted value of nLNK pin
+#define ES_TXUNRN	0x8000	// Tx Underrun
+
+
+// Receive Control Register
+/* BANK 0  */
+#define RCR_REG		0x0004
+#define RCR_RX_ABORT	0x0001	// Set if a rx frame was aborted
+#define RCR_PRMS	0x0002	// Enable promiscuous mode
+#define RCR_ALMUL	0x0004	// When set accepts all multicast frames
+#define RCR_RXEN	0x0100	// IFF this is set, we can receive packets
+#define RCR_STRIP_CRC	0x0200	// When set strips CRC from rx packets
+#define RCR_ABORT_ENB	0x0200	// When set will abort rx on collision
+#define RCR_FILT_CAR	0x0400	// When set filters leading 12 bit s of carrier
+#define RCR_SOFTRST	0x8000 	// resets the chip
+
+/* the normal settings for the RCR register : */
+#define RCR_DEFAULT	(RCR_STRIP_CRC | RCR_RXEN)
+#define RCR_CLEAR	0x0	// set it to a base state
+
+// Counter Register
+/* BANK 0  */
+#define COUNTER_REG	0x0006
+
+// Memory Information Register
+/* BANK 0  */
+#define MIR_REG		0x0008
+
+// Receive/Phy Control Register
+/* BANK 0  */
+#define RPC_REG		0x000A
+#define RPC_SPEED	0x2000	// When 1 PHY is in 100Mbps mode.
+#define RPC_DPLX	0x1000	// When 1 PHY is in Full-Duplex Mode
+#define RPC_ANEG	0x0800	// When 1 PHY is in Auto-Negotiate Mode
+#define RPC_LSXA_SHFT	5	// Bits to shift LS2A,LS1A,LS0A to lsb
+#define RPC_LSXB_SHFT	2	// Bits to get LS2B,LS1B,LS0B to lsb
+#define RPC_LED_100_10	(0x00)	// LED = 100Mbps OR's with 10Mbps link detect
+#define RPC_LED_RES	(0x01)	// LED = Reserved
+#define RPC_LED_10	(0x02)	// LED = 10Mbps link detect
+#define RPC_LED_FD	(0x03)	// LED = Full Duplex Mode
+#define RPC_LED_TX_RX	(0x04)	// LED = TX or RX packet occurred
+#define RPC_LED_100	(0x05)	// LED = 100Mbps link dectect
+#define RPC_LED_TX	(0x06)	// LED = TX packet occurred
+#define RPC_LED_RX	(0x07)	// LED = RX packet occurred
+#define RPC_DEFAULT (RPC_ANEG | (RPC_LED_100 << RPC_LSXA_SHFT) | (RPC_LED_FD << RPC_LSXB_SHFT) | RPC_SPEED | RPC_DPLX)
+
+/* Bank 0 0x000C is reserved */
+
+// Bank Select Register
+/* All Banks */
+#define BSR_REG	0x000E
+
+
+// Configuration Reg
+/* BANK 1 */
+#define CONFIG_REG	0x0000
+#define CONFIG_EXT_PHY	0x0200	// 1=external MII, 0=internal Phy
+#define CONFIG_GPCNTRL	0x0400	// Inverse value drives pin nCNTRL
+#define CONFIG_NO_WAIT	0x1000	// When 1 no extra wait states on ISA bus
+#define CONFIG_EPH_POWER_EN 0x8000 // When 0 EPH is placed into low power mode.
+
+// Default is powered-up, Internal Phy, Wait States, and pin nCNTRL=low
+#define CONFIG_DEFAULT	(CONFIG_EPH_POWER_EN)
+
+
+// Base Address Register
+/* BANK 1 */
+#define BASE_REG	0x0002
+
+
+// Individual Address Registers
+/* BANK 1 */
+#define ADDR0_REG	0x0004
+#define ADDR1_REG	0x0006
+#define ADDR2_REG	0x0008
+
+
+// General Purpose Register
+/* BANK 1 */
+#define GP_REG		0x000A
+
+
+// Control Register
+/* BANK 1 */
+#define CTL_REG		0x000C
+#define CTL_RCV_BAD	0x4000 // When 1 bad CRC packets are received
+#define CTL_AUTO_RELEASE 0x0800 // When 1 tx pages are released automatically
+#define CTL_LE_ENABLE	0x0080 // When 1 enables Link Error interrupt
+#define CTL_CR_ENABLE	0x0040 // When 1 enables Counter Rollover interrupt
+#define CTL_TE_ENABLE	0x0020 // When 1 enables Transmit Error interrupt
+#define CTL_EEPROM_SELECT 0x0004 // Controls EEPROM reload & store
+#define CTL_RELOAD	0x0002 // When set reads EEPROM into registers
+#define CTL_STORE	0x0001 // When set stores registers into EEPROM
+
+
+// MMU Command Register
+/* BANK 2 */
+#define MMU_CMD_REG	0x0000
+#define MC_BUSY		1	// When 1 the last release has not completed
+#define MC_NOP		(0<<5)	// No Op
+#define MC_ALLOC	(1<<5) 	// OR with number of 256 byte packets
+#define MC_RESET	(2<<5)	// Reset MMU to initial state
+#define MC_REMOVE	(3<<5) 	// Remove the current rx packet
+#define MC_RELEASE  	(4<<5) 	// Remove and release the current rx packet
+#define MC_FREEPKT  	(5<<5) 	// Release packet in PNR register
+#define MC_ENQUEUE	(6<<5)	// Enqueue the packet for transmit
+#define MC_RSTTXFIFO	(7<<5)	// Reset the TX FIFOs
+
+
+// Packet Number Register
+/* BANK 2 */
+#define PN_REG		0x0002
+
+
+// Allocation Result Register
+/* BANK 2 */
+#define AR_REG		0x0003
+#define AR_FAILED	0x80	// Alocation Failed
+
+
+// RX FIFO Ports Register
+/* BANK 2 */
+#define RXFIFO_REG	0x0004	// Must be read as a word
+#define RXFIFO_REMPTY	0x8000	// RX FIFO Empty
+
+
+// TX FIFO Ports Register
+/* BANK 2 */
+#define TXFIFO_REG	RXFIFO_REG	// Must be read as a word
+#define TXFIFO_TEMPTY	0x80	// TX FIFO Empty
+
+
+// Pointer Register
+/* BANK 2 */
+#define PTR_REG		0x0006
+#define PTR_RCV		0x8000 // 1=Receive area, 0=Transmit area
+#define PTR_AUTOINC 	0x4000 // Auto increment the pointer on each access
+#define PTR_READ	0x2000 // When 1 the operation is a read
+
+
+// Data Register
+/* BANK 2 */
+#define DATA_REG	0x0008
+
+
+// Interrupt Status/Acknowledge Register
+/* BANK 2 */
+#define INT_REG		0x000C
+
+
+// Interrupt Mask Register
+/* BANK 2 */
+#define IM_REG		0x000D
+#define IM_MDINT	0x80 // PHY MI Register 18 Interrupt
+#define IM_ERCV_INT	0x40 // Early Receive Interrupt
+#define IM_EPH_INT	0x20 // Set by Etheret Protocol Handler section
+#define IM_RX_OVRN_INT	0x10 // Set by Receiver Overruns
+#define IM_ALLOC_INT	0x08 // Set when allocation request is completed
+#define IM_TX_EMPTY_INT	0x04 // Set if the TX FIFO goes empty
+#define IM_TX_INT	0x02 // Transmit Interrrupt
+#define IM_RCV_INT	0x01 // Receive Interrupt
+
+
+// Multicast Table Registers
+/* BANK 3 */
+#define MCAST_REG1	0x0000
+#define MCAST_REG2	0x0002
+#define MCAST_REG3	0x0004
+#define MCAST_REG4	0x0006
+
+
+// Management Interface Register (MII)
+/* BANK 3 */
+#define MII_REG		0x0008
+#define MII_MSK_CRS100	0x4000 // Disables CRS100 detection during tx half dup
+#define MII_MDOE	0x0008 // MII Output Enable
+#define MII_MCLK	0x0004 // MII Clock, pin MDCLK
+#define MII_MDI		0x0002 // MII Input, pin MDI
+#define MII_MDO		0x0001 // MII Output, pin MDO
+
+
+// Revision Register
+/* BANK 3 */
+#define REV_REG		0x000A /* ( hi: chip id   low: rev # ) */
+
+
+// Early RCV Register
+/* BANK 3 */
+/* this is NOT on SMC9192 */
+#define ERCV_REG	0x000C
+#define ERCV_RCV_DISCRD	0x0080 // When 1 discards a packet being received
+#define ERCV_THRESHOLD	0x001F // ERCV Threshold Mask
+
+// External Register
+/* BANK 7 */
+#define EXT_REG		0x0000
+
+
+#define CHIP_9192	3
+#define CHIP_9194	4
+#define CHIP_9195	5
+#define CHIP_9196	6
+#define CHIP_91100	7
+#define CHIP_91100FD	8
+#define CHIP_91111FD	9
+
+static const char * chip_ids[ 15 ] =  {
+	NULL, NULL, NULL,
+	/* 3 */ "SMC91C90/91C92",
+	/* 4 */ "SMC91C94",
+	/* 5 */ "SMC91C95",
+	/* 6 */ "SMC91C96",
+	/* 7 */ "SMC91C100",
+	/* 8 */ "SMC91C100FD",
+	/* 9 */ "SMC91C11xFD",
+	NULL, NULL,
+	NULL, NULL, NULL};
+
+/*
+ . Transmit status bits
+*/
+#define TS_SUCCESS 0x0001
+#define TS_LOSTCAR 0x0400
+#define TS_LATCOL  0x0200
+#define TS_16COL   0x0010
+
+/*
+ . Receive status bits
+*/
+#define RS_ALGNERR	0x8000
+#define RS_BRODCAST	0x4000
+#define RS_BADCRC	0x2000
+#define RS_ODDFRAME	0x1000	// bug: the LAN91C111 never sets this on receive
+#define RS_TOOLONG	0x0800
+#define RS_TOOSHORT	0x0400
+#define RS_MULTICAST	0x0001
+#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
+
+
+// PHY Types
+enum {
+	PHY_LAN83C183 = 1,	// LAN91C111 Internal PHY
+	PHY_LAN83C180
+};
+
+
+// PHY Register Addresses (LAN91C111 Internal PHY)
+
+// PHY Control Register
+#define PHY_CNTL_REG		0x00
+#define PHY_CNTL_RST		0x8000	// 1=PHY Reset
+#define PHY_CNTL_LPBK		0x4000	// 1=PHY Loopback
+#define PHY_CNTL_SPEED		0x2000	// 1=100Mbps, 0=10Mpbs
+#define PHY_CNTL_ANEG_EN	0x1000 // 1=Enable Auto negotiation
+#define PHY_CNTL_PDN		0x0800	// 1=PHY Power Down mode
+#define PHY_CNTL_MII_DIS	0x0400	// 1=MII 4 bit interface disabled
+#define PHY_CNTL_ANEG_RST	0x0200 // 1=Reset Auto negotiate
+#define PHY_CNTL_DPLX		0x0100	// 1=Full Duplex, 0=Half Duplex
+#define PHY_CNTL_COLTST		0x0080	// 1= MII Colision Test
+
+// PHY Status Register
+#define PHY_STAT_REG		0x01
+#define PHY_STAT_CAP_T4		0x8000	// 1=100Base-T4 capable
+#define PHY_STAT_CAP_TXF	0x4000	// 1=100Base-X full duplex capable
+#define PHY_STAT_CAP_TXH	0x2000	// 1=100Base-X half duplex capable
+#define PHY_STAT_CAP_TF		0x1000	// 1=10Mbps full duplex capable
+#define PHY_STAT_CAP_TH		0x0800	// 1=10Mbps half duplex capable
+#define PHY_STAT_CAP_SUPR	0x0040	// 1=recv mgmt frames with not preamble
+#define PHY_STAT_ANEG_ACK	0x0020	// 1=ANEG has completed
+#define PHY_STAT_REM_FLT	0x0010	// 1=Remote Fault detected
+#define PHY_STAT_CAP_ANEG	0x0008	// 1=Auto negotiate capable
+#define PHY_STAT_LINK		0x0004	// 1=valid link
+#define PHY_STAT_JAB		0x0002	// 1=10Mbps jabber condition
+#define PHY_STAT_EXREG		0x0001	// 1=extended registers implemented
+
+// PHY Identifier Registers
+#define PHY_ID1_REG		0x02	// PHY Identifier 1
+#define PHY_ID2_REG		0x03	// PHY Identifier 2
+
+// PHY Auto-Negotiation Advertisement Register
+#define PHY_AD_REG		0x04
+#define PHY_AD_NP		0x8000	// 1=PHY requests exchange of Next Page
+#define PHY_AD_ACK		0x4000	// 1=got link code word from remote
+#define PHY_AD_RF		0x2000	// 1=advertise remote fault
+#define PHY_AD_T4		0x0200	// 1=PHY is capable of 100Base-T4
+#define PHY_AD_TX_FDX		0x0100	// 1=PHY is capable of 100Base-TX FDPLX
+#define PHY_AD_TX_HDX		0x0080	// 1=PHY is capable of 100Base-TX HDPLX
+#define PHY_AD_10_FDX		0x0040	// 1=PHY is capable of 10Base-T FDPLX
+#define PHY_AD_10_HDX		0x0020	// 1=PHY is capable of 10Base-T HDPLX
+#define PHY_AD_CSMA		0x0001	// 1=PHY is capable of 802.3 CMSA
+
+// PHY Auto-negotiation Remote End Capability Register
+#define PHY_RMT_REG		0x05
+// Uses same bit definitions as PHY_AD_REG
+
+// PHY Configuration Register 1
+#define PHY_CFG1_REG		0x10
+#define PHY_CFG1_LNKDIS		0x8000	// 1=Rx Link Detect Function disabled
+#define PHY_CFG1_XMTDIS		0x4000	// 1=TP Transmitter Disabled
+#define PHY_CFG1_XMTPDN		0x2000	// 1=TP Transmitter Powered Down
+#define PHY_CFG1_BYPSCR		0x0400	// 1=Bypass scrambler/descrambler
+#define PHY_CFG1_UNSCDS		0x0200	// 1=Unscramble Idle Reception Disable
+#define PHY_CFG1_EQLZR		0x0100	// 1=Rx Equalizer Disabled
+#define PHY_CFG1_CABLE		0x0080	// 1=STP(150ohm), 0=UTP(100ohm)
+#define PHY_CFG1_RLVL0		0x0040	// 1=Rx Squelch level reduced by 4.5db
+#define PHY_CFG1_TLVL_SHIFT	2	// Transmit Output Level Adjust
+#define PHY_CFG1_TLVL_MASK	0x003C
+#define PHY_CFG1_TRF_MASK	0x0003	// Transmitter Rise/Fall time
+
+
+// PHY Configuration Register 2
+#define PHY_CFG2_REG		0x11
+#define PHY_CFG2_APOLDIS	0x0020	// 1=Auto Polarity Correction disabled
+#define PHY_CFG2_JABDIS		0x0010	// 1=Jabber disabled
+#define PHY_CFG2_MREG		0x0008	// 1=Multiple register access (MII mgt)
+#define PHY_CFG2_INTMDIO	0x0004	// 1=Interrupt signaled with MDIO pulseo
+
+// PHY Status Output (and Interrupt status) Register
+#define PHY_INT_REG		0x12	// Status Output (Interrupt Status)
+#define PHY_INT_INT		0x8000	// 1=bits have changed since last read
+#define PHY_INT_LNKFAIL		0x4000	// 1=Link Not detected
+#define PHY_INT_LOSSSYNC	0x2000	// 1=Descrambler has lost sync
+#define PHY_INT_CWRD		0x1000	// 1=Invalid 4B5B code detected on rx
+#define PHY_INT_SSD		0x0800	// 1=No Start Of Stream detected on rx
+#define PHY_INT_ESD		0x0400	// 1=No End Of Stream detected on rx
+#define PHY_INT_RPOL		0x0200	// 1=Reverse Polarity detected
+#define PHY_INT_JAB		0x0100	// 1=Jabber detected
+#define PHY_INT_SPDDET		0x0080	// 1=100Base-TX mode, 0=10Base-T mode
+#define PHY_INT_DPLXDET		0x0040	// 1=Device in Full Duplex
+
+// PHY Interrupt/Status Mask Register
+#define PHY_MASK_REG		0x13	// Interrupt Mask
+// Uses the same bit definitions as PHY_INT_REG
+
+
+
+/*-------------------------------------------------------------------------
+ .  I define some macros to make it easier to do somewhat common
+ . or slightly complicated, repeated tasks.
+ --------------------------------------------------------------------------*/
+
+/* select a register bank, 0 to 3  */
+
+#define SMC_SELECT_BANK(x)  { SMC_outw( x, ioaddr + BANK_SELECT ); }
+#define SMC_CURRENT_BANK()  SMC_inw( ioaddr + BANK_SELECT )
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = SMC_GET_INT_MASK();\
+		mask |= (x);\
+		SMC_SET_INT_MASK(mask); \
+}
+
+/* this disables an interrupt from the interrupt mask register */
+
+#define SMC_DISABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = SMC_GET_INT_MASK();\
+		mask &= ~(x);\
+		SMC_SET_INT_MASK(mask); \
+}
+
+/* Note: the following macros do *not* select the bank. */
+#if USE_8_BIT
+#define SMC_GET_PN()		SMC_inb( ioaddr + PN_REG )
+#define SMC_SET_PN(x)		SMC_outb( (x), ioaddr + PN_REG )
+#define SMC_GET_AR()		SMC_inb( ioaddr + AR_REG )
+#define SMC_GET_INT()		SMC_inb( ioaddr + INT_REG )
+#define SMC_ACK_INT(x)		SMC_outb( (x), ioaddr + INT_REG )
+#define SMC_GET_INT_MASK()	SMC_inb( ioaddr + IM_REG )
+#define SMC_SET_INT_MASK(x)	SMC_outb( (x), ioaddr + IM_REG )
+#else
+#define SMC_GET_PN()		(SMC_inw( ioaddr + PN_REG ) & 0xFF)
+#define SMC_SET_PN(x)		SMC_outw( (x), ioaddr + PN_REG )
+#define SMC_GET_AR()		(SMC_inw( ioaddr + PN_REG ) >> 8)
+#define SMC_GET_INT()		(SMC_inw( ioaddr + INT_REG ) & 0xFF)
+#define SMC_ACK_INT(x)		SMC_outw( (SMC_GET_INT_MASK() << 8) | (x), \
+					  ioaddr + INT_REG )
+#define SMC_GET_INT_MASK()	(SMC_inw( ioaddr + INT_REG ) >> 8)
+#define SMC_SET_INT_MASK(x)	SMC_outw( (x) << 8, ioaddr + INT_REG )
+#endif
+
+#define SMC_GET_BASE()		SMC_inw( ioaddr + BASE_REG)
+#define SMC_SET_BASE(x)		SMC_outw( (x), ioaddr + BASE_REG)
+#define SMC_GET_CONFIG()	SMC_inw( ioaddr + CONFIG_REG)
+#define SMC_SET_CONFIG(x)	SMC_outw( (x), ioaddr + CONFIG_REG)
+#define SMC_GET_COUNTER()	SMC_inw( ioaddr + COUNTER_REG)
+#define SMC_SET_COUNTER(x)	SMC_outw( (x), ioaddr + COUNTER_REG)
+#define SMC_GET_CTL()		SMC_inw( ioaddr + CTL_REG)
+#define SMC_SET_CTL(x)		SMC_outw( (x), ioaddr + CTL_REG)
+#define SMC_GET_MII()		SMC_inw( ioaddr + MII_REG)
+#define SMC_SET_MII(x)		SMC_outw( (x), ioaddr + MII_REG)
+#define SMC_GET_MIR()		SMC_inw( ioaddr + MIR_REG)
+#define SMC_SET_MIR(x)		SMC_outw( (x), ioaddr + MIR_REG)
+#define SMC_GET_MMU_CMD()	SMC_inw( ioaddr + MMU_CMD_REG)
+#define SMC_SET_MMU_CMD(x)	SMC_outw( (x), ioaddr + MMU_CMD_REG)
+#define SMC_GET_PTR()		SMC_inw( ioaddr + PTR_REG)
+#define SMC_SET_PTR(x)		SMC_outw( (x), ioaddr + PTR_REG)
+#define SMC_GET_RCR()		SMC_inw( ioaddr + RCR_REG)
+#define SMC_SET_RCR(x)		SMC_outw( (x), ioaddr + RCR_REG)
+#define SMC_GET_REV()		SMC_inw( ioaddr + REV_REG)
+#define SMC_SET_REV(x)		SMC_outw( (x), ioaddr + REV_REG)
+#define SMC_GET_RPC()		SMC_inw( ioaddr + RPC_REG)
+#define SMC_SET_RPC(x)		SMC_outw( (x), ioaddr + RPC_REG)
+#define SMC_GET_RXFIFO()	SMC_inw( ioaddr + RXFIFO_REG)
+#define SMC_SET_RXFIFO(x)	SMC_outw( (x), ioaddr + RXFIFO_REG)
+#define SMC_GET_TCR()		SMC_inw( ioaddr + TCR_REG)
+#define SMC_SET_TCR(x)		SMC_outw( (x), ioaddr + TCR_REG)
+
+#define SMC_CLEAR_MCAST()	{\
+		SMC_outw( 0, ioaddr + MCAST_REG1); \
+		SMC_outw( 0, ioaddr + MCAST_REG2); \
+		SMC_outw( 0, ioaddr + MCAST_REG3); \
+		SMC_outw( 0, ioaddr + MCAST_REG4); \
+}
+#define SMC_SET_MCAST(x) {\
+		int i;\
+		word w;\
+		unsigned char *mt = (x);\
+		for ( i = 0; i < 8; i += 2 ) {\
+			w = mt[i] | (mt[i + 1] << 8);\
+			SMC_outw( w, ioaddr + MCAST_REG1 + i );\
+		}\
+}
+
+
+/*----------------------------------------------------------------------
+ . Define the interrupts that I want to receive from the card
+ .
+ . I want:
+ .  IM_EPH_INT, for nasty errors
+ .  IM_RCV_INT, for happy received packets
+ .  IM_RX_OVRN_INT, because I have to kick the receiver
+ .  IM_MDINT, for PHY Register 18 Status Changes
+ --------------------------------------------------------------------------*/
+#define SMC_INTERRUPT_MASK   (IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | \
+	IM_MDINT)
+
+
+#ifdef CONFIG_SYSCTL
+/*
+ * Declarations for the sysctl interface, which allows users the ability to
+ * control the finer aspects of the LAN91C111 chip.  Since the smc
+ * module currently registers its sysctl table dynamically, the sysctl path
+ * for module FOO is /proc/sys/dev/ethX/FOO
+ */
+#define CTL_SMC         (CTL_BUS+1389)      // arbitrary and hopefully unused
+
+enum {
+	CTL_SMC_INFO = 1,	// Sysctl files information
+	CTL_SMC_SWVER,		// Driver Software Version Info
+	CTL_SMC_SWFDUP,		// Switched Full Duplex Mode
+	CTL_SMC_EPHLOOP,	// EPH Block Internal Loopback
+	CTL_SMC_MIIOP,		// MII Operation
+	CTL_SMC_AUTONEG,	// Auto-negotiate Mode
+	CTL_SMC_RFDUPLX,	// Request Full Duplex Mode
+	CTL_SMC_RSPEED,		// Request Speed Selection
+	CTL_SMC_AFDUPLX,	// Actual Full Duplex Mode
+	CTL_SMC_ASPEED,		// Actual Speed Selection
+	CTL_SMC_LNKFAIL,	// Link Failed
+	CTL_SMC_FORCOL,		// Force a Collision
+	CTL_SMC_FILTCAR,	// Filter Carrier
+	CTL_SMC_FREEMEM,	// Free Buffer Memory
+	CTL_SMC_TOTMEM,		// Total Buffer Memory
+	CTL_SMC_LEDA,		// Output of LED-A
+	CTL_SMC_LEDB,		// Output of LED-B
+	CTL_SMC_CHIPREV,	// LAN91C111 Chip Revision ID
+#if SMC_DEBUG > 1
+	// Register access for debugging
+	CTL_SMC_REG_BSR,	// Bank Select
+	CTL_SMC_REG_TCR,	// Transmit Control
+	CTL_SMC_REG_ESR,	// EPH Status
+	CTL_SMC_REG_RCR,	// Receive Control
+	CTL_SMC_REG_CTRR,	// Counter
+	CTL_SMC_REG_MIR,	// Memory Information
+	CTL_SMC_REG_RPCR,	// Receive/Phy Control
+	CTL_SMC_REG_CFGR,	// Configuration
+	CTL_SMC_REG_BAR,	// Base Address
+	CTL_SMC_REG_IAR0,	// Individual Address 0
+	CTL_SMC_REG_IAR1,	// Individual Address 1
+	CTL_SMC_REG_IAR2,	// Individual Address 2
+	CTL_SMC_REG_GPR,	// General Purpose
+	CTL_SMC_REG_CTLR,	// Control
+	CTL_SMC_REG_MCR,	// MMU Command
+	CTL_SMC_REG_PNR,	// Packet Number
+	CTL_SMC_REG_FPR,	// FIFO Ports
+	CTL_SMC_REG_PTR,	// Pointer
+	CTL_SMC_REG_DR,		// Data
+	CTL_SMC_REG_ISR,	// Interrupt Status
+	CTL_SMC_REG_MTR1,	// Multicast Table Entry 1
+	CTL_SMC_REG_MTR2,	// Multicast Table Entry 2
+	CTL_SMC_REG_MTR3,	// Multicast Table Entry 3
+	CTL_SMC_REG_MTR4,	// Multicast Table Entry 4
+	CTL_SMC_REG_MIIR,	// Management Interface
+	CTL_SMC_REG_REVR,	// Revision
+	CTL_SMC_REG_ERCVR,	// Early RCV
+	CTL_SMC_REG_EXTR,	// External
+	CTL_SMC_PHY_CTRL,	// PHY Control
+	CTL_SMC_PHY_STAT,	// PHY Status
+	CTL_SMC_PHY_ID1,	// PHY ID1
+	CTL_SMC_PHY_ID2,	// PHY ID2
+	CTL_SMC_PHY_ADC,	// PHY Advertise Capability
+	CTL_SMC_PHY_REMC,	// PHY Advertise Capability
+	CTL_SMC_PHY_CFG1,	// PHY Configuration 1
+	CTL_SMC_PHY_CFG2,	// PHY Configuration 2
+	CTL_SMC_PHY_INT,	// PHY Interrupt/Status Output
+	CTL_SMC_PHY_MASK,	// PHY Interrupt/Status Mask
+#endif
+	// ---------------------------------------------------
+	CTL_SMC_LAST_ENTRY	// Add new entries above the line
+};
+#endif // CONFIG_SYSCTL
+#endif  /* _SMC_91111_H_ */
diff -p -purN linux-2.5/drivers/video/Makefile linuxppc-2.5/drivers/video/Makefile
--- linux-2.5/drivers/video/Makefile	2003-08-24 17:05:27.000000000 +0200
+++ linuxppc-2.5/drivers/video/Makefile	2003-08-25 21:44:54.000000000 +0200
@@ -54,6 +54,7 @@ obj-$(CONFIG_FB_PMAG_BA)          += pma
 obj-$(CONFIG_FB_PMAGB_B)          += pmagb-b-fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_MAXINE)           += maxinefb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_TX3912)           += tx3912fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+obj-$(CONFIG_FB_IBMLCDC)	  += ibmlcdfb.o
 
 obj-$(CONFIG_FB_MATROX)		  += matrox/ cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_RIVA)		  += riva/ cfbimgblt.o vgastate.o 
diff -p -purN linux-2.5/drivers/video/fbmem.c linuxppc-2.5/drivers/video/fbmem.c
--- linux-2.5/drivers/video/fbmem.c	2003-08-26 18:25:41.000000000 +0200
+++ linuxppc-2.5/drivers/video/fbmem.c	2003-09-01 00:49:53.000000000 +0200
@@ -143,6 +143,8 @@ extern int sstfb_init(void);
 extern int sstfb_setup(char*);
 extern int i810fb_init(void);
 extern int i810fb_setup(char*);
+extern int ibmlcdfb_init(void);
+extern int ibmlcdfb_setup(char*);
 extern int ffb_init(void);
 extern int ffb_setup(char*);
 extern int cg6_init(void);
@@ -253,6 +255,9 @@ static struct {
 #ifdef CONFIG_FB_STI
 	{ "stifb", stifb_init, stifb_setup },
 #endif
+#ifdef CONFIG_FB_IBMLCDC
+	{ "ibmlcdfb", ibmlcdfb_init, ibmlcdfb_setup },
+#endif
 #ifdef CONFIG_FB_FFB
 	{ "ffb", ffb_init, ffb_setup },
 #endif
diff -p -purN linux-2.5/drivers/video/ibmlcd.h linuxppc-2.5/drivers/video/ibmlcd.h
--- linux-2.5/drivers/video/ibmlcd.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/video/ibmlcd.h	2002-09-06 01:31:08.000000000 +0200
@@ -0,0 +1,417 @@
+/*
+ * linux/drivers/video/ibmlcd.h -- 
+ *    Driver for IBM Liquid Crystal Display Controller 
+ *    - original use in PowerPC 405LP embedded platform
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * David T. Eger   <eger@cc.gatech.edu>
+ * Matthew Helsley <mhelsley@linux.ucla.edu>
+ * Bishop Brock    <bcbrock@us.ibm.com>
+ * August 2001
+ *
+ * March 2002 : Modified for Initial Release
+ *              Bishop Brock, bcbrock@us.ibm.com
+ */
+
+#ifndef __IBMLCDC_H__
+#define __IBMLCDC_H__
+
+/* Provide debugging-level ioctl()'s to dump registers directly? */
+/* #define DEBUG_IBMLCD */
+
+#ifdef __KERNEL__
+#include <linux/fb.h>
+#include <asm/semaphore.h>
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/ibm4xx.h>
+#endif
+
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+
+#define IBMLCD_IDSTRING	"IBM LCDC"
+
+/* track if a par we are passed has been properly initialized */
+#define IBMLCD_INIT_MAGIC 0x1CDC600D
+
+/* Default amount of Mem to alloc for the Framebuffer */
+#define DEFAULT_FB_MEM 0x00100000
+
+struct ibmlcdfb_par;
+
+#ifdef DEBUG_IBMLCD
+struct ibmlcd_raw_dcrs;
+
+ /* Debugging IOCTLs */
+
+ /* Read the raw values of the LCD DCRs and report report 
+  * them to user space at the user address given */
+#define FBIO_GETRAW_HW  _IOR('F',0x18,struct ibmlcd_raw_dcrs)
+
+ /* Read the raw values out of the LCD DCRs, convert their
+  * values to that of a par struct, and report them to user
+  * space at the user address given */
+#define FBIO_GETHW_PAR	_IOR('F',0x19,struct ibmlcdfb_par)
+
+ /* #define FBIO_SETHW_PAR      _IOW('F',0x1A, struct ibmlcdfb_par) */
+
+ /* Return the locality that this driver believes itself to be 
+  *  - IBMLCD_ON_CHIP or IBMLCD_ON_BOARD_PECAN */
+#define FBIO_GETLOCALE  _IO('F',0x1B)
+
+#endif
+
+/* Note:  This driver was written long before the LCDC DCRs obtained their
+   "official" names in the 405LP manual.  At some point we should go back and
+   make the names consistent, but for now, these #defines serve as a
+   translation key.*/
+
+/* Direct-mapped DCRs.  */
+
+#define LCDC0_CR      DCRN_LCD0_CFG	/* Configuration Register */
+#define LCDC0_ICR     DCRN_LCD0_ICR	/* Interrupt Control Register */
+#define LCDC0_ISR     DCRN_LCD0_ISR	/* Interrupt Status Register */
+#define LCDC0_IMR     DCRN_LCD0_IMR	/* Interrupt Mask Register */
+#define LCDC0_CFGADDR DCRN_LCD0_CFGADDR	/* Indirect Configuration Address */
+#define LCDC0_CFGDATA DCRN_LCD0_CFGDATA	/* Indirect Configuration Data */
+
+/* Indirect DCRs */
+
+#define LCDC0_DER     DCRN_LCD0_DER	/* Display Enable Regsiter */
+#define LCDC0_DCR     DCRN_LCD0_DCFG	/* Display Configuration Register */
+#define LCDC0_DSR     DCRN_LCD0_DSR	/* Display Status Register */
+#define LCDC0_DFRMR   DCRN_LCD0_FRDR	/* Dither and Frame Rate Modulation Reg. */
+#define LCDC0_PSR     DCRN_LCD0_SDR	/* Power On/Off Sequence Register */
+#define LCDC0_ADSR    DCRN_LCD0_ADSR	/* Active Display Size Register */
+#define LCDC0_TDSR    DCRN_LCD0_TDSR	/* Total Display Size Register */
+#define LCDC0_FPLCR   DCRN_LCD0_FPLCR	/* FPLINE Control Register */
+#define LCDC0_FPLOR   DCRN_LCD0_FPLOR	/* FPLINE Offset Register */
+#define LCDC0_FPFCR   DCRN_LCD0_FPFCR	/* FPFRAME Control Register */
+#define LCDC0_FPFOR   DCRN_LCD0_FPFOR	/* FPFRAME Offset Register */
+#define LCDC0_FPSCR   DCRN_LCD0_FPSCR	/* FPSHIFT Control Register */
+#define LCDC0_FPDRCR  DCRN_LCD0_FPDRR	/* FPDRDY Control Register */
+#define LCDC0_FPDACR  DCRN_LCD0_FPDCR	/* FPDATA Control Register */
+#define LCDC0_MISC    DCRN_LCD0_PFBFR	/* Miscellaneous Register */
+#define LCDC0_PFR     DCRN_LCD0_PFR	/* Pixel Format Register */
+#define LCDC0_BAR     DCRN_LCD0_FBBAR	/* Base Address Register */
+#define LCDC0_SR      DCRN_LCD0_STRIDE	/* Stride Register */
+#define LCDC0_PARBASE DCRN_LCD0_PAR	/* Palette Access Registers Base */
+#define LCDC0_CER     DCRN_LCD0_CER	/* Cursor Enable Register */
+#define LCDC0_CBAR    DCRN_LCD0_CBAR	/* Cursor Base Address Register */
+#define LCDC0_CLR     DCRN_LCD0_CLR	/* Cursor Location Register */
+#define LCDC0_CC0     DCRN_LCD0_CC0R	/* Cursor Color 0 */
+#define LCDC0_CC1     DCRN_LCD0_CC1R	/* Cursor Color 1 */
+#define LCDC0_PARn(n) DCRN_LCD0_PARn(n)	/* Palette Register n */
+
+#define LCDC0_PIXMAP_CUR_COLOR0 0
+#define LCDC0_PIXMAP_CUR_COLOR1 1
+#define LCDC0_PIXMAP_CUR_TRANSP 2
+#define LCDC0_PIXMAP_CUR_XOR    3
+#define LCDC0_PIXMAP_CURSOR_SIZE (64*64*2/8)
+	/* 64 pix by 64 pix by 2 bits / (8bits/byte) */
+
+/* Routines for accessing LCDC DCRs */
+
+#define write_lcdc_dcr(info,dcrn,rvalue) 	\
+do { 					\
+mtdcr((dcrn),(rvalue));	\
+}while(0)
+
+#define read_lcdc_dcr(info,dcrn) \
+({ mfdcr((dcrn)); })
+
+#define write_lcdc_dcri(info,dcrn, rvalue) \
+do {\
+	write_lcdc_dcr((info),LCDC0_CFGADDR,(dcrn));\
+	write_lcdc_dcr((info),LCDC0_CFGDATA,(rvalue));\
+}while(0)
+
+#define read_lcdc_dcri(info,dcrn) \
+({\
+	write_lcdc_dcr((info),LCDC0_CFGADDR,(dcrn));\
+	read_lcdc_dcr((info),LCDC0_CFGDATA);\
+})
+
+/* Structures to represent the LCDC registers */
+
+#ifdef DEBUG_IBMLCD
+
+struct ibmlcd_raw_dcrs {
+	__u32 der;
+	__u32 dcr;
+	__u32 dfrmr;
+	__u32 psr;
+	__u32 adsr;
+	__u32 tdsr;
+	__u32 fplcr;
+	__u32 fplor;
+	__u32 fpfcr;
+	__u32 fpfor;
+	__u32 fpscr;
+	__u32 fpdrcr;
+	__u32 fpdacr;
+	__u32 misc;
+	__u32 pfr;
+	__u32 bar;
+	__u32 sr;
+	__u32 cer;
+	__u32 cbar;
+	__u32 clr;
+	__u32 cc0;
+	__u32 cc1;
+};
+
+#endif
+
+#ifdef __KERNEL__
+
+/*
+ * struct ibmlcdfb_info
+ * 
+ * Warning! This is very C++ish.  
+ * We "subclass" from fb_info_gen - the struct that the "generic" fb driver
+ * 		expects - fbgen.c (see include/linux/fb.h)
+ * which "subclasses" from fb_info - the struct that the rest of the kernel
+ * 		expects. (see include/linux/fb.h)
+ * 		
+ * The purpose of this struct is to contain all of the information associated
+ * with a single framebuffer device.  In our case, we associate one framebuffer
+ * with each LCD Controller Core.
+ */
+struct ibmlcdfb_info {
+	struct fb_info info;	/* must be first so casting works */
+	struct semaphore sem;	/* lock on this framebuffer device */
+	struct list_head list;	/* provision for multiple LCDs */
+
+	unsigned int locality;	/* AV: 0,1,2,3 */
+
+	void *LCDC_pdcr_base;	/* ioremap() virtual addy */
+};
+
+#endif
+
+/* 
+ * This structure defines the hardware state of the graphics card. 
+ *
+ * The fields in this struct roughly equate to the bitfields of the
+ * registers we must set.  Unfortunately, the values are
+ * counter-intuitive.
+ * For example, for single scan mode, the DCR's bitfield is 0, and
+ * for double scan mode, the DCR's bitfield is 1, where more intutively,
+ * they should be 1 and 2.  Therefore, in our struct, we accept the
+ * values 1 and 2 instead of 0 and 1.  Accepted Values are indicated.
+ */
+struct ibmlcdfb_par {
+	/* Basic Hardware information */
+	__u32 magic;		/* struct set up = IBMLCD_INIT_MAGIC */
+
+	/* the difference between this and the base address register is 
+	 * that (1) this points to the *actual* beginning of video memory,  
+	 * the BAR may change with panning, and (2) the BAR is a physical 
+	 * address locally for IBMLCD_ON_CHIP and IBMLCD_ON_BOARD_PECAN,
+	 * and PCI-ish space for IBMLCD_VIA_PCI */
+	void *LCDC_vfb_base;	/* ioremap() virtual addy */
+	__u32 LCDC_dfb_base;	/* start of frame buffer memory adjusted 
+				   for device.  That is, it is the 
+				   physical address for soc and on_board
+				   and remote-PCI adjusted for pci */
+
+	/* Used when we allocate the framebuffer from main memory */
+	unsigned int num_fb_pages;	/* number of pages alloc'd for
+					   the framebuffer */
+	void *LCDC_vfb_orig;	/* pre-ioremap() virtual addy 
+				   from __get_free_pages() */
+
+	__u16 virt_xres;
+	__u16 virt_yres;
+
+	/* Much like the LCDC_vfb_base, and LCDC_dfb_base... */
+	void *LCDC_vcursor_base;
+	__u32 LCDC_dcursor_base;
+
+	/* Display Configuration Register - LCDC0_DCR */
+	unsigned int reduced_horiz_blanking:1;	/* AV: 0,1 */
+	unsigned int tft_multiplex_ratio:2;	/* AV: 1,2 */
+	unsigned int FPSHIFT_clocks:2;	/* AV: 1,2 */
+	unsigned int pixel_clock_per_shift_clock:4;	/* AV: 1-8 */
+	unsigned int n_scan_mode:2;	/* AV: 1,2 */
+	unsigned int LCD_panel_size:3;	/* AV: 0-7 */
+	unsigned int LCD_panel_type:2;	/* AV: 0,1,3 */
+
+	/* Dither and Frame Rate Modulation Register - LCDC0_DFRMR */
+	unsigned int FRM_bits:3;	/* AV: 0-4,7 */
+	unsigned int dither_bits:3;	/* AV: 0-4 */
+	unsigned int native_resolution_bits:4;	/* AV: 1-8 */
+
+	/* Power On/Off Sequence Register - LCDC0_PSR */
+	/* These signal delay values are in 2^(n-1) scan line periods */
+	/* except n=0, where there is no delay. */
+	unsigned int FPSHIFT_delay:4;	/* AV: 0-15 */
+	unsigned int FPFRAME_delay:4;	/* AV: 0-15 */
+	unsigned int FP_VEE_EN_delay:4;	/* AV: 0-15 */
+	unsigned int FP_EN_delay:4;	/* AV: 0-15 */
+
+	/* Active Display Size Register - LCDC0_ADSR */
+	unsigned int horiz_pixels:11;	/* AV: 1-2048 */
+	unsigned int vert_pixels:12;	/* AV: 1-2048 */
+	/* vert_pixels is the total number of pixels.
+	 *  the registers are funky and for dual scan mode take 
+	 *  half this value. */
+
+	/* Total Display Size Register - LCDC0_TDSR */
+	/*  These values incorporate the active scan + blanking */
+	unsigned int total_horiz_pixels:11;	/* AV: 1-2048 */
+	/* Horizontal display size in number of pixels
+	 * - must be integer multiple of effective_pclk_to_sclk ratio
+	 * - normal blanking => must be long enough to fetch pixel data
+	 * - reduced blanking => at least 4 +
+	 *                        "effective_pclk_to_sclk_ratio" */
+	unsigned int total_vert_pixels:12;	/* AV: 2-2048 */
+	/* v_blanking = total_vert_pixels - vert_pixels */
+	/* vert_pixels is the total number of pixels.
+	 *  the registers are funky and for dual scan mode take 
+	 *  half this value. */
+
+	/* FPLINE Control Register - LCDC0_FPLCR */
+	unsigned int FPLINE_mask_during_v_blank:1;	/* AV: 0,1 */
+	unsigned int FPLINE_polarity_negative:1;	/* AV: 0,1 */
+
+	/* FPLINE Offset Register - LCDC0_FPLOR */
+	unsigned int FPLINE_hoff_start:11;	/* AV: 1-2048 */
+	unsigned int FPLINE_hoff_end:11;	/* AV: 1-2048 */
+
+	/* FPFRAME Control Register - LCDC0_FPFCR */
+	unsigned int FPFRAME_hoff:11;	/* AV: 1-2048 */
+	unsigned int FPFRAME_polarity_negative:1;	/* AV: 0,1 */
+
+	/* FPFRAME Offset Register - LCDC0_FPFOR */
+	unsigned int FPFRAME_voff_start:11;	/* AV: 1-2048 */
+	unsigned int FPFRAME_voff_end:11;	/* AV: 1-2048 */
+
+	/* FPSHIFT Control Register - LCDC0_FPSCR */
+	unsigned int FPSHIFT_masking:2;	/* AV: 0,1,3 */
+	unsigned int FPSHIFT_valid_at_positive_edge:1;	/* AV: 0,1 */
+
+	/* FPDRDY Control Register - LCDC0_FPDRCR */
+	unsigned int FPDRDY_polarity_negative:1;	/* AV: 0,1 */
+
+	/* FPDATA Control Register - LCDC0_FPDACR */
+	unsigned int FPDATA_polarity_negative:1;	/* AV: 0,1 */
+
+	/* Miscellaneous Register - LCDC0_MISC */
+	unsigned int pixels_big_endian:1;	/* AV: 0,1 */
+
+	/* Pixel Format Register - LCDC0_PFR */
+	unsigned int pixel_packing:1;	/* AV: 0,1 */
+	unsigned int pixel_size:3;	/* AV: 0,1,5,6,7 */
+	unsigned int pixel_index_size:2;	/* AV: 0-3 */
+	unsigned int palette_enable:1;	/* AV: 0,1 */
+	unsigned int enable_surface:1;	/* AV: 0,1 */
+
+	/* Base Address Register - LCDC0_BAR */
+	__u32 fb_base_address;
+
+	/* Stride Register - LCDC0_SR */
+	unsigned int stride:13;
+
+	/* Cursor Enable Register - LCDC0_CER */
+	unsigned int cursor_enable:1;	/* AV: 0,1 */
+
+	/* Cursor Base Address Register - LCDC0_CBAR */
+	__u32 cursor_base_address;	/* AV: 1k granularity */
+
+	/* Cursor Location Register - LCDC0_CLR */
+	int cursor_x;		/* AV: -2048 - 2047 */
+	int cursor_y;		/* AV: -2048 - 2047 */
+
+	/* Cursor Color 0 - LCDC0_CC0 */
+	unsigned int cc0r:6;	/* AV: 0..63 */
+	unsigned int cc0g:6;	/* AV: 0..63 */
+	unsigned int cc0b:6;	/* AV: 0..63 */
+
+	/* Cursor Color 1 - LCDC0_CC1 */
+	unsigned int cc1r:6;	/* AV: 0..63 */
+	unsigned int cc1g:6;	/* AV: 0..63 */
+	unsigned int cc1b:6;	/* AV: 0..63 */
+
+	/* Timing - frequencies are in KHz */
+
+	unsigned int pixclk_min;
+	unsigned int pixclk_max;
+};
+
+/* Some field values */
+
+/* locality */
+#define IBMLCD_NOT_FOUND	0
+#define IBMLCD_ON_CHIP		1
+#define IBMLCD_ON_BOARD_PECAN	2
+
+/* power state - or'ed together */
+#define IBMLCD_HSYNC_ENABLE 0x00000002
+#define IBMLCD_VSYNC_ENABLE 0x00000001
+#define IBMLCD_POWER_OFF    0x04000000
+
+/* LCDC0_DCR - LCD_panel_size */
+#define TFT_3BIT	0
+#define STN_1BIT	0
+#define TFT_6BIT	1
+#define STN_2BIT	1
+#define TFT_9BIT	2
+#define STN_4BIT	2
+#define TFT_12BIT	3
+#define STN_8BIT	3
+#define TFT_15BIT	4
+#define STN_16BIT	4
+#define TFT_18BIT	5
+#define TFT_21BIT	6
+#define TFT_24BIT	7
+
+/* LCDC0_DCR - LCD_panel_type */
+#define IBMLCD_MONO_STN  0
+#define IBMLCD_COLOR_STN 2
+#define IBMLCD_COLOR_TFT 3
+
+/* LCDC0_FPSCR - FPSHIFT_masking */
+#define IBMLCD_FPSHIFT_NO_MASKING	       0
+#define IBMLCD_FPSHIFT_MASK_FOR_HORIZ	       1
+#define IBMLCD_FPSHIFT_MASK_FOR_HORIZ_AND_VERT 3
+
+/* LCDC0_PFR - pixel_packing */
+#define IBMLCD_RGB	0
+#define IBMLCD_BGR	1
+
+/* LCDC0_PFR - pixel_size */
+#define IBMLCD_PIX_INDEXED 0
+#define IBMLCD_PIX_15BPP   1
+#define IBMLCD_PIX_16BPP   5
+#define IBMLCD_PIX_24BPP   6
+#define IBMLCD_PIX_32BPP   7
+
+/* LCDC0_PFR - pixel_index_size */
+#define IBMLCD_PAL_1BPP 0
+#define IBMLCD_PAL_2BPP 1
+#define IBMLCD_PAL_4BPP 2
+#define IBMLCD_PAL_8BPP 3
+
+#endif
diff -p -purN linux-2.5/drivers/video/ibmlcdfb.c linuxppc-2.5/drivers/video/ibmlcdfb.c
--- linux-2.5/drivers/video/ibmlcdfb.c	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/drivers/video/ibmlcdfb.c	2002-09-06 01:31:08.000000000 +0200
@@ -0,0 +1,2013 @@
+/*
+ * linux/drivers/video/ibmlcdfb.c -- 
+ *    Driver for IBM Liquid Crystal Display Controller 
+ *    - original use in PowerPC 405LP embedded platform
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *  Copyright (C) 2001 David T. Eger   <eger@cc.gatech.edu>
+ *                     Matthew Helsley <mhelsley@linux.ucla.edu>
+ *                     Bishop Brock    <bcbrock@us.ibm.com>
+ *
+ *  Adapted from FB Skeleton by Geert Uytterhoeven 
+ *                   --- linux/drivers/video/skeletonfb.c
+ *  And Framebuffer non-cacheable memory allocation scheme inspired by
+ *                   --- linux/drivers/video/sa1100fb.c
+ *                   
+ * April 2002, Modified for initial public release
+ *             Bishop Brock, bcbrock@us.ibm.com
+ *             Simplified the emulation setup and removed PCI emulation
+ * Sept. 2002, Ported to 2.5  Todd Poynor <source@mvista.com>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/wrapper.h> /* mem_map_(un)reserve */
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/ctype.h>	/* isdigit, isxdigit */
+#include <asm/uaccess.h>	/* copy_[to|from]_user */
+#include <video/fbcon.h>
+#include "ibmlcd.h"
+
+#undef CEIL
+#define CEIL(n,d) (((n)+(d-1))/(d))
+
+/*
+ * Below is a collection of structures, each one defining the capabilities
+ * and default video mode for an LCD.  The values you enter here for resolution
+ * are taken to be the exact capabilities of the LCD, and cannot be changed at
+ * run time.  Some of the other characteristics, such as bit-depth and virtual
+ * resolution can be changed at run time.  
+ *
+ * In order to add a new profile, you need to do two things:
+ *    (1) Create a new structure describing your LCD panel
+ *        This involves getting the proper values to write to the
+ *        LCDC's registers.  A lot of them you can figure out, most of them,
+ *        you'll need to consult:
+ *         - "Liquid Crystal Display Controller Core" 
+ *            SA14-2342-00 IBM Microelectronics Division
+ *            (NOTE: IBM Confidential)
+ *         - linux/drivers/video/ibmlcd.h - contains definition of the 
+ *            par structure used here, what the fields mean,  and what 
+ *            ranges are valid for the given fields.
+ *    (2) Add your structure, and one or more unique aliases to it to 
+ *        ibmlcd_configs at the bottom of this file.
+ *    (3) Use the alias as a command line argument to the kernel.
+ *
+ * TODO: + Change the timing information presented here from precise values, 
+ *         to a usable range, for use with frequency-scaling and dynamic 
+ *         reprogramming of clock dividers
+ *       + Pass the physical screen size in mm width and height, to put in
+ *         the var struct.
+ */
+
+static const struct ibmlcdfb_par IBMLCD_CONFIG0 = {
+	/* DCR */
+	reduced_horiz_blanking:1,
+	tft_multiplex_ratio:1,
+	FPSHIFT_clocks:1,
+	pixel_clock_per_shift_clock:3,
+	n_scan_mode:1,
+	LCD_panel_size:STN_8BIT,
+	LCD_panel_type:IBMLCD_COLOR_STN,
+
+	/* DFRMR */
+	FRM_bits:4,
+	dither_bits:2,
+	native_resolution_bits:1,
+
+	/* PSR */
+	FPSHIFT_delay:12,
+	FPFRAME_delay:12,
+	FP_VEE_EN_delay:13,
+	FP_EN_delay:14,
+
+	/* ADSR */
+	horiz_pixels:320,
+	vert_pixels:240,
+
+	/* TDSR */
+	total_horiz_pixels:328,
+	total_vert_pixels:245,
+
+	FPLINE_mask_during_v_blank:0,
+	FPLINE_polarity_negative:0,
+
+	FPLINE_hoff_start:122,
+	/* 122 * 8/3 =  325; Yes this looks strange. */
+	/* Basic idea - setting hoff_start to zero resulted in screen
+	 * being shifted to the right several pixels.  To correct this,
+	 * we set the value here to the equivalent of -3 pixels in the
+	 * data stream.  -3 = 325 mod 328.
+	 * Why the 8/3?  The Controller sees 8 bit values, but sends 
+	 * 3 bit values packed to the LCD.  Yeah, funky, like I said.
+	 * Koji Ishii was the mastermind to figure this value out */
+	FPLINE_hoff_end:0,
+
+	FPFRAME_hoff:1,
+	FPFRAME_polarity_negative:0,
+
+	FPFRAME_voff_start:0,
+	FPFRAME_voff_end:1,
+
+	FPSHIFT_masking:IBMLCD_FPSHIFT_NO_MASKING,
+	FPSHIFT_valid_at_positive_edge:0,
+
+	FPDRDY_polarity_negative:0,
+	FPDATA_polarity_negative:0,
+
+	pixels_big_endian:1,
+	pixel_packing:IBMLCD_RGB,
+	pixel_size:IBMLCD_PIX_16BPP,
+	pixel_index_size:IBMLCD_PAL_8BPP,
+	palette_enable:0,
+	enable_surface:1,
+
+	fb_base_address:0,	/* dummy value */
+	stride:320 * 2,		/* 320 pixels, 2 bytes per pixel */
+	cursor_enable:0,
+	cursor_base_address:0,	/* dummy value */
+	cursor_x:0,
+	cursor_y:0,
+	cc0r:0, cc0g:0, cc0b:0,
+	cc1r:0xFF, cc1g:0xFF, cc1b:0xFF,
+
+	/* The Hitachi STN is specified for a Pixel clock in the range of 
+	   6 MHz to 8 Mhz.  CLock frequencies are in KHz */
+
+	pixclk_min:6000,
+	pixclk_max:8000
+};
+
+static const struct ibmlcdfb_par IBMLCD_CONFIG1 = {
+	/* DCR */
+	reduced_horiz_blanking:1,
+	tft_multiplex_ratio:1,
+	FPSHIFT_clocks:1,
+	pixel_clock_per_shift_clock:1,
+	n_scan_mode:1,
+	LCD_panel_size:TFT_18BIT,
+	LCD_panel_type:IBMLCD_COLOR_TFT,
+
+	/* FRMR */
+	FRM_bits:0,
+	dither_bits:0,
+	native_resolution_bits:6,
+
+	/* PSR */
+	FPSHIFT_delay:12,
+	FPFRAME_delay:12,
+	FP_VEE_EN_delay:13,
+	FP_EN_delay:14,
+
+	/* ADSR */
+	horiz_pixels:640,
+	vert_pixels:480,
+
+	/* TDSR */
+	total_horiz_pixels:800,
+	total_vert_pixels:525,
+
+	FPLINE_mask_during_v_blank:1,
+	FPLINE_polarity_negative:1,
+
+	FPLINE_hoff_start:640,	/* See comment in the first configuration */
+	FPLINE_hoff_end:0,
+
+	FPFRAME_hoff:1,
+	FPFRAME_polarity_negative:1,
+
+	FPFRAME_voff_start:480,
+	FPFRAME_voff_end:0,
+
+	FPSHIFT_masking:IBMLCD_FPSHIFT_NO_MASKING,
+	FPSHIFT_valid_at_positive_edge:0,
+
+	FPDRDY_polarity_negative:0,
+	FPDATA_polarity_negative:0,
+
+	pixels_big_endian:1,
+	pixel_packing:IBMLCD_RGB,
+	pixel_size:IBMLCD_PIX_16BPP,
+	pixel_index_size:IBMLCD_PAL_8BPP,
+	palette_enable:0,
+	enable_surface:1,
+
+	fb_base_address:0,	/* dummy value */
+	stride:640 * 2,		/* 640 pixels, 2 bytes per pixel */
+	cursor_enable:0,
+	cursor_base_address:0,	/* dummy value */
+	cursor_x:0,
+	cursor_y:0,
+	cc0r:0, cc0g:0, cc0b:0,
+	cc1r:0xFF, cc1g:0xFF, cc1b:0xFF,
+
+	/* The Toshiba TFT is specified for a Pixel clock in the range of 
+	   21.5 MHz to 28.6 Mhz.  Clock frequencies are in KHz */
+
+	pixclk_min:21500,
+	pixclk_max:28600
+};
+
+/* Format: A sequence of database entries, terminated by two consecutive NULLs
+ *	Each entry consists of:
+ *	+ a pointer to a (constant) par description for the LCD,
+ *	+ 1 or more pointers to (constant) descriptive strings / aliases,
+ *	+ a NULL
+ */
+static const void *ibmlcd_configs[] = {
+	/* First Entry */
+	&IBMLCD_CONFIG0,
+	"HitachiQVGA-STN",
+	"HitachiSC09Q002-AZA",
+	NULL,
+	/* Second Entry */
+	&IBMLCD_CONFIG1,
+	"ToshibaVGA-TFT",
+	"TosibaLTM04C380K",
+	NULL,
+	/* ... */
+	/* Last Entry */
+	NULL,
+};
+
+/* 
+ * The current state of the hardware.
+ */
+static struct ibmlcdfb_par current_par;
+
+    /* To go away in the near future */ 
+static struct display disp;
+
+static u32 pseudo_palette[17];
+
+const struct ibmlcdfb_par *
+ibmlcd_config_matching(char *description)
+{
+	void **entry = (void **) ibmlcd_configs;
+	while ((*entry) != NULL) {
+
+		char **name = (char **) (entry);
+		while (*++name != NULL)
+			if (!strcmp(description, *name)) {
+				printk(KERN_INFO
+				       "ibmlcdfb: Configuring for panel %s\n",
+				       *name);
+				return *entry;
+			}
+		entry = (void **) ++name;
+	}
+	return NULL;
+}
+
+const char *
+ibmlcd_config_name(const struct ibmlcdfb_par *par)
+{
+	const void **entry;
+	for (entry = ibmlcd_configs; (*entry) != NULL; entry++) {
+		if ((*entry) == par)
+			return *(entry + 1);
+		else
+			while (*entry != NULL)
+				entry++;
+	}
+	return "Invalid LCD Description";
+}
+
+/* macros to encode the register formatted translations of our struct */
+
+/* Information is packed very tightly into the registers of 
+ * the LCD Controller -- we have much easier access to that information
+ * in the ibmlcdfb_par, but must eventually read and write to the hardware
+ * registers.  These functions are for packing and unpacking data to register
+ * format.
+ *
+ * Bit numbering in PowerPC:
+ * MSB                                      LSB
+ *  0 ... 7 | 8 ... 15 | 16 ... 23 | 24 ... 31 
+ *
+ * Examples:
+ * 
+ * ret |= (par->reduced_horiz_blanking << (31-7))
+ *
+ *    This line inserts a bitfield  starting at bit 7 into
+ *    a 32 bit value that is being prepared to be written to a DCR
+ *
+ * ret |= ((par->FPSHIFT_clocks & 0x2) << (31-11-1))
+ *
+ *    This is a bit trickier.  You are allowed to set 1 or 2 clocks
+ *    in par->FPSHIFT_clocks.  However, these are encoded as 0 or 1
+ *    in bit 11 of the register.  You see?
+ */
+
+static inline __u32
+mk_dcr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->reduced_horiz_blanking << (31 - 7));
+	ret |= ((par->tft_multiplex_ratio & 0x2) << (31 - 10 - 1));
+	ret |= ((par->FPSHIFT_clocks & 0x2) << (31 - 11 - 1));
+	ret |= ((par->pixel_clock_per_shift_clock - 1) << (31 - 15));
+	ret |= ((par->n_scan_mode & 0x2) << (31 - 24 - 1));
+	ret |= ((par->LCD_panel_size) << (31 - 27));
+	ret |= ((par->LCD_panel_type) << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_dcr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->reduced_horiz_blanking = (value >> (31 - 7)) & 0x1;
+
+	par->tft_multiplex_ratio = (value >> (31 - 10 - 1)) & 0x2;
+	if (par->tft_multiplex_ratio != 0x2)
+		par->tft_multiplex_ratio = 1;
+
+	par->FPSHIFT_clocks = (value >> (31 - 11 - 1)) & 0x2;
+	if (par->FPSHIFT_clocks != 0x2)
+		par->FPSHIFT_clocks = 1;
+
+	par->pixel_clock_per_shift_clock = ((value >> (31 - 15)) & 0x7) + 1;
+
+	par->n_scan_mode = (value >> (31 - 24 - 1)) & 0x2;
+	if (par->n_scan_mode != 0x2)
+		par->n_scan_mode = 1;
+
+	par->LCD_panel_size = (value >> (31 - 27)) & 0x7;
+	par->LCD_panel_type = (value >> (31 - 31)) & 0x3;
+}
+
+static inline __u32
+mk_dfrmr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= ((par->FRM_bits) << (31 - 15));
+	ret |= ((par->dither_bits) << (31 - 23));
+	ret |= ((par->native_resolution_bits - 1) << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_dfrmr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FRM_bits = (value >> (31 - 15)) & 0x7;
+	par->dither_bits = (value >> (31 - 23)) & 0x7;
+	par->native_resolution_bits = ((value >> (31 - 31)) & 0x7) + 1;
+}
+
+static inline __u32
+mk_psr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= ((par->FPSHIFT_delay) << (31 - 19));
+	ret |= ((par->FPFRAME_delay) << (31 - 23));
+	ret |= ((par->FP_VEE_EN_delay) << (31 - 27));
+	ret |= ((par->FP_EN_delay) << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_psr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPSHIFT_delay = (value >> (31 - 19)) & 0xF;
+	par->FPFRAME_delay = (value >> (31 - 23)) & 0xF;
+	par->FP_VEE_EN_delay = (value >> (31 - 27)) & 0xF;
+	par->FP_EN_delay = (value >> (31 - 31)) & 0xF;
+}
+
+static inline __u32
+mk_adsr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->horiz_pixels << (31 - 15));
+	ret |= ((par->vert_pixels / par->n_scan_mode) << (31 - 31));
+	return ret;
+}
+
+/* must digest_dcr first */
+static inline void
+digest_adsr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->horiz_pixels = (value >> (31 - 15)) & 0x7FF;
+	par->vert_pixels = ((value >> (31 - 31)) & 0x7FF) * par->n_scan_mode;
+}
+
+static inline __u32
+mk_tdsr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->total_horiz_pixels << (31 - 15));
+	ret |= ((par->total_vert_pixels / par->n_scan_mode) << (31 - 31));
+	return ret;
+}
+
+/* must digest_dcr first */
+static inline void
+digest_tdsr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->total_horiz_pixels = (value >> (31 - 15)) & 0x7FF;
+	par->total_vert_pixels =
+	    ((value >> (31 - 31)) & 0x7FF) * par->n_scan_mode;
+}
+
+static inline __u32
+mk_fplcr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPLINE_mask_during_v_blank << (31 - 30));
+	ret |= (par->FPLINE_polarity_negative << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fplcr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPLINE_mask_during_v_blank = (value >> (31 - 30)) & 0x1;
+	par->FPLINE_polarity_negative = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_fplor(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPLINE_hoff_start << (31 - 15));
+	ret |= (par->FPLINE_hoff_end << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fplor(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPLINE_hoff_start = (value >> (31 - 15)) & 0x7FF;
+	par->FPLINE_hoff_end = (value >> (31 - 31)) & 0x7FF;
+}
+
+static inline __u32
+mk_fpfcr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPFRAME_hoff << (31 - 15));
+	ret |= (par->FPFRAME_polarity_negative << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpfcr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPFRAME_hoff = (value >> (31 - 15)) & 0x7FF;
+	par->FPFRAME_polarity_negative = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_fpfor(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPFRAME_voff_start << (31 - 15));
+	ret |= (par->FPFRAME_voff_end << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpfor(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPFRAME_voff_start = (value >> (31 - 15)) & 0x7FF;
+	par->FPFRAME_voff_end = (value >> (31 - 31)) & 0x7FF;
+}
+
+static inline __u32
+mk_fpscr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPSHIFT_masking << (31 - 30));
+	ret |= (par->FPSHIFT_valid_at_positive_edge << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpscr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPSHIFT_masking = (value >> (31 - 30)) & 0x3;
+	par->FPSHIFT_valid_at_positive_edge = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_fpdrcr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPDRDY_polarity_negative << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpdrcr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPDRDY_polarity_negative = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_fpdacr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPDATA_polarity_negative << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpdacr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPDATA_polarity_negative = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_misc(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->pixels_big_endian << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_misc(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->pixels_big_endian = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_pfr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->pixel_packing << (31 - 24));
+	ret |= (par->pixel_size << (31 - 27));
+	ret |= (par->pixel_index_size << (31 - 29));
+	ret |= (par->palette_enable << (31 - 30));
+	ret |= (par->enable_surface << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_pfr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->pixel_packing = (value >> (31 - 24)) & 0x1;
+	par->pixel_size = (value >> (31 - 27)) & 0x7;
+	par->pixel_index_size = (value >> (31 - 29)) & 0x3;
+	par->palette_enable = (value >> (31 - 30)) & 0x1;
+	par->enable_surface = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_bar(const struct ibmlcdfb_par *par)
+{
+	return par->fb_base_address;
+}
+
+static inline void
+digest_bar(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->fb_base_address = value;
+}
+
+static inline __u32
+mk_sr(const struct ibmlcdfb_par *par)
+{
+	return par->stride;
+}
+
+static inline void
+digest_sr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->stride = value & 0x1FFF;
+}
+
+static inline __u32
+mk_palent(const __u32 r, const __u32 g, const __u32 b)
+{
+	__u32 ret = 0;
+	ret |= ((0x3F & r) << (31 - 13));
+	ret |= ((0x3F & g) << (31 - 21));
+	ret |= ((0x3F & b) << (31 - 29));
+	return ret;
+}
+
+static inline __u32
+mk_cer(const struct ibmlcdfb_par *par)
+{
+	return par->cursor_enable;
+}
+
+static inline void
+digest_cer(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->cursor_enable = value & 0x1;
+}
+
+static inline __u32
+mk_cbar(const struct ibmlcdfb_par *par)
+{
+	return par->cursor_base_address;
+}
+
+static inline void
+digest_cbar(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->cursor_base_address = value & 0xFFFFFE00;
+}
+
+static inline __u32
+mk_clr(const struct ibmlcdfb_par *par)
+{
+	return (((par->cursor_x) << (31 - 15)) |
+		((par->cursor_y) << (31 - 31))) & 0x0FFF0FFF;
+}
+
+static inline void
+digest_clr(__u32 value, struct ibmlcdfb_par *par)
+{
+	int val = value;
+
+	/* Do some signed bit magic to extract the correct field
+	   (signed) field values -MH */
+	val = val << 4;
+	par->cursor_x = val >> (31 - 15 + 4);
+	par->cursor_y = (val << 12) >> (31 - 31 + 12);
+
+}
+
+static inline __u32
+mk_cc0(const struct ibmlcdfb_par *par)
+{
+	return mk_palent(par->cc0r, par->cc0g, par->cc0b);
+}
+
+static inline void
+digest_cc0(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->cc0r = (value >> (31 - 13)) & 0x3F;
+	par->cc0g = (value >> (31 - 21)) & 0x3F;
+	par->cc0b = (value >> (31 - 29)) & 0x3F;
+}
+
+static inline __u32
+mk_cc1(const struct ibmlcdfb_par *par)
+{
+	return mk_palent(par->cc1r, par->cc1g, par->cc1b);
+}
+
+static inline void
+digest_cc1(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->cc1r = (value >> (31 - 13)) & 0x3F;
+	par->cc1g = (value >> (31 - 21)) & 0x3F;
+	par->cc1b = (value >> (31 - 29)) & 0x3F;
+}
+
+static struct list_head fb_list;	/* provision for multiple LCDs */
+static struct semaphore fb_list_sem;	/* lock on the list */
+
+/* command line parameters passed to our driver
+ * - what sort of LCD is attached to this device? */
+static struct lcd_params {
+	const struct ibmlcdfb_par *par;
+	__u32 mem_length;
+	__u32 mem_location;	/* 0xFFFFFFFF if not specified */
+} lcd_params;
+
+int ibmlcdfb_init(void);
+int ibmlcdfb_setup(char *);
+
+/* ------------------- chipset specific functions -------------------------- */
+
+/* return bits per pixel in video RAM from the current par struct */
+static int
+bpp_from_par(const struct ibmlcdfb_par *par)
+{
+	int bpp;
+
+	switch (par->pixel_size) {
+	case IBMLCD_PIX_INDEXED:
+		switch (par->pixel_index_size) {
+		case IBMLCD_PAL_1BPP:
+			bpp = 1;
+			break;
+		case IBMLCD_PAL_2BPP:
+			bpp = 2;
+			break;
+		case IBMLCD_PAL_4BPP:
+			bpp = 4;
+			break;
+		case IBMLCD_PAL_8BPP:
+			bpp = 8;
+			break;
+		default:
+			bpp = 0;
+		}
+		break;
+	case IBMLCD_PIX_15BPP:	/* 15bpp and 16bpp both use 2 bytes */
+	case IBMLCD_PIX_16BPP:
+		bpp = 16;
+		break;
+	case IBMLCD_PIX_24BPP:
+		bpp = 24;
+		break;
+	case IBMLCD_PIX_32BPP:
+		bpp = 32;
+		break;
+	default:
+		bpp = 0;
+	}
+
+	return bpp;
+}
+
+/*
+ *  Fills in the 'fix' structure based on the values
+ *  in the `par' structure.
+ */
+int
+ibmlcd_encode_fix(struct fb_fix_screeninfo *fix,
+		  const void *vp, struct fb_info *inf)
+{
+	const struct ibmlcdfb_par *par = vp;
+	struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+	int bpp = bpp_from_par(par);
+
+	if (info->locality == IBMLCD_ON_CHIP)
+		strncpy(fix->id, IBMLCD_IDSTRING " (On-Chip)", 16);
+	else if (info->locality == IBMLCD_ON_BOARD_PECAN)
+		strncpy(fix->id, IBMLCD_IDSTRING " (Local)", 16);
+	else
+		strncpy(fix->id, IBMLCD_IDSTRING " (Attached How?)", 16);
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->type_aux = 0;
+	if (par->pixel_size == IBMLCD_PIX_INDEXED)
+		fix->visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		fix->visual = FB_VISUAL_TRUECOLOR;
+
+	/* How many pixels can we move the screen by with simple panning? */
+	fix->xpanstep = (bpp <= 8) ? (8 / bpp) : 1;
+	fix->ypanstep = 1;
+
+	fix->line_length = par->stride;
+	fix->accel = FB_ACCEL_NONE;
+	return 0;
+}
+
+/* 0 - Basic Check okay */
+static int
+par_inited(const struct ibmlcdfb_par *par)
+{
+	return (par->magic == IBMLCD_INIT_MAGIC);
+}
+
+/* 0 - prelim check OK */
+static int
+check_for_mem(const struct ibmlcdfb_par *par, 
+	      const struct fb_fix_screeninfo *fix)
+{
+	/* Simplistic model -- allocate enough  RAM at driver load for the
+	 * highest video mode you'll want */
+	long needed_ram =
+	    par->stride * par->virt_yres + LCDC0_PIXMAP_CURSOR_SIZE;
+
+	return (needed_ram > fix->smem_len) || (needed_ram > 16 * 1024 * 1024);	/* LCDC Doc, 3.3.17 - 16MB limit */
+}
+
+/*
+ *  Get the video params out of 'var'. If a value doesn't fit, round it up,
+ *  if it's too big, return -EINVAL.
+ *
+ *  Suggestion: Round up in the following order: bits_per_pixel, xres,
+ *  yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,
+ *  bitfields, horizontal timing, vertical timing.
+ *
+ *  par is a new struct; no one cares what is scribbled in it if we
+ *  return an error. Otherwise, the user can use it as a sane set of
+ *  settings to switch to that are as close to var as we can get.
+ */
+static int
+ibmlcd_decode_var(const struct fb_var_screeninfo *var,
+		  struct ibmlcdfb_par *par, struct fb_info *inf)
+{	
+	const struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+	unsigned int req_xres_virt, req_yres_virt;
+	int granularity, total_bits, bpp, pal_bits;
+
+	if (!par_inited(par)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: "
+		       "passed an uninitialized par\n");
+		return -EINVAL;
+	}
+
+	pal_bits = 0;
+
+	if (var->bits_per_pixel > 32) {
+		printk(KERN_WARNING "ibmlcd_decode_var: IBM LCDC Driver"
+		       " not written to support >32bpp modes.\n");
+		return -EINVAL;
+	}
+	/* These modes *should* be supported */
+	else if (var->bits_per_pixel > 24)
+		par->pixel_size = IBMLCD_PIX_32BPP;
+	else if (var->bits_per_pixel > 16)
+		par->pixel_size = IBMLCD_PIX_24BPP;
+	else if (var->bits_per_pixel > 15) {
+		par->pixel_size = IBMLCD_PIX_16BPP;
+	} else if (var->bits_per_pixel > 8) {
+		par->pixel_size = IBMLCD_PIX_15BPP;
+	} else if (var->bits_per_pixel > 4) {
+		pal_bits = 8;
+	} else if (var->bits_per_pixel > 2) {
+		pal_bits = 4;
+	} else if (var->bits_per_pixel > 1) {
+		pal_bits = 2;
+	} else {
+		pal_bits = 1;
+	}
+
+	if (pal_bits) {
+		/* We can do a palette here.  Otherwise it' no-go */
+		par->pixel_size = IBMLCD_PIX_INDEXED;
+		par->palette_enable = 1;
+		if (pal_bits == 1)
+			par->pixel_index_size = IBMLCD_PAL_1BPP;
+		else if (pal_bits == 2)
+			par->pixel_index_size = IBMLCD_PAL_2BPP;
+		else if (pal_bits == 4)
+			par->pixel_index_size = IBMLCD_PAL_4BPP;
+		else if (pal_bits == 8)
+			par->pixel_index_size = IBMLCD_PAL_8BPP;
+	} /* User requested a palettized (<=8 bpp) mode */
+	else {
+		par->palette_enable = 0;
+	}
+
+	/* Remember, these are LCDs, they can't change their resolution */
+	if ((var->xres > par->horiz_pixels) || (var->yres > par->vert_pixels)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: user requested a"
+		       " video mode with a higher resolution than"
+		       " supported by the LCD.\n");
+		return -EINVAL;
+	}
+
+	/* Calculate the stride with the virtual resolution they want */
+
+	/* with what granularity (in pixels) must the 
+	 *  base address register for the screen be set? */
+	granularity = bpp_from_par(par) / 8;
+	if (!granularity)	/* packed pixels */
+		granularity = 1;
+
+	/* we simply maintain our current resolution */
+	req_xres_virt = var->xres_virtual;
+	req_yres_virt = var->yres_virtual;
+	if (req_xres_virt < par->horiz_pixels)
+		req_xres_virt = par->horiz_pixels;
+	if (req_yres_virt < par->vert_pixels)
+		req_yres_virt = par->vert_pixels;
+
+	par->stride = CEIL(bpp_from_par(par) * req_xres_virt, 8);
+
+	if (par->stride > 0x1FFF) {	/* full bit pattern for the field */
+		printk(KERN_WARNING "ibmlcd_decode_var: user requested a"
+		       " video mode with a higher resolution than"
+		       " supported by Video RAM -- allocate more"
+		       " or use a lower bitdepth\n");
+		return -EINVAL;
+	}
+
+	par->virt_xres = (par->stride * 8) / bpp_from_par(par);
+	par->virt_yres = req_yres_virt;
+
+	if (check_for_mem(par, &info->info.fix)) {
+		/* can't possibly get that much video RAM */
+		printk(KERN_WARNING "ibmlcd_decode_var: user requested a"
+		       " video mode with a higher resolution than"
+		       " supported by Video RAM -- allocate more"
+		       " or use a lower bitdepth\n");
+		return -EINVAL;
+	}
+
+	if ((var->xoffset < 0) ||
+	    ((var->xoffset + par->horiz_pixels) > par->virt_xres)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: invalid xoffset=%d\n",
+		       var->xoffset);
+		return -EINVAL;
+	}
+	if ((var->yoffset < 0) ||
+	    ((var->yoffset + par->vert_pixels) > par->virt_yres)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: invalid yoffset=%d\n",
+		       var->yoffset);
+		return -EINVAL;
+	}
+
+	par->fb_base_address = par->LCDC_dfb_base + par->stride * var->yoffset;
+	par->fb_base_address += (var->xoffset * bpp_from_par(par)) / 8;
+
+	if (!var->grayscale && (par->LCD_panel_type == IBMLCD_MONO_STN)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: non-grayscale mode"
+		       " requested on monochrome LCD\n");
+		return -EINVAL;
+	}
+	if (var->grayscale && (par->LCD_panel_type != IBMLCD_MONO_STN)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: grayscale mode"
+		       " requested on color LCD\n");
+		return -EINVAL;
+	}
+
+	/* Assumption: only length of bitfields is important.  
+	 * They will inspect a generated var to find the proper offsets. */
+	if (var->transp.length != 0) {	/* we don't support transparency */
+		printk(KERN_WARNING "ibmlcd_decode_var: alpha channel "
+		       "requested, but not supported by hardware.\n");
+		return -EINVAL;
+	}
+	total_bits = var->red.length + var->green.length + var->blue.length;
+	bpp = bpp_from_par(par);
+
+	/* Check for inconsistencies between bpp's */
+	if ((total_bits > bpp) ||
+	    ((bpp == 16) &&
+	     ((var->red.length > 5) || (var->green.length > 6)
+	      || (var->blue.length > 5))
+	    ) || (		/* 24BPP or 32BPP */
+			 ((var->red.length > 8) || (var->green.length > 8)
+			  || (var->blue.length > 8))
+	    )
+	    ) {
+		printk(KERN_WARNING "ibmlcd_decode_var: bits per pixel"
+		       " data inconsistent for requested mode.\n");
+		return -EINVAL;
+	}
+
+	par->pixels_big_endian = 1;
+
+	/* NOTE! We assume that the timings in the database are correct
+	 * for our LCD.  We ignore timing information passed by the user
+	 */
+
+	return 0;
+}
+
+/*
+ *  Fill the 'var' structure based on the values in 'par' and maybe other
+ *  values read out of the hardware.
+ */
+static int
+ibmlcd_encode_var(struct fb_var_screeninfo *var,
+		  const struct ibmlcdfb_par *par)
+{
+	int bpp;
+	__u32 fb_rel_base_address;
+	var->xres = par->horiz_pixels;
+	var->yres = par->vert_pixels;
+	var->xres_virtual = par->virt_xres;
+	var->yres_virtual = par->virt_yres;
+	var->bits_per_pixel = bpp_from_par(par);
+
+	fb_rel_base_address = par->LCDC_dfb_base;
+
+	var->xoffset = (((par->fb_base_address - fb_rel_base_address)
+			 % par->stride) * 8)
+	    / var->bits_per_pixel;
+	var->yoffset = ((par->fb_base_address - fb_rel_base_address)
+			/ par->stride);
+	var->grayscale = (par->LCD_panel_type == IBMLCD_MONO_STN);
+
+	/* Assume packing is RGB, then reverse if we find it's BGR */
+	bpp = var->bits_per_pixel;
+	/* If there's a difference between the bpp and the number of
+	 * bits actually used for color, adjust here */
+	if (bpp == 32)
+		bpp = 24;
+	if ((bpp == 16) && (par->pixel_size == IBMLCD_PIX_15BPP))
+		bpp = 15;
+
+	var->red.length = var->blue.length = bpp / 3;
+	var->green.length = bpp - 2 * var->red.length;
+	var->blue.offset = 0;
+	var->green.offset = var->blue.length;
+	var->red.offset = var->blue.length + var->green.length;
+
+	/* if actually BGR, reverse */
+	if (par->pixel_packing == IBMLCD_BGR) {
+		int i = var->red.offset;
+		var->red.offset = var->blue.offset;
+		var->blue.offset = i;
+	}
+
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
+	var->transp.offset = var->transp.length = var->transp.msb_right = 0;
+
+	var->accel_flags = FB_ACCEL_NONE;
+
+	var->left_margin = 0;
+	var->right_margin = par->total_horiz_pixels - par->horiz_pixels;
+	var->upper_margin = 0;
+	var->lower_margin = par->total_vert_pixels - par->vert_pixels;
+
+	/* physical dimensions of the screen in mm ....
+	 * as if I know... assume 72 ppi */
+	var->height = (var->yres * 254) / 720;
+	var->width = (var->xres * 254) / 720;
+
+	/* From here on out, these values are trash.  We ignore all 
+	 * information on timings besides that which is stored
+	 * in our database. */
+	var->pixclock = 40000;
+
+	/* guessing here... */
+	var->nonstd = 0;
+	var->activate = FB_ACTIVATE_NOW;
+
+	/* FIX ME: Not a clue. */
+	var->hsync_len = 1;
+	var->vsync_len = 1;
+	var->sync = 0;
+	var->vmode = 0;
+
+	return 0;
+}
+
+static int 
+ibmlcd_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	int err;
+
+        if ((err = ibmlcd_decode_var(var, &current_par, info)) != 0)
+                return err;
+        ibmlcd_encode_var(var, (const struct ibmlcdfb_par *) &current_par);
+	return 0;
+}
+
+/*
+ *  Fill the hardware's 'par' structure.
+ */
+
+#ifdef DEBUG_IBMLCD
+static void
+ibmlcd_hard_get_raw(struct ibmlcd_raw_dcrs *dcrs,
+		    const struct ibmlcdfb_info *info)
+{
+	dcrs->der = read_lcdc_dcri(info, LCDC0_DER);
+	dcrs->dcr = read_lcdc_dcri(info, LCDC0_DCR);
+	dcrs->dfrmr = read_lcdc_dcri(info, LCDC0_DFRMR);
+	dcrs->psr = read_lcdc_dcri(info, LCDC0_PSR);
+	dcrs->adsr = read_lcdc_dcri(info, LCDC0_ADSR);
+	dcrs->tdsr = read_lcdc_dcri(info, LCDC0_TDSR);
+	dcrs->fplcr = read_lcdc_dcri(info, LCDC0_FPLCR);
+	dcrs->fplor = read_lcdc_dcri(info, LCDC0_FPLOR);
+	dcrs->fpfcr = read_lcdc_dcri(info, LCDC0_FPFCR);
+	dcrs->fpfor = read_lcdc_dcri(info, LCDC0_FPFOR);
+	dcrs->fpscr = read_lcdc_dcri(info, LCDC0_FPSCR);
+	dcrs->fpdrcr = read_lcdc_dcri(info, LCDC0_FPDRCR);
+	dcrs->fpdacr = read_lcdc_dcri(info, LCDC0_FPDACR);
+	dcrs->misc = read_lcdc_dcri(info, LCDC0_MISC);
+	dcrs->pfr = read_lcdc_dcri(info, LCDC0_PFR);
+	dcrs->bar = read_lcdc_dcri(info, LCDC0_BAR);
+	dcrs->sr = read_lcdc_dcri(info, LCDC0_SR);
+	dcrs->cer = read_lcdc_dcri(info, LCDC0_CER);
+	dcrs->cbar = read_lcdc_dcri(info, LCDC0_CBAR);
+	dcrs->clr = read_lcdc_dcri(info, LCDC0_CLR);
+	dcrs->cc0 = read_lcdc_dcri(info, LCDC0_CC0);
+	dcrs->cc1 = read_lcdc_dcri(info, LCDC0_CC1);
+}
+
+#endif
+
+#ifdef DEBUG_IBMLCD
+static void
+ibmlcd_hard_get_par(struct ibmlcdfb_par *par, const struct ibmlcdfb_info *info)
+{
+	const struct ibmlcdfb_par *infopar
+	    = (struct ibmlcdfb_par *) (info->info.par);
+
+	/* copy the couple of things that we manage */
+	memcpy(par, infopar, sizeof (struct ibmlcdfb_par));
+
+	digest_dcr(read_lcdc_dcri(info, LCDC0_DCR), par);
+	digest_dfrmr(read_lcdc_dcri(info, LCDC0_DFRMR), par);
+	digest_psr(read_lcdc_dcri(info, LCDC0_PSR), par);
+	digest_adsr(read_lcdc_dcri(info, LCDC0_ADSR), par);
+	digest_tdsr(read_lcdc_dcri(info, LCDC0_TDSR), par);
+	digest_fplcr(read_lcdc_dcri(info, LCDC0_FPLCR), par);
+	digest_fplor(read_lcdc_dcri(info, LCDC0_FPLOR), par);
+	digest_fpfcr(read_lcdc_dcri(info, LCDC0_FPFCR), par);
+	digest_fpfor(read_lcdc_dcri(info, LCDC0_FPFOR), par);
+	digest_fpscr(read_lcdc_dcri(info, LCDC0_FPSCR), par);
+	digest_fpdrcr(read_lcdc_dcri(info, LCDC0_FPDRCR), par);
+	digest_fpdacr(read_lcdc_dcri(info, LCDC0_FPDACR), par);
+	digest_misc(read_lcdc_dcri(info, LCDC0_MISC), par);
+	digest_pfr(read_lcdc_dcri(info, LCDC0_PFR), par);
+	digest_bar(read_lcdc_dcri(info, LCDC0_BAR), par);
+	digest_sr(read_lcdc_dcri(info, LCDC0_SR), par);
+	digest_cer(read_lcdc_dcri(info, LCDC0_CER), par);
+	digest_cbar(read_lcdc_dcri(info, LCDC0_CBAR), par);
+	digest_clr(read_lcdc_dcri(info, LCDC0_CLR), par);
+	digest_cc0(read_lcdc_dcri(info, LCDC0_CC0), par);
+	digest_cc1(read_lcdc_dcri(info, LCDC0_CC1), par);
+}
+#endif
+
+/*
+ *  Set the hardware according to 'par'.
+ */
+
+static int ibmlcd_blank(int blank_mode, struct fb_info *inf);
+
+static void
+ibmlcd_hard_set_par(const struct ibmlcdfb_par *par, struct ibmlcdfb_info *info)
+{
+	printk(KERN_DEBUG "ibmlcdfb: Setting hardware par,"
+	       " turning on LCD device.\n");
+
+	/* Do honest-to-goodness DCR writes */
+	/* First, reset the thing */
+	iobarrier_rw();
+	write_lcdc_dcri(info, LCDC0_DER, 0x00000000);
+	iobarrier_rw();
+	write_lcdc_dcr(info, LCDC0_CR, 0);	/* Reset value, no interrupts */
+	write_lcdc_dcr(info, LCDC0_ICR, 0);	/* Reset value */
+
+	write_lcdc_dcri(info, LCDC0_DCR, mk_dcr(par));
+	write_lcdc_dcri(info, LCDC0_DFRMR, mk_dfrmr(par));
+	write_lcdc_dcri(info, LCDC0_PSR, mk_psr(par));
+	write_lcdc_dcri(info, LCDC0_ADSR, mk_adsr(par));
+	write_lcdc_dcri(info, LCDC0_TDSR, mk_tdsr(par));
+	write_lcdc_dcri(info, LCDC0_FPLCR, mk_fplcr(par));
+	write_lcdc_dcri(info, LCDC0_FPLOR, mk_fplor(par));
+	write_lcdc_dcri(info, LCDC0_FPFCR, mk_fpfcr(par));
+	write_lcdc_dcri(info, LCDC0_FPFOR, mk_fpfor(par));
+	write_lcdc_dcri(info, LCDC0_FPSCR, mk_fpscr(par));
+	write_lcdc_dcri(info, LCDC0_FPDRCR, mk_fpdrcr(par));
+	write_lcdc_dcri(info, LCDC0_FPDACR, mk_fpdacr(par));
+	write_lcdc_dcri(info, LCDC0_MISC, mk_misc(par));
+	write_lcdc_dcri(info, LCDC0_PFR, mk_pfr(par));
+	write_lcdc_dcri(info, LCDC0_BAR, mk_bar(par));
+	write_lcdc_dcri(info, LCDC0_SR, mk_sr(par));
+	write_lcdc_dcri(info, LCDC0_CER, mk_cer(par));
+	write_lcdc_dcri(info, LCDC0_CBAR, mk_cbar(par));
+	write_lcdc_dcri(info, LCDC0_CLR, mk_clr(par));
+	write_lcdc_dcri(info, LCDC0_CC0, mk_cc0(par));
+	write_lcdc_dcri(info, LCDC0_CC1, mk_cc1(par));
+
+	/* Now we enable the device */
+	iobarrier_rw();
+	ibmlcd_blank(0, (struct fb_info *) info);
+	iobarrier_rw();
+
+}
+
+static int
+ibmlcd_set_par(struct fb_info *info)
+{
+	const struct ibmlcdfb_par *par = info->par;
+
+	if (!par_inited(par)) {
+		printk(KERN_ERR "ibmlcd_set_par: passed an invalid par struct");
+		return -EINVAL;
+	}
+
+	ibmlcd_hard_set_par(par, (struct ibmlcdfb_info *) info);
+	return 0;
+}
+
+/*
+ *  Set a single color register. The values supplied have a 16 bit
+ *  magnitude.
+ *  Return != 0 for invalid regno.
+ */
+static int
+ibmlcd_setcolreg(unsigned regno, unsigned red, unsigned green,
+		 unsigned blue, unsigned transp, struct fb_info *inf)
+{
+	__u32 reg_value;
+	int ncolors;
+	u32 v;
+	struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+
+	ncolors = bpp_from_par(info->info.par);
+
+	if (regno >= ncolors)
+		return -EINVAL;
+
+	if (((struct ibmlcdfb_par *) info->info.par)->pixel_size
+	    == IBMLCD_PIX_INDEXED) {
+		reg_value = mk_palent(red >> 10, green >> 10, blue >> 10);
+
+		/* Set the actual entry in the palette */
+		write_lcdc_dcri(info, LCDC0_PARn(regno), reg_value);
+	}
+
+       if (regno >= 16)
+           return 1;
+
+       red >>= (16 - info->info.var.red.length);
+       green >>= (16 - info->info.var.green.length);
+       blue >>= (16 - info->info.var.blue.length);
+
+       v = (red << info->info.var.red.offset) |
+           (green << info->info.var.green.offset) |
+           (blue << info->info.var.blue.offset) |
+           (transp << info->info.var.transp.offset);
+
+       switch (info->info.var.bits_per_pixel) {
+		case 8:
+           		((u8*)(info->info.pseudo_palette))[regno] = v;
+			break;	
+   		case 16:
+           		((u16*)(info->info.pseudo_palette))[regno] = v;
+			break;
+		case 24:
+		case 32:	
+           		((u32*)(info->info.pseudo_palette))[regno] = v;
+			break;
+       }
+
+       return 0;
+}
+
+/*
+ *  Pan (or wrap, depending on the `vmode' field) the display using the
+ *  `xoffset' and `yoffset' fields of the `var' structure.
+ *  If the values don't fit, return -EINVAL.
+ */
+static int
+ibmlcd_pan_display(struct fb_var_screeninfo *var, int con,
+		   struct fb_info *inf)
+{
+	struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+	struct ibmlcdfb_par *par = info->info.par;
+
+	if ((var->xoffset < 0) ||
+	    ((var->xoffset + par->horiz_pixels) > par->virt_xres))
+		return -EINVAL;
+	if ((var->yoffset < 0) ||
+	    ((var->yoffset + par->vert_pixels) > par->virt_yres))
+		return -EINVAL;
+
+	par->fb_base_address = par->LCDC_dfb_base + par->stride * var->yoffset;
+	par->fb_base_address += (var->xoffset * bpp_from_par(par)) / 8;
+
+	write_lcdc_dcri(info, LCDC0_BAR, mk_bar(par));
+
+	info->info.var.xoffset = var->xoffset;
+	info->info.var.yoffset = var->yoffset;
+
+	return 0;
+}
+
+/*
+ *  Blank the screen if blank_mode != 0, else unblank. If blank == NULL
+ *  then the caller blanks by setting the CLUT (Color Look Up Table) to all
+ *  black. Return 0 if blanking succeeded, != 0 if un-/blanking failed due
+ *  to e.g. a video mode which doesn't support it. Implements VESA suspend
+ *  and powerdown modes on hardware that supports disabling hsync/vsync:
+ *    blank_mode == 2: suspend vsync
+ *    blank_mode == 3: suspend hsync
+ *    blank_mode == 4: powerdown
+ */
+static int
+ibmlcd_blank(int blank_mode, struct fb_info *inf)
+{
+	const struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+	__u32 config, enable;
+
+	printk(KERN_DEBUG "ibmlcd_blank: called with value %d", blank_mode);
+
+	config = read_lcdc_dcr(info, LCDC0_CR);
+	enable = read_lcdc_dcri(info, LCDC0_DER);
+
+	if (blank_mode == 0) {
+
+		/* User wants to unblank (turn on) the display.  We set the
+		   Pixel clock frequency, power up the controller, and enable
+		   the display. */
+
+		printk(", unblanking the display\n");
+		{
+			const struct ibmlcdfb_par *infopar
+			    = (struct ibmlcdfb_par *) (info->info.par);
+
+			if (ibm405lp_set_pixclk(infopar->pixclk_min,
+						infopar->pixclk_max)) {
+				printk(KERN_ERR "ibmlcd: "
+				       "Pixel clock frequency request "
+				       "(%d, %d) failed.\n",
+				       infopar->pixclk_min,
+				       infopar->pixclk_max);
+				return -EINVAL;
+			}
+		}
+		write_lcdc_dcr(info, LCDC0_CR, config & (~IBMLCD_POWER_OFF));
+		write_lcdc_dcri(info, LCDC0_DER, enable | 0x1);
+
+	} else {
+
+		/* User wants to blank (turn off) the display.  We disable the
+		   display, power it off, and set the pixel clock to its
+		   minimum frequency. */
+
+		printk(", blanking the display\n");
+
+		write_lcdc_dcri(info, LCDC0_DER, enable & (~0x1));
+		write_lcdc_dcr(info, LCDC0_CR, config | IBMLCD_POWER_OFF);
+
+		if (ibm405lp_set_pixclk(0, 0)) {
+			printk(KERN_ERR "ibmlcd: "
+			       "Pixel clock frequency request "
+			       "(%d, %d) failed.\n", 0, 0);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+
+static void
+ibmlcd_set_disp(const void *par, struct display *disp, struct fb_info *inf)
+{
+#ifdef FBCON_HAS_CFB8
+	if (bpp_from_par(par) == 8) {
+		disp->dispsw = &fbcon_cfb8;
+	} else
+#endif
+#ifdef FBCON_HAS_CFB16
+	if (bpp_from_par(par) == 16) {
+		disp->dispsw = &fbcon_cfb16;
+		disp->dispsw_data = inf->pseudo_palette;
+	} else
+#endif
+#ifdef FBCON_HAS_CFB24
+	if (bpp_from_par(par) == 24) {
+		disp->dispsw = &fbcon_cfb24;
+		disp->dispsw_data = inf->pseudo_palette;
+	} else
+#endif
+#ifdef FBCON_HAS_CFB32
+	if (bpp_from_par(par) == 32) {
+		disp->dispsw = &fbcon_cfb32;
+		disp->dispsw_data = inf->pseudo_palette;
+	} else
+#endif
+	{
+		disp->dispsw = &fbcon_dummy;
+	}
+
+	disp->can_soft_blank = 0;
+	disp->var = inf->var;
+}
+
+/*
+  The default cursor pixmap
+
+  0 - black         LCDC0_PIXMAP_CUR_COLOR0
+  1 - white         LCDC0_PIXMAP_CUR_COLOR1
+  2 - transparent   LCDC0_PIXMAP_CUR_TRANSP
+  3 - xor           LCDC0_PIXMAP_CUR_XOR
+ */
+static __u32 dcursor[256] = {
+	0x5AAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x46AAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x41AAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x406AAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x401AAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x4006AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x4001AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x40006AAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x40001AAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x400556AA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x4106AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x4641AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x5A41AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAB06AAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAB06AAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAA5AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA
+};
+
+/*
+  Given a set of pixels, copy it into our
+  available cursor image format
+ */
+static void
+ibmlcd_set_default_cursor(struct ibmlcdfb_par *par, struct ibmlcdfb_info *info)
+{
+	unsigned char *cursor = par->LCDC_vcursor_base;
+	par->cc0r = par->cc0g = par->cc0b = 0;
+	par->cc1r = par->cc1g = par->cc1b = 63;
+
+	memcpy(cursor, dcursor, LCDC0_PIXMAP_CURSOR_SIZE);
+	write_lcdc_dcri(info, LCDC0_CBAR, mk_cbar(par));
+	write_lcdc_dcri(info, LCDC0_CC0, mk_cc0(par));
+	write_lcdc_dcri(info, LCDC0_CC1, mk_cc1(par));
+}
+
+static int
+ibmlcd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	     unsigned long arg, int console, struct fb_info *inf)
+{
+	struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+
+	down(&info->sem);
+
+	switch (cmd) {
+#ifdef DEBUG_IBMLCD
+
+	case FBIO_GETHW_PAR:
+		{
+			struct ibmlcdfb_par par;
+			ibmlcd_hard_get_par(&par, info);
+			up(&info->sem);
+			return copy_to_user((void *) arg, &par,
+					    sizeof (par)) ? -EFAULT : 0;
+		}
+		break;
+/*	case FBIO_SETHW_PAR: */
+	case FBIO_GETRAW_HW:
+		{
+			struct ibmlcd_raw_dcrs raw;
+			ibmlcd_hard_get_raw(&raw, info);
+			up(&info->sem);
+			return copy_to_user((void *) arg, &raw,
+					    sizeof (raw)) ? -EFAULT : 0;
+		}
+		break;
+	case FBIO_GETLOCALE:
+		up(&info->sem);
+		return info->locality;
+#endif
+	case FBIOGET_FCURSORINFO:
+		{
+			struct fb_fix_cursorinfo curs;
+			curs.crsr_xsize = 64;
+			curs.crsr_ysize = 64;
+			curs.crsr_width = 64;
+			curs.crsr_height = 64;
+			curs.crsr_color1 = 0;
+			/* FIXME - find closest color in the cmap */
+			curs.crsr_color2 = 0;
+			up(&info->sem);
+			return copy_to_user((void *) arg, &curs,
+					    sizeof (struct fb_fix_cursorinfo));
+		} break;
+	case FBIOGET_VCURSORINFO:
+		{
+			struct fb_var_cursorinfo curs;
+			curs.width = 64;
+			curs.height = 64;
+			curs.xspot = 0;
+			curs.yspot = 0;
+			curs.data[0] = 0;
+			up(&info->sem);
+			return copy_to_user((void *) arg, &curs,
+					    sizeof (struct fb_var_cursorinfo));
+		} break;
+	case FBIOPUT_VCURSORINFO:
+		{
+			/* struct fb_var_cursorinfo * curs = (struct fb_var_cursorinfo*)arg; */
+			up(&info->sem);
+			return -EINVAL;
+		}
+		break;
+	case FBIOGET_CURSORSTATE:
+		{
+			struct fb_cursorstate curs;
+			struct ibmlcdfb_par par;
+
+			digest_cer(read_lcdc_dcri(info, LCDC0_CER), &par);
+			digest_clr(read_lcdc_dcri(info, LCDC0_CLR), &par);
+
+			if (par.cursor_enable) {
+				curs.mode = FB_CURSOR_ON;
+			} else {
+				curs.mode = FB_CURSOR_OFF;
+			}
+
+			curs.xoffset = par.cursor_x;
+			curs.yoffset = par.cursor_y;
+
+			up(&info->sem);
+			return copy_to_user((void *) arg, &curs, sizeof (curs));
+		}
+		break;
+	case FBIOPUT_CURSORSTATE:
+		{
+			struct fb_cursorstate *curs
+			    = (struct fb_cursorstate *) arg;
+			struct ibmlcdfb_par par;
+
+			if ((par.cursor_x != curs->xoffset) ||
+			    (par.cursor_y != curs->yoffset) ||
+			    ((par.cursor_enable != 0) !=
+			     (curs->mode != FB_CURSOR_OFF))) {
+
+				/* Change state of LCD */
+				if (curs->mode == FB_CURSOR_ON) {
+					par.cursor_enable = 1;
+				} else {
+					par.cursor_enable = 0;
+				}
+
+				par.cursor_x = curs->xoffset;
+				par.cursor_y = curs->yoffset;
+
+				write_lcdc_dcri(info, LCDC0_CER, mk_cer(&par));
+				write_lcdc_dcri(info, LCDC0_CLR, mk_clr(&par));
+			} else {
+				/* No changium */
+			}
+			up(&info->sem);
+			return 0;
+		}
+		break;
+	default:
+		break;
+	}
+	up(&info->sem);
+	return -EINVAL;
+}
+
+/* ------------ Hardware Independent Functions ------------ */
+
+static struct fb_ops ibmlcdfb_ops = {
+	.owner          = THIS_MODULE,
+	.fb_set_var     = gen_set_var,
+	.fb_get_cmap    = gen_get_cmap,
+	.fb_set_cmap    = gen_set_cmap,
+	.fb_check_var   = ibmlcd_check_var,
+	.fb_set_par     = ibmlcd_set_par,
+	.fb_setcolreg   = ibmlcd_setcolreg,
+	.fb_blank       = ibmlcd_blank,
+	.fb_pan_display = ibmlcd_pan_display,
+	.fb_ioctl       = ibmlcd_ioctl,
+};
+
+static void
+ibmlcdfb_free_video_memory(struct ibmlcdfb_par *par)
+{
+	int i;
+	struct page *page;
+
+	page = virt_to_page(__va(par->LCDC_dfb_base));
+
+	for(i = 0; i < par->num_fb_pages; i++)
+		mem_map_unreserve(page+i);
+
+	consistent_free(par->LCDC_vfb_orig);
+}
+
+/* 
+ * ibmlcdfb_map_video_memory(par, params):
+ *
+ *      Allocates the DRAM memory for the frame buffer.  This buffer is  
+ *	remapped into a non-cached, non-buffered, memory region to  
+ *      allow palette and pixel writes to occur without flushing the 
+ *      cache.  Once this area is remapped, all virtual memory
+ *      access to the video memory should occur at the new region.
+ *                  ( Blatantly ripped from sa1100fb.c )
+ *      Responsible for setting up:
+ *         par->LCDC_vfb_orig
+ *         par->LCDC_dfb_base
+ *         par->num_fb_pages
+ *         par->LCDC_vfb_base 
+ *
+ * NB: Framebuffer *must* be in __GFP_DMA memory to take advantage of advanced
+ * memory power management options for 405 platforms.
+ */
+static int
+    __init
+ibmlcdfb_map_video_memory(struct ibmlcdfb_par *par, struct lcd_params *params)
+{
+	u_int order;
+	struct page *page;
+	void *allocated_region;
+	int i;
+
+	/* Find order required to allocate enough memory for framebuffer, and
+	   the number of extra pages. */
+
+	par->num_fb_pages = CEIL(params->mem_length, PAGE_SIZE);
+	order = get_order(par->num_fb_pages * PAGE_SIZE);
+
+	if (!(allocated_region =
+	      consistent_alloc(GFP_KERNEL | __GFP_DMA,
+			       (1 << (order + PAGE_SHIFT)),
+			       &par->LCDC_dfb_base))) {
+		printk(KERN_ERR "ibmlcdfb: Error from consistent_alloc()"
+		       " for framebuffer memory\n");
+		return -ENOMEM;
+	}
+
+	par->LCDC_vfb_base = allocated_region;
+	par->LCDC_vfb_orig = allocated_region;
+
+	printk(KERN_INFO
+	       "ibmlcdfb: FB 0x%08lx bytes at 0x%08lx (0x%08lx -> 0x%08lx)\n",
+	       par->num_fb_pages * PAGE_SIZE,
+	       (unsigned long) par->LCDC_vfb_base,
+	       (unsigned long) par->LCDC_dfb_base,
+	       (unsigned long) par->LCDC_vfb_orig);
+
+        /* Set reserved flag for fb memory to allow it to be remapped into */
+        /* user space by the common fbmem driver using remap_page_range(). */
+
+	page = virt_to_page(__va(par->LCDC_dfb_base));
+
+	for(i = 0; i < par->num_fb_pages; i++)
+		mem_map_reserve(page+i);
+
+	return 0;
+}
+
+static int __init
+ibmlcd_add(void)
+{
+	struct lcd_params *params = &lcd_params;
+	struct ibmlcdfb_info *fbinfo;
+	int ret = 0;
+
+	if (params->mem_location != 0xFFFFFFFF) {
+		printk(KERN_ERR "ibmlcdfb: User settable video RAM locations"
+		       " not yet supported.\n");
+		return -EINVAL;
+	}
+
+	fbinfo = kmalloc(sizeof (*fbinfo), GFP_KERNEL);
+	if (!fbinfo) {
+		ret = -ENOMEM;
+		goto err_out0;
+	}
+	memset(fbinfo, 0, sizeof (*fbinfo));
+
+	fbinfo->info.par = &current_par;
+	memcpy(&current_par, params->par, sizeof (struct ibmlcdfb_par));
+
+	fbinfo->info.disp = &disp;
+	// memset(fbinfo->info.disp, 0, sizeof (struct display));
+
+	/* fixup the par */
+
+	if ((ret = ibmlcdfb_map_video_memory(&current_par, params)) != 0)
+		goto err_out3;
+
+	current_par.virt_xres = current_par.horiz_pixels;
+	current_par.virt_yres = current_par.vert_pixels;
+
+	fbinfo->info.fix.smem_start = current_par.LCDC_dfb_base;
+	fbinfo->info.fix.smem_len = current_par.num_fb_pages << PAGE_SHIFT;
+
+	/* fix.smem_* need be set before check_for_mem */
+	if (check_for_mem(&current_par, 
+			  (const struct fb_fix_screeninfo *)&fbinfo->info.fix)) {
+		printk(KERN_WARNING "ibmlcdfb: Too little memory specified"
+		       " for resolution of LCD\n");
+		goto err_out4;
+	}
+
+	current_par.LCDC_vcursor_base = current_par.LCDC_vfb_base + 
+		(current_par.num_fb_pages << PAGE_SHIFT)
+		- LCDC0_PIXMAP_CURSOR_SIZE;
+
+	current_par.LCDC_dcursor_base =
+	    current_par.cursor_base_address =
+	    current_par.LCDC_dfb_base + 
+		(current_par.num_fb_pages << PAGE_SHIFT)
+		- LCDC0_PIXMAP_CURSOR_SIZE;
+
+	current_par.fb_base_address = current_par.LCDC_dfb_base;
+
+	/* initialize those structures */
+	fbinfo->locality = IBMLCD_ON_CHIP;
+	fbinfo->LCDC_pdcr_base = 0;	/* we don't use pseudo-DCRs */
+	strncpy(fbinfo->info.modename, ibmlcd_config_name(params->par), 40);
+
+	fbinfo->info.flags = FBINFO_FLAG_DEFAULT;
+	fbinfo->info.open = 0;
+
+	fbinfo->info.fbops = &ibmlcdfb_ops;
+	fbinfo->info.changevar = NULL;
+	fbinfo->info.currcon = -1;
+	fbinfo->info.node = NODEV;
+	fbinfo->info.pseudo_palette = pseudo_palette;
+
+	fbinfo->info.switch_con = gen_switch;
+	fbinfo->info.updatevar = gen_update_var;
+	fbinfo->info.screen_base = current_par.LCDC_vfb_base;
+
+	current_par.magic = IBMLCD_INIT_MAGIC;
+
+	ibmlcd_encode_var(&fbinfo->info.var, &current_par);
+	memcpy(&fbinfo->info.disp->var, &fbinfo->info.var,
+	       sizeof (struct fb_var_screeninfo));
+
+	/* for System on a Chip, it's done through DCRs */
+	fbinfo->info.fix.mmio_start = 0;
+	fbinfo->info.fix.mmio_len = 0;
+	ibmlcd_encode_fix(&fbinfo->info.fix, &current_par, 
+			  (struct fb_info *) fbinfo);
+
+	/* This should give a reasonable default video mode */
+
+	ibmlcd_set_par((struct fb_info *) fbinfo);
+	strcpy(fbinfo->info.fontname, "VGA8x8");
+
+	// FIXME: I ripped off cmap_len == 256 from other files.
+
+	fb_alloc_cmap(&fbinfo->info.cmap, 256, 0);
+
+#if 1 /* Eventually should be able to call gen_set_disp instead. */
+	ibmlcd_set_disp(&current_par, &disp, &fbinfo->info);
+#else
+	gen_set_disp(-1, &fbinfo->info);
+#endif
+
+	ibmlcd_set_default_cursor(&current_par, fbinfo);
+
+	init_MUTEX(&fbinfo->sem);
+
+	/* black out the screen */
+	memset(current_par.LCDC_vfb_base, 0, current_par.stride * 
+	       current_par.virt_yres);
+
+	if ((ret = register_framebuffer(&fbinfo->info)) < 0) {
+		printk(KERN_ERR "ibmlcdfb: Error registering"
+		       " framebuffer device\n");
+		goto err_out5;
+	}
+	printk(KERN_INFO "fb%d: %s frame buffer device\n",
+	       GET_FB_IDX(fbinfo->info.node), fbinfo->info.modename);
+
+	down(&fb_list_sem);
+	list_add(&(fbinfo->list), &fb_list);
+	up(&fb_list_sem);
+
+	return 0;
+      err_out5:
+	/* shut the LCDC off */
+	write_lcdc_dcri(fbinfo, LCDC0_DER, 0x00000000);
+	write_lcdc_dcr(fbinfo, LCDC0_CR, 0);
+	/* Reset value, no interrupts */
+	write_lcdc_dcr(fbinfo, LCDC0_ICR, 0);	/* Reset value */
+
+      err_out4:
+	/* free mem area */
+	ibmlcdfb_free_video_memory(&current_par);
+      err_out3:
+	kfree(fbinfo);
+      err_out0:
+	if (ret == -ENOMEM) {
+		printk(KERN_ERR
+		       "ibmlcdfb: Could not allocate auxilury fb structs\n");
+	}
+	return ret;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/*
+ *  Initialization
+ *
+ *  Command-line parameters are not needed for Beech (Pass 2 +), as an FPGA
+ *  register holds a switch setting indicating which panel is installed.
+ */
+
+static int setup_called = 0;
+
+int __init
+ibmlcdfb_init(void)
+{
+	INIT_LIST_HEAD(&fb_list);
+	init_MUTEX(&fb_list_sem);
+
+	if (!lcd_params.par) {
+#if defined(CONFIG_BEECH)
+		volatile u8 *beech_fpga_reg_0;
+
+		beech_fpga_reg_0 = (volatile u8 *)
+			ioremap(BEECH_FPGA_REG_0_PADDR, BEECH_FPGA_REG_0_SIZE);
+
+		if (beech_fpga_reg_0 == NULL) {
+			printk(KERN_ERR 
+			       "ibmlcdfb: ioremap of FPGA reg 0 at 0x%x failed.\n",
+			       BEECH_FPGA_REG_0_PADDR);
+			return -EINVAL;
+		}
+
+		if (*beech_fpga_reg_0 & FPGA_REG_0_HITA_TOSH_N)
+			lcd_params.par =
+			    ibmlcd_config_matching("HitachiQVGA-STN");
+		else
+			lcd_params.par =
+			    ibmlcd_config_matching("ToshibaVGA-TFT");
+
+		iounmap((void *) beech_fpga_reg_0);
+#endif
+	}
+
+	if (!setup_called) {
+		lcd_params.mem_length = DEFAULT_FB_MEM;
+		lcd_params.mem_location = 0xFFFFFFFF;
+	}
+
+	if (lcd_params.par) {
+		if (ibmlcd_add())
+			printk(KERN_WARNING "ibmlcdfb: Error initializing"
+			       " LCDC core\n");
+		else
+			printk(KERN_INFO "ibmlcdfb: LCDC initialized\n");
+	} else {
+		printk(KERN_ERR "ibmlcdfb: Error - No Panel Selected\n");
+	}
+
+	return 0;
+}
+
+/*
+ *  Setup
+ *
+ *  The IBM Liquid Crystal Display Core is available in two configurations.
+ *  (1) System On A Chip - where the LCDC is on chip in a PowerPC derivate
+ *  (2) On Board - in the FPGA of the Pecan Board
+ *
+ *  These options are deprecated as command-line options.
+ *
+ *  This code is only called if a video=ibmlcdfb: option is given.  If not, a
+ *  default panel will be selected in ibmlcdfb_init above.
+ */
+
+int __init
+ibmlcdfb_setup(char *options)
+{
+	char *this_opt;
+	char *nextopt = options;
+	struct lcd_params *params = &lcd_params;
+
+	setup_called = 1;
+
+	params->par = NULL;
+	params->mem_length = DEFAULT_FB_MEM;
+	params->mem_location = 0xFFFFFFFF;
+
+	printk(KERN_INFO "ibmlcdfb: Parsing options: %s\n", options);
+
+	if (options && *options) {
+		for (this_opt = strsep(&nextopt, ","); this_opt;
+		     this_opt = strsep(&nextopt, ",")) {
+
+			if (!*this_opt)
+				continue;
+
+				/* Assume it's the LCD name */
+			params->par = ibmlcd_config_matching(this_opt);
+			if (!params->par)
+				printk(KERN_WARNING "ibmlcdfb: %s is"
+				       " not a known LCD.  Add a"
+				       " profile to"
+				       " ibmlcds.c\n", this_opt);
+		}
+	}
+	return 0;
+}
+
+#undef CEIL
+
+/* ------------------------------------------------------------------------- */
+
+    /*
+     *  Modularization
+     */
+
+    /*
+     *  Cleanup
+     */
+
+#ifdef MODULE
+
+static void __devexit
+ibmlcd_deconfigure(void)
+{
+	struct list_head *p;
+	struct ibmlcdfb_info *fbinfo;
+	struct ibmlcdfb_par *par;
+
+	down(&fb_list_sem);
+	list_for_each(p, &fb_list) {
+		fbinfo = list_entry(p, struct ibmlcdfb_info, list);
+		par = (struct ibmlcdfb_par *) fbinfo->info.par;
+
+		/* FIXME: handle -EBUSY */
+		unregister_framebuffer((struct fb_info *) fbinfo);
+		/* shut the LCDC off */
+		write_lcdc_dcri(fbinfo, LCDC0_DER, 0x00000000);
+		write_lcdc_dcr(fbinfo, LCDC0_CR, 0);
+		/* Reset value, no interrupts */
+		write_lcdc_dcr(fbinfo, LCDC0_ICR, 0);	/* Reset value */
+
+		if (par->LCDC_vfb_base)
+			iounmap(par->LCDC_vfb_base);
+		ibmlcdfb_free_video_memory(par);
+		kfree(fbinfo->info.disp);
+		kfree(fbinfo->info.par);
+		list_del(&fbinfo->list);
+		kfree(fbinfo);
+	}
+	up(&fb_list_sem);
+}
+
+static void
+ibmlcdfb_cleanup(struct fb_info *inf)
+{
+	ibmlcd_deconfigure();
+}
+
+int
+init_module(void)
+{
+	return ibmlcdfb_init();
+}
+
+void
+cleanup_module(void)
+{
+	ibmlcdfb_cleanup(void);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("(c) 2001 David T Eger <dteger@cc.gatech.edu>");
+MODULE_DESCRIPTION("IBM Liquid Crystal Display Controller driver");
+
+#endif				/* MODULE */
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -p -purN linux-2.5/drivers/video/radeonfb.c linuxppc-2.5/drivers/video/radeonfb.c
--- linux-2.5/drivers/video/radeonfb.c	2003-07-31 17:58:45.000000000 +0200
+++ linuxppc-2.5/drivers/video/radeonfb.c	2003-08-04 01:59:25.000000000 +0200
@@ -24,12 +24,29 @@
  *	2002-09-21	rv250, r300, m9 initial support,
  *			added mirror option, 0.1.6
  *
- *	Special thanks to ATI DevRel team for their hardware donations.
+ * Other change (--BenH)
+ * 
+ * 	2003-01-01	Tweaks for PLL on some iBooks
+ * 	2003-01-01	Fix SURFACE_CNTL usage on r9000	
+ *      2003-03-23	Added new Power Management code from ATI
+ *      2003-03-23	Added default PLL values for r300 from lkml
+ *      2003-03-26	Never set TMDS_PLL_EN, it seem to break more than
+ *                      just old r300's
+ *
+ *	Special thanks to ATI DevRel team for their hardware donations,
+ *	and for spending the time to fix the power management code !
+ *	
+ *	Note: This driver in in bad need of beeing completely re-organized.
+ *	      My long term plans, if I ever get enough time for that, is
+ *	      to split the actual mode setting code so it can properly 
+ *	      work on any head, the probe code, which will be stuffed with
+ *	      OF parsing on PPC and i2c fallback (look at what XFree does)
+ *	      and the PM code ought to be in a separate file. --BenH.
  *
  */
 
 
-#define RADEON_VERSION	"0.1.6"
+#define RADEON_VERSION	"0.1.6-ben"
 
 
 #include <linux/config.h>
@@ -310,6 +327,7 @@ struct radeon_regs {
 	u32 crtc_gen_cntl;
 	u32 crtc_ext_cntl;
 	u32 dac_cntl;
+	u32 crtc_more_cntl;
 
 	u32 flags;
 	u32 pix_clock;
@@ -359,6 +377,8 @@ struct radeonfb_info {
 	unsigned long mmio_base;
 	unsigned long fb_base;
 
+	u32 fb_local_base;
+
 	struct pci_dev *pdev;
 
 	unsigned char *EDID;
@@ -683,6 +703,8 @@ static char noaccel = 1;
 static char mirror = 0;
 static int panel_yres __initdata = 0;
 static char force_dfp __initdata = 0;
+static char force_crt __initdata = 0;
+static char force_nolcd __initdata = 0;
 static struct radeonfb_info *board_list = NULL;
 static char nomtrr __initdata = 0;
 
@@ -1229,6 +1251,83 @@ static int radeon_read_OF (struct radeon
 #endif	
 
 
+#ifdef CONFIG_PPC_PMAC
+#undef SET_MC_FB_FROM_APERTURE
+static void
+fixup_memory_mappings(struct radeonfb_info *rinfo)
+{
+	u32 save_crtc_gen_cntl, save_crtc2_gen_cntl;
+	u32 save_crtc_ext_cntl;
+	u32 aper_base, aper_size;
+	u32 agp_base;
+
+	/* First, we disable display to avoid interfering */
+	if (rinfo->hasCRTC2) {
+		save_crtc2_gen_cntl = INREG(CRTC2_GEN_CNTL);
+		OUTREG(CRTC2_GEN_CNTL, save_crtc2_gen_cntl | CRTC2_DISP_REQ_EN_B);
+	}
+	save_crtc_gen_cntl = INREG(CRTC_GEN_CNTL);
+	save_crtc_ext_cntl = INREG(CRTC_EXT_CNTL);
+	
+	OUTREG(CRTC_EXT_CNTL, save_crtc_ext_cntl | CRTC_DISPLAY_DIS);
+	OUTREG(CRTC_GEN_CNTL, save_crtc_gen_cntl | CRTC_DISP_REQ_EN_B);
+	mdelay(100);
+
+	aper_base = INREG(CONFIG_APER_0_BASE);
+	aper_size = INREG(CONFIG_APER_SIZE);
+
+#ifdef SET_MC_FB_FROM_APERTURE
+	/* Set framebuffer to be at the same address as set in PCI BAR */
+	OUTREG(MC_FB_LOCATION, 
+		((aper_base + aper_size - 1) & 0xffff0000) | (aper_base >> 16));
+	rinfo->fb_local_base = aper_base;
+#else
+	OUTREG(MC_FB_LOCATION, 0x7fff0000);
+	rinfo->fb_local_base = 0;
+#endif
+	agp_base = aper_base + aper_size;
+	if (agp_base & 0xf0000000)
+		agp_base = (aper_base | 0x0fffffff) + 1;
+
+	/* Set AGP to be just after the framebuffer on a 256Mb boundary. This
+	 * assumes the FB isn't mapped to 0xf0000000 or above, but this is
+	 * always the case on PPCs afaik.
+	 */
+#ifdef SET_MC_FB_FROM_APERTURE
+	OUTREG(MC_AGP_LOCATION, 0xffff0000 | (agp_base >> 16));
+#else
+	OUTREG(MC_AGP_LOCATION, 0xffffe000);
+#endif
+
+	/* Fixup the display base addresses & engine offsets while we
+	 * are at it as well
+	 */
+#ifdef SET_MC_FB_FROM_APERTURE
+	OUTREG(DISPLAY_BASE_ADDR, aper_base);
+	if (rinfo->hasCRTC2)
+		OUTREG(CRTC2_DISPLAY_BASE_ADDR, aper_base);
+#else
+	OUTREG(DISPLAY_BASE_ADDR, 0);
+	if (rinfo->hasCRTC2)
+		OUTREG(CRTC2_DISPLAY_BASE_ADDR, 0);
+#endif
+	mdelay(100);
+
+	/* Restore display settings */
+	OUTREG(CRTC_GEN_CNTL, save_crtc_gen_cntl);
+	OUTREG(CRTC_EXT_CNTL, save_crtc_ext_cntl);
+	if (rinfo->hasCRTC2)
+		OUTREG(CRTC2_GEN_CNTL, save_crtc2_gen_cntl);	
+
+#if 0
+	printk("aper_base: %08x MC_FB_LOC to: %08x, MC_AGP_LOC to: %08x\n",
+		aper_base,
+		((aper_base + aper_size - 1) & 0xffff0000) | (aper_base >> 16),
+		0xffff0000 | (agp_base >> 16));
+#endif
+}
+#endif /* CONFIG_PPC_PMAC */
+
 static void radeon_engine_init (struct radeonfb_info *rinfo)
 {
 	u32 temp;
@@ -1244,10 +1343,13 @@ static void radeon_engine_init (struct r
 	/* XXX */
 	rinfo->pitch = ((rinfo->xres_virtual * (rinfo->bpp / 8) + 0x3f)) >> 6;
 
-	radeon_fifo_wait (1);
+	radeon_fifo_wait (3);
 	temp = INREG(DEFAULT_PITCH_OFFSET);
 	OUTREG(DEFAULT_PITCH_OFFSET, ((temp & 0xc0000000) | 
-				      (rinfo->pitch << 0x16)));
+				      (rinfo->pitch << 0x16) |
+				      (rinfo->fb_local_base >> 10)));
+	OUTREG(DST_PITCH_OFFSET, (rinfo->pitch << 0x16) | (rinfo->fb_local_base >> 10));
+	OUTREG(SRC_PITCH_OFFSET, (rinfo->pitch << 0x16) | (rinfo->fb_local_base >> 10));
 
 	radeon_fifo_wait (1);
 	OUTREGP(DP_DATATYPE, 0, ~HOST_BIG_ENDIAN_EN);
@@ -1300,6 +1402,7 @@ static int __devinit radeon_init_disp (s
 	fb_alloc_cmap(&info->cmap, 256, 0);
 
 	var.activate = FB_ACTIVATE_NOW;
+	fb_set_var(info, &var);
         return 0;
 }
 
@@ -1573,8 +1676,8 @@ static int radeonfb_ioctl (struct inode 
 			}
 
 			OUTREG(CRTC_EXT_CNTL, tmp);
+			return 0;
 
-			break;
 		case FBIO_RADEON_GET_MIRROR:
 			switch (rinfo->arch) {
 				case RADEON_R100:
@@ -1598,8 +1701,6 @@ static int radeonfb_ioctl (struct inode 
 				value |= 0x02;
 
 			return put_user(value, (__u32*)arg);
-		default:
-			return -EINVAL;
 	}
 
 	return -EINVAL;
@@ -1661,7 +1762,7 @@ static int radeonfb_setcolreg (unsigned 
                              unsigned blue, unsigned transp, struct fb_info *info)
 {
         struct radeonfb_info *rinfo = (struct radeonfb_info *) info;
-	u32 pindex, vclk_cntl;
+	u32 pindex;
 	unsigned int i;
 	
 	if (regno > 255)
@@ -1678,9 +1779,18 @@ static int radeonfb_setcolreg (unsigned 
         pindex = regno;
 
         if (!rinfo->asleep) {
+        	u32 dac_cntl2, vclk_cntl;
+
 		vclk_cntl = INPLL(VCLK_ECP_CNTL);
 		OUTPLL(VCLK_ECP_CNTL, vclk_cntl & ~PIXCLK_DAC_ALWAYS_ONb);
 
+		/* Make sure we are on first palette */
+		if (rinfo->hasCRTC2) {
+			dac_cntl2 = INREG(DAC_CNTL2);
+			dac_cntl2 &= ~DAC2_PALETTE_ACCESS_CNTL;
+			OUTREG(DAC_CNTL2, dac_cntl2);
+		}
+
 		if (rinfo->bpp == 16) {
 			pindex = regno * 8;
 
@@ -1737,6 +1847,7 @@ static void radeon_save_state (struct ra
 	/* CRTC regs */
 	save->crtc_gen_cntl = INREG(CRTC_GEN_CNTL);
 	save->crtc_ext_cntl = INREG(CRTC_EXT_CNTL);
+	save->crtc_more_cntl = INREG(CRTC_MORE_CNTL);
 	save->dac_cntl = INREG(DAC_CNTL);
         save->crtc_h_total_disp = INREG(CRTC_H_TOTAL_DISP);
         save->crtc_h_sync_strt_wid = INREG(CRTC_H_SYNC_STRT_WID);
@@ -1773,9 +1884,8 @@ static int radeonfb_set_par (struct fb_i
 	    hSyncPol, vSyncStart, vSyncEnd, vSyncPol, cSync;
 	u8 hsync_adj_tab[] = {0, 0x12, 9, 9, 6, 5};
 	u8 hsync_fudge_fp[] = {2, 2, 0, 0, 5, 5};
-	u32 dotClock = 1000000000 / mode->pixclock,
-	    sync, h_sync_pol, v_sync_pol;
-	int freq = dotClock / 10;  /* x 100 */
+	u32 sync, h_sync_pol, v_sync_pol, dotClock, pixClock;
+	int freq;
         int xclk_freq, vclk_freq, xclk_per_trans, xclk_per_trans_precise;
         int useable_precision, roff, ron;
         int min_bits, format = 0;
@@ -1796,6 +1906,7 @@ static int radeonfb_set_par (struct fb_i
 	vSyncStart = mode->yres + mode->lower_margin;
 	vSyncEnd = vSyncStart + mode->vsync_len;
 	vTotal = vSyncEnd + mode->upper_margin;
+	pixClock = mode->pixclock;
 
 	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
 		if (rinfo->panel_xres < mode->xres)
@@ -1810,7 +1921,11 @@ static int radeonfb_set_par (struct fb_i
 		vTotal = mode->yres + rinfo->vblank;
 		vSyncStart = mode->yres + rinfo->vOver_plus;
 		vSyncEnd = vSyncStart + rinfo->vSync_width;
+
+		pixClock = 100000000 / rinfo->clock;
 	}
+	dotClock = 1000000000 / pixClock;
+	freq = dotClock / 10; /* x100 */
 
 	sync = mode->sync;
 	h_sync_pol = sync & FB_SYNC_HOR_HIGH_ACT ? 0 : 1;
@@ -1851,6 +1966,10 @@ static int radeonfb_set_par (struct fb_i
 	newmode.crtc_gen_cntl = CRTC_EXT_DISP_EN | CRTC_EN |
 				(format << 8);
 
+	/* Clear auto-center etc... */
+	newmode.crtc_more_cntl = rinfo->init_state.crtc_more_cntl;
+	newmode.crtc_more_cntl &= 0xfffffff0;
+	
 	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
 		newmode.crtc_ext_cntl = VGA_ATI_LINEAR | XCRT_CNT_EN;
 		if (mirror)
@@ -1920,6 +2039,9 @@ static int radeonfb_set_par (struct fb_i
 	rinfo->bpp = mode->bits_per_pixel;
 	rinfo->depth = depth;
 
+	RTRACE("pixclock = %lu\n", (unsigned long)pixClock);
+	RTRACE("freq = %lu\n", (unsigned long)freq);
+
 	if (freq > rinfo->pll.ppll_max)
 		freq = rinfo->pll.ppll_max;
 	if (freq*12 < rinfo->pll.ppll_min)
@@ -2001,13 +2123,6 @@ static int radeonfb_set_par (struct fb_i
 	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
 		unsigned int hRatio, vRatio;
 
-		/* We force the pixel clock to be always enabled. Allowing it
-		 * to be power managed during blanking would save power, but has
-		 * nasty interactions with the 2D engine & sleep code that haven't
-		 * been solved yet. --BenH
-		 */
-		newmode.vclk_ecp_cntl &= ~PIXCLK_DAC_ALWAYS_ONb;
-		
 		if (mode->xres > rinfo->panel_xres)
 			mode->xres = rinfo->panel_xres;
 		if (mode->yres > rinfo->panel_yres)
@@ -2065,9 +2180,15 @@ static int radeonfb_set_par (struct fb_i
 		} else {
 			/* DFP */
 			newmode.fp_gen_cntl |= (FP_FPON | FP_TMDS_EN);
-			newmode.tmds_transmitter_cntl = (TMDS_RAN_PAT_RST |
-							 ICHCSEL | TMDS_PLL_EN) &
+			newmode.tmds_transmitter_cntl = (TMDS_RAN_PAT_RST | TMDS_ICHCSEL) &
 							 ~(TMDS_PLLRST);
+#if 1	/* Without this my DFP monitor doesn't come on at all...  - paulus */
+			/* There is something wrong with setting TMDS_PLL_EN
+			 * bit on older radeon's with ADC monitors
+			 */
+			if (rinfo->arch != RADEON_R100)
+				newmode.tmds_transmitter_cntl |= TMDS_PLL_EN;
+#endif
 			newmode.crtc_ext_cntl &= ~CRTC_CRT_ON;
 		}
 
@@ -2123,6 +2244,7 @@ static void radeon_write_mode (struct ra
 	OUTREG(CRTC_GEN_CNTL, mode->crtc_gen_cntl);
 	OUTREGP(CRTC_EXT_CNTL, mode->crtc_ext_cntl,
 		CRTC_HSYNC_DIS | CRTC_VSYNC_DIS | CRTC_DISPLAY_DIS);
+	OUTREG(CRTC_MORE_CNTL, mode->crtc_more_cntl);
 	OUTREGP(DAC_CNTL, mode->dac_cntl, DAC_RANGE_CNTL | DAC_BLANKING);
 	OUTREG(CRTC_H_TOTAL_DISP, mode->crtc_h_total_disp);
 	OUTREG(CRTC_H_SYNC_STRT_WID, mode->crtc_h_sync_strt_wid);
@@ -2162,8 +2284,14 @@ static void radeon_write_mode (struct ra
 
 	OUTPLLP(PPLL_CNTL, 0, ~PPLL_RESET);
 
-//	OUTREG(DDA_CONFIG, mode->dda_config);
-//	OUTREG(DDA_ON_OFF, mode->dda_on_off);
+#if 0
+	/* Those don't seem to actually exist in radeon's, despite some drivers still
+	 * apparently trying to fill them, including some ATI sample codes ...
+	 * Can someone confirm what's up ? --BenH.
+	 */
+	OUTREG(DDA_CONFIG, mode->dda_config);
+	OUTREG(DDA_ON_OFF, mode->dda_on_off);
+#endif
 
 	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
 		OUTREG(FP_CRTC_H_TOTAL_DISP, mode->fp_crtc_h_total_disp);
@@ -2308,7 +2436,7 @@ static int radeon_set_backlight_enable(i
 	lvds_gen_cntl |= (LVDS_BL_MOD_EN | LVDS_BLON);
 	if (on && (level > BACKLIGHT_OFF)) {
 		lvds_gen_cntl |= LVDS_DIGON;
-		if (!lvds_gen_cntl & LVDS_ON) {
+		if ((lvds_gen_cntl & LVDS_ON) == 0) {
 			lvds_gen_cntl &= ~LVDS_BLON;
 			OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
 			(void)INREG(LVDS_GEN_CNTL);
@@ -2347,14 +2475,28 @@ static int radeon_set_backlight_level(in
 
 #ifdef CONFIG_PMAC_PBOOK
 
-static u32 dbg_clk;
-
 /*
- * Radeon M6 Power Management code. This code currently only supports
- * the mobile chips, it's based from some informations provided by ATI
- * along with hours of tracing of MacOS drivers
+ * Radeon M6, M7 and M9 Power Management code. This code currently
+ * only supports the mobile chips in D2 mode, that is typically what
+ * is used on Apple laptops, it's based from some informations provided by ATI
+ * along with hours of tracing of MacOS drivers.
+ * 
+ * New version of this code almost totally rewritten by ATI, many thanks
+ * for their support.
  */
- 
+
+static void OUTMC( struct radeonfb_info *rinfo, u8 indx, u32 value)
+{
+	OUTREG( MC_IND_INDEX, indx | MC_IND_INDEX__MC_IND_WR_EN);	
+	OUTREG( MC_IND_DATA, value);		
+}
+
+static u32 INMC(struct radeonfb_info *rinfo, u8 indx)
+{
+	OUTREG( MC_IND_INDEX, indx);					
+	return INREG( MC_IND_DATA);
+}
+
 static void radeon_pm_save_regs(struct radeonfb_info *rinfo)
 {
 	rinfo->save_regs[0] = INPLL(PLL_PWRMGT_CNTL);
@@ -2408,6 +2550,12 @@ static void radeon_pm_restore_regs(struc
 	OUTPLL(PIXCLKS_CNTL, rinfo->save_regs[6]);
 	OUTPLL(MCLK_MISC, rinfo->save_regs[7]);
 	
+	OUTREG(SURFACE_CNTL, rinfo->save_regs[29]);
+	OUTREG(MC_FB_LOCATION, rinfo->save_regs[30]);
+	OUTREG(DISPLAY_BASE_ADDR, rinfo->save_regs[31]);
+	OUTREG(MC_AGP_LOCATION, rinfo->save_regs[32]);
+	OUTREG(CRTC2_DISPLAY_BASE_ADDR, rinfo->save_regs[33]);
+
 	OUTREG(DISP_MISC_CNTL, rinfo->save_regs[9]);
 	OUTREG(DISP_PWR_MAN, rinfo->save_regs[10]);
 	OUTREG(LVDS_GEN_CNTL, rinfo->save_regs[11]);
@@ -2450,12 +2598,24 @@ static void radeon_pm_disable_iopad(stru
 
 static void radeon_pm_program_v2clk(struct radeonfb_info *rinfo)
 {
-//
-//	u32 reg;
-//
-//	OUTPLL(P2PLL_REF_DIV, 0x0c);
-//
-//      .../... figure out what macos does here
+	/* Set v2clk to 65MHz */
+  	OUTPLL(pllPIXCLKS_CNTL,
+  		INPLL(pllPIXCLKS_CNTL) & ~PIXCLKS_CNTL__PIX2CLK_SRC_SEL_MASK);
+	 
+  	OUTPLL(pllP2PLL_REF_DIV, 0x0000000c);
+	OUTPLL(pllP2PLL_CNTL, 0x0000bf00);
+	OUTPLL(pllP2PLL_DIV_0, 0x00020074 | P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_W);
+	
+	OUTPLL(pllP2PLL_CNTL, INPLL(pllP2PLL_CNTL) & ~P2PLL_CNTL__P2PLL_SLEEP);
+	mdelay(1);
+
+	OUTPLL(pllP2PLL_CNTL, INPLL(pllP2PLL_CNTL) & ~P2PLL_CNTL__P2PLL_RESET); 	
+	mdelay( 1);
+
+  	OUTPLL(pllPIXCLKS_CNTL,
+  		(INPLL(pllPIXCLKS_CNTL) & ~PIXCLKS_CNTL__PIX2CLK_SRC_SEL_MASK)
+  		| (0x03 << PIXCLKS_CNTL__PIX2CLK_SRC_SEL__SHIFT));
+	mdelay( 1);	
 }
 
 static void radeon_pm_low_current(struct radeonfb_info *rinfo)
@@ -2473,10 +2633,6 @@ static void radeon_pm_low_current(struct
 	reg &= ~PLL_PWRMGT_CNTL_SU_MCLK_USE_BCLK;
 	reg &= ~PLL_PWRMGT_CNTL_MOBILE_SU;
 	OUTPLL(PLL_PWRMGT_CNTL, reg);
-
-//	reg  = INPLL(TV_PLL_CNTL1);
-//	reg |= TV_PLL_CNTL1__TVPLL_RESET | TV_PLL_CNTL1__TVPLL_SLEEP;
-//	OUTPLL(TV_PLL_CNTL1, reg);
 	
 	reg  = INREG(TV_DAC_CNTL);
 	reg &= ~(TV_DAC_CNTL_BGADJ_MASK |TV_DAC_CNTL_DACADJ_MASK);
@@ -2486,14 +2642,9 @@ static void radeon_pm_low_current(struct
 	OUTREG(TV_DAC_CNTL, reg);
 	
 	reg  = INREG(TMDS_TRANSMITTER_CNTL);
-	reg &= ~(TMDS_PLL_EN |TMDS_PLLRST);
+	reg &= ~(TMDS_PLL_EN | TMDS_PLLRST);
 	OUTREG(TMDS_TRANSMITTER_CNTL, reg);
 
-//	lvds_pll_cntl  = regr32(g, LVDS_PLL_CNTL);
-//	lvds_pll_cntl &= ~LVDS_PLL_CNTL__LVDS_PLL_EN;											
-//	lvds_pll_cntl |=  LVDS_PLL_CNTL__LVDS_PLL_RESET;	
-//	regw32(g, LVDS_PLL_CNTL, lvds_pll_cntl);
-
 	reg = INREG(DAC_CNTL);
 	reg &= ~DAC_CMP_EN;
 	OUTREG(DAC_CNTL, reg);
@@ -2509,138 +2660,551 @@ static void radeon_pm_low_current(struct
 
 static void radeon_pm_setup_for_suspend(struct radeonfb_info *rinfo)
 {
-	/* This code is disabled. It does what is in the pm_init
-	 * function of the MacOS driver code ATI sent me. However,
-	 * it doesn't fix my sleep problem, and is causing other issues
-	 * on wakeup (bascially the machine dying when switching consoles
-	 * I haven't had time to investigate this yet
-	 */
-#if 0
-	u32 disp_misc_cntl;
+
+	u32 sclk_cntl, mclk_cntl, sclk_more_cntl;
+
+	u32 pll_pwrmgt_cntl;
+	u32 clk_pwrmgt_cntl;
+	u32 clk_pin_cntl;
+	u32 vclk_ecp_cntl; 
+	u32 pixclks_cntl;
+	u32 disp_mis_cntl;
 	u32 disp_pwr_man;
-	u32 temp;
 
-	// set SPLL, MPLL, PPLL, P2PLL, TVPLL, SCLK, MCLK, PCLK, P2CLK,
-	// TCLK and TEST_MODE to 0
-	temp = INPLL(CLK_PWRMGT_CNTL);
-	OUTPLL(CLK_PWRMGT_CNTL , temp & ~0xc00002ff);
-
-	// Turn on Power Management
-	temp = INPLL(CLK_PWRMGT_CNTL);
-	OUTPLL(CLK_PWRMGT_CNTL , temp | 0x00000400);
-
-	// Turn off display clock if using mobile chips
-	temp = INPLL(CLK_PWRMGT_CNTL);
-	OUTREG(CLK_PWRMGT_CNTL , temp | 0x00100000);
-
-	// Force PIXCLK_ALWAYS_ON and PIXCLK_DAC_ALWAYS_ON
-	temp = INPLL(VCLK_ECP_CNTL);
-	OUTPLL(VCLK_ECP_CNTL, temp & ~0x000000c0);
-
-	// Force ECP_FORCE_ON to 1
-	temp = INPLL(VCLK_ECP_CNTL);
-	OUTPLL(VCLK_ECP_CNTL, temp | 0x00040000);
-
-	// Force PIXCLK_BLEND_ALWAYS_ON and PIXCLK_GV_ALWAYS_ON
-	temp = INPLL(PIXCLKS_CNTL);
-       	OUTPLL(PIXCLKS_CNTL, temp & ~0x00001800);
-
-	// Forcing SCLK_CNTL to ON
-	OUTPLL(SCLK_CNTL, (INPLL(SCLK_CNTL)& 0x00000007) | 0xffff8000 );
-
-	// Set PM control over XTALIN pad
-	temp = INPLL(CLK_PIN_CNTL);
-	OUTPLL(CLK_PIN_CNTL, temp | 0x00080000);
-
-	// Force MCLK and YCLK and MC as dynamic
-    	temp = INPLL(MCLK_CNTL);
-	OUTPLL(MCLK_CNTL, temp & 0xffeaffff);
-
-	// PLL_TURNOFF
-	temp = INPLL(PLL_PWRMGT_CNTL);
-	OUTPLL(PLL_PWRMGT_CNTL, temp | 0x0000001f);
- 
-	// set MOBILE_SU to 1 if M6 or DDR64 is detected
-	temp = INPLL(PLL_PWRMGT_CNTL);
-	OUTPLL(PLL_PWRMGT_CNTL, temp | 0x00010000);
-
-	// select PM access mode (PM_MODE_SEL) (use ACPI mode)
-//      temp = INPLL(PLL_PWRMGT_CNTL);
-//      OUTPLL(PLL_PWRMGT_CNTL, temp | 0x00002000);
-	temp = INPLL(PLL_PWRMGT_CNTL);
-        OUTPLL(PLL_PWRMGT_CNTL, temp & ~0x00002000);
-
-	// set DISP_MISC_CNTL register
-	disp_misc_cntl = INREG(DISP_MISC_CNTL);
-	disp_misc_cntl &= ~(	DISP_MISC_CNTL_SOFT_RESET_GRPH_PP |
-				DISP_MISC_CNTL_SOFT_RESET_SUBPIC_PP |
-				DISP_MISC_CNTL_SOFT_RESET_OV0_PP |
-				DISP_MISC_CNTL_SOFT_RESET_GRPH_SCLK |
-				DISP_MISC_CNTL_SOFT_RESET_SUBPIC_SCLK |
-				DISP_MISC_CNTL_SOFT_RESET_OV0_SCLK |
-				DISP_MISC_CNTL_SOFT_RESET_GRPH2_PP |
-				DISP_MISC_CNTL_SOFT_RESET_GRPH2_SCLK |
-				DISP_MISC_CNTL_SOFT_RESET_LVDS |
-				DISP_MISC_CNTL_SOFT_RESET_TMDS |
-				DISP_MISC_CNTL_SOFT_RESET_DIG_TMDS |
-				DISP_MISC_CNTL_SOFT_RESET_TV);
-	OUTREG(DISP_MISC_CNTL, disp_misc_cntl);
+	
+	/* Force Core Clocks */
+	sclk_cntl = INPLL( pllSCLK_CNTL_M6);
+	sclk_cntl |= 	SCLK_CNTL_M6__IDCT_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__VIP_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__RE_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__PB_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__TAM_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__TDM_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__RB_MAX_DYN_STOP_LAT|
+			
+			SCLK_CNTL_M6__FORCE_DISP2|
+			SCLK_CNTL_M6__FORCE_CP|
+			SCLK_CNTL_M6__FORCE_HDP|
+			SCLK_CNTL_M6__FORCE_DISP1|
+			SCLK_CNTL_M6__FORCE_TOP|
+			SCLK_CNTL_M6__FORCE_E2|
+			SCLK_CNTL_M6__FORCE_SE|
+			SCLK_CNTL_M6__FORCE_IDCT|
+			SCLK_CNTL_M6__FORCE_VIP|
+			
+			SCLK_CNTL_M6__FORCE_RE|
+			SCLK_CNTL_M6__FORCE_PB|
+			SCLK_CNTL_M6__FORCE_TAM|
+			SCLK_CNTL_M6__FORCE_TDM|
+			SCLK_CNTL_M6__FORCE_RB|
+			SCLK_CNTL_M6__FORCE_TV_SCLK|
+			SCLK_CNTL_M6__FORCE_SUBPIC|
+			SCLK_CNTL_M6__FORCE_OV0;
+
+	OUTPLL( pllSCLK_CNTL_M6, sclk_cntl);
+
+	sclk_more_cntl = INPLL(pllSCLK_MORE_CNTL);
+	sclk_more_cntl |= 	SCLK_MORE_CNTL__FORCE_DISPREGS |
+				SCLK_MORE_CNTL__FORCE_MC_GUI |
+				SCLK_MORE_CNTL__FORCE_MC_HOST;
+
+	OUTPLL(pllSCLK_MORE_CNTL, sclk_more_cntl);		
+
+	
+	mclk_cntl = INPLL( pllMCLK_CNTL_M6);
+	mclk_cntl &= ~(	MCLK_CNTL_M6__FORCE_MCLKA |  
+			MCLK_CNTL_M6__FORCE_MCLKB |
+			MCLK_CNTL_M6__FORCE_YCLKA | 
+			MCLK_CNTL_M6__FORCE_YCLKB | 
+			MCLK_CNTL_M6__FORCE_MC
+		      );	
+    	OUTPLL( pllMCLK_CNTL_M6, mclk_cntl);
+	
+	/* Force Display clocks	*/
+	vclk_ecp_cntl = INPLL( pllVCLK_ECP_CNTL);
+	vclk_ecp_cntl &= ~(VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb |VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb);
+	vclk_ecp_cntl |= VCLK_ECP_CNTL__ECP_FORCE_ON;
+	OUTPLL( pllVCLK_ECP_CNTL, vclk_ecp_cntl);
+	
+	
+	pixclks_cntl = INPLL( pllPIXCLKS_CNTL);
+	pixclks_cntl &= ~(	PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb | 
+				PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb |
+				PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb);
+						
+ 	OUTPLL( pllPIXCLKS_CNTL, pixclks_cntl);
+
+
+
+	/* Enable System power management */
+	pll_pwrmgt_cntl = INPLL( pllPLL_PWRMGT_CNTL);
+	
+	pll_pwrmgt_cntl |= 	PLL_PWRMGT_CNTL__SPLL_TURNOFF |
+				PLL_PWRMGT_CNTL__MPLL_TURNOFF|
+				PLL_PWRMGT_CNTL__PPLL_TURNOFF|
+				PLL_PWRMGT_CNTL__P2PLL_TURNOFF|
+				PLL_PWRMGT_CNTL__TVPLL_TURNOFF;
+						
+	OUTPLL( pllPLL_PWRMGT_CNTL, pll_pwrmgt_cntl);
+	
+	clk_pwrmgt_cntl	 = INPLL( pllCLK_PWRMGT_CNTL_M6);
+	
+	clk_pwrmgt_cntl &= ~(	CLK_PWRMGT_CNTL_M6__MPLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__SPLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__PPLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__P2PLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__MCLK_TURNOFF|
+				CLK_PWRMGT_CNTL_M6__SCLK_TURNOFF|
+				CLK_PWRMGT_CNTL_M6__PCLK_TURNOFF|
+				CLK_PWRMGT_CNTL_M6__P2CLK_TURNOFF|
+				CLK_PWRMGT_CNTL_M6__TVPLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN|
+				CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE|
+				CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT_MASK|
+				CLK_PWRMGT_CNTL_M6__CG_NO1_DEBUG_MASK			
+			);
+						
+	clk_pwrmgt_cntl |= CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN | CLK_PWRMGT_CNTL_M6__DISP_PM;
+	
+	OUTPLL( pllCLK_PWRMGT_CNTL_M6, clk_pwrmgt_cntl);	
+	
+	clk_pin_cntl = INPLL( pllCLK_PIN_CNTL);
+	
+	clk_pin_cntl &= ~CLK_PIN_CNTL__ACCESS_REGS_IN_SUSPEND;
+	OUTPLL( pllMCLK_MISC, INPLL( pllMCLK_MISC) | MCLK_MISC__EN_MCLK_TRISTATE_IN_SUSPEND);	
+	
+	/* AGP PLL control */
+	OUTREG(BUS_CNTL1, INREG(BUS_CNTL1) |  BUS_CNTL1__AGPCLK_VALID);
+
+	OUTREG(BUS_CNTL1,
+		(INREG(BUS_CNTL1) & ~BUS_CNTL1__MOBILE_PLATFORM_SEL_MASK)
+		| (2<<BUS_CNTL1__MOBILE_PLATFORM_SEL__SHIFT));	// 440BX
+	OUTREG(CRTC_OFFSET_CNTL, (INREG(CRTC_OFFSET_CNTL) & ~CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_OUT_EN));
+	
+	clk_pin_cntl &= ~CLK_PIN_CNTL__CG_CLK_TO_OUTPIN;
+	clk_pin_cntl |= CLK_PIN_CNTL__XTALIN_ALWAYS_ONb;	
+	OUTPLL( pllCLK_PIN_CNTL, clk_pin_cntl);
 
-	// set DISP_PWR_MAN register
+	/* Solano2M */
+	OUTREG(AGP_CNTL,
+		(INREG(AGP_CNTL) & ~(AGP_CNTL__MAX_IDLE_CLK_MASK))
+		| (0x20<<AGP_CNTL__MAX_IDLE_CLK__SHIFT));
+
+	/* ACPI mode */
+	OUTPLL( pllPLL_PWRMGT_CNTL, INPLL( pllPLL_PWRMGT_CNTL) & ~PLL_PWRMGT_CNTL__PM_MODE_SEL);					
+
+
+	disp_mis_cntl = INREG(DISP_MISC_CNTL);
+	
+	disp_mis_cntl &= ~(	DISP_MISC_CNTL__SOFT_RESET_GRPH_PP | 
+				DISP_MISC_CNTL__SOFT_RESET_SUBPIC_PP | 
+				DISP_MISC_CNTL__SOFT_RESET_OV0_PP |
+				DISP_MISC_CNTL__SOFT_RESET_GRPH_SCLK|
+				DISP_MISC_CNTL__SOFT_RESET_SUBPIC_SCLK|
+				DISP_MISC_CNTL__SOFT_RESET_OV0_SCLK|
+				DISP_MISC_CNTL__SOFT_RESET_GRPH2_PP|
+				DISP_MISC_CNTL__SOFT_RESET_GRPH2_SCLK|
+				DISP_MISC_CNTL__SOFT_RESET_LVDS|
+				DISP_MISC_CNTL__SOFT_RESET_TMDS|
+				DISP_MISC_CNTL__SOFT_RESET_DIG_TMDS|
+				DISP_MISC_CNTL__SOFT_RESET_TV);
+	
+	OUTREG(DISP_MISC_CNTL, disp_mis_cntl);					
+						
 	disp_pwr_man = INREG(DISP_PWR_MAN);
-	// clau - 9.29.2000 - changes made to bit23:18 to set to 1 as requested by George
-	disp_pwr_man |= (DISP_PWR_MAN_DIG_TMDS_ENABLE_RST |
-                    DISP_PWR_MAN_TV_ENABLE_RST |
- //                 DISP_PWR_MAN_AUTO_PWRUP_EN |
-                    DISP_PWR_MAN_DISP_D3_GRPH_RST |
-                    DISP_PWR_MAN_DISP_D3_SUBPIC_RST |
-                    DISP_PWR_MAN_DISP_D3_OV0_RST |
-                    DISP_PWR_MAN_DISP_D1D2_GRPH_RST |
-                    DISP_PWR_MAN_DISP_D1D2_SUBPIC_RST |
-                    DISP_PWR_MAN_DISP_D1D2_OV0_RST);
-	disp_pwr_man &= ~(DISP_PWR_MAN_DISP_PWR_MAN_D3_CRTC_EN |
-                    DISP_PWR_MAN_DISP2_PWR_MAN_D3_CRTC2_EN|
-                    DISP_PWR_MAN_DISP_D3_RST |
-                    DISP_PWR_MAN_DISP_D3_REG_RST);
+	
+	disp_pwr_man &= ~(	DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN	| 
+						DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN |
+						DISP_PWR_MAN__DISP_PWR_MAN_DPMS_MASK|		
+						DISP_PWR_MAN__DISP_D3_RST|
+						DISP_PWR_MAN__DISP_D3_REG_RST
+					);
+	
+	disp_pwr_man |= DISP_PWR_MAN__DISP_D3_GRPH_RST|
+					DISP_PWR_MAN__DISP_D3_SUBPIC_RST|
+					DISP_PWR_MAN__DISP_D3_OV0_RST|
+					DISP_PWR_MAN__DISP_D1D2_GRPH_RST|
+					DISP_PWR_MAN__DISP_D1D2_SUBPIC_RST|
+					DISP_PWR_MAN__DISP_D1D2_OV0_RST|
+					DISP_PWR_MAN__DIG_TMDS_ENABLE_RST|
+					DISP_PWR_MAN__TV_ENABLE_RST| 
+//					DISP_PWR_MAN__AUTO_PWRUP_EN|
+					0;
+	
+	OUTREG(DISP_PWR_MAN, disp_pwr_man);					
+							
+	clk_pwrmgt_cntl = INPLL( pllCLK_PWRMGT_CNTL_M6);
+	pll_pwrmgt_cntl = INPLL( pllPLL_PWRMGT_CNTL) ;
+	clk_pin_cntl 	= INPLL( pllCLK_PIN_CNTL);
+	disp_pwr_man	= INREG(DISP_PWR_MAN);
+		
+	
+	/* D2 */
+	clk_pwrmgt_cntl |= CLK_PWRMGT_CNTL_M6__DISP_PM;
+	pll_pwrmgt_cntl |= PLL_PWRMGT_CNTL__MOBILE_SU | PLL_PWRMGT_CNTL__SU_SCLK_USE_BCLK;
+	clk_pin_cntl	|= CLK_PIN_CNTL__XTALIN_ALWAYS_ONb;
+	disp_pwr_man 	&= ~(DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN_MASK | DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN_MASK);							
+						
+
+	OUTPLL( pllCLK_PWRMGT_CNTL_M6, clk_pwrmgt_cntl);
+	OUTPLL( pllPLL_PWRMGT_CNTL, pll_pwrmgt_cntl);
+	OUTPLL( pllCLK_PIN_CNTL, clk_pin_cntl);
 	OUTREG(DISP_PWR_MAN, disp_pwr_man);
 
-	// clau - 10.24.2000
-	// - add in setting for BUS_CNTL1 b27:26 = 0x01 and b31 = 0x1
-	// - add in setting for AGP_CNTL  b7:0 = 0x20
-	// - add in setting for DVI_DDC_DATA_OUT_EN b17:16 = 0x0
-
-	// the following settings (two lines) are applied at a later part of this function, only on mobile platform
-	// requres -mobile flag
-	OUTREG(BUS_CNTL1, (INREG(BUS_CNTL1) & 0xf3ffffff) | 0x04000000);
-	OUTREG(BUS_CNTL1,  INREG(BUS_CNTL1) | 0x80000000);
-	OUTREG(AGP_CNTL, (INREG(AGP_CNTL) & 0xffffff00) | 0x20);
-	OUTREG(GPIO_DVI_DDC, INREG(GPIO_DVI_DDC) & 0xfffcffff);
-
-	// yulee - 12.12.2000
-	// A12 only
-	// EN_MCLK_TRISTATE_IN_SUSPEND@MCLK_MISC = 1
-	// ACCESS_REGS_IN_SUSPEND@CLK_PIN_CNTL = 0
-	// only on mobile platform
-        OUTPLL(MCLK_MISC, INPLL(MCLK_MISC) | 0x00040000 );
-    	
-	// yulee -12.12.2000
-	// AGPCLK_VALID@BUS_CNTL1 = 1
-	// MOBILE_PLATFORM_SEL@BUS_CNTL1 = 01
-	// CRTC_STEREO_SYNC_OUT_EN@CRTC_OFFSET_CNTL = 0
-	// CG_CLK_TO_OUTPIN@CLK_PIN_CNTL = 0
-	// only on mobile platform
-        OUTPLL(CLK_PIN_CNTL, INPLL(CLK_PIN_CNTL ) & 0xFFFFF7FF );
-        OUTREG(BUS_CNTL1, (INREG(BUS_CNTL1 ) & 0xF3FFFFFF) | 0x84000000 );
-        OUTREG(CRTC_OFFSET_CNTL, INREG(CRTC_OFFSET_CNTL ) & 0xFFEFFFFF );
-
-        mdelay(100);
-#endif
-
-	/* Disable CRTCs */
-	OUTREG(CRTC_GEN_CNTL, (INREG(CRTC_GEN_CNTL) & ~CRTC_EN) | CRTC_DISP_REQ_EN_B);
-	OUTREG(CRTC2_GEN_CNTL, (INREG(CRTC2_GEN_CNTL) & ~CRTC2_EN) | CRTC2_DISP_REQ_EN_B);
-	(void)INREG(CRTC2_GEN_CNTL);
-	mdelay(17);
+	/* disable display request & disable display */
+	OUTREG( CRTC_GEN_CNTL, (INREG( CRTC_GEN_CNTL) & ~CRTC_GEN_CNTL__CRTC_EN) | CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B);
+	OUTREG( CRTC2_GEN_CNTL, (INREG( CRTC2_GEN_CNTL) & ~CRTC2_GEN_CNTL__CRTC2_EN) | CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B);
+
+	mdelay(17);				   
+
+}
+
+static void radeon_pm_disable_dynamic_mode(struct radeonfb_info *rinfo)
+{
+
+	u32 sclk_cntl;
+	u32 mclk_cntl;
+	u32 sclk_more_cntl;
+	
+	u32 vclk_ecp_cntl;
+	u32 pixclks_cntl;
+
+	/* Mobility chips only */
+	if ((rinfo->arch != RADEON_M6) && (rinfo->arch != RADEON_M7) && (rinfo->arch != RADEON_M9))
+		return;
+	
+	/* Force Core Clocks */
+	sclk_cntl = INPLL( pllSCLK_CNTL_M6);
+	sclk_cntl |= 	SCLK_CNTL_M6__FORCE_CP|
+			SCLK_CNTL_M6__FORCE_HDP|
+			SCLK_CNTL_M6__FORCE_DISP1|
+			SCLK_CNTL_M6__FORCE_DISP2|
+			SCLK_CNTL_M6__FORCE_TOP|
+			SCLK_CNTL_M6__FORCE_E2|
+			SCLK_CNTL_M6__FORCE_SE|
+			SCLK_CNTL_M6__FORCE_IDCT|
+			SCLK_CNTL_M6__FORCE_VIP|
+			SCLK_CNTL_M6__FORCE_RE|
+			SCLK_CNTL_M6__FORCE_PB|
+			SCLK_CNTL_M6__FORCE_TAM|
+			SCLK_CNTL_M6__FORCE_TDM|
+			SCLK_CNTL_M6__FORCE_RB|
+			SCLK_CNTL_M6__FORCE_TV_SCLK|
+			SCLK_CNTL_M6__FORCE_SUBPIC|
+			SCLK_CNTL_M6__FORCE_OV0;
+    	OUTPLL( pllSCLK_CNTL_M6, sclk_cntl);
+	
+	
+	
+	sclk_more_cntl = INPLL(pllSCLK_MORE_CNTL);
+	sclk_more_cntl |= 	SCLK_MORE_CNTL__FORCE_DISPREGS|
+				SCLK_MORE_CNTL__FORCE_MC_GUI|
+				SCLK_MORE_CNTL__FORCE_MC_HOST;	
+	OUTPLL(pllSCLK_MORE_CNTL, sclk_more_cntl);
+	
+	/* Force Display clocks	*/
+	vclk_ecp_cntl = INPLL( pllVCLK_ECP_CNTL);
+	vclk_ecp_cntl &= ~(	VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb |
+			 	VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb);
+
+	OUTPLL( pllVCLK_ECP_CNTL, vclk_ecp_cntl);
+	
+	pixclks_cntl = INPLL( pllPIXCLKS_CNTL);
+	pixclks_cntl &= ~(	PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb |
+			 	PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb |
+				PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb);
+						
+ 	OUTPLL( pllPIXCLKS_CNTL, pixclks_cntl);
+
+	/* Force Memory Clocks */
+	mclk_cntl = INPLL( pllMCLK_CNTL_M6);
+	mclk_cntl &= ~(	MCLK_CNTL_M6__FORCE_MCLKA |  
+			MCLK_CNTL_M6__FORCE_MCLKB |
+			MCLK_CNTL_M6__FORCE_YCLKA |
+			MCLK_CNTL_M6__FORCE_YCLKB );
+    	OUTPLL( pllMCLK_CNTL_M6, mclk_cntl);
+}
+
+static void radeon_pm_enable_dynamic_mode(struct radeonfb_info *rinfo)
+{
+	u32 clk_pwrmgt_cntl;
+	u32 sclk_cntl;
+	u32 sclk_more_cntl;
+	u32 clk_pin_cntl;
+	u32 pixclks_cntl;
+	u32 vclk_ecp_cntl;
+	u32 mclk_cntl;
+	u32 mclk_misc;
+
+	/* Mobility chips only */
+	if ((rinfo->arch != RADEON_M6) && (rinfo->arch != RADEON_M7) && (rinfo->arch != RADEON_M9))
+		return;
+	
+	/* Set Latencies */
+	clk_pwrmgt_cntl = INPLL( pllCLK_PWRMGT_CNTL_M6);
+	
+	clk_pwrmgt_cntl &= ~(	 CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE_MASK|
+				 CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT_MASK|
+				 CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT_MASK|
+				 CLK_PWRMGT_CNTL_M6__DYN_STOP_MODE_MASK);
+	/* Mode 1 */
+	clk_pwrmgt_cntl = 	CLK_PWRMGT_CNTL_M6__MC_CH_MODE|
+				CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE | 
+				(1<<CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT__SHIFT) |
+				(0<<CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT__SHIFT)|
+				(0<<CLK_PWRMGT_CNTL_M6__DYN_STOP_MODE__SHIFT);
+
+	OUTPLL( pllCLK_PWRMGT_CNTL_M6, clk_pwrmgt_cntl);
+						
+
+	clk_pin_cntl = INPLL( pllCLK_PIN_CNTL);
+	clk_pin_cntl |= CLK_PIN_CNTL__SCLK_DYN_START_CNTL;
+	 
+	OUTPLL( pllCLK_PIN_CNTL, clk_pin_cntl);
+
+	/* Enable Dyanmic mode for SCLK */
+
+	sclk_cntl = INPLL( pllSCLK_CNTL_M6);	
+	sclk_cntl &= SCLK_CNTL_M6__SCLK_SRC_SEL_MASK;
+	sclk_cntl |= SCLK_CNTL_M6__FORCE_VIP;		
+
+	OUTPLL( pllSCLK_CNTL_M6, sclk_cntl);
+
+
+	sclk_more_cntl = INPLL(pllSCLK_MORE_CNTL);
+	sclk_more_cntl &= ~(SCLK_MORE_CNTL__FORCE_DISPREGS);
+				                    
+	OUTPLL(pllSCLK_MORE_CNTL, sclk_more_cntl);
+
+	
+	/* Enable Dynamic mode for PIXCLK & PIX2CLK */
+
+	pixclks_cntl = INPLL( pllPIXCLKS_CNTL);
+	
+	pixclks_cntl|=  PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb | 
+			PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb;
+
+	OUTPLL( pllPIXCLKS_CNTL, pixclks_cntl);
+		
+		
+	vclk_ecp_cntl = INPLL( pllVCLK_ECP_CNTL);
+	
+	vclk_ecp_cntl|=  VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb | 
+			 VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb;
+
+	OUTPLL( pllVCLK_ECP_CNTL, vclk_ecp_cntl);
+
+
+	/* Enable Dynamic mode for MCLK	*/
+
+	mclk_cntl  = INPLL( pllMCLK_CNTL_M6);
+	mclk_cntl |= 	MCLK_CNTL_M6__FORCE_MCLKA|  
+			MCLK_CNTL_M6__FORCE_MCLKB|	
+			MCLK_CNTL_M6__FORCE_YCLKA|
+			MCLK_CNTL_M6__FORCE_YCLKB;
+			
+    	OUTPLL( pllMCLK_CNTL_M6, mclk_cntl);
+
+	mclk_misc = INPLL(pllMCLK_MISC);
+	mclk_misc |= 	MCLK_MISC__MC_MCLK_MAX_DYN_STOP_LAT|
+			MCLK_MISC__IO_MCLK_MAX_DYN_STOP_LAT|
+			MCLK_MISC__MC_MCLK_DYN_ENABLE|
+			MCLK_MISC__IO_MCLK_DYN_ENABLE;	
+	
+	OUTPLL(pllMCLK_MISC, mclk_misc);
+}
+
+
+static void radeon_pm_yclk_mclk_sync(struct radeonfb_info *rinfo)
+{
+	u32 mc_chp_io_cntl_a1, mc_chp_io_cntl_b1;
+
+	mc_chp_io_cntl_a1 = INMC( rinfo, ixMC_CHP_IO_CNTL_A1) & ~MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA_MASK;
+	mc_chp_io_cntl_b1 = INMC( rinfo, ixMC_CHP_IO_CNTL_B1) & ~MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB_MASK;
+
+	OUTMC( rinfo, ixMC_CHP_IO_CNTL_A1, mc_chp_io_cntl_a1 | (1<<MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA__SHIFT));
+	OUTMC( rinfo, ixMC_CHP_IO_CNTL_B1, mc_chp_io_cntl_b1 | (1<<MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB__SHIFT));
+
+	/* Wassup ? This doesn't seem to be defined, let's hope we are ok this way --BenH */
+#ifdef MCLK_YCLK_SYNC_ENABLE
+	mc_chp_io_cntl_a1 |= (2<<MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA__SHIFT);
+	mc_chp_io_cntl_b1 |= (2<<MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB__SHIFT);
+#endif
+
+	OUTMC( rinfo, ixMC_CHP_IO_CNTL_A1, mc_chp_io_cntl_a1);
+	OUTMC( rinfo, ixMC_CHP_IO_CNTL_B1, mc_chp_io_cntl_b1);
+
+	mdelay( 1);
+}
+
+static void radeon_pm_program_mode_reg(struct radeonfb_info *rinfo, u16 value, u8 delay_required)
+{  
+	u32 mem_sdram_mode;
+
+	mem_sdram_mode  = INREG( MEM_SDRAM_MODE_REG);
+
+	mem_sdram_mode &= ~MEM_SDRAM_MODE_REG__MEM_MODE_REG_MASK;
+	mem_sdram_mode |= (value<<MEM_SDRAM_MODE_REG__MEM_MODE_REG__SHIFT) | MEM_SDRAM_MODE_REG__MEM_CFG_TYPE;
+	OUTREG( MEM_SDRAM_MODE_REG, mem_sdram_mode);
+
+	mem_sdram_mode |=  MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET;
+	OUTREG( MEM_SDRAM_MODE_REG, mem_sdram_mode);
+
+	mem_sdram_mode &= ~MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET;
+	OUTREG( MEM_SDRAM_MODE_REG, mem_sdram_mode);
+
+	if (delay_required == 1)
+		while( (INREG( MC_STATUS) & (MC_STATUS__MEM_PWRUP_COMPL_A | MC_STATUS__MEM_PWRUP_COMPL_B) ) == 0 )
+			{ }; 	
+}
+
+
+static void radeon_pm_enable_dll(struct radeonfb_info *rinfo)
+{  
+#define DLL_RESET_DELAY 	5
+#define DLL_SLEEP_DELAY		1
+
+	u32 DLL_CKO_Value = INPLL(pllMDLL_CKO)   | MDLL_CKO__MCKOA_SLEEP |  MDLL_CKO__MCKOA_RESET;
+	u32 DLL_CKA_Value = INPLL(pllMDLL_RDCKA) | MDLL_RDCKA__MRDCKA0_SLEEP | MDLL_RDCKA__MRDCKA1_SLEEP | MDLL_RDCKA__MRDCKA0_RESET | MDLL_RDCKA__MRDCKA1_RESET;
+	u32 DLL_CKB_Value = INPLL(pllMDLL_RDCKB) | MDLL_RDCKB__MRDCKB0_SLEEP | MDLL_RDCKB__MRDCKB1_SLEEP | MDLL_RDCKB__MRDCKB0_RESET | MDLL_RDCKB__MRDCKB1_RESET;
+
+	/* Setting up the DLL range for write */
+	OUTPLL(pllMDLL_CKO,   	DLL_CKO_Value);
+	OUTPLL(pllMDLL_RDCKA,  	DLL_CKA_Value);
+	OUTPLL(pllMDLL_RDCKB,	DLL_CKB_Value);
+
+	mdelay( DLL_RESET_DELAY);
+
+	/* Channel A */
+
+	/* Power Up */
+	DLL_CKO_Value &= ~(MDLL_CKO__MCKOA_SLEEP );
+	OUTPLL(pllMDLL_CKO,   	DLL_CKO_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+   
+	DLL_CKO_Value &= ~(MDLL_CKO__MCKOA_RESET );
+	OUTPLL(pllMDLL_CKO,	DLL_CKO_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+	/* Power Up */
+	DLL_CKA_Value &= ~(MDLL_RDCKA__MRDCKA0_SLEEP );
+	OUTPLL(pllMDLL_RDCKA,  	DLL_CKA_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+
+	DLL_CKA_Value &= ~(MDLL_RDCKA__MRDCKA0_RESET );
+	OUTPLL(pllMDLL_RDCKA,	DLL_CKA_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+	/* Power Up */
+	DLL_CKA_Value &= ~(MDLL_RDCKA__MRDCKA1_SLEEP);
+	OUTPLL(pllMDLL_RDCKA,	DLL_CKA_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+
+	DLL_CKA_Value &= ~(MDLL_RDCKA__MRDCKA1_RESET);
+	OUTPLL(pllMDLL_RDCKA,	DLL_CKA_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+
+	/* Channel B */
+
+	/* Power Up */
+	DLL_CKO_Value &= ~(MDLL_CKO__MCKOB_SLEEP );
+	OUTPLL(pllMDLL_CKO,   	DLL_CKO_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+   
+	DLL_CKO_Value &= ~(MDLL_CKO__MCKOB_RESET );
+	OUTPLL(pllMDLL_CKO,   	DLL_CKO_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+	/* Power Up */
+	DLL_CKB_Value &= ~(MDLL_RDCKB__MRDCKB0_SLEEP);
+	OUTPLL(pllMDLL_RDCKB,   DLL_CKB_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+
+	DLL_CKB_Value &= ~(MDLL_RDCKB__MRDCKB0_RESET);
+	OUTPLL(pllMDLL_RDCKB,   DLL_CKB_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+	/* Power Up */
+	DLL_CKB_Value &= ~(MDLL_RDCKB__MRDCKB1_SLEEP);
+	OUTPLL(pllMDLL_RDCKB,   DLL_CKB_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+
+	DLL_CKB_Value &= ~(MDLL_RDCKB__MRDCKB1_RESET);
+	OUTPLL(pllMDLL_RDCKB,   DLL_CKB_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+#undef DLL_RESET_DELAY 
+#undef DLL_SLEEP_DELAY
+}
+
+static void radeon_pm_full_reset_sdram(struct radeonfb_info *rinfo)
+{
+	u32 crtcGenCntl, crtcGenCntl2, memRefreshCntl, crtc_more_cntl, fp_gen_cntl, fp2_gen_cntl;
+ 
+	crtcGenCntl  = INREG( CRTC_GEN_CNTL);
+	crtcGenCntl2 = INREG( CRTC2_GEN_CNTL);
+
+	memRefreshCntl 	= INREG( MEM_REFRESH_CNTL);
+	crtc_more_cntl 	= INREG( CRTC_MORE_CNTL);
+	fp_gen_cntl 	= INREG( FP_GEN_CNTL);
+	fp2_gen_cntl 	= INREG( FP2_GEN_CNTL);
+ 
+
+	OUTREG( CRTC_MORE_CNTL, 	0);
+	OUTREG( FP_GEN_CNTL, 	0);
+	OUTREG( FP2_GEN_CNTL, 	0);
+ 
+	OUTREG( CRTC_GEN_CNTL,  (crtcGenCntl | CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B) );
+	OUTREG( CRTC2_GEN_CNTL, (crtcGenCntl2 | CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B) );
+  
+	/* Disable refresh */
+	OUTREG( MEM_REFRESH_CNTL, memRefreshCntl | MEM_REFRESH_CNTL__MEM_REFRESH_DIS);
+ 
+	/* Reset memory */
+	OUTREG( MEM_SDRAM_MODE_REG,
+		INREG( MEM_SDRAM_MODE_REG) & ~MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE); // Init  Not Complete
+
+	/* DLL */
+	radeon_pm_enable_dll(rinfo);
+
+	// MLCK /YCLK sync 
+	radeon_pm_yclk_mclk_sync(rinfo);
+
+	if ((rinfo->arch == RADEON_M6) || (rinfo->arch == RADEON_M7) || (rinfo->arch == RADEON_M9)) {
+		radeon_pm_program_mode_reg(rinfo, 0x2000, 1);   
+		radeon_pm_program_mode_reg(rinfo, 0x2001, 1);   
+		radeon_pm_program_mode_reg(rinfo, 0x2002, 1);   
+		radeon_pm_program_mode_reg(rinfo, 0x0132, 1);   
+		radeon_pm_program_mode_reg(rinfo, 0x0032, 1); 
+	}	
+
+	OUTREG( MEM_SDRAM_MODE_REG,
+		INREG( MEM_SDRAM_MODE_REG) |  MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE); // Init Complete
+
+	OUTREG( MEM_REFRESH_CNTL, 	memRefreshCntl);
+
+	OUTREG( CRTC_GEN_CNTL, 		crtcGenCntl);
+	OUTREG( CRTC2_GEN_CNTL, 	crtcGenCntl2);
+	OUTREG( FP_GEN_CNTL, 		fp_gen_cntl);
+	OUTREG( FP2_GEN_CNTL, 		fp2_gen_cntl);
+
+	OUTREG( CRTC_MORE_CNTL, 	crtc_more_cntl);
+
+	mdelay( 15);
 }
 
 static void radeon_set_suspend(struct radeonfb_info *rinfo, int suspend)
@@ -2655,16 +3219,16 @@ static void radeon_set_suspend(struct ra
 	 * including PCI config registers, clocks, AGP conf, ...)
 	 */
 	if (suspend) {
-		/* According to ATI, we should program V2CLK here, I have
-		 * to verify what's up exactly
+		/* Disable dynamic power management of clocks for the
+		 * duration of the suspend/resume process
 		 */
+		radeon_pm_disable_dynamic_mode(rinfo);
 		/* Save some registers */
 		radeon_pm_save_regs(rinfo);
 
-		/* Check that on M7 too, might work might not. M7 may also
-		 * need explicit enabling of PM
+		/* Prepare mobility chips for suspend
 		 */
-		if (rinfo->arch == RADEON_M6) {
+		if (rinfo->arch == RADEON_M6 || rinfo->arch == RADEON_M7 || rinfo->arch == RADEON_M9) {
 			/* Program V2CLK */
 			radeon_pm_program_v2clk(rinfo);
 		
@@ -2678,10 +3242,7 @@ static void radeon_set_suspend(struct ra
 			radeon_pm_setup_for_suspend(rinfo);
 
 			/* Reset the MDLL */
-			OUTPLL(MDLL_CKO, INPLL(MDLL_CKO) | MCKOA_RESET);
-			(void)INPLL(MDLL_RDCKA);
-			OUTPLL(MDLL_CKO, INPLL(MDLL_CKO) & ~MCKOA_RESET);
-			(void)INPLL(MDLL_RDCKA);
+			OUTPLL( pllMDLL_CKO, INPLL( pllMDLL_CKO) | MDLL_CKO__MCKOA_RESET | MDLL_CKO__MCKOB_RESET);
 		}
 
 		/* Switch PCI power managment to D2. */
@@ -2702,17 +3263,13 @@ static void radeon_set_suspend(struct ra
 		pci_write_config_word(rinfo->pdev, rinfo->pm_reg+PCI_PM_CTRL, 0);
 		mdelay(500);
 
-		dbg_clk = INPLL(1);
-
-		/* Do we need that on M7 ? */
-		if (rinfo->arch == RADEON_M6) {
-			/* Restore the MDLL */
-			OUTPLL(MDLL_CKO, INPLL(MDLL_CKO) & ~MCKOA_RESET);
-			(void)INPLL(MDLL_CKO);			
-		}
+		/* Reset the SDRAM controller */
+		if (rinfo->arch == RADEON_M6 || rinfo->arch == RADEON_M7 || rinfo->arch == RADEON_M9)
+			radeon_pm_full_reset_sdram(rinfo);
 		
 		/* Restore some registers */
 		radeon_pm_restore_regs(rinfo);
+		radeon_pm_enable_dynamic_mode(rinfo);
 	}
 }
 
@@ -2780,7 +3337,6 @@ int radeon_sleep_notify(struct pmu_sleep
 
 				radeonfb_blank(0, (struct fb_info *)rinfo);
 				release_console_sem();
-				printk("CLK_PIN_CNTL on wakeup was: %08x\n", dbg_clk);
 				break;
 		}
 	}
@@ -2839,7 +3395,8 @@ static int radeonfb_pci_register (struct
 	}
 
 	/* map the regions */
-	rinfo->mmio_base = (unsigned long) ioremap (rinfo->mmio_base_phys, RADEON_REGSIZE);
+	rinfo->mmio_base = (unsigned long) ioremap (rinfo->mmio_base_phys,
+				    		    RADEON_REGSIZE);
 	if (!rinfo->mmio_base) {
 		printk ("radeonfb: cannot map MMIO\n");
 		release_mem_region (rinfo->mmio_base_phys,
@@ -2948,13 +3505,20 @@ static int radeonfb_pci_register (struct
 #if !defined(__powerpc__)
 	radeon_get_moninfo(rinfo);
 #else
-	switch (pdev->device) {
-		case PCI_DEVICE_ID_ATI_RADEON_LW:
-		case PCI_DEVICE_ID_ATI_RADEON_LX:
-		case PCI_DEVICE_ID_ATI_RADEON_LY:
-		case PCI_DEVICE_ID_ATI_RADEON_LZ:
-			rinfo->dviDisp_type = MT_LCD;
-			break;
+	switch (rinfo->arch) {
+		case RADEON_M6:
+		case RADEON_M7:
+		case RADEON_M9:
+			/* If forced to no-LCD, we shut down the backlight */
+			if (force_nolcd) {
+#ifdef CONFIG_PMAC_BACKLIGHT
+				radeon_set_backlight_enable(0, BACKLIGHT_OFF, rinfo);
+#endif
+			} else {
+				rinfo->dviDisp_type = MT_LCD;
+				break;
+			}
+			/* Fall through */
 		default:
 			radeon_get_moninfo(rinfo);
 			break;
@@ -2976,7 +3540,8 @@ static int radeonfb_pci_register (struct
 		}
 	}
 
-	rinfo->fb_base = (unsigned long) ioremap (rinfo->fb_base_phys, rinfo->video_ram);
+	rinfo->fb_base = (unsigned long) ioremap (rinfo->fb_base_phys,
+				  		  rinfo->video_ram);
 	if (!rinfo->fb_base) {
 		printk ("radeonfb: cannot map FB\n");
 		iounmap ((void*)rinfo->mmio_base);
@@ -2988,40 +3553,24 @@ static int radeonfb_pci_register (struct
 		return -ENODEV;
 	}
 
-	/* I SHOULD FIX THAT CRAP ! I should probably mimmic XFree DRI
-	 * driver setup here.
-	 * 
-	 * On PPC, OF based cards setup the internal memory
-	 * mapping in strange ways. We change it so that the
-	 * framebuffer is mapped at 0 and given half of the card's
-	 * address space (2Gb). AGP is mapped high (0xe0000000) and
-	 * can use up to 512Mb. Once DRI is fully implemented, we
-	 * will have to setup the PCI remapper to remap the agp_special_page
-	 * memory page somewhere between those regions so that the card
-	 * use a normal PCI bus master cycle to access the ring read ptr.
-	 * --BenH.
-	 */
-#ifdef CONFIG_ALL_PPC
-	if (rinfo->hasCRTC2)
-		OUTREG(CRTC2_GEN_CNTL,
-			(INREG(CRTC2_GEN_CNTL) & ~CRTC2_EN) | CRTC2_DISP_REQ_EN_B);
-	OUTREG(CRTC_EXT_CNTL, INREG(CRTC_EXT_CNTL) | CRTC_DISPLAY_DIS);
-	OUTREG(MC_FB_LOCATION, 0x7fff0000);
-	OUTREG(MC_AGP_LOCATION, 0xffffe000);
-	OUTREG(DISPLAY_BASE_ADDR, 0x00000000);
-	if (rinfo->hasCRTC2)
-		OUTREG(CRTC2_DISPLAY_BASE_ADDR, 0x00000000);
-	OUTREG(SRC_OFFSET, 0x00000000);
-	OUTREG(DST_OFFSET, 0x00000000);
-	mdelay(10);
-	OUTREG(CRTC_EXT_CNTL, INREG(CRTC_EXT_CNTL) & ~CRTC_DISPLAY_DIS);
-#endif /* CONFIG_ALL_PPC */
-
 	/* save current mode regs before we switch into the new one
 	 * so we can restore this upon __exit
 	 */
 	radeon_save_state (rinfo, &rinfo->init_state);
 
+	/* On PPC, the firmware sets up a memory mapping that tends
+	 * to cause lockups when enabling the engine. We reconfigure
+	 * the card internal memory mappings properly
+	 * 
+	 * TODO: Save this in radeon_save_state so we can eventually
+	 * restore old mapping upon exit
+	 */
+#ifdef CONFIG_PPC_PMAC
+	fixup_memory_mappings(rinfo);
+#else	
+	rinfo->fb_local_base = INREG(MC_FB_LOCATION) << 16;
+#endif /* CONFIG_PPC_PMAC */
+
 	if (!noaccel) {
 		/* initialize the engine */
 		radeon_engine_init (rinfo);
@@ -3059,9 +3608,14 @@ static int radeonfb_pci_register (struct
 #endif
 
 #ifdef CONFIG_PMAC_PBOOK
-	if (rinfo->dviDisp_type == MT_LCD) {
+	if (rinfo->arch == RADEON_M6 || rinfo->arch == RADEON_M7 || rinfo->arch == RADEON_M9) {
+		/* Find PM registers in config space */
 		rinfo->pm_reg = pci_find_capability(pdev, PCI_CAP_ID_PM);
+		/* Enable dynamic PM of chip clocks */
+		radeon_pm_enable_dynamic_mode(rinfo);
+		/* Register sleep callbacks */
 		pmu_register_sleep_notifier(&radeon_sleep_notifier);
+		printk("radeonfb: Power Management enabled for Mobility chipsets\n");
 	}
 #endif
 
@@ -3119,10 +3673,10 @@ static void __devexit radeonfb_pci_unreg
 
 
 static struct pci_driver radeonfb_driver = {
-	.name		= "radeonfb",
-	.id_table	= radeonfb_pci_table,
-	.probe		= radeonfb_pci_register,
-	.remove		= __devexit_p(radeonfb_pci_unregister),
+	name:		"radeonfb",
+	id_table:	radeonfb_pci_table,
+	probe:		radeonfb_pci_register,
+	remove:		__devexit_p(radeonfb_pci_unregister),
 };
 
 
@@ -3154,6 +3708,12 @@ int __init radeonfb_setup (char *options
 			mirror = 1;
 		} else if (!strncmp(this_opt, "dfp", 3)) {
 			force_dfp = 1;
+			force_nolcd = 1;
+		} else if (!strncmp(this_opt, "crt", 3)) {
+			force_crt = 1;
+			force_nolcd = 1;
+		} else if (!strncmp(this_opt, "nolcd", 5)) {
+			force_nolcd = 1;
 		} else if (!strncmp(this_opt, "panel_yres:", 11)) {
 			panel_yres = simple_strtoul((this_opt+11), NULL, 0);
 		} else if (!strncmp(this_opt, "nomtrr", 6)) {
diff -p -purN linux-2.5/include/asm-ppc/dma.h linuxppc-2.5/include/asm-ppc/dma.h
--- linux-2.5/include/asm-ppc/dma.h	2003-06-05 05:11:02.000000000 +0200
+++ linuxppc-2.5/include/asm-ppc/dma.h	2003-07-17 05:33:23.000000000 +0200
@@ -9,8 +9,10 @@
 #ifdef __KERNEL__
 
 #include <linux/config.h>
-#include <asm/io.h>
 #include <linux/spinlock.h>
+#include <linux/sched.h>
+
+#include <asm/io.h>
 #include <asm/system.h>
 
 /*
@@ -25,14 +27,9 @@
  * with a grain of salt.
  */
 
-
 #ifndef _ASM_DMA_H
 #define _ASM_DMA_H
 
-#ifndef MAX_DMA_CHANNELS
-#define MAX_DMA_CHANNELS	8
-#endif
-
 /* The maximum address that we can perform a DMA transfer to on this platform */
 /* Doesn't really apply... */
 #define MAX_DMA_ADDRESS		0xFFFFFFFF
@@ -192,9 +189,9 @@ static __inline__ void release_dma_lock(
 /* enable/disable a specific DMA channel */
 static __inline__ void enable_dma(unsigned int dmanr)
 {
-	unsigned char ucDmaCmd=0x00;
+	unsigned char ucDmaCmd = 0x00;
 
-	if (dmanr != 4)	{
+	if (dmanr != 4) {
 		dma_outb(0, DMA2_MASK_REG);	/* This may not be enabled */
 		dma_outb(ucDmaCmd, DMA2_CMD_REG);	/* Enable group */
 	}
@@ -244,60 +241,58 @@ static __inline__ void set_dma_mode(unsi
  */
 static __inline__ void set_dma_page(unsigned int dmanr, int pagenr)
 {
-	switch(dmanr) {
-		case 0:
-			dma_outb(pagenr, DMA_LO_PAGE_0);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_0);
-			break;
-		case 1:
-			dma_outb(pagenr, DMA_LO_PAGE_1);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_1);
-			break;
-		case 2:
-			dma_outb(pagenr, DMA_LO_PAGE_2);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_2);
-			break;
-		case 3:
-			dma_outb(pagenr, DMA_LO_PAGE_3);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_3);
-			break;
-		case 5:
-			if (SND_DMA1 == 5 || SND_DMA2 == 5)
-				dma_outb(pagenr, DMA_LO_PAGE_5);
-			else
-				dma_outb(pagenr & 0xfe, DMA_LO_PAGE_5);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_5);
-			break;
-		case 6:
-			if (SND_DMA1 == 6 || SND_DMA2 == 6)
-				dma_outb(pagenr, DMA_LO_PAGE_6);
-			else
-				dma_outb(pagenr & 0xfe, DMA_LO_PAGE_6);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_6);
-			break;
-		case 7:
-			if (SND_DMA1 == 7 || SND_DMA2 == 7)
-				dma_outb(pagenr, DMA_LO_PAGE_7);
-			else
-				dma_outb(pagenr & 0xfe, DMA_LO_PAGE_7);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_7);
-			break;
+	switch (dmanr) {
+	case 0:
+		dma_outb(pagenr, DMA_LO_PAGE_0);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_0);
+		break;
+	case 1:
+		dma_outb(pagenr, DMA_LO_PAGE_1);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_1);
+		break;
+	case 2:
+		dma_outb(pagenr, DMA_LO_PAGE_2);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_2);
+		break;
+	case 3:
+		dma_outb(pagenr, DMA_LO_PAGE_3);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_3);
+		break;
+	case 5:
+		if (SND_DMA1 == 5 || SND_DMA2 == 5)
+			dma_outb(pagenr, DMA_LO_PAGE_5);
+		else
+			dma_outb(pagenr & 0xfe, DMA_LO_PAGE_5);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_5);
+		break;
+	case 6:
+		if (SND_DMA1 == 6 || SND_DMA2 == 6)
+			dma_outb(pagenr, DMA_LO_PAGE_6);
+		else
+			dma_outb(pagenr & 0xfe, DMA_LO_PAGE_6);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_6);
+		break;
+	case 7:
+		if (SND_DMA1 == 7 || SND_DMA2 == 7)
+			dma_outb(pagenr, DMA_LO_PAGE_7);
+		else
+			dma_outb(pagenr & 0xfe, DMA_LO_PAGE_7);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_7);
+		break;
 	}
 }
 
-
 /* Set transfer address & page bits for specific DMA channel.
  * Assumes dma flipflop is clear.
  */
 static __inline__ void set_dma_addr(unsigned int dmanr, unsigned int phys)
 {
 	if (dmanr <= 3) {
-		dma_outb(phys & 0xff, ((dmanr & 3) << 1) + IO_DMA1_BASE );
+		dma_outb(phys & 0xff, ((dmanr & 3) << 1) + IO_DMA1_BASE);
 		dma_outb((phys >> 8) & 0xff, ((dmanr & 3) << 1) + IO_DMA1_BASE);
 	} else if (dmanr == SND_DMA1 || dmanr == SND_DMA2) {
-		dma_outb(phys  & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE );
-		dma_outb((phys >> 8)  & 0xff, ((dmanr & 3) << 2) +
-				IO_DMA2_BASE);
+		dma_outb(phys & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE);
+		dma_outb((phys >> 8) & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE);
 		dma_outb((dmanr & 3), DMA2_EXT_REG);
 	} else {
 		dma_outb((phys >> 1) & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE);
@@ -306,7 +301,6 @@ static __inline__ void set_dma_addr(unsi
 	set_dma_page(dmanr, phys >> 16);
 }
 
-
 /* Set transfer size (max 64k for DMA1..3, 128k for DMA5..7) for
  * a specific DMA channel.
  * You must ensure the parameters are valid.
@@ -321,16 +315,16 @@ static __inline__ void set_dma_count(uns
 	if (dmanr <= 3) {
 		dma_outb(count & 0xff, ((dmanr & 3) << 1) + 1 + IO_DMA1_BASE);
 		dma_outb((count >> 8) & 0xff, ((dmanr & 3) << 1) + 1 +
-				IO_DMA1_BASE);
+			 IO_DMA1_BASE);
 	} else if (dmanr == SND_DMA1 || dmanr == SND_DMA2) {
-		dma_outb( count & 0xff, ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE);
-		dma_outb( (count >> 8) & 0xff, ((dmanr & 3) << 2) + 2 +
-				IO_DMA2_BASE);
+		dma_outb(count & 0xff, ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE);
+		dma_outb((count >> 8) & 0xff, ((dmanr & 3) << 2) + 2 +
+			 IO_DMA2_BASE);
 	} else {
 		dma_outb((count >> 1) & 0xff, ((dmanr & 3) << 2) + 2 +
-				IO_DMA2_BASE);
+			 IO_DMA2_BASE);
 		dma_outb((count >> 9) & 0xff, ((dmanr & 3) << 2) + 2 +
-				IO_DMA2_BASE);
+			 IO_DMA2_BASE);
 	}
 }
 
@@ -345,8 +339,8 @@ static __inline__ void set_dma_count(uns
 static __inline__ int get_dma_residue(unsigned int dmanr)
 {
 	unsigned int io_port = (dmanr <= 3) ?
-		((dmanr & 3) << 1) + 1 + IO_DMA1_BASE
-		: ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE;
+	    ((dmanr & 3) << 1) + 1 + IO_DMA1_BASE
+	    : ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE;
 
 	/* using short to get 16-bit wrap around */
 	unsigned short count;
@@ -355,21 +349,25 @@ static __inline__ int get_dma_residue(un
 	count += dma_inb(io_port) << 8;
 
 	return (dmanr <= 3 || dmanr == SND_DMA1 || dmanr == SND_DMA2)
-		? count : (count<<1);
+	    ? count : (count << 1);
 
 }
 
 /* These are in kernel/dma.c: */
 
 /* reserve a DMA channel */
-extern int request_dma(unsigned int dmanr, const char * device_id);
+extern int request_dma(unsigned int dmanr, const char *device_id);
 /* release it again */
 extern void free_dma(unsigned int dmanr);
 
+#ifndef MAX_DMA_CHANNELS
+#define MAX_DMA_CHANNELS	8
+#endif
 #ifdef CONFIG_PCI
 extern int isa_dma_bridge_buggy;
 #else
 #define isa_dma_bridge_buggy	(0)
 #endif
+
 #endif /* _ASM_DMA_H */
 #endif /* __KERNEL__ */
diff -p -purN linux-2.5/include/asm-ppc/ibm4xx.h linuxppc-2.5/include/asm-ppc/ibm4xx.h
--- linux-2.5/include/asm-ppc/ibm4xx.h	2003-09-23 02:13:38.000000000 +0200
+++ linuxppc-2.5/include/asm-ppc/ibm4xx.h	2003-09-27 13:12:08.000000000 +0200
@@ -38,6 +38,14 @@
 #include <platforms/4xx/oak.h>
 #endif
 
+#if defined(CONFIG_XILINX_ML300)
+#include <platforms/4xx/xilinx_ml300.h>
+#endif
+
+#if defined(CONFIG_RAINIER)
+#include <platforms/4xx/rainier.h>
+#endif
+
 #if defined(CONFIG_REDWOOD_4)
 #include <platforms/4xx/redwood.h>
 #endif
@@ -46,18 +54,27 @@
 #include <platforms/4xx/redwood5.h>
 #endif
 
+#if defined(CONFIG_REDWOOD_6)
+#include <platforms/4xx/redwood6.h>
+#endif
+
 #if defined(CONFIG_WALNUT)
 #include <platforms/4xx/walnut.h>
 #endif
 
-#ifndef __ASSEMBLY__
+#if defined(CONFIG_BEECH)
+#include <platforms/4xx/beech.h>
+#endif
 
-/*
- * The "residual" board information structure the boot loader passes
- * into the kernel.
- */
-extern bd_t __res;
+#if defined(CONFIG_ARCTIC2)
+#include <platforms/4xx/arctic2.h>
+#endif
+
+#if defined(CONFIG_SYCAMORE)
+#include <platforms/4xx/sycamore.h>
+#endif
 
+#ifndef __ASSEMBLY__
 void ppc4xx_setup_arch(void);
 void ppc4xx_map_io(void);
 void ppc4xx_init_IRQ(void);
diff -p -purN linux-2.5/include/asm-ppc/ibm_ocp_gpio.h linuxppc-2.5/include/asm-ppc/ibm_ocp_gpio.h
--- linux-2.5/include/asm-ppc/ibm_ocp_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/include/asm-ppc/ibm_ocp_gpio.h	2003-01-06 09:38:18.000000000 +0100
@@ -0,0 +1,58 @@
+/*
+ * FILE NAME ibm_ocp_gpio.h
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Generic gpio.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __IBM_OCP_GPIO_H
+#define __IBM_OCP_GPIO_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#define IBMGPIO_IOCTL_BASE	'Z'
+
+struct ocp_gpio_ioctl_data {
+	__u32 device;
+	__u32 mask;
+	__u32 data;
+};
+
+#define GPIO_MINOR             185
+#define IBMGPIO_IN		_IOWR(IBMGPIO_IOCTL_BASE, 0, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_OUT		_IOW (IBMGPIO_IOCTL_BASE, 1, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_OPEN_DRAIN	_IOW (IBMGPIO_IOCTL_BASE, 2, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_TRISTATE	_IOW (IBMGPIO_IOCTL_BASE, 3, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_CFG		_IOW (IBMGPIO_IOCTL_BASE, 4, struct ocp_gpio_ioctl_data)
+
+#endif
diff -p -purN linux-2.5/include/asm-ppc/irq.h linuxppc-2.5/include/asm-ppc/irq.h
--- linux-2.5/include/asm-ppc/irq.h	2003-09-12 18:26:56.000000000 +0200
+++ linuxppc-2.5/include/asm-ppc/irq.h	2003-09-12 19:39:40.000000000 +0200
@@ -3,6 +3,7 @@
 #define _ASM_IRQ_H
 
 #include <linux/config.h>
+#include <linux/sched.h>
 #include <asm/machdep.h>		/* ppc_md */
 #include <asm/atomic.h>
 
diff -p -purN linux-2.5/include/asm-ppc/machdep.h linuxppc-2.5/include/asm-ppc/machdep.h
--- linux-2.5/include/asm-ppc/machdep.h	2003-04-23 09:49:34.000000000 +0200
+++ linuxppc-2.5/include/asm-ppc/machdep.h	2003-06-18 00:29:10.000000000 +0200
@@ -52,6 +52,7 @@ struct machdep_calls {
 	unsigned long	(*find_end_of_memory)(void);
 	void		(*setup_io_mappings)(void);
 
+	void		(*early_serial_map)(void);
   	void		(*progress)(char *, unsigned short);
 
 	unsigned char 	(*nvram_read_val)(int addr);
diff -p -purN linux-2.5/include/asm-ppc/pccf_4xx.h linuxppc-2.5/include/asm-ppc/pccf_4xx.h
--- linux-2.5/include/asm-ppc/pccf_4xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/include/asm-ppc/pccf_4xx.h	2003-06-13 00:25:47.000000000 +0200
@@ -0,0 +1,27 @@
+#ifndef __ASM_PCCF_4XX_H
+#define __ASM_PCCF_4XX_H
+
+/* Areas that we ioremap() are mapped only as large as necessary to get the job
+   done: Only a few locations of the macro space are used, and legacy IO space
+   is only 64 KB. There is 1 memory window, and 2 virtual IO windows. */
+
+#define PCCF_4XX_MACRO_OFFSET	0x00000000
+#define PCCF_4XX_MACRO_PADDR	(PCCF_4XX_PADDR + PCCF_4XX_MACRO_OFFSET)
+#define PCCF_4XX_MACRO_WINSIZE	PAGE_SIZE
+
+#define PCCF_4XX_MEM_OFFSET	0x01000000
+#define PCCF_4XX_MEM_PADDR	(PCCF_4XX_PADDR + PCCF_4XX_MEM_OFFSET)
+#define PCCF_4XX_MEM_WINSIZE	(8 * 1024 * 1024)
+
+#define PCCF_4XX_IO_OFFSET	0x01800000
+#define PCCF_4XX_IO_PADDR	(PCCF_4XX_PADDR + PCCF_4XX_IO_OFFSET)
+#define PCCF_4XX_IO_WINSIZE	0x00010000
+
+/* These are declared here, since the pccf_4xx driver needs them, but
+ * must be defined and initialized by the board setup code. */
+extern volatile u16 *pccf_4xx_macro_vaddr;
+extern unsigned long pccf_4xx_io_base;
+extern unsigned long pccf_4xx_mem_base;
+
+#endif /* __ASM_PCCF_4XX_H */
+
diff -p -purN linux-2.5/include/asm-ppc/ppc4xx_dma.h linuxppc-2.5/include/asm-ppc/ppc4xx_dma.h
--- linux-2.5/include/asm-ppc/ppc4xx_dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/include/asm-ppc/ppc4xx_dma.h	2003-06-27 01:17:09.000000000 +0200
@@ -0,0 +1,593 @@
+/*
+ * include/asm-ppc/ppc4xx_dma.h
+ *
+ * IBM PPC4xx DMA engine library
+ *
+ * Copyright 2000-2003 MontaVista Software Inc.
+ *
+ * Cleaned by Matt Porter <mporter@mvista.com>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASMPPC_PPC4xx_DMA_H
+#define __ASMPPC_PPC4xx_DMA_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <asm/mmu.h>
+#include <asm/ibm4xx.h>
+
+#undef DEBUG_4xxDMA
+
+#define MAX_PPC4xx_DMA_CHANNELS		4
+
+/* in arch/ppc/kernel/setup.c -- Cort */
+extern unsigned long DMA_MODE_WRITE, DMA_MODE_READ;
+
+/* 
+ * Function return status codes
+ * These values are used to indicate whether or not the function
+ * call was successful, or a bad/invalid parameter was passed.
+ */
+#define DMA_STATUS_GOOD			0
+#define DMA_STATUS_BAD_CHANNEL		1
+#define DMA_STATUS_BAD_HANDLE		2
+#define DMA_STATUS_BAD_MODE		3
+#define DMA_STATUS_NULL_POINTER		4
+#define DMA_STATUS_OUT_OF_MEMORY	5
+#define DMA_STATUS_SGL_LIST_EMPTY	6
+#define DMA_STATUS_GENERAL_ERROR	7
+#define DMA_STATUS_CHANNEL_NOTFREE	8
+
+#define DMA_CHANNEL_BUSY		0x80000000
+
+/*
+ * These indicate status as returned from the DMA Status Register.
+ */
+#define DMA_STATUS_NO_ERROR	0
+#define DMA_STATUS_CS		1	/* Count Status        */
+#define DMA_STATUS_TS		2	/* Transfer Status     */
+#define DMA_STATUS_DMA_ERROR	3	/* DMA Error Occurred  */
+#define DMA_STATUS_DMA_BUSY	4	/* The channel is busy */
+
+
+/*
+ * DMA Channel Control Registers
+ */
+
+#ifdef CONFIG_44x
+#define	PPC4xx_DMA_64BIT
+#define DMA_CR_OFFSET 1
+#else
+#define DMA_CR_OFFSET 0
+#endif
+
+#define DMA_CE_ENABLE        (1<<31)	/* DMA Channel Enable */
+#define SET_DMA_CE_ENABLE(x) (((x)&0x1)<<31)
+#define GET_DMA_CE_ENABLE(x) (((x)&DMA_CE_ENABLE)>>31)
+
+#define DMA_CIE_ENABLE        (1<<30)	/* DMA Channel Interrupt Enable */
+#define SET_DMA_CIE_ENABLE(x) (((x)&0x1)<<30)
+#define GET_DMA_CIE_ENABLE(x) (((x)&DMA_CIE_ENABLE)>>30)
+
+#define DMA_TD                (1<<29)
+#define SET_DMA_TD(x)         (((x)&0x1)<<29)
+#define GET_DMA_TD(x)         (((x)&DMA_TD)>>29)
+
+#define DMA_PL                (1<<28)	/* Peripheral Location */
+#define SET_DMA_PL(x)         (((x)&0x1)<<28)
+#define GET_DMA_PL(x)         (((x)&DMA_PL)>>28)
+
+#define EXTERNAL_PERIPHERAL    0
+#define INTERNAL_PERIPHERAL    1
+
+#define SET_DMA_PW(x)     (((x)&0x3)<<(26-DMA_CR_OFFSET))	/* Peripheral Width */
+#define DMA_PW_MASK       SET_DMA_PW(3)
+#define   PW_8                 0
+#define   PW_16                1
+#define   PW_32                2
+#define   PW_64                3
+/* FIXME: Add PW_128 support for 440GP DMA block */
+#define GET_DMA_PW(x)     (((x)&DMA_PW_MASK)>>(26-DMA_CR_OFFSET))
+
+#define DMA_DAI           (1<<(25-DMA_CR_OFFSET))	/* Destination Address Increment */
+#define SET_DMA_DAI(x)    (((x)&0x1)<<(25-DMA_CR_OFFSET))
+
+#define DMA_SAI           (1<<(24-DMA_CR_OFFSET))	/* Source Address Increment */
+#define SET_DMA_SAI(x)    (((x)&0x1)<<(24-DMA_CR_OFFSET))
+
+#define DMA_BEN           (1<<(23-DMA_CR_OFFSET))	/* Buffer Enable */
+#define SET_DMA_BEN(x)    (((x)&0x1)<<(23-DMA_CR_OFFSET))
+
+#define SET_DMA_TM(x)     (((x)&0x3)<<(21-DMA_CR_OFFSET))	/* Transfer Mode */
+#define DMA_TM_MASK       SET_DMA_TM(3)
+#define   TM_PERIPHERAL        0	/* Peripheral */
+#define   TM_RESERVED          1	/* Reserved */
+#define   TM_S_MM              2	/* Memory to Memory */
+#define   TM_D_MM              3	/* Device Paced Memory to Memory */
+#define GET_DMA_TM(x)     (((x)&DMA_TM_MASK)>>(21-DMA_CR_OFFSET))
+
+#define SET_DMA_PSC(x)    (((x)&0x3)<<(19-DMA_CR_OFFSET))	/* Peripheral Setup Cycles */
+#define DMA_PSC_MASK      SET_DMA_PSC(3)
+#define GET_DMA_PSC(x)    (((x)&DMA_PSC_MASK)>>(19-DMA_CR_OFFSET))
+
+#define SET_DMA_PWC(x)    (((x)&0x3F)<<(13-DMA_CR_OFFSET))	/* Peripheral Wait Cycles */
+#define DMA_PWC_MASK      SET_DMA_PWC(0x3F)
+#define GET_DMA_PWC(x)    (((x)&DMA_PWC_MASK)>>(13-DMA_CR_OFFSET))
+
+#define SET_DMA_PHC(x)    (((x)&0x7)<<(10-DMA_CR_OFFSET))	/* Peripheral Hold Cycles */
+#define DMA_PHC_MASK      SET_DMA_PHC(0x7)
+#define GET_DMA_PHC(x)    (((x)&DMA_PHC_MASK)>>(10-DMA_CR_OFFSET))
+
+#define DMA_ETD_OUTPUT     (1<<(9-DMA_CR_OFFSET))	/* EOT pin is a TC output */
+#define SET_DMA_ETD(x)     (((x)&0x1)<<(9-DMA_CR_OFFSET))
+
+#define DMA_TCE_ENABLE     (1<<(8-DMA_CR_OFFSET))
+#define SET_DMA_TCE(x)     (((x)&0x1)<<(8-DMA_CR_OFFSET))
+
+#define DMA_DEC            (1<<(2)	/* Address Decrement */
+#define SET_DMA_DEC(x)     (((x)&0x1)<<2)
+#define GET_DMA_DEC(x)     (((x)&DMA_DEC)>>2)
+
+/*
+ * Transfer Modes
+ * These modes are defined in a way that makes it possible to
+ * simply "or" in the value in the control register.
+ */
+
+#define DMA_MODE_MM		(SET_DMA_TM(TM_S_MM))	/* memory to memory */
+
+				/* Device-paced memory to memory, */
+				/* device is at source address    */
+#define DMA_MODE_MM_DEVATSRC	(DMA_TD | SET_DMA_TM(TM_D_MM))
+
+				/* Device-paced memory to memory,      */
+				/* device is at destination address    */
+#define DMA_MODE_MM_DEVATDST	(SET_DMA_TM(TM_D_MM))
+
+/* 405gp/440gp */
+#define SET_DMA_PREFETCH(x)   (((x)&0x3)<<(4-DMA_CR_OFFSET))	/* Memory Read Prefetch */
+#define DMA_PREFETCH_MASK      SET_DMA_PREFETCH(3)
+#define   PREFETCH_1           0	/* Prefetch 1 Double Word */
+#define   PREFETCH_2           1
+#define   PREFETCH_4           2
+#define GET_DMA_PREFETCH(x) (((x)&DMA_PREFETCH_MASK)>>(4-DMA_CR_OFFSET))
+
+#define DMA_PCE            (1<<(3-DMA_CR_OFFSET))	/* Parity Check Enable */
+#define SET_DMA_PCE(x)     (((x)&0x1)<<(3-DMA_CR_OFFSET))
+#define GET_DMA_PCE(x)     (((x)&DMA_PCE)>>(3-DMA_CR_OFFSET))
+
+/* stb3x */
+
+#define DMA_ECE_ENABLE (1<<5)
+#define SET_DMA_ECE(x) (((x)&0x1)<<5)
+#define GET_DMA_ECE(x) (((x)&DMA_ECE_ENABLE)>>5)
+
+#define DMA_TCD_DISABLE	(1<<4)
+#define SET_DMA_TCD(x) (((x)&0x1)<<4)
+#define GET_DMA_TCD(x) (((x)&DMA_TCD_DISABLE)>>4)
+
+typedef uint32_t sgl_handle_t;
+
+#ifdef CONFIG_PPC4xx_EDMA
+
+#define SGL_LIST_SIZE 4096
+#define DMA_PPC4xx_SIZE SGL_LIST_SIZE
+
+#define SET_DMA_PRIORITY(x)   (((x)&0x3)<<(6-DMA_CR_OFFSET))	/* DMA Channel Priority */
+#define DMA_PRIORITY_MASK SET_DMA_PRIORITY(3)
+#define PRIORITY_LOW           0
+#define PRIORITY_MID_LOW       1
+#define PRIORITY_MID_HIGH      2
+#define PRIORITY_HIGH          3
+#define GET_DMA_PRIORITY(x) (((x)&DMA_PRIORITY_MASK)>>(6-DMA_CR_OFFSET))
+
+/* 
+ * DMA Polarity Configuration Register
+ */
+
+#define DMAReq0_ActiveLow (1<<31)
+#define DMAAck0_ActiveLow (1<<30)
+#define EOT0_ActiveLow    (1<<29)	/* End of Transfer      */
+
+#define DMAReq1_ActiveLow (1<<28)
+#define DMAAck1_ActiveLow (1<<27)
+#define EOT1_ActiveLow    (1<<26)
+
+#define DMAReq2_ActiveLow (1<<25)
+#define DMAAck2_ActiveLow (1<<24)
+#define EOT2_ActiveLow    (1<<23)
+
+#define DMAReq3_ActiveLow (1<<22)
+#define DMAAck3_ActiveLow (1<<21)
+#define EOT3_ActiveLow    (1<<20)
+
+/*
+ * DMA Sleep Mode Register
+ */
+#define SLEEP_MODE_ENABLE (1<<21)
+
+/*
+ * DMA Status Register
+ */
+#define DMA_CS0           (1<<31)	/* Terminal Count has been reached */
+#define DMA_CS1           (1<<30)
+#define DMA_CS2           (1<<29)
+#define DMA_CS3           (1<<28)
+
+#define DMA_TS0           (1<<27)	/* End of Transfer has been requested */
+#define DMA_TS1           (1<<26)
+#define DMA_TS2           (1<<25)
+#define DMA_TS3           (1<<24)
+
+#define DMA_CH0_ERR       (1<<23)	/* DMA Chanel 0 Error */
+#define DMA_CH1_ERR       (1<<22)
+#define DMA_CH2_ERR       (1<<21)
+#define DMA_CH3_ERR       (1<<20)
+
+#define DMA_IN_DMA_REQ0   (1<<19)	/* Internal DMA Request is pending */
+#define DMA_IN_DMA_REQ1   (1<<18)
+#define DMA_IN_DMA_REQ2   (1<<17)
+#define DMA_IN_DMA_REQ3   (1<<16)
+
+#define DMA_EXT_DMA_REQ0  (1<<15)	/* External DMA Request is pending */
+#define DMA_EXT_DMA_REQ1  (1<<14)
+#define DMA_EXT_DMA_REQ2  (1<<13)
+#define DMA_EXT_DMA_REQ3  (1<<12)
+
+#define DMA_CH0_BUSY      (1<<11)	/* DMA Channel 0 Busy */
+#define DMA_CH1_BUSY      (1<<10)
+#define DMA_CH2_BUSY       (1<<9)
+#define DMA_CH3_BUSY       (1<<8)
+
+#define DMA_SG0            (1<<7)	/* DMA Channel 0 Scatter/Gather in progress */
+#define DMA_SG1            (1<<6)
+#define DMA_SG2            (1<<5)
+#define DMA_SG3            (1<<4)
+
+/*
+ * DMA SG Command Register
+ */
+#define SSG0_ENABLE        (1<<31)	/* Start Scatter Gather */
+#define SSG1_ENABLE        (1<<30)
+#define SSG2_ENABLE        (1<<29)
+#define SSG3_ENABLE        (1<<28)
+#define SSG0_MASK_ENABLE   (1<<15)	/* Enable writing to SSG0 bit */
+#define SSG1_MASK_ENABLE   (1<<14)
+#define SSG2_MASK_ENABLE   (1<<13)
+#define SSG3_MASK_ENABLE   (1<<12)
+
+/*
+ * DMA Scatter/Gather Descriptor Bit fields 
+ */
+#define SG_LINK            (1<<31)	/* Link */
+#define SG_TCI_ENABLE      (1<<29)	/* Enable Terminal Count Interrupt */
+#define SG_ETI_ENABLE      (1<<28)	/* Enable End of Transfer Interrupt */
+#define SG_ERI_ENABLE      (1<<27)	/* Enable Error Interrupt */
+#define SG_COUNT_MASK       0xFFFF	/* Count Field */
+
+#define SET_DMA_CONTROL \
+ 		(SET_DMA_CIE_ENABLE(p_init->int_enable) | /* interrupt enable         */ \
+ 		SET_DMA_BEN(p_init->buffer_enable)     | /* buffer enable            */\
+		SET_DMA_ETD(p_init->etd_output)        | /* end of transfer pin      */ \
+	       	SET_DMA_TCE(p_init->tce_enable)        | /* terminal count enable    */ \
+                SET_DMA_PL(p_init->pl)                 | /* peripheral location      */ \
+                SET_DMA_DAI(p_init->dai)               | /* dest addr increment      */ \
+                SET_DMA_SAI(p_init->sai)               | /* src addr increment       */ \
+                SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */ \
+                SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */ \
+                SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */ \
+                SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */ \
+                SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */ \
+                SET_DMA_PREFETCH(p_init->pf)              /* read prefetch           */)
+
+#define GET_DMA_POLARITY(chan) (DMAReq##chan##_ActiveLow | DMAAck##chan##_ActiveLow | EOT##chan##_ActiveLow)
+
+#elif defined(CONFIG_STBXXX_DMA)		/* stb03xxx */
+
+#define DMA_PPC4xx_SIZE	4096
+
+/*
+ * DMA Status Register
+ */
+
+#define SET_DMA_PRIORITY(x)   (((x)&0x00800001))	/* DMA Channel Priority */
+#define DMA_PRIORITY_MASK	0x00800001
+#define   PRIORITY_LOW         	0x00000000
+#define   PRIORITY_MID_LOW     	0x00000001
+#define   PRIORITY_MID_HIGH    	0x00800000
+#define   PRIORITY_HIGH        	0x00800001
+#define GET_DMA_PRIORITY(x) (((((x)&DMA_PRIORITY_MASK) &0x00800000) >> 22 ) | (((x)&DMA_PRIORITY_MASK) &0x00000001))
+
+#define DMA_CS0           (1<<31)	/* Terminal Count has been reached */
+#define DMA_CS1           (1<<30)
+#define DMA_CS2           (1<<29)
+#define DMA_CS3           (1<<28)
+
+#define DMA_TS0           (1<<27)	/* End of Transfer has been requested */
+#define DMA_TS1           (1<<26)
+#define DMA_TS2           (1<<25)
+#define DMA_TS3           (1<<24)
+
+#define DMA_CH0_ERR       (1<<23)	/* DMA Chanel 0 Error */
+#define DMA_CH1_ERR       (1<<22)
+#define DMA_CH2_ERR       (1<<21)
+#define DMA_CH3_ERR       (1<<20)
+
+#define DMA_CT0		  (1<<19)	/* Chained transfere */
+
+#define DMA_IN_DMA_REQ0   (1<<18)	/* Internal DMA Request is pending */
+#define DMA_IN_DMA_REQ1   (1<<17)
+#define DMA_IN_DMA_REQ2   (1<<16)
+#define DMA_IN_DMA_REQ3   (1<<15)
+
+#define DMA_EXT_DMA_REQ0  (1<<14)	/* External DMA Request is pending */
+#define DMA_EXT_DMA_REQ1  (1<<13)
+#define DMA_EXT_DMA_REQ2  (1<<12)
+#define DMA_EXT_DMA_REQ3  (1<<11)
+
+#define DMA_CH0_BUSY      (1<<10)	/* DMA Channel 0 Busy */
+#define DMA_CH1_BUSY      (1<<9)
+#define DMA_CH2_BUSY       (1<<8)
+#define DMA_CH3_BUSY       (1<<7)
+
+#define DMA_CT1            (1<<6)	/* Chained transfere */
+#define DMA_CT2            (1<<5)
+#define DMA_CT3            (1<<4)
+
+#define DMA_CH_ENABLE (1<<7)
+#define SET_DMA_CH(x) (((x)&0x1)<<7)
+#define GET_DMA_CH(x) (((x)&DMA_CH_ENABLE)>>7)
+
+/* STBx25xxx dma unique */
+/* enable device port on a dma channel 
+ * example ext 0 on dma 1
+ */
+
+#define	SSP0_RECV	15
+#define	SSP0_XMIT	14
+#define EXT_DMA_0	12
+#define	SC1_XMIT	11
+#define SC1_RECV	10
+#define EXT_DMA_2	9 
+#define	EXT_DMA_3	8 
+#define SERIAL2_XMIT	7
+#define SERIAL2_RECV	6
+#define SC0_XMIT 	5
+#define	SC0_RECV	4
+#define	SERIAL1_XMIT	3 
+#define SERIAL1_RECV	2
+#define	SERIAL0_XMIT	1
+#define SERIAL0_RECV	0
+
+#define DMA_CHAN_0	1
+#define DMA_CHAN_1	2
+#define DMA_CHAN_2	3
+#define DMA_CHAN_3	4
+
+/* end STBx25xx */
+
+/*
+ * Bit 30 must be one for Redwoods, otherwise transfers may receive errors.
+ */
+#define DMA_CR_MB0 0x2
+
+#define SET_DMA_CONTROL \
+       		(SET_DMA_CIE_ENABLE(p_init->int_enable) |  /* interrupt enable         */ \
+		SET_DMA_ETD(p_init->etd_output)        |  /* end of transfer pin      */ \
+		SET_DMA_TCE(p_init->tce_enable)        |  /* terminal count enable    */ \
+		SET_DMA_PL(p_init->pl)                 |  /* peripheral location      */ \
+		SET_DMA_DAI(p_init->dai)               |  /* dest addr increment      */ \
+		SET_DMA_SAI(p_init->sai)               |  /* src addr increment       */ \
+		SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */  \
+		SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */ \
+		SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */ \
+		SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */ \
+		SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */ \
+		SET_DMA_TCD(p_init->tcd_disable)	  |  /* TC chain mode disable   */ \
+		SET_DMA_ECE(p_init->ece_enable)	  |  /* ECE chanin mode enable  */ \
+		SET_DMA_CH(p_init->ch_enable)	|    /* Chain enable 	        */ \
+		DMA_CR_MB0				/* must be one */)
+
+#define GET_DMA_POLARITY(chan) chan
+
+#endif
+
+typedef struct {
+	unsigned short in_use;	/* set when channel is being used, clr when
+				 * available.
+				 */
+	/* 
+	 * Valid polarity settings:
+	 *   DMAReq0_ActiveLow
+	 *   DMAAck0_ActiveLow
+	 *   EOT0_ActiveLow
+	 *
+	 *   DMAReq1_ActiveLow
+	 *   DMAAck1_ActiveLow
+	 *   EOT1_ActiveLow
+	 * 
+	 *   DMAReq2_ActiveLow
+	 *   DMAAck2_ActiveLow
+	 *   EOT2_ActiveLow
+	 *
+	 *   DMAReq3_ActiveLow 
+	 *   DMAAck3_ActiveLow
+	 *   EOT3_ActiveLow
+	 */
+	unsigned int polarity;
+
+	char buffer_enable;	/* Boolean: buffer enable            */
+	char tce_enable;	/* Boolean: terminal count enable    */
+	char etd_output;	/* Boolean: eot pin is a tc output   */
+	char pce;		/* Boolean: parity check enable      */
+
+	/*
+	 * Peripheral location:
+	 * INTERNAL_PERIPHERAL (UART0 on the 405GP)
+	 * EXTERNAL_PERIPHERAL
+	 */
+	char pl;		/* internal/external peripheral      */
+
+	/*
+	 * Valid pwidth settings:
+	 *   PW_8
+	 *   PW_16
+	 *   PW_32
+	 *   PW_64
+	 */
+	unsigned int pwidth;
+
+	char dai;		/* Boolean: dst address increment   */
+	char sai;		/* Boolean: src address increment   */
+
+	/*
+	 * Valid psc settings: 0-3
+	 */
+	unsigned int psc;	/* Peripheral Setup Cycles         */
+
+	/*
+	 * Valid pwc settings:
+	 * 0-63
+	 */
+	unsigned int pwc;	/* Peripheral Wait Cycles          */
+
+	/*
+	 * Valid phc settings:
+	 * 0-7
+	 */
+	unsigned int phc;	/* Peripheral Hold Cycles          */
+
+	/*
+	 * Valid cp (channel priority) settings:
+	 *   PRIORITY_LOW
+	 *   PRIORITY_MID_LOW
+	 *   PRIORITY_MID_HIGH
+	 *   PRIORITY_HIGH
+	 */
+	unsigned int cp;	/* channel priority                */
+
+	/*
+	 * Valid pf (memory read prefetch) settings:
+	 *
+	 *   PREFETCH_1
+	 *   PREFETCH_2
+	 *   PREFETCH_4
+	 */
+	unsigned int pf;	/* memory read prefetch            */
+
+	/*
+	 * Boolean: channel interrupt enable
+	 * NOTE: for sgl transfers, only the last descriptor will be setup to
+	 * interrupt.
+	 */
+	char int_enable;
+
+	char shift;		/* easy access to byte_count shift, based on */
+	/* the width of the channel                  */
+
+	uint32_t control;	/* channel control word                      */
+
+	/* These variabled are used ONLY in single dma transfers              */
+	unsigned int mode;	/* transfer mode                     */
+	phys_addr_t addr;
+	char ce;		/* channel enable */
+#ifdef CONFIG_STB03xxx
+	char ch_enable;
+	char tcd_disable;
+	char ece_enable;
+	char td;		/* transfer direction */
+#endif
+
+} ppc_dma_ch_t;
+
+/*
+ * PPC44x DMA implementations have a slightly different
+ * descriptor layout.  Probably moved about due to the
+ * change to 64-bit addresses and link pointer. I don't
+ * know why they didn't just leave control_count after
+ * the dst_addr.
+ */
+#ifdef PPC4xx_DMA_64BIT
+typedef struct {
+	uint32_t control;
+	uint32_t control_count;
+	phys_addr_t src_addr;
+	phys_addr_t dst_addr;
+	phys_addr_t next;
+} ppc_sgl_t;
+#else
+typedef struct {
+	uint32_t control;
+	phys_addr_t src_addr;
+	phys_addr_t dst_addr;
+	uint32_t control_count;
+	uint32_t next;
+} ppc_sgl_t;
+#endif
+
+typedef struct {
+	unsigned int dmanr;
+	uint32_t control;	/* channel ctrl word; loaded from each descrptr */
+	uint32_t sgl_control;	/* LK, TCI, ETI, and ERI bits in sgl descriptor */
+	dma_addr_t dma_addr;	/* dma (physical) address of this list          */
+	ppc_sgl_t *phead;
+	ppc_sgl_t *ptail;
+	uint32_t pad32[2];
+
+} sgl_list_info_t;
+
+typedef struct {
+	phys_addr_t *src_addr;
+	phys_addr_t *dst_addr;
+	phys_addr_t dma_src_addr;
+	phys_addr_t dma_dst_addr;
+} pci_alloc_desc_t;
+
+extern ppc_dma_ch_t dma_channels[];
+
+/*
+ * The DMA API are in ppc4xx_dma.c and ppc4xx_sgdma.c
+ */
+extern int ppc4xx_init_dma_channel(unsigned int, ppc_dma_ch_t *);
+extern int ppc4xx_get_channel_config(unsigned int, ppc_dma_ch_t *);
+extern int ppc4xx_set_channel_priority(unsigned int, unsigned int);
+extern unsigned int ppc4xx_get_peripheral_width(unsigned int);
+extern int ppc4xx_alloc_dma_handle(sgl_handle_t *, unsigned int, unsigned int);
+extern void ppc4xx_free_dma_handle(sgl_handle_t);
+extern int ppc4xx_get_dma_status(void);
+extern void ppc4xx_set_src_addr(int dmanr, phys_addr_t src_addr);
+extern void ppc4xx_set_dst_addr(int dmanr, phys_addr_t dst_addr);
+extern void ppc4xx_enable_dma(unsigned int dmanr);
+extern void ppc4xx_disable_dma(unsigned int dmanr);
+extern void ppc4xx_set_dma_count(unsigned int dmanr, unsigned int count);
+extern int ppc4xx_get_dma_residue(unsigned int dmanr);
+extern void ppc4xx_set_dma_addr2(unsigned int dmanr, phys_addr_t src_dma_addr,
+				 phys_addr_t dst_dma_addr);
+extern int ppc4xx_enable_dma_interrupt(unsigned int dmanr);
+extern int ppc4xx_disable_dma_interrupt(unsigned int dmanr);
+extern int ppc4xx_clr_dma_status(unsigned int dmanr);
+extern int ppc4xx_map_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan);
+extern int ppc4xx_disable_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan);
+extern int ppc4xx_set_dma_mode(unsigned int dmanr, unsigned int mode);
+
+/* These are in kernel/dma.c: */
+
+/* reserve a DMA channel */
+extern int request_dma(unsigned int dmanr, const char *device_id);
+/* release it again */
+extern void free_dma(unsigned int dmanr);
+#endif
+#endif				/* __KERNEL__ */
diff -p -purN linux-2.5/include/asm-ppc/reg.h linuxppc-2.5/include/asm-ppc/reg.h
--- linux-2.5/include/asm-ppc/reg.h	2003-10-11 16:12:15.000000000 +0200
+++ linuxppc-2.5/include/asm-ppc/reg.h	2003-10-14 13:33:50.000000000 +0200
@@ -86,6 +86,10 @@
 /* Special Purpose Registers (SPRNs)*/
 #define SPRN_CTR	0x009	/* Count Register */
 #define SPRN_DABR	0x3F5	/* Data Address Breakpoint Register */
+#if !defined(SPRN_DAC1) && !defined(SPRN_DAC2)
+#define SPRN_DAC1	0x3F6	/* Data Address Compare 1 */
+#define SPRN_DAC2	0x3F7	/* Data Address Compare 2 */
+#endif
 #define SPRN_DAR	0x013	/* Data Address Register */
 #define SPRN_TBRL	0x10C	/* Time Base Read Lower Register (user, R/O) */
 #define SPRN_TBRU	0x10D	/* Time Base Read Upper Register (user, R/O) */
@@ -290,6 +294,8 @@
 #define SPRN_SPRG7	0x117	/* Special Purpose Register General 7 */
 #define SPRN_SRR0	0x01A	/* Save/Restore Register 0 */
 #define SPRN_SRR1	0x01B	/* Save/Restore Register 1 */
+#define SPRN_SRR2	0x3DE	/* Save/Restore Register 2 */
+#define SPRN_SRR3	0x3DF	/* Save/Restore Register 3 */
 #define SPRN_THRM1	0x3FC		/* Thermal Management Register 1 */
 /* these bits were defined in inverted endian sense originally, ugh, confusing */
 #define THRM1_TIN	(1 << 31)
diff -p -purN linux-2.5/include/asm-ppc/serial.h linuxppc-2.5/include/asm-ppc/serial.h
--- linux-2.5/include/asm-ppc/serial.h	2003-09-15 22:59:05.000000000 +0200
+++ linuxppc-2.5/include/asm-ppc/serial.h	2003-09-27 12:58:50.000000000 +0200
@@ -20,6 +20,8 @@
 #include <platforms/mcpn765_serial.h>
 #elif defined(CONFIG_MVME5100)
 #include <platforms/mvme5100_serial.h>
+#elif defined(CONFIG_PAL4)
+#include <platforms/pal4_serial.h>
 #elif defined(CONFIG_PRPMC750)
 #include <platforms/prpmc750_serial.h>
 #elif defined(CONFIG_PRPMC800)
diff -p -purN linux-2.5/include/linux/ibm_gpio.h linuxppc-2.5/include/linux/ibm_gpio.h
--- linux-2.5/include/linux/ibm_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linuxppc-2.5/include/linux/ibm_gpio.h	2003-07-22 00:46:47.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * FILE NAME ibm_ocp_gpio.h
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Generic gpio.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __IBM_OCP_GPIO_H
+#define __IBM_OCP_GPIO_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+typedef struct gpio_regs {
+	u32 or;
+	u32 tcr;
+	u32 pad[4];
+	u32 odr;
+	u32 ir;
+} gpio_t;
+
+#define IBMGPIO_IOCTL_BASE	'Z'
+
+struct ibm_gpio_ioctl_data {
+	__u32 device;
+	__u32 mask;
+	__u32 data;
+};
+
+#define GPIO_MINOR             185
+#define IBMGPIO_IN		_IOWR(IBMGPIO_IOCTL_BASE, 0, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_OUT		_IOW (IBMGPIO_IOCTL_BASE, 1, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_OPEN_DRAIN	_IOW (IBMGPIO_IOCTL_BASE, 2, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_TRISTATE	_IOW (IBMGPIO_IOCTL_BASE, 3, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_CFG		_IOW (IBMGPIO_IOCTL_BASE, 4, struct ibm_gpio_ioctl_data)
+
+#endif
diff -p -purN linux-2.5/include/linux/pci_ids.h linuxppc-2.5/include/linux/pci_ids.h
--- linux-2.5/include/linux/pci_ids.h	2003-09-02 00:53:57.000000000 +0200
+++ linuxppc-2.5/include/linux/pci_ids.h	2003-09-03 01:11:11.000000000 +0200
@@ -702,6 +702,7 @@
 #define PCI_DEVICE_ID_TI_1410		0xac50
 #define PCI_DEVICE_ID_TI_1420		0xac51
 #define PCI_DEVICE_ID_TI_1520		0xac55
+#define PCI_DEVICE_ID_TI_1510		0xac56
 
 #define PCI_VENDOR_ID_SONY		0x104d
 #define PCI_DEVICE_ID_SONY_CXD3222	0x8039
diff -p -purN linux-2.5/include/linux/pm.h linuxppc-2.5/include/linux/pm.h
--- linux-2.5/include/linux/pm.h	2003-08-21 20:47:27.000000000 +0200
+++ linuxppc-2.5/include/linux/pm.h	2003-08-22 13:00:02.000000000 +0200
@@ -63,6 +63,7 @@ enum
 	PM_SCSI_DEV,	    /* SCSI device */
 	PM_ISA_DEV,	    /* ISA device */
 	PM_MTD_DEV,	    /* Memory Technology Device */
+	PM_OCP_DEV,	    /* On Chip Device */
 };
 
 typedef int pm_dev_t;
diff -p -purN linux-2.5/include/linux/timer.h linuxppc-2.5/include/linux/timer.h
--- linux-2.5/include/linux/timer.h	2003-08-15 03:16:51.000000000 +0200
+++ linuxppc-2.5/include/linux/timer.h	2003-08-18 06:12:28.000000000 +0200
@@ -2,6 +2,7 @@
 #define _LINUX_TIMER_H
 
 #include <linux/config.h>
+#include <linux/stddef.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 
diff -p -purN linux-2.5/include/video/radeon.h linuxppc-2.5/include/video/radeon.h
--- linux-2.5/include/video/radeon.h	2002-12-28 23:39:38.000000000 +0100
+++ linuxppc-2.5/include/video/radeon.h	2003-03-28 15:28:27.000000000 +0100
@@ -365,6 +365,8 @@
 #define DSTCACHE_CTLSTAT                       0x1714  
 #define DEFAULT_PITCH_OFFSET                   0x16E0  
 #define DEFAULT_SC_BOTTOM_RIGHT                0x16E8  
+#define SRC_PITCH_OFFSET                       0x1428
+#define DST_PITCH_OFFSET                       0x142C
 #define DP_GUI_MASTER_CNTL                     0x146C  
 #define SC_TOP_LEFT                            0x16EC  
 #define SC_BOTTOM_RIGHT                        0x16F0  
@@ -373,6 +375,8 @@
 #define RB2D_DSTCACHE_CTLSTAT		       0x342C
 #define LVDS_GEN_CNTL			       0x02d0
 #define LVDS_PLL_CNTL			       0x02d4
+#define FP2_GEN_CNTL                           0x0288
+#define TMDS_CNTL                              0x0294
 #define TMDS_CRC			       0x02a0
 #define TMDS_TRANSMITTER_CNTL		       0x02a4
 
@@ -484,6 +488,7 @@
 #define CRTC_DBL_SCAN_EN                           0x00000001
 #define CRTC_CUR_EN                                0x00010000
 #define CRTC_INTERLACE_EN			   (1 << 1)
+#define CRTC_BYPASS_LUT_EN     			   (1 << 14)
 #define CRTC_EXT_DISP_EN      			   (1 << 24)
 #define CRTC_EN					   (1 << 25)
 #define CRTC_DISP_REQ_EN_B                         (1 << 26)
@@ -560,7 +565,7 @@
 #define TMDS_PLL_EN				   (1 << 0)
 #define TMDS_PLLRST				   (1 << 1)
 #define TMDS_RAN_PAT_RST			   (1 << 7)
-#define ICHCSEL					   (1 << 28)
+#define TMDS_ICHCSEL				   (1 << 28)
 
 /* FP_HORZ_STRETCH bit constants */
 #define HORZ_STRETCH_RATIO_MASK			   0xffff
@@ -600,6 +605,7 @@
 
 /* DAC_CNTL2 bit constants */   
 #define DAC2_CMP_EN                                (1 << 7)
+#define DAC2_PALETTE_ACCESS_CNTL                   (1 << 5)
 
 /* GEN_RESET_CNTL bit constants */
 #define SOFT_RESET_GUI                             0x00000001
@@ -872,5 +878,994 @@
 
 #define GUI_ACTIVE			0x80000000
 
+
+#define MC_IND_INDEX                           0x01F8
+#define MC_IND_DATA                            0x01FC
+#define MEM_REFRESH_CNTL                       0x0178
+
+// CLK_PIN_CNTL
+#define CLK_PIN_CNTL__OSC_EN_MASK                          0x00000001L
+#define CLK_PIN_CNTL__OSC_EN                               0x00000001L
+#define CLK_PIN_CNTL__XTL_LOW_GAIN_MASK                    0x00000004L
+#define CLK_PIN_CNTL__XTL_LOW_GAIN                         0x00000004L
+#define CLK_PIN_CNTL__DONT_USE_XTALIN_MASK                 0x00000010L
+#define CLK_PIN_CNTL__DONT_USE_XTALIN                      0x00000010L
+#define CLK_PIN_CNTL__SLOW_CLOCK_SOURCE_MASK               0x00000020L
+#define CLK_PIN_CNTL__SLOW_CLOCK_SOURCE                    0x00000020L
+#define CLK_PIN_CNTL__CG_CLK_TO_OUTPIN_MASK                0x00000800L
+#define CLK_PIN_CNTL__CG_CLK_TO_OUTPIN                     0x00000800L
+#define CLK_PIN_CNTL__CG_COUNT_UP_TO_OUTPIN_MASK           0x00001000L
+#define CLK_PIN_CNTL__CG_COUNT_UP_TO_OUTPIN                0x00001000L
+#define CLK_PIN_CNTL__ACCESS_REGS_IN_SUSPEND_MASK          0x00002000L
+#define CLK_PIN_CNTL__ACCESS_REGS_IN_SUSPEND               0x00002000L
+#define CLK_PIN_CNTL__CG_SPARE_MASK                        0x00004000L
+#define CLK_PIN_CNTL__CG_SPARE                             0x00004000L
+#define CLK_PIN_CNTL__SCLK_DYN_START_CNTL_MASK             0x00008000L
+#define CLK_PIN_CNTL__SCLK_DYN_START_CNTL                  0x00008000L
+#define CLK_PIN_CNTL__CP_CLK_RUNNING_MASK                  0x00010000L
+#define CLK_PIN_CNTL__CP_CLK_RUNNING                       0x00010000L
+#define CLK_PIN_CNTL__CG_SPARE_RD_MASK                     0x00060000L
+#define CLK_PIN_CNTL__XTALIN_ALWAYS_ONb_MASK               0x00080000L
+#define CLK_PIN_CNTL__XTALIN_ALWAYS_ONb                    0x00080000L
+#define CLK_PIN_CNTL__PWRSEQ_DELAY_MASK                    0xff000000L
+
+// CLK_PWRMGT_CNTL_M6
+#define	CLK_PWRMGT_CNTL_M6__MPLL_PWRMGT_OFF__SHIFT         0x00000000
+#define	CLK_PWRMGT_CNTL_M6__SPLL_PWRMGT_OFF__SHIFT         0x00000001
+#define	CLK_PWRMGT_CNTL_M6__PPLL_PWRMGT_OFF__SHIFT         0x00000002
+#define	CLK_PWRMGT_CNTL_M6__P2PLL_PWRMGT_OFF__SHIFT        0x00000003
+#define	CLK_PWRMGT_CNTL_M6__MCLK_TURNOFF__SHIFT            0x00000004
+#define	CLK_PWRMGT_CNTL_M6__SCLK_TURNOFF__SHIFT            0x00000005
+#define	CLK_PWRMGT_CNTL_M6__PCLK_TURNOFF__SHIFT            0x00000006
+#define	CLK_PWRMGT_CNTL_M6__P2CLK_TURNOFF__SHIFT           0x00000007
+#define	CLK_PWRMGT_CNTL_M6__MC_CH_MODE__SHIFT              0x00000008
+#define	CLK_PWRMGT_CNTL_M6__TEST_MODE__SHIFT               0x00000009
+#define	CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN__SHIFT          0x0000000a
+#define	CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE__SHIFT      0x0000000c
+#define	CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT__SHIFT         0x0000000d
+#define	CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT__SHIFT       0x0000000f
+#define	CLK_PWRMGT_CNTL_M6__MC_BUSY__SHIFT                 0x00000010
+#define	CLK_PWRMGT_CNTL_M6__MC_INT_CNTL__SHIFT             0x00000011
+#define	CLK_PWRMGT_CNTL_M6__MC_SWITCH__SHIFT               0x00000012
+#define	CLK_PWRMGT_CNTL_M6__DLL_READY__SHIFT               0x00000013
+#define	CLK_PWRMGT_CNTL_M6__DISP_PM__SHIFT                 0x00000014
+#define	CLK_PWRMGT_CNTL_M6__DYN_STOP_MODE__SHIFT           0x00000015
+#define	CLK_PWRMGT_CNTL_M6__CG_NO1_DEBUG__SHIFT            0x00000018
+#define	CLK_PWRMGT_CNTL_M6__TVPLL_PWRMGT_OFF__SHIFT        0x0000001e
+#define	CLK_PWRMGT_CNTL_M6__TVCLK_TURNOFF__SHIFT           0x0000001f
+
+// P2PLL_CNTL
+#define P2PLL_CNTL__P2PLL_RESET_MASK                       0x00000001L
+#define P2PLL_CNTL__P2PLL_RESET                            0x00000001L
+#define P2PLL_CNTL__P2PLL_SLEEP_MASK                       0x00000002L
+#define P2PLL_CNTL__P2PLL_SLEEP                            0x00000002L
+#define P2PLL_CNTL__P2PLL_TST_EN_MASK                      0x00000004L
+#define P2PLL_CNTL__P2PLL_TST_EN                           0x00000004L
+#define P2PLL_CNTL__P2PLL_REFCLK_SEL_MASK                  0x00000010L
+#define P2PLL_CNTL__P2PLL_REFCLK_SEL                       0x00000010L
+#define P2PLL_CNTL__P2PLL_FBCLK_SEL_MASK                   0x00000020L
+#define P2PLL_CNTL__P2PLL_FBCLK_SEL                        0x00000020L
+#define P2PLL_CNTL__P2PLL_TCPOFF_MASK                      0x00000040L
+#define P2PLL_CNTL__P2PLL_TCPOFF                           0x00000040L
+#define P2PLL_CNTL__P2PLL_TVCOMAX_MASK                     0x00000080L
+#define P2PLL_CNTL__P2PLL_TVCOMAX                          0x00000080L
+#define P2PLL_CNTL__P2PLL_PCP_MASK                         0x00000700L
+#define P2PLL_CNTL__P2PLL_PVG_MASK                         0x00003800L
+#define P2PLL_CNTL__P2PLL_PDC_MASK                         0x0000c000L
+#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_EN_MASK            0x00010000L
+#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_EN                 0x00010000L
+#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_SYNC_MASK          0x00040000L
+#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_SYNC               0x00040000L
+#define P2PLL_CNTL__P2PLL_DISABLE_AUTO_RESET_MASK          0x00080000L
+#define P2PLL_CNTL__P2PLL_DISABLE_AUTO_RESET               0x00080000L
+
+// PIXCLKS_CNTL
+#define	PIXCLKS_CNTL__PIX2CLK_SRC_SEL__SHIFT               0x00000000
+#define	PIXCLKS_CNTL__PIX2CLK_INVERT__SHIFT                0x00000004
+#define	PIXCLKS_CNTL__PIX2CLK_SRC_INVERT__SHIFT            0x00000005
+#define	PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb__SHIFT            0x00000006
+#define	PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb__SHIFT        0x00000007
+#define	PIXCLKS_CNTL__PIXCLK_TV_SRC_SEL__SHIFT             0x00000008
+#define	PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb__SHIFT       0x0000000b
+#define	PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb__SHIFT          0x0000000c
+#define	PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb__SHIFT    0x0000000d
+#define	PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb__SHIFT        0x0000000e
+#define	PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb__SHIFT        0x0000000f
+
+
+// PIXCLKS_CNTL
+#define PIXCLKS_CNTL__PIX2CLK_SRC_SEL_MASK                 0x00000003L
+#define PIXCLKS_CNTL__PIX2CLK_INVERT_MASK                  0x00000010L
+#define PIXCLKS_CNTL__PIX2CLK_INVERT                       0x00000010L
+#define PIXCLKS_CNTL__PIX2CLK_SRC_INVERT_MASK              0x00000020L
+#define PIXCLKS_CNTL__PIX2CLK_SRC_INVERT                   0x00000020L
+#define PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb_MASK              0x00000040L
+#define PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb                   0x00000040L
+#define PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb_MASK          0x00000080L
+#define PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb               0x00000080L
+#define PIXCLKS_CNTL__PIXCLK_TV_SRC_SEL_MASK               0x00000100L
+#define PIXCLKS_CNTL__PIXCLK_TV_SRC_SEL                    0x00000100L
+#define PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb_MASK         0x00000800L
+#define PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb              0x00000800L
+#define PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb_MASK            0x00001000L
+#define PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb                 0x00001000L
+#define PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb_MASK      0x00002000L
+#define PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb           0x00002000L
+#define PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb_MASK          0x00004000L
+#define PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb               0x00004000L
+#define PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb_MASK          0x00008000L
+#define PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb               0x00008000L
+
+
+// P2PLL_DIV_0
+#define P2PLL_DIV_0__P2PLL_FB_DIV_MASK                     0x000007ffL
+#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_W_MASK            0x00008000L
+#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_W                 0x00008000L
+#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_R_MASK            0x00008000L
+#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_R                 0x00008000L
+#define P2PLL_DIV_0__P2PLL_POST_DIV_MASK                   0x00070000L
+
+// SCLK_CNTL_M6
+#define SCLK_CNTL_M6__SCLK_SRC_SEL_MASK                    0x00000007L
+#define SCLK_CNTL_M6__CP_MAX_DYN_STOP_LAT_MASK             0x00000008L
+#define SCLK_CNTL_M6__CP_MAX_DYN_STOP_LAT                  0x00000008L
+#define SCLK_CNTL_M6__HDP_MAX_DYN_STOP_LAT_MASK            0x00000010L
+#define SCLK_CNTL_M6__HDP_MAX_DYN_STOP_LAT                 0x00000010L
+#define SCLK_CNTL_M6__TV_MAX_DYN_STOP_LAT_MASK             0x00000020L
+#define SCLK_CNTL_M6__TV_MAX_DYN_STOP_LAT                  0x00000020L
+#define SCLK_CNTL_M6__E2_MAX_DYN_STOP_LAT_MASK             0x00000040L
+#define SCLK_CNTL_M6__E2_MAX_DYN_STOP_LAT                  0x00000040L
+#define SCLK_CNTL_M6__SE_MAX_DYN_STOP_LAT_MASK             0x00000080L
+#define SCLK_CNTL_M6__SE_MAX_DYN_STOP_LAT                  0x00000080L
+#define SCLK_CNTL_M6__IDCT_MAX_DYN_STOP_LAT_MASK           0x00000100L
+#define SCLK_CNTL_M6__IDCT_MAX_DYN_STOP_LAT                0x00000100L
+#define SCLK_CNTL_M6__VIP_MAX_DYN_STOP_LAT_MASK            0x00000200L
+#define SCLK_CNTL_M6__VIP_MAX_DYN_STOP_LAT                 0x00000200L
+#define SCLK_CNTL_M6__RE_MAX_DYN_STOP_LAT_MASK             0x00000400L
+#define SCLK_CNTL_M6__RE_MAX_DYN_STOP_LAT                  0x00000400L
+#define SCLK_CNTL_M6__PB_MAX_DYN_STOP_LAT_MASK             0x00000800L
+#define SCLK_CNTL_M6__PB_MAX_DYN_STOP_LAT                  0x00000800L
+#define SCLK_CNTL_M6__TAM_MAX_DYN_STOP_LAT_MASK            0x00001000L
+#define SCLK_CNTL_M6__TAM_MAX_DYN_STOP_LAT                 0x00001000L
+#define SCLK_CNTL_M6__TDM_MAX_DYN_STOP_LAT_MASK            0x00002000L
+#define SCLK_CNTL_M6__TDM_MAX_DYN_STOP_LAT                 0x00002000L
+#define SCLK_CNTL_M6__RB_MAX_DYN_STOP_LAT_MASK             0x00004000L
+#define SCLK_CNTL_M6__RB_MAX_DYN_STOP_LAT                  0x00004000L
+#define SCLK_CNTL_M6__FORCE_DISP2_MASK                     0x00008000L
+#define SCLK_CNTL_M6__FORCE_DISP2                          0x00008000L
+#define SCLK_CNTL_M6__FORCE_CP_MASK                        0x00010000L
+#define SCLK_CNTL_M6__FORCE_CP                             0x00010000L
+#define SCLK_CNTL_M6__FORCE_HDP_MASK                       0x00020000L
+#define SCLK_CNTL_M6__FORCE_HDP                            0x00020000L
+#define SCLK_CNTL_M6__FORCE_DISP1_MASK                     0x00040000L
+#define SCLK_CNTL_M6__FORCE_DISP1                          0x00040000L
+#define SCLK_CNTL_M6__FORCE_TOP_MASK                       0x00080000L
+#define SCLK_CNTL_M6__FORCE_TOP                            0x00080000L
+#define SCLK_CNTL_M6__FORCE_E2_MASK                        0x00100000L
+#define SCLK_CNTL_M6__FORCE_E2                             0x00100000L
+#define SCLK_CNTL_M6__FORCE_SE_MASK                        0x00200000L
+#define SCLK_CNTL_M6__FORCE_SE                             0x00200000L
+#define SCLK_CNTL_M6__FORCE_IDCT_MASK                      0x00400000L
+#define SCLK_CNTL_M6__FORCE_IDCT                           0x00400000L
+#define SCLK_CNTL_M6__FORCE_VIP_MASK                       0x00800000L
+#define SCLK_CNTL_M6__FORCE_VIP                            0x00800000L
+#define SCLK_CNTL_M6__FORCE_RE_MASK                        0x01000000L
+#define SCLK_CNTL_M6__FORCE_RE                             0x01000000L
+#define SCLK_CNTL_M6__FORCE_PB_MASK                        0x02000000L
+#define SCLK_CNTL_M6__FORCE_PB                             0x02000000L
+#define SCLK_CNTL_M6__FORCE_TAM_MASK                       0x04000000L
+#define SCLK_CNTL_M6__FORCE_TAM                            0x04000000L
+#define SCLK_CNTL_M6__FORCE_TDM_MASK                       0x08000000L
+#define SCLK_CNTL_M6__FORCE_TDM                            0x08000000L
+#define SCLK_CNTL_M6__FORCE_RB_MASK                        0x10000000L
+#define SCLK_CNTL_M6__FORCE_RB                             0x10000000L
+#define SCLK_CNTL_M6__FORCE_TV_SCLK_MASK                   0x20000000L
+#define SCLK_CNTL_M6__FORCE_TV_SCLK                        0x20000000L
+#define SCLK_CNTL_M6__FORCE_SUBPIC_MASK                    0x40000000L
+#define SCLK_CNTL_M6__FORCE_SUBPIC                         0x40000000L
+#define SCLK_CNTL_M6__FORCE_OV0_MASK                       0x80000000L
+#define SCLK_CNTL_M6__FORCE_OV0                            0x80000000L
+
+// SCLK_MORE_CNTL
+#define SCLK_MORE_CNTL__DISPREGS_MAX_DYN_STOP_LAT_MASK     0x00000001L
+#define SCLK_MORE_CNTL__DISPREGS_MAX_DYN_STOP_LAT          0x00000001L
+#define SCLK_MORE_CNTL__MC_GUI_MAX_DYN_STOP_LAT_MASK       0x00000002L
+#define SCLK_MORE_CNTL__MC_GUI_MAX_DYN_STOP_LAT            0x00000002L
+#define SCLK_MORE_CNTL__MC_HOST_MAX_DYN_STOP_LAT_MASK      0x00000004L
+#define SCLK_MORE_CNTL__MC_HOST_MAX_DYN_STOP_LAT           0x00000004L
+#define SCLK_MORE_CNTL__FORCE_DISPREGS_MASK                0x00000100L
+#define SCLK_MORE_CNTL__FORCE_DISPREGS                     0x00000100L
+#define SCLK_MORE_CNTL__FORCE_MC_GUI_MASK                  0x00000200L
+#define SCLK_MORE_CNTL__FORCE_MC_GUI                       0x00000200L
+#define SCLK_MORE_CNTL__FORCE_MC_HOST_MASK                 0x00000400L
+#define SCLK_MORE_CNTL__FORCE_MC_HOST                      0x00000400L
+#define SCLK_MORE_CNTL__STOP_SCLK_EN_MASK                  0x00001000L
+#define SCLK_MORE_CNTL__STOP_SCLK_EN                       0x00001000L
+#define SCLK_MORE_CNTL__STOP_SCLK_A_MASK                   0x00002000L
+#define SCLK_MORE_CNTL__STOP_SCLK_A                        0x00002000L
+#define SCLK_MORE_CNTL__STOP_SCLK_B_MASK                   0x00004000L
+#define SCLK_MORE_CNTL__STOP_SCLK_B                        0x00004000L
+#define SCLK_MORE_CNTL__STOP_SCLK_C_MASK                   0x00008000L
+#define SCLK_MORE_CNTL__STOP_SCLK_C                        0x00008000L
+#define SCLK_MORE_CNTL__HALF_SPEED_SCLK_MASK               0x00010000L
+#define SCLK_MORE_CNTL__HALF_SPEED_SCLK                    0x00010000L
+#define SCLK_MORE_CNTL__IO_CG_VOLTAGE_DROP_MASK            0x00020000L
+#define SCLK_MORE_CNTL__IO_CG_VOLTAGE_DROP                 0x00020000L
+#define SCLK_MORE_CNTL__TVFB_SOFT_RESET_MASK               0x00040000L
+#define SCLK_MORE_CNTL__TVFB_SOFT_RESET                    0x00040000L
+#define SCLK_MORE_CNTL__VOLTAGE_DROP_SYNC_MASK             0x00080000L
+#define SCLK_MORE_CNTL__VOLTAGE_DROP_SYNC                  0x00080000L
+#define SCLK_MORE_CNTL__VOLTAGE_DELAY_SEL_MASK             0x00300000L
+#define SCLK_MORE_CNTL__IDLE_DELAY_HALF_SCLK_MASK          0x00400000L
+#define SCLK_MORE_CNTL__IDLE_DELAY_HALF_SCLK               0x00400000L
+#define SCLK_MORE_CNTL__AGP_BUSY_HALF_SCLK_MASK            0x00800000L
+#define SCLK_MORE_CNTL__AGP_BUSY_HALF_SCLK                 0x00800000L
+#define SCLK_MORE_CNTL__CG_SPARE_RD_C_MASK                 0xff000000L
+
+// MCLK_CNTL_M6
+#define MCLK_CNTL_M6__MCLKA_SRC_SEL_MASK                   0x00000007L
+#define MCLK_CNTL_M6__YCLKA_SRC_SEL_MASK                   0x00000070L
+#define MCLK_CNTL_M6__MCLKB_SRC_SEL_MASK                   0x00000700L
+#define MCLK_CNTL_M6__YCLKB_SRC_SEL_MASK                   0x00007000L
+#define MCLK_CNTL_M6__FORCE_MCLKA_MASK                     0x00010000L
+#define MCLK_CNTL_M6__FORCE_MCLKA                          0x00010000L
+#define MCLK_CNTL_M6__FORCE_MCLKB_MASK                     0x00020000L
+#define MCLK_CNTL_M6__FORCE_MCLKB                          0x00020000L
+#define MCLK_CNTL_M6__FORCE_YCLKA_MASK                     0x00040000L
+#define MCLK_CNTL_M6__FORCE_YCLKA                          0x00040000L
+#define MCLK_CNTL_M6__FORCE_YCLKB_MASK                     0x00080000L
+#define MCLK_CNTL_M6__FORCE_YCLKB                          0x00080000L
+#define MCLK_CNTL_M6__FORCE_MC_MASK                        0x00100000L
+#define MCLK_CNTL_M6__FORCE_MC                             0x00100000L
+#define MCLK_CNTL_M6__FORCE_AIC_MASK                       0x00200000L
+#define MCLK_CNTL_M6__FORCE_AIC                            0x00200000L
+#define MCLK_CNTL_M6__MRDCKA0_SOUTSEL_MASK                 0x03000000L
+#define MCLK_CNTL_M6__MRDCKA1_SOUTSEL_MASK                 0x0c000000L
+#define MCLK_CNTL_M6__MRDCKB0_SOUTSEL_MASK                 0x30000000L
+#define MCLK_CNTL_M6__MRDCKB1_SOUTSEL_MASK                 0xc0000000L
+
+// MCLK_MISC
+#define MCLK_MISC__SCLK_SOURCED_FROM_MPLL_SEL_MASK         0x00000003L
+#define MCLK_MISC__MCLK_FROM_SPLL_DIV_SEL_MASK             0x00000004L
+#define MCLK_MISC__MCLK_FROM_SPLL_DIV_SEL                  0x00000004L
+#define MCLK_MISC__ENABLE_SCLK_FROM_MPLL_MASK              0x00000008L
+#define MCLK_MISC__ENABLE_SCLK_FROM_MPLL                   0x00000008L
+#define MCLK_MISC__MPLL_MODEA_MODEC_HW_SEL_EN_MASK         0x00000010L
+#define MCLK_MISC__MPLL_MODEA_MODEC_HW_SEL_EN              0x00000010L
+#define MCLK_MISC__DLL_READY_LAT_MASK                      0x00000100L
+#define MCLK_MISC__DLL_READY_LAT                           0x00000100L
+#define MCLK_MISC__MC_MCLK_MAX_DYN_STOP_LAT_MASK           0x00001000L
+#define MCLK_MISC__MC_MCLK_MAX_DYN_STOP_LAT                0x00001000L
+#define MCLK_MISC__IO_MCLK_MAX_DYN_STOP_LAT_MASK           0x00002000L
+#define MCLK_MISC__IO_MCLK_MAX_DYN_STOP_LAT                0x00002000L
+#define MCLK_MISC__MC_MCLK_DYN_ENABLE_MASK                 0x00004000L
+#define MCLK_MISC__MC_MCLK_DYN_ENABLE                      0x00004000L
+#define MCLK_MISC__IO_MCLK_DYN_ENABLE_MASK                 0x00008000L
+#define MCLK_MISC__IO_MCLK_DYN_ENABLE                      0x00008000L
+#define MCLK_MISC__CGM_CLK_TO_OUTPIN_MASK                  0x00010000L
+#define MCLK_MISC__CGM_CLK_TO_OUTPIN                       0x00010000L
+#define MCLK_MISC__CLK_OR_COUNT_SEL_MASK                   0x00020000L
+#define MCLK_MISC__CLK_OR_COUNT_SEL                        0x00020000L
+#define MCLK_MISC__EN_MCLK_TRISTATE_IN_SUSPEND_MASK        0x00040000L
+#define MCLK_MISC__EN_MCLK_TRISTATE_IN_SUSPEND             0x00040000L
+#define MCLK_MISC__CGM_SPARE_RD_MASK                       0x00300000L
+#define MCLK_MISC__CGM_SPARE_A_RD_MASK                     0x00c00000L
+#define MCLK_MISC__TCLK_TO_YCLKB_EN_MASK                   0x01000000L
+#define MCLK_MISC__TCLK_TO_YCLKB_EN                        0x01000000L
+#define MCLK_MISC__CGM_SPARE_A_MASK                        0x0e000000L
+
+// VCLK_ECP_CNTL
+#define VCLK_ECP_CNTL__VCLK_SRC_SEL_MASK                   0x00000003L
+#define VCLK_ECP_CNTL__VCLK_INVERT_MASK                    0x00000010L
+#define VCLK_ECP_CNTL__VCLK_INVERT                         0x00000010L
+#define VCLK_ECP_CNTL__PIXCLK_SRC_INVERT_MASK              0x00000020L
+#define VCLK_ECP_CNTL__PIXCLK_SRC_INVERT                   0x00000020L
+#define VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb_MASK              0x00000040L
+#define VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb                   0x00000040L
+#define VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb_MASK          0x00000080L
+#define VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb               0x00000080L
+#define VCLK_ECP_CNTL__ECP_DIV_MASK                        0x00000300L
+#define VCLK_ECP_CNTL__ECP_FORCE_ON_MASK                   0x00040000L
+#define VCLK_ECP_CNTL__ECP_FORCE_ON                        0x00040000L
+#define VCLK_ECP_CNTL__SUBCLK_FORCE_ON_MASK                0x00080000L
+#define VCLK_ECP_CNTL__SUBCLK_FORCE_ON                     0x00080000L
+
+// PLL_PWRMGT_CNTL
+#define PLL_PWRMGT_CNTL__MPLL_TURNOFF_MASK                 0x00000001L
+#define PLL_PWRMGT_CNTL__MPLL_TURNOFF                      0x00000001L
+#define PLL_PWRMGT_CNTL__SPLL_TURNOFF_MASK                 0x00000002L
+#define PLL_PWRMGT_CNTL__SPLL_TURNOFF                      0x00000002L
+#define PLL_PWRMGT_CNTL__PPLL_TURNOFF_MASK                 0x00000004L
+#define PLL_PWRMGT_CNTL__PPLL_TURNOFF                      0x00000004L
+#define PLL_PWRMGT_CNTL__P2PLL_TURNOFF_MASK                0x00000008L
+#define PLL_PWRMGT_CNTL__P2PLL_TURNOFF                     0x00000008L
+#define PLL_PWRMGT_CNTL__TVPLL_TURNOFF_MASK                0x00000010L
+#define PLL_PWRMGT_CNTL__TVPLL_TURNOFF                     0x00000010L
+#define PLL_PWRMGT_CNTL__AGPCLK_DYN_STOP_LAT_MASK          0x000001e0L
+#define PLL_PWRMGT_CNTL__APM_POWER_STATE_MASK              0x00000600L
+#define PLL_PWRMGT_CNTL__APM_PWRSTATE_RD_MASK              0x00001800L
+#define PLL_PWRMGT_CNTL__PM_MODE_SEL_MASK                  0x00002000L
+#define PLL_PWRMGT_CNTL__PM_MODE_SEL                       0x00002000L
+#define PLL_PWRMGT_CNTL__EN_PWRSEQ_DONE_COND_MASK          0x00004000L
+#define PLL_PWRMGT_CNTL__EN_PWRSEQ_DONE_COND               0x00004000L
+#define PLL_PWRMGT_CNTL__EN_DISP_PARKED_COND_MASK          0x00008000L
+#define PLL_PWRMGT_CNTL__EN_DISP_PARKED_COND               0x00008000L
+#define PLL_PWRMGT_CNTL__MOBILE_SU_MASK                    0x00010000L
+#define PLL_PWRMGT_CNTL__MOBILE_SU                         0x00010000L
+#define PLL_PWRMGT_CNTL__SU_SCLK_USE_BCLK_MASK             0x00020000L
+#define PLL_PWRMGT_CNTL__SU_SCLK_USE_BCLK                  0x00020000L
+#define PLL_PWRMGT_CNTL__SU_MCLK_USE_BCLK_MASK             0x00040000L
+#define PLL_PWRMGT_CNTL__SU_MCLK_USE_BCLK                  0x00040000L
+#define PLL_PWRMGT_CNTL__SU_SUSTAIN_DISABLE_MASK           0x00080000L
+#define PLL_PWRMGT_CNTL__SU_SUSTAIN_DISABLE                0x00080000L
+#define PLL_PWRMGT_CNTL__TCL_BYPASS_DISABLE_MASK           0x00100000L
+#define PLL_PWRMGT_CNTL__TCL_BYPASS_DISABLE                0x00100000L
+#define PLL_PWRMGT_CNTL__TCL_CLOCK_ACTIVE_RD_MASK          0x00200000L
+#define PLL_PWRMGT_CNTL__TCL_CLOCK_ACTIVE_RD               0x00200000L
+#define PLL_PWRMGT_CNTL__CG_NO2_DEBUG_MASK                 0xff000000L
+
+// CLK_PWRMGT_CNTL_M6
+#define CLK_PWRMGT_CNTL_M6__MPLL_PWRMGT_OFF_MASK           0x00000001L
+#define CLK_PWRMGT_CNTL_M6__MPLL_PWRMGT_OFF                0x00000001L
+#define CLK_PWRMGT_CNTL_M6__SPLL_PWRMGT_OFF_MASK           0x00000002L
+#define CLK_PWRMGT_CNTL_M6__SPLL_PWRMGT_OFF                0x00000002L
+#define CLK_PWRMGT_CNTL_M6__PPLL_PWRMGT_OFF_MASK           0x00000004L
+#define CLK_PWRMGT_CNTL_M6__PPLL_PWRMGT_OFF                0x00000004L
+#define CLK_PWRMGT_CNTL_M6__P2PLL_PWRMGT_OFF_MASK          0x00000008L
+#define CLK_PWRMGT_CNTL_M6__P2PLL_PWRMGT_OFF               0x00000008L
+#define CLK_PWRMGT_CNTL_M6__MCLK_TURNOFF_MASK              0x00000010L
+#define CLK_PWRMGT_CNTL_M6__MCLK_TURNOFF                   0x00000010L
+#define CLK_PWRMGT_CNTL_M6__SCLK_TURNOFF_MASK              0x00000020L
+#define CLK_PWRMGT_CNTL_M6__SCLK_TURNOFF                   0x00000020L
+#define CLK_PWRMGT_CNTL_M6__PCLK_TURNOFF_MASK              0x00000040L
+#define CLK_PWRMGT_CNTL_M6__PCLK_TURNOFF                   0x00000040L
+#define CLK_PWRMGT_CNTL_M6__P2CLK_TURNOFF_MASK             0x00000080L
+#define CLK_PWRMGT_CNTL_M6__P2CLK_TURNOFF                  0x00000080L
+#define CLK_PWRMGT_CNTL_M6__MC_CH_MODE_MASK                0x00000100L
+#define CLK_PWRMGT_CNTL_M6__MC_CH_MODE                     0x00000100L
+#define CLK_PWRMGT_CNTL_M6__TEST_MODE_MASK                 0x00000200L
+#define CLK_PWRMGT_CNTL_M6__TEST_MODE                      0x00000200L
+#define CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN_MASK            0x00000400L
+#define CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN                 0x00000400L
+#define CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE_MASK        0x00001000L
+#define CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE             0x00001000L
+#define CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT_MASK           0x00006000L
+#define CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT_MASK         0x00008000L
+#define CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT              0x00008000L
+#define CLK_PWRMGT_CNTL_M6__MC_BUSY_MASK                   0x00010000L
+#define CLK_PWRMGT_CNTL_M6__MC_BUSY                        0x00010000L
+#define CLK_PWRMGT_CNTL_M6__MC_INT_CNTL_MASK               0x00020000L
+#define CLK_PWRMGT_CNTL_M6__MC_INT_CNTL                    0x00020000L
+#define CLK_PWRMGT_CNTL_M6__MC_SWITCH_MASK                 0x00040000L
+#define CLK_PWRMGT_CNTL_M6__MC_SWITCH                      0x00040000L
+#define CLK_PWRMGT_CNTL_M6__DLL_READY_MASK                 0x00080000L
+#define CLK_PWRMGT_CNTL_M6__DLL_READY                      0x00080000L
+#define CLK_PWRMGT_CNTL_M6__DISP_PM_MASK                   0x00100000L
+#define CLK_PWRMGT_CNTL_M6__DISP_PM                        0x00100000L
+#define CLK_PWRMGT_CNTL_M6__DYN_STOP_MODE_MASK             0x00e00000L
+#define CLK_PWRMGT_CNTL_M6__CG_NO1_DEBUG_MASK              0x3f000000L
+#define CLK_PWRMGT_CNTL_M6__TVPLL_PWRMGT_OFF_MASK          0x40000000L
+#define CLK_PWRMGT_CNTL_M6__TVPLL_PWRMGT_OFF               0x40000000L
+#define CLK_PWRMGT_CNTL_M6__TVCLK_TURNOFF_MASK             0x80000000L
+#define CLK_PWRMGT_CNTL_M6__TVCLK_TURNOFF                  0x80000000L
+
+// BUS_CNTL1
+#define BUS_CNTL1__PMI_IO_DISABLE_MASK                     0x00000001L
+#define BUS_CNTL1__PMI_IO_DISABLE                          0x00000001L
+#define BUS_CNTL1__PMI_MEM_DISABLE_MASK                    0x00000002L
+#define BUS_CNTL1__PMI_MEM_DISABLE                         0x00000002L
+#define BUS_CNTL1__PMI_BM_DISABLE_MASK                     0x00000004L
+#define BUS_CNTL1__PMI_BM_DISABLE                          0x00000004L
+#define BUS_CNTL1__PMI_INT_DISABLE_MASK                    0x00000008L
+#define BUS_CNTL1__PMI_INT_DISABLE                         0x00000008L
+#define BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE_MASK         0x00000020L
+#define BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE              0x00000020L
+#define BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS_MASK         0x00000100L
+#define BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS              0x00000100L
+#define BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS_MASK         0x00000200L
+#define BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS              0x00000200L
+#define BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS_MASK         0x00000400L
+#define BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS              0x00000400L
+#define BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS_MASK   0x00000800L
+#define BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS        0x00000800L
+#define BUS_CNTL1__MOBILE_PLATFORM_SEL_MASK                0x0c000000L
+#define BUS_CNTL1__SEND_SBA_LATENCY_MASK                   0x70000000L
+#define BUS_CNTL1__AGPCLK_VALID_MASK                       0x80000000L
+#define BUS_CNTL1__AGPCLK_VALID                            0x80000000L
+
+// BUS_CNTL1
+#define	BUS_CNTL1__PMI_IO_DISABLE__SHIFT                   0x00000000
+#define	BUS_CNTL1__PMI_MEM_DISABLE__SHIFT                  0x00000001
+#define	BUS_CNTL1__PMI_BM_DISABLE__SHIFT                   0x00000002
+#define	BUS_CNTL1__PMI_INT_DISABLE__SHIFT                  0x00000003
+#define	BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE__SHIFT       0x00000005
+#define	BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS__SHIFT       0x00000008
+#define	BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS__SHIFT       0x00000009
+#define	BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS__SHIFT       0x0000000a
+#define	BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS__SHIFT 0x0000000b
+#define	BUS_CNTL1__MOBILE_PLATFORM_SEL__SHIFT              0x0000001a
+#define	BUS_CNTL1__SEND_SBA_LATENCY__SHIFT                 0x0000001c
+#define	BUS_CNTL1__AGPCLK_VALID__SHIFT                     0x0000001f
+
+// CRTC_OFFSET_CNTL
+#define CRTC_OFFSET_CNTL__CRTC_TILE_LINE_MASK              0x0000000fL
+#define CRTC_OFFSET_CNTL__CRTC_TILE_LINE_RIGHT_MASK        0x000000f0L
+#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_RIGHT_MASK          0x00004000L
+#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_RIGHT               0x00004000L
+#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_MASK                0x00008000L
+#define CRTC_OFFSET_CNTL__CRTC_TILE_EN                     0x00008000L
+#define CRTC_OFFSET_CNTL__CRTC_OFFSET_FLIP_CNTL_MASK       0x00010000L
+#define CRTC_OFFSET_CNTL__CRTC_OFFSET_FLIP_CNTL            0x00010000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_OFFSET_EN_MASK       0x00020000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_OFFSET_EN            0x00020000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_EN_MASK         0x000c0000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_OUT_EN_MASK     0x00100000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_OUT_EN          0x00100000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_MASK            0x00200000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC                 0x00200000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_LEFT_EN_MASK 0x10000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_LEFT_EN     0x10000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_RIGHT_EN_MASK 0x20000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_RIGHT_EN    0x20000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_MASK        0x40000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET             0x40000000L
+#define CRTC_OFFSET_CNTL__CRTC_OFFSET_LOCK_MASK            0x80000000L
+#define CRTC_OFFSET_CNTL__CRTC_OFFSET_LOCK                 0x80000000L
+
+// CRTC_GEN_CNTL
+#define CRTC_GEN_CNTL__CRTC_DBL_SCAN_EN_MASK               0x00000001L
+#define CRTC_GEN_CNTL__CRTC_DBL_SCAN_EN                    0x00000001L
+#define CRTC_GEN_CNTL__CRTC_INTERLACE_EN_MASK              0x00000002L
+#define CRTC_GEN_CNTL__CRTC_INTERLACE_EN                   0x00000002L
+#define CRTC_GEN_CNTL__CRTC_C_SYNC_EN_MASK                 0x00000010L
+#define CRTC_GEN_CNTL__CRTC_C_SYNC_EN                      0x00000010L
+#define CRTC_GEN_CNTL__CRTC_PIX_WIDTH_MASK                 0x00000f00L
+#define CRTC_GEN_CNTL__CRTC_ICON_EN_MASK                   0x00008000L
+#define CRTC_GEN_CNTL__CRTC_ICON_EN                        0x00008000L
+#define CRTC_GEN_CNTL__CRTC_CUR_EN_MASK                    0x00010000L
+#define CRTC_GEN_CNTL__CRTC_CUR_EN                         0x00010000L
+#define CRTC_GEN_CNTL__CRTC_VSTAT_MODE_MASK                0x00060000L
+#define CRTC_GEN_CNTL__CRTC_CUR_MODE_MASK                  0x00700000L
+#define CRTC_GEN_CNTL__CRTC_EXT_DISP_EN_MASK               0x01000000L
+#define CRTC_GEN_CNTL__CRTC_EXT_DISP_EN                    0x01000000L
+#define CRTC_GEN_CNTL__CRTC_EN_MASK                        0x02000000L
+#define CRTC_GEN_CNTL__CRTC_EN                             0x02000000L
+#define CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B_MASK             0x04000000L
+#define CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B                  0x04000000L
+
+// CRTC2_GEN_CNTL
+#define CRTC2_GEN_CNTL__CRTC2_DBL_SCAN_EN_MASK             0x00000001L
+#define CRTC2_GEN_CNTL__CRTC2_DBL_SCAN_EN                  0x00000001L
+#define CRTC2_GEN_CNTL__CRTC2_INTERLACE_EN_MASK            0x00000002L
+#define CRTC2_GEN_CNTL__CRTC2_INTERLACE_EN                 0x00000002L
+#define CRTC2_GEN_CNTL__CRTC2_SYNC_TRISTATE_MASK           0x00000010L
+#define CRTC2_GEN_CNTL__CRTC2_SYNC_TRISTATE                0x00000010L
+#define CRTC2_GEN_CNTL__CRTC2_HSYNC_TRISTATE_MASK          0x00000020L
+#define CRTC2_GEN_CNTL__CRTC2_HSYNC_TRISTATE               0x00000020L
+#define CRTC2_GEN_CNTL__CRTC2_VSYNC_TRISTATE_MASK          0x00000040L
+#define CRTC2_GEN_CNTL__CRTC2_VSYNC_TRISTATE               0x00000040L
+#define CRTC2_GEN_CNTL__CRT2_ON_MASK                       0x00000080L
+#define CRTC2_GEN_CNTL__CRT2_ON                            0x00000080L
+#define CRTC2_GEN_CNTL__CRTC2_PIX_WIDTH_MASK               0x00000f00L
+#define CRTC2_GEN_CNTL__CRTC2_ICON_EN_MASK                 0x00008000L
+#define CRTC2_GEN_CNTL__CRTC2_ICON_EN                      0x00008000L
+#define CRTC2_GEN_CNTL__CRTC2_CUR_EN_MASK                  0x00010000L
+#define CRTC2_GEN_CNTL__CRTC2_CUR_EN                       0x00010000L
+#define CRTC2_GEN_CNTL__CRTC2_CUR_MODE_MASK                0x00700000L
+#define CRTC2_GEN_CNTL__CRTC2_DISPLAY_DIS_MASK             0x00800000L
+#define CRTC2_GEN_CNTL__CRTC2_DISPLAY_DIS                  0x00800000L
+#define CRTC2_GEN_CNTL__CRTC2_EN_MASK                      0x02000000L
+#define CRTC2_GEN_CNTL__CRTC2_EN                           0x02000000L
+#define CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B_MASK           0x04000000L
+#define CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B                0x04000000L
+#define CRTC2_GEN_CNTL__CRTC2_C_SYNC_EN_MASK               0x08000000L
+#define CRTC2_GEN_CNTL__CRTC2_C_SYNC_EN                    0x08000000L
+#define CRTC2_GEN_CNTL__CRTC2_HSYNC_DIS_MASK               0x10000000L
+#define CRTC2_GEN_CNTL__CRTC2_HSYNC_DIS                    0x10000000L
+#define CRTC2_GEN_CNTL__CRTC2_VSYNC_DIS_MASK               0x20000000L
+#define CRTC2_GEN_CNTL__CRTC2_VSYNC_DIS                    0x20000000L
+
+// AGP_CNTL
+#define AGP_CNTL__MAX_IDLE_CLK_MASK                        0x000000ffL
+#define AGP_CNTL__HOLD_RD_FIFO_MASK                        0x00000100L
+#define AGP_CNTL__HOLD_RD_FIFO                             0x00000100L
+#define AGP_CNTL__HOLD_RQ_FIFO_MASK                        0x00000200L
+#define AGP_CNTL__HOLD_RQ_FIFO                             0x00000200L
+#define AGP_CNTL__EN_2X_STBB_MASK                          0x00000400L
+#define AGP_CNTL__EN_2X_STBB                               0x00000400L
+#define AGP_CNTL__FORCE_FULL_SBA_MASK                      0x00000800L
+#define AGP_CNTL__FORCE_FULL_SBA                           0x00000800L
+#define AGP_CNTL__SBA_DIS_MASK                             0x00001000L
+#define AGP_CNTL__SBA_DIS                                  0x00001000L
+#define AGP_CNTL__AGP_REV_ID_MASK                          0x00002000L
+#define AGP_CNTL__AGP_REV_ID                               0x00002000L
+#define AGP_CNTL__REG_CRIPPLE_AGP4X_MASK                   0x00004000L
+#define AGP_CNTL__REG_CRIPPLE_AGP4X                        0x00004000L
+#define AGP_CNTL__REG_CRIPPLE_AGP2X4X_MASK                 0x00008000L
+#define AGP_CNTL__REG_CRIPPLE_AGP2X4X                      0x00008000L
+#define AGP_CNTL__FORCE_INT_VREF_MASK                      0x00010000L
+#define AGP_CNTL__FORCE_INT_VREF                           0x00010000L
+#define AGP_CNTL__PENDING_SLOTS_VAL_MASK                   0x00060000L
+#define AGP_CNTL__PENDING_SLOTS_SEL_MASK                   0x00080000L
+#define AGP_CNTL__PENDING_SLOTS_SEL                        0x00080000L
+#define AGP_CNTL__EN_EXTENDED_AD_STB_2X_MASK               0x00100000L
+#define AGP_CNTL__EN_EXTENDED_AD_STB_2X                    0x00100000L
+#define AGP_CNTL__DIS_QUEUED_GNT_FIX_MASK                  0x00200000L
+#define AGP_CNTL__DIS_QUEUED_GNT_FIX                       0x00200000L
+#define AGP_CNTL__EN_RDATA2X4X_MULTIRESET_MASK             0x00400000L
+#define AGP_CNTL__EN_RDATA2X4X_MULTIRESET                  0x00400000L
+#define AGP_CNTL__EN_RBFCALM_MASK                          0x00800000L
+#define AGP_CNTL__EN_RBFCALM                               0x00800000L
+#define AGP_CNTL__FORCE_EXT_VREF_MASK                      0x01000000L
+#define AGP_CNTL__FORCE_EXT_VREF                           0x01000000L
+#define AGP_CNTL__DIS_RBF_MASK                             0x02000000L
+#define AGP_CNTL__DIS_RBF                                  0x02000000L
+#define AGP_CNTL__DELAY_FIRST_SBA_EN_MASK                  0x04000000L
+#define AGP_CNTL__DELAY_FIRST_SBA_EN                       0x04000000L
+#define AGP_CNTL__DELAY_FIRST_SBA_VAL_MASK                 0x38000000L
+#define AGP_CNTL__AGP_MISC_MASK                            0xc0000000L
+
+// AGP_CNTL
+#define	AGP_CNTL__MAX_IDLE_CLK__SHIFT                      0x00000000
+#define	AGP_CNTL__HOLD_RD_FIFO__SHIFT                      0x00000008
+#define	AGP_CNTL__HOLD_RQ_FIFO__SHIFT                      0x00000009
+#define	AGP_CNTL__EN_2X_STBB__SHIFT                        0x0000000a
+#define	AGP_CNTL__FORCE_FULL_SBA__SHIFT                    0x0000000b
+#define	AGP_CNTL__SBA_DIS__SHIFT                           0x0000000c
+#define	AGP_CNTL__AGP_REV_ID__SHIFT                        0x0000000d
+#define	AGP_CNTL__REG_CRIPPLE_AGP4X__SHIFT                 0x0000000e
+#define	AGP_CNTL__REG_CRIPPLE_AGP2X4X__SHIFT               0x0000000f
+#define	AGP_CNTL__FORCE_INT_VREF__SHIFT                    0x00000010
+#define	AGP_CNTL__PENDING_SLOTS_VAL__SHIFT                 0x00000011
+#define	AGP_CNTL__PENDING_SLOTS_SEL__SHIFT                 0x00000013
+#define	AGP_CNTL__EN_EXTENDED_AD_STB_2X__SHIFT             0x00000014
+#define	AGP_CNTL__DIS_QUEUED_GNT_FIX__SHIFT                0x00000015
+#define	AGP_CNTL__EN_RDATA2X4X_MULTIRESET__SHIFT           0x00000016
+#define	AGP_CNTL__EN_RBFCALM__SHIFT                        0x00000017
+#define	AGP_CNTL__FORCE_EXT_VREF__SHIFT                    0x00000018
+#define	AGP_CNTL__DIS_RBF__SHIFT                           0x00000019
+#define	AGP_CNTL__DELAY_FIRST_SBA_EN__SHIFT                0x0000001a
+#define	AGP_CNTL__DELAY_FIRST_SBA_VAL__SHIFT               0x0000001b
+#define	AGP_CNTL__AGP_MISC__SHIFT                          0x0000001e
+
+// DISP_MISC_CNTL
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH_PP_MASK            0x00000001L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH_PP                 0x00000001L
+#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_PP_MASK          0x00000002L
+#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_PP               0x00000002L
+#define DISP_MISC_CNTL__SOFT_RESET_OV0_PP_MASK             0x00000004L
+#define DISP_MISC_CNTL__SOFT_RESET_OV0_PP                  0x00000004L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH_SCLK_MASK          0x00000010L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH_SCLK               0x00000010L
+#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_SCLK_MASK        0x00000020L
+#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_SCLK             0x00000020L
+#define DISP_MISC_CNTL__SOFT_RESET_OV0_SCLK_MASK           0x00000040L
+#define DISP_MISC_CNTL__SOFT_RESET_OV0_SCLK                0x00000040L
+#define DISP_MISC_CNTL__SYNC_STRENGTH_MASK                 0x00000300L
+#define DISP_MISC_CNTL__SYNC_PAD_FLOP_EN_MASK              0x00000400L
+#define DISP_MISC_CNTL__SYNC_PAD_FLOP_EN                   0x00000400L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_PP_MASK           0x00001000L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_PP                0x00001000L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_SCLK_MASK         0x00008000L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_SCLK              0x00008000L
+#define DISP_MISC_CNTL__SOFT_RESET_LVDS_MASK               0x00010000L
+#define DISP_MISC_CNTL__SOFT_RESET_LVDS                    0x00010000L
+#define DISP_MISC_CNTL__SOFT_RESET_TMDS_MASK               0x00020000L
+#define DISP_MISC_CNTL__SOFT_RESET_TMDS                    0x00020000L
+#define DISP_MISC_CNTL__SOFT_RESET_DIG_TMDS_MASK           0x00040000L
+#define DISP_MISC_CNTL__SOFT_RESET_DIG_TMDS                0x00040000L
+#define DISP_MISC_CNTL__SOFT_RESET_TV_MASK                 0x00080000L
+#define DISP_MISC_CNTL__SOFT_RESET_TV                      0x00080000L
+#define DISP_MISC_CNTL__PALETTE2_MEM_RD_MARGIN_MASK        0x00f00000L
+#define DISP_MISC_CNTL__PALETTE_MEM_RD_MARGIN_MASK         0x0f000000L
+#define DISP_MISC_CNTL__RMX_BUF_MEM_RD_MARGIN_MASK         0xf0000000L
+
+// DISP_PWR_MAN
+#define DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN_MASK         0x00000001L
+#define DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN              0x00000001L
+#define DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN_MASK       0x00000010L
+#define DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN            0x00000010L
+#define DISP_PWR_MAN__DISP_PWR_MAN_DPMS_MASK               0x00000300L
+#define DISP_PWR_MAN__DISP_D3_RST_MASK                     0x00010000L
+#define DISP_PWR_MAN__DISP_D3_RST                          0x00010000L
+#define DISP_PWR_MAN__DISP_D3_REG_RST_MASK                 0x00020000L
+#define DISP_PWR_MAN__DISP_D3_REG_RST                      0x00020000L
+#define DISP_PWR_MAN__DISP_D3_GRPH_RST_MASK                0x00040000L
+#define DISP_PWR_MAN__DISP_D3_GRPH_RST                     0x00040000L
+#define DISP_PWR_MAN__DISP_D3_SUBPIC_RST_MASK              0x00080000L
+#define DISP_PWR_MAN__DISP_D3_SUBPIC_RST                   0x00080000L
+#define DISP_PWR_MAN__DISP_D3_OV0_RST_MASK                 0x00100000L
+#define DISP_PWR_MAN__DISP_D3_OV0_RST                      0x00100000L
+#define DISP_PWR_MAN__DISP_D1D2_GRPH_RST_MASK              0x00200000L
+#define DISP_PWR_MAN__DISP_D1D2_GRPH_RST                   0x00200000L
+#define DISP_PWR_MAN__DISP_D1D2_SUBPIC_RST_MASK            0x00400000L
+#define DISP_PWR_MAN__DISP_D1D2_SUBPIC_RST                 0x00400000L
+#define DISP_PWR_MAN__DISP_D1D2_OV0_RST_MASK               0x00800000L
+#define DISP_PWR_MAN__DISP_D1D2_OV0_RST                    0x00800000L
+#define DISP_PWR_MAN__DIG_TMDS_ENABLE_RST_MASK             0x01000000L
+#define DISP_PWR_MAN__DIG_TMDS_ENABLE_RST                  0x01000000L
+#define DISP_PWR_MAN__TV_ENABLE_RST_MASK                   0x02000000L
+#define DISP_PWR_MAN__TV_ENABLE_RST                        0x02000000L
+#define DISP_PWR_MAN__AUTO_PWRUP_EN_MASK                   0x04000000L
+#define DISP_PWR_MAN__AUTO_PWRUP_EN                        0x04000000L
+
+// MC_IND_INDEX
+#define MC_IND_INDEX__MC_IND_ADDR_MASK                     0x0000001fL
+#define MC_IND_INDEX__MC_IND_WR_EN_MASK                    0x00000100L
+#define MC_IND_INDEX__MC_IND_WR_EN                         0x00000100L
+
+// MC_IND_DATA
+#define MC_IND_DATA__MC_IND_DATA_MASK                      0xffffffffL
+
+// MC_CHP_IO_CNTL_A1
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA__SHIFT            0x00000000
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA__SHIFT             0x00000001
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA__SHIFT           0x00000002
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA__SHIFT           0x00000003
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA__SHIFT            0x00000004
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA__SHIFT             0x00000005
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA__SHIFT           0x00000006
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA__SHIFT           0x00000007
+#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA__SHIFT            0x00000008
+#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA__SHIFT          0x00000009
+#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA__SHIFT          0x0000000a
+#define	MC_CHP_IO_CNTL_A1__MEM_IO_MODEA__SHIFT             0x0000000c
+#define	MC_CHP_IO_CNTL_A1__MEM_REC_CKA__SHIFT              0x0000000e
+#define	MC_CHP_IO_CNTL_A1__MEM_REC_AA__SHIFT               0x00000010
+#define	MC_CHP_IO_CNTL_A1__MEM_REC_DQMA__SHIFT             0x00000012
+#define	MC_CHP_IO_CNTL_A1__MEM_REC_DQSA__SHIFT             0x00000014
+#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA__SHIFT          0x00000016
+#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA__SHIFT         0x00000017
+#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA__SHIFT             0x00000018
+#define	MC_CHP_IO_CNTL_A1__MEM_CLK_SELA__SHIFT             0x0000001a
+#define	MC_CHP_IO_CNTL_A1__MEM_CLK_INVA__SHIFT             0x0000001c
+#define	MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A__SHIFT         0x0000001e
+#define	MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A__SHIFT         0x0000001f
+
+// MC_CHP_IO_CNTL_B1
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB__SHIFT            0x00000000
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB__SHIFT             0x00000001
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB__SHIFT           0x00000002
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB__SHIFT           0x00000003
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB__SHIFT            0x00000004
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB__SHIFT             0x00000005
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB__SHIFT           0x00000006
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB__SHIFT           0x00000007
+#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB__SHIFT            0x00000008
+#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB__SHIFT          0x00000009
+#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB__SHIFT          0x0000000a
+#define	MC_CHP_IO_CNTL_B1__MEM_IO_MODEB__SHIFT             0x0000000c
+#define	MC_CHP_IO_CNTL_B1__MEM_REC_CKB__SHIFT              0x0000000e
+#define	MC_CHP_IO_CNTL_B1__MEM_REC_AB__SHIFT               0x00000010
+#define	MC_CHP_IO_CNTL_B1__MEM_REC_DQMB__SHIFT             0x00000012
+#define	MC_CHP_IO_CNTL_B1__MEM_REC_DQSB__SHIFT             0x00000014
+#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB__SHIFT          0x00000016
+#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB__SHIFT         0x00000017
+#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB__SHIFT             0x00000018
+#define	MC_CHP_IO_CNTL_B1__MEM_CLK_SELB__SHIFT             0x0000001a
+#define	MC_CHP_IO_CNTL_B1__MEM_CLK_INVB__SHIFT             0x0000001c
+#define	MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B__SHIFT         0x0000001e
+#define	MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B__SHIFT         0x0000001f
+
+// MC_CHP_IO_CNTL_A1
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA_MASK              0x00000001L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA                   0x00000001L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA_MASK               0x00000002L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA                    0x00000002L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA_MASK             0x00000004L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA                  0x00000004L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA_MASK             0x00000008L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA                  0x00000008L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA_MASK              0x00000010L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA                   0x00000010L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA_MASK               0x00000020L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA                    0x00000020L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA_MASK             0x00000040L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA                  0x00000040L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA_MASK             0x00000080L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA                  0x00000080L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA_MASK              0x00000100L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA                   0x00000100L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA_MASK            0x00000200L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA                 0x00000200L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA_MASK            0x00000400L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA                 0x00000400L
+#define MC_CHP_IO_CNTL_A1__MEM_IO_MODEA_MASK               0x00003000L
+#define MC_CHP_IO_CNTL_A1__MEM_REC_CKA_MASK                0x0000c000L
+#define MC_CHP_IO_CNTL_A1__MEM_REC_AA_MASK                 0x00030000L
+#define MC_CHP_IO_CNTL_A1__MEM_REC_DQMA_MASK               0x000c0000L
+#define MC_CHP_IO_CNTL_A1__MEM_REC_DQSA_MASK               0x00300000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA_MASK            0x00400000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA                 0x00400000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA_MASK           0x00800000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA                0x00800000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA_MASK               0x03000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CLK_SELA_MASK               0x0c000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CLK_INVA_MASK               0x10000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CLK_INVA                    0x10000000L
+#define MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A_MASK           0x40000000L
+#define MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A                0x40000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A_MASK           0x80000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A                0x80000000L
+
+// MC_CHP_IO_CNTL_B1
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB_MASK              0x00000001L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB                   0x00000001L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB_MASK               0x00000002L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB                    0x00000002L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB_MASK             0x00000004L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB                  0x00000004L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB_MASK             0x00000008L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB                  0x00000008L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB_MASK              0x00000010L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB                   0x00000010L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB_MASK               0x00000020L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB                    0x00000020L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB_MASK             0x00000040L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB                  0x00000040L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB_MASK             0x00000080L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB                  0x00000080L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB_MASK              0x00000100L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB                   0x00000100L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB_MASK            0x00000200L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB                 0x00000200L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB_MASK            0x00000400L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB                 0x00000400L
+#define MC_CHP_IO_CNTL_B1__MEM_IO_MODEB_MASK               0x00003000L
+#define MC_CHP_IO_CNTL_B1__MEM_REC_CKB_MASK                0x0000c000L
+#define MC_CHP_IO_CNTL_B1__MEM_REC_AB_MASK                 0x00030000L
+#define MC_CHP_IO_CNTL_B1__MEM_REC_DQMB_MASK               0x000c0000L
+#define MC_CHP_IO_CNTL_B1__MEM_REC_DQSB_MASK               0x00300000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB_MASK            0x00400000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB                 0x00400000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB_MASK           0x00800000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB                0x00800000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB_MASK               0x03000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CLK_SELB_MASK               0x0c000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CLK_INVB_MASK               0x10000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CLK_INVB                    0x10000000L
+#define MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B_MASK           0x40000000L
+#define MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B                0x40000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B_MASK           0x80000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B                0x80000000L
+
+// MEM_SDRAM_MODE_REG
+#define MEM_SDRAM_MODE_REG__MEM_MODE_REG_MASK              0x00007fffL
+#define MEM_SDRAM_MODE_REG__MEM_WR_LATENCY_MASK            0x000f0000L
+#define MEM_SDRAM_MODE_REG__MEM_CAS_LATENCY_MASK           0x00700000L
+#define MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY_MASK           0x00800000L
+#define MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY                0x00800000L
+#define MEM_SDRAM_MODE_REG__MEM_STR_LATENCY_MASK           0x01000000L
+#define MEM_SDRAM_MODE_REG__MEM_STR_LATENCY                0x01000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD_MASK          0x02000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD               0x02000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA_MASK         0x04000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA              0x04000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR_MASK          0x08000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR               0x08000000L
+#define MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE_MASK          0x10000000L
+#define MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE               0x10000000L
+#define MEM_SDRAM_MODE_REG__MEM_DDR_DLL_MASK               0x20000000L
+#define MEM_SDRAM_MODE_REG__MEM_DDR_DLL                    0x20000000L
+#define MEM_SDRAM_MODE_REG__MEM_CFG_TYPE_MASK              0x40000000L
+#define MEM_SDRAM_MODE_REG__MEM_CFG_TYPE                   0x40000000L
+#define MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET_MASK           0x80000000L
+#define MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET                0x80000000L
+
+// MEM_SDRAM_MODE_REG
+#define	MEM_SDRAM_MODE_REG__MEM_MODE_REG__SHIFT            0x00000000
+#define	MEM_SDRAM_MODE_REG__MEM_WR_LATENCY__SHIFT          0x00000010
+#define	MEM_SDRAM_MODE_REG__MEM_CAS_LATENCY__SHIFT         0x00000014
+#define	MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY__SHIFT         0x00000017
+#define	MEM_SDRAM_MODE_REG__MEM_STR_LATENCY__SHIFT         0x00000018
+#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD__SHIFT        0x00000019
+#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA__SHIFT       0x0000001a
+#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR__SHIFT        0x0000001b
+#define	MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE__SHIFT        0x0000001c
+#define	MEM_SDRAM_MODE_REG__MEM_DDR_DLL__SHIFT             0x0000001d
+#define	MEM_SDRAM_MODE_REG__MEM_CFG_TYPE__SHIFT            0x0000001e
+#define	MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET__SHIFT         0x0000001f
+
+// MEM_REFRESH_CNTL
+#define MEM_REFRESH_CNTL__MEM_REFRESH_RATE_MASK            0x000000ffL
+#define MEM_REFRESH_CNTL__MEM_REFRESH_DIS_MASK             0x00000100L
+#define MEM_REFRESH_CNTL__MEM_REFRESH_DIS                  0x00000100L
+#define MEM_REFRESH_CNTL__MEM_DYNAMIC_CKE_MASK             0x00000200L
+#define MEM_REFRESH_CNTL__MEM_DYNAMIC_CKE                  0x00000200L
+#define MEM_REFRESH_CNTL__MEM_TRFC_MASK                    0x0000f000L
+#define MEM_REFRESH_CNTL__MEM_CLKA0_ENABLE_MASK            0x00010000L
+#define MEM_REFRESH_CNTL__MEM_CLKA0_ENABLE                 0x00010000L
+#define MEM_REFRESH_CNTL__MEM_CLKA0b_ENABLE_MASK           0x00020000L
+#define MEM_REFRESH_CNTL__MEM_CLKA0b_ENABLE                0x00020000L
+#define MEM_REFRESH_CNTL__MEM_CLKA1_ENABLE_MASK            0x00040000L
+#define MEM_REFRESH_CNTL__MEM_CLKA1_ENABLE                 0x00040000L
+#define MEM_REFRESH_CNTL__MEM_CLKA1b_ENABLE_MASK           0x00080000L
+#define MEM_REFRESH_CNTL__MEM_CLKA1b_ENABLE                0x00080000L
+#define MEM_REFRESH_CNTL__MEM_CLKAFB_ENABLE_MASK           0x00100000L
+#define MEM_REFRESH_CNTL__MEM_CLKAFB_ENABLE                0x00100000L
+#define MEM_REFRESH_CNTL__DLL_FB_SLCT_CKA_MASK             0x00c00000L
+#define MEM_REFRESH_CNTL__MEM_CLKB0_ENABLE_MASK            0x01000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB0_ENABLE                 0x01000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB0b_ENABLE_MASK           0x02000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB0b_ENABLE                0x02000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB1_ENABLE_MASK            0x04000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB1_ENABLE                 0x04000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB1b_ENABLE_MASK           0x08000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB1b_ENABLE                0x08000000L
+#define MEM_REFRESH_CNTL__MEM_CLKBFB_ENABLE_MASK           0x10000000L
+#define MEM_REFRESH_CNTL__MEM_CLKBFB_ENABLE                0x10000000L
+#define MEM_REFRESH_CNTL__DLL_FB_SLCT_CKB_MASK             0xc0000000L
+
+// MC_STATUS
+#define MC_STATUS__MEM_PWRUP_COMPL_A_MASK                  0x00000001L
+#define MC_STATUS__MEM_PWRUP_COMPL_A                       0x00000001L
+#define MC_STATUS__MEM_PWRUP_COMPL_B_MASK                  0x00000002L
+#define MC_STATUS__MEM_PWRUP_COMPL_B                       0x00000002L
+#define MC_STATUS__MC_IDLE_MASK                            0x00000004L
+#define MC_STATUS__MC_IDLE                                 0x00000004L
+#define MC_STATUS__IMP_N_VALUE_R_BACK_MASK                 0x00000078L
+#define MC_STATUS__IMP_P_VALUE_R_BACK_MASK                 0x00000780L
+#define MC_STATUS__TEST_OUT_R_BACK_MASK                    0x00000800L
+#define MC_STATUS__TEST_OUT_R_BACK                         0x00000800L
+#define MC_STATUS__DUMMY_OUT_R_BACK_MASK                   0x00001000L
+#define MC_STATUS__DUMMY_OUT_R_BACK                        0x00001000L
+#define MC_STATUS__IMP_N_VALUE_A_R_BACK_MASK               0x0001e000L
+#define MC_STATUS__IMP_P_VALUE_A_R_BACK_MASK               0x001e0000L
+#define MC_STATUS__IMP_N_VALUE_CK_R_BACK_MASK              0x01e00000L
+#define MC_STATUS__IMP_P_VALUE_CK_R_BACK_MASK              0x1e000000L
+
+// MDLL_CKO
+#define MDLL_CKO__MCKOA_SLEEP_MASK                         0x00000001L
+#define MDLL_CKO__MCKOA_SLEEP                              0x00000001L
+#define MDLL_CKO__MCKOA_RESET_MASK                         0x00000002L
+#define MDLL_CKO__MCKOA_RESET                              0x00000002L
+#define MDLL_CKO__MCKOA_RANGE_MASK                         0x0000000cL
+#define MDLL_CKO__ERSTA_SOUTSEL_MASK                       0x00000030L
+#define MDLL_CKO__MCKOA_FB_SEL_MASK                        0x000000c0L
+#define MDLL_CKO__MCKOA_REF_SKEW_MASK                      0x00000700L
+#define MDLL_CKO__MCKOA_FB_SKEW_MASK                       0x00007000L
+#define MDLL_CKO__MCKOA_BP_SEL_MASK                        0x00008000L
+#define MDLL_CKO__MCKOA_BP_SEL                             0x00008000L
+#define MDLL_CKO__MCKOB_SLEEP_MASK                         0x00010000L
+#define MDLL_CKO__MCKOB_SLEEP                              0x00010000L
+#define MDLL_CKO__MCKOB_RESET_MASK                         0x00020000L
+#define MDLL_CKO__MCKOB_RESET                              0x00020000L
+#define MDLL_CKO__MCKOB_RANGE_MASK                         0x000c0000L
+#define MDLL_CKO__ERSTB_SOUTSEL_MASK                       0x00300000L
+#define MDLL_CKO__MCKOB_FB_SEL_MASK                        0x00c00000L
+#define MDLL_CKO__MCKOB_REF_SKEW_MASK                      0x07000000L
+#define MDLL_CKO__MCKOB_FB_SKEW_MASK                       0x70000000L
+#define MDLL_CKO__MCKOB_BP_SEL_MASK                        0x80000000L
+#define MDLL_CKO__MCKOB_BP_SEL                             0x80000000L
+
+// MDLL_RDCKA
+#define MDLL_RDCKA__MRDCKA0_SLEEP_MASK                     0x00000001L
+#define MDLL_RDCKA__MRDCKA0_SLEEP                          0x00000001L
+#define MDLL_RDCKA__MRDCKA0_RESET_MASK                     0x00000002L
+#define MDLL_RDCKA__MRDCKA0_RESET                          0x00000002L
+#define MDLL_RDCKA__MRDCKA0_RANGE_MASK                     0x0000000cL
+#define MDLL_RDCKA__MRDCKA0_REF_SEL_MASK                   0x00000030L
+#define MDLL_RDCKA__MRDCKA0_FB_SEL_MASK                    0x000000c0L
+#define MDLL_RDCKA__MRDCKA0_REF_SKEW_MASK                  0x00000700L
+#define MDLL_RDCKA__MRDCKA0_SINSEL_MASK                    0x00000800L
+#define MDLL_RDCKA__MRDCKA0_SINSEL                         0x00000800L
+#define MDLL_RDCKA__MRDCKA0_FB_SKEW_MASK                   0x00007000L
+#define MDLL_RDCKA__MRDCKA0_BP_SEL_MASK                    0x00008000L
+#define MDLL_RDCKA__MRDCKA0_BP_SEL                         0x00008000L
+#define MDLL_RDCKA__MRDCKA1_SLEEP_MASK                     0x00010000L
+#define MDLL_RDCKA__MRDCKA1_SLEEP                          0x00010000L
+#define MDLL_RDCKA__MRDCKA1_RESET_MASK                     0x00020000L
+#define MDLL_RDCKA__MRDCKA1_RESET                          0x00020000L
+#define MDLL_RDCKA__MRDCKA1_RANGE_MASK                     0x000c0000L
+#define MDLL_RDCKA__MRDCKA1_REF_SEL_MASK                   0x00300000L
+#define MDLL_RDCKA__MRDCKA1_FB_SEL_MASK                    0x00c00000L
+#define MDLL_RDCKA__MRDCKA1_REF_SKEW_MASK                  0x07000000L
+#define MDLL_RDCKA__MRDCKA1_SINSEL_MASK                    0x08000000L
+#define MDLL_RDCKA__MRDCKA1_SINSEL                         0x08000000L
+#define MDLL_RDCKA__MRDCKA1_FB_SKEW_MASK                   0x70000000L
+#define MDLL_RDCKA__MRDCKA1_BP_SEL_MASK                    0x80000000L
+#define MDLL_RDCKA__MRDCKA1_BP_SEL                         0x80000000L
+
+// MDLL_RDCKB
+#define MDLL_RDCKB__MRDCKB0_SLEEP_MASK                     0x00000001L
+#define MDLL_RDCKB__MRDCKB0_SLEEP                          0x00000001L
+#define MDLL_RDCKB__MRDCKB0_RESET_MASK                     0x00000002L
+#define MDLL_RDCKB__MRDCKB0_RESET                          0x00000002L
+#define MDLL_RDCKB__MRDCKB0_RANGE_MASK                     0x0000000cL
+#define MDLL_RDCKB__MRDCKB0_REF_SEL_MASK                   0x00000030L
+#define MDLL_RDCKB__MRDCKB0_FB_SEL_MASK                    0x000000c0L
+#define MDLL_RDCKB__MRDCKB0_REF_SKEW_MASK                  0x00000700L
+#define MDLL_RDCKB__MRDCKB0_SINSEL_MASK                    0x00000800L
+#define MDLL_RDCKB__MRDCKB0_SINSEL                         0x00000800L
+#define MDLL_RDCKB__MRDCKB0_FB_SKEW_MASK                   0x00007000L
+#define MDLL_RDCKB__MRDCKB0_BP_SEL_MASK                    0x00008000L
+#define MDLL_RDCKB__MRDCKB0_BP_SEL                         0x00008000L
+#define MDLL_RDCKB__MRDCKB1_SLEEP_MASK                     0x00010000L
+#define MDLL_RDCKB__MRDCKB1_SLEEP                          0x00010000L
+#define MDLL_RDCKB__MRDCKB1_RESET_MASK                     0x00020000L
+#define MDLL_RDCKB__MRDCKB1_RESET                          0x00020000L
+#define MDLL_RDCKB__MRDCKB1_RANGE_MASK                     0x000c0000L
+#define MDLL_RDCKB__MRDCKB1_REF_SEL_MASK                   0x00300000L
+#define MDLL_RDCKB__MRDCKB1_FB_SEL_MASK                    0x00c00000L
+#define MDLL_RDCKB__MRDCKB1_REF_SKEW_MASK                  0x07000000L
+#define MDLL_RDCKB__MRDCKB1_SINSEL_MASK                    0x08000000L
+#define MDLL_RDCKB__MRDCKB1_SINSEL                         0x08000000L
+#define MDLL_RDCKB__MRDCKB1_FB_SKEW_MASK                   0x70000000L
+#define MDLL_RDCKB__MRDCKB1_BP_SEL_MASK                    0x80000000L
+#define MDLL_RDCKB__MRDCKB1_BP_SEL                         0x80000000L
+
+#define pllVCLK_ECP_CNTL                            0x0008
+#define pllDISP_TEST_MACRO_RW_WRITE                 0x001A
+#define pllDISP_TEST_MACRO_RW_READ                  0x001B
+#define pllDISP_TEST_MACRO_RW_DATA                  0x001C
+#define pllDISP_TEST_MACRO_RW_CNTL                  0x001D
+#define pllPIXCLKS_CNTL                             0x002D
+#define pllPPLL_DIV_0                               0x0004
+#define pllPPLL_DIV_1                               0x0005
+#define pllPPLL_DIV_2                               0x0006
+#define pllPPLL_DIV_3                               0x0007
+#define pllHTOTAL_CNTL                              0x0009
+#define pllPLL_TEST_CNTL_M6                         0x0013
+#define pllP2PLL_DIV_0                              0x002C
+#define pllHTOTAL2_CNTL                             0x002E
+#define pllCLK_PIN_CNTL                             0x0001
+#define pllPPLL_CNTL                                0x0002
+#define pllPPLL_REF_DIV                             0x0003
+#define pllSPLL_CNTL                                0x000C
+#define pllSPLL_AUX_CNTL                            0x0024
+#define pllSCLK_CNTL_M6                             0x000D
+#define pllAGP_PLL_CNTL                             0x000B
+#define pllTV_PLL_FINE_CNTL                         0x0020
+#define pllTV_PLL_CNTL                              0x0021
+#define pllTV_PLL_CNTL1                             0x0022
+#define pllTV_DTO_INCREMENTS                        0x0023
+#define pllP2PLL_CNTL                               0x002A
+#define pllP2PLL_REF_DIV                            0x002B
+#define pllSSPLL_CNTL                               0x0030
+#define pllSSPLL_REF_DIV                            0x0031
+#define pllSSPLL_DIV_0                              0x0032
+#define pllSS_INT_CNTL                              0x0033
+#define pllSS_TST_CNTL                              0x0034
+#define pllSCLK_MORE_CNTL                           0x0035
+#define pllCLK_PWRMGT_CNTL_M6                       0x0014
+#define pllPLL_PWRMGT_CNTL                          0x0015
+#define pllM_SPLL_REF_FB_DIV                        0x000A
+#define pllMPLL_CNTL                                0x000E
+#define pllMPLL_AUX_CNTL                            0x0025
+#define pllMDLL_CKO                                 0x000F
+#define pllMDLL_RDCKA                               0x0010
+#define pllMDLL_RDCKB                               0x0011
+#define pllMCLK_CNTL_M6                             0x0012
+#define pllMCLK_MISC                                0x001F
+#define pllCG_TEST_MACRO_RW_WRITE                   0x0016
+#define pllCG_TEST_MACRO_RW_READ                    0x0017
+#define pllCG_TEST_MACRO_RW_DATA                    0x0018
+#define pllCG_TEST_MACRO_RW_CNTL                    0x0019
+
+#define ixMC_PERF_CNTL                             0x0000
+#define ixMC_PERF_SEL                              0x0001
+#define ixMC_PERF_REGION_0                         0x0002
+#define ixMC_PERF_REGION_1                         0x0003
+#define ixMC_PERF_COUNT_0                          0x0004
+#define ixMC_PERF_COUNT_1                          0x0005
+#define ixMC_PERF_COUNT_2                          0x0006
+#define ixMC_PERF_COUNT_3                          0x0007
+#define ixMC_PERF_COUNT_MEMCH_A                    0x0008
+#define ixMC_PERF_COUNT_MEMCH_B                    0x0009
+#define ixMC_IMP_CNTL                              0x000A
+#define ixMC_CHP_IO_CNTL_A0                        0x000B
+#define ixMC_CHP_IO_CNTL_A1                        0x000C
+#define ixMC_CHP_IO_CNTL_B0                        0x000D
+#define ixMC_CHP_IO_CNTL_B1                        0x000E
+#define ixMC_IMP_CNTL_0                            0x000F
+#define ixTC_MISMATCH_1                            0x0010
+#define ixTC_MISMATCH_2                            0x0011
+#define ixMC_BIST_CTRL                             0x0012
+#define ixREG_COLLAR_WRITE                         0x0013
+#define ixREG_COLLAR_READ                          0x0014
+
+
+
+
 #endif	/* _RADEON_H */
 
