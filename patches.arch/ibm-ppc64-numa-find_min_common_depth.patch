--- /root/SLES9-curr/arch/ppc64/mm/numa.c	2004-05-18 16:04:28.989911688 -0700
+++ SLES9-curr/arch/ppc64/mm/numa.c	2004-05-18 16:03:03.341886760 -0700
@@ -123,73 +123,45 @@
  * their distances represented at a common level.  This won't be 
  * true for heirarchical NUMA.
  *
- * This function answers the question:
- * At which associativity level does a particular kind of device
- * begin to differ.
- *
- * More common levels mean that things are closer together.
+ * In any case the ibm,associativity-reference-points should give
+ * the correct depth for a normal NUMA system.
  *
  * - Dave Hansen <haveblue@us.ibm.com>
  */
-static int find_assoc_diff_depth(char *node_type)
+static int find_min_common_depth(void)
 {
-	struct device_node *device;
-	struct device_node *base_device;
-	int smallest_depth = -1;
-	unsigned int *base_assoc;
-
-	device = of_find_node_by_type(NULL, node_type);
-	if (!device)
-		goto err;
-
-	base_device = device;
-
-	/* 
-	 * keep a reference on the first device node so that it can
-	 * be compared against in the loop below 
+	int depth;
+	unsigned int *ref_points;
+	struct device_node *rtas_root;
+	unsigned int len;
+
+	rtas_root = of_find_node_by_path("/rtas");
+
+	if (!rtas_root) {
+		printk(KERN_ERR "WARNING: %s() could not find rtas root\n",
+				__FUNCTION__);
+		return -1;
+	}
+	
+	/*
+	 * this property is 2 32-bit integers, each representing a level of 
+	 * depth in the associativity nodes.  The first is for an SMP 
+	 * configuration (should be all 0's) and the second is for a normal 
+	 * NUMA configuration.
 	 */
-	of_node_get(base_device);
-	base_assoc = of_get_associativity(base_device);
-
-	for (; device; device = of_find_node_by_type(device, node_type)) {
-		unsigned int depth;
-		unsigned int length;
-		unsigned int *assoc = of_get_associativity(device);
-
-		if (!assoc)
-			goto err;
-
-		/*
-		 * The associativity arrays are pascal-string-style with t
-		 * the length as the first (0th) field. (self-inclusive)
-		 */
-		length = assoc[0];
+	ref_points = (unsigned int *)get_property(rtas_root, 
+			"ibm,associativity-reference-points", &len);
 
-		if (length > base_assoc[0]) {
-			printk(KERN_ERR "OpenFirmware associativity depth "
-			       "changed for %s: approximating depth\n",
-			       node_type);
-			goto err;
-		}
-
-		for (depth = 1; depth <= length; depth++) {
-			if (base_assoc[depth] != assoc[depth]) {
-				smallest_depth = depth;
-				break;
-			}
-		}
+	if ((len >= 1) && ref_points) {
+		depth = ref_points[1];
+	} else {
+		printk(KERN_ERR "WARNING: could not find NUMA "
+				"associativity reference point\n");
+		depth = -1;
 	}
+	of_node_put(rtas_root);
 
-err:
-	of_node_put(device);
-	of_node_put(base_device);
-	return smallest_depth;
-}
-
-static int find_min_common_depth(void)
-{
-	return min(find_assoc_diff_depth("memory"),
-		   find_assoc_diff_depth("cpu"));
+	return depth;
 }
 
 static unsigned long read_cell_ul(struct device_node *device, unsigned int **buf)
