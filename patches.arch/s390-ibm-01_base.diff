 - Add console_unblank in machine_{restart,halt,power_off} to get
   all messages on the screen.
 - Fix write_trylock for 64 bit.
 - Fix svc restarting.
 - System call number on 64 bit is an int. Fix compare in entry64.S.
 - Fix tlb flush problem.
 - Use the idte instruction to flush tlbs of a particular mm.
 - Fix ptrace.
 - Add fadvise64_64 system call wrapper.
 - Fix pfault handling.
 - Do not clobber _PAGE_INVALID_NONE pages in pte_wrprotect.
 - Fix siginfo_t size problem (needs to be 128 for s390x, not 136).

diffstat:
 arch/s390/kernel/entry.S       |    4 +++-
 arch/s390/kernel/entry64.S     |   15 +++++++++------
 arch/s390/kernel/head.S        |   11 +++++++++++
 arch/s390/kernel/head64.S      |   11 +++++++++++
 arch/s390/kernel/ptrace.c      |   35 +++++++++++++++++++++++++++--------
 arch/s390/kernel/semaphore.c   |   12 ++++++------
 arch/s390/kernel/setup.c       |    7 ++++++-
 arch/s390/kernel/sys_s390.c    |   36 ++++++++++++++++++++++++++++++++++++
 arch/s390/kernel/syscalls.S    |    5 +++--
 arch/s390/mm/fault.c           |   32 +++++++++-----------------------
 include/asm-s390/bug.h         |    2 ++
 include/asm-s390/checksum.h    |    8 ++++----
 include/asm-s390/mmu_context.h |    2 +-
 include/asm-s390/pgalloc.h     |    8 ++++++--
 include/asm-s390/pgtable.h     |    9 ++++++---
 include/asm-s390/setup.h       |    1 +
 include/asm-s390/siginfo.h     |    6 ++++++
 include/asm-s390/spinlock.h    |    2 +-
 include/asm-s390/tlbflush.h    |   20 ++++++++++++--------
 include/asm-s390/unistd.h      |    3 ++-
 20 files changed, 162 insertions(+), 67 deletions(-)

diff -urN linux-2.6/arch/s390/kernel/entry.S linux-2.6-s390/arch/s390/kernel/entry.S
--- linux-2.6/arch/s390/kernel/entry.S	Sat Oct 25 20:43:03 2003
+++ linux-2.6-s390/arch/s390/kernel/entry.S	Thu Nov 13 15:29:37 2003
@@ -249,6 +249,8 @@
         l       %r1,BASED(.Ldo_signal)
 	basr	%r14,%r1               # call do_signal
         stnsm   24(%r15),0xfc          # disable I/O and ext. interrupts
+	tm	__TI_flags+3(%r9),_TIF_RESTART_SVC
+	bo	BASED(sysc_restart)
 	b	BASED(sysc_leave)      # out of here, do NOT recheck
 
 #
@@ -258,7 +260,7 @@
 	ni	__TI_flags+3(%r9),255-_TIF_RESTART_SVC # clear TIF_RESTART_SVC
 	stosm	24(%r15),0x03          # reenable interrupts
 	l	%r7,SP_R2(%r15)        # load new svc number
-	sla	%r2,2
+	sla	%r7,2
 	mvc	SP_R2(4,%r15),SP_ORIG_R2(%r15) # restore first argument
 	lm	%r2,%r6,SP_R2(%r15)    # load svc arguments
 	b	BASED(sysc_do_restart) # restart svc
diff -urN linux-2.6/arch/s390/kernel/entry64.S linux-2.6-s390/arch/s390/kernel/entry64.S
--- linux-2.6/arch/s390/kernel/entry64.S	Sat Oct 25 20:43:03 2003
+++ linux-2.6-s390/arch/s390/kernel/entry64.S	Thu Nov 13 15:29:37 2003
@@ -169,9 +169,10 @@
         slag    %r7,%r7,2         # *4 and test for svc 0
 	jnz	sysc_do_restart
 	# svc 0: system call number in %r1
-	clg	%r1,.Lnr_syscalls-.Lconst(%r14)
+	cl	%r1,.Lnr_syscalls-.Lconst(%r14)
 	jnl	sysc_do_restart
-	slag    %r7,%r1,2         # svc 0: system call number in %r1
+	lgfr	%r7,%r1           # clear high word in r1
+	slag    %r7,%r7,2         # svc 0: system call number in %r1
 sysc_do_restart:
 	larl    %r10,sys_call_table
 #ifdef CONFIG_S390_SUPPORT
@@ -235,16 +236,18 @@
         sgr     %r3,%r3           # clear *oldset
 	brasl	%r14,do_signal    # call do_signal
 	stnsm   48(%r15),0xfc     # disable I/O and ext. interrupts
+	tm	__TI_flags+7(%r9),_TIF_RESTART_SVC
+	jo	sysc_restart
 	j	sysc_leave        # out of here, do NOT recheck
 
 #
 # _TIF_RESTART_SVC is set, set up registers and restart svc
 #
 sysc_restart:
-	ni	__TI_flags+3(%r9),255-_TIF_RESTART_SVC # clear TIF_RESTART_SVC
+	ni	__TI_flags+7(%r9),255-_TIF_RESTART_SVC # clear TIF_RESTART_SVC
 	stosm	48(%r15),0x03          # reenable interrupts
 	lg	%r7,SP_R2(%r15)        # load new svc number
-        slag    %r7,%r7,3              # *8
+        slag    %r7,%r7,2              # *4
 	mvc	SP_R2(8,%r15),SP_ORIG_R2(%r15) # restore first argument
 	lmg	%r2,%r6,SP_R2(%r15)    # load svc arguments
 	j	sysc_do_restart        # restart svc
@@ -503,7 +506,7 @@
 	larl    %r10,sys_call_table_emu # use 31 bit emulation system calls
 pgm_svcper_noemu:
 #endif
-	tm	__TI_flags+3(%r9),_TIF_SYSCALL_TRACE
+	tm	__TI_flags+7(%r9),_TIF_SYSCALL_TRACE
         lgf     %r8,0(%r7,%r10)   # load address of system call routine
         jo      pgm_tracesys
         basr    %r14,%r8          # call sys_xxxx
@@ -512,7 +515,7 @@
                                   # changing anything here !!
 
 pgm_svcret:
-	tm	__TI_flags+3(%r9),_TIF_SIGPENDING
+	tm	__TI_flags+7(%r9),_TIF_SIGPENDING
 	jo	pgm_svcper_nosig
         la      %r2,SP_PTREGS(%r15) # load pt_regs
         sgr     %r3,%r3             # clear *oldset
diff -urN linux-2.6/arch/s390/kernel/head.S linux-2.6-s390/arch/s390/kernel/head.S
--- linux-2.6/arch/s390/kernel/head.S	Sat Oct 25 20:43:14 2003
+++ linux-2.6-s390/arch/s390/kernel/head.S	Thu Nov 13 15:29:37 2003
@@ -569,6 +569,16 @@
        oi     3(%r12),16                # set MVPG flag
 .Lchkmvpg:
 
+#
+# find out if we have the IDTE instruction
+#
+	mvc	__LC_PGM_NEW_PSW(8),.Lpcidte-.LPG1(%r13)
+	.long	0xb2b10000		# store facility list
+	tm	0xc8,0x08		# check bit for clearing-by-ASCE
+	bno	.Lchkidte-.LPG1(%r13)
+	oi	3(%r12),0x80		# set IDTE flag
+.Lchkidte:
+
         lpsw  .Lentry-.LPG1(13)         # jump to _stext in primary-space,
                                         # virtual and never return ...
         .align 8
@@ -593,6 +603,7 @@
 .Lpcfpu:.long  0x00080000,0x80000000 + .Lchkfpu
 .Lpccsp:.long  0x00080000,0x80000000 + .Lchkcsp
 .Lpcmvpg:.long 0x00080000,0x80000000 + .Lchkmvpg
+.Lpcidte:.long 0x00080000,0x80000000 + .Lchkidte
 .Lmemsize:.long memory_size
 .Lmchunk:.long memory_chunk
 .Lmflags:.long machine_flags
diff -urN linux-2.6/arch/s390/kernel/head64.S linux-2.6-s390/arch/s390/kernel/head64.S
--- linux-2.6/arch/s390/kernel/head64.S	Sat Oct 25 20:43:20 2003
+++ linux-2.6-s390/arch/s390/kernel/head64.S	Thu Nov 13 15:29:37 2003
@@ -582,6 +582,17 @@
 	mvc    __LC_DIAG44_OPCODE(8),.Ldiag44-.LPG1(%r13)
 0:	
 
+#
+# find out if we have the IDTE instruction
+#
+	la     %r1,0f-.LPG1(%r13)	# set program check address
+	stg    %r1,__LC_PGM_NEW_PSW+8
+	.long	0xb2b10000		# store facility list
+	tm	0xc8,0x08		# check bit for clearing-by-ASCE
+	bno	0f-.LPG1(%r13)
+	oi	7(%r12),0x80		# set IDTE flag
+0:
+
         lpswe .Lentry-.LPG1(13)         # jump to _stext in primary-space,
                                         # virtual and never return ...
         .align 16
diff -urN linux-2.6/arch/s390/kernel/ptrace.c linux-2.6-s390/arch/s390/kernel/ptrace.c
--- linux-2.6/arch/s390/kernel/ptrace.c	Sat Oct 25 20:44:40 2003
+++ linux-2.6-s390/arch/s390/kernel/ptrace.c	Thu Nov 13 15:29:37 2003
@@ -130,7 +130,11 @@
 	struct user *dummy = NULL;
 	addr_t offset, tmp;
 
-	if ((addr & __ADDR_MASK) || addr > sizeof(struct user) - __ADDR_MASK)
+	/*
+	 * Stupid gdb peeks/pokes the access registers in 64 bit with
+	 * an alignment of 4. Programmers from hell...
+	 */
+	if ((addr & 3) || addr > sizeof(struct user) - __ADDR_MASK)
 		return -EIO;
 
 	if (addr <= (addr_t) &dummy->regs.orig_gpr2) {
@@ -138,6 +142,9 @@
 		 * psw, gprs, acrs and orig_gpr2 are stored on the stack
 		 */
 		tmp = *(addr_t *)((addr_t) __KSTK_PTREGS(child) + addr);
+		if (addr == (addr_t) &dummy->regs.psw.mask)
+			/* Remove per bit from user psw. */
+			tmp &= ~PSW_MASK_PER;
 
 	} else if (addr >= (addr_t) &dummy->regs.fp_regs &&
 		   addr < (addr_t) (&dummy->regs.fp_regs + 1)) {
@@ -173,7 +180,11 @@
 	struct user *dummy = NULL;
 	addr_t offset;
 
-	if ((addr & __ADDR_MASK) || addr > sizeof(struct user) - __ADDR_MASK)
+	/*
+	 * Stupid gdb peeks/pokes the access registers in 64 bit with
+	 * an alignment of 4. Programmers from hell indeed...
+	 */
+	if ((addr & 3) || addr > sizeof(struct user) - __ADDR_MASK)
 		return -EIO;
 
 	if (addr <= (addr_t) &dummy->regs.orig_gpr2) {
@@ -258,7 +269,7 @@
 
 	case PTRACE_PEEKUSR_AREA:
 	case PTRACE_POKEUSR_AREA:
-		if (!copy_from_user(&parea, (void *) addr, sizeof(parea)))
+		if (copy_from_user(&parea, (void *) addr, sizeof(parea)))
 			return -EFAULT;
 		addr = parea.kernel_addr;
 		data = parea.process_addr;
@@ -266,8 +277,12 @@
 		while (copied < parea.len) {
 			if (request == PTRACE_PEEKUSR_AREA)
 				ret = peek_user(child, addr, data);
-			else
-				ret = poke_user(child, addr, data);
+			else {
+				addr_t tmp;
+				if (get_user (tmp, (addr_t *) data))
+					return -EFAULT;
+				ret = poke_user(child, addr, tmp);
+			}
 			if (ret)
 				return ret;
 			addr += sizeof(unsigned long);
@@ -484,7 +499,7 @@
 
 	case PTRACE_PEEKUSR_AREA:
 	case PTRACE_POKEUSR_AREA:
-		if (!copy_from_user(&parea, (void *) addr, sizeof(parea)))
+		if (copy_from_user(&parea, (void *) addr, sizeof(parea)))
 			return -EFAULT;
 		addr = parea.kernel_addr;
 		data = parea.process_addr;
@@ -492,8 +507,12 @@
 		while (copied < parea.len) {
 			if (request == PTRACE_PEEKUSR_AREA)
 				ret = peek_user_emu31(child, addr, data);
-			else
-				ret = poke_user_emu31(child, addr, data);
+			else {
+				__u32 tmp;
+				if (get_user (tmp, (__u32 *) data))
+					return -EFAULT;
+				ret = poke_user_emu31(child, addr, tmp);
+			}
 			if (ret)
 				return ret;
 			addr += sizeof(unsigned int);
diff -urN linux-2.6/arch/s390/kernel/semaphore.c linux-2.6-s390/arch/s390/kernel/semaphore.c
--- linux-2.6/arch/s390/kernel/semaphore.c	Sat Oct 25 20:44:42 2003
+++ linux-2.6-s390/arch/s390/kernel/semaphore.c	Thu Nov 13 15:29:37 2003
@@ -64,14 +64,14 @@
 	struct task_struct *tsk = current;
 	DECLARE_WAITQUEUE(wait, tsk);
 
-	tsk->state = TASK_UNINTERRUPTIBLE;
+	__set_task_state(tsk, TASK_UNINTERRUPTIBLE);
 	add_wait_queue_exclusive(&sem->wait, &wait);
 	while (__sem_update_count(sem, -1) <= 0) {
 		schedule();
-		tsk->state = TASK_UNINTERRUPTIBLE;
+		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
 	}
 	remove_wait_queue(&sem->wait, &wait);
-	tsk->state = TASK_RUNNING;
+	__set_task_state(tsk, TASK_RUNNING);
 	wake_up(&sem->wait);
 }
 
@@ -87,7 +87,7 @@
 	struct task_struct *tsk = current;
 	DECLARE_WAITQUEUE(wait, tsk);
 
-	tsk->state = TASK_INTERRUPTIBLE;
+	__set_task_state(tsk, TASK_INTERRUPTIBLE);
 	add_wait_queue_exclusive(&sem->wait, &wait);
 	while (__sem_update_count(sem, -1) <= 0) {
 		if (signal_pending(current)) {
@@ -96,10 +96,10 @@
 			break;
 		}
 		schedule();
-		tsk->state = TASK_INTERRUPTIBLE;
+		set_task_state(tsk, TASK_INTERRUPTIBLE);
 	}
 	remove_wait_queue(&sem->wait, &wait);
-	tsk->state = TASK_RUNNING;
+	__set_task_state(tsk, TASK_RUNNING);
 	wake_up(&sem->wait);
 	return retval;
 }
diff -urN linux-2.6/arch/s390/kernel/setup.c linux-2.6-s390/arch/s390/kernel/setup.c
--- linux-2.6/arch/s390/kernel/setup.c	Sat Oct 25 20:42:55 2003
+++ linux-2.6-s390/arch/s390/kernel/setup.c	Thu Nov 13 15:29:37 2003
@@ -158,8 +158,10 @@
 	int vdev;
 
 	vdev = simple_strtoul(str, &str, 0);
-	if (vdev >= 0 && vdev < 65536)
+	if (vdev >= 0 && vdev < 65536) {
 		console_device = vdev;
+		console_irq = -1;
+	}
 	return 1;
 }
 
@@ -287,6 +289,7 @@
 
 void machine_restart(char *command)
 {
+	console_unblank();
 	_machine_restart(command);
 }
 
@@ -294,6 +297,7 @@
 
 void machine_halt(void)
 {
+	console_unblank();
 	_machine_halt();
 }
 
@@ -301,6 +305,7 @@
 
 void machine_power_off(void)
 {
+	console_unblank();
 	_machine_power_off();
 }
 
diff -urN linux-2.6/arch/s390/kernel/sys_s390.c linux-2.6-s390/arch/s390/kernel/sys_s390.c
--- linux-2.6/arch/s390/kernel/sys_s390.c	Sat Oct 25 20:43:26 2003
+++ linux-2.6-s390/arch/s390/kernel/sys_s390.c	Thu Nov 13 15:29:37 2003
@@ -325,3 +325,39 @@
 	return ret;
 }
 #endif /* CONFIG_ARCH_S390X */
+
+/*
+ * Wrapper function for sys_fadvise64/fadvise64_64
+ */
+#ifndef CONFIG_ARCH_S390X
+
+extern asmlinkage long sys_fadvise64(int, loff_t, size_t, int);
+
+asmlinkage long
+s390_fadvise64(int fd, u32 offset_high, u32 offset_low, size_t len, int advice)
+{
+	return sys_fadvise64(fd, (u64) offset_high << 32 | offset_low,
+			len, advice);
+}
+
+#endif
+
+extern asmlinkage long sys_fadvise64_64(int, loff_t, loff_t, int);
+
+struct fadvise64_64_args {
+	int fd;
+	long long offset;
+	long long len;
+	int advice;
+};
+
+asmlinkage long
+s390_fadvise64_64(struct fadvise64_64_args *args)
+{
+	struct fadvise64_64_args a;
+
+	if ( copy_from_user(&a, args, sizeof(a)) )
+		return -EFAULT;
+	return sys_fadvise64_64(a.fd, a.offset, a.len, a.advice);
+}
+
diff -urN linux-2.6/arch/s390/kernel/syscalls.S linux-2.6-s390/arch/s390/kernel/syscalls.S
--- linux-2.6/arch/s390/kernel/syscalls.S	Sat Oct 25 20:42:55 2003
+++ linux-2.6-s390/arch/s390/kernel/syscalls.S	Thu Nov 13 15:29:37 2003
@@ -15,7 +15,7 @@
 SYSCALL(sys_write,sys_write,sys32_write_wrapper)
 SYSCALL(sys_open,sys_open,sys32_open_wrapper)			/* 5 */
 SYSCALL(sys_close,sys_close,sys32_close_wrapper)
-SYSCALL(sys_restart_syscall,sys_restart_syscall,sys_ni_syscall)
+SYSCALL(sys_restart_syscall,sys_restart_syscall,sys_restart_syscall)
 SYSCALL(sys_creat,sys_creat,sys32_creat_wrapper)
 SYSCALL(sys_link,sys_link,sys32_link_wrapper)
 SYSCALL(sys_unlink,sys_unlink,sys32_unlink_wrapper)		/* 10 */
@@ -261,7 +261,7 @@
 SYSCALL(sys_epoll_ctl,sys_epoll_ctl,sys_epoll_ctl_wrapper)	/* 250 */
 SYSCALL(sys_epoll_wait,sys_epoll_wait,sys_epoll_wait_wrapper)
 SYSCALL(sys_set_tid_address,sys_set_tid_address,sys32_set_tid_address_wrapper)
-SYSCALL(sys_fadvise64,sys_fadvise64,sys_ni_syscall)
+SYSCALL(s390_fadvise64,sys_fadvise64_64,sys_ni_syscall)
 SYSCALL(sys_timer_create,sys_timer_create,sys_ni_syscall)
 SYSCALL(sys_timer_settime,sys_timer_settime,sys_ni_syscall)	/* 255 */
 SYSCALL(sys_timer_gettime,sys_timer_gettime,sys_ni_syscall)
@@ -272,3 +272,4 @@
 SYSCALL(sys_clock_getres,sys_clock_getres,sys_ni_syscall)
 SYSCALL(sys_clock_nanosleep,sys_clock_nanosleep,sys_ni_syscall)
 NI_SYSCALL							/* reserved for vserver */
+SYSCALL(s390_fadvise64_64,sys_fadvise64_64,sys_ni_syscall)
diff -urN linux-2.6/arch/s390/mm/fault.c linux-2.6-s390/arch/s390/mm/fault.c
--- linux-2.6/arch/s390/mm/fault.c	Sat Oct 25 20:44:25 2003
+++ linux-2.6-s390/arch/s390/mm/fault.c	Thu Nov 13 15:29:37 2003
@@ -538,8 +538,6 @@
 pfault_interrupt(struct pt_regs *regs, __u16 error_code)
 {
 	struct task_struct *tsk;
-	wait_queue_head_t queue;
-	wait_queue_head_t *qp;
 	__u16 subcode;
 
 	/*
@@ -557,42 +555,30 @@
 	 */
 	tsk = *(struct task_struct **) __LC_PFAULT_INTPARM;
 
-	/*
-	 * We got all needed information from the lowcore and can
-	 * now safely switch on interrupts.
-	 */
-	if (regs->psw.mask & PSW_MASK_PSTATE)
-		local_irq_enable();
-
 	if (subcode & 0x0080) {
 		/* signal bit is set -> a page has been swapped in by VM */
-		qp = (wait_queue_head_t *)
-			xchg(&tsk->thread.pfault_wait, -1);
-		if (qp != NULL) {
+		if (xchg(&tsk->thread.pfault_wait, -1) != 0) {
 			/* Initial interrupt was faster than the completion
 			 * interrupt. pfault_wait is valid. Set pfault_wait
 			 * back to zero and wake up the process. This can
 			 * safely be done because the task is still sleeping
 			 * and can't procude new pfaults. */
-			tsk->thread.pfault_wait = 0ULL;
-			wake_up(qp);
+			tsk->thread.pfault_wait = 0;
+			wake_up_process(tsk);
 		}
 	} else {
 		/* signal bit not set -> a real page is missing. */
-                init_waitqueue_head (&queue);
-		qp = (wait_queue_head_t *)
-			xchg(&tsk->thread.pfault_wait, (addr_t) &queue);
-		if (qp != NULL) {
+		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
+		if (xchg(&tsk->thread.pfault_wait, 1) != 0) {
 			/* Completion interrupt was faster than the initial
 			 * interrupt (swapped in a -1 for pfault_wait). Set
 			 * pfault_wait back to zero and exit. This can be
 			 * done safely because tsk is running in kernel 
 			 * mode and can't produce new pfaults. */
-			tsk->thread.pfault_wait = 0ULL;
-		}
-
-                /* go to sleep */
-                wait_event(queue, tsk->thread.pfault_wait == 0ULL);
+			tsk->thread.pfault_wait = 0;
+			set_task_state(tsk, TASK_RUNNING);
+		} else
+			set_tsk_need_resched(tsk);
 	}
 }
 #endif
diff -urN linux-2.6/include/asm-s390/bug.h linux-2.6-s390/include/asm-s390/bug.h
--- linux-2.6/include/asm-s390/bug.h	Sat Oct 25 20:44:12 2003
+++ linux-2.6-s390/include/asm-s390/bug.h	Thu Nov 13 15:29:37 2003
@@ -1,6 +1,8 @@
 #ifndef _S390_BUG_H
 #define _S390_BUG_H
 
+#include <linux/kernel.h>
+
 #define BUG() do { \
         printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
         __asm__ __volatile__(".long 0"); \
diff -urN linux-2.6/include/asm-s390/checksum.h linux-2.6-s390/include/asm-s390/checksum.h
--- linux-2.6/include/asm-s390/checksum.h	Sat Oct 25 20:42:46 2003
+++ linux-2.6-s390/include/asm-s390/checksum.h	Thu Nov 13 15:29:37 2003
@@ -70,7 +70,7 @@
 	__asm__ __volatile__ (
 		"0:  cksm %0,%1\n"    /* do checksum on longs */
 		"    jo   0b\n"
-                : "+&d" (sum), "+&a" (rp) : : "cc" );
+                : "+&d" (sum), "+&a" (rp) : : "cc", "memory" );
 #else /* __s390x__ */
 	__asm__ __volatile__ (
 		"    lgr  2,%1\n"    /* address in gpr 2 */
@@ -79,7 +79,7 @@
 		"    jo   0b\n"
                 : "+&d" (sum)
 		: "d" (buff), "d" (len)
-                : "cc", "2", "3" );
+                : "cc", "memory", "2", "3" );
 #endif /* __s390x__ */
 	return sum;
 }
diff -urN linux-2.6/include/asm-s390/mmu_context.h linux-2.6-s390/include/asm-s390/mmu_context.h
--- linux-2.6/include/asm-s390/mmu_context.h	Sat Oct 25 20:43:33 2003
+++ linux-2.6-s390/include/asm-s390/mmu_context.h	Thu Nov 13 15:29:37 2003
@@ -14,7 +14,7 @@
  */
 #define init_new_context(tsk,mm)        0
 
-#define destroy_context(mm)             flush_tlb_mm(mm)
+#define destroy_context(mm)             do { } while (0)
 
 static inline void enter_lazy_tlb(struct mm_struct *mm,
                                   struct task_struct *tsk)
diff -urN linux-2.6/include/asm-s390/pgalloc.h linux-2.6-s390/include/asm-s390/pgalloc.h
--- linux-2.6/include/asm-s390/pgalloc.h	Sat Oct 25 20:43:56 2003
+++ linux-2.6-s390/include/asm-s390/pgalloc.h	Thu Nov 13 15:29:37 2003
@@ -84,7 +84,11 @@
 	free_pages((unsigned long) pmd, 2);
 }
 
-#define __pmd_free_tlb(tlb,pmd) pmd_free(pmd)
+#define __pmd_free_tlb(tlb,pmd)			\
+	do {					\
+		tlb_flush_mmu(tlb, 0, 0);	\
+		pmd_free(pmd);			\
+	 } while (0)
 
 static inline void pgd_populate(struct mm_struct *mm, pgd_t *pgd, pmd_t *pmd)
 {
@@ -146,7 +150,7 @@
         __free_page(pte);
 }
 
-#define __pte_free_tlb(tlb,pte) tlb_remove_page((tlb),(pte))
+#define __pte_free_tlb(tlb,pte) tlb_remove_page(tlb,pte)
 
 /*
  * This establishes kernel virtual mappings (e.g., as a result of a
diff -urN linux-2.6/include/asm-s390/pgtable.h linux-2.6-s390/include/asm-s390/pgtable.h
--- linux-2.6/include/asm-s390/pgtable.h	Sat Oct 25 20:44:29 2003
+++ linux-2.6-s390/include/asm-s390/pgtable.h	Thu Nov 13 15:29:37 2003
@@ -29,6 +29,7 @@
  * the S390 page table tree.
  */
 #ifndef __ASSEMBLY__
+#include <asm/bug.h>
 #include <asm/processor.h>
 #include <linux/threads.h>
 
@@ -465,7 +466,9 @@
 
 extern inline pte_t pte_wrprotect(pte_t pte)
 {
-	pte_val(pte) |= _PAGE_RO;
+	/* Do not clobber _PAGE_INVALID_NONE pages!  */
+	if (!(pte_val(pte) & _PAGE_INVALID))
+		pte_val(pte) |= _PAGE_RO;
 	return pte;
 }
 
@@ -682,9 +685,9 @@
 	pte_t pte;
 	pte_val(pte) = (type << 1) | (offset << 12) | _PAGE_INVALID_SWAP;
 #ifndef __s390x__
-	pte_val(pte) &= 0x7ffff6fe;  /* better to be paranoid */
+	BUG_ON((pte_val(pte) & 0x80000901) != 0);
 #else /* __s390x__ */
-	pte_val(pte) &= 0xfffffffffffff6fe;  /* better to be paranoid */
+	BUG_ON((pte_val(pte) & 0x901) != 0);
 #endif /* __s390x__ */
 	return pte;
 }
diff -urN linux-2.6/include/asm-s390/setup.h linux-2.6-s390/include/asm-s390/setup.h
--- linux-2.6/include/asm-s390/setup.h	Sat Oct 25 20:44:41 2003
+++ linux-2.6-s390/include/asm-s390/setup.h	Thu Nov 13 15:29:37 2003
@@ -36,6 +36,7 @@
 #define MACHINE_HAS_MVPG	(machine_flags & 16)
 #define MACHINE_HAS_DIAG44	(machine_flags & 32)
 #define MACHINE_NEW_STIDP	(machine_flags & 64)
+#define MACHINE_HAS_IDTE	(machine_flags & 128)
 
 #ifndef __s390x__
 #define MACHINE_HAS_IEEE	(machine_flags & 2)
diff -urN linux-2.6/include/asm-s390/siginfo.h linux-2.6-s390/include/asm-s390/siginfo.h
--- linux-2.6/include/asm-s390/siginfo.h	Sat Oct 25 20:44:38 2003
+++ linux-2.6-s390/include/asm-s390/siginfo.h	Thu Nov 13 15:29:37 2003
@@ -14,6 +14,12 @@
 #define __ARCH_SI_PREAMBLE_SIZE (4 * sizeof(int))
 #endif
 
+#ifdef CONFIG_ARCH_S390X
+#define SIGEV_PAD_SIZE ((SIGEV_MAX_SIZE/sizeof(int)) - 4)
+#else
+#define SIGEV_PAD_SIZE ((SIGEV_MAX_SIZE/sizeof(int)) - 3)
+#endif
+
 #include <asm-generic/siginfo.h>
 
 /*
diff -urN linux-2.6/include/asm-s390/spinlock.h linux-2.6-s390/include/asm-s390/spinlock.h
--- linux-2.6/include/asm-s390/spinlock.h	Sat Oct 25 20:45:07 2003
+++ linux-2.6-s390/include/asm-s390/spinlock.h	Thu Nov 13 15:29:37 2003
@@ -217,7 +217,7 @@
 
 extern inline int _raw_write_trylock(rwlock_t *rw)
 {
-	unsigned int result, reg;
+	unsigned long result, reg;
 	
 	__asm__ __volatile__(
 #ifndef __s390x__
diff -urN linux-2.6/include/asm-s390/tlbflush.h linux-2.6-s390/include/asm-s390/tlbflush.h
--- linux-2.6/include/asm-s390/tlbflush.h	Sat Oct 25 20:44:53 2003
+++ linux-2.6-s390/include/asm-s390/tlbflush.h	Thu Nov 13 15:29:37 2003
@@ -99,17 +99,21 @@
 static inline void __flush_tlb_mm(struct mm_struct * mm)
 {
 	cpumask_t local_cpumask;
+
+	if (unlikely(cpus_empty(mm->cpu_vm_mask)))
+		return;
+	if (MACHINE_HAS_IDTE) {
+		asm volatile (".insn rrf,0xb98e0000,0,%0,%1,0"
+			      : : "a" (2048),
+			      "a" (__pa(mm->pgd)&PAGE_MASK) : "cc" );
+		return;
+	}
 	preempt_disable();
 	local_cpumask = cpumask_of_cpu(smp_processor_id());
-	if (cpus_equal(mm->cpu_vm_mask, local_cpumask)) {
-		/* mm was active on more than one cpu. */
-		if (mm == current->active_mm &&
-		    atomic_read(&mm->mm_users) == 1)
-			/* this cpu is the only one using the mm. */
-			mm->cpu_vm_mask = local_cpumask;
-		global_flush_tlb();
-	} else
+	if (cpus_equal(mm->cpu_vm_mask, local_cpumask))
 		local_flush_tlb();
+	else
+		global_flush_tlb();
 	preempt_enable();
 }
 
diff -urN linux-2.6/include/asm-s390/unistd.h linux-2.6-s390/include/asm-s390/unistd.h
--- linux-2.6/include/asm-s390/unistd.h	Sat Oct 25 20:45:06 2003
+++ linux-2.6-s390/include/asm-s390/unistd.h	Thu Nov 13 15:29:37 2003
@@ -259,8 +259,9 @@
 /*
  * Number 263 is reserved for vserver
  */
+#define __NR_fadvise64_64	264
 
-#define NR_syscalls 264
+#define NR_syscalls 265
 
 /* 
  * There are some system calls that are not present on 64 bit, some
