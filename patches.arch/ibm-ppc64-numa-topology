--- ./arch/ppc64/mm/numa.c.orig	Thu May  6 17:22:14 2004
+++ ./arch/ppc64/mm/numa.c	Thu May  6 20:27:35 2004
@@ -84,15 +84,101 @@ static struct device_node * __init find_
 	return NULL;
 }
 
+static int *of_get_associativity(struct device_node *dev)
+ {
+	int * result;
+	int len;
+	
+	result = get_property(dev, "ibm,associativity", &len);
+
+	if (len <= 0)
+		return NULL;
+
+	return result;
+}
+
+/*
+ * In theory, the "ibm,associativity" property may contain multiple 
+ * associativity lists because a resource may be multiply connected 
+ * into the machine.  This resource then has different associativity
+ * characteristics relative to its multiple connections.  We ignore
+ * this for now.  We also assume that all cpu and memory sets have
+ * their distances represented at a common level.  This won't be 
+ * true for heirarchical NUMA.
+ *
+ * This function answers the question:
+ * What is the most shallow level at which any memory or CPU group has
+ * any differrence in distance?
+ *
+ * More common levels mean that things are closer together.
+ *
+ * - Dave Hansen <haveblue@us.ibm.com>
+ */
+static int find_min_common_depth(void)
+{
+	int max_depth = 0xffff;
+	int min_common_depth = max_depth;
+	struct device_node *memory = NULL;
+	struct device_node *cpu;
+
+	/* Check that both memory and cpu have associativity information */
+	cpu = of_find_node_by_type(NULL, "cpu");
+	if (!cpu)
+		goto err;
+
+	memory = of_find_node_by_type(NULL, "memory");
+	if (!memory)
+		goto err;
+
+	for (; cpu; cpu = of_find_node_by_type(cpu, "cpu")) {
+		/*
+		 * The associativity arrays are pascal-string-style with t
+		 * he length as the first (0th) field. (self-inclusive)
+		 */
+		int *cpu_assoc = of_get_associativity(cpu);
+
+		if (!cpu_assoc)
+			goto err;
+
+		memory = of_find_node_by_type(NULL, "memory");
+		for (; memory; memory = of_find_node_by_type(memory, "memory")) {
+			int depth = 1;
+			int smallest_depth;
+			int *mem_assoc = of_get_associativity(memory);
+
+			if (!mem_assoc)
+				goto err;
+
+			/* 
+			 * if each cpu node and each memory node have 
+			 * the same length, this can go in the outer loop
+			 */
+			smallest_depth = min(cpu_assoc[0], mem_assoc[0]);
+
+			while ((depth <= smallest_depth) &&
+			       (cpu_assoc[depth] == mem_assoc[depth]))
+				depth++;
+
+			if (min_common_depth > depth)
+				min_common_depth = depth;
+		}
+	}
+	
+	if (min_common_depth == max_depth)
+		min_common_depth = 0;
+
+	return min_common_depth;
+err:
+	of_node_put(memory);
+	of_node_put(cpu);
+	return -1;
+}
+
 static int __init parse_numa_properties(void)
 {
 	struct device_node *cpu = NULL;
 	struct device_node *memory = NULL;
-	unsigned int *tmp;
-	int cpu_associativity;
-	int memory_associativity;
 	int depth;
-	int len;
 	int max_domain = 0;
 	long entries = lmb_end_of_DRAM() >> MEMORY_INCREMENT_SHIFT;
 	unsigned long i;
@@ -108,53 +194,25 @@ static int __init parse_numa_properties(
 	for (i = 0; i < entries ; i++)
 		numa_memory_lookup_table[i] = ARRAY_INITIALISER;
 
-	/* Check that both memory and cpu have associativity information */
-	cpu = of_find_node_by_type(NULL, "cpu");
-	if (!cpu)
-		return -1;
-
-	tmp = (int *)get_property(cpu, "ibm,associativity", &len);
-	if (!tmp || len <= 0) {
-		of_node_put(cpu);
-		return -1;
-	}
-	cpu_associativity = tmp[0];
-	of_node_put(cpu);
-
-	memory = of_find_node_by_type(NULL, "memory");
-	if (!memory)
-		return -1;
-
-	tmp = (int *)get_property(memory, "ibm,associativity", &len);
-	if (!tmp || len <= 0) {
-		of_node_put(memory);
-		return -1;
-	}
-	memory_associativity = tmp[0];
-	of_node_put(memory);
-
-	/* find common depth */
-	if (cpu_associativity < memory_associativity)
-		depth = cpu_associativity;
-	else
-		depth = memory_associativity;
-
+	depth = find_min_common_depth();
+	if (depth < 0)
+		return depth;
+	
 	for_each_cpu(i) {
 		int numa_domain;
 
 		cpu = find_cpu_node(i);
 
 		if (cpu) {
-			tmp = (int *)get_property(cpu, "ibm,associativity",
-						  &len);
-			if (tmp && (len >= depth)) {
+			tmp = of_get_associativity(cpu);
+			if (!tmp || (tmp[0] < depth)) {
 				numa_domain = tmp[depth];
-				of_node_put(cpu);
 			} else {
 				printk(KERN_ERR "WARNING: no NUMA "
 				       "information for cpu %ld\n", i);
 				numa_domain = 0;
 			}
+			of_node_put(cpu);
 
 			if (numa_domain >= MAX_NUMNODES) {
 				/*
@@ -210,9 +268,8 @@ new_range:
 		start = _ALIGN_DOWN(start, MEMORY_INCREMENT);
 		size = _ALIGN_UP(size, MEMORY_INCREMENT);
 
-		tmp = (unsigned int *)get_property(memory, "ibm,associativity",
-					   &len);
-		if (tmp && len >= depth) {
+		tmp = of_get_associativity(memory)
+		if (tmp && (tmp[0] >= depth)) {
 			numa_domain = tmp[depth];
 		} else {
 			printk(KERN_ERR "WARNING: no NUMA information for "
