diff -puN arch/ppc64/kernel/irq.c~irqstack_dynamic_allocation arch/ppc64/kernel/irq.c
--- linux-2.6.5-7.13-anton/arch/ppc64/kernel/irq.c~irqstack_dynamic_allocation	2004-05-04 00:31:12.202901984 +0000
+++ linux-2.6.5-7.13-anton-root/arch/ppc64/kernel/irq.c	2004-05-04 06:58:59.218983136 +0000
@@ -980,11 +980,6 @@ unsigned int real_irq_to_virt_slowpath(u
 #endif /* CONFIG_PPC_ISERIES */
 
 #ifdef CONFIG_IRQSTACKS
-static unsigned char softirq_stacks[NR_CPUS][THREAD_SIZE]
-	__attribute__((__aligned__(THREAD_SIZE)));
-static unsigned char hardirq_stacks[NR_CPUS][THREAD_SIZE] 
-	__attribute__((__aligned__(THREAD_SIZE)));
-
 struct thread_info *softirq_ctx[NR_CPUS];
 struct thread_info *hardirq_ctx[NR_CPUS];
 
@@ -993,14 +988,14 @@ void irq_ctx_init(void)
 	struct thread_info *tp;
 	int i;
 
-	for (i = 0; i < NR_CPUS; ++i) {
-		tp = (struct thread_info *) softirq_stacks[i];
-		softirq_ctx[i] = tp;
+	for (i = 0; i < NR_CPUS; i++) {
+		memset((void *)softirq_ctx[i], 0, THREAD_SIZE);
+		tp = softirq_ctx[i];
 		tp->cpu = i;
 		tp->preempt_count = SOFTIRQ_OFFSET;
 
-		tp = (struct thread_info *) hardirq_stacks[i];
-		hardirq_ctx[i] = tp;
+		memset((void *)hardirq_ctx[i], 0, THREAD_SIZE);
+		tp = hardirq_ctx[i];
 		tp->cpu = i;
 		tp->preempt_count = HARDIRQ_OFFSET;
 	}
diff -puN arch/ppc64/kernel/setup.c~irqstack_dynamic_allocation arch/ppc64/kernel/setup.c
--- linux-2.6.5-7.13-anton/arch/ppc64/kernel/setup.c~irqstack_dynamic_allocation	2004-05-04 06:41:09.818894912 +0000
+++ linux-2.6.5-7.13-anton-root/arch/ppc64/kernel/setup.c	2004-05-04 06:41:19.980947352 +0000
@@ -45,6 +45,7 @@
 #include <asm/btext.h>
 #include <asm/nvram.h>
 #include <asm/system.h>
+#include <asm/lmb.h>
 
 extern unsigned long klimit;
 /* extern void *stab; */
@@ -569,6 +570,25 @@ void __init ppc64_calibrate_delay(void)
 
 extern void (*calibrate_delay)(void);
 
+#ifdef CONFIG_IRQSTACKS
+static void __init irqstack_early_init(void)
+{
+	int i;
+
+	/* interrupt stacks must be under 256MB, we cannot afford to take SLB misses on them */
+	for (i = 0; i < NR_CPUS; i++) {
+		softirq_ctx[i] = (struct thread_info *)__va(lmb_alloc_base(THREAD_SIZE,
+					THREAD_SIZE, 0x10000000));
+		hardirq_ctx[i] = (struct thread_info *)__va(lmb_alloc_base(THREAD_SIZE,
+					THREAD_SIZE, 0x10000000));
+	}
+}
+#else
+static void __init irqstack_early_init(void)
+{
+}
+#endif
+
 /*
  * Called into from start_kernel, after lock_kernel has been called.
  * Initializes bootmem, which is unsed to manage page allocation until
@@ -614,6 +634,8 @@ void __init setup_arch(char **cmdline_p)
 	strlcpy(saved_command_line, cmd_line, sizeof(saved_command_line));
 	*cmdline_p = cmd_line;
 
+	irqstack_early_init();
+
 	/* set up the bootmem stuff with available memory */
 	do_init_bootmem();
 

_
