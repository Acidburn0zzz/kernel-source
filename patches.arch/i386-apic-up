Subject: Disable i386 APIC by default
From: ak@suse.de

Don't enable local APIC unless the "apic" option is specified on i386
UP kernels.

Index: linux-2.6.15/Documentation/kernel-parameters.txt
===================================================================
--- linux-2.6.15.orig/Documentation/kernel-parameters.txt
+++ linux-2.6.15/Documentation/kernel-parameters.txt
@@ -234,6 +234,12 @@ running once the system is up.
 	apm=		[APM] Advanced Power Management
 			See header of arch/i386/kernel/apm.c.
 
+	apic		[UP,APIC,i386] Tells the kernel to make use of the APIC on
+	                uniprocessor systems. When CONFIG_X86_APIC_OFF is set it 
+			needs this parameter to really activate it (needed to 
+			avoid problems with certain machines). This enables IO 
+			and local APICs.
+
 	applicom=	[HW]
 			Format: <mem>,<irq>
 
Index: linux-2.6.15/arch/i386/kernel/acpi/boot.c
===================================================================
--- linux-2.6.15.orig/arch/i386/kernel/acpi/boot.c
+++ linux-2.6.15/arch/i386/kernel/acpi/boot.c
@@ -814,6 +814,18 @@ static void __init acpi_process_madt(voi
 #ifdef CONFIG_X86_LOCAL_APIC
 	int count, error;
 
+	/* 
+	 * Warning, broken error handling here.
+	 * When X86_APIC_OFF is not set and the APIC initialization
+	 * later fails then the ACPI state will be all messed up.
+	 */
+#ifdef CONFIG_X86_APIC_OFF
+	if (enable_local_apic <= 0) { 
+		printk(KERN_INFO "ACPI: local apic disabled\n");
+		return;
+	}
+#endif	   
+
 	count = acpi_table_parse(ACPI_APIC, acpi_parse_madt);
 	if (count >= 1) {
 
Index: linux-2.6.15/arch/i386/kernel/apic.c
===================================================================
--- linux-2.6.15.orig/arch/i386/kernel/apic.c
+++ linux-2.6.15/arch/i386/kernel/apic.c
@@ -27,6 +27,7 @@
 #include <linux/sysdev.h>
 #include <linux/cpu.h>
 #include <linux/module.h>
+#include <linux/dmi.h>
 
 #include <asm/atomic.h>
 #include <asm/smp.h>
@@ -721,7 +722,11 @@ static void apic_pm_activate(void) { }
 
 static int __init apic_set_verbosity(char *str)
 {
-	if (strcmp("debug", str) == 0)
+	if (*str == '=') 
+		str++;
+	if (*str == 0) 
+		;/* parsed early already */
+	else if (strcmp("debug", str) == 0)
 		apic_verbosity = APIC_DEBUG;
 	else if (strcmp("verbose", str) == 0)
 		apic_verbosity = APIC_VERBOSE;
@@ -732,15 +737,20 @@ static int __init apic_set_verbosity(cha
 	return 0;
 }
 
-__setup("apic=", apic_set_verbosity);
+__setup("apic", apic_set_verbosity);
 
 static int __init detect_init_APIC (void)
 {
 	u32 h, l, features;
-
+#ifdef CONFIG_X86_APIC_OFF
+	/* Disabled by kernel option? */
+	if (enable_local_apic < 1)
+		return -1;
+#else
 	/* Disabled by kernel option? */
 	if (enable_local_apic < 0)
 		return -1;
+#endif
 
 	switch (boot_cpu_data.x86_vendor) {
 	case X86_VENDOR_AMD:
@@ -829,8 +839,6 @@ void __init init_apic_mappings(void)
 		apic_phys = mp_lapic_addr;
 
 	set_fixmap_nocache(FIX_APIC_BASE, apic_phys);
-	printk(KERN_DEBUG "mapped APIC to %08lx (%08lx)\n", APIC_BASE,
-	       apic_phys);
 
 	/*
 	 * Fetch the APIC ID of the BSP in case we have a
@@ -863,8 +871,6 @@ fake_ioapic_page:
 				ioapic_phys = __pa(ioapic_phys);
 			}
 			set_fixmap_nocache(idx, ioapic_phys);
-			printk(KERN_DEBUG "mapped IOAPIC to %08lx (%08lx)\n",
-			       __fix_to_virt(idx), ioapic_phys);
 			idx++;
 		}
 	}
@@ -1287,17 +1293,59 @@ fastcall void smp_error_interrupt(struct
 	irq_exit();
 }
 
+static int __init need_apic(struct dmi_system_id *d)
+{ 
+#ifdef CONFIG_X86_LOCAL_APIC
+	extern int enable_local_apic;
+	if (enable_local_apic == 0)  {
+		enable_local_apic = 1;
+		printk(
+KERN_INFO "%s detected. Enabling local APIC. Overwrite with \"nolapic\"\n",
+		       d->ident);
+#endif
+	}
+	return 0;
+} 
+
+static struct dmi_system_id __initdata apic_dmi_table[] = {
+	/* Systems that need APIC */
+	/* Multinode Summit systems need APIC to boot */
+	{ need_apic, "IBM x445", 
+	  { DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
+	    DMI_MATCH(DMI_PRODUCT_NAME, "xSeries 440") }},
+	{ need_apic, "IBM x445", 
+	  { DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
+	    DMI_MATCH(DMI_PRODUCT_NAME, "xSeries 445") }},
+	{ need_apic, "IBM x460",
+	  { DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
+	    DMI_MATCH(DMI_PRODUCT_NAME, "eserver xSeries 460")}},
+	{}
+};
+
+
 /*
  * This initializes the IO-APIC and APIC hardware if this is
  * a UP kernel.
  */
 int __init APIC_init_uniprocessor (void)
 {
+	dmi_check_system(apic_dmi_table);
+
+#ifdef CONFIG_X86_APIC_OFF
+	if (enable_local_apic <= 0) { 
+		clear_bit(X86_FEATURE_APIC, boot_cpu_data.x86_capability);
+		nr_ioapics = 0;
+		return -1;
+	}
+#endif
+
 	if (enable_local_apic < 0)
 		clear_bit(X86_FEATURE_APIC, boot_cpu_data.x86_capability);
 
-	if (!smp_found_config && !cpu_has_apic)
+	if (!smp_found_config && !cpu_has_apic) { 
+		nr_ioapics = 0;
 		return -1;
+	}
 
 	/*
 	 * Complain if the BIOS pretends there is one.
Index: linux-2.6.15/arch/i386/kernel/setup.c
===================================================================
--- linux-2.6.15.orig/arch/i386/kernel/setup.c
+++ linux-2.6.15/arch/i386/kernel/setup.c
@@ -865,6 +865,9 @@ static void __init parse_cmdline_early (
 		/* disable IO-APIC */
 		else if (!memcmp(from, "noapic", 6))
 			disable_ioapic_setup();
+ 		/* SUSE specific option */
+ 		else if (!memcmp(from, "apic", 4))
+ 		        lapic_enable();
 #endif /* CONFIG_X86_IO_APIC */
 #endif /* CONFIG_ACPI */
 
Index: linux-2.6.15/arch/i386/Kconfig
===================================================================
--- linux-2.6.15.orig/arch/i386/Kconfig
+++ linux-2.6.15/arch/i386/Kconfig
@@ -241,6 +241,15 @@ config X86_UP_APIC
 	  performance counters), and the NMI watchdog which detects hard
 	  lockups.
 
+config X86_APIC_OFF
+        bool "Disable local/IO APIC by default" 
+	depends on X86_LOCAL_APIC  && !SMP
+	default n
+	help
+	  When this option is enabled the IO/local APIC code is compiled in, but 
+	  only enabled when the kernel is booted with "apic" on the kernel 
+	  command line  or an DMI entry forced APIC mode. 
+
 config X86_UP_IOAPIC
 	bool "IO-APIC support on uniprocessors"
 	depends on X86_UP_APIC
Index: linux-2.6.15/arch/x86_64/kernel/apic.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/kernel/apic.c
+++ linux-2.6.15/arch/x86_64/kernel/apic.c
@@ -43,6 +43,9 @@ int apic_runs_main_timer;
 int apic_calibrate_pmtmr __initdata;
 
 int disable_apic_timer __initdata;
+/* just used to communicate with shared i386 code: */
+int enable_local_apic = 1; 
+
 
 /*
  * cpu_mask that denotes the CPUs that needs timer interrupt coming in as
@@ -1090,6 +1093,7 @@ int __init APIC_init_uniprocessor (void)
 	}
 	if (!cpu_has_apic) { 
 		disable_apic = 1;
+		enable_local_apic = -1; 
 		printk(KERN_INFO "Apic disabled by BIOS\n");
 		return -1;
 	}
@@ -1116,12 +1120,14 @@ int __init APIC_init_uniprocessor (void)
 
 static __init int setup_disableapic(char *str) 
 { 
+	enable_local_apic = -1;
 	disable_apic = 1;
 	return 0;
 } 
 
 static __init int setup_nolapic(char *str) 
 { 
+	enable_local_apic = -1;
 	disable_apic = 1;
 	return 0;
 } 
Index: linux-2.6.15/include/asm-i386/mach-default/mach_apic.h
===================================================================
--- linux-2.6.15.orig/include/asm-i386/mach-default/mach_apic.h
+++ linux-2.6.15/include/asm-i386/mach-default/mach_apic.h
@@ -56,8 +56,10 @@ static inline physid_mask_t ioapic_phys_
 
 static inline void clustered_apic_check(void)
 {
+#ifdef CONFIG_SMP
 	printk("Enabling APIC mode:  %s.  Using %d I/O APICs\n",
 					"Flat", nr_ioapics);
+#endif
 }
 
 static inline int multi_timer_check(int apic, int irq)
