From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: zfcp: queue_full is lacking the entry for qdio utilization
References: bnc#466462

Symptom:     ziomon fails with an error message indicating an outdated kernel
Problem:     queue_full is missing an additional entry that gives the
             qdio utilization. Without this entry, the scsi performance
             dara collection feature does not work at all.
Solution:    Add the missing attribute to queue_full.

Acked-by: John Jolly <jjolly@suse.de>

---

 drivers/s390/scsi/zfcp_aux.c   |    1 +
 drivers/s390/scsi/zfcp_def.h   |    3 +++
 drivers/s390/scsi/zfcp_qdio.c  |   20 ++++++++++++++++++++
 drivers/s390/scsi/zfcp_sysfs.c |    3 ++-
 4 files changed, 26 insertions(+), 1 deletion(-)

--- a/drivers/s390/scsi/zfcp_aux.c
+++ b/drivers/s390/scsi/zfcp_aux.c
@@ -500,6 +500,7 @@ int zfcp_adapter_enqueue(struct ccw_devi
 	spin_lock_init(&adapter->scsi_dbf_lock);
 	spin_lock_init(&adapter->rec_dbf_lock);
 	spin_lock_init(&adapter->req_q_lock);
+	spin_lock_init(&adapter->qdio_stat_lock);
 
 	rwlock_init(&adapter->erp_lock);
 	rwlock_init(&adapter->abort_lock);
--- a/drivers/s390/scsi/zfcp_def.h
+++ b/drivers/s390/scsi/zfcp_def.h
@@ -472,6 +472,9 @@ struct zfcp_adapter {
 	spinlock_t		req_q_lock;	   /* for operations on queue */
 	int			req_q_pci_batch;   /* SBALs since PCI indication
 						      was last set */
+	ktime_t			req_q_time; /* time of last fill level change */
+	u64			req_q_util; /* for accounting */
+	spinlock_t		qdio_stat_lock;
 	u32			fsf_req_seq_no;	   /* FSF cmnd seq number */
 	wait_queue_head_t	request_wq;	   /* can be used to wait for
 						      more avaliable SBALs */
--- a/drivers/s390/scsi/zfcp_qdio.c
+++ b/drivers/s390/scsi/zfcp_qdio.c
@@ -76,6 +76,23 @@ static void zfcp_qdio_zero_sbals(struct 
 	}
 }
 
+/* this needs to be called prior to updating the queue fill level */
+static void zfcp_qdio_account(struct zfcp_adapter *adapter)
+{
+	ktime_t now;
+	s64 span;
+	int free, used;
+
+	spin_lock(&adapter->qdio_stat_lock);
+	now = ktime_get();
+	span = ktime_us_delta(now, adapter->req_q_time);
+	free = max(0, atomic_read(&adapter->req_q.count));
+	used = QDIO_MAX_BUFFERS_PER_Q - free;
+	adapter->req_q_util += used * span;
+	adapter->req_q_time = now;
+	spin_unlock(&adapter->qdio_stat_lock);
+}
+
 static void zfcp_qdio_int_req(struct ccw_device *cdev, unsigned int qdio_err,
 			      int queue_no, int first, int count,
 			      unsigned long parm)
@@ -92,6 +109,7 @@ static void zfcp_qdio_int_req(struct ccw
 	/* cleanup all SBALs being program-owned now */
 	zfcp_qdio_zero_sbals(queue->sbal, first, count);
 
+	zfcp_qdio_account(adapter);
 	atomic_add(count, &queue->count);
 	wake_up(&adapter->request_wq);
 }
@@ -358,6 +376,8 @@ int zfcp_qdio_send(struct zfcp_fsf_req *
 		sbale->flags |= SBAL_FLAGS0_PCI;
 	}
 
+	zfcp_qdio_account(adapter);
+
 	retval = do_QDIO(adapter->ccw_device, QDIO_FLAG_SYNC_OUTPUT, 0, first,
 			 count);
 	if (unlikely(retval)) {
--- a/drivers/s390/scsi/zfcp_sysfs.c
+++ b/drivers/s390/scsi/zfcp_sysfs.c
@@ -486,7 +486,8 @@ static ssize_t zfcp_sysfs_adapter_q_full
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *) scsi_host->hostdata[0];
 
-	return sprintf(buf, "%d\n", atomic_read(&adapter->qdio_outb_full));
+	return sprintf(buf, "%d %llu\n", atomic_read(&adapter->qdio_outb_full),
+		       (unsigned long long)adapter->req_q_util);
 }
 static DEVICE_ATTR(queue_full, S_IRUGO, zfcp_sysfs_adapter_q_full_show, NULL);
 
