diffstat:
 drivers/s390/scsi/zfcp_aux.c           |   92 ++++---------
 drivers/s390/scsi/zfcp_ccw.c           |    7 -
 drivers/s390/scsi/zfcp_def.h           |   14 --
 drivers/s390/scsi/zfcp_erp.c           |   14 --
 drivers/s390/scsi/zfcp_ext.h           |    7 -
 drivers/s390/scsi/zfcp_fsf.c           |  116 +++++++++-------
 drivers/s390/scsi/zfcp_qdio.c          |   52 ++++---
 drivers/s390/scsi/zfcp_scsi.c          |  228 +++------------------------------
 drivers/s390/scsi/zfcp_sysfs_adapter.c |   11 +
 drivers/s390/scsi/zfcp_sysfs_port.c    |   26 +++
 drivers/s390/scsi/zfcp_sysfs_unit.c    |   14 +-
 11 files changed, 213 insertions(+), 368 deletions(-)

diff -urN linux-2.6/drivers/s390/scsi/zfcp_aux.c linux-2.6-s390/drivers/s390/scsi/zfcp_aux.c
--- linux-2.6/drivers/s390/scsi/zfcp_aux.c	Sat Oct 25 20:45:00 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_aux.c	Thu Nov 13 15:29:43 2003
@@ -28,7 +28,7 @@
  */
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_AUX_REVISION "$Revision: 1.65 $"
+#define ZFCP_AUX_REVISION "$Revision: 1.76 $"
 
 /********************** INCLUDES *********************************************/
 
@@ -285,7 +285,7 @@
 	debug_event(adapter->cmd_dbf, level, &scsi_cmnd->result, sizeof (u32));
 	debug_event(adapter->cmd_dbf, level, &scsi_cmnd,
 		    sizeof (unsigned long));
-	if (fsf_req) {
+	if (likely(fsf_req)) {
 		debug_event(adapter->cmd_dbf, level, &fsf_req,
 			    sizeof (unsigned long));
 		debug_event(adapter->cmd_dbf, level, &fsf_req->seq_no,
@@ -360,6 +360,7 @@
 	goto out;
 
  out_ccw_register:
+	unregister_reboot_notifier(&zfcp_data.reboot_notifier);
 #ifdef ZFCP_STAT_REQSIZES
 	zfcp_statistics_clear_all();
 #endif
@@ -571,6 +572,7 @@
 	write_unlock_irq(&zfcp_data.config_lock);
 
 	port->units++;
+	zfcp_port_get(port);
 
 	return unit;
 }
@@ -763,17 +765,10 @@
 	/* initialize abort lock */
 	rwlock_init(&adapter->abort_lock);
 
-	/* initialise scsi faking structures */
-	rwlock_init(&adapter->fake_list_lock);
-	init_timer(&adapter->fake_scsi_timer);
-
 	/* initialise some erp stuff */
 	init_waitqueue_head(&adapter->erp_thread_wqh);
 	init_waitqueue_head(&adapter->erp_done_wqh);
 
-	/* notification when there are no outstanding SCSI commands */
-	init_waitqueue_head(&adapter->scsi_reqs_active_wq);
-
 	/* initialize lock of associated request queue */
 	rwlock_init(&adapter->request_queue.queue_lock);
 
@@ -1149,6 +1144,7 @@
 	write_unlock_irq(&zfcp_data.config_lock);
 
 	adapter->ports++;
+	zfcp_adapter_get(adapter);
 
 	return port;
 }
@@ -1193,7 +1189,6 @@
 	/* set special D_ID */
 	port->d_id = ZFCP_DID_NAMESERVER;
 	adapter->nameserver_port = port;
-	zfcp_adapter_get(adapter);
 	zfcp_port_put(port);
 
 	return 0;
@@ -1216,9 +1211,9 @@
 	struct fcp_rscn_head *fcp_rscn_head;
 	struct fcp_rscn_element *fcp_rscn_element;
 	struct zfcp_port *port;
-	int i;
-	int reopen_unknown = 0;
-	int no_entries;
+	u16 i;
+	u16 no_entries;
+	u32 range_mask;
 	unsigned long flags;
 
 	fcp_rscn_head = (struct fcp_rscn_head *) status_buffer->payload;
@@ -1232,56 +1227,57 @@
 
 	debug_text_event(adapter->erp_dbf, 1, "unsol_els_rscn:");
 	for (i = 1; i < no_entries; i++) {
-		int known;
-		int range_mask;
-		int no_notifications;
-
-		range_mask = 0;
-		no_notifications = 0;
-		known = 0;
 		/* skip head and start with 1st element */
 		fcp_rscn_element++;
 		switch (fcp_rscn_element->addr_format) {
 		case ZFCP_PORT_ADDRESS:
 			ZFCP_LOG_FLAGS(1, "ZFCP_PORT_ADDRESS\n");
 			range_mask = ZFCP_PORTS_RANGE_PORT;
-			no_notifications = 1;
 			break;
 		case ZFCP_AREA_ADDRESS:
 			ZFCP_LOG_FLAGS(1, "ZFCP_AREA_ADDRESS\n");
-			/* skip head and start with 1st element */
 			range_mask = ZFCP_PORTS_RANGE_AREA;
-			no_notifications = ZFCP_NO_PORTS_PER_AREA;
 			break;
 		case ZFCP_DOMAIN_ADDRESS:
 			ZFCP_LOG_FLAGS(1, "ZFCP_DOMAIN_ADDRESS\n");
 			range_mask = ZFCP_PORTS_RANGE_DOMAIN;
-			no_notifications = ZFCP_NO_PORTS_PER_DOMAIN;
 			break;
 		case ZFCP_FABRIC_ADDRESS:
 			ZFCP_LOG_FLAGS(1, "ZFCP_FABRIC_ADDRESS\n");
 			range_mask = ZFCP_PORTS_RANGE_FABRIC;
-			no_notifications = ZFCP_NO_PORTS_PER_FABRIC;
 			break;
 		default:
-			/* cannot happen */
-			break;
+			ZFCP_LOG_INFO("Received RSCN with unknown "
+				      "address format.\n");
+			continue;
 		}
 		read_lock_irqsave(&zfcp_data.config_lock, flags);
 		list_for_each_entry(port, &adapter->port_list_head, list) {
+			if (atomic_test_mask
+			    (ZFCP_STATUS_PORT_NAMESERVER, &port->status))
+				continue;
 			/* Do we know this port? If not skip it. */
 			if (!atomic_test_mask
-			    (ZFCP_STATUS_PORT_DID_DID, &port->status))
+			    (ZFCP_STATUS_PORT_DID_DID, &port->status)) {
+				ZFCP_LOG_INFO
+					("Received state change notification."
+					 "Trying to open the port with wwpn "
+					 "0x%Lx. Hope it's there now.\n",
+					 port->wwpn);
+				debug_text_event(adapter->erp_dbf, 1,
+						 "unsol_els_rscnu:");
+				zfcp_erp_port_reopen(port,
+						     ZFCP_STATUS_COMMON_ERP_FAILED);
 				continue;
+			}
+
 			/*
 			 * FIXME: race: d_id might being invalidated
 			 * (...DID_DID reset)
 			 */
 			if ((port->d_id & range_mask)
 			    == (fcp_rscn_element->nport_did & range_mask)) {
-				known++;
-				ZFCP_LOG_TRACE("known=%d, reopen did 0x%x\n",
-					       known,
+				ZFCP_LOG_TRACE("reopen did 0x%x\n",
 					       fcp_rscn_element->nport_did);
 				/*
 				 * Unfortunately, an RSCN does not specify the
@@ -1303,36 +1299,6 @@
 			}
 		}
 		read_unlock_irqrestore(&zfcp_data.config_lock, flags);
-		ZFCP_LOG_TRACE("known %d, no_notifications %d\n",
-			       known, no_notifications);
-		if (known < no_notifications) {
-			ZFCP_LOG_DEBUG
-			    ("At least one unknown port changed state. "
-			     "Unknown ports need to be reopened.\n");
-			reopen_unknown = 1;
-		}
-	}			// for (i=1; i < no_entries; i++)
-
-	if (reopen_unknown) {
-		ZFCP_LOG_DEBUG("At least one unknown did "
-			       "underwent a state change.\n");
-		read_lock_irqsave(&zfcp_data.config_lock, flags);
-		list_for_each_entry(port, &adapter->port_list_head, list) {
-			if (!atomic_test_mask((ZFCP_STATUS_PORT_DID_DID
-					       | ZFCP_STATUS_PORT_NAMESERVER),
-					      &port->status)) {
-				ZFCP_LOG_INFO
-				    ("Received state change notification."
-				     "Trying to open the port with wwpn "
-				     "0x%Lx. Hope it's there now.\n",
-				     port->wwpn);
-				debug_text_event(adapter->erp_dbf, 1,
-						 "unsol_els_rscnu:");
-				zfcp_erp_port_reopen(port,
-						     ZFCP_STATUS_COMMON_ERP_FAILED);
-			}
-		}
-		read_unlock_irqrestore(&zfcp_data.config_lock, flags);
 	}
 }
 
@@ -1469,7 +1435,7 @@
 	struct zfcp_adapter *adapter = fsf_req->adapter;
 	int retval = 0;
 
-	data->outbuf = kmalloc(2 * sizeof (struct fc_ct_iu), GFP_KERNEL);
+	data->outbuf = kmalloc(2 * sizeof (struct fc_ct_iu), GFP_ATOMIC);
 	if (data->outbuf) {
 		memset(data->outbuf, 0, 2 * sizeof (struct fc_ct_iu));
 	} else {
@@ -1479,7 +1445,7 @@
 			       "adapter %s directly.. trying emergency pool\n",
 			       zfcp_get_busid_by_adapter(adapter));
 		data->outbuf =
-		    mempool_alloc(adapter->pool.nameserver, GFP_KERNEL);
+		    mempool_alloc(adapter->pool.nameserver, GFP_ATOMIC);
 		if (!data->outbuf) {
 			ZFCP_LOG_DEBUG
 				("Out of memory. Could not get emergency "
diff -urN linux-2.6/drivers/s390/scsi/zfcp_ccw.c linux-2.6-s390/drivers/s390/scsi/zfcp_ccw.c
--- linux-2.6/drivers/s390/scsi/zfcp_ccw.c	Sat Oct 25 20:43:13 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_ccw.c	Thu Nov 13 15:29:43 2003
@@ -25,7 +25,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_CCW_C_REVISION "$Revision: 1.33 $"
+#define ZFCP_CCW_C_REVISION "$Revision: 1.35 $"
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -90,7 +90,7 @@
  *
  * This function gets called by the common i/o layer and removes an adapter
  * from the system. Task of this function is to get rid of all units and
- * ports that belong to this adapter. And addition all resources of this
+ * ports that belong to this adapter. And in addition all resources of this
  * adapter will be freed too.
  */
 static int
@@ -119,9 +119,12 @@
 	list_for_each_entry_safe(port, p, &adapter->port_remove_lh, list) {
 		list_for_each_entry_safe(unit, u, &port->unit_remove_lh, list) {
 			zfcp_unit_wait(unit);
+			zfcp_sysfs_unit_remove_files(&unit->sysfs_device);
 			device_unregister(&unit->sysfs_device);
 		}
 		zfcp_port_wait(port);
+		zfcp_sysfs_port_remove_files(&port->sysfs_device,
+					     atomic_read(&port->status));
 		device_unregister(&port->sysfs_device);
 	}
 	zfcp_adapter_wait(adapter);
diff -urN linux-2.6/drivers/s390/scsi/zfcp_def.h linux-2.6-s390/drivers/s390/scsi/zfcp_def.h
--- linux-2.6/drivers/s390/scsi/zfcp_def.h	Sat Oct 25 20:43:50 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_def.h	Thu Nov 13 15:35:06 2003
@@ -34,7 +34,7 @@
 #ifdef __KERNEL__
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_DEF_REVISION "$Revision: 1.41 $"
+#define ZFCP_DEF_REVISION "$Revision: 1.45 $"
 
 /*************************** INCLUDES *****************************************/
 
@@ -64,7 +64,6 @@
 typedef u32 scsi_id_t;
 typedef u32 scsi_lun_t;
 
-#define ZFCP_FAKE_SCSI_COMPLETION_TIME	        (HZ / 3)
 #define ZFCP_ERP_SCSI_LOW_MEM_TIMEOUT           (100*HZ)
 #define ZFCP_SCSI_ER_TIMEOUT                    (100*HZ)
 #define ZFCP_SCSI_HOST_FLUSH_TIMEOUT            (1*HZ)
@@ -470,7 +469,6 @@
 #define ZFCP_STATUS_ADAPTER_ERP_THREAD_KILL	0x00000080
 #define ZFCP_STATUS_ADAPTER_ERP_PENDING		0x00000100
 #define ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED	0x00000200
-#define ZFCP_STATUS_ADAPTER_QUEUECOMMAND_BLOCK	0x00000400 
 
 #define ZFCP_STATUS_ADAPTER_SCSI_UP			\
 		(ZFCP_STATUS_COMMON_UNBLOCKED |	\
@@ -676,10 +674,7 @@
 	u32			hydra_version;	   /* Hydra version */
 	u32			fsf_lic_version;
 	struct Scsi_Host	*scsi_host;	   /* Pointer to mid-layer */
-        Scsi_Cmnd               *first_fake_cmnd;  /* Packets in flight list */
-	rwlock_t		fake_list_lock;    /* Lock for the above */
-	struct timer_list       fake_scsi_timer;   /* Starts processing of
-						      faked commands */
+
 	unsigned char		name[9];
 	struct list_head	port_list_head;	   /* remote port list */
 	struct list_head        port_remove_lh;    /* head of ports to be
@@ -692,9 +687,6 @@
 	rwlock_t		fsf_req_list_lock; /* lock for ops on list of
 						      FSF requests */
         atomic_t       		fsf_reqs_active;   /* # active FSF reqs */
-        atomic_t       		scsi_reqs_active;  /* # active SCSI reqs */
-	wait_queue_head_t	scsi_reqs_active_wq; /* can be used to wait for
-							fsf_reqs_active chngs */
 	struct zfcp_qdio_queue	request_queue;	   /* request queue */
 	u32			fsf_req_seq_no;	   /* FSF cmnd seq number */
 	wait_queue_head_t	request_wq;	   /* can be used to wait for
@@ -857,7 +849,7 @@
 
 #ifndef atomic_test_mask
 #define atomic_test_mask(mask, target) \
-           (atomic_read(target) & mask)
+           ((atomic_read(target) & mask) == mask)
 #endif
 
 extern void _zfcp_hex_dump(char *, int);
diff -urN linux-2.6/drivers/s390/scsi/zfcp_erp.c linux-2.6-s390/drivers/s390/scsi/zfcp_erp.c
--- linux-2.6/drivers/s390/scsi/zfcp_erp.c	Sat Oct 25 20:43:04 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_erp.c	Thu Nov 13 15:29:43 2003
@@ -30,7 +30,7 @@
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_ERP
 #define ZFCP_LOG_AREA_PREFIX		ZFCP_LOG_AREA_PREFIX_ERP
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_ERP_REVISION "$Revision: 1.33 $"
+#define ZFCP_ERP_REVISION "$Revision: 1.34 $"
 
 #include "zfcp_ext.h"
 
@@ -1773,9 +1773,8 @@
 	struct zfcp_port *port;
 
 	list_for_each_entry(port, &adapter->port_list_head, list)
-	    if (atomic_test_mask(ZFCP_STATUS_PORT_NAMESERVER, &port->status)
-		!= ZFCP_STATUS_PORT_NAMESERVER)
-		zfcp_erp_port_reopen_internal(port, clear_mask);
+		if (!atomic_test_mask(ZFCP_STATUS_PORT_NAMESERVER, &port->status))
+			zfcp_erp_port_reopen_internal(port, clear_mask);
 
 	return retval;
 }
@@ -2333,8 +2332,8 @@
 		 * open flag is unset - however, this is for readabilty ...
 		 */
 		if (atomic_test_mask((ZFCP_STATUS_PORT_PHYS_OPEN |
-				      ZFCP_STATUS_COMMON_OPEN), &port->status)
-		    == (ZFCP_STATUS_PORT_PHYS_OPEN | ZFCP_STATUS_COMMON_OPEN)) {
+				      ZFCP_STATUS_COMMON_OPEN),
+			             &port->status)) {
 			ZFCP_LOG_DEBUG("Port wwpn=0x%Lx is open -> trying "
 				       " close physical\n",
 				       port->wwpn);
@@ -2433,8 +2432,7 @@
 	int retval;
 
 	if (atomic_test_mask(ZFCP_STATUS_PORT_NAMESERVER,
-			     &erp_action->port->status)
-	    == ZFCP_STATUS_PORT_NAMESERVER)
+			     &erp_action->port->status))
 		retval = zfcp_erp_port_strategy_open_nameserver(erp_action);
 	else
 		retval = zfcp_erp_port_strategy_open_common(erp_action);
diff -urN linux-2.6/drivers/s390/scsi/zfcp_ext.h linux-2.6-s390/drivers/s390/scsi/zfcp_ext.h
--- linux-2.6/drivers/s390/scsi/zfcp_ext.h	Sat Oct 25 20:43:11 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_ext.h	Thu Nov 13 15:35:22 2003
@@ -30,7 +30,7 @@
 #ifndef ZFCP_EXT_H
 #define ZFCP_EXT_H
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_EXT_REVISION "$Revision: 1.33 $"
+#define ZFCP_EXT_REVISION "$Revision: 1.36 $"
 
 #ifdef __KERNEL__
 
@@ -44,7 +44,9 @@
 extern int  zfcp_sysfs_adapter_create_files(struct device *);
 extern void zfcp_sysfs_adapter_remove_files(struct device *);
 extern int  zfcp_sysfs_port_create_files(struct device *, u32);
+extern void zfcp_sysfs_port_remove_files(struct device *, u32);
 extern int  zfcp_sysfs_unit_create_files(struct device *);
+extern void zfcp_sysfs_unit_remove_files(struct device *);
 extern void zfcp_sysfs_port_release(struct device *);
 extern int  zfcp_sysfs_port_shutdown(struct zfcp_port *);
 extern void zfcp_sysfs_unit_release(struct device *);
@@ -112,9 +114,6 @@
 extern int  zfcp_adapter_scsi_register(struct zfcp_adapter *);
 extern void zfcp_adapter_scsi_unregister(struct zfcp_adapter *);
 extern void zfcp_scsi_block_requests(struct Scsi_Host *);
-extern void zfcp_scsi_insert_into_fake_queue(struct zfcp_adapter *,
-					     Scsi_Cmnd *);
-extern void zfcp_scsi_process_and_clear_fake_queue(unsigned long);
 extern int  zfcp_create_sbals_from_sg(struct zfcp_fsf_req *,
 				     Scsi_Cmnd *, char, int, int);
 extern void zfcp_set_fcp_dl(struct fcp_cmnd_iu *, fcp_dl_t);
diff -urN linux-2.6/drivers/s390/scsi/zfcp_fsf.c linux-2.6-s390/drivers/s390/scsi/zfcp_fsf.c
--- linux-2.6/drivers/s390/scsi/zfcp_fsf.c	Sat Oct 25 20:44:07 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_fsf.c	Thu Nov 13 15:29:43 2003
@@ -28,7 +28,7 @@
  */
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_FSF_C_REVISION "$Revision: 1.12 $"
+#define ZFCP_FSF_C_REVISION "$Revision: 1.15 $"
 
 #include "zfcp_ext.h"
 
@@ -101,7 +101,8 @@
 	case FSF_QTCB_ABORT_FCP_CMND:
 		fsf_req = zfcp_fsf_req_get(kmalloc_flags,
 					   adapter->pool.fcp_command_fsf);
-		if (fsf_req && (fsf_req->status & ZFCP_STATUS_FSFREQ_POOL)) {
+		if (unlikely(fsf_req &&
+		             (fsf_req->status & ZFCP_STATUS_FSFREQ_POOL))) {
 			/*
 			 * watch low mem buffer
 			 * Note: If the command is reset or aborted, two
@@ -116,7 +117,8 @@
 		}
 #ifdef ZFCP_DEBUG_REQUESTS
 		debug_text_event(adapter->req_dbf, 5, "fsfa_fcp");
-		if (fsf_req && (fsf_req->status & ZFCP_STATUS_FSFREQ_POOL))
+		if (unlikely(fsf_req &&
+		             (fsf_req->status & ZFCP_STATUS_FSFREQ_POOL)))
 			debug_text_event(adapter->req_dbf, 5, "fsfa_pl");
 #endif /* ZFCP_DEBUG_REQUESTS */
 		break;
@@ -158,7 +160,7 @@
 				"(debug info 0x%x)\n", fsf_cmd);
 	}			//switch(fsf_cmd)
 
-	if (!fsf_req) {
+	if (unlikely(!fsf_req)) {
 		ZFCP_LOG_DEBUG("error: Out of memory. Allocation of FSF "
 			       "request structure failed\n");
 	} else {
@@ -171,7 +173,7 @@
 
 #ifdef ZFCP_DEBUG_REQUESTS
 	debug_event(adapter->req_dbf, 5, &fsf_req, sizeof (unsigned long));
-	if (fsf_req->qtcb)
+	if (likely(fsf_req->qtcb))
 		debug_event(adapter->req_dbf, 5, &fsf_req->qtcb,
 			    sizeof (unsigned long));
 #endif				/* ZFCP_DEBUG_REQUESTS */
@@ -198,7 +200,7 @@
 
 	case FSF_QTCB_FCP_CMND:
 	case FSF_QTCB_ABORT_FCP_CMND:
-		if (fsf_req->status & ZFCP_STATUS_FSFREQ_POOL) {
+		if (unlikely(fsf_req->status & ZFCP_STATUS_FSFREQ_POOL)) {
 			del_timer(&adapter->pool.fcp_command_fsf_timer);
 			mempool_free(fsf_req, adapter->pool.fcp_command_fsf);
 		} else
@@ -299,7 +301,7 @@
 	/* do some statistics */
 	atomic_dec(&adapter->fsf_reqs_active);
 
-	if (fsf_req->fsf_command == FSF_QTCB_UNSOLICITED_STATUS) {
+	if (unlikely(fsf_req->fsf_command == FSF_QTCB_UNSOLICITED_STATUS)) {
 		ZFCP_LOG_DEBUG("Status read response received\n");
 		/*
 		 * Note: all cleanup handling is done in the callchain of
@@ -314,7 +316,7 @@
 	 * fsf_req may be deleted due to waking up functions, so 
 	 * cleanup is saved here and used later 
 	 */
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_CLEANUP)
+	if (likely(fsf_req->status & ZFCP_STATUS_FSFREQ_CLEANUP))
 		cleanup = 1;
 	else
 		cleanup = 0;
@@ -322,7 +324,7 @@
 	fsf_req->status |= ZFCP_STATUS_FSFREQ_COMPLETED;
 
 	/* cleanup request if requested by initiator */
-	if (cleanup) {
+	if (likely(cleanup)) {
 		ZFCP_LOG_TRACE("removing FSF request 0x%lx\n",
 			       (unsigned long) fsf_req);
 		/*
@@ -334,6 +336,16 @@
 		/* notify initiator waiting for the requests completion */
 		ZFCP_LOG_TRACE("waking initiator of FSF request 0x%lx\n",
 			       (unsigned long) fsf_req);
+		/*
+		 * FIXME: Race! We must not access fsf_req here as it might have been
+		 * cleaned up already due to the set ZFCP_STATUS_FSFREQ_COMPLETED
+		 * flag. It's an improbable case. But, we have the same paranoia for
+		 * the cleanup flag already.
+		 * Might better be handled using complete()?
+		 * (setting the flag and doing wakeup ought to be atomic
+		 *  with regard to checking the flag as long as waitqueue is
+		 *  part of the to be released structure)
+		 */
 		wake_up(&fsf_req->completion_wq);
 	}
 
@@ -372,7 +384,7 @@
 	}
 
 	/* log additional information provided by FSF (if any) */
-	if (fsf_req->qtcb->header.log_length) {
+	if (unlikely(fsf_req->qtcb->header.log_length)) {
 		/* do not trust them ;-) */
 		if (fsf_req->qtcb->header.log_start > ZFCP_QTCB_SIZE) {
 			ZFCP_LOG_NORMAL
@@ -686,7 +698,7 @@
 {
 	int retval = 0;
 
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_ERROR) {
+	if (unlikely(fsf_req->status & ZFCP_STATUS_FSFREQ_ERROR)) {
 		goto skip_fsfstatus;
 	}
 
@@ -835,7 +847,7 @@
 {
 	int retval = 0;
 
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_ERROR) {
+	if (unlikely(fsf_req->status & ZFCP_STATUS_FSFREQ_ERROR)) {
 		ZFCP_LOG_TRACE("fsf_req=0x%lx, QTCB=0x%lx\n",
 			       (unsigned long) fsf_req,
 			       (unsigned long) (fsf_req->qtcb));
@@ -1996,6 +2008,20 @@
 				ZFCP_STATUS_PORT_PHYS_OPEN, &port->status);
 		retval = 0;
 		/* check whether D_ID has changed during open */
+		/*
+		 * FIXME: This check is not airtight, as the FCP channel does
+		 * not monitor closures of target port connections caused on
+		 * the remote side. Thus, they might miss out on invalidating
+		 * locally cached WWPNs (and other N_Port parameters) of gone
+		 * target ports. So, our heroic attempt to make things safe
+		 * could be undermined by 'open port' response data tagged with
+		 * obsolete WWPNs. Another reason to monitor potential
+		 * connection closures ourself at least (by interpreting
+		 * incoming ELS' and unsolicited status). It just crosses my
+		 * mind that one should be able to cross-check by means of
+		 * another GID_PN straight after a port has been opened.
+		 * Alternately, an ADISC/PDISC ELS should suffice, as well.
+		 */
 		plogi = (struct fsf_plogi *) fsf_req->qtcb->bottom.support.els;
 		if (!atomic_test_mask(ZFCP_STATUS_PORT_NO_WWPN, &port->status))
 		{
@@ -2835,7 +2861,7 @@
 	retval = zfcp_fsf_req_create(adapter,
 				     FSF_QTCB_FCP_CMND,
 				     &lock_flags, req_flags, &(fsf_req));
-	if (retval < 0) {
+	if (unlikely(retval < 0)) {
 		ZFCP_LOG_DEBUG("error: Out of resources. Could not create an "
 			       "FCP command request for FCP-LUN 0x%Lx "
 			       "connected to the port with WWPN 0x%Lx "
@@ -2928,7 +2954,7 @@
 	fcp_cmnd_iu->fcp_lun = unit->fcp_lun;
 
 	/* set task attributes in FCP_CMND IU in QTCB */
-	if (scsi_cmnd->device->simple_tags) {
+	if (likely(scsi_cmnd->device->simple_tags)) {
 		fcp_cmnd_iu->task_attribute = SIMPLE_Q;
 		ZFCP_LOG_TRACE("setting SIMPLE_Q task attribute\n");
 	} else {
@@ -2937,7 +2963,7 @@
 	}
 
 	/* set additional length of FCP_CDB in FCP_CMND IU in QTCB, if needed */
-	if (scsi_cmnd->cmd_len > FCP_CDB_LENGTH) {
+	if (unlikely(scsi_cmnd->cmd_len > FCP_CDB_LENGTH)) {
 		fcp_cmnd_iu->add_fcp_cdb_length
 		    = (scsi_cmnd->cmd_len - FCP_CDB_LENGTH) >> 2;
 		ZFCP_LOG_TRACE("SCSI CDB length is 0x%x, "
@@ -2965,9 +2991,9 @@
 	/* Note: >= and not = because the combined scatter-gather entries
 	 * may be larger than request_bufflen according to the mailing list
 	 */
-	if (real_bytes >= scsi_cmnd->request_bufflen) {
+	if (likely(real_bytes >= scsi_cmnd->request_bufflen)) {
 		ZFCP_LOG_TRACE("Data fits\n");
-	} else if (real_bytes == 0) {
+	} else if (likely(real_bytes == 0)) {
 		ZFCP_LOG_DEBUG("Data did not fit into available buffer(s), "
 			       "waiting for more...\n");
 		retval = -EIO;
@@ -2996,7 +3022,7 @@
 	 *  covered by an SBALE)
 	 */
 	retval = zfcp_fsf_req_send(fsf_req, NULL);
-	if (retval < 0) {
+	if (unlikely(retval < 0)) {
 		ZFCP_LOG_INFO("error: Could not send an FCP command request "
 			      "for a command on the adapter %s, "
 			      "port WWPN 0x%Lx and unit LUN 0x%Lx\n",
@@ -3139,12 +3165,12 @@
 	int retval = -EINVAL;
 	struct zfcp_unit *unit;
 
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TASK_MANAGEMENT)
+	if (unlikely(fsf_req->status & ZFCP_STATUS_FSFREQ_TASK_MANAGEMENT))
 		unit = fsf_req->data.send_fcp_command_task_management.unit;
 	else
 		unit = fsf_req->data.send_fcp_command_task.unit;
 
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_ERROR) {
+	if (unlikely(fsf_req->status & ZFCP_STATUS_FSFREQ_ERROR)) {
 		/* go directly to calls of special handlers */
 		goto skip_fsfstatus;
 	}
@@ -3445,7 +3471,6 @@
 zfcp_fsf_send_fcp_command_task_handler(struct zfcp_fsf_req *fsf_req)
 {
 	int retval = 0;
-	struct zfcp_adapter *adapter = fsf_req->adapter;
 
 	Scsi_Cmnd *scpnt;
 	struct fcp_rsp_iu *fcp_rsp_iu = (struct fcp_rsp_iu *)
@@ -3459,14 +3484,14 @@
 
 	read_lock_irqsave(&fsf_req->adapter->abort_lock, flags);
 	scpnt = fsf_req->data.send_fcp_command_task.scsi_cmnd;
-	if (!scpnt) {
+	if (unlikely(!scpnt)) {
 		ZFCP_LOG_DEBUG
 		    ("Command with fsf_req 0x%lx is not associated to "
 		     "a scsi command anymore. Aborted?\n",
 		     (unsigned long) fsf_req);
 		goto out;
 	}
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTED) {
+	if (unlikely(fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTED)) {
 		/* FIXME: (design) mid-layer should handle DID_ABORT like
 		 *        DID_SOFT_ERROR by retrying the request for devices
 		 *        that allow retries.
@@ -3477,7 +3502,7 @@
 		goto skip_fsfstatus;
 	}
 
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_ERROR) {
+	if (unlikely(fsf_req->status & ZFCP_STATUS_FSFREQ_ERROR)) {
 		ZFCP_LOG_DEBUG("Setting DID_ERROR\n");
 		set_host_byte(&scpnt->result, DID_ERROR);
 		goto skip_fsfstatus;
@@ -3491,7 +3516,7 @@
 	 * of result in SCSI command
 	 */
 	scpnt->result |= fcp_rsp_iu->scsi_status;
-	if (fcp_rsp_iu->scsi_status) {
+	if (unlikely(fcp_rsp_iu->scsi_status)) {
 		/* DEBUG */
 		ZFCP_LOG_NORMAL("status for SCSI Command:\n");
 		ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_NORMAL,
@@ -3507,7 +3532,7 @@
 	}
 
 	/* check FCP_RSP_INFO */
-	if (fcp_rsp_iu->validity.bits.fcp_rsp_len_valid) {
+	if (unlikely(fcp_rsp_iu->validity.bits.fcp_rsp_len_valid)) {
 		ZFCP_LOG_DEBUG("rsp_len is valid\n");
 		switch (fcp_rsp_info[3]) {
 		case RSP_CODE_GOOD:
@@ -3600,7 +3625,7 @@
 	}
 
 	/* check for sense data */
-	if (fcp_rsp_iu->validity.bits.fcp_sns_len_valid) {
+	if (unlikely(fcp_rsp_iu->validity.bits.fcp_sns_len_valid)) {
 		sns_len = FSF_FCP_RSP_SIZE -
 		    sizeof (struct fcp_rsp_iu) + fcp_rsp_iu->fcp_rsp_len;
 		ZFCP_LOG_TRACE("room for %i bytes sense data in QTCB\n",
@@ -3623,7 +3648,7 @@
 	}
 
 	/* check for overrun */
-	if (fcp_rsp_iu->validity.bits.fcp_resid_over) {
+	if (unlikely(fcp_rsp_iu->validity.bits.fcp_resid_over)) {
 		ZFCP_LOG_INFO("A data overrun was detected for a command. "
 			      "This happened for a command to the unit "
 			      "with FCP LUN 0x%Lx connected to the "
@@ -3638,7 +3663,7 @@
 	}
 
 	/* check for underrun */
-	if (fcp_rsp_iu->validity.bits.fcp_resid_under) {
+	if (unlikely(fcp_rsp_iu->validity.bits.fcp_resid_under)) {
 		ZFCP_LOG_DEBUG("A data underrun was detected for a command. "
 			       "This happened for a command to the unit "
 			       "with FCP LUN 0x%Lx connected to the "
@@ -3755,9 +3780,6 @@
 	 * the new eh
 	 */
 	/* always call back */
-	(scpnt->scsi_done) (scpnt);
-	atomic_dec(&adapter->scsi_reqs_active);
-	wake_up(&adapter->scsi_reqs_active_wq);
 #ifdef ZFCP_DEBUG_REQUESTS
 	debug_text_event(fsf_req->adapter->req_dbf, 2, "ok_done:");
 	debug_event(fsf_req->adapter->req_dbf, 2, &scpnt,
@@ -3768,8 +3790,6 @@
 		    sizeof (unsigned long));
 #endif /* ZFCP_DEBUG_REQUESTS */
 	(scpnt->scsi_done) (scpnt);
-	atomic_dec(&adapter->scsi_reqs_active);
-	wake_up(&adapter->scsi_reqs_active_wq);
 	/*
 	 * We must hold this lock until scsi_done has been called.
 	 * Otherwise we may call scsi_done after abort regarding this
@@ -3904,7 +3924,7 @@
 			       struct zfcp_qdio_queue *queue, int needed)
 {
 	write_lock_irqsave(&queue->queue_lock, *flags);
-	if (atomic_read(&queue->free_count) >= needed)
+	if (likely(atomic_read(&queue->free_count) >= needed))
 		return 1;
 	write_unlock_irqrestore(&queue->queue_lock, *flags);
 	return 0;
@@ -3942,7 +3962,7 @@
 
 	/* allocate new FSF request */
 	fsf_req = zfcp_fsf_req_alloc(adapter, fsf_cmd, GFP_ATOMIC);
-	if (!fsf_req) {
+	if (unlikely(!fsf_req)) {
 		ZFCP_LOG_DEBUG("error: Could not put an FSF request into"
 			       "the outbound (send) queue.\n");
 		retval = -ENOMEM;
@@ -3960,11 +3980,11 @@
 	fsf_req->specific_magic = ZFCP_MAGIC_FSFREQ;
 
 	fsf_req->fsf_command = fsf_cmd;
-	if (req_flags & ZFCP_REQ_AUTO_CLEANUP)
+	if (likely(req_flags & ZFCP_REQ_AUTO_CLEANUP))
 		fsf_req->status |= ZFCP_STATUS_FSFREQ_CLEANUP;
 
 	/* initialize QTCB */
-	if (fsf_cmd != FSF_QTCB_UNSOLICITED_STATUS) {
+	if (likely(fsf_cmd != FSF_QTCB_UNSOLICITED_STATUS)) {
 		ZFCP_LOG_TRACE("fsf_req->qtcb=0x%lx\n",
 			       (unsigned long) fsf_req->qtcb);
 		fsf_req->qtcb->prefix.req_id = (unsigned long) fsf_req;
@@ -3983,7 +4003,7 @@
 	 * try to get needed SBALs in request queue (get queue lock on success)
 	 */
 	ZFCP_LOG_TRACE("try to get free BUFFER in request queue\n");
-	if (req_flags & ZFCP_WAIT_FOR_SBAL) {
+	if (unlikely(req_flags & ZFCP_WAIT_FOR_SBAL)) {
 		timeout = ZFCP_SBAL_TIMEOUT;
 		ZFCP_WAIT_EVENT_TIMEOUT(adapter->request_wq,
 					timeout,
@@ -4009,7 +4029,7 @@
 	/* setup common SBALE fields */
 	buffere[0].addr = fsf_req;
 	buffere[0].flags |= SBAL_FLAGS0_COMMAND;
-	if (fsf_cmd != FSF_QTCB_UNSOLICITED_STATUS) {
+	if (likely(fsf_cmd != FSF_QTCB_UNSOLICITED_STATUS)) {
 		buffere[1].addr = (void *) fsf_req->qtcb;
 		buffere[1].length = ZFCP_QTCB_SIZE;
 	}
@@ -4116,7 +4136,7 @@
 		      buffere->length);
 
 	/* set sequence counter in QTCB */
-	if (fsf_req->qtcb) {
+	if (likely(fsf_req->qtcb)) {
 		fsf_req->qtcb->prefix.req_seq_no = adapter->fsf_req_seq_no;
 		fsf_req->seq_no = adapter->fsf_req_seq_no;
 		ZFCP_LOG_TRACE("FSF request 0x%lx of adapter 0x%lx gets "
@@ -4133,7 +4153,7 @@
 	write_unlock_irqrestore(&adapter->fsf_req_list_lock, flags);
 
 	/* figure out expiration time of timeout and start timeout */
-	if (timer) {
+	if (unlikely(timer)) {
 		timer->expires += jiffies;
 		add_timer(timer);
 	}
@@ -4167,7 +4187,7 @@
 			 QDIO_FLAG_SYNC_OUTPUT,
 			 0, fsf_req->sbal_index, fsf_req->sbal_count, NULL);
 
-	if (retval) {
+	if (unlikely(retval)) {
 		/* Queues are down..... */
 		retval = -EIO;
 		/*
@@ -4198,7 +4218,7 @@
 		debug_text_event(adapter->req_dbf, 1, "o:a/seq");
 		debug_event(adapter->req_dbf, 1, &fsf_req,
 			    sizeof (unsigned long));
-		if (inc_seq_no) {
+		if (likely(inc_seq_no)) {
 			debug_event(adapter->req_dbf, 1,
 				    &adapter->fsf_req_seq_no, sizeof (u32));
 		} else {
@@ -4213,7 +4233,7 @@
 		 * otherwise,
 		 */
 		/* Don't increase for unsolicited status */
-		if (inc_seq_no) {
+		if (likely(inc_seq_no)) {
 			adapter->fsf_req_seq_no++;
 			ZFCP_LOG_TRACE
 			    ("FSF sequence counter value of adapter 0x%lx "
@@ -4263,16 +4283,16 @@
 	struct zfcp_fsf_req *fsf_req;
 
 	fsf_req = kmalloc(ZFCP_QTCB_AND_REQ_SIZE, kmalloc_flags);
-	if (fsf_req) {
+	if (likely(fsf_req)) {
 		memset(fsf_req, 0, ZFCP_QTCB_AND_REQ_SIZE);
 	} else {
 		fsf_req = mempool_alloc(pool, kmalloc_flags);
-		if (fsf_req) {
+		if (likely(fsf_req)) {
 			memset(fsf_req, 0, ZFCP_QTCB_AND_REQ_SIZE);
 			fsf_req->status |= ZFCP_STATUS_FSFREQ_POOL;
 		}
 	}
-	if (fsf_req)
+	if (likely(fsf_req))
 		fsf_req->qtcb =
 		    (struct fsf_qtcb *) ((unsigned long) fsf_req +
 					 sizeof (struct zfcp_fsf_req));
diff -urN linux-2.6/drivers/s390/scsi/zfcp_qdio.c linux-2.6-s390/drivers/s390/scsi/zfcp_qdio.c
--- linux-2.6/drivers/s390/scsi/zfcp_qdio.c	Sat Oct 25 20:42:56 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_qdio.c	Thu Nov 13 15:29:43 2003
@@ -27,7 +27,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_QDIO_C_REVISION "$Revision: 1.7 $"
+#define ZFCP_QDIO_C_REVISION "$Revision: 1.9 $"
 
 #include "zfcp_ext.h"
 
@@ -214,7 +214,7 @@
 				       " QDIO_STATUS_OUTBOUND_INT \n");
 		}
 	}			// if (ZFCP_LOG_CHECK(ZFCP_LOG_LEVEL_TRACE))
-	if (status & QDIO_STATUS_LOOK_FOR_ERROR) {
+	if (unlikely(status & QDIO_STATUS_LOOK_FOR_ERROR)) {
 		retval = -EIO;
 
 		ZFCP_LOG_FLAGS(1, "QDIO_STATUS_LOOK_FOR_ERROR \n");
@@ -261,7 +261,17 @@
 		}
 		/* Restarting IO on the failed adapter from scratch */
 		debug_text_event(adapter->erp_dbf, 1, "qdio_err");
-		zfcp_erp_adapter_reopen(adapter, 0);
+               /*
+                * Since we have been using this adapter, it is save to assume
+                * that it is not failed but recoverable. The card seems to
+                * report link-up events by self-initiated queue shutdown.
+                * That is why we need to clear the the link-down flag
+                * which is set again in case we have missed by a mile.
+                */
+               zfcp_erp_adapter_reopen(
+                       adapter, 
+                       ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED |
+                       ZFCP_STATUS_COMMON_ERP_FAILED);
 	}
 	return retval;
 }
@@ -293,8 +303,8 @@
 		       zfcp_get_busid_by_adapter(adapter),
 		       first_element, elements_processed);
 
-	if (zfcp_qdio_handler_error_check(adapter, status, qdio_error,
-					  siga_error))
+	if (unlikely(zfcp_qdio_handler_error_check(adapter, status, qdio_error,
+					           siga_error)))
 		goto out;
 	/*
 	 * we stored address of struct zfcp_adapter  data structure
@@ -345,8 +355,8 @@
 	adapter = (struct zfcp_adapter *) int_parm;
 	queue = &adapter->response_queue;
 
-	if (zfcp_qdio_handler_error_check(adapter, status, qdio_error,
-					  siga_error))
+	if (unlikely(zfcp_qdio_handler_error_check(adapter, status, qdio_error,
+					           siga_error)))
 		goto out;
 
 	/*
@@ -394,11 +404,17 @@
 				ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_NORMAL,
 					      (char *) buffer, SBAL_SIZE);
 			}
-			if (buffere->flags & SBAL_FLAGS_LAST_ENTRY)
+			/*
+			 * A single used SBALE per inbound SBALE has been
+			 * implemented by QDIO so far. Hope they will
+			 * do some optimisation. Will need to change to
+			 * unlikely() then.
+			 */
+			if (likely(buffere->flags & SBAL_FLAGS_LAST_ENTRY))
 				break;
 		};
 
-		if (!buffere->flags & SBAL_FLAGS_LAST_ENTRY) {
+		if (unlikely(!buffere->flags & SBAL_FLAGS_LAST_ENTRY)) {
 			ZFCP_LOG_NORMAL("bug: End of inbound data "
 					"not marked!\n");
 		}
@@ -421,7 +437,7 @@
 			 QDIO_FLAG_SYNC_INPUT | QDIO_FLAG_UNDER_INTERRUPT,
 			 0, start, count, NULL);
 
-	if (retval) {
+	if (unlikely(retval)) {
 		atomic_set(&queue->free_count, count);
 		ZFCP_LOG_DEBUG("Inbound data regions could not be cleared "
 			       "Transfer queues may be down. "
@@ -458,7 +474,7 @@
 #endif				/* ZFCP_DEBUG_REQUESTS */
 
 	/* invalid (per convention used in this driver) */
-	if (!sbale_addr) {
+	if (unlikely(!sbale_addr)) {
 		ZFCP_LOG_NORMAL
 		    ("bug: Inbound data faulty, contains null-pointer!\n");
 		retval = -EINVAL;
@@ -468,8 +484,8 @@
 	/* valid request id and thus (hopefully :) valid fsf_req address */
 	fsf_req = (struct zfcp_fsf_req *) sbale_addr;
 
-	if ((fsf_req->common_magic != ZFCP_MAGIC) ||
-	    (fsf_req->specific_magic != ZFCP_MAGIC_FSFREQ)) {
+	if (unlikely((fsf_req->common_magic != ZFCP_MAGIC) ||
+	             (fsf_req->specific_magic != ZFCP_MAGIC_FSFREQ))) {
 		ZFCP_LOG_NORMAL("bug: An inbound FSF acknowledgement was "
 				"faulty (debug info 0x%x, 0x%x, 0x%lx)\n",
 				fsf_req->common_magic,
@@ -479,7 +495,7 @@
 		goto out;
 	}
 
-	if (adapter != fsf_req->adapter) {
+	if (unlikely(adapter != fsf_req->adapter)) {
 		ZFCP_LOG_NORMAL("bug: An inbound FSF acknowledgement was not "
 				"correct (debug info 0x%lx, 0x%lx, 0%lx) \n",
 				(unsigned long) fsf_req,
@@ -490,7 +506,7 @@
 	}
 #ifdef ZFCP_DEBUG_REQUESTS
 	/* debug feature stuff (test for QTCB: remember new unsol. status!) */
-	if (fsf_req->qtcb) {
+	if (likely(fsf_req->qtcb)) {
 		debug_event(adapter->req_dbf, 1,
 			    &fsf_req->qtcb->prefix.req_seq_no, sizeof (u32));
 	}
@@ -498,7 +514,7 @@
 
 	ZFCP_LOG_TRACE("fsf_req at 0x%lx, QTCB at 0x%lx\n",
 		       (unsigned long) fsf_req, (unsigned long) fsf_req->qtcb);
-	if (fsf_req->qtcb) {
+	if (likely(fsf_req->qtcb)) {
 		ZFCP_LOG_TRACE("HEX DUMP OF 1ST BUFFERE PAYLOAD (QTCB):\n");
 		ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_TRACE,
 			      (char *) fsf_req->qtcb, ZFCP_QTCB_SIZE);
@@ -518,8 +534,8 @@
 	int pci_pos;
 
 	new_distance_from_int = req_queue->distance_from_int +
-	    fsf_req->sbal_count;
-	if (new_distance_from_int >= ZFCP_QDIO_PCI_INTERVAL) {
+				fsf_req->sbal_count;
+	if (unlikely(new_distance_from_int >= ZFCP_QDIO_PCI_INTERVAL)) {
 		new_distance_from_int %= ZFCP_QDIO_PCI_INTERVAL;
 		pci_pos = fsf_req->sbal_index;
 		pci_pos += fsf_req->sbal_count;
diff -urN linux-2.6/drivers/s390/scsi/zfcp_scsi.c linux-2.6-s390/drivers/s390/scsi/zfcp_scsi.c
--- linux-2.6/drivers/s390/scsi/zfcp_scsi.c	Sat Oct 25 20:43:28 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_scsi.c	Thu Nov 13 15:29:43 2003
@@ -30,7 +30,7 @@
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
 #define ZFCP_LOG_AREA_PREFIX		ZFCP_LOG_AREA_PREFIX_SCSI
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_SCSI_REVISION "$Revision: 1.38 $"
+#define ZFCP_SCSI_REVISION "$Revision: 1.42 $"
 
 #include <linux/blkdev.h>
 
@@ -225,99 +225,6 @@
 	}
 }
 
-/*
- * function:    zfcp_scsi_insert_into_fake_queue
- *
- * purpose:
- *		
- *
- * returns:
- *
- * FIXME:	Is the following scenario possible and - even more interesting -
- *		a problem? It reminds me of the famous 'no retry for tape' fix
- *		(no problem for disks, but what is about tapes...)
- *
- *		device is unaccessable,
- *		command A is put into the fake queue,
- *		device becomes accessable again,
- *		command B is queued to the device,
- *		fake queue timer expires
- *		command A is returned to the mid-layer
- *		command A is queued to the device
- */
-void
-zfcp_scsi_insert_into_fake_queue(struct zfcp_adapter *adapter,
-				 Scsi_Cmnd * new_cmnd)
-{
-	unsigned long flags;
-	Scsi_Cmnd *current_cmnd;
-
-	ZFCP_LOG_DEBUG("Faking SCSI command:\n");
-	ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_DEBUG,
-		      (char *) new_cmnd->cmnd, new_cmnd->cmd_len);
-
-	new_cmnd->host_scribble = NULL;
-
-	write_lock_irqsave(&adapter->fake_list_lock, flags);
-	if (adapter->first_fake_cmnd == NULL) {
-		adapter->first_fake_cmnd = new_cmnd;
-		adapter->fake_scsi_timer.function =
-		    zfcp_scsi_process_and_clear_fake_queue;
-		adapter->fake_scsi_timer.data = (unsigned long) adapter;
-		adapter->fake_scsi_timer.expires =
-		    jiffies + ZFCP_FAKE_SCSI_COMPLETION_TIME;
-		add_timer(&adapter->fake_scsi_timer);
-	} else {
-		for (current_cmnd = adapter->first_fake_cmnd;
-		     current_cmnd->host_scribble != NULL;
-		     current_cmnd =
-		     (Scsi_Cmnd *) (current_cmnd->host_scribble)) ;
-		current_cmnd->host_scribble = (char *) new_cmnd;
-	}
-	write_unlock_irqrestore(&adapter->fake_list_lock, flags);
-}
-
-/*
- * function:    zfcp_scsi_process_and_clear_fake_queue
- *
- * purpose:
- *		
- *
- * returns:
- */
-void
-zfcp_scsi_process_and_clear_fake_queue(unsigned long data)
-{
-	unsigned long flags;
-	struct zfcp_adapter *adapter = (struct zfcp_adapter *) data;
-	Scsi_Cmnd *cur = adapter->first_fake_cmnd;
-	Scsi_Cmnd *next;
-
-	/*
-	 * We need a common lock for scsi_req on command completion
-	 * as well as on command abort to avoid race conditions
-	 * during completions and aborts taking place at the same time.
-	 * It needs to be the outer lock as in the eh_abort_handler.
-	 */
-	read_lock_irqsave(&adapter->abort_lock, flags);
-	write_lock(&adapter->fake_list_lock);
-	while (cur) {
-		next = (Scsi_Cmnd *) cur->host_scribble;
-		cur->host_scribble = NULL;
-		zfcp_cmd_dbf_event_scsi("clrfake", cur);
-		cur->scsi_done(cur);
-		cur = next;
-#ifdef ZFCP_DEBUG_REQUESTS
-		debug_text_event(adapter->req_dbf, 2, "fk_done:");
-		debug_event(adapter->req_dbf, 2, &cur, sizeof (unsigned long));
-#endif
-	}
-	adapter->first_fake_cmnd = NULL;
-	write_unlock(&adapter->fake_list_lock);
-	read_unlock_irqrestore(&adapter->abort_lock, flags);
-	return;
-}
-
 void
 zfcp_scsi_block_requests(struct Scsi_Host *shpnt)
 {
@@ -383,25 +290,6 @@
 	return 0;
 }
 
-/* Sends command on a round-trip using SCSI stack */
-static void
-zfcp_scsi_queuecommand_fake(Scsi_Cmnd * scpnt, struct zfcp_adapter *adapter)
-{
-	ZFCP_LOG_DEBUG("Looping SCSI IO on the adapter %s.\n",
-		       zfcp_get_busid_by_adapter(adapter));
-	/* 
-	 * Reset everything for devices with retries, allow at least one retry
-	 * for others, e.g. tape.
-	 */
-	scpnt->retries = 0;
-	if (scpnt->allowed == 1) {
-		scpnt->allowed = 2;
-	}
-	set_host_byte(&scpnt->result, DID_SOFT_ERROR);
-	set_driver_byte(&scpnt->result, SUGGEST_RETRY);
-	zfcp_scsi_insert_into_fake_queue(adapter, scpnt);
-}
-
 /* Complete a command immediately handing back DID_ERROR */
 static void
 zfcp_scsi_queuecommand_stop(Scsi_Cmnd * scpnt,
@@ -460,10 +348,12 @@
 int
 zfcp_scsi_queuecommand(Scsi_Cmnd * scpnt, void (*done) (Scsi_Cmnd *))
 {
+	int retval;
 	int temp_ret;
 	struct zfcp_unit *unit;
 	struct zfcp_adapter *adapter;
 
+	retval = 0;
 	/* reset the status for this request */
 	scpnt->result = 0;
 	/* save address of mid layer call back function */
@@ -475,47 +365,38 @@
 	 */
 	adapter = (struct zfcp_adapter *) scpnt->device->host->hostdata[0];
 	/* NULL when the adapter was removed from the zfcp list */
-	if (adapter == NULL) {
+	if (unlikely(adapter == NULL)) {
 		zfcp_scsi_queuecommand_stop(scpnt, NULL, NULL);
 		goto out;
 	}
 
-	/* set when we have a unit/port list modification */
-	if (atomic_test_mask(ZFCP_STATUS_ADAPTER_QUEUECOMMAND_BLOCK,
-			     &adapter->status)) {
-		zfcp_scsi_queuecommand_fake(scpnt, adapter);
-		goto out;
-	}
-
 	unit = zfcp_scsi_determine_unit(adapter, scpnt);
-	if (unit == NULL)
+	if (unlikely(unit == NULL))
 		goto out;
 
-	if (atomic_test_mask(ZFCP_STATUS_COMMON_ERP_FAILED, &unit->status)
-	    || !atomic_test_mask(ZFCP_STATUS_COMMON_RUNNING, &unit->status)) {
+	if (unlikely(
+	      atomic_test_mask(ZFCP_STATUS_COMMON_ERP_FAILED, &unit->status) ||
+	     !atomic_test_mask(ZFCP_STATUS_COMMON_RUNNING, &unit->status))) {
 		zfcp_scsi_queuecommand_stop(scpnt, adapter, unit);
 		goto out;
 	}
-	if (!atomic_test_mask(ZFCP_STATUS_COMMON_UNBLOCKED, &unit->status)) {
+	if (unlikely(
+	     !atomic_test_mask(ZFCP_STATUS_COMMON_UNBLOCKED, &unit->status))) {
 		ZFCP_LOG_DEBUG("adapter %s not ready or unit with LUN 0x%Lx "
 			       "on the port with WWPN 0x%Lx in recovery.\n",
 			       zfcp_get_busid_by_adapter(adapter),
 			       unit->fcp_lun, unit->port->wwpn);
-		zfcp_scsi_queuecommand_fake(scpnt, adapter);
+		retval = SCSI_MLQUEUE_DEVICE_BUSY;
 		goto out;
 	}
 
-	atomic_inc(&adapter->scsi_reqs_active);
-
 	temp_ret = zfcp_fsf_send_fcp_command_task(adapter,
 						  unit,
 						  scpnt, ZFCP_REQ_AUTO_CLEANUP);
 
-	if (temp_ret < 0) {
+	if (unlikely(temp_ret < 0)) {
 		ZFCP_LOG_DEBUG("error: Could not send a Send FCP Command\n");
-		atomic_dec(&adapter->scsi_reqs_active);
-		wake_up(&adapter->scsi_reqs_active_wq);
-		zfcp_scsi_queuecommand_fake(scpnt, adapter);
+		retval = SCSI_MLQUEUE_HOST_BUSY;
 	} else {
 #ifdef ZFCP_DEBUG_REQUESTS
 		debug_text_event(adapter->req_dbf, 3, "q_scpnt");
@@ -524,7 +405,7 @@
 #endif				/* ZFCP_DEBUG_REQUESTS */
 	}
  out:
-	return 0;
+	return retval;
 }
 
 /*
@@ -557,45 +438,6 @@
 }
 
 /*
- * function:    zfcp_scsi_potential_abort_on_fake
- *
- * purpose:
- *
- * returns:     0 - no fake request aborted
- *              1 - fake request was aborted
- *
- * context:	both the adapter->abort_lock and the 
- *              adapter->fake_list_lock are assumed to be held write lock
- *              irqsave
- */
-int
-zfcp_scsi_potential_abort_on_fake(struct zfcp_adapter *adapter,
-				  Scsi_Cmnd * cmnd)
-{
-	Scsi_Cmnd *cur = adapter->first_fake_cmnd;
-	Scsi_Cmnd *pre = NULL;
-	int retval = 0;
-
-	while (cur) {
-		if (cur == cmnd) {
-			if (pre)
-				pre->host_scribble = cur->host_scribble;
-			else
-				adapter->first_fake_cmnd =
-				    (Scsi_Cmnd *) cur->host_scribble;
-			cur->host_scribble = NULL;
-			if (!adapter->first_fake_cmnd)
-				del_timer(&adapter->fake_scsi_timer);
-			retval = 1;
-			break;
-		}
-		pre = cur;
-		cur = (Scsi_Cmnd *) cur->host_scribble;
-	}
-	return retval;
-}
-
-/*
  * function:	zfcp_scsi_eh_abort_handler
  *
  * purpose:	tries to abort the specified (timed out) SCSI command
@@ -663,34 +505,12 @@
 	 * Race condition between normal (late) completion and abort has
 	 * to be avoided.
 	 * The entirity of all accesses to scsi_req have to be atomic.
-	 * scsi_req is usually part of the fsf_req (for requests which
-	 * are not faked) and thus we block the release of fsf_req
-	 * as long as we need to access scsi_req.
-	 * For faked commands we use the same lock even if they are not
-	 * put into the fsf_req queue. This makes implementation
-	 * easier. 
+	 * scsi_req is usually part of the fsf_req and thus we block the
+	 * release of fsf_req as long as we need to access scsi_req.
 	 */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
 	/*
-	 * Check if we deal with a faked command, which we may just forget
-	 * about from now on
-	 */
-	write_lock(&adapter->fake_list_lock);
-	/* only need to go through list if there are faked requests */
-	if (adapter->first_fake_cmnd != NULL) {
-		if (zfcp_scsi_potential_abort_on_fake(adapter, scpnt)) {
-			write_unlock(&adapter->fake_list_lock);
-			write_unlock_irqrestore(&adapter->abort_lock, flags);
-			ZFCP_LOG_INFO("A faked command was aborted\n");
-			retval = SUCCESS;
-			strncpy(dbf_result, "##faked", ZFCP_ABORT_DBF_LENGTH);
-			goto out;
-		}
-	}
-	write_unlock(&adapter->fake_list_lock);
-
-	/*
 	 * Check whether command has just completed and can not be aborted.
 	 * Even if the command has just been completed late, we can access
 	 * scpnt since the SCSI stack does not release it at least until
@@ -845,11 +665,6 @@
 
 	spin_unlock_irq(scsi_host->host_lock);
 
-	/*
-	 * We should not be called to reset a target which we 'sent' faked SCSI
-	 * commands since the abort of faked SCSI commands should always
-	 * succeed (simply delete timer). 
-	 */
 	if (!unit) {
 		ZFCP_LOG_NORMAL("bug: Tried to reset a non existant unit.\n");
 		retval = SUCCESS;
@@ -1023,7 +838,6 @@
 		retval = -EIO;
 		goto out;
 	}
-	atomic_set_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
 	ZFCP_LOG_DEBUG("host registered, scsi_host at 0x%lx\n",
 		       (unsigned long) adapter->scsi_host);
 
@@ -1039,7 +853,12 @@
 	 */
 	adapter->scsi_host->hostdata[0] = (unsigned long) adapter;
 
-	scsi_add_host(adapter->scsi_host, &adapter->ccw_device->dev);
+	if (scsi_add_host(adapter->scsi_host, &adapter->ccw_device->dev)) {
+		scsi_host_put(adapter->scsi_host);
+		retval = -EIO;
+		goto out;
+	}
+	atomic_set_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
  out:
 	return retval;
 }
@@ -1061,8 +880,9 @@
 		return;
 	scsi_remove_host(shost);
 	scsi_host_put(shost);
-
 	adapter->scsi_host = NULL;
+	atomic_clear_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
+
 	return;
 }
 
diff -urN linux-2.6/drivers/s390/scsi/zfcp_sysfs_adapter.c linux-2.6-s390/drivers/s390/scsi/zfcp_sysfs_adapter.c
--- linux-2.6/drivers/s390/scsi/zfcp_sysfs_adapter.c	Sat Oct 25 20:42:47 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_sysfs_adapter.c	Thu Nov 13 15:29:43 2003
@@ -25,7 +25,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_SYSFS_ADAPTER_C_REVISION "$Revision: 1.21 $"
+#define ZFCP_SYSFS_ADAPTER_C_REVISION "$Revision: 1.23 $"
 
 #include <asm/ccwdev.h>
 #include "zfcp_ext.h"
@@ -155,8 +155,6 @@
 
 	retval = 0;
 
-	zfcp_adapter_get(adapter);
-
 	/* try to open port only if adapter is online */
 	if (adapter->ccw_device->online == 1)
 		zfcp_erp_port_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED);
@@ -216,9 +214,14 @@
 		goto out;
 	}
 
-	zfcp_erp_port_shutdown(port, 0);
+	/* shutdown port only if adapter is online */
+	if (adapter->ccw_device->online == 1)
+		zfcp_erp_port_shutdown(port, 0);
+
 	zfcp_erp_wait(adapter);
 	zfcp_port_put(port);
+	zfcp_sysfs_port_remove_files(&port->sysfs_device,
+				     atomic_read(&port->status));
 	device_unregister(&port->sysfs_device);
  out:
 	up(&zfcp_data.config_sema);
diff -urN linux-2.6/drivers/s390/scsi/zfcp_sysfs_port.c linux-2.6-s390/drivers/s390/scsi/zfcp_sysfs_port.c
--- linux-2.6/drivers/s390/scsi/zfcp_sysfs_port.c	Sat Oct 25 20:44:45 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_sysfs_port.c	Thu Nov 13 15:29:43 2003
@@ -25,7 +25,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_SYSFS_PORT_C_REVISION "$Revision: 1.26 $"
+#define ZFCP_SYSFS_PORT_C_REVISION "$Revision: 1.28 $"
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -110,8 +110,6 @@
 
 	retval = 0;
 
-	zfcp_port_get(port);
-
 	/* try to open unit only if adapter is online */
 	if (port->adapter->ccw_device->online == 1)
 		zfcp_erp_unit_reopen(unit, ZFCP_STATUS_COMMON_ERP_FAILED);
@@ -167,9 +165,13 @@
 		goto out;
 	}
 
-	zfcp_erp_unit_shutdown(unit, 0);
+	/* shutdown unit only if adapter is online */
+	if (port->adapter->ccw_device->online == 1)
+		zfcp_erp_unit_shutdown(unit, 0);
+
 	zfcp_erp_wait(unit->port->adapter);
 	zfcp_unit_put(unit);
+	zfcp_sysfs_unit_remove_files(&unit->sysfs_device);
 	device_unregister(&unit->sysfs_device);
  out:
 	up(&zfcp_data.config_sema);
@@ -293,7 +295,7 @@
 };
 
 /**
- * zfcp_sysfs_create_port_files - create sysfs port files
+ * zfcp_sysfs_port_create_files - create sysfs port files
  * @dev: pointer to belonging device
  *
  * Create all attributes of the sysfs representation of a port.
@@ -315,5 +317,19 @@
 	return retval;
 }
 
+/**
+ * zfcp_sysfs_port_remove_files - remove sysfs port files
+ * @dev: pointer to belonging device
+ *
+ * Remove all attributes of the sysfs representation of a port.
+ */
+void
+zfcp_sysfs_port_remove_files(struct device *dev, u32 flags)
+{
+	sysfs_remove_group(&dev->kobj, &zfcp_port_common_attr_group);
+	if (!(flags & ZFCP_STATUS_PORT_NAMESERVER))
+		sysfs_remove_group(&dev->kobj, &zfcp_port_no_ns_attr_group);
+}
+
 #undef ZFCP_LOG_AREA
 #undef ZFCP_LOG_AREA_PREFIX
diff -urN linux-2.6/drivers/s390/scsi/zfcp_sysfs_unit.c linux-2.6-s390/drivers/s390/scsi/zfcp_sysfs_unit.c
--- linux-2.6/drivers/s390/scsi/zfcp_sysfs_unit.c	Sat Oct 25 20:43:27 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_sysfs_unit.c	Thu Nov 13 15:29:43 2003
@@ -25,7 +25,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_SYSFS_UNIT_C_REVISION "$Revision: 1.17 $"
+#define ZFCP_SYSFS_UNIT_C_REVISION "$Revision: 1.18 $"
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -186,5 +186,17 @@
 	return sysfs_create_group(&dev->kobj, &zfcp_unit_attr_group);
 }
 
+/** 
+ * zfcp_sysfs_remove_unit_files - remove sysfs unit files
+ * @dev: pointer to belonging device
+ *
+ * Remove all attributes of the sysfs representation of a unit.
+ */
+void
+zfcp_sysfs_unit_remove_files(struct device *dev)
+{
+	return sysfs_remove_group(&dev->kobj, &zfcp_unit_attr_group);
+}
+
 #undef ZFCP_LOG_AREA
 #undef ZFCP_LOG_AREA_PREFIX
