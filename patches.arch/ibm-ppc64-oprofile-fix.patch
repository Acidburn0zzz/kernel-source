Binary files linux-2.6.5/arch/ppc64/oprofile/.common.c.swp and linux-2.6.5-anton/arch/ppc64/oprofile/.common.c.swp differ
Binary files linux-2.6.5/arch/ppc64/oprofile/.op_model_power4.c.swp and linux-2.6.5-anton/arch/ppc64/oprofile/.op_model_power4.c.swp differ
diff -urN linux-2.6.5/arch/ppc64/oprofile/common.c linux-2.6.5-anton/arch/ppc64/oprofile/common.c
--- linux-2.6.5/arch/ppc64/oprofile/common.c	2004-05-10 18:16:46.880485399 +1000
+++ linux-2.6.5-anton/arch/ppc64/oprofile/common.c	2004-05-10 18:14:03.568432596 +1000
@@ -155,12 +155,14 @@
 			break;
 
 		case PV_GPUL:
+		case PV_GPULp:
 			model = &op_model_power4;
 			model->num_counters = 8;
 			oprof_ppc64_ops.cpu_type = "ppc64/970";
 			break;
 
 		case PV_POWER5:
+		case PV_POWER5p:
 			model = &op_model_power4;
 			model->num_counters = 6;
 			oprof_ppc64_ops.cpu_type = "ppc64/power5";
diff -urN linux-2.6.5/arch/ppc64/oprofile/op_model_power4.c linux-2.6.5-anton/arch/ppc64/oprofile/op_model_power4.c
--- linux-2.6.5/arch/ppc64/oprofile/op_model_power4.c	2004-05-10 18:15:45.248919187 +1000
+++ linux-2.6.5-anton/arch/ppc64/oprofile/op_model_power4.c	2004-05-10 18:23:49.787166591 +1000
@@ -24,6 +24,8 @@
 static unsigned long reset_value[OP_MAX_COUNTER];
 
 static int num_counters;
+static int oprofile_running;
+static int mmcra_has_sihv;
 
 static void power4_reg_setup(struct op_counter_config *ctr,
 			     struct op_system_config *sys,
@@ -33,6 +35,16 @@
 
 	num_counters = num_ctrs;
 
+	/* 
+	 * SIHV / SIPR bits are only implemented on POWER4+ (GQ) and above.
+	 * However we disable it on all POWER4 until we verify it works
+	 * (I was seeing some strange behaviour last time I tried).
+	 *
+	 * It has been verified to work on POWER5 so we enable it there.
+	 */
+	if (!(__is_processor(PV_POWER4) || __is_processor(PV_POWER4p)))
+		mmcra_has_sihv = 1;
+
 	for (i = 0; i < num_counters; ++i)
 		reset_value[i] = 0x80000000UL - ctr[i].count;
 
@@ -99,6 +111,8 @@
 	mmcr0 &= ~MMCR0_FC;
 	mtspr(SPRN_MMCR0, mmcr0);
 
+	oprofile_running = 1;
+
 	dbg("start on cpu %d, mmcr0 %x\n", smp_processor_id(), mmcr0);
 }
 
@@ -111,6 +125,8 @@
 	mmcr0 |= MMCR0_FC;
 	mtspr(SPRN_MMCR0, mmcr0);
 
+	oprofile_running = 0;
+
 	dbg("stop on cpu %d, mmcr0 %x\n", smp_processor_id(), mmcr0);
 
 	mb();
@@ -129,9 +145,6 @@
 {
 }
 
-/* XXX Not currently working */
-static int mmcra_has_sihv = 0;
-
 /*
  * On GQ and newer the MMCRA stores the HV and PR bits at the time
  * the SIAR was sampled. We use that to work out if the SIAR was sampled in
@@ -210,7 +223,7 @@
 	for (i = 0; i < num_counters; ++i) {
 		val = ctr_read(i);
 		if (val < 0) {
-			if (ctr[i].enabled) {
+			if (oprofile_running && ctr[i].enabled) {
 				oprofile_add_sample(pc, is_kernel, i, cpu);
 				ctr_write(i, reset_value[i]);
 			} else {
diff -urN linux-2.6.5/include/asm-ppc64/processor.h linux-2.6.5-anton/include/asm-ppc64/processor.h
--- linux-2.6.5/include/asm-ppc64/processor.h	2004-05-08 12:17:06.000000000 +1000
+++ linux-2.6.5-anton/include/asm-ppc64/processor.h	2004-05-10 18:12:45.311220505 +1000
@@ -384,6 +384,8 @@
 #define	PV_POWER4p	0x0038
 #define PV_GPUL		0x0039
 #define	PV_POWER5	0x003A
+#define PV_POWER5p	0x003B
+#define PV_GPULp	0x003C
 #define	PV_630        	0x0040
 #define	PV_630p	        0x0041
 
