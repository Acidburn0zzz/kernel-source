ChangeSet
  1.1540 04/03/30 17:18:48 boutcher@skunk.rchland.ibm.com +4 -0
  Fix a bug in ibmvscsi where max_requests exceeded the number of 
  buffers we allocated.

  drivers/scsi/ibmvscsi/rpa_vscsi.c
    1.15 04/03/30 17:16:03 boutcher@skunk.rchland.ibm.com +4 -2
    handle max_requests properly on iseries

  drivers/scsi/ibmvscsi/iseries_vscsi.c
    1.10 04/03/30 17:16:03 boutcher@skunk.rchland.ibm.com +6 -4
    handle max_requests properly on iseries

  drivers/scsi/ibmvscsi/ibmvscsi.h
    1.11 04/03/30 17:16:03 boutcher@skunk.rchland.ibm.com +4 -3
    Remove hardcoded max_requests

  drivers/scsi/ibmvscsi/ibmvscsi.c
    1.15 04/03/30 17:16:03 boutcher@skunk.rchland.ibm.com +11 -7
    Fix bug where max_requests exceeded the number of buffers we allocated.

diff -Nru a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
--- a/drivers/scsi/ibmvscsi/ibmvscsi.c	Wed Mar 31 06:29:16 2004
+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c	Wed Mar 31 06:29:16 2004
@@ -85,6 +85,7 @@
 static int max_channel = 3;
 static int init_timeout = 5;
 static int cmd_per_lun = 8;
+static int max_requests = 50;
 
 MODULE_DESCRIPTION("IBM Virtual SCSI");
 MODULE_AUTHOR("Dave Boutcher");
@@ -98,6 +99,8 @@
 MODULE_PARM_DESC(init_timeout, "Initialization timeout in seconds");
 module_param_named(cmd_per_lun, cmd_per_lun, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(cd_per_lun, "Commands per lun");
+module_param_named(max_requests, max_requests, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(max_requests, "Maximum requests for this adapter");
 
 /* ------------------------------------------------------------
  * Routines for the event pool and event structs
@@ -599,7 +602,6 @@
 				    (union VIOSRP_IU *)&srp_cmd,
 				    (void *)cmd, handle_cmd_rsp);
 	if (!evt_struct) {
-		printk(KERN_ERR "ibmvscsi: evt_struct_for() returned NULL\n");
 		return NULL;
 	}
 
@@ -626,8 +628,6 @@
 	    scsi_cmd_to_event_struct(cmd, done, hostdata);
 
 	if (!evt_struct) {
-		printk(KERN_ERR
-		       "ibmvscsi: can't convert struct scsi_cmnd to event\n");
 		return SCSI_MLQUEUE_HOST_BUSY;
 	}
 
@@ -747,6 +747,9 @@
 
 	printk(KERN_INFO "ibmvscsi: SRP_LOGIN succeeded\n");
 
+	if (evt_struct->evt->srp.login_rsp.request_limit_delta > max_requests)
+	    evt_struct->evt->srp.login_rsp.request_limit_delta = max_requests;
+
 	/* Now we know what the real request-limit is */
 	atomic_set(&hostdata->request_limit,
 		   evt_struct->evt->srp.login_rsp.request_limit_delta);
@@ -1282,12 +1285,13 @@
 	hostdata->dev = dev;
 	atomic_set(&hostdata->request_limit, -1);
 
-	if (ibmvscsi_init_crq_queue(&hostdata->queue, hostdata) != 0) {
+	if (ibmvscsi_init_crq_queue(&hostdata->queue, hostdata,
+				    max_requests) != 0) {
 		printk(KERN_ERR "ibmvscsi: couldn't initialize crq\n");
 		goto init_crq_failed;
 	}
 	if (initialize_event_pool(&hostdata->pool,
-				  IBMVSCSI_MAX_REQUESTS, hostdata) != 0) {
+				  max_requests, hostdata) != 0) {
 		printk(KERN_ERR "ibmvscsi: couldn't initialize event pool\n");
 		goto init_pool_failed;
 	}
@@ -1328,7 +1332,7 @@
       add_host_failed:
 	release_event_pool(&hostdata->pool, hostdata);
       init_pool_failed:
-	ibmvscsi_release_crq_queue(&hostdata->queue, hostdata);
+	ibmvscsi_release_crq_queue(&hostdata->queue, hostdata, max_requests);
       init_crq_failed:
 	scsi_host_put(host);
       scsi_host_alloc_failed:
@@ -1338,7 +1342,7 @@
 void ibmvscsi_remove(struct ibmvscsi_host_data *hostdata)
 {
 	release_event_pool(&hostdata->pool, hostdata);
-	ibmvscsi_release_crq_queue(&hostdata->queue, hostdata);
+	ibmvscsi_release_crq_queue(&hostdata->queue, hostdata, max_requests);
 
 	scsi_remove_host(hostdata->host);
 	scsi_host_put(hostdata->host);
diff -Nru a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
--- a/drivers/scsi/ibmvscsi/ibmvscsi.h	Wed Mar 31 06:29:16 2004
+++ b/drivers/scsi/ibmvscsi/ibmvscsi.h	Wed Mar 31 06:29:16 2004
@@ -42,7 +42,6 @@
  */
 static const struct SRP_CMD *fake_srp_cmd = NULL;
 enum {
-	IBMVSCSI_MAX_REQUESTS = 50,
 	MAX_INDIRECT_BUFS = (sizeof(fake_srp_cmd->additional_data) -
 			     sizeof(struct indirect_descriptor)) /
 	    sizeof(struct memory_descriptor)
@@ -95,9 +94,11 @@
 
 /* routines for managing a command/response queue */
 int ibmvscsi_init_crq_queue(struct crq_queue *queue,
-			    struct ibmvscsi_host_data *hostdata);
+			    struct ibmvscsi_host_data *hostdata,
+			    int max_requests);
 void ibmvscsi_release_crq_queue(struct crq_queue *queue,
-				struct ibmvscsi_host_data *hostdata);
+				struct ibmvscsi_host_data *hostdata,
+				int max_requests);
 void ibmvscsi_handle_crq(struct VIOSRP_CRQ *crq,
 			 struct ibmvscsi_host_data *hostdata);
 int ibmvscsi_send_crq(struct ibmvscsi_host_data *hostdata,
diff -Nru a/drivers/scsi/ibmvscsi/iseries_vscsi.c b/drivers/scsi/ibmvscsi/iseries_vscsi.c
--- a/drivers/scsi/ibmvscsi/iseries_vscsi.c	Wed Mar 31 06:29:16 2004
+++ b/drivers/scsi/ibmvscsi/iseries_vscsi.c	Wed Mar 31 06:29:16 2004
@@ -83,7 +83,8 @@
  * Routines for driver initialization
  */
 int ibmvscsi_init_crq_queue(struct crq_queue *queue,
-			    struct ibmvscsi_host_data *hostdata)
+			    struct ibmvscsi_host_data *hostdata,
+			    int max_requests)
 {
 	int rc;
 
@@ -104,17 +105,18 @@
 
       vio_setHandler_failed:
 	viopath_close(viopath_hostLp, viomajorsubtype_scsi,
-		      IBMVSCSI_MAX_REQUESTS);
+		      max_requests);
       viopath_open_failed:
 	return -1;
 }
 
 void ibmvscsi_release_crq_queue(struct crq_queue *queue,
-				struct ibmvscsi_host_data *hostdata)
+				struct ibmvscsi_host_data *hostdata,
+				int max_requests)
 {
 	vio_clearHandler(viomajorsubtype_scsi);
 	viopath_close(viopath_hostLp, viomajorsubtype_scsi,
-		      IBMVSCSI_MAX_REQUESTS);
+		      max_requests);
 }
 
 /**
diff -Nru a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
--- a/drivers/scsi/ibmvscsi/rpa_vscsi.c	Wed Mar 31 06:29:16 2004
+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c	Wed Mar 31 06:29:16 2004
@@ -66,7 +66,8 @@
  * the crq with the hypervisor.
  */
 void ibmvscsi_release_crq_queue(struct crq_queue *queue,
-				struct ibmvscsi_host_data *hostdata)
+				struct ibmvscsi_host_data *hostdata,
+				int max_requests)
 {
 	struct vio_dev *vdev = to_vio_dev(hostdata->dev);
 	free_irq(vdev->irq, (void *)hostdata);
@@ -154,7 +155,8 @@
  * Returns zero on success.
  */
 int ibmvscsi_init_crq_queue(struct crq_queue *queue,
-			    struct ibmvscsi_host_data *hostdata)
+			    struct ibmvscsi_host_data *hostdata,
+			    int max_requests)
 {
 	int rc;
 	struct vio_dev *vdev = to_vio_dev(hostdata->dev);
.........................................................................
# vim: syntax=diff

