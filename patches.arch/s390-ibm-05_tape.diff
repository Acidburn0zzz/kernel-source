 - Fix device reference counting.
 - Fix online-offline-online cycle.
 - Add module license gpl.

diffstat:
 drivers/s390/char/tape.h       |   31 ++
 drivers/s390/char/tape_34xx.c  |  369 ++++++++++++++++++-------------
 drivers/s390/char/tape_block.c |   40 ++-
 drivers/s390/char/tape_char.c  |  138 +++++++++--
 drivers/s390/char/tape_core.c  |  475 +++++++++++++++++++++++++++--------------
 drivers/s390/char/tape_proc.c  |   14 -
 drivers/s390/char/tape_std.c   |  229 ++++++++++++++-----
 drivers/s390/char/tape_std.h   |   12 -
 8 files changed, 881 insertions(+), 427 deletions(-)

diff -urN linux-2.6/drivers/s390/char/tape.h linux-2.6-s390/drivers/s390/char/tape.h
--- linux-2.6/drivers/s390/char/tape.h	Sat Oct 25 20:44:05 2003
+++ linux-2.6-s390/drivers/s390/char/tape.h	Thu Nov 13 15:29:41 2003
@@ -25,6 +25,19 @@
 struct gendisk;
 
 /*
+ * Define DBF_LIKE_HELL for lots of messages in the debug feature.
+ */
+#define DBF_LIKE_HELL
+#ifdef  DBF_LIKE_HELL
+#define DBF_LH(level, str, ...) \
+do { \
+	debug_sprintf_event(tape_dbf_area, level, str, ## __VA_ARGS__); \
+} while (0)
+#else
+#define DBF_LH(level, str, ...) do {} while(0)
+#endif
+
+/*
  * macros s390 debug feature (dbf)
  */
 #define DBF_EVENT(d_level, d_str...) \
@@ -46,7 +59,11 @@
 #define TAPEBLOCK_HSEC_S2B	2
 #define TAPEBLOCK_RETRIES	5
 
-#define TAPE_BUSY(td) (td->treq != NULL)
+/* Event types for hotplug */
+#define TAPE_HOTPLUG_CHAR_ADD     1
+#define TAPE_HOTPLUG_BLOCK_ADD    2
+#define TAPE_HOTPLUG_CHAR_REMOVE  3
+#define TAPE_HOTPLUG_BLOCK_REMOVE 4
 
 enum tape_medium_state {
 	MS_UNKNOWN,
@@ -130,8 +147,6 @@
 	struct module *owner;
 	int  (*setup_device)(struct tape_device *);
 	void (*cleanup_device)(struct tape_device *);
-	int (*assign)(struct tape_device *);
-	int (*unassign)(struct tape_device *);
 	int (*irq)(struct tape_device *, struct tape_request *, struct irb *);
 	struct tape_request *(*read_block)(struct tape_device *, size_t);
 	struct tape_request *(*write_block)(struct tape_device *, size_t);
@@ -205,6 +220,10 @@
 	struct list_head req_queue;
 
 	int first_minor;	       /* each tape device has two minors */
+
+	/* Number of tapemarks required for correct termination. */
+	int required_tapemarks;
+
 	/* Character device frontend data */
 	struct tape_char_data char_data;
 #ifdef CONFIG_S390_TAPE_BLOCK
@@ -219,6 +238,7 @@
 extern int tape_do_io(struct tape_device *, struct tape_request *);
 extern int tape_do_io_async(struct tape_device *, struct tape_request *);
 extern int tape_do_io_interruptible(struct tape_device *, struct tape_request *);
+void tape_hotplug_event(struct tape_device *, int major, int action);
 
 static inline int
 tape_do_io_free(struct tape_device *device, struct tape_request *request)
@@ -234,8 +254,6 @@
 extern void tape_noper_handler(int irq, int status);
 extern int tape_open(struct tape_device *);
 extern int tape_release(struct tape_device *);
-extern int tape_assign(struct tape_device *);
-extern int tape_unassign(struct tape_device *);
 extern int tape_mtop(struct tape_device *, int, int);
 
 extern int tape_enable_device(struct tape_device *, struct tape_discipline *);
@@ -246,7 +264,8 @@
 extern int tape_generic_remove(struct ccw_device *);
 
 extern struct tape_device *tape_get_device(int devindex);
-extern void tape_put_device(struct tape_device *);
+extern struct tape_device *tape_get_device_reference(struct tape_device *);
+extern struct tape_device *tape_put_device(struct tape_device *);
 
 /* Externals from tape_char.c */
 extern int tapechar_init(void);
diff -urN linux-2.6/drivers/s390/char/tape_34xx.c linux-2.6-s390/drivers/s390/char/tape_34xx.c
--- linux-2.6/drivers/s390/char/tape_34xx.c	Sat Oct 25 20:43:24 2003
+++ linux-2.6-s390/drivers/s390/char/tape_34xx.c	Thu Nov 13 15:29:41 2003
@@ -14,12 +14,11 @@
 #include <linux/init.h>
 #include <linux/bio.h>
 #include <linux/workqueue.h>
-#include <asm/tape390.h>
 
 #include "tape.h"
 #include "tape_std.h"
 
-#define PRINTK_HEADER "T34xx:"
+#define PRINTK_HEADER "TAPE_34XX: "
 
 enum tape34xx_type {
 	tape_3480,
@@ -27,18 +26,27 @@
 };
 
 /*
- * Medium sense (asynchronous with callback) for 34xx tapes. There is no 'real'
- * medium sense call. So we just do a normal sense.
+ * Medium sense for 34xx tapes. There is no 'real' medium sense call.
+ * So we just do a normal sense.
  */
-static void
-__tape_34xx_medium_sense_callback(struct tape_request *request, void *data)
+static int
+tape_34xx_medium_sense(struct tape_device *device)
 {
-	unsigned char      *sense;
-	struct tape_device *device;
+	struct tape_request *request;
+	unsigned char       *sense;
+	int                  rc;
 
-	request->callback = NULL;
+	request = tape_alloc_request(1, 32);
+	if(IS_ERR(request)) {
+		DBF_EXCEPTION(6, "MSEN fail\n");
+		return PTR_ERR(request);
+	}
+
+	request->op = TO_MSEN;
+	tape_ccw_end(request->cpaddr, SENSE, 32, request->cpdata);
 
-	if(request->rc == 0 && (device = request->device) != NULL) {
+	rc = tape_do_io_interruptible(device, request);
+	if(request->rc == 0) {
 		sense = request->cpdata;
 
 		/*
@@ -56,27 +64,11 @@
 			device->tape_generic_status |= GMT_WR_PROT(~0);
 		else
 			device->tape_generic_status &= ~GMT_WR_PROT(~0);
+	} else {
+		DBF_EVENT(4, "tape_34xx: medium sense failed with rc=%d\n",
+			request->rc);
 	}
 	tape_free_request(request);
-}
-
-static int
-tape_34xx_medium_sense(struct tape_device *device)
-{
-	struct tape_request *request;
-	int                  rc;
-
-	request = tape_alloc_request(1, 32);
-	if(IS_ERR(request)) {
-		DBF_EXCEPTION(6, "MSEN fail\n");
-		return PTR_ERR(request);
-	}
-
-	request->op = TO_MSEN;
-	tape_ccw_end(request->cpaddr, SENSE, 32, request->cpdata);
-	request->callback = __tape_34xx_medium_sense_callback;
-
-	rc = tape_do_io_async(device, request);
 
 	return rc;
 }
@@ -104,7 +96,7 @@
 			DBF_EVENT(3, "T34XX: internal error: unknown work\n");
 	}
 
-	tape_put_device(p->device);
+	p->device = tape_put_device(p->device);
 	kfree(p);
 }
 
@@ -123,8 +115,7 @@
 	memset(p, 0, sizeof(*p));
 	INIT_WORK(&p->work, tape_34xx_work_handler, p);
 
-	atomic_inc(&device->ref_count);
-	p->device = device;
+	p->device = tape_get_device_reference(device);
 	p->op     = op;
 
 	schedule_work(&p->work);
@@ -134,8 +125,8 @@
 /*
  * Done Handler is called when dev stat = DEVICE-END (successful operation)
  */
-static int
-tape_34xx_done(struct tape_device *device, struct tape_request *request)
+static inline int
+tape_34xx_done(struct tape_request *request)
 {
 	DBF_EVENT(6, "%s done\n", tape_op_verbose[request->op]);
 
@@ -143,28 +134,25 @@
 }
 
 static inline int
-tape_34xx_erp_failed(struct tape_device *device,
-		     struct tape_request *request, int rc)
+tape_34xx_erp_failed(struct tape_request *request, int rc)
 {
-	DBF_EVENT(3, "Error recovery failed for %s\n",
-		  tape_op_verbose[request->op]);
+	DBF_EVENT(3, "Error recovery failed for %s (RC=%d)\n",
+		  tape_op_verbose[request->op], rc);
 	return rc;
 }
 
 static inline int
-tape_34xx_erp_succeeded(struct tape_device *device,
-		       struct tape_request *request)
+tape_34xx_erp_succeeded(struct tape_request *request)
 {
 	DBF_EVENT(3, "Error Recovery successful for %s\n",
 		  tape_op_verbose[request->op]);
-	return tape_34xx_done(device, request);
+	return tape_34xx_done(request);
 }
 
 static inline int
-tape_34xx_erp_retry(struct tape_device *device, struct tape_request *request)
+tape_34xx_erp_retry(struct tape_request *request)
 {
-	DBF_EVENT(3, "xerp retr %s\n",
-		  tape_op_verbose[request->op]);
+	DBF_EVENT(3, "xerp retr %s\n", tape_op_verbose[request->op]);
 	return TAPE_IO_RETRY;
 }
 
@@ -203,7 +191,7 @@
 		 * and try again.
 		 */
 		tape_std_read_backward(device, request);
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	}
 	if (request->op != TO_RBA)
 		PRINT_ERR("read_opposite called with state:%s\n",
@@ -212,7 +200,7 @@
 	 * We tried to read forward and backward, but hat no
 	 * success -> failed.
 	 */
-	return tape_34xx_erp_failed(device, request, -EIO);
+	return tape_34xx_erp_failed(request, -EIO);
 }
 
 static int
@@ -228,7 +216,7 @@
 				   tape_op_verbose[request->op]);
 		tape_dump_sense(device, request, irb);
 	}
-	return tape_34xx_erp_failed(device, request, -EIO);
+	return tape_34xx_erp_failed(request, -EIO);
 }
 
 /*
@@ -243,7 +231,7 @@
 		PRINT_WARN ("Data overrun error between control-unit "
 			    "and drive. Use a faster channel connection, "
 			    "if possible! \n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	}
 	return tape_34xx_erp_bug(device, request, irb, -1);
 }
@@ -260,7 +248,7 @@
 		 * cu detected incorrect block-id sequence on tape.
 		 */
 		PRINT_WARN("Illegal block-id sequence found!\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	}
 	/*
 	 * Record sequence error bit is set, but erpa does not
@@ -281,6 +269,9 @@
 	int inhibit_cu_recovery;
 	__u8* sense;
 
+	inhibit_cu_recovery = (*device->modeset_byte & 0x80) ? 1 : 0;
+	sense = irb->ecw;
+
 #ifdef CONFIG_S390_TAPE_BLOCK
 	if (request->op == TO_BLOCK) {
 		/*
@@ -289,51 +280,94 @@
 		 */
 		device->blk_data.block_position = -1;
 		if (request->retries-- <= 0)
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
 		else
-			return tape_34xx_erp_retry(device, request);
+			return tape_34xx_erp_retry(request);
 	}
 #endif
 
-	inhibit_cu_recovery = (*device->modeset_byte & 0x80) ? 1 : 0;
-	sense = irb->ecw;
-
-	if (sense[0] & SENSE_COMMAND_REJECT) {
-		if ((sense[1] & SENSE_WRITE_PROTECT) &&
-		    (request->op == TO_DSE ||
-		     request->op == TO_WRI ||
-		     request->op == TO_WTM))
+	if (
+		sense[0] & SENSE_COMMAND_REJECT &&
+		sense[1] & SENSE_WRITE_PROTECT
+	) {
+		if (
+			request->op == TO_DSE ||
+			request->op == TO_WRI ||
+			request->op == TO_WTM
+		) {
 			/* medium is write protected */
-			return tape_34xx_erp_failed(device, request, -EACCES);
-		else
+			return tape_34xx_erp_failed(request, -EACCES);
+		} else {
 			return tape_34xx_erp_bug(device, request, irb, -3);
+		}
 	}
 
 	/*
-	 * special cases for various tape-states when reaching
+	 * Special cases for various tape-states when reaching
 	 * end of recorded area
+	 *
+	 * FIXME: Maybe a special case of the special case:
+	 *        sense[0] == SENSE_EQUIPMENT_CHECK &&
+	 *        sense[1] == SENSE_DRIVE_ONLINE    &&
+	 *        sense[3] == 0x47 (Volume Fenced)
+	 *
+	 *        This was caused by continued FSF or FSR after an
+	 *        'End Of Data'.
 	 */
-	if ((sense[0] == 0x08 || sense[0] == 0x10 || sense[0] == 0x12) &&
-	    (sense[1] == 0x40 || sense[1] == 0x0c))
+	if ((
+		sense[0] == SENSE_DATA_CHECK      ||
+		sense[0] == SENSE_EQUIPMENT_CHECK ||
+		sense[0] == SENSE_EQUIPMENT_CHECK + SENSE_DEFERRED_UNIT_CHECK
+	) && (
+		sense[1] == SENSE_DRIVE_ONLINE ||
+		sense[1] == SENSE_BEGINNING_OF_TAPE + SENSE_WRITE_MODE
+	)) {
 		switch (request->op) {
+		/*
+		 * sense[0] == SENSE_DATA_CHECK   &&
+		 * sense[1] == SENSE_DRIVE_ONLINE
+		 * sense[3] == 0x36 (End Of Data)
+		 *
+		 * Further seeks might return a 'Volume Fenced'.
+		 */
 		case TO_FSF:
+		case TO_FSB:
 			/* Trying to seek beyond end of recorded area */
-			return tape_34xx_erp_failed(device, request, -ENOSPC);
+			return tape_34xx_erp_failed(request, -ENOSPC);
+		case TO_BSB:
+			return tape_34xx_erp_retry(request);
+
+		/*
+		 * sense[0] == SENSE_DATA_CHECK   &&
+		 * sense[1] == SENSE_DRIVE_ONLINE &&
+		 * sense[3] == 0x36 (End Of Data)
+		 */
 		case TO_LBL:
 			/* Block could not be located. */
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
+
 		case TO_RFO:
 			/* Read beyond end of recorded area -> 0 bytes read */
-			return tape_34xx_erp_failed(device, request, 0);
+			return tape_34xx_erp_failed(request, 0);
+
+		/*
+		 * sense[0] == SENSE_EQUIPMENT_CHECK &&
+		 * sense[1] == SENSE_DRIVE_ONLINE    &&
+		 * sense[3] == 0x38 (Physical End Of Volume)
+		 */
+		case TO_WRI:
+			/* Writing at physical end of volume */
+			return tape_34xx_erp_failed(request, -ENOSPC);
 		default:
 			PRINT_ERR("Invalid op in %s:%i\n",
 				  __FUNCTION__, __LINE__);
-			return tape_34xx_erp_failed(device, request, 0);
+			return tape_34xx_erp_failed(request, 0);
 		}
+	}
 
 	/* Sensing special bits */
 	if (sense[0] & SENSE_BUS_OUT_CHECK)
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 
 	if (sense[0] & SENSE_DATA_CHECK) {
 		/*
@@ -353,7 +387,7 @@
 
 			/* data check is permanent, CU recovery has failed */
 			PRINT_WARN("Permanent read error\n");
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
 		case 0x25:
 			// a write data check occurred
 			if ((sense[2] & SENSE_TAPE_SYNC_MODE) ||
@@ -366,22 +400,22 @@
 
 			// data check is permanent, cu-recovery has failed
 			PRINT_WARN("Permanent write error\n");
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
 		case 0x26:
 			/* Data Check (read opposite) occurred. */
 			return tape_34xx_erp_read_opposite(device, request);
 		case 0x28:
 			/* ID-Mark at tape start couldn't be written */
 			PRINT_WARN("ID-Mark could not be written.\n");
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
 		case 0x31:
 			/* Tape void. Tried to read beyond end of device. */
 			PRINT_WARN("Read beyond end of recorded area.\n");
-			return tape_34xx_erp_failed(device, request, -ENOSPC);
+			return tape_34xx_erp_failed(request, -ENOSPC);
 		case 0x41:
 			/* Record sequence error. */
 			PRINT_WARN("Invalid block-id sequence found.\n");
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
 		default:
 			/* all data checks for 3480 should result in one of
 			 * the above erpa-codes. For 3490, other data-check
@@ -412,7 +446,7 @@
 		 */
 		PRINT_WARN("Data streaming not operational. "
 			   "Switching to interlock-mode.\n");
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x22:
 		/*
 		 * Path equipment check. Might be drive adapter error, buffer
@@ -424,14 +458,14 @@
 		PRINT_WARN("drive adapter error, buffer error on the lower "
 			   "interface, internal path not usable, error "
 			   "during cartridge load.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x24:
 		/*
 		 * Load display check. Load display was command was issued,
 		 * but the drive is displaying a drive check message. Can
 		 * be threated as "device end".
 		 */
-		return tape_34xx_erp_succeeded(device, request);
+		return tape_34xx_erp_succeeded(request);
 	case 0x27:
 		/*
 		 * Command reject. May indicate illegal channel program or
@@ -439,7 +473,7 @@
 		 * issued by this driver and ought be correct, we assume a
 		 * over/underrun situation and retry the channel program.
 		 */
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x29:
 		/*
 		 * Function incompatible. Either the tape is idrc compressed
@@ -447,13 +481,13 @@
 		 * subsystem func is issued and the CU is not on-line.
 		 */
 		PRINT_WARN ("Function incompatible. Try to switch off idrc\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x2a:
 		/*
 		 * Unsolicited environmental data. An internal counter
 		 * overflows, we can ignore this and reissue the cmd.
 		 */
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x2b:
 		/*
 		 * Environmental data present. Indicates either unload
@@ -462,7 +496,7 @@
 		if (request->op == TO_RUN) {
 			/* Rewind unload completed ok. */
 			tape_med_state_set(device, MS_UNLOADED);
-			return tape_34xx_erp_succeeded(device, request);
+			return tape_34xx_erp_succeeded(request);
 		}
 		/* tape_34xx doesn't use read buffered log commands. */
 		return tape_34xx_erp_bug(device, request, irb, sense[3]);
@@ -471,11 +505,11 @@
 		 * Permanent equipment check. CU has tried recovery, but
 		 * did not succeed.
 		 */
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x2d:
 		/* Data security erase failure. */
 		if (request->op == TO_DSE)
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
 		/* Data security erase failure, but no such command issued. */
 		return tape_34xx_erp_bug(device, request, irb, sense[3]);
 	case 0x2e:
@@ -484,16 +518,16 @@
 		 * reading the format id mark or that that format specified
 		 * is not supported by the drive.
 		 */
-		PRINT_WARN("Drive not capable processing the tape format!");
-		return tape_34xx_erp_failed(device, request, -EMEDIUMTYPE);
+		PRINT_WARN("Drive not capable processing the tape format!\n");
+		return tape_34xx_erp_failed(request, -EMEDIUMTYPE);
 	case 0x30:
 		/* The medium is write protected. */
 		PRINT_WARN("Medium is write protected!\n");
-		return tape_34xx_erp_failed(device, request, -EACCES);
+		return tape_34xx_erp_failed(request, -EACCES);
 	case 0x32:
 		// Tension loss. We cannot recover this, it's an I/O error.
 		PRINT_WARN("The drive lost tape tension.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x33:
 		/*
 		 * Load Failure. The cartridge was not inserted correctly or
@@ -501,7 +535,7 @@
 		 */
 		PRINT_WARN("Cartridge load failure. Reload the cartridge "
 			   "and try again.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x34:
 		/*
 		 * Unload failure. The drive cannot maintain tape tension
@@ -510,7 +544,7 @@
 		PRINT_WARN("Failure during cartridge unload. "
 			   "Please try manually.\n");
 		if (request->op == TO_RUN)
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
 		return tape_34xx_erp_bug(device, request, irb, sense[3]);
 	case 0x35:
 		/*
@@ -522,11 +556,11 @@
 		 */
 		PRINT_WARN("Equipment check! Please check the drive and "
 			   "the cartridge loader.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x36:
 		if (device->cdev->id.driver_info == tape_3490)
 			/* End of data. */
-			return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -EIO);
 		/* This erpa is reserved for 3480 */
 		return tape_34xx_erp_bug(device, request, irb, sense[3]);
 	case 0x37:
@@ -535,7 +569,7 @@
 		 * the beginning-of-tape data.
 		 */
 		PRINT_WARN("Tape length error.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x38:
 		/*
 		 * Physical end of tape. A read/write operation reached
@@ -544,27 +578,27 @@
 		if (request->op==TO_WRI ||
 		    request->op==TO_DSE ||
 		    request->op==TO_WTM)
-			return tape_34xx_erp_failed(device, request, -ENOSPC);
-		return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_failed(request, -ENOSPC);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x39:
 		/* Backward at Beginning of tape. */
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x3a:
 		/* Drive switched to not ready. */
 		PRINT_WARN("Drive not ready. Turn the ready/not ready switch "
 			   "to ready position and try again.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x3b:
 		/* Manual rewind or unload. This causes an I/O error. */
 		PRINT_WARN("Medium was rewound or unloaded manually.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x42:
 		/*
 		 * Degraded mode. A condition that can cause degraded
 		 * performance is detected.
 		 */
 		PRINT_WARN("Subsystem is running in degraded mode.\n");
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x43:
 		/* Drive not ready. */
 		tape_med_state_set(device, MS_UNLOADED);
@@ -574,25 +608,26 @@
 				case TO_ASSIGN:
 				case TO_UNASSIGN:
 				case TO_DIS:
-					return tape_34xx_done(device, request);
+				case TO_NOP:
+					return tape_34xx_done(request);
 					break;
 				default:
 					break;
 			}
 		}
 		PRINT_WARN("The drive is not ready.\n");
-		return tape_34xx_erp_failed(device, request, -ENOMEDIUM);
+		return tape_34xx_erp_failed(request, -ENOMEDIUM);
 	case 0x44:
 		/* Locate Block unsuccessful. */
 		if (request->op != TO_BLOCK && request->op != TO_LBL)
 			/* No locate block was issued. */
 			return tape_34xx_erp_bug(device, request,
 						 irb, sense[3]);
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x45:
 		/* The drive is assigned to a different channel path. */
 		PRINT_WARN("The drive is assigned elsewhere.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x46:
 		/*
 		 * Drive not on-line. Drive may be switched offline,
@@ -600,23 +635,23 @@
 		 * the drive address may not be set correctly.
 		 */
 		PRINT_WARN("The drive is not on-line.");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x47:
 		/* Volume fenced. CU reports volume integrity is lost. */
 		PRINT_WARN("Volume fenced. The volume integrity is lost.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x48:
 		/* Log sense data and retry request. */
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x49:
 		/* Bus out check. A parity check error on the bus was found. */
 		PRINT_WARN("Bus out check. A data transfer over the bus "
 			   "has been corrupted.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x4a:
 		/* Control unit erp failed. */
 		PRINT_WARN("The control unit I/O error recovery failed.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x4b:
 		/*
 		 * CU and drive incompatible. The drive requests micro-program
@@ -624,13 +659,13 @@
 		 */
 		PRINT_WARN("The drive needs microprogram patches from the "
 			   "control unit, which are not available.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x4c:
 		/*
 		 * Recovered Check-One failure. Cu develops a hardware error,
 		 * but is able to recover.
 		 */
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x4d:
 		if (device->cdev->id.driver_info == tape_3490)
 			/*
@@ -638,7 +673,7 @@
 			 * not support resetting event recovery (which has to
 			 * be handled by the I/O Layer), retry our command.
 			 */
-			return tape_34xx_erp_retry(device, request);
+			return tape_34xx_erp_retry(request);
 		/* This erpa is reserved for 3480. */
 		return tape_34xx_erp_bug(device, request, irb, sense[3]);
 	case 0x4e:
@@ -650,7 +685,7 @@
 			 */
 			PRINT_WARN("Maximum block size for buffered "
 				   "mode exceeded.\n");
-			return tape_34xx_erp_failed(device, request, -ENOBUFS);
+			return tape_34xx_erp_failed(request, -ENOBUFS);
 		}
 		/* This erpa is reserved for 3480. */
 		return tape_34xx_erp_bug(device, request, irb, sense[3]);
@@ -661,7 +696,7 @@
 		 * never happen, since we're never running in extended
 		 * buffered log mode.
 		 */
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x51:
 		/*
 		 * Read buffered log (EOV). EOF processing occurs while the
@@ -669,73 +704,82 @@
 		 * happen, since we're never running in extended buffered
 		 * log mode.
 		 */
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x52:
 		/* End of Volume complete. Rewind unload completed ok. */
 		if (request->op == TO_RUN) {
 			tape_med_state_set(device, MS_UNLOADED);
-			return tape_34xx_erp_succeeded(device, request);
+			return tape_34xx_erp_succeeded(request);
 		}
 		return tape_34xx_erp_bug(device, request, irb, sense[3]);
 	case 0x53:
 		/* Global command intercept. */
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x54:
 		/* Channel interface recovery (temporary). */
-		return tape_34xx_erp_retry(device, request);
+		return tape_34xx_erp_retry(request);
 	case 0x55:
 		/* Channel interface recovery (permanent). */
 		PRINT_WARN("A permanent channel interface error occurred.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x56:
 		/* Channel protocol error. */
 		PRINT_WARN("A channel protocol error occurred.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x57:
 		if (device->cdev->id.driver_info == tape_3480) {
 			/* Attention intercept. */
 			PRINT_WARN("An attention intercept occurred, "
 				   "which will be recovered.\n");
-			return tape_34xx_erp_retry(device, request);
+			return tape_34xx_erp_retry(request);
 		} else {
 			/* Global status intercept. */
 			PRINT_WARN("An global status intercept was received, "
 				   "which will be recovered.\n");
-			return tape_34xx_erp_retry(device, request);
+			return tape_34xx_erp_retry(request);
 		}
 	case 0x5a:
 		/*
 		 * Tape length incompatible. The tape inserted is too long,
 		 * which could cause damage to the tape or the drive.
 		 */
-		PRINT_WARN("Tape length incompatible [should be IBM Cartridge "
-			   "System Tape]. May cause damage to drive or tape.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		PRINT_WARN("Tape Length Incompatible\n");
+		PRINT_WARN("Tape length exceeds IBM enhanced capacity "
+			"cartdridge length or a medium\n");
+		PRINT_WARN("with EC-CST identification mark has been mounted "
+			"in a device that writes\n");
+		PRINT_WARN("3480 or 3480 XF format.\n");
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x5b:
 		/* Format 3480 XF incompatible */
 		if (sense[1] & SENSE_BEGINNING_OF_TAPE)
 			/* The tape will get overwritten. */
-			return tape_34xx_erp_retry(device, request);
-		PRINT_WARN("Tape format is incompatible to the drive, "
-			   "which writes 3480-2 XF.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+			return tape_34xx_erp_retry(request);
+		PRINT_WARN("Format 3480 XF Incompatible\n");
+		PRINT_WARN("Medium has been created in 3480 format. "
+			"To change the format writes\n");
+		PRINT_WARN("must be issued at BOT.\n");
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x5c:
 		/* Format 3480-2 XF incompatible */
-		PRINT_WARN("Tape format is incompatible to the drive. "
-			   "The drive cannot access 3480-2 XF volumes.\n");
-		return tape_34xx_erp_failed(device, request, -EIO);
+		PRINT_WARN("Format 3480-2 XF Incompatible\n");
+		PRINT_WARN("Device can only read 3480 or 3480 XF format.\n");
+		return tape_34xx_erp_failed(request, -EIO);
 	case 0x5d:
 		/* Tape length violation. */
-		PRINT_WARN("Tape length violation [should be IBM Enhanced "
-			   "Capacity Cartridge System Tape]. May cause "
-			   "damage to drive or tape.\n");
-		return tape_34xx_erp_failed(device, request, -EMEDIUMTYPE);
+		PRINT_WARN("Tape Length Violation\n");
+		PRINT_WARN("The mounted tape exceeds IBM Enhanced Capacity "
+			"Cartdridge System Tape length.\n");
+		PRINT_WARN("This may cause damage to the drive or tape when "
+			"processing to the EOV\n");
+		return tape_34xx_erp_failed(request, -EMEDIUMTYPE);
 	case 0x5e:
 		/* Compaction algorithm incompatible. */
+		PRINT_WARN("Compaction Algorithm Incompatible\n");
 		PRINT_WARN("The volume is recorded using an incompatible "
-			   "compaction algorithm, which is not supported by "
-			   "the control unit.\n");
-		return tape_34xx_erp_failed(device, request, -EMEDIUMTYPE);
+			"compaction algorithm,\n");
+		PRINT_WARN("which is not supported by the device.\n");
+		return tape_34xx_erp_failed(request, -EMEDIUMTYPE);
 
 		/* The following erpas should have been covered earlier. */
 	case 0x23: /* Read data check. */
@@ -766,14 +810,24 @@
 	    (request->op == TO_WRI)) {
 		/* Write at end of volume */
 		PRINT_INFO("End of volume\n"); /* XXX */
-		return tape_34xx_erp_failed(device, request, -ENOSPC);
+		return tape_34xx_erp_failed(request, -ENOSPC);
 	}
 
 	if (irb->scsw.dstat & DEV_STAT_UNIT_CHECK)
 		return tape_34xx_unit_check(device, request, irb);
 
-	if (irb->scsw.dstat & DEV_STAT_DEV_END)
-		return tape_34xx_done(device, request);
+	if (irb->scsw.dstat & DEV_STAT_DEV_END) {
+		/*
+		 * A unit exception occurs on skipping over a tapemark block.
+		 */
+		if (irb->scsw.dstat & DEV_STAT_UNIT_EXCEP) {
+			if (request->op == TO_BSB || request->op == TO_FSB)
+				request->rescnt++;
+			else
+				DBF_EVENT(5, "Unit Exception!\n");
+		}
+		return tape_34xx_done(request);
+	}
 
 	DBF_EVENT(6, "xunknownirq\n");
 	PRINT_ERR("Unexpected interrupt.\n");
@@ -786,26 +840,39 @@
  * ioctl_overload
  */
 static int
-tape_34xx_ioctl(struct tape_device *device,
-		unsigned int cmd, unsigned long arg)
+tape_34xx_ioctl(struct tape_device *device, unsigned int cmd, unsigned long arg)
 {
-	if (cmd == TAPE390_DISPLAY)
-		return tape_std_display(device, cmd, arg);
-	else
+	if (cmd == TAPE390_DISPLAY) {
+		struct display_struct disp;
+
+		if (copy_from_user(&disp, (char *) arg, sizeof(disp)) != 0)
+			return -EFAULT;
+
+		return tape_std_display(device, &disp);
+	} else
 		return -EINVAL;
 }
 
 static int
 tape_34xx_setup_device(struct tape_device * device)
 {
+	int rc;
+
 	DBF_EVENT(6, "34xx minor1: %x\n", device->first_minor);
-	tape_34xx_medium_sense(device);
-	return 0;
+	if ((rc = tape_std_assign(device)) == 0) {
+		if ((rc = tape_34xx_medium_sense(device)) != 0) {
+			DBF_LH(3, "34xx medium sense returned %d\n", rc);
+		}
+	}
+
+	return rc;
 }
 
 static void
-tape_34xx_cleanup_device(struct tape_device * device)
+tape_34xx_cleanup_device(struct tape_device *device)
 {
+	tape_std_unassign(device);
+	
 	if (device->discdata) {
 		kfree(device->discdata);
 		device->discdata = NULL;
@@ -995,8 +1062,6 @@
 	.irq = tape_34xx_irq,
 	.read_block = tape_std_read_block,
 	.write_block = tape_std_write_block,
-	.assign = tape_std_assign,
-	.unassign = tape_std_unassign,
 #ifdef CONFIG_S390_TAPE_BLOCK
 	.bread = tape_34xx_bread,
 	.free_bread = tape_34xx_free_bread,
@@ -1041,7 +1106,7 @@
 {
 	int rc;
 
-	DBF_EVENT(3, "34xx init: $Revision: 1.8 $\n");
+	DBF_EVENT(3, "34xx init: $Revision: 1.16 $\n");
 	/* Register driver for 3480/3490 tapes. */
 	rc = ccw_driver_register(&tape_34xx_driver);
 	if (rc)
@@ -1060,7 +1125,7 @@
 MODULE_DEVICE_TABLE(ccw, tape_34xx_ids);
 MODULE_AUTHOR("(C) 2001-2002 IBM Deutschland Entwicklung GmbH");
 MODULE_DESCRIPTION("Linux on zSeries channel attached 3480 tape "
-		   "device driver ($Revision: 1.8 $)");
+		   "device driver ($Revision: 1.16 $)");
 MODULE_LICENSE("GPL");
 
 module_init(tape_34xx_init);
diff -urN linux-2.6/drivers/s390/char/tape_block.c linux-2.6-s390/drivers/s390/char/tape_block.c
--- linux-2.6/drivers/s390/char/tape_block.c	Sat Oct 25 20:44:14 2003
+++ linux-2.6-s390/drivers/s390/char/tape_block.c	Thu Nov 13 15:29:41 2003
@@ -19,7 +19,7 @@
 
 #include "tape.h"
 
-#define PRINTK_HEADER "TBLOCK:"
+#define PRINTK_HEADER "TAPE_BLOCK: "
 
 #define TAPEBLOCK_MAX_SEC	100
 #define TAPEBLOCK_MIN_REQUEUE	3
@@ -214,7 +214,8 @@
 	if (!disk)
 		return -ENOMEM;
 
-	tasklet_init(&d->tasklet, tapeblock_tasklet, (unsigned long)device);
+	tasklet_init(&d->tasklet, tapeblock_tasklet,
+		(unsigned long) tape_get_device_reference(device));
 
 	spin_lock_init(&d->request_queue_lock);
 	q = blk_init_queue(tapeblock_request_fn, &d->request_queue_lock);
@@ -239,7 +240,7 @@
 	disk->major = tapeblock_major;
 	disk->first_minor = device->first_minor;
 	disk->fops = &tapeblock_fops;
-	disk->private_data = device;
+	disk->private_data = tape_get_device_reference(device);
 	disk->queue = q;
 	//set_capacity(disk, size);
 
@@ -247,6 +248,9 @@
 
 	add_disk(disk);
 	d->disk = disk;
+
+	tape_hotplug_event(device, tapeblock_major, TAPE_HOTPLUG_BLOCK_ADD);
+
 	return 0;
 
  cleanup_queue:
@@ -261,11 +265,15 @@
 {
 	struct tape_blk_data *d = &device->blk_data;
 
+	tape_hotplug_event(device, tapeblock_major, TAPE_HOTPLUG_BLOCK_REMOVE);
+
 	del_gendisk(d->disk);
+	d->disk->private_data = tape_put_device(d->disk->private_data);
 	put_disk(d->disk);
 	blk_cleanup_queue(d->request_queue);
 
 	tasklet_kill(&d->tasklet);
+	tape_put_device(device);
 }
 
 /*
@@ -301,9 +309,9 @@
 static int
 tapeblock_open(struct inode *inode, struct file *filp)
 {
-	struct gendisk *disk = inode->i_bdev->bd_disk;
-	struct tape_device *device = disk->private_data;
-	int rc;
+	struct gendisk *	disk;
+	struct tape_device *	device;
+	int			rc;
 
 	/*
 	 * FIXME: this new tapeblock_open function is from 2.5.69.
@@ -311,20 +319,27 @@
 	 * pointer from disk->private_data. It is stored in 
 	 * tapeblock_setup_device but WITHOUT proper ref-counting.
 	 */
+	disk   = inode->i_bdev->bd_disk;
+	device = tape_get_device_reference(disk->private_data);
+
+	if (device->required_tapemarks) {
+		DBF_EVENT(2, "TBLOCK: missing tapemarks\n");
+		PRINT_ERR("TBLOCK: Refusing to open tape with missing"
+			" end of file marks.\n");
+		rc = -EPERM;
+		goto put_device;
+	}
+
 	rc = tape_open(device);
 	if (rc)
 		goto put_device;
-	rc = tape_assign(device);
-	if (rc)
-		goto release;
 	device->blk_data.block_position = -1;
 	rc = tapeblock_mediumdetect(device);
 	if (rc)
-		goto unassign;
+		goto release;
+
 	return 0;
 
- unassign:
-	tape_unassign(device);
  release:
 	tape_release(device);
  put_device:
@@ -342,7 +357,6 @@
 	struct tape_device *device = disk->private_data;
 
 	tape_release(device);
-	tape_unassign(device);
 	tape_put_device(device);
 
 	return 0;
diff -urN linux-2.6/drivers/s390/char/tape_char.c linux-2.6-s390/drivers/s390/char/tape_char.c
--- linux-2.6/drivers/s390/char/tape_char.c	Sat Oct 25 20:44:16 2003
+++ linux-2.6-s390/drivers/s390/char/tape_char.c	Thu Nov 13 15:29:41 2003
@@ -19,8 +19,9 @@
 #include <asm/uaccess.h>
 
 #include "tape.h"
+#include "tape_std.h"
 
-#define PRINTK_HEADER "TCHAR:"
+#define PRINTK_HEADER "TAPE_CHAR: "
 
 #define TAPECHAR_MAJOR		0	/* get dynamic major */
 
@@ -52,12 +53,14 @@
 int
 tapechar_setup_device(struct tape_device * device)
 {
+	tape_hotplug_event(device, tapechar_major, TAPE_HOTPLUG_CHAR_ADD);
 	return 0;
 }
 
 void
 tapechar_cleanup_device(struct tape_device *device)
 {
+	tape_hotplug_event(device, tapechar_major, TAPE_HOTPLUG_CHAR_REMOVE);
 }
 
 /*
@@ -81,15 +84,27 @@
 	struct idal_buffer *new;
 
 	if (device->char_data.idal_buf != NULL &&
-	    device->char_data.idal_buf->size >= block_size)
+	    device->char_data.idal_buf->size == block_size)
 		return 0;
-	/* The current idal buffer is not big enough. Allocate a new one. */
+
+	if (block_size > MAX_BLOCKSIZE) {
+		DBF_EVENT(3, "Invalid blocksize (%zd > %d)\n",
+			block_size, MAX_BLOCKSIZE);
+		PRINT_ERR("Invalid blocksize (%zd> %d)\n",
+			block_size, MAX_BLOCKSIZE);
+		return -EINVAL;
+	}
+
+	/* The current idal buffer is not correct. Allocate a new one. */
 	new = idal_buffer_alloc(block_size, 0);
 	if (new == NULL)
 		return -ENOMEM;
+
 	if (device->char_data.idal_buf != NULL)
 		idal_buffer_free(device->char_data.idal_buf);
+
 	device->char_data.idal_buf = new;
+
 	return 0;
 }
 
@@ -116,6 +131,16 @@
 		DBF_EVENT(6, "TCHAR:ppos wrong\n");
 		return -EOVERFLOW;
 	}
+
+	/*
+	 * If the tape isn't terminated yet, do it now. And since we then
+	 * are at the end of the tape there wouldn't be anything to read
+	 * anyways. So we return immediatly.
+	 */
+	if(device->required_tapemarks) {
+		return tape_std_terminate_write(device);
+	}
+
 	/* Find out block size to use */
 	if (device->char_data.block_size != 0) {
 		if (count < device->char_data.block_size) {
@@ -225,6 +250,17 @@
 			rc = 0;
 
 	}
+
+	/*
+	 * After doing a write we always need two tapemarks to correctly
+	 * terminate the tape (one to terminate the file, the second to
+	 * flag the end of recorded data.
+	 * Since process_eov positions the tape in front of the written
+	 * tapemark it doesn't hurt to write two marks again.
+	 */
+	if (!rc)
+		device->required_tapemarks = 2;
+
 	return rc ? rc : written;
 }
 
@@ -239,22 +275,22 @@
 
 	if (imajor(filp->f_dentry->d_inode) != tapechar_major)
 		return -ENODEV;
+
 	minor = iminor(filp->f_dentry->d_inode);
 	device = tape_get_device(minor / TAPE_MINORS_PER_DEV);
 	if (IS_ERR(device)) {
 		return PTR_ERR(device);
 	}
+
 	DBF_EVENT(6, "TCHAR:open: %x\n", iminor(inode));
+
 	rc = tape_open(device);
 	if (rc == 0) {
-		rc = tape_assign(device);
-		if (rc == 0) {
-			filp->private_data = device;
-			return 0;
-		}
-		tape_release(device);
+		filp->private_data = device;
+		return 0;
 	}
 	tape_put_device(device);
+
 	return rc;
 }
 
@@ -267,29 +303,32 @@
 {
 	struct tape_device *device;
 
-	device = (struct tape_device *) filp->private_data;
 	DBF_EVENT(6, "TCHAR:release: %x\n", iminor(inode));
-#if 0
-	// FIXME: this is broken. Either MTWEOF/MTWEOF/MTBSR is done
-	// EVERYTIME the user switches from write to something different
-	// or it is not done at all. The second is IMHO better because
-	// we should NEVER do something the user didn't request.
-	if (device->last_op == TO_WRI)
-		tapechar_terminate_write(device);
-#endif
+	device = (struct tape_device *) filp->private_data;
+
 	/*
-	 * If this is the rewinding tape minor then rewind.
+	 * If this is the rewinding tape minor then rewind. In that case we
+	 * write all required tapemarks. Otherwise only one to terminate the
+	 * file.
 	 */
-	if ((iminor(inode) & 1) != 0)
+	if ((iminor(inode) & 1) != 0) {
+		if (device->required_tapemarks)
+			tape_std_terminate_write(device);
 		tape_mtop(device, MTREW, 1);
+	} else {
+		if (device->required_tapemarks > 1) {
+			if (tape_mtop(device, MTWEOF, 1) == 0)
+				device->required_tapemarks--;
+		}
+	}
+
 	if (device->char_data.idal_buf != NULL) {
 		idal_buffer_free(device->char_data.idal_buf);
 		device->char_data.idal_buf = NULL;
 	}
-	device->char_data.block_size = 0;
 	tape_release(device);
-	tape_unassign(device);
-	tape_put_device(device);
+	filp->private_data = tape_put_device(device);
+
 	return 0;
 }
 
@@ -314,7 +353,37 @@
 			return -EFAULT;
 		if (op.mt_count < 0)
 			return -EINVAL;
-		return tape_mtop(device, op.mt_op, op.mt_count);
+
+		/*
+		 * Operations that change tape position should write final
+		 * tapemarks.
+		 */
+		switch (op.mt_op) {
+			case MTFSF:
+			case MTBSF:
+			case MTFSR:
+			case MTBSR:
+			case MTREW:
+			case MTOFFL:
+			case MTEOM:
+			case MTRETEN:
+			case MTBSFM:
+			case MTFSFM:
+			case MTSEEK:
+				if (device->required_tapemarks)
+					tape_std_terminate_write(device);
+			default:
+				;
+		}
+		rc = tape_mtop(device, op.mt_op, op.mt_count);
+
+		if (op.mt_op == MTWEOF && rc == 0) {
+			if (op.mt_count > device->required_tapemarks)
+				device->required_tapemarks = 0;
+			else
+				device->required_tapemarks -= op.mt_count;
+		}
+		return rc;
 	}
 	if (no == MTIOCPOS) {
 		/* MTIOCPOS: query the tape position. */
@@ -333,19 +402,30 @@
 		struct mtget get;
 
 		memset(&get, 0, sizeof(get));
-		rc = tape_mtop(device, MTTELL, 1);
-		if (rc < 0)
-			return rc;
 		get.mt_type = MT_ISUNKNOWN;
+		get.mt_resid = 0 /* device->devstat.rescnt */;
 		get.mt_dsreg = device->tape_state;
 		/* FIXME: mt_gstat, mt_erreg, mt_fileno */
-		get.mt_resid = 0 /* device->devstat.rescnt */;
 		get.mt_gstat = 0;
 		get.mt_erreg = 0;
 		get.mt_fileno = 0;
-		get.mt_blkno = rc;
+		get.mt_gstat  = device->tape_generic_status;
+
+		if (device->medium_state == MS_LOADED) {
+			rc = tape_mtop(device, MTTELL, 1);
+
+			if (rc < 0)
+				return rc;
+
+			if (rc == 0)
+				get.mt_gstat |= GMT_BOT(~0);
+
+			get.mt_blkno = rc;
+		}
+
 		if (copy_to_user((char *) data, &get, sizeof(get)) != 0)
 			return -EFAULT;
+
 		return 0;
 	}
 	/* Try the discipline ioctl function. */
diff -urN linux-2.6/drivers/s390/char/tape_core.c linux-2.6-s390/drivers/s390/char/tape_core.c
--- linux-2.6/drivers/s390/char/tape_core.c	Sat Oct 25 20:43:12 2003
+++ linux-2.6-s390/drivers/s390/char/tape_core.c	Thu Nov 13 15:29:41 2003
@@ -23,9 +23,10 @@
 #include "tape.h"
 #include "tape_std.h"
 
-#define PRINTK_HEADER "T390:"
+#define PRINTK_HEADER "TAPE_CORE: "
 
-static void tape_do_irq (struct ccw_device *, unsigned long, struct irb *);
+static void __tape_do_irq (struct ccw_device *, unsigned long, struct irb *);
+static void __tape_remove_request(struct tape_device *, struct tape_request *);
 
 /*
  * One list to contain all tape devices of all disciplines, so
@@ -36,11 +37,6 @@
 static rwlock_t tape_device_lock = RW_LOCK_UNLOCKED;
 
 /*
- * Wait queue for tape_delete_device waits.
- */
-static DECLARE_WAIT_QUEUE_HEAD(tape_delete_wq);
-
-/*
  * Pointer to debug area.
  */
 debug_info_t *tape_dbf_area = NULL;
@@ -71,6 +67,102 @@
 };
 
 /*
+ * Some channel attached tape specific attributes.
+ *
+ * FIXME: In the future the first_minor and blocksize attribute should be
+ *        replaced by a link to the cdev tree.
+ */
+static ssize_t
+tape_medium_state_show(struct device *dev, char *buf)
+{
+	struct tape_device *tdev;
+
+	tdev = (struct tape_device *) dev->driver_data;
+	return snprintf(buf, PAGE_SIZE, "%i\n", tdev->medium_state);
+}
+
+static
+DEVICE_ATTR(medium_state, 0444, tape_medium_state_show, NULL);
+
+static ssize_t
+tape_first_minor_show(struct device *dev, char *buf)
+{
+	struct tape_device *tdev;
+
+	tdev = (struct tape_device *) dev->driver_data;
+	return snprintf(buf, PAGE_SIZE, "%i\n", tdev->first_minor);
+}
+
+static
+DEVICE_ATTR(first_minor, 0444, tape_first_minor_show, NULL);
+
+static ssize_t
+tape_state_show(struct device *dev, char *buf)
+{
+	struct tape_device *tdev;
+
+	tdev = (struct tape_device *) dev->driver_data;
+	return snprintf(buf, PAGE_SIZE, "%s\n", (tdev->first_minor < 0) ?
+		"OFFLINE" : tape_state_verbose[tdev->tape_state]);
+}
+
+static
+DEVICE_ATTR(state, 0444, tape_state_show, NULL);
+
+static ssize_t
+tape_operation_show(struct device *dev, char *buf)
+{
+	struct tape_device *tdev;
+	ssize_t rc;
+
+	tdev = (struct tape_device *) dev->driver_data;
+	if (tdev->first_minor < 0)
+		return snprintf(buf, PAGE_SIZE, "N/A\n");
+
+	spin_lock_irq(get_ccwdev_lock(tdev->cdev));
+	if (list_empty(&tdev->req_queue))
+		rc = snprintf(buf, PAGE_SIZE, "---\n");
+	else {
+		struct tape_request *req;
+
+		req = list_entry(tdev->req_queue.next, struct tape_request,
+			list);
+		rc = snprintf(buf, PAGE_SIZE, "%s\n", tape_op_verbose[req->op]);
+	}
+	spin_unlock_irq(get_ccwdev_lock(tdev->cdev));
+	return rc;
+}
+
+static
+DEVICE_ATTR(operation, 0444, tape_operation_show, NULL);
+
+static ssize_t
+tape_blocksize_show(struct device *dev, char *buf)
+{
+	struct tape_device *tdev;
+
+	tdev = (struct tape_device *) dev->driver_data;
+
+	return snprintf(buf, PAGE_SIZE, "%i\n", tdev->char_data.block_size);
+}
+
+static
+DEVICE_ATTR(blocksize, 0444, tape_blocksize_show, NULL);
+
+static struct attribute *tape_attrs[] = {
+	&dev_attr_medium_state.attr,
+	&dev_attr_first_minor.attr,
+	&dev_attr_state.attr,
+	&dev_attr_operation.attr,
+	&dev_attr_blocksize.attr,
+	NULL
+};
+
+static struct attribute_group tape_attr_group = {
+	.attrs = tape_attrs,
+};
+
+/*
  * Tape state functions
  */
 static void
@@ -139,14 +231,20 @@
 	/* Check if interrupt has already been processed */
 	if (request->callback == NULL)
 		return 0;
+
 	rc = 0;
 	for (retries = 0; retries < 5; retries++) {
 		if (retries < 2)
 			rc = ccw_device_halt(device->cdev, (long) request);
 		else
 			rc = ccw_device_clear(device->cdev, (long) request);
-		if (rc == 0)
-			break;		/* termination successful */
+
+		if (rc == 0) {                     /* Termination successful */
+			request->rc     = -EIO;
+			request->status = TAPE_REQUEST_DONE;
+			return 0;
+		}
+
 		if (rc == -ENODEV)
 			DBF_EXCEPTION(2, "device gone, retry\n");
 		else if (rc == -EIO)
@@ -156,8 +254,7 @@
 		else
 			BUG();
 	}
-	if (rc == 0)
-		request->status = TAPE_REQUEST_DONE;
+
 	return rc;
 }
 
@@ -207,8 +304,12 @@
 {
 	int rc;
 
-	if (device->tape_state != TS_INIT)
+	DBF_LH(6, "tape_enable_device(%p, %p)\n", device, discipline);
+
+	if (device->tape_state != TS_INIT) {
+		DBF_LH(3, "Tapestate not INIT (%d)\n", device->tape_state);
 		return -EINVAL;
+	}
 
 	/* Let the discipline have a go at the device. */
 	device->discipline = discipline;
@@ -218,6 +319,7 @@
 	rc = tape_assign_minor(device);
 	if (rc)
 		goto out_discipline;
+
 	rc = tapechar_setup_device(device);
 	if (rc)
 		goto out_minor;
@@ -250,7 +352,6 @@
 	struct tape_request *request;
 
 	spin_lock_irq(get_ccwdev_lock(device->cdev));
-	tape_state_set(device, TS_NOT_OPER);
 	/* Post remaining requests with -EIO */
 	list_for_each_safe(l, n, &device->req_queue) {
 		request = list_entry(l, struct tape_request, list);
@@ -258,7 +359,7 @@
 			__tape_halt_io(device, request);
 		list_del(&request->list);
 		/* Decrease ref_count for removed request. */
-		tape_put_device(device);
+		request->device = tape_put_device(device);
 		request->rc = -EIO;
 		if (request->callback != NULL)
 			request->callback(request, request->callback_data);
@@ -269,6 +370,10 @@
 	tapechar_cleanup_device(device);
 	device->discipline->cleanup_device(device);
 	tape_remove_minor(device);
+
+	/* FIXME: This should be more something like TS_OFFLINE */
+	tape_med_state_set(device, MS_UNKNOWN);
+	device->tape_state = TS_INIT;
 }
 
 /*
@@ -301,17 +406,51 @@
 	device->tape_state = TS_INIT;
 	device->medium_state = MS_UNKNOWN;
 	*device->modeset_byte = 0;
+	device->first_minor = -1;
+	atomic_set(&device->ref_count, 1);
+
 	return device;
 }
 
 /*
- * Free memory of a device structure.
+ * Get a reference to an existing device structure. This will automatically
+ * increment the reference count.
  */
-static void
-tape_free_device(struct tape_device *device)
+struct tape_device *
+tape_get_device_reference(struct tape_device *device)
+{
+	DBF_EVENT(4, "tape_get_device_reference(%p) = %i\n", device,
+		atomic_inc_return(&device->ref_count));
+
+	return device;
+}
+
+/*
+ * Decrease the reference counter of a devices structure. If the
+ * reference counter reaches zero free the device structure.
+ * The function returns a NULL pointer to be used by the caller
+ * for clearing reference pointers.
+ */
+struct tape_device *
+tape_put_device(struct tape_device *device)
 {
-	kfree(device->modeset_byte);
-	kfree(device);
+	int remain;
+
+	remain = atomic_dec_return(&device->ref_count);
+	if (remain > 0) {
+		DBF_EVENT(4, "tape_put_device(%p) -> %i\n", device, remain);
+	} else {
+		if (remain < 0) {
+			DBF_EVENT(4, "put device without reference\n");
+			PRINT_ERR("put device without reference\n");
+		} else {
+			DBF_EVENT(4, "tape_free_device(%p)\n", device);
+			kfree(device->modeset_byte);
+			kfree(device);
+		}
+	}
+
+	return NULL;			
 }
 
 /*
@@ -326,8 +465,7 @@
 	read_lock(&tape_device_lock);
 	list_for_each_entry(tmp, &tape_device_list, node) {
 		if (tmp->first_minor * TAPE_MINORS_PER_DEV == devindex) {
-			device = tmp;
-			atomic_inc(&device->ref_count);
+			device = tape_get_device_reference(tmp);
 			break;
 		}
 	}
@@ -336,25 +474,6 @@
 }
 
 /*
- * Decrease the reference counter of a devices structure. If the
- * reference counter reaches zero free the device structure and
- * wake up sleepers.
- */
-void
-tape_put_device(struct tape_device *device)
-{
-	if (atomic_dec_return(&device->ref_count) > 0)
-		return;
-	/*
-	 * Reference counter dropped to zero. This means
-	 * that the device is deleted and the last user
-	 * of the device structure is gone. That is what
-	 * tape_delete_device is waiting for. Do a wake up.
-	 */
-	wake_up(&tape_delete_wq);
-}
-
-/*
  * Driverfs tape probe function.
  */
 int
@@ -367,12 +486,12 @@
 	if (IS_ERR(device))
 		return -ENODEV;
 	PRINT_INFO("tape device %s found\n", bus_id);
-	atomic_inc(&device->ref_count);
 	cdev->dev.driver_data = device;
 	device->cdev = cdev;
-	cdev->handler = tape_do_irq;
+	cdev->handler = __tape_do_irq;
 
 	ccw_device_set_options(cdev, CCWDEV_DO_PATHGROUP);
+	sysfs_create_group(&cdev->dev.kobj, &tape_attr_group);
 
 	return 0;
 }
@@ -383,16 +502,10 @@
 int
 tape_generic_remove(struct ccw_device *cdev)
 {
-	struct tape_device *device;
-
-	device = cdev->dev.driver_data;
-	cdev->dev.driver_data = NULL;
-	if (device != NULL) {
-		tape_put_device(device);
-		wait_event(tape_delete_wq, atomic_read(&device->ref_count) == 0);
-		tape_free_device(device);
+	if (cdev->dev.driver_data != NULL) {
+		sysfs_remove_group(&cdev->dev.kobj, &tape_attr_group);
+		cdev->dev.driver_data = tape_put_device(cdev->dev.driver_data);
 	}
-	return 0;
 }
 
 /*
@@ -406,6 +519,8 @@
 	if (datasize > PAGE_SIZE || (cplength*sizeof(struct ccw1)) > PAGE_SIZE)
 		BUG();
 
+	DBF_LH(6, "tape_alloc_request(%d, %d)\n", cplength, datasize);
+
 	request = (struct tape_request *) kmalloc(sizeof(struct tape_request),
 						  GFP_KERNEL);
 	if (request == NULL) {
@@ -436,6 +551,9 @@
 		}
 		memset(request->cpdata, 0, datasize);
 	}
+	DBF_LH(6, "New request %p(%p/%p)\n", request, request->cpaddr,
+		request->cpdata);
+
 	return request;
 }
 
@@ -445,9 +563,10 @@
 void
 tape_free_request (struct tape_request * request)
 {
+	DBF_LH(6, "Free request %p\n", request);
+
 	if (request->device != NULL) {
-		tape_put_device(request->device);
-		request->device = NULL;
+		request->device = tape_put_device(request->device);
 	}
 	if (request->cpdata != NULL)
 		kfree(request->cpdata);
@@ -456,6 +575,56 @@
 	kfree(request);
 }
 
+static inline void
+__tape_do_io_list(struct tape_device *device)
+{
+	struct list_head *l, *n;
+	struct tape_request *request;
+	int rc;
+
+	DBF_LH(6, "__tape_do_io_list(%p)\n", device);
+	/*
+	 * Try to start each request on request queue until one is
+	 * started successful.
+	 */
+	list_for_each_safe(l, n, &device->req_queue) {
+		request = list_entry(l, struct tape_request, list);
+#ifdef CONFIG_S390_TAPE_BLOCK
+		if (request->op == TO_BLOCK)
+			device->discipline->check_locate(device, request);
+#endif
+		rc = ccw_device_start(device->cdev, request->cpaddr,
+				      (unsigned long) request, 0x00,
+				      request->options);
+		if (rc == 0) {
+			request->status = TAPE_REQUEST_IN_IO;
+			break;
+		}
+		/* Start failed. Remove request and indicate failure. */
+		DBF_EVENT(1, "tape: DOIO failed with er = %i\n", rc);
+
+		/* Set ending status and do callback. */
+		request->rc = rc;
+		request->status = TAPE_REQUEST_DONE;
+		__tape_remove_request(device, request);
+	}
+}
+
+static void
+__tape_remove_request(struct tape_device *device, struct tape_request *request)
+{
+	/* Remove from request queue. */
+	list_del(&request->list);
+
+	/* Do callback. */
+	if (request->callback != NULL)
+		request->callback(request, request->callback_data);
+
+	/* Start next request. */
+	if (!list_empty(&device->req_queue))
+		__tape_do_io_list(device);
+}
+
 /*
  * Write sense data to console/dbf
  */
@@ -514,12 +683,21 @@
 {
 	int rc;
 
-	if (device->tape_state != TS_IN_USE)
-		return -ENODEV;
+	switch (request->op) {
+		case TO_MSEN:
+		case TO_ASSIGN:
+		case TO_UNASSIGN:
+			if (device->tape_state == TS_INIT)
+				break;
+			if (device->tape_state == TS_UNUSED)
+				break;
+		default:
+			if (device->tape_state != TS_IN_USE)
+				return -ENODEV;
+	}
 
 	/* Increase use count of device for the added request. */
-	atomic_inc(&device->ref_count);
-	request->device = device;
+	request->device = tape_get_device_reference(device);
 
 	if (list_empty(&device->req_queue)) {
 		/* No other requests are on the queue. Start this one. */
@@ -534,9 +712,11 @@
 			DBF_EVENT(1, "tape: DOIO failed with rc = %i\n", rc);
 			return rc;
 		}
+		DBF_LH(5, "Request %p added for execution.\n", request);
 		list_add(&request->list, &device->req_queue);
 		request->status = TAPE_REQUEST_IN_IO;
 	} else {
+		DBF_LH(5, "Request %p add to queue.\n", request);
 		list_add_tail(&request->list, &device->req_queue);
 		request->status = TAPE_REQUEST_QUEUED;
 	}
@@ -637,48 +817,11 @@
 	return rc;
 }
 
-static inline void
-__tape_do_io_list(struct tape_device *device)
-{
-	struct list_head *l, *n;
-	struct tape_request *request;
-	int rc;
-
-	if (device->tape_state != TS_IN_USE)
-		return;
-	/*
-	 * Try to start each request on request queue until one is
-	 * started successful.
-	 */
-	list_for_each_safe(l, n, &device->req_queue) {
-		request = list_entry(l, struct tape_request, list);
-#ifdef CONFIG_S390_TAPE_BLOCK
-		if (request->op == TO_BLOCK)
-			device->discipline->check_locate(device, request);
-#endif
-		rc = ccw_device_start(device->cdev, request->cpaddr,
-				      (unsigned long) request, 0x00,
-				      request->options);
-		if (rc == 0) {
-			request->status = TAPE_REQUEST_IN_IO;
-			break;
-		}
-		/* Start failed. Remove request and indicate failure. */
-		DBF_EVENT(1, "tape: DOIO failed with er = %i\n", rc);
-		list_del(&request->list);
-		/* Set ending status and do callback. */
-		request->rc = rc;
-		request->status = TAPE_REQUEST_DONE;
-		if (request->callback != NULL)
-			request->callback(request, request->callback_data);
-	}
-}
-
 /*
  * Tape interrupt routine, called from the ccw_device layer
  */
 static void
-tape_do_irq (struct ccw_device *cdev, unsigned long intparm, struct irb *irb)
+__tape_do_irq (struct ccw_device *cdev, unsigned long intparm, struct irb *irb)
 {
 	struct tape_device *device;
 	struct tape_request *request;
@@ -693,11 +836,13 @@
 	}
 	request = (struct tape_request *) intparm;
 
+	DBF_LH(6, "__tape_do_irq(device=%p, request=%p)\n", device, request);
+
 	/* May be an unsolicited irq */
 	if(request != NULL)
 		request->rescnt = irb->scsw.count;
 
-	if (irb->scsw.dstat != 0x0c){
+	if (irb->scsw.dstat != 0x0c) {
 		/* Set the 'ONLINE' flag depending on sense byte 1 */
 		if(*(((__u8 *) irb->ecw) + 1) & SENSE_DRIVE_ONLINE)
 			device->tape_generic_status |= GMT_ONLINE(~0);
@@ -718,6 +863,16 @@
 		DBF_EVENT(6, "tape:device is not operational\n");
 		return;
 	}
+
+	/*
+	 * Request that were canceled still come back with an interrupt.
+	 * To detect these request the state will be set to TAPE_REQUEST_DONE.
+	 */
+	if(request != NULL && request->status == TAPE_REQUEST_DONE) {
+		__tape_remove_request(device, request);
+		return;
+	}
+
 	rc = device->discipline->irq(device, request, irb);
 	/*
 	 * rc < 0 : request finished unsuccessfully.
@@ -729,6 +884,8 @@
 	final = 0;
 	switch (rc) {
 	case TAPE_IO_SUCCESS:
+		/* Upon normal completion the device _is_ online */
+		device->tape_generic_status |= GMT_ONLINE(~0);
 		final = 1;
 		break;
 	case TAPE_IO_PENDING:
@@ -748,8 +905,6 @@
 		break;
 	case TAPE_IO_STOP:
 		__tape_halt_io(device, request);
-		rc = -EIO;
-		final = 1;
 		break;
 	default:
 		if (rc > 0) {
@@ -767,59 +922,11 @@
 			/* Set ending status. */
 			request->rc = rc;
 			request->status = TAPE_REQUEST_DONE;
-			/* Remove from request queue. */
-			list_del(&request->list);
-			/* Do callback. */
-			if (request->callback != NULL)
-				request->callback(request, request->callback_data);
+			__tape_remove_request(device, request);
+		} else {
+			__tape_do_io_list(device);
 		}
-		/* Start next request. */
-		__tape_do_io_list(device);
-	}
-}
-
-/*
- * Lock a shared tape for our exclusive use.
- */
-int
-tape_assign(struct tape_device *device)
-{
-	int rc;
-
-	rc = device->discipline->assign(device);
-	if (rc) {
-		PRINT_WARN("(%s): assign failed - device might be busy\n",
-			   device->cdev->dev.bus_id);
-		DBF_EVENT(3, "(%s): assign failed - device might be busy\n",
-			  device->cdev->dev.bus_id);
-		return rc;
-	}
-	DBF_EVENT(3, "(%s): assign lpum = %02x\n",
-		  device->cdev->dev.bus_id, 
-		  0 /* FIXME: device->devstat.lpum */ );
-	return 0;
-}
-
-/*
- * Unlock a shared tape.
- */
-int
-tape_unassign(struct tape_device *device)
-{
-	int rc;
-
-	rc = device->discipline->unassign(device);
-	if (rc) {
-		PRINT_WARN("(%s): unassign failed\n",
-			   device->cdev->dev.bus_id);
-		DBF_EVENT(3, "(%s): unassign failed\n",
-			  device->cdev->dev.bus_id);
-		return rc;
 	}
-	DBF_EVENT(3, "(%s): unassign lpum = %02x\n",
-		  device->cdev->dev.bus_id,
-		  0 /* FIXME: device->devstat.lpum */ );
-	return 0;
 }
 
 /*
@@ -884,7 +991,7 @@
 
 	/* We assume that the backends can handle count up to 500. */
 	if (mt_op == MTBSR  || mt_op == MTFSR  || mt_op == MTFSF  ||
-	    mt_op == MTBSR  || mt_op == MTFSFM || mt_op == MTBSFM) {
+	    mt_op == MTBSF  || mt_op == MTFSFM || mt_op == MTBSFM) {
 		rc = 0;
 		for (; mt_count > 500; mt_count -= 500)
 			if ((rc = fn(device, 500)) != 0)
@@ -898,14 +1005,74 @@
 }
 
 /*
+ * Hutplug event support.
+ */
+void
+tape_hotplug_event(struct tape_device *device, int devmaj, int action) {
+#ifdef CONFIG_HOTPLUG
+	char *argv[3];
+	char *envp[8];
+	char  busid[20];
+	char  major[20];
+	char  minor[20];
+
+	/* Call the busid DEVNO to be compatible with old tape.agent. */
+	sprintf(busid, "DEVNO=%s",   device->cdev->dev.bus_id);
+	sprintf(major, "MAJOR=%d",   devmaj);
+	sprintf(minor, "MINOR=%d",   device->first_minor);
+
+	argv[0] = hotplug_path;
+	argv[1] = "tape";
+	argv[2] = NULL;
+
+	envp[0] = "HOME=/";
+	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+
+	switch (action) {
+		case TAPE_HOTPLUG_CHAR_ADD:
+		case TAPE_HOTPLUG_BLOCK_ADD:
+			envp[2] = "ACTION=add";
+			break;
+		case TAPE_HOTPLUG_CHAR_REMOVE:
+		case TAPE_HOTPLUG_BLOCK_REMOVE:
+			envp[2] = "ACTION=remove";
+			break;
+		default:
+			BUG();
+	}
+	switch (action) {
+		case TAPE_HOTPLUG_CHAR_ADD:
+		case TAPE_HOTPLUG_CHAR_REMOVE:
+			envp[3] = "INTERFACE=char";
+			break;
+		case TAPE_HOTPLUG_BLOCK_ADD:
+		case TAPE_HOTPLUG_BLOCK_REMOVE:
+			envp[3] = "INTERFACE=block";
+			break;
+		default:
+			BUG();
+	}
+	envp[4] = busid;
+	envp[5] = major;
+	envp[6] = minor;
+	envp[7] = NULL;
+
+	call_usermodehelper(argv[0], argv, envp, 0);
+#endif
+}
+
+/*
  * Tape init function.
  */
 static int
 tape_init (void)
 {
-	tape_dbf_area = debug_register ( "tape", 1, 2, 3*sizeof(long));
+	tape_dbf_area = debug_register ( "tape", 1, 2, 4*sizeof(long));
 	debug_register_view(tape_dbf_area, &debug_sprintf_view);
-	DBF_EVENT(3, "tape init: ($Revision: 1.26 $)\n");
+#ifdef DBF_LIKE_HELL
+	debug_set_level(tape_dbf_area, 6);
+#endif
+	DBF_EVENT(3, "tape init: ($Revision: 1.36 $)\n");
 	tape_proc_init();
 	tapechar_init ();
 	tapeblock_init ();
@@ -930,7 +1097,8 @@
 MODULE_AUTHOR("(C) 2001 IBM Deutschland Entwicklung GmbH by Carsten Otte and "
 	      "Michael Holzheu (cotte@de.ibm.com,holzheu@de.ibm.com)");
 MODULE_DESCRIPTION("Linux on zSeries channel attached "
-		   "tape device driver ($Revision: 1.26 $)");
+		   "tape device driver ($Revision: 1.36 $)");
+MODULE_LICENSE("GPL");
 
 module_init(tape_init);
 module_exit(tape_exit);
@@ -941,6 +1109,7 @@
 EXPORT_SYMBOL(tape_generic_probe);
 EXPORT_SYMBOL(tape_enable_device);
 EXPORT_SYMBOL(tape_put_device);
+EXPORT_SYMBOL(tape_get_device_reference);
 EXPORT_SYMBOL(tape_state_verbose);
 EXPORT_SYMBOL(tape_op_verbose);
 EXPORT_SYMBOL(tape_state_set);
diff -urN linux-2.6/drivers/s390/char/tape_proc.c linux-2.6-s390/drivers/s390/char/tape_proc.c
--- linux-2.6/drivers/s390/char/tape_proc.c	Sat Oct 25 20:43:28 2003
+++ linux-2.6-s390/drivers/s390/char/tape_proc.c	Thu Nov 13 15:29:41 2003
@@ -18,7 +18,7 @@
 
 #include "tape.h"
 
-#define PRINTK_HEADER "T390:"
+#define PRINTK_HEADER "TAPE_PROC: "
 
 static const char *tape_med_st_verbose[MS_SIZE] =
 {
@@ -42,19 +42,19 @@
 
 	n = (unsigned long) v - 1;
 	if (!n) {
-		seq_printf(m, "TapeNo\tDevNo\tCuType\tCuModel\tDevType\t"
-			   "DevMod\tBlkSize\tState\tOp\tMedState\n");
+		seq_printf(m, "TapeNo\tBusID      CuType/Model\t"
+			"DevType/Model\tBlkSize\tState\tOp\tMedState\n");
 	}
 	device = tape_get_device(n);
 	if (IS_ERR(device))
 		return 0;
 	spin_lock_irq(get_ccwdev_lock(device->cdev));
 	seq_printf(m, "%d\t", (int) n);
-	seq_printf(m, "%s\t", device->cdev->dev.bus_id);
-	seq_printf(m, "%04X\t", device->cdev->id.cu_type);
+	seq_printf(m, "%-10.10s ", device->cdev->dev.bus_id);
+	seq_printf(m, "%04X/", device->cdev->id.cu_type);
 	seq_printf(m, "%02X\t", device->cdev->id.cu_model);
-	seq_printf(m, "%04X\t", device->cdev->id.dev_type);
-	seq_printf(m, "%02X\t", device->cdev->id.dev_model);
+	seq_printf(m, "%04X/", device->cdev->id.dev_type);
+	seq_printf(m, "%02X\t\t", device->cdev->id.dev_model);
 	if (device->char_data.block_size == 0)
 		seq_printf(m, "auto\t");
 	else
diff -urN linux-2.6/drivers/s390/char/tape_std.c linux-2.6-s390/drivers/s390/char/tape_std.c
--- linux-2.6/drivers/s390/char/tape_std.c	Sat Oct 25 20:42:43 2003
+++ linux-2.6-s390/drivers/s390/char/tape_std.c	Thu Nov 13 15:29:41 2003
@@ -8,12 +8,14 @@
  *		 Michael Holzheu <holzheu@de.ibm.com>
  *		 Tuan Ngo-Anh <ngoanh@de.ibm.com>
  *		 Martin Schwidefsky <schwidefsky@de.ibm.com>
+ *		 Stefan Bader <shbader@de.ibm.com>
  */
 
 #include <linux/config.h>
 #include <linux/stddef.h>
 #include <linux/kernel.h>
 #include <linux/bio.h>
+#include <linux/timer.h>
 
 #include <asm/types.h>
 #include <asm/idals.h>
@@ -23,23 +25,72 @@
 #include "tape.h"
 #include "tape_std.h"
 
-#define PRINTK_HEADER "T3xxx:"
+#define PRINTK_HEADER "TAPE_STD: "
 
 /*
  * tape_std_assign
  */
+static void
+tape_std_assign_timeout(unsigned long data)
+{
+	struct tape_request *	request;
+	struct tape_device *	device;
+
+	request = (struct tape_request *) data;
+	if ((device = request->device) == NULL)
+		BUG();
+
+	spin_lock_irq(get_ccwdev_lock(device->cdev));
+	if (request->callback != NULL) {
+		DBF_EVENT(3, "%s: Assignment timeout. Device busy.\n",
+			device->cdev->dev.bus_id);
+		PRINT_ERR("%s: Assignment timeout. Device busy.\n",
+			device->cdev->dev.bus_id);
+		ccw_device_clear(device->cdev, (long) request);
+	}
+	spin_unlock_irq(get_ccwdev_lock(device->cdev));
+}
+
 int
 tape_std_assign(struct tape_device *device)
 {
+	int                  rc;
+	struct timer_list    timeout;
 	struct tape_request *request;
 
 	request = tape_alloc_request(2, 11);
 	if (IS_ERR(request))
 		return PTR_ERR(request);
+
 	request->op = TO_ASSIGN;
 	tape_ccw_cc(request->cpaddr, ASSIGN, 11, request->cpdata);
 	tape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);
-	return tape_do_io_free(device, request);
+
+	/*
+	 * The assign command sometimes blocks if the device is assigned
+	 * to another host (actually this shouldn't happen but it does).
+	 * So we set up a timeout for this call.
+	 */
+	init_timer(&timeout);
+	timeout.function = tape_std_assign_timeout;
+	timeout.data     = (unsigned long) request;
+	timeout.expires  = jiffies + 2 * HZ;
+	add_timer(&timeout);
+
+	rc = tape_do_io_interruptible(device, request);
+
+	del_timer(&timeout);
+
+	if (rc != 0) {
+		PRINT_WARN("%s: assign failed - device might be busy\n",
+			device->cdev->dev.bus_id);
+		DBF_EVENT(3, "%s: assign failed - device might be busy\n",
+			device->cdev->dev.bus_id);
+	} else {
+		DBF_EVENT(3, "%s: Tape assigned\n", device->cdev->dev.bus_id);
+	}
+	tape_free_request(request);
+	return rc;
 }
 
 /*
@@ -48,30 +99,36 @@
 int
 tape_std_unassign (struct tape_device *device)
 {
+	int                  rc;
 	struct tape_request *request;
 
 	request = tape_alloc_request(2, 11);
 	if (IS_ERR(request))
 		return PTR_ERR(request);
+
 	request->op = TO_UNASSIGN;
 	tape_ccw_cc(request->cpaddr, UNASSIGN, 11, request->cpdata);
 	tape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);
-	return tape_do_io_free(device, request);
+
+	if ((rc = tape_do_io(device, request)) != 0) {
+		DBF_EVENT(3, "%s: Unassign failed\n", device->cdev->dev.bus_id);
+		PRINT_WARN("%s: Unassign failed\n", device->cdev->dev.bus_id);
+	} else {
+		DBF_EVENT(3, "%s: Tape unassigned\n", device->cdev->dev.bus_id);
+	}
+	tape_free_request(request);
+	return rc;
 }
 
 /*
  * TAPE390_DISPLAY: Show a string on the tape display.
  */
 int
-tape_std_display(struct tape_device *device, int cmd, unsigned long arg)
+tape_std_display(struct tape_device *device, struct display_struct *disp)
 {
-	struct display_struct d_struct;
 	struct tape_request *request;
 	int rc;
 
-	if (copy_from_user(&d_struct, (char *) arg, sizeof(d_struct)) != 0)
-		return -EFAULT;
-
 	request = tape_alloc_request(2, 17);
 	if (IS_ERR(request)) {
 		DBF_EVENT(3, "TAPE: load display failed\n");
@@ -79,9 +136,10 @@
 	}
 	request->op = TO_DIS;
 
-	*(unsigned char *) request->cpdata = d_struct.cntrl;
-	memcpy(((unsigned char *) request->cpdata) + 1, d_struct.message1, 8);
-	memcpy(((unsigned char *) request->cpdata) + 9, d_struct.message2, 8);
+	*(unsigned char *) request->cpdata = disp->cntrl;
+	DBF_EVENT(5, "TAPE: display cntrl=%04x\n", disp->cntrl);
+	memcpy(((unsigned char *) request->cpdata) + 1, disp->message1, 8);
+	memcpy(((unsigned char *) request->cpdata) + 9, disp->message2, 8);
 	ASCEBC(((unsigned char*) request->cpdata) + 1, 16);
 
 	tape_ccw_cc(request->cpaddr, LOAD_DISPLAY, 17, request->cpdata);
@@ -118,6 +176,25 @@
 	return rc;
 }
 
+int
+tape_std_terminate_write(struct tape_device *device)
+{
+	int rc;
+
+	if(device->required_tapemarks == 0)
+		return 0;
+
+	DBF_LH(5, "tape%d: terminate write %dxEOF\n", device->first_minor,
+		device->required_tapemarks);
+
+	rc = tape_std_mtweof(device, device->required_tapemarks);
+	if (rc)
+		return rc;
+
+	device->required_tapemarks = 0;
+	return tape_std_mtbsr(device, 1);
+}
+
 /*
  * MTLOAD: Loads the tape.
  * The default implementation just wait until the tape medium state changes
@@ -138,6 +215,7 @@
 {
 	struct idal_buffer *new;
 
+	DBF_LH(6, "tape_std_mtsetblk(%d)\n", count);
 	if (count <= 0) {
 		/*
 		 * Just set block_size to 0. tapechar_read/tapechar_write
@@ -151,6 +229,15 @@
 	    device->char_data.idal_buf->size == count)
 		/* We already have a idal buffer of that size. */
 		return 0;
+
+	if (count > MAX_BLOCKSIZE) {
+		DBF_EVENT(3, "Invalid block size (%d > %d) given.\n",
+			count, MAX_BLOCKSIZE);
+		PRINT_ERR("Invalid block size (%d > %d) given.\n",
+			count, MAX_BLOCKSIZE);
+		return -EINVAL;
+	}
+
 	/* Allocate a new idal buffer. */
 	new = idal_buffer_alloc(count, 0);
 	if (new == NULL)
@@ -159,6 +246,9 @@
 		idal_buffer_free(device->char_data.idal_buf);
 	device->char_data.idal_buf = new;
 	device->char_data.block_size = count;
+
+	DBF_LH(6, "new blocksize is %d\n", device->char_data.block_size);
+
 	return 0;
 }
 
@@ -192,6 +282,7 @@
 			  device->modeset_byte);
 	ccw = tape_ccw_repeat(ccw, FORSPACEFILE, mt_count);
 	ccw = tape_ccw_end(ccw, NOP, 0, NULL);
+
 	/* execute it */
 	return tape_do_io_free(device, request);
 }
@@ -205,6 +296,7 @@
 {
 	struct tape_request *request;
 	struct ccw1 *ccw;
+	int rc;
 
 	request = tape_alloc_request(mt_count + 2, 0);
 	if (IS_ERR(request))
@@ -215,8 +307,16 @@
 			  device->modeset_byte);
 	ccw = tape_ccw_repeat(ccw, FORSPACEBLOCK, mt_count);
 	ccw = tape_ccw_end(ccw, NOP, 0, NULL);
+
 	/* execute it */
-	return tape_do_io_free(device, request);
+	rc = tape_do_io(device, request);
+	if (rc == 0 && request->rescnt > 0) {
+		DBF_LH(3, "FSR over tapemark\n");
+		rc = 1;
+	}
+	tape_free_request(request);
+
+	return rc;
 }
 
 /*
@@ -228,6 +328,7 @@
 {
 	struct tape_request *request;
 	struct ccw1 *ccw;
+	int rc;
 
 	request = tape_alloc_request(mt_count + 2, 0);
 	if (IS_ERR(request))
@@ -238,8 +339,16 @@
 			  device->modeset_byte);
 	ccw = tape_ccw_repeat(ccw, BACKSPACEBLOCK, mt_count);
 	ccw = tape_ccw_end(ccw, NOP, 0, NULL);
+
 	/* execute it */
-	return tape_do_io_free(device, request);
+	rc = tape_do_io(device, request);
+	if (rc == 0 && request->rescnt > 0) {
+		DBF_LH(3, "BSR over tapemark\n");
+		rc = 1;
+	}
+	tape_free_request(request);
+
+	return rc;
 }
 
 /*
@@ -260,6 +369,7 @@
 			  device->modeset_byte);
 	ccw = tape_ccw_repeat(ccw, WRITETAPEMARK, mt_count);
 	ccw = tape_ccw_end(ccw, NOP, 0, NULL);
+
 	/* execute it */
 	return tape_do_io_free(device, request);
 }
@@ -284,6 +394,7 @@
 			  device->modeset_byte);
 	ccw = tape_ccw_repeat(ccw, BACKSPACEFILE, mt_count);
 	ccw = tape_ccw_end(ccw, NOP, 0, NULL);
+
 	/* execute it */
 	return tape_do_io_free(device, request);
 }
@@ -309,18 +420,12 @@
 	ccw = tape_ccw_repeat(ccw, BACKSPACEFILE, mt_count);
 	ccw = tape_ccw_end(ccw, NOP, 0, NULL);
 	/* execute it */
-	rc = tape_do_io(device, request);
+	rc = tape_do_io_free(device, request);
 	if (rc == 0) {
-		request->op = TO_FSF;
-		/* need to skip forward over the filemark. */
-		tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,
-			    device->modeset_byte);
-		tape_ccw_cc(request->cpaddr + 1, FORSPACEFILE, 0, NULL);
-		tape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);
-		/* execute it */
-		rc = tape_do_io(device, request);
+		rc = tape_std_mtfsr(device, 1);
+		if (rc > 0)
+			rc = 0;
 	}
-	tape_free_request(request);
 	return rc;
 }
 
@@ -346,18 +451,13 @@
 	ccw = tape_ccw_repeat(ccw, FORSPACEFILE, mt_count);
 	ccw = tape_ccw_end(ccw, NOP, 0, NULL);
 	/* execute it */
-	rc = tape_do_io(device, request);
+	rc = tape_do_io_free(device, request);
 	if (rc == 0) {
-		request->op = TO_BSF;
-		/* need to skip forward over the filemark. */
-		tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,
-			    device->modeset_byte);
-		tape_ccw_cc(request->cpaddr + 1, BACKSPACEFILE, 0, NULL);
-		tape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);
-		/* execute it */
-		rc = tape_do_io(device, request);
+		rc = tape_std_mtbsr(device, 1);
+		if (rc > 0)
+			rc = 0;
 	}
-	tape_free_request(request);
+
 	return rc;
 }
 
@@ -378,6 +478,7 @@
 		    device->modeset_byte);
 	tape_ccw_cc(request->cpaddr + 1, REWIND, 0, NULL);
 	tape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);
+
 	/* execute it */
 	return tape_do_io_free(device, request);
 }
@@ -399,6 +500,7 @@
 	tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);
 	tape_ccw_cc(request->cpaddr + 1, REWIND_UNLOAD, 0, NULL);
 	tape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);
+
 	/* execute it */
 	return tape_do_io_free(device, request);
 }
@@ -430,22 +532,28 @@
 int
 tape_std_mteom(struct tape_device *device, int mt_count)
 {
-	struct tape_request *request;
+	int rc;
 
-	request = tape_alloc_request(4, 0);
-	if (IS_ERR(request))
-		return PTR_ERR(request);
-	request->op = TO_FSF;
-	/* setup ccws */
-	tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);
-	tape_ccw_cc(request->cpaddr + 1,FORSPACEFILE, 0, NULL);
-	tape_ccw_cc(request->cpaddr + 2, NOP, 0, NULL);
-	tape_ccw_end(request->cpaddr + 3, CCW_CMD_TIC, 0, request->cpaddr);
-	/* execute it */
-	tape_do_io_interruptible(device, request);
-	tape_free_request(request);
-	/* MTEOM/MTRETEN errors get ignored. */
-	return 0;
+	/*
+	 * Seek from the beginning of tape (rewind).
+	 */
+	if ((rc = tape_std_mtrew(device, 1)) < 0)
+		return rc;
+
+	/*
+	 * The logical end of volume is given by two sewuential tapemarks.
+	 * Look for this by skipping to the next file (over one tapemark)
+	 * and then test for another one (fsr returns 1 if a tapemark was
+	 * encountered).
+	 */
+	do {
+		if ((rc = tape_std_mtfsf(device, 1)) < 0)
+			return rc;
+		if ((rc = tape_std_mtfsr(device, 1)) < 0)
+			return rc;
+	} while (rc == 0);
+
+	return tape_std_mtbsr(device, 1);
 }
 
 /*
@@ -480,7 +588,7 @@
 {
 	struct tape_request *request;
 
-	request = tape_alloc_request(5, 0);
+	request = tape_alloc_request(6, 0);
 	if (IS_ERR(request))
 		return PTR_ERR(request);
 	request->op = TO_DSE;
@@ -489,7 +597,9 @@
 	tape_ccw_cc(request->cpaddr + 1, REWIND, 0, NULL);
 	tape_ccw_cc(request->cpaddr + 2, ERASE_GAP, 0, NULL);
 	tape_ccw_cc(request->cpaddr + 3, DATA_SEC_ERASE, 0, NULL);
-	tape_ccw_end(request->cpaddr + 4, NOP, 0, NULL);
+	tape_ccw_cc(request->cpaddr + 4, REWIND, 0, NULL);
+	tape_ccw_end(request->cpaddr + 5, NOP, 0, NULL);
+
 	/* execute it */
 	return tape_do_io_free(device, request);
 }
@@ -500,18 +610,7 @@
 int
 tape_std_mtunload(struct tape_device *device, int mt_count)
 {
-	struct tape_request *request;
-
-	request = tape_alloc_request(3, 32);
-	if (IS_ERR(request))
-		return PTR_ERR(request);
-	request->op = TO_RUN;
-	/* setup ccws */
-	tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);
-	tape_ccw_cc(request->cpaddr + 1, REWIND_UNLOAD, 0, NULL);
-	tape_ccw_end(request->cpaddr + 2, SENSE, 32, request->cpdata);
-	/* execute it */
-	return tape_do_io_free(device, request);
+	return tape_std_mtoffl(device, mt_count);
 }
 
 /*
@@ -622,9 +721,9 @@
 	 * End of volume: We have to backspace the last written record, then
 	 * we TRY to write a tapemark and then backspace over the written TM
 	 */
-	if (tape_mtop(device, MTBSR, 1) == 0 &&
-	    tape_mtop(device, MTWEOF, 1) == 0) {
-		tape_mtop(device, MTBSR, 1);
+	if (tape_std_mtbsr(device, 1) == 0 &&
+	    tape_std_mtweof(device, 1) == 0) {
+		tape_std_mtbsr(device, 1);
 	}
 }
 
diff -urN linux-2.6/drivers/s390/char/tape_std.h linux-2.6-s390/drivers/s390/char/tape_std.h
--- linux-2.6/drivers/s390/char/tape_std.h	Sat Oct 25 20:43:03 2003
+++ linux-2.6-s390/drivers/s390/char/tape_std.h	Thu Nov 13 15:29:41 2003
@@ -10,9 +10,16 @@
  */
 
 #ifndef _TAPE_STD_H
-
 #define _TAPE_STD_H
 
+#include <asm/tape390.h>
+
+/*
+ * Biggest block size to handle. Currently 64K because we only build
+ * channel programs without data chaining.
+ */
+#define MAX_BLOCKSIZE   65535
+
 /*
  * The CCW commands for the Tape type of command.
  */
@@ -105,7 +112,8 @@
 int tape_std_assign(struct tape_device *);
 int tape_std_unassign(struct tape_device *);
 int tape_std_read_block_id(struct tape_device *device, __u64 *id);
-int tape_std_display(struct tape_device *, int, unsigned long);
+int tape_std_display(struct tape_device *, struct display_struct *disp);
+int tape_std_terminate_write(struct tape_device *);
 
 /* Standard magnetic tape commands. */
 int tape_std_mtbsf(struct tape_device *, int);
