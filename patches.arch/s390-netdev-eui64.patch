Subject: Per-device specific EUI64 information
From: Martin Schwidefsky <schwidefsky@de.ibm.com>
References: #34980

This patch splits off the EUI64 address generation into a per-device
specific function. It is required for network cards shared across
several instances (e.g. S/390 qeth devices), as each of this instance
need to generate a different link-local IPv6 address.

This patch is _not_ in mainline, as davem thinks it should be moved
into the IPv6 code entirely. However, this would induce a rewrite of
the IPv6 initialisation, as currently the IPv6 information is only
allocated after the card is initialised, making prior initialisation
impossible. So no-one has ventured to do it so far.

Without this patch, IPv6 will not work on S/390 qeth/hsi devices.

Signed-off-by: Hannes Reinecke <hare@suse.de>

Index: linux-2.6.10/net/ethernet/eth.c
===================================================================
--- linux-2.6.10.orig/net/ethernet/eth.c
+++ linux-2.6.10/net/ethernet/eth.c
@@ -274,9 +274,10 @@ void ether_setup(struct net_device *dev)
 	dev->set_mac_address 	= eth_mac_addr;
 	dev->hard_header_cache	= eth_header_cache;
 	dev->header_cache_update= eth_header_cache_update;
 	dev->hard_header_parse	= eth_header_parse;
-
+	dev->generate_eui64	= NULL;
+	dev->dev_id		= 0;
 	dev->type		= ARPHRD_ETHER;
 	dev->hard_header_len 	= ETH_HLEN;
 	dev->mtu		= 1500; /* eth_mtu */
 	dev->addr_len		= ETH_ALEN;
Index: linux-2.6.10/net/802/fddi.c
===================================================================
--- linux-2.6.10.orig/net/802/fddi.c
+++ linux-2.6.10/net/802/fddi.c
@@ -179,8 +179,10 @@ void fddi_setup(struct net_device *dev)
 {
 	dev->change_mtu		= fddi_change_mtu;
 	dev->hard_header	= fddi_header;
 	dev->rebuild_header	= fddi_rebuild_header;
+	dev->generate_eui64	= NULL;
+	dev->dev_id		= 0;
 
 	dev->type		= ARPHRD_FDDI;
 	dev->hard_header_len	= FDDI_K_SNAP_HLEN+3;	/* Assume 802.2 SNAP hdr len + 3 pad bytes */
 	dev->mtu		= FDDI_K_SNAP_DLEN;		/* Assume max payload of 802.2 SNAP frame */
Index: linux-2.6.10/net/802/tr.c
===================================================================
--- linux-2.6.10.orig/net/802/tr.c
+++ linux-2.6.10/net/802/tr.c
@@ -590,8 +590,10 @@ void tr_setup(struct net_device *dev)
 	 */
 	
 	dev->hard_header	= tr_header;
 	dev->rebuild_header	= tr_rebuild_header;
+	dev->generate_eui64	= NULL;
+	dev->dev_id		= 0;
 
 	dev->type		= ARPHRD_IEEE802_TR;
 	dev->hard_header_len	= TR_HLEN;
 	dev->mtu		= 2000;
Index: linux-2.6.8/include/linux/netdevice.h
===================================================================
--- linux-2.6.8.orig/include/linux/netdevice.h
+++ linux-2.6.8/include/linux/netdevice.h
@@ -466,8 +466,9 @@ struct net_device
 	int			(*hard_header_parse)(struct sk_buff *skb,
 						     unsigned char *haddr);
 	int			(*neigh_setup)(struct net_device *dev, struct neigh_parms *);
 	int			(*accept_fastpath)(struct net_device *, struct dst_entry*);
+	int                     (*generate_eui64)(u8 *eui, struct net_device *dev);
 #ifdef CONFIG_NETPOLL
 	int			netpoll_rx;
 #endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
Index: linux-2.6.8/include/net/addrconf.h
===================================================================
--- linux-2.6.8.orig/include/net/addrconf.h
+++ linux-2.6.8/include/net/addrconf.h
@@ -68,8 +68,9 @@ extern int			ipv6_get_saddr(struct dst_e
 extern int			ipv6_dev_get_saddr(struct net_device *dev, 
 					       struct in6_addr *daddr,
 					       struct in6_addr *saddr);
 extern int			ipv6_get_lladdr(struct net_device *dev, struct in6_addr *);
+extern int                      ipv6_generate_eui64(u8 *eui, struct net_device *dev);
 extern int			ipv6_rcv_saddr_equal(const struct sock *sk, 
 						      const struct sock *sk2);
 extern void			addrconf_join_solict(struct net_device *dev,
 					struct in6_addr *addr);
Index: linux-2.6.8/net/8021q/vlan.c
===================================================================
--- linux-2.6.8.orig/net/8021q/vlan.c
+++ linux-2.6.8/net/8021q/vlan.c
@@ -447,8 +447,12 @@ static struct net_device *register_vlan_
 	new_dev->flags &= ~IFF_UP;
 
 	new_dev->state = real_dev->state & VLAN_LINK_STATE_MASK;
 
+	/* ipv6 shared card related stuff */
+	new_dev->dev_id = real_dev->dev_id;
+	new_dev->generate_eui64 = real_dev->generate_eui64;
+
 	/* need 4 bytes for extra VLAN header info,
 	 * hope the underlying device can handle it.
 	 */
 	new_dev->mtu = real_dev->mtu;
Index: linux-2.6.8/net/ipv6/addrconf.c
===================================================================
--- linux-2.6.8.orig/net/ipv6/addrconf.c
+++ linux-2.6.8/net/ipv6/addrconf.c
@@ -1074,8 +1074,8 @@ void addrconf_leave_anycast(struct inet6_
 	__ipv6_dev_ac_dec(ifp->idev, &addr);
 }
 
-static int ipv6_generate_eui64(u8 *eui, struct net_device *dev)
+int ipv6_generate_eui64(u8 *eui, struct net_device *dev)
 {
 	switch (dev->type) {
 	case ARPHRD_ETHER:
 	case ARPHRD_FDDI:
@@ -1131,9 +1131,9 @@ static int __ipv6_regen_rndid(struct ine
 	sg[1].length = 8;
 
 	dev = idev->dev;
 
-	if (ipv6_generate_eui64(idev->work_eui64, dev)) {
+	if (dev->generate_eui64(idev->work_eui64, dev)) {
 		printk(KERN_INFO
 			"__ipv6_regen_rndid(idev=%p): cannot get EUI64 identifier; use random bytes.\n",
 			idev);
 		get_random_bytes(idev->work_eui64, sizeof(idev->work_eui64));
@@ -1395,9 +1395,9 @@ void addrconf_prefix_rcv(struct net_devi
 		int create = 0, update_lft = 0;
 
 		if (pinfo->prefix_len == 64) {
 			memcpy(&addr, &pinfo->prefix, 8);
-			if (ipv6_generate_eui64(addr.s6_addr + 8, dev) &&
+			if (dev->generate_eui64(addr.s6_addr + 8, dev) &&
 			    ipv6_inherit_eui64(addr.s6_addr + 8, in6_dev)) {
 				in6_dev_put(in6_dev);
 				return;
 			}
@@ -1798,16 +1798,18 @@ static void addrconf_dev_config(struct n
 		/* Alas, we support only Ethernet autoconfiguration. */
 		return;
 	}
 
+	if (!dev->generate_eui64) 
+		dev->generate_eui64 = ipv6_generate_eui64;
+
 	idev = addrconf_add_dev(dev);
 	if (idev == NULL)
 		return;
 
 	memset(&addr, 0, sizeof(struct in6_addr));
 	addr.s6_addr32[0] = htonl(0xFE800000);
-
-	if (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)
+	if (dev->generate_eui64(addr.s6_addr + 8, dev) == 0)
 		addrconf_add_linklocal(idev, &addr);
 }
 
 static void addrconf_sit_config(struct net_device *dev)
