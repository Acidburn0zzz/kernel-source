- Description: qeth: bad cable pull/cable plug behaviour
  Symptom:     After a cable pull debug messages are displayed. After re-plugging
               of cable network does not work.
  Problem:     Debug messages were caused by calling a sleeping function from an
               atomic context. Network didn't work after re-plugging cable because
               IP addresses need to be registered on the card again, which we did
               not do.
  Solution:    Changed behaviour in response to STOPLAN/STARTLAN commands. Don't
               call dev_close/dev_open any more. Call netif_carrier_off/.._on
               instead. At receipt of STARTLAN command re-register all IP
               addresses.
  Problem-ID:  --
  Archs:       s390-31, s390-64

- Description: qeth: incorrect handling of buffer_count sysfs attribute
  Symptom:     Decimal values piped into buffer_count are treated as hex
               values. In addition, changing the buffer_count of a qeth card
               leads to a hanging network connection and addressing exception.
  Problem:     The first symptom is caused by wrong number base used in
               simple_strtoul. Second symptom is due to not freeing and
               reallocating QDIO buffers at offline/online.
  Solution:    Fixed number base for simple_strtoul in qeth_dev_bufcnt_store.
               Check new buffer_count value. If it is different from the old one
               call qeth_realloc_buffer_pool -> buffers will be freshly allocated
               using the new buffer_count.
  Problem-ID:  --
  Archs:       s390-31, s390-64

diff -ruN linux-2.6.5/drivers/s390/net/qeth.h linux-2.5/drivers/s390/net/qeth.h
--- linux-2.6.5/drivers/s390/net/qeth.h	Wed Apr 28 17:18:14 2004
+++ linux-2.5/drivers/s390/net/qeth.h	Tue Apr 27 17:30:15 2004
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.98.2.1 $"
+#define VERSION_QETH_H 		"$Revision: 1.98.2.3 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -398,11 +398,6 @@
 	struct qdio_buffer qdio_bufs[QDIO_MAX_BUFFERS_PER_Q];
 	struct qeth_qdio_buffer bufs[QDIO_MAX_BUFFERS_PER_Q];
 	/* 
-	 * buf_to_process means "buffer primed by hardware,
-	 * has to be read in by driver"; current state PRIMED
-	 */
-	volatile int next_buf_to_process;
-	/*
 	 * buf_to_init means "buffer must be initialized by driver and must
 	 * be made available for hardware" -> state is set to EMPTY
 	 */
@@ -493,8 +488,7 @@
 	CARD_STATE_DOWN,
 	CARD_STATE_HARDSETUP,
 	CARD_STATE_SOFTSETUP,
-	CARD_STATE_UP_LAN_OFFLINE,
-	CARD_STATE_UP_LAN_ONLINE,
+	CARD_STATE_UP,
 	CARD_STATE_RECOVER,
 };
 
@@ -981,24 +975,27 @@
 extern int
 qeth_setrouting_v6(struct qeth_card *);
 
-int
+extern int
 qeth_add_ipato_entry(struct qeth_card *, struct qeth_ipato_entry *);
 
-void
+extern void
 qeth_del_ipato_entry(struct qeth_card *, enum qeth_prot_versions, u8 *, int);
 
-int
+extern int
 qeth_add_vipa(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 
-void
+extern void
 qeth_del_vipa(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 
-int
+extern int
 qeth_add_rxip(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 
-void
+extern void
 qeth_del_rxip(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 
-void
+extern void
 qeth_schedule_recovery(struct qeth_card *);
+
+extern int
+qeth_realloc_buffer_pool(struct qeth_card *, int);
 #endif /* __QETH_H__ */
diff -ruN linux-2.6.5/drivers/s390/net/qeth_main.c linux-2.5/drivers/s390/net/qeth_main.c
--- linux-2.6.5/drivers/s390/net/qeth_main.c	Wed Apr 28 17:18:14 2004
+++ linux-2.5/drivers/s390/net/qeth_main.c	Tue Apr 27 17:30:15 2004
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.4 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.6 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.4 $	 $Date: 2004/04/22 15:20:46 $
+ *    $Revision: 1.77.2.6 $	 $Date: 2004/04/27 15:30:15 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.4 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.6 $"
 static const char *version = "qeth S/390 OSA-Express driver ("
 	VERSION_QETH_C "/" VERSION_QETH_H "/" VERSION_QETH_MPC_H
 	QETH_VERSION_IPV6 QETH_VERSION_VLAN ")";
@@ -457,8 +457,7 @@
 	ccw_device_set_offline(CARD_DDEV(card));
 	ccw_device_set_offline(CARD_WDEV(card));
 	ccw_device_set_offline(CARD_RDEV(card));
-	if ((recover_flag == CARD_STATE_UP_LAN_ONLINE) ||
-	    (recover_flag == CARD_STATE_UP_LAN_OFFLINE))
+	if (recover_flag == CARD_STATE_UP)
 		card->state = CARD_STATE_RECOVER;
 	return 0;
 }
@@ -824,7 +823,7 @@
 	struct qeth_card *card;
 
 	card = (struct qeth_card *) ptr;
-	daemonize("qeth_get_mcaddrs");
+	daemonize("qeth_reg_mcaddrs");
 	QETH_DBF_TEXT(trace,4,"regmcth1");
 	if (!qeth_do_run_thread(card, QETH_SET_MC_THREAD))
 		return 0;
@@ -1505,11 +1504,21 @@
 	spin_unlock_irqrestore(&reply->card->lock, flags);
 }
 
+static void
+qeth_reset_ip_addresses(struct qeth_card *card)
+{
+	QETH_DBF_TEXT(trace, 2, "rstipadd");
+
+	qeth_clear_ip_list(card, 0, 1);
+	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
+	qeth_set_thread_start_bit(card, QETH_SET_MC_THREAD);
+	schedule_work(&card->kernel_thread_starter);
+}
+
 static struct qeth_ipa_cmd * 
 qeth_check_ipa_data(struct qeth_card *card, struct qeth_cmd_buffer *iob)
 {
 	struct qeth_ipa_cmd *cmd = NULL;
-	enum qeth_card_states old_state;
 
 	QETH_DBF_TEXT(trace,5,"chkipad");
 	if (IS_IPA(iob->data)){
@@ -1522,30 +1531,27 @@
 				PRINT_WARN("Link failure on %s (CHPID 0x%X) - "
 					   "there is a network problem or "
 					   "someone pulled the cable or "
-					   "disabled the port. Setting state "
-					   "of interface to DOWN.\n",
+					   "disabled the port.\n",
 					   card->info.if_name,
 					   card->info.chpid);
 				card->lan_online = 0;
-				old_state = card->state;
-				rtnl_lock();
-				dev_close(card->dev);
-				rtnl_unlock();
-				if ((old_state == CARD_STATE_UP_LAN_ONLINE) ||
-				    (old_state == CARD_STATE_UP_LAN_OFFLINE))
-					card->state = CARD_STATE_UP_LAN_OFFLINE;
+				if (netif_carrier_ok(card->dev)) {
+					netif_carrier_off(card->dev);
+					netif_stop_queue(card->dev);
+				}
 				return NULL;
 			case IPA_CMD_STARTLAN:
 				PRINT_INFO("Link reestablished on %s "
-					   "(CHPID 0x%X)\n",
+					   "(CHPID 0x%X). Scheduling "
+					   "IP address reset.\n",
 					   card->info.if_name,
 					   card->info.chpid);
 				card->lan_online = 1;
-				if (card->state == CARD_STATE_UP_LAN_OFFLINE){
-					rtnl_lock();
-					dev_open(card->dev);
-					rtnl_unlock();
+				if (!netif_carrier_ok(card->dev)) {
+					netif_carrier_on(card->dev);
+					netif_wake_queue(card->dev);
 				}
+				qeth_reset_ip_addresses(card);
 				return NULL;
 			case IPA_CMD_REGISTER_LOCAL_ADDR:
 				QETH_DBF_TEXT(trace,3, "irla");
@@ -2677,6 +2683,7 @@
 	void *ptr;
 	int i, j;
 	
+	QETH_DBF_TEXT(trace,5,"clwkpool");
 	for (i = 0; i < card->qdio.init_pool.buf_count; ++i){
 	 	pool_entry = kmalloc(sizeof(*pool_entry), GFP_KERNEL);
 		if (!pool_entry){
@@ -2697,12 +2704,27 @@
 		}
 		list_add(&pool_entry->init_list, 
 			 &card->qdio.init_pool.entry_list);
-		list_add(&pool_entry->list, 
-			 &card->qdio.in_buf_pool.entry_list);
 	}
 	return 0;
 }
 
+int
+qeth_realloc_buffer_pool(struct qeth_card *card, int bufcnt)
+{
+	QETH_DBF_TEXT(trace, 2, "realcbp");
+
+	if ((card->state != CARD_STATE_DOWN) &&
+	    (card->state != CARD_STATE_RECOVER))
+		return -EPERM;
+
+	/* TODO: steel/add buffers from/to a running card's buffer pool (?) */
+	qeth_clear_working_pool_list(card);
+	qeth_free_buffer_pool(card);
+	card->qdio.in_buf_pool.buf_count = bufcnt;
+	card->qdio.init_pool.buf_count = bufcnt;
+	return qeth_alloc_buffer_pool(card);
+}
+
 static int
 qeth_alloc_qdio_buffers(struct qeth_card *card)
 {
@@ -2710,10 +2732,9 @@
 	
 	QETH_DBF_TEXT(setup, 2, "allcqdbf");
 
-	if (card->qdio.state == QETH_QDIO_ALLOCATED) {
-		qeth_initialize_working_pool_list(card);
+	if (card->qdio.state == QETH_QDIO_ALLOCATED)
 		return 0;
-	}
+		
 	card->qdio.in_q = kmalloc(sizeof(struct qeth_qdio_q), GFP_KERNEL);
 	if (!card->qdio.in_q)
 		return - ENOMEM;
@@ -2826,14 +2847,13 @@
 	/* inbound queue */
 	memset(card->qdio.in_q->qdio_bufs, 0,
 	       QDIO_MAX_BUFFERS_PER_Q * sizeof(struct qdio_buffer));
-	card->qdio.in_q->next_buf_to_process = 0;
-	card->qdio.in_q->next_buf_to_init = 0;
+	qeth_initialize_working_pool_list(card);
 	/*give only as many buffers to hardware as we have buffer pool entries*/
-	for (i = 0; i < card->qdio.in_buf_pool.buf_count; ++i)
+	for (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)
 		qeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);
-	card->qdio.in_q->next_buf_to_init = card->qdio.in_buf_pool.buf_count;
+	card->qdio.in_q->next_buf_to_init = card->qdio.in_buf_pool.buf_count - 1;
 	rc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0, 0,
-		     card->qdio.in_buf_pool.buf_count, NULL);
+		     card->qdio.in_buf_pool.buf_count - 1, NULL);
 	if (rc) {
 		QETH_DBF_TEXT_(setup, 2, "1err%d", rc);
 		return rc;
@@ -3171,7 +3191,7 @@
 		card->stats.tx_errors++;
 		return -EIO;
 	}
-	if (card->state != CARD_STATE_UP_LAN_ONLINE) {
+	if ((card->state != CARD_STATE_UP) || !netif_carrier_ok(dev)) {
 		card->stats.tx_dropped++;
 		card->stats.tx_errors++;
 		card->stats.tx_carrier_errors++;
@@ -3274,18 +3294,19 @@
 	
 	card = (struct qeth_card *) dev->priv;
 
-	if ((card->state != CARD_STATE_SOFTSETUP) &&
-	    (card->state != CARD_STATE_UP_LAN_OFFLINE))
+	if (card->state != CARD_STATE_SOFTSETUP)
 		return -ENODEV;
-	if (!card->lan_online){
-		card->state = CARD_STATE_UP_LAN_OFFLINE;
-		return -EIO;
-	}
 
 	card->dev->flags |= IFF_UP;
 	netif_start_queue(dev);
 	card->data.state = CH_STATE_UP;
-	card->state = CARD_STATE_UP_LAN_ONLINE;	
+	card->state = CARD_STATE_UP;
+	
+	if (!card->lan_online){
+		if (netif_carrier_ok(dev))
+			netif_carrier_off(dev);
+		netif_stop_queue(dev);
+	}
 	return 0;		
 }
 
@@ -3300,8 +3321,7 @@
 
 	netif_stop_queue(dev);
 	card->dev->flags &= ~IFF_UP;
-	if ((card->state == CARD_STATE_UP_LAN_ONLINE) ||
-	    (card->state == CARD_STATE_UP_LAN_OFFLINE))
+	if (card->state == CARD_STATE_UP)
 		card->state = CARD_STATE_SOFTSETUP; 
 	return 0;
 }
@@ -3982,7 +4002,12 @@
 	
 	QETH_DBF_TEXT(trace,3,"arpquery");
 
-	/* TODO: really not supported by GuestLAN? */
+	/*
+	 * currently GuestLAN  does only deliver all zeros on query arp,
+	 * even though arp processing is supported (according to IPA supp.
+	 * funcs flags); since all zeros is no valueable information,
+	 * we say EOPNOTSUPP for all ARP functions
+	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
@@ -4052,7 +4077,12 @@
 
 	QETH_DBF_TEXT(trace,3,"arpadent");
 
-	/* TODO: really not supported by GuestLAN? */
+	/*
+	 * currently GuestLAN  does only deliver all zeros on query arp,
+	 * even though arp processing is supported (according to IPA supp.
+	 * funcs flags); since all zeros is no valueable information,
+	 * we say EOPNOTSUPP for all ARP functions
+	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
@@ -4090,7 +4120,12 @@
 	
 	QETH_DBF_TEXT(trace,3,"arprment");
 	
-	/* TODO: really not supported by GuestLAN? */
+	/*
+	 * currently GuestLAN  does only deliver all zeros on query arp,
+	 * even though arp processing is supported (according to IPA supp.
+	 * funcs flags); since all zeros is no valueable information,
+	 * we say EOPNOTSUPP for all ARP functions
+	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
@@ -4126,7 +4161,12 @@
 	
 	QETH_DBF_TEXT(trace,3,"arpflush");
 	
-	/* TODO: really not supported by GuestLAN? */
+	/*
+	 * currently GuestLAN  does only deliver all zeros on query arp,
+	 * even though arp processing is supported (according to IPA supp.
+	 * funcs flags); since all zeros is no valueable information,
+	 * we say EOPNOTSUPP for all ARP functions
+	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
@@ -4156,8 +4196,7 @@
 	if (!card)
 		return -ENODEV;
 
-	if ((card->state != CARD_STATE_UP_LAN_ONLINE) &&
-	    (card->state != CARD_STATE_UP_LAN_OFFLINE))
+	if (card->state != CARD_STATE_UP)
 		return -ENODEV;
 
 	switch (cmd){
@@ -5828,8 +5867,7 @@
 		return -ERESTARTSYS;
 	if (card->read.state == CH_STATE_UP &&
 	    card->write.state == CH_STATE_UP &&
-	    ((card->state == CARD_STATE_UP_LAN_ONLINE) ||
-	     (card->state == CARD_STATE_UP_LAN_OFFLINE))) {
+	    (card->state == CARD_STATE_UP)) {
 		recover_flag = 1;
 		rtnl_lock();
 		dev_close(card->dev);
diff -ruN linux-2.6.5/drivers/s390/net/qeth_sys.c linux-2.5/drivers/s390/net/qeth_sys.c
--- linux-2.6.5/drivers/s390/net/qeth_sys.c	Wed Apr 28 17:18:14 2004
+++ linux-2.5/drivers/s390/net/qeth_sys.c	Tue Apr 27 17:30:16 2004
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19.2.1 $)
+ * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19.2.3 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to sysfs.
@@ -41,10 +41,11 @@
 		return sprintf(buf, "HARDSETUP\n");
 	case CARD_STATE_SOFTSETUP:
 		return sprintf(buf, "SOFTSETUP\n");
-	case CARD_STATE_UP_LAN_OFFLINE:
-		return sprintf(buf, "UP (LAN OFFLINE)\n");
-	case CARD_STATE_UP_LAN_ONLINE:
+	case CARD_STATE_UP:
+		if (card->lan_online)
 		return sprintf(buf, "UP (LAN ONLINE)\n");
+		else
+			return sprintf(buf, "UP (LAN OFFLINE)\n");
 	case CARD_STATE_RECOVER:
 		return sprintf(buf, "RECOVER\n");
 	default:
@@ -293,7 +294,8 @@
 {
 	struct qeth_card *card = dev->driver_data;
 	char *tmp;
-	unsigned int cnt;
+	int cnt, old_cnt;
+	int rc;
 	
 	if (!card)
 		return -EINVAL;
@@ -302,12 +304,15 @@
 	    (card->state != CARD_STATE_RECOVER))
 		return -EPERM;
 	
-	cnt = simple_strtoul(buf, &tmp, 16);
+	old_cnt = card->qdio.in_buf_pool.buf_count;
+	cnt = simple_strtoul(buf, &tmp, 10);
 	cnt = (cnt < QETH_IN_BUF_COUNT_MIN) ? QETH_IN_BUF_COUNT_MIN :
 		((cnt > QETH_IN_BUF_COUNT_MAX) ? QETH_IN_BUF_COUNT_MAX : cnt);
-	card->qdio.in_buf_pool.buf_count = cnt;
-	/* TODO: steel/add buffers from/to a running card's buffer pool (?) */
-
+	if (old_cnt != cnt) {
+		if ((rc = qeth_realloc_buffer_pool(card, cnt)))
+				PRINT_WARN("Error (%d) while setting "
+					   "buffer count.\n", rc);
+	}
 	return count;
 }
 
@@ -373,8 +378,7 @@
 		return -EINVAL;
 	}		
 	if (((card->state == CARD_STATE_SOFTSETUP) ||
-	     (card->state == CARD_STATE_UP_LAN_OFFLINE) ||
-	     (card->state == CARD_STATE_UP_LAN_ONLINE)) &&
+	     (card->state == CARD_STATE_UP)) &&
 	    (old_route_type != route->type)){
 		if (prot == QETH_PROT_IPV4)
 			rc = qeth_setrouting_v4(card);
@@ -559,8 +563,7 @@
 	if (!card)
 		return -EINVAL;
 
-	if ((card->state != CARD_STATE_UP_LAN_ONLINE) &&
-	    (card->state != CARD_STATE_UP_LAN_OFFLINE))
+	if (card->state != CARD_STATE_UP)
 		return -EPERM;
 
 	i = simple_strtoul(buf, &tmp, 16);
@@ -572,7 +575,6 @@
 
 static DEVICE_ATTR(recover, 0200, NULL, qeth_dev_recover_store);
 
-/* TODO */
 static ssize_t
 qeth_dev_broadcast_mode_show(struct device *dev, char *buf)
 {
@@ -590,7 +592,6 @@
 		       "all rings":"local");
 }
 
-/* TODO */
 static ssize_t
 qeth_dev_broadcast_mode_store(struct device *dev, const char *buf, size_t count)
 {
@@ -629,7 +630,6 @@
 static DEVICE_ATTR(broadcast_mode, 0644, qeth_dev_broadcast_mode_show,
 		   qeth_dev_broadcast_mode_store);
 
-/* TODO */
 static ssize_t
 qeth_dev_canonical_macaddr_show(struct device *dev, char *buf)
 {
@@ -646,7 +646,6 @@
 				     QETH_TR_MACADDR_CANONICAL)? 1:0);
 }
 
-/* TODO */
 static ssize_t
 qeth_dev_canonical_macaddr_store(struct device *dev, const char *buf,
 				  size_t count)
