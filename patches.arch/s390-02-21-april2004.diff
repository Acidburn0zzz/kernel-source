- Description: qeth: memory leak when doing query ARP
  Symptom:     When doing query ARP (qetharp -nq) there is a memory leak of
               4K.
  Problem:     Memory buffer allocated for query data is not freed after
               query ARP command completes.
  Solution:    Do not allocate buffer at all. We already have io buffers of
               size 4K. OSA card can copy ARP data to these buffers.
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 11:27:02 -0000	1.77.2.12
+++ linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 11:53:24 -0000	1.77.2.13
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.12 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.13 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.12 $	 $Date: 2004/05/14 11:27:02 $
+ *    $Revision: 1.77.2.13 $	 $Date: 2004/05/14 11:53:24 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.12 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.13 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -1618,10 +1618,13 @@
 			spin_unlock_irqrestore(&card->lock, flags);
 			keep_reply = 0;
 			if (reply->callback != NULL) {
-				if (cmd)
+				if (cmd) {
+					reply->offset = (__u16)((char*)cmd -
+								(char *)iob->data);
 					keep_reply = reply->callback(card,
 							reply,
 							(unsigned long)cmd);
+				}
 				else
 					keep_reply = reply->callback(card,
 							reply,
@@ -1737,12 +1740,10 @@
 		  (struct qeth_card *,struct qeth_reply*, unsigned long),
 		  void *reply_param)
 {
-	struct qeth_ipa_cmd *cmd;
 	int rc;
 	
 	QETH_DBF_TEXT(trace,4,"sendipa");
 
-	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE); 
 	memcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);
 	memcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),
 	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
@@ -3867,7 +3868,7 @@
 qeth_arp_query_cb(struct qeth_card *card, struct qeth_reply *reply,
 		  unsigned long data)
 {
-	struct qeth_ipa_arp_cmd *cmd;
+	struct qeth_ipa_cmd *cmd;
 	struct qeth_arp_query_data *qdata;
 	struct qeth_arp_query_info *qinfo;
 	int entry_size;
@@ -3876,17 +3877,17 @@
 	QETH_DBF_TEXT(trace,4,"arpquecb");
 
 	qinfo = (struct qeth_arp_query_info *) reply->param;
-	cmd = (struct qeth_ipa_arp_cmd *) data;
-	if (cmd->ihdr.return_code) {
-		QETH_DBF_TEXT_(trace,4,"qaer1%i", cmd->ihdr.return_code);
+	cmd = (struct qeth_ipa_cmd *) data;
+	if (cmd->hdr.return_code) {
+		QETH_DBF_TEXT_(trace,4,"qaer1%i", cmd->hdr.return_code);
 		return 0;
 	}
-	if (cmd->shdr.return_code) {
-		cmd->ihdr.return_code = cmd->shdr.return_code;
-		QETH_DBF_TEXT_(trace,4,"qaer2%i", cmd->ihdr.return_code);
+	if (cmd->data.setassparms.hdr.return_code) {
+		cmd->hdr.return_code = cmd->data.setassparms.hdr.return_code;
+		QETH_DBF_TEXT_(trace,4,"qaer2%i", cmd->hdr.return_code);
 		return 0;
 	}
-	qdata = &cmd->data.query_arp;
+	qdata = &cmd->data.setassparms.data.query_arp;
 	switch(qdata->reply_bits){
 	case 5:
 		entry_size = sizeof(struct qeth_arp_qi_entry5);
@@ -3903,20 +3904,21 @@
 	if ((qinfo->udata_len - qinfo->udata_offset) <
 			qdata->no_entries * entry_size){
 		QETH_DBF_TEXT_(trace, 4, "qaer3%i", -ENOMEM);
-		cmd->ihdr.return_code = -ENOMEM;
+		cmd->hdr.return_code = -ENOMEM;
 		goto out_error;
 	}	
-	QETH_DBF_TEXT_(trace, 4, "anore%i", cmd->shdr.number_of_replies);
-	QETH_DBF_TEXT_(trace, 4, "aseqn%i", cmd->shdr.seq_no);
+	QETH_DBF_TEXT_(trace, 4, "anore%i",
+		       cmd->data.setassparms.hdr.number_of_replies);
+	QETH_DBF_TEXT_(trace, 4, "aseqn%i", cmd->data.setassparms.hdr.seq_no);
 	QETH_DBF_TEXT_(trace, 4, "anoen%i", qdata->no_entries);
-	for (i = 0; i < qdata->no_entries; ++i){
+	/*copy entries to user buffer*/
 		memcpy(qinfo->udata + qinfo->udata_offset,
-		       qdata->data + i*entry_size, entry_size);
-		qinfo->no_entries++;
-		qinfo->udata_offset += entry_size;
-	}
+	       (char *)&qdata->data, qdata->no_entries*entry_size);
+	qinfo->no_entries += qdata->no_entries;
+	qinfo->udata_offset += (qdata->no_entries*entry_size);
 	/* check if all replies received ... */
-	if (cmd->shdr.seq_no < cmd->shdr.number_of_replies)
+	if (cmd->data.setassparms.hdr.seq_no <
+	    cmd->data.setassparms.hdr.number_of_replies)
 		return 1;
 	memcpy(qinfo->udata, &qinfo->no_entries, 4);
 	memcpy(qinfo->udata + QETH_QARP_MASK_OFFSET,&qdata->reply_bits,2);
@@ -3927,70 +3929,32 @@
 	return 0;
 }
 
-static struct qeth_cmd_buffer *
-qeth_get_ipacmd_buffer(struct qeth_card *, enum qeth_ipa_cmds,
-		       enum qeth_prot_versions);
-
-struct qeth_cmd_buffer *
-qeth_get_ipa_arp_cmd_buffer(struct qeth_card *card, u16 cmd_code,
-			    u32 data_len, enum qeth_prot_versions proto)
-{
-	struct qeth_cmd_buffer *iob;
-	struct qeth_ipa_arp_cmd *cmd;
-	u16 s1, s2;
-
-	QETH_DBF_TEXT(trace,4,"getarpcm");
-	iob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETASSPARMS, proto);
-
-	memcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);
-	
-	if ((IPA_PDU_HEADER_SIZE + QETH_ARP_CMD_BASE_LEN + data_len) > 256) {
-		/* adjust sizes in IPA_PDU_HEADER */
-		s1 = (u32) IPA_PDU_HEADER_SIZE + QETH_ARP_CMD_BASE_LEN +
-			   data_len;
-		s2 = (u32) QETH_ARP_CMD_BASE_LEN + data_len;
-		memcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);
-		memcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);
-		memcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);
-		memcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);
-	}
-
-	cmd = (struct qeth_ipa_arp_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
-	cmd->shdr.assist_no = IPA_ARP_PROCESSING;
-	cmd->shdr.length = 8 + data_len;
-	cmd->shdr.command_code = cmd_code;
-	cmd->shdr.return_code = 0;
-	cmd->shdr.seq_no = 0;
-
-	return iob;
-}
-
 static int
 qeth_send_ipa_arp_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,
-		      char *data, int data_len,
-		      int (*reply_cb)
-		      (struct qeth_card *,struct qeth_reply*, unsigned long),
+		      int len, int (*reply_cb)
+			      		(struct qeth_card *,
+					 struct qeth_reply*, unsigned long),
 		      void *reply_param)
 {
 	int rc;
 	
 	QETH_DBF_TEXT(trace,4,"sendarp");
 
-	memcpy(QETH_IPA_ARP_DATA_POS(iob->data), data, data_len);
+	memcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);
 	memcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),
 	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
-
-	rc = qeth_send_control_data(card, IPA_PDU_HEADER_SIZE +
-				    QETH_ARP_CMD_BASE_LEN + data_len, iob,
+	rc = qeth_send_control_data(card, IPA_PDU_HEADER_SIZE + len, iob,
 				    reply_cb, reply_param);
 	return rc;
 }
 
+static struct qeth_cmd_buffer *
+qeth_get_setassparms_cmd(struct qeth_card *, enum qeth_ipa_funcs,
+			 __u16, __u16, enum qeth_prot_versions);
 static int
 qeth_arp_query(struct qeth_card *card, char *udata)
 {
 	struct qeth_cmd_buffer *iob;
-	struct qeth_arp_query_data *qdata;
 	struct qeth_arp_query_info qinfo = {0, };
 	int tmp;
 	int rc;
@@ -4005,40 +3969,33 @@
 	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
-	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
+	if (!qeth_is_supported(card,/*IPA_QUERY_ARP_ADDR_INFO*/
+			       IPA_ARP_PROCESSING)) {
 		PRINT_WARN("ARP processing not supported "
 			   "on %s!\n", card->info.if_name);
 		return -EOPNOTSUPP;
 	}
-	/* get size of userspace mem area */
+
 	if (copy_from_user(&qinfo.udata_len, udata, 4))
 		return -EFAULT;
 	if (!(qinfo.udata = kmalloc(qinfo.udata_len, GFP_KERNEL)))
 		return -ENOMEM;
 	memset(qinfo.udata, 0, qinfo.udata_len);
 	qinfo.udata_offset = QETH_QARP_ENTRIES_OFFSET;
-	/* alloc mem area for the actual query */
-	if (!(qdata = kmalloc(sizeof(struct qeth_arp_query_data),
-			      GFP_KERNEL))){
-		kfree(qinfo.udata);
-		return -ENOMEM;
-	}
-	memset(qdata, 0, sizeof(struct qeth_arp_query_data));
-	/* do not give sizeof(struct qeth_arp_query_data) to next command;
-	 * this would cause the IPA PDU size to be set to a value of > 256
-	 * and this is to much for HiperSockets */
-	iob = qeth_get_ipa_arp_cmd_buffer(card, IPA_CMD_ASS_ARP_QUERY_INFO,
-					  0, QETH_PROT_IPV4);
+	iob = qeth_get_setassparms_cmd(card, IPA_ARP_PROCESSING,
+				       IPA_CMD_ASS_ARP_QUERY_INFO,
+				       sizeof(int),QETH_PROT_IPV4);
+
 	rc = qeth_send_ipa_arp_cmd(card, iob,
-				   (char *) qdata,
-				   sizeof(struct qeth_arp_query_data),
+				   QETH_SETASS_BASE_LEN+QETH_ARP_CMD_LEN,
 				   qeth_arp_query_cb,
 				   (void *)&qinfo);
 	if (rc) {
 		tmp = rc;
-		PRINT_WARN("Error while querying ARP cache on %s: %s (0x%x)\n",
+		PRINT_WARN("Error while querying ARP cache on %s: %s "
+			   "(0x%x/%d)\n",
 			   card->info.if_name, qeth_arp_get_error_cause(&rc),
-			   tmp);
+			   tmp, tmp);
 		copy_to_user(udata, qinfo.udata, 4);
 	} else {
 		copy_to_user(udata, qinfo.udata, qinfo.udata_len);
@@ -4047,14 +4004,31 @@
 	return rc;
 }
 
+static struct qeth_cmd_buffer *
+qeth_get_ipacmd_buffer(struct qeth_card *, enum qeth_ipa_cmds,
+		       enum qeth_prot_versions );
+
+static struct qeth_cmd_buffer *
+qeth_get_adapter_cmd(struct qeth_card *card, __u32 command, __u32 cmdlen)
+{
+	struct qeth_cmd_buffer *iob;
+	struct qeth_ipa_cmd *cmd;
+
+	iob = qeth_get_ipacmd_buffer(card,IPA_CMD_SETADAPTERPARMS,
+				     QETH_PROT_IPV4);
+	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
+	cmd->data.setadapterparms.hdr.cmdlength = cmdlen;
+	cmd->data.setadapterparms.hdr.command_code = command;
+	cmd->data.setadapterparms.hdr.used_total = 1;
+	cmd->data.setadapterparms.hdr.seq_no = 1;
+
+	return iob;
+}
+
 static int
 qeth_default_setassparms_cb(struct qeth_card *, struct qeth_reply *,
 			    unsigned long);
 
-static struct qeth_cmd_buffer * 
-qeth_get_setassparms_cmd(struct qeth_card *, enum qeth_ipa_funcs,
-			 __u16, __u16, enum qeth_prot_versions);
-
 static int
 qeth_send_setassparms(struct qeth_card *, struct qeth_cmd_buffer *,
 		      __u16, long,
@@ -5002,24 +4976,6 @@
 	return rc;
 }
 
-static struct qeth_cmd_buffer *
-qeth_get_adapter_cmd(struct qeth_card *card, __u32 command)
-{
-	struct qeth_cmd_buffer *iob;
-	struct qeth_ipa_cmd *cmd;
-	
-	iob = qeth_get_ipacmd_buffer(card,IPA_CMD_SETADAPTERPARMS,
-				     QETH_PROT_IPV4);
-	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE); 
-	cmd->data.setadapterparms.cmdlength = 
-				sizeof(struct qeth_ipacmd_setadpparms);
-	cmd->data.setadapterparms.command_code = command;
-	cmd->data.setadapterparms.frames_used_total = 1;
-	cmd->data.setadapterparms.frame_seq_no = 1;
-	
-	return iob;
-}
-
 static int
 qeth_default_setassparms_cb(struct qeth_card *card, struct qeth_reply *reply,
 			    unsigned long data)
@@ -5057,7 +5013,7 @@
 
 	cmd = (struct qeth_ipa_cmd *) data;
 	if (cmd->hdr.return_code == 0)
-		cmd->hdr.return_code = cmd->data.setadapterparms.return_code;
+		cmd->hdr.return_code = cmd->data.setadapterparms.hdr.return_code;
 	return 0;
 }
 
@@ -5085,7 +5041,8 @@
 	struct qeth_cmd_buffer *iob;
 	
 	QETH_DBF_TEXT(trace,3,"queryadp");
-	iob = qeth_get_adapter_cmd(card,IPA_SETADP_QUERY_COMMANDS_SUPPORTED);
+	iob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_COMMANDS_SUPPORTED,
+				   sizeof(struct qeth_ipacmd_setadpparms));
 	rc = qeth_send_ipa_cmd(card, iob, qeth_query_setadapterparms_cb, NULL);
 	return rc;
 }
@@ -5115,7 +5072,8 @@
 	
 	QETH_DBF_TEXT(trace,4,"chgmac");
 	
-	iob = qeth_get_adapter_cmd(card,IPA_SETADP_ALTER_MAC_ADDRESS);
+	iob = qeth_get_adapter_cmd(card,IPA_SETADP_ALTER_MAC_ADDRESS,
+				   sizeof(struct qeth_ipacmd_setadpparms));
 	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE); 
 	cmd->data.setadapterparms.data.change_addr.cmd = CHANGE_ADDR_READ_MAC;
 	cmd->data.setadapterparms.data.change_addr.addr_size = OSA_ADDR_LEN;
@@ -5135,7 +5093,8 @@
 	
 	QETH_DBF_TEXT(trace,4,"adpmode");
 	
-	iob = qeth_get_adapter_cmd(card, command);
+	iob = qeth_get_adapter_cmd(card, command,
+				   sizeof(struct qeth_ipacmd_setadpparms));
 	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE); 
 	cmd->data.setadapterparms.data.mode = mode;
 	rc = qeth_send_ipa_cmd(card, iob, qeth_default_setadapterparms_cb,

--- linux-2.5/drivers/s390/net/qeth_mpc.h	14 May 2004 08:16:06 -0000	1.27.2.2
+++ linux-2.5/drivers/s390/net/qeth_mpc.h	14 May 2004 11:53:24 -0000	1.27.2.3
@@ -14,7 +14,7 @@
 
 #include <asm/qeth.h>
 
-#define VERSION_QETH_MPC_H "$Revision: 1.27.2.2 $"
+#define VERSION_QETH_MPC_H "$Revision: 1.27.2.3 $"
 
 extern const char *VERSION_QETH_MPC_C;
 
@@ -248,12 +248,28 @@
 	__u8 seq_no;
 } __attribute__((packed));
 
+struct qeth_arp_query_data {
+	__u16 request_bits;
+	__u16 reply_bits;
+	__u32 no_entries;
+	char data;
+} __attribute__((packed));
+
+/* used as parameter for arp_query reply */
+struct qeth_arp_query_info {
+	__u32 udata_len;
+	__u32 udata_offset;
+	__u32 no_entries;
+	char *udata;
+};
+
 /* SETASSPARMS IPA Command: */
 struct qeth_ipacmd_setassparms {
 	struct qeth_ipacmd_setassparms_hdr hdr;
 	union {
 		__u32 flags_32bit;
 		struct qeth_arp_cache_entry add_arp_entry; 
+		struct qeth_arp_query_data query_arp;
 		__u8 ip[16];
 	} data;
 } __attribute__ ((packed));
@@ -280,16 +296,20 @@
 	__u8 addr[OSA_ADDR_LEN];
 } __attribute__ ((packed));
 
-struct qeth_ipacmd_setadpparms {
+struct qeth_ipacmd_setadpparms_hdr {
 	__u32 supp_hw_cmds;
 	__u32 reserved1;
 	__u16 cmdlength;
 	__u16 reserved2;
 	__u32 command_code;
 	__u16 return_code;
-	__u8 frames_used_total;
-	__u8 frame_seq_no;
+	__u8  used_total;
+	__u8  seq_no;
 	__u32 reserved3;
+} __attribute__ ((packed));
+
+struct qeth_ipacmd_setadpparms {
+	struct qeth_ipacmd_setadpparms_hdr hdr;
 	union {
 		struct qeth_query_cmds_supp query_cmds_supp;
 		struct qeth_change_addr change_addr;
@@ -360,36 +380,15 @@
 	QETH_IPA_ARP_RC_Q_NO_DATA    = 0x0008,
 };
 
-#define QETH_QARP_DATA_SIZE 3968
-struct qeth_arp_query_data {
-	__u16 request_bits;
-	__u16 reply_bits;
-	__u32 no_entries;
-	char data[QETH_QARP_DATA_SIZE];
-} __attribute__((packed));
-
-/* used as parameter for arp_query reply */
-struct qeth_arp_query_info {
-	__u32 udata_len;
-	__u32 udata_offset;
-	__u32 no_entries;
-	char *udata;
-};
-
-#define IPA_ARP_CMD_LEN (IPA_PDU_HEADER_SIZE+sizeof(struct qeth_ipa_arp_cmd))
-#define QETH_ARP_CMD_BASE_LEN (sizeof(struct qeth_ipacmd_hdr) + \
+#define QETH_SETASS_BASE_LEN (sizeof(struct qeth_ipacmd_hdr) + \
 			       sizeof(struct qeth_ipacmd_setassparms_hdr))
 #define QETH_IPA_ARP_DATA_POS(buffer) (buffer + IPA_PDU_HEADER_SIZE + \
-				       QETH_ARP_CMD_BASE_LEN)
-struct qeth_ipa_arp_cmd {
-	struct qeth_ipacmd_hdr ihdr;
-	struct qeth_ipacmd_setassparms_hdr shdr;
-	union {
-		struct qeth_arp_query_data query_arp;	
-	} data;
-} __attribute__((packed));
-
+				       QETH_SETASS_BASE_LEN)
+#define QETH_SETADP_BASE_LEN (sizeof(struct qeth_ipacmd_hdr) + \
+			      sizeof(struct qeth_ipacmd_setadpparms_hdr))
 
+#define QETH_ARP_DATA_SIZE 3968
+#define QETH_ARP_CMD_LEN (QETH_ARP_DATA_SIZE + 8)
 /* Helper functions */
 #define IS_IPA_REPLY(cmd) (cmd->hdr.initiator == IPA_CMD_INITIATOR_HOST)
 

--- linux-2.5/drivers/s390/net/qeth.h	14 May 2004 10:32:08 -0000	1.98.2.6
+++ linux-2.5/drivers/s390/net/qeth.h	14 May 2004 11:53:24 -0000	1.98.2.7
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.98.2.6 $"
+#define VERSION_QETH_H 		"$Revision: 1.98.2.7 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -608,6 +608,7 @@
 	wait_queue_head_t wait_q;
 	int (*callback)(struct qeth_card *,struct qeth_reply *,unsigned long);
  	int seqno;	
+	unsigned long offset;
 	int received;
 	int rc;
 	void *param;

