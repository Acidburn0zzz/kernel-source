Subject: crash in  init_ipic_sysfs
From: olh@suse.de


possible fix for the crash below.


ok boot eth:192.168.2.52,inst32 inst32 console=ttyPSC0,115200

SuSE Linux zImage starting: loaded at 00040000-00d24cbc (0/0/01003ed8;
sp: 017ffe80)
uncompressing ELF header done. (00000100 bytes)
Allocated 008584d4 bytes for kernel @ 02000000
Allocated 00a963a2 bytes for initrd @ 02859000
uncompressing kernel done. (004faeb8 bytes)
entering kernel at 02010000(2859000/a963a2/01003ed8)
OF stdout device is: /failsafe
command line: console=ttyPSC0,115200
memory layout at init:
  alloc_bottom : 032f0000
  alloc_top    : 30000000
  alloc_top_hi : f000c000
  rmo_top      : 30000000
  ram_top      : f000c000
Looking for displays
instantiating rtas at 0x07ffb000 ... done
Applying EFIKA device tree fixups
Fixing bestcomm interrupts property
Adding Ethernet MDIO node
Adding Ethernet PHY node
copying OF device tree ...
Building dt strings...
Building dt structure...
Device tree strings 0x032f1000 -> 0x032f17e0
Device tree struct  0x032f2000 -> 0x03315000
Calling quiesce ...
returning from prom_init
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Memory: 113264k/131072k available (4808k kernel code, 17648k reserved,
164k data, 461k bss, 228k init)
Security Framework initialized
AppArmor: AppArmor initialized
AppArmor: Unable to log event (1505) to audit subsys
AppArmor: Registered secondary security module name="capability"
AppArmor: Unable to log event (1505) to audit subsys
Capability LSM initialized as secondary
Failure registering Root Plug module with the kernel
AppArmor: Unable to register %s as a secondary security module
name="root_plug"
AppArmor: Unable to log event (1505) to audit subsys
Failure registering Root Plug  module with primary security module.
Mount-cache hash table entries: 512
net_namespace: 544 bytes
NET: Registered protocol family 16
PCI: Probing PCI hardware
DMA: MPC52xx BestComm driver
DMA: MPC52xx BestComm engine @f0001200 ok !
Unable to handle kernel paging request for data at address 0x00000000
Faulting instruction address: 0xc0486aac
Oops: Kernel access of bad area, sig: 11 [#1]
Efika
Modules linked in:
NIP: c0486aac LR: c0479200 CTR: c0486a90
REGS: c782bea0 TRAP: 0300   Not tainted  (2.6.25-rc5-git2-5-default)
MSR: 00009032 <EE,ME,IR,DR>  CR: 44002082  XER: 20000000
DAR: 00000000, DSISR: 20000000
TASK = c78237c0[1] 'swapper' THREAD: c782a000
GPR00: c0479200 c782bf50 c78237c0 ffffffed 00000003 00000000 00000000
00000000
GPR08: fffffffc 00000000 c7800780 000f06a0 22002022 dffffff7 c0405540
c0405558
GPR16: c0405568 c040558c c0405594 c04055a4 c04055d0 c0400000 024184a4
ffffffff
GPR24: 00000000 c04a6468 c0405550 c782a000 c04e0000 00000000 00000000
c04af198
NIP [c0486aac] init_ipic_sysfs+0x1c/0x90
LR [c0479200] kernel_init+0xf8/0x2a0
Call Trace:
[c782bf50] [c04869fc] mpc52xx_bcom_init+0x24/0x34 (unreliable)
[c782bf60] [c0479200] kernel_init+0xf8/0x2a0
[c782bff0] [c001330c] kernel_thread+0x44/0x60
Instruction dump:
80010024 bb61000c 38210020 7c0803a6 4e800020 9421fff0 7c0802a6 3d20c04f
3860ffed 90010014 93e1000c 81299730 <80090000> 2f800000 41be0058 3c60c041
 ---[ end trace 8640abe69a316dee ]---
Kernel panic - not syncing: Attempted to kill init!
Rebooting in 180 seconds..

---
 arch/powerpc/sysdev/ipic.c |   15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

--- a/arch/powerpc/sysdev/ipic.c
+++ b/arch/powerpc/sysdev/ipic.c
@@ -10,6 +10,8 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
+#define olh(fmt,args ...) \
+		printk(KERN_DEBUG "%s(%u) %s(%u):c%u,j%lu " fmt "\n",__FUNCTION__,__LINE__,current->comm,current->pid,smp_processor_id(),jiffies,##args)
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/errno.h>
@@ -725,9 +727,10 @@ struct ipic * __init ipic_init(struct de
 	struct resource res;
 	u32 temp = 0, ret;
 
+	olh("");
 	ipic = alloc_bootmem(sizeof(struct ipic));
 	if (ipic == NULL)
-		return NULL;
+		goto out;
 
 	memset(ipic, 0, sizeof(struct ipic));
 
@@ -736,13 +739,13 @@ struct ipic * __init ipic_init(struct de
 				       &ipic_host_ops, 0);
 	if (ipic->irqhost == NULL) {
 		of_node_put(node);
-		return NULL;
+		goto out;
 	}
 
 	ret = of_address_to_resource(node, 0, &res);
 	if (ret) {
 		of_node_put(node);
-		return NULL;
+		goto out;
 	}
 
 	ipic->regs = ioremap(res.start, res.end - res.start + 1);
@@ -792,6 +795,9 @@ struct ipic * __init ipic_init(struct de
 			primary_ipic->regs);
 
 	return ipic;
+out:
+	olh("primary_ipic %p", primary_ipic);
+	return NULL;
 }
 
 int ipic_set_priority(unsigned int virq, unsigned int priority)
@@ -906,7 +912,8 @@ static int __init init_ipic_sysfs(void)
 {
 	int rc;
 
-	if (!primary_ipic->regs)
+	olh("primary_ipic %p", primary_ipic);
+	if (!primary_ipic || !primary_ipic->regs)
 		return -ENODEV;
 	printk(KERN_DEBUG "Registering ipic with sysfs...\n");
 
