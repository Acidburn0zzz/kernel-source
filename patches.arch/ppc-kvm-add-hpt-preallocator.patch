From: Alexander Graf <agraf@suse.de>
Date: Mon, 16 Jan 2012 19:12:11 +0100
Subject: [PATCH] KVM: PPC: Add HPT preallocator
Patch-mainline: v3.4-rc1
Git-commit: d2a1b483a4a3f4bbb5fec1877f716c15ac7fa405

We're currently allocating 16MB of linear memory on demand when creating
a guest. That does work some times, but finding 16MB of linear memory
available in the system at runtime is definitely not a given.

So let's add another command line option similar to the RMA preallocator,
that we can use to keep a pool of page tables around. Now, when a guest
gets created it has a pretty low chance of receiving an OOM.

Signed-off-by: Alexander Graf <agraf@suse.de>
---
 arch/powerpc/include/asm/kvm_host.h  |    1 +
 arch/powerpc/include/asm/kvm_ppc.h   |    2 +
 arch/powerpc/kvm/book3s_64_mmu_hv.c  |   20 ++++++++++++++++-
 arch/powerpc/kvm/book3s_hv_builtin.c |   39 +++++++++++++++++++++++++++++++++-
 4 files changed, 60 insertions(+), 2 deletions(-)

Index: linux-3.2-master/arch/powerpc/include/asm/kvm_host.h
===================================================================
--- linux-3.2-master.orig/arch/powerpc/include/asm/kvm_host.h
+++ linux-3.2-master/arch/powerpc/include/asm/kvm_host.h
@@ -187,6 +187,7 @@ struct kvm_arch {
 	struct list_head spapr_tce_tables;
 	unsigned short last_vcpu[NR_CPUS];
 	struct kvmppc_vcore *vcores[KVM_MAX_VCORES];
+	struct kvmppc_linear_info *hpt_li;
 #endif /* CONFIG_KVM_BOOK3S_64_HV */
 };
 
Index: linux-3.2-master/arch/powerpc/include/asm/kvm_ppc.h
===================================================================
--- linux-3.2-master.orig/arch/powerpc/include/asm/kvm_ppc.h
+++ linux-3.2-master/arch/powerpc/include/asm/kvm_ppc.h
@@ -129,6 +129,8 @@ extern long kvm_vm_ioctl_allocate_rma(st
 				struct kvm_allocate_rma *rma);
 extern struct kvmppc_linear_info *kvm_alloc_rma(void);
 extern void kvm_release_rma(struct kvmppc_linear_info *ri);
+extern struct kvmppc_linear_info *kvm_alloc_hpt(void);
+extern void kvm_release_hpt(struct kvmppc_linear_info *li);
 extern int kvmppc_core_init_vm(struct kvm *kvm);
 extern void kvmppc_core_destroy_vm(struct kvm *kvm);
 extern int kvmppc_core_prepare_memory_region(struct kvm *kvm,
Index: linux-3.2-master/arch/powerpc/kvm/book3s_64_mmu_hv.c
===================================================================
--- linux-3.2-master.orig/arch/powerpc/kvm/book3s_64_mmu_hv.c
+++ linux-3.2-master/arch/powerpc/kvm/book3s_64_mmu_hv.c
@@ -51,9 +51,21 @@ long kvmppc_alloc_hpt(struct kvm *kvm)
 {
 	unsigned long hpt;
 	unsigned long lpid;
+	struct kvmppc_linear_info *li;
 
+	/* using preallocated memory */
+	li = kvm_alloc_hpt();
+	if (li) {
+		hpt = (ulong)li->base_virt;
+		kvm->arch.hpt_li = li;
+		memset(li->base_virt, 0, li->npages << PAGE_SHIFT);
+		goto has_hpt;
+	}
+
+	/* using dynamic memory */
 	hpt = __get_free_pages(GFP_KERNEL|__GFP_ZERO|__GFP_REPEAT|__GFP_NOWARN,
 			       HPT_ORDER - PAGE_SHIFT);
+has_hpt:
 	if (!hpt) {
 		pr_err("kvm_alloc_hpt: Couldn't alloc HPT\n");
 		return -ENOMEM;
@@ -80,6 +92,10 @@ void kvmppc_free_hpt(struct kvm *kvm)
 {
 	clear_bit(kvm->arch.lpid, lpid_inuse);
 	free_pages(kvm->arch.hpt_virt, HPT_ORDER - PAGE_SHIFT);
+	if (kvm->arch.hpt_li)
+		kvm_release_hpt(kvm->arch.hpt_li);
+	else
+		free_pages(kvm->arch.hpt_virt, HPT_ORDER - PAGE_SHIFT);
 }
 
 void kvmppc_map_vrma(struct kvm *kvm, struct kvm_userspace_memory_region *mem)
Index: linux-3.2-master/arch/powerpc/kvm/book3s_hv_builtin.c
===================================================================
--- linux-3.2-master.orig/arch/powerpc/kvm/book3s_hv_builtin.c
+++ linux-3.2-master/arch/powerpc/kvm/book3s_hv_builtin.c
@@ -19,6 +19,8 @@
 #include <asm/kvm_book3s.h>
 
 #define KVM_LINEAR_RMA		0
+#define KVM_LINEAR_HPT		1
+#define HPT_ORDER	24
 
 static void __init kvm_linear_init_one(ulong size, int count, int type);
 static struct kvmppc_linear_info *kvm_alloc_linear(int type);
@@ -97,6 +99,39 @@ void kvm_release_rma(struct kvmppc_linea
 }
 EXPORT_SYMBOL_GPL(kvm_release_rma);
 
+/*************** HPT *************/
+
+/*
+ * This maintains a list of big linear HPT tables that contain the GVA->HPA
+ * memory mappings. If we don't reserve those early on, we might not be able
+ * to get a big (usually 16MB) linear memory region from the kernel anymore.
+ */
+
+static unsigned long kvm_hpt_count;
+
+static int __init early_parse_hpt_count(char *p)
+{
+	if (!p)
+		return 1;
+
+	kvm_hpt_count = simple_strtoul(p, NULL, 0);
+
+	return 0;
+}
+early_param("kvm_hpt_count", early_parse_hpt_count);
+
+struct kvmppc_linear_info *kvm_alloc_hpt(void)
+{
+	return kvm_alloc_linear(KVM_LINEAR_HPT);
+}
+EXPORT_SYMBOL_GPL(kvm_alloc_hpt);
+
+void kvm_release_hpt(struct kvmppc_linear_info *li)
+{
+	kvm_release_linear(li);
+}
+EXPORT_SYMBOL_GPL(kvm_release_hpt);
+
 /*************** generic *************/
 
 static LIST_HEAD(free_linears);
@@ -114,7 +149,7 @@ static void __init kvm_linear_init_one(u
 	if (!count)
 		return;
 
-	typestr = (type == KVM_LINEAR_RMA) ? "RMA" : "";
+	typestr = (type == KVM_LINEAR_RMA) ? "RMA" : "HPT";
 
 	npages = size >> PAGE_SHIFT;
 	linear_info = alloc_bootmem(count * sizeof(struct kvmppc_linear_info));
@@ -172,6 +207,9 @@ static void kvm_release_linear(struct kv
  */
 void __init kvm_linear_init(void)
 {
+	/* HPT */
+	kvm_linear_init_one(1 << HPT_ORDER, kvm_hpt_count, KVM_LINEAR_HPT);
+
 	/* RMA */
 	/* Only do this on PPC970 in HV mode */
 	if (!cpu_has_feature(CPU_FTR_HVMODE) ||
