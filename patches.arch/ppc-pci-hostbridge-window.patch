Subject: [PATCH] Cope with PCI host bridge I/O window not starting at 0
From: Paul Mackerras <paulus@samba.org>
References: 271689 - LTC34416

Currently our code to set up the data structures for a PCI host bridge
and create the mapping for its I/O window assumes that the window
starts at I/O port 0 on the PCI side.  If this is not true, we can end
up with I/O port numbers in the resources for PCI devices which will
cause an oops if a driver tries to access them via inb/outb etc.,
because there is no mapping for the corresponding addresses.

Normally the I/O window starts at 0, but there are some situations on
partitioned machines with a hypervisor where the window may not start
at 0.

This fixes the problem by allocating space for the range from 0 to the
end of the I/O window.  That is, hose->io_base_virt contains the
virtual address for I/O port 0 on the PCI bus, and thus the assumption
that hose->io_base_virt - pci_io_base is the offset between the
"global" I/O port numbers (those in the PCI device resources) and the
I/O port numbers on the PCI bus is maintained.

For PCI host bridges that are present at boot, we only map the portion
of that range that correspond to the bridge's I/O window.  For bridges
added after boot we ioremap the range from 0 to the end of the I/O
window, for now; in fact hot-added bridges should be using
reserve_phb_iospace() and __ioremap_explicit (so they get sensible
global port numbers), but we don't have the infrastructure yet to do
that (basically a free_phb_iospace() routine plus appropriate
locking).

Interestingly, this makes the two arms of the if statement in
get_bus_io_range do almost exactly the same thing; that function could
now be simplified in a further patch.

Signed-off-by: Paul Mackerras <paulus@samba.org>
Signed-off-by: Olaf Hering <olh@suse.de>
---

---
 arch/powerpc/kernel/pci_64.c |   42 ++++++++++++++++--------------------------
 1 file changed, 16 insertions(+), 26 deletions(-)

--- a/arch/powerpc/kernel/pci_64.c
+++ b/arch/powerpc/kernel/pci_64.c
@@ -996,8 +996,9 @@ void __devinit pci_process_bridge_OF_ran
 
 		switch ((pci_space >> 24) & 0x3) {
 		case 1:		/* I/O space */
-			hose->io_base_phys = cpu_phys_addr;
-			hose->pci_io_size = size;
+			hose->io_base_phys = cpu_phys_addr - pci_addr;
+			/* handle from 0 to top of I/O window */
+			hose->pci_io_size = pci_addr + size;
 
 			res = &hose->io_resource;
 			res->flags = IORESOURCE_IO;
@@ -1087,35 +1088,24 @@ static int get_bus_io_range(struct pci_b
 				unsigned long *start_virt, unsigned long *size)
 {
 	struct pci_controller *hose = pci_bus_to_host(bus);
-	struct pci_bus_region region;
 	struct resource *res;
 
-	if (bus->self) {
+	if (bus->self)
 		res = bus->resource[0];
-		pcibios_resource_to_bus(bus->self, &region, res);
-		*start_phys = hose->io_base_phys + region.start;
-		*start_virt = (unsigned long) hose->io_base_virt + 
-				region.start;
-		if (region.end > region.start) 
-			*size = region.end - region.start + 1;
-		else {
-			printk("%s(): unexpected region 0x%lx->0x%lx\n", 
-					__FUNCTION__, region.start, region.end);
-			return 1;
-		}
-		
-	} else {
+	else
 		/* Root Bus */
 		res = &hose->io_resource;
-		*start_phys = hose->io_base_phys;
-		*start_virt = (unsigned long) hose->io_base_virt;
-		if (res->end > res->start)
-			*size = res->end - res->start + 1;
-		else {
-			printk("%s(): unexpected region 0x%lx->0x%lx\n", 
-					__FUNCTION__, res->start, res->end);
-			return 1;
-		}
+
+	*start_virt = pci_io_base + res->start;
+	*start_phys = *start_virt + hose->io_base_phys
+		- (unsigned long) hose->io_base_virt;
+
+	if (res->end > res->start)
+		*size = res->end - res->start + 1;
+	else {
+		printk("%s(): unexpected region 0x%lx->0x%lx\n",
+		       __FUNCTION__, res->start, res->end);
+		return 1;
 	}
 
 	return 0;
