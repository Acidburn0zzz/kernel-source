The crypto device driver for PCICA & PCICC cards.

diffstat:
 arch/s390/defconfig               |    5 
 drivers/s390/Kconfig              |   13 
 drivers/s390/Makefile             |    3 
 drivers/s390/crypto/Makefile      |    6 
 drivers/s390/crypto/z90common.h   |  110 +
 drivers/s390/crypto/z90crypt.h    |  231 ++
 drivers/s390/crypto/z90hardware.c | 2162 ++++++++++++++++++++++++++
 drivers/s390/crypto/z90main.c     | 3125 ++++++++++++++++++++++++++++++++++++++
 8 files changed, 5654 insertions(+), 1 deletion(-)

diff -urN linux-2.6/arch/s390/defconfig linux-2.6-s390/arch/s390/defconfig
--- linux-2.6/arch/s390/defconfig	Mon Mar  1 16:35:58 2004
+++ linux-2.6-s390/arch/s390/defconfig	Mon Mar  1 16:36:00 2004
@@ -189,6 +189,11 @@
 CONFIG_S390_TAPE_34XX=m
 
 #
+# Cryptographic devices
+#
+CONFIG_Z90CRYPT=m
+
+#
 # Networking support
 #
 CONFIG_NET=y
diff -urN linux-2.6/drivers/s390/Kconfig linux-2.6-s390/drivers/s390/Kconfig
--- linux-2.6/drivers/s390/Kconfig	Mon Mar  1 16:35:31 2004
+++ linux-2.6-s390/drivers/s390/Kconfig	Mon Mar  1 16:36:00 2004
@@ -164,3 +164,16 @@
 	  It is safe to say "Y" here.
 
 endmenu
+
+menu "Cryptographic devices"
+
+config Z90CRYPT
+	tristate "Support for PCI-attached cryptographic adapters"
+        default "m"
+        help
+	  Select this option if you want to use a PCI-attached cryptographic
+	  adapter like the PCI Cryptographic Accelerator (PCICA) or the PCI 
+	  Cryptographic Coprocessor (PCICC).  This option is also available
+	  as a module called z90crypt.ko.
+
+endmenu
diff -urN linux-2.6/drivers/s390/Makefile linux-2.6-s390/drivers/s390/Makefile
--- linux-2.6/drivers/s390/Makefile	Wed Feb 18 04:57:57 2004
+++ linux-2.6-s390/drivers/s390/Makefile	Mon Mar  1 16:36:00 2004
@@ -3,6 +3,7 @@
 #
 
 obj-y += s390mach.o sysinfo.o
-obj-y += cio/ block/ char/ net/ scsi/
+obj-y += cio/ block/ char/ crypto/ net/ scsi/
 
 drivers-y += drivers/s390/built-in.o
+
diff -urN linux-2.6/drivers/s390/crypto/Makefile linux-2.6-s390/drivers/s390/crypto/Makefile
--- linux-2.6/drivers/s390/crypto/Makefile	Thu Jan  1 01:00:00 1970
+++ linux-2.6-s390/drivers/s390/crypto/Makefile	Mon Mar  1 16:36:00 2004
@@ -0,0 +1,6 @@
+#
+# S/390 miscellaneous devices
+#
+
+z90crypt-objs := z90main.o z90hardware.o
+obj-$(CONFIG_Z90CRYPT) += z90crypt.o
diff -urN linux-2.6/drivers/s390/crypto/z90common.h linux-2.6-s390/drivers/s390/crypto/z90common.h
--- linux-2.6/drivers/s390/crypto/z90common.h	Thu Jan  1 01:00:00 1970
+++ linux-2.6-s390/drivers/s390/crypto/z90common.h	Mon Mar  1 16:36:00 2004
@@ -0,0 +1,110 @@
+/*
+ *  linux/drivers/s390/misc/z90common.h
+ *
+ *  z90crypt 1.3.1
+ *
+ *  Copyright (C)  2001, 2004 IBM Corporation
+ *  Author(s): Robert Burroughs (burrough@us.ibm.com)
+ *	       Eric Rossman (edrossma@us.ibm.com)
+ *
+ *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _Z90COMMON_
+#define _Z90COMMON_
+#define VERSION_Z90COMMON_H "$Revision: 1.6 $"
+#define RESPBUFFSIZE 256
+#define PCI_FUNC_KEY_DECRYPT 0x5044
+#define PCI_FUNC_KEY_ENCRYPT 0x504B
+enum devstat {
+	DEV_GONE,		
+	DEV_ONLINE,		
+	DEV_QUEUE_FULL,		
+	DEV_EMPTY,		
+	DEV_NO_WORK,		
+	DEV_BAD_MESSAGE,	
+	DEV_TSQ_EXCEPTION,	
+	DEV_RSQ_EXCEPTION,	
+	DEV_SEN_EXCEPTION,	
+	DEV_REC_EXCEPTION	
+};
+enum hdstat {
+	HD_NOT_THERE,		
+	HD_BUSY,		
+	HD_DECONFIGURED,	
+	HD_CHECKSTOPPED,	
+	HD_ONLINE,		
+	HD_TSQ_EXCEPTION	
+};
+#define Z90C_AMBIGUOUS_DOMAIN	2
+#define Z90C_INCORRECT_DOMAIN	3
+#define ENOTINIT		4
+#define SEN_BUSY	 7	
+#define SEN_USER_ERROR	 8	
+#define SEN_QUEUE_FULL	11	
+#define SEN_NOT_AVAIL	16	
+#define SEN_PAD_ERROR	17	
+#define SEN_RETRY	18	
+#define SEN_RELEASED	24	
+#define REC_EMPTY	 4	
+#define REC_BUSY	 6	
+#define REC_OPERAND_INV	 8	
+#define REC_OPERAND_SIZE 9	
+#define REC_EVEN_MOD	10	
+#define REC_NO_WORK	11	
+#define REC_HARDWAR_ERR 12	
+#define REC_NO_RESPONSE 13	
+#define REC_RETRY_DEV	14	
+#define REC_USER_GONE	15	
+#define REC_BAD_MESSAGE 16	
+#define REC_INVALID_PAD 17	
+#define REC_RELEASED	28	
+#define WRONG_DEVICE_TYPE 20	
+#define REC_FATAL_ERROR 32	
+#define SEN_FATAL_ERROR 33	
+#define TSQ_FATAL_ERROR 34
+#define RSQ_FATAL_ERROR 35
+#define PCICA	0
+#define PCICC	1
+#define PCIXCC	2
+#define NILDEV	-1
+#define ANYDEV	-1
+enum hdevice_type {
+	PCICC_HW  = 3,
+	PCICA_HW  = 4,
+	PCIXCC_HW = 5,
+	OTHER_HW  = 6	
+};
+#ifndef DEV_NAME
+#define DEV_NAME	"z90crypt"
+#endif
+#define PRINTK(fmt, args...) \
+	printk(KERN_DEBUG DEV_NAME ": %s -> " fmt, __FUNCTION__ , ## args)
+#define PRINTKN(fmt, args...) \
+	printk(KERN_DEBUG DEV_NAME ": " fmt, ## args)
+#define PRINTKW(fmt, args...) \
+	printk(KERN_WARNING DEV_NAME ": %s -> " fmt, __FUNCTION__ , ## args)
+#define PRINTKC(fmt, args...) \
+	printk(KERN_CRIT DEV_NAME ": %s -> " fmt, __FUNCTION__ , ## args)
+#ifdef Z90CRYPT_DEBUG
+#define PDEBUG(fmt, args...) \
+	printk(KERN_DEBUG DEV_NAME ": %s -> " fmt, __FUNCTION__ , ## args)
+#else
+#define PDEBUG(fmt, args...) do {} while (0)
+#endif
+#define UMIN(a,b) ((a) > (b) ? (a) : (b))
+#define IS_EVEN(x) ((x) == (2 * ((x) / 2)))
+#endif
diff -urN linux-2.6/drivers/s390/crypto/z90crypt.h linux-2.6-s390/drivers/s390/crypto/z90crypt.h
--- linux-2.6/drivers/s390/crypto/z90crypt.h	Thu Jan  1 01:00:00 1970
+++ linux-2.6-s390/drivers/s390/crypto/z90crypt.h	Mon Mar  1 16:36:00 2004
@@ -0,0 +1,231 @@
+/*
+ *  linux/drivers/s390/misc/z90crypt.h
+ *
+ *  z90crypt 1.3.1
+ *
+ *  Copyright (C)  2001, 2004 IBM Corporation
+ *  Author(s): Robert Burroughs (burrough@us.ibm.com)
+ *	       Eric Rossman (edrossma@us.ibm.com)
+ *
+ *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _LINUX_Z90CRYPT_H_
+#define _LINUX_Z90CRYPT_H_
+
+#include <linux/ioctl.h>
+
+#define VERSION_Z90CRYPT_H "$Revision: 1.2 $"
+
+#define z90crypt_VERSION 1
+#define z90crypt_RELEASE 3	// 2 = PCIXCC, 3 = rewrite for coding standards
+#define z90crypt_VARIANT 1
+
+/**
+ * struct ica_rsa_modexpo
+ *
+ * Requirements:
+ * - outputdatalength is at least as large as inputdatalength.
+ * - All key parts are right justified in their fields, padded on
+ *   the left with zeroes.
+ * - length(b_key) = inputdatalength
+ * - length(n_modulus) = inputdatalength
+ */
+struct ica_rsa_modexpo {
+	char *		inputdata;
+	unsigned int	inputdatalength;
+	char *		outputdata;
+	unsigned int	outputdatalength;
+	char *		b_key;
+	char *		n_modulus;
+};
+
+/**
+ * struct ica_rsa_modexpo_crt
+ *
+ * Requirements:
+ * - inputdatalength is even.
+ * - outputdatalength is at least as large as inputdatalength.
+ * - All key parts are right justified in their fields, padded on
+ *   the left with zeroes.
+ * - length(bp_key)	= inputdatalength/2 + 8
+ * - length(bq_key)	= inputdatalength/2
+ * - length(np_key)	= inputdatalength/2 + 8
+ * - length(nq_key)	= inputdatalength/2
+ * - length(u_mult_inv) = inputdatalength/2 + 8
+ */
+struct ica_rsa_modexpo_crt {
+	char *		inputdata;
+	unsigned int	inputdatalength;
+	char *		outputdata;
+	unsigned int	outputdatalength;
+	char *		bp_key;
+	char *		bq_key;
+	char *		np_prime;
+	char *		nq_prime;
+	char *		u_mult_inv;
+};
+
+#define Z90_IOCTL_MAGIC 'z'  // NOTE:  Need to allocate from linux folks
+
+/**
+ * Interface notes:
+ *
+ * The ioctl()s which are implemented (along with relevant details)
+ * are:
+ *
+ *   ICARSAMODEXPO
+ *     Perform an RSA operation using a Modulus-Exponent pair
+ *     This takes an ica_rsa_modexpo struct as its arg.
+ *
+ *     NOTE: please refer to the comments preceding this structure
+ *	     for the implementation details for the contents of the
+ *	     block
+ *
+ *   ICARSACRT
+ *     Perform an RSA operation using a Chinese-Remainder Theorem key
+ *     This takes an ica_rsa_modexpo_crt struct as its arg.
+ *
+ *     NOTE: please refer to the comments preceding this structure
+ *	     for the implementation details for the contents of the
+ *	     block
+ *
+ *   Z90STAT_TOTALCOUNT
+ *     Return an integer count of all device types together.
+ *
+ *   Z90STAT_PCICACOUNT
+ *     Return an integer count of all PCICAs.
+ *
+ *   Z90STAT_PCICCCOUNT
+ *     Return an integer count of all PCICCs.
+ *
+ *   Z90STAT_PCIXCCCOUNT
+ *     Return an integer count of all PCIXCCs.
+ *
+ *   Z90STAT_REQUESTQ_COUNT
+ *     Return an integer count of the number of entries waiting to be
+ *     sent to a device.
+ *
+ *   Z90STAT_PENDINGQ_COUNT
+ *     Return an integer count of the number of entries sent to a
+ *     device awaiting the reply.
+ *
+ *   Z90STAT_TOTALOPEN_COUNT
+ *     Return an integer count of the number of open file handles.
+ *
+ *   Z90STAT_DOMAIN_INDEX
+ *     Return the integer value of the Cryptographic Domain.
+ *
+ *   Z90STAT_STATUS_MASK
+ *     Return an 64 element array of unsigned chars for the status of
+ *     all devices.
+ *	 0x01: PCICA
+ *	 0x02: PCICC
+ *	 0x03: PCIXCC
+ *	 0x0d: device is disabled via the proc filesystem
+ *
+ *   Z90STAT_QDEPTH_MASK
+ *     Return an 64 element array of unsigned chars for the queue
+ *     depth of all devices.
+ *
+ *   Z90STAT_PERDEV_REQCNT
+ *     Return an 64 element array of unsigned integers for the number
+ *     of successfully completed requests per device since the device
+ *     was detected and made available.
+ *
+ *   ICAZ90STATUS (deprecated)
+ *     Return some device driver status in a ica_z90_status struct
+ *     This takes an ica_z90_status struct as its arg.
+ *
+ *     NOTE: this ioctl() is deprecated, and has been replaced with
+ *	     single ioctl()s for each type of status being requested
+ *
+ *   Z90QUIESCE (not recommended)
+ *     Quiesce the driver.  This is intended to stop all new
+ *     requests from being processed.  Its use is not recommended,
+ *     except in circumstances where there is no other way to stop
+ *     callers from accessing the driver.  Its original use was to
+ *     allow the driver to be "drained" of work in preparation for
+ *     a system shutdown.
+ *
+ *     NOTE: once issued, this ban on new work cannot be undone
+ *	     except by unloading and reloading the driver.
+ */
+
+/**
+ * Supported ioctl calls
+ */
+#define ICARSAMODEXPO	_IOC(_IOC_READ|_IOC_WRITE, Z90_IOCTL_MAGIC, 0x05, 0)
+#define ICARSACRT	_IOC(_IOC_READ|_IOC_WRITE, Z90_IOCTL_MAGIC, 0x06, 0)
+
+/* DEPRECATED status call (bound for removal SOON) */
+#define ICAZ90STATUS	_IOR(Z90_IOCTL_MAGIC, 0x10, struct ica_z90_status)
+
+/* unrelated to ICA callers */
+#define Z90QUIESCE	_IO(Z90_IOCTL_MAGIC, 0x11)
+
+/* New status calls */
+#define Z90STAT_TOTALCOUNT	_IOR(Z90_IOCTL_MAGIC, 0x40, int)
+#define Z90STAT_PCICACOUNT	_IOR(Z90_IOCTL_MAGIC, 0x41, int)
+#define Z90STAT_PCICCCOUNT	_IOR(Z90_IOCTL_MAGIC, 0x42, int)
+#define Z90STAT_PCIXCCCOUNT	_IOR(Z90_IOCTL_MAGIC, 0x43, int)
+#define Z90STAT_REQUESTQ_COUNT	_IOR(Z90_IOCTL_MAGIC, 0x44, int)
+#define Z90STAT_PENDINGQ_COUNT	_IOR(Z90_IOCTL_MAGIC, 0x45, int)
+#define Z90STAT_TOTALOPEN_COUNT _IOR(Z90_IOCTL_MAGIC, 0x46, int)
+#define Z90STAT_DOMAIN_INDEX	_IOR(Z90_IOCTL_MAGIC, 0x47, int)
+#define Z90STAT_STATUS_MASK	_IOR(Z90_IOCTL_MAGIC, 0x48, char[64])
+#define Z90STAT_QDEPTH_MASK	_IOR(Z90_IOCTL_MAGIC, 0x49, char[64])
+#define Z90STAT_PERDEV_REQCNT	_IOR(Z90_IOCTL_MAGIC, 0x4a, int[64])
+
+/**
+ * local errno definitions
+ */
+#define ENOBUFF	  129	// filp->private_data->...>work_elem_p->buffer is NULL
+#define EWORKPEND 130	// user issues ioctl while another pending
+#define ERELEASED 131	// user released while ioctl pending
+#define EQUIESCE  132	// z90crypt quiescing (no more work allowed)
+#define ETIMEOUT  133	// request timed out
+#define EUNKNOWN  134	// some unrecognized error occured
+#define EGETBUFF  135	// Error getting buffer
+
+/**
+ * DEPRECATED STRUCTURES
+ */
+
+/**
+ * This structure is DEPRECATED and the corresponding ioctl() has been
+ * replaced with individual ioctl()s for each piece of data!
+ * This structure will NOT survive past version 1.3.1, so switch to the
+ * new ioctl()s.
+ */
+#define MASK_LENGTH 64 // mask length
+struct ica_z90_status {
+	int totalcount;
+	int leedslitecount; // PCICA
+	int leeds2count;    // PCICC
+	// int PCIXCCCount; is not in struct for backward compatibility
+	int requestqWaitCount;
+	int pendingqWaitCount;
+	int totalOpenCount;
+	int cryptoDomain;
+	// status: 0=not there. 1=PCICA. 2=PCICC. 3=PCIXCC
+	unsigned char status[MASK_LENGTH];
+	// qdepth: # work elements waiting for each device
+	unsigned char qdepth[MASK_LENGTH];
+};
+
+#endif /* _LINUX_Z90CRYPT_H_ */
diff -urN linux-2.6/drivers/s390/crypto/z90hardware.c linux-2.6-s390/drivers/s390/crypto/z90hardware.c
--- linux-2.6/drivers/s390/crypto/z90hardware.c	Thu Jan  1 01:00:00 1970
+++ linux-2.6-s390/drivers/s390/crypto/z90hardware.c	Mon Mar  1 16:36:00 2004
@@ -0,0 +1,2162 @@
+/*
+ *  linux/drivers/s390/misc/z90hardware.c
+ *
+ *  z90crypt 1.3.1
+ *
+ *  Copyright (C)  2001, 2004 IBM Corporation
+ *  Author(s): Robert Burroughs (burrough@us.ibm.com)
+ *	       Eric Rossman (edrossma@us.ibm.com)
+ *
+ *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <asm/uaccess.h>	
+#include <linux/compiler.h>
+#include <linux/delay.h>	
+#include <linux/module.h>
+#include "z90crypt.h"
+#include "z90common.h"
+#define VERSION_Z90HARDWARE_C "$Revision: 1.13 $"
+static const char version[] __attribute_used__ =
+	"z90crypt.o: z90hardware.o ("
+	"z90hardware.c " VERSION_Z90HARDWARE_C "/"
+	"z90common.h "	 VERSION_Z90COMMON_H   "/"
+	"z90crypt.h "	 VERSION_Z90CRYPT_H    ")";
+struct cca_token_hdr {
+	unsigned char  token_identifier;
+	unsigned char  version;
+	unsigned short token_length;
+	unsigned char  reserved[4];
+};
+#define CCA_TKN_HDR_ID_EXT 0x1E
+struct cca_private_ext_ME_sec {
+	unsigned char  section_identifier;
+	unsigned char  version;
+	unsigned short section_length;
+	unsigned char  private_key_hash[20];
+	unsigned char  reserved1[4];
+	unsigned char  key_format;
+	unsigned char  reserved2;
+	unsigned char  key_name_hash[20];
+	unsigned char  key_use_flags[4];
+	unsigned char  reserved3[6];
+	unsigned char  reserved4[24];
+	unsigned char  confounder[24];
+	unsigned char  exponent[128];
+	unsigned char  modulus[128];
+};
+#define CCA_PVT_USAGE_ALL 0x80
+struct cca_public_sec {
+	unsigned char  section_identifier;
+	unsigned char  version;
+	unsigned short section_length;
+	unsigned char  reserved[2];
+	unsigned short exponent_len;
+	unsigned short modulus_bit_len;
+	unsigned short modulus_byte_len;    
+	unsigned char  exponent[3];
+};
+struct cca_private_ext_ME {
+	struct cca_token_hdr	      pvtMEHdr;
+	struct cca_private_ext_ME_sec pvtMESec;
+	struct cca_public_sec	      pubMESec;
+};
+struct cca_public_key {
+	struct cca_token_hdr  pubHdr;
+	struct cca_public_sec pubSec;
+};
+struct cca_pvt_ext_CRT_sec {
+	unsigned char  section_identifier;
+	unsigned char  version;
+	unsigned short section_length;
+	unsigned char  private_key_hash[20];
+	unsigned char  reserved1[4];
+	unsigned char  key_format;
+	unsigned char  reserved2;
+	unsigned char  key_name_hash[20];
+	unsigned char  key_use_flags[4];
+	unsigned short p_len;
+	unsigned short q_len;
+	unsigned short dp_len;
+	unsigned short dq_len;
+	unsigned short u_len;
+	unsigned short mod_len;
+	unsigned char  reserved3[4];
+	unsigned short pad_len;
+	unsigned char  reserved4[52];
+	unsigned char  confounder[8];
+};
+#define CCA_PVT_EXT_CRT_SEC_ID_PVT 0x08
+#define CCA_PVT_EXT_CRT_SEC_FMT_CL 0x40
+struct cca_private_ext_CRT {
+	struct cca_token_hdr	   pvtCrtHdr;
+	struct cca_pvt_ext_CRT_sec pvtCrtSec;
+	struct cca_public_sec	   pubCrtSec;
+};
+struct ap_status_word {
+	unsigned char q_stat_flags;
+	unsigned char response_code;
+	unsigned char reserved[2];
+};
+#define AP_Q_STATUS_EMPTY		0x80
+#define AP_Q_STATUS_REPLIES_WAITING	0x40
+#define AP_Q_STATUS_ARRAY_FULL		0x20
+#define AP_RESPONSE_NORMAL		0x00
+#define AP_RESPONSE_Q_NOT_AVAIL		0x01
+#define AP_RESPONSE_RESET_IN_PROGRESS	0x02
+#define AP_RESPONSE_DECONFIGURED	0x03
+#define AP_RESPONSE_CHECKSTOPPED	0x04
+#define AP_RESPONSE_BUSY		0x05
+#define AP_RESPONSE_Q_FULL		0x10
+#define AP_RESPONSE_NO_PENDING_REPLY	0x10   
+#define AP_RESPONSE_INDEX_TOO_BIG	0x11
+#define AP_RESPONSE_NO_FIRST_PART	0x13
+#define AP_RESPONSE_MESSAGE_TOO_BIG	0x15
+#define AP_MAX_CDX_BITL		4
+#define AP_RQID_RESERVED_BITL	4
+#define SKIP_BITL		(AP_MAX_CDX_BITL + AP_RQID_RESERVED_BITL)
+struct type4_hdr {
+	unsigned char  reserved1;
+	unsigned char  msg_type_code;	
+	unsigned short msg_len;
+	unsigned char  request_code;	
+	unsigned char  msg_fmt;
+	unsigned short reserved2;
+};
+#define TYPE4_TYPE_CODE 0x04
+#define TYPE4_REQU_CODE 0x40
+#define TYPE4_SME_LEN 0x0188
+#define TYPE4_LME_LEN 0x0308
+#define TYPE4_SCR_LEN 0x01E0
+#define TYPE4_LCR_LEN 0x03A0
+#define TYPE4_SME_FMT 0x00
+#define TYPE4_LME_FMT 0x10
+#define TYPE4_SCR_FMT 0x40
+#define TYPE4_LCR_FMT 0x50
+struct type4_sme {
+	struct type4_hdr header;
+	unsigned char	 message[128];
+	unsigned char	 exponent[128];
+	unsigned char	 modulus[128];
+};
+struct type4_lme {
+	struct type4_hdr header;
+	unsigned char	 message[256];
+	unsigned char	 exponent[256];
+	unsigned char	 modulus[256];
+};
+struct type4_scr {
+	struct type4_hdr header;
+	unsigned char	 message[128];
+	unsigned char	 dp[72];
+	unsigned char	 dq[64];
+	unsigned char	 p[72];
+	unsigned char	 q[64];
+	unsigned char	 u[72];
+};
+struct type4_lcr {
+	struct type4_hdr header;
+	unsigned char	 message[256];
+	unsigned char	 dp[136];
+	unsigned char	 dq[128];
+	unsigned char	 p[136];
+	unsigned char	 q[128];
+	unsigned char	 u[136];
+};
+union type4_msg {
+	struct type4_sme sme;
+	struct type4_lme lme;
+	struct type4_scr scr;
+	struct type4_lcr lcr;
+};
+struct type84_hdr {
+	unsigned char  reserved1;
+	unsigned char  code;
+	unsigned short len;
+	unsigned char  reserved2[4];
+};
+#define TYPE84_RSP_CODE 0x84
+struct type6_hdr {
+	unsigned char reserved1;	
+	unsigned char type;		
+	unsigned char reserved2[2];	
+	unsigned char right[4];		
+	unsigned char reserved3[2];	
+	unsigned char reserved4[2];	
+	unsigned char pfs[4];		
+	unsigned int  offset1;		
+	unsigned int  offset2;		
+	unsigned int  offset3;		
+	unsigned int  offset4;		
+	unsigned char agent_id[16];	
+					
+					
+					
+					
+					
+					
+	unsigned char rqid[2];		
+	unsigned char reserved5[2];	
+	unsigned char function_code[2];	
+	unsigned char reserved6[2];	
+	unsigned int  ToCardLen1;	
+	unsigned int  ToCardLen2;	
+	unsigned int  ToCardLen3;	
+	unsigned int  ToCardLen4;	
+	unsigned int  FromCardLen1;	
+	unsigned int  FromCardLen2;	
+	unsigned int  FromCardLen3;	
+	unsigned int  FromCardLen4;	
+};
+struct CPRB {
+	unsigned char cprb_len[2];	
+	unsigned char cprb_ver_id;	
+	unsigned char pad_000;		
+	unsigned char srpi_rtcode[4];	
+	unsigned char srpi_verb;	
+	unsigned char flags;		
+	unsigned char func_id[2];	
+	unsigned char checkpoint_flag;	
+	unsigned char resv2;		
+	unsigned char req_parml[2];	
+					
+	unsigned char req_parmp[4];	
+	unsigned char req_datal[4];	
+					
+	unsigned char req_datap[4];	
+					
+	unsigned char rpl_parml[2];	
+					
+	unsigned char pad_001[2];	
+	unsigned char rpl_parmp[4];	
+	unsigned char rpl_datal[4];	
+	unsigned char rpl_datap[4];	
+					
+	unsigned char ccp_rscode[2];	
+	unsigned char ccp_rtcode[2];	
+	unsigned char repd_parml[2];	
+	unsigned char mac_data_len[2];	
+	unsigned char repd_datal[4];	
+	unsigned char req_pc[2];	
+	unsigned char res_origin[8];	
+	unsigned char mac_value[8];	
+	unsigned char logon_id[8];	
+	unsigned char usage_domain[2];	
+	unsigned char resv3[18];	
+	unsigned char svr_namel[2];	
+	unsigned char svr_name[8];	
+};
+struct CPRBX {
+	unsigned short cprb_len;	
+	unsigned char  cprb_ver_id;	
+	unsigned char  pad_000[3];	
+	unsigned char  func_id[2];	
+	unsigned char  cprb_flags[4];	
+	unsigned int   req_parml;	
+	unsigned int   req_datal;	
+	unsigned int   rpl_msgbl;	
+	unsigned int   rpld_parml;	
+	unsigned int   rpl_datal;	
+	unsigned int   rpld_datal;	
+	unsigned int   req_extbl;	
+	unsigned char  pad_001[4];	
+	unsigned int   rpld_extbl;	
+	unsigned char  req_parmb[16];	
+	unsigned char  req_datab[16];	
+	unsigned char  rpl_parmb[16];	
+	unsigned char  rpl_datab[16];	
+	unsigned char  req_extb[16];	
+	unsigned char  rpl_extb[16];	
+	unsigned short ccp_rtcode;	
+	unsigned short ccp_rscode;	
+	unsigned int   mac_data_len;	
+	unsigned char  logon_id[8];	
+	unsigned char  mac_value[8];	
+	unsigned char  mac_content_flgs;
+	unsigned char  pad_002;		
+	unsigned short domain;		
+	unsigned char  pad_003[12];	
+	unsigned char  pad_004[36];	
+};
+struct type6_msg {
+	struct type6_hdr header;
+	struct CPRB	 CPRB;
+};
+union request_msg {
+	union  type4_msg t4msg;
+	struct type6_msg t6msg;
+};
+struct request_msg_ext {
+	int		  q_nr;
+	unsigned char	  *psmid;
+	union request_msg reqMsg;
+};
+struct type82_hdr {
+	unsigned char reserved1;	
+	unsigned char type;		
+	unsigned char reserved2[2];	
+	unsigned char reply_code;	
+	unsigned char reserved3[3];	
+};
+#define TYPE82_RSP_CODE 0x82
+#define REPLY_ERROR_MACHINE_FAILURE  0x10
+#define REPLY_ERROR_PREEMPT_FAILURE  0x12
+#define REPLY_ERROR_CHECKPT_FAILURE  0x14
+#define REPLY_ERROR_MESSAGE_TYPE     0x20
+#define REPLY_ERROR_INVALID_COMM_CD  0x21  
+#define REPLY_ERROR_INVALID_MSG_LEN  0x23
+#define REPLY_ERROR_RESERVD_FIELD    0x24  
+#define REPLY_ERROR_FORMAT_FIELD     0x29
+#define REPLY_ERROR_INVALID_COMMAND  0x30  
+#define REPLY_ERROR_MALFORMED_MSG    0x40
+#define REPLY_ERROR_RESERVED_FIELD   0x50  
+#define REPLY_ERROR_WORD_ALIGNMENT   0x60
+#define REPLY_ERROR_MESSAGE_LENGTH   0x80
+#define REPLY_ERROR_OPERAND_INVALID  0x82
+#define REPLY_ERROR_OPERAND_SIZE     0x84
+#define REPLY_ERROR_EVEN_MOD_IN_OPND 0x85
+#define REPLY_ERROR_TRANSPORT_FAIL   0x90
+#define REPLY_ERROR_PACKET_TRUNCATED 0xA0
+#define REPLY_ERROR_ZERO_BUFFER_LEN  0xB0
+struct type86_hdr {
+	unsigned char reserved1;	
+	unsigned char type;		
+	unsigned char format;		
+	unsigned char reserved2;	
+	unsigned char reply_code;	
+	unsigned char reserved3[3];	
+};
+#define TYPE86_RSP_CODE 0x86
+#define TYPE86_FMT2	0x02
+struct type86_fmt2_msg {
+	struct type86_hdr hdr;
+	unsigned char	  reserved[4];	
+	unsigned char	  apfs[4];	
+	unsigned int	  count1;	
+	unsigned int	  offset1;	
+	unsigned int	  count2;	
+	unsigned int	  offset2;	
+	unsigned int	  count3;	
+	unsigned int	  offset3;	
+	unsigned int	  ount4;	
+	unsigned int	  offset4;	
+};
+static struct type6_hdr static_type6_hdr = {
+	0x00,
+	0x06,
+	{0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	0x00000058,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	{0x01,0x00,0x43,0x43,0x41,0x2D,0x41,0x50,
+	 0x50,0x4C,0x20,0x20,0x20,0x01,0x01,0x01},
+	{0x00,0x00},
+	{0x00,0x00},
+	{0x50,0x44},
+	{0x00,0x00},
+	0x00000000,	
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,	
+	0x00000000,
+	0x00000000,
+	0x00000000
+};
+static struct type6_hdr static_type6_hdrX = {
+	0x00,
+	0x06,
+	{0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	0x00000058,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	{0x43,0x41,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00},
+	{0x50,0x44},
+	{0x00,0x00},
+	0x00000000,	
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,	
+	0x00000000,
+	0x00000000,
+	0x00000000
+};
+static struct CPRB static_cprb = {
+	{0x70,0x00},
+	0x41,
+	0x00,
+	{0x00,0x00,0x00,0x00},
+	0x00,
+	0x00,
+	{0x54,0x32},
+	0x01,
+	0x00,
+	{0x00,0x00},	
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00},	
+	{0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00,0x00,0x00},
+	{0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00},	
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00},
+	{0x08,0x00},
+	{0x49,0x43,0x53,0x46,0x20,0x20,0x20,0x20}
+};
+struct function_and_rules_block {
+	unsigned char function_code[2];
+	unsigned char ulen[2];
+	unsigned char only_rule[8];
+};
+static struct function_and_rules_block static_pkd_function_and_rules = {
+	{0x50,0x44},			   
+	{0x0A,0x00},			   
+	{'P','K','C','S','-','1','.','2'}
+};
+static struct function_and_rules_block static_pke_function_and_rules = {
+	{0x50,0x4B},			   
+	{0x0A,0x00},			   
+	{'P','K','C','S','-','1','.','2'}
+};
+struct T6_keyBlock_hdr {
+	unsigned char blen[2];
+	unsigned char ulen[2];
+	unsigned char flags[2];
+};
+static struct T6_keyBlock_hdr static_T6_keyBlock_hdr = {
+	{0x89,0x01},	   
+	{0x87,0x01},	   
+	{0x00}
+};
+static struct CPRBX static_cprbx = {
+	0x00DC,
+	0x02,
+	{0x00,0x00,0x00},
+	{0x54,0x32},
+	{0x00,0x00,0x00,0x00},
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	{0x00,0x00,0x00,0x00},
+	0x00000000,
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	0x0000,
+	0x0000,
+	0x00000000,
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	0x00,
+	0x00,
+	0x0000,
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
+};
+static struct function_and_rules_block static_pkd_function_and_rulesX = {
+	{0x50,0x44},	
+	{0x00,0x0A},	
+	{'P','K','C','S','-','1','.','2'}
+};
+static struct function_and_rules_block static_pke_function_and_rulesX = {
+	{0x50,0x4B},	
+	{0x00,0x0A},	
+	{'Z','E','R','O','-','P','A','D'}
+};
+struct T6_keyBlock_hdrX {
+	unsigned short blen;
+	unsigned short ulen;
+	unsigned char flags[2];
+};
+static struct T6_keyBlock_hdrX static_T6_keyBlock_hdrX = {
+	0x0189, 
+	0x0187, 
+	{0x00}
+};
+static unsigned char static_pad[256] = {
+0x1B,0x7B,0x5D,0xB5,0x75,0x01,0x3D,0xFD,0x8D,0xD1,0xC7,0x03,0x2D,0x09,0x23,0x57,
+0x89,0x49,0xB9,0x3F,0xBB,0x99,0x41,0x5B,0x75,0x21,0x7B,0x9D,0x3B,0x6B,0x51,0x39,
+0xBB,0x0D,0x35,0xB9,0x89,0x0F,0x93,0xA5,0x0B,0x47,0xF1,0xD3,0xBB,0xCB,0xF1,0x9D,
+0x23,0x73,0x71,0xFF,0xF3,0xF5,0x45,0xFB,0x61,0x29,0x23,0xFD,0xF1,0x29,0x3F,0x7F,
+0x17,0xB7,0x1B,0xA9,0x19,0xBD,0x57,0xA9,0xD7,0x95,0xA3,0xCB,0xED,0x1D,0xDB,0x45,
+0x7D,0x11,0xD1,0x51,0x1B,0xED,0x71,0xE9,0xB1,0xD1,0xAB,0xAB,0x21,0x2B,0x1B,0x9F,
+0x3B,0x9F,0xF7,0xF7,0xBD,0x63,0xEB,0xAD,0xDF,0xB3,0x6F,0x5B,0xDB,0x8D,0xA9,0x5D,
+0xE3,0x7D,0x77,0x49,0x47,0xF5,0xA7,0xFD,0xAB,0x2F,0x27,0x35,0x77,0xD3,0x49,0xC9,
+0x09,0xEB,0xB1,0xF9,0xBF,0x4B,0xCB,0x2B,0xEB,0xEB,0x05,0xFF,0x7D,0xC7,0x91,0x8B,
+0x09,0x83,0xB9,0xB9,0x69,0x33,0x39,0x6B,0x79,0x75,0x19,0xBF,0xBB,0x07,0x1D,0xBD,
+0x29,0xBF,0x39,0x95,0x93,0x1D,0x35,0xC7,0xC9,0x4D,0xE5,0x97,0x0B,0x43,0x9B,0xF1,
+0x16,0x93,0x03,0x1F,0xA5,0xFB,0xDB,0xF3,0x27,0x4F,0x27,0x61,0x05,0x1F,0xB9,0x23,
+0x2F,0xC3,0x81,0xA9,0x23,0x71,0x55,0x55,0xEB,0xED,0x41,0xE5,0xF3,0x11,0xF1,0x43,
+0x69,0x03,0xBD,0x0B,0x37,0x0F,0x51,0x8F,0x0B,0xB5,0x89,0x5B,0x67,0xA9,0xD9,0x4F,
+0x01,0xF9,0x21,0x77,0x37,0x73,0x79,0xC5,0x7F,0x51,0xC1,0xCF,0x97,0xA1,0x75,0xAD,
+0x35,0x9D,0xD3,0xD3,0xA7,0x9D,0x5D,0x41,0x6F,0x65,0x1B,0xCF,0xA9,0x87,0x91,0x09
+};
+static struct cca_private_ext_ME static_pvt_me_key = {
+	{
+		0x1E,
+		0x00,
+		0x0183,
+		{0x00,0x00,0x00,0x00}
+	},
+	{
+		0x02,
+		0x00,
+		0x016C,
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00},
+		{0x00,0x00,0x00,0x00},
+		0x00,
+		0x00,
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00},
+		{0x80,0x00,0x00,0x00},
+		{0x00,0x00,0x00,0x00,0x00,0x00},
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
+	},
+	{
+		0x04,
+		0x00,
+		0x000F,
+		{0x00,0x00},
+		0x0003,
+		0x0000,
+		0x0000,
+		{0x01,0x00,0x01}
+	}
+};
+static struct cca_public_key static_public_key = {
+	{
+		0x1E,
+		0x00,
+		0x0000,			
+		{0x00,0x00,0x00,0x00}
+	},
+	{
+		0x04,
+		0x00,
+		0x0000,			
+		{0x00,0x00},
+		0x0000,			
+		0x0000,			
+		0x0000,			
+		{0x01,0x00,0x01}
+	}
+};
+#define FIXED_TYPE6_ME_LEN 0x0000025F
+#define FIXED_TYPE6_ME_EN_LEN 0x000000F0
+#define FIXED_TYPE6_ME_LENX 0x000002CB
+#define FIXED_TYPE6_ME_EN_LENX 0x0000015C
+static struct cca_public_sec static_cca_pub_sec = {
+	0x04,
+	0x00,
+	0x000f,
+	{0x00,0x00},
+	0x0003,
+	0x0000,	      
+	0x0000,
+	{0x01,0x00,0x01}
+};
+#define FIXED_TYPE6_CR_LEN 0x00000177
+#define FIXED_TYPE6_CR_LENX 0x000001E3
+#ifndef MAX_RESPONSE_SIZE
+#define MAX_RESPONSE_SIZE 0x00000710
+#define MAX_RESPONSEX_SIZE 0x0000077C
+#endif
+#define RESPONSE_CPRB_SIZE  0x000006B8 
+#define RESPONSE_CPRBX_SIZE 0x00000724 
+#define CALLER_HEADER 12	
+static unsigned char static_PKE_function_code[2] = {0x50, 0x4B};
+static inline int
+testq(int q_nr, int *q_depth, int *dev_type, struct ap_status_word *stat)
+{
+	int ccode;
+	asm volatile
+#ifdef __s390x__
+	("	lgr	0,%4		\n"	
+	 "	slgr	1,1		\n"	
+	 "	lgr	2,1		\n"	
+	 "0:	.long	0xb2af0000	\n"	
+	 "1:	ipm	%0		\n"	
+	 "	srl	%0,28		\n"	
+	 "	iihh	%0,0		\n"	
+	 "	iihl	%0,0		\n"	
+	 "	lgr	%1,1		\n"	
+	 "	lgr	%3,2		\n"
+	 "	srl	%3,24		\n"	
+	 "	sll	2,24		\n"
+	 "	srl	2,24		\n"
+	 "	lgr	%2,2		\n"	
+	 "2:				\n"	
+	 ".section .fixup,\"ax\"	\n"
+	 "3:				\n"	
+	 "	lhi	%0,%h5		\n"
+	 "	bras	1,4f		\n"
+	 "	.long	2b		\n"
+	 "4:				\n"
+	 "	l	1,0(1)		\n"
+	 "	br	1		\n"
+	 ".previous			\n"
+	 ".section __ex_table,\"a\"	\n"
+	 "	.align	8		\n"
+	 "	.quad	0b,3b		\n"
+	 "	.quad	1b,3b		\n"
+	 ".previous"
+	 :"=d" (ccode),"=d" (*stat),"=d" (*q_depth), "=d" (*dev_type)
+	 :"d" (q_nr), "K" (DEV_TSQ_EXCEPTION)
+	 :"cc","0","1","2");
+#else
+	("	lr	0,%4		\n"	
+	 "	slr	1,1		\n"	
+	 "	lr	2,1		\n"	
+	 "0:	.long	0xb2af0000	\n"	
+	 "1:	ipm	%0		\n"	
+	 "	srl	%0,28		\n"	
+	 "	lr	%1,1		\n"	
+	 "	lr	%3,2		\n"
+	 "	srl	%3,24		\n"	
+	 "	sll	2,24		\n"
+	 "	srl	2,24		\n"
+	 "	lr	%2,2		\n"	
+	 "2:				\n"	
+	 ".section .fixup,\"ax\"	\n"
+	 "3:				\n"	
+	 "	lhi	%0,%h5		\n"
+	 "	bras	1,4f		\n"
+	 "	.long	2b		\n"
+	 "4:				\n"
+	 "	l	1,0(1)		\n"
+	 "	br	1		\n"
+	 ".previous			\n"
+	 ".section __ex_table,\"a\"	\n"
+	 "	.align	4		\n"
+	 "	.long	0b,3b		\n"
+	 "	.long	1b,3b		\n"
+	 ".previous"
+	 :"=d" (ccode),"=d" (*stat),"=d" (*q_depth), "=d" (*dev_type)
+	 :"d" (q_nr), "K" (DEV_TSQ_EXCEPTION)
+	 :"cc","0","1","2");
+#endif
+	return ccode;
+}
+static inline int
+resetq(int q_nr, struct ap_status_word *stat_p)
+{
+	int ccode;
+	asm volatile
+#ifdef __s390x__
+	("	lgr	0,%2		\n"	
+	 "	lghi	1,1		\n"	
+	 "	sll	1,24		\n"	
+	 "	or	0,1		\n"	
+	 "	slgr	1,1		\n"	
+	 "	lgr	2,1		\n"	
+	 "0:	.long	0xb2af0000	\n"	
+	 "1:	ipm	%0		\n"	
+	 "	srl	%0,28		\n"	
+	 "	iihh	%0,0		\n"	
+	 "	iihl	%0,0		\n"	
+	 "	lgr	%1,1		\n"	
+	 "2:				\n"	
+	 ".section .fixup,\"ax\"	\n"
+	 "3:				\n"	
+	 "	lhi	%0,%h3		\n"
+	 "	bras	1,4f		\n"
+	 "	.long	2b		\n"
+	 "4:				\n"
+	 "	l	1,0(1)		\n"
+	 "	br	1		\n"
+	 ".previous			\n"
+	 ".section __ex_table,\"a\"	\n"
+	 "	.align	8		\n"
+	 "	.quad	0b,3b		\n"
+	 "	.quad	1b,3b		\n"
+	 ".previous"
+	 :"=d" (ccode),"=d" (*stat_p)
+	 :"d" (q_nr), "K" (DEV_RSQ_EXCEPTION)
+	 :"cc","0","1","2");
+#else
+	("	lr	0,%2		\n"	
+	 "	lhi	1,1		\n"	
+	 "	sll	1,24		\n"	
+	 "	or	0,1		\n"	
+	 "	slr	1,1		\n"	
+	 "	lr	2,1		\n"	
+	 "0:	.long	0xb2af0000	\n"	
+	 "1:	ipm	%0		\n"	
+	 "	srl	%0,28		\n"	
+	 "	lr	%1,1		\n"	
+	 "2:				\n"	
+	 ".section .fixup,\"ax\"	\n"
+	 "3:				\n"	
+	 "	lhi	%0,%h3		\n"
+	 "	bras	1,4f		\n"
+	 "	.long	2b		\n"
+	 "4:				\n"
+	 "	l	1,0(1)		\n"
+	 "	br	1		\n"
+	 ".previous			\n"
+	 ".section __ex_table,\"a\"	\n"
+	 "	.align	4		\n"
+	 "	.long	0b,3b		\n"
+	 "	.long	1b,3b		\n"
+	 ".previous"
+	 :"=d" (ccode),"=d" (*stat_p)
+	 :"d" (q_nr), "K" (DEV_RSQ_EXCEPTION)
+	 :"cc","0","1","2");
+#endif
+	return ccode;
+}
+static inline int
+sen(int msg_len, unsigned char *msg_ext, struct ap_status_word *stat)
+{
+	int ccode;
+	asm volatile
+#ifdef __s390x__
+	("	lgr	6,%3		\n"	
+	 "	lgr	7,%2		\n"	
+	 "	llgt	0,0(6)		\n"	
+	 "	lghi	1,64		\n"	
+	 "	sll	1,24		\n"	
+	 "	or	0,1		\n"	
+	 "	la	6,4(6)		\n"	
+	 "	llgt	2,0(6)		\n"	
+	 "	llgt	3,4(6)		\n"	
+	 "	la	6,8(6)		\n"	
+	 "	slr	1,1		\n"	
+	 "0:	.long	0xb2ad0026	\n"	
+	 "1:	brc	2,0b		\n"	
+	 "	ipm	%0		\n"	
+	 "	srl	%0,28		\n"	
+	 "	iihh	%0,0		\n"	
+	 "	iihl	%0,0		\n"	
+	 "	lgr	%1,1		\n"	
+	 "2:				\n"	
+	 ".section .fixup,\"ax\"	\n"
+	 "3:				\n"	
+	 "	lhi	%0,%h4		\n"
+	 "	bras	1,4f		\n"
+	 "	.long	2b		\n"
+	 "4:				\n"
+	 "	l	1,0(1)		\n"
+	 "	br	1		\n"
+	 ".previous			\n"
+	 ".section __ex_table,\"a\"	\n"
+	 "	.align	8		\n"
+	 "	.quad	0b,3b		\n"
+	 "	.quad	1b,3b		\n"
+	 ".previous"
+	 :"=d" (ccode),"=d" (*stat)
+	 :"d" (msg_len),"a" (msg_ext), "K" (DEV_SEN_EXCEPTION)
+	 :"cc","0","1","2","3","6","7");
+#else
+	("	lr	6,%3		\n"	
+	 "	lr	7,%2		\n"	
+	 "	l	0,0(6)		\n"	
+	 "	lhi	1,64		\n"	
+	 "	sll	1,24		\n"	
+	 "	or	0,1		\n"	
+	 "	la	6,4(6)		\n"	
+	 "	l	2,0(6)		\n"	
+	 "	l	3,4(6)		\n"	
+	 "	la	6,8(6)		\n"	
+	 "	slr	1,1		\n"	
+	 "0:	.long	0xb2ad0026	\n"	
+	 "1:	brc	2,0b		\n"	
+	 "	ipm	%0		\n"	
+	 "	srl	%0,28		\n"	
+	 "	lr	%1,1		\n"	
+	 "2:				\n"	
+	 ".section .fixup,\"ax\"	\n"
+	 "3:				\n"	
+	 "	lhi	%0,%h4		\n"
+	 "	bras	1,4f		\n"
+	 "	.long	2b		\n"
+	 "4:				\n"
+	 "	l	1,0(1)		\n"
+	 "	br	1		\n"
+	 ".previous			\n"
+	 ".section __ex_table,\"a\"	\n"
+	 "	.align	4		\n"
+	 "	.long	0b,3b		\n"
+	 "	.long	1b,3b		\n"
+	 ".previous"
+	 :"=d" (ccode),"=d" (*stat)
+	 :"d" (msg_len),"a" (msg_ext), "K" (DEV_SEN_EXCEPTION)
+	 :"cc","0","1","2","3","6","7");
+#endif
+	return ccode;
+}
+static inline int
+rec(int q_nr, int buff_l, unsigned char *rsp, unsigned char *id,
+    struct ap_status_word *st)
+{
+	int ccode;
+	asm volatile
+#ifdef __s390x__
+	("	lgr	0,%2		\n"	
+	 "	lgr	3,%4		\n"	
+	 "	lgr	6,%3		\n"	
+	 "	lgr	7,%5		\n"	
+	 "	lghi	1,128		\n"	
+	 "	sll	1,24		\n"	
+	 "	or	0,1		\n"	
+	 "	slgr	1,1		\n"	
+	 "	lgr	2,1		\n"	
+	 "	lgr	4,1		\n"	
+	 "	lgr	5,1		\n"	
+	 "0:	.long	0xb2ae0046	\n"	
+	 "1:	brc	2,0b		\n"	
+	 "	brc	4,0b		\n"	
+	 "	ipm	%0		\n"	
+	 "	srl	%0,28		\n"	
+	 "	iihh	%0,0		\n"	
+	 "	iihl	%0,0		\n"	
+	 "	lgr	%1,1		\n"	
+	 "	st	4,0(3)		\n"	
+	 "	st	5,4(3)		\n"	
+	 "2:				\n"	
+	 ".section .fixup,\"ax\"	\n"
+	 "3:				\n"	
+	 "	lhi   %0,%h6		\n"
+	 "	bras  1,4f		\n"
+	 "	.long 2b		\n"
+	 "4:				\n"
+	 "	l     1,0(1)		\n"
+	 "	br    1			\n"
+	 ".previous			\n"
+	 ".section __ex_table,\"a\"	\n"
+	 "   .align	8		\n"
+	 "   .quad	0b,3b		\n"
+	 "   .quad	1b,3b		\n"
+	 ".previous"
+	 :"=d"(ccode),"=d"(*st)
+	 :"d" (q_nr), "d" (rsp), "d" (id), "d" (buff_l), "K" (DEV_REC_EXCEPTION)
+	 :"cc","0","1","2","3","4","5","6","7","memory");
+#else
+	("	lr	0,%2		\n"	
+	 "	lr	3,%4		\n"	
+	 "	lr	6,%3		\n"	
+	 "	lr	7,%5		\n"	
+	 "	lhi	1,128		\n"	
+	 "	sll	1,24		\n"	
+	 "	or	0,1		\n"	
+	 "	slr	1,1		\n"	
+	 "	lr	2,1		\n"	
+	 "	lr	4,1		\n"	
+	 "	lr	5,1		\n"	
+	 "0:	.long	0xb2ae0046	\n"	
+	 "1:	brc	2,0b		\n"	
+	 "	brc	4,0b		\n"	
+	 "	ipm	%0		\n"	
+	 "	srl	%0,28		\n"	
+	 "	lr	%1,1		\n"	
+	 "	st	4,0(3)		\n"	
+	 "	st	5,4(3)		\n"	
+	 "2:				\n"	
+	 ".section .fixup,\"ax\"	\n"
+	 "3:				\n"	
+	 "	lhi   %0,%h6		\n"
+	 "	bras  1,4f		\n"
+	 "	.long 2b		\n"
+	 "4:				\n"
+	 "	l     1,0(1)		\n"
+	 "	br    1			\n"
+	 ".previous			\n"
+	 ".section __ex_table,\"a\"	\n"
+	 "   .align	4		\n"
+	 "   .long	0b,3b		\n"
+	 "   .long	1b,3b		\n"
+	 ".previous"
+	 :"=d"(ccode),"=d"(*st)
+	 :"d" (q_nr), "d" (rsp), "d" (id), "d" (buff_l), "K" (DEV_REC_EXCEPTION)
+	 :"cc","0","1","2","3","4","5","6","7","memory");
+#endif
+	return ccode;
+}
+static inline void
+itoLe2(int *i_p, unsigned char *lechars)
+{
+	*lechars       = *((unsigned char *) i_p + sizeof(int) - 1);
+	*(lechars + 1) = *((unsigned char *) i_p + sizeof(int) - 2);
+}
+static inline void
+le2toI(unsigned char *lechars, int *i_p)
+{
+	unsigned char *ic_p;
+	*i_p = 0;
+	ic_p = (unsigned char *) i_p;
+	*(ic_p + 2) = *(lechars + 1);
+	*(ic_p + 3) = *(lechars);
+}
+static inline int
+is_empty(unsigned char *ptr, int len)
+{
+	return !memcmp(ptr, (unsigned char *) &static_pvt_me_key+60, len);
+}
+enum hdstat
+query_online(int deviceNr, int cdx, int resetNr, int *q_depth, int *dev_type)
+{
+	int q_nr, i, t_depth, t_dev_type;
+	enum devstat ccode;
+	struct ap_status_word stat_word;
+	enum hdstat stat;
+	int break_out;
+	q_nr = (deviceNr << SKIP_BITL) + cdx;
+	stat = HD_BUSY;
+	ccode = testq(q_nr, &t_depth, &t_dev_type, &stat_word);
+	PDEBUG("ccode %d response_code %02X\n", ccode, stat_word.response_code);
+	break_out = 0;
+	for (i = 0; i < resetNr; i++) {
+		if (ccode > 3) {
+			PRINTKC("Exception testing device %d\n", i);
+			return HD_TSQ_EXCEPTION;
+		}
+		switch (ccode) {
+		case 0:
+			PDEBUG("t_dev_type %d\n", t_dev_type);
+			break_out = 1;
+			stat = HD_ONLINE;
+			*q_depth = t_depth + 1;
+			switch (t_dev_type) {
+			case OTHER_HW:
+				stat = HD_NOT_THERE;
+				*dev_type = NILDEV;
+				break;
+			case PCICA_HW:
+				*dev_type = PCICA;
+				break;
+			case PCICC_HW:
+				*dev_type = PCICC;
+				break;
+			case PCIXCC_HW:
+				*dev_type = PCIXCC;
+				break;
+			default:
+				*dev_type = NILDEV;
+				break;
+			}
+			PDEBUG("available device %d: Q depth = %d, dev "
+			       "type = %d, stat = %02X%02X%02X%02X\n",
+			       deviceNr, *q_depth, *dev_type,
+			       stat_word.q_stat_flags,
+			       stat_word.response_code,
+			       stat_word.reserved[0],
+			       stat_word.reserved[1]);
+			break;
+		case 3:
+			switch (stat_word.response_code) {
+			case AP_RESPONSE_NORMAL:
+				stat = HD_ONLINE;
+				break_out = 1;
+				*q_depth = t_depth + 1;
+				*dev_type = t_dev_type;
+				PDEBUG("cc3, available device "
+				       "%d: Q depth = %d, dev "
+				       "type = %d, stat = "
+				       "%02X%02X%02X%02X\n",
+				       deviceNr, *q_depth,
+				       *dev_type,
+				       stat_word.q_stat_flags,
+				       stat_word.response_code,
+				       stat_word.reserved[0],
+				       stat_word.reserved[1]);
+				break;
+			case AP_RESPONSE_Q_NOT_AVAIL:
+				stat = HD_NOT_THERE;
+				break_out = 1;
+				break;
+			case AP_RESPONSE_RESET_IN_PROGRESS:
+				PDEBUG("device %d in reset\n",
+				       deviceNr);
+				break;
+			case AP_RESPONSE_DECONFIGURED:
+				stat = HD_DECONFIGURED;
+				break_out = 1;
+				break;
+			case AP_RESPONSE_CHECKSTOPPED:
+				stat = HD_CHECKSTOPPED;
+				break_out = 1;
+				break;
+			case AP_RESPONSE_BUSY:
+				PDEBUG("device %d busy\n",
+				       deviceNr);
+				break;
+			default:
+				break;
+			}
+			break;
+		default:
+			stat = HD_NOT_THERE;
+			break_out = 1;
+		}
+		if (break_out)
+			break;
+		
+		udelay(5);
+		
+		ccode = testq(q_nr, &t_depth, &t_dev_type, &stat_word);
+	}
+	return stat;
+}
+enum devstat
+reset_device(int deviceNr, int cdx, int resetNr)
+{
+	int q_nr, ccode = 0, dummy_qdepth, dummy_devType, i;
+	struct ap_status_word stat_word;
+	enum devstat stat;
+	int break_out;
+	q_nr = (deviceNr << SKIP_BITL) + cdx;
+	stat = DEV_GONE;
+	ccode = resetq(q_nr, &stat_word);
+	if (ccode > 3)
+		return DEV_RSQ_EXCEPTION;
+	break_out = 0;
+	for (i = 0; i < resetNr; i++) {
+		switch (ccode) {
+		case 0:
+			stat = DEV_ONLINE;
+			if (stat_word.q_stat_flags & AP_Q_STATUS_EMPTY)
+				break_out = 1;
+			break;
+		case 3:
+			switch (stat_word.response_code) {
+			case AP_RESPONSE_NORMAL:
+				stat = DEV_ONLINE;
+				if (stat_word.q_stat_flags &
+				    AP_Q_STATUS_EMPTY)
+					break_out = 1;
+				break;
+			case AP_RESPONSE_Q_NOT_AVAIL:
+				stat = DEV_GONE;
+				break_out = 1;
+				break;
+			case AP_RESPONSE_DECONFIGURED:
+				stat = DEV_GONE;
+				break_out = 1;
+				break;
+			case AP_RESPONSE_CHECKSTOPPED:
+				stat = DEV_GONE;
+				break_out = 1;
+				break;
+			case AP_RESPONSE_RESET_IN_PROGRESS:
+			case AP_RESPONSE_BUSY:
+			default:
+				break;
+			}
+			break;
+		default:
+			stat = DEV_GONE;
+			break_out = 1;
+		}
+		if (break_out == 1)
+			break;
+		udelay(5);
+		ccode = testq(q_nr, &dummy_qdepth, &dummy_devType, &stat_word);
+		if (ccode > 3) {
+			stat = DEV_TSQ_EXCEPTION;
+			break;
+		}
+	}
+	PDEBUG("Number of testq's needed for reset: %d\n", i);
+	if (i >= resetNr) {
+	  stat = DEV_GONE;
+	}
+	return stat;
+}
+#ifdef DEBUG_HYDRA_MSGS
+static inline void
+print_buffer(unsigned char *buffer, int bufflen)
+{
+	int i;
+	for (i = 0; i < bufflen; i += 16) {
+		PRINTK("%04X: %02X%02X%02X%02X %02X%02X%02X%02X "
+		       "%02X%02X%02X%02X %02X%02X%02X%02X\n", i,
+		       buffer[i+0], buffer[i+1], buffer[i+2], buffer[i+3],
+		       buffer[i+4], buffer[i+5], buffer[i+6], buffer[i+7],
+		       buffer[i+8], buffer[i+9], buffer[i+10], buffer[i+11],
+		       buffer[i+12], buffer[i+13], buffer[i+14], buffer[i+15]);
+	}
+}
+#endif
+enum devstat
+send_to_AP(int dev_nr, int cdx, int msg_len, unsigned char *msg_ext)
+{
+	struct ap_status_word stat_word;
+	enum devstat stat;
+	int ccode;
+	((struct request_msg_ext *) msg_ext)->q_nr =
+		(dev_nr << SKIP_BITL) + cdx;
+	PDEBUG("msg_len passed to sen: %d\n", msg_len);
+	PDEBUG("q number passed to sen: %02x%02x%02x%02x\n",
+	       msg_ext[0], msg_ext[1], msg_ext[2], msg_ext[3]);
+	stat = DEV_GONE;
+#ifdef DEBUG_HYDRA_MSGS
+	PRINTK("Request header: %02X%02X%02X%02X %02X%02X%02X%02X "
+	       "%02X%02X%02X%02X\n",
+	       msg_ext[0], msg_ext[1], msg_ext[2], msg_ext[3],
+	       msg_ext[4], msg_ext[5], msg_ext[6], msg_ext[7],
+	       msg_ext[8], msg_ext[9], msg_ext[10], msg_ext[11]);
+	
+	print_buffer(msg_ext+12, msg_len);
+#endif
+	ccode = sen(msg_len, msg_ext, &stat_word);
+	if (ccode > 3)
+		return DEV_SEN_EXCEPTION;
+	PDEBUG("nq cc: %u, st: %02x%02x%02x%02x\n",
+	       ccode, stat_word.q_stat_flags, stat_word.response_code,
+	       stat_word.reserved[0], stat_word.reserved[1]);
+	switch (ccode) {
+	case 0:
+		stat = DEV_ONLINE;
+		break;
+	case 1:
+		stat = DEV_GONE;
+		break;
+	case 3:
+		switch (stat_word.response_code) {
+		case AP_RESPONSE_NORMAL:
+			stat = DEV_ONLINE;
+			break;
+		case AP_RESPONSE_Q_FULL:
+			stat = DEV_QUEUE_FULL;
+			break;
+		default:
+			stat = DEV_GONE;
+			break;
+		}
+		break;
+	default:
+		stat = DEV_GONE;
+	}
+	return stat;
+}
+enum devstat
+receive_from_AP(int dev_nr, int cdx, int resplen,
+		unsigned char *resp, unsigned char *psmid)
+{
+	int ccode;
+	struct ap_status_word stat_word;
+	enum devstat stat;
+	memset(resp, 0x00, 8);
+	ccode = rec((dev_nr << SKIP_BITL) + cdx, resplen, resp, psmid,
+		    &stat_word);
+	if (ccode > 3)
+		return DEV_REC_EXCEPTION;
+	PDEBUG("dq cc: %u, st: %02x%02x%02x%02x\n",
+	       ccode, stat_word.q_stat_flags, stat_word.response_code,
+	       stat_word.reserved[0], stat_word.reserved[1]);
+	stat = DEV_GONE;
+	switch (ccode) {
+	case 0:
+		stat = DEV_ONLINE;
+#ifdef DEBUG_HYDRA_MSGS
+		print_buffer(resp, resplen);
+#endif
+		break;
+	case 3:
+		switch (stat_word.response_code) {
+		case AP_RESPONSE_NORMAL:
+			stat = DEV_ONLINE;
+			break;
+		case AP_RESPONSE_NO_PENDING_REPLY:
+			if (stat_word.q_stat_flags & AP_Q_STATUS_EMPTY)
+				stat = DEV_EMPTY;
+			else
+				stat = DEV_NO_WORK;
+			break;
+		case AP_RESPONSE_INDEX_TOO_BIG:
+		case AP_RESPONSE_NO_FIRST_PART:
+		case AP_RESPONSE_MESSAGE_TOO_BIG:
+			stat = DEV_BAD_MESSAGE;
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	return stat;
+}
+static inline int
+pad_msg(unsigned char *buffer, int  totalLength, int msgLength)
+{
+	int pad_len;
+	for (pad_len = 0; pad_len < (totalLength - msgLength); pad_len++)
+		if (buffer[pad_len] != 0x00)
+			break;
+	pad_len -= 3; 
+	if (pad_len < 8)
+		return SEN_PAD_ERROR;
+	buffer[0] = 0x00;
+	buffer[1] = 0x02;
+	memcpy(buffer+2, static_pad, pad_len);
+	buffer[pad_len + 2] = 0x00;
+	return 0;
+}
+static inline int
+is_common_public_key(unsigned char *key, int len)
+{
+	int i;
+	for (i = 0; i < len; i++)
+		if (key[i])
+			break;
+	key += i;
+	len -= i;
+	if (((len == 1) && (key[0] == 3)) ||
+	    ((len == 3) && (key[0] == 1) && (key[1] == 0) && (key[2] == 1)))
+		return 1;
+	return 0;
+}
+static int
+ICAMEX_msg_to_type4MEX_msg(struct ica_rsa_modexpo *icaMex_p, int *z90cMsg_l_p,
+			   union type4_msg *z90cMsg_p)
+{
+	int mod_len, msg_size, mod_tgt_len, exp_tgt_len, inp_tgt_len;
+	unsigned char *mod_tgt, *exp_tgt, *inp_tgt;
+	union type4_msg *tmp_type4_msg;
+	mod_len = icaMex_p->inputdatalength;
+	msg_size = ((mod_len <= 128) ? TYPE4_SME_LEN : TYPE4_LME_LEN) +
+		    CALLER_HEADER;
+	memset(z90cMsg_p, 0, msg_size);
+	tmp_type4_msg = (union type4_msg *)
+		((unsigned char *) z90cMsg_p + CALLER_HEADER);
+	tmp_type4_msg->sme.header.msg_type_code = TYPE4_TYPE_CODE;
+	tmp_type4_msg->sme.header.request_code = TYPE4_REQU_CODE;
+	if (mod_len <= 128) {
+		tmp_type4_msg->sme.header.msg_fmt = TYPE4_SME_FMT;
+		tmp_type4_msg->sme.header.msg_len = TYPE4_SME_LEN;
+		mod_tgt = tmp_type4_msg->sme.modulus;
+		mod_tgt_len = sizeof(tmp_type4_msg->sme.modulus);
+		exp_tgt = tmp_type4_msg->sme.exponent;
+		exp_tgt_len = sizeof(tmp_type4_msg->sme.exponent);
+		inp_tgt = tmp_type4_msg->sme.message;
+		inp_tgt_len = sizeof(tmp_type4_msg->sme.message);
+	} else {
+		tmp_type4_msg->lme.header.msg_fmt = TYPE4_LME_FMT;
+		tmp_type4_msg->lme.header.msg_len = TYPE4_LME_LEN;
+		mod_tgt = tmp_type4_msg->lme.modulus;
+		mod_tgt_len = sizeof(tmp_type4_msg->lme.modulus);
+		exp_tgt = tmp_type4_msg->lme.exponent;
+		exp_tgt_len = sizeof(tmp_type4_msg->lme.exponent);
+		inp_tgt = tmp_type4_msg->lme.message;
+		inp_tgt_len = sizeof(tmp_type4_msg->lme.message);
+	}
+	mod_tgt += (mod_tgt_len - mod_len);
+	if (copy_from_user(mod_tgt, icaMex_p->n_modulus, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(mod_tgt, mod_len))
+		return SEN_USER_ERROR;
+	exp_tgt += (exp_tgt_len - mod_len);
+	if (copy_from_user(exp_tgt, icaMex_p->b_key, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(exp_tgt, mod_len))
+		return SEN_USER_ERROR;
+	inp_tgt += (inp_tgt_len - mod_len);
+	if (copy_from_user(inp_tgt, icaMex_p->inputdata, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(inp_tgt, mod_len))
+		return SEN_USER_ERROR;
+	*z90cMsg_l_p = msg_size - CALLER_HEADER;
+	return 0;
+}
+static int
+ICACRT_msg_to_type4CRT_msg(struct ica_rsa_modexpo_crt *icaMsg_p,
+			   int *z90cMsg_l_p, union type4_msg *z90cMsg_p)
+{
+	int mod_len, short_len, long_len, tmp_size, p_tgt_len, q_tgt_len,
+	    dp_tgt_len, dq_tgt_len, u_tgt_len, inp_tgt_len;
+	unsigned char *p_tgt, *q_tgt, *dp_tgt, *dq_tgt, *u_tgt, *inp_tgt;
+	union type4_msg *tmp_type4_msg;
+	mod_len = icaMsg_p->inputdatalength;
+	short_len = mod_len / 2;
+	long_len = mod_len / 2 + 8;
+	tmp_size = ((mod_len <= 128) ? TYPE4_SCR_LEN : TYPE4_LCR_LEN) +
+		    CALLER_HEADER;
+	memset(z90cMsg_p, 0, tmp_size);
+	tmp_type4_msg = (union type4_msg *)
+		((unsigned char *) z90cMsg_p + CALLER_HEADER);
+	tmp_type4_msg->scr.header.msg_type_code = TYPE4_TYPE_CODE;
+	tmp_type4_msg->scr.header.request_code = TYPE4_REQU_CODE;
+	if (mod_len <= 128) {
+		tmp_type4_msg->scr.header.msg_fmt = TYPE4_SCR_FMT;
+		tmp_type4_msg->scr.header.msg_len = TYPE4_SCR_LEN;
+		p_tgt = tmp_type4_msg->scr.p;
+		p_tgt_len = sizeof(tmp_type4_msg->scr.p);
+		q_tgt = tmp_type4_msg->scr.q;
+		q_tgt_len = sizeof(tmp_type4_msg->scr.q);
+		dp_tgt = tmp_type4_msg->scr.dp;
+		dp_tgt_len = sizeof(tmp_type4_msg->scr.dp);
+		dq_tgt = tmp_type4_msg->scr.dq;
+		dq_tgt_len = sizeof(tmp_type4_msg->scr.dq);
+		u_tgt = tmp_type4_msg->scr.u;
+		u_tgt_len = sizeof(tmp_type4_msg->scr.u);
+		inp_tgt = tmp_type4_msg->scr.message;
+		inp_tgt_len = sizeof(tmp_type4_msg->scr.message);
+	} else {
+		tmp_type4_msg->lcr.header.msg_fmt = TYPE4_LCR_FMT;
+		tmp_type4_msg->lcr.header.msg_len = TYPE4_LCR_LEN;
+		p_tgt = tmp_type4_msg->lcr.p;
+		p_tgt_len = sizeof(tmp_type4_msg->lcr.p);
+		q_tgt = tmp_type4_msg->lcr.q;
+		q_tgt_len = sizeof(tmp_type4_msg->lcr.q);
+		dp_tgt = tmp_type4_msg->lcr.dp;
+		dp_tgt_len = sizeof(tmp_type4_msg->lcr.dp);
+		dq_tgt = tmp_type4_msg->lcr.dq;
+		dq_tgt_len = sizeof(tmp_type4_msg->lcr.dq);
+		u_tgt = tmp_type4_msg->lcr.u;
+		u_tgt_len = sizeof(tmp_type4_msg->lcr.u);
+		inp_tgt = tmp_type4_msg->lcr.message;
+		inp_tgt_len = sizeof(tmp_type4_msg->lcr.message);
+	}
+	p_tgt += (p_tgt_len - long_len);
+	if (copy_from_user(p_tgt, icaMsg_p->np_prime, long_len))
+		return SEN_RELEASED;
+	if (is_empty(p_tgt, long_len))
+		return SEN_USER_ERROR;
+	q_tgt += (q_tgt_len - short_len);
+	if (copy_from_user(q_tgt, icaMsg_p->nq_prime, short_len))
+		return SEN_RELEASED;
+	if (is_empty(q_tgt, short_len))
+		return SEN_USER_ERROR;
+	dp_tgt += (dp_tgt_len - long_len);
+	if (copy_from_user(dp_tgt, icaMsg_p->bp_key, long_len))
+		return SEN_RELEASED;
+	if (is_empty(dp_tgt, long_len))
+		return SEN_USER_ERROR;
+	dq_tgt += (dq_tgt_len - short_len);
+	if (copy_from_user(dq_tgt, icaMsg_p->bq_key, short_len))
+		return SEN_RELEASED;
+	if (is_empty(dq_tgt, short_len))
+		return SEN_USER_ERROR;
+	u_tgt += (u_tgt_len - long_len);
+	if (copy_from_user(u_tgt, icaMsg_p->u_mult_inv, long_len))
+		return SEN_RELEASED;
+	if (is_empty(u_tgt, long_len))
+		return SEN_USER_ERROR;
+	inp_tgt += (inp_tgt_len - mod_len);
+	if (copy_from_user(inp_tgt, icaMsg_p->inputdata, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(inp_tgt, mod_len))
+		return SEN_USER_ERROR;
+	*z90cMsg_l_p = tmp_size - CALLER_HEADER;
+	return 0;
+}
+static int
+ICAMEX_msg_to_type6MEX_de_msg(struct ica_rsa_modexpo *icaMsg_p, int cdx,
+			      int *z90cMsg_l_p, struct type6_msg *z90cMsg_p)
+{
+	int mod_len, vud_len, tmp_size, total_CPRB_len, parmBlock_l;
+	unsigned char *temp;
+	struct type6_hdr *tp6Hdr_p;
+	struct CPRB *cprb_p;
+	struct cca_private_ext_ME *key_p;
+	mod_len = icaMsg_p->inputdatalength;
+	tmp_size = FIXED_TYPE6_ME_LEN + mod_len;
+	total_CPRB_len = tmp_size - sizeof(struct type6_hdr);
+	parmBlock_l = total_CPRB_len - sizeof(struct CPRB);
+	tmp_size = 4*((tmp_size + 3)/4) + CALLER_HEADER;
+	memset(z90cMsg_p, 0, tmp_size);
+	
+	temp = (unsigned char *)z90cMsg_p + CALLER_HEADER;
+	memcpy(temp, &static_type6_hdr, sizeof(struct type6_hdr));
+	tp6Hdr_p = (struct type6_hdr *)temp;
+	tp6Hdr_p->ToCardLen1 = 4*((total_CPRB_len+3)/4);
+	tp6Hdr_p->FromCardLen1 = RESPONSE_CPRB_SIZE;
+	
+	temp += sizeof(struct type6_hdr);
+	memcpy(temp, &static_cprb, sizeof(struct CPRB));
+	cprb_p = (struct CPRB *) temp;
+	cprb_p->usage_domain[0]= (unsigned char)cdx;
+	itoLe2(&parmBlock_l, cprb_p->req_parml);
+	itoLe2((int *)&(tp6Hdr_p->FromCardLen1), cprb_p->rpl_parml);
+	
+	temp += sizeof(struct CPRB);
+	memcpy(temp, &static_pkd_function_and_rules,
+	       sizeof(struct function_and_rules_block));
+	
+	temp += sizeof(struct function_and_rules_block);
+	vud_len = 2 + icaMsg_p->inputdatalength;
+	itoLe2(&vud_len, temp); 
+	
+	temp += 2;
+	if (copy_from_user(temp, icaMsg_p->inputdata, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(temp, mod_len))
+		return SEN_USER_ERROR;
+	
+	temp += mod_len;
+	memcpy(temp, &static_T6_keyBlock_hdr, sizeof(struct T6_keyBlock_hdr));
+	
+	temp += sizeof(struct T6_keyBlock_hdr);
+	memcpy(temp, &static_pvt_me_key, sizeof(struct cca_private_ext_ME));
+	key_p = (struct cca_private_ext_ME *)temp;
+	temp = key_p->pvtMESec.exponent + sizeof(key_p->pvtMESec.exponent)
+	       - mod_len;
+	if (copy_from_user(temp, icaMsg_p->b_key, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(temp, mod_len))
+		return SEN_USER_ERROR;
+	if (is_common_public_key(temp, mod_len)) {
+		PRINTK("Common public key used for modex decrypt\n");
+		return SEN_NOT_AVAIL;
+	}
+	temp = key_p->pvtMESec.modulus + sizeof(key_p->pvtMESec.modulus)
+	       - mod_len;
+	if (copy_from_user(temp, icaMsg_p->n_modulus, mod_len) != 0)
+		return SEN_RELEASED;
+	if (is_empty(temp, mod_len))
+		return SEN_USER_ERROR;
+	
+	key_p->pubMESec.modulus_bit_len = 8 * mod_len;
+	*z90cMsg_l_p = tmp_size - CALLER_HEADER;
+	return 0;
+}
+static int
+ICAMEX_msg_to_type6MEX_en_msg(struct ica_rsa_modexpo *icaMsg_p, int cdx,
+			      int *z90cMsg_l_p, struct type6_msg *z90cMsg_p)
+{
+	int mod_len, vud_len, exp_len, key_len;
+	int pad_len, tmp_size, total_CPRB_len, parmBlock_l, i;
+	unsigned char temp_exp[256], *exp_p, *temp;
+	struct type6_hdr *tp6Hdr_p;
+	struct CPRB *cprb_p;
+	struct cca_public_key *key_p;
+	struct T6_keyBlock_hdr *keyb_p;
+	mod_len = icaMsg_p->inputdatalength;
+	if (copy_from_user(temp_exp, icaMsg_p->b_key, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(temp_exp, mod_len))
+		return SEN_USER_ERROR;
+	exp_p = temp_exp;
+	for (i = 0; i < mod_len; i++)
+		if (exp_p[i])
+			break;
+	if (i >= mod_len)
+		return SEN_USER_ERROR;
+	exp_len = mod_len - i;
+	exp_p += i;
+	PDEBUG("exp_len after computation: %08x\n", exp_len);
+	tmp_size = FIXED_TYPE6_ME_EN_LEN + 2 * mod_len + exp_len;
+	total_CPRB_len = tmp_size - sizeof(struct type6_hdr);
+	parmBlock_l = total_CPRB_len - sizeof(struct CPRB);
+	tmp_size = 4*((tmp_size + 3)/4) + CALLER_HEADER;
+	vud_len = 2 + mod_len;
+	memset(z90cMsg_p, 0, tmp_size);
+	
+	temp = (unsigned char *)z90cMsg_p + CALLER_HEADER;
+	memcpy(temp, &static_type6_hdr, sizeof(struct type6_hdr));
+	tp6Hdr_p = (struct type6_hdr *)temp;
+	tp6Hdr_p->ToCardLen1 = 4*((total_CPRB_len+3)/4);
+	tp6Hdr_p->FromCardLen1 = RESPONSE_CPRB_SIZE;
+	memcpy(tp6Hdr_p->function_code, static_PKE_function_code,
+	       sizeof(static_PKE_function_code));
+	
+	temp += sizeof(struct type6_hdr);
+	memcpy(temp, &static_cprb, sizeof(struct CPRB));
+	cprb_p = (struct CPRB *) temp;
+	cprb_p->usage_domain[0]= (unsigned char)cdx;
+	itoLe2((int *)&(tp6Hdr_p->FromCardLen1), cprb_p->rpl_parml);
+	
+	temp += sizeof(struct CPRB);
+	memcpy(temp, &static_pke_function_and_rules,
+		 sizeof(struct function_and_rules_block));
+	
+	temp += sizeof(struct function_and_rules_block);
+	temp += 2;
+	if (copy_from_user(temp, icaMsg_p->inputdata, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(temp, mod_len))
+		return SEN_USER_ERROR;
+	
+	if (temp[0] != 0x00 || temp[1] != 0x02)
+		return SEN_NOT_AVAIL;
+	for (i = 2; i < mod_len; i++)
+		if (temp[i] == 0x00)
+			break;
+	if ((i < 9) || (i > (mod_len - 2)))
+		return SEN_NOT_AVAIL;
+	pad_len = i + 1;
+	vud_len = mod_len - pad_len;
+	memmove(temp, temp+pad_len, vud_len);
+	
+	temp -= 2;
+	vud_len += 2;
+	itoLe2(&vud_len, temp);
+	
+	temp += (vud_len);
+	keyb_p = (struct T6_keyBlock_hdr *)temp;
+	
+	temp += sizeof(struct T6_keyBlock_hdr);
+	memcpy(temp, &static_public_key, sizeof(static_public_key));
+	key_p = (struct cca_public_key *)temp;
+	temp = key_p->pubSec.exponent;
+	memcpy(temp, exp_p, exp_len);
+	temp += exp_len;
+	if (copy_from_user(temp, icaMsg_p->n_modulus, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(temp, mod_len))
+		return SEN_USER_ERROR;
+	key_p->pubSec.modulus_bit_len = 8 * mod_len;
+	key_p->pubSec.modulus_byte_len = mod_len;
+	key_p->pubSec.exponent_len = exp_len;
+	key_p->pubSec.section_length = 12 + mod_len + exp_len;
+	key_len = key_p->pubSec.section_length + sizeof(struct cca_token_hdr);
+	key_p->pubHdr.token_length = key_len;
+	key_len += 4;
+	itoLe2(&key_len, keyb_p->ulen);
+	key_len += 2;
+	itoLe2(&key_len, keyb_p->blen);
+	parmBlock_l -= pad_len;
+	itoLe2(&parmBlock_l, cprb_p->req_parml);
+	*z90cMsg_l_p = tmp_size - CALLER_HEADER;
+	return 0;
+}
+static int
+ICACRT_msg_to_type6CRT_msg(struct ica_rsa_modexpo_crt *icaMsg_p, int cdx,
+			   int *z90cMsg_l_p, struct type6_msg *z90cMsg_p)
+{
+	int mod_len, vud_len, tmp_size, total_CPRB_len, parmBlock_l, short_len;
+	int long_len, pad_len, keyPartsLen, tmp_l;
+	unsigned char *tgt_p, *temp;
+	struct type6_hdr *tp6Hdr_p;
+	struct CPRB *cprb_p;
+	struct cca_token_hdr *keyHdr_p;
+	struct cca_pvt_ext_CRT_sec *pvtSec_p;
+	struct cca_public_sec *pubSec_p;
+	mod_len = icaMsg_p->inputdatalength;
+	short_len = mod_len / 2;
+	long_len = 8 + short_len;
+	keyPartsLen = 3 * long_len + 2 * short_len;
+	pad_len = (8 - (keyPartsLen % 8)) % 8;
+	keyPartsLen += pad_len + mod_len;
+	tmp_size = FIXED_TYPE6_CR_LEN + keyPartsLen + mod_len;
+	total_CPRB_len = tmp_size -  sizeof(struct type6_hdr);
+	parmBlock_l = total_CPRB_len - sizeof(struct CPRB);
+	vud_len = 2 + mod_len;	   
+	tmp_size = 4*((tmp_size + 3)/4) + CALLER_HEADER;
+	memset(z90cMsg_p, 0, tmp_size);
+	
+	tgt_p = (unsigned char *)z90cMsg_p + CALLER_HEADER;
+	memcpy(tgt_p, &static_type6_hdr, sizeof(struct type6_hdr));
+	tp6Hdr_p = (struct type6_hdr *)tgt_p;
+	tp6Hdr_p->ToCardLen1 = 4*((total_CPRB_len+3)/4);
+	tp6Hdr_p->FromCardLen1 = RESPONSE_CPRB_SIZE;
+	
+	tgt_p += sizeof(struct type6_hdr);
+	cprb_p = (struct CPRB *) tgt_p;
+	memcpy(tgt_p, &static_cprb, sizeof(struct CPRB));
+	cprb_p->usage_domain[0]= *((unsigned char *)(&(cdx))+3);
+	itoLe2(&parmBlock_l, cprb_p->req_parml);
+	memcpy(cprb_p->rpl_parml, cprb_p->req_parml,
+	       sizeof(cprb_p->req_parml));
+	
+	tgt_p += sizeof(struct CPRB);
+	memcpy(tgt_p, &static_pkd_function_and_rules,
+	       sizeof(struct function_and_rules_block));
+	
+	tgt_p += sizeof(struct function_and_rules_block);
+	itoLe2(&vud_len, tgt_p);
+	
+	tgt_p += 2;
+	if (copy_from_user(tgt_p, icaMsg_p->inputdata, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, mod_len))
+		return SEN_USER_ERROR;
+	
+	tgt_p += mod_len;
+	tmp_l = sizeof(struct T6_keyBlock_hdr) + sizeof(struct cca_token_hdr) +
+		sizeof(struct cca_pvt_ext_CRT_sec) + 0x0F + keyPartsLen;
+	itoLe2(&tmp_l, tgt_p);
+	
+	temp = tgt_p + 2;
+	tmp_l -= 2;
+	itoLe2(&tmp_l, temp);
+	
+	tgt_p += sizeof(struct T6_keyBlock_hdr);
+	keyHdr_p = (struct cca_token_hdr *)tgt_p;
+	keyHdr_p->token_identifier = CCA_TKN_HDR_ID_EXT;
+	tmp_l -= 4;
+	keyHdr_p->token_length = tmp_l;
+	
+	tgt_p += sizeof(struct cca_token_hdr);
+	pvtSec_p = (struct cca_pvt_ext_CRT_sec *)tgt_p;
+	pvtSec_p->section_identifier = CCA_PVT_EXT_CRT_SEC_ID_PVT;
+	pvtSec_p->section_length = 
+		sizeof(struct cca_pvt_ext_CRT_sec) + keyPartsLen;
+	pvtSec_p->key_format = CCA_PVT_EXT_CRT_SEC_FMT_CL;
+	pvtSec_p->key_use_flags[0] = CCA_PVT_USAGE_ALL;
+	pvtSec_p->p_len = long_len;
+	pvtSec_p->q_len = short_len;
+	pvtSec_p->dp_len = long_len;
+	pvtSec_p->dq_len = short_len;
+	pvtSec_p->u_len = long_len;
+	pvtSec_p->mod_len = mod_len;
+	pvtSec_p->pad_len = pad_len;
+	
+	tgt_p += sizeof(struct cca_pvt_ext_CRT_sec);
+	if (copy_from_user(tgt_p, icaMsg_p->np_prime, long_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, long_len))
+		return SEN_USER_ERROR;
+	tgt_p += long_len;
+	if (copy_from_user(tgt_p, icaMsg_p->nq_prime, short_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, short_len))
+		return SEN_USER_ERROR;
+	tgt_p += short_len;
+	if (copy_from_user(tgt_p, icaMsg_p->bp_key, long_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, long_len))
+		return SEN_USER_ERROR;
+	tgt_p += long_len;
+	if (copy_from_user(tgt_p, icaMsg_p->bq_key, short_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, short_len))
+		return SEN_USER_ERROR;
+	tgt_p += short_len;
+	if (copy_from_user(tgt_p, icaMsg_p->u_mult_inv, long_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, long_len))
+		return SEN_USER_ERROR;
+	tgt_p += long_len;
+	tgt_p += pad_len;
+	memset(tgt_p, 0xFF, mod_len);
+	
+	tgt_p += mod_len;
+	memcpy(tgt_p, &static_cca_pub_sec, sizeof(struct cca_public_sec));
+	pubSec_p = (struct cca_public_sec *) tgt_p;
+	pubSec_p->modulus_bit_len = 8 * mod_len;
+	*z90cMsg_l_p = tmp_size - CALLER_HEADER;
+	return 0;
+}
+static int
+ICAMEX_msg_to_type6MEX_de_msgX(struct ica_rsa_modexpo *icaMsg_p, int cdx,
+			       int *z90cMsg_l_p, struct type6_msg *z90cMsg_p)
+{
+	int mod_len, vud_len, tmp_size, total_CPRB_len, parmBlock_l;
+	unsigned char *tgt_p, *temp;
+	struct type6_hdr *tp6Hdr_p;
+	struct CPRBX *cprbx_p;
+	struct cca_private_ext_ME *key_p;
+	mod_len = icaMsg_p->inputdatalength;
+	tmp_size = FIXED_TYPE6_ME_LENX + mod_len;
+	total_CPRB_len = tmp_size - sizeof(struct type6_hdr);
+	parmBlock_l = total_CPRB_len - sizeof(struct CPRBX);
+	tmp_size += CALLER_HEADER;
+	vud_len = 2 + mod_len;
+	memset(z90cMsg_p, 0, tmp_size);
+	
+	tgt_p = (unsigned char *)z90cMsg_p + CALLER_HEADER;
+	memcpy(tgt_p, &static_type6_hdrX, sizeof(struct type6_hdr));
+	tp6Hdr_p = (struct type6_hdr *)tgt_p;
+	tp6Hdr_p->ToCardLen1 = total_CPRB_len;
+	tp6Hdr_p->FromCardLen1 = RESPONSE_CPRBX_SIZE;
+	
+	tgt_p += sizeof(struct type6_hdr);
+	memcpy(tgt_p, &static_cprbx, sizeof(struct CPRBX));
+	cprbx_p = (struct CPRBX *) tgt_p;
+	cprbx_p->domain = (unsigned short)cdx;
+	cprbx_p->req_parml = parmBlock_l;
+	cprbx_p->rpl_msgbl = RESPONSE_CPRBX_SIZE;
+	
+	tgt_p += sizeof(struct CPRBX);
+	memcpy(tgt_p, &static_pkd_function_and_rulesX,
+	       sizeof(struct function_and_rules_block));
+	
+	tgt_p += sizeof(struct function_and_rules_block);
+	*((short *)tgt_p) = (short) vud_len;
+	
+	tgt_p += 2;
+	if (copy_from_user(tgt_p, icaMsg_p->inputdata, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, mod_len))
+		return SEN_USER_ERROR;
+	
+	tgt_p += mod_len;
+	memcpy(tgt_p, &static_T6_keyBlock_hdrX,
+	       sizeof(struct T6_keyBlock_hdrX));
+	
+	tgt_p += sizeof(struct T6_keyBlock_hdrX);
+	memcpy(tgt_p, &static_pvt_me_key,
+	       sizeof(struct cca_private_ext_ME));
+	key_p = (struct cca_private_ext_ME *)tgt_p;
+	temp = key_p->pvtMESec.exponent + sizeof(key_p->pvtMESec.exponent) -
+	       mod_len;
+	if (copy_from_user(temp, icaMsg_p->b_key, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(temp, mod_len))
+		return SEN_USER_ERROR;
+	
+	if (is_common_public_key(temp, mod_len)) {
+		PRINTK("Common public key used for modex decrypt\n");
+		return SEN_NOT_AVAIL;
+	}
+	temp = key_p->pvtMESec.modulus + sizeof(key_p->pvtMESec.modulus) -
+	       mod_len;
+	if (copy_from_user(temp, icaMsg_p->n_modulus, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(temp, mod_len))
+		return SEN_USER_ERROR;
+	key_p->pubMESec.modulus_bit_len = 8 * mod_len;
+	*z90cMsg_l_p = tmp_size - CALLER_HEADER;
+	return 0;
+}
+static int
+ICAMEX_msg_to_type6MEX_en_msgX(struct ica_rsa_modexpo *icaMsg_p, int cdx,
+			       int *z90cMsg_l_p, struct type6_msg *z90cMsg_p)
+{
+	int mod_len, exp_len, vud_len, tmp_size, total_CPRB_len, parmBlock_l;
+	int key_len, i;
+	unsigned char temp_exp[256], *tgt_p, *temp, *exp_p;
+	struct type6_hdr *tp6Hdr_p;
+	struct CPRBX *cprbx_p;
+	struct cca_public_key *key_p;
+	struct T6_keyBlock_hdrX *keyb_p;
+	mod_len = icaMsg_p->inputdatalength;
+	if (copy_from_user(temp_exp, icaMsg_p->b_key, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(temp_exp, mod_len))
+		return SEN_USER_ERROR;
+	exp_p = temp_exp;
+	for (i = 0; i < mod_len; i++)
+		if (exp_p[i])
+			break;
+	if (i >= mod_len)
+		return SEN_USER_ERROR;
+	exp_len = mod_len - i;
+	exp_p += i;
+	PDEBUG("exp_len after computation: %08x\n", exp_len);
+	tmp_size = FIXED_TYPE6_ME_EN_LENX + 2 * mod_len + exp_len;
+	total_CPRB_len = tmp_size - sizeof(struct type6_hdr);
+	parmBlock_l = total_CPRB_len - sizeof(struct CPRBX);
+	tmp_size = tmp_size + CALLER_HEADER;
+	vud_len = 2 + mod_len;
+	memset(z90cMsg_p, 0, tmp_size);
+	
+	tgt_p = (unsigned char *)z90cMsg_p + CALLER_HEADER;
+	memcpy(tgt_p, &static_type6_hdrX, sizeof(struct type6_hdr));
+	tp6Hdr_p = (struct type6_hdr *)tgt_p;
+	tp6Hdr_p->ToCardLen1 = total_CPRB_len;
+	tp6Hdr_p->FromCardLen1 = RESPONSE_CPRBX_SIZE;
+	memcpy(tp6Hdr_p->function_code, static_PKE_function_code,
+	       sizeof(static_PKE_function_code));
+	
+	tgt_p += sizeof(struct type6_hdr);
+	memcpy(tgt_p, &static_cprbx, sizeof(struct CPRBX));
+	cprbx_p = (struct CPRBX *) tgt_p;
+	cprbx_p->domain = (unsigned short)cdx;
+	cprbx_p->rpl_msgbl = RESPONSE_CPRBX_SIZE;
+	
+	tgt_p += sizeof(struct CPRBX);
+	memcpy(tgt_p, &static_pke_function_and_rulesX,
+	       sizeof(struct function_and_rules_block));
+	
+	tgt_p += sizeof(struct function_and_rules_block);
+	
+	tgt_p += 2;
+	if (copy_from_user(tgt_p, icaMsg_p->inputdata, mod_len))
+	      return SEN_RELEASED;
+	if (is_empty(tgt_p, mod_len))
+	      return SEN_USER_ERROR;
+	
+	tgt_p -= 2;
+	*((short *)tgt_p) = (short) vud_len;
+	tgt_p += vud_len;
+	keyb_p = (struct T6_keyBlock_hdrX *)tgt_p;
+	
+	tgt_p += sizeof(struct T6_keyBlock_hdrX);
+	memcpy(tgt_p, &static_public_key, sizeof(static_public_key));
+	key_p = (struct cca_public_key *)tgt_p;
+	temp = key_p->pubSec.exponent;
+	memcpy(temp, exp_p, exp_len);
+	temp += exp_len;
+	if (copy_from_user(temp, icaMsg_p->n_modulus, mod_len))
+	      return SEN_RELEASED;
+	if (is_empty(temp, mod_len))
+	      return SEN_USER_ERROR;
+	key_p->pubSec.modulus_bit_len = 8 * mod_len;
+	key_p->pubSec.modulus_byte_len = mod_len;
+	key_p->pubSec.exponent_len = exp_len;
+	key_p->pubSec.section_length = 12 + mod_len + exp_len;
+	key_len = key_p->pubSec.section_length + sizeof(struct cca_token_hdr);
+	key_p->pubHdr.token_length = key_len;
+	key_len += 4;
+	keyb_p->ulen = (unsigned short)key_len;
+	key_len += 2;
+	keyb_p->blen = (unsigned short)key_len;
+	cprbx_p->req_parml = parmBlock_l;
+	*z90cMsg_l_p = tmp_size - CALLER_HEADER;
+	return 0;
+}
+static int
+ICACRT_msg_to_type6CRT_msgX(struct ica_rsa_modexpo_crt *icaMsg_p, int cdx,
+			    int *z90cMsg_l_p, struct type6_msg *z90cMsg_p)
+{
+	int mod_len, vud_len, tmp_size, total_CPRB_len, parmBlock_l, short_len;
+	int long_len, pad_len, keyPartsLen, tmp_l;
+	unsigned char *tgt_p, *temp;
+	struct type6_hdr *tp6Hdr_p;
+	struct CPRBX *cprbx_p;
+	struct cca_token_hdr *keyHdr_p;
+	struct cca_pvt_ext_CRT_sec *pvtSec_p;
+	struct cca_public_sec *pubSec_p;
+	mod_len = icaMsg_p->inputdatalength;
+	short_len = mod_len / 2;
+	long_len = 8 + short_len;
+	keyPartsLen = 3 * long_len + 2 * short_len;
+	pad_len = (8 - (keyPartsLen % 8)) % 8;
+	keyPartsLen += pad_len + mod_len;
+	tmp_size = FIXED_TYPE6_CR_LENX + keyPartsLen + mod_len;
+	total_CPRB_len = tmp_size -  sizeof(struct type6_hdr);
+	parmBlock_l = total_CPRB_len - sizeof(struct CPRBX);
+	vud_len = 2 + mod_len;
+	tmp_size = tmp_size + CALLER_HEADER;
+	memset(z90cMsg_p, 0, tmp_size);
+	
+	tgt_p = (unsigned char *)z90cMsg_p + CALLER_HEADER;
+	memcpy(tgt_p, &static_type6_hdrX, sizeof(struct type6_hdr));
+	tp6Hdr_p = (struct type6_hdr *)tgt_p;
+	tp6Hdr_p->ToCardLen1 = total_CPRB_len;
+	tp6Hdr_p->FromCardLen1 = RESPONSE_CPRBX_SIZE;
+	
+	tgt_p += sizeof(struct type6_hdr);
+	cprbx_p = (struct CPRBX *) tgt_p;
+	memcpy(tgt_p, &static_cprbx, sizeof(struct CPRBX));
+	cprbx_p->domain = (unsigned short)cdx;
+	cprbx_p->req_parml = parmBlock_l;
+	cprbx_p->rpl_msgbl = parmBlock_l;
+	
+	tgt_p += sizeof(struct CPRBX);
+	memcpy(tgt_p, &static_pkd_function_and_rulesX,
+	       sizeof(struct function_and_rules_block));
+	
+	tgt_p += sizeof(struct function_and_rules_block);
+	*((short *)tgt_p) = (short) vud_len;
+	
+	tgt_p += 2;
+	if (copy_from_user(tgt_p, icaMsg_p->inputdata, mod_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, mod_len))
+		return SEN_USER_ERROR;
+	
+	tgt_p += mod_len;
+	tmp_l = sizeof(struct T6_keyBlock_hdr) + sizeof(struct cca_token_hdr) +
+		sizeof(struct cca_pvt_ext_CRT_sec) + 0x0F + keyPartsLen;
+	*((short *)tgt_p) = (short) tmp_l;
+	temp = tgt_p + 2;
+	tmp_l -= 2;
+	*((short *)temp) = (short) tmp_l;
+	
+	tgt_p += sizeof(struct T6_keyBlock_hdr);
+	keyHdr_p = (struct cca_token_hdr *)tgt_p;
+	keyHdr_p->token_identifier = CCA_TKN_HDR_ID_EXT;
+	tmp_l -= 4;
+	keyHdr_p->token_length = tmp_l;
+	
+	tgt_p += sizeof(struct cca_token_hdr);
+	pvtSec_p = (struct cca_pvt_ext_CRT_sec *)tgt_p;
+	pvtSec_p->section_identifier = CCA_PVT_EXT_CRT_SEC_ID_PVT;
+	pvtSec_p->section_length =
+		sizeof(struct cca_pvt_ext_CRT_sec) + keyPartsLen;
+	pvtSec_p->key_format = CCA_PVT_EXT_CRT_SEC_FMT_CL;
+	pvtSec_p->key_use_flags[0] = CCA_PVT_USAGE_ALL;
+	pvtSec_p->p_len = long_len;
+	pvtSec_p->q_len = short_len;
+	pvtSec_p->dp_len = long_len;
+	pvtSec_p->dq_len = short_len;
+	pvtSec_p->u_len = long_len;
+	pvtSec_p->mod_len = mod_len;
+	pvtSec_p->pad_len = pad_len;
+	
+	tgt_p += sizeof(struct cca_pvt_ext_CRT_sec);
+	if (copy_from_user(tgt_p, icaMsg_p->np_prime, long_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, long_len))
+		return SEN_USER_ERROR;
+	tgt_p += long_len;
+	if (copy_from_user(tgt_p, icaMsg_p->nq_prime, short_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, short_len))
+		return SEN_USER_ERROR;
+	tgt_p += short_len;
+	if (copy_from_user(tgt_p, icaMsg_p->bp_key, long_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, long_len))
+		return SEN_USER_ERROR;
+	tgt_p += long_len;
+	if (copy_from_user(tgt_p, icaMsg_p->bq_key, short_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, short_len))
+		return SEN_USER_ERROR;
+	tgt_p += short_len;
+	if (copy_from_user(tgt_p, icaMsg_p->u_mult_inv, long_len))
+		return SEN_RELEASED;
+	if (is_empty(tgt_p, long_len))
+		return SEN_USER_ERROR;
+	tgt_p += long_len;
+	tgt_p += pad_len;
+	memset(tgt_p, 0xFF, mod_len);
+	
+	tgt_p += mod_len;
+	memcpy(tgt_p, &static_cca_pub_sec, sizeof(struct cca_public_sec));
+	pubSec_p = (struct cca_public_sec *) tgt_p;
+	pubSec_p->modulus_bit_len = 8 * mod_len;
+	*z90cMsg_l_p = tmp_size - CALLER_HEADER;
+	return 0;
+}
+int
+convert_request(unsigned char *buffer, int func, unsigned short function,
+		int cdx, int dev_type, int *msg_l_p, unsigned char *msg_p)
+{
+	if (dev_type == PCICA) {
+		if (func == ICARSACRT)
+			return ICACRT_msg_to_type4CRT_msg(
+				(struct ica_rsa_modexpo_crt *) buffer,
+				msg_l_p, (union type4_msg *) msg_p);
+		else
+			return ICAMEX_msg_to_type4MEX_msg(
+				(struct ica_rsa_modexpo *) buffer,
+				msg_l_p, (union type4_msg *) msg_p);
+	}
+	if (dev_type == PCICC) {
+		if (func == ICARSACRT)
+			return ICACRT_msg_to_type6CRT_msg(
+				(struct ica_rsa_modexpo_crt *) buffer,
+				cdx, msg_l_p, (struct type6_msg *)msg_p);
+		if (function == PCI_FUNC_KEY_ENCRYPT)
+			return ICAMEX_msg_to_type6MEX_en_msg(
+				(struct ica_rsa_modexpo *) buffer,
+				cdx, msg_l_p, (struct type6_msg *) msg_p);
+		else
+			return ICAMEX_msg_to_type6MEX_de_msg(
+				(struct ica_rsa_modexpo *) buffer,
+				cdx, msg_l_p, (struct type6_msg *) msg_p);
+	}
+	if (dev_type == PCIXCC) {
+		if (func == ICARSACRT)
+			return ICACRT_msg_to_type6CRT_msgX(
+				(struct ica_rsa_modexpo_crt *) buffer,
+				cdx, msg_l_p, (struct type6_msg *) msg_p);
+		if (function == PCI_FUNC_KEY_ENCRYPT)
+			return ICAMEX_msg_to_type6MEX_en_msgX(
+				(struct ica_rsa_modexpo *) buffer,
+				cdx, msg_l_p, (struct type6_msg *) msg_p);
+		else
+			return ICAMEX_msg_to_type6MEX_de_msgX(
+				(struct ica_rsa_modexpo *) buffer,
+				cdx, msg_l_p, (struct type6_msg *) msg_p);
+	}
+	return 0;
+}
+int
+convert_response(unsigned char *response, int dev_type, unsigned char *buffer,
+		 int *respbufflen_p, unsigned char *resp_buff)
+{
+	struct ica_rsa_modexpo *icaMsg_p = (struct ica_rsa_modexpo *) buffer;
+	struct type82_hdr *t82h_p = (struct type82_hdr *) response;
+	struct type84_hdr *t84h_p = (struct type84_hdr *) response;
+	struct type86_hdr *t86h_p = (struct type86_hdr *) response;
+	int rv, reply_code, service_rc, service_rs, src_l;
+	unsigned char *src_p, *tgt_p;
+	struct CPRB *cprb_p;
+	struct CPRBX *cprbx_p;
+	src_p = 0;
+	reply_code = 0;
+	service_rc = 0;
+	service_rs = 0;
+	src_l = 0;
+	rv = 0;
+	switch (t82h_p->type) {
+	case TYPE82_RSP_CODE:
+		reply_code = t82h_p->reply_code;
+		rv = 4; 
+		src_p = (unsigned char *)t82h_p;
+		PRINTK("Hardware error: Type 82 Message Header: "
+		       "%02x%02x%02x%02x%02x%02x%02x%02x\n",
+		       src_p[0], src_p[1], src_p[2], src_p[3],
+		       src_p[4], src_p[5], src_p[6], src_p[7]);
+		break;
+	case TYPE84_RSP_CODE:
+		src_l = icaMsg_p->outputdatalength;
+		src_p = response + (int)t84h_p->len - src_l;
+		break;
+	case TYPE86_RSP_CODE:
+		reply_code = t86h_p->reply_code;
+		if (t86h_p->format != TYPE86_FMT2) {
+			rv = 4;
+			break;
+		}
+		if (reply_code != 0) {
+			rv = 4;
+			break;
+		}
+		cprb_p = (struct CPRB *)
+			(response + sizeof(struct type86_fmt2_msg));
+		cprbx_p = (struct CPRBX *) cprb_p;
+		if (cprb_p->cprb_ver_id != 0x02) {
+			le2toI(cprb_p->ccp_rtcode, &service_rc);
+			if (service_rc != 0) {
+				le2toI(cprb_p->ccp_rscode, &service_rs);
+				PDEBUG("service rc/rc: %d/%d\n",
+				       service_rc, service_rs);
+				rv = 8;
+			}
+			src_p = (unsigned char *)cprb_p + sizeof(struct CPRB);
+			src_p += 4; 
+			le2toI(src_p, &src_l);
+			src_l -= 2;	
+			src_p += 2;	
+		} else {
+			service_rc = (int)cprbx_p->ccp_rtcode;
+			if (service_rc != 0) {
+				service_rs = (int) cprbx_p->ccp_rscode;
+				PRINTK("service rc:%d; service rs:%d\n",
+				       service_rc, service_rs);
+				rv = 8;
+			}
+			src_p = (unsigned char *)
+				cprbx_p + sizeof(struct CPRBX);
+			src_p += 4; 
+			src_l = (int)(*((short *) src_p));
+			src_l -= 2;	
+			src_p += 2;	
+		}
+		break;
+	default:
+		break;
+	}
+	
+	
+	if (rv == 8)
+		return 8;
+	if (rv == 4)
+		switch (reply_code) {
+		case REPLY_ERROR_OPERAND_INVALID:
+			return REC_OPERAND_INV;
+		case REPLY_ERROR_OPERAND_SIZE:
+			return REC_OPERAND_SIZE;
+		case REPLY_ERROR_EVEN_MOD_IN_OPND:
+			return REC_EVEN_MOD;
+		case REPLY_ERROR_MESSAGE_TYPE:
+			return WRONG_DEVICE_TYPE;
+		default:
+			return 12;
+		}
+	
+	if (service_rc != 0)
+		return REC_OPERAND_INV;
+	if ((src_l > icaMsg_p->outputdatalength) ||
+	    (src_l > RESPBUFFSIZE) ||
+	    (src_l <= 0))
+		return REC_OPERAND_SIZE;
+	PDEBUG("Length returned = %d\n", src_l);
+	
+	tgt_p = resp_buff + icaMsg_p->outputdatalength - src_l;
+	memcpy(tgt_p, src_p, src_l);
+	
+	if ((t82h_p->type == TYPE86_RSP_CODE) && (resp_buff < tgt_p)) {
+		memset(resp_buff, 0, icaMsg_p->outputdatalength - src_l);
+		rv = pad_msg(resp_buff, icaMsg_p->outputdatalength, src_l);
+		if (rv != 0)
+			return rv;
+	}
+	*respbufflen_p = icaMsg_p->outputdatalength;
+	if (*respbufflen_p == 0)
+		PRINTK("Zero *respbufflen_p\n");
+	return rv;
+}
diff -urN linux-2.6/drivers/s390/crypto/z90main.c linux-2.6-s390/drivers/s390/crypto/z90main.c
--- linux-2.6/drivers/s390/crypto/z90main.c	Thu Jan  1 01:00:00 1970
+++ linux-2.6-s390/drivers/s390/crypto/z90main.c	Mon Mar  1 16:36:00 2004
@@ -0,0 +1,3125 @@
+/*
+ *  linux/drivers/s390/misc/z90main.c
+ *
+ *  z90crypt 1.3.1
+ *
+ *  Copyright (C)  2001, 2004 IBM Corporation
+ *  Author(s): Robert Burroughs (burrough@us.ibm.com)
+ *	       Eric Rossman (edrossma@us.ibm.com)
+ *
+ *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <asm/uaccess.h>       // copy_(from|to)_user
+#include <linux/compiler.h>
+#include <linux/delay.h>       // mdelay
+#include <linux/interrupt.h>   // for tasklets
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include "z90crypt.h"
+#include "z90common.h"
+#ifndef Z90CRYPT_USE_HOTPLUG
+#include <linux/miscdevice.h>
+#endif
+
+#define VERSION_CODE(vers, rel, seq) (((vers)<<16) | ((rel)<<8) | (seq))
+#if LINUX_VERSION_CODE < VERSION_CODE(2,4,0) /* version < 2.4 */
+#  error "This kernel is too old: not supported"
+#endif
+#if LINUX_VERSION_CODE > VERSION_CODE(2,7,0) /* version > 2.6 */
+#  error "This kernel is too recent: not supported by this file"
+#endif
+
+#define VERSION_Z90MAIN_C "$Revision: 1.15 $"
+
+static const char version[] __attribute_used__ =
+	"z90crypt.o: z90main.o ("
+	"z90main.c "   VERSION_Z90MAIN_C   "/"
+	"z90common.h " VERSION_Z90COMMON_H "/"
+	"z90crypt.h "  VERSION_Z90CRYPT_H  ")";
+
+/**
+ * Defaults that may be modified.
+ */
+
+#ifndef Z90CRYPT_USE_HOTPLUG
+/**
+ * You can specify a different minor at compile time.
+ */
+#ifndef Z90CRYPT_MINOR
+#define Z90CRYPT_MINOR	MISC_DYNAMIC_MINOR
+#endif
+#else
+/**
+ * You can specify a different major at compile time.
+ */
+#ifndef Z90CRYPT_MAJOR
+#define Z90CRYPT_MAJOR	0
+#endif
+#endif
+
+/**
+ * You can specify a different domain at compile time or on the insmod
+ * command line.
+ */
+#ifndef DOMAIN_INDEX
+#define DOMAIN_INDEX	-1
+#endif
+
+/**
+ * This is the name under which the device is registered in /proc/modules.
+ */
+#define REG_NAME	"z90crypt"
+
+/**
+ * Cleanup should run every CLEANUPTIME seconds and should clean up requests
+ * older than CLEANUPTIME seconds in the past.
+ */
+#ifndef CLEANUPTIME
+#define CLEANUPTIME 15
+#endif
+
+/**
+ * Config should run every CONFIGTIME seconds
+ */
+#ifndef CONFIGTIME
+#define CONFIGTIME 30
+#endif
+
+/**
+ * The first execution of the config task should take place
+ * immediately after initialization
+ */
+#ifndef INITIAL_CONFIGTIME
+#define INITIAL_CONFIGTIME 1
+#endif
+
+/**
+ * Reader should run every READERTIME milliseconds
+ */
+#ifndef READERTIME
+#define READERTIME 2
+#endif
+
+/**
+ * turn long device array index into device pointer
+ */
+#define LONG2DEVPTR(ndx) (z90crypt.device_p[(ndx)])
+
+/**
+ * turn short device array index into long device array index
+ */
+#define SHRT2LONG(ndx) (z90crypt.overall_device_x.device_index[(ndx)])
+
+/**
+ * turn short device array index into device pointer
+ */
+#define SHRT2DEVPTR(ndx) LONG2DEVPTR(SHRT2LONG(ndx))
+
+/**
+ * Status for a work-element
+ */
+#define STAT_DEFAULT	0x00 // request has not been processed
+
+#define STAT_ROUTED	0x80 // bit 7: requests get routed to specific device
+			     //	       else, device is determined each write
+#define STAT_FAILED	0x40 // bit 6: this bit is set if the request failed
+			     //	       before being sent to the hardware.
+#define STAT_WRITTEN	0x30 // bits 5-4: work to be done, not sent to device
+#define STAT_QUEUED	0x20 // bits 5-4: work has been sent to a device
+#define STAT_READPEND	0x10 // bits 5-4: work done, we're returning data now
+#define STAT_NOWORK	0x00 // bits off: no work on any queue
+#define STAT_RDWRMASK	0x30 // mask for bits 5-4
+
+/**
+ * Macros to check the status RDWRMASK
+ */
+#define CHK_RDWRMASK(statbyte) ((statbyte) & STAT_RDWRMASK)
+#define SET_RDWRMASK(statbyte, newval) \
+	{(statbyte) &= ~STAT_RDWRMASK; (statbyte) |= newval;}
+
+/**
+ * Audit Trail.	 Progress of a Work element
+ * audit[0]: Unless noted otherwise, these bits are all set by the process
+ */
+#define FP_COPYFROM	0x80 // Caller's buffer has been copied to work element
+#define FP_BUFFREQ	0x40 // Low Level buffer requested
+#define FP_BUFFGOT	0x20 // Low Level buffer obtained
+#define FP_SENT		0x10 // Work element sent to a crypto device
+			     // (may be set by process or by reader task)
+#define FP_PENDING	0x08 // Work element placed on pending queue
+			     // (may be set by process or by reader task)
+#define FP_REQUEST	0x04 // Work element placed on request queue
+#define FP_ASLEEP	0x02 // Work element about to sleep
+#define FP_AWAKE	0x01 // Work element has been awakened
+
+/**
+ * audit[1]: These bits are set by the reader task and/or the cleanup task
+ */
+#define FP_NOTPENDING	  0x80 // Work element removed from pending queue
+#define FP_AWAKENING	  0x40 // Caller about to be awakened
+#define FP_TIMEDOUT	  0x20 // Caller timed out
+#define FP_RESPSIZESET	  0x10 // Response size copied to work element
+#define FP_RESPADDRCOPIED 0x08 // Response address copied to work element
+#define FP_RESPBUFFCOPIED 0x04 // Response buffer copied to work element
+#define FP_REMREQUEST	  0x02 // Work element removed from request queue
+#define FP_SIGNALED	  0x01 // Work element was awakened by a signal
+
+/**
+ * audit[2]: unused
+ */
+
+/**
+ * state of the file handle in private_data.status
+ */
+#define STAT_OPEN 0
+#define STAT_CLOSED 1
+
+/**
+ * PID() expands to the process ID of the current process
+ */
+#define PID() (current->pid)
+
+/**
+ * Selected Constants.	The number of APs and the number of devices
+ */
+#ifndef Z90CRYPT_NUM_APS
+#define Z90CRYPT_NUM_APS 64
+#endif
+#ifndef Z90CRYPT_NUM_DEVS
+#define Z90CRYPT_NUM_DEVS Z90CRYPT_NUM_APS
+#endif
+#ifndef Z90CRYPT_NUM_TYPES
+#define Z90CRYPT_NUM_TYPES 3
+#endif
+
+/**
+ * Buffer size for receiving responses. The maximum Response Size
+ * is actually the maximum request size, since in an error condition
+ * the request itself may be returned unchanged.
+ */
+#ifndef MAX_RESPONSE_SIZE
+#define MAX_RESPONSE_SIZE 0x0000077C
+#endif
+
+/**
+ * A count and status-byte mask
+ */
+struct status {
+	int	      st_count;		    // # of enabled devices
+	int	      disabled_count;	    // # of disabled devices
+	int	      user_disabled_count;  // # of devices disabled via proc fs
+	unsigned char st_mask[Z90CRYPT_NUM_APS]; // current status mask
+};
+
+/**
+ * The array of device indexes is a mechanism for fast indexing into
+ * a long (and sparse) array.  For instance, if APs 3, 9 and 47 are
+ * installed, z90CDeviceIndex[0] is 3, z90CDeviceIndex[1] is 9, and
+ * z90CDeviceIndex[2] is 47.
+ */
+struct device_x {
+	int device_index[Z90CRYPT_NUM_DEVS];
+};
+
+/**
+ * All devices are arranged in a single array: 64 APs
+ */
+struct device {
+	int		 dev_type;	    // PCICA, PCICC, or PCIXCC
+	enum devstat	 dev_stat;	    // current device status
+	int		 dev_self_x;	    // Index in array
+	int		 disabled;	    // Set when device is in error
+	int		 user_disabled;	    // Set when device is disabled by user
+	int		 dev_q_depth;	    // q depth
+	unsigned char *	 dev_resp_p;	    // Response buffer address
+	int		 dev_resp_l;	    // Response Buffer length
+	int		 dev_caller_count;  // Number of callers
+	int		 dev_total_req_cnt; // # requests for device since load
+	struct list_head dev_caller_list;   // List of callers
+};
+
+/**
+ * There's a struct status and a struct device_x for each device type.
+ */
+struct hdware_block {
+	struct status	hdware_mask;
+	struct status	type_mask[Z90CRYPT_NUM_TYPES];
+	struct device_x type_x_addr[Z90CRYPT_NUM_TYPES];
+	unsigned char	device_type_array[Z90CRYPT_NUM_APS];
+};
+
+/**
+ * z90crypt is the topmost data structure in the hierarchy.
+ */
+struct z90crypt {
+	int		     max_count;		// Nr of possible crypto devices
+	struct status	     mask;
+	int		     q_depth_array[Z90CRYPT_NUM_DEVS];
+	int		     dev_type_array[Z90CRYPT_NUM_DEVS];
+	struct device_x	     overall_device_x;	// array device indexes
+	struct device *	     device_p[Z90CRYPT_NUM_DEVS];
+	int		     terminating;
+	int		     domain_established;// TRUE:  domain has been found
+	int		     cdx;		// Crypto Domain Index
+	int		     len;		// Length of this data structure
+	struct hdware_block *hdware_info;
+};
+
+/**
+ * An array of these structures is pointed to from dev_caller
+ * The length of the array depends on the device type. For APs,
+ * there are 8.
+ *
+ * The caller buffer is allocated to the user at OPEN. At WRITE,
+ * it contains the request; at READ, the response. The function
+ * send_to_crypto_device converts the request to device-dependent
+ * form and use the caller's OPEN-allocated buffer for the response.
+ */
+struct caller {
+	int		 caller_buf_l;		 // length of original request
+	unsigned char *	 caller_buf_p;		 // Original request on WRITE
+	int		 caller_dev_dep_req_l;	 // len device dependent request
+	unsigned char *	 caller_dev_dep_req_p;	 // Device dependent form
+	unsigned char	 caller_id[8];		 // caller-supplied message id
+	struct list_head caller_liste;
+	unsigned char	 caller_dev_dep_req[MAX_RESPONSE_SIZE];
+};
+
+/**
+ * Function prototypes from z90hardware.c
+ */
+enum hdstat query_online(int, int, int, int *, int *);
+enum devstat reset_device(int, int, int);
+enum devstat send_to_AP(int, int, int, unsigned char *);
+enum devstat receive_from_AP(int, int, int, unsigned char *, unsigned char *);
+int convert_request(unsigned char *, int, short, int, int, int *,
+		    unsigned char *);
+int convert_response(unsigned char *, int, unsigned char *, int *,
+		     unsigned char *);
+
+/**
+ * Low level function prototypes
+ */
+static int create_z90crypt(int *);
+static int refresh_z90crypt(int *);
+static int find_crypto_devices(struct status *);
+static int create_crypto_device(int);
+static int destroy_crypto_device(int);
+static void destroy_z90crypt(void);
+static int refresh_index_array(struct status *, struct device_x *);
+static int probe_device_type(struct device *);
+
+/**
+ * proc fs definitions
+ */
+struct proc_dir_entry *z90crypt_entry;
+
+/**
+ * data structures
+ */
+
+/**
+ * work_element.opener points back to this structure
+ */
+struct priv_data {
+	pid_t	opener_pid;
+	unsigned char	status;		// 0: open  1: closed
+};
+
+/**
+ * A work element is allocated for each request
+ */
+struct work_element {
+	struct priv_data *priv_data;
+	pid_t		  pid;
+	int		  devindex;	  // index of device processing this w_e
+					  // (If request did not specify device,
+					  // -1 until placed onto a queue)
+	int		  devtype;
+	struct list_head  liste;	  // used for requestq and pendingq
+	char		  buffer[128];	  // local copy of user request
+	int		  buff_size;	  // size of the buffer for the request
+	char		  resp_buff[RESPBUFFSIZE];
+	int		  resp_buff_size;
+	char *		  resp_addr;	  // address of response in user space
+	unsigned int	  funccode;	  // function code of request
+	wait_queue_head_t waitq;
+	unsigned long	  requestsent;	  // time at which the request was sent
+	atomic_t	  alarmrung;	  // wake-up signal
+	unsigned char	  caller_id[8];	  // pid + counter, for this w_e
+	unsigned char	  status[1];	  // bits to mark status of the request
+	unsigned char	  audit[3];	  // record of work element's progress
+	unsigned char *	  requestptr;	  // address of request buffer
+	int		  retcode;	  // return code of request
+};
+
+/**
+ * High level function prototypes
+ */
+static int z90crypt_open(struct inode *, struct file *);
+static int z90crypt_release(struct inode *, struct file *);
+static ssize_t z90crypt_read(struct file *, char *, size_t, loff_t *);
+static ssize_t z90crypt_write(struct file *, const char *, size_t, loff_t *);
+static int z90crypt_ioctl(struct inode *, struct file *,
+			  unsigned int, unsigned long);
+
+static void z90crypt_reader_task(unsigned long);
+static void z90crypt_schedule_reader_task(unsigned long);
+static void z90crypt_config_task(unsigned long);
+static void z90crypt_cleanup_task(unsigned long);
+
+static int z90crypt_status(char *, char **, off_t, int, int *, void *);
+static int z90crypt_status_write(struct file *, const char *,
+				 unsigned long, void *);
+
+/**
+ * Hotplug support
+ */
+
+#ifdef Z90CRYPT_USE_HOTPLUG
+#define Z90CRYPT_HOTPLUG_ADD	 1
+#define Z90CRYPT_HOTPLUG_REMOVE	 2
+
+static void z90crypt_hotplug_event(int, int, int);
+#endif
+
+/**
+ * Storage allocated at initialization and used throughout the life of
+ * this insmod
+ */
+#ifdef Z90CRYPT_USE_HOTPLUG
+static int z90crypt_major = Z90CRYPT_MAJOR;
+#endif
+
+static int domain = DOMAIN_INDEX;
+static struct z90crypt z90crypt;
+static int quiesce_z90crypt;
+static spinlock_t queuespinlock;
+static struct list_head request_list;
+static int requestq_count;
+static struct list_head pending_list;
+static int pendingq_count;
+
+static struct tasklet_struct reader_tasklet;
+static struct timer_list reader_timer;
+static struct timer_list config_timer;
+static struct timer_list cleanup_timer;
+static atomic_t total_open;
+static atomic_t z90crypt_step;
+
+struct file_operations z90crypt_fops = {
+	.owner	 = THIS_MODULE,
+	.read	 = z90crypt_read,
+	.write	 = z90crypt_write,
+	.ioctl	 = z90crypt_ioctl,
+	.open	 = z90crypt_open,
+	.release = z90crypt_release
+};
+
+#ifndef Z90CRYPT_USE_HOTPLUG
+struct miscdevice z90crypt_misc_device = {
+	.minor	    = Z90CRYPT_MINOR,
+	.name	    = DEV_NAME,
+	.fops	    = &z90crypt_fops,
+	.devfs_name = DEV_NAME
+};
+#endif
+
+/**
+ * Documentation values.
+ */
+MODULE_AUTHOR("zLinux Crypto Team: Robert H. Burroughs, Eric D. Rossman"
+	      "and Jochen Roehrig");
+MODULE_DESCRIPTION("zLinux Cryptographic Coprocessor device driver, "
+		   "Copyright 2001, 2004 IBM Corporation");
+MODULE_LICENSE("GPL");
+module_param(domain, int, 0);
+MODULE_PARM_DESC(domain, "domain index for device");
+
+/**
+ * The module initialization code.
+ */
+static int __init
+z90crypt_init_module(void)
+{
+	int result, nresult;
+	struct proc_dir_entry *entry;
+
+	PDEBUG("PID %d\n", PID());
+
+#ifndef Z90CRYPT_USE_HOTPLUG
+	/* Register as misc device with given minor (or get a dynamic one). */
+	result = misc_register(&z90crypt_misc_device);
+	if (result <0) {
+		PRINTKW(KERN_ERR "misc_register (minor %d) failed with %d\n",
+			z90crypt_misc_device.minor, result);
+		return result;
+	}
+#else
+	/* Register the major (or get a dynamic one). */
+	result = register_chrdev(z90crypt_major, REG_NAME, &z90crypt_fops);
+	if (result < 0) {
+		PRINTKW("register_chrdev (major %d) failed with %d.\n",
+			z90crypt_major, result);
+		return result;
+	}
+
+	if (z90crypt_major == 0)
+		z90crypt_major = result;
+#endif
+
+	PDEBUG("Registered " DEV_NAME " with result %d\n", result);
+
+	result = create_z90crypt(&domain);
+	if (result != 0) {
+		PRINTKW("create_z90crypt (domain index %d) failed with %d.\n",
+			domain, result);
+		result = -ENOMEM;
+		goto init_module_cleanup;
+	}
+
+	if (result == 0) {
+		PRINTKN("Version %d.%d.%d loaded, built on %s %s\n",
+			z90crypt_VERSION, z90crypt_RELEASE, z90crypt_VARIANT,
+			__DATE__, __TIME__);
+		PDEBUG("create_z90crypt (domain index %d) successful.\n",
+		       domain);
+	} else
+		PRINTK("No devices at startup\n");
+
+#ifdef Z90CRYPT_USE_HOTPLUG
+	/* generate hotplug event for device node generation */
+	z90crypt_hotplug_event(z90crypt_major, 0, Z90CRYPT_HOTPLUG_ADD);
+#endif
+
+	/* Initialize globals. */
+	spin_lock_init(&queuespinlock);
+
+	INIT_LIST_HEAD(&pending_list);
+	pendingq_count = 0;
+
+	INIT_LIST_HEAD(&request_list);
+	requestq_count = 0;
+
+	quiesce_z90crypt = 0;
+
+	atomic_set(&total_open, 0);
+	atomic_set(&z90crypt_step, 0);
+
+	/* Set up the cleanup task. */
+	init_timer(&cleanup_timer);
+	cleanup_timer.function = z90crypt_cleanup_task;
+	cleanup_timer.data = 0;
+	cleanup_timer.expires = jiffies + (CLEANUPTIME * HZ);
+	add_timer(&cleanup_timer);
+
+	/* Set up the proc file system */
+	entry = create_proc_entry("driver/z90crypt", 0644, 0);
+	if (entry) {
+		entry->nlink = 1;
+		entry->data = 0;
+		entry->read_proc = z90crypt_status;
+		entry->write_proc = z90crypt_status_write;
+	}
+	else
+		PRINTK("Couldn't create z90crypt proc entry\n");
+	z90crypt_entry = entry;
+
+	/* Set up the configuration task. */
+	init_timer(&config_timer);
+	config_timer.function = z90crypt_config_task;
+	config_timer.data = 0;
+	config_timer.expires = jiffies + (INITIAL_CONFIGTIME * HZ);
+	add_timer(&config_timer);
+
+	/* Set up the reader task */
+	tasklet_init(&reader_tasklet, z90crypt_reader_task, 0);
+	init_timer(&reader_timer);
+	reader_timer.function = z90crypt_schedule_reader_task;
+	reader_timer.data = 0;
+	reader_timer.expires = jiffies + (READERTIME * HZ / 1000);
+	add_timer(&reader_timer);
+
+	return 0; // success
+
+init_module_cleanup:
+#ifndef Z90CRYPT_USE_HOTPLUG
+	if ((nresult = misc_deregister(&z90crypt_misc_device)))
+		PRINTK("misc_deregister failed with %d.\n", nresult);
+	else
+		PDEBUG("misc_deregister successful.\n");
+#else
+	if ((nresult = unregister_chrdev(z90crypt_major, REG_NAME)))
+		PRINTK("unregister_chrdev failed with %d.\n", nresult);
+	else
+		PDEBUG("unregister_chrdev successful.\n");
+#endif
+
+	return result; // failure
+}
+
+/**
+ * The module termination code
+ */
+static void __exit
+z90crypt_cleanup_module(void)
+{
+	int nresult;
+
+	PDEBUG("PID %d\n", PID());
+
+	remove_proc_entry("driver/z90crypt", 0);
+
+#ifndef Z90CRYPT_USE_HOTPLUG
+	if ((nresult = misc_deregister(&z90crypt_misc_device)))
+		PRINTK("misc_deregister failed with %d.\n", nresult);
+	else
+		PDEBUG("misc_deregister successful.\n");
+#else
+	z90crypt_hotplug_event(z90crypt_major, 0, Z90CRYPT_HOTPLUG_REMOVE);
+
+	if ((nresult = unregister_chrdev(z90crypt_major, REG_NAME)))
+		PRINTK("unregister_chrdev failed with %d.\n", nresult);
+	else
+		PDEBUG("unregister_chrdev successful.\n");
+#endif
+
+	/* Remove the tasks */
+	tasklet_kill(&reader_tasklet);
+	del_timer(&reader_timer);
+	del_timer(&config_timer);
+	del_timer(&cleanup_timer);
+
+	destroy_z90crypt();
+}
+
+/**
+ * Functions running under a process id
+ *
+ * The I/O functions:
+ *     z90crypt_open
+ *     z90crypt_release
+ *     z90crypt_read
+ *     z90crypt_write
+ *     z90crypt_ioctl
+ *     z90crypt_status
+ *     z90crypt_status_write
+ *	 disable_card
+ *	 enable_card
+ *	 scan_char
+ *	 scan_string
+ *
+ * Helper functions:
+ *     z90crypt_rsa
+ *	 z90crypt_prepare
+ *	 z90crypt_send
+ *	 z90crypt_process_results
+ *
+ */
+static int
+z90crypt_open(struct inode *inode, struct file *filp)
+{
+	struct priv_data *private_data_p;
+
+	if (quiesce_z90crypt)
+		return -EQUIESCE;
+
+	private_data_p = kmalloc(sizeof(struct priv_data), GFP_KERNEL);
+	if (!private_data_p)
+		return -ENOMEM;
+
+	memset((void *)private_data_p, 0, sizeof(struct priv_data));
+	private_data_p->status = STAT_OPEN;
+	private_data_p->opener_pid = PID();
+	filp->private_data = private_data_p;
+	atomic_inc(&total_open);
+
+	return 0;
+}
+
+static int
+z90crypt_release(struct inode *inode, struct file *filp)
+{
+	struct priv_data *private_data_p = filp->private_data;
+
+	PDEBUG("PID %d (filp %p)\n", PID(), filp);
+
+	private_data_p->status = STAT_CLOSED;
+	memset(private_data_p, 0, sizeof(struct priv_data));
+	kfree(private_data_p);
+	atomic_dec(&total_open);
+
+	return 0;
+}
+
+/*
+ * there are two read functions, of which compile options will choose one
+ * without USE_GET_RANDOM_BYTES
+ *   => read() always returns -EPERM;
+ * otherwise
+ *   => read() uses get_random_bytes() kernel function
+ */
+#ifndef USE_GET_RANDOM_BYTES
+/**
+ * z90crypt_read will not be supported beyond z90crypt 1.3.1
+ */
+static ssize_t
+z90crypt_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+{
+	PDEBUG("filp %p (PID %d)\n", filp, PID());
+	return -EPERM;
+}
+#else // we want to use get_random_bytes
+/**
+ * read() just returns a string of random bytes.  Since we have no way
+ * to generate these cryptographically, we just execute get_random_bytes
+ * for the length specified.
+ */
+#include <linux/random.h>
+static ssize_t
+z90crypt_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+{
+	unsigned char *temp_buff;
+
+	PDEBUG("filp %p (PID %d)\n", filp, PID());
+
+	if (quiesce_z90crypt)
+		return -EQUIESCE;
+	if (count < 0) {
+		PRINTK("Requested random byte count negative: %ld\n", count);
+		return -EINVAL;
+	}
+	if (count > RESPBUFFSIZE) {
+		PDEBUG("count[%d] > RESPBUFFSIZE", count);
+		return -EINVAL;
+	}
+	if (count == 0)
+		return 0;
+	temp_buff = kmalloc(RESPBUFFSIZE, GFP_KERNEL);
+	if (!temp_buff)
+		return -ENOMEM;
+	get_random_bytes(temp_buff, count);
+
+	if (copy_to_user(buf, temp_buff, count) != 0) {
+		kfree(temp_buff);
+		return -EFAULT;
+	}
+	kfree(temp_buff);
+	return count;
+}
+#endif
+
+/**
+ * Write is is not allowed
+ */
+static ssize_t
+z90crypt_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos)
+{
+	PDEBUG("filp %p (PID %d)\n", filp, PID());
+	return -EPERM;
+}
+
+/**
+ * New status functions
+ */
+static inline int
+get_status_totalcount(void)
+{
+	return z90crypt.hdware_info->hdware_mask.st_count;
+}
+
+static inline int
+get_status_PCICAcount(void)
+{
+	return z90crypt.hdware_info->type_mask[PCICA].st_count;
+}
+
+static inline int
+get_status_PCICCcount(void)
+{
+	return z90crypt.hdware_info->type_mask[PCICC].st_count;
+}
+
+static inline int
+get_status_PCIXCCcount(void)
+{
+	return z90crypt.hdware_info->type_mask[PCIXCC].st_count;
+}
+
+static inline int
+get_status_requestq_count(void)
+{
+	return requestq_count;
+}
+
+static inline int
+get_status_pendingq_count(void)
+{
+	return pendingq_count;
+}
+
+static inline int
+get_status_totalopen_count(void)
+{
+	return atomic_read(&total_open);
+}
+
+static inline int
+get_status_domain_index(void)
+{
+	return z90crypt.cdx;
+}
+
+static inline unsigned char *
+get_status_status_mask(unsigned char status[Z90CRYPT_NUM_APS])
+{
+	int i, ix;
+
+	memcpy(status, z90crypt.hdware_info->device_type_array,
+	       Z90CRYPT_NUM_APS);
+
+	for (i = 0; i < get_status_totalcount(); i++) {
+		ix = SHRT2LONG(i);
+		if (LONG2DEVPTR(ix)->user_disabled)
+			status[ix] = 0x0d;
+	}
+
+	return status;
+}
+
+static inline unsigned char *
+get_status_qdepth_mask(unsigned char qdepth[Z90CRYPT_NUM_APS])
+{
+	int i, ix;
+
+	memset(qdepth, 0, Z90CRYPT_NUM_APS);
+
+	for (i = 0; i < get_status_totalcount(); i++) {
+		ix = SHRT2LONG(i);
+		qdepth[ix] = LONG2DEVPTR(ix)->dev_caller_count;
+	}
+
+	return qdepth;
+}
+
+static inline unsigned int *
+get_status_perdevice_reqcnt(unsigned int reqcnt[Z90CRYPT_NUM_APS])
+{
+	int i, ix;
+
+	memset(reqcnt, 0, Z90CRYPT_NUM_APS * sizeof(int));
+
+	for (i = 0; i < get_status_totalcount(); i++) {
+		ix = SHRT2LONG(i);
+		reqcnt[ix] = LONG2DEVPTR(ix)->dev_total_req_cnt;
+	}
+
+	return reqcnt;
+}
+
+static inline void
+init_work_element(struct work_element *we_p,
+		  struct priv_data *priv_data, pid_t pid)
+{
+	int step;
+
+	we_p->requestptr = (unsigned char *)we_p + sizeof(struct work_element);
+	/* Come up with a unique id for this caller. */
+	step = atomic_inc_return(&z90crypt_step);
+	memcpy(we_p->caller_id+0, (void *) &pid, sizeof(pid));
+	memcpy(we_p->caller_id+4, (void *) &step, sizeof(step));
+	we_p->pid = pid;
+	we_p->priv_data = priv_data;
+	we_p->status[0] = STAT_DEFAULT;
+	we_p->audit[0] = 0x00;
+	we_p->audit[1] = 0x00;
+	we_p->audit[2] = 0x00;
+	we_p->resp_buff_size = 0;
+	we_p->retcode = 0;
+	we_p->devindex = -1; // send_to_crypto selects the device
+	we_p->devtype = -1;  // getCryptoBuffer selects the type
+	atomic_set(&we_p->alarmrung, 0);
+	init_waitqueue_head(&we_p->waitq);
+	INIT_LIST_HEAD(&(we_p->liste));
+}
+
+static inline int
+allocate_work_element(struct work_element **we_pp,
+		      struct priv_data *priv_data_p, pid_t pid)
+{
+	struct work_element *we_p;
+
+	we_p = (struct work_element *) get_zeroed_page(GFP_KERNEL);
+	if (!we_p)
+		return -ENOMEM;
+	init_work_element(we_p, priv_data_p, pid);
+	*we_pp = we_p;
+	return 0;
+}
+
+static inline void
+remove_device(struct device *device_p)
+{
+	if (!device_p || device_p->disabled != 0)
+		return;
+	device_p->disabled = 1;
+	z90crypt.hdware_info->type_mask[device_p->dev_type].disabled_count++;
+	z90crypt.hdware_info->hdware_mask.disabled_count++;
+}
+
+static inline int
+select_device_type(int *dev_type_p)
+{
+	struct status *stat;
+	if ((*dev_type_p != PCICC) && (*dev_type_p != PCICA) &&
+	    (*dev_type_p != PCIXCC) && (*dev_type_p != ANYDEV))
+		return -1;
+	if (*dev_type_p != ANYDEV) {
+		stat = &z90crypt.hdware_info->type_mask[*dev_type_p];
+		if (stat->st_count >
+		    stat->disabled_count + stat->user_disabled_count)
+			return 0;
+		return -1;
+	}
+
+	stat = &z90crypt.hdware_info->type_mask[PCICA];
+	if (stat->st_count > stat->disabled_count + stat->user_disabled_count) {
+		*dev_type_p = PCICA;
+		return 0;
+	}
+
+	stat = &z90crypt.hdware_info->type_mask[PCIXCC];
+	if (stat->st_count > stat->disabled_count + stat->user_disabled_count) {
+		*dev_type_p = PCIXCC;
+		return 0;
+	}
+
+	stat = &z90crypt.hdware_info->type_mask[PCICC];
+	if (stat->st_count > stat->disabled_count + stat->user_disabled_count) {
+		*dev_type_p = PCICC;
+		return 0;
+	}
+
+	return -1;
+}
+
+/**
+ * Try the selected number, then the selected type (can be ANYDEV)
+ */
+static inline int
+select_device(int *dev_type_p, int *device_nr_p)
+{
+	int i, indx, devTp, low_count, low_indx;
+	struct device_x *index_p;
+	struct device *dev_ptr;
+
+	PDEBUG("device type = %d, index = %d\n", *dev_type_p, *device_nr_p);
+	if ((*device_nr_p >= 0) && (*device_nr_p < Z90CRYPT_NUM_DEVS)) {
+		PDEBUG("trying index = %d\n", *device_nr_p);
+		dev_ptr = z90crypt.device_p[*device_nr_p];
+
+		if (dev_ptr &&
+		    dev_ptr->dev_stat != DEV_GONE &&
+		    dev_ptr->disabled == 0 &&
+		    dev_ptr->user_disabled == 0) {
+			PDEBUG("selected by number, index = %d\n",
+			       *device_nr_p);
+			*dev_type_p = dev_ptr->dev_type;
+			return *device_nr_p;
+		}
+	}
+	*device_nr_p = -1;
+	PDEBUG("trying type = %d\n", *dev_type_p);
+	devTp = *dev_type_p;
+	if (select_device_type(&devTp) == -1) {
+		PDEBUG("failed to select by type\n");
+		return -1;
+	}
+	PDEBUG("selected type = %d\n", devTp);
+	index_p = &z90crypt.hdware_info->type_x_addr[devTp];
+	low_count = 0x0000FFFF;
+	low_indx = -1;
+	for (i = 0; i < z90crypt.hdware_info->type_mask[devTp].st_count; i++) {
+		indx = index_p->device_index[i];
+		dev_ptr = z90crypt.device_p[indx];
+		if (dev_ptr &&
+		    dev_ptr->dev_stat != DEV_GONE &&
+		    dev_ptr->disabled == 0 &&
+		    dev_ptr->user_disabled == 0 &&
+		    devTp == dev_ptr->dev_type &&
+		    low_count > dev_ptr->dev_caller_count) {
+			low_count = dev_ptr->dev_caller_count;
+			low_indx = indx;
+		}
+	}
+	*device_nr_p = low_indx;
+	return low_indx;
+}
+
+static inline int
+send_to_crypto_device(unsigned char *psmid, int func, int buff_len,
+		      unsigned char *buff_ptr, int devType,
+		      int *devNr_p, unsigned char *reqBuff)
+{
+	struct caller *caller_p;
+	struct device *device_p;
+	int dev_nr;
+
+	if (!reqBuff)
+		return SEN_FATAL_ERROR;
+	caller_p = (struct caller *)reqBuff;
+	dev_nr = *devNr_p;
+	if (select_device(&devType, &dev_nr) == -1) {
+		if (z90crypt.hdware_info->hdware_mask.st_count != 0)
+			return SEN_RETRY;
+		else
+			return SEN_NOT_AVAIL;
+	}
+	*devNr_p = dev_nr;
+	device_p = z90crypt.device_p[dev_nr];
+	if (!device_p)
+		return SEN_NOT_AVAIL;
+	if (device_p->dev_type != devType)
+		return SEN_RETRY;
+	if (device_p->dev_caller_count >= device_p->dev_q_depth)
+		return SEN_QUEUE_FULL;
+	PDEBUG("device number prior to send: %d\n", dev_nr);
+	switch (send_to_AP(dev_nr, z90crypt.cdx,
+			   caller_p->caller_dev_dep_req_l,
+			   caller_p->caller_dev_dep_req_p)) {
+	case DEV_SEN_EXCEPTION:
+		PRINTKC("Exception during send to device %d\n", dev_nr);
+		z90crypt.terminating = 1;
+		return SEN_FATAL_ERROR;
+	case DEV_GONE:
+		PRINTK("Device %d not available\n", dev_nr);
+		remove_device(device_p);
+		return SEN_NOT_AVAIL;
+	case DEV_EMPTY:
+		return SEN_NOT_AVAIL;
+	case DEV_NO_WORK:
+		return SEN_FATAL_ERROR;
+	case DEV_BAD_MESSAGE:
+		return SEN_USER_ERROR;
+	case DEV_QUEUE_FULL:
+		return SEN_QUEUE_FULL;
+	default:
+	case DEV_ONLINE:
+		break;
+	}
+	list_add_tail(&(caller_p->caller_liste), &(device_p->dev_caller_list));
+	device_p->dev_caller_count++;
+	return 0;
+}
+
+/**
+ * Send puts the user's work on one of two queues:
+ *   the pending queue if the send was successful
+ *   the request queue if the send failed because device full or busy
+ */
+static inline int
+z90crypt_send(struct work_element *we_p, const char *buf)
+{
+	int rv;
+
+	PDEBUG("PID %d\n", PID());
+
+	if (CHK_RDWRMASK(we_p->status[0]) != STAT_NOWORK) {
+		PDEBUG("PID %d tried to send more work but has outstanding "
+		       "work.\n", PID());
+		return -EWORKPEND;
+	}
+	we_p->devindex = -1; // Reset device number
+	spin_lock_irq(&queuespinlock);
+	rv = send_to_crypto_device(we_p->caller_id, we_p->funccode,
+				   we_p->buff_size, we_p->buffer, we_p->devtype,
+				   &we_p->devindex, we_p->requestptr);
+	switch (rv) {
+	case 0:
+		we_p->requestsent = jiffies;
+		we_p->audit[0] |= FP_SENT;
+		list_add_tail(&we_p->liste, &pending_list);
+		++pendingq_count;
+		we_p->audit[0] |= FP_PENDING;
+		break;
+	case SEN_BUSY:
+	case SEN_QUEUE_FULL:
+		rv = 0;
+		we_p->devindex = -1; // any device will do
+		we_p->requestsent = jiffies;
+		list_add_tail(&we_p->liste, &request_list);
+		++requestq_count;
+		we_p->audit[0] |= FP_REQUEST;
+		break;
+	case SEN_RETRY:
+		rv = -ERESTARTSYS;
+		break;
+	case SEN_NOT_AVAIL:
+		PRINTK("*** No devices available.\n");
+		rv = we_p->retcode = -ENODEV;
+		we_p->status[0] |= STAT_FAILED;
+		break;
+	case REC_OPERAND_INV:
+	case REC_OPERAND_SIZE:
+	case REC_EVEN_MOD:
+	case REC_INVALID_PAD:
+		rv = we_p->retcode = -EINVAL;
+		we_p->status[0] |= STAT_FAILED;
+		break;
+	default:
+		we_p->retcode = rv;
+		we_p->status[0] |= STAT_FAILED;
+		break;
+	}
+	if (rv != -ERESTARTSYS)
+		SET_RDWRMASK(we_p->status[0], STAT_WRITTEN);
+	spin_unlock_irq(&queuespinlock);
+	if (rv == 0)
+		tasklet_schedule(&reader_tasklet);
+	return rv;
+}
+
+/**
+ * process_results copies the user's work from kernel space.
+ */
+static inline int
+z90crypt_process_results(struct work_element *we_p, char *buf)
+{
+	int rv;
+
+	PDEBUG("we_p %p (PID %d)\n", we_p, PID());
+
+	LONG2DEVPTR(we_p->devindex)->dev_total_req_cnt++;
+	SET_RDWRMASK(we_p->status[0], STAT_READPEND);
+
+	rv = 0;
+	if (!we_p->buffer) {
+		PRINTK("we_p %p PID %d in STAT_READPEND: buffer NULL.\n",
+			we_p, PID());
+		rv = -ENOBUFF;
+	}
+
+	if (!rv)
+		if ((rv = copy_to_user(buf, we_p->buffer, we_p->buff_size))) {
+			PDEBUG("copy_to_user failed: rv = %d\n", rv);
+			rv = -EFAULT;
+		}
+
+	if (!rv)
+		rv = we_p->retcode;
+	if (!rv)
+		if (we_p->resp_buff_size
+		    &&	copy_to_user(we_p->resp_addr, we_p->resp_buff,
+				     we_p->resp_buff_size))
+			rv = -EFAULT;
+
+	SET_RDWRMASK(we_p->status[0], STAT_NOWORK);
+	return rv;
+}
+
+static unsigned char NULL_psmid[8] =
+{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+/**
+ * MIN_MOD_SIZE is a PCICC and PCIXCC limit.
+ * MAX_PCICC_MOD_SIZE is a hard limit for the PCICC.
+ * MAX_MOD_SIZE is a hard limit for the PCIXCC and PCICA.
+ */
+#define MIN_MOD_SIZE 64
+#define MAX_PCICC_MOD_SIZE 128
+#define MAX_MOD_SIZE 256
+
+/**
+ * Used in device configuration functions
+ */
+#define MAX_RESET 90
+
+/**
+ * This is used only for PCICC support
+ */
+static inline int
+is_PKCS11_padded(unsigned char *buffer, int length)
+{
+	int i;
+	if ((buffer[0] != 0x00) || (buffer[1] != 0x01))
+		return 0;
+	for (i = 2; i < length; i++)
+		if (buffer[i] != 0xFF)
+			break;
+	if ((i < 10) || (i == length))
+		return 0;
+	if (buffer[i] != 0x00)
+		return 0;
+	return 1;
+}
+
+/**
+ * This is used only for PCICC support
+ */
+static inline int
+is_PKCS12_padded(unsigned char *buffer, int length)
+{
+	int i;
+	if ((buffer[0] != 0x00) || (buffer[1] != 0x02))
+		return 0;
+	for (i = 2; i < length; i++)
+		if (buffer[i] == 0x00)
+			break;
+	if ((i < 10) || (i == length))
+		return 0;
+	if (buffer[i] != 0x00)
+		return 0;
+	return 1;
+}
+
+/**
+ * builds struct caller and converts message from generic format to
+ * device-dependent format
+ * func is ICARSAMODEXPO or ICARSACRT
+ * function is PCI_FUNC_KEY_ENCRYPT or PCI_FUNC_KEY_DECRYPT
+ */
+static inline int
+build_caller(char *psmid, int func, short function, int buff_len,
+	     char *buff_ptr, int dev_type, struct caller *caller_p)
+{
+	int rv;
+
+	if ((dev_type != PCICC) && (dev_type != PCICA) && (dev_type != PCIXCC))
+		return SEN_NOT_AVAIL;
+
+	memcpy(caller_p->caller_id, psmid, sizeof(caller_p->caller_id));
+	caller_p->caller_dev_dep_req_p = caller_p->caller_dev_dep_req;
+	caller_p->caller_dev_dep_req_l = MAX_RESPONSE_SIZE;
+	caller_p->caller_buf_p = buff_ptr;
+	INIT_LIST_HEAD(&(caller_p->caller_liste));
+
+	rv = convert_request(buff_ptr, func, function, z90crypt.cdx, dev_type,
+			     &caller_p->caller_dev_dep_req_l,
+			     caller_p->caller_dev_dep_req_p);
+	if (rv)
+		PRINTK("Error from convert_request: %d\n", rv);
+	else
+		memcpy(&(caller_p->caller_dev_dep_req_p[4]), psmid, 8);
+	return rv;
+}
+
+static inline void
+unbuild_caller(struct device *device_p, struct caller *caller_p)
+{
+	if (!caller_p)
+		return;
+	if (caller_p->caller_liste.next && caller_p->caller_liste.prev)
+		if (!list_empty(&caller_p->caller_liste)) {
+			list_del(&caller_p->caller_liste);
+			device_p->dev_caller_count--;
+			INIT_LIST_HEAD(&caller_p->caller_liste);
+		}
+	memset(caller_p->caller_id, 0, sizeof(caller_p->caller_id));
+}
+
+static inline int
+get_crypto_request_buffer(unsigned char *psmid, int func, int buff_len,
+			  unsigned char *buff_ptr, int *dev_type_p,
+			  unsigned char *caller_p)
+{
+	struct ica_rsa_modexpo *mex_p;
+	struct ica_rsa_modexpo_crt *crt_p;
+	unsigned char *temp_buffer;
+	short function;
+	int rv;
+
+	mex_p =	(struct ica_rsa_modexpo *) buff_ptr;
+	crt_p = (struct ica_rsa_modexpo_crt *) buff_ptr;
+
+	PDEBUG("device type input = %d\n", *dev_type_p);
+
+	if (z90crypt.terminating)
+		return REC_NO_RESPONSE;
+
+	temp_buffer = kmalloc(256, GFP_KERNEL);
+	if (!temp_buffer) {
+		PRINTK("kmalloc for temp_buffer failed!\n");
+		return SEN_NOT_AVAIL;
+	}
+	if (memcmp(psmid, NULL_psmid, 8) == 0) {
+		PRINTK("psmid zeroes\n");
+		kfree(temp_buffer);
+		return SEN_FATAL_ERROR;
+	}
+	if (!buff_ptr) {
+		PRINTK("buffer pointer NULL\n");
+		kfree(temp_buffer);
+		return SEN_USER_ERROR;
+	}
+	if (!caller_p) {
+		PRINTK("caller pointer NULL\n");
+		kfree(temp_buffer);
+		return SEN_USER_ERROR;
+	}
+
+	if ((*dev_type_p != PCICA) && (*dev_type_p != PCICC) &&
+	    (*dev_type_p != PCIXCC) && (*dev_type_p != ANYDEV)) {
+		PRINTK("invalid device type\n");
+		kfree(temp_buffer);
+		return SEN_USER_ERROR;
+	}
+
+	if ((mex_p->inputdatalength < 1) ||
+	    (mex_p->inputdatalength > MAX_MOD_SIZE)) {
+		PRINTK("inputdatalength[%d] is not valid\n",
+		       mex_p->inputdatalength);
+		kfree(temp_buffer);
+		return SEN_USER_ERROR;
+	}
+
+	if (mex_p->outputdatalength < mex_p->inputdatalength) {
+		PRINTK("outputdatalength[%d] < inputdatalength[%d]\n",
+		       mex_p->outputdatalength, mex_p->inputdatalength);
+		kfree(temp_buffer);
+		return SEN_USER_ERROR;
+	}
+
+	if (!mex_p->inputdata || !mex_p->outputdata) {
+		PRINTK("inputdata[%p] or outputdata[%p] is NULL\n",
+		       mex_p->outputdata, mex_p->inputdata);
+		kfree(temp_buffer);
+		return SEN_USER_ERROR;
+	}
+
+	/**
+	 * As long as outputdatalength is big enough, we can set the
+	 * outputdatalength equal to the inputdatalength, since that is the
+	 * number of bytes we will copy in any case
+	 */
+	mex_p->outputdatalength = mex_p->inputdatalength;
+
+	rv = 0;
+	switch (func) {
+	case ICARSAMODEXPO:
+		if (!mex_p->b_key || !mex_p->n_modulus)
+			rv = SEN_USER_ERROR;
+		break;
+	case ICARSACRT:
+		if (!IS_EVEN(crt_p->inputdatalength)) {
+			PRINTK("inputdatalength[%d] is odd, CRT form\n",
+			       crt_p->inputdatalength);
+			rv = SEN_USER_ERROR;
+			break;
+		}
+		if (!crt_p->bp_key ||
+		    !crt_p->bq_key ||
+		    !crt_p->np_prime ||
+		    !crt_p->nq_prime ||
+		    !crt_p->u_mult_inv) {
+			PRINTK("CRT form, bad data: %p/%p/%p/%p/%p\n",
+			       crt_p->bp_key, crt_p->bq_key,
+			       crt_p->np_prime, crt_p->nq_prime,
+			       crt_p->u_mult_inv);
+			rv = SEN_USER_ERROR;
+		}
+		break;
+	default:
+		PRINTK("bad func = %d\n", func);
+		rv = SEN_USER_ERROR;
+		break;
+	}
+	if (rv != 0) {
+		kfree(temp_buffer);
+		return rv;
+	}
+
+	if (select_device_type(dev_type_p) < 0) {
+		kfree(temp_buffer);
+		return SEN_NOT_AVAIL;
+	}
+
+	if (copy_from_user(temp_buffer, mex_p->inputdata,
+			   mex_p->inputdatalength) != 0) {
+		kfree(temp_buffer);
+		return SEN_RELEASED;
+	}
+
+	function = PCI_FUNC_KEY_ENCRYPT;
+	switch (*dev_type_p) {
+	/* PCICA does everything with a simple RSA mod-expo operation */
+	case PCICA:
+		function = PCI_FUNC_KEY_ENCRYPT;
+		break;
+	/**
+	 * PCIXCC does all Mod-Expo form with a simple RSA mod-expo
+	 * operation, and all CRT forms with a PKCS-1.2 format decrypt.
+	 */
+	case PCIXCC:
+		/* Anything less than MIN_MOD_SIZE MUST go to a PCICA */
+		if (mex_p->inputdatalength < MIN_MOD_SIZE) {
+			kfree(temp_buffer);
+			return SEN_NOT_AVAIL;
+		}
+		if (func == ICARSAMODEXPO)
+			function = PCI_FUNC_KEY_ENCRYPT;
+		else
+			function = PCI_FUNC_KEY_DECRYPT;
+		break;
+	/**
+	 * PCICC does everything as a PKCS-1.2 format request
+	 */
+	case PCICC:
+		/* Anything less than MIN_MOD_SIZE MUST go to a PCICA */
+		if (mex_p->inputdatalength < MIN_MOD_SIZE) {
+			kfree(temp_buffer);
+			return SEN_NOT_AVAIL;
+		}
+		/* Anythings over MAX_PCICC_MOD_SIZE MUST go to a PCICA */
+		if (mex_p->inputdatalength > MAX_PCICC_MOD_SIZE) {
+			kfree(temp_buffer);
+			return SEN_NOT_AVAIL;
+		}
+		/* PCICC cannot handle input that is is PKCS#1.1 padded */
+		if (is_PKCS11_padded(temp_buffer, mex_p->inputdatalength)) {
+			kfree(temp_buffer);
+			return SEN_NOT_AVAIL;
+		}
+		if (func == ICARSAMODEXPO) {
+			if (is_PKCS12_padded(temp_buffer,
+					     mex_p->inputdatalength))
+				function = PCI_FUNC_KEY_ENCRYPT;
+			else
+				function = PCI_FUNC_KEY_DECRYPT;
+		} else
+			/* all CRT forms are decrypts */
+			function = PCI_FUNC_KEY_DECRYPT;
+		break;
+	}
+	PDEBUG("function: %04x\n", function);
+	rv = build_caller(psmid, func, function, buff_len, buff_ptr,
+			  *dev_type_p, (struct caller *)caller_p);
+	PDEBUG("rv from build_caller = %d\n", rv);
+	kfree(temp_buffer);
+	return rv;
+}
+
+static inline int
+z90crypt_prepare(struct work_element *we_p, unsigned int funccode,
+		 const char *buffer)
+{
+	int rv;
+
+	we_p->devindex = -1;
+	if (funccode == ICARSAMODEXPO)
+		we_p->buff_size = sizeof(struct ica_rsa_modexpo);
+	else
+		we_p->buff_size = sizeof(struct ica_rsa_modexpo_crt);
+
+	if (copy_from_user(we_p->buffer, buffer, we_p->buff_size))
+		return -EFAULT;
+
+	we_p->audit[0] |= FP_COPYFROM;
+	SET_RDWRMASK(we_p->status[0], STAT_WRITTEN);
+	we_p->funccode = funccode;
+	we_p->devtype = -1;
+	we_p->audit[0] |= FP_BUFFREQ;
+	rv = get_crypto_request_buffer(we_p->caller_id, we_p->funccode,
+				       we_p->buff_size, we_p->buffer,
+				       &we_p->devtype, we_p->requestptr);
+	switch (rv) {
+	case 0:
+		we_p->audit[0] |= FP_BUFFGOT;
+		break;
+	case SEN_USER_ERROR:
+		rv = -EINVAL;
+		break;
+	case SEN_QUEUE_FULL:
+		rv = 0;
+		break;
+	case SEN_RELEASED:
+		rv = -EFAULT;
+		break;
+	case REC_NO_RESPONSE:
+		rv = -ENODEV;
+		break;
+	case SEN_NOT_AVAIL:
+	default:
+		PRINTK("rv = %d\n", rv);
+		rv = -EGETBUFF;
+		break;
+	}
+	if (CHK_RDWRMASK(we_p->status[0]) == STAT_WRITTEN)
+		SET_RDWRMASK(we_p->status[0], STAT_DEFAULT);
+	return rv;
+}
+
+static inline void
+purge_work_element(struct work_element *we_p)
+{
+	struct list_head *lptr;
+
+	spin_lock_irq(&queuespinlock);
+	list_for_each(lptr, &request_list) {
+		if (lptr == &we_p->liste) {
+			list_del(lptr);
+			requestq_count--;
+			break;
+		}
+	}
+	list_for_each(lptr, &pending_list) {
+		if (lptr == &we_p->liste) {
+			list_del(lptr);
+			pendingq_count--;
+			break;
+		}
+	}
+	spin_unlock_irq(&queuespinlock);
+}
+
+/**
+ * Build the request and send it.
+ */
+static inline int
+z90crypt_rsa(struct priv_data *private_data_p, pid_t pid,
+	     unsigned int cmd, unsigned long arg)
+{
+	struct work_element *we_p;
+	int keep_work_element;
+	int rv;
+
+	if ((rv = allocate_work_element(&we_p, private_data_p, pid)))
+		return rv;
+	if ((rv = z90crypt_prepare(we_p, cmd, (const char *)arg))) {
+		PDEBUG("PID %d: rv = %d from z90crypt_prepare\n",
+		       pid, rv);
+		return rv;
+	}
+	if (!rv)
+		if ((rv = z90crypt_send(we_p, (const char *)arg)))
+			PDEBUG("PID %d: rv %d from z90crypt_send.\n", pid, rv);
+	if (!rv) {
+		we_p->audit[0] |= FP_ASLEEP;
+		wait_event(we_p->waitq, atomic_read(&we_p->alarmrung));
+		we_p->audit[0] |= FP_AWAKE;
+		rv = we_p->retcode;
+	}
+	if (!rv)
+		rv = z90crypt_process_results(we_p, (char *)arg);
+
+	keep_work_element = 0;
+	if ((we_p->status[0] & STAT_FAILED)) {
+		switch (rv) {
+		/**
+		 * EINVAL *after* receive is almost always padding
+		 * error issued by a PCICC or PCIXCC. We convert this
+		 * return value to -EGETBUFF which should trigger a
+		 * fallback to software.
+		 */
+		case -EINVAL:
+			if ((we_p->devtype == PCICC) ||
+			    (we_p->devtype == PCIXCC))
+				rv = -EGETBUFF;
+			break;
+		case -ETIMEOUT:
+			if (z90crypt.mask.st_count > 0)
+				rv = -ERESTARTSYS; // retry with another
+			else
+				rv = -ENODEV; // no cards left
+		/* fall through to clean up request queue */
+		case -ERESTARTSYS:
+		case -ERELEASED:
+			switch (CHK_RDWRMASK(we_p->status[0])) {
+			case STAT_WRITTEN:
+				purge_work_element(we_p);
+				break;
+			case STAT_QUEUED:
+				keep_work_element = 1;
+				break;
+			case STAT_READPEND:
+			case STAT_NOWORK:
+			default:
+				break;
+			}
+			break;
+		default:
+			we_p->status[0] ^= STAT_FAILED;
+			break;
+		}
+	}
+	if (!keep_work_element)
+		free_page((long)we_p);
+	return rv;
+}
+
+/**
+ * This function is a little long, but it's really just one large switch
+ * statement.
+ */
+static int
+z90crypt_ioctl(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
+{
+	struct priv_data *private_data_p = filp->private_data;
+	unsigned char *status;
+	unsigned char *qdepth;
+	unsigned int *reqcnt;
+	struct ica_z90_status *pstat;
+	int ret, i, loopLim, tempstat;
+
+	PDEBUG("filp %p (PID %d), cmd 0x%08X\n", filp, PID(), cmd);
+	PDEBUG("cmd 0x%08X: dir %s, size 0x%04X, type 0x%02X, nr 0x%02X\n",
+		cmd,
+		!_IOC_DIR(cmd) ? "NO"
+		: ((_IOC_DIR(cmd) == (_IOC_READ|_IOC_WRITE)) ? "RW"
+		: ((_IOC_DIR(cmd) == _IOC_READ) ? "RD"
+		: "WR")),
+		_IOC_SIZE(cmd), _IOC_TYPE(cmd), _IOC_NR(cmd));
+
+	if (_IOC_TYPE(cmd) != Z90_IOCTL_MAGIC) {
+		PRINTK("cmd 0x%08X contains bad magic\n", cmd);
+		return -ENOTTY;
+	}
+
+	ret = 0;
+	switch (cmd) {
+	case ICARSAMODEXPO:
+	case ICARSACRT:
+		if (quiesce_z90crypt) {
+			ret = -EQUIESCE;
+			break;
+		}
+		ret = -ENODEV; // Default if no devices
+		loopLim = z90crypt.hdware_info->hdware_mask.st_count -
+			(z90crypt.hdware_info->hdware_mask.disabled_count +
+			 z90crypt.hdware_info->hdware_mask.user_disabled_count);
+		for (i = 0; i < loopLim; i++) {
+			ret = z90crypt_rsa(private_data_p, PID(), cmd, arg);
+			if (ret != -ERESTARTSYS)
+				break;
+		}
+		if (ret == -ERESTARTSYS)
+			ret = -ENODEV;
+		break;
+		
+	case Z90STAT_TOTALCOUNT:
+		tempstat = get_status_totalcount();
+		if (copy_to_user((int *)arg, &tempstat,sizeof(int)) != 0)
+			ret = -EFAULT;
+		break;
+		
+	case Z90STAT_PCICACOUNT:
+		tempstat = get_status_PCICAcount();
+		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+			ret = -EFAULT;
+		break;
+		
+	case Z90STAT_PCICCCOUNT:
+		tempstat = get_status_PCICCcount();
+		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+			ret = -EFAULT;
+		break;
+		
+	case Z90STAT_PCIXCCCOUNT:
+		tempstat = get_status_PCIXCCcount();
+		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+			ret = -EFAULT;
+		break;
+		
+	case Z90STAT_REQUESTQ_COUNT:
+		tempstat = get_status_requestq_count();
+		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+			ret = -EFAULT;
+		break;
+		
+	case Z90STAT_PENDINGQ_COUNT:
+		tempstat = get_status_pendingq_count();
+		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+			ret = -EFAULT;
+		break;
+		
+	case Z90STAT_TOTALOPEN_COUNT:
+		tempstat = get_status_totalopen_count();
+		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+			ret = -EFAULT;
+		break;
+		
+	case Z90STAT_DOMAIN_INDEX:
+		tempstat = get_status_domain_index();
+		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+			ret = -EFAULT;
+		break;
+		
+	case Z90STAT_STATUS_MASK:
+		status = kmalloc(Z90CRYPT_NUM_APS, GFP_KERNEL);
+		if (!status) {
+			PRINTK("kmalloc for status failed!\n");
+			ret = -ENOMEM;
+			break;
+		}
+		get_status_status_mask(status);
+		if (copy_to_user((char *) arg, status, Z90CRYPT_NUM_APS) != 0)
+			ret = -EFAULT;
+		kfree(status);
+		break;
+		
+	case Z90STAT_QDEPTH_MASK:
+		qdepth = kmalloc(Z90CRYPT_NUM_APS, GFP_KERNEL);
+		if (!qdepth) {
+			PRINTK("kmalloc for qdepth failed!\n");
+			ret = -ENOMEM;
+			break;
+		}
+		get_status_qdepth_mask(qdepth);
+		if (copy_to_user((char *) arg, qdepth, Z90CRYPT_NUM_APS) != 0)
+			ret = -EFAULT;
+		kfree(qdepth);
+		break;
+		
+	case Z90STAT_PERDEV_REQCNT:
+		reqcnt = kmalloc(sizeof(int) * Z90CRYPT_NUM_APS, GFP_KERNEL);
+		if (!reqcnt) {
+			PRINTK("kmalloc for reqcnt failed!\n");
+			ret = -ENOMEM;
+			break;
+		}
+		get_status_perdevice_reqcnt(reqcnt);
+		if (copy_to_user((char *) arg, reqcnt,
+				 Z90CRYPT_NUM_APS * sizeof(int)) != 0)
+			ret = -EFAULT;
+		kfree(reqcnt);
+		break;
+		
+		/* THIS IS DEPRECATED.	USE THE NEW STATUS CALLS */
+	case ICAZ90STATUS:
+		PRINTK("deprecated call to ioctl (ICAZ90STATUS)!\n");
+		
+		pstat = kmalloc(sizeof(struct ica_z90_status), GFP_KERNEL);
+		if (!pstat) {
+			PRINTK("kmalloc for pstat failed!\n");
+			ret = -ENOMEM;
+			break;
+		}
+		
+		pstat->totalcount	 = get_status_totalcount();
+		pstat->leedslitecount	 = get_status_PCICAcount();
+		pstat->leeds2count	 = get_status_PCICCcount();
+		pstat->requestqWaitCount = get_status_requestq_count();
+		pstat->pendingqWaitCount = get_status_pendingq_count();
+		pstat->totalOpenCount	 = get_status_totalopen_count();
+		pstat->cryptoDomain	 = get_status_domain_index();
+		get_status_status_mask(pstat->status);
+		get_status_qdepth_mask(pstat->qdepth);
+		
+		if (copy_to_user((struct ica_z90_status *) arg, pstat,
+				 sizeof(struct ica_z90_status)) != 0)
+			ret = -EFAULT;
+		kfree(pstat);
+		break;
+		
+	case Z90QUIESCE:
+		if (current->euid != 0) {
+			PRINTK("QUIESCE fails: euid %d\n",
+			       current->euid);
+			ret = -EACCES;
+		} else {
+			PRINTK("QUIESCE device from PID %d\n", PID());
+			quiesce_z90crypt = 1;
+		}
+		break;
+		
+	default:
+		/* user passed an invalid IOCTL number */
+		PDEBUG("cmd 0x%08X contains invalid ioctl code\n", cmd);
+		ret = -ENOTTY;
+		break;
+	}
+	
+	return ret;
+}
+
+static inline int
+sprintcl(unsigned char *outaddr, unsigned char *addr, unsigned int len)
+{
+	int hl, i;
+
+	hl = 0;
+	for (i = 0; i < len; i++)
+		hl += sprintf(outaddr+hl, "%01x", (unsigned int) addr[i]);
+	hl += sprintf(outaddr+hl, " ");
+
+	return hl;
+}
+
+static inline int
+sprintrw(unsigned char *outaddr, unsigned char *addr, unsigned int len)
+{
+	int hl, inl, c, cx;
+
+	hl = sprintf(outaddr, "	   ");
+	inl = 0;
+	for (c = 0; c < (len / 16); c++) {
+		hl += sprintcl(outaddr+hl, addr+inl, 16);
+		inl += 16;
+	}
+
+	cx = len%16;
+	if (cx) {
+		hl += sprintcl(outaddr+hl, addr+inl, cx);
+		inl += cx;
+	}
+
+	hl += sprintf(outaddr+hl, "\n");
+
+	return hl;
+}
+
+static inline int
+sprinthx(unsigned char *title, unsigned char *outaddr,
+	 unsigned char *addr, unsigned int len)
+{
+	int hl, inl, r, rx;
+
+	hl = sprintf(outaddr, "\n%s\n", title);
+	inl = 0;
+	for (r = 0; r < (len / 64); r++) {
+		hl += sprintrw(outaddr+hl, addr+inl, 64);
+		inl += 64;
+	}
+	rx = len % 64;
+	if (rx) {
+		hl += sprintrw(outaddr+hl, addr+inl, rx);
+		inl += rx;
+	}
+
+	hl += sprintf(outaddr+hl, "\n");
+
+	return hl;
+}
+
+static inline int
+sprinthx4(unsigned char *title, unsigned char *outaddr,
+	  unsigned int *array, unsigned int len)
+{
+	int hl, r;
+
+	hl = sprintf(outaddr, "\n%s\n", title);
+
+	for (r = 0; r < len; r++) {
+		if ((r % 8) == 0)
+			hl += sprintf(outaddr+hl, "    ");
+		hl += sprintf(outaddr+hl, "%08X ", array[r]);
+		if ((r % 8) == 7)
+			hl += sprintf(outaddr+hl, "\n");
+	}
+
+	hl += sprintf(outaddr+hl, "\n");
+
+	return hl;
+}
+
+static int
+z90crypt_status(char *resp_buff, char **start, off_t offset,
+		int count, int *eof, void *data)
+{
+	unsigned char *workarea;
+	int len;
+
+	/* resp_buff is a page. Use the right half for a work area */
+	workarea = resp_buff+2000;
+	len = 0;
+	len += sprintf(resp_buff+len, "\nz90crypt version: %d.%d.%d\n",
+		z90crypt_VERSION, z90crypt_RELEASE, z90crypt_VARIANT);
+	len += sprintf(resp_buff+len, "Cryptographic domain: %d\n",
+		get_status_domain_index());
+	len += sprintf(resp_buff+len, "Total device count: %d\n",
+		get_status_totalcount());
+	len += sprintf(resp_buff+len, "PCICA count: %d\n",
+		get_status_PCICAcount());
+	len += sprintf(resp_buff+len, "PCICC count: %d\n",
+		get_status_PCICCcount());
+	len += sprintf(resp_buff+len, "PCIXCC count: %d\n",
+		get_status_PCIXCCcount());
+	len += sprintf(resp_buff+len, "requestq count: %d\n",
+		get_status_requestq_count());
+	len += sprintf(resp_buff+len, "pendingq count: %d\n",
+		get_status_pendingq_count());
+	len += sprintf(resp_buff+len, "Total open handles: %d\n\n",
+		get_status_totalopen_count());
+	len += sprinthx(
+		"Online devices: 1 means PCICA, 2 means PCICC, 3 means PCIXCC",
+		resp_buff+len,
+		get_status_status_mask(workarea),
+		Z90CRYPT_NUM_APS);
+	len += sprinthx("Waiting work element counts",
+		resp_buff+len,
+		get_status_qdepth_mask(workarea),
+		Z90CRYPT_NUM_APS);
+	len += sprinthx4(
+		"Per-device successfully completed request counts",
+		resp_buff+len,
+		get_status_perdevice_reqcnt((unsigned int *)workarea),
+		Z90CRYPT_NUM_APS);
+	*eof = 1;
+	memset(workarea, 0, Z90CRYPT_NUM_APS * sizeof(unsigned int));
+	return len;
+}
+
+static inline void
+disable_card(int card_index)
+{
+	struct device *devp;
+
+	devp = LONG2DEVPTR(card_index);
+	if (!devp || devp->user_disabled)
+		return;
+	devp->user_disabled = 1;
+	z90crypt.hdware_info->hdware_mask.user_disabled_count++;
+	if (devp->dev_type == -1)
+		return;
+	z90crypt.hdware_info->type_mask[devp->dev_type].user_disabled_count++;
+}
+
+static inline void
+enable_card(int card_index)
+{
+	struct device *devp;
+
+	devp = LONG2DEVPTR(card_index);
+	if (!devp || !devp->user_disabled)
+		return;
+	devp->user_disabled = 0;
+	z90crypt.hdware_info->hdware_mask.user_disabled_count--;
+	if (devp->dev_type == -1)
+		return;
+	z90crypt.hdware_info->type_mask[devp->dev_type].user_disabled_count--;
+}
+
+static inline int
+scan_char(unsigned char *bf, unsigned int len,
+	  unsigned int *offs, unsigned int *p_eof, unsigned char c)
+{
+	unsigned int i, found;
+
+	found = 0;
+	for (i = 0; i < len; i++) {
+		if (bf[i] == c) {
+			found = 1;
+			break;
+		}
+		if (bf[i] == '\0') {
+			*p_eof = 1;
+			break;
+		}
+		if (bf[i] == '\n') {
+			break;
+		}
+	}
+	*offs = i+1;
+	return found;
+}
+
+static inline int
+scan_string(unsigned char *bf, unsigned int len,
+	    unsigned int *offs, unsigned int *p_eof, unsigned char *s)
+{
+	unsigned int temp_len, temp_offs, found, eof;
+
+	temp_len = temp_offs = found = eof = 0;
+	while (!eof && !found) {
+		found = scan_char(bf+temp_len, len-temp_len,
+				  &temp_offs, &eof, *s);
+
+		temp_len += temp_offs;
+		if (eof) {
+			found = 0;
+			break;
+		}
+
+		if (found) {
+			if (len >= temp_offs+strlen(s)) {
+				found = !strncmp(bf+temp_len-1, s, strlen(s));
+				if (found) {
+					*offs = temp_len+strlen(s)-1;
+					break;
+				}
+			} else {
+				found = 0;
+				*p_eof = 1;
+				break;
+			}
+		}
+	}
+	return found;
+}
+
+static int
+z90crypt_status_write(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	int i, j, len, offs, found, eof;
+	unsigned char *lbuf;
+	unsigned int local_count;
+
+#define LBUFSIZE 600
+	lbuf = kmalloc(LBUFSIZE, GFP_KERNEL);
+	if (!lbuf) {
+		PRINTK("kmalloc failed!\n");
+		return 0;
+	}
+
+	if (count <= 0)
+		return 0;
+
+	local_count = UMIN((unsigned int)count, LBUFSIZE-1);
+
+	if (copy_from_user(lbuf, buffer, local_count) != 0) {
+		kfree(lbuf);
+		return -EFAULT;
+	}
+
+	lbuf[local_count-1] = '\0';
+
+	len = 0;
+	eof = 0;
+	found = 0;
+	while (!eof) {
+		found = scan_string(lbuf+len, local_count-len, &offs, &eof,
+				    "Online devices");
+		len += offs;
+		if (found == 1)
+			break;
+	}
+
+	if (eof) {
+		kfree(lbuf);
+		return count;
+	}
+
+	if (found)
+		found = scan_char(lbuf+len, local_count-len, &offs, &eof, '\n');
+
+	if (!found || eof) {
+		kfree(lbuf);
+		return count;
+	}
+
+	len += offs;
+	j = 0;
+	for (i = 0; i < 80; i++) {
+		switch (*(lbuf+len+i)) {
+		case '\t':
+		case ' ':
+			break;
+		case '\n':
+		default:
+			eof = 1;
+			break;
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+			j++;
+			break;
+		case 'd':
+		case 'D':
+			disable_card(j);
+			j++;
+			break;
+		case 'e':
+		case 'E':
+			enable_card(j);
+			j++;
+			break;
+		}
+		if (eof)
+			break;
+	}
+
+	kfree(lbuf);
+	return count;
+}
+
+/**
+ * Functions that run under a timer, with no process id
+ *
+ * The task functions:
+ *     z90crypt_reader_task
+ *	 helper_send_work
+ *	 helper_handle_work_element
+ *	 helper_receive_rc
+ *     z90crypt_config_task
+ *     z90crypt_cleanup_task
+ *
+ * Helper functions:
+ *     z90crypt_schedule_reader_timer
+ *     z90crypt_schedule_reader_task
+ *     z90crypt_schedule_config_task
+ *     z90crypt_schedule_cleanup_task
+ */
+static inline int
+receive_from_crypto_device(int index, unsigned char *psmid, int *buff_len_p,
+			   unsigned char *buff, unsigned char **dest_p_p)
+{
+	int dv, rv;
+	struct device *dev_ptr;
+	struct caller *caller_p;
+	struct ica_rsa_modexpo *icaMsg_p;
+	struct list_head *ptr, *tptr;
+
+	memcpy(psmid, NULL_psmid, sizeof(NULL_psmid));
+
+	if (z90crypt.terminating)
+		return REC_FATAL_ERROR;
+
+	caller_p = 0;
+	dev_ptr = z90crypt.device_p[index];
+	rv = 0;
+	do {
+		PDEBUG("Dequeue called for device %d\n", index);
+		if (!dev_ptr || dev_ptr->disabled) {
+			rv = REC_NO_RESPONSE;
+			break;
+		}
+		if (dev_ptr->dev_self_x != index) {
+			PRINTK("Corrupt dev ptr in receive_from_AP\n");
+			z90crypt.terminating = 1;
+			rv = REC_FATAL_ERROR;
+			break;
+		}
+		if (!dev_ptr->dev_resp_l || !dev_ptr->dev_resp_p) {
+			dv = DEV_REC_EXCEPTION;
+			PRINTK("dev_resp_l = %d, dev_resp_p = %p\n",
+			       dev_ptr->dev_resp_l, dev_ptr->dev_resp_p);
+		} else {
+			dv = receive_from_AP(index, z90crypt.cdx,
+					     dev_ptr->dev_resp_l,
+					     dev_ptr->dev_resp_p, psmid);
+		}
+		switch (dv) {
+		case DEV_REC_EXCEPTION:
+			rv = REC_FATAL_ERROR;
+			z90crypt.terminating = 1;
+			PRINTKC("Exception in receive from device %d\n",
+				index);
+			break;
+		case DEV_ONLINE:
+			rv = 0;
+			break;
+		case DEV_EMPTY:
+			rv = REC_EMPTY;
+			break;
+		case DEV_NO_WORK:
+			rv = REC_NO_WORK;
+			break;
+		case DEV_BAD_MESSAGE:
+		case DEV_GONE:
+		case REC_HARDWAR_ERR:
+		default:
+			rv = REC_NO_RESPONSE;
+			break;
+		}
+		if (dev_ptr->dev_caller_count <= 0)
+			rv = REC_USER_GONE;
+		if (rv)
+			break;
+
+		list_for_each_safe(ptr, tptr, &dev_ptr->dev_caller_list) {
+			caller_p = list_entry(ptr, struct caller, caller_liste);
+			if (!memcmp(caller_p->caller_id, psmid,
+				    sizeof(caller_p->caller_id))) {
+				if (!list_empty(&caller_p->caller_liste)) {
+					list_del(ptr);
+					dev_ptr->dev_caller_count--;
+					INIT_LIST_HEAD(&caller_p->caller_liste);
+					break;
+				}
+			}
+			caller_p = 0;
+		}
+		if (!caller_p) {
+			rv = REC_USER_GONE;
+			break;
+		}
+
+		PDEBUG("caller_p after successful receive: %p\n", caller_p);
+		rv = convert_response(dev_ptr->dev_resp_p, dev_ptr->dev_type,
+				      caller_p->caller_buf_p, buff_len_p, buff);
+		switch (rv) {
+		case REC_OPERAND_INV:
+			PDEBUG("dev %d: user error %d\n", index, rv);
+			break;
+		case WRONG_DEVICE_TYPE:
+		case REC_HARDWAR_ERR:
+		case REC_BAD_MESSAGE:
+			PRINTK("dev %d: hardware error %d\n",
+			       index, rv);
+			rv = REC_NO_RESPONSE;
+			break;
+		case REC_RELEASED:
+			PDEBUG("dev %d: REC_RELEASED = %d\n",
+			       index, rv);
+			break;
+		default:
+			PDEBUG("dev %d: rv = %d\n", index, rv);
+			break;
+		}
+	} while (0);
+
+	switch (rv) {
+	case 0:
+		PDEBUG("Successful receive from device %d\n", index);
+		icaMsg_p = (struct ica_rsa_modexpo *)caller_p->caller_buf_p;
+		*dest_p_p = icaMsg_p->outputdata;
+		if (*buff_len_p == 0)
+			PRINTK("Zero *buff_len_p\n");
+		break;
+	case REC_NO_RESPONSE:
+		remove_device(dev_ptr);
+		break;
+	}
+	
+	if (caller_p)
+		unbuild_caller(dev_ptr, caller_p);
+
+	return rv;
+}
+
+static inline void
+helper_send_work(int index)
+{
+	struct work_element *rq_p;
+	int rv;
+
+	if (list_empty(&request_list))
+		return;
+	requestq_count--;
+	rq_p = list_entry(request_list.next, struct work_element, liste);
+	list_del(&rq_p->liste);
+	rq_p->audit[1] |= FP_REMREQUEST;
+	if (rq_p->devtype == SHRT2DEVPTR(index)->dev_type) {
+		rq_p->devindex = SHRT2LONG(index);
+		rv = send_to_crypto_device(rq_p->caller_id,
+					   rq_p->funccode,
+					   rq_p->buff_size,
+					   rq_p->buffer,
+					   rq_p->devtype,
+					   &rq_p->devindex,
+					   rq_p->requestptr);
+		if (rv == 0) {
+			rq_p->requestsent = jiffies;
+			rq_p->audit[0] |= FP_SENT;
+			list_add_tail(&rq_p->liste, &pending_list);
+			++pendingq_count;
+			rq_p->audit[0] |= FP_PENDING;
+		} else {
+			switch (rv) {
+			case REC_OPERAND_INV:
+			case REC_OPERAND_SIZE:
+			case REC_EVEN_MOD:
+			case REC_INVALID_PAD:
+				rq_p->retcode = -EINVAL;
+				break;
+			case SEN_NOT_AVAIL:
+			case SEN_RETRY:
+			case REC_NO_RESPONSE:
+			default:
+				if (z90crypt.mask.st_count > 1)
+					rq_p->retcode =
+						-ERESTARTSYS;
+				else
+					rq_p->retcode = -ENODEV;
+				break;
+			}
+			rq_p->status[0] |= STAT_FAILED;
+			rq_p->audit[1] |= FP_AWAKENING;
+			atomic_set(&rq_p->alarmrung, 1);
+			wake_up(&rq_p->waitq);
+		}
+	} else {
+		if (z90crypt.mask.st_count > 1)
+			rq_p->retcode = -ERESTARTSYS;
+		else
+			rq_p->retcode = -ENODEV;
+		rq_p->status[0] |= STAT_FAILED;
+		rq_p->audit[1] |= FP_AWAKENING;
+		atomic_set(&rq_p->alarmrung, 1);
+		wake_up(&rq_p->waitq);
+	}
+}
+
+static inline void
+helper_handle_work_element(int index, unsigned char psmid[8], int rc,
+			   int buff_len, unsigned char *buff,
+			   unsigned char *resp_addr)
+{
+	struct work_element *pq_p;
+	struct list_head *lptr, *tptr;
+
+	pq_p = 0;
+	list_for_each_safe(lptr, tptr, &pending_list) {
+		pq_p = list_entry(lptr, struct work_element, liste);
+		if (!memcmp(pq_p->caller_id, psmid, sizeof(pq_p->caller_id))) {
+			list_del(lptr);
+			pendingq_count--;
+			pq_p->audit[1] |= FP_NOTPENDING;
+			break;
+		}
+		pq_p = 0;
+	}
+
+	if (!pq_p) {
+		PRINTK("device %d has work but no caller exists on pending Q\n",
+		       SHRT2LONG(index));
+		return;
+	}
+
+	switch (rc) {
+		case 0:
+			pq_p->resp_buff_size = buff_len;
+			pq_p->audit[1] |= FP_RESPSIZESET;
+			if (buff_len) {
+				pq_p->resp_addr = resp_addr;
+				pq_p->audit[1] |= FP_RESPADDRCOPIED;
+				memcpy(pq_p->resp_buff, buff, buff_len);
+				pq_p->audit[1] |= FP_RESPBUFFCOPIED;
+			}
+			break;
+		case REC_OPERAND_INV:
+		case REC_OPERAND_SIZE:
+		case REC_EVEN_MOD:
+		case REC_INVALID_PAD:
+			PDEBUG("-EINVAL after application error %d\n", rc);
+			pq_p->retcode = -EINVAL;
+			pq_p->status[0] |= STAT_FAILED;
+			break;
+		case REC_NO_RESPONSE:
+		default:
+			if (z90crypt.mask.st_count > 1)
+				pq_p->retcode = -ERESTARTSYS;
+			else
+				pq_p->retcode = -ENODEV;
+			pq_p->status[0] |= STAT_FAILED;
+			break;
+	}
+	if ((pq_p->status[0] != STAT_FAILED) || (pq_p->retcode != -ERELEASED)) {
+		pq_p->audit[1] |= FP_AWAKENING;
+		atomic_set(&pq_p->alarmrung, 1);
+		wake_up(&pq_p->waitq);
+	}
+}
+
+/**
+ * return TRUE if the work element should be removed from the queue
+ */
+static inline int
+helper_receive_rc(int index, int *rc_p, int *workavail_p)
+{
+	switch (*rc_p) {
+	case 0:
+	case REC_OPERAND_INV:
+	case REC_OPERAND_SIZE:
+	case REC_EVEN_MOD:
+	case REC_INVALID_PAD:
+		return 1;
+		
+	case REC_BUSY:
+	case REC_NO_WORK:
+	case REC_EMPTY:
+	case REC_RETRY_DEV:
+	case REC_FATAL_ERROR:
+		break;
+		
+	case REC_NO_RESPONSE:
+		*workavail_p = 0;
+		break;
+		
+	default:
+		PRINTK("rc %d, device %d\n", *rc_p, SHRT2LONG(index));
+		*rc_p = REC_NO_RESPONSE;
+		*workavail_p = 0;
+		break;
+	}
+	return 0;
+}
+
+static inline void
+z90crypt_schedule_reader_timer(void)
+{
+	if (timer_pending(&reader_timer))
+		return;
+	if (mod_timer(&reader_timer, jiffies+(READERTIME*HZ/1000)) != 0)
+		PRINTK("Timer pending while modifying reader timer\n");
+}
+
+static void
+z90crypt_reader_task(unsigned long ptr)
+{
+	int workavail, remaining, index, rc, buff_len;
+	unsigned char	psmid[8], *resp_addr;
+	static unsigned char buff[1024];
+
+	PDEBUG("jiffies %ld\n", jiffies);
+
+	/**
+	 * we use workavail = 2 to ensure 2 passes with nothing dequeued before
+	 * exiting the loop. If remaining == 0 after the loop, there is no work
+	 * remaining on the queues.
+	 */
+	resp_addr = 0;
+	workavail = 2;
+	remaining = 0;
+	buff_len = 0;
+	while (workavail) {
+		workavail--;
+		rc = 0;
+		spin_lock_irq(&queuespinlock);
+		memset(buff, 0x00, sizeof(buff));
+
+		/* Dequeue once from each device in round robin. */
+		for (index = 0; index < z90crypt.mask.st_count; index++) {
+			PDEBUG("About to receive.\n");
+			rc = receive_from_crypto_device(SHRT2LONG(index),
+							psmid,
+							&buff_len,
+							buff,
+							&resp_addr);
+			PDEBUG("Dequeued: rc = %d.\n", rc);
+
+			if (helper_receive_rc(index, &rc, &workavail)) {
+				if (rc != REC_NO_RESPONSE) {
+					helper_send_work(index);
+					workavail = 2;
+				}
+
+				helper_handle_work_element(index, psmid, rc,
+							   buff_len, buff,
+							   resp_addr);
+			}
+
+			if (rc == REC_FATAL_ERROR)
+				remaining = 0;
+			else if (rc != REC_NO_RESPONSE)
+				remaining +=
+					SHRT2DEVPTR(index)->dev_caller_count;
+		}
+		spin_unlock_irq(&queuespinlock);
+	}
+
+	if (remaining) {
+		spin_lock_irq(&queuespinlock);
+		z90crypt_schedule_reader_timer();
+		spin_unlock_irq(&queuespinlock);
+	}
+}
+
+static inline void
+z90crypt_schedule_config_task(unsigned int expiration)
+{
+	if (timer_pending(&config_timer))
+		return;
+	if (mod_timer(&config_timer, jiffies+(expiration*HZ)) != 0)
+		PRINTK("Timer pending while modifying config timer\n");
+}
+
+static void 
+z90crypt_config_task(unsigned long ptr)
+{
+	int rc;
+
+	PDEBUG("jiffies %ld\n", jiffies);
+
+	if ((rc = refresh_z90crypt(&z90crypt.cdx)))
+		PRINTK("Error %d detected in refresh_z90crypt.\n", rc);
+	/* If return was fatal, don't bother reconfiguring */
+	if ((rc != TSQ_FATAL_ERROR) && (rc != RSQ_FATAL_ERROR))
+		z90crypt_schedule_config_task(CONFIGTIME);
+}
+
+static inline void
+z90crypt_schedule_cleanup_task(void)
+{
+	if (timer_pending(&cleanup_timer))
+		return;
+	if (mod_timer(&cleanup_timer, jiffies+(CLEANUPTIME*HZ)) != 0)
+		PRINTK("Timer pending while modifying cleanup timer\n");
+}
+
+static inline void
+helper_drain_queues(void)
+{
+	struct work_element *pq_p;
+	struct list_head *lptr, *tptr;
+
+	list_for_each_safe(lptr, tptr, &pending_list) {
+		pq_p = list_entry(lptr, struct work_element, liste);
+		pq_p->retcode = -ENODEV;
+		pq_p->status[0] |= STAT_FAILED;
+		unbuild_caller(LONG2DEVPTR(pq_p->devindex),
+			       (struct caller *)pq_p->requestptr);
+		list_del(lptr);
+		pendingq_count--;
+		pq_p->audit[1] |= FP_NOTPENDING;
+		pq_p->audit[1] |= FP_AWAKENING;
+		atomic_set(&pq_p->alarmrung, 1);
+		wake_up(&pq_p->waitq);
+	}
+
+	list_for_each_safe(lptr, tptr, &request_list) {
+		pq_p = list_entry(lptr, struct work_element, liste);
+		pq_p->retcode = -ENODEV;
+		pq_p->status[0] |= STAT_FAILED;
+		list_del(lptr);
+		requestq_count--;
+		pq_p->audit[1] |= FP_REMREQUEST;
+		pq_p->audit[1] |= FP_AWAKENING;
+		atomic_set(&pq_p->alarmrung, 1);
+		wake_up(&pq_p->waitq);
+	}
+}
+
+static inline void
+helper_timeout_requests(void)
+{
+	struct work_element *pq_p;
+	struct list_head *lptr, *tptr;
+	long timelimit;
+
+	timelimit = jiffies - (CLEANUPTIME * HZ);
+	/* The list is in strict chronological order */
+	list_for_each_safe(lptr, tptr, &pending_list) {
+		pq_p = list_entry(lptr, struct work_element, liste);
+		if (pq_p->requestsent >= timelimit)
+			break;
+		pq_p->retcode = -ETIMEOUT;
+		pq_p->status[0] |= STAT_FAILED;
+		/* get this off any caller queue it may be on */
+		unbuild_caller(LONG2DEVPTR(pq_p->devindex),
+			       (struct caller *) pq_p->requestptr);
+		list_del(lptr);
+		pendingq_count--;
+		pq_p->audit[1] |= FP_TIMEDOUT;
+		pq_p->audit[1] |= FP_NOTPENDING;
+		pq_p->audit[1] |= FP_AWAKENING;
+		atomic_set(&pq_p->alarmrung, 1);
+		wake_up(&pq_p->waitq);
+	}
+
+	/**
+	 * If pending count is zero, items left on the request queue may
+	 * never be processed.
+	 */
+	if (pendingq_count <= 0) {
+		list_for_each_safe(lptr, tptr, &request_list) {
+			pq_p = list_entry(lptr, struct work_element, liste);
+			if (pq_p->requestsent >= timelimit)
+				break;
+			pq_p->retcode = -ETIMEOUT;
+			pq_p->status[0] |= STAT_FAILED;
+			list_del(lptr);
+			requestq_count--;
+			pq_p->audit[1] |= FP_TIMEDOUT;
+			pq_p->audit[1] |= FP_REMREQUEST;
+			pq_p->audit[1] |= FP_AWAKENING;
+			atomic_set(&pq_p->alarmrung, 1);
+			wake_up(&pq_p->waitq);
+		}
+	}
+}
+
+static void
+z90crypt_cleanup_task(unsigned long ptr)
+{
+	PDEBUG("jiffies %ld\n", jiffies);
+	spin_lock_irq(&queuespinlock);
+	if (z90crypt.mask.st_count <= 0) // no devices!
+		helper_drain_queues();
+	else
+		helper_timeout_requests();
+	spin_unlock_irq(&queuespinlock);
+	z90crypt_schedule_cleanup_task();
+}
+
+static void
+z90crypt_schedule_reader_task(unsigned long ptr)
+{
+	tasklet_schedule(&reader_tasklet);
+}
+
+/**
+ * Lowlevel Functions:
+ *
+ *   create_z90crypt:  creates and initializes basic data structures
+ *   refresh_z90crypt:	re-initializes basic data structures
+ *   find_crypto_devices: returns a count and mask of hardware status
+ *   create_crypto_device:  builds the descriptor for a device
+ *   destroy_crypto_device:  unallocates the descriptor for a device
+ *   destroy_z90crypt:	drains all work, unallocates structs
+ */
+
+/**
+ * build the z90crypt root structure using the given domain index
+ */
+static int
+create_z90crypt(int *cdx_p)
+{
+	struct hdware_block *hdware_blk_p;
+
+	memset(&z90crypt, 0x00, sizeof(struct z90crypt));
+	z90crypt.domain_established = 0;
+	z90crypt.len = sizeof(struct z90crypt);
+	z90crypt.max_count = Z90CRYPT_NUM_DEVS;
+	z90crypt.cdx = *cdx_p;
+
+	hdware_blk_p = (struct hdware_block *)
+		kmalloc(sizeof(struct hdware_block), GFP_ATOMIC);
+	if (!hdware_blk_p) {
+		PDEBUG("kmalloc for hardware block failed\n");
+		return ENOMEM;
+	}
+	memset(hdware_blk_p, 0x00, sizeof(struct hdware_block));
+	z90crypt.hdware_info = hdware_blk_p;
+
+	return 0;
+}
+
+static inline int
+helper_scan_devices(int cdx_array[16], int *cdx_p, int *correct_cdx_found)
+{
+	enum hdstat hd_stat;
+	int q_depth, dev_type;
+	int i, j, k;
+
+	q_depth = dev_type = k = 0;
+	for (i = 0; i < z90crypt.max_count; i++) {
+		hd_stat = HD_NOT_THERE;
+		for (j = 0; j < 15; cdx_array[j++] = -1);
+		k = 0;
+		for (j = 0; j < 15; j++) {
+			hd_stat = query_online(i, j, MAX_RESET,
+					       &q_depth, &dev_type);
+			if (hd_stat == HD_TSQ_EXCEPTION) {
+				z90crypt.terminating = 1;
+				PRINTKC("exception taken!\n");
+				break;
+			}
+			if (hd_stat == HD_ONLINE) {
+				cdx_array[k++] = j;
+				if (*cdx_p == j) {
+					*correct_cdx_found  = 1;
+					break;
+				}
+			}
+		}
+		if ((*correct_cdx_found == 1) || (k != 0))
+			break;
+		if (z90crypt.terminating)
+			break;
+	}
+	return k;
+}
+
+static inline int
+probe_crypto_domain(int *cdx_p)
+{
+	int cdx_array[16];
+	int correct_cdx_found, k;
+
+	correct_cdx_found = 0;
+	k = helper_scan_devices(cdx_array, cdx_p, &correct_cdx_found);
+
+	if (z90crypt.terminating)
+		return TSQ_FATAL_ERROR;
+
+	if (correct_cdx_found)
+		return 0;
+
+	if (k == 0) {
+		*cdx_p = 0;
+		return 0;
+	}
+
+	if (k == 1) {
+		if ((*cdx_p == -1) || !z90crypt.domain_established) {
+			*cdx_p = cdx_array[0];
+			return 0;
+		}
+		if (*cdx_p != cdx_array[0]) {
+			PRINTK("incorrect domain: specified = %d, found = %d\n",
+			       *cdx_p, cdx_array[0]);
+			return Z90C_INCORRECT_DOMAIN;
+		}
+	}
+
+	return Z90C_AMBIGUOUS_DOMAIN;
+}
+
+static int
+refresh_z90crypt(int *cdx_p)
+{
+	int i, j, indx, rv;
+	struct status local_mask;
+	struct device *devPtr;
+	unsigned char oldStat, newStat;
+	int return_unchanged;
+
+	if (z90crypt.len != sizeof(z90crypt))
+		return ENOTINIT;
+	if (z90crypt.terminating)
+		return TSQ_FATAL_ERROR;
+	rv = 0;
+	if (!z90crypt.hdware_info->hdware_mask.st_count &&
+	    !z90crypt.domain_established)
+		rv = probe_crypto_domain(cdx_p);
+	if (z90crypt.terminating)
+		return TSQ_FATAL_ERROR;
+	if (rv) {
+		switch (rv) {
+		case Z90C_AMBIGUOUS_DOMAIN:
+			PRINTK("ambiguous domain detected\n");
+			break;
+		case Z90C_INCORRECT_DOMAIN:
+			PRINTK("incorrect domain specified\n");
+			break;
+		default:
+			PRINTK("probe domain returned %d\n", rv);
+			break;
+		}
+		return rv;
+	}
+	if (*cdx_p) {
+		z90crypt.cdx = *cdx_p;
+		z90crypt.domain_established = 1;
+	}
+	rv = find_crypto_devices(&local_mask);
+	if (rv) {
+		PRINTK("find crypto devices returned %d\n", rv);
+		return rv;
+	}
+	if (!memcmp(&local_mask, &z90crypt.hdware_info->hdware_mask,
+		    sizeof(struct status))) {
+		return_unchanged = 1;
+		for (i = 0; i < Z90CRYPT_NUM_TYPES; i++) {
+			/**
+			 * Check for disabled cards.  If any device is marked
+			 * disabled, destroy it.
+			 */
+			for (j = 0;
+			     j < z90crypt.hdware_info->type_mask[i].st_count;
+			     j++) {
+				indx = z90crypt.hdware_info->type_x_addr[i].
+								device_index[j];
+				devPtr = z90crypt.device_p[indx];
+				if (devPtr && devPtr->disabled) {
+					local_mask.st_mask[indx] = HD_NOT_THERE;
+					return_unchanged = 0;
+				}
+			}
+		}
+		if (return_unchanged == 1)
+			return 0;
+	}
+
+	spin_lock_irq(&queuespinlock);
+	for (i = 0; i < z90crypt.max_count; i++) {
+		oldStat = z90crypt.hdware_info->hdware_mask.st_mask[i];
+		newStat = local_mask.st_mask[i];
+		if ((oldStat == HD_ONLINE) && (newStat != HD_ONLINE))
+			destroy_crypto_device(i);
+		else if ((oldStat != HD_ONLINE) && (newStat == HD_ONLINE)) {
+			rv = create_crypto_device(i);
+			if (rv >= REC_FATAL_ERROR)
+				return rv;
+			if (rv != 0) {
+				local_mask.st_mask[i] = HD_NOT_THERE;
+				local_mask.st_count--;
+			}
+		}
+	}
+	memcpy(z90crypt.hdware_info->hdware_mask.st_mask, local_mask.st_mask,
+	       sizeof(local_mask.st_mask));
+	z90crypt.hdware_info->hdware_mask.st_count = local_mask.st_count;
+	z90crypt.hdware_info->hdware_mask.disabled_count =
+						      local_mask.disabled_count;
+	refresh_index_array(&z90crypt.mask, &z90crypt.overall_device_x);
+	for (i = 0; i < Z90CRYPT_NUM_TYPES; i++)
+		refresh_index_array(&(z90crypt.hdware_info->type_mask[i]),
+				    &(z90crypt.hdware_info->type_x_addr[i]));
+	spin_unlock_irq(&queuespinlock);
+
+	return rv;
+}
+
+static int
+find_crypto_devices(struct status *deviceMask)
+{
+	int i, q_depth, dev_type;
+	enum hdstat hd_stat;
+
+	deviceMask->st_count = 0;
+	deviceMask->disabled_count = 0;
+	deviceMask->user_disabled_count = 0;
+
+	for (i = 0; i < z90crypt.max_count; i++) {
+		hd_stat = query_online(i, z90crypt.cdx, MAX_RESET, &q_depth,
+				       &dev_type);
+		if (hd_stat == HD_TSQ_EXCEPTION) {
+			z90crypt.terminating = 1;
+			PRINTKC("Exception during probe for crypto devices\n");
+			return TSQ_FATAL_ERROR;
+		}
+		deviceMask->st_mask[i] = hd_stat;
+		if (hd_stat == HD_ONLINE) {
+			PDEBUG("Got an online crypto!: %d\n", i);
+			PDEBUG("Got a queue depth of %d\n", q_depth);
+			PDEBUG("Got a device type of %d\n", dev_type);
+			if (q_depth <= 0)
+				return TSQ_FATAL_ERROR;
+			deviceMask->st_count++;
+			z90crypt.q_depth_array[i] = q_depth;
+			z90crypt.dev_type_array[i] = dev_type;
+		}
+	}
+
+	return 0;
+}
+
+static int
+refresh_index_array(struct status *status_str, struct device_x *index_array)
+{
+	int i, count;
+	enum devstat stat;
+
+	i = -1;
+	count = 0;
+	do {
+		stat = status_str->st_mask[++i];
+		if (stat == DEV_ONLINE)
+			index_array->device_index[count++] = i;
+	} while ((i < Z90CRYPT_NUM_DEVS) && (count < status_str->st_count));
+
+	return count;
+}
+
+static int
+create_crypto_device(int index)
+{
+	int rv, devstat, total_size;
+	struct device *dev_ptr;
+	struct status *type_str_p;
+	int deviceType;
+
+	dev_ptr = z90crypt.device_p[index];
+	if (!dev_ptr) {
+		total_size = sizeof(struct device) +
+			     z90crypt.q_depth_array[index] * sizeof(int);
+
+		dev_ptr = (struct device *) kmalloc(total_size, GFP_ATOMIC);
+		if (!dev_ptr) {
+			PRINTK("kmalloc device %d failed\n", index);
+			return ENOMEM;
+		}
+		memset(dev_ptr, 0, total_size);
+		dev_ptr->dev_resp_p = kmalloc(MAX_RESPONSE_SIZE, GFP_ATOMIC);
+		if (!dev_ptr->dev_resp_p) {
+			kfree(dev_ptr);
+			PRINTK("kmalloc device %d rec buffer failed\n", index);
+			return ENOMEM;
+		}
+		dev_ptr->dev_resp_l = MAX_RESPONSE_SIZE;
+		INIT_LIST_HEAD(&(dev_ptr->dev_caller_list));
+	}
+
+	devstat = reset_device(index, z90crypt.cdx, MAX_RESET);
+	if (devstat == DEV_RSQ_EXCEPTION) {
+		PRINTK("exception during reset device %d\n", index);
+		kfree(dev_ptr->dev_resp_p);
+		kfree(dev_ptr);
+		return RSQ_FATAL_ERROR;
+	}
+	if (devstat == DEV_ONLINE) {
+		dev_ptr->dev_self_x = index;
+		dev_ptr->dev_type = z90crypt.dev_type_array[index];
+		if (dev_ptr->dev_type == NILDEV) {
+			rv = probe_device_type(dev_ptr);
+			if (rv) {
+				kfree(dev_ptr->dev_resp_p);
+				kfree(dev_ptr);
+				return rv;
+			}
+		}
+		deviceType = dev_ptr->dev_type;
+		z90crypt.dev_type_array[index] = deviceType;
+		if (deviceType == PCICA)
+			z90crypt.hdware_info->device_type_array[index] = 1;
+		else if (deviceType == PCICC)
+			z90crypt.hdware_info->device_type_array[index] = 2;
+		else if (deviceType == PCIXCC)
+			z90crypt.hdware_info->device_type_array[index] = 3;
+		else
+			z90crypt.hdware_info->device_type_array[index] = -1;
+	}
+
+	/**
+	 * 'q_depth' returned by the hardware is one less than
+	 * the actual depth
+	 */
+	dev_ptr->dev_q_depth = z90crypt.q_depth_array[index];
+	dev_ptr->dev_type = z90crypt.dev_type_array[index];
+	dev_ptr->dev_stat = devstat;
+	dev_ptr->disabled = 0;
+	z90crypt.device_p[index] = dev_ptr;
+
+	if (devstat == DEV_ONLINE) {
+		if (z90crypt.mask.st_mask[index] != DEV_ONLINE) {
+			z90crypt.mask.st_mask[index] = DEV_ONLINE;
+			z90crypt.mask.st_count++;
+		}
+		deviceType = dev_ptr->dev_type;
+		type_str_p = &z90crypt.hdware_info->type_mask[deviceType];
+		if (type_str_p->st_mask[index] != DEV_ONLINE) {
+			type_str_p->st_mask[index] = DEV_ONLINE;
+			type_str_p->st_count++;
+		}
+	}
+
+	return 0;
+}
+
+static int
+destroy_crypto_device(int index)
+{
+	struct device *dev_ptr;
+	int t, disabledFlag;
+
+	dev_ptr = z90crypt.device_p[index];
+
+	/* remember device type; get rid of device struct */
+	if (dev_ptr) {
+		disabledFlag = dev_ptr->disabled;
+		t = dev_ptr->dev_type;
+		if (dev_ptr->dev_resp_p)
+			kfree(dev_ptr->dev_resp_p);
+		kfree(dev_ptr);
+	} else {
+		disabledFlag = 0;
+		t = -1;
+	}
+	z90crypt.device_p[index] = 0;
+
+	/* if the type is valid, remove the device from the type_mask */
+	if ((t != -1) && z90crypt.hdware_info->type_mask[t].st_mask[index]) {
+		  z90crypt.hdware_info->type_mask[t].st_mask[index] = 0x00;
+		  z90crypt.hdware_info->type_mask[t].st_count--;
+		  if (disabledFlag == 1)
+			z90crypt.hdware_info->type_mask[t].disabled_count--;
+	}
+	if (z90crypt.mask.st_mask[index] != DEV_GONE) {
+		z90crypt.mask.st_mask[index] = DEV_GONE;
+		z90crypt.mask.st_count--;
+	}
+	z90crypt.hdware_info->device_type_array[index] = 0;
+
+	return 0;
+}
+
+static void
+destroy_z90crypt(void)
+{
+	int i;
+	for (i = 0; i < z90crypt.max_count; i++)
+		if (z90crypt.device_p[i])
+			destroy_crypto_device(i);
+	if (z90crypt.hdware_info)
+		kfree((void *)z90crypt.hdware_info);
+	memset((void *)&z90crypt, 0, sizeof(z90crypt));
+}
+
+static unsigned char static_testmsg[] = {
+0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x00,0x06,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x43,0x43,
+0x41,0x2d,0x41,0x50,0x50,0x4c,0x20,0x20,0x20,0x01,0x01,0x01,0x00,0x00,0x00,0x00,
+0x50,0x4b,0x00,0x00,0x00,0x00,0x01,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x05,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x70,0x00,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x32,
+0x01,0x00,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0xb8,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x49,0x43,0x53,0x46,
+0x20,0x20,0x20,0x20,0x50,0x4b,0x0a,0x00,0x50,0x4b,0x43,0x53,0x2d,0x31,0x2e,0x32,
+0x37,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,0x11,0x22,0x33,0x44,
+0x55,0x66,0x77,0x88,0x99,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,
+0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,0x11,0x22,0x33,0x44,0x55,0x66,
+0x77,0x88,0x99,0x00,0x11,0x22,0x33,0x5d,0x00,0x5b,0x00,0x77,0x88,0x1e,0x00,0x00,
+0x57,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x4f,0x00,0x00,0x00,0x03,0x02,0x00,0x00,
+0x40,0x01,0x00,0x01,0xce,0x02,0x68,0x2d,0x5f,0xa9,0xde,0x0c,0xf6,0xd2,0x7b,0x58,
+0x4b,0xf9,0x28,0x68,0x3d,0xb4,0xf4,0xef,0x78,0xd5,0xbe,0x66,0x63,0x42,0xef,0xf8,
+0xfd,0xa4,0xf8,0xb0,0x8e,0x29,0xc2,0xc9,0x2e,0xd8,0x45,0xb8,0x53,0x8c,0x6f,0x4e,
+0x72,0x8f,0x6c,0x04,0x9c,0x88,0xfc,0x1e,0xc5,0x83,0x55,0x57,0xf7,0xdd,0xfd,0x4f,
+0x11,0x36,0x95,0x5d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+static int
+probe_device_type(struct device *devPtr)
+{
+	int rv, dv, i, index, length;
+	unsigned char psmid[8], *dyn_testmsg;
+
+	dyn_testmsg = kmalloc(384, GFP_KERNEL);
+	if (!dyn_testmsg) {
+		PRINTK("kmalloc for dyn_testmsg failed in probe_device_type\n");
+		/**
+		 * Strange to return 0, but it will work. Since we didn't
+		 * update the device type, the next time around, we will
+		 * reprobe and hopefully have enough memory.
+		 */
+		return 0;
+	}
+
+	index = devPtr->dev_self_x;
+	rv = 0;
+	do {
+		memcpy(dyn_testmsg, static_testmsg, sizeof(static_testmsg));
+		length = sizeof(static_testmsg) - 24;
+		/* the -24 allows for the header */
+		dv = send_to_AP(index, z90crypt.cdx, length, dyn_testmsg);
+		if (dv) {
+			PDEBUG("dv returned by send during probe: %d\n", dv);
+			if (dv == DEV_SEN_EXCEPTION) {
+				rv = SEN_FATAL_ERROR;
+				PRINTKC("exception in send to AP %d\n", index);
+				break;
+			}
+			PDEBUG("return value from send_to_AP: %d\n", rv);
+			switch (dv) {
+			case DEV_GONE:
+				PDEBUG("dev %d not available\n", index);
+				rv = SEN_NOT_AVAIL;
+				break;
+			case DEV_ONLINE:
+				rv = 0;
+				break;
+			case DEV_EMPTY:
+				rv = SEN_NOT_AVAIL;
+				break;
+			case DEV_NO_WORK:
+				rv = SEN_FATAL_ERROR;
+				break;
+			case DEV_BAD_MESSAGE:
+				rv = SEN_USER_ERROR;
+				break;
+			case DEV_QUEUE_FULL:
+				rv = SEN_QUEUE_FULL;
+					break;
+			default:
+				break;
+			}
+		}
+
+		if (rv)
+			break;
+
+		for (i = 0; i < 6; i++) {
+			mdelay(300);
+			dv = receive_from_AP(index, z90crypt.cdx,
+					     devPtr->dev_resp_l,
+					     devPtr->dev_resp_p, psmid);
+			PDEBUG("dv returned by DQ = %d\n", dv);
+			if (dv == DEV_REC_EXCEPTION) {
+				rv = REC_FATAL_ERROR;
+				PRINTKC("exception in dequeue %d\n",
+					index);
+				break;
+			}
+			switch (dv) {
+			case DEV_ONLINE:
+				rv = 0;
+				break;
+			case DEV_EMPTY:
+				rv = REC_EMPTY;
+				break;
+			case DEV_NO_WORK:
+				rv = REC_NO_WORK;
+				break;
+			case DEV_BAD_MESSAGE:
+			case DEV_GONE:
+			default:
+				rv = REC_NO_RESPONSE;
+				break;
+			}
+			if ((rv != 0) && (rv != REC_NO_WORK))
+				break;
+			if (rv == 0)
+				break;
+		}
+		if (rv)
+			break;
+		rv = (devPtr->dev_resp_p[0] == 0x00) &&
+		     (devPtr->dev_resp_p[0] == 0x86);
+		if (rv) {
+			devPtr->dev_type = PCICC;
+			break;
+		}
+		devPtr->dev_type = PCICA;
+		rv = 0;
+	} while (0);
+	/* In a general error case, the card is not marked online */
+	kfree(dyn_testmsg);
+	return rv;
+}
+
+#ifdef Z90CRYPT_USE_HOTPLUG
+void
+z90crypt_hotplug_event(int dev_major, int dev_minor, int action)
+{
+#ifdef CONFIG_HOTPLUG
+	char *argv[3];
+	char *envp[6];
+	char  major[20];
+	char  minor[20];
+
+	sprintf(major, "MAJOR=%d", dev_major);
+	sprintf(minor, "MINOR=%d", dev_minor);
+
+	argv[0] = hotplug_path;
+	argv[1] = "z90crypt";
+	argv[2] = 0;
+
+	envp[0] = "HOME=/";
+	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+
+	switch (action) {
+	case Z90CRYPT_HOTPLUG_ADD:
+		envp[2] = "ACTION=add";
+		break;
+	case Z90CRYPT_HOTPLUG_REMOVE:
+		envp[2] = "ACTION=remove";
+		break;
+	default:
+		BUG();
+	}
+	envp[3] = major;
+	envp[4] = minor;
+	envp[5] = 0;
+
+	call_usermodehelper(argv[0], argv, envp, 0);
+#endif
+}
+#endif
+
+module_init(z90crypt_init_module);
+module_exit(z90crypt_cleanup_module);
