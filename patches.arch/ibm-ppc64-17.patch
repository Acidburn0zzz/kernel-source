ChangeSet
  1.1544 04/03/31 09:34:06 boutcher@skunk.rchland.ibm.com +1 -0
  ibmvscsi fix buffer freeing in error paths and request counting

  drivers/scsi/ibmvscsi/ibmvscsi.c
    1.16 04/03/31 09:30:08 boutcher@skunk.rchland.ibm.com +13 -15
    Fix request limit counting and buffer freeing in error paths

diff -Nru a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
--- a/drivers/scsi/ibmvscsi/ibmvscsi.c	Thu Apr  1 06:44:31 2004
+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c	Thu Apr  1 06:44:31 2004
@@ -481,8 +481,11 @@
 	 * (such as task management requests) that the mid layer may think we
 	 * can handle more requests (can_queue) when we actually can't
 	 */
-	if (atomic_dec_if_positive(&hostdata->request_limit) < 0) {
+	if ((evt_struct->crq.format == VIOSRP_SRP_FORMAT) &&
+	    (atomic_dec_if_positive(&hostdata->request_limit) < 0)) {
 		printk("ibmvscsi: Warning, request_limit exceeded\n");
+		unmap_cmd_data(&evt_struct->evt->srp.cmd, hostdata->dev);
+		ibmvscsi_free_event_struct(&hostdata->pool, evt_struct);
 		return SCSI_MLQUEUE_HOST_BUSY;
 	}
 
@@ -615,8 +618,6 @@
  * ibmvscsi_queue: - The queuecommand function of the scsi template 
  * @cmd:	struct scsi_cmnd to be executed
  * @done:	Callback function to be called when cmd is completed
- *
- * Always returns zero
 */
 static
 int ibmvscsi_queuecommand(struct scsi_cmnd *cmd,
@@ -658,15 +659,13 @@
 		printk("ibmvscsi: error %d getting adapter info\n",
 		       evt_struct->evt->mad.adapter_info.common.status);
 	} else {
-		printk("ibmvscsi: host srp version: %16.16x, "
+		printk("ibmvscsi: host srp version: %s, "
 		       "host partition %s (%d), OS %d\n",
-		       *(unsigned int *)hostdata->madapter_info.srp_version,
+		       hostdata->madapter_info.srp_version,
 		       hostdata->madapter_info.partition_name,
 		       hostdata->madapter_info.partition_number,
 		       hostdata->madapter_info.os_type);
 	}
-
-	ibmvscsi_free_event_struct(&evt_struct->hostdata->pool, evt_struct);
 }
 
 /**
@@ -713,8 +712,6 @@
 
 	if (ibmvscsi_send_srp_event(evt_struct, hostdata)) {
 		printk(KERN_ERR "ibmvscsi: couldn't send ADAPTER_INFO_REQ!\n");
-		dma_unmap_single(hostdata->dev, req.buffer, req.common.length,
-				 DMA_BIDIRECTIONAL);
 	}
 };
 
@@ -747,8 +744,8 @@
 
 	printk(KERN_INFO "ibmvscsi: SRP_LOGIN succeeded\n");
 
-	if (evt_struct->evt->srp.login_rsp.request_limit_delta > max_requests)
-	    evt_struct->evt->srp.login_rsp.request_limit_delta = max_requests;
+	if (evt_struct->evt->srp.login_rsp.request_limit_delta > (max_requests-2))
+	    evt_struct->evt->srp.login_rsp.request_limit_delta = max_requests-2;
 
 	/* Now we know what the real request-limit is */
 	atomic_set(&hostdata->request_limit,
@@ -857,7 +854,6 @@
 	init_completion(&evt->comp);
 	if (ibmvscsi_send_srp_event(evt, hostdata) != 0) {
 		printk(KERN_ERR "ibmvscsi: failed to send abort() event\n");
-		ibmvscsi_free_event_struct(&hostdata->pool, evt);
 		return FAILED;
 	}
 
@@ -924,7 +920,6 @@
 	init_completion(&evt->comp);
 	if (ibmvscsi_send_srp_event(evt, hostdata) != 0) {
 		printk(KERN_ERR "ibmvscsi: failed to send reset event\n");
-		ibmvscsi_free_event_struct(&hostdata->pool, evt);
 		return FAILED;
 	}
 
@@ -1093,6 +1088,8 @@
 	if (!evt_struct) {
 		printk(KERN_ERR
 		       "ibmvscsi: could't allocate event for HOST_CONFIG!\n");
+		dma_unmap_single(hostdata->dev, host_config.buffer, length,
+				 DMA_BIDIRECTIONAL);
 		rc = -1;
 	} else {
 		evt_struct->crq.format = VIOSRP_MAD_FORMAT;
@@ -1100,11 +1097,12 @@
 		rc = ibmvscsi_send_srp_event(evt_struct, hostdata);
 		if (rc == 0) {
 			wait_for_completion(&evt_struct->comp);
+			dma_unmap_single(hostdata->dev, host_config.buffer, 
+					 length,
+					 DMA_BIDIRECTIONAL);
 		}
 	}
 
-	dma_unmap_single(hostdata->dev, host_config.buffer, length,
-			 DMA_BIDIRECTIONAL);
 
 	return rc ? rc : host_config.common.status;
 }
.........................................................................
# vim: syntax=diff

