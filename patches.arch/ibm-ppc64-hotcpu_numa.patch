--- linux-2.6.5-20040518/arch/ppc64/mm/numa.c	2004-05-18 12:32:16.000000000 -0500
+++ linux-2.6.5-20040518-ntl/arch/ppc64/mm/numa.c	2004-05-18 18:13:11.000000000 -0500
@@ -14,6 +14,8 @@
 #include <linux/mm.h>
 #include <linux/mmzone.h>
 #include <linux/module.h>
+#include <linux/cpu.h>
+#include <linux/notifier.h>
 #include <asm/lmb.h>
 #include <asm/machdep.h>
 #include <asm/abs_addr.h>
@@ -56,7 +58,24 @@ static inline void map_cpu_to_node(int c
 	}
 }
 
-static struct device_node * __init find_cpu_node(unsigned int cpu)
+#ifdef CONFIG_HOTPLUG_CPU
+static void unmap_cpu_from_node(unsigned long cpu)
+{
+	int node = numa_cpu_lookup_table[cpu];
+
+	dbg("removing cpu %lu from node %d\n", cpu, node);
+
+	if (cpu_isset(cpu, numa_cpumask_lookup_table[node])) {
+		cpu_clear(cpu, numa_cpumask_lookup_table[node]);
+		nr_cpus_in_node[node]--;
+	} else {
+		printk(KERN_ERR "WARNING: cpu %lu not found in node %d\n",
+		       cpu, node);
+	}
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
+static struct device_node * __devinit find_cpu_node(unsigned int cpu)
 {
 	unsigned int hw_cpuid = get_hard_smp_processor_id(cpu);
 	struct device_node *cpu_node = NULL;
@@ -68,9 +87,11 @@ static struct device_node * __init find_
 		interrupt_server = (unsigned int *)get_property(cpu_node,
 					"ibm,ppc-interrupt-server#s", &len);
 
+		len = len / sizeof(u32);
+
 		if (interrupt_server && (len > 0)) {
 			while (len--) {
-				if (interrupt_server[len-1] == hw_cpuid)
+				if (interrupt_server[len] == hw_cpuid)
 					return cpu_node;
 			}
 		} else {
@@ -206,9 +227,87 @@ static unsigned long read_cell_ul(struct
 	return result;
 }
 
+/*
+ * Figure out to which domain a cpu belongs and stick it there.
+ * Return the id of the domain used.
+ */
+static int numa_setup_cpu(unsigned long lcpu, int depth)
+{
+	int numa_domain;
+	struct device_node *cpu;
+
+	cpu = find_cpu_node(lcpu);
+
+	if (cpu) {
+		int *tmp, len;
+
+		tmp = (int *)get_property(cpu, "ibm,associativity",
+					  &len);
+		if (tmp && (len >= depth)) {
+			numa_domain = tmp[depth];
+
+		} else {
+			printk(KERN_ERR "WARNING: no NUMA "
+			       "information for cpu %ld\n", lcpu);
+			numa_domain = 0;
+		}
+
+		if (numa_domain >= MAX_NUMNODES) {
+			/*
+			 * POWER4 LPAR uses 0xffff as invalid node,
+			 * dont warn in this case.
+			 */
+			if (numa_domain != 0xffff)
+				printk(KERN_ERR "WARNING: cpu %ld "
+				       "maps to invalid NUMA node %d\n",
+				       lcpu, numa_domain);
+			numa_domain = 0;
+		}
+	} else {
+		printk(KERN_ERR "WARNING: no NUMA information for "
+		       "cpu %ld\n", lcpu);
+		numa_domain = 0;
+	}
+
+	/* This can be moved to callers if all domains are onlined at
+	 * boot.
+	 */
+	node_set_online(numa_domain);
+
+	map_cpu_to_node(lcpu, numa_domain);
+
+	of_node_put(cpu);
+
+	return numa_domain;
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+
+static int cpu_numa_callback(struct notifier_block *nfb,
+			     unsigned long action,
+			     void *hcpu)
+{
+	unsigned long lcpu = (unsigned long)hcpu;
+
+	if (action == CPU_UP_PREPARE) {
+		int depth = find_min_common_depth();
+
+		if (depth == -1)
+			map_cpu_to_node(lcpu, 0);
+		else
+			numa_setup_cpu(lcpu, depth);
+
+	} else if (action == CPU_DEAD || action == CPU_UP_CANCELED)
+		unmap_cpu_from_node((unsigned long)hcpu);
+
+	return NOTIFY_OK;
+}
+
+
+#endif /* CONFIG_HOTPLUG_CPU */
+
 static int __init parse_numa_properties(void)
 {
-	struct device_node *cpu = NULL;
 	struct device_node *memory = NULL;
 	int depth;
 	int max_domain = 0;
@@ -233,37 +332,10 @@ static int __init parse_numa_properties(
 		return depth;
 	
 	for_each_cpu(i) {
-		int numa_domain;
-
-		cpu = find_cpu_node(i);
-
-		if (cpu) {
-			numa_domain = of_node_numa_domain(cpu, depth);
-			of_node_put(cpu);
-
-			if (numa_domain >= MAX_NUMNODES) {
-				/*
-			 	 * POWER4 LPAR uses 0xffff as invalid node,
-				 * dont warn in this case.
-			 	 */
-				if (numa_domain != 0xffff)
-					printk(KERN_ERR "WARNING: cpu %ld "
-					       "maps to invalid NUMA node %d\n",
-					       i, numa_domain);
-				numa_domain = 0;
-			}
-		} else {
-			printk(KERN_ERR "WARNING: no NUMA information for "
-			       "cpu %ld\n", i);
-			numa_domain = 0;
-		}
-
-		node_set_online(numa_domain);
+		int numa_domain = numa_setup_cpu(i, depth);
 
 		if (max_domain < numa_domain)
 			max_domain = numa_domain;
-
-		map_cpu_to_node(i, numa_domain);
 	}
 
 	memory = NULL;
@@ -362,7 +434,7 @@ static void __init setup_nonnuma(void)
 			numa_memory_lookup_table[i] = ARRAY_INITIALISER;
 	}
 
-	for (i = 0; i < NR_CPUS; i++)
+	for_each_cpu(i)
 		map_cpu_to_node(i, 0);
 
 	node_set_online(0);
@@ -386,6 +458,12 @@ void __init do_init_bootmem(void)
 	if (parse_numa_properties())
 		setup_nonnuma();
 
+	/*
+	 * This must run before the sched domains notifier in
+	 * arch/ppc64/kernel/smp.c.
+	 */
+	hotcpu_notifier(cpu_numa_callback, 1);
+
 	for (nid = 0; nid < numnodes; nid++) {
 		unsigned long start_paddr, end_paddr;
 		int i;
