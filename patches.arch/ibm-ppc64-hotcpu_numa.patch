--- linux-2.6.5-20040508/arch/ppc64/mm/numa.c	2004-05-09 21:23:49.000000000 -0500
+++ linux-2.6.5-20040508-ntl3/arch/ppc64/mm/numa.c	2004-05-11 02:06:21.000000000 -0500
@@ -14,6 +14,8 @@
 #include <linux/mm.h>
 #include <linux/mmzone.h>
 #include <linux/module.h>
+#include <linux/cpu.h>
+#include <linux/notifier.h>
 #include <asm/lmb.h>
 #include <asm/machdep.h>
 #include <asm/abs_addr.h>
@@ -39,6 +41,7 @@ int nr_cpus_in_node[MAX_NUMNODES] = { [0
 struct pglist_data node_data[MAX_NUMNODES];
 bootmem_data_t plat_node_bdata[MAX_NUMNODES];
 static unsigned long node0_io_hole_size;
+static int common_depth;
 
 EXPORT_SYMBOL(node_data);
 EXPORT_SYMBOL(numa_cpu_lookup_table);
@@ -56,7 +59,24 @@ static inline void map_cpu_to_node(int c
 	}
 }
 
-static struct device_node * __init find_cpu_node(unsigned int cpu)
+#ifdef CONFIG_HOTPLUG_CPU
+static void unmap_cpu_from_node(unsigned long cpu)
+{
+	int node = numa_cpu_lookup_table[cpu];
+
+	dbg("removing cpu %lu from node %d\n", cpu, node);
+
+	if (cpu_isset(cpu, numa_cpumask_lookup_table[node])) {
+		cpu_clear(cpu, numa_cpumask_lookup_table[node]);
+		nr_cpus_in_node[node]--;
+	} else {
+		printk(KERN_ERR "WARNING: cpu %lu not found in node %d\n",
+		       cpu, node);
+	}
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
+static struct device_node * __devinit find_cpu_node(unsigned int cpu)
 {
 	unsigned int hw_cpuid = get_hard_smp_processor_id(cpu);
 	struct device_node *cpu_node = NULL;
@@ -68,9 +88,11 @@ static struct device_node * __init find_
 		interrupt_server = (unsigned int *)get_property(cpu_node,
 					"ibm,ppc-interrupt-server#s", &len);
 
+		len = len / sizeof(u32);
+
 		if (interrupt_server && (len > 0)) {
 			while (len--) {
-				if (interrupt_server[len-1] == hw_cpuid)
+				if (interrupt_server[len] == hw_cpuid)
 					return cpu_node;
 			}
 		} else {
@@ -84,6 +106,85 @@ static struct device_node * __init find_
 	return NULL;
 }
 
+/*
+ * Figure out to which domain a cpu belongs and stick it there.
+ * Return the id of the domain used.
+ */
+static int numa_setup_cpu(unsigned long lcpu)
+{
+	int numa_domain;
+	struct device_node *cpu;
+
+	cpu = find_cpu_node(lcpu);
+
+	if (cpu) {
+		int *tmp, len;
+
+		tmp = (int *)get_property(cpu, "ibm,associativity",
+					  &len);
+		if (tmp && (len >= common_depth)) {
+			numa_domain = tmp[common_depth];
+
+		} else {
+			printk(KERN_ERR "WARNING: no NUMA "
+			       "information for cpu %ld\n", lcpu);
+			numa_domain = 0;
+		}
+
+		if (numa_domain >= MAX_NUMNODES) {
+			/*
+			 * POWER4 LPAR uses 0xffff as invalid node,
+			 * dont warn in this case.
+			 */
+			if (numa_domain != 0xffff)
+				printk(KERN_ERR "WARNING: cpu %ld "
+				       "maps to invalid NUMA node %d\n",
+				       lcpu, numa_domain);
+			numa_domain = 0;
+		}
+	} else {
+		printk(KERN_ERR "WARNING: no NUMA information for "
+		       "cpu %ld\n", lcpu);
+		numa_domain = 0;
+	}
+
+	/* This can be moved to callers if all domains are onlined at
+	 * boot.
+	 */
+	node_set_online(numa_domain);
+
+	map_cpu_to_node(lcpu, numa_domain);
+
+	of_node_put(cpu);
+
+	return numa_domain;
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+
+static int cpu_numa_callback(struct notifier_block *nfb,
+			     unsigned long action,
+			     void *hcpu)
+{
+	if (action == CPU_UP_PREPARE) {
+		dbg("Running %s for new cpu %lu\n", __FUNCTION__,
+		    (unsigned long)hcpu);
+
+		numa_setup_cpu((unsigned long)hcpu);
+
+	} else if (action == CPU_DEAD || action == CPU_UP_CANCELED) {
+		dbg("Running %s for dead cpu %lu\n", __FUNCTION__,
+		    (unsigned long)hcpu);
+
+		unmap_cpu_from_node((unsigned long)hcpu);
+
+	}
+	return NOTIFY_OK;
+}
+
+
+#endif /* CONFIG_HOTPLUG_CPU */
+
 static int __init parse_numa_properties(void)
 {
 	struct device_node *cpu = NULL;
@@ -91,7 +192,6 @@ static int __init parse_numa_properties(
 	unsigned int *tmp;
 	int cpu_associativity;
 	int memory_associativity;
-	int depth;
 	int len;
 	int max_domain = 0;
 	long entries = lmb_end_of_DRAM() >> MEMORY_INCREMENT_SHIFT;
@@ -135,50 +235,15 @@ static int __init parse_numa_properties(
 
 	/* find common depth */
 	if (cpu_associativity < memory_associativity)
-		depth = cpu_associativity;
+		common_depth = cpu_associativity;
 	else
-		depth = memory_associativity;
+		common_depth = memory_associativity;
 
 	for_each_cpu(i) {
-		int numa_domain;
-
-		cpu = find_cpu_node(i);
-
-		if (cpu) {
-			tmp = (int *)get_property(cpu, "ibm,associativity",
-						  &len);
-			if (tmp && (len >= depth)) {
-				numa_domain = tmp[depth];
-				of_node_put(cpu);
-			} else {
-				printk(KERN_ERR "WARNING: no NUMA "
-				       "information for cpu %ld\n", i);
-				numa_domain = 0;
-			}
-
-			if (numa_domain >= MAX_NUMNODES) {
-				/*
-			 	 * POWER4 LPAR uses 0xffff as invalid node,
-				 * dont warn in this case.
-			 	 */
-				if (numa_domain != 0xffff)
-					printk(KERN_ERR "WARNING: cpu %ld "
-					       "maps to invalid NUMA node %d\n",
-					       i, numa_domain);
-				numa_domain = 0;
-			}
-		} else {
-			printk(KERN_ERR "WARNING: no NUMA information for "
-			       "cpu %ld\n", i);
-			numa_domain = 0;
-		}
-
-		node_set_online(numa_domain);
+		int numa_domain = numa_setup_cpu(i);
 
 		if (max_domain < numa_domain)
 			max_domain = numa_domain;
-
-		map_cpu_to_node(i, numa_domain);
 	}
 
 	memory = NULL;
@@ -212,8 +277,8 @@ new_range:
 
 		tmp = (unsigned int *)get_property(memory, "ibm,associativity",
 					   &len);
-		if (tmp && len >= depth) {
-			numa_domain = tmp[depth];
+		if (tmp && len >= common_depth) {
+			numa_domain = tmp[common_depth];
 		} else {
 			printk(KERN_ERR "WARNING: no NUMA information for "
 			       "memory at %lx\n", start);
@@ -270,6 +335,12 @@ new_range:
 
 	numnodes = max_domain + 1;
 
+	/*
+	 * This must run before the sched domains notifier in
+	 * arch/ppc64/kernel/smp.c.
+	 */
+	hotcpu_notifier(cpu_numa_callback, 1);
+
 	return 0;
 }
 
