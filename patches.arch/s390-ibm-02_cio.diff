 - Correctly initialize all spin_locks with spin_lock_init.
 - Use subchannel lock directly instead of ccw device lock pointer in
   ccw_device_recognition to avoid accessing an already free structure.
 - Take/release ccw device lock in ccw_device_console_enable.

diffstat:
 drivers/s390/cio/chsc.c          |    6 ++---
 drivers/s390/cio/cio.c           |   42 +++++++++++++++++++++++--------------
 drivers/s390/cio/css.c           |    5 ----
 drivers/s390/cio/device.c        |   23 +++++++++++---------
 drivers/s390/cio/device_fsm.c    |   36 +++++++++++++++++++++----------
 drivers/s390/cio/device_id.c     |   25 ++++++++++++----------
 drivers/s390/cio/device_ops.c    |   10 +++-----
 drivers/s390/cio/device_pgid.c   |   44 ++++++++++++++++++---------------------
 drivers/s390/cio/device_status.c |    4 +--
 9 files changed, 109 insertions(+), 86 deletions(-)

diff -urN linux-2.6/drivers/s390/cio/chsc.c linux-2.6-s390/drivers/s390/cio/chsc.c
--- linux-2.6/drivers/s390/cio/chsc.c	Sat Oct 25 20:43:48 2003
+++ linux-2.6-s390/drivers/s390/cio/chsc.c	Thu Nov 13 15:29:38 2003
@@ -151,7 +151,7 @@
 	 */
 	if (ssd_area->st > 3) { /* uhm, that looks strange... */
 		CIO_CRW_EVENT(0, "Strange subchannel type %d"
-			      " for sch %x\n", ssd_area->st, irq);
+			      " for sch %s\n", ssd_area->st, sch->dev.bus_id);
 		/*
 		 * There may have been a new subchannel type defined in the
 		 * time since this code was written; since we don't know which
@@ -160,8 +160,8 @@
 		return 0;
 	} else {
 		const char *type[4] = {"I/O", "chsc", "message", "ADM"};
-		CIO_CRW_EVENT(6, "ssd: sch %x is %s subchannel\n",
-			      irq, type[ssd_area->st]);
+		CIO_CRW_EVENT(6, "ssd: sch %s is %s subchannel\n",
+			      sch->dev.bus_id, type[ssd_area->st]);
 		if (ioinfo[irq] == NULL)
 			/* FIXME: we should do device rec. here... */
 			return 0;
diff -urN linux-2.6/drivers/s390/cio/cio.c linux-2.6-s390/drivers/s390/cio/cio.c
--- linux-2.6/drivers/s390/cio/cio.c	Sat Oct 25 20:44:53 2003
+++ linux-2.6-s390/drivers/s390/cio/cio.c	Thu Nov 13 15:29:38 2003
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/cio.c
  *   S/390 common I/O routines -- low level i/o calls
- *   $Revision: 1.105 $
+ *   $Revision: 1.106 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -190,8 +190,8 @@
 	char dbf_txt[15];
 	int ccode;
 
-	sprintf (dbf_txt, "stIO%x", sch->irq);
-	CIO_TRACE_EVENT (4, dbf_txt);
+	CIO_TRACE_EVENT (4, "stIO");
+	CIO_TRACE_EVENT (4, sch->dev.bus_id);
 
 	sch->orb.intparm = intparm;
 	sch->orb.fmt = 1;
@@ -240,8 +240,8 @@
 	char dbf_txt[15];
 	int ccode;
 
-	sprintf (dbf_txt, "resIO%x", sch->irq);
-	CIO_TRACE_EVENT (4, dbf_txt);
+	CIO_TRACE_EVENT (4, "resIO");
+	CIO_TRACE_EVENT (4, sch->dev.bus_id);
 
 	ccode = rsch (sch->irq);
 
@@ -277,8 +277,8 @@
 	if (!sch)
 		return -ENODEV;
 
-	sprintf (dbf_txt, "haltIO%x", sch->irq);
-	CIO_TRACE_EVENT (2, dbf_txt);
+	CIO_TRACE_EVENT (2, "haltIO");
+	CIO_TRACE_EVENT (2, sch->dev.bus_id);
 
 	/*
 	 * Issue "Halt subchannel" and process condition code
@@ -312,8 +312,8 @@
 	if (!sch)
 		return -ENODEV;
 
-	sprintf (dbf_txt, "clearIO%x", sch->irq);
-	CIO_TRACE_EVENT (2, dbf_txt);
+	CIO_TRACE_EVENT (2, "clearIO");
+	CIO_TRACE_EVENT (2, sch->dev.bus_id);
 
 	/*
 	 * Issue "Clear subchannel" and process condition code
@@ -348,8 +348,8 @@
 	if (!sch)
 		return -ENODEV;
 
-	sprintf (dbf_txt, "cancelIO%x", sch->irq);
-	CIO_TRACE_EVENT (2, dbf_txt);
+	CIO_TRACE_EVENT (2, "cancelIO");
+	CIO_TRACE_EVENT (2, sch->dev.bus_id);
 
 	ccode = xsch (sch->irq);
 
@@ -411,8 +411,8 @@
 	int retry;
 	int ret;
 
-	sprintf (dbf_txt, "ensch%x", sch->irq);
-	CIO_TRACE_EVENT (2, dbf_txt);
+	CIO_TRACE_EVENT (2, "ensch");
+	CIO_TRACE_EVENT (2, sch->dev.bus_id);
 
 	ccode = stsch (sch->irq, &sch->schib);
 	if (ccode)
@@ -457,8 +457,8 @@
 	int retry;
 	int ret;
 
-	sprintf (dbf_txt, "dissch%x", sch->irq);
-	CIO_TRACE_EVENT (2, dbf_txt);
+	CIO_TRACE_EVENT (2, "dissch");
+	CIO_TRACE_EVENT (2, sch->dev.bus_id);
 
 	ccode = stsch (sch->irq, &sch->schib);
 	if (ccode == 3)		/* Not operational. */
@@ -477,6 +477,13 @@
 		ret = cio_modify(sch);
 		if (ret == -ENODEV)
 			break;
+		if (ret == -EBUSY)
+			/*
+			 * The subchannel is busy or status pending.
+			 * We'll disable when the next interrupt was delivered
+			 * via the state machine.
+			 */
+			break;
 		if (ret == 0) {
 			stsch (sch->irq, &sch->schib);
 			if (!sch->schib.pmcw.ena)
@@ -512,6 +519,11 @@
 	/* Nuke all fields. */
 	memset(sch, 0, sizeof(struct subchannel));
 
+	spin_lock_init(&sch->lock);
+
+	/* Set a name for the subchannel */
+	snprintf (sch->dev.bus_id, BUS_ID_SIZE, "0.0.%04x", irq);
+
 	/*
 	 * The first subchannel that is not-operational (ccode==3)
 	 *  indicates that there aren't any more devices available.
diff -urN linux-2.6/drivers/s390/cio/css.c linux-2.6-s390/drivers/s390/cio/css.c
--- linux-2.6/drivers/s390/cio/css.c	Sat Oct 25 20:42:59 2003
+++ linux-2.6-s390/drivers/s390/cio/css.c	Thu Nov 13 15:29:38 2003
@@ -83,10 +83,7 @@
 	/* Initialize the subchannel structure */
 	sch->dev.parent = &css_bus_device;
 	sch->dev.bus = &css_bus_type;
-
-	/* Set a name for the subchannel */
-	snprintf (sch->dev.bus_id, BUS_ID_SIZE, "0.0.%04x", sch->irq);
-
+	
 	/* make it known to the system */
 	ret = device_register(&sch->dev);
 	if (ret)
diff -urN linux-2.6/drivers/s390/cio/device.c linux-2.6-s390/drivers/s390/cio/device.c
--- linux-2.6/drivers/s390/cio/device.c	Sat Oct 25 20:44:13 2003
+++ linux-2.6-s390/drivers/s390/cio/device.c	Thu Nov 13 15:29:38 2003
@@ -495,8 +495,8 @@
 
 	ret = subchannel_add_files(cdev->dev.parent);
 	if (ret)
-		printk(KERN_WARNING "%s: could not add attributes to %04x\n",
-		       __func__, sch->irq);
+		printk(KERN_WARNING "%s: could not add attributes to %s\n",
+		       __func__, sch->dev.bus_id);
 	if (cdev->private->state == DEV_STATE_BOXED)
 		device_create_file(&cdev->dev, &dev_attr_steal_lock);
 out:
@@ -562,9 +562,9 @@
 	atomic_inc(&ccw_device_init_count);
 
 	/* Start async. device sensing. */
-	spin_lock_irq(cdev->ccwlock);
+	spin_lock_irq(&sch->lock);
 	rc = ccw_device_recognition(cdev);
-	spin_unlock_irq(cdev->ccwlock);
+	spin_unlock_irq(&sch->lock);
 	if (rc) {
 		if (atomic_dec_and_test(&ccw_device_init_count))
 			wake_up(&ccw_device_init_wq);
@@ -652,25 +652,28 @@
 		.parent = &sch->dev,
 	};
 	/* Initialize the subchannel structure */
-	sch->dev = (struct device) {
-		.parent = &css_bus_device,
-		.bus	= &css_bus_type,
-	};
+	sch->dev.parent = &css_bus_device;
+	sch->dev.bus = &css_bus_type;
 
 	rc = io_subchannel_recog(cdev, sch);
 	if (rc)
 		return rc;
 
 	/* Now wait for the async. recognition to come to an end. */
+	spin_lock_irq(cdev->ccwlock);
 	while (!dev_fsm_final_state(cdev))
 		wait_cons_dev();
+	rc = -EIO;
 	if (cdev->private->state != DEV_STATE_OFFLINE)
-		return -EIO;
+		goto out_unlock;
 	ccw_device_online(cdev);
 	while (!dev_fsm_final_state(cdev))
 		wait_cons_dev();
 	if (cdev->private->state != DEV_STATE_ONLINE)
-		return -EIO;
+		goto out_unlock;
+	rc = 0;
+out_unlock:
+	spin_unlock_irq(cdev->ccwlock);
 	return 0;
 }
 
diff -urN linux-2.6/drivers/s390/cio/device_fsm.c linux-2.6-s390/drivers/s390/cio/device_fsm.c
--- linux-2.6/drivers/s390/cio/device_fsm.c	Sat Oct 25 20:43:40 2003
+++ linux-2.6-s390/drivers/s390/cio/device_fsm.c	Thu Nov 13 15:29:38 2003
@@ -110,8 +110,8 @@
 	switch (state) {
 	case DEV_STATE_NOT_OPER:
 		CIO_DEBUG(KERN_WARNING, 2,
-			  "SenseID : unknown device %04X on subchannel %04X\n",
-			  sch->schib.pmcw.dev, sch->irq);
+			  "SenseID : unknown device %s on subchannel %s\n",
+			  cdev->dev.bus_id, sch->dev.bus_id);
 		break;
 	case DEV_STATE_OFFLINE:
 		/* fill out sense information */
@@ -122,16 +122,16 @@
 			.dev_model = cdev->private->senseid.dev_model,
 		};
 		/* Issue device info message. */
-		CIO_DEBUG(KERN_INFO, 2, "SenseID : device %04X reports: "
+		CIO_DEBUG(KERN_INFO, 2, "SenseID : device %s reports: "
 			  "CU  Type/Mod = %04X/%02X, Dev Type/Mod = "
-			  "%04X/%02X\n", sch->schib.pmcw.dev,
+			  "%04X/%02X\n", cdev->dev.bus_id,
 			  cdev->id.cu_type, cdev->id.cu_model,
 			  cdev->id.dev_type, cdev->id.dev_model);
 		break;
 	case DEV_STATE_BOXED:
 		CIO_DEBUG(KERN_WARNING, 2,
-			  "SenseID : boxed device %04X on subchannel %04X\n",
-			  sch->schib.pmcw.dev, sch->irq);
+			  "SenseID : boxed device %s on subchannel %s\n",
+			  cdev->dev.bus_id, sch->dev.bus_id);
 		break;
 	}
 	io_subchannel_recog_done(cdev);
@@ -179,8 +179,8 @@
 
 	if (state == DEV_STATE_BOXED) {
 		CIO_DEBUG(KERN_WARNING, 2,
-			  "Boxed device %04X on subchannel %04X\n",
-			  sch->schib.pmcw.dev, sch->irq);
+			  "Boxed device %s on subchannel %s\n",
+			  cdev->dev.bus_id, sch->dev.bus_id);
 		INIT_WORK(&cdev->private->kick_work,
 			  ccw_device_add_stlck, (void *) cdev);
 		queue_work(ccw_device_work, &cdev->private->kick_work);
@@ -586,6 +586,19 @@
 	wake_up(&cdev->private->wait_q);
 }
 
+static void
+ccw_device_offline_irq(struct ccw_device *cdev, enum dev_event dev_event)
+{
+	struct subchannel *sch;
+
+	sch = to_subchannel(cdev->dev.parent);
+	/*
+	 * An interrupt in state offline means a previous disable was not
+	 * successful. Try again.
+	 */
+	cio_disable_subchannel(sch);
+}
+
 /*
  * No operation action. This is used e.g. to ignore a timeout event in
  * state offline.
@@ -630,7 +643,7 @@
 	},
 	[DEV_STATE_OFFLINE] {
 		[DEV_EVENT_NOTOPER]	ccw_device_offline_notoper,
-		[DEV_EVENT_INTERRUPT]	ccw_device_bug,
+		[DEV_EVENT_INTERRUPT]	ccw_device_offline_irq,
 		[DEV_EVENT_TIMEOUT]	ccw_device_nop,
 		[DEV_EVENT_VERIFY]	ccw_device_nop,
 	},
@@ -686,13 +699,12 @@
 void
 io_subchannel_irq (struct device *pdev)
 {
-	char dbf_txt[15];
 	struct ccw_device *cdev;
 
 	cdev = to_subchannel(pdev)->dev.driver_data;
 
-	sprintf (dbf_txt, "IRQ%04x", cdev->private->irq);
-	CIO_TRACE_EVENT (3, dbf_txt);
+	CIO_TRACE_EVENT (3, "IRQ");
+	CIO_TRACE_EVENT (3, pdev->bus_id);
 
 	dev_fsm_event(cdev, DEV_EVENT_INTERRUPT);
 }
diff -urN linux-2.6/drivers/s390/cio/device_id.c linux-2.6-s390/drivers/s390/cio/device_id.c
--- linux-2.6/drivers/s390/cio/device_id.c	Sat Oct 25 20:42:40 2003
+++ linux-2.6-s390/drivers/s390/cio/device_id.c	Thu Nov 13 15:29:38 2003
@@ -22,6 +22,7 @@
 #include "cio_debug.h"
 #include "css.h"
 #include "device.h"
+#include "ioasm.h"
 
 /*
  * diag210 is used under VM to get information about a virtual device
@@ -201,7 +202,9 @@
 					 0x00E2C9C4, cdev->private->imask);
 			/* ret is 0, -EBUSY, -EACCES or -ENODEV */
 			if (ret == -EBUSY) {
-				udelay(100);
+				struct irb irb;
+				if (tsch(sch->irq, &irb))
+					udelay(100);
 				continue;
 			}
 			if (ret != -EACCES)
@@ -255,16 +258,16 @@
 		 * if the device doesn't support the SenseID
 		 *  command further retries wouldn't help ...
 		 */
-		CIO_MSG_EVENT(2, "SenseID : device %04X on Subchannel %04X "
+		CIO_MSG_EVENT(2, "SenseID : device %s on Subchannel %s "
 			      "reports cmd reject or intervention required\n",
-			      sch->schib.pmcw.dev, sch->irq);
+			      cdev->dev.bus_id, sch->dev.bus_id);
 		return -EOPNOTSUPP;
 	}
 	if (irb->esw.esw0.erw.cons) {
-		CIO_MSG_EVENT(2, "SenseID : UC on dev %04X, "
+		CIO_MSG_EVENT(2, "SenseID : UC on dev %s, "
 			      "lpum %02X, cnt %02d, sns :"
 			      " %02X%02X%02X%02X %02X%02X%02X%02X ...\n",
-			      sch->schib.pmcw.dev,
+			      cdev->dev.bus_id,
 			      irb->esw.esw0.sublog.lpum,
 			      irb->esw.esw0.erw.scnt,
 			      irb->ecw[0], irb->ecw[1],
@@ -274,15 +277,15 @@
 		return -EAGAIN;
 	}
 	if (irb->scsw.cc == 3) {
-		CIO_MSG_EVENT(2, "SenseID : path %02X for device %04X on "
-			      "subchannel %04X is 'not operational'\n",
-			      sch->orb.lpm, sch->schib.pmcw.dev, sch->irq);
+		CIO_MSG_EVENT(2, "SenseID : path %02X for device %s on "
+			      "subchannel %s is 'not operational'\n",
+			      sch->orb.lpm, cdev->dev.bus_id, sch->dev.bus_id);
 		return -EACCES;
 	}
 	/* Hmm, whatever happened, try again. */
-	CIO_MSG_EVENT(2, "SenseID : start_IO() for device %04X on "
-		      "subchannel %04X returns status %02X%02X\n",
-		      sch->schib.pmcw.dev, sch->irq,
+	CIO_MSG_EVENT(2, "SenseID : start_IO() for device %s on "
+		      "subchannel %s returns status %02X%02X\n",
+		      cdev->dev.bus_id, sch->dev.bus_id,
 		      irb->scsw.dstat, irb->scsw.cstat);
 	return -EAGAIN;
 }
diff -urN linux-2.6/drivers/s390/cio/device_ops.c linux-2.6-s390/drivers/s390/cio/device_ops.c
--- linux-2.6/drivers/s390/cio/device_ops.c	Sat Oct 25 20:44:13 2003
+++ linux-2.6-s390/drivers/s390/cio/device_ops.c	Thu Nov 13 15:29:38 2003
@@ -302,7 +302,6 @@
 read_dev_chars (struct ccw_device *cdev, void **buffer, int length)
 {
 	void (*handler)(struct ccw_device *, unsigned long, struct irb *);
-	char dbf_txt[15];
 	struct subchannel *sch;
 	int ret;
 	struct ccw1 *rdc_ccw;
@@ -313,8 +312,8 @@
 		return -EINVAL;
 	sch = to_subchannel(cdev->dev.parent);
 
-	sprintf (dbf_txt, "rddevch%x", sch->irq);
-	CIO_TRACE_EVENT (4, dbf_txt);
+	CIO_TRACE_EVENT (4, "rddevch");
+	CIO_TRACE_EVENT (4, sch->dev.bus_id);
 
 	rdc_ccw = kmalloc(sizeof(struct ccw1), GFP_KERNEL | GFP_DMA);
 	if (!rdc_ccw)
@@ -359,7 +358,6 @@
 read_conf_data (struct ccw_device *cdev, void **buffer, int *length)
 {
 	void (*handler)(struct ccw_device *, unsigned long, struct irb *);
-	char dbf_txt[15];
 	struct subchannel *sch;
 	struct ciw *ciw;
 	char *rcd_buf;
@@ -372,8 +370,8 @@
 		return -EINVAL;
 	sch = to_subchannel(cdev->dev.parent);
 
-	sprintf (dbf_txt, "rdconf%x", sch->irq);
-	CIO_TRACE_EVENT (4, dbf_txt);
+	CIO_TRACE_EVENT (4, "rdconf");
+	CIO_TRACE_EVENT (4, sch->dev.bus_id);
 
 	/*
 	 * scan for RCD command in extended SenseID data
diff -urN linux-2.6/drivers/s390/cio/device_pgid.c linux-2.6-s390/drivers/s390/cio/device_pgid.c
--- linux-2.6/drivers/s390/cio/device_pgid.c	Sat Oct 25 20:43:47 2003
+++ linux-2.6-s390/drivers/s390/cio/device_pgid.c	Thu Nov 13 15:29:38 2003
@@ -55,18 +55,18 @@
 			/* ret is 0, -EBUSY, -EACCES or -ENODEV */
 			if (ret == -EBUSY) {
 				CIO_MSG_EVENT(2, 
-					      "SNID - device %04X, start_io() "
+					      "SNID - device %s, start_io() "
 					      "reports rc : %d, retrying ...\n",
-					      sch->schib.pmcw.dev, ret);
+					      cdev->dev.bus_id, ret);
 				udelay(100);
 				continue;
 			}
 			if (ret != -EACCES)
 				return ret;
-			CIO_MSG_EVENT(2, "SNID - Device %04X on Subchannel "
-				      "%04X, lpm %02X, became 'not "
+			CIO_MSG_EVENT(2, "SNID - Device %s on Subchannel "
+				      "%s, lpm %02X, became 'not "
 				      "operational'\n",
-				      sch->schib.pmcw.dev, sch->irq,
+				      cdev->dev.bus_id, sch->dev.bus_id,
 				      cdev->private->imask);
 
 		}
@@ -113,10 +113,10 @@
 		return -EOPNOTSUPP;
 	}
 	if (irb->esw.esw0.erw.cons) {
-		CIO_MSG_EVENT(2, "SNID - device %04X, unit check, "
+		CIO_MSG_EVENT(2, "SNID - device %s, unit check, "
 			      "lpum %02X, cnt %02d, sns : "
 			      "%02X%02X%02X%02X %02X%02X%02X%02X ...\n",
-			      sch->schib.pmcw.dev,
+			      cdev->dev.bus_id,
 			      irb->esw.esw0.sublog.lpum,
 			      irb->esw.esw0.erw.scnt,
 			      irb->ecw[0], irb->ecw[1],
@@ -126,16 +126,16 @@
 		return -EAGAIN;
 	}
 	if (irb->scsw.cc == 3) {
-		CIO_MSG_EVENT(2, "SNID - Device %04X on Subchannel "
-			      "%04X, lpm %02X, became 'not "
-			      "operational'\n",
-			      sch->schib.pmcw.dev, sch->irq, sch->orb.lpm);
+		CIO_MSG_EVENT(2, "SNID - Device %s on Subchannel "
+			      "%s, lpm %02X, became 'not operational'\n",
+			      cdev->dev.bus_id, sch->dev.bus_id,
+			      sch->orb.lpm);
 		return -EACCES;
 	}
 	if (cdev->private->pgid.inf.ps.state2 == SNID_STATE2_RESVD_ELSE) {
-		CIO_MSG_EVENT(2, "SNID - Device %04X on Subchannel %04X "
+		CIO_MSG_EVENT(2, "SNID - Device %s on Subchannel %s "
 			      "is reserved by someone else\n",
-			      sch->schib.pmcw.dev, sch->irq);
+			      cdev->dev.bus_id, sch->dev.bus_id);
 		return -EUSERS;
 	}
 	return 0;
@@ -250,10 +250,9 @@
 	/* PGID command failed on this path. Switch it off. */
 	sch->lpm &= ~cdev->private->imask;
 	sch->vpm &= ~cdev->private->imask;
-	CIO_MSG_EVENT(2, "SPID - Device %04X on Subchannel "
-		      "%04X, lpm %02X, became 'not "
-		      "operational'\n",
-		      sch->schib.pmcw.dev, sch->irq,
+	CIO_MSG_EVENT(2, "SPID - Device %s on Subchannel "
+		      "%s, lpm %02X, became 'not operational'\n",
+		      cdev->dev.bus_id, sch->dev.bus_id,
 		      cdev->private->imask);
 	return ret;
 }
@@ -276,9 +275,9 @@
 		if (irb->ecw[0] & SNS0_CMD_REJECT)
 			return -EOPNOTSUPP;
 		/* Hmm, whatever happened, try again. */
-		CIO_MSG_EVENT(2, "SPID - device %04X, unit check, cnt %02d, "
+		CIO_MSG_EVENT(2, "SPID - device %s, unit check, cnt %02d, "
 			      "sns : %02X%02X%02X%02X %02X%02X%02X%02X ...\n",
-			      sch->schib.pmcw.dev, irb->esw.esw0.erw.scnt,
+			      cdev->dev.bus_id, irb->esw.esw0.erw.scnt,
 			      irb->ecw[0], irb->ecw[1],
 			      irb->ecw[2], irb->ecw[3],
 			      irb->ecw[4], irb->ecw[5],
@@ -286,10 +285,9 @@
 		return -EAGAIN;
 	}
 	if (irb->scsw.cc == 3) {
-		CIO_MSG_EVENT(2, "SPID - Device %04X on Subchannel "
-			      "%04X, lpm %02X, became 'not "
-			      "operational'\n",
-			      sch->schib.pmcw.dev, sch->irq,
+		CIO_MSG_EVENT(2, "SPID - Device %s on Subchannel "
+			      "%s, lpm %02X, became 'not operational'\n",
+			      cdev->dev.bus_id, sch->dev.bus_id,
 			      cdev->private->imask);
 		return -EACCES;
 	}
diff -urN linux-2.6/drivers/s390/cio/device_status.c linux-2.6-s390/drivers/s390/cio/device_status.c
--- linux-2.6/drivers/s390/cio/device_status.c	Sat Oct 25 20:43:34 2003
+++ linux-2.6-s390/drivers/s390/cio/device_status.c	Thu Nov 13 15:29:38 2003
@@ -62,8 +62,8 @@
 	sch = to_subchannel(cdev->dev.parent);
 	stsch (sch->irq, &sch->schib);
 
-	CIO_MSG_EVENT(0, "%s(%04X) - path(s) %02x are "
-		      "not operational \n", __FUNCTION__, sch->irq,
+	CIO_MSG_EVENT(0, "%s(%s) - path(s) %02x are "
+		      "not operational \n", __FUNCTION__, sch->dev.bus_id,
 		      sch->schib.pmcw.pnom);
 
 	sch->lpm &= ~sch->schib.pmcw.pnom;
