- Description: cio: Clean up subchannels on reipl.
  Symptom:     After a forced reboot via SysRq-b on LPAR, some devices that were
               active are not detected.
  Problem:     On SysRq-b, no real cleanup is performed (especially the shutdown
               method is not called by the driver core and the reboot notifier
               chain is not triggered). After reipl on LPAR the subchannels may
               remain in a busy state and can't be sensed on startup.
  Solution:    Insert a loop before do_reipl which tries to quiesce via csch()
               and disable all active subchannels.
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/cio/cio.c	8 Apr 2004 11:09:24 -0000	1.117.2.1
+++ linux-2.5/drivers/s390/cio/cio.c	14 Apr 2004 13:58:51 -0000	1.117.2.2
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/cio.c
  *   S/390 common I/O routines -- low level i/o calls
- *   $Revision: 1.117.2.1 $
+ *   $Revision: 1.117.2.2 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -783,3 +783,68 @@
 }
 
 #endif
+static inline int
+__disable_subchannel_easy(unsigned int schid, struct schib *schib)
+{
+	int retry, cc;
+
+	cc = 0;
+	for (retry=0;retry<3;retry++) {
+		schib->pmcw.ena = 0;
+		cc = msch(schid, schib);
+		if (cc)
+			return (cc==3?-ENODEV:-EBUSY);
+		stsch(schid, schib);
+		if (!schib->pmcw.ena)
+			return 0;
+	}
+	return -EBUSY; /* uhm... */
+}
+
+static inline int
+__clear_subchannel_easy(unsigned int schid)
+{
+	int retry;
+
+	if (csch(schid))
+		return -ENODEV;
+	for (retry=0;retry<20;retry++) {
+		struct tpi_info ti;
+		
+		if (tpi(&ti)) {
+			tsch(schid, (struct irb *)__LC_IRB);
+			return 0;
+		}
+		udelay(100);
+	}
+	return -EBUSY;
+}
+
+extern void do_reipl(unsigned long devno);
+/* Make sure all subchannels are quiet before we re-ipl an lpar. */
+void
+reipl(unsigned long devno)
+{
+	unsigned int schid;
+
+	local_irq_disable();
+	for (schid=0;schid<=highest_subchannel;schid++) {
+		struct schib schib;
+		if (stsch(schid, &schib))
+			goto out;
+		if (!schib.pmcw.ena)
+			continue;
+		switch(__disable_subchannel_easy(schid, &schib)) {
+		case 0:
+		case -ENODEV:
+			break;
+		default: /* -EBUSY */
+			if (__clear_subchannel_easy(schid))
+				break; /* give up... */
+			stsch(schid, &schib);
+			__disable_subchannel_easy(schid, &schib);
+		}
+	}
+out:
+	do_reipl(devno);
+}

--- linux-2.5/arch/s390/kernel/setup.c	22 Mar 2004 15:32:23 -0000	1.32
+++ linux-2.5/arch/s390/kernel/setup.c	14 Apr 2004 13:58:51 -0000	1.32.2.1
@@ -254,13 +254,13 @@
 /*
  * Reboot, halt and power_off routines for non SMP.
  */
-extern void do_reipl(unsigned long devno);
+extern void reipl(unsigned long devno);
 static void do_machine_restart_nonsmp(char * __unused)
 {
 	if (MACHINE_IS_VM)
 		cpcmd ("IPL", NULL, 0);
 	else
-		do_reipl (0x10000 | S390_lowcore.ipl_device);
+		reipl (0x10000 | S390_lowcore.ipl_device);
 }
 
 static void do_machine_halt_nonsmp(void)

--- linux-2.5/arch/s390/kernel/smp.c	27 Feb 2004 17:24:05 -0000	1.47
+++ linux-2.5/arch/s390/kernel/smp.c	14 Apr 2004 13:58:51 -0000	1.47.2.1
@@ -64,7 +64,7 @@
 extern char vmhalt_cmd[];
 extern char vmpoff_cmd[];
 
-extern void do_reipl(unsigned long devno);
+extern void reipl(unsigned long devno);
 
 static void smp_ext_bitcall(int, ec_bit_sig);
 static void smp_ext_bitcall_others(ec_bit_sig);
@@ -278,7 +278,7 @@
 		if (MACHINE_IS_VM)
 			cpcmd ("IPL", NULL, 0);
 		else
-			do_reipl (0x10000 | S390_lowcore.ipl_device);
+			reipl (0x10000 | S390_lowcore.ipl_device);
 	}
 	signal_processor(smp_processor_id(), sigp_stop);
 }

