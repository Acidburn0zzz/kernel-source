- Description: cio: Always get subchannel from list.
  Symptom:     Oopses during heavy machine check load and vary on/off stress.
  Problem:     Obtaining a subchannel via stsch() might yield a subchannel not yet
               or not any longer registered, leading to incorrect handling.
  Solution:    Always obtain subchannels by its id via searching the devices list
               of the css bus.
  Problem-ID:  -
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/cio/css.c	5 Apr 2004 17:24:50 -0000	1.72
+++ linux-2.5/drivers/s390/cio/css.c	8 Jun 2004 11:57:13 -0000	1.72.2.1
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/css.c
  *  driver for channel subsystem
- *   $Revision: 1.72 $
+ *   $Revision: 1.72.2.1 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -124,24 +124,6 @@
 	return ret;
 }
 
-static struct subchannel *
-__get_subchannel_by_stsch(int irq)
-{
-	struct subchannel *sch;
-	int cc;
-	struct schib schib;
-
-	cc = stsch(irq, &schib);
-	if (cc || !schib.pmcw.dnv)
-		return NULL;
-	sch = (struct subchannel *)(unsigned long)schib.pmcw.intparm;
-	if (!sch)
-		return NULL;
-	if (get_device(&sch->dev))
-		return sch;
-	return NULL;
-}
-
 struct subchannel *
 get_subchannel_by_schid(int irq)
 {
@@ -151,13 +133,8 @@
 
 	if (!get_bus(&css_bus_type))
 		return NULL;
-
-	/* Try to get subchannel from pmcw first. */ 
-	sch = __get_subchannel_by_stsch(irq);
-	if (sch)
-		goto out;
 	down_read(&css_bus_type.subsys.rwsem);
-
+	sch = NULL;
 	list_for_each(entry, &css_bus_type.devices.list) {
 		dev = get_device(container_of(entry,
 					      struct device, bus_list));
@@ -170,7 +147,6 @@
 		sch = NULL;
 	}
 	up_read(&css_bus_type.subsys.rwsem);
-out:
 	put_bus(&css_bus_type);
 
 	return sch;

