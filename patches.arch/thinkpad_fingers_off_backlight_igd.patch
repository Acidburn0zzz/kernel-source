From: Thomas Renninger <trenn@stravinsky.suse.de>
Subject: Serve ThinkPad IGD devices backlight functionality through thinkpad_acpi
References: fate #302883

In future IDG devices will be handled by the dri subsystem.
But this code is very young and complex, better workaround this in
thinkpad_acpi driver for now.

If in a later service pack the IGD parts get backported, this patch must
be reverted.

Signed-off-by: Thomas Renninger <trenn@suse.de>
---
 drivers/acpi/video_detect.c          |   15 +++++++++++++
 drivers/platform/x86/thinkpad_acpi.c |   38 +++++++++++++++++++++++++++++++----
 include/linux/acpi.h                 |    2 +
 3 files changed, 51 insertions(+), 4 deletions(-)

--- a/drivers/acpi/video_detect.c
+++ b/drivers/acpi/video_detect.c
@@ -98,6 +98,21 @@ long acpi_is_video_device(struct acpi_de
 				    ACPI_UINT32_MAX, acpi_backlight_cap_match,
 				    &video_caps, NULL);
 
+	/* IGD detection is not perfect. It should use the same method as done
+	 * to identify an IGD device in the dri parts or video.ko
+	 */
+
+	/*
+	 * ThinkPads do need the IGD implementation, we detect ThinkPad IGD
+	 * devices here and specially workaround it in thinkpad_acpi as the
+	 * IGD parts are too experimental yet
+	*/
+	if (dmi_name_in_vendors("LENOVO") &&
+	    ACPI_SUCCESS(acpi_get_handle(device->handle, "DRDY", &h_dummy))) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IGD device\n"));
+		video_caps |= ACPI_VIDEO_IGD;
+	}
+
 	return video_caps;
 }
 EXPORT_SYMBOL(acpi_is_video_device);
--- a/drivers/platform/x86/thinkpad_acpi.c
+++ b/drivers/platform/x86/thinkpad_acpi.c
@@ -263,6 +263,7 @@ static struct {
 	u32 light_status:1;
 	u32 bright_16levels:1;
 	u32 bright_acpimode:1;
+	u32 bright_igdmode:1;
 	u32 wan:1;
 	u32 uwb:1;
 	u32 fan_ctrl_status_undef:1;
@@ -2573,6 +2574,9 @@ err_exit:
 	return (res < 0)? res : 1;
 }
 
+static struct backlight_device *ibm_backlight_device;
+static int brightness_update_status(struct backlight_device *bd);
+
 static bool hotkey_notify_hotkey(const u32 hkey,
 				 bool *send_acpi_ev,
 				 bool *ignore_acpi_ev)
@@ -2582,6 +2586,26 @@ static bool hotkey_notify_hotkey(const u
 	*send_acpi_ev = true;
 	*ignore_acpi_ev = false;
 
+	if (tp_features.bright_igdmode && ibm_backlight_device) {
+		/* ToDo: Is there an already defined key? */
+		if (hkey == 0x1011) {
+			if (ibm_backlight_device->
+			    props.brightness > 0) {
+				ibm_backlight_device->
+					props.brightness--;
+			}
+		} else if (hkey == 0x1010) {
+			if (ibm_backlight_device->
+			    props.brightness <
+			    ibm_backlight_device->
+			    props.max_brightness) {
+				ibm_backlight_device->
+					props.brightness++;
+			}
+		}
+		brightness_update_status(ibm_backlight_device);
+	}
+
 	if (scancode > 0 && scancode < 0x21) {
 		scancode--;
 		if (!(hotkey_source_mask & (1 << scancode))) {
@@ -5349,7 +5373,6 @@ enum {
 	TP_EC_BACKLIGHT_MAPSW = 0x20,
 };
 
-static struct backlight_device *ibm_backlight_device;
 static int brightness_mode;
 static unsigned int brightness_enable = 2; /* 2 = auto, 0 = no, 1 = yes */
 
@@ -5488,7 +5511,7 @@ static struct backlight_ops ibm_backligh
 static int __init brightness_init(struct ibm_init_struct *iibm)
 {
 	int b;
-
+	long acpi_video_support;
 	vdbg_printk(TPACPI_DBG_INIT, "initializing brightness subdriver\n");
 
 	mutex_init(&brightness_mutex);
@@ -5500,8 +5523,9 @@ static int __init brightness_init(struct
 	 */
 	b = tpacpi_check_std_acpi_brightness_support();
 	if (b > 0) {
-
-		if (acpi_video_backlight_support()) {
+		acpi_video_support = acpi_video_backlight_support();
+		if (acpi_video_support &&
+		    !(acpi_video_support & ACPI_VIDEO_IGD)) {
 			if (brightness_enable > 1) {
 				printk(TPACPI_NOTICE
 				       "Standard ACPI backlight interface "
@@ -5519,6 +5543,12 @@ static int __init brightness_init(struct
 				       "available, thinkpad_acpi native "
 				       "brightness control enabled\n");
 			}
+			if (acpi_video_support & ACPI_VIDEO_IGD) {
+				printk(TPACPI_NOTICE, "IGD device"
+				       " detected - take over backlight"
+				       " switching\n");
+				tp_features.bright_igdmode = 1;
+			}
 		}
 	}
 
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -186,6 +186,8 @@ extern bool wmi_has_guid(const char *gui
 #define ACPI_VIDEO_BACKLIGHT_DMI_VIDEO			0x0200
 #define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VENDOR		0x0400
 #define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VIDEO		0x0800
+/* Do not use the IGD define, this is a SUSE only ThinkPad workaround hack! */
+#define ACPI_VIDEO_IGD					0x1000
 
 #if defined(CONFIG_ACPI_VIDEO) || defined(CONFIG_ACPI_VIDEO_MODULE)
 
