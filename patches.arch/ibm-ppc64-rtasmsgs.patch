diff -Nru a/arch/ppc64/kernel/rtas-proc.c b/arch/ppc64/kernel/rtas-proc.c
--- a/arch/ppc64/kernel/rtas-proc.c	Fri May  7 11:55:10 2004
+++ b/arch/ppc64/kernel/rtas-proc.c	Fri May  7 11:55:10 2004
@@ -162,6 +162,10 @@
 		size_t count, loff_t *ppos);
 static ssize_t ppc_rtas_rmo_buf_read(struct file *file, char *buf,
 				    size_t count, loff_t *ppos);
+static ssize_t ppc_rtas_msg_write(struct file * file, const char * buf,
+		size_t count, loff_t *ppos);
+static ssize_t ppc_rtas_msg_read(struct file * file, char * buf,
+		size_t count, loff_t *ppos);
 
 struct file_operations ppc_rtas_poweron_operations = {
 	.read =		ppc_rtas_poweron_read,
@@ -189,6 +193,10 @@
 static struct file_operations ppc_rtas_rmo_buf_ops = {
 	.read =		ppc_rtas_rmo_buf_read,
 };
+struct file_operations ppc_rtas_msg_operations = {
+	.read =		ppc_rtas_msg_read,
+	.write =	ppc_rtas_msg_write
+};
 
 int ppc_rtas_find_all_sensors (void);
 int ppc_rtas_process_sensor(struct individual_sensor s, int state, 
@@ -237,6 +245,10 @@
 	if (entry)
 		entry->proc_fops = &ppc_rtas_rmo_buf_ops;
 
+	entry = create_proc_entry("ppc64/rtas/rtasmsgs", S_IRUSR, NULL);
+	if (entry)
+		entry->proc_fops = &ppc_rtas_msg_operations;
+
 	return 0;
 }
 
@@ -954,3 +966,50 @@
 	
 	return n;
 }
+
+/* ****************************************************************** */
+
+static ssize_t ppc_rtas_msg_write(struct file * file, const char * buf,
+		size_t count, loff_t *ppos)
+{
+	char stkbuf[40];  /* its small, its on stack */
+	char *dest;
+
+	if (39 < count) count = 39;
+	if (copy_from_user (stkbuf, buf, count)) {
+		return -EFAULT;
+	}
+	stkbuf[count] = 0;
+	print_rtasmsgs = simple_strtoul(stkbuf, &dest, 10);
+	if (*dest != '\0' && *dest != '\n') {
+		printk("ppc_rtas_msg_write: Invalid message setting\n");
+		return count;
+	}
+	
+	printk(KERN_INFO "RTAS: %s rtas messsage output to /var/log/messages\n",
+		(print_rtasmsgs ? "Enabling" : "Disabling"));
+	return count;
+}
+
+static ssize_t ppc_rtas_msg_read(struct file * file, char * buf,
+		size_t count, loff_t *ppos)
+{
+	int n, sn;
+	char stkbuf[40];  /* its small, its on stack */
+
+	n = scnprintf(stkbuf, 40, "%d\n", print_rtasmsgs);
+
+	sn = strlen (stkbuf) +1;
+	if (*ppos >= sn)
+		return 0;
+	if (n > sn - *ppos)
+		n = sn - *ppos;
+	if (n > count)
+		n = count;
+	if (copy_to_user (buf, stkbuf + (*ppos), n)) {
+		return -EFAULT;
+	}
+	*ppos += n;
+	return n;
+}
+
diff -Nru a/arch/ppc64/kernel/rtasd.c b/arch/ppc64/kernel/rtasd.c
--- a/arch/ppc64/kernel/rtasd.c	Fri May  7 11:55:10 2004
+++ b/arch/ppc64/kernel/rtasd.c	Fri May  7 11:55:10 2004
@@ -50,6 +50,8 @@
 
 volatile int error_log_cnt = 0;
 
+int print_rtasmsgs = 1;
+
 /*
  * Since we use 32 bit RTAS, the physical address of this must be below
  * 4G or else bad things happen. Allocate this in the kernel data and
@@ -78,6 +80,9 @@
 	char buffer[64];
 	char * str = "RTAS event";
 
+	if (print_rtasmsgs == 0)
+		return;
+
 	printk(RTAS_DEBUG "%d -------- %s begin --------\n", error_log_cnt, str);
 
 	/*
@@ -474,5 +479,15 @@
 	return 1;
 }
 
+static int __init rtasmsg_setup(char *str)
+{
+	int i;
+	if (get_option(&str, &i)) 
+		print_rtasmsgs = i;
+
+	return 1;
+}
+
 __initcall(rtas_init);
 __setup("surveillance=", surveillance_setup);
+__setup("rtasmsgs=", rtasmsg_setup);
diff -Nru a/include/asm-ppc64/rtas.h b/include/asm-ppc64/rtas.h
--- a/include/asm-ppc64/rtas.h	Fri May  7 11:55:10 2004
+++ b/include/asm-ppc64/rtas.h	Fri May  7 11:55:10 2004
@@ -166,6 +166,8 @@
 
 extern struct rtas_t rtas;
 
+extern int print_rtasmsgs;
+
 extern void enter_rtas(struct rtas_args *);
 extern int rtas_token(const char *service);
 extern long rtas_call(int token, int, int, unsigned long *, ...);
