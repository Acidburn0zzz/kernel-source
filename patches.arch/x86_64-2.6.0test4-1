diff -burpN -X ../KDIFX linux/arch/x86_64/defconfig linux-2.6.0test4-amd64/arch/x86_64/defconfig
--- linux/arch/x86_64/defconfig	2003-08-23 13:03:11.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/defconfig	2003-08-23 13:57:05.000000000 +0200
@@ -14,6 +14,7 @@ CONFIG_GENERIC_ISA_DMA=y
 # Code maturity level options
 #
 CONFIG_EXPERIMENTAL=y
+# CONFIG_BROKEN is not set
 
 #
 # General setup
@@ -23,10 +24,12 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=18
+# CONFIG_IKCONFIG is not set
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 
@@ -72,10 +75,10 @@ CONFIG_PM=y
 CONFIG_SOFTWARE_SUSPEND=y
 
 #
-# ACPI Support
+# ACPI (Advanced Configuration and Power Interface) Support
 #
+# CONFIG_ACPI_HT is not set
 CONFIG_ACPI=y
-# CONFIG_ACPI_HT_ONLY is not set
 CONFIG_ACPI_BOOT=y
 CONFIG_ACPI_SLEEP=y
 CONFIG_ACPI_SLEEP_PROC_FS=y
@@ -117,7 +120,6 @@ CONFIG_UID16=y
 #
 # Generic Driver Options
 #
-# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -159,6 +161,7 @@ CONFIG_BLK_DEV_IDEDISK=y
 CONFIG_IDEDISK_MULTI_MODE=y
 # CONFIG_IDEDISK_STROKE is not set
 CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
 # CONFIG_BLK_DEV_IDESCSI is not set
 # CONFIG_IDE_TASK_IOCTL is not set
@@ -318,7 +321,6 @@ CONFIG_IP_MULTICAST=y
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_NETFILTER is not set
-# CONFIG_XFRM_USER is not set
 
 #
 # SCTP Configuration (EXPERIMENTAL)
@@ -405,6 +407,7 @@ CONFIG_E1000=m
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
 # CONFIG_SK98LIN is not set
 CONFIG_TIGON3=y
 
@@ -595,10 +598,7 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=y
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
-CONFIG_JFS_FS=y
-CONFIG_JFS_POSIX_ACL=y
-# CONFIG_JFS_DEBUG is not set
-# CONFIG_JFS_STATISTICS is not set
+# CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
@@ -674,49 +674,6 @@ CONFIG_SUNRPC=y
 #
 # CONFIG_PARTITION_ADVANCED is not set
 CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-
-#
-# Native Language Support
-#
-CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_CODEPAGE_437 is not set
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ISO8859_1 is not set
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
 
 #
 # Graphics support
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/apic.c linux-2.6.0test4-amd64/arch/x86_64/kernel/apic.c
--- linux/arch/x86_64/kernel/apic.c	2003-08-23 13:03:11.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/kernel/apic.c	2003-08-23 14:13:33.000000000 +0200
@@ -299,7 +299,7 @@ void __init setup_local_APIC (void)
 	 * This is meaningless in clustered apic mode, so we skip it.
 	 */
 	if (!clustered_apic_mode &&
-		!cpu_isset(GET_APIC_ID(apic_read(APIC_ID)), phys_cpu_present_map))
+		!physid_isset(GET_APIC_ID(apic_read(APIC_ID)), phys_cpu_present_map))
 		BUG();
 
 	/*
@@ -993,7 +993,7 @@ int __init APIC_init_uniprocessor (void)
 
 	connect_bsp_APIC();
 
-	phys_cpu_present_map = cpumask_of_cpu(0);
+	phys_cpu_present_map = physid_mask_of_physid(0);
 	apic_write_around(APIC_ID, boot_cpu_id);
 
 	setup_local_APIC();
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/io_apic.c linux-2.6.0test4-amd64/arch/x86_64/kernel/io_apic.c
--- linux/arch/x86_64/kernel/io_apic.c	2003-08-23 13:03:11.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/kernel/io_apic.c	2003-08-23 14:13:33.000000000 +0200
@@ -1014,7 +1014,7 @@ void disable_IO_APIC(void)
 static void __init setup_ioapic_ids_from_mpc (void)
 {
 	union IO_APIC_reg_00 reg_00;
-	cpumask_t phys_id_present_map = phys_cpu_present_map;
+	physid_mask_t phys_id_present_map = phys_cpu_present_map;
 	int apic;
 	int i;
 	unsigned char old_id;
@@ -1047,22 +1047,22 @@ static void __init setup_ioapic_ids_from
 		 * system must have a unique ID or we get lots of nice
 		 * 'stuck on smp_invalidate_needed IPI wait' messages.
 	 	 */
-		if (cpu_isset(mp_ioapics[apic].mpc_apicid, phys_id_present_map)) {
+		if (physid_isset(mp_ioapics[apic].mpc_apicid, phys_id_present_map)) {
 			printk(KERN_ERR "BIOS bug, IO-APIC#%d ID %d is already used!...\n",
 				apic, mp_ioapics[apic].mpc_apicid);
 			for (i = 0; i < 0xf; i++)
-				if (!cpu_isset(i, phys_id_present_map))
+				if (!physid_isset(i, phys_id_present_map))
 					break;
 			if (i >= 0xf)
 				panic("Max APIC ID exceeded!\n");
 			printk(KERN_ERR "... fixing up to %d. (tell your hw vendor)\n",
 				i);
-			cpu_set(i, phys_id_present_map);
+			physid_set(i, phys_id_present_map);
 			mp_ioapics[apic].mpc_apicid = i;
 		} else {
 			printk(KERN_INFO 
 			       "Using IO-APIC %d\n", mp_ioapics[apic].mpc_apicid);
-			cpu_set(mp_ioapics[apic].mpc_apicid, phys_id_present_map);
+			physid_set(mp_ioapics[apic].mpc_apicid, phys_id_present_map);
 		}
 
 
@@ -1642,7 +1642,7 @@ void __init mp_config_ioapic_for_sci(int
 int __init io_apic_get_unique_id (int ioapic, int apic_id)
 {
 	union IO_APIC_reg_00 reg_00;
-	static cpumask_t apic_id_map;
+	static physid_mask_t apic_id_map;
 	unsigned long flags;
 	int i = 0;
 
@@ -1655,7 +1655,7 @@ int __init io_apic_get_unique_id (int io
 	 *      advantage of new APIC bus architecture.
 	 */
 
-	if (!cpus_empty(apic_id_map))
+	if (!physids_empty(apic_id_map))
 		apic_id_map = phys_cpu_present_map;
 
 	spin_lock_irqsave(&ioapic_lock, flags);
@@ -1672,10 +1672,10 @@ int __init io_apic_get_unique_id (int io
 	 * Every APIC in a system must have a unique ID or we get lots of nice 
 	 * 'stuck on smp_invalidate_needed IPI wait' messages.
 	 */
-	if (cpu_isset(apic_id, apic_id_map)) {
+	if (physid_isset(apic_id, apic_id_map)) {
 
 		for (i = 0; i < IO_APIC_MAX_ID; i++) {
-			if (!cpu_isset(i, apic_id_map))
+			if (!physid_isset(i, apic_id_map))
 				break;
 		}
 
@@ -1688,7 +1688,7 @@ int __init io_apic_get_unique_id (int io
 		apic_id = i;
 	} 
 
-	cpu_set(apic_id, apic_id_map);
+	physid_set(apic_id, apic_id_map);
 
 	if (reg_00.bits.ID != apic_id) {
 		reg_00.bits.ID = apic_id;
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/ioport.c linux-2.6.0test4-amd64/arch/x86_64/kernel/ioport.c
--- linux/arch/x86_64/kernel/ioport.c	2003-08-23 13:03:11.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/kernel/ioport.c	2003-08-23 14:03:34.000000000 +0200
@@ -10,12 +10,11 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/ioport.h>
-#include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
 #include <linux/slab.h>
-#include <asm/io.h>
+#include <linux/thread_info.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base, unsigned int extent, int new_value)
@@ -118,12 +117,7 @@ asmlinkage long sys_iopl(unsigned int le
 			return -EPERM;
 	}
 	regs.eflags = (regs.eflags &~ 0x3000UL) | (level << 12);
+	/* Make sure we return the long way (not sysenter) */
+	set_thread_flag(TIF_IRET);
 	return 0;
 }
-
-void eat_key(void)
-{
-	if (inb(0x60) & 1) 
-		inb(0x64);
-}
-
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/mpparse.c linux-2.6.0test4-amd64/arch/x86_64/kernel/mpparse.c
--- linux/arch/x86_64/kernel/mpparse.c	2003-08-23 13:03:11.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/kernel/mpparse.c	2003-08-23 14:13:33.000000000 +0200
@@ -67,7 +67,7 @@ unsigned int boot_cpu_id = -1U;
 static unsigned int num_processors = 0;
 
 /* Bitmask of physically existing CPUs */
-cpumask_t phys_cpu_present_map = CPU_MASK_NONE;
+physid_mask_t phys_cpu_present_map = PHYSID_MASK_NONE;
 
 /* ACPI MADT entry parsing functions */
 #ifdef CONFIG_ACPI_BOOT
@@ -126,7 +126,7 @@ static void __init MP_processor_info (st
 	}
 	ver = m->mpc_apicver;
 
-	cpu_set(m->mpc_apicid, phys_cpu_present_map);
+	physid_set(m->mpc_apicid, phys_cpu_present_map);
 	/*
 	 * Validate version
 	 */
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/setup.c linux-2.6.0test4-amd64/arch/x86_64/kernel/setup.c
--- linux/arch/x86_64/kernel/setup.c	2003-08-23 13:03:11.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/kernel/setup.c	2003-08-23 13:55:48.000000000 +0200
@@ -243,6 +243,8 @@ static void __init contig_initmem_init(v
 
 void __init setup_arch(char **cmdline_p)
 {
+	unsigned long low_mem_size;
+
  	ROOT_DEV = ORIG_ROOT_DEV;
  	drive_info = DRIVE_INFO;
  	screen_info = SCREEN_INFO;
@@ -378,7 +380,13 @@ void __init setup_arch(char **cmdline_p)
 		request_resource(&ioport_resource, standard_io_resources+i);
 	}
 
-	pci_mem_start = IOMAP_START; 
+	/* Will likely break when you have unassigned resources with more
+	   than 4GB memory and bridges that don't support more than 4GB. 
+	   Doing it properly would require to allocate GFP_DMA memory
+	   in this case. */
+	low_mem_size = ((end_pfn << PAGE_SHIFT) + 0xfffff) & ~0xfffff;
+	if (low_mem_size > pci_mem_start)
+		pci_mem_start = low_mem_size;
 
 #ifdef CONFIG_GART_IOMMU
        iommu_hole_init();
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/smpboot.c linux-2.6.0test4-amd64/arch/x86_64/kernel/smpboot.c
--- linux/arch/x86_64/kernel/smpboot.c	2003-08-23 13:03:11.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/kernel/smpboot.c	2003-08-23 14:13:33.000000000 +0200
@@ -734,10 +734,10 @@ static void __init smp_boot_cpus(unsigne
 	current_thread_info()->cpu = 0;
 	smp_tune_scheduling();
 
-	if (!cpu_isset(hard_smp_processor_id(), phys_cpu_present_map)) {
+	if (!physid_isset(hard_smp_processor_id(), phys_cpu_present_map)) {
 		printk("weird, boot CPU (#%d) not listed by the BIOS.\n",
 		       hard_smp_processor_id());
-		cpu_set(hard_smp_processor_id(), phys_cpu_present_map);
+		physid_set(hard_smp_processor_id(), phys_cpu_present_map);
 	}
 
 	/*
@@ -748,7 +748,7 @@ static void __init smp_boot_cpus(unsigne
 		printk(KERN_NOTICE "SMP motherboard not detected.\n");
 		io_apic_irqs = 0;
 		cpu_online_map = cpumask_of_cpu(0);
-		phys_cpu_present_map = cpumask_of_cpu(0);
+		phys_cpu_present_map = physid_mask_of_physid(0);
 		if (APIC_init_uniprocessor())
 			printk(KERN_NOTICE "Local APIC not detected."
 					   " Using dummy APIC emulation.\n");
@@ -759,10 +759,10 @@ static void __init smp_boot_cpus(unsigne
 	 * Should not be necessary because the MP table should list the boot
 	 * CPU too, but we do it for the sake of robustness anyway.
 	 */
-	if (!cpu_isset(boot_cpu_id, phys_cpu_present_map)) {
+	if (!physid_isset(boot_cpu_id, phys_cpu_present_map)) {
 		printk(KERN_NOTICE "weird, boot CPU (#%d) not listed by the BIOS.\n",
 								 boot_cpu_id);
-		cpu_set(hard_smp_processor_id(), phys_cpu_present_map);
+		physid_set(hard_smp_processor_id(), phys_cpu_present_map);
 	}
 
 	/*
@@ -774,7 +774,7 @@ static void __init smp_boot_cpus(unsigne
 		printk(KERN_ERR "... forcing use of dummy APIC emulation. (tell your hw vendor)\n");
 		io_apic_irqs = 0;
 		cpu_online_map = cpumask_of_cpu(0);
-		phys_cpu_present_map = cpumask_of_cpu(0);
+		phys_cpu_present_map = physid_mask_of_physid(0);
 		disable_apic = 1;
 		goto smp_done;
 	}
@@ -789,7 +789,7 @@ static void __init smp_boot_cpus(unsigne
 		printk(KERN_INFO "SMP mode deactivated, forcing use of dummy APIC emulation.\n");
 		io_apic_irqs = 0;
 		cpu_online_map = cpumask_of_cpu(0);
-		phys_cpu_present_map = cpumask_of_cpu(0);
+		phys_cpu_present_map = physid_mask_of_physid(0);
 		disable_apic = 1;
 		goto smp_done;
 	}
@@ -803,7 +803,7 @@ static void __init smp_boot_cpus(unsigne
 	/*
 	 * Now scan the CPU present map and fire up the other CPUs.
 	 */
-	Dprintk("CPU present map: %lx\n", phys_cpu_present_map);
+	Dprintk("CPU present map: %lx\n", physids_coerce(phys_cpu_present_map));
 
 	for (apicid = 0; apicid < NR_CPUS; apicid++) {
 		/*
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/time.c linux-2.6.0test4-amd64/arch/x86_64/kernel/time.c
--- linux/arch/x86_64/kernel/time.c	2003-07-18 02:42:38.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/kernel/time.c	2003-08-23 13:31:18.000000000 +0200
@@ -79,6 +79,7 @@ static inline unsigned int do_gettimeoff
 	unsigned long t;
 	unsigned long x;
 	rdtscll_sync(&t);
+	if (t < vxtime.last_tsc) t = vxtime.last_tsc; /* hack */
 	x = ((t - vxtime.last_tsc) * vxtime.tsc_quot) >> 32;
 	return x;
 }
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/vsyscall.c linux-2.6.0test4-amd64/arch/x86_64/kernel/vsyscall.c
--- linux/arch/x86_64/kernel/vsyscall.c	2003-07-18 02:39:06.000000000 +0200
+++ linux-2.6.0test4-amd64/arch/x86_64/kernel/vsyscall.c	2003-08-23 13:31:40.000000000 +0200
@@ -85,6 +85,7 @@ static force_inline void do_vgettimeofda
 		if (__vxtime.mode == VXTIME_TSC) {
 			sync_core();
 			rdtscll(t);
+			if (t < __vxtime.last_tsc) t = __vxtime.last_tsc;
 			usec += ((t - __vxtime.last_tsc) *
 				 __vxtime.tsc_quot) >> 32;
 		} else {
diff -burpN -X ../KDIFX linux/drivers/acpi/Kconfig linux-2.6.0test4-amd64/drivers/acpi/Kconfig
--- linux/drivers/acpi/Kconfig	2003-08-23 13:03:11.000000000 +0200
+++ linux-2.6.0test4-amd64/drivers/acpi/Kconfig	2003-08-23 13:07:34.000000000 +0200
@@ -69,6 +69,7 @@ config ACPI_SLEEP
 	bool "Sleep States (EXPERIMENTAL)"
 	depends on X86 && ACPI
 	depends on EXPERIMENTAL && PM
+	select SOFTWARE_SUSPEND
 	default y
 	---help---
 	  This option adds support for ACPI suspend states. 
diff -burpN -X ../KDIFX linux/drivers/char/agp/Kconfig linux-2.6.0test4-amd64/drivers/char/agp/Kconfig
--- linux/drivers/char/agp/Kconfig	2003-08-23 13:03:12.000000000 +0200
+++ linux-2.6.0test4-amd64/drivers/char/agp/Kconfig	2003-08-23 13:00:00.000000000 +0200
@@ -63,15 +63,19 @@ config AGP_AMD
 	  You should say Y here if you use XFree86 3.3.6 or 4.x and want to
 	  use GLX or DRI.  If unsure, say N.
 
+# RED-PEN this option is misnamed, it's not 8151 specific
 config AGP_AMD_8151
 	tristate "AMD Opteron/Athlon64 on-CPU GART support"
 	depends on AGP && X86
 	default GART_IOMMU
 	help
 	  This option gives you AGP support for the GLX component of
-	  XFree86 4.x using the on-CPU AGP bridge of the AMD Athlon64/Opteron CPUs.
+	  XFree86 4.x using the on-CPU northbridge of the AMD Athlon64/Opteron CPUs.
+	  You still need an external AGP bridge like the AMD 8151, VIA
+          K8T400M, SiS755. It may also support other AGP bridges when loaded
+	  with agp_try_unsupported=1.
 	  You should say Y here if you use XFree86 3.3.6 or 4.x and want to
-	  use GLX or DRI.  If unsure, say N
+	  use GLX or DRI.  If unsure, say Y
 
 config AGP_INTEL
 	tristate "Intel 440LX/BX/GX, I8xx and E7x05 chipset support"
diff -burpN -X ../KDIFX linux/drivers/char/agp/agp.h linux-2.6.0test4-amd64/drivers/char/agp/agp.h
--- linux/drivers/char/agp/agp.h	2003-08-23 13:03:12.000000000 +0200
+++ linux-2.6.0test4-amd64/drivers/char/agp/agp.h	2003-08-23 13:00:00.000000000 +0200
@@ -406,6 +406,8 @@ void global_cache_flush(void);
 void get_agp_version(struct agp_bridge_data *bridge);
 unsigned long agp_generic_mask_memory(unsigned long addr, int type);
 
+extern int agp_off;
+
 /* Standard agp registers */
 #define AGPSTAT			0x4
 #define AGPCMD			0x8
diff -burpN -X ../KDIFX linux/drivers/char/agp/amd-k8-agp.c linux-2.6.0test4-amd64/drivers/char/agp/amd-k8-agp.c
--- linux/drivers/char/agp/amd-k8-agp.c	2003-08-09 16:48:03.000000000 +0200
+++ linux-2.6.0test4-amd64/drivers/char/agp/amd-k8-agp.c	2003-08-09 16:50:16.000000000 +0200
@@ -8,12 +8,6 @@
  * work is done in the northbridge(s).
  */
 
-/*
- * On x86-64 the AGP driver needs to be initialized early by the IOMMU 
- * code.  When you use this driver as a template for a new K8 AGP bridge
- * driver don't forget to change arch/x86_64/kernel/pci-gart.c too -AK.
- */
-
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/init.h>
@@ -21,7 +15,11 @@
 #include "agp.h"
 
 /* Will need to be increased if hammer ever goes >8-way. */
+#ifdef CONFIG_SMP
 #define MAX_HAMMER_GARTS   8
+#else
+#define MAX_HAMMER_GARTS   1
+#endif
 
 /* PTE bits. */
 #define GPTE_VALID	1
@@ -39,6 +37,8 @@
 static int nr_garts;
 static struct pci_dev * hammers[MAX_HAMMER_GARTS];
 
+static int __initdata agp_try_unsupported;
+
 static int gart_iterator;
 #define for_each_nb() for(gart_iterator=0;gart_iterator<nr_garts;gart_iterator++)
 
@@ -246,24 +246,128 @@ struct agp_bridge_driver amd_8151_driver
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
+/* Some basic sanity checks for the aperture. */
+static int __init aperture_valid(u64 aper, u32 size)
+{ 
+	static int not_first_call; 
+	u32 pfn, c;
+	if (aper == 0) { 
+		printk(KERN_ERR "No aperture\n");
+		return 0; 
+	}
+	if (size < 32*1024*1024) {
+		printk(KERN_ERR "Aperture too small (%d MB)\n", size>>20);
+		return 0;
+	}
+	if (aper + size > 0xffffffff) { 
+		printk(KERN_ERR "Aperture out of bounds\n"); 
+		return 0;
+	} 
+	pfn = aper >> PAGE_SHIFT;
+	for (c = 0; c < size/PAGE_SIZE; c++) { 
+		if (!pfn_valid(pfn + c))
+			break;
+		if (!PageReserved(pfn_to_page(pfn + c))) { 
+			printk(KERN_ERR "Aperture pointing to RAM\n");
+			return 0;
+		}
+	}
+
+	/* Request the Aperture. This catches cases when someone else
+	   already put a mapping in there - happens with some very broken BIOS 
 
-#ifdef CONFIG_SMP
-static int cache_nbs (void)
+	   Maybe better to use pci_assign_resource/pci_enable_device instead trusting
+	   the bridges? */
+	if (!not_first_call && request_mem_region(aper, size, "aperture") < 0) { 
+		printk(KERN_ERR "Aperture conflicts with PCI mapping.\n"); 
+		return 0;
+	}
+
+	not_first_call = 1;
+	return 1;
+} 
+
+/* 
+ * W*s centric BIOS sometimes only set up the aperture in the AGP
+ * bridge, not the northbridge. On AMD64 this is handled early 
+ * in aperture.c, but when GART_IOMMU is not enabled or we run
+ * on a 32bit kernel this needs to be redone. 
+ * Unfortunately it is impossible to fix the aperture here because it's too late
+ * to allocate that much memory. But at least error out cleanly instead of
+ * crashing.
+ */ 
+static __init int fix_northbridge(struct pci_dev *nb, struct pci_dev *agp, 
+								 u16 cap)
+{
+	u32 aper_low, aper_hi;
+	u64 aper, nb_aper;
+	int order = 0;
+	u32 nb_order, nb_base;
+	u16 apsize;
+
+	printk("fix northbridge\n");
+
+	pci_read_config_dword(nb, 0x90, &nb_order); 
+	nb_order = (nb_order >> 1) & 7;
+	pci_read_config_dword(nb, 0x94, &nb_base); 
+	nb_aper = nb_base << 25;	
+	if (aperture_valid(nb_aper, (32*1024*1024)<<nb_order)) { 
+		printk("aperture valid\n");
+		return 0;
+	}
+
+	/* Northbridge seems to contain crap. Try the AGP bridge. */
+
+	pci_read_config_word(agp, cap+0x14, &apsize); 
+	if (apsize == 0xffff) 
+		return -1; 
+
+	apsize &= 0xfff;
+	/* Some BIOS use weird encodings not in the AGPv3 table. */
+	if (apsize & 0xff) 
+		apsize |= 0xf00; 
+	order = 7 - hweight16(apsize); 
+
+	pci_read_config_dword(agp, 0x10, &aper_low);
+	pci_read_config_dword(agp, 0x14, &aper_hi);
+	aper = (aper_low & ~((1<<22)-1)) | ((u64)aper_hi << 32); 
+	printk(KERN_INFO "Aperture from AGP @ %Lx size %u MB\n", aper, 32 << order);
+	if (order < 0 || !aperture_valid(aper, (32*1024*1024)<<order)) { 
+		printk("bad aperture\n");
+		return -1; 
+	}
+	
+	pci_write_config_dword(nb, 0x90, order << 1); 
+	pci_write_config_dword(nb, 0x94, aper >> 25); 
+
+	return 0;
+} 
+
+static __init int cache_nbs (struct pci_dev *pdev, u32 cap_ptr)
 {
 	struct pci_dev *loop_dev = NULL;
 	int i = 0;
 
 	/* cache pci_devs of northbridges. */
-	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) != NULL) {
+	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) 
+			!= NULL) {
+		if (fix_northbridge(loop_dev, pdev, cap_ptr) < 0) { 
+			printk("No usable aperture found.\n");
+#ifdef __x86_64__ 
+			/* should port this to i386 */
+			printk("Consider rebooting with iommu=memaper=2 to get a good aperture.\n");
+#endif 
+			return -1;  
+		}
 		hammers[i++] = loop_dev;
 		nr_garts = i;
-		if (i == MAX_HAMMER_GARTS)
+		if (i == MAX_HAMMER_GARTS) { 
+			printk(KERN_INFO "Too many northbridges for AGP\n");
 			return -1;
 	}
-	return 0;
+	}
+	return i == 0 ? -1 : 0;
 }
-#endif
-
 
 static int __init agp_amdk8_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *ent)
@@ -277,7 +381,7 @@ static int __init agp_amdk8_probe(struct
 	if (!cap_ptr)
 		return -ENODEV;
 
-	printk(KERN_INFO PFX "Detected Opteron/Athlon64 on-CPU GART\n");
+	/* Could check for AGPv3 here */
 
 	bridge = agp_alloc_bridge();
 	if (!bridge)
@@ -311,6 +415,9 @@ static int __init agp_amdk8_probe(struct
 			bridge->major_version = 3;
 			bridge->minor_version = 0;
 		}
+	} else {
+		printk(KERN_INFO PFX "Detected AGP bridge %x\n",
+			pdev->devfn);
 	}
 
 	bridge->driver = &amd_8151_driver;
@@ -320,22 +427,10 @@ static int __init agp_amdk8_probe(struct
 	/* Fill in the mode register */
 	pci_read_config_dword(pdev, bridge->capndx+PCI_AGP_STATUS, &bridge->mode);
 
-#ifdef CONFIG_SMP
-	if (cache_nbs() == -1) {
+	if (cache_nbs(pdev, cap_ptr) == -1) {
 		agp_put_bridge(bridge);
-		return -ENOMEM;
-	}
-#else
-	{
-	struct pci_dev *loop_dev = NULL;
-	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) != NULL) {
-		/* For UP, we only care about the first GART. */
-		hammers[0] = loop_dev;
-		nr_garts = 1;
-		break;
-	}
+		return -ENODEV;
 	}
-#endif
 
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
@@ -345,6 +440,8 @@ static void __devexit agp_amdk8_remove(s
 {
 	struct agp_bridge_data *bridge = pci_get_drvdata(pdev);
 
+	release_mem_region(virt_to_phys(bridge->gatt_table_real), 
+			   x86_64_aperture_sizes[bridge->aperture_size_idx].size); 
 	agp_remove_bridge(bridge);
 	agp_put_bridge(bridge);
 }
@@ -386,10 +483,36 @@ static struct pci_driver agp_amdk8_pci_d
 	.remove		= agp_amdk8_remove,
 };
 
+
 /* Not static due to IOMMU code calling it early. */
 int __init agp_amdk8_init(void)
 {
-	return pci_module_init(&agp_amdk8_pci_driver);
+	int err;
+	if (agp_off)
+		return -EINVAL;
+	err = pci_module_init(&agp_amdk8_pci_driver);
+	if (err == -ENODEV) { 
+		struct pci_dev *dev;
+		if (!agp_try_unsupported) { 
+			printk(KERN_INFO "No supported AGP bridge found.\n");
+			printk(KERN_INFO "You can try agp_try_unsupported=1\n");
+			return err;
+		}
+
+		/* First check that we have at least one K8 NB */
+		if (!pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, NULL))
+			return -ENODEV;
+
+		/* Look for any AGP bridge */
+		dev = NULL;
+		while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev))) {
+			if (!pci_find_capability(dev, PCI_CAP_ID_AGP))
+				continue;
+			if (agp_amdk8_probe(dev, NULL) == 0)
+				err = 0;
+		}		
+	}
+	return err;
 }
 
 static void __exit agp_amdk8_cleanup(void)
@@ -405,5 +528,5 @@ module_exit(agp_amdk8_cleanup);
 #endif
 
 MODULE_AUTHOR("Dave Jones <davej@codemonkey.org.uk>");
+MODULE_PARM(agp_try_unsupported, "1i");
 MODULE_LICENSE("GPL and additional rights");
-
diff -burpN -X ../KDIFX linux/drivers/char/agp/backend.c linux-2.6.0test4-amd64/drivers/char/agp/backend.c
--- linux/drivers/char/agp/backend.c	2003-08-23 13:03:12.000000000 +0200
+++ linux-2.6.0test4-amd64/drivers/char/agp/backend.c	2003-08-23 13:00:00.000000000 +0200
@@ -301,9 +301,12 @@ void agp_remove_bridge(struct agp_bridge
 }
 EXPORT_SYMBOL_GPL(agp_remove_bridge);
 
+int agp_off;
+EXPORT_SYMBOL(agp_off);
 
 static int __init agp_init(void)
 {
+	if (!agp_off) 
 	printk(KERN_INFO "Linux agpgart interface v%d.%d (c) Dave Jones\n",
 	       AGPGART_VERSION_MAJOR, AGPGART_VERSION_MINOR);
 	return 0;
@@ -313,6 +316,13 @@ void __exit agp_exit(void)
 {
 }
 
+static __init int agp_setup(char *s)
+{
+	if (!strcmp(s,"off"))
+		agp_off = 1;
+	return 1;	
+}
+__setup("agp=", agp_setup);
 
 MODULE_AUTHOR("Dave Jones <davej@codemonkey.org.uk>");
 MODULE_DESCRIPTION("AGP GART driver");
diff -burpN -X ../KDIFX linux/drivers/message/fusion/mptscsih.c linux-2.6.0test4-amd64/drivers/message/fusion/mptscsih.c
--- linux/drivers/message/fusion/mptscsih.c	2003-08-23 13:03:14.000000000 +0200
+++ linux-2.6.0test4-amd64/drivers/message/fusion/mptscsih.c	2003-08-23 13:00:00.000000000 +0200
@@ -75,6 +75,7 @@
 #include <linux/delay.h>	/* for mdelay */
 #include <linux/interrupt.h>	/* needed for in_interrupt() proto */
 #include <linux/reboot.h>	/* notifier code */
+#include <linux/nmi.h>
 #include "../../scsi/scsi.h"
 #include "../../scsi/hosts.h"
 
@@ -475,6 +476,8 @@ mptscsih_AddSGE(MPT_SCSI_HOST *hd, Scsi_
 			       (struct scatterlist *) SCpnt->request_buffer,
 			       SCpnt->use_sg,
 			       scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+		if (sges_left == 0) 
+			return FAILED;
 	} else if (SCpnt->request_bufflen) {
 		dma_addr_t	 buf_dma_addr;
 		scPrivate	*my_priv;
@@ -3074,6 +3077,7 @@ mptscsih_tm_pending_wait(MPT_SCSI_HOST *
 			break;
 		}
 		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		touch_nmi_watchdog(); 
 		mdelay(250);
 	} while (--loop_count);
 
diff -burpN -X ../KDIFX linux/fs/proc/task_mmu.c linux-2.6.0test4-amd64/fs/proc/task_mmu.c
--- linux/fs/proc/task_mmu.c	2003-07-18 02:39:41.000000000 +0200
+++ linux-2.6.0test4-amd64/fs/proc/task_mmu.c	2003-08-23 14:08:00.000000000 +0200
@@ -90,14 +90,14 @@ static int show_map(struct seq_file *m, 
 		ino = inode->i_ino;
 	}
 
-	seq_printf(m, "%0*lx-%0*lx %c%c%c%c %0*lx %02x:%02x %lu %n",
-			(int) (2*sizeof(void*)), map->vm_start,
-			(int) (2*sizeof(void*)), map->vm_end,
+	seq_printf(m, "%08lx-%08lx %c%c%c%c %08lx %02x:%02x %lu %n",
+		map->vm_start,
+		map->vm_end,
 			flags & VM_READ ? 'r' : '-',
 			flags & VM_WRITE ? 'w' : '-',
 			flags & VM_EXEC ? 'x' : '-',
 			flags & VM_MAYSHARE ? 's' : 'p',
-			(int) (2*sizeof(void*)), map->vm_pgoff << PAGE_SHIFT,
+		map->vm_pgoff << PAGE_SHIFT,
 			MAJOR(dev), MINOR(dev), ino, &len);
 
 	if (map->vm_file) {
diff -burpN -X ../KDIFX linux/include/asm-x86_64/bitops.h linux-2.6.0test4-amd64/include/asm-x86_64/bitops.h
--- linux/include/asm-x86_64/bitops.h	2003-08-23 13:03:22.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/bitops.h	2003-08-23 13:08:11.000000000 +0200
@@ -466,7 +466,7 @@ static __inline__ int ffs(int x)
 
 	__asm__("bsfl %1,%0\n\t"
 		"cmovzl %2,%0" 
-		: "=r" (r) : "g" (x), "r" (32));
+		: "=r" (r) : "g" (x), "r" (-1));
 	return r+1;
 }
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/compat.h linux-2.6.0test4-amd64/include/asm-x86_64/compat.h
--- linux/include/asm-x86_64/compat.h	2003-07-18 02:39:47.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/compat.h	2003-08-23 14:09:41.000000000 +0200
@@ -6,6 +6,7 @@
  */
 #include <linux/types.h>
 #include <linux/sched.h>
+#include <linux/thread_info.h>
 
 #define COMPAT_USER_HZ	100
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/ia32.h linux-2.6.0test4-amd64/include/asm-x86_64/ia32.h
--- linux/include/asm-x86_64/ia32.h	2003-05-27 03:00:56.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/ia32.h	2003-08-20 22:53:38.000000000 +0200
@@ -160,7 +160,6 @@ struct ustat32 {
 	char			f_fpack[6];
 };
 
-#define IA32_PAGE_OFFSET 0xffffe000
 #define IA32_STACK_TOP IA32_PAGE_OFFSET
 
 #ifdef __KERNEL__
diff -burpN -X ../KDIFX linux/include/asm-x86_64/mpspec.h linux-2.6.0test4-amd64/include/asm-x86_64/mpspec.h
--- linux/include/asm-x86_64/mpspec.h	2003-08-23 13:03:22.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/mpspec.h	2003-08-23 14:13:33.000000000 +0200
@@ -169,7 +169,6 @@ extern int mp_bus_id_to_pci_bus [MAX_MP_
 extern cpumask_t mp_bus_to_cpumask [MAX_MP_BUSSES];
 
 extern unsigned int boot_cpu_physical_apicid;
-extern cpumask_t phys_cpu_present_map;
 extern int smp_found_config;
 extern void find_smp_config (void);
 extern void get_smp_config (void);
@@ -198,5 +197,49 @@ extern void mp_config_ioapic_for_sci(int
 
 extern int using_apic_timer;
 
+#define PHYSID_ARRAY_SIZE	BITS_TO_LONGS(MAX_APICS)
+
+struct physid_mask
+{
+	unsigned long mask[PHYSID_ARRAY_SIZE];
+};
+
+typedef struct physid_mask physid_mask_t;
+
+#define physid_set(physid, map)			set_bit(physid, (map).mask)
+#define physid_clear(physid, map)		clear_bit(physid, (map).mask)
+#define physid_isset(physid, map)		test_bit(physid, (map).mask)
+#define physid_test_and_set(physid, map)	test_and_set_bit(physid, (map).mask)
+
+#define physids_and(dst, src1, src2)		bitmap_and((dst).mask, (src1).mask, (src2).mask, MAX_APICS)
+#define physids_or(dst, src1, src2)		bitmap_or((dst).mask, (src1).mask, (src2).mask, MAX_APICS)
+#define physids_clear(map)			bitmap_clear((map).mask, MAX_APICS)
+#define physids_complement(map)			bitmap_complement((map).mask, MAX_APICS)
+#define physids_empty(map)			bitmap_empty((map).mask, MAX_APICS)
+#define physids_equal(map1, map2)		bitmap_equal((map1).mask, (map2).mask, MAX_APICS)
+#define physids_weight(map)			bitmap_weight((map).mask, MAX_APICS)
+#define physids_shift_right(d, s, n)		bitmap_shift_right((d).mask, (s).mask, n, MAX_APICS)
+#define physids_shift_left(d, s, n)		bitmap_shift_left((d).mask, (s).mask, n, MAX_APICS)
+#define physids_coerce(map)			((map).mask[0])
+
+#define physids_promote(physids)						\
+	({									\
+		physid_mask_t __physid_mask = PHYSID_MASK_NONE;			\
+		__physid_mask.mask[0] = physids;				\
+		__physid_mask;							\
+	})
+
+#define physid_mask_of_physid(physid)						\
+	({									\
+		physid_mask_t __physid_mask = PHYSID_MASK_NONE;			\
+		physid_set(physid, __physid_mask);				\
+		__physid_mask;							\
+	})
+
+#define PHYSID_MASK_ALL		{ {[0 ... PHYSID_ARRAY_SIZE-1] = ~0UL} }
+#define PHYSID_MASK_NONE	{ {[0 ... PHYSID_ARRAY_SIZE-1] = 0UL} }
+
+extern physid_mask_t phys_cpu_present_map;
+
 #endif
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/percpu.h linux-2.6.0test4-amd64/include/asm-x86_64/percpu.h
--- linux/include/asm-x86_64/percpu.h	2003-08-23 13:03:22.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/percpu.h	2003-08-23 14:29:54.000000000 +0200
@@ -31,6 +31,9 @@ do {								\
 			memcpy((pcpudst)+__per_cpu_offset(__i),	\
 			       (src), (size));			\
 } while (0)
+
+extern void setup_per_cpu_areas(void);
+
 #else /* ! SMP */
 
 #define DEFINE_PER_CPU(type, name) \
@@ -46,6 +49,4 @@ do {								\
 #define EXPORT_PER_CPU_SYMBOL(var) EXPORT_SYMBOL(per_cpu__##var)
 #define EXPORT_PER_CPU_SYMBOL_GPL(var) EXPORT_SYMBOL_GPL(per_cpu__##var)
 
-extern void setup_per_cpu_areas(void);
-
 #endif /* _ASM_X8664_PERCPU_H_ */
diff -burpN -X ../KDIFX linux/include/asm-x86_64/processor.h linux-2.6.0test4-amd64/include/asm-x86_64/processor.h
--- linux/include/asm-x86_64/processor.h	2003-08-23 13:03:22.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/processor.h	2003-08-23 13:12:33.000000000 +0200
@@ -18,6 +18,7 @@
 #include <asm/current.h>
 #include <asm/system.h>
 #include <asm/mmsegment.h>
+#include <linux/personality.h>
 
 #define TF_MASK		0x00000100
 #define IF_MASK		0x00000200
@@ -172,7 +173,8 @@ static inline void clear_in_cr4 (unsigne
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_32 0xa0000000
+#define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
+#define TASK_UNMAPPED_32 (IA32_PAGE_OFFSET / 3)
 #define TASK_UNMAPPED_64 PAGE_ALIGN(TASK_SIZE/3) 
 #define TASK_UNMAPPED_BASE	\
 	(test_thread_flag(TIF_IA32) ? TASK_UNMAPPED_32 : TASK_UNMAPPED_64)  
@@ -225,7 +227,6 @@ struct tss_struct {
 	 * 8 bytes, for an extra "long" of ~0UL
 	 */
 	unsigned long io_bitmap[IO_BITMAP_LONGS + 1];
-	u32 __cacheline_filler[4];      /* size is 0x100 */
 } __attribute__((packed)) ____cacheline_aligned;
 
 struct thread_struct {
diff -burpN -X ../KDIFX linux/include/asm-x86_64/smp.h linux-2.6.0test4-amd64/include/asm-x86_64/smp.h
--- linux/include/asm-x86_64/smp.h	2003-08-23 13:03:22.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/smp.h	2003-08-23 14:14:50.000000000 +0200
@@ -36,7 +36,6 @@ struct pt_regs;
  */
  
 extern void smp_alloc_memory(void);
-extern cpumask_t phys_cpu_present_map;
 extern cpumask_t cpu_online_map;
 extern volatile unsigned long smp_invalidate_needed;
 extern int pic_mode;
diff -burpN -X ../KDIFX linux/include/asm-x86_64/suspend.h linux-2.6.0test4-amd64/include/asm-x86_64/suspend.h
--- linux/include/asm-x86_64/suspend.h	2003-07-18 02:39:28.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/suspend.h	2003-08-23 14:22:09.000000000 +0200
@@ -44,7 +44,7 @@ extern unsigned long saved_context_eflag
                        :"r" ((thread)->debugreg##register))
 
 extern void fix_processor_context(void);
-extern void do_magic(int resume);
+extern int do_magic(int resume);
 
 #ifdef CONFIG_ACPI_SLEEP
 extern unsigned long saved_eip;
diff -burpN -X ../KDIFX linux/include/asm-x86_64/topology.h linux-2.6.0test4-amd64/include/asm-x86_64/topology.h
--- linux/include/asm-x86_64/topology.h	2003-08-23 13:03:22.000000000 +0200
+++ linux-2.6.0test4-amd64/include/asm-x86_64/topology.h	2003-08-23 13:00:02.000000000 +0200
@@ -10,21 +10,18 @@
 /* Map the K8 CPU local memory controllers to a simple 1:1 CPU:NODE topology */
 
 extern int fake_node;
-extern cpumask_t cpu_online_map;
+extern unsigned long cpu_online_map;
 
 #define cpu_to_node(cpu)		(fake_node ? 0 : (cpu))
 #define memblk_to_node(memblk) 	(fake_node ? 0 : (memblk))
 #define parent_node(node)		(node)
 #define node_to_first_cpu(node) 	(fake_node ? 0 : (node))
-#define node_to_cpu_mask(node)	(fake_node ? cpu_online_map : cpumask_of_cpu(node))
+#define node_to_cpu_mask(node)	(fake_node ? cpu_online_map : (1UL << (node)))
 #define node_to_memblk(node)		(node)
 
-static inline cpumask_t pcibus_to_cpumask(int bus)
+static inline unsigned long pcibus_to_cpumask(int bus)
 {
-	cpumask_t ret;
-
-	cpus_and(ret, mp_bus_to_cpumask[bus], cpu_online_map);
-	return ret;
+	return mp_bus_to_cpumask[bus] & cpu_online_map; 
 }
 
 #define NODE_BALANCE_RATE 30	/* CHECKME */ 
diff -burpN -X ../KDIFX linux/include/linux/personality.h linux-2.6.0test4-amd64/include/linux/personality.h
--- linux/include/linux/personality.h	2003-05-27 03:00:40.000000000 +0200
+++ linux-2.6.0test4-amd64/include/linux/personality.h	2003-08-20 22:55:54.000000000 +0200
@@ -34,6 +34,7 @@ enum {
 	SHORT_INODE =		0x1000000,
 	WHOLE_SECONDS =		0x2000000,
 	STICKY_TIMEOUTS	=	0x4000000,
+	ADDR_LIMIT_3GB = 	0x8000000,
 };
 
 /*
@@ -56,6 +57,7 @@ enum {
 	PER_SUNOS =		0x0006 | STICKY_TIMEOUTS,
 	PER_XENIX =		0x0007 | STICKY_TIMEOUTS | SHORT_INODE,
 	PER_LINUX32 =		0x0008,
+	PER_LINUX32_3GB =	0x0008 | ADDR_LIMIT_3GB,
 	PER_IRIX32 =		0x0009 | STICKY_TIMEOUTS,/* IRIX5 32-bit */
 	PER_IRIXN32 =		0x000a | STICKY_TIMEOUTS,/* IRIX6 new 32-bit */
 	PER_IRIX64 =		0x000b | STICKY_TIMEOUTS,/* IRIX6 64-bit */
