From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: IBM Codestream linux-2.6.16 october2005, patch 02-02
Patch-Mainline: 2.6.17-rc4

  Description: z90crypt: analysis revealed unreachable code
  Symptom:     error messages never generated under certain conditions
  Problem:     extraneous check of variable for non-zero value
  Solution:    remove extraneous check
  Problem-ID:  22772
  Archs:       s390-31, s390-64

Acked-by: Hannes Reinecke <hare@suse.de>

--- linux-2.5/drivers/s390/crypto/z90main.c	21 Mar 2006 19:39:52 -0000	1.87.2.1
+++ linux-2.5/drivers/s390/crypto/z90main.c	30 Mar 2006 22:01:11 -0000	1.87.2.2
@@ -3157,39 +3157,37 @@
 		length = sizeof(static_testmsg) - 24;
 		/* the -24 allows for the header */
 		dv = send_to_AP(index, z90crypt.cdx, length, loc_testmsg);
-		if (dv) {
-			PDEBUG("dv returned by send during probe: %d\n", dv);
-			if (dv == DEV_SEN_EXCEPTION) {
-				rv = SEN_FATAL_ERROR;
-				PRINTKC("exception in send to AP %d\n", index);
-				break;
-			}
-			PDEBUG("return value from send_to_AP: %d\n", rv);
-			switch (dv) {
-			case DEV_GONE:
-				PDEBUG("dev %d not available\n", index);
-				rv = SEN_NOT_AVAIL;
-				break;
-			case DEV_ONLINE:
-				rv = 0;
-				break;
-			case DEV_EMPTY:
-				rv = SEN_NOT_AVAIL;
-				break;
-			case DEV_NO_WORK:
-				rv = SEN_FATAL_ERROR;
-				break;
-			case DEV_BAD_MESSAGE:
-				rv = SEN_USER_ERROR;
-				break;
-			case DEV_QUEUE_FULL:
-				rv = SEN_QUEUE_FULL;
-				break;
-			default:
-				PRINTK("unknown dv=%d for dev %d\n", dv, index);
-				rv = SEN_NOT_AVAIL;
-				break;
-			}
+		PDEBUG("dv returned by send during probe: %d\n", dv);
+		if (dv == DEV_SEN_EXCEPTION) {
+			rv = SEN_FATAL_ERROR;
+			PRINTKC("exception in send to AP %d\n", index);
+			break;
+		}
+		PDEBUG("return value from send_to_AP: %d\n", rv);
+		switch (dv) {
+		case DEV_GONE:
+			PDEBUG("dev %d not available\n", index);
+			rv = SEN_NOT_AVAIL;
+			break;
+		case DEV_ONLINE:
+			rv = 0;
+			break;
+		case DEV_EMPTY:
+			rv = SEN_NOT_AVAIL;
+			break;
+		case DEV_NO_WORK:
+			rv = SEN_FATAL_ERROR;
+			break;
+		case DEV_BAD_MESSAGE:
+			rv = SEN_USER_ERROR;
+			break;
+		case DEV_QUEUE_FULL:
+			rv = SEN_QUEUE_FULL;
+			break;
+		default:
+			PRINTK("unknown dv=%d for dev %d\n", dv, index);
+			rv = SEN_NOT_AVAIL;
+			break;
 		}
 
 		if (rv)
@@ -3294,39 +3292,37 @@
 		memcpy(loc_testmsg, MCL3_testmsg, sizeof(MCL3_testmsg));
 		length = sizeof(MCL3_testmsg) - 0x0C;
 		dv = send_to_AP(index, z90crypt.cdx, length, loc_testmsg);
-		if (dv) {
-			PDEBUG("dv returned = %d\n", dv);
-			if (dv == DEV_SEN_EXCEPTION) {
-				rv = SEN_FATAL_ERROR;
-				PRINTKC("exception in send to AP %d\n", index);
-				break;
-			}
-			PDEBUG("return value from send_to_AP: %d\n", rv);
-			switch (dv) {
-			case DEV_GONE:
-				PDEBUG("dev %d not available\n", index);
-				rv = SEN_NOT_AVAIL;
-				break;
-			case DEV_ONLINE:
-				rv = 0;
-				break;
-			case DEV_EMPTY:
-				rv = SEN_NOT_AVAIL;
-				break;
-			case DEV_NO_WORK:
-				rv = SEN_FATAL_ERROR;
-				break;
-			case DEV_BAD_MESSAGE:
-				rv = SEN_USER_ERROR;
-				break;
-			case DEV_QUEUE_FULL:
-				rv = SEN_QUEUE_FULL;
-				break;
-			default:
-				PRINTK("unknown dv=%d for dev %d\n", dv, index);
-				rv = SEN_NOT_AVAIL;
-				break;
-			}
+		PDEBUG("dv returned = %d\n", dv);
+		if (dv == DEV_SEN_EXCEPTION) {
+			rv = SEN_FATAL_ERROR;
+			PRINTKC("exception in send to AP %d\n", index);
+			break;
+		}
+		PDEBUG("return value from send_to_AP: %d\n", rv);
+		switch (dv) {
+		case DEV_GONE:
+			PDEBUG("dev %d not available\n", index);
+			rv = SEN_NOT_AVAIL;
+			break;
+		case DEV_ONLINE:
+			rv = 0;
+			break;
+		case DEV_EMPTY:
+			rv = SEN_NOT_AVAIL;
+			break;
+		case DEV_NO_WORK:
+			rv = SEN_FATAL_ERROR;
+			break;
+		case DEV_BAD_MESSAGE:
+			rv = SEN_USER_ERROR;
+			break;
+		case DEV_QUEUE_FULL:
+			rv = SEN_QUEUE_FULL;
+			break;
+		default:
+			PRINTK("unknown dv=%d for dev %d\n", dv, index);
+			rv = SEN_NOT_AVAIL;
+			break;
 		}
 
 		if (rv)

