Subject: PS3: Make ps3fb loadable

FIXME Missing calls to ps3av_register_flip_ctl() in ps3fb

Signed-off-by: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
Signed-off-by: Geoff Levand <geoffrey.levand@am.sony.com>

---
 arch/powerpc/platforms/ps3/setup.c |    8 -
 drivers/ps3/ps3av.c                |   17 ++
 drivers/ps3/ps3av_cmd.c            |    4 
 drivers/video/Kconfig              |    2 
 drivers/video/ps3fb.c              |  267 ++++++++++++++++++-------------------
 include/asm-powerpc/ps3av.h        |    2 
 include/asm-powerpc/ps3fb.h        |    8 -
 7 files changed, 157 insertions(+), 151 deletions(-)

--- a/arch/powerpc/platforms/ps3/setup.c
+++ b/arch/powerpc/platforms/ps3/setup.c
@@ -119,11 +119,13 @@ static void prealloc(struct ps3_prealloc
 }
 #endif
 
+#if defined(CONFIG_FB_PS3) || defined(CONFIG_FB_PS3_MODULE)
 struct ps3_prealloc ps3fb_videomemory = {
-    .name = "ps3fb videomemory",
-    .size = CONFIG_FB_PS3_DEFAULT_SIZE_M*1024*1024,
-    .align = 1024*1024			/* the GPU requires 1 MiB alignment */
+	.name = "ps3fb videomemory",
+	.size = CONFIG_FB_PS3_DEFAULT_SIZE_M*1024*1024,
+	.align = 1024*1024		/* the GPU requires 1 MiB alignment */
 };
+EXPORT_SYMBOL_GPL(ps3fb_videomemory);
 #define prealloc_ps3fb_videomemory()	prealloc(&ps3fb_videomemory)
 
 static int __init early_parse_ps3fb(char *p)
--- a/drivers/ps3/ps3av.c
+++ b/drivers/ps3/ps3av.c
@@ -53,6 +53,7 @@ static struct ps3av {
 	u32 audio_port;
 	int ps3av_mode;
 	int ps3av_mode_old;
+	void (*flip_ctl)(int on);
 } ps3av;
 
 static struct ps3_vuart_port_device ps3av_dev = {
@@ -840,6 +841,22 @@ int ps3av_audio_mute(int mute)
 
 EXPORT_SYMBOL_GPL(ps3av_audio_mute);
 
+void ps3av_register_flip_ctl(void (*flip_ctl)(int on))
+{
+	mutex_lock(&ps3av.mutex);
+	ps3av.flip_ctl = flip_ctl;
+	mutex_unlock(&ps3av.mutex);
+}
+EXPORT_SYMBOL_GPL(ps3av_register_flip_ctl);
+
+void ps3av_flip_ctl(int on)
+{
+	mutex_lock(&ps3av.mutex);
+	if (ps3av.flip_ctl)
+		ps3av.flip_ctl(on);
+	mutex_unlock(&ps3av.mutex);
+}
+
 static int ps3av_probe(struct ps3_vuart_port_device *dev)
 {
 	int res;
--- a/drivers/ps3/ps3av_cmd.c
+++ b/drivers/ps3/ps3av_cmd.c
@@ -854,7 +854,7 @@ int ps3av_cmd_avb_param(struct ps3av_pkt
 {
 	int res;
 
-	ps3fb_flip_ctl(0);	/* flip off */
+	ps3av_flip_ctl(0);	/* flip off */
 
 	/* avb packet */
 	res = ps3av_do_pkt(PS3AV_CID_AVB_PARAM, send_len, sizeof(*avb),
@@ -868,7 +868,7 @@ int ps3av_cmd_avb_param(struct ps3av_pkt
 			 res);
 
       out:
-	ps3fb_flip_ctl(1);	/* flip on */
+	ps3av_flip_ctl(1);	/* flip on */
 	return res;
 }
 
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1615,7 +1615,7 @@ config FB_IBM_GXT4500
 	  adaptor, found on some IBM System P (pSeries) machines.
 
 config FB_PS3
-	bool "PS3 GPU framebuffer driver"
+	tristate "PS3 GPU framebuffer driver"
 	depends on (FB = y) && PS3_PS3AV
 	select FB_SYS_FILLRECT
 	select FB_SYS_COPYAREA
--- a/drivers/video/ps3fb.c
+++ b/drivers/video/ps3fb.c
@@ -303,7 +303,7 @@ static int ps3fb_mode;
 module_param(ps3fb_mode, bool, 0);
 
 static char *mode_option __initdata;
-
+int mode_hack; // FIXME: do something with this...
 
 static int ps3fb_get_res_table(u32 xres, u32 yres)
 {
@@ -853,35 +853,6 @@ static irqreturn_t ps3fb_vsync_interrupt
 	return IRQ_HANDLED;
 }
 
-#ifndef MODULE
-static int __init ps3fb_setup(char *options)
-{
-	char *this_opt;
-	int mode = 0;
-
-	if (!options || !*options)
-		return 0;	/* no options */
-
-	while ((this_opt = strsep(&options, ",")) != NULL) {
-		if (!*this_opt)
-			continue;
-		if (!strncmp(this_opt, "mode:", 5))
-			mode = simple_strtoul(this_opt + 5, NULL, 0);
-		else
-			mode_option = this_opt;
-	}
-	return mode;
-}
-#endif	/* MODULE */
-
-    /*
-     *  Initialisation
-     */
-
-static void ps3fb_platform_release(struct device *device)
-{
-	/* This is called when the reference count goes to zero. */
-}
 
 static int ps3fb_vsync_settings(struct gpu_driver_info *dinfo, void *dev)
 {
@@ -974,6 +945,43 @@ static struct fb_fix_screeninfo ps3fb_fi
 	.accel =	FB_ACCEL_NONE,
 };
 
+static void ps3fb_platform_release(struct device *device)
+{
+	printk("%s:%u\n need this???", __func__, __LINE__);
+}
+
+static int ps3fb_set_sync(void)
+{
+	int status;
+
+#ifdef HEAD_A
+	status = lv1_gpu_context_attribute(0x0,
+					   L1GPU_CONTEXT_ATTRIBUTE_DISPLAY_SYNC,
+					   0, L1GPU_DISPLAY_SYNC_VSYNC, 0, 0);
+	if (status) {
+		printk(KERN_ERR
+		       "%s: lv1_gpu_context_attribute DISPLAY_SYNC failed: %d\n",
+		       __func__, status);
+		return -1;
+	}
+#endif
+#ifdef HEAD_B
+	status = lv1_gpu_context_attribute(0x0,
+					   L1GPU_CONTEXT_ATTRIBUTE_DISPLAY_SYNC,
+					   1, L1GPU_DISPLAY_SYNC_VSYNC, 0, 0);
+
+	if (status) {
+		printk(KERN_ERR
+		       "%s: lv1_gpu_context_attribute DISPLAY_MODE failed: %d\n",
+		       __func__, status);
+		return -1;
+	}
+#endif
+	return 0;
+}
+
+//EXPORT_SYMBOL_GPL(ps3fb_set_sync);
+
 static int __init ps3fb_probe(struct platform_device *dev)
 {
 	struct fb_info *info;
@@ -990,6 +998,38 @@ static int __init ps3fb_probe(struct pla
 
 	printk(" -> %s:%u\n", __func__, __LINE__);
 
+	dev->dev.release = ps3fb_platform_release; // need this???
+
+	ps3_system_bus_device_init(&fake_dev, PS3_MATCH_ID_GFX, NULL, NULL);
+
+	status = ps3_open_hv_device(&fake_dev);
+
+	if (status) {
+		printk(KERN_ERR "%s: ps3_open_hv_device failed\n", __func__);
+		goto err;
+	}
+
+	ps3fb_mode = ps3av_get_mode();
+	DPRINTK("ps3av_mode:%d\n", ps3fb_mode);
+
+	if (mode_hack)
+		ps3fb_mode = mode_hack;
+
+	if (ps3fb_mode > 0) {
+		u32 xres, yres;
+		ps3av_video_mode2res(ps3fb_mode, &xres, &yres);
+		ps3fb.res_index = ps3fb_get_res_table(xres, yres);
+		DPRINTK("res_index:%d\n", ps3fb.res_index);
+	} else
+		ps3fb.res_index = GPU_RES_INDEX;
+
+	atomic_set(&ps3fb.f_count, -1);	/* fbcon opens ps3fb */
+	atomic_set(&ps3fb.ext_flip, 0);	/* for flip with vsync */
+	init_waitqueue_head(&ps3fb.wait_vsync);
+	ps3fb.num_frames = 1;
+
+	ps3fb_set_sync();
+
 	/* get gpu context handle */
 	status = lv1_gpu_memory_allocate(DDR_SIZE, 0, 0, 0, 0,
 					 &ps3fb.memory_handle, &ddr_lpar);
@@ -1101,11 +1141,34 @@ err:
 	return retval;
 }
 
-void ps3fb_cleanup(void)
+static int ps3fb_remove(struct platform_device *dev)
+{
+	BUG();
+	return 0;
+}
+
+extern void fbcon_exit(void);
+extern void vt_console_stop(void);
+
+static void ps3fb_shutdown(struct platform_device *dev)
 {
 	int status;
+	struct fb_info *info = platform_get_drvdata(dev);
 
 	printk(" -> %s:%d\n", __func__, __LINE__);
+
+	vt_console_stop();
+	fbcon_exit();
+
+	ps3fb_flip_ctl(0); /* flip off */
+	ps3fb.dinfo->irq.mask = 0;
+
+	if (info) {
+		unregister_framebuffer(info);
+		fb_dealloc_cmap(&info->cmap);
+		framebuffer_release(info);
+	}
+
 	if (ps3fb.task) {
 		struct task_struct *task = ps3fb.task;
 		ps3fb.task = NULL;
@@ -1126,37 +1189,6 @@ void ps3fb_cleanup(void)
 		DPRINTK("lv1_gpu_memory_free failed: %d\n", status);
 
 	ps3_close_hv_device(&fake_dev);
-}
-
-static int ps3fb_remove(struct platform_device *dev)
-{
-	struct fb_info *info = platform_get_drvdata(dev);
-
-	printk(" -> %s:%d\n", __func__, __LINE__);
-
-	if (info) {
-		unregister_framebuffer(info);
-		fb_dealloc_cmap(&info->cmap);
-		framebuffer_release(info);
-	}
-	ps3fb_cleanup();
-	printk(" <- %s:%d\n", __func__, __LINE__);
-	return 0;
-}
-
-extern void fbcon_exit(void);
-extern void vt_console_stop(void);
-
-static void ps3fb_shutdown(struct platform_device *dev)
-{
-	printk(" -> %s:%d\n", __func__, __LINE__);
-
-	vt_console_stop();
-	fbcon_exit();
-
-	ps3fb_flip_ctl(0); /* flip off */
-	ps3fb.dinfo->irq.mask = 0;
-	ps3fb_remove(dev);
 	printk(" <- %s:%d\n", __func__, __LINE__);
 }
 
@@ -1167,100 +1199,55 @@ static struct platform_driver ps3fb_driv
 	.driver = { .name = "ps3fb" }
 };
 
-static struct platform_device ps3fb_device = {
-	.name	= "ps3fb",
-	.id	= 0,
-	.dev	= { .release = ps3fb_platform_release }
-};
-
-int ps3fb_set_sync(void)
+#ifndef MODULE
+static int __init ps3fb_setup(void)
 {
-	int status;
+	char *this_opt;
+	int mode = 0;
+	char *options;
 
-#ifdef HEAD_A
-	status = lv1_gpu_context_attribute(0x0,
-					   L1GPU_CONTEXT_ATTRIBUTE_DISPLAY_SYNC,
-					   0, L1GPU_DISPLAY_SYNC_VSYNC, 0, 0);
-	if (status) {
-		printk(KERN_ERR
-		       "%s: lv1_gpu_context_attribute DISPLAY_SYNC failed: %d\n",
-		       __func__, status);
-		return -1;
-	}
-#endif
-#ifdef HEAD_B
-	status = lv1_gpu_context_attribute(0x0,
-					   L1GPU_CONTEXT_ATTRIBUTE_DISPLAY_SYNC,
-					   1, L1GPU_DISPLAY_SYNC_VSYNC, 0, 0);
+	if (fb_get_options("ps3fb", &options))
+		return -ENXIO;
 
-	if (status) {
-		printk(KERN_ERR
-		       "%s: lv1_gpu_context_attribute DISPLAY_MODE failed: %d\n",
-		       __func__, status);
-		return -1;
+	if (!options || !*options)
+		return 0;	/* no options */
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+		if (!strncmp(this_opt, "mode:", 5))
+			mode_hack = simple_strtoul(this_opt + 5, NULL, 0);
+		else
+			mode_option = this_opt;
 	}
-#endif
 	return 0;
 }
-
-EXPORT_SYMBOL_GPL(ps3fb_set_sync);
+#endif	/* MODULE */
 
 static int __init ps3fb_init(void)
 {
 	int error;
 
-#ifndef MODULE
-	int mode;
-	char *option = NULL;
-
-	if (fb_get_options("ps3fb", &option))
-		goto err;
-#endif
-
-	if (!ps3fb_videomemory.address)
-		goto err;
-
-	//FIXME: shouldn't this be in ps3fb_probe? No, in device-init.c
-	ps3_system_bus_device_init(&fake_dev, PS3_MATCH_ID_GFX, NULL, NULL);
-	error = ps3_open_hv_device(&fake_dev);
-	if (error) {
-		printk(KERN_ERR "%s: ps3_open_hv_device failed\n", __func__);
-		goto err;
-	}
+	printk(" -> %s:%d\n", __func__, __LINE__);
 
-	ps3fb_mode = ps3av_get_mode();
-	DPRINTK("ps3av_mode:%d\n", ps3fb_mode);
 #ifndef MODULE
-	mode = ps3fb_setup(option);	/* check boot option */
-	if (mode)
-		ps3fb_mode = mode;
+	error = ps3fb_setup();
+	if (error)
+		return error;
 #endif
-	if (ps3fb_mode > 0) {
-		u32 xres, yres;
-		ps3av_video_mode2res(ps3fb_mode, &xres, &yres);
-		ps3fb.res_index = ps3fb_get_res_table(xres, yres);
-		DPRINTK("res_index:%d\n", ps3fb.res_index);
-	} else
-		ps3fb.res_index = GPU_RES_INDEX;
 
-	atomic_set(&ps3fb.f_count, -1);	/* fbcon opens ps3fb */
-	atomic_set(&ps3fb.ext_flip, 0);	/* for flip with vsync */
-	init_waitqueue_head(&ps3fb.wait_vsync);
-	ps3fb.num_frames = 1;
+	if (!ps3fb_videomemory.address)
+		return -ENXIO;
 
 	error = platform_driver_register(&ps3fb_driver);
-	if (!error) {
-		error = platform_device_register(&ps3fb_device);
-		if (error)
-			platform_driver_unregister(&ps3fb_driver);
+	if (error) {
+		printk(KERN_ERR "%s: platform_driver_register failed: %d\n",
+		       __func__, error);
 	}
 
-	ps3fb_set_sync();
+	printk(" <- %s:%d\n", __func__, __LINE__);
 
 	return error;
-
-err:
-	return -ENXIO;
 }
 
 module_init(ps3fb_init);
@@ -1268,11 +1255,17 @@ module_init(ps3fb_init);
 #ifdef MODULE
 static void __exit ps3fb_exit(void)
 {
-	platform_device_unregister(&ps3fb_device);
+	printk(" -> %s:%d\n", __func__, __LINE__);
 	platform_driver_unregister(&ps3fb_driver);
+	printk(" <- %s:%d\n", __func__, __LINE__);
 }
 
+/*
+FIXME: need to fix fbcon to support remove
 module_exit(ps3fb_exit);
+*/
+#endif /* MODULE */
 
 MODULE_LICENSE("GPL");
-#endif				/* MODULE */
+MODULE_DESCRIPTION("PS3 GPU Frame Buffer Driver");
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
--- a/include/asm-powerpc/ps3av.h
+++ b/include/asm-powerpc/ps3av.h
@@ -719,5 +719,7 @@ extern int ps3av_video_mute(int);
 extern int ps3av_audio_mute(int);
 extern int ps3av_dev_open(void);
 extern int ps3av_dev_close(void);
+extern void ps3av_register_flip_ctl(void (*func)(int on));
+extern void ps3av_flip_ctl(int on);
 
 #endif	/* _ASM_POWERPC_PS3AV_H_ */
--- a/include/asm-powerpc/ps3fb.h
+++ b/include/asm-powerpc/ps3fb.h
@@ -43,14 +43,6 @@ struct ps3fb_ioctl_res {
 
 #ifdef __KERNEL__
 
-#ifdef CONFIG_FB_PS3
-extern void ps3fb_flip_ctl(int on);
-extern void ps3fb_cleanup(void);
-#else
-static inline void ps3fb_flip_ctl(int on) {}
-static inline void ps3fb_cleanup(void) {}
-#endif
-
 #endif /* __KERNEL__ */
 
 #endif /* _ASM_POWERPC_PS3FB_H_ */
