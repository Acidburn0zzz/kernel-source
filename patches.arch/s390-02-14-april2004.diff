- Description: qeth: purge ARP cache IPA command gets timeout
  Symptom:     When doing a qetharp -p after adding a big number of static
               ARP entries to an OSA card, the purge ARP cache command
               times out. qetharp says "Timer expired". Furthermore,
               unclear error messages are displayed for ARP commands.
  Problem:     When very much ARP entries are added the purge command can
               take a long time to complete. For this case the timeout
               used in send_control_data was too small.
               Improved ARP error messages.
  Solution:    Use bigger timeout for IPA commands.
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 07:27:37 -0000	1.77.2.7
+++ linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 08:16:06 -0000	1.77.2.8
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.7 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.8 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.7 $	 $Date: 2004/05/14 07:27:37 $
+ *    $Revision: 1.77.2.8 $	 $Date: 2004/05/14 08:16:06 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.7 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.8 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -699,7 +699,7 @@
 qeth_set_ip_addr_list(struct qeth_card *card) 
 {
 	struct list_head failed_todos;
-	struct qeth_ipaddr *todo, *addr, *tmp;
+	struct qeth_ipaddr *todo, *addr;
 	unsigned long flags;
 	int rc;
 
@@ -708,9 +708,10 @@
 
 	INIT_LIST_HEAD(&failed_todos);
 
-process_todos:
 	spin_lock_irqsave(&card->ip_lock, flags);
-	list_for_each_entry_safe(todo, tmp, &card->ip_tbd_list, entry) {
+	while (!list_empty(&card->ip_tbd_list)) {
+		todo = list_entry(card->ip_tbd_list.next,
+				  struct qeth_ipaddr, entry);
 		list_del_init(&todo->entry);
 		rc = __qeth_ref_ip_on_card(card, todo, &addr);
 		if (rc == 0) {
@@ -720,28 +721,24 @@
 			/* new entry to be added to on-card list */
 			spin_unlock_irqrestore(&card->ip_lock, flags);
 			rc = qeth_register_addr_entry(card, todo);
-			if (!rc){
 				spin_lock_irqsave(&card->ip_lock, flags);
+			if (!rc)
 				list_add_tail(&todo->entry, &card->ip_list);
-				spin_unlock_irqrestore(&card->ip_lock, flags);
-			} else
+			else
 				list_add_tail(&todo->entry, &failed_todos);
-			goto process_todos;
 		} else if (rc == -1) {
 			/* on-card entry to be removed */
 			list_del_init(&addr->entry);
 			spin_unlock_irqrestore(&card->ip_lock, flags);
 			rc = qeth_deregister_addr_entry(card, addr);
+			spin_lock_irqsave(&card->ip_lock, flags);
 			if (!rc) {
 				kfree(addr);
 				kfree(todo);
 			} else {
-				spin_lock_irqsave(&card->ip_lock, flags);
 				list_add_tail(&addr->entry, &card->ip_list);
 				list_add_tail(&todo->entry, &failed_todos);
-				spin_unlock_irqrestore(&card->ip_lock, flags);
 			}
-			goto process_todos;
 		}
 	}
 	spin_unlock_irqrestore(&card->ip_lock, flags);
@@ -1455,7 +1452,7 @@
 {
 	struct qeth_reply *reply;
 
-	reply = kmalloc(sizeof(struct qeth_reply), GFP_KERNEL|GFP_ATOMIC);
+	reply = kmalloc(sizeof(struct qeth_reply), GFP_ATOMIC);
 	if (reply){
 		memset(reply, 0, sizeof(struct qeth_reply));
 		atomic_set(&reply->refcnt, 1);
@@ -1702,6 +1699,9 @@
 	init_timer(&timer);
 	timer.function = qeth_cmd_timeout;
 	timer.data = (unsigned long) reply;
+	if (IS_IPA(iob->data))
+		timer.expires = jiffies + QETH_IPA_TIMEOUT;
+	else
 	timer.expires = jiffies + QETH_TIMEOUT;
 	init_waitqueue_head(&reply->wait_q);
 	spin_lock_irqsave(&card->lock, flags);
@@ -2228,12 +2228,11 @@
 	while((skb = qeth_get_next_skb(card, buf->buffer, &element,
 				       &offset, &hdr))){
 		qeth_rebuild_skb(card, skb, hdr);
-
-#ifdef CONFIG_QETH_PERF_STATS
-		card->perf_stats.inbound_time += qeth_get_micros() -
-			card->perf_stats.inbound_start_time;
-		card->perf_stats.inbound_cnt++;
-#endif
+		/* is device UP ? */
+		if (!(card->dev->flags & IFF_UP)){
+			dev_kfree_skb_irq(skb);
+			continue;
+		}
 		skb->dev = card->dev;
 		rxrc = netif_rx(skb);
 		card->dev->last_rx = jiffies;
@@ -2331,6 +2330,9 @@
 		 * 'index') un-requeued -> this buffer is the first buffer that
 		 * will be requeued the next time
 		 */
+#ifdef CONFIG_QETH_PERF_STATS
+		card->perf_stats.inbound_do_qdio++;
+#endif
 		rc = do_QDIO(CARD_DDEV(card),
 			     QDIO_FLAG_SYNC_INPUT,
 			     0, queue->next_buf_to_init, count, NULL);
@@ -2370,6 +2372,7 @@
 	card = (struct qeth_card *) card_ptr;
 	net_dev = card->dev;
 #ifdef CONFIG_QETH_PERF_STATS
+	card->perf_stats.inbound_cnt++;
 	card->perf_stats.inbound_start_time = qeth_get_micros();
 #endif
 	if (status & QDIO_STATUS_LOOK_FOR_ERROR) {
@@ -2392,6 +2395,10 @@
 		qeth_put_buffer_pool_entry(card, buffer->pool_entry);
 		qeth_queue_input_buffer(card, index);
 	}
+#ifdef CONFIG_QETH_PERF_STATS
+	card->perf_stats.inbound_time += qeth_get_micros() -
+		card->perf_stats.inbound_start_time;
+#endif
 }
 
 static inline int
@@ -2480,6 +2487,9 @@
 	}
 
 	queue->card->dev->trans_start = jiffies;
+#ifdef CONFIG_QETH_PERF_STATS
+		queue->card->perf_stats.outbound_do_qdio++;
+#endif
 	if (under_int)
 		rc = do_QDIO(CARD_DDEV(queue->card),
 			     QDIO_FLAG_SYNC_OUTPUT | QDIO_FLAG_UNDER_INTERRUPT,
@@ -2498,7 +2508,6 @@
 	}
 #ifdef CONFIG_QETH_PERF_STATS
 	queue->card->perf_stats.bufs_sent += count;
-	queue->card->perf_stats.outbound_cnt++;
 #endif
 }
 
@@ -2851,6 +2860,9 @@
 	for (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)
 		qeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);
 	card->qdio.in_q->next_buf_to_init = card->qdio.in_buf_pool.buf_count - 1;
+#ifdef CONFIG_QETH_PERF_STATS
+		card->perf_stats.inbound_do_qdio++;
+#endif
 	rc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0, 0,
 		     card->qdio.in_buf_pool.buf_count - 1, NULL);
 	if (rc) {
@@ -3201,6 +3213,7 @@
 		return -EBUSY;
 	}
 #ifdef CONFIG_QETH_PERF_STATS
+	card->perf_stats.outbound_cnt++;
 	card->perf_stats.outbound_start_time = qeth_get_micros();
 #endif
 	/*
@@ -3211,6 +3224,10 @@
 	if (!(rc = qeth_send_packet(card, skb)))
 		netif_wake_queue(dev);
 
+#ifdef CONFIG_QETH_PERF_STATS
+	card->perf_stats.outbound_time += qeth_get_micros() -
+		card->perf_stats.outbound_start_time;
+#endif
 	return rc;
 }
 
@@ -3711,10 +3728,6 @@
 	if (!rc){
 		card->stats.tx_packets++;
 		card->stats.tx_bytes += skb->len;
-#ifdef CONFIG_QETH_PERF_STATS
-		card->perf_stats.outbound_time += qeth_get_micros() -
-			card->perf_stats.outbound_start_time;
-#endif
 	}
 	return rc;
 }
@@ -3860,9 +3873,9 @@
 	if (rc) {
 		tmp = rc;
 		PRINT_WARN("Could not set number of ARP entries on %s: "
-			   "%s (0x%x)\n",
+			   "%s (0x%x/%d)\n",
 			   card->info.if_name, qeth_arp_get_error_cause(&rc),
-			   tmp);
+			   tmp, tmp);
 	}
 	return rc;
 }
@@ -4102,9 +4115,9 @@
 		tmp = rc;
 		qeth_ipaddr4_to_string((u8 *)entry->ipaddr, buf);
 		PRINT_WARN("Could not add ARP entry for address %s on %s: "
-			   "%s (0x%x)\n",
+			   "%s (0x%x/%d)\n",
 			   buf, card->info.if_name,
-			   qeth_arp_get_error_cause(&rc), tmp);
+			   qeth_arp_get_error_cause(&rc), tmp, tmp);
 	}
 	return rc;
 }
@@ -4145,9 +4158,9 @@
 		memset(buf, 0, 16);
 		qeth_ipaddr4_to_string((u8 *)entry->ipaddr, buf);
 		PRINT_WARN("Could not delete ARP entry for address %s on %s: "
-			   "%s (0x%x)\n",
+			   "%s (0x%x/%d)\n",
 			   buf, card->info.if_name,
-			   qeth_arp_get_error_cause(&rc), tmp);
+			   qeth_arp_get_error_cause(&rc), tmp, tmp);
 	}
 	return rc;
 }
@@ -4166,7 +4179,7 @@
 	 * funcs flags); since all zeros is no valueable information,
 	 * we say EOPNOTSUPP for all ARP functions
 	 */
-	if (card->info.guestlan)
+	if (card->info.guestlan || (card->info.type == QETH_CARD_TYPE_IQD))
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
 		PRINT_WARN("ARP processing not supported "
@@ -4177,9 +4190,9 @@
 					  IPA_CMD_ASS_ARP_FLUSH_CACHE, 0);
 	if (rc){
 		tmp = rc;
-		PRINT_WARN("Could not flush ARP cache on %s: %s (0x%x)\n",
+		PRINT_WARN("Could not flush ARP cache on %s: %s (0x%x/%d)\n",
 			   card->info.if_name, qeth_arp_get_error_cause(&rc),
-			   tmp);
+			   tmp, tmp);
 	}
 	return rc;
 }
@@ -5782,7 +5795,6 @@
 qeth_clear_ip_list(struct qeth_card *card, int clean, int recover)
 {
 	struct qeth_ipaddr *addr, *tmp;
-	int first_run = 1;
 	unsigned long flags;
 
 	QETH_DBF_TEXT(trace,4,"clearip");
@@ -5792,29 +5804,21 @@
 		list_del(&addr->entry);
 		kfree(addr);
 	}
-again:
-	if (first_run)
-		first_run = 0;
-	else
-		spin_lock_irqsave(&card->ip_lock, flags);
 	
-	list_for_each_entry_safe(addr, tmp, &card->ip_list, entry) {
+	while (!list_empty(&card->ip_list)) {
+		addr = list_entry(card->ip_list.next,
+				  struct qeth_ipaddr, entry);
 		list_del_init(&addr->entry);
-		if (clean){
+		if (clean) {
 			spin_unlock_irqrestore(&card->ip_lock, flags);
 			qeth_deregister_addr_entry(card, addr);
-		}
-		if (!recover || addr->is_multicast)
-			kfree(addr);
-		else {
-			if (clean)
 				spin_lock_irqsave(&card->ip_lock, flags);
-			list_add_tail(&addr->entry, &card->ip_tbd_list);
-			if (clean) {
-				spin_unlock_irqrestore(&card->ip_lock, flags);
-				goto again;
 			}
+		if (!recover || addr->is_multicast) {
+			kfree(addr);
+			continue;
 		}
+		list_add_tail(&addr->entry, &card->ip_tbd_list);
 	}
 	spin_unlock_irqrestore(&card->ip_lock, flags);
 }

--- linux-2.5/drivers/s390/net/qeth_mpc.h	14 May 2004 07:27:38 -0000	1.27.2.1
+++ linux-2.5/drivers/s390/net/qeth_mpc.h	14 May 2004 08:16:06 -0000	1.27.2.2
@@ -14,7 +14,7 @@
 
 #include <asm/qeth.h>
 
-#define VERSION_QETH_MPC_H "$Revision: 1.27.2.1 $"
+#define VERSION_QETH_MPC_H "$Revision: 1.27.2.2 $"
 
 extern const char *VERSION_QETH_MPC_C;
 
@@ -35,6 +35,7 @@
 #define OSA_ADDR_LEN		6
 
 #define QETH_TIMEOUT 		(10 * HZ)	
+#define QETH_IPA_TIMEOUT 	(45 * HZ)
 #define QETH_IDX_COMMAND_SEQNO 	-1
 #define SR_INFO_LEN		16
 

--- linux-2.5/drivers/s390/net/qeth_mpc.c	14 May 2004 07:27:38 -0000	1.8.2.1
+++ linux-2.5/drivers/s390/net/qeth_mpc.c	14 May 2004 08:16:06 -0000	1.8.2.2
@@ -11,5 +11,7 @@
 #include <asm/cio.h>
 #include "qeth_mpc.h"
 
+const char *VERSION_QETH_MPC_C = "$Revision: 1.8.2.2 $";
+
 unsigned char IDX_ACTIVATE_READ[]={
 	0x00,0x00,0x80,0x00, 0x00,0x00,0x00,0x00,
@@ -131,8 +131,7 @@
 	0x00,0x00,0x00,0x14, 0x00,0x00,
 		(IPA_PDU_HEADER_SIZE+sizeof(struct qeth_ipa_cmd))/256,
 		(IPA_PDU_HEADER_SIZE+sizeof(struct qeth_ipa_cmd))%256,
-	0x10,0x00,0x00,0x01,
-	0x00,0x00,0x00,0x00,
+	0x10,0x00,0x00,0x01, 0x00,0x00,0x00,0x00,
 	0xc1,0x03,0x00,0x01, 0x00,0x00,0x00,0x00,
 	0x00,0x00,0x00,0x00, 0x00,0x24,
 		sizeof(struct qeth_ipa_cmd)/256,

--- linux-2.5/drivers/s390/net/qeth_proc.c	14 May 2004 07:27:38 -0000	1.5.2.1
+++ linux-2.5/drivers/s390/net/qeth_proc.c	14 May 2004 08:16:06 -0000	1.5.2.2
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_fs.c ($Revision: 1.5 $)
+ * linux/drivers/s390/net/qeth_fs.c ($Revision: 1.5.2.2 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to procfs.
@@ -21,5 +21,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
+const char *VERSION_QETH_PROC_C = "$Revision: 1.5.2.2 $";
+
 /***** /proc/qeth *****/
 #define QETH_PROCFILE_NAME "qeth"
@@ -246,14 +246,18 @@
 				: 0
 		  );
 	seq_printf(s, "  Inbound time (in us)                   : %i\n"
-		      "  Inbound cnt                            : %i\n"
+		      "  Inbound count                          : %i\n"
+		      "  Inboud do_QDIO count                   : %i\n"
 		      "  Outbound time (in us, incl QDIO)       : %i\n"
-		      "  Outbound cnt                           : %i\n"
+		      "  Outbound count                         : %i\n"
+		      "  Outbound do_QDIO count                 : %i\n"
 		      "  Watermarks L/H                         : %i/%i\n\n",
 		        card->perf_stats.inbound_time,
 			card->perf_stats.inbound_cnt,
+			card->perf_stats.inbound_do_qdio,
 			card->perf_stats.outbound_time,
 			card->perf_stats.outbound_cnt,
+			card->perf_stats.outbound_do_qdio,
 			QETH_LOW_WATERMARK_PACK, QETH_HIGH_WATERMARK_PACK
 		  );
 

--- linux-2.5/drivers/s390/net/qeth.h	27 Apr 2004 15:30:15 -0000	1.98.2.3
+++ linux-2.5/drivers/s390/net/qeth.h	14 May 2004 08:16:06 -0000	1.98.2.4
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.98.2.3 $"
+#define VERSION_QETH_H 		"$Revision: 1.98.2.4 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -186,6 +186,8 @@
 	__u64 outbound_start_time;
 	unsigned int outbound_cnt;
 	unsigned int outbound_time;
+	unsigned int inbound_do_qdio;
+	unsigned int outbound_do_qdio;
 };
 #endif /* CONFIG_QETH_PERF_STATS */
 
@@ -279,7 +281,7 @@
 #define QETH_IN_BUF_COUNT_MAX 128
 #define QETH_MAX_BUFFER_ELEMENTS(card) ((card)->qdio.in_buf_size >> 12)
 #define QETH_IN_BUF_REQUEUE_THRESHOLD(card) \
-		((card)->qdio.in_buf_pool.buf_count / 4)
+		((card)->qdio.in_buf_pool.buf_count / 2)
 
 /* buffers we have to be behind before we get a PCI */
 #define QETH_PCI_THRESHOLD_A(card) ((card)->qdio.in_buf_pool.buf_count+1)

