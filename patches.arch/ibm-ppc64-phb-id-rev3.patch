--- a/arch/ppc64/kernel/pSeries_pci.c	2004-06-08 17:52:23.000000000 -0500
+++ b/arch/ppc64/kernel/pSeries_pci.c	2004-06-15 17:53:08.000000000 -0500
@@ -353,14 +353,51 @@ static void python_countermeasures(unsig
 	iounmap(chip_regs);
 }
 
-struct pci_controller *alloc_phb(struct device_node *dev,
+void __init init_pci_config_tokens (void)
+{
+	read_pci_config = rtas_token("read-pci-config");
+	write_pci_config = rtas_token("write-pci-config");
+	ibm_read_pci_config = rtas_token("ibm,read-pci-config");
+	ibm_write_pci_config = rtas_token("ibm,write-pci-config");
+}
+
+unsigned long __init get_phb_buid (struct device_node *phb)
+{
+	int addr_cells;
+	unsigned int *buid_vals;
+	unsigned int len;
+	unsigned long buid;
+
+	if (ibm_read_pci_config == -1) return 0;
+
+	/* PHB's will always be children of the root node,
+	 * or so it is promised by the current firmware. */
+	if (phb->parent == NULL) 
+		return 0;
+	if (phb->parent->parent) 
+		return 0;
+
+	buid_vals = (unsigned int *) get_property(phb, "reg", &len);
+	if (buid_vals == NULL) 
+		return 0;
+
+	addr_cells = prom_n_addr_cells(phb);
+	if (addr_cells == 1) {
+		buid = (unsigned long) buid_vals[0];
+	} else {
+		buid = (((unsigned long)buid_vals[0]) << 32UL) |
+			(((unsigned long)buid_vals[1]) & 0xffffffff);
+	}
+	return buid;
+}
+
+static struct pci_controller * __init alloc_phb(struct device_node *dev,
 				 unsigned int addr_size_words)
 {
 	struct pci_controller *phb;
 	unsigned int *ui_ptr = NULL, len;
 	struct reg_property64 reg_struct;
 	int *bus_range;
-	int *buid_vals;
 	char *model;
 	enum phb_types phb_type;
  	struct property *of_prop;
@@ -431,18 +468,7 @@ struct pci_controller *alloc_phb(struct 
 	phb->arch_data   = dev;
 	phb->ops = &rtas_pci_ops;
 
-	buid_vals = (int *) get_property(dev, "ibm,fw-phb-id", &len);
-
-	if (buid_vals == NULL) {
-		phb->buid = 0;
-	} else {
-		if (len < 2 * sizeof(int))
-			// Support for new OF that only has 1 integer for buid.
-			phb->buid = (unsigned long)buid_vals[0];
-		else
-			phb->buid = (((unsigned long)buid_vals[0]) << 32UL) |
-				(((unsigned long)buid_vals[1]) & 0xffffffff);
-	}
+	phb->buid = get_phb_buid(dev);
 
 	return phb;
 }
@@ -456,11 +482,6 @@ unsigned long __init find_and_init_phbs(
 	unsigned int *opprop;
 	struct device_node *root = of_find_node_by_path("/");
 
-	read_pci_config = rtas_token("read-pci-config");
-	write_pci_config = rtas_token("write-pci-config");
-	ibm_read_pci_config = rtas_token("ibm,read-pci-config");
-	ibm_write_pci_config = rtas_token("ibm,write-pci-config");
-
 	if (naca->interrupt_controller == IC_OPEN_PIC) {
 		opprop = (unsigned int *)get_property(root,
 				"platform-open-pic", NULL);
--- a/arch/ppc64/kernel/eeh.c 2004-06-11 14:10:19.000000000 -0500
+++ b/arch/ppc64/kernel/eeh.c	2004-06-15 16:52:05.000000000 -0500
@@ -645,7 +645,7 @@ static void *early_enable_eeh(struct dev
 			       dn->full_name);
 #endif
 		} else {
-			printk(KERN_WARNING "EEH: %s: rtas_call failed.\n",
+			printk(KERN_WARNING "EEH: %s: could not enable EEH, rtas_call failed.\n",
 			       dn->full_name);
 		}
 	} else {
@@ -709,24 +709,17 @@ void __init eeh_init(void)
 	}
 
 	/* Enable EEH for all adapters.  Note that eeh requires buid's */
+	init_pci_config_tokens();
 	for (phb = of_find_node_by_name(NULL, "pci"); phb;
 	     phb = of_find_node_by_name(phb, "pci")) {
-		int len;
-		int *buid_vals;
+		unsigned long buid;
 
-		buid_vals = (int *)get_property(phb, "ibm,fw-phb-id", &len);
-		if (!buid_vals)
+		buid = get_phb_buid(phb);
+		if (buid == 0) 
 			continue;
-		if (len == sizeof(int)) {
-			info.buid_lo = buid_vals[0];
-			info.buid_hi = 0;
-		} else if (len == sizeof(int)*2) {
-			info.buid_hi = buid_vals[0];
-			info.buid_lo = buid_vals[1];
-		} else {
-			printk(KERN_INFO "EEH: odd ibm,fw-phb-id len returned: %d\n", len);
-			continue;
-		}
+		
+		info.buid_lo = BUID_LO(buid);
+		info.buid_hi = BUID_HI(buid);
 		traverse_pci_devices(phb, early_enable_eeh, NULL, &info);
 	}
 
--- a/arch/ppc64/kernel/pci.h	2004-06-15 16:51:04.000000000 -0500
+++ b/arch/ppc64/kernel/pci.h	2004-06-15 16:51:38.000000000 -0500
@@ -47,4 +47,9 @@ struct device_node *fetch_dev_dn(struct 
 void pci_addr_cache_insert_device(struct pci_dev *dev);
 void pci_addr_cache_remove_device(struct pci_dev *dev);
 
+/* From pSeries_pci.h */
+void init_pci_config_tokens (void);
+unsigned long get_phb_buid (struct device_node *);
+
+
 #endif /* __PPC_KERNEL_PCI_H__ */
