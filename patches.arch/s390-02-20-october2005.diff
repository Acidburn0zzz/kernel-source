From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: Performance regression with spin_lock_retry

  Description: kernel: spin lock retry performance.
  Symptom:     Decreased performance if running with spin_retry != 0.
  Problem:     Currently the spin lock code tries up to spin_retry times to
               grab a lock using the cs instruction. The cs instruction has
               exclusive access to a memory region and therefore invalidates
               the appropiate cache line of all other cpus. If there is
               contention on a lock this leads to cache line trashing.
  Solution:    Check wether a cs instruction is likely to succeed before
               the instruction gets actually executed.
  Problem-ID:  22170
  Archs:       s390-31, s390-64

Signed-off-by: Hannes Reinecke <hare@suse.de>

--- linux-2.5/arch/s390/lib/spinlock.c	1 Feb 2006 14:13:32 -0000	1.2.2.1
+++ linux-2.5/arch/s390/lib/spinlock.c	3 Mar 2006 18:49:27 -0000	1.2.2.2
@@ -2,8 +2,7 @@
  *  arch/s390/lib/spinlock.c
  *    Out of line spinlock code.
  *
- *  S390 version
- *    Copyright (C) 2004 IBM Deutschland Entwicklung GmbH, IBM Corporation
+ *    Copyright (C) IBM Corp. 2004, 2006
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
  */
 
@@ -44,6 +43,8 @@
 			_diag44();
 			count = spin_retry;
 		}
+		if (__raw_spin_is_locked(lp))
+			continue;
 		if (_raw_compare_and_swap(&lp->lock, 0, pc) == 0)
 			return;
 	}
@@ -56,6 +57,8 @@
 	int count = spin_retry;
 
 	while (count-- > 0) {
+		if (__raw_spin_is_locked(lp))
+			continue;
 		if (_raw_compare_and_swap(&lp->lock, 0, pc) == 0)
 			return 1;
 	}
@@ -74,6 +77,8 @@
 			_diag44();
 			count = spin_retry;
 		}
+		if (!__raw_read_can_lock(rw))
+			continue;
 		old = rw->lock & 0x7fffffffU;
 		if (_raw_compare_and_swap(&rw->lock, old, old + 1) == old)
 			return;
@@ -88,6 +93,8 @@
 	int count = spin_retry;
 
 	while (count-- > 0) {
+		if (!__raw_read_can_lock(rw))
+			continue;
 		old = rw->lock & 0x7fffffffU;
 		if (_raw_compare_and_swap(&rw->lock, old, old + 1) == old)
 			return 1;
@@ -106,6 +113,8 @@
 			_diag44();
 			count = spin_retry;
 		}
+		if (!__raw_write_can_lock(rw))
+			continue;
 		if (_raw_compare_and_swap(&rw->lock, 0, 0x80000000) == 0)
 			return;
 	}
@@ -118,6 +127,8 @@
 	int count = spin_retry;
 
 	while (count-- > 0) {
+		if (!__raw_write_can_lock(rw))
+			continue;
 		if (_raw_compare_and_swap(&rw->lock, 0, 0x80000000) == 0)
 			return 1;
 	}

