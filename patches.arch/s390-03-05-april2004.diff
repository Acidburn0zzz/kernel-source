- Description: qeth: osasnmpd not working on Linux 2.6
  Symptom:     osasnmpd does not work with 2.6 version of qeth.
  Problem:     snmp functionality not yet implemented on 2.6 qeth.
  Solution:    Added missing functions to support snmp.
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_mpc.h	14 May 2004 11:53:24 -0000	1.27.2.3
+++ linux-2.5/drivers/s390/net/qeth_mpc.h	24 May 2004 15:46:48 -0000	1.27.2.4
@@ -14,7 +14,7 @@
 
 #include <asm/qeth.h>
 
-#define VERSION_QETH_MPC_H "$Revision: 1.27.2.3 $"
+#define VERSION_QETH_MPC_H "$Revision: 1.27.2.4 $"
 
 extern const char *VERSION_QETH_MPC_C;
 
@@ -296,6 +296,29 @@
 	__u8 addr[OSA_ADDR_LEN];
 } __attribute__ ((packed));
 
+
+struct qeth_snmp_cmd {
+	__u8  token[16];
+	__u32 request;
+	__u32 interface;
+	__u32 returncode;
+	__u32 firmwarelevel;
+	__u32 seqno;
+	__u8  data;
+} __attribute__ ((packed));
+
+struct qeth_snmp_ureq_hdr {
+	__u32   data_len;
+	__u32   req_len;
+	__u32   reserved1;
+	__u32   reserved2;
+} __attribute__ ((packed));
+
+struct qeth_snmp_ureq {
+	struct qeth_snmp_ureq_hdr hdr;
+	struct qeth_snmp_cmd cmd;
+} __attribute__((packed));
+
 struct qeth_ipacmd_setadpparms_hdr {
 	__u32 supp_hw_cmds;
 	__u32 reserved1;
@@ -313,6 +336,7 @@
 	union {
 		struct qeth_query_cmds_supp query_cmds_supp;
 		struct qeth_change_addr change_addr;
+		struct qeth_snmp_cmd snmp;
 		__u32 mode;
 	} data;
 } __attribute__ ((packed));
@@ -386,6 +410,7 @@
 				       QETH_SETASS_BASE_LEN)
 #define QETH_SETADP_BASE_LEN (sizeof(struct qeth_ipacmd_hdr) + \
 			      sizeof(struct qeth_ipacmd_setadpparms_hdr))
+#define QETH_SNMP_SETADP_CMDLENGTH 16
 
 #define QETH_ARP_DATA_SIZE 3968
 #define QETH_ARP_CMD_LEN (QETH_ARP_DATA_SIZE + 8)

--- linux-2.5/drivers/s390/net/qeth_main.c	24 May 2004 15:35:17 -0000	1.77.2.14
+++ linux-2.5/drivers/s390/net/qeth_main.c	24 May 2004 15:46:48 -0000	1.77.2.15
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.14 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.15 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.14 $	 $Date: 2004/05/24 15:35:17 $
+ *    $Revision: 1.77.2.15 $	 $Date: 2004/05/24 15:46:48 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.14 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.15 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -100,6 +100,9 @@
 
 /* list of our cards */
 struct qeth_card_list_struct qeth_card_list;
+/*process list want to be notified*/
+spinlock_t qeth_notify_lock;
+struct list_head qeth_notify_list;
 
 static void qeth_send_control_data_cb(struct qeth_channel *,
 				      struct qeth_cmd_buffer *); 
@@ -155,6 +158,68 @@
 static struct qeth_ipaddr *
 qeth_get_addr_buffer(enum qeth_prot_versions);
 
+static void
+qeth_notify_processes(void)
+{
+	/*notify all  registered processes */
+	struct qeth_notify_list_struct *n_entry;
+
+	QETH_DBF_TEXT(trace,3,"procnoti");
+	spin_lock(&qeth_notify_lock);
+	list_for_each_entry(n_entry, &qeth_notify_list, list) {
+		send_sig(n_entry->signum, n_entry->task, 1);
+	}
+	spin_unlock(&qeth_notify_lock);
+
+}
+int
+qeth_notifier_unregister(struct task_struct *p)
+{
+	struct qeth_notify_list_struct *n_entry, *tmp;
+
+	QETH_DBF_TEXT(trace, 2, "notunreg");
+	spin_lock(&qeth_notify_lock);
+	list_for_each_entry_safe(n_entry, tmp, &qeth_notify_list, list) {
+		if (n_entry->task == p) {
+			list_del(&n_entry->list);
+			kfree(n_entry);
+			goto out;
+		}
+	}
+out:
+	spin_unlock(&qeth_notify_lock);
+	return 0;
+}
+int
+qeth_notifier_register(struct task_struct *p, int signum)
+{
+	struct qeth_notify_list_struct *n_entry;
+
+	QETH_DBF_TEXT(trace, 2, "notreg");
+	/*check first if entry already exists*/
+	spin_lock(&qeth_notify_lock);
+	list_for_each_entry(n_entry, &qeth_notify_list, list) {
+		if (n_entry->task == p) {
+			n_entry->signum = signum;
+			spin_unlock(&qeth_notify_lock);
+			return 0;
+		}
+	}
+	spin_unlock(&qeth_notify_lock);
+
+	n_entry = (struct qeth_notify_list_struct *)
+		kmalloc(sizeof(struct qeth_notify_list_struct),GFP_KERNEL);
+	if (!n_entry)
+		return -ENOMEM;
+	n_entry->task = p;
+	n_entry->signum = signum;
+	spin_lock(&qeth_notify_lock);
+	list_add(&n_entry->list,&qeth_notify_list);
+	spin_unlock(&qeth_notify_lock);
+	return 0;
+}
+
+
 /**
  * free channel command buffers
  */ 
@@ -460,6 +525,7 @@
 	ccw_device_set_offline(CARD_RDEV(card));
 	if (recover_flag == CARD_STATE_UP)
 		card->state = CARD_STATE_RECOVER;
+	qeth_notify_processes();
 	return 0;
 }
 
@@ -1631,7 +1697,7 @@
 							(unsigned long)iob);
 			}
 			if (cmd)
-				reply->rc = cmd->hdr.return_code;
+				reply->rc = (s16) cmd->hdr.return_code;
 			else if (iob->rc)
 				reply->rc = iob->rc;
 			if (keep_reply) {
@@ -4051,6 +4117,70 @@
 	return rc;
 }
 
+/**
+ * SNMP command callback
+ */
+static int
+qeth_snmp_command_cb(struct qeth_card *card, struct qeth_reply *reply,
+		     unsigned long sdata)
+{
+	struct qeth_ipa_cmd *cmd;
+	struct qeth_arp_query_info *qinfo;
+	struct qeth_snmp_cmd *snmp;
+	unsigned char *data;
+	__u16 data_len;
+
+	QETH_DBF_TEXT(trace,3,"snpcmdcb");
+
+	cmd = (struct qeth_ipa_cmd *) sdata;
+	data = (unsigned char *)((char *)cmd - reply->offset);
+	qinfo = (struct qeth_arp_query_info *) reply->param;
+	snmp = &cmd->data.setadapterparms.data.snmp;
+
+	if (cmd->hdr.return_code) {
+		QETH_DBF_TEXT_(trace,4,"scer1%i", cmd->hdr.return_code);
+		return 0;
+	}
+	if (cmd->data.setadapterparms.hdr.return_code) {
+		cmd->hdr.return_code = cmd->data.setadapterparms.hdr.return_code;
+		QETH_DBF_TEXT_(trace,4,"scer2%i", cmd->hdr.return_code);
+		return 0;
+	}
+	data_len = *((__u16*)QETH_IPA_PDU_LEN_PDU1(data));
+	if (cmd->data.setadapterparms.hdr.seq_no == 1)
+		data_len -= (__u16)((char*)&snmp->request - (char *)cmd);
+	else
+		data_len -= (__u16)((char *)&snmp->data - (char *)cmd);
+	/* check if there is enough room in userspace */
+	if ((qinfo->udata_len - qinfo->udata_offset) < data_len) {
+		QETH_DBF_TEXT_(trace, 4, "scer3%i", -ENOMEM);
+		cmd->hdr.return_code = -ENOMEM;
+		return 0;
+	}
+	QETH_DBF_TEXT_(trace, 4, "snore%i",
+		       cmd->data.setadapterparms.hdr.used_total);
+	QETH_DBF_TEXT_(trace, 4, "sseqn%i", cmd->data.setassparms.hdr.seq_no);
+	/*copy entries to user buffer*/
+	if (cmd->data.setadapterparms.hdr.seq_no == 1) {
+		memcpy(qinfo->udata + qinfo->udata_offset,
+		       (char *)snmp,offsetof(struct qeth_snmp_cmd,data));
+		qinfo->udata_offset += offsetof(struct qeth_snmp_cmd, data);
+	}
+	memcpy(qinfo->udata + qinfo->udata_offset,
+	       (char *)&snmp->data, data_len);
+	qinfo->udata_offset += data_len;
+	/* check if all replies received ... */
+		QETH_DBF_TEXT_(trace, 4, "srtot%i",
+			       cmd->data.setadapterparms.hdr.used_total);
+		QETH_DBF_TEXT_(trace, 4, "srseq%i",
+			       cmd->data.setadapterparms.hdr.seq_no);
+	if (cmd->data.setadapterparms.hdr.seq_no <
+	    cmd->data.setadapterparms.hdr.used_total)
+		return 1;
+	return 0;
+
+}
+
 static struct qeth_cmd_buffer *
 qeth_get_ipacmd_buffer(struct qeth_card *, enum qeth_ipa_cmds,
 		       enum qeth_prot_versions );
@@ -4072,6 +4202,55 @@
 	return iob;
 }
 
+/**
+ * function to send SNMP commands to OSA-E card
+ */
+static int
+qeth_snmp_command(struct qeth_card *card, char *udata)
+{
+	struct qeth_cmd_buffer *iob;
+	struct qeth_ipa_cmd *cmd;
+	struct qeth_snmp_ureq ureq;
+	struct qeth_arp_query_info qinfo = {0, };
+	int rc = 0;
+
+	QETH_DBF_TEXT(trace,3,"snmpcmd");
+
+	if (card->info.guestlan)
+		return -EOPNOTSUPP;
+	if (!qeth_adp_supported(card,IPA_SETADP_SET_SNMP_CONTROL)) {
+		PRINT_WARN("SNMP Query MIBS not supported "
+			   "on %s!\n", card->info.if_name);
+		return -EOPNOTSUPP;
+	}
+	if (copy_from_user(&ureq, udata, sizeof(struct qeth_snmp_ureq)))
+		return -EFAULT;
+	qinfo.udata_len = ureq.hdr.data_len;
+	if (!(qinfo.udata = kmalloc(qinfo.udata_len, GFP_KERNEL)))
+		return -ENOMEM;
+	memset(qinfo.udata, 0, qinfo.udata_len);
+	qinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);
+
+	iob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,
+				   QETH_SNMP_SETADP_CMDLENGTH+ureq.hdr.req_len);
+	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
+	memcpy(&cmd->data.setadapterparms.data.snmp, &ureq.cmd,
+	       sizeof(struct qeth_snmp_cmd));
+	rc = qeth_send_ipa_arp_cmd(card, iob,
+				   QETH_SETADP_BASE_LEN + QETH_ARP_DATA_SIZE +
+				   ureq.hdr.req_len, qeth_snmp_command_cb,
+				   (void *)&qinfo);
+	if (rc)
+		PRINT_WARN("SNMP command failed on %s: (0x%x)\n",
+			   card->info.if_name, rc);
+	 else
+		copy_to_user(udata, qinfo.udata, qinfo.udata_len);
+
+
+	kfree(qinfo.udata);
+	return rc;
+}
+
 static int
 qeth_default_setassparms_cb(struct qeth_card *, struct qeth_reply *,
 			    unsigned long);
@@ -4260,8 +4439,13 @@
 		rc = qeth_arp_flush_cache(card);
 		break;
 	case SIOC_QETH_ADP_SET_SNMP_CONTROL:
+		rc = qeth_snmp_command(card, rq->ifr_ifru.ifru_data);
 		break;
 	case SIOC_QETH_GET_CARD_TYPE:
+		if ((card->info.type == QETH_CARD_TYPE_OSAE) &&
+		    !card->info.guestlan)
+			return 1;
+		return 0;
 		break;
 	case SIOCGMIIPHY:
 		mii_data = (struct mii_ioctl_data *) &rq->ifr_ifru.ifru_data;
@@ -6225,7 +6409,7 @@
 	qeth_set_allowed_threads(card, 0xffffffff, 0);
 	if (recover_flag == CARD_STATE_RECOVER)
 		qeth_start_again(card);
-
+	qeth_notify_processes();
 	return 0;
 out_remove:
 	card->use_hard_stop = 1;
@@ -6899,6 +7083,8 @@
 		   QETH_VERSION_VLAN);
 
 	INIT_LIST_HEAD(&qeth_card_list.list);
+	INIT_LIST_HEAD(&qeth_notify_list);
+	spin_lock_init(&qeth_notify_lock);
 	rwlock_init(&qeth_card_list.rwlock);
 
 	if (qeth_register_dbf_views())

--- linux-2.5/drivers/s390/net/qeth.h	24 May 2004 15:35:17 -0000	1.98.2.8
+++ linux-2.5/drivers/s390/net/qeth.h	24 May 2004 15:46:48 -0000	1.98.2.9
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.98.2.8 $"
+#define VERSION_QETH_H 		"$Revision: 1.98.2.9 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -725,6 +725,15 @@
 
 extern struct qeth_card_list_struct qeth_card_list;
 
+/*notifier list */
+struct qeth_notify_list_struct {
+	struct list_head list;
+	struct task_struct *task;
+	int signum;
+};
+extern spinlock_t qeth_notify_lock;
+extern struct list_head qeth_notify_list;
+
 /*some helper functions*/
 
 inline static __u8
@@ -1007,6 +1016,12 @@
 
 extern void
 qeth_del_rxip(struct qeth_card *, enum qeth_prot_versions, const u8 *);
+
+extern int
+qeth_notifier_register(struct task_struct *, int );
+
+extern int
+qeth_notifier_unregister(struct task_struct * );
 
 extern void
 qeth_schedule_recovery(struct qeth_card *);

--- linux-2.5/drivers/s390/net/qeth_sys.c	14 May 2004 10:32:08 -0000	1.19.2.6
+++ linux-2.5/drivers/s390/net/qeth_sys.c	24 May 2004 15:58:40 -0000	1.19.2.7
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19.2.6 $)
+ * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19.2.7 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to sysfs.
@@ -20,7 +20,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-const char *VERSION_QETH_SYS_C = "$Revision: 1.19.2.6 $";
+const char *VERSION_QETH_SYS_C = "$Revision: 1.19.2.7 $";
 
 /*****************************************************************************/
 /*                                                                           */
@@ -1442,22 +1442,33 @@
 static DRIVER_ATTR(group, 0200, 0, qeth_driver_group_store);
 
 static ssize_t
-qeth_driver_snmp_register_show(struct device_driver *ddrv, char *buf)
-{
-	/* TODO */
-	return 0;
-}
-
-static ssize_t
-qeth_driver_snmp_register_store(struct device_driver *ddrv, const char *buf,
+qeth_driver_notifier_register_store(struct device_driver *ddrv, const char *buf,
 				size_t count)
 {
-	/* TODO */
+	int rc;
+	int signum;
+	char *tmp, *tmp2;
+
+	tmp = strsep((char **) &buf, "\n");
+	if (!strncmp(tmp, "unregister", 10)){
+		if ((rc = qeth_notifier_unregister(current)))
+			return rc;
+		return count;
+	}
+
+	signum = simple_strtoul(tmp, &tmp2, 10);
+	if ((signum < 0) || (signum > 32)){
+		PRINT_WARN("Signal number %d is out of range\n", signum);
+		return -EINVAL;
+	}
+	if ((rc = qeth_notifier_register(current, signum)))
+		return rc;
+
 	return count;
 }
 
-static DRIVER_ATTR(snmp_register, 0644, qeth_driver_snmp_register_show,
-		   qeth_driver_snmp_register_store);
+static DRIVER_ATTR(notifier_register, 0200, 0,
+		   qeth_driver_notifier_register_store);
 
 int
 qeth_create_driver_attributes(void)
@@ -1468,7 +1479,7 @@
 				     &driver_attr_group)))
 		return rc;
 	return driver_create_file(&qeth_ccwgroup_driver.driver,
-				  &driver_attr_snmp_register);
+				  &driver_attr_notifier_register);
 }
 
 void
@@ -1477,5 +1488,5 @@
 	driver_remove_file(&qeth_ccwgroup_driver.driver,
 			&driver_attr_group);
 	driver_remove_file(&qeth_ccwgroup_driver.driver,
-			&driver_attr_snmp_register);
+			&driver_attr_notifier_register);
 }

