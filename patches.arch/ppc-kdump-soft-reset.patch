From: hbabu@us.ibm.com
Subject: Bug 158238 - LTC22382-Sometimes kdump boot hung when invoked using soft-reset

Signed-off-by: Olaf Hering <olh@suse.de>
---
 arch/powerpc/kernel/crash.c |   28 ++++++++++++++++++++--------
 arch/powerpc/kernel/smp.c   |   13 +------------
 arch/powerpc/kernel/traps.c |   37 ++++++++++++++++++++++++++++---------
 include/asm-powerpc/kexec.h |    2 +-
 4 files changed, 50 insertions(+), 30 deletions(-)

Index: linux-2.6.16-olh-kdump/arch/powerpc/kernel/crash.c
===================================================================
--- linux-2.6.16-olh-kdump.orig/arch/powerpc/kernel/crash.c
+++ linux-2.6.16-olh-kdump/arch/powerpc/kernel/crash.c
@@ -97,7 +97,16 @@ static void crash_save_this_cpu(struct p
 }
 
 #ifdef CONFIG_SMP
-static atomic_t waiting_for_crash_ipi;
+static cpumask_t cpus_in_crash = CPU_MASK_NONE;
+
+static void crash_send_ipi(void (*crash_ipi_callback)(struct pt_regs *))
+{
+	crash_ipi_function_ptr = crash_ipi_callback;
+	if (crash_ipi_callback) {
+		mb();
+		smp_ops->message_pass(MSG_ALL_BUT_SELF, PPC_MSG_DEBUGGER_BREAK);
+	}
+}
 
 void crash_ipi_callback(struct pt_regs *regs)
 {
@@ -109,13 +118,16 @@ void crash_ipi_callback(struct pt_regs *
 	if (!cpu_online(cpu))
 		return;
 
+	if (cpu_isset(cpu, cpus_in_crash))
+		return;
+
 	if (ppc_md.kexec_cpu_down)
 		ppc_md.kexec_cpu_down(1, 1);
 
 	local_irq_disable();
 
 	crash_save_this_cpu(regs, cpu);
-	atomic_dec(&waiting_for_crash_ipi);
+	cpu_set(cpu, cpus_in_crash);
 	kexec_smp_wait();
 	/* NOTREACHED */
 }
@@ -123,8 +135,7 @@ void crash_ipi_callback(struct pt_regs *
 static void crash_kexec_prepare_cpus(void)
 {
 	unsigned int msecs;
-
-	atomic_set(&waiting_for_crash_ipi, num_online_cpus() - 1);
+	unsigned int ncpus = num_online_cpus() - 1;/* Excluding the panic cpu */
 
 	crash_send_ipi(crash_ipi_callback);
 	smp_wmb();
@@ -138,7 +149,7 @@ static void crash_kexec_prepare_cpus(voi
 	 */
 	printk(KERN_ALERT "Sending IPI to other cpus...\n");
 	msecs = 10000;
-	while ((atomic_read(&waiting_for_crash_ipi) > 0) && (--msecs > 0)) {
+	while ((cpus_weight(cpus_in_crash) < ncpus) && (--msecs > 0)) {
 		barrier();
 		mdelay(1);
 	}
@@ -153,9 +164,10 @@ static void crash_kexec_prepare_cpus(voi
 	 * will call machine_kexec() directly from this handler to do
 	 * kexec boot.
 	 */
-	if (atomic_read(&waiting_for_crash_ipi))
-		printk(KERN_ALERT "done waiting: %d cpus not responding\n",
-			atomic_read(&waiting_for_crash_ipi));
+	if (cpus_weight(cpus_in_crash) < ncpus)
+		printk(KERN_ALERT "done waiting: %d cpu(s) not responding\n",
+			ncpus - cpus_weight(cpus_in_crash));
+
 	/* Leave the IPI callback set */
 }
 #else
Index: linux-2.6.16-olh-kdump/arch/powerpc/kernel/smp.c
===================================================================
--- linux-2.6.16-olh-kdump.orig/arch/powerpc/kernel/smp.c
+++ linux-2.6.16-olh-kdump/arch/powerpc/kernel/smp.c
@@ -76,7 +76,7 @@ void smp_call_function_interrupt(void);
 
 int smt_enabled_at_boot = 1;
 
-static void (*crash_ipi_function_ptr)(struct pt_regs *) = NULL;
+void (*crash_ipi_function_ptr)(struct pt_regs *) = NULL;
 
 #ifdef CONFIG_MPIC
 int __init smp_mpic_probe(void)
@@ -155,17 +155,6 @@ void smp_send_debugger_break(int cpu)
 }
 #endif
 
-#ifdef CONFIG_KEXEC
-void crash_send_ipi(void (*crash_ipi_callback)(struct pt_regs *))
-{
-	crash_ipi_function_ptr = crash_ipi_callback;
-	if (crash_ipi_callback) {
-		mb();
-		smp_ops->message_pass(MSG_ALL_BUT_SELF, PPC_MSG_DEBUGGER_BREAK);
-	}
-}
-#endif
-
 static void stop_this_cpu(void *dummy)
 {
 	local_irq_disable();
Index: linux-2.6.16-olh-kdump/arch/powerpc/kernel/traps.c
===================================================================
--- linux-2.6.16-olh-kdump.orig/arch/powerpc/kernel/traps.c
+++ linux-2.6.16-olh-kdump/arch/powerpc/kernel/traps.c
@@ -96,7 +96,10 @@ static DEFINE_SPINLOCK(die_lock);
 
 int die(const char *str, struct pt_regs *regs, long err)
 {
-	static int die_counter, crash_dump_start = 0;
+	static int die_counter;
+#ifdef CONFIG_KEXEC
+	static int crash_dump_start = 0;
+#endif
 	int nl = 0;
 
 	if (debugger(regs))
@@ -158,20 +161,36 @@ int die(const char *str, struct pt_regs 
 	show_regs(regs);
 	bust_spinlocks(0);
 
+#ifdef CONFIG_KEXEC
 	if (!crash_dump_start && kexec_should_crash(current)) {
 		crash_dump_start = 1;
 		spin_unlock_irq(&die_lock);
 		crash_kexec(regs);
-		/* NOTREACHED */
-	}
-	spin_unlock_irq(&die_lock);
-	if (crash_dump_start)
 		/*
-		 * Only for soft-reset: Other CPUs will be responded to an IPI
-		 * sent by first kexec CPU.
+		 * If the kdump image is not loaded.
 		 */
-		for(;;)
-			;
+		crash_dump_start = 0;
+	} else
+		spin_unlock_irq(&die_lock);
+	if (crash_dump_start) {
+		/*
+	 	 * For soft-reset, some CPUs would have responded
+		 * to kdump IPI before receives FWNMI. So, call kdump IPI
+		 * callback directly. Otherwise, these CPUs will be
+	 	 * spinning forever since no more IPIs coming from
+		 * panic CPU.
+	 	 */
+		if (crash_ipi_function_ptr) {
+			crash_ipi_function_ptr(regs);
+			return 1;
+		}
+		while (crash_dump_start) {
+			mdelay(1);
+			barrier();
+		}
+		/* kdump image is not loaded */
+	}
+#endif
 
 	if (in_interrupt())
 		panic("Fatal exception in interrupt");
Index: linux-2.6.16-olh-kdump/include/asm-powerpc/kexec.h
===================================================================
--- linux-2.6.16-olh-kdump.orig/include/asm-powerpc/kexec.h
+++ linux-2.6.16-olh-kdump/include/asm-powerpc/kexec.h
@@ -113,9 +113,9 @@ extern void kexec_smp_wait(void);	/* get
 					  master to copy new code to 0 */
 extern void __init kexec_setup(void);
 extern int crashing_cpu;
-extern void crash_send_ipi(void (*crash_ipi_callback)(struct pt_regs *));
 #endif /* __powerpc64 __ */
 
+extern void (*crash_ipi_function_ptr)(struct pt_regs *);
 struct kimage;
 struct pt_regs;
 extern void default_machine_kexec(struct kimage *image);
