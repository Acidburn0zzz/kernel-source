Subject: [PATCH] 2 of 3   kdump-ppc64-soft-reset-fixes
From: David Wilder <dwilder@us.ibm.com>
Date: Mon, 10 Apr 2006 15:31:42 -0700
Message-ID: <443ADCCE.1070504@us.ibm.com>

Bug 149545 - LTC21344-kdump boot panic when a CPU hangs in the first kernel
Bug 152931 - LTC21955 - kdump: crash in calibrating delay loop on power5
Bug 158238 - LTC22382-Sometimes kdump boot hung when invoked using soft-reset
Bug 159713 - LTC22581 - kdump via reset -sft fails on JS20 with bad kernel stack pointer


 - When a system hangs, user will activate the soft-reset to initiate the
 kdump boot. But, soft-reset behavior is indeterminate on sending FWNMI
 to all CPUS. i.e, all CPUs will not get FW NMI at the same time. When the
 first CPU entered (calling primary CPU here onwards) kdump using crash_kexec(),
 sends an IPI to other CPUs. Some CPUs will respond to this IPI and execute
 crash_ipi_callback()  before receive NMI. When they receive FW NMI, will
 execute die() and waiting forever since no more kdump IPI coming from the
 primary CPU. This issue will be fixed by invoking crash_kexec_secondary()
 directly from die().

Since the secondary CPUs will enter the IPI_callback function two times,
CPU states have to be saved only once and the primary CPU has to start kdump
boot after all CPUs are stopped. Hence, cpus_in_crash bitmap is used to
determine whether pt_regs is saved. If the bit is not set, regs will be saved.
Introduced cpus_in_sr bitmap and enter_on_soft_reset counter which are used
to let the primary CPU know that all secondary CPUs entered via soft-reset
and ready to do down.

 - For the crash scenario, when a CPU hangs with interrupts disabled and
 the other CPUs panic or user invoked kdump boot using sysrq-c. In this case,
 the hung CPU can not be stopped and causes the kdump boot not successful.
 This case can be treated as complete system hang and asks the user to
 activate soft-reset if all secondary CPUs are not stopped.

 - unless panic_on_oops is set it is possible for none of the cpus to
 become the crashing cpu when initiating a dump with a soft-reset.
 Thus the boot of the kdump kernel is never started.

Signed-off-by: Haren Myneni <haren@us.ibm.com>
Signed-off-by: Olaf Hering <olh@suse.de>

---
 arch/powerpc/kernel/crash.c |  149 +++++++++++++++++++++++++++++++++++---------
 arch/powerpc/kernel/traps.c |   26 +++----
 include/asm-powerpc/kexec.h |   18 ++++-
 include/linux/kexec.h       |    1 
 4 files changed, 146 insertions(+), 48 deletions(-)

Index: linux-2.6.16-olh-kdump/arch/powerpc/kernel/crash.c
===================================================================
--- linux-2.6.16-olh-kdump.orig/arch/powerpc/kernel/crash.c
+++ linux-2.6.16-olh-kdump/arch/powerpc/kernel/crash.c
@@ -24,9 +24,11 @@
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/types.h>
+#include <linux/irq.h>
 
 #include <asm/processor.h>
 #include <asm/machdep.h>
+#include <asm/kexec.h>
 #include <asm/kdump.h>
 #include <asm/lmb.h>
 #include <asm/firmware.h>
@@ -41,6 +43,7 @@
 
 /* This keeps a track of which one is crashing cpu. */
 int crashing_cpu = -1;
+static cpumask_t cpus_in_crash = CPU_MASK_NONE;
 
 static u32 *append_elf_note(u32 *buf, char *name, unsigned type, void *data,
 							       size_t data_len)
@@ -98,34 +101,65 @@ static void crash_save_this_cpu(struct p
 }
 
 #ifdef CONFIG_SMP
-static atomic_t waiting_for_crash_ipi;
+static atomic_t enter_on_soft_reset = ATOMIC_INIT(0);
 
 void crash_ipi_callback(struct pt_regs *regs)
 {
 	int cpu = smp_processor_id();
 
-	if (cpu == crashing_cpu)
-		return;
-
 	if (!cpu_online(cpu))
 		return;
 
-	if (ppc_md.kexec_cpu_down)
-		ppc_md.kexec_cpu_down(1, 1);
-
 	local_irq_disable();
+	if (!cpu_isset(cpu, cpus_in_crash))
+		crash_save_this_cpu(regs, cpu);
+	cpu_set(cpu, cpus_in_crash);
+
+	/*
+	 * Entered via soft-reset - could be the kdump
+	 * process is invoked using soft-reset or user activated
+	 * it if some CPU did not respond to an IPI.
+	 * For soft-reset, the secondary CPU can enter this func
+	 * twice. 1 - using IPI, and 2. soft-reset.
+	 * Tell the kexec CPU that entered via soft-reset and ready
+	 * to go down.
+	 */
+	if (cpu_isset(cpu, cpus_in_sr)) {
+		cpu_clear(cpu, cpus_in_sr);
+		atomic_inc(&enter_on_soft_reset);
+	}
 
-	crash_save_this_cpu(regs, cpu);
-	atomic_dec(&waiting_for_crash_ipi);
+	/*
+	 * Starting the kdump boot.
+	 * This barrier is needed to make sure that all CPUs are stopped.
+	 * If not, soft-reset will be invoked to bring other CPUs.
+	 */
+	while (!cpu_isset(crashing_cpu, cpus_in_crash))
+		cpu_relax();
+
+	if (ppc_md.kexec_cpu_down)
+		ppc_md.kexec_cpu_down(1, 1);
 	kexec_smp_wait();
 	/* NOTREACHED */
 }
 
-static void crash_kexec_prepare_cpus(void)
+/*
+ * Wait until all CPUs are entered via soft-reset.
+ */
+static void crash_soft_reset_check(int cpu)
+{
+	unsigned int ncpus = num_online_cpus() - 1;/* Excluding the panic cpu */
+
+	cpu_clear(cpu, cpus_in_sr);
+	while (atomic_read(&enter_on_soft_reset) != ncpus)
+		cpu_relax();
+}
+
+static void crash_kexec_prepare_cpus(int cpu)
 {
 	unsigned int msecs;
 
-	atomic_set(&waiting_for_crash_ipi, num_online_cpus() - 1);
+	unsigned int ncpus = num_online_cpus() - 1;/* Excluding the panic cpu */
 
 	crash_send_ipi(crash_ipi_callback);
 	smp_wmb();
@@ -133,14 +167,13 @@ static void crash_kexec_prepare_cpus(voi
 	/*
 	 * FIXME: Until we will have the way to stop other CPUSs reliabally,
 	 * the crash CPU will send an IPI and wait for other CPUs to
-	 * respond. If not, proceed the kexec boot even though we failed to
-	 * capture other CPU states.
+	 * respond.
 	 * Delay of at least 10 seconds.
 	 */
-	printk(KERN_ALERT "Sending IPI to other cpus...\n");
+	printk(KERN_EMERG "Sending IPI to other cpus...\n");
 	msecs = 10000;
-	while ((atomic_read(&waiting_for_crash_ipi) > 0) && (--msecs > 0)) {
-		barrier();
+	while ((cpus_weight(cpus_in_crash) < ncpus) && (--msecs > 0)) {
+		cpu_relax();
 		mdelay(1);
 	}
 
@@ -149,18 +182,71 @@ static void crash_kexec_prepare_cpus(voi
 	/*
 	 * FIXME: In case if we do not get all CPUs, one possibility: ask the
 	 * user to do soft reset such that we get all.
-	 * IPI handler is already set by the panic cpu initially. Therefore,
-	 * all cpus could invoke this handler from die() and the panic CPU
-	 * will call machine_kexec() directly from this handler to do
-	 * kexec boot.
-	 */
-	if (atomic_read(&waiting_for_crash_ipi))
-		printk(KERN_ALERT "done waiting: %d cpus not responding\n",
-			atomic_read(&waiting_for_crash_ipi));
+	 * Soft-reset will be used until better mechanism is implemented.
+	 */
+	if (cpus_weight(cpus_in_crash) < ncpus) {
+		printk(KERN_EMERG "done waiting: %d cpu(s) not responding\n",
+			ncpus - cpus_weight(cpus_in_crash));
+		printk(KERN_EMERG "Activate soft-reset to stop other cpu(s)\n");
+		cpus_in_sr = CPU_MASK_NONE;
+		atomic_set(&enter_on_soft_reset, 0);
+		while (cpus_weight(cpus_in_crash) < ncpus)
+			cpu_relax();
+	}
+	/*
+	 * Make sure all CPUs are entered via soft-reset if the kdump is
+	 * invoked using soft-reset.
+	 */
+	if (cpu_isset(cpu, cpus_in_sr))
+		crash_soft_reset_check(cpu);
 	/* Leave the IPI callback set */
 }
+
+/*
+ * This function will be called by secondary cpus or by kexec cpu
+ * if soft-reset is activated to stop some CPUs.
+ */
+void crash_kexec_secondary(struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+	unsigned long flags;
+	int msecs = 5;
+
+	local_irq_save(flags);
+	/* Wait 5ms if the kexec CPU is not entered yet. */
+	while (crashing_cpu < 0) {
+		if (--msecs < 0) {
+			/*
+			 * Either kdump image is not loaded or
+			 * kdump process is not started - Probably xmon
+			 * exited using 'x'(exit and recover) or
+			 * kexec_should_crash() failed for all running tasks.
+			 */
+			cpu_clear(cpu, cpus_in_sr);
+			local_irq_restore(flags);
+			return;
+		}
+		mdelay(1);
+		cpu_relax();
+	}
+	if (cpu == crashing_cpu) {
+		/*
+		 * Panic CPU will enter this func only via soft-reset.
+		 * Wait until all secondary CPUs entered and
+		 * then start kexec boot.
+		 */
+		crash_soft_reset_check(cpu);
+		cpu_set(crashing_cpu, cpus_in_crash);
+		if (ppc_md.kexec_cpu_down)
+			ppc_md.kexec_cpu_down(1, 0);
+		machine_kexec(kexec_crash_image);
+		/* NOTREACHED */
+	}
+	crash_ipi_callback(regs);
+}
+
 #else
-static void crash_kexec_prepare_cpus(void)
+static void crash_kexec_prepare_cpus(int cpu)
 {
 	/*
 	 * move the secondarys to us so that we can copy
@@ -171,6 +257,10 @@ static void crash_kexec_prepare_cpus(voi
 	smp_release_cpus();
 }
 
+void crash_kexec_secondary(struct pt_regs *regs)
+{
+	cpus_in_sr = CPU_MASK_NONE;
+}
 #endif
 
 void default_machine_crash_shutdown(struct pt_regs *regs)
@@ -198,15 +288,14 @@ void default_machine_crash_shutdown(stru
 		if (!(desc->status & IRQ_DISABLED))
 			desc->handler->disable(irq);
 	}
-
-	if (ppc_md.kexec_cpu_down)
-		ppc_md.kexec_cpu_down(1, 0);
-
 	/*
 	 * Make a note of crashing cpu. Will be used in machine_kexec
 	 * such that another IPI will not be sent.
 	 */
 	crashing_cpu = smp_processor_id();
-	crash_kexec_prepare_cpus();
 	crash_save_this_cpu(regs, crashing_cpu);
+	crash_kexec_prepare_cpus(crashing_cpu);
+	cpu_set(crashing_cpu, cpus_in_crash);
+	if (ppc_md.kexec_cpu_down)
+		ppc_md.kexec_cpu_down(1, 0);
 }
Index: linux-2.6.16-olh-kdump/arch/powerpc/kernel/traps.c
===================================================================
--- linux-2.6.16-olh-kdump.orig/arch/powerpc/kernel/traps.c
+++ linux-2.6.16-olh-kdump/arch/powerpc/kernel/traps.c
@@ -51,9 +51,13 @@
 #include <asm/firmware.h>
 #include <asm/processor.h>
 #endif
+#include <asm/kexec.h>
 
 #ifdef CONFIG_PPC64	/* XXX */
 #define _IO_BASE	pci_io_base
+#ifdef CONFIG_KEXEC
+cpumask_t cpus_in_sr = CPU_MASK_NONE;
+#endif
 #endif
 
 #ifdef CONFIG_DEBUGGER
@@ -96,7 +100,7 @@ static DEFINE_SPINLOCK(die_lock);
 
 int die(const char *str, struct pt_regs *regs, long err)
 {
-	static int die_counter, crash_dump_start = 0;
+	static int die_counter;
 	int nl = 0;
 
 	if (debugger(regs))
@@ -157,21 +161,11 @@ int die(const char *str, struct pt_regs 
 	print_modules();
 	show_regs(regs);
 	bust_spinlocks(0);
+	spin_unlock_irq(&die_lock);
 
-	if (!crash_dump_start && kexec_should_crash(current)) {
-		crash_dump_start = 1;
-		spin_unlock_irq(&die_lock);
+	if (kexec_should_crash(current) || kexec_sr_activated(smp_processor_id()))
 		crash_kexec(regs);
-		/* NOTREACHED */
-	}
-	spin_unlock_irq(&die_lock);
-	if (crash_dump_start)
-		/*
-		 * Only for soft-reset: Other CPUs will be responded to an IPI
-		 * sent by first kexec CPU.
-		 */
-		for(;;)
-			;
+	crash_kexec_secondary(regs);
 
 	if (in_interrupt())
 		panic("Fatal exception in interrupt");
@@ -235,6 +229,10 @@ void system_reset_exception(struct pt_re
 			return;
 	}
 
+#ifdef CONFIG_KEXEC
+	cpu_set(smp_processor_id(), cpus_in_sr);
+#endif
+
 	die("System Reset", regs, SIGABRT);
 
 	/* Must die if the interrupt is not recoverable */
Index: linux-2.6.16-olh-kdump/include/asm-powerpc/kexec.h
===================================================================
--- linux-2.6.16-olh-kdump.orig/include/asm-powerpc/kexec.h
+++ linux-2.6.16-olh-kdump/include/asm-powerpc/kexec.h
@@ -31,9 +31,8 @@
 #define KEXEC_ARCH KEXEC_ARCH_PPC
 #endif
 
-#ifdef CONFIG_KEXEC
-
 #ifndef __ASSEMBLY__
+#ifdef CONFIG_KEXEC
 #ifdef __powerpc64__
 /*
  * This function is responsible for capturing register states if coming
@@ -114,6 +113,11 @@ extern void kexec_smp_wait(void);	/* get
 extern void __init kexec_setup(void);
 extern int crashing_cpu;
 extern void crash_send_ipi(void (*crash_ipi_callback)(struct pt_regs *));
+extern cpumask_t cpus_in_sr;
+static inline int kexec_sr_activated(int cpu)
+{
+	return cpu_isset(cpu,cpus_in_sr);
+}
 #endif /* __powerpc64 __ */
 
 struct kimage;
@@ -123,8 +127,14 @@ extern int default_machine_kexec_prepare
 extern void default_machine_crash_shutdown(struct pt_regs *regs);
 
 extern void machine_kexec_simple(struct kimage *image);
-
-#endif /* ! __ASSEMBLY__ */
+extern void crash_kexec_secondary(struct pt_regs *regs);
+#else
+static inline void crash_kexec_secondary(struct pt_regs *regs) { }
+static inline int kexec_sr_activated(int cpu)
+{
+	return 0;
+}
 #endif /* CONFIG_KEXEC */
+#endif /* ! __ASSEMBLY__ */
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_KEXEC_H */
Index: linux-2.6.16-olh-kdump/include/linux/kexec.h
===================================================================
--- linux-2.6.16-olh-kdump.orig/include/linux/kexec.h
+++ linux-2.6.16-olh-kdump/include/linux/kexec.h
@@ -106,6 +106,7 @@ extern struct page *kimage_alloc_control
 extern void crash_kexec(struct pt_regs *);
 int kexec_should_crash(struct task_struct *);
 extern struct kimage *kexec_image;
+extern struct kimage *kexec_crash_image;
 
 #define KEXEC_ON_CRASH  0x00000001
 #define KEXEC_ARCH_MASK 0xffff0000
