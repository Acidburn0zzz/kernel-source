From: Horst Hummel <horst.hummel@de.ibm.com>
Subject: ECKD dasd reporting invalid partition size.

  Description: dasd: Failing partition detection during device bring-up.
  Symptom:     Setting a device online either failing or leading to invalid
               (-24) partition size.
  Problem:     DASD allows to open a device as soon as gendisk is registered,
               which means the the device is a fake device (capacity=0) and we
               do know nothing about blocksize and partitions at that point of
               time.
               In case the device is opened by someone, the bdev and inode
               creation is done with the fake device info and the following
               partition detection code is just using these wrong data
               (capacity = 0 minus offset 24 leading to a partition size = -24).
  Solution:    Modify the DASD state machine to make sure that the open
               is rejected until the device analysis is either finished or
               a unformatted device was detected.
  Problem-ID:  21059
  Archs:       s390-31, s390-64

Signed-off-by: Hannes Reinecke <hare@suse.de

--- linux-2.5/drivers/s390/block/dasd.c	17 Feb 2006 16:38:33 -0000	1.173.2.3
+++ linux-2.5/drivers/s390/block/dasd.c	3 Mar 2006 14:04:15 -0000	1.173.2.4
@@ -219,9 +219,10 @@
  * interrupt for this detection ccw uses the kernel event daemon to
  * trigger the call to dasd_change_state. All this is done in the
  * discipline code, see dasd_eckd.c.
- * After the analysis ccw is done (do_analysis returned 0 or error)
- * the block device is setup. Either a fake disk is added to allow
- * formatting or a proper device request queue is created.
+ * After the analysis ccw is done (do_analysis returned 0) the block
+ * device is setup.
+ * In case the analysis returns an error, the device setup is stopped
+ * (a fake disk was already added to allow formatting).
  */
 static inline int
 dasd_state_basic_to_ready(struct dasd_device * device)
@@ -231,13 +232,19 @@
 	rc = 0;
 	if (device->discipline->do_analysis != NULL)
 		rc = device->discipline->do_analysis(device);
-	if (rc)
+	if (rc) {
+		if (rc != -EAGAIN)
+			device->state = DASD_STATE_UNFMT;
 		return rc;
+	}
+	/* make disk known with correct capacity */
 	dasd_setup_queue(device);
+	set_capacity(device->gdp, device->blocks << device->s2b_shift);
 	device->state = DASD_STATE_READY;
-	if (dasd_scan_partitions(device) != 0)
+	rc = dasd_scan_partitions(device);
+	if (rc)
 		device->state = DASD_STATE_BASIC;
-	return 0;
+	return rc;
 }
 
 /*
@@ -258,6 +265,15 @@
 }
 
 /*
+ * Back to basic.
+ */
+static inline void
+dasd_state_unfmt_to_basic(struct dasd_device * device)
+{
+	device->state = DASD_STATE_BASIC;
+}
+
+/*
  * Make the device online and schedule the bottom half to start
  * the requeueing of requests from the linux request queue to the
  * ccw queue.
@@ -323,8 +339,12 @@
 	if (device->state == DASD_STATE_READY &&
 	    device->target <= DASD_STATE_BASIC)
 		dasd_state_ready_to_basic(device);
-	
-	if (device->state == DASD_STATE_BASIC && 
+
+	if (device->state == DASD_STATE_UNFMT &&
+	    device->target <= DASD_STATE_BASIC)
+		dasd_state_unfmt_to_basic(device);
+
+	if (device->state == DASD_STATE_BASIC &&
 	    device->target <= DASD_STATE_KNOWN)
 		dasd_state_basic_to_known(device);
 	
@@ -1747,7 +1767,7 @@
 		goto out;
 	}
 
-	if (device->state < DASD_STATE_BASIC) {
+	if (device->state <= DASD_STATE_BASIC) {
 		DBF_DEV_EVENT(DBF_ERR, device, " %s",
 			      " Cannot open unrecognized device");
 		rc = -ENODEV;

--- linux-2.5/drivers/s390/block/dasd_genhd.c	2 Aug 2005 16:34:15 -0000	1.51
+++ linux-2.5/drivers/s390/block/dasd_genhd.c	3 Mar 2006 14:04:15 -0000	1.51.2.1
@@ -101,8 +101,6 @@
 {
 	struct block_device *bdev;
 
-	/* Make the disk known. */
-	set_capacity(device->gdp, device->blocks << device->s2b_shift);
 	bdev = bdget_disk(device->gdp, 0);
 	if (!bdev || blkdev_get(bdev, FMODE_READ, 1) < 0)
 		return -ENODEV;

--- linux-2.5/drivers/s390/block/dasd_int.h	17 Feb 2006 16:38:33 -0000	1.68.2.1
+++ linux-2.5/drivers/s390/block/dasd_int.h	3 Mar 2006 14:04:15 -0000	1.68.2.2
@@ -27,7 +27,7 @@
  *   new: the dasd_device structure is allocated.
  *   known: the discipline for the device is identified.
  *   basic: the device can do basic i/o.
- *   accept: the device is analysed (format is known).
+ *   unfmt: the device could not be analyzed (format is unknown).
  *   ready: partition detection is done and the device is can do block io.
  *   online: the device accepts requests from the block device queue.
  *
@@ -48,8 +48,9 @@
 #define DASD_STATE_NEW	  0
 #define DASD_STATE_KNOWN  1
 #define DASD_STATE_BASIC  2
-#define DASD_STATE_READY  3
-#define DASD_STATE_ONLINE 4
+#define DASD_STATE_UNFMT  3
+#define DASD_STATE_READY  4
+#define DASD_STATE_ONLINE 5
 
 #include <linux/module.h>
 #include <linux/wait.h>

--- linux-2.5/drivers/s390/block/dasd_proc.c	2 Aug 2005 16:34:15 -0000	1.33
+++ linux-2.5/drivers/s390/block/dasd_proc.c	3 Mar 2006 14:04:15 -0000	1.33.2.1
@@ -94,6 +94,9 @@
 	case DASD_STATE_BASIC:
 		seq_printf(m, "basic");
 		break;
+	case DASD_STATE_UNFMT:
+		seq_printf(m, "unformatted");
+		break;
 	case DASD_STATE_READY:
 	case DASD_STATE_ONLINE:
 		seq_printf(m, "active ");

--- linux-2.5/fs/partitions/ibm.c	2 Nov 2005 14:30:28 -0000	1.13
+++ linux-2.5/fs/partitions/ibm.c	3 Mar 2006 14:04:16 -0000	1.13.2.1
@@ -52,6 +52,7 @@
 ibm_partition(struct parsed_partitions *state, struct block_device *bdev)
 {
 	int blocksize, offset, size;
+	loff_t i_size;
 	dasd_information_t *info;
 	struct hd_geometry *geo;
 	char type[5] = {0,};
@@ -63,6 +64,13 @@
 	unsigned char *data;
 	Sector sect;
 
+	blocksize = bdev_hardsect_size(bdev);
+	if (blocksize <= 0)
+		return 0;
+	i_size = i_size_read(bdev->bd_inode);
+	if (i_size == 0)
+		return 0;
+
 	if ((info = kmalloc(sizeof(dasd_information_t), GFP_KERNEL)) == NULL)
 		goto out_noinfo;
 	if ((geo = kmalloc(sizeof(struct hd_geometry), GFP_KERNEL)) == NULL)
@@ -73,9 +81,6 @@
 	if (ioctl_by_bdev(bdev, BIODASDINFO, (unsigned long)info) != 0 ||
 	    ioctl_by_bdev(bdev, HDIO_GETGEO, (unsigned long)geo) != 0)
 		goto out_noioctl;
-	
-	if ((blocksize = bdev_hardsect_size(bdev)) <= 0)
-		goto out_badsect;
 
 	/*
 	 * Get volume label, extract name and type.
@@ -111,7 +116,7 @@
 		} else {
 			printk("CMS1/%8s:", name);
 			offset = (info->label_block + 1);
-			size = bdev->bd_inode->i_size >> 9;
+			size = i_size >> 9;
 		}
 		put_partition(state, 1, offset*(blocksize >> 9),
 				 size-offset*(blocksize >> 9));
@@ -168,7 +173,7 @@
 		else
 			printk("(nonl)/%8s:", name);
 		offset = (info->label_block + 1);
-		size = (bdev->bd_inode->i_size >> 9);
+		size = i_size >> 9;
 		put_partition(state, 1, offset*(blocksize >> 9),
 				 size-offset*(blocksize >> 9));
 	}
@@ -180,7 +185,6 @@
 	return 1;
 	
 out_readerr:
-out_badsect:
 out_noioctl:
 	kfree(label);
 out_nolab:

