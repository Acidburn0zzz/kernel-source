- Description: Fix for a Kernel panic in CTC driver related to irq_handler
  Sympton:     Kernel panic in CTC driver at the attempt to vary off/on for chipids
  Problem:     Interrupt handler missed checking error codes in irb
  Solution:    checking routine and call to it then exit with errorcode if appr.
  Problem-ID:  -
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/ctcmain.c	24 Mar 2004 10:51:56 -0000	1.58
+++ linux-2.5/drivers/s390/net/ctcmain.c	23 Apr 2004 16:15:16 -0000	1.58.2.1
@@ -1,5 +1,5 @@
 /*
- * $Id: ctcmain.c,v 1.58 2004/03/24 10:51:56 ptiedem Exp $
+ * $Id: ctcmain.c,v 1.58.2.1 2004/04/23 16:15:16 ptiedem Exp $
  *
  * CTC / ESCON network driver
  *
@@ -36,7 +36,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.58 $
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.58.2.1 $
  *
  */
 
@@ -319,7 +319,7 @@
 print_banner(void)
 {
 	static int printed = 0;
-	char vbuf[] = "$Revision: 1.58 $";
+	char vbuf[] = "$Revision: 1.58.2.1 $";
 	char *version = vbuf;
 
 	if (printed)
@@ -2045,6 +2045,32 @@
 	return ret;
 }
 
+static long
+__ctc_check_irb_error(struct ccw_device *cdev, struct irb *irb)
+{
+	if (!IS_ERR(irb))
+		return 0;
+
+	switch (PTR_ERR(irb)) {
+	case -EIO:
+		ctc_pr_warn("i/o-error on device %s\n", cdev->dev.bus_id);
+//		CTC_DBF_TEXT(trace, 2, "ckirberr");
+//		CTC_DBF_TEXT_(trace, 2, "  rc%d", -EIO);
+		break;
+	case -ETIMEDOUT:
+		ctc_pr_warn("timeout on device %s\n", cdev->dev.bus_id);
+//		CTC_DBF_TEXT(trace, 2, "ckirberr");
+//		CTC_DBF_TEXT_(trace, 2, "  rc%d", -ETIMEDOUT);
+		break;
+	default:
+		ctc_pr_warn("unknown error %ld on device %s\n", PTR_ERR(irb),
+			   cdev->dev.bus_id);
+//		CTC_DBF_TEXT(trace, 2, "ckirberr");
+//		CTC_DBF_TEXT(trace, 2, "  rc???");
+	}
+	return PTR_ERR(irb);
+}
+
 /**
  * Main IRQ handler.
  *
@@ -2058,6 +2084,9 @@
 	struct channel *ch;
 	struct net_device *dev;
 	struct ctc_priv *priv;
+
+	if (__ctc_check_irb_error(cdev, irb))
+		return;
 
 	/* Check for unsolicited interrupts. */
 	if (!cdev->dev.driver_data) {

