diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/defconfig linux-2.6.0test9-amd64/arch/x86_64/defconfig
--- linux-vanilla/arch/x86_64/defconfig	2003-09-28 10:54:53.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/defconfig	2003-10-25 23:18:39.000000000 +0200
@@ -59,7 +59,6 @@ CONFIG_X86_CPUID=y
 CONFIG_X86_IO_APIC=y
 CONFIG_X86_LOCAL_APIC=y
 CONFIG_MTRR=y
-# CONFIG_HUGETLB_PAGE is not set
 CONFIG_SMP=y
 # CONFIG_PREEMPT is not set
 CONFIG_K8_NUMA=y
@@ -79,9 +78,9 @@ CONFIG_SOFTWARE_SUSPEND=y
 #
 # ACPI (Advanced Configuration and Power Interface) Support
 #
-# CONFIG_ACPI_HT is not set
 CONFIG_ACPI=y
 CONFIG_ACPI_BOOT=y
+CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_SLEEP=y
 CONFIG_ACPI_SLEEP_PROC_FS=y
 CONFIG_ACPI_AC=y
@@ -94,11 +93,29 @@ CONFIG_ACPI_THERMAL=y
 CONFIG_ACPI_TOSHIBA=y
 CONFIG_ACPI_DEBUG=y
 CONFIG_ACPI_BUS=y
-CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_EC=y
 CONFIG_ACPI_POWER=y
 CONFIG_ACPI_PCI=y
 CONFIG_ACPI_SYSTEM=y
+CONFIG_ACPI_RELAXED_AML=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_PROC_INTF=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_24_API is not set
+CONFIG_CPU_FREQ_TABLE=y
+
+#
+# CPUFreq processor drivers
+#
+CONFIG_X86_POWERNOW_K8=y
 
 #
 # Bus options (PCI etc.)
@@ -246,6 +263,7 @@ CONFIG_BLK_DEV_SD=y
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -325,7 +343,9 @@ CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
-# CONFIG_LLC is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
 # CONFIG_NET_DIVERT is not set
@@ -358,7 +378,7 @@ CONFIG_NETDEVICES=y
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_NET_VENDOR_3COM is not set
@@ -388,7 +408,6 @@ CONFIG_8139TOO=m
 # CONFIG_SIS900 is not set
 # CONFIG_EPIC100 is not set
 # CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
 # CONFIG_VIA_RHINE is not set
 
 #
@@ -421,10 +440,10 @@ CONFIG_TIGON3=y
 # CONFIG_NET_RADIO is not set
 
 #
-# Token Ring devices (depends on LLC=y)
+# Token Ring devices
 #
+# CONFIG_TR is not set
 # CONFIG_NET_FC is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 
 #
@@ -443,6 +462,11 @@ CONFIG_TIGON3=y
 # CONFIG_IRDA is not set
 
 #
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
 # ISDN subsystem
 #
 # CONFIG_ISDN_BOOL is not set
@@ -485,6 +509,7 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_PS2_SYNAPTICS is not set
 # CONFIG_MOUSE_SERIAL is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
@@ -504,6 +529,7 @@ CONFIG_HW_CONSOLE=y
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
 # CONFIG_SERIAL_8250_ACPI is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
 # CONFIG_SERIAL_8250_EXTENDED is not set
 
 #
@@ -520,7 +546,11 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_I2C is not set
 
 #
-# I2C Hardware Sensors Mainboard support
+# I2C Algorithms
+#
+
+#
+# I2C Hardware Bus support
 #
 
 #
@@ -549,7 +579,6 @@ CONFIG_RTC=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
-# CONFIG_SONYPI is not set
 
 #
 # Ftape, the floppy tape device driver
@@ -559,6 +588,7 @@ CONFIG_AGP_AMD64=y
 # CONFIG_DRM is not set
 # CONFIG_MWAVE is not set
 CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=256
 CONFIG_HANGCHECK_TIMER=y
 
 #
@@ -619,10 +649,13 @@ CONFIG_ISO9660_FS=y
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
 # CONFIG_DEVFS_FS is not set
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
 
 #
@@ -647,6 +680,7 @@ CONFIG_RAMFS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
 # CONFIG_NFSD_V4 is not set
@@ -707,13 +741,15 @@ CONFIG_SOUND_PRIME=y
 # CONFIG_SOUND_MAESTRO is not set
 # CONFIG_SOUND_MAESTRO3 is not set
 CONFIG_SOUND_ICH=y
-# CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 # CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
 # CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
 # CONFIG_SOUND_ALI5455 is not set
 # CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_AD1980 is not set
 
 #
@@ -723,11 +759,6 @@ CONFIG_SOUND_ICH=y
 # CONFIG_USB_GADGET is not set
 
 #
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
 # Profiling support
 #
 CONFIG_PROFILING=y
@@ -760,4 +791,4 @@ CONFIG_MCE_DEBUG=y
 #
 # Library routines
 #
-# CONFIG_CRC32 is not set
+CONFIG_CRC32=y
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/ia32/syscall32.c linux-2.6.0test9-amd64/arch/x86_64/ia32/syscall32.c
--- linux-vanilla/arch/x86_64/ia32/syscall32.c	2003-08-23 01:57:17.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/ia32/syscall32.c	2003-10-25 23:19:43.000000000 +0200
@@ -30,10 +30,12 @@ char *syscall32_page; 
 int map_syscall32(struct mm_struct *mm, unsigned long address) 
 { 
 	pte_t *pte;
+	pmd_t *pmd;
 	int err = 0;
+
 	down_read(&mm->mmap_sem);
 	spin_lock(&mm->page_table_lock); 
-	pmd_t *pmd = pmd_alloc(mm, pgd_offset(mm, address), address); 
+	pmd = pmd_alloc(mm, pgd_offset(mm, address), address); 
 	if (pmd && (pte = pte_alloc_map(mm, pmd, address)) != NULL) { 
 		if (pte_none(*pte)) { 
 			set_pte(pte, 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/Makefile linux-2.6.0test9-amd64/arch/x86_64/kernel/Makefile
--- linux-vanilla/arch/x86_64/kernel/Makefile	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/Makefile	2003-10-26 00:31:52.000000000 +0200
@@ -18,13 +18,16 @@ obj-$(CONFIG_X86_LOCAL_APIC)	+= apic.o  
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o mpparse.o
 obj-$(CONFIG_PM)		+= suspend.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= suspend_asm.o
+obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_GART_IOMMU)	+= pci-gart.o aperture.o
 obj-$(CONFIG_DUMMY_IOMMU)	+= pci-nommu.o pci-dma.o
 
 obj-$(CONFIG_MODULES)		+= module.o
 
+obj-y				+= topology.o
+
 bootflag-y			+= ../../i386/kernel/bootflag.o
 cpuid-$(CONFIG_X86_CPUID)	+= ../../i386/kernel/cpuid.o
+topology-y                     += ../../i386/mach-default/topology.o
 
-obj-$(CONFIG_CPU_FREQ)	+=	cpufreq/
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/acpi/boot.c linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/boot.c
--- linux-vanilla/arch/x86_64/kernel/acpi/boot.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/boot.c	2003-10-25 23:39:20.000000000 +0200
@@ -251,6 +251,33 @@ acpi_parse_hpet (
 } 
 #endif
 
+#ifdef CONFIG_ACPI_BUS
+/*
+ * Set specified PIC IRQ to level triggered mode.
+ *
+ * Port 0x4d0-4d1 are ECLR1 and ECLR2, the Edge/Level Control Registers
+ * for the 8259 PIC.  bit[n] = 1 means irq[n] is Level, otherwise Edge.
+ * ECLR1 is IRQ's 0-7 (IRQ 0, 1, 2 must be 0)
+ * ECLR2 is IRQ's 8-15 (IRQ 8, 13 must be 0)
+ *
+ * As the BIOS should have done this for us,
+ * print a warning if the IRQ wasn't already set to level.
+ */
+
+void acpi_pic_set_level_irq(unsigned int irq)
+{
+	unsigned char mask = 1 << (irq & 7);
+	unsigned int port = 0x4d0 + (irq >> 3);
+	unsigned char val = inb(port);
+
+	if (!(val & mask)) {
+		printk(KERN_WARNING PREFIX "IRQ %d was Edge Triggered, "
+			"setting to Level Triggerd\n", irq);
+		outb(val | mask, port);
+	}
+}
+#endif /* CONFIG_ACPI_BUS */
+
 static unsigned long __init
 acpi_scan_rsdp (
 	unsigned long		start,
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/acpi/sleep.c linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/sleep.c
--- linux-vanilla/arch/x86_64/kernel/acpi/sleep.c	2003-08-23 01:51:42.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/sleep.c	2003-10-25 23:20:22.000000000 +0200
@@ -56,6 +56,7 @@
 
 /* address in low memory of the wakeup routine. */
 unsigned long acpi_wakeup_address = 0;
+unsigned long acpi_video_flags;
 extern char wakeup_start, wakeup_end;
 
 extern unsigned long FASTCALL(acpi_copy_wakeup_routine(unsigned long));
@@ -116,6 +117,22 @@ void __init acpi_reserve_bootmem(void)
 	printk(KERN_DEBUG "ACPI: have wakeup address 0x%8.8lx\n", acpi_wakeup_address);
 }
 
+static int __init acpi_sleep_setup(char *str)
+{
+	while ((str != NULL) && (*str != '\0')) {
+		if (strncmp(str, "s3_bios", 7) == 0)
+			acpi_video_flags = 1;
+		if (strncmp(str, "s3_mode", 7) == 0)
+			acpi_video_flags |= 2;
+		str = strchr(str, ',');
+		if (str != NULL)
+			str += strspn(str, ", \t");
+	}
+	return 1;
+}
+
+__setup("acpi_sleep=", acpi_sleep_setup);
+
 #endif /*CONFIG_ACPI_SLEEP*/
 
 void acpi_pci_link_exit(void) {}
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/acpi/wakeup.S linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/wakeup.S
--- linux-vanilla/arch/x86_64/kernel/acpi/wakeup.S	2003-08-23 01:57:53.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/wakeup.S	2003-10-25 23:20:58.000000000 +0200
@@ -41,7 +41,19 @@ wakeup_code:
 	cmpl	$0x12345678, %eax
 	jne	bogus_real_magic
 
+	testl	$1, video_flags - wakeup_code
+	jz	1f
 	lcall   $0xc000,$3
+	movw	%cs, %ax
+	movw	%ax, %ds					# Bios might have played with that
+	movw	%ax, %ss
+1:
+
+	testl	$2, video_flags - wakeup_code
+	jz	1f
+	mov	video_mode - wakeup_code, %ax
+	call	mode_seta
+1:
 
  	movw	$0xb800, %ax
 	movw	%ax,%fs
@@ -250,6 +262,7 @@ real_save_gdt:	.word 0
 		.quad 0
 real_magic:	.quad 0
 video_mode:	.quad 0
+video_flags:	.quad 0
 
 bogus_real_magic:
 	movb	$0xba,%al	;  outb %al,$0x80		
@@ -382,8 +395,10 @@ ENTRY(acpi_copy_wakeup_routine)
 	movl	%eax, saved_efer
 	movl	%edx, saved_efer2
 
-#	movq	saved_videomode, %rdx				# FIXME:	 videomode
-	movq	%rdx, video_mode - wakeup_start (,%rdi)
+	movl	saved_video_mode, %edx
+	movl	%edx, video_mode - wakeup_start (,%rdi)
+	movl	acpi_video_flags, %edx
+	movl	%edx, video_flags - wakeup_start (,%rdi)
 	movq	$0x12345678, real_magic - wakeup_start (,%rdi)
 	movq	$0x123456789abcdef0, %rdx
 	movq	%rdx, saved_magic
@@ -415,8 +430,6 @@ do_suspend_lowlevel:
 .LFB5:
 	subq	$8, %rsp
 .LCFI2:
-	testl	%edi, %edi
-	jne	.L99
 	xorl	%eax, %eax
 	call	save_processor_state
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/apic.c linux-2.6.0test9-amd64/arch/x86_64/kernel/apic.c
--- linux-vanilla/arch/x86_64/kernel/apic.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/apic.c	2003-10-25 23:20:58.000000000 +0200
@@ -42,6 +42,8 @@ static DEFINE_PER_CPU(int, prof_multipli
 static DEFINE_PER_CPU(int, prof_old_multiplier) = 1;
 static DEFINE_PER_CPU(int, prof_counter) = 1;
 
+static void apic_pm_activate(void);
+
 void enable_NMI_through_LVT0 (void * dummy)
 {
 	unsigned int v, ver;
@@ -435,6 +437,7 @@ void __init setup_local_APIC (void)
 
 	if (nmi_watchdog == NMI_LOCAL_APIC)
 		setup_apic_nmi_watchdog();
+	apic_pm_activate();
 }
 
 #ifdef CONFIG_PM
@@ -556,7 +559,7 @@ device_initcall(init_lapic_sysfs);
 
 #else	/* CONFIG_PM */
 
-static inline void apic_pm_activate(void) { }
+static void apic_pm_activate(void) { }
 
 #endif	/* CONFIG_PM */
 
@@ -579,7 +582,6 @@ static int __init detect_init_APIC (void
 	if (nmi_watchdog != NMI_NONE)
 		nmi_watchdog = NMI_LOCAL_APIC;
 
-	apic_pm_activate();
 	return 0;
 }
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/bluesmoke.c linux-2.6.0test9-amd64/arch/x86_64/kernel/bluesmoke.c
--- linux-vanilla/arch/x86_64/kernel/bluesmoke.c	2003-08-23 01:59:34.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/bluesmoke.c	2003-10-25 23:19:43.000000000 +0200
@@ -200,11 +200,14 @@ static char *highbits[32] = { 
 static void check_k8_nb(int header)
 {
 	struct pci_dev *nb;
+	u32 statuslow, statushigh;
+	unsigned short errcode;
+	int i;
+
 	nb = find_k8_nb(); 
 	if (nb == NULL)
 		return;
 
-	u32 statuslow, statushigh;
 	pci_read_config_dword(nb, 0x48, &statuslow);
 	pci_read_config_dword(nb, 0x4c, &statushigh);
 	if (!(statushigh & (1<<31)))
@@ -215,7 +218,7 @@ static void check_k8_nb(int header)
 	printk(KERN_ERR "Northbridge status %08x%08x\n",
 	       statushigh,statuslow); 
 
-	unsigned short errcode = statuslow & 0xffff;	
+	errcode = statuslow & 0xffff;	
 	switch (errcode >> 8) { 
 	case 0: 					
 		printk(KERN_ERR "    GART TLB error %s %s\n", 
@@ -249,7 +252,6 @@ static void check_k8_nb(int header)
 	/* should only print when it was a HyperTransport related error. */
 	printk(KERN_ERR "    link number %x\n", (statushigh >> 4) & 3);
 
-	int i;
 	for (i = 0; i < 32; i++) 
 		if (highbits[i] && (statushigh & (1<<i)))
 			printk(KERN_ERR "    %s\n", highbits[i]); 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/entry.S linux-2.6.0test9-amd64/arch/x86_64/kernel/entry.S
--- linux-vanilla/arch/x86_64/kernel/entry.S	2003-09-28 10:54:54.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/entry.S	2003-10-26 01:52:02.000000000 +0200
@@ -566,8 +566,14 @@ error_kernelspace:
 	incl %ebx
        /* There are two places in the kernel that can potentially fault with
           usergs. Handle them here. The exception handlers after
-	  iret run with kernel gs again, so don't set the user space flag. */
-	cmpq $iret_label,RIP(%rsp) 
+	   iret run with kernel gs again, so don't set the user space flag.
+	   B stepping K8s sometimes report an truncated RIP for IRET 
+	   exceptions returning to compat mode. Check for these here too. */
+	leaq iret_label(%rip),%rbp
+	cmpq %rbp,RIP(%rsp) 
+	je   error_swapgs
+	movl %ebp,%ebp	/* zero extend */
+	cmpq %rbp,RIP(%rsp) 
 	je   error_swapgs
 	cmpq $gs_change,RIP(%rsp)
         je   error_swapgs
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/io_apic.c linux-2.6.0test9-amd64/arch/x86_64/kernel/io_apic.c
--- linux-vanilla/arch/x86_64/kernel/io_apic.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/io_apic.c	2003-10-25 23:40:46.000000000 +0200
@@ -622,11 +622,13 @@ static inline int IO_APIC_irq_trigger(in
 	return 0;
 }
 
-int irq_vector[NR_IRQS] = { FIRST_DEVICE_VECTOR , 0 };
+/* irq_vectors is indexed by the sum of all RTEs in all I/O APICs. */
+u8 irq_vector[NR_IRQ_VECTORS] = { FIRST_DEVICE_VECTOR , 0 };
 
 static int __init assign_irq_vector(int irq)
 {
 	static int current_vector = FIRST_DEVICE_VECTOR, offset = 0;
+	BUG_ON(irq >= NR_IRQ_VECTORS);
 	if (IO_APIC_VECTOR(irq) > 0)
 		return IO_APIC_VECTOR(irq);
 next:
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/setup.c linux-2.6.0test9-amd64/arch/x86_64/kernel/setup.c
--- linux-vanilla/arch/x86_64/kernel/setup.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/setup.c	2003-10-25 23:19:43.000000000 +0200
@@ -332,6 +332,7 @@ __setup("noreplacement", noreplacement_s
 void __init setup_arch(char **cmdline_p)
 {
 	unsigned long low_mem_size;
+	unsigned long kernel_end;
 
  	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
  	drive_info = DRIVE_INFO;
@@ -380,7 +381,6 @@ void __init setup_arch(char **cmdline_p)
 				(table_end - table_start) << PAGE_SHIFT);
 
 	/* reserve kernel */
-	unsigned long kernel_end;
 	kernel_end = round_up(__pa_symbol(&_end),PAGE_SIZE);
 	reserve_bootmem_generic(HIGH_MEMORY, kernel_end - HIGH_MEMORY);
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/setup64.c linux-2.6.0test9-amd64/arch/x86_64/kernel/setup64.c
--- linux-vanilla/arch/x86_64/kernel/setup64.c	2003-08-23 01:53:44.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/setup64.c	2003-10-26 00:18:46.000000000 +0200
@@ -189,8 +189,7 @@ void pda_init(int cpu)
 	pda->irqstackptr += IRQSTACKSIZE-64;
 } 
 
-#define EXCEPTION_STK_ORDER 0 /* >= N_EXCEPTION_STACKS*EXCEPTION_STKSZ */
-char boot_exception_stacks[N_EXCEPTION_STACKS*EXCEPTION_STKSZ];
+char boot_exception_stacks[N_EXCEPTION_STACKS * EXCEPTION_STKSZ];
 
 void syscall_init(void)
 {
@@ -226,15 +225,12 @@ void __init cpu_init (void)
 #endif
 	struct tss_struct * t = &init_tss[cpu];
 	unsigned long v, efer; 
-	char *estacks; 
+	char *estacks = NULL; 
 	struct task_struct *me;
 
 	/* CPU 0 is initialised in head64.c */
 	if (cpu != 0) {
 		pda_init(cpu);
-		estacks = (char *)__get_free_pages(GFP_ATOMIC, 0); 
-		if (!estacks)
-			panic("Can't allocate exception stacks for CPU %d\n",cpu);
 	} else 
 		estacks = boot_exception_stacks; 
 
@@ -282,10 +278,15 @@ void __init cpu_init (void)
 	/*
 	 * set up and load the per-CPU TSS
 	 */
-	estacks += EXCEPTION_STKSZ;
 	for (v = 0; v < N_EXCEPTION_STACKS; v++) {
-		t->ist[v] = (unsigned long)estacks;
+		if (cpu) {
+			estacks = (char *)__get_free_pages(GFP_ATOMIC, 0);
+			if (!estacks)
+				panic("Cannot allocate exception stack %ld %d\n",
+				      v, cpu); 
+		}
 		estacks += EXCEPTION_STKSZ;
+		t->ist[v] = (unsigned long)estacks;
 	}
 
 	t->io_bitmap_base = INVALID_IO_BITMAP_OFFSET;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/smp.c linux-2.6.0test9-amd64/arch/x86_64/kernel/smp.c
--- linux-vanilla/arch/x86_64/kernel/smp.c	2003-08-23 01:53:15.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/smp.c	2003-10-25 23:35:55.000000000 +0200
@@ -487,25 +487,3 @@ asmlinkage void smp_call_function_interr
 		atomic_inc(&call_data->finished);
 	}
 }
-
-/* Slow. Should be only used for debugging. */
-int slow_smp_processor_id(void)
-{ 
-	int stack_location;
-	unsigned long sp = (unsigned long)&stack_location; 
-	int offset = 0, cpu;
-
-	for (offset = 0; next_cpu(offset, cpu_online_map) < NR_CPUS; offset = cpu + 1) {
-		cpu = next_cpu(offset, cpu_online_map);
-
-		if (sp >= (u64)cpu_pda[cpu].irqstackptr - IRQSTACKSIZE && 
-		    sp <= (u64)cpu_pda[cpu].irqstackptr)
-			return cpu;
-
-		unsigned long estack = init_tss[cpu].ist[0] - EXCEPTION_STKSZ;
-		if (sp >= estack && sp <= estack+(1<<(PAGE_SHIFT+EXCEPTION_STK_ORDER)))
-			return cpu;			
-	}
-
-	return stack_smp_processor_id();
-} 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/smpboot.c linux-2.6.0test9-amd64/arch/x86_64/kernel/smpboot.c
--- linux-vanilla/arch/x86_64/kernel/smpboot.c	2003-09-23 08:03:38.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/smpboot.c	2003-10-26 00:26:29.000000000 +0200
@@ -54,7 +54,7 @@
 #include <asm/proto.h>
 
 /* Bitmask of currently online CPUs */
-cpumask_t cpu_online_map;
+cpumask_t cpu_online_map = { 1 };
 
 static cpumask_t cpu_callin_map;
 cpumask_t cpu_callout_map;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/time.c linux-2.6.0test9-amd64/arch/x86_64/kernel/time.c
--- linux-vanilla/arch/x86_64/kernel/time.c	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/time.c	2003-10-26 01:20:04.000000000 +0200
@@ -111,6 +111,14 @@ void do_gettimeofday(struct timeval *tv)
 		sec = xtime.tv_sec;
 		usec = xtime.tv_nsec / 1000;
 
+		/*
+		 * If time_adjust is negative then NTP is slowing the clock
+		 * so make sure not to go into next possible interval.
+		 * Better to lose some accuracy than have time go backwards..
+		 */
+		if (unlikely(time_adjust < 0) && usec > tickadj)
+			usec = tickadj;
+
 		t = (jiffies - wall_jiffies) * (1000000L / HZ) +
 			do_gettimeoffset();
 		usec += t;
@@ -477,22 +485,28 @@ unsigned long get_cmos_time(void)
 static unsigned int  ref_freq = 0;
 static unsigned long loops_per_jiffy_ref = 0;
 
-//static unsigned long fast_gettimeoffset_ref = 0;
 static unsigned long cpu_khz_ref = 0;
 
 static int time_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
 				 void *data)
 {
         struct cpufreq_freqs *freq = data;
+	unsigned long *lpj;
+
+#ifdef CONFIG_SMP
+	lpj = &cpu_data[freq->cpu].loops_per_jiffy;
+#else
+	lpj = &boot_cpu_data.loops_per_jiffy;
+#endif
 
 	if (!ref_freq) {
 		ref_freq = freq->old;
-		loops_per_jiffy_ref = cpu_data[freq->cpu].loops_per_jiffy;
+		loops_per_jiffy_ref = *lpj;
 		cpu_khz_ref = cpu_khz;
 	}
         if ((val == CPUFREQ_PRECHANGE  && freq->old < freq->new) ||
             (val == CPUFREQ_POSTCHANGE && freq->old > freq->new)) {
-                cpu_data[freq->cpu].loops_per_jiffy =
+                *lpj =
 		cpufreq_scale(loops_per_jiffy_ref, ref_freq, freq->new);
 
 		cpu_khz = cpufreq_scale(cpu_khz_ref, ref_freq, freq->new);
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/x8664_ksyms.c linux-2.6.0test9-amd64/arch/x86_64/kernel/x8664_ksyms.c
--- linux-vanilla/arch/x86_64/kernel/x8664_ksyms.c	2003-08-23 01:52:53.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/x8664_ksyms.c	2003-10-25 23:19:06.000000000 +0200
@@ -153,7 +153,7 @@ EXPORT_SYMBOL_GPL(unset_nmi_callback);
 
 extern void * memset(void *,int,__kernel_size_t);
 extern size_t strlen(const char *);
-extern char * bcopy(const char * src, char * dest, int count);
+extern void bcopy(const char * src, char * dest, int count);
 extern void * memmove(void * dest,const void *src,size_t count);
 extern char * strcpy(char * dest,const char *src);
 extern int strcmp(const char * cs,const char * ct);
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/extable.c linux-2.6.0test9-amd64/arch/x86_64/mm/extable.c
--- linux-vanilla/arch/x86_64/mm/extable.c	2003-08-23 02:00:23.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/mm/extable.c	2003-10-26 01:46:51.000000000 +0200
@@ -14,6 +14,10 @@ search_extable(const struct exception_ta
 	       const struct exception_table_entry *last,
 	       unsigned long value)
 {
+	/* Work around a B stepping K8 bug */
+	if ((value >> 32) == 0)
+		value |= 0xffffffffUL << 32; 
+
         while (first <= last) {
 		const struct exception_table_entry *mid;
 		long diff;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/k8topology.c linux-2.6.0test9-amd64/arch/x86_64/mm/k8topology.c
--- linux-vanilla/arch/x86_64/mm/k8topology.c	2003-08-23 02:01:50.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/mm/k8topology.c	2003-10-26 00:58:20.000000000 +0200
@@ -164,5 +164,8 @@ int __init k8_scan_nodes(unsigned long s
 		rr++; 
 	}
 
+	if (found == 1) 
+		fake_node = 1;
+
 	return 0;
 } 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/numa.c linux-2.6.0test9-amd64/arch/x86_64/mm/numa.c
--- linux-vanilla/arch/x86_64/mm/numa.c	2003-08-23 01:58:49.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/mm/numa.c	2003-10-25 23:36:21.000000000 +0200
@@ -104,6 +104,7 @@ void __init setup_node_bootmem(int nodei
 	if (nodeid + 1 > numnodes)
 		numnodes = nodeid + 1;
 	nodes_present |= (1UL << nodeid); 
+	node_set_online(nodeid);
 } 
 
 /* Initialize final allocator for a zone */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/apic.h linux-2.6.0test9-amd64/include/asm-x86_64/apic.h
--- linux-vanilla/include/asm-x86_64/apic.h	2003-08-23 01:59:29.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/apic.h	2003-10-25 23:57:51.000000000 +0200
@@ -79,7 +79,7 @@ extern void disable_lapic_nmi_watchdog(v
 extern void enable_lapic_nmi_watchdog(void);
 extern void disable_timer_nmi_watchdog(void);
 extern void enable_timer_nmi_watchdog(void);
-extern inline void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
+extern void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
 extern int APIC_init_uniprocessor (void);
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/cpu.h linux-2.6.0test9-amd64/include/asm-x86_64/cpu.h
--- linux-vanilla/include/asm-x86_64/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test9-amd64/include/asm-x86_64/cpu.h	2003-10-25 23:37:40.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/cpu.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/desc.h linux-2.6.0test9-amd64/include/asm-x86_64/desc.h
--- linux-vanilla/include/asm-x86_64/desc.h	2003-09-28 10:55:14.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/desc.h	2003-10-25 23:06:51.000000000 +0200
@@ -190,7 +190,7 @@ static inline void load_TLS(struct threa
 /*
  * load one particular LDT into the current CPU
  */
-extern inline void load_LDT_nolock (mm_context_t *pc, int cpu)
+static inline void load_LDT_nolock (mm_context_t *pc, int cpu)
 {
 	int count = pc->size;
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/fixmap.h linux-2.6.0test9-amd64/include/asm-x86_64/fixmap.h
--- linux-vanilla/include/asm-x86_64/fixmap.h	2003-08-23 01:52:59.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/fixmap.h	2003-10-25 23:06:51.000000000 +0200
@@ -76,7 +76,7 @@ extern void __this_fixmap_does_not_exist
  * directly without translation, we catch the bug with a NULL-deference
  * kernel oops. Illegal ranges of incoming indices are caught too.
  */
-extern inline unsigned long fix_to_virt(const unsigned int idx)
+static inline unsigned long fix_to_virt(const unsigned int idx)
 {
 	/*
 	 * this branch gets completely eliminated after inlining,
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/hw_irq.h linux-2.6.0test9-amd64/include/asm-x86_64/hw_irq.h
--- linux-vanilla/include/asm-x86_64/hw_irq.h	2003-08-23 02:01:37.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/hw_irq.h	2003-10-25 23:52:47.000000000 +0200
@@ -76,8 +76,8 @@ struct hw_interrupt_type;
 
 
 #ifndef __ASSEMBLY__
-extern int irq_vector[NR_IRQS];
-#define IO_APIC_VECTOR(irq)	irq_vector[irq]
+extern u8 irq_vector[NR_IRQ_VECTORS];
+#define IO_APIC_VECTOR(irq)	((int)irq_vector[irq])
 
 /*
  * Various low-level irq details needed by irq.c, process.c,
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/io.h linux-2.6.0test9-amd64/include/asm-x86_64/io.h
--- linux-vanilla/include/asm-x86_64/io.h	2003-08-23 01:54:34.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/io.h	2003-10-25 23:06:51.000000000 +0200
@@ -52,7 +52,7 @@
  * Talk about misusing macros..
  */
 #define __OUT1(s,x) \
-extern inline void out##s(unsigned x value, unsigned short port) {
+static inline void out##s(unsigned x value, unsigned short port) {
 
 #define __OUT2(s,s1,s2) \
 __asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
@@ -62,7 +62,7 @@ __OUT1(s,x) __OUT2(s,s1,"w") : : "a" (va
 __OUT1(s##_p,x) __OUT2(s,s1,"w") __FULL_SLOW_DOWN_IO : : "a" (value), "Nd" (port));} \
 
 #define __IN1(s) \
-extern inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
+static inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
 
 #define __IN2(s,s1,s2) \
 __asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
@@ -72,12 +72,12 @@ __IN1(s) __IN2(s,s1,"w") : "=a" (_v) : "
 __IN1(s##_p) __IN2(s,s1,"w") __FULL_SLOW_DOWN_IO : "=a" (_v) : "Nd" (port) ,##i ); return _v; } \
 
 #define __INS(s) \
-extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+static inline void ins##s(unsigned short port, void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; ins" #s \
 : "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
 #define __OUTS(s) \
-extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+static inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; outs" #s \
 : "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
@@ -125,12 +125,12 @@ __OUTS(l)
  * Change virtual addresses to physical addresses and vv.
  * These are pretty trivial
  */
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 	return __pa(address);
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
 	return __va(address);
 }
@@ -148,7 +148,7 @@ extern inline void * phys_to_virt(unsign
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap (unsigned long offset, unsigned long size)
+static inline void * ioremap (unsigned long offset, unsigned long size)
 {
 	return __ioremap(offset, size, 0);
 }
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/irq.h linux-2.6.0test9-amd64/include/asm-x86_64/irq.h
--- linux-vanilla/include/asm-x86_64/irq.h	2003-08-23 01:50:19.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/irq.h	2003-10-25 23:53:28.000000000 +0200
@@ -22,6 +22,7 @@
  * the usable vector space is 0x20-0xff (224 vectors)
  */
 #define NR_IRQS 224
+#define NR_IRQ_VECTORS NR_IRQS
 
 static __inline__ int irq_canonicalize(int irq)
 {
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/memblk.h linux-2.6.0test9-amd64/include/asm-x86_64/memblk.h
--- linux-vanilla/include/asm-x86_64/memblk.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test9-amd64/include/asm-x86_64/memblk.h	2003-10-25 23:38:01.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/memblk.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/msr.h linux-2.6.0test9-amd64/include/asm-x86_64/msr.h
--- linux-vanilla/include/asm-x86_64/msr.h	2003-08-23 01:59:52.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/msr.h	2003-10-25 23:06:51.000000000 +0200
@@ -67,7 +67,7 @@
 			  : "=a" (low), "=d" (high) \
 			  : "c" (counter))
 
-extern inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
+static inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
 {
 	__asm__("cpuid"
 		: "=a" (*eax),
@@ -80,7 +80,7 @@ extern inline void cpuid(int op, int *ea
 /*
  * CPUID functions returning a single datum
  */
-extern inline unsigned int cpuid_eax(unsigned int op)
+static inline unsigned int cpuid_eax(unsigned int op)
 {
 	unsigned int eax;
 
@@ -90,7 +90,7 @@ extern inline unsigned int cpuid_eax(uns
 		: "bx", "cx", "dx");
 	return eax;
 }
-extern inline unsigned int cpuid_ebx(unsigned int op)
+static inline unsigned int cpuid_ebx(unsigned int op)
 {
 	unsigned int eax, ebx;
 
@@ -100,7 +100,7 @@ extern inline unsigned int cpuid_ebx(uns
 		: "cx", "dx" );
 	return ebx;
 }
-extern inline unsigned int cpuid_ecx(unsigned int op)
+static inline unsigned int cpuid_ecx(unsigned int op)
 {
 	unsigned int eax, ecx;
 
@@ -110,7 +110,7 @@ extern inline unsigned int cpuid_ecx(uns
 		: "bx", "dx" );
 	return ecx;
 }
-extern inline unsigned int cpuid_edx(unsigned int op)
+static inline unsigned int cpuid_edx(unsigned int op)
 {
 	unsigned int eax, edx;
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/node.h linux-2.6.0test9-amd64/include/asm-x86_64/node.h
--- linux-vanilla/include/asm-x86_64/node.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test9-amd64/include/asm-x86_64/node.h	2003-10-25 23:38:16.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/node.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pci.h linux-2.6.0test9-amd64/include/asm-x86_64/pci.h
--- linux-vanilla/include/asm-x86_64/pci.h	2003-08-23 01:54:57.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/pci.h	2003-10-25 23:53:53.000000000 +0200
@@ -24,6 +24,8 @@ extern unsigned long pci_mem_start;
 #define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		(pci_mem_start)
 
+#define PCIBIOS_MIN_CARDBUS_IO	0x4000
+
 void pcibios_config_init(void);
 struct pci_bus * pcibios_scan_root(int bus);
 extern int (*pci_config_read)(int seg, int bus, int dev, int fn, int reg, int len, u32 *value);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pgalloc.h linux-2.6.0test9-amd64/include/asm-x86_64/pgalloc.h
--- linux-vanilla/include/asm-x86_64/pgalloc.h	2003-08-23 01:56:24.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/pgalloc.h	2003-10-25 23:06:51.000000000 +0200
@@ -69,7 +69,7 @@ extern __inline__ void pte_free_kernel(p
 	free_page((unsigned long)pte); 
 }
 
-extern inline void pte_free(struct page *pte)
+static inline void pte_free(struct page *pte)
 {
 	__free_page(pte);
 } 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pgtable.h linux-2.6.0test9-amd64/include/asm-x86_64/pgtable.h
--- linux-vanilla/include/asm-x86_64/pgtable.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/pgtable.h	2003-10-25 23:06:51.000000000 +0200
@@ -71,7 +71,7 @@ extern unsigned long empty_zero_page[102
 #define pml4_none(x)	(!pml4_val(x))
 #define pgd_none(x)	(!pgd_val(x))
 
-extern inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
+static inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
 
 static inline void set_pte(pte_t *dst, pte_t val)
 {
@@ -88,7 +88,7 @@ static inline void set_pgd(pgd_t *dst, p
 	pgd_val(*dst) = pgd_val(val); 
 } 
 
-extern inline void pgd_clear (pgd_t * pgd)
+static inline void pgd_clear (pgd_t * pgd)
 {
 	set_pgd(pgd, __pgd(0));
 }
@@ -242,23 +242,23 @@ static inline pte_t pfn_pte(unsigned lon
  * Undefined behaviour if not..
  */
 static inline int pte_user(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
-extern inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
+static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
 static inline int pte_file(pte_t pte)		{ return pte_val(pte) & _PAGE_FILE; }
 
-extern inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
+static inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
 static inline  int ptep_test_and_clear_dirty(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_DIRTY, ptep); }
 static inline  int ptep_test_and_clear_young(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep); }
 static inline void ptep_set_wrprotect(pte_t *ptep)		{ clear_bit(_PAGE_BIT_RW, ptep); }
@@ -359,7 +359,7 @@ static inline pte_t mk_pte_phys(unsigned
 }
  
 /* Change flags of a PTE */
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 { 
 	pte_val(pte) &= _PAGE_CHG_MASK;
 	pte_val(pte) |= pgprot_val(newprot);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/processor.h linux-2.6.0test9-amd64/include/asm-x86_64/processor.h
--- linux-vanilla/include/asm-x86_64/processor.h	2003-09-28 10:55:14.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/processor.h	2003-10-26 00:18:46.000000000 +0200
@@ -263,8 +263,8 @@ struct thread_struct {
 #define DOUBLEFAULT_STACK 2 
 #define NMI_STACK 3 
 #define N_EXCEPTION_STACKS 3  /* hw limit: 7 */
-#define EXCEPTION_STKSZ 1024
-#define EXCEPTION_STK_ORDER 0
+#define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
+#define EXCEPTION_STACK_ORDER 0 
 
 #define start_thread(regs,new_rip,new_rsp) do { \
 	asm volatile("movl %0,%%fs; movl %0,%%es; movl %0,%%ds": :"r" (0));	 \
@@ -304,13 +304,13 @@ extern unsigned long get_wchan(struct ta
 #define KSTK_ESP(tsk) -1 /* sorry. doesn't work for syscall. */
 
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
-extern inline void rep_nop(void)
+static inline void rep_nop(void)
 {
 	__asm__ __volatile__("rep;nop": : :"memory");
 }
 
 /* Stop speculative execution */
-extern inline void sync_core(void)
+static inline void sync_core(void)
 { 
 	int tmp;
 	asm volatile("cpuid" : "=a" (tmp) : "0" (1) : "ebx","ecx","edx","memory");
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/smp.h linux-2.6.0test9-amd64/include/asm-x86_64/smp.h
--- linux-vanilla/include/asm-x86_64/smp.h	2003-09-23 08:03:57.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/smp.h	2003-10-25 23:35:35.000000000 +0200
@@ -74,15 +74,7 @@ extern __inline int hard_smp_processor_i
 	return GET_APIC_ID(*(unsigned int *)(APIC_BASE+APIC_ID));
 }
 
-extern int slow_smp_processor_id(void);
-
-extern inline int safe_smp_processor_id(void)
-{ 
-	if (disable_apic)
-		return slow_smp_processor_id(); 
-	else
-		return hard_smp_processor_id();
-} 
+#define safe_smp_processor_id() (cpuid_ebx(1) >> 24) 
 
 #define cpu_online(cpu) cpu_isset(cpu, cpu_online_map)
 #endif /* !ASSEMBLY */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/system.h linux-2.6.0test9-amd64/include/asm-x86_64/system.h
--- linux-vanilla/include/asm-x86_64/system.h	2003-09-23 08:03:57.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/system.h	2003-10-25 23:06:51.000000000 +0200
@@ -188,7 +188,7 @@ static inline void write_cr4(unsigned lo
 
 #define __xg(x) ((volatile long *)(x))
 
-extern inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
+static inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
 {
 	*ptr = val;
 }
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/topology.h linux-2.6.0test9-amd64/include/asm-x86_64/topology.h
--- linux-vanilla/include/asm-x86_64/topology.h	2003-09-23 08:03:57.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/topology.h	2003-10-26 02:10:39.000000000 +0200
@@ -10,13 +10,15 @@
 /* Map the K8 CPU local memory controllers to a simple 1:1 CPU:NODE topology */
 
 extern int fake_node;
+/* This is actually a cpumask_t, but doesn't matter because we don't have
+   >BITS_PER_LONG CPUs */
 extern unsigned long cpu_online_map;
 
 #define cpu_to_node(cpu)		(fake_node ? 0 : (cpu))
 #define memblk_to_node(memblk) 	(fake_node ? 0 : (memblk))
 #define parent_node(node)		(node)
 #define node_to_first_cpu(node) 	(fake_node ? 0 : (node))
-#define node_to_cpu_mask(node)	(fake_node ? cpu_online_map : (1UL << (node)))
+#define node_to_cpumask(node)	(fake_node ? cpu_online_map : (1UL << (node)))
 #define node_to_memblk(node)		(node)
 
 static inline unsigned long pcibus_to_cpumask(int bus)
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/uaccess.h linux-2.6.0test9-amd64/include/asm-x86_64/uaccess.h
--- linux-vanilla/include/asm-x86_64/uaccess.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/uaccess.h	2003-10-25 23:06:51.000000000 +0200
@@ -48,7 +48,7 @@
 
 #define access_ok(type,addr,size) (__range_not_ok(addr,size) == 0)
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size) ? 0 : -EFAULT;
 }
