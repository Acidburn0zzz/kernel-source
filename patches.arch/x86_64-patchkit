diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/ia32/ia32_binfmt.c linux-2.5-merge/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.5/arch/x86_64/ia32/ia32_binfmt.c	2004-02-28 05:36:54.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/ia32/ia32_binfmt.c	2004-02-25 17:06:01.000000000 +0100
@@ -398,3 +398,26 @@ elf32_map (struct file *filep, unsigned 
 	return(map_addr);
 }
 
+#ifdef CONFIG_SYSCTL
+/* Register vsyscall32 into the ABI table */
+#include <linux/sysctl.h>
+
+static ctl_table abi_table2[] = {
+	{ 99, "vsyscall32", &sysctl_vsyscall32, sizeof(int), 0644, NULL,
+	  proc_dointvec },
+	{ 0, }
+}; 
+
+static ctl_table abi_root_table2[] = { 
+	{ .ctl_name = CTL_ABI, .procname = "abi", .mode = 0555, 
+	  .child = abi_table2 }, 
+	{ 0 }, 
+}; 
+
+static __init int ia32_binfmt_init(void)
+{ 
+	register_sysctl_table(abi_root_table2, 1);
+	return 0;
+}
+__initcall(ia32_binfmt_init);
+#endif
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/ia32/ia32_ioctl.c linux-2.5-merge/arch/x86_64/ia32/ia32_ioctl.c
--- linux-2.5/arch/x86_64/ia32/ia32_ioctl.c	2004-01-24 05:41:20.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/ia32/ia32_ioctl.c	2004-02-25 17:06:01.000000000 +0100
@@ -175,16 +175,6 @@ COMPATIBLE_IOCTL(BLKRASET)
 COMPATIBLE_IOCTL(BLKFRASET)
 COMPATIBLE_IOCTL(0x4B50)   /* KDGHWCLK - not in the kernel, but don't complain */
 COMPATIBLE_IOCTL(0x4B51)   /* KDSHWCLK - not in the kernel, but don't complain */
-#ifdef CONFIG_AUTOFS_FS
-COMPATIBLE_IOCTL(AUTOFS_IOC_READY)
-COMPATIBLE_IOCTL(AUTOFS_IOC_FAIL)
-COMPATIBLE_IOCTL(AUTOFS_IOC_CATATONIC)
-COMPATIBLE_IOCTL(AUTOFS_IOC_PROTOVER)
-COMPATIBLE_IOCTL(AUTOFS_IOC_SETTIMEOUT)
-COMPATIBLE_IOCTL(AUTOFS_IOC_EXPIRE)
-COMPATIBLE_IOCTL(AUTOFS_IOC_EXPIRE_MULTI)
-#endif
-#ifdef CONFIG_RTC
 COMPATIBLE_IOCTL(RTC_AIE_ON)
 COMPATIBLE_IOCTL(RTC_AIE_OFF)
 COMPATIBLE_IOCTL(RTC_UIE_ON)
@@ -199,7 +189,6 @@ COMPATIBLE_IOCTL(RTC_RD_TIME)
 COMPATIBLE_IOCTL(RTC_SET_TIME)
 COMPATIBLE_IOCTL(RTC_WKALM_SET)
 COMPATIBLE_IOCTL(RTC_WKALM_RD)
-#endif
 COMPATIBLE_IOCTL(HCIUARTSETPROTO)
 COMPATIBLE_IOCTL(HCIUARTGETPROTO)
 COMPATIBLE_IOCTL(RFCOMMCREATEDEV)
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/ia32/Makefile linux-2.5-merge/arch/x86_64/ia32/Makefile
--- linux-2.5/arch/x86_64/ia32/Makefile	2004-01-24 05:41:20.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/ia32/Makefile	2004-02-25 17:06:01.000000000 +0100
@@ -4,7 +4,10 @@
 
 obj-$(CONFIG_IA32_EMULATION) := ia32entry.o sys_ia32.o ia32_ioctl.o \
 	ia32_signal.o tls32.o \
-	ia32_binfmt.o fpu32.o ptrace32.o ipc32.o syscall32.o
+	ia32_binfmt.o fpu32.o ptrace32.o syscall32.o
+
+sysv-$(CONFIG_SYSVIPC) := ipc32.o
+obj-$(CONFIG_IA32_EMULATION) += $(sysv-y)
 
 obj-$(CONFIG_IA32_AOUT) += ia32_aout.o
 
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/ia32/sys_ia32.c linux-2.5-merge/arch/x86_64/ia32/sys_ia32.c
--- linux-2.5/arch/x86_64/ia32/sys_ia32.c	2004-02-28 05:36:54.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/ia32/sys_ia32.c	2004-02-25 17:06:01.000000000 +0100
@@ -1930,6 +1930,8 @@ long sys32_quotactl(void)
 	return -ENOSYS;
 } 
 
+cond_syscall(sys32_ipc)
+
 struct exec_domain ia32_exec_domain = { 
 	.name = "linux/x86",
 	.pers_low = PER_LINUX32,
Binary files linux-2.5/arch/x86_64/ia32/vsyscall.so and linux-2.5-merge/arch/x86_64/ia32/vsyscall.so differ
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/Kconfig linux-2.5-merge/arch/x86_64/Kconfig
--- linux-2.5/arch/x86_64/Kconfig	2004-02-28 05:36:53.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/Kconfig	2004-02-25 17:06:01.000000000 +0100
@@ -14,7 +14,8 @@ config X86_64
 	default y
 	help
 	  Port to the x86-64 architecture. x86-64 is a 64-bit extension to the
-	  classical 32-bit x86 architecture. For details see http://www.x86-64.org
+	  classical 32-bit x86 architecture. For details see
+	  <http://www.x86-64.org/>.
 
 config 64BIT
 	def_bool y
@@ -92,7 +93,10 @@ config MK8
 	  Optimize for AMD Opteron/Athlon64/Hammer/K8 CPUs. 
 
 config MPSC
-       bool "Prescott/Nocona" 
+       bool "Intel x86-64" 
+       help
+	  Optimize for Intel IA32 with 64bit extension CPUs
+	  (Prescott/Nocona/Potomac)
        
 config GENERIC_CPU
 	bool "Generic-x86-64"
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/aperture.c linux-2.5-merge/arch/x86_64/kernel/aperture.c
--- linux-2.5/arch/x86_64/kernel/aperture.c	2004-02-20 05:01:22.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/aperture.c	2004-02-25 17:06:01.000000000 +0100
@@ -208,7 +208,7 @@ void __init iommu_hole_init(void) 
 		if (read_pci_config(0, num, 3, 0x00) != NB_ID_3) 
 			continue;	
 
-		iommu_aperture = 1;; 
+		iommu_aperture = 1; 
 
 		aper_order = (read_pci_config(0, num, 3, 0x90) >> 1) & 7; 
 		aper_size = (32 * 1024 * 1024) << aper_order; 
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/apic.c linux-2.5-merge/arch/x86_64/kernel/apic.c
--- linux-2.5/arch/x86_64/kernel/apic.c	2004-01-24 05:41:20.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/apic.c	2004-02-25 17:06:01.000000000 +0100
@@ -435,6 +435,7 @@ void __init setup_local_APIC (void)
 			printk("No ESR for 82489DX.\n");
 	}
 
+	nmi_watchdog_default();
 	if (nmi_watchdog == NMI_LOCAL_APIC)
 		setup_apic_nmi_watchdog();
 	apic_pm_activate();
@@ -579,9 +580,6 @@ static int __init detect_init_APIC (void
 
 	mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
 	boot_cpu_id = 0;
-	if (nmi_watchdog != NMI_NONE)
-		nmi_watchdog = NMI_LOCAL_APIC;
-
 	return 0;
 }
 
@@ -646,11 +644,13 @@ void __init init_apic_mappings(void)
 
 void __setup_APIC_LVTT(unsigned int clocks)
 {
-	unsigned int lvtt1_value, tmp_value;
+	unsigned int lvtt_value, tmp_value, ver;
 
-	lvtt1_value = SET_APIC_TIMER_BASE(APIC_TIMER_BASE_DIV) |
-			APIC_LVT_TIMER_PERIODIC | LOCAL_TIMER_VECTOR;
-	apic_write_around(APIC_LVTT, lvtt1_value);
+	ver = GET_APIC_VERSION(apic_read(APIC_LVR));
+	lvtt_value = APIC_LVT_TIMER_PERIODIC | LOCAL_TIMER_VECTOR;
+	if (!APIC_INTEGRATED(ver))
+		lvtt_value |= SET_APIC_TIMER_BASE(APIC_TIMER_BASE_DIV);
+	apic_write_around(APIC_LVTT, lvtt_value);
 
 	/*
 	 * Divide PICLK by 16
@@ -994,8 +994,6 @@ int __init APIC_init_uniprocessor (void)
 
 	setup_local_APIC();
 
-	if (nmi_watchdog == NMI_LOCAL_APIC)
-		check_nmi_watchdog();
 #ifdef CONFIG_X86_IO_APIC
 	if (smp_found_config && !skip_ioapic_setup && nr_ioapics)
 			setup_IO_APIC();
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/bluesmoke.c linux-2.5-merge/arch/x86_64/kernel/bluesmoke.c
--- linux-2.5/arch/x86_64/kernel/bluesmoke.c	2004-01-24 05:41:20.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/bluesmoke.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,473 +0,0 @@
-/*
- * Machine check handler.
- * K8 parts Copyright 2002,2003 Andi Kleen, SuSE Labs.
- * Rest from unknown author(s). 
- */
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/string.h>
-#include <linux/ctype.h>
-#include <asm/processor.h> 
-#include <asm/msr.h>
-#include <asm/kdebug.h>
-#include <linux/pci.h>
-#include <linux/timer.h>
-
-static int mce_disabled __initdata;
-static unsigned long mce_cpus; 
-
-/*
- *	Machine Check Handler For PII/PIII/K7
- */
-
-static int banks;
-static unsigned long ignored_banks, disabled_banks;
-
-static void generic_machine_check(struct pt_regs * regs, long error_code)
-{
-	int recover=1;
-	u32 alow, ahigh, high, low;
-	u32 mcgstl, mcgsth;
-	int i;
-
-	preempt_disable();
-
-	rdmsr(MSR_IA32_MCG_STATUS, mcgstl, mcgsth);
-	if(mcgstl&(1<<0))	/* Recoverable ? */
-		recover=0;
-
-	printk(KERN_EMERG "CPU %d: Machine Check Exception: %08x%08x\n", smp_processor_id(), mcgsth, mcgstl);
-	
-	if (regs && (mcgstl & 2))
-		printk(KERN_EMERG "RIP <%02lx>:%016lx RSP %016lx\n", 
-		       regs->cs, regs->rip, regs->rsp); 
-
-	for(i=0;i<banks;i++)
-	{
-		if ((1UL<<i) & ignored_banks) 
-			continue; 
-
-		rdmsr(MSR_IA32_MC0_STATUS+i*4,low, high);
-		if(high&(1<<31))
-		{
-			if(high&(1<<29))
-				recover|=1;
-			if(high&(1<<25))
-				recover|=2;
-			printk(KERN_EMERG "Bank %d: %08x%08x", i, high, low);
-			high&=~(1<<31);
-			if(high&(1<<27))
-			{
-				rdmsr(MSR_IA32_MC0_MISC+i*4, alow, ahigh);
-				printk("[%08x%08x]", alow, ahigh);
-			}
-			if(high&(1<<26))
-			{
-				rdmsr(MSR_IA32_MC0_ADDR+i*4, alow, ahigh);
-				printk(" at %08x%08x", 
-					ahigh, alow);
-			}
-			printk("\n");
-			/* Clear it */
-			wrmsr(MSR_IA32_MC0_STATUS+i*4, 0UL, 0UL);
-			/* Serialize */
-			wmb();
-		}
-	}
-
-	if(recover&2)
-		panic("CPU context corrupt");
-	if(recover&1)
-		panic("Unable to continue");
-	printk(KERN_EMERG "Attempting to continue.\n");
-	mcgstl&=~(1<<2);
-	wrmsr(MSR_IA32_MCG_STATUS,mcgstl, mcgsth);
-
-	preempt_enable();
-}
-
-static void unexpected_machine_check(struct pt_regs *regs, long error_code)
-{	
-	printk("unexpected machine check %lx\n", error_code); 
-}
-
-/*
- *	Call the installed machine check handler for this CPU setup.
- */
-
-static void (*machine_check_vector)(struct pt_regs *, long error_code) = unexpected_machine_check;
-
-void do_machine_check(struct pt_regs * regs, long error_code)
-{
-	notify_die(DIE_NMI, "machine check", regs, error_code, 255, SIGKILL);
-	machine_check_vector(regs, error_code);
-}
-
-/* 
- *	K8 machine check.
- */
-
-static struct pci_dev *find_k8_nb(void)
-{ 
-	struct pci_dev *dev = NULL;
-	int cpu = smp_processor_id(); 
-	while ((dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, dev)) != NULL) {
-		if (dev->bus->number==0 && PCI_SLOT(dev->devfn) == (24U+cpu))
-			return dev;
-	}
-	return NULL;
-}
-
-/* When we have kallsyms we can afford kmcedecode too. */
-
-static char *transaction[] = { 
-	"instruction", "data", "generic", "reserved"
-}; 
-static char *cachelevel[] = { 
-	"level 0", "level 1", "level 2", "level generic"
-};
-static char *memtrans[] = { 
-	"generic error", "generic read", "generic write", "data read",
-	"data write", "instruction fetch", "prefetch", "snoop",
-	"?", "?", "?", "?", "?", "?", "?"
-};
-static char *partproc[] = { 
-	"local node origin", "local node response", 
-	"local node observed", "generic" 
-};
-static char *timeout[] = { 
-	"request didn't time out",
-	"request timed out"
-};
-static char *memoryio[] = { 
-	"memory access", "res.", "i/o access", "generic"
-}; 
-static char *extendederr[] = { 
-	"ecc error", 
-	"crc error",
-	"sync error",
-	"mst abort",
-	"tgt abort",
-	"gart error",
-	"rmw error",
-	"wdog error",
-	"chipkill ecc error", 
-	"<9>","<10>","<11>","<12>",
-	"<13>","<14>","<15>"
-}; 
-static char *highbits[32] = { 
-	[31] = "previous error lost", 
-	[30] = "error overflow",
-	[29] = "error uncorrected",
-	[28] = "error enable",
-	[27] = "misc error valid",
-	[26] = "error address valid", 
-	[25] = "processor context corrupt", 
-	[24] = "res24",
-	[23] = "res23",
-	/* 22-15 ecc syndrome bits */
-	[14] = "corrected ecc error",
-	[13] = "uncorrected ecc error",
-	[12] = "res12",
-	[11] = "res11",
-	[10] = "res10",
-	[9] = "res9",
-	[8] = "dram scrub error", 
-	[7] = "res7",
-	/* 6-4 ht link number of error */ 
-	[3] = "res3",
-	[2] = "res2",
-	[1] = "err cpu0",
-	[0] = "err cpu1",
-};
-
-static void check_k8_nb(int header)
-{
-	struct pci_dev *nb;
-	u32 statuslow, statushigh;
-	unsigned short errcode;
-	int i;
-
-	nb = find_k8_nb(); 
-	if (nb == NULL)
-		return;
-
-	pci_read_config_dword(nb, 0x48, &statuslow);
-	pci_read_config_dword(nb, 0x4c, &statushigh);
-	if (!(statushigh & (1<<31)))
-		return;
-	if (header)
-		printk(KERN_ERR "CPU %d: Silent Northbridge MCE\n", smp_processor_id());
-
-	printk(KERN_ERR "Northbridge status %08x%08x\n",
-	       statushigh,statuslow); 
-
-	printk(KERN_ERR "    Error %s\n", extendederr[(statuslow >> 16) & 0xf]); 
-
-	errcode = statuslow & 0xffff;	
-	switch ((statuslow >> 16) & 0xF) { 
-	case 5: 					
-		printk(KERN_ERR "    GART TLB error %s %s\n", 
-		       transaction[(errcode >> 2) & 3], 
-		       cachelevel[errcode & 3]);
-		break;
-	case 8:
-		printk(KERN_ERR "    ECC error syndrome %x\n", 
-		       (((statuslow >> 24) & 0xff)  << 8) | ((statushigh >> 15) & 0x7f));		
-		/*FALL THROUGH*/
-	default:
-		printk(KERN_ERR "    bus error %s, %s\n    %s\n    %s, %s\n",
-		       partproc[(errcode >> 9) & 0x3],
-		       timeout[(errcode >> 8) & 1],
-			       memtrans[(errcode >> 4) & 0xf],
-			       memoryio[(errcode >> 2) & 0x3], 
-			       cachelevel[(errcode & 0x3)]); 
-	/* should only print when it was a HyperTransport related error. */
-	printk(KERN_ERR "    link number %x\n", (statushigh >> 4) & 3);
- 		break;
-	} 
-
-	for (i = 0; i < 32; i++) {
-		if (i == 26 || i == 28) 
-			continue;
-		if (highbits[i] && (statushigh & (1<<i)))
-			printk(KERN_ERR "    %s\n", highbits[i]); 
-	}
-	if (statushigh & (1<<26)) { 
-		u32 addrhigh, addrlow; 
-		pci_read_config_dword(nb, 0x54, &addrhigh); 
-		pci_read_config_dword(nb, 0x50, &addrlow); 
-		printk(KERN_ERR "    NB error address %08x%08x\n", addrhigh,addrlow); 
-	}
-	statushigh &= ~(1<<31); 
-	pci_write_config_dword(nb, 0x4c, statushigh); 		
-}
-
-static void k8_machine_check(struct pt_regs * regs, long error_code)
-{ 
-	u64 status, nbstatus;
-
-	preempt_disable();
-
-	rdmsrl(MSR_IA32_MCG_STATUS, status); 
-	if ((status & (1<<2)) == 0) { 
-		if (!regs) 
-			check_k8_nb(1);
-		return; 
-		}
-
-	printk(KERN_EMERG "CPU %d: Machine Check Exception: %016Lx\n", smp_processor_id(), status);
-
-	if (status & 1)
-		printk(KERN_EMERG "MCG_STATUS: unrecoverable\n"); 
-
-	rdmsrl(MSR_IA32_MC0_STATUS+4*4, nbstatus); 
-	if ((nbstatus & (1UL<<63)) == 0)
-		goto others; 
-	
-	printk(KERN_EMERG "Northbridge Machine Check %s %016lx %lx\n", 
-	       regs ? "exception" : "timer",
-	       (unsigned long)nbstatus, error_code); 
-	if (nbstatus & (1UL<<62))
-		printk(KERN_EMERG "Lost at least one NB error condition\n"); 	
-	if (nbstatus & (1UL<<61))
-		printk(KERN_EMERG "Uncorrectable condition\n"); 
-	if (nbstatus & (1UL<57))
-		printk(KERN_EMERG "Unrecoverable condition\n"); 
-		
-	check_k8_nb(0);
-
-	if (nbstatus & (1UL<<58)) { 
-		u64 adr;
-		rdmsrl(MSR_IA32_MC0_ADDR+4*4, adr);
-		printk(KERN_EMERG "Address: %016lx\n", (unsigned long)adr);
-	}
-	
-	wrmsrl(MSR_IA32_MC0_STATUS+4*4, 0); 
-	wrmsrl(MSR_IA32_MCG_STATUS, 0);
-       
- others:
-	generic_machine_check(regs, error_code); 
-
-	preempt_enable();
-} 
-
-static struct timer_list mcheck_timer;
-int mcheck_interval = 30*HZ; 
-
-#ifndef CONFIG_SMP 
-static void mcheck_timer_handler(unsigned long data)
-{
-	k8_machine_check(NULL,0);
-	mcheck_timer.expires = jiffies + mcheck_interval;
-	add_timer(&mcheck_timer);
-}
-#else
-
-/* SMP needs a process context trampoline because smp_call_function cannot be 
-   called from interrupt context. */
-
-static void mcheck_timer_other(void *data)
-{ 
-	k8_machine_check(NULL, 0); 
-} 
-
-static void mcheck_timer_dist(void *data)
-{
-	smp_call_function(mcheck_timer_other,0,0,0);
-	k8_machine_check(NULL, 0); 
-	mcheck_timer.expires = jiffies + mcheck_interval;
-	add_timer(&mcheck_timer);
-} 
-
-static void mcheck_timer_handler(unsigned long data)
-{ 
-	static DECLARE_WORK(mcheck_work, mcheck_timer_dist, NULL);
-	schedule_work(&mcheck_work); 
-}
-#endif
-
-static int nok8 __initdata; 
-
-static void __init k8_mcheck_init(struct cpuinfo_x86 *c)
-{
-	u64 cap;
-	int i;
-
-	if (!test_bit(X86_FEATURE_MCE, &c->x86_capability) || 
-	    !test_bit(X86_FEATURE_MCA, &c->x86_capability))
-		return; 
-
-	rdmsrl(MSR_IA32_MCG_CAP, cap); 
-	banks = cap&0xff; 
-	machine_check_vector = k8_machine_check; 
-	for (i = 0; i < banks; i++) { 
-		u64 val = ((1UL<<i) & disabled_banks) ? 0 : ~0UL; 
-		wrmsrl(MSR_IA32_MC0_CTL+4*i, val);
-		wrmsrl(MSR_IA32_MC0_STATUS+4*i,0); 
-	}
-
-	if (cap & (1<<8))
-		wrmsrl(MSR_IA32_MCG_CTL, 0xffffffffffffffffULL);
-
-	set_in_cr4(X86_CR4_MCE);	   	
-
-	if (mcheck_interval && (smp_processor_id() == 0)) { 
-		init_timer(&mcheck_timer); 
-		mcheck_timer.function = (void (*)(unsigned long))mcheck_timer_handler; 
-		mcheck_timer.expires = jiffies + mcheck_interval; 
-		add_timer(&mcheck_timer); 
-	} 
-	
-	printk(KERN_INFO "Machine Check Reporting enabled for CPU#%d\n", smp_processor_id()); 
-} 
-
-/*
- *	Set up machine check reporting for Intel processors
- */
-
-static void __init generic_mcheck_init(struct cpuinfo_x86 *c)
-{
-	u32 l, h;
-	int i;
-	static int done;
-	
-	/*
-	 *	Check for MCE support
-	 */
-
-	if( !test_bit(X86_FEATURE_MCE, &c->x86_capability) )
-		return;	
-
-	/*
-	 *	Check for PPro style MCA
-	 */
-	 		
-	if( !test_bit(X86_FEATURE_MCA, &c->x86_capability) )
-		return;
-
-	/* Ok machine check is available */
-	
-	machine_check_vector = generic_machine_check;
-	wmb();
-
-	if(done==0)
-		printk(KERN_INFO "Intel machine check architecture supported.\n");
-	rdmsr(MSR_IA32_MCG_CAP, l, h);
-	if(l&(1<<8))
-		wrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);
-	banks = l&0xff;
-
-	for(i=0;i<banks;i++)
-	{
-		u32 val = ((1UL<<i) & disabled_banks) ? 0 : ~0;
-		wrmsr(MSR_IA32_MC0_CTL+4*i, val, val);
-		wrmsr(MSR_IA32_MC0_STATUS+4*i, 0x0, 0x0);
-	}
-	set_in_cr4(X86_CR4_MCE);
-	printk(KERN_INFO "Intel machine check reporting enabled on CPU#%d.\n", smp_processor_id());
-	done=1;
-}
-
-/*
- *	This has to be run for each processor
- */
-
-void __init mcheck_init(struct cpuinfo_x86 *c)
-{
-	if (test_and_set_bit(smp_processor_id(), &mce_cpus))
-		return; 
-
-	if(mce_disabled==1)
-		return;
-
-	switch(c->x86_vendor) {
-		case X86_VENDOR_AMD:
-		if (c->x86 == 15 && !nok8) {
-			k8_mcheck_init(c); 
-			break;
-		}
-		/* FALL THROUGH */
-		default:
-	case X86_VENDOR_INTEL:
-		generic_mcheck_init(c);
-			break;
-	}
-}
-
-static int __init mcheck_disable(char *str)
-{
-	mce_disabled = 1;
-	return 0;
-}
-
-
-/* mce=off disable machine check
-   mce=nok8 disable k8 specific features
-   mce=disable<NUMBER> disable bank NUMBER
-   mce=enable<NUMBER> enable bank number
-   mce=NUMBER mcheck timer interval number seconds. 
-   Can be also comma separated in a single mce= */
-static int __init mcheck_enable(char *str)
-{
-	char *p;
-	while ((p = strsep(&str,",")) != NULL) { 
-		if (isdigit(*p))
-			mcheck_interval = simple_strtol(p,NULL,0) * HZ; 
-		else if (!strcmp(p,"off"))
-			mce_disabled = 1; 
-		else if (!strncmp(p,"enable",6))
-			disabled_banks &= ~(1<<simple_strtol(p+6,NULL,0));
-		else if (!strncmp(p,"disable",7))
-			disabled_banks |= ~(1<<simple_strtol(p+7,NULL,0));
-		else if (!strcmp(p,"nok8"))
-			nok8 = 1;
-	}
-	return 0;
-}
-
-__setup("nomce", mcheck_disable);
-__setup("mce", mcheck_enable);
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/cpufreq/Kconfig linux-2.5-merge/arch/x86_64/kernel/cpufreq/Kconfig
--- linux-2.5/arch/x86_64/kernel/cpufreq/Kconfig	2003-10-07 00:15:45.000000000 +0200
+++ linux-2.5-merge/arch/x86_64/kernel/cpufreq/Kconfig	2004-02-25 17:06:01.000000000 +0100
@@ -11,8 +11,8 @@ config CPU_FREQ
 	  fly. This is a nice method to save battery power on notebooks,
 	  because the lower the clock speed, the less power the CPU consumes.
 
-	  For more information, take a look at linux/Documentation/cpu-freq or
-	  at <http://www.brodo.de/cpufreq/>
+	  For more information, take a look at <file:Documentation/cpu-freq/>
+	  or at <http://www.codemonkey.org.uk/projects/cpufreq/>
 
 	  If in doubt, say N.
 
@@ -37,7 +37,7 @@ config X86_POWERNOW_K8
 	help
 	  This adds the CPUFreq driver for mobile AMD Opteron/Athlon64 processors.
 
-	  For details, take a look at linux/Documentation/cpu-freq. 
+	  For details, take a look at <file:Documentation/cpu-freq/>. 
 
 	  If in doubt, say N.
 
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/head.S linux-2.5-merge/arch/x86_64/kernel/head.S
--- linux-2.5/arch/x86_64/kernel/head.S	2004-02-28 05:36:54.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/head.S	2004-02-25 17:06:01.000000000 +0100
@@ -341,7 +341,7 @@ gdt32_end:	
 	
 ENTRY(cpu_gdt_table)
 	.quad	0x0000000000000000	/* NULL descriptor */
-	.quad	0x00af9a000000ffff ^ (1<<21)	/* __KERNEL_COMPAT32_CS */	
+	.quad	0x008f9a000000ffff	/* __KERNEL_COMPAT32_CS */	
 	.quad	0x00af9a000000ffff	/* __KERNEL_CS */
 	.quad	0x00cf92000000ffff	/* __KERNEL_DS */
 	.quad	0x00cffe000000ffff	/* __USER32_CS */
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/io_apic.c linux-2.5-merge/arch/x86_64/kernel/io_apic.c
--- linux-2.5/arch/x86_64/kernel/io_apic.c	2004-02-20 05:01:22.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/io_apic.c	2004-02-25 17:06:01.000000000 +0100
@@ -1653,6 +1653,7 @@ static inline void check_timer(void)
 		 */
 		unmask_IO_APIC_irq(0);
 		if (timer_irq_works()) {
+			nmi_watchdog_default();
 			if (nmi_watchdog == NMI_IO_APIC) {
 				disable_8259A_irq(0);
 				setup_nmi();
@@ -1674,6 +1675,7 @@ static inline void check_timer(void)
 		setup_ExtINT_IRQ0_pin(pin2, vector);
 		if (timer_irq_works()) {
 			printk("works.\n");
+			nmi_watchdog_default();
 			if (nmi_watchdog == NMI_IO_APIC) {
 				setup_nmi();
 				check_nmi_watchdog();
@@ -1759,23 +1761,6 @@ void __init setup_IO_APIC(void)
 		print_IO_APIC();
 }
 
-/* Ensure the ACPI SCI interrupt level is active low, edge-triggered */
-
-void __init mp_config_ioapic_for_sci(int irq)
-{
-#if 0 /* fixme */
-       int ioapic;
-       int ioapic_pin;
-
-       ioapic = mp_find_ioapic(irq);
-
-       ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
-
-       io_apic_set_pci_routing(ioapic, ioapic_pin, irq);
-#endif
-}
-
-
 /* --------------------------------------------------------------------------
                           ACPI-based IOAPIC Configuration
    -------------------------------------------------------------------------- */
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/Makefile linux-2.5-merge/arch/x86_64/kernel/Makefile
--- linux-2.5/arch/x86_64/kernel/Makefile	2004-02-28 05:36:54.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/Makefile	2004-02-25 17:06:01.000000000 +0100
@@ -7,7 +7,8 @@ EXTRA_AFLAGS	:= -traditional
 obj-y	:= process.o semaphore.o signal.o entry.o traps.o irq.o \
 		ptrace.o i8259.o ioport.o ldt.o setup.o time.o sys_x86_64.o \
 		x8664_ksyms.o i387.o syscall.o vsyscall.o \
-		setup64.o bluesmoke.o bootflag.o e820.o reboot.o warmreboot.o
+		setup64.o bootflag.o e820.o reboot.o warmreboot.o
+obj-y += mce.o
 
 obj-$(CONFIG_MTRR)		+= ../../i386/kernel/cpu/mtrr/
 obj-$(CONFIG_ACPI)		+= acpi/
@@ -33,4 +34,4 @@ bootflag-y			+= ../../i386/kernel/bootfl
 cpuid-$(subst m,y,$(CONFIG_X86_CPUID))  += ../../i386/kernel/cpuid.o
 topology-y                     += ../../i386/mach-default/topology.o
 swiotlb-$(CONFIG_SWIOTLB)      += ../../ia64/lib/swiotlb.o
-microcode-$(subst m,y,$(CONFIG_X86_CPUID))  += ../../i386/kernel/microcode.o
+microcode-$(subst m,y,$(CONFIG_MICROCODE))  += ../../i386/kernel/microcode.o
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/mce.c linux-2.5-merge/arch/x86_64/kernel/mce.c
--- linux-2.5/arch/x86_64/kernel/mce.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/mce.c	2004-02-25 17:06:01.000000000 +0100
@@ -0,0 +1,463 @@
+/*
+ * Machine check handler.
+ * K8 parts Copyright 2002,2003 Andi Kleen, SuSE Labs.
+ * Rest from unknown author(s). 
+ * 2004 Andi Kleen. Rewrote most of it. 
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/rcupdate.h>
+#include <linux/kallsyms.h>
+#include <linux/sysdev.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <asm/processor.h> 
+#include <asm/msr.h>
+#include <asm/mce.h>
+#include <asm/kdebug.h>
+#include <asm/uaccess.h>
+
+#define MISC_MCELOG_MINOR 227
+
+static int mce_disabled __initdata;
+/* 0: always panic, 1: panic if deadlock possible, 2: try to avoid panic */ 
+static int tolerant = 2;
+static int banks;
+static unsigned long disabled_banks;
+
+/*
+ * Lockless MCE logging infrastructure.
+ * This avoids deadlocks on printk locks without having to break locks. Also
+ * separate MCEs from kernel messages to avoid bogus bug reports.
+ */
+
+struct mce_log mcelog = { 
+	MCE_LOG_SIGNATURE,
+	MCE_LOG_LEN,
+}; 
+
+static void mce_log(struct mce *mce)
+{
+	unsigned next, entry;
+	mce->finished = 0;
+	smp_wmb();
+	for (;;) {
+		entry = mcelog.next;
+		read_barrier_depends();
+		/* When the buffer fills up discard new entries. Assume 
+		   that the earlier errors are the more interesting. */
+		if (entry >= MCE_LOG_LEN) {
+			set_bit(MCE_OVERFLOW, &mcelog.flags);
+			return;
+		}
+		/* Old left over entry. Skip. */
+		if (mcelog.entry[entry].finished)
+			continue;
+		smp_rmb();
+		next = entry + 1;
+		if (cmpxchg(&mcelog.next, entry, next) == entry)
+			break;
+	}
+	memcpy(mcelog.entry + entry, mce, sizeof(struct mce));
+	smp_wmb();
+	mcelog.entry[entry].finished = 1;
+	smp_wmb();
+}
+
+static void print_mce(struct mce *m)
+{
+	printk("CPU %d: Machine Check Exception: %16Lx Bank %d: %016Lx\n",
+	       m->cpu, m->mcgstatus, m->bank, m->status);
+	if (m->rip) {
+		printk("RIP %02x:<%016Lx> ", m->cs, m->rip);
+		if (m->cs == __KERNEL_CS)
+			print_symbol("{%s}", m->rip);
+		printk("\n");
+	}
+	printk("TSC %Lx ", m->tsc); 
+	if (m->addr)
+		printk("ADDR %Lx ", m->addr);
+	if (m->misc)
+		printk("MISC %Lx ", m->addr); 	
+	printk("\n");
+}
+
+static void mce_panic(char *msg, struct mce *backup, unsigned long start)
+{ 
+	int i;
+	oops_begin();
+	for (i = 0; i < MCE_LOG_LEN; i++) {
+		if (mcelog.entry[i].tsc < start)
+			continue;
+		print_mce(&mcelog.entry[i]); 
+		if (mcelog.entry[i].tsc == backup->tsc)
+			backup = NULL;
+	}
+	if (backup)
+		print_mce(backup);
+	panic(msg);
+} 
+
+static int mce_available(struct cpuinfo_x86 *c)
+{
+	return !mce_disabled && 
+		test_bit(X86_FEATURE_MCE, &c->x86_capability) &&
+		test_bit(X86_FEATURE_MCA, &c->x86_capability);
+}
+
+/* 
+ * The actual machine check handler
+ */
+
+void do_machine_check(struct pt_regs * regs, long error_code)
+{
+	struct mce m;
+	int nowayout = 0;
+	int kill_it = 0;
+	u64 mcestart;
+	int i;
+
+	if (regs)
+		notify_die(DIE_NMI, "machine check", regs, error_code, 255, SIGKILL);
+	if (!banks)
+		return;
+
+	memset(&m, 0, sizeof(struct mce));
+	m.cpu = hard_smp_processor_id();
+	rdmsrl(MSR_IA32_MCG_STATUS, m.mcgstatus);
+	if (!regs && (m.mcgstatus & MCG_STATUS_MCIP))
+		return;
+	if (!(m.mcgstatus & MCG_STATUS_RIPV))
+		kill_it = 1;
+	if (regs && (m.mcgstatus & MCG_STATUS_EIPV)) {
+		m.rip = regs->rip;
+		m.cs = regs->cs;
+	}
+	
+	rdtscll(mcestart);
+	mb();
+
+	for (i = 0; i < banks; i++) {
+		if (test_bit(i, &disabled_banks))
+			continue;
+
+		rdmsrl(MSR_IA32_MC0_STATUS + i*4, m.status);
+		if ((m.status & MCI_STATUS_VAL) == 0)
+			continue;
+
+		nowayout |= (tolerant < 1); 
+		nowayout |= !!(m.status & (MCI_STATUS_OVER|MCI_STATUS_PCC));
+		kill_it |= !!(m.status & MCI_STATUS_UC);
+		m.bank = i;
+
+		if (m.status & MCI_STATUS_MISCV)
+			rdmsrl(MSR_IA32_MC0_MISC + i*4, m.misc);
+		if (m.status & MCI_STATUS_ADDRV)
+			rdmsrl(MSR_IA32_MC0_MISC + i*4, m.addr);
+
+		rdtscll(m.tsc);
+		wrmsrl(MSR_IA32_MC0_STATUS + i*4, 0);
+		mce_log(&m);
+	}
+	wrmsrl(MSR_IA32_MCG_STATUS, 0);
+
+	/* Never do anything final in the polling timer */
+	if (!regs)
+		return;
+	if (nowayout)
+		mce_panic("Machine check", &m, mcestart);
+	if (kill_it) {
+		int user_space = (m.rip && (m.cs & 3));
+		
+		/* When the machine was in user space and the CPU didn't get
+		   confused it's normally not necessary to panic, unless you are 
+		   paranoid (tolerant == 0) */ 
+		if (!user_space && (panic_on_oops || tolerant < 2))
+			mce_panic("Uncorrected machine check in kernel", &m, mcestart);
+
+		/* do_exit takes an awful lot of locks and has as slight risk 
+		   of deadlocking. If you don't want that don't set tolerant >= 2 */
+		do_exit(SIGBUS);
+	}
+}
+
+static void mce_clear_all(void)
+{
+	int i;
+	for (i = 0; i < banks; i++)
+		wrmsrl(MSR_IA32_MC0_STATUS + i*4, 0);
+	wrmsrl(MSR_IA32_MCG_STATUS, 0);
+}
+
+/*
+ * Periodic polling timer for "silent" machine check errors.
+ */
+
+static int check_interval = 3600; /* one hour */
+static void mcheck_timer(void *data);
+static DECLARE_WORK(mcheck_work, mcheck_timer, NULL);
+
+static void mcheck_check_cpu(void *info)
+{
+	if (mce_available(&current_cpu_data))
+		do_machine_check(NULL, 0);
+}
+
+static void mcheck_timer(void *data)
+{
+	on_each_cpu(mcheck_check_cpu, NULL, 1, 1);
+	schedule_delayed_work(&mcheck_work, check_interval * HZ);
+}
+
+
+static __init int periodic_mcheck_init(void)
+{ 
+	if (check_interval)
+		schedule_delayed_work(&mcheck_work, check_interval*HZ);
+	return 0;
+} 
+__initcall(periodic_mcheck_init);
+
+
+/* 
+ * Initialize Machine Checks for a CPU.
+ */
+static void mce_init(void *dummy)
+{
+	u64 cap;
+	int i;
+
+	rdmsrl(MSR_IA32_MCG_CAP, cap);
+	if (cap & MCG_CTL_P)
+		wrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);
+
+	banks = cap & 0xff;
+
+	mce_clear_all(); 
+	for (i = 0; i < banks; i++) {
+		u64 val = test_bit(i, &disabled_banks) ? 0 : ~0UL;
+		wrmsrl(MSR_IA32_MC0_CTL+4*i, val);
+		wrmsrl(MSR_IA32_MC0_STATUS+4*i, 0);
+	}	
+
+	set_in_cr4(X86_CR4_MCE);
+}
+
+/* 
+ * Called for each booted CPU to set up machine checks.
+ * Must be called with preempt off. 
+ */
+void __init mcheck_init(struct cpuinfo_x86 *c)
+{
+	static unsigned long mce_cpus __initdata = 0;
+
+	if (test_and_set_bit(smp_processor_id(), &mce_cpus) || !mce_available(c))
+		return;
+
+	mce_init(NULL);
+}
+
+/*
+ * Character device to read and clear the MCE log.
+ */
+
+static void collect_tscs(void *data) 
+{ 
+	unsigned long *cpu_tsc = (unsigned long *)data;
+	rdtscll(cpu_tsc[smp_processor_id()]);
+} 
+
+static ssize_t mce_read(struct file *filp, char *ubuf, size_t usize, loff_t *off)
+{
+	unsigned long cpu_tsc[NR_CPUS];
+	static DECLARE_MUTEX(mce_read_sem);
+	unsigned next;
+	char *buf = ubuf;
+	int i, err;
+
+	down(&mce_read_sem); 
+	next = mcelog.next;
+	read_barrier_depends();
+		
+	/* Only supports full reads right now */
+	if (*off != 0 || usize < MCE_LOG_LEN*sizeof(struct mce)) { 
+		up(&mce_read_sem);
+		return -EINVAL;
+	}
+
+	err = 0;
+	for (i = 0; i < next; i++) {
+		if (!mcelog.entry[i].finished)
+			continue;
+		smp_rmb();
+		err |= copy_to_user(buf, mcelog.entry + i, sizeof(struct mce));
+		buf += sizeof(struct mce); 
+	} 
+
+	memset(mcelog.entry, 0, next * sizeof(struct mce));
+	mcelog.next = 0;
+	smp_wmb(); 
+	
+	synchronize_kernel();	
+
+	/* Collect entries that were still getting written before the synchronize. */
+
+	on_each_cpu(collect_tscs, cpu_tsc, 1, 1);
+	for (i = next; i < MCE_LOG_LEN; i++) { 
+		if (mcelog.entry[i].finished && 
+		    mcelog.entry[i].tsc < cpu_tsc[mcelog.entry[i].cpu]) {  
+			err |= copy_to_user(buf, mcelog.entry+i, sizeof(struct mce));
+			smp_rmb();
+			buf += sizeof(struct mce);
+			memset(&mcelog.entry[i], 0, sizeof(struct mce));
+		}
+	} 	
+	up(&mce_read_sem);
+	return err ? -EFAULT : buf - ubuf; 
+}
+
+static int mce_ioctl(struct inode *i, struct file *f,unsigned int cmd, unsigned long arg)
+{
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM; 
+	switch (cmd) {
+	case MCE_GET_RECORD_LEN: 
+		return put_user(sizeof(struct mce), (int *)arg);
+	case MCE_GET_LOG_LEN:
+		return put_user(MCE_LOG_LEN, (int *)arg);		
+	case MCE_GETCLEAR_FLAGS: {
+		unsigned flags;
+		do { 
+			flags = mcelog.flags;
+		} while (cmpxchg(&mcelog.flags, flags, 0) != flags); 
+		return put_user(flags, (int *)arg); 
+	}
+	default:
+		return -ENOTTY; 
+	} 
+}
+
+#if 0 /* for testing */
+static ssize_t mce_write(struct file *f, const char __user *buf, size_t sz, loff_t *off)
+{
+	struct mce m;
+	if (sz != sizeof(struct mce))
+		return -EINVAL;
+	copy_from_user(&m, buf, sizeof(struct mce));
+	m.finished = 0;
+	mce_log(&m);
+	return sizeof(struct mce);
+}
+#endif
+
+static struct file_operations mce_chrdev_ops = {
+	.read = mce_read,
+	.ioctl = mce_ioctl,
+//	.write = mce_write
+};
+
+static struct miscdevice mce_log_device = {
+	MISC_MCELOG_MINOR,
+	"mcelog",
+	&mce_chrdev_ops,
+};
+
+/* 
+ * Old style boot options parsing. Only for compatibility. 
+ */
+
+static int __init mcheck_disable(char *str)
+{
+	mce_disabled = 1;
+	return 0;
+}
+
+/* mce=off disable machine check */
+static int __init mcheck_enable(char *str)
+{
+	if (!strcmp(str, "off"))
+		mce_disabled = 1;
+	else
+		printk("mce= argument %s ignored. Please use /sys", str); 
+	return 0;
+}
+
+__setup("nomce", mcheck_disable);
+__setup("mce", mcheck_enable);
+
+/* 
+ * Sysfs support
+ */ 
+
+/* On resume clear all MCE state. Don't want to see leftovers from the BIOS. */
+static int mce_resume(struct sys_device *dev)
+{
+	mce_clear_all();
+	on_each_cpu(mce_init, NULL, 1, 1);
+	return 0;
+}
+
+/* Reinit MCEs after user configuration changes */
+static void mce_restart(void) 
+{ 
+	if (check_interval)
+		cancel_delayed_work(&mcheck_work);
+	/* Timer race is harmless here */
+	on_each_cpu(mce_init, NULL, 1, 1);       
+	if (check_interval)
+		schedule_delayed_work(&mcheck_work, check_interval*HZ);
+}
+
+static struct sysdev_class mce_sysclass = {
+	.resume = mce_resume,
+	set_kset_name("machinecheck"),
+};
+
+static struct sys_device device_mce = {
+	.id	= 0,
+	.cls	= &mce_sysclass,
+};
+
+/* Why are there no generic functions for this? */
+#define ACCESSOR(name, start) \
+	static ssize_t show_ ## name(struct sys_device *s, char *buf) { 	   	   \
+		return sprintf(buf, "%lu\n", (unsigned long)name);		   \
+	} 									   \
+	static ssize_t set_ ## name(struct sys_device *s,const char *buf,size_t siz) { \
+		char *end; 							   \
+		unsigned long new = simple_strtoul(buf, &end, 0); 		   \
+		if (end == buf) return -EINVAL;					   \
+		name = new;							   \
+		start; 								   \
+		return end-buf;		     					   \
+	}									   \
+	static SYSDEV_ATTR(name, 0644, show_ ## name, set_ ## name);
+
+ACCESSOR(disabled_banks,mce_restart())
+ACCESSOR(tolerant,)
+ACCESSOR(check_interval,mce_restart())
+
+static __init int mce_init_device(void)
+{
+	int err;
+	if (!mce_available(&boot_cpu_data))
+		return -EIO;
+	err = sysdev_class_register(&mce_sysclass);
+	if (!err)
+		err = sys_device_register(&device_mce);
+	if (!err) { 
+		/* could create per CPU objects, but is not worth it. */
+		sysdev_create_file(&device_mce, &attr_disabled_banks); 
+		sysdev_create_file(&device_mce, &attr_tolerant); 
+		sysdev_create_file(&device_mce, &attr_check_interval);
+	} 
+	
+	misc_register(&mce_log_device);
+	return err;
+
+}
+device_initcall(mce_init_device);
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/mpparse.c linux-2.5-merge/arch/x86_64/kernel/mpparse.c
--- linux-2.5/arch/x86_64/kernel/mpparse.c	2004-02-20 05:01:22.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/mpparse.c	2004-02-25 17:06:01.000000000 +0100
@@ -573,8 +573,6 @@ static int __init smp_scan_config (unsig
 				|| (mpf->mpf_specification == 4)) ) {
 
 			smp_found_config = 1;
-			printk(KERN_INFO "found SMP MP-table at %08lx\n",
-						virt_to_phys(mpf));
 			reserve_bootmem_generic(virt_to_phys(mpf), PAGE_SIZE);
 			if (mpf->mpf_physptr)
 				reserve_bootmem_generic(mpf->mpf_physptr, PAGE_SIZE);
@@ -584,6 +582,7 @@ static int __init smp_scan_config (unsig
 		bp += 4;
 		length -= 16;
 	}
+	printk(KERN_INFO "No mptable found.\n");
 	return 0;
 }
 
@@ -876,6 +875,72 @@ void __init mp_config_acpi_legacy_irqs (
 	return;
 }
 
+
+extern FADT_DESCRIPTOR acpi_fadt;
+
+void __init mp_config_ioapic_for_sci(int irq)
+{
+	int ioapic;
+	int ioapic_pin;
+	struct acpi_table_madt *madt;
+	struct acpi_table_int_src_ovr *entry = NULL;
+	acpi_interrupt_flags flags;
+	void *madt_end;
+	acpi_status status;
+
+	/*
+	 * Ensure that if there is an interrupt source override entry
+	 * for the ACPI SCI, we leave it as is. Unfortunately this involves
+	 * walking the MADT again.
+	 */
+	status = acpi_get_firmware_table("APIC", 1, ACPI_LOGICAL_ADDRESSING,
+		(struct acpi_table_header **) &madt);
+	if (ACPI_SUCCESS(status)) {
+		madt_end = (void *) (unsigned long)madt + madt->header.length;
+
+		entry = (struct acpi_table_int_src_ovr *)
+                ((unsigned long) madt + sizeof(struct acpi_table_madt));
+
+		while ((void *) entry < madt_end) {
+                	if (entry->header.type == ACPI_MADT_INT_SRC_OVR &&
+			    acpi_fadt.sci_int == entry->bus_irq)
+				goto found;
+			
+                	entry = (struct acpi_table_int_src_ovr *)
+                	        ((unsigned long) entry + entry->header.length);
+        	}
+	}
+	/*
+	 * Although the ACPI spec says that the SCI should be level/low
+	 * don't reprogram it unless there is an explicit MADT OVR entry
+	 * instructing us to do so -- otherwise we break Tyan boards which
+	 * have the SCI wired edge/high but no MADT OVR.
+	 */
+	return;
+
+found:
+	/*
+	 * See the note at the end of ACPI 2.0b section
+	 * 5.2.10.8 for what this is about.
+	 */
+	flags = entry->flags;
+	acpi_fadt.sci_int = entry->global_irq;
+	irq = entry->global_irq;
+
+	ioapic = mp_find_ioapic(irq);
+
+	ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
+
+	/*
+	 * MPS INTI flags:
+	 *  trigger: 0=default, 1=edge, 3=level
+	 *  polarity: 0=default, 1=high, 3=low
+	 * Per ACPI spec, default for SCI means level/low.
+	 */
+	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 
+		(flags.trigger == 1 ? 0 : 1), (flags.polarity == 1 ? 0 : 1));
+}
+
 #ifdef CONFIG_ACPI_PCI
 
 void __init mp_parse_prt (void)
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/nmi.c linux-2.5-merge/arch/x86_64/kernel/nmi.c
--- linux-2.5/arch/x86_64/kernel/nmi.c	2004-02-20 05:01:22.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/nmi.c	2004-02-25 17:06:01.000000000 +0100
@@ -42,10 +42,12 @@
 int nmi_active;		/* oprofile uses this */
 static int panic_on_timeout;
 
-unsigned int nmi_watchdog = NMI_LOCAL_APIC;
+unsigned int nmi_watchdog = NMI_DEFAULT;
 static unsigned int nmi_hz = HZ;
 unsigned int nmi_perfctr_msr;	/* the MSR to reset in NMI handler */
-int nmi_watchdog_disabled;
+
+/* Note that these events don't tick when the CPU idles. This means
+   the frequency varies with CPU load. */
 
 #define K7_EVNTSEL_ENABLE	(1 << 22)
 #define K7_EVNTSEL_INT		(1 << 20)
@@ -61,6 +63,27 @@ int nmi_watchdog_disabled;
 #define P6_EVENT_CPU_CLOCKS_NOT_HALTED	0x79
 #define P6_NMI_EVENT		P6_EVENT_CPU_CLOCKS_NOT_HALTED
 
+/* Run after command line and cpu_init init, but before all other checks */
+void __init nmi_watchdog_default(void)
+{
+	if (nmi_watchdog != NMI_DEFAULT)
+		return;
+
+	/* For some reason the IO APIC watchdog doesn't work on the AMD
+	   8111 chipset. For now switch to local APIC mode using
+	   perfctr0 there.  On Intel CPUs we don't have code to handle
+	   the perfctr and the IO-APIC seems to work, so use that.  */
+
+	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
+		nmi_watchdog = NMI_LOCAL_APIC; 
+		printk(KERN_INFO 
+              "Using local APIC NMI watchdog using perfctr0\n");
+	} else {
+		printk(KERN_INFO "Using IO APIC NMI watchdog\n");
+		nmi_watchdog = NMI_IO_APIC;
+	}
+}
+
 /* Why is there no CPUID flag for this? */
 static __init int cpu_has_lapic(void)
 {
@@ -112,7 +135,7 @@ int __init check_nmi_watchdog (void)
 	return 0;
 }
 
-static int __init setup_nmi_watchdog(char *str)
+int __init setup_nmi_watchdog(char *str)
 {
 	int nmi;
 
@@ -236,6 +259,9 @@ static void setup_k7_watchdog(void)
 	int i;
 	unsigned int evntsel;
 
+	/* No check, so can start with slow frequency */
+	nmi_hz = 1; 
+
 	/* XXX should check these in EFER */
 
 	nmi_perfctr_msr = MSR_K7_PERFCTR0;
@@ -253,14 +279,13 @@ static void setup_k7_watchdog(void)
 		| K7_NMI_EVENT;
 
 	wrmsr(MSR_K7_EVNTSEL0, evntsel, 0);
-	printk(KERN_INFO "watchdog: setting K7_PERFCTR0 to %08x\n", -(cpu_khz/nmi_hz*1000));
-	wrmsr(MSR_K7_PERFCTR0, -(cpu_khz/nmi_hz*1000), -1);
+	wrmsrl(MSR_K7_PERFCTR0, -((u64)cpu_khz*1000) / nmi_hz);
 	apic_write(APIC_LVTPC, APIC_DM_NMI);
 	evntsel |= K7_EVNTSEL_ENABLE;
 	wrmsr(MSR_K7_EVNTSEL0, evntsel, 0);
 }
 
-void setup_apic_nmi_watchdog (void)
+void setup_apic_nmi_watchdog(void)
 {
 	switch (boot_cpu_data.x86_vendor) {
 	case X86_VENDOR_AMD:
@@ -311,11 +336,10 @@ void touch_nmi_watchdog (void)
 
 void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason)
 {
-	int sum, cpu = safe_smp_processor_id();
-
-	if (nmi_watchdog_disabled)
-		return;
+	int sum, cpu;
+	//static int count;
 
+	cpu = safe_smp_processor_id();
 	sum = read_pda(apic_timer_irqs);
 	if (last_irq_sums[cpu] == sum) {
 		/*
@@ -336,7 +360,7 @@ void nmi_watchdog_tick (struct pt_regs *
 			bust_spinlocks(1);
 			printk("NMI Watchdog detected LOCKUP on CPU%d, registers:\n", cpu);
 			show_registers(regs);
-			if (panic_on_timeout)
+			if (panic_on_timeout || panic_on_oops)
 				panic("nmi watchdog");
 			printk("console shuts up ...\n");
 			console_silent();
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/process.c linux-2.5-merge/arch/x86_64/kernel/process.c
--- linux-2.5/arch/x86_64/kernel/process.c	2004-02-20 05:01:22.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/process.c	2004-02-25 17:06:01.000000000 +0100
@@ -583,16 +583,18 @@ extern void scheduling_functions_end_her
 
 unsigned long get_wchan(struct task_struct *p)
 {
+	unsigned long stack;
 	u64 fp,rip;
 	int count = 0;
 
 	if (!p || p == current || p->state==TASK_RUNNING)
 		return 0; 
-	if (p->thread.rsp < (u64)p || p->thread.rsp > (u64)p + THREAD_SIZE)
+	stack = (unsigned long)p->thread_info; 
+	if (p->thread.rsp < stack || p->thread.rsp > stack+THREAD_SIZE)
 		return 0;
 	fp = *(u64 *)(p->thread.rsp);
 	do { 
-		if (fp < (unsigned long)p || fp > (unsigned long)p+THREAD_SIZE)
+		if (fp < (unsigned long)stack || fp > (unsigned long)stack+THREAD_SIZE)
 			return 0; 
 		rip = *(u64 *)(fp+8); 
 		if (rip < first_sched || rip >= last_sched)
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/setup64.c linux-2.5-merge/arch/x86_64/kernel/setup64.c
--- linux-2.5/arch/x86_64/kernel/setup64.c	2004-01-24 05:41:20.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/setup64.c	2004-02-25 17:06:01.000000000 +0100
@@ -191,7 +191,7 @@ void pda_init(int cpu)
 
 char boot_exception_stacks[N_EXCEPTION_STACKS * EXCEPTION_STKSZ];
 
-void syscall_init(void)
+void __init syscall_init(void)
 {
 	/* 
 	 * LSTAR and STAR live in a bit strange symbiosis.
@@ -209,6 +209,16 @@ void syscall_init(void)
 	wrmsrl(MSR_SYSCALL_MASK, EF_TF|EF_DF|EF_IE|0x3000); 
 }
 
+void __init check_efer(void)
+{
+	unsigned long efer;
+
+	rdmsrl(MSR_EFER, efer); 
+        if (!(efer & EFER_NX) || do_not_nx) { 
+                __supported_pte_mask &= ~_PAGE_NX; 
+        }       
+}
+
 /*
  * cpu_init() initializes state that is per-CPU. Some data is already
  * initialized (naturally) in the bootstrap process, such as the GDT
@@ -224,7 +234,7 @@ void __init cpu_init (void)
 	int cpu = smp_processor_id();
 #endif
 	struct tss_struct * t = &init_tss[cpu];
-	unsigned long v, efer; 
+	unsigned long v; 
 	char *estacks = NULL; 
 	struct task_struct *me;
 
@@ -270,10 +280,7 @@ void __init cpu_init (void)
 	wrmsrl(MSR_KERNEL_GS_BASE, 0);
 	barrier(); 
 
-	rdmsrl(MSR_EFER, efer); 
-        if (!(efer & EFER_NX) || do_not_nx) { 
-                __supported_pte_mask &= ~_PAGE_NX; 
-        }       
+	check_efer();
 
 	/*
 	 * set up and load the per-CPU TSS
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/setup.c linux-2.5-merge/arch/x86_64/kernel/setup.c
--- linux-2.5/arch/x86_64/kernel/setup.c	2004-02-28 05:36:54.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/setup.c	2004-02-25 17:06:01.000000000 +0100
@@ -380,6 +380,8 @@ void __init setup_arch(char **cmdline_p)
 	 */
 	end_pfn = e820_end_of_ram();
 
+	check_efer();
+
 	init_memory_mapping(); 
 
 #ifdef CONFIG_DISCONTIGMEM
@@ -892,6 +894,7 @@ void __init identify_cpu(struct cpuinfo_
 			boot_cpu_data.x86_capability[i] &= c->x86_capability[i];
 	}
 
+	mcheck_init(c);
 }
  
 
@@ -949,7 +952,7 @@ static int show_cpuinfo(struct seq_file 
 
 		/* Intel-defined (#2) */
 		"pni", NULL, NULL, "monitor", "ds_cpl", NULL, NULL, "tm2",
-		"est", NULL, "cid", NULL, NULL, NULL, NULL, NULL,
+		"est", NULL, "cid", NULL, NULL, "cmpxchg16b", NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 	};
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/smpboot.c linux-2.5-merge/arch/x86_64/kernel/smpboot.c
--- linux-2.5/arch/x86_64/kernel/smpboot.c	2004-02-20 05:01:22.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/smpboot.c	2004-02-25 17:06:01.000000000 +0100
@@ -264,7 +264,7 @@ void __init smp_callin(void)
 	 */
 	phys_id = GET_APIC_ID(apic_read(APIC_ID));
 	cpuid = smp_processor_id();
-	if (cpu_test_and_set(cpuid, cpu_callin_map)) {
+	if (cpu_isset(cpuid, cpu_callin_map)) {
 		panic("smp_callin: phys CPU#%d, CPU#%d already present??\n",
 					phys_id, cpuid);
 	}
@@ -651,7 +651,6 @@ static void __init do_boot_cpu (int apic
 		if (cpu_isset(cpu, cpu_callin_map)) {
 			/* number CPUs logically, starting from 1 (BSP is 0) */
 			Dprintk("OK.\n");
-			printk(KERN_INFO "CPU%d: ", cpu);
 			print_cpu_info(&cpu_data[cpu]);
 			Dprintk("CPU has booted.\n");
 		} else {
@@ -730,6 +729,8 @@ static void __init smp_boot_cpus(unsigne
 {
 	unsigned apicid, cpu;
 
+	nmi_watchdog_default();
+
 	/*
 	 * Setup boot CPU information
 	 */
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/syscall.c linux-2.5-merge/arch/x86_64/kernel/syscall.c
--- linux-2.5/arch/x86_64/kernel/syscall.c	2002-04-20 19:23:17.000000000 +0200
+++ linux-2.5-merge/arch/x86_64/kernel/syscall.c	2004-02-25 17:06:01.000000000 +0100
@@ -5,12 +5,6 @@
 #include <linux/cache.h>
 #include <linux/config.h>
 
-/* No comment. */
-#if defined(CONFIG_NFSD) || defined(CONFIG_NFSD_MODULE)
-#else
-#define sys_nfsservctl		sys_ni_syscall
-#endif
-
 #define __NO_STUBS
 
 #define __SYSCALL(nr, sym) extern asmlinkage void sym(void) ; 
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/time.c linux-2.5-merge/arch/x86_64/kernel/time.c
--- linux-2.5/arch/x86_64/kernel/time.c	2004-02-20 05:01:22.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/time.c	2004-02-25 17:06:01.000000000 +0100
@@ -24,6 +24,7 @@
 #include <linux/ioport.h>
 #include <linux/module.h>
 #include <linux/device.h>
+#include <linux/sysdev.h>
 #include <linux/bcd.h>
 #include <asm/pgtable.h>
 #include <asm/vsyscall.h>
@@ -44,6 +45,8 @@ extern int using_apic_timer;
 spinlock_t rtc_lock = SPIN_LOCK_UNLOCKED;
 spinlock_t i8253_lock = SPIN_LOCK_UNLOCKED;
 
+static int nohpet __initdata = 0;
+
 #undef HPET_HACK_ENABLE_DANGEROUS
 
 
@@ -217,14 +220,22 @@ static void set_rtc_mmss(unsigned long n
 		real_minutes += 30;		/* correct for half hour time zone */
 	real_minutes %= 60;
 
-	if (abs(real_minutes - cmos_minutes) < 30) {
+#if 0
+	/* AMD 8111 is a really bad time keeper and hits this regularly. 
+	   It probably was an attempt to avoid screwing up DST, but ignore
+	   that for now. */	   
+	if (abs(real_minutes - cmos_minutes) >= 30) {
+		printk(KERN_WARNING "time.c: can't update CMOS clock "
+		       "from %d to %d\n", cmos_minutes, real_minutes);
+	} else
+#endif
+
+	{
 			BIN_TO_BCD(real_seconds);
 			BIN_TO_BCD(real_minutes);
 		CMOS_WRITE(real_seconds, RTC_SECONDS);
 		CMOS_WRITE(real_minutes, RTC_MINUTES);
-	} else
-		printk(KERN_WARNING "time.c: can't update CMOS clock "
-		       "from %d to %d\n", cmos_minutes, real_minutes);
+	}
 
 /*
  * The following flags have to be released exactly in this order, otherwise the
@@ -683,6 +694,8 @@ void __init time_init(void)
 		       "at %#lx.\n", hpet_address);
         }
 #endif
+	if (nohpet)
+		vxtime.hpet_address = 0;
 
 	xtime.tv_sec = get_cmos_time();
 	xtime.tv_nsec = 0;
@@ -736,6 +749,51 @@ void __init time_init_smp(void)
 
 __setup("report_lost_ticks", time_setup);
 
+static long clock_cmos_diff;
+
+static int time_suspend(struct sys_device *dev, u32 state)
+{
+	/*
+	 * Estimate time zone so that set_time can update the clock
+	 */
+	clock_cmos_diff = -get_cmos_time();
+	clock_cmos_diff += get_seconds();
+	return 0;
+}
+
+static int time_resume(struct sys_device *dev)
+{
+	unsigned long sec = get_cmos_time() + clock_cmos_diff;
+	write_seqlock_irq(&xtime_lock);
+	xtime.tv_sec = sec;
+	xtime.tv_nsec = 0;
+	write_sequnlock_irq(&xtime_lock);
+	return 0;
+}
+
+static struct sysdev_class pit_sysclass = {
+	.resume = time_resume,
+	.suspend = time_suspend,
+	set_kset_name("pit"),
+};
+
+
+/* XXX this driverfs stuff should probably go elsewhere later -john */
+static struct sys_device device_i8253 = {
+	.id	= 0,
+	.cls	= &pit_sysclass,
+};
+
+static int time_init_device(void)
+{
+	int error = sysdev_class_register(&pit_sysclass);
+	if (!error)
+		error = sys_device_register(&device_i8253);
+	return error;
+}
+
+device_initcall(time_init_device);
+
 #ifdef CONFIG_HPET_EMULATE_RTC
 /* HPET in LegacyReplacement Mode eats up RTC interrupt line. When, HPET
  * is enabled, we support RTC interrupt functionality in software.
@@ -961,3 +1019,11 @@ irqreturn_t hpet_rtc_interrupt(int irq, 
 	return IRQ_HANDLED;
 }
 #endif
+
+static int __init nohpet_setup(char *s) 
+{ 
+	nohpet = 1;
+	return 0;
+} 
+
+__setup("nohpet", nohpet_setup);
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/traps.c linux-2.5-merge/arch/x86_64/kernel/traps.c
--- linux-2.5/arch/x86_64/kernel/traps.c	2004-02-20 05:01:22.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/traps.c	2004-02-25 17:06:01.000000000 +0100
@@ -556,7 +556,7 @@ asmlinkage void default_do_nmi(struct pt
 		 * Ok, so this is none of the documented NMI sources,
 		 * so it must be the NMI watchdog.
 		 */
-		if (nmi_watchdog) {
+		if (nmi_watchdog > 0) {
 			nmi_watchdog_tick(regs,reason);
 			return;
 		}
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/kernel/x8664_ksyms.c linux-2.5-merge/arch/x86_64/kernel/x8664_ksyms.c
--- linux-2.5/arch/x86_64/kernel/x8664_ksyms.c	2004-02-28 05:36:54.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/kernel/x8664_ksyms.c	2004-02-25 17:06:01.000000000 +0100
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/tty.h>
+#include <linux/ioctl32.h>
 
 #include <asm/semaphore.h>
 #include <asm/processor.h>
@@ -222,3 +223,5 @@ EXPORT_SYMBOL(clear_page);
 EXPORT_SYMBOL(flush_tlb_page);
 EXPORT_SYMBOL_GPL(flush_tlb_all);
 #endif
+
+EXPORT_SYMBOL(sys_ioctl);
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/Makefile linux-2.5-merge/arch/x86_64/Makefile
--- linux-2.5/arch/x86_64/Makefile	2004-02-28 05:36:53.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/Makefile	2004-02-25 17:06:01.000000000 +0100
@@ -37,8 +37,6 @@ LDFLAGS		:= -m elf_x86_64
 OBJCOPYFLAGS	:= -O binary -R .note -R .comment -S
 LDFLAGS_vmlinux := -e stext
 
-check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1 ; then echo "$(1)"; else echo "$(2)"; fi)
-
 cflags-$(CONFIG_MK8) += $(call check_gcc,-march=k8,)
 cflags-$(CONFIG_MPSC) += $(call check_gcc,-march=pentium4,)
 CFLAGS += $(cflags-y)
@@ -49,16 +47,15 @@ CFLAGS += -pipe
 # this makes reading assembly source easier, but produces worse code
 # actually it makes the kernel smaller too.
 CFLAGS += -fno-reorder-blocks	
-# should lower this a lot and see how much .text is saves	
-# CFLAGS += -finline-limit=2000
 CFLAGS += -Wno-sign-compare
-# don't enable this when you use kgdb:
 ifneq ($(CONFIG_DEBUG_INFO),y)
 CFLAGS += -fno-asynchronous-unwind-tables
+# -fweb shrinks the kernel a bit, but the difference is very small
+# it also messes up debugging, so don't use it for now.
+#CFLAGS += $(call check_gcc,-fweb,)
 endif
-
-# Enable unit-at-a-time mode when possible. It shrinks the
-# kernel considerably.
+# -funit-at-a-time shrinks the kernel .text considerably
+# unfortunately it makes reading oopses harder.
 CFLAGS += $(call check_gcc,-funit-at-a-time,)
 
 head-y := arch/x86_64/kernel/head.o arch/x86_64/kernel/head64.o arch/x86_64/kernel/init_task.o
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/mm/init.c linux-2.5-merge/arch/x86_64/mm/init.c
--- linux-2.5/arch/x86_64/mm/init.c	2004-02-20 05:01:23.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/mm/init.c	2004-02-25 17:06:01.000000000 +0100
@@ -548,3 +548,32 @@ int kern_addr_valid(unsigned long addr) 
 		return 0;
 	return pfn_valid(pte_pfn(*pte));
 }
+
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+
+extern int exception_trace, page_fault_trace;
+
+static ctl_table debug_table2[] = {
+	{ 99, "exception-trace", &exception_trace, sizeof(int), 0644, NULL,
+	  proc_dointvec },
+#ifdef CONFIG_CHECKING
+	{ 100, "page-fault-trace", &page_fault_trace, sizeof(int), 0644, NULL,
+	  proc_dointvec },
+#endif
+	{ 0, }
+}; 
+
+static ctl_table debug_root_table2[] = { 
+	{ .ctl_name = CTL_DEBUG, .procname = "debug", .mode = 0555, 
+	   .child = debug_table2 }, 
+	{ 0 }, 
+}; 
+
+static __init int x8664_sysctl_init(void)
+{ 
+	register_sysctl_table(debug_root_table2, 1);
+	return 0;
+}
+__initcall(x8664_sysctl_init);
+#endif
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/arch/x86_64/mm/k8topology.c linux-2.5-merge/arch/x86_64/mm/k8topology.c
--- linux-2.5/arch/x86_64/mm/k8topology.c	2004-02-20 05:01:23.000000000 +0100
+++ linux-2.5-merge/arch/x86_64/mm/k8topology.c	2004-02-25 17:06:01.000000000 +0100
@@ -48,6 +48,7 @@ int __init k8_scan_nodes(unsigned long s
 	int nodeid, i, nb; 
 	int found = 0;
 	u32 reg;
+	int rr;
 
 	nb = find_northbridge(); 
 	if (nb < 0) 
@@ -160,7 +161,7 @@ int __init k8_scan_nodes(unsigned long s
 	   mapping. To avoid this fill in the mapping for all possible
 	   CPUs, as the number of CPUs is not known yet. 
 	   We round robin the existing nodes. */
-	int rr = 0;
+	rr = 0;
 	for (i = 0; i < MAXNODE; i++) {
 		if (nodes_present & (1UL<<i))
 			continue;
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/Documentation/nmi_watchdog.txt linux-2.5-merge/Documentation/nmi_watchdog.txt
--- linux-2.5/Documentation/nmi_watchdog.txt	2003-08-22 13:27:30.000000000 +0200
+++ linux-2.5-merge/Documentation/nmi_watchdog.txt	2004-02-25 17:06:01.000000000 +0100
@@ -22,9 +22,10 @@ CONFIG_X86_UP_IOAPIC is for uniprocessor
 kernel debugging options, such as Kernel Stack Meter or Kernel Tracer,
 may implicitly disable the NMI watchdog.]
 
-For x86-64, the needed APIC is always compiled in, and the NMI watchdog is
-always enabled with I/O-APIC mode (nmi_watchdog=1). Currently, local APIC
-mode (nmi_watchdog=2) does not work on x86-64.
+For x86-64, the needed APIC is always compiled in, and the NMI
+watchdog is always enabled with Local APIC mode (nmi_watchdog=2).
+Currently, I/O APIC mode (nmi_watchdog=1) does not work on x86_64/AMD8111
+(How about other chipsets?)
 
 Using local APIC (nmi_watchdog=2) needs the first performance register, so
 you can't use it for other purposes (such as high precision performance
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/Documentation/x86_64/boot-options.txt linux-2.5-merge/Documentation/x86_64/boot-options.txt
--- linux-2.5/Documentation/x86_64/boot-options.txt	2004-01-24 05:40:46.000000000 +0100
+++ linux-2.5-merge/Documentation/x86_64/boot-options.txt	2004-02-25 17:06:01.000000000 +0100
@@ -5,19 +5,12 @@ only the AMD64 specific ones are listed 
 
 Machine check
 
-(see the Opteron BIOS&Kernel manual for more details on the banks etc.)
-
    mce=off disable machine check
-   mce=nok8 disable k8 specific features
-   mce=disable<NUMBER> disable bank NUMBER
-   mce=enable<NUMBER> enable bank number
-   mce=device	Enable more machine check options in Northbridge.
-		Can be useful for device driver debugging.
-   mce=NUMBER mcheck timer interval number seconds.
-   Can be also comma separated in a single mce=
 
    nomce (for compatibility with i386): same as mce=off
 
+   Everything else is in sysfs now.
+
 APICs
 
    apic		 Use IO-APIC. Default
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/drivers/char/agp/amd64-agp.c linux-2.5-merge/drivers/char/agp/amd64-agp.c
--- linux-2.5/drivers/char/agp/amd64-agp.c	2004-01-24 05:41:25.000000000 +0100
+++ linux-2.5-merge/drivers/char/agp/amd64-agp.c	2004-02-25 17:06:01.000000000 +0100
@@ -16,11 +16,7 @@
 #include "agp.h"
 
 /* Will need to be increased if AMD64 ever goes >8-way. */
-#ifdef CONFIG_SMP
 #define MAX_HAMMER_GARTS   8
-#else
-#define MAX_HAMMER_GARTS   1
-#endif
 
 /* PTE bits. */
 #define GPTE_VALID	1
@@ -35,6 +31,14 @@
 #define INVGART		(1<<0)
 #define GARTPTEERR	(1<<1)
 
+/* NVIDIA K8 registers */
+#define NVIDIA_X86_64_0_APBASE		0x10
+#define NVIDIA_X86_64_1_APBASE1		0x50
+#define NVIDIA_X86_64_1_APLIMIT1	0x54
+#define NVIDIA_X86_64_1_APSIZE		0xa8
+#define NVIDIA_X86_64_1_APBASE2		0xd8
+#define NVIDIA_X86_64_1_APLIMIT2	0xdc
+
 static int nr_garts;
 static struct pci_dev * hammers[MAX_HAMMER_GARTS];
 
@@ -346,6 +350,10 @@ static __devinit int cache_nbs (struct p
 	/* cache pci_devs of northbridges. */
 	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) 
 			!= NULL) {
+		if (i == MAX_HAMMER_GARTS) { 
+			printk(KERN_ERR PFX "Too many northbridges for AGP\n");
+			return -1;
+		}
 		if (fix_northbridge(loop_dev, pdev, cap_ptr) < 0) { 
 			printk(KERN_ERR PFX "No usable aperture found.\n");
 #ifdef __x86_64__ 
@@ -355,29 +363,111 @@ static __devinit int cache_nbs (struct p
 			return -1;  
 		}
 		hammers[i++] = loop_dev;
+	}
 		nr_garts = i;
-#ifdef CONFIG_SMP
-		if (i > MAX_HAMMER_GARTS) { 
-			printk(KERN_ERR PFX "Too many northbridges for AGP\n");
-			return -1;
+	return i == 0 ? -1 : 0;
+}
+
+/* Handle AMD 8151 quirks */
+static void __devinit amd8151_init(struct pci_dev *pdev, struct agp_bridge_data *bridge)
+
+{		
+	char *revstring;
+	u8 rev_id;
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+	switch (rev_id) {
+	case 0x01: revstring="A0"; break;
+	case 0x02: revstring="A1"; break;
+	case 0x11: revstring="B0"; break;
+	case 0x12: revstring="B1"; break;
+	case 0x13: revstring="B2"; break;
+	default:   revstring="??"; break;
 		}
-#else
-		/* Uniprocessor case, return after finding first bridge.
-		   (There may be more, but in UP, we don't care). */
-		return 0;
-#endif
+
+	printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
+
+	/*
+	 * Work around errata.
+	 * Chips before B2 stepping incorrectly reporting v3.5
+	 */
+	if (rev_id < 0x13) {
+		printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
+		bridge->major_version = 3;
+		bridge->minor_version = 0;
 	}
+}
 
-	return i == 0 ? -1 : 0;
+static struct aper_size_info_32 nforce3_sizes[5] =
+{
+	{512,  131072, 7, 0x00000000 },
+	{256,  65536,  6, 0x00000008 },
+	{128,  32768,  5, 0x0000000C },
+	{64,   16384,  4, 0x0000000E },
+	{32,   8192,   3, 0x0000000F }
+};
+
+/* Handle shadow device of the Nvidia NForce3 */
+/* CHECK-ME original 2.4 version set up some IORRs. Check if that is needed. */
+static int __devinit nforce3_agp_init(struct pci_dev *pdev) 
+{ 
+	u32 tmp, apbase, apbar, aplimit;
+	struct pci_dev *dev1; 
+	int i;
+	unsigned size = amd64_fetch_size(); 
+
+	printk(KERN_INFO PFX "Setting up Nforce3 AGP.\n");
+
+	dev1 = pci_find_slot((unsigned int)pdev->bus->number, PCI_DEVFN(11, 0));
+	if (dev1 == NULL) {
+		printk(KERN_INFO PFX "agpgart: Detected an NVIDIA "
+			"nForce3 chipset, but could not find "
+			"the secondary device.\n");
+		return -ENODEV;
+	}	
+
+	for (i = 0; i < ARRAY_SIZE(nforce3_sizes); i++) 
+		if (nforce3_sizes[i].size == size)
+			break; 
+
+	if (i == ARRAY_SIZE(nforce3_sizes)) {
+		printk(KERN_INFO PFX "No NForce3 size found for %d\n", size); 
+		return -ENODEV; 
+	}
+	
+	pci_read_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, &tmp);
+	tmp &= ~(0xf);
+	tmp |= nforce3_sizes[i].size_value;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, tmp);
+
+	/* shadow x86-64 registers into NVIDIA registers */
+	pci_read_config_dword (hammers[0], AMD64_GARTAPERTUREBASE, &apbase);
+
+	/* if x86-64 aperture base is beyond 4G, exit here */
+	if ( (apbase & 0x7fff) >> (32 - 25) )
+		 return -ENODEV;
+
+	apbase = (apbase & 0x7fff) << 25;
+
+	pci_read_config_dword(pdev, NVIDIA_X86_64_0_APBASE, &apbar);
+	apbar &= ~PCI_BASE_ADDRESS_MEM_MASK;
+	apbar |= apbase;
+	pci_write_config_dword(pdev, NVIDIA_X86_64_0_APBASE, apbar);
+
+	aplimit = apbase + (size * 1024 * 1024) - 1;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE1, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT1, aplimit);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE2, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT2, aplimit);
+
+	return 0;
 }
 
 static int __devinit agp_amd64_probe(struct pci_dev *pdev,
 				     const struct pci_device_id *ent)
 {
 	struct agp_bridge_data *bridge;
-	u8 rev_id;
 	u8 cap_ptr;
-	char *revstring=NULL;
 
 	cap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);
 	if (!cap_ptr)
@@ -391,32 +481,7 @@ static int __devinit agp_amd64_probe(str
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
 	    pdev->device == PCI_DEVICE_ID_AMD_8151_0) {
-
-		pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
-		switch (rev_id) {
-		case 0x01:	revstring="A0";
-				break;
-		case 0x02:	revstring="A1";
-				break;
-		case 0x11:	revstring="B0";
-				break;
-		case 0x12:	revstring="B1";
-				break;
-		case 0x13:	revstring="B2";
-				break;
-		default:	revstring="??";
-				break;
-		}
-		printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
-		/*
-		 * Work around errata.
-		 * Chips before B2 stepping incorrectly reporting v3.5
-		 */
-		if (rev_id < 0x13) {
-			printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
-			bridge->major_version = 3;
-			bridge->minor_version = 0;
-		}
+		amd8151_init(pdev, bridge);
 	} else {
 		printk(KERN_INFO PFX "Detected AGP bridge %x\n",
 			pdev->devfn);
@@ -434,6 +499,14 @@ static int __devinit agp_amd64_probe(str
 		return -ENODEV;
 	}
 
+	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA) { 
+		int ret = nforce3_agp_init(pdev);
+		if (ret) { 
+			agp_put_bridge(bridge); 
+			return ret;
+		}
+	}
+
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
 }
@@ -478,8 +551,25 @@ static struct pci_device_id agp_amd64_pc
 	{
 	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
 	.class_mask	= ~0,
-	.vendor		= PCI_VENDOR_ID_SI,
-	.device		= PCI_DEVICE_ID_SI_755,
+	.vendor		= PCI_VENDOR_ID_VIA,
+	.device		= PCI_DEVICE_ID_VIA_8380_0,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	/* NForce3 */
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3S,
 	.subvendor	= PCI_ANY_ID,
 	.subdevice	= PCI_ANY_ID,
 	},
Binary files linux-2.5/drivers/pci/gen-devlist and linux-2.5-merge/drivers/pci/gen-devlist differ
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/fs/binfmt_elf.c linux-2.5-merge/fs/binfmt_elf.c
--- linux-2.5/fs/binfmt_elf.c	2004-02-20 05:02:48.000000000 +0100
+++ linux-2.5-merge/fs/binfmt_elf.c	2004-02-25 17:06:00.000000000 +0100
@@ -198,6 +198,7 @@ create_elf_tables(struct linux_binprm *b
 	NEW_AUX_ENT(AT_GID, (elf_addr_t) tsk->gid);
 	NEW_AUX_ENT(AT_EGID, (elf_addr_t) tsk->egid);
  	NEW_AUX_ENT(AT_SECURE, (elf_addr_t) security_bprm_secureexec(bprm));
+	NEW_AUX_ENT(AT_NUMCPUS, num_online_cpus());
 	if (k_platform) {
 		NEW_AUX_ENT(AT_PLATFORM, (elf_addr_t)(long)u_platform);
 	}
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/fs/compat.c linux-2.5-merge/fs/compat.c
--- linux-2.5/fs/compat.c	2004-01-24 05:41:57.000000000 +0100
+++ linux-2.5-merge/fs/compat.c	2004-02-25 17:06:00.000000000 +0100
@@ -405,9 +405,11 @@ asmlinkage long compat_sys_ioctl(unsigne
 	while (t && t->cmd != cmd)
 		t = (struct ioctl_trans *)t->next;
 	if (t) {
-		if (t->handler)
+		if (t->handler) { 
+			lock_kernel();
 			error = t->handler(fd, cmd, arg, filp);
-		else
+			unlock_kernel();
+		} else
 			error = sys_ioctl(fd, cmd, arg);
 	} else if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15)) {
 		error = siocdevprivate_ioctl(fd, cmd, arg);
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/asm-x86_64/a.out.h linux-2.5-merge/include/asm-x86_64/a.out.h
--- linux-2.5/include/asm-x86_64/a.out.h	2004-01-24 05:42:24.000000000 +0100
+++ linux-2.5-merge/include/asm-x86_64/a.out.h	2004-02-25 17:06:01.000000000 +0100
@@ -20,9 +20,8 @@ struct exec
 #define N_SYMSIZE(a)	((a).a_syms)
 
 #ifdef __KERNEL__
-
-#define STACK_TOP	0xc0000000
-
+#include <linux/thread_info.h>
+#define STACK_TOP (test_thread_flag(TIF_IA32) ? IA32_PAGE_OFFSET : TASK_SIZE)
 #endif
 
 #endif /* __A_OUT_GNU_H__ */
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/asm-x86_64/apic.h linux-2.5-merge/include/asm-x86_64/apic.h
--- linux-2.5/include/asm-x86_64/apic.h	2004-02-20 05:03:39.000000000 +0100
+++ linux-2.5-merge/include/asm-x86_64/apic.h	2004-02-25 17:06:01.000000000 +0100
@@ -84,9 +84,12 @@ extern int APIC_init_uniprocessor (void)
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
 
-extern int check_nmi_watchdog (void);
+extern int check_nmi_watchdog(void);
+extern void nmi_watchdog_default(void);
+extern int setup_nmi_watchdog(char *);
 
 extern unsigned int nmi_watchdog;
+#define NMI_DEFAULT	-1
 #define NMI_NONE	0
 #define NMI_IO_APIC	1
 #define NMI_LOCAL_APIC	2
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/asm-x86_64/mce.h linux-2.5-merge/include/asm-x86_64/mce.h
--- linux-2.5/include/asm-x86_64/mce.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.5-merge/include/asm-x86_64/mce.h	2004-02-25 17:06:01.000000000 +0100
@@ -0,0 +1,67 @@
+#ifndef _ASM_MCE_H
+#define _ASM_MCE_H 1
+
+#include <asm/ioctls.h>
+#include <asm/types.h>
+
+/* 
+ * Machine Check support for x86
+ */
+
+#define MCG_CTL_P        (1UL<<8)   /* MCG_CAP register available */
+
+#define MCG_STATUS_RIPV  (1UL<<0)   /* restart ip valid */
+#define MCG_STATUS_EIPV  (1UL<<1)   /* eip points to correct instruction */
+#define MCG_STATUS_MCIP  (1UL<<2)   /* machine check in progress */
+
+#define MCI_STATUS_VAL   (1UL<<63)  /* valid error */
+#define MCI_STATUS_OVER  (1UL<<62)  /* previous errors lost */
+#define MCI_STATUS_UC    (1UL<<61)  /* uncorrected error */
+#define MCI_STATUS_EN    (1UL<<60)  /* error enabled */
+#define MCI_STATUS_MISCV (1UL<<59)  /* misc error reg. valid */
+#define MCI_STATUS_ADDRV (1UL<<58)  /* addr reg. valid */
+#define MCI_STATUS_PCC   (1UL<<57)  /* processor context corrupt */
+
+/* Fields are zero when not available */
+struct mce {
+	__u64 status;
+	__u64 misc;
+	__u64 addr;
+	__u64 mcgstatus;
+	__u64 rip;	
+	__u64 tsc;	/* cpu time stamp counter */
+	__u64 res1;	/* for future extension */	
+	__u64 res2;	/* dito. */
+	__u8  cs;		/* code segment */
+	__u8  bank;	/* machine check bank */
+	__u8  cpu;	/* cpu that raised the error */
+	__u8  finished;   /* entry is valid */
+	__u32 pad;   
+};
+
+/* 
+ * This structure contains all data related to the MCE log.
+ * Also carries a signature to make it easier to find from external debugging tools.
+ * Each entry is only valid when its finished flag is set.
+ */
+
+#define MCE_LOG_LEN 32
+
+struct mce_log { 
+	char signature[12]; /* "MACHINECHECK" */ 
+	unsigned len;  	    /* = MCE_LOG_LEN */ 
+	unsigned next;
+	unsigned flags;
+	unsigned pad0; 
+	struct mce entry[MCE_LOG_LEN];
+};
+
+#define MCE_OVERFLOW 0		/* bit 0 in flags means overflow */
+
+#define MCE_LOG_SIGNATURE 	"MACHINECHECK"
+
+#define MCE_GET_RECORD_LEN   _IOR('M', 1, int)
+#define MCE_GET_LOG_LEN      _IOR('M', 2, int)
+#define MCE_GETCLEAR_FLAGS   _IOR('M', 3, int)
+
+#endif
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/asm-x86_64/module.h linux-2.5-merge/include/asm-x86_64/module.h
--- linux-2.5/include/asm-x86_64/module.h	2002-12-21 20:18:20.000000000 +0100
+++ linux-2.5-merge/include/asm-x86_64/module.h	2004-02-25 17:06:01.000000000 +0100
@@ -7,4 +7,6 @@ struct mod_arch_specific {}; 
 #define Elf_Sym Elf64_Sym
 #define Elf_Ehdr Elf64_Ehdr
 
+#define ARCH_COMPILER_COMPATIBLE 1
+
 #endif 
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/asm-x86_64/pci-direct.h linux-2.5-merge/include/asm-x86_64/pci-direct.h
--- linux-2.5/include/asm-x86_64/pci-direct.h	2003-08-19 13:19:52.000000000 +0200
+++ linux-2.5-merge/include/asm-x86_64/pci-direct.h	2004-02-25 17:06:01.000000000 +0100
@@ -28,7 +28,7 @@ static inline u8 read_pci_config_byte(u8
 	return v;
 }
 
-static inline u8 read_pci_config_16(u8 bus, u8 slot, u8 func, u8 offset)
+static inline u16 read_pci_config_16(u8 bus, u8 slot, u8 func, u8 offset)
 {
 	u16 v; 
 	outl(0x80000000 | (bus<<16) | (slot<<11) | (func<<8) | offset, 0xcf8);
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/asm-x86_64/pgtable.h linux-2.5-merge/include/asm-x86_64/pgtable.h
--- linux-2.5/include/asm-x86_64/pgtable.h	2004-01-24 05:42:25.000000000 +0100
+++ linux-2.5-merge/include/asm-x86_64/pgtable.h	2004-02-25 17:06:01.000000000 +0100
@@ -36,7 +36,7 @@ extern unsigned long pgkern_mask;
  * ZERO_PAGE is a global shared page that is always zero: used
  * for zero-mapped memory areas etc..
  */
-extern unsigned long empty_zero_page[1024];
+extern unsigned long empty_zero_page[PAGE_SIZE/sizeof(unsigned long)];
 #define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
 
 #define PML4_SHIFT	39
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/asm-x86_64/processor.h linux-2.5-merge/include/asm-x86_64/processor.h
--- linux-2.5/include/asm-x86_64/processor.h	2004-02-20 05:03:39.000000000 +0100
+++ linux-2.5-merge/include/asm-x86_64/processor.h	2004-02-25 17:06:01.000000000 +0100
@@ -388,7 +388,7 @@ static inline void prefetch(void *x) 
 #define ARCH_HAS_PREFETCHW 1
 static inline void prefetchw(void *x) 
 { 
-	alternative_input(ASM_NOP4,
+	alternative_input(ASM_NOP5,
 			  "prefetchw (%1)",
 			  X86_FEATURE_3DNOW,
 			  "r" (x));
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/asm-x86_64/proto.h linux-2.5-merge/include/asm-x86_64/proto.h
--- linux-2.5/include/asm-x86_64/proto.h	2004-02-20 05:03:39.000000000 +0100
+++ linux-2.5-merge/include/asm-x86_64/proto.h	2004-02-25 17:06:01.000000000 +0100
@@ -73,6 +73,7 @@ extern char *syscall32_page;
 extern void setup_node_bootmem(int nodeid, unsigned long start, unsigned long end);
 
 extern void check_ioapic(void);
+extern void check_efer(void);
 
 extern int unhandled_signal(struct task_struct *tsk, int sig);
 
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/linux/elf.h linux-2.5-merge/include/linux/elf.h
--- linux-2.5/include/linux/elf.h	2003-10-02 18:12:43.000000000 +0200
+++ linux-2.5-merge/include/linux/elf.h	2004-02-25 17:06:01.000000000 +0100
@@ -164,6 +164,7 @@ typedef __s64	Elf64_Sxword;
 #define AT_CLKTCK 17	/* frequency at which times() increments */
 
 #define AT_SECURE 23   /* secure mode boolean */
+#define AT_NUMCPUS 24  /* number of running cpus */
 
 typedef struct dynamic{
   Elf32_Sword d_tag;
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/linux/pci_ids.h linux-2.5-merge/include/linux/pci_ids.h
--- linux-2.5/include/linux/pci_ids.h	2004-02-28 05:37:57.000000000 +0100
+++ linux-2.5-merge/include/linux/pci_ids.h	2004-02-25 17:06:01.000000000 +0100
@@ -1050,6 +1050,8 @@
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE	0x0085
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA	0x008e
 #define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3		0x00d1
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3S  		0x00e1
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE	0x00d5
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA	0x00e3
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE	0x00e5
diff -burpN -X /averell/home/lsrc/KDIFX linux-2.5/include/linux/vermagic.h linux-2.5-merge/include/linux/vermagic.h
--- linux-2.5/include/linux/vermagic.h	2003-02-16 01:10:07.000000000 +0100
+++ linux-2.5-merge/include/linux/vermagic.h	2004-02-25 17:06:01.000000000 +0100
@@ -15,9 +15,15 @@
 #ifndef MODULE_ARCH_VERMAGIC
 #define MODULE_ARCH_VERMAGIC ""
 #endif
+#ifdef ARCH_COMPILER_COMPATIBLE
+#define MODULE_COMPILER ""
+#else
+#define MODULE_COMPILER \
+	"gcc-" __stringify(__GNUC__) "." __stringify(__GNUC_MINOR__)
+#endif
 
 #define VERMAGIC_STRING 						\
 	UTS_RELEASE " "							\
 	MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT 			\
-	MODULE_ARCH_VERMAGIC 						\
-	"gcc-" __stringify(__GNUC__) "." __stringify(__GNUC_MINOR__)
+	MODULE_ARCH_VERMAGIC
+
