diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/defconfig linux-2.6.0test9-amd64/arch/x86_64/defconfig
--- linux-vanilla/arch/x86_64/defconfig	2003-09-28 10:54:53.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/defconfig	2003-10-25 23:18:39.000000000 +0200
@@ -59,7 +59,6 @@ CONFIG_X86_CPUID=y
 CONFIG_X86_IO_APIC=y
 CONFIG_X86_LOCAL_APIC=y
 CONFIG_MTRR=y
-# CONFIG_HUGETLB_PAGE is not set
 CONFIG_SMP=y
 # CONFIG_PREEMPT is not set
 CONFIG_K8_NUMA=y
@@ -79,9 +78,9 @@ CONFIG_SOFTWARE_SUSPEND=y
 #
 # ACPI (Advanced Configuration and Power Interface) Support
 #
-# CONFIG_ACPI_HT is not set
 CONFIG_ACPI=y
 CONFIG_ACPI_BOOT=y
+CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_SLEEP=y
 CONFIG_ACPI_SLEEP_PROC_FS=y
 CONFIG_ACPI_AC=y
@@ -94,11 +93,29 @@ CONFIG_ACPI_THERMAL=y
 CONFIG_ACPI_TOSHIBA=y
 CONFIG_ACPI_DEBUG=y
 CONFIG_ACPI_BUS=y
-CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_EC=y
 CONFIG_ACPI_POWER=y
 CONFIG_ACPI_PCI=y
 CONFIG_ACPI_SYSTEM=y
+CONFIG_ACPI_RELAXED_AML=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_PROC_INTF=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_24_API is not set
+CONFIG_CPU_FREQ_TABLE=y
+
+#
+# CPUFreq processor drivers
+#
+CONFIG_X86_POWERNOW_K8=y
 
 #
 # Bus options (PCI etc.)
@@ -246,6 +263,7 @@ CONFIG_BLK_DEV_SD=y
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -325,7 +343,9 @@ CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
-# CONFIG_LLC is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
 # CONFIG_NET_DIVERT is not set
@@ -358,7 +378,7 @@ CONFIG_NETDEVICES=y
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_NET_VENDOR_3COM is not set
@@ -388,7 +408,6 @@ CONFIG_8139TOO=m
 # CONFIG_SIS900 is not set
 # CONFIG_EPIC100 is not set
 # CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
 # CONFIG_VIA_RHINE is not set
 
 #
@@ -421,10 +440,10 @@ CONFIG_TIGON3=y
 # CONFIG_NET_RADIO is not set
 
 #
-# Token Ring devices (depends on LLC=y)
+# Token Ring devices
 #
+# CONFIG_TR is not set
 # CONFIG_NET_FC is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 
 #
@@ -443,6 +462,11 @@ CONFIG_TIGON3=y
 # CONFIG_IRDA is not set
 
 #
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
 # ISDN subsystem
 #
 # CONFIG_ISDN_BOOL is not set
@@ -485,6 +509,7 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_PS2_SYNAPTICS is not set
 # CONFIG_MOUSE_SERIAL is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
@@ -504,6 +529,7 @@ CONFIG_HW_CONSOLE=y
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
 # CONFIG_SERIAL_8250_ACPI is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
 # CONFIG_SERIAL_8250_EXTENDED is not set
 
 #
@@ -520,7 +546,11 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_I2C is not set
 
 #
-# I2C Hardware Sensors Mainboard support
+# I2C Algorithms
+#
+
+#
+# I2C Hardware Bus support
 #
 
 #
@@ -549,7 +579,6 @@ CONFIG_RTC=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
-# CONFIG_SONYPI is not set
 
 #
 # Ftape, the floppy tape device driver
@@ -559,6 +588,7 @@ CONFIG_AGP_AMD64=y
 # CONFIG_DRM is not set
 # CONFIG_MWAVE is not set
 CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=256
 CONFIG_HANGCHECK_TIMER=y
 
 #
@@ -619,10 +649,13 @@ CONFIG_ISO9660_FS=y
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
 # CONFIG_DEVFS_FS is not set
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
 
 #
@@ -647,6 +680,7 @@ CONFIG_RAMFS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
 # CONFIG_NFSD_V4 is not set
@@ -707,13 +741,15 @@ CONFIG_SOUND_PRIME=y
 # CONFIG_SOUND_MAESTRO is not set
 # CONFIG_SOUND_MAESTRO3 is not set
 CONFIG_SOUND_ICH=y
-# CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 # CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
 # CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
 # CONFIG_SOUND_ALI5455 is not set
 # CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_AD1980 is not set
 
 #
@@ -723,11 +759,6 @@ CONFIG_SOUND_ICH=y
 # CONFIG_USB_GADGET is not set
 
 #
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
 # Profiling support
 #
 CONFIG_PROFILING=y
@@ -760,4 +791,4 @@ CONFIG_MCE_DEBUG=y
 #
 # Library routines
 #
-# CONFIG_CRC32 is not set
+CONFIG_CRC32=y
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/ia32/syscall32.c linux-2.6.0test9-amd64/arch/x86_64/ia32/syscall32.c
--- linux-vanilla/arch/x86_64/ia32/syscall32.c	2003-08-23 01:57:17.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/ia32/syscall32.c	2003-10-25 23:19:43.000000000 +0200
@@ -30,10 +30,12 @@ char *syscall32_page; 
 int map_syscall32(struct mm_struct *mm, unsigned long address) 
 { 
 	pte_t *pte;
+	pmd_t *pmd;
 	int err = 0;
+
 	down_read(&mm->mmap_sem);
 	spin_lock(&mm->page_table_lock); 
-	pmd_t *pmd = pmd_alloc(mm, pgd_offset(mm, address), address); 
+	pmd = pmd_alloc(mm, pgd_offset(mm, address), address); 
 	if (pmd && (pte = pte_alloc_map(mm, pmd, address)) != NULL) { 
 		if (pte_none(*pte)) { 
 			set_pte(pte, 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/Makefile linux-2.6.0test9-amd64/arch/x86_64/kernel/Makefile
--- linux-vanilla/arch/x86_64/kernel/Makefile	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/Makefile	2003-11-09 23:15:50.000000000 +0100
@@ -18,13 +18,16 @@ obj-$(CONFIG_X86_LOCAL_APIC)	+= apic.o  
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o mpparse.o
 obj-$(CONFIG_PM)		+= suspend.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= suspend_asm.o
+obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_GART_IOMMU)	+= pci-gart.o aperture.o
 obj-$(CONFIG_DUMMY_IOMMU)	+= pci-nommu.o pci-dma.o
 
 obj-$(CONFIG_MODULES)		+= module.o
 
+obj-y				+= topology.o
+
 bootflag-y			+= ../../i386/kernel/bootflag.o
-cpuid-$(CONFIG_X86_CPUID)	+= ../../i386/kernel/cpuid.o
+cpuid-$(subst m,y,$(CONFIG_X86_CPUID))  += ../../i386/kernel/cpuid.o
+topology-y                     += ../../i386/mach-default/topology.o
 
-obj-$(CONFIG_CPU_FREQ)	+=	cpufreq/
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/acpi/boot.c linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/boot.c
--- linux-vanilla/arch/x86_64/kernel/acpi/boot.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/boot.c	2003-10-25 23:39:20.000000000 +0200
@@ -251,6 +251,33 @@ acpi_parse_hpet (
 } 
 #endif
 
+#ifdef CONFIG_ACPI_BUS
+/*
+ * Set specified PIC IRQ to level triggered mode.
+ *
+ * Port 0x4d0-4d1 are ECLR1 and ECLR2, the Edge/Level Control Registers
+ * for the 8259 PIC.  bit[n] = 1 means irq[n] is Level, otherwise Edge.
+ * ECLR1 is IRQ's 0-7 (IRQ 0, 1, 2 must be 0)
+ * ECLR2 is IRQ's 8-15 (IRQ 8, 13 must be 0)
+ *
+ * As the BIOS should have done this for us,
+ * print a warning if the IRQ wasn't already set to level.
+ */
+
+void acpi_pic_set_level_irq(unsigned int irq)
+{
+	unsigned char mask = 1 << (irq & 7);
+	unsigned int port = 0x4d0 + (irq >> 3);
+	unsigned char val = inb(port);
+
+	if (!(val & mask)) {
+		printk(KERN_WARNING PREFIX "IRQ %d was Edge Triggered, "
+			"setting to Level Triggerd\n", irq);
+		outb(val | mask, port);
+	}
+}
+#endif /* CONFIG_ACPI_BUS */
+
 static unsigned long __init
 acpi_scan_rsdp (
 	unsigned long		start,
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/acpi/sleep.c linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/sleep.c
--- linux-vanilla/arch/x86_64/kernel/acpi/sleep.c	2003-08-23 01:51:42.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/sleep.c	2003-10-25 23:20:22.000000000 +0200
@@ -56,6 +56,7 @@
 
 /* address in low memory of the wakeup routine. */
 unsigned long acpi_wakeup_address = 0;
+unsigned long acpi_video_flags;
 extern char wakeup_start, wakeup_end;
 
 extern unsigned long FASTCALL(acpi_copy_wakeup_routine(unsigned long));
@@ -116,6 +117,22 @@ void __init acpi_reserve_bootmem(void)
 	printk(KERN_DEBUG "ACPI: have wakeup address 0x%8.8lx\n", acpi_wakeup_address);
 }
 
+static int __init acpi_sleep_setup(char *str)
+{
+	while ((str != NULL) && (*str != '\0')) {
+		if (strncmp(str, "s3_bios", 7) == 0)
+			acpi_video_flags = 1;
+		if (strncmp(str, "s3_mode", 7) == 0)
+			acpi_video_flags |= 2;
+		str = strchr(str, ',');
+		if (str != NULL)
+			str += strspn(str, ", \t");
+	}
+	return 1;
+}
+
+__setup("acpi_sleep=", acpi_sleep_setup);
+
 #endif /*CONFIG_ACPI_SLEEP*/
 
 void acpi_pci_link_exit(void) {}
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/acpi/wakeup.S linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/wakeup.S
--- linux-vanilla/arch/x86_64/kernel/acpi/wakeup.S	2003-08-23 01:57:53.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/acpi/wakeup.S	2003-10-25 23:20:58.000000000 +0200
@@ -41,7 +41,19 @@ wakeup_code:
 	cmpl	$0x12345678, %eax
 	jne	bogus_real_magic
 
+	testl	$1, video_flags - wakeup_code
+	jz	1f
 	lcall   $0xc000,$3
+	movw	%cs, %ax
+	movw	%ax, %ds					# Bios might have played with that
+	movw	%ax, %ss
+1:
+
+	testl	$2, video_flags - wakeup_code
+	jz	1f
+	mov	video_mode - wakeup_code, %ax
+	call	mode_seta
+1:
 
  	movw	$0xb800, %ax
 	movw	%ax,%fs
@@ -250,6 +262,7 @@ real_save_gdt:	.word 0
 		.quad 0
 real_magic:	.quad 0
 video_mode:	.quad 0
+video_flags:	.quad 0
 
 bogus_real_magic:
 	movb	$0xba,%al	;  outb %al,$0x80		
@@ -382,8 +395,10 @@ ENTRY(acpi_copy_wakeup_routine)
 	movl	%eax, saved_efer
 	movl	%edx, saved_efer2
 
-#	movq	saved_videomode, %rdx				# FIXME:	 videomode
-	movq	%rdx, video_mode - wakeup_start (,%rdi)
+	movl	saved_video_mode, %edx
+	movl	%edx, video_mode - wakeup_start (,%rdi)
+	movl	acpi_video_flags, %edx
+	movl	%edx, video_flags - wakeup_start (,%rdi)
 	movq	$0x12345678, real_magic - wakeup_start (,%rdi)
 	movq	$0x123456789abcdef0, %rdx
 	movq	%rdx, saved_magic
@@ -415,8 +430,6 @@ do_suspend_lowlevel:
 .LFB5:
 	subq	$8, %rsp
 .LCFI2:
-	testl	%edi, %edi
-	jne	.L99
 	xorl	%eax, %eax
 	call	save_processor_state
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/apic.c linux-2.6.0test9-amd64/arch/x86_64/kernel/apic.c
--- linux-vanilla/arch/x86_64/kernel/apic.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/apic.c	2003-10-25 23:20:58.000000000 +0200
@@ -42,6 +42,8 @@ static DEFINE_PER_CPU(int, prof_multipli
 static DEFINE_PER_CPU(int, prof_old_multiplier) = 1;
 static DEFINE_PER_CPU(int, prof_counter) = 1;
 
+static void apic_pm_activate(void);
+
 void enable_NMI_through_LVT0 (void * dummy)
 {
 	unsigned int v, ver;
@@ -435,6 +437,7 @@ void __init setup_local_APIC (void)
 
 	if (nmi_watchdog == NMI_LOCAL_APIC)
 		setup_apic_nmi_watchdog();
+	apic_pm_activate();
 }
 
 #ifdef CONFIG_PM
@@ -556,7 +559,7 @@ device_initcall(init_lapic_sysfs);
 
 #else	/* CONFIG_PM */
 
-static inline void apic_pm_activate(void) { }
+static void apic_pm_activate(void) { }
 
 #endif	/* CONFIG_PM */
 
@@ -579,7 +582,6 @@ static int __init detect_init_APIC (void
 	if (nmi_watchdog != NMI_NONE)
 		nmi_watchdog = NMI_LOCAL_APIC;
 
-	apic_pm_activate();
 	return 0;
 }
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/bluesmoke.c linux-2.6.0test9-amd64/arch/x86_64/kernel/bluesmoke.c
--- linux-vanilla/arch/x86_64/kernel/bluesmoke.c	2003-08-23 01:59:34.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/bluesmoke.c	2003-10-25 23:19:43.000000000 +0200
@@ -200,11 +200,14 @@ static char *highbits[32] = { 
 static void check_k8_nb(int header)
 {
 	struct pci_dev *nb;
+	u32 statuslow, statushigh;
+	unsigned short errcode;
+	int i;
+
 	nb = find_k8_nb(); 
 	if (nb == NULL)
 		return;
 
-	u32 statuslow, statushigh;
 	pci_read_config_dword(nb, 0x48, &statuslow);
 	pci_read_config_dword(nb, 0x4c, &statushigh);
 	if (!(statushigh & (1<<31)))
@@ -215,7 +218,7 @@ static void check_k8_nb(int header)
 	printk(KERN_ERR "Northbridge status %08x%08x\n",
 	       statushigh,statuslow); 
 
-	unsigned short errcode = statuslow & 0xffff;	
+	errcode = statuslow & 0xffff;	
 	switch (errcode >> 8) { 
 	case 0: 					
 		printk(KERN_ERR "    GART TLB error %s %s\n", 
@@ -249,7 +252,6 @@ static void check_k8_nb(int header)
 	/* should only print when it was a HyperTransport related error. */
 	printk(KERN_ERR "    link number %x\n", (statushigh >> 4) & 3);
 
-	int i;
 	for (i = 0; i < 32; i++) 
 		if (highbits[i] && (statushigh & (1<<i)))
 			printk(KERN_ERR "    %s\n", highbits[i]); 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/entry.S linux-2.6.0test9-amd64/arch/x86_64/kernel/entry.S
--- linux-vanilla/arch/x86_64/kernel/entry.S	2003-09-28 10:54:54.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/entry.S	2003-11-07 19:20:37.000000000 +0100
@@ -219,8 +219,8 @@ tracesys:			 
 	movq %r10,%rcx	/* fixup for C */
 	call *sys_call_table(,%rax,8)
 	movq %rax,RAX-ARGOFFSET(%rsp)
-	SAVE_REST
-1:	movq %rsp,%rdi
+1:	SAVE_REST
+	movq %rsp,%rdi
 	call syscall_trace
 	RESTORE_TOP_OF_STACK %rbx
 	RESTORE_REST
@@ -566,8 +566,14 @@ error_kernelspace:
 	incl %ebx
        /* There are two places in the kernel that can potentially fault with
           usergs. Handle them here. The exception handlers after
-	  iret run with kernel gs again, so don't set the user space flag. */
-	cmpq $iret_label,RIP(%rsp) 
+	   iret run with kernel gs again, so don't set the user space flag.
+	   B stepping K8s sometimes report an truncated RIP for IRET 
+	   exceptions returning to compat mode. Check for these here too. */
+	leaq iret_label(%rip),%rbp
+	cmpq %rbp,RIP(%rsp) 
+	je   error_swapgs
+	movl %ebp,%ebp	/* zero extend */
+	cmpq %rbp,RIP(%rsp) 
 	je   error_swapgs
 	cmpq $gs_change,RIP(%rsp)
         je   error_swapgs
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/head.S linux-2.6.0test9-amd64/arch/x86_64/kernel/head.S
--- linux-vanilla/arch/x86_64/kernel/head.S	2003-08-23 01:57:24.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/head.S	2003-11-07 22:45:57.000000000 +0100
@@ -38,6 +38,9 @@ startup_32:
 
 	movl %ebx,%ebp	/* Save trampoline flag */
 	
+	movl $__KERNEL_DS,%eax
+	movl %eax,%ds
+	
 	/* If the CPU doesn't support CPUID this will double fault.
 	 * Unfortunately it is hard to check for CPUID without a stack. 
 	 */
@@ -114,25 +117,11 @@ reach_compatibility_mode:
 	movl	$(pGDT32 - __START_KERNEL_map), %eax
 	lgdt	(%eax)
 
+second:	
 	movl    $(ljumpvector - __START_KERNEL_map), %eax
 	/* Finally jump in 64bit mode */
 	ljmp	*(%eax)
 
-second:
-	/* abuse syscall to get into 64bit mode. this way we don't need
-	   a working low identity mapping just for the short 32bit roundtrip. 
-	   XXX kludge. this should not be needed. */
-	movl  $MSR_STAR,%ecx
-	xorl  %eax,%eax
-	movl  $(__USER32_CS<<16)|__KERNEL_CS,%edx
-	wrmsr
-
-	movl  $MSR_CSTAR,%ecx
-	movl  $0xffffffff,%edx
-	movl  $0x80100100,%eax	# reach_long64 absolute
-	wrmsr
-	syscall
-
 	.code64
 	.org 0x100	
 reach_long64:
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/io_apic.c linux-2.6.0test9-amd64/arch/x86_64/kernel/io_apic.c
--- linux-vanilla/arch/x86_64/kernel/io_apic.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/io_apic.c	2003-10-25 23:40:46.000000000 +0200
@@ -622,11 +622,13 @@ static inline int IO_APIC_irq_trigger(in
 	return 0;
 }
 
-int irq_vector[NR_IRQS] = { FIRST_DEVICE_VECTOR , 0 };
+/* irq_vectors is indexed by the sum of all RTEs in all I/O APICs. */
+u8 irq_vector[NR_IRQ_VECTORS] = { FIRST_DEVICE_VECTOR , 0 };
 
 static int __init assign_irq_vector(int irq)
 {
 	static int current_vector = FIRST_DEVICE_VECTOR, offset = 0;
+	BUG_ON(irq >= NR_IRQ_VECTORS);
 	if (IO_APIC_VECTOR(irq) > 0)
 		return IO_APIC_VECTOR(irq);
 next:
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/pci-gart.c linux-2.6.0test9-amd64/arch/x86_64/kernel/pci-gart.c
--- linux-vanilla/arch/x86_64/kernel/pci-gart.c	2003-09-28 10:54:54.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/pci-gart.c	2003-11-10 23:39:46.000000000 +0100
@@ -31,6 +31,9 @@
 #include <asm/kdebug.h>
 #include <asm/proto.h>
 
+/* Work around a bug in the mpt-fusion driver. */
+#define FUSION_WORKAROUND 1 
+
 dma_addr_t bad_dma_address;
 
 unsigned long iommu_bus_base;	/* GART remapping area (physical) */
@@ -44,12 +47,13 @@ static int no_agp; 
 #ifdef CONFIG_IOMMU_DEBUG
 int panic_on_overflow = 1; 
 int force_iommu = 1;
-int sac_force_size = 0; 
 #else
-int panic_on_overflow = 1; /* for testing */
+int panic_on_overflow = 0;
 int force_iommu = 0;
-int sac_force_size = 256*1024*1024;
 #endif
+int iommu_merge = 1; 
+int iommu_sac_force = 0; 
+int iommu_fullflush = 0;
 
 /* Allocation bitmap for the remapping area */ 
 static spinlock_t iommu_bitmap_lock = SPIN_LOCK_UNLOCKED;
@@ -152,6 +156,8 @@ static void __flush_gart(struct pci_dev 
 
 static inline void flush_gart(struct pci_dev *dev)
 { 
+	if (iommu_fullflush)
+		need_flush = 1;
 	if (need_flush)
 		__flush_gart(dev);
 } 
@@ -290,6 +296,10 @@ static inline int need_iommu(struct pci_
 	int mmu = high;
 	if (force_iommu) 
 		mmu = 1; 
+#ifdef FUSION_WORKAROUND
+	if (dev->vendor == PCI_VENDOR_ID_LSI_LOGIC)
+		mmu = 1; 
+#endif		
 	if (no_iommu) { 
 		if (high) 
 			panic("PCI-DMA: high address but no IOMMU.\n"); 
@@ -395,7 +405,7 @@ static int __pci_map_cont(struct scatter
 	for (i = start; i < stopat; i++) {
 		struct scatterlist *s = &sg[i];
 		unsigned long start_addr = s->dma_address;
-		BUG_ON(i > 0 && s->offset);
+		BUG_ON(i > start && s->offset);
 		if (i == start) {
 			*sout = *s; 
 			sout->dma_address = iommu_bus_base;
@@ -410,7 +420,6 @@ static int __pci_map_cont(struct scatter
 			addr += PAGE_SIZE;
 			iommu_page++;
 	} 
-		BUG_ON(i > 0 && addr % PAGE_SIZE); 
 	} 
 	BUG_ON(iommu_page - iommu_start != pages);	
 	return 0;
@@ -460,7 +469,7 @@ int pci_map_sg(struct pci_dev *dev, stru
 			struct scatterlist *ps = &sg[i-1];
 			/* Can only merge when the last chunk ends on a page 
 			   boundary. */
-			if (!force_iommu || !need || (i-1 > start && ps->offset) ||
+			if (!iommu_merge || !need || (i-1 > start && s->offset) ||
 			    (ps->offset + ps->length) % PAGE_SIZE) { 
 				if (pci_map_cont(sg, start, i, sg+out, pages, 
 						 need) < 0)
@@ -545,14 +554,12 @@ int pci_dma_supported(struct pci_dev *de
 
 	   Problem with this is that if we overflow the IOMMU area
 	   and return DAC as fallback address the device may not handle it correctly.
-	   As a compromise we only do this if the IOMMU area is >= 256MB 
-	   which should make overflow unlikely enough.
 	   
 	   As a special case some controllers have a 39bit address mode 
 	   that is as efficient as 32bit (aic79xx). Don't force SAC for these.
 	   Assume all masks <= 40 bits are of this type. Normally this doesn't
 	   make any difference, but gives more gentle handling of IOMMU overflow. */
-	if (force_iommu && (mask > 0xffffffffffULL) && (iommu_size >= sac_force_size)){ 
+	if (iommu_sac_force && (mask >= 0xffffffffffULL)) { 
 		printk(KERN_INFO "%s: Force SAC with mask %Lx\n", dev->slot_name,mask);
 		return 0; 
 	}
@@ -681,7 +688,7 @@ static int __init pci_iommu_init(void)
 	unsigned long iommu_start;
 	struct pci_dev *dev;
 		
-#ifndef CONFIG_AGP_AMD_8151
+#ifndef CONFIG_AGP_AMD64
 	no_agp = 1; 
 #else
 	/* Makefile puts PCI initialization via subsys_initcall first. */
@@ -777,7 +784,8 @@ static int __init pci_iommu_init(void)
 /* Must execute after PCI subsystem */
 fs_initcall(pci_iommu_init);
 
-/* iommu=[size][,noagp][,off][,force][,noforce][,leak][,memaper[=order]]
+/* iommu=[size][,noagp][,off][,force][,noforce][,leak][,memaper[=order]][,merge]
+         [,forcesac][,fullflush][,nomerge]
    size  set size of iommu (in bytes) 
    noagp don't initialize the AGP driver and use full aperture.
    off   don't use the IOMMU
@@ -785,6 +793,10 @@ fs_initcall(pci_iommu_init);
    memaper[=order] allocate an own aperture over RAM with size 32MB^order.  
    noforce don't force IOMMU usage. Default.
    force  Force IOMMU.
+   merge  Do SG merging. Implies force (experimental)  
+   nomerge Don't do SG merging.
+   forcesac For SAC mode for masks <40bits  (experimental)
+   fullflush Flush IOMMU on each allocation (for testing)
 */
 __init int iommu_setup(char *opt) 
 { 
@@ -810,6 +822,16 @@ __init int iommu_setup(char *opt) 
 		    panic_on_overflow = 1;
 	    if (!memcmp(p, "nopanic", 7))
 		    panic_on_overflow = 0;	    
+	    if (!memcmp(p, "merge", 5)) { 
+		    iommu_merge = 1;
+		    force_iommu = 1; 
+	    }
+	    if (!memcmp(p, "nomerge", 7))
+		    iommu_merge = 0;
+	    if (!memcmp(p, "forcesac", 8))
+		    iommu_sac_force = 1;
+	    if (!memcmp(p, "fullflush", 9))
+		    iommu_fullflush = 1;
 #ifdef CONFIG_IOMMU_LEAK
 	    if (!memcmp(p,"leak", 4)) { 
 		    leak_trace = 1;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/pci-nommu.c linux-2.6.0test9-amd64/arch/x86_64/kernel/pci-nommu.c
--- linux-vanilla/arch/x86_64/kernel/pci-nommu.c	2003-08-23 01:50:22.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/pci-nommu.c	2003-11-07 15:59:48.000000000 +0100
@@ -4,6 +4,8 @@
 #include <linux/string.h>
 #include <asm/proto.h>
 
+int iommu_merge = 0;
+
 /* 
  * Dummy IO MMU functions
  */
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/setup.c linux-2.6.0test9-amd64/arch/x86_64/kernel/setup.c
--- linux-vanilla/arch/x86_64/kernel/setup.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/setup.c	2003-10-25 23:19:43.000000000 +0200
@@ -332,6 +332,7 @@ __setup("noreplacement", noreplacement_s
 void __init setup_arch(char **cmdline_p)
 {
 	unsigned long low_mem_size;
+	unsigned long kernel_end;
 
  	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
  	drive_info = DRIVE_INFO;
@@ -380,7 +381,6 @@ void __init setup_arch(char **cmdline_p)
 				(table_end - table_start) << PAGE_SHIFT);
 
 	/* reserve kernel */
-	unsigned long kernel_end;
 	kernel_end = round_up(__pa_symbol(&_end),PAGE_SIZE);
 	reserve_bootmem_generic(HIGH_MEMORY, kernel_end - HIGH_MEMORY);
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/setup64.c linux-2.6.0test9-amd64/arch/x86_64/kernel/setup64.c
--- linux-vanilla/arch/x86_64/kernel/setup64.c	2003-08-23 01:53:44.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/setup64.c	2003-10-26 00:18:46.000000000 +0200
@@ -189,8 +189,7 @@ void pda_init(int cpu)
 	pda->irqstackptr += IRQSTACKSIZE-64;
 } 
 
-#define EXCEPTION_STK_ORDER 0 /* >= N_EXCEPTION_STACKS*EXCEPTION_STKSZ */
-char boot_exception_stacks[N_EXCEPTION_STACKS*EXCEPTION_STKSZ];
+char boot_exception_stacks[N_EXCEPTION_STACKS * EXCEPTION_STKSZ];
 
 void syscall_init(void)
 {
@@ -226,15 +225,12 @@ void __init cpu_init (void)
 #endif
 	struct tss_struct * t = &init_tss[cpu];
 	unsigned long v, efer; 
-	char *estacks; 
+	char *estacks = NULL; 
 	struct task_struct *me;
 
 	/* CPU 0 is initialised in head64.c */
 	if (cpu != 0) {
 		pda_init(cpu);
-		estacks = (char *)__get_free_pages(GFP_ATOMIC, 0); 
-		if (!estacks)
-			panic("Can't allocate exception stacks for CPU %d\n",cpu);
 	} else 
 		estacks = boot_exception_stacks; 
 
@@ -282,10 +278,15 @@ void __init cpu_init (void)
 	/*
 	 * set up and load the per-CPU TSS
 	 */
-	estacks += EXCEPTION_STKSZ;
 	for (v = 0; v < N_EXCEPTION_STACKS; v++) {
-		t->ist[v] = (unsigned long)estacks;
+		if (cpu) {
+			estacks = (char *)__get_free_pages(GFP_ATOMIC, 0);
+			if (!estacks)
+				panic("Cannot allocate exception stack %ld %d\n",
+				      v, cpu); 
+		}
 		estacks += EXCEPTION_STKSZ;
+		t->ist[v] = (unsigned long)estacks;
 	}
 
 	t->io_bitmap_base = INVALID_IO_BITMAP_OFFSET;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/smp.c linux-2.6.0test9-amd64/arch/x86_64/kernel/smp.c
--- linux-vanilla/arch/x86_64/kernel/smp.c	2003-08-23 01:53:15.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/smp.c	2003-10-25 23:35:55.000000000 +0200
@@ -487,25 +487,3 @@ asmlinkage void smp_call_function_interr
 		atomic_inc(&call_data->finished);
 	}
 }
-
-/* Slow. Should be only used for debugging. */
-int slow_smp_processor_id(void)
-{ 
-	int stack_location;
-	unsigned long sp = (unsigned long)&stack_location; 
-	int offset = 0, cpu;
-
-	for (offset = 0; next_cpu(offset, cpu_online_map) < NR_CPUS; offset = cpu + 1) {
-		cpu = next_cpu(offset, cpu_online_map);
-
-		if (sp >= (u64)cpu_pda[cpu].irqstackptr - IRQSTACKSIZE && 
-		    sp <= (u64)cpu_pda[cpu].irqstackptr)
-			return cpu;
-
-		unsigned long estack = init_tss[cpu].ist[0] - EXCEPTION_STKSZ;
-		if (sp >= estack && sp <= estack+(1<<(PAGE_SHIFT+EXCEPTION_STK_ORDER)))
-			return cpu;			
-	}
-
-	return stack_smp_processor_id();
-} 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/smpboot.c linux-2.6.0test9-amd64/arch/x86_64/kernel/smpboot.c
--- linux-vanilla/arch/x86_64/kernel/smpboot.c	2003-09-23 08:03:38.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/smpboot.c	2003-10-26 00:26:29.000000000 +0200
@@ -54,7 +54,7 @@
 #include <asm/proto.h>
 
 /* Bitmask of currently online CPUs */
-cpumask_t cpu_online_map;
+cpumask_t cpu_online_map = { 1 };
 
 static cpumask_t cpu_callin_map;
 cpumask_t cpu_callout_map;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/time.c linux-2.6.0test9-amd64/arch/x86_64/kernel/time.c
--- linux-vanilla/arch/x86_64/kernel/time.c	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/time.c	2003-10-26 01:20:04.000000000 +0200
@@ -111,6 +111,14 @@ void do_gettimeofday(struct timeval *tv)
 		sec = xtime.tv_sec;
 		usec = xtime.tv_nsec / 1000;
 
+		/*
+		 * If time_adjust is negative then NTP is slowing the clock
+		 * so make sure not to go into next possible interval.
+		 * Better to lose some accuracy than have time go backwards..
+		 */
+		if (unlikely(time_adjust < 0) && usec > tickadj)
+			usec = tickadj;
+
 		t = (jiffies - wall_jiffies) * (1000000L / HZ) +
 			do_gettimeoffset();
 		usec += t;
@@ -477,22 +485,28 @@ unsigned long get_cmos_time(void)
 static unsigned int  ref_freq = 0;
 static unsigned long loops_per_jiffy_ref = 0;
 
-//static unsigned long fast_gettimeoffset_ref = 0;
 static unsigned long cpu_khz_ref = 0;
 
 static int time_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
 				 void *data)
 {
         struct cpufreq_freqs *freq = data;
+	unsigned long *lpj;
+
+#ifdef CONFIG_SMP
+	lpj = &cpu_data[freq->cpu].loops_per_jiffy;
+#else
+	lpj = &boot_cpu_data.loops_per_jiffy;
+#endif
 
 	if (!ref_freq) {
 		ref_freq = freq->old;
-		loops_per_jiffy_ref = cpu_data[freq->cpu].loops_per_jiffy;
+		loops_per_jiffy_ref = *lpj;
 		cpu_khz_ref = cpu_khz;
 	}
         if ((val == CPUFREQ_PRECHANGE  && freq->old < freq->new) ||
             (val == CPUFREQ_POSTCHANGE && freq->old > freq->new)) {
-                cpu_data[freq->cpu].loops_per_jiffy =
+                *lpj =
 		cpufreq_scale(loops_per_jiffy_ref, ref_freq, freq->new);
 
 		cpu_khz = cpufreq_scale(cpu_khz_ref, ref_freq, freq->new);
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/x8664_ksyms.c linux-2.6.0test9-amd64/arch/x86_64/kernel/x8664_ksyms.c
--- linux-vanilla/arch/x86_64/kernel/x8664_ksyms.c	2003-08-23 01:52:53.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/kernel/x8664_ksyms.c	2003-10-26 20:23:18.000000000 +0100
@@ -71,6 +71,7 @@ EXPORT_SYMBOL_NOVERS(__down_failed_trylo
 EXPORT_SYMBOL_NOVERS(__up_wakeup);
 /* Networking helper routines. */
 EXPORT_SYMBOL(csum_partial_copy_nocheck);
+EXPORT_SYMBOL(ip_compute_csum);
 /* Delay loops */
 EXPORT_SYMBOL(__udelay);
 EXPORT_SYMBOL(__ndelay);
@@ -113,6 +114,7 @@ EXPORT_SYMBOL(mmx_clear_page);
 EXPORT_SYMBOL(mmx_copy_page);
 #endif
 
+EXPORT_SYMBOL(cpu_pda);
 #ifdef CONFIG_SMP
 EXPORT_SYMBOL(cpu_data);
 EXPORT_SYMBOL(cpu_online_map);
@@ -153,7 +155,7 @@ EXPORT_SYMBOL_GPL(unset_nmi_callback);
 
 extern void * memset(void *,int,__kernel_size_t);
 extern size_t strlen(const char *);
-extern char * bcopy(const char * src, char * dest, int count);
+extern void bcopy(const char * src, char * dest, int count);
 extern void * memmove(void * dest,const void *src,size_t count);
 extern char * strcpy(char * dest,const char *src);
 extern int strcmp(const char * cs,const char * ct);
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/extable.c linux-2.6.0test9-amd64/arch/x86_64/mm/extable.c
--- linux-vanilla/arch/x86_64/mm/extable.c	2003-08-23 02:00:23.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/mm/extable.c	2003-10-26 01:46:51.000000000 +0200
@@ -14,6 +14,10 @@ search_extable(const struct exception_ta
 	       const struct exception_table_entry *last,
 	       unsigned long value)
 {
+	/* Work around a B stepping K8 bug */
+	if ((value >> 32) == 0)
+		value |= 0xffffffffUL << 32; 
+
         while (first <= last) {
 		const struct exception_table_entry *mid;
 		long diff;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/fault.c linux-2.6.0test9-amd64/arch/x86_64/mm/fault.c
--- linux-vanilla/arch/x86_64/mm/fault.c	2003-09-28 10:54:54.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/mm/fault.c	2003-11-08 20:48:07.000000000 +0100
@@ -126,12 +126,6 @@ static int is_prefetch(struct pt_regs *r
 			break;
 		} 
 	}
-
-#if 1
-	if (prefetch)
-		printk("%s: prefetch caused page fault at %lx/%lx\n", current->comm,
-		       regs->rip, addr);
-#endif
 	return prefetch;
 }
 
@@ -241,6 +235,15 @@ asmlinkage void do_page_fault(struct pt_
 	if (unlikely(in_atomic() || !mm))
 		goto bad_area_nosemaphore;
 
+	/* Work around K8 erratum #100
+	   K8 in compat mode occasionally jumps to illegal addresses >4GB.
+	   We catch this here in the page fault handler because these
+	   addresses are not reachable. Just detect this case and return.
+	   Any code segment in LDT is compatibility mode. */
+	if ((regs->cs == __USER32_CS || (regs->cs & (1<<2))) &&
+		(address >> 32))
+		return;
+
  again:
 	down_read(&mm->mmap_sem);
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/k8topology.c linux-2.6.0test9-amd64/arch/x86_64/mm/k8topology.c
--- linux-vanilla/arch/x86_64/mm/k8topology.c	2003-08-23 02:01:50.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/mm/k8topology.c	2003-10-26 00:58:20.000000000 +0200
@@ -164,5 +164,8 @@ int __init k8_scan_nodes(unsigned long s
 		rr++; 
 	}
 
+	if (found == 1) 
+		fake_node = 1;
+
 	return 0;
 } 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/numa.c linux-2.6.0test9-amd64/arch/x86_64/mm/numa.c
--- linux-vanilla/arch/x86_64/mm/numa.c	2003-08-23 01:58:49.000000000 +0200
+++ linux-2.6.0test9-amd64/arch/x86_64/mm/numa.c	2003-10-25 23:36:21.000000000 +0200
@@ -104,6 +104,7 @@ void __init setup_node_bootmem(int nodei
 	if (nodeid + 1 > numnodes)
 		numnodes = nodeid + 1;
 	nodes_present |= (1UL << nodeid); 
+	node_set_online(nodeid);
 } 
 
 /* Initialize final allocator for a zone */
diff -burpN -X ../KDIFX linux-vanilla/drivers/char/agp/amd64-agp.c linux-2.6.0test9-amd64/drivers/char/agp/amd64-agp.c
--- linux-vanilla/drivers/char/agp/amd64-agp.c	2003-10-25 22:57:48.000000000 +0200
+++ linux-2.6.0test9-amd64/drivers/char/agp/amd64-agp.c	2003-11-11 00:42:08.000000000 +0100
@@ -35,9 +35,18 @@
 #define INVGART		(1<<0)
 #define GARTPTEERR	(1<<1)
 
+/* NVIDIA K8 registers */
+#define NVIDIA_X86_64_0_APBASE		0x10
+#define NVIDIA_X86_64_1_APBASE1		0x50
+#define NVIDIA_X86_64_1_APLIMIT1	0x54
+#define NVIDIA_X86_64_1_APSIZE		0xa8
+#define NVIDIA_X86_64_1_APBASE2		0xd8
+#define NVIDIA_X86_64_1_APLIMIT2	0xdc
+
 static int nr_garts;
 static struct pci_dev * hammers[MAX_HAMMER_GARTS];
 
+static struct resource *aperture_resource;
 static int __initdata agp_try_unsupported;
 
 static int gart_iterator;
@@ -250,7 +259,6 @@ struct agp_bridge_driver amd_8151_driver
 /* Some basic sanity checks for the aperture. */
 static int __devinit aperture_valid(u64 aper, u32 size)
 { 
-	static int not_first_call; 
 	u32 pfn, c;
 	if (aper == 0) { 
 		printk(KERN_ERR PFX "No aperture\n");
@@ -279,12 +287,11 @@ static int __devinit aperture_valid(u64 
 
 	   Maybe better to use pci_assign_resource/pci_enable_device instead trusting
 	   the bridges? */
-	if (!not_first_call && request_mem_region(aper, size, "aperture") < 0) { 
+	if (!aperture_resource && 
+	    !(aperture_resource = request_mem_region(aper, size, "aperture"))) {
 		printk(KERN_ERR PFX "Aperture conflicts with PCI mapping.\n"); 
 		return 0;
 	}
-
-	not_first_call = 1;
 	return 1;
 } 
 
@@ -365,13 +372,106 @@ static __devinit int cache_nbs (struct p
 	return i == 0 ? -1 : 0;
 }
 
+/* Handle AMD 8151 quirks */
+static void __devinit amd8151_init(struct pci_dev *pdev, struct agp_bridge_data *bridge)
+
+{		
+	char *revstring;
+	u8 rev_id;
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+	switch (rev_id) {
+	case 0x01: revstring="A0"; break;
+	case 0x02: revstring="A1"; break;
+	case 0x11: revstring="B0"; break;
+	case 0x12: revstring="B1"; break;
+	case 0x13: revstring="B2"; break;
+	default:   revstring="??"; break;
+	}
+
+	printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
+
+	/*
+	 * Work around errata.
+	 * Chips before B2 stepping incorrectly reporting v3.5
+	 */
+	if (rev_id < 0x13) {
+		printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
+		bridge->major_version = 3;
+		bridge->minor_version = 0;
+	}
+}
+
+static struct aper_size_info_32 nforce3_sizes[5] =
+{
+	{512,  131072, 7, 0x00000000 },
+	{256,  65536,  6, 0x00000008 },
+	{128,  32768,  5, 0x0000000C },
+	{64,   16384,  4, 0x0000000E },
+	{32,   8192,   3, 0x0000000F }
+};
+
+/* Handle shadow device of the Nvidia NForce3 */
+/* CHECK-ME original 2.4 version set up some IORRs. Check if that is needed. */
+static int __devinit nforce3_agp_init(struct pci_dev *pdev) 
+{ 
+	u32 tmp, apbase, apbar, aplimit;
+	struct pci_dev *dev1; 
+	int i;
+	unsigned size = amd64_fetch_size(); 
+
+	printk(KERN_INFO PFX "Setting up Nforce3 AGP.\n");
+
+	dev1 = pci_find_slot((unsigned int)pdev->bus->number, PCI_DEVFN(11, 0));
+	if (dev1 == NULL) {
+		printk(KERN_INFO PFX "agpgart: Detected an NVIDIA "
+			"nForce3 chipset, but could not find "
+			"the secondary device.\n");
+		return -ENODEV;
+	}	
+
+	for (i = 0; i < ARRAY_SIZE(nforce3_sizes); i++) 
+		if (nforce3_sizes[i].size == size)
+			break; 
+
+	if (i == ARRAY_SIZE(nforce3_sizes)) {
+		printk(KERN_INFO PFX "No NForce3 size found for %d\n", size); 
+		return -ENODEV; 
+	}
+	
+	pci_read_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, &tmp);
+	tmp &= ~(0xf);
+	tmp |= nforce3_sizes[i].size_value;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, tmp);
+
+	/* shadow x86-64 registers into NVIDIA registers */
+	pci_read_config_dword (hammers[0], AMD64_GARTAPERTUREBASE, &apbase);
+
+	/* if x86-64 aperture base is beyond 4G, exit here */
+	if ( (apbase & 0x7fff) >> (32 - 25) )
+		 return -ENODEV;
+
+	apbase = (apbase & 0x7fff) << 25;
+
+	pci_read_config_dword(pdev, NVIDIA_X86_64_0_APBASE, &apbar);
+	apbar &= ~PCI_BASE_ADDRESS_MEM_MASK;
+	apbar |= apbase;
+	pci_write_config_dword(pdev, NVIDIA_X86_64_0_APBASE, apbar);
+
+	aplimit = apbase + (size * 1024 * 1024) - 1;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE1, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT1, aplimit);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE2, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT2, aplimit);
+
+	return 0;
+} 
+
 static int __devinit agp_amd64_probe(struct pci_dev *pdev,
 				     const struct pci_device_id *ent)
 {
 	struct agp_bridge_data *bridge;
-	u8 rev_id;
 	u8 cap_ptr;
-	char *revstring=NULL;
 
 	cap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);
 	if (!cap_ptr)
@@ -385,32 +485,7 @@ static int __devinit agp_amd64_probe(str
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
 	    pdev->device == PCI_DEVICE_ID_AMD_8151_0) {
-
-		pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
-		switch (rev_id) {
-		case 0x01:	revstring="A0";
-				break;
-		case 0x02:	revstring="A1";
-				break;
-		case 0x11:	revstring="B0";
-				break;
-		case 0x12:	revstring="B1";
-				break;
-		case 0x13:	revstring="B2";
-				break;
-		default:	revstring="??";
-				break;
-		}
-		printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
-		/*
-		 * Work around errata.
-		 * Chips before B2 stepping incorrectly reporting v3.5
-		 */
-		if (rev_id < 0x13) {
-			printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
-			bridge->major_version = 3;
-			bridge->minor_version = 0;
-		}
+		amd8151_init(pdev, bridge);
 	} else {
 		printk(KERN_INFO PFX "Detected AGP bridge %x\n",
 			pdev->devfn);
@@ -428,6 +503,14 @@ static int __devinit agp_amd64_probe(str
 		return -ENODEV;
 	}
 
+	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA) { 
+		int ret = nforce3_agp_init(pdev);
+		if (ret) { 
+			agp_put_bridge(bridge); 
+			return ret;
+		}
+	}
+
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
 }
@@ -472,8 +555,25 @@ static struct pci_device_id agp_amd64_pc
 	{
 	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
 	.class_mask	= ~0,
-	.vendor		= PCI_VENDOR_ID_SI,
-	.device		= PCI_DEVICE_ID_SI_755,
+	.vendor		= PCI_VENDOR_ID_VIA,
+	.device		= PCI_DEVICE_ID_VIA_8380_0,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	/* NForce3 */
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3S,
 	.subvendor	= PCI_ANY_ID,
 	.subdevice	= PCI_ANY_ID,
 	},
@@ -530,6 +630,8 @@ int __init agp_amd64_init(void)
 
 static void __exit agp_amd64_cleanup(void)
 {
+	if (aperture_resource) 
+		release_resource(aperture_resource);
 	pci_unregister_driver(&agp_amd64_pci_driver);
 }
 
diff -burpN -X ../KDIFX linux-vanilla/drivers/char/drm/Kconfig linux-2.6.0test9-amd64/drivers/char/drm/Kconfig
--- linux-vanilla/drivers/char/drm/Kconfig	2003-09-28 10:54:55.000000000 +0200
+++ linux-2.6.0test9-amd64/drivers/char/drm/Kconfig	2003-11-08 14:30:26.000000000 +0100
@@ -64,10 +64,9 @@ config DRM_I830
 	  module will be called i830.  AGP support is required for this driver
 	  to work.
 
-
 config DRM_MGA
 	tristate "Matrox g200/g400"
-	depends on DRM && AGP
+	depends on DRM && AGP && (!X86_64 || BROKEN) 
 	help
 	  Choose this option if you have a Matrox G200, G400 or G450 graphics
 	  card.  If M is selected, the module will be called mga.  AGP
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/apic.h linux-2.6.0test9-amd64/include/asm-x86_64/apic.h
--- linux-vanilla/include/asm-x86_64/apic.h	2003-08-23 01:59:29.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/apic.h	2003-10-25 23:57:51.000000000 +0200
@@ -79,7 +79,7 @@ extern void disable_lapic_nmi_watchdog(v
 extern void enable_lapic_nmi_watchdog(void);
 extern void disable_timer_nmi_watchdog(void);
 extern void enable_timer_nmi_watchdog(void);
-extern inline void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
+extern void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
 extern int APIC_init_uniprocessor (void);
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/checksum.h linux-2.6.0test9-amd64/include/asm-x86_64/checksum.h
--- linux-vanilla/include/asm-x86_64/checksum.h	2003-08-23 01:58:02.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/checksum.h	2003-11-07 11:04:38.000000000 +0100
@@ -68,7 +68,8 @@ static inline unsigned short ip_fast_csu
 	   are modified, we must also specify them as outputs, or gcc
 	   will assume they contain their original values. */
 	: "=r" (sum), "=r" (iph), "=r" (ihl)
-	: "1" (iph), "2" (ihl));
+	: "1" (iph), "2" (ihl)
+	: "memory");
 	return(sum);
 }
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/cpu.h linux-2.6.0test9-amd64/include/asm-x86_64/cpu.h
--- linux-vanilla/include/asm-x86_64/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test9-amd64/include/asm-x86_64/cpu.h	2003-10-25 23:37:40.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/cpu.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/desc.h linux-2.6.0test9-amd64/include/asm-x86_64/desc.h
--- linux-vanilla/include/asm-x86_64/desc.h	2003-09-28 10:55:14.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/desc.h	2003-11-02 04:12:01.000000000 +0100
@@ -118,7 +118,7 @@ static inline void set_tssldt_descriptor
 	d.base1 = PTR_MIDDLE(tss) & 0xFF; 
 	d.type = type;
 	d.p = 1; 
-	d.limit1 = 0xF;
+	d.limit1 = (size >> 16) & 0xF;
 	d.base2 = (PTR_MIDDLE(tss) >> 8) & 0xFF; 
 	d.base3 = PTR_HIGH(tss); 
 	memcpy(ptr, &d, 16); 
@@ -190,7 +190,7 @@ static inline void load_TLS(struct threa
 /*
  * load one particular LDT into the current CPU
  */
-extern inline void load_LDT_nolock (mm_context_t *pc, int cpu)
+static inline void load_LDT_nolock (mm_context_t *pc, int cpu)
 {
 	int count = pc->size;
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/fixmap.h linux-2.6.0test9-amd64/include/asm-x86_64/fixmap.h
--- linux-vanilla/include/asm-x86_64/fixmap.h	2003-08-23 01:52:59.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/fixmap.h	2003-10-25 23:06:51.000000000 +0200
@@ -76,7 +76,7 @@ extern void __this_fixmap_does_not_exist
  * directly without translation, we catch the bug with a NULL-deference
  * kernel oops. Illegal ranges of incoming indices are caught too.
  */
-extern inline unsigned long fix_to_virt(const unsigned int idx)
+static inline unsigned long fix_to_virt(const unsigned int idx)
 {
 	/*
 	 * this branch gets completely eliminated after inlining,
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/hw_irq.h linux-2.6.0test9-amd64/include/asm-x86_64/hw_irq.h
--- linux-vanilla/include/asm-x86_64/hw_irq.h	2003-08-23 02:01:37.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/hw_irq.h	2003-10-25 23:52:47.000000000 +0200
@@ -76,8 +76,8 @@ struct hw_interrupt_type;
 
 
 #ifndef __ASSEMBLY__
-extern int irq_vector[NR_IRQS];
-#define IO_APIC_VECTOR(irq)	irq_vector[irq]
+extern u8 irq_vector[NR_IRQ_VECTORS];
+#define IO_APIC_VECTOR(irq)	((int)irq_vector[irq])
 
 /*
  * Various low-level irq details needed by irq.c, process.c,
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/io.h linux-2.6.0test9-amd64/include/asm-x86_64/io.h
--- linux-vanilla/include/asm-x86_64/io.h	2003-08-23 01:54:34.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/io.h	2003-11-07 12:00:29.000000000 +0100
@@ -52,7 +52,7 @@
  * Talk about misusing macros..
  */
 #define __OUT1(s,x) \
-extern inline void out##s(unsigned x value, unsigned short port) {
+static inline void out##s(unsigned x value, unsigned short port) {
 
 #define __OUT2(s,s1,s2) \
 __asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
@@ -62,7 +62,7 @@ __OUT1(s,x) __OUT2(s,s1,"w") : : "a" (va
 __OUT1(s##_p,x) __OUT2(s,s1,"w") __FULL_SLOW_DOWN_IO : : "a" (value), "Nd" (port));} \
 
 #define __IN1(s) \
-extern inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
+static inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
 
 #define __IN2(s,s1,s2) \
 __asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
@@ -72,12 +72,12 @@ __IN1(s) __IN2(s,s1,"w") : "=a" (_v) : "
 __IN1(s##_p) __IN2(s,s1,"w") __FULL_SLOW_DOWN_IO : "=a" (_v) : "Nd" (port) ,##i ); return _v; } \
 
 #define __INS(s) \
-extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+static inline void ins##s(unsigned short port, void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; ins" #s \
 : "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
 #define __OUTS(s) \
-extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+static inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; outs" #s \
 : "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
@@ -125,12 +125,12 @@ __OUTS(l)
  * Change virtual addresses to physical addresses and vv.
  * These are pretty trivial
  */
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 	return __pa(address);
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
 	return __va(address);
 }
@@ -148,7 +148,7 @@ extern inline void * phys_to_virt(unsign
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap (unsigned long offset, unsigned long size)
+static inline void * ioremap (unsigned long offset, unsigned long size)
 {
 	return __ioremap(offset, size, 0);
 }
@@ -304,8 +304,8 @@ out:
 /* Disable vmerge for now. Need to fix the block layer code
    to check for non iommu addresses first.
    When the IOMMU is force it is safe to enable. */
-extern int force_iommu; 
-#define BIO_VERMGE_BOUNDARY (force_iommu ? 4096 : 0)
+extern int iommu_merge;
+#define BIO_VMERGE_BOUNDARY (iommu_merge ? 4096 : 0)
 
 #endif /* __KERNEL__ */
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/irq.h linux-2.6.0test9-amd64/include/asm-x86_64/irq.h
--- linux-vanilla/include/asm-x86_64/irq.h	2003-08-23 01:50:19.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/irq.h	2003-10-25 23:53:28.000000000 +0200
@@ -22,6 +22,7 @@
  * the usable vector space is 0x20-0xff (224 vectors)
  */
 #define NR_IRQS 224
+#define NR_IRQ_VECTORS NR_IRQS
 
 static __inline__ int irq_canonicalize(int irq)
 {
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/memblk.h linux-2.6.0test9-amd64/include/asm-x86_64/memblk.h
--- linux-vanilla/include/asm-x86_64/memblk.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test9-amd64/include/asm-x86_64/memblk.h	2003-10-25 23:38:01.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/memblk.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/msr.h linux-2.6.0test9-amd64/include/asm-x86_64/msr.h
--- linux-vanilla/include/asm-x86_64/msr.h	2003-08-23 01:59:52.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/msr.h	2003-10-25 23:06:51.000000000 +0200
@@ -67,7 +67,7 @@
 			  : "=a" (low), "=d" (high) \
 			  : "c" (counter))
 
-extern inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
+static inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
 {
 	__asm__("cpuid"
 		: "=a" (*eax),
@@ -80,7 +80,7 @@ extern inline void cpuid(int op, int *ea
 /*
  * CPUID functions returning a single datum
  */
-extern inline unsigned int cpuid_eax(unsigned int op)
+static inline unsigned int cpuid_eax(unsigned int op)
 {
 	unsigned int eax;
 
@@ -90,7 +90,7 @@ extern inline unsigned int cpuid_eax(uns
 		: "bx", "cx", "dx");
 	return eax;
 }
-extern inline unsigned int cpuid_ebx(unsigned int op)
+static inline unsigned int cpuid_ebx(unsigned int op)
 {
 	unsigned int eax, ebx;
 
@@ -100,7 +100,7 @@ extern inline unsigned int cpuid_ebx(uns
 		: "cx", "dx" );
 	return ebx;
 }
-extern inline unsigned int cpuid_ecx(unsigned int op)
+static inline unsigned int cpuid_ecx(unsigned int op)
 {
 	unsigned int eax, ecx;
 
@@ -110,7 +110,7 @@ extern inline unsigned int cpuid_ecx(uns
 		: "bx", "dx" );
 	return ecx;
 }
-extern inline unsigned int cpuid_edx(unsigned int op)
+static inline unsigned int cpuid_edx(unsigned int op)
 {
 	unsigned int eax, edx;
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/node.h linux-2.6.0test9-amd64/include/asm-x86_64/node.h
--- linux-vanilla/include/asm-x86_64/node.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test9-amd64/include/asm-x86_64/node.h	2003-10-25 23:38:16.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/node.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pci.h linux-2.6.0test9-amd64/include/asm-x86_64/pci.h
--- linux-vanilla/include/asm-x86_64/pci.h	2003-08-23 01:54:57.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/pci.h	2003-10-25 23:53:53.000000000 +0200
@@ -24,6 +24,8 @@ extern unsigned long pci_mem_start;
 #define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		(pci_mem_start)
 
+#define PCIBIOS_MIN_CARDBUS_IO	0x4000
+
 void pcibios_config_init(void);
 struct pci_bus * pcibios_scan_root(int bus);
 extern int (*pci_config_read)(int seg, int bus, int dev, int fn, int reg, int len, u32 *value);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pgalloc.h linux-2.6.0test9-amd64/include/asm-x86_64/pgalloc.h
--- linux-vanilla/include/asm-x86_64/pgalloc.h	2003-08-23 01:56:24.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/pgalloc.h	2003-10-25 23:06:51.000000000 +0200
@@ -69,7 +69,7 @@ extern __inline__ void pte_free_kernel(p
 	free_page((unsigned long)pte); 
 }
 
-extern inline void pte_free(struct page *pte)
+static inline void pte_free(struct page *pte)
 {
 	__free_page(pte);
 } 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pgtable.h linux-2.6.0test9-amd64/include/asm-x86_64/pgtable.h
--- linux-vanilla/include/asm-x86_64/pgtable.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/pgtable.h	2003-10-25 23:06:51.000000000 +0200
@@ -71,7 +71,7 @@ extern unsigned long empty_zero_page[102
 #define pml4_none(x)	(!pml4_val(x))
 #define pgd_none(x)	(!pgd_val(x))
 
-extern inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
+static inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
 
 static inline void set_pte(pte_t *dst, pte_t val)
 {
@@ -88,7 +88,7 @@ static inline void set_pgd(pgd_t *dst, p
 	pgd_val(*dst) = pgd_val(val); 
 } 
 
-extern inline void pgd_clear (pgd_t * pgd)
+static inline void pgd_clear (pgd_t * pgd)
 {
 	set_pgd(pgd, __pgd(0));
 }
@@ -242,23 +242,23 @@ static inline pte_t pfn_pte(unsigned lon
  * Undefined behaviour if not..
  */
 static inline int pte_user(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
-extern inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
+static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
 static inline int pte_file(pte_t pte)		{ return pte_val(pte) & _PAGE_FILE; }
 
-extern inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
+static inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
 static inline  int ptep_test_and_clear_dirty(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_DIRTY, ptep); }
 static inline  int ptep_test_and_clear_young(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep); }
 static inline void ptep_set_wrprotect(pte_t *ptep)		{ clear_bit(_PAGE_BIT_RW, ptep); }
@@ -359,7 +359,7 @@ static inline pte_t mk_pte_phys(unsigned
 }
  
 /* Change flags of a PTE */
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 { 
 	pte_val(pte) &= _PAGE_CHG_MASK;
 	pte_val(pte) |= pgprot_val(newprot);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/processor.h linux-2.6.0test9-amd64/include/asm-x86_64/processor.h
--- linux-vanilla/include/asm-x86_64/processor.h	2003-09-28 10:55:14.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/processor.h	2003-10-26 00:18:46.000000000 +0200
@@ -263,8 +263,8 @@ struct thread_struct {
 #define DOUBLEFAULT_STACK 2 
 #define NMI_STACK 3 
 #define N_EXCEPTION_STACKS 3  /* hw limit: 7 */
-#define EXCEPTION_STKSZ 1024
-#define EXCEPTION_STK_ORDER 0
+#define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
+#define EXCEPTION_STACK_ORDER 0 
 
 #define start_thread(regs,new_rip,new_rsp) do { \
 	asm volatile("movl %0,%%fs; movl %0,%%es; movl %0,%%ds": :"r" (0));	 \
@@ -304,13 +304,13 @@ extern unsigned long get_wchan(struct ta
 #define KSTK_ESP(tsk) -1 /* sorry. doesn't work for syscall. */
 
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
-extern inline void rep_nop(void)
+static inline void rep_nop(void)
 {
 	__asm__ __volatile__("rep;nop": : :"memory");
 }
 
 /* Stop speculative execution */
-extern inline void sync_core(void)
+static inline void sync_core(void)
 { 
 	int tmp;
 	asm volatile("cpuid" : "=a" (tmp) : "0" (1) : "ebx","ecx","edx","memory");
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/smp.h linux-2.6.0test9-amd64/include/asm-x86_64/smp.h
--- linux-vanilla/include/asm-x86_64/smp.h	2003-09-23 08:03:57.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/smp.h	2003-10-25 23:35:35.000000000 +0200
@@ -74,15 +74,7 @@ extern __inline int hard_smp_processor_i
 	return GET_APIC_ID(*(unsigned int *)(APIC_BASE+APIC_ID));
 }
 
-extern int slow_smp_processor_id(void);
-
-extern inline int safe_smp_processor_id(void)
-{ 
-	if (disable_apic)
-		return slow_smp_processor_id(); 
-	else
-		return hard_smp_processor_id();
-} 
+#define safe_smp_processor_id() (cpuid_ebx(1) >> 24) 
 
 #define cpu_online(cpu) cpu_isset(cpu, cpu_online_map)
 #endif /* !ASSEMBLY */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/system.h linux-2.6.0test9-amd64/include/asm-x86_64/system.h
--- linux-vanilla/include/asm-x86_64/system.h	2003-09-23 08:03:57.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/system.h	2003-10-25 23:06:51.000000000 +0200
@@ -188,7 +188,7 @@ static inline void write_cr4(unsigned lo
 
 #define __xg(x) ((volatile long *)(x))
 
-extern inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
+static inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
 {
 	*ptr = val;
 }
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/topology.h linux-2.6.0test9-amd64/include/asm-x86_64/topology.h
--- linux-vanilla/include/asm-x86_64/topology.h	2003-09-23 08:03:57.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/topology.h	2003-10-26 02:10:39.000000000 +0200
@@ -10,13 +10,15 @@
 /* Map the K8 CPU local memory controllers to a simple 1:1 CPU:NODE topology */
 
 extern int fake_node;
+/* This is actually a cpumask_t, but doesn't matter because we don't have
+   >BITS_PER_LONG CPUs */
 extern unsigned long cpu_online_map;
 
 #define cpu_to_node(cpu)		(fake_node ? 0 : (cpu))
 #define memblk_to_node(memblk) 	(fake_node ? 0 : (memblk))
 #define parent_node(node)		(node)
 #define node_to_first_cpu(node) 	(fake_node ? 0 : (node))
-#define node_to_cpu_mask(node)	(fake_node ? cpu_online_map : (1UL << (node)))
+#define node_to_cpumask(node)	(fake_node ? cpu_online_map : (1UL << (node)))
 #define node_to_memblk(node)		(node)
 
 static inline unsigned long pcibus_to_cpumask(int bus)
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/uaccess.h linux-2.6.0test9-amd64/include/asm-x86_64/uaccess.h
--- linux-vanilla/include/asm-x86_64/uaccess.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test9-amd64/include/asm-x86_64/uaccess.h	2003-10-25 23:06:51.000000000 +0200
@@ -48,7 +48,7 @@
 
 #define access_ok(type,addr,size) (__range_not_ok(addr,size) == 0)
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size) ? 0 : -EFAULT;
 }
diff -burpN -X ../KDIFX linux-vanilla/include/linux/pci_ids.h linux-2.6.0test9-amd64/include/linux/pci_ids.h
--- linux-vanilla/include/linux/pci_ids.h	2003-09-23 08:03:58.000000000 +0200
+++ linux-2.6.0test9-amd64/include/linux/pci_ids.h	2003-11-11 00:03:41.000000000 +0100
@@ -1024,6 +1024,8 @@
 #define PCI_DEVICE_ID_NVIDIA_UVTNT2		0x002D
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2_IDE	0x0065
 #define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3		0x00d1
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3S  		0x00e1
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE_SDR	0x0100
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR	0x0101
 #define PCI_DEVICE_ID_NVIDIA_QUADRO		0x0103
