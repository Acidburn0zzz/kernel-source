diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/Kconfig linux-2.6.0test11-amd64/arch/x86_64/Kconfig
--- linux-vanilla/arch/x86_64/Kconfig	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/Kconfig	2003-11-25 22:27:12.000000000 +0100
@@ -505,6 +505,7 @@ config FRAME_POINTER
 	 Normally you should say N.
 
 config IOMMU_DEBUG
+       depends on GART_IOMMU && DEBUG_KERNEL
        bool "Force IOMMU to on" 
        help
          Force the IOMMU to on even when you have less than 4GB of memory and add 
@@ -519,13 +520,6 @@ config IOMMU_LEAK
          Add a simple leak tracer to the IOMMU code. This is useful when you
 	 are debugging a buggy device driver that leaks IOMMU mappings.
        
-config MCE_DEBUG
-       bool "K8 Machine check debugging mode"
-       default y 
-       help
-         Turn on all Machine Check debugging for device driver problems.	  
-	 This can cause panics, but is useful to find device driver problems.
-
 #config X86_REMOTE_DEBUG
 #       bool "kgdb debugging stub"
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/defconfig linux-2.6.0test11-amd64/arch/x86_64/defconfig
--- linux-vanilla/arch/x86_64/defconfig	2003-09-28 10:54:53.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/defconfig	2003-11-20 06:13:24.000000000 +0100
@@ -59,7 +59,6 @@ CONFIG_X86_CPUID=y
 CONFIG_X86_IO_APIC=y
 CONFIG_X86_LOCAL_APIC=y
 CONFIG_MTRR=y
-# CONFIG_HUGETLB_PAGE is not set
 CONFIG_SMP=y
 # CONFIG_PREEMPT is not set
 CONFIG_K8_NUMA=y
@@ -79,9 +78,9 @@ CONFIG_SOFTWARE_SUSPEND=y
 #
 # ACPI (Advanced Configuration and Power Interface) Support
 #
-# CONFIG_ACPI_HT is not set
 CONFIG_ACPI=y
 CONFIG_ACPI_BOOT=y
+CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_SLEEP=y
 CONFIG_ACPI_SLEEP_PROC_FS=y
 CONFIG_ACPI_AC=y
@@ -94,11 +93,29 @@ CONFIG_ACPI_THERMAL=y
 CONFIG_ACPI_TOSHIBA=y
 CONFIG_ACPI_DEBUG=y
 CONFIG_ACPI_BUS=y
-CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_EC=y
 CONFIG_ACPI_POWER=y
 CONFIG_ACPI_PCI=y
 CONFIG_ACPI_SYSTEM=y
+CONFIG_ACPI_RELAXED_AML=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_PROC_INTF=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_24_API is not set
+CONFIG_CPU_FREQ_TABLE=y
+
+#
+# CPUFreq processor drivers
+#
+CONFIG_X86_POWERNOW_K8=y
 
 #
 # Bus options (PCI etc.)
@@ -246,6 +263,7 @@ CONFIG_BLK_DEV_SD=y
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -325,7 +343,9 @@ CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
-# CONFIG_LLC is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
 # CONFIG_NET_DIVERT is not set
@@ -358,7 +378,7 @@ CONFIG_NETDEVICES=y
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_NET_VENDOR_3COM is not set
@@ -388,7 +408,6 @@ CONFIG_8139TOO=m
 # CONFIG_SIS900 is not set
 # CONFIG_EPIC100 is not set
 # CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
 # CONFIG_VIA_RHINE is not set
 
 #
@@ -421,10 +440,10 @@ CONFIG_TIGON3=y
 # CONFIG_NET_RADIO is not set
 
 #
-# Token Ring devices (depends on LLC=y)
+# Token Ring devices
 #
+# CONFIG_TR is not set
 # CONFIG_NET_FC is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 
 #
@@ -443,6 +462,11 @@ CONFIG_TIGON3=y
 # CONFIG_IRDA is not set
 
 #
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
 # ISDN subsystem
 #
 # CONFIG_ISDN_BOOL is not set
@@ -485,6 +509,7 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_PS2_SYNAPTICS is not set
 # CONFIG_MOUSE_SERIAL is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
@@ -504,6 +529,7 @@ CONFIG_HW_CONSOLE=y
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
 # CONFIG_SERIAL_8250_ACPI is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
 # CONFIG_SERIAL_8250_EXTENDED is not set
 
 #
@@ -520,7 +546,11 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_I2C is not set
 
 #
-# I2C Hardware Sensors Mainboard support
+# I2C Algorithms
+#
+
+#
+# I2C Hardware Bus support
 #
 
 #
@@ -549,7 +579,6 @@ CONFIG_RTC=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
-# CONFIG_SONYPI is not set
 
 #
 # Ftape, the floppy tape device driver
@@ -559,6 +588,7 @@ CONFIG_AGP_AMD64=y
 # CONFIG_DRM is not set
 # CONFIG_MWAVE is not set
 CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=256
 CONFIG_HANGCHECK_TIMER=y
 
 #
@@ -619,10 +649,13 @@ CONFIG_ISO9660_FS=y
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
 # CONFIG_DEVFS_FS is not set
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
 
 #
@@ -647,6 +680,7 @@ CONFIG_RAMFS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
 # CONFIG_NFSD_V4 is not set
@@ -707,13 +741,15 @@ CONFIG_SOUND_PRIME=y
 # CONFIG_SOUND_MAESTRO is not set
 # CONFIG_SOUND_MAESTRO3 is not set
 CONFIG_SOUND_ICH=y
-# CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 # CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
 # CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
 # CONFIG_SOUND_ALI5455 is not set
 # CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_AD1980 is not set
 
 #
@@ -723,11 +759,6 @@ CONFIG_SOUND_ICH=y
 # CONFIG_USB_GADGET is not set
 
 #
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
 # Profiling support
 #
 CONFIG_PROFILING=y
@@ -743,8 +774,7 @@ CONFIG_MAGIC_SYSRQ=y
 # CONFIG_INIT_DEBUG is not set
 # CONFIG_DEBUG_INFO is not set
 # CONFIG_FRAME_POINTER is not set
-CONFIG_IOMMU_DEBUG=y
-CONFIG_IOMMU_LEAK=y
+# CONFIG_IOMMU_DEBUG is not set
 CONFIG_MCE_DEBUG=y
 
 #
@@ -760,4 +790,4 @@ CONFIG_MCE_DEBUG=y
 #
 # Library routines
 #
-# CONFIG_CRC32 is not set
+CONFIG_CRC32=y
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/ia32/ia32_signal.c linux-2.6.0test11-amd64/arch/x86_64/ia32/ia32_signal.c
--- linux-vanilla/arch/x86_64/ia32/ia32_signal.c	2003-09-23 08:03:38.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/ia32/ia32_signal.c	2003-11-26 10:08:44.000000000 +0100
@@ -46,25 +46,25 @@ void signal_fault(struct pt_regs *regs, 
 
 static int ia32_copy_siginfo_to_user(siginfo_t32 *to, siginfo_t *from)
 {
+	int err;
 	if (!access_ok (VERIFY_WRITE, to, sizeof(siginfo_t)))
 		return -EFAULT;
-	if (from->si_code < 0) { 
-		/* the only field that's different is the alignment
-		   of the pointer in sigval_t. Move that 4 bytes down including
-		   padding. */
-		memmove(&((siginfo_t32 *)&from)->si_int,
-			&from->si_int, 
-			sizeof(siginfo_t) - offsetof(siginfo_t, si_int));
-		/* last 4 bytes stay the same */
-		return __copy_to_user(to, from, sizeof(siginfo_t32));
-	} else {
-		int err;
 
-		/* If you change siginfo_t structure, please be sure
+	/* If you change siginfo_t structure, please make sure that
 		   this code is fixed accordingly.
 		   It should never copy any pad contained in the structure
 		   to avoid security leaks, but must copy the generic
 		   3 ints plus the relevant union member.  */
+	
+	if (from->si_code < 0) {
+		err = __put_user(from->si_signo, &to->si_signo);
+		err |= __put_user(from->si_errno, &to->si_errno); 
+		err |= __put_user(from->si_code, &to->si_code); 
+		err |= __put_user(from->_sifields._rt._pid, &to->_sifields._rt._pid); 
+		err |= __put_user(from->_sifields._rt._uid, &to->_sifields._rt._uid); 
+		err |= __put_user((u32)(u64)from->_sifields._rt._sigval.sival_ptr, 
+				  &to->_sifields._rt._sigval.sival_ptr); 
+	} else {
 		err = __put_user(from->si_signo, &to->si_signo);
 		err |= __put_user(from->si_errno, &to->si_errno);
 		err |= __put_user(from->si_code, &to->si_code);
@@ -86,8 +86,8 @@ static int ia32_copy_siginfo_to_user(sig
 			break;
 		/* case __SI_RT: This is not generated by the kernel as of now.  */
 		}
-		return err;
 	}
+	return err;
 }
 
 asmlinkage long
@@ -173,6 +173,9 @@ ia32_restore_sigcontext(struct pt_regs *
 {
 	unsigned int err = 0;
 	
+	/* Always make any pending restarted system calls return -EINTR */
+	current_thread_info()->restart_block.fn = do_no_restart_syscall;
+	
 #if DEBUG_SIG
 	printk("SIG restore_sigcontext: sc=%p err(%x) eip(%x) cs(%x) flg(%x)\n",
 		sc, sc->err, sc->eip, sc->cs, sc->eflags);
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/ia32/ia32entry.S linux-2.6.0test11-amd64/arch/x86_64/ia32/ia32entry.S
--- linux-vanilla/arch/x86_64/ia32/ia32entry.S	2003-09-23 08:03:38.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/ia32/ia32entry.S	2003-11-20 17:39:24.000000000 +0100
@@ -330,10 +330,10 @@ ia32_sys_call_table:
 	.quad sys32_adjtimex
 	.quad sys32_mprotect		/* 125 */
 	.quad compat_sys_sigprocmask
-	.quad sys32_module_warning	/* create_module */
+	.quad quiet_ni_syscall		/* create_module */
 	.quad sys_init_module
 	.quad sys_delete_module
-	.quad sys32_module_warning	/* 130  get_kernel_syms */
+	.quad quiet_ni_syscall		/* 130  get_kernel_syms */
 	.quad ni_syscall	/* quotactl */ 
 	.quad sys_getpgid
 	.quad sys_fchdir
@@ -396,8 +396,8 @@ ia32_sys_call_table:
 	.quad stub32_vfork            /* 190 */
 	.quad compat_sys_getrlimit
 	.quad sys32_mmap2
-	.quad sys_truncate
-	.quad sys_ftruncate
+	.quad sys32_truncate64
+	.quad sys32_ftruncate64
 	.quad sys32_stat64		/* 195 */
 	.quad sys32_lstat64
 	.quad sys32_fstat64
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/ia32/sys_ia32.c linux-2.6.0test11-amd64/arch/x86_64/ia32/sys_ia32.c
--- linux-vanilla/arch/x86_64/ia32/sys_ia32.c	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/ia32/sys_ia32.c	2003-11-22 17:18:41.000000000 +0100
@@ -110,6 +110,21 @@ int cp_compat_stat(struct kstat *kbuf, s
 	return 0;
 }
 
+extern long sys_truncate(char *, loff_t); 
+extern long sys_ftruncate(int, loff_t); 
+
+asmlinkage long
+sys32_truncate64(char * filename, unsigned long offset_low, unsigned long offset_high)
+{
+       return sys_truncate(filename, ((loff_t) offset_high << 32) | offset_low);
+}
+
+asmlinkage long
+sys32_ftruncate64(unsigned int fd, unsigned long offset_low, unsigned long offset_high)
+{
+       return sys_ftruncate(fd, ((loff_t) offset_high << 32) | offset_low);
+}
+
 /* Another set for IA32/LFS -- x86_64 struct stat is different due to 
    support for 64bit inode numbers. */
 
@@ -1817,13 +1832,6 @@ long asmlinkage sys32_nfsservctl(int cmd
 }
 #endif
 
-long sys32_module_warning(void)
-{ 
-		printk(KERN_INFO "%s: 32bit 2.4.x modutils not supported on 64bit kernel\n",
-		       current->comm);
-	return -ENOSYS ;
-} 
-
 extern long sys_io_setup(unsigned nr_reqs, aio_context_t *ctx);
 
 long sys32_io_setup(unsigned nr_reqs, u32 *ctx32p)
@@ -1989,12 +1997,16 @@ long sys32_fadvise64_64(int fd, __u32 of
 
 long sys32_vm86_warning(void)
 { 
+	struct task_struct *me = current;
+	static char lastcomm[8];
+	if (strcmp(lastcomm, me->comm)) {
 		printk(KERN_INFO "%s: vm86 mode not supported on 64 bit kernel\n",
-		       current->comm);
-	return -ENOSYS ;
+		       me->comm);
+		strcpy(lastcomm, me->comm); 
+	} 
+	return -ENOSYS;
 } 
 
-
 struct exec_domain ia32_exec_domain = { 
 	.name = "linux/x86",
 	.pers_low = PER_LINUX32,
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/ia32/syscall32.c linux-2.6.0test11-amd64/arch/x86_64/ia32/syscall32.c
--- linux-vanilla/arch/x86_64/ia32/syscall32.c	2003-08-23 01:57:17.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/ia32/syscall32.c	2003-10-25 23:19:43.000000000 +0200
@@ -30,10 +30,12 @@ char *syscall32_page; 
 int map_syscall32(struct mm_struct *mm, unsigned long address) 
 { 
 	pte_t *pte;
+	pmd_t *pmd;
 	int err = 0;
+
 	down_read(&mm->mmap_sem);
 	spin_lock(&mm->page_table_lock); 
-	pmd_t *pmd = pmd_alloc(mm, pgd_offset(mm, address), address); 
+	pmd = pmd_alloc(mm, pgd_offset(mm, address), address); 
 	if (pmd && (pte = pte_alloc_map(mm, pmd, address)) != NULL) { 
 		if (pte_none(*pte)) { 
 			set_pte(pte, 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/Makefile linux-2.6.0test11-amd64/arch/x86_64/kernel/Makefile
--- linux-vanilla/arch/x86_64/kernel/Makefile	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/Makefile	2003-11-09 23:15:50.000000000 +0100
@@ -18,13 +18,16 @@ obj-$(CONFIG_X86_LOCAL_APIC)	+= apic.o  
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o mpparse.o
 obj-$(CONFIG_PM)		+= suspend.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= suspend_asm.o
+obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_GART_IOMMU)	+= pci-gart.o aperture.o
 obj-$(CONFIG_DUMMY_IOMMU)	+= pci-nommu.o pci-dma.o
 
 obj-$(CONFIG_MODULES)		+= module.o
 
+obj-y				+= topology.o
+
 bootflag-y			+= ../../i386/kernel/bootflag.o
-cpuid-$(CONFIG_X86_CPUID)	+= ../../i386/kernel/cpuid.o
+cpuid-$(subst m,y,$(CONFIG_X86_CPUID))  += ../../i386/kernel/cpuid.o
+topology-y                     += ../../i386/mach-default/topology.o
 
-obj-$(CONFIG_CPU_FREQ)	+=	cpufreq/
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/acpi/sleep.c linux-2.6.0test11-amd64/arch/x86_64/kernel/acpi/sleep.c
--- linux-vanilla/arch/x86_64/kernel/acpi/sleep.c	2003-08-23 01:51:42.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/acpi/sleep.c	2003-10-25 23:20:22.000000000 +0200
@@ -56,6 +56,7 @@
 
 /* address in low memory of the wakeup routine. */
 unsigned long acpi_wakeup_address = 0;
+unsigned long acpi_video_flags;
 extern char wakeup_start, wakeup_end;
 
 extern unsigned long FASTCALL(acpi_copy_wakeup_routine(unsigned long));
@@ -116,6 +117,22 @@ void __init acpi_reserve_bootmem(void)
 	printk(KERN_DEBUG "ACPI: have wakeup address 0x%8.8lx\n", acpi_wakeup_address);
 }
 
+static int __init acpi_sleep_setup(char *str)
+{
+	while ((str != NULL) && (*str != '\0')) {
+		if (strncmp(str, "s3_bios", 7) == 0)
+			acpi_video_flags = 1;
+		if (strncmp(str, "s3_mode", 7) == 0)
+			acpi_video_flags |= 2;
+		str = strchr(str, ',');
+		if (str != NULL)
+			str += strspn(str, ", \t");
+	}
+	return 1;
+}
+
+__setup("acpi_sleep=", acpi_sleep_setup);
+
 #endif /*CONFIG_ACPI_SLEEP*/
 
 void acpi_pci_link_exit(void) {}
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/acpi/wakeup.S linux-2.6.0test11-amd64/arch/x86_64/kernel/acpi/wakeup.S
--- linux-vanilla/arch/x86_64/kernel/acpi/wakeup.S	2003-08-23 01:57:53.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/acpi/wakeup.S	2003-10-25 23:20:58.000000000 +0200
@@ -41,7 +41,19 @@ wakeup_code:
 	cmpl	$0x12345678, %eax
 	jne	bogus_real_magic
 
+	testl	$1, video_flags - wakeup_code
+	jz	1f
 	lcall   $0xc000,$3
+	movw	%cs, %ax
+	movw	%ax, %ds					# Bios might have played with that
+	movw	%ax, %ss
+1:
+
+	testl	$2, video_flags - wakeup_code
+	jz	1f
+	mov	video_mode - wakeup_code, %ax
+	call	mode_seta
+1:
 
  	movw	$0xb800, %ax
 	movw	%ax,%fs
@@ -250,6 +262,7 @@ real_save_gdt:	.word 0
 		.quad 0
 real_magic:	.quad 0
 video_mode:	.quad 0
+video_flags:	.quad 0
 
 bogus_real_magic:
 	movb	$0xba,%al	;  outb %al,$0x80		
@@ -382,8 +395,10 @@ ENTRY(acpi_copy_wakeup_routine)
 	movl	%eax, saved_efer
 	movl	%edx, saved_efer2
 
-#	movq	saved_videomode, %rdx				# FIXME:	 videomode
-	movq	%rdx, video_mode - wakeup_start (,%rdi)
+	movl	saved_video_mode, %edx
+	movl	%edx, video_mode - wakeup_start (,%rdi)
+	movl	acpi_video_flags, %edx
+	movl	%edx, video_flags - wakeup_start (,%rdi)
 	movq	$0x12345678, real_magic - wakeup_start (,%rdi)
 	movq	$0x123456789abcdef0, %rdx
 	movq	%rdx, saved_magic
@@ -415,8 +430,6 @@ do_suspend_lowlevel:
 .LFB5:
 	subq	$8, %rsp
 .LCFI2:
-	testl	%edi, %edi
-	jne	.L99
 	xorl	%eax, %eax
 	call	save_processor_state
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/apic.c linux-2.6.0test11-amd64/arch/x86_64/kernel/apic.c
--- linux-vanilla/arch/x86_64/kernel/apic.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/apic.c	2003-10-25 23:20:58.000000000 +0200
@@ -42,6 +42,8 @@ static DEFINE_PER_CPU(int, prof_multipli
 static DEFINE_PER_CPU(int, prof_old_multiplier) = 1;
 static DEFINE_PER_CPU(int, prof_counter) = 1;
 
+static void apic_pm_activate(void);
+
 void enable_NMI_through_LVT0 (void * dummy)
 {
 	unsigned int v, ver;
@@ -435,6 +437,7 @@ void __init setup_local_APIC (void)
 
 	if (nmi_watchdog == NMI_LOCAL_APIC)
 		setup_apic_nmi_watchdog();
+	apic_pm_activate();
 }
 
 #ifdef CONFIG_PM
@@ -556,7 +559,7 @@ device_initcall(init_lapic_sysfs);
 
 #else	/* CONFIG_PM */
 
-static inline void apic_pm_activate(void) { }
+static void apic_pm_activate(void) { }
 
 #endif	/* CONFIG_PM */
 
@@ -579,7 +582,6 @@ static int __init detect_init_APIC (void
 	if (nmi_watchdog != NMI_NONE)
 		nmi_watchdog = NMI_LOCAL_APIC;
 
-	apic_pm_activate();
 	return 0;
 }
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/bluesmoke.c linux-2.6.0test11-amd64/arch/x86_64/kernel/bluesmoke.c
--- linux-vanilla/arch/x86_64/kernel/bluesmoke.c	2003-08-23 01:59:34.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/bluesmoke.c	2003-11-27 04:29:38.000000000 +0100
@@ -26,19 +26,6 @@ static unsigned long mce_cpus; 
 static int banks;
 static unsigned long ignored_banks, disabled_banks;
 
-/* Machine Check on everything dubious. This is a good setting
-   for device driver testing. */
-#define K8_DRIVER_DEBUG ((1<<13)-1)
-/* Report RAM errors and Hyper Transport Problems, but ignore Device
-   aborts and GART errors. */
-#define K8_NORMAL_OP    0xff
-
-#ifdef CONFIG_MCE_DEBUG
-static u32 k8_nb_flags __initdata = K8_DRIVER_DEBUG;
-#else
-static u32 k8_nb_flags __initdata = K8_NORMAL_OP;
-#endif
-
 static void generic_machine_check(struct pt_regs * regs, long error_code)
 {
 	int recover=1;
@@ -200,11 +187,14 @@ static char *highbits[32] = { 
 static void check_k8_nb(int header)
 {
 	struct pci_dev *nb;
+	u32 statuslow, statushigh;
+	unsigned short errcode;
+	int i;
+
 	nb = find_k8_nb(); 
 	if (nb == NULL)
 		return;
 
-	u32 statuslow, statushigh;
 	pci_read_config_dword(nb, 0x48, &statuslow);
 	pci_read_config_dword(nb, 0x4c, &statushigh);
 	if (!(statushigh & (1<<31)))
@@ -215,50 +205,42 @@ static void check_k8_nb(int header)
 	printk(KERN_ERR "Northbridge status %08x%08x\n",
 	       statushigh,statuslow); 
 
-	unsigned short errcode = statuslow & 0xffff;	
-	switch (errcode >> 8) { 
-	case 0: 					
+	printk(KERN_ERR "    Error %s\n", extendederr[(statuslow >> 16) & 0xf]); 
+
+	errcode = statuslow & 0xffff;	
+	switch ((statuslow >> 16) & 0xF) { 
+	case 5: 					
 		printk(KERN_ERR "    GART TLB error %s %s\n", 
 		       transaction[(errcode >> 2) & 3], 
 		       cachelevel[errcode & 3]);
 		break;
-	case 1: 
-		if (errcode & (1<<11)) { 
-			printk(KERN_ERR "    bus error %s %s %s %s %s\n",
-			       partproc[(errcode >> 10) & 0x3],
-			       timeout[(errcode >> 9) & 1],
+	case 8:
+		printk(KERN_ERR "    ECC error syndrome %x\n", 
+		       (((statuslow >> 24) & 0xff)  << 8) | ((statushigh >> 15) & 0x7f));		
+		/*FALL THROUGH*/
+	default:
+		printk(KERN_ERR "    bus error %s, %s\n    %s\n    %s, %s\n",
+		       partproc[(errcode >> 9) & 0x3],
+		       timeout[(errcode >> 8) & 1],
 			       memtrans[(errcode >> 4) & 0xf],
 			       memoryio[(errcode >> 2) & 0x3], 
 			       cachelevel[(errcode & 0x3)]); 
-		} else if (errcode & (1<<8)) { 
-			printk(KERN_ERR "    memory error %s %s %s\n",
-			       memtrans[(errcode >> 4) & 0xf],
-			       transaction[(errcode >> 2) & 0x3],
-			       cachelevel[(errcode & 0x3)]);
-		} else {
-			printk(KERN_ERR "    unknown error code %x\n", errcode); 
-		}
-		break;
-	} 
-	if (statushigh & ((1<<14)|(1<<13)))
-		printk(KERN_ERR "    ECC syndrome bits %x\n", 
-		       (((statuslow >> 24) & 0xff)  << 8) | ((statushigh >> 15) & 0x7f));
-	errcode = (statuslow >> 16) & 0xf;
-	printk(KERN_ERR "    extended error %s\n", extendederr[(statuslow >> 16) & 0xf]); 
-	
 	/* should only print when it was a HyperTransport related error. */
 	printk(KERN_ERR "    link number %x\n", (statushigh >> 4) & 3);
+ 		break;
+	} 
 
-	int i;
-	for (i = 0; i < 32; i++) 
+	for (i = 0; i < 32; i++) {
+		if (i == 26 || i == 28) 
+			continue;
 		if (highbits[i] && (statushigh & (1<<i)))
 			printk(KERN_ERR "    %s\n", highbits[i]); 
-
+	}
 	if (statushigh & (1<<26)) { 
 		u32 addrhigh, addrlow; 
 		pci_read_config_dword(nb, 0x54, &addrhigh); 
 		pci_read_config_dword(nb, 0x50, &addrlow); 
-		printk(KERN_ERR "    error address %08x%08x\n", addrhigh,addrlow); 
+		printk(KERN_ERR "    NB error address %08x%08x\n", addrhigh,addrlow); 
 	}
 	statushigh &= ~(1<<31); 
 	pci_write_config_dword(nb, 0x4c, statushigh); 		
@@ -307,9 +289,6 @@ static void k8_machine_check(struct pt_r
 	wrmsrl(MSR_IA32_MC0_STATUS+4*4, 0); 
 	wrmsrl(MSR_IA32_MCG_STATUS, 0);
        
-	if (regs && (status & (1<<1)))
-		printk(KERN_EMERG "MCE at RIP %lx RSP %lx\n", regs->rip, regs->rsp); 
-
  others:
 	generic_machine_check(regs, error_code); 
 
@@ -367,12 +346,13 @@ static void __init k8_mcheck_init(struct
 	machine_check_vector = k8_machine_check; 
 	for (i = 0; i < banks; i++) { 
 		u64 val = ((1UL<<i) & disabled_banks) ? 0 : ~0UL; 
-		if (val && i == 4) 
-			val = k8_nb_flags;
 		wrmsrl(MSR_IA32_MC0_CTL+4*i, val);
 		wrmsrl(MSR_IA32_MC0_STATUS+4*i,0); 
 	}
 
+	if (cap & (1<<8))
+		wrmsrl(MSR_IA32_MCG_CTL, 0xffffffffffffffffULL);
+
 	set_in_cr4(X86_CR4_MCE);	   	
 
 	if (mcheck_interval && (smp_processor_id() == 0)) { 
@@ -469,7 +449,6 @@ static int __init mcheck_disable(char *s
    mce=nok8 disable k8 specific features
    mce=disable<NUMBER> disable bank NUMBER
    mce=enable<NUMBER> enable bank number
-   mce=device	Enable device driver test reporting in NB
    mce=NUMBER mcheck timer interval number seconds. 
    Can be also comma separated in a single mce= */
 static int __init mcheck_enable(char *str)
@@ -486,8 +465,6 @@ static int __init mcheck_enable(char *st
 			disabled_banks |= ~(1<<simple_strtol(p+7,NULL,0));
 		else if (!strcmp(p,"nok8"))
 			nok8 = 1;
-		else if (!strcmp(p,"device"))
-			k8_nb_flags = K8_DRIVER_DEBUG;
 	}
 	return 0;
 }
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/e820.c linux-2.6.0test11-amd64/arch/x86_64/kernel/e820.c
--- linux-vanilla/arch/x86_64/kernel/e820.c	2003-08-23 01:53:43.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/e820.c	2003-11-12 01:48:29.000000000 +0100
@@ -2,10 +2,6 @@
  * Handle the memory map.
  * The functions here do the job until bootmem takes over.
  * $Id: e820.c,v 1.4 2002/09/19 19:25:32 ak Exp $
-
- * AK: some of these functions are not used in 2.5 yet but they will be when
- * NUMA is completely merged.
-
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/head.S linux-2.6.0test11-amd64/arch/x86_64/kernel/head.S
--- linux-vanilla/arch/x86_64/kernel/head.S	2003-08-23 01:57:24.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/head.S	2003-11-07 22:45:57.000000000 +0100
@@ -38,6 +38,9 @@ startup_32:
 
 	movl %ebx,%ebp	/* Save trampoline flag */
 	
+	movl $__KERNEL_DS,%eax
+	movl %eax,%ds
+	
 	/* If the CPU doesn't support CPUID this will double fault.
 	 * Unfortunately it is hard to check for CPUID without a stack. 
 	 */
@@ -114,25 +117,11 @@ reach_compatibility_mode:
 	movl	$(pGDT32 - __START_KERNEL_map), %eax
 	lgdt	(%eax)
 
+second:	
 	movl    $(ljumpvector - __START_KERNEL_map), %eax
 	/* Finally jump in 64bit mode */
 	ljmp	*(%eax)
 
-second:
-	/* abuse syscall to get into 64bit mode. this way we don't need
-	   a working low identity mapping just for the short 32bit roundtrip. 
-	   XXX kludge. this should not be needed. */
-	movl  $MSR_STAR,%ecx
-	xorl  %eax,%eax
-	movl  $(__USER32_CS<<16)|__KERNEL_CS,%edx
-	wrmsr
-
-	movl  $MSR_CSTAR,%ecx
-	movl  $0xffffffff,%edx
-	movl  $0x80100100,%eax	# reach_long64 absolute
-	wrmsr
-	syscall
-
 	.code64
 	.org 0x100	
 reach_long64:
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/io_apic.c linux-2.6.0test11-amd64/arch/x86_64/kernel/io_apic.c
--- linux-vanilla/arch/x86_64/kernel/io_apic.c	2003-11-24 21:39:24.000000000 +0100
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/io_apic.c	2003-11-11 19:44:57.000000000 +0100
@@ -147,6 +147,13 @@ void clear_IO_APIC_pin(unsigned int apic
 	struct IO_APIC_route_entry entry;
 	unsigned long flags;
 
+	/* Check delivery_mode to be sure we're not clearing an SMI pin */
+	spin_lock_irqsave(&ioapic_lock, flags);
+	*(((int*)&entry) + 0) = io_apic_read(apic, 0x10 + 2 * pin);
+	*(((int*)&entry) + 1) = io_apic_read(apic, 0x11 + 2 * pin);
+	spin_unlock_irqrestore(&ioapic_lock, flags);
+	if (entry.delivery_mode == dest_SMI)
+		return;
 	/*
 	 * Disable it in the IO-APIC irq-routing table:
 	 */
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/mpparse.c linux-2.6.0test11-amd64/arch/x86_64/kernel/mpparse.c
--- linux-vanilla/arch/x86_64/kernel/mpparse.c	2003-09-28 10:54:54.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/mpparse.c	2003-11-24 06:39:20.000000000 +0100
@@ -226,7 +226,7 @@ static int __init smp_read_mpc(struct mp
 	unsigned char *mpt=((unsigned char *)mpc)+count;
 
 	if (memcmp(mpc->mpc_signature,MPC_SIGNATURE,4)) {
-		panic("SMP mptable: bad signature [%c%c%c%c]!\n",
+		printk("SMP mptable: bad signature [%c%c%c%c]!\n",
 			mpc->mpc_signature[0],
 			mpc->mpc_signature[1],
 			mpc->mpc_signature[2],
@@ -234,7 +234,7 @@ static int __init smp_read_mpc(struct mp
 		return 0;
 	}
 	if (mpf_checksum((unsigned char *)mpc,mpc->mpc_length)) {
-		panic("SMP mptable: checksum error!\n");
+		printk("SMP mptable: checksum error!\n");
 		return 0;
 	}
 	if (mpc->mpc_spec!=0x01 && mpc->mpc_spec!=0x04) {
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/pci-gart.c linux-2.6.0test11-amd64/arch/x86_64/kernel/pci-gart.c
--- linux-vanilla/arch/x86_64/kernel/pci-gart.c	2003-11-24 21:39:24.000000000 +0100
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/pci-gart.c	2003-12-10 18:59:17.000000000 +0100
@@ -31,6 +31,10 @@
 #include <asm/kdebug.h>
 #include <asm/proto.h>
 
+/* Workarounds for specific drivers */
+#define FUSION_WORKAROUND 1 
+#define FLUSH_WORKAROUND 1
+
 dma_addr_t bad_dma_address;
 
 unsigned long iommu_bus_base;	/* GART remapping area (physical) */
@@ -44,12 +48,13 @@ static int no_agp; 
 #ifdef CONFIG_IOMMU_DEBUG
 int panic_on_overflow = 1; 
 int force_iommu = 1;
-int sac_force_size = 0; 
 #else
-int panic_on_overflow = 1; /* for testing */
+int panic_on_overflow = 0;
 int force_iommu = 0;
-int sac_force_size = 256*1024*1024;
 #endif
+int iommu_merge = 0; 
+int iommu_sac_force = 0; 
+int iommu_fullflush = 0;
 
 /* Allocation bitmap for the remapping area */ 
 static spinlock_t iommu_bitmap_lock = SPIN_LOCK_UNLOCKED;
@@ -125,7 +130,7 @@ static void free_iommu(unsigned long off
 /* 
  * Use global flush state to avoid races with multiple flushers.
  */
-static void __flush_gart(struct pci_dev *dev)
+static void flush_gart(struct pci_dev *dev)
 { 
 	unsigned long flags;
 	int bus = dev ? dev->bus->number : -1;
@@ -134,13 +139,17 @@ static void __flush_gart(struct pci_dev 
 	int i;
 
 	spin_lock_irqsave(&iommu_bitmap_lock, flags);
-	/* recheck flush count inside lock */
-	if (need_flush) { 
+	if (need_flush || iommu_fullflush) { 
 		for (i = 0; northbridges[i]; i++) {
+			u32 w;
 			if (bus >= 0 && !(cpu_isset_const(i, bus_cpumask)))
 				continue;
 			pci_write_config_dword(northbridges[i], 0x9c, 
 					       northbridge_flush_word[i] | 1); 
+			/* Make sure the hardware actually executed the flush. */
+			do { 
+				pci_read_config_dword(northbridges[i], 0x9c, &w);
+			} while (w & 1);
 			flushed++;
 		} 
 		if (!flushed) 
@@ -150,12 +159,6 @@ static void __flush_gart(struct pci_dev 
 	spin_unlock_irqrestore(&iommu_bitmap_lock, flags);
 } 
 
-static inline void flush_gart(struct pci_dev *dev)
-{ 
-	if (need_flush)
-		__flush_gart(dev);
-} 
-
 /* 
  * Allocate memory for a consistent mapping.
  * All mappings are consistent here, so this is just a wrapper around
@@ -174,11 +177,16 @@ void *pci_alloc_consistent(struct pci_de
 	} else {
 		dma_mask = hwdev->consistent_dma_mask; 
 	}
+
 	if (dma_mask == 0) 
 		dma_mask = 0xffffffff; 
 	if (dma_mask < 0xffffffff || no_iommu)
 		gfp |= GFP_DMA;
 
+	/* Kludge to make it bug-to-bug compatible with i386. i386
+	   uses the normal dma_mask for alloc_consistent. */
+	dma_mask &= hwdev->dma_mask;
+
 	memory = (void *)__get_free_pages(gfp, get_order(size));
 	if (memory == NULL) {
 		return NULL; 
@@ -381,6 +389,16 @@ static int pci_map_sg_nonforce(struct pc
 	return nents;
 }
 
+static void dump_sg(struct scatterlist *sg, int stopat)
+{
+	int k;
+	for (k = 0; k < stopat; k++) 
+		printk(KERN_EMERG "sg[%d] page:%p dma:%lx offset:%u length:%u\n",
+		       k,
+		       sg[k].page, (unsigned long)sg[k].dma_address, sg[k].offset,
+		       sg[k].length); 		
+}			   
+
 /* Map multiple scatterlist entries continuous into the first. */
 static int __pci_map_cont(struct scatterlist *sg, int start, int stopat, 
 		      struct scatterlist *sout, unsigned long pages)
@@ -394,7 +412,9 @@ static int __pci_map_cont(struct scatter
 	
 	for (i = start; i < stopat; i++) {
 		struct scatterlist *s = &sg[i];
-		unsigned long start_addr = s->dma_address;
+		unsigned long pages, addr;
+		unsigned long phys_addr = s->dma_address;
+		
 		BUG_ON(i > start && s->offset);
 		if (i == start) {
 			*sout = *s; 
@@ -403,15 +423,23 @@ static int __pci_map_cont(struct scatter
 		} else { 
 			sout->length += s->length; 
 		}
-		unsigned long addr = start_addr;
-		while (addr < start_addr + s->length) { 
+
+		addr = phys_addr;
+		pages = to_pages(s->offset, s->length); 
+		while (pages--) { 
 			iommu_gatt_base[iommu_page] = GPTE_ENCODE(addr); 
 			SET_LEAK(iommu_page);
 			addr += PAGE_SIZE;
 			iommu_page++;
 	} 
 	} 
-	BUG_ON(iommu_page - iommu_start != pages);	
+	if (iommu_page - iommu_start != pages) { 
+		printk(KERN_EMERG
+	      "iommu_page:%lx iommu_start:%lx pages:%lu start:%d stopat:%d\n",
+		       iommu_page, iommu_start, pages, start, stopat); 
+		dump_sg(sg, stopat); 	   
+		panic("IOMMU confused"); 
+	} 
 	return 0;
 }
 
@@ -437,7 +465,7 @@ int pci_map_sg(struct pci_dev *dev, stru
 	int out;
 	int start;
 	unsigned long pages = 0;
-	int need = 0;
+	int need = 0, nextneed;
 
 	unsigned long size = 0; 
 
@@ -453,13 +481,14 @@ int pci_map_sg(struct pci_dev *dev, stru
 		BUG_ON(s->length == 0); 
 
 		size += s->length; 
+		nextneed = need_iommu(dev, addr, s->length); 
 
 		/* Handle the previous not yet processed entries */
 		if (i > start) {
 			struct scatterlist *ps = &sg[i-1];
 			/* Can only merge when the last chunk ends on a page 
-			   boundary. */
-			if (!force_iommu || !need || (i-1 > start && ps->offset) ||
+			   boundary and the new one doesn't have an offset. */
+			if (!iommu_merge || !nextneed || !need || s->offset ||
 			    (ps->offset + ps->length) % PAGE_SIZE) { 
 				if (pci_map_cont(sg, start, i, sg+out, pages, 
 						 need) < 0)
@@ -470,7 +499,7 @@ int pci_map_sg(struct pci_dev *dev, stru
 			}
 	}
 
-		need = need_iommu(dev, addr, s->length); 
+		need = nextneed;
 		pages += to_pages(s->offset, s->length);
 	}
 	if (pci_map_cont(sg, start, i, sg+out, pages, need) < 0)
@@ -539,19 +568,30 @@ int pci_dma_supported(struct pci_dev *de
         if (mask < 0x00ffffff)
                 return 0;
 
+#ifdef FUSION_WORKAROUND
+	if (dev->vendor == PCI_VENDOR_ID_LSI_LOGIC && mask > 0xffffffff) { 
+		force_iommu = 1;
+		iommu_merge = 1; 
+		return 0; 
+	} 
+#endif
+#ifdef FLUSH_WORKAROUND
+	if ((dev->vendor == PCI_VENDOR_ID_3WARE && mask <= 0xffffffff) ||
+	    (dev->vendor == PCI_VENDOR_ID_QLOGIC && force_iommu))
+		iommu_fullflush = 1;
+#endif
+
 	/* Tell the device to use SAC when IOMMU force is on. 
 	   This allows the driver to use cheaper accesses in some cases.
 
 	   Problem with this is that if we overflow the IOMMU area
 	   and return DAC as fallback address the device may not handle it correctly.
-	   As a compromise we only do this if the IOMMU area is >= 256MB 
-	   which should make overflow unlikely enough.
 	   
 	   As a special case some controllers have a 39bit address mode 
 	   that is as efficient as 32bit (aic79xx). Don't force SAC for these.
 	   Assume all masks <= 40 bits are of this type. Normally this doesn't
 	   make any difference, but gives more gentle handling of IOMMU overflow. */
-	if (force_iommu && (mask > 0xffffffffffULL) && (iommu_size >= sac_force_size)){ 
+	if (iommu_sac_force && (mask >= 0xffffffffffULL)) { 
 		printk(KERN_INFO "%s: Force SAC with mask %Lx\n", dev->slot_name,mask);
 		return 0; 
 	}
@@ -680,7 +720,7 @@ static int __init pci_iommu_init(void)
 	unsigned long iommu_start;
 	struct pci_dev *dev;
 		
-#ifndef CONFIG_AGP_AMD_8151
+#ifndef CONFIG_AGP_AMD64
 	no_agp = 1; 
 #else
 	/* Makefile puts PCI initialization via subsys_initcall first. */
@@ -776,7 +816,8 @@ static int __init pci_iommu_init(void)
 /* Must execute after PCI subsystem */
 fs_initcall(pci_iommu_init);
 
-/* iommu=[size][,noagp][,off][,force][,noforce][,leak][,memaper[=order]]
+/* iommu=[size][,noagp][,off][,force][,noforce][,leak][,memaper[=order]][,merge]
+         [,forcesac][,fullflush][,nomerge]
    size  set size of iommu (in bytes) 
    noagp don't initialize the AGP driver and use full aperture.
    off   don't use the IOMMU
@@ -784,6 +825,10 @@ fs_initcall(pci_iommu_init);
    memaper[=order] allocate an own aperture over RAM with size 32MB^order.  
    noforce don't force IOMMU usage. Default.
    force  Force IOMMU.
+   merge  Do SG merging. Implies force (experimental)  
+   nomerge Don't do SG merging.
+   forcesac For SAC mode for masks <40bits  (experimental)
+   fullflush Flush IOMMU on each allocation (for testing)
 */
 __init int iommu_setup(char *opt) 
 { 
@@ -797,8 +842,10 @@ __init int iommu_setup(char *opt) 
 		    no_iommu = 1;
 	    if (!memcmp(p,"force", 5))
 		    force_iommu = 1;
-	    if (!memcmp(p,"noforce", 7))
+	    if (!memcmp(p,"noforce", 7)) { 
+		    iommu_merge = 0;
 		    force_iommu = 0;
+	    }
 	    if (!memcmp(p, "memaper", 7)) { 
 		    fallback_aper_force = 1; 
 		    p += 7; 
@@ -809,6 +856,16 @@ __init int iommu_setup(char *opt) 
 		    panic_on_overflow = 1;
 	    if (!memcmp(p, "nopanic", 7))
 		    panic_on_overflow = 0;	    
+	    if (!memcmp(p, "merge", 5)) { 
+		    iommu_merge = 1;
+		    force_iommu = 1; 
+	    }
+	    if (!memcmp(p, "nomerge", 7))
+		    iommu_merge = 0;
+	    if (!memcmp(p, "forcesac", 8))
+		    iommu_sac_force = 1;
+	    if (!memcmp(p, "fullflush", 9))
+		    iommu_fullflush = 1;
 #ifdef CONFIG_IOMMU_LEAK
 	    if (!memcmp(p,"leak", 4)) { 
 		    leak_trace = 1;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/pci-nommu.c linux-2.6.0test11-amd64/arch/x86_64/kernel/pci-nommu.c
--- linux-vanilla/arch/x86_64/kernel/pci-nommu.c	2003-08-23 01:50:22.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/pci-nommu.c	2003-11-07 15:59:48.000000000 +0100
@@ -4,6 +4,8 @@
 #include <linux/string.h>
 #include <asm/proto.h>
 
+int iommu_merge = 0;
+
 /* 
  * Dummy IO MMU functions
  */
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/process.c linux-2.6.0test11-amd64/arch/x86_64/kernel/process.c
--- linux-vanilla/arch/x86_64/kernel/process.c	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/process.c	2003-12-04 04:57:10.000000000 +0100
@@ -152,6 +152,19 @@ static int __init idle_setup (char *str)
 
 __setup("idle=", idle_setup);
 
+void idle_warning(void) 
+{ 
+	static int warned;
+	if (warned)
+		return; 
+	warned = 1;
+	if (boot_cpu_data.x86_vendor != X86_VENDOR_AMD) 
+		BUG();
+	printk(KERN_ERR "******* Your BIOS seems to not contain a fix for K8 errata #93\n"); 
+	printk(KERN_ERR "******* Working around it, but it will cost you a lot of power\n");
+	printk(KERN_ERR "******* Please consider a BIOS update.\n");
+	printk(KERN_ERR "******* Disabling USB legacy in the BIOS may also help.\n");
+} 
 
 /* Prints also some state that isn't saved in the pt_regs */ 
 void __show_regs(struct pt_regs * regs)
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/setup.c linux-2.6.0test11-amd64/arch/x86_64/kernel/setup.c
--- linux-vanilla/arch/x86_64/kernel/setup.c	2003-10-25 22:57:47.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/setup.c	2003-12-10 12:39:21.000000000 +0100
@@ -237,6 +237,9 @@ static __init void parse_cmdline_early (
 		}
 #endif
 
+		if (!memcmp(from,"oops=panic", 10))
+			panic_on_oops = 1;
+
 	next_char:
 		c = *(from++);
 		if (!c)
@@ -332,6 +335,7 @@ __setup("noreplacement", noreplacement_s
 void __init setup_arch(char **cmdline_p)
 {
 	unsigned long low_mem_size;
+	unsigned long kernel_end;
 
  	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
  	drive_info = DRIVE_INFO;
@@ -380,7 +384,6 @@ void __init setup_arch(char **cmdline_p)
 				(table_end - table_start) << PAGE_SHIFT);
 
 	/* reserve kernel */
-	unsigned long kernel_end;
 	kernel_end = round_up(__pa_symbol(&_end),PAGE_SIZE);
 	reserve_bootmem_generic(HIGH_MEMORY, kernel_end - HIGH_MEMORY);
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/signal.c linux-2.6.0test11-amd64/arch/x86_64/kernel/signal.c
--- linux-vanilla/arch/x86_64/kernel/signal.c	2003-08-23 01:57:56.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/signal.c	2003-11-25 01:31:57.000000000 +0100
@@ -93,6 +93,8 @@ restore_sigcontext(struct pt_regs *regs,
 {
 	unsigned int err = 0;
 
+	/* Always make any pending restarted system calls return -EINTR */
+	current_thread_info()->restart_block.fn = do_no_restart_syscall;
 
 #define COPY(x)		err |= __get_user(regs->x, &sc->x)
 
@@ -355,8 +357,6 @@ handle_signal(unsigned long sig, siginfo
 		/* If so, check system call restarting.. */
 		switch (regs->rax) {
 		        case -ERESTART_RESTARTBLOCK:
-				current_thread_info()->restart_block.fn = do_no_restart_syscall;
-				/* FALL THROUGH */
 			case -ERESTARTNOHAND:
 				regs->rax = -EINTR;
 				break;
@@ -371,10 +371,6 @@ handle_signal(unsigned long sig, siginfo
 				regs->rax = regs->orig_rax;
 				regs->rip -= 2;
 		}
-		if (regs->rax == (unsigned long)-ERESTART_RESTARTBLOCK){
-			regs->rax = __NR_restart_syscall;
- 			regs->rip -= 2;
- 		}		
 	}
 
 #ifdef CONFIG_IA32_EMULATION
@@ -453,6 +449,10 @@ int do_signal(struct pt_regs *regs, sigs
 			regs->rax = regs->orig_rax;
 			regs->rip -= 2;
 		}
+		if (regs->rax == (unsigned long)-ERESTART_RESTARTBLOCK) {
+			regs->rax = __NR_restart_syscall;
+			regs->rip -= 2;
+		}
 	}
 	return 0;
 }
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/smpboot.c linux-2.6.0test11-amd64/arch/x86_64/kernel/smpboot.c
--- linux-vanilla/arch/x86_64/kernel/smpboot.c	2003-09-23 08:03:38.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/smpboot.c	2003-10-26 00:26:29.000000000 +0200
@@ -54,7 +54,7 @@
 #include <asm/proto.h>
 
 /* Bitmask of currently online CPUs */
-cpumask_t cpu_online_map;
+cpumask_t cpu_online_map = { 1 };
 
 static cpumask_t cpu_callin_map;
 cpumask_t cpu_callout_map;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/time.c linux-2.6.0test11-amd64/arch/x86_64/kernel/time.c
--- linux-vanilla/arch/x86_64/kernel/time.c	2003-11-24 21:39:24.000000000 +0100
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/time.c	2003-12-10 16:04:57.000000000 +0100
@@ -111,13 +111,21 @@ void do_gettimeofday(struct timeval *tv)
 		sec = xtime.tv_sec;
 		usec = xtime.tv_nsec / 1000;
 
+#if 0
 		/*
 		 * If time_adjust is negative then NTP is slowing the clock
 		 * so make sure not to go into next possible interval.
 		 * Better to lose some accuracy than have time go backwards..
 		 */
-		if (unlikely(time_adjust < 0) && usec > tickadj)
-			usec = tickadj;
+		unsigned long lost = jiffies - wall_jiffies;
+		if (unlikely(time_adjust < 0)) {
+			unsigned long max_ntp_tick = tick_usec - tickadj;
+			usec = min_t(unsigned, usec, max_ntp_tick);
+			if (lost)
+				usec += lost * max_ntp_tick;
+		} else if (unlikely(lost))
+			usec += lost * tick_usec;
+#endif			
 
 		t = (jiffies - wall_jiffies) * (1000000L / HZ) +
 			do_gettimeoffset();
@@ -592,6 +600,7 @@ static int hpet_init(void)
 	if (!vxtime.hpet_address)
 		return -1;
 	set_fixmap_nocache(FIX_HPET_BASE, vxtime.hpet_address);
+	__set_fixmap(VSYSCALL_HPET, vxtime.hpet_address, PAGE_KERNEL_VSYSCALL_NOCACHE);
 
 /*
  * Read the period, compute tick and quotient.
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/traps.c linux-2.6.0test11-amd64/arch/x86_64/kernel/traps.c
--- linux-vanilla/arch/x86_64/kernel/traps.c	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/traps.c	2003-12-10 12:38:56.000000000 +0100
@@ -218,8 +218,12 @@ void show_stack(struct task_struct *tsk,
 	// debugging aid: "show_stack(NULL, NULL);" prints the
 	// back trace for this cpu.
 
-	if(rsp==NULL)
-		rsp=(unsigned long*)&rsp;
+	if (rsp == NULL) { 
+		if (tsk)
+			rsp = (unsigned long *)tsk->thread.rsp;
+		else
+			rsp = (unsigned long *)&rsp;
+	}
 
 	stack = rsp;
 	for(i=0; i < kstack_depth_to_print; i++) {
@@ -341,6 +345,8 @@ void oops_end(void)
 	bust_spinlocks(0); 
 	spin_unlock(&die_lock); 
 	local_irq_enable();	/* make sure back scroll still works */
+	if (panic_on_oops)
+		panic("Oops"); 
 } 
 
 void __die(const char * str, struct pt_regs * regs, long err)
@@ -844,3 +850,11 @@ void __init trap_init(void)
 	cpu_init();
 }
 
+
+/* Actual parsing is done early in setup.c. */
+static int __init oops_dummy(char *s)
+{ 
+	panic_on_oops = 1;
+	return -1; 
+} 
+__setup("oops=", oops_dummy); 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/vmlinux.lds.S linux-2.6.0test11-amd64/arch/x86_64/kernel/vmlinux.lds.S
--- linux-vanilla/arch/x86_64/kernel/vmlinux.lds.S	2003-09-23 08:03:38.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/vmlinux.lds.S	2003-11-28 13:09:00.000000000 +0100
@@ -62,7 +62,13 @@ SECTIONS
   .sysctl_vsyscall : AT ((LOADADDR(.sys_tz) + SIZEOF(.sys_tz) + 15) & ~(15)) { *(.sysctl_vsyscall) }
   sysctl_vsyscall = LOADADDR(.sysctl_vsyscall);
   . = ALIGN(16);
-  .jiffies : AT ((LOADADDR(.sysctl_vsyscall) + SIZEOF(.sysctl_vsyscall) + 15) & ~(15)) { *(.jiffies) }
+  .time_adjust : AT ((LOADADDR(.sysctl_vsyscall) + SIZEOF(.sysctl_vsyscall) + 16) & ~(15)) { *(.time_adjust) }
+  time_adjust = LOADADDR(.time_adjust);
+  . = ALIGN(16);
+  .tick_usec : AT ((LOADADDR(.time_adjust) + SIZEOF(.time_adjust) + 16) & ~(15)) { *(.tick_usec) }
+  tick_usec = LOADADDR(.tick_usec);	
+  . = ALIGN(16);
+  .jiffies : AT ((LOADADDR(.tick_usec) + SIZEOF(.tick_usec) + 16) & ~(15)) { *(.jiffies) }
   jiffies = LOADADDR(.jiffies);
   . = ALIGN(16);
   .xtime : AT ((LOADADDR(.jiffies) + SIZEOF(.jiffies) + 15) & ~(15)) { *(.xtime) }
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/vsyscall.c linux-2.6.0test11-amd64/arch/x86_64/kernel/vsyscall.c
--- linux-vanilla/arch/x86_64/kernel/vsyscall.c	2003-09-23 08:03:38.000000000 +0200
+++ linux-2.6.0test11-amd64/arch/x86_64/kernel/vsyscall.c	2003-12-03 06:11:57.000000000 +0100
@@ -49,12 +49,15 @@
 #include <asm/page.h>
 #include <asm/fixmap.h>
 #include <asm/errno.h>
+#include <asm/io.h>
 
 #define __vsyscall(nr) __attribute__ ((unused,__section__(".vsyscall_" #nr)))
 #define force_inline __attribute__((always_inline)) inline
 
 int __sysctl_vsyscall __section_sysctl_vsyscall = 1;
 seqlock_t __xtime_lock __section_xtime_lock = SEQLOCK_UNLOCKED;
+long __time_adjust __section_time_adjust; 
+long __tick_usec __section_tick_usec;
 
 #include <asm/unistd.h>
 
@@ -82,6 +85,22 @@ static force_inline void do_vgettimeofda
 		usec = (__xtime.tv_nsec / 1000) +
 			(__jiffies - __wall_jiffies) * (1000000 / HZ);
 
+#if 0
+		/*
+		 * If time_adjust is negative then NTP is slowing the clock
+		 * so make sure not to go into next possible interval.
+		 * Better to lose some accuracy than have time go backwards..
+		 */
+		unsigned long lost = __jiffies - __wall_jiffies;
+		if (unlikely(__time_adjust < 0)) {
+			unsigned long max_ntp_tick = __tick_usec - tickadj;
+			usec = min(usec, max_ntp_tick);
+			if (lost)
+				usec += lost * max_ntp_tick;
+		} else if (unlikely(lost))
+			usec += lost * __tick_usec;
+#endif			
+
 		if (__vxtime.mode == VXTIME_TSC) {
 			sync_core();
 			rdtscll(t);
@@ -89,10 +108,8 @@ static force_inline void do_vgettimeofda
 			usec += ((t - __vxtime.last_tsc) *
 				 __vxtime.tsc_quot) >> 32;
 		} else {
-#if 0
 			usec += ((readl(fix_to_virt(VSYSCALL_HPET) + 0xf0) -
 				  __vxtime.last) * __vxtime.quot) >> 32;
-#endif
 		}
 	} while (read_seqretry(&__xtime_lock, sequence));
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/fault.c linux-2.6.0test11-amd64/arch/x86_64/mm/fault.c
--- linux-vanilla/arch/x86_64/mm/fault.c	2003-11-24 21:39:24.000000000 +0100
+++ linux-2.6.0test11-amd64/arch/x86_64/mm/fault.c	2003-12-10 12:30:11.000000000 +0100
@@ -73,6 +73,9 @@ static int is_prefetch(struct pt_regs *r
 	if (regs->cs & (1<<2))
 		return 0;
 
+	if ((regs->cs & 3) != 0 && regs->rip >= TASK_SIZE)
+		return 0;
+
 	while (scan_more && instr < max_instr) { 
 		unsigned char opcode;
 		unsigned char instr_hi;
@@ -337,7 +340,8 @@ bad_area_nosemaphore:
 		}
        
 		tsk->thread.cr2 = address;
-		tsk->thread.error_code = error_code;
+		/* Kernel addresses are always protection faults */
+		tsk->thread.error_code = error_code | (address >= TASK_SIZE);
 		tsk->thread.trap_no = 14;
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
@@ -374,7 +378,7 @@ no_context:
 	printk_address(regs->rip);
 	dump_pagetable(address);
 	__die("Oops", regs, error_code);
-	/* Execute summary in case the body of the oops scrolled away */
+	/* Executive summary in case the body of the oops scrolled away */
 	printk(KERN_EMERG "CR2: %016lx\n", address);
 	oops_end(); 
 	do_exit(SIGKILL);
diff -burpN -X ../KDIFX linux-vanilla/drivers/char/agp/amd64-agp.c linux-2.6.0test11-amd64/drivers/char/agp/amd64-agp.c
--- linux-vanilla/drivers/char/agp/amd64-agp.c	2003-10-25 22:57:48.000000000 +0200
+++ linux-2.6.0test11-amd64/drivers/char/agp/amd64-agp.c	2003-11-30 22:45:19.000000000 +0100
@@ -16,11 +16,7 @@
 #include "agp.h"
 
 /* Will need to be increased if AMD64 ever goes >8-way. */
-#ifdef CONFIG_SMP
 #define MAX_HAMMER_GARTS   8
-#else
-#define MAX_HAMMER_GARTS   1
-#endif
 
 /* PTE bits. */
 #define GPTE_VALID	1
@@ -35,9 +31,18 @@
 #define INVGART		(1<<0)
 #define GARTPTEERR	(1<<1)
 
+/* NVIDIA K8 registers */
+#define NVIDIA_X86_64_0_APBASE		0x10
+#define NVIDIA_X86_64_1_APBASE1		0x50
+#define NVIDIA_X86_64_1_APLIMIT1	0x54
+#define NVIDIA_X86_64_1_APSIZE		0xa8
+#define NVIDIA_X86_64_1_APBASE2		0xd8
+#define NVIDIA_X86_64_1_APLIMIT2	0xdc
+
 static int nr_garts;
 static struct pci_dev * hammers[MAX_HAMMER_GARTS];
 
+static struct resource *aperture_resource;
 static int __initdata agp_try_unsupported;
 
 static int gart_iterator;
@@ -250,7 +255,6 @@ struct agp_bridge_driver amd_8151_driver
 /* Some basic sanity checks for the aperture. */
 static int __devinit aperture_valid(u64 aper, u32 size)
 { 
-	static int not_first_call; 
 	u32 pfn, c;
 	if (aper == 0) { 
 		printk(KERN_ERR PFX "No aperture\n");
@@ -279,12 +283,11 @@ static int __devinit aperture_valid(u64 
 
 	   Maybe better to use pci_assign_resource/pci_enable_device instead trusting
 	   the bridges? */
-	if (!not_first_call && request_mem_region(aper, size, "aperture") < 0) { 
+	if (!aperture_resource && 
+	    !(aperture_resource = request_mem_region(aper, size, "aperture"))) {
 		printk(KERN_ERR PFX "Aperture conflicts with PCI mapping.\n"); 
 		return 0;
 	}
-
-	not_first_call = 1;
 	return 1;
 } 
 
@@ -347,31 +350,124 @@ static __devinit int cache_nbs (struct p
 	/* cache pci_devs of northbridges. */
 	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) 
 			!= NULL) {
+		if (i == MAX_HAMMER_GARTS) { 
+			printk(KERN_ERR PFX "Too many northbridges for AGP\n");
+			return -1;
+		}
 		if (fix_northbridge(loop_dev, pdev, cap_ptr) < 0) { 
-			printk(KERN_INFO PFX "No usable aperture found.\n");
+			printk(KERN_ERR PFX "No usable aperture found.\n");
 #ifdef __x86_64__ 
 			/* should port this to i386 */
-			printk(KERN_INFO PFX "Consider rebooting with iommu=memaper=2 to get a good aperture.\n");
+			printk(KERN_ERR PFX "Consider rebooting with iommu=memaper=2 to get a good aperture.\n");
 #endif 
 			return -1;  
 		}
 		hammers[i++] = loop_dev;
+	}
 		nr_garts = i;
-		if (i == MAX_HAMMER_GARTS) { 
-			printk(KERN_INFO PFX "Too many northbridges for AGP\n");
-			return -1;
+	return i == 0 ? -1 : 0;
+}
+
+/* Handle AMD 8151 quirks */
+static void __devinit amd8151_init(struct pci_dev *pdev, struct agp_bridge_data *bridge)
+
+{		
+	char *revstring;
+	u8 rev_id;
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+	switch (rev_id) {
+	case 0x01: revstring="A0"; break;
+	case 0x02: revstring="A1"; break;
+	case 0x11: revstring="B0"; break;
+	case 0x12: revstring="B1"; break;
+	case 0x13: revstring="B2"; break;
+	default:   revstring="??"; break;
 		}
+
+	printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
+
+	/*
+	 * Work around errata.
+	 * Chips before B2 stepping incorrectly reporting v3.5
+	 */
+	if (rev_id < 0x13) {
+		printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
+		bridge->major_version = 3;
+		bridge->minor_version = 0;
 	}
-	return i == 0 ? -1 : 0;
+}
+
+static struct aper_size_info_32 nforce3_sizes[5] =
+{
+	{512,  131072, 7, 0x00000000 },
+	{256,  65536,  6, 0x00000008 },
+	{128,  32768,  5, 0x0000000C },
+	{64,   16384,  4, 0x0000000E },
+	{32,   8192,   3, 0x0000000F }
+};
+
+/* Handle shadow device of the Nvidia NForce3 */
+/* CHECK-ME original 2.4 version set up some IORRs. Check if that is needed. */
+static int __devinit nforce3_agp_init(struct pci_dev *pdev) 
+{ 
+	u32 tmp, apbase, apbar, aplimit;
+	struct pci_dev *dev1; 
+	int i;
+	unsigned size = amd64_fetch_size(); 
+
+	printk(KERN_INFO PFX "Setting up Nforce3 AGP.\n");
+
+	dev1 = pci_find_slot((unsigned int)pdev->bus->number, PCI_DEVFN(11, 0));
+	if (dev1 == NULL) {
+		printk(KERN_INFO PFX "agpgart: Detected an NVIDIA "
+			"nForce3 chipset, but could not find "
+			"the secondary device.\n");
+		return -ENODEV;
+	}	
+
+	for (i = 0; i < ARRAY_SIZE(nforce3_sizes); i++) 
+		if (nforce3_sizes[i].size == size)
+			break; 
+
+	if (i == ARRAY_SIZE(nforce3_sizes)) {
+		printk(KERN_INFO PFX "No NForce3 size found for %d\n", size); 
+		return -ENODEV; 
+	}
+	
+	pci_read_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, &tmp);
+	tmp &= ~(0xf);
+	tmp |= nforce3_sizes[i].size_value;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, tmp);
+
+	/* shadow x86-64 registers into NVIDIA registers */
+	pci_read_config_dword (hammers[0], AMD64_GARTAPERTUREBASE, &apbase);
+
+	/* if x86-64 aperture base is beyond 4G, exit here */
+	if ( (apbase & 0x7fff) >> (32 - 25) )
+		 return -ENODEV;
+
+	apbase = (apbase & 0x7fff) << 25;
+
+	pci_read_config_dword(pdev, NVIDIA_X86_64_0_APBASE, &apbar);
+	apbar &= ~PCI_BASE_ADDRESS_MEM_MASK;
+	apbar |= apbase;
+	pci_write_config_dword(pdev, NVIDIA_X86_64_0_APBASE, apbar);
+
+	aplimit = apbase + (size * 1024 * 1024) - 1;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE1, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT1, aplimit);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE2, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT2, aplimit);
+
+	return 0;
 }
 
 static int __devinit agp_amd64_probe(struct pci_dev *pdev,
 				     const struct pci_device_id *ent)
 {
 	struct agp_bridge_data *bridge;
-	u8 rev_id;
 	u8 cap_ptr;
-	char *revstring=NULL;
 
 	cap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);
 	if (!cap_ptr)
@@ -385,32 +481,7 @@ static int __devinit agp_amd64_probe(str
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
 	    pdev->device == PCI_DEVICE_ID_AMD_8151_0) {
-
-		pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
-		switch (rev_id) {
-		case 0x01:	revstring="A0";
-				break;
-		case 0x02:	revstring="A1";
-				break;
-		case 0x11:	revstring="B0";
-				break;
-		case 0x12:	revstring="B1";
-				break;
-		case 0x13:	revstring="B2";
-				break;
-		default:	revstring="??";
-				break;
-		}
-		printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
-		/*
-		 * Work around errata.
-		 * Chips before B2 stepping incorrectly reporting v3.5
-		 */
-		if (rev_id < 0x13) {
-			printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
-			bridge->major_version = 3;
-			bridge->minor_version = 0;
-		}
+		amd8151_init(pdev, bridge);
 	} else {
 		printk(KERN_INFO PFX "Detected AGP bridge %x\n",
 			pdev->devfn);
@@ -428,6 +499,14 @@ static int __devinit agp_amd64_probe(str
 		return -ENODEV;
 	}
 
+	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA) { 
+		int ret = nforce3_agp_init(pdev);
+		if (ret) { 
+			agp_put_bridge(bridge); 
+			return ret;
+		}
+	}
+
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
 }
@@ -472,8 +551,25 @@ static struct pci_device_id agp_amd64_pc
 	{
 	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
 	.class_mask	= ~0,
-	.vendor		= PCI_VENDOR_ID_SI,
-	.device		= PCI_DEVICE_ID_SI_755,
+	.vendor		= PCI_VENDOR_ID_VIA,
+	.device		= PCI_DEVICE_ID_VIA_8380_0,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	/* NForce3 */
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3S,
 	.subvendor	= PCI_ANY_ID,
 	.subdevice	= PCI_ANY_ID,
 	},
@@ -530,6 +626,8 @@ int __init agp_amd64_init(void)
 
 static void __exit agp_amd64_cleanup(void)
 {
+	if (aperture_resource) 
+		release_resource(aperture_resource);
 	pci_unregister_driver(&agp_amd64_pci_driver);
 }
 
diff -burpN -X ../KDIFX linux-vanilla/drivers/char/drm/Kconfig linux-2.6.0test11-amd64/drivers/char/drm/Kconfig
--- linux-vanilla/drivers/char/drm/Kconfig	2003-09-28 10:54:55.000000000 +0200
+++ linux-2.6.0test11-amd64/drivers/char/drm/Kconfig	2003-11-08 14:30:26.000000000 +0100
@@ -64,10 +64,9 @@ config DRM_I830
 	  module will be called i830.  AGP support is required for this driver
 	  to work.
 
-
 config DRM_MGA
 	tristate "Matrox g200/g400"
-	depends on DRM && AGP
+	depends on DRM && AGP && (!X86_64 || BROKEN) 
 	help
 	  Choose this option if you have a Matrox G200, G400 or G450 graphics
 	  card.  If M is selected, the module will be called mga.  AGP
diff -burpN -X ../KDIFX linux-vanilla/include/asm-generic/statfs.h linux-2.6.0test11-amd64/include/asm-generic/statfs.h
--- linux-vanilla/include/asm-generic/statfs.h	2003-08-23 01:56:23.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-generic/statfs.h	2003-11-24 05:47:25.000000000 +0100
@@ -34,4 +34,18 @@ struct statfs64 {
 	__u32 f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif
diff -burpN -X ../KDIFX linux-vanilla/include/asm-ia64/statfs.h linux-2.6.0test11-amd64/include/asm-ia64/statfs.h
--- linux-vanilla/include/asm-ia64/statfs.h	2003-08-23 01:56:27.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-ia64/statfs.h	2003-11-24 21:45:06.000000000 +0100
@@ -43,5 +43,18 @@ struct statfs64 {
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
 
 #endif /* _ASM_IA64_STATFS_H */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-mips/statfs.h linux-2.6.0test11-amd64/include/asm-mips/statfs.h
--- linux-vanilla/include/asm-mips/statfs.h	2003-08-23 01:57:19.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-mips/statfs.h	2003-11-24 21:45:24.000000000 +0100
@@ -75,6 +75,20 @@ struct statfs64 {			/* Same as struct st
 	long		f_spare[6];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI64 */
 
 #endif /* _ASM_STATFS_H */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-parisc/statfs.h linux-2.6.0test11-amd64/include/asm-parisc/statfs.h
--- linux-vanilla/include/asm-parisc/statfs.h	2003-08-23 01:58:14.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-parisc/statfs.h	2003-11-24 21:45:36.000000000 +0100
@@ -41,4 +41,18 @@ struct statfs64 {
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif
diff -burpN -X ../KDIFX linux-vanilla/include/asm-ppc64/statfs.h linux-2.6.0test11-amd64/include/asm-ppc64/statfs.h
--- linux-vanilla/include/asm-ppc64/statfs.h	2003-08-23 01:57:48.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-ppc64/statfs.h	2003-11-24 21:45:47.000000000 +0100
@@ -44,4 +44,18 @@ struct statfs64 {
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif  /* _PPC64_STATFS_H */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-s390/statfs.h linux-2.6.0test11-amd64/include/asm-s390/statfs.h
--- linux-vanilla/include/asm-s390/statfs.h	2003-08-23 02:01:55.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-s390/statfs.h	2003-11-24 21:45:58.000000000 +0100
@@ -53,5 +53,19 @@ struct statfs64 {
 	int  f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif /* __s390x__ */
 #endif
diff -burpN -X ../KDIFX linux-vanilla/include/asm-sparc64/statfs.h linux-2.6.0test11-amd64/include/asm-sparc64/statfs.h
--- linux-vanilla/include/asm-sparc64/statfs.h	2003-08-23 01:55:42.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-sparc64/statfs.h	2003-11-24 21:46:12.000000000 +0100
@@ -38,4 +38,18 @@ struct statfs64 {
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/acpi.h linux-2.6.0test11-amd64/include/asm-x86_64/acpi.h
--- linux-vanilla/include/asm-x86_64/acpi.h	2003-08-23 01:57:46.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/acpi.h	2003-12-10 16:15:52.000000000 +0100
@@ -52,40 +52,36 @@
 #define ACPI_ENABLE_IRQS()  local_irq_enable()
 #define ACPI_FLUSH_CPU_CACHE()	wbinvd()
 
-/*
- * A brief explanation as GNU inline assembly is a bit hairy
- *  %0 is the output parameter in RAX ("=a")
- *  %1 and %2 are the input parameters in RCX ("c")
- *  and an immediate value ("i") respectively
- *  All actual register references are preceded with "%%" as in "%%edx"
- *  Immediate values in the assembly are preceded by "$" as in "$0x1"
- *  The final asm parameter are the operation altered non-output registers.
- */
+
+static inline int
+__acpi_acquire_global_lock (unsigned int *lock)
+{
+	unsigned int old, new, val;
+	do {
+		old = *lock;
+		new = (((old & ~0x3) + 2) + ((old >> 1) & 0x1));
+		val = cmpxchg4_locked(lock, new, old);
+	} while (unlikely (val != old));
+	return (new < 3) ? -1 : 0;
+}
+
+static inline int
+__acpi_release_global_lock (unsigned int *lock)
+{
+	unsigned int old, new, val;
+	do {
+		old = *lock;
+		new = old & ~0x3;
+		val = cmpxchg4_locked(lock, new, old);
+	} while (unlikely (val != old));
+	return old & 0x1;
+}
+
 #define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		unsigned long dummy; \
-		asm("1:     movl (%2),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andq   %2,%%rdx;" \
-			"btsl   $0x1,%%edx;" \
-			"adcl   $0x0,%%edx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"cmpb   $0x3,%%dl;" \
-			"sbbl   %%eax,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~1L):"dx"); \
-	} while(0)
+	((Acq) = __acpi_acquire_global_lock((unsigned int *) GLptr))
+
 #define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		unsigned long dummy; \
-		asm("1:     movl (%2),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andq   %2,%%rdx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"andl   $0x1,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~3L):"dx"); \
-	} while(0)
+	((Acq) = __acpi_release_global_lock((unsigned int *) GLptr))
 
 /*
  * Math helper asm macros
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/apic.h linux-2.6.0test11-amd64/include/asm-x86_64/apic.h
--- linux-vanilla/include/asm-x86_64/apic.h	2003-08-23 01:59:29.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/apic.h	2003-10-25 23:57:51.000000000 +0200
@@ -79,7 +79,7 @@ extern void disable_lapic_nmi_watchdog(v
 extern void enable_lapic_nmi_watchdog(void);
 extern void disable_timer_nmi_watchdog(void);
 extern void enable_timer_nmi_watchdog(void);
-extern inline void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
+extern void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
 extern int APIC_init_uniprocessor (void);
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/calling.h linux-2.6.0test11-amd64/include/asm-x86_64/calling.h
--- linux-vanilla/include/asm-x86_64/calling.h	2003-08-23 01:57:23.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/calling.h	2003-11-14 22:06:20.000000000 +0100
@@ -8,7 +8,7 @@
 #define R14 8
 #define R13 16
 #define R12 24
-#define RBP 36
+#define RBP 32
 #define RBX 40
 /* arguments: interrupts/non tracing syscalls only save upto here*/
 #define R11 48
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/cpu.h linux-2.6.0test11-amd64/include/asm-x86_64/cpu.h
--- linux-vanilla/include/asm-x86_64/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test11-amd64/include/asm-x86_64/cpu.h	2003-10-25 23:37:40.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/cpu.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/desc.h linux-2.6.0test11-amd64/include/asm-x86_64/desc.h
--- linux-vanilla/include/asm-x86_64/desc.h	2003-11-24 21:39:27.000000000 +0100
+++ linux-2.6.0test11-amd64/include/asm-x86_64/desc.h	2003-11-02 04:12:01.000000000 +0100
@@ -190,7 +190,7 @@ static inline void load_TLS(struct threa
 /*
  * load one particular LDT into the current CPU
  */
-extern inline void load_LDT_nolock (mm_context_t *pc, int cpu)
+static inline void load_LDT_nolock (mm_context_t *pc, int cpu)
 {
 	int count = pc->size;
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/fixmap.h linux-2.6.0test11-amd64/include/asm-x86_64/fixmap.h
--- linux-vanilla/include/asm-x86_64/fixmap.h	2003-08-23 01:52:59.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/fixmap.h	2003-11-24 07:16:50.000000000 +0100
@@ -76,7 +76,7 @@ extern void __this_fixmap_does_not_exist
  * directly without translation, we catch the bug with a NULL-deference
  * kernel oops. Illegal ranges of incoming indices are caught too.
  */
-extern inline unsigned long fix_to_virt(const unsigned int idx)
+static inline unsigned long fix_to_virt(const unsigned int idx)
 {
 	/*
 	 * this branch gets completely eliminated after inlining,
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/io.h linux-2.6.0test11-amd64/include/asm-x86_64/io.h
--- linux-vanilla/include/asm-x86_64/io.h	2003-08-23 01:54:34.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/io.h	2003-11-07 12:00:29.000000000 +0100
@@ -52,7 +52,7 @@
  * Talk about misusing macros..
  */
 #define __OUT1(s,x) \
-extern inline void out##s(unsigned x value, unsigned short port) {
+static inline void out##s(unsigned x value, unsigned short port) {
 
 #define __OUT2(s,s1,s2) \
 __asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
@@ -62,7 +62,7 @@ __OUT1(s,x) __OUT2(s,s1,"w") : : "a" (va
 __OUT1(s##_p,x) __OUT2(s,s1,"w") __FULL_SLOW_DOWN_IO : : "a" (value), "Nd" (port));} \
 
 #define __IN1(s) \
-extern inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
+static inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
 
 #define __IN2(s,s1,s2) \
 __asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
@@ -72,12 +72,12 @@ __IN1(s) __IN2(s,s1,"w") : "=a" (_v) : "
 __IN1(s##_p) __IN2(s,s1,"w") __FULL_SLOW_DOWN_IO : "=a" (_v) : "Nd" (port) ,##i ); return _v; } \
 
 #define __INS(s) \
-extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+static inline void ins##s(unsigned short port, void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; ins" #s \
 : "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
 #define __OUTS(s) \
-extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+static inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; outs" #s \
 : "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
@@ -125,12 +125,12 @@ __OUTS(l)
  * Change virtual addresses to physical addresses and vv.
  * These are pretty trivial
  */
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 	return __pa(address);
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
 	return __va(address);
 }
@@ -148,7 +148,7 @@ extern inline void * phys_to_virt(unsign
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap (unsigned long offset, unsigned long size)
+static inline void * ioremap (unsigned long offset, unsigned long size)
 {
 	return __ioremap(offset, size, 0);
 }
@@ -304,8 +304,8 @@ out:
 /* Disable vmerge for now. Need to fix the block layer code
    to check for non iommu addresses first.
    When the IOMMU is force it is safe to enable. */
-extern int force_iommu; 
-#define BIO_VERMGE_BOUNDARY (force_iommu ? 4096 : 0)
+extern int iommu_merge;
+#define BIO_VMERGE_BOUNDARY (iommu_merge ? 4096 : 0)
 
 #endif /* __KERNEL__ */
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/memblk.h linux-2.6.0test11-amd64/include/asm-x86_64/memblk.h
--- linux-vanilla/include/asm-x86_64/memblk.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test11-amd64/include/asm-x86_64/memblk.h	2003-10-25 23:38:01.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/memblk.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/msr.h linux-2.6.0test11-amd64/include/asm-x86_64/msr.h
--- linux-vanilla/include/asm-x86_64/msr.h	2003-08-23 01:59:52.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/msr.h	2003-11-26 18:06:03.000000000 +0100
@@ -67,7 +67,7 @@
 			  : "=a" (low), "=d" (high) \
 			  : "c" (counter))
 
-extern inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
+static inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
 {
 	__asm__("cpuid"
 		: "=a" (*eax),
@@ -80,7 +80,7 @@ extern inline void cpuid(int op, int *ea
 /*
  * CPUID functions returning a single datum
  */
-extern inline unsigned int cpuid_eax(unsigned int op)
+static inline unsigned int cpuid_eax(unsigned int op)
 {
 	unsigned int eax;
 
@@ -90,7 +90,7 @@ extern inline unsigned int cpuid_eax(uns
 		: "bx", "cx", "dx");
 	return eax;
 }
-extern inline unsigned int cpuid_ebx(unsigned int op)
+static inline unsigned int cpuid_ebx(unsigned int op)
 {
 	unsigned int eax, ebx;
 
@@ -100,7 +100,7 @@ extern inline unsigned int cpuid_ebx(uns
 		: "cx", "dx" );
 	return ebx;
 }
-extern inline unsigned int cpuid_ecx(unsigned int op)
+static inline unsigned int cpuid_ecx(unsigned int op)
 {
 	unsigned int eax, ecx;
 
@@ -110,7 +110,7 @@ extern inline unsigned int cpuid_ecx(uns
 		: "bx", "dx" );
 	return ecx;
 }
-extern inline unsigned int cpuid_edx(unsigned int op)
+static inline unsigned int cpuid_edx(unsigned int op)
 {
 	unsigned int eax, edx;
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/node.h linux-2.6.0test11-amd64/include/asm-x86_64/node.h
--- linux-vanilla/include/asm-x86_64/node.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test11-amd64/include/asm-x86_64/node.h	2003-10-25 23:38:16.000000000 +0200
@@ -0,0 +1 @@
+#include <asm-i386/node.h>
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pgalloc.h linux-2.6.0test11-amd64/include/asm-x86_64/pgalloc.h
--- linux-vanilla/include/asm-x86_64/pgalloc.h	2003-08-23 01:56:24.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/pgalloc.h	2003-10-25 23:06:51.000000000 +0200
@@ -69,7 +69,7 @@ extern __inline__ void pte_free_kernel(p
 	free_page((unsigned long)pte); 
 }
 
-extern inline void pte_free(struct page *pte)
+static inline void pte_free(struct page *pte)
 {
 	__free_page(pte);
 } 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pgtable.h linux-2.6.0test11-amd64/include/asm-x86_64/pgtable.h
--- linux-vanilla/include/asm-x86_64/pgtable.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/pgtable.h	2003-11-24 07:16:43.000000000 +0100
@@ -71,7 +71,7 @@ extern unsigned long empty_zero_page[102
 #define pml4_none(x)	(!pml4_val(x))
 #define pgd_none(x)	(!pgd_val(x))
 
-extern inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
+static inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
 
 static inline void set_pte(pte_t *dst, pte_t val)
 {
@@ -88,7 +88,7 @@ static inline void set_pgd(pgd_t *dst, p
 	pgd_val(*dst) = pgd_val(val); 
 } 
 
-extern inline void pgd_clear (pgd_t * pgd)
+static inline void pgd_clear (pgd_t * pgd)
 {
 	set_pgd(pgd, __pgd(0));
 }
@@ -180,6 +180,8 @@ static inline void set_pml4(pml4_t *dst,
 	(_PAGE_PRESENT | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_NX)
 #define __PAGE_KERNEL_VSYSCALL \
 	(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+#define __PAGE_KERNEL_VSYSCALL_NOCACHE \
+	(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_PCD)
 #define __PAGE_KERNEL_LARGE \
 	(__PAGE_KERNEL | _PAGE_PSE)
 
@@ -191,6 +193,7 @@ static inline void set_pml4(pml4_t *dst,
 #define PAGE_KERNEL_NOCACHE MAKE_GLOBAL(__PAGE_KERNEL_NOCACHE)
 #define PAGE_KERNEL_VSYSCALL MAKE_GLOBAL(__PAGE_KERNEL_VSYSCALL)
 #define PAGE_KERNEL_LARGE MAKE_GLOBAL(__PAGE_KERNEL_LARGE)
+#define PAGE_KERNEL_VSYSCALL_NOCACHE MAKE_GLOBAL(__PAGE_KERNEL_VSYSCALL_NOCACHE)
 
 /*         xwr */
 #define __P000	PAGE_NONE
@@ -242,23 +245,23 @@ static inline pte_t pfn_pte(unsigned lon
  * Undefined behaviour if not..
  */
 static inline int pte_user(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
-extern inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
+static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
 static inline int pte_file(pte_t pte)		{ return pte_val(pte) & _PAGE_FILE; }
 
-extern inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
+static inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
 static inline  int ptep_test_and_clear_dirty(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_DIRTY, ptep); }
 static inline  int ptep_test_and_clear_young(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep); }
 static inline void ptep_set_wrprotect(pte_t *ptep)		{ clear_bit(_PAGE_BIT_RW, ptep); }
@@ -359,7 +362,7 @@ static inline pte_t mk_pte_phys(unsigned
 }
  
 /* Change flags of a PTE */
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 { 
 	pte_val(pte) &= _PAGE_CHG_MASK;
 	pte_val(pte) |= pgprot_val(newprot);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/processor.h linux-2.6.0test11-amd64/include/asm-x86_64/processor.h
--- linux-vanilla/include/asm-x86_64/processor.h	2003-11-24 21:39:27.000000000 +0100
+++ linux-2.6.0test11-amd64/include/asm-x86_64/processor.h	2003-10-26 00:18:46.000000000 +0200
@@ -304,13 +304,13 @@ extern unsigned long get_wchan(struct ta
 #define KSTK_ESP(tsk) -1 /* sorry. doesn't work for syscall. */
 
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
-extern inline void rep_nop(void)
+static inline void rep_nop(void)
 {
 	__asm__ __volatile__("rep;nop": : :"memory");
 }
 
 /* Stop speculative execution */
-extern inline void sync_core(void)
+static inline void sync_core(void)
 { 
 	int tmp;
 	asm volatile("cpuid" : "=a" (tmp) : "0" (1) : "ebx","ecx","edx","memory");
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/smp.h linux-2.6.0test11-amd64/include/asm-x86_64/smp.h
--- linux-vanilla/include/asm-x86_64/smp.h	2003-11-24 21:39:27.000000000 +0100
+++ linux-2.6.0test11-amd64/include/asm-x86_64/smp.h	2003-11-12 13:14:22.000000000 +0100
@@ -74,7 +74,7 @@ extern __inline int hard_smp_processor_i
 	return GET_APIC_ID(*(unsigned int *)(APIC_BASE+APIC_ID));
 }
 
-#define safe_smp_processor_id() (cpuid_ebx(1) >> 24) 
+#define safe_smp_processor_id() (disable_apic ? 0 : hard_smp_processor_id())
 
 #define cpu_online(cpu) cpu_isset(cpu, cpu_online_map)
 #endif /* !ASSEMBLY */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/statfs.h linux-2.6.0test11-amd64/include/asm-x86_64/statfs.h
--- linux-vanilla/include/asm-x86_64/statfs.h	2003-08-23 01:57:53.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/statfs.h	2003-11-24 05:47:21.000000000 +0100
@@ -41,4 +41,18 @@ struct statfs64 {
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+} __attribute__((packed));
+
 #endif
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/system.h linux-2.6.0test11-amd64/include/asm-x86_64/system.h
--- linux-vanilla/include/asm-x86_64/system.h	2003-09-23 08:03:57.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/system.h	2003-12-10 16:04:25.000000000 +0100
@@ -188,7 +188,7 @@ static inline void write_cr4(unsigned lo
 
 #define __xg(x) ((volatile long *)(x))
 
-extern inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
+static inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
 {
 	*ptr = val;
 }
@@ -276,6 +276,13 @@ static inline unsigned long __cmpxchg(vo
 	((__typeof__(*(ptr)))__cmpxchg((ptr),(unsigned long)(o),\
 					(unsigned long)(n),sizeof(*(ptr))))
 
+static inline __u32 cmpxchg4_locked(__u32 *ptr, __u32 old, __u32 new) 
+{
+	asm volatile("lock ; cmpxchgl %k1,%2" :
+		     "=r" (new) : "0" (old), "m" (*(__u32 *)ptr) : "memory");
+	return new; 
+}
+
 #ifdef CONFIG_SMP
 #define smp_mb()	mb()
 #define smp_rmb()	rmb()
@@ -314,7 +321,21 @@ static inline unsigned long __cmpxchg(vo
 #define local_irq_disable() 	__asm__ __volatile__("cli": : :"memory")
 #define local_irq_enable()	__asm__ __volatile__("sti": : :"memory")
 /* used in the idle loop; sti takes one instruction cycle to complete */
-#define safe_halt()		__asm__ __volatile__("sti; hlt": : :"memory")
+
+/* Work around BIOS that don't have K8 Errata #93 fixed. */
+#define safe_halt()	      \
+	asm volatile("   sti\n"					\
+		     "1: hlt\n"						\
+		     "2:\n"							\
+		     ".section .fixup,\"ax\"\n"		\
+		     "3: call idle_warning\n"		\
+		     "   jmp 2b\n"					\
+		     ".previous\n"					\
+		     ".section __ex_table,\"a\"\n\t"	\
+		     ".align 8\n\t"					\
+		     ".quad 1b,3b\n"				\
+		     ".previous" ::: "memory")
+
 #define irqs_disabled()			\
 ({					\
 	unsigned long flags;		\
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/timex.h linux-2.6.0test11-amd64/include/asm-x86_64/timex.h
--- linux-vanilla/include/asm-x86_64/timex.h	2003-08-23 01:56:59.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/timex.h	2003-11-24 20:58:26.000000000 +0100
@@ -60,4 +60,7 @@ extern unsigned int cpu_khz;
 
 extern struct vxtime_data vxtime;
 
+#define ARCH_HAS_TIMEVARS 1
+
+
 #endif
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/topology.h linux-2.6.0test11-amd64/include/asm-x86_64/topology.h
--- linux-vanilla/include/asm-x86_64/topology.h	2003-11-24 21:39:27.000000000 +0100
+++ linux-2.6.0test11-amd64/include/asm-x86_64/topology.h	2003-11-17 00:01:32.000000000 +0100
@@ -23,6 +23,7 @@ extern unsigned long cpu_online_map;
 
 static inline unsigned long pcibus_to_cpumask(int bus)
 {
+	BUG_ON(bus >= MAX_MP_BUSSES);
 	return mp_bus_to_cpumask[bus] & cpu_online_map; 
 }
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/uaccess.h linux-2.6.0test11-amd64/include/asm-x86_64/uaccess.h
--- linux-vanilla/include/asm-x86_64/uaccess.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/uaccess.h	2003-10-25 23:06:51.000000000 +0200
@@ -48,7 +48,7 @@
 
 #define access_ok(type,addr,size) (__range_not_ok(addr,size) == 0)
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size) ? 0 : -EFAULT;
 }
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/unistd.h linux-2.6.0test11-amd64/include/asm-x86_64/unistd.h
--- linux-vanilla/include/asm-x86_64/unistd.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/unistd.h	2003-11-26 09:45:12.000000000 +0100
@@ -623,11 +623,11 @@ __syscall_return(type,__res); \
 type name (type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5,type6 arg6) \
 { \
 long __res; \
-__asm__ volatile ("movq %5,%%r10 ; movq %6,%%r8 ; movq %7,%%r9" __syscall \
+__asm__ volatile ("movq %5,%%r10 ; movq %6,%%r8 ; movq %7,%%r9 ; " __syscall \
 	: "=a" (__res) \
 	: "0" (__NR_##name),"D" ((long)(arg1)),"S" ((long)(arg2)), \
-	  "d" ((long)(arg3)),"g" ((long)(arg4)),"g" ((long)(arg5), \
-	  "g" ((long)(arg6),) : \
+	  "d" ((long)(arg3)), "g" ((long)(arg4)), "g" ((long)(arg5)), \
+	  "g" ((long)(arg6)) : \
 	__syscall_clobber,"r8","r10","r9" ); \
 __syscall_return(type,__res); \
 }
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/vsyscall.h linux-2.6.0test11-amd64/include/asm-x86_64/vsyscall.h
--- linux-vanilla/include/asm-x86_64/vsyscall.h	2003-08-23 02:01:03.000000000 +0200
+++ linux-2.6.0test11-amd64/include/asm-x86_64/vsyscall.h	2003-11-28 13:09:26.000000000 +0100
@@ -15,6 +15,8 @@ enum vsyscall_num {
 
 #ifdef __KERNEL__
 
+/* FIXME: put all this into a single section */ 
+
 #define __section_vxtime __attribute__ ((unused, __section__ (".vxtime"), aligned(16)))
 #define __section_wall_jiffies __attribute__ ((unused, __section__ (".wall_jiffies"), aligned(16)))
 #define __section_jiffies __attribute__ ((unused, __section__ (".jiffies"), aligned(16)))
@@ -22,6 +24,8 @@ enum vsyscall_num {
 #define __section_sysctl_vsyscall __attribute__ ((unused, __section__ (".sysctl_vsyscall"), aligned(16)))
 #define __section_xtime __attribute__ ((unused, __section__ (".xtime"), aligned(16)))
 #define __section_xtime_lock __attribute__ ((unused, __section__ (".xtime_lock"), aligned(L1_CACHE_BYTES)))
+#define __section_time_adjust __attribute__ ((unused, __section__ (".time_adjust"), aligned(16)))
+#define __section_tick_usec __attribute__ ((unused, __section__ (".tick_usec"), aligned(16)))
 
 #define VXTIME_TSC	1
 #define VXTIME_HPET	2
@@ -46,6 +50,8 @@ extern volatile unsigned long __jiffies;
 extern unsigned long __wall_jiffies;
 extern struct timezone __sys_tz;
 extern seqlock_t __xtime_lock;
+extern long __time_adjust;
+extern long __tick_usec;
 
 /* kernel space (writeable) */
 extern struct vxtime_data vxtime;
@@ -53,6 +59,8 @@ extern unsigned long wall_jiffies;
 extern struct timezone sys_tz;
 extern int sysctl_vsyscall;
 extern seqlock_t xtime_lock;
+extern long time_adjust;
+extern unsigned long tick_usec;
 
 #define ARCH_HAVE_XTIME_LOCK 1
 
diff -burpN -X ../KDIFX linux-vanilla/include/linux/compat.h linux-2.6.0test11-amd64/include/linux/compat.h
--- linux-vanilla/include/linux/compat.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test11-amd64/include/linux/compat.h	2003-11-24 05:47:25.000000000 +0100
@@ -76,20 +76,6 @@ struct compat_rusage {
 	compat_long_t	ru_nivcsw;
 };
 
-struct compat_statfs64 {
-	__u32 f_type;
-	__u32 f_bsize;
-	__u64 f_blocks;
-	__u64 f_bfree;
-	__u64 f_bavail;
-	__u64 f_files;
-	__u64 f_ffree;
-	__kernel_fsid_t f_fsid;
-	__u32 f_namelen;
-	__u32 f_frsize;
-	__u32 f_spare[5];
-};
-
 struct compat_dirent {
 	u32		d_ino;
 	compat_off_t	d_off;
diff -burpN -X ../KDIFX linux-vanilla/include/linux/compat_ioctl.h linux-2.6.0test11-amd64/include/linux/compat_ioctl.h
--- linux-vanilla/include/linux/compat_ioctl.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.0test11-amd64/include/linux/compat_ioctl.h	2003-11-27 15:38:17.000000000 +0100
@@ -260,6 +260,7 @@ COMPATIBLE_IOCTL(SIOCATMARK)
 COMPATIBLE_IOCTL(SIOCSIFLINK)
 COMPATIBLE_IOCTL(SIOCSIFENCAP)
 COMPATIBLE_IOCTL(SIOCGIFENCAP)
+COMPATIBLE_IOCTL(SIOCSIFNAME)
 COMPATIBLE_IOCTL(SIOCSIFBR)
 COMPATIBLE_IOCTL(SIOCGIFBR)
 COMPATIBLE_IOCTL(SIOCSARP)
diff -burpN -X ../KDIFX linux-vanilla/include/linux/pci_ids.h linux-2.6.0test11-amd64/include/linux/pci_ids.h
--- linux-vanilla/include/linux/pci_ids.h	2003-11-24 21:39:27.000000000 +0100
+++ linux-2.6.0test11-amd64/include/linux/pci_ids.h	2003-11-24 06:20:50.000000000 +0100
@@ -1030,6 +1030,8 @@
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE	0x0085
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA	0x008e
 #define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3		0x00d1
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3S  		0x00e1
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE	0x00d5
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA	0x00e3
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE	0x00e5
diff -burpN -X ../KDIFX linux-vanilla/include/linux/timex.h linux-2.6.0test11-amd64/include/linux/timex.h
--- linux-vanilla/include/linux/timex.h	2003-10-25 22:58:06.000000000 +0200
+++ linux-2.6.0test11-amd64/include/linux/timex.h	2003-11-24 06:54:36.000000000 +0100
@@ -282,7 +282,7 @@ struct timex {
  */
 extern unsigned long tick_usec;		/* USER_HZ period (usec) */
 extern unsigned long tick_nsec;		/* ACTHZ          period (nsec) */
-extern int tickadj;			/* amount of adjustment per tick */
+#define tickadj ((int)(500/HZ ? : 1))
 
 /*
  * phase-lock loop variables
diff -burpN -X ../KDIFX linux-vanilla/kernel/timer.c linux-2.6.0test11-amd64/kernel/timer.c
--- linux-vanilla/kernel/timer.c	2003-11-24 21:39:27.000000000 +0100
+++ linux-2.6.0test11-amd64/kernel/timer.c	2003-11-28 13:07:46.000000000 +0100
@@ -436,7 +436,18 @@ repeat:
 /*
  * Timekeeping variables
  */
+
+/* 
+ * Any variables used in low level gettimeofday must be declared
+ * inside ARCH_HAS_TIMEVARS. This is requires for x86-64 who
+ * can run gettimeofday in user context in a vsyscall. The variables
+ * must be mapped in a special way in the low level architecture code
+ * then. -AK
+ */ 
+
+#ifndef ARCH_HAS_TIMEVARS
 unsigned long tick_usec = TICK_USEC; 		/* USER_HZ period (usec) */
+#endif
 unsigned long tick_nsec = TICK_NSEC;		/* ACTHZ period (nsec) */
 
 /* 
@@ -452,10 +463,6 @@ struct timespec wall_to_monotonic __attr
 
 EXPORT_SYMBOL(xtime);
 
-/* Don't completely fail for HZ > 500.  */
-int tickadj = 500/HZ ? : 1;		/* microsecs */
-
-
 /*
  * phase-lock loop variables
  */
@@ -473,7 +480,9 @@ long time_freq = (((NSEC_PER_SEC + HZ/2)
 					/* frequency offset (scaled ppm)*/
 long time_adj;				/* tick adjust (scaled 1 / HZ)	*/
 long time_reftime;			/* time at last adjustment (s)	*/
+#ifndef ARCH_HAS_TIMEVARS
 long time_adjust;
+#endif
 long time_next_adjust;
 
 /*
