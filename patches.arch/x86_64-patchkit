diff -X ../../KDIFX -burpN linux/arch/x86_64/Kconfig /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/Kconfig
--- linux/arch/x86_64/Kconfig	2004-04-20 16:02:34.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/Kconfig	2004-04-14 04:46:21.000000000 +0200
@@ -290,9 +290,11 @@ config GART_IOMMU
 	  Normally the kernel will take the right choice by itself.
 	  If unsure say Y 
 
+# need this always enabled with GART_IOMMU for the VIA workaround
 config SWIOTLB
-       select GART_IOMMU
-       bool "Software IOTLB support"
+       bool
+       depends on GART_IOMMU
+       default y
 
 config DUMMY_IOMMU
 	bool
@@ -480,11 +484,18 @@ config FRAME_POINTER
 
 config IOMMU_DEBUG
        depends on GART_IOMMU && DEBUG_KERNEL
-       bool "Force IOMMU to on" 
+       bool "Enable IOMMU debugging"
        help
-         Force the IOMMU to on even when you have less than 4GB of memory and add 
-	 debugging code. 
-	 Can be disabled at boot time with iommu=noforce.
+         Force the IOMMU to on even when you have less than 4GB of
+	 memory and add debugging code. On overflow always panic. And
+	 allow to enable IOMMU leak tracing. Can be disabled at boot
+	 time with iommu=noforce. This will also enable scatter gather
+	 list merging.  Currently not recommended for production
+	 code. When you use it make sure you have a big enough
+	 IOMMU/AGP aperture.  Most of the options enabled by this can
+	 be set more finegrained using the iommu= command line
+	 options. See Documentation/x86_64/boot-options.txt for more
+	 details.
 
 config IOMMU_LEAK
        bool "IOMMU leak tracing"
diff -X ../../KDIFX -burpN linux/arch/x86_64/kernel/io_apic.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/io_apic.c
--- linux/arch/x86_64/kernel/io_apic.c	2004-04-20 16:02:10.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/io_apic.c	2004-04-14 04:46:21.000000000 +0200
@@ -250,12 +250,14 @@ void __init check_ioapic(void) 
 				vendor &= 0xffff;
 				switch (vendor) { 
 				case PCI_VENDOR_ID_VIA:
+#ifdef CONFIG_GART_IOMMU
 					if (end_pfn >= (0xffffffff>>PAGE_SHIFT) &&
 					    !iommu_aperture_allowed) { 
 						printk(KERN_INFO
     "Looks like a VIA chipset. Disabling IOMMU. Overwrite with \"iommu=allowed\"\n"); 
 						iommu_aperture_disabled = 1; 
 					} 
+#endif
 					/* FALL THROUGH */
 				case PCI_VENDOR_ID_NVIDIA:
 #ifndef CONFIG_SMP
diff -X ../../KDIFX -burpN linux/arch/x86_64/kernel/mce.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/mce.c
--- linux/arch/x86_64/kernel/mce.c	2004-04-06 13:12:05.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/mce.c	2004-04-14 04:46:21.000000000 +0200
@@ -85,7 +85,7 @@ static void print_mce(struct mce *m)
 	if (m->addr)
 		printk("ADDR %Lx ", m->addr);
 	if (m->misc)
-		printk("MISC %Lx ", m->addr); 	
+		printk("MISC %Lx ", m->misc); 	
 	printk("\n");
 }
 
@@ -160,7 +160,7 @@ void do_machine_check(struct pt_regs * r
 		if (m.status & MCI_STATUS_MISCV)
 			rdmsrl(MSR_IA32_MC0_MISC + i*4, m.misc);
 		if (m.status & MCI_STATUS_ADDRV)
-			rdmsrl(MSR_IA32_MC0_MISC + i*4, m.addr);
+			rdmsrl(MSR_IA32_MC0_ADDR + i*4, m.addr);
 
 		rdtscll(m.tsc);
 		wrmsrl(MSR_IA32_MC0_STATUS + i*4, 0);
diff -X ../../KDIFX -burpN linux/arch/x86_64/kernel/mtrr/Makefile /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/mtrr/Makefile
--- linux/arch/x86_64/kernel/mtrr/Makefile	2004-03-21 21:12:09.000000000 +0100
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/mtrr/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-#
-# Reuse the i386 MTRR driver.
-#
-
-obj-y		:= main.o if.o generic.o state.o
-obj-y		+= amd.o
-obj-y		+= cyrix.o
-obj-y		+= centaur.o
-
-$(obj)/main.c: $(obj)/mtrr.h
-	@ln -sf ../../../i386/kernel/cpu/mtrr/main.c $(obj)/main.c
-$(obj)/if.c: $(obj)/mtrr.h
-	@ln -sf ../../../i386/kernel/cpu/mtrr/if.c $(obj)/if.c
-$(obj)/generic.c: $(obj)/mtrr.h
-	@ln -sf ../../../i386/kernel/cpu/mtrr/generic.c $(obj)/generic.c
-$(obj)/state.c: $(obj)/mtrr.h
-	@ln -sf ../../../i386/kernel/cpu/mtrr/state.c $(obj)/state.c
-$(obj)/amd.c: $(obj)/mtrr.h
-	@ln -sf ../../../i386/kernel/cpu/mtrr/amd.c $(obj)/amd.c
-$(obj)/cyrix.c: $(obj)/mtrr.h
-	@ln -sf ../../../i386/kernel/cpu/mtrr/cyrix.c $(obj)/cyrix.c
-$(obj)/centaur.c: $(obj)/mtrr.h
-	@ln -sf ../../../i386/kernel/cpu/mtrr/centaur.c $(obj)/centaur.c
-$(obj)/mtrr.h:
-	@ln -sf ../../../i386/kernel/cpu/mtrr/mtrr.h $(obj)/mtrr.h
-
-clean-files += main.c if.c generic.c state.c amd.c cyrix.c centaur.c mtrr.h
-
diff -X ../../KDIFX -burpN linux/arch/x86_64/kernel/setup.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/setup.c
--- linux/arch/x86_64/kernel/setup.c	2004-04-20 16:02:10.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/setup.c	2004-04-14 04:53:10.000000000 +0200
@@ -794,6 +844,9 @@ static void __init init_intel(struct cpu
 		c->x86_virt_bits = (eax >> 8) & 0xff;
 		c->x86_phys_bits = eax & 0xff;
 	}
+
+	if (c->x86 == 15)
+		c->x86_cache_alignment = c->x86_clflush_size * 2;
 }
 
 void __init get_cpu_vendor(struct cpuinfo_x86 *c)
@@ -828,6 +881,7 @@ void __init early_identify_cpu(struct cp
 	c->x86_vendor_id[0] = '\0'; /* Unset */
 	c->x86_model_id[0] = '\0';  /* Unset */
 	c->x86_clflush_size = 64;
+	c->x86_cache_alignment = c->x86_clflush_size;
 	memset(&c->x86_capability, 0, sizeof c->x86_capability);
 
 	/* Get vendor name */
@@ -1055,6 +1109,7 @@ static int show_cpuinfo(struct seq_file 
 	if (c->x86_tlbsize > 0) 
 		seq_printf(m, "TLB size\t: %d 4K pages\n", c->x86_tlbsize);
 	seq_printf(m, "clflush size\t: %d\n", c->x86_clflush_size);
+	seq_printf(m, "cache_alignment\t: %d\n", c->x86_cache_alignment);
 
 	seq_printf(m, "address sizes\t: %u bits physical, %u bits virtual\n", 
 		   c->x86_phys_bits, c->x86_virt_bits);
diff -X ../../KDIFX -burpN linux/arch/x86_64/kernel/setup64.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/setup64.c
--- linux/arch/x86_64/kernel/setup64.c	2004-04-06 13:12:05.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/setup64.c	2004-04-14 04:46:21.000000000 +0200
@@ -24,6 +24,7 @@
 #include <asm/mtrr.h>
 #include <asm/proto.h>
 #include <asm/mman.h>
+#include <asm/numa.h>
 
 char x86_boot_params[2048] __initdata = {0,};
 
@@ -329,4 +330,8 @@ void __init cpu_init (void)
 	set_debug(0UL, 7);
 
 	fpu_init(); 
+
+#ifdef CONFIG_NUMA
+	numa_add_cpu(cpu);
+#endif
 }
diff -X ../../KDIFX -burpN linux/arch/x86_64/kernel/smpboot.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/smpboot.c
--- linux/arch/x86_64/kernel/smpboot.c	2004-04-20 16:02:10.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/smpboot.c	2004-04-14 04:46:21.000000000 +0200
@@ -811,6 +811,8 @@ static void __init smp_boot_cpus(unsigne
 	if (GET_APIC_ID(apic_read(APIC_ID)) != boot_cpu_id)
 		BUG();
 
+	x86_cpu_to_apicid[0] = boot_cpu_id;
+
 	/*
 	 * Now scan the CPU present map and fire up the other CPUs.
 	 */
diff -X ../../KDIFX -burpN linux/arch/x86_64/kernel/traps.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/traps.c
--- linux/arch/x86_64/kernel/traps.c	2004-04-06 13:12:05.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/traps.c	2004-04-15 22:20:25.000000000 +0200
@@ -266,8 +266,8 @@ void show_registers(struct pt_regs *regs
 
 	printk("CPU %d ", cpu);
 	__show_regs(regs);
-	printk("Process %s (pid: %d, stackpage=%08lx)\n",
-		cur->comm, cur->pid, 4096+(unsigned long)cur);
+	printk("Process %s (pid: %d, threadinfo %p, task %p)\n",
+		cur->comm, cur->pid, cur->thread_info, cur);
 
 	/*
 	 * When in-kernel, we also print out the stack and code at the
diff -X ../../KDIFX -burpN linux/arch/x86_64/kernel/x8664_ksyms.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/x8664_ksyms.c
--- linux/arch/x86_64/kernel/x8664_ksyms.c	2004-04-06 13:12:05.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/kernel/x8664_ksyms.c	2004-04-14 04:46:21.000000000 +0200
@@ -98,8 +98,10 @@ EXPORT_SYMBOL(copy_to_user);
 EXPORT_SYMBOL(copy_in_user);
 EXPORT_SYMBOL(strnlen_user);
 
+#ifdef CONFIG_PCI
 EXPORT_SYMBOL(pci_alloc_consistent);
 EXPORT_SYMBOL(pci_free_consistent);
+#endif
 
 #ifdef CONFIG_PCI
 EXPORT_SYMBOL(pcibios_penalize_isa_irq);
@@ -206,13 +208,6 @@ EXPORT_SYMBOL(init_level4_pgt);
 extern unsigned long __supported_pte_mask;
 EXPORT_SYMBOL(__supported_pte_mask);
 
-#ifdef CONFIG_DISCONTIGMEM
-EXPORT_SYMBOL(memnode_shift);
-EXPORT_SYMBOL(memnodemap);
-EXPORT_SYMBOL(node_data);
-EXPORT_SYMBOL(fake_node);
-#endif
-
 EXPORT_SYMBOL(clear_page);
 
 #ifdef CONFIG_SMP
diff -X ../../KDIFX -burpN linux/arch/x86_64/mm/init.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/mm/init.c
--- linux/arch/x86_64/mm/init.c	2004-04-06 13:12:05.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/mm/init.c	2004-04-14 04:34:45.000000000 +0200
@@ -603,8 +603,6 @@ struct vm_area_struct *get_gate_vma(stru
 
 int in_gate_area(struct task_struct *task, unsigned long addr)
 {
-	struct vm_area_struct *vma = &gate_vma;
-	if (test_tsk_thread_flag(task, TIF_IA32))
-		vma = &gate32_vma;
+	struct vm_area_struct *vma = get_gate_vma(task);
 	return (addr >= vma->vm_start) && (addr < vma->vm_end);
 }
diff -X ../../KDIFX -burpN linux/arch/x86_64/mm/k8topology.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/mm/k8topology.c
--- linux/arch/x86_64/mm/k8topology.c	1970-01-01 01:12:51.000000000 +0100
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/mm/k8topology.c	2004-04-14 05:12:18.000000000 +0200
@@ -48,7 +48,6 @@ int __init k8_scan_nodes(unsigned long s
 	int nodeid, i, nb; 
 	int found = 0;
 	u32 reg;
-	int rr;
 
 	nb = find_northbridge(); 
 	if (nb < 0) 
@@ -91,7 +90,7 @@ int __init k8_scan_nodes(unsigned long s
 			       nodeid, (base>>8)&3, (limit>>8) & 3); 
 			return -1; 
 		}	
-		if ((1UL << nodeid) & nodes_present) { 
+		if (node_online(nodeid)) { 
 			printk(KERN_INFO "Node %d already present. Skipping\n", 
 			       nodeid);
 			continue;
@@ -152,28 +151,13 @@ int __init k8_scan_nodes(unsigned long s
 	printk(KERN_INFO "Using node hash shift of %d\n", memnode_shift); 
 
 	for (i = 0; i < MAXNODE; i++) { 
-		if (nodes[i].start != nodes[i].end)
+		if (nodes[i].start != nodes[i].end) { 
+			/* assume 1:1 NODE:CPU */
+			cpu_to_node[i] = i; 
 		setup_node_bootmem(i, nodes[i].start, nodes[i].end); 
 	} 
-
-	/* There are unfortunately some poorly designed mainboards around
-	   that only connect memory to a single CPU. This breaks the 1:1 cpu->node
-	   mapping. To avoid this fill in the mapping for all possible
-	   CPUs, as the number of CPUs is not known yet. 
-	   We round robin the existing nodes. */
-	rr = 0;
-	for (i = 0; i < MAXNODE; i++) {
-		if (nodes_present & (1UL<<i))
-			continue;
-		if ((nodes_present >> rr) == 0) 
-			rr = 0; 
-		rr = ffz(~nodes_present >> rr); 
-		node_data[i] = node_data[rr];
-		rr++; 
 	}
 
-	if (found == 1) 
-		fake_node = 1;
-
+	numa_init_array();
 	return 0;
 } 
diff -X ../../KDIFX -burpN linux/arch/x86_64/mm/numa.c /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/mm/numa.c
--- linux/arch/x86_64/mm/numa.c	2004-04-06 13:12:05.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/arch/x86_64/mm/numa.c	2004-04-14 04:46:21.000000000 +0200
@@ -9,6 +9,7 @@
 #include <linux/bootmem.h>
 #include <linux/mmzone.h>
 #include <linux/ctype.h>
+#include <linux/module.h>
 #include <asm/e820.h>
 #include <asm/proto.h>
 #include <asm/dma.h>
@@ -24,6 +25,9 @@ bootmem_data_t plat_node_bdata[MAX_NUMNO
 int memnode_shift;
 u8  memnodemap[NODEMAPSIZE];
 
+unsigned char cpu_to_node[NR_CPUS];  
+cpumask_t     node_to_cpumask[MAXNODE]; 
+
 static int numa_off __initdata; 
 
 unsigned long nodes_present; 
@@ -105,7 +109,6 @@ void __init setup_node_bootmem(int nodei
 	reserve_bootmem_node(NODE_DATA(nodeid), bootmap_start, bootmap_pages<<PAGE_SHIFT);
 	if (nodeid + 1 > numnodes)
 		numnodes = nodeid + 1;
-	nodes_present |= (1UL << nodeid); 
 	node_set_online(nodeid);
 } 
 
@@ -136,13 +139,36 @@ void __init setup_node_zones(int nodeid)
 			    start_pfn, NULL); 
 } 
 
-int fake_node;
+void __init numa_init_array(void)
+{
+	int rr, i;
+	/* There are unfortunately some poorly designed mainboards around
+	   that only connect memory to a single CPU. This breaks the 1:1 cpu->node
+	   mapping. To avoid this fill in the mapping for all possible
+	   CPUs, as the number of CPUs is not known yet. 
+	   We round robin the existing nodes. */
+	rr = 0;
+	for (i = 0; i < MAXNODE; i++) {
+		if (node_online(i))
+			continue;
+		rr = find_next_bit(node_online_map, MAX_NUMNODES, rr);
+		if (rr == MAX_NUMNODES)
+			rr = find_first_bit(node_online_map, MAX_NUMNODES);
+		node_data[i] = node_data[rr];
+		cpu_to_node[i] = rr;
+		rr++; 
+	}
 
-int __init numa_initmem_init(unsigned long start_pfn, unsigned long end_pfn)
+	set_bit(0, &node_to_cpumask[cpu_to_node(0)]);
+}
+
+void __init numa_initmem_init(unsigned long start_pfn, unsigned long end_pfn)
 { 
+	int i;
+
 #ifdef CONFIG_K8_NUMA
 	if (!numa_off && !k8_scan_nodes(start_pfn<<PAGE_SHIFT, end_pfn<<PAGE_SHIFT))
-		return 0; 
+		return;
 #endif
 	printk(KERN_INFO "%s\n",
 	       numa_off ? "NUMA turned off" : "No NUMA configuration found");
@@ -151,12 +177,20 @@ int __init numa_initmem_init(unsigned lo
 	       start_pfn << PAGE_SHIFT,
 	       end_pfn << PAGE_SHIFT); 
 		/* setup dummy node covering all memory */ 
-	fake_node = 1; 	
 	memnode_shift = 63; 
 	memnodemap[0] = 0;
 	numnodes = 1;
+	for (i = 0; i < NR_CPUS; i++)
+		cpu_to_node[i] = 0;
+	node_to_cpumask[0] = 1;
 	setup_node_bootmem(0, start_pfn<<PAGE_SHIFT, end_pfn<<PAGE_SHIFT);
-	return -1; 
+}
+
+__init void numa_add_cpu(int cpu)
+{
+	/* BP is initialized elsewhere */
+	if (cpu) 
+		set_bit(cpu, &node_to_cpumask[cpu_to_node(cpu)]);
 } 
 
 unsigned long __init numa_free_all_bootmem(void) 
@@ -185,4 +219,8 @@ __init int numa_setup(char *opt) 
 	return 1;
 } 
 
-
+EXPORT_SYMBOL(cpu_to_node);
+EXPORT_SYMBOL(node_to_cpumask);
+EXPORT_SYMBOL(memnode_shift);
+EXPORT_SYMBOL(memnodemap);
+EXPORT_SYMBOL(node_data);
diff -X ../../KDIFX -burpN linux/include/asm-x86_64/bitops.h /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/bitops.h
--- linux/include/asm-x86_64/bitops.h	2004-04-06 13:12:21.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/bitops.h	2004-04-14 04:34:58.000000000 +0200
@@ -204,7 +204,7 @@ static __inline__ int __test_and_change_
 }
 
 /**
- * test_and_change_bit - Change a bit and return its new value
+ * test_and_change_bit - Change a bit and return its old value
  * @nr: Bit to change
  * @addr: Address to count from
  *
diff -X ../../KDIFX -burpN linux/include/asm-x86_64/ia32_unistd.h /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/ia32_unistd.h
--- linux/include/asm-x86_64/ia32_unistd.h	2004-03-21 21:11:54.000000000 +0100
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/ia32_unistd.h	2004-04-14 13:30:32.000000000 +0200
@@ -278,7 +278,17 @@
 #define __NR_ia32_tgkill		270
 #define __NR_ia32_utimes		271
 #define __NR_ia32_fadvise64_64		272
+#define __NR_ia32_vserver		273
+#define __NR_ia32_mbind		274
+#define __NR_ia32_get_mempolicy	275
+#define __NR_ia32_set_mempolicy	276
+#define __NR_ia32_mq_open 		277
+#define __NR_ia32_mq_unlink		(__NR_ia32_mq_open+1)
+#define __NR_ia32_mq_timedsend	(__NR_ia32_mq_open+2)
+#define __NR_ia32_mq_timedreceive	(__NR_ia32_mq_open+3)
+#define __NR_ia32_mq_notify		(__NR_ia32_mq_open+4)
+#define __NR_ia32_mq_getsetattr	(__NR_ia32_mq_open+5)
 
-#define IA32_NR_syscalls 275	/* must be > than biggest syscall! */	
+#define IA32_NR_syscalls 285	/* must be > than biggest syscall! */	
 
 #endif /* _ASM_X86_64_IA32_UNISTD_H_ */
diff -X ../../KDIFX -burpN linux/include/asm-x86_64/numa.h /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/numa.h
--- linux/include/asm-x86_64/numa.h	2004-03-21 21:11:54.000000000 +0100
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/numa.h	2004-04-14 04:46:23.000000000 +0200
@@ -9,12 +9,13 @@ struct node { 
 };
 
 #define for_all_nodes(x) for ((x) = 0; (x) < numnodes; (x)++) \
-				if ((1UL << (x)) & nodes_present)
-
+				if (node_online(x))
 
 extern int compute_hash_shift(struct node *nodes);
-extern unsigned long nodes_present;
 
 #define ZONE_ALIGN (1UL << (MAX_ORDER+PAGE_SHIFT))
 
+extern void numa_add_cpu(int cpu);
+extern void numa_init_array(void);
+
 #endif
diff -X ../../KDIFX -burpN linux/include/asm-x86_64/pci.h /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/pci.h
--- linux/include/asm-x86_64/pci.h	2004-04-06 13:12:21.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/pci.h	2004-04-14 04:34:58.000000000 +0200
@@ -357,8 +357,9 @@ static inline void pcibios_add_platform_
 #endif /* __KERNEL__ */
 
 /* generic pci stuff */
+#ifdef CONFIG_PCI
 #include <asm-generic/pci.h>
-
 #include <linux/dma-mapping.h>
+#endif
 
 #endif /* __x8664_PCI_H */
diff -X ../../KDIFX -burpN linux/include/asm-x86_64/processor.h /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/processor.h
--- linux/include/asm-x86_64/processor.h	2004-04-20 16:02:30.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/processor.h	2004-04-14 04:34:58.000000000 +0200
@@ -59,6 +59,7 @@ struct cpuinfo_x86 {
 	char	x86_model_id[64];
 	int 	x86_cache_size;  /* in KB */
 	int	x86_clflush_size;
+	int	x86_cache_alignment;
 	int	x86_tlbsize;	/* number of 4K pages in DTLB/ITLB combined(in pages)*/
         __u8    x86_virt_bits, x86_phys_bits;
         __u32   x86_power; 	
@@ -458,6 +454,6 @@ static inline void __mwait(unsigned long
 	ti->task;					\
 })
 
-#define cache_line_size() (boot_cpu_data.x86_clflush_size)
+#define cache_line_size() (boot_cpu_data.x86_cache_alignment)
 
 #endif /* __ASM_X86_64_PROCESSOR_H */
diff -X ../../KDIFX -burpN linux/include/asm-x86_64/proto.h /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/proto.h
--- linux/include/asm-x86_64/proto.h	2004-04-20 16:02:10.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/proto.h	2004-04-14 04:46:23.000000000 +0200
@@ -42,7 +42,7 @@ extern void early_identify_cpu(struct cp
 
 extern int k8_scan_nodes(unsigned long start, unsigned long end);
 
-extern int numa_initmem_init(unsigned long start_pfn, unsigned long end_pfn);
+extern void numa_initmem_init(unsigned long start_pfn, unsigned long end_pfn);
 extern unsigned long numa_free_all_bootmem(void);
 
 extern void reserve_bootmem_generic(unsigned long phys, unsigned len);
diff -X ../../KDIFX -burpN linux/include/asm-x86_64/topology.h /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/topology.h
--- linux/include/asm-x86_64/topology.h	2004-03-21 21:11:54.000000000 +0100
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/topology.h	2004-04-14 04:46:23.000000000 +0200
@@ -6,18 +6,19 @@
 #ifdef CONFIG_DISCONTIGMEM
 
 #include <asm/mpspec.h>
+#include <asm/bitops.h>
 
 /* Map the K8 CPU local memory controllers to a simple 1:1 CPU:NODE topology */
 
-extern int fake_node;
-/* This is actually a cpumask_t, but doesn't matter because we don't have
-   >BITS_PER_LONG CPUs */
-extern unsigned long cpu_online_map;
+extern cpumask_t cpu_online_map;
 
-#define cpu_to_node(cpu)		(fake_node ? 0 : (cpu))
+extern unsigned char cpu_to_node[];
+extern cpumask_t     node_to_cpumask[];
+
+#define cpu_to_node(cpu)		(cpu_to_node[cpu])
 #define parent_node(node)		(node)
-#define node_to_first_cpu(node) 	(fake_node ? 0 : (node))
-#define node_to_cpumask(node)	(fake_node ? cpu_online_map : (1UL << (node)))
+#define node_to_first_cpu(node) 	(__ffs(node_to_cpumask[node]))
+#define node_to_cpumask(node)		(node_to_cpumask[node])
 
 static inline unsigned long pcibus_to_cpumask(int bus)
 {
diff -X ../../KDIFX -burpN linux/include/asm-x86_64/types.h /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/types.h
--- linux/include/asm-x86_64/types.h	2004-04-06 13:12:21.000000000 +0200
+++ /home/andi/lsrc/v2.6/linux-2.6.5-bk1-amd64/include/asm-x86_64/types.h	2004-04-14 04:34:58.000000000 +0200
@@ -33,8 +33,6 @@ typedef unsigned long long  __u64;
 
 #ifndef __ASSEMBLY__
 
-#include <linux/config.h>
-
 typedef signed char s8;
 typedef unsigned char u8;
 
@@ -50,10 +48,8 @@ typedef unsigned long long u64;
 typedef u64 dma64_addr_t;
 typedef u64 dma_addr_t;
 
-#ifdef CONFIG_LBD
 typedef u64 sector_t;
 #define HAVE_SECTOR_T
-#endif
 
 #endif /* __ASSEMBLY__ */
 
