- Description: cio: machine check and vary on/off problems.
  Symptom:     Various oopses after machine checks or logical vary on/off.
  Problem:     Handling of appearing and disappearing devices was not correctly
               serialized. Can't allocate channel path in interrupt path.
  Solution:    Convert kernel thread for slow handling of crws to a singlethread
               workqueue. Use this workqueue in addition to the existing for
               proper serialization to avoid double unregister. When detecting a
               missing channel path structure, trigger a rescan of the channel
               subsystem.
  Problem-ID:  -
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/cio/css.h	2 Mar 2004 20:04:57 -0000	1.36
+++ linux-2.5/drivers/s390/cio/css.h	9 Jun 2004 11:21:53 -0000	1.36.2.1
@@ -136,7 +136,6 @@
 
 /* Helper functions for vary on/off. */
 void device_set_waiting(struct subchannel *);
-void device_call_nopath_notify(struct subchannel *);
 
 /* Helper functions to build lists for the slow path. */
 int css_enqueue_subchannel_slow(unsigned long schid);
@@ -144,4 +143,7 @@
 void css_clear_subchannel_slow_list(void);
 int css_slow_subchannels_exist(void);
 extern int need_rescan;
+
+extern struct workqueue_struct *slow_path_wq;
+extern struct work_struct slow_path_work;
 #endif

--- linux-2.5/drivers/s390/cio/chsc.c	23 Apr 2004 14:06:10 -0000	1.107.2.1
+++ linux-2.5/drivers/s390/cio/chsc.c	9 Jun 2004 11:21:53 -0000	1.107.2.2
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/chsc.c
  *   S/390 common I/O routines -- channel subsystem call
- *   $Revision: 1.107.2.1 $
+ *   $Revision: 1.107.2.2 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -62,11 +62,11 @@
 	int state;
 
 	state = get_chp_status(chp);
-	if (state < 0)
-		new_channel_path(chp);
-	else
+	if (state < 0) {
+		need_rescan = 1;
+		queue_work(slow_path_wq, &slow_path_work);
+	} else
 		WARN_ON(!state);
-	/* FIXME: should notify other subchannels here */
 }
 
 /* FIXME: this is _always_ called for every subchannel. shouldn't we
@@ -285,8 +285,10 @@
 out_unreg:
 	spin_unlock(&sch->lock);
 	sch->lpm = 0;
-	/* We can't block here. */
-	device_call_nopath_notify(sch);
+	if (css_enqueue_subchannel_slow(sch->irq)) {
+		css_clear_subchannel_slow_list();
+		need_rescan = 1;
+	}
 	return 0;
 }
 
@@ -303,6 +305,9 @@
 
 	bus_for_each_dev(&css_bus_type, NULL, &chpid,
 			 s390_subchannel_remove_chpid);
+
+	if (need_rescan || css_slow_subchannels_exist())
+		queue_work(slow_path_wq, &slow_path_work);
 }
 
 static int
@@ -737,10 +742,12 @@
 			 * can successfully terminate, even using the
 			 * just varied off path. Then kill it.
 			 */
-			if (!__check_for_io_and_kill(sch, chp) && !sch->lpm)
-				/* Get over with it now. */
-				device_call_nopath_notify(sch);
-			else if (sch->driver && sch->driver->verify)
+			if (!__check_for_io_and_kill(sch, chp) && !sch->lpm) {
+				if (css_enqueue_subchannel_slow(sch->irq)) {
+					css_clear_subchannel_slow_list();
+					need_rescan = 1;
+				}
+			} else if (sch->driver && sch->driver->verify)
 				sch->driver->verify(&sch->dev);
 		}
 		break;
@@ -773,11 +780,6 @@
 	return 0;
 }
 
-extern void css_trigger_slow_path(void);
-typedef void (*workfunc)(void *);
-static DECLARE_WORK(varyonoff_work, (workfunc)css_trigger_slow_path,
-		    NULL);
-
 /*
  * Function: s390_vary_chpid
  * Varies the specified chpid online or offline
@@ -813,11 +815,13 @@
 			 s390_subchannel_vary_chpid_on :
 			 s390_subchannel_vary_chpid_off);
 	if (!on)
-		return 0;
+		goto out;
 	/* Scan for new devices on varied on path. */
 	for (irq = 0; irq < __MAX_SUBCHANNELS; irq++) {
 		struct schib schib;
 
+		if (need_rescan)
+			break;
 		sch = get_subchannel_by_schid(irq);
 		if (sch) {
 			put_device(&sch->dev);
@@ -826,18 +830,16 @@
 		if (stsch(irq, &schib))
 			/* We're through */
 			break;
-		if (need_rescan)
-			continue;
 		/* Put it on the slow path. */
 		ret = css_enqueue_subchannel_slow(irq);
 		if (ret) {
 			css_clear_subchannel_slow_list();
 			need_rescan = 1;
 		}
-		continue;
 	}
+out:
 	if (need_rescan || css_slow_subchannels_exist())
-		schedule_work(&varyonoff_work);
+		queue_work(slow_path_wq, &slow_path_work);
 	return 0;
 }
 

--- linux-2.5/drivers/s390/cio/device.c	8 Jun 2004 19:01:46 -0000	1.113.2.1
+++ linux-2.5/drivers/s390/cio/device.c	9 Jun 2004 11:21:53 -0000	1.113.2.2
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device.c
  *  bus driver for ccw devices
- *   $Revision: 1.113.2.1 $
+ *   $Revision: 1.113.2.2 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -139,6 +139,7 @@
 };
 
 struct workqueue_struct *ccw_device_work;
+struct workqueue_struct *ccw_device_notify_work;
 static wait_queue_head_t ccw_device_init_wq;
 static atomic_t ccw_device_init_count;
 
@@ -150,20 +151,37 @@
 	init_waitqueue_head(&ccw_device_init_wq);
 	atomic_set(&ccw_device_init_count, 0);
 
-	ccw_device_work = create_workqueue("cio");
+	ccw_device_work = create_singlethread_workqueue("cio");
 	if (!ccw_device_work)
 		return -ENOMEM; /* FIXME: better errno ? */
-
+	ccw_device_notify_work = create_singlethread_workqueue("cio_notify");
+	if (!ccw_device_notify_work) {
+		ret = -ENOMEM; /* FIXME: better errno ? */
+		goto out_err;
+	}
+	slow_path_wq = create_singlethread_workqueue("kslowcrw");
+	if (!slow_path_wq) {
+		ret = -ENOMEM; /* FIXME: better errno ? */
+		goto out_err;
+	}
 	if ((ret = bus_register (&ccw_bus_type)))
-		return ret;
+		goto out_err;
 
 	if ((ret = driver_register(&io_subchannel_driver.drv)))
-		return ret;
+		goto out_err;
 
 	wait_event(ccw_device_init_wq,
 		   atomic_read(&ccw_device_init_count) == 0);
 	flush_workqueue(ccw_device_work);
 	return 0;
+out_err:
+	if (ccw_device_work)
+		destroy_workqueue(ccw_device_work);
+	if (ccw_device_notify_work)
+		destroy_workqueue(ccw_device_notify_work);
+	if (slow_path_wq)
+		destroy_workqueue(slow_path_wq);
+	return ret;
 }
 
 static void __exit
@@ -171,6 +189,7 @@
 {
 	driver_unregister(&io_subchannel_driver.drv);
 	bus_unregister(&ccw_bus_type);
+	destroy_workqueue(ccw_device_notify_work);
 	destroy_workqueue(ccw_device_work);
 }
 
@@ -534,7 +553,7 @@
 		/*
 		 * The device number has changed. This is usually only when
 		 * a device has been detached under VM and then re-appeared
-		 * on another subchannel because of a different attachment 
+		 * on another subchannel because of a different attachment
 		 * order than before. Ideally, we should should just switch
 		 * subchannels, but unfortunately, this is not possible with
 		 * the current implementation.
@@ -628,8 +647,8 @@
 	wake_up(&cdev->private->wait_q);
 }
 
-static void
-device_call_sch_unregister(void *data)
+void
+ccw_device_call_sch_unregister(void *data)
 {
 	struct ccw_device *cdev = data;
 	struct subchannel *sch;
@@ -640,6 +659,7 @@
 	sch->schib.pmcw.intparm = 0;
 	cio_modify(sch);
 	put_device(&cdev->dev);
+	put_device(&sch->dev);
 }
 
 /*
@@ -662,8 +682,8 @@
 			break;
 		sch = to_subchannel(cdev->dev.parent);
 		INIT_WORK(&cdev->private->kick_work,
-			  device_call_sch_unregister, (void *) cdev);
-		queue_work(ccw_device_work, &cdev->private->kick_work);
+			  ccw_device_call_sch_unregister, (void *) cdev);
+		queue_work(slow_path_wq, &cdev->private->kick_work);
 		break;
 	case DEV_STATE_BOXED:
 		/* Device did not respond in time. */
@@ -1057,3 +1077,4 @@
 EXPORT_SYMBOL(get_ccwdev_by_busid);
 EXPORT_SYMBOL(ccw_bus_type);
 EXPORT_SYMBOL(ccw_device_work);
+EXPORT_SYMBOL(ccw_device_notify_work);

--- linux-2.5/drivers/s390/cio/device.h	7 Apr 2004 14:56:48 -0000	1.20
+++ linux-2.5/drivers/s390/cio/device.h	9 Jun 2004 11:21:53 -0000	1.20.2.1
@@ -66,6 +66,7 @@
 }
 
 extern struct workqueue_struct *ccw_device_work;
+extern struct workqueue_struct *ccw_device_notify_work;
 
 void io_subchannel_recog_done(struct ccw_device *cdev);
 
@@ -73,7 +74,7 @@
 
 int ccw_device_register(struct ccw_device *);
 void ccw_device_do_unreg_rereg(void *);
-
+void ccw_device_call_sch_unregister(void *);
 
 int ccw_device_recognition(struct ccw_device *);
 int ccw_device_online(struct ccw_device *);

--- linux-2.5/drivers/s390/s390mach.c	12 Feb 2004 19:57:23 -0000	1.21
+++ linux-2.5/drivers/s390/s390mach.c	9 Jun 2004 11:21:53 -0000	1.21.2.1
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/errno.h>
+#include <linux/workqueue.h>
 
 #include <asm/lowcore.h>
 
@@ -21,13 +22,14 @@
 // #define DBG(args,...) do {} while (0);
 
 static struct semaphore m_sem;
-static struct semaphore s_sem;
 
 extern int css_process_crw(int);
 extern int chsc_process_crw(void);
 extern int chp_process_crw(int, int);
 extern void css_reiterate_subchannels(void);
-extern void css_trigger_slow_path(void);
+
+extern struct workqueue_struct *slow_path_wq;
+extern struct work_struct slow_path_work;
 
 static void
 s390_handle_damage(char *msg)
@@ -39,21 +41,6 @@
 	disabled_wait((unsigned long) __builtin_return_address(0));
 }
 
-static int
-s390_mchk_slow_path(void *param)
-{
-	struct semaphore *sem;
-
-	sem = (struct semaphore *)param;
-	/* Set a nice name. */
-	daemonize("kslowcrw");
-repeat:
-	down_interruptible(sem);
-	css_trigger_slow_path();
-	goto repeat;
-	return 0;
-}
-
 /*
  * Retrieve CRWs and call function to handle event.
  *
@@ -130,7 +117,7 @@
 		}
 	}
 	if (slow)
-		up(&s_sem);
+		queue_work(slow_path_wq, &slow_path_work);
 	goto repeat;
 	return 0;
 }
@@ -202,7 +189,6 @@
 machine_check_init(void)
 {
 	init_MUTEX_LOCKED(&m_sem);
-	init_MUTEX_LOCKED( &s_sem );
 	ctl_clear_bit(14, 25);	/* disable damage MCH */
 	ctl_set_bit(14, 26);	/* enable degradation MCH */
 	ctl_set_bit(14, 27);	/* enable system recovery MCH */
@@ -226,7 +212,6 @@
 machine_check_crw_init (void)
 {
 	kernel_thread(s390_collect_crw_info, &m_sem, CLONE_FS|CLONE_FILES);
-	kernel_thread(s390_mchk_slow_path, &s_sem, CLONE_FS|CLONE_FILES);
 	ctl_set_bit(14, 28);	/* enable channel report MCH */
 	return 0;
 }

--- linux-2.5/drivers/s390/cio/css.c	8 Jun 2004 19:01:45 -0000	1.72.2.2
+++ linux-2.5/drivers/s390/cio/css.c	9 Jun 2004 11:21:53 -0000	1.72.2.3
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/css.c
  *  driver for channel subsystem
- *   $Revision: 1.72.2.2 $
+ *   $Revision: 1.72.2.3 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -166,10 +166,12 @@
 	if (sch && sch->schib.pmcw.dnv &&
 	    (schib.pmcw.dev != sch->schib.pmcw.dev))
 		return CIO_REVALIDATE;
+	if (sch && !sch->lpm)
+		return CIO_NO_PATH;
 	return CIO_OPER;
 }
 	
-static inline int
+static int
 css_evaluate_subchannel(int irq, int slow)
 {
 	int event, ret, disc;
@@ -188,7 +190,11 @@
 		return -EAGAIN; /* Will be done on the slow path. */
 	}
 	event = css_get_subchannel_status(sch, irq);
+	CIO_MSG_EVENT(4, "Evaluating schid %04x, event %d, %s, %s path.\n",
+		      irq, event, sch?(disc?"disconnected":"normal"):"unknown",
+		      slow?"slow":"fast");
 	switch (event) {
+	case CIO_NO_PATH:
 	case CIO_GONE:
 		if (!sch) {
 			/* Never used this subchannel. Ignore. */
@@ -196,7 +202,8 @@
 			break;
 		}
 		if (sch->driver && sch->driver->notify &&
-		    sch->driver->notify(&sch->dev, CIO_GONE)) {
+		    sch->driver->notify(&sch->dev, event)) {
+			cio_disable_subchannel(sch);
 			device_set_disconnected(sch);
 			ret = 0;
 			break;
@@ -205,6 +212,7 @@
 		 * Unregister subchannel.
 		 * The device will be killed automatically.
 		 */
+		cio_disable_subchannel(sch);
 		device_unregister(&sch->dev);
 		/* Reset intparm to zeroes. */
 		sch->schib.pmcw.intparm = 0;
@@ -266,23 +274,44 @@
 	}
 }
 
-static void
-css_evaluate_slow_subchannel(unsigned long schid)
-{
-	css_evaluate_subchannel(schid, 1);
-}
+struct slow_subchannel {
+	struct list_head slow_list;
+	unsigned long schid;
+};
 
-void
+static LIST_HEAD(slow_subchannels_head);
+static spinlock_t slow_subchannel_lock = SPIN_LOCK_UNLOCKED;
+
+static void
 css_trigger_slow_path(void)
 {
+	CIO_TRACE_EVENT(4, "slowpath");
+
 	if (need_rescan) {
 		need_rescan = 0;
 		css_rescan_devices();
 		return;
 	}
-	css_walk_subchannel_slow_list(css_evaluate_slow_subchannel);
+
+	spin_lock_irq(&slow_subchannel_lock);
+	while (!list_empty(&slow_subchannels_head)) {
+		struct slow_subchannel *slow_sch =
+			list_entry(slow_subchannels_head.next,
+				   struct slow_subchannel, slow_list);
+
+		list_del_init(slow_subchannels_head.next);
+		spin_unlock_irq(&slow_subchannel_lock);
+		css_evaluate_subchannel(slow_sch->schid, 1);
+		spin_lock_irq(&slow_subchannel_lock);
+		kfree(slow_sch);
+	}
+	spin_unlock_irq(&slow_subchannel_lock);
 }
 
+typedef void (*workfunc)(void *);
+DECLARE_WORK(slow_path_work, (workfunc)css_trigger_slow_path, NULL);
+struct workqueue_struct *slow_path_wq;
+
 /*
  * Rescan for new devices. FIXME: This is slow.
  * This function is called when we have lost CRWs due to overflows and we have
@@ -443,14 +472,6 @@
 		device_unregister(dev);
 }
 
-struct slow_subchannel {
-	struct list_head slow_list;
-	unsigned long schid;
-};
-
-static LIST_HEAD(slow_subchannels_head);
-static spinlock_t slow_subchannel_lock = SPIN_LOCK_UNLOCKED;
-
 int
 css_enqueue_subchannel_slow(unsigned long schid)
 {
@@ -484,25 +505,7 @@
 	spin_unlock_irqrestore(&slow_subchannel_lock, flags);
 }
 
-void
-css_walk_subchannel_slow_list(void (*fn)(unsigned long))
-{
-	unsigned long flags;
 
-	spin_lock_irqsave(&slow_subchannel_lock, flags);
-	while (!list_empty(&slow_subchannels_head)) {
-		struct slow_subchannel *slow_sch =
-			list_entry(slow_subchannels_head.next,
-				   struct slow_subchannel, slow_list);
-
-		list_del_init(slow_subchannels_head.next);
-		spin_unlock_irqrestore(&slow_subchannel_lock, flags);
-		fn(slow_sch->schid);
-		spin_lock_irqsave(&slow_subchannel_lock, flags);
-		kfree(slow_sch);
-	}
-	spin_unlock_irqrestore(&slow_subchannel_lock, flags);
-}
 
 int
 css_slow_subchannels_exist(void)

--- linux-2.5/drivers/s390/cio/device_fsm.c	8 Jun 2004 19:01:46 -0000	1.85.2.4
+++ linux-2.5/drivers/s390/cio/device_fsm.c	9 Jun 2004 11:21:53 -0000	1.85.2.5
@@ -329,7 +329,7 @@
 		cdev->private->flags.donotify = 0;
 		PREPARE_WORK(&cdev->private->kick_work, ccw_device_oper_notify,
 			     (void *)cdev);
-		queue_work(ccw_device_work, &cdev->private->kick_work);
+		queue_work(ccw_device_notify_work, &cdev->private->kick_work);
 	}
 	wake_up(&cdev->private->wait_q);
 
@@ -442,10 +442,13 @@
 		if (get_device(&sch->dev)) {
 			/* Driver doesn't want to keep device. */
 			cio_disable_subchannel(sch);
-			device_unregister(&sch->dev);
-			sch->schib.pmcw.intparm = 0;
-			cio_modify(sch);
-			put_device(&sch->dev);
+			if (get_device(&cdev->dev)) {
+				PREPARE_WORK(&cdev->private->kick_work,
+					     ccw_device_call_sch_unregister,
+					     (void *)cdev);
+				queue_work(ccw_device_work,
+					   &cdev->private->kick_work);
+			}
 		}
 	} else {
 		cio_disable_subchannel(sch);
@@ -456,20 +459,6 @@
 }
 
 void
-device_call_nopath_notify(struct subchannel *sch)
-{
-	struct ccw_device *cdev;
-
-	if (!sch->dev.driver_data)
-		return;
-	cdev = sch->dev.driver_data;
-	PREPARE_WORK(&cdev->private->kick_work,
-		     ccw_device_nopath_notify, (void *)cdev);
-	queue_work(ccw_device_work, &cdev->private->kick_work);
-}
-
-
-void
 ccw_device_verify_done(struct ccw_device *cdev, int err)
 {
 	cdev->private->flags.doverify = 0;
@@ -485,7 +474,7 @@
 	default:
 		PREPARE_WORK(&cdev->private->kick_work,
 			     ccw_device_nopath_notify, (void *)cdev);
-		queue_work(ccw_device_work, &cdev->private->kick_work);
+		queue_work(ccw_device_notify_work, &cdev->private->kick_work);
 		ccw_device_done(cdev, DEV_STATE_NOT_OPER);
 		break;
 	}
@@ -725,7 +714,8 @@
 		if (!sch->lpm) {
 			PREPARE_WORK(&cdev->private->kick_work,
 				     ccw_device_nopath_notify, (void *)cdev);
-			queue_work(ccw_device_work, &cdev->private->kick_work);
+			queue_work(ccw_device_notify_work,
+				   &cdev->private->kick_work);
 		} else
 			dev_fsm_event(cdev, DEV_EVENT_NOTOPER);
 	} else if (cdev->handler)
@@ -801,7 +791,7 @@
 	if (!sch->lpm) {
 		PREPARE_WORK(&cdev->private->kick_work,
 			     ccw_device_nopath_notify, (void *)cdev);
-		queue_work(ccw_device_work, &cdev->private->kick_work);
+		queue_work(ccw_device_notify_work, &cdev->private->kick_work);
 	} else if (cdev->private->flags.doverify)
 		/* Start delayed path verification. */
 		ccw_device_online_verify(cdev, 0);
@@ -824,7 +814,8 @@
 		if (!sch->lpm) {
 			PREPARE_WORK(&cdev->private->kick_work,
 				     ccw_device_nopath_notify, (void *)cdev);
-			queue_work(ccw_device_work, &cdev->private->kick_work);
+			queue_work(ccw_device_notify_work,
+				   &cdev->private->kick_work);
 		} else
 			dev_fsm_event(cdev, DEV_EVENT_NOTOPER);
 		return;
@@ -874,7 +865,7 @@
 	if (!sch->lpm) {
 		PREPARE_WORK(&cdev->private->kick_work,
 			     ccw_device_nopath_notify, (void *)cdev);
-		queue_work(ccw_device_work, &cdev->private->kick_work);
+		queue_work(ccw_device_notify_work, &cdev->private->kick_work);
 	} else if (cdev->private->flags.doverify)
 		ccw_device_online_verify(cdev, 0);
 }
@@ -897,7 +888,8 @@
 		if (!sch->lpm) {
 			PREPARE_WORK(&cdev->private->kick_work,
 				     ccw_device_nopath_notify, (void *)cdev);
-			queue_work(ccw_device_work, &cdev->private->kick_work);
+			queue_work(ccw_device_notify_work,
+				   &cdev->private->kick_work);
 		} else
 			dev_fsm_event(cdev, DEV_EVENT_NOTOPER);
 		return;
@@ -908,7 +900,7 @@
 	if (!sch->lpm) {
 		PREPARE_WORK(&cdev->private->kick_work,
 			     ccw_device_nopath_notify, (void *)cdev);
-		queue_work(ccw_device_work, &cdev->private->kick_work);
+		queue_work(ccw_device_notify_work, &cdev->private->kick_work);
 	} else if (cdev->private->flags.doverify)
 		/* Start delayed path verification. */
 		ccw_device_online_verify(cdev, 0);

