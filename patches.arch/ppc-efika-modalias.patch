Subject: add modalias file for of_devices to sysfs 
From: olh@suse.de

modalias files are supposed to be there for every node.
They allow module autoloading, and it is possible to match required kernel modules.
Tested on Efika:

	==> /sys/devices/f0000000.builtin/f0003a00.ata/devspec <==
	/builtin@F0000000/ata@F0003A00

	==> /sys/devices/f0000000.builtin/f0003a00.ata/modalias <==
	of:NataTataCmpc5200b-ataCmpc5200-ata

Also add a newline to the 'devspec' file output.

---
 drivers/macintosh/macio_sysfs.c |   11 ++++++++
 drivers/of/device.c             |   50 ++++++++++++++++++++++++++++------------
 drivers/of/platform.c           |    2 +
 3 files changed, 48 insertions(+), 15 deletions(-)

--- a/drivers/macintosh/macio_sysfs.c	2007-10-31 17:43:32.000000000 -0400
+++ b/drivers/macintosh/macio_sysfs.c	2007-10-31 17:43:52.000000000 -0400
@@ -52,12 +52,23 @@ static ssize_t modalias_show (struct dev
 	return len+1;
 }
 
+static ssize_t devspec_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct of_device *ofdev;
+
+	ofdev = to_of_device(dev);
+	return sprintf(buf, "%s\n", ofdev->node->full_name);
+}
+
+
 macio_config_of_attr (name, "%s\n");
 macio_config_of_attr (type, "%s\n");
 
 struct device_attribute macio_dev_attrs[] = {
 	__ATTR_RO(name),
 	__ATTR_RO(type),
+	__ATTR_RO(devspec),
 	__ATTR_RO(compatible),
 	__ATTR_RO(modalias),
 	__ATTR_NULL
--- a/drivers/of/device.c	2007-10-31 17:43:32.000000000 -0400
+++ b/drivers/of/device.c	2007-10-31 17:43:52.000000000 -0400
@@ -77,16 +77,47 @@ void of_dev_put(struct of_device *dev)
 }
 EXPORT_SYMBOL(of_dev_put);
 
-static ssize_t dev_show_devspec(struct device *dev,
+static ssize_t devspec_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
 	struct of_device *ofdev;
 
 	ofdev = to_of_device(dev);
-	return sprintf(buf, "%s", ofdev->node->full_name);
+	return sprintf(buf, "%s\n", ofdev->node->full_name);
 }
 
-static DEVICE_ATTR(devspec, S_IRUGO, dev_show_devspec, NULL);
+static ssize_t modalias_show (struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct of_device *ofdev;
+	const char *compat;
+	int cplen;
+	int length;
+
+	ofdev = to_of_device(dev);
+	compat = get_property(ofdev->node, "compatible", &cplen);
+	if (!compat) compat = "", cplen = 1;
+	length = sprintf (buf, "of:N%sT%s", ofdev->node->name, ofdev->node->type);
+	buf += length;
+	while (cplen > 0) {
+		int l;
+		l = sprintf (buf, "C%s", compat);
+		length += l;
+		buf += l;
+		l = strlen (compat) + 1;
+		compat += l;
+		cplen -= l;
+	}
+	length += sprintf (buf, "\n");
+
+	return length;
+}
+
+struct device_attribute of_platform_device_attrs[] = {
+	__ATTR_RO(devspec),
+	__ATTR_RO(modalias),
+	__ATTR_NULL
+};
 
 /**
  * of_release_dev - free an of device structure when all users of it are finished.
@@ -107,25 +138,14 @@ EXPORT_SYMBOL(of_release_dev);
 
 int of_device_register(struct of_device *ofdev)
 {
-	int rc;
-
 	BUG_ON(ofdev->node == NULL);
 
-	rc = device_register(&ofdev->dev);
-	if (rc)
-		return rc;
-
-	rc = device_create_file(&ofdev->dev, &dev_attr_devspec);
-	if (rc)
-		device_unregister(&ofdev->dev);
-
-	return rc;
+	return device_register(&ofdev->dev);
 }
 EXPORT_SYMBOL(of_device_register);
 
 void of_device_unregister(struct of_device *ofdev)
 {
-	device_remove_file(&ofdev->dev, &dev_attr_devspec);
 	device_unregister(&ofdev->dev);
 }
 EXPORT_SYMBOL(of_device_unregister);
--- a/drivers/of/platform.c	2007-10-31 17:43:32.000000000 -0400
+++ b/drivers/of/platform.c	2007-10-31 17:43:52.000000000 -0400
@@ -86,11 +86,13 @@ static int of_platform_device_resume(str
 
 int of_bus_type_init(struct bus_type *bus, const char *name)
 {
+	extern struct device_attribute of_platform_device_attrs[];
 	bus->name = name;
 	bus->match = of_platform_bus_match;
 	bus->probe = of_platform_device_probe;
 	bus->remove = of_platform_device_remove;
 	bus->suspend = of_platform_device_suspend;
 	bus->resume = of_platform_device_resume;
+	bus->dev_attrs = of_platform_device_attrs;
 	return bus_register(bus);
 }
