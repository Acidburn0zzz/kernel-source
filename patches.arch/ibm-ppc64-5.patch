ChangeSet
  1.1534 04/03/30 11:35:07 anton@samba.org +20 -0
  The iSeries has an arch-specific mapping from physical <-> absolute
  addresses.  Fortunately this is only used in a few places.  However,
  the following arch-specific macros/functions are provided in addition
  to the standard macros:
  
          __a2p()
          __a2v()
          __p2a()
          __p2v()
          __v2a()
          __v2p()
          absolute_to_phys()
          phys_to_absolute()
          virt_to_absolute()
          absolute_to_virt()
  
  Reduce them to these, with slightly shorter names, and taking either
  pointers or unsigned long (as per __va and __pa) rather than making
  the caller cast:
  
          abs_to_phys()
          phys_to_abs()
  
  And helper macros:
  
          virt_to_abs()
          abs_to_virt()
  
  As is standard, virtual addresses are returned as void *, physical and
  absolute as unsigned long.
  
  Note that the change the iSeries_setup is a little subtle: ea is set
  to __va(pa) above, so "phys_to_abs(pa)" is the same as
  "virt_to_abs(ea)".
  
  Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
  places where appropriate.

  include/asm-ppc64/page.h
    1.27 04/03/30 11:34:47 anton@samba.org +0 -13
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  include/asm-ppc64/iSeries/iSeries_pci.h
    1.7 04/03/30 11:34:47 anton@samba.org +2 -1
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  include/asm-ppc64/iSeries/HvCallEvent.h
    1.4 04/03/30 11:34:47 anton@samba.org +5 -5
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  include/asm-ppc64/abs_addr.h
    1.3 04/03/30 11:34:47 anton@samba.org +13 -26
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  drivers/net/iseries_veth.c
    1.14 04/03/30 11:34:47 anton@samba.org +5 -9
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/mm/init.c
    1.65 04/03/30 11:34:47 anton@samba.org +3 -2
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/mm/hash_utils.c
    1.52 04/03/30 11:34:47 anton@samba.org +5 -3
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/smp.c
    1.69 04/03/30 11:34:47 anton@samba.org +1 -1
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/rtas.c
    1.33 04/03/30 11:34:47 anton@samba.org +4 -4
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/prom.c
    1.78 04/03/30 11:34:47 anton@samba.org +7 -4
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/pmac_iommu.c
    1.3 04/03/30 11:34:47 anton@samba.org +3 -3
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/pci_dma_direct.c
    1.2 04/03/30 11:34:47 anton@samba.org +2 -2
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/pSeries_lpar.c
    1.51 04/03/30 11:34:47 anton@samba.org +2 -1
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/pSeries_iommu.c
    1.4 04/03/30 11:34:46 anton@samba.org +1 -1
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/mf.c
    1.13 04/03/30 11:34:46 anton@samba.org +4 -8
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/iSeries_setup.c
    1.31 04/03/30 11:34:46 anton@samba.org +1 -2
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/iSeries_pci.c
    1.28 04/03/30 11:34:46 anton@samba.org +2 -2
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/iSeries_iommu.c
    1.5 04/03/30 11:34:46 anton@samba.org +3 -3
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/iSeries_VpdInfo.c
    1.11 04/03/30 11:34:46 anton@samba.org +2 -1
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

  arch/ppc64/kernel/HvCall.c
    1.7 04/03/30 11:34:46 anton@samba.org +2 -2
    The iSeries has an arch-specific mapping from physical <-> absolute
    addresses.  Fortunately this is only used in a few places.  However,
    the following arch-specific macros/functions are provided in addition
    to the standard macros:
    
            __a2p()
            __a2v()
            __p2a()
            __p2v()
            __v2a()
            __v2p()
            absolute_to_phys()
            phys_to_absolute()
            virt_to_absolute()
            absolute_to_virt()
    
    Reduce them to these, with slightly shorter names, and taking either
    pointers or unsigned long (as per __va and __pa) rather than making
    the caller cast:
    
            abs_to_phys()
            phys_to_abs()
    
    And helper macros:
    
            virt_to_abs()
            abs_to_virt()
    
    As is standard, virtual addresses are returned as void *, physical and
    absolute as unsigned long.
    
    Note that the change the iSeries_setup is a little subtle: ea is set
    to __va(pa) above, so "phys_to_abs(pa)" is the same as
    "virt_to_abs(ea)".
    
    Also, REALADDR is renamed to ISERIES_HV_ADDR and used in a couple of
    places where appropriate.

diff -Nru a/arch/ppc64/kernel/HvCall.c b/arch/ppc64/kernel/HvCall.c
--- a/arch/ppc64/kernel/HvCall.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/HvCall.c	Tue Mar 30 07:08:06 2004
@@ -19,7 +19,7 @@
 {
 	struct HvLpBufferList hv_buf;
 	u64 left_this_page;
-	u64 cur = virt_to_absolute((unsigned long)buffer);
+	u64 cur = virt_to_abs(buffer);
 
 	while (len) {
 		hv_buf.addr = cur;
@@ -29,7 +29,7 @@
 		hv_buf.len = left_this_page;
 		len -= left_this_page;
 		HvCall2(HvCallBaseWriteLogBuffer,
-				virt_to_absolute((unsigned long)&hv_buf),
+				virt_to_abs(&hv_buf),
 				left_this_page);
 		cur = (cur & PAGE_MASK) + PAGE_SIZE;
 	}
diff -Nru a/arch/ppc64/kernel/iSeries_VpdInfo.c b/arch/ppc64/kernel/iSeries_VpdInfo.c
--- a/arch/ppc64/kernel/iSeries_VpdInfo.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/iSeries_VpdInfo.c	Tue Mar 30 07:08:06 2004
@@ -293,7 +293,8 @@
 		return;
 	}
 	BusVpdLen = HvCallPci_getBusVpd(ISERIES_BUS(DevNode),
-			REALADDR(BusVpdPtr), BUS_VPDSIZE);
+					ISERIES_HV_ADDR(BusVpdPtr),
+					BUS_VPDSIZE);
 	if (BusVpdLen == 0) {
 		kfree(BusVpdPtr);
 		printk("PCI: Bus VPD Buffer zero length.\n");
diff -Nru a/arch/ppc64/kernel/iSeries_iommu.c b/arch/ppc64/kernel/iSeries_iommu.c
--- a/arch/ppc64/kernel/iSeries_iommu.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/iSeries_iommu.c	Tue Mar 30 07:08:06 2004
@@ -76,7 +76,7 @@
 	
 	while (npages--) {
 		tce.te_word = 0;
-		tce.te_bits.tb_rpn = (virt_to_absolute(uaddr)) >> PAGE_SHIFT;
+		tce.te_bits.tb_rpn = virt_to_abs(uaddr) >> PAGE_SHIFT;
 
 		if (tbl->it_type == TCE_VB) {
 			/* Virtual Bus */
@@ -130,7 +130,7 @@
 	cb.itc_busno = 255;    /* Bus 255 is the virtual bus */
 	cb.itc_virtbus = 0xff; /* Ask for virtual bus */
 	
-	cbp = virt_to_absolute((unsigned long)&cb);
+	cbp = virt_to_abs(&cb);
 	HvCallXm_getTceTableParms(cbp);
 	
 	veth_iommu_table.it_size        = cb.itc_size / 2;
@@ -209,7 +209,7 @@
 	parms->itc_slotno  = dn->LogicalSlot;
 	parms->itc_virtbus = 0;
 
-	HvCallXm_getTceTableParms(REALADDR(parms));
+	HvCallXm_getTceTableParms(ISERIES_HV_ADDR(parms));
 
 	if (parms->itc_size == 0)
 		panic("PCI_DMA: parms->size is zero, parms is 0x%p", parms);
diff -Nru a/arch/ppc64/kernel/iSeries_pci.c b/arch/ppc64/kernel/iSeries_pci.c
--- a/arch/ppc64/kernel/iSeries_pci.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/iSeries_pci.c	Tue Mar 30 07:08:06 2004
@@ -283,7 +283,7 @@
 	 */
 	for (IdSel = 1; IdSel < MaxAgents; ++IdSel) {
     		HvRc = HvCallPci_getDeviceInfo(bus, SubBus, IdSel,
-				REALADDR(DevInfo),
+				ISERIES_HV_ADDR(DevInfo),
 				sizeof(struct HvCallPci_DeviceInfo));
 		if (HvRc == 0) {
 			if (DevInfo->deviceType == HvCallPci_NodeDevice)
@@ -324,7 +324,7 @@
 					"PCI:Connect EADs: 0x%02X.%02X.%02X\n",
 					bus, SubBus, AgentId);
 	    		HvRc = HvCallPci_getBusUnitInfo(bus, SubBus, AgentId,
-					REALADDR(BridgeInfo),
+					ISERIES_HV_ADDR(BridgeInfo),
 					sizeof(struct HvCallPci_BridgeInfo));
 	 		if (HvRc == 0) {
 				printk("bridge info: type %x subbus %x maxAgents %x maxsubbus %x logslot %x\n",
diff -Nru a/arch/ppc64/kernel/iSeries_setup.c b/arch/ppc64/kernel/iSeries_setup.c
--- a/arch/ppc64/kernel/iSeries_setup.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/iSeries_setup.c	Tue Mar 30 07:08:06 2004
@@ -657,8 +657,7 @@
 			HvCallHpt_setPp(slot, PP_RWXX);
 		} else
 			/* No HPTE exists, so create a new bolted one */
-			iSeries_make_pte(va, (unsigned long)__v2a(ea),
-					mode_rw);
+			iSeries_make_pte(va, phys_to_abs(pa), mode_rw);
 	}
 }
 
diff -Nru a/arch/ppc64/kernel/mf.c b/arch/ppc64/kernel/mf.c
--- a/arch/ppc64/kernel/mf.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/mf.c	Tue Mar 30 07:08:06 2004
@@ -763,14 +763,10 @@
 	ev->event.data.vsp_cmd.lp_index = HvLpConfig_getLpIndex();
 	ev->event.data.vsp_cmd.result_code = 0xFF;
 	ev->event.data.vsp_cmd.reserved = 0;
-	ev->event.data.vsp_cmd.sub_data.page[0] =
-		(0x8000000000000000ULL | virt_to_absolute((unsigned long)pages[0]));
-	ev->event.data.vsp_cmd.sub_data.page[1] =
-		(0x8000000000000000ULL | virt_to_absolute((unsigned long)pages[1]));
-	ev->event.data.vsp_cmd.sub_data.page[2] =
-		(0x8000000000000000ULL | virt_to_absolute((unsigned long)pages[2]));
-	ev->event.data.vsp_cmd.sub_data.page[3] =
-		(0x8000000000000000ULL | virt_to_absolute((unsigned long)pages[3]));
+	ev->event.data.vsp_cmd.sub_data.page[0] = ISERIES_HV_ADDR(pages[0]);
+	ev->event.data.vsp_cmd.sub_data.page[1] = ISERIES_HV_ADDR(pages[1]);
+	ev->event.data.vsp_cmd.sub_data.page[2] = ISERIES_HV_ADDR(pages[2]);
+	ev->event.data.vsp_cmd.sub_data.page[3] = ISERIES_HV_ADDR(pages[3]);
 	mb();
 	if (signal_event(ev) != 0)
 		return;
diff -Nru a/arch/ppc64/kernel/pSeries_iommu.c b/arch/ppc64/kernel/pSeries_iommu.c
--- a/arch/ppc64/kernel/pSeries_iommu.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/pSeries_iommu.c	Tue Mar 30 07:08:06 2004
@@ -61,7 +61,7 @@
 
 	while (npages--) {
 		/* can't move this out since we might cross LMB boundary */
-		t.te_rpn = (virt_to_absolute(uaddr)) >> PAGE_SHIFT;
+		t.te_rpn = (virt_to_abs(uaddr)) >> PAGE_SHIFT;
 	
 		tp->te_word = t.te_word;
 
diff -Nru a/arch/ppc64/kernel/pSeries_lpar.c b/arch/ppc64/kernel/pSeries_lpar.c
--- a/arch/ppc64/kernel/pSeries_lpar.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/pSeries_lpar.c	Tue Mar 30 07:08:06 2004
@@ -36,6 +36,7 @@
 #include <asm/tlb.h>
 #include <asm/hvcall.h>
 #include <asm/prom.h>
+#include <asm/abs_addr.h>
 
 /* in pSeries_hvCall.S */
 EXPORT_SYMBOL(plpar_hcall);
@@ -135,7 +136,7 @@
 	union tce_entry tce;
 
 	tce.te_word = 0;
-	tce.te_rpn = (virt_to_absolute(uaddr)) >> PAGE_SHIFT;
+	tce.te_rpn = (virt_to_abs(uaddr)) >> PAGE_SHIFT;
 	tce.te_rdwr = 1;
 	if (direction != PCI_DMA_TODEVICE)
 		tce.te_pciwr = 1;
diff -Nru a/arch/ppc64/kernel/pci_dma_direct.c b/arch/ppc64/kernel/pci_dma_direct.c
--- a/arch/ppc64/kernel/pci_dma_direct.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/pci_dma_direct.c	Tue Mar 30 07:08:06 2004
@@ -37,7 +37,7 @@
 	ret = (void *)__get_free_pages(GFP_ATOMIC, get_order(size));
 	if (ret != NULL) {
 		memset(ret, 0, size);
-		*dma_handle = virt_to_absolute((unsigned long)ret);
+		*dma_handle = virt_to_abs(ret);
 	}
 	return ret;
 }
@@ -51,7 +51,7 @@
 static dma_addr_t pci_direct_map_single(struct pci_dev *hwdev, void *ptr,
 				  size_t size, int direction)
 {
-	return virt_to_absolute((unsigned long)ptr);
+	return virt_to_abs(ptr);
 }
 
 static void pci_direct_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr,
diff -Nru a/arch/ppc64/kernel/pmac_iommu.c b/arch/ppc64/kernel/pmac_iommu.c
--- a/arch/ppc64/kernel/pmac_iommu.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/pmac_iommu.c	Tue Mar 30 07:08:06 2004
@@ -154,7 +154,7 @@
 	 * out of the loop.
 	 */
 	while (npages--) {
-		rpn = (virt_to_absolute(uaddr)) >> PAGE_SHIFT;
+		rpn = virt_to_abs(uaddr) >> PAGE_SHIFT;
 
 		*(dp++) = DARTMAP_VALID | (rpn & DARTMAP_RPNMASK);
 
@@ -210,7 +210,7 @@
 	if (tmp == 0)
 		panic("U3-DART: Cannot allocate spare page !");
 	dart_emptyval = DARTMAP_VALID |
-		((virt_to_absolute(tmp) >> PAGE_SHIFT) & DARTMAP_RPNMASK);
+		((virt_to_abs(tmp) >> PAGE_SHIFT) & DARTMAP_RPNMASK);
 
 	/* Map in DART registers. FIXME: Use device node to get base address */
 	dart = ioremap(DART_BASE, 0x7000);
@@ -225,7 +225,7 @@
 		(((dart_tablesize >> PAGE_SHIFT) & DARTCNTL_SIZE_MASK)
 				 << DARTCNTL_SIZE_SHIFT);
 	p = virt_to_page(dart_tablebase);
-	dart_vbase = ioremap(virt_to_absolute(dart_tablebase), dart_tablesize);
+	dart_vbase = ioremap(virt_to_abs(dart_tablebase), dart_tablesize);
 
 	/* Fill initial table */
 	for (i = 0; i < dart_tablesize/4; i++)
diff -Nru a/arch/ppc64/kernel/prom.c b/arch/ppc64/kernel/prom.c
--- a/arch/ppc64/kernel/prom.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/prom.c	Tue Mar 30 07:08:06 2004
@@ -900,7 +900,7 @@
 			prom_panic(RELOC("ERROR, cannot find space for TCE table.\n"));
 		}
 
-		vbase = absolute_to_virt(base);
+		vbase = (unsigned long)abs_to_virt(base);
 
 		/* Save away the TCE table attributes for later use. */
 		prom_tce_table[table].node = node;
@@ -1007,9 +1007,12 @@
 	extern void __secondary_hold(void);
         extern unsigned long __secondary_hold_spinloop;
         extern unsigned long __secondary_hold_acknowledge;
-        unsigned long *spinloop     = __v2a(&__secondary_hold_spinloop);
-        unsigned long *acknowledge  = __v2a(&__secondary_hold_acknowledge);
-        unsigned long secondary_hold = (unsigned long)__v2a(*PTRRELOC((unsigned long *)__secondary_hold));
+        unsigned long *spinloop
+		= (void *)virt_to_abs(&__secondary_hold_spinloop);
+        unsigned long *acknowledge
+		= (void *)virt_to_abs(&__secondary_hold_acknowledge);
+        unsigned long secondary_hold
+		= virt_to_abs(*PTRRELOC((unsigned long *)__secondary_hold));
         struct systemcfg *_systemcfg = RELOC(systemcfg);
 	struct paca_struct *_xPaca = PTRRELOC(&paca[0]);
 	struct prom_t *_prom = PTRRELOC(&prom);
diff -Nru a/arch/ppc64/kernel/rtas.c b/arch/ppc64/kernel/rtas.c
--- a/arch/ppc64/kernel/rtas.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/rtas.c	Tue Mar 30 07:08:06 2004
@@ -362,7 +362,7 @@
 	 */
 	rtas_firmware_flash_list.num_blocks = 0;
 	flist = (struct flash_block_list *)&rtas_firmware_flash_list;
-	rtas_block_list = virt_to_absolute((unsigned long)flist);
+	rtas_block_list = virt_to_abs(flist);
 	if (rtas_block_list >= (4UL << 20)) {
 		printk(KERN_ALERT "FLASH: kernel bug...flash list header addr above 4GB\n");
 		return;
@@ -374,13 +374,13 @@
 	for (f = flist; f; f = next) {
 		/* Translate data addrs to absolute */
 		for (i = 0; i < f->num_blocks; i++) {
-			f->blocks[i].data = (char *)virt_to_absolute((unsigned long)f->blocks[i].data);
+			f->blocks[i].data = (char *)virt_to_abs(f->blocks[i].data);
 			image_size += f->blocks[i].length;
 		}
 		next = f->next;
 		/* Don't translate NULL pointer for last entry */
-		if(f->next)
-			f->next = (struct flash_block_list *)virt_to_absolute((unsigned long)f->next);
+		if (f->next)
+			f->next = (struct flash_block_list *)virt_to_abs(f->next);
 		else
 			f->next = 0LL;
 		/* make num_blocks into the version/length field */
diff -Nru a/arch/ppc64/kernel/smp.c b/arch/ppc64/kernel/smp.c
--- a/arch/ppc64/kernel/smp.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/kernel/smp.c	Tue Mar 30 07:08:06 2004
@@ -986,7 +986,7 @@
 		tmp = &stab_array[PAGE_SIZE * cpu];
 		memset(tmp, 0, PAGE_SIZE); 
 		paca[cpu].xStab_data.virt = (unsigned long)tmp;
-		paca[cpu].xStab_data.real = (unsigned long)__v2a(tmp);
+		paca[cpu].xStab_data.real = virt_to_abs(tmp);
 	}
 
 	/* The information for processor bringup must be written out
diff -Nru a/arch/ppc64/mm/hash_utils.c b/arch/ppc64/mm/hash_utils.c
--- a/arch/ppc64/mm/hash_utils.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/mm/hash_utils.c	Tue Mar 30 07:08:06 2004
@@ -48,6 +48,8 @@
 #include <asm/tlb.h>
 #include <asm/cacheflush.h>
 #include <asm/cputable.h>
+#include <asm/abs_addr.h>
+
 /*
  * Note:  pte   --> Linux PTE
  *        HPTE  --> PowerPC Hashed Page Table Entry
@@ -107,11 +109,11 @@
 
 		if (systemcfg->platform == PLATFORM_PSERIES_LPAR)
 			ret = pSeries_lpar_hpte_insert(hpteg, va,
-				(unsigned long)__v2a(addr) >> PAGE_SHIFT,
+				virt_to_abs(addr) >> PAGE_SHIFT,
 				0, mode, 1, large);
 		else
 			ret = pSeries_hpte_insert(hpteg, va,
-				(unsigned long)__v2a(addr) >> PAGE_SHIFT,
+				virt_to_abs(addr) >> PAGE_SHIFT,
 				0, mode, 1, large);
 
 		if (ret == -1) {
@@ -154,7 +156,7 @@
 			ppc64_terminate_msg(0x20, "hpt space");
 			loop_forever();
 		}
-		htab_data.htab = (HPTE *)__a2v(table);
+		htab_data.htab = abs_to_virt(table);
 
 		/* htab absolute addr + encoded htabsize */
 		_SDR1 = table + __ilog2(pteg_count) - 11;
diff -Nru a/arch/ppc64/mm/init.c b/arch/ppc64/mm/init.c
--- a/arch/ppc64/mm/init.c	Tue Mar 30 07:08:06 2004
+++ b/arch/ppc64/mm/init.c	Tue Mar 30 07:08:06 2004
@@ -60,6 +60,7 @@
 #include <asm/sections.h>
 #include <asm/system.h>
 #include <asm/iommu.h>
+#include <asm/abs_addr.h>
 
 
 struct mmu_context_queue_t mmu_context_queue;
@@ -153,7 +154,7 @@
 		pmdp = pmd_alloc(&ioremap_mm, pgdp, ea);
 		ptep = pte_alloc_kernel(&ioremap_mm, pmdp, ea);
 
-		pa = absolute_to_phys(pa);
+		pa = abs_to_phys(pa);
 		set_pte(ptep, pfn_pte(pa >> PAGE_SHIFT, __pgprot(flags)));
 		spin_unlock(&ioremap_mm.page_table_lock);
 	} else {
@@ -539,7 +540,7 @@
 	 */
 	bootmap_pages = bootmem_bootmap_pages(total_pages);
 
-	start = (unsigned long)__a2p(lmb_alloc(bootmap_pages<<PAGE_SHIFT, PAGE_SIZE));
+	start = abs_to_phys(lmb_alloc(bootmap_pages<<PAGE_SHIFT, PAGE_SIZE));
 	BUG_ON(!start);
 
 	boot_mapsize = init_bootmem(start >> PAGE_SHIFT, total_pages);
diff -Nru a/drivers/net/iseries_veth.c b/drivers/net/iseries_veth.c
--- a/drivers/net/iseries_veth.c	Tue Mar 30 07:08:06 2004
+++ b/drivers/net/iseries_veth.c	Tue Mar 30 07:08:06 2004
@@ -71,6 +71,7 @@
 #include <linux/mm.h>
 #include <linux/ethtool.h>
 #include <asm/iSeries/mf.h>
+#include <asm/iSeries/iSeries_pci.h>
 #include <asm/uaccess.h>
 
 #include <asm/iSeries/HvLpConfig.h>
@@ -137,11 +138,6 @@
 
 static int VethModuleReopen = 1;
 
-static inline u64 veth_dma_addr(void *p)
-{
-	return 0x8000000000000000LL | virt_to_absolute((unsigned long) p);
-}
-
 static inline HvLpEvent_Rc 
 veth_signalevent(struct veth_lpar_connection *cnx, u16 subtype, 
 		 HvLpEvent_AckInd ackind, HvLpEvent_AckType acktype,
@@ -1178,13 +1174,13 @@
 	 * really need to break it into PAGE_SIZE chunks, or can we do
 	 * it just at the granularity of iSeries real->absolute
 	 * mapping? */
-	list[0].addr = veth_dma_addr(p);
+	list[0].addr = ISERIES_HV_ADDR(p);
 	list[0].size = min(length,
 			   PAGE_SIZE - ((unsigned long)p & ~PAGE_MASK));
 
 	done = list[0].size;
 	while (done < length) {
-		list[i].addr = veth_dma_addr(p + done);
+		list[i].addr = ISERIES_HV_ADDR(p + done);
 		list[i].size = min(done, PAGE_SIZE);
 		done += list[i].size;
 		i++;
@@ -1255,8 +1251,8 @@
 					    cnx->dst_inst,
 					    HvLpDma_AddressType_RealAddress,
 					    HvLpDma_AddressType_TceIndex,
-					    veth_dma_addr(&local_list),
-					    veth_dma_addr(&remote_list),
+					    ISERIES_HV_ADDR(&local_list),
+					    ISERIES_HV_ADDR(&remote_list),
 					    length);
 		if (rc != HvLpDma_Rc_Good) {
 			dev_kfree_skb_irq(skb);
diff -Nru a/include/asm-ppc64/abs_addr.h b/include/asm-ppc64/abs_addr.h
--- a/include/asm-ppc64/abs_addr.h	Tue Mar 30 07:08:06 2004
+++ b/include/asm-ppc64/abs_addr.h	Tue Mar 30 07:08:06 2004
@@ -71,26 +71,22 @@
 	return PTRRELOC(_msChunks->abs)[pchunk];
 }
 
-
-static inline unsigned long
-phys_to_absolute(unsigned long pa)
-{
-	return chunk_to_addr(abs_chunk(addr_to_chunk(pa))) + chunk_offset(pa);
-}
+/* A macro so it can take pointers or unsigned long. */
+#define phys_to_abs(pa)						     \
+	({ unsigned long _pa = (unsigned long)(pa);			     \
+	   chunk_to_addr(abs_chunk(addr_to_chunk(_pa))) + chunk_offset(_pa); \
+	})
 
 static inline unsigned long
 physRpn_to_absRpn(unsigned long rpn)
 {
 	unsigned long pa = rpn << PAGE_SHIFT;
-	unsigned long aa = phys_to_absolute(pa);
+	unsigned long aa = phys_to_abs(pa);
 	return (aa >> PAGE_SHIFT);
 }
 
-static inline unsigned long
-absolute_to_phys(unsigned long aa)
-{
-	return lmb_abs_to_phys(aa);
-}
+/* A macro so it can take pointers or unsigned long. */
+#define abs_to_phys(aa) lmb_abs_to_phys((unsigned long)(aa))
 
 #else  /* !CONFIG_MSCHUNKS */
 
@@ -99,23 +95,14 @@
 #define chunk_offset(addr) (0)
 #define abs_chunk(pchunk) (pchunk)
 
-#define phys_to_absolute(pa) (pa)
+#define phys_to_abs(pa) (pa)
 #define physRpn_to_absRpn(rpn) (rpn)
-#define absolute_to_phys(aa) (aa)
+#define abs_to_phys(aa) (aa)
 
 #endif /* !CONFIG_MSCHUNKS */
 
-
-static inline unsigned long
-virt_to_absolute(unsigned long ea)
-{
-	return phys_to_absolute(__pa(ea));
-}
-
-static inline unsigned long
-absolute_to_virt(unsigned long aa)
-{
-	return (unsigned long)__va(absolute_to_phys(aa));
-}
+/* Convenience macros */
+#define virt_to_abs(va) phys_to_abs(__pa(va))
+#define abs_to_virt(aa) __va(abs_to_phys(aa))
 
 #endif /* _ABS_ADDR_H */
diff -Nru a/include/asm-ppc64/iSeries/HvCallEvent.h b/include/asm-ppc64/iSeries/HvCallEvent.h
--- a/include/asm-ppc64/iSeries/HvCallEvent.h	Tue Mar 30 07:08:06 2004
+++ b/include/asm-ppc64/iSeries/HvCallEvent.h	Tue Mar 30 07:08:06 2004
@@ -100,7 +100,7 @@
 {
 	u64 abs_addr;
 
-	abs_addr = virt_to_absolute((unsigned long)eventStackAddr);
+	abs_addr = virt_to_abs(eventStackAddr);
 	HvCall3(HvCallEventSetLpEventStack, queueIndex, abs_addr,
 			eventStackSize);
 	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
@@ -123,7 +123,7 @@
 	printk("HvCallEvent_signalLpEvent: *event = %016lx\n ",
 			(unsigned long)event);
 #endif
-	abs_addr = virt_to_absolute((unsigned long)event);
+	abs_addr = virt_to_abs(event);
 	retVal = (HvLpEvent_Rc)HvCall1(HvCallEventSignalLpEvent, abs_addr);
 	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
 	return retVal;
@@ -164,7 +164,7 @@
 	u64 abs_addr;
 	HvLpEvent_Rc retVal;
 
-	abs_addr = virt_to_absolute((unsigned long)event);
+	abs_addr = virt_to_abs(event);
 	retVal = (HvLpEvent_Rc)HvCall1(HvCallEventAckLpEvent, abs_addr);
 	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
 	return retVal;
@@ -175,7 +175,7 @@
 	u64 abs_addr;
 	HvLpEvent_Rc retVal;
 
-	abs_addr = virt_to_absolute((unsigned long)event);
+	abs_addr = virt_to_abs(event);
 	retVal = (HvLpEvent_Rc)HvCall1(HvCallEventCancelLpEvent, abs_addr);
 	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
 	return retVal;
@@ -286,7 +286,7 @@
 	u64 abs_addr;
 	HvLpDma_Rc retVal;
 
-	abs_addr = virt_to_absolute((unsigned long)local);
+	abs_addr = virt_to_abs(local);
 	retVal = (HvLpDma_Rc)HvCall4(HvCallEventDmaToSp, abs_addr, remote,
 			length, dir);
 	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
diff -Nru a/include/asm-ppc64/iSeries/iSeries_pci.h b/include/asm-ppc64/iSeries/iSeries_pci.h
--- a/include/asm-ppc64/iSeries/iSeries_pci.h	Tue Mar 30 07:08:06 2004
+++ b/include/asm-ppc64/iSeries/iSeries_pci.h	Tue Mar 30 07:08:06 2004
@@ -31,6 +31,7 @@
 /************************************************************************/
 
 #include <asm/iSeries/HvCallPci.h>
+#include <asm/abs_addr.h>
 
 struct pci_dev;				/* For Forward Reference        */
 struct iSeries_Device_Node;
@@ -71,7 +72,7 @@
 /* Converts Virtual Address to Real Address for Hypervisor calls        */
 /************************************************************************/
 
-#define REALADDR(virtaddr)  (0x8000000000000000 | (virt_to_absolute((u64)virtaddr) ))
+#define ISERIES_HV_ADDR(virtaddr)  (0x8000000000000000 | virt_to_abs(virtaddr))
 
 /************************************************************************/
 /* iSeries Device Information                                           */
diff -Nru a/include/asm-ppc64/page.h b/include/asm-ppc64/page.h
--- a/include/asm-ppc64/page.h	Tue Mar 30 07:08:06 2004
+++ b/include/asm-ppc64/page.h	Tue Mar 30 07:08:06 2004
@@ -212,19 +212,6 @@
 
 #define __va(x) ((void *)((unsigned long)(x) + KERNELBASE))
 
-/* Given that physical addresses do not map 1-1 to absolute addresses, we
- * use these macros to better specify exactly what we want to do.
- * The only restriction on their use is that the absolute address
- * macros cannot be used until after the LMB structure has been
- * initialized in prom.c.  -Peter
- */
-#define __v2p(x) ((void *) __pa(x))
-#define __v2a(x) ((void *) phys_to_absolute(__pa(x)))
-#define __p2a(x) ((void *) phys_to_absolute(x))
-#define __p2v(x) ((void *) __va(x))
-#define __a2p(x) ((void *) absolute_to_phys(x))
-#define __a2v(x) ((void *) __va(absolute_to_phys(x)))
-
 #ifdef CONFIG_DISCONTIGMEM
 #define page_to_pfn(page)	discontigmem_page_to_pfn(page)
 #define pfn_to_page(pfn)	discontigmem_pfn_to_page(pfn)
.........................................................................
# vim: syntax=diff

