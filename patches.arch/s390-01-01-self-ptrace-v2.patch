From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject:     kernel (new function): System call notification with self_ptrace
References:  bnc#417299,FATE#304021

Description: This patch adds a new functionality to the ptrace implementation.
             The new function is self-tracing. If self-tracing is switched on
             for a process, it receives a SIGSYS each time it performs a
             system call.

             This functionality can be used to implement debugging within the
             scope of the calling process, which allows easy access to all
             process structures in the process space.

             In order to communicate this new function the ptrace system call
             now recognizes the new requests:
             * PTRACE_SELF_ON - enables the self tracing
             * PTRACE_SELF_OFF - disables the self tracing

Acked-by: John Jolly <jjolly@suse.de>
---

 arch/s390/kernel/ptrace.c     |   18 +++++++++++++++++
 arch/s390/kernel/signal.c     |    5 ++++
 arch/x86/kernel/ptrace.c      |   43 ++++++++++++++++++++++++++++++++++++++++++
 arch/x86/kernel/signal_32.c   |    5 ++++
 arch/x86/kernel/signal_64.c   |    5 ++++
 include/asm-generic/siginfo.h |    6 +++++
 include/linux/ptrace.h        |    5 ++++
 kernel/ptrace.c               |   17 ++++++++++++++++
 8 files changed, 104 insertions(+)

Index: linux-sles11/arch/s390/kernel/ptrace.c
===================================================================
--- linux-sles11.orig/arch/s390/kernel/ptrace.c
+++ linux-sles11/arch/s390/kernel/ptrace.c
@@ -619,6 +619,24 @@ syscall_trace(struct pt_regs *regs, int 
 
 	if (!test_thread_flag(TIF_SYSCALL_TRACE))
 		goto out;
+
+	if ((current->ptrace & PT_SELF)
+	        && (regs->gprs[2] != __NR_ptrace)
+		&& (regs->gprs[2] != __NR_rt_sigreturn)) {
+		if (!entryexit) {
+			struct siginfo info;
+
+			memset(&info, 0, sizeof(struct siginfo));
+			info.si_signo = SIGSYS;
+			info.si_code = SYS_SYSCALL;
+			info.si_errno = regs->gprs[2];
+			info.si_addr = (void *)regs->orig_gpr2;
+			send_sig_info(SIGSYS, &info, current);
+			regs->gprs[2] = -1;
+		}
+		return;
+	}
+
 	if (!(current->ptrace & PT_PTRACED))
 		goto out;
 	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
Index: linux-sles11/arch/s390/kernel/signal.c
===================================================================
--- linux-sles11.orig/arch/s390/kernel/signal.c
+++ linux-sles11/arch/s390/kernel/signal.c
@@ -409,6 +409,11 @@ handle_signal(unsigned long sig, struct 
 		spin_unlock_irq(&current->sighand->siglock);
 	}
 
+	if (current->ptrace & PT_SELF) {
+		clear_thread_flag(TIF_SYSCALL_TRACE);
+		current->ptrace &= ~PT_SELF;
+	}
+
 	return ret;
 }
 
Index: linux-sles11/arch/x86/kernel/ptrace.c
===================================================================
--- linux-sles11.orig/arch/x86/kernel/ptrace.c
+++ linux-sles11/arch/x86/kernel/ptrace.c
@@ -20,6 +20,7 @@
 #include <linux/audit.h>
 #include <linux/seccomp.h>
 #include <linux/signal.h>
+#include <linux/unistd.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -1377,6 +1378,21 @@ void send_sigtrap(struct task_struct *ts
 
 static void syscall_trace(struct pt_regs *regs)
 {
+	if ((current->ptrace & PT_SELF) &&
+	    (regs->orig_ax != __NR_ptrace) &&
+	    (regs->orig_ax != __NR_rt_sigreturn)) {
+		if (!entryexit) {
+			struct siginfo info;
+
+			memset(&info, 0, sizeof(struct siginfo));
+			info.si_signo = SIGSYS;
+			info.si_code = SYS_SYSCALL;
+			info.si_addr = (void *) regs->orig_ax;
+			send_sig_info(SIGSYS, &info, current);
+		}
+		return 1; /* Skip system call, deliver signal. */
+	}
+
 	if (!(current->ptrace & PT_PTRACED))
 		return;
 
@@ -1432,6 +1448,19 @@ asmregparm long syscall_trace_enter(stru
 	if (unlikely(test_thread_flag(TIF_SYSCALL_EMU)))
 		ret = -1L;
 
+	if ((current->ptrace & PT_SELF)
+		&& (regs->orig_rax != __NR_rt_sigreturn)) {
+		struct siginfo info;
+
+		memset(&info, 0, sizeof(struct siginfo));
+		info.si_signo = SIGSYS;
+		info.si_code = SYS_SYSCALL;
+		info.si_addr = (void *) regs->orig_rax;
+		send_sig_info(SIGSYS, &info, current);
+		regs->rax = -1 ;
+		return; /* Skip system call, deliver signal. */
+	}
+
 	if (ret || test_thread_flag(TIF_SYSCALL_TRACE))
 		syscall_trace(regs);
 
@@ -1455,6 +1484,20 @@ asmregparm long syscall_trace_enter(stru
 
 asmregparm void syscall_trace_leave(struct pt_regs *regs)
 {
+	if ((current->ptrace & PT_SELF)
+	        && (regs->orig_rax != __NR_ptrace)
+		&& (regs->orig_rax != __NR_rt_sigreturn)) {
+		struct siginfo info;
+
+		memset(&info, 0, sizeof(struct siginfo));
+		info.si_signo = SIGSYS;
+		info.si_code = SYS_SYSCALL;
+		info.si_addr = (void *) regs->orig_rax;
+		send_sig_info(SIGSYS, &info, current);
+		regs->rax = -1 ;
+		return; /* Skip system call. */
+	}
+
 	if (unlikely(current->audit_context))
 		audit_syscall_exit(AUDITSC_RESULT(regs->ax), regs->ax);
 
Index: linux-sles11/arch/x86/kernel/signal_32.c
===================================================================
--- linux-sles11.orig/arch/x86/kernel/signal_32.c
+++ linux-sles11/arch/x86/kernel/signal_32.c
@@ -94,6 +94,11 @@ sys_sigaction(int sig, const struct old_
 		__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
 	}
 
+	if (current->ptrace & PT_SELF) {
+		clear_thread_flag(TIF_SYSCALL_TRACE);
+		current->ptrace &= ~PT_SELF;
+	}
+
 	return ret;
 }
 
Index: linux-sles11/arch/x86/kernel/signal_64.c
===================================================================
--- linux-sles11.orig/arch/x86/kernel/signal_64.c
+++ linux-sles11/arch/x86/kernel/signal_64.c
@@ -455,6 +455,11 @@ handle_signal(unsigned long sig, siginfo
 		spin_unlock_irq(&current->sighand->siglock);
 	}
 
+	if (current->ptrace & PT_SELF) {
+		clear_thread_flag(TIF_SYSCALL_TRACE);
+		current->ptrace &= ~PT_SELF;
+	}
+
 	return ret;
 }
 
Index: linux-sles11/include/asm-generic/siginfo.h
===================================================================
--- linux-sles11.orig/include/asm-generic/siginfo.h
+++ linux-sles11/include/asm-generic/siginfo.h
@@ -224,6 +224,12 @@ typedef struct siginfo {
 #define NSIGPOLL	6
 
 /*
+ * SIGSYS si_codes
+ */
+ #define SYS_SYSCALL	(__SI_FAULT|1)	/* system call notification */
+ #define NSIGSYS	1
+
+/*
  * sigevent definitions
  * 
  * It seems likely that SIGEV_THREAD will have to be handled from 
Index: linux-sles11/include/linux/ptrace.h
===================================================================
--- linux-sles11.orig/include/linux/ptrace.h
+++ linux-sles11/include/linux/ptrace.h
@@ -27,6 +27,10 @@
 #define PTRACE_GETSIGINFO	0x4202
 #define PTRACE_SETSIGINFO	0x4203
 
+/* PTRACE_SELF options							*/
+#define PTRACE_SELF_ON		0x4281
+#define PTRACE_SELF_OFF		0x4282
+
 /* options set using PTRACE_SETOPTIONS */
 #define PTRACE_O_TRACESYSGOOD	0x00000001
 #define PTRACE_O_TRACEFORK	0x00000002
@@ -67,6 +71,7 @@
 #define PT_TRACE_EXEC	0x00000080
 #define PT_TRACE_VFORK_DONE	0x00000100
 #define PT_TRACE_EXIT	0x00000200
+#define PT_SELF		0x00000400
 
 #define PT_TRACE_MASK	0x000003f4
 
Index: linux-sles11/kernel/ptrace.c
===================================================================
--- linux-sles11.orig/kernel/ptrace.c
+++ linux-sles11/kernel/ptrace.c
@@ -562,6 +562,23 @@ asmlinkage long sys_ptrace(long request,
 		goto out;
 	}
 
+	if (request == PTRACE_SELF_ON) {
+		task_lock(current);
+		set_thread_flag(TIF_SYSCALL_TRACE);
+		current->ptrace |= PT_SELF;
+		task_unlock(current);
+		ret = 0;
+		goto out;
+	}
+	if (request == PTRACE_SELF_OFF) {
+		task_lock(current);
+		clear_thread_flag(TIF_SYSCALL_TRACE);
+		current->ptrace &= ~PT_SELF;
+		task_unlock(current);
+		ret = 0;
+		goto out;
+	}
+
 	child = ptrace_get_task_struct(pid);
 	if (IS_ERR(child)) {
 		ret = PTR_ERR(child);
