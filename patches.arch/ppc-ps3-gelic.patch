ps3-wip/ps3-gelic.patch
ps3-wip/ps3-gelic-2.6.21-version-up.diff
ps3-wip/ps3-gelic-system-bus.patch
ps3-wip/ps3-gelic-fix-ipv6.diff
ps3-wip/ps3-gelic_wireless_base.diff 
ps3-wip/ps3-gelic_wireless_kern16.diff 
ps3-wip/ps3-gelic_wireless_kern21.diff 
ps3-wip/ps3-gelic_wireless_wext.diff
ps3-wip/ps3-gelic-cleanup.diff


---
 drivers/net/Kconfig          |   17 
 drivers/net/Makefile         |    4 
 drivers/net/gelic_net.c      | 1601 +++++++++++++++++++++++++++++++
 drivers/net/gelic_net.h      |  468 +++++++++
 drivers/net/gelic_wireless.c | 2191 +++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 4281 insertions(+)

--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2260,6 +2260,23 @@ config TSI108_ETH
 	     To compile this driver as a module, choose M here: the module
 	     will be called tsi108_eth.
 
+config GELIC_NET
+	tristate "PS3 Gigabit Ethernet driver"
+	depends on PPC_PS3
+	help
+	  This driver supports the Gigabit Ethernet device on the
+	  PS3 game console.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gelic_net.
+
+config GELIC_WIRELESS
+	bool "Gelic net Wireless Extension"
+	depends on GELIC_NET
+	select WIRELESS_EXT
+	help
+	  Wireless Extension support for Gelic Gigabit Ethernet driver
+
 config GIANFAR
 	tristate "Gianfar Ethernet"
 	depends on 85xx || 83xx || PPC_86xx
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -60,6 +60,10 @@ obj-$(CONFIG_TIGON3) += tg3.o
 obj-$(CONFIG_BNX2) += bnx2.o
 spidernet-y += spider_net.o spider_net_ethtool.o
 obj-$(CONFIG_SPIDER_NET) += spidernet.o sungem_phy.o
+obj-$(CONFIG_GELIC_NET) += gelic_net.o
+ifeq ($(CONFIG_GELIC_WIRELESS),y)
+  obj-$(CONFIG_GELIC_NET) += gelic_wireless.o
+endif
 obj-$(CONFIG_TC35815) += tc35815.o
 obj-$(CONFIG_SKGE) += skge.o
 obj-$(CONFIG_SKY2) += sky2.o
--- /dev/null
+++ b/drivers/net/gelic_net.c
@@ -0,0 +1,1601 @@
+/*
+ *  PS3 Platfom gelic network driver.
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corporation
+ *
+ *  this file is based on: spider_net.c
+ *
+ * Network device driver for Cell Processor-Based Blade
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Authors : Utz Bacher <utz.bacher@de.ibm.com>
+ *           Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define DEBUG 1
+#undef GELIC_RING_CHAIN
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/if_vlan.h>
+
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+
+#include <linux/dma-mapping.h>
+#include <net/checksum.h>
+#include <asm/firmware.h>
+#include <asm/ps3.h>
+#include <asm/lv1call.h>
+
+#include "gelic_net.h"
+
+#define GELIC_NET_DRV_NAME "Gelic Network Driver"
+#define GELIC_NET_DRV_VERSION "1.0"
+
+MODULE_AUTHOR("SCE Inc.");
+MODULE_DESCRIPTION("Gelic Network driver");
+MODULE_LICENSE("GPL");
+
+static inline struct device * ctodev(struct gelic_net_card * card)
+{
+	return &card->dev->core;
+}
+static inline unsigned int bus_id(struct gelic_net_card *card)
+{
+	return card->dev->did.bus_id;
+}
+static inline unsigned int dev_id(struct gelic_net_card *card)
+{
+	return card->dev->did.dev_id;
+}
+
+/* set irq_mask */
+static int gelic_net_set_irq_mask(struct gelic_net_card *card, u64 mask)
+{
+	int status;
+
+	status = lv1_net_set_interrupt_mask(bus_id(card), dev_id(card),
+					    mask, 0);
+	if (status)
+		dev_info(ctodev(card),
+			 "lv1_net_set_interrupt_mask failed %d\n", status);
+	return status;
+}
+static inline void gelic_net_rx_irq_on(struct gelic_net_card *card)
+{
+	gelic_net_set_irq_mask(card, card->ghiintmask | GELIC_NET_RXINT);
+}
+static inline void gelic_net_rx_irq_off(struct gelic_net_card *card)
+{
+	gelic_net_set_irq_mask(card, card->ghiintmask & ~GELIC_NET_RXINT);
+}
+/**
+ * gelic_net_get_descr_status -- returns the status of a descriptor
+ * @descr: descriptor to look at
+ *
+ * returns the status as in the dmac_cmd_status field of the descriptor
+ */
+static enum gelic_net_descr_status
+gelic_net_get_descr_status(struct gelic_net_descr *descr)
+{
+	u32 cmd_status;
+
+	cmd_status = descr->dmac_cmd_status;
+	cmd_status >>= GELIC_NET_DESCR_IND_PROC_SHIFT;
+	return cmd_status;
+}
+
+/**
+ * gelic_net_set_descr_status -- sets the status of a descriptor
+ * @descr: descriptor to change
+ * @status: status to set in the descriptor
+ *
+ * changes the status to the specified value. Doesn't change other bits
+ * in the status
+ */
+static void gelic_net_set_descr_status(struct gelic_net_descr *descr,
+				       enum gelic_net_descr_status status)
+{
+	u32 cmd_status;
+
+	/* read the status */
+	cmd_status = descr->dmac_cmd_status;
+	/* clean the upper 4 bits */
+	cmd_status &= GELIC_NET_DESCR_IND_PROC_MASKO;
+	/* add the status to it */
+	cmd_status |= ((u32)status) << GELIC_NET_DESCR_IND_PROC_SHIFT;
+	/* and write it back */
+	descr->dmac_cmd_status = cmd_status;
+	wmb();
+}
+
+/**
+ * gelic_net_free_chain - free descriptor chain
+ * @card: card structure
+ * @descr_in: address of desc
+ */
+static void gelic_net_free_chain(struct gelic_net_card *card,
+				 struct gelic_net_descr *descr_in)
+{
+	struct gelic_net_descr *descr;
+
+	for (descr = descr_in; descr && descr->bus_addr; descr = descr->next) {
+		dma_unmap_single(ctodev(card), descr->bus_addr,
+				 GELIC_NET_DESCR_SIZE, DMA_BIDIRECTIONAL);
+		descr->bus_addr = 0;
+	}
+}
+
+/**
+ * gelic_net_init_chain - links descriptor chain
+ * @card: card structure
+ * @chain: address of chain
+ * @start_descr: address of descriptor array
+ * @no: number of descriptors
+ *
+ * we manage a circular list that mirrors the hardware structure,
+ * except that the hardware uses bus addresses.
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int gelic_net_init_chain(struct gelic_net_card *card,
+				struct gelic_net_descr_chain *chain,
+				struct gelic_net_descr *start_descr, int no)
+{
+	int i;
+	struct gelic_net_descr *descr;
+
+	descr = start_descr;
+	memset(descr, 0, sizeof(*descr) * no);
+
+	/* set up the hardware pointers in each descriptor */
+	for (i = 0; i < no; i++, descr++) {
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+		descr->bus_addr =
+			dma_map_single(ctodev(card), descr,
+				       GELIC_NET_DESCR_SIZE,
+				       DMA_BIDIRECTIONAL);
+
+		if (!descr->bus_addr)
+			goto iommu_error;
+
+		descr->next = descr + 1;
+		descr->prev = descr - 1;
+	}
+	/* make them as ring */
+	(descr - 1)->next = start_descr;
+	start_descr->prev = (descr - 1);
+
+	/* chain bus addr of hw descriptor */
+	descr = start_descr;
+	for (i = 0; i < no; i++, descr++) {
+		descr->next_descr_addr = descr->next->bus_addr;
+	}
+
+	chain->head = start_descr;
+	chain->tail = start_descr;
+
+
+#ifdef GELIC_RING_CHAIN
+	(descr - 1)->next_descr_addr = start_descr->bus_addr;
+#else
+	/* do not chain last hw descriptor */
+	(descr - 1)->next_descr_addr = 0;
+#endif
+	return 0;
+
+iommu_error:
+	for (i--, descr--; 0 <= i; i--, descr--)
+		if (descr->bus_addr)
+			dma_unmap_single(ctodev(card), descr->bus_addr,
+					 GELIC_NET_DESCR_SIZE,
+					 DMA_BIDIRECTIONAL);
+	return -ENOMEM;
+}
+
+/**
+ * gelic_net_prepare_rx_descr - reinitializes a rx descriptor
+ * @card: card structure
+ * @descr: descriptor to re-init
+ *
+ * return 0 on succes, <0 on failure
+ *
+ * allocates a new rx skb, iommu-maps it and attaches it to the descriptor.
+ * Activate the descriptor state-wise
+ */
+static int gelic_net_prepare_rx_descr(struct gelic_net_card *card,
+				      struct gelic_net_descr *descr)
+{
+	int offset;
+	unsigned int bufsize;
+
+	if (gelic_net_get_descr_status(descr) !=  GELIC_NET_DESCR_NOT_IN_USE) {
+		dev_info(ctodev(card), "%s: ERROR status \n", __func__);
+	}
+	/* we need to round up the buffer size to a multiple of 128 */
+	bufsize = (GELIC_NET_MAX_MTU + GELIC_NET_RXBUF_ALIGN - 1) &
+		(~(GELIC_NET_RXBUF_ALIGN - 1));
+
+	/* and we need to have it 128 byte aligned, therefore we allocate a
+	 * bit more */
+	descr->skb = netdev_alloc_skb(card->netdev,
+		bufsize + GELIC_NET_RXBUF_ALIGN - 1);
+	if (!descr->skb) {
+		descr->buf_addr = 0; /* tell DMAC don't touch memory */
+		dev_info(ctodev(card),
+			 "%s:allocate skb failed !!\n", __func__);
+		return -ENOMEM;
+	}
+	descr->buf_size = bufsize;
+	descr->dmac_cmd_status = 0;
+	descr->result_size = 0;
+	descr->valid_size = 0;
+	descr->data_error = 0;
+
+	offset = ((unsigned long)descr->skb->data) &
+		(GELIC_NET_RXBUF_ALIGN - 1);
+	if (offset)
+		skb_reserve(descr->skb, GELIC_NET_RXBUF_ALIGN - offset);
+	/* io-mmu-map the skb */
+	descr->buf_addr = dma_map_single(ctodev(card), descr->skb->data,
+					 GELIC_NET_MAX_MTU,
+					 DMA_BIDIRECTIONAL);
+	wmb();
+	if (!descr->buf_addr) {
+		dev_kfree_skb_any(descr->skb);
+		descr->skb = NULL;
+		dev_info(ctodev(card),
+			 "%s:Could not iommu-map rx buffer\n", __func__);
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+		return -ENOMEM;
+	} else {
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_CARDOWNED);
+		return 0;
+	}
+}
+
+/**
+ * gelic_net_release_rx_chain - free all skb of rx descr
+ * @card: card structure
+ *
+ */
+static void gelic_net_release_rx_chain(struct gelic_net_card *card)
+{
+	struct gelic_net_descr * descr = card->rx_chain.head;
+
+	do {
+		if (descr->skb) {
+			dma_unmap_single(ctodev(card),
+					 descr->buf_addr,
+					 descr->skb->len,
+					 DMA_BIDIRECTIONAL);
+			descr->buf_addr = 0;
+			dev_kfree_skb_any(descr->skb);
+			descr->skb = NULL;
+			descr->dmac_cmd_status = GELIC_NET_DESCR_NOT_IN_USE;
+		}
+		descr = descr->next;
+	} while (descr != card->rx_chain.head);
+}
+
+/**
+ * gelic_net_fill_rx_chain - fills descriptors/skbs in the rx chains
+ * @card: card structure
+ *
+ * fills all descriptors in the rx chain: allocates skbs
+ * and iommu-maps them.
+ * returns 0 on success, <0 on failure
+ */
+static int gelic_net_fill_rx_chain(struct gelic_net_card *card)
+{
+	struct gelic_net_descr *descr = card->rx_chain.head;
+	int ret;
+
+	do {
+		if (!descr->skb)
+			if ((ret = gelic_net_prepare_rx_descr(card, descr)))
+				goto rewind;
+		descr = descr->next;
+	} while (descr != card->rx_chain.head);
+
+	return 0;
+rewind:
+	gelic_net_release_rx_chain(card);
+	return ret;
+}
+
+/**
+ * gelic_net_alloc_rx_skbs - allocates rx skbs in rx descriptor chains
+ * @card: card structure
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int gelic_net_alloc_rx_skbs(struct gelic_net_card *card)
+{
+	struct gelic_net_descr_chain *chain;
+	int ret;
+	chain = &card->rx_chain;
+	ret = gelic_net_fill_rx_chain(card);
+	chain->head = card->rx_top->prev; /* point to the last */
+	return ret;
+}
+
+/**
+ * gelic_net_release_tx_descr - processes a used tx descriptor
+ * @card: card structure
+ * @descr: descriptor to release
+ *
+ * releases a used tx descriptor (unmapping, freeing of skb)
+ */
+static void gelic_net_release_tx_descr(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr)
+{
+	struct sk_buff *skb;
+
+
+	if (descr->data_status & (1 << GELIC_NET_TXDESC_TAIL)) {
+		/* 2nd descriptor */
+		skb = descr->skb;
+		dma_unmap_single(ctodev(card), descr->buf_addr, skb->len,
+				 DMA_BIDIRECTIONAL);
+		dev_kfree_skb_any(skb);
+	} else {
+		dma_unmap_single(ctodev(card), descr->buf_addr,
+				 descr->buf_size, DMA_BIDIRECTIONAL);
+	}
+
+	descr->buf_addr = 0;
+	descr->buf_size = 0;
+	descr->next_descr_addr = 0;
+	descr->result_size = 0;
+	descr->valid_size = 0;
+	descr->data_status = 0;
+	descr->data_error = 0;
+	descr->skb = NULL;
+
+	/* set descr status */
+	descr->dmac_cmd_status = GELIC_NET_DMAC_CMDSTAT_NOT_IN_USE;
+}
+
+/**
+ * gelic_net_release_tx_chain - processes sent tx descriptors
+ * @card: adapter structure
+ * @stop: net_stop sequence
+ *
+ * releases the tx descriptors that gelic has finished with
+ */
+static void gelic_net_release_tx_chain(struct gelic_net_card *card, int stop)
+{
+	struct gelic_net_descr_chain *tx_chain;
+	enum gelic_net_descr_status status;
+	int release = 0;
+
+	for (tx_chain = &card->tx_chain;
+	     tx_chain->head != tx_chain->tail && tx_chain->tail;
+	     tx_chain->tail = tx_chain->tail->next) {
+		status = gelic_net_get_descr_status(tx_chain->tail);
+		switch (status) {
+		case GELIC_NET_DESCR_RESPONSE_ERROR:
+		case GELIC_NET_DESCR_PROTECTION_ERROR:
+		case GELIC_NET_DESCR_FORCE_END:
+			if (printk_ratelimit())
+				dev_info(ctodev(card),
+					 "%s: forcing end of tx descriptor " \
+					 "with status %x\n",
+					 __func__, status);
+			card->netdev_stats.tx_dropped++;
+			break;
+
+		case GELIC_NET_DESCR_COMPLETE:
+			card->netdev_stats.tx_packets++;
+			card->netdev_stats.tx_bytes +=
+				tx_chain->tail->skb->len;
+			break;
+
+		case GELIC_NET_DESCR_CARDOWNED:
+			/* pending tx request */
+		default:
+			/* any other value (== GELIC_NET_DESCR_NOT_IN_USE) */
+			goto out;
+		}
+		gelic_net_release_tx_descr(card, tx_chain->tail);
+		release = 1;
+	}
+out:
+	if (!stop && release && netif_queue_stopped(card->netdev))
+		netif_wake_queue(card->netdev);
+}
+
+/**
+ * gelic_net_set_multi - sets multicast addresses and promisc flags
+ * @netdev: interface device structure
+ *
+ * gelic_net_set_multi configures multicast addresses as needed for the
+ * netdev interface. It also sets up multicast, allmulti and promisc
+ * flags appropriately
+ */
+static void gelic_net_set_multi(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	struct dev_mc_list *mc;
+	unsigned int i;
+	uint8_t *p;
+	u64 addr;
+	int status;
+
+	/* clear all multicast address */
+	status = lv1_net_remove_multicast_address(bus_id(card), dev_id(card),
+						  0, 1);
+	if (status)
+		dev_err(ctodev(card),
+			"lv1_net_remove_multicast_address failed %d\n",
+			status);
+	/* set broadcast address */
+	status = lv1_net_add_multicast_address(bus_id(card), dev_id(card),
+					       GELIC_NET_BROADCAST_ADDR, 0);
+	if (status)
+		dev_err(ctodev(card),
+			"lv1_net_add_multicast_address failed, %d\n",
+			status);
+
+	if (netdev->flags & IFF_ALLMULTI
+		|| netdev->mc_count > GELIC_NET_MC_COUNT_MAX) { /* list max */
+		status = lv1_net_add_multicast_address(bus_id(card), dev_id(card),
+						       0, 1);
+		if (status)
+			dev_err(ctodev(card),
+				"lv1_net_add_multicast_address failed, %d\n",
+				status);
+		return;
+	}
+
+	/* set multicast address */
+	for (mc = netdev->mc_list; mc; mc = mc->next) {
+		addr = 0;
+		p = mc->dmi_addr;
+		for (i = 0; i < ETH_ALEN; i++) {
+			addr <<= 8;
+			addr |= *p++;
+		}
+		status = lv1_net_add_multicast_address(bus_id(card), dev_id(card),
+				addr, 0);
+		if (status)
+			dev_err(ctodev(card),
+				"lv1_net_add_multicast_address failed, %d\n",
+				status);
+	}
+}
+
+/**
+ * gelic_net_enable_rxdmac - enables the receive DMA controller
+ * @card: card structure
+ *
+ * gelic_net_enable_rxdmac enables the DMA controller by setting RX_DMA_EN
+ * in the GDADMACCNTR register
+ */
+static void gelic_net_enable_rxdmac(struct gelic_net_card *card)
+{
+	int status;
+
+	status = lv1_net_start_rx_dma(bus_id(card), dev_id(card),
+				card->rx_chain.tail->bus_addr, 0);
+	if (status)
+		printk("lv1_net_start_rx_dma failed, status=%d\n", status);
+}
+
+/**
+ * gelic_net_disable_rxdmac - disables the receive DMA controller
+ * @card: card structure
+ *
+ * gelic_net_disable_rxdmac terminates processing on the DMA controller by
+ * turing off DMA and issueing a force end
+ */
+static void gelic_net_disable_rxdmac(struct gelic_net_card *card)
+{
+	int status;
+
+	/* this hvc blocks until the DMA in progress really stopped */
+	status = lv1_net_stop_rx_dma(bus_id(card), dev_id(card), 0);
+	if (status)
+		dev_err(ctodev(card),
+			"lv1_net_stop_rx_dma faild, %d\n", status);
+}
+
+/**
+ * gelic_net_disable_txdmac - disables the transmit DMA controller
+ * @card: card structure
+ *
+ * gelic_net_disable_txdmac terminates processing on the DMA controller by
+ * turing off DMA and issueing a force end
+ */
+static void gelic_net_disable_txdmac(struct gelic_net_card *card)
+{
+	int status;
+
+	/* this hvc blocks until the DMA in progress really stopped */
+	status = lv1_net_stop_tx_dma(bus_id(card), dev_id(card), 0);
+	if (status)
+		dev_err(ctodev(card),
+			"lv1_net_stop_tx_dma faild, status=%d\n", status);
+}
+
+/**
+ * gelic_net_stop - called upon ifconfig down
+ * @netdev: interface device structure
+ *
+ * always returns 0
+ */
+static int gelic_net_stop(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+#ifdef CONFIG_GELIC_WIRELESS
+	gelicw_down(netdev);
+#endif
+	netif_poll_disable(netdev);
+	netif_stop_queue(netdev);
+
+	/* turn off DMA, force end */
+	gelic_net_disable_rxdmac(card);
+	gelic_net_disable_txdmac(card);
+
+	gelic_net_set_irq_mask(card, 0);
+
+	/* disconnect event port */
+	free_irq(card->netdev->irq, card->netdev);
+	ps3_sb_event_receive_port_destroy(&card->dev->did,
+		card->dev->interrupt_id, card->netdev->irq);
+	card->netdev->irq = NO_IRQ;
+
+	netif_carrier_off(netdev);
+
+	/* release chains */
+	gelic_net_release_tx_chain(card, 1);
+	gelic_net_release_rx_chain(card);
+
+	gelic_net_free_chain(card, card->tx_top);
+	gelic_net_free_chain(card, card->rx_top);
+
+	return 0;
+}
+
+/**
+ * gelic_net_get_next_tx_descr - returns the next available tx descriptor
+ * @card: device structure to get descriptor from
+ *
+ * returns the address of the next descriptor, or NULL if not available.
+ */
+static struct gelic_net_descr *
+gelic_net_get_next_tx_descr(struct gelic_net_card *card)
+{
+	if (!card->tx_chain.head)
+		return NULL;
+	/*  see if we can two consecutive free descrs */
+	if (card->tx_chain.tail != card->tx_chain.head->next &&
+	    gelic_net_get_descr_status(card->tx_chain.head) ==
+	    GELIC_NET_DESCR_NOT_IN_USE &&
+	    card->tx_chain.tail != card->tx_chain.head->next->next &&
+	    gelic_net_get_descr_status(card->tx_chain.head->next) ==
+	     GELIC_NET_DESCR_NOT_IN_USE )
+		return card->tx_chain.head;
+	else
+		return NULL;
+
+}
+
+/**
+ * gelic_net_set_txdescr_cmdstat - sets the tx descriptor command field
+ * @descr: descriptor structure to fill out
+ * @skb: packet to consider
+ * @middle: middle of frame
+ *
+ * fills out the command and status field of the descriptor structure,
+ * depending on hardware checksum settings. This function assumes a wmb()
+ * has executed before.
+ */
+static void gelic_net_set_txdescr_cmdstat(struct gelic_net_descr *descr,
+					  struct sk_buff *skb, int middle)
+{
+	u32 eofr;
+
+	if (middle)
+		eofr = 0;
+	else
+		eofr = GELIC_NET_DMAC_CMDSTAT_END_FRAME;
+
+	if (skb->ip_summed != CHECKSUM_PARTIAL)
+		descr->dmac_cmd_status = GELIC_NET_DMAC_CMDSTAT_NOCS | eofr;
+	else {
+		/* is packet ip?
+		 * if yes: tcp? udp? */
+		if (skb->protocol == htons(ETH_P_IP)) {
+			if (ip_hdr(skb)->protocol == IPPROTO_TCP)
+				descr->dmac_cmd_status = GELIC_NET_DMAC_CMDSTAT_TCPCS | eofr;
+			else if (ip_hdr(skb)->protocol == IPPROTO_UDP)
+				descr->dmac_cmd_status = GELIC_NET_DMAC_CMDSTAT_UDPCS | eofr;
+			else	/*
+				 * the stack should checksum non-tcp and non-udp
+				 * packets on his own: NETIF_F_IP_CSUM
+				 */
+				descr->dmac_cmd_status = GELIC_NET_DMAC_CMDSTAT_NOCS | eofr;
+		}
+	}
+}
+
+/**
+ * gelic_net_prepare_tx_descr_v - get dma address of skb_data
+ * @card: card structure
+ * @descr: descriptor structure
+ * @skb: packet to use
+ *
+ * returns 0 on success, <0 on failure.
+ *
+ */
+static int gelic_net_prepare_tx_descr_v(struct gelic_net_card *card,
+					struct gelic_net_descr *descr,
+					struct sk_buff *skb)
+{
+	dma_addr_t buf[2];
+	unsigned int vlan_len;
+
+	if (skb->len < GELIC_NET_VLAN_POS)
+		return -EINVAL;
+
+	memcpy(&descr->vlan, skb->data, GELIC_NET_VLAN_POS);
+	if (card->vlan_index != -1) {
+		descr->vlan.h_vlan_proto = htons(ETH_P_8021Q); /* vlan 0x8100*/
+		descr->vlan.h_vlan_TCI = htons(card->vlan_id[card->vlan_index]);
+		vlan_len = GELIC_NET_VLAN_POS + VLAN_HLEN; /* VLAN_HLEN=4 */
+	} else
+		vlan_len = GELIC_NET_VLAN_POS; /* no vlan tag */
+
+	/* first descr */
+	buf[0] = dma_map_single(ctodev(card), &descr->vlan,
+			     vlan_len, DMA_BIDIRECTIONAL);
+
+	if (!buf[0]) {
+		dev_err(ctodev(card),
+			"dma map 1 failed (%p, %i). Dropping packet\n",
+			skb->data, vlan_len);
+		return -ENOMEM;
+	}
+
+	descr->buf_addr = buf[0];
+	descr->buf_size = vlan_len;
+	descr->skb = skb; /* not used */
+	descr->data_status = 0;
+	gelic_net_set_txdescr_cmdstat(descr, skb, 1); /* not the frame end */
+
+	/* second descr */
+	card->tx_chain.head = card->tx_chain.head->next;
+	descr->next_descr_addr = descr->next->bus_addr;
+	descr = descr->next;
+	if (gelic_net_get_descr_status(descr) != GELIC_NET_DESCR_NOT_IN_USE)
+		dev_err(ctodev(card),"descr is not free!\n"); /* XXX will be removed */
+
+	buf[1] = dma_map_single(ctodev(card), skb->data + GELIC_NET_VLAN_POS,
+			     skb->len - GELIC_NET_VLAN_POS,
+			     DMA_BIDIRECTIONAL);
+
+	if (!buf[1]) {
+		dev_err(ctodev(card),
+			"dma map 2 failed (%p, %i). Dropping packet\n",
+			skb->data + GELIC_NET_VLAN_POS,
+			skb->len - GELIC_NET_VLAN_POS);
+		dma_unmap_single(ctodev(card), buf[0], vlan_len,
+				 DMA_BIDIRECTIONAL);
+		return -ENOMEM;
+	}
+
+	descr->buf_addr = buf[1];
+	descr->buf_size = skb->len - GELIC_NET_VLAN_POS;
+	descr->skb = skb;
+	descr->data_status = 0;
+	descr->next_descr_addr= 0; /* terminate hw descr */
+	gelic_net_set_txdescr_cmdstat(descr,skb, 0);
+
+	return 0;
+}
+
+/**
+ * gelic_net_kick_txdma - enables TX DMA processing
+ * @card: card structure
+ * @descr: descriptor address to enable TX processing at
+ *
+ */
+static int gelic_net_kick_txdma(struct gelic_net_card *card,
+				struct gelic_net_descr *descr)
+{
+	int status = -ENXIO;
+	int count = 10;
+
+	if (card->tx_dma_progress)
+		return 0;
+
+	if (gelic_net_get_descr_status(descr) == GELIC_NET_DESCR_CARDOWNED) {
+		card->tx_dma_progress = 1;
+		/* sometimes we need retry here */
+		while (count--) {
+			status = lv1_net_start_tx_dma(bus_id(card),
+						      dev_id(card),
+						      descr->bus_addr, 0);
+			if (!status)
+				break;
+		}
+		if (!count)
+			dev_info(ctodev(card), "lv1_net_start_txdma failed," \
+				"status=%d %#lx\n",
+				 status, card->irq_status);
+	}
+	return status;
+}
+
+/**
+ * gelic_net_xmit - transmits a frame over the device
+ * @skb: packet to send out
+ * @netdev: interface device structure
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int gelic_net_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	struct gelic_net_descr *descr = NULL;
+	int result;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->tx_dma_lock, flags);
+
+	gelic_net_release_tx_chain(card, 0);
+	if (!skb)
+		goto kick;
+	descr = gelic_net_get_next_tx_descr(card);
+	if (!descr) {
+		netif_stop_queue(netdev);
+		spin_unlock_irqrestore(&card->tx_dma_lock, flags);
+		return NETDEV_TX_BUSY;
+	}
+	result = gelic_net_prepare_tx_descr_v(card, descr, skb);
+
+	if (result)
+		goto error;
+
+	card->tx_chain.head = card->tx_chain.head->next;
+
+	if (descr->prev)
+		descr->prev->next_descr_addr = descr->bus_addr;
+kick:
+	wmb();
+	if (gelic_net_kick_txdma(card, card->tx_chain.tail))
+		goto error;
+
+	netdev->trans_start = jiffies;
+	spin_unlock_irqrestore(&card->tx_dma_lock, flags);
+	return NETDEV_TX_OK;
+
+error:
+	card->netdev_stats.tx_dropped++;
+	spin_unlock_irqrestore(&card->tx_dma_lock, flags);
+	return NETDEV_TX_LOCKED;
+}
+
+/**
+ * gelic_net_pass_skb_up - takes an skb from a descriptor and passes it on
+ * @descr: descriptor to process
+ * @card: card structure
+ *
+ * iommu-unmaps the skb, fills out skb structure and passes the data to the
+ * stack. The descriptor state is not changed.
+ */
+static void gelic_net_pass_skb_up(struct gelic_net_descr *descr,
+				 struct gelic_net_card *card)
+{
+	struct sk_buff *skb;
+	struct net_device *netdev;
+	u32 data_status, data_error;
+
+	data_status = descr->data_status;
+	data_error = descr->data_error;
+	netdev = card->netdev;
+	/* unmap skb buffer */
+	skb = descr->skb;
+	dma_unmap_single(ctodev(card), descr->buf_addr, GELIC_NET_MAX_MTU,
+			 DMA_BIDIRECTIONAL);
+
+	skb->dev = netdev;
+	skb_put(skb, descr->valid_size? descr->valid_size : descr->result_size);
+	if (!descr->valid_size)
+		dev_info(ctodev(card), "buffer full %x %x %x\n",
+			 descr->result_size, descr->buf_size, descr->dmac_cmd_status);
+
+	descr->skb = NULL;
+	/*
+	 * the card put 2 bytes vlan tag in front
+	 * of the ethernet frame
+	 */
+	skb_pull(skb, 2);
+	skb->protocol = eth_type_trans(skb, netdev);
+
+	/* checksum offload */
+	if (card->rx_csum) {
+		if ((data_status & GELIC_NET_DATA_STATUS_CHK_MASK) &&
+		    (!(data_error & GELIC_NET_DATA_ERROR_CHK_MASK)))
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+		else
+			skb->ip_summed = CHECKSUM_NONE;
+	} else
+		skb->ip_summed = CHECKSUM_NONE;
+
+	/* update netdevice statistics */
+	card->netdev_stats.rx_packets++;
+	card->netdev_stats.rx_bytes += skb->len;
+
+	/* pass skb up to stack */
+	netif_receive_skb(skb);
+}
+
+/**
+ * gelic_net_decode_one_descr - processes an rx descriptor
+ * @card: card structure
+ *
+ * returns 1 if a packet has been sent to the stack, otherwise 0
+ *
+ * processes an rx descriptor by iommu-unmapping the data buffer and passing
+ * the packet up to the stack
+ */
+static int gelic_net_decode_one_descr(struct gelic_net_card *card)
+{
+	enum gelic_net_descr_status status;
+	struct gelic_net_descr_chain *chain = &card->rx_chain;
+	struct gelic_net_descr *descr = chain->tail;
+#ifndef GELIC_RING_CHAIN
+	int dmac_chain_ended;
+#endif
+
+	status = gelic_net_get_descr_status(descr);
+#ifndef GELIC_RING_CHAIN
+	/* is this descriptor terminated with next_descr == NULL? */
+	dmac_chain_ended = descr->dmac_cmd_status & GELIC_NET_DMAC_CMDSTAT_RXDCEIS;
+#endif
+
+	if (status == GELIC_NET_DESCR_CARDOWNED) {
+		return 0;
+	}
+	if (status == GELIC_NET_DESCR_NOT_IN_USE) {
+		dev_dbg(ctodev(card), "dormant descr? %p\n", descr);
+		return 0;
+	}
+
+	if ((status == GELIC_NET_DESCR_RESPONSE_ERROR) ||
+	    (status == GELIC_NET_DESCR_PROTECTION_ERROR) ||
+	    (status == GELIC_NET_DESCR_FORCE_END)) {
+		dev_info(ctodev(card), "dropping RX descriptor with state %x\n",
+			 status);
+		card->netdev_stats.rx_dropped++;
+		goto refill;
+	}
+
+	if ((status != GELIC_NET_DESCR_COMPLETE) &&
+	    (status != GELIC_NET_DESCR_FRAME_END)) {
+		dev_dbg(ctodev(card), "RX descriptor with state %x\n",
+			status);
+		goto refill;
+	}
+
+	/* ok, we've got a packet in descr */
+	gelic_net_pass_skb_up(descr, card); /* 1: skb_up sccess */
+
+refill:
+#ifndef GELIC_RING_CHAIN
+	descr->next_descr_addr = 0; /* unlink the descr */
+#endif
+	/* change the descriptor state: */
+	gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+
+	/* refill one desc
+	 * FIXME: this can fail, but for now, just leave this
+	 * descriptor without skb
+	 */
+	gelic_net_prepare_rx_descr(card, descr);
+	chain->head = descr;
+	chain->tail = descr->next;
+	descr->prev->next_descr_addr = descr->bus_addr;
+
+#ifndef GELIC_RING_CHAIN
+	if (dmac_chain_ended) {
+		gelic_net_enable_rxdmac(card);
+		dev_dbg(ctodev(card), "reenable rx dma\n");
+	}
+#endif
+	return 1;
+}
+
+/**
+ * gelic_net_poll - NAPI poll function called by the stack to return packets
+ * @netdev: interface device structure
+ * @budget: number of packets we can pass to the stack at most
+ *
+ * returns 0 if no more packets available to the driver/stack. Returns 1,
+ * if the quota is exceeded, but the driver has still packets.
+ *
+ */
+static int gelic_net_poll(struct net_device *netdev, int *budget)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	int packets_to_do, packets_done = 0;
+	int no_more_packets = 0;
+
+	packets_to_do = min(*budget, netdev->quota);
+
+	while (packets_to_do) {
+		if (gelic_net_decode_one_descr(card)) {
+			packets_done++;
+			packets_to_do--;
+		} else {
+			/* no more packets for the stack */
+			no_more_packets = 1;
+			break;
+		}
+	}
+	netdev->quota -= packets_done;
+	*budget -= packets_done;
+	if (no_more_packets) {
+		netif_rx_complete(netdev);
+		gelic_net_rx_irq_on(card);
+		return 0;
+	} else
+		return 1;
+}
+
+/**
+ * gelic_net_get_stats - get interface statistics
+ * @netdev: interface device structure
+ *
+ * returns the interface statistics residing in the gelic_net_card struct
+ */
+static struct net_device_stats * gelic_net_get_stats(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	return &card->netdev_stats;
+}
+
+/**
+ * gelic_net_change_mtu - changes the MTU of an interface
+ * @netdev: interface device structure
+ * @new_mtu: new MTU value
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int gelic_net_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	/* no need to re-alloc skbs or so -- the max mtu is about 2.3k
+	 * and mtu is outbound only anyway */
+	if ((new_mtu < GELIC_NET_MIN_MTU) ||
+	    (new_mtu > GELIC_NET_MAX_MTU)) {
+		return -EINVAL;
+	}
+	netdev->mtu = new_mtu;
+	return 0;
+}
+
+/**
+ * gelic_net_interrupt - event handler for gelic_net
+ */
+static irqreturn_t gelic_net_interrupt(int irq, void *ptr)
+{
+	unsigned long flags;
+	struct net_device *netdev = ptr;
+	struct gelic_net_card *card = netdev_priv(netdev);
+	u64 status;
+
+	status = card->irq_status;
+
+	if (!status)
+		return IRQ_NONE;
+
+	if (status & GELIC_NET_RXINT) {
+		gelic_net_rx_irq_off(card);
+		netif_rx_schedule(netdev);
+	}
+
+	if (status & GELIC_NET_TXINT) {
+		spin_lock_irqsave(&card->tx_dma_lock, flags);
+		card->tx_dma_progress = 0;
+		spin_unlock_irqrestore(&card->tx_dma_lock, flags);
+		/* start pending DMA */
+		gelic_net_xmit(NULL, netdev);
+	}
+#ifdef CONFIG_GELIC_WIRELESS
+	gelicw_interrupt(netdev, status);
+#endif
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/**
+ * gelic_net_poll_controller - artificial interrupt for netconsole etc.
+ * @netdev: interface device structure
+ *
+ * see Documentation/networking/netconsole.txt
+ */
+static void gelic_net_poll_controller(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	gelic_net_set_irq_mask(card, 0);
+	gelic_net_interrupt(netdev->irq, netdev);
+	gelic_net_set_irq_mask(card, card->ghiintmask);
+}
+#endif /* CONFIG_NET_POLL_CONTROLLER */
+
+/**
+ * gelic_net_open_device - open device and map dma region
+ * @card: card structure
+ */
+static int gelic_net_open_device(struct gelic_net_card *card)
+{
+	int result;
+
+	result = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+		&card->dev->did, card->dev->interrupt_id, &card->netdev->irq);
+
+	if (result) {
+		dev_info(ctodev(card),
+			 "%s:%d: gelic_net_open_device failed (%d)\n",
+			 __func__, __LINE__, result);
+		result = -EPERM;
+		goto fail_alloc_irq;
+	}
+
+	result = request_irq(card->netdev->irq, gelic_net_interrupt, IRQF_DISABLED,
+		"gelic network", card->netdev);
+
+	if (result) {
+		dev_info(ctodev(card), "%s:%d: request_irq failed (%d)\n",
+			__func__, __LINE__, result);
+		goto fail_request_irq;
+	}
+
+	return 0;
+
+fail_request_irq:
+	ps3_sb_event_receive_port_destroy(&card->dev->did,
+		card->dev->interrupt_id, card->netdev->irq);
+	card->netdev->irq = NO_IRQ;
+fail_alloc_irq:
+	return result;
+}
+
+
+/**
+ * gelic_net_open - called upon ifonfig up
+ * @netdev: interface device structure
+ *
+ * returns 0 on success, <0 on failure
+ *
+ * gelic_net_open allocates all the descriptors and memory needed for
+ * operation, sets up multicast list and enables interrupts
+ */
+static int gelic_net_open(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	dev_dbg(ctodev(card), " -> %s:%d\n", __func__, __LINE__);
+
+	gelic_net_open_device(card);
+
+	if (gelic_net_init_chain(card, &card->tx_chain,
+			card->descr, GELIC_NET_TX_DESCRIPTORS))
+		goto alloc_tx_failed;
+	if (gelic_net_init_chain(card, &card->rx_chain,
+				 card->descr + GELIC_NET_RX_DESCRIPTORS,
+				 GELIC_NET_RX_DESCRIPTORS))
+		goto alloc_rx_failed;
+
+	/* head of chain */
+	card->tx_top = card->tx_chain.head;
+	card->rx_top = card->rx_chain.head;
+	dev_dbg(ctodev(card), "descr rx %p, tx %p, size %#lx, num %#x\n",
+		card->rx_top, card->tx_top, sizeof(struct gelic_net_descr),
+		GELIC_NET_RX_DESCRIPTORS);
+	/* allocate rx skbs */
+	if (gelic_net_alloc_rx_skbs(card))
+		goto alloc_skbs_failed;
+
+	card->tx_dma_progress = 0;
+	card->ghiintmask = GELIC_NET_RXINT | GELIC_NET_TXINT;
+#ifdef CONFIG_GELIC_WIRELESS
+	card->ghiintmask |= GELICW_DEVICE_CMD_COMP | GELICW_DEVICE_EVENT_RECV;
+#endif
+	gelic_net_set_irq_mask(card, card->ghiintmask);
+	gelic_net_enable_rxdmac(card);
+
+	netif_start_queue(netdev);
+	netif_carrier_on(netdev);
+	netif_poll_enable(netdev);
+#ifdef CONFIG_GELIC_WIRELESS
+	gelicw_up(netdev);
+#endif
+
+	return 0;
+
+alloc_skbs_failed:
+	gelic_net_free_chain(card, card->rx_top);
+alloc_rx_failed:
+	gelic_net_free_chain(card, card->tx_top);
+alloc_tx_failed:
+	return -ENOMEM;
+}
+
+#ifdef GELIC_NET_ETHTOOL
+static void gelic_net_get_drvinfo (struct net_device *netdev,
+				   struct ethtool_drvinfo *info)
+{
+	strncpy(info->driver, GELIC_NET_DRV_NAME, sizeof(info->driver) - 1);
+	strncpy(info->version, GELIC_NET_DRV_VERSION, sizeof(info->version) - 1);
+}
+
+static int gelic_net_get_settings(struct net_device *netdev,
+				  struct ethtool_cmd *cmd)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	int status;
+	u64 v1, v2;
+	int speed, duplex;
+
+	speed = duplex = -1;
+	status = lv1_net_control(bus_id(card), dev_id(card),
+			GELIC_NET_GET_ETH_PORT_STATUS, GELIC_NET_PORT, 0, 0,
+			&v1, &v2);
+	if (status) {
+		/* link down */
+	} else {
+		if (v1 & GELIC_NET_FULL_DUPLEX) {
+			duplex = DUPLEX_FULL;
+		} else {
+			duplex = DUPLEX_HALF;
+		}
+
+		if (v1 & GELIC_NET_SPEED_10 ) {
+			speed = SPEED_10;
+		} else if (v1 & GELIC_NET_SPEED_100) {
+			speed = SPEED_100;
+		} else if (v1 & GELIC_NET_SPEED_1000) {
+			speed = SPEED_1000;
+		}
+	}
+	cmd->supported = SUPPORTED_TP | SUPPORTED_Autoneg |
+			SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+			SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+			SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full;
+	cmd->advertising = cmd->supported;
+	cmd->speed = speed;
+	cmd->duplex = duplex;
+	cmd->autoneg = AUTONEG_ENABLE; /* always enabled */
+	cmd->port = PORT_TP;
+
+	return 0;
+}
+
+static u32 gelic_net_get_link(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	int status;
+	u64 v1, v2;
+	int link;
+
+	status = lv1_net_control(bus_id(card), dev_id(card),
+			GELIC_NET_GET_ETH_PORT_STATUS, GELIC_NET_PORT, 0, 0,
+			&v1, &v2);
+	if (status)
+		return 0; /* link down */
+
+	if (v1 & GELIC_NET_LINK_UP)
+		link = 1;
+	else
+		link = 0;
+#ifdef CONFIG_GELIC_WIRELESS
+	/* (v1 & GELIC_NET_LINK_UP) is always 0 in wireless mode */
+	if (gelicw_is_associated(netdev)) {
+		link = 1;
+	}
+#endif
+	return link;
+}
+
+static int gelic_net_nway_reset(struct net_device *netdev)
+{
+	if (netif_running(netdev)) {
+		gelic_net_stop(netdev);
+		gelic_net_open(netdev);
+	}
+	return 0;
+}
+
+static u32 gelic_net_get_tx_csum(struct net_device *netdev)
+{
+	return (netdev->features & NETIF_F_IP_CSUM) != 0;
+}
+
+static int gelic_net_set_tx_csum(struct net_device *netdev, u32 data)
+{
+	if (data)
+		netdev->features |= NETIF_F_IP_CSUM;
+	else
+		netdev->features &= ~NETIF_F_IP_CSUM;
+
+	return 0;
+}
+
+static u32 gelic_net_get_rx_csum(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	return card->rx_csum;
+}
+
+static int gelic_net_set_rx_csum(struct net_device *netdev, u32 data)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	card->rx_csum = data;
+	return 0;
+}
+
+static struct ethtool_ops gelic_net_ethtool_ops = {
+	.get_drvinfo	= gelic_net_get_drvinfo,
+	.get_settings	= gelic_net_get_settings,
+	.get_link	= gelic_net_get_link,
+	.nway_reset	= gelic_net_nway_reset,
+	.get_tx_csum	= gelic_net_get_tx_csum,
+	.set_tx_csum	= gelic_net_set_tx_csum,
+	.get_rx_csum	= gelic_net_get_rx_csum,
+	.set_rx_csum	= gelic_net_set_rx_csum,
+};
+#endif
+
+/**
+ * gelic_net_tx_timeout_task - task scheduled by the watchdog timeout
+ * function (to be called not under interrupt status)
+ * @work: work is context of tx timout task
+ *
+ * called as task when tx hangs, resets interface (if interface is up)
+ */
+static void gelic_net_tx_timeout_task(struct work_struct *work)
+{
+	struct gelic_net_card *card =
+		container_of(work, struct gelic_net_card, tx_timeout_task);
+	struct net_device *netdev = card->netdev;
+
+	dev_info(ctodev(card), "%s:Timed out. Restarting... \n", __func__);
+
+	if (!(netdev->flags & IFF_UP))
+		goto out;
+
+	netif_device_detach(netdev);
+	gelic_net_stop(netdev);
+
+	gelic_net_open(netdev);
+	netif_device_attach(netdev);
+
+out:
+	atomic_dec(&card->tx_timeout_task_counter);
+}
+
+/**
+ * gelic_net_tx_timeout - called when the tx timeout watchdog kicks in.
+ * @netdev: interface device structure
+ *
+ * called, if tx hangs. Schedules a task that resets the interface
+ */
+static void gelic_net_tx_timeout(struct net_device *netdev)
+{
+	struct gelic_net_card *card;
+
+	card = netdev_priv(netdev);
+	atomic_inc(&card->tx_timeout_task_counter);
+	if (netdev->flags & IFF_UP)
+		schedule_work(&card->tx_timeout_task);
+	else
+		atomic_dec(&card->tx_timeout_task_counter);
+}
+
+/**
+ * gelic_net_setup_netdev_ops - initialization of net_device operations
+ * @netdev: net_device structure
+ *
+ * fills out function pointers in the net_device structure
+ */
+static void gelic_net_setup_netdev_ops(struct net_device *netdev)
+{
+	netdev->open = &gelic_net_open;
+	netdev->stop = &gelic_net_stop;
+	netdev->hard_start_xmit = &gelic_net_xmit;
+	netdev->get_stats = &gelic_net_get_stats;
+	netdev->set_multicast_list = &gelic_net_set_multi;
+	netdev->change_mtu = &gelic_net_change_mtu;
+	/* tx watchdog */
+	netdev->tx_timeout = &gelic_net_tx_timeout;
+	netdev->watchdog_timeo = GELIC_NET_WATCHDOG_TIMEOUT;
+	/* NAPI */
+	netdev->poll = &gelic_net_poll;
+	netdev->weight = GELIC_NET_NAPI_WEIGHT;
+#ifdef GELIC_NET_ETHTOOL
+	netdev->ethtool_ops = &gelic_net_ethtool_ops;
+#endif
+}
+
+/**
+ * gelic_net_setup_netdev - initialization of net_device
+ * @card: card structure
+ *
+ * Returns 0 on success or <0 on failure
+ *
+ * gelic_net_setup_netdev initializes the net_device structure
+ **/
+static int gelic_net_setup_netdev(struct gelic_net_card *card)
+{
+	struct net_device *netdev = card->netdev;
+	struct sockaddr addr;
+	unsigned int i;
+	int status;
+	u64 v1, v2;
+
+	SET_MODULE_OWNER(netdev);
+	spin_lock_init(&card->tx_dma_lock);
+
+	card->rx_csum = GELIC_NET_RX_CSUM_DEFAULT;
+
+	gelic_net_setup_netdev_ops(netdev);
+
+	netdev->features = NETIF_F_IP_CSUM;
+
+	status = lv1_net_control(bus_id(card), dev_id(card),
+				 GELIC_NET_GET_MAC_ADDRESS,
+				 0, 0, 0, &v1, &v2);
+	if (status || !is_valid_ether_addr((u8*)&v1)) {
+		dev_info(ctodev(card),
+			 "%s:lv1_net_control GET_MAC_ADDR failed %d\n",
+			 __func__,status);
+		return -EINVAL;
+	}
+	v1 <<= 16;
+	memcpy(addr.sa_data, &v1, ETH_ALEN);
+	memcpy(netdev->dev_addr, addr.sa_data, ETH_ALEN);
+	dev_info(ctodev(card), "MAC addr %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 netdev->dev_addr[0], netdev->dev_addr[1],
+		 netdev->dev_addr[2], netdev->dev_addr[3],
+		 netdev->dev_addr[4], netdev->dev_addr[5]);
+
+	card->vlan_index = -1;	/* no vlan */
+	for (i = 0; i < GELIC_NET_VLAN_MAX; i++) {
+		status = lv1_net_control(bus_id(card), dev_id(card),
+					GELIC_NET_GET_VLAN_ID,
+					i + 1, /* index; one based */
+					0, 0, &v1, &v2);
+		if (status == GELIC_NET_VLAN_NO_ENTRY) {
+			dev_dbg(ctodev(card),
+				"GELIC_VLAN_ID no entry:%d, VLAN disabled\n",
+				status);
+			card->vlan_id[i] = 0;
+		} else if (status) {
+			dev_dbg(ctodev(card),
+				"%s:GELIC_NET_VLAN_ID faild, status=%d\n",
+				__func__, status);
+			card->vlan_id[i] = 0;
+		} else {
+			card->vlan_id[i] = (u32)v1;
+			dev_dbg(ctodev(card), "vlan_id:%d, %lx\n", i, v1);
+		}
+	}
+	if (card->vlan_id[GELIC_NET_VLAN_WIRED - 1])
+		card->vlan_index = GELIC_NET_VLAN_WIRED - 1;
+#ifdef CONFIG_GELIC_WIRELESS
+	card->w.card = card;
+	/* init wireless extension */
+	/* No wireless vlan_index:-1 */
+	gelicw_setup_netdev(netdev, card->vlan_index);
+#endif
+	status = register_netdev(netdev);
+	if (status) {
+		dev_err(ctodev(card), "%s:Couldn't register net_device: %d\n",
+			__func__, status);
+		return status;
+	}
+
+	return 0;
+}
+
+/**
+ * gelic_net_alloc_card - allocates net_device and card structure
+ *
+ * returns the card structure or NULL in case of errors
+ *
+ * the card and net_device structures are linked to each other
+ */
+static struct gelic_net_card * gelic_net_alloc_card(void)
+{
+	struct net_device *netdev;
+	struct gelic_net_card *card;
+	size_t alloc_size;
+
+	alloc_size = sizeof (*card) +
+		sizeof (struct gelic_net_descr) * GELIC_NET_RX_DESCRIPTORS +
+		sizeof (struct gelic_net_descr) * GELIC_NET_TX_DESCRIPTORS;
+	/*
+	 * we assume private data is allocated 32 bytes (or more) aligned
+	 * so that gelic_net_descr should be 32 bytes aligned.
+	 * Current alloc_etherdev() does do it because NETDEV_ALIGN
+	 * is 32.
+	 * check this assumption here.
+	 */
+	BUILD_BUG_ON(NETDEV_ALIGN < 32);
+	BUILD_BUG_ON(offsetof(struct gelic_net_card, irq_status) % 8);
+	BUILD_BUG_ON(offsetof(struct gelic_net_card, descr) % 32);
+
+	netdev = alloc_etherdev(alloc_size);
+	if (!netdev)
+		return NULL;
+
+	card = netdev_priv(netdev);
+	card->netdev = netdev;
+	INIT_WORK(&card->tx_timeout_task, gelic_net_tx_timeout_task);
+	init_waitqueue_head(&card->waitq);
+	atomic_set(&card->tx_timeout_task_counter, 0);
+
+	return card;
+}
+
+/**
+ * ps3_gelic_driver_probe - add a device to the control of this driver
+ */
+static int ps3_gelic_driver_probe (struct ps3_system_bus_device *dev)
+{
+	struct gelic_net_card * card;
+	int result;
+
+	card = gelic_net_alloc_card();
+
+	if (!card) {
+		dev_info(&dev->core, "gelic_net_alloc_card failed\n");
+		result = -ENOMEM;
+		goto fail_alloc_card;
+	}
+
+	ps3_system_bus_set_driver_data(dev, card);
+	card->dev = dev;
+
+	result = ps3_open_hv_device(dev);
+
+	if (result) {
+		dev_dbg(&dev->core, "ps3_open_hv_device failed\n");
+		goto fail_open;
+	}
+
+	result = ps3_dma_region_create(dev->d_region);
+
+	if (result) {
+		dev_dbg(&dev->core, "ps3_dma_region_create failed(%d)\n",
+			result);
+		BUG_ON("check region type");
+		goto fail_dma_region;
+	}
+
+	result = lv1_net_set_interrupt_status_indicator(bus_id(card),
+							dev_id(card),
+		ps3_mm_phys_to_lpar(__pa(&card->irq_status)),
+		0);
+
+	if (result) {
+		dev_dbg(&dev->core,
+			"lv1_net_set_interrupt_status_indicator failed: %s\n",
+			ps3_result(result));
+		result = -EIO;
+		goto fail_status_indicator;
+	}
+
+	result = gelic_net_setup_netdev(card);
+
+	if (result) {
+		dev_dbg(&dev->core, "%s:%d: ps3_dma_region_create failed: "
+			"(%d)\n", __func__, __LINE__, result);
+		goto fail_setup_netdev;
+	}
+
+	return 0;
+
+fail_setup_netdev:
+	lv1_net_set_interrupt_status_indicator(bus_id(card),
+					       bus_id(card),
+					       0 , 0);
+fail_status_indicator:
+	ps3_dma_region_free(dev->d_region);
+fail_dma_region:
+	ps3_close_hv_device(dev);
+fail_open:
+	ps3_system_bus_set_driver_data(dev, NULL);
+	free_netdev(card->netdev);
+fail_alloc_card:
+	return result;
+}
+
+/**
+ * ps3_gelic_driver_remove - remove a device from the control of this driver
+ */
+
+static int ps3_gelic_driver_remove (struct ps3_system_bus_device *dev)
+{
+	struct gelic_net_card * card;
+
+	card = ps3_system_bus_get_driver_data(dev);
+
+#ifdef CONFIG_GELIC_WIRELESS
+	gelicw_remove(card->netdev);
+#endif
+	wait_event(card->waitq,
+		   atomic_read(&card->tx_timeout_task_counter) == 0);
+
+	unregister_netdev(card->netdev);
+	free_netdev(card->netdev);
+
+	lv1_net_set_interrupt_status_indicator(bus_id(card), dev_id(card),
+					       0 , 0);
+
+	ps3_system_bus_set_driver_data(dev, NULL);
+
+	ps3_dma_region_free(dev->d_region);
+
+	ps3_close_hv_device(dev);
+
+	return 0;
+}
+
+static struct ps3_system_bus_driver ps3_gelic_driver = {
+	.match_id = PS3_MATCH_ID_GELIC,
+	.probe = ps3_gelic_driver_probe,
+	.remove = ps3_gelic_driver_remove,
+	.shutdown = ps3_gelic_driver_remove,
+	.core = {
+		.name = "ps3_gelic_driver",
+	},
+};
+
+static int __init ps3_gelic_driver_init (void)
+{
+	return firmware_has_feature(FW_FEATURE_PS3_LV1)
+		? ps3_system_bus_driver_register(&ps3_gelic_driver,
+						 PS3_IOBUS_SB)
+		: -ENODEV;
+}
+
+static void __exit ps3_gelic_driver_exit (void)
+{
+	ps3_system_bus_driver_unregister(&ps3_gelic_driver);
+}
+
+module_init (ps3_gelic_driver_init);
+module_exit (ps3_gelic_driver_exit);
+
+
--- /dev/null
+++ b/drivers/net/gelic_net.h
@@ -0,0 +1,468 @@
+/*
+ *  PS3 Platfom gelic network driver.
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corporation.
+ *
+ *  this file is based on: spider_net.h
+ *
+ * Network device driver for Cell Processor-Based Blade
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Authors : Utz Bacher <utz.bacher@de.ibm.com>
+ *           Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _GELIC_NET_H
+#define _GELIC_NET_H
+
+#include <linux/wireless.h>
+#include <net/ieee80211.h>
+
+#define GELIC_NET_DRV_NAME "Gelic Network Driver"
+#define GELIC_NET_DRV_VERSION "1.0"
+
+#define GELIC_NET_ETHTOOL               /* use ethtool */
+
+/* ioctl */
+#define GELIC_NET_GET_MODE              (SIOCDEVPRIVATE + 0)
+#define GELIC_NET_SET_MODE              (SIOCDEVPRIVATE + 1)
+
+/* descriptors */
+#define GELIC_NET_RX_DESCRIPTORS        128 /* num of descriptors */
+#define GELIC_NET_TX_DESCRIPTORS        128 /* num of descriptors */
+
+#define GELIC_NET_MAX_MTU               2308
+#define GELIC_NET_MIN_MTU               64
+#define GELIC_NET_RXBUF_ALIGN           128
+#define GELIC_NET_RX_CSUM_DEFAULT       1 /* hw chksum */
+#define GELIC_NET_WATCHDOG_TIMEOUT      5*HZ
+#define GELIC_NET_NAPI_WEIGHT           (GELIC_NET_RX_DESCRIPTORS)
+#define GELIC_NET_BROADCAST_ADDR        0xffffffffffffL
+#define GELIC_NET_VLAN_POS              (VLAN_ETH_ALEN * 2)
+#define GELIC_NET_VLAN_MAX              4
+#define GELIC_NET_MC_COUNT_MAX          32 /* multicast address list */
+
+enum gelic_net_int0_status {
+	GELIC_NET_GDTDCEINT  = 24,
+	GELIC_NET_GRFANMINT  = 28,
+};
+
+/* GHIINT1STS bits */
+enum gelic_net_int1_status {
+	GELIC_NET_GDADCEINT = 14,
+};
+
+/* interrupt mask */
+#define GELIC_NET_TXINT                   (1L << (GELIC_NET_GDTDCEINT + 32))
+
+#define GELIC_NET_RXINT0                  (1L << (GELIC_NET_GRFANMINT + 32))
+#define GELIC_NET_RXINT1                  (1L << GELIC_NET_GDADCEINT)
+#define GELIC_NET_RXINT                   (GELIC_NET_RXINT0 | GELIC_NET_RXINT1)
+
+ /* RX descriptor data_status bits */
+#define GELIC_NET_RXDMADU		0x80000000 /* destination MAC addr unknown */
+#define GELIC_NET_RXLSTFBF		0x40000000 /* last frame buffer            */
+#define GELIC_NET_RXIPCHK		0x20000000 /* IP checksum performed        */
+#define GELIC_NET_RXTCPCHK		0x10000000 /* TCP/UDP checksup performed   */
+#define GELIC_NET_RXIPSPKT		0x08000000 /* IPsec packet   */
+#define GELIC_NET_RXIPSAHPRT		0x04000000 /* IPsec AH protocol performed */
+#define GELIC_NET_RXIPSESPPRT		0x02000000 /* IPsec ESP protocol performed */
+#define GELIC_NET_RXSESPAH		0x01000000 /* IPsec ESP protocol auth performed */
+#define GELIC_NET_RXWTPKT	        0x00C00000 /*
+						    * wakeup trigger packet
+						    * 01: Magic Packet (TM)
+						    * 10: ARP packet
+						    * 11: Multicast MAC addr
+						    */
+#define GELIC_NET_RXVLNPKT		0x00200000 /* VLAN packet */
+/* bit 20..16 reserved */
+#define GELIC_NET_RXRECNUM		0x0000ff00 /* reception receipt number */
+/* bit 7..0 reserved */
+
+#define GELIC_NET_TXDESC_TAIL		0
+#define GELIC_NET_DATA_STATUS_CHK_MASK	(GELIC_NET_RXIPCHK | GELIC_NET_RXTCPCHK)
+
+/* RX descriptor data_error bits */
+/* bit 31 reserved */
+#define GELIC_NET_RXALNERR		0x40000000 /* alignement error 10/100M */
+#define GELIC_NET_RXOVERERR		0x20000000 /* oversize error */
+#define GELIC_NET_RXRNTERR		0x10000000 /* Runt error */
+#define GELIC_NET_RXIPCHKERR		0x08000000 /* IP checksum  error */
+#define GELIC_NET_RXTCPCHKERR		0x04000000 /* TCP/UDP checksum  error */
+#define GELIC_NET_RXUMCHSP		0x02000000 /* unmatched sp on sp */
+#define GELIC_NET_RXUMCHSPI		0x01000000 /* unmatched SPI on SAD */
+#define GELIC_NET_RXUMCHSAD		0x00800000 /* unmatched SAD */
+#define GELIC_NET_RXIPSAHERR		0x00400000 /* auth error on AH protocol
+						    * processing */
+#define GELIC_NET_RXIPSESPAHERR		0x00200000 /* auth error on ESP protocol
+						    * processing */
+#define GELIC_NET_RXDRPPKT		0x00100000 /* drop packet */
+#define GELIC_NET_RXIPFMTERR		0x00080000 /* IP packet format error */
+/* bit 18 reserved */
+#define GELIC_NET_RXDATAERR		0x00020000 /* IP packet format error */
+#define GELIC_NET_RXCALERR		0x00010000 /* cariier extension length
+						    * error */
+#define GELIC_NET_RXCREXERR		0x00008000 /* carrier extention error */
+#define GELIC_NET_RXMLTCST		0x00004000 /* multicast address frame */
+/* bit 13..0 reserved */
+//#define GELIC_NET_IP		29 /* last frame buffer */
+//#define GELIC_NET_RXIPCHKERR              27
+//#define GELIC_NET_RXTCPCHKERR             26
+//#define GELIC_NET_DATA_ERROR_CHK_MASK     (1 << GELIC_NET_RXIPCHKERR | 1 << GELIC_NET_RXTCPCHKERR)
+
+/* ignore ipsec ans multicast */
+/*#define GELIC_NET_DATA_ERROR_MASK         0xfdefbfff */
+/* ignore unmatched sp on sp, drop_packet, multicast address frame*/
+/*#define GELIC_NET_DATA_ERROR_FLG          0x7def8000*/
+#define GELIC_NET_DATA_ERROR_CHK_MASK	(GELIC_NET_RXIPCHKERR | GELIC_NET_RXTCPCHKERR)
+
+
+/* tx descriptor command and status */
+#define GELIC_NET_DMAC_CMDSTAT_NOCS       0xa0080000 /* middle of frame */
+#define GELIC_NET_DMAC_CMDSTAT_TCPCS      0xa00a0000
+#define GELIC_NET_DMAC_CMDSTAT_UDPCS      0xa00b0000
+#define GELIC_NET_DMAC_CMDSTAT_END_FRAME  0x00040000 /* end of frame */
+
+#define GELIC_NET_DMAC_CMDSTAT_RXDCEIS	  0x00000002 /* descriptor chain end
+						      * interrupt status */
+
+#define GELIC_NET_DMAC_CMDSTAT_CHAIN_END  0x00000002 /* RXDCEIS:DMA stopped */
+
+#define GELIC_NET_DESCR_IND_PROC_SHIFT    28
+#define GELIC_NET_DESCR_IND_PROC_MASKO    0x0fffffff
+
+
+enum gelic_net_descr_status {
+	GELIC_NET_DESCR_COMPLETE            = 0x00, /* used in rx and tx */
+	GELIC_NET_DESCR_RESPONSE_ERROR      = 0x01, /* used in rx and tx */
+	GELIC_NET_DESCR_PROTECTION_ERROR    = 0x02, /* used in rx and tx */
+	GELIC_NET_DESCR_FRAME_END           = 0x04, /* used in rx */
+	GELIC_NET_DESCR_FORCE_END           = 0x05, /* used in rx and tx */
+	GELIC_NET_DESCR_CARDOWNED           = 0x0a, /* used in rx and tx */
+	GELIC_NET_DESCR_NOT_IN_USE                  /* any other value */
+};
+#define GELIC_NET_DMAC_CMDSTAT_NOT_IN_USE 0xb0000000
+
+struct gelicw_bss {
+	u8 bssid[ETH_ALEN];
+	u8 channel;
+	u8 mode;
+	u8 essid_len;
+	u8 essid[IW_ESSID_MAX_SIZE + 1]; /* null terminated for debug msg */
+
+	u16 capability;
+	u16 beacon_interval;
+
+	u8 rates_len;
+	u8 rates[MAX_RATES_LENGTH];
+	u8 rates_ex_len;
+	u8 rates_ex[MAX_RATES_EX_LENGTH];
+	u8 rssi;
+
+	/* scan results have sec_info instead of rsn_ie or wpa_ie */
+	u16 sec_info;
+};
+
+/* max scan list */
+#define MAX_SCAN_BSS			16
+
+struct gelic_wireless {
+	struct gelic_net_card *card;
+	struct completion cmd_done, rssi_done;
+	struct work_struct work_event, work_start_done;
+	struct delayed_work work_rssi, work_scan_all, work_scan_essid;
+	struct delayed_work work_common, work_encode;
+	struct delayed_work work_start, work_stop, work_roam;
+	wait_queue_head_t waitq_cmd, waitq_scan;
+
+	u64 cmd_tag, cmd_id;
+	u8 cmd_send_flg;
+
+	struct iw_public_data wireless_data;
+	u8 *data_buf; /* data buffer for lv1_net_control */
+
+	u8 wireless; /* wireless support */
+	u8 state;
+	u8 scan_all; /* essid scan or all scan */
+	u8 essid_search; /* essid background scan */
+	u8 is_assoc;
+
+	u16 ch_info; /* supoprted channels */
+	u8 wireless_mode; /* 11b/g */
+	u8 channel; /* current ch */
+	u8 iw_mode; /* INFRA or Ad-hoc */
+	u8 rssi;
+	u8 essid_len;
+	u8 essid[IW_ESSID_MAX_SIZE + 1]; /* null terminated for debug msg */
+	u8 nick[IW_ESSID_MAX_SIZE + 1];
+	u8 bssid[ETH_ALEN];
+
+	u8 key_index;
+	u8 key[WEP_KEYS][IW_ENCODING_TOKEN_MAX]; /* 4 * 64byte */
+	u8 key_len[WEP_KEYS];
+	u8 key_alg; /* key algorithm  */
+	u8 auth_mode; /* authenticaton mode */
+
+	u8 bss_index; /* current bss in bss_list */
+	u8 num_bss_list;
+	u8 bss_key_alg; /* key alg of bss */
+	u8 wap_bssid[ETH_ALEN];
+	unsigned long last_scan; /* last scan time */
+	struct gelicw_bss current_bss;
+	struct gelicw_bss bss_list[MAX_SCAN_BSS];
+};
+
+#define GELIC_NET_DESCR_SIZE              32
+struct gelic_net_descr {
+	/* as defined by the hardware */
+	u32 buf_addr;
+	u32 buf_size;
+	u32 next_descr_addr;
+	u32 dmac_cmd_status;
+	u32 result_size;
+	u32 valid_size;	/* all zeroes for tx */
+	u32 data_status;
+	u32 data_error;	/* all zeroes for tx */
+
+	/* used in the driver */
+	struct sk_buff *skb;
+	dma_addr_t bus_addr;
+	struct gelic_net_descr *next;
+	struct gelic_net_descr *prev;
+	struct vlan_ethhdr vlan;
+} __attribute__((aligned(32)));
+
+struct gelic_net_descr_chain {
+	/* we walk from tail to head */
+	struct gelic_net_descr *head;
+	struct gelic_net_descr *tail;
+};
+
+struct gelic_net_card {
+	struct net_device *netdev;
+	/*
+	 * hypervisor requires irq_status should be
+	 * 8 bytes aligned, but u64 member is
+	 * always disposed in that manner
+	 */
+	u64 irq_status;
+	u64 ghiintmask;
+
+	struct ps3_system_bus_device *dev;
+	u32 vlan_id[GELIC_NET_VLAN_MAX];
+	int vlan_index;
+
+	struct gelic_net_descr_chain tx_chain;
+	struct gelic_net_descr_chain rx_chain;
+	spinlock_t chain_lock;
+
+	struct net_device_stats netdev_stats;
+	int rx_csum;
+	spinlock_t tx_dma_lock;
+	int tx_dma_progress;
+
+	struct work_struct tx_timeout_task;
+	atomic_t tx_timeout_task_counter;
+	wait_queue_head_t waitq;
+
+	struct gelic_net_descr *tx_top, *rx_top;
+#ifdef CONFIG_GELIC_WIRELESS
+	struct gelic_wireless w;
+#endif
+	struct gelic_net_descr descr[0];
+};
+
+/* for lv1_net_control */
+#define GELIC_NET_GET_MAC_ADDRESS               0x0000000000000001
+#define GELIC_NET_GET_ETH_PORT_STATUS           0x0000000000000002
+#define GELIC_NET_SET_NEGOTIATION_MODE          0x0000000000000003
+#define GELIC_NET_GET_VLAN_ID                   0x0000000000000004
+
+#define GELIC_NET_LINK_UP                       0x0000000000000001
+#define GELIC_NET_FULL_DUPLEX                   0x0000000000000002
+#define GELIC_NET_AUTO_NEG                      0x0000000000000004
+#define GELIC_NET_SPEED_10                      0x0000000000000010
+#define GELIC_NET_SPEED_100                     0x0000000000000020
+#define GELIC_NET_SPEED_1000                    0x0000000000000040
+
+#define GELIC_NET_VLAN_ALL                      0x0000000000000001
+#define GELIC_NET_VLAN_WIRED                    0x0000000000000002
+#define GELIC_NET_VLAN_WIRELESS                 0x0000000000000003
+#define GELIC_NET_VLAN_PSP                      0x0000000000000004
+#define GELIC_NET_VLAN_PORT0                    0x0000000000000010
+#define GELIC_NET_VLAN_PORT1                    0x0000000000000011
+#define GELIC_NET_VLAN_PORT2                    0x0000000000000012
+#define GELIC_NET_VLAN_DAEMON_CLIENT_BSS        0x0000000000000013
+#define GELIC_NET_VLAN_LIBERO_CLIENT_BSS        0x0000000000000014
+#define GELIC_NET_VLAN_NO_ENTRY                 -6
+
+#define GELIC_NET_PORT                          2 /* for port status */
+
+/* wireless */
+#define GELICW_WIRELESS_NOT_EXIST	0
+#define GELICW_WIRELESS_SUPPORTED	1
+#define GELICW_WIRELESS_ON		2
+#define GELICW_WIRELESS_SHUTDOWN	3
+/* state */
+#define GELICW_STATE_DOWN		0
+#define GELICW_STATE_UP			1
+#define GELICW_STATE_SCANNING		2
+#define GELICW_STATE_SCAN_DONE		3
+#define GELICW_STATE_ASSOCIATED		4
+
+/* cmd_send_flg */
+#define GELICW_CMD_SEND_NONE		0x00
+#define GELICW_CMD_SEND_COMMON		0x01
+#define GELICW_CMD_SEND_ENCODE		0x02
+#define GELICW_CMD_SEND_SCAN		0x04
+#define GELICW_CMD_SEND_ALL		(GELICW_CMD_SEND_COMMON \
+					| GELICW_CMD_SEND_ENCODE \
+					| GELICW_CMD_SEND_SCAN)
+
+#define GELICW_SCAN_INTERVAL		(HZ)
+
+#ifdef DEBUG
+#define CH_INFO_FAIL 0x0600 /* debug */
+#else
+#define CH_INFO_FAIL 0
+#endif
+
+
+/* net_control command */
+#define GELICW_SET_PORT			3 /* control Ether port */
+#define GELICW_GET_INFO			6 /* get supported channels */
+#define GELICW_SET_CMD			9 /* set configuration */
+#define GELICW_GET_RES			10 /* get command response */
+#define GELICW_GET_EVENT		11 /* get event from device */
+/* net_control command data buffer */
+#define GELICW_DATA_BUF_SIZE		0x1000
+
+/* GELICW_SET_CMD params */
+#define GELICW_CMD_START		1
+#define GELICW_CMD_STOP			2
+#define GELICW_CMD_SCAN			3
+#define GELICW_CMD_GET_SCAN		4
+#define GELICW_CMD_SET_CONFIG		5
+#define GELICW_CMD_GET_CONFIG		6
+#define GELICW_CMD_SET_WEP		7
+#define GELICW_CMD_GET_WEP		8
+#define GELICW_CMD_SET_WPA		9
+#define GELICW_CMD_GET_WPA		10
+#define GELICW_CMD_GET_RSSI		11
+
+/* GELICW_SET_PORT params */
+#define GELICW_ETHER_PORT		2
+#define GELICW_PORT_DOWN		0 /* Ether port off */
+#define GELICW_PORT_UP			4 /* Ether port on (auto neg) */
+
+/* interrupt status bit */
+#define GELICW_DEVICE_CMD_COMP		(1UL << 31)
+#define GELICW_DEVICE_EVENT_RECV	(1UL << 30)
+
+/* GELICW_GET_EVENT ID */
+#define GELICW_EVENT_UNKNOWN		0x00
+#define GELICW_EVENT_DEVICE_READY	0x01
+#define GELICW_EVENT_SCAN_COMPLETED	0x02
+#define GELICW_EVENT_DEAUTH		0x04
+#define GELICW_EVENT_BEACON_LOST	0x08
+#define GELICW_EVENT_CONNECTED		0x10
+#define GELICW_EVENT_WPA_CONNECTED	0x20
+#define GELICW_EVENT_WPA_ERROR		0x40
+#define GELICW_EVENT_NO_ENTRY		(-6)
+
+#define MAX_IW_PRIV_SIZE		32
+
+/* structure of data buffer for lv1_net_contol */
+/* wep_config: sec */
+#define GELICW_WEP_SEC_NONE		0
+#define GELICW_WEP_SEC_40BIT		1
+#define GELICW_WEP_SEC_104BIT		2
+struct wep_config {
+	u16 sec;
+	u8  key[4][16];
+} __attribute__ ((packed));
+
+/* wpa_config: sec */
+#define GELICW_WPA_SEC_NONE		0
+#define GELICW_WPA_SEC_TKIP		1
+#define GELICW_WPA_SEC_AES		2
+/* wpa_config: psk_type */
+#define GELICW_PSK_PASSPHRASE		0
+#define GELICW_PSK_64HEX		1
+struct wpa_config {
+	u16 sec;
+	u16 psk_type;
+	u8  psk_material[64]; /* key */
+} __attribute__ ((packed));
+
+/* common_config: bss_type */
+#define GELICW_BSS_INFRA		0
+#define GELICW_BSS_ADHOC		1
+/* common_config: auth_method */
+#define GELICW_AUTH_OPEN		0
+#define GELICW_AUTH_SHARED		1
+/* common_config: op_mode */
+#define GELICW_OP_MODE_11BG		0
+#define GELICW_OP_MODE_11B		1
+#define GELICW_OP_MODE_11G		2
+struct common_config {
+	u16 scan_index; /* index of scan_desc list */
+	u16 bss_type;
+	u16 auth_method;
+	u16 op_mode;
+} __attribute__ ((packed));
+
+/* scan_descriptor: security */
+#define GELICW_SEC_TYPE_NONE		0x0000
+#define GELICW_SEC_TYPE_WEP		0x0100
+#define GELICW_SEC_TYPE_WEP40		0x0101
+#define GELICW_SEC_TYPE_WEP104		0x0102
+#define GELICW_SEC_TYPE_TKIP		0x0201
+#define GELICW_SEC_TYPE_AES		0x0202
+#define GELICW_SEC_TYPE_WEP_MASK	0xFF00
+struct scan_desc {
+	u16 size;
+	u16 rssi;
+	u16 channel;
+	u16 beacon_period;
+	u16 capability;
+	u16 security;
+	u64 bssid;
+	u8  essid[32];
+	u8  rate[16];
+	u8  ext_rate[16];
+	u32 reserved1;
+	u32 reserved2;
+	u32 reserved3;
+	u32 reserved4;
+} __attribute__ ((packed));
+
+/* rssi_descriptor */
+struct rssi_desc {
+	u16 rssi; /* max rssi = 100 */
+} __attribute__ ((packed));
+
+extern unsigned long p_to_lp(long pa);
+extern int gelicw_setup_netdev(struct net_device *netdev, int wi);
+extern void gelicw_up(struct net_device *netdev);
+extern int gelicw_down(struct net_device *netdev);
+extern void gelicw_remove(struct net_device *netdev);
+extern void gelicw_interrupt(struct net_device *netdev, u64 status);
+extern int gelicw_is_associated(struct net_device *netdev);
+
+#endif //_GELIC_NET_H
--- /dev/null
+++ b/drivers/net/gelic_wireless.c
@@ -0,0 +1,2191 @@
+/*
+ * gelic_wireless.c: wireless extension for gelic_net
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/completion.h>
+#include <linux/ctype.h>
+#include <asm/ps3.h>
+#include <asm/lv1call.h>
+
+#include "gelic_net.h"
+
+MODULE_AUTHOR("SCE Inc.");
+MODULE_DESCRIPTION("Gelic Wireless Extension");
+MODULE_LICENSE("GPL");
+
+static struct iw_handler_def gelicw_handler_def;
+
+/*
+ * Data tables
+ */
+static const u32 freq_list[] = {
+	2412, 2417, 2422, 2427, 2432,
+	2437, 2442, 2447, 2452, 2457,
+	2462, 2467, 2472, 2484 };
+
+static const u32 bitrate_list[] = {
+	 1000000,  2000000,  5500000, 11000000, /* 11b */
+	 6000000,  9000000, 12000000, 18000000,
+	24000000, 36000000, 48000000, 54000000
+};
+#define GELICW_NUM_11B_BITRATES 4 /* 802.11b: 1 ~ 11 Mb/s */
+
+static inline struct device * ntodev(struct net_device *netdev)
+{
+	return &((struct gelic_net_card *)netdev_priv(netdev))->dev->core;
+}
+
+static inline struct device * wtodev(struct gelic_wireless *w)
+{
+	return &w->card->dev->core;
+}
+static inline struct gelic_wireless *gelicw_priv(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	return &card->w;
+}
+static inline unsigned int bus_id(struct gelic_wireless *w)
+{
+	return w->card->dev->did.bus_id;
+}
+static inline unsigned int dev_id(struct gelic_wireless *w)
+{
+	return w->card->dev->did.dev_id;
+}
+
+/* control wired or wireless */
+static void gelicw_vlan_mode(struct net_device *netdev, int mode)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	if ((mode < GELIC_NET_VLAN_WIRED)
+		|| (mode > GELIC_NET_VLAN_WIRELESS))
+		return;
+
+	card->vlan_index = mode - 1;
+}
+
+/* wireless_send_event */
+static void notify_assoc_event(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	union iwreq_data wrqu;
+
+	cancel_delayed_work(&w->work_scan_all);
+	cancel_delayed_work(&w->work_scan_essid);
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	if (w->state < GELICW_STATE_ASSOCIATED) {
+		dev_dbg(ntodev(netdev), "notify disassociated\n");
+		w->is_assoc = 0;
+		memset(w->bssid, 0, ETH_ALEN);
+	} else {
+		dev_dbg(ntodev(netdev), "notify associated\n");
+		w->channel = w->current_bss.channel;
+		w->is_assoc = 1;
+		memcpy(w->bssid, w->current_bss.bssid, ETH_ALEN);
+	}
+	memcpy(wrqu.ap_addr.sa_data, w->bssid, ETH_ALEN);
+	wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+/* association/disassociation */
+static void gelicw_assoc(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (w->state == GELICW_STATE_ASSOCIATED)
+		return;
+	schedule_delayed_work(&w->work_start, 0);
+}
+
+static int gelicw_disassoc(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	memset(w->bssid, 0, ETH_ALEN); /* clear current bssid */
+	if (w->state < GELICW_STATE_ASSOCIATED)
+		return 0;
+
+	schedule_delayed_work(&w->work_stop, 0);
+	w->state = GELICW_STATE_SCAN_DONE;
+	/* notify disassociation */
+	notify_assoc_event(netdev);
+
+	return 0;
+}
+
+static void gelicw_reassoc(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (w->cmd_send_flg != GELICW_CMD_SEND_ALL)
+		return;
+
+	if (!gelicw_disassoc(netdev))
+		gelicw_assoc(netdev);
+}
+
+
+/*
+ * lv1_net_control command
+ */
+/* control Ether port */
+static int gelicw_cmd_set_port(struct net_device *netdev, int mode)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 tag, val;
+	int status;
+
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_SET_PORT, GELICW_ETHER_PORT, mode, 0,
+			&tag, &val);
+	if (status)
+		dev_dbg(ntodev(netdev), "GELICW_SET_PORT failed:%d\n", status);
+	return status;
+}
+
+/* check support channels */
+static int gelicw_cmd_get_ch_info(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 ch_info, val;
+	int status;
+
+	if (w->state < GELICW_STATE_UP)
+		return -EIO;
+
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_GET_INFO, 0, 0 , 0,
+			&ch_info, &val);
+	if (status) {
+		dev_dbg(ntodev(netdev), "GELICW_GET_INFO failed:%d\n", status);
+		w->ch_info = CH_INFO_FAIL;
+	} else {
+		dev_dbg(ntodev(netdev), "ch_info:%lx val:%lx\n", ch_info, val);
+		w->ch_info = ch_info >> 48; /* MSB 16bit shows supported channnels */
+	}
+	return status;
+}
+
+
+/*
+ * lv1_net_control GELICW_SET_CMD command
+ * queued using schedule_work()
+ */
+/* association */
+static void gelicw_cmd_start(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 val;
+	int status;
+
+	if (w->state < GELICW_STATE_SCAN_DONE)
+		return;
+
+	dev_dbg(ntodev(netdev), "GELICW_CMD_START\n");
+	w->cmd_id = GELICW_CMD_START;
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_SET_CMD, w->cmd_id, 0, 0,
+			&w->cmd_tag, &val);
+	if (status) {
+		w->cmd_tag = 0;
+		dev_dbg(ntodev(netdev), "GELICW_CMD_START failed:%d\n", status);
+	}
+}
+
+/* association done */
+static void gelicw_cmd_start_done(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 res, val;
+	int status;
+
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_GET_RES, w->cmd_tag, 0, 0,
+			&res, &val);
+	w->cmd_tag = 0;
+	wake_up_interruptible(&w->waitq_cmd);
+
+	if (status || res)
+		dev_dbg(ntodev(netdev), "GELICW_CMD_START res:%d,%ld\n", status, res);
+}
+
+/* disassociation */
+static void gelicw_cmd_stop(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 res, val;
+	int status;
+
+	if (w->state < GELICW_STATE_SCAN_DONE)
+		return;
+
+	dev_dbg(ntodev(netdev), "GELICW_CMD_STOP\n");
+	init_completion(&w->cmd_done);
+	w->cmd_id = GELICW_CMD_STOP;
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_SET_CMD, w->cmd_id, 0, 0,
+			&w->cmd_tag, &val);
+	if (status) {
+		w->cmd_tag = 0;
+		dev_dbg(ntodev(netdev), "GELICW_CMD_STOP failed:%d\n", status);
+		return;
+	}
+	wait_for_completion_interruptible(&w->cmd_done);
+
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_GET_RES, w->cmd_tag, 0, 0,
+			&res, &val);
+	w->cmd_tag = 0;
+	if (status || res) {
+		dev_dbg(ntodev(netdev), "GELICW_CMD_STOP res:%d,%ld\n", status, res);
+		return;
+	}
+}
+
+/* get rssi */
+static void gelicw_cmd_rssi(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 lpar, res, val;
+	int status;
+	struct rssi_desc *rssi;
+
+	if (w->state < GELICW_STATE_ASSOCIATED) {
+		w->rssi = 0;
+		complete(&w->rssi_done);
+		return;
+	}
+
+	lpar = ps3_mm_phys_to_lpar(__pa(w->data_buf));
+	init_completion(&w->cmd_done);
+	w->cmd_id = GELICW_CMD_GET_RSSI;
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_SET_CMD, w->cmd_id, 0, 0,
+			&w->cmd_tag, &val);
+	if (status) {
+		w->cmd_tag = 0;
+		w->rssi = 0;
+		dev_dbg(ntodev(netdev), "GELICW_CMD_GET_RSSI failed:%d\n", status);
+	} else {
+		wait_for_completion_interruptible(&w->cmd_done);
+		status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_GET_RES, w->cmd_tag, lpar, sizeof(*rssi),
+				&res, &val);
+		w->cmd_tag = 0;
+		if (status || res) {
+			w->rssi = 0;
+			dev_dbg(ntodev(netdev), "GELICW_CMD_GET_RSSI res:%d,%ld\n", status, res);
+		}
+		rssi = (struct rssi_desc *)w->data_buf;
+		w->rssi = rssi->rssi;
+		dev_dbg(ntodev(netdev), "GELICW_CMD_GET_RSSI:%d\n", rssi->rssi);
+	}
+
+	complete(&w->rssi_done);
+}
+
+/* set common configuration */
+static int gelicw_cmd_common(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 lpar, res, val;
+	int status;
+	struct common_config *config;
+
+	if (w->state < GELICW_STATE_SCAN_DONE)
+		return -EIO;
+
+	lpar = ps3_mm_phys_to_lpar(__pa(w->data_buf));
+	config = (struct common_config *)w->data_buf;
+	config->scan_index = w->bss_index;
+	config->bss_type = (w->iw_mode == IW_MODE_ADHOC) ? \
+				GELICW_BSS_ADHOC : GELICW_BSS_INFRA;
+	config->auth_method = (w->auth_mode == IW_AUTH_ALG_SHARED_KEY) ? \
+				GELICW_AUTH_SHARED : GELICW_AUTH_OPEN;
+	switch (w->wireless_mode) {
+	case IEEE_B:
+		config->op_mode = GELICW_OP_MODE_11B;
+		break;
+	case IEEE_G:
+		config->op_mode = GELICW_OP_MODE_11G;
+		break;
+	case IEEE_B | IEEE_G:
+	default:
+		/* default 11bg mode */
+		config->op_mode = GELICW_OP_MODE_11BG;
+		break;
+	}
+
+	dev_dbg(ntodev(netdev), "GELICW_CMD_SET_CONFIG: index:%d type:%d auth:%d mode:%d\n",\
+		config->scan_index, config->bss_type,\
+		config->auth_method,config->op_mode);
+	init_completion(&w->cmd_done);
+	w->cmd_id = GELICW_CMD_SET_CONFIG;
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_SET_CMD, w->cmd_id,
+			lpar, sizeof(struct common_config),
+			&w->cmd_tag, &val);
+	if (status) {
+		w->cmd_tag = 0;
+		dev_dbg(ntodev(netdev), "GELICW_CMD_SET_CONFIG failed:%d\n", status);
+		return status;
+	}
+	wait_for_completion_interruptible(&w->cmd_done);
+
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_GET_RES, w->cmd_tag, 0, 0,
+			&res, &val);
+	w->cmd_tag = 0;
+	if (status || res) {
+		dev_dbg(ntodev(netdev), "GELICW_CMD_SET_CONFIG res:%d,%ld\n", status, res);
+		return -EFAULT;
+	}
+
+	w->cmd_send_flg |= GELICW_CMD_SEND_COMMON;
+
+	return 0;
+}
+
+#define h2i(c)    (isdigit(c) ? c - '0' : toupper(c) - 'A' + 10)
+/* send WEP/WPA configuration */
+static int gelicw_cmd_encode(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 res, val, lpar;
+	int status;
+	struct wep_config *config;
+	struct wpa_config *wpa_config;
+
+	u8 *key, key_len;
+
+	if (w->state < GELICW_STATE_SCAN_DONE)
+		return -EIO;
+
+	lpar = ps3_mm_phys_to_lpar(__pa(w->data_buf));
+
+	if (w->key_alg == IW_ENCODE_ALG_WEP
+		|| w->key_alg == IW_ENCODE_ALG_NONE) {
+		/* WEP */
+		config = (struct wep_config *)w->data_buf;
+		memset(config, 0, sizeof(struct wep_config));
+
+		/* check key len */
+		key_len = w->key_len[w->key_index];
+		key = w->key[w->key_index];
+		if (w->key_alg == IW_ENCODE_ALG_NONE)
+			config->sec = GELICW_WEP_SEC_NONE;
+		else
+			config->sec = (key_len == 5) ? GELICW_WEP_SEC_40BIT :
+							GELICW_WEP_SEC_104BIT;
+		/* copy key */
+		memcpy(config->key[w->key_index], key, key_len);
+
+		/* send wep config */
+		dev_dbg(ntodev(netdev), "GELICW_CMD_SET_WEP\n");
+		init_completion(&w->cmd_done);
+		w->cmd_id = GELICW_CMD_SET_WEP;
+		status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_SET_CMD, w->cmd_id,
+			lpar, sizeof(struct wep_config),
+			&w->cmd_tag, &val);
+		if (status) {
+			w->cmd_tag = 0;
+			dev_dbg(ntodev(netdev), "GELICW_CMD_SET_WEP failed:%d\n", status);
+			goto err;
+		}
+		wait_for_completion_interruptible(&w->cmd_done);
+
+		status = lv1_net_control(bus_id(w), dev_id(w),
+				GELICW_GET_RES, w->cmd_tag, 0, 0,
+				&res, &val);
+		w->cmd_tag = 0;
+		if (status || res) {
+			dev_dbg(ntodev(netdev), "GELICW_CMD_SET_WEP res:%d,%ld\n", status, res);
+			status = -EFAULT;
+			goto err;
+		}
+	} else {
+		/* WPA */
+		wpa_config = (struct wpa_config *)w->data_buf;
+		memset(wpa_config, 0, sizeof(struct wpa_config));
+
+		switch (w->key_alg) {
+		case IW_ENCODE_ALG_TKIP:
+			wpa_config->sec = GELICW_WPA_SEC_TKIP;
+			break;
+		default:
+		case IW_ENCODE_ALG_CCMP:
+			wpa_config->sec = GELICW_WPA_SEC_AES;
+			break;
+		}
+		/* check key len */
+		key = w->key[w->key_index];
+		key_len = w->key_len[w->key_index];
+
+		if (key_len > 64) key_len = 64;
+		if (key_len != 64) {
+			/* if key_len isn't 64byte ,it should be passphrase */
+			/* pass phrase */
+			memcpy(wpa_config->psk_material, key, key_len);
+			wpa_config->psk_type = GELICW_PSK_PASSPHRASE;
+		} else {
+			int i;
+			/* 64 hex */
+			for (i = 0; i < 32; i++)
+				wpa_config->psk_material[i] =
+						h2i(key[ 2 * i]) * 16
+						+ h2i(key[2 * i + 1]);
+			wpa_config->psk_type = GELICW_PSK_64HEX;
+		}
+
+		/* send wpa config */
+		dev_dbg(ntodev(netdev), "GELICW_CMD_SET_WPA:type:%d\n", wpa_config->psk_type);
+		init_completion(&w->cmd_done);
+		w->cmd_id = GELICW_CMD_SET_WPA;
+		status = lv1_net_control(bus_id(w), dev_id(w),
+				GELICW_SET_CMD, w->cmd_id,
+				lpar, sizeof(struct wpa_config),
+				&w->cmd_tag, &val);
+		if (status) {
+			w->cmd_tag = 0;
+			dev_dbg(ntodev(netdev), "GELICW_CMD_SET_WPA failed:%d\n", status);
+			goto err;
+		}
+		wait_for_completion_interruptible(&w->cmd_done);
+
+		status = lv1_net_control(bus_id(w), dev_id(w),
+				GELICW_GET_RES, w->cmd_tag, 0, 0, &res, &val);
+		w->cmd_tag = 0;
+		if (status || res) {
+			dev_dbg(ntodev(netdev), "GELICW_CMD_SET_WPA res:%d,%ld\n", status, res);
+			status = -EFAULT;
+			goto err;
+		}
+	}
+
+	w->cmd_send_flg |= GELICW_CMD_SEND_ENCODE;
+	/* (re)associate */
+	gelicw_reassoc(netdev);
+
+	return 0;
+err:
+	gelicw_disassoc(netdev);
+	return status;
+}
+
+static int gelicw_is_ap_11b(struct gelicw_bss *list)
+{
+	if (list->rates_len + list->rates_ex_len == GELICW_NUM_11B_BITRATES)
+		return 1;
+	else
+		return 0;
+}
+
+/* get scan results */
+static int gelicw_cmd_get_scan(struct gelic_wireless *w)
+{
+	u64 lpar, res, val;
+	int status;
+	struct scan_desc *desc;
+	int i, j;
+	u8 *p;
+	struct gelicw_bss *bss;
+
+	lpar = ps3_mm_phys_to_lpar(__pa(w->data_buf));
+
+	/* get scan */
+	dev_dbg(wtodev(w), "GELICW_CMD_GET_SCAN\n");
+	init_completion(&w->cmd_done);
+	w->cmd_id = GELICW_CMD_GET_SCAN;
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_SET_CMD, w->cmd_id, 0, 0,
+			&w->cmd_tag, &val);
+	if (status) {
+		w->cmd_tag = 0;
+		dev_dbg(wtodev(w), "GELICW_CMD_GET_SCAN failed:%d\n", status);
+		return status;
+	}
+	wait_for_completion_interruptible(&w->cmd_done);
+
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_GET_RES, w->cmd_tag, lpar, GELICW_DATA_BUF_SIZE,
+			&res, &val);
+	w->cmd_tag = 0;
+	if (status || res) {
+		dev_dbg(wtodev(w), "GELICW_CMD_GET_SCAN res:%d,%ld\n", status, res);
+		return -EFAULT;
+	}
+
+	desc = (struct scan_desc *)w->data_buf;
+	for (i = 0; i < val/ sizeof(struct scan_desc) ; i++) {
+		bss = &w->bss_list[i];
+		bss->rates_len = 0;
+		for (j = 0; j < MAX_RATES_LENGTH; j++)
+			if (desc[i].rate[j])
+				bss->rates[bss->rates_len++] = desc[i].rate[j];
+		bss->rates_ex_len = 0;
+		for (j = 0; j < MAX_RATES_EX_LENGTH; j++)
+			if (desc[i].ext_rate[j])
+				bss->rates_ex[bss->rates_ex_len++]
+						= desc[i].ext_rate[j];
+
+		if (desc[i].capability & 0x3) {
+			if (desc[i].capability & 0x1)
+				bss->mode = IW_MODE_INFRA;
+			else
+				bss->mode = IW_MODE_ADHOC;
+		}
+		bss->channel = desc[i].channel;
+		bss->essid_len = strnlen(desc[i].essid, IW_ESSID_MAX_SIZE);
+		bss->rssi = (u8)desc[i].rssi;
+		bss->capability = desc[i].capability;
+		bss->beacon_interval = desc[i].beacon_period;
+		memcpy(bss->essid, desc[i].essid, bss->essid_len);
+		p = (u8 *)&desc[i].bssid;
+		memcpy(bss->bssid, &p[2], ETH_ALEN);/* bssid:64bit in desc */
+		bss->sec_info = desc[i].security;
+	}
+	w->num_bss_list = i;
+
+	if (!i)
+		return -1; /* no ap found */
+	else
+		return 0; /* ap found */
+}
+
+/* search bssid in bss list */
+static int gelicw_search_bss_list(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	static const u8 off[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	int i;
+	int check_bss = 0, check_11g = 0, found_bss, found_11g;
+
+	if (!w->num_bss_list)
+		return -1;	/* no bss list */
+
+	if (memcmp(off, w->wap_bssid, ETH_ALEN))
+		check_bss = 1;
+
+	/* wireless op_mode seems not working with CMD_SET_CONFIG */
+	if (w->wireless_mode == IEEE_G)
+		check_11g = 1;
+
+	if (!check_bss && !check_11g)
+		return 0;	/* no check bssid, wmode */
+
+	for (i = 0; i < w->num_bss_list; i++) {
+		found_bss = found_11g = 1;
+		if (check_bss &&
+		    memcmp(w->bss_list[i].bssid, w->wap_bssid, ETH_ALEN))
+			found_bss = 0; /* not found */
+
+		if (check_11g &&
+		    gelicw_is_ap_11b(&w->bss_list[i]))
+			found_11g = 0; /* not found */
+
+		if (found_bss && found_11g)
+			break;
+	}
+
+	if (i == w->num_bss_list)
+		return -1; /* not found */
+	else
+		return i;
+}
+
+/* scan done */
+static void gelicw_scan_complete(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	int res;
+	int bss_index;
+
+	/* get scan results */
+	res = gelicw_cmd_get_scan(w);
+	if (w->is_assoc)
+		w->state = GELICW_STATE_ASSOCIATED;
+	else
+		w->state = GELICW_STATE_SCAN_DONE;
+
+	if (res) {
+		/* No AP found */
+		if (!w->scan_all) {
+			/* no specified AP */
+			gelicw_disassoc(netdev);
+			/* rescan */
+			if (w->essid_search && w->essid_len)
+				schedule_delayed_work(&w->work_scan_essid,
+							GELICW_SCAN_INTERVAL);
+			return;
+		}
+	}
+
+	if (w->scan_all) {
+		/* all params should be set again after scan */
+		w->cmd_send_flg = 0;
+		return;
+	}
+
+	bss_index = gelicw_search_bss_list(netdev);
+	if (bss_index < 0) {
+		/* no wap_bssid in bss_list */
+		if (w->essid_search && w->essid_len)
+			schedule_delayed_work(&w->work_scan_essid,
+						GELICW_SCAN_INTERVAL);
+		return;
+	}
+	w->bss_index = (u8)bss_index;
+	w->current_bss = w->bss_list[w->bss_index];
+
+	/* essid search complete */
+	w->essid_search = 0;
+	w->cmd_send_flg |= GELICW_CMD_SEND_SCAN;
+
+	/* (re)connect to AP */
+	if (w->is_assoc) {
+		/* notify disassociation */
+		w->state = GELICW_STATE_SCAN_DONE;
+		notify_assoc_event(netdev);
+	}
+	schedule_delayed_work(&w->work_common, 0);
+	schedule_delayed_work(&w->work_encode, 0);
+}
+
+/* start scan */
+static int gelicw_cmd_set_scan(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 res, val, lpar;
+	int status;
+	u8 *p;
+
+	if (w->state < GELICW_STATE_UP) {
+		w->scan_all = 0;
+		return -EIO;
+	}
+	if (!w->scan_all && !w->essid_len)
+		return -EINVAL; /* unsupported essid ANY */
+
+	/* set device wired to wireless when essid is set */
+	if (!w->scan_all && w->wireless < GELICW_WIRELESS_ON) {
+		gelicw_vlan_mode(netdev, GELIC_NET_VLAN_WIRELESS);
+		gelicw_cmd_set_port(netdev, GELICW_PORT_DOWN);
+		w->wireless = GELICW_WIRELESS_ON;
+	}
+
+	p = (u8 *)w->data_buf;
+	lpar = ps3_mm_phys_to_lpar(__pa(w->data_buf));
+
+	/* avoid frequent scanning */
+	if (!w->essid_search /* background scan off */
+	  && w->scan_all
+	  && (jiffies - w->last_scan) < (5 * HZ)) {
+		return 0;
+	}
+
+	w->bss_key_alg = IW_ENCODE_ALG_NONE;
+
+	init_completion(&w->cmd_done);
+	w->state = GELICW_STATE_SCANNING;
+	w->cmd_id = GELICW_CMD_SCAN;
+
+	if (w->scan_all) {
+		/* scan all ch */
+		dev_dbg(ntodev(netdev), "GELICW_CMD_SCAN all\n");
+		w->last_scan = jiffies; /* last scan time */
+		status = lv1_net_control(bus_id(w), dev_id(w),
+				GELICW_SET_CMD, w->cmd_id, 0, 0,
+				&w->cmd_tag, &val);
+	} else {
+		/* scan essid */
+		memset(p, 0, 32);
+		memcpy(p, w->essid, w->essid_len);
+		dev_dbg(ntodev(netdev), "GELICW_CMD_SCAN essid\n");
+		status = lv1_net_control(bus_id(w), dev_id(w),
+				GELICW_SET_CMD, w->cmd_id, lpar, 32,
+				&w->cmd_tag, &val);
+	}
+
+	if (status) {
+		w->cmd_tag = 0;
+		dev_dbg(ntodev(netdev), "GELICW_CMD_SCAN failed:%d\n", status);
+		return status;
+	}
+	wait_for_completion_interruptible(&w->cmd_done);
+
+	status = lv1_net_control(bus_id(w), dev_id(w),
+			GELICW_GET_RES, w->cmd_tag, 0, 0,
+			&res, &val);
+	w->cmd_tag = 0;
+	if (status || res) {
+		dev_dbg(ntodev(netdev), "GELICW_CMD_SCAN res:%d,%ld\n", status, res);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void gelicw_send_common_config(struct net_device *netdev,
+					u8 *cur, u8 mode)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (*cur != mode) {
+		*cur = mode;
+		if (w->state < GELICW_STATE_SCAN_DONE)
+			return;
+
+		if (!(w->cmd_send_flg & GELICW_CMD_SEND_SCAN)
+		    && w->essid_len)
+			/* scan essid and set other params */
+			schedule_delayed_work(&w->work_scan_essid, 0);
+		else {
+			schedule_delayed_work(&w->work_common, 0);
+			if (w->cmd_send_flg
+			    & GELICW_CMD_SEND_ENCODE)
+				/* (re)send encode key */
+				schedule_delayed_work(&w->work_encode, 0);
+		}
+	}
+}
+
+
+/*
+ * work queue
+ */
+static void gelicw_work_rssi(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_rssi.work);
+	struct net_device *netdev = w->card->netdev;
+
+	if (w->cmd_tag) {
+		schedule_delayed_work(&w->work_rssi, HZ / 5);
+		return;
+	}
+
+	gelicw_cmd_rssi(netdev);
+}
+
+static void gelicw_work_scan_all(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_scan_all.work);
+	struct net_device *netdev = w->card->netdev;
+
+	if (w->cmd_tag || w->state == GELICW_STATE_SCANNING) {
+		schedule_delayed_work(&w->work_scan_all, HZ / 5);
+		return;
+	}
+
+	w->scan_all = 1;
+	gelicw_cmd_set_scan(netdev);
+}
+
+static void gelicw_work_scan_essid(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_scan_essid.work);
+	struct net_device *netdev = w->card->netdev;
+
+	if (w->cmd_tag || w->scan_all || w->state == GELICW_STATE_SCANNING) {
+		schedule_delayed_work(&w->work_scan_essid, HZ / 5);
+		return;
+	}
+	w->bss_index = 0;
+	w->scan_all = 0;
+	gelicw_cmd_set_scan(netdev);
+}
+
+static void gelicw_work_common(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_common.work);
+	struct net_device *netdev = w->card->netdev;
+
+	if (w->cmd_tag) {
+		schedule_delayed_work(&w->work_common, HZ / 5);
+		return;
+	}
+	gelicw_cmd_common(netdev);
+}
+
+static void gelicw_work_encode(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_encode.work);
+	struct net_device *netdev = w->card->netdev;
+
+	if (w->cmd_tag) {
+		schedule_delayed_work(&w->work_encode, HZ / 5);
+		return;
+	}
+	gelicw_cmd_encode(netdev);
+}
+
+static void gelicw_work_start(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_start.work);
+	struct net_device *netdev = w->card->netdev;
+
+	if (w->cmd_tag) {
+		schedule_delayed_work(&w->work_start, HZ / 5);
+		return;
+	}
+	gelicw_cmd_start(netdev);
+}
+
+static void gelicw_work_start_done(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_start_done);
+	struct net_device *netdev = w->card->netdev;
+
+	gelicw_cmd_start_done(netdev);
+}
+
+static void gelicw_work_stop(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_stop.work);
+	struct net_device *netdev = w->card->netdev;
+
+	if (w->cmd_tag) {
+		schedule_delayed_work(&w->work_stop, HZ / 5);
+		return;
+	}
+	gelicw_cmd_stop(netdev);
+}
+
+static void gelicw_work_roam(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_roam.work);
+	struct net_device *netdev = w->card->netdev;
+
+	if (w->cmd_tag || w->scan_all || w->state == GELICW_STATE_SCANNING) {
+		schedule_delayed_work(&w->work_roam, HZ / 5);
+		return;
+	}
+	gelicw_cmd_stop(netdev);
+	w->bss_index = 0;
+	w->scan_all = 0;
+	gelicw_cmd_set_scan(netdev);
+}
+
+/*
+ * Event handler
+ */
+#define GELICW_EVENT_LOOP_MAX 16
+static void gelicw_event(struct work_struct *work)
+{
+	struct gelic_wireless *w =
+		container_of(work, struct gelic_wireless, work_event);
+	struct net_device *netdev = w->card->netdev;
+	u64 event_type, val;
+	int i, status;
+
+	for (i = 0; i < GELICW_EVENT_LOOP_MAX; i++) {
+		status = lv1_net_control(bus_id(w), dev_id(w),
+				GELICW_GET_EVENT, 0, 0 , 0,
+				&event_type, &val);
+		if (status == GELICW_EVENT_NO_ENTRY) {
+			/* got all events */
+			break;
+		} else if (status){
+			dev_dbg(ntodev(netdev), "GELICW_GET_EVENT failed:%d\n", status);
+			return;
+		}
+		switch(event_type) {
+		case GELICW_EVENT_DEVICE_READY:
+			dev_dbg(ntodev(netdev), "  GELICW_EVENT_DEVICE_READY\n");
+			break;
+		case GELICW_EVENT_SCAN_COMPLETED:
+			dev_dbg(ntodev(netdev), "  GELICW_EVENT_SCAN_COMPLETED\n");
+			gelicw_scan_complete(netdev);
+			break;
+		case GELICW_EVENT_BEACON_LOST:
+			dev_dbg(ntodev(netdev), "  GELICW_EVENT_BEACON_LOST\n");
+			w->state = GELICW_STATE_SCAN_DONE;
+			notify_assoc_event(netdev);
+			/* roaming */
+			w->essid_search = 1;
+			schedule_delayed_work(&w->work_roam, 0);
+			break;
+		case GELICW_EVENT_CONNECTED:
+		{
+			u16 ap_sec;
+			dev_dbg(ntodev(netdev), "  GELICW_EVENT_CONNECTED\n");
+			/* this event ocuured with any key_alg */
+			ap_sec = w->current_bss.sec_info;
+			if (w->key_alg == IW_ENCODE_ALG_NONE) {
+				/* no encryption */
+				if (ap_sec == 0) {
+					w->state = GELICW_STATE_ASSOCIATED;
+					notify_assoc_event(netdev);
+				}
+			} else if (w->key_alg == IW_ENCODE_ALG_WEP){
+				if ((ap_sec & GELICW_SEC_TYPE_WEP_MASK)
+				    == GELICW_SEC_TYPE_WEP) {
+					/* wep */
+					w->state = GELICW_STATE_ASSOCIATED;
+					notify_assoc_event(netdev);
+				}
+			}
+			break;
+		}
+		case GELICW_EVENT_WPA_CONNECTED:
+			dev_dbg(ntodev(netdev), "  GELICW_EVENT_WPA_CONNECTED\n");
+			w->state = GELICW_STATE_ASSOCIATED;
+			notify_assoc_event(netdev);
+			break;
+		case GELICW_EVENT_WPA_ERROR:
+			dev_dbg(ntodev(netdev), "  GELICW_EVENT_WPA_ERROR\n");
+			break;
+		default:
+			dev_dbg(ntodev(netdev), "  GELICW_EVENT_UNKNOWN\n");
+			break;
+		}
+	}
+}
+
+static void gelicw_clear_event(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u64 event_type, val;
+	int i, status;
+
+	for (i = 0; i < GELICW_EVENT_LOOP_MAX; i++) {
+		status = lv1_net_control(bus_id(w), dev_id(w),
+				GELICW_GET_EVENT, 0, 0 , 0,
+				&event_type, &val);
+		if (status) {
+			/* got all events */
+			return;
+		}
+		switch(event_type) {
+		case GELICW_EVENT_SCAN_COMPLETED:
+			w->state = GELICW_STATE_SCAN_DONE;
+			wake_up_interruptible(&w->waitq_scan);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/*
+ * gelic_net support function
+ */
+static void gelicw_clear_params(struct gelic_wireless *w)
+{
+	int i;
+
+	/* clear status */
+	w->state = GELICW_STATE_DOWN;
+	w->cmd_send_flg = 0;
+	w->scan_all = 0;
+	w->is_assoc = 0;
+	w->essid_search = 0;
+	w->cmd_tag = 0;
+	w->cmd_id = 0;
+	w->last_scan = 0;
+
+	/* default mode and settings */
+	w->essid_len = 0;
+	w->essid[0] = '\0';
+	w->nick[0] = '\0';
+	w->iw_mode = IW_MODE_INFRA;
+	w->auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
+	w->wireless_mode = IEEE_B | IEEE_G;
+	w->bss_index = 0;
+	memset(w->bssid, 0, ETH_ALEN);
+	memset(w->wap_bssid, 0, ETH_ALEN);
+
+	/* init key */
+	w->key_index = 0;
+	for (i = 0; i < WEP_KEYS; i++) {
+		w->key[i][0] = '\0';
+		w->key_len[i] = 0;
+	}
+	w->key_alg = IW_ENCODE_ALG_NONE;
+	w->bss_key_alg = IW_ENCODE_ALG_NONE;
+}
+
+int gelicw_setup_netdev(struct net_device *netdev, int wi)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (wi < 0) {
+		/* PS3 low model has no wireless */
+		dev_dbg(ntodev(netdev), "No wireless dvice in this system\n");
+		w->wireless = 0;
+		return 0;
+	}
+	w->data_buf = kmalloc(GELICW_DATA_BUF_SIZE, GFP_KERNEL);
+	if (!w->data_buf) {
+		w->wireless = 0;
+		dev_info(ntodev(netdev), "%s:kmalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+	w->wireless = GELICW_WIRELESS_SUPPORTED; /* wireless support */
+
+	w->ch_info = 0;
+	w->channel = 0;
+	netdev->wireless_data = &w->wireless_data;
+	netdev->wireless_handlers = &gelicw_handler_def;
+	INIT_WORK(&w->work_event, gelicw_event);
+	INIT_WORK(&w->work_start_done, gelicw_work_start_done);
+	INIT_DELAYED_WORK(&w->work_rssi, gelicw_work_rssi);
+	INIT_DELAYED_WORK(&w->work_scan_all, gelicw_work_scan_all);
+	INIT_DELAYED_WORK(&w->work_scan_essid, gelicw_work_scan_essid);
+	INIT_DELAYED_WORK(&w->work_common, gelicw_work_common);
+	INIT_DELAYED_WORK(&w->work_encode, gelicw_work_encode);
+	INIT_DELAYED_WORK(&w->work_start, gelicw_work_start);
+	INIT_DELAYED_WORK(&w->work_stop, gelicw_work_stop);
+	INIT_DELAYED_WORK(&w->work_roam, gelicw_work_roam);
+	init_waitqueue_head(&w->waitq_cmd);
+	init_waitqueue_head(&w->waitq_scan);
+
+	gelicw_clear_params(w);
+
+	return 0;
+}
+
+void gelicw_up(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (!w->wireless)
+		return;
+
+	dev_dbg(ntodev(netdev), "gelicw_up\n");
+	if (w->state < GELICW_STATE_UP)
+		w->state = GELICW_STATE_UP;
+
+	/* start essid scanning */
+	if (w->essid_len)
+		schedule_delayed_work(&w->work_scan_essid, 0);
+}
+
+int gelicw_down(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (!w->wireless || w->state == GELICW_STATE_DOWN)
+		return 0;
+
+	dev_dbg(ntodev(netdev), "gelicw_down\n");
+	w->wireless = GELICW_WIRELESS_SHUTDOWN;
+	flush_scheduled_work();
+
+	/* check cmd_tag of CMD_START */
+	if (w->cmd_id == GELICW_CMD_START) {
+		wait_event_interruptible(w->waitq_cmd, !w->cmd_tag);
+	}
+	/* wait scan done */
+	if (w->state == GELICW_STATE_SCANNING) {
+		wait_event_interruptible(w->waitq_scan,
+					w->state != GELICW_STATE_SCANNING);
+		gelicw_cmd_get_scan(w);
+	}
+
+	gelicw_cmd_stop(netdev);
+	if (w->is_assoc) {
+		w->state = GELICW_STATE_DOWN;
+		notify_assoc_event(netdev);
+	}
+	gelicw_clear_params(w);
+
+	/* set device wireless to wired */
+	gelicw_vlan_mode(netdev, GELIC_NET_VLAN_WIRED);
+	gelicw_cmd_set_port(netdev, GELICW_PORT_UP);
+	w->wireless = GELICW_WIRELESS_SUPPORTED;
+
+	return 0;
+}
+
+void gelicw_remove(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (!w->wireless)
+		return;
+
+	dev_dbg(ntodev(netdev), "gelicw_remove\n");
+	gelicw_down(netdev);
+	w->wireless = 0;
+	netdev->wireless_handlers = NULL;
+	kfree(w->data_buf);
+}
+
+void gelicw_interrupt(struct net_device *netdev, u64 status)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (!w->wireless) {
+		return;
+	}
+
+	if (status & GELICW_DEVICE_CMD_COMP) {
+		dev_dbg(ntodev(netdev), "GELICW_DEVICE_CMD_COMP\n");
+		if (w->cmd_id == GELICW_CMD_START) {
+			schedule_work(&w->work_start_done);
+		} else {
+			complete(&w->cmd_done);
+		}
+	}
+	if (status & GELICW_DEVICE_EVENT_RECV) {
+		dev_dbg(ntodev(netdev), "GELICW_DEVICE_EVENT_RECV\n");
+		if (w->wireless == GELICW_WIRELESS_SHUTDOWN)
+			gelicw_clear_event(netdev);
+		else
+			schedule_work(&w->work_event);
+	}
+}
+
+int gelicw_is_associated(struct net_device *netdev)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	if (!w->wireless)
+		return 0;
+
+	return w->is_assoc;
+}
+
+
+/*
+ * Wireless externsions
+ */
+static int gelicw_get_name(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx: get_name\n");
+	if (w->state < GELICW_STATE_UP) {
+		strcpy(wrqu->name, "radio off");
+		return 0;
+	}
+
+	if (w->wireless_mode == IEEE_B ||
+		(w->is_assoc && gelicw_is_ap_11b(&w->current_bss)))
+		strcpy(wrqu->name, "IEEE 802.11b");
+	else {
+		switch (w->wireless_mode) {
+		case IEEE_G:
+			strcpy(wrqu->name, "IEEE 802.11g");
+			break;
+		case IEEE_B | IEEE_G:
+		default:
+			strcpy(wrqu->name, "IEEE 802.11bg");
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int gelicw_set_freq(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	struct iw_freq *fwrq = &wrqu->freq;
+	int ch;
+
+	dev_dbg(ntodev(netdev), "wx: set_freq e:%d m:%d\n", fwrq->e, fwrq->m);
+	if (w->is_assoc || w->state < GELICW_STATE_UP)
+		return 0;
+
+	/* this setting has no effect for INFRA mode */
+	if (fwrq->e == 1) {
+		u32 f = fwrq->m / 100000;
+		int i;
+		for (i = 0; i < ARRAY_SIZE(freq_list); i++)
+			if (freq_list[i] == f)
+				break;
+		if (i == ARRAY_SIZE(freq_list))
+			return -EINVAL;
+		fwrq->m = i + 1; /* ch number */
+		fwrq->e = 0;
+	}
+	if (fwrq->e > 0)
+		return -EINVAL;
+
+	ch = fwrq->m;
+	if (ch < 1)
+		w->channel = 0; /* auto */
+	else if (ch > ARRAY_SIZE(freq_list))
+		return -EINVAL;
+	else {
+		/* check supported channnel */
+		if (!w->ch_info)
+			gelicw_cmd_get_ch_info(netdev);
+		if (w->ch_info & (1 << (ch - 1)))
+			w->channel = ch;
+		else
+			return -EINVAL;
+	}
+	dev_dbg(ntodev(netdev), " set cnannel: %d\n", w->channel);
+
+	return 0;
+}
+
+static int gelicw_get_freq(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx: get_freq:%d\n", w->channel);
+	if (w->channel == 0)
+		wrqu->freq.m = 0;
+	else
+		wrqu->freq.m = freq_list[w->channel - 1] * 100000;
+	wrqu->freq.e = 1;
+
+	return 0;
+}
+
+static int gelicw_set_mode(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	int mode = wrqu->mode;
+	u8 iw_mode = IW_MODE_INFRA;
+
+	dev_dbg(ntodev(netdev), "wx: set_mode:%x\n",mode);
+	switch (mode) {
+	case IW_MODE_ADHOC:
+		dev_dbg(ntodev(netdev), "IW_MODE_ADHOC\n");
+		iw_mode = mode;
+		return -EOPNOTSUPP; /* adhoc not supported */
+	case IW_MODE_INFRA:
+	default:
+		dev_dbg(ntodev(netdev), "IW_MODE_INFRA\n");
+		iw_mode = IW_MODE_INFRA;
+		break;
+	}
+
+	/* send common config */
+	gelicw_send_common_config(netdev, &w->iw_mode, iw_mode);
+
+	return 0;
+}
+
+static int gelicw_get_mode(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx: get_mode\n");
+	wrqu->mode = w->iw_mode;
+
+	return 0;
+}
+
+static inline int gelicw_qual2level(int qual)
+{
+	return (qual * 4 - 820)/10; /* FIXME: dummy */
+}
+
+static int gelicw_get_range(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	struct iw_range *range = (struct iw_range *)extra;
+	int num_ch, i;
+
+	dev_dbg(ntodev(netdev), "wx: get_range\n");
+	wrqu->data.length = sizeof(*range);
+	memset(range, 0, sizeof(*range));
+
+	/* wireless extension */
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 19;
+
+	/* supported bitrates */
+	if (w->wireless_mode == IEEE_B)
+		range->num_bitrates = GELICW_NUM_11B_BITRATES;
+	else
+		range->num_bitrates = ARRAY_SIZE(bitrate_list);
+	range->throughput = bitrate_list[range->num_bitrates -1] / 2; /* half */
+	for (i = 0; i < range->num_bitrates; i++)
+		range->bitrate[i] = bitrate_list[i];
+
+	range->max_qual.qual = 100; /* relative value */
+	range->max_qual.level = 0;
+	range->avg_qual.qual = 50;
+	range->avg_qual.level = 0;
+	range->sensitivity = 0;
+
+	/* encryption capabilities */
+	range->encoding_size[0] = 5;	/* 40bit WEP */
+	range->encoding_size[1] = 13;	/* 104bit WEP */
+	range->encoding_size[2] = 64;	/* WPA-PSK */
+	range->num_encoding_sizes = 3;
+	range->max_encoding_tokens = WEP_KEYS;
+	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
+			  IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
+
+	/* freq */
+	if (!w->ch_info)
+		gelicw_cmd_get_ch_info(netdev); /* get supported freq */
+
+	num_ch = 0;
+	for (i = 0; i < ARRAY_SIZE(freq_list); i++)
+		if (w->ch_info & (1 << i)) {
+			range->freq[num_ch].i = i + 1;
+			range->freq[num_ch].m = freq_list[i] * 100000;
+			range->freq[num_ch].e = 1;
+			if (++num_ch == IW_MAX_FREQUENCIES)
+				break;
+		}
+
+	range->num_channels = num_ch;
+	range->num_frequency = num_ch;
+
+	/* event capabilities */
+	range->event_capa[0] = (IW_EVENT_CAPA_K_0 |
+				IW_EVENT_CAPA_MASK(SIOCGIWAP));
+	range->event_capa[1] = IW_EVENT_CAPA_K_1;
+
+	return 0;
+}
+
+static int gelicw_set_wap(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	static const u8 any[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	static const u8 off[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+	dev_dbg(ntodev(netdev), "wx: set_wap\n");
+	if (wrqu->ap_addr.sa_family != ARPHRD_ETHER)
+		return -EINVAL;
+
+	if (!memcmp(any, wrqu->ap_addr.sa_data, ETH_ALEN)
+	    || !memcmp(off, wrqu->ap_addr.sa_data, ETH_ALEN)) {
+		if (!memcmp(off, w->wap_bssid, ETH_ALEN))
+			return 0; /* ap off, no change */
+		else {
+			memset(w->wap_bssid, 0, ETH_ALEN);
+			/* start scan */
+		}
+	} else if (!memcmp(w->wap_bssid, wrqu->ap_addr.sa_data, ETH_ALEN)) {
+		/* no change */
+		return 0;
+	} else if (!memcmp(w->bssid, wrqu->ap_addr.sa_data, ETH_ALEN)){
+		/* current bss */
+		memcpy(w->wap_bssid, wrqu->ap_addr.sa_data, ETH_ALEN);
+		return 0;
+	} else
+		memcpy(w->wap_bssid, wrqu->ap_addr.sa_data, ETH_ALEN);
+
+	/* start scan */
+	if (w->essid_len && w->state >= GELICW_STATE_SCAN_DONE) {
+		gelicw_disassoc(netdev);
+		/* scan essid */
+		cancel_delayed_work(&w->work_scan_all);
+		cancel_delayed_work(&w->work_scan_essid);
+		w->essid_search = 1;
+		schedule_delayed_work(&w->work_scan_essid, 0);
+	}
+
+	return 0;
+}
+
+static int gelicw_get_wap(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx: get_wap\n");
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(wrqu->ap_addr.sa_data, w->bssid, ETH_ALEN);
+
+	return 0;
+}
+
+static int gelicw_set_scan(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx: set_scan\n");
+	if (w->state < GELICW_STATE_UP)
+		return -EIO;
+
+	/* cancel scan */
+	cancel_delayed_work(&w->work_scan_all);
+	cancel_delayed_work(&w->work_scan_essid);
+
+	schedule_delayed_work(&w->work_scan_all, 0);
+
+	return 0;
+}
+
+#define MAX_CUSTOM_LEN 64
+static char *gelicw_translate_scan(struct net_device *netdev,
+				char *start, char *stop,
+				struct gelicw_bss *list)
+{
+	char custom[MAX_CUSTOM_LEN];
+	struct iw_event iwe;
+	int i;
+	char *p, *current_val;
+
+	/* BSSID */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(iwe.u.ap_addr.sa_data, list->bssid, ETH_ALEN);
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_ADDR_LEN);
+
+	/* ESSID */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	iwe.u.data.length = list->essid_len;
+	start = iwe_stream_add_point(start, stop, &iwe, list->essid);
+
+	/* protocol name */
+	iwe.cmd = SIOCGIWNAME;
+	if (gelicw_is_ap_11b(list))
+		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	else
+		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_CHAR_LEN);
+
+	/* MODE */
+	iwe.cmd = SIOCGIWMODE;
+	iwe.u.mode = list->mode;
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_UINT_LEN);
+
+	/* FREQ */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = list->channel;
+	iwe.u.freq.e = 0;
+	iwe.u.freq.i = 0;
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* ENCODE */
+	iwe.cmd = SIOCGIWENCODE;
+	if (list->capability & WLAN_CAPABILITY_PRIVACY)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(start, stop, &iwe, list->essid);
+
+	/* QUAL */
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.updated  = IW_QUAL_QUAL_UPDATED |
+			IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID;
+	iwe.u.qual.qual = list->rssi;
+	iwe.u.qual.level = gelicw_qual2level(list->rssi);
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_QUAL_LEN);
+
+	/* RATE */
+	current_val = start + IW_EV_LCP_LEN;
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+	for (i = 0; i < list->rates_len; i++) {
+		iwe.u.bitrate.value = ((list->rates[i] & 0x7f) * 500000);
+		current_val = iwe_stream_add_value(start, current_val, stop,
+					&iwe, IW_EV_PARAM_LEN);
+	}
+	for (i = 0; i < list->rates_ex_len; i++) {
+		iwe.u.bitrate.value = ((list->rates_ex[i] & 0x7f) * 500000);
+		current_val = iwe_stream_add_value(start, current_val, stop,
+					&iwe, IW_EV_PARAM_LEN);
+	}
+	if ((current_val - start) > IW_EV_LCP_LEN)
+		start = current_val;
+
+	/* Extra */
+	/* BEACON */
+	memset(&iwe, 0, sizeof(iwe));
+	iwe.cmd = IWEVCUSTOM;
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN, "bcn_int=%d", list->beacon_interval);
+	iwe.u.data.length = p - custom;
+	start = iwe_stream_add_point(start, stop, &iwe, custom);
+
+	/* AP security */
+	memset(&iwe, 0, sizeof(iwe));
+	iwe.cmd = IWEVCUSTOM;
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN, "ap_sec=%04X", list->sec_info);
+	iwe.u.data.length = p - custom;
+	start = iwe_stream_add_point(start, stop, &iwe, custom);
+
+	return start;
+}
+
+static int gelicw_get_scan(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	int i;
+	char *ev = extra;
+	char *stop = ev + wrqu->data.length;
+
+	dev_dbg(ntodev(netdev), "wx: get_scan \n");
+	switch (w->state) {
+	case GELICW_STATE_DOWN:
+	case GELICW_STATE_UP:
+		return 0; /* no scan results */
+	case GELICW_STATE_SCANNING:
+		return -EAGAIN; /* now scanning */
+	case GELICW_STATE_SCAN_DONE:
+		if (!w->scan_all) /* essid scan */
+			return -EAGAIN;
+		break;
+	default:
+		break;
+	}
+
+	w->scan_all = 0;
+	for (i = 0; i < w->num_bss_list; i++)
+		ev = gelicw_translate_scan(netdev, ev, stop, &w->bss_list[i]);
+	wrqu->data.length = ev - extra;
+	wrqu->data.flags = 0;
+
+	/* start background scan */
+	if (w->essid_search)
+		schedule_delayed_work(&w->work_scan_essid,
+					GELICW_SCAN_INTERVAL);
+
+	return 0;
+}
+
+static int gelicw_set_essid(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u16 length = 0;
+
+	dev_dbg(ntodev(netdev), "wx:set_essid\n");
+	/* cancel scan */
+	w->essid_search = 0;
+	cancel_delayed_work(&w->work_scan_all);
+	cancel_delayed_work(&w->work_scan_essid);
+
+	if (wrqu->essid.flags && wrqu->essid.length)
+		length = wrqu->essid.length;
+
+	if (length == 0) {
+		/* essid ANY scan not supported */
+		dev_dbg(ntodev(netdev), "ESSID ANY\n");
+		w->essid_len = 0; /* clear essid */
+		w->essid[0] = '\0';
+		return 0;
+	} else {
+		/* check essid */
+		if (length > IW_ESSID_MAX_SIZE)
+			return -EINVAL;
+		if (w->essid_len == length
+		    && !strncmp(w->essid, extra, length)) {
+			/* same essid */
+			if (w->is_assoc)
+				return 0;
+		} else {
+			/* set new essid */
+			w->essid_len = length;
+			memcpy(w->essid, extra, length);
+		}
+	}
+	/* start essid scan */
+	w->essid_search = 1;
+	schedule_delayed_work(&w->work_scan_essid, 0);
+
+	return 0;
+}
+
+static int gelicw_get_essid(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx:get_essid\n");
+	if (w->essid_len) {
+		memcpy(extra, w->essid, w->essid_len);
+		wrqu->essid.length = w->essid_len;
+		wrqu->essid.flags = 1;
+	} else {
+		wrqu->essid.length = 0;
+		wrqu->essid.flags = 0;
+	}
+
+	return 0;
+}
+
+static int gelicw_set_nick(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	u32 len = wrqu->data.length;
+
+	dev_dbg(ntodev(netdev), "wx:set_nick\n");
+	if (len > IW_ESSID_MAX_SIZE)
+		return -EINVAL;
+
+	memset(w->nick, 0, sizeof(w->nick));
+	memcpy(w->nick, extra, len);
+
+	return 0;
+}
+
+static int gelicw_get_nick(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx:get_nick\n");
+	wrqu->data.length = strlen(w->nick);
+	memcpy(extra, w->nick, wrqu->data.length);
+	wrqu->data.flags = 1;
+
+	return 0;
+}
+
+static int gelicw_set_rate(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	dev_dbg(ntodev(netdev), "wx:set_rate:%d\n", wrqu->bitrate.value);
+	if (wrqu->bitrate.value == -1)
+		return 0;	/* auto rate only */
+
+	return -EOPNOTSUPP;
+}
+
+static int gelicw_get_rate(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx:get_rate\n");
+
+	if (w->wireless_mode == IEEE_B ||
+		(w->is_assoc && gelicw_is_ap_11b(&w->current_bss)))
+		wrqu->bitrate.value = bitrate_list[GELICW_NUM_11B_BITRATES -1];
+	else
+		wrqu->bitrate.value = bitrate_list[ARRAY_SIZE(bitrate_list) -1];
+
+	wrqu->bitrate.fixed = 0;
+
+	return 0;
+}
+
+static int gelicw_set_encode(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	struct iw_point *enc = &wrqu->encoding;
+	int i, index, key_index;
+
+	dev_dbg(ntodev(netdev), "wx:set_encode: flags:%x\n", enc->flags );
+	index = enc->flags & IW_ENCODE_INDEX;
+	if (index < 0 || index > WEP_KEYS)
+		return -EINVAL;
+	index--;
+
+	if (enc->length > IW_ENCODING_TOKEN_MAX)
+		return -EINVAL;
+
+	if (index != -1)
+		w->key_index = index;
+	key_index = w->key_index;
+
+	if (enc->flags & IW_ENCODE_DISABLED) {
+		/* disable encryption */
+		if (index == -1) {
+			/* disable all */
+			w->key_alg = IW_ENCODE_ALG_NONE;
+			for (i = 0; i < WEP_KEYS; i++)
+				w->key_len[i] = 0;
+		} else
+			w->key_len[key_index] = 0;
+	} else if (enc->flags & IW_ENCODE_NOKEY) {
+		/* key not changed */
+		if (w->key_alg == IW_ENCODE_ALG_NONE)
+			w->key_alg = IW_ENCODE_ALG_WEP; /* default wep */
+	} else {
+		/* enable encryption */
+		w->key_len[key_index] = enc->length;
+		if (w->key_alg == IW_ENCODE_ALG_NONE)
+			w->key_alg = IW_ENCODE_ALG_WEP; /* default wep */
+		memcpy(w->key[key_index], extra, w->key_len[key_index]);
+	}
+	dev_dbg(ntodev(netdev), "key %d len:%d alg:%x\n",\
+		key_index, w->key_len[key_index], w->key_alg);
+
+	if (w->state >= GELICW_STATE_SCAN_DONE
+		&& w->cmd_send_flg == 0 && w->essid_len)
+		/* scan essid and set other params */
+		schedule_delayed_work(&w->work_scan_essid, 0);
+	else
+		schedule_delayed_work(&w->work_encode, 0);
+
+	return 0;
+}
+
+static int gelicw_get_encode(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	struct iw_point *enc = &wrqu->encoding;
+	int index, key_index;
+
+	dev_dbg(ntodev(netdev), "wx:get_encode\n");
+	index = enc->flags & IW_ENCODE_INDEX;
+	if (index < 0 || index > WEP_KEYS)
+		return -EINVAL;
+
+	index--;
+	key_index = (index == -1 ? w->key_index : index);
+	enc->flags = key_index + 1;
+
+	if (w->key_alg == IW_ENCODE_ALG_NONE || !w->key_len[key_index]) {
+		/* no encryption */
+		enc->flags |= IW_ENCODE_DISABLED;
+		enc->length = 0;
+	} else {
+		enc->flags |= IW_ENCODE_NOKEY;
+		enc->length = w->key_len[key_index];
+		memset(extra, 0, w->key_len[key_index]);
+	}
+
+	return 0;
+}
+
+static int gelicw_set_auth(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	struct iw_param *param = &wrqu->param;
+	int value = param->value;
+	int ret = 0;
+
+	dev_dbg(ntodev(netdev), "wx:set_auth:%x\n", param->flags & IW_AUTH_INDEX);
+	switch(param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_KEY_MGMT:
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+	case IW_AUTH_DROP_UNENCRYPTED:
+	case IW_AUTH_WPA_ENABLED:
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+	case IW_AUTH_ROAMING_CONTROL:
+	case IW_AUTH_PRIVACY_INVOKED:
+		/* ignore */
+		dev_dbg(ntodev(netdev), "IW_AUTH(%x)\n", param->flags & IW_AUTH_INDEX);
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+		dev_dbg(ntodev(netdev), "IW_AUTH_80211_AUTH_ALG:\n");
+		if (value & IW_AUTH_ALG_SHARED_KEY)
+			w->auth_mode = IW_AUTH_ALG_SHARED_KEY;
+		else if (value & IW_AUTH_ALG_OPEN_SYSTEM)
+			w->auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
+		else
+			ret = -EINVAL;
+		break;
+	default:
+		dev_dbg(ntodev(netdev), "IW_AUTH_UNKNOWN flags:%x\n", param->flags);
+		ret = -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+static int gelicw_get_auth(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	struct iw_param *param = &wrqu->param;
+
+	dev_dbg(ntodev(netdev), "wx:get_auth\n");
+	switch(param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_80211_AUTH_ALG:
+		param->value = w->auth_mode;
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		if ((w->key_alg & IW_ENCODE_ALG_TKIP)
+			|| (w->key_alg & IW_ENCODE_ALG_CCMP))
+			param->value = 1;
+		else
+			param->value = 0;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int gelicw_set_encodeext(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	struct iw_point *enc = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int i, index, key_index;
+
+	dev_dbg(ntodev(netdev), "wx:set_encodeext\n");
+	index = enc->flags & IW_ENCODE_INDEX;
+	if (index < 0 || index > WEP_KEYS)
+		return -EINVAL;
+
+	index--;
+	if (ext->key_len > IW_ENCODING_TOKEN_MAX)
+		return -EINVAL;
+
+	if (index != -1)
+		w->key_index = index;
+	key_index = w->key_index;
+
+	if (enc->flags & IW_ENCODE_DISABLED) {
+		/* disable encryption */
+		if (index == -1) {
+			/* disable all */
+			w->key_alg = IW_ENCODE_ALG_NONE;
+			for (i = 0; i < WEP_KEYS; i++)
+				w->key_len[i] = 0;
+		} else
+			w->key_len[key_index] = 0;
+	} else if (enc->flags & IW_ENCODE_NOKEY) {
+		/* key not changed */
+		w->key_alg = ext->alg;
+	} else {
+		w->key_len[key_index] = ext->key_len;
+		w->key_alg = ext->alg;
+		if (w->key_alg != IW_ENCODE_ALG_NONE && w->key_len[key_index])
+			memcpy(w->key[key_index], ext->key, w->key_len[key_index]);
+	}
+	dev_dbg(ntodev(netdev), "key %d len:%d alg:%x\n",\
+		key_index, w->key_len[key_index], w->key_alg);
+
+	if (w->state >= GELICW_STATE_SCAN_DONE
+		&& w->cmd_send_flg == 0 && w->essid_len)
+		/* scan essid and set other params */
+		schedule_delayed_work(&w->work_scan_essid, 0);
+	else
+		schedule_delayed_work(&w->work_encode, 0);
+
+	return 0;
+}
+
+static int gelicw_get_encodeext(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	struct iw_point *enc = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int index, key_index, key_len;
+
+	dev_dbg(ntodev(netdev), "wx:get_encodeext\n");
+	key_len = enc->length - sizeof(*ext);
+	if (key_len < 0)
+		return -EINVAL;
+
+	index = enc->flags & IW_ENCODE_INDEX;
+	if (index < 0 || index > WEP_KEYS)
+		return -EINVAL;
+
+	index--;
+	key_index = (index == -1 ? w->key_index : index);
+
+	memset(ext, 0, sizeof(*ext));
+	enc->flags = key_index + 1;
+
+	if (w->key_alg == IW_ENCODE_ALG_NONE || !w->key_len[key_index]) {
+		/* no encryption */
+		enc->flags |= IW_ENCODE_DISABLED;
+		ext->alg = IW_ENCODE_ALG_NONE;
+		ext->key_len = 0;
+	} else {
+		enc->flags |= IW_ENCODE_NOKEY;
+		ext->alg = w->key_alg;
+		ext->key_len = w->key_len[key_index];
+	}
+
+	return 0;
+}
+
+/*
+ * wireless stats
+ */
+static struct iw_statistics *gelicw_get_wireless_stats(struct net_device *netdev)
+{
+	static struct iw_statistics wstats;
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx:wireless_stats\n");
+	if (w->state < GELICW_STATE_ASSOCIATED) {
+		wstats.qual.updated  = IW_QUAL_QUAL_UPDATED |
+				IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID;
+		wstats.qual.qual = 0;
+		wstats.qual.level = 0;
+		return &wstats;
+	}
+	init_completion(&w->rssi_done);
+	schedule_delayed_work(&w->work_rssi, 0);
+
+	wait_for_completion_interruptible(&w->rssi_done);
+	wstats.qual.updated  = IW_QUAL_QUAL_UPDATED |
+			IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID;
+	wstats.qual.qual = w->rssi;
+	wstats.qual.level = gelicw_qual2level(w->rssi);
+
+	return &wstats;
+}
+
+/*
+ * private handler
+ */
+static int gelicw_priv_set_wireless_mode(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	int mode = *(int *)extra;
+
+	dev_dbg(ntodev(netdev), "wx:priv_set_wmode\n");
+	switch (mode) {
+	case IEEE_B: /* 0x02 */
+	case IEEE_G: /* 0x04 */
+	case IEEE_B | IEEE_G:
+		break;
+	default:
+		return -EINVAL;
+	}
+	/* send common config */
+	gelicw_send_common_config(netdev, &w->wireless_mode, (u8)mode);
+
+	return 0;
+}
+
+static int gelicw_priv_get_wireless_mode(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+
+	dev_dbg(ntodev(netdev), "wx:priv_get_wmode\n");
+	switch (w->wireless_mode) {
+	case IEEE_B:
+		strncpy(extra, "802.11b (2)", MAX_IW_PRIV_SIZE);
+		break;
+	case IEEE_G:
+		strncpy(extra, "802.11g (4)", MAX_IW_PRIV_SIZE);
+		break;
+	case IEEE_B | IEEE_G:
+	default:
+		strncpy(extra, "802.11bg (6)", MAX_IW_PRIV_SIZE);
+		break;
+	}
+	wrqu->data.length = strlen(extra);
+
+	return 0;
+}
+
+static int gelicw_priv_set_alg_mode(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	int mode = *(int *)extra;
+
+	dev_dbg(ntodev(netdev), "wx:priv_set_alg\n");
+	switch (mode) {
+	case IW_ENCODE_ALG_NONE:
+	case IW_ENCODE_ALG_WEP:
+	case IW_ENCODE_ALG_TKIP:
+	case IW_ENCODE_ALG_CCMP:
+		break;
+	default:
+		return -EINVAL;
+	}
+	/* send common config */
+	gelicw_send_common_config(netdev, &w->key_alg, (u8)mode);
+
+	return 0;
+}
+
+static int gelicw_priv_get_alg_mode(struct net_device *netdev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct gelic_wireless *w = gelicw_priv(netdev);
+	char *p;
+
+	dev_dbg(ntodev(netdev), "wx:priv_get_alg\n");
+	switch (w->key_alg) {
+	case IW_ENCODE_ALG_NONE:
+		strncpy(extra, "OFF", MAX_IW_PRIV_SIZE);
+		break;
+	case IW_ENCODE_ALG_WEP:
+		strncpy(extra, "WEP", MAX_IW_PRIV_SIZE);
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		strncpy(extra, "TKIP", MAX_IW_PRIV_SIZE);
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		strncpy(extra, "AES-CCMP", MAX_IW_PRIV_SIZE);
+		break;
+	default:
+		break;
+	}
+	p = extra + strlen(extra);
+
+	if (w->key_alg == IW_ENCODE_ALG_TKIP
+		|| w->key_alg == IW_ENCODE_ALG_CCMP) {
+		if (w->key_len[w->key_index] == 64) /* current key index */
+			strncpy(p, " hex", MAX_IW_PRIV_SIZE);
+		else
+			strncpy(p, " passphrase", MAX_IW_PRIV_SIZE);
+	}
+	wrqu->data.length = strlen(extra);
+
+	return 0;
+}
+
+
+/*
+ * Wireless handlers
+ */
+static const iw_handler gelicw_handler[] =
+{
+	[IW_IOCTL_IDX(SIOCGIWNAME)]      = (iw_handler) gelicw_get_name,
+	[IW_IOCTL_IDX(SIOCSIWFREQ)]      = (iw_handler) gelicw_set_freq,
+	[IW_IOCTL_IDX(SIOCGIWFREQ)]      = (iw_handler) gelicw_get_freq,
+	[IW_IOCTL_IDX(SIOCSIWMODE)]      = (iw_handler) gelicw_set_mode,
+	[IW_IOCTL_IDX(SIOCGIWMODE)]      = (iw_handler) gelicw_get_mode,
+	[IW_IOCTL_IDX(SIOCGIWRANGE)]     = (iw_handler) gelicw_get_range,
+	[IW_IOCTL_IDX(SIOCSIWAP)]        = (iw_handler) gelicw_set_wap,
+	[IW_IOCTL_IDX(SIOCGIWAP)]        = (iw_handler) gelicw_get_wap,
+	[IW_IOCTL_IDX(SIOCSIWSCAN)]      = (iw_handler) gelicw_set_scan,
+	[IW_IOCTL_IDX(SIOCGIWSCAN)]      = (iw_handler) gelicw_get_scan,
+	[IW_IOCTL_IDX(SIOCSIWESSID)]     = (iw_handler) gelicw_set_essid,
+	[IW_IOCTL_IDX(SIOCGIWESSID)]     = (iw_handler) gelicw_get_essid,
+	[IW_IOCTL_IDX(SIOCSIWNICKN)]     = (iw_handler) gelicw_set_nick,
+	[IW_IOCTL_IDX(SIOCGIWNICKN)]     = (iw_handler) gelicw_get_nick,
+	[IW_IOCTL_IDX(SIOCSIWRATE)]      = (iw_handler) gelicw_set_rate,
+	[IW_IOCTL_IDX(SIOCGIWRATE)]      = (iw_handler) gelicw_get_rate,
+	[IW_IOCTL_IDX(SIOCSIWENCODE)]    = (iw_handler) gelicw_set_encode,
+	[IW_IOCTL_IDX(SIOCGIWENCODE)]    = (iw_handler) gelicw_get_encode,
+	[IW_IOCTL_IDX(SIOCSIWAUTH)]      = (iw_handler) gelicw_set_auth,
+	[IW_IOCTL_IDX(SIOCGIWAUTH)]      = (iw_handler) gelicw_get_auth,
+	[IW_IOCTL_IDX(SIOCSIWENCODEEXT)] = (iw_handler) gelicw_set_encodeext,
+	[IW_IOCTL_IDX(SIOCGIWENCODEEXT)] = (iw_handler) gelicw_get_encodeext,
+};
+
+/*
+ * Private wireless handlers
+ */
+enum {
+	GELICW_PRIV_SET_WIRELESS_MODE = SIOCIWFIRSTPRIV,
+	GELICW_PRIV_GET_WIRELESS_MODE,
+	GELICW_PRIV_SET_AUTH,
+	GELICW_PRIV_GET_AUTH,
+	GELICW_PRIV_START,
+	GELICW_PRIV_STOP,
+};
+
+static struct iw_priv_args gelicw_private_args[] = {
+	{
+	 .cmd = GELICW_PRIV_SET_WIRELESS_MODE,
+	 .set_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 .name = "set_wmode"
+	},
+	{
+	 .cmd = GELICW_PRIV_GET_WIRELESS_MODE,
+	 .get_args = IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_IW_PRIV_SIZE,
+	 .name = "get_wmode"
+	},
+	{
+	 .cmd = GELICW_PRIV_SET_AUTH,
+	 .set_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 .name = "set_alg"
+	},
+	{
+	 .cmd = GELICW_PRIV_GET_AUTH,
+	 .get_args = IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_IW_PRIV_SIZE,
+	 .name = "get_alg"
+	},
+};
+
+static const iw_handler gelicw_private_handler[] =
+{
+	gelicw_priv_set_wireless_mode,
+	gelicw_priv_get_wireless_mode,
+	gelicw_priv_set_alg_mode,
+	gelicw_priv_get_alg_mode,
+};
+
+static struct iw_handler_def gelicw_handler_def =
+{
+	.num_standard	= ARRAY_SIZE(gelicw_handler),
+	.num_private	= ARRAY_SIZE(gelicw_private_handler),
+	.num_private_args = ARRAY_SIZE(gelicw_private_args),
+	.standard	= (iw_handler *)gelicw_handler,
+	.private	= (iw_handler *)gelicw_private_handler,
+	.private_args	= (struct iw_priv_args *)gelicw_private_args,
+	.get_wireless_stats = gelicw_get_wireless_stats
+};
+
+EXPORT_SYMBOL_GPL(gelicw_setup_netdev);
+EXPORT_SYMBOL_GPL(gelicw_up);
+EXPORT_SYMBOL_GPL(gelicw_down);
+EXPORT_SYMBOL_GPL(gelicw_remove);
+EXPORT_SYMBOL_GPL(gelicw_interrupt);
+EXPORT_SYMBOL_GPL(gelicw_is_associated);
+
