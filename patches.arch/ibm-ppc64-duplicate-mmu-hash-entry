Return-Path: <olaf@suse.de>
Received: from hermes.suse.de (hermes.suse.de [10.0.0.1])
	by wotan.suse.de (Postfix) with ESMTP id 3D16B135B2
	for <olh@wotan.suse.de>; Thu, 15 Apr 2004 22:00:40 +0200 (CEST)
Received: by hermes.suse.de (Postfix)
	id 3704C35E8B; Thu, 15 Apr 2004 22:00:40 +0200 (CEST)
Received: from mandarine.suse.de (mandarine.suse.de [10.10.3.21])
	by hermes.suse.de (Postfix) with ESMTP
	id 31C7535DC9; Thu, 15 Apr 2004 22:00:40 +0200 (CEST)
Received: by mandarine.suse.de (Postfix, from userid 90)
	id 1E40B468F6; Thu, 15 Apr 2004 22:00:40 +0200 (CEST)
To: mantel@suse.de, olh@suse.de
Subject: Incoming changes to linux-2.5 cset 1.1800  mandarine.suse.de:/olaf/sources/tree/linux-2.5 
Message-Id: <20040415200040.1E40B468F6@mandarine.suse.de>
Date: Thu, 15 Apr 2004 22:00:40 +0200 (CEST)
From: olaf@suse.de (Olaf Hering)
X-Spam-Checker-Version: SpamAssassin 2.63 (2004-01-11) on wotan.suse.de
X-Spam-Level: 
X-Spam-Status: No, hits=-4.8 required=5.0 tests=AWL,BAYES_00 autolearn=ham 
	version=2.63

old status OK
ChangeSet
  1.1800 04/04/15 07:04:10 benh@kernel.crashing.org[torvalds] +1 -0
  [PATCH] ppc64: Fix possible duplicate MMU hash entries
  
  The current code has a subtle race where 2 hash PTEs can be inserted
  for the same virtual address for a short period of time. There should
  not be a stale one as the "old" one ultimately gets flushed, but the
  architecture specifies that having two hash PTE is illegal and can
  result in undefined behaviour.
  
  This patch fixes it by never clearing the _PAGE_HASHPTE bit when
  doing test_and_clear_{young,dirty}. That means that subsequent faults
  on those pages will have a bit more overhead to "discover" that the
  hash entry was indeed evicted.
  
  It also adds a small optisation to avoid doing the atomic operation
  and the hash flush in test_and_clear_dirty when the page isn't dirty
  or when setting write protect while it's already set.

  include/asm-ppc64/pgtable.h
    1.32 04/04/08 10:30:57 benh@kernel.crashing.org[torvalds] +9 -26
    ppc64: Fix possible duplicate MMU hash entries

.........................................................................
diff -Nru a/include/asm-ppc64/pgtable.h b/include/asm-ppc64/pgtable.h
--- a/include/asm-ppc64/pgtable.h	Thu Apr 15 22:00:40 2004
+++ b/include/asm-ppc64/pgtable.h	Thu Apr 15 22:00:40 2004
@@ -313,7 +313,9 @@
 {
 	unsigned long old;
 
-	old = pte_update(ptep, _PAGE_ACCESSED | _PAGE_HPTEFLAGS);
+       	if ((pte_val(*ptep) & (_PAGE_ACCESSED | _PAGE_HASHPTE)) == 0)
+		return 0;
+	old = pte_update(ptep, _PAGE_ACCESSED);
 	if (old & _PAGE_HASHPTE) {
 		hpte_update(ptep, old, 0);
 		flush_tlb_pending();	/* XXX generic code doesn't flush */
@@ -326,12 +328,13 @@
  * moment we always flush but we need to fix hpte_update and test if the
  * optimisation is worth it.
  */
-#if 1
 static inline int ptep_test_and_clear_dirty(pte_t *ptep)
 {
 	unsigned long old;
 
-	old = pte_update(ptep, _PAGE_DIRTY | _PAGE_HPTEFLAGS);
+       	if ((pte_val(*ptep) & _PAGE_DIRTY) == 0)
+		return 0;
+	old = pte_update(ptep, _PAGE_DIRTY);
 	if (old & _PAGE_HASHPTE)
 		hpte_update(ptep, old, 0);
 	return (old & _PAGE_DIRTY) != 0;
@@ -341,7 +344,9 @@
 {
 	unsigned long old;
 
-	old = pte_update(ptep, _PAGE_RW | _PAGE_HPTEFLAGS);
+       	if ((pte_val(*ptep) & _PAGE_RW) == 0)
+       		return;
+	old = pte_update(ptep, _PAGE_RW);
 	if (old & _PAGE_HASHPTE)
 		hpte_update(ptep, old, 0);
 }
@@ -358,7 +363,6 @@
 #define ptep_clear_flush_young(__vma, __address, __ptep)		\
 ({									\
 	int __young = ptep_test_and_clear_young(__ptep);		\
-	flush_tlb_page(__vma, __address);				\
 	__young;							\
 })
 
@@ -369,27 +373,6 @@
 	flush_tlb_page(__vma, __address);				\
 	__dirty;							\
 })
-
-#else
-static inline int ptep_test_and_clear_dirty(pte_t *ptep)
-{
-	unsigned long old;
-
-	old = pte_update(ptep, _PAGE_DIRTY);
-	if ((~old & (_PAGE_HASHPTE | _PAGE_RW | _PAGE_DIRTY)) == 0)
-		hpte_update(ptep, old, 1);
-	return (old & _PAGE_DIRTY) != 0;
-}
-
-static inline void ptep_set_wrprotect(pte_t *ptep)
-{
-	unsigned long old;
-
-	old = pte_update(ptep, _PAGE_RW);
-	if ((~old & (_PAGE_HASHPTE | _PAGE_RW | _PAGE_DIRTY)) == 0)
-		hpte_update(ptep, old, 1);
-}
-#endif
 
 static inline pte_t ptep_get_and_clear(pte_t *ptep)
 {
.........................................................................
# vim: syntax=diff

