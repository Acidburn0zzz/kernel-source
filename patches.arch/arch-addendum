--- linux-2.5.69/arch/x86_64/kernel/reboot.c.~1~	2003-05-05 01:53:37.000000000 +0200
+++ linux-2.5.69/arch/x86_64/kernel/reboot.c	2003-05-15 14:54:47.000000000 +0200
@@ -5,10 +5,10 @@
 #include <linux/kernel.h>
 #include <linux/ctype.h>
 #include <linux/string.h>
+#include <linux/irq.h>
 #include <asm/io.h>
 #include <asm/kdebug.h>
 #include <asm/delay.h>
-#include <asm/hw_irq.h>
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
--- linux-2.5.69/include/asm-alpha/hw_irq.h.~1~	2003-05-05 01:52:59.000000000 +0200
+++ linux-2.5.69/include/asm-alpha/hw_irq.h	2003-05-15 14:59:54.000000000 +0200
@@ -13,4 +13,6 @@ extern volatile unsigned long irq_err_co
 #define ACTUAL_NR_IRQS	NR_IRQS
 #endif
 
+extern irq_desc_t irq_desc [NR_IRQS];
+
 #endif
--- linux-2.5.69/include/asm-alpha/ptrace.h.~1~	2003-05-05 01:53:07.000000000 +0200
+++ linux-2.5.69/include/asm-alpha/ptrace.h	2003-05-15 15:13:39.000000000 +0200
@@ -69,6 +69,7 @@ struct switch_stack {
 #ifdef __KERNEL__
 #define user_mode(regs) (((regs)->ps & 8) != 0)
 #define instruction_pointer(regs) ((regs)->pc)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 #endif
 
--- linux-2.5.69/include/asm-arm/ptrace.h.~1~	2003-05-05 01:53:32.000000000 +0200
+++ linux-2.5.69/include/asm-arm/ptrace.h	2003-05-15 15:18:03.000000000 +0200
@@ -17,6 +17,8 @@
 #define instruction_pointer(regs) \
 	(pc_pointer((regs)->ARM_pc))
 
+#define force_successful_syscall_return()	do { } while (0)
+
 #ifdef __KERNEL__
 extern void show_regs(struct pt_regs *);
 
--- linux-2.5.69/include/asm-cris/ptrace.h.~1~	2003-05-05 01:53:32.000000000 +0200
+++ linux-2.5.69/include/asm-cris/ptrace.h	2003-05-15 15:15:32.000000000 +0200
@@ -114,6 +114,7 @@ struct switch_stack {
 /* bit 8 is user-mode flag */
 #define user_mode(regs) (((regs)->dccr & 0x100) != 0)
 #define instruction_pointer(regs) ((regs)->irp)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 #endif
 
--- linux-2.5.69/include/asm-h8300/ptrace.h.~1~	2003-05-05 01:53:41.000000000 +0200
+++ linux-2.5.69/include/asm-h8300/ptrace.h	2003-05-15 15:14:02.000000000 +0200
@@ -50,6 +50,7 @@ struct switch_stack {
 
 #define user_mode(regs) (!((regs)->ccr & PS_S))
 #define instruction_pointer(regs) ((regs)->pc)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 #endif /* __KERNEL__ */
 #endif /* __ASSEMBLY__ */
--- linux-2.5.69/include/asm-m68k/ptrace.h.~1~	2003-05-05 01:53:57.000000000 +0200
+++ linux-2.5.69/include/asm-m68k/ptrace.h	2003-05-15 15:16:03.000000000 +0200
@@ -73,6 +73,7 @@ struct switch_stack {
 
 #define user_mode(regs) (!((regs)->sr & PS_S))
 #define instruction_pointer(regs) ((regs)->pc)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 #endif /* __KERNEL__ */
 #endif /* __ASSEMBLY__ */
--- linux-2.5.69/include/asm-m68knommu/ptrace.h.~1~	2003-05-05 01:53:01.000000000 +0200
+++ linux-2.5.69/include/asm-m68knommu/ptrace.h	2003-05-15 15:11:37.000000000 +0200
@@ -84,6 +84,7 @@ struct switch_stack {
 
 #define user_mode(regs) (!((regs)->sr & PS_S))
 #define instruction_pointer(regs) ((regs)->pc)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 #endif /* __KERNEL__ */
 #endif /* __ASSEMBLY__ */
--- linux-2.5.69/include/asm-mips/hw_irq.h.~1~	2003-05-05 01:53:41.000000000 +0200
+++ linux-2.5.69/include/asm-mips/hw_irq.h	2003-05-15 15:08:44.000000000 +0200
@@ -13,4 +13,6 @@ static inline void hw_resend_irq(struct 
 {
 }
 
+extern irq_desc_t irq_desc [NR_IRQS];
+
 #endif /* _ASM_HW_IRQ_H */
--- linux-2.5.69/include/asm-mips/ptrace.h.~1~	2003-05-05 01:53:32.000000000 +0200
+++ linux-2.5.69/include/asm-mips/ptrace.h	2003-05-15 15:16:34.000000000 +0200
@@ -75,6 +75,8 @@ struct pt_regs {
 
 #define instruction_pointer(regs) ((regs)->cp0_epc)
 
+#define force_successful_syscall_return()	do { } while (0)
+
 extern void show_regs(struct pt_regs *);
 #endif /* !(_LANGUAGE_ASSEMBLY) */
 
--- linux-2.5.69/include/asm-mips64/hw_irq.h.~1~	2003-05-05 01:53:03.000000000 +0200
+++ linux-2.5.69/include/asm-mips64/hw_irq.h	2003-05-15 15:04:25.000000000 +0200
@@ -3,3 +3,5 @@
 
    Everything of consequence is in arch/alpha/kernel/irq_impl.h,
    to be used only in arch/alpha/kernel/.  */
+
+extern irq_desc_t irq_desc [NR_IRQS];
--- linux-2.5.69/include/asm-mips64/ptrace.h.~1~	2003-05-05 01:53:41.000000000 +0200
+++ linux-2.5.69/include/asm-mips64/ptrace.h	2003-05-15 15:12:40.000000000 +0200
@@ -74,6 +74,7 @@ struct pt_regs {
 
 #ifndef _LANGUAGE_ASSEMBLY
 #define instruction_pointer(regs) ((regs)->cp0_epc)
+#define force_successful_syscall_return()	do { } while (0)
 
 extern void (*_show_regs)(struct pt_regs *);
 #define show_regs(regs)	_show_regs(regs)
--- linux-2.5.69/include/asm-parisc/hw_irq.h.~1~	2003-05-05 01:53:08.000000000 +0200
+++ linux-2.5.69/include/asm-parisc/hw_irq.h	2003-05-15 15:05:43.000000000 +0200
@@ -14,4 +14,6 @@
 
 #include <asm/irq.h>
 
+extern irq_desc_t irq_desc [NR_IRQS];
+
 #endif
--- linux-2.5.69/include/asm-parisc/ptrace.h.~1~	2003-05-05 01:53:14.000000000 +0200
+++ linux-2.5.69/include/asm-parisc/ptrace.h	2003-05-15 15:13:09.000000000 +0200
@@ -48,6 +48,7 @@ struct pt_regs {
 /* XXX should we use iaoq[1] or iaoq[0] ? */
 #define user_mode(regs)			(((regs)->iaoq[0] &  3) ? 1 : 0)
 #define instruction_pointer(regs)	((regs)->iaoq[0] & ~3)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 #endif
 
--- linux-2.5.69/include/asm-ppc/hw_irq.h.~1~	2003-05-05 01:53:35.000000000 +0200
+++ linux-2.5.69/include/asm-ppc/hw_irq.h	2003-05-15 15:09:43.000000000 +0200
@@ -71,6 +71,8 @@ extern void do_lost_interrupts(unsigned 
 struct hw_interrupt_type;
 static inline void hw_resend_irq(struct hw_interrupt_type *h, unsigned int i) {}
 
+extern irq_desc_t irq_desc [NR_IRQS];
+
 
 #endif /* _PPC_HW_IRQ_H */
 #endif /* __KERNEL__ */
--- linux-2.5.69/include/asm-ppc/ptrace.h.~1~	2003-05-05 01:53:31.000000000 +0200
+++ linux-2.5.69/include/asm-ppc/ptrace.h	2003-05-15 15:18:40.000000000 +0200
@@ -48,6 +48,7 @@ struct pt_regs {
 #ifndef __ASSEMBLY__
 #define instruction_pointer(regs) ((regs)->nip)
 #define user_mode(regs) (((regs)->msr & MSR_PR) != 0)
+#define force_successful_syscall_return()	do { } while (0)
 
 /*
  * We use the least-significant bit of the trap field to indicate
--- linux-2.5.70/include/asm-ppc/system.h.~1~	2003-05-27 03:00:39.000000000 +0200
+++ linux-2.5.70/include/asm-ppc/system.h	2003-06-11 16:23:46.000000000 +0200
@@ -6,10 +6,10 @@
 
 #include <linux/config.h>
 #include <linux/kdev_t.h>
+#include <linux/irq.h>
 
 #include <asm/processor.h>
 #include <asm/atomic.h>
-#include <asm/hw_irq.h>
 
 /*
  * Memory barrier.
--- linux-2.5.69/include/asm-ppc64/hw_irq.h.~1~	2003-05-05 01:53:55.000000000 +0200
+++ linux-2.5.69/include/asm-ppc64/hw_irq.h	2003-05-15 15:07:27.000000000 +0200
@@ -81,5 +81,7 @@ static inline void __do_save_and_cli(uns
 struct hw_interrupt_type;
 static inline void hw_resend_irq(struct hw_interrupt_type *h, unsigned int i) {}
  
+extern irq_desc_t irq_desc [NR_IRQS];
+
 #endif /* _PPC64_HW_IRQ_H */
 #endif /* __KERNEL__ */
--- linux-2.5.69/include/asm-ppc64/ptrace.h.~1~	2003-05-05 01:53:35.000000000 +0200
+++ linux-2.5.69/include/asm-ppc64/ptrace.h	2003-05-15 15:14:31.000000000 +0200
@@ -71,6 +71,7 @@ struct pt_regs32 {
 
 #define instruction_pointer(regs) ((regs)->nip)
 #define user_mode(regs) ((((regs)->msr) >> MSR_PR_LG) & 0x1)
+#define force_successful_syscall_return()	do { } while (0)
 
 /*
  * Offsets used by 'ptrace' system call interface.
--- linux-2.5.69/include/asm-s390/ptrace.h.~1~	2003-05-05 01:53:35.000000000 +0200
+++ linux-2.5.69/include/asm-s390/ptrace.h	2003-05-15 15:17:03.000000000 +0200
@@ -458,6 +458,7 @@ struct user_regs_struct
 #ifdef __KERNEL__
 #define user_mode(regs) (((regs)->psw.mask & PSW_MASK_PSTATE) != 0)
 #define instruction_pointer(regs) ((regs)->psw.addr & PSW_ADDR_INSN)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs * regs);
 #endif
 
--- linux-2.5.69/include/asm-sh/hw_irq.h.~1~	2003-05-05 01:53:33.000000000 +0200
+++ linux-2.5.69/include/asm-sh/hw_irq.h	2003-05-15 15:01:08.000000000 +0200
@@ -3,4 +3,7 @@
 static __inline__ void sh_do_profile (unsigned long pc) {/*Not implemented yet*/}
 
 static __inline__ void hw_resend_irq(struct hw_interrupt_type *h, unsigned int i) { /* Nothing to do */ }
+
+extern irq_desc_t irq_desc [NR_IRQS];
+
 #endif /* __ASM_SH_HW_IRQ_H */
--- linux-2.5.69/include/asm-sh/ptrace.h.~1~	2003-05-05 01:53:40.000000000 +0200
+++ linux-2.5.69/include/asm-sh/ptrace.h	2003-05-15 15:12:12.000000000 +0200
@@ -64,6 +64,7 @@ struct pt_regs {
 #ifdef __KERNEL__
 #define user_mode(regs) (((regs)->sr & 0x40000000)==0)
 #define instruction_pointer(regs) ((regs)->pc)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 
 /* User Break Controller */
--- linux-2.5.69/include/asm-sparc/ptrace.h.~1~	2003-05-05 01:53:41.000000000 +0200
+++ linux-2.5.69/include/asm-sparc/ptrace.h	2003-05-15 15:15:01.000000000 +0200
@@ -62,6 +62,7 @@ struct sparc_stackf {
 #ifdef __KERNEL__
 #define user_mode(regs) (!((regs)->psr & PSR_PS))
 #define instruction_pointer(regs) ((regs)->pc)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 #endif
 
--- linux-2.5.69/include/asm-sparc64/ptrace.h.~1~	2003-05-05 01:53:32.000000000 +0200
+++ linux-2.5.69/include/asm-sparc64/ptrace.h	2003-05-15 15:19:09.000000000 +0200
@@ -96,6 +96,7 @@ struct sparc_trapf {
 #ifdef __KERNEL__
 #define user_mode(regs) (!((regs)->tstate & TSTATE_PRIV))
 #define instruction_pointer(regs) ((regs)->tpc)
+#define force_successful_syscall_return()	do { } while (0)
 extern void show_regs(struct pt_regs *);
 #endif
 
--- linux-2.5.69/include/asm-um/hw_irq.h.~1~	2003-05-05 01:52:49.000000000 +0200
+++ linux-2.5.69/include/asm-um/hw_irq.h	2003-05-15 15:03:15.000000000 +0200
@@ -7,4 +7,6 @@
 static inline void hw_resend_irq(struct hw_interrupt_type *h, unsigned int i)
 {}
 
+extern irq_desc_t irq_desc [NR_IRQS];
+
 #endif
--- linux-2.5.69/include/asm-v850/hw_irq.h.~1~	2003-05-05 01:53:40.000000000 +0200
+++ linux-2.5.69/include/asm-v850/hw_irq.h	2003-05-15 15:10:23.000000000 +0200
@@ -5,4 +5,6 @@ extern inline void hw_resend_irq (struct
 {
 }
 
+extern irq_desc_t irq_desc [NR_IRQS];
+
 #endif /* __V850_HW_IRQ_H__ */
--- linux-2.5.69/include/asm-v850/ptrace.h.~1~	2003-05-05 01:53:57.000000000 +0200
+++ linux-2.5.69/include/asm-v850/ptrace.h	2003-05-15 15:17:31.000000000 +0200
@@ -77,6 +77,7 @@ struct pt_regs
 
 #define instruction_pointer(regs)	((regs)->pc)
 #define user_mode(regs)			(!(regs)->kernel_mode)
+#define force_successful_syscall_return()	do { } while (0)
 
 /* When a struct pt_regs is used to save user state for a system call in
    the kernel, the system call is stored in the space for R0 (since it's
--- linux-2.5.69/include/asm-x86_64/hw_irq.h.~1~	2003-05-05 01:53:42.000000000 +0200
+++ linux-2.5.69/include/asm-x86_64/hw_irq.h	2003-05-15 14:40:56.000000000 +0200
@@ -173,6 +173,8 @@ static inline void hw_resend_irq(struct 
 static inline void hw_resend_irq(struct hw_interrupt_type *h, unsigned int i) {}
 #endif
 
+extern irq_desc_t irq_desc [NR_IRQS];
+
 #endif
 
 #endif /* _ASM_HW_IRQ_H */
--- linux-2.5.69/include/asm-x86_64/ptrace.h.~1~	2003-05-05 01:53:08.000000000 +0200
+++ linux-2.5.69/include/asm-x86_64/ptrace.h	2003-05-15 14:57:27.000000000 +0200
@@ -87,6 +87,7 @@ struct pt_regs {
 #if defined(__KERNEL__) && !defined(__ASSEMBLY__) 
 #define user_mode(regs) (!!((regs)->cs & 3))
 #define instruction_pointer(regs) ((regs)->rip)
+#define force_successful_syscall_return()	do { } while (0)
 void signal_fault(struct pt_regs *regs, void *frame, char *where);
 
 enum {
