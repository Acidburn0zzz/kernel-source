diff -p -purN linuxppc-2.5-benh-latest/drivers/scsi/libata-core.c linuxppc-2.5-benh-latest.fixup/drivers/scsi/libata-core.c
--- linuxppc-2.5-benh-latest/drivers/scsi/libata-core.c	2004-02-07 16:33:45.000000000 +0100
+++ linuxppc-2.5-benh-latest.fixup/drivers/scsi/libata-core.c	2004-02-07 22:19:24.000000000 +0100
@@ -39,6 +39,7 @@
 #include "hosts.h"
 #include <linux/libata.h>
 #include <asm/io.h>
+#include <linux/ide.h>
 #include <asm/semaphore.h>
 
 #include "libata.h"
diff -p -purN linuxppc-2.5-benh-latest/fs/hfs/mdb.c linuxppc-2.5-benh-latest.fixup/fs/hfs/mdb.c
--- linuxppc-2.5-benh-latest/fs/hfs/mdb.c	2003-12-24 04:48:17.000000000 +0100
+++ linuxppc-2.5-benh-latest.fixup/fs/hfs/mdb.c	2004-02-06 20:03:29.000000000 +0100
@@ -40,28 +40,6 @@ static int hfs_get_last_session(struct s
 	/* default values */
 	*start = 0;
 	*size = sb->s_bdev->bd_inode->i_size >> 9;
-	{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		struct gendisk *gd = get_gendisk(sb->s_bdev->bd_inode->i_rdev);
-		if (gd && gd->part) {
-			printk("size: %ld,%ld\n", *size,
-				gd->part[MINOR(sb->s_bdev->bd_inode->i_rdev)].nr_sects);
-			*size = gd->part[MINOR(sb->s_bdev->bd_inode->i_rdev)].nr_sects;
-		}
-#else
-		int part;
-		struct gendisk *gd = get_gendisk(sb->s_bdev->bd_inode->i_rdev, &part);
-		if (gd && part && gd->part) {
-			printk("size: %ld,%ld\n", *size,
-				gd->part[part-1]->nr_sects);
-			//*size = gd->part[part-1]->nr_sects;
-		} else if (gd && !part) {
-			printk("size: %d,%ld,%ld\n", part, *size,
-				gd->capacity);
-		}
-		put_disk(gd);
-#endif
-	}
 
 	if (HFS_SB(sb)->session >= 0) {
 		te.cdte_track = HFS_SB(sb)->session;
diff -p -purN linuxppc-2.5-benh-latest/fs/hfsplus/wrapper.c linuxppc-2.5-benh-latest.fixup/fs/hfsplus/wrapper.c
--- linuxppc-2.5-benh-latest/fs/hfsplus/wrapper.c	2003-11-01 03:03:55.000000000 +0100
+++ linuxppc-2.5-benh-latest.fixup/fs/hfsplus/wrapper.c	2004-02-06 20:03:13.000000000 +0100
@@ -61,28 +61,6 @@ static int hfsplus_get_last_session(stru
 	/* default values */
 	*start = 0;
 	*size = sb->s_bdev->bd_inode->i_size >> 9;
-	{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		struct gendisk *gd = get_gendisk(sb->s_bdev->bd_inode->i_rdev);
-		if (gd && gd->part) {
-			printk("size: %ld,%ld\n", *size,
-				gd->part[MINOR(sb->s_bdev->bd_inode->i_rdev)].nr_sects);
-			*size = gd->part[MINOR(sb->s_bdev->bd_inode->i_rdev)].nr_sects;
-		}
-#else
-		int part;
-		struct gendisk *gd = get_gendisk(sb->s_bdev->bd_inode->i_rdev, &part);
-		if (gd && part && gd->part) {
-			printk("size: %d,%ld,%ld\n", part, *size,
-				gd->part[part-1]->nr_sects);
-			//*size = gd->part[part-1]->nr_sects;
-		} else if (gd && !part) {
-			printk("size: %d,%ld,%ld\n", part, *size,
-				gd->capacity);
-		}
-		put_disk(gd);
-#endif
-	}
 
 	if (HFSPLUS_SB(sb).session >= 0) {
 		te.cdte_track = HFSPLUS_SB(sb).session;
diff -p -purN linuxppc-2.5-benh-latest/include/linux/fb.h linuxppc-2.5-benh-latest.fixup/include/linux/fb.h
--- linuxppc-2.5-benh-latest/include/linux/fb.h	2004-02-07 16:58:37.000000000 +0100
+++ linuxppc-2.5-benh-latest.fixup/include/linux/fb.h	2004-02-07 22:35:28.000000000 +0100
@@ -340,6 +340,42 @@ struct fb_info;
 struct device;
 struct file;
 
+	/*
+	 * Framebuffer clients. Currently, this is only used
+	 * by fbcon to get notified of events on the framebuffer,
+	 * though that should be extended to the userland interface
+	 * some way.
+	 * 
+	 * We should also add more callbacks to better deal with
+	 * hotplug displays (add/removal notification). This is
+	 * not to replaced by a device class, though it could be
+	 * wrapped in a device interface according to the driver
+	 * model, I have to think more about it.
+	 * 
+	 * Locking rules: The callback should not take the console
+	 * semaphore explicitely (call acquire_console_sem()) as it
+	 * will typically already be owned.
+	 * 
+	 */ 
+struct fb_client_ops {	
+	struct module *owner;
+
+	/* Userland initiated mode change */
+	void	(*mode_changed)(void *data, struct fb_info *info);
+	/* The device is beeing suspended, do not access from
+	 * that point
+	 */
+	void	(*suspended)(void *data, struct fb_info *info);
+	/* The device is back to life, refresh screen
+	 */
+	void	(*resumed)(void *data, struct fb_info *info);
+};
+
+struct fb_client {
+	struct list_head	link;
+	struct fb_client_ops	*ops;
+	void			*data;
+};
 /*
  * Pixmap structure definition
  *
