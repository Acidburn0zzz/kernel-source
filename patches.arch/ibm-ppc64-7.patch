ChangeSet
  1.1530.1.2 04/03/30 14:23:38 dgibson@wocket.ozlabs.ibm.com +2 -0
  Rearrange code in iseries_veth driver to group logically related functions
  together, etc.  Makes further cleanup patches easier to follow.

  drivers/net/iseries_veth.h
    1.7 04/03/30 14:23:10 dgibson@wocket.ozlabs.ibm.com +0 -82
    Rearrange code in iseries_veth driver to group logically related functions
    together, etc.  Makes further cleanup patches easier to follow.

  drivers/net/iseries_veth.c
    1.13.1.2 04/03/30 14:23:10 dgibson@wocket.ozlabs.ibm.com +654 -575
    Rearrange code in iseries_veth driver to group logically related functions
    together, etc.  Makes further cleanup patches easier to follow.

diff -Nru a/drivers/net/iseries_veth.c b/drivers/net/iseries_veth.c
--- a/drivers/net/iseries_veth.c	Tue Mar 30 09:07:15 2004
+++ b/drivers/net/iseries_veth.c	Tue Mar 30 09:07:15 2004
@@ -82,13 +82,15 @@
 
 extern struct pci_dev *iSeries_veth_dev;
 
-#define veth_printk(prio, fmt, args...) \
-	printk(prio "%s: " fmt, __FILE__, ## args)
-
-#define veth_error(fmt, args...) \
-	printk(KERN_ERR "(%s:%3.3d) ERROR: " fmt, __FILE__, __LINE__ , ## args)
+MODULE_AUTHOR("Kyle Lucke <klucke@us.ibm.com>");
+MODULE_DESCRIPTION("iSeries Virtual ethernet driver");
+MODULE_LICENSE("GPL");
 
 #define VETH_NUMBUFFERS		120
+#define VETH_ACKTIMEOUT 	(1000000) /* microseconds */
+#define VETH_MAX_MCAST		(12)
+
+#define VETH_MAX_MTU		9000
 
 #if VETH_NUMBUFFERS < 10
 #define ACK_THRESHOLD 1
@@ -100,39 +102,6 @@
 #define ACK_THRESHOLD 20
 #endif
 
-static int veth_open(struct net_device *dev);
-static int veth_close(struct net_device *dev);
-static int veth_start_xmit(struct sk_buff *skb, struct net_device *dev);
-static int veth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
-static void veth_handle_event(struct HvLpEvent *, struct pt_regs *);
-static void veth_handle_ack(struct VethLpEvent *);
-static void veth_handle_int(struct VethLpEvent *);
-static void veth_init_connection(struct veth_lpar_connection *cnx, u8 rlp);
-static void veth_statemachine(void *p);
-static void veth_close_connection(u8);
-static void veth_set_multicast_list(struct net_device *dev);
-static void veth_flush_pending(struct veth_lpar_connection *cnx);
-
-static void veth_take_cap(struct veth_lpar_connection *, struct VethLpEvent *);
-static void veth_take_cap_ack(struct veth_lpar_connection *, struct VethLpEvent *);
-static void veth_take_monitor_ack(struct veth_lpar_connection *,
-				  struct VethLpEvent *);
-static void veth_recycle_msg(struct veth_lpar_connection *, struct veth_msg *);
-static void veth_receive(struct veth_lpar_connection *, struct VethLpEvent *);
-static struct net_device_stats *veth_get_stats(struct net_device *dev);
-static int veth_change_mtu(struct net_device *dev, int new_mtu);
-static void veth_timed_ack(unsigned long connectionPtr);
-
-static struct VethFabricMgr *mFabricMgr; /* = NULL */
-static struct net_device *veth_devices[HVMAXARCHITECTEDVIRTUALLANS];
-static int veth_num_devices; /* = 0 */
-
-#define VETH_MAX_MTU		9000
-
-MODULE_AUTHOR("Kyle Lucke <klucke@us.ibm.com>");
-MODULE_DESCRIPTION("iSeries Virtual ethernet driver");
-MODULE_LICENSE("GPL");
-
 #define	VETH_STATE_SHUTDOWN	(0x0001)
 #define VETH_STATE_OPEN		(0x0002)
 #define VETH_STATE_RESET	(0x0004)
@@ -143,6 +112,106 @@
 #define VETH_STATE_SENTCAPACK	(0x0080)
 #define VETH_STATE_READY	(0x0100)
 
+#define VETHSTACK(T) \
+	struct VethStack##T { \
+		struct T *head; \
+		spinlock_t lock; \
+	}
+#define VETHSTACKPUSH(s, p) \
+	do { \
+		unsigned long flags; \
+		spin_lock_irqsave(&(s)->lock,flags); \
+		(p)->next = (s)->head; \
+		(s)->head = (p); \
+		spin_unlock_irqrestore(&(s)->lock, flags); \
+	} while (0)
+
+#define VETHSTACKPOP(s,p) \
+	do { \
+		unsigned long flags; \
+		spin_lock_irqsave(&(s)->lock,flags); \
+		(p) = (s)->head; \
+		if ((s)->head) \
+			(s)->head = (s)->head->next; \
+		spin_unlock_irqrestore(&(s)->lock, flags); \
+	} while (0)
+
+struct veth_msg {
+	struct veth_msg *next;
+	struct VethFramesData data;
+	int token;
+	unsigned long in_use;
+	struct sk_buff *skb;
+};
+
+struct veth_lpar_connection {
+	HvLpIndex remote_lp;
+	struct work_struct statemachine_wq;
+	struct veth_msg *msgs;
+	int mNumberAllocated;
+	int mNumberRcvMsgs;
+	struct VethCapData local_caps;
+
+	struct timer_list ack_timer;
+
+	spinlock_t lock;
+	unsigned long state;
+	HvLpInstanceId src_inst;
+	HvLpInstanceId dst_inst;
+	struct VethLpEvent cap_event, cap_ack_event;
+	u16 pending_acks[VETH_MAX_ACKS_PER_MSG];
+	u32 num_pending_acks;
+
+	int mNumberLpAcksAlloced;
+	struct VethCapData remote_caps;
+	u32 ack_timeout;
+
+	VETHSTACK(veth_msg) msg_stack;
+};
+
+struct veth_port {
+	struct net_device_stats stats;
+	u64 mac_addr;
+	HvLpIndexMap lpar_map;
+
+	spinlock_t pending_gate;
+	struct sk_buff *pending_skb;
+	HvLpIndexMap pending_lpmask;
+
+	rwlock_t mcast_gate;
+	int promiscuous;
+	int all_mcast;
+	int num_mcast;
+	u64 mcast_addr[VETH_MAX_MCAST];
+};
+
+struct VethFabricMgr {
+	HvLpIndex this_lp;
+	struct veth_lpar_connection connection[HVMAXARCHITECTEDLPS];
+	struct net_device *netdev[HVMAXARCHITECTEDVIRTUALLANS];
+};
+
+static struct VethFabricMgr *mFabricMgr; /* = NULL */
+static struct net_device *veth_devices[HVMAXARCHITECTEDVIRTUALLANS];
+static int veth_num_devices; /* = 0 */
+
+static int veth_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static void veth_recycle_msg(struct veth_lpar_connection *, struct veth_msg *);
+static void veth_flush_pending(struct veth_lpar_connection *cnx);
+static void veth_receive(struct veth_lpar_connection *, struct VethLpEvent *);
+static void veth_timed_ack(unsigned long connectionPtr);
+
+/*
+ * Utility functions
+ */
+
+#define veth_printk(prio, fmt, args...) \
+	printk(prio "%s: " fmt, __FILE__, ## args)
+
+#define veth_error(fmt, args...) \
+	printk(KERN_ERR "(%s:%3.3d) ERROR: " fmt, __FILE__, __LINE__ , ## args)
+
+
 static inline HvLpEvent_Rc 
 veth_signalevent(struct veth_lpar_connection *cnx, u16 subtype, 
 		 HvLpEvent_AckInd ackind, HvLpEvent_AckType acktype,
@@ -198,483 +267,69 @@
 	return vc.num;
 }
 
+/*
+ * LPAR connection code
+ */
+
 static inline void veth_kick_statemachine(struct veth_lpar_connection *cnx)
 {
 	schedule_work(&cnx->statemachine_wq);
 }
 
-struct net_device * __init veth_probe_one(int vlan)
-{
-	struct net_device *dev;
-	struct veth_port *port;
-	int i, rc;
-
-	dev = alloc_etherdev(sizeof (struct veth_port));
-	if (! dev) {
-		veth_error("Unable to allocate net_device structure!\n");
-		return NULL;
-	}
-
-	port = (struct veth_port *) dev->priv;
-
-	spin_lock_init(&port->pending_gate);
-	rwlock_init(&port->mcast_gate);
-
-	for (i = 0; i < HVMAXARCHITECTEDLPS; i++) {
-		HvLpVirtualLanIndexMap map;
-
-		if (i == mFabricMgr->this_lp)
-			continue;
-		map = HvLpConfig_getVirtualLanIndexMapForLp(i);
-		if (map & (0x8000 >> vlan))
-			port->lpar_map |= (1 << i);
-	}
-
-	dev->dev_addr[0] = 0x02;
-	dev->dev_addr[1] = 0x01;
-	dev->dev_addr[2] = 0xff;
-	dev->dev_addr[3] = vlan;
-	dev->dev_addr[4] = 0xff;
-	dev->dev_addr[5] = HvLpConfig_getLpIndex_outline();
-
-	dev->mtu = VETH_MAX_MTU;
-
-	memcpy(&port->mac_addr, dev->dev_addr, 6);
-
-	dev->open = veth_open;
-	dev->hard_start_xmit = veth_start_xmit;
-	dev->stop = veth_close;
-	dev->get_stats = veth_get_stats;
-	dev->change_mtu = veth_change_mtu;
-	dev->set_mac_address = NULL;
-	dev->set_multicast_list = veth_set_multicast_list;
-	dev->do_ioctl = veth_ioctl;
-
-	rc = register_netdev(dev);
-	if (rc != 0) {
-		veth_printk(KERN_ERR,
-			    "Failed to register an ethernet device for vlan %d\n",
-			    vlan);
-		free_netdev(dev);
-		return NULL;
-	}
-
-	veth_printk(KERN_DEBUG, "%s attached to iSeries vlan %d (lpar_map=0x%04x)\n",
-		    dev->name, vlan, port->lpar_map);
-
-	return dev;
-}
-
-int __init veth_probe(void)
-{
-	HvLpIndexMap vlan_map = HvLpConfig_getVirtualLanIndexMap();
-	int i;
-
-	memset(veth_devices, 0, sizeof(veth_devices));
-
-	for (i = 0; vlan_map != 0; vlan_map <<= 1, i++) {
-		struct net_device *dev = NULL;
-
-		if (! (vlan_map & 0x8000))
-			continue;
-
-		dev = veth_probe_one(i);
-
-		if (dev) {
-			mFabricMgr->netdev[i] = dev;
-			veth_devices[veth_num_devices] = dev;
-			veth_num_devices++;
-		}
-	}
-
-	if (veth_num_devices == 0)
-		return -ENODEV;
-
-	return 0;
-}
-
-void __exit veth_module_cleanup(void)
-{
-	int i;
-	struct VethFabricMgr *fm = mFabricMgr;
-
-	if (! mFabricMgr)
-		return;
-
-	for (i = 0; i < HVMAXARCHITECTEDLPS; ++i)
-		veth_close_connection(i);
-	
-	HvLpEvent_unregisterHandler(HvLpEvent_Type_VirtualLan);
-	
-	mb();
-	mFabricMgr = NULL;
-	mb();
-	
-	for (i = 0; i < HVMAXARCHITECTEDLPS; ++i) {
-		struct veth_lpar_connection *cnx = &fm->connection[i];
-
-		if (cnx->mNumberAllocated + cnx->mNumberRcvMsgs > 0) {
-			mf_deallocateLpEvents(cnx->remote_lp,
-					      HvLpEvent_Type_VirtualLan,
-					      cnx->mNumberAllocated
-					      + cnx->mNumberRcvMsgs,
-					      NULL, NULL);
-		}
-		
-		if (cnx->msgs)
-			kfree(cnx->msgs);
-	}
-	
-	for (i = 0; i < HVMAXARCHITECTEDVIRTUALLANS; ++i) {
-		struct net_device *dev;
-
-		if (! fm->netdev[i])
-			continue;
-
-		dev = fm->netdev[i];
-		fm->netdev[i] = NULL;
-
-		mb();
-			
-		if (dev) {
-			unregister_netdev(dev);
-			free_netdev(dev);
-		}
-	}
-	
-	kfree(fm);
-}
-
-module_exit(veth_module_cleanup);
-
-int __init veth_module_init(void)
-{
-	int i;
-	int this_lp;
-	int rc;
-
-	mFabricMgr = kmalloc(sizeof (struct VethFabricMgr), GFP_KERNEL);
-	if (! mFabricMgr) {
-		veth_error("Unable to allocate fabric manager\n");
-		return -ENOMEM;
-	}
-
-	memset(mFabricMgr, 0, sizeof (*mFabricMgr));
-
-	this_lp = HvLpConfig_getLpIndex_outline();
-	mFabricMgr->this_lp = this_lp;
-
-	for (i = 0; i < HVMAXARCHITECTEDLPS; ++i) {
-		struct veth_lpar_connection *cnx = &mFabricMgr->connection[i];
-
-		veth_init_connection(cnx, i);
-	}
-
-	rc = veth_probe();
-	if (rc != 0) {
-		veth_module_cleanup();
-		return rc;
-	}
-
-	HvLpEvent_registerHandler(HvLpEvent_Type_VirtualLan, &veth_handle_event);
-
-	/* Run through the active lps and open connections to the ones
-	 * we need to */
-	/* FIXME: is there any reason to do this backwards? */
-	for (i = HVMAXARCHITECTEDLPS - 1; i >= 0; --i) {
-		struct veth_lpar_connection *cnx = &mFabricMgr->connection[i];
-
-		if ( (i == this_lp) 
-		     || ! HvLpConfig_doLpsCommunicateOnVirtualLan(this_lp, i) )
-			continue;
-
-		veth_kick_statemachine(cnx);
-	}
-
-	return 0;
-}
-
-module_init(veth_module_init);
-
-static int veth_open(struct net_device *dev)
-{
-	struct veth_port *port = (struct veth_port *) dev->priv;
-
-	memset(&port->stats, 0, sizeof (port->stats));
-
-	netif_start_queue(dev);
-
-	return 0;
-}
-
-static int veth_close(struct net_device *dev)
-{
-	netif_stop_queue(dev);
-
-	return 0;
-}
-
-static struct net_device_stats *veth_get_stats(struct net_device *dev)
-{
-	struct veth_port *port = (struct veth_port *) dev->priv;
-
-	return &port->stats;
-}
-
-static int veth_change_mtu(struct net_device *dev, int new_mtu)
-{
-	if ((new_mtu < 68) || (new_mtu > VETH_MAX_MTU))
-		return -EINVAL;
-	dev->mtu = new_mtu;
-	return 0;
-}
-
-static int veth_transmit_to_one(struct sk_buff *skb, HvLpIndex rlp,
-				struct net_device *dev)
+static void veth_take_cap(struct veth_lpar_connection *cnx,
+			  struct VethLpEvent *event)
 {
-	struct veth_lpar_connection *cnx = mFabricMgr->connection + rlp;
-	HvLpEvent_Rc rc;
-	u32 dma_address, dma_length;
-	struct veth_msg *msg = NULL;
-	int err = 2;
 	unsigned long flags;
 
 	spin_lock_irqsave(&cnx->lock, flags);
+	/* Receiving caps may mean the other end has just come up, so
+	 * we need to reload the instance ID of the far end */
+	cnx->dst_inst =
+		HvCallEvent_getTargetLpInstanceId(cnx->remote_lp,
+						  HvLpEvent_Type_VirtualLan);
 
-	if (! cnx->state & VETH_STATE_READY)
-		goto out;
-
-	if ((skb->len - 14) > VETH_MAX_MTU)
-		goto out;
-
-	VETHSTACKPOP(&cnx->msg_stack, msg);
-
-	if (! msg) {
-		err = 1;
-		goto out;
-	}
-
-	dma_length = skb->len;
-	dma_address = pci_map_single(iSeries_veth_dev, skb->data,
-				     dma_length, PCI_DMA_TODEVICE);
-	
-	/* Is it really necessary to check the length and address
-	 * fields of the first entry here? */
-	if (!pci_dma_mapping_error(dma_address)) {
-		msg->skb = skb;
-		msg->data.addr[0] = dma_address;
-		msg->data.len[0] = dma_length;
-		msg->data.eof = 1;
-		set_bit(0, &(msg->in_use));
-		rc = veth_signaldata(cnx, VethEventTypeFrames,
-				     msg->token, &msg->data);
-	} else {
-		struct veth_port *port = (struct veth_port *) dev->priv;
-		rc = -1;	/* Bad return code */
-		port->stats.tx_errors++;
-	}
-
-	if (rc != HvLpEvent_Rc_Good) {
-		msg->skb = NULL;
-		/* need to set in use to make veth_recycle_msg in case
-		 * this was a mapping failure */
-		set_bit(0, &msg->in_use);
-		veth_recycle_msg(cnx, msg);
+	if (cnx->state & VETH_STATE_GOTCAPS) {
+		veth_error("Received a second capabilities from lpar %d\n",
+			   cnx->remote_lp);
+		event->base_event.xRc = HvLpEvent_Rc_BufferNotAvailable;
+		HvCallEvent_ackLpEvent((struct HvLpEvent *) event);
 	} else {
-		err = 0;
+		memcpy(&cnx->cap_event, event, sizeof(cnx->cap_event));
+		cnx->state |= VETH_STATE_GOTCAPS;
+		veth_kick_statemachine(cnx);
 	}
-
- out:
 	spin_unlock_irqrestore(&cnx->lock, flags);
-	
-	return err;
 }
 
-static HvLpIndexMap veth_transmit_to_many(struct sk_buff *skb,
-					  HvLpIndexMap lpmask,
-					  struct net_device *dev)
-{
-	struct veth_port *port = (struct veth_port *) dev->priv;
-	int i;
-	int rc;
-
-	for (i = 0; i < HVMAXARCHITECTEDLPS; i++) {
-		struct sk_buff *clone;
-
-		if (! lpmask & (1<<i))
-			continue;
-		
-		clone = skb_clone(skb, GFP_ATOMIC);
-
-		if (! clone) {
-			veth_error("%s: skb_clone failed %p\n",
-				   dev->name, skb);
-			continue;
-		}
-		/* the ack handles deleting the skb */
-		rc = veth_transmit_to_one(clone, i, dev);
-		
-		/* tx failed, we need to free the skb */
-		if (rc != 0)
-			dev_kfree_skb(clone);
-			
-		/* if we didn't fail from lack of buffers, the tx as a
-		 * whole is successful */
-		if (rc != 1)
-			lpmask &= ~(1<<i);
-	}
-
-	if (! lpmask) {
-		port->stats.tx_packets++;
-		port->stats.tx_bytes += skb->len;
-	}
-
-	return lpmask;
-}
-
-static int veth_start_xmit(struct sk_buff *skb, struct net_device *dev)
+static void veth_take_cap_ack(struct veth_lpar_connection *cnx,
+			      struct VethLpEvent *event)
 {
-	unsigned char *frame = skb->data;
-	struct veth_port *port = (struct veth_port *) dev->priv;
 	unsigned long flags;
-	HvLpIndexMap lpmask;
 
-	BUG_ON(! mFabricMgr);
-
-	if (! (frame[0] & 0x01)) {
-		/* unicast packet */
-		HvLpIndex rlp = frame[5];
-
-		if ( ! ((1 << rlp) & port->lpar_map) ) {
-			dev_kfree_skb(skb);
-			return 0;
-		}
-
-		lpmask = 1 << rlp;
+	spin_lock_irqsave(&cnx->lock, flags);
+	if (cnx->state & VETH_STATE_GOTCAPACK) {
+		veth_error("Received a second capabilities ack from lpar %d\n",
+			   cnx->remote_lp);
 	} else {
-		lpmask = port->lpar_map;
-	}
-
-	lpmask = veth_transmit_to_many(skb, lpmask, dev);
-
-	if (lpmask) {
-		spin_lock_irqsave(&port->pending_gate, flags);
-		if (port->pending_skb) {
-			veth_error("%s: Tx while skb was pending!\n", dev->name);
-			dev_kfree_skb(skb);
-			return 1;
-		}
-
-		port->pending_skb = skb;
-		port->pending_lpmask = lpmask;
-		netif_stop_queue(dev);
-
-		spin_unlock_irqrestore(&port->pending_gate, flags);
-	}
-
-	dev_kfree_skb(skb);
-	return 0;
-}
-
-static int veth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
-{
-#ifdef SIOCETHTOOL
-	struct ethtool_cmd ecmd;
-
-	if (cmd != SIOCETHTOOL)
-		return -EOPNOTSUPP;
-	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof (ecmd)))
-		return -EFAULT;
-	switch (ecmd.cmd) {
-	case ETHTOOL_GSET:
-		ecmd.supported = (SUPPORTED_1000baseT_Full
-				  | SUPPORTED_Autoneg | SUPPORTED_FIBRE);
-		ecmd.advertising = (SUPPORTED_1000baseT_Full
-				    | SUPPORTED_Autoneg | SUPPORTED_FIBRE);
-
-		ecmd.port = PORT_FIBRE;
-		ecmd.transceiver = XCVR_INTERNAL;
-		ecmd.phy_address = 0;
-		ecmd.speed = SPEED_1000;
-		ecmd.duplex = DUPLEX_FULL;
-		ecmd.autoneg = AUTONEG_ENABLE;
-		ecmd.maxtxpkt = 120;
-		ecmd.maxrxpkt = 120;
-		if (copy_to_user(ifr->ifr_data, &ecmd, sizeof(ecmd)))
-			return -EFAULT;
-		return 0;
-
-	case ETHTOOL_GDRVINFO:{
-			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
-			strncpy(info.driver, "veth", sizeof(info.driver) - 1);
-			info.driver[sizeof(info.driver) - 1] = '\0';
-			strncpy(info.version, "1.0", sizeof(info.version) - 1);
-			if (copy_to_user(ifr->ifr_data, &info, sizeof(info)))
-				return -EFAULT;
-			return 0;
-		}
-		/* get link status */
-	case ETHTOOL_GLINK:{
-			struct ethtool_value edata = { ETHTOOL_GLINK };
-			edata.data = 1;
-			if (copy_to_user(ifr->ifr_data, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-
-	default:
-		break;
+		memcpy(&cnx->cap_ack_event, event,
+		       sizeof(&cnx->cap_ack_event));
+		cnx->state |= VETH_STATE_GOTCAPACK;
+		veth_kick_statemachine(cnx);
 	}
-
-#endif
-	return -EOPNOTSUPP;
+	spin_unlock_irqrestore(&cnx->lock, flags);
 }
 
-static void veth_set_multicast_list(struct net_device *dev)
+static void veth_take_monitor_ack(struct veth_lpar_connection *cnx,
+				  struct VethLpEvent *event)
 {
-	struct veth_port *port = (struct veth_port *) dev->priv;
 	unsigned long flags;
 
-	write_lock_irqsave(&port->mcast_gate, flags);
-
-	if (dev->flags & IFF_PROMISC) {	/* set promiscuous mode */
-		printk(KERN_INFO "%s: Promiscuous mode enabled.\n",
-		       dev->name);
-		port->promiscuous = 1;
-	} else if ( (dev->flags & IFF_ALLMULTI)
-		    || (dev->mc_count > VETH_MAX_MCAST) ) {
-		port->all_mcast = 1;
-	} else {
-		struct dev_mc_list *dmi = dev->mc_list;
-		int i;
-
-		/* Update table */
-		port->num_mcast = 0;
-		
-		for (i = 0; i < dev->mc_count; i++) {
-			u8 *addr = dmi->dmi_addr;
-			u64 xaddr = 0;
-
-			if (addr[0] & 0x01) {/* multicast address? */
-				memcpy(&xaddr, addr, ETH_ALEN);
-				port->mcast_addr[port->num_mcast] = xaddr;
-				port->num_mcast++;
-			}
-			dmi = dmi->next;
-		}
-	}
-
-	write_unlock_irqrestore(&port->mcast_gate, flags);
-}
-
-static void veth_handle_event(struct HvLpEvent *event, struct pt_regs *regs)
-{
-	struct VethLpEvent *veth_event = (struct VethLpEvent *)event;
-
-	if (event->xFlags.xFunction == HvLpEvent_Function_Ack)
-		veth_handle_ack(veth_event);
-	else if (event->xFlags.xFunction == HvLpEvent_Function_Int)
-		veth_handle_int(veth_event);
+	spin_lock_irqsave(&cnx->lock, flags);
+	veth_printk(KERN_DEBUG, "Monitor ack returned for lpar %d\n",
+		    cnx->remote_lp);
+	cnx->state |= VETH_STATE_RESET;
+	veth_kick_statemachine(cnx);
+	spin_unlock_irqrestore(&cnx->lock, flags);
 }
 
 static void veth_handle_ack(struct VethLpEvent *event)
@@ -730,58 +385,14 @@
 	};
 }
 
-static void veth_init_connection(struct veth_lpar_connection *cnx, u8 rlp)
+static void veth_handle_event(struct HvLpEvent *event, struct pt_regs *regs)
 {
-	struct veth_msg *msgs;
-	HvLpIndex this_lp = mFabricMgr->this_lp;
-	int i;
-
-	cnx->state = 0;
-
-	cnx->remote_lp = rlp;
-
-	spin_lock_init(&cnx->lock);
-
-	INIT_WORK(&cnx->statemachine_wq, veth_statemachine, cnx);
-
-	init_timer(&cnx->ack_timer);
-	cnx->ack_timer.function = veth_timed_ack;
-	cnx->ack_timer.data = (unsigned long) cnx;
-	memset(&cnx->pending_acks, 0xff, sizeof (cnx->pending_acks));
-	cnx->num_pending_acks = 0;
-
-	if ( (rlp == this_lp) 
-	     || ! HvLpConfig_doLpsCommunicateOnVirtualLan(this_lp, rlp) )
-		return;
-
-	msgs = kmalloc(VETH_NUMBUFFERS * sizeof(struct veth_msg), GFP_KERNEL);
-	if (! msgs)
-		return;
-
-	cnx->msgs = msgs;
-	memset(msgs, 0, VETH_NUMBUFFERS * sizeof(struct veth_msg));
-	spin_lock_init(&cnx->msg_stack.lock);
-
-	for (i = 0; i < VETH_NUMBUFFERS; i++) {
-		msgs[i].token = i;
-		VETHSTACKPUSH(&cnx->msg_stack, msgs + i);
-	}
-
-	cnx->mNumberAllocated = veth_allocate_events(rlp, 2);
-
-	if (cnx->mNumberAllocated < 2) {
-		veth_error("Couldn't allocate base msgs for lpar %d, only got %d\n",
-			   cnx->remote_lp, cnx->mNumberAllocated);
-		/* FIXME: break, somehow */
-		return;
-	}
-
-	cnx->mNumberRcvMsgs = veth_allocate_events(cnx->remote_lp,
-						   VETH_NUMBUFFERS);
+	struct VethLpEvent *veth_event = (struct VethLpEvent *)event;
 
-	cnx->local_caps.num_buffers = VETH_NUMBUFFERS;
-	cnx->local_caps.ack_threshold = ACK_THRESHOLD;
-	cnx->local_caps.ack_timeout = VETH_ACKTIMEOUT;
+	if (event->xFlags.xFunction == HvLpEvent_Function_Ack)
+		veth_handle_ack(veth_event);
+	else if (event->xFlags.xFunction == HvLpEvent_Function_Int)
+		veth_handle_int(veth_event);
 }
 
 static int veth_process_caps(struct veth_lpar_connection *cnx)
@@ -979,6 +590,57 @@
 	spin_unlock_irq(&cnx->lock);
 }
 
+static void veth_init_connection(struct veth_lpar_connection *cnx, u8 rlp)
+{
+	struct veth_msg *msgs;
+	HvLpIndex this_lp = mFabricMgr->this_lp;
+	int i;
+
+	cnx->state = 0;
+
+	cnx->remote_lp = rlp;
+	spin_lock_init(&cnx->lock);
+	INIT_WORK(&cnx->statemachine_wq, veth_statemachine, cnx);
+	init_timer(&cnx->ack_timer);
+	cnx->ack_timer.function = veth_timed_ack;
+	cnx->ack_timer.data = (unsigned long) cnx;
+	memset(&cnx->pending_acks, 0xff, sizeof (cnx->pending_acks));
+	cnx->num_pending_acks = 0;
+
+	if ( (rlp == this_lp) 
+	     || ! HvLpConfig_doLpsCommunicateOnVirtualLan(this_lp, rlp) )
+		return;
+
+	msgs = kmalloc(VETH_NUMBUFFERS * sizeof(struct veth_msg), GFP_KERNEL);
+	if (! msgs)
+		return;
+
+	cnx->msgs = msgs;
+	memset(msgs, 0, VETH_NUMBUFFERS * sizeof(struct veth_msg));
+	spin_lock_init(&cnx->msg_stack.lock);
+
+	for (i = 0; i < VETH_NUMBUFFERS; i++) {
+		msgs[i].token = i;
+		VETHSTACKPUSH(&cnx->msg_stack, msgs + i);
+	}
+
+	cnx->mNumberAllocated = veth_allocate_events(rlp, 2);
+
+	if (cnx->mNumberAllocated < 2) {
+		veth_error("Couldn't allocate base msgs for lpar %d, only got %d\n",
+			   cnx->remote_lp, cnx->mNumberAllocated);
+		/* FIXME: break, somehow */
+		return;
+	}
+
+	cnx->mNumberRcvMsgs = veth_allocate_events(cnx->remote_lp,
+						   VETH_NUMBUFFERS);
+
+	cnx->local_caps.num_buffers = VETH_NUMBUFFERS;
+	cnx->local_caps.ack_threshold = ACK_THRESHOLD;
+	cnx->local_caps.ack_timeout = VETH_ACKTIMEOUT;
+}
+
 static void veth_close_connection(u8 rlp)
 {
 	struct veth_lpar_connection *cnx = &mFabricMgr->connection[rlp];
@@ -996,60 +658,368 @@
 	del_timer_sync(&cnx->ack_timer);
 }
 
-static void veth_take_cap(struct veth_lpar_connection *cnx,
-			  struct VethLpEvent *event)
+/*
+ * net_device code
+ */
+
+static int veth_open(struct net_device *dev)
+{
+	struct veth_port *port = (struct veth_port *) dev->priv;
+
+	memset(&port->stats, 0, sizeof (port->stats));
+	netif_start_queue(dev);
+	return 0;
+}
+
+static int veth_close(struct net_device *dev)
+{
+	netif_stop_queue(dev);
+	return 0;
+}
+
+static struct net_device_stats *veth_get_stats(struct net_device *dev)
 {
+	struct veth_port *port = (struct veth_port *) dev->priv;
+
+	return &port->stats;
+}
+
+static int veth_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if ((new_mtu < 68) || (new_mtu > VETH_MAX_MTU))
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+static void veth_set_multicast_list(struct net_device *dev)
+{
+	struct veth_port *port = (struct veth_port *) dev->priv;
 	unsigned long flags;
 
-	spin_lock_irqsave(&cnx->lock, flags);
-	/* Receiving caps may mean the other end has just come up, so
-	 * we need to reload the instance ID of the far end */
-	cnx->dst_inst =
-		HvCallEvent_getTargetLpInstanceId(cnx->remote_lp,
-						  HvLpEvent_Type_VirtualLan);
+	write_lock_irqsave(&port->mcast_gate, flags);
 
-	if (cnx->state & VETH_STATE_GOTCAPS) {
-		veth_error("Received a second capabilities from lpar %d\n",
-			   cnx->remote_lp);
-		event->base_event.xRc = HvLpEvent_Rc_BufferNotAvailable;
-		HvCallEvent_ackLpEvent((struct HvLpEvent *) event);
+	if (dev->flags & IFF_PROMISC) {	/* set promiscuous mode */
+		printk(KERN_INFO "%s: Promiscuous mode enabled.\n",
+		       dev->name);
+		port->promiscuous = 1;
+	} else if ( (dev->flags & IFF_ALLMULTI)
+		    || (dev->mc_count > VETH_MAX_MCAST) ) {
+		port->all_mcast = 1;
 	} else {
-		memcpy(&cnx->cap_event, event, sizeof(cnx->cap_event));
-		cnx->state |= VETH_STATE_GOTCAPS;
-		veth_kick_statemachine(cnx);
+		struct dev_mc_list *dmi = dev->mc_list;
+		int i;
+
+		/* Update table */
+		port->num_mcast = 0;
+		
+		for (i = 0; i < dev->mc_count; i++) {
+			u8 *addr = dmi->dmi_addr;
+			u64 xaddr = 0;
+
+			if (addr[0] & 0x01) {/* multicast address? */
+				memcpy(&xaddr, addr, ETH_ALEN);
+				port->mcast_addr[port->num_mcast] = xaddr;
+				port->num_mcast++;
+			}
+			dmi = dmi->next;
+		}
 	}
-	spin_unlock_irqrestore(&cnx->lock, flags);
+
+	write_unlock_irqrestore(&port->mcast_gate, flags);
 }
 
-static void veth_take_cap_ack(struct veth_lpar_connection *cnx,
-			      struct VethLpEvent *event)
+static int veth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+#ifdef SIOCETHTOOL
+	struct ethtool_cmd ecmd;
+
+	if (cmd != SIOCETHTOOL)
+		return -EOPNOTSUPP;
+	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof (ecmd)))
+		return -EFAULT;
+	switch (ecmd.cmd) {
+	case ETHTOOL_GSET:
+		ecmd.supported = (SUPPORTED_1000baseT_Full
+				  | SUPPORTED_Autoneg | SUPPORTED_FIBRE);
+		ecmd.advertising = (SUPPORTED_1000baseT_Full
+				    | SUPPORTED_Autoneg | SUPPORTED_FIBRE);
+
+		ecmd.port = PORT_FIBRE;
+		ecmd.transceiver = XCVR_INTERNAL;
+		ecmd.phy_address = 0;
+		ecmd.speed = SPEED_1000;
+		ecmd.duplex = DUPLEX_FULL;
+		ecmd.autoneg = AUTONEG_ENABLE;
+		ecmd.maxtxpkt = 120;
+		ecmd.maxrxpkt = 120;
+		if (copy_to_user(ifr->ifr_data, &ecmd, sizeof(ecmd)))
+			return -EFAULT;
+		return 0;
+
+	case ETHTOOL_GDRVINFO:{
+			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+			strncpy(info.driver, "veth", sizeof(info.driver) - 1);
+			info.driver[sizeof(info.driver) - 1] = '\0';
+			strncpy(info.version, "1.0", sizeof(info.version) - 1);
+			if (copy_to_user(ifr->ifr_data, &info, sizeof(info)))
+				return -EFAULT;
+			return 0;
+		}
+		/* get link status */
+	case ETHTOOL_GLINK:{
+			struct ethtool_value edata = { ETHTOOL_GLINK };
+			edata.data = 1;
+			if (copy_to_user(ifr->ifr_data, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+
+	default:
+		break;
+	}
+
+#endif
+	return -EOPNOTSUPP;
+}
+
+struct net_device * __init veth_probe_one(int vlan)
+{
+	struct net_device *dev;
+	struct veth_port *port;
+	int i, rc;
+
+	dev = alloc_etherdev(sizeof (struct veth_port));
+	if (! dev) {
+		veth_error("Unable to allocate net_device structure!\n");
+		return NULL;
+	}
+
+	port = (struct veth_port *) dev->priv;
+
+	spin_lock_init(&port->pending_gate);
+	rwlock_init(&port->mcast_gate);
+
+	for (i = 0; i < HVMAXARCHITECTEDLPS; i++) {
+		HvLpVirtualLanIndexMap map;
+
+		if (i == mFabricMgr->this_lp)
+			continue;
+		map = HvLpConfig_getVirtualLanIndexMapForLp(i);
+		if (map & (0x8000 >> vlan))
+			port->lpar_map |= (1 << i);
+	}
+
+	dev->dev_addr[0] = 0x02;
+	dev->dev_addr[1] = 0x01;
+	dev->dev_addr[2] = 0xff;
+	dev->dev_addr[3] = vlan;
+	dev->dev_addr[4] = 0xff;
+	dev->dev_addr[5] = HvLpConfig_getLpIndex_outline();
+
+	dev->mtu = VETH_MAX_MTU;
+
+	memcpy(&port->mac_addr, dev->dev_addr, 6);
+
+	dev->open = veth_open;
+	dev->hard_start_xmit = veth_start_xmit;
+	dev->stop = veth_close;
+	dev->get_stats = veth_get_stats;
+	dev->change_mtu = veth_change_mtu;
+	dev->set_mac_address = NULL;
+	dev->set_multicast_list = veth_set_multicast_list;
+	dev->do_ioctl = veth_ioctl;
+
+	rc = register_netdev(dev);
+	if (rc != 0) {
+		veth_printk(KERN_ERR,
+			    "Failed to register an ethernet device for vlan %d\n",
+			    vlan);
+		free_netdev(dev);
+		return NULL;
+	}
+
+	veth_printk(KERN_DEBUG, "%s attached to iSeries vlan %d (lpar_map=0x%04x)\n",
+		    dev->name, vlan, port->lpar_map);
+
+	return dev;
+}
+
+int __init veth_probe(void)
+{
+	HvLpIndexMap vlan_map = HvLpConfig_getVirtualLanIndexMap();
+	int i;
+
+	memset(veth_devices, 0, sizeof(veth_devices));
+
+	for (i = 0; vlan_map != 0; vlan_map <<= 1, i++) {
+		struct net_device *dev = NULL;
+
+		if (! (vlan_map & 0x8000))
+			continue;
+
+		dev = veth_probe_one(i);
+
+		if (dev) {
+			mFabricMgr->netdev[i] = dev;
+			veth_devices[veth_num_devices] = dev;
+			veth_num_devices++;
+		}
+	}
+
+	if (veth_num_devices == 0)
+		return -ENODEV;
+
+	return 0;
+}
+
+/*
+ * Tx path
+ */
+
+static int veth_transmit_to_one(struct sk_buff *skb, HvLpIndex rlp,
+				struct net_device *dev)
 {
+	struct veth_lpar_connection *cnx = mFabricMgr->connection + rlp;
+	HvLpEvent_Rc rc;
+	u32 dma_address, dma_length;
+	struct veth_msg *msg = NULL;
+	int err = 2;
 	unsigned long flags;
 
 	spin_lock_irqsave(&cnx->lock, flags);
-	if (cnx->state & VETH_STATE_GOTCAPACK) {
-		veth_error("Received a second capabilities ack from lpar %d\n",
-			   cnx->remote_lp);
+
+	if (! cnx->state & VETH_STATE_READY)
+		goto out;
+
+	if ((skb->len - 14) > VETH_MAX_MTU)
+		goto out;
+
+	VETHSTACKPOP(&cnx->msg_stack, msg);
+
+	if (! msg) {
+		err = 1;
+		goto out;
+	}
+
+	dma_length = skb->len;
+	dma_address = pci_map_single(iSeries_veth_dev, skb->data,
+				     dma_length, PCI_DMA_TODEVICE);
+	
+	/* Is it really necessary to check the length and address
+	 * fields of the first entry here? */
+	if (!pci_dma_mapping_error(dma_address)) {
+		msg->skb = skb;
+		msg->data.addr[0] = dma_address;
+		msg->data.len[0] = dma_length;
+		msg->data.eof = 1;
+		set_bit(0, &(msg->in_use));
+		rc = veth_signaldata(cnx, VethEventTypeFrames,
+				     msg->token, &msg->data);
 	} else {
-		memcpy(&cnx->cap_ack_event, event,
-		       sizeof(&cnx->cap_ack_event));
-		cnx->state |= VETH_STATE_GOTCAPACK;
-		veth_kick_statemachine(cnx);
+		struct veth_port *port = (struct veth_port *) dev->priv;
+		rc = -1;	/* Bad return code */
+		port->stats.tx_errors++;
+	}
+
+	if (rc != HvLpEvent_Rc_Good) {
+		msg->skb = NULL;
+		/* need to set in use to make veth_recycle_msg in case
+		 * this was a mapping failure */
+		set_bit(0, &msg->in_use);
+		veth_recycle_msg(cnx, msg);
+	} else {
+		err = 0;
 	}
+
+ out:
 	spin_unlock_irqrestore(&cnx->lock, flags);
+	return err;
 }
 
-static void veth_take_monitor_ack(struct veth_lpar_connection *cnx,
-				  struct VethLpEvent *event)
+static HvLpIndexMap veth_transmit_to_many(struct sk_buff *skb,
+					  HvLpIndexMap lpmask,
+					  struct net_device *dev)
+{
+	struct veth_port *port = (struct veth_port *) dev->priv;
+	int i;
+	int rc;
+
+	for (i = 0; i < HVMAXARCHITECTEDLPS; i++) {
+		struct sk_buff *clone;
+
+		if (! lpmask & (1<<i))
+			continue;
+		
+		clone = skb_clone(skb, GFP_ATOMIC);
+		if (! clone) {
+			veth_error("%s: skb_clone failed %p\n",
+				   dev->name, skb);
+			continue;
+		}
+		/* the ack handles deleting the skb */
+		rc = veth_transmit_to_one(clone, i, dev);
+		
+		/* tx failed, we need to free the skb */
+		if (rc != 0)
+			dev_kfree_skb(clone);
+			
+		/* if we didn't fail from lack of buffers, the tx as a
+		 * whole is successful */
+		if (rc != 1)
+			lpmask &= ~(1<<i);
+	}
+
+	if (! lpmask) {
+		port->stats.tx_packets++;
+		port->stats.tx_bytes += skb->len;
+	}
+
+	return lpmask;
+}
+
+static int veth_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
+	unsigned char *frame = skb->data;
+	struct veth_port *port = (struct veth_port *) dev->priv;
 	unsigned long flags;
+	HvLpIndexMap lpmask;
 
-	spin_lock_irqsave(&cnx->lock, flags);
-	veth_printk(KERN_DEBUG, "Monitor ack returned for lpar %d\n",
-		    cnx->remote_lp);
-	cnx->state |= VETH_STATE_RESET;
-	veth_kick_statemachine(cnx);
-	spin_unlock_irqrestore(&cnx->lock, flags);
+	BUG_ON(! mFabricMgr);
+
+	if (! (frame[0] & 0x01)) {
+		/* unicast packet */
+		HvLpIndex rlp = frame[5];
+
+		if ( ! ((1 << rlp) & port->lpar_map) ) {
+			dev_kfree_skb(skb);
+			return 0;
+		}
+
+		lpmask = 1 << rlp;
+	} else {
+		lpmask = port->lpar_map;
+	}
+
+	lpmask = veth_transmit_to_many(skb, lpmask, dev);
+
+	if (lpmask) {
+		spin_lock_irqsave(&port->pending_gate, flags);
+		if (port->pending_skb) {
+			veth_error("%s: Tx while skb was pending!\n", dev->name);
+			dev_kfree_skb(skb);
+			return 1;
+		}
+
+		port->pending_skb = skb;
+		port->pending_lpmask = lpmask;
+		netif_stop_queue(dev);
+
+		spin_unlock_irqrestore(&port->pending_gate, flags);
+	}
+
+	dev_kfree_skb(skb);
+	return 0;
 }
 
 static void veth_recycle_msg(struct veth_lpar_connection *cnx,
@@ -1104,6 +1074,10 @@
 	}
 }
 
+/*
+ * Rx path
+ */
+
 static inline int veth_frame_wanted(struct veth_port *port, u64 mac_addr)
 {
 	int wanted = 0;
@@ -1203,7 +1177,7 @@
 				   (unsigned) senddata->eof, startchunk);
 			break;
 		}
-
+		
 		/* build list of chunks in this frame */
 		do {
 			remote_list[nchunks].addr =
@@ -1326,3 +1300,108 @@
 	cnx->ack_timer.expires = jiffies + cnx->ack_timeout;
 	add_timer(&cnx->ack_timer);
 }
+
+/*
+ * Module initialization/cleanup
+ */
+
+void __exit veth_module_cleanup(void)
+{
+	int i;
+	struct VethFabricMgr *fm = mFabricMgr;
+
+	if (! mFabricMgr)
+		return;
+
+	for (i = 0; i < HVMAXARCHITECTEDLPS; ++i)
+		veth_close_connection(i);
+	
+	HvLpEvent_unregisterHandler(HvLpEvent_Type_VirtualLan);
+	
+	mb();
+	mFabricMgr = NULL;
+	mb();
+	
+	for (i = 0; i < HVMAXARCHITECTEDLPS; ++i) {
+		struct veth_lpar_connection *cnx = &fm->connection[i];
+
+		if (cnx->mNumberAllocated + cnx->mNumberRcvMsgs > 0) {
+			mf_deallocateLpEvents(cnx->remote_lp,
+					      HvLpEvent_Type_VirtualLan,
+					      cnx->mNumberAllocated
+					      + cnx->mNumberRcvMsgs,
+					      NULL, NULL);
+		}
+		
+		if (cnx->msgs)
+			kfree(cnx->msgs);
+	}
+	
+	for (i = 0; i < HVMAXARCHITECTEDVIRTUALLANS; ++i) {
+		struct net_device *dev;
+
+		if (! fm->netdev[i])
+			continue;
+
+		dev = fm->netdev[i];
+		fm->netdev[i] = NULL;
+
+		mb();
+			
+		if (dev) {
+			unregister_netdev(dev);
+			free_netdev(dev);
+		}
+	}
+	
+	kfree(fm);
+}
+module_exit(veth_module_cleanup);
+
+int __init veth_module_init(void)
+{
+	int i;
+	int this_lp;
+	int rc;
+
+	mFabricMgr = kmalloc(sizeof (struct VethFabricMgr), GFP_KERNEL);
+	if (! mFabricMgr) {
+		veth_error("Unable to allocate fabric manager\n");
+		return -ENOMEM;
+	}
+
+	memset(mFabricMgr, 0, sizeof (*mFabricMgr));
+
+	this_lp = HvLpConfig_getLpIndex_outline();
+	mFabricMgr->this_lp = this_lp;
+
+	for (i = 0; i < HVMAXARCHITECTEDLPS; ++i) {
+		struct veth_lpar_connection *cnx = &mFabricMgr->connection[i];
+
+		veth_init_connection(cnx, i);
+	}
+
+	rc = veth_probe();
+	if (rc != 0) {
+		veth_module_cleanup();
+		return rc;
+	}
+
+	HvLpEvent_registerHandler(HvLpEvent_Type_VirtualLan, &veth_handle_event);
+
+	/* Run through the active lps and open connections to the ones
+	 * we need to */
+	/* FIXME: is there any reason to do this backwards? */
+	for (i = HVMAXARCHITECTEDLPS - 1; i >= 0; --i) {
+		struct veth_lpar_connection *cnx = &mFabricMgr->connection[i];
+
+		if ( (i == this_lp) 
+		     || ! HvLpConfig_doLpsCommunicateOnVirtualLan(this_lp, i) )
+			continue;
+
+		veth_kick_statemachine(cnx);
+	}
+
+	return 0;
+}
+module_init(veth_module_init);
diff -Nru a/drivers/net/iseries_veth.h b/drivers/net/iseries_veth.h
--- a/drivers/net/iseries_veth.h	Tue Mar 30 09:07:15 2004
+++ b/drivers/net/iseries_veth.h	Tue Mar 30 09:07:15 2004
@@ -43,88 +43,6 @@
 
 };
 
-#define VETH_ACKTIMEOUT 	(1000000) /* microseconds */
-#define VETH_MAX_MCAST		(12)
-
 #define HVMAXARCHITECTEDVIRTUALLANS (16)
-
-#define VETHSTACK(T) \
-	struct VethStack##T { \
-		struct T *head; \
-		spinlock_t lock; \
-	}
-#define VETHSTACKPUSH(s, p) \
-	do { \
-		unsigned long flags; \
-		spin_lock_irqsave(&(s)->lock,flags); \
-		(p)->next = (s)->head; \
-		(s)->head = (p); \
-		spin_unlock_irqrestore(&(s)->lock, flags); \
-	} while (0)
-
-#define VETHSTACKPOP(s,p) \
-	do { \
-		unsigned long flags; \
-		spin_lock_irqsave(&(s)->lock,flags); \
-		(p) = (s)->head; \
-		if ((s)->head) \
-			(s)->head = (s)->head->next; \
-		spin_unlock_irqrestore(&(s)->lock, flags); \
-	} while (0)
-
-struct veth_msg {
-	struct veth_msg *next;
-	struct VethFramesData data;
-	int token;
-	unsigned long in_use;
-	struct sk_buff *skb;
-};
-
-struct veth_lpar_connection {
-	HvLpIndex remote_lp;
-	struct work_struct statemachine_wq;
-	struct veth_msg *msgs;
-	int mNumberAllocated;
-	int mNumberRcvMsgs;
-	struct VethCapData local_caps;
-
-	struct timer_list ack_timer;
-
-	spinlock_t lock;
-	unsigned long state;
-	HvLpInstanceId src_inst;
-	HvLpInstanceId dst_inst;
-	struct VethLpEvent cap_event, cap_ack_event;
-	u16 pending_acks[VETH_MAX_ACKS_PER_MSG];
-	u32 num_pending_acks;
-
-	int mNumberLpAcksAlloced;
-	struct VethCapData remote_caps;
-	u32 ack_timeout;
-
-	VETHSTACK(veth_msg) msg_stack;
-};
-
-struct veth_port {
-	struct net_device_stats stats;
-	u64 mac_addr;
-	HvLpIndexMap lpar_map;
-
-	spinlock_t pending_gate;
-	struct sk_buff *pending_skb;
-	HvLpIndexMap pending_lpmask;
-
-	rwlock_t mcast_gate;
-	int promiscuous;
-	int all_mcast;
-	int num_mcast;
-	u64 mcast_addr[VETH_MAX_MCAST];
-};
-
-struct VethFabricMgr {
-	HvLpIndex this_lp;
-	struct veth_lpar_connection connection[HVMAXARCHITECTEDLPS];
-	struct net_device *netdev[HVMAXARCHITECTEDVIRTUALLANS];
-};
 
 #endif	/* _ISERIES_VETH_H */
.........................................................................
# vim: syntax=diff

