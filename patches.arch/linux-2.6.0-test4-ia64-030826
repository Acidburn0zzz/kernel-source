diff -Nru a/arch/ia64/Kconfig b/arch/ia64/Kconfig
--- a/arch/ia64/Kconfig	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/Kconfig	Tue Aug 26 11:14:11 2003
@@ -234,8 +234,8 @@
 endchoice
 
 config DISCONTIGMEM
-	bool "Discontiguous memory support" if (IA64_DIG && NUMA)
-	default y if IA64_SGI_SN2 || IA64_GENERIC
+	bool "Discontiguous memory support" if (IA64_DIG || IA64_SGI_SN2 || IA64_GENERIC) && NUMA
+	default y if (IA64_SGI_SN2 || IA64_GENERIC) && NUMA
 	help
 	  Say Y to support efficient handling of discontiguous physical memory,
 	  for architectures which are either NUMA (Non-Uniform Memory Access)
@@ -647,6 +647,33 @@
 	  send a BREAK and then within 5 seconds a command keypress. The
 	  keys are documented in <file:Documentation/sysrq.txt>. Don't say Y
 	  unless you really know what this hack does.
+
+config IA64_EARLY_PRINTK
+	bool "Early printk support"
+	depends on DEBUG_KERNEL && !IA64_GENERIC
+	help
+	  Selecting this option uses the VGA screen or serial console for
+	  printk() output before the consoles are initialised.  It is useful
+	  for debugging problems early in the boot process, but only if you
+	  have a suitable VGA/serial console attached.  If you're unsure,
+	  select N.
+
+config IA64_EARLY_PRINTK_UART
+	bool "Early printk on MMIO serial port"
+	depends on IA64_EARLY_PRINTK
+
+config IA64_EARLY_PRINTK_UART_BASE
+	hex "UART MMIO base address"
+	depends on IA64_EARLY_PRINTK_UART
+	default "ff5e0000"
+
+config IA64_EARLY_PRINTK_VGA
+	bool "Early printk on VGA"
+	depends on IA64_EARLY_PRINTK
+
+config IA64_EARLY_PRINTK_SGI_SN
+	bool "Early printk on SGI SN serial console"
+	depends on IA64_EARLY_PRINTK && (IA64_GENERIC || IA64_SGI_SN2)
 
 config DEBUG_SLAB
 	bool "Debug memory allocations"
diff -Nru a/arch/ia64/Makefile b/arch/ia64/Makefile
--- a/arch/ia64/Makefile	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/Makefile	Tue Aug 26 11:14:11 2003
@@ -70,6 +70,8 @@
 
 .PHONY: boot compressed check
 
+all: compressed
+
 compressed: vmlinux.gz
 
 vmlinux.gz: vmlinux
@@ -100,6 +102,6 @@
 
 
 define archhelp
-  echo '  compressed	- Build compressed kernel image'
+  echo '* compressed	- Build compressed kernel image'
   echo '  boot		- Build vmlinux and bootloader for Ski simulator'
 endef
diff -Nru a/arch/ia64/ia32/sys_ia32.c b/arch/ia64/ia32/sys_ia32.c
--- a/arch/ia64/ia32/sys_ia32.c	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/ia32/sys_ia32.c	Tue Aug 26 11:14:11 2003
@@ -76,7 +76,6 @@
 
 #define OFFSET4K(a)		((a) & 0xfff)
 #define PAGE_START(addr)	((addr) & PAGE_MASK)
-#define PAGE_OFF(addr)		((addr) & ~PAGE_MASK)
 
 #define high2lowuid(uid) ((uid) > 65535 ? 65534 : (uid))
 #define high2lowgid(gid) ((gid) > 65535 ? 65534 : (gid))
@@ -170,9 +169,9 @@
 		current->thread.map_base  = old_map_base;
 		current->thread.task_size = old_task_size;
 		set_fs(USER_DS);	/* establish new task-size as the address-limit */
-	  out:
-		kfree(av);
 	}
+  out:
+	kfree(av);
 	return r;
 }
 
@@ -271,11 +270,11 @@
 
 	if (old_prot) {
 		/* copy back the old page contents.  */
-		if (PAGE_OFF(start))
-			copy_to_user((void *) PAGE_START(start), page, PAGE_OFF(start));
-		if (PAGE_OFF(end))
-			copy_to_user((void *) end, page + PAGE_OFF(end),
-				     PAGE_SIZE - PAGE_OFF(end));
+		if (offset_in_page(start))
+			copy_to_user((void *) PAGE_START(start), page, offset_in_page(start));
+		if (offset_in_page(end))
+			copy_to_user((void *) end, page + offset_in_page(end),
+				     PAGE_SIZE - offset_in_page(end));
 	}
 
 	if (!(flags & MAP_ANONYMOUS)) {
@@ -330,7 +329,7 @@
 				       "%s(%d): emulate_mmap() can't share tail (end=0x%lx)\n",
 				       current->comm, current->pid, end);
 			ret = mmap_subpage(file, max(start, PAGE_START(end)), end, prot, flags,
-					   (off + len) - PAGE_OFF(end));
+					   (off + len) - offset_in_page(end));
 			if (IS_ERR((void *) ret))
 				return ret;
 			pend -= PAGE_SIZE;
@@ -347,14 +346,14 @@
 		tmp = arch_get_unmapped_area(file, pstart - fudge, pend - pstart, 0, flags);
 		if (tmp != pstart) {
 			pstart = tmp;
-			start = pstart + PAGE_OFF(off);	/* make start congruent with off */
+			start = pstart + offset_in_page(off);	/* make start congruent with off */
 			end = start + len;
 			pend = PAGE_ALIGN(end);
 		}
 	}
 
 	poff = off + (pstart - start);	/* note: (pstart - start) may be negative */
-	is_congruent = (flags & MAP_ANONYMOUS) || (PAGE_OFF(poff) == 0);
+	is_congruent = (flags & MAP_ANONYMOUS) || (offset_in_page(poff) == 0);
 
 	if ((flags & MAP_SHARED) && !is_congruent)
 		printk(KERN_INFO "%s(%d): emulate_mmap() can't share contents of incongruent mmap "
@@ -588,7 +587,7 @@
 
 	down(&ia32_mmap_sem);
 	{
-		if (PAGE_OFF(start)) {
+		if (offset_in_page(start)) {
 			/* start address is 4KB aligned but not page aligned. */
 			retval = mprotect_subpage(PAGE_START(start), prot);
 			if (retval < 0)
@@ -599,7 +598,7 @@
 				goto out;	/* retval is already zero... */
 		}
 
-		if (PAGE_OFF(end)) {
+		if (offset_in_page(end)) {
 			/* end address is 4KB aligned but not page aligned. */
 			retval = mprotect_subpage(PAGE_START(end), prot);
 			if (retval < 0)
diff -Nru a/arch/ia64/kernel/entry.S b/arch/ia64/kernel/entry.S
--- a/arch/ia64/kernel/entry.S	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/kernel/entry.S	Tue Aug 26 11:14:11 2003
@@ -1473,7 +1473,7 @@
 	data8 sys_clock_nanosleep
 	data8 sys_fstatfs64
 	data8 sys_statfs64
-	data8 ia64_ni_syscall
+	data8 sys_fadvise64_64
 	data8 ia64_ni_syscall			// 1260
 	data8 ia64_ni_syscall
 	data8 ia64_ni_syscall
diff -Nru a/arch/ia64/kernel/fsys.S b/arch/ia64/kernel/fsys.S
--- a/arch/ia64/kernel/fsys.S	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/kernel/fsys.S	Tue Aug 26 11:14:11 2003
@@ -678,9 +678,9 @@
 	data8 0				// clock_gettime
 	data8 0				// clock_getres		// 1255
 	data8 0				// clock_nanosleep
-	data8 0
-	data8 0
-	data8 0
+	data8 0				// fstatfs64
+	data8 0				// statfs64
+	data8 0				// fadvise64_64
 	data8 0							// 1260
 	data8 0
 	data8 0
diff -Nru a/arch/ia64/kernel/mca.c b/arch/ia64/kernel/mca.c
--- a/arch/ia64/kernel/mca.c	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/kernel/mca.c	Tue Aug 26 11:14:11 2003
@@ -1145,7 +1145,7 @@
 
 	ia64_mca_cmc_int_handler(cpe_irq, arg, ptregs);
 
-	for (++cpuid ; !cpu_online(cpuid) && cpuid < NR_CPUS ; cpuid++);
+	for (++cpuid ; cpuid < NR_CPUS && !cpu_online(cpuid) ; cpuid++);
 
 	if (cpuid < NR_CPUS) {
 		platform_send_ipi(cpuid, IA64_CMCP_VECTOR, IA64_IPI_DM_INT, 0);
diff -Nru a/arch/ia64/kernel/smpboot.c b/arch/ia64/kernel/smpboot.c
--- a/arch/ia64/kernel/smpboot.c	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/kernel/smpboot.c	Tue Aug 26 11:14:11 2003
@@ -560,7 +560,7 @@
 		if (cpu_online(cpu))
 			bogosum += cpu_data(cpu)->loops_per_jiffy;
 
-	printk(KERN_INFO "Total of %d processors activated (%lu.%02lu BogoMIPS).\n",
+	printk(KERN_INFO "Total of %lu processors activated (%lu.%02lu BogoMIPS).\n",
 	       num_online_cpus(), bogosum/(500000/HZ), (bogosum/(5000/HZ))%100);
 }
 
diff -Nru a/arch/ia64/kernel/sys_ia64.c b/arch/ia64/kernel/sys_ia64.c
--- a/arch/ia64/kernel/sys_ia64.c	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/kernel/sys_ia64.c	Tue Aug 26 11:14:11 2003
@@ -242,7 +242,7 @@
 asmlinkage unsigned long
 sys_mmap (unsigned long addr, unsigned long len, int prot, int flags, int fd, long off)
 {
-	if ((off & ~PAGE_MASK) != 0)
+	if (offset_in_page(off) != 0)
 		return -EINVAL;
 
 	addr = do_mmap2(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
diff -Nru a/arch/ia64/lib/Makefile b/arch/ia64/lib/Makefile
--- a/arch/ia64/lib/Makefile	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/lib/Makefile	Tue Aug 26 11:14:11 2003
@@ -14,9 +14,6 @@
 lib-$(CONFIG_PERFMON)	+= carta_random.o
 lib-$(CONFIG_MD_RAID5)	+= xor.o
 
-IGNORE_FLAGS_OBJS =	__divsi3.o __udivsi3.o __modsi3.o __umodsi3.o \
-			__divdi3.o __udivdi3.o __moddi3.o __umoddi3.o
-
 AFLAGS___divdi3.o	=
 AFLAGS___udivdi3.o	= -DUNSIGNED
 AFLAGS___moddi3.o	= 	     -DMODULO
@@ -27,26 +24,26 @@
 AFLAGS___modsi3.o	=	     -DMODULO
 AFLAGS___umodsi3.o	= -DUNSIGNED -DMODULO
 
-$(obj)/__divdi3.o: $(src)/idiv64.S
-	$(cmd_as_o_S)
+$(obj)/__divdi3.o: $(src)/idiv64.S FORCE
+	$(call if_changed_dep,as_o_S)
 
-$(obj)/__udivdi3.o: $(src)/idiv64.S
-	$(cmd_as_o_S)
+$(obj)/__udivdi3.o: $(src)/idiv64.S FORCE
+	$(call if_changed_dep,as_o_S)
 
-$(obj)/__moddi3.o: $(src)/idiv64.S
-	$(cmd_as_o_S)
+$(obj)/__moddi3.o: $(src)/idiv64.S FORCE
+	$(call if_changed_dep,as_o_S)
 
-$(obj)/__umoddi3.o: $(src)/idiv64.S
-	$(cmd_as_o_S)
+$(obj)/__umoddi3.o: $(src)/idiv64.S FORCE
+	$(call if_changed_dep,as_o_S)
 
-$(obj)/__divsi3.o: $(src)/idiv32.S
-	$(cmd_as_o_S)
+$(obj)/__divsi3.o: $(src)/idiv32.S FORCE
+	$(call if_changed_dep,as_o_S)
 
-$(obj)/__udivsi3.o: $(src)/idiv32.S
-	$(cmd_as_o_S)
+$(obj)/__udivsi3.o: $(src)/idiv32.S FORCE
+	$(call if_changed_dep,as_o_S)
 
-$(obj)/__modsi3.o: $(src)/idiv32.S
-	$(cmd_as_o_S)
+$(obj)/__modsi3.o: $(src)/idiv32.S FORCE
+	$(call if_changed_dep,as_o_S)
 
-$(obj)/__umodsi3.o: $(src)/idiv32.S
-	$(cmd_as_o_S)
+$(obj)/__umodsi3.o: $(src)/idiv32.S FORCE
+	$(call if_changed_dep,as_o_S)
diff -Nru a/arch/ia64/mm/numa.c b/arch/ia64/mm/numa.c
--- a/arch/ia64/mm/numa.c	Tue Aug 26 11:14:11 2003
+++ b/arch/ia64/mm/numa.c	Tue Aug 26 11:14:11 2003
@@ -42,5 +42,5 @@
 		    paddr < node_memblk[i].start_paddr + node_memblk[i].size)
 			break;
 
-	return (i < num_memblks) ? node_memblk[i].nid : -1;
+	return (i < num_memblks) ? node_memblk[i].nid : (num_memblks ? -1 : 0);
 }
diff -Nru a/drivers/acpi/tables.c b/drivers/acpi/tables.c
--- a/drivers/acpi/tables.c	Tue Aug 26 11:14:11 2003
+++ b/drivers/acpi/tables.c	Tue Aug 26 11:14:11 2003
@@ -261,10 +261,17 @@
 
 	/* Map the DSDT header via the pointer in the FADT */
 	if (id == ACPI_DSDT) {
-		struct acpi_table_fadt *fadt = (struct acpi_table_fadt *) *header;
+		struct fadt_descriptor_rev2 *fadt = (struct fadt_descriptor_rev2 *) *header;
+
+		if (fadt->header.revision == 3 && fadt->Xdsdt) {
+			*header = (void *) __acpi_map_table(fadt->Xdsdt,
+					sizeof(struct acpi_table_header));
+		} else if (fadt->V1_dsdt) {
+			*header = (void *) __acpi_map_table(fadt->V1_dsdt,
+					sizeof(struct acpi_table_header));
+		} else
+			*header = 0;
 
-		*header = (void *) __acpi_map_table(fadt->dsdt_addr,
-				sizeof(struct acpi_table_header));
 		if (!*header) {
 			printk(KERN_WARNING PREFIX "Unable to map DSDT\n");
 			return -ENODEV;
diff -Nru a/drivers/media/radio/Makefile b/drivers/media/radio/Makefile
--- a/drivers/media/radio/Makefile	Tue Aug 26 11:14:11 2003
+++ b/drivers/media/radio/Makefile	Tue Aug 26 11:14:11 2003
@@ -2,6 +2,8 @@
 # Makefile for the kernel character device drivers.
 #
 
+obj-y		:= dummy.o
+
 miropcm20-objs	:= miropcm20-rds-core.o miropcm20-radio.o
 
 obj-$(CONFIG_RADIO_AZTECH) += radio-aztech.o
diff -Nru a/drivers/media/radio/dummy.c b/drivers/media/radio/dummy.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/media/radio/dummy.c	Tue Aug 26 11:14:11 2003
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -Nru a/drivers/media/video/Makefile b/drivers/media/video/Makefile
--- a/drivers/media/video/Makefile	Tue Aug 26 11:14:11 2003
+++ b/drivers/media/video/Makefile	Tue Aug 26 11:14:11 2003
@@ -7,6 +7,7 @@
 zoran-objs      :=	zr36120.o zr36120_i2c.o zr36120_mem.o
 zr36067-objs	:=	zoran_procfs.o zoran_device.o \
 			zoran_driver.o zoran_card.o
+obj-y		:=	dummy.o
 
 obj-$(CONFIG_VIDEO_DEV) += videodev.o v4l2-common.o v4l1-compat.o
 
diff -Nru a/drivers/media/video/dummy.c b/drivers/media/video/dummy.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/media/video/dummy.c	Tue Aug 26 11:14:11 2003
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -Nru a/drivers/net/tulip/media.c b/drivers/net/tulip/media.c
--- a/drivers/net/tulip/media.c	Tue Aug 26 11:14:11 2003
+++ b/drivers/net/tulip/media.c	Tue Aug 26 11:14:11 2003
@@ -278,6 +278,10 @@
 				for (i = 0; i < init_length; i++)
 					outl(init_sequence[i], ioaddr + CSR12);
 			}
+
+			(void) inl(ioaddr + CSR6); /* flush CSR12 writes */
+			udelay(500);		/* Give MII time to recover */
+
 			tmp_info = get_u16(&misc_info[1]);
 			if (tmp_info)
 				tp->advertising[phy_num] = tmp_info | 1;
diff -Nru a/include/asm-ia64/pci.h b/include/asm-ia64/pci.h
--- a/include/asm-ia64/pci.h	Tue Aug 26 11:14:11 2003
+++ b/include/asm-ia64/pci.h	Tue Aug 26 11:14:11 2003
@@ -74,7 +74,7 @@
 #define pci_dac_dma_supported(pci_dev, mask)		(1)
 #define pci_dac_page_to_dma(dev,pg,off,dir)		((dma_addr_t) page_to_bus(pg) + (off))
 #define pci_dac_dma_to_page(dev,dma_addr)		(virt_to_page(bus_to_virt(dma_addr)))
-#define pci_dac_dma_to_offset(dev,dma_addr)		((dma_addr) & ~PAGE_MASK)
+#define pci_dac_dma_to_offset(dev,dma_addr)		offset_in_page(dma_addr)
 #define pci_dac_dma_sync_single(dev,dma_addr,len,dir)	do { mb(); } while (0)
 
 #define sg_dma_len(sg)		((sg)->dma_length)
diff -Nru a/include/asm-ia64/unistd.h b/include/asm-ia64/unistd.h
--- a/include/asm-ia64/unistd.h	Tue Aug 26 11:14:11 2003
+++ b/include/asm-ia64/unistd.h	Tue Aug 26 11:14:11 2003
@@ -248,6 +248,7 @@
 #define __NR_sys_clock_nanosleep	1256
 #define __NR_sys_fstatfs64		1257
 #define __NR_sys_statfs64		1258
+#define __NR_fadvises64_64		1259
 
 #ifdef __KERNEL__
 
diff -Nru a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
--- a/include/linux/nfs_fs.h	Tue Aug 26 11:14:11 2003
+++ b/include/linux/nfs_fs.h	Tue Aug 26 11:14:11 2003
@@ -410,7 +410,7 @@
 nfs_size_to_loff_t(__u64 size)
 {
 	loff_t maxsz = (((loff_t) ULONG_MAX) << PAGE_CACHE_SHIFT) + PAGE_CACHE_SIZE - 1;
-	if (size > maxsz)
+	if (size > (__u64) maxsz)
 		return maxsz;
 	return (loff_t) size;
 }
diff -Nru a/include/linux/sysctl.h b/include/linux/sysctl.h
--- a/include/linux/sysctl.h	Tue Aug 26 11:14:11 2003
+++ b/include/linux/sysctl.h	Tue Aug 26 11:14:11 2003
@@ -127,6 +127,7 @@
 	KERN_PANIC_ON_OOPS=57,  /* int: whether we will panic on an oops */
 	KERN_HPPA_PWRSW=58,	/* int: hppa soft-power enable */
 	KERN_HPPA_UNALIGNED=59,	/* int: hppa unaligned-trap enable */
+	KERN_CACHEDECAYTICKS=60,/* ulong: value for cache_decay_ticks (EXPERIMENTAL!) */
 };
 
 
diff -Nru a/kernel/printk.c b/kernel/printk.c
--- a/kernel/printk.c	Tue Aug 26 11:14:11 2003
+++ b/kernel/printk.c	Tue Aug 26 11:14:11 2003
@@ -313,6 +313,12 @@
 			__call_console_drivers(start, end);
 		}
 	}
+#ifdef CONFIG_IA64_EARLY_PRINTK
+	if (!console_drivers) {
+		void early_printk (const char *str, size_t len);
+		early_printk(&LOG_BUF(start), end - start);
+	}
+#endif
 }
 
 /*
@@ -630,7 +636,11 @@
 		 * for us.
 		 */
 		spin_lock_irqsave(&logbuf_lock, flags);
+#ifdef CONFIG_IA64_EARLY_PRINTK
+		con_start = log_end;
+#else
 		con_start = log_start;
+#endif
 		spin_unlock_irqrestore(&logbuf_lock, flags);
 	}
 	release_console_sem();
@@ -683,3 +693,117 @@
 		tty->driver->write(tty, 0, msg, strlen(msg));
 	return;
 }
+
+#ifdef CONFIG_IA64_EARLY_PRINTK
+
+#include <asm/io.h>
+
+# ifdef CONFIG_IA64_EARLY_PRINTK_VGA
+
+
+#define VGABASE		((char *)0xc0000000000b8000)
+#define VGALINES	24
+#define VGACOLS		80
+
+static int current_ypos = VGALINES, current_xpos = 0;
+
+static void
+early_printk_vga (const char *str, size_t len)
+{
+	char c;
+	int  i, k, j;
+
+	while (len-- > 0) {
+		c = *str++;
+		if (current_ypos >= VGALINES) {
+			/* scroll 1 line up */
+			for (k = 1, j = 0; k < VGALINES; k++, j++) {
+				for (i = 0; i < VGACOLS; i++) {
+					writew(readw(VGABASE + 2*(VGACOLS*k + i)),
+					       VGABASE + 2*(VGACOLS*j + i));
+				}
+			}
+			for (i = 0; i < VGACOLS; i++) {
+				writew(0x720, VGABASE + 2*(VGACOLS*j + i));
+			}
+			current_ypos = VGALINES-1;
+		}
+		if (c == '\n') {
+			current_xpos = 0;
+			current_ypos++;
+		} else if (c != '\r')  {
+			writew(((0x7 << 8) | (unsigned short) c),
+			       VGABASE + 2*(VGACOLS*current_ypos + current_xpos++));
+			if (current_xpos >= VGACOLS) {
+				current_xpos = 0;
+				current_ypos++;
+			}
+		}
+	}
+}
+
+# endif /* CONFIG_IA64_EARLY_PRINTK_VGA */
+
+# ifdef CONFIG_IA64_EARLY_PRINTK_UART
+
+#include <linux/serial_reg.h>
+#include <asm/system.h>
+
+static void early_printk_uart(const char *str, size_t len)
+{
+	static char *uart = NULL;
+	unsigned long uart_base;
+	char c;
+
+	if (!uart) {
+		uart_base = 0;
+#  ifdef CONFIG_SERIAL_8250_HCDP
+		{
+			extern unsigned long hcdp_early_uart(void);
+			uart_base = hcdp_early_uart();
+		}
+#  endif
+#  if CONFIG_IA64_EARLY_PRINTK_UART_BASE
+		if (!uart_base)
+			uart_base = CONFIG_IA64_EARLY_PRINTK_UART_BASE;
+#  endif
+		if (!uart_base)
+			return;
+
+		uart = ioremap(uart_base, 64);
+		if (!uart)
+			return;
+	}
+
+	while (len-- > 0) {
+		c = *str++;
+		while ((readb(uart + UART_LSR) & UART_LSR_TEMT) == 0)
+			cpu_relax(); /* spin */
+
+		writeb(c, uart + UART_TX);
+
+		if (c == '\n')
+			writeb('\r', uart + UART_TX);
+	}
+}
+
+# endif /* CONFIG_IA64_EARLY_PRINTK_UART */
+
+#ifdef CONFIG_IA64_EARLY_PRINTK_SGI_SN
+extern int sn_sal_console_out(const char *str, int len);
+#endif
+
+void early_printk(const char *str, size_t len)
+{
+#ifdef CONFIG_IA64_EARLY_PRINTK_UART
+	early_printk_uart(str, len);
+#endif
+#ifdef CONFIG_IA64_EARLY_PRINTK_VGA
+	early_printk_vga(str, len);
+#endif
+#ifdef CONFIG_IA64_EARLY_PRINTK_SGI_SN
+ 	sn_sal_console_out(str, len);
+#endif
+}
+
+#endif /* CONFIG_IA64_EARLY_PRINTK */
diff -Nru a/kernel/sysctl.c b/kernel/sysctl.c
--- a/kernel/sysctl.c	Tue Aug 26 11:14:11 2003
+++ b/kernel/sysctl.c	Tue Aug 26 11:14:11 2003
@@ -580,6 +580,16 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#ifdef CONFIG_SMP
+	{
+		.ctl_name	= KERN_CACHEDECAYTICKS,
+		.procname	= "cache_decay_ticks",
+		.data		= &cache_decay_ticks,
+		.maxlen		= sizeof(cache_decay_ticks),
+		.mode		= 0644,
+		.proc_handler	= &proc_doulongvec_minmax,
+	},
+#endif
 	{ .ctl_name = 0 }
 };
 
diff -Nru a/mm/memory.c b/mm/memory.c
--- a/mm/memory.c	Tue Aug 26 11:14:11 2003
+++ b/mm/memory.c	Tue Aug 26 11:14:11 2003
@@ -114,8 +114,10 @@
 	}
 	pmd = pmd_offset(dir, 0);
 	pgd_clear(dir);
-	for (j = 0; j < PTRS_PER_PMD ; j++)
+	for (j = 0; j < PTRS_PER_PMD ; j++) {
+		prefetchw(pmd + j + PREFETCH_STRIDE/sizeof(*pmd));
 		free_one_pmd(tlb, pmd+j);
+	}
 	pmd_free_tlb(tlb, pmd);
 }
 
@@ -1384,7 +1386,7 @@
 	unsigned long address, int write_access, pte_t *page_table, pmd_t *pmd)
 {
 	struct page * new_page;
-	struct address_space *mapping;
+	struct address_space *mapping = NULL;
 	pte_t entry;
 	struct pte_chain *pte_chain;
 	int sequence;
@@ -1396,8 +1398,10 @@
 	pte_unmap(page_table);
 	spin_unlock(&mm->page_table_lock);
 
-	mapping = vma->vm_file->f_dentry->d_inode->i_mapping;
-	sequence = atomic_read(&mapping->truncate_count);
+	if (vma->vm_file) {
+		mapping = vma->vm_file->f_dentry->d_inode->i_mapping;
+		sequence = atomic_read(&mapping->truncate_count);
+	}
 	smp_rmb();  /* Prevent CPU from reordering lock-free ->nopage() */
 retry:
 	new_page = vma->vm_ops->nopage(vma, address & PAGE_MASK, 0);
@@ -1433,7 +1437,8 @@
 	 * invalidated this page.  If invalidate_mmap_range got called,
 	 * retry getting the page.
 	 */
-	if (unlikely(sequence != atomic_read(&mapping->truncate_count))) {
+	if (mapping && 
+	      (unlikely(sequence != atomic_read(&mapping->truncate_count)))) {
 		sequence = atomic_read(&mapping->truncate_count);
 		spin_unlock(&mm->page_table_lock);
 		page_cache_release(new_page);
