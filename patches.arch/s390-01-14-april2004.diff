- Description: qeth: bad network performance and potential network freeze
  Symptom:     network performance (especially the inbound path) is considerably
               bad compared to 2.4 version of qeth; network may hang under
               stress
  Problem:     inbound and outbound traffic handled by tasklets does not perform
               as well as when buffers were handled directly in interrupt
               handler
  Solution:    remove inbound and outbound tasklets and handle buffers directly
               in interrupt handlers
  Problem-ID:  7789
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth.h	6 Apr 2004 14:38:19 -0000	1.98
+++ linux-2.5/drivers/s390/net/qeth.h	21 Apr 2004 15:24:04 -0000	1.98.2.1
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.98 $"
+#define VERSION_QETH_H 		"$Revision: 1.98.2.1 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -423,14 +423,12 @@
 	struct qeth_qdio_out_buffer bufs[QDIO_MAX_BUFFERS_PER_Q];
 	int queue_no;
 	struct qeth_card *card;
-	struct tasklet_struct tasklet;
 	spinlock_t lock;
 	volatile int do_pack;
 	/*
 	 * index of buffer to be filled by driver; state EMPTY or PACKING
 	 */
 	volatile int next_buf_to_fill;
-	volatile int next_buf_to_flush;
 	/*
 	 * number of buffers that are currently filled (PRIMED)
 	 * -> these buffers are hardware-owned
@@ -447,7 +445,6 @@
 	struct qeth_qdio_buffer_pool in_buf_pool;
 	struct qeth_qdio_buffer_pool init_pool;
 	int in_buf_size;
-	struct tasklet_struct in_tasklet;
 
 	/* output */
 	int no_out_queues;

--- linux-2.5/drivers/s390/net/qeth_main.c	13 Apr 2004 09:19:12 -0000	1.77.2.1
+++ linux-2.5/drivers/s390/net/qeth_main.c	21 Apr 2004 15:24:04 -0000	1.77.2.2
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.1 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.2 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.1 $	 $Date: 2004/04/13 09:19:12 $
+ *    $Revision: 1.77.2.2 $	 $Date: 2004/04/21 15:24:04 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.1 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.2 $"
 static const char *version = "qeth S/390 OSA-Express driver ("
 	VERSION_QETH_C "/" VERSION_QETH_H "/" VERSION_QETH_MPC_H
 	QETH_VERSION_IPV6 QETH_VERSION_VLAN ")";
@@ -823,7 +823,7 @@
 	struct qeth_card *card;
 
 	card = (struct qeth_card *) ptr;
-	daemonize("getmcaddr");
+	daemonize("qeth_get_mcaddrs");
 	QETH_DBF_TEXT(trace,4,"regmcth1");
 	if (!qeth_do_run_thread(card, QETH_SET_MC_THREAD))
 		return 0;
@@ -844,7 +844,7 @@
 	struct qeth_card *card;
 
 	card = (struct qeth_card *) ptr;
-	daemonize("regip");
+	daemonize("qeth_reg_ip");
 	QETH_DBF_TEXT(trace,4,"regipth1");
 	if (!qeth_do_run_thread(card, QETH_SET_IP_THREAD))
 		return 0;
@@ -861,7 +861,7 @@
 	int rc = 0;
 	
 	card = (struct qeth_card *) ptr;
-	daemonize("recover");
+	daemonize("qeth_recover");
 	QETH_DBF_TEXT(trace,2,"recover1");
 	QETH_DBF_HEX(trace, 2, &card, sizeof(void *));
 	if (!qeth_do_run_thread(card, QETH_RECOVER_THREAD))
@@ -1970,45 +1970,6 @@
 	return rc;
 }
 
-static void
-qeth_qdio_input_handler(struct ccw_device * ccwdev, unsigned int status,
-		        unsigned int qdio_err, unsigned int siga_err,
-			unsigned int queue, int first_element, int count,
-			unsigned long card_ptr)
-{
-	struct net_device *net_dev;
-	struct qeth_card *card;
-	struct qeth_qdio_buffer *buffer;
-	int i;
-
-	QETH_DBF_TEXT(trace, 6, "qdinput");
-	card = (struct qeth_card *) card_ptr;
-	net_dev = card->dev;
-#ifdef CONFIG_QETH_PERF_STATS
-	card->perf_stats.inbound_start_time = qeth_get_micros();
-#endif
-	if (status & QDIO_STATUS_LOOK_FOR_ERROR) {
-		if (status & QDIO_STATUS_ACTIVATE_CHECK_CONDITION){
-			QETH_DBF_TEXT(trace, 1,"qdinchk");
-			QETH_DBF_TEXT_(trace,1,"%s",CARD_BUS_ID(card));
-			QETH_DBF_TEXT_(trace,1,"%04X%04X",first_element,count);
-			QETH_DBF_TEXT_(trace,1,"%04X%04X", queue, status);
-			qeth_schedule_recovery(card);
-			return;
-		}
-	}
-	for (i = first_element; i < (first_element + count); ++i) {
-		buffer = &card->qdio.in_q->bufs[i % QDIO_MAX_BUFFERS_PER_Q];
-		if ((status == QDIO_STATUS_LOOK_FOR_ERROR) &&
-		    qeth_check_for_inbound_error(buffer, qdio_err, siga_err))
-			buffer->state = QETH_QDIO_BUF_ERROR;
-		else
-			buffer->state = QETH_QDIO_BUF_PRIMED;
-	}
-	
-	tasklet_schedule(&card->qdio.in_tasklet);
-}
-
 static inline struct sk_buff *
 qeth_get_skb(unsigned int length)
 {
@@ -2242,6 +2203,38 @@
 	qeth_rebuild_skb_vlan(card, skb, hdr);
 }
 
+static inline void
+qeth_process_inbound_buffer(struct qeth_card *card,
+			    struct qeth_qdio_buffer *buf, int index)
+{
+	struct qdio_buffer_element *element;
+	int offset;
+	struct sk_buff *skb;
+	struct qeth_hdr *hdr;
+	int rxrc;
+	
+	/* get first element of current buffer */
+	element = (struct qdio_buffer_element *)&buf->buffer->element[0];
+	offset = 0;
+#ifdef CONFIG_QETH_PERF_STATS
+	card->perf_stats.bufs_rec++;
+#endif
+	while((skb = qeth_get_next_skb(card, buf->buffer, &element,
+				       &offset, &hdr))){
+		qeth_rebuild_skb(card, skb, hdr);
+
+#ifdef CONFIG_QETH_PERF_STATS
+		card->perf_stats.inbound_time += qeth_get_micros() -
+			card->perf_stats.inbound_start_time;
+		card->perf_stats.inbound_cnt++;
+#endif
+		skb->dev = card->dev;
+		rxrc = netif_rx(skb);
+		card->dev->last_rx = jiffies;
+		card->stats.rx_packets++;
+		card->stats.rx_bytes += skb->len;
+	}
+}
 
 static inline struct qeth_buffer_pool_entry *
 qeth_get_buffer_pool_entry(struct qeth_card *card)
@@ -2285,7 +2278,7 @@
 	buf->state = QETH_QDIO_BUF_EMPTY;
 }
 
-static void
+static inline void
 qeth_clear_output_buffer(struct qeth_card *card,
 			 struct qeth_qdio_out_buffer *buf)
 {
@@ -2356,61 +2349,43 @@
 }
 
 static void
-qeth_qdio_input_tasklet(unsigned long data)
+qeth_qdio_input_handler(struct ccw_device * ccwdev, unsigned int status,
+		        unsigned int qdio_err, unsigned int siga_err,
+			unsigned int queue, int first_element, int count,
+			unsigned long card_ptr)
 {
-	struct qeth_card *card = (struct qeth_card *) data;
-	int current_buf = card->qdio.in_q->next_buf_to_process;
-	struct qeth_qdio_buffer *buf;
-	struct qdio_buffer_element *element;
-	int offset;
-	struct sk_buff *skb;
-	struct qeth_hdr *hdr;
-	int rxrc;
-	
-	QETH_DBF_TEXT(trace,6,"qdintlet");
-	buf = &card->qdio.in_q->bufs[current_buf];
-	while((buf->state == QETH_QDIO_BUF_PRIMED) ||
-	      (buf->state == QETH_QDIO_BUF_ERROR)){
-		if (buf->state == QETH_QDIO_BUF_ERROR)
-			goto clear_buffer;
-		if (netif_queue_stopped(card->dev))
-			goto clear_buffer;
-		/* get first element of current buffer */
-		element = (struct qdio_buffer_element *)
-			&buf->buffer->element[0];
-		offset = 0;
-#ifdef CONFIG_QETH_PERF_STATS
-		card->perf_stats.bufs_rec++;
-#endif
-		while((skb = qeth_get_next_skb(card, buf->buffer, &element,
-					       &offset, &hdr))){
+	struct net_device *net_dev;
+	struct qeth_card *card;
+	struct qeth_qdio_buffer *buffer;
+	int index;
+	int i;
 
-			qeth_rebuild_skb(card, skb, hdr);
+	QETH_DBF_TEXT(trace, 6, "qdinput");
+	card = (struct qeth_card *) card_ptr;
+	net_dev = card->dev;
 #ifdef CONFIG_QETH_PERF_STATS
-			card->perf_stats.inbound_time += qeth_get_micros() -
-				card->perf_stats.inbound_start_time;
-			card->perf_stats.inbound_cnt++;
+	card->perf_stats.inbound_start_time = qeth_get_micros();
 #endif
-			skb->dev = card->dev;
-			if (netif_queue_stopped(card->dev)) {
-				dev_kfree_skb_irq(skb);
-				card->stats.rx_dropped++;
-			} else {
-				rxrc = netif_rx(skb);
-				card->dev->last_rx = jiffies;
-				card->stats.rx_packets++;
-				card->stats.rx_bytes += skb->len;
-			}
+	if (status & QDIO_STATUS_LOOK_FOR_ERROR) {
+		if (status & QDIO_STATUS_ACTIVATE_CHECK_CONDITION){
+			QETH_DBF_TEXT(trace, 1,"qdinchk");
+			QETH_DBF_TEXT_(trace,1,"%s",CARD_BUS_ID(card));
+			QETH_DBF_TEXT_(trace,1,"%04X%04X",first_element,count);
+			QETH_DBF_TEXT_(trace,1,"%04X%04X", queue, status);
+			qeth_schedule_recovery(card);
+			return;
 		}
-clear_buffer:
-		qeth_put_buffer_pool_entry(card, buf->pool_entry);
-		/* give buffer back to hardware */
-		qeth_queue_input_buffer(card, current_buf);
-		current_buf = (current_buf + 1) % QDIO_MAX_BUFFERS_PER_Q;
-		buf = &card->qdio.in_q->bufs[current_buf];
 	}
-	/* set index for next time the tasklet is scheduled */
-	card->qdio.in_q->next_buf_to_process = current_buf;
+	for (i = first_element; i < (first_element + count); ++i) {
+		index = i % QDIO_MAX_BUFFERS_PER_Q;
+		buffer = &card->qdio.in_q->bufs[index];
+		if (!((status == QDIO_STATUS_LOOK_FOR_ERROR) &&
+		      qeth_check_for_inbound_error(buffer, qdio_err, siga_err)))
+			qeth_process_inbound_buffer(card, buffer, index);
+		/* clear buffer and give back to hardware */
+		qeth_put_buffer_pool_entry(card, buffer->pool_entry);
+		qeth_queue_input_buffer(card, index);
+	}
 }
 
 static inline int
@@ -2525,11 +2500,12 @@
  * switches between PACKING and non-PACKING state if needed.
  * has to be called holding queue->lock
  */
-static inline void
+static inline int
 qeth_switch_packing_state(struct qeth_qdio_out_q *queue)
 {
 	struct qeth_qdio_out_buffer *buffer;
-	
+	int flush_count = 0;
+
 	QETH_DBF_TEXT(trace, 6, "swipack");
 	if (!queue->do_pack) {
 		if (atomic_read(&queue->used_buffers)
@@ -2555,13 +2531,33 @@
 			BUG_ON(buffer->state == QETH_QDIO_BUF_PRIMED);
 			if (buffer->next_element_to_fill > 0) {
 				buffer->state = QETH_QDIO_BUF_PRIMED;
+				flush_count++;
 				atomic_inc(&queue->used_buffers);
-				queue->next_buf_to_fill = 
-					(queue->next_buf_to_fill + 1) % 
+				queue->next_buf_to_fill =
+					(queue->next_buf_to_fill + 1) %
 					QDIO_MAX_BUFFERS_PER_Q;
 		 	}
 		}
 	}
+	return flush_count;
+}
+
+static inline void
+qeth_flush_buffers_on_no_pci(struct qeth_qdio_out_q *queue, int under_int)
+{
+	struct qeth_qdio_out_buffer *buffer;
+	
+	buffer = &queue->bufs[queue->next_buf_to_fill];
+	BUG_ON(buffer->state == QETH_QDIO_BUF_PRIMED);
+	if (buffer->next_element_to_fill > 0){
+		/* it's a packing buffer */
+		buffer->state = QETH_QDIO_BUF_PRIMED;
+		atomic_inc(&queue->used_buffers);
+		qeth_flush_buffers(queue, under_int, queue->next_buf_to_fill,
+				   1);
+		queue->next_buf_to_fill =
+			(queue->next_buf_to_fill + 1) % QDIO_MAX_BUFFERS_PER_Q;
+	}
 }
 
 static void
@@ -2604,58 +2600,12 @@
 			atomic_dec(&queue->set_pci_flags_count);
 
 		qeth_clear_output_buffer(card, buffer);
+		atomic_dec(&queue->used_buffers);
 	}
-	atomic_sub(count, &queue->used_buffers);
 
-	//if (!atomic_read(&queue->set_pci_flags_count))
-		tasklet_schedule(&queue->tasklet);
-	
 	netif_wake_queue(card->dev);
 }
 
-static void
-qeth_qdio_output_tasklet(unsigned long data)
-{
-	struct qeth_qdio_out_q *queue = (struct qeth_qdio_out_q *) data;
-	struct qeth_qdio_out_buffer *buffer;
-	int index;
-	int count;
-	
-	QETH_DBF_TEXT(trace, 6, "outtlet");
-	
-	/* flush all PRIMED buffers */
-	index = queue->next_buf_to_flush;
-	count = 0;
-	while (queue->bufs[index].state == QETH_QDIO_BUF_PRIMED) {
-		count++;
-		index = (index + 1) % QDIO_MAX_BUFFERS_PER_Q;
-	}
-	qeth_flush_buffers(queue, 0, queue->next_buf_to_flush, count);
-	queue->next_buf_to_flush = index;
-
-	/* flush a buffer with data, if no more PCIs are
-	 * outstanding */
-	if (!atomic_read(&queue->set_pci_flags_count)){
-		spin_lock(&queue->lock);
-		buffer = &queue->bufs[index];
-		if (buffer->state == QETH_QDIO_BUF_PRIMED){
-			qeth_flush_buffers(queue, 0, index, 1);
-			index = (index + 1) % QDIO_MAX_BUFFERS_PER_Q;
-			queue->next_buf_to_flush = index;
-		} else if (buffer->next_element_to_fill > 0){
-			/* it's a packing buffer */
-			BUG_ON(index != queue->next_buf_to_fill);
-			buffer->state = QETH_QDIO_BUF_PRIMED;
-			atomic_inc(&queue->used_buffers);
-			qeth_flush_buffers(queue, 0, index, 1);
-			index = (index + 1) % QDIO_MAX_BUFFERS_PER_Q;
-			queue->next_buf_to_flush = index;
-			queue->next_buf_to_fill = index;
-		}
-		spin_unlock(&queue->lock);
-	}
-}
-
 static char*
 qeth_create_qib_param_field(struct qeth_card *card)
 {
@@ -2859,8 +2809,6 @@
 	card->qdio.in_buf_pool.buf_count = card->qdio.init_pool.buf_count;
 	INIT_LIST_HEAD(&card->qdio.in_buf_pool.entry_list);
 	INIT_LIST_HEAD(&card->qdio.init_pool.entry_list);
-	card->qdio.in_tasklet.data = (unsigned long) card;
-	card->qdio.in_tasklet.func = qeth_qdio_input_tasklet;
 	/* outbound */
 	card->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;
 	card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
@@ -2904,13 +2852,9 @@
 		}
 		card->qdio.out_qs[i]->card = card;
 		card->qdio.out_qs[i]->next_buf_to_fill = 0;
-		card->qdio.out_qs[i]->next_buf_to_flush = 0;
 		card->qdio.out_qs[i]->do_pack = 0;
 		atomic_set(&card->qdio.out_qs[i]->used_buffers,0);
 		atomic_set(&card->qdio.out_qs[i]->set_pci_flags_count, 0);
-		card->qdio.out_qs[i]->tasklet.data = 
-			(unsigned long) card->qdio.out_qs[i];
-		card->qdio.out_qs[i]->tasklet.func = qeth_qdio_output_tasklet;
 		spin_lock_init(&card->qdio.out_qs[i]->lock);
 	}
 	return 0;
@@ -3654,6 +3598,8 @@
 	struct qeth_hdr *hdr;
 	struct qeth_qdio_out_buffer *buffer;
 	int elements_needed;
+	int start_index;
+	int flush_count = 0;
 	int rc;
 
 	QETH_DBF_TEXT(trace, 6, "dosndpkt");
@@ -3670,11 +3616,9 @@
 				 "IP packet. Discarded.");
 		return -EINVAL;
 	}
-	
+
 	spin_lock(&queue->lock);
-	/* check if we need to switch packing state of this queue */
-	if (card->info.type != QETH_CARD_TYPE_IQD)
-		qeth_switch_packing_state(queue);
+	start_index = queue->next_buf_to_fill;
 	buffer = &queue->bufs[queue->next_buf_to_fill];
 	BUG_ON(buffer->state == QETH_QDIO_BUF_PRIMED);
 	if (queue->do_pack){
@@ -3683,31 +3627,38 @@
 				< elements_needed){
 			/* ... no -> set state PRIMED */
 			buffer->state = QETH_QDIO_BUF_PRIMED;
+			flush_count++;
 			atomic_inc(&queue->used_buffers);
 			queue->next_buf_to_fill =
 				(queue->next_buf_to_fill + 1) %
 				QDIO_MAX_BUFFERS_PER_Q;
 			buffer = &queue->bufs[queue->next_buf_to_fill];
 		}
-	} 
-	
+	}
+
 	rc = qeth_fill_buffer(queue, buffer, (char *)hdr, skb);
 	if (rc) {
 		PRINT_WARN("qeth_do_send_packet: error during "
 			      "qeth_fill_buffer.");
 		card->stats.tx_dropped++;
-		spin_unlock(&queue->lock);
-		return rc;
-	}
-	if (buffer->state == QETH_QDIO_BUF_PRIMED){
+	} else if (buffer->state == QETH_QDIO_BUF_PRIMED){
 		/* next time fill the next buffer */
+		flush_count++;
 		atomic_inc(&queue->used_buffers);
 		queue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %
 			QDIO_MAX_BUFFERS_PER_Q;
 	}
-	spin_unlock(&queue->lock);
+	/* check if we need to switch packing state of this queue */
+	if (card->info.type != QETH_CARD_TYPE_IQD)
+		flush_count += qeth_switch_packing_state(queue);
+	
+	if (flush_count)
+		qeth_flush_buffers(queue, 0, start_index, flush_count);
 
-	tasklet_schedule(&queue->tasklet);
+	if (!atomic_read(&queue->set_pci_flags_count))
+		qeth_flush_buffers_on_no_pci(queue, 0);
+	
+	spin_unlock(&queue->lock);
 	
 	return rc;
 }
@@ -4684,29 +4635,29 @@
 		memcpy(cmd->data.setdelip4.mask, &addr->u.a4.mask, 4);
 		cmd->data.setdelip4.flags = flags;
 	}
-	
+
 	rc = qeth_send_ipa_cmd(card, iob, NULL, NULL);
 
 	return rc;
 }
 
-static int 
+static int
 qeth_register_addr_entry(struct qeth_card *card, struct qeth_ipaddr *addr)
 {
 	//char buf[50];
 	int rc;
 	int cnt = 3;
-	
+
 	if (addr->proto == QETH_PROT_IPV4) {
 		QETH_DBF_TEXT(trace, 2,"setaddr4");
-		QETH_DBF_HEX(trace, 4, &addr->u.a4.addr, sizeof(int));
+		QETH_DBF_HEX(trace, 3, &addr->u.a4.addr, sizeof(int));
 	} else if (addr->proto == QETH_PROT_IPV6) {
 		QETH_DBF_TEXT(trace, 2, "setaddr6");
-		QETH_DBF_HEX(trace,4,&addr->u.a6.addr,4);
-		QETH_DBF_HEX(trace,4,((char *)&addr->u.a6.addr)+4,4);
+		QETH_DBF_HEX(trace,3,&addr->u.a6.addr,8);
+		QETH_DBF_HEX(trace,3,((char *)&addr->u.a6.addr)+8,8);
 	} else {
 		QETH_DBF_TEXT(trace, 2, "setaddr?");
-		QETH_DBF_HEX(trace, 4, addr, sizeof(struct qeth_ipaddr));
+		QETH_DBF_HEX(trace, 3, addr, sizeof(struct qeth_ipaddr));
 	}
 	do {
 		if (addr->is_multicast)
@@ -4734,17 +4685,17 @@
 {
 	//char buf[50];
 	int rc;
-	
+
 	if (addr->proto == QETH_PROT_IPV4) {
 		QETH_DBF_TEXT(trace, 2,"deladdr4");
-		QETH_DBF_HEX(trace, 2, &addr->u.a4.addr, sizeof(int));
+		QETH_DBF_HEX(trace, 3, &addr->u.a4.addr, sizeof(int));
 	} else if (addr->proto == QETH_PROT_IPV6) {
 		QETH_DBF_TEXT(trace, 2, "deladdr6");
-		QETH_DBF_HEX(trace, 2, &addr->u.a6.addr,
-			     sizeof(struct in6_addr));
+		QETH_DBF_HEX(trace,3,&addr->u.a6.addr,8);
+		QETH_DBF_HEX(trace,3,((char *)&addr->u.a6.addr)+8,8);
 	} else {
 		QETH_DBF_TEXT(trace, 2, "deladdr?");
-		QETH_DBF_HEX(trace, 2, addr, sizeof(struct qeth_ipaddr));
+		QETH_DBF_HEX(trace, 3, addr, sizeof(struct qeth_ipaddr));
 	}
 	if (addr->is_multicast)
 		rc = qeth_send_setdelmc(card, addr, IPA_CMD_DELIPM);
@@ -6525,12 +6476,12 @@
 
 	switch(event) {
 	case NETDEV_UP:
-			if (!qeth_add_ip(card, addr))
-				kfree(addr);
+		if (!qeth_add_ip(card, addr))
+			kfree(addr);
 		break;
 	case NETDEV_DOWN:
-			if (!qeth_delete_ip(card, addr))
-				kfree(addr);
+		if (!qeth_delete_ip(card, addr))
+			kfree(addr);
 		break;
 	default:
 		break;
@@ -6575,15 +6526,15 @@
 		addr->type = QETH_IP_TYPE_NORMAL;
 	} else
 		goto out;
-	
+
 	switch(event) {
 	case NETDEV_UP:
-			if (!qeth_add_ip(card, addr))
-				kfree(addr);
+		if (!qeth_add_ip(card, addr))
+			kfree(addr);
 		break;
 	case NETDEV_DOWN:
-			if (!qeth_delete_ip(card, addr))
-				kfree(addr);
+		if (!qeth_delete_ip(card, addr))
+			kfree(addr);
 		break;
 	default:
 		break;

