- Description: qeth: HiperSockets performance loss compared to Linux 2.4
  Symptom:     With certain workloads a performance loss compared to the
               Linux 2.4 version of qeth may be experienced.
  Problem:     Inefficient qdio queue handling for HiperSockets.
  Solution:    Optimized qdio queue handling for HiperSockets. Introdcuced
               function qeth_do_send_packet_fast as shortcut for HiperSockets.
               Also added some more performance statistics to improve
               performance tracking.
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth.h	14 May 2004 11:53:24 -0000	1.98.2.7
+++ linux-2.5/drivers/s390/net/qeth.h	24 May 2004 15:35:17 -0000	1.98.2.8
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.98.2.7 $"
+#define VERSION_QETH_H 		"$Revision: 1.98.2.8 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -179,15 +179,26 @@
 
 	unsigned int sc_dp_p;
 	unsigned int sc_p_dp;
-
+	/* qdio_input_handler: number of times called, time spent in */
 	__u64 inbound_start_time;
 	unsigned int inbound_cnt;
 	unsigned int inbound_time;
+	/* qeth_send_packet: number of times called, time spent in */
 	__u64 outbound_start_time;
 	unsigned int outbound_cnt;
 	unsigned int outbound_time;
-	unsigned int inbound_do_qdio;
-	unsigned int outbound_do_qdio;
+	/* qdio_output_handler: number of times called, time spent in */
+	__u64 outbound_handler_start_time;
+	unsigned int outbound_handler_cnt;
+	unsigned int outbound_handler_time;
+	/* number of calls to and time spent in do_QDIO for inbound queue */
+	__u64 inbound_do_qdio_start_time;
+	unsigned int inbound_do_qdio_cnt;
+	unsigned int inbound_do_qdio_time;
+	/* number of calls to and time spent in do_QDIO for outbound queues */
+	__u64 outbound_do_qdio_start_time;
+	unsigned int outbound_do_qdio_cnt;
+	unsigned int outbound_do_qdio_time;
 };
 #endif /* CONFIG_QETH_PERF_STATS */
 

--- linux-2.5/drivers/s390/net/qeth_main.c	14 May 2004 11:53:24 -0000	1.77.2.13
+++ linux-2.5/drivers/s390/net/qeth_main.c	24 May 2004 15:35:17 -0000	1.77.2.14
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.13 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.14 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.13 $	 $Date: 2004/05/14 11:53:24 $
+ *    $Revision: 1.77.2.14 $	 $Date: 2004/05/24 15:35:17 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.13 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.14 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -2327,11 +2327,16 @@
 		 * will be requeued the next time
 		 */
 #ifdef CONFIG_QETH_PERF_STATS
-		card->perf_stats.inbound_do_qdio++;
+		card->perf_stats.inbound_do_qdio_cnt++;
+		card->perf_stats.inbound_do_qdio_start_time = qeth_get_micros();
 #endif
 		rc = do_QDIO(CARD_DDEV(card),
-			     QDIO_FLAG_SYNC_INPUT,
+			     QDIO_FLAG_SYNC_INPUT | QDIO_FLAG_UNDER_INTERRUPT,
 			     0, queue->next_buf_to_init, count, NULL);
+#ifdef CONFIG_QETH_PERF_STATS
+		card->perf_stats.inbound_do_qdio_time += qeth_get_micros() -
+			card->perf_stats.inbound_do_qdio_start_time;
+#endif
 		if (rc){
 			PRINT_WARN("qeth_queue_input_buffer's do_QDIO "
 				   "return %i (device %s).\n",
@@ -2453,6 +2458,9 @@
 		buf->buffer->element[buf->next_element_to_fill - 1].flags |=
 				SBAL_FLAGS_LAST_ENTRY;
 
+		if (queue->card->info.type == QETH_CARD_TYPE_IQD)
+			continue;
+
 		if (!queue->do_pack){
 			if ((atomic_read(&queue->used_buffers) >= 
 		    		(QETH_HIGH_WATERMARK_PACK -
@@ -2484,7 +2492,8 @@
 
 	queue->card->dev->trans_start = jiffies;
 #ifdef CONFIG_QETH_PERF_STATS
-		queue->card->perf_stats.outbound_do_qdio++;
+	queue->card->perf_stats.outbound_do_qdio_cnt++;
+	queue->card->perf_stats.outbound_do_qdio_start_time = qeth_get_micros();
 #endif
 	if (under_int)
 		rc = do_QDIO(CARD_DDEV(queue->card),
@@ -2493,6 +2502,10 @@
 	else
 		rc = do_QDIO(CARD_DDEV(queue->card), QDIO_FLAG_SYNC_OUTPUT,
 			     queue->queue_no, index, count, NULL);
+#ifdef CONFIG_QETH_PERF_STATS
+	queue->card->perf_stats.outbound_do_qdio_time += qeth_get_micros() -
+		queue->card->perf_stats.outbound_do_qdio_start_time;
+#endif
 	if (rc){
 		QETH_DBF_SPRINTF(trace, 0, "qeth_flush_buffers: do_QDIO "
 				 "returned error (%i) on device %s.",
@@ -2597,6 +2610,10 @@
 		}
 	}
 	
+#ifdef CONFIG_QETH_PERF_STATS
+	card->perf_stats.outbound_handler_cnt++;
+	card->perf_stats.outbound_handler_start_time = qeth_get_micros();
+#endif
 	for(i = first_element; i < (first_element + count); ++i){
 		buffer = &queue->bufs[i % QDIO_MAX_BUFFERS_PER_Q];
 		/*we only handle the KICK_IT error by doing a recovery */
@@ -2615,6 +2632,10 @@
 	}
 
 	netif_wake_queue(card->dev);
+#ifdef CONFIG_QETH_PERF_STATS
+	card->perf_stats.outbound_handler_time += qeth_get_micros() -
+		card->perf_stats.outbound_handler_start_time;
+#endif
 }
 
 static char*
@@ -2856,9 +2877,6 @@
 	for (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)
 		qeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);
 	card->qdio.in_q->next_buf_to_init = card->qdio.in_buf_pool.buf_count - 1;
-#ifdef CONFIG_QETH_PERF_STATS
-		card->perf_stats.inbound_do_qdio++;
-#endif
 	rc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0, 0,
 		     card->qdio.in_buf_pool.buf_count - 1, NULL);
 	if (rc) {
@@ -3192,10 +3210,6 @@
 		card->stats.tx_carrier_errors++;
 		return -EIO;
 	}
-	if (netif_queue_stopped(dev) ) {
-		card->stats.tx_dropped++;
-		return -EBUSY;
-	}
 #ifdef CONFIG_QETH_PERF_STATS
 	card->perf_stats.outbound_cnt++;
 	card->perf_stats.outbound_start_time = qeth_get_micros();
@@ -3612,33 +3626,59 @@
 }
 
 static inline int
-qeth_do_send_packet(struct qeth_card *card, struct sk_buff *skb,
-		    struct qeth_qdio_out_q *queue, int ipv,
-		    int cast_type)
+qeth_do_send_packet_fast(struct qeth_card *card, struct qeth_qdio_out_q *queue,
+			 struct sk_buff *skb, struct qeth_hdr *hdr,
+			 int elements_needed)
+{
+	struct qeth_qdio_out_buffer *buffer;
+	int index;
+	int rc = 0;
+
+	QETH_DBF_TEXT(trace, 6, "dosndpfa");
+
+	spin_lock(&queue->lock);
+	/* do we have empty buffers? */
+	if (atomic_read(&queue->used_buffers) >= (QDIO_MAX_BUFFERS_PER_Q - 1)){
+		card->stats.tx_dropped++;
+		rc = -EBUSY;
+		spin_unlock(&queue->lock);
+		goto out;
+	}
+	index = queue->next_buf_to_fill;
+	buffer = &queue->bufs[queue->next_buf_to_fill];
+	BUG_ON(buffer->state == QETH_QDIO_BUF_PRIMED);
+	queue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %
+				  QDIO_MAX_BUFFERS_PER_Q;
+	atomic_inc(&queue->used_buffers);
+	spin_unlock(&queue->lock);
+
+	/* go on sending ... */
+	netif_wake_queue(skb->dev);
+	qeth_fill_buffer(queue, buffer, (char *)hdr, skb);
+	qeth_flush_buffers(queue, 0, index, 1);
+out:
+	return rc;
+}
+
+static inline int
+qeth_do_send_packet(struct qeth_card *card, struct qeth_qdio_out_q *queue,
+		    struct sk_buff *skb, struct qeth_hdr *hdr,
+		    int elements_needed)
 {
-	struct qeth_hdr *hdr;
 	struct qeth_qdio_out_buffer *buffer;
-	int elements_needed;
 	int start_index;
 	int flush_count = 0;
-	int rc;
+	int rc = 0;
 
 	QETH_DBF_TEXT(trace, 6, "dosndpkt");
 
-	if ((rc = qeth_prepare_skb(card, &skb, &hdr, ipv))){
-		QETH_DBF_TEXT_(trace, 4, "1err%d", rc);
-		return rc;
-	}
-	qeth_fill_header(card, hdr, skb, ipv, cast_type);
-	elements_needed = 1 + (((((unsigned long) hdr) % PAGE_SIZE) + skb->len)
-				>> PAGE_SHIFT);
-	if (elements_needed > QETH_MAX_BUFFER_ELEMENTS(card)){
-		PRINT_ERR("qeth_do_send_packet: invalid size of "
-				 "IP packet. Discarded.");
-		return -EINVAL;
-	}
-
 	spin_lock(&queue->lock);
+	/* do we have empty buffers? */
+	if (atomic_read(&queue->used_buffers) >= (QDIO_MAX_BUFFERS_PER_Q - 2)){
+		card->stats.tx_dropped++;
+		rc = -EBUSY;
+		goto out;
+	}
 	start_index = queue->next_buf_to_fill;
 	buffer = &queue->bufs[queue->next_buf_to_fill];
 	BUG_ON(buffer->state == QETH_QDIO_BUF_PRIMED);
@@ -3657,12 +3697,8 @@
 		}
 	}
 
-	rc = qeth_fill_buffer(queue, buffer, (char *)hdr, skb);
-	if (rc) {
-		PRINT_WARN("qeth_do_send_packet: error during "
-			      "qeth_fill_buffer.");
-		card->stats.tx_dropped++;
-	} else if (buffer->state == QETH_QDIO_BUF_PRIMED){
+	qeth_fill_buffer(queue, buffer, (char *)hdr, skb);
+	if (buffer->state == QETH_QDIO_BUF_PRIMED){
 		/* next time fill the next buffer */
 		flush_count++;
 		atomic_inc(&queue->used_buffers);
@@ -3670,7 +3706,6 @@
 			QDIO_MAX_BUFFERS_PER_Q;
 	}
 	/* check if we need to switch packing state of this queue */
-	if (card->info.type != QETH_CARD_TYPE_IQD)
 		flush_count += qeth_switch_packing_state(queue);
 	
 	if (flush_count)
@@ -3678,7 +3713,7 @@
 
 	if (!atomic_read(&queue->set_pci_flags_count))
 		qeth_flush_buffers_on_no_pci(queue, 0);
-	
+out:
 	spin_unlock(&queue->lock);
 	
 	return rc;
@@ -3690,6 +3725,8 @@
 	int ipv;
 	int cast_type;
 	struct qeth_qdio_out_q *queue;
+	struct qeth_hdr *hdr;
+	int elements_needed;
 	int rc;
 
 	QETH_DBF_TEXT(trace, 6, "sendpkt");
@@ -3698,16 +3735,26 @@
 	cast_type = qeth_get_cast_type(card, skb);
 	queue = card->qdio.out_qs
 		[qeth_get_priority_queue(card, skb, ipv, cast_type)];
-	/* do we have empty buffers? */
-	rc = (atomic_read(&queue->used_buffers) >= 
-	      QDIO_MAX_BUFFERS_PER_Q - 1) ? -EBUSY : 0;
-	if (rc) {
-		card->stats.tx_dropped++;
+
+	if ((rc = qeth_prepare_skb(card, &skb, &hdr, ipv))){
 		QETH_DBF_TEXT_(trace, 4, "1err%d", rc);
 		return rc;
 	}
+	qeth_fill_header(card, hdr, skb, ipv, cast_type);
+	elements_needed = 1 + (((((unsigned long) hdr) % PAGE_SIZE) + skb->len)
+				>> PAGE_SHIFT);
+	if (elements_needed > QETH_MAX_BUFFER_ELEMENTS(card)){
+		PRINT_ERR("qeth_do_send_packet: invalid size of "
+				 "IP packet. Discarded.");
+		return -EINVAL;
+	}
 
-	rc = qeth_do_send_packet(card, skb, queue, ipv, cast_type);
+	if (card->info.type != QETH_CARD_TYPE_IQD)
+		rc = qeth_do_send_packet(card, queue, skb, hdr,
+					 elements_needed);
+	else
+		rc = qeth_do_send_packet_fast(card, queue, skb, hdr,
+					      elements_needed);
 
 	if (!rc){
 		card->stats.tx_packets++;

--- linux-2.5/drivers/s390/net/qeth_proc.c	14 May 2004 10:32:08 -0000	1.5.2.3
+++ linux-2.5/drivers/s390/net/qeth_proc.c	24 May 2004 15:35:17 -0000	1.5.2.4
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_fs.c ($Revision: 1.5.2.3 $)
+ * linux/drivers/s390/net/qeth_fs.c ($Revision: 1.5.2.4 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to procfs.
@@ -21,7 +21,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-const char *VERSION_QETH_PROC_C = "$Revision: 1.5.2.3 $";
+const char *VERSION_QETH_PROC_C = "$Revision: 1.5.2.4 $";
 
 /***** /proc/qeth *****/
 #define QETH_PROCFILE_NAME "qeth"
@@ -237,9 +237,11 @@
 		   card->perf_stats.bufs_sent_pack
 		  );
 	seq_printf(s, "  Packing state changes no pkg.->packing : %i/%i\n"
+		      "  Watermarks L/H                         : %i/%i\n"
 		      "  Current buffer usage (outbound q's)    : "
 		      "%i/%i/%i/%i\n\n",
 		        card->perf_stats.sc_dp_p, card->perf_stats.sc_p_dp,
+			QETH_LOW_WATERMARK_PACK, QETH_HIGH_WATERMARK_PACK,
 			atomic_read(&card->qdio.out_qs[0]->used_buffers),
 			(card->qdio.no_out_queues > 1)?
 				atomic_read(&card->qdio.out_qs[1]->used_buffers)
@@ -251,20 +253,26 @@
 				atomic_read(&card->qdio.out_qs[3]->used_buffers)
 				: 0
 		  );
-	seq_printf(s, "  Inbound time (in us)                   : %i\n"
-		      "  Inbound count                          : %i\n"
-		      "  Inboud do_QDIO count                   : %i\n"
+	seq_printf(s, "  Inbound handler time (in us)           : %i\n"
+		      "  Inbound handler count                  : %i\n"
+		      "  Inbound do_QDIO time (in us)           : %i\n"
+		      "  Inbound do_QDIO count                  : %i\n\n"
+		      "  Outbound handler time (in us)          : %i\n"
+		      "  Outbound handler count                 : %i\n\n"
 		      "  Outbound time (in us, incl QDIO)       : %i\n"
 		      "  Outbound count                         : %i\n"
-		      "  Outbound do_QDIO count                 : %i\n"
-		      "  Watermarks L/H                         : %i/%i\n\n",
+		      "  Outbound do_QDIO time (in us)          : %i\n"
+		      "  Outbound do_QDIO count                 : %i\n",
 		        card->perf_stats.inbound_time,
 			card->perf_stats.inbound_cnt,
-			card->perf_stats.inbound_do_qdio,
+		        card->perf_stats.inbound_do_qdio_time,
+			card->perf_stats.inbound_do_qdio_cnt,
+			card->perf_stats.outbound_handler_time,
+			card->perf_stats.outbound_handler_cnt,
 			card->perf_stats.outbound_time,
 			card->perf_stats.outbound_cnt,
-			card->perf_stats.outbound_do_qdio,
-			QETH_LOW_WATERMARK_PACK, QETH_HIGH_WATERMARK_PACK
+		        card->perf_stats.outbound_do_qdio_time,
+			card->perf_stats.outbound_do_qdio_cnt
 		  );
 
 	return 0;

