From: Martin Peschke <mp3@de.ibm.com>
Subject: [patch] zfcp: performance statistics.
References: 149742 - LTC21427

Add statistics interface and make use of it in the zfcp driver
to gather performance data.

Acked-by: Hannes Reinecke <hare@suse.de>

---

 Documentation/00-INDEX        |    2
 Documentation/statistics.txt  |  629 ++++++++++++
 MAINTAINERS                   |    7
 arch/s390/Kconfig             |    6
 arch/s390/defconfig           |    1
 arch/s390/oprofile/Kconfig    |    5
 drivers/s390/scsi/Makefile    |    4
 drivers/s390/scsi/zfcp_aux.c  |   20
 drivers/s390/scsi/zfcp_ccw.c  |    7
 drivers/s390/scsi/zfcp_def.h  |   33
 drivers/s390/scsi/zfcp_erp.c  |    4
 drivers/s390/scsi/zfcp_ext.h  |    6
 drivers/s390/scsi/zfcp_fsf.c  |   57 +
 drivers/s390/scsi/zfcp_qdio.c |    5
 drivers/s390/scsi/zfcp_scsi.c |   14
 drivers/s390/scsi/zfcp_stat.c |  195 +++
 include/linux/jiffies.h       |    7
 include/linux/list.h          |   12
 include/linux/parser.h        |    2
 include/linux/sgrb.h          |   92 +
 include/linux/statistic.h     |  449 ++++++++
 kernel/printk.c               |   98 -
 lib/Kconfig                   |    6
 lib/Kconfig.statistic         |   12
 lib/Makefile                  |    3
 lib/parser.c                  |   60 +
 lib/sgrb.c                    |  329 ++++++
 lib/statistic.c               | 2183 ++++++++++++++++++++++++++++++++++++++++++
 28 files changed, 4177 insertions(+), 71 deletions(-)

diff -urpN linux-2.6.16-rc2/Documentation/00-INDEX linux-2.6.16-rc2-git3/Documentation/00-INDEX
--- linux-2.6.16-rc2/Documentation/00-INDEX	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/Documentation/00-INDEX	2006-02-14 15:27:07.000000000 +0100
@@ -264,6 +264,8 @@ stable_kernel_rules.txt
 	- rules and procedures for the -stable kernel releases.
 stallion.txt
 	- info on using the Stallion multiport serial driver.
+statistics.txt
+	- info on statistics infrastructure available for drivers and others
 svga.txt
 	- short guide on selecting video modes at boot via VGA BIOS.
 sx.txt
diff -urpN linux-2.6.16-rc2/Documentation/statistics.txt linux-2.6.16-rc2-git3/Documentation/statistics.txt
--- linux-2.6.16-rc2/Documentation/statistics.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-rc2-git3/Documentation/statistics.txt	2006-02-14 15:27:07.000000000 +0100
@@ -0,0 +1,629 @@
+
+  Statistics infrastructure
+
+0. Which problems is it meant to solve?
+1. Concept
+2. Advantages of a generic approach
+3. Disadvantages of a generic approach
+4. Features
+5. User interface
+6. Programming interface
+7. Possible future enhancements / known bugs
+8. Contact
+
+
+
+
+  0. Which problems is it meant to solve?
+
+This common code layer implements statistics in a device driver independent
+and architecture independent way.
+
+It targets kernel programmers (mostly device driver programmers) who think about
+providing statistics for their driver and devices, and who look for an
+alternative to the reinvent-the-wheel approach.
+
+This layer tries to minimize the effort imposed on programmers implementing
+statistics. It is not meant to support the proliferation of unnecessary
+statistics, though.
+
+It also tries to solve the problem of different user interfaces for the various
+device drivers implementing statistics.
+
+
+
+
+  1. Concept
+
+	Overview
+
+The following figure tries to depict how the statistics infrastructure
+fits into the global picture, and how it interacts with both exploiting
+kernel code as well as users.
+
+ USER          :                        KERNEL
+               :
+          user         statistics            programming
+          interface    infrastructure        interface    exploiter
+               :       +------------------+       :       +-----------------+
+               :       | process data and |       :       | collect and     |
+ "data"        :       | provide output   |     (X, Y)    | report data     |
+  <====================| to user          |<==============| as (X, Y) pairs |
+ file          :       |         ^        |       :       |                 |
+               :       |         ^        |       :       |                 |
+               :       |         ^        |       :       |                 |
+               :       |         ^        |       :       | create/discard  |
+ "definition"  :       | display settings |       :       | statistics,     |
+  <===================>| and accept       |<==============| provide default |
+ file          :       | changed settings |       :       | settings        |
+               :       +------------------+       :       +-----------------+
+               :                                  :
+
+Actual semantics of the data that feeds a statistic is unimportant when it
+comes to data processing. All that matters is how the user wants the data to
+be presented (counters, histograms, and so on). That's something that can be
+dealt with by a generic layer without intervention by the device driver
+being the source of data.
+
+It's like a cow giving milk. Every time some milk has been gathered
+it is rushed to the dairy. Its not the cow's business to worry about
+the various products made of milk and how these products are packaged
+and delivered. Nor is it the business of sheep or goat, for that
+matter. It's a question of customer demand observed by the dairy
+whether milk is sold as cheese, yogurt, cream,... or simply milk.
+
+
+	The role of the statistics infrastructure
+
+It is the statistic infrastructure's task to accept or drop, accumulate,
+compute and store, as well as display statistics data according to the
+current settings.
+
+
+	The role of exploiters
+
+It is the exploiter's (e.g. device driver's) responsibility to feed the
+statistics infrastructure with sampled data for the statistics maintained by the
+statistics infrastructure on behalf of the exploiter.
+
+It would be nice of any exploiter to provide a default configuration for each
+statistic that most likely works best for general purpose use.
+
+
+	The role of users
+
+It is the user's freedom to configure how accumulation, computation and
+display of data are done, according to their needs.
+
+
+	How data is reported
+
+Exploiters report data bits in the form of (X, Y) with X being a numerical
+value for the main characteristic of the statistic, like a request size or
+request latency, and with Y being a qualifier for that characteristic,
+for example occurrence of a particular X-value.
+
+
+	How data is processed
+
+(X, Y) pairs can be processed in different ways by the statistics
+infrastructure, according to the current settings applicable to a
+particular statistic.
+
+For example, Y-parts can summed up using a simple counter, which,
+in case of a (request size, occurrence)-statistic, would yield the
+total of requests observed.
+
+Or, a simple counter can be the sum of all X*Y products, which,
+in case of a (request size, occurrence)-statistic, would yield the
+total of bytes transfered.
+
+Or, the X-value could be used, sticking to the example above, to distinguish
+request sizes and, therewith, to determine the occurrence of certain request
+sizes. This can be accomplished by the histogram functions of the statistics
+infrastructure.
+
+There are more ways of data processing implemented.
+All these algorithms are documented as part of the programming interface.
+Please note that the statistics infrastructure does not care about the
+actual semantics of (X, Y), an that it just adheres to abstract rules
+describing what to do with (X, Y) pairs for certain settings.
+It is up to the user to interpret processed data, to add semantics
+back to it, and to choose settings and, therewith, data processing modes
+according to their needs.
+
+
+	More design points
+
+Statistics can be grouped within "interfaces" (debugfs entries), in order to
+reflect collections of related statistics of an entity, to allow for coherence
+across statistics of an entity when being read by users, and in order not to
+"pollute" debugfs.
+
+The statistics infrastructure provides multiple "views" on the same data or
+statistic respectively (called "definition", or settings in this document),
+or to be precise, multiple ways to process that data at run-time.
+The way data processing is done impact impacts the output format.
+The current implementation only allows to apply a one
+"view" / definition to a statistic to any point in time.
+
+ statistics infrastructure
+    |
+    +----- statistic interface
+    |         |
+    |         +----- statistic
+    |         |        (comprising definition and data)
+    |         |
+    |         +----- statistic
+    |         |
+    |         :
+    |
+    |
+    +----- statistic interface
+    |         |
+    |         +----- statistic
+    |         |
+    :         :
+
+
+Statistics are off by default. Starting and stopping is independent from
+resetting a statistic's data.
+
+
+
+
+  2. Advantages of a generic approach
+
+Apart from a cleaner design approach, other advantages include:
+
+	Reduced development and test effort
+
+Once the generic layer was almost finished (using a test module),
+implementation and test of an assortment of statistics for the zfcp
+driver took me about 2 days. I spend more time evaluating which
+statistics make sense and which don't than coding the device driver
+extension.
+
+This makes it also cheap to put private patches for performance
+debugging purposes together which can be thrown away once the
+performance problem is understood.
+
+By not putting the statistics code into the device driver,
+I separated about 90 percent of it out into a reusable layer, which
+has seen some testing that the next exploiter can rely on.
+
+
+	Common user interface
+
+There is no point in coming up with another user interface and
+new algorithms for data processing for every device driver that
+is going to implement statistics.
+
+Once a user has learned to read and adjust statistics of component A
+they will have little or no problems applying this knowledge to
+statistics of component B.
+
+Besides, I can imagine a single script that would suffice to generate
+input for the spreadsheet program of your choice from statistics output
+of any component.
+
+
+	Lots of features
+
+The generic layer provides a superset of features of the
+"reinventing the wheel"-statistics I am aware of. This includes many
+ways data processing can be done. It's all there for everybody.
+
+It also means plenty of flexibility from a users perspective, because
+there are enough knobs available that make it unnecessary for me to
+respond to requests like "Hey, could you rebuild the zfcp module
+for me, because I need a finer resolution for that latency histogram?"
+
+
+
+
+  3. Disadvantages of a generic approach
+
+Well, disadvantages center about performance. Some people might feel strong
+about it, while others don't have any issues with it.
+I am listing here what has come to my mind, anyway.
+
+While the code has been written to be as concise as possible,
+some programmers might feel the statistics infrastructure are
+overkill for their purposes. For example, if they think they can do
+with a simple atomic_t, they might frown upon statistic_add().
+
+The statistic infrastructure doesn't make use of in-line assemblies, which might
+be faster than the architecture independent C code. Maybe some programmers would
+rather opt for some small in-line assembly for their own specific purposes.
+
+Because of the flexibility as to the various knobs available for adjusting
+statistics (ranges, resolution or precision, mode of data processing, ...)
+it is up to the statistics infrastructure to take some decisions at run time
+(if this setting do that data processing), which, therewith, can't be resolved
+and optimized by the compiler. Flexibility and functionality are achieved on
+the expense of slightly increased path length.
+
+
+
+
+  4. Features
+
+	Modes of data processing
+
+The simplest type of statistic is called "value" that provides either the total
+of Y-values, or the total of X*Y products using a simple counter.
+
+Another type that does require little memory is called "range" and comprises a
+set of four values: number, minimum, average, and maximum. It is a nice fill
+level indicator.
+
+Then, there are two types of histograms, one where Y-values are summed up for
+each X-value observed (called "list" because it utilizes an adaptable
+list_head list), and another one where Y-values are added up for ranges or
+intervals of X-values (called "array" because it utilizes a fixed-size array).
+"array"-type statistics can have either a linear or logarithmic X-scale.
+
+The statistic type "history" enhances other basic types ("value" and "range")
+by the dimension time. It allows to generate statistic results for successive
+periods of time, and it provides a history of these results. For example,
+transfer rate over time, like bytes/second, can be shown this way for a
+(request size, occurrence)-like data feed.
+
+Finally, there is a type called "raw" which simply stores timestamped (X, Y)
+pairs in a ring-buffer.
+
+Details on each type and the associated algorithms can be found in the
+kernel-doc-style comments of the programming interface.
+
+The statistics infrastructure has been designed to allow for easy addition of
+more types.
+
+
+	Other things that can be adjusted
+
+Ranges of acceptable X-values of (X, Y) pairs can be adjusted to the users
+needs. For example, a certain range of latencies could be of interest for a
+(request latency, occurrence)-like data source.
+
+Data can be discarded by users by resetting the statistic.
+
+Data gathering can be turned on and off for each statistic individually, or
+in an atomic fashion for all statistics attached to an interface.
+
+
+
+
+  5. User interface
+
+	Locating statistics
+
+The statistics infrastructure's user interface is in the
+/sys/kernel/debug/statistics directory, assuming debugfs has been mounted at
+/sys/kernel/debug.  The "statistics" directory holds interface subdirectories
+created by exploiters, for example:
+
+  drwxr-xr-x 2 root root 0 Jul 28 02:16 zfcp-0.0.50d4
+
+An interface subdirectory contains two files, a data and a definition file:
+
+  -r-------- 1 root root 0 Jul 28 02:16 data
+  -rw------- 1 root root 0 Jul 28 02:16 definition
+
+The data file holds the statistic data collected in ASCII format. Each
+line contains one entry of a statistic, tagged with the statistic name,
+for example:
+
+  request_sizes_scsi_write 0x1000 34
+
+You can influence the output in the data file by setting attributes in
+the definition file.
+
+
+	The "definition" file
+
+The statistics infrastructure processes reported data according to the
+settings in the definition file, particularly the type attribute. You
+can change some statistic attributes and thereby change how data is
+processed.
+
+The definition file contains the name, type, mode and other definitions
+for the different statistics for which data are collected. For example,
+a entry for a statistic in a definition file might look like this:
+
+  # cat definition
+  name=util_qdio_outb on=0 type=history range_min=0 range_max=127
+  entries_max=128 mode=range period=1000000 hits_out_of_range=0
+  data=[2417020.832398] started=[2417044.149675] stopped=[2417020.832398]
+  units=slots-occupied/incidents
+
+Some of the attributes shown are common to all statistics, others only apply
+to specific statistic type or mode of data processing respectively. Many
+attributes can be changed by users, others are read-only. All timestamps
+are in the style of printk-timestamps.
+
+
+	Common statistic attributes
+
+  Attribute	Changeable	Comment
+
+  name		No		The device driver provides the name that defines
+				a statistic.
+
+  units		No 		Units defines what the device driver reports
+				as (X, Y) pair.
+
+  type		Yes		The attribute determines the way sampled data
+				is processed and displayed. Valid values are:
+				value, range, array, list, history, raw
+
+  data 		Yes 		The age of sampled data, that is, the time
+				since last reset.
+
+  on 		Yes 		The on or off state. Valid assignments are
+				0 (off) and 1 (on).
+
+  started 	No 		The last time the statistic was started.
+				Depends on the on attribute.
+
+  stopped 	No 		The last time the statistic was stopped.
+				Depends on the on attribute.
+
+  range_min 	Yes 		The minimum value of the range you are
+				interested in.
+
+  range_max 	Yes 		The maximum value of the range you are
+				interested in.
+
+  hits_out_of_range 	No 	Values smaller than range_min and larger than
+				range_max are counted here.
+
+
+	Attributes specific to particular statistic types
+
+  Attribute	Specific to 	Changeable 	Comment
+
+  entries_max 	type=history    Yes		Maximum number of entries in a
+		type=list			ring buffer or list.
+		type=raw
+
+  hits_missed 	type=list 	No 		Number of (X, Y) pairs missed
+						due to a list-size limit
+						imposed by entries_max.
+
+  scale 	type=array 	Yes 		Valid values are:
+						lin for linear scale,
+						log2 for logarithmic scale.
+
+  base_interval type=array 	Yes 		base interval used for X-scale
+
+  mode=increments 		Yes		Mode determines that only the
+		type=history			total of Y-value is to be
+		type=value 	Yes		calculated.
+
+  mode=products type=history	Yes		Mode determines that the total
+		type=value 	Yes 		of X*Y products is to be
+						calculated.
+
+  mode=range 	type=history 	Yes 		Mode determines that a set of
+						(number, min, average, max) is
+						to be calculated for each
+						period shown in the history
+						ring-buffer.
+
+  period 	type=history 	Yes 		Determines the time to elapse
+						before calculation is started
+						over.
+
+
+	Changing attributes through the "definition" file
+
+A statistic can be reconfigured by writing changed attributes to the
+definition-file:
+
+  echo name=foobar type=list entries_max=256 > definition
+
+You can either write the entire line describing a statistic, including
+read-only attributes (which are ignored by the statistics infrastructure, as
+any other junk is). This simplifies the procedures (copy, paste to command line,
+modify command line, echo attributes from command line into definition file)
+and (cat to file, modify file content, cat file back into definition file).
+
+In many cases, there is no need to write all attributes of a statistic back.
+Many attributes can be changed by themselves or when combined with other
+independent attributes:
+
+  echo name=foo range_min=3 > definition
+
+  echo name=foo range_max=17 > definition
+
+  echo name=bar on=1 > definition
+
+Only if you change the type of a statistic you are required to provide all
+type-specific attributes, because the type-specific attributes of the old type
+do not apply anymore:
+
+  echo name=foobar type=history mode=range period=1000000 entries_max=1024
+   > definition
+
+Naturally, changes of the type of a statistic or of type-specific attributes
+causes all data to be discarded and calculations being started over.
+
+Some operations can be done in an atomic fashion for all statistics grouped
+within the scope of an interface. Simply, omit the name= attribute:
+
+  echo on=1 > definition
+
+  echo on=0 > definition
+
+  echo data=reset > definition
+
+
+	Reading statistic output from the "data" file
+
+The "data" file contains the output of all statistics available for a
+particular interface. This is an ASCII file. Depending on the type of a
+statistic, the output for a statistic consists of a single line or a bunch
+of lines. Each line delivers one value or one result of a statistic and
+consists of several strings separated by spaces. The beginning of each line
+is tagged with the name of the statistic the line belongs to. The rest of
+a line is statistic-type specific. The content of a "data" might look like
+this:
+
+  foo 0x1000 4
+  foo 0x2000 1
+  foo 0x5000 2
+  bar 961 1 42.000 128
+
+
+	Output formats of different statistic types
+
+  Statistic Type	Output Format				Number of Lines
+
+  value			<name> <total>				1
+
+  range			<name> <total> <min> <avg> <max>	1
+
+  list			<name> <Xn> <total for Xn>		<= entries_max
+			...
+
+  array			<name> "<="<Xn> <total for interval>    number of
+			...					intervals as
+			<name> ">"<Xm> <total for interval>	determined by
+								base_interval,
+								scale,
+								range_min,
+								range_max
+
+  history		<name> <time-stamp> <total>		<= entries_max
+  (mode=increments,	...
+   mode=products)
+
+  history		<name> <time-stamp> <total> <min> <avg> <max>
+  (mode=range)		...					<= entries_max
+
+  raw			<name> <time-stamp> <serial> <X> <Y>	<= entries_max
+			...
+
+	Sample Output
+
+This is output from per-adapter statistics of the zfcp SCSI HBA driver.
+It shows data for 5 statistics:
+
+  occurrence_qdio_outb_full 57
+  util_qdio_outb [3097301.211992] 0 0 0.000 0
+  ...
+  util_qdio_outb [3097394.211992] 865 1 1.052 5
+  util_qdio_outb [3097395.211992] 737 1 4.558 125
+  util_qdio_outb [3097396.211992] 396 1 11.765 77
+  util_qdio_outb [3097397.211992] 270 1 12.863 128
+  util_qdio_outb [3097398.211992] 765 1 7.271 26
+  util_qdio_outb [3097399.211992] 577 1 4.036 27
+  util_qdio_inb 118706 1 1.017 31
+  occurrence_low_mem_scsi 0
+  occurrence_erp 0
+
+In the order of appearance there are:
+
+  a value-type statistic providing a simple counter,
+  a history-of-ranges-type statistic providing a fill level indicator
+	over time (one entry per second),
+  a range-type statistic providing a fill level indicator,
+  two more value-type statistics.
+
+Here is more data for the same device driver (data per LUN):
+
+  request_sizes_scsi_write 0x64000 13
+  ...
+  request_sizes_scsi_write 0x67000 9
+  request_sizes_scsi_write 0x73000 8
+  ...
+  request_sizes_scsi_write 0x7b000 5
+  request_sizes_scsi_read 0x1000 44163
+  request_sizes_scsi_read 0x2000 9281
+  request_sizes_scsi_read 0x3000 4860
+  request_sizes_scsi_read 0x8000 4682
+  ...
+  request_sizes_scsi_read 0x4000 2976
+  request_sizes_scsi_nodata 0
+  latencies_scsi_write <=0 0
+  latencies_scsi_write <=1 0
+  latencies_scsi_write <=2 0
+  latencies_scsi_write <=4 174
+  latencies_scsi_write <=8 872
+  latencies_scsi_write <=16 2555
+  latencies_scsi_write <=32 2483
+  ...
+  latencies_scsi_write <=1024 1872
+  latencies_scsi_write >1024 1637
+  latencies_scsi_read <=0 0
+  latencies_scsi_read <=1 0
+  latencies_scsi_read <=2 0
+  latencies_scsi_read <=4 57265
+  latencies_scsi_read <=8 13610
+  latencies_scsi_read <=16 1082
+  latencies_scsi_read <=32 319
+  latencies_scsi_read <=64 63
+  ...
+  latencies_scsi_read >1024 0
+  latencies_scsi_nodata <=0 0
+  ...
+  latencies_scsi_nodata >1024 0
+  pending_scsi_write 17121 1 28.502 32
+  pending_scsi_read 72348 3 3.002 5
+
+In the order of appearance there are:
+
+  two lists of request sizes and their occurrences (write, read),
+  a counter for commands without data transfer,
+  three array-type histograms with logarithmic scales for request latencies
+	in milliseconds (write, read, no data),
+  two range-type statistics indicating many SCSI commands are pending
+	concurrently (write, read).
+
+
+
+
+  6. Programming interface
+
+The programming interface can be retrieved from the kernel-doc-style comments
+available for all interface functions. A programming example can be found in
+drivers/s390/scsi.
+
+Anyway, here is an introduction:
+
+First, call statistic_create_interface() in order to create an interface
+where several statistics for the concerned entity can be attached next by
+calling statistic_create(). It is recommended that you call
+statistic_define_*() for each statistic, as well, in order to provide some
+half-decent default settings for the newly created statistic.
+
+Usually, exploiters won't enable data gathering - by calling statistic_start() -
+unless data should be collected by default. In many cases, it might be better
+to leave this to users, who can start statistics any time they wish.
+
+Add statistic_add*() or statistic_inc*() calls where appropriate for
+reporting statistics data. Data to be reported through these functions has the
+form of (X, Y) as explained above.
+
+In order to remove statistics call statistic_remove().
+The function statistic_interface_remove() cleans up an entire interface with
+all statistics still attached.
+
+
+
+
+  7. Possible future enhancements / known bugs
+
+The current implementation is a prototype. It is good enough for the current
+zfcp requirements, though. For general use more work might be required.
+
+There are several possible enhancements and optimizations documented
+at the head of lib/statistic.c There I keep track of bugs as well.
+
+
+
+
+  8. Contact
+
+See MAINTAINERS file.
diff -urpN linux-2.6.16-rc2/MAINTAINERS linux-2.6.16-rc2-git3/MAINTAINERS
--- linux-2.6.16-rc2/MAINTAINERS	2006-02-14 15:30:51.000000000 +0100
+++ linux-2.6.16-rc2-git3/MAINTAINERS	2006-02-14 15:27:07.000000000 +0100
@@ -2499,6 +2499,13 @@ STARMODE RADIO IP (STRIP) PROTOCOL DRIVE
 W:	http://mosquitonet.Stanford.EDU/strip.html
 S:	Unsupported ?
 
+STATISTICS INFRASTRUCTURE
+P:	Martin Peschke
+M:	mpeschke@de.ibm.com
+M:	linux390@de.ibm.com
+W:	http://oss.software.ibm.com/developerworks/opensource/linux390
+S:	Supported
+
 STRADIS MPEG-2 DECODER DRIVER
 P:	Nathan Laredo
 M:	laredo@gnu.org
diff -urpN linux-2.6.16-rc2/arch/s390/Kconfig linux-2.6.16-rc2-git3/arch/s390/Kconfig
--- linux-2.6.16-rc2/arch/s390/Kconfig	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/arch/s390/Kconfig	2006-02-14 15:27:07.000000000 +0100
@@ -464,8 +464,14 @@ source "drivers/net/Kconfig"
 
 source "fs/Kconfig"
 
+menu "Instrumentation Support"
+
 source "arch/s390/oprofile/Kconfig"
 
+source "lib/Kconfig.statistic"
+
+endmenu
+
 source "arch/s390/Kconfig.debug"
 
 source "security/Kconfig"
diff -urpN linux-2.6.16-rc2/arch/s390/oprofile/Kconfig linux-2.6.16-rc2-git3/arch/s390/oprofile/Kconfig
--- linux-2.6.16-rc2/arch/s390/oprofile/Kconfig	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/arch/s390/oprofile/Kconfig	2006-02-14 15:27:07.000000000 +0100
@@ -1,6 +1,3 @@
-
-menu "Profiling support"
-
 config PROFILING
 	bool "Profiling support"
 	help
@@ -18,5 +15,3 @@ config OPROFILE
 
 	  If unsure, say N.
 
-endmenu
-
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/Makefile linux-2.6.16-rc2-git3/drivers/s390/scsi/Makefile
--- linux-2.6.16-rc2/drivers/s390/scsi/Makefile	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/Makefile	2006-02-14 15:27:07.000000000 +0100
@@ -3,7 +3,7 @@
 #
 
 zfcp-objs := zfcp_aux.o zfcp_ccw.o zfcp_scsi.o zfcp_erp.o zfcp_qdio.o \
-	     zfcp_fsf.o zfcp_dbf.o zfcp_sysfs_adapter.o zfcp_sysfs_port.o \
-	     zfcp_sysfs_unit.o zfcp_sysfs_driver.o
+	     zfcp_fsf.o zfcp_dbf.o zfcp_stat.o zfcp_sysfs_adapter.o \
+	     zfcp_sysfs_port.o zfcp_sysfs_unit.o zfcp_sysfs_driver.o
 
 obj-$(CONFIG_ZFCP) += zfcp.o
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_aux.c linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_aux.c
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_aux.c	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_aux.c	2006-02-14 15:27:07.000000000 +0100
@@ -776,15 +776,20 @@ zfcp_unit_enqueue(struct zfcp_port *port
 	unit->sysfs_device.release = zfcp_sysfs_unit_release;
 	dev_set_drvdata(&unit->sysfs_device, unit);
 
+	if (zfcp_unit_statistic_register(unit))
+		return NULL;
+
 	/* mark unit unusable as long as sysfs registration is not complete */
 	atomic_set_mask(ZFCP_STATUS_COMMON_REMOVE, &unit->status);
 
 	if (device_register(&unit->sysfs_device)) {
+		zfcp_unit_statistic_unregister(unit);
 		kfree(unit);
 		return NULL;
 	}
 
 	if (zfcp_sysfs_unit_create_files(&unit->sysfs_device)) {
+		zfcp_unit_statistic_unregister(unit);
 		device_unregister(&unit->sysfs_device);
 		return NULL;
 	}
@@ -824,6 +829,7 @@ zfcp_unit_dequeue(struct zfcp_unit *unit
 	list_del(&unit->list);
 	write_unlock_irq(&zfcp_data.config_lock);
 	unit->port->units--;
+	zfcp_unit_statistic_unregister(unit);
 	zfcp_port_put(unit->port);
 	zfcp_sysfs_unit_remove_files(&unit->sysfs_device);
 	device_unregister(&unit->sysfs_device);
@@ -835,6 +841,16 @@ zfcp_mempool_alloc(gfp_t gfp_mask, void 
 	return kmalloc((size_t) size, gfp_mask);
 }
 
+static void *
+zfcp_mempool_alloc_fsf_req_scsi(unsigned int __nocast gfp_mask, void *data)
+{
+	struct zfcp_adapter *adapter = (struct zfcp_adapter *)data;
+	void *ptr = kmalloc(sizeof(struct zfcp_fsf_req_pool_element), gfp_mask);
+	if (!ptr)
+		statistic_inc(adapter->stat_low_mem_scsi, 0);
+	return ptr;
+}
+
 static void
 zfcp_mempool_free(void *element, void *size)
 {
@@ -862,8 +878,8 @@ zfcp_allocate_low_mem_buffers(struct zfc
 
 	adapter->pool.fsf_req_scsi =
 		mempool_create(ZFCP_POOL_FSF_REQ_SCSI_NR,
-			       zfcp_mempool_alloc, zfcp_mempool_free, (void *)
-			       sizeof(struct zfcp_fsf_req_pool_element));
+			       zfcp_mempool_alloc_fsf_req_scsi,
+			       zfcp_mempool_free, (void *)adapter);
 
 	if (NULL == adapter->pool.fsf_req_scsi)
 		return -ENOMEM;
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_ccw.c linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_ccw.c
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_ccw.c	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_ccw.c	2006-02-14 15:27:07.000000000 +0100
@@ -161,6 +161,10 @@ zfcp_ccw_set_online(struct ccw_device *c
 	retval = zfcp_adapter_debug_register(adapter);
 	if (retval)
 		goto out;
+	retval = zfcp_adapter_statistic_register(adapter);
+	if (retval)
+		goto out_stat_create;
+
 	retval = zfcp_erp_thread_setup(adapter);
 	if (retval) {
 		ZFCP_LOG_INFO("error: start of error recovery thread for "
@@ -181,6 +185,8 @@ zfcp_ccw_set_online(struct ccw_device *c
  out_scsi_register:
 	zfcp_erp_thread_kill(adapter);
  out_erp_thread:
+	zfcp_adapter_statistic_unregister(adapter);
+ out_stat_create:
 	zfcp_adapter_debug_unregister(adapter);
  out:
 	up(&zfcp_data.config_sema);
@@ -207,6 +213,7 @@ zfcp_ccw_set_offline(struct ccw_device *
 	zfcp_erp_wait(adapter);
 	zfcp_adapter_scsi_unregister(adapter);
 	zfcp_erp_thread_kill(adapter);
+	zfcp_adapter_statistic_unregister(adapter);
 	zfcp_adapter_debug_unregister(adapter);
 	up(&zfcp_data.config_sema);
 	return 0;
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_def.h linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_def.h
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_def.h	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_def.h	2006-02-14 15:27:07.000000000 +0100
@@ -56,6 +56,8 @@
 #include <asm/qdio.h>
 #include <asm/debug.h>
 #include <asm/ebcdic.h>
+#include <asm/timex.h>
+#include <linux/statistic.h>
 #include <linux/mempool.h>
 #include <linux/syscalls.h>
 #include <linux/ioctl.h>
@@ -64,7 +66,7 @@
 /********************* GENERAL DEFINES *********************************/
 
 /* zfcp version number, it consists of major, minor, and patch-level number */
-#define ZFCP_VERSION		"4.5.0"
+#define ZFCP_VERSION		"4.6.0"
 
 /**
  * zfcp_sg_to_address - determine kernel address from struct scatterlist
@@ -978,6 +980,12 @@ struct zfcp_adapter {
 	struct fc_host_statistics *fc_stats;
 	struct fsf_qtcb_bottom_port *stats_reset_data;
 	unsigned long		stats_reset;
+	struct statistic_interface	*stat_if;
+	struct statistic		*stat_qdio_outb_full;
+	struct statistic		*stat_qdio_outb;
+	struct statistic		*stat_qdio_inb;
+	struct statistic		*stat_low_mem_scsi;
+	struct statistic		*stat_erp;
 };
 
 /*
@@ -1024,6 +1032,24 @@ struct zfcp_unit {
         struct scsi_device     *device;        /* scsi device struct pointer */
 	struct zfcp_erp_action erp_action;     /* pending error recovery */
         atomic_t               erp_counter;
+	atomic_t		read_num;
+	atomic_t		write_num;
+	struct statistic_interface	*stat_if;
+	struct statistic		*stat_sizes_scsi_write;
+	struct statistic		*stat_sizes_scsi_read;
+	struct statistic		*stat_sizes_scsi_nodata;
+	struct statistic		*stat_sizes_scsi_nofit;
+	struct statistic		*stat_sizes_scsi_nomem;
+	struct statistic		*stat_sizes_timedout_write;
+	struct statistic		*stat_sizes_timedout_read;
+	struct statistic		*stat_sizes_timedout_nodata;
+	struct statistic		*stat_latencies_scsi_write;
+	struct statistic		*stat_latencies_scsi_read;
+	struct statistic		*stat_latencies_scsi_nodata;
+	struct statistic		*stat_pending_scsi_write;
+	struct statistic		*stat_pending_scsi_read;
+	struct statistic		*stat_erp;
+	struct statistic		*stat_eh_reset;
 };
 
 /* FSF request */
@@ -1044,13 +1070,14 @@ struct zfcp_fsf_req {
 	u32		       fsf_command;    /* FSF Command copy */
 	struct fsf_qtcb	       *qtcb;	       /* address of associated QTCB */
 	u32		       seq_no;         /* Sequence number of request */
-        unsigned long          data;           /* private data of request */ 
+	unsigned long	       data;           /* private data of request */
 	struct zfcp_erp_action *erp_action;    /* used if this request is
 						  issued on behalf of erp */
 	mempool_t	       *pool;	       /* used if request was alloacted
 						  from emergency pool */
 	unsigned long long     issued;         /* request sent time (STCK) */
-	struct zfcp_unit       *unit;
+	unsigned long long	received;
+	struct zfcp_unit	*unit;
 };
 
 typedef void zfcp_fsf_req_handler_t(struct zfcp_fsf_req*);
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_erp.c linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_erp.c
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_erp.c	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_erp.c	2006-02-14 15:27:07.000000000 +0100
@@ -1622,10 +1622,12 @@ zfcp_erp_strategy_check_unit(struct zfcp
 	switch (result) {
 	case ZFCP_ERP_SUCCEEDED :
 		atomic_set(&unit->erp_counter, 0);
+		statistic_inc(unit->stat_erp, 1);
 		zfcp_erp_unit_unblock(unit);
 		break;
 	case ZFCP_ERP_FAILED :
 		atomic_inc(&unit->erp_counter);
+		statistic_inc(unit->stat_erp, -1);
 		if (atomic_read(&unit->erp_counter) > ZFCP_MAX_ERPS)
 			zfcp_erp_unit_failed(unit);
 		break;
@@ -1693,10 +1695,12 @@ zfcp_erp_strategy_check_adapter(struct z
 	switch (result) {
 	case ZFCP_ERP_SUCCEEDED :
 		atomic_set(&adapter->erp_counter, 0);
+		statistic_inc(adapter->stat_erp, 1);
 		zfcp_erp_adapter_unblock(adapter);
 		break;
 	case ZFCP_ERP_FAILED :
 		atomic_inc(&adapter->erp_counter);
+		statistic_inc(adapter->stat_erp, -1);
 		if (atomic_read(&adapter->erp_counter) > ZFCP_MAX_ERPS)
 			zfcp_erp_adapter_failed(adapter);
 		break;
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_ext.h linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_ext.h
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_ext.h	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_ext.h	2006-02-14 15:27:07.000000000 +0100
@@ -201,4 +201,10 @@ extern void zfcp_scsi_dbf_event_abort(co
 extern void zfcp_scsi_dbf_event_devreset(const char *, u8, struct zfcp_unit *,
 					 struct scsi_cmnd *);
 
+/*************************** stat ********************************************/
+extern int zfcp_adapter_statistic_register(struct zfcp_adapter *);
+extern int zfcp_adapter_statistic_unregister(struct zfcp_adapter *);
+extern int zfcp_unit_statistic_register(struct zfcp_unit *);
+extern int zfcp_unit_statistic_unregister(struct zfcp_unit *);
+
 #endif	/* ZFCP_EXT_H */
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_fsf.c linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_fsf.c
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_fsf.c	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_fsf.c	2006-02-14 15:27:07.000000000 +0100
@@ -217,6 +217,8 @@ zfcp_fsf_req_complete(struct zfcp_fsf_re
 	int retval = 0;
 	int cleanup;
 
+	fsf_req->received = get_clock();
+
 	if (unlikely(fsf_req->fsf_command == FSF_QTCB_UNSOLICITED_STATUS)) {
 		ZFCP_LOG_DEBUG("Status read response received\n");
 		/*
@@ -3505,6 +3507,12 @@ zfcp_fsf_send_fcp_command_task(struct zf
 			       unit->fcp_lun,
 			       unit->port->wwpn,
 			       zfcp_get_busid_by_adapter(adapter));
+		if (retval == -ENOMEM)
+			statistic_inc(unit->stat_sizes_scsi_nomem,
+				       scsi_cmnd->request_bufflen);
+		if (retval == -EIO)
+			statistic_inc(unit->stat_sizes_scsi_nofit,
+				       scsi_cmnd->request_bufflen);
 		goto failed_req_create;
 	}
 
@@ -3615,6 +3623,8 @@ zfcp_fsf_send_fcp_command_task(struct zf
 		zfcp_erp_unit_shutdown(unit, 0);
 		retval = -EINVAL;
 		}
+		statistic_inc(unit->stat_sizes_scsi_nofit,
+			       scsi_cmnd->request_bufflen);
 		goto no_fit;
 	}
 
@@ -3639,6 +3649,17 @@ zfcp_fsf_send_fcp_command_task(struct zf
 		goto send_failed;
 	}
 
+	switch (sbtype) {
+	case SBAL_FLAGS0_TYPE_READ :
+		statistic_inc(unit->stat_pending_scsi_read,
+				atomic_inc_return(&unit->read_num));
+		break;
+	case SBAL_FLAGS0_TYPE_WRITE :
+		statistic_inc(unit->stat_pending_scsi_write,
+				atomic_inc_return(&unit->write_num));
+		break;
+	}
+
 	ZFCP_LOG_TRACE("Send FCP Command initiated (adapter %s, "
 		       "port 0x%016Lx, unit 0x%016Lx)\n",
 		       zfcp_get_busid_by_adapter(adapter),
@@ -4018,9 +4039,32 @@ zfcp_fsf_send_fcp_command_task_handler(s
 	u32 sns_len;
 	char *fcp_rsp_info = zfcp_get_fcp_rsp_info_ptr(fcp_rsp_iu);
 	unsigned long flags;
+	struct zfcp_adapter *adapter = fsf_req->adapter;
 	struct zfcp_unit *unit = fsf_req->unit;
+	long long unsigned latency;
 
-	read_lock_irqsave(&fsf_req->adapter->abort_lock, flags);
+	statistic_lock(unit->stat_if, flags);
+	latency = fsf_req->received - fsf_req->issued;
+	do_div(latency, 1000000);
+	latency++;
+	if (fcp_cmnd_iu->wddata == 1) {
+		statistic_inc_nolock(unit->stat_sizes_scsi_write,
+				      zfcp_get_fcp_dl(fcp_cmnd_iu));
+		statistic_inc_nolock(unit->stat_latencies_scsi_write, latency);
+		atomic_dec(&unit->write_num);
+	} else if (fcp_cmnd_iu->rddata == 1) {
+		statistic_inc_nolock(unit->stat_sizes_scsi_read,
+				      zfcp_get_fcp_dl(fcp_cmnd_iu));
+		statistic_inc_nolock(unit->stat_latencies_scsi_read, latency);
+		atomic_dec(&unit->read_num);
+	} else {
+		statistic_inc_nolock(unit->stat_sizes_scsi_nodata,
+				      zfcp_get_fcp_dl(fcp_cmnd_iu));
+		statistic_inc_nolock(unit->stat_latencies_scsi_nodata, latency);
+	}
+	statistic_unlock(unit->stat_if, flags);
+
+	read_lock_irqsave(&adapter->abort_lock, flags);
 	scpnt = (struct scsi_cmnd *) fsf_req->data;
 	if (unlikely(!scpnt)) {
 		ZFCP_LOG_DEBUG
@@ -4639,10 +4683,14 @@ zfcp_fsf_req_sbal_get(struct zfcp_adapte
 						       ZFCP_SBAL_TIMEOUT);
 		if (ret < 0)
 			return ret;
-		if (!ret)
+		if (!ret) {
+			statistic_inc(adapter->stat_qdio_outb_full, 1);
 			return -EIO;
-        } else if (!zfcp_fsf_req_sbal_check(lock_flags, req_queue, 1))
+		}
+        } else if (!zfcp_fsf_req_sbal_check(lock_flags, req_queue, 1)) {
+		statistic_inc(adapter->stat_qdio_outb_full, 1);
                 return -EIO;
+	}
 
         return 0;
 }
@@ -4808,6 +4856,9 @@ zfcp_fsf_req_send(struct zfcp_fsf_req *f
 	 * position of first one
 	 */
 	atomic_sub(fsf_req->sbal_number, &req_queue->free_count);
+	statistic_inc(adapter->stat_qdio_outb,
+			QDIO_MAX_BUFFERS_PER_Q - 
+			atomic_read(&req_queue->free_count));
 	ZFCP_LOG_TRACE("free_count=%d\n", atomic_read(&req_queue->free_count));
 	req_queue->free_index += fsf_req->sbal_number;	  /* increase */
 	req_queue->free_index %= QDIO_MAX_BUFFERS_PER_Q;  /* wrap if needed */
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_qdio.c linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_qdio.c
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_qdio.c	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_qdio.c	2006-02-14 15:27:07.000000000 +0100
@@ -416,6 +416,7 @@ zfcp_qdio_response_handler(struct ccw_de
 	} else {
 		queue->free_index += count;
 		queue->free_index %= QDIO_MAX_BUFFERS_PER_Q;
+		statistic_inc(adapter->stat_qdio_inb, count);
 		atomic_set(&queue->free_count, 0);
 		ZFCP_LOG_TRACE("%i buffers enqueued to response "
 			       "queue at position %i\n", count, start);
@@ -660,6 +661,10 @@ zfcp_qdio_sbals_from_segment(struct zfcp
 		/* get next free SBALE for new piece */
 		if (NULL == zfcp_qdio_sbale_next(fsf_req, sbtype)) {
 			/* no SBALE left, clean up and leave */
+			statistic_inc(
+				fsf_req->adapter->stat_qdio_outb_full,
+				atomic_read(
+				 &fsf_req->adapter->request_queue.free_count));
 			zfcp_qdio_sbals_wipe(fsf_req);
 			return -EINVAL;
 		}
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_scsi.c linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_scsi.c
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_scsi.c	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_scsi.c	2006-02-14 15:27:07.000000000 +0100
@@ -433,6 +433,16 @@ zfcp_scsi_eh_abort_handler(struct scsi_c
 	ZFCP_LOG_INFO("aborting scsi_cmnd=%p on adapter %s\n",
 		      scpnt, zfcp_get_busid_by_adapter(adapter));
 
+	if (scpnt->sc_data_direction == DMA_TO_DEVICE)
+		statistic_inc(unit->stat_sizes_timedout_write,
+			      scpnt->request_bufflen);
+	else if (scpnt->sc_data_direction == DMA_FROM_DEVICE)
+		statistic_inc(unit->stat_sizes_timedout_read,
+			      scpnt->request_bufflen);
+	else
+		statistic_inc(unit->stat_sizes_timedout_nodata,
+			       scpnt->request_bufflen);
+
 	/* avoid race condition between late normal completion and abort */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
@@ -522,12 +532,14 @@ zfcp_scsi_eh_device_reset_handler(struct
 				atomic_set_mask
 				    (ZFCP_STATUS_UNIT_NOTSUPPUNITRESET,
 				     &unit->status);
+			statistic_inc(unit->stat_eh_reset, -1);
 			/* fall through and try 'target reset' next */
 		} else {
 			ZFCP_LOG_DEBUG("unit reset succeeded (unit=%p)\n",
 				       unit);
 			/* avoid 'target reset' */
 			retval = SUCCESS;
+			statistic_inc(unit->stat_eh_reset, 1);
 			goto out;
 		}
 	}
@@ -535,9 +547,11 @@ zfcp_scsi_eh_device_reset_handler(struct
 	if (retval) {
 		ZFCP_LOG_DEBUG("target reset failed (unit=%p)\n", unit);
 		retval = FAILED;
+		statistic_inc(unit->stat_eh_reset, -2);
 	} else {
 		ZFCP_LOG_DEBUG("target reset succeeded (unit=%p)\n", unit);
 		retval = SUCCESS;
+		statistic_inc(unit->stat_eh_reset, 2);
 	}
  out:
 	return retval;
diff -urpN linux-2.6.16-rc2/drivers/s390/scsi/zfcp_stat.c linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_stat.c
--- linux-2.6.16-rc2/drivers/s390/scsi/zfcp_stat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-rc2-git3/drivers/s390/scsi/zfcp_stat.c	2006-02-14 15:27:07.000000000 +0100
@@ -0,0 +1,195 @@
+/*
+ *
+ * linux/drivers/s390/scsi/zfcp_stat.c
+ *
+ * FCP adapter driver for IBM eServer zSeries
+ *
+ * Statistics
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define ZFCP_STAT_REVISION "$Revision: 1.9.2.1 $"
+
+#include <linux/statistic.h>
+#include <linux/ctype.h>
+#include "zfcp_ext.h"
+
+#define ZFCP_LOG_AREA			ZFCP_LOG_AREA_OTHER
+
+int zfcp_adapter_statistic_register(struct zfcp_adapter *adapter)
+{
+	int retval = 0;
+	char name[14];
+
+	sprintf(name, "zfcp-%s", zfcp_get_busid_by_adapter(adapter));
+	statistic_interface_create(&adapter->stat_if, name);
+
+	retval |=
+	    statistic_create(&adapter->stat_qdio_outb_full, adapter->stat_if,
+			     "occurrence_qdio_outb_full",
+			     "sbals_left/incidents");
+	statistic_define_value(adapter->stat_qdio_outb_full,
+			       STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+			       STATISTIC_DEF_MODE_INC);
+
+	retval |= statistic_create(&adapter->stat_qdio_outb, adapter->stat_if,
+				   "util_qdio_outb",
+				   "slots-occupied/incidents");
+	statistic_define_range(adapter->stat_qdio_outb,
+			       0, QDIO_MAX_BUFFERS_PER_Q - 1);
+
+	retval |= statistic_create(&adapter->stat_qdio_inb, adapter->stat_if,
+				   "util_qdio_inb", "slots-occupied/incidents");
+	statistic_define_range(adapter->stat_qdio_inb,
+			       0, QDIO_MAX_BUFFERS_PER_Q - 1);
+
+	retval |=
+	    statistic_create(&adapter->stat_low_mem_scsi, adapter->stat_if,
+			     "occurrence_low_mem_scsi", "-/incidents");
+	statistic_define_value(adapter->stat_low_mem_scsi, STATISTIC_RANGE_MIN,
+			       STATISTIC_RANGE_MAX, STATISTIC_DEF_MODE_INC);
+
+	retval |= statistic_create(&adapter->stat_erp, adapter->stat_if,
+				   "occurrence_erp", "results/incidents");
+	statistic_define_value(adapter->stat_erp,
+			       STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+			       STATISTIC_DEF_MODE_INC);
+
+	return retval;
+}
+
+int zfcp_adapter_statistic_unregister(struct zfcp_adapter *adapter)
+{
+	return statistic_interface_remove(&adapter->stat_if);
+}
+
+int zfcp_unit_statistic_register(struct zfcp_unit *unit)
+{
+	int retval = 0;
+	char name[64];
+
+	atomic_set(&unit->read_num, 0);
+	atomic_set(&unit->write_num, 0);
+
+	sprintf(name, "zfcp-%s-0x%016Lx-0x%016Lx",
+		zfcp_get_busid_by_unit(unit), unit->port->wwpn, unit->fcp_lun);
+	statistic_interface_create(&unit->stat_if, name);
+
+	retval |= statistic_create(&unit->stat_sizes_scsi_write, unit->stat_if,
+				   "request_sizes_scsi_write",
+				   "bytes/incidents");
+	statistic_define_list(unit->stat_sizes_scsi_write, 0,
+			      STATISTIC_RANGE_MAX, 256);
+
+	retval |= statistic_create(&unit->stat_sizes_scsi_read, unit->stat_if,
+				   "request_sizes_scsi_read",
+				   "bytes/incidents");
+	statistic_define_list(unit->stat_sizes_scsi_read, 0,
+			      STATISTIC_RANGE_MAX, 256);
+
+	retval |= statistic_create(&unit->stat_sizes_scsi_nodata, unit->stat_if,
+				   "request_sizes_scsi_nodata",
+				   "bytes/incidents");
+	statistic_define_value(unit->stat_sizes_scsi_nodata,
+			       STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+			       STATISTIC_DEF_MODE_INC);
+
+	retval |= statistic_create(&unit->stat_sizes_scsi_nofit, unit->stat_if,
+				   "request_sizes_scsi_nofit",
+				   "bytes/incidents");
+	statistic_define_list(unit->stat_sizes_scsi_nofit, 0,
+			      STATISTIC_RANGE_MAX, 256);
+
+	retval |= statistic_create(&unit->stat_sizes_scsi_nomem, unit->stat_if,
+				   "request_sizes_scsi_nomem",
+				   "bytes/incidents");
+	statistic_define_value(unit->stat_sizes_scsi_nomem, STATISTIC_RANGE_MIN,
+			       STATISTIC_RANGE_MAX, STATISTIC_DEF_MODE_INC);
+
+	retval |=
+	    statistic_create(&unit->stat_sizes_timedout_write, unit->stat_if,
+			     "request_sizes_timedout_write", "bytes/incidents");
+	statistic_define_value(unit->stat_sizes_timedout_write,
+			       STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+			       STATISTIC_DEF_MODE_INC);
+
+	retval |=
+	    statistic_create(&unit->stat_sizes_timedout_read, unit->stat_if,
+			     "request_sizes_timedout_read", "bytes/incidents");
+	statistic_define_value(unit->stat_sizes_timedout_read,
+			       STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+			       STATISTIC_DEF_MODE_INC);
+
+	retval |=
+	    statistic_create(&unit->stat_sizes_timedout_nodata, unit->stat_if,
+			     "request_sizes_timedout_nodata",
+			     "bytes/incidents");
+	statistic_define_value(unit->stat_sizes_timedout_nodata,
+			       STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+			       STATISTIC_DEF_MODE_INC);
+
+	retval |=
+	    statistic_create(&unit->stat_latencies_scsi_write, unit->stat_if,
+			     "latencies_scsi_write", "milliseconds/incidents");
+	statistic_define_array(unit->stat_latencies_scsi_write, 0, 1024, 1,
+			       STATISTIC_DEF_SCALE_LOG2);
+
+	retval |=
+	    statistic_create(&unit->stat_latencies_scsi_read, unit->stat_if,
+			     "latencies_scsi_read", "milliseconds/incidents");
+	statistic_define_array(unit->stat_latencies_scsi_read, 0, 1024, 1,
+			       STATISTIC_DEF_SCALE_LOG2);
+
+	retval |=
+	    statistic_create(&unit->stat_latencies_scsi_nodata, unit->stat_if,
+			     "latencies_scsi_nodata", "milliseconds/incidents");
+	statistic_define_array(unit->stat_latencies_scsi_nodata, 0, 1024, 1,
+			       STATISTIC_DEF_SCALE_LOG2);
+
+	retval |=
+	    statistic_create(&unit->stat_pending_scsi_write, unit->stat_if,
+			     "pending_scsi_write", "commands/incidents");
+	statistic_define_range(unit->stat_pending_scsi_write, 0,
+			       STATISTIC_RANGE_MAX);
+
+	retval |= statistic_create(&unit->stat_pending_scsi_read, unit->stat_if,
+				   "pending_scsi_read", "commands/incidents");
+	statistic_define_range(unit->stat_pending_scsi_read, 0,
+			       STATISTIC_RANGE_MAX);
+
+	retval |= statistic_create(&unit->stat_erp, unit->stat_if,
+				   "occurrence_erp", "results/incidents");
+	statistic_define_value(unit->stat_erp,
+			       STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+			       STATISTIC_DEF_MODE_INC);
+
+	retval |= statistic_create(&unit->stat_eh_reset, unit->stat_if,
+				   "occurrence_eh_reset", "results/incidents");
+	statistic_define_value(unit->stat_eh_reset,
+			       STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+			       STATISTIC_DEF_MODE_INC);
+
+	return retval;
+}
+
+int zfcp_unit_statistic_unregister(struct zfcp_unit *unit)
+{
+	return statistic_interface_remove(&unit->stat_if);
+}
+
+#undef ZFCP_LOG_AREA
diff -urpN linux-2.6.16-rc2/include/linux/jiffies.h linux-2.6.16-rc2-git3/include/linux/jiffies.h
--- linux-2.6.16-rc2/include/linux/jiffies.h	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/include/linux/jiffies.h	2006-02-14 15:27:07.000000000 +0100
@@ -441,4 +441,11 @@ static inline u64 nsec_to_clock_t(u64 x)
 	return x;
 }
 
+static inline int nsec_to_timestamp(char *s, unsigned long long t)
+{
+	unsigned long nsec_rem = do_div(t, 1000000000);
+	return sprintf(s, "[%5lu.%06lu]", (unsigned long)t, nsec_rem/1000);
+}
+#define TIMESTAMP_SIZE	30
+
 #endif
diff -urpN linux-2.6.16-rc2/include/linux/list.h linux-2.6.16-rc2-git3/include/linux/list.h
--- linux-2.6.16-rc2/include/linux/list.h	2006-02-14 15:30:51.000000000 +0100
+++ linux-2.6.16-rc2-git3/include/linux/list.h	2006-02-14 15:27:07.000000000 +0100
@@ -411,6 +411,18 @@ static inline void list_splice_init(stru
 	     pos = list_entry(pos->member.next, typeof(*pos), member))
 
 /**
+ * list_for_each_entry_continue_reverse -       iterate backwards over list
+ *                      of given type continuing before existing point
+ * @pos:        the type * to use as a loop counter.
+ * @head:       the head for your list.
+ * @member:     the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_continue_reverse(pos, head, member)                 \
+        for (pos = list_entry(pos->member.prev, typeof(*pos), member);  \
+             prefetch(pos->member.prev), &pos->member != (head);        \
+             pos = list_entry(pos->member.prev, typeof(*pos), member))
+
+/**
  * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
  * @pos:	the type * to use as a loop counter.
  * @n:		another type * to use as temporary storage
diff -urpN linux-2.6.16-rc2/include/linux/parser.h linux-2.6.16-rc2-git3/include/linux/parser.h
--- linux-2.6.16-rc2/include/linux/parser.h	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/include/linux/parser.h	2006-02-14 15:27:07.000000000 +0100
@@ -31,3 +31,5 @@ int match_octal(substring_t *, int *resu
 int match_hex(substring_t *, int *result);
 void match_strcpy(char *, substring_t *);
 char *match_strdup(substring_t *);
+int match_u64(substring_t *, u64 *result, int);
+int match_s64(substring_t *, s64 *result, int);
diff -urpN linux-2.6.16-rc2/include/linux/sgrb.h linux-2.6.16-rc2-git3/include/linux/sgrb.h
--- linux-2.6.16-rc2/include/linux/sgrb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-rc2-git3/include/linux/sgrb.h	2006-02-14 15:27:07.000000000 +0100
@@ -0,0 +1,92 @@
+/*
+ * include/linux/sgrb.h
+ *
+ * a ringbuffer made up of scattered buffers;
+ * holds fixed-size entries smaller than the size of underlying buffers
+ * (ringbuffer resizing has not been implemented)
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Author(s): Martin Peschke <mpeschke@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef SGRB_H
+#define SGRB_H
+
+#define SGRB_H_REVISION "$Revision: 1.2 $"
+
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+
+#define SGRB_BUFFER_SIZE	PAGE_SIZE
+
+struct sgrb_seg {
+	struct list_head list;
+	char *address;
+	int offset;
+	int size;
+};
+
+struct sgrb_ptr {
+	struct sgrb_seg *seg;
+	signed int offset;
+};
+
+struct sgrb {
+	struct list_head seg_lh;
+	struct sgrb_ptr first;
+	struct sgrb_ptr last;
+	int entry_size;
+	int entries;
+};
+
+/**
+ * sgrb_ptr_copy - prepare ringbuffer pointer a by copying b
+ * @a: duplicate
+ * @b: original
+ *
+ * required to prepare a ringbuffer pointer for use with sgrb_consume_nodelete()
+ */
+static inline void sgrb_ptr_copy(struct sgrb_ptr *a, struct sgrb_ptr *b)
+{
+	a->seg = b->seg;
+	a->offset = b->offset;
+}
+
+/**
+ * sgrb_entry - returns address of entry
+ * @a: ringbuffer pointer that determines entry
+ */
+static inline void * sgrb_entry(struct sgrb_ptr *a)
+{
+	return (a->seg->address + a->offset);
+}
+
+extern struct sgrb_seg * sgrb_seg_find(struct list_head *, int, gfp_t);
+extern void sgrb_seg_release_all(struct list_head *);
+
+extern int sgrb_alloc(struct sgrb *, int, int, int, gfp_t);
+extern void sgrb_release(struct sgrb *);
+extern void sgrb_reset(struct sgrb *);
+
+extern void * sgrb_produce_overwrite(struct sgrb *);
+extern void * sgrb_produce_nooverwrite(struct sgrb *);
+extern void * sgrb_consume_delete(struct sgrb *);
+extern void * sgrb_consume_nodelete(struct sgrb *, struct sgrb_ptr *);
+
+#endif /* SGRB_H */
diff -urpN linux-2.6.16-rc2/include/linux/statistic.h linux-2.6.16-rc2-git3/include/linux/statistic.h
--- linux-2.6.16-rc2/include/linux/statistic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-rc2-git3/include/linux/statistic.h	2006-02-14 15:27:07.000000000 +0100
@@ -0,0 +1,449 @@
+/*
+ * include/linux/statistic.h
+ *
+ * Statistics facility
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Author(s): Martin Peschke <mpeschke@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef STATISTIC_H
+#define STATISTIC_H
+
+#define STATISTIC_H_REVISION "$Revision: 1.5 $"
+
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/sgrb.h>
+
+#define STATISTIC_ROOT_DIR	"statistics"
+
+#define STATISTIC_FILENAME_DATA	"data"
+#define STATISTIC_FILENAME_DEF	"definition"
+
+#define STATISTIC_NAME_SIZE	64
+
+#define STATISTIC_RANGE_MIN	-0x7fffffffffffffffLL
+#define STATISTIC_RANGE_MAX	 0x7ffffffffffffffeLL
+
+enum {
+	STATISTIC_DEF_NAME,
+	STATISTIC_DEF_UNIT,
+	STATISTIC_DEF_TYPE_VALUE,
+	STATISTIC_DEF_TYPE_RANGE,
+	STATISTIC_DEF_TYPE_ARRAY,
+	STATISTIC_DEF_TYPE_LIST,
+	STATISTIC_DEF_TYPE_RAW,
+	STATISTIC_DEF_TYPE_HISTORY,
+	STATISTIC_DEF_ON,
+	STATISTIC_DEF_OFF,
+	STATISTIC_DEF_STARTED,
+	STATISTIC_DEF_STOPPED,
+	STATISTIC_DEF_RANGEMIN,
+	STATISTIC_DEF_RANGEMAX,
+	STATISTIC_DEF_SCALE_LIN,
+	STATISTIC_DEF_SCALE_LOG2,
+	STATISTIC_DEF_ENTRIESMAX,
+	STATISTIC_DEF_BASEINT,
+	STATISTIC_DEF_HITSMISSED,
+	STATISTIC_DEF_HITSOUT,
+	STATISTIC_DEF_RESET,
+	STATISTIC_DEF_MODE_INC,
+	STATISTIC_DEF_MODE_PROD,
+	STATISTIC_DEF_MODE_RANGE,
+	STATISTIC_DEF_PERIOD,
+	STATISTIC_DEF_VOID,
+};
+
+struct statistic;
+struct statistic_file_private;
+
+typedef void (statistic_release_fn) (struct statistic *);
+typedef void (statistic_reset_fn) (struct statistic *);
+typedef int (statistic_format_data_fn)
+		(struct statistic *, struct statistic_file_private *);
+typedef int (statistic_format_def_fn) (struct statistic *, char *);
+typedef u64 (statistic_add_fn) (struct statistic *, s64, u64);
+
+struct statistic_entry_list {
+	struct list_head	list;
+	s64			value;
+	u64			hits;
+};
+
+struct statistic_entry_raw {
+	u64 clock;
+	u64 serial;
+	s64 value;
+	u64 incr;
+};
+
+struct statistic_entry_range {
+	u32 res;
+	u32 num;	/* FIXME: better 64 bit; do_div can't deal with it) */
+	s64 acc;
+	s64 min;
+	s64 max;
+};
+
+struct statistic {
+	struct list_head		list;
+	struct statistic_interface	*interface;
+	struct statistic		**stat_ptr;
+	statistic_release_fn		*release;
+	statistic_reset_fn		*reset;
+	statistic_format_data_fn	*format_data;
+	statistic_format_def_fn		*format_def;
+	statistic_add_fn		*add;
+	char	name[STATISTIC_NAME_SIZE];
+	char	units[STATISTIC_NAME_SIZE];
+	u8	type;
+	u8	on;
+	u64	started;
+	u64	stopped;
+	u64	age;
+	s64 	range_min;
+	s64 	range_max;
+	u64	hits_out_of_range;
+	union {
+		struct {
+			/* data */
+			u64 hits;
+			/* user-writeable */
+			int mode;
+		} value;
+		struct {
+			/* data */
+			struct statistic_entry_range range;
+		} range;
+		struct {
+			/* data */
+			u64 *hits;
+			/* user-writeable */
+			u32 base_interval;
+			u8 scale;
+			/* internal */
+			u32 entries;
+		} array;
+		struct {
+			/* data */
+			struct list_head entry_lh;
+			/* user-writeable */
+			u32 entries_max;
+			/* informational for user */
+			u64 hits_missed;
+			/* internal */
+			u32 entries;
+		} list;
+		struct {
+			/* data */
+			struct sgrb rb;
+			/* user-writeable */
+			u32 entries_max;
+			/* internal */
+			u64 next_serial;
+		} raw;
+		struct {
+			/* data */
+			struct sgrb rb;
+			/* user-writeable */
+			u32 entries_max;
+			int mode;
+			u64 period;
+			/* internal */
+			u64 checkpoint;
+			u64 window;
+			u8 entry_size;
+		} history;
+	} data;
+};
+
+struct statistic_interface {
+	struct list_head	list;
+	struct dentry		*debugfs_dir;
+	struct dentry		*data_file;
+	struct dentry		*def_file;
+	struct list_head	statistic_lh;
+	struct semaphore	sem;
+	spinlock_t		lock;
+};
+
+struct statistic_file_private {
+	struct list_head read_seg_lh;
+	struct list_head write_seg_lh;
+	size_t write_seg_total_size;
+};
+
+struct statistic_global_data {
+	struct dentry		*root_dir;
+	struct list_head	interface_lh;
+	struct semaphore	sem;
+};
+
+#ifdef CONFIG_STATISTICS
+
+#define statistic_lock(interface, flags)	\
+		spin_lock_irqsave(&(interface)->lock, flags)
+#define statistic_unlock(interface, flags)	\
+		spin_unlock_irqrestore(&(interface)->lock, flags)
+
+extern int statistic_interface_create(struct statistic_interface **,
+				      const char *);
+extern int statistic_interface_remove(struct statistic_interface **);
+
+extern int statistic_create(struct statistic **, struct statistic_interface *,
+			    const char *, const char *);
+extern int statistic_remove(struct statistic **);
+
+extern int statistic_define_value(struct statistic *, s64, s64, int);
+extern int statistic_define_range(struct statistic *, s64, s64);
+extern int statistic_define_array(struct statistic *, s64, s64, u32, u8);
+extern int statistic_define_list(struct statistic *, s64, s64, u32);
+extern int statistic_define_raw(struct statistic *, s64, s64, u32);
+extern int statistic_define_history(struct statistic *, s64, s64, u32, u64,
+				    int);
+
+extern int statistic_start(struct statistic *);
+extern int statistic_stop(struct statistic *);
+extern void statistic_reset(struct statistic *);
+
+/**
+ * statistic_add - update statistic with (discriminator, increment) pair
+ * @stat: statistic
+ * @value: discriminator
+ * @incr: increment
+ *
+ * The actual processing of (discriminator, increment) is determined by the
+ * the definition applied to the statistic. See the descriptions of the
+ * statistic_define_*() routines for details.
+ *
+ * This variant grabs the lock and should be used when there is _no_ need
+ * to make a bunch of updates to various statistics of an interface,
+ * including the statistic this update is reported for, atomic
+ * in order to be meaningful (get the next coherent state of several
+ * statistics).
+ *
+ * On success, the return value is dependend on which type of accumulation
+ * has been applied through the recent definition. Usually, returns the
+ * updated total of increments reported for this discriminator, if the
+ * defined type of accumulation does this kind of computation.
+ *
+ * If the struct statistic pointer provided by the caller
+ * is NULL (unused), this routine fails, and 0 is returned.
+ *
+ * If some required memory could not be allocated this routine fails,
+ * and 0 is returned.
+ *
+ * If the discriminator is not valid (out of range), this routine fails,
+ * and 0 is returned.
+ */
+static inline u64 statistic_add(struct statistic *stat, s64 value, u64 incr)
+{
+	unsigned long flags;
+	int retval;
+
+	if (stat->on != STATISTIC_DEF_ON)
+		return 0;
+
+	statistic_lock(stat->interface, flags);
+	retval = stat->add(stat, value, incr);
+	statistic_unlock(stat->interface, flags);
+
+	return retval;
+}
+
+/**
+ * statistic_add_nolock - a statistic_add() variant
+ * @stat: statistic
+ * @value: discriminator
+ * @incr: increment
+ *
+ * Same purpose and behavious as statistic_add(). See there for details.
+ *
+ * Only difference to statistic_add():
+ * Lock management is up to the exploiter. Basically, we give exploiters
+ * the option to ensure data consistency across all statistics attached
+ * to a parent interface by adding several calls to this routine into one
+ * critical section protected by stat->interface->lock,
+ */
+static inline u64 statistic_add_nolock(struct statistic *stat, s64 value,
+				       u64 incr)
+{
+	if (stat->on != STATISTIC_DEF_ON)
+		return 0;
+
+#ifdef DEBUG
+	assert_spin_locked(&stat->interface->lock);
+#endif
+
+	return stat->add(stat, value, incr);
+}
+
+/**
+ * statistic_inc - a statistic_add() variant
+ * @stat: statistic
+ * @value: discriminator
+ *
+ * Same purpose and behaviour as statistic_add(). See there for details.
+ * Difference: Increment defaults to 1.
+ */
+static inline u64 statistic_inc(struct statistic *stat, s64 value)
+{
+	unsigned long flags;
+	int retval;
+
+	if (stat->on != STATISTIC_DEF_ON)
+		return 0;
+
+	statistic_lock(stat->interface, flags);
+	retval = stat->add(stat, value, 1);
+	statistic_unlock(stat->interface, flags);
+
+	return retval;
+}
+
+/**
+ * statistic_inc_nolock - a statistic_add_nolock() variant
+ * @stat: statistic
+ * @value: discriminator
+ *
+ * Same purpose and behaviour as statistic_add_nolock(). See there for details.
+ * Difference: Increment defaults to 1.
+ */
+static inline u64 statistic_inc_nolock(struct statistic *stat, s64 value)
+{
+	if (stat->on != STATISTIC_DEF_ON)
+		return 0;
+
+#ifdef DEBUG
+	assert_spin_locked(&stat->interface->lock);
+#endif
+
+	return stat->add(stat, value, 1);
+}
+
+#else /* CONFIG_STATISTICS */
+
+#define statistic_lock(interface, flags)	do { } while (0)
+#define statistic_unlock(interface, flags)	do { } while (0)
+
+static inline int statistic_interface_create(
+				struct statistic_interface **interface_ptr,
+				const char *name)
+{
+	return 0;
+}
+
+static inline int statistic_interface_remove(
+				struct statistic_interface **interface_ptr)
+{
+	return 0;
+}
+
+static inline int statistic_create(struct statistic **stat_ptr,
+				   struct statistic_interface *interface,
+				   const char *name, const char *units)
+{
+	return 0;
+}
+
+static inline int statistic_remove(struct statistic **stat_ptr)
+{
+	return 0;
+}
+
+
+static inline int statistic_define_value(struct statistic *stat, s64 range_min,
+					 s64 range_max, int mode)
+{
+	return 0;
+}
+
+static inline int statistic_define_range(struct statistic *stat, s64 range_min,
+					 s64 range_max)
+{
+	return 0;
+}
+
+static inline int statistic_define_array(struct statistic *stat, s64 range_min,
+					 s64 range_max, u32 base_interval,
+					 u8 scale)
+{
+	return 0;
+}
+
+static inline int statistic_define_list(struct statistic *stat, s64 range_min,
+					s64 range_max, u32 entries_max)
+{
+	return 0;
+}
+
+static inline int statistic_define_raw(struct statistic *stat, s64 range_min,
+				       s64 range_max, u32 entries_max)
+{
+	return 0;
+}
+
+static inline int statistic_define_history(struct statistic *stat,
+					   s64 range_min, s64 range_max,
+					   u32 entries_max, u64 period,
+					   int mode)
+{
+	return 0;
+}
+
+
+static inline int statistic_start(struct statistic *stat)
+{
+	return 0;
+}
+
+static inline int statistic_stop(struct statistic *stat)
+{
+	return 0;
+}
+
+static inline void statistic_reset(struct statistic *stat)
+{
+}
+
+static inline u64 statistic_add(struct statistic *stat, s64 value, u64 incr)
+{
+	return 0;
+}
+
+static inline u64 statistic_add_nolock(struct statistic *stat, s64 value,
+				       u64 incr)
+{
+	return 0;
+}
+
+static inline u64 statistic_inc(struct statistic *stat, s64 value)
+{
+	return 0;
+}
+
+static inline u64 statistic_inc_nolock(struct statistic *stat, s64 value)
+{
+	return 0;
+}
+
+#endif /* CONFIG_STATISTICS */
+
+#endif /* STATISTIC_H */
diff -urpN linux-2.6.16-rc2/kernel/printk.c linux-2.6.16-rc2-git3/kernel/printk.c
--- linux-2.6.16-rc2/kernel/printk.c	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/kernel/printk.c	2006-02-14 15:26:01.000000000 +0100
@@ -532,7 +532,7 @@ asmlinkage int vprintk(const char *fmt, 
 	int printed_len;
 	char *p;
 	static char printk_buf[1024];
-	static int log_level_unknown = 1;
+	static int new_line = 1;
 
 	preempt_disable();
 	if (unlikely(oops_in_progress) && printk_cpu == smp_processor_id())
@@ -547,62 +547,48 @@ asmlinkage int vprintk(const char *fmt, 
 	/* Emit the output into the temporary buffer */
 	printed_len = vscnprintf(printk_buf, sizeof(printk_buf), fmt, args);
 
-	/*
-	 * Copy the output into log_buf.  If the caller didn't provide
-	 * appropriate log level tags, we insert them here
-	 */
-	for (p = printk_buf; *p; p++) {
-		if (log_level_unknown) {
-                        /* log_level_unknown signals the start of a new line */
-			if (printk_time) {
-				int loglev_char;
-				char tbuf[50], *tp;
-				unsigned tlen;
-				unsigned long long t;
-				unsigned long nanosec_rem;
-
-				/*
-				 * force the log level token to be
-				 * before the time output.
-				 */
-				if (p[0] == '<' && p[1] >='0' &&
-				   p[1] <= '7' && p[2] == '>') {
-					loglev_char = p[1];
-					p += 3;
-					printed_len -= 3;
-				} else {
-					loglev_char = default_message_loglevel
-						+ '0';
-				}
-				t = printk_clock();
-				nanosec_rem = do_div(t, 1000000000);
-				tlen = sprintf(tbuf,
-						"<%c>[%5lu.%06lu] ",
-						loglev_char,
-						(unsigned long)t,
-						nanosec_rem/1000);
-
-				for (tp = tbuf; tp < tbuf + tlen; tp++)
-					emit_log_char(*tp);
-				printed_len += tlen;
-			} else {
-				if (p[0] != '<' || p[1] < '0' ||
-				   p[1] > '7' || p[2] != '>') {
-					emit_log_char('<');
-					emit_log_char(default_message_loglevel
-						+ '0');
-					emit_log_char('>');
-					printed_len += 3;
-				}
+ 	/*
+ 	 * Copy the output into log_buf.  If the caller didn't provide
+	 * appropriate log level tags, we insert them here.
+ 	 */
+ 	for (p = printk_buf; *p; p++) {
+		if (new_line) {
+			/* The log level token is first. */
+			int loglev_char;
+			if (p[0] == '<' && p[1] >='0' &&
+			    p[1] <= '7' && p[2] == '>') {
+				loglev_char = p[1];
+				p += 3;
+			} else	{
+				loglev_char = default_message_loglevel + '0';
+				printed_len += 3;
 			}
-			log_level_unknown = 0;
-			if (!*p)
-				break;
-		}
-		emit_log_char(*p);
-		if (*p == '\n')
-			log_level_unknown = 1;
-	}
+			emit_log_char('<');
+			emit_log_char(loglev_char);
+			emit_log_char('>');
+			/* A timestamp, if requested, goes next. */
+ 			if (printk_time) {
+				char tbuf[TIMESTAMP_SIZE], *tp;
+				printed_len += nsec_to_timestamp(tbuf,
+							printk_clock());
+				for (tp = tbuf; *tp; tp++)
+ 					emit_log_char(*tp);
+				emit_log_char(' ');
+				printed_len++;
+ 			}
+			new_line = 0;
+ 			if (!*p)
+ 				break;
+ 		}
+		/*
+		 * Once we are done with special strings at the head of
+		 * each line, we just keep copying characters until
+		 * we come across another line and need to start over.
+		 */
+ 		emit_log_char(*p);
+ 		if (*p == '\n')
+			new_line = 1;
+ 	}
 
 	if (!cpu_online(smp_processor_id())) {
 		/*
diff -urpN linux-2.6.16-rc2/lib/Kconfig linux-2.6.16-rc2-git3/lib/Kconfig
--- linux-2.6.16-rc2/lib/Kconfig	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/lib/Kconfig	2006-02-14 15:27:07.000000000 +0100
@@ -86,4 +86,10 @@ config TEXTSEARCH_BM
 config TEXTSEARCH_FSM
 	tristate
 
+#
+# Scatter-gather ring-buffer is select'ed if needed
+#
+config SGRB
+	boolean
+
 endmenu
diff -urpN linux-2.6.16-rc2/lib/Kconfig.statistic linux-2.6.16-rc2-git3/lib/Kconfig.statistic
--- linux-2.6.16-rc2/lib/Kconfig.statistic	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-rc2-git3/lib/Kconfig.statistic	2006-02-14 15:27:07.000000000 +0100
@@ -0,0 +1,12 @@
+config STATISTICS
+	bool "Statistics infrastructure"
+	depends on DEBUG_FS
+	select SGRB
+	help
+	  The statistics infrastructure provides a debug-fs based user interface
+	  for statistics of kernel components, that is, usually device drivers.
+	  Statistics are available for components that have been instrumented to
+	  feed data into the statistics infrastructure.
+	  This feature is useful for performance measurements or performance
+	  debugging.
+	  If in doubt, say "N".
diff -urpN linux-2.6.16-rc2/lib/Makefile linux-2.6.16-rc2-git3/lib/Makefile
--- linux-2.6.16-rc2/lib/Makefile	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/lib/Makefile	2006-02-14 15:27:07.000000000 +0100
@@ -44,6 +44,9 @@ obj-$(CONFIG_TEXTSEARCH_KMP) += ts_kmp.o
 obj-$(CONFIG_TEXTSEARCH_BM) += ts_bm.o
 obj-$(CONFIG_TEXTSEARCH_FSM) += ts_fsm.o
 
+obj-$(CONFIG_SGRB)	 += sgrb.o
+obj-$(CONFIG_STATISTICS) += statistic.o
+
 obj-$(CONFIG_SWIOTLB) += swiotlb.o
 
 hostprogs-y	:= gen_crc32table
diff -urpN linux-2.6.16-rc2/lib/parser.c linux-2.6.16-rc2-git3/lib/parser.c
--- linux-2.6.16-rc2/lib/parser.c	2006-02-03 07:03:08.000000000 +0100
+++ linux-2.6.16-rc2-git3/lib/parser.c	2006-02-14 15:27:07.000000000 +0100
@@ -140,6 +140,64 @@ static int match_number(substring_t *s, 
 }
 
 /**
+ * match_u64: scan a number in the given base from a substring_t
+ * @s: substring to be scanned
+ * @result: resulting integer on success
+ * @base: base to use when converting string
+ *
+ * Description: Given a &substring_t and a base, attempts to parse the substring
+ * as a number in that base. On success, sets @result to the u64 represented
+ * by the string and returns 0. Returns either -ENOMEM or -EINVAL on failure.
+ */
+int match_u64(substring_t *s, u64 *result, int base)
+{
+        char *endp;
+        char *buf;
+        int ret;
+
+        buf = kmalloc(s->to - s->from + 1, GFP_KERNEL);
+        if (!buf)
+                return -ENOMEM;
+        memcpy(buf, s->from, s->to - s->from);
+        buf[s->to - s->from] = '\0';
+        *result = simple_strtoull(buf, &endp, base);
+        ret = 0;
+        if (endp == buf)
+                ret = -EINVAL;
+        kfree(buf);
+        return ret;
+}
+
+/**
+ * match_s64: scan a number in the given base from a substring_t
+ * @s: substring to be scanned
+ * @result: resulting integer on success
+ * @base: base to use when converting string
+ *
+ * Description: Given a &substring_t and a base, attempts to parse the substring
+ * as a number in that base. On success, sets @result to the s64 represented
+ * by the string and returns 0. Returns either -ENOMEM or -EINVAL on failure.
+ */
+int match_s64(substring_t *s, s64 *result, int base)
+{
+        char *endp;
+        char *buf;
+        int ret;
+
+        buf = kmalloc(s->to - s->from + 1, GFP_KERNEL);
+        if (!buf)
+                return -ENOMEM;
+        memcpy(buf, s->from, s->to - s->from);
+        buf[s->to - s->from] = '\0';
+        *result = simple_strtoll(buf, &endp, base);
+        ret = 0;
+        if (endp == buf)
+                ret = -EINVAL;
+        kfree(buf);
+        return ret;
+}
+
+/**
  * match_int: - scan a decimal representation of an integer from a substring_t
  * @s: substring_t to be scanned
  * @result: resulting integer on success
@@ -218,3 +276,5 @@ EXPORT_SYMBOL(match_octal);
 EXPORT_SYMBOL(match_hex);
 EXPORT_SYMBOL(match_strcpy);
 EXPORT_SYMBOL(match_strdup);
+EXPORT_SYMBOL(match_u64);
+EXPORT_SYMBOL(match_s64);
diff -urpN linux-2.6.16-rc2/lib/sgrb.c linux-2.6.16-rc2-git3/lib/sgrb.c
--- linux-2.6.16-rc2/lib/sgrb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-rc2-git3/lib/sgrb.c	2006-02-14 15:27:07.000000000 +0100
@@ -0,0 +1,329 @@
+/*
+ * lib/sgrb.c
+ *
+ * a ringbuffer made up of scattered buffers;
+ * holds fixed-size entries smaller than the size of underlying buffers
+ * (ringbuffer resizing has not been implemented)
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Author(s): Martin Peschke <mpeschke@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define SGRB_C_REVISION "$Revision: 1.2 $"
+
+#include <linux/module.h>
+#include <linux/sgrb.h>
+
+static struct sgrb_seg * sgrb_seg_alloc(struct list_head *lh, int size,
+					gfp_t gfp)
+{
+	struct sgrb_seg *seg;
+
+	seg = kmalloc(sizeof(struct sgrb_seg), gfp);
+	if (!seg)
+		return NULL;
+	seg->offset = 0;
+	seg->size = size;
+	seg->address = kmalloc(size, gfp);
+	if (!seg->address) {
+		kfree(seg);
+		return NULL;
+	}
+	list_add_tail(&seg->list, lh);
+	return seg;
+}
+
+/**
+ * sgrb_seg_find - find room for another entry
+ * @lh: list_head that holds list of scattered buffers used to store entries
+ * @size: entry size (must be smaller than size of underlying buffers)
+ * @gfp: GFP_* flags used if another buffer needs to be allocated
+ *
+ * tries to find room for an entry in buffer alloacted last, and if required
+ * allocates another buffer
+ */
+struct sgrb_seg * sgrb_seg_find(struct list_head *lh, int size, gfp_t gfp)
+{
+	struct sgrb_seg *seg;
+
+	list_for_each_entry_reverse(seg, lh, list) {
+		if ((seg->size - seg->offset) >= size)
+			return seg;
+		break;
+	}
+	return sgrb_seg_alloc(lh, SGRB_BUFFER_SIZE, gfp);
+}
+EXPORT_SYMBOL_GPL(sgrb_seg_find);
+
+/**
+ * sgrb_seg_release_all - releases scatter-gather buffer
+ * @lh: list_head that holds list of scattered buffer parts
+ */
+void sgrb_seg_release_all(struct list_head *lh)
+{
+	struct sgrb_seg *seg, *tmp;
+
+	list_for_each_entry_safe(seg, tmp, lh, list) {
+		list_del(&seg->list);
+		kfree(seg->address);
+		kfree(seg);
+	}
+}
+EXPORT_SYMBOL_GPL(sgrb_seg_release_all);
+
+static inline int sgrb_ptr_identical(struct sgrb_ptr *a, struct sgrb_ptr *b)
+{
+	if (a->seg == b->seg &&
+	    a->offset == b->offset)
+		return 1;
+	else
+		return 0;
+}
+
+static inline int sgrb_ptr_valid(struct sgrb_ptr *a)
+{
+	return (a->offset >= 0);
+}
+
+static inline void sgrb_ptr_invalidate(struct sgrb *rb, struct sgrb_ptr *a)
+{
+	a->offset = -rb->entry_size;
+}
+
+static inline void sgrb_init(struct sgrb *rb)
+{
+	sgrb_ptr_invalidate(rb, &rb->first);
+	sgrb_ptr_invalidate(rb, &rb->last);
+	rb->entries = 0;
+}
+
+void sgrb_reset(struct sgrb *rb)
+{
+	sgrb_init(rb);
+}
+EXPORT_SYMBOL(sgrb_reset);
+
+/**
+ * sgrb_alloc - prepare a new ringbuffer for use
+ *
+ * @rb: a ringbuffer struct provided by the exploiter
+ * @entry_size: size of entries in ringbuffer
+ * @entry_num: total number of entries in ringbuffer
+ * @seg_size: size of underlying scatter-gather segments used to build up
+ *            ringbuffer
+ * @gfp: GFP_* flags for kmalloc()
+ *
+ * Returns 0 on success.
+ * Returns -ENOMEM if some memory allocation failed.
+ */
+int sgrb_alloc(struct sgrb *rb, int entry_size, int entry_num, int seg_size,
+	       gfp_t gfp)
+{
+	int i;
+	struct sgrb_seg *seg;
+	int entries_per_seg = (seg_size / entry_size);
+	int seg_num = entry_num / entries_per_seg;
+	int residual = (entry_num % entries_per_seg) * entry_size;
+
+	rb->entry_size = entry_size;
+	INIT_LIST_HEAD(&rb->seg_lh);
+	for (i = 0; i < seg_num; i++)
+		if (!sgrb_seg_alloc(&rb->seg_lh, seg_size, gfp)) {
+			sgrb_release(rb);
+			return -ENOMEM;
+		}
+	if (residual)
+		if (!sgrb_seg_alloc(&rb->seg_lh, residual, gfp)) {
+			sgrb_release(rb);
+			return -ENOMEM;
+		}
+	/* get the first list entry */
+	list_for_each_entry(seg, &rb->seg_lh, list)
+		break;
+	rb->first.seg = seg;
+	rb->last.seg = seg;
+	sgrb_init(rb);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sgrb_alloc);
+
+/**
+ * sgrb_release - destroy a ringbuffer
+ *
+ * @rb: the ringbuffer to release
+ *
+ * It is the callers responsibility to make sure that the ringbuffer is
+ * unused.
+ */
+void sgrb_release(struct sgrb *rb)
+{
+	sgrb_seg_release_all(&rb->seg_lh);
+}
+EXPORT_SYMBOL_GPL(sgrb_release);
+
+static void sgrb_next_entry(struct sgrb *rb, struct sgrb_ptr *pos,
+			    struct sgrb_ptr *next)
+{
+	sgrb_ptr_copy(next, pos);
+	next->offset += rb->entry_size;
+	if ((next->offset + rb->entry_size) - 1 > next->seg->size) {
+		if (rb->seg_lh.prev == &next->seg->list) {
+			next->seg = NULL;
+			next->seg = list_prepare_entry(next->seg, &rb->seg_lh, list);
+		}
+		/* get the first list entry */
+		list_for_each_entry_continue(next->seg, &rb->seg_lh, list)
+			break;
+		next->offset = 0;
+	}
+}
+
+/**
+ * sgrb_produce_overwrite - put an entry into the ringbuffer and
+ *     overwrite an older entry if required
+ *
+ * @rb: the ringbuffer being worked with
+ *
+ * It is the callers responsibility to protect the critical section
+ * as described here through locking:
+ * 	spin_lock(lock_for_this_ringbuffer);
+ * 	entry = sgrb_produce_overwrite(&ringbuffer);
+ *	write entry;
+ *	spin_unlock(lock_for_this_ringbuffer);
+ *
+ * Always returns address of the new entry.
+ */
+void * sgrb_produce_overwrite(struct sgrb *rb)
+{
+	struct sgrb_ptr next;
+
+	sgrb_next_entry(rb, &rb->last, &next);
+	if (!sgrb_ptr_valid(&rb->first))
+		sgrb_ptr_copy(&rb->first, &next);
+	else if (sgrb_ptr_identical(&next, &rb->first))
+		sgrb_consume_delete(rb);
+	sgrb_ptr_copy(&rb->last, &next);
+	rb->entries++;
+	return sgrb_entry(&next);
+}
+EXPORT_SYMBOL_GPL(sgrb_produce_overwrite);
+
+/**
+ * sgrb_produce_nooverwrite - put an entry into the ringbuffer
+ *     if there is room without the need to overwrite the oldest
+ *     entry not yet deleted on consumption
+ *
+ * @rb: the ringbuffer being worked with
+ *
+ * It is the callers responsibility to protect the critical section
+ * as described here through locking:
+ * 	spin_lock(lock_for_this_ringbuffer);
+ * 	entry = sgrb_produce_nooverwrite(&ringbuffer);
+ *	if (entry)
+ *		write entry;
+ *	spin_unlock(lock_for_this_ringbuffer);
+ *
+ * Returns address of the new entry, if there is room for it.
+ * Returns NULL otherwise.
+ */
+void * sgrb_produce_nooverwrite(struct sgrb *rb)
+{
+	struct sgrb_ptr next;
+
+	sgrb_next_entry(rb, &rb->last, &next);
+	if (!sgrb_ptr_valid(&rb->first))
+		sgrb_ptr_copy(&rb->first, &next);
+	else if (sgrb_ptr_identical(&next, &rb->first))
+		return NULL;
+	rb->entries++;
+	return sgrb_entry(&next);
+}
+EXPORT_SYMBOL_GPL(sgrb_produce_nooverwrite);
+
+/**
+ * sgrb_consume_delete - get an entry from the ringbuffer and
+ *     delete the entry from the ringbuffer so that it can't
+ *     be consumed twice, and in order to free up its slot for
+ *     another entry
+ *
+ * @rb: the ringbuffer being worked with
+ *
+ * It is the callers responsibility to protect the critical section
+ * as described here through locking:
+ * 	spin_lock(lock_for_this_ringbuffer);
+ * 	entry = sgrb_consume_delete(&ringbuffer);
+ *	read entry;
+ *	spin_unlock(lock_for_this_ringbuffer);
+ *
+ * Returns address of the entry read, if there is an entry available.
+ * Returns NULL otherwise.
+ */
+void * sgrb_consume_delete(struct sgrb *rb)
+{
+	struct sgrb_ptr prev;
+
+	if (!sgrb_ptr_valid(&rb->first))
+		return NULL;
+	sgrb_ptr_copy(&prev, &rb->first);
+	if (sgrb_ptr_identical(&rb->last, &rb->first))
+		sgrb_init(rb);
+	else
+		sgrb_next_entry(rb, &rb->first, &rb->first);
+	rb->entries--;
+	return sgrb_entry(&prev);
+}
+EXPORT_SYMBOL_GPL(sgrb_consume_delete);
+
+/**
+ * sgrb_consume_nodelete - get an entry from the ringbuffer
+ *     while keeping this entry in the ringbuffer so that it can
+ *     be consumed again
+ *
+ * @rb: the ringbuffer being worked with
+ * @pos: the ringbuffer pointer that determines which entry to consume
+ *
+ * Use sgrb_ptr_copy() to prepare pos prior to iterating over the ringbuffer
+ * (copy rb->first, the producers tail and the consumers head, to pos).
+ * This routine is particularly useful to get a snapshot of the complete
+ * content of the ringbuffer without changing it.
+ *
+ * It is the callers responsibility to protect the critical section
+ * as described here through locking:
+ * 	spin_lock(lock_for_this_ringbuffer);
+ * 	sgrb_ptr_copy(&i, &ringbuffer.first);
+ * 	while (entry = sgrb_consume_nodelete(&ringbuffer, &i))
+ *		read entry;
+ *	spin_unlock(lock_for_this_ringbuffer);
+ *
+ * Returns address of the entry read, if there is an entry available.
+ * Returns NULL otherwise.
+ */
+void * sgrb_consume_nodelete(struct sgrb *rb, struct sgrb_ptr *pos)
+{
+	struct sgrb_ptr prev;
+
+	if (!sgrb_ptr_valid(pos))
+		return NULL;
+	sgrb_ptr_copy(&prev, pos);
+	if (sgrb_ptr_identical(&rb->last, pos))
+		sgrb_ptr_invalidate(rb, pos);
+	else
+		sgrb_next_entry(rb, pos, pos);
+	return sgrb_entry(&prev);
+}
+EXPORT_SYMBOL_GPL(sgrb_consume_nodelete);
diff -urpN linux-2.6.16-rc2/lib/statistic.c linux-2.6.16-rc2-git3/lib/statistic.c
--- linux-2.6.16-rc2/lib/statistic.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-rc2-git3/lib/statistic.c	2006-02-14 15:27:07.000000000 +0100
@@ -0,0 +1,2183 @@
+/*
+ *  lib/statistic.c
+ *    statistics facility
+ *
+ *    Copyright (C) 2005 IBM Deutschland Entwicklung GmbH,
+ *                       IBM Corporation
+ *
+ *    Author(s): Martin Peschke (mpeschke@de.ibm.com),
+ *
+ *    Bugreports to: <Linux390@de.ibm.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *    todos:
+ *	- see locking rules; one tbd remaining
+ *	- define a set of agreed names or a naming scheme for
+ *	  consistency and comparability across exploiters
+ *	  (e.g. similar statistic names for latencies of dasd driver
+ *	  and zfcp driver); this entails an agreement about granularities
+ *	  as well (e.g. separate statistic for read/write/no-data commands);
+ *	  a common set of unit strings would be nice then, too, of course
+ *	  (e.g. "seconds", "milliseconds", "microseconds", ...)
+ *	- seq_file use might simplify this code
+ *
+ *
+ *    another bunch of ideas being pondered:
+ *	- provide a (perl?) script for automatic reformating and processing of
+ *	  the contents of "data" files (for generating fancy tables, diagrams
+ *	  in ASCII-art, XML-output ready to be imported into the OpenOffice
+ *	  spreadsheet/diagram tool, ... you name it); a generic script that
+ *	  takes hints from "definition" files into account would basically
+ *	  suffice for all exploiters
+ *	- slim down struct statistic and move on/off/reset/started/stopped
+ *        etc. up to struct statistic_interface???
+ *	  (Is there a need to turn individual statistic on and off etc; or
+ *	  is it more handy and sufficient to allow that only for the entirety
+ *	  of all statistic attached to an interface?)
+ *	- some user-configurable that allows to release unused resources
+ *	  of stopped statistic; or release on stop / allocate on start?
+ *	- perf. opt. of array: table lookup of values, binary search for values
+ *	- another statistic disclipline based on some sort of tree, but
+ *	  similar in semantics to list discipline (for high-perf. histograms of
+ *	  discrete values)
+ *	- use list entries (visible in data file) for hits_out_of_range/
+ *	  hits_missed instead of meta data values (visible in definition file)
+ *	  on analogy to first and last entries of array discipline (<=range_min,
+ *	  >range_max)???
+ *	- allow for more than a single "view" on data at the same time by
+ *	  providing the capability to attach several (a list of) "definitions"
+ *	  to a struct statistic
+ *	  (e.g. show histogram of requests sizes and history of megabytes/sec.
+ *	  at the same time)
+ *	- group similar statitistics in classes and allow for redefinitions
+ *	  per group
+ *	  (e.g. [automagically?] group all list disciplines of request sizes
+ *	  gathered by zfcp in order to allow for a single-operation redefinition
+ *	  of range_max for all of them)
+ *	- multi-dimensional statistic (combination of two or more
+ *	  characteristics/discriminators); worth the effort??
+ *	  (e.g. a matrix of occurences for latencies of requests of
+ *	  particular sizes)
+ *	- allow exploiters to register a callback with every struct statistic
+ *	  (or statistic interface?) in order to be able to do another
+ *	  statitics update when the user reads the data file; would be useful
+ *	  for gathering statistic data about any ongoing condition
+ *	- have exploiters always provide the best granularity possible
+ *	  (like nanoseconds instead of milliseconds) in order to keep
+ *	  flexibility, and have the statitics user interface handle any
+ *	  desired computation (like from nanoseconds to milliseconds)
+ *	- allow user to choose hex/oct/dec representation of numbers
+ *	- make "history" an extra option that allows it to combine with
+ *	  any other type/discipline??? (history request size lists???)
+ *	- split out the definition of range_min/range_max from existing
+ *	  definition functions
+ *
+ *
+ *    locking rules
+ *	- We grab a global semaphore on calls to statistic_interface_create() /
+ *	  statistic_interface_remove() to make sure various exploiters do not
+ *	  interfere with each other by corrupting internal global data (list).
+ *	- Once an interface has been created, it is assumed that the exploiter
+ *	  serialises any other setup or closure business related to statistics
+ *	  attached to the same interface. No internal locking for this purpose!
+ *	- data reading vs. data gathering vs. redefinition (incl. on/off/reset):
+ *	  We hold the interfaces spinlock to make sure that statistics' meta
+ *	  data as well their data is not being messed with concurrently,
+ *	  and coherent on reading (concurrent updates shall not interfere).
+ *	- data gathering vs. removal of statistic: It is assumed that the
+ *	  exploiter makes sure that data gathering has ceased prior to removing
+ *	  a statistic.
+ *	- multiple related data updates in the scope of a single interface:
+ *	  We provide *_nolock variants of the statistic_inc() /
+ *	  statistic_add() routines, and thus allow exploiters to manage
+ *	  locking during updates. This way multiple updates can be made in
+ *	  an atomic fashion. Exploiters are encouraged to make use of this
+ *	  if an atomic update of more than one statistic is required to
+ *	  generate the next valid state as to the coherence of related
+ *	  statistics.
+ *	- touching files by user vs. removal of anything: tbd
+ *
+ *    known bugs:
+ *      - Statistics of type "history" are continuesly updated even if being
+ *	  turned off. Fix: implement statistic_stop_history() and move the
+ *	  beforementioned enforced update - inactivity case - there from
+ *	  statistic_format_data_history().
+ */
+
+#define STATISTIC_C_REVISION "$Revision: 1.5 $"
+
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/parser.h>
+#include <linux/time.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+
+#include <asm/bug.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+
+#include <linux/sgrb.h>
+#include <linux/statistic.h>
+
+extern void tod_to_timeval(__u64, struct timespec *);
+
+struct statistic_global_data statistic_globals;
+
+static int statistic_interface_generic_close(struct inode *inode,
+					     struct file *file);
+static ssize_t statistic_interface_generic_read(struct file *, char __user *,
+						size_t, loff_t *);
+static ssize_t statistic_interface_generic_write(struct file *,
+					const char __user *, size_t, loff_t *);
+
+static int statistic_interface_def_open(struct inode *, struct file *);
+static int statistic_interface_def_close(struct inode *, struct file *);
+
+static int statistic_interface_data_open(struct inode *, struct file *);
+
+struct file_operations statistic_def_file_ops = {
+	.owner		= THIS_MODULE,
+	.read		= statistic_interface_generic_read,
+	.write		= statistic_interface_generic_write,
+	.open		= statistic_interface_def_open,
+	.release	= statistic_interface_def_close,
+};
+
+struct file_operations statistic_data_file_ops = {
+	.owner		= THIS_MODULE,
+	.read		= statistic_interface_generic_read,
+	.open		= statistic_interface_data_open,
+	.release	= statistic_interface_generic_close,
+};
+
+/*
+ * FIXME:
+ * Is there any way to get rid of statistic_strings by merging it somehow into
+ * statistic_def?
+ */
+static char * statistic_strings[] = {
+	"name=",
+	"units=",
+	"type=value",
+	"type=range",
+	"type=array",
+	"type=list",
+	"type=raw",
+	"type=history",
+	"on=1",
+	"on=0",
+	"started=",
+	"stopped=",
+	"range_min=",
+	"range_max=",
+	"scale=lin",
+	"scale=log2",
+	"entries_max=",
+	"base_interval=",
+	"hits_missed=",
+	"hits_out_of_range=",
+	"data=",
+	"mode=increments",
+	"mode=products",
+	"mode=range",
+	"period=",
+	NULL
+};
+
+static match_table_t statistic_def = {
+	{STATISTIC_DEF_NAME, "name=%s"},
+	{STATISTIC_DEF_UNIT, "units="},
+	{STATISTIC_DEF_TYPE_VALUE, "type=value"},
+	{STATISTIC_DEF_TYPE_RANGE, "type=range"},
+	{STATISTIC_DEF_TYPE_ARRAY, "type=array"},
+	{STATISTIC_DEF_TYPE_LIST, "type=list"},
+	{STATISTIC_DEF_TYPE_RAW, "type=raw"},
+	{STATISTIC_DEF_TYPE_HISTORY, "type=history"},
+	{STATISTIC_DEF_ON, "on=1"},
+	{STATISTIC_DEF_OFF, "on=0"},
+	{STATISTIC_DEF_STARTED, "started="},
+	{STATISTIC_DEF_STOPPED, "stopped="},
+	{STATISTIC_DEF_RANGEMIN, "range_min=%s"},
+	{STATISTIC_DEF_RANGEMAX, "range_max=%s"},
+	{STATISTIC_DEF_SCALE_LIN, "scale=lin"},
+	{STATISTIC_DEF_SCALE_LOG2, "scale=log2"},
+	{STATISTIC_DEF_ENTRIESMAX, "entries_max=%u"},
+	{STATISTIC_DEF_BASEINT, "base_interval=%s"},
+	{STATISTIC_DEF_HITSMISSED, "hits_missed="},
+	{STATISTIC_DEF_HITSOUT, "hits_out_of_range="},
+	{STATISTIC_DEF_RESET, "data=reset"},
+	{STATISTIC_DEF_MODE_INC, "mode=increments"},
+	{STATISTIC_DEF_MODE_PROD, "mode=products"},
+	{STATISTIC_DEF_MODE_RANGE, "mode=range"},
+	{STATISTIC_DEF_PERIOD, "period=%s"},
+	{STATISTIC_DEF_VOID, NULL}
+};
+
+/* code concerned with module matters */
+
+int __init statistic_init(void)
+{
+	sema_init(&statistic_globals.sem, 1);
+	INIT_LIST_HEAD(&statistic_globals.interface_lh);
+	statistic_globals.root_dir = debugfs_create_dir(STATISTIC_ROOT_DIR, NULL);
+	return 0;
+}
+
+void __exit statistic_exit(void)
+{
+	/*
+	 * FIXME: any need to cleanup any statistic possibly still allocated?
+	 * (would only concern leftovers of exploiters - someone elses problem?)
+	 */
+	debugfs_remove(statistic_globals.root_dir);
+}
+
+/* code mostly concerned with accounting */
+
+static inline int statistic_start_nolock(struct statistic *stat)
+{
+	int retval = stat->on;
+
+	stat->on = STATISTIC_DEF_ON;
+	stat->started = sched_clock();
+
+	return retval;
+}
+
+/**
+ * statistic_start - enable statistic for data gathering
+ * @stat: statistic to be enabled
+ *
+ * Start data gathering without discarding old data.
+ * Function is both available to exploiting device drivers as well as to
+ * the user through the "definition" file.
+ *
+ * On success, returns the previous on/off state.
+ */
+int statistic_start(struct statistic *stat)
+{
+	unsigned long flags;
+	int retval;
+
+	statistic_lock(stat->interface, flags);
+	retval = statistic_start_nolock(stat);
+	statistic_unlock(stat->interface, flags);
+
+	return retval;
+}
+
+static inline int statistic_stop_nolock(struct statistic *stat)
+{
+	int retval = stat->on;
+
+	stat->on = STATISTIC_DEF_OFF;
+	stat->stopped = sched_clock();
+
+	return retval;
+}
+
+/**
+ * statistic_stop - disable statistic for data gathering
+ * @stat: statistic to be disabled
+ *
+ * Stop data gathering without discarding old data.
+ * Function is both available to exploiting device drivers as well as to
+ * the user through the "definition" file.
+ *
+ * On success, returns the previous on/off state.
+ */
+int statistic_stop(struct statistic *stat)
+{
+	unsigned long flags;
+	int retval;
+
+	statistic_lock(stat->interface, flags);
+	retval = statistic_stop_nolock(stat);
+	statistic_unlock(stat->interface, flags);
+
+	return retval;
+}
+
+static inline void statistic_reset_nolock(struct statistic *stat)
+{
+	stat->reset(stat);
+	stat->hits_out_of_range = 0;
+	stat->age = sched_clock();
+}
+
+/**
+ * statistic_reset - discard data gathered so far
+ * @stat: statistic to be reset
+ *
+ * Discard any gathered data without changing the on/off state.
+ * Function is both available to exploiting device drivers as well as to
+ * the user through the "definition" file.
+ */
+void statistic_reset(struct statistic *stat)
+{
+	unsigned long flags;
+
+	statistic_lock(stat->interface, flags);
+	statistic_reset_nolock(stat);
+	statistic_unlock(stat->interface, flags);
+}
+
+/**
+ * statistic_create - create a statistic and attach it to a given interface
+ * @stat_ptr: reference to struct statistic pointer
+ * @interface_ptr: struct statistic_interface pointer
+ * @name: name of statistic to be created and as seen in "data" and
+ *        "definition" files
+ * @units: string describing the units of the (discriminator, value) pairs
+ *	   that are the raw data delivered by the exploiter to
+ *	   the statistics facility for every update to a statistic,
+ *         exported through the definition file for users' information,
+ *	   suggested format "unit1/unit2" (no blanks!)
+ *
+ * Create a statistic, which - after being defined and enabled - is ready
+ * to capture and compute data provided by the exploiter. A line in the
+ * interface's "definition" file will hold specifics about the named statistic.
+ * The statistic is defined as type "value" by default for the convenience
+ * of the statistics code which can now rely on a statistic to have some
+ * valid settings all the time.
+ *
+ * On success, 0 is returned, and the struct statistic pointer
+ * provided by the caller points to a newly allocated struct.
+ *
+ * If the struct statistic pointer provided by the caller
+ * is not NULL (used), this routine fails, the struct statistic
+ * pointer is not changed, and -EINVAL is returned.
+ *
+ * If some required memory could not be allocated this routine fails,
+ * the struct statistic pointer is not changed, and -ENOMEM is returned.
+ */
+int statistic_create(struct statistic **stat_ptr,
+		     struct statistic_interface *interface,
+		     const char *name, const char *units)
+{
+	struct statistic *stat;
+	unsigned long flags;
+
+	if (*stat_ptr || !interface)
+		return -EINVAL;
+
+	stat = kmalloc(sizeof(struct statistic), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+	memset(stat, 0, sizeof(struct statistic));
+
+	stat->interface = interface;
+	strlcpy(stat->name, name, sizeof(stat->name));
+	strlcpy(stat->units, units, sizeof(stat->units));
+	statistic_define_value(stat, STATISTIC_RANGE_MIN, STATISTIC_RANGE_MAX,
+				STATISTIC_DEF_MODE_INC);
+	statistic_stop_nolock(stat);
+	stat->started = stat->stopped;
+	stat->stat_ptr = stat_ptr;
+
+	statistic_lock(interface, flags);
+	list_add_tail(&stat->list, &interface->statistic_lh);
+	*stat_ptr = stat;
+	statistic_unlock(interface, flags);
+
+	return 0;
+}
+
+/**
+ * statistic_remove - remove given statistic
+ * @stat_ptr: reference to struct statistic pointer
+ *
+ * Remove statistic along with its recent data and definition.
+ *
+ * On success, 0 is returned and the struct statistic pointer
+ * provided by the caller is set to NULL.
+ *
+ * If the struct statistic pointer provided by the caller
+ * is NULL (unused), this routine fails, the struct statistic
+ * pointer is not changed, and -EINVAL is returned.
+ */
+int statistic_remove(struct statistic **stat_ptr)
+{
+	unsigned long flags;
+
+	if (!*stat_ptr)
+		return -EINVAL;
+
+	statistic_lock((*stat_ptr)->interface, flags);
+	if ((*stat_ptr)->release)
+		(*stat_ptr)->release(*stat_ptr);
+	list_del(&(*stat_ptr)->list);
+	kfree(*stat_ptr);
+	*stat_ptr = NULL;
+	statistic_unlock((*stat_ptr)->interface, flags);
+
+	return 0;
+}
+
+static int statistic_format_def(struct statistic *stat,
+				struct statistic_file_private *private)
+{
+	struct sgrb_seg *seg;
+	char t0[TIMESTAMP_SIZE], t1[TIMESTAMP_SIZE], t2[TIMESTAMP_SIZE];
+
+	seg = sgrb_seg_find(&private->read_seg_lh, 1024, GFP_ATOMIC);
+	if (!seg)
+		return -ENOMEM;
+
+	seg->offset += sprintf(seg->address + seg->offset,
+				"%s%s %s %s %s%lld %s%lld",
+				statistic_strings[STATISTIC_DEF_NAME],
+				stat->name,
+				statistic_strings[stat->on],
+				statistic_strings[stat->type],
+				statistic_strings[STATISTIC_DEF_RANGEMIN],
+				(long long signed)stat->range_min,
+				statistic_strings[STATISTIC_DEF_RANGEMAX],
+				(long long signed)stat->range_max);
+
+	if (stat->format_def)
+		seg->offset += stat->format_def(stat,
+						seg->address + seg->offset);
+
+	nsec_to_timestamp(t0, stat->age);
+	nsec_to_timestamp(t1, stat->started);
+	nsec_to_timestamp(t2, stat->stopped);
+
+	seg->offset += sprintf(seg->address + seg->offset,
+				" %s%llu %s%s %s%s %s%s %s%s\n\n",
+				statistic_strings[STATISTIC_DEF_HITSOUT],
+				(long long unsigned)stat->hits_out_of_range,
+				statistic_strings[STATISTIC_DEF_RESET], t0,
+				statistic_strings[STATISTIC_DEF_STARTED], t1,
+				statistic_strings[STATISTIC_DEF_STOPPED], t2,
+				statistic_strings[STATISTIC_DEF_UNIT],
+				stat->units);
+
+	return 0;
+}
+
+/* code concerned with single value statistics */
+
+static void statistic_reset_value(struct statistic *stat)
+{
+	stat->data.value.hits = 0;
+}
+
+static inline void _statistic_format_data_value(struct statistic *stat,
+				struct sgrb_seg *seg, char *s, u64 value)
+{
+	seg->offset += sprintf(seg->address + seg->offset, "%s%s %llu\n",
+				stat->name, s,
+				(unsigned long long)stat->data.value.hits);
+}
+
+static int statistic_format_data_value(struct statistic *stat,
+				       struct statistic_file_private *private)
+{
+	struct sgrb_seg *seg;
+
+	seg = sgrb_seg_find(&private->read_seg_lh, 128, GFP_ATOMIC);
+	if (!seg)
+		return -ENOMEM;
+
+	_statistic_format_data_value(stat, seg, "", stat->data.value.hits);
+	return 0;
+}
+
+static int statistic_format_def_value(struct statistic *stat, char *line)
+{
+	return sprintf(line, " %s", statistic_strings[stat->data.value.mode]);
+}
+
+static inline u64 _statistic_add_value_increments(s64 *single, s64 value,
+						  u64 incr)
+{
+	return (*single += incr);
+}
+
+static inline u64 _statistic_add_value_products(s64 *single, s64 value,
+						u64 incr)
+{
+	if (value < 0)
+		value = -value;
+	return (*single += value * incr);
+}
+
+static u64 statistic_add_value_increments(struct statistic *stat, s64 value,
+					  u64 incr)
+{
+	if (value < stat->range_min || value > stat->range_max) {
+		stat->hits_out_of_range++;
+		return 0;
+	}
+	return _statistic_add_value_increments(
+			&stat->data.value.hits, value, incr);
+}
+
+static u64 statistic_add_value_products(struct statistic *stat, s64 value,
+					u64 incr)
+{
+	if (value < stat->range_min || value > stat->range_max) {
+		stat->hits_out_of_range++;
+		return 0;
+	}
+	return _statistic_add_value_products(
+			&stat->data.value.hits, value, incr);
+}
+
+/**
+ * statistic_define_value - instantiate statistic as single value (counter)
+ * @stat: statistic to be defined
+ * @range_min: lower bound of discriminators
+ * @range_max: upper bound of discriminators
+ * @mode: determines how to use the counter
+ *
+ * Depending on the mode parameter, accumulation is done as
+ *
+ * a) <total> += <increment N>				(mode=increments)
+ * b) <total> += ABS(<discriminator N>) * <increment N>	(mode=products)
+ *
+ * The output format of a single value statistic found in the "data" file is:
+ * <statistic name> <total>
+ *
+ * This (re)definition function is available both to exploiting device drivers
+ * and to the user through the "definition" file. Device driver programmers
+ * might find it user-friendly to provide a default definition for a
+ * particular statistic by calling this or a related function. A previous
+ * definition is replaced by the new one. In addition, the statistic must be
+ * started in order to make it gather data. A line in the interface's "definition"
+ * file holds specifics about the named statistic.
+ *
+ * This routines always succeeds and returns 0.
+ */
+int statistic_define_value(struct statistic *stat, s64 range_min, s64 range_max,
+			   int mode)
+{
+	unsigned long flags;
+
+	if (mode != STATISTIC_DEF_MODE_INC &&
+	    mode != STATISTIC_DEF_MODE_PROD)
+		return -EINVAL;
+
+	statistic_lock(stat->interface, flags);
+
+	if (stat->release)
+		stat->release(stat);
+
+	stat->type = STATISTIC_DEF_TYPE_VALUE;
+	stat->range_min = range_min;
+	stat->range_max = range_max;
+	stat->data.value.mode = mode;
+
+	stat->release = NULL;
+	stat->reset = statistic_reset_value;
+	stat->format_data = statistic_format_data_value;
+	stat->format_def = statistic_format_def_value;
+	if (mode == STATISTIC_DEF_MODE_INC)
+		stat->add = statistic_add_value_increments;
+	else
+		stat->add = statistic_add_value_products;
+
+	statistic_reset_nolock(stat);
+
+	statistic_unlock(stat->interface, flags);
+
+	return 0;
+}
+
+/* code concerned with range statistic */
+
+static inline void statistic_init_range(struct statistic_entry_range *range,
+					s64 range_min, s64 range_max)
+{
+	range->num = 0;
+	range->acc = 0;
+	range->min = range_max + 1;
+	range->max = range_min - 1;
+}
+
+static void statistic_reset_range(struct statistic *stat)
+{
+	statistic_init_range(
+		&stat->data.range.range, stat->range_min, stat->range_max);
+}
+
+static inline void _statistic_format_data_range(struct statistic *stat,
+	struct sgrb_seg *seg, char *s, struct statistic_entry_range *range)
+{
+	long long unsigned whole = 0;
+	long long signed min = 0, max = 0, decimal = 0, last_digit;
+
+	if (range->num) {
+		whole = range->acc;
+		do_div(whole, range->num);
+		decimal  = range->acc * 10000;
+		do_div(decimal, range->num);
+		decimal -= whole * 10000;
+		if (decimal < 0)
+			decimal = -decimal;
+		last_digit = decimal;
+		do_div(last_digit, 10);
+		last_digit = decimal - last_digit * 10;
+		if (last_digit >= 5)
+			decimal += 10;
+		do_div(decimal, 10);
+		min = range->min;
+		max = range->max;
+	}
+
+	seg->offset += sprintf(seg->address + seg->offset,
+				"%s%s %llu %lld %lld.%03lld %lld\n",
+				stat->name, s,
+				(long long unsigned)range->num,
+				(long long signed)min,
+				whole, decimal,
+				(long long signed)max);
+}
+
+static int statistic_format_data_range(struct statistic *stat,
+				       struct statistic_file_private *private)
+{
+	struct sgrb_seg *seg;
+
+	seg = sgrb_seg_find(&private->read_seg_lh, 128, GFP_ATOMIC);
+	if (!seg)
+		return -ENOMEM;
+
+	_statistic_format_data_range(
+		stat, seg, "", &stat->data.range.range);
+	return 0;
+}
+
+static inline u64 _statistic_add_range(struct statistic_entry_range *range,
+				       s64 value, u64 incr)
+{
+	range->num += incr;
+	range->acc += value * incr;
+	if (value < range->min)
+		range->min = value;
+	if (value > range->max)
+		range->max = value;
+	return range->num;
+}
+
+static u64 statistic_add_range(struct statistic *stat, s64 value, u64 incr)
+{
+	if (value < stat->range_min || value > stat->range_max) {
+		stat->hits_out_of_range++;
+		return 0;
+	}
+	return _statistic_add_range(&stat->data.range.range, value, incr);
+}
+
+/**
+ * statistic_define_range - instantiate statistic as small set of values
+ *    that describe a range of observed discriminitors
+ * @stat: statistic to be defined
+ * @range_min: lower bound of discriminators
+ * @range_max: upper bound of discriminators
+ *
+ * Determines that the statistic provides the minimum, average and maximum
+ * of the numbers reported by the exploiter. Besides the number of updates
+ * is counted. Statistic events with increments larger than 1 are counted
+ * as multiple occurences of a particular discrimintator with regard to
+ * the computation of the average.
+ * For example, this statistic type could be used as a fill level or
+ * utilisation indicator for queues.
+ *
+ * The output format of a range statistic found in the "data" file is:
+ * <statistic name> <total of increments> <minimum> <average> <maximum>
+ *
+ * This (re)definition function is available both to exploiting device drivers
+ * and to the user through the "definition" file. Device driver programmers
+ * might find it user-friendly to provide a default definition for a
+ * particular statistic by calling this or a related function. A previous
+ * definition is replaced by the new one. In addition, the statistic must be
+ * started in order to make it gather data. A line in the interface's "definition"
+ * file holds specifics about the named statistic.
+ *
+ * This routine always succeeds and returns 0.
+ */
+int statistic_define_range(struct statistic *stat, s64 range_min, s64 range_max)
+{
+	unsigned long flags;
+
+	statistic_lock(stat->interface, flags);
+
+	if (stat->release)
+		stat->release(stat);
+
+	stat->type = STATISTIC_DEF_TYPE_RANGE;
+	stat->range_min = range_min;
+	stat->range_max = range_max;
+
+	stat->release = NULL;
+	stat->reset = statistic_reset_range;
+	stat->format_data = statistic_format_data_range;
+	stat->format_def = NULL;
+	stat->add = statistic_add_range;
+
+	statistic_reset_nolock(stat);
+
+	statistic_unlock(stat->interface, flags);
+
+	return 0;
+}
+
+/* code concerned with fixed array statistics */
+
+static inline s64 statistic_array_calc_value_lin(struct statistic *stat,
+						 int index)
+{
+	return stat->range_min + (stat->data.array.base_interval * index);
+}
+
+static inline s64 statistic_array_calc_value_log2(struct statistic *stat,
+						  int index)
+{
+	return stat->range_min +
+		(index ? (stat->data.array.base_interval << (index - 1)) : 0);
+}
+
+static inline s64 statistic_array_calc_value(struct statistic *stat, int index)
+{
+	if (stat->data.array.scale == STATISTIC_DEF_SCALE_LIN)
+		return statistic_array_calc_value_lin(stat, index);
+	else
+		return statistic_array_calc_value_log2(stat, index);
+}
+
+static inline int statistic_array_calc_index_lin(struct statistic *stat,
+						 s64 value)
+{
+	unsigned long long index = value - stat->range_min;
+	do_div(index, stat->data.array.base_interval);
+	return index;
+}
+
+static inline int statistic_array_calc_index_log2(struct statistic *stat,
+						  s64 value)
+{
+	unsigned long long index;
+
+	for (index = 0;
+	     index < (stat->data.array.entries - 1) &&
+	     value > statistic_array_calc_value_log2(stat, index);
+	     index++);
+	return index;
+}
+
+static inline int statistic_array_calc_index(struct statistic *stat, s64 value)
+{
+	if (stat->data.array.scale == STATISTIC_DEF_SCALE_LIN)
+		return statistic_array_calc_index_lin(stat, value);
+	else
+		return statistic_array_calc_index_log2(stat, value);
+}
+
+static inline int statistic_alloc_array(struct statistic *stat)
+{
+	int i, size;
+
+	for (i = 0;
+	     statistic_array_calc_value(stat, i) <= stat->range_max;
+	     i++);
+	i++;
+	if (i < 2) {
+		printk("statistic: definition of ""%s"" as type=array failed "
+		       "because it would comprise less than 2 intervals\n",
+		       stat->name);
+		return -EINVAL;
+	}
+	stat->data.array.entries = i;
+
+	size = stat->data.array.entries * sizeof(u64);
+	stat->data.array.hits = kmalloc(size, GFP_KERNEL);
+	if (!stat->data.array.hits) {
+		printk("statistic: definition of ""%s"" as type=array failed "
+		       "due to memory constraints\n", stat->name);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static void statistic_release_array(struct statistic *stat)
+{
+	kfree(stat->data.array.hits);
+	stat->data.array.hits = NULL;
+}
+
+static void statistic_reset_array(struct statistic *stat)
+{
+	int size = stat->data.array.entries * sizeof(u64);
+	memset(stat->data.array.hits, 0, size);
+}
+
+static inline int statistic_format_data_array_line(struct statistic *stat,
+					struct statistic_file_private *private,
+					int i, const char *prefix,u64 value)
+{
+	struct sgrb_seg *seg;
+
+	seg = sgrb_seg_find(&private->read_seg_lh, 256, GFP_ATOMIC);
+	if (!seg)
+		return -ENOMEM;
+
+	seg->offset += sprintf(seg->address + seg->offset,
+				"%s %s%lld %llu\n", stat->name,
+				prefix, (long long signed)value,
+				(long long unsigned)stat->data.array.hits[i]);
+	return 0;
+}
+
+static int statistic_format_data_array(struct statistic *stat,
+				       struct statistic_file_private *private)
+{
+	int i;
+	int retval;
+
+	for (i = 0; i < (stat->data.array.entries - 1); i++) {
+		retval = statistic_format_data_array_line(
+				stat, private, i, "<=",
+				statistic_array_calc_value(stat, i));
+		if (retval)
+			return retval;
+	}
+	retval = statistic_format_data_array_line(
+			stat, private, i, ">",
+			statistic_array_calc_value(stat, i - 1));
+	return retval;
+}
+
+static int statistic_format_def_array(struct statistic *stat, char *line)
+{
+	return  sprintf(line,
+			" %s%llu %s",
+			statistic_strings[STATISTIC_DEF_BASEINT],
+			(long long unsigned)stat->data.array.base_interval,
+			statistic_strings[stat->data.array.scale]);
+}
+
+static u64 statistic_add_array_lin(struct statistic *stat, s64 value, u64 incr)
+{
+	int index = statistic_array_calc_index_lin(stat, value);
+	return (stat->data.array.hits[index] += incr);
+}
+
+static u64 statistic_add_array_log2(struct statistic *stat, s64 value, u64 incr)
+{
+	int index = statistic_array_calc_index_log2(stat, value);
+	return (stat->data.array.hits[index] += incr);
+}
+
+/**
+ * statistic_define_array - instantiate statistic as fixed size array of
+ *    interval/counter pairs (histogram for intervals)
+ * @stat: statistic to be defined
+ * @range_min: lower bound of discriminators
+ * @range_max: upper bound of discriminators
+ * @base_interval: width of intervals between two discriminators (linear scale);
+ *         	   starting width of intervals (logarithmic scale, base 2)
+ * @scale: scale applied to discriminators (linear/logarithmic)
+ *
+ * Determines that the statistic maintains a counter for each interval
+ * as determined by the above parameters. These counters hold the total
+ * of the increments applicable to particular intervals. The first interval
+ * is determined by (<the smallest s64 value>, range_min). The last interval
+ * is (range_max, <the largest s64 value>). That means, this statistic
+ * discpline is capable of giving account of hits out of the specified range.
+ * Basically, the function implemented by this statistic discipline is a
+ * histogram for intervals.
+ *
+ * The output format of a fixed-size array statistic found in the "data" file
+ * is:
+ *
+ * <statistic name> "<="<discriminator 0> <total of increments for interval
+ *                                          (smallest s64, discriminator 0)>
+ * <statistic name> "<="<discriminator 1> <total of increments for interval
+ *                                          (discriminator 0, discriminator 1)>
+ * ...
+ * <statistic name> "<="<discriminator N> <total of increments for interval
+ *                                         (discriminator N-1, discriminator N)>
+ * <statistic name> ">"<discriminator N> <total of increments for interval
+ *                                         (discriminator N, largest s64)>
+ *
+ * This (re)definition function is available both to exploiting device drivers
+ * and to the user through the "definition" file. Device driver programmers
+ * might find it user-friendly to provide a default definition for a
+ * particular statistic by calling this or a related function. A previous
+ * definition is replaced by the new one. In addition, the statistic must be
+ * started in order to make it gather data. A line in the interface's "definition"
+ * file holds specifics about the named statistic.
+ *
+ * On success, 0 is returned.
+ *
+ * If some required memory could not be allocated this routine fails,
+ * the previous definition is preserved, and -ENOMEM is returned.
+ *
+ * If an invalid definition has been specified, the definition is not altered,
+ * and -EINVAL is returned.
+ */
+int statistic_define_array(struct statistic *stat, s64 range_min, s64 range_max,
+			   u32 base_interval, u8 scale)
+{
+	unsigned long flags;
+	int retval;
+	struct statistic *tmp;
+
+	if (range_min > range_max)
+		return -EINVAL;
+
+	if (scale != STATISTIC_DEF_SCALE_LIN &&
+	    scale != STATISTIC_DEF_SCALE_LOG2)
+		return -EINVAL;
+
+	tmp = kmalloc(sizeof(struct statistic), GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	memcpy(tmp, stat, sizeof(struct statistic));
+
+	tmp->type = STATISTIC_DEF_TYPE_ARRAY;
+	tmp->range_min = range_min;
+	tmp->range_max = range_max;
+	tmp->data.array.base_interval = base_interval;
+	tmp->data.array.scale = scale;
+
+	tmp->release = statistic_release_array;
+	tmp->reset = statistic_reset_array;
+	tmp->format_data = statistic_format_data_array;
+	tmp->format_def = statistic_format_def_array;
+ 	if (scale == STATISTIC_DEF_SCALE_LIN)
+		tmp->add = statistic_add_array_lin;
+ 	else
+		tmp->add = statistic_add_array_log2;
+
+	retval = statistic_alloc_array(tmp);
+	if (retval) {
+		kfree(tmp);
+		return retval;
+	}
+
+	statistic_lock(stat->interface, flags);
+	if (stat->release)
+		stat->release(stat);
+	memcpy(stat, tmp, sizeof(struct statistic));
+	statistic_reset_nolock(stat);
+ 	statistic_unlock(stat->interface, flags);
+
+	kfree(tmp);
+	return 0;
+}
+
+/* code concerned with adaptable list statistics */
+
+static void statistic_release_list(struct statistic *stat)
+{
+	struct statistic_entry_list *entry, *tmp;
+
+	list_for_each_entry_safe(entry, tmp, &stat->data.list.entry_lh, list) {
+		list_del(&entry->list);
+		kfree(entry);
+	}
+}
+
+static void statistic_reset_list(struct statistic *stat)
+{
+	statistic_release_list(stat);
+	stat->data.list.hits_missed = 0;
+	stat->data.list.entries = 0;
+}
+
+static int statistic_format_data_list(struct statistic *stat,
+				      struct statistic_file_private *private)
+{
+	struct sgrb_seg *seg;
+	struct statistic_entry_list *entry;
+
+	list_for_each_entry(entry, &stat->data.list.entry_lh, list) {
+		seg = sgrb_seg_find(&private->read_seg_lh, 256, GFP_ATOMIC);
+		if (!seg)
+			return -ENOMEM;
+		seg->offset += sprintf(seg->address + seg->offset,
+					"%s 0x%llx %llu\n",
+					stat->name,
+					(long long signed)entry->value,
+					(long long unsigned)entry->hits);
+	}
+	return 0;
+}
+
+static int statistic_format_def_list(struct statistic *stat, char *line)
+{
+	return sprintf(line,
+			" %s%u %s%llu",
+			statistic_strings[STATISTIC_DEF_ENTRIESMAX],
+			stat->data.list.entries_max,
+			statistic_strings[STATISTIC_DEF_HITSMISSED],
+			(long long unsigned)stat->data.list.hits_missed);
+}
+
+static inline void statistic_add_list_sort(struct list_head *head,
+					   struct statistic_entry_list *entry)
+{
+	struct statistic_entry_list *sort =
+		list_prepare_entry(entry, head, list);
+
+	list_for_each_entry_continue_reverse(sort, head, list)
+		if (sort->hits >= entry->hits)
+			break;
+	if (sort->list.next != &entry->list &&
+	    (&sort->list == head || sort->hits >= entry->hits))
+		list_move(&entry->list, &sort->list);
+}
+
+static inline int statistic_add_list_new(struct statistic *stat, s64 value,
+					 u64 incr)
+{
+	struct statistic_entry_list *entry;
+
+	if (stat->data.list.entries == stat->data.list.entries_max)
+		return -ENOMEM;
+
+	entry = kmalloc(sizeof(struct statistic_entry_list), GFP_ATOMIC);
+	if (entry) {
+		entry->value = value;
+		entry->hits = incr;
+		stat->data.list.entries++;
+		list_add_tail(&entry->list, &stat->data.list.entry_lh);
+		return 0;
+	} else	return -ENOMEM;
+}
+
+static u64 statistic_add_list(struct statistic *stat, s64 value, u64 incr)
+{
+	struct statistic_entry_list *entry;
+	struct list_head *head = &stat->data.list.entry_lh;
+
+	if (value < stat->range_min || value > stat->range_max) {
+		stat->hits_out_of_range++;
+		return 0;
+	}
+
+	list_for_each_entry(entry, head, list) {
+		if (entry->value == value) {
+			entry->hits += incr;
+			statistic_add_list_sort(head, entry);
+			return entry->hits;
+		}
+	}
+	if (statistic_add_list_new(stat, value, incr)) {
+		stat->data.list.hits_missed++;
+		return 0;
+	} else
+		return incr;
+}
+
+/**
+ * statistic_define_list - instantiate statistic as adaptable-size list of
+ *    discriminator/counter pairs (histogram for discrete values)
+ * @stat: statistic to be defined
+ * @range_min: lower bound of discriminators
+ * @range_max: upper bound of discriminators
+ * @entries_max: limits the list size
+ *
+ * Determines that the statistic maintains a counter for each discrete
+ * discriminator that is reported along with increments by the exploiter.
+ * These counters hold the total of the increments applicable to particular
+ * discriminators. Hits that were out of the specified range, or that would have
+ * required list entries beyond the specified maximum, are discarded and their
+ * numbers are visible through the "definition" file.
+ * Basically, the function implemented by this statistic discipline is a
+ * histogram for discrete values. Which values make it into the histogram is
+ * determined by their order of appearance (first come, first served).
+ *
+ * The output format of an adaptable-size list statistic found in the "data"
+ * file is:
+ *
+ * <statistic name> <discriminator 0> <total of increments for discriminator 0>
+ * <statistic name> <discriminator 1> <total of increments for discriminator 1>
+ * ...
+ * <statistic name> <discriminator N> <total of increments for discriminator N>
+ *
+ * This (re)definition function is available both to exploiting device drivers
+ * and to the user through the "definition" file. Device driver programmers
+ * might find it user-friendly to provide a default definition for a
+ * particular statistic by calling this or a related function. A previous
+ * definition is replaced by the new one. In addition, the statistic must be
+ * started in order to make it gather data. A line in the interface's "definition"
+ * file holds specifics about the named statistic.
+ *
+ * This routine always succeeds and returns 0.
+ */
+int statistic_define_list(struct statistic *stat, s64 range_min, s64 range_max,
+			  u32 entries_max)
+{
+	unsigned long flags;
+
+	statistic_lock(stat->interface, flags);
+
+	if (stat->release)
+		stat->release(stat);
+
+	stat->type = STATISTIC_DEF_TYPE_LIST;
+	stat->range_min = range_min;
+	stat->range_max = range_max;
+	stat->data.list.entries_max = entries_max;
+	INIT_LIST_HEAD(&stat->data.list.entry_lh);
+
+	stat->release = statistic_release_list;
+	stat->reset = statistic_reset_list;
+	stat->format_data = statistic_format_data_list;
+	stat->format_def = statistic_format_def_list;
+	stat->add = statistic_add_list;
+
+	statistic_reset_nolock(stat);
+
+	statistic_unlock(stat->interface, flags);
+
+	return 0;
+}
+
+/* code concerned with raw, timestamped statistic events */
+
+static void statistic_release_raw(struct statistic *stat)
+{
+	sgrb_release(&stat->data.raw.rb);
+}
+
+static void statistic_reset_raw(struct statistic *stat)
+{
+	sgrb_reset(&stat->data.raw.rb);
+	stat->data.raw.next_serial = 0;
+}
+
+static int statistic_format_data_raw(struct statistic *stat,
+				     struct statistic_file_private *private)
+{
+	struct sgrb_seg *seg;
+	struct sgrb_ptr ptr;
+	struct statistic_entry_raw *entry;
+	char t[TIMESTAMP_SIZE];
+
+	sgrb_ptr_copy(&ptr, &stat->data.raw.rb.first);
+	while ((entry = sgrb_consume_nodelete(&stat->data.raw.rb, &ptr))) {
+		seg = sgrb_seg_find(&private->read_seg_lh, 256, GFP_ATOMIC);
+		if (!seg)
+			return -ENOMEM;
+		nsec_to_timestamp(t, entry->clock);
+		seg->offset += sprintf(seg->address + seg->offset,
+					"%s %s %llu %lld %llu\n",
+					stat->name, t,
+					(long long unsigned)entry->serial,
+					(long long signed)entry->value,
+					(long long unsigned)entry->incr);
+	}
+	return 0;
+}
+
+static int statistic_format_def_raw(struct statistic *stat, char *line)
+{
+	return sprintf(line,
+			" %s%u",
+			statistic_strings[STATISTIC_DEF_ENTRIESMAX],
+			stat->data.raw.entries_max);
+}
+
+static u64 statistic_add_raw(struct statistic *stat, s64 value, u64 incr)
+{
+	struct statistic_entry_raw *entry;
+
+	if (value < stat->range_min || value > stat->range_max) {
+		stat->hits_out_of_range++;
+		return 0;
+	}
+
+	entry = sgrb_produce_overwrite(&stat->data.raw.rb);
+
+	entry->clock = sched_clock();
+	entry->serial = stat->data.raw.next_serial++;
+	entry->value = value;
+	entry->incr = incr;
+
+	return incr;
+}
+
+/**
+ * statistic_define_raw - instantiate statistic as a record of incremental
+ *    updates as they have happened (history of statistic events)
+ * @stat: statistic to be defined
+ * @range_min: lower bound of discriminators
+ * @range_max: upper bound of discriminators
+ * @entries_max: maximum number of entries in ringbuffer
+ *
+ * Determines that the statistic does not maintain counters for any increments,
+ * but that it accumulates the reported updates in the form of a history of
+ * these updates. Updates out of the specified range are dropped, though their
+ * total number is readable through the "definition" file. Besides, once the
+ * allocated pages are completely occupied, new entries are written over the
+ * oldest ones (ringbuffer). Each entry is tagged with a unique serial number
+ * and a timestamp. A single entry consumes 32 bytes.
+ * This discipline might be used to relate (seldom) statistic events to other
+ * (debugging?) events, or to do calculations on raw data in user space.
+ *
+ * The output format of a "raw" statistic found in the "data" file is:
+ *
+ * <statistic name> <discriminator> <increment> <serial> <timestamp>
+ *
+ * This (re)definition function is available both to exploiting device drivers
+ * and to the user through the "definition" file. Device driver programmers
+ * might find it user-friendly to provide a default definition for a
+ * particular statistic by calling this or a related function. A previous
+ * definition is replaced by the new one. In addition, the statistic must be
+ * started in order to make it gather data. A line in the interface's "definition"
+ * file holds specifics about the named statistic.
+ *
+ * On success, 0 is returned.
+ *
+ * If some required memory could not be allocated this routine fails,
+ * the previous definition is preserved, and -ENOMEM is returned.
+ */
+int statistic_define_raw(struct statistic *stat, s64 range_min, s64 range_max,
+			 u32 entries_max)
+{
+	unsigned long flags;
+	int retval;
+	struct statistic *tmp;
+
+	tmp = kmalloc(sizeof(struct statistic), GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	memcpy(tmp, stat, sizeof(struct statistic));
+
+	tmp->type = STATISTIC_DEF_TYPE_RAW;
+	tmp->range_min = range_min;
+	tmp->range_max = range_max;
+	tmp->data.raw.entries_max = entries_max;
+
+	tmp->release = statistic_release_raw;
+	tmp->reset = statistic_reset_raw;
+	tmp->format_data = statistic_format_data_raw;
+	tmp->format_def = statistic_format_def_raw;
+	tmp->add = statistic_add_raw;
+
+	tmp->data.raw.next_serial = 0;
+	/*
+	 * sgrb_alloc initialises list head for us. We must not use pointers
+	 * to the stat's list through tmp in order to avoid list corruption.
+	 */
+	retval = sgrb_alloc(&tmp->data.raw.rb,
+			    sizeof(struct statistic_entry_raw),
+			    tmp->data.raw.entries_max, PAGE_SIZE, GFP_KERNEL);
+	if (retval) {
+		printk("statistic: definition of ""%s"" failed due to memory "
+		       "constraints\n", stat->name);
+		kfree(tmp);
+		return retval;
+	}
+
+	statistic_lock(stat->interface, flags);
+	if (stat->release)
+		stat->release(stat);
+	memcpy(stat, tmp, sizeof(struct statistic));
+	/*
+	 * The new ringbuffer's list is attached to tmp. memcpy() has left
+	 * some loose ends pointing to the soon to be kfree()-ed tmp.
+	 * So we need to migrate the list from tmp to stat here,
+	 * even if this looks like nasty poking inside ringbuffers.
+	 */
+	INIT_LIST_HEAD(&stat->data.raw.rb.seg_lh);
+	list_splice(&tmp->data.raw.rb.seg_lh, &stat->data.raw.rb.seg_lh);
+	statistic_reset_nolock(stat);
+ 	statistic_unlock(stat->interface, flags);
+
+	kfree(tmp);
+	return 0;
+}
+
+/* code concerned with history statistics */
+
+static void statistic_release_history(struct statistic *stat)
+{
+	sgrb_release(&stat->data.history.rb);
+}
+
+static void statistic_reset_history(struct statistic *stat)
+{
+	sgrb_reset(&stat->data.history.rb);
+	stat->data.history.checkpoint = sched_clock();
+}
+
+static inline void * statistic_add_history_entry(struct statistic *stat)
+{
+	u64 now, then, window, period, checkp, elapsed;
+	void *entry = NULL;
+
+	window = stat->data.history.window;
+	period = stat->data.history.period;
+	checkp = stat->data.history.checkpoint;
+
+	now = sched_clock();
+	if (now <= checkp)
+		entry = sgrb_entry(&stat->data.history.rb.last);
+	else	{
+		then = checkp;
+		elapsed = now - then;
+		/*
+		 * FIXME: replace loops by formula for supposedly
+		 * improved performance
+		 *  - would require something like do_div64_64()
+		 */
+#if 0
+		if (elapsed > window)
+			then = (now - window) + (period - elapsed % period);
+#endif
+
+		if (elapsed > window) {
+			for (; then < now - 2 * window; then += window);
+			for (; then < now - window; then += period);
+		}
+		for (; then < now; then += period) {
+			entry = sgrb_produce_overwrite(&stat->data.history.rb);
+			memset(entry, 0, stat->data.history.rb.entry_size);
+		}
+		if (stat->data.history.mode == STATISTIC_DEF_MODE_RANGE)
+			statistic_init_range(
+				(struct statistic_entry_range *)entry,
+				stat->range_min,
+				stat->range_max);
+		stat->data.history.checkpoint = then;
+	}
+	return entry;
+}
+
+static inline int statistic_format_data_history(struct statistic *stat,
+					struct statistic_file_private *private)
+{
+	struct sgrb_seg *seg;
+	struct sgrb_ptr ptr;
+	void *entry;
+	u64 time;
+	char t[TIMESTAMP_SIZE + 1];
+
+	/* enforce update for time of inactivity */
+	statistic_add_history_entry(stat);
+	time = stat->data.history.checkpoint -
+	       stat->data.history.period *
+			(stat->data.history.rb.entries - 1);
+	sgrb_ptr_copy(&ptr, &stat->data.history.rb.first);
+	while ((entry = sgrb_consume_nodelete(&stat->data.history.rb, &ptr))) {
+		seg = sgrb_seg_find(&private->read_seg_lh, 256, GFP_ATOMIC);
+		if (!seg)
+			return -ENOMEM;
+		t[0] = ' ';
+		nsec_to_timestamp(&t[1], time);
+		switch (stat->data.history.mode) {
+		case STATISTIC_DEF_MODE_INC :
+		case STATISTIC_DEF_MODE_PROD :
+			_statistic_format_data_value(
+				stat, seg, t, *(u64*)entry);
+			break;
+		case STATISTIC_DEF_MODE_RANGE :
+			_statistic_format_data_range(
+				stat, seg, t,
+				(struct statistic_entry_range *)entry);
+			break;
+		default :
+			break;
+		}
+		time += stat->data.history.period;
+	}
+	return 0;
+}
+
+static inline int statistic_format_def_history(struct statistic *stat,
+					       char *line)
+{
+	unsigned long long period = stat->data.history.period;
+
+	do_div(period, 1000);
+	return sprintf(line,
+			" %s%u %s %s%llu",
+			statistic_strings[STATISTIC_DEF_ENTRIESMAX],
+			stat->data.history.entries_max,
+	    		statistic_strings[stat->data.history.mode],
+			statistic_strings[STATISTIC_DEF_PERIOD],
+			period);
+}
+
+static u64 statistic_add_history_increments(struct statistic *stat, s64 value,
+					    u64 incr)
+{
+	if (value < stat->range_min || value > stat->range_max) {
+		stat->hits_out_of_range++;
+		return 0;
+	}
+	return _statistic_add_value_increments(
+			(s64*) statistic_add_history_entry(stat), value, incr);
+}
+
+static u64 statistic_add_history_products(struct statistic *stat, s64 value,
+					  u64 incr)
+{
+	if (value < stat->range_min || value > stat->range_max) {
+		stat->hits_out_of_range++;
+		return 0;
+	}
+	return _statistic_add_value_products(
+			(s64*) statistic_add_history_entry(stat), value, incr);
+}
+
+static u64 statistic_add_history_range(struct statistic *stat, s64 value,
+				       u64 incr)
+{
+	if (value < stat->range_min || value > stat->range_max) {
+		stat->hits_out_of_range++;
+		return 0;
+	}
+	return _statistic_add_range(
+			(struct statistic_entry_range *)
+				statistic_add_history_entry(stat),
+			value, incr);
+}
+
+/**
+ * statistic_define_history - instantiate statistic as a history
+ *    that accumulates all updates per defined period of time
+ * @stat: statistic to be defined
+ * @range_min: lower bound of discriminators
+ * @range_max: upper bound of discriminators
+ * @entries_max: number of entries in the history buffer
+ * @period: time to elapse for each entry in history
+ * @mode: accumulate increments only, or products of discriminator and increment
+ *
+ * Determines that the statistic does maintain data per fixed period
+ * of time. All updates within a particular period of time are added up. When
+ * that period has passed, the next entry in the history buffer is used to start
+ * over with accumulation. The history buffer is a ringbuffer. That is, the
+ * oldest entry is replaced by the newest, if the history buffer has been filled
+ * up. Updates out of the specified range are dropped, though their total number
+ * is readable through the "definition" file. Each entry is tagged with a
+ * timestamp. Each entry consumes 8 bytes (mode=increments, mode=products)
+ * or 32 bytes (mode=range).
+ * This statistic discipline basically is other basic discplines enhanced by
+ * another dimension, time.
+ *
+ * Depending on the definition, accumulation is done as
+ *
+ * a) mode=increments	: see statistic_define_value()
+ * b) mode=products	: see statistic_define_value()
+ * c) mode=range	: see statistic_define_range()
+ *
+ * The output format of a "history" statistic found in the "data" file is
+ * similar to those documented for the underlying basic types (see mode
+ * parameter), with the exception of a timestamp inserted after the
+ * <statistic name> field that allows to identify an entries of particular
+ * age (timestamp marks the end of periods).
+ *
+ * This (re)definition function is available both to exploiting device drivers
+ * and to the user through the "definition" file. Device driver programmers
+ * might find it user-friendly to provide a default definition for a
+ * particular statistic by calling this or a related function. A previous
+ * definition is replaced by the new one. In addition, the statistic must be
+ * started in order to make it gather data. A line in the interface's "definition"
+ * file holds specifics about the named statistic.
+ *
+ * On success, 0 is returned.
+ *
+ * If some required memory could not be allocated this routine fails,
+ * the previous definition is preserved, and -ENOMEM is returned.
+ *
+ * If an invalid definition has been specified, the definition is not altered,
+ * and -EINVAL is returned.
+ */
+int statistic_define_history(struct statistic *stat, s64 range_min,
+		     s64 range_max, u32 entries_max, u64 period, int mode)
+{
+	unsigned long flags;
+	int retval;
+	struct statistic *tmp;
+	int entry_size;
+
+ 	if (mode != STATISTIC_DEF_MODE_INC &&
+ 	    mode != STATISTIC_DEF_MODE_PROD &&
+ 	    mode != STATISTIC_DEF_MODE_RANGE)
+ 		return -EINVAL;
+
+	tmp = kmalloc(sizeof(struct statistic), GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	memcpy(tmp, stat, sizeof(struct statistic));
+
+ 	period *= 1000;	/* microseconds to nanoseconds */
+
+	tmp->type = STATISTIC_DEF_TYPE_HISTORY;
+	tmp->range_min = range_min;
+	tmp->range_max = range_max;
+	tmp->data.history.entries_max = entries_max;
+	tmp->data.history.mode = mode;
+	tmp->data.history.period = period;
+	tmp->data.history.window = entries_max * period;
+
+	tmp->release = statistic_release_history;
+	tmp->reset = statistic_reset_history;
+	tmp->format_data = statistic_format_data_history;
+	tmp->format_def = statistic_format_def_history;
+ 	if (mode == STATISTIC_DEF_MODE_INC)
+		tmp->add = statistic_add_history_increments;
+ 	else if (mode == STATISTIC_DEF_MODE_PROD)
+		tmp->add = statistic_add_history_products;
+ 	else
+		tmp->add = statistic_add_history_range;
+
+	entry_size = (STATISTIC_DEF_MODE_RANGE ?
+		      sizeof(struct statistic_entry_range) :
+		      sizeof(s64));
+	/*
+	 * sgrb_alloc initialises list head for us. We must not use pointers
+	 * to the stat's list through tmp in order to avoid list corruption.
+	 */
+	retval = sgrb_alloc(&tmp->data.history.rb, entry_size,
+			    tmp->data.history.entries_max,
+			    PAGE_SIZE, GFP_KERNEL);
+	if (retval) {
+		printk("statistic: definition of ""%s"" failed due to memory "
+		       "constraints\n", stat->name);
+		kfree(tmp);
+		return retval;
+	}
+
+	statistic_lock(stat->interface, flags);
+	if (stat->release)
+		stat->release(stat);
+	memcpy(stat, tmp, sizeof(struct statistic));
+	/*
+	 * The new ringbuffer's list is attached to tmp. memcpy() has left
+	 * some loose ends pointing to the soon to be kfree()-ed tmp.
+	 * So we need to migrate the list from tmp to stat here,
+	 * even if this looks like nasty poking inside ringbuffers.
+	 */
+	INIT_LIST_HEAD(&stat->data.history.rb.seg_lh);
+	list_splice(&tmp->data.history.rb.seg_lh,
+		    &stat->data.history.rb.seg_lh);
+	statistic_reset_nolock(stat);
+ 	statistic_unlock(stat->interface, flags);
+
+	kfree(tmp);
+	return 0;
+}
+
+/* code concerned with user interface */
+
+/**
+ * statistic_interface_create - create debugfs files for a collection of
+ *    related statistics
+ * @interface_ptr: reference to struct statistic_interface pointer
+ * @name: name of debugfs directory to be created
+ *
+ * Create a debugfs directory in "statistics" as well as the "data" and
+ * "definition" files. Creating this user interface is prequisite for
+ * attaching statistics to an interface.
+ *
+ * On success, 0 is returned and the struct statistic_interface pointer
+ * provided by the caller points to a newly allocated struct.
+ *
+ * If the struct statistic_interface pointer provided by the caller
+ * is not NULL (used), this routine fails, the struct statistic_interface
+ * pointer is not changed, and -EINVAL is returned.
+ *
+ * If some required memory could not be allocated, or the creation
+ * of debugfs entries failed, this routine fails, the struct
+ * statistic_interface pointer is not changed, and -ENOMEM is returned.
+ */
+int statistic_interface_create(struct statistic_interface **interface_ptr,
+			       const char *name)
+{
+	struct statistic_interface *interface;
+	int retval;
+
+	if (*interface_ptr)
+		return -EINVAL;
+
+	interface = kmalloc(sizeof(struct statistic_interface), GFP_KERNEL);
+	if (!interface)
+		return -ENOMEM;
+	memset(interface, 0, sizeof(struct statistic_interface));
+	INIT_LIST_HEAD(&interface->statistic_lh);
+	spin_lock_init(&interface->lock);
+
+	down(&statistic_globals.sem);
+
+	interface->debugfs_dir = debugfs_create_dir(
+					name, statistic_globals.root_dir);
+	if (!interface->debugfs_dir) {
+		retval = -ENOMEM;
+		goto failed_dir;
+	}
+
+	interface->data_file = debugfs_create_file(
+					STATISTIC_FILENAME_DATA,
+					S_IFREG | S_IRUSR,
+					interface->debugfs_dir,
+					(void*) interface,
+					&statistic_data_file_ops);
+	if (!interface->data_file) {
+		retval = -ENOMEM;
+		goto failed_data;
+	}
+
+	interface->def_file = debugfs_create_file(
+					STATISTIC_FILENAME_DEF,
+					S_IFREG | S_IRUSR | S_IWUSR,
+					interface->debugfs_dir,
+					(void*) interface,
+					&statistic_def_file_ops);
+	if (!interface->def_file) {
+		retval = -ENOMEM;
+		goto failed_def;
+	}
+
+	list_add_tail(&interface->list, &statistic_globals.interface_lh);
+	*interface_ptr = interface;
+	retval = 0;
+	goto out;
+
+failed_def:
+	debugfs_remove(interface->data_file);
+
+failed_data:
+failed_dir:
+	kfree(interface);
+	interface = NULL;
+
+out:
+	up(&statistic_globals.sem);
+
+	return retval;
+}
+
+/**
+ * statistic_interface_remove - remove debugfs files for statistics
+ * @interface_ptr: reference to struct statistic_interface pointer
+ *
+ * Remove a debugfs directory in "statistics" along with its "data" and
+ * "definition" files. Removing this user interface also causes the removal
+ * of all statistics attached to the interface.
+ *
+ * On success, 0 is returned and the struct statistic_interface pointer
+ * provided by the caller is set to NULL.
+ *
+ * If the struct statistic_interface pointer provided by the caller
+ * is NULL (unused), this routine fails, the struct statistic_interface
+ * pointer is not changed, and -EINVAL is returned.
+ */
+int statistic_interface_remove(struct statistic_interface **interface_ptr)
+{
+	struct statistic_interface *interface = *interface_ptr;
+	struct statistic *stat, *tmp;
+
+	if (!interface)
+		return -EINVAL;
+
+	down(&statistic_globals.sem);
+
+	list_for_each_entry_safe(stat, tmp, &interface->statistic_lh, list)
+		statistic_remove(stat->stat_ptr);
+
+	debugfs_remove(interface->data_file);
+	debugfs_remove(interface->def_file);
+	debugfs_remove(interface->debugfs_dir);
+
+	list_del(&interface->list);
+	kfree(interface);
+	*interface_ptr = NULL;
+
+	up(&statistic_globals.sem);
+
+	return 0;
+}
+
+static int statistic_interface_generic_open(struct inode *inode,
+		struct file *file, struct statistic_interface **interface,
+		struct statistic_file_private **private)
+{
+	*interface = (struct statistic_interface *) inode->u.generic_ip;
+	BUG_ON(!interface);
+
+	*private = kmalloc(sizeof(struct statistic_file_private), GFP_KERNEL);
+	if (!(*private))
+		return -ENOMEM;
+
+	memset(*private, 0, sizeof(struct statistic_file_private));
+	INIT_LIST_HEAD(&(*private)->read_seg_lh);
+	INIT_LIST_HEAD(&(*private)->write_seg_lh);
+	file->private_data = *private;
+	return 0;
+}
+
+static int statistic_interface_generic_close(struct inode *inode,
+					     struct file *file)
+{
+	struct statistic_file_private *private;
+
+	private = (struct statistic_file_private *) file->private_data;
+	BUG_ON(!private);
+
+	sgrb_seg_release_all(&private->read_seg_lh);
+	sgrb_seg_release_all(&private->write_seg_lh);
+
+	kfree(private);
+	return 0;
+}
+
+static ssize_t statistic_interface_generic_read(struct file *file,
+				char __user *buf, size_t len, loff_t *offset)
+{
+	struct statistic_file_private *private;
+	struct sgrb_seg *seg;
+	size_t seg_offset, seg_residual, seg_transfer;
+	size_t transfered = 0;
+	loff_t pos = 0;
+
+	private = (struct statistic_file_private *) file->private_data;
+	BUG_ON(!private);
+
+	list_for_each_entry(seg, &private->read_seg_lh, list) {
+		if (!len)
+			break;
+		if (*offset >= pos  &&
+		    *offset <= (pos + seg->offset)) {
+			seg_offset = *offset - pos;
+			seg_residual = seg->offset - seg_offset;
+			seg_transfer = min(len, seg_residual);
+			if (copy_to_user(buf + transfered,
+					 seg->address + seg_offset,
+					 seg_transfer))
+				return -EFAULT;
+			transfered += seg_transfer;
+			*offset += seg_transfer;
+			pos += seg_transfer + seg_offset;
+			len -= seg_transfer;
+		} else
+			pos += seg->offset;
+	}
+	return transfered;
+}
+
+static ssize_t statistic_interface_generic_write(struct file *file,
+			const char __user *buf, size_t len, loff_t *offset)
+{
+	struct statistic_file_private *private;
+	struct sgrb_seg *seg;
+	size_t seg_residual, seg_transfer;
+	size_t transfered = 0;
+
+	private = (struct statistic_file_private *) file->private_data;
+	BUG_ON(!private);
+
+	if (*offset != private->write_seg_total_size)
+		return -EPIPE;
+
+	while (len) {
+		seg = sgrb_seg_find(&private->write_seg_lh, 1, GFP_KERNEL);
+		if (!seg)
+			return -ENOMEM;
+		seg_residual = seg->size - seg->offset;
+		seg_transfer = min(len, seg_residual);
+		if (copy_from_user(seg->address + seg->offset,
+				   buf + transfered,
+				   seg_transfer))
+			return -EFAULT;
+		private->write_seg_total_size += seg_transfer;
+		seg->offset += seg_transfer;
+		transfered += seg_transfer;
+		*offset += seg_transfer;
+		len -= seg_transfer;
+	}
+	return transfered;
+}
+
+static int statistic_interface_def_open(struct inode *inode, struct file *file)
+{
+	struct statistic_interface *interface;
+	struct statistic_file_private *private;
+	struct statistic *stat;
+	unsigned long flags;
+	int retval = 0;
+
+	retval = statistic_interface_generic_open(
+			inode, file, &interface, &private);
+	if (retval)
+		return retval;
+
+	statistic_lock(interface, flags);
+	list_for_each_entry(stat, &interface->statistic_lh, list) {
+		retval = statistic_format_def(stat, private);
+		if (retval) {
+			statistic_interface_def_close(inode, file);
+			break;
+		}
+	}
+	statistic_unlock(interface, flags);
+	return retval;
+}
+
+static int statistic_parse_definitions_line(
+			struct statistic_interface *interface, char *def)
+{
+	struct statistic *stat;
+	char * p;
+	substring_t args[MAX_OPT_ARGS];
+	int token, type = 0, scale = 0;
+	u32 entries_max, base_interval;
+	s64 range_min, range_max;
+	u64 period = 0;
+	int mode = 0;
+	char *name = NULL;
+	int retval = 0;
+	unsigned long flags;
+	int got_type = 0, got_scale = 0, got_entries_max = 0,
+	    got_range_min = 0, got_range_max = 0,
+	    got_base_interval = 0, got_period = 0, got_mode = 0, got_reset = 0,
+	    got_on = 0, got_off = 0, redefinition = 0, new_type = 0,
+	    was_on = 0;
+
+	if (!def)
+		return 1;
+
+	while ((p = strsep (&def, " ")) != NULL) {
+		token = match_token(p, statistic_def, args);
+		switch (token) {
+		case STATISTIC_DEF_NAME :
+			if (!name)
+				name = match_strdup(&args[0]);
+			break;
+		case STATISTIC_DEF_TYPE_VALUE :
+		case STATISTIC_DEF_TYPE_RANGE :
+		case STATISTIC_DEF_TYPE_ARRAY :
+		case STATISTIC_DEF_TYPE_LIST :
+		case STATISTIC_DEF_TYPE_RAW :
+		case STATISTIC_DEF_TYPE_HISTORY :
+			type = token;
+			got_type = 1;
+			break;
+		case STATISTIC_DEF_ON :
+			got_on = 1;
+			break;
+		case STATISTIC_DEF_OFF :
+			got_off = 1;
+			break;
+		case STATISTIC_DEF_SCALE_LIN :
+		case STATISTIC_DEF_SCALE_LOG2 :
+			scale = token;
+			got_scale = 1;
+			break;
+		case STATISTIC_DEF_ENTRIESMAX :
+			match_int(&args[0], &entries_max);
+			got_entries_max = 1;
+			break;
+		case STATISTIC_DEF_RANGEMIN :
+			match_s64(&args[0], &range_min, 0);
+			got_range_min = 1;
+			break;
+		case STATISTIC_DEF_RANGEMAX :
+			match_s64(&args[0], &range_max, 0);
+			got_range_max = 1;
+			break;
+		case STATISTIC_DEF_BASEINT :
+			match_int(&args[0], &base_interval);
+			got_base_interval = 1;
+			break;
+		case STATISTIC_DEF_PERIOD :
+			match_u64(&args[0], &period, 0);
+			got_period = 1;
+			break;
+		case STATISTIC_DEF_MODE_INC :
+		case STATISTIC_DEF_MODE_PROD :
+		case STATISTIC_DEF_MODE_RANGE :
+			mode = token;
+			got_mode = 1;
+			break;
+		case STATISTIC_DEF_RESET :
+			got_reset = 1;
+			break;
+		default :
+			break;
+		}
+	}
+
+	redefinition =  got_type | got_mode | got_scale | got_entries_max |
+			got_range_min | got_range_max |
+			got_base_interval | got_period;
+
+	if (!name) {
+		if (redefinition)
+			goto out;
+		statistic_lock(interface, flags);
+		if (got_on)
+			list_for_each_entry(stat, &interface->statistic_lh, list)
+				statistic_start_nolock(stat);
+		if (got_off)
+			list_for_each_entry(stat, &interface->statistic_lh, list)
+				statistic_stop_nolock(stat);
+		if (got_reset) {
+			list_for_each_entry(stat, &interface->statistic_lh, list)
+				statistic_reset_nolock(stat);
+		}
+		statistic_unlock(interface, flags);
+		goto out;
+	}
+
+	statistic_lock(interface, flags);
+	list_for_each_entry(stat, &interface->statistic_lh, list) {
+		if (!strcmp(stat->name, name))
+			break;
+	}
+	statistic_unlock(interface, flags);
+	if (strcmp(stat->name, name))
+		goto out;
+
+	if (!redefinition) {
+		if (got_on)
+			statistic_start(stat);
+		if (got_off)
+			statistic_stop(stat);
+		if (got_reset)
+			statistic_reset(stat);
+		goto out;
+	}
+
+	if (statistic_stop(stat) == STATISTIC_DEF_ON)
+		was_on = 1;
+
+	if (!got_type)
+		type = stat->type;
+	else if (type != stat->type)
+		new_type = 1;
+
+	if (!got_range_min)
+		range_min = stat->range_min;
+	if (!got_range_max)
+		range_max = stat->range_max;
+
+        switch (type) {
+        case STATISTIC_DEF_TYPE_VALUE :
+		if (new_type && !got_mode) {
+			retval = -EINVAL;
+			break;
+		}
+		if (!got_mode)
+			mode = stat->data.value.mode;
+		retval = statistic_define_value(
+				stat, range_min, range_max, mode);
+		break;
+        case STATISTIC_DEF_TYPE_RANGE :
+		retval = statistic_define_range(
+				stat, range_min, range_max);
+		break;
+        case STATISTIC_DEF_TYPE_ARRAY :
+		if (new_type && (!got_base_interval || !got_scale)) {
+			retval = -EINVAL;
+			break;
+		}
+		if (!got_base_interval)
+			base_interval = stat->data.array.base_interval;
+		if (!got_scale)
+			scale = stat->data.array.scale;
+		retval = statistic_define_array(
+				stat, range_min, range_max, base_interval, scale);
+		break;
+        case STATISTIC_DEF_TYPE_LIST :
+		if (new_type && !got_entries_max) {
+			retval = -EINVAL;
+			break;
+		}
+		if (!got_entries_max)
+			entries_max = stat->data.list.entries_max;
+		retval = statistic_define_list(
+				stat, range_min, range_max, entries_max);
+		break;
+        case STATISTIC_DEF_TYPE_RAW :
+		if (new_type && !got_entries_max) {
+			retval = -EINVAL;
+			break;
+		}
+		if (!got_entries_max)
+			entries_max = stat->data.raw.entries_max;
+		retval = statistic_define_raw(
+				stat, range_min, range_max, entries_max);
+		break;
+        case STATISTIC_DEF_TYPE_HISTORY :
+		if (new_type && (!got_entries_max || !got_period ||
+				 !got_mode)) {
+			retval = -EINVAL;
+			break;
+		}
+		if (!got_entries_max)
+			entries_max = stat->data.history.entries_max;
+		if (!got_period)
+			period = stat->data.history.period;
+		if (!got_mode)
+			mode = stat->data.history.mode;
+		retval = statistic_define_history(
+				stat, range_min, range_max, entries_max,
+				period, mode);
+		break;
+        default :
+                retval = -EINVAL;
+        }
+
+	if (got_on || was_on)
+		statistic_start(stat);
+
+out:
+	kfree(name);
+	return retval;
+}
+
+static void statistic_interface_def_close_parse(
+				struct statistic_interface *interface,
+				struct list_head *line_lh, size_t *line_size)
+{
+	struct sgrb_seg *seg, *tmp;
+	char *buf;
+	int offset = 0;
+
+	if (!*line_size)
+		return;
+
+	buf = kmalloc(*line_size + 2, GFP_KERNEL);
+	if (!buf)
+		/*
+		 * FIXME:
+		 * Does it make sense to indicate -ENOMEM on close()?
+		 * Should we omit other new settings because we could not
+		 * process this line of definitions?
+		 */
+		return;
+	buf[*line_size] = ' ';
+	buf[*line_size + 1] = '\0';
+	*line_size = 0;
+
+	list_for_each_entry_safe(seg, tmp, line_lh, list) {
+		memcpy(buf + offset, seg->address, seg->size);
+		offset += seg->size;
+		list_del(&seg->list);
+		kfree(seg);
+	}
+
+	statistic_parse_definitions_line(interface, buf);
+
+	kfree(buf);
+}
+
+static int statistic_interface_def_close(struct inode *inode, struct file *file)
+{
+	struct statistic_interface *interface;
+	struct statistic_file_private *private;
+	struct sgrb_seg *seg, *seg_nl;
+	int offset;
+	struct list_head line_lh;
+	char *nl;
+	size_t line_size = 0;
+
+	INIT_LIST_HEAD(&line_lh);
+	interface = (struct statistic_interface *) inode->u.generic_ip;
+	private = (struct statistic_file_private *) file->private_data;
+
+	list_for_each_entry(seg, &private->write_seg_lh, list) {
+		for (offset = 0; offset < seg->offset; offset += seg_nl->size) {
+			seg_nl = kmalloc(sizeof(struct sgrb_seg), GFP_KERNEL);
+			if (!seg_nl)
+				/*
+				 * FIXME:
+				 * Should we omit other new settings because we
+				 * could not process this line of definitions?
+				 */
+				continue;
+			seg_nl->address = seg->address + offset;
+			nl = strnchr(seg_nl->address,
+				     seg->offset - offset, '\n');
+			if (nl) {
+				seg_nl->offset = nl - seg_nl->address;
+				if (seg_nl->offset)
+					seg_nl->offset--;
+			} else
+				seg_nl->offset = seg->offset - offset;
+			seg_nl->size = seg_nl->offset + 1;
+			line_size += seg_nl->size;
+			list_add_tail(&seg_nl->list, &line_lh);
+			if (nl)
+				statistic_interface_def_close_parse(
+					interface, &line_lh, &line_size);
+		}
+	}
+	if (!list_empty(&line_lh))
+		statistic_interface_def_close_parse(
+			interface, &line_lh, &line_size);
+
+	return statistic_interface_generic_close(inode, file);
+}
+
+static int statistic_interface_data_open(struct inode *inode, struct file *file)
+{
+	struct statistic_interface *interface;
+	struct statistic_file_private *private;
+	struct statistic *stat;
+	unsigned long flags;
+	int retval = 0;
+
+	retval = statistic_interface_generic_open(
+			inode, file, &interface, &private);
+	if (retval)
+		return retval;
+
+	statistic_lock(interface, flags);
+	list_for_each_entry(stat, &interface->statistic_lh, list) {
+		if (stat->format_data) {
+			retval = stat->format_data(stat, private);
+			if (retval) {
+				statistic_interface_generic_close(inode, file);
+				break;
+			}
+		}
+	}
+	statistic_unlock(interface, flags);
+
+	return retval;
+}
+
+postcore_initcall(statistic_init);
+module_exit(statistic_exit);
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL_GPL(statistic_interface_create);
+EXPORT_SYMBOL_GPL(statistic_interface_remove);
+EXPORT_SYMBOL_GPL(statistic_create);
+EXPORT_SYMBOL_GPL(statistic_remove);
+EXPORT_SYMBOL_GPL(statistic_define_value);
+EXPORT_SYMBOL_GPL(statistic_define_range);
+EXPORT_SYMBOL_GPL(statistic_define_array);
+EXPORT_SYMBOL_GPL(statistic_define_list);
+EXPORT_SYMBOL_GPL(statistic_define_raw);
+EXPORT_SYMBOL_GPL(statistic_define_history);
+EXPORT_SYMBOL_GPL(statistic_start);
+EXPORT_SYMBOL_GPL(statistic_stop);
+EXPORT_SYMBOL_GPL(statistic_reset);
