diff -Nru a/arch/ia64/Kconfig b/arch/ia64/Kconfig
--- a/arch/ia64/Kconfig	Fri Aug 15 18:23:28 2003
+++ b/arch/ia64/Kconfig	Fri Aug 15 18:23:28 2003
@@ -648,6 +648,33 @@
 	  keys are documented in <file:Documentation/sysrq.txt>. Don't say Y
 	  unless you really know what this hack does.
 
+config IA64_EARLY_PRINTK
+	bool "Early printk support"
+	depends on DEBUG_KERNEL && !IA64_GENERIC
+	help
+	  Selecting this option uses the VGA screen or serial console for
+	  printk() output before the consoles are initialised.  It is useful
+	  for debugging problems early in the boot process, but only if you
+	  have a suitable VGA/serial console attached.  If you're unsure,
+	  select N.
+
+config IA64_EARLY_PRINTK_UART
+	bool "Early printk on MMIO serial port"
+	depends on IA64_EARLY_PRINTK
+
+config IA64_EARLY_PRINTK_UART_BASE
+	hex "UART MMIO base address"
+	depends on IA64_EARLY_PRINTK_UART
+	default "ff5e0000"
+
+config IA64_EARLY_PRINTK_VGA
+	bool "Early printk on VGA"
+	depends on IA64_EARLY_PRINTK
+
+config IA64_EARLY_PRINTK_SGI_SN
+	bool "Early printk on SGI SN serial console"
+	depends on IA64_EARLY_PRINTK && (IA64_GENERIC || IA64_SGI_SN2)
+
 config DEBUG_SLAB
 	bool "Debug memory allocations"
 	depends on DEBUG_KERNEL
diff -Nru a/arch/ia64/ia32/sys_ia32.c b/arch/ia64/ia32/sys_ia32.c
--- a/arch/ia64/ia32/sys_ia32.c	Fri Aug 15 18:23:27 2003
+++ b/arch/ia64/ia32/sys_ia32.c	Fri Aug 15 18:23:27 2003
@@ -1374,7 +1374,7 @@
 			break;
 		old_fs = get_fs();
 		set_fs(KERNEL_DS);
-		err = sys_msgctl(first, second, &m64);
+		err = sys_msgctl(first, second, (struct msqid_ds *)&m64);
 		set_fs(old_fs);
 		break;
 
@@ -1382,7 +1382,7 @@
 	      case MSG_STAT:
 		old_fs = get_fs();
 		set_fs(KERNEL_DS);
-		err = sys_msgctl(first, second, (void *) &m64);
+		err = sys_msgctl(first, second, (struct msqid_ds *)&m64);
 		set_fs(old_fs);
 
 		if (version == IPC_64) {
@@ -1518,7 +1518,7 @@
 			break;
 		old_fs = get_fs();
 		set_fs(KERNEL_DS);
-		err = sys_shmctl(first, second, &s64);
+		err = sys_shmctl(first, second, (struct shmid_ds *)&s64);
 		set_fs(old_fs);
 		break;
 
@@ -1526,7 +1526,7 @@
 	      case SHM_STAT:
 		old_fs = get_fs();
 		set_fs(KERNEL_DS);
-		err = sys_shmctl(first, second, (void *) &s64);
+		err = sys_shmctl(first, second, (struct shmid_ds *)&s64);
 		set_fs(old_fs);
 		if (err < 0)
 			break;
@@ -1693,6 +1693,10 @@
 	}
 	return i;
 }
+
+asmlinkage long
+compat_sys_wait4 (compat_pid_t pid, compat_uint_t * stat_addr, int options,
+		 struct compat_rusage *ru);
 
 asmlinkage long
 sys32_waitpid (int pid, unsigned int *stat_addr, int options)
diff -Nru a/arch/ia64/kernel/efivars.c b/arch/ia64/kernel/efivars.c
--- a/arch/ia64/kernel/efivars.c	Fri Aug 15 18:23:27 2003
+++ b/arch/ia64/kernel/efivars.c	Fri Aug 15 18:23:27 2003
@@ -168,13 +168,12 @@
 			 efi_char16_t *variable_name,
 			 efi_guid_t *vendor_guid)
 {
-
 	int i, short_name_size = variable_name_size / sizeof(efi_char16_t) + 38;
 	char *short_name;
 	efivar_entry_t *new_efivar;
 
-        short_name = kmalloc(short_name_size+1, GFP_KERNEL);
-        new_efivar = kmalloc(sizeof(efivar_entry_t), GFP_KERNEL);
+	short_name = kmalloc(short_name_size+1, GFP_KERNEL);
+	new_efivar = kmalloc(sizeof(efivar_entry_t), GFP_KERNEL);
 
 	if (!short_name || !new_efivar)  {
 		if (short_name)        kfree(short_name);
@@ -210,9 +209,9 @@
 	new_efivar->entry->read_proc = efivar_read;
 	new_efivar->entry->write_proc = efivar_write;
 
-        spin_lock(&efivars_lock);
-        list_add(&new_efivar->list, &efivar_list);
-        spin_unlock(&efivars_lock);
+	spin_lock(&efivars_lock);
+	list_add(&new_efivar->list, &efivar_list);
+	spin_unlock(&efivars_lock);
 
 	return 0;
 }
@@ -283,7 +282,7 @@
 	if (!var_data)
 		return -ENOMEM;
 	if (copy_from_user(var_data, buffer, size)) {
-                kfree(var_data);
+		kfree(var_data);
 		return -EFAULT;
 	}
 
@@ -344,12 +343,73 @@
 	return size;
 }
 
+/*
+ * The EFI system table contains pointers to the SAL system table,
+ * HCDP, ACPI, SMBIOS, etc, that may be useful to applications.
+ */
+static ssize_t
+efi_systab_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	void *data;
+	u8 *proc_buffer;
+	ssize_t size, length;
+	int ret;
+	const int max_nr_entries = 7; 	/* num ptrs to tables we could expose */
+	const int max_line_len = 80;
+
+	if (!efi.systab)
+		return 0;
 
+	proc_buffer = kmalloc(max_nr_entries * max_line_len, GFP_KERNEL);
+	if (!proc_buffer)
+		return -ENOMEM;
+
+	length = 0;
+	if (efi.mps)
+		length += sprintf(proc_buffer + length, "MPS=0x%lx\n", __pa(efi.mps));
+	if (efi.acpi20)
+		length += sprintf(proc_buffer + length, "ACPI20=0x%lx\n", __pa(efi.acpi20));
+	if (efi.acpi)
+		length += sprintf(proc_buffer + length, "ACPI=0x%lx\n", __pa(efi.acpi));
+	if (efi.smbios)
+		length += sprintf(proc_buffer + length, "SMBIOS=0x%lx\n", __pa(efi.smbios));
+	if (efi.sal_systab)
+		length += sprintf(proc_buffer + length, "SAL=0x%lx\n", __pa(efi.sal_systab));
+	if (efi.hcdp)
+		length += sprintf(proc_buffer + length, "HCDP=0x%lx\n", __pa(efi.hcdp));
+	if (efi.boot_info)
+		length += sprintf(proc_buffer + length, "BOOTINFO=0x%lx\n", __pa(efi.boot_info));
+
+	if (*ppos >= length) {
+		ret = 0;
+		goto out;
+	}
+
+	data = proc_buffer + file->f_pos;
+	size = length - file->f_pos;
+	if (size > count)
+		size = count;
+	if (copy_to_user(buffer, data, size)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	*ppos += size;
+	ret = size;
+
+out:
+	kfree(proc_buffer);
+	return ret;
+}
+
+static struct proc_dir_entry *efi_systab_entry;
+static struct file_operations efi_systab_fops = {
+	.read = efi_systab_read,
+};
 
 static int __init
 efivars_init(void)
 {
-
 	efi_status_t status;
 	efi_guid_t vendor_guid;
 	efi_char16_t *variable_name = kmalloc(1024, GFP_KERNEL);
@@ -357,13 +417,17 @@
 
 	printk(KERN_INFO "EFI Variables Facility v%s\n", EFIVARS_VERSION);
 
-        /* Since efi.c happens before procfs is available,
-           we create the directory here if it doesn't
-           already exist.  There's probably a better way
-           to do this.
-        */
-        if (!efi_dir)
-                efi_dir = proc_mkdir("efi", NULL);
+	/* Since efi.c happens before procfs is available,
+	   we create the directory here if it doesn't
+	   already exist.  There's probably a better way
+	   to do this.
+	*/
+	if (!efi_dir)
+		efi_dir = proc_mkdir("efi", NULL);
+
+	efi_systab_entry = create_proc_entry("systab", S_IRUSR | S_IRGRP, efi_dir);
+	if (efi_systab_entry)
+		efi_systab_entry->proc_fops = &efi_systab_fops;
 
 	efi_vars_dir = proc_mkdir("vars", efi_dir);
 
@@ -407,7 +471,9 @@
 	struct list_head *pos, *n;
 	efivar_entry_t *efivar;
 
-        spin_lock(&efivars_lock);
+	spin_lock(&efivars_lock);
+	if (efi_systab_entry)
+		remove_proc_entry(efi_systab_entry->name, efi_dir);
 	list_for_each_safe(pos, n, &efivar_list) {
 		efivar = efivar_entry(pos);
 		remove_proc_entry(efivar->entry->name, efi_vars_dir);
diff -Nru a/arch/ia64/kernel/entry.S b/arch/ia64/kernel/entry.S
--- a/arch/ia64/kernel/entry.S	Fri Aug 15 18:23:27 2003
+++ b/arch/ia64/kernel/entry.S	Fri Aug 15 18:23:27 2003
@@ -113,7 +113,7 @@
  *	      u64 tls)
  */
 GLOBAL_ENTRY(sys_clone2)
-	.prologue ASM_UNW_PRLG_RP|ASM_UNW_PRLG_PFS, ASM_UNW_PRLG_GRSAVE(2)
+	.prologue ASM_UNW_PRLG_RP|ASM_UNW_PRLG_PFS, ASM_UNW_PRLG_GRSAVE(6)
 	alloc r16=ar.pfs,6,2,6,0
 	DO_SAVE_SWITCH_STACK
 	adds r2=PT(R16)+IA64_SWITCH_STACK_SIZE+16,sp
@@ -142,7 +142,7 @@
  *	Deprecated.  Use sys_clone2() instead.
  */
 GLOBAL_ENTRY(sys_clone)
-	.prologue ASM_UNW_PRLG_RP|ASM_UNW_PRLG_PFS, ASM_UNW_PRLG_GRSAVE(2)
+	.prologue ASM_UNW_PRLG_RP|ASM_UNW_PRLG_PFS, ASM_UNW_PRLG_GRSAVE(5)
 	alloc r16=ar.pfs,5,2,6,0
 	DO_SAVE_SWITCH_STACK
 	adds r2=PT(R16)+IA64_SWITCH_STACK_SIZE+16,sp
diff -Nru a/arch/ia64/kernel/mca.c b/arch/ia64/kernel/mca.c
--- a/arch/ia64/kernel/mca.c	Fri Aug 15 18:23:27 2003
+++ b/arch/ia64/kernel/mca.c	Fri Aug 15 18:23:27 2003
@@ -115,6 +115,7 @@
 	.name =		"mca_wkup"
 };
 
+#ifdef CONFIG_ACPI
 static struct irqaction mca_cpe_irqaction = {
 	.handler =	ia64_mca_cpe_int_handler,
 	.flags =	SA_INTERRUPT,
@@ -126,6 +127,7 @@
 	.flags =	SA_INTERRUPT,
 	.name =		"cpe_poll"
 };
+#endif /* CONFIG_ACPI */
 
 #define MAX_CPE_POLL_INTERVAL (15*60*HZ) /* 15 minutes */
 #define MIN_CPE_POLL_INTERVAL (2*60*HZ)  /* 2 minutes */
@@ -434,6 +436,7 @@
 
 device_initcall(ia64_mca_check_errors);
 
+#ifdef CONFIG_ACPI
 /*
  * ia64_mca_register_cpev
  *
@@ -458,6 +461,7 @@
 	IA64_MCA_DEBUG("ia64_mca_platform_init: corrected platform error "
 		       "vector %#x setup and enabled\n", cpev);
 }
+#endif /* CONFIG_ACPI */
 
 #endif /* PLATFORM_MCA_HANDLERS */
 
@@ -750,6 +754,7 @@
 	/* Setup the MCA wakeup interrupt vector */
 	register_percpu_irq(IA64_MCA_WAKEUP_VECTOR, &mca_wkup_irqaction);
 
+#ifdef CONFIG_ACPI
 	/* Setup the CPE interrupt vector */
 	{
 		irq_desc_t *desc;
@@ -767,6 +772,7 @@
 			ia64_mca_register_cpev(cpev);
 		}
 	}
+#endif
 
 	/* Initialize the areas set aside by the OS to buffer the
 	 * platform/processor error states for MCA/INIT/CMC
@@ -1279,11 +1285,13 @@
 	init_timer(&cpe_poll_timer);
 	cpe_poll_timer.function = ia64_mca_cpe_poll;
 
+#ifdef CONFIG_ACPI
 	/* If platform doesn't support CPEI, get the timer going. */
 	if (acpi_request_vector(ACPI_INTERRUPT_CPEI) < 0 && cpe_poll_enabled) {
 		register_percpu_irq(IA64_CPEP_VECTOR, &mca_cpep_irqaction);
 		ia64_mca_cpe_poll(0UL);
 	}
+#endif
 
 	return 0;
 }
@@ -1398,6 +1406,9 @@
 
 	// SAL will tell us the maximum size of any error record of this type
 	max_size = ia64_sal_get_state_info_size(sal_info_type);
+	if (!max_size)
+		/* alloc_bootmem() doesn't like zero-sized allocations! */
+		return;
 
 	// set up OS data structures to hold error info
 	IA64_LOG_ALLOCATE(sal_info_type, max_size);
diff -Nru a/arch/ia64/kernel/process.c b/arch/ia64/kernel/process.c
--- a/arch/ia64/kernel/process.c	Fri Aug 15 18:23:27 2003
+++ b/arch/ia64/kernel/process.c	Fri Aug 15 18:23:27 2003
@@ -45,7 +45,7 @@
 ia64_do_show_stack (struct unw_frame_info *info, void *arg)
 {
 	unsigned long ip, sp, bsp;
-	char buf[80];			/* don't make it so big that it overflows the stack! */
+	char buf[128];			/* don't make it so big that it overflows the stack! */
 
 	printk("\nCall Trace:\n");
 	do {
@@ -55,7 +55,9 @@
 
 		unw_get_sp(info, &sp);
 		unw_get_bsp(info, &bsp);
-		snprintf(buf, sizeof(buf), " [<%016lx>] %%s\n\t\t\t\tsp=%016lx bsp=%016lx\n",
+		snprintf(buf, sizeof(buf),
+			 " [<%016lx>] %%s\n"
+			 "                                sp=%016lx bsp=%016lx\n",
 			 ip, sp, bsp);
 		print_symbol(buf, ip);
 	} while (unw_unwind(info) >= 0);
diff -Nru a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
--- a/drivers/acpi/pci_irq.c	Fri Aug 15 18:23:27 2003
+++ b/drivers/acpi/pci_irq.c	Fri Aug 15 18:23:27 2003
@@ -24,6 +24,8 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
+#include <linux/config.h>
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -35,6 +37,9 @@
 #include <linux/acpi.h>
 #ifdef CONFIG_X86_IO_APIC
 #include <asm/mpspec.h>
+#endif
+#ifdef CONFIG_IOSAPIC
+# include <asm/iosapic.h>
 #endif
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
diff -Nru a/drivers/acpi/tables.c b/drivers/acpi/tables.c
--- a/drivers/acpi/tables.c	Fri Aug 15 18:23:27 2003
+++ b/drivers/acpi/tables.c	Fri Aug 15 18:23:27 2003
@@ -256,10 +256,17 @@
 
 	/* Map the DSDT header via the pointer in the FADT */
 	if (id == ACPI_DSDT) {
-		struct acpi_table_fadt *fadt = (struct acpi_table_fadt *) *header;
+		struct fadt_descriptor_rev2 *fadt = (struct fadt_descriptor_rev2 *) *header;
+
+		if (fadt->header.revision == 3 && fadt->Xdsdt) {
+			*header = (void *) __acpi_map_table(fadt->Xdsdt,
+					sizeof(struct acpi_table_header));
+		} else if (fadt->V1_dsdt) {
+			*header = (void *) __acpi_map_table(fadt->V1_dsdt,
+					sizeof(struct acpi_table_header));
+		} else
+			*header = 0;
 
-		*header = (void *) __acpi_map_table(fadt->dsdt_addr,
-				sizeof(struct acpi_table_header));
 		if (!*header) {
 			printk(KERN_WARNING PREFIX "Unable to map DSDT\n");
 			return -ENODEV;
diff -Nru a/drivers/media/radio/Makefile b/drivers/media/radio/Makefile
--- a/drivers/media/radio/Makefile	Fri Aug 15 18:23:27 2003
+++ b/drivers/media/radio/Makefile	Fri Aug 15 18:23:27 2003
@@ -2,6 +2,8 @@
 # Makefile for the kernel character device drivers.
 #
 
+obj-y		:= dummy.o
+
 miropcm20-objs	:= miropcm20-rds-core.o miropcm20-radio.o
 
 obj-$(CONFIG_RADIO_AZTECH) += radio-aztech.o
diff -Nru a/drivers/media/radio/dummy.c b/drivers/media/radio/dummy.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/media/radio/dummy.c	Fri Aug 15 18:23:28 2003
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -Nru a/drivers/media/video/Makefile b/drivers/media/video/Makefile
--- a/drivers/media/video/Makefile	Fri Aug 15 18:23:27 2003
+++ b/drivers/media/video/Makefile	Fri Aug 15 18:23:27 2003
@@ -6,6 +6,8 @@
 			bttv-risc.o bttv-vbi.o
 zoran-objs      :=	zr36120.o zr36120_i2c.o zr36120_mem.o
 
+obj-y		:=	dummy.o
+
 obj-$(CONFIG_VIDEO_DEV) += videodev.o v4l2-common.o v4l1-compat.o
 
 obj-$(CONFIG_VIDEO_BT848) += bttv.o msp3400.o tvaudio.o \
diff -Nru a/drivers/media/video/dummy.c b/drivers/media/video/dummy.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/media/video/dummy.c	Fri Aug 15 18:23:28 2003
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -Nru a/drivers/net/tulip/media.c b/drivers/net/tulip/media.c
--- a/drivers/net/tulip/media.c	Fri Aug 15 18:23:27 2003
+++ b/drivers/net/tulip/media.c	Fri Aug 15 18:23:27 2003
@@ -278,6 +278,10 @@
 				for (i = 0; i < init_length; i++)
 					outl(init_sequence[i], ioaddr + CSR12);
 			}
+
+			(void) inl(ioaddr + CSR6); /* flush CSR12 writes */
+			udelay(500);		/* Give MII time to recover */
+
 			tmp_info = get_u16(&misc_info[1]);
 			if (tmp_info)
 				tp->advertising[phy_num] = tmp_info | 1;
diff -Nru a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
--- a/drivers/scsi/qla1280.c	Fri Aug 15 18:23:28 2003
+++ b/drivers/scsi/qla1280.c	Fri Aug 15 18:23:28 2003
@@ -284,7 +284,7 @@
 #define  QL1280_TARGET_MODE_SUPPORT    0	/* Target mode support */
 #define  QL1280_LUN_SUPPORT            0
 #define  WATCHDOGTIMER                 0
-#define  MEMORY_MAPPED_IO              0
+#define  MEMORY_MAPPED_IO              1
 #define  DEBUG_QLA1280_INTR            0
 #define  USE_NVRAM_DEFAULTS	       0
 #define  DEBUG_PRINT_NVRAM             0
@@ -2491,7 +2491,7 @@
 	/*
 	 * Get memory mapped I/O address.
 	 */
-	pci_read_config_word (ha->pdev, PCI_BASE_ADDRESS_1, &mmapbase);
+	pci_read_config_dword (ha->pdev, PCI_BASE_ADDRESS_1, &mmapbase);
 	mmapbase &= PCI_BASE_ADDRESS_MEM_MASK;
 
 	/*
diff -Nru a/include/asm-ia64/sn/nodepda.h b/include/asm-ia64/sn/nodepda.h
--- a/include/asm-ia64/sn/nodepda.h	Fri Aug 15 18:23:27 2003
+++ b/include/asm-ia64/sn/nodepda.h	Fri Aug 15 18:23:27 2003
@@ -12,6 +12,7 @@
 #include <linux/config.h>
 #include <asm/sn/sgi.h>
 #include <asm/irq.h>
+#include <asm/topology.h>
 #include <asm/sn/intr.h>
 #include <asm/sn/router.h>
 #include <asm/sn/pda.h>
@@ -127,7 +128,7 @@
  * Check if given a compact node id the corresponding node has all the
  * cpus disabled. 
  */
-#define is_headless_node(cnode)		(!test_bit(cnode, &node_has_active_cpus))
+#define is_headless_node(cnode)		(!node_to_cpumask(cnode))
 
 /*
  * Check if given a node vertex handle the corresponding node has all the
diff -Nru a/include/asm-ia64/unistd.h b/include/asm-ia64/unistd.h
--- a/include/asm-ia64/unistd.h	Fri Aug 15 18:23:27 2003
+++ b/include/asm-ia64/unistd.h	Fri Aug 15 18:23:27 2003
@@ -257,96 +257,138 @@
 
 extern long __ia64_syscall (long a0, long a1, long a2, long a3, long a4, long nr);
 
-#define _syscall0(type,name)						\
-type									\
-name (void)								\
-{									\
-	register long dummy1 __asm__ ("out0");				\
-	register long dummy2 __asm__ ("out1");				\
-	register long dummy3 __asm__ ("out2");				\
-	register long dummy4 __asm__ ("out3");				\
-	register long dummy5 __asm__ ("out4");				\
-									\
-	return __ia64_syscall(dummy1, dummy2, dummy3, dummy4, dummy5,	\
-			      __NR_##name);				\
-}
-
-#define _syscall1(type,name,type1,arg1)					\
-type									\
-name (type1 arg1)							\
-{									\
-	register long dummy2 __asm__ ("out1");				\
-	register long dummy3 __asm__ ("out2");				\
-	register long dummy4 __asm__ ("out3");				\
-	register long dummy5 __asm__ ("out4");				\
-									\
-	return __ia64_syscall((long) arg1, dummy2, dummy3, dummy4,	\
-			      dummy5, __NR_##name);			\
-}
-
-#define _syscall2(type,name,type1,arg1,type2,arg2)			\
-type									\
-name (type1 arg1, type2 arg2)						\
-{									\
-	register long dummy3 __asm__ ("out2");				\
-	register long dummy4 __asm__ ("out3");				\
-	register long dummy5 __asm__ ("out4");				\
-									\
-	return __ia64_syscall((long) arg1, (long) arg2, dummy3, dummy4,	\
-			      dummy5, __NR_##name);			\
-}
-
-#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
-type									\
-name (type1 arg1, type2 arg2, type3 arg3)				\
-{									\
-	register long dummy4 __asm__ ("out3");				\
-	register long dummy5 __asm__ ("out4");				\
-									\
-	return __ia64_syscall((long) arg1, (long) arg2, (long) arg3,	\
-			      dummy4, dummy5, __NR_##name);		\
-}
-
-#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)	\
-type										\
-name (type1 arg1, type2 arg2, type3 arg3, type4 arg4)				\
-{										\
-	register long dummy5 __asm__ ("out4");					\
-										\
-	return __ia64_syscall((long) arg1, (long) arg2, (long) arg3,		\
-			      (long) arg4, dummy5, __NR_##name);		\
-}
-
-#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,type5,arg5)	\
-type											\
-name (type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5)			\
-{											\
-	return __ia64_syscall((long) arg1, (long) arg2, (long) arg3,			\
-			      (long) arg4, (long) arg5, __NR_##name);			\
+#ifdef __KERNEL_SYSCALLS__
+
+#include <linux/string.h>
+#include <linux/signal.h>
+#include <asm/ptrace.h>
+#include <linux/stringify.h>
+
+static inline long
+open (const char * name, int mode, int flags)
+{
+	extern long sys_open (const char *, int, int);
+	return sys_open(name, mode, flags);
 }
 
-#ifdef __KERNEL_SYSCALLS__
+static inline long
+dup (int fd)
+{
+	extern long sys_dup (int);
+	return sys_dup(fd);
+}
+
+static inline long
+close (int fd)
+{
+	extern long sys_close(unsigned int);
+	return sys_close(fd);
+}
+
+static inline off_t
+lseek (int fd, off_t off, int whence)
+{
+	extern off_t sys_lseek (int, off_t, int);
+	return sys_lseek(fd, off, whence);
+}
+
+static inline long
+_exit (int value)
+{
+	extern long sys_exit (int);
+	return sys_exit(value);
+}
+
+#define exit(x) _exit(x)
+
+static inline long
+write (int fd, const char * buf, size_t nr)
+{
+	extern long sys_write (int, const char *, size_t);
+	return sys_write(fd, buf, nr);
+}
+
+static inline long
+read (int fd, char * buf, size_t nr)
+{
+	extern long sys_read (int, char *, size_t);
+	return sys_read(fd, buf, nr);
+}
+
+
+static inline long
+setsid (void)
+{
+	extern long sys_setsid (void);
+	return sys_setsid();
+}
 
 struct rusage;
 
-static inline _syscall0(pid_t,setsid)
-static inline _syscall3(int,write,int,fd,const char *,buf,off_t,count)
-static inline _syscall3(int,read,int,fd,char *,buf,off_t,count)
-static inline _syscall3(off_t,lseek,int,fd,off_t,offset,int,count)
-static inline _syscall1(int,dup,int,fd)
-static inline _syscall3(int,execve,const char *,file,char **,argv,char **,envp)
-static inline _syscall3(int,open,const char *,file,int,flag,int,mode)
-static inline _syscall1(int,close,int,fd)
-static inline _syscall4(pid_t,wait4,pid_t,pid,int *,wait_stat,int,options,struct rusage*, rusage)
-static inline _syscall2(pid_t,clone,unsigned long,flags,void*,sp);
+static inline pid_t
+waitpid (int pid, int * wait_stat, int flags)
+{
+	extern asmlinkage long sys_wait4 (pid_t, unsigned int *, int, struct rusage *);
+
+	return sys_wait4(pid, wait_stat, flags, NULL);
+}
 
-#define __NR__exit __NR_exit
-static inline _syscall1(int,_exit,int,exitcode)
+
+static inline int
+execve (const char *filename, char *const av[], char *const ep[])
+{
+	register long r8 asm("r8");
+	register long r10 asm("r10");
+	register long r15 asm("r15") = __NR_execve;
+	register long out0 asm("out0") = (long)filename;
+	register long out1 asm("out1") = (long)av;
+	register long out2 asm("out2") = (long)ep;
+
+	asm volatile ("break " __stringify(__BREAK_SYSCALL) ";;\n\t"
+		      : "=r" (r8), "=r" (r10), "=r" (r15), "=r" (out0), "=r" (out1), "=r" (out2)
+		      : "2" (r15), "3" (out0), "4" (out1), "5" (out2)
+		      : "memory", "out3", "out4", "out5", "out6", "out7",
+		      /* Non-stacked integer registers, minus r8, r10, r15, r13  */
+		      "r2", "r3", "r9", "r11", "r12", "r14", "r16", "r17", "r18",
+		      "r19", "r20", "r21", "r22", "r23", "r24", "r25", "r26", "r27",
+		      "r28", "r29", "r30", "r31",
+		      /* Predicate registers.  */
+		      "p6", "p7", "p8", "p9", "p10", "p11", "p12", "p13", "p14", "p15",
+		      /* Non-rotating fp registers.  */
+		      "f6", "f7", "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
+		      /* Branch registers.  */
+		      "b6", "b7" );
+	return r8;
+}
 
 static inline pid_t
-waitpid (int pid, int *wait_stat, int flags)
+clone (unsigned long flags, void *sp)
 {
-	return wait4(pid, wait_stat, flags, NULL);
+	register long r8 asm("r8");
+	register long r10 asm("r10");
+	register long r15 asm("r15") = __NR_clone;
+	register long out0 asm("out0") = (long)flags;
+	register long out1 asm("out1") = (long)sp;
+	long retval;
+
+	/* clone clobbers current, hence the "r13" in the clobbers list */
+	asm volatile ( "break " __stringify(__BREAK_SYSCALL) ";;\n\t"
+		       : "=r" (r8), "=r" (r10), "=r" (r15), "=r" (out0), "=r" (out1)
+		       : "2" (r15), "3" (out0), "4" (out1)
+		       : "memory", "out2", "out3", "out4", "out5", "out6", "out7", "r13",
+		       /* Non-stacked integer registers, minus r8, r10, r15, r13  */
+		       "r2", "r3", "r9", "r11", "r12", "r14", "r16", "r17", "r18",
+		       "r19", "r20", "r21", "r22", "r23", "r24", "r25", "r26", "r27",
+		       "r28", "r29", "r30", "r31",
+		       /* Predicate registers.  */
+		       "p6", "p7", "p8", "p9", "p10", "p11", "p12", "p13", "p14", "p15",
+		       /* Non-rotating fp registers.  */
+		       "f6", "f7", "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
+		       /* Branch registers.  */
+		       "b6", "b7" );
+	retval = r8;
+	return retval;;
+
 }
 
 #endif /* __KERNEL_SYSCALLS__ */
diff -Nru a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
--- a/include/linux/nfs_fs.h	Fri Aug 15 18:23:27 2003
+++ b/include/linux/nfs_fs.h	Fri Aug 15 18:23:27 2003
@@ -410,7 +410,7 @@
 nfs_size_to_loff_t(__u64 size)
 {
 	loff_t maxsz = (((loff_t) ULONG_MAX) << PAGE_CACHE_SHIFT) + PAGE_CACHE_SIZE - 1;
-	if (size > maxsz)
+	if (size > (__u64) maxsz)
 		return maxsz;
 	return (loff_t) size;
 }
diff -Nru a/include/linux/sysctl.h b/include/linux/sysctl.h
--- a/include/linux/sysctl.h	Fri Aug 15 18:23:27 2003
+++ b/include/linux/sysctl.h	Fri Aug 15 18:23:27 2003
@@ -126,6 +126,7 @@
 	KERN_PANIC_ON_OOPS=57,  /* int: whether we will panic on an oops */
 	KERN_HPPA_PWRSW=58,	/* int: hppa soft-power enable */
 	KERN_HPPA_UNALIGNED=59,	/* int: hppa unaligned-trap enable */
+	KERN_CACHEDECAYTICKS=60,/* ulong: value for cache_decay_ticks (EXPERIMENTAL!) */
 };
 
 
diff -Nru a/kernel/printk.c b/kernel/printk.c
--- a/kernel/printk.c	Fri Aug 15 18:23:28 2003
+++ b/kernel/printk.c	Fri Aug 15 18:23:28 2003
@@ -313,6 +313,12 @@
 			__call_console_drivers(start, end);
 		}
 	}
+#ifdef CONFIG_IA64_EARLY_PRINTK
+	if (!console_drivers) {
+		void early_printk (const char *str, size_t len);
+		early_printk(&LOG_BUF(start), end - start);
+	}
+#endif
 }
 
 /*
@@ -630,7 +636,11 @@
 		 * for us.
 		 */
 		spin_lock_irqsave(&logbuf_lock, flags);
+#ifdef CONFIG_IA64_EARLY_PRINTK
+		con_start = log_end;
+#else
 		con_start = log_start;
+#endif
 		spin_unlock_irqrestore(&logbuf_lock, flags);
 	}
 	release_console_sem();
@@ -683,3 +693,117 @@
 		tty->driver->write(tty, 0, msg, strlen(msg));
 	return;
 }
+
+#ifdef CONFIG_IA64_EARLY_PRINTK
+
+#include <asm/io.h>
+
+# ifdef CONFIG_IA64_EARLY_PRINTK_VGA
+
+
+#define VGABASE		((char *)0xc0000000000b8000)
+#define VGALINES	24
+#define VGACOLS		80
+
+static int current_ypos = VGALINES, current_xpos = 0;
+
+static void
+early_printk_vga (const char *str, size_t len)
+{
+	char c;
+	int  i, k, j;
+
+	while (len-- > 0) {
+		c = *str++;
+		if (current_ypos >= VGALINES) {
+			/* scroll 1 line up */
+			for (k = 1, j = 0; k < VGALINES; k++, j++) {
+				for (i = 0; i < VGACOLS; i++) {
+					writew(readw(VGABASE + 2*(VGACOLS*k + i)),
+					       VGABASE + 2*(VGACOLS*j + i));
+				}
+			}
+			for (i = 0; i < VGACOLS; i++) {
+				writew(0x720, VGABASE + 2*(VGACOLS*j + i));
+			}
+			current_ypos = VGALINES-1;
+		}
+		if (c == '\n') {
+			current_xpos = 0;
+			current_ypos++;
+		} else if (c != '\r')  {
+			writew(((0x7 << 8) | (unsigned short) c),
+			       VGABASE + 2*(VGACOLS*current_ypos + current_xpos++));
+			if (current_xpos >= VGACOLS) {
+				current_xpos = 0;
+				current_ypos++;
+			}
+		}
+	}
+}
+
+# endif /* CONFIG_IA64_EARLY_PRINTK_VGA */
+
+# ifdef CONFIG_IA64_EARLY_PRINTK_UART
+
+#include <linux/serial_reg.h>
+#include <asm/system.h>
+
+static void early_printk_uart(const char *str, size_t len)
+{
+	static char *uart = NULL;
+	unsigned long uart_base;
+	char c;
+
+	if (!uart) {
+		uart_base = 0;
+#  ifdef CONFIG_SERIAL_8250_HCDP
+		{
+			extern unsigned long hcdp_early_uart(void);
+			uart_base = hcdp_early_uart();
+		}
+#  endif
+#  if CONFIG_IA64_EARLY_PRINTK_UART_BASE
+		if (!uart_base)
+			uart_base = CONFIG_IA64_EARLY_PRINTK_UART_BASE;
+#  endif
+		if (!uart_base)
+			return;
+
+		uart = ioremap(uart_base, 64);
+		if (!uart)
+			return;
+	}
+
+	while (len-- > 0) {
+		c = *str++;
+		while ((readb(uart + UART_LSR) & UART_LSR_TEMT) == 0)
+			cpu_relax(); /* spin */
+
+		writeb(c, uart + UART_TX);
+
+		if (c == '\n')
+			writeb('\r', uart + UART_TX);
+	}
+}
+
+# endif /* CONFIG_IA64_EARLY_PRINTK_UART */
+
+#ifdef CONFIG_IA64_EARLY_PRINTK_SGI_SN
+extern int sn_sal_console_out(const char *str, int len);
+#endif
+
+void early_printk(const char *str, size_t len)
+{
+#ifdef CONFIG_IA64_EARLY_PRINTK_UART
+	early_printk_uart(str, len);
+#endif
+#ifdef CONFIG_IA64_EARLY_PRINTK_VGA
+	early_printk_vga(str, len);
+#endif
+#ifdef CONFIG_IA64_EARLY_PRINTK_SGI_SN
+ 	sn_sal_console_out(str, len);
+#endif
+}
+
+#endif /* CONFIG_IA64_EARLY_PRINTK */
diff -Nru a/kernel/sysctl.c b/kernel/sysctl.c
--- a/kernel/sysctl.c	Fri Aug 15 18:23:27 2003
+++ b/kernel/sysctl.c	Fri Aug 15 18:23:27 2003
@@ -580,6 +580,16 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#ifdef CONFIG_SMP
+	{
+		.ctl_name	= KERN_CACHEDECAYTICKS,
+		.procname	= "cache_decay_ticks",
+		.data		= &cache_decay_ticks,
+		.maxlen		= sizeof(cache_decay_ticks),
+		.mode		= 0644,
+		.proc_handler	= &proc_doulongvec_minmax,
+	},
+#endif
 	{ .ctl_name = 0 }
 };
 
diff -Nru a/mm/memory.c b/mm/memory.c
--- a/mm/memory.c	Fri Aug 15 18:23:27 2003
+++ b/mm/memory.c	Fri Aug 15 18:23:27 2003
@@ -114,8 +114,10 @@
 	}
 	pmd = pmd_offset(dir, 0);
 	pgd_clear(dir);
-	for (j = 0; j < PTRS_PER_PMD ; j++)
+	for (j = 0; j < PTRS_PER_PMD ; j++) {
+		prefetchw(pmd + j + PREFETCH_STRIDE/sizeof(*pmd));
 		free_one_pmd(tlb, pmd+j);
+	}
 	pmd_free_tlb(tlb, pmd);
 }
 
