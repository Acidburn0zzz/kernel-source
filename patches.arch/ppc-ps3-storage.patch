ps3-hacks/ps3stor_flash_bootmem.diff
ps3-hacks/ps3stor-repository-exports.diff
ps3-wip/ps3_repository_find_bus.diff
ps3-wip/ps3stor_bus.diff
ps3-wip/ps3stor_disk.diff
ps3-wip/ps3stor_rom.diff
ps3-wip/ps3stor_flash.diff
ps3-wip/ps3_storage.diff
ps3-hacks/ps3stor_use_bootmem_buffer.diff
ps3-wip/ps3stor_repository.diff
ps3-wip/ps3stor_repository-2.diff
ps3-wip/ps3stor_config.diff
ps3-wip/ps3stor_kill_DYNAMIC_BOUNCE.diff
ps3-wip/ps3stor_rw_semaphore.diff
ps3-wip/ps3stor-readcd.diff
ps3-wip/ps3stor_modalias.diff
ps3-wip/ps3stor_cleanup.diff
ps3-wip/ps3stor_cleanup2.diff
ps3-wip/ps3stor_cleanup3.diff
ps3-wip/ps3stor_cleanup4.diff
ps3-wip/ps3stor_cleanup5.diff
ps3-wip/ps3stor_cleanup6.diff
ps3-wip/ps3stor_cleanup-kconfig.diff
ps3-wip/ps3stor_cleanup-open.diff
ps3-wip/ps3disk-remove-getgeo.diff
ps3-wip/ps3stor_devinit.diff

---
 arch/powerpc/platforms/ps3/Kconfig       |   39 
 arch/powerpc/platforms/ps3/device-init.c |    2 
 arch/powerpc/platforms/ps3/platform.h    |    3 
 arch/powerpc/platforms/ps3/repository.c  |   60 
 arch/powerpc/platforms/ps3/setup.c       |   20 
 arch/powerpc/platforms/ps3/system-bus.c  |    6 
 drivers/block/Kconfig                    |   28 
 drivers/block/Makefile                   |    2 
 drivers/block/ps3_storage.c              | 2753 +++++++++++++++++++++++++++++++
 drivers/block/ps3_storage.h              |  237 ++
 drivers/block/ps3disk.c                  |  452 +++++
 drivers/char/Makefile                    |    2 
 drivers/char/ps3flash.c                  |  491 +++++
 drivers/ps3/Makefile                     |    1 
 drivers/ps3/ps3stor_lib.c                |  257 ++
 drivers/scsi/Makefile                    |    1 
 drivers/scsi/ps3rom.c                    |  930 ++++++++++
 include/asm-powerpc/ps3.h                |    1 
 include/asm-powerpc/ps3stor.h            |   70 
 19 files changed, 5331 insertions(+), 24 deletions(-)

--- a/arch/powerpc/platforms/ps3/Kconfig
+++ b/arch/powerpc/platforms/ps3/Kconfig
@@ -81,4 +81,43 @@ config PS3_SYS_MANAGER
 	  This support is required for system control.  In
 	  general, all users will say Y or M.
 
+config PS3_STORAGE
+	depends on PPC_PS3
+	tristate
+
+config PS3_DISK
+	tristate "PS3 Disk Storage Driver"
+	depends on PPC_PS3
+	select PS3_STORAGE
+	default y
+	help
+	  Include support for the PS3 Disk Storage.
+
+	  This support is required to access the PS3 hard disk.
+	  In general, all users will say Y or M.
+
+config PS3_ROM
+	tristate "PS3 ROM Storage Driver"
+	depends on PPC_PS3
+	select BLK_DEV_SR
+	select PS3_STORAGE
+	default y
+	help
+	  Include support for the PS3 ROM Storage.
+
+	  This support is required to access the PS3 BD/DVD/CD-ROM drive.
+	  In general, all users will say Y or M.
+
+config PS3_FLASH
+	tristate "PS3 FLASH ROM Storage Driver"
+	depends on PPC_PS3
+	select PS3_STORAGE
+	default y
+	help
+	  Include support for the PS3 FLASH ROM Storage.
+
+	  This support is required to access the PS3 FLASH ROM, which
+	  contains the boot loader and some boot options.
+	  In general, all users will say Y or M.
+
 endmenu
--- a/arch/powerpc/platforms/ps3/device-init.c
+++ b/arch/powerpc/platforms/ps3/device-init.c
@@ -697,7 +697,7 @@ static int ps3stor_probe_dev(struct ps3_
 		goto cleanup;
 	}
 
-#if defined(CONFIG_PS3_STORAGE) || defined(CONFIG_PS3_STORAGE_MODULE)
+#if defined(CONFIG_PS3_STORAGE_OLD) || defined(CONFIG_PS3_STORAGE_OLD_MODULE)
 	switch (match_id) {
 #if defined(CONFIG_PS3_DISK) || defined(CONFIG_PS3_DISK_MODULE)
 	case PS3_MATCH_ID_STOR_DISK:
--- a/arch/powerpc/platforms/ps3/platform.h
+++ b/arch/powerpc/platforms/ps3/platform.h
@@ -82,6 +82,7 @@ enum ps3_dev_type {
 	PS3_DEV_TYPE_STOR_ROM = TYPE_ROM,	/* 5 */
 	PS3_DEV_TYPE_SB_GPIO = 6,
 	PS3_DEV_TYPE_STOR_FLASH = TYPE_RBC,	/* 14 */
+	PS3_DEV_TYPE_NONE = 255,
 };
 
 int ps3_repository_read_bus_str(unsigned int bus_index, const char *bus_str,
@@ -134,6 +135,8 @@ struct ps3_repository_device {
 	struct ps3_device_id did;
 };
 
+int ps3_repository_find_bus(enum ps3_bus_type bus_type, unsigned int from,
+	unsigned int *bus_index);
 int ps3_repository_find_device(enum ps3_bus_type bus_type,
 	enum ps3_dev_type dev_type,
 	const struct ps3_repository_device *start_dev,
--- a/arch/powerpc/platforms/ps3/repository.c
+++ b/arch/powerpc/platforms/ps3/repository.c
@@ -182,6 +182,7 @@ int ps3_repository_read_bus_id(unsigned 
 	*bus_id = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_id);
 
 int ps3_repository_read_bus_type(unsigned int bus_index,
 	enum ps3_bus_type *bus_type)
@@ -197,6 +198,7 @@ int ps3_repository_read_bus_type(unsigne
 	*bus_type = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_type);
 
 int ps3_repository_read_bus_num_dev(unsigned int bus_index,
 	unsigned int *num_dev)
@@ -212,6 +214,7 @@ int ps3_repository_read_bus_num_dev(unsi
 	*num_dev = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_num_dev);
 
 int ps3_repository_read_dev_str(unsigned int bus_index,
 	unsigned int dev_index, const char *dev_str, u64 *value)
@@ -239,6 +242,7 @@ int ps3_repository_read_dev_id(unsigned 
 	*dev_id = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_id);
 
 int ps3_repository_read_dev_type(unsigned int bus_index,
 	unsigned int dev_index, enum ps3_dev_type *dev_type)
@@ -255,6 +259,7 @@ int ps3_repository_read_dev_type(unsigne
 	*dev_type = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_type);
 
 int ps3_repository_read_dev_intr(unsigned int bus_index,
 	unsigned int dev_index, unsigned int intr_index,
@@ -274,6 +279,7 @@ int ps3_repository_read_dev_intr(unsigne
 	*interrupt_id = v2;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_intr);
 
 int ps3_repository_read_dev_reg_type(unsigned int bus_index,
 	unsigned int dev_index, unsigned int reg_index,
@@ -513,6 +519,31 @@ int ps3_repository_dump_bus_info(void)
 }
 #endif /* defined(DEBUG) */
 
+int ps3_repository_find_bus(enum ps3_bus_type bus_type, unsigned int from,
+	unsigned int *bus_index)
+{
+	unsigned int i;
+	enum ps3_bus_type type;
+	int error;
+
+	for (i = from; i < 10; i++) {
+		error = ps3_repository_read_bus_type(i, &type);
+		if (error) {
+			pr_debug("%s:%d read_bus_type failed\n",
+				__func__, __LINE__);
+			*bus_index = UINT_MAX;
+			return error;
+		}
+		if (type == bus_type) {
+			*bus_index = i;
+			return 0;
+		}
+	}
+	*bus_index = UINT_MAX;
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(ps3_repository_find_bus);
+
 static int find_device(unsigned int bus_index, unsigned int num_dev,
 	unsigned int start_dev_index, enum ps3_dev_type dev_type,
 	struct ps3_repository_device *dev)
@@ -541,7 +572,7 @@ static int find_device(unsigned int bus_
 	}
 
 	if (dev_index == num_dev)
-		return -1;
+		return -ENODEV;
 
 	pr_debug("%s:%d: found dev_type %u at dev_index %u\n",
 		__func__, __LINE__, dev_type, dev_index);
@@ -577,25 +608,14 @@ int ps3_repository_find_device (enum ps3
 
 	BUG_ON(start_dev && start_dev->bus_index > 10);
 
-	for (bus_index = start_dev ? start_dev->bus_index : 0; bus_index < 10;
-		bus_index++) {
-		enum ps3_bus_type x;
-
-		result = ps3_repository_read_bus_type(bus_index, &x);
-
-		if (result) {
-			pr_debug("%s:%d read_bus_type failed\n",
-				__func__, __LINE__);
-			dev->bus_index = UINT_MAX;
-			return result;
-		}
-		if (x == bus_type)
-			break;
+	result = ps3_repository_find_bus(bus_type,
+					 start_dev ? start_dev->bus_index : 0,
+					 &bus_index);
+	if (result) {
+		dev->bus_index = UINT_MAX;
+		return result;
 	}
 
-	if (bus_index >= 10)
-		return -ENODEV;
-
 	pr_debug("%s:%d: found bus_type %u at bus_index %u\n",
 		__func__, __LINE__, bus_type, bus_index);
 
@@ -630,6 +650,7 @@ int ps3_repository_find_device (enum ps3
 
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_find_device);
 
 int ps3_repository_find_interrupt(const struct ps3_repository_device *dev,
 	enum ps3_interrupt_type intr_type, unsigned int *interrupt_id)
@@ -668,6 +689,7 @@ int ps3_repository_find_interrupt(const 
 
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_find_interrupt);
 
 int ps3_repository_find_reg(const struct ps3_repository_device *dev,
 	enum ps3_reg_type reg_type, u64 *bus_addr, u64 *len)
@@ -949,6 +971,7 @@ int ps3_repository_read_boot_dat_address
 		0,
 		address, 0);
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_stor_dev_info);
 
 int ps3_repository_read_boot_dat_size(unsigned int *size)
 {
@@ -1015,6 +1038,7 @@ int ps3_repository_read_tb_freq(u64 node
 		0,
 		tb_freq, 0);
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_stor_dev_region);
 
 int ps3_repository_read_be_tb_freq(unsigned int be_index, u64 *tb_freq)
 {
--- a/arch/powerpc/platforms/ps3/setup.c
+++ b/arch/powerpc/platforms/ps3/setup.c
@@ -99,7 +99,9 @@ static void ps3_panic(char *str)
 	while(1);
 }
 
-#ifdef CONFIG_FB_PS3
+#if defined(CONFIG_FB_PS3) || defined(CONFIG_PS3_FLASH) || \
+    defined(CONFIG_PS3_FLASH_MODULE) || defined(CONFIG_PS3_STORAGE_OLD) || \
+    defined(CONFIG_PS3_STORAGE_MODULE_OLD)
 static void prealloc(struct ps3_prealloc *p)
 {
 	if (!p->size)
@@ -115,6 +117,7 @@ static void prealloc(struct ps3_prealloc
 	printk(KERN_INFO "%s: %lu bytes at %p\n", p->name, p->size,
 	       p->address);
 }
+#endif
 
 struct ps3_prealloc ps3fb_videomemory = {
     .name = "ps3fb videomemory",
@@ -137,6 +140,19 @@ early_param("ps3fb", early_parse_ps3fb);
 #define prealloc_ps3fb_videomemory()	do { } while (0)
 #endif
 
+#if defined(CONFIG_PS3_FLASH) || defined(CONFIG_PS3_FLASH_MODULE) || \
+    defined(CONFIG_PS3_STORAGE_OLD) || defined(CONFIG_PS3_STORAGE_OLD_MODULE)
+struct ps3_prealloc ps3flash_bounce_buffer = {
+	.name = "ps3flash bounce buffer",
+	.size = 256*1024,
+	.align = 256*1024
+};
+EXPORT_SYMBOL_GPL(ps3flash_bounce_buffer);
+#define prealloc_ps3flash_bounce_buffer()	prealloc(&ps3flash_bounce_buffer)
+#else
+#define prealloc_ps3flash_bounce_buffer()	do { } while (0)
+#endif
+
 static int ps3_set_dabr(u64 dabr)
 {
 	enum {DABR_USER = 1, DABR_KERNEL = 2,};
@@ -166,6 +182,8 @@ static void __init ps3_setup_arch(void)
 #endif
 
 	prealloc_ps3fb_videomemory();
+	prealloc_ps3flash_bounce_buffer();
+
 	ppc_md.power_save = ps3_power_save;
 
 	DBG(" <- %s:%d\n", __func__, __LINE__);
--- a/arch/powerpc/platforms/ps3/system-bus.c
+++ b/arch/powerpc/platforms/ps3/system-bus.c
@@ -670,7 +670,7 @@ static int ps3_dma_supported(struct devi
 	return mask >= DMA_32BIT_MASK;
 }
 
-struct dma_mapping_ops ps3_sb_dma_ops = {
+static struct dma_mapping_ops ps3_sb_dma_ops = {
 	.alloc_coherent = ps3_alloc_coherent,
 	.free_coherent = ps3_free_coherent,
 	.map_single = ps3_sb_map_single,
@@ -679,9 +679,8 @@ struct dma_mapping_ops ps3_sb_dma_ops = 
 	.unmap_sg = ps3_sb_unmap_sg,
 	.dma_supported = ps3_dma_supported
 };
-EXPORT_SYMBOL(ps3_sb_dma_ops);
 
-struct dma_mapping_ops ps3_ioc0_dma_ops = {
+static struct dma_mapping_ops ps3_ioc0_dma_ops = {
 	.alloc_coherent = ps3_alloc_coherent,
 	.free_coherent = ps3_free_coherent,
 	.map_single = ps3_ioc0_map_single,
@@ -690,7 +689,6 @@ struct dma_mapping_ops ps3_ioc0_dma_ops 
 	.unmap_sg = ps3_ioc0_unmap_sg,
 	.dma_supported = ps3_dma_supported
 };
-EXPORT_SYMBOL(ps3_ioc0_dma_ops);
 
 /**
  * ps3_system_bus_release_device - remove a device from the system bus
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -453,6 +453,34 @@ config ATA_OVER_ETH
 	This driver provides Support for ATA over Ethernet block
 	devices like the Coraid EtherDrive (R) Storage Blade.
 
+config PS3_STORAGE_OLD
+       tristate "Support PS3 internal HDD/CDROM drives"
+       depends on PPC_PS3 && BLK_DEV_SD && BLK_DEV_SR
+       help
+       This driver provides support for internal HDD/CD-ROM drives
+       controlled under PS3 hypervisor storage system.
+
+config PS3_STORAGE_EXPECTED_NUM_DRIVES
+       int "Number of expected storage drives"
+       depends on PS3_STORAGE_OLD
+       default "3"
+       help
+         This specifies number of expected numbers of internal
+         storage drives.  The PS3 storage driver waits for
+         this number of drives are reported ready by the
+         hypervisor.
+
+config PS3_STORAGE_MAX_SPINUP_WAIT_TIME
+       int "Maximum time of wait time"
+       depends on PS3_STORAGE_OLD
+       default "10"
+       help
+         This specifies maximum time to wait for storage
+         drive readiness.  If only less drives than
+         PS3_STORAGE_EXPECTED_NUM_DRIVES become ready
+         until this time expired,  the PS3 storage driver
+         stop to wait and continue to run with available
+         drives.
 endmenu
 
 endif
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -28,4 +28,6 @@ obj-$(CONFIG_BLK_DEV_CRYPTOLOOP) += cryp
 obj-$(CONFIG_VIODASD)		+= viodasd.o
 obj-$(CONFIG_BLK_DEV_SX8)	+= sx8.o
 obj-$(CONFIG_BLK_DEV_UB)	+= ub.o
+obj-$(CONFIG_PS3_STORAGE_OLD)	+= ps3_storage.o
 
+obj-$(CONFIG_PS3_DISK)		+= ps3disk.o
--- /dev/null
+++ b/drivers/block/ps3_storage.c
@@ -0,0 +1,2753 @@
+/*
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * Copyright 2006, 2007 Sony Corporation
+ * storage support for PS3
+ *
+ * based on scsi_debug.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/blkdev.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/rwsem.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <linux/cdrom.h>
+#include <asm/lv1call.h>
+#include <asm/abs_addr.h>
+#include <asm/ps3.h>
+#include "ps3_storage.h"
+
+#undef _DEBUG
+#if defined(_DEBUG)
+#define DPRINTK(x...) printk(x)
+#else
+#define DPRINTK(x...) do {} while(0)
+#endif
+
+#undef _DEBUG_CALLTREE
+#if defined(_DEBUG_CALLTREE)
+static int func_level;
+#define FUNC_START     printk(KERN_ERR "%s:%d start\n", __FUNCTION__, func_level++)
+#define FUNC_STEP_C(x) printk(KERN_ERR "%s:%d step %s\n", __FUNCTION__, func_level, x)
+#define FUNC_END       printk(KERN_ERR "%s:%d end\n", __FUNCTION__, --func_level)
+#define FUNC_END_C(x)  printk(KERN_ERR "%s:%d end %s\n", __FUNCTION__, --func_level, x)
+#else
+#define FUNC_START     do {} while(0)
+#define FUNC_END       FUNC_START
+#define FUNC_STEP_C(x) FUNC_START
+#define FUNC_END_C(x)  FUNC_START
+#endif
+
+#define FLASH_ALIGN    (0x00040000) /* flash safe write size (256KB); should be powers of 2 */
+
+static int ps3_stor_add_host = 2;
+static int ps3_stor_wait_time = CONFIG_PS3_STORAGE_MAX_SPINUP_WAIT_TIME;
+static int ps3_stor_wait_num_storages = CONFIG_PS3_STORAGE_EXPECTED_NUM_DRIVES + 1;
+
+#define CEIL_ALIGN_16M(mem)  ((((mem - 1) >> 24) + 1 ) << 24) /* 2^24=16M */
+#define CEIL_ALIGN_1M(mem)   ((((mem - 1) >> 20) + 1 ) << 20) /* 2^20=1M */
+#define CEIL_ALIGN_64K(mem)  ((((mem - 1) >> 16) + 1 ) << 16) /* 2^16=64K */
+#define CEIL_ALIGN_4K(mem)   ((((mem - 1) >> 12) + 1 ) << 12) /* 2^12=4K */
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PS3 storage driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(PS3_STOR_VERSION);
+
+module_param_named(wait_num_storages, ps3_stor_wait_num_storages, int, 0);
+module_param_named(wait_time, ps3_stor_wait_time, int, 0);
+MODULE_PARM_DESC(wait_num_storages, "Number of expected (wanted) drives to wait spin up (default=3 drives)");
+MODULE_PARM_DESC(wait_time, "Maximum time to wait spinup (default=10sec)");
+
+static struct ps3_stor_lv1_bus_info ps3_stor_lv1_bus_info_array[PS3_STORAGE_NUM_OF_BUS_TYPES];
+
+static struct ps3_stor_lv1_dev_info * ps3_stor_lv1_dev_info_array;
+static int ps3_stor_lv1_devnum ; /* number of configured(used) lv1 devices */
+
+static LIST_HEAD(ps3_stor_host_list);
+static DEFINE_SPINLOCK(ps3_stor_host_list_lock);
+
+static u64 ps3_stor_virtual_to_lpar(struct ps3_stor_dev_info *dev_info,
+				    void *va);
+
+/*
+ * fill buf with MODE SENSE page 8 (caching parameter)
+ * changable: 0 fills current value, otherwise fills 0
+ * returns length of this page
+ */
+const static unsigned char page_data_6[] =
+{
+	0x06,    2, /* page 6, length =2                         */
+	0x01,       /* 0: write cache disabled                   */
+	0x00        /* reserved                                  */
+};
+const static unsigned char page_data_8[] =
+{
+	0x08,   10, /* page 8, length =10                        */
+	0x04,       /* 0:read cache, 1:mult factor, 2:write cache*/
+	0x00,       /* 0..3:write retantion, 4..7:read retantion */
+	0xff, 0xff, /* disable prefech block length              */
+	0x00, 0x00, /* minimum prefech                           */
+	0xff, 0xff, /* maximum prefech                           */
+	0xff, 0xff  /* maximum prefech ceiling                   */
+};
+
+/*
+ * returns 0: decoded
+ *        -1: not sense info, issue REQUEST_SENSE needed
+ */
+static int decode_lv1_status(u64 status, unsigned char * sense_key,
+			     unsigned char * asc, unsigned char * ascq)
+{
+	if (((status >> 24) & 0xff) != 0x02)
+		return -1;
+
+	*sense_key = (status >> 16) & 0xff;
+	*asc       = (status >>  8) & 0xff;
+	*ascq      =  status        & 0xff;
+	return 0;
+}
+
+
+static void ps3_stor_srb_done(struct ps3_stor_dev_info * dev_info)
+{
+	struct scsi_cmnd * srb = dev_info->srb;
+	unsigned long flags;
+
+	spin_lock_irqsave(&(dev_info->srb_lock), flags);
+	{
+		dev_info->srb = NULL;
+		srb->scsi_done(srb);
+	}
+	spin_unlock_irqrestore(&(dev_info->srb_lock), flags);
+}
+
+static void ps3_stor_process_srb(struct scsi_cmnd * srb)
+{
+	struct ps3_stor_dev_info * dev_info;
+	int (*command_handler)(struct ps3_stor_dev_info *, struct scsi_cmnd *);
+
+	dev_info = (struct ps3_stor_dev_info*) srb->device->hostdata;
+	command_handler = dev_info->handler_info[srb->cmnd[0]].cmnd_handler;
+
+	if (command_handler) {
+		(*command_handler)(dev_info, srb);
+	} else {
+		srb->result = (DID_ERROR << 16);
+		memset(srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		srb->sense_buffer[0] = 0x70;
+		srb->sense_buffer[2] = ILLEGAL_REQUEST;
+		ps3_stor_srb_done(dev_info);
+	}
+}
+
+/*
+ * main thread to process srb.
+ * thread is created per device basis.
+ * srb are often passed in interrupt context (softirq), so
+ * we can't sleep at queuecommand().  just receive it
+ * at queucommand(), then passed it to other thread
+ * to process it under non-interrupt context.
+ */
+static int ps3_stor_main_thread(void * parm)
+{
+	struct ps3_stor_dev_info * dev_info = (struct ps3_stor_dev_info *)parm;
+	int reason = 0;
+
+	current->flags |= PF_NOFREEZE; /* jugemu jugemu */
+
+	while (!reason) {
+		down_interruptible(&(dev_info->thread_sema));
+		switch (dev_info->thread_wakeup_reason) {
+		case SRB_QUEUED:
+			ps3_stor_process_srb(dev_info->srb);
+			break;
+		case THREAD_TERMINATE:
+			reason =  THREAD_TERMINATE;
+			break;
+		default:
+			printk(KERN_ERR "%s: unknown wakeup reason %d\n", __FUNCTION__,
+			       dev_info->thread_wakeup_reason);
+			break;
+		}
+	}
+
+	complete_and_exit(&(dev_info->thread_terminated), reason);
+}
+
+/*
+ * copy data from device into scatter/gather buffer
+ */
+static int fill_from_dev_buffer(struct scsi_cmnd * srb,
+				const unsigned char * arr,
+				int arr_len)
+{
+	int k, req_len, act_len, len, active;
+	void * kaddr;
+	void * kaddr_off;
+	struct scatterlist * sgpnt;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return (DID_ERROR << 16);
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_FROM_DEVICE)))
+		return (DID_ERROR << 16);
+	if (0 == srb->use_sg) {
+		req_len = srb->request_bufflen;
+		act_len = (req_len < arr_len) ? req_len : arr_len;
+		memcpy(srb->request_buffer, arr, act_len);
+		srb->resid = req_len - act_len;
+		return 0;
+	}
+	sgpnt = (struct scatterlist *)srb->request_buffer;
+	active = 1;
+	for (k = 0, req_len = 0, act_len = 0; k < srb->use_sg; ++k, ++sgpnt) {
+		if (active) {
+			kaddr = kmap_atomic(sgpnt->page, KM_USER0);
+			if (NULL == kaddr)
+				return (DID_ERROR << 16);
+			kaddr_off = kaddr + sgpnt->offset;
+			len = sgpnt->length;
+			if ((req_len + len) > arr_len) {
+				active = 0;
+				len = arr_len - req_len;
+			}
+			memcpy(kaddr_off, arr + req_len, len);
+			kunmap_atomic(kaddr, KM_USER0);
+			act_len += len;
+		}
+		req_len += sgpnt->length;
+	}
+	srb->resid = req_len - act_len;
+	return 0;
+}
+
+/*
+ * copy data from scatter/gather into device's buffer
+ */
+static int fetch_to_dev_buffer(struct scsi_cmnd * srb,
+			       unsigned char * arr,
+			       int max_arr_len)
+{
+	int k, req_len, len, fin;
+	void * kaddr;
+	void * kaddr_off;
+	struct scatterlist * sgpnt;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return -1;
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_TO_DEVICE)))
+		return -1;
+	if (0 == srb->use_sg) {
+		req_len = srb->request_bufflen;
+		len = (req_len < max_arr_len) ? req_len : max_arr_len;
+		memcpy(arr, srb->request_buffer, len);
+		return len;
+	}
+
+	sgpnt = (struct scatterlist *)srb->request_buffer;
+	for (k = 0, req_len = 0, fin = 0; k < srb->use_sg; ++k, ++sgpnt) {
+		kaddr = kmap_atomic(sgpnt->page, KM_USER0);
+		if (NULL == kaddr)
+			return -1;
+		kaddr_off = kaddr + sgpnt->offset;
+		len = sgpnt->length;
+		if ((req_len + len) > max_arr_len) {
+			len = max_arr_len - req_len;
+			fin = 1;
+		}
+		memcpy(arr + req_len, kaddr_off, len);
+		kunmap_atomic(kaddr, KM_USER0);
+		if (fin)
+			return req_len + len;
+		req_len += sgpnt->length;
+	}
+	return req_len;
+}
+
+/*
+ * copy data into device buffer to write.
+ * byte offset 'from' until byte offset 'to'
+ * data always copied into 'arr'
+ */
+static off_t fetch_to_dev_buffer_abs(struct scsi_cmnd * srb,
+				     unsigned char * arr,
+				     off_t from,
+				     off_t to)
+{
+	int i, fin;
+	void * kaddr;
+	void * kaddr_off;
+	off_t cur_pos, end_pos, start_pos, len;
+	struct scatterlist * sg;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return -1;
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_TO_DEVICE)))
+		return -1;
+	if (to < from)
+		return -1;
+
+	DPRINTK(KERN_ERR "%s: from=%#lx(%ld) to=%#lx(%ld) sg=%d\n", __FUNCTION__,
+		from, from , to, to, srb->use_sg);
+
+	if (0 == srb->use_sg) {
+		len = (srb->request_bufflen < to) ? (srb->request_bufflen - from) : (to - from);
+		memcpy(arr, srb->request_buffer + from, len);
+		return len;
+	}
+
+
+	len = 0;
+	sg = (struct scatterlist *)srb->request_buffer;
+	for (i = 0, cur_pos = 0, fin = 0;
+	     (i < srb->use_sg) && !fin;
+	     cur_pos += sg->length, i++, sg++) {
+		kaddr = kmap_atomic(sg->page, KM_USER0);
+		kaddr_off = kaddr + sg->offset;
+
+		//DPRINTK(KERN_ERR "%s: cur_pos=%ld, sglen=%d kadoff=%p\n", __FUNCTION__,
+		//cur_pos, sg->length, kaddr_off);
+		if (NULL == kaddr)
+			return -1;
+
+		if (from <= cur_pos) {
+			start_pos = cur_pos;
+		}  else {
+			if (from < (cur_pos + sg->length)) {
+				/* copy start with middle of this segment */
+				start_pos = from;
+				kaddr_off += from - start_pos;
+			} else {
+				/* this segment does not have any desired data */
+				kunmap_atomic(kaddr, KM_USER0);
+				continue;
+			}
+		}
+
+		if (to < (cur_pos + sg->length)) {
+			/* copy end with middle of this segment */
+			end_pos = to;
+			fin = 1;
+		} else {
+			end_pos = cur_pos + sg->length;
+		}
+
+		if (start_pos < end_pos) {
+			//DPRINTK(KERN_ERR "%s: COPY start=%ld end=%ld kaddoff=%p\n", __FUNCTION__,
+			//start_pos, end_pos, kaddr_off);
+			memcpy(arr + len, kaddr_off, end_pos - start_pos);
+			len += end_pos - start_pos;
+		}
+		kunmap_atomic(kaddr, KM_USER0);
+
+	}
+	DPRINTK(KERN_ERR "%s: return ren=%ld\n", __FUNCTION__, len);
+	return len;
+}
+
+
+/*
+ * issue PACKET command according to passed SRB
+ * caller will block until the command completed.
+ * returns 0 if command sucessfully done,
+ * otherwise error detected.
+ * if auto_sense is on, request_sense is automatically issued and
+ * return the sense data into srb->sensebuffer[SCSI_SENSE_BUFFERSIZE]
+ * srb->result will be set.
+ * caller should call done(srb) to inform mid layer the command completed.
+ */
+static int issue_atapi_by_srb(struct ps3_stor_dev_info * dev_info,
+			      int auto_sense)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	struct lv1_atapi_cmnd_block atapi_cmnd;
+	const struct scsi_command_handler_info * handler_info;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+	int bounce_len = 0;
+	int error;
+	unsigned char keys[4];
+
+	handler_info = &(dev_info->handler_info[cmnd[0]]);
+
+	/* check buffer size */
+	switch (handler_info->buflen) {
+	case USE_SRB_6:
+		bounce_len = cmnd[4];
+		break;
+	case USE_SRB_10:
+ 		bounce_len = (cmnd[7] << 8) | cmnd[8];
+		break;
+	case USE_CDDA_FRAME_RAW:
+		bounce_len = ((cmnd[6] << 16) |
+		       (cmnd[7] <<  8) |
+		       (cmnd[8] <<  0)) * CD_FRAMESIZE_RAW;
+		break;
+	default:
+		bounce_len = handler_info->buflen;
+	}
+
+	if (dev_info->dedicated_bounce_size < bounce_len ) {
+		static int printed;
+		if (!printed++)
+			printk(KERN_ERR "%s: data size too large %#x<%#x\n",
+			       __FUNCTION__,
+			       dev_info->dedicated_bounce_size,
+			       bounce_len);
+		dev_info->srb->result = DID_ERROR << 16;
+		memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		dev_info->srb->sense_buffer[0] = 0x70;
+		dev_info->srb->sense_buffer[2] = ILLEGAL_REQUEST;
+		return -1;
+	}
+
+	memset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));
+	memcpy(&(atapi_cmnd.pkt), cmnd, 12);
+	atapi_cmnd.pktlen = 12;
+	atapi_cmnd.proto = handler_info->proto;
+	if (handler_info->in_out != DIR_NA)
+		atapi_cmnd.in_out = handler_info->in_out;
+
+	if (atapi_cmnd.in_out == DIR_WRITE)
+		fetch_to_dev_buffer(dev_info->srb, dev_info->bounce_buf, bounce_len);
+
+	atapi_cmnd.block_size = 1; /* transfer size is block_size * blocks */
+
+	atapi_cmnd.blocks = atapi_cmnd.arglen = bounce_len;
+	atapi_cmnd.buffer = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+
+	/* issue command */
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+						LV1_STORAGE_SEND_ATAPI_COMMAND,
+						ps3_mm_phys_to_lpar(__pa(&atapi_cmnd)),
+						sizeof(struct lv1_atapi_cmnd_block),
+						atapi_cmnd.buffer,
+						atapi_cmnd.arglen,
+						&lv1_dev_info->current_tag);
+	if (error) {
+		printk(KERN_ERR "%s: send_device failed lv1dev=%u ret=%d\n",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code ? */
+		return -1;
+	}
+
+	/* wait interrupt */
+	wait_for_completion(&(dev_info->irq_done));
+
+	/* check error */
+	if (!dev_info->lv1_status) {
+		/* OK, completed */
+		if (atapi_cmnd.in_out == DIR_READ)
+			fill_from_dev_buffer(dev_info->srb, dev_info->bounce_buf, bounce_len);
+		dev_info->srb->result = DID_OK << 16;
+		return 0;
+	}
+
+	/* error */
+	if (!auto_sense) {
+		dev_info->srb->result = (DID_ERROR << 16) | (CHECK_CONDITION << 1);
+		printk(KERN_ERR "%s: end error withtout autosense\n", __FUNCTION__);
+		return 1;
+	}
+
+	if (!decode_lv1_status(dev_info->lv1_status,
+			       &(keys[0]), &(keys[1]), &(keys[2]))) {
+		/* lv1 may have issued autosense ... */
+		dev_info->srb->sense_buffer[0]  = 0x70;
+		dev_info->srb->sense_buffer[2]  = keys[0];
+		dev_info->srb->sense_buffer[7]  = 16 - 6;
+		dev_info->srb->sense_buffer[12] = keys[1];
+		dev_info->srb->sense_buffer[13] = keys[2];
+		dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+	} else {
+		/* do auto sense by our selves*/
+		memset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));
+		atapi_cmnd.pkt[0] = REQUEST_SENSE;
+		atapi_cmnd.pkt[4] = 18;
+		atapi_cmnd.pktlen = 12;
+		atapi_cmnd.arglen = atapi_cmnd.blocks = atapi_cmnd.pkt[4];
+		atapi_cmnd.block_size = 1;
+		atapi_cmnd.proto = DMA_PROTO;
+		atapi_cmnd.in_out = DIR_READ;
+		atapi_cmnd.buffer = ps3_stor_virtual_to_lpar(dev_info,dev_info->bounce_buf);
+
+		/* issue REQUEST_SENSE command */
+		init_completion(&(dev_info->irq_done));
+		error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+							LV1_STORAGE_SEND_ATAPI_COMMAND,
+							ps3_mm_phys_to_lpar(__pa(&atapi_cmnd)),
+							sizeof(struct lv1_atapi_cmnd_block),
+							atapi_cmnd.buffer,
+							atapi_cmnd.arglen,
+							&lv1_dev_info->current_tag);
+		if (error) {
+			printk(KERN_ERR "%s: send_device for request sense failed lv1dev=%u ret=%d\n", __FUNCTION__,
+			       lv1_dev_info->repo.did.dev_id, error);
+			dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code ? */
+			return -1;
+		}
+
+		/* wait interrupt */
+		wait_for_completion(&(dev_info->irq_done));
+
+		/* scsi spec says request sense should never get error */
+		if (dev_info->lv1_status) {
+			decode_lv1_status(dev_info->lv1_status,
+					  &(keys[0]), &(keys[1]), &(keys[2]));
+			printk(KERN_ERR "%s: auto REQUEST_SENSE error %#x %#x %#x\n", __FUNCTION__,
+			       keys[0], keys[1], keys[2]);
+		}
+
+		memcpy(dev_info->srb->sense_buffer, dev_info->bounce_buf,
+		       min((int)atapi_cmnd.pkt[4], SCSI_SENSE_BUFFERSIZE));
+		dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+	}
+
+	return 1;
+}
+
+/*
+ * just send command with auto REQUEST_SENSE
+ */
+static int ps3_stor_atapi_handle_simple(struct ps3_stor_dev_info * dev_info,
+				        struct scsi_cmnd * srb)
+{
+	int ret;
+
+	ret = issue_atapi_by_srb(dev_info, 1);
+	ps3_stor_srb_done(dev_info);
+	return ret;
+}
+
+/*
+ * just send command WITHOUT auto REQUEST_SENSE
+ */
+static int ps3_stor_atapi_handle_request_sense(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	int ret;
+
+	ret = issue_atapi_by_srb(dev_info, 0);
+	ps3_stor_srb_done(dev_info);
+	return ret;
+}
+
+/******************************************************
+ * handlers for HDD
+ */
+
+static int ps3_stor_hdd_handle_inquiry(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char inquiry_reply[PS3_STOR_MAX_INQUIRY_DATA_SIZE];
+	unsigned char *cmd = srb->cmnd;
+	const char * msg;
+	int alloc_len;
+	int ret;
+
+	FUNC_START;
+	alloc_len = (cmd[3] << 8) + cmd[4];
+	memset(inquiry_reply, 0, PS3_STOR_MAX_INQUIRY_DATA_SIZE);
+	inquiry_reply[0] = lv1_dev_info->device_type;
+	inquiry_reply[1] = 0;  /* Removable flag */
+	inquiry_reply[2] = 2;  /* ANSI version */
+	inquiry_reply[3] = 2;  /* response_data_format==2 */
+	inquiry_reply[4] = PS3_STOR_INQUIRY_DATA_SIZE - 5;
+
+	sprintf(&inquiry_reply[8], "%-8s", "SCEI");
+	if (lv1_dev_info->device_type == PS3_DEV_TYPE_STOR_DISK) {
+		switch (lv1_dev_info->attached_port) {
+		case 0:
+			msg = "Pri:Master";
+			break;
+		case 1:
+			msg = "Pri:Slave";
+			break;
+		case 2:
+			msg = "Sec:Master";
+			break;
+		case 3:
+			msg = "Sec:Slave";
+			break;
+		default:
+			msg = "Unknown";
+			break;
+
+		}
+	} else {
+		msg = "Flash";
+	}
+
+	/* SCSI spec requires model name left aligned, spece padded */
+	ret = sprintf(&inquiry_reply[16], "%s-%d", msg,
+		      lv1_dev_info->region_info_array[srb->cmnd[1]>>5].region_index);
+	if (ret < 16)
+		memset(&(inquiry_reply[16 + ret]), ' ', 16 - ret);
+
+	sprintf(&inquiry_reply[32], "%-4d", 4989);
+
+	inquiry_reply[58] = 0x0; inquiry_reply[59] = 0x40; /* SAM-2 */
+	inquiry_reply[60] = 0x3; inquiry_reply[61] = 0x0;  /* SPC-3 */
+	inquiry_reply[62] = 0x1; inquiry_reply[63] = 0x80; /* SBC */
+
+	ret = fill_from_dev_buffer(dev_info->srb, inquiry_reply, min(alloc_len, PS3_STOR_INQUIRY_DATA_SIZE));
+
+	srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	FUNC_END;
+	return ret;
+}
+
+
+static int ps3_stor_hdd_handle_request_sense(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	unsigned char sense_data[PS3_STOR_SENSE_LEN];
+	int len = 18;
+
+	memset(sense_data, 0, PS3_STOR_SENSE_LEN);
+
+	if (dev_info->lv1_status) {
+		if (!decode_lv1_status(dev_info->lv1_status,
+				       &(sense_data[2]),
+				       &(sense_data[12]),
+				       &(sense_data[13]))) {
+		} else {
+			/* unknown error */
+			printk(KERN_ERR "%s: FIXME issue real RS %#lx %d\n",
+			       __FUNCTION__, dev_info->lv1_status,
+			       dev_info->lv1_retval);
+			sense_data[2] = HARDWARE_ERROR;
+			dev_info->srb->result = DID_OK << 16;
+		}
+		sense_data[0] = 0x70;
+	} else {
+		/* no sense */
+		sense_data[0] = 0x70;
+		dev_info->srb->result = DID_OK << 16;
+	}
+
+	fill_from_dev_buffer(dev_info->srb, sense_data, len);
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_just_ok(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	dev_info->srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_sync_cache(struct ps3_stor_dev_info * dev_info,
+					  struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char keys[4];
+	int error;
+
+	/* issue command */
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+						LV1_STORAGE_ATA_HDDOUT,
+						0,
+						0,
+						0,
+						0,
+						&lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: send_device failed. lv1dev=%u ret=%d\n",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code? */
+	} else {
+		/* wait interrupt */
+		wait_for_completion(&(dev_info->irq_done));
+
+		/* check error */
+		if (!dev_info->lv1_status) {
+			dev_info->srb->result = DID_OK << 16;
+		} else {
+			decode_lv1_status(dev_info->lv1_status,
+					  &(keys[0]), &(keys[1]), &(keys[2]));
+			dev_info->srb->sense_buffer[0]  = 0x70;
+			dev_info->srb->sense_buffer[2]  = keys[0];
+			dev_info->srb->sense_buffer[7]  = 16 - 6;
+			dev_info->srb->sense_buffer[12] = keys[1];
+			dev_info->srb->sense_buffer[13] = keys[2];
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+		}
+	}
+
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_read_capacity(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char data[PS3_STOR_READCAP_DATA_SIZE];
+	u64 len;
+	int ret;
+
+	FUNC_START;
+	memset(data, 0, sizeof(data));
+	len = lv1_dev_info->region_info_array[srb->cmnd[1] >> 5].region_size - 1;
+	data[0] = (len >> 24) & 0xff;
+	data[1] = (len >> 16) & 0xff;
+	data[2] = (len >> 8)  & 0xff;
+	data[3] =  len        & 0xff;
+
+	len = lv1_dev_info->sector_size;
+	data[4] = (len >> 24) & 0xff;
+	data[5] = (len >> 16) & 0xff;
+	data[6] = (len >> 8)  & 0xff;
+	data[7] =  len        & 0xff;
+
+	ret = fill_from_dev_buffer(dev_info->srb, data, PS3_STOR_READCAP_DATA_SIZE);
+	dev_info->srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	FUNC_END;
+	return ret;
+}
+
+
+static int copy_page_data(unsigned char * buf, const unsigned char * data,
+			   int length, int changable)
+{
+	if (changable) {
+		/* reports no parameters are changable */
+		memcpy(buf, data, 2);
+		memset(buf + 2, 0, length - 2);
+	} else {
+		memcpy(buf, data, length);
+	}
+	return length;
+}
+
+static int fill_mode_page(struct ps3_stor_dev_info * dev_info,
+			  unsigned char *buf, int page, int changable)
+{
+	int length;
+
+	switch (page){
+	case 8:
+		/* TYPE_DISK; see sd_read_cache_type():sd.c */
+		length = copy_page_data(buf, page_data_8, sizeof(page_data_8), changable);
+		break;
+	case 6:
+		/* TYPE_RBC */
+		length = copy_page_data(buf, page_data_6, sizeof(page_data_6), changable);
+		break;
+	case 0x3f: /* ALL PAGES, but sd.c checks only parameter header to see WriteProtect */
+		length  = copy_page_data(buf, page_data_6, sizeof(page_data_6), changable);
+		length += copy_page_data(buf + length, page_data_8, sizeof(page_data_8), changable);
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown page=%#x\n", __FUNCTION__, page);
+		return 0;
+	}
+
+	return length;
+}
+
+/*
+ * scsi disk driver asks only PAGE= 0x3f, 6(RBC), 8(SCSI disk)
+ */
+static int ps3_stor_hdd_handle_mode_sense(struct ps3_stor_dev_info * dev_info,
+					  struct scsi_cmnd * srb)
+{
+	unsigned char sense_data[128];
+	int offset = 0;
+
+	/*
+	 * NOTE: support MODE_SENSE_10 only
+	 * see slave_cofigure()
+	 */
+	memset(sense_data, 0, sizeof(sense_data));
+	/* parameter header */
+	sense_data[2] = dev_info->lv1_dev_info->device_type;
+	sense_data[3] = 0;      /* mid layer wants to see here     */
+	/* bit 7=1 means WriteProtected    */
+	offset = fill_mode_page(dev_info,
+				&(sense_data[8]),
+				dev_info->srb->cmnd[2] & 0x3f,
+				dev_info->srb->cmnd[2] & 0xc0);
+	sense_data[1] = offset + 8;        /* parameter length */
+	sense_data[0] = (offset + 8) >> 8;
+
+	fill_from_dev_buffer(dev_info->srb, sense_data, offset + 8);
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+
+/*
+ * convert kernel virtal address to lpar address for storage IO
+ * NOTE: va should be within allocated special buffer
+ *       if DEDICATED_SPECIAL bounce type
+ */
+static u64 ps3_stor_virtual_to_lpar(struct ps3_stor_dev_info *dev_info,
+				    void *va)
+{
+	if (unlikely(dev_info->bounce_type == DEDICATED_SPECIAL)) {
+		return dev_info->separate_bounce_lpar + (va - dev_info->bounce_buf);
+	} else {
+		return ps3_mm_phys_to_lpar(__pa(va));
+	}
+}
+
+
+static int ps3_stor_common_handle_read(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int error;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u32 sectors = 0;
+	u32 start_sector = 0;
+	unsigned char *cmnd = dev_info->srb->cmnd;
+	int ret = 0;
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case READ_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case READ_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+
+	}
+
+	/* issue read */
+	down_read(&dev_info->bounce_sem);
+	lpar_addr = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+	region_id = lv1_dev_info->region_info_array[(cmnd[1] >> 5)].region_id;
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+				 region_id,
+				 start_sector,
+				 sectors,
+				 0, /* flags */
+				 lpar_addr,
+				 &lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: error lv1dev =%u ret=%d\n", __FUNCTION__,
+		       lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+		ret = -1;
+	} else {
+		/* wait irq */
+		wait_for_completion(&(dev_info->irq_done));
+		if (dev_info->lv1_status) {
+			/* error */
+			memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+			decode_lv1_status(dev_info->lv1_status,
+					  &(dev_info->srb->sense_buffer[2]),
+					  &(dev_info->srb->sense_buffer[12]),
+					  &(dev_info->srb->sense_buffer[13]));
+			dev_info->srb->sense_buffer[7] = 16 - 6;
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+			ret =  1;
+		} else {
+			/* OK */
+			fill_from_dev_buffer(dev_info->srb,
+					     dev_info->bounce_buf,
+					     sectors * dev_info->sector_size);
+
+			dev_info->srb->result = DID_OK << 16;
+			ret =  0;
+		}
+	}
+
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static int ps3_stor_common_handle_write(struct ps3_stor_dev_info * dev_info,
+					struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int ret;
+	int error;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u32 start_sector = 0;
+	u32 sectors = 0;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case WRITE_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case WRITE_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+	}
+
+	down_read(&dev_info->bounce_sem);
+	ret = fetch_to_dev_buffer(dev_info->srb,
+				  dev_info->bounce_buf,
+				  sectors * dev_info->sector_size);
+
+	lpar_addr = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+	region_id = lv1_dev_info->region_info_array[(cmnd[1] >> 5)].region_id;
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_write(lv1_dev_info->repo.did.dev_id,
+				  region_id, /* region id */
+				  start_sector,
+				  sectors,
+				  0, /* flags */
+				  lpar_addr/*srb->request_buffer*/, /* assume non SG! */
+				  &lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n", __FUNCTION__,
+		       lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+		ret = -1;
+	} else {
+
+		/* wait irq */
+		wait_for_completion(&(dev_info->irq_done));
+
+		if (dev_info->lv1_status) {
+			/* error */
+			memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+			decode_lv1_status(dev_info->lv1_status,
+					  &(dev_info->srb->sense_buffer[2]),
+					  &(dev_info->srb->sense_buffer[12]),
+					  &(dev_info->srb->sense_buffer[13]));
+			dev_info->srb->sense_buffer[7] = 16 - 6;
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+			ret = 1;
+		} else {
+			/* OK */
+			dev_info->srb->result = DID_OK << 16;
+			ret = 0;
+		}
+
+	}
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static int is_aligned_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return (sector % flash_align_sector)? 0 : 1;
+}
+
+static u32 floor_align_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return sector & ~(flash_align_sector - 1);
+}
+
+static u32 ceil_align_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return (sector + (flash_align_sector - 1)) & ~(flash_align_sector - 1);
+}
+
+/*
+ * special handling for flash drive; do safer way to write in order to reduce
+ * the risk of flash corruption by sudden power off.
+ */
+static int ps3_stor_handle_write_flash(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int ret = 0;
+	int error;
+	u64 sector_size;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u64 start_sector = 0;
+	u64 start_sector_aligned = 0;
+	u64 sectors = 0;
+	u64 sectors_aligned = 0;
+	u64 current_sector;
+	u64 aligned_sector_count;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+	void * current_buffer;
+	struct ps3_stor_lv1_region_info * region_info;
+
+	static int align_warned;
+
+	DPRINTK(KERN_ERR "%s: start\n", __FUNCTION__);
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case WRITE_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case WRITE_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+	}
+
+
+        /*
+         *    start_sector_aligned
+         *   /          start_sector
+         *  /          /
+         * +----------+--------------------+---+
+         *            |<-    sectors     ->|   |
+         *            |<-   sectors_aligned  ->|
+         *
+         * ^-----------------------------------^ 256K align
+         */
+	sector_size = dev_info->sector_size;
+	aligned_sector_count = FLASH_ALIGN / sector_size;
+
+	start_sector_aligned = floor_align_flash(start_sector, sector_size);
+	sectors_aligned = ceil_align_flash(start_sector + sectors, sector_size) - start_sector;
+
+	/* check aligned border exceed region */
+	region_info = &lv1_dev_info->region_info_array[cmnd[1] >> 5];
+	if (!is_aligned_flash(region_info->region_start, sector_size) ||
+	    (region_info->region_size < (start_sector_aligned + sectors_aligned))) {
+		if (!align_warned) {
+			printk(KERN_ERR "%s: region alignment is not 256k, continue to work with norman method\n",
+			       __FUNCTION__);
+			align_warned = 1;
+		}
+		return ps3_stor_common_handle_write(dev_info, srb);
+	};
+
+	down_read(&dev_info->bounce_sem);
+	region_id = region_info->region_id;
+
+
+	DPRINTK(KERN_ERR "%s: start=%#lx(%ld) start_a=%#lx(%ld) sec=%#lx(%ld) sec_a=%#lx(%ld)\n", __FUNCTION__,
+		start_sector, start_sector,
+		start_sector_aligned, start_sector_aligned,
+		sectors, sectors,
+		sectors_aligned, sectors_aligned);
+
+	/*
+	 * loop in the case that the requested write sectors across
+	 * 245Kb alignment.  Since we have set max_sectors as 256kb,
+	 * loop count is up to 2.
+	 */
+	for (current_sector = start_sector_aligned, ret = 0;
+	     (current_sector < (start_sector + sectors_aligned)) && !ret;
+	     current_sector += aligned_sector_count) {
+
+		DPRINTK(KERN_ERR "%s: LOOP current=%#lx\n", __FUNCTION__, current_sector);
+
+		current_buffer = dev_info->bounce_buf;
+
+		/* read from (start_sector_aligned) to (start_sector) */
+		if (current_sector < start_sector) {
+			DPRINTK(KERN_ERR "%s: head read \n", __FUNCTION__);
+			lpar_addr = ps3_stor_virtual_to_lpar(dev_info,
+							     current_buffer);
+			init_completion(&(dev_info->irq_done));
+			error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+						 region_id,
+						 current_sector,
+						 start_sector - current_sector,
+						 0,
+						 lpar_addr,
+						 &lv1_dev_info->current_tag);
+			DPRINTK(KERN_ERR "HEAD start=%#lx, len=%#lx\n",
+				start_sector_aligned, (start_sector - start_sector_aligned));
+			if (error) {
+				/* error */
+				printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+				       __FUNCTION__,
+				       lv1_dev_info->repo.did.dev_id, error);
+				dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+				ret = -1;
+				goto done;
+			} else {
+				/* wait irq */
+				wait_for_completion(&(dev_info->irq_done));
+			}
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+				goto done;
+			} else {
+				/* OK */
+				ret = 0;
+				current_buffer += (start_sector - start_sector_aligned) * sector_size;
+			}
+		} /* head remainder */
+
+
+		if ((start_sector + sectors) < (current_sector + aligned_sector_count)) {
+			void * buf = dev_info->bounce_buf;
+			DPRINTK(KERN_ERR "%s: tail read\n", __FUNCTION__);
+			buf += (start_sector + sectors - current_sector) * sector_size;
+			lpar_addr = ps3_stor_virtual_to_lpar(dev_info, buf);
+			init_completion(&(dev_info->irq_done));
+			error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+						 region_id,
+						 start_sector + sectors,
+						 sectors_aligned - sectors,
+						 0,
+						 lpar_addr,
+						 &lv1_dev_info->current_tag);
+			DPRINTK(KERN_ERR "TAIL start=%#lx, len=%#lx\n",
+				start_sector + sectors, sectors_aligned - sectors);
+			if (error) {
+				/* error */
+				printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+				       __FUNCTION__,
+				       lv1_dev_info->repo.did.dev_id, error);
+				dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+				ret = -1;
+				goto done;
+			} else {
+				/* wait irq */
+				wait_for_completion(&(dev_info->irq_done));
+			}
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+				goto done;
+			} else {
+				/* OK */
+				ret = 0;
+			}
+		} /* tail remainder */
+
+		{
+			u64 copy_sectors_from, copy_sectors_to;
+
+			/* start_sector is within this iteration */
+			if ((current_sector < start_sector)  &&
+			    (start_sector < (current_sector + aligned_sector_count))) {
+				copy_sectors_from = start_sector;
+			}
+			else {
+				copy_sectors_from = current_sector;
+			}
+
+			/* start_sector+sectors is within this iteration */
+			if ((current_sector < (start_sector + sectors))  &&
+			    ((start_sector + sectors) < (current_sector + aligned_sector_count))) {
+				copy_sectors_to = start_sector + sectors;
+			}
+			else {
+				copy_sectors_to = current_sector + aligned_sector_count;
+			}
+
+			DPRINTK(KERN_ERR "%s: copy to current=%p\n", __FUNCTION__, current_buffer);
+			ret = fetch_to_dev_buffer_abs(dev_info->srb,
+						      current_buffer,
+						      (copy_sectors_from - start_sector) * sector_size,
+						      (copy_sectors_to - start_sector) * sector_size);
+		} /* write data */
+
+		/* write 256K */
+		DPRINTK(KERN_ERR "%s: WRITE sector=%#lx\n", __FUNCTION__, current_sector);
+		lpar_addr = ps3_stor_virtual_to_lpar(dev_info,
+						     dev_info->bounce_buf);
+		init_completion(&(dev_info->irq_done));
+		error = lv1_storage_write(lv1_dev_info->repo.did.dev_id,
+					  region_id,
+					  current_sector,
+					  aligned_sector_count,
+					  0,
+					  lpar_addr,
+					  &lv1_dev_info->current_tag);
+		if (error) {
+			/* error */
+			printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+			       __FUNCTION__, lv1_dev_info->repo.did.dev_id,
+			       error);
+			dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+			ret = -1;
+		} else {
+
+			/* wait irq */
+			wait_for_completion(&(dev_info->irq_done));
+
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+			} else {
+				/* OK */
+				dev_info->srb->result = DID_OK << 16;
+				ret = 0;
+			}
+
+		}
+	} /* for */
+ done:
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	DPRINTK(KERN_ERR "%s: end\n", __FUNCTION__);
+	return ret;
+}
+
+/*
+ * NOTE: If return 1, all buffers communicate with the device
+ *       should be in dedicated buffer area.
+ *       Currently common_handle_read, common_handle_write know this
+ *       restriction.
+ *       And should implement remap function in ps3_stor_set_max_sectors()
+ */
+static int need_dedicated_dma_region(enum ps3_dev_type device_type)
+{
+	int ret = 0;
+	switch (device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = 1; /* should be 1 */
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = 0;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret = 0;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+/*
+ * allocate static(dedicated) bounce buffer
+ */
+static int get_dedicated_buffer_type(enum ps3_dev_type device_type)
+{
+	int ret = 0;
+	switch (device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = DEDICATED_SPECIAL;
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = DEDICATED_KMALLOC;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret = DEDICATED_KMALLOC;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+
+
+extern unsigned long ps3_mem_total;
+extern unsigned long ps3_rm_limit;
+extern unsigned long ps3_2nd_mem_base;
+extern unsigned long ps3_2nd_mem_size;
+
+#define PS3_PCI_DMA_SIZE(mem) ((((mem -1) >> 27) + 1 ) << 27) /* 2^27=128M */
+#define PS3_PCI_IO_PAGESIZE      24
+
+static u64 ps3_allocate_dma_region(const struct ps3_device_id *did)
+{
+	u64 size, io_size, io_pagesize;
+	u64 dma, flg = 0;
+	int error;
+
+	io_size = PS3_PCI_DMA_SIZE(ps3_mem_total);
+	io_pagesize = PS3_PCI_IO_PAGESIZE;
+	error = lv1_allocate_device_dma_region(did->bus_id, did->dev_id,
+					       io_size, io_pagesize, flg,
+					       &dma);
+	if (error) {
+		printk("lv1_allocate_device_dma_region faild, error=%d\n",
+			error);
+		return 0;
+	}
+
+	size = ps3_rm_limit;
+	error = lv1_map_device_dma_region(did->bus_id, did->dev_id,
+					  0, /* lpar addr */
+					  dma, /* I/O addr */
+					  size,
+					  0xf800000000000000UL  /* flags */);
+	if (error) {
+		printk("lv1_map_device_dma_region faild, error=%d\n", error);
+		return 0;
+	}
+
+	size = ps3_2nd_mem_size;
+	error = lv1_map_device_dma_region(did->bus_id, did->dev_id,
+					  ps3_2nd_mem_base,   /* lpar addr */
+					  ps3_rm_limit + dma, /* I/O addr */
+					  size,
+					  0xf800000000000000UL  /* flags */);
+
+	if (error) {
+		printk("lv1_map_device_dma_region faild, error=%d\n", error);
+		return 0;
+	}
+	return dma;
+}
+
+static u64 ps3_free_dma_region(const struct ps3_device_id *did, u64 dma)
+{
+	u64 size, io_size, io_pagesize;
+	int error;
+
+	io_size = PS3_PCI_DMA_SIZE(ps3_mem_total);
+	io_pagesize = PS3_PCI_IO_PAGESIZE;
+
+	if (dma == 0)
+		return 0;
+
+	/* unmap dma_region */
+	size = ps3_rm_limit;
+	error = lv1_unmap_device_dma_region(did->bus_id, did->dev_id,
+					    dma, /* I/O addr */
+					    size);
+	if (error)
+		printk("lv1_unmap_device_dma_region faild, error=%d\n", error);
+	size = ps3_2nd_mem_size;
+	error = lv1_unmap_device_dma_region(did->bus_id, did->dev_id,
+					    ps3_rm_limit +  dma, /* I/O addr */
+					    size);
+
+	if (error)
+		printk("lv1_unmap_device_dma_region faild, error=%d\n", error);
+
+	/* free dma region */
+	error = lv1_free_device_dma_region(did->bus_id, did->dev_id, dma);
+	if (error)
+		printk("lv1_free_device_dma_region faild, error=%d\n", error);
+	return 0;
+}
+
+
+static void *ps3_stor_alloc_separate_memory(int alloc_size, u64 *lpar_addr)
+{
+	void * va;
+	BUG_ON(alloc_size != ps3flash_bounce_buffer.size);
+	va = ps3flash_bounce_buffer.address;
+	*lpar_addr = ps3_mm_phys_to_lpar(__pa(va));
+	return va;
+}
+
+static int ps3_stor_release_separate_memory(void *va, u64 lpar)
+{
+	/* Nothing to release anymore */
+	return 0;
+}
+
+
+static int get_default_max_sector(struct ps3_stor_lv1_dev_info * lv1_dev_info)
+{
+	int ret = 0;
+	switch (lv1_dev_info->device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = FLASH_ALIGN / lv1_dev_info->sector_size;
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = 32;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret =  128;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       lv1_dev_info->device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+
+
+static irqreturn_t ps3_stor_hdd_irq_handler(int irq, void * context)
+{
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = context;
+	struct ps3_stor_dev_info * dev_info = lv1_dev_info->dev_info;
+	int ret_val = IRQ_HANDLED;
+	u64 tag;
+
+	if (dev_info) {
+		dev_info->lv1_retval = lv1_storage_get_async_status(lv1_dev_info->repo.did.dev_id,
+								    &tag,
+								    (u64 *)&dev_info->lv1_status);
+		/*
+		 * lv1_status = -1 may mean that ATAPI transport completed OK, but ATAPI command
+		 * itself resulted CHECK CONDITION
+		 * so, upper layer should issue REQUEST_SENSE to check the sense data
+		 */
+		if (tag != lv1_dev_info->current_tag)
+			printk("%s: tag=%#lx ctag=%#lx\n", __FUNCTION__,
+			       tag, lv1_dev_info->current_tag);
+		if (dev_info->lv1_retval) {
+			printk("%s: ret=%d status=%#lx\n", __FUNCTION__,
+			       dev_info->lv1_retval, dev_info->lv1_status);
+			//if (dev_info->lv1_retval == LV1_NO_ENTRY)
+			//ret_val = IRQ_NONE;
+		} else {
+			complete(&(dev_info->irq_done));
+		}
+	}
+	return ret_val;
+}
+
+
+/*
+ * return 1 specified region is accessible from linux
+ */
+static irqreturn_t ps3_stor_temporary_irq_handler(int irq, void * context)
+{
+	struct ps3_stor_quirk_probe_info * info = context;
+
+	info->lv1_retval = lv1_storage_get_async_status(info->device_id,
+							&info->lv1_ret_tag,
+							&info->lv1_status);
+	complete(&(info->irq_done));
+
+	return IRQ_HANDLED;
+}
+
+static int is_region_accessible(struct ps3_stor_lv1_dev_info * lv1_dev_info,
+				unsigned int region_id)
+{
+	int accessible = 0;
+	unsigned int irq_plug_id, dma_region;
+	void * buf;
+	struct ps3_stor_quirk_probe_info info;
+	int error;
+
+	/*
+	 * special case
+	 * cd-rom is assumed always accessible
+	 */
+	if (lv1_dev_info->device_type == PS3_DEV_TYPE_STOR_ROM)
+		return 1;
+
+	/*
+	 * 1. open the device
+	 * 2. register irq for the device
+	 * 3. connect irq
+	 * 4. map dma region
+	 * 5. do read
+	 * 6. umap dma region
+	 * 7. disconnect irq
+	 * 8. unregister irq
+	 * 9. close the device
+	 */
+	memset(&info, 0, sizeof(info));
+
+	error = lv1_open_device(lv1_dev_info->repo.did.bus_id,
+				lv1_dev_info->repo.did.dev_id, 0);
+	if (error)
+		return 0;
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+				      &lv1_dev_info->repo.did,
+				      lv1_dev_info->interrupt_id,
+				      &irq_plug_id);
+	if (error) {
+		printk("%s:%u: ps3_sb_event_receive_port_setup failed (%d)\n",
+		       __func__, __LINE__, error);
+		goto fail_close_device;
+	}
+
+	error = request_irq(irq_plug_id, ps3_stor_temporary_irq_handler,
+			    IRQF_DISABLED, "PS3 quirk", &info);
+	if (error) {
+		printk("%s:%d: request_irq failed (%d)\n", __func__, __LINE__,
+		       error);
+		goto fail_event_receive_port_destroy;
+	}
+
+	dma_region = ps3_allocate_dma_region(&lv1_dev_info->repo.did);
+	if (!dma_region)
+		goto fail_free_irq;
+
+	/* 4k buffer is for fail safe of large sector devices */
+	buf = kmalloc(4096, GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_ERR "%s: no memory while probing dev=%u",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id);
+		goto fail_free_dma_region;
+	};
+
+	init_completion(&(info.irq_done));
+	info.device_id = lv1_dev_info->repo.did.dev_id;
+	error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+				 region_id,
+				 0, /* start sector */
+				 1, /* sector count */
+				 0, /* flags */
+				 ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+				 &info.lv1_tag);
+	if (error)
+		goto fail_free_buf;
+
+	wait_for_completion(&(info.irq_done));
+
+	if (!info.lv1_retval && !info.lv1_status) {
+		if (info.lv1_tag != info.lv1_ret_tag) {
+			printk(KERN_ERR "%s: tag mismached dev=%u\n",
+			       __FUNCTION__, lv1_dev_info->repo.did.dev_id);
+		} else
+			accessible = 1;
+	}
+
+fail_free_buf:
+	kfree(buf);
+fail_free_dma_region:
+	ps3_free_dma_region(&lv1_dev_info->repo.did, dma_region);
+fail_free_irq:
+	free_irq(irq_plug_id, &info);
+fail_event_receive_port_destroy:
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  irq_plug_id);
+fail_close_device:
+	lv1_close_device(lv1_dev_info->repo.did.bus_id,
+			 lv1_dev_info->repo.did.dev_id);
+
+	return accessible;
+}
+
+static unsigned int ps3_stor_enum_storage_type(enum ps3_dev_type device_type)
+{
+	struct ps3_repository_device repo, *prev = NULL;
+	unsigned int devices = 0;
+	int error;
+	unsigned int interrupt_id, regions, region_id;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	u64 port, blksize, blocks, region_size, region_start;
+	unsigned int i, j, accessible_regions;
+
+	while (!(error = ps3_repository_find_device(PS3_BUS_TYPE_STORAGE,
+						    device_type, prev,
+						    &repo))) {
+		prev = &repo;
+		error = ps3_repository_find_interrupt(&repo,
+				PS3_INTERRUPT_TYPE_EVENT_PORT, &interrupt_id);
+		if (error) {
+			printk(KERN_ERR "%s: find_interrupt failed (%d)\n",
+			       __FUNCTION__, error);
+			continue;
+		}
+
+		error = ps3_repository_read_stor_dev_info(repo.bus_index,
+							  repo.dev_index,
+							  &port, &blksize,
+							  &blocks, &regions);
+		if (error) {
+			printk(KERN_ERR "%s: read_stor_dev_info failed\n",
+			       __FUNCTION__);
+			continue;
+		}
+
+		/* LUN limitation */
+		if (regions > 8) {
+			printk(KERN_ERR "%s: region count exceeded (%u).  the rest are ignored\n",
+			       __FUNCTION__, regions);
+			regions = 8;
+		}
+
+		lv1_dev_info = &(ps3_stor_lv1_dev_info_array[ps3_stor_lv1_devnum]);
+		INIT_LIST_HEAD(&(lv1_dev_info->bus_dev_list));
+
+		lv1_dev_info->repo = repo;
+		lv1_dev_info->device_type = device_type;
+		lv1_dev_info->interrupt_id = interrupt_id;
+		lv1_dev_info->sector_size = blksize;
+		lv1_dev_info->attached_port = port;
+		lv1_dev_info->regions = regions;
+
+		/* check how many regions are accessible */
+		accessible_regions = 0;
+		for (i = 0; i < regions; i++) {
+			if (is_region_accessible(lv1_dev_info, i)) {
+				set_bit(i, &(lv1_dev_info->accessible_region_flag));
+				accessible_regions ++;
+			}
+		}
+		if (!accessible_regions) {
+		    printk(KERN_WARNING "No accessible regions found\n");
+		    continue;
+		}
+
+		lv1_dev_info->region_info_array = kzalloc(sizeof(struct ps3_stor_lv1_region_info) * accessible_regions,
+							  GFP_KERNEL);
+		if (!lv1_dev_info->region_info_array) {
+			printk(KERN_ERR "%s: kzalloc failed for info array\n",
+			       __FUNCTION__);
+			continue;
+		}
+
+		lv1_dev_info->accessible_regions = accessible_regions;
+		for (i = j = 0; i < regions; i++) {
+			if (!test_bit(i, &lv1_dev_info->accessible_region_flag))
+				continue;
+
+			if (ps3_repository_read_stor_dev_region(repo.bus_index,
+							        repo.dev_index,
+								i, &region_id,
+							        &region_start,
+							        &region_size)) {
+				printk(KERN_ERR "%s: read_stor_dev_region failed\n",
+				       __FUNCTION__);
+				continue;
+			}
+			printk(KERN_INFO "Region %u: id %u start %lu size %lu\n",
+			       i, region_id, region_start, region_size);
+			lv1_dev_info->region_info_array[j].region_index = i;
+			lv1_dev_info->region_info_array[j].region_id = region_id;
+			lv1_dev_info->region_info_array[j].region_start = region_start;
+			lv1_dev_info->region_info_array[j].region_size = region_size;
+			j++;
+		}
+		printk(KERN_INFO "ps3_stor: dev=%u type=%u port=%lu regions=%u accessible=%u\n",
+		       repo.did.dev_id, device_type, port, regions,
+		       accessible_regions);
+		ps3_stor_lv1_devnum++;
+
+		devices++;
+	}
+	if (error != -ENODEV)
+		printk(KERN_ERR "%s: find_device failed: %d\n", __FUNCTION__,
+		       error);
+	return devices;
+}
+
+/*
+ * returns current number of found HDDs
+ * and collect device info
+ */
+static unsigned int ps3_stor_enum_storage_drives(void)
+{
+	unsigned int devices = 0;
+
+#if defined(CONFIG_PS3_DISK) || defined(CONFIG_PS3_DISK_MODULE)
+	printk("NOT looking for disk devices!!!\n");
+#else
+	printk("Looking for disk devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_DISK);
+#endif
+#if defined(CONFIG_PS3_ROM) || defined(CONFIG_PS3_ROM_MODULE)
+	printk("Not looking for ROM devices...\n");
+#else
+	printk("Looking for ROM devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_ROM);
+#endif
+#if defined(CONFIG_PS3_FLASH) || defined(CONFIG_PS3_FLASH_MODULE)
+	printk("NOT looking for FLASH devices!!!\n");
+#else
+	printk("Looking for FLASH devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_FLASH);
+#endif
+
+	return devices;
+}
+
+
+static void ps3_stor_device_release(struct device * device)
+{
+	FUNC_START;
+	// place holder
+	FUNC_END;
+}
+
+const static struct platform_device ps3_stor_platform_device = {
+	.name           = "ps3_storage",
+	.dev            = {
+		.release        = ps3_stor_device_release
+	}
+};
+
+
+/*
+  construct a host structure
+  and associated structures for
+  its devices.
+  register the host thru device_register()
+*/
+static int ps3_stor_add_adapter(struct ps3_stor_lv1_bus_info * lv1_bus_info)
+{
+	int k;
+        int error = 0;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_dev_info *dev_info;
+        struct list_head *lh, *lh_sf;
+
+        host_info = kzalloc(sizeof(struct ps3_stor_host_info), GFP_KERNEL);
+
+        if (NULL == host_info) {
+                printk(KERN_ERR "%s: out of memory \n", __FUNCTION__);
+                return -ENOMEM;
+        }
+        INIT_LIST_HEAD(&host_info->dev_info_list);
+	host_info->lv1_bus_info = lv1_bus_info;
+
+	/* create structures for child devices of this adapter */
+        for (k = 0; k < lv1_bus_info->devices; k++) {
+                dev_info = kzalloc(sizeof(struct ps3_stor_dev_info),
+				   GFP_KERNEL);
+                if (NULL == dev_info) {
+                        printk(KERN_ERR "%s: out of memory \n", __FUNCTION__);
+                        error = -ENOMEM;
+			goto clean;
+                }
+                dev_info->host_info = host_info;
+		INIT_LIST_HEAD(&dev_info->dev_list);
+		spin_lock_init(&dev_info->srb_lock);
+		init_rwsem(&dev_info->bounce_sem);
+                list_add_tail(&dev_info->dev_list, &host_info->dev_info_list);
+        }
+
+        spin_lock(&ps3_stor_host_list_lock);
+        list_add_tail(&host_info->host_list, &ps3_stor_host_list);
+        spin_unlock(&ps3_stor_host_list_lock);
+
+	/* copy struct platform_device */
+        host_info->dev =  ps3_stor_platform_device;
+        host_info->dev.id = ps3_stor_add_host;
+
+        error = platform_device_register(&host_info->dev);
+
+        if (error)
+		goto clean;
+
+	/* bump up registerd buses */
+	++ps3_stor_add_host;
+
+        return error;
+
+clean:
+	list_for_each_safe(lh, lh_sf, &host_info->dev_info_list) {
+		dev_info = list_entry(lh, struct ps3_stor_dev_info, dev_list);
+		list_del(&dev_info->dev_list);
+		kfree(dev_info);
+	}
+
+	kfree(host_info);
+        return error;
+}
+
+static void ps3_stor_remove_adapter(void)
+{
+        struct ps3_stor_host_info * host_info = NULL;
+
+        spin_lock(&ps3_stor_host_list_lock);
+        if (!list_empty(&ps3_stor_host_list)) {
+                host_info = list_entry(ps3_stor_host_list.prev,
+                                       struct ps3_stor_host_info, host_list);
+		list_del(&host_info->host_list);
+	}
+        spin_unlock(&ps3_stor_host_list_lock);
+
+	if (!host_info)
+		return;
+
+        platform_device_unregister(&host_info->dev);
+	kfree(host_info);
+        --ps3_stor_add_host;
+}
+
+static int ps3_stor_wait_device_ready(void)
+{
+	unsigned int bus_index, bus_id, num_of_dev;
+	int error;
+	u64 tag, status;
+	int retries;
+	int ret = 0;
+	int i;
+	u64 * buf;
+	int region_ready = 0;
+	int region_expected = 0;
+	struct device_probe_info * info_array;
+
+	/* find the storage bus */
+	error = ps3_repository_find_bus(PS3_BUS_TYPE_STORAGE, 0, &bus_index);
+	if (error) {
+		printk(KERN_ERR "%s: Cannot find storage bus (%d)\n",
+		       __FUNCTION__, error);
+		return 0;
+	}
+
+	error = ps3_repository_read_bus_id(bus_index, &bus_id);
+	if (error) {
+		printk(KERN_ERR "%s: read_bus_id failed (%d)\n", __FUNCTION__,
+		       error);
+		return 0;
+	}
+
+	error = ps3_repository_read_bus_num_dev(bus_index, &num_of_dev);
+	if (error) {
+		printk(KERN_ERR "%s: read_bus_num_dev failed (%d)\n",
+		       __FUNCTION__, error);
+		return 0;
+	}
+
+	/* 1) wait for expected devices becomes in repositry */
+	retries = 0;
+	while (retries++ < ps3_stor_wait_time)
+	{
+		if (ps3_repository_read_bus_num_dev(bus_index, &num_of_dev)) {
+			continue;
+		}
+		if (ps3_stor_wait_num_storages + 1 <= num_of_dev)
+			break;
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+		printk(".");
+	}
+	printk("\n");
+
+	buf = kzalloc(512, GFP_KERNEL);
+	if (!buf)
+		return 0;
+
+	info_array = kzalloc(sizeof(struct device_probe_info) * num_of_dev, GFP_KERNEL);
+	if (!info_array) {
+		ret = -1;
+		goto cleanup_0;
+	}
+
+	/* 2) store the device info */
+	for (i = 0; i < num_of_dev; i++) {
+		if (ps3_repository_read_dev_id(bus_index, i,
+					       &info_array[i].device_id)) {
+			BUG();
+		}
+		ps3_repository_read_dev_type(bus_index, i,
+					     &info_array[i].device_type);
+		info_array[i].found = 1;
+
+		switch (info_array[i].device_type) {
+		case PS3_DEV_TYPE_STOR_DISK:
+		case PS3_DEV_TYPE_STOR_FLASH:
+			info_array[i].region_expected = 1;
+			region_expected ++;
+			ret ++;
+			break;
+		case PS3_DEV_TYPE_STOR_ROM:
+			ret ++;
+		default:
+			break;
+		}
+	} /* for */
+
+
+	/* 2-1) open special event device */
+	error = lv1_open_device(bus_id, NOTIFICATION_DEVID, 0);
+	if (error) {
+		printk(KERN_ERR "%s: open failed notification dev %d\n",
+		       __FUNCTION__, error);
+		ret = 0;
+		goto cleanup_1;
+	}
+
+	/* 2-2) write info to request notify */
+	buf[0] = 0;
+	buf[1] = (1 << 1); /* region update info only */
+	error = lv1_storage_write(NOTIFICATION_DEVID,
+				  0, /* region */
+				  0, /* lba */
+				  1, /* sectors to write */
+				  0, /* flags */
+				  ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+				  &tag);
+	if (error) {
+		printk(KERN_ERR "%s: notify request write failed %d\n",
+		       __FUNCTION__, error);
+		ret = 0;
+		goto cleanup_2;
+	}
+
+	/* wait for completion in one sec */
+	retries = 0;
+	while ((error = lv1_storage_check_async_status(NOTIFICATION_DEVID, tag,
+						       &status)) &&
+	       (retries++ < 1000)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+	if (error) {
+		/* write not completed */
+		printk(KERN_ERR "%s: write not completed %d\n", __FUNCTION__,
+		       error);
+		ret = 0;
+		goto cleanup_2;
+	}
+
+	/* 2-3) read to wait region notification for each device */
+	while (region_ready < region_expected) {
+		memset(buf, 0, 512);
+		error = lv1_storage_read(NOTIFICATION_DEVID,
+					 0, /* region */
+					 0, /* lba */
+					 1, /* sectors to read */
+					 0, /* flags */
+					 ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+					 &tag);
+		retries = 0;
+		while ((error = lv1_storage_check_async_status(NOTIFICATION_DEVID, tag, &status)) &&
+		       (retries++ < 1000)) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		}
+		if (error) {
+			/* read not completed */
+			printk(KERN_ERR "%s: read not complated %d\n",
+			       __FUNCTION__, error);
+			break;
+		}
+
+		/* 2-4) verify the notification */
+		if (buf[0] != 1) {
+			/* other info notified */
+			printk(KERN_ERR "%s: notification info %ld dev=%lx type=%lx\n", __FUNCTION__,
+			       buf[0], buf[2], buf[3]);
+		}
+
+		for (i = 0; i < num_of_dev; i++) {
+			if (info_array[i].found && info_array[i].device_id == buf[2]) {
+				info_array[i].region_ready = 1;
+				region_ready ++;
+				break;
+			}
+		} /* for */
+	} /* while */
+
+ cleanup_2:
+	lv1_close_device(bus_id, NOTIFICATION_DEVID);
+
+ cleanup_1:
+	kfree(info_array);
+ cleanup_0:
+	kfree(buf);
+	return ret;
+}
+
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_hdd[256] =
+{
+	[INQUIRY]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_inquiry},
+	[REQUEST_SENSE]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_request_sense},
+	[TEST_UNIT_READY]         = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_just_ok},
+	[READ_CAPACITY]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_read_capacity},
+	[MODE_SENSE_10]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_mode_sense},
+	[SYNCHRONIZE_CACHE]       = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_sync_cache},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write}
+};
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_flash[256] =
+{
+	[INQUIRY]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_inquiry},
+	[REQUEST_SENSE]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_request_sense},
+	[TEST_UNIT_READY]         = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_just_ok},
+	[READ_CAPACITY]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_read_capacity},
+	[MODE_SENSE_10]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_mode_sense},
+	[SYNCHRONIZE_CACHE]       = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_sync_cache},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_handle_write_flash},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_handle_write_flash}
+};
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_atapi[256] =
+{
+	[INQUIRY]                 = {USE_SRB_6, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[REQUEST_SENSE]           = {USE_SRB_6, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_request_sense},
+	[START_STOP]              = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[ALLOW_MEDIUM_REMOVAL]    = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[TEST_UNIT_READY]         = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[READ_CAPACITY]           = {8, PIO_DATA_IN_PROTO,  DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[MODE_SENSE_10]           = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[READ_TOC]                = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[GPCMD_GET_CONFIGURATION] = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[GPCMD_READ_DISC_INFO]    = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[GPCMD_READ_CD]           = {USE_CDDA_FRAME_RAW, DMA_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple}
+};
+
+
+/*
+ * called from scsi mid layer when it want to probe a
+ * device.
+ * Prepare so that mid can issue SCSI commands later (slave_configure)
+ */
+static int ps3_stor_slave_alloc(struct scsi_device * scsi_dev)
+{
+        int error = 0;
+        struct ps3_stor_host_info * host_info = NULL;
+	struct ps3_stor_dev_info * dev_info = NULL;
+        struct Scsi_Host *scsi_host;
+	struct ps3_stor_lv1_bus_info * lv1_bus_info;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = NULL;
+	struct list_head * pos;
+	int found;
+	char thread_name[64];
+
+	FUNC_START;
+
+	scsi_host = scsi_dev->host;
+	host_info = *(struct ps3_stor_host_info **)(scsi_host->hostdata);
+	lv1_bus_info = host_info->lv1_bus_info;
+	/*
+	 * connect lv1_dev_info with scsi_device
+	 * assume SCSI mid layer started scsi id with ZERO '0'
+	 */
+	found = 0;
+	list_for_each(pos, &(lv1_bus_info->dev_list)) {
+		lv1_dev_info = list_entry(pos, struct ps3_stor_lv1_dev_info,
+					  bus_dev_list);
+
+		if ((lv1_dev_info->bus_device_index == scsi_dev->id) &&
+		    (scsi_dev->lun < lv1_dev_info->accessible_regions)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		error = -ENXIO;
+		goto out;
+	}
+
+	/*
+	 * connect scsi_dev with dev_info
+	 */
+	found = 0;
+	list_for_each(pos, &(host_info->dev_info_list)) {
+		dev_info = list_entry(pos, struct ps3_stor_dev_info, dev_list);
+		if (!dev_info->used) {
+			dev_info->used = 1;
+			dev_info->target = scsi_dev->id;
+			dev_info->lv1_dev_info = lv1_dev_info;
+			switch (lv1_dev_info->device_type)
+			{
+			case PS3_DEV_TYPE_STOR_DISK:
+				dev_info->handler_info = scsi_cmnd_info_table_hdd;
+				break;
+			case PS3_DEV_TYPE_STOR_FLASH:
+				dev_info->handler_info = scsi_cmnd_info_table_flash;
+				break;
+			case PS3_DEV_TYPE_STOR_ROM:
+				dev_info->handler_info = scsi_cmnd_info_table_atapi;
+				break;
+			default:
+				break;
+			}
+			/* reverse link */
+			lv1_dev_info->dev_info = dev_info;
+			scsi_dev->hostdata = dev_info;
+			/* copy sector length and capacity */
+			dev_info->sector_size = lv1_dev_info->sector_size;
+			found = 1;
+			break;
+		} else {
+			if (dev_info->target == scsi_dev->id) {
+				/* another lun ? */
+				if (scsi_dev->lun < lv1_dev_info->accessible_regions) {
+					/* ok, support this lun */
+					scsi_dev->hostdata = dev_info;
+					goto skip_per_device_configure;
+				}
+			}
+		}
+	}
+
+	if (!found) {
+		printk(KERN_ERR "%s: no empty dev_info for device id=%d lun=%d \n", __FUNCTION__,
+		       scsi_dev->id, scsi_dev->lun);
+		error = -ENODEV;
+		goto out;
+	}
+	FUNC_STEP_C("1");
+
+	/* open lv1 device */
+	error = lv1_open_device(lv1_dev_info->repo.did.bus_id,
+			        lv1_dev_info->repo.did.dev_id, 0);
+	if (error) {
+		printk(KERN_ERR "%s:open failed %d\n", __FUNCTION__, error);
+		error = -ENODEV;
+		goto out;
+	}
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+						&lv1_dev_info->repo.did /* host_info->dev.did */,
+						lv1_dev_info->interrupt_id,
+						&lv1_dev_info->irq_plug_id);
+	if (error) {
+		printk("%s:%u: ps3_sb_event_receive_port_setup failed (%d)\n",
+		       __func__, __LINE__, error);
+		error = -EPERM;
+		goto fail_close_device;
+	}
+
+	FUNC_STEP_C("2");
+
+	error = request_irq(lv1_dev_info->irq_plug_id,
+			    ps3_stor_hdd_irq_handler, IRQF_DISABLED,
+			    "PS3 stor", lv1_dev_info);
+	if (error) {
+		printk("%s:%d: request_irq failed (%d)\n", __func__, __LINE__,
+		       error);
+		goto fail_event_receive_port_destroy;
+	}
+
+	FUNC_STEP_C("3");
+
+	/* prepare dma regions for the device */
+	down_write(&dev_info->bounce_sem);
+	switch (get_dedicated_buffer_type(lv1_dev_info->device_type)) {
+	case DEDICATED_KMALLOC:
+		/*
+		 * adjust max_sector count.
+		 * mid layer already set default value from host template
+		 */
+		blk_queue_max_sectors(scsi_dev->request_queue, get_default_max_sector(lv1_dev_info));
+		/* create its own static bouce buffer */
+		dev_info->dedicated_bounce_size = get_default_max_sector(lv1_dev_info) * lv1_dev_info->sector_size;
+		dev_info->bounce_buf = kmalloc(dev_info->dedicated_bounce_size, GFP_KERNEL | __GFP_DMA);
+		up_write(&dev_info->bounce_sem);
+		if (!dev_info->bounce_buf) {
+			printk(KERN_ERR "%s:kmalloc for static bounce buffer failed %#x\n", __FUNCTION__,
+			       dev_info->dedicated_bounce_size);
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		dev_info->bounce_type = DEDICATED_KMALLOC;
+		break;
+	case DEDICATED_SPECIAL:
+		blk_queue_max_sectors(scsi_dev->request_queue, get_default_max_sector(lv1_dev_info));
+		/* use static buffer, kmalloc can not allocate 256K */
+		dev_info->dedicated_bounce_size = FLASH_ALIGN;
+		dev_info->bounce_buf = ps3_stor_alloc_separate_memory(FLASH_ALIGN,
+								      &dev_info->separate_bounce_lpar);
+		if (!dev_info->bounce_buf) {
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		up_write(&dev_info->bounce_sem);
+		dev_info->bounce_type = DEDICATED_SPECIAL;
+		break;
+	}
+	/* allocate dma region */
+	if (need_dedicated_dma_region(lv1_dev_info->device_type)) {
+		error = lv1_allocate_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						       lv1_dev_info->repo.did.dev_id,
+						       CEIL_ALIGN_4K(dev_info->dedicated_bounce_size),
+						       12 /* 4K */,
+						       0,
+						       &lv1_dev_info->dma_region);
+		if (error || !lv1_dev_info->dma_region) {
+			printk(KERN_ERR "%s:allocate dma region failed %d\n",
+			       __FUNCTION__, error);
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		error = lv1_map_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						  lv1_dev_info->repo.did.dev_id,
+						  ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf),
+						  lv1_dev_info->dma_region,
+						  CEIL_ALIGN_4K(dev_info->dedicated_bounce_size),
+						  0xf800000000000000UL);
+		DPRINTK(KERN_ERR "%s:map bounce buffer %d va=%p lp=%#lx pa=%#lx size=%#x dma=%#lx\n",
+			__FUNCTION__, error, dev_info->bounce_buf,
+			ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf),
+		       __pa(dev_info->bounce_buf),
+		       dev_info->dedicated_bounce_size,
+		       lv1_dev_info->dma_region);
+		if (error) {
+			lv1_free_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						   lv1_dev_info->repo.did.dev_id,
+						   lv1_dev_info->dma_region);
+
+			error = -ENODEV;
+			goto fail_free_irq;
+		}
+		dev_info->dedicated_dma_region = 1;
+
+	} else {
+		lv1_dev_info->dma_region =
+			ps3_allocate_dma_region(&lv1_dev_info->repo.did);
+		if (!lv1_dev_info->dma_region) {
+			printk(KERN_ERR "%s:create dma region failed\n",
+			       __FUNCTION__);
+			error = -ENODEV;
+			goto fail_free_irq;
+		}
+	}
+	FUNC_STEP_C("4");
+
+	/* create receive thread */
+	sprintf(thread_name, "ps3stor-%d-%d",
+		scsi_host->host_no, scsi_dev->id);
+	dev_info->thread_struct = kthread_create(ps3_stor_main_thread,
+						 dev_info, thread_name);
+	if (IS_ERR(dev_info->thread_struct)) {
+		error = -ENOMEM;
+		dev_info->thread_struct = NULL;
+		goto fail_free_irq;
+	}
+	init_MUTEX_LOCKED(&(dev_info->thread_sema));
+	wake_up_process(dev_info->thread_struct);
+
+skip_per_device_configure:
+	FUNC_END;
+        return 0;
+
+fail_free_irq:
+	FUNC_STEP_C("5");
+	free_irq(lv1_dev_info->irq_plug_id, lv1_dev_info);
+fail_event_receive_port_destroy:
+	FUNC_STEP_C("6");
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  lv1_dev_info->irq_plug_id);
+fail_close_device:
+	FUNC_STEP_C("7");
+	lv1_close_device(lv1_dev_info->repo.did.bus_id, lv1_dev_info->repo.did.dev_id);
+out:
+	FUNC_END_C("error");
+	return error;/* say failed to alloc */
+}
+
+static int ps3_stor_slave_configure(struct scsi_device * scsi_dev)
+{
+
+	if (scsi_dev->host->max_cmd_len != PS3_STOR_MAX_CMD_LEN)
+		scsi_dev->host->max_cmd_len = PS3_STOR_MAX_CMD_LEN;
+
+	if (scsi_dev->host->cmd_per_lun)
+		scsi_adjust_queue_depth(scsi_dev, 0, scsi_dev->host->cmd_per_lun);
+	/*
+	 * ATAPI SFF8020 devices use MODE_SENSE_10,
+	 * so we can prohibit MODE_SENSE_6
+	 */
+	scsi_dev->use_10_for_ms = 1;
+
+	return 0;
+}
+
+static void ps3_stor_slave_destroy(struct scsi_device * scsi_dev)
+{
+	int error;
+	struct ps3_stor_dev_info * dev_info =
+				(struct ps3_stor_dev_info *)scsi_dev->hostdata;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = dev_info->lv1_dev_info;
+
+	/* only LUN=0 should do */
+	if (scsi_dev->lun != 0) {
+		printk(KERN_ERR "%s: id=%d lun=%d skipped\n", __FUNCTION__,
+		       scsi_dev->id, scsi_dev->lun);
+		return;
+	}
+
+	/* terminate main thread */
+	dev_info->thread_wakeup_reason = THREAD_TERMINATE;
+	init_completion(&(dev_info->thread_terminated));
+	up(&(dev_info)->thread_sema);
+	wait_for_completion(&(dev_info->thread_terminated));
+
+
+	/* free resources */
+	switch (dev_info->bounce_type) {
+	case DEDICATED_SPECIAL:
+		ps3_stor_release_separate_memory(dev_info->bounce_buf,
+						 dev_info->separate_bounce_lpar);
+		dev_info->bounce_buf = NULL;
+		break;
+	case DEDICATED_KMALLOC:
+		kfree(dev_info->bounce_buf);
+		dev_info->bounce_buf = NULL;
+		break;
+	}
+
+	if (dev_info->dedicated_dma_region) {
+		error = lv1_unmap_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						    lv1_dev_info->repo.did.dev_id,
+						    lv1_dev_info->dma_region,
+						    CEIL_ALIGN_4K(dev_info->dedicated_bounce_size));
+		if (error) {
+			printk(KERN_ERR "%s: unmap dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+		error = lv1_free_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						   lv1_dev_info->repo.did.dev_id,
+						   lv1_dev_info->dma_region);
+		if (error) {
+			printk(KERN_ERR "%s: unmap dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+		dev_info->dedicated_dma_region = 0;
+	} else {
+		error = ps3_free_dma_region(&lv1_dev_info->repo.did,
+					    lv1_dev_info->dma_region);
+		if (error) {
+			printk(KERN_ERR "%s: free dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+	}
+
+	free_irq(lv1_dev_info->irq_plug_id, lv1_dev_info);
+
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  lv1_dev_info->irq_plug_id);
+	if (error)
+		printk(KERN_ERR "%s: disconnect event irq %d\n", __FUNCTION__,
+		       error);
+
+	error = lv1_close_device(lv1_dev_info->repo.did.bus_id,
+				 lv1_dev_info->repo.did.dev_id);
+	if (error)
+		printk(KERN_ERR "%s: close device %d\n", __FUNCTION__, error);
+
+	if (dev_info) {
+		/* make this slot avaliable for re-use */
+		dev_info->used = 0;
+		scsi_dev->hostdata = NULL;
+	}
+
+}
+
+static int ps3_stor_queuecommand(struct scsi_cmnd * srb,
+				 void (*done)(struct scsi_cmnd *))
+{
+	struct ps3_stor_dev_info * dev_info;
+	unsigned long flags;
+	int ret = 0;
+	dev_info = (struct ps3_stor_dev_info *)srb->device->hostdata;
+
+	spin_lock_irqsave(&dev_info->srb_lock, flags);
+	{
+		if (dev_info->srb) {
+			/* no more than one can be processed */
+			printk(KERN_ERR "%s: more than 1 SRB queued %d %d\n", __FUNCTION__,
+			       srb->device->host->host_no, srb->device->id);
+			ret = SCSI_MLQUEUE_HOST_BUSY;
+		} else {
+			srb->scsi_done = done;
+			dev_info->srb = srb;
+
+			dev_info->thread_wakeup_reason = SRB_QUEUED;
+			up(&(dev_info->thread_sema));
+			ret = 0;
+		};
+	}
+	spin_unlock_irqrestore(&(dev_info->srb_lock), flags);
+	return ret;
+}
+
+static int ps3_stor_host_reset(struct scsi_cmnd * srb)
+{
+	return FAILED;
+}
+
+
+static ssize_t ps3_stor_get_max_sectors(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct scsi_device *scsi_dev = from_dev_to_scsi_device(dev);
+	struct ps3_stor_dev_info * dev_info =
+		(struct ps3_stor_dev_info *)scsi_dev->hostdata;
+	ssize_t ret;
+
+	down_read(&dev_info->bounce_sem);
+	ret = sprintf(buf, "%u\n", scsi_dev->request_queue->max_sectors);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static ssize_t ps3_stor_set_max_sectors(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct scsi_device *scsi_dev = from_dev_to_scsi_device(dev);
+	struct ps3_stor_dev_info * dev_info;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	unsigned short max_sectors;
+	void * bounce_buf;
+
+	if (sscanf(buf, "%hu", &max_sectors) > 0 && max_sectors <= SCSI_DEFAULT_MAX_SECTORS) {
+		dev_info = (struct ps3_stor_dev_info *)scsi_dev->hostdata;
+		lv1_dev_info = dev_info->lv1_dev_info;
+		/* if dedicated dma region, refuse to reset buffer */
+		if (need_dedicated_dma_region(lv1_dev_info->device_type)) {
+			/* FIXME: need remap dma region !!! */
+			return -EINVAL;
+		}
+		down_write(&dev_info->bounce_sem);
+		if (dev_info->bounce_type == DEDICATED_KMALLOC) {
+			/* try to allocate new bounce buffer */
+			bounce_buf = kmalloc(max_sectors * lv1_dev_info->sector_size, GFP_NOIO | __GFP_DMA | __GFP_NOWARN);
+			if (!bounce_buf) {
+				up_write(&dev_info->bounce_sem);
+				return -ENOMEM;
+			}
+			kfree(dev_info->bounce_buf);
+			dev_info->bounce_buf = bounce_buf;
+			dev_info->dedicated_bounce_size = max_sectors * lv1_dev_info->sector_size;
+		}
+		blk_queue_max_sectors(scsi_dev->request_queue, max_sectors);
+		up_write(&dev_info->bounce_sem);
+		return strlen(buf);
+	}
+	return -EINVAL;
+}
+
+
+static DEVICE_ATTR(max_sectors, S_IRUGO | S_IWUSR, ps3_stor_get_max_sectors,
+		   ps3_stor_set_max_sectors);
+
+static struct device_attribute *ps3_stor_sysfs_device_attr_list[] = {
+	&dev_attr_max_sectors,
+	NULL,
+};
+
+static struct scsi_host_template ps3_stor_driver_template = {
+	.name =			"ps3_stor",
+	.slave_alloc =		ps3_stor_slave_alloc,
+	.slave_configure =	ps3_stor_slave_configure,
+	.slave_destroy =	ps3_stor_slave_destroy,
+	.queuecommand =		ps3_stor_queuecommand,
+	.eh_host_reset_handler = ps3_stor_host_reset,
+	.can_queue =		PS3_STOR_CANQUEUE,
+	.this_id =		7,
+	.sg_tablesize =		SG_ALL,
+	.cmd_per_lun =		1,
+	.emulated =             1,   /* only sg driver uses this       */
+	.max_sectors =		128, /* multiple of pagesize, reset later */
+	.unchecked_isa_dma =	0,
+	.use_clustering =	ENABLE_CLUSTERING,
+	.sdev_attrs =           ps3_stor_sysfs_device_attr_list,
+	.module =		THIS_MODULE,
+};
+
+
+static int ps3_stor_driver_probe(struct platform_device * dev)
+{
+        int error = 0;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_lv1_bus_info *lv1_bus_info;
+        struct Scsi_Host *scsi_host;
+
+	host_info = from_dev_to_ps3_stor_host(dev);
+	lv1_bus_info = host_info->lv1_bus_info;
+
+        scsi_host = scsi_host_alloc(&ps3_stor_driver_template,
+				    sizeof(struct ps3_stor_host_info*));
+        if (NULL == scsi_host) {
+                printk(KERN_ERR "%s: scsi_register failed\n", __FUNCTION__);
+                error = -ENODEV;
+		return error;
+        }
+
+        host_info->scsi_host = scsi_host;
+	*((struct ps3_stor_host_info **)scsi_host->hostdata) = host_info;
+
+	/*
+	 * set maximum id as same as number of child devices
+	 */
+	scsi_host->max_id = lv1_bus_info->devices;
+	scsi_host->max_lun = 8;
+
+        error = scsi_add_host(scsi_host, &host_info->dev.dev);
+
+        if (error) {
+                printk(KERN_ERR "%s: scsi_add_host failed\n", __FUNCTION__);
+                error = -ENODEV;
+		scsi_host_put(scsi_host);
+        } else {
+		scsi_scan_host(scsi_host);
+	}
+
+
+        return error;
+}
+
+static int ps3_stor_driver_remove(struct platform_device * dev)
+{
+        struct list_head *lh, *lh_sf;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_dev_info *dev_info;
+
+	host_info = from_dev_to_ps3_stor_host(dev);
+
+	if (!host_info) {
+		printk(KERN_ERR "%s: Unable to locate host info\n",
+		       __FUNCTION__);
+		return -ENODEV;
+	}
+
+        scsi_remove_host(host_info->scsi_host);
+
+        list_for_each_safe(lh, lh_sf, &host_info->dev_info_list) {
+                dev_info = list_entry(lh, struct ps3_stor_dev_info, dev_list);
+                list_del(&dev_info->dev_list);
+                kfree(dev_info);
+        }
+
+        scsi_host_put(host_info->scsi_host);
+
+        return 0;
+}
+
+static void ps3_stor_driver_shutdown(struct platform_device * dev)
+{
+	ps3_stor_driver_remove(dev);
+}
+
+
+static struct platform_driver ps3_stor_platform_driver = {
+	.driver = {
+		.name = "ps3_storage"
+	},
+	.probe          = ps3_stor_driver_probe,
+	.remove         = ps3_stor_driver_remove,
+	.shutdown       = ps3_stor_driver_shutdown
+};
+
+static int __init ps3_stor_init(void)
+{
+	int host_to_add;
+	unsigned int devices, index;
+
+	FUNC_START;
+
+	/* register this driver thru devfs */
+	platform_driver_register(&ps3_stor_platform_driver);
+
+	/* wait until expected number of devices becomes ready */
+	devices = ps3_stor_wait_device_ready();
+	if (devices <= 0)
+		return -ENODEV;
+
+	/* init lv1_bus_info */
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		ps3_stor_lv1_bus_info_array[index].bus_type = index;
+		INIT_LIST_HEAD(&(ps3_stor_lv1_bus_info_array[index].dev_list));
+	}
+
+	/* alloc lv1_dev_info for devices */
+	ps3_stor_lv1_dev_info_array =
+		kzalloc(sizeof(struct ps3_stor_lv1_dev_info) * devices,
+			GFP_KERNEL);
+
+	if (!ps3_stor_lv1_dev_info_array) {
+		printk("init failed\n");
+		goto clean;
+	}
+	for (index = 0; index < devices; index++) {
+		INIT_LIST_HEAD(&(ps3_stor_lv1_dev_info_array[index].bus_dev_list));
+	}
+
+	/* calc how many HBA to add */
+	ps3_stor_lv1_devnum = 0;
+	devices = ps3_stor_enum_storage_drives();
+
+	for (index = 0; index < devices; index++) {
+		struct ps3_stor_lv1_dev_info *dev_info =
+			&ps3_stor_lv1_dev_info_array[index];
+		if (dev_info->device_type == PS3_DEV_TYPE_STOR_DISK ||
+		    dev_info->device_type == PS3_DEV_TYPE_STOR_ROM) {
+			if (dev_info->attached_port & (1 << 1)) {
+				dev_info->bus_device_index =
+					ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_1].devices ++;
+				list_add_tail(&(dev_info->bus_dev_list),
+					      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_1].dev_list));
+			} else {
+				dev_info->bus_device_index =
+					ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_0].devices ++;
+				list_add_tail(&(dev_info->bus_dev_list),
+					      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_0].dev_list));
+			}
+
+		}
+
+		if (dev_info->device_type == PS3_DEV_TYPE_STOR_FLASH) {
+			dev_info->bus_device_index =
+				ps3_stor_lv1_bus_info_array[PS3_STORAGE_FLASH].devices ++;
+			list_add_tail(&(dev_info->bus_dev_list),
+				      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_FLASH].dev_list));
+		}
+
+	}
+
+	host_to_add = 0;
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		if (ps3_stor_lv1_bus_info_array[index].devices)
+			host_to_add ++;
+	}
+
+
+        /* add HBAs */
+	ps3_stor_add_host = 0;
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		if (ps3_stor_lv1_bus_info_array[index].devices) {
+			if (ps3_stor_add_adapter(&(ps3_stor_lv1_bus_info_array[index]))) {
+				printk(KERN_ERR "ps3_stor_init: ps3_stor_add_adapter failed\n");
+				break;
+			} else
+				host_to_add --;
+		}
+	}
+
+	FUNC_END;
+	return 0;
+
+ clean:
+	platform_driver_unregister(&ps3_stor_platform_driver);
+	return -ENOMEM;
+}
+
+static void __exit ps3_stor_exit(void)
+{
+	int k;
+
+	for (k = ps3_stor_add_host; k; k--)
+		ps3_stor_remove_adapter();
+	platform_driver_unregister(&ps3_stor_platform_driver);
+
+	for (k = 0; k < ps3_stor_lv1_devnum; k++) {
+		if (ps3_stor_lv1_dev_info_array[k].region_info_array) {
+			kfree(ps3_stor_lv1_dev_info_array[k].region_info_array);
+		}
+	}
+	kfree(ps3_stor_lv1_dev_info_array);
+}
+
+
+device_initcall(ps3_stor_init);
+module_exit(ps3_stor_exit);
--- /dev/null
+++ b/drivers/block/ps3_storage.h
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * Copyright 2006, 2007 Sony Corporation
+ * storage support for PS3
+ *
+ * based on scsi_debug.h
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef _PS3_STOR_H
+#define _PS3_STOR_H
+
+#include <linux/types.h>
+#include <../arch/powerpc/platforms/ps3/platform.h>
+
+#define LV1_STORAGE_SEND_ATAPI_COMMAND	(1)
+#define LV1_STORAGE_ATA_HDDOUT		(0x23)
+
+#define PS3_STOR_MAX_INQUIRY_DATA_SIZE	(128)
+#define PS3_STOR_INQUIRY_DATA_SIZE	(86)
+#define PS3_STOR_READCAP_DATA_SIZE	(8)
+#define PS3_STOR_SENSE_LEN		(32)
+#define PS3_STOR_VERSION		"1.00"
+#define PS3_STOR_CANQUEUE		(1)
+#define PS3_STOR_MAX_CMD_LEN		(16)
+
+struct lv1_atapi_cmnd_block {
+	u8	pkt[32];	/* packet command block           */
+	u32	pktlen;		/* should be 12 for ATAPI 8020    */
+	u32	blocks;
+	u32	block_size;
+	u32	proto;		/* transfer mode                  */
+	u32	in_out;		/* transfer direction             */
+	u64	buffer;		/* parameter except command block */
+	u32	arglen;		/* length above                   */
+};
+
+enum lv1_atapi_proto {
+	NA_PROTO = -1,
+	NON_DATA_PROTO     = 0,
+	PIO_DATA_IN_PROTO  = 1,
+	PIO_DATA_OUT_PROTO = 2,
+	DMA_PROTO = 3
+};
+
+enum lv1_atapi_in_out {
+	DIR_NA = -1,
+	DIR_WRITE = 0, /* memory -> device */
+	DIR_READ = 1 /* device -> memory */
+};
+
+/*
+ * describe protocol of an ATAPI command
+ */
+struct ps3_stor_dev_info;
+
+struct scsi_command_handler_info {
+	int buflen;
+	int proto;
+	int in_out;
+	int (*cmnd_handler)(struct ps3_stor_dev_info *, struct scsi_cmnd *);
+};
+
+/*
+ * to position parameter
+ */
+enum {
+	NOT_AVAIL          = -1,
+	USE_SRB_10         = -2,
+	USE_SRB_6          = -3,
+	USE_CDDA_FRAME_RAW = -4
+};
+/*
+ * for LV1 maintainance
+ */
+enum  {
+	PS3_STORAGE_PATA_0, /* primary   PATA bus */
+	PS3_STORAGE_PATA_1, /* secondary PATA bus */
+	PS3_STORAGE_FLASH,
+	PS3_STORAGE_NUM_OF_BUS_TYPES /* terminator */
+};
+
+/*
+ * LV1 per physical bus info:
+ * PATA0, PATA1, FLASH
+ */
+struct ps3_stor_lv1_bus_info {
+	int bus_type;           /* PATA0, PATA1, FLASH */
+	int devices;            /* number of devices on the bus */
+	struct list_head dev_list;
+};
+
+/*
+ * LV1 per region info
+ */
+struct ps3_stor_lv1_region_info {
+	int region_index;	/* index of this region       */
+	unsigned int region_id;	/* id of this region          */
+	u64 region_size;	/* region size in sector      */
+	u64 region_start;	/* start sector */
+};
+
+/*
+ * LV1 per device info
+ */
+struct ps3_stor_lv1_dev_info {
+	struct list_head bus_dev_list; /* device list of devices          */
+				       /* which share same physical bus   */
+	struct ps3_stor_dev_info * dev_info;
+	/* repository values */
+	struct ps3_repository_device repo;
+	enum ps3_dev_type device_type;	/* bus#X.dev#Y.type     */
+	u64 attached_port;		/* bus#x.dev#Y.port     */
+	u64 sector_size;		/* bus#X.dev#Y.blk_size */
+
+	/* house keeping */
+	int bus_type;			/* PATA0,1 or FLASH */
+	unsigned int irq_plug_id;
+	unsigned int interrupt_id;
+	u64 dma_region;
+	u64 current_tag;
+	int bus_device_index;		/*
+					 * device index of same lv1 phy bus.
+					 * 0 for first device, 1 for second.
+					 * should be same as SCSI id
+					 */
+	/* regions */
+	unsigned int regions;	/* number of regions reported thru repository */
+	unsigned long accessible_region_flag; /* flag of accessible regions */
+	unsigned int accessible_regions; /* number of accessible regions of this dev.
+				 * currently, this includes region #0
+				 * NOTE: maximum is 8, if exceed, the rest of
+				 * regions are ignored
+				 */
+	struct ps3_stor_lv1_region_info * region_info_array;
+};
+
+enum read_or_write {
+	SCSIDEBUG_READ,
+	SCSIDEBUG_WRITE
+};
+
+
+enum thread_wakeup_reason {
+	SRB_QUEUED,
+	THREAD_TERMINATE
+};
+
+enum bounce_buffer_type {
+	DEDICATED_KMALLOC,
+	DEDICATED_SPECIAL,
+};
+
+struct ps3_stor_dev_info {
+	struct list_head dev_list;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	struct ps3_stor_host_info *host_info;
+	const struct scsi_command_handler_info * handler_info;
+	unsigned int target;
+
+	u64 sector_size;	/* copied from lv1 repository at initialize */
+	/* devices may change these value */
+	struct rw_semaphore bounce_sem;	/* protect the following members:
+					* bounce_buf (pointer itself, not buffer),
+					* dedicated_bounce_size
+					* max_sectors in scsi_dev->request_queue
+					*/
+	int  dedicated_bounce;	/* set nonzero if the bounce buffer is dedicated */
+	int  dedicated_bounce_size;
+	int  dedicated_dma_region; /* set if partial dma region allocated */
+	enum bounce_buffer_type bounce_type;	/* bounce buffer type */
+	void * bounce_buf;
+	u64 separate_bounce_lpar; /* lpar address for separated buffer  */
+
+	char used;
+
+	/* main thread communication */
+	struct task_struct * thread_struct;
+	spinlock_t srb_lock;
+	struct scsi_cmnd * srb;              /* queued srb; just one srb allowd             */
+	struct semaphore thread_sema;        /* device main thread wakeup                   */
+	struct completion thread_terminated; /* notify thread temination to slave_destory() */
+	int thread_wakeup_reason;
+
+	/* interrupt handler communication */
+	struct completion irq_done;
+	volatile u64 lv1_status;	/* result of get_async_status() */
+	volatile int lv1_retval;	/* return value of get_async_status() */
+
+};
+
+struct ps3_stor_host_info {
+	struct list_head host_list;
+	struct Scsi_Host *scsi_host;
+	struct platform_device dev;
+	struct list_head dev_info_list;
+	struct ps3_stor_lv1_bus_info * lv1_bus_info;
+};
+
+#define from_dev_to_ps3_stor_host(p) \
+	container_of(p, struct ps3_stor_host_info, dev)
+#define from_dev_to_scsi_device(p) \
+	container_of(p, struct scsi_device, sdev_gendev)
+
+
+struct ps3_stor_quirk_probe_info {
+	struct completion irq_done;
+	unsigned int device_id;
+	int lv1_retval;
+	u64 lv1_status;
+	u64 lv1_tag;
+	u64 lv1_ret_tag;
+};
+
+
+#define NOTIFICATION_DEVID ((u64)(-1L))
+
+struct device_probe_info {
+	unsigned int device_id;
+	enum ps3_dev_type device_type;
+	int      found;
+	int      region_expected;
+	int      region_ready;
+};
+
+#endif
--- /dev/null
+++ b/drivers/block/ps3disk.c
@@ -0,0 +1,452 @@
+/*
+ * PS3 Disk Storage Driver
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#define DEBUG
+
+#include <linux/dma-mapping.h>
+#include <linux/blkdev.h>
+#include <linux/freezer.h>
+#include <linux/hdreg.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+
+#include <asm/lv1call.h>
+#include <asm/ps3stor.h>
+
+
+#define DEVICE_NAME		"ps3disk"
+
+#define BOUNCE_SIZE		(64*1024)
+
+// FIXME Use a fixed major assigned by LANANA?
+#define PS3DISK_MAJOR		0
+
+#define PS3DISK_MAX_DISKS	16
+#define PS3DISK_MINORS		16
+
+#define KERNEL_SECTOR_SIZE	512
+
+
+#define PS3DISK_NAME		"ps3d%c"
+
+
+struct ps3disk_private {
+	spinlock_t lock;
+	struct task_struct *thread;
+	struct request_queue *queue;
+	struct gendisk *gendisk;
+	unsigned int blocking_factor;
+};
+#define ps3disk_priv(dev)	((dev)->sbd.core.driver_data)
+
+static int ps3disk_major = PS3DISK_MAJOR;
+
+static int ps3disk_open(struct inode *inode, struct file *file)
+{
+	struct ps3_storage_device *dev = inode->i_bdev->bd_disk->private_data;
+
+	file->private_data = dev;
+	return 0;
+}
+
+
+
+static struct block_device_operations ps3disk_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ps3disk_open,
+};
+
+static void ps3disk_scatter_gather(struct ps3_storage_device *dev,
+				   struct request *req, int gather)
+{
+	unsigned int sectors = 0, offset = 0;
+	struct bio *bio;
+	sector_t sector;
+	struct bio_vec *bvec;
+	unsigned int i = 0, j;
+	size_t size;
+	void *buf;
+
+	rq_for_each_bio(bio, req) {
+		sector = bio->bi_sector;
+		dev_dbg(&dev->sbd.core,
+			"%s:%u: bio %u: %u segs %u sectors from %lu\n",
+			__func__, __LINE__, i, bio_segments(bio),
+			bio_sectors(bio), sector);
+		bio_for_each_segment(bvec, bio, j) {
+			size = bio_cur_sectors(bio)*KERNEL_SECTOR_SIZE;
+			buf = __bio_kmap_atomic(bio, j, KM_USER0);
+			if (gather)
+				memcpy(dev->bounce_buf+offset, buf, size);
+			else
+				memcpy(buf, dev->bounce_buf+offset, size);
+			offset += size;
+			__bio_kunmap_atomic(bio, KM_USER0);
+		}
+		sectors += bio_sectors(bio);
+		i++;
+	}
+}
+
+static void ps3disk_handle_request_sg(struct ps3_storage_device *dev,
+				      struct request *req)
+{
+	struct ps3disk_private *priv = ps3disk_priv(dev);
+	int uptodate = 1;
+	int write = rq_data_dir(req);
+	u64 res;
+
+#ifdef DEBUG
+	unsigned int n = 0;
+	struct bio *bio;
+	const char *op = write ? "write" : "read";
+	rq_for_each_bio(bio, req)
+		n++;
+	dev_dbg(&dev->sbd.core,
+		"%s:%u: %s req has %u bios for %lu sectors %lu hard sectors\n",
+		__func__, __LINE__, op, n, req->nr_sectors,
+		req->hard_nr_sectors);
+#endif
+
+	if (write)
+		ps3disk_scatter_gather(dev, req, 1);
+
+	res = ps3stor_read_write_sectors(dev, dev->bounce_lpar,
+					 req->sector*priv->blocking_factor,
+					 req->nr_sectors*priv->blocking_factor,
+					 write);
+	if (res)
+		uptodate = 0;
+	else if (!write)
+		ps3disk_scatter_gather(dev, req, 0);
+
+	spin_lock_irq(&priv->lock);
+	if (!end_that_request_first(req, uptodate, req->nr_sectors)) {
+		blkdev_dequeue_request(req);
+		end_that_request_last(req, uptodate);
+	}
+	spin_unlock_irq(&priv->lock);
+}
+
+static int ps3disk_thread(void *data)
+{
+	struct ps3_storage_device *dev = data;
+	struct ps3disk_private *priv = ps3disk_priv(dev);
+	request_queue_t *q = priv->queue;
+	struct request *req;
+
+	dev_dbg(&dev->sbd.core, "%s thread init\n", __func__);
+
+	current->flags |= PF_NOFREEZE;
+
+	while (!kthread_should_stop()) {
+		spin_lock_irq(&priv->lock);
+		set_current_state(TASK_INTERRUPTIBLE);
+		req = elv_next_request(q);
+		if (!req) {
+			spin_unlock_irq(&priv->lock);
+			schedule();
+			continue;
+		}
+		if (!blk_fs_request(req)) {
+			blk_dump_rq_flags(req, DEVICE_NAME " bad request");
+			end_request(req, 0);
+			spin_unlock_irq(&priv->lock);
+			continue;
+		}
+		spin_unlock_irq(&priv->lock);
+		ps3disk_handle_request_sg(dev, req);
+	}
+
+	dev_dbg(&dev->sbd.core, "%s thread exit\n", __func__);
+	return 0;
+}
+
+static void ps3disk_request(request_queue_t *q)
+{
+	struct ps3_storage_device *dev = q->queuedata;
+	struct ps3disk_private *priv = ps3disk_priv(dev);
+	wake_up_process(priv->thread);
+}
+
+static unsigned long ps3disk_mask;
+
+static int __devinit ps3disk_probe(struct ps3_system_bus_device *_dev)
+{
+	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
+	struct ps3disk_private *priv;
+	int res, error;
+	unsigned int devidx;
+	struct request_queue *queue;
+	struct gendisk *gendisk;
+	struct task_struct *task;
+
+	error = ps3stor_probe_access(dev);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: No accessible regions found\n",
+			__func__, __LINE__);
+		return error;
+	}
+
+	if (dev->blk_size < KERNEL_SECTOR_SIZE) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: cannot handle block size %lu\n", __func__,
+			__LINE__, dev->blk_size);
+		return -EINVAL;
+	}
+
+	BUILD_BUG_ON(PS3DISK_MAX_DISKS > BITS_PER_LONG);
+	devidx = find_first_zero_bit(&ps3disk_mask, PS3DISK_MAX_DISKS);
+	if (devidx >= PS3DISK_MAX_DISKS) {
+		dev_err(&dev->sbd.core, "%s:%u: Too many disks\n", __func__,
+			__LINE__);
+		return -ENOSPC;
+	}
+	__set_bit(devidx, &ps3disk_mask);
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		error = -ENOMEM;
+		goto fail;
+	}
+
+	ps3disk_priv(dev) = priv;
+	spin_lock_init(&priv->lock);
+
+	dev->bounce_size = BOUNCE_SIZE;
+	dev->bounce_buf = kmalloc(BOUNCE_SIZE, GFP_DMA);
+	if (!dev->bounce_buf) {
+		error = -ENOMEM;
+		goto fail_free_priv;
+	}
+
+	error = ps3_open_hv_device(&dev->sbd);
+	if (error) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_open_hv_device failed %d\n", __func__,
+			__LINE__, error);
+		goto fail_free_bounce;
+	}
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+						&dev->sbd.did,
+						dev->sbd.interrupt_id,
+						&dev->irq);
+	if (error) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_sb_event_receive_port_setup failed %d\n",
+		       __func__, __LINE__, error);
+		goto fail_close_device;
+	}
+
+	error = request_irq(dev->irq, ps3stor_interrupt, IRQF_DISABLED,
+			    DEVICE_NAME, dev);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: request_irq failed %d\n",
+			__func__, __LINE__, error);
+		goto fail_sb_event_receive_port_destroy;
+	}
+
+	dev->bounce_lpar = ps3_mm_phys_to_lpar(__pa(dev->bounce_buf));
+
+	dev->sbd.d_region = &dev->dma_region;
+	ps3_dma_region_init(&dev->dma_region, &dev->sbd.did, PS3_DMA_4K,
+			    PS3_DMA_OTHER, dev->bounce_buf, dev->bounce_size,
+			    PS3_IOBUS_SB);
+	res = ps3_dma_region_create(&dev->dma_region);
+	if (res) {
+		dev_err(&dev->sbd.core, "%s:%u: cannot create DMA region\n",
+			__func__, __LINE__);
+		error = -ENOMEM;
+		goto fail_free_irq;
+	}
+
+	dev->bounce_dma = dma_map_single(&dev->sbd.core, dev->bounce_buf,
+					 dev->bounce_size, DMA_BIDIRECTIONAL);
+	if (!dev->bounce_dma) {
+		dev_err(&dev->sbd.core, "%s:%u: map DMA region failed\n",
+			__func__, __LINE__);
+		error = -ENODEV;
+		goto fail_free_dma;
+	}
+
+	queue = blk_init_queue(ps3disk_request, &priv->lock);
+	if (!queue) {
+		dev_err(&dev->sbd.core, "%s:%u: blk_init_queue failed\n",
+			__func__, __LINE__);
+		error = -ENOMEM;
+		goto fail_unmap_dma;
+	}
+
+	priv->queue = queue;
+	queue->queuedata = dev;
+
+	blk_queue_bounce_limit(queue, BLK_BOUNCE_HIGH);
+
+	blk_queue_max_sectors(queue, dev->bounce_size/KERNEL_SECTOR_SIZE);
+	blk_queue_segment_boundary(queue, -1UL);
+	blk_queue_dma_alignment(queue, dev->blk_size-1);
+	blk_queue_hardsect_size(queue, dev->blk_size);
+
+	blk_queue_ordered(queue, 0, NULL);	// FIXME no barriers
+
+	blk_queue_max_phys_segments(queue, -1);
+	blk_queue_max_hw_segments(queue, -1);
+	blk_queue_max_segment_size(queue, dev->bounce_size);
+
+	gendisk = alloc_disk(PS3DISK_MINORS);
+	if (!gendisk) {
+		dev_err(&dev->sbd.core, "%s:%u: alloc_disk failed\n", __func__,
+			__LINE__);
+		error = -ENOMEM;
+		goto fail_cleanup_queue;
+	}
+
+	priv->gendisk = gendisk;
+	gendisk->major = ps3disk_major;
+	gendisk->first_minor = devidx * PS3DISK_MINORS;
+	gendisk->fops = &ps3disk_fops;
+	gendisk->queue = queue;
+	gendisk->private_data = dev;
+	snprintf(gendisk->disk_name, sizeof(gendisk->disk_name), PS3DISK_NAME,
+		 devidx+'a');
+	priv->blocking_factor = dev->blk_size/KERNEL_SECTOR_SIZE;
+	set_capacity(gendisk,
+		     dev->regions[dev->region_idx].size*priv->blocking_factor);
+
+	task = kthread_run(ps3disk_thread, dev, DEVICE_NAME);
+	if (IS_ERR(task)) {
+		error = PTR_ERR(task);
+		goto fail_free_disk;
+	}
+	priv->thread = task;
+
+	add_disk(gendisk);
+	return 0;
+
+fail_free_disk:
+	put_disk(priv->gendisk);
+fail_cleanup_queue:
+	blk_cleanup_queue(queue);
+fail_unmap_dma:
+	dma_unmap_single(&dev->sbd.core, dev->bounce_dma, dev->bounce_size,
+			 DMA_BIDIRECTIONAL);
+fail_free_dma:
+	ps3_dma_region_free(&dev->dma_region);
+fail_free_irq:
+	free_irq(dev->irq, dev);
+fail_sb_event_receive_port_destroy:
+	ps3_sb_event_receive_port_destroy(&dev->sbd.did, dev->sbd.interrupt_id,
+					  dev->irq);
+fail_close_device:
+	ps3_close_hv_device(&dev->sbd);
+fail_free_bounce:
+	kfree(dev->bounce_buf);
+fail_free_priv:
+	kfree(priv);
+fail:
+	__clear_bit(devidx, &ps3disk_mask);
+	return error;
+}
+
+static int ps3disk_remove(struct ps3_system_bus_device *_dev)
+{
+	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
+	struct ps3disk_private *priv = ps3disk_priv(dev);
+	int error;
+
+	if (priv->thread)
+		kthread_stop(priv->thread);
+	if (priv->gendisk) {
+		__clear_bit(priv->gendisk->first_minor / PS3DISK_MINORS,
+			    &ps3disk_mask);
+		del_gendisk(priv->gendisk);
+		put_disk(priv->gendisk);
+	}
+	if (priv->queue)
+		blk_cleanup_queue(priv->queue);
+	dma_unmap_single(&dev->sbd.core, dev->bounce_dma, dev->bounce_size,
+			 DMA_BIDIRECTIONAL);
+	ps3_dma_region_free(&dev->dma_region);
+
+	free_irq(dev->irq, dev);
+
+	error = ps3_sb_event_receive_port_destroy(&dev->sbd.did,
+						  dev->sbd.interrupt_id,
+						  dev->irq);
+	if (error)
+		dev_err(&dev->sbd.core,
+			"%s:%u: destroy event receive port failed %d\n",
+			__func__, __LINE__, error);
+
+	error = ps3_close_hv_device(&dev->sbd);
+	if (error)
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_close_hv_device failed %d\n", __func__,
+			__LINE__, error);
+
+	kfree(dev->bounce_buf);
+	kfree(priv);
+	return 0;
+}
+
+
+static struct ps3_system_bus_driver ps3disk = {
+	.match_id	= PS3_MATCH_ID_STOR_DISK,
+	.core.name	= DEVICE_NAME,
+	.probe		= ps3disk_probe,
+	.remove		= ps3disk_remove,
+	.shutdown	= ps3disk_remove,
+};
+
+
+static int __init ps3disk_init(void)
+{
+	int error;
+
+	error = register_blkdev(ps3disk_major, DEVICE_NAME);
+	if (error <= 0) {
+		printk(KERN_ERR "%s:%u: register_blkdev failed %d\n", __func__,
+		       __LINE__, error);
+		return error;
+	}
+	if (!ps3disk_major)
+		ps3disk_major = error;
+
+	pr_info("%s:%u: registered block device major %d\n", __func__,
+		__LINE__, ps3disk_major);
+
+	return ps3_system_bus_driver_register(&ps3disk, PS3_IOBUS_SB);
+}
+
+static void __exit ps3disk_exit(void)
+{
+	unregister_blkdev(ps3disk_major, DEVICE_NAME);
+
+	return ps3_system_bus_driver_unregister(&ps3disk);
+}
+
+module_init(ps3disk_init);
+module_exit(ps3disk_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PS3 Disk Storage Driver");
+MODULE_AUTHOR("Sony Corporation");
+
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -104,6 +104,8 @@ obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
+obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
+
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c
 
--- /dev/null
+++ b/drivers/char/ps3flash.c
@@ -0,0 +1,491 @@
+/*
+ * PS3 FLASH ROM Storage Driver
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#define DEBUG
+
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+
+#include <asm/uaccess.h>
+#include <asm/lv1call.h>
+#include <asm/ps3stor.h>
+
+
+#define DEVICE_NAME		"ps3flash"
+
+
+#define FLASH_BLOCK_SIZE	(256*1024)
+
+
+struct ps3flash_private {
+	struct mutex mutex;
+};
+#define ps3flash_priv(dev)	((dev)->sbd.core.driver_data)
+
+static struct ps3_storage_device *ps3flash_dev;
+
+enum {
+	PS3FLASH_READ	= 0,
+	PS3FLASH_WRITE	= 1,
+};
+
+static ssize_t ps3flash_read_sectors(struct ps3_storage_device *dev,
+				     u64 start_sector, u64 sectors,
+				     unsigned int sector_offset)
+{
+	u64 max_sectors, lpar, res;
+
+	max_sectors = dev->bounce_size / dev->blk_size;
+	if (sectors > max_sectors) {
+		dev_dbg(&dev->sbd.core, "%s:%u Limiting sectors to %lu\n",
+			__func__, __LINE__, max_sectors);
+		sectors = max_sectors;
+	}
+
+	lpar = dev->bounce_lpar + sector_offset * dev->blk_size;
+	res = ps3stor_read_write_sectors(dev, lpar, start_sector, sectors, 0);
+	return res ? -EIO : sectors;
+}
+
+static ssize_t ps3flash_write_chunk(struct ps3_storage_device *dev,
+				    u64 start_sector)
+{
+	u64 sectors, res;
+
+	sectors = dev->bounce_size / dev->blk_size;
+	res = ps3stor_read_write_sectors(dev, dev->bounce_lpar, start_sector,
+					 sectors, 1);
+	return res ? -EIO : sectors;
+}
+
+
+static loff_t ps3flash_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct ps3_storage_device *dev = ps3flash_dev;
+	u64 size = dev->regions[dev->region_idx].size*dev->blk_size;
+
+	switch (origin) {
+	case 1:
+		offset += file->f_pos;
+		break;
+	case 2:
+		offset += size;
+		break;
+	}
+	if (offset < 0)
+		return -EINVAL;
+
+	file->f_pos = offset;
+	return file->f_pos;
+}
+
+static ssize_t ps3flash_read(struct file *file, char __user *buf, size_t count,
+			     loff_t *pos)
+{
+	struct ps3_storage_device *dev = ps3flash_dev;
+	struct ps3flash_private *priv = ps3flash_priv(dev);
+	u64 size, start_sector, end_sector, offset;
+	ssize_t sectors_read;
+	size_t remaining, n;
+
+	dev_dbg(&dev->sbd.core,
+		"%s:%u: Reading %zu bytes at position %lld to user 0x%p\n",
+		__func__, __LINE__, count, *pos, buf);
+
+	size = dev->regions[dev->region_idx].size*dev->blk_size;
+	if (*pos >= size || !count)
+		return 0;
+
+	if (*pos+count > size) {
+		dev_dbg(&dev->sbd.core,
+			"%s:%u Truncating count from %zu to %llu\n", __func__,
+			__LINE__, count, size-*pos);
+		count = size-*pos;
+	}
+
+	start_sector = do_div_llr(*pos, dev->blk_size, &offset);
+	end_sector = DIV_ROUND_UP(*pos+count, dev->blk_size);
+
+	remaining = count;
+	do {
+		mutex_lock(&priv->mutex);
+
+		sectors_read = ps3flash_read_sectors(dev, start_sector,
+						     end_sector-start_sector,
+						     0);
+		if (sectors_read < 0) {
+			mutex_unlock(&priv->mutex);
+			return sectors_read;
+		}
+
+		n = min(remaining, sectors_read*dev->blk_size-offset);
+		dev_dbg(&dev->sbd.core,
+			"%s:%u: copy %lu bytes from 0x%p to user 0x%p\n",
+			__func__, __LINE__, n, dev->bounce_buf+offset, buf);
+		if (copy_to_user(buf, dev->bounce_buf+offset, n)) {
+			mutex_unlock(&priv->mutex);
+			return -EFAULT;
+		}
+
+		mutex_unlock(&priv->mutex);
+
+		*pos += n;
+		buf += n;
+		remaining -= n;
+		start_sector += sectors_read;
+		offset = 0;
+	} while (remaining > 0);
+
+	return count;
+}
+
+static ssize_t ps3flash_write(struct file *file, const char __user *buf,
+			      size_t count, loff_t *pos)
+{
+	struct ps3_storage_device *dev = ps3flash_dev;
+	struct ps3flash_private *priv = ps3flash_priv(dev);
+	u64 size, chunk_sectors, start_write_sector, end_write_sector,
+	    end_read_sector, start_read_sector, head, tail, offset;
+	ssize_t res;
+	size_t remaining, n;
+
+	dev_dbg(&dev->sbd.core,
+		"%s:%u: Writing %zu bytes at position %lld from user 0x%p\n",
+		__func__, __LINE__, count, *pos, buf);
+
+	size = dev->regions[dev->region_idx].size*dev->blk_size;
+	if (*pos >= size || !count)
+		return 0;
+
+	if (*pos+count > size) {
+		dev_dbg(&dev->sbd.core,
+			"%s:%u Truncating count from %zu to %llu\n", __func__,
+			__LINE__, count, size-*pos);
+		count = size-*pos;
+	}
+
+	chunk_sectors = dev->bounce_size / dev->blk_size;
+
+	start_write_sector = do_div_llr(*pos, dev->bounce_size, &offset) *
+			     chunk_sectors;
+	end_write_sector = DIV_ROUND_UP(*pos+count, dev->bounce_size) *
+			   chunk_sectors;
+
+	end_read_sector = DIV_ROUND_UP(*pos, dev->blk_size);
+	start_read_sector = (*pos+count) / dev->blk_size;
+
+	/*
+	 * As we have to write in 256 KiB chunks, while we can read in blk_size
+	 * (usually 512 bytes) chunks, we perform the following steps:
+	 *   1. Read from start_write_sector to end_read_sector ("head")
+	 *   2. Read from start_read_sector to end_write_sector ("tail")
+	 *   3. Copy data to buffer
+	 *   4. Write from start_write_sector to end_write_sector
+	 * All of this is complicated by using only one 256 KiB bounce buffer.
+	 */
+
+	head = end_read_sector-start_write_sector;
+	tail = end_write_sector-start_read_sector;
+
+	remaining = count;
+	do {
+		mutex_lock(&priv->mutex);
+
+		if (end_read_sector >= start_read_sector) {
+			/* Merge head and tail */
+			dev_dbg(&dev->sbd.core,
+				"Merged head and tail: %lu sectors at %lu\n",
+				chunk_sectors, start_write_sector);
+			res = ps3flash_read_sectors(dev, start_write_sector,
+						    chunk_sectors, 0);
+			if (res < 0)
+				goto fail;
+
+
+		} else {
+			if (head) {
+				/* Read head */
+			dev_dbg(&dev->sbd.core, "head: %lu sectors at %lu\n",
+				head, start_write_sector);
+				res = ps3flash_read_sectors(dev,
+							    start_write_sector,
+							    head, 0);
+				if (res < 0)
+					goto fail;
+			}
+			if (start_read_sector <
+			    start_write_sector+chunk_sectors) {
+				/* Read tail */
+				dev_dbg(&dev->sbd.core,
+					"tail: %lu sectors at %lu\n", tail,
+					start_read_sector-start_write_sector);
+				res = ps3flash_read_sectors(dev,
+							    start_read_sector,
+							    tail,
+							    start_read_sector-start_write_sector);
+				if (res < 0)
+					goto fail;
+			}
+		}
+
+		if (start_read_sector < start_write_sector+chunk_sectors) {
+
+
+
+		}
+
+		n = min(remaining, dev->bounce_size-offset);
+		dev_dbg(&dev->sbd.core,
+			"%s:%u: copy %lu bytes from user 0x%p to 0x%p\n",
+			__func__, __LINE__, n, buf, dev->bounce_buf+offset);
+		if (copy_from_user(dev->bounce_buf+offset, buf, n)) {
+			res = -EFAULT;
+			goto fail;
+		}
+
+		res = ps3flash_write_chunk(dev, start_write_sector);
+		if (res < 0)
+			goto fail;
+
+		mutex_unlock(&priv->mutex);
+
+		*pos += n;
+		buf += n;
+		remaining -= n;
+		start_write_sector += chunk_sectors;
+		head = 0;
+		offset = 0;
+	} while (remaining > 0);
+
+	return count;
+
+fail:
+	mutex_unlock(&priv->mutex);
+	return res;
+}
+
+
+static const struct file_operations ps3flash_fops = {
+	.owner	= THIS_MODULE,
+	.llseek	= ps3flash_llseek,
+	.read	= ps3flash_read,
+	.write	= ps3flash_write,
+};
+
+static struct miscdevice ps3flash_misc = {
+	.minor	= MISC_DYNAMIC_MINOR,
+	.name	= DEVICE_NAME,
+	.fops	= &ps3flash_fops,
+};
+
+static int __devinit ps3flash_probe(struct ps3_system_bus_device *_dev)
+{
+	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
+	struct ps3flash_private *priv;
+	int res, error;
+	unsigned long tmp;
+
+	error = ps3stor_probe_access(dev);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: No accessible regions found\n",
+			__func__, __LINE__);
+		return error;
+	}
+
+	if (!ps3flash_bounce_buffer.address)
+		return -ENOMEM;
+
+	if (ps3flash_dev) {
+		dev_dbg(&dev->sbd.core,
+			"Only one FLASH device is supported\n");
+		return -EBUSY;
+	}
+
+	ps3flash_dev = dev;
+
+	tmp = dev->regions[dev->region_idx].start*dev->blk_size;
+	if (tmp % FLASH_BLOCK_SIZE) {
+		dev_err(&dev->sbd.core,
+			"%s:%u region start %lu is not aligned\n", __func__,
+			__LINE__, tmp);
+		error = -EINVAL;
+		goto fail;
+	}
+	tmp = dev->regions[dev->region_idx].size*dev->blk_size;
+	if (tmp % FLASH_BLOCK_SIZE) {
+		dev_err(&dev->sbd.core,
+			"%s:%u region size %lu is not aligned\n", __func__,
+			__LINE__, tmp);
+		error = -EINVAL;
+		goto fail;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		error = -ENOMEM;
+		goto fail;
+	}
+
+	ps3flash_priv(dev) = priv;
+	mutex_init(&priv->mutex);
+
+	error = ps3_open_hv_device(&dev->sbd);
+	if (error) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_open_hv_device failed %d\n", __func__,
+			__LINE__, error);
+		goto fail_free_priv;
+	}
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+						&dev->sbd.did,
+						dev->sbd.interrupt_id,
+						&dev->irq);
+	if (error) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_sb_event_receive_port_setup failed %d\n",
+		       __func__, __LINE__, error);
+		goto fail_close_device;
+	}
+
+	error = request_irq(dev->irq, ps3stor_interrupt, IRQF_DISABLED,
+			    DEVICE_NAME, dev);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: request_irq failed %d\n",
+			__func__, __LINE__, error);
+		goto fail_sb_event_receive_port_destroy;
+	}
+
+	/* use static buffer, kmalloc cannot allocate 256 KiB */
+	dev->bounce_size = ps3flash_bounce_buffer.size;
+	dev->bounce_buf = ps3flash_bounce_buffer.address;
+	dev->bounce_lpar = ps3_mm_phys_to_lpar(__pa(dev->bounce_buf));
+
+	dev->sbd.d_region = &dev->dma_region;
+	ps3_dma_region_init(&dev->dma_region, &dev->sbd.did, PS3_DMA_64K,
+			    PS3_DMA_OTHER, dev->bounce_buf, dev->bounce_size,
+			    PS3_IOBUS_SB);
+	res = ps3_dma_region_create(&dev->dma_region);
+	if (res) {
+		dev_err(&dev->sbd.core, "%s:%u: cannot create DMA region\n",
+			__func__, __LINE__);
+		error = -ENOMEM;
+		goto fail_free_irq;
+	}
+
+	dev->bounce_dma = dma_map_single(&dev->sbd.core, dev->bounce_buf,
+					 dev->bounce_size, DMA_BIDIRECTIONAL);
+	if (!dev->bounce_dma) {
+		dev_err(&dev->sbd.core, "%s:%u: map DMA region failed\n",
+			__func__, __LINE__);
+		error = -ENODEV;
+		goto fail_free_dma;
+	}
+
+	error = misc_register(&ps3flash_misc);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: misc_register failed %d\n",
+			__func__, __LINE__, error);
+		goto fail_unmap_dma;
+	}
+
+	dev_info(&dev->sbd.core, "%s:%u: registered misc device %d\n",
+		 __func__, __LINE__, ps3flash_misc.minor);
+	return 0;
+
+fail_unmap_dma:
+	dma_unmap_single(&dev->sbd.core, dev->bounce_dma, dev->bounce_size,
+			 DMA_BIDIRECTIONAL);
+fail_free_dma:
+	ps3_dma_region_free(&dev->dma_region);
+fail_free_irq:
+	free_irq(dev->irq, dev);
+fail_sb_event_receive_port_destroy:
+	ps3_sb_event_receive_port_destroy(&dev->sbd.did, dev->sbd.interrupt_id,
+					  dev->irq);
+fail_close_device:
+	ps3_close_hv_device(&dev->sbd);
+fail_free_priv:
+	kfree(priv);
+fail:
+	ps3flash_dev = NULL;
+	return error;
+}
+
+static int ps3flash_remove(struct ps3_system_bus_device *_dev)
+{
+	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
+	int error;
+
+	misc_deregister(&ps3flash_misc);
+
+	dma_unmap_single(&dev->sbd.core, dev->bounce_dma, dev->bounce_size,
+			 DMA_BIDIRECTIONAL);
+	ps3_dma_region_free(&dev->dma_region);
+
+	free_irq(dev->irq, dev);
+
+	error = ps3_sb_event_receive_port_destroy(&dev->sbd.did,
+						  dev->sbd.interrupt_id,
+						  dev->irq);
+	if (error)
+		dev_err(&dev->sbd.core,
+			"%s:%u: destroy event receive port failed %d\n",
+			__func__, __LINE__, error);
+
+	error = ps3_close_hv_device(&dev->sbd);
+	if (error)
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_close_hv_device failed %d\n", __func__,
+			__LINE__, error);
+
+	kfree(ps3flash_priv(dev));
+	ps3flash_dev = NULL;
+
+	return 0;
+}
+
+
+static struct ps3_system_bus_driver ps3flash = {
+	.match_id	= PS3_MATCH_ID_STOR_FLASH,
+	.core.name	= DEVICE_NAME,
+	.probe		= ps3flash_probe,
+	.remove		= ps3flash_remove,
+	.shutdown	= ps3flash_remove,
+};
+
+
+static int __init ps3flash_init(void)
+{
+	return ps3_system_bus_driver_register(&ps3flash, PS3_IOBUS_SB);
+}
+
+static void __exit ps3flash_exit(void)
+{
+	return ps3_system_bus_driver_unregister(&ps3flash);
+}
+
+module_init(ps3flash_init);
+module_exit(ps3flash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PS3 FLASH ROM Storage Driver");
+MODULE_AUTHOR("Sony Corporation");
--- a/drivers/ps3/Makefile
+++ b/drivers/ps3/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_PS3_VUART) += vuart.o
 obj-$(CONFIG_PS3_PS3AV) += ps3av.o ps3av_cmd.o
 obj-$(CONFIG_PS3_SYS_MANAGER) += sys-manager.o
+obj-$(CONFIG_PS3_STORAGE) += ps3stor_lib.o
--- /dev/null
+++ b/drivers/ps3/ps3stor_lib.c
@@ -0,0 +1,257 @@
+/*
+ * PS3 Storage Library
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#define DEBUG
+
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+
+#include <asm/lv1call.h>
+#include <asm/ps3stor.h>
+
+
+
+/**
+ *	ps3stor_interrupt - common interrupt routine for storage drivers
+ *	@irq: IRQ number
+ *	@data: Pointer to a struct ps3_storage_device
+ */
+irqreturn_t ps3stor_interrupt(int irq, void *data)
+{
+	struct ps3_storage_device *dev = data;
+
+	dev->lv1_res = lv1_storage_get_async_status(dev->sbd.did.dev_id,
+						    &dev->lv1_tag,
+						    &dev->lv1_status);
+	/*
+	 * lv1_status = -1 may mean that ATAPI transport completed OK, but
+	 * ATAPI command itself resulted CHECK CONDITION
+	 * so, upper layer should issue REQUEST_SENSE to check the sense data
+	 */
+
+	if (dev->lv1_tag != dev->tag)
+		dev_err(&dev->sbd.core,
+			"%s:%u: tag mismatch, got %lx, expected %lx\n",
+			__func__, __LINE__, dev->lv1_tag, dev->tag);
+	if (dev->lv1_res)
+		dev_err(&dev->sbd.core, "%s:%u: res=%d status=0x%lx\n",
+			__func__, __LINE__, dev->lv1_res, dev->lv1_status);
+	else
+		complete(&dev->irq_done);
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL_GPL(ps3stor_interrupt);
+
+
+/**
+ *	ps3stor_read_write_sectors - read/write from/to a storage device
+ *	@dev: Pointer to a struct ps3_storage_device
+ *	@lpar: HV logical partition address
+ *	@start_sector: First sector to read/write
+ *	@sectors: Number of sectors to read/write
+ *	@write: Flag indicating write (non-zero) or read (zero)
+ *
+ *	Returns 0 for success, -1 in case of failure to submit the command, or
+ *	an LV1 status value in case of other errors
+ */
+u64 ps3stor_read_write_sectors(struct ps3_storage_device *dev, u64 lpar,
+			       u64 start_sector, u64 sectors, int write)
+{
+	unsigned int idx = ffs(dev->accessible_regions)-1;
+	unsigned int region_id = dev->regions[idx].id;
+	const char *op = write ? "write" : "read";
+	int res;
+
+	dev_dbg(&dev->sbd.core, "%s:%u: %s %lu sectors starting at %lu\n",
+		__func__, __LINE__, op, sectors, start_sector);
+
+	init_completion(&dev->irq_done);
+	res = write ? lv1_storage_write(dev->sbd.did.dev_id, region_id,
+					start_sector, sectors, 0, lpar,
+					&dev->tag)
+		    : lv1_storage_read(dev->sbd.did.dev_id, region_id,
+				       start_sector, sectors, 0, lpar,
+				       &dev->tag);
+	if (res) {
+		dev_err(&dev->sbd.core, "%s:%u: %s failed %d\n", __func__,
+			__LINE__, op, res);
+		return -1;
+	}
+
+	wait_for_completion(&dev->irq_done);
+	if (dev->lv1_status) {
+		dev_err(&dev->sbd.core, "%s:%u: %s failed 0x%lx\n", __func__,
+			__LINE__, op, dev->lv1_status);
+		return dev->lv1_status;
+	}
+
+	dev_dbg(&dev->sbd.core, "%s:%u: %s completed\n", __func__, __LINE__,
+		op);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ps3stor_read_write_sectors);
+
+
+/**
+ *	ps3stor_probe_access - Probe for accessibility of regions
+ *	@dev: Pointer to a struct ps3_storage_device
+ *
+ *	Returns the index of the first accessible region, or an error code
+ */
+int ps3stor_probe_access(struct ps3_storage_device *dev)
+{
+	int res, error;
+	unsigned int irq, i;
+	unsigned long n;
+	void *buf;
+	dma_addr_t dma;
+	u64 lpar;
+
+	error = ps3_open_hv_device(&dev->sbd);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: open device %u:%u failed %d\n",
+			__func__, __LINE__, dev->sbd.did.bus_id,
+			dev->sbd.did.dev_id, error);
+		return error;
+	}
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+						&dev->sbd.did,
+						dev->sbd.interrupt_id, &irq);
+	if (error) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_sb_event_receive_port_setup failed %d\n",
+			__func__, __LINE__, error);
+		goto fail_close_device;
+	}
+
+	error = request_irq(irq, ps3stor_interrupt, IRQF_DISABLED,
+			    "ps3stor-probe", dev);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: request_irq failed %d\n",
+			__func__, __LINE__, error);
+		goto fail_event_receive_port_destroy;
+	}
+
+	/* PAGE_SIZE >= 4 KiB buffer for fail safe of large sector devices */
+	buf = (void *)__get_free_page(GFP_KERNEL);
+	if (!buf) {
+		dev_err(&dev->sbd.core, "%s:%u: no memory while probing",
+			__func__, dev->sbd.did.dev_id);
+		error = -ENOMEM;
+		goto fail_free_irq;
+	};
+
+	ps3_dma_region_init(&dev->dma_region, &dev->sbd.did, PS3_DMA_4K,
+			    PS3_DMA_OTHER, buf, PAGE_SIZE, PS3_IOBUS_SB);
+	res = ps3_dma_region_create(&dev->dma_region);
+	if (res) {
+		dev_err(&dev->sbd.core, "%s:%u: cannot create DMA region\n",
+			__func__, __LINE__);
+		error = -ENOMEM;
+		goto fail_free_buf;
+	}
+
+	lpar = ps3_mm_phys_to_lpar(__pa(buf));
+
+	dma = dma_map_single(&dev->sbd.core, buf, PAGE_SIZE, DMA_FROM_DEVICE);
+	if (!dma) {
+		dev_err(&dev->sbd.core, "%s:%u: map DMA region failed\n",
+			__func__, __LINE__);
+		error = -ENODEV;
+		goto fail_free_dma;
+	}
+
+	error = -EPERM;
+	for (i = 0; i < dev->num_regions; i++) {
+		dev_dbg(&dev->sbd.core,
+			"%s:%u: checking accessibility of region %u\n",
+			__func__, __LINE__, i);
+
+		init_completion(&dev->irq_done);
+		res = lv1_storage_read(dev->sbd.did.dev_id, dev->regions[i].id,
+				       0, /* start sector */
+				       1, /* sector count */
+				       0, /* flags */
+				       lpar, &dev->tag);
+		if (res) {
+			dev_dbg(&dev->sbd.core,
+				"%s:%u: read failed %d, region %u is not accessible\n",
+				__func__, __LINE__, res, i);
+			continue;
+		}
+
+		wait_for_completion(&dev->irq_done);
+
+		if (dev->lv1_res || dev->lv1_status) {
+			dev_dbg(&dev->sbd.core,
+				"%s:%u: read failed, region %u is not accessible\n",
+				__func__, __LINE__, i);
+			continue;
+		}
+
+		if (dev->lv1_tag != dev->tag) {
+			dev_err(&dev->sbd.core,
+				"%s:%u: tag mismatch, got %lx, expected %lx\n",
+				__func__, __LINE__, dev->lv1_tag, dev->tag);
+			break;
+		}
+
+		dev_dbg(&dev->sbd.core, "%s:%u: region %u is accessible\n",
+			__func__, __LINE__, i);
+		set_bit(i, &dev->accessible_regions);
+
+		/* We can access at least one region */
+		error = 0;
+	}
+	n = hweight_long(dev->accessible_regions);
+	if (n > 1)
+		dev_info(&dev->sbd.core,
+			 "%s:%u: %lu accessible regions found. Only the first "
+			 "one will be used",
+			 __func__, __LINE__, n);
+	dev->region_idx = __ffs(dev->accessible_regions);
+	dev_dbg(&dev->sbd.core,
+		"First accessible region has index %u start %lu size %lu\n",
+		dev->region_idx, dev->regions[dev->region_idx].start,
+		dev->regions[dev->region_idx].size);
+
+	dma_unmap_single(&dev->sbd.core, dma, PAGE_SIZE, DMA_FROM_DEVICE);
+fail_free_dma:
+	ps3_dma_region_free(&dev->dma_region);
+fail_free_buf:
+	free_page((unsigned long)buf);
+fail_free_irq:
+	free_irq(irq, dev);
+fail_event_receive_port_destroy:
+	ps3_sb_event_receive_port_destroy(&dev->sbd.did, dev->sbd.interrupt_id,
+					  irq);
+fail_close_device:
+	ps3_close_hv_device(&dev->sbd);
+
+	return error;
+}
+EXPORT_SYMBOL_GPL(ps3stor_probe_access);
+
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PS3 Storage Bus Library");
+MODULE_AUTHOR("Sony Corporation");
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -132,6 +132,7 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
 obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
 obj-$(CONFIG_SCSI_HPTIOP)	+= hptiop.o
 obj-$(CONFIG_SCSI_STEX)		+= stex.o
+obj-$(CONFIG_PS3_ROM)		+= ps3rom.o
 
 obj-$(CONFIG_ARM)		+= arm/
 
--- /dev/null
+++ b/drivers/scsi/ps3rom.c
@@ -0,0 +1,930 @@
+/*
+ * PS3 ROM Storage Driver
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#define DEBUG
+
+#include <linux/cdrom.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+
+#include <asm/lv1call.h>
+#include <asm/ps3stor.h>
+
+
+#define DEVICE_NAME			"ps3rom"
+
+#define BOUNCE_SIZE			(64*1024)
+
+#define PS3ROM_MAX_SECTORS		(BOUNCE_SIZE / CD_FRAMESIZE)
+
+#define LV1_STORAGE_SEND_ATAPI_COMMAND	(1)
+
+
+struct ps3rom_private {
+	spinlock_t lock;
+	struct task_struct *thread;
+	struct Scsi_Host *host;
+	struct scsi_cmnd *cmd;
+	void (*scsi_done)(struct scsi_cmnd *);
+};
+#define ps3rom_priv(dev)	((dev)->sbd.core.driver_data)
+
+struct lv1_atapi_cmnd_block {
+	u8	pkt[32];	/* packet command block           */
+	u32	pktlen;		/* should be 12 for ATAPI 8020    */
+	u32	blocks;
+	u32	block_size;
+	u32	proto;		/* transfer mode                  */
+	u32	in_out;		/* transfer direction             */
+	u64	buffer;		/* parameter except command block */
+	u32	arglen;		/* length above                   */
+};
+
+/*
+ * to position parameter
+ */
+enum {
+	NOT_AVAIL          = -1,
+	USE_SRB_10         = -2,
+	USE_SRB_6          = -3,
+	USE_CDDA_FRAME_RAW = -4
+};
+
+enum lv1_atapi_proto {
+	NA_PROTO = -1,
+	NON_DATA_PROTO     = 0,
+	PIO_DATA_IN_PROTO  = 1,
+	PIO_DATA_OUT_PROTO = 2,
+	DMA_PROTO = 3
+};
+
+enum lv1_atapi_in_out {
+	DIR_NA = -1,
+	DIR_WRITE = 0, /* memory -> device */
+	DIR_READ = 1 /* device -> memory */
+};
+
+
+#ifdef DEBUG
+static const char *scsi_command(unsigned char cmd)
+{
+	switch (cmd) {
+	case TEST_UNIT_READY:		return "TEST_UNIT_READY/GPCMD_TEST_UNIT_READY";
+	case REZERO_UNIT:		return "REZERO_UNIT";
+	case REQUEST_SENSE:		return "REQUEST_SENSE/GPCMD_REQUEST_SENSE";
+	case FORMAT_UNIT:		return "FORMAT_UNIT/GPCMD_FORMAT_UNIT";
+	case READ_BLOCK_LIMITS:		return "READ_BLOCK_LIMITS";
+	case REASSIGN_BLOCKS:		return "REASSIGN_BLOCKS/INITIALIZE_ELEMENT_STATUS";
+	case READ_6:			return "READ_6";
+	case WRITE_6:			return "WRITE_6/MI_REPORT_TARGET_PGS";
+	case SEEK_6:			return "SEEK_6";
+	case READ_REVERSE:		return "READ_REVERSE";
+	case WRITE_FILEMARKS:		return "WRITE_FILEMARKS/SAI_READ_CAPACITY_16";
+	case SPACE:			return "SPACE";
+	case INQUIRY:			return "INQUIRY/GPCMD_INQUIRY";
+	case RECOVER_BUFFERED_DATA:	return "RECOVER_BUFFERED_DATA";
+	case MODE_SELECT:		return "MODE_SELECT";
+	case RESERVE:			return "RESERVE";
+	case RELEASE:			return "RELEASE";
+	case COPY:			return "COPY";
+	case ERASE:			return "ERASE";
+	case MODE_SENSE:		return "MODE_SENSE";
+	case START_STOP:		return "START_STOP/GPCMD_START_STOP_UNIT";
+	case RECEIVE_DIAGNOSTIC:	return "RECEIVE_DIAGNOSTIC";
+	case SEND_DIAGNOSTIC:		return "SEND_DIAGNOSTIC";
+	case ALLOW_MEDIUM_REMOVAL:	return "ALLOW_MEDIUM_REMOVAL/GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL";
+	case SET_WINDOW:		return "SET_WINDOW";
+	case READ_CAPACITY:		return "READ_CAPACITY/GPCMD_READ_CDVD_CAPACITY";
+	case READ_10:			return "READ_10/GPCMD_READ_10";
+	case WRITE_10:			return "WRITE_10/GPCMD_WRITE_10";
+	case SEEK_10:			return "SEEK_10/POSITION_TO_ELEMENT/GPCMD_SEEK";
+	case WRITE_VERIFY:		return "WRITE_VERIFY/GPCMD_WRITE_AND_VERIFY_10";
+	case VERIFY:			return "VERIFY/GPCMD_VERIFY_10";
+	case SEARCH_HIGH:		return "SEARCH_HIGH";
+	case SEARCH_EQUAL:		return "SEARCH_EQUAL";
+	case SEARCH_LOW:		return "SEARCH_LOW";
+	case SET_LIMITS:		return "SET_LIMITS";
+	case PRE_FETCH:			return "PRE_FETCH/READ_POSITION";
+	case SYNCHRONIZE_CACHE:		return "SYNCHRONIZE_CACHE/GPCMD_FLUSH_CACHE";
+	case LOCK_UNLOCK_CACHE:		return "LOCK_UNLOCK_CACHE";
+	case READ_DEFECT_DATA:		return "READ_DEFECT_DATA";
+	case MEDIUM_SCAN:		return "MEDIUM_SCAN";
+	case COMPARE:			return "COMPARE";
+	case COPY_VERIFY:		return "COPY_VERIFY";
+	case WRITE_BUFFER:		return "WRITE_BUFFER";
+	case READ_BUFFER:		return "READ_BUFFER";
+	case UPDATE_BLOCK:		return "UPDATE_BLOCK";
+	case READ_LONG:			return "READ_LONG";
+	case WRITE_LONG:		return "WRITE_LONG";
+	case CHANGE_DEFINITION:		return "CHANGE_DEFINITION";
+	case WRITE_SAME:		return "WRITE_SAME";
+	case READ_TOC:			return "READ_TOC/GPCMD_READ_TOC_PMA_ATIP";
+	case LOG_SELECT:		return "LOG_SELECT";
+	case LOG_SENSE:			return "LOG_SENSE";
+	case MODE_SELECT_10:		return "MODE_SELECT_10/GPCMD_MODE_SELECT_10";
+	case RESERVE_10:		return "RESERVE_10";
+	case RELEASE_10:		return "RELEASE_10";
+	case MODE_SENSE_10:		return "MODE_SENSE_10/GPCMD_MODE_SENSE_10";
+	case PERSISTENT_RESERVE_IN:	return "PERSISTENT_RESERVE_IN";
+	case PERSISTENT_RESERVE_OUT:	return "PERSISTENT_RESERVE_OUT";
+	case REPORT_LUNS:		return "REPORT_LUNS";
+	case MAINTENANCE_IN:		return "MAINTENANCE_IN/GPCMD_SEND_KEY";
+	case MOVE_MEDIUM:		return "MOVE_MEDIUM";
+	case EXCHANGE_MEDIUM:		return "EXCHANGE_MEDIUM/GPCMD_LOAD_UNLOAD";
+	case READ_12:			return "READ_12/GPCMD_READ_12";
+	case WRITE_12:			return "WRITE_12";
+	case WRITE_VERIFY_12:		return "WRITE_VERIFY_12";
+	case SEARCH_HIGH_12:		return "SEARCH_HIGH_12";
+	case SEARCH_EQUAL_12:		return "SEARCH_EQUAL_12";
+	case SEARCH_LOW_12:		return "SEARCH_LOW_12";
+	case READ_ELEMENT_STATUS:	return "READ_ELEMENT_STATUS";
+	case SEND_VOLUME_TAG:		return "SEND_VOLUME_TAG/GPCMD_SET_STREAMING";
+	case WRITE_LONG_2:		return "WRITE_LONG_2";
+	case READ_16:			return "READ_16";
+	case WRITE_16:			return "WRITE_16";
+	case VERIFY_16:			return "VERIFY_16";
+	case SERVICE_ACTION_IN:		return "SERVICE_ACTION_IN";
+	case ATA_16:			return "ATA_16";
+	case ATA_12:			return "ATA_12/GPCMD_BLANK";
+	case GPCMD_CLOSE_TRACK:		return "GPCMD_CLOSE_TRACK";
+	case GPCMD_GET_CONFIGURATION:	return "GPCMD_GET_CONFIGURATION";
+	case GPCMD_GET_EVENT_STATUS_NOTIFICATION:	return "GPCMD_GET_EVENT_STATUS_NOTIFICATION";
+	case GPCMD_GET_PERFORMANCE:	return "GPCMD_GET_PERFORMANCE";
+	case GPCMD_MECHANISM_STATUS:	return "GPCMD_MECHANISM_STATUS";
+	case GPCMD_PAUSE_RESUME:	return "GPCMD_PAUSE_RESUME";
+	case GPCMD_PLAY_AUDIO_10:	return "GPCMD_PLAY_AUDIO_10";
+	case GPCMD_PLAY_AUDIO_MSF:	return "GPCMD_PLAY_AUDIO_MSF";
+	case GPCMD_PLAY_AUDIO_TI:	return "GPCMD_PLAY_AUDIO_TI/GPCMD_PLAYAUDIO_TI";
+	case GPCMD_PLAY_CD:		return "GPCMD_PLAY_CD";
+	case GPCMD_READ_BUFFER_CAPACITY:	return "GPCMD_READ_BUFFER_CAPACITY";
+	case GPCMD_READ_CD:		return "GPCMD_READ_CD";
+	case GPCMD_READ_CD_MSF:		return "GPCMD_READ_CD_MSF";
+	case GPCMD_READ_DISC_INFO:	return "GPCMD_READ_DISC_INFO";
+	case GPCMD_READ_DVD_STRUCTURE:	return "GPCMD_READ_DVD_STRUCTURE";
+	case GPCMD_READ_FORMAT_CAPACITIES:	return "GPCMD_READ_FORMAT_CAPACITIES";
+	case GPCMD_READ_HEADER:		return "GPCMD_READ_HEADER";
+	case GPCMD_READ_TRACK_RZONE_INFO:	return "GPCMD_READ_TRACK_RZONE_INFO";
+	case GPCMD_READ_SUBCHANNEL:	return "GPCMD_READ_SUBCHANNEL";
+	case GPCMD_REPAIR_RZONE_TRACK:	return "GPCMD_REPAIR_RZONE_TRACK";
+	case GPCMD_REPORT_KEY:		return "GPCMD_REPORT_KEY";
+	case GPCMD_RESERVE_RZONE_TRACK:	return "GPCMD_RESERVE_RZONE_TRACK";
+	case GPCMD_SEND_CUE_SHEET:	return "GPCMD_SEND_CUE_SHEET";
+	case GPCMD_SCAN:		return "GPCMD_SCAN";
+	case GPCMD_SEND_DVD_STRUCTURE:	return "GPCMD_SEND_DVD_STRUCTURE";
+	case GPCMD_SEND_EVENT:		return "GPCMD_SEND_EVENT";
+	case GPCMD_SEND_OPC:		return "GPCMD_SEND_OPC";
+	case GPCMD_SET_READ_AHEAD:	return "GPCMD_SET_READ_AHEAD";
+	case GPCMD_STOP_PLAY_SCAN:	return "GPCMD_STOP_PLAY_SCAN";
+	case GPCMD_SET_SPEED:		return "GPCMD_SET_SPEED";
+	case GPCMD_GET_MEDIA_STATUS:	return "GPCMD_GET_MEDIA_STATUS";
+
+	default:
+	    return "***UNKNOWN***";
+	}
+}
+#else /* !DEBUG */
+static inline const char *scsi_command(unsigned char cmd) { return NULL; }
+#endif /* DEBUG */
+
+
+static int ps3rom_slave_alloc(struct scsi_device *scsi_dev)
+{
+	struct ps3_storage_device *dev;
+
+	dev = (struct ps3_storage_device *)scsi_dev->host->hostdata[0];
+
+	dev_dbg(&dev->sbd.core, "%s:%u: id %u, lun %u, channel %u\n", __func__,
+		__LINE__, scsi_dev->id, scsi_dev->lun, scsi_dev->channel);
+
+	scsi_dev->hostdata = dev;
+	return 0;
+}
+
+static int ps3rom_slave_configure(struct scsi_device *scsi_dev)
+{
+	struct ps3_storage_device *dev = scsi_dev->hostdata;
+
+	dev_dbg(&dev->sbd.core, "%s:%u: id %u, lun %u, channel %u\n", __func__,
+		__LINE__, scsi_dev->id, scsi_dev->lun, scsi_dev->channel);
+
+	/*
+	 * ATAPI SFF8020 devices use MODE_SENSE_10,
+	 * so we can prohibit MODE_SENSE_6
+	 */
+	scsi_dev->use_10_for_ms = 1;
+
+	return 0;
+}
+
+static void ps3rom_slave_destroy(struct scsi_device *scsi_dev)
+{
+}
+
+static int ps3rom_queuecommand(struct scsi_cmnd *cmd,
+			       void (*done)(struct scsi_cmnd *))
+{
+	struct ps3_storage_device *dev = cmd->device->hostdata;
+	struct ps3rom_private *priv = ps3rom_priv(dev);
+
+	dev_dbg(&dev->sbd.core, "%s:%u: command 0x%02x (%s)\n", __func__,
+		__LINE__, cmd->cmnd[0], scsi_command(cmd->cmnd[0]));
+
+	spin_lock_irq(&priv->lock);
+	if (priv->cmd) {
+		/* no more than one can be processed */
+		dev_err(&dev->sbd.core, "%s:%u: more than 1 command queued\n",
+			__func__, __LINE__);
+		spin_unlock_irq(&priv->lock);
+		return SCSI_MLQUEUE_HOST_BUSY;
+	}
+
+	// FIXME Prevalidate commands?
+	priv->cmd = cmd;
+	priv->scsi_done = done;
+	spin_unlock_irq(&priv->lock);
+	wake_up_process(priv->thread);
+	return 0;
+
+
+	return -1;
+}
+
+/*
+ * copy data from device into scatter/gather buffer
+ */
+static int fill_from_dev_buffer(struct scsi_cmnd *cmd, const void *buf,
+				int buflen)
+{
+	int k, req_len, act_len, len, active;
+	void *kaddr;
+	struct scatterlist *sgpnt;
+
+	if (!cmd->request_bufflen)
+		return 0;
+
+	if (!cmd->request_buffer)
+		return DID_ERROR << 16;
+
+	if (cmd->sc_data_direction != DMA_BIDIRECTIONAL &&
+	    cmd->sc_data_direction != DMA_FROM_DEVICE)
+		return DID_ERROR << 16;
+
+	if (!cmd->use_sg) {
+		req_len = cmd->request_bufflen;
+		act_len = min(req_len, buflen);
+		memcpy(cmd->request_buffer, buf, act_len);
+		cmd->resid = req_len - act_len;
+		return 0;
+	}
+
+	sgpnt = cmd->request_buffer;
+	active = 1;
+	for (k = 0, req_len = 0, act_len = 0; k < cmd->use_sg; ++k, ++sgpnt) {
+		if (active) {
+			kaddr = kmap_atomic(sgpnt->page, KM_USER0);
+			if (!kaddr)
+				return DID_ERROR << 16;
+			len = sgpnt->length;
+			if ((req_len + len) > buflen) {
+				active = 0;
+				len = buflen - req_len;
+			}
+			memcpy(kaddr + sgpnt->offset, buf + req_len, len);
+			kunmap_atomic(kaddr, KM_USER0);
+			act_len += len;
+		}
+		req_len += sgpnt->length;
+	}
+	cmd->resid = req_len - act_len;
+	return 0;
+}
+
+/*
+ * copy data from scatter/gather into device's buffer
+ */
+static int fetch_to_dev_buffer(struct scsi_cmnd *cmd, void *buf, int buflen)
+{
+	int k, req_len, len, fin;
+	void *kaddr;
+	struct scatterlist *sgpnt;
+
+	if (!cmd->request_bufflen)
+		return 0;
+
+	if (!cmd->request_buffer)
+		return -1;
+
+	if (cmd->sc_data_direction != DMA_BIDIRECTIONAL &&
+	    cmd->sc_data_direction != DMA_TO_DEVICE)
+		return -1;
+
+	if (!cmd->use_sg) {
+		req_len = cmd->request_bufflen;
+		len = min(req_len, buflen);
+		memcpy(buf, cmd->request_buffer, len);
+		return len;
+	}
+
+	sgpnt = cmd->request_buffer;
+	for (k = 0, req_len = 0, fin = 0; k < cmd->use_sg; ++k, ++sgpnt) {
+		kaddr = kmap_atomic(sgpnt->page, KM_USER0);
+		if (!kaddr)
+			return -1;
+		len = sgpnt->length;
+		if ((req_len + len) > buflen) {
+			len = buflen - req_len;
+			fin = 1;
+		}
+		memcpy(buf + req_len, kaddr + sgpnt->offset, len);
+		kunmap_atomic(kaddr, KM_USER0);
+		if (fin)
+			return req_len + len;
+		req_len += sgpnt->length;
+	}
+	return req_len;
+}
+
+static int decode_lv1_status(u64 status, unsigned char *sense_key,
+			     unsigned char *asc, unsigned char *ascq)
+{
+	if (((status >> 24) & 0xff) != SAM_STAT_CHECK_CONDITION)
+		return -1;
+
+	*sense_key = (status >> 16) & 0xff;
+	*asc       = (status >>  8) & 0xff;
+	*ascq      =  status        & 0xff;
+	return 0;
+}
+
+static inline unsigned int srb6_lba(const struct scsi_cmnd *cmd)
+{
+	BUG_ON(cmd->cmnd[1] & 0xe0);	// FIXME lun == 0
+	return cmd->cmnd[1] << 16 | cmd->cmnd[2] << 8 | cmd->cmnd[3];
+}
+
+static inline unsigned int srb6_len(const struct scsi_cmnd *cmd)
+{
+	return cmd->cmnd[4];
+}
+
+static inline unsigned int srb10_lba(const struct scsi_cmnd *cmd)
+{
+	return cmd->cmnd[2] << 24 | cmd->cmnd[3] << 16 | cmd->cmnd[4] << 8 |
+	       cmd->cmnd[5];
+}
+
+static inline unsigned int srb10_len(const struct scsi_cmnd *cmd)
+{
+	return cmd->cmnd[7] << 8 | cmd->cmnd[8];
+}
+
+static inline unsigned int cdda_raw_len(const struct scsi_cmnd *cmd)
+{
+	unsigned int nframes;
+
+	nframes = cmd->cmnd[6] << 16 | cmd->cmnd[7] <<  8 | cmd->cmnd[8];
+	return nframes * CD_FRAMESIZE_RAW;
+}
+
+static u64 ps3rom_send_atapi_command(struct ps3_storage_device *dev,
+				     struct lv1_atapi_cmnd_block *cmd)
+{
+	int res;
+	u64 lpar;
+
+	dev_dbg(&dev->sbd.core, "%s:%u: send ATAPI command 0x%02x (%s)\n",
+		__func__, __LINE__, cmd->pkt[0], scsi_command(cmd->pkt[0]));
+
+	init_completion(&dev->irq_done);
+
+	lpar = ps3_mm_phys_to_lpar(__pa(cmd));
+	res = lv1_storage_send_device_command(dev->sbd.did.dev_id,
+					      LV1_STORAGE_SEND_ATAPI_COMMAND,
+					      lpar, sizeof(*cmd), cmd->buffer,
+					      cmd->arglen, &dev->tag);
+	if (res) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: send_device_command failed %d\n", __func__,
+			__LINE__, res);
+		return -1;
+	}
+
+	wait_for_completion(&dev->irq_done);
+	if (dev->lv1_status)
+		dev_dbg(&dev->sbd.core, "%s:%u: ATAPI command failed 0x%lx\n",
+			__func__, __LINE__, dev->lv1_status);
+	else
+		dev_dbg(&dev->sbd.core, "%s:%u: ATAPI command completed\n",
+			__func__, __LINE__);
+
+	return dev->lv1_status;
+}
+
+static void ps3rom_atapi_request(struct ps3_storage_device *dev,
+				 struct scsi_cmnd *cmd, unsigned int len,
+				 int proto, int in_out, int auto_sense)
+{
+	struct lv1_atapi_cmnd_block atapi_cmnd;
+	unsigned char *cmnd = cmd->cmnd;
+	u64 status;
+	unsigned char sense_key, asc, ascq;
+
+	if (len > dev->bounce_size) {
+		static int printed;
+		if (!printed++)
+			dev_err(&dev->sbd.core,
+				"%s:%u: data size too large %u > %lu\n",
+			       __func__, __LINE__, len, dev->bounce_size);
+		cmd->result = DID_ERROR << 16;
+		memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		cmd->sense_buffer[0] = 0x70;
+		cmd->sense_buffer[2] = ILLEGAL_REQUEST;
+		return;
+	}
+
+	memset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));
+	memcpy(&atapi_cmnd.pkt, cmnd, 12);
+	atapi_cmnd.pktlen = 12;
+	atapi_cmnd.proto = proto;
+	if (in_out != DIR_NA)
+		atapi_cmnd.in_out = in_out;
+
+	if (atapi_cmnd.in_out == DIR_WRITE) {
+		// FIXME check error
+		fetch_to_dev_buffer(cmd, dev->bounce_buf, len);
+	}
+
+	atapi_cmnd.block_size = 1; /* transfer size is block_size * blocks */
+
+	atapi_cmnd.blocks = atapi_cmnd.arglen = len;
+	atapi_cmnd.buffer = dev->bounce_lpar;
+
+	status = ps3rom_send_atapi_command(dev, &atapi_cmnd);
+	if (status == -1) {
+		cmd->result = DID_ERROR << 16; /* FIXME: is better other error code ? */
+		return;
+	}
+
+	if (!status) {
+		/* OK, completed */
+		if (atapi_cmnd.in_out == DIR_READ) {
+			// FIXME check error
+			fill_from_dev_buffer(cmd, dev->bounce_buf, len);
+		}
+		cmd->result = DID_OK << 16;
+		return;
+	}
+
+	/* error */
+	if (!auto_sense) {
+		cmd->result = (DID_ERROR << 16) | (CHECK_CONDITION << 1);
+		dev_err(&dev->sbd.core, "%s:%u: end error without autosense\n",
+		       __func__, __LINE__);
+		return;
+	}
+
+	if (!decode_lv1_status(status, &sense_key, &asc, &ascq)) {
+		/* lv1 may have issued autosense ... */
+		cmd->sense_buffer[0]  = 0x70;
+		cmd->sense_buffer[2]  = sense_key;
+		cmd->sense_buffer[7]  = 16 - 6;
+		cmd->sense_buffer[12] = asc;
+		cmd->sense_buffer[13] = ascq;
+		cmd->result = SAM_STAT_CHECK_CONDITION;
+		return;
+	}
+
+	/* do auto sense by ourselves */
+	memset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));
+	atapi_cmnd.pkt[0] = REQUEST_SENSE;
+	atapi_cmnd.pkt[4] = 18;
+	atapi_cmnd.pktlen = 12;
+	atapi_cmnd.arglen = atapi_cmnd.blocks = atapi_cmnd.pkt[4];
+	atapi_cmnd.block_size = 1;
+	atapi_cmnd.proto = DMA_PROTO;
+	atapi_cmnd.in_out = DIR_READ;
+	atapi_cmnd.buffer = dev->bounce_lpar;
+
+	/* issue REQUEST_SENSE command */
+	status = ps3rom_send_atapi_command(dev, &atapi_cmnd);
+	if (status == -1) {
+		cmd->result = DID_ERROR << 16; /* FIXME: is better other error code ? */
+		return;
+	}
+
+	/* scsi spec says request sense should never get error */
+	if (status) {
+		decode_lv1_status(status, &sense_key, &asc, &ascq);
+		dev_err(&dev->sbd.core,
+			"%s:%u: auto REQUEST_SENSE error %#x %#x %#x\n",
+			__func__, __LINE__, sense_key, asc, ascq);
+	}
+
+	memcpy(cmd->sense_buffer, dev->bounce_buf,
+	       min_t(size_t, atapi_cmnd.pkt[4], SCSI_SENSE_BUFFERSIZE));
+	cmd->result = SAM_STAT_CHECK_CONDITION;
+}
+
+static void ps3rom_read_request(struct ps3_storage_device *dev,
+				struct scsi_cmnd *cmd, u32 start_sector,
+				u32 sectors)
+{
+	u64 status;
+
+	status = ps3stor_read_write_sectors(dev, dev->bounce_lpar,
+					    start_sector, sectors, 0);
+	if (status == -1) {
+		cmd->result = DID_ERROR << 16; /* FIXME: other error code? */
+		return;
+	}
+
+	if (status) {
+		memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		decode_lv1_status(dev->lv1_status, &cmd->sense_buffer[2],
+				  &cmd->sense_buffer[12],
+				  &cmd->sense_buffer[13]);
+		cmd->sense_buffer[7] = 16 - 6;	// FIXME hardcoded numbers?
+		cmd->result = SAM_STAT_CHECK_CONDITION;
+		return;
+	}
+
+	// FIXME check error
+	fill_from_dev_buffer(cmd, dev->bounce_buf, sectors * CD_FRAMESIZE);
+
+	cmd->result = DID_OK << 16;
+}
+
+static void ps3rom_write_request(struct ps3_storage_device *dev,
+				 struct scsi_cmnd *cmd, u32 start_sector,
+				 u32 sectors)
+{
+	u64 status;
+
+	// FIXME check error
+	fetch_to_dev_buffer(cmd, dev->bounce_buf, sectors * CD_FRAMESIZE);
+
+	status = ps3stor_read_write_sectors(dev, dev->bounce_lpar,
+					    start_sector, sectors, 1);
+	if (status == -1) {
+		cmd->result = DID_ERROR << 16; /* FIXME: other error code? */
+		return;
+	}
+
+	if (status) {
+		memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		decode_lv1_status(dev->lv1_status, &cmd->sense_buffer[2],
+				  &cmd->sense_buffer[12],
+				  &cmd->sense_buffer[13]);
+		cmd->sense_buffer[7] = 16 - 6;	// FIXME hardcoded numbers?
+		cmd->result = SAM_STAT_CHECK_CONDITION;
+		return;
+	}
+
+	cmd->result = DID_OK << 16;
+}
+
+static void ps3rom_request(struct ps3_storage_device *dev,
+			   struct scsi_cmnd *cmd)
+{
+	unsigned char opcode = cmd->cmnd[0];
+	struct ps3rom_private *priv = ps3rom_priv(dev);
+
+	dev_dbg(&dev->sbd.core, "%s:%u: command 0x%02x (%s)\n", __func__,
+		__LINE__, opcode, scsi_command(opcode));
+
+	switch (opcode) {
+	case INQUIRY:
+		ps3rom_atapi_request(dev, cmd, srb6_len(cmd),
+				     PIO_DATA_IN_PROTO, DIR_READ, 1);
+		break;
+
+	case REQUEST_SENSE:
+		ps3rom_atapi_request(dev, cmd, srb6_len(cmd),
+				     PIO_DATA_IN_PROTO, DIR_READ, 0);
+		break;
+
+	case ALLOW_MEDIUM_REMOVAL:
+	case START_STOP:
+	case TEST_UNIT_READY:
+		ps3rom_atapi_request(dev, cmd, 0, NON_DATA_PROTO, DIR_NA, 1);
+		break;
+
+	case READ_CAPACITY:
+		ps3rom_atapi_request(dev, cmd, 8, PIO_DATA_IN_PROTO, DIR_READ,
+				     1);
+		break;
+
+	case MODE_SENSE_10:
+	case READ_TOC:
+	case GPCMD_GET_CONFIGURATION:
+	case GPCMD_READ_DISC_INFO:
+		ps3rom_atapi_request(dev, cmd, srb10_len(cmd),
+				     PIO_DATA_IN_PROTO, DIR_READ, 1);
+		break;
+
+	case READ_6:
+		ps3rom_read_request(dev, cmd, srb6_lba(cmd), srb6_len(cmd));
+		break;
+
+	case READ_10:
+		ps3rom_read_request(dev, cmd, srb10_lba(cmd), srb10_len(cmd));
+		break;
+
+	case WRITE_6:
+		ps3rom_write_request(dev, cmd, srb6_lba(cmd), srb6_len(cmd));
+		break;
+
+	case WRITE_10:
+		ps3rom_write_request(dev, cmd, srb10_lba(cmd), srb10_len(cmd));
+		break;
+
+	case GPCMD_READ_CD:
+		ps3rom_atapi_request(dev, cmd, cdda_raw_len(cmd), DMA_PROTO,
+				     DIR_READ, 1);
+		break;
+
+	default:
+		dev_err(&dev->sbd.core, "%s:%u: illegal request 0x%02x (%s)\n",
+			__func__, __LINE__, opcode, scsi_command(opcode));
+		cmd->result = DID_ERROR << 16;
+		memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		cmd->sense_buffer[0] = 0x70;
+		cmd->sense_buffer[2] = ILLEGAL_REQUEST;
+	}
+
+	spin_lock_irq(&priv->lock);
+	priv->cmd = NULL;
+	priv->scsi_done(cmd);
+	spin_unlock_irq(&priv->lock);
+}
+
+static int ps3rom_thread(void *data)
+{
+	struct ps3_storage_device *dev = data;
+	struct ps3rom_private *priv = ps3rom_priv(dev);
+	struct scsi_cmnd *cmd;
+
+	dev_dbg(&dev->sbd.core, "%s thread init\n", __func__);
+
+	current->flags |= PF_NOFREEZE;
+
+	while (!kthread_should_stop()) {
+		spin_lock_irq(&priv->lock);
+		set_current_state(TASK_INTERRUPTIBLE);
+		cmd = priv->cmd;
+		spin_unlock_irq(&priv->lock);
+		if (!cmd) {
+			schedule();
+			continue;
+		}
+		ps3rom_request(dev, cmd);
+	}
+
+	dev_dbg(&dev->sbd.core, "%s thread exit\n", __func__);
+	return 0;
+}
+
+
+static struct scsi_host_template ps3rom_host_template = {
+	.name =			DEVICE_NAME,
+	.slave_alloc =		ps3rom_slave_alloc,
+	.slave_configure =	ps3rom_slave_configure,
+	.slave_destroy =	ps3rom_slave_destroy,
+	.queuecommand =		ps3rom_queuecommand,
+	.can_queue =		1,
+	.this_id =		7,
+	.sg_tablesize =		SG_ALL,
+	.cmd_per_lun =		1,
+	.emulated =             1,		/* only sg driver uses this */
+	.max_sectors =		PS3ROM_MAX_SECTORS,
+	.use_clustering =	ENABLE_CLUSTERING,
+	.module =		THIS_MODULE,
+};
+
+
+static int __devinit ps3rom_probe(struct ps3_system_bus_device *_dev)
+{
+	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
+	struct ps3rom_private *priv;
+	int res, error;
+	struct Scsi_Host *host;
+	struct task_struct *task;
+
+	/* special case: CD-ROM is assumed always accessible */
+	dev->accessible_regions = 1;
+
+	if (dev->blk_size != CD_FRAMESIZE) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: cannot handle block size %lu\n", __func__,
+			__LINE__, dev->blk_size);
+		return -EINVAL;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	ps3rom_priv(dev) = priv;
+	spin_lock_init(&priv->lock);
+
+	dev->bounce_size = BOUNCE_SIZE;
+	dev->bounce_buf = kmalloc(BOUNCE_SIZE, GFP_DMA);
+	if (!dev->bounce_buf) {
+		error = -ENOMEM;
+		goto fail_free_priv;
+	}
+
+	error = ps3_open_hv_device(&dev->sbd);
+	if (error) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_open_hv_device failed %d\n", __func__,
+			__LINE__, error);
+		goto fail_free_bounce;
+	}
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+						&dev->sbd.did,
+						dev->sbd.interrupt_id,
+						&dev->irq);
+	if (error) {
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_sb_event_receive_port_setup failed %d\n",
+		       __func__, __LINE__, error);
+		goto fail_close_device;
+	}
+
+	error = request_irq(dev->irq, ps3stor_interrupt, IRQF_DISABLED,
+			    DEVICE_NAME, dev);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: request_irq failed %d\n",
+			__func__, __LINE__, error);
+		goto fail_sb_event_receive_port_destroy;
+	}
+
+	dev->bounce_lpar = ps3_mm_phys_to_lpar(__pa(dev->bounce_buf));
+
+	dev->sbd.d_region = &dev->dma_region;
+	ps3_dma_region_init(&dev->dma_region, &dev->sbd.did, PS3_DMA_4K,
+			    PS3_DMA_OTHER, dev->bounce_buf,
+			    dev->bounce_size, PS3_IOBUS_SB);
+	res = ps3_dma_region_create(&dev->dma_region);
+	if (res) {
+		dev_err(&dev->sbd.core, "%s:%u: cannot create DMA region\n",
+			__func__, __LINE__);
+		error = -ENOMEM;
+		goto fail_free_irq;
+	}
+
+	dev->bounce_dma = dma_map_single(&dev->sbd.core, dev->bounce_buf,
+					 dev->bounce_size, DMA_BIDIRECTIONAL);
+	if (!dev->bounce_dma) {
+		dev_err(&dev->sbd.core, "%s:%u: map DMA region failed\n",
+			__func__, __LINE__);
+		error = -ENODEV;
+		goto fail_free_dma;
+	}
+
+	host = scsi_host_alloc(&ps3rom_host_template,
+			       sizeof(struct ps3_system_bus_device *));
+	if (!host) {
+		dev_err(&dev->sbd.core, "%s:%u: scsi_host_alloc failed\n",
+			__func__, __LINE__);
+		goto fail_unmap_dma;
+	}
+
+	priv->host = host;
+	host->hostdata[0] = (unsigned long)dev;
+
+	/* One device/LUN per SCSI bus */
+	host->max_id = 1;
+	host->max_lun = 1;
+
+	error = scsi_add_host(host, &dev->sbd.core);
+	if (error) {
+		dev_err(&dev->sbd.core, "%s:%u: scsi_host_alloc failed %d\n",
+			__func__, __LINE__, error);
+		error = -ENODEV;
+		goto fail_host_put;
+	}
+
+	task = kthread_run(ps3rom_thread, dev, DEVICE_NAME);
+	if (IS_ERR(task)) {
+		error = PTR_ERR(task);
+		goto fail_remove_host;
+	}
+	priv->thread = task;
+
+	scsi_scan_host(host);
+	return 0;
+
+fail_remove_host:
+	scsi_remove_host(host);
+fail_host_put:
+	scsi_host_put(host);
+fail_unmap_dma:
+	dma_unmap_single(&dev->sbd.core, dev->bounce_dma, dev->bounce_size,
+			 DMA_BIDIRECTIONAL);
+fail_free_dma:
+	ps3_dma_region_free(&dev->dma_region);
+fail_free_irq:
+	free_irq(dev->irq, dev);
+fail_sb_event_receive_port_destroy:
+	ps3_sb_event_receive_port_destroy(&dev->sbd.did, dev->sbd.interrupt_id,
+					  dev->irq);
+fail_close_device:
+	ps3_close_hv_device(&dev->sbd);
+fail_free_bounce:
+	kfree(dev->bounce_buf);
+fail_free_priv:
+	kfree(priv);
+	return error;
+}
+
+static int ps3rom_remove(struct ps3_system_bus_device *_dev)
+{
+	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
+	struct ps3rom_private *priv = ps3rom_priv(dev);
+	int error;
+
+	dev_dbg(&dev->sbd.core, "%s:%u\n", __func__, __LINE__);
+
+	if (priv->host) {
+		scsi_remove_host(priv->host);
+		scsi_host_put(priv->host);
+	}
+
+	if (priv->thread)
+		kthread_stop(priv->thread);
+
+	dma_unmap_single(&dev->sbd.core, dev->bounce_dma, dev->bounce_size,
+			 DMA_BIDIRECTIONAL);
+	ps3_dma_region_free(&dev->dma_region);
+
+	free_irq(dev->irq, dev);
+
+	error = ps3_sb_event_receive_port_destroy(&dev->sbd.did,
+						  dev->sbd.interrupt_id,
+						  dev->irq);
+	if (error)
+		dev_err(&dev->sbd.core,
+			"%s:%u: destroy event receive port failed %d\n",
+			__func__, __LINE__, error);
+
+	error = ps3_close_hv_device(&dev->sbd);
+	if (error)
+		dev_err(&dev->sbd.core,
+			"%s:%u: ps3_close_hv_device failed %d\n", __func__,
+			__LINE__, error);
+
+	kfree(dev->bounce_buf);
+	kfree(priv);
+	return 0;
+}
+
+
+static struct ps3_system_bus_driver ps3rom = {
+	.match_id	= PS3_MATCH_ID_STOR_ROM,
+	.core.name	= DEVICE_NAME,
+	.probe		= ps3rom_probe,
+	.remove		= ps3rom_remove
+};
+
+
+static int __init ps3rom_init(void)
+{
+	return ps3_system_bus_driver_register(&ps3rom, PS3_IOBUS_SB);
+}
+
+static void __exit ps3rom_exit(void)
+{
+	return ps3_system_bus_driver_unregister(&ps3rom);
+}
+
+module_init(ps3rom_init);
+module_exit(ps3rom_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PS3 ROM Storage Driver");
+MODULE_AUTHOR("Sony Corporation");
--- a/include/asm-powerpc/ps3.h
+++ b/include/asm-powerpc/ps3.h
@@ -440,5 +440,6 @@ struct ps3_prealloc {
 };
 
 extern struct ps3_prealloc ps3fb_videomemory;
+extern struct ps3_prealloc ps3flash_bounce_buffer;
 
 #endif
--- /dev/null
+++ b/include/asm-powerpc/ps3stor.h
@@ -0,0 +1,70 @@
+/*
+ * PS3 Storage Bus
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _ASM_POWERPC_PS3STOR_H_
+#define _ASM_POWERPC_PS3STOR_H_
+
+#include <linux/irqreturn.h>
+
+#include <asm/ps3.h>
+
+
+struct ps3_storage_region {
+	unsigned int id;
+	u64 start;
+	u64 size;
+};
+
+struct ps3_storage_device {
+	struct ps3_system_bus_device sbd;
+
+	struct ps3_dma_region dma_region;
+	unsigned int irq;
+	u64 blk_size;
+
+	u64 tag;
+	int lv1_res;
+	u64 lv1_tag;
+	u64 lv1_status;
+	struct completion irq_done;
+
+	unsigned long bounce_size;
+	void *bounce_buf;
+	u64 bounce_lpar;
+	dma_addr_t bounce_dma;
+
+	unsigned int num_regions;
+	unsigned long accessible_regions;
+	unsigned int region_idx;		/* first accessible region */
+	struct ps3_storage_region regions[0];	/* Must be last */
+};
+
+static inline struct ps3_storage_device *to_ps3_storage_device(struct device *dev)
+{
+	return container_of(dev, struct ps3_storage_device, sbd.core);
+}
+
+extern int ps3stor_probe_access(struct ps3_storage_device *dev);
+extern irqreturn_t ps3stor_interrupt(int irq, void *data);
+extern u64 ps3stor_read_write_sectors(struct ps3_storage_device *dev, u64 lpar,
+				      u64 start_sector, u64 sectors,
+				      int write);
+
+#endif /* _ASM_POWERPC_PS3STOR_H_ */
