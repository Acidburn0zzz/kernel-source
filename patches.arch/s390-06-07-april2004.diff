- Description: zfcp: System hang on adapter detach.
  Symptom:     System hangs.
  Problem:     Race between calls of qdio_shutdown and do_QDIO. This can lead
               to enqueued requests for an adapter which is detached instead
               of returning the requests with error code.
  Solution:    Eliminate race.
  Problem-ID:  9757
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/scsi/zfcp_fsf.c	15 Jun 2004 08:33:44 -0000	1.43.2.5
+++ linux-2.5/drivers/s390/scsi/zfcp_fsf.c	1 Jul 2004 09:01:45 -0000	1.43.2.6
@@ -29,7 +29,7 @@
  */
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_FSF_C_REVISION "$Revision: 1.43.2.5 $"
+#define ZFCP_FSF_C_REVISION "$Revision: 1.43.2.6 $"
 
 #include "zfcp_ext.h"
 
@@ -4779,6 +4779,16 @@
         ret = zfcp_fsf_req_sbal_get(adapter, req_flags, lock_flags);
         if(ret < 0) {
                 goto failed_sbals;
+	}
+
+	/*
+	 * We hold queue_lock here. Check if QDIOUP is set and let request fail
+	 * if it is not set (see also *_open_qdio and *_close_qdio).
+	 */
+
+	if (!atomic_test_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status)) {
+		write_unlock_irqrestore(&req_queue->queue_lock, *lock_flags);
+		goto failed_sbals;
 	}
 
 	fsf_req->adapter = adapter;	/* pointer to "parent" adapter */

--- linux-2.5/drivers/s390/scsi/zfcp_scsi.c	15 Jun 2004 08:33:44 -0000	1.59.2.4
+++ linux-2.5/drivers/s390/scsi/zfcp_scsi.c	1 Jul 2004 09:01:45 -0000	1.59.2.5
@@ -31,7 +31,7 @@
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_SCSI_REVISION "$Revision: 1.59.2.4 $"
+#define ZFCP_SCSI_REVISION "$Revision: 1.59.2.5 $"
 
 #include "zfcp_ext.h"
 
@@ -435,8 +435,8 @@
 	       scpnt->cmnd,
 	       min(scpnt->cmd_len, (unsigned char) ZFCP_ABORT_DBF_LENGTH));
 
-	ZFCP_LOG_DEBUG("aborting scsi_cmnd=%p on adapter %s\n",
-		       scpnt, zfcp_get_busid_by_adapter(adapter));
+	ZFCP_LOG_INFO("aborting scsi_cmnd=%p on adapter %s\n",
+		      scpnt, zfcp_get_busid_by_adapter(adapter));
 
 	spin_unlock_irq(scsi_host->host_lock);
 

--- linux-2.5/drivers/s390/scsi/zfcp_erp.c	19 May 2004 07:40:20 -0000	1.49.2.4
+++ linux-2.5/drivers/s390/scsi/zfcp_erp.c	1 Jul 2004 09:01:45 -0000	1.49.2.5
@@ -31,7 +31,7 @@
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_ERP
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_ERP_REVISION "$Revision: 1.49.2.4 $"
+#define ZFCP_ERP_REVISION "$Revision: 1.49.2.5 $"
 
 #include "zfcp_ext.h"
 
@@ -2286,7 +2286,6 @@
 	int i;
 	volatile struct qdio_buffer_element *sbale;
 	struct zfcp_adapter *adapter = erp_action->adapter;
-	int retval_cleanup = 0;
 
 	if (atomic_test_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status)) {
 		ZFCP_LOG_NORMAL("bug: second attempt to set up QDIO on "
@@ -2301,7 +2300,7 @@
 			      zfcp_get_busid_by_adapter(adapter));
 		goto failed_qdio_establish;
 	}
-	ZFCP_LOG_DEBUG("queues established\n");
+	debug_text_event(adapter->erp_dbf, 3, "qdio_est");
 
 	if (qdio_activate(adapter->ccw_device, 0) != 0) {
 		ZFCP_LOG_INFO("error: activation of QDIO queues failed "
@@ -2309,7 +2308,7 @@
 			      zfcp_get_busid_by_adapter(adapter));
 		goto failed_qdio_activate;
 	}
-	ZFCP_LOG_DEBUG("queues activated\n");
+	debug_text_event(adapter->erp_dbf, 3, "qdio_act");
 
 	/*
 	 * put buffers into response queue,
@@ -2357,19 +2356,15 @@
 	/* NOP */
 
  failed_qdio_activate:
-	/* DEBUG */
-	//__ZFCP_WAIT_EVENT_TIMEOUT(timeout, 0);
-	/* cleanup queues previously established */
-	retval_cleanup = qdio_shutdown(adapter->ccw_device,
-				       QDIO_FLAG_CLEANUP_USING_CLEAR);
-	if (retval_cleanup) {
-		ZFCP_LOG_NORMAL("bug: shutdown of QDIO queues failed "
-				"(retval=%d)\n", retval_cleanup);
+	debug_text_event(adapter->erp_dbf, 3, "qdio_down1a");
+	while (qdio_shutdown(adapter->ccw_device,
+			     QDIO_FLAG_CLEANUP_USING_CLEAR) == -EINPROGRESS) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ);
 	}
+	debug_text_event(adapter->erp_dbf, 3, "qdio_down1b");
 
  failed_qdio_establish:
-	atomic_clear_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status);
-
  failed_sanity:
 	retval = ZFCP_ERP_FAILED;
 
@@ -2401,42 +2396,22 @@
 		goto out;
 	}
 
-	/* cleanup queues previously established */
-
 	/*
-	 * MUST NOT LOCK - qdio_cleanup might call schedule
-	 * FIXME: need another way to make cleanup safe
-	 */
-	/* Note:
-	 * We need the request_queue lock here, otherwise there exists the 
-	 * following race:
-	 * 
-	 * queuecommand calls create_fcp_commmand_task...calls req_create, 
-	 * gets sbal x to x+y - meanwhile adapter reopen is called, completes 
-	 * - req_send calls do_QDIO for sbal x to x+y, i.e. wrong indices.
-	 *
-	 * with lock:
-	 * queuecommand calls create_fcp_commmand_task...calls req_create, 
-	 * gets sbal x to x+y - meanwhile adapter reopen is called, waits 
-	 * - req_send calls do_QDIO for sbal x to x+y, i.e. wrong indices 
-	 * but do_QDIO fails as adapter_reopen is still waiting for the lock
-	 * OR
-	 * queuecommand calls create_fcp_commmand_task...calls req_create 
-	 * - meanwhile adapter reopen is called...completes,
-	 * - gets sbal 0 to 0+y, - req_send calls do_QDIO for sbal 0 to 0+y, 
-	 * i.e. correct indices...though an fcp command is called before 
-	 * exchange config data...that should be fine, however
+	 * Get queue_lock and clear QDIOUP flag. Thus it's guaranteed that
+	 * do_QDIO won't be called while qdio_shutdown is in progress.
 	 */
-	if (qdio_shutdown(adapter->ccw_device, QDIO_FLAG_CLEANUP_USING_CLEAR)) {
-		/*
-		 * FIXME(design):
-		 * What went wrong? What to do best? Proper retval?
-		 */
-		ZFCP_LOG_NORMAL("bug: shutdown of QDIO queues failed on "
-				"adapter %s\n",
-				zfcp_get_busid_by_adapter(adapter));
-	} else
-		ZFCP_LOG_DEBUG("queues cleaned up\n");
+
+	write_lock_irq(&adapter->request_queue.queue_lock);
+	atomic_clear_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status);
+	write_unlock_irq(&adapter->request_queue.queue_lock);
+
+	debug_text_event(adapter->erp_dbf, 3, "qdio_down2a");
+	while (qdio_shutdown(adapter->ccw_device,
+			     QDIO_FLAG_CLEANUP_USING_CLEAR) == -EINPROGRESS) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ);
+	}
+	debug_text_event(adapter->erp_dbf, 3, "qdio_down2b");
 
 	/*
 	 * First we had to stop QDIO operation.
@@ -2459,8 +2434,6 @@
 	adapter->request_queue.free_index = 0;
 	atomic_set(&adapter->request_queue.free_count, 0);
 	adapter->request_queue.distance_from_int = 0;
-
-	atomic_clear_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status);
  out:
 	return retval;
 }

