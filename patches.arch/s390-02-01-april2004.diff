- Description: qeth: incorrect handling of buffer_count sysfs attribute
  Symptom:     Decimal values piped into buffer_count are treated as hex
               values. In addition, changing the buffer_count of a qeth card
               leads to a hanging network connection and addressing exception.
  Problem:     The first symptom is caused by wrong number base used in
               simple_strtoul. Second symptom is due to not freeing and
               reallocating QDIO buffers at offline/online.
  Solution:    Fixed number base for simple_strtoul in qeth_dev_bufcnt_store.
               Check new buffer_count value. If it is different from the old one
               call qeth_realloc_buffer_pool -> buffers will be freshly allocated
               using the new buffer_count.
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth.h	21 Apr 2004 15:24:04 -0000	1.98.2.1
+++ linux-2.5/drivers/s390/net/qeth.h	26 Apr 2004 16:02:02 -0000	1.98.2.2
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.98.2.1 $"
+#define VERSION_QETH_H 		"$Revision: 1.98.2.2 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -398,11 +398,6 @@
 	struct qdio_buffer qdio_bufs[QDIO_MAX_BUFFERS_PER_Q];
 	struct qeth_qdio_buffer bufs[QDIO_MAX_BUFFERS_PER_Q];
 	/* 
-	 * buf_to_process means "buffer primed by hardware,
-	 * has to be read in by driver"; current state PRIMED
-	 */
-	volatile int next_buf_to_process;
-	/*
 	 * buf_to_init means "buffer must be initialized by driver and must
 	 * be made available for hardware" -> state is set to EMPTY
 	 */
@@ -981,24 +976,27 @@
 extern int
 qeth_setrouting_v6(struct qeth_card *);
 
-int
+extern int
 qeth_add_ipato_entry(struct qeth_card *, struct qeth_ipato_entry *);
 
-void
+extern void
 qeth_del_ipato_entry(struct qeth_card *, enum qeth_prot_versions, u8 *, int);
 
-int
+extern int
 qeth_add_vipa(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 
-void
+extern void
 qeth_del_vipa(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 
-int
+extern int
 qeth_add_rxip(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 
-void
+extern void
 qeth_del_rxip(struct qeth_card *, enum qeth_prot_versions, const u8 *);
 
-void
+extern void
 qeth_schedule_recovery(struct qeth_card *);
+
+extern int
+qeth_realloc_buffer_pool(struct qeth_card *, int);
 #endif /* __QETH_H__ */

--- linux-2.5/drivers/s390/net/qeth_main.c	22 Apr 2004 15:20:46 -0000	1.77.2.4
+++ linux-2.5/drivers/s390/net/qeth_main.c	26 Apr 2004 16:34:42 -0000	1.77.2.5
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.4 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.5 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77.2.4 $	 $Date: 2004/04/22 15:20:46 $
+ *    $Revision: 1.77.2.5 $	 $Date: 2004/04/26 16:34:42 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77.2.4 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.5 $"
 static const char *version = "qeth S/390 OSA-Express driver ("
 	VERSION_QETH_C "/" VERSION_QETH_H "/" VERSION_QETH_MPC_H
 	QETH_VERSION_IPV6 QETH_VERSION_VLAN ")";
@@ -824,7 +824,7 @@
 	struct qeth_card *card;
 
 	card = (struct qeth_card *) ptr;
-	daemonize("qeth_get_mcaddrs");
+	daemonize("qeth_reg_mcaddrs");
 	QETH_DBF_TEXT(trace,4,"regmcth1");
 	if (!qeth_do_run_thread(card, QETH_SET_MC_THREAD))
 		return 0;
@@ -2677,6 +2677,7 @@
 	void *ptr;
 	int i, j;
 	
+	QETH_DBF_TEXT(trace,5,"clwkpool");
 	for (i = 0; i < card->qdio.init_pool.buf_count; ++i){
 	 	pool_entry = kmalloc(sizeof(*pool_entry), GFP_KERNEL);
 		if (!pool_entry){
@@ -2697,12 +2698,27 @@
 		}
 		list_add(&pool_entry->init_list, 
 			 &card->qdio.init_pool.entry_list);
-		list_add(&pool_entry->list, 
-			 &card->qdio.in_buf_pool.entry_list);
 	}
 	return 0;
 }
 
+int
+qeth_realloc_buffer_pool(struct qeth_card *card, int bufcnt)
+{
+	QETH_DBF_TEXT(trace, 2, "realcbp");
+
+	if ((card->state != CARD_STATE_DOWN) &&
+	    (card->state != CARD_STATE_RECOVER))
+		return -EPERM;
+
+	/* TODO: steel/add buffers from/to a running card's buffer pool (?) */
+	qeth_clear_working_pool_list(card);
+	qeth_free_buffer_pool(card);
+	card->qdio.in_buf_pool.buf_count = bufcnt;
+	card->qdio.init_pool.buf_count = bufcnt;
+	return qeth_alloc_buffer_pool(card);
+}
+
 static int
 qeth_alloc_qdio_buffers(struct qeth_card *card)
 {
@@ -2710,10 +2726,9 @@
 	
 	QETH_DBF_TEXT(setup, 2, "allcqdbf");
 
-	if (card->qdio.state == QETH_QDIO_ALLOCATED) {
-		qeth_initialize_working_pool_list(card);
+	if (card->qdio.state == QETH_QDIO_ALLOCATED)
 		return 0;
-	}
+		
 	card->qdio.in_q = kmalloc(sizeof(struct qeth_qdio_q), GFP_KERNEL);
 	if (!card->qdio.in_q)
 		return - ENOMEM;
@@ -2826,14 +2841,13 @@
 	/* inbound queue */
 	memset(card->qdio.in_q->qdio_bufs, 0,
 	       QDIO_MAX_BUFFERS_PER_Q * sizeof(struct qdio_buffer));
-	card->qdio.in_q->next_buf_to_process = 0;
-	card->qdio.in_q->next_buf_to_init = 0;
+	qeth_initialize_working_pool_list(card);
 	/*give only as many buffers to hardware as we have buffer pool entries*/
-	for (i = 0; i < card->qdio.in_buf_pool.buf_count; ++i)
+	for (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)
 		qeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);
-	card->qdio.in_q->next_buf_to_init = card->qdio.in_buf_pool.buf_count;
+	card->qdio.in_q->next_buf_to_init = card->qdio.in_buf_pool.buf_count - 1;
 	rc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0, 0,
-		     card->qdio.in_buf_pool.buf_count, NULL);
+		     card->qdio.in_buf_pool.buf_count - 1, NULL);
 	if (rc) {
 		QETH_DBF_TEXT_(setup, 2, "1err%d", rc);
 		return rc;
@@ -3982,7 +3996,12 @@
 	
 	QETH_DBF_TEXT(trace,3,"arpquery");
 
-	/* TODO: really not supported by GuestLAN? */
+	/*
+	 * currently GuestLAN  does only deliver all zeros on query arp,
+	 * even though arp processing is supported (according to IPA supp.
+	 * funcs flags); since all zeros is no valueable information,
+	 * we say EOPNOTSUPP for all ARP functions
+	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
@@ -4052,7 +4071,12 @@
 
 	QETH_DBF_TEXT(trace,3,"arpadent");
 
-	/* TODO: really not supported by GuestLAN? */
+	/*
+	 * currently GuestLAN  does only deliver all zeros on query arp,
+	 * even though arp processing is supported (according to IPA supp.
+	 * funcs flags); since all zeros is no valueable information,
+	 * we say EOPNOTSUPP for all ARP functions
+	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
@@ -4090,7 +4114,12 @@
 	
 	QETH_DBF_TEXT(trace,3,"arprment");
 	
-	/* TODO: really not supported by GuestLAN? */
+	/*
+	 * currently GuestLAN  does only deliver all zeros on query arp,
+	 * even though arp processing is supported (according to IPA supp.
+	 * funcs flags); since all zeros is no valueable information,
+	 * we say EOPNOTSUPP for all ARP functions
+	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {
@@ -4126,7 +4155,12 @@
 	
 	QETH_DBF_TEXT(trace,3,"arpflush");
 	
-	/* TODO: really not supported by GuestLAN? */
+	/*
+	 * currently GuestLAN  does only deliver all zeros on query arp,
+	 * even though arp processing is supported (according to IPA supp.
+	 * funcs flags); since all zeros is no valueable information,
+	 * we say EOPNOTSUPP for all ARP functions
+	 */
 	if (card->info.guestlan)
 		return -EOPNOTSUPP;
 	if (!qeth_is_supported(card,IPA_ARP_PROCESSING)) {

--- linux-2.5/drivers/s390/net/qeth_sys.c	22 Apr 2004 15:12:55 -0000	1.19.2.1
+++ linux-2.5/drivers/s390/net/qeth_sys.c	26 Apr 2004 16:34:43 -0000	1.19.2.2
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19.2.1 $)
+ * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19.2.2 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to sysfs.
@@ -293,7 +293,8 @@
 {
 	struct qeth_card *card = dev->driver_data;
 	char *tmp;
-	unsigned int cnt;
+	int cnt, old_cnt;
+	int rc = 0;
 	
 	if (!card)
 		return -EINVAL;
@@ -302,12 +303,15 @@
 	    (card->state != CARD_STATE_RECOVER))
 		return -EPERM;
 	
-	cnt = simple_strtoul(buf, &tmp, 16);
+	old_cnt = card->qdio.in_buf_pool.buf_count;
+	cnt = simple_strtoul(buf, &tmp, 10);
 	cnt = (cnt < QETH_IN_BUF_COUNT_MIN) ? QETH_IN_BUF_COUNT_MIN :
 		((cnt > QETH_IN_BUF_COUNT_MAX) ? QETH_IN_BUF_COUNT_MAX : cnt);
-	card->qdio.in_buf_pool.buf_count = cnt;
-	/* TODO: steel/add buffers from/to a running card's buffer pool (?) */
-
+	if (old_cnt != cnt) {
+		if ((rc = qeth_realloc_buffer_pool(card, cnt)))
+				PRINT_WARN("Error (%d) while setting "
+					   "buffer count.\n", rc);
+	}
 	return count;
 }
 
@@ -572,7 +576,6 @@
 
 static DEVICE_ATTR(recover, 0200, NULL, qeth_dev_recover_store);
 
-/* TODO */
 static ssize_t
 qeth_dev_broadcast_mode_show(struct device *dev, char *buf)
 {
@@ -590,7 +593,6 @@
 		       "all rings":"local");
 }
 
-/* TODO */
 static ssize_t
 qeth_dev_broadcast_mode_store(struct device *dev, const char *buf, size_t count)
 {
@@ -629,7 +631,6 @@
 static DEVICE_ATTR(broadcast_mode, 0644, qeth_dev_broadcast_mode_show,
 		   qeth_dev_broadcast_mode_store);
 
-/* TODO */
 static ssize_t
 qeth_dev_canonical_macaddr_show(struct device *dev, char *buf)
 {
@@ -646,7 +647,6 @@
 				     QETH_TR_MACADDR_CANONICAL)? 1:0);
 }
 
-/* TODO */
 static ssize_t
 qeth_dev_canonical_macaddr_store(struct device *dev, const char *buf,
 				  size_t count)

