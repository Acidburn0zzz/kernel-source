Fix dentry reference counting (from 2.6.3-mm3).

diffstat:
 fs/sysfs/dir.c   |   13 ++++++++-----
 fs/sysfs/group.c |    5 +++--
 2 files changed, 11 insertions(+), 7 deletions(-)

diff -urN linux-2.6/fs/sysfs/dir.c linux-2.6-s390/fs/sysfs/dir.c
--- linux-2.6/fs/sysfs/dir.c	Wed Feb 18 04:57:32 2004
+++ linux-2.6-s390/fs/sysfs/dir.c	Mon Mar  1 16:35:56 2004
@@ -96,6 +96,8 @@
 void sysfs_remove_subdir(struct dentry * d)
 {
 	remove_dir(d);
+	/* release the "extra" ref taken during sysfs_create() */
+	dput(d);
 }
 
 
@@ -120,13 +122,14 @@
 	down(&dentry->d_inode->i_sem);
 
 	spin_lock(&dcache_lock);
+restart:
 	node = dentry->d_subdirs.next;
 	while (node != &dentry->d_subdirs) {
 		struct dentry * d = list_entry(node,struct dentry,d_child);
-		list_del_init(node);
 
+		node = node->next;
 		pr_debug(" o %s (%d): ",d->d_name.name,atomic_read(&d->d_count));
-		if (d->d_inode) {
+		if (!d_unhashed(d) && (d->d_inode)) {
 			d = dget_locked(d);
 			pr_debug("removing");
 
@@ -137,12 +140,12 @@
 			d_delete(d);
 			simple_unlink(dentry->d_inode,d);
 			dput(d);
+			pr_debug(" done\n");
 			spin_lock(&dcache_lock);
+			/* re-acquired dcache_lock, need to restart */
+			goto restart;
 		}
-		pr_debug(" done\n");
-		node = dentry->d_subdirs.next;
 	}
-	list_del_init(&dentry->d_child);
 	spin_unlock(&dcache_lock);
 	up(&dentry->d_inode->i_sem);
 
diff -urN linux-2.6/fs/sysfs/group.c linux-2.6-s390/fs/sysfs/group.c
--- linux-2.6/fs/sysfs/group.c	Wed Feb 18 04:58:11 2004
+++ linux-2.6-s390/fs/sysfs/group.c	Mon Mar  1 16:35:56 2004
@@ -68,12 +68,13 @@
 	if (grp->name)
 		dir = sysfs_get_dentry(kobj->dentry,grp->name);
 	else
-		dir = kobj->dentry;
+		dir = dget(kobj->dentry);
 
 	remove_files(dir,grp);
-	dput(dir);
 	if (grp->name)
 		sysfs_remove_subdir(dir);
+	/* release the ref. taken in this routine */
+	dput(dir);
 }
 
 
