From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: Fix zfcp problems that have been found
References: bnc#434333

Symptom:     lock dependency warnings and flaws found during code review
Problem:     various small zfcp problems
Solution:    fix zfcp problems
	     	 - SCSI command times out on "deleted scsi device"
		 - fix memory leak for status_read requests
		 - locking for req_list
		 - fix error path for failed request send

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/scsi/zfcp_fsf.c  |   23 ++++++++++-------------
 drivers/s390/scsi/zfcp_scsi.c |   12 ++++--------
 2 files changed, 14 insertions(+), 21 deletions(-)

--- a/drivers/s390/scsi/zfcp_scsi.c	2008-10-15 16:39:08.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_scsi.c	2008-10-15 16:39:08.000000000 +0200
@@ -26,14 +26,10 @@ char *zfcp_get_fcp_sns_info_ptr(struct f
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
-	WARN_ON(!unit);
-	if (unit) {
-		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
-		sdpnt->hostdata = NULL;
-		unit->device = NULL;
-		zfcp_erp_unit_failed(unit, 12, NULL);
-		zfcp_unit_put(unit);
-	}
+	atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
+	unit->device = NULL;
+	zfcp_erp_unit_failed(unit, 12, NULL);
+	zfcp_unit_put(unit);
 }
 
 static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
--- a/drivers/s390/scsi/zfcp_fsf.c	2008-10-15 16:39:08.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_fsf.c	2008-10-15 16:40:11.000000000 +0200
@@ -685,6 +685,7 @@ static struct zfcp_fsf_req *zfcp_fsf_all
 	if (!req)
 		return NULL;
 	memset(req, 0, sizeof(*req));
+	req->pool = pool;
 	return req;
 }
 
@@ -771,28 +772,24 @@ static struct zfcp_fsf_req *zfcp_fsf_req
 static int zfcp_fsf_req_send(struct zfcp_fsf_req *req)
 {
 	struct zfcp_adapter *adapter = req->adapter;
-	struct zfcp_qdio_queue *req_q = &adapter->req_q;
+	unsigned long flags;
 	int idx;
 
 	/* put allocated FSF request into hash table */
-	spin_lock(&adapter->req_list_lock);
+	spin_lock_irqsave(&adapter->req_list_lock, flags);
 	idx = zfcp_reqlist_hash(req->req_id);
 	list_add_tail(&req->list, &adapter->req_list[idx]);
-	spin_unlock(&adapter->req_list_lock);
+	spin_unlock_irqrestore(&adapter->req_list_lock, flags);
 
-	req->qdio_outb_usage = atomic_read(&req_q->count);
+	req->qdio_outb_usage = atomic_read(&adapter->req_q.count);
 	req->issued = get_clock();
 	if (zfcp_qdio_send(req)) {
-		/* Queues are down..... */
 		del_timer(&req->timer);
-		spin_lock(&adapter->req_list_lock);
-		zfcp_reqlist_remove(adapter, req);
-		spin_unlock(&adapter->req_list_lock);
-		/* undo changes in request queue made for this request */
-		atomic_add(req->sbal_number, &req_q->count);
-		req_q->first -= req->sbal_number;
-		req_q->first += QDIO_MAX_BUFFERS_PER_Q;
-		req_q->first %= QDIO_MAX_BUFFERS_PER_Q; /* wrap */
+		spin_lock_irqsave(&adapter->req_list_lock, flags);
+		/* lookup request again, list might have changed */
+		if (zfcp_reqlist_find_safe(adapter, req))
+			zfcp_reqlist_remove(adapter, req);
+		spin_unlock_irqrestore(&adapter->req_list_lock, flags);
 		zfcp_erp_adapter_reopen(adapter, 0, 116, req);
 		return -EIO;
 	}
