diffstat:
 drivers/s390/block/dasd.c     |   25 ++--
 drivers/s390/block/dasd_int.h |    4 
 drivers/s390/char/con3215.c   |    4 
 drivers/s390/char/raw3270.c   |   28 ++--
 drivers/s390/char/tape.h      |    2 
 drivers/s390/char/tape_core.c |    3 
 drivers/s390/cio/ccwgroup.c   |   14 +-
 drivers/s390/cio/chsc.c       |  245 ++++++++++++++++++++++++------------------
 drivers/s390/cio/cio.c        |   41 +++++--
 drivers/s390/cio/cio.h        |    4 
 drivers/s390/cio/css.c        |  214 ++++++++++++++++++++++++++----------
 drivers/s390/cio/css.h        |    3 
 drivers/s390/cio/device.c     |   50 +++++++-
 drivers/s390/net/ctcmain.c    |   11 -
 drivers/s390/net/lcs.c        |    9 -
 drivers/s390/net/qeth.c       |    5 
 drivers/s390/s390mach.c       |   26 +++-
 drivers/s390/scsi/zfcp_ccw.c  |    6 -
 include/asm-s390/ccwdev.h     |    2 
 include/asm-s390/ccwgroup.h   |    5 
 include/asm-s390/cio.h        |    8 +
 21 files changed, 476 insertions(+), 233 deletions(-)

diff -urN linux-2.6/drivers/s390/block/dasd.c linux-2.6-s390/drivers/s390/block/dasd.c
--- linux-2.6/drivers/s390/block/dasd.c	Thu Nov 13 15:29:41 2003
+++ linux-2.6-s390/drivers/s390/block/dasd.c	Thu Nov 13 15:35:25 2003
@@ -1747,15 +1747,16 @@
 
 /* this will one day be called from a global not_oper handler.
  * It is also used by driver_unregister during module unload */
-int
+void
 dasd_generic_remove (struct ccw_device *cdev)
 {
-	/*
-	 * Nothing to remove. set_offline already removes the
-	 * dasd_device structure and the devmap information
-	 * is persistent.
-	 */
-	return 0;
+	struct dasd_device *device;
+
+	device = dasd_device_from_cdev(cdev);
+	if (!IS_ERR(device)) {
+		dasd_set_target_state(device, DASD_STATE_NEW);
+		dasd_delete_device(device);
+	}
 }
 
 /* activate a device. This is called from dasd_{eckd,fba}_probe() when either
@@ -1811,9 +1812,13 @@
 	struct dasd_device *device;
 
 	device = dasd_device_from_cdev(cdev);
-	dasd_set_target_state(device, DASD_STATE_NEW);
-	dasd_delete_device(device);
-	
+	if (atomic_read(&device->open_count) > 0) {
+		printk (KERN_WARNING "Can't offline dasd device with open"
+			" count = %i.\n",
+			atomic_read(&device->open_count));
+		return -EBUSY;
+	}
+	dasd_generic_remove (cdev);
 	return 0;
 }
 
diff -urN linux-2.6/drivers/s390/block/dasd_int.h linux-2.6-s390/drivers/s390/block/dasd_int.h
--- linux-2.6/drivers/s390/block/dasd_int.h	Thu Nov 13 15:29:41 2003
+++ linux-2.6-s390/drivers/s390/block/dasd_int.h	Thu Nov 13 15:35:25 2003
@@ -6,7 +6,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.49 $
+ * $Revision: 1.50 $
  */
 
 #ifndef DASD_INT_H
@@ -458,7 +458,7 @@
 void dasd_clear_timer(struct dasd_device *);
 int  dasd_cancel_req(struct dasd_ccw_req *);
 int dasd_generic_probe (struct ccw_device *, struct dasd_discipline *);
-int dasd_generic_remove (struct ccw_device *cdev);
+void dasd_generic_remove (struct ccw_device *cdev);
 int dasd_generic_set_online(struct ccw_device *, struct dasd_discipline *);
 int dasd_generic_set_offline (struct ccw_device *cdev);
 void dasd_generic_auto_online (struct ccw_driver *);
diff -urN linux-2.6/drivers/s390/char/con3215.c linux-2.6-s390/drivers/s390/char/con3215.c
--- linux-2.6/drivers/s390/char/con3215.c	Thu Nov 13 15:29:43 2003
+++ linux-2.6-s390/drivers/s390/char/con3215.c	Thu Nov 13 15:35:25 2003
@@ -721,11 +721,12 @@
 	return 0;
 }
 
-static int
+static void
 raw3215_remove (struct ccw_device *cdev)
 {
 	struct raw3215_info *raw;
 
+	ccw_device_set_offline(cdev);
 	raw = cdev->dev.driver_data;
 	if (raw) {
 		cdev->dev.driver_data = NULL;
@@ -733,7 +734,6 @@
 			kfree(raw->buffer);
 		kfree(raw);
 	}
-	return 0;
 }
 
 static int
diff -urN linux-2.6/drivers/s390/char/raw3270.c linux-2.6-s390/drivers/s390/char/raw3270.c
--- linux-2.6/drivers/s390/char/raw3270.c	Thu Nov 13 15:35:25 2003
+++ linux-2.6-s390/drivers/s390/char/raw3270.c	Thu Nov 13 15:35:25 2003
@@ -1060,12 +1060,6 @@
 	return 0;
 }
 
-static int
-raw3270_remove (struct ccw_device *cdev)
-{
-	return 0;
-}
-
 /*
  * Additional attributes for a 3270 device
  */
@@ -1134,18 +1128,16 @@
 }
 
 /*
- * Set 3270 device offline.
+ * Remove 3270 device structure.
  */
-static int
-raw3270_set_offline (struct ccw_device *cdev)
+static void
+raw3270_remove (struct ccw_device *cdev)
 {
 	unsigned long flags;
 	struct raw3270 *rp;
 	struct raw3270_view *v;
 
 	rp = cdev->dev.driver_data;
-	if (test_bit(RAW3270_FLAGS_CONSOLE, &rp->flags))
-		return -EBUSY;
 	set_bit(RAW3270_FLAGS_SHUTDOWN, &rp->flags);
 
 	sysfs_remove_group(&cdev->dev.kobj, &raw3270_attr_group);
@@ -1172,6 +1164,20 @@
 	raw3270_reset_device(rp);
 	/* And finally remove it. */
 	raw3270_delete_device(rp);
+}
+
+/*
+ * Set 3270 device offline.
+ */
+static int
+raw3270_set_offline (struct ccw_device *cdev)
+{
+	struct raw3270 *rp;
+
+	rp = cdev->dev.driver_data;
+	if (test_bit(RAW3270_FLAGS_CONSOLE, &rp->flags))
+		return -EBUSY;
+	raw3270_remove(cdev);
 	return 0;
 }
 
diff -urN linux-2.6/drivers/s390/char/tape.h linux-2.6-s390/drivers/s390/char/tape.h
--- linux-2.6/drivers/s390/char/tape.h	Thu Nov 13 15:29:41 2003
+++ linux-2.6-s390/drivers/s390/char/tape.h	Thu Nov 13 15:35:25 2003
@@ -261,7 +261,7 @@
 
 /* Externals from tape_devmap.c */
 extern int tape_generic_probe(struct ccw_device *);
-extern int tape_generic_remove(struct ccw_device *);
+extern void tape_generic_remove(struct ccw_device *);
 
 extern struct tape_device *tape_get_device(int devindex);
 extern struct tape_device *tape_get_device_reference(struct tape_device *);
diff -urN linux-2.6/drivers/s390/char/tape_core.c linux-2.6-s390/drivers/s390/char/tape_core.c
--- linux-2.6/drivers/s390/char/tape_core.c	Thu Nov 13 15:29:41 2003
+++ linux-2.6-s390/drivers/s390/char/tape_core.c	Thu Nov 13 15:35:25 2003
@@ -499,9 +499,10 @@
 /*
  * Driverfs tape remove function.
  */
-int
+void
 tape_generic_remove(struct ccw_device *cdev)
 {
+	ccw_device_set_offline(cdev);
 	if (cdev->dev.driver_data != NULL) {
 		sysfs_remove_group(&cdev->dev.kobj, &tape_attr_group);
 		cdev->dev.driver_data = tape_put_device(cdev->dev.driver_data);
diff -urN linux-2.6/drivers/s390/cio/ccwgroup.c linux-2.6-s390/drivers/s390/cio/ccwgroup.c
--- linux-2.6/drivers/s390/cio/ccwgroup.c	Sat Oct 25 20:43:49 2003
+++ linux-2.6-s390/drivers/s390/cio/ccwgroup.c	Thu Nov 13 15:35:25 2003
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/ccwgroup.c
  *  bus driver for ccwgroup
- *   $Revision: 1.17 $
+ *   $Revision: 1.18 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *                       IBM Corporation
@@ -337,7 +337,6 @@
 {
 	struct ccwgroup_device *gdev;
 	struct ccwgroup_driver *gdrv;
-	int ret;
 
 	gdev = to_ccwgroupdev(dev);
 	gdrv = to_ccwgroupdrv(dev->driver);
@@ -347,9 +346,9 @@
 	device_remove_file(dev, &dev_attr_online);
 	ccwgroup_set_offline(gdev);
 
-	ret = (gdrv && gdrv->remove) ? gdrv->remove(gdev) : 0;
-
-	return ret;
+	if (gdrv && gdrv->remove)
+		gdrv->remove(gdev);
+	return 0;
 }
 
 int
@@ -418,20 +417,21 @@
 	return gdev;
 }
 
-int
+void
 ccwgroup_remove_ccwdev(struct ccw_device *cdev)
 {
 	struct ccwgroup_device *gdev;
 
+	ccw_device_set_offline(cdev);
 	/* If one of its devices is gone, the whole group is done for. */
 	gdev = __ccwgroup_get_gdev_by_cdev(cdev);
 	if (gdev) {
+		// FIXME: ccwgroup_set_offline returns a status which is ignored
 		ccwgroup_set_offline(gdev);
 		__ccwgroup_remove_symlinks(gdev);
 		device_unregister(&gdev->dev);
 		put_device(&gdev->dev);
 	}
-	return 0;
 }
 
 MODULE_LICENSE("GPL");
diff -urN linux-2.6/drivers/s390/cio/chsc.c linux-2.6-s390/drivers/s390/cio/chsc.c
--- linux-2.6/drivers/s390/cio/chsc.c	Thu Nov 13 15:29:39 2003
+++ linux-2.6-s390/drivers/s390/cio/chsc.c	Thu Nov 13 15:35:25 2003
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/chsc.c
  *   S/390 common I/O routines -- channel subsystem call
- *   $Revision: 1.78 $
+ *   $Revision: 1.85 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -73,7 +73,7 @@
 /* FIXME: this is _always_ called for every subchannel. shouldn't we
  *	  process more than one at a time? */
 static int
-chsc_get_sch_desc_irq(int irq, void *page)
+chsc_get_sch_desc_irq(struct subchannel *sch, void *page)
 {
 	int ccode, chpid, j;
 
@@ -106,8 +106,8 @@
 		.code   = 0x0004,
 	};
 
-	ssd_area->f_sch = irq;
-	ssd_area->l_sch = irq;
+	ssd_area->f_sch = sch->irq;
+	ssd_area->l_sch = sch->irq;
 
 	ccode = chsc(ssd_area);
 	if (ccode > 0) {
@@ -162,12 +162,9 @@
 		const char *type[4] = {"I/O", "chsc", "message", "ADM"};
 		CIO_CRW_EVENT(6, "ssd: sch %s is %s subchannel\n",
 			      sch->dev.bus_id, type[ssd_area->st]);
-		if (ioinfo[irq] == NULL)
-			/* FIXME: we should do device rec. here... */
-			return 0;
 
-		ioinfo[irq]->ssd_info.valid = 1;
-		ioinfo[irq]->ssd_info.type = ssd_area->st;
+		sch->ssd_info.valid = 1;
+		sch->ssd_info.type = ssd_area->st;
 	}
 
 	if (ssd_area->st == 0 || ssd_area->st == 2) {
@@ -181,18 +178,60 @@
 			    && (test_bit (chpid, chpids_logical)))
 				set_bit	 (chpid, chpids);
 
-			ioinfo[irq]->ssd_info.chpid[j] = chpid;
-			ioinfo[irq]->ssd_info.fla[j]   = ssd_area->fla[j];
+			sch->ssd_info.chpid[j] = chpid;
+			sch->ssd_info.fla[j]   = ssd_area->fla[j];
 		}
 	}
-
 	return 0;
 }
 
+int
+css_get_ssd_info(struct subchannel *sch)
+{
+	int ret;
+	void *page;
+
+	page = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);
+	if (!page)
+		return -ENOMEM;
+	spin_lock_irq(&sch->lock);
+	ret = chsc_get_sch_desc_irq(sch, page);
+	spin_unlock_irq(&sch->lock);
+	free_page((unsigned long)page);
+	return ret;
+}
+
+static int
+__chsc_get_sch_desc(struct device *dev, void *page)
+{
+	struct subchannel *sch;
+	unsigned long flags;
+	int err;
+
+	sch = to_subchannel(dev);
+	spin_lock_irqsave(&sch->lock, flags);
+	err = chsc_get_sch_desc_irq(sch, page);
+	if (err) {
+		static int cio_chsc_err_msg;
+		
+		if (!cio_chsc_err_msg) {
+			printk(KERN_ERR
+			       "chsc_get_sch_descriptions:"
+			       " Error %d while doing chsc; "
+			       "processing some machine checks may "
+			       "not work\n", err);
+			cio_chsc_err_msg = 1;
+		}
+	}
+	clear_page(page);
+	spin_unlock_irqrestore(&sch->lock, flags);
+	return err;
+}
+
+
 static int
 chsc_get_sch_descriptions(void)
 {
-	int irq;
 	int err;
 	void *page;
 
@@ -205,30 +244,11 @@
 	page = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);
 	if (!page)
 		return -ENOMEM;
-
-	err = 0;
-	for (irq = 0; irq <= highest_subchannel; irq++) {
-		/*
-		 * retrieve information for each sch
-		 */
-		err = chsc_get_sch_desc_irq(irq, page);
-		if (err) {
-			static int cio_chsc_err_msg;
-
-			if (!cio_chsc_err_msg) {
-				printk(KERN_ERR
-				       "chsc_get_sch_descriptions:"
-				       " Error %d while doing chsc; "
-				       "processing some machine checks may "
-				       "not work\n", err);
-				cio_chsc_err_msg = 1;
-			}
-			goto out;
-		}
-		clear_page(page);
-	}
+	/*
+	 * Retrieve information for each sch that is registered.
+	 */
+	err = bus_for_each_dev(&css_bus_type, NULL, page, __chsc_get_sch_desc);
 	cio_chsc_desc_avail = 1;
-out:
 	free_page((unsigned long)page);
 	return err;
 }
@@ -236,17 +256,21 @@
 __initcall(chsc_get_sch_descriptions);
 
 
-static inline void
-s390_subchannel_remove_chpid(struct subchannel *sch, __u8 chpid)
+static int
+s390_subchannel_remove_chpid(struct device *dev, void *data)
 {
 	int j;
 	int mask;
+	struct subchannel *sch;
+	__u8 *chpid;
 
+	sch = to_subchannel(dev);
+	chpid = data;
 	for (j = 0; j < 8; j++)
-		if (sch->schib.pmcw.chpid[j] == chpid)
+		if (sch->schib.pmcw.chpid[j] == *chpid)
 			break;
 	if (j >= 8)
-		return;
+		return 0;
 
 	mask = 0x80 >> j;
 	spin_lock(&sch->lock);
@@ -254,10 +278,9 @@
 	chsc_validate_chpids(sch);
 
 	stsch(sch->irq, &sch->schib);
-	if (sch->vpm == mask) {
-		dev_fsm_event(sch->dev.driver_data, DEV_EVENT_NOTOPER);
-		goto out_unlock;
-	}
+	if (sch->vpm == mask)
+		goto out_unreg;
+
 	if ((sch->schib.scsw.actl & (SCSW_ACTL_CLEAR_PEND |
 				     SCSW_ACTL_HALT_PEND |
 				     SCSW_ACTL_START_PEND |
@@ -265,20 +288,15 @@
 	    (sch->schib.pmcw.lpum == mask)) {
 		int cc = cio_cancel(sch);
 		
-		if (cc == -ENODEV) {
-			dev_fsm_event(sch->dev.driver_data, DEV_EVENT_NOTOPER);
-			goto out_unlock;
-		}
+		if (cc == -ENODEV)
+			goto out_unreg;
 
 		if (cc == -EINVAL) {
 			struct ccw_device *cdev;
 
 			cc = cio_clear(sch);
-			if (cc == -ENODEV) {
-				dev_fsm_event(sch->dev.driver_data,
-					      DEV_EVENT_NOTOPER);
-				goto out_unlock;
-			}
+			if (cc == -ENODEV)
+				goto out_unreg;
 			/* Call handler. */
 			cdev = sch->dev.driver_data;
 			cdev->private->state = DEV_STATE_CLEAR_VERIFY;
@@ -294,10 +312,8 @@
 		int cc;
 
 		cc = cio_clear(sch);
-		if (cc == -ENODEV) {
-			dev_fsm_event(sch->dev.driver_data, DEV_EVENT_NOTOPER);
-			goto out_unlock;
-		}
+		if (cc == -ENODEV)
+			goto out_unreg;
 		/* Call handler. */
 		cdev = sch->dev.driver_data;
 		cdev->private->state = DEV_STATE_CLEAR_VERIFY;
@@ -311,15 +327,19 @@
 	dev_fsm_event(sch->dev.driver_data, DEV_EVENT_VERIFY);
 out_unlock:
 	spin_unlock(&sch->lock);
+	return 0;
+out_unreg:
+	spin_unlock(&sch->lock);
+	device_unregister(&sch->dev);
+	sch->schib.pmcw.intparm = 0;
+	cio_modify(sch);
+	return 0;
 }
 
-/* FIXME: don't iterate all subchannels but use driver_for_each_dev */
 static inline void
 s390_set_chpid_offline( __u8 chpid)
 {
 	char dbf_txt[15];
-	struct subchannel *sch;
-	int irq;
 
 	sprintf(dbf_txt, "chpr%x", chpid);
 	CIO_TRACE_EVENT(2, dbf_txt);
@@ -330,18 +350,8 @@
 
 	set_chp_status(chpid, CHP_OFFLINE);
 
-#if 0
-	driver_for_each_dev(io_subchannel_driver, chpid, s390_subchannel_remove_chpid);
-#else
-
-	for (irq = 0; irq <= highest_subchannel; irq++) {
-		sch = ioinfo[irq];
-		if (sch == NULL)
-			continue;  /* we don't know the device anyway */
-
-		s390_subchannel_remove_chpid(sch, chpid);
-	}
-#endif
+	bus_for_each_dev(&css_bus_type, NULL, &chpid,
+			 s390_subchannel_remove_chpid);
 }
 
 static int
@@ -353,7 +363,7 @@
 	int ccode;
 	
 	/* Update our ssd_info */
-	if (chsc_get_sch_desc_irq(sch->irq, page))
+	if (chsc_get_sch_desc_irq(sch, page))
 		return 0;
 	
 	found = 0;
@@ -417,7 +427,7 @@
 	for (irq = 0; irq < __MAX_SUBCHANNELS; irq++) {
 		int chp_mask;
 
-		sch = ioinfo[irq];
+		sch = get_subchannel_by_schid(irq);
 		if (!sch) {
 			/*
 			 * We don't know the device yet, but since a path
@@ -460,7 +470,7 @@
 		dev_fsm_event(sch->dev.driver_data, DEV_EVENT_VERIFY);
 
 		spin_unlock_irq(&sch->lock);
-
+		put_device(&sch->dev);
 		if (fla_mask != 0)
 			break;
 	}
@@ -663,7 +673,7 @@
 	for (irq = 0; irq < __MAX_SUBCHANNELS; irq++) {
 		int i;
 
-		sch = ioinfo[irq];
+		sch = get_subchannel_by_schid(irq);
 		if (!sch) {
 			ret = css_probe_device(irq);
 			if (ret == -ENXIO)
@@ -696,6 +706,7 @@
 		dev_fsm_event(sch->dev.driver_data, DEV_EVENT_VERIFY);
 
 		spin_unlock(&sch->lock);
+		put_device(&sch->dev);
 	}
 }
 
@@ -722,6 +733,57 @@
 	}
 }
 
+static inline void
+__s390_subchannel_vary_chpid(struct subchannel *sch, __u8 chpid, int on)
+{
+	int chp;
+
+	/*
+	 * We don't need to adjust the lpm, as this will be done in
+	 * DevicePathVerification...
+	 */
+	if (!sch->ssd_info.valid)
+		return;
+	
+	for (chp = 0; chp < 8; chp++) {
+		if (sch->ssd_info.chpid[chp] == chpid) {
+			if (on)
+				sch->lpm |= (0x80 >> chp);
+			else
+				sch->lpm &= ~(0x80 >> chp);
+			dev_fsm_event(sch->dev.driver_data,
+				      DEV_EVENT_VERIFY);
+			break;
+		}
+	}
+}
+
+static int
+s390_subchannel_vary_chpid_off(struct device *dev, void *data)
+{
+	struct subchannel *sch;
+	__u8 *chpid;
+
+	sch = to_subchannel(dev);
+	chpid = data;
+
+	__s390_subchannel_vary_chpid(sch, *chpid, 0);
+	return 0;
+}
+
+static int
+s390_subchannel_vary_chpid_on(struct device *dev, void *data)
+{
+	struct subchannel *sch;
+	__u8 *chpid;
+
+	sch = to_subchannel(dev);
+	chpid = data;
+
+	__s390_subchannel_vary_chpid(sch, *chpid, 1);
+	return 0;
+}
+
 /*
  * Function: s390_vary_chpid
  * Varies the specified chpid online or offline
@@ -730,8 +792,6 @@
 s390_vary_chpid( __u8 chpid, int on)
 {
 	char dbf_text[15];
-	struct subchannel *sch;
-	int irq;
 
 	sprintf(dbf_text, on?"varyon%x":"varyoff%x", chpid);
 	CIO_TRACE_EVENT( 2, dbf_text);
@@ -768,28 +828,9 @@
 	 * Redo PathVerification on the devices the chpid connects to
 	 */
 
-	for (irq = 0; irq <= highest_subchannel; irq++) {
-		int chp;
-		/*
-		 * We don't need to adjust the lpm, as this will be done in
-		 * DevicePathVerification...
-		 */
-		sch = ioinfo[irq];
-		if (sch == NULL || sch->st || !sch->ssd_info.valid)
-			continue;
-
-		for (chp = 0; chp < 8; chp++) {
-			if (sch->ssd_info.chpid[chp] == chpid) {
-				if (on)
-					sch->lpm |= (0x80 >> chp);
-				else
-					sch->lpm &= ~(0x80 >> chp);
-				dev_fsm_event(sch->dev.driver_data,
-					      DEV_EVENT_VERIFY);
-				break;
-			}
-		}
-	}
+	bus_for_each_dev(&css_bus_type, NULL, &chpid, on ?
+			 s390_subchannel_vary_chpid_on :
+			 s390_subchannel_vary_chpid_off);
 	return 0;
 }
 
@@ -847,6 +888,10 @@
 static void
 chp_release(struct device *dev)
 {
+	struct channel_path *cp;
+	
+	cp = container_of(dev, struct channel_path, dev);
+	kfree(cp);
 }
 
 /*
diff -urN linux-2.6/drivers/s390/cio/cio.c linux-2.6-s390/drivers/s390/cio/cio.c
--- linux-2.6/drivers/s390/cio/cio.c	Thu Nov 13 15:29:39 2003
+++ linux-2.6-s390/drivers/s390/cio/cio.c	Thu Nov 13 15:35:25 2003
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/cio.c
  *   S/390 common I/O routines -- low level i/o calls
- *   $Revision: 1.106 $
+ *   $Revision: 1.112 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -147,7 +147,7 @@
 	if (tsch (tpi_info->irq, irb) != 0)
 		/* Not status pending or not operational. */
 		return 1;
-	sch = ioinfo[tpi_info->irq];
+	sch = (struct subchannel *)(unsigned long)tpi_info->intparm;
 	if (!sch)
 		return 1;
 	irq_enter ();
@@ -193,7 +193,8 @@
 	CIO_TRACE_EVENT (4, "stIO");
 	CIO_TRACE_EVENT (4, sch->dev.bus_id);
 
-	sch->orb.intparm = intparm;
+	/* sch is always under 2G. */
+	sch->orb.intparm = (__u32)(unsigned long)sch;
 	sch->orb.fmt = 1;
 
 	sch->orb.pfch = sch->options.prefetch == 0;
@@ -374,7 +375,7 @@
  * Function: cio_modify
  * Issues a "Modify Subchannel" on the specified subchannel
  */
-static int
+int
 cio_modify (struct subchannel *sch)
 {
 	int ccode, retry, ret;
@@ -420,6 +421,7 @@
 
 	sch->schib.pmcw.ena = 1;
 	sch->schib.pmcw.isc = isc;
+	sch->schib.pmcw.intparm = (__u32)(unsigned long)sch;
 	for (retry = 5, ret = 0; retry > 0; retry--) {
 		ret = cio_modify(sch);
 		if (ret == -ENODEV)
@@ -587,7 +589,6 @@
 	sch->schib.pmcw.isc = 3;	/* could be smth. else */
 	sch->schib.pmcw.csense = 1;	/* concurrent sense */
 	sch->schib.pmcw.ena = 0;
-	sch->schib.pmcw.intparm = sch->schib.pmcw.dev;
 	if ((sch->lpm & (sch->lpm - 1)) != 0)
 		sch->schib.pmcw.mp = 1;	/* multipath mode */
 	return 0;
@@ -624,7 +625,7 @@
 			do_adapter_IO();
 			continue;
 		}
-		sch = ioinfo[tpi_info->irq];
+		sch = (struct subchannel *)(unsigned long)tpi_info->intparm;
 		if (sch)
 			spin_lock(&sch->lock);
 		/* Store interrupt response block to lowcore. */
@@ -745,16 +746,40 @@
 	 */
 	ctl_set_bit(6, 24);
 	console_subchannel.schib.pmcw.isc = 7;
-	ioinfo[irq] = &console_subchannel;
+	console_subchannel.schib.pmcw.intparm =
+		(__u32)(unsigned long)&console_subchannel;
+	ret = cio_modify(&console_subchannel);
+	if (ret) {
+		console_subchannel_in_use = 0;
+		return ERR_PTR(ret);
+	}
 	return &console_subchannel;
 }
 
 void
 cio_release_console(void)
 {
-	ioinfo[console_subchannel.irq] = NULL;
+	console_subchannel.schib.pmcw.intparm = 0;
+	cio_modify(&console_subchannel);
 	ctl_clear_bit(6, 24);
 	console_subchannel_in_use = 0;
 }
 
+/* Bah... hack to catch console special sausages. */
+int
+cio_is_console(int irq)
+{
+	if (!console_subchannel_in_use)
+		return 0;
+	return (irq == console_subchannel.irq);
+}
+
+struct subchannel *
+cio_get_console_subchannel(void)
+{
+	if (!console_subchannel_in_use)
+		return 0;
+	return &console_subchannel;
+}
+
 #endif
diff -urN linux-2.6/drivers/s390/cio/cio.h linux-2.6-s390/drivers/s390/cio/cio.h
--- linux-2.6/drivers/s390/cio/cio.h	Sat Oct 25 20:42:47 2003
+++ linux-2.6-s390/drivers/s390/cio/cio.h	Thu Nov 13 15:35:25 2003
@@ -121,10 +121,12 @@
 extern int cio_cancel (struct subchannel *);
 extern int cio_set_options (struct subchannel *, int);
 extern int cio_get_options (struct subchannel *);
-
+extern int cio_modify (struct subchannel *);
 /* Use with care. */
 extern struct subchannel *cio_probe_console(void);
 extern void cio_release_console(void);
+extern int cio_is_console(int irq);
+extern struct subchannel *cio_get_console_subchannel(void);
 
 extern int cio_show_msg;
 
diff -urN linux-2.6/drivers/s390/cio/css.c linux-2.6-s390/drivers/s390/cio/css.c
--- linux-2.6/drivers/s390/cio/css.c	Thu Nov 13 15:29:43 2003
+++ linux-2.6-s390/drivers/s390/cio/css.c	Thu Nov 13 15:35:25 2003
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/css.c
  *  driver for channel subsystem
- *   $Revision: 1.51 $
+ *   $Revision: 1.60 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -14,15 +14,11 @@
 #include <linux/slab.h>
 #include <linux/errno.h>
 
-#include <asm/ccwdev.h> // FIXME: layering violation, remove this
-
 #include "css.h"
 #include "cio.h"
 #include "cio_debug.h"
-#include "device.h" // FIXME: dito
 #include "ioasm.h"
 
-struct subchannel *ioinfo[__MAX_SUBCHANNELS];
 unsigned int highest_subchannel;
 int css_init_done = 0;
 
@@ -30,23 +26,19 @@
 	.bus_id = "css0",
 };
 
-static int
+static struct subchannel *
 css_alloc_subchannel(int irq)
 {
 	struct subchannel *sch;
 	int ret;
 
-	if (ioinfo[irq])
-		/* There already is a struct subchannel for this irq. */
-		return -EBUSY;
-
 	sch = kmalloc (sizeof (*sch), GFP_KERNEL | GFP_DMA);
 	if (sch == NULL)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 	ret = cio_validate_subchannel (sch, irq);
 	if (ret < 0) {
 		kfree(sch);
-		return ret;
+		return ERR_PTR(ret);
 	}
 	if (irq > highest_subchannel)
 		highest_subchannel = irq;
@@ -54,27 +46,45 @@
 	if (sch->st != SUBCHANNEL_TYPE_IO) {
 		/* For now we ignore all non-io subchannels. */
 		kfree(sch);
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	}
 
-	ioinfo[irq] = sch;
-
-	return 0;
+	/* 
+	 * Set intparm to subchannel address.
+	 * This is fine even on 64bit since the subchannel is always located
+	 * under 2G.
+	 */
+	sch->schib.pmcw.intparm = (__u32)(unsigned long)sch;
+	ret = cio_modify(sch);
+	if (ret) {
+		kfree(sch);
+		return ERR_PTR(ret);
+	}
+	return sch;
 }
 
 static void
-css_free_subchannel(int irq)
+css_free_subchannel(struct subchannel *sch)
 {
-	struct subchannel *sch;
-
-	sch = ioinfo[irq];
 	if (sch) {
-		ioinfo[irq] = NULL;
+		/* Reset intparm to zeroes. */
+		sch->schib.pmcw.intparm = 0;
+		cio_modify(sch);
 		kfree(sch);
 	}
 	
 }
 
+static void
+css_subchannel_release(struct device *dev)
+{
+	struct subchannel *sch;
+
+	sch = to_subchannel(dev);
+	if (!cio_is_console(sch->irq))
+		kfree(sch);
+}
+
 static int
 css_register_subchannel(struct subchannel *sch)
 {
@@ -83,6 +93,7 @@
 	/* Initialize the subchannel structure */
 	sch->dev.parent = &css_bus_device;
 	sch->dev.bus = &css_bus_type;
+	sch->dev.release = &css_subchannel_release;
 	
 	/* make it known to the system */
 	ret = device_register(&sch->dev);
@@ -92,32 +103,127 @@
 	return ret;
 }
 
+extern int css_get_ssd_info(struct subchannel *sch);
+
 int
 css_probe_device(int irq)
 {
 	int ret;
+	struct subchannel *sch;
 
-	ret = css_alloc_subchannel(irq);
+	sch = css_alloc_subchannel(irq);
+	if (IS_ERR(sch))
+		return PTR_ERR(sch);
+	ret = css_register_subchannel(sch);
 	if (ret)
-		return ret;
-	ret = css_register_subchannel(ioinfo[irq]);
-	if (ret)
-		css_free_subchannel(irq);
+		css_free_subchannel(sch);
+	else
+		css_get_ssd_info(sch);
+	return ret;
+}
+
+struct subchannel *
+get_subchannel_by_schid(int irq)
+{
+	struct subchannel *sch;
+	struct list_head *entry;
+	struct device *dev;
+
+	if (!get_bus(&css_bus_type))
+		return NULL;
+
+	sch = NULL;
+	down_read(&css_bus_type.subsys.rwsem);
+
+	list_for_each(entry, &css_bus_type.devices.list) {
+		dev = get_device(container_of(entry, struct device, bus_list));
+		if (!dev)
+			continue;
+		sch = to_subchannel(dev);
+		if (sch->irq == irq)
+			break;
+		put_device(dev);
+		sch = NULL;
+	}
+	up_read(&css_bus_type.subsys.rwsem);
+	put_bus(&css_bus_type);
+
+	return sch;
+}
+
+static inline int
+css_get_subchannel_status(struct subchannel *sch, int schid)
+{
+	struct schib schib;
+	int cc;
+
+	cc = stsch(schid, &schib);
+	if (cc)
+		return CIO_GONE;
+	if (!schib.pmcw.dnv)
+		return CIO_GONE;
+	if (sch && (schib.pmcw.dev != sch->schib.pmcw.dev))
+		return CIO_REVALIDATE;
+	return CIO_OPER;
+}
+	
+static inline int
+css_evaluate_subchannel(int irq)
+{
+	int event, ret;
+	struct subchannel *sch;
+
+	sch = get_subchannel_by_schid(irq);
+	event = css_get_subchannel_status(sch, irq);
+	switch (event) {
+	case CIO_GONE:
+		if (!sch) {
+			/* Never used this subchannel. Ignore. */
+			ret = 0;
+			break;
+		}
+		/*
+		 * Unregister subchannel.
+		 * The device will be killed automatically.
+		 */
+		device_unregister(&sch->dev);
+		/* Reset intparm to zeroes. */
+		sch->schib.pmcw.intparm = 0;
+		cio_modify(sch);
+		put_device(&sch->dev);
+		ret = 0;
+		break;
+	case CIO_REVALIDATE:
+		/* Revalidation machine check. Sick. */
+		device_unregister(&sch->dev);
+		/* Reset intparm to zeroes. */
+		sch->schib.pmcw.intparm = 0;
+		cio_modify(sch);
+		put_device(&sch->dev);
+		ret = css_probe_device(irq);
+		break;
+	case CIO_OPER:
+		ret = sch ? 0 : css_probe_device(irq);
+		break;
+	default:
+		BUG();
+		ret = 0;
+	}
 	return ret;
 }
 
 /*
  * Rescan for new devices. FIXME: This is slow.
+ * This function is called when we have lost CRWs due to overflows and we have
+ * to do subchannel housekeeping.
  */
-static void
-do_process_crw(void *ignore)
+void
+css_reiterate_subchannels(void)
 {
 	int irq, ret;
 
-	for (irq = 0; irq < __MAX_SUBCHANNELS; irq++) {
-		if (ioinfo[irq])
-			continue;
-		ret = css_probe_device(irq);
+	for (irq = 0; irq <= __MAX_SUBCHANNELS; irq++) {
+		ret = css_evaluate_subchannel(irq);
 		/* No more memory. It doesn't make sense to continue. No
 		 * panic because this can happen in midflight and just
 		 * because we can't use a new device is no reason to crash
@@ -132,39 +238,25 @@
 
 /*
  * Called from the machine check handler for subchannel report words.
- * Note: this is called disabled from the machine check handler itself.
  */
 void
 css_process_crw(int irq)
 {
-	static DECLARE_WORK(work, do_process_crw, 0);
-	struct subchannel *sch;
-	int ccode, devno;
-
 	CIO_CRW_EVENT(2, "source is subchannel %04X\n", irq);
 
-	sch = ioinfo[irq];
-	if (sch == NULL) {
-		queue_work(ccw_device_work, &work);
-		return;
-	}
-	if (!sch->dev.driver_data)
-		return;
-	devno = sch->schib.pmcw.dev;
-	/* FIXME: css_process_crw must not know about ccw_device */
-	dev_fsm_event(sch->dev.driver_data, DEV_EVENT_NOTOPER);
-	ccode = stsch(irq, &sch->schib);
-	if (!ccode)
-		if (devno != sch->schib.pmcw.dev)
-			queue_work(ccw_device_work, &work);
+	/* 
+	 * Since we are always presented with IPI in the CRW, we have to
+	 * use stsch() to find out if the subchannel in question has come
+	 * or gone.
+	 */
+	css_evaluate_subchannel(irq);
 }
 
 /*
  * some of the initialization has already been done from init_IRQ(),
  * here we do the rest now that the driver core is running.
- * Currently, this functions scans all the subchannel structures for
- * devices. The long term plan is to remove ioinfo[] and then the
- * struct subchannel's will be created during probing. 
+ * The struct subchannel's are created during probing (except for the
+ * static console subchannel).
  */
 static int __init
 init_channel_subsystem (void)
@@ -181,8 +273,16 @@
 	ctl_set_bit(6, 28);
 
 	for (irq = 0; irq < __MAX_SUBCHANNELS; irq++) {
-		if (!ioinfo[irq]) {
-			ret = css_alloc_subchannel(irq);
+		struct subchannel *sch;
+
+		if (cio_is_console(irq))
+			sch = cio_get_console_subchannel();
+		else {
+			sch = css_alloc_subchannel(irq);
+			if (IS_ERR(sch))
+				ret = PTR_ERR(sch);
+			else
+				ret = 0;
 			if (ret == -ENOMEM)
 				panic("Out of memory in "
 				      "init_channel_subsystem\n");
@@ -199,7 +299,7 @@
 		 * not working) so we do it now. This is true e.g. for the
 		 * console subchannel.
 		 */
-		css_register_subchannel(ioinfo[irq]);
+		css_register_subchannel(sch);
 	}
 	return 0;
 
diff -urN linux-2.6/drivers/s390/cio/css.h linux-2.6-s390/drivers/s390/cio/css.h
--- linux-2.6/drivers/s390/cio/css.h	Sat Oct 25 20:45:07 2003
+++ linux-2.6-s390/drivers/s390/cio/css.h	Thu Nov 13 15:35:25 2003
@@ -108,12 +108,11 @@
 extern struct bus_type css_bus_type;
 
 int css_probe_device(int irq);
-
+extern struct subchannel * get_subchannel_by_schid(int irq);
 extern unsigned int highest_subchannel;
 extern int css_init_done;
 
 #define __MAX_SUBCHANNELS 65536
-extern struct subchannel *ioinfo[__MAX_SUBCHANNELS];
 
 extern struct bus_type css_bus_type;
 extern struct device css_bus_device;
diff -urN linux-2.6/drivers/s390/cio/device.c linux-2.6-s390/drivers/s390/cio/device.c
--- linux-2.6/drivers/s390/cio/device.c	Thu Nov 13 15:29:39 2003
+++ linux-2.6-s390/drivers/s390/cio/device.c	Thu Nov 13 15:35:25 2003
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device.c
  *  bus driver for ccw devices
- *   $Revision: 1.70 $
+ *   $Revision: 1.78 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -115,6 +115,7 @@
 };
 
 static int io_subchannel_probe (struct device *);
+static int io_subchannel_remove (struct device *);
 void io_subchannel_irq (struct device *);
 
 static struct css_driver io_subchannel_driver = {
@@ -123,6 +124,7 @@
 		.name = "io_subchannel",
 		.bus  = &css_bus_type,
 		.probe = &io_subchannel_probe,
+		.remove = &io_subchannel_remove,
 	},
 	.irq = io_subchannel_irq,
 };
@@ -389,6 +391,12 @@
 	return sysfs_create_group(&dev->kobj, &subch_attr_group);
 }
 
+static inline void
+subchannel_remove_files(struct device *dev)
+{
+	sysfs_remove_group(&dev->kobj, &subch_attr_group);
+}
+
 static struct attribute * ccwdev_attrs[] = {
 	&dev_attr_devtype.attr,
 	&dev_attr_cutype.attr,
@@ -637,6 +645,22 @@
 	return 0;
 }
 
+static int
+io_subchannel_remove (struct device *dev)
+{
+	struct ccw_device *cdev;
+
+	if (!dev->driver_data)
+		return 0;
+	cdev = dev->driver_data;
+	/* Set ccw device to not operational and drop reference. */
+	dev_fsm_event(cdev, DEV_EVENT_NOTOPER);
+	put_device(&cdev->dev);
+	dev->driver_data = NULL;
+	subchannel_remove_files(dev);
+	return 0;
+}
+
 #ifdef CONFIG_CCW_CONSOLE
 static struct ccw_device console_cdev;
 static struct ccw_device_private console_private;
@@ -770,18 +794,28 @@
 {
 	struct ccw_device *cdev = to_ccwdev(dev);
 	struct ccw_driver *cdrv = cdev->drv;
+	int ret;
 
-	/*
-	 * Set device offline, so device drivers don't end up with
-	 * doubled code.
-	 * This is safe because of the checks in ccw_device_set_offline.
-	 */
 	pr_debug("removing device %s, sch %d, devno %x\n",
 		 cdev->dev.name,
 		 cdev->private->irq,
 		 cdev->private->devno);
-	ccw_device_set_offline(cdev);
-	return cdrv->remove ? cdrv->remove(cdev) : 0;
+	if (cdrv->remove)
+		cdrv->remove(cdev);
+	if (cdev->online) {
+		cdev->online = 0;
+		spin_lock_irq(cdev->ccwlock);
+		ret = ccw_device_offline(cdev);
+		spin_unlock_irq(cdev->ccwlock);
+		if (ret == 0)
+			wait_event(cdev->private->wait_q,
+				   dev_fsm_final_state(cdev));
+		else
+			//FIXME: we can't fail!
+			pr_debug("ccw_device_offline returned %d, device %s\n",
+				 ret, cdev->dev.bus_id);
+	}
+	return 0;
 }
 
 int
diff -urN linux-2.6/drivers/s390/net/ctcmain.c linux-2.6-s390/drivers/s390/net/ctcmain.c
--- linux-2.6/drivers/s390/net/ctcmain.c	Thu Nov 13 15:29:40 2003
+++ linux-2.6-s390/drivers/s390/net/ctcmain.c	Thu Nov 13 15:35:25 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: ctcmain.c,v 1.48 2003/10/06 18:35:24 mschwide Exp $
+ * $Id: ctcmain.c,v 1.49 2003/10/15 11:28:37 mschwide Exp $
  *
  * CTC / ESCON network driver
  *
@@ -36,7 +36,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.48 $
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.49 $
  *
  */
 
@@ -272,7 +272,7 @@
 print_banner(void)
 {
 	static int printed = 0;
-	char vbuf[] = "$Revision: 1.48 $";
+	char vbuf[] = "$Revision: 1.49 $";
 	char *version = vbuf;
 
 	if (printed)
@@ -2992,20 +2992,19 @@
 
 }
 
-static int
+static void
 ctc_remove_device(struct ccwgroup_device *cgdev)
 {
 	struct ctc_priv *priv;
 
 	priv = cgdev->dev.driver_data;
 	if (!priv)
-		return 0;
+		return;
 
 	ctc_remove_files(&cgdev->dev);
 	cgdev->dev.driver_data = NULL;
 	kfree(priv);
 	put_device(&cgdev->dev);
-	return 0;
 }
 
 static struct ccwgroup_driver ctc_group_driver = {
diff -urN linux-2.6/drivers/s390/net/lcs.c linux-2.6-s390/drivers/s390/net/lcs.c
--- linux-2.6/drivers/s390/net/lcs.c	Thu Nov 13 15:29:40 2003
+++ linux-2.6-s390/drivers/s390/net/lcs.c	Thu Nov 13 15:35:25 2003
@@ -11,7 +11,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Martin Schwidefsky <schwidefsky@de.ibm.com>
  *
- *    $Revision: 1.58 $	 $Date: 2003/09/22 13:33:56 $
+ *    $Revision: 1.60 $	 $Date: 2003/10/21 13:43:56 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -58,7 +58,7 @@
 /**
  * initialization string for output
  */
-#define VERSION_LCS_C  "$Revision: 1.58 $"
+#define VERSION_LCS_C  "$Revision: 1.60 $"
 
 static char version[] __initdata = "LCS driver ("VERSION_LCS_C "/" VERSION_LCS_H ")";
 
@@ -1890,7 +1890,7 @@
 /**
  * lcs_remove_device, free buffers and card
  */
-static int
+static void
 lcs_remove_device(struct ccwgroup_device *ccwgdev)
 {
 	struct lcs_card *card;
@@ -1898,12 +1898,11 @@
 	LCS_DBF_TEXT(3, setup, "remdev");
 	card = (struct lcs_card *)ccwgdev->dev.driver_data;
 	if (!card)
-		return 0;
+		return;
 	sysfs_remove_group(&ccwgdev->dev.kobj, &lcs_attr_group);
 	lcs_cleanup_card(card);
 	lcs_free_card(card);
 	put_device(&ccwgdev->dev);
-	return 0;
 }
 
 /**
diff -urN linux-2.6/drivers/s390/net/qeth.c linux-2.6-s390/drivers/s390/net/qeth.c
--- linux-2.6/drivers/s390/net/qeth.c	Thu Nov 13 15:29:43 2003
+++ linux-2.6-s390/drivers/s390/net/qeth.c	Thu Nov 13 15:35:25 2003
@@ -2653,6 +2653,8 @@
 		QETH_DBF_TEXT2(0, trace, "scd:doio");
 		sprintf(dbf_text, "%4x", (__s16) result);
 		QETH_DBF_TEXT2(0, trace, dbf_text);
+		/* re-enable qeth_send_control_data again */
+		atomic_set(&card->write_busy,0);
 		return NULL;
 	}
 
@@ -10702,7 +10704,7 @@
 	return -ENODEV;
 }
 
-static int
+static void
 qeth_remove_device(struct ccwgroup_device *gdev)
 {
 	struct qeth_card *card = gdev->dev.driver_data;
@@ -10712,7 +10714,6 @@
 	if (card)
 		qeth_free_card(card);
 	put_device(&gdev->dev);
-	return 0;
 }
 
 static int
diff -urN linux-2.6/drivers/s390/s390mach.c linux-2.6-s390/drivers/s390/s390mach.c
--- linux-2.6/drivers/s390/s390mach.c	Sat Oct 25 20:44:54 2003
+++ linux-2.6-s390/drivers/s390/s390mach.c	Thu Nov 13 15:35:25 2003
@@ -19,9 +19,12 @@
 #define DBG printk
 // #define DBG(args,...) do {} while (0);
 
+static struct semaphore s_sem;
+
 extern void css_process_crw(int);
 extern void chsc_process_crw(void);
 extern void chp_process_crw(int, int);
+extern void css_reiterate_subchannels(void);
 
 static void
 s390_handle_damage(char *msg)
@@ -38,12 +41,19 @@
  *
  * Note : we currently process CRWs for io and chsc subchannels only
  */
-static void
-s390_collect_crw_info(void)
+static int
+s390_collect_crw_info(void *param)
 {
 	struct crw crw;
 	int ccode;
+	struct semaphore *sem;
 
+	sem = (struct semaphore *)param;
+	/* Set a nice name. */
+	daemonize("kmcheck");
+
+repeat:
+	down_interruptible(sem);
 	while (1) {
 		ccode = stcrw(&crw);
 		if (ccode != 0)
@@ -52,6 +62,12 @@
 		    "chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\n",
 		    crw.slct, crw.oflw, crw.chn, crw.rsc, crw.anc,
 		    crw.erc, crw.rsid);
+		/* Check for overflows. */
+		if (crw.oflw) {
+			pr_debug("%s: crw overflow detected!\n", __FUNCTION__);
+			css_reiterate_subchannels();
+			continue;
+		}
 		switch (crw.rsc) {
 		case CRW_RSC_SCH:
 			pr_debug("source is subchannel %04X\n", crw.rsid);
@@ -86,6 +102,8 @@
 			break;
 		}
 	}
+	goto repeat;
+	return 0;
 }
 
 /*
@@ -122,7 +140,7 @@
 				   "check\n");
 
 	if (mci->cp)		/* channel report word pending */
-		s390_collect_crw_info();
+		up(&s_sem);
 
 #ifdef CONFIG_MACHCHK_WARNING
 /*
@@ -154,6 +172,7 @@
 static int
 machine_check_init(void)
 {
+	init_MUTEX_LOCKED( &s_sem );
 	ctl_clear_bit(14, 25);	/* disable damage MCH */
 	ctl_set_bit(14, 26);	/* enable degradation MCH */
 	ctl_set_bit(14, 27);	/* enable system recovery MCH */
@@ -176,6 +195,7 @@
 static int __init
 machine_check_crw_init (void)
 {
+	kernel_thread(s390_collect_crw_info, &s_sem, CLONE_FS|CLONE_FILES);
 	ctl_set_bit(14, 28);	/* enable channel report MCH */
 	return 0;
 }
diff -urN linux-2.6/drivers/s390/scsi/zfcp_ccw.c linux-2.6-s390/drivers/s390/scsi/zfcp_ccw.c
--- linux-2.6/drivers/s390/scsi/zfcp_ccw.c	Thu Nov 13 15:35:24 2003
+++ linux-2.6-s390/drivers/s390/scsi/zfcp_ccw.c	Thu Nov 13 15:35:25 2003
@@ -37,7 +37,7 @@
 #define ZFCP_LOG_AREA_PREFIX            ZFCP_LOG_AREA_PREFIX_CONFIG
 
 static int zfcp_ccw_probe(struct ccw_device *);
-static int zfcp_ccw_remove(struct ccw_device *);
+static void zfcp_ccw_remove(struct ccw_device *);
 static int zfcp_ccw_set_online(struct ccw_device *);
 static int zfcp_ccw_set_offline(struct ccw_device *);
 
@@ -93,13 +93,14 @@
  * ports that belong to this adapter. And in addition all resources of this
  * adapter will be freed too.
  */
-static int
+static void
 zfcp_ccw_remove(struct ccw_device *ccw_device)
 {
 	struct zfcp_adapter *adapter;
 	struct zfcp_port *port, *p;
 	struct zfcp_unit *unit, *u;
 
+	ccw_device_set_offline(ccw_device);
 	down(&zfcp_data.config_sema);
 	adapter = dev_get_drvdata(&ccw_device->dev);
 
@@ -131,7 +132,6 @@
 	zfcp_adapter_dequeue(adapter);
 
 	up(&zfcp_data.config_sema);
-	return 0;
 }
 
 /**
diff -urN linux-2.6/include/asm-s390/ccwdev.h linux-2.6-s390/include/asm-s390/ccwdev.h
--- linux-2.6/include/asm-s390/ccwdev.h	Thu Nov 13 15:29:43 2003
+++ linux-2.6-s390/include/asm-s390/ccwdev.h	Thu Nov 13 15:35:25 2003
@@ -89,7 +89,7 @@
 	struct module *owner;		/* for automatic MOD_INC_USE_COUNT   */
 	struct ccw_device_id *ids;	/* probe driver with these devs      */
 	int (*probe) (struct ccw_device *); /* ask driver to probe dev 	     */
-	int (*remove) (struct ccw_device *);
+	void (*remove) (struct ccw_device *);
 					/* device is no longer available     */
 	int (*set_online) (struct ccw_device *);
 	int (*set_offline) (struct ccw_device *);
diff -urN linux-2.6/include/asm-s390/ccwgroup.h linux-2.6-s390/include/asm-s390/ccwgroup.h
--- linux-2.6/include/asm-s390/ccwgroup.h	Sat Oct 25 20:43:40 2003
+++ linux-2.6-s390/include/asm-s390/ccwgroup.h	Thu Nov 13 15:35:25 2003
@@ -21,8 +21,7 @@
 	unsigned long driver_id;
 
 	int (*probe) (struct ccwgroup_device *);
-	int (*remove) (struct ccwgroup_device *);
-	int (*release) (struct ccwgroup_driver *);
+	void (*remove) (struct ccwgroup_device *);
 	int (*set_online) (struct ccwgroup_device *);
 	int (*set_offline) (struct ccwgroup_device *);
 
@@ -37,7 +36,7 @@
 			    int argc, char *argv[]);
 
 extern int ccwgroup_probe_ccwdev(struct ccw_device *cdev);
-extern int ccwgroup_remove_ccwdev(struct ccw_device *cdev);
+extern void ccwgroup_remove_ccwdev(struct ccw_device *cdev);
 
 #define to_ccwgroupdev(x) container_of((x), struct ccwgroup_device, dev)
 #define to_ccwgroupdrv(x) container_of((x), struct ccwgroup_driver, driver)
diff -urN linux-2.6/include/asm-s390/cio.h linux-2.6-s390/include/asm-s390/cio.h
--- linux-2.6/include/asm-s390/cio.h	Sat Oct 25 20:44:39 2003
+++ linux-2.6-s390/include/asm-s390/cio.h	Thu Nov 13 15:35:26 2003
@@ -247,6 +247,14 @@
 #define DOIO_DENY_PREFETCH	 0x0002 /* don't allow for CCW prefetch */
 #define DOIO_SUPPRESS_INTER	 0x0004 /* suppress intermediate inter. */
 					/* ... for suspended CCWs */
+/* Device or subchannel gone. */
+#define CIO_GONE       0x0001
+/* No path to device. */
+#define CIO_NO_PATH    0x0002
+/* Device has appeared. */
+#define CIO_OPER       0x0004
+/* Sick revalidation of device. */
+#define CIO_REVALIDATE 0x0008
 
 struct diag210 {
 	__u16 vrdcdvno : 16;   /* device number (input) */
