- Description: qeth: ccwgroup device reference count problem
  Symptom:     If a qeth ccwgroup device is ungrouped, the single ccw devices
               cannot be regrouped again
  Problem:     qeth creates sub directories in sysfs for each device. These sub
               dirs hold references to the corresponding ccwgroup device. On
               removal of qeth device the sub dirs are not removed automati-
               cally; references on ccwgroup device are not released. As a
               result, common IO does not clean up the ccwgroup device and
               does not allow another grouping of related ccw devices.
  Solution:    Add a call to qeth_remove_device_attributes to qeth_remove_device
               This explicitly removes previously created subdirs om sysfs
  Problem-ID:  --
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/qeth_main.c	6 Apr 2004 14:38:19 -0000	1.77
+++ linux-2.5/drivers/s390/net/qeth_main.c	13 Apr 2004 09:19:12 -0000	1.77.2.1
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.1 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77 $	 $Date: 2004/04/06 14:38:19 $
+ *    $Revision: 1.77.2.1 $	 $Date: 2004/04/13 09:19:12 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.1 $"
 static const char *version = "qeth S/390 OSA-Express driver ("
 	VERSION_QETH_C "/" VERSION_QETH_H "/" VERSION_QETH_MPC_H
 	QETH_VERSION_IPV6 QETH_VERSION_VLAN ")";
@@ -486,6 +486,7 @@
 	list_del(&card->list);
 	write_unlock_irqrestore(&qeth_card_list.rwlock, flags);
 	unregister_netdev(card->dev);
+	qeth_remove_device_attributes(&cgdev->dev);
 	qeth_free_card(card);
 	cgdev->dev.driver_data = NULL;
 	put_device(&cgdev->dev);
@@ -4424,6 +4425,10 @@
 		if (!ipm->is_multicast)
 			continue;
 		iptodo = qeth_get_addr_buffer(ipm->proto);
+		if (!iptodo) {
+			QETH_DBF_TEXT(trace, 2, "dmcnomem");
+			continue;
+		}
 		memcpy(iptodo, ipm, sizeof(struct qeth_ipaddr));
 		iptodo->users = iptodo->users * -1;
 		if (!__qeth_insert_ip_todo(card, iptodo, 0))
@@ -6515,26 +6520,24 @@
 		addr->u.a4.addr = ifa->ifa_address;
 		addr->u.a4.mask = ifa->ifa_mask;
 		addr->type = QETH_IP_TYPE_NORMAL;
-	}
+	} else
+		goto out;
+
 	switch(event) {
 	case NETDEV_UP:
-		if (addr) {
 			if (!qeth_add_ip(card, addr))
 				kfree(addr);
-		}
 		break;
 	case NETDEV_DOWN:
-		if (addr) {
 			if (!qeth_delete_ip(card, addr))
 				kfree(addr);
-		}
 		break;
 	default:
 		break;
 	}
 	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
 	schedule_work(&card->kernel_thread_starter);
-	
+out:	
 	return NOTIFY_DONE;
 }
 
@@ -6570,26 +6573,24 @@
 		memcpy(&addr->u.a6.addr, &ifa->addr, sizeof(struct in6_addr));
 		addr->u.a6.pfxlen = ifa->prefix_len;
 		addr->type = QETH_IP_TYPE_NORMAL;
-	}
+	} else
+		goto out;
+	
 	switch(event) {
 	case NETDEV_UP:
-		if (addr){
 			if (!qeth_add_ip(card, addr))
 				kfree(addr);
-		}
 		break;
 	case NETDEV_DOWN:
-		if (addr){
 			if (!qeth_delete_ip(card, addr))
 				kfree(addr);
-		}
 		break;
 	default:
 		break;
 	}
 	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
 	schedule_work(&card->kernel_thread_starter);
-
+out:
 	return NOTIFY_DONE;
 }
 

