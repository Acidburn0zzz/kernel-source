- Description: dcssblk: sleeping function called from invalid context
  Symptom:     Error message "bad: scheduling while atomic!" may occur in dmesg
               when a segment is being added.
  Problem:     device_register() function (which may sleep), is called with a
               spinlock held.
  Solution:    Replaced spinlock with semaphore.
  Problem-ID:  
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/block/dcssblk.c	13 Apr 2004 08:08:51 -0000	1.15.2.1
+++ linux-2.5/drivers/s390/block/dcssblk.c	3 Jun 2004 12:19:41 -0000	1.15.2.2
@@ -76,8 +76,7 @@
 };
 
 static struct list_head dcssblk_devices = LIST_HEAD_INIT(dcssblk_devices);
-static rwlock_t dcssblk_devices_lock = RW_LOCK_UNLOCKED;
-
+static struct rw_semaphore dcssblk_devices_sem;
 
 /*
  * release function for segment device.
@@ -92,8 +91,8 @@
 
 /*
  * get a minor number. needs to be called with
- * write_lock(&dcssblk_devices_lock) and the
- * device needs to be enqueued before the lock is
+ * down_write(&dcssblk_devices_sem) and the
+ * device needs to be enqueued before the semaphore is
  * freed.
  */
 static inline int
@@ -121,7 +120,7 @@
 /*
  * get the struct dcssblk_dev_info from dcssblk_devices
  * for the given name.
- * read_lock(&dcssblk_devices_lock) must be held.
+ * down_read(&dcssblk_devices_sem) must be held.
  */
 static struct dcssblk_dev_info *
 dcssblk_get_device_by_name(char *name)
@@ -184,24 +183,24 @@
 		PRINT_WARN("Invalid value, must be 0 or 1\n");
 		return -EINVAL;
 	}
-	write_lock(&dcssblk_devices_lock);
+	down_write(&dcssblk_devices_sem);
 	dev_info = container_of(dev, struct dcssblk_dev_info, dev);
 	if (atomic_read(&dev_info->use_count)) {
 		PRINT_ERR("share: segment %s is busy!\n",
 			  dev_info->segment_name);
-		write_unlock(&dcssblk_devices_lock);
+		up_write(&dcssblk_devices_sem);
 		return -EBUSY;
 	}
 	if ((inbuf[0] == '1') && (dev_info->is_shared == 1)) {
 		PRINT_WARN("Segment %s already loaded in shared mode!\n",
 			   dev_info->segment_name);
-		write_unlock(&dcssblk_devices_lock);
+		up_write(&dcssblk_devices_sem);
 		return count;
 	}
 	if ((inbuf[0] == '0') && (dev_info->is_shared == 0)) {
 		PRINT_WARN("Segment %s already loaded in exclusive mode!\n",
 			   dev_info->segment_name);
-		write_unlock(&dcssblk_devices_lock);
+		up_write(&dcssblk_devices_sem);
 		return count;
 	}
 	if (inbuf[0] == '1') {
@@ -231,7 +230,7 @@
 		PRINT_INFO("Segment %s reloaded, exclusive (read-write) mode.\n",
 			   dev_info->segment_name);
 	} else {
-		write_unlock(&dcssblk_devices_lock);
+		up_write(&dcssblk_devices_sem);
 		PRINT_WARN("Invalid value, must be 0 or 1\n");
 		return -EINVAL;
 	}
@@ -262,14 +261,13 @@
 				dev_info->segment_name);
 		rc = -EPERM;
 	}
-	write_unlock(&dcssblk_devices_lock);
+	up_write(&dcssblk_devices_sem);
 	goto out;
 
 removeseg:
 	PRINT_ERR("Could not reload segment %s, removing it now!\n",
 			dev_info->segment_name);
 	list_del(&dev_info->lh);
-	write_unlock(&dcssblk_devices_lock);
 
 	del_gendisk(dev_info->gd);
 	blk_put_queue(dev_info->dcssblk_queue);
@@ -277,6 +275,7 @@
 	put_disk(dev_info->gd);
 	device_unregister(dev);
 	put_device(dev);
+	up_write(&dcssblk_devices_sem);
 out:
 	return rc;
 }
@@ -308,7 +307,7 @@
 	}
 	dev_info = container_of(dev, struct dcssblk_dev_info, dev);
 
-	write_lock(&dcssblk_devices_lock);
+	down_write(&dcssblk_devices_sem);
 	if (inbuf[0] == '1') {
 		if (atomic_read(&dev_info->use_count) == 0) {
 			// device is idle => we save immediately
@@ -332,11 +331,11 @@
 					dev_info->segment_name);
 		}
 	} else {
-		write_unlock(&dcssblk_devices_lock);
+		up_write(&dcssblk_devices_sem);
 		PRINT_WARN("Invalid value, must be 0 or 1\n");
 		return -EINVAL;
 	}
-	write_unlock(&dcssblk_devices_lock);
+	up_write(&dcssblk_devices_sem);
 	return count;
 }
 
@@ -375,9 +374,9 @@
 	/*
 	 * already loaded?
 	 */
-	read_lock(&dcssblk_devices_lock);
+	down_read(&dcssblk_devices_sem);
 	dev_info = dcssblk_get_device_by_name(local_buf);
-	read_unlock(&dcssblk_devices_lock);
+	up_read(&dcssblk_devices_sem);
 	if (dev_info != NULL) {
 		PRINT_WARN("Segment %s already loaded!\n", local_buf);
 		rc = -EEXIST;
@@ -433,10 +432,10 @@
 	/*
 	 * get minor, add to list
 	 */
-	write_lock(&dcssblk_devices_lock);
+	down_write(&dcssblk_devices_sem);
 	rc = dcssblk_assign_free_minor(dev_info);
 	if (rc) {
-		write_unlock(&dcssblk_devices_lock);
+		up_write(&dcssblk_devices_sem);
 		PRINT_ERR("No free minor number available! "
 			  "Unloading segment...\n");
 		goto unload_seg;
@@ -476,13 +475,13 @@
 			break;
 	}
 	PRINT_DEBUG("Segment %s loaded successfully\n", local_buf);
-	write_unlock(&dcssblk_devices_lock);
+	up_write(&dcssblk_devices_sem);
 	rc = count;
 	goto out;
 
 list_del:
 	list_del(&dev_info->lh);
-	write_unlock(&dcssblk_devices_lock);
+	up_write(&dcssblk_devices_sem);
 unload_seg:
 	segment_unload(local_buf);
 dealloc_gendisk:
@@ -526,22 +525,21 @@
 		goto out_buf;
 	}
 
-	write_lock(&dcssblk_devices_lock);
+	down_write(&dcssblk_devices_sem);
 	dev_info = dcssblk_get_device_by_name(local_buf);
 	if (dev_info == NULL) {
-		write_unlock(&dcssblk_devices_lock);
+		up_write(&dcssblk_devices_sem);
 		PRINT_WARN("Segment %s is not loaded!\n", local_buf);
 		rc = -ENODEV;
 		goto out_buf;
 	}
 	if (atomic_read(&dev_info->use_count) != 0) {
-		write_unlock(&dcssblk_devices_lock);
+		up_write(&dcssblk_devices_sem);
 		PRINT_WARN("Segment %s is in use!\n", local_buf);
 		rc = -EBUSY;
 		goto out_buf;
 	}
 	list_del(&dev_info->lh);
-	write_unlock(&dcssblk_devices_lock);
 
 	del_gendisk(dev_info->gd);
 	blk_put_queue(dev_info->dcssblk_queue);
@@ -552,6 +550,8 @@
 	PRINT_DEBUG("Segment %s unloaded successfully\n",
 			dev_info->segment_name);
 	put_device(&dev_info->dev);
+	up_write(&dcssblk_devices_sem);
+
 	rc = count;
 out_buf:
 	kfree(local_buf);
@@ -587,7 +587,7 @@
 		rc = -ENODEV;
 		goto out;
 	}
-	write_lock(&dcssblk_devices_lock);
+	down_write(&dcssblk_devices_sem);
 	if (atomic_dec_and_test(&dev_info->use_count)
 	    && (dev_info->save_pending)) {
 		PRINT_INFO("Segment %s became idle and is being saved now\n",
@@ -595,7 +595,7 @@
 		segment_replace(dev_info->segment_name);
 		dev_info->save_pending = 0;
 	}
-	write_unlock(&dcssblk_devices_lock);
+	up_write(&dcssblk_devices_sem);
 	rc = 0;
 out:
 	return rc;
@@ -695,6 +695,7 @@
 		return rc;
 	}
 	dcssblk_major = rc;
+	init_rwsem(&dcssblk_devices_sem);
 	PRINT_DEBUG("...finished!\n");
 	return 0;
 }

