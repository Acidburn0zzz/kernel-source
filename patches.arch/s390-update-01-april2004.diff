diff -ruN linux-2.6.5/arch/s390/kernel/entry.S linux-2.5/arch/s390/kernel/entry.S
--- linux-2.6.5/arch/s390/kernel/entry.S	Sun Apr  4 05:36:26 2004
+++ linux-2.5/arch/s390/kernel/entry.S	Fri Apr 16 18:12:01 2004
@@ -198,7 +198,8 @@
  */
 	.global do_call_softirq
 do_call_softirq:
-	stm	%r12,%r15,24(%r15)
+	stnsm	24(%r15),0xfc
+	stm	%r12,%r15,28(%r15)
 	lr	%r12,%r15
         basr    %r13,0
 do_call_base:
@@ -211,7 +212,8 @@
         st	%r12,0(%r15)	# store backchain
 	l	%r1,.Ldo_softirq-do_call_base(%r13)
 	basr	%r14,%r1
-	lm	%r12,%r15,24(%r12)
+	lm	%r12,%r15,28(%r12)
+	ssm	24(%r15)
 	br	%r14
 	
 __critical_start:
diff -ruN linux-2.6.5/arch/s390/kernel/entry64.S linux-2.5/arch/s390/kernel/entry64.S
--- linux-2.6.5/arch/s390/kernel/entry64.S	Sun Apr  4 05:36:26 2004
+++ linux-2.5/arch/s390/kernel/entry64.S	Fri Apr 16 18:12:01 2004
@@ -186,7 +186,8 @@
  */
 	.global do_call_softirq
 do_call_softirq:
-	stmg	%r12,%r15,48(%r15)
+	stnsm	48(%r15),0xfc
+	stmg	%r12,%r15,56(%r15)
 	lgr	%r12,%r15
 	lg	%r0,__LC_ASYNC_STACK
 	slgr    %r0,%r15
@@ -196,7 +197,8 @@
 0:	aghi	%r15,-STACK_FRAME_OVERHEAD
 	stg	%r12,0(%r15)		# store back chain
 	brasl	%r14,do_softirq
-	lmg	%r12,%r15,48(%r12)
+	lmg	%r12,%r15,56(%r12)
+	ssm	48(%r15)
 	br	%r14
 
 __critical_start:
diff -ruN linux-2.6.5/arch/s390/kernel/setup.c linux-2.5/arch/s390/kernel/setup.c
--- linux-2.6.5/arch/s390/kernel/setup.c	Sun Apr  4 05:36:18 2004
+++ linux-2.5/arch/s390/kernel/setup.c	Wed Apr 14 15:58:51 2004
@@ -254,13 +254,13 @@
 /*
  * Reboot, halt and power_off routines for non SMP.
  */
-extern void do_reipl(unsigned long devno);
+extern void reipl(unsigned long devno);
 static void do_machine_restart_nonsmp(char * __unused)
 {
 	if (MACHINE_IS_VM)
 		cpcmd ("IPL", NULL, 0);
 	else
-		do_reipl (0x10000 | S390_lowcore.ipl_device);
+		reipl (0x10000 | S390_lowcore.ipl_device);
 }
 
 static void do_machine_halt_nonsmp(void)
diff -ruN linux-2.6.5/arch/s390/kernel/smp.c linux-2.5/arch/s390/kernel/smp.c
--- linux-2.6.5/arch/s390/kernel/smp.c	Sun Apr  4 05:36:13 2004
+++ linux-2.5/arch/s390/kernel/smp.c	Wed Apr 14 15:58:51 2004
@@ -64,7 +64,7 @@
 extern char vmhalt_cmd[];
 extern char vmpoff_cmd[];
 
-extern void do_reipl(unsigned long devno);
+extern void reipl(unsigned long devno);
 
 static void smp_ext_bitcall(int, ec_bit_sig);
 static void smp_ext_bitcall_others(ec_bit_sig);
@@ -278,7 +278,7 @@
 		if (MACHINE_IS_VM)
 			cpcmd ("IPL", NULL, 0);
 		else
-			do_reipl (0x10000 | S390_lowcore.ipl_device);
+			reipl (0x10000 | S390_lowcore.ipl_device);
 	}
 	signal_processor(smp_processor_id(), sigp_stop);
 }
diff -ruN linux-2.6.5/drivers/s390/block/dasd.c linux-2.5/drivers/s390/block/dasd.c
--- linux-2.6.5/drivers/s390/block/dasd.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/block/dasd.c	Tue Apr 20 15:49:52 2004
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision: 1.137.2.1 $
+ * $Revision: 1.137.2.3 $
  */
 
 #include <linux/config.h>
@@ -74,6 +74,8 @@
 	if (device == NULL)
 		return ERR_PTR(-ENOMEM);
 	memset(device, 0, sizeof (struct dasd_device));
+	/* open_count = 0 means device online but not in use */
+	atomic_set(&device->open_count, -1); 
 
 	/* Get two pages for normal block device operations. */
 	device->ccw_mem = (void *) __get_free_pages(GFP_ATOMIC | GFP_DMA, 1);
@@ -549,6 +551,7 @@
 	}
 	strncpy((char *) &cqr->magic, magic, 4);
 	ASCEBC((char *) &cqr->magic, 4);
+	set_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);
 	dasd_get_device(device);
 	return cqr;
 }
@@ -597,6 +600,7 @@
 	}
 	strncpy((char *) &cqr->magic, magic, 4);
 	ASCEBC((char *) &cqr->magic, 4);
+	set_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);
 	dasd_get_device(device);
 	return cqr;
 }
@@ -688,9 +692,10 @@
 		rc = ccw_device_clear(device->cdev, (long) cqr);
 		switch (rc) {
 		case 0:	/* termination successful */
-			if (cqr->retries > 0)
+		        if (cqr->retries > 0) {
+				cqr->retries--;
 				cqr->status = DASD_CQR_QUEUED;
-			else
+			} else
 				cqr->status = DASD_CQR_FAILED;
 			cqr->stopclk = get_clock();
 			break;
@@ -982,6 +987,8 @@
 		 irb->scsw.cstat == 0 &&
 		 !irb->esw.esw0.erw.cons)
 		era = dasd_era_none;
+	else if (!test_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags))
+ 	        era = dasd_era_fatal; /* don't recover this request */
 	else if (irb->esw.esw0.erw.cons)
 		era = device->discipline->examine_error(cqr, irb);
 	else 
@@ -1875,7 +1882,7 @@
 	 * the blkdev_get in dasd_scan_partitions. We are only interested
 	 * in the other openers.
 	 */
-	max_count = device->bdev ? 1 : 0;
+	max_count = device->bdev ? 0 : -1;
 	if (atomic_read(&device->open_count) > max_count) {
 		printk (KERN_WARNING "Can't offline dasd device with open"
 			" count = %i.\n",
diff -ruN linux-2.6.5/drivers/s390/block/dasd_3990_erp.c linux-2.5/drivers/s390/block/dasd_3990_erp.c
--- linux-2.6.5/drivers/s390/block/dasd_3990_erp.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/block/dasd_3990_erp.c	Tue Apr 20 15:28:03 2004
@@ -5,7 +5,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000, 2001
  *
- * $Revision: 1.29.2.1 $
+ * $Revision: 1.29.2.2 $
  */
 
 #include <linux/timer.h>
@@ -1763,6 +1763,7 @@
 	erp->magic = default_erp->magic;
 	erp->expires = 0;
 	erp->retries = 256;
+	cqr->buildclk = get_clock();
 	erp->status = DASD_CQR_FILLED;
 
 	/* remove the default erp */
diff -ruN linux-2.6.5/drivers/s390/block/dasd_eckd.c linux-2.5/drivers/s390/block/dasd_eckd.c
--- linux-2.6.5/drivers/s390/block/dasd_eckd.c	Sun Apr  4 05:36:13 2004
+++ linux-2.5/drivers/s390/block/dasd_eckd.c	Tue Apr 20 15:28:03 2004
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.53 $
+ * $Revision: 1.53.2.1 $
  */
 
 #include <linux/config.h>
@@ -1130,6 +1130,7 @@
         cqr->cpaddr->count = 32;
 	cqr->cpaddr->cda = (__u32)(addr_t) cqr->data;
 	cqr->device = device;
+	clear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);
 	cqr->retries = 0;
 	cqr->expires = 2 * HZ;
 	cqr->buildclk = get_clock();
@@ -1173,6 +1174,7 @@
         cqr->cpaddr->count = 32;
 	cqr->cpaddr->cda = (__u32)(addr_t) cqr->data;
 	cqr->device = device;
+	clear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);
 	cqr->retries = 0;
 	cqr->expires = 2 * HZ;
 	cqr->buildclk = get_clock();
@@ -1215,6 +1217,7 @@
         cqr->cpaddr->count = 32;
 	cqr->cpaddr->cda = (__u32)(addr_t) cqr->data;
 	cqr->device = device;
+	clear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);
 	cqr->retries = 0;
 	cqr->expires = 2 * HZ;
 	cqr->buildclk = get_clock();
diff -ruN linux-2.6.5/drivers/s390/block/dasd_int.h linux-2.5/drivers/s390/block/dasd_int.h
--- linux-2.6.5/drivers/s390/block/dasd_int.h	Sun Apr  4 05:37:37 2004
+++ linux-2.5/drivers/s390/block/dasd_int.h	Tue Apr 20 15:28:03 2004
@@ -6,7 +6,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.56 $
+ * $Revision: 1.56.2.1 $
  */
 
 #ifndef DASD_INT_H
@@ -159,6 +159,7 @@
 	struct ccw1 *cpaddr;		/* address of channel program */
 	char status;	        	/* status of this request */
 	short retries;			/* A retry counter */
+	unsigned long flags;        	/* flags of this request */
 
 	/* ... and how */
 	unsigned long starttime;	/* jiffies time of request start */
@@ -192,6 +193,9 @@
 #define DASD_CQR_ERROR    0x04	/* request is completed with error */
 #define DASD_CQR_FAILED   0x05	/* request is finally failed */
 
+/* per dasd_ccw_req flags */
+#define DASD_CQR_FLAGS_USE_ERP   0	/* use ERP for this request */
+
 /* Signature for error recovery functions. */
 typedef struct dasd_ccw_req *(*dasd_erp_fn_t) (struct dasd_ccw_req *);
 
diff -ruN linux-2.6.5/drivers/s390/char/raw3270.c linux-2.5/drivers/s390/char/raw3270.c
--- linux-2.6.5/drivers/s390/char/raw3270.c	Sun Apr  4 05:37:45 2004
+++ linux-2.5/drivers/s390/char/raw3270.c	Fri Apr 23 14:36:20 2004
@@ -345,8 +345,10 @@
 	rq = (struct raw3270_request *) intparm;
 	view = rq ? rq->view : rp->view;
 
-	if (irb->scsw.dstat == 
-	    (DEV_STAT_CHN_END | DEV_STAT_DEV_END | DEV_STAT_UNIT_EXCEP)) {
+	if (IS_ERR(irb))
+		rc = RAW3270_IO_RETRY;
+	else if (irb->scsw.dstat ==  (DEV_STAT_CHN_END | DEV_STAT_DEV_END |
+				      DEV_STAT_UNIT_EXCEP)) {
 		/* Handle CE-DE-UE and subsequent UDE */
 		set_bit(RAW3270_FLAGS_BUSY, &rp->flags);
 		rc = RAW3270_IO_BUSY;
@@ -381,6 +383,8 @@
 			return;	/* Sucessfully restarted. */
 		break;
 	case RAW3270_IO_STOP:
+		if (!rq)
+			break;
 		raw3270_halt_io_nolock(rp, rq);
 		rq->rc = -EIO;
 		break;
@@ -881,7 +885,7 @@
 		if (rc) {
 			/* Didn't work. Try to reactivate the old view. */
 			rp->view = oldview;
-			if (oldview->fn->activate(oldview) != 0) {
+			if (!oldview || oldview->fn->activate(oldview) != 0) {
 				/* Didn't work as well. Try any other view. */
 				list_for_each_entry(nv, &rp->view_list, list)
 					if (nv != view && nv != oldview) {
diff -ruN linux-2.6.5/drivers/s390/cio/chsc.c linux-2.5/drivers/s390/cio/chsc.c
--- linux-2.6.5/drivers/s390/cio/chsc.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/cio/chsc.c	Fri Apr 23 16:06:10 2004
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/chsc.c
  *   S/390 common I/O routines -- channel subsystem call
- *   $Revision: 1.107 $
+ *   $Revision: 1.107.2.1 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -148,7 +148,7 @@
 	 */
 	if (ssd_area->st > 3) { /* uhm, that looks strange... */
 		CIO_CRW_EVENT(0, "Strange subchannel type %d"
-			      " for sch %s\n", ssd_area->st, sch->dev.bus_id);
+			      " for sch %04x\n", ssd_area->st, sch->irq);
 		/*
 		 * There may have been a new subchannel type defined in the
 		 * time since this code was written; since we don't know which
@@ -157,8 +157,8 @@
 		return 0;
 	} else {
 		const char *type[4] = {"I/O", "chsc", "message", "ADM"};
-		CIO_CRW_EVENT(6, "ssd: sch %s is %s subchannel\n",
-			      sch->dev.bus_id, type[ssd_area->st]);
+		CIO_CRW_EVENT(6, "ssd: sch %04x is %s subchannel\n",
+			      sch->irq, type[ssd_area->st]);
 
 		sch->ssd_info.valid = 1;
 		sch->ssd_info.type = ssd_area->st;
diff -ruN linux-2.6.5/drivers/s390/cio/cio.c linux-2.5/drivers/s390/cio/cio.c
--- linux-2.6.5/drivers/s390/cio/cio.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/cio/cio.c	Wed Apr 14 15:58:51 2004
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/cio.c
  *   S/390 common I/O routines -- low level i/o calls
- *   $Revision: 1.117.2.1 $
+ *   $Revision: 1.117.2.2 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -783,3 +783,68 @@
 }
 
 #endif
+static inline int
+__disable_subchannel_easy(unsigned int schid, struct schib *schib)
+{
+	int retry, cc;
+
+	cc = 0;
+	for (retry=0;retry<3;retry++) {
+		schib->pmcw.ena = 0;
+		cc = msch(schid, schib);
+		if (cc)
+			return (cc==3?-ENODEV:-EBUSY);
+		stsch(schid, schib);
+		if (!schib->pmcw.ena)
+			return 0;
+	}
+	return -EBUSY; /* uhm... */
+}
+
+static inline int
+__clear_subchannel_easy(unsigned int schid)
+{
+	int retry;
+
+	if (csch(schid))
+		return -ENODEV;
+	for (retry=0;retry<20;retry++) {
+		struct tpi_info ti;
+		
+		if (tpi(&ti)) {
+			tsch(schid, (struct irb *)__LC_IRB);
+			return 0;
+		}
+		udelay(100);
+	}
+	return -EBUSY;
+}
+
+extern void do_reipl(unsigned long devno);
+/* Make sure all subchannels are quiet before we re-ipl an lpar. */
+void
+reipl(unsigned long devno)
+{
+	unsigned int schid;
+
+	local_irq_disable();
+	for (schid=0;schid<=highest_subchannel;schid++) {
+		struct schib schib;
+		if (stsch(schid, &schib))
+			goto out;
+		if (!schib.pmcw.ena)
+			continue;
+		switch(__disable_subchannel_easy(schid, &schib)) {
+		case 0:
+		case -ENODEV:
+			break;
+		default: /* -EBUSY */
+			if (__clear_subchannel_easy(schid))
+				break; /* give up... */
+			stsch(schid, &schib);
+			__disable_subchannel_easy(schid, &schib);
+		}
+	}
+out:
+	do_reipl(devno);
+}
diff -ruN linux-2.6.5/drivers/s390/cio/device_fsm.c linux-2.5/drivers/s390/cio/device_fsm.c
--- linux-2.6.5/drivers/s390/cio/device_fsm.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/cio/device_fsm.c	Fri Apr 23 14:57:40 2004
@@ -440,12 +440,14 @@
 	if (!ret) {
 		if (get_device(&sch->dev)) {
 			/* Driver doesn't want to keep device. */
+			cio_disable_subchannel(sch);
 			device_unregister(&sch->dev);
 			sch->schib.pmcw.intparm = 0;
 			cio_modify(sch);
 			put_device(&sch->dev);
 		}
 	} else {
+		cio_disable_subchannel(sch);
 		ccw_device_set_timeout(cdev, 0);
 		cdev->private->state = DEV_STATE_DISCONNECTED;
 		wake_up(&cdev->private->wait_q);
@@ -787,6 +789,7 @@
 	struct subchannel *sch;
 
 	sch = to_subchannel(cdev->dev.parent);
+	ccw_device_set_timeout(cdev, 0);
 	/* OK, i/o is dead now. Call interrupt handler. */
 	cdev->private->state = DEV_STATE_ONLINE;
 	if (cdev->handler)
diff -ruN linux-2.6.5/drivers/s390/cio/device_pgid.c linux-2.5/drivers/s390/cio/device_pgid.c
--- linux-2.6.5/drivers/s390/cio/device_pgid.c	Sun Apr  4 05:37:23 2004
+++ linux-2.5/drivers/s390/cio/device_pgid.c	Fri Apr 23 16:40:37 2004
@@ -227,7 +227,7 @@
 		ret = cio_start (sch, cdev->private->iccws,
 				 cdev->private->imask);
 		/* ret is 0, -EBUSY, -EACCES or -ENODEV */
-		if (ret != -EACCES)
+		if ((ret != -EACCES) && (ret != -ENODEV))
 			return ret;
 	}
 	/* PGID command failed on this path. Switch it off. */
diff -ruN linux-2.6.5/drivers/s390/cio/qdio.c linux-2.5/drivers/s390/cio/qdio.c
--- linux-2.6.5/drivers/s390/cio/qdio.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/cio/qdio.c	Tue Apr 13 21:19:27 2004
@@ -56,7 +56,7 @@
 #include "ioasm.h"
 #include "chsc.h"
 
-#define VERSION_QDIO_C "$Revision: 1.79 $"
+#define VERSION_QDIO_C "$Revision: 1.79.2.1 $"
 
 /****************** MODULE PARAMETER VARIABLES ********************/
 MODULE_AUTHOR("Utz Bacher <utz.bacher@de.ibm.com>");
@@ -461,12 +461,12 @@
 
 	switch(slsb[f_mod_no]) {
 
-        /* the hydra has not fetched the output yet */
+        /* the adapter has not fetched the output yet */
 	case SLSB_CU_OUTPUT_PRIMED:
 		QDIO_DBF_TEXT5(0,trace,"outpprim");
 		break;
 
-	/* the hydra got it */
+	/* the adapter got it */
 	case SLSB_P_OUTPUT_EMPTY:
 		atomic_dec(&q->number_of_buffers_used);
 		f++;
@@ -919,7 +919,7 @@
 	no_used=atomic_read(&q->number_of_buffers_used);
 
 	/* 
-	 * we need that one for synchronization with Hydra, as Hydra
+	 * we need that one for synchronization with the adapter, as it
 	 * does a kind of PCI avoidance 
 	 */
 	SYNC_MEMORY;
@@ -1069,7 +1069,7 @@
 	}
 	/*
 	 * maybe we have to do work on our outbound queues... at least
-	 * we have to check Hydra outbound-int-capable thinint-capable
+	 * we have to check the outbound-int-capable thinint-capable
 	 * queues
 	 */
 	if (q->hydra_gives_outbound_pcis) {
@@ -2027,7 +2027,7 @@
 		goto exit;
 	}
 
-	/* Check for hydra thin interrupts (bit 67). */
+	/* Check for OSA/FCP thin interrupts (bit 67). */
 	hydra_thinints = ((scsc_area->general_char[2] & 0x10000000)
 		== 0x10000000);
 	sprintf(dbf_text,"hydrati%1x", hydra_thinints);
diff -ruN linux-2.6.5/drivers/s390/net/ctcmain.c linux-2.5/drivers/s390/net/ctcmain.c
--- linux-2.6.5/drivers/s390/net/ctcmain.c	Sun Apr  4 05:36:56 2004
+++ linux-2.5/drivers/s390/net/ctcmain.c	Fri Apr 23 18:15:16 2004
@@ -1,5 +1,5 @@
 /*
- * $Id: ctcmain.c,v 1.58 2004/03/24 10:51:56 ptiedem Exp $
+ * $Id: ctcmain.c,v 1.58.2.1 2004/04/23 16:15:16 ptiedem Exp $
  *
  * CTC / ESCON network driver
  *
@@ -36,7 +36,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.58 $
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.58.2.1 $
  *
  */
 
@@ -319,7 +319,7 @@
 print_banner(void)
 {
 	static int printed = 0;
-	char vbuf[] = "$Revision: 1.58 $";
+	char vbuf[] = "$Revision: 1.58.2.1 $";
 	char *version = vbuf;
 
 	if (printed)
@@ -2045,6 +2045,32 @@
 	return ret;
 }
 
+static long
+__ctc_check_irb_error(struct ccw_device *cdev, struct irb *irb)
+{
+	if (!IS_ERR(irb))
+		return 0;
+
+	switch (PTR_ERR(irb)) {
+	case -EIO:
+		ctc_pr_warn("i/o-error on device %s\n", cdev->dev.bus_id);
+//		CTC_DBF_TEXT(trace, 2, "ckirberr");
+//		CTC_DBF_TEXT_(trace, 2, "  rc%d", -EIO);
+		break;
+	case -ETIMEDOUT:
+		ctc_pr_warn("timeout on device %s\n", cdev->dev.bus_id);
+//		CTC_DBF_TEXT(trace, 2, "ckirberr");
+//		CTC_DBF_TEXT_(trace, 2, "  rc%d", -ETIMEDOUT);
+		break;
+	default:
+		ctc_pr_warn("unknown error %ld on device %s\n", PTR_ERR(irb),
+			   cdev->dev.bus_id);
+//		CTC_DBF_TEXT(trace, 2, "ckirberr");
+//		CTC_DBF_TEXT(trace, 2, "  rc???");
+	}
+	return PTR_ERR(irb);
+}
+
 /**
  * Main IRQ handler.
  *
@@ -2059,6 +2085,9 @@
 	struct net_device *dev;
 	struct ctc_priv *priv;
 
+	if (__ctc_check_irb_error(cdev, irb))
+		return;
+
 	/* Check for unsolicited interrupts. */
 	if (!cdev->dev.driver_data) {
 		ctc_pr_warn("ctc: Got unsolicited irq: %s c-%02x d-%02x\n",
diff -ruN linux-2.6.5/drivers/s390/net/iucv.c linux-2.5/drivers/s390/net/iucv.c
--- linux-2.6.5/drivers/s390/net/iucv.c	Sun Apr  4 05:36:18 2004
+++ linux-2.5/drivers/s390/net/iucv.c	Thu Apr 15 11:18:47 2004
@@ -1,5 +1,5 @@
 /* 
- * $Id: iucv.c,v 1.27 2004/03/22 07:43:43 braunu Exp $
+ * $Id: iucv.c,v 1.27.2.1 2004/04/15 09:18:47 braunu Exp $
  *
  * IUCV network driver
  *
@@ -29,7 +29,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.27 $
+ * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.27.2.1 $
  *
  */
 
@@ -351,7 +351,7 @@
 static void
 iucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.27 $";
+	char vbuf[] = "$Revision: 1.27.2.1 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
@@ -800,6 +800,7 @@
 		if (iucv_pathid_table == NULL) {
 			printk(KERN_WARNING "%s: iucv_pathid_table storage "
 			       "allocation failed\n", __FUNCTION__);
+			kfree(new_handler);
 			return NULL;
 		}
 		memset (iucv_pathid_table, 0, max_connections * sizeof(handler *));
diff -ruN linux-2.6.5/drivers/s390/net/netiucv.c linux-2.5/drivers/s390/net/netiucv.c
--- linux-2.6.5/drivers/s390/net/netiucv.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/net/netiucv.c	Thu Apr 15 11:26:33 2004
@@ -1,5 +1,5 @@
 /*
- * $Id: netiucv.c,v 1.48 2004/04/01 13:42:09 braunu Exp $
+ * $Id: netiucv.c,v 1.48.2.1 2004/04/15 09:26:33 braunu Exp $
  *
  * IUCV network driver
  *
@@ -30,7 +30,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV network driver $Revision: 1.48 $
+ * RELEASE-TAG: IUCV network driver $Revision: 1.48.2.1 $
  *
  */
 
@@ -601,11 +601,12 @@
 		if ((skb = skb_dequeue(&conn->commit_queue))) {
 			atomic_dec(&skb->users);
 			dev_kfree_skb_any(skb);
-		}
-		if (privptr) {
-			privptr->stats.tx_packets++;
-			privptr->stats.tx_bytes +=
-				(skb->len - NETIUCV_HDRLEN - NETIUCV_HDRLEN);
+			if (privptr) {
+				privptr->stats.tx_packets++;
+				privptr->stats.tx_bytes +=
+					(skb->len - NETIUCV_HDRLEN 
+						  - NETIUCV_HDRLEN);
+			}
 		}
 	}
 	conn->tx_buff->data = conn->tx_buff->tail = conn->tx_buff->head;
@@ -1078,6 +1079,7 @@
 				       "%s: Could not allocate tx_skb\n",
 				       conn->netdev->name);
 				rc = -ENOMEM;
+				return rc;
 			} else {
 				skb_reserve(nskb, NETIUCV_HDRLEN);
 				memcpy(skb_put(nskb, skb->len),
@@ -1880,7 +1882,7 @@
 static void
 netiucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.48 $";
+	char vbuf[] = "$Revision: 1.48.2.1 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
diff -ruN linux-2.6.5/drivers/s390/net/qeth.h linux-2.5/drivers/s390/net/qeth.h
--- linux-2.6.5/drivers/s390/net/qeth.h	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/net/qeth.h	Wed Apr 21 17:24:04 2004
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.98 $"
+#define VERSION_QETH_H 		"$Revision: 1.98.2.1 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -423,14 +423,12 @@
 	struct qeth_qdio_out_buffer bufs[QDIO_MAX_BUFFERS_PER_Q];
 	int queue_no;
 	struct qeth_card *card;
-	struct tasklet_struct tasklet;
 	spinlock_t lock;
 	volatile int do_pack;
 	/*
 	 * index of buffer to be filled by driver; state EMPTY or PACKING
 	 */
 	volatile int next_buf_to_fill;
-	volatile int next_buf_to_flush;
 	/*
 	 * number of buffers that are currently filled (PRIMED)
 	 * -> these buffers are hardware-owned
@@ -447,7 +445,6 @@
 	struct qeth_qdio_buffer_pool in_buf_pool;
 	struct qeth_qdio_buffer_pool init_pool;
 	int in_buf_size;
-	struct tasklet_struct in_tasklet;
 
 	/* output */
 	int no_out_queues;
diff -ruN linux-2.6.5/drivers/s390/net/qeth_main.c linux-2.5/drivers/s390/net/qeth_main.c
--- linux-2.6.5/drivers/s390/net/qeth_main.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/net/qeth_main.c	Thu Apr 22 17:20:46 2004
@@ -1,6 +1,6 @@
 /*
  * 
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.77.2.4 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.77 $	 $Date: 2004/04/06 14:38:19 $
+ *    $Revision: 1.77.2.4 $	 $Date: 2004/04/22 15:20:46 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.77 $"
+#define VERSION_QETH_C "$Revision: 1.77.2.4 $"
 static const char *version = "qeth S/390 OSA-Express driver ("
 	VERSION_QETH_C "/" VERSION_QETH_H "/" VERSION_QETH_MPC_H
 	QETH_VERSION_IPV6 QETH_VERSION_VLAN ")";
@@ -485,7 +485,9 @@
 	write_lock_irqsave(&qeth_card_list.rwlock, flags);
 	list_del(&card->list);
 	write_unlock_irqrestore(&qeth_card_list.rwlock, flags);
-	unregister_netdev(card->dev);
+	if (card->dev)
+		unregister_netdev(card->dev);
+	qeth_remove_device_attributes(&cgdev->dev);
 	qeth_free_card(card);
 	cgdev->dev.driver_data = NULL;
 	put_device(&cgdev->dev);
@@ -822,7 +824,7 @@
 	struct qeth_card *card;
 
 	card = (struct qeth_card *) ptr;
-	daemonize("getmcaddr");
+	daemonize("qeth_get_mcaddrs");
 	QETH_DBF_TEXT(trace,4,"regmcth1");
 	if (!qeth_do_run_thread(card, QETH_SET_MC_THREAD))
 		return 0;
@@ -843,7 +845,7 @@
 	struct qeth_card *card;
 
 	card = (struct qeth_card *) ptr;
-	daemonize("regip");
+	daemonize("qeth_reg_ip");
 	QETH_DBF_TEXT(trace,4,"regipth1");
 	if (!qeth_do_run_thread(card, QETH_SET_IP_THREAD))
 		return 0;
@@ -860,7 +862,7 @@
 	int rc = 0;
 	
 	card = (struct qeth_card *) ptr;
-	daemonize("recover");
+	daemonize("qeth_recover");
 	QETH_DBF_TEXT(trace,2,"recover1");
 	QETH_DBF_HEX(trace, 2, &card, sizeof(void *));
 	if (!qeth_do_run_thread(card, QETH_RECOVER_THREAD))
@@ -1969,45 +1971,6 @@
 	return rc;
 }
 
-static void
-qeth_qdio_input_handler(struct ccw_device * ccwdev, unsigned int status,
-		        unsigned int qdio_err, unsigned int siga_err,
-			unsigned int queue, int first_element, int count,
-			unsigned long card_ptr)
-{
-	struct net_device *net_dev;
-	struct qeth_card *card;
-	struct qeth_qdio_buffer *buffer;
-	int i;
-
-	QETH_DBF_TEXT(trace, 6, "qdinput");
-	card = (struct qeth_card *) card_ptr;
-	net_dev = card->dev;
-#ifdef CONFIG_QETH_PERF_STATS
-	card->perf_stats.inbound_start_time = qeth_get_micros();
-#endif
-	if (status & QDIO_STATUS_LOOK_FOR_ERROR) {
-		if (status & QDIO_STATUS_ACTIVATE_CHECK_CONDITION){
-			QETH_DBF_TEXT(trace, 1,"qdinchk");
-			QETH_DBF_TEXT_(trace,1,"%s",CARD_BUS_ID(card));
-			QETH_DBF_TEXT_(trace,1,"%04X%04X",first_element,count);
-			QETH_DBF_TEXT_(trace,1,"%04X%04X", queue, status);
-			qeth_schedule_recovery(card);
-			return;
-		}
-	}
-	for (i = first_element; i < (first_element + count); ++i) {
-		buffer = &card->qdio.in_q->bufs[i % QDIO_MAX_BUFFERS_PER_Q];
-		if ((status == QDIO_STATUS_LOOK_FOR_ERROR) &&
-		    qeth_check_for_inbound_error(buffer, qdio_err, siga_err))
-			buffer->state = QETH_QDIO_BUF_ERROR;
-		else
-			buffer->state = QETH_QDIO_BUF_PRIMED;
-	}
-	
-	tasklet_schedule(&card->qdio.in_tasklet);
-}
-
 static inline struct sk_buff *
 qeth_get_skb(unsigned int length)
 {
@@ -2241,6 +2204,38 @@
 	qeth_rebuild_skb_vlan(card, skb, hdr);
 }
 
+static inline void
+qeth_process_inbound_buffer(struct qeth_card *card,
+			    struct qeth_qdio_buffer *buf, int index)
+{
+	struct qdio_buffer_element *element;
+	int offset;
+	struct sk_buff *skb;
+	struct qeth_hdr *hdr;
+	int rxrc;
+	
+	/* get first element of current buffer */
+	element = (struct qdio_buffer_element *)&buf->buffer->element[0];
+	offset = 0;
+#ifdef CONFIG_QETH_PERF_STATS
+	card->perf_stats.bufs_rec++;
+#endif
+	while((skb = qeth_get_next_skb(card, buf->buffer, &element,
+				       &offset, &hdr))){
+		qeth_rebuild_skb(card, skb, hdr);
+
+#ifdef CONFIG_QETH_PERF_STATS
+		card->perf_stats.inbound_time += qeth_get_micros() -
+			card->perf_stats.inbound_start_time;
+		card->perf_stats.inbound_cnt++;
+#endif
+		skb->dev = card->dev;
+		rxrc = netif_rx(skb);
+		card->dev->last_rx = jiffies;
+		card->stats.rx_packets++;
+		card->stats.rx_bytes += skb->len;
+	}
+}
 
 static inline struct qeth_buffer_pool_entry *
 qeth_get_buffer_pool_entry(struct qeth_card *card)
@@ -2284,7 +2279,7 @@
 	buf->state = QETH_QDIO_BUF_EMPTY;
 }
 
-static void
+static inline void
 qeth_clear_output_buffer(struct qeth_card *card,
 			 struct qeth_qdio_out_buffer *buf)
 {
@@ -2355,61 +2350,43 @@
 }
 
 static void
-qeth_qdio_input_tasklet(unsigned long data)
+qeth_qdio_input_handler(struct ccw_device * ccwdev, unsigned int status,
+		        unsigned int qdio_err, unsigned int siga_err,
+			unsigned int queue, int first_element, int count,
+			unsigned long card_ptr)
 {
-	struct qeth_card *card = (struct qeth_card *) data;
-	int current_buf = card->qdio.in_q->next_buf_to_process;
-	struct qeth_qdio_buffer *buf;
-	struct qdio_buffer_element *element;
-	int offset;
-	struct sk_buff *skb;
-	struct qeth_hdr *hdr;
-	int rxrc;
-	
-	QETH_DBF_TEXT(trace,6,"qdintlet");
-	buf = &card->qdio.in_q->bufs[current_buf];
-	while((buf->state == QETH_QDIO_BUF_PRIMED) ||
-	      (buf->state == QETH_QDIO_BUF_ERROR)){
-		if (buf->state == QETH_QDIO_BUF_ERROR)
-			goto clear_buffer;
-		if (netif_queue_stopped(card->dev))
-			goto clear_buffer;
-		/* get first element of current buffer */
-		element = (struct qdio_buffer_element *)
-			&buf->buffer->element[0];
-		offset = 0;
-#ifdef CONFIG_QETH_PERF_STATS
-		card->perf_stats.bufs_rec++;
-#endif
-		while((skb = qeth_get_next_skb(card, buf->buffer, &element,
-					       &offset, &hdr))){
+	struct net_device *net_dev;
+	struct qeth_card *card;
+	struct qeth_qdio_buffer *buffer;
+	int index;
+	int i;
 
-			qeth_rebuild_skb(card, skb, hdr);
+	QETH_DBF_TEXT(trace, 6, "qdinput");
+	card = (struct qeth_card *) card_ptr;
+	net_dev = card->dev;
 #ifdef CONFIG_QETH_PERF_STATS
-			card->perf_stats.inbound_time += qeth_get_micros() -
-				card->perf_stats.inbound_start_time;
-			card->perf_stats.inbound_cnt++;
+	card->perf_stats.inbound_start_time = qeth_get_micros();
 #endif
-			skb->dev = card->dev;
-			if (netif_queue_stopped(card->dev)) {
-				dev_kfree_skb_irq(skb);
-				card->stats.rx_dropped++;
-			} else {
-				rxrc = netif_rx(skb);
-				card->dev->last_rx = jiffies;
-				card->stats.rx_packets++;
-				card->stats.rx_bytes += skb->len;
-			}
+	if (status & QDIO_STATUS_LOOK_FOR_ERROR) {
+		if (status & QDIO_STATUS_ACTIVATE_CHECK_CONDITION){
+			QETH_DBF_TEXT(trace, 1,"qdinchk");
+			QETH_DBF_TEXT_(trace,1,"%s",CARD_BUS_ID(card));
+			QETH_DBF_TEXT_(trace,1,"%04X%04X",first_element,count);
+			QETH_DBF_TEXT_(trace,1,"%04X%04X", queue, status);
+			qeth_schedule_recovery(card);
+			return;
 		}
-clear_buffer:
-		qeth_put_buffer_pool_entry(card, buf->pool_entry);
-		/* give buffer back to hardware */
-		qeth_queue_input_buffer(card, current_buf);
-		current_buf = (current_buf + 1) % QDIO_MAX_BUFFERS_PER_Q;
-		buf = &card->qdio.in_q->bufs[current_buf];
 	}
-	/* set index for next time the tasklet is scheduled */
-	card->qdio.in_q->next_buf_to_process = current_buf;
+	for (i = first_element; i < (first_element + count); ++i) {
+		index = i % QDIO_MAX_BUFFERS_PER_Q;
+		buffer = &card->qdio.in_q->bufs[index];
+		if (!((status == QDIO_STATUS_LOOK_FOR_ERROR) &&
+		      qeth_check_for_inbound_error(buffer, qdio_err, siga_err)))
+			qeth_process_inbound_buffer(card, buffer, index);
+		/* clear buffer and give back to hardware */
+		qeth_put_buffer_pool_entry(card, buffer->pool_entry);
+		qeth_queue_input_buffer(card, index);
+	}
 }
 
 static inline int
@@ -2524,11 +2501,12 @@
  * switches between PACKING and non-PACKING state if needed.
  * has to be called holding queue->lock
  */
-static inline void
+static inline int
 qeth_switch_packing_state(struct qeth_qdio_out_q *queue)
 {
 	struct qeth_qdio_out_buffer *buffer;
-	
+	int flush_count = 0;
+
 	QETH_DBF_TEXT(trace, 6, "swipack");
 	if (!queue->do_pack) {
 		if (atomic_read(&queue->used_buffers)
@@ -2554,13 +2532,33 @@
 			BUG_ON(buffer->state == QETH_QDIO_BUF_PRIMED);
 			if (buffer->next_element_to_fill > 0) {
 				buffer->state = QETH_QDIO_BUF_PRIMED;
+				flush_count++;
 				atomic_inc(&queue->used_buffers);
-				queue->next_buf_to_fill = 
-					(queue->next_buf_to_fill + 1) % 
+				queue->next_buf_to_fill =
+					(queue->next_buf_to_fill + 1) %
 					QDIO_MAX_BUFFERS_PER_Q;
 		 	}
 		}
 	}
+	return flush_count;
+}
+
+static inline void
+qeth_flush_buffers_on_no_pci(struct qeth_qdio_out_q *queue, int under_int)
+{
+	struct qeth_qdio_out_buffer *buffer;
+	
+	buffer = &queue->bufs[queue->next_buf_to_fill];
+	BUG_ON(buffer->state == QETH_QDIO_BUF_PRIMED);
+	if (buffer->next_element_to_fill > 0){
+		/* it's a packing buffer */
+		buffer->state = QETH_QDIO_BUF_PRIMED;
+		atomic_inc(&queue->used_buffers);
+		qeth_flush_buffers(queue, under_int, queue->next_buf_to_fill,
+				   1);
+		queue->next_buf_to_fill =
+			(queue->next_buf_to_fill + 1) % QDIO_MAX_BUFFERS_PER_Q;
+	}
 }
 
 static void
@@ -2603,58 +2601,12 @@
 			atomic_dec(&queue->set_pci_flags_count);
 
 		qeth_clear_output_buffer(card, buffer);
+		atomic_dec(&queue->used_buffers);
 	}
-	atomic_sub(count, &queue->used_buffers);
 
-	//if (!atomic_read(&queue->set_pci_flags_count))
-		tasklet_schedule(&queue->tasklet);
-	
 	netif_wake_queue(card->dev);
 }
 
-static void
-qeth_qdio_output_tasklet(unsigned long data)
-{
-	struct qeth_qdio_out_q *queue = (struct qeth_qdio_out_q *) data;
-	struct qeth_qdio_out_buffer *buffer;
-	int index;
-	int count;
-	
-	QETH_DBF_TEXT(trace, 6, "outtlet");
-	
-	/* flush all PRIMED buffers */
-	index = queue->next_buf_to_flush;
-	count = 0;
-	while (queue->bufs[index].state == QETH_QDIO_BUF_PRIMED) {
-		count++;
-		index = (index + 1) % QDIO_MAX_BUFFERS_PER_Q;
-	}
-	qeth_flush_buffers(queue, 0, queue->next_buf_to_flush, count);
-	queue->next_buf_to_flush = index;
-
-	/* flush a buffer with data, if no more PCIs are
-	 * outstanding */
-	if (!atomic_read(&queue->set_pci_flags_count)){
-		spin_lock(&queue->lock);
-		buffer = &queue->bufs[index];
-		if (buffer->state == QETH_QDIO_BUF_PRIMED){
-			qeth_flush_buffers(queue, 0, index, 1);
-			index = (index + 1) % QDIO_MAX_BUFFERS_PER_Q;
-			queue->next_buf_to_flush = index;
-		} else if (buffer->next_element_to_fill > 0){
-			/* it's a packing buffer */
-			BUG_ON(index != queue->next_buf_to_fill);
-			buffer->state = QETH_QDIO_BUF_PRIMED;
-			atomic_inc(&queue->used_buffers);
-			qeth_flush_buffers(queue, 0, index, 1);
-			index = (index + 1) % QDIO_MAX_BUFFERS_PER_Q;
-			queue->next_buf_to_flush = index;
-			queue->next_buf_to_fill = index;
-		}
-		spin_unlock(&queue->lock);
-	}
-}
-
 static char*
 qeth_create_qib_param_field(struct qeth_card *card)
 {
@@ -2858,8 +2810,6 @@
 	card->qdio.in_buf_pool.buf_count = card->qdio.init_pool.buf_count;
 	INIT_LIST_HEAD(&card->qdio.in_buf_pool.entry_list);
 	INIT_LIST_HEAD(&card->qdio.init_pool.entry_list);
-	card->qdio.in_tasklet.data = (unsigned long) card;
-	card->qdio.in_tasklet.func = qeth_qdio_input_tasklet;
 	/* outbound */
 	card->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;
 	card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
@@ -2903,13 +2853,9 @@
 		}
 		card->qdio.out_qs[i]->card = card;
 		card->qdio.out_qs[i]->next_buf_to_fill = 0;
-		card->qdio.out_qs[i]->next_buf_to_flush = 0;
 		card->qdio.out_qs[i]->do_pack = 0;
 		atomic_set(&card->qdio.out_qs[i]->used_buffers,0);
 		atomic_set(&card->qdio.out_qs[i]->set_pci_flags_count, 0);
-		card->qdio.out_qs[i]->tasklet.data = 
-			(unsigned long) card->qdio.out_qs[i];
-		card->qdio.out_qs[i]->tasklet.func = qeth_qdio_output_tasklet;
 		spin_lock_init(&card->qdio.out_qs[i]->lock);
 	}
 	return 0;
@@ -3653,6 +3599,8 @@
 	struct qeth_hdr *hdr;
 	struct qeth_qdio_out_buffer *buffer;
 	int elements_needed;
+	int start_index;
+	int flush_count = 0;
 	int rc;
 
 	QETH_DBF_TEXT(trace, 6, "dosndpkt");
@@ -3669,11 +3617,9 @@
 				 "IP packet. Discarded.");
 		return -EINVAL;
 	}
-	
+
 	spin_lock(&queue->lock);
-	/* check if we need to switch packing state of this queue */
-	if (card->info.type != QETH_CARD_TYPE_IQD)
-		qeth_switch_packing_state(queue);
+	start_index = queue->next_buf_to_fill;
 	buffer = &queue->bufs[queue->next_buf_to_fill];
 	BUG_ON(buffer->state == QETH_QDIO_BUF_PRIMED);
 	if (queue->do_pack){
@@ -3682,31 +3628,38 @@
 				< elements_needed){
 			/* ... no -> set state PRIMED */
 			buffer->state = QETH_QDIO_BUF_PRIMED;
+			flush_count++;
 			atomic_inc(&queue->used_buffers);
 			queue->next_buf_to_fill =
 				(queue->next_buf_to_fill + 1) %
 				QDIO_MAX_BUFFERS_PER_Q;
 			buffer = &queue->bufs[queue->next_buf_to_fill];
 		}
-	} 
-	
+	}
+
 	rc = qeth_fill_buffer(queue, buffer, (char *)hdr, skb);
 	if (rc) {
 		PRINT_WARN("qeth_do_send_packet: error during "
 			      "qeth_fill_buffer.");
 		card->stats.tx_dropped++;
-		spin_unlock(&queue->lock);
-		return rc;
-	}
-	if (buffer->state == QETH_QDIO_BUF_PRIMED){
+	} else if (buffer->state == QETH_QDIO_BUF_PRIMED){
 		/* next time fill the next buffer */
+		flush_count++;
 		atomic_inc(&queue->used_buffers);
 		queue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %
 			QDIO_MAX_BUFFERS_PER_Q;
 	}
-	spin_unlock(&queue->lock);
+	/* check if we need to switch packing state of this queue */
+	if (card->info.type != QETH_CARD_TYPE_IQD)
+		flush_count += qeth_switch_packing_state(queue);
+	
+	if (flush_count)
+		qeth_flush_buffers(queue, 0, start_index, flush_count);
 
-	tasklet_schedule(&queue->tasklet);
+	if (!atomic_read(&queue->set_pci_flags_count))
+		qeth_flush_buffers_on_no_pci(queue, 0);
+	
+	spin_unlock(&queue->lock);
 	
 	return rc;
 }
@@ -3970,20 +3923,24 @@
 	struct qeth_cmd_buffer *iob;
 	struct qeth_ipa_arp_cmd *cmd;
 	u16 s1, s2;
-	
+
 	QETH_DBF_TEXT(trace,4,"getarpcm");
 	iob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETASSPARMS, proto);
 
 	memcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);
-	/* adjust sizes in IPA_PDU_HEADER */
-	s1 = (u32) IPA_PDU_HEADER_SIZE + QETH_ARP_CMD_BASE_LEN + data_len;
-	s2 = (u32) QETH_ARP_CMD_BASE_LEN + data_len;
-	memcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);
-	memcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);
-	memcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);
-	memcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);
+	
+	if ((IPA_PDU_HEADER_SIZE + QETH_ARP_CMD_BASE_LEN + data_len) > 256) {
+		/* adjust sizes in IPA_PDU_HEADER */
+		s1 = (u32) IPA_PDU_HEADER_SIZE + QETH_ARP_CMD_BASE_LEN +
+			   data_len;
+		s2 = (u32) QETH_ARP_CMD_BASE_LEN + data_len;
+		memcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);
+		memcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);
+		memcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);
+		memcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);
+	}
 
-	cmd = (struct qeth_ipa_arp_cmd *)(iob->data+IPA_PDU_HEADER_SIZE); 
+	cmd = (struct qeth_ipa_arp_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
 	cmd->shdr.assist_no = IPA_ARP_PROCESSING;
 	cmd->shdr.length = 8 + data_len;
 	cmd->shdr.command_code = cmd_code;
@@ -4047,9 +4004,11 @@
 		return -ENOMEM;
 	}
 	memset(qdata, 0, sizeof(struct qeth_arp_query_data));
+	/* do not give sizeof(struct qeth_arp_query_data) to next command;
+	 * this would cause the IPA PDU size to be set to a value of > 256
+	 * and this is to much for HiperSockets */
 	iob = qeth_get_ipa_arp_cmd_buffer(card, IPA_CMD_ASS_ARP_QUERY_INFO,
-					  sizeof(struct qeth_arp_query_data),
-					  QETH_PROT_IPV4);
+					  0, QETH_PROT_IPV4);
 	rc = qeth_send_ipa_arp_cmd(card, iob,
 				   (char *) qdata,
 				   sizeof(struct qeth_arp_query_data),
@@ -4424,6 +4383,10 @@
 		if (!ipm->is_multicast)
 			continue;
 		iptodo = qeth_get_addr_buffer(ipm->proto);
+		if (!iptodo) {
+			QETH_DBF_TEXT(trace, 2, "dmcnomem");
+			continue;
+		}
 		memcpy(iptodo, ipm, sizeof(struct qeth_ipaddr));
 		iptodo->users = iptodo->users * -1;
 		if (!__qeth_insert_ip_todo(card, iptodo, 0))
@@ -4679,29 +4642,29 @@
 		memcpy(cmd->data.setdelip4.mask, &addr->u.a4.mask, 4);
 		cmd->data.setdelip4.flags = flags;
 	}
-	
+
 	rc = qeth_send_ipa_cmd(card, iob, NULL, NULL);
 
 	return rc;
 }
 
-static int 
+static int
 qeth_register_addr_entry(struct qeth_card *card, struct qeth_ipaddr *addr)
 {
 	//char buf[50];
 	int rc;
 	int cnt = 3;
-	
+
 	if (addr->proto == QETH_PROT_IPV4) {
 		QETH_DBF_TEXT(trace, 2,"setaddr4");
-		QETH_DBF_HEX(trace, 4, &addr->u.a4.addr, sizeof(int));
+		QETH_DBF_HEX(trace, 3, &addr->u.a4.addr, sizeof(int));
 	} else if (addr->proto == QETH_PROT_IPV6) {
 		QETH_DBF_TEXT(trace, 2, "setaddr6");
-		QETH_DBF_HEX(trace,4,&addr->u.a6.addr,4);
-		QETH_DBF_HEX(trace,4,((char *)&addr->u.a6.addr)+4,4);
+		QETH_DBF_HEX(trace,3,&addr->u.a6.addr,8);
+		QETH_DBF_HEX(trace,3,((char *)&addr->u.a6.addr)+8,8);
 	} else {
 		QETH_DBF_TEXT(trace, 2, "setaddr?");
-		QETH_DBF_HEX(trace, 4, addr, sizeof(struct qeth_ipaddr));
+		QETH_DBF_HEX(trace, 3, addr, sizeof(struct qeth_ipaddr));
 	}
 	do {
 		if (addr->is_multicast)
@@ -4729,17 +4692,17 @@
 {
 	//char buf[50];
 	int rc;
-	
+
 	if (addr->proto == QETH_PROT_IPV4) {
 		QETH_DBF_TEXT(trace, 2,"deladdr4");
-		QETH_DBF_HEX(trace, 2, &addr->u.a4.addr, sizeof(int));
+		QETH_DBF_HEX(trace, 3, &addr->u.a4.addr, sizeof(int));
 	} else if (addr->proto == QETH_PROT_IPV6) {
 		QETH_DBF_TEXT(trace, 2, "deladdr6");
-		QETH_DBF_HEX(trace, 2, &addr->u.a6.addr,
-			     sizeof(struct in6_addr));
+		QETH_DBF_HEX(trace,3,&addr->u.a6.addr,8);
+		QETH_DBF_HEX(trace,3,((char *)&addr->u.a6.addr)+8,8);
 	} else {
 		QETH_DBF_TEXT(trace, 2, "deladdr?");
-		QETH_DBF_HEX(trace, 2, addr, sizeof(struct qeth_ipaddr));
+		QETH_DBF_HEX(trace, 3, addr, sizeof(struct qeth_ipaddr));
 	}
 	if (addr->is_multicast)
 		rc = qeth_send_setdelmc(card, addr, IPA_CMD_DELIPM);
@@ -5597,6 +5560,47 @@
 	
 }
 
+static void
+qeth_correct_routing_type(struct qeth_card *card, enum qeth_routing_types *type,
+			enum qeth_prot_versions prot)
+{
+	if (card->info.type == QETH_CARD_TYPE_IQD) {
+		switch (*type) {
+		case NO_ROUTER:
+		case PRIMARY_CONNECTOR:
+		case SECONDARY_CONNECTOR:
+		case MULTICAST_ROUTER:
+			return;
+		default:
+			goto out_inval;
+		}
+	} else {
+		switch (*type) {
+		case NO_ROUTER:
+		case PRIMARY_ROUTER:
+		case SECONDARY_ROUTER:
+			return;
+		case MULTICAST_ROUTER:
+			if (qeth_is_ipafunc_supported(card, prot,
+						      IPA_OSA_MC_ROUTER))
+				return;
+		default:
+			goto out_inval;
+		}
+	}
+out_inval:
+	PRINT_WARN("Routing type '%s' not supported for interface %s.\n"
+		   "Router status set to 'no router'.\n",
+		   ((*type == PRIMARY_ROUTER)? "primary router" :
+		    (*type == SECONDARY_ROUTER)? "secondary router" :
+		    (*type == PRIMARY_CONNECTOR)? "primary connector" :
+		    (*type == SECONDARY_CONNECTOR)? "secondary connector" :
+		    (*type == MULTICAST_ROUTER)? "multicast router" :
+		    "unknown"),
+		   card->dev->name);
+	*type = NO_ROUTER;
+}
+
 int 
 qeth_setrouting_v4(struct qeth_card *card)
 {
@@ -5604,8 +5608,8 @@
 
 	QETH_DBF_TEXT(trace,3,"setrtg4");
 
-	if (card->options.route4.type == NO_ROUTER)
-		return 0;
+	qeth_correct_routing_type(card, &card->options.route4.type,
+				  QETH_PROT_IPV4);
 
 	rc = qeth_send_setrouting(card, card->options.route4.type,
 				  QETH_PROT_IPV4);
@@ -5626,6 +5630,9 @@
 	QETH_DBF_TEXT(trace,3,"setrtg6");
 #ifdef CONFIG_QETH_IPV6
 	
+	qeth_correct_routing_type(card, &card->options.route6.type,
+				  QETH_PROT_IPV6);
+
 	if ((card->options.route6.type == NO_ROUTER) ||
 	    ((card->info.type == QETH_CARD_TYPE_OSAE) &&
 	     (card->options.route6.type == MULTICAST_ROUTER) &&
@@ -6515,26 +6522,24 @@
 		addr->u.a4.addr = ifa->ifa_address;
 		addr->u.a4.mask = ifa->ifa_mask;
 		addr->type = QETH_IP_TYPE_NORMAL;
-	}
+	} else
+		goto out;
+
 	switch(event) {
 	case NETDEV_UP:
-		if (addr) {
-			if (!qeth_add_ip(card, addr))
-				kfree(addr);
-		}
+		if (!qeth_add_ip(card, addr))
+			kfree(addr);
 		break;
 	case NETDEV_DOWN:
-		if (addr) {
-			if (!qeth_delete_ip(card, addr))
-				kfree(addr);
-		}
+		if (!qeth_delete_ip(card, addr))
+			kfree(addr);
 		break;
 	default:
 		break;
 	}
 	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
 	schedule_work(&card->kernel_thread_starter);
-	
+out:	
 	return NOTIFY_DONE;
 }
 
@@ -6570,26 +6575,24 @@
 		memcpy(&addr->u.a6.addr, &ifa->addr, sizeof(struct in6_addr));
 		addr->u.a6.pfxlen = ifa->prefix_len;
 		addr->type = QETH_IP_TYPE_NORMAL;
-	}
+	} else
+		goto out;
+
 	switch(event) {
 	case NETDEV_UP:
-		if (addr){
-			if (!qeth_add_ip(card, addr))
-				kfree(addr);
-		}
+		if (!qeth_add_ip(card, addr))
+			kfree(addr);
 		break;
 	case NETDEV_DOWN:
-		if (addr){
-			if (!qeth_delete_ip(card, addr))
-				kfree(addr);
-		}
+		if (!qeth_delete_ip(card, addr))
+			kfree(addr);
 		break;
 	default:
 		break;
 	}
 	qeth_set_thread_start_bit(card, QETH_SET_IP_THREAD);
 	schedule_work(&card->kernel_thread_starter);
-
+out:
 	return NOTIFY_DONE;
 }
 
diff -ruN linux-2.6.5/drivers/s390/net/qeth_sys.c linux-2.5/drivers/s390/net/qeth_sys.c
--- linux-2.6.5/drivers/s390/net/qeth_sys.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/net/qeth_sys.c	Thu Apr 22 17:12:55 2004
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19 $)
+ * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.19.2.1 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to sysfs.
@@ -356,45 +356,32 @@
 
 	if (!strcmp(tmp, "no_router")){
 		route->type = NO_ROUTER;
-		goto check_reset;
-	}
-
-	if (card->info.type == QETH_CARD_TYPE_IQD) {
-		if (!strcmp(tmp, "primary_connector")) {
+	} else if (!strcmp(tmp, "primary_connector")) {
 			route->type = PRIMARY_CONNECTOR;
 		} else if (!strcmp(tmp, "secondary_connector")) {
 			route->type = SECONDARY_CONNECTOR;
 		} else if (!strcmp(tmp, "multicast_router")) {
 			route->type = MULTICAST_ROUTER;
-		} else
-			goto out_inval;
-	} else {
-		if (!strcmp(tmp, "primary_router")) {
+	} else if (!strcmp(tmp, "primary_router")) {
 			route->type = PRIMARY_ROUTER;
 		} else if (!strcmp(tmp, "secondary_router")) {
 			route->type = SECONDARY_ROUTER;
 		} else if (!strcmp(tmp, "multicast_router")) {
-			if (qeth_is_ipafunc_supported(card, prot,
-						      IPA_OSA_MC_ROUTER))
 				route->type = MULTICAST_ROUTER;
-			else
-				goto out_inval;
-		} else
-			goto out_inval;
+	} else {
+		PRINT_WARN("Invalid routing type '%s'.\n", tmp);
+		return -EINVAL;
 	}		
-check_reset:
-	if (old_route_type != route->type){
+	if (((card->state == CARD_STATE_SOFTSETUP) ||
+	     (card->state == CARD_STATE_UP_LAN_OFFLINE) ||
+	     (card->state == CARD_STATE_UP_LAN_ONLINE)) &&
+	    (old_route_type != route->type)){
 		if (prot == QETH_PROT_IPV4)
 			rc = qeth_setrouting_v4(card);
 		else if (prot == QETH_PROT_IPV6)
 			rc = qeth_setrouting_v6(card);
 	}
 	return count;
-out_inval:
-	PRINT_WARN("Routing type '%s' not supported for interface %s.\n"
-		   "Router status not changed.\n",
-		   tmp, card->info.if_name);
-	return -EINVAL;
 }
 
 static ssize_t
diff -ruN linux-2.6.5/drivers/s390/scsi/zfcp_aux.c linux-2.5/drivers/s390/scsi/zfcp_aux.c
--- linux-2.6.5/drivers/s390/scsi/zfcp_aux.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/scsi/zfcp_aux.c	Mon Apr 19 12:49:37 2004
@@ -29,7 +29,7 @@
  */
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_AUX_REVISION "$Revision: 1.105 $"
+#define ZFCP_AUX_REVISION "$Revision: 1.105.2.1 $"
 
 #include "zfcp_ext.h"
 
@@ -1094,17 +1094,6 @@
 {
 	char dbf_name[20];
 
-	/* debug feature area which records fsf request sequence numbers */
-	sprintf(dbf_name, ZFCP_REQ_DBF_NAME "%s",
-		zfcp_get_busid_by_adapter(adapter));
-	adapter->req_dbf = debug_register(dbf_name,
-					  ZFCP_REQ_DBF_INDEX,
-					  ZFCP_REQ_DBF_AREAS,
-					  ZFCP_REQ_DBF_LENGTH);
-	debug_register_view(adapter->req_dbf, &debug_hex_ascii_view);
-	debug_set_level(adapter->req_dbf, ZFCP_REQ_DBF_LEVEL);
-	debug_text_event(adapter->req_dbf, 1, "zzz");
-
 	/* debug feature area which records SCSI command failures (hostbyte) */
 	rwlock_init(&adapter->cmd_dbf_lock);
 	sprintf(dbf_name, ZFCP_CMD_DBF_NAME "%s",
@@ -1147,7 +1136,7 @@
 	debug_register_view(adapter->erp_dbf, &debug_hex_ascii_view);
 	debug_set_level(adapter->erp_dbf, ZFCP_ERP_DBF_LEVEL);
 
-	if (adapter->req_dbf && adapter->cmd_dbf && adapter->abort_dbf &&
+	if (adapter->cmd_dbf && adapter->abort_dbf &&
 	    adapter->in_els_dbf && adapter->erp_dbf)
 		return 0;
 
@@ -1163,7 +1152,6 @@
 zfcp_adapter_debug_unregister(struct zfcp_adapter *adapter)
 {
 	debug_unregister(adapter->erp_dbf);
-	debug_unregister(adapter->req_dbf);
 	debug_unregister(adapter->cmd_dbf);
 	debug_unregister(adapter->abort_dbf);
 	debug_unregister(adapter->in_els_dbf);
diff -ruN linux-2.6.5/drivers/s390/scsi/zfcp_def.h linux-2.5/drivers/s390/scsi/zfcp_def.h
--- linux-2.6.5/drivers/s390/scsi/zfcp_def.h	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/scsi/zfcp_def.h	Mon Apr 19 12:49:37 2004
@@ -33,7 +33,7 @@
 #define ZFCP_DEF_H
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_DEF_REVISION "$Revision: 1.71 $"
+#define ZFCP_DEF_REVISION "$Revision: 1.71.2.1 $"
 
 /*************************** INCLUDES *****************************************/
 
@@ -450,19 +450,12 @@
 #define ZFCP_ERP_DBF_LEVEL     3
 #define ZFCP_ERP_DBF_NAME      "zfcperp"
 
-#define ZFCP_REQ_DBF_INDEX     1
-#define ZFCP_REQ_DBF_AREAS     1
-#define ZFCP_REQ_DBF_LENGTH    8
-#define ZFCP_REQ_DBF_LEVEL     1
-#define ZFCP_REQ_DBF_NAME      "zfcpreq"
-
 #define ZFCP_CMD_DBF_INDEX     2
 #define ZFCP_CMD_DBF_AREAS     1
 #define ZFCP_CMD_DBF_LENGTH    8
 #define ZFCP_CMD_DBF_LEVEL     3
 #define ZFCP_CMD_DBF_NAME      "zfcpcmd"
 
-
 #define ZFCP_ABORT_DBF_INDEX   2
 #define ZFCP_ABORT_DBF_AREAS   1
 #define ZFCP_ABORT_DBF_LENGTH  8
@@ -475,11 +468,6 @@
 #define ZFCP_IN_ELS_DBF_LEVEL  6
 #define ZFCP_IN_ELS_DBF_NAME   "zfcpels"
 
-#define ZFCP_ADAPTER_REQ_DBF_INDEX  4 
-#define ZFCP_ADAPTER_REQ_DBF_AREAS  1
-#define ZFCP_ADAPTER_REQ_DBF_LENGTH 8
-#define ZFCP_ADAPTER_REQ_DBF_LEVEL  6
-
 /******************** LOGGING MACROS AND DEFINES *****************************/
 
 /*
@@ -986,7 +974,6 @@
 	struct zfcp_port	*nameserver_port;  /* adapter's nameserver */
         debug_info_t            *erp_dbf;          /* S/390 debug features */
 	debug_info_t            *abort_dbf;
-	debug_info_t            *req_dbf;
 	debug_info_t            *in_els_dbf;
 	debug_info_t            *cmd_dbf;
 	rwlock_t                cmd_dbf_lock;
diff -ruN linux-2.6.5/drivers/s390/scsi/zfcp_erp.c linux-2.5/drivers/s390/scsi/zfcp_erp.c
--- linux-2.6.5/drivers/s390/scsi/zfcp_erp.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/scsi/zfcp_erp.c	Mon Apr 19 12:49:37 2004
@@ -31,7 +31,7 @@
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_ERP
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_ERP_REVISION "$Revision: 1.49 $"
+#define ZFCP_ERP_REVISION "$Revision: 1.49.2.2 $"
 
 #include "zfcp_ext.h"
 
@@ -1865,6 +1865,7 @@
 	case ZFCP_ERP_FAILED :
 		atomic_inc(&port->erp_counter);
 		if (atomic_read(&port->erp_counter) > ZFCP_MAX_ERPS)
+			zfcp_erp_port_failed(port);
 		break;
 	case ZFCP_ERP_EXIT :
 		/* nothing */
@@ -1874,7 +1875,6 @@
 	if (atomic_test_mask(ZFCP_STATUS_COMMON_ERP_FAILED, &port->status)) {
 		zfcp_erp_port_block(port, 0); /* for ZFCP_ERP_SUCCEEDED */
 		result = ZFCP_ERP_EXIT;
-			zfcp_erp_port_failed(port);
 	}
 
 	return result;
@@ -2397,8 +2397,6 @@
 		ZFCP_LOG_NORMAL("bug: shutdown of QDIO queues failed "
 				"(retval=%d)\n", retval_cleanup);
 	}
-	else
-		debug_text_event(adapter->req_dbf, 1, "q_clean");
 
  failed_qdio_establish:
 	atomic_clear_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status);
@@ -2468,10 +2466,8 @@
 		ZFCP_LOG_NORMAL("bug: shutdown of QDIO queues failed on "
 				"adapter %s\n",
 				zfcp_get_busid_by_adapter(adapter));
-	} else {
+	} else
 		ZFCP_LOG_DEBUG("queues cleaned up\n");
-		debug_text_event(adapter->req_dbf, 1, "q_clean");
-	}
 
 	/*
 	 * First we had to stop QDIO operation.
@@ -2834,9 +2830,10 @@
 			/* nameserver port may live again */
 			atomic_set_mask(ZFCP_STATUS_COMMON_RUNNING,
 					&adapter->nameserver_port->status);
-			zfcp_erp_port_reopen(adapter->nameserver_port, 0);
-			erp_action->step = ZFCP_ERP_STEP_NAMESERVER_OPEN;
-			retval = ZFCP_ERP_CONTINUES;
+			if (zfcp_erp_port_reopen(adapter->nameserver_port, 0) >= 0) {
+				erp_action->step = ZFCP_ERP_STEP_NAMESERVER_OPEN;
+				retval = ZFCP_ERP_CONTINUES;
+			} else  retval = ZFCP_ERP_FAILED;
 			break;
 		}
 		/* else nameserver port is already open, fall through */
@@ -2972,6 +2969,10 @@
 			debug_text_event(adapter->erp_dbf, 3, "p_pstnsw_w");
 			debug_event(adapter->erp_dbf, 3,
 				    &erp_action->port->wwpn, sizeof (wwn_t));
+			if (atomic_test_mask(
+				    ZFCP_STATUS_COMMON_ERP_FAILED,
+				    &adapter->nameserver_port->status))
+				zfcp_erp_port_failed(erp_action->port);
 			zfcp_erp_action_ready(erp_action);
 		}
 	}
@@ -3357,7 +3358,7 @@
 			struct zfcp_adapter *adapter,
 			struct zfcp_port *port, struct zfcp_unit *unit)
 {
-	int retval = -1;
+	int retval = 1;
 	struct zfcp_erp_action *erp_action = NULL;
 	int stronger_action = 0;
 	u32 status = 0;
@@ -3376,7 +3377,7 @@
 
 	if (!atomic_test_mask(ZFCP_STATUS_ADAPTER_ERP_THREAD_UP,
 			      &adapter->status))
-		goto out;
+		return -EIO;
 
 	debug_event(adapter->erp_dbf, 4, &action, sizeof (int));
 	/* check whether we really need this */
diff -ruN linux-2.6.5/drivers/s390/scsi/zfcp_fsf.c linux-2.5/drivers/s390/scsi/zfcp_fsf.c
--- linux-2.6.5/drivers/s390/scsi/zfcp_fsf.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/scsi/zfcp_fsf.c	Mon Apr 19 12:49:37 2004
@@ -29,7 +29,7 @@
  */
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_FSF_C_REVISION "$Revision: 1.43 $"
+#define ZFCP_FSF_C_REVISION "$Revision: 1.43.2.2 $"
 
 #include "zfcp_ext.h"
 
@@ -379,13 +379,6 @@
 				zfcp_get_busid_by_adapter(adapter),
 				fsf_req->qtcb->prefix.prot_status_qual.
 				sequence_error.exp_req_seq_no);
-		debug_text_event(adapter->req_dbf, 1, "exp_seq!");
-		debug_event(adapter->req_dbf, 1,
-			    &fsf_req->qtcb->prefix.prot_status_qual.
-			    sequence_error.exp_req_seq_no, 4);
-		debug_text_event(adapter->req_dbf, 1, "qtcb_seq!");
-		debug_exception(adapter->req_dbf, 1,
-				&fsf_req->qtcb->prefix.req_seq_no, 4);
 		debug_text_exception(adapter->erp_dbf, 0, "prot_seq_err");
 		/* restart operation on this adapter */
 		zfcp_erp_adapter_reopen(adapter, 0);
@@ -891,7 +884,6 @@
 
 	ZFCP_LOG_TRACE("Status Read request initiated (adapter%s)\n",
 		       zfcp_get_busid_by_adapter(adapter));
-	debug_text_event(adapter->req_dbf, 1, "unso");
 	goto out;
 
  failed_req_send:
@@ -1277,10 +1269,6 @@
 	case FSF_FCP_COMMAND_DOES_NOT_EXIST:
 		ZFCP_LOG_FLAGS(2, "FSF_FCP_COMMAND_DOES_NOT_EXIST\n");
 		retval = 0;
-		debug_text_event(new_fsf_req->adapter->req_dbf, 3, "no_exist");
-		debug_event(new_fsf_req->adapter->req_dbf, 3,
-			    &new_fsf_req->qtcb->bottom.support.req_handle,
-			    sizeof (unsigned long));
 		debug_text_event(new_fsf_req->adapter->erp_dbf, 3,
 				 "fsf_s_no_exist");
 		new_fsf_req->status |= ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED;
@@ -3373,10 +3361,6 @@
 	 * (need this for look up on normal command completion)
 	 */
 	fsf_req->data.send_fcp_command_task.scsi_cmnd = scsi_cmnd;
-	debug_text_event(adapter->req_dbf, 3, "fsf/sc");
-	debug_event(adapter->req_dbf, 3, &fsf_req, sizeof (unsigned long));
-	debug_event(adapter->req_dbf, 3, &scsi_cmnd, sizeof (unsigned long));
-
 	fsf_req->data.send_fcp_command_task.start_jiffies = jiffies;
 	fsf_req->data.send_fcp_command_task.unit = unit;
 	ZFCP_LOG_DEBUG("unit=%p, fcp_lun=0x%016Lx\n", unit, unit->fcp_lun);
@@ -3517,12 +3501,9 @@
  send_failed:
  no_fit:
  failed_scsi_cmnd:
-	/* dequeue new FSF request previously enqueued */
-	debug_text_event(adapter->req_dbf, 3, "fail_sc");
-	debug_event(adapter->req_dbf, 3, &scsi_cmnd, sizeof (unsigned long));
-
 	zfcp_fsf_req_free(fsf_req);
 	fsf_req = NULL;
+	scsi_cmnd->host_scribble = NULL;
  success:
  failed_req_create:
 	write_unlock_irqrestore(&adapter->request_queue.queue_lock, lock_flags);
@@ -4267,14 +4248,9 @@
 	 * the new eh
 	 */
 	/* always call back */
-	debug_text_event(fsf_req->adapter->req_dbf, 2, "ok_done:");
-	debug_event(fsf_req->adapter->req_dbf, 2, &scpnt,
-		    sizeof (unsigned long));
-	debug_event(fsf_req->adapter->req_dbf, 2, &scpnt->scsi_done,
-		    sizeof (unsigned long));
-	debug_event(fsf_req->adapter->req_dbf, 2, &fsf_req,
-		    sizeof (unsigned long));
+
 	(scpnt->scsi_done) (scpnt);
+
 	/*
 	 * We must hold this lock until scsi_done has been called.
 	 * Otherwise we may call scsi_done after abort regarding this
@@ -4954,15 +4930,6 @@
 			 "to request queue.\n");
 	} else {
 		req_queue->distance_from_int = new_distance_from_int;
-		debug_text_event(adapter->req_dbf, 1, "o:a/seq");
-		debug_event(adapter->req_dbf, 1, &fsf_req,
-			    sizeof (unsigned long));
-		if (likely(inc_seq_no)) {
-			debug_event(adapter->req_dbf, 1,
-				    &adapter->fsf_req_seq_no, sizeof (u32));
-		} else {
-			debug_text_event(adapter->req_dbf, 1, "nocb");
-		}
 		/*
 		 * increase FSF sequence counter -
 		 * this must only be done for request successfully enqueued to
diff -ruN linux-2.6.5/drivers/s390/scsi/zfcp_qdio.c linux-2.5/drivers/s390/scsi/zfcp_qdio.c
--- linux-2.6.5/drivers/s390/scsi/zfcp_qdio.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/scsi/zfcp_qdio.c	Mon Apr 19 12:49:37 2004
@@ -28,7 +28,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_QDIO_C_REVISION "$Revision: 1.16 $"
+#define ZFCP_QDIO_C_REVISION "$Revision: 1.16.2.1 $"
 
 #include "zfcp_ext.h"
 
@@ -485,10 +485,6 @@
 	struct zfcp_fsf_req *fsf_req;
 	int retval = 0;
 
-	/* Note: seq is entered later */
-	debug_text_event(adapter->req_dbf, 1, "i:a/seq");
-	debug_event(adapter->req_dbf, 1, &sbale_addr, sizeof (unsigned long));
-
 	/* invalid (per convention used in this driver) */
 	if (unlikely(!sbale_addr)) {
 		ZFCP_LOG_NORMAL("bug: invalid reqid\n");
@@ -506,11 +502,6 @@
 		retval = -EINVAL;
 		goto out;
 	}
-	/* debug feature stuff (test for QTCB: remember new unsol. status!) */
-	if (likely(fsf_req->qtcb)) {
-		debug_event(adapter->req_dbf, 1,
-			    &fsf_req->qtcb->prefix.req_seq_no, sizeof (u32));
-	}
 
 	ZFCP_LOG_TRACE("fsf_req at %p, QTCB at %p\n", fsf_req, fsf_req->qtcb);
 	if (likely(fsf_req->qtcb)) {
diff -ruN linux-2.6.5/drivers/s390/scsi/zfcp_scsi.c linux-2.5/drivers/s390/scsi/zfcp_scsi.c
--- linux-2.6.5/drivers/s390/scsi/zfcp_scsi.c	Mon Apr 26 14:47:36 2004
+++ linux-2.5/drivers/s390/scsi/zfcp_scsi.c	Fri Apr 23 16:36:18 2004
@@ -31,7 +31,7 @@
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_SCSI_REVISION "$Revision: 1.59 $"
+#define ZFCP_SCSI_REVISION "$Revision: 1.59.2.2 $"
 
 #include <linux/blkdev.h>
 
@@ -297,10 +297,6 @@
 	if (unlikely(tmp < 0)) {
 		ZFCP_LOG_DEBUG("error: initiation of Send FCP Cmnd failed\n");
 		retval = SCSI_MLQUEUE_HOST_BUSY;
-	} else {
-		debug_text_event(adapter->req_dbf, 3, "q_scpnt");
-		debug_event(adapter->req_dbf, 3, &scpnt,
-			    sizeof (unsigned long));
 	}
 
 out:
@@ -349,7 +345,7 @@
 
 	/* reset the status for this request */
 	scpnt->result = 0;
-	/* save address of mid layer call back function */
+	scpnt->host_scribble = NULL;
 	scpnt->scsi_done = done;
 
 	/*
