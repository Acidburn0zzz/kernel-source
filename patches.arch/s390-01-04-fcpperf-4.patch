From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject:     (kernel):FCP - Performance Data colletion & analysis
References:  bnc#417243

Summary: [PATCH] zfcp: add queue_full sysfs attribute

Adds a new sysfs attribute queue_full for adapters that records the
number of incidents where a requests could not be submitted due to
insufficient free space on the request queue.

Signed-off-by: Stefan Raspl <raspl@linux.vnet.ibm.com>
Signed-off-by: Martin Peschke <mp3@de.ibm.com>
Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>

Acked-by: John Jolly <jjolly@suse.de>

---

 drivers/s390/scsi/zfcp_def.h   |    3 +++
 drivers/s390/scsi/zfcp_fsf.c   |   26 +++++++++++++++++++-------
 drivers/s390/scsi/zfcp_qdio.c  |    1 +
 drivers/s390/scsi/zfcp_scsi.c  |   10 +++++-----
 drivers/s390/scsi/zfcp_sysfs.c |   16 ++++++++++++++++
 5 files changed, 44 insertions(+), 12 deletions(-)

--- a/drivers/s390/scsi/zfcp_def.h
+++ b/drivers/s390/scsi/zfcp_def.h
@@ -568,6 +568,9 @@ struct zfcp_adapter {
 	struct fsf_qtcb_bottom_port *stats_reset_data;
 	unsigned long		stats_reset;
 	struct work_struct	scan_work;
+	atomic_t		qdio_outb_full;	   /* queue full incidents */
+	atomic_t		out_of_mem;
+	atomic_t		out_of_order;
 };
 
 struct zfcp_port {
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@ -718,6 +718,14 @@ static int zfcp_fsf_sbal_check(struct zf
 	return 0;
 }
 
+static int zfcp_fsf_sbal_available(struct zfcp_adapter *adapter)
+{
+	unsigned int count = atomic_read(&adapter->req_q.count);
+	if (!count)
+		atomic_inc(&adapter->qdio_outb_full);
+	return count > 0;
+}
+
 static int zfcp_fsf_req_sbal_get(struct zfcp_adapter *adapter)
 {
 	long ret;
@@ -728,6 +736,8 @@ static int zfcp_fsf_req_sbal_get(struct 
 					zfcp_fsf_sbal_check(req_q), 5 * HZ);
 	if (ret > 0)
 		return 0;
+	if (!ret)
+		atomic_inc(&adapter->qdio_outb_full);
 
 	spin_lock(&req_q->lock);
 	return -EIO;
@@ -986,7 +996,7 @@ struct zfcp_fsf_req *zfcp_fsf_abort_fcp_
 	struct zfcp_fsf_req *req = NULL;
 
 	spin_lock(&adapter->req_q.lock);
-	if (!atomic_read(&adapter->req_q.count))
+	if (!zfcp_fsf_sbal_available(adapter))
 		goto out;
 	req = zfcp_fsf_req_create(adapter, FSF_QTCB_ABORT_FCP_CMND,
 				  req_flags, adapter->pool.fsf_req_abort);
@@ -1221,7 +1231,7 @@ int zfcp_fsf_send_els(struct zfcp_send_e
 		return -EBUSY;
 
 	spin_lock(&adapter->req_q.lock);
-	if (!atomic_read(&adapter->req_q.count))
+	if (!zfcp_fsf_sbal_available(adapter))
 		goto out;
 	req = zfcp_fsf_req_create(adapter, FSF_QTCB_SEND_ELS,
 				  ZFCP_REQ_AUTO_CLEANUP, NULL);
@@ -1266,7 +1276,7 @@ int zfcp_fsf_exchange_config_data(struct
 	int retval = -EIO;
 
 	spin_lock(&adapter->req_q.lock);
-	if (!atomic_read(&adapter->req_q.count))
+	if (!zfcp_fsf_sbal_available(adapter))
 		goto out;
 	req = zfcp_fsf_req_create(adapter,
 				  FSF_QTCB_EXCHANGE_CONFIG_DATA,
@@ -1362,7 +1372,7 @@ int zfcp_fsf_exchange_port_data(struct z
 		return -EOPNOTSUPP;
 
 	spin_lock(&adapter->req_q.lock);
-	if (!atomic_read(&adapter->req_q.count))
+	if (!zfcp_fsf_sbal_available(adapter))
 		goto out;
 	req = zfcp_fsf_req_create(adapter, FSF_QTCB_EXCHANGE_PORT_DATA,
 				  ZFCP_REQ_AUTO_CLEANUP,
@@ -1408,7 +1418,7 @@ int zfcp_fsf_exchange_port_data_sync(str
 		return -EOPNOTSUPP;
 
 	spin_lock(&adapter->req_q.lock);
-	if (!atomic_read(&adapter->req_q.count))
+	if (!zfcp_fsf_sbal_available(adapter))
 		goto out;
 
 	req = zfcp_fsf_req_create(adapter, FSF_QTCB_EXCHANGE_PORT_DATA, 0,
@@ -2257,12 +2267,14 @@ int zfcp_fsf_send_fcp_command_task(struc
 		return -EBUSY;
 
 	spin_lock(&adapter->req_q.lock);
-	if (!atomic_read(&adapter->req_q.count))
+	if (!zfcp_fsf_sbal_available(adapter))
 		goto out;
 	req = zfcp_fsf_req_create(adapter, FSF_QTCB_FCP_CMND, req_flags,
 				  adapter->pool.fsf_req_scsi);
 	if (unlikely(IS_ERR(req))) {
 		retval = PTR_ERR(req);
+		if (retval == -ENOMEM)
+			atomic_inc(&adapter->out_of_mem);
 		goto out;
 	}
 
@@ -2380,7 +2392,7 @@ struct zfcp_fsf_req *zfcp_fsf_send_fcp_c
 		return NULL;
 
 	spin_lock(&adapter->req_q.lock);
-	if (!atomic_read(&adapter->req_q.count))
+	if (!zfcp_fsf_sbal_available(adapter))
 		goto out;
 	req = zfcp_fsf_req_create(adapter, FSF_QTCB_FCP_CMND, req_flags,
 				  adapter->pool.fsf_req_scsi);
--- a/drivers/s390/scsi/zfcp_qdio.c
+++ b/drivers/s390/scsi/zfcp_qdio.c
@@ -283,6 +283,7 @@ static int zfcp_qdio_fill_sbals(struct z
 	     addr += length, remaining -= length) {
 		sbale = zfcp_qdio_sbale_next(fsf_req, sbtype);
 		if (!sbale) {
+			atomic_inc(&fsf_req->adapter->qdio_outb_full);
 			zfcp_qdio_undo_sbals(fsf_req);
 			return -EINVAL;
 		}
--- a/drivers/s390/scsi/zfcp_sysfs.c
+++ b/drivers/s390/scsi/zfcp_sysfs.c
@@ -487,10 +487,26 @@ ZFCP_SHOST_ATTR(megabytes, "%llu %llu\n"
 ZFCP_SHOST_ATTR(seconds_active, "%llu\n",
 		(unsigned long long) stat_info.seconds_act);
 
+static ssize_t zfcp_sysfs_adapter_err_stat_show(struct device *dev,
+						struct device_attribute *attr,
+						char *buf)
+{
+	struct Scsi_Host *scsi_host = class_to_shost(dev);
+	struct zfcp_adapter *adapter =
+		(struct zfcp_adapter *) scsi_host->hostdata[0];
+
+	return sprintf(buf, "%d %d %d\n",
+		       atomic_read(&adapter->qdio_outb_full),
+		       atomic_read(&adapter->out_of_mem),
+		       atomic_read(&adapter->out_of_order));
+}
+static DEVICE_ATTR(error_stats, S_IRUGO, zfcp_sysfs_adapter_err_stat_show, NULL);
+
 struct device_attribute *zfcp_sysfs_shost_attrs[] = {
 	&dev_attr_utilization,
 	&dev_attr_requests,
 	&dev_attr_megabytes,
 	&dev_attr_seconds_active,
+	&dev_attr_error_stats,
 	NULL
 };
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -59,12 +59,12 @@ static int zfcp_scsi_slave_configure(str
 
 static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 {
+	struct zfcp_adapter *adapter;
+
+	adapter = (struct zfcp_adapter *)scpnt->device->host->hostdata[0];
+	atomic_inc(&adapter->out_of_order);
 	set_host_byte(scpnt, result);
-	if ((scpnt->device != NULL) && (scpnt->device->host != NULL))
-		zfcp_scsi_dbf_event_result("fail", 4,
-			(struct zfcp_adapter*) scpnt->device->host->hostdata[0],
-			scpnt, NULL);
-	/* return directly */
+	zfcp_scsi_dbf_event_result("fail", 4, adapter, scpnt, NULL);
 	scpnt->scsi_done(scpnt);
 }
 
