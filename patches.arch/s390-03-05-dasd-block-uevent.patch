From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: dasd: DASD uevents are not sent correctly
References: bnc#440610,LTC#49429

Symptom:     by-id device links are not created
Problem:     On SLES10 there was an extra patch that would send
             uevents for a DASD block device when it reached the
             online state. This code was never upstream and is now
             missing from SLES11.
Solution:    Send change events when device reaches or leaves online
             state.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/block/dasd.c |   33 ++++++++++++++++++++++++++++++---
 1 file changed, 30 insertions(+), 3 deletions(-)

Index: linux-sles11/drivers/s390/block/dasd.c
===================================================================
--- linux-sles11.orig/drivers/s390/block/dasd.c
+++ linux-sles11/drivers/s390/block/dasd.c
@@ -335,7 +335,9 @@ static int dasd_state_unfmt_to_basic(str
 static int
 dasd_state_ready_to_online(struct dasd_device * device)
 {
-	int rc;
+	int rc, i;
+	struct gendisk *disk;
+	struct hd_struct *p;
 
 	if (device->discipline->ready_to_online) {
 		rc = device->discipline->ready_to_online(device);
@@ -343,8 +345,19 @@ dasd_state_ready_to_online(struct dasd_d
 			return rc;
 	}
 	device->state = DASD_STATE_ONLINE;
-	if (device->block)
+	if (device->block) {
 		dasd_schedule_block_bh(device->block);
+
+		disk = device->block->bdev->bd_disk;
+		kobject_uevent(&disk->dev.kobj, KOBJ_CHANGE);
+		/* send uevents for all partitions */
+		for (i = 1; i < disk->minors; i++) {
+			p = disk->part[i-1];
+			if (!p || !p->nr_sects)
+				continue;
+			kobject_uevent(&p->dev.kobj, KOBJ_CHANGE);
+		}
+	}
 	return 0;
 }
 
@@ -353,7 +366,9 @@ dasd_state_ready_to_online(struct dasd_d
  */
 static int dasd_state_online_to_ready(struct dasd_device *device)
 {
-	int rc;
+	int rc, i;
+	struct gendisk *disk;
+	struct hd_struct *p;
 
 	if (device->discipline->online_to_ready) {
 		rc = device->discipline->online_to_ready(device);
@@ -361,6 +376,18 @@ static int dasd_state_online_to_ready(st
 			return rc;
 	}
 	device->state = DASD_STATE_READY;
+
+	/* send uevents for all partitions */
+	if (device->block) {
+		disk = device->block->bdev->bd_disk;
+		for (i = 1; i < disk->minors; i++) {
+			p = disk->part[i-1];
+			if (!p || !p->nr_sects)
+				continue;
+			kobject_uevent(&p->dev.kobj, KOBJ_CHANGE);
+		}
+		kobject_uevent(&disk->dev.kobj, KOBJ_CHANGE);
+	}
 	return 0;
 }
 
