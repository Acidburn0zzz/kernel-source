Date: Thu, 29 Apr 2004 19:31:16 +1000
From: Anton Blanchard <anton@samba.org>
To: torvalds@osdl.org
Cc: olh@suse.de
Subject: [PATCH] cpu hotplug fix


From: Srivatsa Vaddagiri <vatsa@in.ibm.com>

I hit a race in __cpu_up wherein the cpu being onlined
comes up and quickly dies _immediately_.  This is because
by the time __cpu_up had put the cpu in the online_map,
the idle thread on the onlined-cpu had examined its online status
and not finding itself in the online map, died again.

I think following patch should fix it. It causes start_secondary
to stall until its cpu is put in the online map.

diff -puN arch/ppc64/kernel/smp.c~cpu_up_race_fix arch/ppc64/kernel/smp.c
--- ameslab/arch/ppc64/kernel/smp.c~cpu_up_race_fix	2004-04-29 13:02:49.000000000 +0530
+++ ameslab-vatsa/arch/ppc64/kernel/smp.c	2004-04-29 13:43:46.000000000 +0530
@@ -955,7 +955,10 @@ int __devinit __cpu_up(unsigned int cpu)
 
 	if (smp_ops->give_timebase)
 		smp_ops->give_timebase();
-	cpu_set(cpu, cpu_online_map);
+
+	while (!cpu_online(cpu))
+		cpu_relax();
+
 	return 0;
 }
 
@@ -993,6 +996,13 @@ int __devinit start_secondary(void *unus
 #endif
 #endif
 
+	/* Take call_lock. Otherwise smp_call_function can end up
+	 * not waiting for this cpu.
+	 */
+	spin_lock(&call_lock);
+	cpu_set(cpu, cpu_online_map);
+	spin_unlock(&call_lock);
+
 	local_irq_enable();
 
 	return cpu_idle(NULL);

_

-- 


Thanks and Regards,
Srivatsa Vaddagiri,
Linux Technology Center,
IBM Software Labs,
Bangalore, INDIA - 560017

