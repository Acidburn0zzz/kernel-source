- Description: iucv: NULL pointer dereference
  Symptom:     Kernel OOPS
  Problem:     missing return in case of ENOMEM in netiucv_transmit_skb()
               wrong place of an if-branch in conn_action_txdone()
  Solution:    add missing return in netiucv_transmit_skb
               move if (privptr) inside the if
               (skb=...) in conn_action_txdone()
  Problem-ID:  -
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/net/netiucv.c	1 Apr 2004 13:42:09 -0000	1.48
+++ linux-2.5/drivers/s390/net/netiucv.c	15 Apr 2004 09:26:33 -0000	1.48.2.1
@@ -1,5 +1,5 @@
 /*
- * $Id: netiucv.c,v 1.48 2004/04/01 13:42:09 braunu Exp $
+ * $Id: netiucv.c,v 1.48.2.1 2004/04/15 09:26:33 braunu Exp $
  *
  * IUCV network driver
  *
@@ -30,7 +30,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV network driver $Revision: 1.48 $
+ * RELEASE-TAG: IUCV network driver $Revision: 1.48.2.1 $
  *
  */
 
@@ -601,11 +601,12 @@
 		if ((skb = skb_dequeue(&conn->commit_queue))) {
 			atomic_dec(&skb->users);
 			dev_kfree_skb_any(skb);
-		}
-		if (privptr) {
-			privptr->stats.tx_packets++;
-			privptr->stats.tx_bytes +=
-				(skb->len - NETIUCV_HDRLEN - NETIUCV_HDRLEN);
+			if (privptr) {
+				privptr->stats.tx_packets++;
+				privptr->stats.tx_bytes +=
+					(skb->len - NETIUCV_HDRLEN 
+						  - NETIUCV_HDRLEN);
+			}
 		}
 	}
 	conn->tx_buff->data = conn->tx_buff->tail = conn->tx_buff->head;
@@ -1078,6 +1079,7 @@
 				       "%s: Could not allocate tx_skb\n",
 				       conn->netdev->name);
 				rc = -ENOMEM;
+				return rc;
 			} else {
 				skb_reserve(nskb, NETIUCV_HDRLEN);
 				memcpy(skb_put(nskb, skb->len),
@@ -1880,7 +1882,7 @@
 static void
 netiucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.48 $";
+	char vbuf[] = "$Revision: 1.48.2.1 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {

