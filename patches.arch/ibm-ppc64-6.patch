ChangeSet
  1.1530.1.1 04/03/30 14:20:58 dgibson@wocket.ozlabs.ibm.com +2 -0
  Rewrite the iseries_veth link negotiation code to use a single state
  machine instead of a hairy and broken chain of callbacks.  This fixes a
  serious bug which meant the previous version of the driver could not
  interoperate with itself, although it would talk to earlier versions.

  drivers/net/iseries_veth.h
    1.6 04/03/30 14:20:30 dgibson@wocket.ozlabs.ibm.com +8 -18
    Rewrite the iseries_veth link negotiation code to use a single state
    machine instead of a hairy and broken chain of callbacks.  This fixes a
    serious bug which meant the previous version of the driver could not
    interoperate with itself, although it would talk to earlier versions.

  drivers/net/iseries_veth.c
    1.13.1.1 04/03/30 14:20:30 dgibson@wocket.ozlabs.ibm.com +247 -270
    Rewrite the iseries_veth link negotiation code to use a single state
    machine instead of a hairy and broken chain of callbacks.  This fixes a
    serious bug which meant the previous version of the driver could not
    interoperate with itself, although it would talk to earlier versions.

diff -Nru a/drivers/net/iseries_veth.c b/drivers/net/iseries_veth.c
--- a/drivers/net/iseries_veth.c	Tue Mar 30 09:06:51 2004
+++ b/drivers/net/iseries_veth.c	Tue Mar 30 09:06:51 2004
@@ -108,22 +108,20 @@
 static void veth_handle_ack(struct VethLpEvent *);
 static void veth_handle_int(struct VethLpEvent *);
 static void veth_init_connection(struct veth_lpar_connection *cnx, u8 rlp);
-static void veth_open_connection(u8);
-static void veth_finish_open_connection(void *parm);
+static void veth_statemachine(void *p);
 static void veth_close_connection(u8);
 static void veth_set_multicast_list(struct net_device *dev);
+static void veth_flush_pending(struct veth_lpar_connection *cnx);
 
 static void veth_take_cap(struct veth_lpar_connection *, struct VethLpEvent *);
 static void veth_take_cap_ack(struct veth_lpar_connection *, struct VethLpEvent *);
 static void veth_take_monitor_ack(struct veth_lpar_connection *,
 				  struct VethLpEvent *);
 static void veth_recycle_msg(struct veth_lpar_connection *, struct veth_msg *);
-static void veth_monitor_ack_task(void *);
 static void veth_receive(struct veth_lpar_connection *, struct VethLpEvent *);
 static struct net_device_stats *veth_get_stats(struct net_device *dev);
 static int veth_change_mtu(struct net_device *dev, int new_mtu);
 static void veth_timed_ack(unsigned long connectionPtr);
-static void veth_failMe(struct veth_lpar_connection *cnx);
 
 static struct VethFabricMgr *mFabricMgr; /* = NULL */
 static struct net_device *veth_devices[HVMAXARCHITECTEDVIRTUALLANS];
@@ -135,7 +133,15 @@
 MODULE_DESCRIPTION("iSeries Virtual ethernet driver");
 MODULE_LICENSE("GPL");
 
-static int VethModuleReopen = 1;
+#define	VETH_STATE_SHUTDOWN	(0x0001)
+#define VETH_STATE_OPEN		(0x0002)
+#define VETH_STATE_RESET	(0x0004)
+#define VETH_STATE_SENTMON	(0x0008)
+#define VETH_STATE_SENTCAPS	(0x0010)
+#define VETH_STATE_GOTCAPACK	(0x0020)
+#define VETH_STATE_GOTCAPS	(0x0040)
+#define VETH_STATE_SENTCAPACK	(0x0080)
+#define VETH_STATE_READY	(0x0100)
 
 static inline u64 veth_dma_addr(void *p)
 {
@@ -192,6 +198,11 @@
 	return vc.num;
 }
 
+static inline void veth_kick_statemachine(struct veth_lpar_connection *cnx)
+{
+	schedule_work(&cnx->statemachine_wq);
+}
+
 struct net_device * __init veth_probe_one(int vlan)
 {
 	struct net_device *dev;
@@ -290,18 +301,8 @@
 	if (! mFabricMgr)
 		return;
 
-	VethModuleReopen = 0;
-	
-	for (i = 0; i < HVMAXARCHITECTEDLPS; ++i) {
-		struct veth_lpar_connection *cnx = &mFabricMgr->connection[i];
-		unsigned long flags;
-
-		spin_lock_irqsave(&cnx->status_gate, flags);
+	for (i = 0; i < HVMAXARCHITECTEDLPS; ++i)
 		veth_close_connection(i);
-		spin_unlock_irqrestore(&cnx->status_gate, flags);
-	}
-	
-	flush_scheduled_work();
 	
 	HvLpEvent_unregisterHandler(HvLpEvent_Type_VirtualLan);
 	
@@ -387,9 +388,7 @@
 		     || ! HvLpConfig_doLpsCommunicateOnVirtualLan(this_lp, i) )
 			continue;
 
-		spin_lock_irq(&cnx->status_gate);
-		veth_open_connection(i);
-		spin_unlock_irq(&cnx->status_gate);
+		veth_kick_statemachine(cnx);
 	}
 
 	return 0;
@@ -437,17 +436,23 @@
 	HvLpEvent_Rc rc;
 	u32 dma_address, dma_length;
 	struct veth_msg *msg = NULL;
+	int err = 2;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cnx->lock, flags);
 
-	if (! cnx->status.ready)
-		return 2;
+	if (! cnx->state & VETH_STATE_READY)
+		goto out;
 
 	if ((skb->len - 14) > VETH_MAX_MTU)
-		return 2;
+		goto out;
 
 	VETHSTACKPOP(&cnx->msg_stack, msg);
 
-	if (! msg)
-		return 1;
+	if (! msg) {
+		err = 1;
+		goto out;
+	}
 
 	dma_length = skb->len;
 	dma_address = pci_map_single(iSeries_veth_dev, skb->data,
@@ -468,17 +473,21 @@
 		rc = -1;	/* Bad return code */
 		port->stats.tx_errors++;
 	}
-	
+
 	if (rc != HvLpEvent_Rc_Good) {
 		msg->skb = NULL;
 		/* need to set in use to make veth_recycle_msg in case
 		 * this was a mapping failure */
 		set_bit(0, &msg->in_use);
 		veth_recycle_msg(cnx, msg);
-		return 2;
+	} else {
+		err = 0;
 	}
 
-	return 0;
+ out:
+	spin_unlock_irqrestore(&cnx->lock, flags);
+	
+	return err;
 }
 
 static HvLpIndexMap veth_transmit_to_many(struct sk_buff *skb,
@@ -690,6 +699,7 @@
 {
 	HvLpIndex rlp = event->base_event.xSourceLp;
 	struct veth_lpar_connection *cnx = &mFabricMgr->connection[rlp];
+	unsigned long flags;
 	int i;
 
 	switch (event->base_event.xSubtype) {
@@ -701,12 +711,15 @@
 		 * and the hypervisor will return it for us. */
 		break;
 	case VethEventTypeFramesAck:
+		spin_lock_irqsave(&cnx->lock, flags);
 		for (i = 0; i < VETH_MAX_ACKS_PER_MSG; ++i) {
 			u16 msgnum = event->u.frames_ack_data.token[i];
 
 			if (msgnum < VETH_NUMBUFFERS)
 				veth_recycle_msg(cnx, cnx->msgs + msgnum);
 		}
+		spin_unlock_irqrestore(&cnx->lock, flags);
+		veth_flush_pending(cnx);
 		break;
 	case VethEventTypeFrames:
 		veth_receive(cnx, event);
@@ -717,33 +730,25 @@
 	};
 }
 
-static void veth_failMe(struct veth_lpar_connection *cnx)
-{
-	cnx->status.ready = 0;
-}
-
 static void veth_init_connection(struct veth_lpar_connection *cnx, u8 rlp)
 {
 	struct veth_msg *msgs;
 	HvLpIndex this_lp = mFabricMgr->this_lp;
 	int i;
 
-	veth_failMe(cnx);
+	cnx->state = 0;
 
 	cnx->remote_lp = rlp;
 
-	spin_lock_init(&cnx->ack_gate);
-	spin_lock_init(&cnx->status_gate);
+	spin_lock_init(&cnx->lock);
 
-	cnx->status.got_cap = 0;
-	cnx->status.got_cap_ack = 0;
-
-	INIT_WORK(&cnx->finish_open_wq, veth_finish_open_connection, cnx);
-	INIT_WORK(&cnx->monitor_ack_wq, veth_monitor_ack_task, cnx);
+	INIT_WORK(&cnx->statemachine_wq, veth_statemachine, cnx);
 
 	init_timer(&cnx->ack_timer);
 	cnx->ack_timer.function = veth_timed_ack;
 	cnx->ack_timer.data = (unsigned long) cnx;
+	memset(&cnx->pending_acks, 0xff, sizeof (cnx->pending_acks));
+	cnx->num_pending_acks = 0;
 
 	if ( (rlp == this_lp) 
 	     || ! HvLpConfig_doLpsCommunicateOnVirtualLan(this_lp, rlp) )
@@ -767,7 +772,7 @@
 	if (cnx->mNumberAllocated < 2) {
 		veth_error("Couldn't allocate base msgs for lpar %d, only got %d\n",
 			   cnx->remote_lp, cnx->mNumberAllocated);
-		veth_failMe(cnx);
+		/* FIXME: break, somehow */
 		return;
 	}
 
@@ -779,75 +784,13 @@
 	cnx->local_caps.ack_timeout = VETH_ACKTIMEOUT;
 }
 
-static void veth_open_connection(u8 rlp)
-{
-	struct veth_lpar_connection *cnx = &mFabricMgr->connection[rlp];
-	HvLpEvent_Rc rc;
-	u64 *rawcap = (u64 *) &cnx->local_caps;
-
-	if (! cnx->msgs || (cnx->mNumberAllocated < 2)
-	    || ! cnx->mNumberRcvMsgs) {
-		veth_failMe(cnx);
-		return;
-	}
-
-	spin_lock_irq(&cnx->ack_gate);
-
-	memset(&cnx->pending_acks, 0xff, sizeof (cnx->pending_acks));
-	cnx->num_pending_acks = 0;
-
-	HvCallEvent_openLpEventPath(rlp, HvLpEvent_Type_VirtualLan);
-
-	cnx->status.open = 1;
-
-	cnx->src_inst = 
-		HvCallEvent_getSourceLpInstanceId(rlp,
-						  HvLpEvent_Type_VirtualLan);
-	cnx->dst_inst =
-		HvCallEvent_getTargetLpInstanceId(rlp,
-						  HvLpEvent_Type_VirtualLan);
-
-	spin_unlock_irq(&cnx->ack_gate);
-
-	rc = veth_signalevent(cnx, VethEventTypeCap,
-			      HvLpEvent_AckInd_DoAck,
-			      HvLpEvent_AckType_ImmediateAck,
-			      0, rawcap[0], rawcap[1], rawcap[2], rawcap[3],
-			      rawcap[4]);
-
-	if ( (rc == HvLpEvent_Rc_PartitionDead)
-	     || (rc == HvLpEvent_Rc_PathClosed)) {
-		/* Never mind we'll resend out caps when we get the
-		 * caps from the other end comes up and sends
-		 * theirs */
-		return;
-	} else if (rc != HvLpEvent_Rc_Good) {
-		veth_error("Couldn't send capabilities to lpar %d, rc=%x\n",
-				  cnx->remote_lp, (int) rc);
-		veth_failMe(cnx);
-		return;
-	}
-
-	cnx->status.sent_caps = 1;
-}
-
-static void veth_finish_open_connection(void *parm)
+static int veth_process_caps(struct veth_lpar_connection *cnx)
 {
-	struct veth_lpar_connection *cnx = (struct veth_lpar_connection *)parm;
 	struct VethCapData *remote_caps = &cnx->remote_caps;
-	u64 num_acks_needed = 0;
-	HvLpEvent_Rc rc;
-
-	spin_lock_irq(&cnx->status_gate);
-
-	memcpy(remote_caps, &cnx->cap_event.u.caps_data,
-	       sizeof(*remote_caps));
+	int num_acks_needed;
 
 	/* Convert timer to jiffies */
-	if (cnx->local_caps.ack_timeout)
-		cnx->ack_timeout = remote_caps->ack_timeout * HZ / 1000000;
-	else
-		cnx->ack_timeout = VETH_ACKTIMEOUT * HZ / 1000000;
+	cnx->ack_timeout = remote_caps->ack_timeout * HZ / 1000000;
 
 	if ( (remote_caps->num_buffers == 0)
 	     || (remote_caps->ack_threshold > VETH_MAX_ACKS_PER_MSG)
@@ -855,160 +798,227 @@
 	     || (cnx->ack_timeout == 0) ) {
 		veth_error("Received incompatible capabilities from lpar %d\n",
 			   cnx->remote_lp);
-		cnx->cap_event.base_event.xRc = HvLpEvent_Rc_InvalidSubtypeData;
-		HvCallEvent_ackLpEvent((struct HvLpEvent *)&cnx->cap_event);
-
-		veth_failMe(cnx);
-		goto out;
+		return HvLpEvent_Rc_InvalidSubtypeData;
 	}
 
-	num_acks_needed = (remote_caps->num_buffers / remote_caps->ack_threshold) + 1;
+	num_acks_needed = (remote_caps->num_buffers
+			   / remote_caps->ack_threshold) + 1;
 
+	/* FIXME: locking on mNumberLpAcksAlloced */
 	if (cnx->mNumberLpAcksAlloced < num_acks_needed) {
 		int num;
 		
 		num_acks_needed = num_acks_needed - cnx->mNumberLpAcksAlloced;
 		
-		spin_unlock_irq(&cnx->status_gate);
-		
 		num = veth_allocate_events(cnx->remote_lp, num_acks_needed);
-		
 		if (num > 0)
 			cnx->mNumberLpAcksAlloced += num;
-		spin_lock_irq(&cnx->status_gate);
 	}
 	
 	if (cnx->mNumberLpAcksAlloced < num_acks_needed) {
 		veth_error("Couldn't allocate all the frames ack events for lpar %d\n",
 			   cnx->remote_lp);
 
-		cnx->cap_event.base_event.xRc = HvLpEvent_Rc_BufferNotAvailable;
-		HvCallEvent_ackLpEvent((struct HvLpEvent *)&cnx->cap_event);
+		return HvLpEvent_Rc_BufferNotAvailable;
+	}
 
-		veth_failMe(cnx);
-		goto out;
+	return HvLpEvent_Rc_Good;
+}
+
+/* FIXME: The gotos here are a bit dubious */
+static void veth_statemachine(void *p)
+{
+	struct veth_lpar_connection *cnx = (struct veth_lpar_connection *)p;
+	int rlp = cnx->remote_lp;
+	int rc;
+
+	spin_lock_irq(&cnx->lock);
+
+ restart:
+	if (cnx->state & VETH_STATE_RESET) {
+		int i;
+
+		del_timer(&cnx->ack_timer);
+
+		if (cnx->state & VETH_STATE_OPEN)
+			HvCallEvent_closeLpEventPath(cnx->remote_lp,
+						     HvLpEvent_Type_VirtualLan);
+
+		/* reset ack data */
+		memset(&cnx->pending_acks, 0xff, sizeof (cnx->pending_acks));
+		cnx->num_pending_acks = 0;
+
+		cnx->state &= ~(VETH_STATE_RESET | VETH_STATE_SENTMON
+				| VETH_STATE_OPEN | VETH_STATE_SENTCAPS
+				| VETH_STATE_GOTCAPACK | VETH_STATE_GOTCAPS
+				| VETH_STATE_SENTCAPACK | VETH_STATE_READY);
+		
+		/* Clean up any leftover messages */
+		if (cnx->msgs)
+			for (i = 0; i < VETH_NUMBUFFERS; ++i)
+				veth_recycle_msg(cnx, cnx->msgs + i);
 	}
 
-	rc = HvCallEvent_ackLpEvent((struct HvLpEvent *)&cnx->cap_event);
-	if (rc != HvLpEvent_Rc_Good) {
-		veth_error("Failed to ack remote cap for lpar %d with rc %x\n",
-			   cnx->remote_lp, (int) rc);
-		veth_failMe(cnx);
+	if (cnx->state & VETH_STATE_SHUTDOWN)
+		/* It's all over, do nothing */
 		goto out;
+
+	if ( !(cnx->state & VETH_STATE_OPEN) ) {
+		if (! cnx->msgs || (cnx->mNumberAllocated < 2)
+		    || ! cnx->mNumberRcvMsgs)
+			goto cant_cope;
+
+		HvCallEvent_openLpEventPath(rlp, HvLpEvent_Type_VirtualLan);
+		cnx->src_inst = 
+			HvCallEvent_getSourceLpInstanceId(rlp,
+							  HvLpEvent_Type_VirtualLan);
+		cnx->dst_inst =
+			HvCallEvent_getTargetLpInstanceId(rlp,
+							  HvLpEvent_Type_VirtualLan);
+		cnx->state |= VETH_STATE_OPEN;
 	}
 
-	if (cnx->cap_ack_event.base_event.xRc != HvLpEvent_Rc_Good) {
-		veth_printk(KERN_ERR, "Bad rc(%d) from lpar %d on capabilities\n",
-			    cnx->cap_ack_event.base_event.xRc, cnx->remote_lp);
-		veth_failMe(cnx);
-		goto out;
+	if ( (cnx->state & VETH_STATE_OPEN)
+	     && !(cnx->state & VETH_STATE_SENTMON) ) {
+		rc = veth_signalevent(cnx, VethEventTypeMonitor,
+				      HvLpEvent_AckInd_DoAck,
+				      HvLpEvent_AckType_DeferredAck,
+				      0, 0, 0, 0, 0, 0);
+		
+		if (rc == HvLpEvent_Rc_Good) {
+			cnx->state |= VETH_STATE_SENTMON;
+		} else {
+			if ( (rc != HvLpEvent_Rc_PartitionDead)
+			     && (rc != HvLpEvent_Rc_PathClosed) )
+				veth_error("Error sending monitor to "
+					   "lpar %d, rc=%x\n",
+					   rlp, (int) rc);
+
+			/* Oh well, hope we get a cap from the other
+			 * end and do better when that kicks us */
+			goto out;
+		}
 	}
 
-	/* Send the monitor */
-	rc = veth_signalevent(cnx, VethEventTypeMonitor,
-			      HvLpEvent_AckInd_DoAck,
-			      HvLpEvent_AckType_DeferredAck,
-			      0, 0, 0, 0, 0, 0);
-	
-	if (rc != HvLpEvent_Rc_Good) {
-		veth_error("Monitor send to lpar %d failed with rc %x\n",
-				  cnx->remote_lp, (int) rc);
-		veth_failMe(cnx);
-		goto out;
+	if ( (cnx->state & VETH_STATE_OPEN)
+	     && !(cnx->state & VETH_STATE_SENTCAPS)) {
+		u64 *rawcap = (u64 *)&cnx->local_caps;
+
+		rc = veth_signalevent(cnx, VethEventTypeCap,
+				      HvLpEvent_AckInd_DoAck,
+				      HvLpEvent_AckType_ImmediateAck,
+				      0, rawcap[0], rawcap[1], rawcap[2],
+				      rawcap[3], rawcap[4]);
+
+		if (rc == HvLpEvent_Rc_Good) {
+			cnx->state |= VETH_STATE_SENTCAPS;
+		} else {
+			if ( (rc != HvLpEvent_Rc_PartitionDead)
+			     && (rc != HvLpEvent_Rc_PathClosed) )
+				veth_error("Error sending caps to "
+					   "lpar %d, rc=%x\n",
+					   rlp, (int) rc);
+			/* Oh well, hope we get a cap from the other
+			 * end and do better when that kicks us */
+			goto out;
+		}
 	}
 
-	cnx->status.ready = 1;
-	
-	/* Start the ACK timer */
-	cnx->ack_timer.expires = jiffies + cnx->ack_timeout;
-	add_timer(&cnx->ack_timer);
+	if ((cnx->state & VETH_STATE_GOTCAPS)
+	    && !(cnx->state & VETH_STATE_SENTCAPACK)) {
+		struct VethCapData *remote_caps = &cnx->remote_caps;
+
+		memcpy(remote_caps, &cnx->cap_event.u.caps_data,
+		       sizeof(*remote_caps));
+
+		spin_unlock_irq(&cnx->lock);
+		rc = veth_process_caps(cnx);
+		spin_lock_irq(&cnx->lock);
+
+		/* We dropped the lock, so recheck for anything which
+		 * might mess us up */
+		if (cnx->state & (VETH_STATE_RESET|VETH_STATE_SHUTDOWN))
+			goto restart;
+
+		cnx->cap_event.base_event.xRc = rc;
+		HvCallEvent_ackLpEvent((struct HvLpEvent *)&cnx->cap_event);
+		if (rc == HvLpEvent_Rc_Good)
+			cnx->state |= VETH_STATE_SENTCAPACK;
+		else
+			goto cant_cope;
+	}
+
+	if ((cnx->state & VETH_STATE_GOTCAPACK)
+	    && (cnx->state & VETH_STATE_GOTCAPS)
+	    && !(cnx->state & VETH_STATE_READY)) {
+		if (cnx->cap_ack_event.base_event.xRc == HvLpEvent_Rc_Good) {
+			/* Start the ACK timer */
+			cnx->ack_timer.expires = jiffies + cnx->ack_timeout;
+			add_timer(&cnx->ack_timer);
+			cnx->state |= VETH_STATE_READY;
+		} else {
+			veth_printk(KERN_ERR, "Caps rejected (rc=%d) by "
+				    "lpar %d\n",
+				    cnx->cap_ack_event.base_event.xRc,
+				    rlp);
+			goto cant_cope;
+		}
+	}
 
  out:
-	spin_unlock_irq(&cnx->status_gate);
+	spin_unlock_irq(&cnx->lock);
+	return;
+
+ cant_cope:
+	/* FIXME: we get here if something happens we really can't
+	 * cope with.  The link will never work once we get here, and
+	 * all we can do is not lock the rest of the system up */
+	veth_error("Badness on connection to lpar %d (state=%04lx) "
+		   " - shutting down\n", rlp, cnx->state);
+	cnx->state |= VETH_STATE_SHUTDOWN;
+	spin_unlock_irq(&cnx->lock);
 }
 
 static void veth_close_connection(u8 rlp)
 {
 	struct veth_lpar_connection *cnx = &mFabricMgr->connection[rlp];
-	unsigned long flags;
-
-	del_timer_sync(&cnx->ack_timer);
 
-	cnx->status.sent_caps = 0;
-	cnx->status.got_cap = 0;
-	cnx->status.got_cap_ack = 0;
-
-	if (cnx->status.open) {
-		int i;		
-
-		HvCallEvent_closeLpEventPath(rlp, HvLpEvent_Type_VirtualLan);
-		cnx->status.open = 0;
-		veth_failMe(cnx);
+	spin_lock_irq(&cnx->lock);
+	cnx->state |= VETH_STATE_RESET | VETH_STATE_SHUTDOWN;
+	veth_kick_statemachine(cnx);
+	spin_unlock_irq(&cnx->lock);
 
-		/* reset ack data */
-		spin_lock_irqsave(&cnx->ack_gate, flags);
-
-		memset(&cnx->pending_acks, 0xff, sizeof (cnx->pending_acks));
-		cnx->num_pending_acks = 0;
-
-		spin_unlock_irqrestore(&cnx->ack_gate, flags);
-
-		/* Clean up any leftover messages */
-		for (i = 0; i < VETH_NUMBUFFERS; ++i)
-			veth_recycle_msg(cnx, cnx->msgs + i);
-	}
+	flush_scheduled_work();
 
+	/* FIXME: not sure if this is necessary - will already have
+	 * been deleted by the state machine, just want to make sure
+	 * its not running any more */
+	del_timer_sync(&cnx->ack_timer);
 }
 
-static void veth_take_cap(struct veth_lpar_connection *cnx, struct VethLpEvent *event)
+static void veth_take_cap(struct veth_lpar_connection *cnx,
+			  struct VethLpEvent *event)
 {
 	unsigned long flags;
-	HvLpEvent_Rc rc;
 
-	spin_lock_irqsave(&cnx->status_gate, flags);
+	spin_lock_irqsave(&cnx->lock, flags);
+	/* Receiving caps may mean the other end has just come up, so
+	 * we need to reload the instance ID of the far end */
+	cnx->dst_inst =
+		HvCallEvent_getTargetLpInstanceId(cnx->remote_lp,
+						  HvLpEvent_Type_VirtualLan);
 
-	if (cnx->status.got_cap) {
+	if (cnx->state & VETH_STATE_GOTCAPS) {
 		veth_error("Received a second capabilities from lpar %d\n",
 			   cnx->remote_lp);
 		event->base_event.xRc = HvLpEvent_Rc_BufferNotAvailable;
 		HvCallEvent_ackLpEvent((struct HvLpEvent *) event);
-		goto out;
-	}
-
-	memcpy(&cnx->cap_event, event, sizeof (cnx->cap_event));
-	/* If we failed to send caps out before (presumably because
-	 * the target lpar was down), send them now. */
-	if (! cnx->status.sent_caps) {
-		u64 *rawcap = (u64 *) &cnx->local_caps;
-
-		cnx->dst_inst =
-			HvCallEvent_getTargetLpInstanceId(cnx->remote_lp,
-							  HvLpEvent_Type_VirtualLan);
-
-		rc = veth_signalevent(cnx, VethEventTypeCap,
-				      HvLpEvent_AckInd_DoAck,
-				      HvLpEvent_AckType_ImmediateAck,
-				      0, rawcap[0], rawcap[1], rawcap[2], rawcap[3],
-				      rawcap[4]);
-		if ( (rc == HvLpEvent_Rc_PartitionDead)
-		     || (rc == HvLpEvent_Rc_PathClosed)) {
-			veth_error("Partition down when resending capabilities!!\n");
-			goto out;
-		} else if (rc != HvLpEvent_Rc_Good) {
-			veth_error("Couldn't send cap to lpar %d, rc %x\n",
-				   cnx->remote_lp, (int) rc);
-			veth_failMe(cnx);
-			goto out;
-		}
-		cnx->status.sent_caps = 1;
+	} else {
+		memcpy(&cnx->cap_event, event, sizeof(cnx->cap_event));
+		cnx->state |= VETH_STATE_GOTCAPS;
+		veth_kick_statemachine(cnx);
 	}
-
-	cnx->status.got_cap = 1;
-	if (cnx->status.got_cap_ack)
-		schedule_work(&cnx->finish_open_wq);
-
- out:
-	spin_unlock_irqrestore(&cnx->status_gate, flags);
+	spin_unlock_irqrestore(&cnx->lock, flags);
 }
 
 static void veth_take_cap_ack(struct veth_lpar_connection *cnx,
@@ -1016,22 +1026,17 @@
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&cnx->status_gate, flags);
-
-	if (cnx->status.got_cap_ack) {
+	spin_lock_irqsave(&cnx->lock, flags);
+	if (cnx->state & VETH_STATE_GOTCAPACK) {
 		veth_error("Received a second capabilities ack from lpar %d\n",
 			   cnx->remote_lp);
-		goto out;
+	} else {
+		memcpy(&cnx->cap_ack_event, event,
+		       sizeof(&cnx->cap_ack_event));
+		cnx->state |= VETH_STATE_GOTCAPACK;
+		veth_kick_statemachine(cnx);
 	}
-
-	memcpy(&cnx->cap_ack_event, event, sizeof(&cnx->cap_ack_event));
-	cnx->status.got_cap_ack = 1;
-
-	if (cnx->status.got_cap)
-		schedule_work(&cnx->finish_open_wq);
-
- out:
-	spin_unlock_irqrestore(&cnx->status_gate, flags);
+	spin_unlock_irqrestore(&cnx->lock, flags);
 }
 
 static void veth_take_monitor_ack(struct veth_lpar_connection *cnx,
@@ -1039,27 +1044,18 @@
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&cnx->status_gate, flags);
-
-	veth_printk(KERN_DEBUG, "Monitor ack returned for lpar %d\n", cnx->remote_lp);
-
-	if (cnx->status.monitor_ack_pending) {
-		veth_error("Received a monitor ack from lpar %d while already processing one\n",
-			   cnx->remote_lp);
-		goto out;
-	}
-
-	schedule_work(&cnx->monitor_ack_wq);
-
- out:
-	spin_unlock_irqrestore(&cnx->status_gate, flags);
+	spin_lock_irqsave(&cnx->lock, flags);
+	veth_printk(KERN_DEBUG, "Monitor ack returned for lpar %d\n",
+		    cnx->remote_lp);
+	cnx->state |= VETH_STATE_RESET;
+	veth_kick_statemachine(cnx);
+	spin_unlock_irqrestore(&cnx->lock, flags);
 }
 
 static void veth_recycle_msg(struct veth_lpar_connection *cnx,
 			     struct veth_msg *myMsg)
 {
 	u32 dma_address, dma_length;
-	int i;
 
 	if (test_and_clear_bit(0, &myMsg->in_use)) {
 		dma_address = myMsg->data.addr[0];
@@ -1075,12 +1071,15 @@
 
 		memset(&myMsg->data, 0, sizeof(myMsg->data));
 		VETHSTACKPUSH(&cnx->msg_stack, myMsg);
-	} else {
-		if (cnx->status.open)
-			veth_error("Bogus frames ack from lpar %d (index=%d)\n",
+	} else
+		if (cnx->state & VETH_STATE_OPEN)
+			veth_error("Bogus frames ack from lpar %d (#%d)\n",
 				   cnx->remote_lp, myMsg->token);
-	}
+}
 
+static void veth_flush_pending(struct veth_lpar_connection *cnx)
+{
+	int i;
 	for (i = 0; i < veth_num_devices; i++) {
 		struct net_device *dev = veth_devices[i];
 		struct veth_port *port = (struct veth_port *)dev->priv;
@@ -1105,28 +1104,6 @@
 	}
 }
 
-static void veth_monitor_ack_task(void *parm)
-{
-	struct veth_lpar_connection *cnx = (struct veth_lpar_connection *) parm;
-
-	spin_lock_irq(&cnx->status_gate);
-
-	veth_failMe(cnx);
-
-	if (cnx->status.open) {
-		veth_close_connection(cnx->remote_lp);
-
-		udelay(100);
-	}
-
-	if (VethModuleReopen)
-		veth_open_connection(cnx->remote_lp);
-
-	cnx->status.monitor_ack_pending = 0;
-
-	spin_unlock_irq(&cnx->status_gate);
-}
-
 static inline int veth_frame_wanted(struct veth_port *port, u64 mac_addr)
 {
 	int wanted = 0;
@@ -1299,7 +1276,7 @@
 	} while (startchunk += nchunks, startchunk < VETH_MAX_FRAMES_PER_MSG);
 
 	/* Ack it */
-	spin_lock_irqsave(&cnx->ack_gate, flags);
+	spin_lock_irqsave(&cnx->lock, flags);
 	
 	if (cnx->num_pending_acks < VETH_MAX_ACKS_PER_MSG) {
 		cnx->pending_acks[cnx->num_pending_acks] =
@@ -1320,7 +1297,7 @@
 		
 	}
 	
-	spin_unlock_irqrestore(&cnx->ack_gate, flags);
+	spin_unlock_irqrestore(&cnx->lock, flags);
 }
 
 static void veth_timed_ack(unsigned long ptr)
@@ -1330,7 +1307,7 @@
 	struct veth_lpar_connection *cnx = (struct veth_lpar_connection *) ptr;
 
 	/* Ack all the events */
-	spin_lock_irqsave(&cnx->ack_gate, flags);
+	spin_lock_irqsave(&cnx->lock, flags);
 
 	if (cnx->num_pending_acks > 0) {
 		rc = veth_signaldata(cnx, VethEventTypeFramesAck,
@@ -1343,7 +1320,7 @@
 		memset(&cnx->pending_acks, 0xff, sizeof(cnx->pending_acks));
 	}
 
-	spin_unlock_irqrestore(&cnx->ack_gate, flags);
+	spin_unlock_irqrestore(&cnx->lock, flags);
 
 	/* Reschedule the timer */
 	cnx->ack_timer.expires = jiffies + cnx->ack_timeout;
diff -Nru a/drivers/net/iseries_veth.h b/drivers/net/iseries_veth.h
--- a/drivers/net/iseries_veth.h	Tue Mar 30 09:06:51 2004
+++ b/drivers/net/iseries_veth.h	Tue Mar 30 09:06:51 2004
@@ -82,33 +82,23 @@
 
 struct veth_lpar_connection {
 	HvLpIndex remote_lp;
-	struct work_struct finish_open_wq;
-	struct work_struct monitor_ack_wq;
-	struct timer_list ack_timer;
+	struct work_struct statemachine_wq;
 	struct veth_msg *msgs;
+	int mNumberAllocated;
+	int mNumberRcvMsgs;
+	struct VethCapData local_caps;
+
+	struct timer_list ack_timer;
 
+	spinlock_t lock;
+	unsigned long state;
 	HvLpInstanceId src_inst;
 	HvLpInstanceId dst_inst;
-
-	spinlock_t status_gate;
-	struct {
-		u64 open:1;
-		u64 ready:1;
-		u64 sent_caps:1;
-		u64 got_cap:1;
-		u64 got_cap_ack:1;
-		u64 monitor_ack_pending:1;
-	} status;
 	struct VethLpEvent cap_event, cap_ack_event;
-
-	spinlock_t ack_gate;
 	u16 pending_acks[VETH_MAX_ACKS_PER_MSG];
 	u32 num_pending_acks;
 
-	int mNumberAllocated;
-	int mNumberRcvMsgs;
 	int mNumberLpAcksAlloced;
-	struct VethCapData local_caps;
 	struct VethCapData remote_caps;
 	u32 ack_timeout;
 
.........................................................................
# vim: syntax=diff

