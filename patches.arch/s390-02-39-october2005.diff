From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: IBM Codestream linux-2.6.15 october2005, patch 02-39

  Description: tape: Fix timeout and deferred codition code handling for assign
               requests
  Symptom:     'chccwdev -e' hangs. Endless loop of retry messages.
  Problem:     If a tape device is assigned to another host, the interrupt for
               the assign operation comes back with deferred condition code 1.
               The tape interrupt handler reacts to that with retries. After
               some delay the timeout handler for the assign operation is called
               and the assign request is cancelled. There are some conditions,
               depending on timing, which lead to an endless loop of retries.
  Solution:    Check in the deferred condition code handling, if the request is
               still in IO. This prevents retries, when requests have already
               been cancelled. Use existing infrastructure for request
               cancellation and therefore export the tape_cancel_io() function.
  Problem-ID:  -
  Archs:       s390-31, s390-64

Acked-by: Hannes Reinecke <hare@suse.de>

--- linux-2.5/drivers/s390/char/tape_core.c	17 Mar 2006 13:14:44 -0000	1.56.2.2
+++ linux-2.5/drivers/s390/char/tape_core.c	17 Mar 2006 13:21:57 -0000	1.56.2.3
@@ -761,6 +761,13 @@
 		 */
 		if (request->status == TAPE_REQUEST_IN_IO)
 			return;
+		/*
+		 * Request has already been stopped. We have to wait until
+		 * the request is removed from the queue in the interrupt
+		 * handling.
+		 */
+		if (request->status == TAPE_REQUEST_DONE)
+			return;
 
 		/*
 		 * We wanted to cancel the request but the common I/O layer
@@ -1024,6 +1031,20 @@
 }
 
 /*
+ * Stop running ccw.
+ */
+int
+tape_cancel_io(struct tape_device *device, struct tape_request *request)
+{
+	int rc;
+
+	spin_lock_irq(get_ccwdev_lock(device->cdev));
+	rc = __tape_cancel_io(device, request);
+	spin_unlock_irq(get_ccwdev_lock(device->cdev));
+	return rc;
+}
+
+/*
  * Tape interrupt routine, called from the ccw_device layer
  */
 static void
@@ -1064,15 +1085,16 @@
 	/*
 	 * If the condition code is not zero and the start function bit is
 	 * still set, this is an deferred error and the last start I/O did
-	 * not succeed. Restart the request now.
+	 * not succeed. At this point the condition that caused the deferred
+	 * error might still apply. So we just schedule the request to be
+	 * started later.
 	 */
-	if (irb->scsw.cc != 0 && (irb->scsw.fctl & SCSW_FCTL_START_FUNC)) {
-		PRINT_WARN("(%s): deferred cc=%i. restaring\n",
-			cdev->dev.bus_id,
-			irb->scsw.cc);
-		rc = __tape_start_io(device, request);
-		if (rc)
-			__tape_end_request(device, request, rc);
+	if (irb->scsw.cc != 0 && (irb->scsw.fctl & SCSW_FCTL_START_FUNC) &&
+	    (request->status == TAPE_REQUEST_IN_IO)) {
+		DBF_EVENT(3,"(%08x): deferred cc=%i, fctl=%i. restarting\n",
+			device->cdev_id, irb->scsw.cc, irb->scsw.fctl);
+		request->status = TAPE_REQUEST_QUEUED;
+		schedule_delayed_work(&device->tape_dnr, HZ);
 		return;
 	}
 
@@ -1287,4 +1309,5 @@
 EXPORT_SYMBOL(tape_do_io);
 EXPORT_SYMBOL(tape_do_io_async);
 EXPORT_SYMBOL(tape_do_io_interruptible);
+EXPORT_SYMBOL(tape_cancel_io);
 EXPORT_SYMBOL(tape_mtop);

--- linux-2.5/drivers/s390/char/tape.h	9 Jun 2005 12:49:22 -0000	1.29
+++ linux-2.5/drivers/s390/char/tape.h	17 Mar 2006 13:21:57 -0000	1.29.6.1
@@ -250,6 +250,7 @@
 extern int tape_do_io(struct tape_device *, struct tape_request *);
 extern int tape_do_io_async(struct tape_device *, struct tape_request *);
 extern int tape_do_io_interruptible(struct tape_device *, struct tape_request *);
+extern int tape_cancel_io(struct tape_device *, struct tape_request *);
 void tape_hotplug_event(struct tape_device *, int major, int action);
 
 static inline int

--- linux-2.5/drivers/s390/char/tape_std.c	9 Jun 2004 12:35:41 -0000	1.16
+++ linux-2.5/drivers/s390/char/tape_std.c	17 Mar 2006 13:21:57 -0000	1.16.36.1
@@ -37,20 +37,19 @@
 {
 	struct tape_request *	request;
 	struct tape_device *	device;
+	int rc;
 
 	request = (struct tape_request *) data;
 	if ((device = request->device) == NULL)
 		BUG();
 
-	spin_lock_irq(get_ccwdev_lock(device->cdev));
-	if (request->callback != NULL) {
-		DBF_EVENT(3, "%08x: Assignment timeout. Device busy.\n",
+	DBF_EVENT(3, "%08x: Assignment timeout. Device busy.\n",
 			device->cdev_id);
-		PRINT_ERR("%s: Assignment timeout. Device busy.\n",
-			device->cdev->dev.bus_id);
-		ccw_device_clear(device->cdev, (long) request);
-	}
-	spin_unlock_irq(get_ccwdev_lock(device->cdev));
+	rc = tape_cancel_io(device, request);
+	if(rc)
+		PRINT_ERR("(%s): Assign timeout: Cancel failed with rc = %i\n",
+			device->cdev->dev.bus_id, rc);
+		
 }
 
 int

