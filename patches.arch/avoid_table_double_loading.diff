Subject: dont load acpi tables twice
From: Thomas Renninger (trenn@suse.de)

The OEM/revision id and the checksum of new tables is compared 
with already loaded ones. Loading is
denied if the table already exists in the kernel's AML namespace.

Bugzilla: http://bugzilla.kernel.org/show_bug.cgi?id=4749

--- linux-2.6.14/drivers/acpi/namespace/nsload.c.orig	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14/drivers/acpi/namespace/nsload.c	2005-11-18 13:11:47.639440371 +0100
@@ -44,6 +44,7 @@
 #include <acpi/acpi.h>
 #include <acpi/acnamesp.h>
 #include <acpi/acdispat.h>
+#include <acpi/actables.h>
 
 #define _COMPONENT          ACPI_NAMESPACE
 ACPI_MODULE_NAME("nsload")
@@ -76,6 +77,8 @@ acpi_ns_load_table(struct acpi_table_des
 		   struct acpi_namespace_node *node)
 {
 	acpi_status status;
+	struct acpi_table_desc          *table_desc_loaded;
+	int                             count;
 
 	ACPI_FUNCTION_TRACE("ns_load_table");
 
@@ -108,6 +111,31 @@ acpi_ns_load_table(struct acpi_table_des
 	}
 
 	/*
+	 * Check whether the table already exists -> then deny loading it again
+	 * Use OEM id and revision id of the table to identify uniqueness.
+	 */
+	table_desc_loaded = acpi_gbl_table_lists[table_desc->type].next;
+	for (count = 0;
+	     count < acpi_gbl_table_lists[table_desc->type].count
+	       && table_desc_loaded != NULL;
+	     count++){
+		table_desc_loaded = acpi_gbl_table_lists[table_desc->type].next;
+		if (table_desc_loaded->loaded_into_namespace
+		    && table_desc_loaded->pointer->revision ==
+			       table_desc->pointer->revision
+		    && table_desc_loaded->pointer->checksum ==
+			       table_desc->pointer->checksum
+		    && !memcmp(table_desc_loaded->pointer->oem_table_id, 
+			       table_desc->pointer->oem_table_id, 8)
+			){
+			ACPI_REPORT_WARNING (("Table %s has already been loaded (not bad)\n", 
+					      table_desc->pointer->oem_table_id));
+			return (AE_OK);
+		}
+		table_desc_loaded = table_desc_loaded->next;
+	}
+
+	/*
 	 * Parse the table and load the namespace with all named
 	 * objects found within.  Control methods are NOT parsed
 	 * at this time.  In fact, the control methods cannot be
