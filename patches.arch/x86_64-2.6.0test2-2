diff -burpN -X ../KDIFX linux/Documentation/x86_64/boot-options.txt linux-2.6.0test2-amd64/Documentation/x86_64/boot-options.txt
--- linux/Documentation/x86_64/boot-options.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test2-amd64/Documentation/x86_64/boot-options.txt	2003-07-11 13:34:20.000000000 +0200
@@ -0,0 +1,152 @@
+AMD64 specific boot options
+
+There are many others (usually documented in driver documentation), but 
+only the AMD64 specific ones are listed here.
+
+Machine check
+
+(see the Opteron BIOS&Kernel manual for more details on the banks etc.)
+
+   mce=off disable machine check
+   mce=nok8 disable k8 specific features
+   mce=disable<NUMBER> disable bank NUMBER
+   mce=enable<NUMBER> enable bank number
+   mce=device	Enable more machine check options in Northbridge. 
+		Can be useful for device driver debugging.
+   mce=NUMBER mcheck timer interval number seconds. 
+   Can be also comma separated in a single mce=
+
+   nomce (for compatibility with i386): same as mce=off
+
+APICs
+
+   nolocalapic   Don't use a local or IO-APIC. This should only
+   		 be needed if you have a buggy BIOS. The newer
+		 kernels already turn it off by default if the
+		 BIOS didn't enable the local APIC, so it will
+		 be hopefully not needed.
+		 Note this code path is not very well tested, you are on
+		 your own.
+		
+   apic		 Use IO-APIC. Default
+
+   noapic	 Don't use the IO-APIC. 
+		 Also only lightly tested. 
+
+   pirq=...	 See Documentation/i386/IO-APIC.txt		 
+    
+Early Console
+
+   syntax: earlyprintk=vga
+           earlyprintk=serial[,ttySn[,baudrate]] 
+
+   The early console is useful when the kernel crashes before the
+   normal console is initialized. It is not enabled by 
+   default because it has some cosmetic problems.	   
+   Append ,keep to not disable it when the real console takes over.
+   Only vga or serial at a time, not both.
+   Currently only ttyS0 and ttyS1 are supported. 
+   Interaction with the standard serial driver is not very good. 
+   The VGA output is eventually overwritten by the real console.		 
+
+Timing
+
+  notsc
+  Don't use the CPU time stamp counter to read the wall time. 
+  This can be used to work around timing problems on multiprocessor systems 
+  with not properly synchronized CPUs. Only useful with a SMP kernel
+
+  report_lost_ticks
+  Report when timer interrupts are lost because some code turned off
+  interrupts for too long. 
+
+  nmi_watchdog=NUMBER
+  NUMBER can be: 
+  0 don't use an NMI watchdog
+  1 use the IO-APIC timer for the NMI watchdog
+  2 use the local APIC for the NMI watchdog using a performance counter. Note
+  This will use one performance counter and the local APIC's performance
+  vector.
+
+Idle loop
+
+  idle=poll
+  Don't do power saving in the idle loop using HLT, but poll for rescheduling 
+  event. This will make the CPUs eat a lot more power, but may be useful 
+  to get slightly better performance in multiprocessor benchmarks. It also
+  makes some profiling using performance counters more accurate.
+
+Rebooting
+
+   reboot=b[ios] | t[riple] | k[bd] [, [w]arm | [c]old]
+   bios	  Use the CPU reboto vector for warm reset
+   warm   Don't set the cold reboot flag
+   cold   Set the cold reboto flag
+   triple Force a triple fault (init)
+   kbd    Use the keyboard controller. cold reset (default)
+
+   Using warm reset will be much faster especially on big memory
+   systems because the BIOS will not go through the memory check.
+   Disadvantage is that not all hardware will be completely reinitialized
+   on reboot so there may be boot problems on some systems.
+   
+Non Executable Mappings
+
+  noexec=on|off
+
+  on      Enable
+  off     Disable
+  noforce (default) Don't enable by default for heap/stack/data,
+          but allow PROT_EXEC to be effective
+
+  noexec32=opt{,opt} 
+
+  Control the no exec default for 32bit processes. 
+  Requires noexec=on or noexec=noforce to be effective.
+
+  Valid options: 
+     all,on    Heap,stack,data is non executable. 	
+     off       (default) Heap,stack,data is executable
+     stack     Stack is non executable, heap/data is.
+     force     Don't imply PROT_EXEC for PROT_READ 
+     compat    (default) Imply PROT_EXEC for PROT_READ
+ 
+SMP 
+
+  nosmp	Only use a single CPU
+
+  maxcpus=NUMBER only use upto NUMBER CPUs
+
+  cpumask=MASK   only use cpus with bits set in mask
+
+NUMA
+
+  numa=off	Only set up a single NUMA node spanning all memory.
+
+
+ACPI 
+
+  acpi=off	Don't enable ACPI
+  
+PCI
+
+  pci=off	Don't use PCI
+  pci=conf1	Use conf1 access.
+  pci=conf2	Use conf2 access.
+  pci=rom	Assign ROMs.
+  pci=assign-busses    Assign busses
+  pci=irqmask=MASK	       Set PCI interrupt mask to MASK
+  pci=lastbus=NUMBER	       Scan upto NUMBER busses, no matter what the mptable says.
+
+IOMMU
+
+  iommu=[size][,noagp][,off][,force][,noforce][,leak][,memaper[=order]]
+   size  set size of iommu (in bytes) 
+   noagp don't initialize the AGP driver and use full aperture.
+   off   don't use the IOMMU
+   leak  turn on simple iommu leak tracing (only when CONFIG_IOMMU_LEAK is on)
+   memaper[=order] allocate an own aperture over RAM with size 32MB^order.
+   noforce don't force IOMMU usage. Default.
+   force  Force IOMMU
+
+
diff -burpN -X ../KDIFX linux/arch/x86_64/defconfig linux-2.6.0test2-amd64/arch/x86_64/defconfig
--- linux/arch/x86_64/defconfig	2003-07-18 02:39:52.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/defconfig	2003-07-29 01:07:28.000000000 +0200
@@ -24,8 +24,11 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=16
 # CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
 
 #
 # Loadable module support
@@ -135,6 +138,7 @@ CONFIG_BLK_DEV_FD=y
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
 CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_SIZE=4096
@@ -163,6 +167,7 @@ CONFIG_BLK_DEV_IDECD=y
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
 # CONFIG_BLK_DEV_IDESCSI is not set
 # CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
 
 #
 # IDE chipset support/bugfixes
@@ -379,7 +384,6 @@ CONFIG_NET_PCI=y
 CONFIG_AMD8111_ETH=y
 # CONFIG_ADAPTEC_STARFIRE is not set
 # CONFIG_B44 is not set
-# CONFIG_TC35815 is not set
 # CONFIG_DGRS is not set
 # CONFIG_EEPRO100 is not set
 # CONFIG_E100 is not set
@@ -727,6 +731,9 @@ CONFIG_SOUND_ICH=y
 # CONFIG_SOUND_MSNDPIN is not set
 # CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_ALI5455 is not set
+# CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_AD1980 is not set
 
 #
 # USB support
@@ -753,7 +760,6 @@ CONFIG_DEBUG_KERNEL=y
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_DEBUG_SPINLOCK is not set
 # CONFIG_INIT_DEBUG is not set
-CONFIG_KALLSYMS=y
 # CONFIG_FRAME_POINTER is not set
 CONFIG_IOMMU_DEBUG=y
 CONFIG_IOMMU_LEAK=y
diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/ia32_binfmt.c linux-2.6.0test2-amd64/arch/x86_64/ia32/ia32_binfmt.c
--- linux/arch/x86_64/ia32/ia32_binfmt.c	2003-07-18 02:40:03.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/ia32/ia32_binfmt.c	2003-07-29 01:53:21.000000000 +0200
@@ -32,12 +32,14 @@
 #define AT_SYSINFO 32
 #define AT_SYSINFO_EHDR		33
 
-#if 0 /* disabled for now because the code has still problems */
+int sysctl_vsyscall32;
+
 #define ARCH_DLINFO do {  \
+	if (sysctl_vsyscall32) { \
 	NEW_AUX_ENT(AT_SYSINFO, (u32)(u64)VSYSCALL32_VSYSCALL); \
 	NEW_AUX_ENT(AT_SYSINFO_EHDR, VSYSCALL32_BASE);    \
+	}	\
 } while(0)
-#endif
 
 struct file;
 struct elf_phdr; 
@@ -202,7 +204,7 @@ static inline int elf_core_copy_task_reg
 }
 
 static inline int 
-elf_core_copy_task_fpregs(struct task_struct *tsk, elf_fpregset_t *fpu)
+elf_core_copy_task_fpregs(struct task_struct *tsk, struct pt_regs *regs, elf_fpregset_t *fpu)
 {
 	struct _fpstate_ia32 *fpstate = (void*)fpu; 
 	struct pt_regs *regs = (struct pt_regs *)(tsk->thread.rsp0); 
diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/ia32_ioctl.c linux-2.6.0test2-amd64/arch/x86_64/ia32/ia32_ioctl.c
--- linux/arch/x86_64/ia32/ia32_ioctl.c	2003-07-18 02:39:52.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/ia32/ia32_ioctl.c	2003-07-11 14:14:13.000000000 +0200
@@ -726,6 +726,7 @@ COMPATIBLE_IOCTL(BNEPCONNADD)
 COMPATIBLE_IOCTL(BNEPCONNDEL)
 COMPATIBLE_IOCTL(BNEPGETCONNLIST)
 COMPATIBLE_IOCTL(BNEPGETCONNINFO)
+COMPATIBLE_IOCTL(FIOQSIZE)
 
 /* And these ioctls need translation */
 HANDLE_IOCTL(TIOCGDEV, tiocgdev)
diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/ia32entry.S linux-2.6.0test2-amd64/arch/x86_64/ia32/ia32entry.S
--- linux/arch/x86_64/ia32/ia32entry.S	2003-07-18 02:39:52.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/ia32/ia32entry.S	2003-07-14 00:14:25.000000000 +0200
@@ -462,11 +462,21 @@ ia32_sys_call_table:
 	.quad sys_epoll_wait
 	.quad sys_remap_file_pages
 	.quad sys_set_tid_address
-	
+	.quad sys32_timer_create
+	.quad compat_timer_settime
+	.quad compat_timer_gettime
+	.quad sys_timer_getoverrun
+	.quad sys_timer_delete
+	.quad compat_clock_settime
+	.quad compat_clock_gettime
+	.quad compat_clock_getres
+	.quad compat_clock_nanosleep
+	.quad compat_statfs64   /* statfs64 */
+	.quad compat_fstatfs64  /* fstatfs64 */
+	.quad sys_tgkill
+	.quad compat_sys_utimes
 	/* don't forget to change IA32_NR_syscalls */
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
 		.quad ni_syscall
 	.endr
-
-	
diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/ipc32.c linux-2.6.0test2-amd64/arch/x86_64/ia32/ipc32.c
--- linux/arch/x86_64/ia32/ipc32.c	2003-07-18 02:42:38.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/ia32/ipc32.c	2003-07-11 14:10:21.000000000 +0200
@@ -687,9 +687,7 @@ sys32_ipc (u32 call, int first, int seco
 		return sys_shmget(first, second, third);
 	      case SHMCTL:
 		return shmctl32(first, second, (void *)AA(ptr));
-	      default:
-		return -EINVAL;
 	}
-	return -EINVAL;
+	return -ENOSYS;
 }
 
diff -burpN -X ../KDIFX linux/arch/x86_64/ia32/sys_ia32.c linux-2.6.0test2-amd64/arch/x86_64/ia32/sys_ia32.c
--- linux/arch/x86_64/ia32/sys_ia32.c	2003-07-18 02:39:52.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/ia32/sys_ia32.c	2003-07-14 13:19:39.000000000 +0200
@@ -1993,6 +1993,41 @@ asmlinkage long sys32_open(const char * 
 	return fd;
 }
 
+struct sigevent32 { 
+	u32 sigev_value;
+	u32 sigev_signo; 
+	u32 sigev_notify; 
+	u32 payload[(64 / 4) - 3]; 
+}; 
+
+extern asmlinkage long
+sys_timer_create(clockid_t which_clock,
+		 struct sigevent __user *timer_event_spec,
+		 timer_t __user * created_timer_id);
+
+long
+sys32_timer_create(u32 clock, struct sigevent32 *se32, timer_t *timer_id)
+{
+	struct sigevent se;
+	if (se32) { 
+		memset(&se, 0, sizeof(struct sigevent)); 
+		if (get_user(se.sigev_value.sival_int,  &se32->sigev_value) ||
+		    __get_user(se.sigev_signo, &se32->sigev_signo) ||
+		    __get_user(se.sigev_notify, &se32->sigev_notify) ||
+		    __copy_from_user(&se._sigev_un._pad, &se32->payload, 
+				     sizeof(se32->payload)))
+			return -EFAULT;
+	} 
+	if (!access_ok(VERIFY_WRITE,timer_id,sizeof(timer_t)))
+		return -EFAULT;
+
+	mm_segment_t oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	long err = sys_timer_create(clock, se32 ? &se : NULL, timer_id);
+	set_fs(oldfs); 
+	
+	return err; 
+} 
 
 long sys32_vm86_warning(void)
 { 
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/Makefile linux-2.6.0test2-amd64/arch/x86_64/kernel/Makefile
--- linux/arch/x86_64/kernel/Makefile	2003-07-18 02:39:30.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/Makefile	2003-07-29 01:42:02.000000000 +0200
@@ -6,7 +6,7 @@ extra-y 	:= head.o head64.o init_task.o
 EXTRA_AFLAGS	:= -traditional
 obj-y	:= process.o semaphore.o signal.o entry.o traps.o irq.o \
 		ptrace.o i8259.o ioport.o ldt.o setup.o time.o sys_x86_64.o \
-		pci-dma.o x8664_ksyms.o i387.o syscall.o vsyscall.o \
+		x8664_ksyms.o i387.o syscall.o vsyscall.o \
 		setup64.o bluesmoke.o bootflag.o e820.o reboot.o warmreboot.o
 
 obj-$(CONFIG_MTRR)	+= mtrr/
@@ -19,7 +19,8 @@ obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o m
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= suspend.o suspend_asm.o
 obj-$(CONFIG_EARLY_PRINTK)    += early_printk.o
 obj-$(CONFIG_GART_IOMMU) += pci-gart.o aperture.o
-obj-$(CONFIG_DUMMY_IOMMU) += pci-nommu.o
+obj-$(CONFIG_DUMMY_IOMMU) += pci-nommu.o pci-dma.o
+
 obj-$(CONFIG_MODULES) += module.o
 
 $(obj)/bootflag.c: 
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/aperture.c linux-2.6.0test2-amd64/arch/x86_64/kernel/aperture.c
--- linux/arch/x86_64/kernel/aperture.c	2003-07-18 02:39:30.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/aperture.c	2003-07-11 19:20:32.000000000 +0200
@@ -1,14 +1,14 @@
 /* 
  * Firmware replacement code.
  * 
- * Work around broken BIOSes that don't set an aperture. 
- * The IOMMU code needs an aperture even who no AGP is present in the system.
- * Map the aperture over some low memory.  This is cheaper than doing bounce 
- * buffering. The memory is lost. This is done at early boot because only
- * the bootmem allocator can allocate 32+MB. 
+ * Work around broken BIOSes that don't set an aperture or only set the
+ * aperture in the AGP bridge. 
+ * If all fails map the aperture over some low memory.  This is cheaper than 
+ * doing bounce buffering. The memory is lost. This is done at early boot 
+ * because only the bootmem allocator can allocate 32+MB. 
  * 
  * Copyright 2002 Andi Kleen, SuSE Labs.
- * $Id: aperture.c,v 1.2 2002/09/19 19:25:32 ak Exp $
+ * $Id: aperture.c,v 1.5 2003/07/11 12:30:09 ak Exp $
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -17,6 +17,8 @@
 #include <linux/bootmem.h>
 #include <linux/mmzone.h>
 #include <linux/pci_ids.h>
+#include <linux/pci.h>
+#include <linux/bitops.h>
 #include <asm/e820.h>
 #include <asm/io.h>
 #include <asm/proto.h>
@@ -45,10 +47,9 @@ static u32 __init allocate_aperture(void
 	aper_size = (32 * 1024 * 1024) << fallback_aper_order; 
 
 	/* 
-         * Aperture has to be naturally aligned it seems. This means an
-	 * 2GB aperture won't have much changes to succeed in the lower 4GB of 
-	 * memory. Unfortunately we cannot move it up because that would make
-	 * the IOMMU useless.
+         * Aperture has to be naturally aligned. This means an 2GB aperture won't 
+         * have much chances to find a place in the lower 4GB of memory. Unfortunately 
+         * we cannot move it up because that would make the IOMMU useless.
 	 */
 	p = __alloc_bootmem_node(nd0, aper_size, aper_size, 0); 
 	if (!p || __pa(p)+aper_size > 0xffffffff) {
@@ -63,17 +64,123 @@ static u32 __init allocate_aperture(void
 	return (u32)__pa(p); 
 }
 
+static int __init aperture_valid(u64 aper_base, u32 aper_size) 
+{ 
+	if (!aper_base)
+		return 0; 
+	if (aper_size < 64*1024*1024) { 
+		printk("Aperture too small (%d MB)\n", aper_size>>20); 
+		return 0;
+	}
+	if (aper_base + aper_size >= 0xffffffff) { 
+		printk("Aperture beyond 4GB. Ignoring.\n");
+		return 0; 
+	}
+	if (e820_mapped(aper_base, aper_base + aper_size, E820_RAM)) {  
+		printk("Aperture pointing to e820 RAM. Ignoring.\n");
+		return 0; 
+	} 
+	return 1;
+} 
+
+/* Find a PCI capability */ 
+static __u32 __init find_cap(int num, int slot, int func, int cap) 
+{ 
+	if (!(read_pci_config_16(num,slot,func,PCI_STATUS) & PCI_STATUS_CAP_LIST))
+		return 0;
+	u8 pos = read_pci_config_byte(num,slot,func,PCI_CAPABILITY_LIST);
+	int bytes;
+	for (bytes = 0; bytes < 48 && pos >= 0x40; bytes++) { 
+		pos &= ~3; 
+		u8 id = read_pci_config_byte(num,slot,func,pos+PCI_CAP_LIST_ID); 
+		if (id == 0xff)
+			break;
+		if (id == cap) 
+			return pos; 
+		pos = read_pci_config_byte(num,slot,func,pos+PCI_CAP_LIST_NEXT); 
+	} 
+	return 0;
+} 
+
+/* Read a standard AGPv3 bridge header */
+static __u32 __init read_agp(int num, int slot, int func, int cap, u32 *order)
+{ 
+	printk("AGP bridge at %02x:%02x:%02x\n", num, slot, func); 
+
+	u32 apsize = read_pci_config_16(num,slot,func, cap + 0x14);
+	if (apsize == 0xffffffff) {
+		printk("APSIZE in AGP bridge unreadable\n");
+		return 0;
+	}
+
+	apsize &= 0xfff;
+	int nbits = hweight16(apsize);
+	*order = 7 - nbits;
+	
+	u32 aper_low = read_pci_config(num,slot,func, 0x10); 
+	u32 aper_hi = read_pci_config(num,slot,func,0x14); 
+	u64 aper = (aper_low & ~((1<<22)-1)) | ((u64)aper_hi << 32); 
+
+	printk("Aperture from AGP @ %Lx size %u MB\n", aper, 32 << *order);
+
+	if (!aperture_valid(aper, (32*1024*1024) << *order))
+	    return 0;
+	return (u32)aper; 
+} 
+
+/* Look for an AGP bridge. Windows only expects the aperture in the
+   AGP bridge and some BIOS forget to initialize the Northbridge too.
+   Work around this here. 
+
+   Do an PCI bus scan by hand because we're running before the PCI
+   subsystem. 
+
+   All K8 AGP bridges are AGPv3 compliant, so we can do this scan
+   generically. It's probably overkill to always scan all slots because
+   the AGP bridges should be always an own bus on the HT hierarchy, 
+   but do it here for future safety. */
+static __u32 __init search_agp_bridge(u32 *order)
+{
+	int num, slot, func;
+
+	/* Poor man's PCI discovery */
+	for (num = 0; num < 32; num++) { 
+		for (slot = 0; slot < 32; slot++) { 
+			for (func = 0; func < 8; func++) { 
+				u32 class, cap;
+				class = read_pci_config(num,slot,func,
+							PCI_CLASS_REVISION);
+				if (class == 0xffffffff)
+					break; 
+				
+				switch (class >> 16) { 
+				case PCI_CLASS_BRIDGE_HOST:
+				case PCI_CLASS_BRIDGE_OTHER: /* needed? */
+					/* AGP bridge? */
+					cap = find_cap(num,slot,func,PCI_CAP_ID_AGP);
+					if (!cap)
+						break;
+					return read_agp(num,slot,func,cap,order);
+				} 
+				
+				/* No multi-function device? */
+				u8 type = read_pci_config_byte(num,slot,func,
+							       PCI_HEADER_TYPE);
+				if (!(type & 0x80))
+					break;
+			} 
+		} 
+	}
+	printk("No AGP bridge found\n"); 
+	return 0;
+}
+
 void __init iommu_hole_init(void) 
 { 
 	int fix, num; 
-	u32 aper_size, aper_alloc, aper_order;
+	u32 aper_size, aper_alloc = 0, aper_order;
 	u64 aper_base; 
 
-	if (no_iommu)
-		return;
-	if (end_pfn < (0xffffffff>>PAGE_SHIFT) && !force_mmu) 
-		return;
-
 	printk("Checking aperture...\n"); 
 
 	fix = 0;
@@ -86,15 +193,10 @@ void __init iommu_hole_init(void) 
 		aper_base = read_pci_config(0, num, 3, 0x94) & 0x7fff;
 		aper_base <<= 25; 
 
-		printk("CPU %d: aperture @ %Lx size %u KB\n", num-24, 
-		       aper_base, aper_size>>10);
-		if (!aper_base || aper_base + aper_size >= 0xffffffff) {
-			fix = 1; 
-			break; 
-		} 
+		printk("CPU %d: aperture @ %Lx size %u MB\n", num-24, 
+		       aper_base, aper_size>>20);
 		
-		if (e820_mapped(aper_base, aper_base + aper_size, E820_RAM)) {  
-			printk("Aperture pointing to e820 RAM. Ignoring.\n");
+		if (!aperture_valid(aper_base, aper_size)) { 
 			fix = 1; 
 			break; 
 		} 
@@ -103,12 +205,27 @@ void __init iommu_hole_init(void) 
 	if (!fix && !fallback_aper_force) 
 		return; 
 
+	if (!fallback_aper_force)
+		aper_alloc = search_agp_bridge(&aper_order); 
+		
+	if (aper_alloc) { 
+		/* All ok - got the aperture from the AGP bridge */
+	} else if ((no_iommu || 
+		      (end_pfn < 0xffffffff>>PAGE_SHIFT && !force_iommu))
+		  	   && !fallback_aper_force) { 
+		return; 
+	} else {
 	printk("Your BIOS doesn't leave a aperture memory hole\n");
 	printk("Please enable the IOMMU option in the BIOS setup\n"); 
+		printk("This costs you %d MB of RAM\n", 32 << fallback_aper_order); 
+ 
+		aper_order = fallback_aper_order;
 	aper_alloc = allocate_aperture(); 
 	if (!aper_alloc) 
 		return; 
+	}
 
+	/* Fix up the north bridges */
 	for (num = 24; num < 32; num++) { 		
 		if (read_pci_config(0, num, 3, 0x00) != NB_ID_3) 
 			continue;	
@@ -116,7 +233,7 @@ void __init iommu_hole_init(void) 
 		/* Don't enable translation yet. That is done later. 
 		   Assume this BIOS didn't initialise the GART so 
 		   just overwrite all previous bits */ 
-		write_pci_config(0, num, 3, 0x90, fallback_aper_order<<1); 
+		write_pci_config(0, num, 3, 0x90, aper_order<<1); 
 		write_pci_config(0, num, 3, 0x94, aper_alloc>>25); 
 	} 
 } 
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/apic.c linux-2.6.0test2-amd64/arch/x86_64/kernel/apic.c
--- linux/arch/x86_64/kernel/apic.c	2003-07-18 02:39:30.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/apic.c	2003-07-11 13:34:21.000000000 +0200
@@ -441,9 +441,6 @@ void __init setup_local_APIC (void)
 
 #ifdef CONFIG_PM
 
-#include <linux/device.h>
-#include <linux/module.h>
-
 static struct {
 	/* 'active' is true if the local APIC was enabled by us and
 	   not the BIOS; this signifies that we are also responsible
@@ -540,7 +537,6 @@ static struct sysdev_class lapic_sysclas
 	.suspend	= lapic_suspend,
 };
 
-/* not static, needed by child devices */
 static struct sys_device device_lapic = {
 	.id		= 0,
 	.cls		= &lapic_sysclass,
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/bluesmoke.c linux-2.6.0test2-amd64/arch/x86_64/kernel/bluesmoke.c
--- linux/arch/x86_64/kernel/bluesmoke.c	2003-07-18 02:39:30.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/bluesmoke.c	2003-07-11 13:34:21.000000000 +0200
@@ -127,9 +127,8 @@ static struct pci_dev *find_k8_nb(void)
 { 
 	struct pci_dev *dev = NULL;
 	int cpu = smp_processor_id(); 
-	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-		if (dev->bus->number==0 && PCI_FUNC(dev->devfn)==3 &&
-		    PCI_SLOT(dev->devfn) == (24U+cpu))
+	while ((dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, dev)) != NULL) {
+		if (dev->bus->number==0 && PCI_SLOT(dev->devfn) == (24U+cpu))
 			return dev;
 	}
 	return NULL;
@@ -198,7 +197,7 @@ static char *highbits[32] = { 
 	[0] = "err cpu1",
 };
 
-static void check_k8_nb(void)
+static void check_k8_nb(int header)
 {
 	struct pci_dev *nb;
 	nb = find_k8_nb(); 
@@ -210,6 +209,9 @@ static void check_k8_nb(void)
 	pci_read_config_dword(nb, 0x4c, &statushigh);
 	if (!(statushigh & (1<<31)))
 		return;
+	if (header)
+		printk(KERN_ERR "CPU %d: Silent Northbridge MCE\n", smp_processor_id());
+
 	printk(KERN_ERR "Northbridge status %08x%08x\n",
 	       statushigh,statuslow); 
 
@@ -271,9 +273,12 @@ static void k8_machine_check(struct pt_r
 	rdmsrl(MSR_IA32_MCG_STATUS, status); 
 	if ((status & (1<<2)) == 0) { 
 		if (!regs) 
-			check_k8_nb();
+			check_k8_nb(1);
 		return; 
 		}
+
+	printk(KERN_EMERG "CPU %d: Machine Check Exception: %016Lx\n", smp_processor_id(), status);
+
 	if (status & 1)
 		printk(KERN_EMERG "MCG_STATUS: unrecoverable\n"); 
 
@@ -291,7 +296,7 @@ static void k8_machine_check(struct pt_r
 	if (nbstatus & (1UL<57))
 		printk(KERN_EMERG "Unrecoverable condition\n"); 
 		
-	check_k8_nb();
+	check_k8_nb(0);
 
 	if (nbstatus & (1UL<<58)) { 
 		u64 adr;
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/head.S linux-2.6.0test2-amd64/arch/x86_64/kernel/head.S
--- linux/arch/x86_64/kernel/head.S	2003-05-27 03:00:42.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/head.S	2003-07-11 14:24:57.000000000 +0200
@@ -307,7 +307,8 @@ ENTRY(empty_bad_pmd_table)
 ENTRY(level3_physmem_pgt)
 	.quad	0x0000000000105007		/* -> level2_kernel_pgt (so that __va works even before pagetable_init) */
 
-.org 0xb000
+	.org 0xb000
+#ifdef CONFIG_ACPI_SLEEP
 ENTRY(wakeup_level4_pgt)
 	.quad	0x0000000000102007		/* -> level3_ident_pgt */
 	.fill	255,8,0
@@ -315,9 +316,9 @@ ENTRY(wakeup_level4_pgt)
 	.fill	254,8,0
 	/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */
 	.quad	0x0000000000103007		/* -> level3_kernel_pgt */
+#endif
 
-.org 0xc000
-.data
+	.data
 
 	.align 16
 	.globl cpu_gdt_descr
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/io_apic.c linux-2.6.0test2-amd64/arch/x86_64/kernel/io_apic.c
--- linux/arch/x86_64/kernel/io_apic.c	2003-07-18 02:39:52.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/io_apic.c	2003-07-28 20:01:58.000000000 +0200
@@ -63,7 +63,7 @@ int nr_ioapic_registers[MAX_IO_APICS];
  */
 
 static struct irq_pin_list {
-	int apic, pin, next;
+	short apic, pin, next;
 } irq_2_pin[PIN_MAP_SIZE];
 
 /*
@@ -1781,3 +1781,21 @@ int io_apic_set_pci_routing (int ioapic,
 }
 
 #endif /*CONFIG_ACPI_BOOT*/
+
+#ifndef CONFIG_SMP
+void send_IPI_self(int vector)
+{
+	unsigned int cfg;
+	
+       /*
+        * Wait for idle.
+        */
+	apic_wait_icr_idle();
+	cfg = APIC_DM_FIXED | APIC_DEST_SELF | vector | APIC_DEST_LOGICAL;
+
+	/*
+	 * Send the IPI. The write to APIC_ICR fires this off.
+	 */
+	apic_write_around(APIC_ICR, cfg);
+}
+#endif
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/ioport.c linux-2.6.0test2-amd64/arch/x86_64/kernel/ioport.c
--- linux/arch/x86_64/kernel/ioport.c	2003-05-27 03:00:26.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/ioport.c	2003-07-29 01:28:09.000000000 +0200
@@ -51,42 +51,50 @@ static void set_bitmap(unsigned long *bi
 	}
 }
 
+
 /*
  * this changes the io permissions bitmap in the current task.
  */
 asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int turn_on)
 {
 	struct thread_struct * t = &current->thread;
-	struct tss_struct * tss;
-	int ret = 0;
+	int cpu = get_cpu(); 
 
 	if ((from + num <= from) || (from + num > IO_BITMAP_SIZE*32))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
+	struct tss_struct * tss = init_tss + cpu; 
+
+	/*
+	 * If it's the first ioperm() call in this thread's lifetime, set the
+	 * IO bitmap up. ioperm() is much less timing critical than clone(),
+	 * this is why we delay this operation until now:
+	 */
 	if (!t->io_bitmap_ptr) { 
-		t->io_bitmap_ptr = kmalloc((IO_BITMAP_SIZE+1)*4, GFP_KERNEL);
+		t->io_bitmap_ptr = kmalloc(IO_BITMAP_BYTES, GFP_KERNEL);
 		if (!t->io_bitmap_ptr) { 
-			ret = -ENOMEM;
-			goto out;
-		}
-		memset(t->io_bitmap_ptr,0xff,(IO_BITMAP_SIZE+1)*4);
-		tss  = init_tss + get_cpu();
-		tss->io_map_base = IO_BITMAP_OFFSET;
 		put_cpu(); 
+			return -ENOMEM; 
+		}
+
+		memset(t->io_bitmap_ptr,0xff,IO_BITMAP_BYTES);
 	}
-	tss = init_tss + get_cpu();
 
 	/*
 	 * do it in the per-thread copy and in the TSS ...
 	 */
 	set_bitmap((unsigned long *) t->io_bitmap_ptr, from, num, !turn_on);
+	if (tss->io_map_base != IO_BITMAP_OFFSET) { 
+		memcpy(tss->io_bitmap, t->io_bitmap_ptr, sizeof(tss->io_bitmap));
+		tss->io_map_base = IO_BITMAP_OFFSET;
+	} else { 
 	set_bitmap((unsigned long *) tss->io_bitmap, from, num, !turn_on);
+	}
 
- out:
 	put_cpu();
-	return ret;
+	return 0;
 }
 
 /*
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/mpparse.c linux-2.6.0test2-amd64/arch/x86_64/kernel/mpparse.c
--- linux/arch/x86_64/kernel/mpparse.c	2003-05-27 03:00:28.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/mpparse.c	2003-07-18 02:07:00.000000000 +0200
@@ -41,8 +41,10 @@ int acpi_found_madt;
  * MP-table.
  */
 int apic_version [MAX_APICS];
-int mp_bus_id_to_type [MAX_MP_BUSSES] = { [0 ... MAX_MP_BUSSES-1] = -1 };
+unsigned char mp_bus_id_to_type [MAX_MP_BUSSES] = { [0 ... MAX_MP_BUSSES-1] = -1 };
 int mp_bus_id_to_pci_bus [MAX_MP_BUSSES] = { [0 ... MAX_MP_BUSSES-1] = -1 };
+unsigned long mp_bus_to_cpumask [MAX_MP_BUSSES] = { [0 ... MAX_MP_BUSSES-1] = -1UL };
+
 int mp_current_pci_id = 0;
 /* I/O APIC entries */
 struct mpc_config_ioapic mp_ioapics[MAX_IO_APICS];
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/nmi.c linux-2.6.0test2-amd64/arch/x86_64/kernel/nmi.c
--- linux/arch/x86_64/kernel/nmi.c	2003-07-18 02:39:52.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/nmi.c	2003-07-11 13:34:21.000000000 +0200
@@ -141,14 +141,14 @@ void disable_lapic_nmi_watchdog(void)
 	/* tell do_nmi() and others that we're not active any more */
 	nmi_watchdog = 0;
 }
+
 void enable_lapic_nmi_watchdog(void)
-  {
+{
 	if (nmi_active < 0) {
 		nmi_watchdog = NMI_LOCAL_APIC;
 		setup_apic_nmi_watchdog();
 	}
-  }
-
+}
 
 void disable_timer_nmi_watchdog(void)
 {
@@ -173,8 +173,6 @@ void enable_timer_nmi_watchdog(void)
 
 #ifdef CONFIG_PM
 
-#include <linux/device.h>
-
 static int nmi_pm_active; /* nmi_active before suspend */
 
 static int lapic_nmi_suspend(struct sys_device *dev, u32 state)
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/pci-dma.c linux-2.6.0test2-amd64/arch/x86_64/kernel/pci-dma.c
--- linux/arch/x86_64/kernel/pci-dma.c	2003-05-27 03:00:58.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/pci-dma.c	2003-07-13 21:56:27.000000000 +0200
@@ -9,8 +9,6 @@
 #include <linux/module.h>
 #include <asm/io.h>
 
-dma_addr_t bad_dma_address = -1UL; 
-
 /* Map a set of buffers described by scatterlist in streaming
  * mode for DMA.  This is the scatter-gather version of the
  * above pci_map_single interface.  Here the scatter gather list
@@ -34,16 +32,9 @@ int pci_map_sg(struct pci_dev *hwdev, st
 	BUG_ON(direction == PCI_DMA_NONE);
  	for (i = 0; i < nents; i++ ) {
 		struct scatterlist *s = &sg[i];
-
 		BUG_ON(!s->page); 
-
 			s->dma_address = pci_map_page(hwdev, s->page, s->offset, 
 						      s->length, direction); 
-
-		if (unlikely(s->dma_address == bad_dma_address)) {
-	pci_unmap_sg(hwdev, sg, i, direction); 
-	return 0; 
-		}
 	}
 	return nents;
 }
@@ -67,3 +58,4 @@ void pci_unmap_sg(struct pci_dev *dev, s
 }
 
 EXPORT_SYMBOL(pci_unmap_sg);
+
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/pci-gart.c linux-2.6.0test2-amd64/arch/x86_64/kernel/pci-gart.c
--- linux/arch/x86_64/kernel/pci-gart.c	2003-07-18 02:39:52.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/pci-gart.c	2003-07-18 02:35:34.000000000 +0200
@@ -8,20 +8,8 @@
  * See Documentation/DMA-mapping.txt for the interface specification.
  * 
  * Copyright 2002 Andi Kleen, SuSE Labs.
- * $Id: pci-gart.c,v 1.20 2003/03/12 08:23:29 ak Exp $
  */
 
-/* 
- * Notebook:
-
-possible future tuning: 
- fast path for sg streaming mappings - only take the locks once.
- more intelligent flush strategy - flush only the NB of the CPU directly
- connected to the device?
- move boundary between IOMMU and AGP in GART dynamically
-  
-*/ 
-
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/ctype.h>
@@ -32,6 +20,7 @@ possible future tuning: 
 #include <linux/spinlock.h>
 #include <linux/pci.h>
 #include <linux/module.h>
+#include <linux/topology.h>
 #include <asm/io.h>
 #include <asm/mtrr.h>
 #include <asm/bitops.h>
@@ -41,6 +30,8 @@ possible future tuning: 
 #include <asm/kdebug.h>
 #include <asm/proto.h>
 
+dma_addr_t bad_dma_address;
+
 unsigned long iommu_bus_base;	/* GART remapping area (physical) */
 static unsigned long iommu_size; 	/* size of remapping area bytes */
 static unsigned long iommu_pages;	/* .. and in pages */
@@ -50,9 +41,9 @@ u32 *iommu_gatt_base; 		/* Remapping tab
 int no_iommu; 
 static int no_agp; 
 #ifdef CONFIG_IOMMU_DEBUG
-int force_mmu = 1;
+int force_iommu = 1;
 #else
-int force_mmu = 0;
+int force_iommu = 0;
 #endif
 
 /* Allocation bitmap for the remapping area */ 
@@ -65,12 +56,18 @@ static unsigned long *iommu_gart_bitmap;
 	(((x) & 0xfffff000) | (((x) >> 32) << 4) | GPTE_VALID | GPTE_COHERENT)
 #define GPTE_DECODE(x) (((x) & 0xfffff000) | (((u64)(x) & 0xff0) << 28))
 
+#define to_pages(addr,size) \
+	(round_up(((addr) & ~PAGE_MASK) + (size), PAGE_SIZE) >> PAGE_SHIFT)
+
 #define for_all_nb(dev) \
-	dev=NULL; \
-	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) \
-		if (dev->bus->number == 0 && PCI_FUNC(dev->devfn) == 3 && \
+	dev = NULL;	\
+	while ((dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, dev))!=NULL)\
+	     if (dev->bus->number == 0 && 				     \
 		    (PCI_SLOT(dev->devfn) >= 24) && (PCI_SLOT(dev->devfn) <= 31))
 
+static struct pci_dev *northbridges[NR_CPUS + 1];
+static u32 northbridge_flush_word[NR_CPUS + 1];
+
 #define EMERGENCY_PAGES 32 /* = 128KB */ 
 
 #ifdef CONFIG_AGP
@@ -110,32 +107,44 @@ static unsigned long alloc_iommu(int siz
 
 static void free_iommu(unsigned long offset, int size)
 { 
+	if (size == 1) { 
+		clear_bit(offset, iommu_gart_bitmap); 
+		return;
+	}
 	unsigned long flags;
 	spin_lock_irqsave(&iommu_bitmap_lock, flags);
-	clear_bit_string(iommu_gart_bitmap, offset, size);
+	__clear_bit_string(iommu_gart_bitmap, offset, size);
 	spin_unlock_irqrestore(&iommu_bitmap_lock, flags);
 } 
 
-static inline void flush_gart(void) 
+/* 
+ * Only flush the aperture on the CPU the PCI bridge is connected to.
+ */
+static void flush_gart(int bus) 
 { 
-	struct pci_dev *nb; 
-	for_all_nb(nb) { 
-		u32 flag; 
-		pci_read_config_dword(nb, 0x9c, &flag); /* could cache this */ 
-		/* could complain for PTE walk errors here (bit 1 of flag) */ 
-		flag |= 1; 
-		pci_write_config_dword(nb, 0x9c, flag); 
+	int flushed = 0;
+	int i;
+	for (i = 0; northbridges[i]; i++) { 
+		if (bus >= 0 && !(pcibus_to_cpumask(bus) & (1UL << i))) 
+			continue;
+		pci_write_config_dword(northbridges[i], 0x9c, 
+				       northbridge_flush_word[i] | 1); 
+		flushed++;
 	} 
+	if (!flushed) 
+		printk("nothing to flush? %d\n", bus);
 } 
 
+/* 
+ * Allocate memory for a consistent mapping.
+ * All mappings are consistent here, so this is just a wrapper around
+ * pci_map_single.
+ */
 void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
 			   dma_addr_t *dma_handle)
 {
 	void *memory;
 	int gfp = GFP_ATOMIC;
-	int i;
-	int flush = 0;
-	unsigned long iommu_page;
 	unsigned long dma_mask;
 
 	if (hwdev == NULL) {
@@ -149,20 +158,14 @@ void *pci_alloc_consistent(struct pci_de
 	if (dma_mask < 0xffffffff || no_iommu)
 		gfp |= GFP_DMA;
 
-	/* 
-	 * First try to allocate continuous and use directly if already 
-	 * in lowmem. 
-	 */ 
-	size = round_up(size, PAGE_SIZE); 
 	memory = (void *)__get_free_pages(gfp, get_order(size));
 	if (memory == NULL) {
 		return NULL; 
 	} else {
-		int high = 0, mmu;
-		if (((unsigned long)virt_to_bus(memory) + size) > dma_mask)
-			high = 1;
-		mmu = 1;
-		if (force_mmu && !(gfp & GFP_DMA)) 
+		int high, mmu;
+	        high = ((unsigned long)virt_to_bus(memory) + size) >= dma_mask;
+		mmu = high;
+		if (force_iommu && !(gfp & GFP_DMA)) 
 			mmu = 1;
 		if (no_iommu) { 
 			if (high) goto error;
@@ -175,27 +178,13 @@ void *pci_alloc_consistent(struct pci_de
 		}
 	} 
 
-	size >>= PAGE_SHIFT;
-
-	iommu_page = alloc_iommu(size, &flush);
-	if (iommu_page == -1)
+	*dma_handle = pci_map_single(hwdev, memory, size, 0);
+	if (*dma_handle == bad_dma_address)
 		goto error; 
 
-   	/* Fill in the GATT */
-	for (i = 0; i < size; i++) { 
-		unsigned long phys_mem; 
-		void *mem = memory + i*PAGE_SIZE;
-		phys_mem = virt_to_phys(mem); 
-		BUG_ON(phys_mem & ~PHYSICAL_PAGE_MASK); 
-		iommu_gatt_base[iommu_page + i] = GPTE_ENCODE(phys_mem); 
-	} 
-
-	if (flush) 
-	flush_gart();
-	*dma_handle = iommu_bus_base + (iommu_page << PAGE_SHIFT);
 	return memory; 
 	
- error:
+error:
 	free_pages((unsigned long)memory, get_order(size)); 
 	return NULL; 
 }
@@ -207,25 +196,17 @@ void *pci_alloc_consistent(struct pci_de
 void pci_free_consistent(struct pci_dev *hwdev, size_t size,
 			 void *vaddr, dma_addr_t bus)
 {
-	unsigned long iommu_page;
-
-	size = round_up(size, PAGE_SIZE); 
-	if (bus >= iommu_bus_base && bus <= iommu_bus_base + iommu_size) { 
-		unsigned pages = size >> PAGE_SHIFT;
-		int i;
-		iommu_page = (bus - iommu_bus_base) >> PAGE_SHIFT;
-		vaddr = __va(GPTE_DECODE(iommu_gatt_base[iommu_page]));
-		for (i = 0; i < pages; i++) {
-			u64 pte = iommu_gatt_base[iommu_page + i];
-		BUG_ON((pte & GPTE_VALID) == 0); 
-		iommu_gatt_base[iommu_page + i] = 0; 		
-	} 
-		free_iommu(iommu_page, pages);
-	}
+	pci_unmap_single(hwdev, bus, size, 0);
 	free_pages((unsigned long)vaddr, get_order(size)); 		
 }
 
 #ifdef CONFIG_IOMMU_LEAK
+
+#define SET_LEAK(x) if (iommu_leak_tab) \
+			iommu_leak_tab[x] = __builtin_return_address(0);
+#define CLEAR_LEAK(x) if (iommu_leak_tab) \
+			iommu_leak_tab[x] = 0;
+
 /* Debugging aid for drivers that don't free their IOMMU tables */
 static void **iommu_leak_tab; 
 static int leak_trace;
@@ -246,9 +227,12 @@ void dump_leak(void)
 	} 
 	printk("\n");
 }
+#else
+#define SET_LEAK(x)
+#define CLEAR_LEAK(x)
 #endif
 
-static void iommu_full(struct pci_dev *dev, void *addr, size_t size, int dir)
+static void iommu_full(struct pci_dev *dev, size_t size, int dir)
 {
 	/* 
 	 * Ran out of IOMMU space for this operation. This is very bad.
@@ -261,8 +245,8 @@ static void iommu_full(struct pci_dev *d
 	 */ 
 	
 	printk(KERN_ERR 
-  "PCI-DMA: Out of IOMMU space for %p size %lu at device %s[%s]\n",
-	       addr,size, dev ? dev->dev.name : "?", dev ? dev->slot_name : "?");
+  "PCI-DMA: Out of IOMMU space for %lu bytes at device %s[%s]\n",
+	       size, dev ? dev->dev.name : "?", dev ? dev->slot_name : "?");
 
 	if (size > PAGE_SIZE*EMERGENCY_PAGES) {
 		if (dir == PCI_DMA_FROMDEVICE || dir == PCI_DMA_BIDIRECTIONAL)
@@ -279,23 +263,60 @@ static void iommu_full(struct pci_dev *d
 static inline int need_iommu(struct pci_dev *dev, unsigned long addr, size_t size)
 { 
 	u64 mask = dev ? dev->dma_mask : 0xffffffff;
-	int high = (~mask & (unsigned long)(addr + size)) != 0;
+	int high = addr + size >= mask;
 	int mmu = high;
-	if (force_mmu) 
+	if (force_iommu) 
 		mmu = 1; 
 	if (no_iommu) { 
 		if (high) 
-			panic("pci_map_single: high address but no IOMMU.\n"); 
+			panic("PCI-DMA: high address but no IOMMU.\n"); 
 		mmu = 0; 
 	} 	
 	return mmu; 
 }
 
-dma_addr_t pci_map_single(struct pci_dev *dev, void *addr, size_t size, int dir)
+static inline int nonforced_iommu(struct pci_dev *dev, unsigned long addr, size_t size)
+{ 
+	u64 mask = dev ? dev->dma_mask : 0xffffffff;
+	int high = addr + size >= mask;
+	int mmu = high;
+	if (no_iommu) { 
+		if (high) 
+			panic("PCI-DMA: high address but no IOMMU.\n"); 
+		mmu = 0; 
+	} 	
+	return mmu; 
+}
+
+/* Map a single continuous physical area into the IOMMU.
+ * Caller needs to check if the iommu is needed and flush.
+ */
+static dma_addr_t pci_map_area(struct pci_dev *dev, unsigned long phys_mem, 
+				size_t size, int *flush, int dir)
+{ 
+	unsigned long npages = to_pages(phys_mem, size);
+	unsigned long iommu_page = alloc_iommu(npages, flush);
+	if (iommu_page == -1) {
+		if (!nonforced_iommu(dev, phys_mem, size))
+			return phys_mem; 
+		iommu_full(dev, size, dir);
+		return bad_dma_address;
+	}
+
+	int i;
+	for (i = 0; i < npages; i++) {
+		iommu_gatt_base[iommu_page + i] = GPTE_ENCODE(phys_mem);
+		SET_LEAK(iommu_page + i);
+		phys_mem += PAGE_SIZE;
+	}
+	return iommu_bus_base + iommu_page*PAGE_SIZE + (phys_mem & ~PAGE_MASK);
+}
+
+/* Map a single area into the IOMMU */
+dma_addr_t pci_map_single(struct pci_dev *dev, void *addr, size_t size, 
+				  	 	 int dir)
 { 
-	unsigned long iommu_page;
 	unsigned long phys_mem, bus;
-	int i, npages;
 	int flush = 0;
 
 	BUG_ON(dir == PCI_DMA_NONE);
@@ -304,39 +325,154 @@ dma_addr_t pci_map_single(struct pci_dev
 	if (!need_iommu(dev, phys_mem, size))
 		return phys_mem; 
 
-	npages = round_up(size + ((u64)addr & ~PAGE_MASK), PAGE_SIZE) >> PAGE_SHIFT;
+	bus = pci_map_area(dev, phys_mem, size, &flush, dir);
+	if (flush)
+		flush_gart(dev->bus->number); 
+	return bus; 
+} 
 
-	iommu_page = alloc_iommu(npages, &flush); 
-	if (iommu_page == -1) {
-		iommu_full(dev, addr, size, dir); 
-		return iommu_bus_base; 
+/* Fallback for pci_map_sg in case of overflow */ 
+static int pci_map_sg_nonforce(struct pci_dev *dev, struct scatterlist *sg,
+			       int nents, int dir)
+{
+	int i;
+	int flush = 0;
+ 	for (i = 0; i < nents; i++ ) {
+		struct scatterlist *s = &sg[i];
+		unsigned long addr = page_to_phys(s->page) + s->offset; 
+		if (nonforced_iommu(dev, addr, s->length)) { 
+			addr = pci_map_area(dev, addr, s->length, &flush, dir); 
+			if (addr == bad_dma_address) { 
+				if (i > 0) 
+					pci_unmap_sg(dev, sg, i, dir); 
+				nents = 0; 
+				break;
 	} 
+		}
+		s->dma_address = addr;
+	}
+	if (flush) 
+		flush_gart(dev->bus->number);
+	return nents;
+}
 
-	phys_mem &= PAGE_MASK;
-	for (i = 0; i < npages; i++, phys_mem += PAGE_SIZE) {
-		BUG_ON(phys_mem & ~PHYSICAL_PAGE_MASK); 
+/* Map multiple scatterlist entries continuous into the first. */
+static int __pci_map_cont(struct scatterlist *sg, int start, int stopat, 
+		      struct scatterlist *sout,
+		      unsigned long pages, int *flush)
+{
+	unsigned long iommu_start = alloc_iommu(pages, flush);
+	if (iommu_start == -1)
+		return -1;
 		
-		/* 
-		 * Set coherent mapping here to avoid needing to flush
-		 * the caches on mapping.
+	unsigned long iommu_page = iommu_start; 
+	int i;
+	
+	for (i = start; i < stopat; i++) {
+		struct scatterlist *s = &sg[i];
+		unsigned long start_addr = s->dma_address;
+		BUG_ON(i > 0 && s->offset);
+		if (i == start) {
+			*sout = *s; 
+			sout->dma_address = iommu_bus_base;
+			sout->dma_address += iommu_page*PAGE_SIZE + s->offset;
+		} else { 
+			sout->length += s->length; 
+		}
+		unsigned long addr = start_addr;
+		while (addr < start_addr + s->length) { 
+			iommu_gatt_base[iommu_page] = GPTE_ENCODE(addr); 
+			SET_LEAK(iommu_page);
+			addr += PAGE_SIZE;
+			iommu_page++;
+		}
+		BUG_ON(i > 0 && addr % PAGE_SIZE); 
+	} 
+	BUG_ON(iommu_page - iommu_start != pages);	
+	return 0;
+}
+
+static inline int pci_map_cont(struct scatterlist *sg, int start, int stopat, 
+		      struct scatterlist *sout,
+		      unsigned long pages, int *flush, int need)
+{
+	if (!need) { 
+		BUG_ON(stopat - start != 1);
+		if (sout != sg + start)
+			*sout = sg[start]; 
+		return 0;
+	} 
+	return __pci_map_cont(sg, start, stopat, sout, pages, flush);
+}
+		
+/*
+ * DMA map all entries in a scatterlist.
+ * Merge chunks that have page aligned sizes into a continuous mapping. 
 		 */
-		iommu_gatt_base[iommu_page + i] = GPTE_ENCODE(phys_mem);
+int pci_map_sg(struct pci_dev *dev, struct scatterlist *sg,
+	       int nents, int dir)
+{
+	int i;
+	int out;
+	int flush = 0;
+	int start;
+	unsigned long pages = 0;
+	int need = 0;
 
-#ifdef CONFIG_IOMMU_LEAK
-		/* XXX need eventually caller of pci_map_sg */
-		if (iommu_leak_tab) 
-			iommu_leak_tab[iommu_page + i] = __builtin_return_address(0); 
-#endif
+	BUG_ON(dir == PCI_DMA_NONE);
+	if (nents == 0) 
+		return 0;
+	out = 0;
+	start = 0;
+	for (i = 0; i < nents; i++) {
+		struct scatterlist *s = &sg[i];
+		dma_addr_t addr = page_to_phys(s->page) + s->offset;
+		s->dma_address = addr;
+		BUG_ON(s->length == 0); 
+
+		/* Handle the previous not yet processed entries */
+		if (i > 0) {
+			struct scatterlist *ps = &sg[i-1];
+			/* Can only merge when the last chunk ends on a page 
+			   boundary */
+			if (!need || (i > start+1 && ps->offset) ||
+			    (ps->offset + ps->length) % PAGE_SIZE) { 
+				if (pci_map_cont(sg, start, i, sg+out, pages, 
+						 &flush, need) < 0)
+					goto error;
+				out++;
+				pages = 0;
+				start = i;		
+			}
 	}
-	if (flush)
-	flush_gart(); 
 
-	bus = iommu_bus_base + iommu_page*PAGE_SIZE; 
-	return bus + ((unsigned long)addr & ~PAGE_MASK); 	
+		need = need_iommu(dev, addr, s->length); 
+		pages += to_pages(s->offset, s->length);
+	}
+	if (pci_map_cont(sg, start, i, sg+out, pages, &flush, need) < 0)
+		goto error;
+	out++;	
+	if (flush)
+		flush_gart(dev->bus->number);
+	if (out < nents) 
+		sg[out].length = 0; 
+	return out;
+
+error:
+	if (out > 0) 
+		flush_gart(-1);
+	pci_unmap_sg(dev, sg, nents, dir);
+	/* When it was forced try again unforced */
+	if (force_iommu) 
+		return pci_map_sg_nonforce(dev, sg, nents, dir);
+	iommu_full(dev, pages << PAGE_SHIFT, dir);	
+	for (i = 0; i < nents; i++)
+		sg[i].dma_address = bad_dma_address;
+	return 0;
 } 
 
 /*
- * Free a temporary PCI mapping.
+ * Free a PCI mapping.
  */ 
 void pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr,
 		      size_t size, int direction)
@@ -347,20 +483,60 @@ void pci_unmap_single(struct pci_dev *hw
 	    dma_addr > iommu_bus_base + iommu_size)
 		return;
 	iommu_page = (dma_addr - iommu_bus_base)>>PAGE_SHIFT;	
-	npages = round_up(size + (dma_addr & ~PAGE_MASK), PAGE_SIZE) >> PAGE_SHIFT;
+	npages = to_pages(dma_addr, size);
 	int i;
 	for (i = 0; i < npages; i++) { 
 		iommu_gatt_base[iommu_page + i] = 0; 
-#ifdef CONFIG_IOMMU_LEAK
-		if (iommu_leak_tab)
-			iommu_leak_tab[iommu_page + i] = 0; 
-#endif
+		CLEAR_LEAK(iommu_page + i);
 	}
 	free_iommu(iommu_page, npages);
 }
 
+/* 
+ * Wrapper for pci_unmap_single working with scatterlists.
+ */ 
+void pci_unmap_sg(struct pci_dev *dev, struct scatterlist *sg, int nents, 
+		  int dir)
+{
+	int i;
+	for (i = 0; i < nents; i++) { 
+		struct scatterlist *s = &sg[i];
+		if (!s->length) 
+			break;
+		pci_unmap_single(dev, s->dma_address, s->length, dir);
+	}
+}
+
+int pci_dma_supported(struct pci_dev *hwdev, u64 mask)
+{
+	/* Copied from i386. Doesn't make much sense, because it will 
+	   only work for pci_alloc_consistent. 
+	   The caller just has to use GFP_DMA in this case. */
+        if (mask < 0x00ffffff)
+                return 0;
+
+	/* Tell the device to use SAC. This allows it to use cheaper accesses
+	   in some cases.
+	   Problem with this is that if we overflow the IOMMU area
+	   and return DAC as fallback address the device may not handle it correctly.
+	   As a compromise we only do this if the IOMMU area is >= 256MB,
+	   which should make overflow unlikely enough. */
+	if (force_iommu && mask > 0xffffffff && iommu_size >= 256*1024*1024) 
+		return 0; 
+
+	if (no_iommu && (~mask & (end_pfn << PAGE_SHIFT)))
+		return 0;
+
+	return 1;
+} 
+
+EXPORT_SYMBOL(pci_unmap_sg);
+EXPORT_SYMBOL(pci_map_sg);
 EXPORT_SYMBOL(pci_map_single);
 EXPORT_SYMBOL(pci_unmap_single);
+EXPORT_SYMBOL(pci_dma_supported);
+EXPORT_SYMBOL(no_iommu);
+EXPORT_SYMBOL(force_iommu); 
 
 static __init unsigned long check_iommu_size(unsigned long aper, u64 aper_size)
 { 
@@ -452,13 +628,12 @@ static __init int init_k8_gatt(struct ag
 
 		pci_write_config_dword(dev, 0x90, ctl); 
 	}
-	flush_gart(); 
+	flush_gart(-1); 
 	
-	printk("PCI-DMA: aperture base @ %x size %u KB\n", aper_base, aper_size>>10); 
+	printk("PCI-DMA: aperture base @ %x size %u KB\n",aper_base, aper_size>>10); 
 	return 0;
 
  nommu:
-	/* XXX: reject 0xffffffff mask now in pci mapping functions */
 	printk(KERN_ERR "PCI-DMA: More than 4GB of RAM and no IOMMU\n"
 	       KERN_ERR "PCI-DMA: 32bit PCI IO may malfunction."); 
 	return -1; 
@@ -466,11 +641,12 @@ static __init int init_k8_gatt(struct ag
 
 extern int agp_amdk8_init(void);
 
-int __init pci_iommu_init(void)
+static int __init pci_iommu_init(void)
 { 
 	struct agp_kern_info info;
 	unsigned long aper_size;
 	unsigned long iommu_start;
+	struct pci_dev *dev;
 		
 #ifndef CONFIG_AGP_AMD_8151
 	no_agp = 1; 
@@ -482,7 +658,7 @@ int __init pci_iommu_init(void)
 		(agp_copy_info(&info) < 0); 
 #endif	
 
-	if (no_iommu || (!force_mmu && end_pfn < 0xffffffff>>PAGE_SHIFT)) { 
+	if (no_iommu || (!force_iommu && end_pfn < 0xffffffff>>PAGE_SHIFT)) { 
 		printk(KERN_INFO "PCI-DMA: Disabling IOMMU.\n"); 
 		no_iommu = 1;
 		return -1;
@@ -492,7 +668,7 @@ int __init pci_iommu_init(void)
 		int err = -1;
 		printk(KERN_INFO "PCI-DMA: Disabling AGP.\n");
 		no_agp = 1;
-		if (force_mmu || end_pfn >= 0xffffffff>>PAGE_SHIFT)
+		if (force_iommu || end_pfn >= 0xffffffff>>PAGE_SHIFT)
 			err = init_k8_gatt(&info);
 		if (err < 0) { 
 			printk(KERN_INFO "PCI-DMA: Disabling IOMMU.\n"); 
@@ -529,25 +705,38 @@ int __init pci_iommu_init(void)
 	set_bit_string(iommu_gart_bitmap, 0, EMERGENCY_PAGES); 
 
 	agp_memory_reserved = iommu_size;	
-	printk(KERN_INFO"PCI-DMA: Reserving %luMB of IOMMU area in the AGP aperture\n",
+	printk(KERN_INFO
+	       "PCI-DMA: Reserving %luMB of IOMMU area in the AGP aperture\n",
 	       iommu_size>>20); 
 
 	iommu_start = aper_size - iommu_size;	
 	iommu_bus_base = info.aper_base + iommu_start; 
-	iommu_gatt_base = agp_gatt_table + (iommu_start>>PAGE_SHIFT);
 	bad_dma_address = iommu_bus_base;
+	iommu_gatt_base = agp_gatt_table + (iommu_start>>PAGE_SHIFT);
 
 	/* 
-         * Unmap the IOMMU part of the GART. The alias of the page is always mapped
-	 * with cache enabled and there is no full cache coherency across the GART
-	 * remapping. The unmapping avoids automatic prefetches from the CPU 
-	 * allocating cache lines in there. All CPU accesses are done via the 
-	 * direct mapping to the backing memory. The GART address is only used by PCI 
+	 * Unmap the IOMMU part of the GART. The alias of the page is
+	 * always mapped with cache enabled and there is no full cache
+	 * coherency across the GART remapping. The unmapping avoids
+	 * automatic prefetches from the CPU allocating cache lines in
+	 * there. All CPU accesses are done via the direct mapping to
+	 * the backing memory. The GART address is only used by PCI
 	 * devices. 
 	 */
 	clear_kernel_mapping((unsigned long)__va(iommu_bus_base), iommu_size);
 
-	flush_gart();
+	for_all_nb(dev) {
+		u32 flag; 
+		int cpu = PCI_SLOT(dev->devfn) - 24;
+		if (cpu >= NR_CPUS)
+			continue;
+		northbridges[cpu] = dev;
+
+		pci_read_config_dword(dev, 0x9c, &flag); /* cache flush word */
+		northbridge_flush_word[cpu] = flag; 
+	}
+		     
+	flush_gart(-1);
 
 	return 0;
 } 
@@ -561,8 +750,8 @@ fs_initcall(pci_iommu_init);
    off   don't use the IOMMU
    leak  turn on simple iommu leak tracing (only when CONFIG_IOMMU_LEAK is on)
    memaper[=order] allocate an own aperture over RAM with size 32MB^order.  
-   noforce don't force IOMMU usage. Should be fastest.
-   force  Force IOMMU and turn on unmap debugging.
+   noforce don't force IOMMU usage. Default.
+   force  Force IOMMU.
 */
 __init int iommu_setup(char *opt) 
 { 
@@ -575,9 +764,9 @@ __init int iommu_setup(char *opt) 
 	    if (!memcmp(p,"off", 3))
 		    no_iommu = 1;
 	    if (!memcmp(p,"force", 5))
-		    force_mmu = 1;
+		    force_iommu = 1;
 	    if (!memcmp(p,"noforce", 7))
-		    force_mmu = 0;
+		    force_iommu = 0;
 	    if (!memcmp(p, "memaper", 7)) { 
 		    fallback_aper_force = 1; 
 		    p += 7; 
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/pci-nommu.c linux-2.6.0test2-amd64/arch/x86_64/kernel/pci-nommu.c
--- linux/arch/x86_64/kernel/pci-nommu.c	2003-07-18 02:39:30.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/pci-nommu.c	2003-07-11 13:34:21.000000000 +0200
@@ -33,15 +33,30 @@ void pci_free_consistent(struct pci_dev 
 	free_pages((unsigned long)vaddr, get_order(size));
 }
 
+int pci_dma_supported(struct pci_dev *hwdev, u64 mask)
+{
+        /*
+         * we fall back to GFP_DMA when the mask isn't all 1s,
+         * so we can't guarantee allocations that must be
+         * within a tighter range than GFP_DMA..
+	 * XXX: this won't work for pci_map_single. Caller has to
+	 * use GFP_DMA in the first place.
+         */
+        if (mask < 0x00ffffff)
+                return 0;
+
+	return 1;
+} 
 
-static void __init check_ram(void) 
+EXPORT_SYMBOL(pci_dma_supported);
+
+static int __init check_ram(void) 
 { 
 	if (end_pfn >= 0xffffffff>>PAGE_SHIFT) { 
 		printk(KERN_ERR "WARNING more than 4GB of memory but no IOMMU.\n"
 		       KERN_ERR "WARNING 32bit PCI may malfunction.\n"); 
-		/* Could play with highmem_start_page here to trick some subsystems
-		   into bounce buffers. Unfortunately that would require setting
-		   CONFIG_HIGHMEM too. 
-		 */ 
 	} 
+	return 0;
 } 
+__initcall(check_ram);
+
diff -burpN -X ../KDIFX linux/arch/x86_64/kernel/setup64.c linux-2.6.0test2-amd64/arch/x86_64/kernel/setup64.c
--- linux/arch/x86_64/kernel/setup64.c	2003-07-18 02:40:03.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/kernel/setup64.c	2003-07-29 03:01:39.000000000 +0200
@@ -114,32 +114,37 @@ Valid options: 
 
 __setup("noexec32=", nonx32_setup); 
 
-#ifndef  __GENERIC_PER_CPU
-
-unsigned long __per_cpu_offset[NR_CPUS];
-
+/* 
+ * Great future plan: 
+ * Declare PDA itself and support (irqstack,tss,pml4) as per cpu data.
+ * Always point %gs to its beginning
+ */
 void __init setup_per_cpu_areas(void)
 { 
-	unsigned long size, i;
-	unsigned char *ptr;
+	int i;
+	unsigned long size;
 
 	/* Copy section for each CPU (we discard the original) */
 	size = ALIGN(__per_cpu_end - __per_cpu_start, SMP_CACHE_BYTES);
-	if (!size)
-		return;
+#ifdef CONFIG_MODULES
+	if (size < PERCPU_ENOUGH_ROOM)
+		size = PERCPU_ENOUGH_ROOM;
+#endif
+
+	/* We don't support CPU hotplug, so only allocate as much as needed here */
 
-	ptr = alloc_bootmem(size * NR_CPUS);
+	int maxi = max_t(unsigned, numnodes, num_online_cpus()); 
 
-	for (i = 0; i < NR_CPUS; i++, ptr += size) {
-		/* hide this from the compiler to avoid problems */ 
-		unsigned long offset;
-		asm("subq %[b],%0" : "=r" (offset) : "0" (ptr), [b] "r" (&__per_cpu_start));
-		__per_cpu_offset[i] = offset;
-		cpu_pda[i].cpudata_offset = offset;
-		memcpy(ptr, __per_cpu_start, size);
+	for (i = 0; i < maxi; i++) { 
+		/* If possible allocate on the node of the CPU.
+		   In case it doesn't exist round-robin nodes. */
+		unsigned char *ptr = alloc_bootmem_node(NODE_DATA(i % numnodes), size);
+		if (!ptr)
+			panic("Cannot allocate cpu data for CPU %d\n", i);
+		cpu_pda[i].data_offset = ptr - __per_cpu_start;
+		memcpy(ptr, __per_cpu_start, __per_cpu_end - __per_cpu_start);
 	}
 } 
-#endif
 
 void pda_init(int cpu)
 { 
@@ -153,7 +158,7 @@ void pda_init(int cpu)
 	pda->me = pda;
 	pda->cpunumber = cpu; 
 	pda->irqcount = -1;
-	pda->cpudata_offset = 0;
+	pda->data_offset = 0;
 	pda->kernelstack = 
 		(unsigned long)stack_thread_info() - PDA_STACKOFFSET + THREAD_SIZE; 
 	pda->active_mm = &init_mm;
diff -burpN -X ../KDIFX linux/arch/x86_64/mm/extable.c linux-2.6.0test2-amd64/arch/x86_64/mm/extable.c
--- linux/arch/x86_64/mm/extable.c	2003-05-27 03:00:58.000000000 +0200
+++ linux-2.6.0test2-amd64/arch/x86_64/mm/extable.c	2003-07-15 15:49:55.000000000 +0200
@@ -5,6 +5,7 @@
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <linux/init.h>
 #include <asm/uaccess.h>
 
 /* Simple binary search */
@@ -28,3 +29,29 @@ search_extable(const struct exception_ta
         }
         return NULL;
 }
+
+/* When an exception handler is in an non standard section (like __init) 
+   the fixup table can end up unordered. Fix that here. */
+static __init int check_extable(void)
+{ 
+	extern struct exception_table_entry __start___ex_table[];
+	extern struct exception_table_entry  __stop___ex_table[];
+	struct exception_table_entry *e;
+	int change; 
+
+	/* The input is near completely presorted, which makes bubble sort the
+	   best (and simplest) sort algorithm. */
+	do { 
+		change = 0;
+		for (e = __start___ex_table+1; e < __stop___ex_table; e++) {
+			if (e->insn < e[-1].insn) { 
+				struct exception_table_entry tmp = e[-1];
+				e[-1] = e[0];
+				e[0] = tmp;
+				change = 1; 
+			} 
+		} 
+	} while (change != 0); 
+	return 0;
+} 
+core_initcall(check_extable);
diff -burpN -X ../KDIFX linux/drivers/char/agp/Kconfig linux-2.6.0test2-amd64/drivers/char/agp/Kconfig
--- linux/drivers/char/agp/Kconfig	2003-07-18 02:39:06.000000000 +0200
+++ linux-2.6.0test2-amd64/drivers/char/agp/Kconfig	2003-07-14 18:39:56.000000000 +0200
@@ -53,15 +53,19 @@ config AGP_AMD
 	  You should say Y here if you use XFree86 3.3.6 or 4.x and want to
 	  use GLX or DRI.  If unsure, say N.
 
+# RED-PEN this option is misnamed, it's not 8151 specific
 config AGP_AMD_8151
 	tristate "AMD Opteron/Athlon64 on-CPU GART support"
 	depends on AGP && X86
 	default GART_IOMMU
 	help
 	  This option gives you AGP support for the GLX component of
-	  XFree86 4.x using the on-CPU AGP bridge of the AMD Athlon64/Opteron CPUs.
+	  XFree86 4.x using the on-CPU northbridge of the AMD Athlon64/Opteron CPUs.
+	  You still need an external AGP bridge like the AMD 8151, VIA
+          K8T400M, SiS755. It may also support other AGP bridges when loaded
+	  with agp_try_unsupported=1.
 	  You should say Y here if you use XFree86 3.3.6 or 4.x and want to
-	  use GLX or DRI.  If unsure, say N
+	  use GLX or DRI.  If unsure, say Y
 
 config AGP_INTEL
 	tristate "Intel 440LX/BX/GX, I8xx and E7x05 chipset support"
diff -burpN -X ../KDIFX linux/drivers/char/agp/amd-k8-agp.c linux-2.6.0test2-amd64/drivers/char/agp/amd-k8-agp.c
--- linux/drivers/char/agp/amd-k8-agp.c	2003-07-18 02:42:38.000000000 +0200
+++ linux-2.6.0test2-amd64/drivers/char/agp/amd-k8-agp.c	2003-07-14 20:45:20.000000000 +0200
@@ -21,7 +21,11 @@
 #include "agp.h"
 
 /* Will need to be increased if hammer ever goes >8-way. */
+#ifdef CONFIG_SMP
 #define MAX_HAMMER_GARTS   8
+#else
+#define MAX_HAMMER_GARTS   1
+#endif
 
 /* PTE bits. */
 #define GPTE_VALID	1
@@ -39,6 +43,8 @@
 static int nr_garts;
 static struct pci_dev * hammers[MAX_HAMMER_GARTS];
 
+static int __initdata agp_try_unsupported;
+
 static int gart_iterator;
 #define for_each_nb() for(gart_iterator=0;gart_iterator<nr_garts;gart_iterator++)
 
@@ -246,24 +252,94 @@ struct agp_bridge_driver amd_8151_driver
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
+/* Some basic sanity checks for the aperture. */
+static int __init aperture_valid(u64 aper, u32 size)
+{ 
+	u32 pfn, c;
+	if (aper == 0)
+		return 0; 
+	if (size < 32*1024*1024) {
+		printk(KERN_INFO "Aperture too small (%d MB)\n", size>>20);
+		return 0;
+	}
+	if (aper + size > 0xffffffff) { 
+		printk(KERN_INFO "Aperture out of bounds\n"); 
+		return 0;
+	} 
+	pfn = aper >> PAGE_SHIFT;
+	for (c = 0; c < size/PAGE_SIZE; c++) { 
+		if (!pfn_valid(pfn + c))
+			break;
+		if (!PageReserved(pfn_to_page(pfn + c))) { 
+			printk(KERN_INFO "Aperture pointing to RAM\n");
+			return 0;
+		}
+	}
+	return 1;
+} 
 
-#ifdef CONFIG_SMP
-static int cache_nbs (void)
+/* 
+ * W*s centric BIOS sometimes only set up the aperture in the AGP
+ * bridge, not the northbridge. On AMD64 this is handled early 
+ * in aperture.c, but when GART_IOMMU is not enabled or we run
+ * on a 32bit kernel this needs to be redone. 
+ */ 
+static __init int fix_northbridge(struct pci_dev *nb, struct pci_dev *agp, 
+								 u16 cap)
+{
+	u32 aper_low, aper_hi;
+	u64 aper, nb_aper;
+	int order = 0;
+	u32 nb_order, nb_base;
+	u16 apsize;
+
+	pci_read_config_dword(nb, 0x90, &nb_order); 
+	nb_order = (nb_order >> 1) & 7;
+	pci_read_config_dword(nb, 0x94, &nb_base); 
+	nb_aper = nb_base << 25;	
+	if (aperture_valid(nb_aper, (32*1024*1024)<<nb_order))
+		return 0;
+
+	/* Northbridge seems to contain crap. Try the AGP bridge. */
+
+	pci_read_config_word(agp, cap+0x14, &apsize); 
+	if (apsize == 0xffff) 
+		return -1; 
+
+	apsize &= 0xfff;
+	order = 7 - hweight16(apsize); 
+	pci_read_config_dword(agp, 0x10, &aper_low);
+	pci_read_config_dword(agp, 0x14, &aper_hi);
+	aper = (aper_low & ~((1<<22)-1)) | ((u64)aper_hi << 32); 
+	printk(KERN_INFO "Aperture from AGP @ %Lx size %u MB\n", aper, 32 << order);
+	if (order < 0 || !aperture_valid(aper, (32*1024*1024)<<order))
+		return -1; 
+	
+	pci_write_config_dword(nb, 0x90, order << 1); 
+	pci_write_config_dword(nb, 0x94, aper >> 25); 
+
+	return 0;
+} 
+
+static __init int cache_nbs (struct pci_dev *pdev, u32 cap_ptr)
 {
 	struct pci_dev *loop_dev = NULL;
 	int i = 0;
 
 	/* cache pci_devs of northbridges. */
-	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) != NULL) {
+	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) 
+			!= NULL) {
+		if (fix_northbridge(loop_dev, pdev, cap_ptr) < 0) 
+			return -1;  
 		hammers[i++] = loop_dev;
 		nr_garts = i;
-		if (i == MAX_HAMMER_GARTS)
+		if (i == MAX_HAMMER_GARTS) { 
+			printk(KERN_INFO "Too many northbridges for AGP\n");
 			return -1;
 	}
-	return 0;
+	}
+	return i == 0 ? -1 : 0;
 }
-#endif
-
 
 static int __init agp_amdk8_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *ent)
@@ -277,7 +353,7 @@ static int __init agp_amdk8_probe(struct
 	if (!cap_ptr)
 		return -ENODEV;
 
-	printk(KERN_INFO PFX "Detected Opteron/Athlon64 on-CPU GART\n");
+	/* Could check for AGPv3 here */
 
 	bridge = agp_alloc_bridge();
 	if (!bridge)
@@ -311,6 +387,9 @@ static int __init agp_amdk8_probe(struct
 			bridge->major_version = 3;
 			bridge->minor_version = 0;
 		}
+	} else {
+		printk(KERN_INFO PFX "Detected AGP bridge %x\n",
+			pdev->devfn);
 	}
 
 	bridge->driver = &amd_8151_driver;
@@ -320,22 +399,10 @@ static int __init agp_amdk8_probe(struct
 	/* Fill in the mode register */
 	pci_read_config_dword(pdev, bridge->capndx+PCI_AGP_STATUS, &bridge->mode);
 
-#ifdef CONFIG_SMP
-	if (cache_nbs() == -1) {
+	if (cache_nbs(pdev, cap_ptr) == -1) {
 		agp_put_bridge(bridge);
-		return -ENOMEM;
-	}
-#else
-	{
-	struct pci_dev *loop_dev = NULL;
-	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) != NULL) {
-		/* For UP, we only care about the first GART. */
-		hammers[0] = loop_dev;
-		nr_garts = 1;
-		break;
-	}
+		return -ENODEV;
 	}
-#endif
 
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
@@ -389,7 +456,29 @@ static struct pci_driver agp_amdk8_pci_d
 /* Not static due to IOMMU code calling it early. */
 int __init agp_amdk8_init(void)
 {
-	return pci_module_init(&agp_amdk8_pci_driver);
+	int err = pci_module_init(&agp_amdk8_pci_driver);
+	if (err == -ENODEV) { 
+		struct pci_dev *dev;
+		if (!agp_try_unsupported) { 
+			printk(KERN_INFO "No supported AGP bridge found.\n");
+			printk(KERN_INFO "You can try agp_try_unsupported=1\n");
+			return err;
+		}
+
+		/* First check that we have at least one K8 NB */
+		if (!pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, NULL))
+			return -ENODEV;
+
+		/* Look for any AGP bridge */
+		dev = NULL;
+		while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev))) {
+			if (!pci_find_capability(dev, PCI_CAP_ID_AGP))
+				continue;
+			if (agp_amdk8_probe(dev, NULL) == 0)
+				err = 0;
+		}		
+	}
+	return err;
 }
 
 static void __exit agp_amdk8_cleanup(void)
@@ -405,5 +494,5 @@ module_exit(agp_amdk8_cleanup);
 #endif
 
 MODULE_AUTHOR("Dave Jones <davej@codemonkey.org.uk>");
+MODULE_PARM(agp_try_unsupported, "1i");
 MODULE_LICENSE("GPL and additional rights");
-
diff -burpN -X ../KDIFX linux/fs/compat.c linux-2.6.0test2-amd64/fs/compat.c
--- linux/fs/compat.c	2003-07-18 02:39:58.000000000 +0200
+++ linux-2.6.0test2-amd64/fs/compat.c	2003-07-13 23:26:23.000000000 +0200
@@ -53,6 +53,19 @@ asmlinkage long compat_sys_utime(char *f
 	return do_utimes(filename, t ? tv : NULL);
 }
 
+asmlinkage long compat_sys_utimes(char *filename, struct compat_timeval *t)
+{
+	struct timeval tv[2];
+
+	if (t) { 
+		if (get_user(tv[0].tv_sec, &t[0].tv_sec) ||
+		    get_user(tv[0].tv_usec, &t[0].tv_usec) ||
+		    get_user(tv[1].tv_sec, &t[1].tv_sec) ||
+		    get_user(tv[1].tv_usec, &t[1].tv_usec))
+			return -EFAULT; 
+	} 
+	return do_utimes(filename, t ? tv : NULL);
+}
 
 asmlinkage long compat_sys_newstat(char * filename,
 		struct compat_stat *statbuf)
@@ -150,6 +163,64 @@ out:
 	return error;
 }
 
+static int put_compat_statfs64(struct compat_statfs64 *ubuf, struct kstatfs *kbuf)
+{
+	
+	if (sizeof ubuf->f_blocks == 4) {
+		if ((kbuf->f_blocks | kbuf->f_bfree |
+		     kbuf->f_bavail | kbuf->f_files | kbuf->f_ffree) &
+		    0xffffffff00000000ULL)
+			return -EOVERFLOW;
+	}
+	if (verify_area(VERIFY_WRITE, ubuf, sizeof(*ubuf)) ||
+	    __put_user(kbuf->f_type, &ubuf->f_type) ||
+	    __put_user(kbuf->f_bsize, &ubuf->f_bsize) ||
+	    __put_user(kbuf->f_blocks, &ubuf->f_blocks) ||
+	    __put_user(kbuf->f_bfree, &ubuf->f_bfree) ||
+	    __put_user(kbuf->f_bavail, &ubuf->f_bavail) ||
+	    __put_user(kbuf->f_files, &ubuf->f_files) ||
+	    __put_user(kbuf->f_ffree, &ubuf->f_ffree) ||
+	    __put_user(kbuf->f_namelen, &ubuf->f_namelen) ||
+	    __put_user(kbuf->f_fsid.val[0], &ubuf->f_fsid.val[0]) ||
+	    __put_user(kbuf->f_fsid.val[1], &ubuf->f_fsid.val[1]) ||
+	    __put_user(kbuf->f_frsize, &ubuf->f_frsize))
+		return -EFAULT;
+	return 0;
+}
+
+asmlinkage long compat_statfs64(const char *path, struct compat_statfs64 *buf)
+{
+	struct nameidata nd;
+	int error;
+
+	error = user_path_walk(path, &nd);
+	if (!error) {
+		struct kstatfs tmp;
+		error = vfs_statfs(nd.dentry->d_inode->i_sb, &tmp);
+		if (!error && put_compat_statfs64(buf, &tmp))
+			error = -EFAULT;
+		path_release(&nd);
+	}
+	return error;
+}
+
+asmlinkage long compat_fstatfs64(unsigned int fd, struct compat_statfs64 *buf)
+{
+	struct file * file;
+	struct kstatfs tmp;
+	int error;
+
+	error = -EBADF;
+	file = fget(fd);
+	if (!file)
+		goto out;
+	error = vfs_statfs(file->f_dentry->d_inode->i_sb, &tmp);
+	if (!error && put_compat_statfs64(buf, &tmp))
+		error = -EFAULT;
+	fput(file);
+out:
+	return error;
+}
 
 /* ioctl32 stuff, used by sparc64, parisc, s390x, ppc64, x86_64 */
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/apic.h linux-2.6.0test2-amd64/include/asm-x86_64/apic.h
--- linux/include/asm-x86_64/apic.h	2003-07-18 02:40:01.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/apic.h	2003-07-11 13:34:21.000000000 +0200
@@ -84,10 +84,6 @@ extern int APIC_init_uniprocessor (void)
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
 
-#ifdef CONFIG_PM
-extern struct sys_device device_lapic;
-#endif
-
 extern int check_nmi_watchdog (void);
 
 extern unsigned int nmi_watchdog;
diff -burpN -X ../KDIFX linux/include/asm-x86_64/bitops.h linux-2.6.0test2-amd64/include/asm-x86_64/bitops.h
--- linux/include/asm-x86_64/bitops.h	2003-05-27 03:00:38.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/bitops.h	2003-07-11 13:34:21.000000000 +0200
@@ -402,12 +402,12 @@ static inline void set_bit_string(unsign
 	}
 } 
 
-static inline void clear_bit_string(unsigned long *bitmap, unsigned long i, 
+static inline void __clear_bit_string(unsigned long *bitmap, unsigned long i, 
 				    int len) 
 { 
 	unsigned long end = i + len; 
 	while (i < end) {
-		clear_bit(i, bitmap); 
+		__clear_bit(i, bitmap); 
 		i++;
 	}
 } 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/desc.h linux-2.6.0test2-amd64/include/asm-x86_64/desc.h
--- linux/include/asm-x86_64/desc.h	2003-05-27 03:01:03.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/desc.h	2003-07-11 13:34:21.000000000 +0200
@@ -7,6 +7,7 @@
 
 #ifndef __ASSEMBLY__
 
+#include <linux/string.h>
 #include <asm/segment.h>
 #include <asm/mmu.h>
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/hw_irq.h linux-2.6.0test2-amd64/include/asm-x86_64/hw_irq.h
--- linux/include/asm-x86_64/hw_irq.h	2003-05-27 03:00:59.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/hw_irq.h	2003-07-28 20:03:02.000000000 +0200
@@ -164,7 +164,7 @@ static inline void x86_do_profile (struc
 	atomic_inc((atomic_t *)&prof_buffer[rip]);
 }
 
-#ifdef CONFIG_SMP /*more of this file should probably be ifdefed SMP */
+#if defined(CONFIG_X86_IO_APIC) && defined(CONFIG_SMP)
 static inline void hw_resend_irq(struct hw_interrupt_type *h, unsigned int i) {
 	if (IO_APIC_IRQ(i))
 		send_IPI_self(IO_APIC_VECTOR(i));
diff -burpN -X ../KDIFX linux/include/asm-x86_64/ia32_unistd.h linux-2.6.0test2-amd64/include/asm-x86_64/ia32_unistd.h
--- linux/include/asm-x86_64/ia32_unistd.h	2003-05-27 03:00:42.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/ia32_unistd.h	2003-07-13 23:27:13.000000000 +0200
@@ -264,7 +264,20 @@
 #define __NR_ia32_sys_epoll_wait	256
 #define __NR_ia32_remap_file_pages	257
 #define __NR_ia32_set_tid_address	258
+#define __NR_ia32_timer_create		259
+#define __NR_ia32_timer_settime	(__NR_ia32_timer_create+1)
+#define __NR_ia32_timer_gettime	(__NR_ia32_timer_create+2)
+#define __NR_ia32_timer_getoverrun	(__NR_ia32_timer_create+3)
+#define __NR_ia32_timer_delete	(__NR_ia32_timer_create+4)
+#define __NR_ia32_clock_settime	(__NR_ia32_timer_create+5)
+#define __NR_ia32_clock_gettime	(__NR_ia32_timer_create+6)
+#define __NR_ia32_clock_getres	(__NR_ia32_timer_create+7)
+#define __NR_ia32_clock_nanosleep	(__NR_ia32_timer_create+8)
+#define __NR_ia32_statfs64		268
+#define __NR_ia32_fstatfs64		269
+#define __NR_ia32_tgkill		270
+#define __NR_ia32_utimes		271
 
-#define IA32_NR_syscalls 265	/* must be > than biggest syscall! */	
+#define IA32_NR_syscalls 275	/* must be > than biggest syscall! */	
 
 #endif /* _ASM_X86_64_IA32_UNISTD_H_ */
diff -burpN -X ../KDIFX linux/include/asm-x86_64/io.h linux-2.6.0test2-amd64/include/asm-x86_64/io.h
--- linux/include/asm-x86_64/io.h	2003-07-18 02:39:31.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/io.h	2003-07-11 13:34:21.000000000 +0200
@@ -301,6 +301,12 @@ out:
 
 #define flush_write_buffers() 
 
+/* Disable vmerge for now. Need to fix the block layer code
+   to check for non iommu addresses first.
+   When the IOMMU is force it is safe to enable. */
+extern int force_iommu; 
+#define BIO_VERMGE_BOUNDARY (force_iommu ? 4096 : 0)
+
 #endif /* __KERNEL__ */
 
 #endif
diff -burpN -X ../KDIFX linux/include/asm-x86_64/local.h linux-2.6.0test2-amd64/include/asm-x86_64/local.h
--- linux/include/asm-x86_64/local.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0test2-amd64/include/asm-x86_64/local.h	2003-07-28 20:07:06.000000000 +0200
@@ -0,0 +1,73 @@
+#ifndef _ARCH_X8664_LOCAL_H
+#define _ARCH_X8664_LOCAL_H
+
+#include <linux/percpu.h>
+
+typedef struct
+{
+	volatile unsigned int counter;
+} local_t;
+
+#define LOCAL_INIT(i)	{ (i) }
+
+#define local_read(v)	((v)->counter)
+#define local_set(v,i)	(((v)->counter) = (i))
+
+static __inline__ void local_inc(local_t *v)
+{
+	__asm__ __volatile__(
+		"incl %0"
+		:"=m" (v->counter)
+		:"m" (v->counter));
+}
+
+static __inline__ void local_dec(local_t *v)
+{
+	__asm__ __volatile__(
+		"decl %0"
+		:"=m" (v->counter)
+		:"m" (v->counter));
+}
+
+static __inline__ void local_add(unsigned long i, local_t *v)
+{
+	__asm__ __volatile__(
+		"addl %1,%0"
+		:"=m" (v->counter)
+		:"ir" (i), "m" (v->counter));
+}
+
+static __inline__ void local_sub(unsigned long i, local_t *v)
+{
+	__asm__ __volatile__(
+		"subl %1,%0"
+		:"=m" (v->counter)
+		:"ir" (i), "m" (v->counter));
+}
+
+/* On x86, these are no better than the atomic variants. */
+#define __local_inc(l)		local_inc(l)
+#define __local_dec(l)		local_dec(l)
+#define __local_add(i,l)	local_add((i),(l))
+#define __local_sub(i,l)	local_sub((i),(l))
+
+/* Use these for per-cpu local_t variables: on some archs they are
+ * much more efficient than these naive implementations.  Note they take
+ * a variable, not an address.
+ * 
+ * This could be done better if we moved the per cpu data directly 
+ * after GS.
+ */
+#define cpu_local_read(v)	local_read(&__get_cpu_var(v))
+#define cpu_local_set(v, i)	local_set(&__get_cpu_var(v), (i))
+#define cpu_local_inc(v)	local_inc(&__get_cpu_var(v))
+#define cpu_local_dec(v)	local_dec(&__get_cpu_var(v))
+#define cpu_local_add(i, v)	local_add((i), &__get_cpu_var(v))
+#define cpu_local_sub(i, v)	local_sub((i), &__get_cpu_var(v))
+
+#define __cpu_local_inc(v)	cpu_local_inc(v)
+#define __cpu_local_dec(v)	cpu_local_dec(v)
+#define __cpu_local_add(i, v)	cpu_local_add((i), (v))
+#define __cpu_local_sub(i, v)	cpu_local_sub((i), (v))
+
+#endif /* _ARCH_I386_LOCAL_H */
diff -burpN -X ../KDIFX linux/include/asm-x86_64/mpspec.h linux-2.6.0test2-amd64/include/asm-x86_64/mpspec.h
--- linux/include/asm-x86_64/mpspec.h	2003-05-27 03:00:39.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/mpspec.h	2003-07-11 13:34:21.000000000 +0200
@@ -164,11 +164,9 @@ enum mp_bustype {
 	MP_BUS_PCI,
 	MP_BUS_MCA
 };
-extern int mp_bus_id_to_type [MAX_MP_BUSSES];
-extern int mp_bus_id_to_node [MAX_MP_BUSSES];
-extern int mp_bus_id_to_local [MAX_MP_BUSSES];
-extern int quad_local_to_mp_bus_id [NR_CPUS/4][4];
+extern unsigned char mp_bus_id_to_type [MAX_MP_BUSSES];
 extern int mp_bus_id_to_pci_bus [MAX_MP_BUSSES];
+extern unsigned long mp_bus_to_cpumask [MAX_MP_BUSSES];
 
 extern unsigned int boot_cpu_physical_apicid;
 extern unsigned long phys_cpu_present_map;
@@ -177,11 +175,9 @@ extern void find_smp_config (void);
 extern void get_smp_config (void);
 extern int nr_ioapics;
 extern int apic_version [MAX_APICS];
-extern int mp_bus_id_to_type [MAX_MP_BUSSES];
 extern int mp_irq_entries;
 extern struct mpc_config_intsrc mp_irqs [MAX_IRQ_SOURCES];
 extern int mpc_default_type;
-extern int mp_bus_id_to_pci_bus [MAX_MP_BUSSES];
 extern int mp_current_pci_id;
 extern unsigned long mp_lapic_addr;
 extern int pic_mode;
diff -burpN -X ../KDIFX linux/include/asm-x86_64/nmi.h linux-2.6.0test2-amd64/include/asm-x86_64/nmi.h
--- linux/include/asm-x86_64/nmi.h	2003-07-18 02:40:01.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/nmi.h	2003-07-11 13:34:21.000000000 +0200
@@ -48,4 +48,6 @@ static inline void unset_nmi_pm_callback
  
 extern void default_do_nmi(struct pt_regs *);
  
+extern void default_do_nmi(struct pt_regs *);
+ 
 #endif /* ASM_NMI_H */
diff -burpN -X ../KDIFX linux/include/asm-x86_64/pci-direct.h linux-2.6.0test2-amd64/include/asm-x86_64/pci-direct.h
--- linux/include/asm-x86_64/pci-direct.h	2003-05-27 03:00:25.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/pci-direct.h	2003-07-11 13:35:37.000000000 +0200
@@ -14,7 +14,26 @@ static inline u32 read_pci_config(u8 bus
 	u32 v; 
 	outl(0x80000000 | (bus<<16) | (slot<<11) | (func<<8) | offset, 0xcf8);
 	v = inl(0xcfc); 
-	PDprintk("%x reading from %x: %x\n", slot, offset, v);
+	if (v != 0xffffffff)
+		PDprintk("%x reading 4 from %x: %x\n", slot, offset, v);
+	return v;
+}
+
+static inline u8 read_pci_config_byte(u8 bus, u8 slot, u8 func, u8 offset)
+{
+	u8 v; 
+	outl(0x80000000 | (bus<<16) | (slot<<11) | (func<<8) | offset, 0xcf8);
+	v = inb(0xcfc + (offset&3)); 
+	PDprintk("%x reading 1 from %x: %x\n", slot, offset, v);
+	return v;
+}
+
+static inline u8 read_pci_config_16(u8 bus, u8 slot, u8 func, u8 offset)
+{
+	u16 v; 
+	outl(0x80000000 | (bus<<16) | (slot<<11) | (func<<8) | offset, 0xcf8);
+	v = inw(0xcfc + (offset&2)); 
+	PDprintk("%x reading 2 from %x: %x\n", slot, offset, v);
 	return v;
 }
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/pci.h linux-2.6.0test2-amd64/include/asm-x86_64/pci.h
--- linux/include/asm-x86_64/pci.h	2003-07-18 02:40:01.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/pci.h	2003-07-11 13:34:21.000000000 +0200
@@ -8,9 +8,6 @@
 
 #include <linux/mm.h> /* for struct page */
 
-
-extern dma_addr_t bad_dma_address;
-
 /* Can be used to override the logic in pci_scan_bus for skipping
    already-configured bus numbers - to be used for buggy BIOSes
    or architectures with incomplete PCI setup by the loader */
@@ -21,6 +18,8 @@ extern unsigned int pcibios_assign_all_b
 #define pcibios_assign_all_busses()	0
 #endif
 
+extern int no_iommu, force_iommu;
+
 extern unsigned long pci_mem_start;
 #define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		(pci_mem_start)
@@ -46,6 +45,9 @@ struct pci_dev;
 
 extern int iommu_setup(char *opt);
 
+extern dma_addr_t bad_dma_address;
+#define pci_dma_error(x) ((x) == bad_dma_address)
+
 /* Allocate and map kernel buffer using consistent mode DMA for a device.
  * hwdev should be valid struct pci_dev pointer for PCI devices,
  * NULL for PCI-like buses (ISA, EISA).
@@ -119,10 +121,16 @@ static inline void pci_dma_sync_sg(struc
 
 /* The PCI address space does equal the physical memory
  * address space.  The networking and block device layers use
- * this boolean for bounce buffer decisions.
+ * this boolean for bounce buffer decisions
+ *
+ * On AMD64 it mostly equals, but we set it to zero to tell some subsystems
+ * that an IOMMU is available.
  */
-#define PCI_DMA_BUS_IS_PHYS	(0)
+#define PCI_DMA_BUS_IS_PHYS	(no_iommu ? 1 : 0) 
 
+/* We lie slightly when the IOMMU is forced to get the device to 
+   use SAC instead of DAC. */
+#define pci_dac_dma_supported(pci_dev, mask)	(force_iommu ? 0 : 1)
 
 #else
 static inline dma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr,
@@ -206,6 +214,7 @@ static inline void pci_dma_sync_sg(struc
 
 #define PCI_DMA_BUS_IS_PHYS	1
 
+#define pci_dac_dma_supported(pci_dev, mask)	1
 #endif
 
 extern int pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
@@ -220,21 +229,7 @@ extern void pci_unmap_sg(struct pci_dev 
  * only drive the low 24-bits during PCI bus mastering, then
  * you would pass 0x00ffffff as the mask to this function.
  */
-static inline int pci_dma_supported(struct pci_dev *hwdev, u64 mask)
-{
-        /*
-         * we fall back to GFP_DMA when the mask isn't all 1s,
-         * so we can't guarantee allocations that must be
-         * within a tighter range than GFP_DMA..
-         */
-        if(mask < 0x00ffffff)
-                return 0;
-
-	return 1;
-}
-
-/* This is always fine. */
-#define pci_dac_dma_supported(pci_dev, mask)	(1)
+extern int pci_dma_supported(struct pci_dev *hwdev, u64 mask);
 
 static __inline__ dma64_addr_t
 pci_dac_page_to_dma(struct pci_dev *pdev, struct page *page, unsigned long offset, int direction)
diff -burpN -X ../KDIFX linux/include/asm-x86_64/pda.h linux-2.6.0test2-amd64/include/asm-x86_64/pda.h
--- linux/include/asm-x86_64/pda.h	2003-05-27 03:00:38.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/pda.h	2003-07-29 01:37:11.000000000 +0200
@@ -9,7 +9,7 @@
 /* Per processor datastructure. %gs points to it while the kernel runs */ 
 struct x8664_pda {
 	struct task_struct *pcurrent;	/* Current process */
-	unsigned long cpudata_offset;
+	unsigned long data_offset;	/* Per cpu data offset from linker address */
 	struct x8664_pda *me;	    /* Pointer to itself */  
 	unsigned long kernelstack;  /* TOS for current process */ 
 	unsigned long oldrsp; 	    /* user rsp for system call */
diff -burpN -X ../KDIFX linux/include/asm-x86_64/percpu.h linux-2.6.0test2-amd64/include/asm-x86_64/percpu.h
--- linux/include/asm-x86_64/percpu.h	2003-05-27 03:00:43.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/percpu.h	2003-07-29 01:37:25.000000000 +0200
@@ -1,6 +1,53 @@
-#ifndef __ARCH_I386_PERCPU__
-#define __ARCH_I386_PERCPU__
+#ifndef _ASM_X8664_PERCPU_H_
+#define _ASM_X8664_PERCPU_H_
 
-#include <asm-generic/percpu.h>
+#include <asm/pda.h>
 
-#endif /* __ARCH_I386_PERCPU__ */
+#ifdef CONFIG_SMP
+
+/* Same as the generic code except that we cache the per cpu offset
+   in the pda. This gives an 3 instruction reference for per cpu data */
+
+#include <linux/compiler.h>
+#include <asm/pda.h>
+#define __my_cpu_offset() read_pda(data_offset)
+#define __per_cpu_offset(cpu) (cpu_pda[cpu].data_offset)
+
+/* Separate out the type, so (int[3], foo) works. */
+#define DEFINE_PER_CPU(type, name) \
+    __attribute__((__section__(".data.percpu"))) __typeof__(type) name##__per_cpu
+
+/* var is in discarded region: offset to particular copy we want */
+#define per_cpu(var, cpu) (*RELOC_HIDE(&var##__per_cpu, __per_cpu_offset(cpu)))
+#define __get_cpu_var(var) \
+	(*RELOC_HIDE(&var##__per_cpu, __my_cpu_offset()))
+
+static inline void percpu_modcopy(void *pcpudst, const void *src,
+				  unsigned long size)
+{
+	unsigned int i;
+	for (i = 0; i < NR_CPUS; i++)
+		if (cpu_possible(i))
+			memcpy(pcpudst + __per_cpu_offset(i), src, size);
+}
+
+extern void setup_per_cpu_areas(void);
+
+#else /* ! SMP */
+
+#define DEFINE_PER_CPU(type, name) \
+    __typeof__(type) name##__per_cpu
+
+#define per_cpu(var, cpu)			((void)cpu, var##__per_cpu)
+#define __get_cpu_var(var)			var##__per_cpu
+
+#endif	/* SMP */
+
+#define DECLARE_PER_CPU(type, name) extern __typeof__(type) name##__per_cpu
+
+#define EXPORT_PER_CPU_SYMBOL(var) EXPORT_SYMBOL(var##__per_cpu)
+#define EXPORT_PER_CPU_SYMBOL_GPL(var) EXPORT_SYMBOL_GPL(var##__per_cpu)
+
+DECLARE_PER_CPU(struct x8664_pda, per_cpu_pda); 
+
+#endif
diff -burpN -X ../KDIFX linux/include/asm-x86_64/processor.h linux-2.6.0test2-amd64/include/asm-x86_64/processor.h
--- linux/include/asm-x86_64/processor.h	2003-07-18 02:40:01.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/processor.h	2003-07-29 01:42:29.000000000 +0200
@@ -181,6 +181,7 @@ static inline void clear_in_cr4 (unsigne
  * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
  */
 #define IO_BITMAP_SIZE	32
+#define IO_BITMAP_BYTES (IO_BITMAP_SIZE * 4)
 #define IO_BITMAP_OFFSET offsetof(struct tss_struct,io_bitmap)
 #define INVALID_IO_BITMAP_OFFSET 0x8000
 
diff -burpN -X ../KDIFX linux/include/asm-x86_64/proto.h linux-2.6.0test2-amd64/include/asm-x86_64/proto.h
--- linux/include/asm-x86_64/proto.h	2003-07-18 02:40:01.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/proto.h	2003-07-11 13:34:21.000000000 +0200
@@ -77,7 +77,7 @@ extern unsigned long end_pfn; 
 extern unsigned long table_start, table_end;
 
 extern int exception_trace;
-extern int no_iommu, force_mmu;
+extern int force_iommu, no_iommu;
 extern int using_apic_timer;
 extern int disable_apic;
 extern unsigned cpu_khz;
diff -burpN -X ../KDIFX linux/include/asm-x86_64/smp.h linux-2.6.0test2-amd64/include/asm-x86_64/smp.h
--- linux/include/asm-x86_64/smp.h	2003-07-18 02:39:47.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/smp.h	2003-07-28 19:41:24.000000000 +0200
@@ -117,7 +117,7 @@ extern inline int safe_smp_processor_id(
 #ifndef CONFIG_SMP
 #define stack_smp_processor_id() 0
 #define safe_smp_processor_id() 0
-#define for_each_cpu(x) (x)=0;
+#define for_each_cpu(x,mask) (void)(mask), (x)=0;
 #define cpu_logical_map(x) (x)
 #else
 #include <asm/thread_info.h>
diff -burpN -X ../KDIFX linux/include/asm-x86_64/topology.h linux-2.6.0test2-amd64/include/asm-x86_64/topology.h
--- linux/include/asm-x86_64/topology.h	2003-05-27 03:00:43.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/topology.h	2003-07-11 13:34:21.000000000 +0200
@@ -5,6 +5,8 @@
 
 #ifdef CONFIG_DISCONTIGMEM
 
+#include <asm/mpspec.h>
+
 /* Map the K8 CPU local memory controllers to a simple 1:1 CPU:NODE topology */
 
 extern int fake_node;
@@ -17,6 +19,11 @@ extern unsigned long cpu_online_map;
 #define node_to_cpu_mask(node)	(fake_node ? cpu_online_map : (1UL << (node)))
 #define node_to_memblk(node)		(node)
 
+static inline unsigned long pcibus_to_cpumask(int bus)
+{ 
+	return mp_bus_to_cpumask[bus] & cpu_online_map; 
+} 
+
 #define NODE_BALANCE_RATE 30	/* CHECKME */ 
 
 #endif
diff -burpN -X ../KDIFX linux/include/asm-x86_64/unistd.h linux-2.6.0test2-amd64/include/asm-x86_64/unistd.h
--- linux/include/asm-x86_64/unistd.h	2003-07-18 02:40:01.000000000 +0200
+++ linux-2.6.0test2-amd64/include/asm-x86_64/unistd.h	2003-07-14 12:00:43.000000000 +0200
@@ -526,8 +526,12 @@ __SYSCALL(__NR_exit_group, sys_exit_grou
 __SYSCALL(__NR_epoll_wait, sys_epoll_wait)
 #define __NR_epoll_ctl		233
 __SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
+#define __NR_tgkill		234
+__SYSCALL(__NR_tgkill, sys_tgkill)
+#define __NR_utimes		235
+__SYSCALL(__NR_utimes, sys_utimes)
 
-#define __NR_syscall_max __NR_epoll_ctl
+#define __NR_syscall_max __NR_utimes
 #ifndef __NO_STUBS
 
 /* user-visible error numbers are in the range -1 - -4095 */
diff -burpN -X ../KDIFX linux/include/linux/compat.h linux-2.6.0test2-amd64/include/linux/compat.h
--- linux/include/linux/compat.h	2003-05-27 03:00:39.000000000 +0200
+++ linux-2.6.0test2-amd64/include/linux/compat.h	2003-07-11 13:34:21.000000000 +0200
@@ -15,6 +15,11 @@
 #define compat_jiffies_to_clock_t(x)	\
 		(((unsigned long)(x) * COMPAT_USER_HZ) / HZ)
 
+struct compat_itimerspec { 
+	struct compat_timespec it_interval;
+	struct compat_timespec it_value;
+};
+
 struct compat_utimbuf {
 	compat_time_t		actime;
 	compat_time_t		modtime;
@@ -71,5 +76,19 @@ struct compat_rusage {
 	compat_long_t	ru_nivcsw;
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif /* CONFIG_COMPAT */
 #endif /* _LINUX_COMPAT_H */
diff -burpN -X ../KDIFX linux/include/linux/pci.h linux-2.6.0test2-amd64/include/linux/pci.h
--- linux/include/linux/pci.h	2003-07-28 23:12:30.000000000 +0200
+++ linux-2.6.0test2-amd64/include/linux/pci.h	2003-07-28 19:18:18.000000000 +0200
@@ -671,6 +671,10 @@ extern struct pci_dev *isa_bridge;
 
 #include <asm/pci.h>
 
+#ifdef pci_dma_error
+#define pci_dma_error(x) 0 
+#endif
+
 /*
  *  If the system does not have PCI, clearly these return errors.  Define
  *  these as simple inline functions to avoid hair in drivers.
diff -burpN -X ../KDIFX linux/kernel/compat.c linux-2.6.0test2-amd64/kernel/compat.c
--- linux/kernel/compat.c	2003-07-28 23:12:31.000000000 +0200
+++ linux-2.6.0test2-amd64/kernel/compat.c	2003-07-28 19:18:18.000000000 +0200
@@ -434,3 +434,130 @@ asmlinkage int compat_sys_sched_getaffin
 	return ret;
 }
 
+static int get_compat_itimerspec(struct itimerspec *dst, 
+				 struct compat_itimerspec *src)
+{ 
+	if (get_compat_timespec(&dst->it_interval, &src->it_interval) ||
+	    get_compat_timespec(&dst->it_value, &src->it_value))
+		return -EFAULT;
+	return 0;
+} 
+
+static int put_compat_itimerspec(struct compat_itimerspec *dst, 
+				 struct itimerspec *src)
+{ 
+	if (put_compat_timespec(&src->it_interval, &dst->it_interval) ||
+	    put_compat_timespec(&src->it_value, &dst->it_value))
+		return -EFAULT;
+	return 0;
+} 
+
+extern asmlinkage long sys_timer_settime(timer_t timer_id, int flags,
+				  struct itimerspec __user *new_setting,
+				 struct itimerspec __user *old_setting);
+extern asmlinkage long sys_timer_gettime(timer_t timer_id, 
+					 struct itimerspec __user *setting);
+
+long compat_timer_settime(timer_t timer_id, int flags, 
+			  struct compat_itimerspec *new, 
+			  struct compat_itimerspec *old)
+{ 
+	long err;
+	mm_segment_t oldfs;
+	struct itimerspec newts, oldts;
+	if (get_compat_itimerspec(&newts, new))
+		return -EFAULT;	
+	oldfs = get_fs();
+	err = sys_timer_settime(timer_id, flags, &newts, &oldts);
+	set_fs(oldfs); 
+	if (!err && old && put_compat_itimerspec(old, &oldts))
+		return -EFAULT;
+	return err;
+} 
+
+long compat_timer_gettime(timer_t timer_id, struct compat_itimerspec *setting)
+{ 
+	long err;
+	mm_segment_t oldfs;
+	struct itimerspec ts; 
+	oldfs = get_fs();
+	err = sys_timer_gettime(timer_id, &ts); 
+	set_fs(oldfs); 
+	if (!err && put_compat_itimerspec(setting, &ts))
+		return -EFAULT;
+	return err;
+} 
+
+extern asmlinkage long
+sys_clock_settime(clockid_t which_clock, struct timespec __user *tp);
+
+long compat_clock_settime(clockid_t which_clock,  struct compat_timespec *tp)
+{
+	long err;
+	mm_segment_t oldfs;
+	struct timespec ts; 
+	if (get_compat_timespec(&ts, tp))
+		return -EFAULT; 
+	oldfs = get_fs(); 
+	err = sys_clock_settime(which_clock, &ts); 
+	set_fs(oldfs);
+	return err;
+} 
+
+extern asmlinkage long
+sys_clock_gettime(clockid_t which_clock, struct timespec __user *tp);
+
+long compat_clock_gettime(clockid_t which_clock,  struct compat_timespec *tp)
+{
+	long err;
+	mm_segment_t oldfs;
+	struct timespec ts; 
+	oldfs = get_fs(); 
+	err = sys_clock_gettime(which_clock, &ts); 
+	set_fs(oldfs);
+	if (!err && put_compat_timespec(&ts, tp))
+		return -EFAULT; 
+	return err;
+} 
+
+extern asmlinkage long
+sys_clock_getres(clockid_t which_clock, struct timespec __user *tp);
+
+long compat_clock_getres(clockid_t which_clock,  struct compat_timespec *tp)
+{
+	long err;
+	mm_segment_t oldfs;
+	struct timespec ts; 
+	oldfs = get_fs(); 
+	err = sys_clock_getres(which_clock, &ts); 
+	set_fs(oldfs);
+	if (!err && put_compat_timespec(&ts, tp))
+		return -EFAULT; 
+	return err;
+} 
+
+extern asmlinkage long
+sys_clock_nanosleep(clockid_t which_clock, int flags,
+		     struct timespec __user *rqtp,
+		    struct timespec __user *rmtp);
+
+long compat_clock_nanosleep(clockid_t which_clock, int flags,
+			    struct compat_timespec __user *rqtp,
+			    struct compat_timespec __user *rmtp)
+{
+	long err;
+	mm_segment_t oldfs;
+	struct timespec in, out; 
+	if (get_compat_timespec(&in, rqtp)) 
+		return -EFAULT;
+	oldfs = get_fs(); 
+	err = sys_clock_nanosleep(which_clock, flags, &in, &out);  
+	set_fs(oldfs);
+	if ((err == -ERESTART_RESTARTBLOCK) && rmtp &&
+	    put_compat_timespec(&out, rmtp))
+		return -EFAULT;
+	return err;	
+} 
+
+/* timer_create is architecture specific because it needs sigevent conversion */
+
diff -burpN -X ../KDIFX linux/kernel/sysctl.c linux-2.6.0test2-amd64/kernel/sysctl.c
--- linux/kernel/sysctl.c	2003-07-18 02:42:42.000000000 +0200
+++ linux-2.6.0test2-amd64/kernel/sysctl.c	2003-07-14 11:57:37.000000000 +0200
@@ -798,7 +798,17 @@ static ctl_table fs_table[] = {
 	{ .ctl_name = 0 }
 };
 
+extern int sysctl_vsyscall32;
+
 static ctl_table debug_table[] = {
+#if defined(__x86_64__) && defined(CONFIG_IA32_EMULATION)
+	{ .ctl_name = 100, 
+	  .procname = "vsyscall32", 
+	  .data = &sysctl_vsyscall32, 
+	  .maxlen = sizeof(int), 
+	  .mode = 0644, 
+	  .proc_handler = &proc_dointvec},
+#endif
 	{ .ctl_name = 0 }
 };
 
