  arch/ppc64/kernel/pmac_iommu.c
    1.2 04/03/16 09:45:10 benh@kernel.crashing.org[torvalds] +5 -2
    g5: Fix iommu vs. pci_device_to_OF_node

ChangeSet
  1.1320.631.1 04/03/16 07:07:38 benh@kernel.crashing.org +1 -0
  [PATCH] g5: Fix iommu vs. pci_device_to_OF_node
  
  The g5 iommu code would fill the "iommu_table" member of whatever
  device node was pointed to by pcidev->sysdata during boot. However,
  the ppc64 kernel fills that with a pointer to the PHB node which is
  later replaced "lazily" with a pointer to the real node when calling
  pci_device_to_OF_node(). In this case, we were thus "losign" the
  iommu_table pointer. Typical symptom: loss of the SATA when looking
  at it's /proc entry.
  
  This fixes it by forcing the update to the final sysdata pointer
  when filling up the iommu_table pointers. The "lazy" thing is useless
  on pmac anyway.

diff -Nru a/arch/ppc64/kernel/pmac_iommu.c b/arch/ppc64/kernel/pmac_iommu.c
--- a/arch/ppc64/kernel/pmac_iommu.c	Wed Mar 17 11:55:22 2004
+++ b/arch/ppc64/kernel/pmac_iommu.c	Wed Mar 17 11:55:22 2004
@@ -289,8 +289,11 @@
 	 * things simple. Setup all PCI devices to point to this table
 	 */
 	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-		dn = PCI_GET_DN(dev);
-
+		/* We must use pci_device_to_OF_node() to make sure that
+		 * we get the real "final" pointer to the device in the
+		 * pci_dev sysdata and not the temporary PHB one
+		 */
+		struct device_node *dn = pci_device_to_OF_node(dev);
 		if (dn)
 			dn->iommu_table = &iommu_table_pmac;
 	}
.........................................................................
# vim: syntax=diff

