ps3-wip/ps3-sys-manager-fix-reboot.diff

Fixups to the PS3 sys-manager and vuart drivers to properly support
sys_reboot().  User commands reboot, poweroff, etc., and the system
power button work as expected with these changes.

- Fix a bug in the vuart polled read logic.
- Move ps3_vuart_work into ps3_vuart_port_priv.tx_list.
- Remove redundant spinlock ps3_vuart_work.lock.
- No longer free ps3_vuart_port_device.priv on shutdown.
- Add varable request_tag to struct ps3_sys_manager_header.
- Move ctrl_alt_del from PS3_SM_EVENT_POWER_RELEASED to
  PS3_SM_EVENT_POWER_PRESSED.
- Add more comments to vuart.c.

Signed-off-by: Geoff Levand <geoffrey.levand@am.sony.com>

---
 drivers/ps3/sys-manager.c |   68 +++++++++++---
 drivers/ps3/vuart.c       |  209 ++++++++++++++++++++++++++++++----------------
 drivers/ps3/vuart.h       |    3 
 3 files changed, 191 insertions(+), 89 deletions(-)

--- linux-2.6.21.orig/drivers/ps3/sys-manager.c
+++ linux-2.6.21/drivers/ps3/sys-manager.c
@@ -35,7 +35,7 @@ MODULE_DESCRIPTION("PS3 System Manager")
 /**
  * ps3_sys_manager - PS3 system manager driver.
  *
- * The system manager provides an asyncronous system event notification
+ * The system manager provides an asynchronous system event notification
  * mechanism for reporting events like thermal alert and button presses to
  * guests.  It also provides support to control system shutdown and startup.
  *
@@ -52,6 +52,7 @@ MODULE_DESCRIPTION("PS3 System Manager")
  * @size: Header size in bytes, curently 16.
  * @payload_size: Message payload size in bytes.
  * @service_id: Message type, one of enum ps3_sys_manager_service_id.
+ * @request_tag: Unique number to identify reply.
  */
 
 struct ps3_sys_manager_header {
@@ -61,7 +62,8 @@ struct ps3_sys_manager_header {
 	u16 reserved_1;
 	u32 payload_size;
 	u16 service_id;
-	u16 reserved_2[3];
+	u16 reserved_2;
+	u32 request_tag;
 };
 
 /**
@@ -185,6 +187,16 @@ enum ps3_sys_manager_cmd {
 };
 
 /**
+ * ps3_sm_force_power_off - Poweroff helper.
+ *
+ * A global variable used to force a poweroff when the power button has
+ * been pressed irrespective of how init handles the ctrl_alt_del signal.
+ *
+ */
+
+static unsigned int ps3_sm_force_power_off;
+
+/**
  * ps3_sys_manager_write - Helper to write a two part message to the vuart.
  *
  */
@@ -286,10 +298,11 @@ static int ps3_sys_manager_send_next_op(
  * the command is then communicated back to the system manager with a response
  * message.
  *
- * Currently, the only supported request it the 'shutdown self' request.
+ * Currently, the only supported request is the 'shutdown self' request.
  */
 
-static int ps3_sys_manager_send_request_shutdown(struct ps3_vuart_port_device *dev)
+static int ps3_sys_manager_send_request_shutdown(
+	struct ps3_vuart_port_device *dev)
 {
 	static const struct ps3_sys_manager_header header = {
 		.version = 1,
@@ -382,11 +395,24 @@ static int ps3_sys_manager_handle_event(
 	case PS3_SM_EVENT_POWER_PRESSED:
 		dev_dbg(&dev->core, "%s:%d: POWER_PRESSED\n",
 			__func__, __LINE__);
+		ps3_sm_force_power_off = 1;
+		wmb();
+		ctrl_alt_del();
 		break;
 	case PS3_SM_EVENT_POWER_RELEASED:
 		dev_dbg(&dev->core, "%s:%d: POWER_RELEASED (%u ms)\n",
 			__func__, __LINE__, event.value);
-		kill_cad_pid(SIGINT, 1);
+		break;
+	case PS3_SM_EVENT_RESET_PRESSED:
+		dev_dbg(&dev->core, "%s:%d: RESET_PRESSED\n",
+			__func__, __LINE__);
+		ps3_sm_force_power_off = 0;
+		wmb();
+		ctrl_alt_del();
+		break;
+	case PS3_SM_EVENT_RESET_RELEASED:
+		dev_dbg(&dev->core, "%s:%d: RESET_RELEASED (%u ms)\n",
+			__func__, __LINE__, event.value);
 		break;
 	case PS3_SM_EVENT_THERMAL_ALERT:
 		dev_dbg(&dev->core, "%s:%d: THERMAL_ALERT (zone %u)\n",
@@ -494,7 +520,7 @@ fail_id:
 }
 
 /**
- * ps3_sys_manager_work - Asyncronous read handler.
+ * ps3_sys_manager_work - Asynchronous read handler.
  *
  * Signaled when a complete message arrives at the vuart port.
  */
@@ -512,16 +538,16 @@ struct {
 } static drv_priv;
 
 /**
- * ps3_sys_manager_restart - The final platform machine_restart routine.
+ * ps3_sys_manager_power_off - The final platform machine_power_off routine.
  *
- * This routine never returns.  The routine disables asyncronous vuart reads
+ * This routine never returns.  The routine disables asynchronous vuart reads
  * then spins calling ps3_sys_manager_handle_msg() to receive and acknowledge
  * the shutdown command sent from the system manager.  Soon after the
  * acknowledgement is sent the lpar is destroyed by the HV.  This routine
- * should only be called from ps3_restart().
+ * should only be called from ps3_power_off().
  */
 
-void ps3_sys_manager_restart(void)
+void ps3_sys_manager_power_off(void)
 {
 	struct ps3_vuart_port_device *dev = drv_priv.dev;
 
@@ -531,8 +557,7 @@ void ps3_sys_manager_restart(void)
 
 	ps3_vuart_cancel_async(dev);
 
-	ps3_sys_manager_send_attr(dev, 0);
-	ps3_sys_manager_send_next_op(dev, PS3_SM_NEXT_OP_LPAR_REBOOT,
+	ps3_sys_manager_send_next_op(dev, PS3_SM_NEXT_OP_SYS_SHUTDOWN,
 		PS3_SM_WAKE_DEFAULT);
 	ps3_sys_manager_send_request_shutdown(dev);
 
@@ -543,16 +568,16 @@ void ps3_sys_manager_restart(void)
 }
 
 /**
- * ps3_sys_manager_power_off - The final platform machine_power_off routine.
+ * ps3_sys_manager_restart - The final platform machine_restart routine.
  *
- * This routine never returns.  The routine disables asyncronous vuart reads
+ * This routine never returns.  The routine disables asynchronous vuart reads
  * then spins calling ps3_sys_manager_handle_msg() to receive and acknowledge
  * the shutdown command sent from the system manager.  Soon after the
  * acknowledgement is sent the lpar is destroyed by the HV.  This routine
- * should only be called from ps3_power_off().
+ * should only be called from ps3_restart().
  */
 
-void ps3_sys_manager_power_off(void)
+void ps3_sys_manager_restart(void)
 {
 	struct ps3_vuart_port_device *dev = drv_priv.dev;
 
@@ -560,9 +585,18 @@ void ps3_sys_manager_power_off(void)
 
 	dev_dbg(&dev->core, "%s:%d\n", __func__, __LINE__);
 
+	/* Check if we got here via a power button event. */
+
+	if(ps3_sm_force_power_off) {
+		dev_dbg(&dev->core, "%s:%d: forcing poweroff\n",
+			__func__, __LINE__);
+		ps3_sys_manager_power_off();
+	}
+
 	ps3_vuart_cancel_async(dev);
 
-	ps3_sys_manager_send_next_op(dev, PS3_SM_NEXT_OP_SYS_SHUTDOWN,
+	ps3_sys_manager_send_attr(dev, 0);
+	ps3_sys_manager_send_next_op(dev, PS3_SM_NEXT_OP_LPAR_REBOOT,
 		PS3_SM_WAKE_DEFAULT);
 	ps3_sys_manager_send_request_shutdown(dev);
 
--- linux-2.6.21.orig/drivers/ps3/vuart.c
+++ linux-2.6.21/drivers/ps3/vuart.c
@@ -240,6 +240,12 @@ static int ps3_vuart_get_rx_bytes_waitin
 	return result;
 }
 
+/**
+ * ps3_vuart_set_interrupt_mask - Enable/disable the port interrupt sources.
+ * @dev: The struct ps3_vuart_port_device instance.
+ * @bmp: Logical OR of enum vuart_interrupt_mask values. A zero bit disables.
+ */
+
 static int ps3_vuart_set_interrupt_mask(struct ps3_vuart_port_device *dev,
 	unsigned long mask)
 {
@@ -322,6 +328,7 @@ int ps3_vuart_disable_interrupt_disconne
 
 /**
  * ps3_vuart_raw_write - Low level write helper.
+ * @dev: The struct ps3_vuart_port_device instance.
  *
  * Do not call ps3_vuart_raw_write directly, use ps3_vuart_write.
  */
@@ -350,6 +357,7 @@ static int ps3_vuart_raw_write(struct ps
 
 /**
  * ps3_vuart_raw_read - Low level read helper.
+ * @dev: The struct ps3_vuart_port_device instance.
  *
  * Do not call ps3_vuart_raw_read directly, use ps3_vuart_read.
  */
@@ -380,6 +388,7 @@ static int ps3_vuart_raw_read(struct ps3
 
 /**
  * ps3_vuart_clear_rx_bytes - Discard bytes received.
+ * @dev: The struct ps3_vuart_port_device instance.
  * @bytes: Max byte count to discard, zero = all pending.
  *
  * Used to clear pending rx interrupt source.  Will not block.
@@ -435,6 +444,7 @@ struct list_buffer {
 
 /**
  * ps3_vuart_write - the entry point for writing data to a port
+ * @dev: The struct ps3_vuart_port_device instance.
  *
  * If the port is idle on entry as much of the incoming data is written to
  * the port as the port will accept.  Otherwise a list buffer is created
@@ -503,17 +513,71 @@ int ps3_vuart_write(struct ps3_vuart_por
 }
 
 /**
- * ps3_vuart_read - the entry point for reading data from a port
+ * ps3_vuart_queue_rx_bytes - Queue waiting bytes into the buffer list.
+ * @dev: The struct ps3_vuart_port_device instance.
+ * @bytes_queued: Number of bytes queued to the buffer list.
  *
- * If enough bytes to satisfy the request are held in the buffer list those
- * bytes are dequeued and copied to the caller's buffer.  Emptied list buffers
- * are retiered.  If the request cannot be statified by bytes held in the list
- * buffers -EAGAIN is returned.
+ * Must be called with dev->priv->rx_list.lock held.
+ */
+
+static int ps3_vuart_queue_rx_bytes(struct ps3_vuart_port_device *dev,
+	u64 *bytes_queued)
+{
+	static unsigned long dbg_number;
+	int result;
+	struct list_buffer *lb;
+	u64 bytes;
+
+	*bytes_queued = 0;
+
+	result = ps3_vuart_get_rx_bytes_waiting(dev, &bytes);
+	BUG_ON(result);
+
+	if (result)
+		return -EIO;
+
+	if(!bytes)
+		return 0;
+
+	/* Add some extra space for recently arrived data. */
+
+	bytes += 128;
+
+	lb = kmalloc(sizeof(struct list_buffer) + bytes, GFP_ATOMIC);
+
+	if (!lb)
+		return -ENOMEM;
+
+	ps3_vuart_raw_read(dev, lb->data, bytes, &bytes);
+
+	lb->head = lb->data;
+	lb->tail = lb->data + bytes;
+	lb->dbg_number = ++dbg_number;
+
+	list_add_tail(&lb->link, &dev->priv->rx_list.head);
+	dev->priv->rx_list.bytes_held += bytes;
+
+	dev_dbg(&dev->core, "%s:%d: buf_%lu: queued %lxh bytes\n",
+		__func__, __LINE__, lb->dbg_number, bytes);
+
+	*bytes_queued = bytes;
+
+	return 0;
+}
+
+/**
+ * ps3_vuart_read - The entry point for reading data from a port.
+ *
+ * Queue data waiting at the port, and if enough bytes to satisfy the request
+ * are held in the buffer list those bytes are dequeued and copied to the
+ * caller's buffer.  Emptied list buffers are retiered.  If the request cannot
+ * be statified by bytes held in the list buffers -EAGAIN is returned.
  */
 
 int ps3_vuart_read(struct ps3_vuart_port_device *dev, void* buf,
 	unsigned int bytes)
 {
+	int result;
 	unsigned long flags;
 	struct list_buffer *lb, *n;
 	unsigned long bytes_read;
@@ -523,12 +587,19 @@ int ps3_vuart_read(struct ps3_vuart_port
 
 	spin_lock_irqsave(&dev->priv->rx_list.lock, flags);
 
-	if (dev->priv->rx_list.bytes_held < bytes) {
-		spin_unlock_irqrestore(&dev->priv->rx_list.lock, flags);
-		dev_dbg(&dev->core, "%s:%d: starved for %lxh bytes\n",
-			__func__, __LINE__,
-			bytes - dev->priv->rx_list.bytes_held);
-		return -EAGAIN;
+	/* Queue rx bytes here for polled reads. */
+
+	while (dev->priv->rx_list.bytes_held < bytes) {
+		u64 tmp;
+
+		result = ps3_vuart_queue_rx_bytes(dev, &tmp);
+		if (result || !tmp) {
+			dev_dbg(&dev->core, "%s:%d: starved for %lxh bytes\n",
+				__func__, __LINE__,
+				bytes - dev->priv->rx_list.bytes_held);
+			spin_unlock_irqrestore(&dev->priv->rx_list.lock, flags);
+			return -EAGAIN;
+		}
 	}
 
 	list_for_each_entry_safe(lb, n, &dev->priv->rx_list.head, link) {
@@ -565,7 +636,7 @@ int ps3_vuart_read_async(struct ps3_vuar
 {
 	unsigned long flags;
 
-	if(dev->priv->work.trigger) {
+	if(dev->priv->rx_list.work.trigger) {
 		dev_dbg(&dev->core, "%s:%d: warning, multiple calls\n",
 			__func__, __LINE__);
 		return -EAGAIN;
@@ -573,19 +644,19 @@ int ps3_vuart_read_async(struct ps3_vuar
 
 	BUG_ON(!bytes);
 
-	PREPARE_WORK(&dev->priv->work.work, func);
+	PREPARE_WORK(&dev->priv->rx_list.work.work, func);
 
-	spin_lock_irqsave(&dev->priv->work.lock, flags);
+	spin_lock_irqsave(&dev->priv->rx_list.lock, flags);
 	if(dev->priv->rx_list.bytes_held >= bytes) {
 		dev_dbg(&dev->core, "%s:%d: schedule_work %xh bytes\n",
 			__func__, __LINE__, bytes);
-		schedule_work(&dev->priv->work.work);
-		spin_unlock_irqrestore(&dev->priv->work.lock, flags);
+		schedule_work(&dev->priv->rx_list.work.work);
+		spin_unlock_irqrestore(&dev->priv->rx_list.lock, flags);
 		return 0;
 	}
 
-	dev->priv->work.trigger = bytes;
-	spin_unlock_irqrestore(&dev->priv->work.lock, flags);
+	dev->priv->rx_list.work.trigger = bytes;
+	spin_unlock_irqrestore(&dev->priv->rx_list.lock, flags);
 
 	dev_dbg(&dev->core, "%s:%d: waiting for %u(%xh) bytes\n", __func__,
 		__LINE__, bytes, bytes);
@@ -595,7 +666,7 @@ int ps3_vuart_read_async(struct ps3_vuar
 
 void ps3_vuart_cancel_async(struct ps3_vuart_port_device *dev)
 {
-	dev->priv->work.trigger = 0;
+	dev->priv->rx_list.work.trigger = 0;
 }
 
 /**
@@ -667,54 +738,30 @@ port_full:
 
 static int ps3_vuart_handle_interrupt_rx(struct ps3_vuart_port_device *dev)
 {
-	static unsigned long dbg_number;
-	int result = 0;
+	int result;
 	unsigned long flags;
-	struct list_buffer *lb;
-	unsigned long bytes;
+	u64 bytes;
 
 	dev_dbg(&dev->core, "%s:%d\n", __func__, __LINE__);
 
-	result = ps3_vuart_get_rx_bytes_waiting(dev, &bytes);
-
-	if (result)
-		return -EIO;
-
-	BUG_ON(!bytes);
-
-	/* Add some extra space for recently arrived data. */
-
-	bytes += 128;
-
-	lb = kmalloc(sizeof(struct list_buffer) + bytes, GFP_ATOMIC);
-
-	if (!lb)
-		return -ENOMEM;
-
-	ps3_vuart_raw_read(dev, lb->data, bytes, &bytes);
-
-	lb->head = lb->data;
-	lb->tail = lb->data + bytes;
-	lb->dbg_number = ++dbg_number;
-
 	spin_lock_irqsave(&dev->priv->rx_list.lock, flags);
-	list_add_tail(&lb->link, &dev->priv->rx_list.head);
-	dev->priv->rx_list.bytes_held += bytes;
-	spin_unlock_irqrestore(&dev->priv->rx_list.lock, flags);
+	result = ps3_vuart_queue_rx_bytes(dev, &bytes);
 
-	dev_dbg(&dev->core, "%s:%d: buf_%lu: queued %lxh bytes\n",
-		__func__, __LINE__, lb->dbg_number, bytes);
+	if (result) {
+		spin_unlock_irqrestore(&dev->priv->rx_list.lock, flags);
+		return result;
+	}
 
-	spin_lock_irqsave(&dev->priv->work.lock, flags);
-	if(dev->priv->work.trigger
-		&& dev->priv->rx_list.bytes_held >= dev->priv->work.trigger) {
+	if(dev->priv->rx_list.work.trigger && dev->priv->rx_list.bytes_held
+		>= dev->priv->rx_list.work.trigger) {
 		dev_dbg(&dev->core, "%s:%d: schedule_work %lxh bytes\n",
-			__func__, __LINE__, dev->priv->work.trigger);
-		dev->priv->work.trigger = 0;
-		schedule_work(&dev->priv->work.work);
+			__func__, __LINE__, dev->priv->rx_list.work.trigger);
+		dev->priv->rx_list.work.trigger = 0;
+		schedule_work(&dev->priv->rx_list.work.work);
 	}
-	spin_unlock_irqrestore(&dev->priv->work.lock, flags);
-	return 0;
+
+	spin_unlock_irqrestore(&dev->priv->rx_list.lock, flags);
+	return result;
 }
 
 static int ps3_vuart_handle_interrupt_disconnect(
@@ -879,15 +926,15 @@ static int ps3_vuart_probe(struct device
 	INIT_LIST_HEAD(&dev->priv->rx_list.head);
 	spin_lock_init(&dev->priv->rx_list.lock);
 
-	INIT_WORK(&dev->priv->work.work, NULL);
-	spin_lock_init(&dev->priv->work.lock);
-	dev->priv->work.trigger = 0;
-	dev->priv->work.dev = dev;
+	INIT_WORK(&dev->priv->rx_list.work.work, NULL);
+	dev->priv->rx_list.work.trigger = 0;
+	dev->priv->rx_list.work.dev = dev;
 
 	if (++vuart_bus_priv.use_count == 1) {
 
 		result = ps3_vuart_irq_setup(PS3_BINDING_CPU_ANY,
-			(void*)&vuart_bus_priv.bmp.status, &vuart_bus_priv.virq);
+			(void*)&vuart_bus_priv.bmp.status,
+			&vuart_bus_priv.virq);
 
 		if (result) {
 			dev_dbg(&dev->core,
@@ -956,9 +1003,9 @@ fail_match:
  * @dev: The struct ps3_vuart_port_device instance.
  * @drv: The struct ps3_vuart_port_driver instance.
  *
- * Cleans dynamicly allocated mem and interrupts.  Must be called with
+ * Cleans interrupts and HV resources.  Must be called with
  * vuart_bus_priv.probe_mutex held.  Used by ps3_vuart_remove and
- * ps3_vuart_shutdown.
+ * ps3_vuart_shutdown.  After this call, polled reading will still work.
  */
 
 static int ps3_vuart_cleanup(struct ps3_vuart_port_device *dev,
@@ -968,21 +1015,29 @@ static int ps3_vuart_cleanup(struct ps3_
 
 	BUG_ON(vuart_bus_priv.use_count < 1);
 
-	vuart_bus_priv.devices[dev->priv->port_number] = NULL;
+	ps3_vuart_cancel_async(dev);
+
+	ps3_vuart_set_interrupt_mask(dev, 0);
 
 	if (--vuart_bus_priv.use_count == 0) {
-		// need to do this only for kexec???
+		dev_dbg(&dev->core, "%s:%d: ps3_vuart_irq_destroy\n",
+			__func__, __LINE__);
 		free_irq(vuart_bus_priv.virq, &vuart_bus_priv);
 		ps3_vuart_irq_destroy(vuart_bus_priv.virq);
 		vuart_bus_priv.virq = NO_IRQ;
 	}
 
-	kfree(dev->priv);
-	dev->priv = NULL;
-
 	return 0;
 }
 
+/**
+ * ps3_vuart_remove - Completely clean the device instance.
+ * @dev: The struct ps3_vuart_port_device instance.
+ *
+ * Cleans all memory, interrupts and HV resources.  After this call the
+ * device can no longer be used.
+ */
+
 static int ps3_vuart_remove(struct device *_dev)
 {
 	struct ps3_vuart_port_device *dev = to_ps3_vuart_port_device(_dev);
@@ -1016,12 +1071,26 @@ static int ps3_vuart_remove(struct devic
 
 	ps3_vuart_cleanup(dev, drv);
 
+	kfree(dev->priv);
+	dev->priv = NULL;
+	vuart_bus_priv.devices[dev->priv->port_number] = NULL;
+
 	dev_dbg(&dev->core, " <- %s:%d\n", __func__, __LINE__);
 
 	up(&vuart_bus_priv.probe_mutex);
 	return 0;
 }
 
+/**
+ * ps3_vuart_shutdown - Cleans interrupts and HV resources.
+ * @dev: The struct ps3_vuart_port_device instance.
+ *
+ * Cleans interrupts and HV resources.  After this call the
+ * device can still be used in polling mode.  This behavior required
+ * by sys-manager to be able to complete the device power operation
+ * sequence.
+ */
+
 static void ps3_vuart_shutdown(struct device *_dev)
 {
 	struct ps3_vuart_port_device *dev = to_ps3_vuart_port_device(_dev);
--- linux-2.6.21.orig/drivers/ps3/vuart.h
+++ linux-2.6.21/drivers/ps3/vuart.h
@@ -34,7 +34,6 @@ struct ps3_vuart_stats {
 struct ps3_vuart_work {
 	struct work_struct work;
 	unsigned long trigger;
-	spinlock_t lock;
 	struct ps3_vuart_port_device* dev; /* to convert work to device */
 };
 
@@ -51,12 +50,12 @@ struct ps3_vuart_port_priv {
 		struct list_head head;
 	} tx_list;
 	struct {
+		struct ps3_vuart_work work;
 		unsigned long bytes_held;
 		spinlock_t lock;
 		struct list_head head;
 	} rx_list;
 	struct ps3_vuart_stats stats;
-	struct ps3_vuart_work work;
 };
 
 /**
