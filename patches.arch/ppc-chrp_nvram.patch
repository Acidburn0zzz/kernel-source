From: Olaf Hering <olh@suse.de>
Subject: [PATCH] nvram driver for chrp

This implements a nvram acccess method, similar to
arch/ppc64/kernel/pSeries_nvram.c
tested on CHRP B50.

Signed-off-by: Olaf Hering <olh@suse.de>


diff -purNx tags ../linux-2.6.11-rc3.orig/arch/ppc/platforms/Makefile ./arch/ppc/platforms/Makefile
--- ../linux-2.6.11-rc3.orig/arch/ppc/platforms/Makefile	2005-02-03 02:57:04.000000000 +0100
+++ ./arch/ppc/platforms/Makefile	2005-02-06 10:56:57.428548209 +0100
@@ -13,6 +13,9 @@ obj-$(CONFIG_PPC_PMAC)		+= pmac_pic.o pm
 					pmac_feature.o pmac_pci.o pmac_sleep.o \
 					pmac_low_i2c.o pmac_cache.o
 obj-$(CONFIG_PPC_CHRP)		+= chrp_setup.o chrp_time.o chrp_pci.o
+ifeq ($(CONFIG_PPC_CHRP),y)
+obj-$(CONFIG_NVRAM)		+= chrp_nvram.o
+endif
 obj-$(CONFIG_PPC_PREP)		+= prep_pci.o prep_setup.o
 ifeq ($(CONFIG_PPC_PMAC),y)
 obj-$(CONFIG_NVRAM)		+= pmac_nvram.o
diff -purNx tags ../linux-2.6.11-rc3.orig/arch/ppc/platforms/chrp_nvram.c ./arch/ppc/platforms/chrp_nvram.c
--- ../linux-2.6.11-rc3.orig/arch/ppc/platforms/chrp_nvram.c	1970-01-01 01:00:00.000000000 +0100
+++ ./arch/ppc/platforms/chrp_nvram.c	2005-02-06 13:45:57.671598084 +0100
@@ -0,0 +1,83 @@
+/*
+ *  c 2001 PPC 64 Team, IBM Corp
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * /dev/nvram driver for PPC
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+
+static unsigned int nvram_size;
+static unsigned char nvram_buf[4];
+static DEFINE_SPINLOCK(nvram_lock);
+
+static unsigned char chrp_nvram_read(int addr)
+{
+	unsigned long done, flags;
+	unsigned char ret;
+
+	if (addr >= nvram_size) {
+		printk(KERN_DEBUG "%s: read addr %d > nvram_size %u\n",
+		       current->comm, addr, nvram_size);
+		return 0xff;
+	}
+	spin_lock_irqsave(&nvram_lock, flags);
+	if ((call_rtas("nvram-fetch", 3, 2, &done, addr, __pa(nvram_buf), 1) != 0) || 1 != done)
+		ret = 0xff;
+	else
+		ret = nvram_buf[0];
+	spin_unlock_irqrestore(&nvram_lock, flags);
+
+	return ret;
+}
+
+static void chrp_nvram_write(int addr, unsigned char val)
+{
+	unsigned long done, flags;
+
+	if (addr >= nvram_size) {
+		printk(KERN_DEBUG "%s: write addr %d > nvram_size %u\n",
+		       current->comm, addr, nvram_size);
+		return;
+	}
+	spin_lock_irqsave(&nvram_lock, flags);
+	nvram_buf[0] = val;
+	if ((call_rtas("nvram-store", 3, 2, &done, addr, __pa(nvram_buf), 1) != 0) || 1 != done)
+		printk(KERN_DEBUG "rtas IO error storing 0x%02x at %d", val, addr);
+	spin_unlock_irqrestore(&nvram_lock, flags);
+}
+
+void __init chrp_nvram_init(void)
+{
+	struct device_node *nvram;
+	unsigned int *nbytes_p, proplen;
+
+	nvram = of_find_node_by_type(NULL, "nvram");
+	if (nvram == NULL)
+		return;
+
+	nbytes_p = (unsigned int *)get_property(nvram, "#bytes", &proplen);
+	if (nbytes_p == NULL || proplen != sizeof(unsigned int))
+		return;
+
+	nvram_size = *nbytes_p;
+
+	printk(KERN_INFO "CHRP nvram contains %u bytes\n", nvram_size);
+	of_node_put(nvram);
+
+	ppc_md.nvram_read_val = chrp_nvram_read;
+	ppc_md.nvram_write_val = chrp_nvram_write;
+
+	return;
+}
diff -purNx tags ../linux-2.6.11-rc3.orig/arch/ppc/platforms/chrp_setup.c ./arch/ppc/platforms/chrp_setup.c
--- ../linux-2.6.11-rc3.orig/arch/ppc/platforms/chrp_setup.c	2005-02-03 02:56:33.000000000 +0100
+++ ./arch/ppc/platforms/chrp_setup.c	2005-02-06 13:15:12.494374066 +0100
@@ -465,8 +465,7 @@ void __init
 chrp_init2(void)
 {
 #ifdef CONFIG_NVRAM
-// XX replace this in a more saner way
-//	pmac_nvram_init();
+	chrp_nvram_init();
 #endif
 
 	request_region(0x20,0x20,"pic1");
diff -purNx tags ../linux-2.6.11-rc3.orig/include/asm-ppc/system.h ./include/asm-ppc/system.h
--- ../linux-2.6.11-rc3.orig/include/asm-ppc/system.h	2005-02-03 02:55:50.000000000 +0100
+++ ./include/asm-ppc/system.h	2005-02-06 13:13:38.456637144 +0100
@@ -70,6 +70,7 @@ extern void _set_L3CR(unsigned long);
 #endif
 extern void via_cuda_init(void);
 extern void pmac_nvram_init(void);
+extern void chrp_nvram_init(void);
 extern void read_rtc_time(void);
 extern void pmac_find_display(void);
 extern void giveup_fpu(struct task_struct *);
_______________________________________________
Linuxppc-dev mailing list
Linuxppc-dev@ozlabs.org
https://ozlabs.org/mailman/listinfo/linuxppc-dev

