Subject: Fix freeing of initrd
Patch-mainline: 2.6.16

From: Haren Myneni <haren@us.ibm.com>

Based on free_initrd_mem() (arch/x86_64/mm/init.c), it is freed only if 
initrd_start is greater than end of kernel text.

if (start < (unsigned long)&_end)
    return;

On my system, initrd starts at 0xffff810037ca5000 ( 893MB) and _end = 
0xffffffff80536000.  Hence, free_initrd_mem() simply returns without 
freeing the initrd region.
However, with the following patch, it is freed.

[AK: I did some investigation and it looks like gcc uses
signed comparisons for variable pointers and unsigned comparisons
if the address of an object is directly involved. The code
happened to work by chance on i386 because the comparison
was both variable pointers there.

P.S.: yes I know it's technically undefined]

Signed-off-by: Haren Myneni <haren@us.ibm.com>
Signed-off-by: Andi Kleen <ak@suse.de>


--- 2615-git9-k1/arch/x86_64/mm/init.c.orig	2006-01-19 01:41:39.000000000 -0800
+++ 2615-git9-k1/arch/x86_64/mm/init.c	2006-01-19 01:43:12.000000000 -0800
@@ -539,8 +539,9 @@ void mark_rodata_ro(void)
 #ifdef CONFIG_BLK_DEV_INITRD
 void free_initrd_mem(unsigned long start, unsigned long end)
 {
-	if (start < (unsigned long)&_end)
+	if (__pa(start) < __pa((unsigned long)&_end))
 		return;
+
 	printk ("Freeing initrd memory: %ldk freed\n", (end - start) >> 10);
 	for (; start < end; start += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(start));
