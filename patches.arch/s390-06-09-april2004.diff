- Description: dasd: RACE in state change interrupt handling.
  Symptom:     Data consistency problems and 'invalid status' message.
  Problem:     The state change handler was called via work queue.
               In rare cases the next request was started prior to the
               state change handling and the currently started request was reset
               to status queued by the handler.
  Solution:    Handle state changes directly in interrupt handler.
  Problem-ID:  9788
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/block/dasd.c	25 May 2004 13:37:59 -0000	1.137.2.5
+++ linux-2.5/drivers/s390/block/dasd.c	2 Jul 2004 13:43:46 -0000	1.137.2.6
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision: 1.137.2.5 $
+ * $Revision: 1.137.2.6 $
  */
 
 #include <linux/config.h>
@@ -826,41 +826,6 @@
 		del_timer(&device->timer);
 }
 
-/*
- *   Handles the state change pending interrupt.
- */
-static void
-do_state_change_pending(void *data)
-{
-	struct {
-		struct work_struct work;
-		struct dasd_device *device;
-	} *p;
-	struct dasd_device *device;
-	struct dasd_ccw_req *cqr;
-	struct list_head *l, *n;
-	unsigned long flags;
-
-	p = data;
-	device = p->device;
-	DBF_EVENT(DBF_NOTICE, "State change Interrupt for bus_id %s",
-		  device->cdev->dev.bus_id);
-	device->stopped &= ~DASD_STOPPED_PENDING;
-
-        /* restart all 'running' IO on queue */
-	spin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);
-	list_for_each_safe(l, n, &device->ccw_queue) {
-		cqr = list_entry(l, struct dasd_ccw_req, list);
-                if (cqr->status == DASD_CQR_IN_IO)
-                        cqr->status = DASD_CQR_QUEUED;
-        }
-	spin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);
-	dasd_set_timer (device, 0);
-	dasd_schedule_bh(device);
-	dasd_put_device(device);
-	kfree(p);
-}
-
 static void
 dasd_handle_killed_request(struct ccw_device *cdev, unsigned long intparm)
 {
@@ -896,19 +861,20 @@
 static void
 dasd_handle_state_change_pending(struct dasd_device *device)
 {
-	struct {
-		struct work_struct work;
-		struct dasd_device *device;
-	} *p;
-
-	p = kmalloc(sizeof(*p), GFP_ATOMIC);
-	if (p == NULL)
-		/* No memory, let the timeout do the reactivation. */
-		return;
-	INIT_WORK(&p->work, (void *) do_state_change_pending, p);
-	p->device = device;
-	dasd_get_device(device);
-	schedule_work(&p->work);
+	struct dasd_ccw_req *cqr;
+	struct list_head *l, *n;
+
+	device->stopped &= ~DASD_STOPPED_PENDING;
+
+        /* restart all 'running' IO on queue */
+	list_for_each_safe(l, n, &device->ccw_queue) {
+		cqr = list_entry(l, struct dasd_ccw_req, list);
+                if (cqr->status == DASD_CQR_IN_IO) {
+                        cqr->status = DASD_CQR_QUEUED;
+		}
+        }
+	dasd_clear_timer(device);
+	dasd_schedule_bh(device);
 }
 
 /*

