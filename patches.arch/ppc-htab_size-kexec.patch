From: Michael Ellerman <michael@ellerman.id.au>
Subject: [PATCH] powerpc: Only calculate htab_size in one place for kexec

For kexec we need to know the size of the htab.

Currently we calculate the size once in the htab code, and then twice more in
the kexec code, once using htab_hash_mask and once using ppc64_pft_size.
On some machines the ppc64_pft_size calculation is broken because
ppc64_pft_size is not set.

So we need to fix the second calculation, but better still we should just
calculate the size once and use it everywhere else.

Tested on Power5 LPAR, Power4 non-LPAR and Power3.

Kexec is broken on some non-LPAR machines without this, so I think it should
go upstream for 2.6.16.

Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
Signed-off-by: Olaf Hering <olh@suse.de>
---

 arch/powerpc/kernel/machine_kexec_64.c |   10 +++-------
 arch/powerpc/mm/hash_utils_64.c        |    3 ++-
 include/asm-powerpc/mmu.h              |    1 +
 3 files changed, 6 insertions(+), 8 deletions(-)

Index: to-merge/arch/powerpc/kernel/machine_kexec_64.c
===================================================================
--- to-merge.orig/arch/powerpc/kernel/machine_kexec_64.c
+++ to-merge/arch/powerpc/kernel/machine_kexec_64.c
@@ -26,8 +26,6 @@
 #include <asm/prom.h>
 #include <asm/smp.h>
 
-#define HASH_GROUP_SIZE 0x80	/* size of each hash group, asm/mmu.h */
-
 int default_machine_kexec_prepare(struct kimage *image)
 {
 	int i;
@@ -61,7 +59,7 @@ int default_machine_kexec_prepare(struct
 	 */
 	if (htab_address) {
 		low = __pa(htab_address);
-		high = low + (htab_hash_mask + 1) * HASH_GROUP_SIZE;
+		high = low + htab_size_bytes;
 
 		for (i = 0; i < image->nr_segments; i++) {
 			begin = image->segment[i].mem;
@@ -294,7 +292,7 @@ void default_machine_kexec(struct kimage
 }
 
 /* Values we need to export to the second kernel via the device tree. */
-static unsigned long htab_base, htab_size, kernel_end;
+static unsigned long htab_base, kernel_end;
 
 static struct property htab_base_prop = {
 	.name = "linux,htab-base",
@@ -305,7 +303,7 @@ static struct property htab_base_prop = 
 static struct property htab_size_prop = {
 	.name = "linux,htab-size",
 	.length = sizeof(unsigned long),
-	.value = (unsigned char *)&htab_size,
+	.value = (unsigned char *)&htab_size_bytes,
 };
 
 static struct property kernel_end_prop = {
@@ -331,8 +329,6 @@ static void __init export_htab_values(vo
 
 	htab_base = __pa(htab_address);
 	prom_add_property(node, &htab_base_prop);
-
-	htab_size = 1UL << ppc64_pft_size;
 	prom_add_property(node, &htab_size_prop);
 
  out:
Index: to-merge/arch/powerpc/mm/hash_utils_64.c
===================================================================
--- to-merge.orig/arch/powerpc/mm/hash_utils_64.c
+++ to-merge/arch/powerpc/mm/hash_utils_64.c
@@ -88,6 +88,7 @@ static unsigned long _SDR1;
 struct mmu_psize_def mmu_psize_defs[MMU_PAGE_COUNT];
 
 hpte_t *htab_address;
+unsigned long htab_size_bytes;
 unsigned long htab_hash_mask;
 int mmu_linear_psize = MMU_PAGE_4K;
 int mmu_virtual_psize = MMU_PAGE_4K;
@@ -399,7 +400,7 @@ void create_section_mapping(unsigned lon
 
 void __init htab_initialize(void)
 {
-	unsigned long table, htab_size_bytes;
+	unsigned long table;
 	unsigned long pteg_count;
 	unsigned long mode_rw;
 	unsigned long base = 0, size = 0;
Index: to-merge/include/asm-powerpc/mmu.h
===================================================================
--- to-merge.orig/include/asm-powerpc/mmu.h
+++ to-merge/include/asm-powerpc/mmu.h
@@ -112,6 +112,7 @@ typedef struct {
 } hpte_t;
 
 extern hpte_t *htab_address;
+extern unsigned long htab_size_bytes;
 extern unsigned long htab_hash_mask;
 
 /*
_______________________________________________
Linuxppc64-dev mailing list
Linuxppc64-dev@ozlabs.org
https://ozlabs.org/mailman/listinfo/linuxppc64-dev

