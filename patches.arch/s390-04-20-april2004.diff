- Description: z90crypt: Backport several changes to service stream for 2.6
  Symptom:     domain=xx parameter ignored in certain situations
  Problem:     incorrect checking in probe_crypto_domain
  Solution:    remove unneeded check
               Unrelated, but useful changes that went in:
               - reformat code (indenting and #defines primarily), to make
               maintenance easier
               - changed the names of a couple fields in structs for correctness
               - change name from "zLinux" to "zSeries Linux" to match the legal
               requirements
               - make hotplug function static to prevent kernel namespace usage
               - use __user hints for sparse
  Problem-ID:  9373
  Archs:       s390-31, s390-64

--- linux-2.5/drivers/s390/crypto/z90main.c	18 May 2004 16:21:07 -0000	1.31.2.1
+++ linux-2.5/drivers/s390/crypto/z90main.c	16 Jun 2004 19:45:12 -0000	1.31.2.2
@@ -5,7 +5,7 @@
  *
  *  Copyright (C)  2001, 2004 IBM Corporation
  *  Author(s): Robert Burroughs (burrough@us.ibm.com)
- *	       Eric Rossman (edrossma@us.ibm.com)
+ *             Eric Rossman (edrossma@us.ibm.com)
  *
  *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
  *
@@ -16,7 +16,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -50,7 +50,7 @@
 #  error "This kernel is too recent: not supported by this file"
 #endif
 
-#define VERSION_Z90MAIN_C "$Revision: 1.31.2.1 $"
+#define VERSION_Z90MAIN_C "$Revision: 1.31.2.2 $"
 
 static char z90cmain_version[] __initdata =
 	"z90main.o (" VERSION_Z90MAIN_C "/"
@@ -215,18 +215,13 @@
 #ifndef Z90CRYPT_NUM_DEVS
 #define Z90CRYPT_NUM_DEVS Z90CRYPT_NUM_APS
 #endif
-#ifndef Z90CRYPT_NUM_TYPES
-#define Z90CRYPT_NUM_TYPES 3
-#endif
 
 /**
  * Buffer size for receiving responses. The maximum Response Size
  * is actually the maximum request size, since in an error condition
  * the request itself may be returned unchanged.
  */
-#ifndef MAX_RESPONSE_SIZE
 #define MAX_RESPONSE_SIZE 0x0000077C
-#endif
 
 /**
  * A count and status-byte mask
@@ -252,7 +247,7 @@
  * All devices are arranged in a single array: 64 APs
  */
 struct device {
-	int		 dev_type;	    // PCICA, PCICC, or PCIXCC
+	int		 dev_type;	    // PCICA, PCICC, PCIXCC
 	enum devstat	 dev_stat;	    // current device status
 	int		 dev_self_x;	    // Index in array
 	int		 disabled;	    // Set when device is in error
@@ -367,7 +362,7 @@
 	int		  buff_size;	  // size of the buffer for the request
 	char		  resp_buff[RESPBUFFSIZE];
 	int		  resp_buff_size;
-	char *		  resp_addr;	  // address of response in user space
+	char __user *	  resp_addr;	  // address of response in user space
 	unsigned int	  funccode;	  // function code of request
 	wait_queue_head_t waitq;
 	unsigned long	  requestsent;	  // time at which the request was sent
@@ -384,8 +379,9 @@
  */
 static int z90crypt_open(struct inode *, struct file *);
 static int z90crypt_release(struct inode *, struct file *);
-static ssize_t z90crypt_read(struct file *, char *, size_t, loff_t *);
-static ssize_t z90crypt_write(struct file *, const char *, size_t, loff_t *);
+static ssize_t z90crypt_read(struct file *, char __user *, size_t, loff_t *);
+static ssize_t z90crypt_write(struct file *, const char __user *,
+							size_t, loff_t *);
 static int z90crypt_ioctl(struct inode *, struct file *,
 			  unsigned int, unsigned long);
 
@@ -395,7 +391,7 @@
 static void z90crypt_cleanup_task(unsigned long);
 
 static int z90crypt_status(char *, char **, off_t, int, int *, void *);
-static int z90crypt_status_write(struct file *, const char *,
+static int z90crypt_status_write(struct file *, const char __user *,
 				 unsigned long, void *);
 
 /**
@@ -454,9 +450,9 @@
 /**
  * Documentation values.
  */
-MODULE_AUTHOR("zLinux Crypto Team: Robert H. Burroughs, Eric D. Rossman"
+MODULE_AUTHOR("zSeries Linux Crypto Team: Robert H. Burroughs, Eric D. Rossman"
 	      "and Jochen Roehrig");
-MODULE_DESCRIPTION("zLinux Cryptographic Coprocessor device driver, "
+MODULE_DESCRIPTION("zSeries Linux Cryptographic Coprocessor device driver, "
 		   "Copyright 2001, 2004 IBM Corporation");
 MODULE_LICENSE("GPL");
 module_param(domain, int, 0);
@@ -479,9 +475,9 @@
 trans_modexpo32(unsigned int fd, unsigned int cmd, unsigned long arg,
 		struct file *file)
 {
-	struct ica_rsa_modexpo_32 *mex32u = compat_ptr(arg);
+	struct ica_rsa_modexpo_32 __user *mex32u = compat_ptr(arg);
 	struct ica_rsa_modexpo_32  mex32k;
-	struct ica_rsa_modexpo    *mex64;
+	struct ica_rsa_modexpo __user *mex64;
 	int ret = 0;
 	unsigned int i;
 
@@ -523,9 +519,9 @@
 trans_modexpo_crt32(unsigned int fd, unsigned int cmd, unsigned long arg,
 		    struct file *file)
 {
-	struct ica_rsa_modexpo_crt_32 *crt32u = compat_ptr(arg);
+	struct ica_rsa_modexpo_crt_32 __user *crt32u = compat_ptr(arg);
 	struct ica_rsa_modexpo_crt_32  crt32k;
-	struct ica_rsa_modexpo_crt    *crt64;
+	struct ica_rsa_modexpo_crt __user *crt64;
 	int ret = 0;
 	unsigned int i;
 
@@ -587,7 +583,7 @@
 		return result;
 
 	for(i = 0; i < ARRAY_SIZE(compatible_ioctls); i++) {
-		result = register_ioctl32_conversion(compatible_ioctls[i],NULL);
+		result = register_ioctl32_conversion(compatible_ioctls[i], 0);
 		if (result) {
 			z90_unregister_ioctl32s();
 			return result;
@@ -847,7 +843,7 @@
  * z90crypt_read will not be supported beyond z90crypt 1.3.1
  */
 static ssize_t
-z90crypt_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+z90crypt_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
 {
 	PDEBUG("filp %p (PID %d)\n", filp, PID());
 	return -EPERM;
@@ -860,7 +856,7 @@
  */
 #include <linux/random.h>
 static ssize_t
-z90crypt_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+z90crypt_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
 {
 	unsigned char *temp_buff;
 
@@ -898,7 +894,7 @@
  * Write is is not allowed
  */
 static ssize_t
-z90crypt_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos)
+z90crypt_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
 {
 	PDEBUG("filp %p (PID %d)\n", filp, PID());
 	return -EPERM;
@@ -1045,7 +1041,7 @@
 static inline void
 remove_device(struct device *device_p)
 {
-	if (!device_p || device_p->disabled != 0)
+	if (!device_p || (device_p->disabled != 0))
 		return;
 	device_p->disabled = 1;
 	z90crypt.hdware_info->type_mask[device_p->dev_type].disabled_count++;
@@ -1062,25 +1058,28 @@
 	if (*dev_type_p != ANYDEV) {
 		stat = &z90crypt.hdware_info->type_mask[*dev_type_p];
 		if (stat->st_count >
-		    stat->disabled_count + stat->user_disabled_count)
+		    (stat->disabled_count + stat->user_disabled_count))
 			return 0;
 		return -1;
 	}
 
 	stat = &z90crypt.hdware_info->type_mask[PCICA];
-	if (stat->st_count > stat->disabled_count + stat->user_disabled_count) {
+	if (stat->st_count >
+	    (stat->disabled_count + stat->user_disabled_count)) {
 		*dev_type_p = PCICA;
 		return 0;
 	}
 
 	stat = &z90crypt.hdware_info->type_mask[PCIXCC];
-	if (stat->st_count > stat->disabled_count + stat->user_disabled_count) {
+	if (stat->st_count >
+	    (stat->disabled_count + stat->user_disabled_count)) {
 		*dev_type_p = PCIXCC;
 		return 0;
 	}
 
 	stat = &z90crypt.hdware_info->type_mask[PCICC];
-	if (stat->st_count > stat->disabled_count + stat->user_disabled_count) {
+	if (stat->st_count >
+	    (stat->disabled_count + stat->user_disabled_count)) {
 		*dev_type_p = PCICC;
 		return 0;
 	}
@@ -1104,9 +1103,9 @@
 		dev_ptr = z90crypt.device_p[*device_nr_p];
 
 		if (dev_ptr &&
-		    dev_ptr->dev_stat != DEV_GONE &&
-		    dev_ptr->disabled == 0 &&
-		    dev_ptr->user_disabled == 0) {
+		    (dev_ptr->dev_stat != DEV_GONE) &&
+		    (dev_ptr->disabled == 0) &&
+		    (dev_ptr->user_disabled == 0)) {
 			PDEBUG("selected by number, index = %d\n",
 			       *device_nr_p);
 			*dev_type_p = dev_ptr->dev_type;
@@ -1128,11 +1127,11 @@
 		indx = index_p->device_index[i];
 		dev_ptr = z90crypt.device_p[indx];
 		if (dev_ptr &&
-		    dev_ptr->dev_stat != DEV_GONE &&
-		    dev_ptr->disabled == 0 &&
-		    dev_ptr->user_disabled == 0 &&
-		    devTp == dev_ptr->dev_type &&
-		    low_count > dev_ptr->dev_caller_count) {
+		    (dev_ptr->dev_stat != DEV_GONE) &&
+		    (dev_ptr->disabled == 0) &&
+		    (dev_ptr->user_disabled == 0) &&
+		    (devTp == dev_ptr->dev_type) &&
+		    (low_count > dev_ptr->dev_caller_count)) {
 			low_count = dev_ptr->dev_caller_count;
 			low_indx = indx;
 		}
@@ -1264,7 +1263,7 @@
  * process_results copies the user's work from kernel space.
  */
 static inline int
-z90crypt_process_results(struct work_element *we_p, char *buf)
+z90crypt_process_results(struct work_element *we_p, char __user *buf)
 {
 	int rv;
 
@@ -1561,7 +1560,7 @@
 
 static inline int
 z90crypt_prepare(struct work_element *we_p, unsigned int funccode,
-		 const char *buffer)
+		 const char __user *buffer)
 {
 	int rv;
 
@@ -1646,7 +1645,7 @@
 		PDEBUG("PID %d: allocate_work_element returned ENOMEM\n", pid);
 		return rv;
 	}
-	if ((rv = z90crypt_prepare(we_p, cmd, (const char *)arg)))
+	if ((rv = z90crypt_prepare(we_p, cmd, (const char __user *)arg)))
 		PDEBUG("PID %d: rv = %d from z90crypt_prepare\n", pid, rv);
 	if (!rv)
 		if ((rv = z90crypt_send(we_p, (const char *)arg)))
@@ -1658,7 +1657,7 @@
 		rv = we_p->retcode;
 	}
 	if (!rv)
-		rv = z90crypt_process_results(we_p, (char *)arg);
+		rv = z90crypt_process_results(we_p, (char __user *)arg);
 
 	if ((we_p->status[0] & STAT_FAILED)) {
 		switch (rv) {
@@ -1753,49 +1752,49 @@
 
 	case Z90STAT_TOTALCOUNT:
 		tempstat = get_status_totalcount();
-		if (copy_to_user((int *)arg, &tempstat,sizeof(int)) != 0)
+		if (copy_to_user((int __user *)arg, &tempstat,sizeof(int)) != 0)
 			ret = -EFAULT;
 		break;
 
 	case Z90STAT_PCICACOUNT:
 		tempstat = get_status_PCICAcount();
-		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+		if (copy_to_user((int __user *)arg, &tempstat, sizeof(int)) != 0)
 			ret = -EFAULT;
 		break;
 
 	case Z90STAT_PCICCCOUNT:
 		tempstat = get_status_PCICCcount();
-		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+		if (copy_to_user((int __user *)arg, &tempstat, sizeof(int)) != 0)
 			ret = -EFAULT;
 		break;
 
 	case Z90STAT_PCIXCCCOUNT:
 		tempstat = get_status_PCIXCCcount();
-		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+		if (copy_to_user((int __user *)arg, &tempstat, sizeof(int)) != 0)
 			ret = -EFAULT;
 		break;
 
 	case Z90STAT_REQUESTQ_COUNT:
 		tempstat = get_status_requestq_count();
-		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+		if (copy_to_user((int __user *)arg, &tempstat, sizeof(int)) != 0)
 			ret = -EFAULT;
 		break;
 
 	case Z90STAT_PENDINGQ_COUNT:
 		tempstat = get_status_pendingq_count();
-		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+		if (copy_to_user((int __user *)arg, &tempstat, sizeof(int)) != 0)
 			ret = -EFAULT;
 		break;
 
 	case Z90STAT_TOTALOPEN_COUNT:
 		tempstat = get_status_totalopen_count();
-		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+		if (copy_to_user((int __user *)arg, &tempstat, sizeof(int)) != 0)
 			ret = -EFAULT;
 		break;
 
 	case Z90STAT_DOMAIN_INDEX:
 		tempstat = get_status_domain_index();
-		if (copy_to_user((int *)arg, &tempstat, sizeof(int)) != 0)
+		if (copy_to_user((int __user *)arg, &tempstat, sizeof(int)) != 0)
 			ret = -EFAULT;
 		break;
 
@@ -1807,7 +1806,8 @@
 			break;
 		}
 		get_status_status_mask(status);
-		if (copy_to_user((char *) arg, status, Z90CRYPT_NUM_APS) != 0)
+		if (copy_to_user((char __user *) arg, status, Z90CRYPT_NUM_APS)
+									!= 0)
 			ret = -EFAULT;
 		kfree(status);
 		break;
@@ -1820,7 +1820,7 @@
 			break;
 		}
 		get_status_qdepth_mask(qdepth);
-		if (copy_to_user((char *) arg, qdepth, Z90CRYPT_NUM_APS) != 0)
+		if (copy_to_user((char __user *) arg, qdepth, Z90CRYPT_NUM_APS) != 0)
 			ret = -EFAULT;
 		kfree(qdepth);
 		break;
@@ -1833,7 +1833,7 @@
 			break;
 		}
 		get_status_perdevice_reqcnt(reqcnt);
-		if (copy_to_user((char *) arg, reqcnt,
+		if (copy_to_user((char __user *) arg, reqcnt,
 				 Z90CRYPT_NUM_APS * sizeof(int)) != 0)
 			ret = -EFAULT;
 		kfree(reqcnt);
@@ -1841,10 +1841,10 @@
 
 		/* THIS IS DEPRECATED.	USE THE NEW STATUS CALLS */
 	case ICAZ90STATUS:
-		if (deprecated_msg_count < 100) {
+		if (deprecated_msg_count < 20) {
 			PRINTK("deprecated call to ioctl (ICAZ90STATUS)!\n");
 			deprecated_msg_count++;
-			if (deprecated_msg_count == 100)
+			if (deprecated_msg_count == 20)
 				PRINTK("No longer issuing messages related to "
 				       "deprecated call to ICAZ90STATUS.\n");
 		}
@@ -1866,7 +1866,7 @@
 		get_status_status_mask(pstat->status);
 		get_status_qdepth_mask(pstat->qdepth);
 
-		if (copy_to_user((struct ica_z90_status *) arg, pstat,
+		if (copy_to_user((struct ica_z90_status __user *) arg, pstat,
 				 sizeof(struct ica_z90_status)) != 0)
 			ret = -EFAULT;
 		kfree(pstat);
@@ -2109,7 +2109,7 @@
 }
 
 static int
-z90crypt_status_write(struct file *file, const char *buffer,
+z90crypt_status_write(struct file *file, const char __user *buffer,
 		      unsigned long count, void *data)
 {
 	int i, j, len, offs, found, eof;
@@ -2214,7 +2214,7 @@
  */
 static inline int
 receive_from_crypto_device(int index, unsigned char *psmid, int *buff_len_p,
-			   unsigned char *buff, unsigned char **dest_p_p)
+			   unsigned char *buff, unsigned char __user **dest_p_p)
 {
 	int dv, rv;
 	struct device *dev_ptr;
@@ -2405,7 +2405,7 @@
 static inline void
 helper_handle_work_element(int index, unsigned char psmid[8], int rc,
 			   int buff_len, unsigned char *buff,
-			   unsigned char *resp_addr)
+			   unsigned char __user *resp_addr)
 {
 	struct work_element *pq_p;
 	struct list_head *lptr, *tptr;
@@ -2510,7 +2510,8 @@
 z90crypt_reader_task(unsigned long ptr)
 {
 	int workavail, index, rc, buff_len;
-	unsigned char	psmid[8], *resp_addr;
+	unsigned char	psmid[8];
+	unsigned char __user *resp_addr;
 	static unsigned char buff[1024];
 
 	/**
@@ -2804,7 +2805,7 @@
 	}
 
 	if (k == 1) {
-		if ((*cdx_p == -1) || !z90crypt.domain_established) {
+		if (*cdx_p == -1) {
 			*cdx_p = cdx_array[0];
 			return 0;
 		}
@@ -3101,7 +3102,7 @@
 	memset((void *)&z90crypt, 0, sizeof(z90crypt));
 }
 
-static unsigned char static_testmsg[] = {
+static unsigned char static_testmsg[384] = {
 0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x00,0x06,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x43,0x43,
@@ -3133,7 +3134,7 @@
 {
 	int rv, dv, i, index, length;
 	unsigned char psmid[8];
-	static unsigned char loc_testmsg[384];
+	static unsigned char loc_testmsg[sizeof(static_testmsg)];
 
 	index = devPtr->dev_self_x;
 	rv = 0;
@@ -3228,7 +3229,7 @@
 }
 
 #ifdef Z90CRYPT_USE_HOTPLUG
-void
+static void
 z90crypt_hotplug_event(int dev_major, int dev_minor, int action)
 {
 #ifdef CONFIG_HOTPLUG

--- linux-2.5/drivers/s390/crypto/z90crypt.h	13 Feb 2004 18:41:01 -0000	1.2
+++ linux-2.5/drivers/s390/crypto/z90crypt.h	16 Jun 2004 19:45:12 -0000	1.2.2.1
@@ -5,7 +5,7 @@
  *
  *  Copyright (C)  2001, 2004 IBM Corporation
  *  Author(s): Robert Burroughs (burrough@us.ibm.com)
- *	       Eric Rossman (edrossma@us.ibm.com)
+ *             Eric Rossman (edrossma@us.ibm.com)
  *
  *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
  *
@@ -16,7 +16,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -29,7 +29,7 @@
 
 #include <linux/ioctl.h>
 
-#define VERSION_Z90CRYPT_H "$Revision: 1.2 $"
+#define VERSION_Z90CRYPT_H "$Revision: 1.2.2.1 $"
 
 #define z90crypt_VERSION 1
 #define z90crypt_RELEASE 3	// 2 = PCIXCC, 3 = rewrite for coding standards
@@ -46,12 +46,12 @@
  * - length(n_modulus) = inputdatalength
  */
 struct ica_rsa_modexpo {
-	char *		inputdata;
+	char __user *	inputdata;
 	unsigned int	inputdatalength;
-	char *		outputdata;
+	char __user *	outputdata;
 	unsigned int	outputdatalength;
-	char *		b_key;
-	char *		n_modulus;
+	char __user *	b_key;
+	char __user *	n_modulus;
 };
 
 /**
@@ -69,15 +69,15 @@
  * - length(u_mult_inv) = inputdatalength/2 + 8
  */
 struct ica_rsa_modexpo_crt {
-	char *		inputdata;
+	char __user *	inputdata;
 	unsigned int	inputdatalength;
-	char *		outputdata;
+	char __user *	outputdata;
 	unsigned int	outputdatalength;
-	char *		bp_key;
-	char *		bq_key;
-	char *		np_prime;
-	char *		nq_prime;
-	char *		u_mult_inv;
+	char __user *	bp_key;
+	char __user *	bq_key;
+	char __user *	np_prime;
+	char __user *	nq_prime;
+	char __user *	u_mult_inv;
 };
 
 #define Z90_IOCTL_MAGIC 'z'  // NOTE:  Need to allocate from linux folks
@@ -93,16 +93,16 @@
  *     This takes an ica_rsa_modexpo struct as its arg.
  *
  *     NOTE: please refer to the comments preceding this structure
- *	     for the implementation details for the contents of the
- *	     block
+ *           for the implementation details for the contents of the
+ *           block
  *
  *   ICARSACRT
  *     Perform an RSA operation using a Chinese-Remainder Theorem key
  *     This takes an ica_rsa_modexpo_crt struct as its arg.
  *
  *     NOTE: please refer to the comments preceding this structure
- *	     for the implementation details for the contents of the
- *	     block
+ *           for the implementation details for the contents of the
+ *           block
  *
  *   Z90STAT_TOTALCOUNT
  *     Return an integer count of all device types together.
@@ -133,10 +133,10 @@
  *   Z90STAT_STATUS_MASK
  *     Return an 64 element array of unsigned chars for the status of
  *     all devices.
- *	 0x01: PCICA
- *	 0x02: PCICC
- *	 0x03: PCIXCC
- *	 0x0d: device is disabled via the proc filesystem
+ *       0x01: PCICA
+ *       0x02: PCICC
+ *       0x03: PCIXCC
+ *       0x0d: device is disabled via the proc filesystem
  *
  *   Z90STAT_QDEPTH_MASK
  *     Return an 64 element array of unsigned chars for the queue
@@ -152,18 +152,18 @@
  *     This takes an ica_z90_status struct as its arg.
  *
  *     NOTE: this ioctl() is deprecated, and has been replaced with
- *	     single ioctl()s for each type of status being requested
+ *           single ioctl()s for each type of status being requested
  *
  *   Z90QUIESCE (not recommended)
  *     Quiesce the driver.  This is intended to stop all new
- *     requests from being processed.  Its use is not recommended,
+ *     requests from being processed.  Its use is NOT recommended,
  *     except in circumstances where there is no other way to stop
  *     callers from accessing the driver.  Its original use was to
  *     allow the driver to be "drained" of work in preparation for
  *     a system shutdown.
  *
  *     NOTE: once issued, this ban on new work cannot be undone
- *	     except by unloading and reloading the driver.
+ *           except by unloading and reloading the driver.
  */
 
 /**
@@ -172,7 +172,7 @@
 #define ICARSAMODEXPO	_IOC(_IOC_READ|_IOC_WRITE, Z90_IOCTL_MAGIC, 0x05, 0)
 #define ICARSACRT	_IOC(_IOC_READ|_IOC_WRITE, Z90_IOCTL_MAGIC, 0x06, 0)
 
-/* DEPRECATED status call (bound for removal SOON) */
+/* DEPRECATED status calls (bound for removal at some point) */
 #define ICAZ90STATUS	_IOR(Z90_IOCTL_MAGIC, 0x10, struct ica_z90_status)
 
 /* unrelated to ICA callers */
@@ -199,8 +199,9 @@
 #define ERELEASED 131	// user released while ioctl pending
 #define EQUIESCE  132	// z90crypt quiescing (no more work allowed)
 #define ETIMEOUT  133	// request timed out
-#define EUNKNOWN  134	// some unrecognized error occured
-#define EGETBUFF  135	// Error getting buffer
+#define EUNKNOWN  134	// some unrecognized error occured (retry may succeed)
+#define EGETBUFF  135	// Error getting buffer or hardware lacks capability
+			// (retry in software)
 
 /**
  * DEPRECATED STRUCTURES
@@ -222,7 +223,7 @@
 	int pendingqWaitCount;
 	int totalOpenCount;
 	int cryptoDomain;
-	// status: 0=not there. 1=PCICA. 2=PCICC. 3=PCIXCC
+	// status: 0=not there, 1=PCICA, 2=PCICC, 3=PCIXCC
 	unsigned char status[MASK_LENGTH];
 	// qdepth: # work elements waiting for each device
 	unsigned char qdepth[MASK_LENGTH];

diff -ruN linux-2.6.5/drivers/s390/crypto/z90common.h linux-2.5/drivers/s390/crypto/z90common.h
--- linux-2.6.5/drivers/s390/crypto/z90common.h	Mon Jun 21 14:11:21 2004
+++ linux-2.5/drivers/s390/crypto/z90common.h	Mon Jun 21 14:13:08 2004
@@ -5,7 +5,7 @@
  *
  *  Copyright (C)  2001, 2004 IBM Corporation
  *  Author(s): Robert Burroughs (burrough@us.ibm.com)
- *	       Eric Rossman (edrossma@us.ibm.com)
+ *             Eric Rossman (edrossma@us.ibm.com)
  *
  *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
  *
@@ -16,7 +16,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -27,7 +27,7 @@
 #ifndef _Z90COMMON_
 #define _Z90COMMON_
 
-#define VERSION_Z90COMMON_H "$Revision: 1.8 $"
+#define VERSION_Z90COMMON_H "$Revision: 1.8.2.1 $"
 
 
 #define RESPBUFFSIZE 256
@@ -89,18 +89,52 @@
 #define TSQ_FATAL_ERROR 34
 #define RSQ_FATAL_ERROR 35
 
-#define PCICA	0
-#define PCICC	1
-#define PCIXCC	2
-#define NILDEV	-1
-#define ANYDEV	-1
+#define Z90CRYPT_NUM_TYPES	3
+#define PCICA		0
+#define PCICC		1
+#define PCIXCC		2
+#define NILDEV		-1
+#define ANYDEV		-1
 
 enum hdevice_type {
 	PCICC_HW  = 3,
 	PCICA_HW  = 4,
 	PCIXCC_HW = 5,
 	OTHER_HW  = 6,	
-	OTHER2_HW = 7	
+	OTHER2_HW  = 7	
+};
+
+struct CPRBX {
+	unsigned short cprb_len;	
+	unsigned char  cprb_ver_id;	
+	unsigned char  pad_000[3];	
+	unsigned char  func_id[2];	
+	unsigned char  cprb_flags[4];	
+	unsigned int   req_parml;	
+	unsigned int   req_datal;	
+	unsigned int   rpl_msgbl;	
+	unsigned int   rpld_parml;	
+	unsigned int   rpl_datal;	
+	unsigned int   rpld_datal;	
+	unsigned int   req_extbl;	
+	unsigned char  pad_001[4];	
+	unsigned int   rpld_extbl;	
+	unsigned char  req_parmb[16];	
+	unsigned char  req_datab[16];	
+	unsigned char  rpl_parmb[16];	
+	unsigned char  rpl_datab[16];	
+	unsigned char  req_extb[16];	
+	unsigned char  rpl_extb[16];	
+	unsigned short ccp_rtcode;	
+	unsigned short ccp_rscode;	
+	unsigned int   mac_data_len;	
+	unsigned char  logon_id[8];	
+	unsigned char  mac_value[8];	
+	unsigned char  mac_content_flgs;
+	unsigned char  pad_002;		
+	unsigned short domain;		
+	unsigned char  pad_003[12];	
+	unsigned char  pad_004[36];	
 };
 
 #ifndef DEV_NAME

diff -ruN linux-2.6.5/drivers/s390/crypto/z90hardware.c linux-2.5/drivers/s390/crypto/z90hardware.c
--- linux-2.6.5/drivers/s390/crypto/z90hardware.c	Mon Jun 21 14:11:21 2004
+++ linux-2.5/drivers/s390/crypto/z90hardware.c	Mon Jun 21 14:13:08 2004
@@ -5,7 +5,7 @@
  *
  *  Copyright (C)  2001, 2004 IBM Corporation
  *  Author(s): Robert Burroughs (burrough@us.ibm.com)
- *	       Eric Rossman (edrossma@us.ibm.com)
+ *             Eric Rossman (edrossma@us.ibm.com)
  *
  *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
  *
@@ -16,7 +16,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -32,7 +32,7 @@
 #include "z90crypt.h"
 #include "z90common.h"
 
-#define VERSION_Z90HARDWARE_C "$Revision: 1.19 $"
+#define VERSION_Z90HARDWARE_C "$Revision: 1.19.2.2 $"
 
 char z90chardware_version[] __initdata =
 	"z90hardware.o (" VERSION_Z90HARDWARE_C "/"
@@ -224,7 +224,7 @@
 	unsigned char right[4];		
 	unsigned char reserved3[2];	
 	unsigned char reserved4[2];	
-	unsigned char pfs[4];		
+	unsigned char apfs[4];		
 	unsigned int  offset1;		
 	unsigned int  offset2;		
 	unsigned int  offset3;		
@@ -278,39 +278,6 @@
 	unsigned char svr_name[8];	
 };
 
-struct CPRBX {
-	unsigned short cprb_len;	
-	unsigned char  cprb_ver_id;	
-	unsigned char  pad_000[3];	
-	unsigned char  func_id[2];	
-	unsigned char  cprb_flags[4];	
-	unsigned int   req_parml;	
-	unsigned int   req_datal;	
-	unsigned int   rpl_msgbl;	
-	unsigned int   rpld_parml;	
-	unsigned int   rpl_datal;	
-	unsigned int   rpld_datal;	
-	unsigned int   req_extbl;	
-	unsigned char  pad_001[4];	
-	unsigned int   rpld_extbl;	
-	unsigned char  req_parmb[16];	
-	unsigned char  req_datab[16];	
-	unsigned char  rpl_parmb[16];	
-	unsigned char  rpl_datab[16];	
-	unsigned char  req_extb[16];	
-	unsigned char  rpl_extb[16];	
-	unsigned short ccp_rtcode;	
-	unsigned short ccp_rscode;	
-	unsigned int   mac_data_len;	
-	unsigned char  logon_id[8];	
-	unsigned char  mac_value[8];	
-	unsigned char  mac_content_flgs;
-	unsigned char  pad_002;		
-	unsigned short domain;		
-	unsigned char  pad_003[12];	
-	unsigned char  pad_004[36];	
-};
-
 struct type6_msg {
 	struct type6_hdr header;
 	struct CPRB	 CPRB;
@@ -379,7 +346,7 @@
 	unsigned int	  offset2;	
 	unsigned int	  count3;	
 	unsigned int	  offset3;	
-	unsigned int	  ount4;	
+	unsigned int	  count4;	
 	unsigned int	  offset4;	
 };
 
@@ -701,11 +668,9 @@
 
 #define FIXED_TYPE6_CR_LENX 0x000001E3
 
-#ifndef MAX_RESPONSE_SIZE
 #define MAX_RESPONSE_SIZE 0x00000710
 
 #define MAX_RESPONSEX_SIZE 0x0000077C
-#endif
 
 #define RESPONSE_CPRB_SIZE  0x000006B8 
 #define RESPONSE_CPRBX_SIZE 0x00000724 
@@ -1170,18 +1135,11 @@
 			switch (stat_word.response_code) {
 			case AP_RESPONSE_NORMAL:
 				stat = DEV_ONLINE;
-				if (stat_word.q_stat_flags &
-				    AP_Q_STATUS_EMPTY)
+				if (stat_word.q_stat_flags & AP_Q_STATUS_EMPTY)
 					break_out = 1;
 				break;
 			case AP_RESPONSE_Q_NOT_AVAIL:
-				stat = DEV_GONE;
-				break_out = 1;
-				break;
 			case AP_RESPONSE_DECONFIGURED:
-				stat = DEV_GONE;
-				break_out = 1;
-				break;
 			case AP_RESPONSE_CHECKSTOPPED:
 				stat = DEV_GONE;
 				break_out = 1;
@@ -1251,7 +1209,7 @@
 	       msg_ext[0], msg_ext[1], msg_ext[2], msg_ext[3],
 	       msg_ext[4], msg_ext[5], msg_ext[6], msg_ext[7],
 	       msg_ext[8], msg_ext[9], msg_ext[10], msg_ext[11]);
-	print_buffer(msg_ext+12, msg_len);
+	print_buffer(msg_ext+CALLER_HEADER, msg_len);
 #endif
 
 	ccode = sen(msg_len, msg_ext, &stat_word);
@@ -1289,8 +1247,8 @@
 }
 
 enum devstat
-receive_from_AP(int dev_nr, int cdx, int resplen,
-		unsigned char *resp, unsigned char *psmid)
+receive_from_AP(int dev_nr, int cdx, int resplen, unsigned char *resp,
+		unsigned char *psmid)
 {
 	int ccode;
 	struct ap_status_word stat_word;
@@ -1543,6 +1501,7 @@
 	struct type6_hdr *tp6Hdr_p;
 	struct CPRB *cprb_p;
 	struct cca_private_ext_ME *key_p;
+	static int deprecated_msg_count = 0;
 
 	mod_len = icaMsg_p->inputdatalength;
 	tmp_size = FIXED_TYPE6_ME_LEN + mod_len;
@@ -1593,13 +1552,19 @@
 		return SEN_USER_ERROR;
 
 	if (is_common_public_key(temp, mod_len)) {
-		PRINTK("Common public key used for modex decrypt\n");
+		if (deprecated_msg_count < 20) {
+			PRINTK("Common public key used for modex decrypt\n");
+			deprecated_msg_count++;
+			if (deprecated_msg_count == 20)
+				PRINTK("No longer issuing messages about common"
+				       " public key for modex decrypt.\n");
+		}
 		return SEN_NOT_AVAIL;
 	}
 
 	temp = key_p->pvtMESec.modulus + sizeof(key_p->pvtMESec.modulus)
 	       - mod_len;
-	if (copy_from_user(temp, icaMsg_p->n_modulus, mod_len) != 0)
+	if (copy_from_user(temp, icaMsg_p->n_modulus, mod_len))
 		return SEN_RELEASED;
 	if (is_empty(temp, mod_len))
 		return SEN_USER_ERROR;
@@ -1669,7 +1634,7 @@
 		return SEN_RELEASED;
 	if (is_empty(temp, mod_len))
 		return SEN_USER_ERROR;
-	if (temp[0] != 0x00 || temp[1] != 0x02)
+	if ((temp[0] != 0x00) || (temp[1] != 0x02))
 		return SEN_NOT_AVAIL;
 	for (i = 2; i < mod_len; i++)
 		if (temp[i] == 0x00)
@@ -1697,7 +1662,7 @@
 	key_p->pubSec.modulus_bit_len = 8 * mod_len;
 	key_p->pubSec.modulus_byte_len = mod_len;
 	key_p->pubSec.exponent_len = exp_len;
-	key_p->pubSec.section_length = 12 + mod_len + exp_len;
+	key_p->pubSec.section_length = CALLER_HEADER + mod_len + exp_len;
 	key_len = key_p->pubSec.section_length + sizeof(struct cca_token_hdr);
 	key_p->pubHdr.token_length = key_len;
 	key_len += 4;
@@ -1893,7 +1858,7 @@
 	key_p->pubSec.modulus_bit_len = 8 * mod_len;
 	key_p->pubSec.modulus_byte_len = mod_len;
 	key_p->pubSec.exponent_len = exp_len;
-	key_p->pubSec.section_length = 12 + mod_len + exp_len;
+	key_p->pubSec.section_length = CALLER_HEADER + mod_len + exp_len;
 	key_len = key_p->pubSec.section_length + sizeof(struct cca_token_hdr);
 	key_p->pubHdr.token_length = key_len;
 	key_len += 4;
