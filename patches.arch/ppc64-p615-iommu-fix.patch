From: olh@suse.de
Subject: [PATCH] PPC64: p615 IOMMU fix

Uniform Multi-Platform E-IDE driver Revision: 7.00alpha2
ide: Assuming 33MHz system bus speed for PIO modes; override with idebus=xx
W82C105: IDE controller at PCI slot 0000:00:03.1
W82C105: chipset revision 5   
W82C105: 100% native mode on irq 102
    ide0: BM-DMA at 0xf040-0xf047<3> CPU: -- Error, unable to allocateW82C105 DMA table(s).
    ide1: BM-DMA at 0xf048-0xf04f<3> CPU: -- Error, unable to allocateW82C105 DMA table(s).
hda: HL-DT-ST CD-ROM GCR-8480B, ATAPI CD/DVD-ROM drive
Oops: Kernel access of bad area, sig: 11 [#1]
SMP NR_CPUS=128 NUMA PSERIES
Modules linked in:
NIP: C00000000028E248 XER: 00000000 LR: C000000000284E7C CTR: 0000000000000015
REGS: c0000000041e3620 TRAP: 0300   Not tainted  (2.6.11-rc2-pseries64)
MSR: 9000000000009032 EE: 1 PR: 0 FP: 0 ME: 1 IR/DR: 11 CR: 24004048
DAR: 0000000000000000 DSISR: 0000000040000000
TASK: c0000001fe7927f0[1] 'swapper' THREAD: c0000000041e0000 CPU: 0
GPR00: C000000000602B40 C0000000041E38A0 C000000000619990 C0000000006CB468
GPR04: 000000000000000C 0000000000000015 C0000000041E39E8 E00000000000F042
GPR08: 0000000000000001 0000000000000000 03000000A0000000 0000000000000000
GPR12: 000000003FD228A8 C000000000491C00 0000000000000000 0000000000000000
GPR16: 0000000000000000 0000000000000000 0000000003A10000 0000000003E3CA10
GPR20: 0000000003E3CA10 BFFFFFFFFC5F0000 0000000000000001 000000000000000C
GPR24: 0000000000000001 0000000000000044 C0000000006CB468 C0000000006CB358
GPR28: C0000000006CB468 0000000000000000 C00000000052F8F0 C0000000041E38A0
NIP [c00000000028e248] .ide_config_drive_speed+0x32c/0x6e0
LR [c000000000284e7c] .config_for_pio+0x1b8/0x240
Call Trace:
[c0000000041e38a0] [0000000040000000] .__start+0x4000000040000000/0x8 (unreliable)
[c0000000041e3970] [c000000000284e7c] .config_for_pio+0x1b8/0x240
[c0000000041e3a30] [c000000000284fb4] .tune_sl82c105+0x2c/0x54
[c0000000041e3ac0] [c0000000002926bc] .probe_hwif+0x9e4/0x9ec
[c0000000041e3b90] [c000000000293414] .probe_hwif_init_with_fixup+0x2c/0xe0
[c0000000041e3c20] [c000000000296e20] .ide_setup_pci_device+0x74/0xd8
[c0000000041e3cc0] [c00000000028495c] .sl82c105_init_one+0x24/0x40
[c0000000041e3d40] [c000000000426ffc] .ide_scan_pcidev+0xb0/0x10c
[c0000000041e3dd0] [c0000000004270a0] .ide_scan_pcibus+0x48/0x120
[c0000000041e3e70] [c000000000426f18] .ide_init+0x80/0xb4
[c0000000041e3f00] [c00000000000c390] .init+0x1d4/0x3f4
[c0000000041e3f90] [c000000000014388] .kernel_thread+0x4c/0x6c
Instruction dump:
887a00dd e8090000 f8410028 60630002 e9690010 e8490008 7c0903a6 4e800421
e8410028 e97a0090 4bfffdd4 e93b06a0 <e8090000> f8410028 60000000 e9690010
 <0>Kernel panic - not syncing: Attempted to kill init!


From: Olof Johansson <olof@austin.ibm.com>

pSeries p615 happens to have a bus hierarchy where the IDE controller for
the built-in CD is connected directly to the PHB without an intermediate
EADS bridge.  The new iommu/bus setup code assumed that all systems with
EADS will have all devices under them, so this resulted in the IDE
controller not having an iommu table allocated.

To avoid this, always allocate a small table at the PHB level.  It will
never be used for regular devices, and it's allocated out of the 256MB that
we previously skipped.

Signed-off-by: Olof Johansson <olof@austin.ibm.com>
Signed-off-by: Andrew Morton <akpm@osdl.org>
---

 25-akpm/arch/ppc64/kernel/pSeries_iommu.c |   34 ++++++++++++++++++++++--------
 1 files changed, 25 insertions(+), 9 deletions(-)

diff -puN arch/ppc64/kernel/pSeries_iommu.c~ppc64-p615-iommu-fix arch/ppc64/kernel/pSeries_iommu.c
--- 25/arch/ppc64/kernel/pSeries_iommu.c~ppc64-p615-iommu-fix	2005-01-28 14:25:59.525766944 -0800
+++ 25-akpm/arch/ppc64/kernel/pSeries_iommu.c	2005-01-28 14:25:59.529766336 -0800
@@ -309,6 +309,7 @@ static void iommu_table_setparms_lpar(st
 static void iommu_bus_setup_pSeries(struct pci_bus *bus)
 {
 	struct device_node *dn, *pdn;
+	struct iommu_table *tbl;
 
 	DBG("iommu_bus_setup_pSeries, bus %p, bus->self %p\n", bus, bus->self);
 
@@ -326,7 +327,6 @@ static void iommu_bus_setup_pSeries(stru
 	if (!bus->self) {
 		/* Root bus */
 		if (is_python(dn)) {
-			struct iommu_table *tbl;
 			unsigned int *iohole;
 
 			DBG("Python root bus %s\n", bus->name);
@@ -352,19 +352,35 @@ static void iommu_bus_setup_pSeries(stru
 			iommu_table_setparms(dn->phb, dn, tbl);
 			dn->iommu_table = iommu_init_table(tbl);
 		} else {
-			/* 256 MB window by default */
-			dn->phb->dma_window_size = 1 << 28;
-			/* always skip the first 256MB */
-			dn->phb->dma_window_base_cur = 1 << 28;
+			/* Do a 128MB table at root. This is used for the IDE
+			 * controller on some SMP-mode POWER4 machines. It
+			 * doesn't hurt to allocate it on other machines
+			 * -- it'll just be unused since new tables are
+			 * allocated on the EADS level.
+			 *
+			 * Allocate at offset 128MB to avoid having to deal
+			 * with ISA holes; 128MB table for IDE is plenty.
+			 */
+			dn->phb->dma_window_size = 1 << 27;
+			dn->phb->dma_window_base_cur = 1 << 27;
+
+			tbl = kmalloc(sizeof(struct iommu_table), GFP_KERNEL);
 
-			/* No table at PHB level for non-python PHBs */
+			iommu_table_setparms(dn->phb, dn, tbl);
+			dn->iommu_table = iommu_init_table(tbl);
+
+			/* All child buses have 256MB tables */
+			dn->phb->dma_window_size = 1 << 28;
 		}
 	} else {
 		pdn = pci_bus_to_OF_node(bus->parent);
 
-		if (!pdn->iommu_table) {
+		if (!bus->parent->self && !is_python(pdn)) {
 			struct iommu_table *tbl;
-			/* First child, allocate new table (256MB window) */
+			/* First child and not python means this is the EADS
+			 * level. Allocate new table for this slot with 256MB
+			 * window.
+			 */
 
 			tbl = kmalloc(sizeof(struct iommu_table), GFP_KERNEL);
 
@@ -372,7 +388,7 @@ static void iommu_bus_setup_pSeries(stru
 
 			dn->iommu_table = iommu_init_table(tbl);
 		} else {
-			/* Lower than first child or under python, copy parent table */
+			/* Lower than first child or under python, use parent table */
 			dn->iommu_table = pdn->iommu_table;
 		}
 	}
_
