From: Thomas Renninger <trenn@suse.de>
Subject: Avoid unaligned memory access
Patch-mainline: yes
References: 153173

 drivers/acpi/resources/rscalc.c  |   93 +++++++++++++++++----------------------
 drivers/acpi/resources/rslist.c  |   16 ++++++
 drivers/acpi/resources/rsmisc.c  |    7 +-
 drivers/acpi/resources/rsutils.c |   16 +++---
 include/acpi/acmacros.h          |    8 ++-
 include/acpi/actypes.h           |   10 ----
 6 files changed, 77 insertions(+), 73 deletions(-)

Signed-off-by: Thomas Renninger <trenn@suse.de>

Index: linux-2.6.16/include/acpi/acmacros.h
===================================================================
--- linux-2.6.16.orig/include/acpi/acmacros.h
+++ linux-2.6.16/include/acpi/acmacros.h
@@ -348,13 +348,15 @@
 												(((acpi_native_uint) boundary)-1)) & \
 												(~(((acpi_native_uint) boundary)-1)))
 
+/* Note: sizeof(acpi_native_uint) evaluates to either 2, 4, or 8 */
+
 #define ACPI_ROUND_DOWN_TO_32_BITS(a)        ACPI_ROUND_DOWN(a,4)
 #define ACPI_ROUND_DOWN_TO_64_BITS(a)        ACPI_ROUND_DOWN(a,8)
-#define ACPI_ROUND_DOWN_TO_NATIVE_WORD(a)    ACPI_ROUND_DOWN(a,ALIGNED_ADDRESS_BOUNDARY)
+#define ACPI_ROUND_DOWN_TO_NATIVE_WORD(a)    ACPI_ROUND_DOWN(a,sizeof(acpi_native_uint))
 
 #define ACPI_ROUND_UP_to_32_bITS(a)          ACPI_ROUND_UP(a,4)
 #define ACPI_ROUND_UP_to_64_bITS(a)          ACPI_ROUND_UP(a,8)
-#define ACPI_ROUND_UP_TO_NATIVE_WORD(a)      ACPI_ROUND_UP(a,ALIGNED_ADDRESS_BOUNDARY)
+#define ACPI_ROUND_UP_TO_NATIVE_WORD(a)      ACPI_ROUND_UP(a,sizeof(acpi_native_uint))
 
 #define ACPI_ROUND_BITS_UP_TO_BYTES(a)       ACPI_DIV_8((a) + 7)
 #define ACPI_ROUND_BITS_DOWN_TO_BYTES(a)     ACPI_DIV_8((a))
@@ -365,6 +367,8 @@
 
 #define ACPI_ROUND_UP_TO(value,boundary)     (((value) + ((boundary)-1)) / (boundary))
 
+#define ACPI_IS_MISALIGNED(value)            (((acpi_native_uint)value) & (sizeof(acpi_native_uint)-1))
+
 /*
  * Bitmask creation
  * Bit positions start at zero.
Index: linux-2.6.16/include/acpi/actypes.h
===================================================================
--- linux-2.6.16.orig/include/acpi/actypes.h
+++ linux-2.6.16/include/acpi/actypes.h
@@ -154,7 +154,6 @@ typedef u64 acpi_physical_address;
 #define ACPI_MAX_PTR                    ACPI_UINT64_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT64_MAX
 
-#define ALIGNED_ADDRESS_BOUNDARY        0x00000008
 #define ACPI_USE_NATIVE_DIVIDE	/* Has native 64-bit integer support */
 
 /*
@@ -195,8 +194,6 @@ typedef u64 acpi_physical_address;
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
-#define ALIGNED_ADDRESS_BOUNDARY        0x00000004
-
 /*******************************************************************************
  *
  * Types specific to 16-bit targets
@@ -223,7 +220,6 @@ typedef char *acpi_physical_address;
 #define ACPI_MAX_PTR                    ACPI_UINT16_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT16_MAX
 
-#define ALIGNED_ADDRESS_BOUNDARY        0x00000002
 #define ACPI_USE_NATIVE_DIVIDE	/* No 64-bit integers, ok to use native divide */
 
 /* 64-bit integers cannot be supported */
@@ -1297,12 +1293,6 @@ struct acpi_resource {
 
 #define ACPI_NEXT_RESOURCE(res)             (struct acpi_resource *)((u8 *) res + res->length)
 
-#ifndef ACPI_MISALIGNMENT_NOT_SUPPORTED
-#define ACPI_ALIGN_RESOURCE_SIZE(length)    (length)
-#else
-#define ACPI_ALIGN_RESOURCE_SIZE(length)    ACPI_ROUND_UP_TO_NATIVE_WORD(length)
-#endif
-
 /*
  * END: of definitions for Resource Attributes
  */
Index: linux-2.6.16/drivers/acpi/resources/rscalc.c
===================================================================
--- linux-2.6.16.orig/drivers/acpi/resources/rscalc.c
+++ linux-2.6.16/drivers/acpi/resources/rscalc.c
@@ -160,9 +160,11 @@ acpi_rs_stream_option_length(u32 resourc
 		    resource_length - minimum_aml_resource_length - 1;
 	}
 
-	/* Round up length to 32 bits for internal structure alignment */
-
-	return (ACPI_ROUND_UP_to_32_bITS(string_length));
+	/*
+	 * Round the length up to a multiple of the native word in order to
+	 * guarantee that the entire resource descriptor is native word aligned
+	 */
+	return ((u32) ACPI_ROUND_UP_TO_NATIVE_WORD(string_length));
 }
 
 /*******************************************************************************
@@ -332,7 +334,7 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 	acpi_status status;
 	u8 *end_aml;
 	u8 *buffer;
-	u32 buffer_size = 0;
+	u32 buffer_size;
 	u16 temp16;
 	u16 resource_length;
 	u32 extra_struct_bytes;
@@ -341,6 +343,7 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 
 	ACPI_FUNCTION_TRACE("rs_get_list_length");
 
+	*size_needed = 0;
 	end_aml = aml_buffer + aml_buffer_length;
 
 	/* Walk the list of AML resource descriptors */
@@ -386,35 +389,27 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 			break;
 
 		case ACPI_RESOURCE_NAME_VENDOR_SMALL:
+		case ACPI_RESOURCE_NAME_VENDOR_LARGE:
 			/*
 			 * Vendor Resource:
-			 * Ensure a 32-bit boundary for the structure
+			 * Get the number of vendor data bytes
 			 */
-			extra_struct_bytes =
-			    ACPI_ROUND_UP_to_32_bITS(resource_length);
+			extra_struct_bytes = resource_length;
 			break;
 
 		case ACPI_RESOURCE_NAME_END_TAG:
 			/*
 			 * End Tag: This is the normal exit, add size of end_tag
 			 */
-			*size_needed = buffer_size + ACPI_RS_SIZE_MIN;
+			*size_needed += ACPI_RS_SIZE_MIN;
 			return_ACPI_STATUS(AE_OK);
 
-		case ACPI_RESOURCE_NAME_VENDOR_LARGE:
-			/*
-			 * Vendor Resource:
-			 * Add vendor data and ensure a 32-bit boundary for the structure
-			 */
-			extra_struct_bytes =
-			    ACPI_ROUND_UP_to_32_bITS(resource_length);
-			break;
-
 		case ACPI_RESOURCE_NAME_ADDRESS32:
 		case ACPI_RESOURCE_NAME_ADDRESS16:
+		case ACPI_RESOURCE_NAME_ADDRESS64:
 			/*
-			 * 32-Bit or 16-bit Address Resource:
-			 * Add the size of any optional data (resource_source)
+			 * Address Resource:
+			 * Add the size of the optional resource_source
 			 */
 			extra_struct_bytes =
 			    acpi_rs_stream_option_length(resource_length,
@@ -423,50 +418,46 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 
 		case ACPI_RESOURCE_NAME_EXTENDED_IRQ:
 			/*
-			 * Extended IRQ:
-			 * Point past the interrupt_vector_flags to get the
-			 * interrupt_table_length.
+			 * Extended IRQ Resource:
+			 * Using the interrupt_table_length, add 4 bytes for each additional
+			 * interrupt. Note: at least one interrupt is required and is
+			 * included in the minimum descriptor size (reason for the -1)
 			 */
-			buffer++;
+			extra_struct_bytes = (buffer[1] - 1) * sizeof(u32);
 
-			extra_struct_bytes =
-			    /*
-			     * Add 4 bytes for each additional interrupt. Note: at
-			     * least one interrupt is required and is included in
-			     * the minimum descriptor size
-			     */
-			    ((*buffer - 1) * sizeof(u32)) +
-			    /* Add the size of any optional data (resource_source) */
+			/* Add the size of the optional resource_source */
+
+			extra_struct_bytes +=
 			    acpi_rs_stream_option_length(resource_length -
 							 extra_struct_bytes,
 							 minimum_aml_resource_length);
 			break;
 
-		case ACPI_RESOURCE_NAME_ADDRESS64:
-			/*
-			 * 64-Bit Address Resource:
-			 * Add the size of any optional data (resource_source)
-			 * Ensure a 64-bit boundary for the structure
-			 */
-			extra_struct_bytes =
-			    ACPI_ROUND_UP_to_64_bITS
-			    (acpi_rs_stream_option_length
-			     (resource_length, minimum_aml_resource_length));
-			break;
-
 		default:
 			break;
 		}
 
-		/* Update the required buffer size for the internal descriptor structs */
-
-		temp16 = (u16) (acpi_gbl_resource_struct_sizes[resource_index] +
-				extra_struct_bytes);
-		buffer_size += (u32) ACPI_ROUND_UP_TO_NATIVE_WORD(temp16);
+		/*
+		 * Update the required buffer size for the internal descriptor structs
+		 *
+		 * Important: Round the size up for the appropriate alignment. This
+		 * is a requirement on IA64.
+		 */
+		buffer_size = acpi_gbl_resource_struct_sizes[resource_index] +
+		    extra_struct_bytes;
+		buffer_size = ACPI_ROUND_UP_TO_NATIVE_WORD(buffer_size);
+
+		*size_needed += buffer_size;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_RESOURCES,
+				  "Type %.2X, Aml %.2X internal %.2X\n",
+				  acpi_ut_get_resource_type(aml_buffer),
+				  acpi_ut_get_descriptor_length(aml_buffer),
+				  buffer_size));
 
 		/*
-		 * Point to the next resource within the stream
-		 * using the size of the header plus the length contained in the header
+		 * Point to the next resource within the AML stream using the length
+		 * contained in the resource descriptor header
 		 */
 		aml_buffer += acpi_ut_get_descriptor_length(aml_buffer);
 	}
@@ -589,7 +580,7 @@ acpi_rs_get_pci_routing_table_length(uni
 	}
 
 	/*
-	 * Adding an extra element to the end of the list, essentially a
+	 * Add an extra element to the end of the list, essentially a
 	 * NULL terminator
 	 */
 	*buffer_size_needed =
Index: linux-2.6.16/drivers/acpi/resources/rslist.c
===================================================================
--- linux-2.6.16.orig/drivers/acpi/resources/rslist.c
+++ linux-2.6.16/drivers/acpi/resources/rslist.c
@@ -77,6 +77,16 @@ acpi_rs_convert_aml_to_resources(u8 * am
 	/* Loop until end-of-buffer or an end_tag is found */
 
 	while (aml < end_aml) {
+		/*
+		 * Check that the input buffer and all subsequent pointers into it
+		 * are aligned on a native word boundary. Most important on IA64
+		 */
+		if (ACPI_IS_MISALIGNED(resource)) {
+			ACPI_WARNING((AE_INFO,
+				      "Misaligned resource pointer %p",
+				      resource));
+		}
+
 		/* Validate the Resource Type and Resource Length */
 
 		status = acpi_ut_validate_resource(aml, &resource_index);
@@ -100,6 +110,12 @@ acpi_rs_convert_aml_to_resources(u8 * am
 			return_ACPI_STATUS(status);
 		}
 
+		ACPI_DEBUG_PRINT((ACPI_DB_RESOURCES,
+				  "Type %.2X, Aml %.2X internal %.2X\n",
+				  acpi_ut_get_resource_type(aml),
+				  acpi_ut_get_descriptor_length(aml),
+				  resource->length));
+
 		/* Normal exit on completion of an end_tag resource descriptor */
 
 		if (acpi_ut_get_resource_type(aml) ==
Index: linux-2.6.16/drivers/acpi/resources/rsmisc.c
===================================================================
--- linux-2.6.16.orig/drivers/acpi/resources/rsmisc.c
+++ linux-2.6.16/drivers/acpi/resources/rsmisc.c
@@ -81,7 +81,7 @@ acpi_rs_convert_aml_to_resource(struct a
 	u16 item_count = 0;
 	u16 temp16 = 0;
 
-	ACPI_FUNCTION_TRACE("rs_get_resource");
+	ACPI_FUNCTION_TRACE("rs_convert_aml_to_resource");
 
 	if (((acpi_native_uint) resource) & 0x3) {
 		/* Each internal resource struct is expected to be 32-bit aligned */
@@ -295,9 +295,10 @@ acpi_rs_convert_aml_to_resource(struct a
 
       exit:
 	if (!flags_mode) {
-		/* Round the resource struct length up to the next 32-bit boundary */
+		/* Round the resource struct length up to the next boundary (32 or 64) */
 
-		resource->length = ACPI_ROUND_UP_to_32_bITS(resource->length);
+		resource->length =
+		    (u32) ACPI_ROUND_UP_TO_NATIVE_WORD(resource->length);
 	}
 	return_ACPI_STATUS(AE_OK);
 }
Index: linux-2.6.16/drivers/acpi/resources/rsutils.c
===================================================================
--- linux-2.6.16.orig/drivers/acpi/resources/rsutils.c
+++ linux-2.6.16/drivers/acpi/resources/rsutils.c
@@ -298,7 +298,8 @@ static u16 acpi_rs_strcpy(char *destinat
  *              string_ptr          - (optional) where to store the actual
  *                                    resource_source string
  *
- * RETURN:      Length of the string plus NULL terminator, rounded up to 32 bit
+ * RETURN:      Length of the string plus NULL terminator, rounded up to native
+ *		word boundary
  *
  * DESCRIPTION: Copy the optional resource_source data from a raw AML descriptor
  *              to an internal resource descriptor
@@ -344,16 +345,17 @@ acpi_rs_get_resource_source(acpi_rs_leng
 		}
 
 		/*
-		 * In order for the struct_size to fall on a 32-bit boundary, calculate
-		 * the length of the string (+1 for the NULL terminator) and expand the
-		 * struct_size to the next 32-bit boundary.
+		 * In order for the Resource length to be a multiple of the native
+		 * word, calculate the length of the string (+1 for NULL terminator)
+		 * and expand to the next word multiple.
 		 *
 		 * Zero the entire area of the buffer.
 		 */
 		total_length =
-		    ACPI_ROUND_UP_to_32_bITS(ACPI_STRLEN
-					     ((char *)&aml_resource_source[1]) +
-					     1);
+		    ACPI_STRLEN(ACPI_CAST_PTR(char, &aml_resource_source[1])) +
+		    1;
+		total_length = (u32) ACPI_ROUND_UP_TO_NATIVE_WORD(total_length);
+
 		ACPI_MEMSET(resource_source->string_ptr, 0, total_length);
 
 		/* Copy the resource_source string to the destination */
