#! /usr/bin/perl -w

use FileHandle;
use Getopt::Long;
use Carp;
use strict;

my @frec;  # Remaining records in files (indexed by file, record).
my %occurrences;  # Remaining numbers of occurrences of records.
my @cond_syms;  # Symbols for files used in conditionals.
my $mask; # Mask that matches the current set of conditions: Each record that
	  # matches has its bit set.
my $lang = 'cpp';  # the language to generate (cpp, make).
my $gen_code = \&gen_cpp_code;  # Function for emitting conditionals.
my $dump_records = 0;  # dump resulting records (debugging)
my $initial_mask = 1;  # The initial conditional state
		       # (1 or 0, the real value is set later)
my $wrap_if = 1;
my $symbol;  # Make/shell variable to use (--make/--shell)

if (@ARGV && $ARGV[0] eq "--records") {
    $dump_records=1;
    shift @ARGV;
}
    
if (@ARGV) {
    if ($ARGV[0] eq "--make") {
	$gen_code = \&gen_make_code;
	$lang = 'make';
	shift @ARGV;
	$symbol=$ARGV[0];
	shift @ARGV;
    } elsif ($ARGV[0] eq "--shell") {
	$gen_code = \&gen_shell_code;
	$lang = 'shell';
	shift @ARGV;
	$symbol=$ARGV[0];
	shift @ARGV;
    }
}

sub readHeaderFile($) {
    my ($filename) = @_;
    my @frec;
    my $fh = new FileHandle("< $filename")
	or die "$filename: $!\n";

    while (<$fh>) {
	if (@frec && $frec[$#frec] =~ /^\n*$/s) {
	    $frec[$#frec] .= $_;
	} else {
	    push @frec, $_;
	}
	# Must merge multi-line comments: Otherwise, we could later
	# place a conditional in the middle of a comment, causing
	# a syntax error.
	if ($lang eq 'cpp' && m[/\*]) {
	    while (!m[(?<!/)\*/]) {
		    $_ = <$fh> || last;
		    $frec[$#frec] .= $_;
	    }
	# While not strictly necessary, merging heading comments avoids
	# very confusing results.
	} elsif (($lang eq 'shell' || $lang eq 'make') && m[^#] && @frec >= 2) {
		my $r = $frec[$#frec-1] . $_;
		if ($r =~ m[^\n*#\n#[^\n]+(\n#)?$]s) {
		    $frec[$#frec-1] .= $_;
		    pop @frec;
		}
	}
    }
    return @frec;
}

sub low_bit_index($) {
    my ($mask) = @_;
    croak "low_bit_index(0) not defined\n"
    	if ($mask == 0);
    my $n = 0;
    until ($mask & 1) {
	$mask >>= 1;
	$n++;
    }
    return $n;
}

sub count_bits($) {
    my ($mask) = @_;
    my $n = 0;
    while ($mask) {
	$n++ if ($mask & 1);
	$mask >>= 1;
    }
    return $n;
}

# Compute the bitmask for a given record (with bits set for all files
# that have that record on top).
sub mask_for($) {
    my ($record) = @_;
    my $mask = 0;
    for (my $n = @frec - 1 ; $n >= 0; $n--) {
	$mask = ($mask << 1) | ($frec[$n][0] eq $record);
    }
    return $mask;
}

sub all_bits_mask() {
    return (1 << @frec) - 1;
}

# Check if the next set of records still matches the mask.
sub mask_still_matches() {
    $mask != 0 or return 0;
    my $record = $frec[low_bit_index($mask)][0];
    
    for (my $n = 0 ; $n < @frec; $n++) {
	my $should_match = ($mask & (1 << $n)) != 0;
	my $does_match = @{$frec[$n]} && $frec[$n][0] eq $record;
	return 0 if $should_match != $does_match;
    }
    return 1;
}

# Generate conditionals in C preprocessor syntax.
sub gen_cpp_code($$) {
    my ($what, $mask) = @_;
    my $cond;
    if (defined $mask) {
	my @sym;
	$mask <<= 1;
	for (my $n = 0; $mask >>= 1; $n++) {
	    push @sym, $cond_syms[$n]
		if ($mask & 1);
	}
	$cond = join(" || ", map { "defined(" . $_ . ")" } @sym);
    }
    if ($what eq 'if' || $what eq 'elif') {
	print "#$what $cond\n";
    } elsif ($what eq 'else') {
	print "#else  /* $cond */\n";
    } else {
	print "#endif\n";
    }
}

# Generate conditionals in GNU make syntax.
my $nesting_level = 0;
sub gen_make_code($$) {
    my ($what, $mask) = @_;
    my $cond;
    my @sym;
    if (defined $mask) {
	$mask <<= 1;
	for (my $n = 0; $mask >>= 1; $n++) {
	    push @sym, $cond_syms[$n]
		if ($mask & 1);
	}
	if (@sym == 1) {
		$cond = "ifeq (\$($symbol),$sym[0])";
	} else {
		$cond = "ifneq (,\$(findstring |\$($symbol)|,|"
			. join("|", @sym)
			. "|))";
		#$cond = "ifeq (\$(shell case \"\$($symbol)\" in ("
		#	. join("|", @sym)
		#	. ") echo yes ;; esac),yes)";
	}
    }
    if ($what eq 'if' || $what eq 'elif') {
	print "else\n"
	    if ($what eq 'elif');
	print "$cond\n";
	$nesting_level++;
    } elsif ($what eq 'else') {
	print "else  # " . join(" ", @sym) . "\n";
    } else {
	for (; $nesting_level > 0; $nesting_level--) {
	    print "endif\n";
	}
    }
}

# Generate conditionals in sh syntax.
sub gen_shell_code($$) {
    my ($what, $mask) = @_;
    my $cond;
    my @sym;
    if (defined $mask) {
	$mask <<= 1;
	for (my $n = 0; $mask >>= 1; $n++) {
	    push @sym, $cond_syms[$n]
		if ($mask & 1);
	}
	$cond = join("|", @sym);
    }
    if ($what eq 'if') {
	print "case \"\$$symbol\" in\n$cond)\n";
    } elsif ($what eq 'elif') {
	print ";;\n$cond)\n";
    } elsif ($what eq 'else') {
	print ";;\n*)  # $cond\n";
    } else {
	print ";;\nesac\n";
    }
}

# Change the current mask to new_mask, emitting contitionals as needed.
my $cond_mask = 0;
sub change_mask($) {
    my ($new_mask) = @_;
    return unless ($new_mask != $mask);
    if (($new_mask & $cond_mask) == $new_mask) {
	if ($new_mask == $cond_mask) {
	    &$gen_code('else', $new_mask);
	} else {
	    &$gen_code('elif', $new_mask);
	}
    } else {
	&$gen_code('endif')
	    if ($mask != $initial_mask);
	&$gen_code('if', $new_mask)
	    if ($new_mask != $initial_mask);
	$cond_mask = $initial_mask;
    }
    $cond_mask &= ~$new_mask;
    $mask = $new_mask;
}

# In how many files does the record still occur?
sub remaining_files($) {
    my ($record) = @_;
    my $count;
    for (my $n = 0; $n < @frec; $n++) {
	foreach my $r (@{$frec[$n]}) {
	    next unless ($r eq $record);
	    $count++;
	    last;
	}
    }
    return $count;
}

# Output a record and remove it from all data structures.
sub emit_record() {
    my $low_bit = low_bit_index($mask);
    my $record = $frec[$low_bit][0];
    print $record;
    for (my $n = $low_bit; $n < @frec; $n++) {
	if ($mask & (1 << $n)) {
	    shift @{$frec[$n]};
	    delete $occurrences{$record}
		unless (--$occurrences{$record});
	}
    }
}

# Main stuff starts here ...

foreach my $filename (@ARGV) {
    push @frec, [ readHeaderFile($filename) ];
    foreach my $record (@{$frec[$#frec]}) {
	    $occurrences{$record}++;
    }

    my $sym = $filename;
    $sym = "F" . @cond_syms
	unless ($sym =~ s[/.*][]);
    push @cond_syms, $sym;
}

if ($dump_records) {
    foreach my $file (@frec) {
	foreach my $record (@$file) {
	    print STDERR $record;
	    print STDERR "-------\n";
	}
    }
    print STDERR "=======\n";
}

sub complete_match() {
    $mask != 0 or return 0;
    my $low_bit = low_bit_index($mask);
    @{$frec[$low_bit]} != 0 or return 0;
    my $record = $frec[$low_bit][0];
    return count_bits $mask == $occurrences{$record};
}

if ($wrap_if) {
    &$gen_code('if', all_bits_mask);
    # Adjust nesting level: we only want to close the encapsulating if at the
    # very end.
    $nesting_level--;
}
$initial_mask = $initial_mask ? all_bits_mask : 0;
$mask = $initial_mask;
while (%occurrences) {
    #my $low_bit = $mask ? low_bit_index($mask) : undef;
    #my $record = ($low_bit && @{$frec[$low_bit]}) ? $frec[$low_bit][0] : undef;
    #
    #unless (mask_still_matches && defined $record
    #	    && count_bits $mask == $occurrences{$record}) {
    unless (mask_still_matches && complete_match) {
	my $new_mask;
	# Search for a record whose reference count will drop to zero.
	for (my $n = 0; $n < @frec; $n++) {
	    next unless @{$frec[$n]};
	    my $record = $frec[$n][0];
	    $new_mask = mask_for $record;
	    goto good_mask
	        if (count_bits $new_mask == $occurrences{$record});
	}

	# Pick the record which appears in the fewest remaining
	# files. (This prevents records that appear in one file several
	# times from preceding symbols that appear in all files.)
	my ($min, $min_files);
	for (my $n = 0; $n < @frec; $n++) {
	    next unless @{$frec[$n]};
	    my $record = $frec[$n][0];
	    my $files = remaining_files $record;
	    if (!defined $min || $files < $min_files ||
		($files == $min_files &&
		 ($lang eq 'cpp'  && $frec[$min][0] =~ m[/\*] ||
		  ($lang eq 'shell' || $lang eq 'make')
		    && $frec[$min][0] =~ m[^#]))) {
		# We explicitly give common comments higher priority here
		# than other records!
		$min = $n;
		$min_files = $files;
	    }
	}
	$new_mask = mask_for $frec[$min][0];

      good_mask:
	change_mask $new_mask;
    }
    emit_record;
}
&$gen_code('endif')
    if $mask != $initial_mask;

if ($wrap_if) {
    # Adjust nesting level for final closing if.
    $nesting_level++;

    &$gen_code('endif');
}
