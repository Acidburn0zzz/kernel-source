From: okir@suse.de
Subject: IPv6 PMTU fix

This patch makes sure we pass the TAHI PMTU test #2

Index: linux-2.6.11/include/net/dst.h
===================================================================
--- linux-2.6.11.orig/include/net/dst.h	2005-03-10 15:25:51.000000000 +0100
+++ linux-2.6.11/include/net/dst.h	2005-03-10 15:29:13.000000000 +0100
@@ -48,6 +48,7 @@ struct dst_entry
 #define DST_NOXFRM		2
 #define DST_NOPOLICY		4
 #define DST_NOHASH		8
+#define DST_FRAGHDR		16
 	unsigned long		lastuse;
 	unsigned long		expires;
 
Index: linux-2.6.11/net/ipv6/ip6_output.c
===================================================================
--- linux-2.6.11.orig/net/ipv6/ip6_output.c	2005-03-10 15:25:51.000000000 +0100
+++ linux-2.6.11/net/ipv6/ip6_output.c	2005-03-10 15:30:03.000000000 +0100
@@ -147,7 +147,7 @@ static int ip6_output2(struct sk_buff *s
 
 int ip6_output(struct sk_buff *skb)
 {
-	if (skb->len > dst_pmtu(skb->dst))
+	if (skb->len > dst_pmtu(skb->dst) || (skb->dst->flags & DST_FRAGHDR))
 		return ip6_fragment(skb, ip6_output2);
 	else
 		return ip6_output2(skb);
Index: linux-2.6.11/net/ipv6/route.c
===================================================================
--- linux-2.6.11.orig/net/ipv6/route.c	2005-03-10 15:25:51.000000000 +0100
+++ linux-2.6.11/net/ipv6/route.c	2005-03-10 15:29:13.000000000 +0100
@@ -1185,6 +1185,7 @@ void rt6_pmtu_discovery(struct in6_addr 
 			struct net_device *dev, u32 pmtu)
 {
 	struct rt6_info *rt, *nrt;
+	int fraghdr_flag = 0;
 
 	if (pmtu < IPV6_MIN_MTU) {
 		if (net_ratelimit())
@@ -1194,6 +1195,7 @@ void rt6_pmtu_discovery(struct in6_addr 
 		   link MTU if the node receives a Packet Too Big message
 		   reporting next-hop MTU that is less than the IPv6 minimum MTU.
 		   */
+		fraghdr_flag = DST_FRAGHDR;
 		pmtu = IPV6_MIN_MTU;
 	}
 
@@ -1202,7 +1204,7 @@ void rt6_pmtu_discovery(struct in6_addr 
 	if (rt == NULL)
 		return;
 
-	if (pmtu >= dst_pmtu(&rt->u.dst))
+	if (pmtu >= dst_pmtu(&rt->u.dst) && !fraghdr_flag)
 		goto out;
 
 	/* New mtu received -> path was valid.
@@ -1218,6 +1220,7 @@ void rt6_pmtu_discovery(struct in6_addr 
 	 */
 	if (rt->rt6i_flags & RTF_CACHE) {
 		rt->u.dst.metrics[RTAX_MTU-1] = pmtu;
+		rt->u.dst.flags |= fraghdr_flag;
 		dst_set_expires(&rt->u.dst, ip6_rt_mtu_expires);
 		rt->rt6i_flags |= RTF_MODIFIED|RTF_EXPIRES;
 		goto out;
@@ -1232,6 +1235,7 @@ void rt6_pmtu_discovery(struct in6_addr 
 		nrt = rt6_cow(rt, daddr, saddr);
 		if (!nrt->u.dst.error) {
 			nrt->u.dst.metrics[RTAX_MTU-1] = pmtu;
+			nrt->u.dst.flags |= fraghdr_flag;
 			/* According to RFC 1981, detecting PMTU increase shouldn't be
 			   happened within 5 mins, the recommended timer is 10 mins.
 			   Here this route expiration time is set to ip6_rt_mtu_expires
@@ -1253,6 +1257,7 @@ void rt6_pmtu_discovery(struct in6_addr 
 		dst_set_expires(&nrt->u.dst, ip6_rt_mtu_expires);
 		nrt->rt6i_flags |= RTF_DYNAMIC|RTF_CACHE|RTF_EXPIRES;
 		nrt->u.dst.metrics[RTAX_MTU-1] = pmtu;
+		nrt->u.dst.flags |= fraghdr_flag;
 		ip6_ins_rt(nrt, NULL, NULL);
 	}
 
