From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH 37/40] reiserfs: clean up bl_when_delete


Signed-off-by: Jeff Mahoney <jeffm@suse.com.

---
 fs/reiserfs/do_balan.c |   71 ++++++++++++++++++++++---------------------------
 1 file changed, 33 insertions(+), 38 deletions(-)

--- a/fs/reiserfs/do_balan.c	2007-06-11 14:49:42.000000000 -0400
+++ b/fs/reiserfs/do_balan.c	2007-06-11 14:49:59.000000000 -0400
@@ -115,6 +115,13 @@ static int balance_leaf_when_delete(stru
 	int n;
 	struct item_head *ih;
 
+	if (flag != M_DELETE && flag != M_CUT) {
+		print_cur_tb("12040");
+		reiserfs_panic(tb->tb_sb, "PAP-12040",
+		               "unexpected mode: %s(%d)",
+			       tb_mode_names(flag), flag);
+	}
+
 	RFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,
 	       "vs- 12000: level: wrong FR %z", tb->FR[0]);
 	RFALSE(tb->blknum[0] > 1,
@@ -127,9 +134,7 @@ static int balance_leaf_when_delete(stru
 
 	/* Delete or truncate the item */
 
-	switch (flag) {
-	case M_DELETE:		/* delete item in S[0] */
-
+	if (flag == M_DELETE) {
 		RFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
 		       "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
 		       -tb->insert_size[0], ih);
@@ -151,44 +156,34 @@ static int balance_leaf_when_delete(stru
 		RFALSE(!item_pos && !tb->CFL[0],
 		       "PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0],
 		       tb->L[0]);
+	} else { /* M_CUT */
+		if (is_direntry_le_ih(ih)) {
 
-		break;
-
-	case M_CUT:{		/* cut item in S[0] */
-			if (is_direntry_le_ih(ih)) {
-
-				/* UFS unlink semantics are such that you can only delete one directory entry at a time. */
-				/* when we cut a directory tb->insert_size[0] means number of entries to be cut (always 1) */
-				tb->insert_size[0] = -1;
-				leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
-						     -tb->insert_size[0]);
-
-				RFALSE(!item_pos && !pos_in_item && !tb->CFL[0],
-				       "PAP-12030: can not change delimiting key. CFL[0]=%p",
-				       tb->CFL[0]);
-
-				if (!item_pos && !pos_in_item && tb->CFL[0]) {
-					replace_key(tb, tb->CFL[0], tb->lkey[0],
-						    tbS0, 0);
-				}
-			} else {
-				leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
-						     -tb->insert_size[0]);
-
-				RFALSE(!ih_item_len(ih),
-				       "PAP-12035: cut must leave non-zero dynamic length of item");
+			/* UFS unlink semantics are such that
+			 * you can only delete one directory entry
+			 * at a time. */
+			/* when we cut a directory tb->insert_size[0]
+			 * means number of entries to be cut
+			 * (always 1) */
+			tb->insert_size[0] = -1;
+			leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
+					     -tb->insert_size[0]);
+
+			RFALSE(!item_pos && !pos_in_item && !tb->CFL[0],
+			       "PAP-12030: can not change delimiting key. CFL[0]=%p",
+			       tb->CFL[0]);
+
+			if (!item_pos && !pos_in_item && tb->CFL[0]) {
+				replace_key(tb, tb->CFL[0], tb->lkey[0],
+					    tbS0, 0);
 			}
-			break;
-		}
+		} else {
+			leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
+					     -tb->insert_size[0]);
 
-	default:
-		print_cur_tb("12040");
-		reiserfs_panic(tb->tb_sb, "PAP-12040",
-		               "unexpected mode: %s(%d)",
-			       (flag ==
-				M_PASTE) ? "PASTE" : ((flag ==
-						       M_INSERT) ? "INSERT" :
-						      "UNKNOWN"), flag);
+			RFALSE(!ih_item_len(ih), "PAP-12035: cut must "
+			       "leave non-zero dynamic length of item");
+		}
 	}
 
 	/* the rule is that no shifting occurs unless by shifting a node can be freed */
