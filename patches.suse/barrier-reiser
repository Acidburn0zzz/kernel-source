diff -urp /mnt/kscratch/linux-2.6.5/fs/reiserfs/file.c linux-2.6.5-SUSE-20040406/fs/reiserfs/file.c
--- /mnt/kscratch/linux-2.6.5/fs/reiserfs/file.c	2004-04-06 09:59:15.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/fs/reiserfs/file.c	2004-04-06 10:11:58.991387540 +0200
@@ -88,15 +88,16 @@ static int reiserfs_sync_file(
 			      ) {
   struct inode * p_s_inode = p_s_dentry->d_inode;
   int n_err;
-
-  reiserfs_write_lock(p_s_inode->i_sb);
+  int barrier_done;
 
   if (!S_ISREG(p_s_inode->i_mode))
       BUG ();
-
   n_err = sync_mapping_buffers(p_s_inode->i_mapping) ;
-  reiserfs_commit_for_inode(p_s_inode) ;
+  reiserfs_write_lock(p_s_inode->i_sb);
+  barrier_done = reiserfs_commit_for_inode(p_s_inode);
   reiserfs_write_unlock(p_s_inode->i_sb);
+  if (barrier_done != 1)
+      blkdev_issue_flush(p_s_inode->i_sb->s_bdev, NULL);
   return ( n_err < 0 ) ? -EIO : 0;
 }
 
diff -urp /mnt/kscratch/linux-2.6.5/fs/reiserfs/inode.c linux-2.6.5-SUSE-20040406/fs/reiserfs/inode.c
--- /mnt/kscratch/linux-2.6.5/fs/reiserfs/inode.c	2004-04-06 09:59:15.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/fs/reiserfs/inode.c	2004-04-06 10:11:58.993387323 +0200
@@ -1123,7 +1123,6 @@ static void init_inode (struct inode * i
 	inode->i_mapping->a_ops = &reiserfs_address_space_operations;
     } else {
 	inode->i_blocks = 0;
-	inode->i_op = &reiserfs_special_inode_operations;
 	init_special_inode(inode, inode->i_mode, new_decode_dev(rdev));
     }
 }
@@ -2352,11 +2351,8 @@ int reiserfs_prepare_write(struct file *
 	if (th->t_refcount > old_ref) {
 	    if (old_ref)
 	    	th->t_refcount--;
-	    else {
-		reiserfs_write_lock(inode->i_sb);
+	    else
 		reiserfs_end_persistent_transaction(th);
-		reiserfs_write_unlock(inode->i_sb);
-	    }
 	}
     }
     return ret;
diff -urp /mnt/kscratch/linux-2.6.5/fs/reiserfs/journal.c linux-2.6.5-SUSE-20040406/fs/reiserfs/journal.c
--- /mnt/kscratch/linux-2.6.5/fs/reiserfs/journal.c	2004-04-06 09:59:15.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/fs/reiserfs/journal.c	2004-04-06 10:11:58.996386998 +0200
@@ -126,6 +126,12 @@ static int reiserfs_clean_and_file_buffe
   return 0 ;
 }
 
+static void disable_barrier(struct super_block *s)
+{
+    REISERFS_SB(s)->s_mount_opt &= ~(1 << REISERFS_BARRIER_FLUSH); 
+    printk("reiserfs: disabling flush barriers on %s\n", reiserfs_bdevname(s));
+}
+
 static struct reiserfs_bitmap_node *
 allocate_bitmap_node(struct super_block *p_s_sb) {
   struct reiserfs_bitmap_node *bn ;
@@ -639,6 +645,15 @@ static void submit_ordered_buffer(struct
     submit_bh(WRITE, bh) ;
 }
 
+static int submit_barrier_buffer(struct buffer_head *bh) {
+    get_bh(bh) ;
+    bh->b_end_io = reiserfs_end_ordered_io;
+    clear_buffer_dirty(bh) ;
+    if (!buffer_uptodate(bh))
+        BUG();
+    return submit_bh(WRITE_BARRIER, bh) ;
+}
+
 #define CHUNK_SIZE 32
 struct buffer_chunk {
     struct buffer_head *bh[CHUNK_SIZE];
@@ -908,6 +923,7 @@ static int flush_commit_list(struct supe
   int bn ;
   struct buffer_head *tbh = NULL ;
   unsigned long trans_id = jl->j_trans_id;
+  int barrier = 0;
 
   reiserfs_check_lock_depth(s, "flush_commit_list") ;
 
@@ -972,7 +988,20 @@ static int flush_commit_list(struct supe
   }
   atomic_dec(&SB_JOURNAL(s)->j_async_throttle);
 
-  /* wait on everything written so far before writing the commit */
+  /* wait on everything written so far before writing the commit 
+   * if we are in barrier mode, send the commit down now
+   */
+  barrier = reiserfs_barrier_flush(s);
+  if (barrier) {
+      int ret;
+      lock_buffer(jl->j_commit_bh);
+      ret = submit_barrier_buffer(jl->j_commit_bh);
+      if (ret == -EOPNOTSUPP) {
+	  set_buffer_uptodate(jl->j_commit_bh);
+          disable_barrier(s);
+	  barrier = 0;
+      }
+  }
   for (i = 0 ;  i < (jl->j_len + 1) ; i++) {  
     bn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + 
 	 (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s) ;
@@ -994,10 +1023,14 @@ static int flush_commit_list(struct supe
   if (atomic_read(&(jl->j_commit_left)) != 1)
     BUG();
 
-  if (buffer_dirty(jl->j_commit_bh))
-    BUG();
-  mark_buffer_dirty(jl->j_commit_bh) ;
-  sync_dirty_buffer(jl->j_commit_bh) ;
+  if (!barrier) {
+      if (buffer_dirty(jl->j_commit_bh))
+	BUG();
+      mark_buffer_dirty(jl->j_commit_bh) ;
+      sync_dirty_buffer(jl->j_commit_bh) ;
+  } else
+      wait_on_buffer(jl->j_commit_bh);
+
   if (!buffer_uptodate(jl->j_commit_bh)) {
     reiserfs_panic(s, "journal-615: buffer write failed\n") ;
   }
@@ -1098,8 +1131,22 @@ static int _update_journal_header_block(
     jh->j_last_flush_trans_id = cpu_to_le32(trans_id) ;
     jh->j_first_unflushed_offset = cpu_to_le32(offset) ;
     jh->j_mount_id = cpu_to_le32(SB_JOURNAL(p_s_sb)->j_mount_id) ;
-    set_buffer_dirty(SB_JOURNAL(p_s_sb)->j_header_bh) ;
-    sync_dirty_buffer(SB_JOURNAL(p_s_sb)->j_header_bh) ;
+
+    if (reiserfs_barrier_flush(p_s_sb)) {
+	int ret;
+	lock_buffer(SB_JOURNAL(p_s_sb)->j_header_bh);
+	ret = submit_barrier_buffer(SB_JOURNAL(p_s_sb)->j_header_bh);
+	if (ret == -EOPNOTSUPP) {
+	    set_buffer_uptodate(SB_JOURNAL(p_s_sb)->j_header_bh);
+	    disable_barrier(p_s_sb);
+	    goto sync;
+	}
+	wait_on_buffer(SB_JOURNAL(p_s_sb)->j_header_bh);
+    } else {
+sync:
+	set_buffer_dirty(SB_JOURNAL(p_s_sb)->j_header_bh) ;
+	sync_dirty_buffer(SB_JOURNAL(p_s_sb)->j_header_bh) ;
+    }
     if (!buffer_uptodate(SB_JOURNAL(p_s_sb)->j_header_bh)) {
       reiserfs_warning (p_s_sb, "journal-837: IO error during journal replay");
       return -EIO ;
@@ -2705,7 +2752,7 @@ int journal_mark_dirty(struct reiserfs_t
   ** a dirty or journal_dirty or locked buffer to be logged, as some changes
   ** could get to disk too early.  NOT GOOD.
   */
-  if (!prepared || buffer_dirty(bh)) {
+  if (!prepared || buffer_locked(bh) || buffer_dirty(bh)) {
     reiserfs_warning (p_s_sb, "journal-1777: buffer %llu bad state "
 		      "%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT",
 		      (unsigned long long)bh->b_blocknr, prepared ? ' ' : '!', 
@@ -3153,11 +3200,16 @@ void reiserfs_update_inode_transaction(s
   REISERFS_I(inode)->i_trans_id = SB_JOURNAL(inode->i_sb)->j_trans_id ;
 }
 
-static void __commit_trans_jl(struct inode *inode, unsigned long id,
+/*
+ * returns -1 on error, 0 if no commits/barriers were done and 1
+ * if a transaction was actually committed and the barrier was done
+ */
+static int __commit_trans_jl(struct inode *inode, unsigned long id,
                                  struct reiserfs_journal_list *jl) 
 {
     struct reiserfs_transaction_handle th ;
     struct super_block *sb = inode->i_sb ;
+    int ret = 0;
 
     /* is it from the current transaction, or from an unknown transaction? */
     if (id == SB_JOURNAL(sb)->j_trans_id) {
@@ -3179,6 +3231,7 @@ static void __commit_trans_jl(struct ino
 	}
 
 	journal_end_sync(&th, sb, 1) ;
+	ret = 1;
 	
     } else {
 	/* this gets tricky, we have to make sure the journal list in
@@ -3187,13 +3240,21 @@ static void __commit_trans_jl(struct ino
 	 */
 flush_commit_only:
 	if (journal_list_still_alive(inode->i_sb, id)) {
+	    /* 
+	     * we only set ret to 1 when we know for sure
+	     * the barrier hasn't been started yet on the commit
+	     * block.
+	     */
+	    if (atomic_read(&jl->j_commit_left) > 1)
+	        ret = 1;
 	    flush_commit_list(sb, jl, 1) ;
 	}
     }
     /* otherwise the list is gone, and long since committed */
+    return ret;
 }
 
-void reiserfs_commit_for_inode(struct inode *inode) {
+int reiserfs_commit_for_inode(struct inode *inode) {
     unsigned long id = REISERFS_I(inode)->i_trans_id;
     struct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;
 
@@ -3206,7 +3267,7 @@ void reiserfs_commit_for_inode(struct in
 	/* jl will be updated in __commit_trans_jl */
     }
 
-    __commit_trans_jl(inode, id, jl);
+   return __commit_trans_jl(inode, id, jl);
 }
 
 void reiserfs_restore_prepared_buffer(struct super_block *p_s_sb, 
diff -urp /mnt/kscratch/linux-2.6.5/fs/reiserfs/namei.c linux-2.6.5-SUSE-20040406/fs/reiserfs/namei.c
--- /mnt/kscratch/linux-2.6.5/fs/reiserfs/namei.c	2004-04-06 09:59:15.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/fs/reiserfs/namei.c	2004-04-06 10:11:58.997386890 +0200
@@ -677,7 +677,6 @@ static int reiserfs_mknod (struct inode 
         goto out_failed;
     }
 
-    inode->i_op = &reiserfs_special_inode_operations;
     init_special_inode(inode, inode->i_mode, rdev) ;
 
     //FIXME: needed for block and char devices only
@@ -1401,17 +1400,3 @@ struct inode_operations reiserfs_symlink
 };
 
 
-/*
- * special file operations.. just xattr/acl stuff
- */
-struct inode_operations reiserfs_special_inode_operations = {
-    .setattr        = reiserfs_setattr,
-    .setxattr       = reiserfs_setxattr,
-    .getxattr       = reiserfs_getxattr,
-    .listxattr      = reiserfs_listxattr,
-    .removexattr    = reiserfs_removexattr,
-    .permission     = reiserfs_permission,
-
-};
-
-
diff -urp /mnt/kscratch/linux-2.6.5/fs/reiserfs/super.c linux-2.6.5-SUSE-20040406/fs/reiserfs/super.c
--- /mnt/kscratch/linux-2.6.5/fs/reiserfs/super.c	2004-04-06 09:59:15.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/fs/reiserfs/super.c	2004-04-06 10:11:58.999386674 +0200
@@ -550,6 +550,13 @@ static const arg_desc_t logging_mode[] =
     {NULL, 0}
 };
 
+/* possible values for -o data= */
+static const arg_desc_t barrier_mode[] = {
+    {"none", 1<<REISERFS_BARRIER_NONE, 1<<REISERFS_BARRIER_FLUSH},
+    {"flush", 1<<REISERFS_BARRIER_FLUSH, 1<<REISERFS_BARRIER_NONE},
+    {NULL, 0}
+};
+
 /* possible values for "-o block-allocator=" and bits which are to be set in
    s_mount_opt of reiserfs specific part of in-core super block */
 static const arg_desc_t balloc[] = {
@@ -708,6 +715,7 @@ static int reiserfs_parse_options (struc
 	{"replayonly", 0, 0, 1<<REPLAYONLY, 0},
 	{"block-allocator", 'a', balloc, 0, 0},
 	{"data", 'd', logging_mode, 0, 0},
+	{"barrier", 'b', barrier_mode, 0, 0},
 	{"resize", 'r', 0, 0, 0},
 	{"jdev", 'j', 0, 0, 0},
 	{"nolargeio", 'w', 0, 0, 0},
@@ -810,6 +818,23 @@ static void handle_data_mode(struct supe
     }
 }
 
+static void handle_barrier_mode(struct super_block *s, unsigned long bits) {
+    int flush = (1 << REISERFS_BARRIER_FLUSH);
+    int none = (1 << REISERFS_BARRIER_NONE);
+    int all_barrier = flush | none;
+                      
+    if (bits & all_barrier) {
+        REISERFS_SB(s)->s_mount_opt &= ~all_barrier;
+	if (bits & flush) {
+	    REISERFS_SB(s)->s_mount_opt |= flush;
+	    printk("reiserfs: enabling write barrier flush mode\n");
+	} else if (bits & none) {
+	    REISERFS_SB(s)->s_mount_opt |= none;
+	    printk("reiserfs: write barriers turned off\n");
+	}
+   }
+}
+
 static void handle_attrs( struct super_block *s )
 {
 	struct reiserfs_super_block * rs;
@@ -854,6 +879,8 @@ static int reiserfs_remount (struct supe
   safe_mask |= 1 << REISERFS_ATTRS;
   safe_mask |= 1 << REISERFS_XATTRS_USER;
   safe_mask |= 1 << REISERFS_POSIXACL;
+  safe_mask |= 1 << REISERFS_BARRIER_FLUSH;
+  safe_mask |= 1 << REISERFS_BARRIER_NONE;
 
   /* Update the bitmask, taking care to keep
    * the bits we're not allowed to change here */
@@ -894,6 +921,7 @@ static int reiserfs_remount (struct supe
     }
 
     handle_data_mode(s, mount_options);
+    handle_barrier_mode(s, mount_options);
     REISERFS_SB(s)->s_mount_state = sb_umount_state(rs) ;
     s->s_flags &= ~MS_RDONLY ; /* now it is safe to call journal_begin */
     journal_begin(&th, s, 10) ;
@@ -1405,6 +1433,9 @@ static int reiserfs_fill_super (struct s
     } else {
         reiserfs_info (s, "using writeback data mode\n");
     }
+    if (reiserfs_barrier_flush(s)) {
+    	printk("reiserfs: using flush barriers\n");
+    }
 
     // set_device_ro(s->s_dev, 1) ;
     if( journal_init(s, jdev_name, old_format, commit_max_age) ) {
diff -urp /mnt/kscratch/linux-2.6.5/include/linux/reiserfs_fs.h linux-2.6.5-SUSE-20040406/include/linux/reiserfs_fs.h
--- /mnt/kscratch/linux-2.6.5/include/linux/reiserfs_fs.h	2004-04-06 09:59:15.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/include/linux/reiserfs_fs.h	2004-04-06 10:11:59.006385916 +0200
@@ -1765,7 +1765,8 @@ int reiserfs_end_persistent_transaction(
 int reiserfs_commit_page(struct inode *inode, struct page *page,
 		unsigned from, unsigned to);
 int reiserfs_flush_old_commits(struct super_block *);
-void reiserfs_commit_for_inode(struct inode *) ;
+int reiserfs_commit_for_inode(struct inode *) ;
+int  reiserfs_inode_needs_commit(struct inode *) ;
 void reiserfs_update_inode_transaction(struct inode *) ;
 void reiserfs_wait_on_write_block(struct super_block *s) ;
 void reiserfs_block_writes(struct reiserfs_transaction_handle *th) ;
@@ -2023,7 +2024,6 @@ int reiserfs_global_version_in_proc( cha
 /* dir.c */
 extern struct inode_operations reiserfs_dir_inode_operations;
 extern struct inode_operations reiserfs_symlink_inode_operations;
-extern struct inode_operations reiserfs_special_inode_operations;
 extern struct file_operations reiserfs_dir_operations;
 
 /* tail_conversion.c */
diff -urp /mnt/kscratch/linux-2.6.5/include/linux/reiserfs_fs_sb.h linux-2.6.5-SUSE-20040406/include/linux/reiserfs_fs_sb.h
--- /mnt/kscratch/linux-2.6.5/include/linux/reiserfs_fs_sb.h	2004-04-06 09:59:02.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/include/linux/reiserfs_fs_sb.h	2004-04-06 10:11:59.007385807 +0200
@@ -443,6 +443,8 @@ enum reiserfs_mount_options {
     REISERFS_XATTRS,
     REISERFS_XATTRS_USER,
     REISERFS_POSIXACL,
+    REISERFS_BARRIER_NONE,
+    REISERFS_BARRIER_FLUSH,
 
     REISERFS_TEST1,
     REISERFS_TEST2,
@@ -472,6 +474,8 @@ enum reiserfs_mount_options {
 #define reiserfs_xattrs_user(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_XATTRS_USER))
 #define reiserfs_posixacl(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_POSIXACL))
 #define reiserfs_xattrs_optional(s) (reiserfs_xattrs_user(s) || reiserfs_posixacl(s))
+#define reiserfs_barrier_none(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_BARRIER_NONE))
+#define reiserfs_barrier_flush(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_BARRIER_FLUSH))
 
 void reiserfs_file_buffer (struct buffer_head * bh, int list);
 extern struct file_system_type reiserfs_fs_type;
