Index: linux-2.6.0-test9/fs/nfsd/vfs.c
===================================================================
--- linux-2.6.0-test9.orig/fs/nfsd/vfs.c	2003-10-25 20:43:26.000000000 +0200
+++ linux-2.6.0-test9/fs/nfsd/vfs.c	2003-11-16 12:36:44.000000000 +0100
@@ -43,6 +43,7 @@
 #endif /* CONFIG_NFSD_V3 */
 #include <linux/nfsd/nfsfh.h>
 #include <linux/quotaops.h>
+#include <linux/xattr_acl.h>
 
 #include <asm/uaccess.h>
 
@@ -1630,3 +1631,109 @@ nfsd_racache_init(int cache_size)
 	nfsdstats.ra_size = cache_size;
 	return 0;
 }
+
+#ifdef CONFIG_NFSD_ACL
+struct posix_acl *
+nfsd_get_posix_acl(struct svc_fh *fhp, int type)
+{
+	struct inode *inode = fhp->fh_dentry->d_inode;
+	char *name;
+	void *value = NULL;
+	ssize_t size;
+	struct posix_acl *acl;
+
+	if (!IS_POSIXACL(inode) || !inode->i_op || !inode->i_op->getxattr)
+		return ERR_PTR(-EOPNOTSUPP);
+	switch(type) {
+		case ACL_TYPE_ACCESS:
+			name = XATTR_NAME_ACL_ACCESS;
+			break;
+		case ACL_TYPE_DEFAULT:
+			name = XATTR_NAME_ACL_DEFAULT;
+			break;
+		default:
+			return ERR_PTR(-EOPNOTSUPP);
+	}
+
+	size = inode->i_op->getxattr(fhp->fh_dentry, name, NULL, 0);
+
+	if (size < 0) {
+		acl = ERR_PTR(size);
+		goto getout;
+	} else if (size > 0) {
+		value = kmalloc(size, GFP_KERNEL);
+		if (!value) {
+			acl = ERR_PTR(-ENOMEM);
+			goto getout;
+		}
+		size = inode->i_op->getxattr(fhp->fh_dentry, name, value, size);
+		if (size < 0) {
+			acl = ERR_PTR(size);
+			goto getout;
+		}
+	}
+	acl = posix_acl_from_xattr(value, size);
+
+getout:
+	kfree(value);
+	return acl;
+}
+#endif  /* CONFIG_NFSD_ACL */
+
+#ifdef CONFIG_NFSD_ACL
+int
+nfsd_set_posix_acl(struct svc_fh *fhp, int type, struct posix_acl *acl)
+{
+	struct inode *inode = fhp->fh_dentry->d_inode;
+	char *name;
+	void *value = NULL;
+	size_t size;
+	int error;
+
+	if (!IS_POSIXACL(inode) || !inode->i_op ||
+	    !inode->i_op->setxattr || !inode->i_op->removexattr)
+		return -EOPNOTSUPP;
+	switch(type) {
+		case ACL_TYPE_ACCESS:
+			name = XATTR_NAME_ACL_ACCESS;
+			break;
+		case ACL_TYPE_DEFAULT:
+			name = XATTR_NAME_ACL_DEFAULT;
+			break;
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	if (acl && acl->a_count) {
+		size = xattr_acl_size(acl->a_count);
+		value = kmalloc(size, GFP_KERNEL);
+		if (!value)
+			return -ENOMEM;
+		size = posix_acl_to_xattr(acl, value, size);
+		if (size < 0) {
+			error = size;
+			goto getout;
+		}
+	} else
+		size = 0;
+
+	if (!fhp->fh_locked)
+		fh_lock(fhp);  /* unlocking is done automatically */
+	if (size)
+		error = inode->i_op->setxattr(fhp->fh_dentry, name,
+					      value, size, 0);
+	else {
+		if (!S_ISDIR(inode->i_mode) && type == ACL_TYPE_DEFAULT)
+			error = 0;
+		else {
+			error = inode->i_op->removexattr(fhp->fh_dentry, name);
+			if (error == -ENODATA)
+				error = 0;
+		}
+	}
+
+getout:
+	kfree(value);
+	return error;
+}
+#endif  /* CONFIG_NFSD_ACL */
Index: linux-2.6.0-test9/fs/nfsd/nfs3xdr.c
===================================================================
--- linux-2.6.0-test9.orig/fs/nfsd/nfs3xdr.c	2003-10-25 20:42:41.000000000 +0200
+++ linux-2.6.0-test9/fs/nfsd/nfs3xdr.c	2003-11-17 16:59:38.000000000 +0100
@@ -21,6 +21,8 @@
 #include <linux/sunrpc/svc.h>
 #include <linux/nfsd/nfsd.h>
 #include <linux/nfsd/xdr3.h>
+#include <linux/vmalloc.h>
+#include <linux/nfsacl.h>
 
 #define NFSDDBG_FACILITY		NFSDDBG_XDR
 
@@ -588,6 +590,52 @@ nfs3svc_decode_commitargs(struct svc_rqs
 	return xdr_argsize_check(rqstp, p);
 }
 
+#ifdef CONFIG_NFSD_ACL
+int
+nfs3svc_decode_getaclargs(struct svc_rqst *rqstp, u32 *p,
+			  struct nfsd3_getaclargs *args)
+{
+	if (!(p = decode_fh(p, &args->fh)))
+		return 0;
+	args->mask = ntohl(*p); p++;
+
+	return xdr_argsize_check(rqstp, p);
+}
+#endif  /* CONFIG_NFSD_ACL */
+
+#ifdef CONFIG_NFSD_ACL
+int
+nfs3svc_decode_setaclargs(struct svc_rqst *rqstp, u32 *p,
+			  struct nfsd3_setaclargs *args)
+{
+	u32 *buf, *end;
+
+	if (!(p = decode_fh(p, &args->fh)))
+		return 0;
+	args->mask = ntohl(*p++);
+	if (args->mask & ~(NFS3_ACL|NFS3_ACLCNT|NFS3_DFACL|NFS3_DFACLCNT) ||
+	    !xdr_argsize_check(rqstp, p))
+		return 0;
+
+	/* Use the big hammer here: Trying to extract the acls directly from
+	   the xdr_buf has caused me many headaches already. */
+	p = buf = vmalloc(rqstp->rq_arg.len);
+	if (!buf)
+		return 0;
+	copy_from_xdr((char *)buf, &rqstp->rq_arg);
+	end = buf + (rqstp->rq_arg.len >> 2);
+
+	/* argp->acl_{access,default} are released in nfsd3_proc_setacl. */
+	p = nfsacl_decode(p, end, NULL, (args->mask & NFS3_ACL) ?
+					&args->acl_access : NULL);
+	if (p)
+		p = nfsacl_decode(p, end, NULL, (args->mask & NFS3_DFACL) ?
+						&args->acl_default : NULL);
+	vfree(buf);
+	return (p != NULL);
+}
+#endif  /* CONFIG_NFSD_ACL */
+
 /*
  * XDR encode functions
  */
@@ -940,6 +988,77 @@ nfs3svc_encode_commitres(struct svc_rqst
 	return xdr_ressize_check(rqstp, p);
 }
 
+#ifdef CONFIG_NFSD_ACL
+/* GETACL */
+int
+nfs3svc_encode_getaclres(struct svc_rqst *rqstp, u32 *p,
+			 struct nfsd3_getaclres *resp)
+{
+	struct dentry *dentry = resp->fh.fh_dentry;
+
+	p = encode_post_op_attr(rqstp, p, &resp->fh);
+	if (resp->status == 0 && dentry && dentry->d_inode) {
+		struct inode *inode = dentry->d_inode;
+		ssize_t len = 4 +
+			resp->acl_access  ? resp->acl_access->a_count  : 0 +
+			resp->acl_default ? resp->acl_default->a_count : 0;
+		u32 *buf, *end;
+
+		*p++ = htonl(resp->mask);
+		if (!xdr_ressize_check(rqstp, p))
+			return 0;
+		
+		p = buf = vmalloc(len);
+		if (!buf)
+			return 0;
+		end = buf + (len >> 2);
+		if (!(p = nfsacl_encode(p, end, inode, resp->acl_access,
+					resp->mask & NFS3_ACL, 0))) {
+			vfree(buf);
+			return 0;
+		}
+		if (!(p = nfsacl_encode(p, end, inode, resp->acl_default,
+					resp->mask & NFS3_DFACL,
+					NFS3_ACL_DEFAULT))) {
+			vfree(buf);
+			return 0;
+		}
+
+		end = p; p = buf;
+		len = (end - buf) << 2;
+		rqstp->rq_res.page_len = len;
+		while (len > 0) {
+			if (svc_take_page(rqstp) != 0) {
+				vfree(buf);
+				return 0;
+			}
+			memcpy(page_address(rqstp->rq_respages[
+				rqstp->rq_resused-1]), p,
+				min((size_t)len, PAGE_SIZE));
+			p += PAGE_SIZE >> 2;
+			len -= PAGE_SIZE;
+		}
+		vfree(buf);
+	} else
+		if (!xdr_ressize_check(rqstp, p))
+			return 0;
+
+	return 1;
+}
+#endif  /* CONFIG_NFSD_ACL */
+
+#ifdef CONFIG_NFSD_ACL
+/* SETACL */
+int
+nfs3svc_encode_setaclres(struct svc_rqst *rqstp, u32 *p,
+			 struct nfsd3_attrstat *resp)
+{
+	p = encode_post_op_attr(rqstp, p, &resp->fh);
+
+	return xdr_ressize_check(rqstp, p);
+}
+#endif  /* CONFIG_NFSD_ACL */
+
 /*
  * XDR release functions
  */
@@ -959,3 +1078,15 @@ nfs3svc_release_fhandle2(struct svc_rqst
 	fh_put(&resp->fh2);
 	return 1;
 }
+
+#ifdef CONFIG_NFSD_ACL
+int
+nfs3svc_release_getacl(struct svc_rqst *rqstp, u32 *p,
+		       struct nfsd3_getaclres *resp)
+{
+	fh_put(&resp->fh);
+	posix_acl_release(resp->acl_access);
+	posix_acl_release(resp->acl_default);
+	return 1;
+}
+#endif  /* CONFIG_NFSD_ACL */
Index: linux-2.6.0-test9/fs/nfsd/stats.c
===================================================================
--- linux-2.6.0-test9.orig/fs/nfsd/stats.c	2003-10-25 20:42:42.000000000 +0200
+++ linux-2.6.0-test9/fs/nfsd/stats.c	2003-11-15 08:29:11.000000000 +0100
@@ -39,6 +39,12 @@ struct svc_stat		nfsd_svcstats = {
 	.program	= &nfsd_program,
 };
 
+#ifdef CONFIG_NFSD_ACL
+struct svc_stat	nfsd_acl_svcstats = {
+	.program	= &nfsd_acl_program,
+};
+#endif
+
 static int
 nfsd_proc_read(char *buffer, char **start, off_t offset, int count,
 				int *eof, void *data)
Index: linux-2.6.0-test9/fs/nfsd/nfs3proc.c
===================================================================
--- linux-2.6.0-test9.orig/fs/nfsd/nfs3proc.c	2003-10-25 20:43:24.000000000 +0200
+++ linux-2.6.0-test9/fs/nfsd/nfs3proc.c	2003-11-15 08:29:11.000000000 +0100
@@ -609,6 +609,105 @@ nfsd3_proc_commit(struct svc_rqst * rqst
 	RETURN_STATUS(nfserr);
 }
 
+#ifdef CONFIG_NFSD_ACL
+/*
+ * Get the Access and/or Default ACL of a file.
+ */
+static int
+nfsd3_proc_getacl(struct svc_rqst * rqstp, struct nfsd3_getaclargs *argp,
+					   struct nfsd3_getaclres *resp)
+{
+	svc_fh *fh;
+	struct posix_acl *acl;
+	int nfserr = 0;
+
+	fh = fh_copy(&resp->fh, &argp->fh);
+	if ((nfserr = fh_verify(rqstp, &resp->fh, 0, MAY_NOP)))
+		RETURN_STATUS(nfserr_inval);
+	
+	if (argp->mask & ~(NFS3_ACL|NFS3_ACLCNT|NFS3_DFACL|NFS3_DFACLCNT))
+		RETURN_STATUS(nfserr_inval);
+	resp->mask = argp->mask;
+
+	if (resp->mask & (NFS3_ACL|NFS3_ACLCNT)) {
+		acl = nfsd_get_posix_acl(fh, ACL_TYPE_ACCESS);
+		if (IS_ERR(acl)) {
+			int err = PTR_ERR(acl);
+
+			if (err == -ENODATA || err == -EOPNOTSUPP)
+				acl = NULL;
+			else {
+				nfserr = nfserrno(err);
+				goto fail;
+			}
+		}
+		if (acl == NULL) {
+			/* Solaris returns the inode's minimum ACL. */
+
+			struct inode *inode = fh->fh_dentry->d_inode;
+			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
+		}
+		resp->acl_access = acl;
+	}
+	if (resp->mask & (NFS3_DFACL|NFS3_DFACLCNT)) {
+		/* Check how Solaris handles requests for the Default ACL
+		   of a non-directory! */
+
+		acl = nfsd_get_posix_acl(fh, ACL_TYPE_DEFAULT);
+		if (IS_ERR(acl)) {
+			int err = PTR_ERR(acl);
+
+			if (err == -ENODATA || err == -EOPNOTSUPP)
+				acl = NULL;
+			else {
+				nfserr = nfserrno(err);
+				goto fail;
+			}
+		}
+		resp->acl_default = acl;
+	}
+
+	/* resp->acl_{access,default} are released in nfs3svc_release_getacl. */
+	RETURN_STATUS(0);
+
+fail:
+	posix_acl_release(resp->acl_access);
+	posix_acl_release(resp->acl_default);
+	RETURN_STATUS(nfserr);
+}
+#endif  /* CONFIG_NFSD_ACL */
+
+#ifdef CONFIG_NFSD_ACL
+/*
+ * Set the Access and/or Default ACL of a file.
+ */
+static int
+nfsd3_proc_setacl(struct svc_rqst * rqstp, struct nfsd3_setaclargs *argp,
+					   struct nfsd3_attrstat *resp)
+{
+	svc_fh *fh;
+	int nfserr = 0;
+
+	fh = fh_copy(&resp->fh, &argp->fh);
+	nfserr = fh_verify(rqstp, &resp->fh, 0, MAY_NOP);
+	
+	if (!nfserr) {
+		nfserr = nfserrno( nfsd_set_posix_acl(
+			fh, ACL_TYPE_ACCESS, argp->acl_access) );
+	}
+	if (!nfserr) {
+		nfserr = nfserrno( nfsd_set_posix_acl(
+			fh, ACL_TYPE_DEFAULT, argp->acl_default) );
+	}
+
+	/* argp->acl_{access,default} may have been allocated in
+	   nfs3svc_decode_setaclargs. */
+	posix_acl_release(argp->acl_access);
+	posix_acl_release(argp->acl_default);
+	RETURN_STATUS(nfserr);
+}
+#endif  /* CONFIG_NFSD_ACL */
+
 
 /*
  * NFSv3 Server procedures.
@@ -626,6 +725,7 @@ nfsd3_proc_commit(struct svc_rqst * rqst
 #define nfsd3_attrstatres		nfsd3_attrstat
 #define nfsd3_wccstatres		nfsd3_attrstat
 #define nfsd3_createres			nfsd3_diropres
+#define nfsd3_setaclres			nfsd3_attrstat
 #define nfsd3_voidres			nfsd3_voidargs
 struct nfsd3_voidargs { int dummy; };
 
@@ -646,6 +746,7 @@ struct nfsd3_voidargs { int dummy; };
 #define AT 21		/* attributes */
 #define pAT (1+AT)	/* post attributes - conditional */
 #define WC (7+pAT)	/* WCC attributes */
+#define ACL (1+NFS3_ACL_MAX_ENTRIES*3)  /* Access Control List */
 
 static struct svc_procedure		nfsd_procedures3[22] = {
   PROC(null,	 void,		void,		void,	  RC_NOCACHE, ST),
@@ -679,3 +780,19 @@ struct svc_version	nfsd_version3 = {
 		.vs_dispatch	= nfsd_dispatch,
 		.vs_xdrsize	= NFS3_SVC_XDRSIZE,
 };
+
+#ifdef CONFIG_NFSD_ACL
+struct svc_procedure		nfsd_acl_procedures3[] = {
+  PROC(null,	void,		void,		void,	  RC_NOCACHE, ST),
+  PROC(getacl,	getacl,		getacl,		getacl,	  RC_NOCACHE, ST+1+2*(1+ACL)),
+  PROC(setacl,	setacl,		setacl,		fhandle,  RC_NOCACHE, ST+pAT),
+};
+
+struct svc_version	nfsd_acl_version3 = {
+		.vs_vers	= 3,
+		.vs_nproc	= 3,
+		.vs_proc	nfsd_acl_procedures3,
+		.vs_dispatch	= nfsd_dispatch,
+		.vs_xdrsize	= NFS3_SVC_XDRSIZE,
+};
+#endif  /* CONFIG_NFSD_ACL */
Index: linux-2.6.0-test9/fs/nfsd/nfssvc.c
===================================================================
--- linux-2.6.0-test9.orig/fs/nfsd/nfssvc.c	2003-10-25 20:43:49.000000000 +0200
+++ linux-2.6.0-test9/fs/nfsd/nfssvc.c	2003-11-16 10:58:04.000000000 +0100
@@ -49,6 +49,9 @@
 #define	SIG_NOCLEAN	SIGHUP
 
 extern struct svc_program	nfsd_program;
+#ifdef CONFIG_NFSD_ACL
+extern struct svc_program	nfsd_acl_program;
+#endif
 static void			nfsd(struct svc_rqst *rqstp);
 struct timeval			nfssvc_boot;
 static struct svc_serv 		*nfsd_serv;
@@ -369,8 +372,29 @@ static struct svc_version *	nfsd_version
 #endif
 };
 
+#ifdef CONFIG_NFSD_ACL
+extern struct svc_version nfsd_acl_version3;
+
+static struct svc_version *	nfsd_acl_version[] = {
+	[3] = &nfsd_acl_version3,
+};
+
+#define NFSD_ACL_NRVERS		(sizeof(nfsd_acl_version)/sizeof(nfsd_acl_version[0]))
+struct svc_program		nfsd_acl_program = {
+	.pg_prog		= NFS3_ACL_PROGRAM,
+	.pg_nvers		= NFSD_ACL_NRVERS,
+	.pg_vers		= nfsd_acl_version,
+	.pg_name		= "nfsd",
+	.pg_stats		= &nfsd_acl_svcstats,
+};
+# define nfsd_acl_program_p &nfsd_acl_program
+#else
+# define nfsd_acl_program_p NULL
+#endif
+
 #define NFSD_NRVERS		(sizeof(nfsd_version)/sizeof(nfsd_version[0]))
 struct svc_program		nfsd_program = {
+	.pg_next		= nfsd_acl_program_p,
 	.pg_prog		= NFS_PROGRAM,		/* program number */
 	.pg_nvers		= NFSD_NRVERS,		/* nr of entries in nfsd_version */
 	.pg_vers		= nfsd_version,		/* version table */
Index: linux-2.6.0-test9/fs/Makefile
===================================================================
--- linux-2.6.0-test9.orig/fs/Makefile	2003-11-15 08:26:18.000000000 +0100
+++ linux-2.6.0-test9/fs/Makefile	2003-11-15 08:29:11.000000000 +0100
@@ -31,6 +31,7 @@ obj-$(CONFIG_BINFMT_FLAT)	+= binfmt_flat
 
 obj-$(CONFIG_FS_MBCACHE)	+= mbcache.o
 obj-$(CONFIG_FS_POSIX_ACL)	+= posix_acl.o xattr_acl.o
+obj-$(CONFIG_NFSD_ACL)		+= nfsacl.o
 
 obj-$(CONFIG_QUOTA)		+= dquot.o
 obj-$(CONFIG_QFMT_V1)		+= quota_v1.o
Index: linux-2.6.0-test9/fs/Kconfig
===================================================================
--- linux-2.6.0-test9.orig/fs/Kconfig	2003-11-15 08:26:15.000000000 +0100
+++ linux-2.6.0-test9/fs/Kconfig	2003-11-15 08:29:11.000000000 +0100
@@ -1402,6 +1402,15 @@ config NFSD_V3
 	  If you would like to include the NFSv3 server as well as the NFSv2
 	  server, say Y here.  If unsure, say Y.
 
+config NFSD_ACL
+	bool "NFS_ACL protocol extension"
+	depends on NFSD_V3
+	help
+	  Implement the NFS_ACL protocol extension for manipulating POSIX
+	  Access Control Lists on exported file systems.  The clients must
+	  also implement the NFS_ACL protocol extension; see the
+	  CONFIG_NFS_ACL option.  If unsure, say N.
+
 config NFSD_V4
 	bool "Provide NFSv4 server support (EXPERIMENTAL)"
 	depends on NFSD_V3 && EXPERIMENTAL
Index: linux-2.6.0-test9/fs/nfsacl.c
===================================================================
--- linux-2.6.0-test9.orig/fs/nfsacl.c	2003-08-25 21:12:19.000000000 +0200
+++ linux-2.6.0-test9/fs/nfsacl.c	2003-11-16 12:36:44.000000000 +0100
@@ -0,0 +1,207 @@
+/*
+ * linux/fs/nfsacl.c
+ *
+ *  Copyright (C) 2002 by Andreas Gruenbacher <a.gruenbacher@computer.org>
+ */
+
+/*
+ * The Solaris nfsacl protocol represents some ACLs slightly differently
+ * than POSIX 1003.1e draft 17 does (and we do):
+ *
+ *  - Minimal ACLs always have an ACL_MASK entry, so they have
+ *    four instead of three entries.
+ *  - The ACL_MASK entry in such minimal ACLs always has the same
+ *    permissions as the ACL_GROUP_OBJ entry. (In extended ACLs
+ *    the ACL_MASK and ACL_GROUP_OBJ entries may differ.)
+ *  - The identifier fields of the ACL_USER_OBJ and ACL_GROUP_OBJ
+ *    entries contain the identifiers of the owner and owning group.
+ *    (In POSIX ACLs we always set them to ACL_UNDEFINED_ID).
+ *  - ACL entries in the kernel are kept sorted in ascending order
+ *    of (e_tag, e_id). Solaris ACLs are unsorted.
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/nfsacl.h>
+#include <linux/nfs3.h>
+
+EXPORT_SYMBOL(nfsacl_encode);
+EXPORT_SYMBOL(nfsacl_decode);
+
+u32 *
+nfsacl_encode(u32 *p, u32 *end, struct inode *inode, struct posix_acl *acl,
+	      int encode_entries, int typeflag)
+{
+	int entries = acl ? acl->a_count : 0;
+	
+	if (entries == 3)
+		entries++;  /* need to fake up ACL_MASK entry */
+	if (entries > NFS3_ACL_MAX_ENTRIES ||
+	    p + 2 + (encode_entries ? (3 * entries) : 0) > end)
+		return NULL;
+	*p++ = htonl(entries);
+	if (acl && encode_entries) {
+		struct posix_acl_entry *pa, *pe;
+		int group_obj_perm = ACL_READ|ACL_WRITE|ACL_EXECUTE;
+
+		*p++ = htonl(entries);
+		FOREACH_ACL_ENTRY(pa, acl, pe) {
+			*p++ = htonl(pa->e_tag | typeflag);
+			switch(pa->e_tag) {
+				case ACL_USER_OBJ:
+					*p++ = htonl(inode->i_uid);
+					break;
+				case ACL_GROUP_OBJ:
+					*p++ = htonl(inode->i_gid);
+					group_obj_perm = pa->e_perm;
+					break;
+				case ACL_USER:
+				case ACL_GROUP:
+					*p++ = htonl(pa->e_id);
+					break;
+				default:  /* Solaris depends on that! */
+					*p++ = 0;
+					break;
+			}
+			*p++ = htonl(pa->e_perm & S_IRWXO);
+		}
+		if (acl->a_count < entries) {
+			/* fake up ACL_MASK entry */
+			*p++ = htonl(ACL_MASK | typeflag);
+			*p++ = htonl(ACL_UNDEFINED_ID);
+			*p++ = htonl(group_obj_perm & S_IRWXO);
+		}
+	} else
+		*p++ = 0;
+
+	return p;
+}
+
+#if 0
+static int
+cmp_acl_entry(const struct posix_acl_entry *a, const struct posix_acl_entry *b)
+{
+	if (a->e_tag != b->e_tag)
+		return a->e_tag - b->e_tag;
+	else if (a->e_id > b->e_id)
+		return 1;
+	else if (a->e_id < b->e_id)
+		return -1;
+	else
+		return 0;
+}
+#endif
+
+/*
+ * Convert from a Solaris ACL to a POSIX 1003.1e draft 17 ACL.
+ */
+static int
+posix_acl_from_nfsacl(struct posix_acl *acl)
+{
+	struct posix_acl_entry *pa, *pe,
+	       *group_obj = NULL, *mask = NULL;
+
+	if (!acl)
+		return 0;
+
+#if 0
+	qsort(acl->a_entries, acl->a_count, sizeof(struct posix_acl_entry),
+	      (int(*)(const void *,const void *))cmp_acl_entry);
+#endif
+
+	/* Clear undefined identifier fields and find the ACL_GROUP_OBJ
+	   and ACL_MASK entries. */
+	FOREACH_ACL_ENTRY(pa, acl, pe) {
+		switch(pa->e_tag) {
+			case ACL_USER_OBJ:
+				pa->e_id = ACL_UNDEFINED_ID;
+				break;
+			case ACL_GROUP_OBJ:
+				pa->e_id = ACL_UNDEFINED_ID;
+				group_obj = pa;
+				break;
+			case ACL_MASK:
+				mask = pa;
+				/* fall through */
+			case ACL_OTHER:
+				pa->e_id = ACL_UNDEFINED_ID;
+				break;
+		}
+	}
+	if (acl->a_count == 4 && group_obj && mask &&
+	    mask->e_perm == group_obj->e_perm) {
+		/* remove bogus ACL_MASK entry */
+		memmove(mask, mask+1, (acl->a_entries + 4 - mask) *
+				      sizeof(struct posix_acl_entry));
+		acl->a_count = 3;
+	}
+	return 0;
+}
+
+static u32 *
+nfsacl_decode_entry(u32 *p, struct posix_acl_entry *entry)
+{
+	entry->e_tag = ntohl(*p++) & ~NFS3_ACL_DEFAULT;
+	entry->e_id = ntohl(*p++);
+	entry->e_perm = ntohl(*p++);
+
+	switch(entry->e_tag) {
+		case ACL_USER_OBJ:
+		case ACL_USER:
+		case ACL_GROUP_OBJ:
+		case ACL_GROUP:
+		case ACL_OTHER:
+			if (entry->e_perm & ~S_IRWXO)
+				return NULL;
+			break;
+		case ACL_MASK:
+			/* Solaris sometimes sets additonal bits in the mask */
+			entry->e_perm &= S_IRWXO;
+			break;
+		default:
+			return NULL;
+	}
+	return p;
+}
+
+u32 *
+nfsacl_decode(u32 *p, u32 *end, unsigned int *aclcnt, struct posix_acl **pacl)
+{
+	struct posix_acl_entry *pa, *pe;
+	unsigned int entries, array_len;
+
+	if (p + 2 > end)
+		return NULL;
+	entries = ntohl(*p++);
+	array_len = ntohl(*p++);
+	if (entries > NFS3_ACL_MAX_ENTRIES || (pacl && entries != array_len))
+		return NULL;
+	if (p + 3 * array_len > end)
+		return NULL;
+	if (pacl) {
+		*pacl = NULL;
+		if (entries) {
+			struct posix_acl *acl;
+			
+			if (!(acl = posix_acl_alloc(array_len, GFP_KERNEL)))
+				return NULL;
+			FOREACH_ACL_ENTRY(pa, acl, pe) {
+				if (!(p = nfsacl_decode_entry(p, pa))) {
+					posix_acl_release(acl);
+					return NULL;
+				}
+			}
+			if (posix_acl_from_nfsacl(acl) != 0) {
+				posix_acl_release(acl);
+				return NULL;
+			}
+			*pacl = acl;
+		}
+	} else 
+		p += 3 * array_len;
+
+	if (aclcnt)
+		*aclcnt = entries;
+	return p;
+}
+
Index: linux-2.6.0-test9/net/sunrpc/xdr.c
===================================================================
--- linux-2.6.0-test9.orig/net/sunrpc/xdr.c	2003-10-25 20:44:06.000000000 +0200
+++ linux-2.6.0-test9/net/sunrpc/xdr.c	2003-11-17 16:00:13.000000000 +0100
@@ -568,6 +568,27 @@ _copy_from_pages(char *p, struct page **
 }
 
 /*
+ * copy_from_xdr
+ * @p: pointer to destination
+ * @buf: xdr_buf
+ *
+ * Copies data into an arbitrary memory location from an XDR buffer.
+ * The copy is assumed to be non-overlapping.
+ */
+void
+copy_from_xdr(char *p, struct xdr_buf *buf)
+{
+	struct iovec *head = buf->head, *tail = buf->tail;
+	memcpy(p, head->iov_base, head->iov_len);
+	p += head->iov_len;
+	if (buf->page_len) {
+		_copy_from_pages(p, buf->pages, buf->page_base, buf->page_len);
+		p += buf->page_len;
+	}
+	memcpy(p, tail->iov_base, tail->iov_len);
+}
+
+/*
  * xdr_shrink_bufhead
  * @buf: xdr_buf
  * @len: bytes to remove from buf->head[0]
Index: linux-2.6.0-test9/include/linux/nfsd/stats.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/nfsd/stats.h	2003-10-25 20:43:27.000000000 +0200
+++ linux-2.6.0-test9/include/linux/nfsd/stats.h	2003-11-15 08:29:11.000000000 +0100
@@ -36,6 +36,7 @@ struct nfsd_stats {
 
 extern struct nfsd_stats	nfsdstats;
 extern struct svc_stat		nfsd_svcstats;
+extern struct svc_stat		nfsd_acl_svcstats;
 
 void	nfsd_stat_init(void);
 void	nfsd_stat_shutdown(void);
Index: linux-2.6.0-test9/include/linux/nfsd/nfsd.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/nfsd/nfsd.h	2003-10-25 20:44:51.000000000 +0200
+++ linux-2.6.0-test9/include/linux/nfsd/nfsd.h	2003-11-15 08:29:11.000000000 +0100
@@ -15,6 +15,7 @@
 #include <linux/unistd.h>
 #include <linux/dirent.h>
 #include <linux/fs.h>
+#include <linux/posix_acl.h>
 #include <linux/mount.h>
 
 #include <linux/nfsd/debug.h>
@@ -60,6 +61,8 @@ extern struct svc_program	nfsd_program;
 extern struct svc_version	nfsd_version2, nfsd_version3,
 				nfsd_version4;
 
+extern struct svc_program	nfsd_acl_program;
+extern struct svc_version	nfsd_acl_version3;
 /*
  * Function prototypes.
  */
@@ -119,6 +122,22 @@ int		nfsd_statfs(struct svc_rqst *, stru
 int		nfsd_notify_change(struct inode *, struct iattr *);
 int		nfsd_permission(struct svc_export *, struct dentry *, int);
 
+#ifdef CONFIG_NFSD_ACL
+struct posix_acl *nfsd_get_posix_acl(struct svc_fh *, int);
+int nfsd_set_posix_acl(struct svc_fh *, int, struct posix_acl *);
+#else
+static inline struct posix_acl *
+nfsd_get_posix_acl(struct svc_fh *fhp, int acl_type)
+{
+	return ERR_PTR(-EOPNOTSUPP);
+}
+static inline int
+nfsd_set_posix_acl(struct svc_fh *fhp, int type, struct posix_acl *acl)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
 
 /* 
  * NFSv4 State
Index: linux-2.6.0-test9/include/linux/nfsd/xdr3.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/nfsd/xdr3.h	2003-10-25 20:43:19.000000000 +0200
+++ linux-2.6.0-test9/include/linux/nfsd/xdr3.h	2003-11-15 08:29:11.000000000 +0100
@@ -10,6 +10,7 @@
 #define _LINUX_NFSD_XDR3_H
 
 #include <linux/nfsd/xdr.h>
+#include <linux/posix_acl.h>
 
 struct nfsd3_sattrargs {
 	struct svc_fh		fh;
@@ -110,6 +111,18 @@ struct nfsd3_commitargs {
 	__u32			count;
 };
 
+struct nfsd3_getaclargs {
+	struct svc_fh		fh;
+	int			mask;
+};
+
+struct nfsd3_setaclargs {
+	struct svc_fh		fh;
+	int			mask;
+	struct posix_acl	*acl_access;
+	struct posix_acl	*acl_default;
+};
+
 struct nfsd3_attrstat {
 	__u32			status;
 	struct svc_fh		fh;
@@ -208,6 +221,14 @@ struct nfsd3_commitres {
 	struct svc_fh		fh;
 };
 
+struct nfsd3_getaclres {
+	__u32			status;
+	struct svc_fh		fh;
+	int			mask;
+	struct posix_acl	*acl_access;
+	struct posix_acl	*acl_default;
+};
+
 /* dummy type for release */
 struct nfsd3_fhandle_pair {
 	__u32			dummy;
@@ -240,6 +261,7 @@ union nfsd3_xdrstore {
 	struct nfsd3_fsinfores		fsinfores;
 	struct nfsd3_pathconfres	pathconfres;
 	struct nfsd3_commitres		commitres;
+	struct nfsd3_getaclres		getaclres;
 };
 
 #define NFS3_SVC_XDRSIZE		sizeof(union nfsd3_xdrstore)
@@ -275,6 +297,10 @@ int nfs3svc_decode_readdirplusargs(struc
 				struct nfsd3_readdirargs *);
 int nfs3svc_decode_commitargs(struct svc_rqst *, u32 *,
 				struct nfsd3_commitargs *);
+int nfs3svc_decode_getaclargs(struct svc_rqst *, u32 *,
+			      struct nfsd3_getaclargs *);
+int nfs3svc_decode_setaclargs(struct svc_rqst *, u32 *,
+			      struct nfsd3_setaclargs *);
 int nfs3svc_encode_voidres(struct svc_rqst *, u32 *, void *);
 int nfs3svc_encode_attrstat(struct svc_rqst *, u32 *,
 				struct nfsd3_attrstat *);
@@ -304,11 +330,17 @@ int nfs3svc_encode_pathconfres(struct sv
 				struct nfsd3_pathconfres *);
 int nfs3svc_encode_commitres(struct svc_rqst *, u32 *,
 				struct nfsd3_commitres *);
+int nfs3svc_encode_getaclres(struct svc_rqst *, u32 *,
+			     struct nfsd3_getaclres *);
+int nfs3svc_encode_setaclres(struct svc_rqst *, u32 *,
+			     struct nfsd3_attrstat *);
 
 int nfs3svc_release_fhandle(struct svc_rqst *, u32 *,
 				struct nfsd3_attrstat *);
 int nfs3svc_release_fhandle2(struct svc_rqst *, u32 *,
 				struct nfsd3_fhandle_pair *);
+int nfs3svc_release_getacl(struct svc_rqst *rqstp, u32 *p,
+			   struct nfsd3_getaclres *resp);
 int nfs3svc_encode_entry(struct readdir_cd *, const char *name,
 				int namlen, loff_t offset, ino_t ino,
 				unsigned int);
Index: linux-2.6.0-test9/include/linux/nfs3.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/nfs3.h	2003-10-25 20:44:02.000000000 +0200
+++ linux-2.6.0-test9/include/linux/nfs3.h	2003-11-17 13:54:10.000000000 +0100
@@ -37,6 +37,18 @@ enum nfs3_createmode {
 	NFS3_CREATE_EXCLUSIVE = 2
 };
 
+/* Flags for the getacl/setacl mode */
+#define NFS3_ACL		0x0001
+#define NFS3_ACLCNT		0x0002
+#define NFS3_DFACL		0x0004
+#define NFS3_DFACLCNT		0x0008
+
+/* Flag for Default ACL entries */
+#define NFS3_ACL_DEFAULT	0x1000
+
+/* Maximum number of ACL entries over NFS */
+#define NFS3_ACL_MAX_ENTRIES	1024
+
 /* NFSv3 file system properties */
 #define NFS3_FSF_LINK		0x0001
 #define NFS3_FSF_SYMLINK	0x0002
@@ -88,6 +100,10 @@ struct nfs3_fh {
 #define NFS3PROC_PATHCONF	20
 #define NFS3PROC_COMMIT		21
 
+#define NFS3_ACL_PROGRAM	100227
+#define NFS3PROC_GETACL		1
+#define NFS3PROC_SETACL		2
+
 #define NFS_MNT3_PROGRAM	100005
 #define NFS_MNT3_VERSION	3
 #define MOUNTPROC3_NULL		0
Index: linux-2.6.0-test9/include/linux/sunrpc/xdr.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/sunrpc/xdr.h	2003-10-25 20:44:58.000000000 +0200
+++ linux-2.6.0-test9/include/linux/sunrpc/xdr.h	2003-11-16 13:33:08.000000000 +0100
@@ -218,6 +218,8 @@ xdr_reserve_space(struct xdr_stream *xdr
 	return p;
 }
 
+extern void copy_from_xdr(char *p, struct xdr_buf *buf);
+
 extern void xdr_write_pages(struct xdr_stream *xdr, struct page **pages,
 		unsigned int base, unsigned int len);
 extern void xdr_read_pages(struct xdr_stream *xdr, unsigned int len);
Index: linux-2.6.0-test9/include/linux/nfsacl.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/nfsacl.h	2003-08-25 21:12:19.000000000 +0200
+++ linux-2.6.0-test9/include/linux/nfsacl.h	2003-11-16 13:32:47.000000000 +0100
@@ -0,0 +1,18 @@
+/*
+ * File: linux/nfsacl.h
+ *
+ * (C) 2003 Andreas Gruenbacher <agruen@suse.de>
+ */
+
+
+#ifndef __LINUX_NFSACL_H
+#define __LINUX_NFSACL_H
+
+#include <linux/posix_acl.h>
+
+extern u32 *nfsacl_encode(u32 *, u32 *, struct inode *, struct posix_acl *,
+			  int, int);
+extern u32 *nfsacl_decode(u32 *, u32 *, unsigned int *, struct posix_acl **);
+
+#endif  /* __LINUX_NFSACL_H */
+
