# This is a BitKeeper generated patch for the following project:
# Project Name: Linux 2.6 Kernel
# This patch format is intended for GNU patch command version 2.5 or higher.
# This patch includes the following deltas:
#	           ChangeSet	1.19    -> 1.34   
#	include/linux/sched.h	1.13    -> 1.14   
#	include/asm-i386/unistd.h	1.4     -> 1.6    
#	       kernel/exit.c	1.10    -> 1.11   
#	            Makefile	1.16    -> 1.18   
#	         init/main.c	1.10    -> 1.13   
#	arch/i386/kernel/entry.S	1.5     -> 1.7    
#	       kernel/fork.c	1.12    -> 1.13   
#	          fs/Kconfig	1.7     -> 1.8    
#	     kernel/Makefile	1.7     -> 1.8    
#	         fs/Makefile	1.4     -> 1.5    
#	           fs/exec.c	1.8     -> 1.9    
#	        kernel/sys.c	1.11    -> 1.12   
#	       kernel/user.c	1.2     -> 1.4    
#	   arch/i386/Kconfig	1.10    -> 1.13   
#	               (new)	        -> 1.4     include/linux/ckrm_rc.h
#	               (new)	        -> 1.6     include/linux/ckrm_ce.h
#	               (new)	        -> 1.1     kernel/ckrm/ckrmstub.c
#	               (new)	        -> 1.2     fs/rcfs/magic_config.c
#	               (new)	        -> 1.2     include/linux/ckrm.h
#	               (new)	        -> 1.3     fs/rcfs/magic_target.c
#	               (new)	        -> 1.2     include/linux/ckrm_res.h
#	               (new)	        -> 1.7     fs/rcfs/rcfs.h 
#	               (new)	        -> 1.6     fs/rcfs/super.c
#	               (new)	        -> 1.9     fs/rcfs/inode.c
#	               (new)	        -> 1.1     kernel/ckrm/ckrm_socketaq.c
#	               (new)	        -> 1.8     fs/rcfs/dir.c  
#	               (new)	        -> 1.10    kernel/ckrm/ckrm.c
#	               (new)	        -> 1.5     kernel/ckrm/ckrm_dummy.c
#	               (new)	        -> 1.4     fs/rcfs/magic.h
#	               (new)	        -> 1.1     kernel/ckrm/ckrmutils.c
#	               (new)	        -> 1.4     fs/rcfs/Makefile
#	               (new)	        -> 1.3     fs/rcfs/file.c 
#	               (new)	        -> 1.4     fs/rcfs/MOVETOCORE.h
#	               (new)	        -> 1.5     fs/rcfs/magic_shares.c
#	               (new)	        -> 1.1     fs/rcfs/magic_members.c
#	               (new)	        -> 1.3     fs/rcfs/magic_stats.c
#	               (new)	        -> 1.2     kernel/ckrm/Makefile
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 04/03/05	nagar@elinux03.watson.ibm.com	1.20
# rcfs-2.6-patch
# --------------------------------------------
# 04/03/08	nagar@elinux03.watson.ibm.com	1.21
# SN: Added magic share file handling, fake code for hooking up to core 
# (to be removed on real integration), separated out some files and
# added disabled/nonfunctioning code for automatic generation of files
# on directory creation. 
# --------------------------------------------
# 04/03/09	nagar@elinux03.watson.ibm.com	1.22
# Working (standalone) version of rcfs with directory, inode and (magic)
# file operations for target/share/stats/config separated cleanly.
# 
# If user creates the magic files by hand, input/output is in the format
# desired (without any side effects of calling real core code).
# 
# Code for automatic creation/deletion of files is present but oopses.
# Commented out for now.
# 
# This patchset is ready for integration with Core/RBCE/Dummy controllers.
# --------------------------------------------
# 04/03/09	nagar@elinux03.watson.ibm.com	1.23
# ckrm-core-E0
# --------------------------------------------
# 04/03/10	nagar@elinux03.watson.ibm.com	1.24
# Dump for HF debugging
# --------------------------------------------
# 04/03/10	nagar@elinux03.watson.ibm.com	1.25
# Dump for HF debugging
# --------------------------------------------
# 04/03/10	nagar@elinux03.watson.ibm.com	1.26
# rcfscore-E0 : First cut of rcfs-core integration with mkdir/rmdir working properly
# including creation/deletion of a hierarchy of classes. Tested by hand
# creation/deletion of directory hierarchies (thus no timing/locking
# issues handled yet).
# --------------------------------------------
# 04/03/11	nagar@elinux03.watson.ibm.com	1.27
# rcfscore-E1
# 
# Assorted changes to integrate rcfs with Core + Dummy Resource 
# Controller.
# What works: 
# - share get/set, stats get for res=dummy in any hierarchy level
# - creation/deletion of classes in hierarchy 
# This largely completes the first integration of rcfs with Core+Dummy.
# Locking issues not examined properly - simple testing using 
# single commands at user level done.
# --------------------------------------------
# 04/03/11	nagar@elinux03.watson.ibm.com	1.28
# Changes to interface with RBCE - first cut. Not run.
# --------------------------------------------
# 04/03/11	nagar@elinux03.watson.ibm.com	1.29
# rcfscore-E2
# Minor changes to get rbce running properly with a common ckrm_ce.h
# Tested with rbce loaded and rules files created.
# --------------------------------------------
# 04/03/15	nagar@elinux03.watson.ibm.com	1.30
# rcfscore-E3
# 
# Added changes to 
# - do better locking on CE callbacks
# - automatic creation/deletion of magic files/directories
# 
# Tested to work with 10 level deep directory creation and deletion
# at command line (using mkdir/rmdir -p) with printk's in. 
# Same code without autocreation/deletion of dirs fails when more than
# two levels created (upto two is ok). Needs debugging.
# --------------------------------------------
# 04/03/16	nagar@elinux03.watson.ibm.com	1.31
# Changes from rbce-v3. Untested.
# --------------------------------------------
# 04/03/16	nagar@elinux03.watson.ibm.com	1.32
# Minor change to Chandra's set from rbce-v3.
# 
# As of this point, creation of deep directories (> 2 levels, using 
# mkdir -p 1/2/3) results in an oops. Most probably not to do with the
# code additions as it has been seen before....triggered earlier by
# automagic creation (which has currently been disabled - still see oops).
# Should not affect regular rbce/CE testing.
# --------------------------------------------
# 04/03/17	nagar@elinux03.optonline.net	1.33
# remove syscalls, add debug code, ensure ckrm_init called early and
# tasks created before it is called are classified into default.
# --------------------------------------------
# 04/03/17	nagar@elinux03.optonline.net	1.34
# rcfs-core-E5: also ckrm-F1
# 
# Integrate socketaq controller and required interface changes 
# throughout rcfs and core.
# 
# -Creates /rcfs/network and /rcfs/network/socketaq 
# -allows class creation in /rcfs
# -RBCE tested to work properly i.e.
#   - /rcfs/rules created, rules populated using classes from /rcfs/*
# -magic files shares, stats work imperfectly
# but report errors (probably unnecessarily)
# -magic file members does not show pids
# -magic file config not being used
# 
# 
# 
# --------------------------------------------
#
Index: linux-2.6.5/fs/rcfs/Makefile
===================================================================
--- linux-2.6.5.orig/fs/rcfs/Makefile	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/Makefile	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for rcfs routines.
+#
+
+obj-$(CONFIG_RCFS_FS) += rcfs.o
+
+rcfs-objs := super.o inode.o dir.o file.o magic_shares.o magic_stats.o magic_target.o magic_config.o magic_members.o
Index: linux-2.6.5/fs/rcfs/dir.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/dir.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/dir.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,290 @@
+/* 
+ * fs/rcfs/dir.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *               Vivek Kashyap,   IBM Corp. 2004
+ *           
+ * 
+ * Directory operations for rcfs
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 08 Mar 2004
+ *        Created.
+ */
+
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
+#include <linux/parser.h>
+
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+#include "magic.h"
+
+
+rbce_eng_callback_t rcfs_eng_callbacks = {
+	NULL, NULL
+};
+/* Helper functions */
+
+#define rcfs_positive(dentry)  ((dentry)->d_inode && !d_unhashed((dentry)))
+
+static
+int rcfs_empty(struct dentry *dentry)
+{
+	struct dentry *child;
+	int ret = 0;
+
+	/* Don't use now - don't know if its safe to take the dcache_lock */
+	return 0 ;
+
+	spin_lock(&dcache_lock);
+	list_for_each_entry(child, &dentry->d_subdirs, d_child) 
+		if (!rcfs_is_magic(child) && rcfs_positive(child))
+			goto out;
+	ret = 1;
+out:
+	spin_unlock(&dcache_lock);
+	return ret;
+}
+
+
+
+int 
+rcfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+{
+	// USEME later when files are only created automagically
+	// return -EPERM;
+	return rcfs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+
+/* Directory inode operations */
+
+
+/* Symlinks permitted ?? */
+int  
+rcfs_symlink(struct inode * dir, struct dentry *dentry, const char * symname)
+{
+	struct inode *inode;
+	int error = -ENOSPC;
+
+	inode = rcfs_get_inode(dir->i_sb, S_IFLNK|S_IRWXUGO, 0);
+	if (inode) {
+		int l = strlen(symname)+1;
+		error = page_symlink(inode, symname, l);
+		if (!error) {
+			if (dir->i_mode & S_ISGID)
+				inode->i_gid = dir->i_gid;
+			d_instantiate(dentry, inode);
+			dget(dentry);
+		} else
+			iput(inode);
+	}
+	return error;
+}
+
+
+int 
+rcfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	extern struct dentry *rcfs_nwde;
+	struct dentry *ldentry;
+	int retval;
+	int mfmode,i,j;
+	struct rcfs_inode_info *ripar,*ridir;
+	struct dentry *pd = list_entry(dir->i_dentry.next, struct dentry, d_alias);
+
+//	printk(KERN_ERR "rcfs_mkdir called with dir=%p dentry=%p mode=%d\n",dir,dentry,mode);
+
+	if ((!strcmp(pd->d_name.name, "/") &&
+				!strcmp(dentry->d_name.name, "ce"))) {
+		// Call CE's mkdir if it has registered, else fail.
+		if (rcfs_eng_callbacks.mkdir) {
+			return (*rcfs_eng_callbacks.mkdir)(dir, dentry, mode);
+		} else {
+			return -EINVAL;
+		}
+	}
+	// Creation in /rcfs/network is not allowed
+	// XXX - would be good to instead add a check with the parent's 
+	// core class
+	if (dir == rcfs_nwde->d_inode)
+		return -EPERM;
+
+
+	retval  = rcfs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	if (retval) {
+		printk(KERN_ERR "rcfs_mkdir: error reaching parent\n");
+		return retval;
+	}
+
+	dir->i_nlink++;
+
+	ripar = RCFS_I(dir);
+	ridir = RCFS_I(dentry->d_inode);
+
+	/* Inform RC's - do Core operations */
+	/* On error, goto mkdir_err */
+
+	if (is_core_valid(ripar->core))
+		ridir->core = ckrm_alloc_core_class((ckrm_core_class_t *)ripar->core, 
+						    dentry);
+	else {
+		printk(KERN_ERR "rcfs_mkdir: Invalid parent core \n");
+		return -EINVAL;
+	}
+
+#if 0
+	mfmode = S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;	
+	for (i=0; i < NR_MAGF; i++) {
+		ldentry = 
+			rcfs_create_internal(dentry, magf[i].name, mfmode, 0);
+		if (!ldentry)
+			break;
+		ldentry->d_fsdata = &RCFS_IS_MAGIC;
+	}
+
+	printk(KERN_ERR "rcfs_mkdir: core cls(%s, inode %p, ri %p, core %p) created\n",
+	       dentry->d_name.name, dentry->d_inode, ridir, ridir->core);
+
+
+	/* Create magic files, directories */
+	
+//
+//	for (i=0; i<NR_MAGF; i++) {
+//	        if (rcfs_create_magic(dentry, &magf[i]))
+//			break;
+//	}
+
+	if (i != NR_MAGF) { /* Error creating any magic file */
+		printk(KERN_ERR "Error creating magic files %d\n",i);
+		rcfs_delete_all_magic(dentry);
+		goto mkdir_err ;
+	}
+#endif
+		
+	return retval;
+
+mkdir_err:
+	dir->i_nlink--;
+	return -EINVAL;
+}
+
+
+int 
+rcfs_rmdir(struct inode * dir, struct dentry * dentry)
+{
+	int i;
+	int retval;
+	struct rcfs_inode_info *ri = RCFS_I(dentry->d_inode);
+	struct dentry *pd = list_entry(dir->i_dentry.next, struct dentry, d_alias);
+
+	
+//	printk(KERN_ERR "dir %p, dentry name %s inode %p, parent name %s inode %p\n", dir, dentry->d_name.name, dentry->d_inode, dentry->d_parent->d_name.name, dentry->d_parent->d_inode);
+	
+
+	/* Class about to be deleted.
+	   Order of operations
+	   - underlying rcfs entry removal (so no new ops initiated from user space)
+	   - Core class removal (should handle CE initiated changes as well)
+	   - rcfs dir removal 
+	*/
+
+
+	/* Ensure following first
+	   a) members/ subdir empty.
+	   b) no subdirs except members, no files except magic (latter not necessary
+	      once we disallow all file creation.
+	   c) remove members/ & magic files
+	   If errors doing any of those, barf.
+	*/
+
+#if 0
+	rcfs_delete_all_magic(dentry);
+#endif
+
+	/* Core class removal */
+	//printk(KERN_ERR "About to remove %s ( %p)\n",dentry->d_name.name, ri);
+	
+	if ((!strcmp(pd->d_name.name, "/") &&
+				!strcmp(dentry->d_name.name, "ce"))) {
+		// Call CE's mkdir if it has registered, else fail.
+		if (rcfs_eng_callbacks.rmdir) {
+			return (*rcfs_eng_callbacks.rmdir)(dir, dentry);
+		} else {
+			return simple_rmdir(dir, dentry);
+		}
+	}
+	if (ckrm_free_core_class(ri->core)) {
+		printk(KERN_ERR "rcfs_rmdir: ckrm_free_core_class failed\n");
+		goto recreate_magic;
+	}
+	ri->core = NULL ; /* just to be safe */
+
+	dentry->d_inode->i_nlink--;	
+	return simple_rmdir(dir, dentry);
+
+recreate_magic:
+	printk("rcfs_rmdir: should recreate magic files here. Do manually now\n");
+rmdir_err:
+	return -EINVAL;
+}
+
+int
+rcfs_register_engine(rbce_eng_callback_t *rcbs)
+{
+	if (!rcbs->mkdir || rcfs_eng_callbacks.mkdir) {
+		return -EINVAL;
+	}
+	rcfs_eng_callbacks = *rcbs;
+	return 0;
+}
+
+int
+rcfs_unregister_engine(rbce_eng_callback_t *rcbs)
+{
+	if (!rcbs->mkdir || !rcfs_eng_callbacks.mkdir ||
+			(rcbs->mkdir != rcfs_eng_callbacks.mkdir)) {
+		return -EINVAL;
+	}
+	rcfs_eng_callbacks.mkdir = NULL;
+	rcfs_eng_callbacks.rmdir = NULL;
+	return 0;
+}
+
+struct inode_operations rcfs_dir_inode_operations = {
+	.create		= rcfs_create,
+	.lookup		= simple_lookup,
+	.link		= simple_link,
+	.unlink		= simple_unlink,
+	.symlink	= rcfs_symlink,
+	.mkdir		= rcfs_mkdir,
+	.rmdir          = rcfs_rmdir,
+	.mknod		= rcfs_mknod,
+	.rename		= simple_rename,
+};
+
+EXPORT_SYMBOL(rcfs_register_engine);
+EXPORT_SYMBOL(rcfs_unregister_engine);
Index: linux-2.6.5/fs/rcfs/magic_config.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/magic_config.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/magic_config.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,214 @@
+/* 
+ * fs/rcfs/magic_config.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *           
+ * 
+ * virtual file for setting/getting configuration values of a 
+ * task class. Part of resource class file system (rcfs) 
+ * interface to Class-based Kernel Resource Management (CKRM).
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 08 Mar 2004
+ *        Created.
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/parser.h>
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+#include "MOVETOCORE.h"
+
+
+/* Currently there are no per-class config parameters defined.
+ * 
+ */
+
+
+#define CONFIG_MAX_INPUT_SIZE  300
+
+enum config_token_t {
+         CONFIG_STR, RES_TYPE, CONFIG_ERR
+};
+
+static match_table_t tokens = {
+	{RES_TYPE, "res=%s"},
+	{CONFIG_STR, "config=%s"},
+        {CONFIG_ERR, NULL},
+};
+
+static int config_parse(char *options, int *resid, char **cfgstr)
+{
+	char *p,resname[CKRM_MAX_RES_NAME];
+
+	if (!options)
+		return 1;
+	
+	//printk(KERN_ERR "options |%s|\n",options);
+	while ((p = strsep(&options, ",")) != NULL) {
+		
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		
+		//printk(KERN_ERR "p |%s| options |%s|\n",p,options);
+
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		//printk(KERN_ERR "Token %d\n",token);
+		switch (token) {
+			
+		case RES_TYPE:
+
+			match_strcpy(resname,args);
+			*resid = ckrm_resid_lookup(resname);
+			break;
+			
+		case CONFIG_STR:
+			
+			*cfgstr = match_strdup(args);
+			break;
+
+		default:
+			return 0;
+		}
+
+	}
+	return 1;
+}	
+
+/* Poorly written currently. Strings with spaces will not be accepted */
+/* Parser.c isn't buying us much here. Manual parsing might be better */
+
+static ssize_t
+config_write(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	struct rcfs_inode_info *ri = RCFS_I(file->f_dentry->d_inode);
+	char *optbuf, *cfgstr;
+	int done;
+	int resid ;
+
+	if ((ssize_t) count < 0 || (ssize_t) count > CONFIG_MAX_INPUT_SIZE)
+		return -EINVAL;
+	
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+	
+	down(&(ri->vfs_inode.i_sem));
+	
+	optbuf = kmalloc(CONFIG_MAX_INPUT_SIZE, GFP_KERNEL);
+	__copy_from_user(optbuf, buf, count);
+
+	/* cat > shares puts in an extra newline */
+	if (optbuf[count-1] == '\n')
+		optbuf[count-1]='\0';
+
+	done = config_parse(optbuf, &resid, &cfgstr);
+
+	if (!done) {
+		printk(KERN_ERR "Error parsing config \n");
+		goto config_out;
+	}
+
+#if 0
+	/* Error control ? */
+	if (resid && ckrm_isregd(resid)) {
+		if (ckrm_res_ctlrs[resid].set_config)
+			(*ckrm_res_ctlrs[resid].set_config)(ri->core->resclass[resid],cfgstr) ;
+
+	}				
+#endif	
+	
+	printk(KERN_ERR "Set %d's config using %s\n", resid, cfgstr);
+	
+config_out:
+	
+	up(&(ri->vfs_inode.i_sem));
+	kfree(optbuf);
+	kfree(cfgstr);
+	return count;
+}
+
+static int 
+config_show(struct seq_file *s, void *v)
+{
+	int resid;
+
+	// USEME struct rcfs_inode_info *rinfo = RCFS_I(s->private) ;
+
+	/* Get and "display" config data for each registered resource.
+	 * Data from each resource is atomic but not across resources
+	 */
+	
+	for_each_resid(resid) {
+
+/*		if (ckrm_isregd(resid) && 
+		    ckrm_get_res_ctrlrs[resid].get_config) {
+		    if ((*(ckrm_get_res_ctrlrs[resid].get_config)(s)) < 0)
+		           goto config_out;
+                }
+*/
+		seq_printf(s, "Showing configs 1 2 3 for res %d\n",resid);
+	}
+
+	return 0;
+
+show_out:
+
+	seq_printf(s,"Error retrieving contents of next RC. Aborting\n");
+	return 0;
+}	
+
+static int 
+config_open(struct inode *inode, struct file *file)
+{
+	int ret = single_open(file, config_show, file);
+
+	/* Store inode in seq_file->private to allow  core class retrieval later
+	   in seq_file start
+	   If seq_file not used, inode is directly available on read */
+
+	/* USEME
+	if (ret)
+		((struct seq_file *)(file->private_data))->private = inode;
+	*/
+
+	return ret;
+}
+
+static int 
+config_close(struct inode *inode, struct file *file)
+{
+	return single_release(inode,file);
+}
+
+struct file_operations config_fileops = {
+	.open           = config_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = config_close,
+	.write          = config_write,
+};
+
+
Index: linux-2.6.5/fs/rcfs/magic_members.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/magic_members.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/magic_members.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,109 @@
+/* 
+ * fs/rcfs/magic_members.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *           
+ * 
+ * virtual file for getting pids belonging to a class
+ * Part of resource class file system (rcfs) 
+ * interface to Class-based Kernel Resource Management (CKRM).
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 12 Mar 2004
+ *        Created.
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/parser.h>
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+
+
+
+static int 
+members_show(struct seq_file *s, void *v)
+{
+	int retval;
+	ckrm_core_class_t *core ;
+	struct list_head *lh;
+	struct task_struct *tsk;
+
+	/* Get and "display" statistics for each registered resource.
+	 * Data from each resource is "atomic" (depends on RC) 
+	 * but not across resources
+	 */
+
+	core = (ckrm_core_class_t *)(((struct rcfs_inode_info *)s->private)->core);
+
+	if (!is_core_valid(core))
+		return -EINVAL;
+
+	seq_printf(s,"Printing tasks in members of %p\n",core);
+	
+	spin_lock(&core->ckrm_lock);
+//	read_lock(&tasklist_lock);
+//	for_each_process(tsk) {
+	list_for_each(lh, &core->tasklist) {	
+		tsk = container_of(lh, struct task_struct, ckrm_link);
+		seq_printf(s,"%ld\n", (long)tsk->pid);
+	}
+//	read_unlock(&tasklist_lock);
+	spin_unlock(&core->ckrm_lock);
+
+	return 0;
+}	
+
+static int 
+members_open(struct inode *inode, struct file *file)
+{
+	struct rcfs_inode_info *ri;
+	int ret=-EINVAL;
+
+	if (file->f_dentry && file->f_dentry->d_parent) {
+
+		ri = RCFS_I(file->f_dentry->d_parent->d_inode);
+		printk(KERN_ERR "file %s parent %s %p %p\n",
+		       file->f_dentry->d_name.name, 
+		       file->f_dentry->d_parent->d_name.name,
+		       (void *)ri->core, (void *)&ckrm_dflt_class);
+
+		ret = single_open(file, members_show, (void *)ri);
+	}
+	return ret;
+}
+
+
+static int 
+members_close(struct inode *inode, struct file *file)
+{
+	return single_release(inode,file);
+}
+
+struct file_operations members_fileops = {
+	.open           = members_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = members_close,
+};
+
Index: linux-2.6.5/fs/rcfs/magic.h
===================================================================
--- linux-2.6.5.orig/fs/rcfs/magic.h	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/magic.h	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,42 @@
+#ifndef _LINUX_RCFS_MAGIC_H
+#define _LINUX_RCFS_MAGIC_H
+
+#include <linux/fs.h>
+#include <linux/dcache.h>
+
+#define MAGF_NAMELEN 20
+
+struct magf_t {
+	char name[MAGF_NAMELEN];
+	int mode;
+	struct inode_operations *i_op;
+	struct file_operations *i_fop;
+};
+
+
+/* Simpler to index by enum and initialize directly */
+
+
+
+enum MAGF_IDX {
+	MAGF_TARGET = 0,
+	MAGF_SHARES,
+	MAGF_STATS,
+	MAGF_CONFIG,
+	MAGF_MEMBERS,
+	NR_MAGF,	// always the last. Number of entries.
+};
+
+extern struct magf_t magf[NR_MAGF];
+extern int RCFS_IS_MAGIC;
+
+
+int rcfs_create_magic(struct dentry *parent, struct magf_t *magf);
+int rcfs_delete_all_magic(struct dentry *parent);
+
+
+#define rcfs_is_magic(dentry)  ((dentry)->d_fsdata == &RCFS_IS_MAGIC)
+
+
+
+#endif /* _LINUX_RCFS_MAGIC_H */
Index: linux-2.6.5/fs/rcfs/magic_stats.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/magic_stats.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/magic_stats.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,116 @@
+/* 
+ * fs/rcfs/magic_stats.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *           
+ * 
+ * virtual file for getting all statistics for a task class 
+ * in rcfs.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 08 Mar 2004
+ *        Created.
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/parser.h>
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+#include "MOVETOCORE.h"
+#include "magic.h"
+
+static int 
+stats_show(struct seq_file *s, void *v)
+{
+	int resid,retval;
+	struct rcfs_inode_info *ri = s->private;
+
+	/* Get and "display" statistics for each registered resource.
+	 * Data from each resource is "atomic" (depends on RC) 
+	 * but not across resources
+	 */
+
+	if (!ri || !is_core_valid((ckrm_core_class_t *)(ri->core))) {
+		printk(KERN_ERR "stats_show: Error accessing core class\n");
+		return -EFAULT;
+	}
+
+	for_each_resid(resid) {
+		if (is_res_regd(resid)) {
+
+#if 1
+			ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
+			
+			printk(KERN_ERR "Showing %s's stats %p %p\n",rcbs->res_name,ri->core,(void *)((ckrm_core_class_t *)(ri->core))->res_class[resid]);
+		
+			if (rcbs->get_stats) {
+				retval = (*rcbs->get_stats)
+					((void *)((ckrm_core_class_t *)(ri->core))->res_class[resid],s);
+				if (retval) {
+					printk(KERN_ERR "stats_show: resctlr share get error\n");
+					goto show_out;
+				}
+			}
+#endif
+		} /* is_res_regd(resid) */
+	} /* for_each_resid(resid) */
+
+	return 0;
+
+show_out:
+
+	seq_printf(s,"Error retrieving stats of next RC. Aborting\n");
+	return 0;
+}	
+
+static int 
+stats_open(struct inode *inode, struct file *file)
+{
+	struct rcfs_inode_info *ri;
+	int ret=-EINVAL;
+
+	if (file->f_dentry && file->f_dentry->d_parent) {
+
+		printk(KERN_ERR "file %s parent %s\n",
+		       file->f_dentry->d_name.name, 
+		       file->f_dentry->d_parent->d_name.name);
+
+		ri = RCFS_I(file->f_dentry->d_parent->d_inode);
+		ret = single_open(file, stats_show, (void *)ri);
+	}
+	return ret;
+}
+
+static int 
+stats_close(struct inode *inode, struct file *file)
+{
+	return single_release(inode,file);
+}
+
+struct file_operations stats_fileops = {
+	.open           = stats_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = stats_close,
+};
+
+
Index: linux-2.6.5/fs/rcfs/magic_target.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/magic_target.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/magic_target.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,170 @@
+/* 
+ * fs/rcfs/magic_target.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *           
+ * 
+ * virtual file assisting in reclassification in rcfs. 
+ * 
+ * Writing a pid to a class's target file reclassifies the corresponding
+ * task to the class.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 06 Mar 2004
+ *        Created.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/parser.h>
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+#include "MOVETOCORE.h"
+#include "magic.h"
+
+
+#define TARGET_MAX_INPUT_SIZE  300
+
+/* The enums for the share types should match the indices expected by
+   array parameter to ckrm_set_resshare */
+
+/* Note only the first NUM_SHAREVAL enums correspond to share types,
+   the remaining ones are for token matching purposes */
+
+enum target_token_t {
+        PID, RES_TYPE, TARGET_ERR
+};
+
+static match_table_t tokens = {
+        {PID, "pid=%u"},
+        {TARGET_ERR, NULL},
+};
+
+
+static int target_parse(char *options, pid_t *mpid )
+{
+	char *p;
+	int option;
+
+
+	if (!options)
+		return 1;
+	
+	//printk(KERN_ERR "options |%s|\n",options);
+	while ((p = strsep(&options, ",")) != NULL) {
+		
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		
+		//printk(KERN_ERR "p |%s| options |%s|\n",p,options);
+
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		//printk(KERN_ERR "Token %d\n",token);
+		switch (token) {
+			
+		case PID:
+			if (match_int(args, &option))
+				return 0;
+			*mpid = (pid_t)(option);
+			break;
+		default:
+			return 0;
+		}
+
+	}
+	return 1;
+}	
+
+
+static ssize_t
+target_write(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	struct rcfs_inode_info *ri= RCFS_I(file->f_dentry->d_inode);
+	char *optbuf;
+	int done;
+	pid_t mpid;
+	struct task_struct *mtsk;
+	
+
+	if ((ssize_t) count < 0 || (ssize_t) count > TARGET_MAX_INPUT_SIZE)
+		return -EINVAL;
+	
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+	
+	down(&(ri->vfs_inode.i_sem));
+	
+	optbuf = kmalloc(TARGET_MAX_INPUT_SIZE, GFP_KERNEL);
+	__copy_from_user(optbuf, buf, count);
+
+	/* cat > shares puts in an extra newline */
+	if (optbuf[count-1] == '\n')
+		optbuf[count-1]='\0';
+
+	done = target_parse(optbuf, &mpid);
+
+	if (!done) {
+		printk(KERN_ERR "Error parsing target \n");
+		goto target_out;
+	}
+
+	/* USEMELATER */
+	   
+	mtsk = find_task_by_pid(mpid);
+	if (!mtsk) {
+		printk(KERN_ERR "No such pid \n");
+		goto target_out;
+	}
+
+#if 0
+	/* Error control ? */
+	if (callbacks_active)
+		if (ckrm_eng_callbacks.relinquish_tsk)
+			(*ckrm_eng_callbacks.relinquish_tsk)(mtsk) ;
+				
+	/* Error control ? */
+	/* Do manual reclassification after CE relinquishes control to
+	   avoid races with other operations which might reclassify task
+	 */
+	ckrm_reclassify_task(mtsk, ri->core);
+#endif
+	
+	
+	printk(KERN_ERR "Reclassifying task pid %d cmd %s \n",
+	       (int) mpid, mtsk->comm);
+	
+
+target_out:	
+
+	up(&(ri->vfs_inode.i_sem));
+	kfree(optbuf);
+	return count;
+}
+
+
+
+struct file_operations target_fileops = {
+	.write          = target_write,
+};
+
+
Index: linux-2.6.5/fs/rcfs/super.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/super.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/super.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,255 @@
+/* 
+ * fs/rcfs/super.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *		 Vivek Kashyap,   IBM Corp. 2004
+ *           
+ * Super block operations for rcfs
+ * 
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 08 Mar 2004
+ *        Created.
+ */
+
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
+#include <linux/parser.h>
+
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+#include "MOVETOCORE.h"
+
+
+
+static kmem_cache_t *rcfs_inode_cachep;
+
+
+inline struct rcfs_inode_info *RCFS_I(struct inode *inode)
+{
+	return container_of(inode, struct rcfs_inode_info, vfs_inode);
+}
+
+
+static struct inode *
+rcfs_alloc_inode(struct super_block *sb)
+{
+	struct rcfs_inode_info *ri;
+	ri = (struct rcfs_inode_info *) kmem_cache_alloc(rcfs_inode_cachep, SLAB_KERNEL);
+	if (!ri)
+		return NULL;
+	return &ri->vfs_inode;
+}
+
+static void 
+rcfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(rcfs_inode_cachep, RCFS_I(inode));
+}
+
+static void 
+rcfs_init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct rcfs_inode_info *ri = (struct rcfs_inode_info *) foo;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+	    SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&ri->vfs_inode);
+}
+
+int 
+rcfs_init_inodecache(void)
+{
+	rcfs_inode_cachep = kmem_cache_create("rcfs_inode_cache",
+				sizeof(struct rcfs_inode_info),
+				0, SLAB_HWCACHE_ALIGN | SLAB_RECLAIM_ACCOUNT,
+				rcfs_init_once, NULL);
+	if (rcfs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+void rcfs_destroy_inodecache(void)
+{
+	if (kmem_cache_destroy(rcfs_inode_cachep))
+		printk(KERN_INFO "rcfs_inode_cache: not all structures were freed\n");
+}
+
+/* exported operations */
+struct super_operations rcfs_super_ops =
+{
+	.alloc_inode	= rcfs_alloc_inode,
+	.destroy_inode	= rcfs_destroy_inode,
+//	.clear_inode	= rcfs_clear_inode,
+	.statfs		= simple_statfs,
+	.drop_inode     = generic_delete_inode,
+};
+
+
+
+/*
+static 
+int res_initialize(void)
+{
+
+	printk (KERN_ERR "initialized res_ctrlr data in rcfs\n");
+	return 0;
+}
+*/
+
+struct dentry *rcfs_rootde, *rcfs_nwde, *rcfs_nw_aqde;
+struct inode *rcfs_root, *rcfs_nw, *rcfs_nw_aq;
+struct rcfs_inode_info *rcfs_rootri, *rcfs_nwri;
+
+static int rcfs_fill_super(struct super_block * sb, void * data, int silent)
+{
+	struct inode * inode;
+	struct dentry * root;
+	struct rcfs_inode_info *rootri;
+	struct ckrm_core_class *core ;
+	struct task_struct *tsk;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = RCFS_MAGIC;
+	sb->s_op = &rcfs_super_ops;
+	inode = rcfs_get_inode(sb, S_IFDIR | 0755, 0);
+	if (!inode)
+		return -ENOMEM;
+
+	root = d_alloc_root(inode);
+	if (!root) {
+		iput(inode);
+		return -ENOMEM;
+	}
+	sb->s_root = root;
+
+	/* Link inode and core class */
+
+	rootri = RCFS_I(inode);
+	rootri->core = &ckrm_dflt_class;
+	ckrm_dflt_class.dentry = rcfs_rootde;
+
+
+	rcfs_root = inode;
+	rcfs_rootde = root ;
+	rcfs_rootri = rootri ;
+
+
+	printk("get_alloc_super: root class created (%s, de-%p ri-%p in-%p ri->core-%p ri->core->in-%p",root->d_name.name, root, rootri, inode, rootri->core, ((struct ckrm_core_class *)(rootri->core))->dentry);
+	
+	// Create the network root
+	// XXX -- add error reporting
+	rcfs_nwde = rcfs_create_internal(rcfs_rootde, "network", 
+							rcfs_root->i_mode, 0);
+	// Link inode and core class
+	rootri = RCFS_I(rcfs_nwde->d_inode);
+	rootri->core = &ckrm_net_root;
+	ckrm_net_root.dentry = rcfs_nwde;
+
+	// Pre-create other top level network directories
+	// At present only the socket_aq direcotry.
+	rcfs_nw_aqde = rcfs_create_internal(rcfs_nwde, "socket_aq", 
+							rcfs_root->i_mode, 0);
+	// Link inode and core class
+	RCFS_I(rcfs_nw_aqde->d_inode)->core = 
+		ckrm_alloc_core_class((ckrm_core_class_t *)&ckrm_net_root,
+						rcfs_nw_aqde);
+
+#if 0
+	core = &ckrm_dflt_class ;
+	spin_lock(&core->ckrm_lock);
+
+	
+	read_lock(&tasklist_lock);
+	for_each_process(tsk) {
+		
+		/* Should take a task lock here but its too early for any other
+		   CKRM component to touch the element. So safe to modify directly.
+		*/
+		task_lock(tsk);
+		tsk->ckrm_core = core;
+		INIT_LIST_HEAD(&tsk->ckrm_link);
+		list_add(&tsk->ckrm_link, &core->tasklist);
+		printk("ckrm_init: Added %ld to %p\n",(long)tsk->pid,core);
+		task_unlock(tsk);
+	}
+	read_unlock(&tasklist_lock);
+
+	spin_unlock(&core->ckrm_lock);	
+#endif
+	
+	// Other post-mount initializations here */
+	//if (res_initialize())
+	//	return -EINVAL;
+	
+	return 0;
+	
+}
+
+static struct super_block *rcfs_get_sb(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data)
+{
+	return get_sb_nodev(fs_type, flags, data, rcfs_fill_super);
+}
+
+static struct file_system_type rcfs_fs_type = {
+	.name		= "rcfs",
+	.get_sb		= rcfs_get_sb,
+	.kill_sb	= kill_litter_super,
+};
+
+static int __init init_rcfs_fs(void)
+{
+	int ret;
+
+	ret = register_filesystem(&rcfs_fs_type);
+	if (ret)
+		goto init_register_err;
+
+	ret = rcfs_init_inodecache();
+	if (ret)
+		goto init_cache_err;
+	
+	return ret;
+
+init_cache_err:
+	unregister_filesystem(&rcfs_fs_type);
+init_register_err:
+	return ret;
+}
+
+static void __exit exit_rcfs_fs(void)
+{
+	rcfs_destroy_inodecache();
+	unregister_filesystem(&rcfs_fs_type);
+}
+
+
+module_init(init_rcfs_fs)
+module_exit(exit_rcfs_fs)
+
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.5/fs/rcfs/file.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/file.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/file.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,122 @@
+/* 
+ * fs/rcfs/inode.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *           
+ * 
+ * Resource class filesystem (rcfs) forming the 
+ * user interface to Class-based Kernel Resource Management (CKRM).
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 05 Mar 2004
+ *        Created.
+ * 06 Mar 2004
+ *        Parsing for shares added
+ */
+
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
+#include <linux/parser.h>
+
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+#include "MOVETOCORE.h"
+#include "magic.h"
+
+
+
+/* Magic file info */
+
+#define MAG_FILE_MODE (S_IFREG | S_IRUGO | S_IWUSR) 
+#define MAG_DIR_MODE  (S_IFDIR | S_IRUGO | S_IXUGO) 
+ 	
+
+struct magf_t magf[NR_MAGF] = {
+	{ 
+		.name    =  "target", 
+		.mode    = MAG_FILE_MODE, 
+		.i_fop    = &target_fileops, 
+	},
+	{ 
+		.name    =  "shares", 
+		.mode    = MAG_FILE_MODE, 
+		.i_fop    = &shares_fileops, 
+	},
+	{ 
+		.name    =  "stats", 
+		.mode    = MAG_FILE_MODE, 
+		.i_fop    = &stats_fileops, 
+	},
+	{ 
+		.name    =  "config", 
+		.mode    = MAG_FILE_MODE, 
+		.i_fop    = &config_fileops, 
+	},
+	{ 
+		.name    =  "members", 
+		.mode    = MAG_FILE_MODE, 
+		.i_fop   = &members_fileops,
+	}
+};
+
+
+/* rcfs has no files to handle except magic files  */
+/* So the generic file ops here can be deleted once the code is working */
+
+
+/*******************************Generic file ops ********************/
+
+
+static struct seq_operations rcfile_seq_ops;
+
+static int rcfs_open(struct inode *inode, struct file *file)
+{
+	return -EPERM;
+//	return seq_open(file, &rcfile_seq_ops);
+}
+
+
+
+
+struct address_space_operations rcfs_aops = {
+	.readpage	= simple_readpage,
+	.prepare_write	= simple_prepare_write,
+	.commit_write	= simple_commit_write
+};
+
+struct file_operations rcfs_file_operations = {
+//	.open           = rcfs_open,
+//	.read           = seq_read,
+//	.llseek         = seq_lseek,
+//	.release        = seq_release,
+//	.write          = generic_file_write,
+//	.read		= generic_file_read,
+//	.write		= generic_file_write,
+//	.mmap		= generic_file_mmap,
+//	.fsync		= simple_sync_file,
+//	.sendfile	= generic_file_sendfile,
+//	.llseek		= generic_file_llseek,
+};
+
Index: linux-2.6.5/fs/rcfs/magic_shares.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/magic_shares.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/magic_shares.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,312 @@
+/* 
+ * fs/rcfs/magic_shares.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *           
+ * 
+ * virtual file for setting/getting share values of a 
+ * task class. Part of resource class file system (rcfs) 
+ * interface to Class-based Kernel Resource Management (CKRM).
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 06 Mar 2004
+ *        Created.
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/parser.h>
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+#include "MOVETOCORE.h"
+#include "magic.h"
+
+
+/* Token matching for parsing input to this magic file */
+
+//NOTNEEDED #define SHARE_UNCHANGED -1
+
+/* Next few are dependent on number of share types */
+
+//NOTNEEDED #define NUM_SHAREVAL 4
+#define SHARES_MAX_INPUT_SIZE  300
+
+/* The enums for the share types should match the indices expected by
+   array parameter to ckrm_set_resshare */
+
+/* Note only the first NUM_SHAREVAL enums correspond to share types,
+   the remaining ones are for token matching purposes */
+
+enum share_token_t {
+        MY_GUAR, MY_LIM, TOT_GUAR, TOT_LIM, RES_TYPE, SHARE_ERR
+};
+
+static match_table_t tokens = {
+	{RES_TYPE, "res=%s"},
+        {MY_GUAR, "guarantee=%d"},
+        {MY_LIM,  "limit=%d"},
+	{TOT_GUAR,"tot_guarantee=%d"},
+	{TOT_LIM, "tot_limit=%d"},
+        {SHARE_ERR, NULL}
+};
+
+
+static int shares_parse(char *options, int *resid, struct ckrm_shares *shares)
+{
+	char *p,resname[CKRM_MAX_RES_NAME];
+	int option;
+
+
+	if (!options)
+		return 1;
+	
+	//printk(KERN_ERR "options |%s|\n",options);
+	while ((p = strsep(&options, ",")) != NULL) {
+		
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		
+		//printk(KERN_ERR "p |%s| options |%s|\n",p,options);
+
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		//printk(KERN_ERR "Token %d\n",token);
+		switch (token) {
+			
+		case RES_TYPE:
+			
+			match_strcpy(resname,args);
+			printk(KERN_ERR "resname %s tried\n",resname);
+			*resid = ckrm_resid_lookup(resname);
+			break;
+			
+		case MY_GUAR:
+			if (match_int(args, &option))
+				return 0;
+			shares->my_guarantee = option;
+			break;
+		case MY_LIM:
+			if (match_int(args, &option))
+				return 0;
+			shares->my_limit = option;
+			break;
+		case TOT_GUAR:
+			if (match_int(args, &option))
+				return 0;
+			shares->total_guarantee = option;
+			break;
+		case TOT_LIM:
+			if (match_int(args, &option))
+				return 0;
+			shares->total_limit = option;
+			break;
+		default:
+			return 0;
+		}
+
+	}
+	return 1;
+}	
+
+
+static ssize_t
+shares_write(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	struct rcfs_inode_info *ri;
+	char *optbuf;
+	int i,done, resid, retval;
+
+	//newval[NUM_SHAREVAL]; ;
+	struct ckrm_shares newshares = {
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED
+	};
+
+	if ((ssize_t) count < 0 || (ssize_t) count > SHARES_MAX_INPUT_SIZE)
+		return -EINVAL;
+	
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	ri = RCFS_I(file->f_dentry->d_parent->d_inode);
+
+	if (!ri || !is_core_valid((ckrm_core_class_t *)(ri->core))) {
+		printk(KERN_ERR "shares_write: Error accessing core class\n");
+		return -EFAULT;
+	}
+	
+	down(&inode->i_sem);
+	
+	optbuf = kmalloc(SHARES_MAX_INPUT_SIZE, GFP_KERNEL);
+	__copy_from_user(optbuf, buf, count);
+
+	/* cat > shares puts in an extra newline */
+	if (optbuf[count-1] == '\n')
+		optbuf[count-1]='\0';
+
+	/* Set default values */
+	//for (i=0; i<NUM_SHAREVAL; i++)
+	//	newval[i] = SHARE_UNCHANGED;
+
+	done = shares_parse(optbuf, &resid, &newshares);
+	if (!done) {
+		printk(KERN_ERR "Error parsing shares\n");
+		retval = -EINVAL;
+		goto write_out;
+	}
+
+	if (resid && is_res_regd(resid)) {
+
+#if 1
+		ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
+		
+		if (rcbs->set_share_values) {
+			retval = (*rcbs->set_share_values)
+				(((ckrm_core_class_t *)(ri->core))->res_class[resid],&newshares);
+			if (retval) {
+				printk(KERN_ERR "shares_write: resctlr share set error\n");
+				goto write_out;
+			}
+		}
+#endif
+	}
+	
+	printk(KERN_ERR "Set %s shares to %d %d %d %d\n",
+	       ckrm_res_ctlrs[resid].res_name, 
+	       newshares.my_guarantee, 
+	       newshares.my_limit, 
+	       newshares.total_guarantee,
+	       newshares.total_limit);
+      
+	retval = count ;
+
+write_out:	
+
+	up(&inode->i_sem);
+	kfree(optbuf);
+	return count;
+}
+
+
+static int 
+shares_show(struct seq_file *s, void *v)
+{
+	int resid,retval;
+	struct ckrm_shares curshares;
+	struct rcfs_inode_info *ri = s->private;
+
+	// USEME struct rcfs_inode_info *rinfo = RCFS_I(s->private) ;
+
+	/* Get and "display" share data for each registered resource.
+	 * Data from each resource is atomic but not across resources
+	 */
+
+	if (!ri || !is_core_valid((ckrm_core_class_t *)(ri->core))) {
+		printk(KERN_ERR "shares_show: Error accessing core class\n");
+		return -EFAULT;
+	}
+
+
+	for_each_resid(resid) {
+		if (is_res_regd(resid)) {
+
+#if 1
+			ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
+			
+			printk(KERN_ERR "Showing %s's shares %p %p\n",rcbs->res_name,ri->core,(void *)((ckrm_core_class_t *)(ri->core))->res_class[resid]);
+		
+			if (rcbs->get_share_values) {
+				/* Copy into curshares can be removed if all RC's 
+				   keep ckrm_shares allocated - getting back the ptr
+				   is sufficient then. 
+				*/
+				retval = (*rcbs->get_share_values)
+					((void *)((ckrm_core_class_t *)(ri->core))->res_class[resid],&curshares);
+				if (retval) {
+					printk(KERN_ERR "shares_show: resctlr share get error\n");
+					goto show_out;
+				}
+				seq_printf(s,"res=%s %d %d %d %d\n",
+					   rcbs->res_name,
+					   curshares.my_guarantee, 
+					   curshares.my_limit, 
+					   curshares.total_guarantee,
+					   curshares.total_limit);
+			}
+#endif
+//			seq_printf(s,"Fake res output for %d\n",resid);
+		} /* is_res_regd(resid) */
+	} /* for_each_resid(resid) */
+
+	return 0;
+
+ show_out:
+
+	seq_printf(s,"Error retrieving contents of next RC. Aborting\n");
+	return 0;
+}	
+
+static int 
+shares_open(struct inode *inode, struct file *file)
+{
+	struct rcfs_inode_info *ri;
+	int ret=-EINVAL;
+
+	if (file->f_dentry && file->f_dentry->d_parent) {
+		printk(KERN_ERR "file %s parent %s\n",file->f_dentry->d_name.name, file->f_dentry->d_parent->d_name.name);
+
+		ri = RCFS_I(file->f_dentry->d_parent->d_inode);
+
+		ret = single_open(file, shares_show, (void *)ri);
+	}
+
+	/* Allow core class retrieval using seq_file */
+	/*
+	if (ret)
+		((struct seq_file *)(file->private_data))->private = RCFS_I(file->f_dentry->d_parent->d_inode);
+	*/
+
+	return ret;
+}
+
+static int 
+shares_close(struct inode *inode, struct file *file)
+{
+	return single_release(inode,file);
+}
+
+struct file_operations shares_fileops = {
+	.open           = shares_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = shares_close,
+	.write          = shares_write,
+};
+
+
Index: linux-2.6.5/fs/rcfs/rcfs.h
===================================================================
--- linux-2.6.5.orig/fs/rcfs/rcfs.h	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/rcfs.h	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,49 @@
+#ifndef _LINUX_RCFS_H
+#define _LINUX_RCFS_H
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/ckrm.h>
+#include <linux/ckrm_rc.h>
+#include <linux/ckrm_res.h>
+#include <linux/ckrm_ce.h>
+
+
+
+/* The following declarations cannot be included in any of ckrm*.h files without 
+   jumping hoops. Remove later when rearrangements done */
+
+extern ckrm_res_callback_t ckrm_res_ctlrs[CKRM_MAX_RES_CTLRS];
+
+#define RCFS_MAGIC	0x4feedbac
+
+
+typedef struct rcfs_inode_info {
+	/* USEME ckrm_core_class_t *core */
+	void *core;
+	struct inode vfs_inode;
+} rcfs_inode_info_t;
+
+
+inline struct rcfs_inode_info *RCFS_I(struct inode *inode);
+
+
+struct inode *rcfs_get_inode(struct super_block *sb, int mode, dev_t dev);
+int rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev);
+struct dentry * rcfs_create_internal(struct dentry *parent, const char *name, 
+				     int mfmode, int magic);
+
+extern struct super_operations rcfs_super_ops;
+extern struct address_space_operations rcfs_aops;
+
+extern struct inode_operations rcfs_dir_inode_operations;
+extern struct inode_operations rcfs_file_inode_operations;
+
+extern struct file_operations target_fileops;
+extern struct file_operations shares_fileops;
+extern struct file_operations stats_fileops;
+extern struct file_operations config_fileops;
+extern struct file_operations members_fileops;
+extern struct file_operations rcfs_file_operations;
+
+#endif /* _LINUX_RCFS_H */ 
Index: linux-2.6.5/fs/rcfs/MOVETOCORE.h
===================================================================
--- linux-2.6.5.orig/fs/rcfs/MOVETOCORE.h	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/MOVETOCORE.h	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,4 @@
+#ifndef _LINUX_MOVETOCORE_H
+#define _LINUX_MOVETOCORE_H
+
+#endif /* _LINUX_MOVETOCORE_H */
Index: linux-2.6.5/fs/rcfs/inode.c
===================================================================
--- linux-2.6.5.orig/fs/rcfs/inode.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/fs/rcfs/inode.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,295 @@
+/* 
+ * fs/rcfs/inode.c 
+ *
+ * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ *               Vivek Kashyap,   IBM Corp. 2004
+ *           
+ * 
+ * Resource class filesystem (rcfs) forming the 
+ * user interface to Class-based Kernel Resource Management (CKRM).
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 05 Mar 2004
+ *        Created.
+ * 06 Mar 2004
+ *        Parsing for shares added
+ */
+
+
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
+#include <linux/parser.h>
+
+#include <asm/uaccess.h>
+
+#include "rcfs.h"
+#include "magic.h"
+
+
+/* Address of variable used as flag to indicate a magic file, value unimportant */
+int RCFS_IS_MAGIC;
+
+
+//static struct magf_t mymagf = { "mymagf", NULL, 100, &rcfs_file_operations };
+
+
+static struct backing_dev_info rcfs_backing_dev_info = {
+	.ra_pages	= 0,	/* No readahead */
+	.memory_backed	= 1,	/* Does not contribute to dirty memory */
+};
+
+
+struct inode *rcfs_get_inode(struct super_block *sb, int mode, dev_t dev)
+{
+	struct inode * inode = new_inode(sb);
+
+	if (inode) {
+		inode->i_mode = mode;
+		inode->i_uid = current->fsuid;
+		inode->i_gid = current->fsgid;
+		inode->i_blksize = PAGE_CACHE_SIZE;
+		inode->i_blocks = 0;
+		inode->i_mapping->a_ops = &rcfs_aops;
+		inode->i_mapping->backing_dev_info = &rcfs_backing_dev_info;
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		switch (mode & S_IFMT) {
+		default:
+			init_special_inode(inode, mode, dev);
+			break;
+		case S_IFREG:
+			/* Treat as default assignment */
+			inode->i_op = &rcfs_file_inode_operations;
+			inode->i_fop = &rcfs_file_operations;
+			break;
+		case S_IFDIR:
+			inode->i_op = &rcfs_dir_inode_operations;
+			inode->i_fop = &simple_dir_operations;
+
+			/* directory inodes start off with i_nlink == 2 (for "." entry) */
+			inode->i_nlink++;
+			break;
+		case S_IFLNK:
+			inode->i_op = &page_symlink_inode_operations;
+			break;
+		}
+	}
+	return inode;
+}
+
+
+
+int 
+_rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	struct inode *inode;
+	int error = -ENOSPC, i=0;
+
+	inode = rcfs_get_inode(dir->i_sb, mode, dev);
+
+	if (inode) {
+		if (dir->i_mode & S_ISGID) {
+			inode->i_gid = dir->i_gid;
+			if (S_ISDIR(mode))
+				inode->i_mode |= S_ISGID;
+		}
+		d_instantiate(dentry, inode);
+		dget(dentry);	/* Extra count - pin the dentry in core */
+		error = 0;
+
+		printk (KERN_INFO "%s being created\n", dentry->d_name.name);
+
+
+		/* Reassign i_op, i_fop for magic files */
+		/* Safe to do here as /rcfs/ce, /rcfs/network shouldn't invoke
+		   rcfs_mknod */
+
+		i=0;
+		while ((i < NR_MAGF) && magf[i].name && 
+		       (strnicmp(dentry->d_name.name,magf[i].name,MAGF_NAMELEN))) 
+			i++;
+		
+		if (i < NR_MAGF) {
+			if (magf[i].i_fop)
+				inode->i_fop = magf[i].i_fop;
+			if (magf[i].i_op)
+				inode->i_op = magf[i].i_op;
+		}
+	}
+	return error;
+}
+
+int
+rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	struct inode *inode;
+	int err = -ENOSPC, i = 0;
+
+        // printk(KERN_ERR "rcfs_mknod called with dir=%p dentry=%p mode=%d\n",dir,dentry,mode);
+	// Do not allow creation of files by the user. Only directories i.e.
+	// the classes can be created.
+
+	/*
+	if ((mode & S_IFMT) == S_IFREG)
+		return -EINVAL;
+	else 
+	*/
+	return _rcfs_mknod(dir, dentry, mode, dev);
+}
+
+
+#if 0
+int
+rcfs_create_magic(struct dentry *parent, struct magf_t *magf)
+{
+	struct qstr qstr;
+	struct dentry *mfdentry ;
+
+
+	if (!(magf && magf->name && magf->mode && (magf->i_op || magf->i_fop)))
+		return -EINVAL;
+
+	dget(parent);
+
+	/* Get new dentry for name  */
+	qstr.name = magf->name;
+	qstr.len = strlen(magf->name);
+	qstr.hash = full_name_hash(magf->name,qstr.len);
+	mfdentry = lookup_hash(&qstr,parent);
+
+	if (!IS_ERR(mfdentry)) {
+		int err; 
+
+		down(&parent->d_inode->i_sem);
+		err = rcfs_mknod(parent->d_inode, mfdentry, magf->mode, 0);
+		up(&parent->d_inode->i_sem);
+
+		if (err) {
+			dput(mfdentry);
+			dput(parent);
+			return -EINVAL;
+		}
+
+		if (magf->i_op)
+			mfdentry->d_inode->i_op = magf->i_op;
+		if (magf->i_fop)
+			mfdentry->d_inode->i_fop = magf->i_fop;
+		mfdentry->d_fsdata = &RCFS_IS_MAGIC; // flag for magic file/dir
+	}
+	dput(parent);
+
+	return 0 ;
+}
+#endif
+
+struct dentry * 
+rcfs_create_internal(struct dentry *parent, const char *name, int mfmode, 
+			int magic)
+{
+	struct qstr qstr;
+	struct dentry *mfdentry ;
+
+	
+	/* Get new dentry for name  */
+	qstr.name = name;
+	qstr.len = strlen(name);
+	qstr.hash = full_name_hash(name,qstr.len);
+	mfdentry = lookup_hash(&qstr,parent);
+
+	printk(KERN_INFO "parent %p name %s mfdentry is %x\n",parent, name, mfdentry);
+	if (!IS_ERR(mfdentry)) {
+		int err; 
+
+		down(&parent->d_inode->i_sem);
+		if (magic)
+			err = rcfs_mkdir(parent->d_inode, mfdentry, mfmode, 0);
+		else
+			err = _rcfs_mknod(parent->d_inode, mfdentry, mfmode, 0);
+		parent->d_inode->i_nlink++;
+		up(&parent->d_inode->i_sem);
+
+		if (err) {
+			dput(mfdentry);
+			return mfdentry;
+		}
+	}
+	return mfdentry ;
+}
+EXPORT_SYMBOL(rcfs_create_internal);
+
+int 
+rcfs_delete_all_magic(struct dentry *parent)
+{
+	struct dentry *mftmp, *mfdentry ;
+	umode_t mfmode;
+
+//	if (!(magf && magf->name))
+//		return NULL;
+	
+	down(&parent->d_inode->i_sem);
+
+	//dget(parent);
+
+	list_for_each_entry_safe(mfdentry, mftmp, &parent->d_subdirs, d_child) {
+		int x=0;
+		if (!rcfs_is_magic(mfdentry))
+			continue ;
+
+		mfmode =  (mfdentry->d_inode->i_mode);
+			
+		if (mfmode & S_IFREG)
+			simple_unlink(parent->d_inode, mfdentry);
+		if (mfmode & S_IFDIR)
+			simple_rmdir(parent->d_inode, mfdentry);
+
+		d_delete(mfdentry);
+		dput(mfdentry);
+	}
+	up(&parent->d_inode->i_sem);		
+		
+#if 0
+	if (!parent || (parent->d_inode != dir))
+		return -EINVAL;
+//	down(&parent->d_inode->i_sem);
+	d_delete(magf->dentry);
+	simple_unlink(parent->d_inode, magf->dentry);
+	dput(magf->dentry);
+//	up(&parent->d_inode->i_sem);
+#endif
+
+	return 0;
+}
+
+
+struct inode_operations rcfs_file_inode_operations = {
+//	.getattr	= simple_getattr,
+};
+		
+
+
+	
+
+
+
+
+
Index: linux-2.6.5/fs/Makefile
===================================================================
--- linux-2.6.5.orig/fs/Makefile	2004-04-16 15:38:32.000000000 +0200
+++ linux-2.6.5/fs/Makefile	2004-04-16 15:38:35.000000000 +0200
@@ -97,3 +97,4 @@
 obj-$(CONFIG_BEFS_FS)		+= befs/
 obj-$(CONFIG_HOSTFS)		+= hostfs/
 obj-$(CONFIG_HPPFS)		+= hppfs/
+obj-$(CONFIG_RCFS_FS)		+= rcfs/
Index: linux-2.6.5/fs/Kconfig
===================================================================
--- linux-2.6.5.orig/fs/Kconfig	2004-04-16 15:38:32.000000000 +0200
+++ linux-2.6.5/fs/Kconfig	2004-04-16 15:38:35.000000000 +0200
@@ -857,6 +857,12 @@
 
 	  It is perfectly safe to say N here.
 
+config RCFS_FS
+       tristate "Resource Class File System for CKRM"
+       depends on EXPERIMENTAL
+       help
+	 This option adds CKRM support to the Kernel. Say N if you are unsure.
+
 endmenu
 
 menu "Pseudo filesystems"
Index: linux-2.6.5/fs/exec.c
===================================================================
--- linux-2.6.5.orig/fs/exec.c	2004-04-16 15:38:32.000000000 +0200
+++ linux-2.6.5/fs/exec.c	2004-04-16 15:38:35.000000000 +0200
@@ -46,6 +46,7 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/objrmap.h>
+#include <linux/ckrm.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -1161,6 +1162,8 @@
 	if (retval >= 0) {
 		free_arg_pages(&bprm);
 
+		ckrm_cb_exec(filename);
+
 		/* execve success */
 		security_bprm_free(&bprm);
 		return retval;
Index: linux-2.6.5/init/Kconfig
===================================================================
--- linux-2.6.5.orig/init/Kconfig	2004-04-16 15:38:31.000000000 +0200
+++ linux-2.6.5/init/Kconfig	2004-04-16 15:38:35.000000000 +0200
@@ -332,4 +332,24 @@
 	depends on (SMP && MODULE_UNLOAD) || HOTPLUG_CPU
 	help
 	  Need stop_machine() primitive.
+
+config CKRM
+	bool "Class Based Kernel Resource Management"
+	depends on EXPERIMENTAL
+	help
+	  This option adds CKRM support to the Kernel. Say N if you are unsure.
+
+config CKRM_RES_DUMMY
+	tristate "Dummy Resource Manager for CKRM"
+	depends on CKRM
+	default m
+	help
+	  Provides a Dummy Resource Manager for CKRM
+config CKRM_RES_SOCKETAQ
+	tristate "Multiple Accept Queues Resource Manager for CKRM"
+	depends on CKRM
+	help
+	  Provides a  Resource Manager for CKRM to manage the accept queue 
+	  weights. Say N if you are unsure.
+
 endmenu
Index: linux-2.6.5/init/main.c
===================================================================
--- linux-2.6.5.orig/init/main.c	2004-04-16 15:38:32.000000000 +0200
+++ linux-2.6.5/init/main.c	2004-04-16 15:38:57.000000000 +0200
@@ -46,6 +46,9 @@
 #include <asm/io.h>
 #include <asm/bugs.h>
 
+#include <linux/ckrm.h>
+#include <linux/ckrm_res.h>
+
 /*
  * This is one of the first .c files built. Error out early
  * if we have compiler trouble..
@@ -467,6 +470,7 @@
 	rcu_init();
 	init_IRQ();
 	pidhash_init();
+	ckrm_init();
 	init_timers();
 	softirq_init();
 	time_init();
Index: linux-2.6.5/kernel/ckrm/Makefile
===================================================================
--- linux-2.6.5.orig/kernel/ckrm/Makefile	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/kernel/ckrm/Makefile	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,12 @@
+#
+# Makefile for the ckrm Module
+#
+
+ifeq ($(CONFIG_CKRM),y)
+	obj-y = ckrm.o ckrmutils.o
+else
+	obj-y = ckrmstub.o
+endif
+
+obj-$(CONFIG_CKRM_RES_DUMMY) += ckrm_dummy.o ckrm_socketaq.o
+
Index: linux-2.6.5/kernel/ckrm/ckrmutils.c
===================================================================
--- linux-2.6.5.orig/kernel/ckrm/ckrmutils.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/kernel/ckrm/ckrmutils.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,68 @@
+/* ckrmutils.c - Utility functions for CKRM
+ *
+ * Copyright (C) Chandra Seetharaman,  IBM Corp. 2003
+ * 
+ * Provides simple utility functions for the core module, CE and resource
+ * controllers.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ * 
+ * 13 Nov 2003
+ *        Created
+ */
+
+#include <linux/ckrm.h>
+#include <linux/mm.h>
+#include <linux/err.h>
+#include <linux/mount.h>
+#include <linux/module.h>
+
+int
+get_exe_path_name(struct task_struct *tsk, char *buf, int buflen)
+{
+	struct vm_area_struct * vma;
+	struct vfsmount *mnt;
+	struct mm_struct * mm = get_task_mm(tsk);
+	struct dentry *dentry;
+	char *lname;
+	int rc = 0;
+
+	*buf = '\0';
+	if (!mm) {
+		return -EINVAL;
+	}
+
+	down_read(&mm->mmap_sem);
+	vma = mm->mmap;
+	while (vma) {
+		if ((vma->vm_flags & VM_EXECUTABLE) &&
+				vma->vm_file) {
+			dentry = dget(vma->vm_file->f_dentry);
+			mnt = mntget(vma->vm_file->f_vfsmnt);
+			lname = d_path(dentry, mnt, buf, buflen);
+			if (! IS_ERR(lname)) {
+				strncpy(buf, lname, strlen(lname) + 1);
+			} else {
+				rc = (int) PTR_ERR(lname);
+			}
+			mntput(mnt);
+			dput(dentry);
+			break;
+		}
+		vma = vma->vm_next;
+	}
+	up_read(&mm->mmap_sem);
+	mmput(mm);
+	return rc;
+}
+
+EXPORT_SYMBOL(get_exe_path_name);
Index: linux-2.6.5/kernel/ckrm/ckrm_socketaq.c
===================================================================
--- linux-2.6.5.orig/kernel/ckrm/ckrm_socketaq.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/kernel/ckrm/ckrm_socketaq.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,347 @@
+/* ckrm_socketaq.c - Socket accept queue resource controller
+ *
+ * Copyright (C) Vivek Kashyap,      IBM Corp. 2004
+ * 
+ * Provides a Dummy Resource controller for CKRM
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ * Initial version
+ */
+
+/* Code Description: TBD
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <asm/errno.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/ckrm.h>
+#include <linux/ckrm_rc.h>
+#include <net/tcp.h>
+
+#define DEBUG_CKRM_SAQ 1
+
+#define SAQ_MAX_HIERARCHY 0 	/*the user is not allowed to create a subclass*/
+
+typedef struct ckrm_saq_res {
+	struct ckrm_hnode  hnode;    /* build our own hierarchy */
+	struct ckrm_shares shares;
+	struct ckrm_core_class *core;
+} ckrm_saq_res_t;
+
+static int my_resid = -1;
+
+#define get_parent(res) (container_of((res)->hnode.parent,ckrm_saq_res_t,hnode))
+
+
+extern struct dentry * 
+rcfs_create_internal(struct dentry *parent, const char *name, int mfmode, int magic) ;
+
+
+/* Initialize rescls values
+ */
+
+static void
+saq_res_initcls_zero(void *my_res)
+{
+	ckrm_saq_res_t *res = my_res;
+
+	res->shares.my_guarantee     = CKRM_SHARE_DONTCARE;
+	res->shares.my_limit         = CKRM_SHARE_DONTCARE;
+	res->shares.total_guarantee  = 0; 
+	res->shares.total_limit      = 0;
+	res->shares.unused_guarantee = 0;
+	res->shares.unused_limit     = 0;
+	
+	/* Don't initiate propagation to children here, caller will do it if needed */
+}
+
+static void
+saq_res_initcls_one(void *my_res)
+{
+	ckrm_saq_res_t *res = my_res;
+
+	res->shares.my_guarantee     = CKRM_SHARE_DONTCARE;
+	res->shares.my_limit         = CKRM_SHARE_DONTCARE;
+	res->shares.total_guarantee  = CKRM_SHARE_DFLT_TOTAL_GUARANTEE;
+	res->shares.total_limit      = CKRM_SHARE_DFLT_TOTAL_LIMIT;
+	res->shares.unused_guarantee = CKRM_SHARE_DFLT_TOTAL_GUARANTEE;
+	res->shares.unused_limit     = CKRM_SHARE_DFLT_TOTAL_LIMIT;
+	
+	/* Don't initiate propagation to children here, caller will do it if needed */
+}
+static void
+saq_res_initcls(void *my_res)
+{
+	ckrm_saq_res_t *res = my_res;
+
+	res->shares.my_guarantee     = CKRM_SHARE_DONTCARE;
+	res->shares.my_limit         = CKRM_SHARE_DONTCARE;
+	res->shares.total_guarantee  = CKRM_SHARE_DFLT_TOTAL_GUARANTEE;
+	res->shares.total_limit      = CKRM_SHARE_DFLT_TOTAL_LIMIT;
+	res->shares.unused_guarantee = CKRM_SHARE_DFLT_TOTAL_GUARANTEE;
+	res->shares.unused_limit     = CKRM_SHARE_DFLT_TOTAL_LIMIT;
+	
+	/* Don't initiate propagation to children here, caller will do it if needed */
+}
+
+static void *
+saq_res_alloc(struct ckrm_core_class *core, struct ckrm_core_class *parent)
+{
+	ckrm_saq_res_t *res;
+
+	res = kmalloc(sizeof(ckrm_saq_res_t), GFP_KERNEL);
+	if (res) {
+		struct ckrm_hnode *parhnode = NULL;
+		
+		if (parent) {
+			ckrm_saq_res_t  *parres;
+			parres = ckrm_get_res_class(parent,my_resid,
+								ckrm_saq_res_t);
+			parhnode = &parres->hnode;
+		}
+		res->core = core;
+		ckrm_hnode_add(&res->hnode, parhnode);
+		printk(KERN_ERR "saq_res_alloc: Adding saq res class %p to %p\n",res,parent);
+
+		/* rescls in place, now initialize contents other than hierarchy pointers */
+		saq_res_initcls_one(res);
+	}
+	return res;
+}
+
+static void
+saq_res_free(void *my_res)
+{
+	ckrm_saq_res_t *res = my_res;
+	ckrm_saq_res_t *parent;
+
+	if (!res) 
+		return;
+
+	parent = get_parent(res);
+	ckrm_hnode_remove(&res->hnode);
+
+	// return child's limit/guarantee to parent node
+	if (parent) {
+		if (res->shares.my_guarantee >= 0)
+			parent->shares.unused_guarantee += res->shares.my_guarantee;
+		if (res->shares.my_limit >= 0)
+			parent->shares.unused_limit += res->shares.my_limit;
+	}
+	kfree(res);
+	return;
+}
+
+int
+saq_set_aq_values(ckrm_saq_res_t *my_res, struct ckrm_shares *shares)
+{
+
+	int i = 0; 
+	int j;
+	char name[4];
+	struct dentry *parent = my_res->core->dentry;
+
+#ifdef CONFIG_ACCEPT_QUEUES
+	int cnt = NUM_ACCEPT_QUEUES;
+#else
+	int cnt = 8;
+#endif
+
+	if (list_empty(&my_res->hnode.children)) {
+		for( i = 1; i < cnt; i++) {
+			j = sprintf(name, "%d",i);
+			name[j] = '\0';
+			rcfs_create_internal(parent,name, 
+					parent->d_inode->i_mode,1);
+		}
+	}
+
+	return 0;
+	/*
+ 	* Set the shares
+	*/
+	// USEME
+	// for the recalculated shares
+	// 	find each socket in members
+	//		update its accept queue weights
+	//
+}
+
+
+
+static int
+saq_set_share_values(void *my_res, struct ckrm_shares *shares)
+{
+	ckrm_saq_res_t *res = my_res;
+	ckrm_saq_res_t *parent;
+	int reduce_by;
+	int rc = EINVAL;
+
+	if (!res) 
+		return -EINVAL;
+
+	parent = get_parent(res);
+
+	// we have to ensure that the set of parameters is OK
+
+	// ensure that lim/guarantees are ok wrt to parent total values 
+	// don't have to consider negative special values
+
+	/* FIXME following doesn't appear to be working */
+	if (parent) {
+		if ((shares->my_guarantee > parent->shares.unused_guarantee) ||
+		    (shares->my_limit > parent->shares.unused_limit))
+			goto set_share_err;
+	}
+
+	// translate UNCHANGED to existing values
+	if (shares->total_guarantee == CKRM_SHARE_UNCHANGED)
+		shares->total_guarantee = res->shares.total_guarantee;
+	if (shares->total_limit == CKRM_SHARE_UNCHANGED)
+		shares->total_limit = res->shares.total_limit;
+
+	// we don't allow DONTCARE for totals
+	if ((shares->total_guarantee <= CKRM_SHARE_DONTCARE) || (shares->total_limit <= CKRM_SHARE_DONTCARE))
+		goto set_share_err;
+
+	// check whether total shares still exceeds sum of children (total - unused)
+	if (((reduce_by = shares->total_guarantee - res->shares.total_guarantee) > 0) &&
+	    (reduce_by > res->shares.unused_guarantee))
+		goto set_share_err;
+	if (((reduce_by = shares->total_limit - res->shares.total_limit) > 0) &&
+	    (reduce_by > res->shares.unused_limit))
+		goto set_share_err;
+
+
+	/* Need more sanity checks (first two not being enforced currently):
+	 *  1. guarantee < limit
+         *  2. my_* < tot_*
+	 *  etc. Do later.
+	 */
+	// values are OK now enforce them 
+
+	if (shares->my_guarantee > 0) {
+		if (parent) { 
+			parent->shares.unused_guarantee -= shares->my_guarantee;
+			if (res->shares.my_guarantee >= 0)
+				parent->shares.unused_guarantee += res->shares.my_guarantee;
+		}
+		res->shares.my_guarantee = shares->my_guarantee;
+	} else if (shares->my_guarantee == CKRM_SHARE_DONTCARE) {
+		if (parent) 
+			parent->shares.unused_guarantee += res->shares.my_guarantee;
+		res->shares.my_guarantee = CKRM_SHARE_DONTCARE;
+	}
+
+	if (shares->my_limit > 0) {
+		if (parent) { 
+			parent->shares.unused_limit -= shares->my_limit;
+			if (res->shares.my_limit >= 0)
+				parent->shares.unused_limit += res->shares.my_limit;
+		}
+		res->shares.my_limit = shares->my_limit;
+	} else if (shares->my_limit == CKRM_SHARE_DONTCARE) {
+		if (parent) 
+			parent->shares.unused_limit += res->shares.my_limit;
+		res->shares.my_limit = CKRM_SHARE_DONTCARE;
+	}
+
+
+	res->shares.unused_guarantee += (shares->total_guarantee - res->shares.total_guarantee);
+	res->shares.unused_limit     += (shares->total_limit     - res->shares.total_limit);
+
+	res->shares.total_guarantee  = shares->total_guarantee;
+	res->shares.total_limit      = shares->total_limit;
+
+	/* Here we should force the propagation of share values */
+	rc = saq_set_aq_values(my_res,shares);
+	goto out;
+
+set_share_err:
+#ifdef DEBUG_CKRM_DUMMY
+	saq_res_initcls_one(res);
+	rc = 0;
+#endif
+out:
+	
+	return rc;
+}
+
+static int
+saq_get_share_values(void *my_res, struct ckrm_shares *shares)
+{
+	ckrm_saq_res_t *res = my_res;
+
+	if (!res) 
+		return -EINVAL;
+	*shares = res->shares;
+	return 0;
+}
+
+static int  
+saq_get_stats(void *my_res, struct seq_file *sfile)
+{
+	ckrm_saq_res_t *res = my_res;
+
+	if (!res) 
+		return -EINVAL;
+
+	seq_printf(sfile, "res=saq: these are my stats <none>\n");
+
+	return 0;
+}
+
+static void
+saq_change_resclass(struct task_struct *tsk, void *old, void *new)
+{
+	// does nothing
+	return;
+}
+
+ckrm_res_callback_t saq_rcbs = {
+	.res_name          = "saq",
+	.res_type	   = CKRM_NET_CLASS,
+	.resid		   = CKRM_RES_SAQ,
+	.res_hdepth        = SAQ_MAX_HIERARCHY,
+	.res_alloc         = saq_res_alloc,
+	.res_free          = saq_res_free,
+	.set_share_values  = saq_set_share_values,
+	.get_share_values  = saq_get_share_values,
+	.get_stats         = saq_get_stats,
+	.change_resclass   = saq_change_resclass,
+	.res_initcls       = saq_res_initcls,
+};
+
+int __init
+init_ckrm_saq_res(void)
+{
+	my_resid = ckrm_register_res_ctlr(&saq_rcbs);
+	printk(KERN_INFO "SAQ resid is %d\n",my_resid);
+	return 0;
+}	
+
+void __exit
+exit_ckrm_saq_res(void)
+{
+	ckrm_unregister_res_ctlr(my_resid);
+}
+
+
+module_init(init_ckrm_saq_res)
+module_exit(exit_ckrm_saq_res)
+
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.5/kernel/ckrm/ckrm.c
===================================================================
--- linux-2.6.5.orig/kernel/ckrm/ckrm.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/kernel/ckrm/ckrm.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,841 @@
+/* ckrm.c - Class-based Kernel Resource Management (CKRM)
+ *
+ * Copyright (C) Hubertus Franke, IBM Corp. 2003
+ *           (C) Shailabh Nagar,  IBM Corp. 2003
+ *           (C) Chandra Seetharaman,  IBM Corp. 2003
+ *	     (C) Vivek Kashyap,	IBM Corp. 2004
+ * 
+ * 
+ * Provides kernel API of CKRM for in-kernel,per-resource controllers 
+ * (one each for cpu, memory, io, network) and callbacks for 
+ * classification modules.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 28 Aug 2003
+ *        Created.
+ * 06 Nov 2003
+ *        Made modifications to suit the new RBCE module.
+ * 10 Nov 2003
+ *        Fixed a bug in fork and exit callbacks. Added callbacks_active and
+ *        surrounding logic. Added task paramter for all CE callbacks.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/errno.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/ckrm_ce.h>
+#include <linux/ckrm_rc.h>
+
+/*
+ * callback structures for each registered resource controller.
+ */
+ckrm_res_callback_t ckrm_res_ctlrs[CKRM_MAX_RES_CTLRS];
+static spinlock_t ckrm_res_ctlrs_lock = SPIN_LOCK_UNLOCKED; // protects the array
+long bit_res_ctlrs = 0; // bit set for registered resource controllers
+static atomic_t nr_resusers[CKRM_MAX_RES_CTLRS]; // no of users for each res ctlr
+static int max_resid = 0; // highest resource id currently used.
+
+EXPORT_SYMBOL(ckrm_res_ctlrs);
+
+/*
+ * Callback registered by the classification engine.
+ * The chances of two engines trying to register/unregister at the same
+ * moment is very less. So, it is ok to not have any locking mechanism
+ * protecting ckrm_eng_callbacks data structure.
+ */
+static ckrm_eng_callback_t ckrm_eng_callbacks;
+static atomic_t nr_engusers; // Number of users using the data structure above.
+static int callbacks_active = 0;
+
+/* 
+ * Default Class and global variables
+ */
+
+static int ckrm_num_classes = 1;
+static LIST_HEAD(ckrm_classes);
+
+struct ckrm_core_class ckrm_dflt_class = { .class_type = CKRM_TASK_CLASS };
+struct ckrm_core_class ckrm_net_root   = { .class_type = CKRM_NET_CLASS };
+
+EXPORT_SYMBOL(ckrm_dflt_class);
+EXPORT_SYMBOL(ckrm_net_root);
+
+rwlock_t               ckrm_class_lock = RW_LOCK_UNLOCKED;  // protect the class and rc hierarchy structure add/del
+
+
+/**************************************************************************
+ *                   Helper Functions                                     *
+ **************************************************************************/
+
+/*
+ * Return TRUE if the given core class pointer is valid.
+ */
+inline unsigned int
+is_core_valid(ckrm_core_class_t *core)
+{
+	if (core && (core->magic == CKRM_CORE_MAGIC))
+		return 1;
+	return 0;
+}
+
+/*
+ * Return TRUE if the given resource is registered.
+ */
+inline unsigned int
+is_res_regd(int resid)
+{
+	return (test_bit(resid, &bit_res_ctlrs));
+}
+
+int 
+ckrm_resid_lookup (char *resname)
+{
+	int resid = -1;
+	
+	//for_each_resid(resid) {
+	for (resid=0; resid < CKRM_MAX_RES_CTLRS; resid++) { 
+		if (is_res_regd(resid)) {
+			if (!strncmp(resname, ckrm_res_ctlrs[resid].res_name,CKRM_MAX_RES_NAME))
+				return resid;
+		}
+	}
+	return resid ;
+}
+
+
+/* given a classname return the class handle */
+void *
+ckrm_classobj(char *classname)
+{
+	struct ckrm_core_class *tmp, *core = NULL;
+
+	if (!classname || !*classname) {
+		return NULL;
+	}
+	read_lock(&ckrm_class_lock);
+	list_for_each_entry(tmp, &ckrm_classes, clslist) {
+		if (!strcmp(tmp->dentry->d_name.name, classname)) {
+			core = tmp;
+			break;
+		}
+	}
+	read_unlock(&ckrm_class_lock);
+	return core;
+}
+
+
+
+
+EXPORT_SYMBOL(is_core_valid);
+EXPORT_SYMBOL(is_res_regd);
+EXPORT_SYMBOL(ckrm_resid_lookup);
+EXPORT_SYMBOL(ckrm_classobj);
+
+
+
+/**************************************************************************
+ *                   Internal Functions                                   *
+ **************************************************************************/
+
+#define hnode_2_core(ptr)  ((ptr) ? container_of(ptr,struct ckrm_core_class,hnode) : NULL)
+
+static inline
+void set_callbacks_active(void)
+{
+	callbacks_active = ((atomic_read(&nr_engusers) > 0) &&
+			    (ckrm_eng_callbacks.always_callback || (ckrm_num_classes > 1)));
+}
+
+/*
+ * Change the core class of the given task.
+ */
+void
+ckrm_reclassify_task(struct task_struct *tsk, ckrm_core_class_t *core)
+{
+	int i;
+	ckrm_res_callback_t *rcbs;
+	ckrm_core_class_t *old_core;
+	void *old_res_class, *new_res_class;
+
+	// Remove the task from the current core class
+	if ((old_core = tsk->ckrm_core) != NULL) {
+		spin_lock(&old_core->ckrm_lock);
+		list_del(&tsk->ckrm_link);
+		tsk->ckrm_core = NULL;
+		spin_unlock(&old_core->ckrm_lock);
+	}	
+
+	if (core != NULL) {
+		spin_lock(&core->ckrm_lock);
+		tsk->ckrm_core = core;
+		list_add(&tsk->ckrm_link, &core->tasklist);
+		spin_unlock(&core->ckrm_lock);
+	}
+
+	if (core != old_core) {
+		for (i = 0; i < max_resid; i++) {
+			rcbs = &ckrm_res_ctlrs[i];
+			old_res_class = old_core ? old_core->res_class[i] : NULL;
+			new_res_class = core ? core->res_class[i] : NULL;
+			if (rcbs->change_resclass && (old_res_class != new_res_class)) 
+				(*rcbs->change_resclass)(tsk,old_res_class, new_res_class);
+		}
+	}
+	return;
+}
+
+/*
+ * Reclassify all tasks in the given core class.
+ */
+int
+ckrm_reclassify_class_tasks(struct ckrm_core_class *core)
+{
+	int ret = 0;
+  
+	// Reclassify all tasks in the given core class.
+	if (!list_empty(&core->tasklist)) {
+		struct list_head *lh1, *lh2;
+		ckrm_core_class_t *temp;
+		struct task_struct *tsk;
+
+		read_lock(&ckrm_class_lock);
+		spin_lock(&core->ckrm_lock);
+
+		list_for_each_safe(lh1, lh2, &core->tasklist) {
+			list_del(lh1);
+			tsk = container_of(lh1, struct task_struct, ckrm_link);
+
+			if (ckrm_num_classes > 0) {
+				temp = (*ckrm_eng_callbacks.reclassify)(tsk);
+			} else {
+				temp = &ckrm_dflt_class;
+			}
+			if (unlikely(temp == core)) {
+				// Classification engine still using this core class,
+				temp = NULL;
+				ret = -EBUSY;
+			}
+			tsk->ckrm_core = NULL;
+			ckrm_reclassify_task(tsk, temp);
+		}
+		
+		spin_unlock(&core->ckrm_lock);
+		read_unlock(&ckrm_class_lock);
+	}
+	return ret;
+}
+
+/*
+ * Go through the task list and reclassify all tasks according to the current
+ * classification rules.
+ *
+ */
+static void
+ckrm_reclassify_all_tasks(void)
+{
+	ckrm_core_class_t *temp;
+	struct task_struct *proc, *thread;
+
+	read_lock(&ckrm_class_lock);
+	read_lock(&tasklist_lock);
+	do_each_thread(proc, thread) {
+		if (ckrm_num_classes > 0) {
+			temp = (*ckrm_eng_callbacks.reclassify)(thread);
+		} else {
+			temp = &ckrm_dflt_class;
+		}
+		if (temp != thread->ckrm_core) {
+			ckrm_reclassify_task(thread, temp);
+		}
+	} while_each_thread(proc, thread);
+	read_unlock(&tasklist_lock);
+	read_unlock(&ckrm_class_lock);
+}
+
+	
+
+/****************************************************************************
+ *           Interfaces for classification engine                           *
+ ****************************************************************************/
+
+/*
+ * Registering a callback structure by the classification engine.
+ *
+ * Returns 0 on success -errno for failure.
+ */
+int
+ckrm_register_engine(ckrm_eng_callback_t *ecbs)
+{
+
+	if (atomic_read(&nr_engusers) > 0) {
+		// Some engine is acive, deregister it first.
+		return (-EBUSY);
+	}
+	
+	if (strnlen(ecbs->ckrm_eng_name, CKRM_MAX_ENG_NAME) == 0 ||
+				ecbs->reclassify == NULL) {
+		return (-EINVAL);
+	}
+
+	ckrm_eng_callbacks = *ecbs;
+	atomic_set(&nr_engusers, 1); // existence counted as 1
+	set_callbacks_active();
+	return 0;
+}
+
+/*
+ * Unregistering a callback structure by the classification engine.
+ *
+ * Returns 0 on success -errno for failure.
+ */
+int
+ckrm_unregister_engine(ckrm_eng_callback_t *ecbs)
+{
+	if (atomic_dec_and_test(&nr_engusers) != 1) {
+		// Somebody is currently using the engine, cannot deregister.
+		return (-EBUSY);
+	}
+
+	if (strncmp(ckrm_eng_callbacks.ckrm_eng_name, ecbs->ckrm_eng_name,
+				CKRM_MAX_ENG_NAME) != 0) {
+		atomic_inc(&nr_engusers);
+		// Somebody other than the owner is trying to unregister.
+		return (-EINVAL);
+	}
+
+	memset(&ckrm_eng_callbacks, 0, sizeof(ckrm_eng_callbacks));
+	set_callbacks_active();
+	return 0;
+}
+
+/* functions to manipulate class (core or resource) hierarchies 
+ */
+
+
+/* Caller must ensure ckrm_class_lock held */
+void ckrm_hnode_add(struct ckrm_hnode *node,
+	  	    struct ckrm_hnode *parent )
+{
+	node->parent = parent;
+	INIT_LIST_HEAD(&node->children);
+	INIT_LIST_HEAD(&node->siblings);
+
+//	if (parent)
+//		printk(KERN_ERR "hnode_add: %p\n",&parent->children);
+
+ 	if (parent) {
+		if (!is_core_valid(hnode_2_core(parent)))
+			printk(KERN_ERR "hnode_add: non-NULL invalid parent\n");
+		else {
+			if (&parent->children)
+				list_add(&node->siblings, &parent->children);
+			else
+				printk(KERN_ERR "hnode_add: parent->children not initialized\n");
+		}
+	}
+	
+}
+
+/* Caller must ensure ckrm_class_lock held */
+int ckrm_hnode_remove(struct ckrm_hnode *node)
+{
+	/* ensure that the node does not have children */
+	if (!list_empty(&node->children))
+		return 0;
+	list_del(&node->siblings);
+	node->parent = NULL;
+	return 1;
+}
+
+
+static void 
+ckrm_alloc_res_class(struct ckrm_core_class *core,
+				 struct ckrm_core_class *parent,
+				 int resid)
+{
+	/* 
+	 * Allocate a resource class only if the resource controller has
+	 * registered with core and the engine requests for the class.
+	 */
+
+	if (!is_core_valid(core))
+		return ; 
+
+	
+	core->res_class[resid] = NULL;
+
+	if (test_bit(resid, &bit_res_ctlrs)) {
+		ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
+		
+		if (rcbs->res_alloc) {
+			core->res_class[resid] =(*rcbs->res_alloc)(core,parent);
+			if (core->res_class[resid]) 
+				atomic_inc(&nr_resusers[resid]);
+			else
+				printk(KERN_ERR "Error creating res class\n");
+		}
+	}
+}
+
+/*
+ * Allocate a core class, which in turn allocates resource classes as
+ * specified by the res_mask parameter.
+ *
+ * Return the handle to the core class on success, NULL on failure.
+ */
+
+ckrm_core_class_t *dcore;
+
+struct ckrm_core_class *
+ckrm_alloc_core_class(struct ckrm_core_class *parent, struct dentry *dentry)
+{
+	int i;
+
+	if (!is_core_valid(parent))
+		return NULL; 
+	
+	dcore = kmalloc(sizeof(ckrm_core_class_t), GFP_KERNEL);
+	if (dcore == NULL) 
+		return NULL;
+
+	dcore->magic = CKRM_CORE_MAGIC;
+	dcore->dentry = dentry;
+	INIT_LIST_HEAD(&dcore->tasklist);
+	dcore->ckrm_lock = SPIN_LOCK_UNLOCKED;
+
+	write_lock(&ckrm_class_lock);
+
+	list_add(&dcore->clslist,&ckrm_classes);
+	ckrm_hnode_add(&dcore->hnode, parent ? &parent->hnode : NULL); 
+	ckrm_num_classes++;
+	set_callbacks_active();
+
+	dcore->class_type = parent->class_type;
+	for (i = 0; i < CKRM_MAX_RES_CTLRS; i++) {
+		if (dcore->class_type == ckrm_res_ctlrs[i].res_type)
+			ckrm_alloc_res_class(dcore,parent,i);
+		else
+			dcore->res_class[i] = NULL;
+	}
+
+	write_unlock(&ckrm_class_lock);
+
+	/* Inform CE at last, once core is ready for use */
+	if (callbacks_active && *ckrm_eng_callbacks.class_add) {
+		(*ckrm_eng_callbacks.class_add)(dcore->dentry->d_name.name, (void *)dcore);
+	}
+
+
+	return dcore;
+}
+
+
+static void 
+ckrm_free_res_class(struct ckrm_core_class *core, int resid)
+{
+	/* 
+	 * Free a resource class only if the resource controller has
+	 * registered with core 
+	 */
+
+	if (core->res_class[resid]) {
+		ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
+
+		if (rcbs->res_free) {
+			(*rcbs->res_free)(core->res_class[resid]);
+			atomic_dec(&nr_resusers[resid]);
+			core->res_class[resid] = NULL;	
+		}	
+	}
+}
+
+
+/*
+ * Free a core class 
+ *   requires that all tasks were previously reassigned to another class
+ *
+ * Returns 0 on success -errno on failure.
+ */
+int
+ckrm_free_core_class(struct ckrm_core_class *core)
+{
+	int i;
+
+	if (!is_core_valid(core)) {
+		// Invalid core
+		return (-EINVAL);
+	}
+
+	/* Inform CE first, in case it needs any core class data */
+	if (callbacks_active && *ckrm_eng_callbacks.class_delete) {
+		(*ckrm_eng_callbacks.class_delete)(core->dentry->d_name.name, 
+								(void *)core);
+	}
+	// Clear the magic, so we would know if this core is reused.
+	core->magic = 0;
+
+	// Remove this core class from its linked list.
+	write_lock(&ckrm_class_lock);
+
+	ckrm_hnode_remove(&core->hnode);   /* Hubertus ; locking */
+	list_del(&core->clslist);
+	ckrm_num_classes--;
+
+	set_callbacks_active();
+
+	for (i = 0; i < max_resid; i++) {
+//		if (core->res_class[i]) {
+//		(*ckrm_res_ctlrs[i].res_free)(core->res_class[i]);
+//			atomic_dec(&nr_resusers[i]);
+//		}
+		ckrm_free_res_class(core,i);
+	}
+	write_unlock(&ckrm_class_lock);
+
+	kfree(core);
+	return 0;
+}
+
+EXPORT_SYMBOL(ckrm_hnode_add);
+EXPORT_SYMBOL(ckrm_hnode_remove);
+
+/****************************************************************************
+ *           Interfaces for the resource controller                         *
+ ****************************************************************************/
+/*
+ * Registering a callback structure by the resource controller.
+ *
+ * Returns the resource id(0 or +ve) on success, -errno for failure.
+ */
+static int
+ckrm_register_res_ctlr_intern(ckrm_res_callback_t *rcbs)
+{
+	int resid;
+	
+	if (!rcbs)
+		return -EINVAL;
+
+	resid = rcbs->resid;
+	if (strnlen(rcbs->res_name, CKRM_MAX_RES_NAME) == 0 ||
+	    rcbs->res_alloc        == NULL ||
+	    rcbs->res_free         == NULL ||
+	    rcbs->set_share_values == NULL ||
+	    rcbs->get_share_values == NULL ||
+	    rcbs->get_stats        == NULL ||
+	    resid >= CKRM_MAX_RES_CTLRS ) 
+	{
+		// Name and the above functions are mandatory.
+		return (-EINVAL);
+	}
+
+	spin_lock(&ckrm_res_ctlrs_lock);
+
+	ckrm_res_ctlrs[resid] = *rcbs;
+	atomic_set(&nr_resusers[resid], 0);
+	set_bit(resid, &bit_res_ctlrs);	
+	spin_unlock(&ckrm_res_ctlrs_lock);
+	return resid;
+
+#if 0
+	if (resid >= 0) {
+		if (strnlen(ckrm_res_ctlrs[resid].res_name,CKRM_MAX_RES_NAME) == 0) {
+			ckrm_res_ctlrs[resid] = *rcbs;
+			atomic_set(&nr_resusers[resid], 0);
+			set_bit(resid, &bit_res_ctlrs);	
+			ret = resid;
+			if (resid >= max_resid) {
+				max_resid = resid + 1;
+			}
+		} else {
+			ret = -EBUSY;
+		}
+		spin_unlock(&ckrm_res_ctlrs_lock);
+		return ret;
+	}
+
+	for (i = CKRM_RES_MAX_RSVD; i < CKRM_MAX_RES_CTLRS; i++) {
+		if (strnlen(ckrm_res_ctlrs[i].res_name, CKRM_MAX_RES_NAME) == 0) {
+			ckrm_res_ctlrs[i] = *rcbs;
+			atomic_set(&nr_resusers[i], 0);
+			set_bit(i, &bit_res_ctlrs);	
+			if (i >= max_resid) {
+				max_resid = i + 1;
+			}
+			spin_unlock(&ckrm_res_ctlrs_lock);
+			return i;
+		}
+	}
+	spin_unlock(&ckrm_res_ctlrs_lock);
+	return (-ENOMEM);
+#endif
+}
+
+int
+ckrm_register_res_ctlr(ckrm_res_callback_t *rcbs)
+{
+	struct ckrm_core_class *core;
+	int resid;
+
+	resid = ckrm_register_res_ctlr_intern(rcbs);
+	
+	if (resid >= 0) {
+		/* run through all classes and create the resource class object */
+
+		list_for_each_entry(core, &ckrm_classes, clslist) {
+			printk(KERN_ERR "CKRM .. create res clsobj for <%s>\n",rcbs->res_name);
+			ckrm_alloc_res_class(core,hnode_2_core(core->hnode.parent),resid);
+		}
+	}
+	return resid;
+}
+
+/*
+ * Unregistering a callback structure by the resource controller.
+ *
+ * Returns 0 on success -errno for failure.
+ */
+int
+ckrm_unregister_res_ctlr(int resid)
+{
+	ckrm_res_callback_t *rcbs;
+	struct ckrm_core_class *core;
+
+	if (!is_res_regd(resid))
+		return -EINVAL;
+
+	rcbs = &ckrm_res_ctlrs[resid];
+
+	if (atomic_read(&nr_resusers[resid])) {
+		return -EBUSY;
+	}
+
+	spin_lock(&ckrm_res_ctlrs_lock);
+	memset(&ckrm_res_ctlrs[resid], 0, sizeof(ckrm_res_callback_t));
+	clear_bit(resid, &bit_res_ctlrs);	
+	max_resid = fls(bit_res_ctlrs);
+	spin_unlock(&ckrm_res_ctlrs_lock);
+
+	/* run through all classes and delete the resource class object */
+
+	list_for_each_entry(core, &ckrm_classes, clslist) {
+		printk(KERN_ERR "CKRM .. delete res clsobj for <%s>\n",rcbs->res_name);
+		ckrm_free_res_class(core,resid);
+	}
+
+	return 0;
+}
+
+/**************************************************************************
+ *                   Functions called from classification points          *
+ **************************************************************************/
+
+inline void
+ckrm_new_task(struct task_struct *tsk)
+{
+	/* nothing has to be done at this point 
+	 * but we keep it as a place holder for now
+	 */
+}
+
+
+#define CKRM_CB1(function, tsk) \
+{ \
+	struct ckrm_core_class *core = NULL; \
+\
+	if (callbacks_active && ckrm_eng_callbacks.function) { \
+		        read_lock(&ckrm_class_lock); \
+                        core = (*ckrm_eng_callbacks.function)(tsk); \
+	                if (core && (core != tsk->ckrm_core)) { \
+		               ckrm_reclassify_task(tsk, core); \
+	                } \
+	                read_unlock(&ckrm_class_lock); \
+	} \
+	return; \
+}
+
+#define CKRM_CB1_ARGS(function, tsk, args) \
+{ \
+	struct ckrm_core_class *core = NULL; \
+\
+	if (callbacks_active && ckrm_eng_callbacks.function) { \
+                read_lock(&ckrm_class_lock); \
+                core = (*ckrm_eng_callbacks.function)(tsk, args); \
+	        if (core && (core != tsk->ckrm_core)) { \
+		        ckrm_reclassify_task(tsk, core); \
+	        } \
+		read_unlock(&ckrm_class_lock); \
+	} \
+	return; \
+}
+
+#define CKRM_CB2(function) \
+{ \
+	if (callbacks_active && ckrm_eng_callbacks.function) { \
+                read_lock(&ckrm_class_lock); \
+		(*ckrm_eng_callbacks.function)();\
+		read_unlock(&ckrm_class_lock); \
+	} \
+	return;\
+}
+
+#define CKRM_CB3(function, arg) \
+{\
+	if (callbacks_active && ckrm_eng_callbacks.function) { \
+                read_lock(&ckrm_class_lock); \
+		(*ckrm_eng_callbacks.function)(arg); \
+		read_unlock(&ckrm_class_lock); \
+	} \
+	return;\
+}
+
+void
+ckrm_cb_exec(const char *filename)
+{
+	CKRM_CB1_ARGS(exec, current, filename);
+}
+
+void
+ckrm_cb_fork(struct task_struct *tsk)
+{
+	CKRM_CB1(fork, tsk);
+}
+
+void
+ckrm_reclassify(int pid)
+{
+	struct task_struct *tsk;
+
+	if (pid < 0) {
+		// do we want to treat this as process group ?
+		return;
+	}
+	if (pid) {
+		if ((tsk = find_task_by_pid(pid)) != NULL) {
+			CKRM_CB1(reclassify, tsk);
+		}
+	} else { // reclassify all tasks in the system
+		ckrm_reclassify_all_tasks();
+	}
+	return;
+}
+
+void
+ckrm_cb_exit(struct task_struct *tsk)
+{
+	ckrm_core_class_t *core;
+
+	// Remove the task from the current core class
+	if ((core = tsk->ckrm_core) != NULL) {
+		spin_lock(&core->ckrm_lock);
+		list_del(&tsk->ckrm_link);
+		tsk->ckrm_core = NULL;
+		spin_unlock(&core->ckrm_lock);
+	}	
+
+	CKRM_CB3(exit, tsk);
+}
+
+void
+ckrm_cb_uid(void)
+{
+	CKRM_CB1(uid, current);
+}
+
+void
+ckrm_cb_gid(void)
+{
+	CKRM_CB1(gid, current);
+}
+
+void
+ckrm_cb_manual(struct task_struct *tsk)
+{
+	if (callbacks_active) { 
+		if (ckrm_eng_callbacks.manual) { 
+			read_lock(&ckrm_class_lock); 
+			(*ckrm_eng_callbacks.manual)(tsk); 
+			read_unlock(&ckrm_class_lock); 
+		} 
+	} 
+	return; 
+}
+
+
+void __init ckrm_init(void) 
+{
+	struct ckrm_core_class *core = &ckrm_dflt_class;
+	struct task_struct *tsk;
+	int i;
+
+
+	if (!core)
+		return;
+
+
+	/* Initialize default core class */
+	core->magic = CKRM_CORE_MAGIC;
+	core->dentry = NULL;
+	INIT_LIST_HEAD(&core->tasklist);
+	core->ckrm_lock = SPIN_LOCK_UNLOCKED;
+	for (i = 0; i < CKRM_MAX_RES_CTLRS; i++)
+		core->res_class[i] = NULL;
+	
+	/* Add the default class to the global classes list 
+	 * ckrm_num_classes initialized to 1, don't increment
+	 */
+	
+	write_lock(&ckrm_class_lock);
+	list_add(&core->clslist,&ckrm_classes);
+	ckrm_hnode_add(&core->hnode,NULL);
+	write_unlock(&ckrm_class_lock);
+	
+	spin_lock(&core->ckrm_lock);
+	
+
+	read_lock(&tasklist_lock);
+	for_each_process(tsk) {
+		task_lock(tsk);
+		tsk->ckrm_core = core;
+		INIT_LIST_HEAD(&tsk->ckrm_link);
+		list_add(&tsk->ckrm_link, &core->tasklist);
+			task_unlock(tsk);
+			//printk("ckrm_init: Added %ld to %p\n",(long)tsk->pid,core);
+	}
+	read_unlock(&tasklist_lock);
+	
+	spin_unlock(&core->ckrm_lock);	
+	printk("CKRM Initialized\n");
+}
+
+
+EXPORT_SYMBOL(ckrm_register_engine);
+EXPORT_SYMBOL(ckrm_unregister_engine);
+
+EXPORT_SYMBOL(ckrm_reclassify_task);
+
+EXPORT_SYMBOL(ckrm_register_res_ctlr);
+EXPORT_SYMBOL(ckrm_unregister_res_ctlr);
+
+EXPORT_SYMBOL(ckrm_alloc_core_class);
+EXPORT_SYMBOL(ckrm_free_core_class);
+
+EXPORT_SYMBOL(ckrm_reclassify);
Index: linux-2.6.5/kernel/ckrm/ckrmstub.c
===================================================================
--- linux-2.6.5.orig/kernel/ckrm/ckrmstub.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/kernel/ckrm/ckrmstub.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,30 @@
+/* ckrmstub.c - Stub for Class-based Kernel Resource Management (CKRM)
+ *
+ * Copyright (C) Chandra Seetharaman,  IBM Corp. 2003
+ * 
+ * Provides system call stub for the CKRM system calls.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ * 
+ * 06 Nov 2003
+ *        Created
+ */
+
+#include <linux/linkage.h>
+#include <asm/errno.h>
+
+asmlinkage int
+sys_res_ctrl(unsigned int op, void *data)
+{
+	return -ENOSYS;
+}
+
Index: linux-2.6.5/kernel/ckrm/ckrm_dummy.c
===================================================================
--- linux-2.6.5.orig/kernel/ckrm/ckrm_dummy.c	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/kernel/ckrm/ckrm_dummy.c	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,311 @@
+/* ckrm_dummy.c - Dummy Resource Manager for CKRM
+ *
+ * Copyright (C) Chandra Seetharaman,  IBM Corp. 2003
+ * Copyright (C) Hubertus Franke,      IBM Corp. 2004
+ * 
+ * Provides a Dummy Resource controller for CKRM
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ * 
+ * 06 Nov 2003: Created
+ * 03 Mar 2004: Adopted to new Interface
+ * 
+ */
+
+/* Code Description: TBD
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <asm/errno.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/ckrm.h>
+#include <linux/ckrm_rc.h>
+
+#define DEBUG_CKRM_DUMMY 1
+
+typedef struct ckrm_dummy_res {
+	struct ckrm_hnode  hnode;    /* build our own hierarchy */
+	struct ckrm_shares shares;
+} ckrm_dummy_res_t;
+
+static int my_resid = -1;
+
+#define get_parent(res)  (container_of((res)->hnode.parent,ckrm_dummy_res_t,hnode))
+
+
+
+/* Initialize rescls values
+ * May be called on each rcfs unmount or as part of error recovery
+ * to make share values sane.
+ * Does not traverse hierarchy reinitializing children.
+ */
+
+static void
+dummy_res_initcls_one(void *my_res)
+{
+	ckrm_dummy_res_t *res = my_res;
+
+	res->shares.my_guarantee     = CKRM_SHARE_DONTCARE;
+	res->shares.my_limit         = CKRM_SHARE_DONTCARE;
+	res->shares.total_guarantee  = CKRM_SHARE_DFLT_TOTAL_GUARANTEE;
+	res->shares.total_limit      = CKRM_SHARE_DFLT_TOTAL_LIMIT;
+	res->shares.unused_guarantee = CKRM_SHARE_DFLT_TOTAL_GUARANTEE;
+	res->shares.unused_limit     = CKRM_SHARE_DFLT_TOTAL_LIMIT;
+	
+	/* Don't initiate propagation to children here, caller will do it if needed */
+}
+
+static void
+dummy_res_initcls(void *my_res)
+{
+	ckrm_dummy_res_t *res = my_res;
+
+	/* Write a version which propagates values all the way down 
+	   and replace rcbs callback with that version */
+	
+}
+
+ckrm_dummy_res_t *dres;
+struct ckrm_hnode  *dparhnode;
+ckrm_dummy_res_t *dparres;
+
+static void *
+dummy_res_alloc(struct ckrm_core_class *core, struct ckrm_core_class *parent)
+{
+	//ckrm_dummy_res_t *res;
+	
+
+	dres = kmalloc(sizeof(ckrm_dummy_res_t), GFP_ATOMIC);
+	
+	if (dres) {
+		//struct ckrm_hnode *parhnode = NULL;
+		dparhnode = NULL ;
+
+		if (is_core_valid(parent)) {
+			// ckrm_dummy_res_t  *parres;
+			dparres = ckrm_get_res_class(parent,my_resid,ckrm_dummy_res_t);
+			dparhnode = &dparres->hnode;
+		}
+		ckrm_hnode_add(&dres->hnode, dparhnode);
+		printk(KERN_ERR "dummy_res_alloc: Adding dummy res class %p to %p\n",dres,parent);
+		
+		/* rescls in place, now initialize contents other than hierarchy pointers */
+		dummy_res_initcls_one(dres);
+		
+		/*
+		  else {
+			kfree(dres);
+			printk(KERN_ERR "dummy_res_alloc: Invalid core \n");
+			return NULL;
+		}
+		*/
+	}
+	else
+		printk(KERN_ERR "dummy_res_alloc: failed GFP_ATOMIC alloc\n");
+	return dres;
+}
+
+ckrm_dummy_res_t *d2res, *d2parres;
+
+
+static void
+dummy_res_free(void *my_res)
+{
+	//ckrm_dummy_res_t *res = my_res;
+	//ckrm_dummy_res_t *parres;
+
+	d2res = my_res ;
+
+	if (!d2res) 
+		return;
+
+	d2parres = get_parent(d2res);
+	ckrm_hnode_remove(&d2res->hnode);
+
+	// return child's limit/guarantee to parent node
+	if (d2parres) {
+		if (d2res->shares.my_guarantee >= 0)
+			d2parres->shares.unused_guarantee += d2res->shares.my_guarantee;
+		if (d2res->shares.my_limit >= 0)
+			d2parres->shares.unused_limit += d2res->shares.my_limit;
+	}
+	kfree(d2res);
+	return;
+}
+
+static int
+dummy_set_share_values(void *my_res, struct ckrm_shares *shares)
+{
+	ckrm_dummy_res_t *res = my_res;
+	ckrm_dummy_res_t *parent;
+	int reduce_by;
+	int rc = EINVAL;
+
+	if (!res) 
+		return -EINVAL;
+
+	parent = get_parent(res);
+
+	// we have to ensure that the set of parameters is OK
+
+	// ensure that lim/guarantees are ok wrt to parent total values 
+	// don't have to consider negative special values
+
+	/* FIXME following doesn't appear to be working */
+	if (parent) {
+		if ((shares->my_guarantee > parent->shares.unused_guarantee) ||
+		    (shares->my_limit > parent->shares.unused_limit))
+			goto set_share_err;
+	}
+
+	// translate UNCHANGED to existing values
+	if (shares->total_guarantee == CKRM_SHARE_UNCHANGED)
+		shares->total_guarantee = res->shares.total_guarantee;
+	if (shares->total_limit == CKRM_SHARE_UNCHANGED)
+		shares->total_limit = res->shares.total_limit;
+
+	// we don't allow DONTCARE for totals
+	if ((shares->total_guarantee <= CKRM_SHARE_DONTCARE) || (shares->total_limit <= CKRM_SHARE_DONTCARE))
+		goto set_share_err;
+
+	// check whether total shares still exceeds sum of children (total - unused)
+	if (((reduce_by = shares->total_guarantee - res->shares.total_guarantee) > 0) &&
+	    (reduce_by > res->shares.unused_guarantee))
+		goto set_share_err;
+	if (((reduce_by = shares->total_limit - res->shares.total_limit) > 0) &&
+	    (reduce_by > res->shares.unused_limit))
+		goto set_share_err;
+
+
+	/* Need more sanity checks (first two not being enforced currently):
+	 *  1. guarantee < limit
+         *  2. my_* < tot_*
+	 *  etc. Do later.
+	 */
+	// values are OK now enforce them 
+
+	if (shares->my_guarantee > 0) {
+		if (parent) { 
+			parent->shares.unused_guarantee -= shares->my_guarantee;
+			if (res->shares.my_guarantee >= 0)
+				parent->shares.unused_guarantee += res->shares.my_guarantee;
+		}
+		res->shares.my_guarantee = shares->my_guarantee;
+	} else if (shares->my_guarantee == CKRM_SHARE_DONTCARE) {
+		if (parent) 
+			parent->shares.unused_guarantee += res->shares.my_guarantee;
+		res->shares.my_guarantee = CKRM_SHARE_DONTCARE;
+	}
+
+	if (shares->my_limit > 0) {
+		if (parent) { 
+			parent->shares.unused_limit -= shares->my_limit;
+			if (res->shares.my_limit >= 0)
+				parent->shares.unused_limit += res->shares.my_limit;
+		}
+		res->shares.my_limit = shares->my_limit;
+	} else if (shares->my_limit == CKRM_SHARE_DONTCARE) {
+		if (parent) 
+			parent->shares.unused_limit += res->shares.my_limit;
+		res->shares.my_limit = CKRM_SHARE_DONTCARE;
+	}
+
+
+	res->shares.unused_guarantee += (shares->total_guarantee - res->shares.total_guarantee);
+	res->shares.unused_limit     += (shares->total_limit     - res->shares.total_limit);
+
+	res->shares.total_guarantee  = shares->total_guarantee;
+	res->shares.total_limit      = shares->total_limit;
+
+	/* Here we should force the propagation of share values */
+	
+	rc = 0;
+	goto out;
+
+set_share_err:
+#ifdef DEBUG_CKRM_DUMMY
+	dummy_res_initcls_one(res);
+	rc = 0;
+#endif
+out:
+	
+	return rc;
+}
+
+static int
+dummy_get_share_values(void *my_res, struct ckrm_shares *shares)
+{
+	ckrm_dummy_res_t *res = my_res;
+
+	if (!res) 
+		return -EINVAL;
+	*shares = res->shares;
+	return 0;
+}
+
+static int  
+dummy_get_stats(void *my_res, struct seq_file *sfile)
+{
+	ckrm_dummy_res_t *res = my_res;
+
+	if (!res) 
+		return -EINVAL;
+
+	seq_printf(sfile, "res=dummy: these are my stats <none>\n");
+
+	return 0;
+}
+
+static void
+dummy_change_resclass(struct task_struct *tsk, void *old, void *new)
+{
+	// does nothing
+	return;
+}
+
+ckrm_res_callback_t dummy_rcbs = {
+	.res_name          = "dummy",
+	.res_hdepth	   = 1,
+	.res_type	   = CKRM_TASK_CLASS,
+	.resid		   = CKRM_RES_DUMMY,
+	.res_alloc         = dummy_res_alloc,
+	.res_free          = dummy_res_free,
+	.set_share_values  = dummy_set_share_values,
+	.get_share_values  = dummy_get_share_values,
+	.get_stats         = dummy_get_stats,
+	.change_resclass   = dummy_change_resclass,
+	.res_initcls       = dummy_res_initcls_one,
+};
+
+int __init
+init_ckrm_dummy_res(void)
+{
+	my_resid = ckrm_register_res_ctlr(&dummy_rcbs);
+	return 0;
+}	
+
+void __exit
+exit_ckrm_dummy_res(void)
+{
+	ckrm_unregister_res_ctlr(my_resid);
+}
+
+
+module_init(init_ckrm_dummy_res)
+module_exit(exit_ckrm_dummy_res)
+
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.5/kernel/Makefile
===================================================================
--- linux-2.6.5.orig/kernel/Makefile	2004-04-16 15:38:31.000000000 +0200
+++ linux-2.6.5/kernel/Makefile	2004-04-16 15:38:35.000000000 +0200
@@ -7,7 +7,7 @@
 	    sysctl.o capability.o ptrace.o timer.o user.o \
 	    signal.o sys.o kmod.o workqueue.o pid.o \
 	    rcupdate.o intermodule.o extable.o params.o posix-timers.o \
-	    kthread.o
+	    kthread.o ckrm/
 
 obj-$(CONFIG_FUTEX) += futex.o
 obj-$(CONFIG_GENERIC_ISA_DMA) += dma.o
Index: linux-2.6.5/kernel/sys.c
===================================================================
--- linux-2.6.5.orig/kernel/sys.c	2004-04-16 15:38:32.000000000 +0200
+++ linux-2.6.5/kernel/sys.c	2004-04-16 15:38:35.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/security.h>
 #include <linux/dcookies.h>
 #include <linux/suspend.h>
+#include <linux/ckrm.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -585,6 +586,9 @@
 	current->fsgid = new_egid;
 	current->egid = new_egid;
 	current->gid = new_rgid;
+
+	ckrm_cb_gid();
+
 	return 0;
 }
 
@@ -622,6 +626,9 @@
 	}
 	else
 		return -EPERM;
+
+	ckrm_cb_gid();
+
 	return 0;
 }
   
@@ -710,6 +717,8 @@
 		current->suid = current->euid;
 	current->fsuid = current->euid;
 
+	ckrm_cb_uid();
+
 	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RE);
 }
 
@@ -755,6 +764,8 @@
 	current->fsuid = current->euid = uid;
 	current->suid = new_suid;
 
+	ckrm_cb_uid();
+
 	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_ID);
 }
 
@@ -801,6 +812,8 @@
 	if (suid != (uid_t) -1)
 		current->suid = suid;
 
+	ckrm_cb_uid();
+
 	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RES);
 }
 
@@ -850,6 +863,9 @@
 		current->gid = rgid;
 	if (sgid != (gid_t) -1)
 		current->sgid = sgid;
+
+	ckrm_cb_gid();
+
 	return 0;
 }
 
Index: linux-2.6.5/kernel/exit.c
===================================================================
--- linux-2.6.5.orig/kernel/exit.c	2004-04-16 15:38:32.000000000 +0200
+++ linux-2.6.5/kernel/exit.c	2004-04-16 15:38:35.000000000 +0200
@@ -25,6 +25,7 @@
 #ifdef	CONFIG_KDB
 #include <linux/kdb.h>
 #endif
+#include <linux/ckrm.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -630,6 +631,8 @@
 	int state;
 	struct task_struct *t;
 
+	ckrm_cb_exit(tsk);
+
 	if (signal_pending(tsk) && !tsk->signal->group_exit
 	    && !thread_group_empty(tsk)) {
 		/*
Index: linux-2.6.5/kernel/fork.c
===================================================================
--- linux-2.6.5.orig/kernel/fork.c	2004-04-16 15:38:32.000000000 +0200
+++ linux-2.6.5/kernel/fork.c	2004-04-16 15:38:35.000000000 +0200
@@ -33,6 +33,7 @@
 #include <linux/mount.h>
 #include <linux/objrmap.h>
 
+#include <linux/ckrm.h>
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -267,6 +268,7 @@
 	tsk->thread_info = ti;
 	ti->task = tsk;
 
+	ckrm_new_task(tsk);
 	/* One for us, one for whoever does the "release_task()" (usually parent) */
 	atomic_set(&tsk->usage,2);
 	return tsk;
@@ -1184,6 +1186,8 @@
 	if (!IS_ERR(p)) {
 		struct completion vfork;
 
+		ckrm_cb_fork(p);
+
 		if (clone_flags & CLONE_VFORK) {
 			p->vfork_done = &vfork;
 			init_completion(&vfork);
Index: linux-2.6.5/include/linux/sched.h
===================================================================
--- linux-2.6.5.orig/include/linux/sched.h	2004-04-16 15:38:32.000000000 +0200
+++ linux-2.6.5/include/linux/sched.h	2004-04-16 15:38:35.000000000 +0200
@@ -506,6 +506,11 @@
  * to a stack based synchronous wait) if its doing sync IO.
  */
 	wait_queue_t *io_wait;
+#ifdef CONFIG_CKRM
+	void *ckrm_core;
+	struct list_head ckrm_link;
+	void *ce_data;
+#endif // CONFIG_CKRM
 
 /* TASK_UNMAPPED_BASE */
 	unsigned long map_base;
Index: linux-2.6.5/include/linux/ckrm.h
===================================================================
--- linux-2.6.5.orig/include/linux/ckrm.h	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/include/linux/ckrm.h	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,76 @@
+/* ckrm.h - Class-based Kernel Resource Management (CKRM)
+ *
+ * Copyright (C) Hubertus Franke, IBM Corp. 2003
+ *           (C) Shailabh Nagar,  IBM Corp. 2003
+ *           (C) Chandra Seetharaman, IBM Corp. 2003
+ * 
+ * 
+ * Provides a base header file including macros and basic data structures.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 28 Aug 2003
+ *        Created.
+ * 06 Nov 2003
+ *        Made modifications to suit the new RBCE module.
+ * 10 Nov 2003
+ *        Added callbacks_active and surrounding logic. Added task paramter
+ *        for all CE callbacks.
+ */
+
+#ifndef _LINUX_CKRM_H
+#define _LINUX_CKRM_H
+
+#ifdef __KERNEL__
+#ifdef CONFIG_CKRM
+
+// Data structure and function to get the list of registered 
+// resource controllers.
+
+#include <linux/sched.h>
+
+extern void ckrm_init(void);
+
+// Interfaces used from classification points
+extern void ckrm_cb_exec(const char *);
+extern void ckrm_cb_fork(struct task_struct *);
+extern void ckrm_cb_exit(struct task_struct *);
+extern void ckrm_cb_uid(void);
+extern void ckrm_cb_gid(void);
+extern void ckrm_cb_apptag(void);
+extern void ckrm_cb_login(void);
+extern void ckrm_cb_useradd(struct user_struct *);
+extern void ckrm_cb_userdel(struct user_struct *);
+extern void ckrm_new_task(struct task_struct *);
+
+// Utility functions.
+extern int get_exe_path_name(struct task_struct *, char *, int);
+
+#else // !CONFIG_CKRM
+
+#define ckrm_init()
+#define ckrm_cb_exec(cmd)
+#define ckrm_cb_fork(t)
+#define ckrm_cb_exit(t)
+#define ckrm_cb_uid()
+#define ckrm_cb_gid()
+#define ckrm_cb_apptag()
+#define ckrm_cb_login()
+#define ckrm_cb_useradd(x)
+#define ckrm_cb_userdel(x)
+#define ckrm_new_task(x)
+
+#endif // CONFIG_CKRM
+
+#endif // __KERNEL__
+
+#endif // _LINUX_CKRM_H
Index: linux-2.6.5/include/linux/ckrm_ce.h
===================================================================
--- linux-2.6.5.orig/include/linux/ckrm_ce.h	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/include/linux/ckrm_ce.h	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,80 @@
+/* ckrm_ce.h - Header file to be used by Classification Engine of CKRM
+ *
+ * Copyright (C) Hubertus Franke, IBM Corp. 2003
+ *           (C) Shailabh Nagar,  IBM Corp. 2003
+ *           (C) Chandra Seetharaman, IBM Corp. 2003
+ * 
+ * Provides data structures, macros and kernel API of CKRM for 
+ * classification engine.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 12 Nov 2003
+ *        Created.
+ */
+
+#ifndef _LINUX_CKRM_CE_H
+#define _LINUX_CKRM_CE_H
+
+#ifdef __KERNEL__
+
+#ifdef CONFIG_CKRM
+
+//#include <linux/ckrm.h>
+
+// Max engine name length
+#define CKRM_MAX_ENG_NAME 128
+
+typedef struct ckrm_eng_callback {
+	char ckrm_eng_name[CKRM_MAX_ENG_NAME];
+	void * (*fork)(struct task_struct*); // on fork
+	void * (*exec)(struct task_struct*,const char *filename); // on exec
+
+	void * (*reclassify)(struct task_struct *); // on need
+	void * (*uid)(struct task_struct*);  // on uid change
+	void * (*gid)(struct task_struct*);  // on gid change
+
+	void (*manual)(struct task_struct *);  /* manual reclassification */
+	void (*exit)(struct task_struct *);  /* on exit - just notification */
+
+	void (*class_add)(const char *name, void *core);   /* class added */
+	void (*class_delete)(const char *name, void *core);      /* class deleted */
+
+	void * (*listen_cb)(void *n); // listen callback
+	int always_callback;
+	/* and more to come */
+
+	/* Hubertus.. this should be removed in the final version when API 
+	   transition was done */
+	int  (*engine_ctl)(unsigned int op, void *data); /* user level ctl api */
+} ckrm_eng_callback_t;
+
+typedef struct rbce_eng_callback {
+	int (*mkdir)(struct inode *, struct dentry *, int); // mkdir
+	int (*rmdir)(struct inode *, struct dentry *); // rmdir
+} rbce_eng_callback_t;
+
+extern int ckrm_register_engine(ckrm_eng_callback_t *);
+extern int ckrm_unregister_engine(ckrm_eng_callback_t *);
+extern void *ckrm_classobj(char *);
+extern void ckrm_reclassify(int);
+extern int get_exe_path_name(struct task_struct *t, char *filename, int max_size);
+
+extern int rcfs_register_engine(rbce_eng_callback_t *);
+extern int rcfs_unregister_engine(rbce_eng_callback_t *);
+
+
+#endif // CONFIG_CKRM
+
+#endif // __KERNEL__
+
+#endif // _LINUX_CKRM_CE_H
Index: linux-2.6.5/include/linux/ckrm_rc.h
===================================================================
--- linux-2.6.5.orig/include/linux/ckrm_rc.h	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/include/linux/ckrm_rc.h	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,166 @@
+/* ckrm_res.h - Header file to be used by Resource controllers of CKRM
+ *
+ * Copyright (C) Hubertus Franke, IBM Corp. 2003
+ *           (C) Shailabh Nagar,  IBM Corp. 2003
+ *           (C) Chandra Seetharaman, IBM Corp. 2003
+ *	     (C) Vivek Kashyap , IBM Corp. 2004
+ * 
+ * Provides data structures, macros and kernel API of CKRM for 
+ * resource controllers.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 12 Nov 2003
+ *        Created.
+ */
+
+#ifndef _LINUX_CKRM_RES_H
+#define _LINUX_CKRM_RES_H
+
+#ifdef __KERNEL__
+
+#ifdef CONFIG_CKRM
+
+#include <linux/list.h>
+#include <linux/ckrm.h>
+#include <linux/seq_file.h>
+
+// Class types
+enum {
+	CKRM_TASK_CLASS=1,
+	CKRM_NET_CLASS,
+};
+
+// Modes of CKRM   Hubertus... Mode can disappear ? no implicitely through DONTCARE'S
+#define CKRM_MONITOR_MODE		1
+#define CKRM_MANAGE_MODE		2
+
+extern int ckrm_mode;   /* are we in monitor or in managed mode */
+
+// predefined constants
+#define CKRM_MAX_RES_CTLRS 32
+#define CKRM_MAX_RES_NAME		128
+
+// Predefined macros for known kernel resources
+enum resid {
+	CKRM_RES_DUMMY=0,
+	CKRM_RES_CPU,
+	CKRM_RES_MEM,
+	CKRM_RES_IO,
+	CKRM_RES_SAQ,
+	CKRM_RES_MAX_RSVD,
+};
+
+#define CKRM_CORE_MAGIC		0xBADCAFFE
+
+// Share specifications
+
+typedef struct ckrm_shares {
+	int my_guarantee;
+	int my_limit;
+	int total_guarantee;
+	int total_limit;
+	int unused_guarantee;  // not used as parameters
+	int unused_limit;      // not used as parameters
+} ckrm_shares_t;
+
+#define CKRM_SHARE_UNCHANGED     (-1)  // value to indicate no change
+#define CKRM_SHARE_DONTCARE      (-2)  // value to indicate don't care.
+#define CKRM_SHARE_DFLT_TOTAL_GUARANTEE (100) // Start off with these values
+#define CKRM_SHARE_DFLT_TOTAL_LIMIT     (100) // to simplify set_res_shares logic
+
+/* basic definition of a hierarchy that is to be used by the the CORE classes
+ * and can be used by the resource class objects
+ */
+
+struct ckrm_hnode {
+	struct ckrm_hnode *parent;
+	struct list_head   siblings; /* anchor for sibling list */
+	struct list_head   children; /* anchor for children     */
+};
+
+/* core class definition */
+	
+typedef struct ckrm_core_class {
+	struct list_head tasklist; // list of tasks in this core class; anchor
+	int class_type;			// task class or otherwise
+  	spinlock_t ckrm_lock;           // to protect the list and the array above
+	struct list_head clslist;       // to link up all classes in a single list
+	struct dentry  *dentry;           // dentry of inode in the RCFS
+	int magic;
+	void *res_class[CKRM_MAX_RES_CTLRS]; // per registered resource
+	struct ckrm_hnode  hnode;    // hierarchy
+} ckrm_core_class_t;
+
+#define ckrm_get_res_class(rescls,resid,type)   ((type*)((rescls)->res_class[resid]))
+
+/* resource controller callback structure */
+
+typedef struct ckrm_res_callback {
+	char res_name[CKRM_MAX_RES_NAME];
+	int  res_hdepth;	// maximum hierarchy
+	int  res_type;	        // class type to which resource belongs
+	int  resid;		// (for now) same as the enum resid
+
+	/* allocate/free new resource class object for resource controller */
+	void * (*res_alloc)  (struct ckrm_core_class *core, 
+					struct ckrm_core_class *parent);
+	void (*res_free)     (void *);
+	/* reinitialize existing resource class object */
+	void (*res_initcls)  (void *);
+
+	/* set/get limits/guarantees for a resource controller class */
+	int  (*set_share_values)    (void *, struct ckrm_shares *);
+	int  (*get_share_values)    (void *, struct ckrm_shares *);
+
+	/* statistics access */
+	int  (*get_stats)    (void *, struct seq_file *s);
+
+	void (*change_resclass)(struct task_struct *, void *, void *);
+} ckrm_res_callback_t;
+
+extern int ckrm_register_res_ctlr(ckrm_res_callback_t *);
+extern int ckrm_unregister_res_ctlr(int);
+
+extern inline unsigned int is_core_valid(ckrm_core_class_t *core);
+extern inline unsigned int is_res_regd(int resid);
+extern inline int ckrm_resid_lookup (char *resname);
+
+#define for_each_resid(rid) \
+	for (rid=0; rid < CKRM_MAX_RES_CTLRS; rid++) 
+
+
+/* interface to the RCFS filesystem */
+
+extern struct ckrm_core_class ckrm_dflt_class;
+extern struct ckrm_core_class ckrm_net_root;
+
+extern struct ckrm_core_class *ckrm_alloc_core_class(struct ckrm_core_class *parent, struct dentry *dentry);
+extern int ckrm_free_core_class(struct ckrm_core_class *cls);
+
+// Reclassify the given task to the given core class.
+extern void ckrm_reclassify_task(struct task_struct *, struct ckrm_core_class *);
+
+// Reclassify the given task to the given core class by force
+extern void ckrm_forced_reclassify_task(struct task_struct *, struct ckrm_core_class *);
+
+extern void ckrm_hnode_add(struct ckrm_hnode *node,struct ckrm_hnode *parent );
+extern int  ckrm_hnode_remove(struct ckrm_hnode *node);
+
+
+#endif // CONFIG_CKRM
+
+#endif // __KERNEL__
+
+#endif // _LINUX_CKRM_RES_H
+
+
Index: linux-2.6.5/include/linux/ckrm_res.h
===================================================================
--- linux-2.6.5.orig/include/linux/ckrm_res.h	2003-03-14 13:56:44.000000000 +0100
+++ linux-2.6.5/include/linux/ckrm_res.h	2004-04-16 15:38:35.000000000 +0200
@@ -0,0 +1,36 @@
+/* ckrm_res.h - Dummy resource controller for CKRM
+ *
+ * Copyright (C) Chandra Seetharaman, IBM Corp. 2003
+ * 
+ * 
+ * Provides a dummy resource controller for CKRM
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 06 Nov 2003
+ *        Created.
+ */
+
+#ifndef _LINUX_CKRM_RES_H
+#define _LINUX_CKRM_RES_H
+
+#ifdef CONFIG_CKRM_RES_DUMMY
+
+extern int init_ckrm_dummy_res(void);
+
+#else
+
+#define init_ckrm_dummy_res()
+
+#endif
+
+#endif // _LINUX_CKRM_RES_H
