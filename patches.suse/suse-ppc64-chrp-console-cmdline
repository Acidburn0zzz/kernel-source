diff -p -purNX kernel_exclude.txt x/linux-2.6.0-test10/arch/ppc64/kernel/setup.c linux-2.6.0-test10/arch/ppc64/kernel/setup.c
--- x/linux-2.6.0-test10/arch/ppc64/kernel/setup.c	2003-11-25 20:51:52.000000000 +0100
+++ linux-2.6.0-test10/arch/ppc64/kernel/setup.c	2003-11-26 12:29:26.000000000 +0100
@@ -399,6 +399,44 @@ void parse_cmd_line(unsigned long r3, un
 	}
 #endif
 
+#ifdef CONFIG_PPC_PSERIES
+	/* Hack -- add console=ttySn,9600 if necessary */
+	if(strstr(cmd_line, "console=") == NULL) {
+		struct device_node *prom_stdout = find_path_device(of_stdout_device);
+		u32 *reg;
+		int i;
+		char *name, *val = NULL;
+		printk("of_stdout_device %s\n", of_stdout_device);
+		if (prom_stdout) {
+			name = (char *)get_property(prom_stdout, "name", NULL);
+			if (name) {
+				if (strcmp(name, "serial") == 0) {
+					reg = (u32 *)get_property(prom_stdout, "reg", &i);
+					if (i > 8) {
+						switch (reg[1]) {
+							case 0x3f8: val = "ttyS0,9600"; break;
+							case 0x2f8: val = "ttyS1,9600"; break;
+							case 0x898: val = "ttyS2,9600"; break;
+							case 0x890: val = "ttyS3,9600"; break;
+						}
+					}
+				} else if (strcmp(name, "vty") == 0) {
+					/* pSeries LPAR virtual console */
+					val = "hvc0";
+				}
+				if (val) {
+					char tmp_cmd_line[CMD_LINE_SIZE];
+					snprintf(tmp_cmd_line, CMD_LINE_SIZE,
+							"AUTOCONSOLE console=%s %s",
+							val, cmd_line);
+					memcpy(cmd_line, tmp_cmd_line, CMD_LINE_SIZE);
+					printk("console= not found, add console=%s\n", val);
+				}
+			}
+		}
+	}
+#endif
+
 	/* Look for mem= option on command line */
 	if (strstr(cmd_line, "mem=")) {
 		char *p, *q;
diff -p -purNX kernel_exclude.txt x/linux-2.6.0-test10/include/asm-ppc64/bootinfo.h linux-2.6.0-test10/include/asm-ppc64/bootinfo.h
--- x/linux-2.6.0-test10/include/asm-ppc64/bootinfo.h	2003-11-24 02:32:06.000000000 +0100
+++ linux-2.6.0-test10/include/asm-ppc64/bootinfo.h	2003-11-26 12:30:17.000000000 +0100
@@ -17,6 +17,8 @@
 
 #include <asm/types.h>
 
+#define CMD_LINE_SIZE 512
+
 /* We use a u32 for the type of the fields since they're written by
  * the bootloader which is a 32-bit process and read by the kernel
  * which is a 64-bit process.  This way they can both agree on the
