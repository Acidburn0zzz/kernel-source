Subject: Support for vendor-specific features on ASUS/Panasonic/Sony notebooks
From: Timo Hoenig <thoenig@suse.de>

Cumulative patch of:

   * asus_acpi-SuSE-01.patch
   * panasonic_acpi-SuSE-01.patch
   * sony_acpi-SuSE-01.patch


Signed-off-by: Timo Hoenig <thoenig@suse.de>

diff -urN linux-2.6.12_org/Documentation/acpi/sony_acpi.txt linux-2.6.12/Documentation/acpi/sony_acpi.txt
--- linux-2.6.12_org/Documentation/acpi/sony_acpi.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/Documentation/acpi/sony_acpi.txt	2005-08-22 16:35:26.000000000 +0200
@@ -0,0 +1,87 @@
+ACPI Sony Notebook Control Driver (SNC) Readme
+----------------------------------------------
+	Copyright (C) 2004- 2005 Stelian Pop <stelian@popies.net>
+
+This mini-driver drives the ACPI SNC device present in the 
+ACPI BIOS of the Sony Vaio laptops.
+
+It gives access to some extra laptop functionalities. In 
+its current form, this driver is mainly useful for controlling the
+screen brightness, but it may do more in the future.
+
+You should probably start by trying the sonypi driver, and try
+sony_acpi only if sonypi doesn't work for you.
+
+Usage:
+------
+
+Loading the sony_acpi module will create a /proc/acpi/sony/
+directory populated with a couple of files.
+
+You then read/write integer values from/to those files by using
+standard UNIX tools.
+
+The files are:
+	brightness		current screen brightness
+	brightness_default	screen brightness which will be set
+				when the laptop will be rebooted
+	cdpower			power on/off the internal CD drive
+
+Note that some files may be missing if they are not supported
+by your particular laptop model.
+
+Example usage:
+	# echo "1" > /proc/acpi/sony/brightness
+sets the lowest screen brightness,
+	# echo "8" > /proc/acpi/sony/brightness
+sets the highest screen brightness,
+	# cat /proc/acpi/sony/brightness
+retrieves the current screen brightness.
+
+Development:
+------------
+
+If you want to help with the development of this driver (and
+you are not afraid of any side effects doing strange things with
+your ACPI BIOS could have on your laptop), load the driver and
+pass the option 'debug=1'.
+
+REPEAT: DON'T DO THIS IF YOU DON'T LIKE RISKY BUSINESS.
+
+In your kernel logs you will find the list of all ACPI methods
+the SNC device has on your laptop. You can see the GBRT/SBRT methods
+used to get/set the brightness, but there are others.
+
+I HAVE NO IDEA WHAT THOSE METHODS DO.
+
+The sony_acpi driver creates, for some of those methods (the most 
+current ones found on several Vaio models), an entry under
+/proc/acpi/sony/, just like the 'brightness' one. You can create
+other entries corresponding to your own laptop methods by further
+editing the source (see the 'sony_acpi_values' table, and add a new
+structure to this table with your get/set method names).
+
+Your mission, should you accept it, is to try finding out what 
+those entries are for, by reading/writing random values from/to those
+files and find out what is the impact on your laptop.
+
+Should you find anything interesting, please report it back to me,
+I will not disavow all knowledge of your actions :)
+
+Bugs/Limitations:
+-----------------
+
+* This driver is not based on official documentation from Sony
+  (because there is none), so there is no guarantee this driver
+  will work at all, or do the right thing. Although this hasn't
+  happened to me, this driver could do very bad things to your
+  laptop, including permanent damage.
+  
+* The sony_acpi and sonypi drivers do not interact at all. In the
+  future, sonypi could use sony_acpi to do (part of) its business.
+
+* spicctrl, which is the userspace tool used to communicate with the
+  sonypi driver (through /dev/sonypi) does not try to use the 
+  sony_acpi driver. In the future, spicctrl could try sonypi first, 
+  and if it isn't present, try sony_acpi instead.
+
diff -urN linux-2.6.12_org/drivers/acpi/Kconfig linux-2.6.12/drivers/acpi/Kconfig
--- linux-2.6.12_org/drivers/acpi/Kconfig	2005-08-22 12:12:17.000000000 +0200
+++ linux-2.6.12/drivers/acpi/Kconfig	2005-08-22 16:36:16.000000000 +0200
@@ -233,6 +233,35 @@
 	  If you have a legacy free Toshiba laptop (such as the Libretto L1
 	  series), say Y.
 
+config ACPI_SONY
+	tristate "Sony Laptop Extras" 
+	depends on X86
+	default m
+	  ---help---
+	  This mini-driver drives the ACPI SNC device present in the
+	  ACPI BIOS of the Sony Vaio laptops.
+
+	  It gives access to some extra laptop functionalities. In
+	  its current form, the only thing this driver does is letting 
+	  the user set or query the screen brightness.
+
+	  Read <file:Documentation/acpi/sony_acpi.txt> for more information.
+
+config ACPI_PCC
+        tristate "Panasonic Laptop Extras"
+        depends on X86
+        default m
+           ---help---
+           This driver implements hotkey functionality and access to
+	   various hardware (e.g. LCD brightness) for the
+           Panasonic R1 (N variant), R2, R3, T2, W2, and Y2 laptops.
+
+           Further details and user space tools are available at
+           <http://www.da-cha.org/letsnote/>.
+
+	   If you have one of the above listed Panasonic laptops
+	   say Y or M here.
+
 config ACPI_CUSTOM_DSDT
 	bool "Include Custom DSDT"
 	depends on !STANDALONE
diff -urN linux-2.6.12_org/drivers/acpi/Makefile linux-2.6.12/drivers/acpi/Makefile
--- linux-2.6.12_org/drivers/acpi/Makefile	2005-08-22 12:12:16.000000000 +0200
+++ linux-2.6.12/drivers/acpi/Makefile	2005-08-22 16:36:51.000000000 +0200
@@ -54,5 +54,7 @@
 obj-$(CONFIG_ACPI_ASUS)		+= asus_acpi.o
 obj-$(CONFIG_ACPI_IBM)		+= ibm_acpi.o
 obj-$(CONFIG_ACPI_TOSHIBA)	+= toshiba_acpi.o
+obj-$(CONFIG_ACPI_SONY)		+= sony_acpi.o
+obj-$(CONFIG_ACPI_PCC)          += pcc_acpi.o
 obj-$(CONFIG_ACPI_BUS)		+= scan.o motherboard.o
 obj-$(CONFIG_ACPI_HOTPLUG_MEMORY)	+= acpi_memhotplug.o
diff -urN linux-2.6.12_org/drivers/acpi/asus_acpi.c linux-2.6.12/drivers/acpi/asus_acpi.c
--- linux-2.6.12_org/drivers/acpi/asus_acpi.c	2005-08-22 12:12:18.000000000 +0200
+++ linux-2.6.12/drivers/acpi/asus_acpi.c	2005-08-22 16:35:06.000000000 +0200
@@ -26,6 +26,7 @@
  *  Pontus Fuchs   - Helper functions, cleanup
  *  Johann Wiesner - Small compile fixes
  *  John Belmonte  - ACPI code for Toshiba laptop was a good starting point.
+ *  Éric Burghard  - LEDD support (LED display) for W1N
  *
  *  TODO:
  *  add Fn key status
@@ -42,12 +43,14 @@
 #include <acpi/acpi_bus.h>
 #include <asm/uaccess.h>
 
-#define ASUS_ACPI_VERSION "0.29"
+#define ASUS_ACPI_VERSION "0.29-SUSE"
 
 #define PROC_ASUS       "asus"	//the directory
 #define PROC_MLED       "mled"
 #define PROC_WLED       "wled"
 #define PROC_TLED       "tled"
+#define PROC_BTLED      "bled"
+#define PROC_LEDD       "ledd"
 #define PROC_INFO       "info"
 #define PROC_LCD        "lcd"
 #define PROC_BRN        "brn"
@@ -70,6 +73,7 @@
 #define MLED_ON     0x01	//is MLED ON ?
 #define WLED_ON     0x02
 #define TLED_ON     0x04
+#define BTLED_ON    0x08
 
 MODULE_AUTHOR("Julien Lerouge, Karol Kozimor");
 MODULE_DESCRIPTION(ACPI_HOTK_NAME);
@@ -79,9 +83,9 @@
 static uid_t asus_uid;
 static gid_t asus_gid;
 module_param(asus_uid, uint, 0);
-MODULE_PARM_DESC(uid, "UID for entries in /proc/acpi/asus.\n");
+MODULE_PARM_DESC(asus_uid, "UID for entries in /proc/acpi/asus.\n");
 module_param(asus_gid, uint, 0);
-MODULE_PARM_DESC(gid, "GID for entries in /proc/acpi/asus.\n");
+MODULE_PARM_DESC(asus_gid, "GID for entries in /proc/acpi/asus.\n");
 
 
 /* For each model, all features implemented, 
@@ -94,7 +98,10 @@
 	char *wled_status;       //node to handle wled reading_______A
  	char *mt_tled;           //method to handle tled_____________R
  	char *tled_status;       //node to handle tled reading_______A
+ 	char *mt_ledd;           //method to handle ledd_____________R
 	char *mt_lcd_switch;     //method to turn LCD ON/OFF_________A
+	char *mt_btled;          //method to handle btled____________R
+	char *btled_status;      //node to handle btled reading______A
 	char *lcd_status;        //node to read LCD panel state______A
 	char *brightness_up;     //method to set brightness up_______A
 	char *brightness_down;   //guess what ?______________________A
@@ -113,11 +120,14 @@
 	struct acpi_device *device; //the device we are in
 	acpi_handle handle;         //the handle of the hotk device
 	char status;                //status of the hotk, for LEDs, ...
+	u32  ledd_status;           //status of the LEDD (W1N model, cf README)
 	struct model_data *methods; //methods available on the laptop
 	u8 brightness;              //brightness level
 	enum {
 		A1x = 0,  //A1340D, A1300F
 		A2x,      //A2500H
+		A4G,      //A4759GUH
+		A6G,      //A6000
 		D1x,      //D1
 		L2D,      //L2000D
 		L3C,      //L3800C
@@ -128,14 +138,18 @@
 		L8L,      //L8400L
 		M1A,      //M1300A
 		M2E,      //M2400E, L4400L
-		M6N,      //M6800N
-		M6R,      //M6700R
+		M6N,      //M6800N, W3400N
+		M6R,      //M6700R, A3000G
+	        M6V,      //M6V - 8012
 		P30,	  //Samsung P30
 		S1x,      //S1300A, but also L1400B and M2400A (L84F)
 		S2x,      //S200 (J1 reported), Victor MP-XP7210
+		W5A,      //W5A - 8012
+		W5x,      //W5000A
+		V6V,      //V6V
 		xxN,      //M2400N, M3700N, M5200N, S1300N, S5200N, W1OOON
 			  //(Centrino)
-		END_MODEL
+        	END_MODEL
 	} model;              //Models currently supported
 	u16 event_count[128]; //count for each event TODO make this better
 };
@@ -148,17 +162,11 @@
 #define S1x_PREFIX "\\_SB.PCI0.PX40."
 #define S2x_PREFIX A1x_PREFIX
 #define xxN_PREFIX "\\_SB.PCI0.SBRG.EC0."
+#define A6G_PREFIX xxN_PREFIX
+#define W5x_PREFIX xxN_PREFIX
 
 static struct model_data model_conf[END_MODEL] = {
         /*
-	 * Those pathnames are relative to the HOTK / ATKD device :
-	 *       - mt_mled
-	 *       - mt_wled
-	 *       - brightness_set
-	 *       - brightness_get
-	 *       - display_set
-	 *       - display_get
-	 *
 	 * TODO I have seen a SWBX and AIBX method on some models, like L1400B,
 	 * it seems to be a kind of switch, but what for ?
 	 *
@@ -188,6 +196,30 @@
 	},
 
 	{
+		.name              = "A4G",
+		.mt_mled           = "MLED",
+		.mt_wled           = "WLED",
+		.mt_lcd_switch     = xxN_PREFIX "_Q10",
+		.lcd_status        = "\\SWHG",
+		.brightness_set    = "SPLV",
+		.brightness_get    = "GPLV",
+		.display_set       = "SDSP",
+		.display_get       = "\\ADVG"
+	},
+
+	{
+		.name              = "A6G",
+		.mt_mled           = "MLED",
+		.mt_wled           = "WLED",
+		.mt_lcd_switch     = A6G_PREFIX "_Q10",
+		.lcd_status        = "\\BKLT",
+		.brightness_set    = "SPLV",
+		.brightness_get    = "GPLV",
+		.display_set       = "SDSP",
+		.display_get       = "\\ADVG"
+	},
+
+	{
 		.name              = "D1x",
 		.mt_mled           = "MLED",
 		.mt_lcd_switch     = "\\Q0D",
@@ -329,6 +361,19 @@
 		.display_get       = "\\SSTE"
 	},
 
+	{
+		.name              = "M6V",
+		.mt_mled           = NULL,
+		.mt_btled          = "BLED",
+		.mt_wled           = "WLED",
+		.wled_status       = "\\WLSF",
+		.display_get       = "\\_SB.PCI0.P0P3.VGA.GETD",
+		.display_set       = "SDSP",
+		.brightness_set    = "SPLV",
+		.brightness_get    = "GPLV",
+		.mt_lcd_switch     = xxN_PREFIX "_Q10",
+		.lcd_status        = NULL,
+    	},
 
 	{
 		.name              = "P30",
@@ -364,6 +409,45 @@
 	},
 
 	{
+		.name              = "W5A",
+		.mt_btled          = "BLED",
+		.mt_wled           = "WLED",
+		.wled_status       = "\\_SB.PCI0.SBRG.SG13",
+		.display_get       = "\\SSTE",
+		.display_set       = "SDSP",
+		.brightness_set    = "SPLV",
+		.brightness_get    = "GPLV",
+		.mt_lcd_switch     = xxN_PREFIX "_Q10"
+	},
+
+	{
+		.name              = "W5x",
+		.mt_wled           = "WLED",
+		.mt_btled          = "BLED",
+		.mt_lcd_switch     = W5x_PREFIX "_Q10",
+		.lcd_status        = "\\VGAF",
+		.brightness_set    = "SPLV",
+		.brightness_get    = "GPLV",
+		.display_set       = "\\ADVG",
+		.display_get       = "\\SWHG"
+	},
+
+	{
+		.name              = "V6V",
+		.mt_btled          = "BLED",
+		.mt_wled           = "WLED",
+		.mt_tled           = "TLED",
+		.wled_status       = "\\_SB.PCI0.SBRG.SG13",
+		.btled_status      = "\\_SB.PCI0.SBRG.BLTS",
+		.display_get       = "\\_SB.PCI0.P0P1.VGA.GETD",
+		.display_set       = "SDSP",
+		.brightness_set    = "SPLV",
+		.brightness_get    = "GPLV",
+		.mt_lcd_switch     = xxN_PREFIX "_Q10",
+		.lcd_status        = "\\BKLT"
+	},                                 
+
+	{
 		.name              = "xxN",
 		.mt_mled           = "MLED",
 /* WLED present, but not controlled by ACPI */
@@ -584,6 +668,36 @@
 }
 
 /*
+ * Proc handlers for LEDD
+ */
+static int
+proc_read_ledd(char *page, char **start, off_t off, int count, int *eof,
+	       void *data)
+{
+	return sprintf(page, "0x%08x\n", hotk->ledd_status);
+}
+
+static int
+proc_write_ledd(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	int value;
+
+	count = parse_arg(buffer, count, &value);
+	if (count > 0) {
+	        if (!write_acpi_int(hotk->handle, hotk->methods->mt_ledd, value, NULL))
+		      printk(KERN_WARNING "Asus ACPI: LEDD (%s) write failed\n", hotk->methods->mt_ledd);
+		else
+		      hotk->ledd_status = (u32) value;
+        }
+	else if (count < 0)
+		printk(KERN_WARNING "Asus ACPI: Error reading user input\n");
+
+	return count;
+}
+
+
+/*
  * Proc handlers for WLED
  */
 static int
@@ -601,6 +715,24 @@
 }
 
 /*
+ * Proc handlers for BTLED
+ */
+static int
+proc_read_btled(char *page, char **start, off_t off, int count, int *eof,
+	       void *data)
+{
+	return sprintf(page, "%d\n", read_led(hotk->methods->btled_status, BTLED_ON));
+}
+
+
+static int
+proc_write_btled(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	return write_led(buffer, count, hotk->methods->mt_btled, BTLED_ON, 0);
+}
+
+/*
  * Proc handlers for TLED
  */
 static int
@@ -862,6 +994,8 @@
 		mode = S_IFREG | S_IRUGO | S_IWUGO;
 	} else {
 		mode = S_IFREG | S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP;
+		printk(KERN_WARNING "  asus_uid and asus_gid parameters are "
+		       "deprecated, use chown and chmod instead!\n");
 	}
 
 	acpi_device_dir(device) = asus_proc_dir;
@@ -888,9 +1022,17 @@
 		asus_proc_add(PROC_MLED, &proc_write_mled, &proc_read_mled, mode, device);
 	}
 
+	if (hotk->methods->mt_btled) {
+		asus_proc_add(PROC_BTLED, &proc_write_btled, &proc_read_btled, mode, device);
+	}
+
 	if (hotk->methods->mt_tled) {
 		asus_proc_add(PROC_TLED, &proc_write_tled, &proc_read_tled, mode, device);
 	}
+	
+	if (hotk->methods->mt_ledd) {
+		asus_proc_add(PROC_LEDD, &proc_write_ledd, &proc_read_ledd, mode, device);
+	}
 
 	/* 
 	 * We need both read node and write method as LCD switch is also accessible
@@ -920,8 +1062,12 @@
 			remove_proc_entry(PROC_WLED,acpi_device_dir(device));
 		if (hotk->methods->mt_mled)
 			remove_proc_entry(PROC_MLED,acpi_device_dir(device));
+		if (hotk->methods->mt_btled)
+			remove_proc_entry(PROC_BTLED,acpi_device_dir(device));
 		if (hotk->methods->mt_tled)
 			remove_proc_entry(PROC_TLED,acpi_device_dir(device));
+		if (hotk->methods->mt_ledd)
+			remove_proc_entry(PROC_LEDD,acpi_device_dir(device));
 		if (hotk->methods->mt_lcd_switch && hotk->methods->lcd_status)
 			remove_proc_entry(PROC_LCD, acpi_device_dir(device));
 		if ((hotk->methods->brightness_up && hotk->methods->brightness_down) ||
@@ -990,9 +1136,15 @@
 	else if (bsts_result)
 		printk(KERN_NOTICE "  BSTS called, 0x%02x returned\n", bsts_result);
 
+	if (buffer.pointer == NULL)
+		return -EINVAL;
+	model = (union acpi_object *) buffer.pointer;
+
 	/* Samsung P30 has a device with a valid _HID whose INIT does not 
 	 * return anything. Catch this one and any similar here */
-	if (buffer.pointer == NULL) {
+	if (model->type == ACPI_TYPE_STRING) {
+		printk(KERN_NOTICE "  %s model detected, ", model->string.pointer);
+	} else {
 		if (asus_info && /* Samsung P30 */
 		    strncmp(asus_info->oem_table_id, "ODEM", 4) == 0) {
 			hotk->model = P30;
@@ -1007,11 +1159,6 @@
 		return AE_OK;
 	}
 	
-	model = (union acpi_object *) buffer.pointer;
-	if (model->type == ACPI_TYPE_STRING) {
-		printk(KERN_NOTICE "  %s model detected, ", model->string.pointer);
-	}
-
 	hotk->model = END_MODEL;
 	if (strncmp(model->string.pointer, "L3D", 3) == 0)
 		hotk->model = L3D;
@@ -1025,9 +1172,11 @@
 		hotk->model = L8L;
 	else if (strncmp(model->string.pointer, "L4R", 3) == 0)
 		hotk->model = L4R;
-	else if (strncmp(model->string.pointer, "M6N", 3) == 0)
+	else if (strncmp(model->string.pointer, "M6N", 3) == 0 ||
+		 strncmp(model->string.pointer, "W3N", 3) == 0)
 		hotk->model = M6N;
-	else if (strncmp(model->string.pointer, "M6R", 3) == 0)
+	else if (strncmp(model->string.pointer, "M6R", 3) == 0 ||
+	         strncmp(model->string.pointer, "A3G", 3) == 0)
 		hotk->model = M6R;
 	else if (strncmp(model->string.pointer, "M2N", 3) == 0 ||
 		 strncmp(model->string.pointer, "M3N", 3) == 0 ||
@@ -1056,6 +1205,18 @@
 		hotk->model = S2x;
 	else if (strncmp(model->string.pointer, "L5", 2) == 0)
 		hotk->model = L5x;
+	else if (strncmp(model->string.pointer, "A4G", 3) == 0)
+		hotk->model = A4G;
+	else if (strncmp(model->string.pointer, "A6G", 3) == 0)
+		hotk->model = A6G;
+ 	else if (strncmp(model->string.pointer, "W5A", 3) == 0)
+ 		hotk->model = W5A;
+	else if (strncmp(model->string.pointer, "W5", 2) == 0)
+		hotk->model = W5x;
+	else if (strncmp(model->string.pointer, "M6V", 3) == 0)
+		hotk->model = M6V;
+	else if (strncmp(model->string.pointer, "V6V", 3) == 0)
+		hotk->model = V6V;
 
 	if (hotk->model == END_MODEL) {
 		printk("unsupported, trying default values, supply the "
@@ -1072,13 +1233,20 @@
 		hotk->methods->lcd_status = NULL; 
 	/* L2B is similar enough to L3C to use its settings, with this only 
 	   exception */
+	else if (strncmp(model->string.pointer, "A3G", 3) == 0)
+		hotk->methods->lcd_status = "\\BLFG";
+	/* A3G is like M6R */
 	else if (strncmp(model->string.pointer, "S5N", 3) == 0 ||
-		 strncmp(model->string.pointer, "M5N", 3) == 0)
+		 strncmp(model->string.pointer, "M5N", 3) == 0 ||
+		 strncmp(model->string.pointer, "W3N", 3) == 0)
 		hotk->methods->mt_mled = NULL; 
 	/* S5N and M5N have no MLED */
-	else if (strncmp(model->string.pointer, "M2N", 3) == 0 ||
-		 strncmp(model->string.pointer, "W1N", 3) == 0)
-		hotk->methods->mt_wled = "WLED"; 
+	else if (strncmp(model->string.pointer, "M2N", 3) == 0) 
+		hotk->methods->mt_wled = "WLED";
+	else if (strncmp(model->string.pointer, "W1N", 3) == 0) {
+                hotk->methods->mt_wled = "WLED";
+                hotk->methods->mt_ledd = "SLCM";
+	}
 	/* M2N and W1N have a usable WLED */
 	else if (asus_info) {
 		if (strncmp(asus_info->oem_table_id, "L1", 2) == 0)
@@ -1168,6 +1336,9 @@
 		}
 	}
 
+	/* ledd is off by default */
+	hotk->ledd_status = 0xFFF;
+
       end:
 	if (result) {
 		kfree(hotk);
diff -urN linux-2.6.12_org/drivers/acpi/pcc_acpi.c linux-2.6.12/drivers/acpi/pcc_acpi.c
--- linux-2.6.12_org/drivers/acpi/pcc_acpi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/acpi/pcc_acpi.c	2005-08-22 16:36:16.000000000 +0200
@@ -0,0 +1,937 @@
+/*
+ *  Panasonic HotKey and lcd brightness control Extra driver
+ *  (C) 2004 Hiroshi Miura <miura@da-cha.org>
+ *  (C) 2004 NTT DATA Intellilink Co. http://www.intellilink.co.jp/
+ *  (C) 2005 Timo Hoenig <thoenig@nouse.net>
+ *
+ *  derived from toshiba_acpi.c, Copyright (C) 2002-2004 John Belmonte
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as 
+ *  publicshed by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#define ACPI_PCC_VERSION	"0.8.3"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+
+#include <asm/uaccess.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+MODULE_AUTHOR("Hiroshi Miura");
+MODULE_DESCRIPTION("ACPI driver for Panasonic Lets Note laptops");
+MODULE_LICENSE("GPL");
+
+/* Defines */
+#define ACPI_HOTKEY_COMPONENT	0x10000000
+#define _COMPONENT		ACPI_HOTKEY_COMPONENT
+#define HKEY_NOTIFY		0x80
+#define PROC_PCC		"panasonic"
+
+#define PCC_LOG    "pcc_acpi: "
+#define PCC_ERR    KERN_ERR    PCC_LOG 
+#define PCC_INFO   KERN_INFO   PCC_LOG
+
+/* This is transitional definition */
+#ifndef KEY_BATT
+# define KEY_BATT 227
+#endif
+
+#define PROC_STR_MAX_LEN  8
+
+/* LCD_TYPEs: 0 = Normal, 1 = Semi-transparent
+ * ENV_STATEs: Normal temp=0x01, High temp=0x81, N/A=0x00
+ * 
+ */
+enum SINF_BITS { SINF_NUM_BATTERIES = 0,
+                 SINF_LCD_TYPE, SINF_AC_MAX_BRIGHT,
+		 SINF_AC_MIN_BRIGHT, SINF_AC_CUR_BRIGHT, SINF_DC_MAX_BRIGHT,
+		 SINF_DC_MIN_BRIGHT, SINF_DC_CUR_BRIGHT, SINF_MUTE,
+		 SINF_RESERVED,      SINF_ENV_STATE,
+		 SINF_STICKY_KEY = 0x80,
+};
+
+
+static int __devinit acpi_pcc_hotkey_add (struct acpi_device *device);
+static int __devexit acpi_pcc_hotkey_remove (struct acpi_device *device,
+						int type);
+static int acpi_pcc_hotkey_resume(struct acpi_device *device, int state);
+
+static struct acpi_driver acpi_pcc_driver = {
+	.name =		"Panasonic PCC extra driver",
+	.class =	"pcc",
+	.ids =		"MAT0012,MAT0013,MAT0018,MAT0019",
+	.ops =		{
+				.add =    acpi_pcc_hotkey_add,
+				.remove = __devexit_p(acpi_pcc_hotkey_remove),
+				.resume = acpi_pcc_hotkey_resume,
+			},
+};
+
+struct acpi_hotkey {
+	acpi_handle		handle;
+	struct acpi_device	*device;
+	struct proc_dir_entry   *proc_dir_entry;
+	unsigned long		num_sifr;
+	unsigned long		status;
+	struct input_dev	*input_dev;
+	int			sticky_mode;
+};
+
+struct pcc_keyinput {
+	struct acpi_hotkey *hotkey;
+	int key_mode;
+};
+
+/* method access functions */
+static int acpi_pcc_write_sset(struct acpi_hotkey *hotkey, int func, int val)
+{
+	acpi_status status;
+	union acpi_object in_objs[] = {
+		{ .integer.type  = ACPI_TYPE_INTEGER,
+		  .integer.value = func, },
+		{ .integer.type  = ACPI_TYPE_INTEGER,
+		  .integer.value = val, },
+	};
+	struct acpi_object_list params = {
+		.count   = ARRAY_SIZE(in_objs),
+		.pointer = in_objs,
+	};
+
+	status = acpi_evaluate_object(hotkey->handle, "SSET", &params, NULL);
+
+	if (status != AE_OK) {
+		return -1;
+	}
+	
+	return 0;
+}
+
+static inline int acpi_pcc_get_sqty(struct acpi_device *device)
+{
+	acpi_status status;
+	unsigned long s;
+
+	status = acpi_evaluate_integer(device->handle, "SQTY", NULL, &s);
+
+	if (ACPI_SUCCESS(status)) {
+		return(s);
+	}
+	else {
+		printk(PCC_ERR "acpi_pcc_get_sqty() evaluation error \
+				HKEY.SQTY\n");
+		return(-EINVAL);
+	}
+}
+
+static int acpi_pcc_retrieve_biosdata(struct acpi_hotkey *hotkey, u32* sinf) 
+{
+	acpi_status status;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object *hkey = NULL;
+	int i;
+
+	status = acpi_evaluate_object(hotkey->handle, "SINF", 0 , &buffer);
+	if (ACPI_FAILURE(status)) {
+		printk(PCC_ERR "acpi_pcc_retrieve_biosdata() evaluation error \
+				HKEY.SINF\n");
+		return 0;
+	}
+
+	hkey = buffer.pointer;
+	if (!hkey || (hkey->type != ACPI_TYPE_PACKAGE)) {
+		printk(PCC_ERR "acpi_pcc_retrieve_biosdata() invalid \
+				HKEY.SINF\n");
+		goto end;
+	}
+	
+	if (hotkey->num_sifr < hkey->package.count) {
+		printk(PCC_ERR "acpi_pcc_retrieve_biosdata() SQTY reports bad \
+				SINF length\n");
+		status = AE_ERROR;
+		goto end;
+	}
+
+	for (i = 0; i < hkey->package.count; i++) {
+		union acpi_object *element = &(hkey->package.elements[i]);
+		if (likely(element->type == ACPI_TYPE_INTEGER)) {
+			sinf[i] = element->integer.value;
+		}
+		else {
+			printk(PCC_ERR "acpi_pcc_retrieve_biosdata() invalid \
+					HKEY.SINF data");
+		}
+	}
+	sinf[hkey->package.count] = -1;
+
+end:
+	acpi_os_free(buffer.pointer);
+	
+	if (status != AE_OK) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int acpi_pcc_read_sinf_field(struct seq_file *seq, int field)
+{
+	struct acpi_hotkey *hotkey = (struct acpi_hotkey *) seq->private;
+	u32* sinf = kmalloc(sizeof(u32) * (hotkey->num_sifr + 1), GFP_KERNEL);
+
+	if (!sinf) {
+		printk(PCC_ERR "acpi_pcc_read_sinf_field() could not allocate \
+				%li bytes\n", sizeof(u32) * hotkey->num_sifr);
+		return 0;
+	}
+
+	if (acpi_pcc_retrieve_biosdata(hotkey, sinf)) {
+		seq_printf(seq, "%u\n",	sinf[field]);
+	}
+	else {
+		printk(PCC_ERR "acpi_pcc_read_sinf_field() could not retrieve \
+				BIOS data\n");
+	}
+
+	kfree(sinf);
+	return 0;
+}
+
+/* user interface functions
+ *   - read methods
+ *   - SINF read methods
+ *
+ */
+
+#define PCC_SINF_READ_F(_name_, FUNC) \
+static int _name_ (struct seq_file *seq, void *offset) \
+{ \
+	return acpi_pcc_read_sinf_field(seq, (FUNC)); \
+}
+
+PCC_SINF_READ_F(acpi_pcc_numbatteries_show,	 SINF_NUM_BATTERIES);
+PCC_SINF_READ_F(acpi_pcc_lcdtype_show,		 SINF_LCD_TYPE);
+PCC_SINF_READ_F(acpi_pcc_ac_brightness_max_show, SINF_AC_MAX_BRIGHT);
+PCC_SINF_READ_F(acpi_pcc_ac_brightness_min_show, SINF_AC_MIN_BRIGHT);
+PCC_SINF_READ_F(acpi_pcc_ac_brightness_show,	 SINF_AC_CUR_BRIGHT);
+PCC_SINF_READ_F(acpi_pcc_dc_brightness_max_show, SINF_DC_MAX_BRIGHT);
+PCC_SINF_READ_F(acpi_pcc_dc_brightness_min_show, SINF_DC_MIN_BRIGHT);
+PCC_SINF_READ_F(acpi_pcc_dc_brightness_show,	 SINF_DC_CUR_BRIGHT);
+PCC_SINF_READ_F(acpi_pcc_mute_show,		 SINF_MUTE);
+
+static int acpi_pcc_sticky_key_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_hotkey *hotkey = seq->private;
+
+	if (!hotkey || !hotkey->device) {
+		return 0;
+	}
+
+	seq_printf(seq, "%d\n", hotkey->sticky_mode);
+
+	return 0;
+}
+
+static int acpi_pcc_keyinput_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_hotkey *hotkey = (struct acpi_hotkey *) seq->private;
+	struct input_dev *hotk_input_dev = hotkey->input_dev;
+	struct pcc_keyinput *keyinput = hotk_input_dev->private;
+
+	seq_printf(seq, "%d\n", keyinput->key_mode);
+
+	return 0;
+}
+
+static int acpi_pcc_version_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_hotkey *hotkey = (struct acpi_hotkey *) seq->private;
+
+	if (!hotkey || !hotkey->device) {
+		return 0;
+	}
+
+	seq_printf(seq, "%s version %s\n", "Panasonic PCC extra driver",
+			ACPI_PCC_VERSION);
+	seq_printf(seq, "%li functions\n", hotkey->num_sifr);
+
+	return 0;
+}
+
+/* write methods */
+static ssize_t acpi_pcc_write_single_flag (struct file *file,
+                                           const char __user *buffer,
+                                           size_t count,
+                                           int sinf_func)
+{
+	struct seq_file	*seq = file->private_data;
+	struct acpi_hotkey *hotkey = seq->private;
+	char write_string[PROC_STR_MAX_LEN];
+	u32 val;
+
+	if (!hotkey || (count > sizeof(write_string) - 1)) {
+		return -EINVAL;
+        }
+
+	if (copy_from_user(write_string, buffer, count)) {
+		return -EFAULT;
+        }
+	write_string[count] = '\0';
+
+	if (sscanf(write_string, "%i", &val) == 1 && (val == 0 || val == 1)) {
+		acpi_pcc_write_sset(hotkey, sinf_func, val);
+	}
+
+	return count;
+}
+
+static unsigned long acpi_pcc_write_brightness(struct file *file,
+					       const char __user *buffer,
+					       size_t count,
+					       int min_index, int max_index,
+					       int cur_index)
+{
+	struct seq_file	*seq = (struct seq_file *)file->private_data;
+	struct acpi_hotkey *hotkey = (struct acpi_hotkey *)seq->private;
+	char write_string[PROC_STR_MAX_LEN];
+	u32 bright;
+	u32* sinf = kmalloc(sizeof(u32) * (hotkey->num_sifr + 1), GFP_KERNEL);
+
+	if (!hotkey || (count > sizeof(write_string) - 1)) {
+		return -EINVAL;
+	}
+
+	if (!sinf) {
+		printk(PCC_ERR "acpi_pcc_write_brightness() could not \
+				allocate %li bytes\n", 
+				sizeof(u32) * hotkey->num_sifr);
+		return -EFAULT;
+	}
+
+	if (copy_from_user(write_string, buffer, count)) {
+		return -EFAULT;
+	}
+	
+	write_string[count] = '\0';
+
+	if (!acpi_pcc_retrieve_biosdata(hotkey, sinf)) {
+		printk(PCC_ERR "acpi_pcc_write_brightness() could not \
+				retrieve BIOS data\n");
+		goto end;
+	}
+
+	if ((sscanf(write_string, "%i", &bright) == 1) &&
+			(bright >= sinf[min_index]) &&
+			(bright <= sinf[max_index])) {
+		acpi_pcc_write_sset(hotkey, cur_index, bright);
+	}
+
+end: 
+	kfree(sinf);
+	return count;
+}
+
+static ssize_t acpi_pcc_write_ac_brightness(struct file *file,
+					    const char __user *buffer,
+					    size_t count, loff_t *ppos)
+{
+	return acpi_pcc_write_brightness(file, buffer, count,
+					 SINF_AC_MIN_BRIGHT, 
+					 SINF_AC_MAX_BRIGHT, 
+					 SINF_AC_CUR_BRIGHT);
+}
+
+static ssize_t acpi_pcc_write_dc_brightness(struct file *file,
+					    const char __user *buffer,
+					    size_t count, loff_t *ppos)
+{
+	return acpi_pcc_write_brightness(file, buffer, count,
+					 SINF_DC_MIN_BRIGHT, 
+					 SINF_DC_MAX_BRIGHT, 
+					 SINF_DC_CUR_BRIGHT);
+}
+
+static ssize_t acpi_pcc_write_mute (struct file *file,
+				    const char __user *buffer,
+				    size_t count, loff_t *ppos)
+{
+	return acpi_pcc_write_single_flag(file, buffer, count, SINF_MUTE);
+}
+
+static ssize_t acpi_pcc_write_sticky_key (struct file *file,
+					  const char __user *buffer,
+					  size_t count, loff_t *ppos)
+{
+	return acpi_pcc_write_single_flag(file, buffer, count,
+					  SINF_STICKY_KEY);
+}
+
+static ssize_t acpi_pcc_write_keyinput(struct file *file,
+				       const char __user *buffer,
+				       size_t count, loff_t *ppos)
+{
+	struct seq_file	*seq = (struct seq_file *)file->private_data;
+	struct acpi_hotkey *hotkey = (struct acpi_hotkey *)seq->private;
+	struct pcc_keyinput *keyinput;
+	char write_string[PROC_STR_MAX_LEN];
+	int key_mode;
+
+	if (!hotkey || (count > sizeof(write_string) - 1)) {
+		return -EINVAL;
+	}
+
+	if (copy_from_user(write_string, buffer, count)) {
+		return -EFAULT;
+	}
+	
+	write_string[count] = '\0';
+
+	if ((sscanf(write_string, "%i", &key_mode) == 1) &&
+	    (key_mode == 0 || key_mode == 1)) {
+		keyinput = (struct pcc_keyinput *) hotkey->input_dev->private;
+		keyinput->key_mode = key_mode;
+	}
+
+	return count;
+}
+
+/* hotkey driver */
+static void acpi_pcc_generete_keyinput(struct acpi_hotkey *hotkey)
+{
+	struct input_dev *hotk_input_dev = hotkey->input_dev;
+	struct pcc_keyinput *keyinput = hotk_input_dev->private;
+	int hinf = hotkey->status;
+	int key_code, hkey_num;
+	const int key_map[] = {
+		/*  0 */ -1,
+		/*  1 */ KEY_BRIGHTNESSDOWN,
+		/*  2 */ KEY_BRIGHTNESSUP,
+		/*  3 */ -1, /* vga/lcd switch event does not occur on
+			      * hotkey driver.
+			      */
+		/*  4 */ KEY_MUTE,
+		/*  5 */ KEY_VOLUMEDOWN,
+		/*  6 */ KEY_VOLUMEUP,
+		/*  7 */ KEY_SLEEP,
+		/*  8 */ -1, /* Change CPU boost: do nothing */
+		/*  9 */ KEY_BATT,
+		/* 10 */ KEY_SUSPEND,
+	};
+
+	if (keyinput->key_mode == 0) {
+		return;
+	}
+
+	hkey_num = hinf & 0xf;
+
+	if ((0 > hkey_num) || (hkey_num > ARRAY_SIZE(key_map))) {
+		printk(PCC_ERR "acpi_pcc_generete_keyinput() hotkey \
+				number (%d) out of range\n", hkey_num);
+		return;
+	}
+
+	key_code = key_map[hkey_num];
+
+	if (key_code != -1) {
+		int pushed = (hinf & 0x80) ? TRUE : FALSE;
+
+		input_report_key(hotk_input_dev, key_code, pushed);
+		input_sync(hotk_input_dev);
+	}
+
+	return;
+}
+
+static int acpi_pcc_hotkey_get_key(struct acpi_hotkey *hotkey)
+{
+	acpi_status status;
+	unsigned long result;
+
+	status = acpi_evaluate_integer(hotkey->handle, "HINF", NULL, &result);
+	if (likely(ACPI_SUCCESS(status))) {
+		hotkey->status = result;
+	}
+	else {
+		printk(PCC_ERR "acpi_pcc_hotkey_get_key() error getting \
+				hotkey status\n");
+	}
+
+	if (status != AE_OK) {
+		return -1;
+	}
+
+	return 0;
+}
+
+void acpi_pcc_hotkey_notify(acpi_handle handle, u32 event, void *data)
+{
+	struct acpi_hotkey *hotkey = (struct acpi_hotkey *) data;
+
+	switch(event) {
+	case HKEY_NOTIFY:
+		if (acpi_pcc_hotkey_get_key(hotkey)) {
+			/* generate event
+			 *   e.g. '"pcc HKEY 00000080 00000084"' when Fn+F4 is 
+			 *   pressed
+			 *
+			 */
+
+			acpi_bus_generate_event(hotkey->device, event,
+					hotkey->status);
+		}
+		
+		acpi_pcc_generete_keyinput(hotkey);
+		break;
+
+	default:
+		/* nothing to do */
+		break;
+
+	}
+
+	return;
+}
+
+/* proc interface  */
+#define SEQ_OPEN_FS(_open_func_name_, _show_func_name_) \
+    static int _open_func_name_(struct inode *inode, struct file *file) \
+{ \
+            return single_open(file, _show_func_name_, PDE(inode)->data); \
+}
+
+SEQ_OPEN_FS(acpi_pcc_dc_brightness_open_fs,
+	    acpi_pcc_dc_brightness_show);
+SEQ_OPEN_FS(acpi_pcc_numbatteries_open_fs, 
+	    acpi_pcc_numbatteries_show);
+SEQ_OPEN_FS(acpi_pcc_lcdtype_open_fs,
+	    acpi_pcc_lcdtype_show);
+SEQ_OPEN_FS(acpi_pcc_ac_brightness_max_open_fs,
+    	    acpi_pcc_ac_brightness_max_show);
+SEQ_OPEN_FS(acpi_pcc_ac_brightness_min_open_fs,
+	    acpi_pcc_ac_brightness_min_show);
+SEQ_OPEN_FS(acpi_pcc_ac_brightness_open_fs,
+	    acpi_pcc_ac_brightness_show);
+SEQ_OPEN_FS(acpi_pcc_dc_brightness_max_open_fs,
+	    acpi_pcc_dc_brightness_max_show);
+SEQ_OPEN_FS(acpi_pcc_dc_brightness_min_open_fs,
+	    acpi_pcc_dc_brightness_min_show);
+SEQ_OPEN_FS(acpi_pcc_mute_open_fs,
+	    acpi_pcc_mute_show);
+SEQ_OPEN_FS(acpi_pcc_version_open_fs,
+	    acpi_pcc_version_show);
+SEQ_OPEN_FS(acpi_pcc_keyinput_open_fs,
+	    acpi_pcc_keyinput_show);
+SEQ_OPEN_FS(acpi_pcc_sticky_key_open_fs,
+            acpi_pcc_sticky_key_show);
+
+#define SEQ_FILEOPS_R(_open_func_name_) \
+{ \
+            .open    = _open_func_name_, \
+            .read    = seq_read,         \
+            .llseek  = seq_lseek,        \
+            .release = single_release,   \
+}
+
+#define SEQ_FILEOPS_RW(_open_func_name_, _write_func_name_) \
+{ \
+            .open    = _open_func_name_ , \
+            .read    = seq_read,          \
+            .write   = _write_func_name_, \
+            .llseek  = seq_lseek,         \
+            .release = single_release,    \
+}
+
+typedef struct file_operations fops_t;
+
+/* number of batteries */
+static fops_t acpi_pcc_numbatteries_fops = \
+	SEQ_FILEOPS_R (acpi_pcc_numbatteries_open_fs);
+
+/* type of lcd */
+static fops_t acpi_pcc_lcdtype_fops = \
+	SEQ_FILEOPS_R (acpi_pcc_lcdtype_open_fs);
+
+/* mute */
+static fops_t acpi_pcc_mute_fops = \
+	SEQ_FILEOPS_RW(acpi_pcc_mute_open_fs,
+		       acpi_pcc_write_mute);
+
+/* brightness */
+static fops_t acpi_pcc_ac_brightness_fops = \
+	SEQ_FILEOPS_RW(acpi_pcc_ac_brightness_open_fs,
+		       acpi_pcc_write_ac_brightness);
+static fops_t acpi_pcc_ac_brightness_max_fops = \
+	SEQ_FILEOPS_R(acpi_pcc_ac_brightness_max_open_fs);
+static fops_t acpi_pcc_ac_brightness_min_fops = \
+	SEQ_FILEOPS_R(acpi_pcc_ac_brightness_min_open_fs);
+static fops_t acpi_pcc_dc_brightness_fops = \
+	SEQ_FILEOPS_RW(acpi_pcc_dc_brightness_open_fs,
+		       acpi_pcc_write_dc_brightness);
+static fops_t acpi_pcc_dc_brightness_max_fops = \
+	SEQ_FILEOPS_R(acpi_pcc_dc_brightness_max_open_fs);
+static fops_t acpi_pcc_dc_brightness_min_fops = \
+	SEQ_FILEOPS_R(acpi_pcc_dc_brightness_min_open_fs);
+
+/* sticky key */
+static fops_t acpi_pcc_sticky_key_fops = \
+	SEQ_FILEOPS_RW(acpi_pcc_sticky_key_open_fs,
+		       acpi_pcc_write_sticky_key);
+
+/* keyinput */
+static fops_t acpi_pcc_keyinput_fops = \
+	SEQ_FILEOPS_RW(acpi_pcc_keyinput_open_fs,
+	   	       acpi_pcc_write_keyinput);
+
+/* version */
+static fops_t acpi_pcc_version_fops = \
+	SEQ_FILEOPS_R (acpi_pcc_version_open_fs);
+
+typedef struct _ProcItem
+{
+	const char* name;
+	struct file_operations *fops;
+	mode_t flag;
+} ProcItem;
+
+/* Note: These functions map *exactly* to the SINF/SSET functions */
+ProcItem pcc_proc_items_sifr[] =
+{
+	{ "num_batteries",      &acpi_pcc_numbatteries_fops,     S_IRUGO },
+	{ "lcd_type",           &acpi_pcc_lcdtype_fops,          S_IRUGO },
+	{ "ac_brightness_max" , &acpi_pcc_ac_brightness_max_fops,S_IRUGO },
+	{ "ac_brightness_min" , &acpi_pcc_ac_brightness_min_fops,S_IRUGO },
+	{ "ac_brightness" ,     &acpi_pcc_ac_brightness_fops,    S_IFREG |
+								 S_IRUGO |
+								 S_IWUSR },
+	{ "dc_brightness_max" , &acpi_pcc_dc_brightness_max_fops,S_IRUGO },
+	{ "dc_brightness_min" , &acpi_pcc_dc_brightness_min_fops,S_IRUGO },
+	{ "dc_brightness" ,     &acpi_pcc_dc_brightness_fops,    S_IFREG |
+								 S_IRUGO |
+								 S_IWUSR },
+	{ "mute",               &acpi_pcc_mute_fops,             S_IFREG |
+								 S_IRUGO |
+								 S_IWUSR },
+	{ NULL, NULL, 0 },
+};
+
+ProcItem pcc_proc_items[] =
+{
+	{ "sticky_key",		&acpi_pcc_sticky_key_fops,	 S_IFREG |
+								 S_IRUGO |
+								 S_IWUSR },
+	{ "keyinput",           &acpi_pcc_keyinput_fops,         S_IFREG |
+								 S_IRUGO |
+							 	 S_IWUSR },
+	{ "version",            &acpi_pcc_version_fops,          S_IRUGO },
+	{ NULL, NULL, 0 },
+};
+
+static int __init acpi_pcc_add_device(struct acpi_device *device,
+                                      ProcItem *proc_items, 
+                                      int num)
+{
+	struct acpi_hotkey *hotkey = \
+		(struct acpi_hotkey*)acpi_driver_data(device);
+	struct proc_dir_entry* proc;
+	ProcItem* item;
+	int i;
+
+
+	for (item = proc_items, i = 0; item->name && i < num; ++item, ++i) {
+		proc = create_proc_entry(item->name, item->flag,
+					 hotkey->proc_dir_entry); 
+		if (likely(proc)) {
+			proc->proc_fops = item->fops;
+			proc->data = hotkey;
+			proc->owner = THIS_MODULE;
+		}
+		else {
+			while (i-- > 0) {
+				item--;
+				remove_proc_entry(item->name,
+						  hotkey->proc_dir_entry);
+			}
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+static int __init acpi_pcc_proc_init(struct acpi_device *device)
+{
+	acpi_status status;
+	struct acpi_hotkey *hotkey = \
+		(struct acpi_hotkey*)acpi_driver_data(device);
+	struct proc_dir_entry* acpi_pcc_dir;
+
+	acpi_pcc_dir = proc_mkdir(PROC_PCC, acpi_root_dir);
+
+	if (unlikely(!acpi_pcc_dir)) {
+		printk(PCC_ERR "acpi_pcc_proc_init() could not create proc \
+				entry\n");
+		return -ENODEV;
+	}
+
+	acpi_pcc_dir->owner = THIS_MODULE;
+	hotkey->proc_dir_entry = acpi_pcc_dir;
+
+	status = acpi_pcc_add_device(device, pcc_proc_items_sifr,
+				     hotkey->num_sifr);
+	status |= acpi_pcc_add_device(device, pcc_proc_items,
+			              sizeof(pcc_proc_items)/sizeof(ProcItem));
+
+	if (unlikely(status)) {
+		remove_proc_entry(PROC_PCC, acpi_root_dir);
+		hotkey->proc_dir_entry = NULL;
+		return -ENODEV;
+	}
+
+	return status;
+}
+
+static void __exit acpi_pcc_remove_device(struct acpi_device *device,
+                                          ProcItem *proc_items,
+                                          int num)
+{
+	struct acpi_hotkey *hotkey = 
+		(struct acpi_hotkey*)acpi_driver_data(device);
+	ProcItem* item;
+	int i;
+
+	for (item = proc_items, i = 0; item->name != NULL &&
+				        i < num; ++item, ++i) {
+		remove_proc_entry(item->name, hotkey->proc_dir_entry);
+	}
+
+	return;
+}
+
+/* input init */
+static int hotk_input_open(struct input_dev *dev)
+{
+	return 0;
+}
+
+static void hotk_input_close(struct input_dev *dev)
+{
+	return;
+}
+
+static int acpi_pcc_init_input(struct acpi_hotkey *hotkey)
+{
+	struct input_dev *hotk_input_dev;
+	struct pcc_keyinput *pcc_keyinput;
+
+	hotk_input_dev = kmalloc(sizeof(struct input_dev),GFP_KERNEL);
+
+	if (!hotk_input_dev) {
+		printk(PCC_ERR "acpi_pcc_init_input() could not allocate \
+				memory\n");
+		return -ENOMEM;
+	}
+
+	pcc_keyinput = kmalloc(sizeof(struct pcc_keyinput),GFP_KERNEL);
+
+	if (!pcc_keyinput) {
+		printk(PCC_ERR "acpi_pcc_init_input() could not allocate \
+				memory\n");
+		return -ENOMEM;
+	}
+
+	memset(hotk_input_dev, 0, sizeof(struct input_dev));
+	hotk_input_dev->open = hotk_input_open;
+	hotk_input_dev->close = hotk_input_close;
+  
+	hotk_input_dev->evbit[0] = BIT(EV_KEY);
+  
+	set_bit(KEY_BRIGHTNESSDOWN, hotk_input_dev->keybit);
+	set_bit(KEY_BRIGHTNESSUP, hotk_input_dev->keybit);
+	set_bit(KEY_MUTE, hotk_input_dev->keybit);
+	set_bit(KEY_VOLUMEDOWN, hotk_input_dev->keybit);
+	set_bit(KEY_VOLUMEUP, hotk_input_dev->keybit);
+	set_bit(KEY_SLEEP, hotk_input_dev->keybit);
+	set_bit(KEY_BATT, hotk_input_dev->keybit);
+	set_bit(KEY_SUSPEND, hotk_input_dev->keybit);
+ 
+	hotk_input_dev->name = "Panasonic PCC extra driver";
+	hotk_input_dev->phys = "panasonic/hkey0";
+	hotk_input_dev->id.bustype = 0x1a; /* XXX FIXME: BUS_I8042? */
+	hotk_input_dev->id.vendor = 0x0001; 
+	hotk_input_dev->id.product = 0x0001;
+	hotk_input_dev->id.version = 0x0100;
+
+	pcc_keyinput->key_mode = 1; /* default on */
+	pcc_keyinput->hotkey = hotkey; 
+  
+	hotk_input_dev->private = pcc_keyinput;
+
+	hotkey->input_dev = hotk_input_dev;
+
+	input_register_device(hotk_input_dev);
+
+	return 0;
+}
+
+/* module init */
+static int acpi_pcc_hotkey_add (struct acpi_device *device)
+{
+	acpi_status status;
+	struct acpi_hotkey *hotkey = NULL;
+	int num_sifr, result;
+
+	if (!device) {
+		return -EINVAL;
+	}
+
+	num_sifr = acpi_pcc_get_sqty(device);
+	
+	if (num_sifr > 255) {
+		printk(PCC_ERR "acpi_pcc_hotkey_add() num_sifr too large \
+				(%i)\n", num_sifr);
+		return -ENODEV;
+	}
+
+	hotkey = kmalloc(sizeof(struct acpi_hotkey), GFP_KERNEL);
+
+	if (!hotkey) {
+		printk(PCC_ERR "acpi_pcc_hotkey_add() could not allocate \
+				memory\n");
+		return -ENOMEM;
+	}
+
+	memset(hotkey, 0, sizeof(struct acpi_hotkey));
+
+	hotkey->device = device;
+	hotkey->handle = device->handle;
+	hotkey->num_sifr = num_sifr;
+	acpi_driver_data(device) = hotkey;
+	strcpy(acpi_device_name(device), "Panasonic PCC");
+	strcpy(acpi_device_class(device), "pcc");
+
+	status = acpi_install_notify_handler (
+			hotkey->handle,
+			ACPI_DEVICE_NOTIFY,
+			acpi_pcc_hotkey_notify,
+			hotkey);
+
+	if (ACPI_FAILURE(status)) {
+		printk(PCC_ERR "acpi_pcc_hotkey_add() error installing notify \
+				handler\n");
+		kfree(hotkey); 
+		return -ENODEV;
+	}
+
+	result = acpi_pcc_init_input(hotkey);
+
+	if (result) {
+		printk(PCC_ERR "acpi_pcc_hotkey_add() error installing input \
+				handler\n");
+		kfree(hotkey); 
+		return result;
+	}
+
+	return acpi_pcc_proc_init(device);
+}
+
+static int acpi_pcc_hotkey_remove(struct acpi_device *device, int type)
+{
+	acpi_status status;
+	struct acpi_hotkey *hotkey = acpi_driver_data(device);
+
+	if (!device || !hotkey) {
+		return -EINVAL;
+	}
+
+	if (hotkey->proc_dir_entry) {
+		acpi_pcc_remove_device(device, pcc_proc_items_sifr,
+				       hotkey->num_sifr);
+		acpi_pcc_remove_device(device, pcc_proc_items,
+				       sizeof(pcc_proc_items)/sizeof(ProcItem));
+		remove_proc_entry(PROC_PCC, acpi_root_dir);
+	}
+
+	status = acpi_remove_notify_handler(hotkey->handle,
+		    ACPI_DEVICE_NOTIFY, acpi_pcc_hotkey_notify);
+
+	if (ACPI_FAILURE(status)) {
+		printk(PCC_ERR "acpi_pcc_hotkey_remove() error removing \
+				notify handler\n");
+	}
+
+	kfree(hotkey);
+
+	if(status != AE_OK) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int acpi_pcc_hotkey_resume(struct acpi_device *device, int state)
+{
+	acpi_status status;
+	struct acpi_hotkey *hotkey = acpi_driver_data(device);
+
+	if (device == NULL || hotkey == NULL) {
+		return -EINVAL;
+	}
+
+	printk(PCC_INFO "acpi_pcc_hotkey_resume() sticky mode restore: %d\n",
+			hotkey->sticky_mode);
+
+	status = acpi_pcc_write_sset(hotkey, SINF_STICKY_KEY,
+				     hotkey->sticky_mode);
+
+	if (status != AE_OK) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int __init acpi_pcc_init(void)
+{
+	int result = 0;
+ 
+	if (acpi_disabled) {
+		return -ENODEV;
+	}
+
+	result = acpi_bus_register_driver(&acpi_pcc_driver);
+	if (result < 0) {
+		printk(PCC_ERR "error registering hotkey driver\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit acpi_pcc_exit(void)
+{
+	acpi_bus_unregister_driver(&acpi_pcc_driver); 
+
+	return;
+}
+
+module_init(acpi_pcc_init);
+module_exit(acpi_pcc_exit);
diff -urN linux-2.6.12_org/drivers/acpi/sony_acpi.c linux-2.6.12/drivers/acpi/sony_acpi.c
--- linux-2.6.12_org/drivers/acpi/sony_acpi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/acpi/sony_acpi.c	2005-08-22 16:35:26.000000000 +0200
@@ -0,0 +1,392 @@
+/*
+ * ACPI Sony Notebook Control Driver (SNC)
+ *
+ * Copyright (C) 2004-2005 Stelian Pop <stelian@popies.net>
+ *
+ * Parts of this driver inspired from asus_acpi.c and ibm_acpi.c
+ * which are copyrighted by their respective authors.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/acpi_bus.h>
+#include <asm/uaccess.h>
+
+#define ACPI_SNC_CLASS		"sony"
+#define ACPI_SNC_HID		"SNY5001"
+#define ACPI_SNC_DRIVER_NAME	"ACPI Sony Notebook Control Driver v0.2"
+
+#define LOG_PFX			KERN_WARNING "sony_acpi: "
+
+MODULE_AUTHOR("Stelian Pop");
+MODULE_DESCRIPTION(ACPI_SNC_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+static int debug;
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "set this to 1 (and RTFM) if you want to help "
+			"the development of this driver");
+
+static int sony_acpi_add (struct acpi_device *device);
+static int sony_acpi_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver sony_acpi_driver = {
+	.name	= ACPI_SNC_DRIVER_NAME,
+	.class	= ACPI_SNC_CLASS,
+	.ids	= ACPI_SNC_HID,
+	.ops	= {
+			.add	= sony_acpi_add,
+			.remove	= sony_acpi_remove,
+		  },
+};
+
+static acpi_handle sony_acpi_handle;
+static struct proc_dir_entry *sony_acpi_dir;
+
+static struct sony_acpi_value {
+	char			*name;	 /* name of the entry */
+	struct proc_dir_entry 	*proc;	 /* /proc entry */
+	char			*acpiget;/* name of the ACPI get function */
+	char			*acpiset;/* name of the ACPI get function */
+	int 			min;	 /* minimum allowed value or -1 */
+	int			max;	 /* maximum allowed value or -1 */
+	int			debug;	 /* active only in debug mode ? */
+} sony_acpi_values[] = {
+	{
+		.name		= "brightness",
+		.acpiget	= "GBRT",
+		.acpiset	= "SBRT",
+		.min		= 1,
+		.max		= 8,
+		.debug		= 0,
+	},
+	{
+		.name		= "brightness_default",
+		.acpiget	= "GPBR",
+		.acpiset	= "SPBR",
+		.min		= 1,
+		.max		= 8,
+		.debug		= 0,
+	},
+	{
+		.name		= "cdpower",
+		.acpiget	= "GCDP",
+		.acpiset	= "SCDP",
+		.min		= -1,
+		.max		= -1,
+		.debug		= 0,
+	},
+	{
+		.name		= "PID",
+		.acpiget	= "GPID",
+		.debug		= 1,
+	},
+	{
+		.name		= "CTR",
+		.acpiget	= "GCTR",
+		.acpiset	= "SCTR",
+		.min		= -1,
+		.max		= -1,
+		.debug		= 1,
+	},
+	{
+		.name		= "PCR",
+		.acpiget	= "GPCR",
+		.acpiset	= "SPCR",
+		.min		= -1,
+		.max		= -1,
+		.debug		= 1,
+	},
+	{
+		.name		= "CMI",
+		.acpiget	= "GCMI",
+		.acpiset	= "SCMI",
+		.min		= -1,
+		.max		= -1,
+		.debug		= 1,
+	},
+	{
+		.name		= NULL,
+	}
+};
+
+static int acpi_callgetfunc(acpi_handle handle, char *name, int *result)
+{
+	struct acpi_buffer output;
+	union acpi_object out_obj;
+	acpi_status status;
+
+	output.length = sizeof(out_obj);
+	output.pointer = &out_obj;
+
+	status = acpi_evaluate_object(handle, name, NULL, &output);
+	if ((status == AE_OK) && (out_obj.type == ACPI_TYPE_INTEGER)) {
+		*result = out_obj.integer.value;
+		return 0;
+	}
+
+	printk(LOG_PFX "acpi_callreadfunc failed\n");
+
+	return -1;
+}
+
+static int acpi_callsetfunc(acpi_handle handle, char *name, int value,
+			    int *result)
+{
+	struct acpi_object_list params;
+	union acpi_object in_obj;
+	struct acpi_buffer output;
+	union acpi_object out_obj;
+	acpi_status status;
+
+	params.count = 1;
+	params.pointer = &in_obj;
+	in_obj.type = ACPI_TYPE_INTEGER;
+	in_obj.integer.value = value;
+
+	output.length = sizeof(out_obj);
+	output.pointer = &out_obj;
+
+	status = acpi_evaluate_object(handle, name, &params, &output);
+	if (status == AE_OK) {
+		if (result != NULL) {
+			if (out_obj.type != ACPI_TYPE_INTEGER) {
+				printk(LOG_PFX "acpi_evaluate_object bad "
+				       "return type\n");
+				return -1;
+			}
+			*result = out_obj.integer.value;
+		}
+		return 0;
+	}
+
+	printk(LOG_PFX "acpi_evaluate_object failed\n");
+
+	return -1;
+}
+
+static int parse_buffer(const char __user *buffer, unsigned long count,
+			int *val) {
+	char s[32];
+	int ret;
+
+	if (count > 31)
+		return -EINVAL;
+	if (copy_from_user(s, buffer, count))
+		return -EFAULT;
+	s[count] = '\0';
+	ret = simple_strtoul(s, NULL, 10);
+	*val = ret;
+	return 0;
+}
+
+static int sony_acpi_read(char* page, char** start, off_t off, int count,
+			  int* eof, void *data)
+{
+	struct sony_acpi_value *item = data;
+	int value;
+
+	if (!item->acpiget)
+		return -EIO;
+
+	if (acpi_callgetfunc(sony_acpi_handle, item->acpiget, &value) < 0)
+		return -EIO;
+
+	return sprintf(page, "%d\n", value);
+}
+
+static int sony_acpi_write(struct file *file, const char __user *buffer,
+			   unsigned long count, void *data)
+{
+	struct sony_acpi_value *item = data;
+	int result;
+	int value;
+
+	if (!item->acpiset)
+		return -EIO;
+
+	if ((result = parse_buffer(buffer, count, &value)) < 0)
+		return result;
+
+	if (item->min != -1 && value < item->min)
+		return -EINVAL;
+	if (item->max != -1 && value > item->max)
+		return -EINVAL;
+
+	if (acpi_callsetfunc(sony_acpi_handle, item->acpiset, value, NULL) < 0)
+		return -EIO;
+
+	return count;
+}
+
+static void sony_acpi_notify(acpi_handle handle, u32 event, void *data)
+{
+	printk(LOG_PFX "sony_acpi_notify\n");
+}
+
+static acpi_status sony_walk_callback(acpi_handle handle, u32 level,
+				      void *context, void **return_value)
+{
+	struct acpi_namespace_node *node;
+	union acpi_operand_object *operand;
+
+	node = (struct acpi_namespace_node *) handle;
+	operand = (union acpi_operand_object *) node->object;
+
+	printk(LOG_PFX "method: name: %4.4s, args %X\n", node->name.ascii,
+	       (u32) operand->method.param_count);
+
+	return AE_OK;
+}
+
+static int __init sony_acpi_add(struct acpi_device *device)
+{
+	acpi_status status;
+	int result;
+	struct sony_acpi_value *item;
+
+	sony_acpi_handle = device->handle;
+
+	acpi_driver_data(device) = NULL;
+	acpi_device_dir(device) = sony_acpi_dir;
+
+	if (debug) {
+		status = acpi_walk_namespace(ACPI_TYPE_METHOD, sony_acpi_handle,
+					     1, sony_walk_callback, NULL, NULL);
+		if (ACPI_FAILURE(status)) {
+			printk(LOG_PFX "unable to walk acpi resources\n");
+			result = -ENODEV;
+			goto outwalk;
+		}
+
+		status = acpi_install_notify_handler(sony_acpi_handle,
+						     ACPI_DEVICE_NOTIFY,
+						     sony_acpi_notify,
+						     NULL);
+		if (ACPI_FAILURE(status)) {
+			printk(LOG_PFX "unable to install notify handler\n");
+			result = -ENODEV;
+			goto outnotify;
+		}
+	}
+
+	for (item = sony_acpi_values; item->name; ++item) {
+		acpi_handle handle;
+
+		if (!debug && item->debug)
+			continue;
+
+		if (item->acpiget &&
+		    ACPI_FAILURE(acpi_get_handle(sony_acpi_handle,
+		    		 item->acpiget, &handle)))
+		    	continue;
+
+		if (item->acpiset &&
+		    ACPI_FAILURE(acpi_get_handle(sony_acpi_handle,
+		    		 item->acpiset, &handle)))
+		    	continue;
+
+		item->proc = create_proc_entry(item->name, 0600,
+					       acpi_device_dir(device));
+		if (!item->proc) {
+			printk(LOG_PFX "unable to create proc entry\n");
+			result = -EIO;
+			goto outproc;
+		}
+
+		item->proc->read_proc = sony_acpi_read;
+		item->proc->write_proc = sony_acpi_write;
+		item->proc->data = item;
+		item->proc->owner = THIS_MODULE;
+	}
+
+	printk(KERN_INFO ACPI_SNC_DRIVER_NAME " successfully installed\n");
+
+	return 0;
+
+outproc:
+	if (debug) {
+		status = acpi_remove_notify_handler(sony_acpi_handle,
+						    ACPI_DEVICE_NOTIFY,
+						    sony_acpi_notify);
+		if (ACPI_FAILURE(status))
+			printk(LOG_PFX "unable to remove notify handler\n");
+	}
+outnotify:
+	for (item = sony_acpi_values; item->name; ++item)
+		if (item->proc)
+			remove_proc_entry(item->name, acpi_device_dir(device));
+outwalk:
+	return result;
+}
+
+
+static int __exit sony_acpi_remove(struct acpi_device *device, int type)
+{
+	acpi_status status;
+	struct sony_acpi_value *item;
+
+	if (debug) {
+		status = acpi_remove_notify_handler(sony_acpi_handle,
+						    ACPI_DEVICE_NOTIFY,
+						    sony_acpi_notify);
+		if (ACPI_FAILURE(status))
+			printk(LOG_PFX "unable to remove notify handler\n");
+	}
+
+	for (item = sony_acpi_values; item->name; ++item)
+		if (item->proc)
+			remove_proc_entry(item->name, acpi_device_dir(device));
+
+	printk(KERN_INFO ACPI_SNC_DRIVER_NAME " successfully removed\n");
+
+	return 0;
+}
+
+static int __init sony_acpi_init(void)
+{
+	int result;
+
+	sony_acpi_dir = proc_mkdir("sony", acpi_root_dir);
+	if (!sony_acpi_dir) {
+		printk(LOG_PFX "unable to create /proc entry\n");
+		return -ENODEV;
+	}
+	sony_acpi_dir->owner = THIS_MODULE;
+
+	result = acpi_bus_register_driver(&sony_acpi_driver);
+	if (result < 0) {
+		remove_proc_entry("sony", acpi_root_dir);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+
+static void __exit sony_acpi_exit(void)
+{
+	acpi_bus_unregister_driver(&sony_acpi_driver);
+	remove_proc_entry("sony", acpi_root_dir);
+}
+
+module_init(sony_acpi_init);
+module_exit(sony_acpi_exit);
