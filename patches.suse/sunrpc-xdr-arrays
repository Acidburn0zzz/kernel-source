Index: linux-2.6.5/include/linux/sunrpc/svc.h
===================================================================
--- linux-2.6.5.orig/include/linux/sunrpc/svc.h	2004-04-21 02:49:48.971150176 +0200
+++ linux-2.6.5/include/linux/sunrpc/svc.h	2004-04-21 02:51:03.216863112 +0200
@@ -177,6 +177,25 @@
 	return vec->iov_len <= PAGE_SIZE;
 }
 
+static inline struct page *
+svc_take_arg_page(struct svc_rqst *rqstp)
+{
+	if (rqstp->rq_arghi <= rqstp->rq_argused)
+		return NULL;
+	return rqstp->rq_argpages[rqstp->rq_argused++];
+}
+
+static inline struct page *
+svc_take_res_page(struct svc_rqst *rqstp)
+{
+	if (rqstp->rq_arghi <= rqstp->rq_argused)
+		return NULL;
+	rqstp->rq_arghi--;
+	rqstp->rq_respages[rqstp->rq_resused] =
+		rqstp->rq_argpages[rqstp->rq_arghi];
+	return rqstp->rq_respages[rqstp->rq_resused++];
+}
+
 static inline int svc_take_page(struct svc_rqst *rqstp)
 {
 	if (rqstp->rq_arghi <= rqstp->rq_argused)
Index: linux-2.6.5/include/linux/sunrpc/xdr.h
===================================================================
--- linux-2.6.5.orig/include/linux/sunrpc/xdr.h	2004-04-04 05:38:25.000000000 +0200
+++ linux-2.6.5/include/linux/sunrpc/xdr.h	2004-04-21 02:51:03.232860680 +0200
@@ -226,6 +226,22 @@
 		unsigned int base, unsigned int len);
 extern void xdr_read_pages(struct xdr_stream *xdr, unsigned int len);
 
+extern int xdr_encode_word(struct xdr_buf *buf, unsigned int base, u32 w);
+extern int xdr_decode_word(struct xdr_buf *buf, unsigned int base, u32 *w);
+
+struct xdr_array2_desc;
+typedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *desc, void *elem);
+struct xdr_array2_desc {
+	unsigned int elem_size;
+	unsigned int array_len;
+	xdr_xcode_elem_t xcode;
+};
+
+extern int xdr_decode_array2(struct xdr_buf *buf, unsigned int base,
+                             struct xdr_array2_desc *desc);
+extern int xdr_encode_array2(struct xdr_buf *buf, unsigned int base,
+			     struct xdr_array2_desc *desc);
+
 /*
  * Initialize an xdr_stream for decoding data.
  */
Index: linux-2.6.5/net/sunrpc/sunrpc_syms.c
===================================================================
--- linux-2.6.5.orig/net/sunrpc/sunrpc_syms.c	2004-04-04 05:38:12.000000000 +0200
+++ linux-2.6.5/net/sunrpc/sunrpc_syms.c	2004-04-21 02:51:03.241859312 +0200
@@ -131,6 +131,10 @@
 EXPORT_SYMBOL(xdr_shift_buf);
 EXPORT_SYMBOL(xdr_write_pages);
 EXPORT_SYMBOL(xdr_read_pages);
+EXPORT_SYMBOL(xdr_encode_word);
+EXPORT_SYMBOL(xdr_decode_word);
+EXPORT_SYMBOL(xdr_encode_array2);
+EXPORT_SYMBOL(xdr_decode_array2);
 EXPORT_SYMBOL(xdr_buf_from_iov);
 EXPORT_SYMBOL(xdr_buf_subsegment);
 EXPORT_SYMBOL(xdr_buf_read_netobj);
Index: linux-2.6.5/net/sunrpc/xdr.c
===================================================================
--- linux-2.6.5.orig/net/sunrpc/xdr.c	2004-04-04 05:37:37.000000000 +0200
+++ linux-2.6.5/net/sunrpc/xdr.c	2004-04-21 02:52:27.776008168 +0200
@@ -880,3 +880,340 @@
 out:
 	return -1;
 }
+
+int
+xdr_encode_word(struct xdr_buf *buf, unsigned int base, u32 w)
+{
+	/* We ensure that xdr buffers are always 4-byte aligned, so
+	   words will always be entirely in one area of memory in an
+	   xdr_buf. */
+#if 0
+	unsigned int n = 4;
+	w = swab32(w);
+
+	while (n && base < buf->head->iov_len) {
+		((char *) buf->head->iov_base)[base++] = w;
+		w >>= 8;
+		n--;
+	}
+	base -= buf->head->iov_len;
+	if (n && base < buf->page_len) {
+		unsigned int avail = min((unsigned int) PAGE_CACHE_SIZE,
+					 buf->page_len - base);
+		base += buf->page_base;
+		struct page **ppages = buf->pages + (base >> PAGE_CACHE_SHIFT);
+		char *c = kmap(*ppages) + (base & ~PAGE_CACHE_MASK);
+		unsigned int page_avail = min(avail, (unsigned int)
+					      (PAGE_CACHE_SIZE -
+					      (base & ~PAGE_CACHE_MASK)));
+		unsigned int m = min(n, page_avail);
+		n -= m; base += m; avail -= m;
+		while (m) {
+			*c++ = w;
+			w >>= 8;
+			m--;
+		}
+		kunmap(*ppages);
+		if (n && avail) {
+			ppages = buf->pages + ((base + buf->page_base) >>
+					       PAGE_CACHE_SHIFT);
+			c = kmap(*ppages) + (base & ~PAGE_CACHE_MASK);
+			page_avail = min(avail, (unsigned int)
+					 (PAGE_CACHE_SIZE -
+					  (base & ~PAGE_CACHE_MASK)));
+			m = min(n, page_avail);
+			n -= m; base += m;
+			while (m) {
+				*c++ = w;
+				w >>= 8;
+				m--;
+			}
+			kunmap(*ppages);
+		}
+		base -= buf->page_base;
+	}
+	base -= buf->page_len;
+	while (n && base < buf->tail->iov_len) {
+		((char *)buf->tail->iov_base)[base++] = w;
+		w >>= 8;
+		n--;
+	}
+	return n ? -EINVAL : 0;
+#endif
+
+	if (base < buf->head->iov_len) {
+		((u32 *) buf->head->iov_base)[base >> 2] = htonl(w);
+		return 0;
+	}
+	base -= buf->head->iov_len;
+	if (base < buf->page_len) {
+		base += buf->page_base;
+		struct page **ppages = buf->pages + (base >> PAGE_CACHE_SHIFT);
+		u32 *p = (u32 *) kmap(*ppages) +
+			 ((base & ~PAGE_CACHE_MASK) >> 2);
+		*p = htonl(w);
+		kunmap(*ppages);
+		return 0;
+	}
+	base -= buf->page_len;
+	if (base < buf->tail->iov_len) {
+		((u32 *) buf->tail->iov_base)[base >> 2] = htonl(w);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+int
+xdr_decode_word(struct xdr_buf *buf, unsigned int base, u32 *w)
+{
+	/* We ensure that xdr buffers are always 4-byte aligned, so
+	   words will always be entirely in one area of memory in an
+	   xdr_buf. */
+#if 0
+	unsigned int n = 4;
+
+	while (n && base < buf->head->iov_len) {
+		*w = (*w << 8) + ((char *) buf->head->iov_base)[base++];
+		n--;
+	}
+	base -= buf->head->iov_len;
+	if (n && base < buf->page_len) {
+		unsigned int avail = min((unsigned int) PAGE_CACHE_SIZE,
+					 buf->page_len - base);
+		base += buf->page_base;
+		struct page **ppages = buf->pages + (base >> PAGE_CACHE_SHIFT);
+		char *c = kmap(*ppages) + (base & ~PAGE_CACHE_MASK);
+		unsigned int page_avail = min(avail, (unsigned int)
+					      (PAGE_CACHE_SIZE -
+					      (base & ~PAGE_CACHE_MASK)));
+		unsigned int m = min(n, page_avail);
+		n -= m; base += m; avail -= m;
+		while (m) {
+			*w = (*w << 8) + *c++;
+			m--;
+		}
+		kunmap(*ppages);
+		if (n && base < avail) {
+			ppages = buf->pages + ((base + buf->page_base) >>
+					       PAGE_CACHE_SHIFT);
+			c = kmap(*ppages) + (base & ~PAGE_CACHE_MASK);
+			page_avail = min(avail, (unsigned int)
+					 (PAGE_CACHE_SIZE -
+					  (base & ~PAGE_CACHE_MASK)));
+			m = min(n, page_avail);
+			n -= m; base += m;
+			while (m) {
+				*w = (*w << 8) + *c++;
+				m--;
+			}
+			kunmap(*ppages);
+		}
+		base -= buf->page_base;
+	}
+	base -= buf->page_len;
+	while (n && base < buf->tail->iov_len) {
+		*w = (*w << 8) + ((char *)buf->tail->iov_base)[base++];
+		n--;
+	}
+	return n ? -EINVAL : 0;
+#endif
+
+	if (base < buf->head->iov_len) {
+		*w = ntohl(((u32 *) buf->head->iov_base)[base >> 2]);
+		return 0;
+	}
+	base -= buf->head->iov_len;
+	if (base < buf->page_len) {
+		base += buf->page_base;
+		struct page **ppages = buf->pages + (base >> PAGE_CACHE_SHIFT);
+		u32 *p = (u32 *) kmap(*ppages) +
+			 ((base & ~PAGE_CACHE_MASK) >> 2);
+		*w = ntohl(*p);
+		kunmap(*ppages);
+		return 0;
+	}
+	base -= buf->page_len;
+	if (base < buf->tail->iov_len) {
+		*w = ntohl(((u32 *) buf->tail->iov_base)[base >> 2]);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/* Returns 0 on success, or else a negative error code. */
+static int
+xdr_xcode_array2(struct xdr_buf *buf, unsigned int base,
+		 struct xdr_array2_desc *desc, int encode)
+{
+	char elem[desc->elem_size], *c;
+	unsigned int copied = 0, todo, avail_here;
+	struct page **ppages = NULL;
+	int err = 0;
+
+	if (encode) {
+		if (xdr_encode_word(buf, base, desc->array_len) != 0)
+			return -EINVAL;
+	} else {
+		if (xdr_decode_word(buf, base, &desc->array_len) != 0 ||
+		    (unsigned long) base + desc->array_len * desc->elem_size >
+		    buf->len)
+			return -EINVAL;
+	}
+	base += 4;
+
+	if (!desc->xcode)
+		return 0;
+
+	todo = desc->array_len * desc->elem_size;
+	if (base < buf->head->iov_len) {
+		c = buf->head->iov_base + base;
+		avail_here = min(todo, (unsigned int)buf->head->iov_len - base);
+		todo -= avail_here;
+		while (avail_here >= desc->elem_size) {
+			err = desc->xcode(desc, c);
+			if (err)
+				goto out;
+			c += desc->elem_size;
+			avail_here -= desc->elem_size;
+		}
+		if (avail_here) {
+			if (encode) {
+				err = desc->xcode(desc, elem);
+				if (err)
+					goto out;
+				memcpy(c, elem, avail_here);
+			} else
+				memcpy(elem, c, avail_here);
+			copied = avail_here;
+		}
+		if (todo) {
+			base = 0;
+			if (buf->page_len)
+				goto process_pages;
+			else
+				goto process_tail;
+		}
+	} else {
+		base -= buf->head->iov_len;
+		if (base < buf->page_len) {
+		    process_pages:
+			avail_here = min(todo, buf->page_len - base);
+			todo -= avail_here;
+
+			base += buf->page_base;
+			ppages = buf->pages + (base >> PAGE_CACHE_SHIFT);
+			base &= ~PAGE_CACHE_MASK;
+			unsigned int avail_page = min(PAGE_CACHE_SIZE - base,
+						      avail_here);
+			c = kmap(*ppages) + base;
+			while (avail_here) {
+				avail_here -= avail_page;
+				if (copied || avail_page < desc->elem_size) {
+					unsigned int l = min(avail_page,
+						desc->elem_size - copied);
+					if (encode)
+						memcpy(c, elem + copied, l);
+					else
+						memcpy(elem + copied, c, l);
+					copied += l;
+					avail_page -= l;
+					c += l;
+					if (copied == desc->elem_size) {
+						if (!encode) {
+							err = desc->xcode(
+								desc, elem);
+							if (err)
+								goto out;
+						}
+						copied = 0;
+					}
+				}
+				while (avail_page >= desc->elem_size) {
+					err = desc->xcode(desc, c);
+					if (err)
+						goto out;
+					c += desc->elem_size;
+					avail_page -= desc->elem_size;
+				}
+				if (avail_page) {
+					unsigned int l = min(avail_page,
+						    desc->elem_size - copied);
+					if (encode) {
+						if (!copied) {
+							err = desc->xcode(
+								desc, elem);
+							if (err)
+								goto out;
+						}
+						memcpy(c, elem + copied, l);
+					} else
+						memcpy(elem + copied, c, l);
+					copied += l;
+				}
+				if (avail_here) {
+					kunmap(*ppages);
+					ppages++;
+					c = kmap(*ppages);
+				}
+
+				avail_page = min(avail_here,
+					 (unsigned int) PAGE_CACHE_SIZE);
+			}
+			if (todo) {
+				base = 0;
+				goto process_tail;
+			}
+		} else {
+			base -= buf->page_len;
+		    process_tail:
+			c = buf->tail->iov_base + base;
+			if (copied) {
+				unsigned int l = desc->elem_size - copied;
+
+				if (encode)
+					memcpy(c, elem + copied, l);
+				else {
+					memcpy(elem + copied, c, l);
+					err = desc->xcode(desc, elem);
+					if (err)
+						goto out;
+				}
+				todo -= l;
+				c += l;
+			}
+			while (todo) {
+				err = desc->xcode(desc, c);
+				if (err)
+					goto out;
+				c += desc->elem_size;
+				todo -= desc->elem_size;
+			}
+		}
+	}
+	
+    out:
+	if (ppages)
+		kunmap(*ppages);
+	return err;
+}
+
+int
+xdr_decode_array2(struct xdr_buf *buf, unsigned int base,
+		  struct xdr_array2_desc *desc)
+{
+	if (base >= buf->len)
+		return -EINVAL;
+
+	return xdr_xcode_array2(buf, base, desc, 0);
+}
+
+int
+xdr_encode_array2(struct xdr_buf *buf, unsigned int base,
+		  struct xdr_array2_desc *desc)
+{
+	if ((unsigned long) desc->array_len * desc->elem_size + base >=
+	    buf->head->iov_len + buf->page_len + buf->tail->iov_len)
+		return -EINVAL;
+
+	return xdr_xcode_array2(buf, base, desc, 1);
+}
