Index: linux-2.6.0-test9/net/sunrpc/xdr.c
===================================================================
--- linux-2.6.0-test9.orig/net/sunrpc/xdr.c	2003-11-20 11:47:46.000000000 +0100
+++ linux-2.6.0-test9/net/sunrpc/xdr.c	2003-11-21 15:43:23.000000000 +0100
@@ -751,3 +751,290 @@ xdr_read_pages(struct xdr_stream *xdr, u
 	xdr->p = (uint32_t *)((char *)iov->iov_base + padding);
 	xdr->end = (uint32_t *)((char *)iov->iov_base + iov->iov_len);
 }
+
+int
+xdr_encode_word(struct xdr_buf *buf, unsigned int base, u32 w)
+{
+	unsigned int n = 4;
+	w = swab32(w);
+
+	while (n && base < buf->head->iov_len) {
+		((char *) buf->head->iov_base)[base++] = w;
+		w >>= 8;
+		n--;
+	}
+	base -= buf->head->iov_len;
+	if (n && base < buf->page_len) {
+		unsigned int avail = min((unsigned int) PAGE_CACHE_SIZE,
+					 buf->page_len - base);
+		base += buf->page_base;
+		struct page **ppages = buf->pages + (base >> PAGE_CACHE_SHIFT);
+		char *p = kmap(*ppages) + (base & ~PAGE_CACHE_MASK);
+		unsigned int page_avail = min(avail, (unsigned int)
+					      (PAGE_CACHE_SIZE -
+					      (base & ~PAGE_CACHE_MASK)));
+		unsigned int m = min(n, page_avail);
+		n -= m; base += m; avail -= m;
+		while (m && page_avail--) {
+			*p++ = w;
+			w >>= 8;
+			m--;
+		}
+		kunmap(*ppages);
+		if (n && base < buf->page_base + buf->page_len) {
+			ppages = buf->pages + ((base + buf->page_base) >>
+					       PAGE_CACHE_SHIFT);
+			p = kmap(*ppages) + (base & ~PAGE_CACHE_MASK);
+			page_avail = min(avail, (unsigned int)
+					 (PAGE_CACHE_SIZE -
+					  (base & ~PAGE_CACHE_MASK)));
+			m = min(n, page_avail);
+			n -= m; base += m; avail -= m;
+			while (m && page_avail--) {
+				*p++ = w;
+				w >>= 8;
+				m--;
+			}
+			kunmap(*ppages);
+		}
+		base -= buf->page_base;
+	}
+	base -= buf->page_len;
+	while (n && base < buf->tail->iov_len) {
+		((char *)buf->tail->iov_base)[base++] = w;
+		w >>= 8;
+		n--;
+	}
+	return n ? -EINVAL : 0;
+}
+
+int
+xdr_decode_word(struct xdr_buf *buf, unsigned int base, u32 *w)
+{
+	unsigned int n = 4;
+
+	while (n && base < buf->head->iov_len) {
+		*w = (*w << 8) + ((char *) buf->head->iov_base)[base++];
+		n--;
+	}
+	base -= buf->head->iov_len;
+	if (n && base < buf->page_len) {
+		unsigned int avail = min((unsigned int) PAGE_CACHE_SIZE,
+					 buf->page_len - base);
+		base += buf->page_base;
+		struct page **ppages = buf->pages + (base >> PAGE_CACHE_SHIFT);
+		char *p = kmap(*ppages) + (base & ~PAGE_CACHE_MASK);
+		unsigned int page_avail = min(avail, (unsigned int)
+					      (PAGE_CACHE_SIZE -
+					      (base & ~PAGE_CACHE_MASK)));
+		unsigned int m = min(n, page_avail);
+		n -= m; base += m; avail -= m;
+		while (m && page_avail--) {
+			*w = (*w << 8) + *p++;
+			m--;
+		}
+		kunmap(*ppages);
+		if (n && base < buf->page_base + buf->page_len) {
+			ppages = buf->pages + ((base + buf->page_base) >>
+					       PAGE_CACHE_SHIFT);
+			p = kmap(*ppages) + (base & ~PAGE_CACHE_MASK);
+			page_avail = min(avail, (unsigned int)
+					 (PAGE_CACHE_SIZE -
+					  (base & ~PAGE_CACHE_MASK)));
+			m = min(n, page_avail);
+			n -= m; base += m; avail -= m;
+			while (m && page_avail--) {
+				*w = (*w << 8) + *p++;
+				m--;
+			}
+			kunmap(*ppages);
+		}
+		base -= buf->page_base;
+	}
+	base -= buf->page_len;
+	while (n && base < buf->tail->iov_len) {
+		*w = (*w << 8) + ((char *)buf->tail->iov_base)[base++];
+		n--;
+	}
+	return n ? -EINVAL : 0;
+}
+
+/* Returns 0 on success, or else a negative error code. */
+static int
+xdr_xcode_array2(struct xdr_buf *buf, unsigned int base,
+		 struct xdr_array2_desc *desc, int encode)
+{
+	char elem[desc->elem_size], *p;
+	unsigned int copied = 0, avail, todo, avail_here;
+	struct page **ppages = NULL;
+
+	if (encode) {
+		if (xdr_encode_word(buf, base, desc->array_len) != 0)
+			return -EINVAL;
+	} else {
+		if (xdr_decode_word(buf, base, &desc->array_len) != 0 ||
+		    (unsigned long) base + desc->array_len * desc->elem_size >
+		    buf->len)
+			return -EINVAL;
+	}
+	base += 4;
+
+	avail = buf->len;
+	if (base < buf->head->iov_len) {
+		p = buf->head->iov_base + base;
+		avail_here = min(desc->array_len * desc->elem_size,
+				 (unsigned int)buf->head->iov_len - base);
+		todo = desc->array_len * desc->elem_size - avail_here;
+		while (avail_here >= desc->elem_size) {
+			desc->xcode(desc, p);
+			p += desc->elem_size;
+			avail_here -= desc->elem_size;
+		}
+		if (avail_here) {
+			if (encode) {
+				desc->xcode(desc, elem);
+				memcpy(p, elem, avail_here);
+			} else
+				memcpy(elem, p, avail_here);
+			copied = avail_here;
+		}
+		if (todo) {
+			if (buf->page_len) {
+				avail_here = min(todo, buf->page_len);
+				ppages = buf->pages;
+				p = kmap(*ppages) + buf->page_base;
+				goto process_pages;
+			} else {
+				p = (char *) buf->tail->iov_base;
+				goto process_tail;
+			}
+		}
+	} else {
+		base -= buf->head->iov_len;
+		avail -= buf->head->iov_len;
+		if (base < buf->page_len) {
+			ppages = buf->pages +
+				 ((base + buf->page_base) >> PAGE_CACHE_SHIFT);
+			p = kmap(*ppages) +
+			    ((base + buf->page_base) & ~PAGE_CACHE_MASK);
+			todo  = desc->array_len * desc->elem_size;
+			avail_here = min(todo, buf->page_len - base);
+		    process_pages:
+			todo -= avail_here;
+			while (avail_here >= desc->elem_size) {
+				unsigned int avail_page = PAGE_CACHE_SIZE;
+				if (ppages == buf->pages)
+					avail_page -= buf->page_base;
+				avail_page = min(avail_here, avail_page);
+				avail_here -= avail_page;
+				if (copied) {
+					unsigned int l = min(avail_page,
+						desc->elem_size - copied);
+					if (encode)
+						memcpy(p, elem + copied, l);
+					else
+						memcpy(elem + copied, p, l);
+					copied += l;
+					avail_page -= l;
+					p += l;
+					if (copied == desc->elem_size) {
+						if (!encode)
+							desc->xcode(desc,elem);
+						copied = 0;
+					}
+				}
+				while (avail_page >= desc->elem_size) {
+					desc->xcode(desc, p);
+					p += desc->elem_size;
+					avail_page -= desc->elem_size;
+				}
+				if (avail_page != 0) {
+					unsigned int l = min(avail_page,
+						    desc->elem_size - copied);
+					if (encode) {
+						if (!copied)
+							desc->xcode(desc,elem);
+						memcpy(p, elem + copied, l);
+					} else
+						memcpy(elem + copied, p, l);
+					copied += l;
+					BUG_ON(copied >= desc->elem_size);
+				}
+				if (avail_here) {
+					kunmap(*ppages++);
+					p = kmap(*ppages);
+					avail_page = min(PAGE_CACHE_SIZE,
+							 (size_t) avail_here);
+				}
+			}
+			if (avail_here) {
+				if (encode) {
+					if (!copied)
+						desc->xcode(desc, elem);
+					memcpy(p, elem + copied, avail_here);
+				} else
+					memcpy(elem + copied, p, avail_here);
+				copied += avail_here;
+				if (copied == desc->elem_size) {
+					if (!encode)
+						desc->xcode(desc, elem);
+					copied = 0;
+				}
+			}
+			if (todo) {
+				p = buf->tail->iov_base;
+				avail_here = min(todo,
+					(unsigned int) buf->tail->iov_len);
+				goto process_tail;
+			}
+		} else {
+			base -= buf->page_len;
+			avail -= buf->page_len;
+			p = buf->tail->iov_base + base;
+			todo = desc->array_len * desc->elem_size;
+		    process_tail:
+			if (copied) {
+				unsigned int l = desc->elem_size - copied;
+
+				if (encode)
+					memcpy(p, elem + copied, l);
+				else {
+					memcpy(elem + copied, p, l);
+					desc->xcode(desc, elem);
+				}
+				todo -= l;
+				p += l;
+			}
+			while (todo) {
+				desc->xcode(desc, p);
+				p += desc->elem_size;
+				todo -= desc->elem_size;
+			}
+		}
+	}
+	
+	if (ppages)
+		kunmap(*ppages);
+	return 0;
+}
+
+int
+xdr_decode_array2(struct xdr_buf *buf, unsigned int base,
+		  struct xdr_array2_desc *desc)
+{
+	if (base >= buf->len)
+		return -EINVAL;
+
+	return xdr_xcode_array2(buf, base, desc, 0);
+}
+
+int
+xdr_encode_array2(struct xdr_buf *buf, unsigned int base,
+		  struct xdr_array2_desc *desc)
+{
+	if ((unsigned long) desc->array_len * desc->elem_size + base >=
+	    buf->len)
+		return -EINVAL;
+
+	return xdr_xcode_array2(buf, base, desc, 1);
+}
Index: linux-2.6.0-test9/include/linux/sunrpc/svc.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/sunrpc/svc.h	2003-11-18 17:04:10.000000000 +0100
+++ linux-2.6.0-test9/include/linux/sunrpc/svc.h	2003-11-20 11:47:46.000000000 +0100
@@ -176,6 +176,25 @@ xdr_ressize_check(struct svc_rqst *rqstp
 	return vec->iov_len <= PAGE_SIZE;
 }
 
+static inline struct page *
+svc_take_arg_page(struct svc_rqst *rqstp)
+{
+	if (rqstp->rq_arghi <= rqstp->rq_argused)
+		return NULL;
+	return rqstp->rq_argpages[rqstp->rq_argused++];
+}
+
+static inline struct page *
+svc_take_res_page(struct svc_rqst *rqstp)
+{
+	if (rqstp->rq_arghi <= rqstp->rq_argused)
+		return NULL;
+	rqstp->rq_arghi--;
+	rqstp->rq_respages[rqstp->rq_resused] =
+		rqstp->rq_argpages[rqstp->rq_arghi];
+	return rqstp->rq_respages[rqstp->rq_resused++];
+}
+
 static inline int svc_take_page(struct svc_rqst *rqstp)
 {
 	if (rqstp->rq_arghi <= rqstp->rq_argused)
Index: linux-2.6.0-test9/include/linux/sunrpc/xdr.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/sunrpc/xdr.h	2003-11-18 17:04:10.000000000 +0100
+++ linux-2.6.0-test9/include/linux/sunrpc/xdr.h	2003-11-21 15:44:14.000000000 +0100
@@ -224,6 +224,22 @@ extern void xdr_write_pages(struct xdr_s
 		unsigned int base, unsigned int len);
 extern void xdr_read_pages(struct xdr_stream *xdr, unsigned int len);
 
+extern int xdr_encode_word(struct xdr_buf *buf, unsigned int base, u32 w);
+extern int xdr_decode_word(struct xdr_buf *buf, unsigned int base, u32 *w);
+
+struct xdr_array2_desc;
+typedef void (*xdr_xcode_elem_t)(struct xdr_array2_desc *desc, void *elem);
+struct xdr_array2_desc {
+	unsigned int elem_size;
+	unsigned int array_len;
+	xdr_xcode_elem_t xcode;
+};
+
+extern int xdr_decode_array2(struct xdr_buf *buf, unsigned int base,
+                             struct xdr_array2_desc *desc);
+extern int xdr_encode_array2(struct xdr_buf *buf, unsigned int base,
+			     struct xdr_array2_desc *desc);
+
 /*
  * Initialize an xdr_stream for decoding data.
  */
