Index: linux-2.6.0-test9/net/sunrpc/xdr.c
===================================================================
--- linux-2.6.0-test9.orig/net/sunrpc/xdr.c	2003-11-18 17:04:10.000000000 +0100
+++ linux-2.6.0-test9/net/sunrpc/xdr.c	2003-11-19 16:19:12.000000000 +0100
@@ -752,3 +752,183 @@ xdr_read_pages(struct xdr_stream *xdr, u
 	xdr->p = (uint32_t *)((char *)iov->iov_base + padding);
 	xdr->end = (uint32_t *)((char *)iov->iov_base + iov->iov_len);
 }
+
+/* Returns 0 on success, or else a negative error code. */
+int
+xdr_decode_array2(struct xdr_buf *buf, unsigned int base,
+		  struct xdr_array2_desc *desc)
+{
+	char elem[desc->elem_size];
+	size_t b, elem_len = 0, avail, avail_here, avail_page;
+	struct page **ppages = NULL;
+	char *p;
+
+	if (base >= buf->len)
+		return -EINVAL;
+
+	/* Make sure the array length does not cross page boundaries. */
+	b = base;
+	if (b < buf->head->iov_len) {
+		if (b + 4 > buf->head->iov_len)
+			xdr_shrink_bufhead(buf, buf->head->iov_len - b);
+	} else {
+		b -= buf->head->iov_len;
+		if (b < buf->page_len) {
+			if (b + 4 > buf->page_len)
+				xdr_shrink_bufhead(buf, buf->page_len - b);
+			else {
+				b += buf->page_base;
+				if ((b & ~PAGE_CACHE_MASK)+4 > PAGE_CACHE_SIZE)
+					xdr_shrink_bufhead(
+						buf, PAGE_CACHE_SIZE -
+						(b & ~PAGE_CACHE_MASK));
+			}
+		}
+	}
+
+	b = base;
+	avail = buf->len;
+	if (b < buf->head->iov_len) {
+		p = buf->head->iov_base + b;
+		desc->array_len = ntohl(*(u32 *)p);
+		p += 4;
+		avail -= b + 4;
+		if ((unsigned long) desc->array_len * desc->elem_size > avail)
+			goto fail;
+		avail_here = min(desc->array_len * desc->elem_size,
+				 buf->head->iov_len - (b + 4));
+		avail = desc->array_len * desc->elem_size - avail_here;
+		while (avail_here >= desc->elem_size) {
+			desc->xcode_elem(desc, p);
+			p += desc->elem_size;
+			avail_here -= desc->elem_size;
+		}
+		if (avail_here) {
+			memcpy(elem, p, avail_here);
+			elem_len = avail_here;
+		}
+		if (avail) {
+			if (buf->page_len) {
+				avail_here = min(avail, (size_t) buf->page_len);
+				ppages = buf->pages;
+				p = kmap(*ppages) + buf->page_base;
+				goto process_pages;
+			} else {
+				p = buf->tail->iov_base;
+				goto process_tail;
+			}
+		}
+	} else {
+		b -= buf->head->iov_len;
+		avail -= buf->head->iov_len;
+		if (b < buf->page_len) {
+			ppages = buf->pages +
+				 ((b + buf->page_base) >> PAGE_CACHE_SHIFT);
+			p = kmap(*ppages) +
+			    ((b + buf->page_base) & ~PAGE_CACHE_MASK);
+			desc->array_len = ntohl(*(u32 *)p);
+			p += 4;
+			b += 4;
+			avail -= b;
+			if ((unsigned long) desc->array_len * desc->elem_size >
+			    avail)
+				goto fail;
+			avail  = desc->array_len * desc->elem_size;
+			avail_here = min(avail, buf->page_len - b);
+		    process_pages:
+			avail -= avail_here;
+			while (avail_here >= desc->elem_size) {
+				avail_page = PAGE_CACHE_SIZE;
+				if (ppages == buf->pages)
+					avail_page -= buf->page_base;
+				avail_page = min(avail_here, avail_page);
+				avail_here -= avail_page;
+				if (elem_len) {
+					unsigned int l = min(avail_page,
+						desc->elem_size - elem_len);
+					memcpy(elem + elem_len, p, l);
+					elem_len += l;
+					avail_page -= l;
+					p += l;
+					if (elem_len == desc->elem_size) {
+						desc->xcode_elem(desc, elem);
+						elem_len = 0;
+					}
+				}
+				while (avail_page >= desc->elem_size) {
+					desc->xcode_elem(desc, p);
+					p += desc->elem_size;
+					avail_page -= desc->elem_size;
+				}
+				if (avail_page != 0) {
+					unsigned int l = min(avail_page,
+						    desc->elem_size - elem_len);
+					memcpy(elem + elem_len, p, l);
+					elem_len += l;
+				}
+				if (avail_here) {
+					kunmap(*ppages++);
+					p = kmap(*ppages);
+					avail_page = min(PAGE_CACHE_SIZE,
+							 (size_t)avail_here);
+				}
+			}
+			if (avail_here) {
+				memcpy(elem + elem_len, p, avail_here);
+				elem_len += avail_here;
+			}
+			if (avail) {
+				p = buf->tail->iov_base;
+				avail_here = min(avail, buf->tail->iov_len);
+				goto process_tail;
+			}
+		} else {
+			b -= buf->page_len;
+			avail -= buf->page_len;
+			p = buf->tail->iov_base + b;
+			desc->array_len = ntohl(*(u32 *)p);
+			p += 4;
+			avail -= b + 4;
+			if ((unsigned long) desc->array_len * elem_len > avail)
+				goto fail;
+			avail = desc->array_len * desc->elem_size;
+		    process_tail:
+			if (elem_len) {
+				unsigned int l = desc->elem_size - elem_len;
+
+				memcpy(elem + elem_len, p, l);
+				desc->xcode_elem(desc, elem);
+				avail -= l;
+				p += l;
+			}
+			while (avail) {
+				desc->xcode_elem(desc, p);
+				p += desc->elem_size;
+				avail -= desc->elem_size;
+			}
+		}
+	}
+	
+	if (ppages)
+		kunmap(*ppages);
+	return 0;
+
+    fail:
+	if (ppages)
+		kunmap(*ppages);
+	return -EINVAL;
+}
+
+void
+xdr_encode_array2(struct xdr_buf *buf, unsigned int base,
+		  struct xdr_array2_desc *desc)
+{
+	char elem[desc->elem_size];
+
+	/* could change the interface so that pages are taken
+	   automatically ... */
+
+	/* locate first area */
+	/* proceed as above */
+}
+
Index: linux-2.6.0-test9/include/linux/sunrpc/xdr.h
===================================================================
--- linux-2.6.0-test9.orig/include/linux/sunrpc/xdr.h	2003-11-18 17:04:10.000000000 +0100
+++ linux-2.6.0-test9/include/linux/sunrpc/xdr.h	2003-11-19 16:15:18.000000000 +0100
@@ -224,6 +224,20 @@ extern void xdr_write_pages(struct xdr_s
 		unsigned int base, unsigned int len);
 extern void xdr_read_pages(struct xdr_stream *xdr, unsigned int len);
 
+struct xdr_array2_desc;
+typedef void (*xdr_xcode_elem_t)(struct xdr_array2_desc *desc, void *elem);
+struct xdr_array2_desc {
+	unsigned int elem_size;
+	unsigned int array_len;
+	xdr_xcode_elem_t xcode;
+};
+
+extern int xdr_decode_array2(struct xdr_buf *buf, unsigned int base,
+			     struct xdr_array2_desc *desc);
+extern void xdr_encode_array2(struct xdr_buf *buf, unsigned int base,
+			      struct xdr_array2_desc *desc);
+
+
 /*
  * Initialize an xdr_stream for decoding data.
  */
