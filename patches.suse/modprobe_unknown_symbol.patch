From: olh@suse.de
Subject: debug spurious 'Unknown symbol' errors in dmesg

the modules will work anyway.

	Bug 66533 - unknown symbols in usb modules
 kernel/module.c |   23 +++++++++++++++++++++--
 1 files changed, 21 insertions(+), 2 deletions(-)

Index: linux-2.6.12/kernel/module.c
===================================================================
--- linux-2.6.12.orig/kernel/module.c
+++ linux-2.6.12/kernel/module.c
@@ -1238,8 +1238,8 @@ static int simplify_symbols(Elf_Shdr *se
 			if (ELF_ST_BIND(sym[i].st_info) == STB_WEAK)
 				break;
 
-			printk(KERN_WARNING "%s: Unknown symbol %s\n",
-			       mod->name, strtab + sym[i].st_name);
+			printk(KERN_WARNING "%s: Unknown symbol %s, st_info == 0x%x\n",
+			       mod->name, strtab + sym[i].st_name,(ELF_ST_BIND(sym[i].st_info)));
 			ret = -ENOENT;
 			break;
 
@@ -1486,6 +1486,9 @@ static inline void add_kallsyms(struct m
 }
 #endif /* CONFIG_KALLSYMS */
 
+/* unprotected ok, happens also on single cpu */
+static char *mod_in_progress;
+
 /* Allocate and load the module: note that size of section 0 is always
    zero, and we rely on this for optional sections. */
 static struct module *load_module(void __user *umod,
@@ -1567,6 +1570,11 @@ static struct module *load_module(void _
 	}
 	mod = (void *)sechdrs[modindex].sh_addr;
 
+	if (mod_in_progress)
+		printk(KERN_DEBUG "%s: '%s' and '%s' loaded parallel\n", __FUNCTION__, mod_in_progress, mod->name);
+	else
+		mod_in_progress = mod->name;
+
 	if (symindex == 0) {
 		printk(KERN_WARNING "%s: module has no symbols (stripped?)\n",
 		       mod->name);
@@ -1815,6 +1823,16 @@ static struct module *load_module(void _
  arch_cleanup:
 	module_arch_cleanup(mod);
  cleanup:
+	if (err) {
+		char *p = "";
+		if (-EEXIST == err && mod)
+			printk(KERN_DEBUG "%s: '%s' already loaded (dont worry)\n",__FUNCTION__, mod->name);
+		else {
+			if (mod)
+				p = mod->name;
+			printk(KERN_DEBUG "%s '%s': err 0x%lx (dont worry)\n",__FUNCTION__, p, err);
+		}
+	}
 	module_unload_free(mod);
 	module_free(mod, mod->module_init);
  free_core:
@@ -1825,6 +1843,7 @@ static struct module *load_module(void _
  free_mod:
 	kfree(args);
  free_hdr:
+	mod_in_progress = NULL;
 	vfree(hdr);
 	if (err < 0) return ERR_PTR(err);
 	else return ptr;
