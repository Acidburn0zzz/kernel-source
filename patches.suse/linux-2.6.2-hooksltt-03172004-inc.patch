Index: linux.t/Documentation/filesystems/relayfs.txt
===================================================================
--- linux.t.orig/Documentation/filesystems/relayfs.txt	2004-03-21 11:10:28.465157535 -0500
+++ linux.t/Documentation/filesystems/relayfs.txt	2004-03-21 11:43:18.428993033 -0500
@@ -461,6 +461,14 @@ The remaining parameters for relay_open(
 	    RELAY_FILE_UNMAP- a relayfs file is being unmapped.  The return
 			      value is ignored.
 
+	  - void ioctl(rchan_id, cmd, arg)
+
+  	    called when an ioctl call is made using a relayfs file
+	    descriptor.  The cmd and arg are passed along to this
+	    callback unmodified for it to do as it wishes with.  The
+	    return value from this callback is used as the return value
+	    of the ioctl call.
+
   If the callbacks param passed to relay_open() is NULL, a set of
   default do-nothing callbacks will be defined for the channel.
   Likewise, any NULL rchan_callback function contained in a non-NULL
Index: linux.t/arch/alpha/Kconfig
===================================================================
--- linux.t.orig/arch/alpha/Kconfig	2004-03-21 11:28:57.210834619 -0500
+++ linux.t/arch/alpha/Kconfig	2004-03-21 11:43:18.430992793 -0500
@@ -723,33 +723,6 @@ config TRIGEVENT_HOOKS
 
 	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
 
-config TRACE
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/arm/Kconfig
===================================================================
--- linux.t.orig/arch/arm/Kconfig	2004-03-21 11:28:57.212834374 -0500
+++ linux.t/arch/arm/Kconfig	2004-03-21 11:43:18.432992553 -0500
@@ -801,34 +801,6 @@ config TRIGEVENT_SYSCALL_HOOK
 	RAS hooks to enable tracing of system call entry and exit points.
 	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
 
-config LTT
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	select RELAYFS_FS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/ia64/kernel/process.c
===================================================================
--- linux.t.orig/arch/ia64/kernel/process.c	2004-03-21 10:54:48.150022172 -0500
+++ linux.t/arch/ia64/kernel/process.c	2004-03-21 11:46:27.911240992 -0500
@@ -148,7 +148,6 @@ do_notify_resume_user (sigset_t *oldset,
 			ia64_psr(&scr->pt)->lp = 1;
 		return;
 	}
-
 #ifdef CONFIG_PERFMON
 	if (current->thread.pfm_needs_checking)
 		pfm_handle_work();
@@ -590,6 +589,7 @@ kernel_thread (int (*fn)(void *), void *
 {
 	extern void start_kernel_thread (void);
 	unsigned long *helper_fptr = (unsigned long *) &start_kernel_thread;
+	pid_t ret;
 	struct {
 		struct switch_stack sw;
 		struct pt_regs pt;
@@ -606,7 +606,14 @@ kernel_thread (int (*fn)(void *), void *
 	regs.sw.ar_fpsr = regs.pt.ar_fpsr = ia64_getreg(_IA64_REG_AR_FPSR);
 	regs.sw.ar_bspstore = (unsigned long) current + IA64_RBS_OFFSET;
 
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
+	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+
+	if (ret > 0)
+		TRIG_EVENT(kthread_hook, ret, (unsigned long) fn);
+#endif
+	return ret;
+
 }
 EXPORT_SYMBOL(kernel_thread);
 
Index: linux.t/arch/ia64/kernel/time.c
===================================================================
--- linux.t.orig/arch/ia64/kernel/time.c	2004-03-21 11:11:29.107984809 -0500
+++ linux.t/arch/ia64/kernel/time.c	2004-03-21 11:43:18.437991953 -0500
@@ -20,6 +20,7 @@
 #include <linux/efi.h>
 #include <linux/profile.h>
 #include <linux/timex.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/machvec.h>
 #include <asm/delay.h>
Index: linux.t/arch/mips/Kconfig
===================================================================
--- linux.t.orig/arch/mips/Kconfig	2004-03-21 11:28:57.229832297 -0500
+++ linux.t/arch/mips/Kconfig	2004-03-21 11:43:18.439991713 -0500
@@ -1570,34 +1570,6 @@ config TRIGEVENT_SYSCALL_HOOK
 	RAS hooks to enable tracing of system call entry and exit points.
 	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
 
-config LTT
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	select RELAYFS_FS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/parisc/Kconfig
===================================================================
--- linux.t.orig/arch/parisc/Kconfig	2004-03-21 11:28:57.236831442 -0500
+++ linux.t/arch/parisc/Kconfig	2004-03-21 11:43:18.440991593 -0500
@@ -254,33 +254,6 @@ config TRIGEVENT_HOOKS
 
 	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
 
-config TRACE
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/ppc/Kconfig
===================================================================
--- linux.t.orig/arch/ppc/Kconfig	2004-03-21 11:28:57.238831198 -0500
+++ linux.t/arch/ppc/Kconfig	2004-03-21 11:43:18.442991353 -0500
@@ -1273,34 +1273,6 @@ config TRIGEVENT_SYSCALL_HOOK
 	RAS hooks to enable tracing of system call entry and exit points.
 	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
 
-config LTT
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	select RELAYFS_FS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/s390/Kconfig
===================================================================
--- linux.t.orig/arch/s390/Kconfig	2004-03-21 11:28:57.245830343 -0500
+++ linux.t/arch/s390/Kconfig	2004-03-21 11:43:18.443991233 -0500
@@ -474,34 +474,6 @@ config TRIGEVENT_SYSCALL_HOOK
 	RAS hooks to enable tracing of system call entry and exit points.
 	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
 
-config LTT
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	select RELAYFS_FS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/sh/Kconfig
===================================================================
--- linux.t.orig/arch/sh/Kconfig	2004-03-21 11:28:57.249829854 -0500
+++ linux.t/arch/sh/Kconfig	2004-03-21 11:43:18.446990873 -0500
@@ -1144,34 +1144,6 @@ config TRIGEVENT_SYSCALL_HOOK
 	RAS hooks to enable tracing of system call entry and exit points.
 	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
 
-config LTT
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	select RELAYFS_FS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/sparc/Kconfig
===================================================================
--- linux.t.orig/arch/sparc/Kconfig	2004-03-21 11:28:57.255829121 -0500
+++ linux.t/arch/sparc/Kconfig	2004-03-21 11:43:18.447990753 -0500
@@ -479,33 +479,6 @@ config TRIGEVENT_HOOKS
 
 	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
 
-config TRACE
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/sparc64/Kconfig
===================================================================
--- linux.t.orig/arch/sparc64/Kconfig	2004-03-21 11:28:57.256828999 -0500
+++ linux.t/arch/sparc64/Kconfig	2004-03-21 11:43:18.449990513 -0500
@@ -732,33 +732,6 @@ config TRIGEVENT_HOOKS
 
 	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
 
-config TRACE
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/x86_64/Kconfig
===================================================================
--- linux.t.orig/arch/x86_64/Kconfig	2004-03-21 11:28:57.258828754 -0500
+++ linux.t/arch/x86_64/Kconfig	2004-03-21 11:43:18.450990393 -0500
@@ -529,33 +529,6 @@ config TRIGEVENT_HOOKS
 
 	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
 
-config TRACE
-	bool "Tracing support"
-	depends on TRIGEVENT_HOOKS
-	---help---
-	  It is possible for the kernel to log important events to a trace
-	  facility. Doing so, enables the use of the generated traces in order
-	  to reconstruct the dynamic behavior of the kernel, and hence the
-	  whole system.
-
-	  The tracing process contains 4 parts :
-	      1) The logging of events by key parts of the kernel.
-	      2) The tracer that keeps the events in a data buffer.
-	      3) A trace daemon that interacts with the tracer and is
-	         notified every time there is a certain quantity of data to
-	         read from the tracer.
-	      4) A trace event data decoder that reads the accumulated data
-	         and formats it in a human-readable format.
-
-	  If you say Y, the first two components will be built into the kernel.
-	  Critical parts of the kernel will call upon the kernel tracing
-	  function. The data is then recorded by the tracer if a trace daemon
-	  is running in user-space and has issued a "start" command.
-
-	  For more information on kernel tracing, the trace daemon or the event
-	  decoder, please check the following address :
-	       http://www.opersys.com/LTT
-
 endmenu
 
 source "security/Kconfig"
Index: linux.t/fs/relayfs/inode.c
===================================================================
--- linux.t.orig/fs/relayfs/inode.c	2004-03-21 11:10:28.472156706 -0500
+++ linux.t/fs/relayfs/inode.c	2004-03-21 11:43:18.451990273 -0500
@@ -431,6 +431,38 @@ relayfs_file_write(struct file *filp, co
 }
 
 /**
+ *	relayfs_ioctl - ioctl file op for relayfs files
+ *	@inode: the inode
+ *	@filp: the file
+ *	@cmd: the command
+ *	@arg: command arg
+ *
+ *	Passes the specified cmd/arg to the kernel client.  arg may be a 
+ *	pointer to user-space data, in which case the kernel client is 
+ *	responsible for copying the data to/from user space appropriately.
+ *	The kernel client is also responsible for returning a meaningful
+ *	return value for ioctl calls.
+ *	
+ *	Returns result of relay channel callback, -EPERM if unsuccessful.
+ */
+int
+relayfs_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct rchan *rchan;
+	struct rchan_reader *reader;
+
+	reader = (struct rchan_reader *)filp->private_data;
+	if (reader == NULL)
+		return -EPERM;
+
+	rchan = reader->rchan;
+	if (rchan == NULL)
+		return -EPERM;
+
+	return rchan->callbacks->ioctl(rchan->id, cmd, arg);
+}
+
+/**
  *	relayfs_poll - poll file op for relayfs files
  *	@filp: the file
  *	@wait: poll table
@@ -501,6 +533,7 @@ static struct file_operations relayfs_fi
 	.open		= relayfs_open,
 	.read		= relayfs_file_read,
 	.write		= relayfs_file_write,
+	.ioctl		= relayfs_ioctl,
 	.poll		= relayfs_poll,
 	.mmap		= relayfs_mmap,
 	.fsync		= simple_sync_file,
Index: linux.t/fs/relayfs/relay.c
===================================================================
--- linux.t.orig/fs/relayfs/relay.c	2004-03-21 11:10:28.478155995 -0500
+++ linux.t/fs/relayfs/relay.c	2004-03-21 11:43:18.453990034 -0500
@@ -514,6 +514,17 @@ fileop_notify_default_callback(int rchan
 	return 0;
 }
 
+/*
+ * ioctl() default callback.  Does nothing.
+ */
+static int
+ioctl_default_callback(int rchan_id,
+		       unsigned int cmd,
+		       unsigned long arg)
+{
+	return 0;
+}
+
 /* relay channel default callbacks */
 static struct rchan_callbacks default_channel_callbacks = {
 	.buffer_start = buffer_start_default_callback,
@@ -522,6 +533,7 @@ static struct rchan_callbacks default_ch
 	.user_deliver = user_deliver_default_callback,
 	.needs_resize = needs_resize_default_callback,
 	.fileop_notify = fileop_notify_default_callback,
+	.ioctl = ioctl_default_callback,
 };
 
 /**
@@ -979,6 +991,8 @@ relay_open(const char *chanpath,
 		callbacks->needs_resize = needs_resize_default_callback;
 	if (callbacks->fileop_notify == NULL)
 		callbacks->fileop_notify = fileop_notify_default_callback;
+	if (callbacks->ioctl == NULL)
+		callbacks->ioctl = ioctl_default_callback;
 	rchan->callbacks = callbacks;
 
 	/* Just to let the client know the sizes used */
Index: linux.t/include/linux/ltt.h
===================================================================
--- linux.t.orig/include/linux/ltt.h	2004-03-21 11:28:57.262828266 -0500
+++ linux.t/include/linux/ltt.h	2004-03-21 11:43:18.455989794 -0500
@@ -43,6 +43,11 @@ typedef u64 trace_event_mask;
 
 #define TRACE_MAX_HANDLES		256
 
+/* In the ltt root directory lives the trace control file, used for
+   kernel-user communication. */
+#define TRACE_RELAYFS_ROOT		"ltt"
+#define TRACE_CONTROL_FILE		"control"
+
 /* We currently support 2 traces, normal trace and flight recorder */
 #define NR_TRACES			2
 #define TRACE_HANDLE			0
Index: linux.t/include/linux/relayfs_fs.h
===================================================================
--- linux.t.orig/include/linux/relayfs_fs.h	2004-03-21 11:10:28.505152797 -0500
+++ linux.t/include/linux/relayfs_fs.h	2004-03-21 11:43:18.456989674 -0500
@@ -203,6 +203,18 @@ struct rchan_callbacks
         int (*fileop_notify)(int rchan_id,
 			     struct file *filp,
 			     enum relay_fileop fileop);
+
+	/*
+	 * ioctl - called in ioctl context from userspace
+	 * @rchan_id: the channel id
+	 * @cmd: ioctl cmd
+	 * @arg: ioctl cmd arg
+	 *
+	 * The return value is returned as the value from the ioctl call.
+	 *
+	 * See Documentation/filesystems/relayfs.txt for details.
+	 */
+	int (*ioctl) (int rchan_id, unsigned int cmd, unsigned long arg);
 };
 
 /*
Index: linux.t/kernel/hook.c
===================================================================
--- linux.t.orig/kernel/hook.c	2004-03-21 11:10:28.616139648 -0500
+++ linux.t/kernel/hook.c	2004-03-21 11:43:18.458989434 -0500
@@ -18,6 +18,7 @@
 #include <asm/uaccess.h>
 
 static spinlock_t hook_lock = SPIN_LOCK_UNLOCKED;
+static DECLARE_MUTEX(hook_proc_sem);
 
 static int hook_global_status = 0;
 
@@ -123,11 +124,11 @@ static void hook_create_proc(struct hook
 
 static inline void create_hook_exit_proc_entry(struct hook_rec *hook_rec)
 {
-	spin_lock(&hook_lock);
+	down(&hook_proc_sem);
 	if (hook_global_status & HOOK_INIT) {
 		hook_create_proc(hook_rec);
 	}
-	spin_unlock(&hook_lock);
+	up(&hook_proc_sem);
 }
 
 static inline void remove_hook_exit_proc_entry(struct hook_rec *hook_rec)
@@ -135,6 +136,7 @@ static inline void remove_hook_exit_proc
 	char tmp[32];
 	char *proc_entry_name;
 
+	down(&hook_proc_sem);
 	if (hook_rec->proc_entry) {
 		proc_entry_name = hook_rec->hook_exit_name;
 		if (!proc_entry_name) {
@@ -144,34 +146,39 @@ static inline void remove_hook_exit_proc
 		hook_rec->proc_entry->data = NULL;
 		remove_proc_entry(proc_entry_name, hook_rec->hook_head->proc_entry);
 	}
+	up(&hook_proc_sem);
 }
 
 static inline void create_hook_proc_dir(struct hook *hook)
 {
-	spin_lock(&hook_lock);
+	down(&hook_proc_sem);
 	if (hook_global_status & HOOK_INIT) {
 		hook->proc_entry = proc_mkdir(hook->hook_id, proc_hooks_dir);
 	}
-	spin_unlock(&hook_lock);
+	up(&hook_proc_sem);
 }
 
 static inline void remove_hook_proc_dir(struct hook *hook)
 {
+	down(&hook_proc_sem);
 	if (hook->proc_entry) {
 		remove_proc_entry(hook->hook_id, proc_hooks_dir);
 	}
+	up(&hook_proc_sem);
 }
 
 static void __init init_hook_procfs(void)
 {
-	spin_lock(&hook_lock);
+	down(&hook_proc_sem);
 	proc_hooks_dir = proc_mkdir(PROC_HOOKS_ROOT, NULL);
-	spin_unlock(&hook_lock);
+	up(&hook_proc_sem);
 }
 
 static void __exit cleanup_hook_procfs(void)
 {
+	down(&hook_proc_sem);
 	remove_proc_entry(PROC_HOOKS_ROOT, NULL);
+	up(&hook_proc_sem);
 }
 #else
 static inline void hook_create_proc(struct hook_rec *hook_rec) {}
@@ -262,17 +269,18 @@ void hook_exit_deregister(struct hook_re
 	if(rec->hook_head->hook_flags & HOOK_EXCLUSIVE)
 		rec->hook_head->hook_ex_exit = NULL;
 	list_del(&rec->exit_list);
-	/* Remove hook exit entries from /proc. */
-	remove_hook_exit_proc_entry(rec);
 	hook = rec->hook_head;
 	calculate_indicies(rec->hook_head);
+	module_put(THIS_MODULE);
+	spin_unlock_irqrestore(&hook_lock, flags);
+
+	/* Remove hook exit entries from /proc. */
+	remove_hook_exit_proc_entry(rec);
 
 	/* Remove hook entries from /proc. */
 	if (list_empty(&hook->exit_list))
 		remove_hook_proc_dir(hook);
 		 
-	module_put(THIS_MODULE);
-	spin_unlock_irqrestore(&hook_lock, flags);
 }
 
 void hook_exit_arm(struct hook_rec *rec)
Index: linux.t/kernel/ltt/ltt-core.c
===================================================================
--- linux.t.orig/kernel/ltt/ltt-core.c	2004-03-21 11:28:57.277826433 -0500
+++ linux.t/kernel/ltt/ltt-core.c	2004-03-21 11:43:18.462988954 -0500
@@ -98,10 +98,11 @@ static struct timer_list	heartbeat_timer
 static struct timer_list	percpu_timer[NR_CPUS] __cacheline_aligned;
 
 /* /proc variables */
-static struct proc_dir_entry *	ltt_proc_root_entry; /* proc/trace */
+static struct proc_dir_entry *	ltt_proc_root_entry; /* proc/ltt */
 static int			tmp_rchan_handles[NR_CPUS];
 static char			relayfs_path[PATH_MAX];	/* path to attribs */
-static char			relay_file_name[PATH_MAX];/* scratch area */
+static char			relay_file_name[PATH_MAX]; /* scratch area */
+static int			control_channel; /* LTT control channel */
 
 /* Forward declarations */
 static struct proc_dir_entry *create_handle_proc_dir(unsigned trace_handle);
@@ -401,7 +402,6 @@ static void do_waiting_async_tasks(unsig
 
 	if (trace->tracer_stopping && (tasks & LTT_FINALIZE_TRACE)) {
                 clear_waiting_for_cpu_async(trace_handle, cpu_id, LTT_FINALIZE_TRACE);
-
 		if (relay_close(trace_channel_handle(trace_handle, cpu_id)) != 0)
 			printk(KERN_ALERT "LTT: Couldn't close trace channel %d\n", trace_channel_handle(trace_handle, cpu_id));
 
@@ -572,27 +572,25 @@ static int tracer_get_status(struct trac
 }
 
 /**
- *	sys_trace: - Tracing system call
- *
- *	@tracer_handle: tracing mechanism handle
- *	@tracer_command: command given by the caller
- *	@command_arg1: argument "1" to the command
- *	@command_arg2: argument "2" to the command
+ *      ltt_ioctl: - Tracing kernel-user control interface
  *
- *	Returns:
- *	>0, In case the caller requested the number of events lost.
- *	0, Everything went OK
- *	-ENOSYS, no such command
- *	-EINVAL, tracer not properly configured
- *	-EBUSY, tracer can't be reconfigured while in operation
- *	-ENOMEM, no more memory
- *	-EFAULT, unable to access user space memory
- *	-EACCES, invalid tracer handle
- */
-asmlinkage int sys_trace(unsigned int tracer_handle,
-			 unsigned int tracer_command,
-			 unsigned long command_arg1,
-			 unsigned long command_arg2)
+ *      @rchan_id: rchan id ioctl occurred on
+ *      @tracer_command: command given by the caller
+ *      @command_arg: argument to the command
+ *
+ *      Returns:
+ *      >0, In case the caller requested the number of events lost.
+ *      0, Everything went OK
+ *      -ENOSYS, no such command
+ *      -EINVAL, tracer not properly configured
+ *      -EBUSY, tracer can't be reconfigured while in operation
+ *      -ENOMEM, no more memory
+ *      -EFAULT, unable to access user space memory
+ *      -EACCES, invalid tracer handle
+ */
+static int ltt_ioctl(int rchan_id,
+		     unsigned int tracer_command,
+		     unsigned long arg)
 {
 	int retval;
 	int new_user_event_id;
@@ -606,6 +604,14 @@ asmlinkage int sys_trace(unsigned int tr
 	struct buffers_committed buffers_committed;
 	struct trace_struct *trace = NULL;
 	struct tracer_status tracer_status;
+	unsigned int tracer_handle;
+	unsigned long command_arg;
+
+	if (copy_from_user(&tracer_handle, (void *)arg, sizeof(unsigned int)))
+		return -EFAULT;
+
+	if (copy_from_user(&command_arg, (void*)(arg + sizeof(tracer_handle)), sizeof(unsigned long)))
+		return -EFAULT;
 
 	if (tracer_command == TRACER_ALLOC_HANDLE)
 		return ltt_alloc_trace_handle(tracer_handle);
@@ -723,49 +729,47 @@ asmlinkage int sys_trace(unsigned int tr
 
 	case TRACER_CONFIG_MEMORY_BUFFERS:
 		if (trace->use_locking == 1) {
-			if (command_arg1 < TRACER_MIN_BUF_SIZE)
+			if (command_arg < TRACER_MIN_BUF_SIZE)
 				return -EINVAL;
 		} else {
-			if ((command_arg1 < TRACER_LOCKLESS_MIN_BUF_SIZE) || 
-			    (command_arg1 > TRACER_LOCKLESS_MAX_BUF_SIZE))
+			if ((command_arg < TRACER_LOCKLESS_MIN_BUF_SIZE) || 
+			    (command_arg > TRACER_LOCKLESS_MAX_BUF_SIZE))
 				return -EINVAL;
 		}
-
-		return ltt_set_buffer_size(trace, command_arg1, relayfs_path);
+		return ltt_set_buffer_size(trace, command_arg, relayfs_path);
 		break;
 
 	case TRACER_CONFIG_N_MEMORY_BUFFERS:
-		if (command_arg1 < TRACER_MIN_BUFFERS || 
-		    command_arg1 > TRACER_MAX_BUFFERS)
+		if (command_arg < TRACER_MIN_BUFFERS || 
+		    command_arg > TRACER_MAX_BUFFERS)
 			return -EINVAL;
 
-		return ltt_set_n_buffers(trace, command_arg1);
+		return ltt_set_n_buffers(trace, command_arg);
 		break;
 
 	case TRACER_CONFIG_USE_LOCKING:
-		trace->use_locking = command_arg1;
+		trace->use_locking = command_arg;
 
 		if ((trace->use_locking == 0) && (have_cmpxchg() == 0))
 			return -EINVAL;
 		break;
 
 	case TRACER_CONFIG_EVENTS:
-		if (copy_from_user(&trace->traced_events, (void *) command_arg1, sizeof(trace->traced_events)))
+		if (copy_from_user(&trace->traced_events, (void *)command_arg, sizeof(trace->traced_events)))
 			return -EFAULT;
 		break;
 
 	case TRACER_CONFIG_TIMESTAMP:
-		trace->using_tsc = command_arg1;
+		trace->using_tsc = command_arg;
 
 		if ((trace->using_tsc == 1) && (have_tsc() == 0)) {
 			trace->using_tsc = 0;
 			return -EINVAL;
 		}
-
 		break;
 
 	case TRACER_CONFIG_DETAILS:
-		if (copy_from_user(&trace->log_event_details_mask, (void *) command_arg1, sizeof(trace->log_event_details_mask)))
+		if (copy_from_user(&trace->log_event_details_mask, (void *)command_arg, sizeof(trace->log_event_details_mask)))
 			return -EFAULT;
 		 /* Enable hooks for the events we are interested in. */
 
@@ -781,43 +785,43 @@ asmlinkage int sys_trace(unsigned int tr
 
 	case TRACER_CONFIG_PID:
 		trace->tracing_pid = 1;
-		trace->traced_pid = command_arg1;
+		trace->traced_pid = command_arg;
 		break;
 
 	case TRACER_CONFIG_PGRP:
 		trace->tracing_pgrp = 1;
-		trace->traced_pgrp = command_arg1;
+		trace->traced_pgrp = command_arg;
 		break;
 
 	case TRACER_CONFIG_GID:
 		trace->tracing_gid = 1;
-		trace->traced_gid = command_arg1;
+		trace->traced_gid = command_arg;
 		break;
 
 	case TRACER_CONFIG_UID:
 		trace->tracing_uid = 1;
-		trace->traced_uid = command_arg1;
+		trace->traced_uid = command_arg;
 		break;
 
 	case TRACER_CONFIG_SYSCALL_EIP_DEPTH:
 		syscall_eip_depth_set = 1;
-		syscall_eip_depth = command_arg1;
+		syscall_eip_depth = command_arg;
 		break;
 
 	case TRACER_CONFIG_SYSCALL_EIP_LOWER:
 		use_syscall_eip_bounds = 1;
-		lower_eip_bound = (void *) command_arg1;
+		lower_eip_bound = (void *)command_arg;
 		lower_eip_bound_set = 1;
 		break;
 
 	case TRACER_CONFIG_SYSCALL_EIP_UPPER:
 		use_syscall_eip_bounds = 1;
-		upper_eip_bound = (void *) command_arg1;
+		upper_eip_bound = (void *)command_arg;
 		upper_eip_bound_set = 1;
 		break;
 
 	case TRACER_DATA_COMITTED:
-		if (copy_from_user(&buffers_committed, (void *)command_arg1, 
+		if (copy_from_user(&buffers_committed, (void *)command_arg, 
 				   sizeof(buffers_committed)))
 			return -EFAULT;
 
@@ -833,11 +837,11 @@ asmlinkage int sys_trace(unsigned int tr
 		break;
 
 	case TRACER_GET_EVENTS_LOST:
-		return events_lost(tracer_handle, command_arg1);
+		return events_lost(tracer_handle, command_arg);
 		break;
 
 	case TRACER_CREATE_USER_EVENT:
-		if (copy_from_user(&new_user_event, (void *) command_arg1, sizeof(new_user_event)))
+		if (copy_from_user(&new_user_event, (void *)command_arg, sizeof(new_user_event)))
 			return -EFAULT;
 
 		new_user_event_id = ltt_create_owned_event(new_user_event.type,
@@ -847,23 +851,22 @@ asmlinkage int sys_trace(unsigned int tr
 							     current->pid);
 		if (new_user_event_id >= 0) {
 			new_user_event.id = new_user_event_id;
-			if (copy_to_user((void *) command_arg1, &new_user_event, sizeof(new_user_event))) {
+			if (copy_to_user((void *)command_arg, &new_user_event, sizeof(new_user_event))) {
 				ltt_destroy_event(new_user_event_id);
 				return -EFAULT;
 			}
-		}
-		else
+		} else
 			return new_user_event_id;
 		break;
 
 	case TRACER_DESTROY_USER_EVENT:
-		ltt_destroy_event((int) command_arg1);
+		ltt_destroy_event((int)command_arg);
 		break;
 
 	case TRACER_TRACE_USER_EVENT:
-		if (copy_from_user(&user_event, (void *) command_arg1, sizeof(user_event)))
+		if (copy_from_user(&user_event, (void *)command_arg, sizeof(user_event)))
 			return -EFAULT;
-
+		
 		if ((user_event_data == NULL) 
 		    && (user_event_data = vmalloc(CUSTOM_EVENT_MAX_SIZE)) < 0)
 			return -ENOMEM;
@@ -874,13 +877,12 @@ asmlinkage int sys_trace(unsigned int tr
 		retval = ltt_log_raw_event(user_event.id,
 					   user_event.data_size,
 					   user_event_data);
-
 		if (retval < 0)
 			return retval;
 		break;
 
 	case TRACER_SET_EVENT_MASK:
-		if (copy_from_user(&(trace_mask.mask), (void *) command_arg1, sizeof(trace_mask.mask)))
+		if (copy_from_user(&(trace_mask.mask), (void *)command_arg, sizeof(trace_mask.mask)))
 			return -EFAULT;
 
 		retval = _ltt_log_event(trace,
@@ -903,7 +905,7 @@ asmlinkage int sys_trace(unsigned int tr
 		break;
 
 	case TRACER_GET_EVENT_MASK:
-		if (copy_to_user((void *) command_arg1, &trace->traced_events, sizeof(trace->traced_events)))
+		if (copy_to_user((void *)command_arg, &trace->traced_events, sizeof(trace->traced_events)))
 			return -EFAULT;
 		break;
 
@@ -911,8 +913,8 @@ asmlinkage int sys_trace(unsigned int tr
 		ltt_arch_info.n_cpus = num_cpus;
 		ltt_arch_info.page_shift = PAGE_SHIFT;
 
-		if (copy_to_user((void *) command_arg1, 
-				 &ltt_arch_info, 
+		if (copy_to_user((void *)command_arg,
+				 &ltt_arch_info,
 				 sizeof(ltt_arch_info))) {
 			return -EFAULT;
 		}
@@ -920,8 +922,8 @@ asmlinkage int sys_trace(unsigned int tr
 
 	case TRACER_GET_START_INFO:
 		if (trace->trace_start_data) {
-			if (copy_to_user((void *) command_arg1, 
-					 trace->trace_start_data, 
+			if (copy_to_user((void *)command_arg,
+					 trace->trace_start_data,
 					 sizeof(trace_start)))
 				return -EFAULT;
 		} else
@@ -932,43 +934,40 @@ asmlinkage int sys_trace(unsigned int tr
 		if (tracer_get_status(&tracer_status))
 			return -EINVAL;
 		
-		if (copy_to_user((void *) command_arg1, 
-				 &tracer_status, 
+		if (copy_to_user((void *)command_arg, 
+				 &tracer_status,
 				 sizeof(struct tracer_status)))
 			return -EFAULT;
 		break;
 
 	case TRACER_GET_BUFFER_CONTROL:
-		if (copy_from_user(&shared_buf_ctl, (void *) command_arg1, sizeof(shared_buf_ctl)))
+		if (copy_from_user(&shared_buf_ctl, (void *)command_arg, sizeof(shared_buf_ctl)))
 			return -EFAULT;
 
 		if (shared_buf_ctl.cpu_id == -1) {
 			for (i = 0; i < num_cpus; i++) {
 				if (trace->buffer_switches_pending & (1UL << i)) {
 					update_shared_buffer_control(trace, i);
-					
-					if (copy_to_user((void *) command_arg1, 
-							 &shared_buf_ctl, 
+					if (copy_to_user((void *)command_arg,
+							 &shared_buf_ctl,
 							 sizeof(struct buf_control_info)))
 						return -EFAULT;
-
 					return 0;
 				}
 			}
 		} else {
 			update_shared_buffer_control(trace, (u8)shared_buf_ctl.cpu_id);
-			if (copy_to_user((void *) command_arg1, 
-					 &shared_buf_ctl, 
+			if (copy_to_user((void *)command_arg,
+					 &shared_buf_ctl,
 					 sizeof(struct buf_control_info)))
 				return -EFAULT;
-
 			return 0;
 		}
 
 		shared_buf_ctl.cpu_id = 0;
 		shared_buf_ctl.buffer_control_valid = 0;
 
-		if (copy_to_user((void *) command_arg1,
+		if (copy_to_user((void *) command_arg,
 				&shared_buf_ctl,
 				sizeof(struct buf_control_info)))
 			return -EFAULT;
@@ -992,7 +991,9 @@ asmlinkage int sys_trace(unsigned int tr
 
 	default:
 		return -ENOSYS;
+		break;
 	}
+
 	return 0;
 }
 
@@ -1300,7 +1301,6 @@ int ltt_set_buffer_size(struct trace_str
 							  0,
 							  NULL,
 							  0);
-
 		if (trace_channel_handle(trace->trace_handle, i) < 0)
 			return -ENOMEM;
 	}
@@ -1950,7 +1950,7 @@ static struct trace_struct *ltt_channel_
  *	trace handle
  *	-1, channel_handle, thus trace handle, not found
  */
-static unsigned int ltt_channel_trace_handle(int channel_handle)
+static int ltt_channel_trace_handle(int channel_handle)
 {
 	unsigned int i;
 	
@@ -2180,7 +2180,7 @@ void deliver_callback(int channel_handle
 {
 	struct trace_struct *trace;
 	int cpu_id;
-	
+
 	trace = ltt_channel_trace(channel_handle);
 	if (!trace)
 		return;
@@ -2192,6 +2192,16 @@ void deliver_callback(int channel_handle
 	set_bit(cpu_id, &trace->buffer_switches_pending);
 }
 
+/**
+ *	fileop_notify - called when change to trace file status 
+ *	@rchan_id: the rchan id
+ *	@filp: the file
+ *	@fileop: the file operation
+ *
+ *	This is the relayfs fileop_notify() callback implementation for
+ *	the tracer.  We use it to take care of trace file mapping and
+ *	unmapping tasks.
+ */
 static int fileop_notify(int rchan_id,
 			 struct file *filp,
 			 enum relay_fileop fileop)
@@ -2200,7 +2210,7 @@ static int fileop_notify(int rchan_id,
 	struct rchan_reader *open_file_reader;
 	struct rchan *rchan;
 	u8 cpu_id;
-	unsigned int trace_handle;
+	int trace_handle;
 
 	trace_handle = ltt_channel_trace_handle(rchan_id);
 	if (trace_handle == -1)
@@ -2228,6 +2238,7 @@ static struct rchan_callbacks ltt_callba
 	.buffer_end = buffer_end_callback,
 	.deliver = deliver_callback,
 	.fileop_notify = fileop_notify,
+	.ioctl = ltt_ioctl,
 };
 
 /*
@@ -2364,10 +2375,93 @@ static void remove_handle_proc_dir(struc
  * Initialization and finalization
  */
 
+static struct rchan_callbacks control_callbacks = {
+	.ioctl = ltt_ioctl,
+};
+
+/**
+ *	create_control_channel - creates channel /mnt/relay/ltt/control
+ *
+ *	Returns channel id on success, negative otherwise.
+ */
+static int
+create_control_channel(void)
+{
+	u32 bufsize, nbufs;
+	u32 channel_flags;
+	int control;
+
+	sprintf(relay_file_name, "%s/%s", TRACE_RELAYFS_ROOT, TRACE_CONTROL_FILE);
+
+	channel_flags = RELAY_DELIVERY_PACKET | RELAY_USAGE_GLOBAL;
+	channel_flags |= RELAY_SCHEME_ANY | RELAY_TIMESTAMP_ANY;
+
+	bufsize = 4096;
+	nbufs = 4;
+
+	control = relay_open(relay_file_name,
+			     bufsize,
+			     nbufs,
+			     channel_flags,
+			     &control_callbacks,
+			     0,
+			     0,
+			     0,
+			     0,
+			     0,
+			     0,
+			     NULL,
+			     0);
+
+	return control;
+}
+
+/**
+ *	proc_read_init_ltt - procfs read callback for init attr 
+ */
+static int proc_read_init_ltt(char *page, char **start, off_t off, 
+			      int count, int *eof, void *data)
+{
+	return sprintf(page, "%d", control_channel == -1 ? 0 : 1);
+}
+
+/**
+ *	proc_write_init_ltt - procfs write callback for init attr 
+ */
+static int proc_write_init_ltt(struct file *filp, const char *buffer,
+			       unsigned long count, void *data)
+{
+	if (control_channel == -1) {
+		control_channel = create_control_channel();
+	
+		if (control_channel < 0)
+			printk("LTT control channel creation failed, errcode: %d\n", control_channel);
+		else
+			printk("LTT control channel created\n");
+	}
+
+	return 1;
+}
+
+/**
+ *	remove_control_channel - destroys channel /mnt/relay/ltt/control
+ *
+ *	Returns 0, negative otherwise.
+ */
+static int
+remove_control_channel(void)
+{
+	if (control_channel != -1)
+		return relay_close(control_channel);
+
+	return -ENODEV;
+}
+
 static int __init init_ltt(void)
 {
 	int i;
 	int err = 0;
+	struct proc_dir_entry *init_entry;
 
 	ltt_proc_root_entry = proc_mkdir("ltt", NULL);
 
@@ -2375,7 +2469,19 @@ static int __init init_ltt(void)
 		err = -ENOMEM;
 	else
 		ltt_proc_root_entry->owner = THIS_MODULE;
+
+	control_channel = -1;
 	
+	init_entry = create_proc_entry("init", 0666, ltt_proc_root_entry);
+	if (init_entry == NULL) {
+		err = -ENOMEM;
+		return err;
+	}
+
+	init_entry->read_proc = proc_read_init_ltt;
+	init_entry->write_proc = proc_write_init_ltt;
+	init_entry->owner = THIS_MODULE;
+
 	for (i = 0; i < NR_TRACES; i++)
 		init_trace(&current_traces[i]);
 		
@@ -2384,6 +2490,10 @@ static int __init init_ltt(void)
 
 static void __exit exit_ltt(void)
 {
+	remove_proc_entry("init", ltt_proc_root_entry);
+	remove_proc_entry("ltt", NULL);
+
+	remove_control_channel();
 }
 
 module_init(init_ltt)
Index: linux.t/kernel/ltt/ltt-core_hooks.c
===================================================================
--- linux.t.orig/kernel/ltt/ltt-core_hooks.c	2004-03-21 11:28:57.280826067 -0500
+++ linux.t/kernel/ltt/ltt-core_hooks.c	2004-03-21 11:43:18.463988834 -0500
@@ -54,6 +54,7 @@ static struct hook_rec ltt_##name##_rec 
 	hook_exit_disarm(&ltt_##name##_rec); \
 	hook_exit_deregister(&ltt_##name##_rec)
 
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
 /* TRACE_SYSCALL_ENTRY */
 extern void ltt_pre_syscall(struct pt_regs *);
 static void ltt_pre_syscall_hook(struct hook *h, struct pt_regs *regs)
@@ -108,6 +109,7 @@ static int disable_post_syscall_hooks(vo
 	ltt_hook_remove(post_syscall_hook);
 	return 0;
 }
+#endif
 /* TRACE_TRAP_ENTRY */
 static void ltt_trap_entry_hook(struct hook *h, int trapnr, unsigned long eip, struct pt_regs *regs)
 {
@@ -857,8 +859,10 @@ typedef int (*enable_fn_t)(void);
 static enable_fn_t enable[TRACE_EV_MAX + 1][2] =
 {
 	{ NULL, NULL},							/* TRACE_START */
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
 	{ disable_pre_syscall_hooks, enable_pre_syscall_hooks},		/* TRACE_SYSCALL_ENTRY */
 	{ disable_post_syscall_hooks, enable_post_syscall_hooks},	/* TRACE_SYSCALL_EXIT */
+#endif
 	{ disable_trap_entry_hooks, enable_trap_entry_hooks},		/* TRACE_TRAP_ENTRY */
 	{ disable_trap_exit_hooks, enable_trap_exit_hooks},		/* TRACE_TRAP_EXIT */
 	{ disable_irq_entry_hooks, enable_irq_entry_hooks},		/* TRACE_IRQ_ENTRY */
