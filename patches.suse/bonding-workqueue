From: Jaroslav Kysela <perex@suse.cz>
Subject: Replace system timer with work queue in monitor functions
References: 174843

This patch replaces system timer with work queue in monitor functions.
Also, it adds rtnl_lock/unlock calls to timer functions to guarantee
the network atomicity operations when bonding module activates or
deactivates slave devices.

Signed-off-by: Jaroslav Kysela <perex@suse.cz>


--- linux-2.6.16.orig/drivers/net/bonding/bond_alb.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bond_alb.c	2006-05-31 10:51:48.000000000 +0200
@@ -28,7 +28,8 @@
 #include <linux/pkt_sched.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
-#include <linux/timer.h>
+#include <linux/rtnetlink.h>
+#include <linux/workqueue.h>
 #include <linux/ip.h>
 #include <linux/ipv6.h>
 #include <linux/if_arp.h>
@@ -1373,6 +1374,7 @@ void bond_alb_monitor(struct bonding *bo
 	struct slave *slave;
 	int i;
 
+	rtnl_lock();
 	read_lock(&bond->lock);
 
 	if (bond->kill_timers) {
@@ -1471,9 +1473,10 @@ void bond_alb_monitor(struct bonding *bo
 	}
 
 re_arm:
-	mod_timer(&(bond_info->alb_timer), jiffies + alb_delta_in_ticks);
+	schedule_delayed_work(&(bond_info->alb_work), alb_delta_in_ticks);
 out:
 	read_unlock(&bond->lock);
+	rtnl_unlock();
 }
 
 /* assumption: called before the slave is attached to the bond
--- linux-2.6.16.orig/drivers/net/bonding/bond_alb.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bond_alb.h	2006-05-31 09:12:12.000000000 +0200
@@ -84,7 +84,7 @@ struct tlb_slave_info {
 };
 
 struct alb_bond_info {
-	struct timer_list	alb_timer;
+	struct work_struct	alb_work;
 	struct tlb_client_info	*tx_hashtbl; /* Dynamically allocated */
 	spinlock_t		tx_hashtbl_lock;
 	u32			unbalanced_load;
--- linux-2.6.16.orig/drivers/net/bonding/bonding.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bonding.h	2006-05-31 09:54:24.000000000 +0200
@@ -15,7 +15,7 @@
 #ifndef _LINUX_BONDING_H
 #define _LINUX_BONDING_H
 
-#include <linux/timer.h>
+#include <linux/workqueue.h>
 #include <linux/proc_fs.h>
 #include <linux/if_bonding.h>
 #include <linux/kobject.h>
@@ -180,8 +180,8 @@ struct bonding {
 	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
 	rwlock_t lock;
 	rwlock_t curr_slave_lock;
-	struct   timer_list mii_timer;
-	struct   timer_list arp_timer;
+	struct   work_struct mii_work;
+	struct   work_struct arp_work;
 	s8       kill_timers;
 	struct   net_device_stats stats;
 #ifdef CONFIG_PROC_FS
--- linux-2.6.16.orig/drivers/net/bonding/bond_main.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bond_main.c	2006-05-31 10:31:13.000000000 +0200
@@ -50,7 +50,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/init.h>
-#include <linux/timer.h>
+#include <linux/workqueue.h>
 #include <linux/socket.h>
 #include <linux/ctype.h>
 #include <linux/inet.h>
@@ -1971,6 +1971,7 @@ void bond_mii_monitor(struct net_device 
 	int delta_in_ticks;
 	int i;
 
+	rtnl_lock();
 	read_lock(&bond->lock);
 
 	delta_in_ticks = (bond->params.miimon * HZ) / 1000;
@@ -2201,10 +2202,11 @@ void bond_mii_monitor(struct net_device 
 
 re_arm:
 	if (bond->params.miimon) {
-		mod_timer(&bond->mii_timer, jiffies + delta_in_ticks);
+		schedule_delayed_work(&bond->mii_work, delta_in_ticks);
 	}
 out:
 	read_unlock(&bond->lock);
+	rtnl_unlock();
 }
 
 
@@ -2404,6 +2406,7 @@ void bond_loadbalance_arp_mon(struct net
 	int delta_in_ticks;
 	int i;
 
+	rtnl_lock();
 	read_lock(&bond->lock);
 
 	delta_in_ticks = (bond->params.arp_interval * HZ) / 1000;
@@ -2513,10 +2516,11 @@ void bond_loadbalance_arp_mon(struct net
 
 re_arm:
 	if (bond->params.arp_interval) {
-		mod_timer(&bond->arp_timer, jiffies + delta_in_ticks);
+		schedule_delayed_work(&bond->arp_work, delta_in_ticks);
 	}
 out:
 	read_unlock(&bond->lock);
+	rtnl_unlock();
 }
 
 /*
@@ -2541,6 +2545,7 @@ void bond_activebackup_arp_mon(struct ne
 	int delta_in_ticks;
 	int i;
 
+	rtnl_lock();
 	read_lock(&bond->lock);
 
 	delta_in_ticks = (bond->params.arp_interval * HZ) / 1000;
@@ -2757,10 +2762,11 @@ void bond_activebackup_arp_mon(struct ne
 
 re_arm:
 	if (bond->params.arp_interval) {
-		mod_timer(&bond->arp_timer, jiffies + delta_in_ticks);
+		schedule_delayed_work(&bond->arp_work, delta_in_ticks);
 	}
 out:
 	read_unlock(&bond->lock);
+	rtnl_unlock();
 }
 
 /*------------------------------ proc/seq_file-------------------------------*/
@@ -3313,14 +3319,12 @@ static int bond_xmit_hash_policy_l2(stru
 static int bond_open(struct net_device *bond_dev)
 {
 	struct bonding *bond = bond_dev->priv;
-	struct timer_list *mii_timer = &bond->mii_timer;
-	struct timer_list *arp_timer = &bond->arp_timer;
 
 	bond->kill_timers = 0;
 
 	if ((bond->params.mode == BOND_MODE_TLB) ||
 	    (bond->params.mode == BOND_MODE_ALB)) {
-		struct timer_list *alb_timer = &(BOND_ALB_INFO(bond).alb_timer);
+		struct work_struct *alb_work = &(BOND_ALB_INFO(bond).alb_work);
 
 		/* bond_alb_initialize must be called before the timer
 		 * is started.
@@ -3330,40 +3334,22 @@ static int bond_open(struct net_device *
 			return -1;
 		}
 
-		init_timer(alb_timer);
-		alb_timer->expires  = jiffies + 1;
-		alb_timer->data     = (unsigned long)bond;
-		alb_timer->function = (void *)&bond_alb_monitor;
-		add_timer(alb_timer);
+		INIT_WORK(alb_work, (void *)&bond_alb_monitor, bond);
+		schedule_delayed_work(alb_work, 1);
 	}
 
 	if (bond->params.miimon) {  /* link check interval, in milliseconds. */
-		init_timer(mii_timer);
-		mii_timer->expires  = jiffies + 1;
-		mii_timer->data     = (unsigned long)bond_dev;
-		mii_timer->function = (void *)&bond_mii_monitor;
-		add_timer(mii_timer);
+                schedule_delayed_work(&bond->mii_work, 1);
 	}
 
 	if (bond->params.arp_interval) {  /* arp interval, in milliseconds. */
-		init_timer(arp_timer);
-		arp_timer->expires  = jiffies + 1;
-		arp_timer->data     = (unsigned long)bond_dev;
-		if (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {
-			arp_timer->function = (void *)&bond_activebackup_arp_mon;
-		} else {
-			arp_timer->function = (void *)&bond_loadbalance_arp_mon;
-		}
-		add_timer(arp_timer);
+                schedule_delayed_work(&bond->arp_work, 1);
 	}
 
 	if (bond->params.mode == BOND_MODE_8023AD) {
-		struct timer_list *ad_timer = &(BOND_AD_INFO(bond).ad_timer);
-		init_timer(ad_timer);
-		ad_timer->expires  = jiffies + 1;
-		ad_timer->data     = (unsigned long)bond;
-		ad_timer->function = (void *)&bond_3ad_state_machine_handler;
-		add_timer(ad_timer);
+		struct work_struct *ad_work = &(BOND_AD_INFO(bond).ad_work);
+		INIT_WORK(ad_work, (void *)&bond_3ad_state_machine_handler, bond);
+		schedule_delayed_work(ad_work, 1);
 
 		/* register to receive LACPDUs */
 		bond_register_lacpdu(bond);
@@ -3395,20 +3381,20 @@ static int bond_close(struct net_device 
 	 */
 
 	if (bond->params.miimon) {  /* link check interval, in milliseconds. */
-		del_timer_sync(&bond->mii_timer);
+		cancel_rearming_delayed_work(&bond->mii_work);
 	}
 
 	if (bond->params.arp_interval) {  /* arp interval, in milliseconds. */
-		del_timer_sync(&bond->arp_timer);
+		cancel_rearming_delayed_work(&bond->arp_work);
 	}
 
 	switch (bond->params.mode) {
 	case BOND_MODE_8023AD:
-		del_timer_sync(&(BOND_AD_INFO(bond).ad_timer));
+		cancel_rearming_delayed_work(&(BOND_AD_INFO(bond).ad_work));
 		break;
 	case BOND_MODE_TLB:
 	case BOND_MODE_ALB:
-		del_timer_sync(&(BOND_ALB_INFO(bond).alb_timer));
+		cancel_rearming_delayed_work(&(BOND_ALB_INFO(bond).alb_work));
 		break;
 	default:
 		break;
@@ -4112,6 +4098,14 @@ static int bond_init(struct net_device *
 	rwlock_init(&bond->lock);
 	rwlock_init(&bond->curr_slave_lock);
 
+	/* initialize work */
+	INIT_WORK(&bond->mii_work, (void *)&bond_mii_monitor, bond_dev);
+	if (params->mode == BOND_MODE_ACTIVEBACKUP) {
+	        INIT_WORK(&bond->arp_work, (void *)&bond_activebackup_arp_mon, bond_dev);
+	} else {
+		INIT_WORK(&bond->arp_work, (void *)&bond_loadbalance_arp_mon, bond_dev);
+	}
+
 	bond->params = *params; /* copy params struct */
 
 	/* Initialize pointers */
--- linux-2.6.16.orig/drivers/net/bonding/bond_sysfs.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bond_sysfs.c	2006-05-31 10:23:46.000000000 +0200
@@ -1,4 +1,3 @@
-
 /*
  * Copyright(c) 2004-2005 Intel Corporation. All rights reserved.
  *
@@ -424,6 +423,11 @@ static ssize_t bonding_store_mode(struct
 		ret = -EINVAL;
 		goto out;
 	} else {
+	        if (new_value == BOND_MODE_ACTIVEBACKUP) {
+	               INIT_WORK(&bond->arp_work, (void *)&bond_activebackup_arp_mon, bond->dev);
+                } else {
+                       INIT_WORK(&bond->arp_work, (void *)&bond_loadbalance_arp_mon, bond->dev);
+	        }
 		bond->params.mode = new_value;
 		bond_set_mode_ops(bond, bond->params.mode);
 		printk(KERN_INFO DRV_NAME ": %s: setting mode to %s (%d).\n",
@@ -540,13 +544,7 @@ static ssize_t bonding_store_arp_interva
 		       "%s Disabling MII monitoring.\n",
 		       bond->dev->name, bond->dev->name);
 		bond->params.miimon = 0;
-		/* Kill MII timer, else it brings bond's link down */
-		if (bond->arp_timer.function) {
-			printk(KERN_INFO DRV_NAME
-			": %s: Kill MII timer, else it brings bond's link down...\n",
-		       bond->dev->name);
-			del_timer_sync(&bond->mii_timer);
-		}
+		cancel_rearming_delayed_work(&bond->mii_work);
 	}
 	if (!bond->params.arp_targets[0]) {
 		printk(KERN_INFO DRV_NAME
@@ -560,26 +558,8 @@ static ssize_t bonding_store_arp_interva
 		 * timer will get fired off when the open function
 		 * is called.
 		 */
-		if (bond->arp_timer.function) {
-			/* The timer's already set up, so fire it off */
-			mod_timer(&bond->arp_timer, jiffies + 1);
-		} else {
-			/* Set up the timer. */
-			init_timer(&bond->arp_timer);
-			bond->arp_timer.expires = jiffies + 1;
-			bond->arp_timer.data =
-				(unsigned long) bond->dev;
-			if (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {
-				bond->arp_timer.function =
-					(void *)
-					&bond_activebackup_arp_mon;
-			} else {
-				bond->arp_timer.function =
-					(void *)
-					&bond_loadbalance_arp_mon;
-			}
-			add_timer(&bond->arp_timer);
-		}
+		cancel_rearming_delayed_work(&bond->arp_work);
+		schedule_delayed_work(&bond->arp_work, 1);
 	}
 
 out:
@@ -909,13 +889,7 @@ static ssize_t bonding_store_miimon(stru
 			       "ARP monitoring. Disabling ARP monitoring...\n",
 			       bond->dev->name);
 			bond->params.arp_interval = 0;
-			/* Kill ARP timer, else it brings bond's link down */
-			if (bond->mii_timer.function) {
-				printk(KERN_INFO DRV_NAME
-				": %s: Kill ARP timer, else it brings bond's link down...\n",
-			       bond->dev->name);
-				del_timer_sync(&bond->arp_timer);
-			}
+			cancel_rearming_delayed_work(&bond->arp_work);
 		}
 
 		if (bond->dev->flags & IFF_UP) {
@@ -924,19 +898,8 @@ static ssize_t bonding_store_miimon(stru
 			 * timer will get fired off when the open function
 			 * is called.
 			 */
-			if (bond->mii_timer.function) {
-				/* The timer's already set up, so fire it off */
-				mod_timer(&bond->mii_timer, jiffies + 1);
-			} else {
-				/* Set up the timer. */
-				init_timer(&bond->mii_timer);
-				bond->mii_timer.expires = jiffies + 1;
-				bond->mii_timer.data =
-					(unsigned long) bond->dev;
-				bond->mii_timer.function =
-					(void *) &bond_mii_monitor;
-				add_timer(&bond->mii_timer);
-			}
+			cancel_rearming_delayed_work(&bond->mii_work);
+			schedule_delayed_work(&bond->mii_work, 1);
 		}
 	}
 out:
--- linux-2.6.16.orig/drivers/net/bonding/bond_3ad.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bond_3ad.c	2006-05-31 09:57:09.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/ethtool.h>
 #include <linux/if_bonding.h>
 #include <linux/pkt_sched.h>
+#include <linux/rtnetlink.h>
 #include "bonding.h"
 #include "bond_3ad.h"
 
@@ -2093,6 +2094,7 @@ void bond_3ad_state_machine_handler(stru
 	struct port *port;
 	struct aggregator *aggregator;
 
+	rtnl_lock();
 	read_lock(&bond->lock);
 
 	if (bond->kill_timers) {
@@ -2140,9 +2142,10 @@ void bond_3ad_state_machine_handler(stru
 	}
 
 re_arm:
-	mod_timer(&(BOND_AD_INFO(bond).ad_timer), jiffies + ad_delta_in_ticks);
+	schedule_delayed_work(&(BOND_AD_INFO(bond).ad_work), ad_delta_in_ticks);
 out:
 	read_unlock(&bond->lock);
+	rtnl_unlock();
 }
 
 /**
--- linux-2.6.16.orig/drivers/net/bonding/bond_3ad.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bond_3ad.h	2006-05-31 09:12:32.000000000 +0200
@@ -261,7 +261,7 @@ struct ad_bond_info {
 	int lacp_fast;		/* whether fast periodic tx should be
 				 * requested
 				 */
-	struct timer_list ad_timer;
+	struct work_struct ad_work;
 	struct packet_type ad_pkt_type;
 };
 
