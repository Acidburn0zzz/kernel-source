From: Kurt Garloff <garloff@suse.de>
Subject: [PATCH] X86: sysctl to allow panic on IOCK NMI error
References: bnc427979

This patch introduces a sysctl /proc/sys/kernel/panic_on_io_nmi.,
which defaults to 0 (off).
When enabled, the kernel panics when the kernel receives an NMI
caused by an IO error.

The IO error triggered NMI indicates a serious system condition,
which could result in IO data corruption. Rather than contiuing,
panicing and dumping might be a better choice, so one can figure
out what's causing the IO error.
This could be especially important to companies running IO intensive
applications where corruption must be avoided, e.g. a banks databases.


Signed-off-by: Roberto Angelino <robertangelino@gmail.com>


diff -Nrp -U6 linux-2.6.27/arch/x86/kernel/traps_32.c linux-2.6.27.nmi/arch/x86/kernel/traps_32.c
--- linux-2.6.27/arch/x86/kernel/traps_32.c	2008-11-18 09:54:50.000000000 +0100
+++ linux-2.6.27.nmi/arch/x86/kernel/traps_32.c	2008-11-18 10:10:38.000000000 +0100
@@ -80,12 +80,13 @@ char ignore_fpu_irq;
  * for this.
  */
 gate_desc idt_table[256]
 	__attribute__((__section__(".data.idt"))) = { { { { 0, 0 } } }, };
 
 int panic_on_unrecovered_nmi;
+int panic_on_io_nmi;
 int kstack_depth_to_print = 24;
 static unsigned int code_bytes = 64;
 #ifdef CONFIG_STACK_UNWIND
 static int call_trace = 1;
 #else
 #define call_trace (-1)
@@ -776,12 +777,15 @@ io_check_error(unsigned char reason, str
 {
 	unsigned long i;
 
 	printk(KERN_EMERG "NMI: IOCK error (debug interrupt?)\n");
 	show_registers(regs);
 
+	if (panic_on_io_nmi)
+		panic("NMI IOCK error: Not continuing");
+
 	/* Re-enable the IOCK line, wait for a few seconds */
 	reason = (reason & 0xf) | 8;
 	outb(reason, 0x61);
 
 	i = 2000;
 	while (--i)
diff -Nrp -U6 linux-2.6.27/arch/x86/kernel/traps_64.c linux-2.6.27.nmi/arch/x86/kernel/traps_64.c
--- linux-2.6.27/arch/x86/kernel/traps_64.c	2008-11-18 09:54:50.000000000 +0100
+++ linux-2.6.27.nmi/arch/x86/kernel/traps_64.c	2008-11-18 10:13:04.000000000 +0100
@@ -53,12 +53,13 @@
 #include <asm/pda.h>
 #include <asm/traps.h>
 
 #include <mach_traps.h>
 
 int panic_on_unrecovered_nmi;
+int panic_on_io_nmi;
 int kstack_depth_to_print = 12;
 static unsigned int code_bytes = 64;
 #ifdef CONFIG_STACK_UNWIND
 static int call_trace = 1;
 #else
 #define call_trace (-1)
@@ -837,12 +838,15 @@ mem_parity_error(unsigned char reason, s
 static notrace __kprobes void
 io_check_error(unsigned char reason, struct pt_regs *regs)
 {
 	printk("NMI: IOCK error (debug interrupt?)\n");
 	show_registers(regs);
 
+	if (panic_on_io_nmi)
+		panic("NMI IOCK error: Not continuing");
+
 	/* Re-enable the IOCK line, wait for a few seconds */
 	reason = (reason & 0xf) | 8;
 	outb(reason, 0x61);
 	mdelay(2000);
 	reason &= ~8;
 	outb(reason, 0x61);
diff -Nrp -U6 linux-2.6.27/include/linux/kernel.h linux-2.6.27.nmi/include/linux/kernel.h
--- linux-2.6.27/include/linux/kernel.h	2008-11-18 09:54:54.000000000 +0100
+++ linux-2.6.27.nmi/include/linux/kernel.h	2008-11-18 10:07:21.000000000 +0100
@@ -233,12 +233,13 @@ static inline void console_verbose(void)
 extern void bust_spinlocks(int yes);
 extern void wake_up_klogd(void);
 extern int oops_in_progress;		/* If set, an oops, panic(), BUG() or die() is in progress */
 extern int panic_timeout;
 extern int panic_on_oops;
 extern int panic_on_unrecovered_nmi;
+extern int panic_on_io_nmi;
 extern int tainted;
 extern int unsupported;
 extern const char *print_tainted(void);
 extern void add_taint(unsigned);
 extern int root_mountflags;
 
diff -Nrp -U6 linux-2.6.27/include/linux/sysctl.h linux-2.6.27.nmi/include/linux/sysctl.h
--- linux-2.6.27/include/linux/sysctl.h	2008-11-18 09:54:56.000000000 +0100
+++ linux-2.6.27.nmi/include/linux/sysctl.h	2008-11-18 10:05:35.000000000 +0100
@@ -163,12 +163,13 @@ enum
 	KERN_COMPAT_LOG=73,	/* int: print compat layer  messages */
 	KERN_MAX_LOCK_DEPTH=74,
 	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
 	KERN_KDB=77,		/* int: kdb on/off */
 	KERN_DUMP_AFTER_NOTIFIER=78, /* int: kdump after panic_notifier (SUSE only) */
+	KERN_PANIC_ON_IO_NMI=79, /* int: whether we will panic on an io NMI */
 };
 
 
 
 /* CTL_VM names: */
 enum
diff -Nrp -U6 linux-2.6.27/kernel/sysctl.c linux-2.6.27.nmi/kernel/sysctl.c
--- linux-2.6.27/kernel/sysctl.c	2008-11-18 09:54:58.000000000 +0100
+++ linux-2.6.27.nmi/kernel/sysctl.c	2008-11-18 10:04:12.000000000 +0100
@@ -687,12 +687,20 @@ static struct ctl_table kern_table[] = {
 		.data		= &panic_on_unrecovered_nmi,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
 	{
+		.ctl_name	= KERN_PANIC_ON_IO_NMI,
+		.procname	= "panic_on_io_nmi",
+		.data		= &panic_on_io_nmi,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
 		.ctl_name	= KERN_BOOTLOADER_TYPE,
 		.procname	= "bootloader_type",
 		.data		= &bootloader_type,
 		.maxlen		= sizeof (int),
 		.mode		= 0444,
 		.proc_handler	= &proc_dointvec,
diff -Nrp -U6 linux-2.6.27/kernel/sysctl_check.c linux-2.6.27.nmi/kernel/sysctl_check.c
--- linux-2.6.27/kernel/sysctl_check.c	2008-11-18 09:54:56.000000000 +0100
+++ linux-2.6.27.nmi/kernel/sysctl_check.c	2008-11-18 10:06:39.000000000 +0100
@@ -102,12 +102,13 @@ static const struct trans_ctl_table tran
 	{ KERN_ACPI_VIDEO_FLAGS,	"acpi_video_flags" },
 	{ KERN_IA64_UNALIGNED,		"ignore-unaligned-usertrap" },
 	{ KERN_COMPAT_LOG,		"compat-log" },
 	{ KERN_MAX_LOCK_DEPTH,		"max_lock_depth" },
 	{ KERN_NMI_WATCHDOG,		"nmi_watchdog" },
 	{ KERN_PANIC_ON_NMI,		"panic_on_unrecovered_nmi" },
+	{ KERN_PANIC_ON_IO_NMI,		"panic_on_io_nmi" },
 	{ KERN_SETUID_DUMPABLE,		"suid_dumpable" },
 	{ KERN_KDB,			"kdb" },
 	{ KERN_DUMP_AFTER_NOTIFIER,	"dump_after_notifier" },
 	{}
 };
 
