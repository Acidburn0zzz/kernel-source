From: Olaf Kirch <okir@suse.de>
Subject: [NFS] Make lockd use hostnames instead of IP addresses

This patch makes the NFS lockd use hostnames instead of IP addresses
when identifying its peers.


Index: linux-2.6.12/fs/lockd/clntlock.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/clntlock.c
+++ linux-2.6.12/fs/lockd/clntlock.c
@@ -172,13 +172,10 @@ void nlmclnt_mark_reclaim(struct nlm_hos
 static inline
 void nlmclnt_prepare_reclaim(struct nlm_host *host, u32 newstate)
 {
-	host->h_monitored = 0;
-	host->h_nsmstate = newstate;
-	host->h_state++;
 	host->h_nextrebind = 0;
 	nlm_rebind_host(host);
 	nlmclnt_mark_reclaim(host);
-	dprintk("NLM: reclaiming locks for host %s", host->h_name);
+	dprintk("lockd: reclaiming locks for host %s\n", host->h_name);
 }
 
 /*
@@ -188,12 +185,8 @@ void nlmclnt_prepare_reclaim(struct nlm_
 void
 nlmclnt_recovery(struct nlm_host *host, u32 newstate)
 {
-	if (host->h_reclaiming++) {
-		if (host->h_nsmstate == newstate)
-			return;
-		nlmclnt_prepare_reclaim(host, newstate);
-	} else {
-		nlmclnt_prepare_reclaim(host, newstate);
+	nlmclnt_prepare_reclaim(host, newstate);
+	if (!host->h_reclaiming++) {
 		nlm_get_host(host);
 		__module_get(THIS_MODULE);
 		if (kernel_thread(reclaimer, host, CLONE_KERNEL) < 0)
Index: linux-2.6.12/fs/lockd/clntproc.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/clntproc.c
+++ linux-2.6.12/fs/lockd/clntproc.c
@@ -207,7 +207,7 @@ nlmclnt_proc(struct inode *inode, int cm
 	/* Retrieve transport protocol from NFS client */
 	proto = NFS_CLIENT(inode)->cl_xprt->prot;
 
-	if (!(host = nlmclnt_lookup_host(NFS_ADDR(inode), proto, vers)))
+	if (!(host = nlmclnt_lookup_host(NFS_ADDR(inode), proto, vers, nfssrv->hostname)))
 		return -ENOLCK;
 
 	/* Create RPC client handle if not there, and copy soft
@@ -557,7 +557,7 @@ nlmclnt_lock(struct nlm_rqst *req, struc
 	long timeout;
 	int status;
 
-	if (!host->h_monitored && nsm_monitor(host) < 0) {
+	if (nsm_monitor(host) < 0) {
 		printk(KERN_NOTICE "lockd: failed to monitor %s\n",
 					host->h_name);
 		status = -ENOLCK;
Index: linux-2.6.12/fs/lockd/host.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/host.c
+++ linux-2.6.12/fs/lockd/host.c
@@ -19,12 +19,11 @@
 
 
 #define NLMDBG_FACILITY		NLMDBG_HOSTCACHE
-#define NLM_HOST_MAX		64
 #define NLM_HOST_NRHASH		32
 #define NLM_ADDRHASH(addr)	(ntohl(addr) & (NLM_HOST_NRHASH-1))
 #define NLM_HOST_REBIND		(60 * HZ)
-#define NLM_HOST_EXPIRE		((nrhosts > NLM_HOST_MAX)? 300 * HZ : 120 * HZ)
-#define NLM_HOST_COLLECT	((nrhosts > NLM_HOST_MAX)? 120 * HZ :  60 * HZ)
+#define NLM_HOST_EXPIRE		((nrhosts > nlm_max_hosts)? 300 * HZ : 120 * HZ)
+#define NLM_HOST_COLLECT	((nrhosts > nlm_max_hosts)? 120 * HZ :  60 * HZ)
 #define NLM_HOST_ADDR(sv)	(&(sv)->s_nlmclnt->cl_xprt->addr)
 
 static struct nlm_host *	nlm_hosts[NLM_HOST_NRHASH];
@@ -34,24 +33,26 @@ static DECLARE_MUTEX(nlm_host_sema);
 
 
 static void			nlm_gc_hosts(void);
+static struct nsm_handle *	__nsm_find(const struct sockaddr_in *, const char *, int);
 
 /*
  * Find an NLM server handle in the cache. If there is none, create it.
  */
 struct nlm_host *
-nlmclnt_lookup_host(struct sockaddr_in *sin, int proto, int version)
+nlmclnt_lookup_host(struct sockaddr_in *sin, int proto, int version, const char *hostname)
 {
-	return nlm_lookup_host(0, sin, proto, version);
+	return nlm_lookup_host(0, sin, proto, version, hostname);
 }
 
 /*
  * Find an NLM client handle in the cache. If there is none, create it.
  */
 struct nlm_host *
-nlmsvc_lookup_host(struct svc_rqst *rqstp)
+nlmsvc_lookup_host(struct svc_rqst *rqstp, const char *hostname)
 {
 	return nlm_lookup_host(1, &rqstp->rq_addr,
-			       rqstp->rq_prot, rqstp->rq_vers);
+			       rqstp->rq_prot, rqstp->rq_vers,
+			       hostname);
 }
 
 /*
@@ -59,14 +60,17 @@ nlmsvc_lookup_host(struct svc_rqst *rqst
  */
 struct nlm_host *
 nlm_lookup_host(int server, struct sockaddr_in *sin,
-					int proto, int version)
+					int proto, int version,
+					const char *hostname)
 {
 	struct nlm_host	*host, **hp;
-	u32		addr;
+	struct nsm_handle *nsm = NULL;
 	int		hash;
 
-	dprintk("lockd: nlm_lookup_host(%08x, p=%d, v=%d)\n",
-			(unsigned)(sin? ntohl(sin->sin_addr.s_addr) : 0), proto, version);
+	dprintk("lockd: nlm_lookup_host(%08x, p=%d, v=%d, my role=%s, name=%s)\n",
+			(unsigned)(sin? ntohl(sin->sin_addr.s_addr) : 0), proto, version,
+			server? "server" : "client",
+			hostname? hostname : "<none>");
 
 	hash = NLM_ADDRHASH(sin->sin_addr.s_addr);
 
@@ -76,7 +80,21 @@ nlm_lookup_host(int server, struct socka
 	if (time_after_eq(jiffies, next_gc))
 		nlm_gc_hosts();
 
+	/* We may keep several nlm_host objects for a peer, because each
+	 * nlm_host is identified by
+	 * (address, protocol, version, server/client)
+	 * We could probably simplify this a little by putting all those
+	 * different NLM rpc_clients into one single nlm_host object.
+	 * This would allow us to have one nlm_host per address.
+	 */
 	for (hp = &nlm_hosts[hash]; (host = *hp) != 0; hp = &host->h_next) {
+		if (!nlm_cmp_addr(&host->h_addr, sin))
+			continue;
+
+		/* See if we have an NSM handle for this client */
+		if (!nsm && (nsm = host->h_nsmhandle) != 0)
+			atomic_inc(&nsm->sm_count);
+
 		if (host->h_proto != proto)
 			continue;
 		if (host->h_version != version)
@@ -84,28 +102,28 @@ nlm_lookup_host(int server, struct socka
 		if (host->h_server != server)
 			continue;
 
-		if (nlm_cmp_addr(&host->h_addr, sin)) {
-			if (hp != nlm_hosts + hash) {
-				*hp = host->h_next;
-				host->h_next = nlm_hosts[hash];
-				nlm_hosts[hash] = host;
-			}
-			nlm_get_host(host);
-			up(&nlm_host_sema);
-			return host;
+		/* Move it to the head of the hash chain. */
+		if (hp != nlm_hosts + hash) {
+			*hp = host->h_next;
+			host->h_next = nlm_hosts[hash];
+			nlm_hosts[hash] = host;
 		}
+		nlm_get_host(host);
+		goto out;
 	}
 
-	/* Ooops, no host found, create it */
-	dprintk("lockd: creating host entry\n");
+	/* Sadly, the host isn't in our hash table yet. See if
+	 * we have an NSM handle for it. If not, create one.
+	 */
+	if (!nsm && !(nsm = nsm_find(sin, hostname)))
+		goto out;
 
-	if (!(host = (struct nlm_host *) kmalloc(sizeof(*host), GFP_KERNEL)))
-		goto nohost;
+	if (!(host = (struct nlm_host *) kmalloc(sizeof(*host), GFP_KERNEL))) {
+		nsm_release(nsm);
+		goto out;
+	}
 	memset(host, 0, sizeof(*host));
-
-	addr = sin->sin_addr.s_addr;
-	sprintf(host->h_name, "%u.%u.%u.%u", NIPQUAD(addr));
-
+	host->h_name	   = nsm->sm_name;
 	host->h_addr       = *sin;
 	host->h_addr.sin_port = 0;	/* ouch! */
 	host->h_version    = version;
@@ -118,16 +136,17 @@ nlm_lookup_host(int server, struct socka
 	init_waitqueue_head(&host->h_gracewait);
 	host->h_state      = 0;			/* pseudo NSM state */
 	host->h_nsmstate   = 0;			/* real NSM state */
+	host->h_nsmhandle  = nsm;
 	host->h_server	   = server;
 	host->h_next       = nlm_hosts[hash];
 	nlm_hosts[hash]    = host;
 	INIT_LIST_HEAD(&host->h_lockowners);
 	spin_lock_init(&host->h_lock);
 
-	if (++nrhosts > NLM_HOST_MAX)
+	if (++nrhosts > nlm_max_hosts)
 		next_gc = 0;
 
-nohost:
+out:
 	up(&nlm_host_sema);
 	return host;
 }
@@ -135,16 +154,17 @@ nohost:
 struct nlm_host *
 nlm_find_client(void)
 {
-	/* find a nlm_host for a client for which h_killed == 0.
-	 * and return it
+	/* Find the next NLM client host and remove it from the
+	 * list. The caller is supposed to release all resources
+	 * held by this client, and release the nlm_host afterwards.
 	 */
 	int hash;
 	down(&nlm_host_sema);
 	for (hash = 0 ; hash < NLM_HOST_NRHASH; hash++) {
 		struct nlm_host *host, **hp;
 		for (hp = &nlm_hosts[hash]; (host = *hp) != 0; hp = &host->h_next) {
-			if (host->h_server &&
-			    host->h_killed == 0) {
+			if (host->h_server) {
+				*hp = host->h_next;
 				nlm_get_host(host);
 				up(&nlm_host_sema);
 				return host;
@@ -243,13 +263,69 @@ struct nlm_host * nlm_get_host(struct nl
 void nlm_release_host(struct nlm_host *host)
 {
 	if (host != NULL) {
-		dprintk("lockd: release host %s\n", host->h_name);
+		dprintk("lockd: release host %s, refcount is now %u\n",
+				host->h_name, atomic_read(&host->h_count)-1);
 		atomic_dec(&host->h_count);
 		BUG_ON(atomic_read(&host->h_count) < 0);
 	}
 }
 
 /*
+ * Given an IP address or a host name, initiate recovery and ditch all locks.
+ */
+void
+nlm_host_rebooted(const struct sockaddr_in *sin, const char *hostname, u32 new_state)
+{
+	struct nsm_handle *nsm;
+	struct nlm_host	*host, **hp;
+	int		hash;
+
+	dprintk("lockd: nlm_host_rebooted(%s, %u.%u.%u.%u)\n",
+			hostname, NIPQUAD(sin->sin_addr));
+
+	/* Find the NSM handle for this peer */
+	if (!(nsm = __nsm_find(sin, hostname, 0)))
+		return;
+
+	/* When reclaiming locks on this peer, make sure that
+	 * we set up a new notification */
+	nsm->sm_monitored = 0;
+
+	/* Mark all hosts tied to this NSM state as having rebooted.
+	 * We run the loop repeatedly, because we drop the host table
+	 * lock for this.
+	 * To avoid processing a host several times, we match the nsmstate.
+	 */
+again:	down(&nlm_host_sema);
+	for (hash = 0; hash < NLM_HOST_NRHASH; hash++) {
+		for (hp = &nlm_hosts[hash]; (host = *hp); hp = &host->h_next) {
+			if (host->h_nsmhandle == nsm
+			 && host->h_nsmstate != new_state) {
+				host->h_nsmstate = new_state;
+				host->h_state++;
+
+				nlm_get_host(host);
+				up(&nlm_host_sema);
+
+				if (host->h_server) {
+					/* We're server for this guy, just ditch
+					 * all the locks he held. */
+					nlmsvc_free_host_resources(host);
+				} else {
+					/* He's the server, initiate lock recovery. */
+					nlmclnt_recovery(host, new_state);
+				}
+
+				nlm_release_host(host);
+				goto again;
+			}
+		}
+	}
+
+	up(&nlm_host_sema);
+}
+
+/*
  * Shut down the hosts module.
  * Note that this routine is called only at server shutdown time.
  */
@@ -321,9 +397,12 @@ nlm_gc_hosts(void)
 			}
 			dprintk("lockd: delete host %s\n", host->h_name);
 			*q = host->h_next;
-			/* Don't unmonitor hosts that have been invalidated */
-			if (host->h_monitored && !host->h_killed)
-				nsm_unmonitor(host);
+
+			/* Release the NSM handle. Unmonitor unless
+			 * host was invalidated (i.e. lockd restarted)
+			 */
+			nsm_unmonitor(host);
+
 			if ((clnt = host->h_rpcclnt) != NULL) {
 				if (atomic_read(&clnt->cl_users)) {
 					printk(KERN_WARNING
@@ -342,3 +421,87 @@ nlm_gc_hosts(void)
 	next_gc = jiffies + NLM_HOST_COLLECT;
 }
 
+
+/*
+ * Manage NSM handles
+ */
+static LIST_HEAD(nsm_handles);
+static DECLARE_MUTEX(nsm_sema);
+
+static struct nsm_handle *
+__nsm_find(const struct sockaddr_in *sin, const char *hostname, int create)
+{
+	struct nsm_handle *nsm = NULL;
+	struct list_head *pos;
+	int hlen;
+
+	if (!hostname || !sin)
+		return NULL;
+
+	if (nsm_use_hostnames && strchr(hostname, '/') != NULL) {
+		if (printk_ratelimit()) {
+			printk(KERN_WARNING "Invalid hostname \"%s\" "
+					    "in NFS lock request\n",
+				hostname);
+		}
+		return NULL;
+	}
+
+	down(&nsm_sema);
+	list_for_each(pos, &nsm_handles) {
+		nsm = list_entry(pos, struct nsm_handle, sm_link);
+		if (nsm_use_hostnames) {
+			if (strcmp(nsm->sm_name, hostname))
+				continue;
+		} else if (!nlm_cmp_addr(&nsm->sm_addr, sin)) {
+			continue;
+		}
+		atomic_inc(&nsm->sm_count);
+		goto out;
+	}
+
+	if (!create) {
+		nsm = NULL;
+		goto out;
+	}
+
+	hlen = strlen(hostname) + 1;
+
+	nsm = (struct nsm_handle *) kmalloc(sizeof(*nsm) + hlen, GFP_KERNEL);
+	if (nsm != NULL) {
+		memset(nsm, 0, sizeof(*nsm));
+		nsm->sm_addr = *sin;
+		nsm->sm_name = (char *) (nsm + 1);
+		strcpy(nsm->sm_name, hostname);
+		atomic_set(&nsm->sm_count, 1);
+
+		list_add(&nsm->sm_link, &nsm_handles);
+	}
+
+out:	up(&nsm_sema);
+	return nsm;
+}
+
+struct nsm_handle *
+nsm_find(const struct sockaddr_in *sin, const char *hostname)
+{
+	return __nsm_find(sin, hostname, 1);
+}
+
+/*
+ * Release an NSM handle
+ */
+void
+nsm_release(struct nsm_handle *nsm)
+{
+	if (!nsm)
+		return;
+	if (atomic_read(&nsm->sm_count) == 1) {
+		down(&nsm_sema);
+		if (atomic_dec_and_test(&nsm->sm_count)) {
+			list_del(&nsm->sm_link);
+			kfree(nsm);
+		}
+		up(&nsm_sema);
+	}
+}
Index: linux-2.6.12/fs/lockd/mon.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/mon.c
+++ linux-2.6.12/fs/lockd/mon.c
@@ -23,6 +23,7 @@ static struct rpc_program	nsm_program;
 
 /*
  * Local NSM state
+ * This should really be initialized somehow.
  */
 u32				nsm_local_state;
 
@@ -30,7 +31,7 @@ u32				nsm_local_state;
  * Common procedure for SM_MON/SM_UNMON calls
  */
 static int
-nsm_mon_unmon(struct nlm_host *host, u32 proc, struct nsm_res *res)
+nsm_mon_unmon(struct nsm_handle *nsm, u32 proc, struct nsm_res *res)
 {
 	struct rpc_clnt	*clnt;
 	int		status;
@@ -42,10 +43,10 @@ nsm_mon_unmon(struct nlm_host *host, u32
 		goto out;
 	}
 
-	args.addr = host->h_addr.sin_addr.s_addr;
-	args.proto= (host->h_proto<<1) | host->h_server;
+	memset(&args, 0, sizeof(args));
+	args.mon_name = nsm->sm_name;
 	args.prog = NLM_PROGRAM;
-	args.vers = host->h_version;
+	args.vers = 3;
 	args.proc = NLMPROC_NSM_NOTIFY;
 	memset(res, 0, sizeof(*res));
 
@@ -65,17 +66,23 @@ nsm_mon_unmon(struct nlm_host *host, u32
 int
 nsm_monitor(struct nlm_host *host)
 {
+	struct nsm_handle *nsm;
 	struct nsm_res	res;
 	int		status;
 
 	dprintk("lockd: nsm_monitor(%s)\n", host->h_name);
+	if ((nsm = host->h_nsmhandle) == NULL)
+		BUG();
 
-	status = nsm_mon_unmon(host, SM_MON, &res);
+	if (nsm->sm_monitored)
+		return 0;
+
+	status = nsm_mon_unmon(nsm, SM_MON, &res);
 
 	if (status < 0 || res.status != 0)
 		printk(KERN_NOTICE "lockd: cannot monitor %s\n", host->h_name);
 	else
-		host->h_monitored = 1;
+		nsm->sm_monitored = 1;
 	return status;
 }
 
@@ -85,16 +92,25 @@ nsm_monitor(struct nlm_host *host)
 int
 nsm_unmonitor(struct nlm_host *host)
 {
+	struct nsm_handle *nsm;
 	struct nsm_res	res;
-	int		status;
+	int		status = 0;
 
-	dprintk("lockd: nsm_unmonitor(%s)\n", host->h_name);
+	nsm = host->h_nsmhandle;
+	host->h_nsmhandle = NULL;
 
-	status = nsm_mon_unmon(host, SM_UNMON, &res);
-	if (status < 0)
-		printk(KERN_NOTICE "lockd: cannot unmonitor %s\n", host->h_name);
-	else
-		host->h_monitored = 0;
+	if (nsm && atomic_read(&nsm->sm_count) == 1
+	 && nsm->sm_monitored && !nsm->sm_sticky) {
+		dprintk("lockd: nsm_unmonitor(%s)\n", host->h_name);
+		status = nsm_mon_unmon(nsm, SM_UNMON, &res);
+		if (status < 0) {
+			printk(KERN_NOTICE "lockd: cannot unmonitor %s\n",
+				       	host->h_name);
+		} else {
+			nsm->sm_monitored = 0;
+		}
+	}
+	nsm_release(nsm);
 	return status;
 }
 
@@ -138,7 +154,7 @@ out_err:
 static u32 *
 xdr_encode_common(struct rpc_rqst *rqstp, u32 *p, struct nsm_args *argp)
 {
-	char	buffer[20];
+	char	buffer[20], *name;
 
 	/*
 	 * Use the dotted-quad IP address of the remote host as
@@ -146,8 +162,13 @@ xdr_encode_common(struct rpc_rqst *rqstp
 	 * hostname first for whatever remote hostname it receives,
 	 * so this works alright.
 	 */
-	sprintf(buffer, "%u.%u.%u.%u", NIPQUAD(argp->addr));
-	if (!(p = xdr_encode_string(p, buffer))
+	if (nsm_use_hostnames) {
+		name = argp->mon_name;
+	} else {
+		sprintf(buffer, "%u.%u.%u.%u", NIPQUAD(argp->addr));
+		name = buffer;
+	}
+	if (!(p = xdr_encode_string(p, name))
 	 || !(p = xdr_encode_string(p, system_utsname.nodename)))
 		return ERR_PTR(-EIO);
 	*p++ = htonl(argp->prog);
Index: linux-2.6.12/fs/lockd/svc.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/svc.c
+++ linux-2.6.12/fs/lockd/svc.c
@@ -59,6 +59,8 @@ static DECLARE_WAIT_QUEUE_HEAD(lockd_exi
 static unsigned long		nlm_grace_period;
 static unsigned long		nlm_timeout = LOCKD_DFLT_TIMEO;
 static int			nlm_udpport, nlm_tcpport;
+int				nlm_max_hosts = 256;
+int				nsm_use_hostnames = 1;
 
 /*
  * Constants needed for the sysctl interface.
@@ -367,6 +369,23 @@ static ctl_table nlm_sysctls[] = {
 		.extra1		= (int *) &nlm_port_min,
 		.extra2		= (int *) &nlm_port_max,
 	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nlm_max_hosts",
+		.data		= &nlm_max_hosts,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nsm_use_hostnames",
+		.data		= &nsm_use_hostnames,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+
 	{ .ctl_name = 0 }
 };
 
Index: linux-2.6.12/fs/lockd/svc4proc.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/svc4proc.c
+++ linux-2.6.12/fs/lockd/svc4proc.c
@@ -41,8 +41,8 @@ nlm4svc_retrieve_args(struct svc_rqst *r
 		return nlm_lck_denied_nolocks;
 
 	/* Obtain host handle */
-	if (!(host = nlmsvc_lookup_host(rqstp))
-	 || (argp->monitor && !host->h_monitored && nsm_monitor(host) < 0))
+	if (!(host = nlmsvc_lookup_host(rqstp, lock->caller))
+	 || (argp->monitor && nsm_monitor(host) < 0))
 		goto no_locks;
 	*hostp = host;
 
@@ -417,10 +417,6 @@ nlm4svc_proc_sm_notify(struct svc_rqst *
 					      void	        *resp)
 {
 	struct sockaddr_in	saddr = rqstp->rq_addr;
-	int			vers = argp->vers;
-	int			prot = argp->proto >> 1;
-
-	struct nlm_host		*host;
 
 	dprintk("lockd: SM_NOTIFY     called\n");
 	if (saddr.sin_addr.s_addr != htonl(INADDR_LOOPBACK)
@@ -432,24 +428,7 @@ nlm4svc_proc_sm_notify(struct svc_rqst *
 		return rpc_system_err;
 	}
 
-	/* Obtain the host pointer for this NFS server and try to
-	 * reclaim all locks we hold on this server.
-	 */
-	saddr.sin_addr.s_addr = argp->addr;
-
-	if ((argp->proto & 1)==0) {
-		if ((host = nlmclnt_lookup_host(&saddr, prot, vers)) != NULL) {
-			nlmclnt_recovery(host, argp->state);
-			nlm_release_host(host);
-		}
-	} else {
-		/* If we run on an NFS server, delete all locks held by the client */
-
-		if ((host = nlm_lookup_host(1, &saddr, prot, vers)) != NULL) {
-			nlmsvc_free_host_resources(host);
-			nlm_release_host(host);
-		}
-	}
+	nlm_host_rebooted(&saddr, argp->mon, argp->state);
 	return rpc_success;
 }
 
@@ -484,7 +463,8 @@ nlm4svc_callback(struct svc_rqst *rqstp,
 		return rpc_system_err;
 
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				NULL);
 	if (!host) {
 		kfree(call);
 		return rpc_system_err;
Index: linux-2.6.12/fs/lockd/svclock.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/svclock.c
+++ linux-2.6.12/fs/lockd/svclock.c
@@ -177,7 +177,8 @@ nlmsvc_create_block(struct svc_rqst *rqs
 
 	/* Create host handle for callback */
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				lock->caller);
 	if (host == NULL)
 		return NULL;
 
Index: linux-2.6.12/fs/lockd/svcproc.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/svcproc.c
+++ linux-2.6.12/fs/lockd/svcproc.c
@@ -22,7 +22,8 @@
 
 #define NLMDBG_FACILITY		NLMDBG_CLIENT
 
-static u32	nlmsvc_callback(struct svc_rqst *, u32, struct nlm_res *);
+static u32	nlmsvc_callback(struct svc_rqst *, u32,
+			struct nlm_res *, const char *);
 static void	nlmsvc_callback_exit(struct rpc_task *);
 
 #ifdef CONFIG_LOCKD_V4
@@ -70,8 +71,8 @@ nlmsvc_retrieve_args(struct svc_rqst *rq
 		return nlm_lck_denied_nolocks;
 
 	/* Obtain host handle */
-	if (!(host = nlmsvc_lookup_host(rqstp))
-	 || (argp->monitor && !host->h_monitored && nsm_monitor(host) < 0))
+	if (!(host = nlmsvc_lookup_host(rqstp, lock->caller))
+	 || (argp->monitor && nsm_monitor(host) < 0))
 		goto no_locks;
 	*hostp = host;
 
@@ -276,7 +277,8 @@ nlmsvc_proc_test_msg(struct svc_rqst *rq
 	memset(&res, 0, sizeof(res));
 
 	if ((stat = nlmsvc_proc_test(rqstp, argp, &res)) == 0)
-		stat = nlmsvc_callback(rqstp, NLMPROC_TEST_RES, &res);
+		stat = nlmsvc_callback(rqstp, NLMPROC_TEST_RES, &res,
+				argp->lock.caller);
 	return stat;
 }
 
@@ -291,7 +293,8 @@ nlmsvc_proc_lock_msg(struct svc_rqst *rq
 	memset(&res, 0, sizeof(res));
 
 	if ((stat = nlmsvc_proc_lock(rqstp, argp, &res)) == 0)
-		stat = nlmsvc_callback(rqstp, NLMPROC_LOCK_RES, &res);
+		stat = nlmsvc_callback(rqstp, NLMPROC_LOCK_RES, &res,
+				argp->lock.caller);
 	return stat;
 }
 
@@ -306,7 +309,8 @@ nlmsvc_proc_cancel_msg(struct svc_rqst *
 	memset(&res, 0, sizeof(res));
 
 	if ((stat = nlmsvc_proc_cancel(rqstp, argp, &res)) == 0)
-		stat = nlmsvc_callback(rqstp, NLMPROC_CANCEL_RES, &res);
+		stat = nlmsvc_callback(rqstp, NLMPROC_CANCEL_RES, &res,
+				argp->lock.caller);
 	return stat;
 }
 
@@ -321,7 +325,8 @@ nlmsvc_proc_unlock_msg(struct svc_rqst *
 	memset(&res, 0, sizeof(res));
 
 	if ((stat = nlmsvc_proc_unlock(rqstp, argp, &res)) == 0)
-		stat = nlmsvc_callback(rqstp, NLMPROC_UNLOCK_RES, &res);
+		stat = nlmsvc_callback(rqstp, NLMPROC_UNLOCK_RES, &res,
+				argp->lock.caller);
 	return stat;
 }
 
@@ -336,7 +341,8 @@ nlmsvc_proc_granted_msg(struct svc_rqst 
 	memset(&res, 0, sizeof(res));
 
 	if ((stat = nlmsvc_proc_granted(rqstp, argp, &res)) == 0)
-		stat = nlmsvc_callback(rqstp, NLMPROC_GRANTED_RES, &res);
+		stat = nlmsvc_callback(rqstp, NLMPROC_GRANTED_RES, &res,
+				argp->lock.caller);
 	return stat;
 }
 
@@ -445,9 +451,6 @@ nlmsvc_proc_sm_notify(struct svc_rqst *r
 					      void	        *resp)
 {
 	struct sockaddr_in	saddr = rqstp->rq_addr;
-	int			vers = argp->vers;
-	int			prot = argp->proto >> 1;
-	struct nlm_host		*host;
 
 	dprintk("lockd: SM_NOTIFY     called\n");
 	if (saddr.sin_addr.s_addr != htonl(INADDR_LOOPBACK)
@@ -459,23 +462,7 @@ nlmsvc_proc_sm_notify(struct svc_rqst *r
 		return rpc_system_err;
 	}
 
-	/* Obtain the host pointer for this NFS server and try to
-	 * reclaim all locks we hold on this server.
-	 */
-	saddr.sin_addr.s_addr = argp->addr;
-	if ((argp->proto & 1)==0) {
-		if ((host = nlmclnt_lookup_host(&saddr, prot, vers)) != NULL) {
-			nlmclnt_recovery(host, argp->state);
-			nlm_release_host(host);
-		}
-	} else {
-		/* If we run on an NFS server, delete all locks held by the client */
-		if ((host = nlm_lookup_host(1, &saddr, prot, vers)) != NULL) {
-			nlmsvc_free_host_resources(host);
-			nlm_release_host(host);
-		}
-	}
-
+	nlm_host_rebooted(&saddr, argp->mon, argp->state);
 	return rpc_success;
 }
 
@@ -499,7 +486,8 @@ nlmsvc_proc_granted_res(struct svc_rqst 
  * This is the generic lockd callback for async RPC calls
  */
 static u32
-nlmsvc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_res *resp)
+nlmsvc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_res *resp,
+		const char *hostname)
 {
 	struct nlm_host	*host;
 	struct nlm_rqst	*call;
@@ -508,7 +496,8 @@ nlmsvc_callback(struct svc_rqst *rqstp, 
 		return rpc_system_err;
 
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				NULL);
 	if (!host) {
 		kfree(call);
 		return rpc_system_err;
Index: linux-2.6.12/fs/lockd/svcsubs.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/svcsubs.c
+++ linux-2.6.12/fs/lockd/svcsubs.c
@@ -90,7 +90,7 @@ nlm_lookup_file(struct svc_rqst *rqstp, 
 	 * the file.
 	 */
 	if ((nfserr = nlmsvc_ops->fopen(rqstp, f, &file->f_file)) != 0) {
-		dprintk("lockd: open failed (nfserr %d)\n", ntohl(nfserr));
+		dprintk("lockd: open failed (error %d)\n", nfserr);
 		goto out_free;
 	}
 
@@ -287,10 +287,12 @@ nlmsvc_free_host_resources(struct nlm_ho
 {
 	dprintk("lockd: nlmsvc_free_host_resources\n");
 
-	if (nlm_traverse_files(host, NLM_ACT_UNLOCK))
+	if (nlm_traverse_files(host, NLM_ACT_UNLOCK)) {
 		printk(KERN_WARNING
-			"lockd: couldn't remove all locks held by %s",
+			"lockd: couldn't remove all locks held by %s\n",
 			host->h_name);
+		BUG();
+	}
 }
 
 /*
@@ -301,9 +303,20 @@ nlmsvc_invalidate_all(void)
 {
 	struct nlm_host *host;
 	while ((host = nlm_find_client()) != NULL) {
-		nlmsvc_free_host_resources(host);
 		host->h_expires = 0;
-		host->h_killed = 1;
+		nlmsvc_free_host_resources(host);
+		/* Do not unmonitor the host */
+		if (host->h_nsmhandle)
+			host->h_nsmhandle->sm_sticky = 1;
+		if (atomic_read(&host->h_count) != 1) {
+			/* Whatever is holding references to this host,
+			 * it seems likely we're going to leak memory
+			 * or worse */
+			printk(KERN_WARNING "lockd: host has reference count %u "
+				"after nlmsvc_free_host_resources!\n",
+				atomic_read(&host->h_count));
+
+		}
 		nlm_release_host(host);
 	}
 }
Index: linux-2.6.12/fs/lockd/xdr.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/xdr.c
+++ linux-2.6.12/fs/lockd/xdr.c
@@ -125,7 +125,7 @@ nlm_decode_lock(u32 *p, struct nlm_lock 
 	struct file_lock	*fl = &lock->fl;
 	s32			start, len, end;
 
-	if (!(p = xdr_decode_string_inplace(p, &lock->caller,
+	if (!(p = xdr_decode_string(p, &lock->caller,
 					    &lock->len,
 					    NLM_MAXSTRLEN))
 	 || !(p = nlm_decode_fh(p, &lock->fh))
@@ -301,7 +301,7 @@ nlmsvc_decode_shareargs(struct svc_rqst 
 	lock->fl.fl_pid = ~(u32) 0;
 
 	if (!(p = nlm_decode_cookie(p, &argp->cookie))
-	 || !(p = xdr_decode_string_inplace(p, &lock->caller,
+	 || !(p = xdr_decode_string(p, &lock->caller,
 					    &lock->len, NLM_MAXSTRLEN))
 	 || !(p = nlm_decode_fh(p, &lock->fh))
 	 || !(p = nlm_decode_oh(p, &lock->oh)))
@@ -335,7 +335,7 @@ nlmsvc_decode_notify(struct svc_rqst *rq
 {
 	struct nlm_lock	*lock = &argp->lock;
 
-	if (!(p = xdr_decode_string_inplace(p, &lock->caller,
+	if (!(p = xdr_decode_string(p, &lock->caller,
 					    &lock->len, NLM_MAXSTRLEN)))
 		return 0;
 	argp->state = ntohl(*p++);
@@ -345,7 +345,7 @@ nlmsvc_decode_notify(struct svc_rqst *rq
 int
 nlmsvc_decode_reboot(struct svc_rqst *rqstp, u32 *p, struct nlm_reboot *argp)
 {
-	if (!(p = xdr_decode_string_inplace(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))
+	if (!(p = xdr_decode_string(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))
 		return 0;
 	argp->state = ntohl(*p++);
 	/* Preserve the address in network byte order */
Index: linux-2.6.12/fs/lockd/xdr4.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/xdr4.c
+++ linux-2.6.12/fs/lockd/xdr4.c
@@ -125,7 +125,7 @@ nlm4_decode_lock(u32 *p, struct nlm_lock
 	struct file_lock	*fl = &lock->fl;
 	__s64			len, start, end;
 
-	if (!(p = xdr_decode_string_inplace(p, &lock->caller,
+	if (!(p = xdr_decode_string(p, &lock->caller,
 					    &lock->len, NLM_MAXSTRLEN))
 	 || !(p = nlm4_decode_fh(p, &lock->fh))
 	 || !(p = nlm4_decode_oh(p, &lock->oh)))
@@ -306,7 +306,7 @@ nlm4svc_decode_shareargs(struct svc_rqst
 	lock->fl.fl_pid = ~(u32) 0;
 
 	if (!(p = nlm4_decode_cookie(p, &argp->cookie))
-	 || !(p = xdr_decode_string_inplace(p, &lock->caller,
+	 || !(p = xdr_decode_string(p, &lock->caller,
 					    &lock->len, NLM_MAXSTRLEN))
 	 || !(p = nlm4_decode_fh(p, &lock->fh))
 	 || !(p = nlm4_decode_oh(p, &lock->oh)))
@@ -340,7 +340,7 @@ nlm4svc_decode_notify(struct svc_rqst *r
 {
 	struct nlm_lock	*lock = &argp->lock;
 
-	if (!(p = xdr_decode_string_inplace(p, &lock->caller,
+	if (!(p = xdr_decode_string(p, &lock->caller,
 					    &lock->len, NLM_MAXSTRLEN)))
 		return 0;
 	argp->state = ntohl(*p++);
@@ -350,7 +350,7 @@ nlm4svc_decode_notify(struct svc_rqst *r
 int
 nlm4svc_decode_reboot(struct svc_rqst *rqstp, u32 *p, struct nlm_reboot *argp)
 {
-	if (!(p = xdr_decode_string_inplace(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))
+	if (!(p = xdr_decode_string(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))
 		return 0;
 	argp->state = ntohl(*p++);
 	/* Preserve the address in network byte order */
Index: linux-2.6.12/include/linux/lockd/lockd.h
===================================================================
--- linux-2.6.12.orig/include/linux/lockd/lockd.h
+++ linux-2.6.12/include/linux/lockd/lockd.h
@@ -40,14 +40,12 @@ struct nlm_host {
 	struct nlm_host *	h_next;		/* linked list (hash table) */
 	struct sockaddr_in	h_addr;		/* peer address */
 	struct rpc_clnt	*	h_rpcclnt;	/* RPC client to talk to peer */
-	char			h_name[20];	/* remote hostname */
+	char *			h_name;		/* remote hostname */
 	u32			h_version;	/* interface version */
 	unsigned short		h_proto;	/* transport proto */
 	unsigned short		h_reclaiming : 1,
 				h_server     : 1, /* server side, not client side */
-				h_inuse      : 1,
-				h_killed     : 1,
-				h_monitored  : 1;
+				h_inuse      : 1;
 	wait_queue_head_t	h_gracewait;	/* wait while reclaiming */
 	u32			h_state;	/* pseudo-state counter */
 	u32			h_nsmstate;	/* true remote NSM state */
@@ -58,6 +56,19 @@ struct nlm_host {
 	unsigned long		h_expires;	/* eligible for GC */
 	struct list_head	h_lockowners;	/* Lockowners for the client */
 	spinlock_t		h_lock;
+	struct nsm_handle *	h_nsmhandle;	/* NSM status handle */
+};
+
+/*
+ * NSM handle - used to track status of monitored hosts
+ */
+struct nsm_handle {
+	struct list_head	sm_link;
+	atomic_t                sm_count;
+	char *			sm_name;
+	struct sockaddr_in      sm_addr;
+	unsigned int            sm_monitored : 1,
+				sm_sticky : 1;	/* don't unmonitor */
 };
 
 /*
@@ -140,6 +151,8 @@ extern struct svc_procedure	nlmsvc_proce
 #endif
 extern int			nlmsvc_grace_period;
 extern unsigned long		nlmsvc_timeout;
+extern int			nlm_max_hosts;
+extern int			nsm_use_hostnames;
 
 /*
  * Lockd client functions
@@ -158,15 +171,19 @@ void		  nlmclnt_freegrantargs(struct nlm
 /*
  * Host cache
  */
-struct nlm_host * nlmclnt_lookup_host(struct sockaddr_in *, int, int);
-struct nlm_host * nlmsvc_lookup_host(struct svc_rqst *);
-struct nlm_host * nlm_lookup_host(int server, struct sockaddr_in *, int, int);
+struct nlm_host * nlmclnt_lookup_host(struct sockaddr_in *, int, int, const char *);
+struct nlm_host * nlmsvc_lookup_host(struct svc_rqst *, const char *);
+struct nlm_host * nlm_lookup_host(int server, struct sockaddr_in *, int, int, const char *);
 struct rpc_clnt * nlm_bind_host(struct nlm_host *);
 void		  nlm_rebind_host(struct nlm_host *);
 struct nlm_host * nlm_get_host(struct nlm_host *);
 void		  nlm_release_host(struct nlm_host *);
 void		  nlm_shutdown_hosts(void);
 extern struct nlm_host *nlm_find_client(void);
+extern void	nlm_host_rebooted(const struct sockaddr_in *, const char *, u32);
+struct nsm_handle *nsm_find(const struct sockaddr_in *, const char *);
+void		nsm_release(struct nsm_handle *);
+
 
 
 /*
@@ -204,12 +221,23 @@ nlmsvc_file_inode(struct nlm_file *file)
  * Compare two host addresses (needs modifying for ipv6)
  */
 static __inline__ int
-nlm_cmp_addr(struct sockaddr_in *sin1, struct sockaddr_in *sin2)
+nlm_cmp_addr(const struct sockaddr_in *sin1, const struct sockaddr_in *sin2)
 {
 	return sin1->sin_addr.s_addr == sin2->sin_addr.s_addr;
 }
 
 /*
+ * Compare two host names
+ */
+static __inline__ int
+nlm_cmp_name(const char *name1, const char *name2)
+{
+	if (!name1 || !name2)
+		return name1 == name2;
+	return !strcmp(name1, name2);
+}
+
+/*
  * Compare two NLM locks.
  * When the second lock is of type F_UNLCK, this acts like a wildcard.
  */
Index: linux-2.6.12/include/linux/lockd/sm_inter.h
===================================================================
--- linux-2.6.12.orig/include/linux/lockd/sm_inter.h
+++ linux-2.6.12/include/linux/lockd/sm_inter.h
@@ -19,6 +19,7 @@
 #define SM_NOTIFY	6
 
 #define SM_MAXSTRLEN	1024
+#define SMSVC_XDRSIZE	(sizeof(struct nsm_args) + SM_MAXSTRLEN)
 
 /*
  * Arguments for all calls to statd
@@ -29,6 +30,9 @@ struct nsm_args {
 	u32		vers;
 	u32		proc;
 	u32		proto;		/* protocol (udp/tcp) plus server/client flag */
+
+	char *		mon_name;
+	u32		state;		/* in NOTIFY calls */
 };
 
 /*
@@ -39,8 +43,11 @@ struct nsm_res {
 	u32		state;
 };
 
-int		nsm_monitor(struct nlm_host *);
-int		nsm_unmonitor(struct nlm_host *);
+extern int	nsm_statd_upcalls_init(void);
+extern int	nsm_kernel_statd_init(void);
+extern int	(*nsm_monitor)(struct nlm_host *);
+extern int	(*nsm_unmonitor)(struct nlm_host *);
 extern u32	nsm_local_state;
+extern int	statd_authenticate(struct svc_rqst *);
 
 #endif /* LINUX_LOCKD_SM_INTER_H */
