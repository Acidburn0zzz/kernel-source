diff -purNa linux-2.6.3-evlog/include/linux/printkat.h linux-2.6.3/include/linux/printkat.h
--- linux-2.6.3-evlog/include/linux/printkat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.3/include/linux/printkat.h	2004-02-27 13:56:26.000000000 +0100
@@ -0,0 +1,98 @@
+/*
+ * Linux Event Logging for the Enterprise
+ * Copyright (C) International Business Machines Corp., 2002
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+
+#ifndef _LINUX_PRINTKAT_H
+#define _LINUX_PRINTKAT_H
+
+extern int __printkat(const char *facname, int call_printk,
+	const char *fmt, ...);
+
+#ifndef CONFIG_EVLOG
+
+/* Just strip {id} constructs and call printk. */
+#define printkat(fmt, arg...) __printkat((const char*)0, 1, fmt, ## arg)
+#define printkat_noprintk(fmt, arg...) do {} while(0)
+
+#else	/* CONFIG_EVLOG */
+
+#include <linux/stringify.h>
+#include <linux/kernel.h>
+#include <linux/evlog.h>
+
+/*
+ * Facility name defaults to the name of the module, as set in the kernel
+ * build, or to kern (the kernel default) if the module name is not set.
+ * Define EVL_FACILITY_NAME before including this file (or redefine it
+ * before calling printkat) if that's unsatisfactory.
+ *
+ * In a device driver, EVL_FACILITY_NAME should be the driver name (without
+ * quotes).
+ */
+#ifndef EVL_FACILITY_NAME
+#ifdef KBUILD_MODNAME
+#define EVL_FACILITY_NAME KBUILD_MODNAME
+#else
+#define EVL_FACILITY_NAME kern
+#endif
+#endif
+
+/* Bloat doesn't matter: this doesn't end up in vmlinux. */
+struct log_position {
+   int line;
+   char function[64 - sizeof(int)];
+   char file[128];
+};
+
+#define _LOG_POS { __LINE__, __FUNCTION__, __FILE__ }
+
+/*
+ * Information about a printkat() message.
+ * Again, bloat doesn't matter: this doesn't end up in vmlinux.
+ * Note that, because of default alignment in the .log section,
+ * sizeof(struct log_info) should be a multiple of 32.
+ */
+struct log_info {
+   char format[128+64];
+   char facility[64];
+   struct log_position pos;
+};
+
+#define printkat(fmt, arg...) \
+({ \
+   static struct log_info __attribute__((section(".log"),unused)) ___ \
+      = { fmt, __stringify(EVL_FACILITY_NAME), _LOG_POS }; \
+   __printkat(__stringify(EVL_FACILITY_NAME) , 1, fmt , ## arg); \
+})
+
+/* Same as printkat, but don't call printk. */
+#define printkat_noprintk(fmt, arg...) \
+({ \
+   static struct log_info __attribute__((section(".log"),unused)) ___ \
+      = { fmt, __stringify(EVL_FACILITY_NAME), _LOG_POS }; \
+   __printkat(__stringify(EVL_FACILITY_NAME) , 0, fmt , ## arg); \
+})
+
+#endif /* CONFIG_EVLOG */
+
+#endif /*_LINUX_PRINTKAT_H*/
diff -purNa linux-2.6.3-evlog/kernel/evlapi.c linux-2.6.3/kernel/evlapi.c
--- linux-2.6.3-evlog/kernel/evlapi.c	2004-02-27 13:55:01.000000000 +0100
+++ linux-2.6.3/kernel/evlapi.c	2004-02-27 13:56:26.000000000 +0100
@@ -35,6 +35,7 @@ extern void evl_mk_rechdr(struct kern_lo
 	const char *facility, int event_type, int severity, size_t size,
 	uint flags, int format);
 extern int evl_writeh(struct kern_log_entry *hdr, const char *vardata);
+extern void evl_unbrace(char *dest, const char *src, int bufsz);
 
 /**
  * evl_write() - write header + optional buffer to event handler
@@ -419,6 +420,80 @@ evl_printk(const char *facility, int eve
 	return ret;
 }
 
+/*** printkat support ***/
+
+static int
+try_extract_severity(const char *msg)
+{
+	if (msg[0] == '<'
+	    && msg[1] >= '0' && msg[1] <= '7'
+	    && msg[2] == '>') {
+		return msg[1] - '0';
+	}
+	return -1;
+}
+
+static int
+extract_severity(const char *fmt, va_list args)
+{
+	int sev = try_extract_severity(fmt);
+	if (sev == -1 && (fmt[0] == '<' || fmt[0] == '%')) {
+		/* Handle stuff like "<%d>..." and "%s..." */
+		char prefix[4];
+		(void) vsnprintf(prefix, 4, fmt, args);
+		sev = try_extract_severity(prefix);
+	}
+	return sev;
+}
+
+/**
+ * evl_printkat() - Log a PRINTF-format record, stripping attribute names.
+ * @facility: facility name (e.g., "kern", driver name)
+ * @buf, @buflen: a scratch buffer in which we construct the record
+ * @fmt: format string, possibly including severity-level prefix.
+ *	Any attribute names in curly braces will be stripped out by
+ *	evl_unbrace().
+ * other args as per printk()
+ * 
+ * On return, buf contains the format string, purged of {id} constructs
+ * and the "{{" trailer, if any.
+ */
+int
+evl_printkat(const char *facility, char *buf, size_t buflen, const char *fmt,
+	va_list args)
+{
+	int ret;
+	int severity;
+	struct evl_recbuf b;
+	struct kern_log_entry hdr;
+
+	evl_init_recbuf(&b, buf, buflen);
+	evl_unbrace(b.b_buf, fmt, (int) buflen);
+	b.b_tail = b.b_buf + strlen(b.b_buf) + 1;
+	evl_zap_newline(&b);
+	evl_end_fmt(&b);
+
+	evl_pack_args(&b, fmt, args);
+	evl_end_args(&b);
+
+	severity = extract_severity(b.b_buf, args);
+	if (severity < 0) {
+		/* See kernel.h and printk.c */
+		severity = default_message_loglevel;
+	}
+
+	evl_mk_rechdr(&hdr, facility, 0, severity, b.b_tail - b.b_buf,
+		EVL_EVTYCRC, EVL_PRINTF);
+	/* Note: If size > EVL_ENTRY_MAXLEN, evl_writeh() will handle it. */
+	
+	ret = evl_writeh(&hdr, b.b_buf);
+
+	/* Put the newline back in case caller calls printk(). */
+	evl_unzap_newline(&b);
+	return ret;
+}
+
 EXPORT_SYMBOL(evl_write);
 EXPORT_SYMBOL(evl_printk);
 EXPORT_SYMBOL(evl_vprintk);
+EXPORT_SYMBOL(evl_printkat);
diff -purNa linux-2.6.3-evlog/kernel/printk.c linux-2.6.3/kernel/printk.c
--- linux-2.6.3-evlog/kernel/printk.c	2004-02-27 13:55:01.000000000 +0100
+++ linux-2.6.3/kernel/printk.c	2004-02-27 14:21:22.000000000 +0100
@@ -30,8 +30,18 @@
 #include <linux/smp.h>
 #include <linux/security.h>
 #include <linux/bootmem.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
 
 #include <asm/uaccess.h>
+#ifdef CONFIG_EVLOG
+#include <linux/evlog.h>
+extern int evl_printkat(const char *facname, char *buf, size_t buflen,
+	const char *fmt, va_list args);
+#define PRINTKAT_BUFLEN EVL_ENTRY_MAXLEN
+#else
+#define PRINTKAT_BUFLEN 512
+#endif
 
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
@@ -516,9 +526,20 @@ static void emit_log_char(char c)
  * then changes console_loglevel may break. This is because console_loglevel
  * is inspected when the actual printing occurs.
  */
+int vprintk(const char *fmt, va_list args);
+
 asmlinkage int printk(const char *fmt, ...)
 {
+	int status;
 	va_list args;
+	va_start(args, fmt);
+	status = vprintk(fmt, args);
+	va_end(args);
+	return status;
+}
+
+int vprintk(const char *fmt, va_list args)
+{
 	unsigned long flags;
 	int printed_len;
 	char *p;
@@ -536,9 +557,7 @@ asmlinkage int printk(const char *fmt, .
 	spin_lock_irqsave(&logbuf_lock, flags);
 
 	/* Emit the output into the temporary buffer */
-	va_start(args, fmt);
 	printed_len = vscnprintf(printk_buf, sizeof(printk_buf), fmt, args);
-	va_end(args);
 
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
@@ -989,3 +1008,108 @@ void early_printk(const char *str, size_
 }
 
 #endif /* CONFIG_IA64_EARLY_PRINTK */
+
+
+/*
+ * Event logging: printk wrapper that strips {foo}% tags from the
+ * format string.
+ */
+static char printkat_buf[PRINTKAT_BUFLEN];
+static spinlock_t printkat_lock = SPIN_LOCK_UNLOCKED;
+
+/*
+ * Copy src to dest, replacing strings of the form "{id}%" with "%".
+ * If src contains "{{", strip out that and anything beyond it.
+ * dest is a buffer of size bufsz.  Make sure we don't overflow it.
+ */
+void evl_unbrace(char *dest, const char *src, int bufsz)
+{
+	const char *copy_this = src, *scan_this = src;
+	const char *c, *lcb, *rcb, *cut_here;
+	int copy_len, dlen = 0;
+
+	cut_here = strstr(src, "{{");
+	dest[0] = '\0';
+	for (;;) {
+		lcb = strchr(scan_this, '{');
+		if (!lcb) {
+			goto done;
+		}
+		rcb = strstr(lcb+2, "}%");
+		if (!rcb) {
+			goto done;
+		}
+		if (cut_here && cut_here < rcb) {
+			goto done;
+		}
+		/* Is it a valid identifier between the { and } ? */
+		c = lcb+1;
+		if (*c != '_' && !isalpha(*c)) {
+			goto scan_again;
+		}
+		for (c++; c < rcb; c++) {
+			if (*c != '_' && !isalnum(*c)) {
+				goto scan_again;
+			}
+		}
+		copy_len = min(lcb - copy_this, bufsz-(dlen+1));
+		strncat(dest + dlen, copy_this, copy_len);
+		dlen += copy_len;
+		copy_this = rcb+1;
+scan_again:
+		scan_this = rcb+2;
+	}
+done:
+	if (cut_here) {
+		copy_len = min(cut_here - copy_this, bufsz-(dlen+1));
+	} else {
+		copy_len = bufsz-(dlen+1);
+	}
+	strncat(dest + dlen, copy_this, copy_len);
+	return;
+}
+
+/**
+ * printkat - Log message to printk and/or evlog, stripping {id}s.
+ * @facname: facility name (e.g., driver name) for evlog event
+ * @call_printk: 0 -> don't call printk
+ * fmt and subsequent args are as with printk.  Log the message to printk
+ * (via vprintk), and (if EVLOG is configured) also to evlog as an
+ * EVL_PRINTF-format record.  Strip {id}s from the message, and also
+ * anything following "{{".
+ */
+/*ARGSUSED*/
+int __printkat(const char *facname, int call_printk,  const char *fmt, ...)
+{
+	int status;
+	unsigned long flags;
+	va_list args;
+
+	va_start(args, fmt);
+#ifdef CONFIG_EVLOG
+	spin_lock_irqsave(&printkat_lock, flags);
+	status = evl_printkat(facname, printkat_buf, PRINTKAT_BUFLEN, fmt,
+		args);
+	if (call_printk) {
+		(void) vprintk(printkat_buf, args);
+	}
+	spin_unlock_irqrestore(&printkat_lock, flags);
+#else
+	/* EVLOG disabled.  Just call printk, stripping {id}s as needed. */
+	if (!call_printk) {
+		return 0;
+	}
+	if (strstr(fmt, "}%") || strstr(fmt, "{{")) {
+		spin_lock_irqsave(&printkat_lock, flags);
+		evl_unbrace(printkat_buf, fmt, PRINTKAT_BUFLEN);
+		status = vprintk(printkat_buf, args);
+		spin_unlock_irqrestore(&printkat_lock, flags);
+	} else {
+		status = vprintk(fmt, args);
+	}
+#endif
+	va_end(args);
+
+	return status;
+}
+EXPORT_SYMBOL(__printkat);
