From Jeff Mahoney

Add device info to the various reiserfs warnings and panics so you can tell
which filesystem triggers the message.  Loosely based on code from Oleg
Drokin.

diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/bitmap.c linux-2.6.4.warnings/fs/reiserfs/bitmap.c
--- linux-2.6.4/fs/reiserfs/bitmap.c	2004-03-29 10:42:49.536830323 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/bitmap.c	2004-03-29 11:08:57.999359806 -0500
@@ -37,7 +37,7 @@
 
 #define SET_OPTION(optname) \
    do { \
-        reiserfs_warning("reiserfs: option \"%s\" is set\n", #optname); \
+        reiserfs_warning(s, "reiserfs: option \"%s\" is set", #optname); \
         set_bit(_ALLOC_ ## optname , &SB_ALLOC_OPTS(s)); \
     } while(0)
 #define TEST_OPTION(optname, s) \
@@ -60,7 +60,7 @@ int is_reusable (struct super_block * s,
     int i, j;
 
     if (block == 0 || block >= SB_BLOCK_COUNT (s)) {
-	reiserfs_warning ("vs-4010: is_reusable: block number is out of range %lu (%u)\n",
+	reiserfs_warning (s, "vs-4010: is_reusable: block number is out of range %lu (%u)",
 			  block, SB_BLOCK_COUNT (s));
 	return 0;
     }
@@ -68,8 +68,8 @@ int is_reusable (struct super_block * s,
     /* it can't be one of the bitmap blocks */
     for (i = 0; i < SB_BMAP_NR (s); i ++)
 	if (block == SB_AP_BITMAP (s)[i].bh->b_blocknr) {
-	    reiserfs_warning ("vs: 4020: is_reusable: "
-			      "bitmap block %lu(%u) can't be freed or reused\n",
+	    reiserfs_warning (s, "vs: 4020: is_reusable: "
+			      "bitmap block %lu(%u) can't be freed or reused",
 			      block, SB_BMAP_NR (s));
 	    return 0;
 	}
@@ -77,8 +77,8 @@ int is_reusable (struct super_block * s,
     get_bit_address (s, block, &i, &j);
 
     if (i >= SB_BMAP_NR (s)) {
-	reiserfs_warning ("vs-4030: is_reusable: there is no so many bitmap blocks: "
-			  "block=%lu, bitmap_nr=%d\n", block, i);
+	reiserfs_warning (s, "vs-4030: is_reusable: there is no so many bitmap blocks: "
+			  "block=%lu, bitmap_nr=%d", block, i);
 	return 0;
     }
 
@@ -86,16 +86,16 @@ int is_reusable (struct super_block * s,
          reiserfs_test_le_bit(j, SB_AP_BITMAP(s)[i].bh->b_data)) ||
 	(bit_value == 1 && 
 	 reiserfs_test_le_bit(j, SB_AP_BITMAP (s)[i].bh->b_data) == 0)) {
-	reiserfs_warning ("vs-4040: is_reusable: corresponding bit of block %lu does not "
-			  "match required value (i==%d, j==%d) test_bit==%d\n",
+	reiserfs_warning (s, "vs-4040: is_reusable: corresponding bit of block %lu does not "
+			  "match required value (i==%d, j==%d) test_bit==%d",
 		block, i, j, reiserfs_test_le_bit (j, SB_AP_BITMAP (s)[i].bh->b_data));
 
 	return 0;
     }
 
     if (bit_value == 0 && block == SB_ROOT_BLOCK (s)) {
-	reiserfs_warning ("vs-4050: is_reusable: this is root block (%u), "
-			  "it must be busy\n", SB_ROOT_BLOCK (s));
+	reiserfs_warning (s, "vs-4050: is_reusable: this is root block (%u), "
+			  "it must be busy", SB_ROOT_BLOCK (s));
 	return 0;
     }
 
@@ -134,7 +134,7 @@ static int scan_bitmap_block (struct rei
     int end, next;
     int org = *beg;
 
-    RFALSE(bmap_n >= SB_BMAP_NR (s), "Bitmap %d is out of range (0..%d)\n",bmap_n, SB_BMAP_NR (s) - 1);
+    RFALSE(bmap_n >= SB_BMAP_NR (s), "Bitmap %d is out of range (0..%d)",bmap_n, SB_BMAP_NR (s) - 1);
     PROC_INFO_INC( s, scan_bitmap.bmap );
 /* this is unclear and lacks comments, explain how journal bitmaps
    work here for the reader.  Convey a sense of the design here. What
@@ -142,7 +142,7 @@ static int scan_bitmap_block (struct rei
 /* - I mean `a window of zero bits' as in description of this function - Zam. */
   
     if ( !bi ) {
-	printk("Hey, bitmap info pointer is zero for bitmap %d!\n",bmap_n);
+	reiserfs_warning (s, "NULL bitmap info pointer for bitmap %d", bmap_n);
 	return 0;
     }
     if (buffer_locked (bi->bh)) {
@@ -300,8 +300,8 @@ static void _reiserfs_free_block (struct
     get_bit_address (s, block, &nr, &offset);
 
     if (nr >= sb_bmap_nr (rs)) {
-	reiserfs_warning ("vs-4075: reiserfs_free_block: "
-			  "block %lu is out of range on %s\n", 
+	reiserfs_warning (s, "vs-4075: reiserfs_free_block: "
+			  "block %lu is out of range on %s", 
 			  block, reiserfs_bdevname (s));
 	return;
     }
@@ -310,8 +310,8 @@ static void _reiserfs_free_block (struct
 
     /* clear bit for the given block in bit map */
     if (!reiserfs_test_and_clear_le_bit (offset, apbi[nr].bh->b_data)) {
-	reiserfs_warning ("vs-4080: reiserfs_free_block: "
-			  "free_block (%s:%lu)[dev:blocknr]: bit already cleared\n", 
+	reiserfs_warning (s, "vs-4080: reiserfs_free_block: "
+			  "free_block (%s:%lu)[dev:blocknr]: bit already cleared", 
 			  reiserfs_bdevname (s), block);
     }
     if (offset < apbi[nr].first_zero_hint) {
@@ -358,7 +358,7 @@ static void __discard_prealloc (struct r
     struct inode *inode = &ei->vfs_inode;
 #ifdef CONFIG_REISERFS_CHECK
     if (ei->i_prealloc_count < 0)
-	reiserfs_warning("zam-4001:%s: inode has negative prealloc blocks count.\n", __FUNCTION__ );
+	reiserfs_warning (th->t_super, "zam-4001:%s: inode has negative prealloc blocks count.", __FUNCTION__ );
 #endif
     while (ei->i_prealloc_count > 0) {
 	reiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);
@@ -390,7 +390,7 @@ void reiserfs_discard_all_prealloc (stru
 	ei = list_entry(plist->next, struct reiserfs_inode_info, i_prealloc_list);
 #ifdef CONFIG_REISERFS_CHECK
 	if (!ei->i_prealloc_count) {
-	    reiserfs_warning("zam-4001:%s: inode is in prealloc list but has no preallocated blocks.\n", __FUNCTION__);
+	    reiserfs_warning (th->t_super, "zam-4001:%s: inode is in prealloc list but has no preallocated blocks.", __FUNCTION__);
 	}
 #endif
 	__discard_prealloc(th, ei);
@@ -476,7 +476,8 @@ int reiserfs_parse_alloc_options(struct 
 	    continue;
 	}
 
-	reiserfs_warning("zam-4001: %s : unknown option - %s\n", __FUNCTION__ , this_char);
+	reiserfs_warning (s, "zam-4001: %s : unknown option - %s",
+			  __FUNCTION__ , this_char);
 	return 1;
       }
   
@@ -516,7 +517,7 @@ static inline void get_left_neighbor(rei
 
     path = hint->path;
     bh = get_last_bh(path);
-    RFALSE( !bh, "green-4002: Illegal path specified to get_left_neighbor\n");
+    RFALSE( !bh, "green-4002: Illegal path specified to get_left_neighbor");
     ih = get_ih(path);
     pos_in_item = path->pos_in_item;
     item = get_item (path);
@@ -783,14 +784,14 @@ static inline int blocknrs_and_prealloc_
     if (!hint->formatted_node) {
         int quota_ret;
 #ifdef REISERQUOTA_DEBUG
-	printk(KERN_DEBUG "reiserquota: allocating %d blocks id=%u\n", amount_needed, hint->inode->i_uid);
+	reiserfs_debug (s, "reiserquota: allocating %d blocks id=%u", amount_needed, hint->inode->i_uid);
 #endif
 	quota_ret = DQUOT_ALLOC_BLOCK_NODIRTY(hint->inode, amount_needed);
 	if (quota_ret)    /* Quota exceeded? */
 	    return QUOTA_EXCEEDED;
 	if (hint->preallocate && hint->prealloc_size ) {
 #ifdef REISERQUOTA_DEBUG
-	    printk(KERN_DEBUG "reiserquota: allocating (prealloc) %d blocks id=%u\n", hint->prealloc_size, hint->inode->i_uid);
+	    reiserfs_debug (s, "reiserquota: allocating (prealloc) %d blocks id=%u", hint->prealloc_size, hint->inode->i_uid);
 #endif
 	    quota_ret = DQUOT_PREALLOC_BLOCK_NODIRTY(hint->inode, hint->prealloc_size);
 	    if (quota_ret)
@@ -807,7 +808,7 @@ static inline int blocknrs_and_prealloc_
 	if (second_pass) {	/* it was a second pass; we must free all blocks */
 	    if (!hint->formatted_node) {
 #ifdef REISERQUOTA_DEBUG
-		printk(KERN_DEBUG "reiserquota: freeing (nospace) %d blocks id=%u\n", amount_needed + hint->prealloc_size - nr_allocated, hint->inode->i_uid);
+		reiserfs_debug (s, "reiserquota: freeing (nospace) %d blocks id=%u", amount_needed + hint->prealloc_size - nr_allocated, hint->inode->i_uid);
 #endif
 		DQUOT_FREE_BLOCK_NODIRTY(hint->inode, amount_needed + hint->prealloc_size - nr_allocated);     /* Free not allocated blocks */
 	    }
@@ -827,7 +828,7 @@ static inline int blocknrs_and_prealloc_
 	 nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {
     /* Some of preallocation blocks were not allocated */
 #ifdef REISERQUOTA_DEBUG
-	printk(KERN_DEBUG "reiserquota: freeing (failed prealloc) %d blocks id=%u\n", amount_needed + hint->prealloc_size - nr_allocated - INODE_INFO(hint->inode)->i_prealloc_count, hint->inode->i_uid);
+	reiserfs_debug (s, "reiserquota: freeing (failed prealloc) %d blocks id=%u", amount_needed + hint->prealloc_size - nr_allocated - INODE_INFO(hint->inode)->i_prealloc_count, hint->inode->i_uid);
 #endif
 	DQUOT_FREE_BLOCK_NODIRTY(hint->inode, amount_needed + 
 	                         hint->prealloc_size - nr_allocated - 
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/dir.c linux-2.6.4.warnings/fs/reiserfs/dir.c
--- linux-2.6.4/fs/reiserfs/dir.c	2004-03-29 10:42:49.435848775 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/dir.c	2004-03-29 10:43:44.834726370 -0500
@@ -54,7 +54,7 @@ static int reiserfs_readdir (struct file
 
     reiserfs_write_lock(inode->i_sb);
 
-    reiserfs_check_lock_depth("readdir") ;
+    reiserfs_check_lock_depth(inode->i_sb, "readdir") ;
 
     /* form key for search the next directory entry using f_pos field of
        file structure */
@@ -62,7 +62,7 @@ static int reiserfs_readdir (struct file
 		  TYPE_DIRENTRY, 3);
     next_pos = cpu_key_k_offset (&pos_key);
 
-    /*  reiserfs_warning ("reiserfs_readdir 1: f_pos = %Ld\n", filp->f_pos);*/
+    /*  reiserfs_warning (inode->i_sb, "reiserfs_readdir 1: f_pos = %Ld", filp->f_pos);*/
 
     while (1) {
     research:
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/do_balan.c linux-2.6.4.warnings/fs/reiserfs/do_balan.c
--- linux-2.6.4/fs/reiserfs/do_balan.c	2004-03-29 10:42:49.546828496 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/do_balan.c	2004-03-29 11:09:52.667381212 -0500
@@ -83,7 +83,7 @@ static int balance_leaf_when_delete (str
     struct item_head * ih;
 
     RFALSE( tb->FR[0] && B_LEVEL (tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,
-	    "vs- 12000: level: wrong FR %z\n", tb->FR[0]);
+	    "vs- 12000: level: wrong FR %z", tb->FR[0]);
     RFALSE( tb->blknum[0] > 1,
 	    "PAP-12005: tb->blknum == %d, can not be > 1", tb->blknum[0]);
     RFALSE( ! tb->blknum[0] && ! PATH_H_PPARENT(tb->tb_path, 0),
@@ -1056,7 +1056,7 @@ static int balance_leaf (struct tree_bal
 
 	RFALSE (!buffer_journaled (S_new [i]) || buffer_journal_dirty (S_new [i]) ||
 		buffer_dirty (S_new [i]),
-		"PAP-12247: S_new[%d] : (%b)\n", i, S_new[i]);
+		"PAP-12247: S_new[%d] : (%b)", i, S_new[i]);
     }
 
     /* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
@@ -1215,14 +1215,14 @@ static void store_thrown (struct tree_ba
     int i;
 
     if (buffer_dirty (bh))
-      printk ("store_thrown deals with dirty buffer\n");
+      reiserfs_warning (tb->tb_sb, "store_thrown deals with dirty buffer");
     for (i = 0; i < sizeof (tb->thrown)/sizeof (tb->thrown[0]); i ++)
 	if (!tb->thrown[i]) {
 	    tb->thrown[i] = bh;
 	    get_bh(bh) ; /* free_thrown puts this */
 	    return;
 	}
-    reiserfs_warning ("store_thrown: too many thrown buffers\n");
+    reiserfs_warning (tb->tb_sb, "store_thrown: too many thrown buffers");
 }
 
 static void free_thrown(struct tree_balance *tb) {
@@ -1232,7 +1232,9 @@ static void free_thrown(struct tree_bala
 	if (tb->thrown[i]) {
 	    blocknr = tb->thrown[i]->b_blocknr ;
 	    if (buffer_dirty (tb->thrown[i]))
-	      printk ("free_thrown deals with dirty buffer %d\n", blocknr);
+	      reiserfs_warning (tb->tb_sb,
+				"free_thrown deals with dirty buffer %d",
+				blocknr);
 	    brelse(tb->thrown[i]) ; /* incremented in store_thrown */
 	    reiserfs_free_block (tb->transaction_handle, NULL, blocknr, 0);
 	}
@@ -1340,7 +1342,8 @@ static void check_internal_node (struct 
 static int locked_or_not_in_tree (struct buffer_head * bh, char * which)
 {
   if ( buffer_locked (bh) || !B_IS_IN_TREE (bh) ) {
-    reiserfs_warning ("vs-12339: locked_or_not_in_tree: %s (%b)\n", which, bh);
+    reiserfs_warning (NULL, "vs-12339: locked_or_not_in_tree: %s (%b)",
+                      which, bh);
     return 1;
   } 
   return 0;
@@ -1404,9 +1407,9 @@ void check_after_balance_leaf (struct tr
 		    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1),
 			PATH_H_POSITION (tb->tb_path, 1))));
 	print_cur_tb ("12223");
-	reiserfs_warning(
+	reiserfs_warning (tb->tb_sb,
 	    "B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "
-    	    "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d\n",
+    	    "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",
 	    left,
 	    MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)),
 	    PATH_H_PBUFFER(tb->tb_path,1),
@@ -1563,7 +1566,8 @@ void do_balance (struct tree_balance * t
     }
     /* if we have no real work to do  */
     if ( ! tb->insert_size[0] ) {
-	reiserfs_warning ("PAP-12350: do_balance: insert_size == 0, mode == %c",
+	reiserfs_warning (tb->tb_sb,
+			  "PAP-12350: do_balance: insert_size == 0, mode == %c",
 			  flag);
 	unfix_nodes(tb);
 	return;
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/file.c linux-2.6.4.warnings/fs/reiserfs/file.c
--- linux-2.6.4/fs/reiserfs/file.c	2004-03-29 10:42:58.196248028 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/file.c	2004-03-29 11:10:35.513560955 -0500
@@ -298,8 +298,9 @@ int reiserfs_allocate_blocks_for_region(
 		    if ( res != ITEM_NOT_FOUND ) {
 			/* item should not exist, otherwise we have error */
 			if ( res != -ENOSPC ) {
-			    reiserfs_warning ("green-9008: search_by_key (%K) returned %d\n",
-					       &key, res);
+			    reiserfs_warning (inode->i_sb, 
+				"green-9008: search_by_key (%K) returned %d",
+					      &key, res);
 			}
 			res = -EIO;
 		        kfree(zeros);
@@ -446,8 +447,9 @@ retry:
 		/* Well, if we have found such item already, or some error
 		   occured, we need to warn user and return error */
 		if ( res != -ENOSPC ) {
-		    reiserfs_warning ("green-9009: search_by_key (%K) returned %d\n",
-			              &key, res);
+		    reiserfs_warning (inode->i_sb,
+				      "green-9009: search_by_key (%K) "
+				      "returned %d", &key, res);
 		}
 		res = -EIO;
 		goto error_exit_free_blocks;
@@ -799,7 +801,9 @@ int reiserfs_prepare_file_region_for_wri
 
 
     if ( num_pages < 1 ) {
-	reiserfs_warning("green-9001: reiserfs_prepare_file_region_for_write called with zero number of pages to process\n");
+	reiserfs_warning (inode->i_sb,
+			  "green-9001: reiserfs_prepare_file_region_for_write "
+			  "called with zero number of pages to process");
 	return -EFAULT;
     }
 
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/fix_node.c linux-2.6.4.warnings/fs/reiserfs/fix_node.c
--- linux-2.6.4/fs/reiserfs/fix_node.c	2004-03-29 10:42:49.543829044 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/fix_node.c	2004-03-29 10:48:45.918727739 -0500
@@ -483,7 +483,8 @@ static int get_num_ver (int mode, struct
 	snum012[needed_nodes - 1 + 3] = units;
 
 	if (needed_nodes > 2)
-	    reiserfs_warning ("vs-8111: get_num_ver: split_item_position is out of boundary\n");
+	    reiserfs_warning (tb->tb_sb, "vs-8111: get_num_ver: "
+			      "split_item_position is out of boundary");
 	snum012[needed_nodes - 1] ++;
 	split_item_positions[needed_nodes - 1] = i;
 	needed_nodes ++;
@@ -510,7 +511,8 @@ static int get_num_ver (int mode, struct
 	snum012[4] = op_unit_num (&vn->vn_vi[split_item_num]) - snum012[4] - bytes_to_r - bytes_to_l - bytes_to_S1new;
 
 	if (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY)
-	    reiserfs_warning ("vs-8115: get_num_ver: not directory item\n");
+	    reiserfs_warning (tb->tb_sb, "vs-8115: get_num_ver: not "
+			      "directory item");
     }
 
     /* now we know S2bytes, calculate S1bytes */
@@ -1974,11 +1976,12 @@ void * reiserfs_kmalloc (size_t size, in
     if (vp) {
 	REISERFS_SB(s)->s_kmallocs += size;
 	if (REISERFS_SB(s)->s_kmallocs > malloced + 200000) {
-	    reiserfs_warning ("vs-8301: reiserfs_kmalloc: allocated memory %d\n", REISERFS_SB(s)->s_kmallocs);
+	    reiserfs_warning (s,
+			      "vs-8301: reiserfs_kmalloc: allocated memory %d",
+			      REISERFS_SB(s)->s_kmallocs);
 	    malloced = REISERFS_SB(s)->s_kmallocs;
 	}
     }
-/*printk ("malloc : size %d, allocated %d\n", size, REISERFS_SB(s)->s_kmallocs);*/
     return vp;
 }
 
@@ -1988,7 +1991,8 @@ void reiserfs_kfree (const void * vp, si
   
     REISERFS_SB(s)->s_kmallocs -= size;
     if (REISERFS_SB(s)->s_kmallocs < 0)
-	reiserfs_warning ("vs-8302: reiserfs_kfree: allocated memory %d\n", REISERFS_SB(s)->s_kmallocs);
+	reiserfs_warning (s, "vs-8302: reiserfs_kfree: allocated memory %d",
+			  REISERFS_SB(s)->s_kmallocs);
 
 }
 #endif
@@ -2048,8 +2052,9 @@ static int get_mem_for_virtual_node (str
 	    buf = reiserfs_kmalloc(size, GFP_NOFS, tb->tb_sb);
 	    if ( !buf ) {
 #ifdef CONFIG_REISERFS_CHECK
-		reiserfs_warning ("vs-8345: get_mem_for_virtual_node: "
-				  "kmalloc failed. reiserfs kmalloced %d bytes\n",
+		reiserfs_warning (tb->tb_sb,
+				  "vs-8345: get_mem_for_virtual_node: "
+				  "kmalloc failed. reiserfs kmalloced %d bytes",
 				  REISERFS_SB(tb->tb_sb)->s_kmallocs);
 #endif
 		tb->vn_buf_size = 0;
@@ -2211,7 +2216,10 @@ static int wait_tb_buffers_until_unlocke
 #ifdef CONFIG_REISERFS_CHECK
 	    repeat_counter++;
 	    if ( (repeat_counter % 10000) == 0) {
-		reiserfs_warning ("wait_tb_buffers_until_released(): too many iterations waiting for buffer to unlock (%b)\n", locked);
+		reiserfs_warning (p_s_tb->tb_sb,
+				  "wait_tb_buffers_until_released(): too many "
+				  "iterations waiting for buffer to unlock "
+				  "(%b)", locked);
 
 		/* Don't loop forever.  Try to recover from possible error. */
 
@@ -2324,8 +2332,7 @@ int fix_nodes (int n_op_mode,
     case M_CUT:
 	if ( n_item_num < 0 || n_item_num >= B_NR_ITEMS(p_s_tbS0) ) {
 	    print_block (p_s_tbS0, 0, -1, -1);
-	    printk("mode = %c insert_size = %d\n", n_op_mode, p_s_tb->insert_size[0]);
-	    reiserfs_panic(p_s_tb->tb_sb,"PAP-8335: fix_nodes: Incorrect item number(%d)", n_item_num);
+	    reiserfs_panic(p_s_tb->tb_sb,"PAP-8335: fix_nodes: Incorrect item number(%d); mode = %c insert_size = %d\n", n_item_num, n_op_mode, p_s_tb->insert_size[0]);
 	}
 	break;
     default:
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/inode.c linux-2.6.4.warnings/fs/reiserfs/inode.c
--- linux-2.6.4/fs/reiserfs/inode.c	2004-03-29 10:42:57.681342114 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/inode.c	2004-03-29 10:51:35.870693557 -0500
@@ -774,7 +774,7 @@ start_trans:
 		retval = convert_tail_for_hole(inode, bh_result, tail_offset) ;
 		if (retval) {
 		    if ( retval != -ENOSPC )
-			printk("clm-6004: convert tail failed inode %lu, error %d\n", inode->i_ino, retval) ;
+			reiserfs_warning (inode->i_sb, "clm-6004: convert tail failed inode %lu, error %d", inode->i_ino, retval) ;
 		    if (allocated_block_nr) {
 			/* the bitmap, the super, and the stat data == 3 */
 			if (!th)
@@ -911,8 +911,8 @@ start_trans:
 	    goto failure;
 	}
 	if (retval == POSITION_FOUND) {
-	    reiserfs_warning ("vs-825: reiserfs_get_block: "
-			      "%K should not be found\n", &key);
+	    reiserfs_warning (inode->i_sb, "vs-825: reiserfs_get_block: "
+			      "%K should not be found", &key);
 	    retval = -EEXIST;
 	    if (allocated_block_nr)
 	        reiserfs_free_block (th, inode, allocated_block_nr, 1);
@@ -1221,7 +1221,7 @@ void reiserfs_update_sd_size (struct rei
 	/* look for the object's stat data */
 	retval = search_item (inode->i_sb, &key, &path);
 	if (retval == IO_ERROR) {
-	    reiserfs_warning ("vs-13050: reiserfs_update_sd: "
+	    reiserfs_warning (inode->i_sb, "vs-13050: reiserfs_update_sd: "
 			      "i/o failure occurred trying to update %K stat data",
 			      &key);
 	    return;
@@ -1230,11 +1230,11 @@ void reiserfs_update_sd_size (struct rei
 	    pos = PATH_LAST_POSITION (&path);
 	    pathrelse(&path) ;
 	    if (inode->i_nlink == 0) {
-		/*printk ("vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found\n");*/
+		/*reiserfs_warning (inode->i_sb, "vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found");*/
 		return;
 	    }
-	    reiserfs_warning ("vs-13060: reiserfs_update_sd: "
-			      "stat data of object %k (nlink == %d) not found (pos %d)\n", 
+	    reiserfs_warning (inode->i_sb, "vs-13060: reiserfs_update_sd: "
+			      "stat data of object %k (nlink == %d) not found (pos %d)", 
 			      INODE_PKEY (inode), inode->i_nlink, pos);
 	    reiserfs_check_path(&path) ;
 	    return;
@@ -1307,9 +1307,9 @@ void reiserfs_read_locked_inode (struct 
     /* look for the object's stat data */
     retval = search_item (inode->i_sb, &key, &path_to_sd);
     if (retval == IO_ERROR) {
-	reiserfs_warning ("vs-13070: reiserfs_read_locked_inode: "
-                    "i/o failure occurred trying to find stat data of %K\n",
-                    &key);
+	reiserfs_warning (inode->i_sb, "vs-13070: reiserfs_read_locked_inode: "
+			  "i/o failure occurred trying to find stat data of %K",
+			  &key);
 	reiserfs_make_bad_inode(inode) ;
 	return;
     }
@@ -1339,9 +1339,10 @@ void reiserfs_read_locked_inode (struct 
        during mount (fs/reiserfs/super.c:finish_unfinished()). */
     if( ( inode -> i_nlink == 0 ) && 
 	! REISERFS_SB(inode -> i_sb) -> s_is_unlinked_ok ) {
-	    reiserfs_warning( "vs-13075: reiserfs_read_locked_inode: "
+	    reiserfs_warning (inode->i_sb,
+			      "vs-13075: reiserfs_read_locked_inode: "
 			      "dead inode read from disk %K. "
-			      "This is likely to be race with knfsd. Ignore\n", 
+			      "This is likely to be race with knfsd. Ignore", 
 			      &key );
 	    reiserfs_make_bad_inode( inode );
     }
@@ -1444,7 +1445,7 @@ struct dentry *reiserfs_decode_fh(struct
      */
     if (fhtype > len) {
 	    if (fhtype != 6 || len != 5)
-		    printk(KERN_WARNING "nfsd/reiserfs, fhtype=%d, len=%d - odd\n",
+		    reiserfs_warning (sb, "nfsd/reiserfs, fhtype=%d, len=%d - odd",
 			   fhtype, len);
 	    fhtype = 5;
     }
@@ -1507,8 +1508,9 @@ void reiserfs_write_inode (struct inode 
     int jbegin_count = 1 ;
 
     if (inode->i_sb->s_flags & MS_RDONLY) {
-        reiserfs_warning("clm-6005: writing inode %lu on readonly FS\n", 
-	                  inode->i_ino) ;
+        reiserfs_warning (inode->i_sb,
+			  "clm-6005: writing inode %lu on readonly FS", 
+			  inode->i_ino) ;
         return ;
     }
     /* memory pressure can sometimes initiate write_inode calls with sync == 1,
@@ -1571,13 +1573,13 @@ static int reiserfs_new_directory (struc
     /* look for place in the tree for new item */
     retval = search_item (sb, &key, path);
     if (retval == IO_ERROR) {
-	reiserfs_warning ("vs-13080: reiserfs_new_directory: "
-			  "i/o failure occurred creating new directory\n");
+	reiserfs_warning (sb, "vs-13080: reiserfs_new_directory: "
+			  "i/o failure occurred creating new directory");
 	return -EIO;
     }
     if (retval == ITEM_FOUND) {
 	pathrelse (path);
-	reiserfs_warning ("vs-13070: reiserfs_new_directory: "
+	reiserfs_warning (sb, "vs-13070: reiserfs_new_directory: "
 			  "object with this key exists (%k)", &(ih->ih_key));
 	return -EEXIST;
     }
@@ -1608,13 +1610,13 @@ static int reiserfs_new_symlink (struct 
     /* look for place in the tree for new item */
     retval = search_item (sb, &key, path);
     if (retval == IO_ERROR) {
-	reiserfs_warning ("vs-13080: reiserfs_new_symlinik: "
-			  "i/o failure occurred creating new symlink\n");
+	reiserfs_warning (sb, "vs-13080: reiserfs_new_symlinik: "
+			  "i/o failure occurred creating new symlink");
 	return -EIO;
     }
     if (retval == ITEM_FOUND) {
 	pathrelse (path);
-	reiserfs_warning ("vs-13080: reiserfs_new_symlink: "
+	reiserfs_warning (sb, "vs-13080: reiserfs_new_symlink: "
 			  "object with this key exists (%k)", &(ih->ih_key));
 	return -EEXIST;
     }
@@ -1799,7 +1801,8 @@ int reiserfs_new_inode (struct reiserfs_
             goto out_inserted_sd;
         }
     } else if (inode->i_sb->s_flags & MS_POSIXACL) {
-        reiserfs_warning ("ACLs aren't enabled in the fs, but vfs thinks they are!\n");
+	reiserfs_warning (inode->i_sb, "ACLs aren't enabled in the fs, "
+			  "but vfs thinks they are!");
     }
 
     insert_inode_hash (inode);
@@ -1897,9 +1900,10 @@ static int grab_tail_page(struct inode *
 	** I've screwed up the code to find the buffer, or the code to
 	** call prepare_write
 	*/
-	reiserfs_warning("clm-6000: error reading block %lu on dev %s\n",
-			 bh->b_blocknr,
-			 reiserfs_bdevname (p_s_inode->i_sb)) ;
+	reiserfs_warning (p_s_inode->i_sb,
+			  "clm-6000: error reading block %lu on dev %s",
+			  bh->b_blocknr,
+			  reiserfs_bdevname (p_s_inode->i_sb)) ;
 	error = -EIO ;
 	goto unlock ;
     }
@@ -1939,7 +1943,9 @@ void reiserfs_truncate_file(struct inode
 	    // and get_block_create_0 could not find a block to read in,
 	    // which is ok.
 	    if (error != -ENOENT)
-	        reiserfs_warning("clm-6001: grab_tail_page failed %d\n", error);
+	        reiserfs_warning (p_s_inode->i_sb,
+				  "clm-6001: grab_tail_page failed %d",
+				  error);
 	    page = NULL ;
 	    bh = NULL ;
 	}
@@ -2038,7 +2044,8 @@ research:
     /* we've found an unformatted node */
     if (indirect_item_found(retval, ih)) {
 	if (bytes_copied > 0) {
-	    reiserfs_warning("clm-6002: bytes_copied %d\n", bytes_copied) ;
+	    reiserfs_warning (inode->i_sb, "clm-6002: bytes_copied %d",
+			      bytes_copied) ;
 	}
         if (!get_block_num(item, pos_in_item)) {
 	    /* crap, we are writing to a hole */
@@ -2086,7 +2093,9 @@ research:
 	    goto research ;
 	}
     } else {
-        reiserfs_warning("clm-6003: bad item inode %lu, device %s\n", inode->i_ino, reiserfs_bdevname (inode->i_sb)) ;
+        reiserfs_warning (inode->i_sb,
+			  "clm-6003: bad item inode %lu, device %s",
+			  inode->i_ino, reiserfs_bdevname (inode->i_sb)) ;
         retval = -EIO ;
 	goto out ;
     }
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/item_ops.c linux-2.6.4.warnings/fs/reiserfs/item_ops.c
--- linux-2.6.4/fs/reiserfs/item_ops.c	2004-03-10 21:55:36.000000000 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/item_ops.c	2004-03-29 10:43:44.868720159 -0500
@@ -106,7 +106,7 @@ static int sd_unit_num (struct virtual_i
 
 static void sd_print_vi (struct virtual_item * vi)
 {
-    reiserfs_warning ("STATDATA, index %d, type 0x%x, %h\n", 
+    reiserfs_warning (NULL, "STATDATA, index %d, type 0x%x, %h", 
 		      vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -209,7 +209,7 @@ static int direct_unit_num (struct virtu
 
 static void direct_print_vi (struct virtual_item * vi)
 {
-    reiserfs_warning ("DIRECT, index %d, type 0x%x, %h\n", 
+    reiserfs_warning (NULL, "DIRECT, index %d, type 0x%x, %h", 
 		      vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -302,7 +302,7 @@ static void indirect_print_item (struct 
     unp = (__u32 *)item;
 
     if (ih_item_len(ih) % UNFM_P_SIZE)
-	printk ("indirect_print_item: invalid item len");  
+	reiserfs_warning (NULL, "indirect_print_item: invalid item len");  
 
     printk ("%d pointers\n[ ", (int)I_UNFM_NUM (ih));
     for (j = 0; j < I_UNFM_NUM (ih); j ++) {
@@ -363,7 +363,7 @@ static int indirect_unit_num (struct vir
 
 static void indirect_print_vi (struct virtual_item * vi)
 {
-    reiserfs_warning ("INDIRECT, index %d, type 0x%x, %h\n", 
+    reiserfs_warning (NULL, "INDIRECT, index %d, type 0x%x, %h", 
 		      vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -390,7 +390,7 @@ struct item_operations indirect_ops = {
 
 static int direntry_bytes_number (struct item_head * ih, int block_size)
 {
-    reiserfs_warning ("vs-16090: direntry_bytes_number: "
+    reiserfs_warning (NULL, "vs-16090: direntry_bytes_number: "
 		      "bytes number is asked for direntry");
     return 0;
 }
@@ -582,8 +582,7 @@ static int direntry_check_left (struct v
     }
 
     if (entries == dir_u->entry_count) {
-	printk ("free spze %d, entry_count %d\n", free, dir_u->entry_count);
-	BUG ();
+	reiserfs_panic (NULL, "free space %d, entry_count %d\n", free, dir_u->entry_count);
     }
 
     /* "." and ".." can not be separated from each other */
@@ -653,7 +652,7 @@ static void direntry_print_vi (struct vi
     int i;
     struct direntry_uarea * dir_u = vi->vi_uarea;
 
-    reiserfs_warning ("DIRENTRY, index %d, type 0x%x, %h, flags 0x%x\n", 
+    reiserfs_warning (NULL, "DIRENTRY, index %d, type 0x%x, %h, flags 0x%x", 
 		      vi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);
     printk ("%d entries: ", dir_u->entry_count);
     for (i = 0; i < dir_u->entry_count; i ++)
@@ -682,32 +681,32 @@ struct item_operations direntry_ops = {
 //
 static int errcatch_bytes_number (struct item_head * ih, int block_size)
 {
-    reiserfs_warning ("green-16001: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16001: Invalid item type observed, run fsck ASAP");
     return 0;
 }
 
 static void errcatch_decrement_key (struct cpu_key * key)
 {
-    reiserfs_warning ("green-16002: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16002: Invalid item type observed, run fsck ASAP");
 }
 
 
 static int errcatch_is_left_mergeable (struct key * key, unsigned long bsize)
 {
-    reiserfs_warning ("green-16003: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16003: Invalid item type observed, run fsck ASAP");
     return 0;
 }
 
 
 static void errcatch_print_item (struct item_head * ih, char * item)
 {
-    reiserfs_warning ("green-16004: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16004: Invalid item type observed, run fsck ASAP");
 }
 
 
 static void errcatch_check_item (struct item_head * ih, char * item)
 {
-    reiserfs_warning ("green-16005: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16005: Invalid item type observed, run fsck ASAP");
 }
 
 static int errcatch_create_vi (struct virtual_node * vn,
@@ -715,7 +714,7 @@ static int errcatch_create_vi (struct vi
 			       int is_affected, 
 			       int insert_size)
 {
-    reiserfs_warning ("green-16006: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16006: Invalid item type observed, run fsck ASAP");
     return 0;	// We might return -1 here as well, but it won't help as create_virtual_node() from where
 		// this operation is called from is of return type void.
 }
@@ -723,32 +722,32 @@ static int errcatch_create_vi (struct vi
 static int errcatch_check_left (struct virtual_item * vi, int free,
 				int start_skip, int end_skip)
 {
-    reiserfs_warning ("green-16007: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16007: Invalid item type observed, run fsck ASAP");
     return -1;
 }
 
 
 static int errcatch_check_right (struct virtual_item * vi, int free)
 {
-    reiserfs_warning ("green-16008: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16008: Invalid item type observed, run fsck ASAP");
     return -1;
 }
 
 static int errcatch_part_size (struct virtual_item * vi, int first, int count)
 {
-    reiserfs_warning ("green-16009: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16009: Invalid item type observed, run fsck ASAP");
     return 0;
 }
 
 static int errcatch_unit_num (struct virtual_item * vi)
 {
-    reiserfs_warning ("green-16010: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16010: Invalid item type observed, run fsck ASAP");
     return 0;
 }
 
 static void errcatch_print_vi (struct virtual_item * vi)
 {
-    reiserfs_warning ("green-16011: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16011: Invalid item type observed, run fsck ASAP");
 }
 
 struct item_operations errcatch_ops = {
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/journal.c linux-2.6.4.warnings/fs/reiserfs/journal.c
--- linux-2.6.4/fs/reiserfs/journal.c	2004-03-29 10:42:58.622170202 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/journal.c	2004-03-29 11:12:02.797611276 -0500
@@ -270,7 +270,7 @@ int reiserfs_allocate_list_bitmaps(struc
     jb->journal_list = NULL ;
     jb->bitmaps = vmalloc( mem ) ;
     if (!jb->bitmaps) {
-      reiserfs_warning("clm-2000, unable to allocate bitmaps for journal lists\n") ;
+      reiserfs_warning(p_s_sb, "clm-2000, unable to allocate bitmaps for journal lists") ;
       failed = 1;   
       break ;
     }
@@ -344,7 +344,7 @@ static struct reiserfs_journal_cnode *al
 static struct reiserfs_journal_cnode *get_cnode(struct super_block *p_s_sb) {
   struct reiserfs_journal_cnode *cn ;
 
-  reiserfs_check_lock_depth("get_cnode") ;
+  reiserfs_check_lock_depth(p_s_sb, "get_cnode") ;
 
   if (SB_JOURNAL(p_s_sb)->j_cnode_free <= 0) {
     return NULL ;
@@ -368,7 +368,7 @@ static struct reiserfs_journal_cnode *ge
 */
 static void free_cnode(struct super_block *p_s_sb, struct reiserfs_journal_cnode *cn) {
 
-  reiserfs_check_lock_depth("free_cnode") ;
+  reiserfs_check_lock_depth(p_s_sb, "free_cnode") ;
 
   SB_JOURNAL(p_s_sb)->j_cnode_used-- ;
   SB_JOURNAL(p_s_sb)->j_cnode_free++ ;
@@ -421,11 +421,10 @@ inline int mark_buffer_not_journaled(str
 /* utility function to force a BUG if it is called without the big
 ** kernel lock held.  caller is the string printed just before calling BUG()
 */
-void reiserfs_check_lock_depth(char *caller) {
+void reiserfs_check_lock_depth(struct super_block *sb, char *caller) {
 #ifdef CONFIG_SMP
   if (current->lock_depth < 0) {
-    printk("%s called without kernel lock held\n", caller) ;
-    BUG() ;
+    reiserfs_panic (sb, "%s called without kernel lock held", caller) ;
   }
 #else
   ;
@@ -558,9 +557,8 @@ static inline void put_journal_list(stru
                                    struct reiserfs_journal_list *jl)
 {
     if (jl->j_refcount < 1) {
-        printk("trans id %lu, refcount at %d\n", jl->j_trans_id, 
+        reiserfs_panic (s, "trans id %lu, refcount at %d", jl->j_trans_id, 
 	                                         jl->j_refcount);
-        BUG();
     }
     if (--jl->j_refcount == 0)
         reiserfs_kfree(jl, sizeof(struct reiserfs_journal_list), s);
@@ -600,7 +598,7 @@ static void reiserfs_end_buffer_io_sync(
     char b[BDEVNAME_SIZE];
 
     if (buffer_journaled(bh)) {
-        reiserfs_warning("clm-2084: pinned buffer %lu:%s sent to disk\n",
+        reiserfs_warning(NULL, "clm-2084: pinned buffer %lu:%s sent to disk",
 	                 bh->b_blocknr, bdevname(bh->b_bdev, b)) ;
     }
     if (uptodate)
@@ -911,7 +909,7 @@ static int flush_commit_list(struct supe
   struct buffer_head *tbh = NULL ;
   unsigned long trans_id = jl->j_trans_id;
 
-  reiserfs_check_lock_depth("flush_commit_list") ;
+  reiserfs_check_lock_depth(s, "flush_commit_list") ;
 
   if (atomic_read(&jl->j_older_commits_done)) {
     return 0 ;
@@ -1006,7 +1004,7 @@ static int flush_commit_list(struct supe
   bforget(jl->j_commit_bh) ;
   if (SB_JOURNAL(s)->j_last_commit_id != 0 && 
      (jl->j_trans_id - SB_JOURNAL(s)->j_last_commit_id) != 1) {
-      reiserfs_warning("clm-2200: last commit %lu, current %lu\n",
+      reiserfs_warning(s, "clm-2200: last commit %lu, current %lu",
                        SB_JOURNAL(s)->j_last_commit_id,
 		       jl->j_trans_id);
   }
@@ -1065,8 +1063,8 @@ static void remove_all_from_journal_list
   while(cn) {
     if (cn->blocknr != 0) {
       if (debug) {
-        printk("block %u, bh is %d, state %ld\n", cn->blocknr, cn->bh ? 1: 0,
-	        cn->state) ;
+       reiserfs_warning (p_s_sb, "block %u, bh is %d, state %ld", cn->blocknr,
+                         cn->bh ? 1: 0, cn->state) ;
       }
       cn->state = 0 ;
       remove_journal_hash(p_s_sb, SB_JOURNAL(p_s_sb)->j_list_hash_table, jl, cn->blocknr, 1) ;
@@ -1103,7 +1101,7 @@ static int _update_journal_header_block(
     set_buffer_dirty(SB_JOURNAL(p_s_sb)->j_header_bh) ;
     sync_dirty_buffer(SB_JOURNAL(p_s_sb)->j_header_bh) ;
     if (!buffer_uptodate(SB_JOURNAL(p_s_sb)->j_header_bh)) {
-      printk( "reiserfs: journal-837: IO error during journal replay\n" );
+      reiserfs_warning (p_s_sb, "journal-837: IO error during journal replay");
       return -EIO ;
     }
   }
@@ -1177,7 +1175,7 @@ static int flush_journal_list(struct sup
   }
 
   if (atomic_read(&SB_JOURNAL(s)->j_wcount) != 0) {
-    reiserfs_warning("clm-2048: flush_journal_list called with wcount %d\n",
+    reiserfs_warning(s, "clm-2048: flush_journal_list called with wcount %d",
                       atomic_read(&SB_JOURNAL(s)->j_wcount)) ;
   }
   if (jl->j_trans_id == 0)
@@ -1276,8 +1274,10 @@ static int flush_journal_list(struct sup
     ** is not marked JDirty_wait
     */
     if ((!was_jwait) && !buffer_locked(saved_bh)) {
-printk("journal-813: BAD! buffer %llu %cdirty %cjwait, not in a newer tranasction\n", (unsigned long long)saved_bh->b_blocknr,
-        was_dirty ? ' ' : '!', was_jwait ? ' ' : '!') ;
+	reiserfs_warning (s, "journal-813: BAD! buffer %llu %cdirty %cjwait, "
+			  "not in a newer tranasction",
+			  (unsigned long long)saved_bh->b_blocknr,
+			  was_dirty ? ' ' : '!', was_jwait ? ' ' : '!') ;
     }
     if (was_dirty) { 
       /* we inc again because saved_bh gets decremented at free_cnode */
@@ -1292,8 +1292,8 @@ printk("journal-813: BAD! buffer %llu %c
         unlock_buffer(saved_bh);
       count++ ;
     } else {
-      printk("clm-2082: Unable to flush buffer %llu in flush_journal_list\n",
-              (unsigned long long)saved_bh->b_blocknr) ;
+      reiserfs_warning (s, "clm-2082: Unable to flush buffer %llu in %s",
+                        (unsigned long long)saved_bh->b_blocknr, __FUNCTION__);
     }
 free_cnode:
     last = cn ;
@@ -1302,7 +1302,7 @@ free_cnode:
       /* we incremented this to keep others from taking the buffer head away */
       put_bh(saved_bh) ;
       if (atomic_read(&(saved_bh->b_count)) < 0) {
-        printk("journal-945: saved_bh->b_count < 0") ;
+        reiserfs_warning (s, "journal-945: saved_bh->b_count < 0");
       }
     }
   }
@@ -1362,7 +1362,7 @@ flush_older_and_return:
 
   if (SB_JOURNAL(s)->j_last_flush_id != 0 && 
      (jl->j_trans_id - SB_JOURNAL(s)->j_last_flush_id) != 1) {
-      reiserfs_warning("clm-2201: last flush %lu, current %lu\n",
+      reiserfs_warning(s, "clm-2201: last flush %lu, current %lu",
                        SB_JOURNAL(s)->j_last_flush_id,
 		       jl->j_trans_id);
   }
@@ -1710,19 +1710,19 @@ static int journal_transaction_is_valid(
     if (oldest_invalid_trans_id && *oldest_invalid_trans_id && get_desc_trans_id(desc) > *oldest_invalid_trans_id) {
       reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-986: transaction "
 	              "is valid returning because trans_id %d is greater than "
-		      "oldest_invalid %lu\n", get_desc_trans_id(desc), 
+		      "oldest_invalid %lu", get_desc_trans_id(desc), 
 		       *oldest_invalid_trans_id);
       return 0 ;
     }
     if (newest_mount_id && *newest_mount_id > get_desc_mount_id (desc)) {
       reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1087: transaction "
                      "is valid returning because mount_id %d is less than "
-		     "newest_mount_id %lu\n", get_desc_mount_id (desc), 
+		     "newest_mount_id %lu", get_desc_mount_id (desc), 
 		     *newest_mount_id) ;
       return -1 ;
     }
     if ( get_desc_trans_len(desc) > SB_JOURNAL_TRANS_MAX(p_s_sb) ) {
-      reiserfs_warning("journal-2018: Bad transaction length %d encountered, ignoring transaction\n", get_desc_trans_len(desc));
+      reiserfs_warning(p_s_sb, "journal-2018: Bad transaction length %d encountered, ignoring transaction", get_desc_trans_len(desc));
       return -1 ;
     }
     offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) ;
@@ -1736,7 +1736,7 @@ static int journal_transaction_is_valid(
     if (journal_compare_desc_commit(p_s_sb, desc, commit)) {
       reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, 
                      "journal_transaction_is_valid, commit offset %ld had bad "
-		     "time %d or length %d\n", 
+		     "time %d or length %d", 
 		     c_bh->b_blocknr -  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb),
 		     get_commit_trans_id (commit), 
 		     get_commit_trans_len(commit));
@@ -1744,14 +1744,14 @@ static int journal_transaction_is_valid(
       if (oldest_invalid_trans_id) {
 	*oldest_invalid_trans_id = get_desc_trans_id(desc) ;
 	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1004: "
-	               "transaction_is_valid setting oldest invalid trans_id "
-		       "to %d\n", get_desc_trans_id(desc)) ;
+		       "transaction_is_valid setting oldest invalid trans_id "
+		       "to %d", get_desc_trans_id(desc)) ;
       }
       return -1; 
     }
     brelse(c_bh) ;
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1006: found valid "
-                   "transaction start offset %llu, len %d id %d\n", 
+                   "transaction start offset %llu, len %d id %d", 
 		   d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		   get_desc_trans_len(desc), get_desc_trans_id(desc)) ;
     return 1 ;
@@ -1791,12 +1791,12 @@ static int journal_read_transaction(stru
   desc = (struct reiserfs_journal_desc *)d_bh->b_data ;
   trans_offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) ;
   reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1037: "
-                 "journal_read_transaction, offset %llu, len %d mount_id %d\n", 
+                 "journal_read_transaction, offset %llu, len %d mount_id %d", 
 		 d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		 get_desc_trans_len(desc), get_desc_mount_id(desc)) ;
   if (get_desc_trans_id(desc) < oldest_trans_id) {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1039: "
-                   "journal_read_trans skipping because %lu is too old\n", 
+                   "journal_read_trans skipping because %lu is too old", 
 		   cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb)) ;
     brelse(d_bh) ;
     return 1 ;
@@ -1804,7 +1804,7 @@ static int journal_read_transaction(stru
   if (get_desc_mount_id(desc) != newest_mount_id) {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1146: "
                    "journal_read_trans skipping because %d is != "
-		   "newest_mount_id %lu\n", get_desc_mount_id(desc), 
+		   "newest_mount_id %lu", get_desc_mount_id(desc), 
 		    newest_mount_id) ;
     brelse(d_bh) ;
     return 1 ;
@@ -1819,7 +1819,7 @@ static int journal_read_transaction(stru
   commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
   if (journal_compare_desc_commit(p_s_sb, desc, commit)) {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal_read_transaction, "
-                   "commit offset %llu had bad time %d or length %d\n", 
+                   "commit offset %llu had bad time %d or length %d", 
 		   c_bh->b_blocknr -  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		   get_commit_trans_id(commit), get_commit_trans_len(commit));
     brelse(c_bh) ;
@@ -1835,7 +1835,7 @@ static int journal_read_transaction(stru
     brelse(d_bh) ;
     reiserfs_kfree(log_blocks, get_desc_trans_len(desc) * sizeof(struct buffer_head *), p_s_sb) ;
     reiserfs_kfree(real_blocks, get_desc_trans_len(desc) * sizeof(struct buffer_head *), p_s_sb) ;
-    reiserfs_warning("journal-1169: kmalloc failed, unable to mount FS\n") ;
+    reiserfs_warning(p_s_sb, "journal-1169: kmalloc failed, unable to mount FS") ;
     return -1 ;
   }
   /* get all the buffer heads */
@@ -1848,12 +1848,12 @@ static int journal_read_transaction(stru
       real_blocks[i] = sb_getblk(p_s_sb, le32_to_cpu(commit->j_realblock[i - trans_half])) ;
     }
     if ( real_blocks[i]->b_blocknr > SB_BLOCK_COUNT(p_s_sb) ) {
-      reiserfs_warning("journal-1207: REPLAY FAILURE fsck required! Block to replay is outside of filesystem\n");
+      reiserfs_warning(p_s_sb, "journal-1207: REPLAY FAILURE fsck required! Block to replay is outside of filesystem");
       goto abort_replay;
     }
     /* make sure we don't try to replay onto log or reserved area */
     if (is_block_in_log_or_reserved_area(p_s_sb, real_blocks[i]->b_blocknr)) {
-      reiserfs_warning("journal-1204: REPLAY FAILURE fsck required! Trying to replay onto a log block\n") ;
+      reiserfs_warning(p_s_sb, "journal-1204: REPLAY FAILURE fsck required! Trying to replay onto a log block") ;
 abort_replay:
       brelse_array(log_blocks, i) ;
       brelse_array(real_blocks, i) ;
@@ -1869,7 +1869,7 @@ abort_replay:
   for (i = 0 ; i < get_desc_trans_len(desc) ; i++) {
     wait_on_buffer(log_blocks[i]) ;
     if (!buffer_uptodate(log_blocks[i])) {
-      reiserfs_warning("journal-1212: REPLAY FAILURE fsck required! buffer write failed\n") ;
+      reiserfs_warning(p_s_sb, "journal-1212: REPLAY FAILURE fsck required! buffer write failed") ;
       brelse_array(log_blocks + i, get_desc_trans_len(desc) - i) ;
       brelse_array(real_blocks, get_desc_trans_len(desc)) ;
       brelse(c_bh) ;
@@ -1890,7 +1890,7 @@ abort_replay:
   for (i = 0 ; i < get_desc_trans_len(desc) ; i++) {
     wait_on_buffer(real_blocks[i]) ; 
     if (!buffer_uptodate(real_blocks[i])) {
-      reiserfs_warning("journal-1226: REPLAY FAILURE, fsck required! buffer write failed\n") ;
+      reiserfs_warning(p_s_sb, "journal-1226: REPLAY FAILURE, fsck required! buffer write failed") ;
       brelse_array(real_blocks + i, get_desc_trans_len(desc) - i) ;
       brelse(c_bh) ;
       brelse(d_bh) ;
@@ -1902,7 +1902,7 @@ abort_replay:
   }
   cur_dblock =  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) + ((trans_offset + get_desc_trans_len(desc) + 2) % SB_ONDISK_JOURNAL_SIZE(p_s_sb)) ;
   reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1095: setting journal "
-                 "start to offset %ld\n", 
+                 "start to offset %ld", 
 		 cur_dblock -  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb)) ;
   
   /* init starting values for the first transaction, in case this is the last transaction to be replayed. */
@@ -1984,9 +1984,8 @@ static int journal_read(struct super_blo
   char b[BDEVNAME_SIZE];
 
   cur_dblock = SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) ;
-  printk("reiserfs: checking transaction log (%s) for (%s)\n",
-	 bdevname(SB_JOURNAL(p_s_sb)->j_dev_bd, b),
-	 reiserfs_bdevname(p_s_sb));
+  reiserfs_info (p_s_sb, "checking transaction log (%s)\n",
+	 bdevname(SB_JOURNAL(p_s_sb)->j_dev_bd, b));
   start = get_seconds();
 
   /* step 1, read in the journal header block.  Check the transaction it says 
@@ -2009,7 +2008,7 @@ static int journal_read(struct super_blo
     newest_mount_id = le32_to_cpu(jh->j_mount_id);
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1153: found in "
                    "header: first_unflushed_offset %d, last_flushed_trans_id "
-		   "%lu\n", le32_to_cpu(jh->j_first_unflushed_offset), 
+		   "%lu", le32_to_cpu(jh->j_first_unflushed_offset), 
 		   le32_to_cpu(jh->j_last_flush_trans_id)) ;
     valid_journal_header = 1 ;
 
@@ -2027,7 +2026,8 @@ static int journal_read(struct super_blo
   }
 
   if (continue_replay && bdev_read_only(p_s_sb->s_bdev)) {
-    printk("clm-2076: device is readonly, unable to replay log\n") ;
+    reiserfs_warning (p_s_sb,
+		      "clm-2076: device is readonly, unable to replay log") ;
     return -1 ;
   }
 
@@ -2047,7 +2047,7 @@ static int journal_read(struct super_blo
 	oldest_start = d_bh->b_blocknr ;
 	newest_mount_id = get_desc_mount_id(desc) ;
 	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1179: Setting "
-	               "oldest_start to offset %llu, trans_id %lu\n", 
+	               "oldest_start to offset %llu, trans_id %lu", 
 		       oldest_start - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		       oldest_trans_id) ;
       } else if (oldest_trans_id > get_desc_trans_id(desc)) { 
@@ -2055,14 +2055,14 @@ static int journal_read(struct super_blo
         oldest_trans_id = get_desc_trans_id(desc) ;
 	oldest_start = d_bh->b_blocknr ;
 	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1180: Resetting "
-	               "oldest_start to offset %lu, trans_id %lu\n", 
+	               "oldest_start to offset %lu, trans_id %lu", 
 			oldest_start - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 			oldest_trans_id) ;
       }
       if (newest_mount_id < get_desc_mount_id(desc)) {
         newest_mount_id = get_desc_mount_id(desc) ;
 	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1299: Setting "
-	              "newest_mount_id to %d\n", get_desc_mount_id(desc));
+	              "newest_mount_id to %d", get_desc_mount_id(desc));
       }
       cur_dblock += get_desc_trans_len(desc) + 2 ;
     } else {
@@ -2075,7 +2075,7 @@ start_log_replay:
   cur_dblock = oldest_start ;
   if (oldest_trans_id)  {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1206: Starting replay "
-                   "from offset %llu, trans_id %lu\n", 
+                   "from offset %llu, trans_id %lu", 
 		   cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		   oldest_trans_id) ;
 
@@ -2096,7 +2096,7 @@ start_log_replay:
 
   if (oldest_trans_id == 0) {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1225: No valid "
-                   "transactions found\n") ;
+                   "transactions found") ;
   }
   /* j_start does not get set correctly if we don't replay any transactions.
   ** if we had a valid journal_header, set j_start to the first unflushed transaction value,
@@ -2111,11 +2111,11 @@ start_log_replay:
     SB_JOURNAL(p_s_sb)->j_mount_id = newest_mount_id + 1 ;
   }
   reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1299: Setting "
-                 "newest_mount_id to %lu\n", SB_JOURNAL(p_s_sb)->j_mount_id) ;
+                 "newest_mount_id to %lu", SB_JOURNAL(p_s_sb)->j_mount_id) ;
   SB_JOURNAL(p_s_sb)->j_first_unflushed_offset = SB_JOURNAL(p_s_sb)->j_start ; 
   if (replay_count > 0) {
-    printk("reiserfs: replayed %d transactions in %lu seconds\n", replay_count, 
-	    get_seconds() - start) ;
+    reiserfs_info (p_s_sb, "replayed %d transactions in %lu seconds\n",
+		   replay_count, get_seconds() - start) ;
   }
   if (!bdev_read_only(p_s_sb->s_bdev) && 
        _update_journal_header_block(p_s_sb, SB_JOURNAL(p_s_sb)->j_start, 
@@ -2170,7 +2170,7 @@ static int release_journal_dev( struct s
     }
 
     if( result != 0 ) {
-	reiserfs_warning("sh-457: release_journal_dev: Cannot release journal device: %i\n", result );
+	reiserfs_warning(super, "sh-457: release_journal_dev: Cannot release journal device: %i", result );
     }
     return result;
 }
@@ -2200,8 +2200,9 @@ static int journal_init_dev( struct supe
 		if (IS_ERR(journal->j_dev_bd)) {
 			result = PTR_ERR(journal->j_dev_bd);
 			journal->j_dev_bd = NULL;
-			printk( "sh-458: journal_init_dev: cannot init journal device\n '%s': %i", 
-				__bdevname(jdev, b), result );
+			reiserfs_warning (super, "sh-458: journal_init_dev: "
+					  "cannot init journal device '%s': %i",
+					  __bdevname(jdev, b), result );
 			return result;
 		} else if (jdev != super->s_dev)
 			set_blocksize(journal->j_dev_bd, super->s_blocksize);
@@ -2212,7 +2213,8 @@ static int journal_init_dev( struct supe
 	if( !IS_ERR( journal -> j_dev_file ) ) {
 		struct inode *jdev_inode = journal->j_dev_file->f_mapping->host;
 		if( !S_ISBLK( jdev_inode -> i_mode ) ) {
-			printk( "journal_init_dev: '%s' is not a block device\n", jdev_name );
+			reiserfs_warning  (super, "journal_init_dev: '%s' is "
+					   "not a block device", jdev_name );
 			result = -ENOTBLK;
 		} else  {
 			/* ok */
@@ -2222,12 +2224,14 @@ static int journal_init_dev( struct supe
 	} else {
 		result = PTR_ERR( journal -> j_dev_file );
 		journal -> j_dev_file = NULL;
-		printk( "journal_init_dev: Cannot open '%s': %i\n", jdev_name, result );
+		reiserfs_warning (super,
+				  "journal_init_dev: Cannot open '%s': %i",
+				  jdev_name, result );
 	}
 	if( result != 0 ) {
 		release_journal_dev( super, journal );
 	}
-	printk( "journal_init_dev: journal device: %s\n",
+	reiserfs_info(super, "journal_init_dev: journal device: %s\n",
 		bdevname(journal->j_dev_bd, b));
 	return result;
 }
@@ -2246,7 +2250,7 @@ int journal_init(struct super_block *p_s
 
     journal = SB_JOURNAL(p_s_sb) = vmalloc(sizeof (struct reiserfs_journal)) ;
     if (!journal) {
-	printk("journal-1256: unable to get memory for journal structure\n") ;
+	reiserfs_warning (p_s_sb, "journal-1256: unable to get memory for journal structure") ;
 	return 1 ;
     }
     memset(journal, 0, sizeof(struct reiserfs_journal)) ;
@@ -2268,14 +2272,16 @@ int journal_init(struct super_block *p_s
        (actual for small blocksizes) */
     if ( !SB_ONDISK_JOURNAL_DEVICE( p_s_sb ) &&
          (SB_JOURNAL_1st_RESERVED_BLOCK(p_s_sb) + SB_ONDISK_JOURNAL_SIZE(p_s_sb) > p_s_sb->s_blocksize * 8) ) {
-	printk("journal-1393: journal does not fit for area addressed by first of bitmap blocks. "
-	       "It starts at %u and its size is %u. Block size %ld\n",
-		SB_JOURNAL_1st_RESERVED_BLOCK(p_s_sb), SB_ONDISK_JOURNAL_SIZE(p_s_sb), p_s_sb->s_blocksize) ;
+	reiserfs_warning (p_s_sb, "journal-1393: journal does not fit for area "
+			  "addressed by first of bitmap blocks. It starts at "
+			  "%u and its size is %u. Block size %ld",
+			  SB_JOURNAL_1st_RESERVED_BLOCK(p_s_sb),
+			  SB_ONDISK_JOURNAL_SIZE(p_s_sb), p_s_sb->s_blocksize);
 	goto free_and_return;
     }
 
     if( journal_init_dev( p_s_sb, journal, j_dev_name ) != 0 ) {
-      printk( "sh-462: unable to initialize jornal device\n");
+      reiserfs_warning (p_s_sb, "sh-462: unable to initialize jornal device");
       goto free_and_return;
     }
 
@@ -2285,18 +2291,19 @@ int journal_init(struct super_block *p_s
      bhjh = journal_bread(p_s_sb,
 		   SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) + SB_ONDISK_JOURNAL_SIZE(p_s_sb));
      if (!bhjh) {
-	 printk("sh-459: unable to read  journal header\n") ;
+	 reiserfs_warning (p_s_sb, "sh-459: unable to read journal header");
 	 goto free_and_return;
      }
      jh = (struct reiserfs_journal_header *)(bhjh->b_data);
      
      /* make sure that journal matches to the super block */
      if (is_reiserfs_jr(rs) && (jh->jh_journal.jp_journal_magic != sb_jp_journal_magic(rs))) {
-	 printk("sh-460: journal header magic %x (device %s) does not match "
-		"to magic found in super block %x (device %s)\n",
-		jh->jh_journal.jp_journal_magic,
-		bdevname( SB_JOURNAL(p_s_sb)->j_dev_bd, b),
-		sb_jp_journal_magic(rs), reiserfs_bdevname (p_s_sb));
+	 reiserfs_warning (p_s_sb, "sh-460: journal header magic %x "
+			   "(device %s) does not match to magic found in super "
+			   "block %x",
+			   jh->jh_journal.jp_journal_magic,
+			   bdevname( SB_JOURNAL(p_s_sb)->j_dev_bd, b),
+			   sb_jp_journal_magic(rs));
 	 brelse (bhjh);
 	 goto free_and_return;
   }
@@ -2327,7 +2334,7 @@ int journal_init(struct super_block *p_s
       SB_JOURNAL_TRANS_MAX(p_s_sb) = JOURNAL_TRANS_MIN_DEFAULT / ratio;
     
     if (SB_JOURNAL_TRANS_MAX(p_s_sb) != initial)
-      printk ("sh-461: journal_init: wrong transaction max size (%u). Changed to %u\n",
+      reiserfs_warning (p_s_sb, "sh-461: journal_init: wrong transaction max size (%u). Changed to %u",
 	      initial, SB_JOURNAL_TRANS_MAX(p_s_sb));
 
     SB_JOURNAL_MAX_BATCH(p_s_sb) = SB_JOURNAL_TRANS_MAX(p_s_sb)*
@@ -2348,16 +2355,16 @@ int journal_init(struct super_block *p_s
       SB_JOURNAL_MAX_BATCH(p_s_sb) = (SB_JOURNAL_TRANS_MAX(p_s_sb)) * 9 / 10 ;
     }
   }
-  printk ("Reiserfs journal params: device %s, size %u, "
-	  "journal first block %u, max trans len %u, max batch %u, "
-	  "max commit age %u, max trans age %u\n",
-	  bdevname( SB_JOURNAL(p_s_sb)->j_dev_bd, b),
-	  SB_ONDISK_JOURNAL_SIZE(p_s_sb),
-	  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb),
-	  SB_JOURNAL_TRANS_MAX(p_s_sb),
-	  SB_JOURNAL_MAX_BATCH(p_s_sb),
-	  SB_JOURNAL_MAX_COMMIT_AGE(p_s_sb),
-	  SB_JOURNAL_MAX_TRANS_AGE(p_s_sb));
+  reiserfs_info (p_s_sb, "journal params: device %s, size %u, "
+		 "journal first block %u, max trans len %u, max batch %u, "
+		 "max commit age %u, max trans age %u\n",
+		 bdevname( SB_JOURNAL(p_s_sb)->j_dev_bd, b),
+		 SB_ONDISK_JOURNAL_SIZE(p_s_sb),
+		 SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb),
+		 SB_JOURNAL_TRANS_MAX(p_s_sb),
+		 SB_JOURNAL_MAX_BATCH(p_s_sb),
+		 SB_JOURNAL_MAX_COMMIT_AGE(p_s_sb),
+		 SB_JOURNAL_MAX_TRANS_AGE(p_s_sb));
 
   brelse (bhjh);
      
@@ -2396,11 +2403,11 @@ int journal_init(struct super_block *p_s
   jl = SB_JOURNAL(p_s_sb)->j_current_jl;
   jl->j_list_bitmap = get_list_bitmap(p_s_sb, jl);
   if (!jl->j_list_bitmap) {
-    reiserfs_warning("journal-2005, get_list_bitmap failed for journal list 0\n") ;
+    reiserfs_warning(p_s_sb, "journal-2005, get_list_bitmap failed for journal list 0") ;
     goto free_and_return;
   }
   if (journal_read(p_s_sb) < 0) {
-    reiserfs_warning("Replay Failure, unable to mount\n") ;
+    reiserfs_warning(p_s_sb, "Replay Failure, unable to mount") ;
     goto free_and_return;
   }
 
@@ -2503,7 +2510,7 @@ static int do_journal_begin_r(struct rei
   struct reiserfs_transaction_handle myth;
   int sched_count = 0;
 
-  reiserfs_check_lock_depth("journal_begin") ;
+  reiserfs_check_lock_depth(p_s_sb, "journal_begin") ;
   RFALSE( p_s_sb->s_flags & MS_RDONLY, 
 	  "clm-2078: calling journal_begin on readonly FS") ;
 
@@ -2645,14 +2652,14 @@ int journal_begin(struct reiserfs_transa
 	      cur_th->t_refcount++ ;
 	      memcpy(th, cur_th, sizeof(*th)); 
 	      if (th->t_refcount <= 1) 
-		      printk("BAD: refcount <= 1, but journal_info != 0\n"); 
+		      reiserfs_warning (p_s_sb, "BAD: refcount <= 1, but journal_info != 0"); 
 	      return 0;
 	} else {
 	    /* we've ended up with a handle from a different filesystem.
 	    ** save it and restore on journal_end.  This should never
 	    ** really happen...
 	    */
-	    reiserfs_warning("clm-2100: nesting info a different FS\n") ;
+	    reiserfs_warning(p_s_sb, "clm-2100: nesting info a different FS") ;
 	    th->t_handle_save = current->journal_info ;
 	    current->journal_info = th;
 	}
@@ -2699,14 +2706,16 @@ int journal_mark_dirty(struct reiserfs_t
   ** could get to disk too early.  NOT GOOD.
   */
   if (!prepared || buffer_locked(bh) || buffer_dirty(bh)) {
-    printk("journal-1777: buffer %llu bad state %cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\n", (unsigned long long)bh->b_blocknr, prepared ? ' ' : '!', 
-                            buffer_locked(bh) ? ' ' : '!',
+    reiserfs_warning (p_s_sb, "journal-1777: buffer %llu bad state "
+		      "%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT",
+		      (unsigned long long)bh->b_blocknr, prepared ? ' ' : '!', 
+			    buffer_locked(bh) ? ' ' : '!',
 			    buffer_dirty(bh) ? ' ' : '!',
 			    buffer_journal_dirty(bh) ? ' ' : '!') ;
   }
 
   if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) <= 0) {
-    printk("journal-1409: journal_mark_dirty returning because j_wcount was %d\n", atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount))) ;
+    reiserfs_warning (p_s_sb, "journal-1409: journal_mark_dirty returning because j_wcount was %d", atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount))) ;
     return 1 ;
   }
   /* this error means I've screwed up, and we've overflowed the transaction.  
@@ -2766,7 +2775,8 @@ int journal_mark_dirty(struct reiserfs_t
 
 int journal_end(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, unsigned long nblocks) {
   if (!current->journal_info && th->t_refcount > 1) 
-    printk("REISER-NESTING: th NULL, refcount %d\n", th->t_refcount); 
+    reiserfs_warning (p_s_sb, "REISER-NESTING: th NULL, refcount %d",
+                      th->t_refcount); 
 
   th->t_refcount--;
   if (th->t_refcount > 0) { 
@@ -2825,7 +2835,7 @@ static int remove_from_transaction(struc
     mark_buffer_notjournal_dirty(bh) ; 
     put_bh(bh) ;
     if (atomic_read(&(bh->b_count)) < 0) {
-      printk("journal-1752: remove from trans, b_count < 0\n") ;
+      reiserfs_warning (p_s_sb, "journal-1752: remove from trans, b_count < 0");
     }
     ret = 1 ;
   }
@@ -3116,7 +3126,7 @@ int journal_mark_freed(struct reiserfs_t
 	    cleaned = 1 ;
 	    put_bh(cn->bh) ;
 	    if (atomic_read(&(cn->bh->b_count)) < 0) {
-	      printk("journal-2138: cn->bh->b_count < 0\n") ;
+	      reiserfs_warning (p_s_sb, "journal-2138: cn->bh->b_count < 0");
 	    }
 	  }
 	  if (cn->jlist) { /* since we are clearing the bh, we MUST dec nonzerolen */
@@ -3132,7 +3142,7 @@ int journal_mark_freed(struct reiserfs_t
   if (bh) {
     put_bh(bh) ; /* get_hash grabs the buffer */
     if (atomic_read(&(bh->b_count)) < 0) {
-      printk("journal-2165: bh->b_count < 0\n") ;
+      reiserfs_warning (p_s_sb, "journal-2165: bh->b_count < 0");
     }
   }
   return 0 ;
@@ -3292,7 +3302,7 @@ static int do_journal_end(struct reiserf
     BUG() ;
 
   current->journal_info = th->t_handle_save;
-  reiserfs_check_lock_depth("journal end");
+  reiserfs_check_lock_depth(p_s_sb, "journal end");
   if (SB_JOURNAL(p_s_sb)->j_len == 0) {
       reiserfs_prepare_for_journal(p_s_sb, SB_BUFFER_WITH_SB(p_s_sb), 1) ;
       journal_mark_dirty(th, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
@@ -3454,7 +3464,7 @@ static int do_journal_end(struct reiserf
       clear_bit(BH_JDirty, &(cn->bh->b_state)) ;
     } else {
       /* JDirty cleared sometime during transaction.  don't log this one */
-      reiserfs_warning("journal-2048: do_journal_end: BAD, buffer in journal hash, but not JDirty!\n") ;
+      reiserfs_warning(p_s_sb, "journal-2048: do_journal_end: BAD, buffer in journal hash, but not JDirty!") ;
       brelse(cn->bh) ;
     }
     next = cn->next ;
@@ -3586,7 +3596,7 @@ first_jl:
 	  flush_commit_list(p_s_sb, jl, 1) ;
   }
 out:
-  reiserfs_check_lock_depth("journal end2");
+  reiserfs_check_lock_depth(p_s_sb, "journal end2");
   th->t_trans_id = 0;
   return 0 ;
 }
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/lbalance.c linux-2.6.4.warnings/fs/reiserfs/lbalance.c
--- linux-2.6.4/fs/reiserfs/lbalance.c	2004-03-10 21:55:54.000000000 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/lbalance.c	2004-03-29 10:43:44.908712852 -0500
@@ -1210,10 +1210,10 @@ void    leaf_paste_entries (
       prev = (i != 0) ? deh_location( &(deh[i - 1]) ) : 0;
       
       if (prev && prev <= deh_location( &(deh[i])))
-	reiserfs_warning ("vs-10240: leaf_paste_entries: directory item (%h) corrupted (prev %a, cur(%d) %a)\n", 
+	reiserfs_warning (NULL, "vs-10240: leaf_paste_entries: directory item (%h) corrupted (prev %a, cur(%d) %a)", 
 			  ih, deh + i - 1, i, deh + i);
       if (next && next >= deh_location( &(deh[i])))
-	reiserfs_warning ("vs-10250: leaf_paste_entries: directory item (%h) corrupted (cur(%d) %a, next %a)\n",
+	reiserfs_warning (NULL, "vs-10250: leaf_paste_entries: directory item (%h) corrupted (cur(%d) %a, next %a)",
 			  ih, i, deh + i, deh + i + 1);
     }
   }
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/namei.c linux-2.6.4.warnings/fs/reiserfs/namei.c
--- linux-2.6.4/fs/reiserfs/namei.c	2004-03-29 10:42:49.539829775 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/namei.c	2004-03-29 10:58:47.176904409 -0500
@@ -126,7 +126,7 @@ int search_by_entry_key (struct super_bl
     switch (retval) {
     case ITEM_NOT_FOUND:
 	if (!PATH_LAST_POSITION (path)) {
-	    reiserfs_warning ("vs-7000: search_by_entry_key: search_by_key returned item position == 0");
+	    reiserfs_warning (sb, "vs-7000: search_by_entry_key: search_by_key returned item position == 0");
 	    pathrelse(path) ;
 	    return IO_ERROR ;
 	}
@@ -140,7 +140,7 @@ int search_by_entry_key (struct super_bl
 
     default:
 	pathrelse (path);
-	reiserfs_warning ("vs-7002: search_by_entry_key: no path to here");
+	reiserfs_warning (sb, "vs-7002: search_by_entry_key: no path to here");
 	return IO_ERROR;
     }
 
@@ -299,7 +299,8 @@ static int reiserfs_find_entry (struct i
     while (1) {
 	retval = search_by_entry_key (dir->i_sb, &key_to_search, path_to_entry, de);
 	if (retval == IO_ERROR) {
-	    reiserfs_warning ("zam-7001: io error in %s\n", __FUNCTION__);
+	    reiserfs_warning (dir->i_sb, "zam-7001: io error in %s",
+			      __FUNCTION__);
 	    return IO_ERROR;
 	}
 
@@ -484,8 +485,9 @@ static int reiserfs_add_entry (struct re
 	}
 
         if (retval != NAME_FOUND) {
-	    reiserfs_warning ("zam-7002:%s: \"reiserfs_find_entry\" has returned"
-                              " unexpected value (%d)\n", __FUNCTION__, retval);
+	    reiserfs_warning (dir->i_sb, "zam-7002:%s: \"reiserfs_find_entry\" "
+			      "has returned unexpected value (%d)",
+			      __FUNCTION__, retval);
        }
 
 	return -EEXIST;
@@ -494,7 +496,7 @@ static int reiserfs_add_entry (struct re
     gen_number = find_first_zero_bit ((unsigned long *)bit_string, MAX_GENERATION_NUMBER + 1);
     if (gen_number > MAX_GENERATION_NUMBER) {
       /* there is no free generation number */
-      reiserfs_warning ("reiserfs_add_entry: Congratulations! we have got hash function screwed up\n");
+      reiserfs_warning (dir->i_sb, "reiserfs_add_entry: Congratulations! we have got hash function screwed up");
       if (buffer != small_buf)
           reiserfs_kfree (buffer, buflen, dir->i_sb);
       pathrelse (&path);
@@ -509,8 +511,9 @@ static int reiserfs_add_entry (struct re
  		  
     if (gen_number != 0) {	/* we need to re-search for the insertion point */
       if (search_by_entry_key (dir->i_sb, &entry_key, &path, &de) != NAME_NOT_FOUND) {
-            reiserfs_warning ("vs-7032: reiserfs_add_entry: "
-                            "entry with this key (%K) already exists\n", &entry_key);
+            reiserfs_warning (dir->i_sb, "vs-7032: reiserfs_add_entry: "
+                              "entry with this key (%K) already exists",
+                              &entry_key);
 
 	    if (buffer != small_buf)
 		reiserfs_kfree (buffer, buflen, dir->i_sb);
@@ -834,7 +837,8 @@ static int reiserfs_rmdir (struct inode 
 	goto end_rmdir;
 
     if ( inode->i_nlink != 2 && inode->i_nlink != 1 )
-	printk ("reiserfs_rmdir: empty directory has nlink != 2 (%d)\n", inode->i_nlink);
+	reiserfs_warning (inode->i_sb, "%s: empty directory has nlink "
+			  "!= 2 (%d)", __FUNCTION__, inode->i_nlink);
 
     inode->i_nlink = 0;
     inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
@@ -901,8 +905,10 @@ static int reiserfs_unlink (struct inode
     }
   
     if (!inode->i_nlink) {
-	printk("reiserfs_unlink: deleting nonexistent file (%s:%lu), %d\n",
-	       reiserfs_bdevname (inode->i_sb), inode->i_ino, inode->i_nlink);
+	reiserfs_warning (inode->i_sb, "%s: deleting nonexistent file "
+			  "(%s:%lu), %d", __FUNCTION__,
+			  reiserfs_bdevname (inode->i_sb), inode->i_ino,
+			  inode->i_nlink);
 	inode->i_nlink = 1;
     }
 
@@ -1336,7 +1342,7 @@ static int reiserfs_rename (struct inode
     // anybody, but it will panic if will not be able to find the
     // entry. This needs one more clean up
     if (reiserfs_cut_from_item (&th, &old_entry_path, &(old_de.de_entry_key), old_dir, NULL, 0) < 0)
-	reiserfs_warning ("vs-7060: reiserfs_rename: couldn't not cut old name. Fsck later?\n");
+	reiserfs_warning (old_dir->i_sb, "vs-7060: reiserfs_rename: couldn't not cut old name. Fsck later?");
 
     old_dir->i_size -= DEH_SIZE + old_de.de_entrylen;
 
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/objectid.c linux-2.6.4.warnings/fs/reiserfs/objectid.c
--- linux-2.6.4/fs/reiserfs/objectid.c	2004-03-29 10:42:49.382858457 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/objectid.c	2004-03-29 10:43:44.910712486 -0500
@@ -62,7 +62,7 @@ __u32 reiserfs_get_unused_objectid (stru
                                 /* comment needed -Hans */
     unused_objectid = le32_to_cpu (map[1]);
     if (unused_objectid == U32_MAX) {
-	printk ("REISERFS: get_objectid: no more object ids\n");
+	reiserfs_warning (s, "%s: no more object ids", __FUNCTION__);
 	reiserfs_restore_prepared_buffer(s, SB_BUFFER_WITH_SB(s)) ;
 	return 0;
     }
@@ -159,7 +159,7 @@ void reiserfs_release_objectid (struct r
 	i += 2;
     }
 
-    reiserfs_warning ("vs-15011: reiserfs_release_objectid: tried to free free object id (%lu)\n", 
+    reiserfs_warning (s, "vs-15011: reiserfs_release_objectid: tried to free free object id (%lu)", 
 		      ( long unsigned ) objectid_to_release);
 }
 
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/prints.c linux-2.6.4.warnings/fs/reiserfs/prints.c
--- linux-2.6.4/fs/reiserfs/prints.c	2004-03-29 10:42:49.340866131 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/prints.c	2004-03-29 10:43:44.911712304 -0500
@@ -264,20 +264,43 @@ prepare_error_buf( const char *fmt, va_l
     va_end( args );\
 }
 
-void reiserfs_warning (const char * fmt, ...)
+void reiserfs_warning (struct super_block *sb, const char * fmt, ...)
 {
   do_reiserfs_warning(fmt);
-  /* console_print (error_buf); */
-  printk (KERN_WARNING "%s", error_buf);
+  if (sb)
+      printk (KERN_WARNING "ReiserFS: %s: warning: %s\n",
+             reiserfs_bdevname (sb), error_buf);
+  else
+      printk (KERN_WARNING "ReiserFS: warning: %s\n", error_buf);
+}
+
+/* No newline.. reiserfs_info calls can be followed by printk's */
+void reiserfs_info (struct super_block *sb, const char * fmt, ...)
+{
+  do_reiserfs_warning(fmt);
+  if (sb)
+      printk (KERN_NOTICE "ReiserFS: %s: %s",
+             reiserfs_bdevname (sb), error_buf);
+  else
+      printk (KERN_NOTICE "ReiserFS: %s", error_buf);
+}
+
+/* No newline.. reiserfs_printk calls can be followed by printk's */
+void reiserfs_printk (const char * fmt, ...)
+{
+  do_reiserfs_warning(fmt);
+  printk (error_buf);
 }
 
 void reiserfs_debug (struct super_block *s, int level, const char * fmt, ...)
 {
 #ifdef CONFIG_REISERFS_CHECK
   do_reiserfs_warning(fmt);
-  printk (KERN_DEBUG "%s", error_buf);
-#else
-  ; 
+  if (s)
+      printk (KERN_DEBUG "ReiserFS: %s: %s\n",
+             reiserfs_bdevname (s), error_buf);
+  else
+      printk (KERN_DEBUG "ReiserFS: %s\n", error_buf);
 #endif
 }
 
@@ -334,7 +357,8 @@ extern struct tree_balance * cur_tb;
 void reiserfs_panic (struct super_block * sb, const char * fmt, ...)
 {
   do_reiserfs_warning(fmt);
-  printk ( KERN_EMERG "%s", error_buf);
+  printk (KERN_EMERG "REISERFS: panic (device %s): %s\n",
+          reiserfs_bdevname (sb), error_buf);
   BUG ();
 
   /* this is not actually called, but makes reiserfs_panic() "noreturn" */
@@ -413,13 +437,13 @@ static int print_internal (struct buffer
 	to = last < B_NR_ITEMS (bh) ? last : B_NR_ITEMS (bh);
     }
 
-    reiserfs_warning ("INTERNAL NODE (%ld) contains %z\n",  bh->b_blocknr, bh);
+    reiserfs_printk ("INTERNAL NODE (%ld) contains %z\n",  bh->b_blocknr, bh);
     
     dc = B_N_CHILD (bh, from);
-    reiserfs_warning ("PTR %d: %y ", from, dc);
+    reiserfs_printk ("PTR %d: %y ", from, dc);
     
     for (i = from, key = B_N_PDELIM_KEY (bh, from), dc ++; i < to; i ++, key ++, dc ++) {
-	reiserfs_warning ("KEY %d: %k PTR %d: %y ", i, key, i + 1, dc);
+	reiserfs_printk ("KEY %d: %k PTR %d: %y ", i, key, i + 1, dc);
 	if (i && i % 4 == 0)
 	    printk ("\n");
     }
@@ -448,10 +472,10 @@ static int print_leaf (struct buffer_hea
     nr = blkh_nr_item(blkh);
 
     printk ("\n===================================================================\n");
-    reiserfs_warning ("LEAF NODE (%ld) contains %z\n", bh->b_blocknr, bh);
+    reiserfs_printk ("LEAF NODE (%ld) contains %z\n", bh->b_blocknr, bh);
 
     if (!(print_mode & PRINT_LEAF_ITEMS)) {
-	reiserfs_warning ("FIRST ITEM_KEY: %k, LAST ITEM KEY: %k\n",
+	reiserfs_printk ("FIRST ITEM_KEY: %k, LAST ITEM KEY: %k\n",
 			  &(ih->ih_key), &((ih + nr - 1)->ih_key));
 	return 0;
     }
@@ -471,7 +495,7 @@ static int print_leaf (struct buffer_hea
     printk ("|##|   type    |           key           | ilen | free_space | version | loc  |\n");
     for (i = from; i < to; i++, ih ++) {
 	printk ("-------------------------------------------------------------------------------\n");
-	reiserfs_warning ("|%2d| %h |\n", i, ih);
+	reiserfs_printk ("|%2d| %h |\n", i, ih);
 	if (print_mode & PRINT_LEAF_ITEMS)
 	    op_print_item (ih, B_I_PITEM (bh, ih));
     }
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/procfs.c linux-2.6.4.warnings/fs/reiserfs/procfs.c
--- linux-2.6.4/fs/reiserfs/procfs.c	2004-03-29 10:42:49.386857727 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/procfs.c	2004-03-29 11:13:14.263544913 -0500
@@ -548,8 +548,8 @@ int reiserfs_proc_info_init( struct supe
 		add_file(sb, "journal", show_journal);
 		return 0;
 	}
-	reiserfs_warning( "reiserfs: cannot create /proc/%s/%s\n",
-			  proc_info_root_name, reiserfs_bdevname (sb) );
+	reiserfs_warning(sb, "reiserfs: cannot create /proc/%s/%s",
+			 proc_info_root_name, reiserfs_bdevname (sb) );
 	return 1;
 }
 
@@ -595,7 +595,8 @@ int reiserfs_proc_info_global_init( void
 		if( proc_info_root ) {
 			proc_info_root -> owner = THIS_MODULE;
 		} else {
-			reiserfs_warning( "reiserfs: cannot create /proc/%s\n",
+			reiserfs_warning (NULL,
+					  "reiserfs: cannot create /proc/%s",
 					  proc_info_root_name );
 			return 1;
 		}
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/stree.c linux-2.6.4.warnings/fs/reiserfs/stree.c
--- linux-2.6.4/fs/reiserfs/stree.c	2004-03-29 10:42:49.538829957 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/stree.c	2004-03-29 11:02:44.519550923 -0500
@@ -164,7 +164,7 @@ inline int comp_cpu_keys (const struct c
     if (cpu_key_k_offset (key1) > cpu_key_k_offset (key2))
 	return 1;
 
-    reiserfs_warning ("comp_cpu_keys: type are compared for %K and %K\n",
+    reiserfs_warning (NULL, "comp_cpu_keys: type are compared for %K and %K",
 		      key1, key2);
 
     if (cpu_key_k_type (key1) < cpu_key_k_type (key2))
@@ -497,21 +497,21 @@ static int is_leaf (char * buf, int bloc
 
     blkh = (struct block_head *)buf;
     if ( blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {
-	printk ("is_leaf: this should be caught earlier\n");
+	reiserfs_warning (NULL, "is_leaf: this should be caught earlier");
 	return 0;
     }
 
     nr = blkh_nr_item(blkh);
     if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {
 	/* item number is too big or too small */
-	reiserfs_warning ("is_leaf: nr_item seems wrong: %z\n", bh);
+	reiserfs_warning (NULL, "is_leaf: nr_item seems wrong: %z", bh);
 	return 0;
     }
     ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
     used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location (ih));
     if (used_space != blocksize - blkh_free_space(blkh)) {
 	/* free space does not match to calculated amount of use space */
-	reiserfs_warning ("is_leaf: free space seems wrong: %z\n", bh);
+	reiserfs_warning (NULL, "is_leaf: free space seems wrong: %z", bh);
 	return 0;
     }
 
@@ -523,19 +523,19 @@ static int is_leaf (char * buf, int bloc
     prev_location = blocksize;
     for (i = 0; i < nr; i ++, ih ++) {
 	if ( le_ih_k_type(ih) == TYPE_ANY) {
-	    reiserfs_warning ("is_leaf: wrong item type for item %h\n",ih);
+	    reiserfs_warning (NULL, "is_leaf: wrong item type for item %h",ih);
 	    return 0;
 	}
 	if (ih_location (ih) >= blocksize || ih_location (ih) < IH_SIZE * nr) {
-	    reiserfs_warning ("is_leaf: item location seems wrong: %h\n", ih);
+	    reiserfs_warning (NULL, "is_leaf: item location seems wrong: %h", ih);
 	    return 0;
 	}
 	if (ih_item_len (ih) < 1 || ih_item_len (ih) > MAX_ITEM_LEN (blocksize)) {
-	    reiserfs_warning ("is_leaf: item length seems wrong: %h\n", ih);
+	    reiserfs_warning (NULL, "is_leaf: item length seems wrong: %h", ih);
 	    return 0;
 	}
 	if (prev_location - ih_location (ih) != ih_item_len (ih)) {
-	    reiserfs_warning ("is_leaf: item location seems wrong (second one): %h\n", ih);
+	    reiserfs_warning (NULL, "is_leaf: item location seems wrong (second one): %h", ih);
 	    return 0;
 	}
 	prev_location = ih_location (ih);
@@ -557,20 +557,20 @@ static int is_internal (char * buf, int 
     nr = blkh_level(blkh);
     if (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {
 	/* this level is not possible for internal nodes */
-	printk ("is_internal: this should be caught earlier\n");
+	reiserfs_warning (NULL, "is_internal: this should be caught earlier");
 	return 0;
     }
     
     nr = blkh_nr_item(blkh);
     if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {
 	/* for internal which is not root we might check min number of keys */
-	reiserfs_warning ("is_internal: number of key seems wrong: %z\n", bh);
+	reiserfs_warning (NULL, "is_internal: number of key seems wrong: %z", bh);
 	return 0;
     }
 
     used_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);
     if (used_space != blocksize - blkh_free_space(blkh)) {
-	reiserfs_warning ("is_internal: free space seems wrong: %z\n", bh);
+	reiserfs_warning (NULL, "is_internal: free space seems wrong: %z", bh);
 	return 0;
     }
 
@@ -584,7 +584,7 @@ static int is_internal (char * buf, int 
 static int is_tree_node (struct buffer_head * bh, int level)
 {
     if (B_LEVEL (bh) != level) {
-	printk ("is_tree_node: node level %d does not match to the expected one %d\n",
+	reiserfs_warning (NULL, "is_tree_node: node level %d does not match to the expected one %d",
 		B_LEVEL (bh), level);
 	return 0;
     }
@@ -681,9 +681,9 @@ int search_by_key (struct super_block * 
 
 #ifdef CONFIG_REISERFS_CHECK
 	if ( !(++n_repeat_counter % 50000) )
-	    reiserfs_warning ("PAP-5100: search_by_key: %s:"
+	    reiserfs_warning (p_s_sb, "PAP-5100: search_by_key: %s:"
 			      "there were %d iterations of while loop "
-			      "looking for key %K\n",
+			      "looking for key %K",
 			      current->comm, n_repeat_counter, p_s_key);
 #endif
 
@@ -746,8 +746,8 @@ int search_by_key (struct super_block * 
 	// make sure, that the node contents look like a node of
 	// certain level
 	if (!is_tree_node (p_s_bh, expected_level)) {
-	    reiserfs_warning ("vs-5150: search_by_key: "
-			      "invalid format found in block %ld. Fsck?\n", 
+	    reiserfs_warning (p_s_sb, "vs-5150: search_by_key: "
+			      "invalid format found in block %ld. Fsck?", 
 			      p_s_bh->b_blocknr);
 	    pathrelse (p_s_search_path);
 	    return IO_ERROR;
@@ -1280,8 +1280,8 @@ int reiserfs_delete_item (struct reiserf
 	if (n_ret_value == IO_ERROR)
 	    break;
 	if (n_ret_value == FILE_NOT_FOUND) {
-	    reiserfs_warning ("vs-5340: reiserfs_delete_item: "
-			      "no items of the file %K found\n", p_s_item_key);
+	    reiserfs_warning (p_s_sb, "vs-5340: reiserfs_delete_item: "
+			      "no items of the file %K found", p_s_item_key);
 	    break;
 	}
     } /* while (1) */
@@ -1344,7 +1344,7 @@ int reiserfs_delete_item (struct reiserf
     do_balance(&s_del_balance, NULL, NULL, M_DELETE);
 
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota delete_item(): freeing %u, id=%u type=%c\n", quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
+    reiserfs_debug (p_s_sb, "reiserquota delete_item(): freeing %u, id=%u type=%c", quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
 #endif
     DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
 
@@ -1388,8 +1388,10 @@ void reiserfs_delete_solid_item (struct 
     while (1) {
 	retval = search_item (th->t_super, &cpu_key, &path);
 	if (retval == IO_ERROR) {
-	    reiserfs_warning ("vs-5350: reiserfs_delete_solid_item: "
-			      "i/o failure occurred trying to delete %K\n", &cpu_key);
+	    reiserfs_warning (th->t_super,
+			      "vs-5350: reiserfs_delete_solid_item: "
+			      "i/o failure occurred trying to delete %K",
+			      &cpu_key);
 	    break;
 	}
 	if (retval != ITEM_FOUND) {
@@ -1397,7 +1399,7 @@ void reiserfs_delete_solid_item (struct 
 	    // No need for a warning, if there is just no free space to insert '..' item into the newly-created subdir
 	    if ( !( (unsigned long long) GET_HASH_VALUE (le_key_k_offset (le_key_version (key), key)) == 0 && \
 		 (unsigned long long) GET_GENERATION_NUMBER (le_key_k_offset (le_key_version (key), key)) == 1 ) )
-		reiserfs_warning ("vs-5355: reiserfs_delete_solid_item: %k not found", key);
+		reiserfs_warning (th->t_super, "vs-5355: reiserfs_delete_solid_item: %k not found", key);
 	    break;
 	}
 	if (!tb_init) {
@@ -1417,7 +1419,7 @@ void reiserfs_delete_solid_item (struct 
 	    do_balance (&tb, 0, 0, M_DELETE);
 	    if (inode) {	/* Should we count quota for item? (we don't count quotas for save-links) */
 #ifdef REISERQUOTA_DEBUG
-		printk(KERN_DEBUG "reiserquota delete_solid_item(): freeing %u id=%u type=%c\n", quota_cut_bytes, inode->i_uid, key2type(key));
+		reiserfs_debug (th->t_super, "reiserquota delete_solid_item(): freeing %u id=%u type=%c", quota_cut_bytes, inode->i_uid, key2type(key));
 #endif
 		DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
 	    }
@@ -1425,8 +1427,8 @@ void reiserfs_delete_solid_item (struct 
 	}
 
 	// IO_ERROR, NO_DISK_SPACE, etc
-	reiserfs_warning ("vs-5360: reiserfs_delete_solid_item: "
-			  "could not delete %K due to fix_nodes failure\n", &cpu_key);
+	reiserfs_warning (th->t_super, "vs-5360: reiserfs_delete_solid_item: "
+			  "could not delete %K due to fix_nodes failure", &cpu_key);
 	unfix_nodes (&tb);
 	break;
     }
@@ -1520,7 +1522,7 @@ static void indirect_to_direct_roll_back
 	tail_len -= removed;
 	set_cpu_key_k_offset (&tail_key, cpu_key_k_offset (&tail_key) - removed);
     }
-    printk ("indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space\n");
+    reiserfs_warning (inode->i_sb, "indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space");
     //mark_file_without_tail (inode);
     mark_inode_dirty (inode);
 }
@@ -1612,7 +1614,7 @@ int reiserfs_cut_from_item (struct reise
 	if (n_ret_value == POSITION_FOUND)
 	    continue;
 
-	reiserfs_warning ("PAP-5610: reiserfs_cut_from_item: item %K not found\n", p_s_item_key);
+	reiserfs_warning (p_s_sb, "PAP-5610: reiserfs_cut_from_item: item %K not found", p_s_item_key);
 	unfix_nodes (&s_cut_balance);
 	return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
     } /* while */
@@ -1625,7 +1627,7 @@ int reiserfs_cut_from_item (struct reise
 	    indirect_to_direct_roll_back (th, p_s_inode, p_s_path);
 	}
 	if (n_ret_value == NO_DISK_SPACE)
-	    reiserfs_warning ("NO_DISK_SPACE");
+	    reiserfs_warning (p_s_sb, "NO_DISK_SPACE");
 	unfix_nodes (&s_cut_balance);
 	return -EIO;
     }
@@ -1691,7 +1693,7 @@ int reiserfs_cut_from_item (struct reise
 	REISERFS_I(p_s_inode)->i_flags &= ~i_pack_on_close_mask ;
     }
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota cut_from_item(): freeing %u id=%u type=%c\n", quota_cut_bytes, p_s_inode->i_uid, '?');
+    reiserfs_debug (p_s_inode->i_sb, "reiserquota cut_from_item(): freeing %u id=%u type=%c", quota_cut_bytes, p_s_inode->i_uid, '?');
 #endif
     DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
     return n_ret_value;
@@ -1700,7 +1702,8 @@ int reiserfs_cut_from_item (struct reise
 static void truncate_directory (struct reiserfs_transaction_handle *th, struct inode * inode)
 {
     if (inode->i_nlink)
-	reiserfs_warning ("vs-5655: truncate_directory: link count != 0\n");
+	reiserfs_warning (inode->i_sb,
+			  "vs-5655: truncate_directory: link count != 0");
 
     set_le_key_k_offset (KEY_FORMAT_3_5, INODE_PKEY (inode), DOT_OFFSET);
     set_le_key_k_type (KEY_FORMAT_3_5, INODE_PKEY (inode), TYPE_DIRENTRY);
@@ -1749,14 +1752,14 @@ void reiserfs_do_truncate (struct reiser
 
     retval = search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path);
     if (retval == IO_ERROR) {
-	reiserfs_warning ("vs-5657: reiserfs_do_truncate: "
-			  "i/o failure occurred trying to truncate %K\n", &s_item_key);
+	reiserfs_warning (p_s_inode->i_sb, "vs-5657: reiserfs_do_truncate: "
+			  "i/o failure occurred trying to truncate %K", &s_item_key);
 	return;
     }
     if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
 	pathrelse (&s_search_path);
-	reiserfs_warning ("PAP-5660: reiserfs_do_truncate: "
-			  "wrong result %d of search for %K\n", retval, &s_item_key);
+	reiserfs_warning (p_s_inode->i_sb, "PAP-5660: reiserfs_do_truncate: "
+			  "wrong result %d of search for %K", retval, &s_item_key);
 	return;
     }
 
@@ -1787,7 +1790,7 @@ void reiserfs_do_truncate (struct reiser
 	/* Cut or delete file item. */
 	n_deleted = reiserfs_cut_from_item(th, &s_search_path, &s_item_key, p_s_inode,  page, n_new_file_size);
 	if (n_deleted < 0) {
-	    reiserfs_warning ("vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed");
+	    reiserfs_warning (p_s_inode->i_sb, "vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed");
 	    reiserfs_check_path(&s_search_path) ;
 	    return;
 	}
@@ -1827,7 +1830,7 @@ void reiserfs_do_truncate (struct reiser
 	      search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path) == POSITION_FOUND )  ;
 
     RFALSE( n_file_size > ROUND_UP (n_new_file_size),
-	    "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d\n",
+	    "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d",
 	    n_new_file_size, n_file_size, s_item_key.on_disk_key.k_objectid);
 
 update_and_out:
@@ -1883,7 +1886,7 @@ int reiserfs_paste_into_item (struct rei
     fs_gen = get_generation(inode->i_sb) ;
 
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota paste_into_item(): allocating %u id=%u type=%c\n", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+    reiserfs_debug (inode->i_sb, "reiserquota paste_into_item(): allocating %u id=%u type=%c", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
 #endif
 
     if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
@@ -1911,7 +1914,7 @@ search_again:
 	    goto error_out ;
 	}
 	if (retval == POSITION_FOUND) {
-	    reiserfs_warning ("PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists\n", p_s_key);
+	    reiserfs_warning (inode->i_sb, "PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists", p_s_key);
 	    retval = -EEXIST ;
 	    goto error_out ;
 	}
@@ -1932,7 +1935,7 @@ error_out:
     /* this also releases the path */
     unfix_nodes(&s_paste_balance);
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota paste_into_item(): freeing %u id=%u type=%c\n", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+    reiserfs_debug (inode->i_sb, "reiserquota paste_into_item(): freeing %u id=%u type=%c", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
 #endif
     DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
     return retval ;
@@ -1963,7 +1966,7 @@ int reiserfs_insert_item(struct reiserfs
 	    quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE ;
 	}
 #ifdef REISERQUOTA_DEBUG
-	printk(KERN_DEBUG "reiserquota insert_item(): allocating %u id=%u type=%c\n", quota_bytes, inode->i_uid, head2type(p_s_ih));
+	reiserfs_debug (inode->i_sb, "reiserquota insert_item(): allocating %u id=%u type=%c", quota_bytes, inode->i_uid, head2type(p_s_ih));
 #endif
 	/* We can't dirty inode here. It would be immediately written but
 	 * appropriate stat item isn't inserted yet... */
@@ -1991,8 +1994,8 @@ search_again:
 	    goto error_out ;
 	}
 	if (retval == ITEM_FOUND) {
-	    reiserfs_warning ("PAP-5760: reiserfs_insert_item: "
-			      "key %K already exists in the tree\n", key);
+	    reiserfs_warning (th->t_super, "PAP-5760: reiserfs_insert_item: "
+			      "key %K already exists in the tree", key);
 	    retval = -EEXIST ;
 	    goto error_out; 
 	}
@@ -2009,7 +2012,7 @@ error_out:
     /* also releases the path */
     unfix_nodes(&s_ins_balance);
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota insert_item(): freeing %u id=%u type=%c\n", quota_bytes, inode->i_uid, head2type(p_s_ih));
+    reiserfs_debug (th->t_super, "reiserquota insert_item(): freeing %u id=%u type=%c", quota_bytes, inode->i_uid, head2type(p_s_ih));
 #endif
     if (inode)
 	DQUOT_FREE_SPACE_NODIRTY(inode, quota_bytes) ;
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/super.c linux-2.6.4.warnings/fs/reiserfs/super.c
--- linux-2.6.4/fs/reiserfs/super.c	2004-03-29 10:42:58.623170019 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/super.c	2004-03-29 11:13:52.519551683 -0500
@@ -150,7 +150,7 @@ static void finish_unfinished (struct su
     while (1) {
         retval = search_item (s, &max_cpu_key, &path);
         if (retval != ITEM_NOT_FOUND) {
-            reiserfs_warning ("vs-2140: finish_unfinished: search_by_key returned %d\n",
+            reiserfs_warning (s, "vs-2140: finish_unfinished: search_by_key returned %d",
                               retval);
             break;
         }
@@ -158,7 +158,7 @@ static void finish_unfinished (struct su
         bh = get_last_bh (&path);
         item_pos = get_item_pos (&path);
         if (item_pos != B_NR_ITEMS (bh)) {
-            reiserfs_warning ("vs-2060: finish_unfinished: wrong position found\n");
+            reiserfs_warning (s, "vs-2060: finish_unfinished: wrong position found");
             break;
         }
         item_pos --;
@@ -187,7 +187,7 @@ static void finish_unfinished (struct su
         if (!inode) {
             /* the unlink almost completed, it just did not manage to remove
 	       "save" link and release objectid */
-            reiserfs_warning ("vs-2180: finish_unfinished: iget failed for %K\n",
+            reiserfs_warning (s, "vs-2180: finish_unfinished: iget failed for %K",
                               &obj_key);
             remove_save_link_only (s, &save_link_key, 1);
             continue;
@@ -195,7 +195,7 @@ static void finish_unfinished (struct su
 
 	if (!truncate && inode->i_nlink) {
 	    /* file is not unlinked */
-            reiserfs_warning ("vs-2185: finish_unfinished: file %K is not unlinked\n",
+            reiserfs_warning (s, "vs-2185: finish_unfinished: file %K is not unlinked",
                               &obj_key);
             remove_save_link_only (s, &save_link_key, 0);
             continue;
@@ -206,7 +206,7 @@ static void finish_unfinished (struct su
 	       The only imaginable way is to execute unfinished truncate request
 	       then boot into old kernel, remove the file and create dir with
 	       the same key. */
-	    reiserfs_warning("green-2101: impossible truncate on a directory %k. Please report\n", INODE_PKEY (inode));
+	    reiserfs_warning(s, "green-2101: impossible truncate on a directory %k. Please report", INODE_PKEY (inode));
 	    remove_save_link_only (s, &save_link_key, 0);
 	    truncate = 0;
 	    iput (inode); 
@@ -217,14 +217,14 @@ static void finish_unfinished (struct su
             REISERFS_I(inode) -> i_flags |= i_link_saved_truncate_mask;
             /* not completed truncate found. New size was committed together
 	       with "save" link */
-            reiserfs_warning ("Truncating %k to %Ld ..",
+            reiserfs_info (s, "Truncating %k to %Ld ..",
                               INODE_PKEY (inode), inode->i_size);
             reiserfs_truncate_file (inode, 0/*don't update modification time*/);
             remove_save_link (inode, truncate);
         } else {
             REISERFS_I(inode) -> i_flags |= i_link_saved_unlink_mask;
             /* not completed unlink (rmdir) found */
-            reiserfs_warning ("Removing %k..", INODE_PKEY (inode));
+            reiserfs_info (s, "Removing %k..", INODE_PKEY (inode));
             /* removal gets completed in iput */
         }
  
@@ -236,7 +236,7 @@ static void finish_unfinished (struct su
      
     pathrelse (&path);
     if (done)
-        reiserfs_warning ("There were %d uncompleted unlinks/truncates. "
+        reiserfs_info (s, "There were %d uncompleted unlinks/truncates. "
                           "Completed\n", done);
 }
  
@@ -278,7 +278,7 @@ void add_save_link (struct reiserfs_tran
     } else {
 	/* truncate */
 	if (S_ISDIR (inode->i_mode))
-	    reiserfs_warning("green-2102: Adding a truncate savelink for a directory %k! Please report\n", INODE_PKEY(inode));
+	    reiserfs_warning(inode->i_sb, "green-2102: Adding a truncate savelink for a directory %k! Please report", INODE_PKEY(inode));
 	set_cpu_key_k_offset (&key, 1);
 	set_cpu_key_k_type (&key, TYPE_INDIRECT);
 
@@ -292,8 +292,8 @@ void add_save_link (struct reiserfs_tran
     retval = search_item (inode->i_sb, &key, &path);
     if (retval != ITEM_NOT_FOUND) {
 	if ( retval != -ENOSPC )
-	    reiserfs_warning ("vs-2100: add_save_link:"
-			  "search_by_key (%K) returned %d\n", &key, retval);
+	    reiserfs_warning (inode->i_sb, "vs-2100: add_save_link:"
+			  "search_by_key (%K) returned %d", &key, retval);
 	pathrelse (&path);
 	return;
     }
@@ -305,7 +305,7 @@ void add_save_link (struct reiserfs_tran
     retval = reiserfs_insert_item (th, &path, &key, &ih, NULL, (char *)&link);
     if (retval) {
 	if (retval != -ENOSPC)
-	    reiserfs_warning ("vs-2120: add_save_link: insert_item returned %d\n",
+	    reiserfs_warning (inode->i_sb, "vs-2120: add_save_link: insert_item returned %d",
 			  retval);
     } else {
 	if( truncate )
@@ -394,12 +394,12 @@ static void reiserfs_put_super (struct s
   print_statistics (s);
 
   if (REISERFS_SB(s)->s_kmallocs != 0) {
-    reiserfs_warning ("vs-2004: reiserfs_put_super: allocated memory left %d\n",
+    reiserfs_warning (s, "vs-2004: reiserfs_put_super: allocated memory left %d",
 		      REISERFS_SB(s)->s_kmallocs);
   }
 
   if (REISERFS_SB(s)->reserved_blocks != 0) {
-    reiserfs_warning ("green-2005: reiserfs_put_super: reserved blocks left %d\n",
+    reiserfs_warning (s, "green-2005: reiserfs_put_super: reserved blocks left %d",
 		      REISERFS_SB(s)->reserved_blocks);
   }
 
@@ -454,7 +454,7 @@ static int init_inodecache(void)
 static void destroy_inodecache(void)
 {
 	if (kmem_cache_destroy(reiserfs_inode_cachep))
-		printk(KERN_INFO "reiserfs_inode_cache: not all structures were freed\n");
+		reiserfs_warning (NULL, "reiserfs_inode_cache: not all structures were freed");
 }
 
 /* we don't mark inodes dirty, we just log them */
@@ -462,7 +462,7 @@ static void reiserfs_dirty_inode (struct
     struct reiserfs_transaction_handle th ;
 
     if (inode->i_sb->s_flags & MS_RDONLY) {
-        reiserfs_warning("clm-6006: writing inode %lu on readonly FS\n", 
+        reiserfs_warning(inode->i_sb, "clm-6006: writing inode %lu on readonly FS", 
 	                  inode->i_ino) ;
         return ;
     }
@@ -624,7 +624,7 @@ static int reiserfs_getopt ( struct supe
 	}
     }
     if (!opt->option_name) {
-	printk ("reiserfs_getopt: unknown option \"%s\"\n", p);
+	reiserfs_warning (s, "unknown mount option \"%s\"", p);
 	return -1;
     }
     
@@ -632,7 +632,7 @@ static int reiserfs_getopt ( struct supe
     switch (*p) {
     case '=':
 	if (!opt->arg_required) {
-	    printk ("reiserfs_getopt: the option \"%s\" does not require an argument\n",
+	    reiserfs_warning (s, "the option \"%s\" does not require an argument",
 		    opt->option_name);
 	    return -1;
 	}
@@ -640,12 +640,12 @@ static int reiserfs_getopt ( struct supe
 	
     case 0:
 	if (opt->arg_required) {
-	    printk ("reiserfs_getopt: the option \"%s\" requires an argument\n", opt->option_name);
+	    reiserfs_warning (s, "the option \"%s\" requires an argument", opt->option_name);
 	    return -1;
 	}
 	break;
     default:
-	printk ("reiserfs_getopt: head of option \"%s\" is only correct\n", opt->option_name);
+	reiserfs_warning (s, "head of option \"%s\" is only correct", opt->option_name);
 	return -1;
     }
 	
@@ -654,7 +654,7 @@ static int reiserfs_getopt ( struct supe
     
     if ( opt->arg_required && !strlen (p) ) {
 	/* this catches "option=," */
-	printk ("reiserfs_getopt: empty argument for \"%s\"\n", opt->option_name);
+	reiserfs_warning (s, "empty argument for \"%s\"", opt->option_name);
 	return -1;
     }
     
@@ -675,7 +675,7 @@ static int reiserfs_getopt ( struct supe
 	}
     }
     
-    printk ("reiserfs_getopt: bad value \"%s\" for option \"%s\"\n", p, opt->option_name);
+    reiserfs_warning (s, "bad value \"%s\" for option \"%s\"", p, opt->option_name);
     return -1;
 }
 
@@ -737,7 +737,7 @@ static int reiserfs_parse_options (struc
 	    *blocks = simple_strtoul (arg, &p, 0);
 	    if (*p != '\0') {
 		/* NNN does not look like a number */
-		printk ("reiserfs_parse_options: bad value %s\n", arg);
+		reiserfs_warning (s, "reiserfs_parse_options: bad value %s", arg);
 		return 0;
 	    }
 	}
@@ -747,7 +747,7 @@ static int reiserfs_parse_options (struc
 		int val = simple_strtoul (arg, &p, 0);
 		/* commit=NNN (time in seconds) */
 		if ( *p != '\0' || val == 0) {
-			printk ("reiserfs_parse_options: bad value %s\n", arg);
+			reiserfs_warning (s, "reiserfs_parse_options: bad value %s", arg);
 			return 0;
 		}
 		if ( val > 0 ) {
@@ -760,7 +760,7 @@ static int reiserfs_parse_options (struc
 		int val = simple_strtoul (arg, &p, 0);
 
 		if ( *p != '\0') {
-		    printk ("reiserfs_parse_options: non-numeric value %s for nolargeio option\n", arg);
+		    reiserfs_warning (s, "reiserfs_parse_options: non-numeric value %s for nolargeio option", arg);
 		    return 0;
 		}
 		if ( val ) 
@@ -772,7 +772,7 @@ static int reiserfs_parse_options (struc
 	if (c == 'j') {
 	    if (arg && *arg && jdev_name) {
 		if ( *jdev_name ) { //Hm, already assigned?
-		    printk("reiserfs_parse_options: journal device was already  specified to be %s\n", *jdev_name);
+		    reiserfs_warning (s, "reiserfs_parse_options: journal device was already  specified to be %s", *jdev_name);
 		    return 0;
 		}
 		*jdev_name = arg;
@@ -795,17 +795,17 @@ static void handle_data_mode(struct supe
     if (mount_options & (1 << REISERFS_DATA_LOG)) {
         if (!reiserfs_data_log(s)) {
 	    switch_data_mode(s, REISERFS_DATA_LOG);
-	    printk("reiserfs: switching to journaled data mode\n");
+	    reiserfs_info (s, "switching to journaled data mode\n");
 	}
     } else if (mount_options & (1 << REISERFS_DATA_ORDERED)) {
         if (!reiserfs_data_ordered(s)) {
 	    switch_data_mode(s, REISERFS_DATA_ORDERED);
-	    printk("reiserfs: switching to ordered data mode\n");
+	    reiserfs_info (s, "switching to ordered data mode\n");
 	}
     } else if (mount_options & (1 << REISERFS_DATA_WRITEBACK)) {
         if (!reiserfs_data_writeback(s)) {
 	    switch_data_mode(s, REISERFS_DATA_WRITEBACK);
-	    printk("reiserfs: switching to writeback data mode\n");
+	    reiserfs_info (s, "switching to writeback data mode\n");
 	}
     }
 }
@@ -817,12 +817,12 @@ static void handle_attrs( struct super_b
 	if( reiserfs_attrs( s ) ) {
 		rs = SB_DISK_SUPER_BLOCK (s);
 		if( old_format_only(s) ) {
-			reiserfs_warning( "reiserfs: cannot support attributes on 3.5.x disk format\n" );
+			reiserfs_warning(s, "reiserfs: cannot support attributes on 3.5.x disk format" );
 			REISERFS_SB(s) -> s_mount_opt &= ~ ( 1 << REISERFS_ATTRS );
 			return;
 		}
 		if( !( le32_to_cpu( rs -> s_flags ) & reiserfs_attrs_cleared ) ) {
-				reiserfs_warning( "reiserfs: cannot support attributes until flag is set in super-block\n" );
+				reiserfs_warning(s, "reiserfs: cannot support attributes until flag is set in super-block" );
 				REISERFS_SB(s) -> s_mount_opt &= ~ ( 1 << REISERFS_ATTRS );
 		}
 	}
@@ -966,7 +966,7 @@ static void load_bitmap_info_data (struc
 
 #ifdef CONFIG_REISERFS_CHECK
 // This outputs a lot of unneded info on big FSes
-//    reiserfs_warning ("bitmap loaded from block %d: %d free blocks\n",
+//    reiserfs_warning ("bitmap loaded from block %d: %d free blocks",
 //		      bi->bh->b_blocknr, bi->free_count);
 #endif
 }
@@ -988,8 +988,8 @@ static int read_bitmaps (struct super_bl
     for (i = 0; i < SB_BMAP_NR(s); i++) {
 	wait_on_buffer(SB_AP_BITMAP (s)[i].bh);
 	if (!buffer_uptodate(SB_AP_BITMAP(s)[i].bh)) {
-	    reiserfs_warning("sh-2029: reiserfs read_bitmaps: "
-			 "bitmap block (#%lu) reading failed\n",
+	    reiserfs_warning(s,"sh-2029: reiserfs read_bitmaps: "
+			 "bitmap block (#%lu) reading failed",
 			 SB_AP_BITMAP(s)[i].bh->b_blocknr);
 	    for (i = 0; i < SB_BMAP_NR(s); i++)
 		brelse(SB_AP_BITMAP(s)[i].bh);
@@ -1039,7 +1039,7 @@ void check_bitmap (struct super_block * 
   }
 
   if (free != SB_FREE_BLOCKS (s))
-    reiserfs_warning ("vs-4000: check_bitmap: %d free blocks, must be %d\n",
+    reiserfs_warning (s,"vs-4000: check_bitmap: %d free blocks, must be %d",
 		      free, SB_FREE_BLOCKS (s));
 }
 
@@ -1052,8 +1052,8 @@ static int read_super_block (struct supe
 
     bh = sb_bread (s, offset / s->s_blocksize);
     if (!bh) {
-      printk ("sh-2006: read_super_block: "
-              "bread failed (dev %s, block %lu, size %lu)\n",
+      reiserfs_warning (s, "sh-2006: read_super_block: "
+              "bread failed (dev %s, block %lu, size %lu)",
               reiserfs_bdevname (s), offset / s->s_blocksize, s->s_blocksize);
       return 1;
     }
@@ -1073,7 +1073,7 @@ static int read_super_block (struct supe
     
     bh = sb_bread (s, offset / s->s_blocksize);
     if (!bh) {
-	printk("sh-2007: read_super_block: "
+	reiserfs_warning (s, "sh-2007: read_super_block: "
                 "bread failed (dev %s, block %lu, size %lu)\n",
                 reiserfs_bdevname (s), offset / s->s_blocksize, s->s_blocksize);
 	return 1;
@@ -1081,7 +1081,7 @@ static int read_super_block (struct supe
     
     rs = (struct reiserfs_super_block *)bh->b_data;
     if (sb_blocksize(rs) != s->s_blocksize) {
-	printk ("sh-2011: read_super_block: "
+	reiserfs_warning (s, "sh-2011: read_super_block: "
 		"can't find a reiserfs filesystem on (dev %s, block %Lu, size %lu)\n",
 		reiserfs_bdevname (s), (unsigned long long)bh->b_blocknr, s->s_blocksize);
 	brelse (bh);
@@ -1090,9 +1090,9 @@ static int read_super_block (struct supe
 
     if ( rs->s_v1.s_root_block == -1 ) {
        brelse(bh) ;
-       printk("dev %s: Unfinished reiserfsck --rebuild-tree run detected. Please run\n"
+       reiserfs_warning (s, "Unfinished reiserfsck --rebuild-tree run detected. Please run\n"
               "reiserfsck --rebuild-tree and wait for a completion. If that fails\n"
-              "get newer reiserfsprogs package\n", reiserfs_bdevname (s));
+              "get newer reiserfsprogs package");
        return 1;
     }
 
@@ -1103,21 +1103,22 @@ static int read_super_block (struct supe
 	/* magic is of non-standard journal filesystem, look at s_version to
 	   find which format is in use */
 	if (sb_version(rs) == REISERFS_VERSION_2)
-	  printk ("read_super_block: found reiserfs format \"3.6\" "
-		  "with non-standard journal\n");
+	  reiserfs_warning (s, "read_super_block: found reiserfs format \"3.6\""
+		  " with non-standard journal");
 	else if (sb_version(rs) == REISERFS_VERSION_1)
-	  printk ("read_super_block: found reiserfs format \"3.5\" "
-		  "with non-standard journal\n");
+	  reiserfs_warning (s, "read_super_block: found reiserfs format \"3.5\""
+		  " with non-standard journal");
 	else {
-	  printk ("sh-2012: read_super_block: found unknown format \"%u\" "
-	            "of reiserfs with non-standard magic\n", sb_version(rs));
+	  reiserfs_warning (s, "sh-2012: read_super_block: found unknown "
+			    "format \"%u\" of reiserfs with non-standard magic",
+			    sb_version(rs));
 	return 1;
 	}
     }
     else
       /* s_version of standard format may contain incorrect information,
 	 so we just look at the magic string */
-      printk ("found reiserfs format \"%s\" with standard journal\n",
+      reiserfs_info (s, "found reiserfs format \"%s\" with standard journal\n",
 	      is_reiserfs_3_5 (rs) ? "3.5" : "3.6");
 
     s->s_op = &reiserfs_sops;
@@ -1138,7 +1139,7 @@ static int reread_meta_blocks(struct sup
   ll_rw_block(READ, 1, &(SB_BUFFER_WITH_SB(s))) ;
   wait_on_buffer(SB_BUFFER_WITH_SB(s)) ;
   if (!buffer_uptodate(SB_BUFFER_WITH_SB(s))) {
-    printk("reread_meta_blocks, error reading the super\n") ;
+    reiserfs_warning (s, "reread_meta_blocks, error reading the super") ;
     return 1 ;
   }
 
@@ -1146,7 +1147,7 @@ static int reread_meta_blocks(struct sup
     ll_rw_block(READ, 1, &(SB_AP_BITMAP(s)[i].bh)) ;
     wait_on_buffer(SB_AP_BITMAP(s)[i].bh) ;
     if (!buffer_uptodate(SB_AP_BITMAP(s)[i].bh)) {
-      printk("reread_meta_blocks, error reading bitmap block number %d at %llu\n", 
+      reiserfs_warning (s, "reread_meta_blocks, error reading bitmap block number %d at %llu", 
         i, (unsigned long long)SB_AP_BITMAP(s)[i].bh->b_blocknr) ;
       return 1 ;
     }
@@ -1193,8 +1194,8 @@ __u32 find_hash_out (struct super_block 
 	    if (reiserfs_rupasov_hash(s)) {
 		hash = YURA_HASH ;
 	    }
-	    reiserfs_warning("reiserfs: FS seems to be empty, autodetect "
-	                     "is using the default hash\n");
+	    reiserfs_warning(s,"FS seems to be empty, autodetect "
+	                     "is using the default hash");
 	    break;
 	}
 	r5hash=GET_HASH_VALUE (r5_hash (de.de_name, de.de_namelen));
@@ -1203,9 +1204,9 @@ __u32 find_hash_out (struct super_block 
 	if ( ( (teahash == r5hash) && (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num]))) == r5hash) ) ||
 	     ( (teahash == yurahash) && (yurahash == GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])))) ) ||
 	     ( (r5hash == yurahash) && (yurahash == GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])))) ) ) {
-	    reiserfs_warning("reiserfs: Unable to automatically detect hash"
-		"function for device %s\n"
-		"please mount with -o hash={tea,rupasov,r5}\n", reiserfs_bdevname (s));
+	    reiserfs_warning(s,"Unable to automatically detect hash function. "
+			     "Please mount with -o hash={tea,rupasov,r5}",
+			     reiserfs_bdevname (s));
 	    hash = UNSET_HASH;
 	    break;
 	}
@@ -1216,8 +1217,7 @@ __u32 find_hash_out (struct super_block 
 	else if (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])) ) == r5hash)
 	    hash = R5_HASH;
 	else {
-	    reiserfs_warning("reiserfs: Unrecognised hash function for "
-			     "device %s\n", reiserfs_bdevname (s));
+	    reiserfs_warning (s,"Unrecognised hash function");
 	    hash = UNSET_HASH;
 	}
     } while (0);
@@ -1245,16 +1245,16 @@ static int what_hash (struct super_block
 	** mount options 
 	*/
 	if (reiserfs_rupasov_hash(s) && code != YURA_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force rupasov hash\n", reiserfs_hashname(code)) ;
+	    reiserfs_warning (s, "Error, %s hash detected, "
+		   "unable to force rupasov hash", reiserfs_hashname(code)) ;
 	    code = UNSET_HASH ;
 	} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force tea hash\n", reiserfs_hashname(code)) ;
+	    reiserfs_warning (s, "Error, %s hash detected, "
+		   "unable to force tea hash", reiserfs_hashname(code)) ;
 	    code = UNSET_HASH ;
 	} else if (reiserfs_r5_hash(s) && code != R5_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force r5 hash\n", reiserfs_hashname(code)) ;
+	    reiserfs_warning (s, "Error, %s hash detected, "
+		   "unable to force r5 hash", reiserfs_hashname(code)) ;
 	    code = UNSET_HASH ;
 	} 
     } else { 
@@ -1284,13 +1284,13 @@ static hashf_t hash_function (struct sup
 {
     switch (what_hash (s)) {
     case TEA_HASH:
-	reiserfs_warning ("Using tea hash to sort names\n");
+	reiserfs_info (s, "Using tea hash to sort names\n");
 	return keyed_hash;
     case YURA_HASH:
-	reiserfs_warning ("Using rupasov hash to sort names\n");
+	reiserfs_info (s, "Using rupasov hash to sort names\n");
 	return yura_hash;
     case R5_HASH:
-	reiserfs_warning ("Using r5 hash to sort names\n");
+	reiserfs_info (s, "Using r5 hash to sort names\n");
 	return r5_hash;
     }
     return NULL;
@@ -1311,9 +1311,9 @@ int function2code (hashf_t func)
     return 0;
 }
 
-#define SPRINTK(silent, ...)			\
+#define SWARN(silent, s, ...)			\
 	if (!(silent))				\
-		printk(__VA_ARGS__)
+		reiserfs_warning (s, __VA_ARGS__)
 
 static int reiserfs_fill_super (struct super_block * s, void * data, int silent)
 {
@@ -1354,7 +1354,8 @@ static int reiserfs_fill_super (struct s
     }
 
     if (blocks) {
-	SPRINTK(silent, "jmacd-7: reiserfs_fill_super: resize option for remount only\n");
+	SWARN (silent, s, "jmacd-7: reiserfs_fill_super: resize option "
+	       "for remount only");
 	goto error;
     }	
 
@@ -1363,7 +1364,7 @@ static int reiserfs_fill_super (struct s
       old_format = 1;
     /* try new format (64-th 1k block), which can contain reiserfs super block */
     else if (read_super_block (s, REISERFS_DISK_OFFSET_IN_BYTES)) {
-      SPRINTK(silent, "sh-2021: reiserfs_fill_super: can not find reiserfs on %s\n", reiserfs_bdevname (s));
+      SWARN(silent, s, "sh-2021: reiserfs_fill_super: can not find reiserfs on %s", reiserfs_bdevname (s));
       goto error;
     }
 
@@ -1372,9 +1373,9 @@ static int reiserfs_fill_super (struct s
        smaller than the filesystem. If the check fails then abort and scream,
        because bad stuff will happen otherwise. */
     if ( s->s_bdev && s->s_bdev->bd_inode && i_size_read(s->s_bdev->bd_inode) < sb_block_count(rs)*sb_blocksize(rs)) {
-	SPRINTK(silent, "Filesystem on %s cannot be mounted because it is bigger than the device\n", reiserfs_bdevname(s));
-	SPRINTK(silent, "You may need to run fsck or increase size of your LVM partition\n");
-	SPRINTK(silent, "Or may be you forgot to reboot after fdisk when it told you to\n");
+	SWARN (silent, s, "Filesystem on %s cannot be mounted because it is bigger than the device", reiserfs_bdevname(s));
+	SWARN(silent, s, "You may need to run fsck or increase size of your LVM partition");
+	SWARN(silent, s, "Or may be you forgot to reboot after fdisk when it told you to");
 	goto error;
     }
 
@@ -1382,12 +1383,12 @@ static int reiserfs_fill_super (struct s
     sbi->s_mount_state = REISERFS_VALID_FS ;
 
     if (old_format ? read_old_bitmaps(s) : read_bitmaps(s)) {
-	SPRINTK(silent, "jmacd-8: reiserfs_fill_super: unable to read bitmap\n");
+	SWARN(silent, s, "jmacd-8: reiserfs_fill_super: unable to read bitmap");
 	goto error;
     }
 #ifdef CONFIG_REISERFS_CHECK
-    SPRINTK(silent, "reiserfs:warning: CONFIG_REISERFS_CHECK is set ON\n");
-    SPRINTK(silent, "reiserfs:warning: - it is slow mode for debugging.\n");
+    SWARN (silent, s, "CONFIG_REISERFS_CHECK is set ON");
+    SWARN (silent, s, "- it is slow mode for debugging.");
 #endif
 
     /* make data=ordered the default */
@@ -1398,16 +1399,16 @@ static int reiserfs_fill_super (struct s
     }
 
     if (reiserfs_data_log(s)) {
-        printk("reiserfs: using journaled data mode\n");
+        reiserfs_info (s, "using journaled data mode\n");
     } else if (reiserfs_data_ordered(s)) {
-        printk("reiserfs: using ordered data mode\n");
+        reiserfs_info (s, "using ordered data mode\n");
     } else {
-        printk("reiserfs: using writeback data mode\n");
+        reiserfs_info (s, "using writeback data mode\n");
     }
 
     // set_device_ro(s->s_dev, 1) ;
     if( journal_init(s, jdev_name, old_format, commit_max_age) ) {
-	SPRINTK(silent, "sh-2022: reiserfs_fill_super: unable to initialize journal space\n") ;
+	SWARN(silent, s, "sh-2022: reiserfs_fill_super: unable to initialize journal space") ;
 	goto error ;
     } else {
 	jinit_done = 1 ; /* once this is set, journal_release must be called
@@ -1415,7 +1416,7 @@ static int reiserfs_fill_super (struct s
 			 */
     }
     if (reread_meta_blocks(s)) {
-	SPRINTK(silent, "jmacd-9: reiserfs_fill_super: unable to reread meta blocks after journal init\n") ;
+	SWARN(silent, s, "jmacd-9: reiserfs_fill_super: unable to reread meta blocks after journal init") ;
 	goto error ;
     }
 
@@ -1423,14 +1424,14 @@ static int reiserfs_fill_super (struct s
 	goto error;
 
     if (bdev_read_only(s->s_bdev) && !(s->s_flags & MS_RDONLY)) {
-        SPRINTK(silent, "clm-7000: Detected readonly device, marking FS readonly\n") ;
+        SWARN(silent, s, "clm-7000: Detected readonly device, marking FS readonly") ;
 	s->s_flags |= MS_RDONLY ;
     }
     args.objectid = REISERFS_ROOT_OBJECTID ;
     args.dirid = REISERFS_ROOT_PARENT_OBJECTID ;
     root_inode = iget5_locked (s, REISERFS_ROOT_OBJECTID, reiserfs_find_actor, reiserfs_init_locked_inode, (void *)(&args));
     if (!root_inode) {
-	SPRINTK(silent, "jmacd-10: reiserfs_fill_super: get root inode failed\n");
+	SWARN(silent, s, "jmacd-10: reiserfs_fill_super: get root inode failed");
 	goto error;
     }
 
@@ -1472,7 +1473,7 @@ static int reiserfs_fill_super (struct s
 	  if (convert_reiserfs (s)) {
 	    /* and -o conv is given */
 	    if(!silent)
-	      reiserfs_warning ("reiserfs: converting 3.5 filesystem to the 3.6 format\n") ;
+	      reiserfs_info (s,"converting 3.5 filesystem to the 3.6 format") ;
 
 	    if (is_reiserfs_3_5 (rs))
 	      /* put magic string of 3.6 format. 2.2 will not be able to
@@ -1485,7 +1486,7 @@ static int reiserfs_fill_super (struct s
 	    set_bit(REISERFS_3_6, &(sbi->s_properties));
 	    clear_bit(REISERFS_3_5, &(sbi->s_properties));
 	  } else if (!silent){
-	    reiserfs_warning("reiserfs: using 3.5.x disk format\n") ;
+	    reiserfs_info (s, "using 3.5.x disk format\n") ;
 	  }
 	}
 
@@ -1502,7 +1503,7 @@ static int reiserfs_fill_super (struct s
 	finish_unfinished (s);
     } else {
 	if ( old_format_only(s) && !silent) {
-	    reiserfs_warning("reiserfs: using 3.5.x disk format\n") ;
+	    reiserfs_info (s, "using 3.5.x disk format\n") ;
 	}
 
 	if (reiserfs_xattr_init (s, s->s_flags)) {
Binary files linux-2.6.4/fs/reiserfs/.super.c.swp and linux-2.6.4.warnings/fs/reiserfs/.super.c.swp differ
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/tail_conversion.c linux-2.6.4.warnings/fs/reiserfs/tail_conversion.c
--- linux-2.6.4/fs/reiserfs/tail_conversion.c	2004-03-29 10:42:57.334405508 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/tail_conversion.c	2004-03-29 10:43:44.917711208 -0500
@@ -50,9 +50,9 @@ int direct2indirect (struct reiserfs_tra
 
     // FIXME: we could avoid this 
     if ( search_for_position_by_key (sb, &end_key, path) == POSITION_FOUND ) {
-	reiserfs_warning ("PAP-14030: direct2indirect: "
+	reiserfs_warning (sb, "PAP-14030: direct2indirect: "
 			"pasted or inserted byte exists in the tree %K. "
-			"Use fsck to repair.\n", &end_key);
+			"Use fsck to repair.", &end_key);
 	pathrelse(path);
 	return -EIO;
     }
diff -ruNp -x '*~' linux-2.6.4/fs/reiserfs/xattr.c linux-2.6.4.warnings/fs/reiserfs/xattr.c
--- linux-2.6.4/fs/reiserfs/xattr.c	2004-03-29 10:42:50.330685264 -0500
+++ linux-2.6.4.warnings/fs/reiserfs/xattr.c	2004-03-29 10:43:44.918711025 -0500
@@ -326,7 +326,7 @@ research:
 	ih = de.de_ih;
 
 	if (!is_direntry_le_ih(ih)) {
-            reiserfs_warning("not direntry %h\n", ih);
+            reiserfs_warning(inode->i_sb, "not direntry %h", ih);
 	    break;
         }
 	copy_item_head(&tmp_ih, ih);
@@ -671,9 +671,8 @@ reiserfs_xattr_get (const struct inode *
             if (rxh->h_magic != cpu_to_le32 (REISERFS_XATTR_MAGIC)) {
                 unlock_page (page);
                 reiserfs_put_page (page);
-                reiserfs_warning ("reiserfs: Invalid magic for xattr (%s) "
-                                  "associated with %s %k\n", name,
-                                  reiserfs_bdevname (inode->i_sb),
+                reiserfs_warning (inode->i_sb, "Invalid magic for xattr (%s) "
+                                  "associated with %k", name,
                                   INODE_PKEY (inode));
                 err = -EIO;
                 goto out_dput;
@@ -690,9 +689,8 @@ reiserfs_xattr_get (const struct inode *
     err = isize - sizeof (struct reiserfs_xattr_header);
 
     if (xattr_hash (buffer, isize - sizeof (struct reiserfs_xattr_header)) != hash) {
-        reiserfs_warning ("reiserfs: Invalid hash for xattr (%s) associated "
-                          "with %s %k\n", name,
-                          reiserfs_bdevname (inode->i_sb), INODE_PKEY (inode));
+        reiserfs_warning (inode->i_sb, "Invalid hash for xattr (%s) associated "
+                          "with %k", name, INODE_PKEY (inode));
         err = -EIO;
     }
 
@@ -724,7 +722,8 @@ __reiserfs_xattr_del (struct dentry *xad
         goto out_file;
 
     if (!is_reiserfs_priv_object (dentry->d_inode)) {
-        reiserfs_warning ("OID %08x [%.*s/%.*s] doesn't have priv flag set [parent is %sset].\n",
+        reiserfs_warning (dir->i_sb, "OID %08x [%.*s/%.*s] doesn't have "
+                                     "priv flag set [parent is %sset].",
                         le32_to_cpu (INODE_PKEY (dentry->d_inode)->k_objectid),
                         xadir->d_name.len, xadir->d_name.name, namelen, name,
                         is_reiserfs_priv_object (xadir->d_inode) ? "" : "not ");
@@ -828,7 +827,8 @@ reiserfs_delete_xattrs (struct inode *in
         reiserfs_write_unlock_xattrs (inode->i_sb);
         dput (root);
     } else {
-        reiserfs_warning ("Couldn't remove all entries in directory\n");
+        reiserfs_warning (inode->i_sb,
+                          "Couldn't remove all entries in directory");
     }
     unlock_kernel ();
 
@@ -1265,8 +1265,8 @@ reiserfs_xattr_init (struct super_block 
   } else if (reiserfs_xattrs_optional (s)) {
     /* Old format filesystem, but optional xattrs have been enabled
      * at mount time. Error out. */
-    reiserfs_warning ("reiserfs: xattrs/ACLs not supported on pre v3.6 "
-                      "format filesystem. Failing mount.\n");
+    reiserfs_warning (s, "xattrs/ACLs not supported on pre v3.6 "
+                      "format filesystem. Failing mount.");
     err = -EOPNOTSUPP;
     goto error;
   } else {
@@ -1292,8 +1292,8 @@ reiserfs_xattr_init (struct super_block 
             }
 
             if (dentry && dentry->d_inode)
-                reiserfs_warning ("reiserfs: Created %s on %s - reserved for "
-                                  "xattr storage.\n", PRIVROOT_NAME, 
+                reiserfs_warning (s, "Created %s on %s - reserved for "
+                                  "xattr storage.", PRIVROOT_NAME, 
                                   reiserfs_bdevname (inode->i_sb));
         } else if (!dentry->d_inode) {
             dput (dentry);
@@ -1310,8 +1310,8 @@ reiserfs_xattr_init (struct super_block 
           /* If we're read-only it just means that the dir hasn't been
            * created. Not an error -- just no xattrs on the fs. We'll
            * check again if we go read-write */
-          reiserfs_warning ("reiserfs: xattrs/ACLs enabled and couldn't "
-                            "find/create .reiserfs_priv. Failing mount.\n");
+          reiserfs_warning (s, "xattrs/ACLs enabled and couldn't "
+                            "find/create .reiserfs_priv. Failing mount.");
           err = -EOPNOTSUPP;
       }
   }
diff -ruNp -x '*~' linux-2.6.4/include/linux/reiserfs_fs.h linux-2.6.4.warnings/include/linux/reiserfs_fs.h
--- linux-2.6.4/include/linux/reiserfs_fs.h	2004-03-29 10:42:49.548828130 -0500
+++ linux-2.6.4.warnings/include/linux/reiserfs_fs.h	2004-03-29 11:07:32.600949071 -0500
@@ -75,6 +75,7 @@
 */
 #define REISERFS_DEBUG_CODE 5 /* extra messages to help find/debug errors */ 
 
+void reiserfs_warning (struct super_block *s, const char * fmt, ...);
 /* assertions handling */
 
 /** always check a condition and panic if it's false. */
@@ -562,9 +563,6 @@ struct item_head
 #define V1_DIRENTRY_UNIQUENESS 500
 #define V1_ANY_UNIQUENESS 555 // FIXME: comment is required
 
-extern void reiserfs_warning (const char * fmt, ...);
-/* __attribute__( ( format ( printf, 1, 2 ) ) ); */
-
 //
 // here are conversion routines
 //
@@ -577,7 +575,8 @@ static inline int uniqueness2type (__u32
     case V1_DIRECT_UNIQUENESS: return TYPE_DIRECT;
     case V1_DIRENTRY_UNIQUENESS: return TYPE_DIRENTRY;
     default:
-	    reiserfs_warning( "vs-500: unknown uniqueness %d\n", uniqueness);
+	    reiserfs_warning (NULL, "vs-500: unknown uniqueness %d",
+			      uniqueness);
 	case V1_ANY_UNIQUENESS:
 	    return TYPE_ANY;
     }
@@ -592,7 +591,7 @@ static inline __u32 type2uniqueness (int
     case TYPE_DIRECT: return V1_DIRECT_UNIQUENESS;
     case TYPE_DIRENTRY: return V1_DIRENTRY_UNIQUENESS;
     default:
-	    reiserfs_warning( "vs-501: unknown type %d\n", type);
+	    reiserfs_warning (NULL, "vs-501: unknown type %d", type);
 	case TYPE_ANY:
 	    return V1_ANY_UNIQUENESS;
     }
@@ -1771,7 +1770,7 @@ void reiserfs_update_inode_transaction(s
 void reiserfs_wait_on_write_block(struct super_block *s) ;
 void reiserfs_block_writes(struct reiserfs_transaction_handle *th) ;
 void reiserfs_allow_writes(struct super_block *s) ;
-void reiserfs_check_lock_depth(char *caller) ;
+void reiserfs_check_lock_depth(struct super_block *s, char *caller) ;
 int reiserfs_prepare_for_journal(struct super_block *, struct buffer_head *bh, int wait) ;
 void reiserfs_restore_prepared_buffer(struct super_block *, struct buffer_head *bh) ;
 int journal_init(struct super_block *, const char * j_dev_name, int old_format, unsigned int) ;
@@ -2053,10 +2052,10 @@ void free_buffers_in_tb (struct tree_bal
 
 
 /* prints.c */
-void reiserfs_panic (struct super_block * s, const char * fmt, ...)
-__attribute__ ( ( noreturn ) );/* __attribute__( ( format ( printf, 2, 3 ) ) ) */
+void reiserfs_panic (struct super_block * s, const char * fmt, ...) __attribute__ ( ( noreturn ) );
+void reiserfs_info (struct super_block *s, const char * fmt, ...);
+void reiserfs_printk (const char * fmt, ...);
 void reiserfs_debug (struct super_block *s, int level, const char * fmt, ...);
-/* __attribute__( ( format ( printf, 3, 4 ) ) ); */
 void print_virtual_node (struct virtual_node * vn);
 void print_indirect_item (struct buffer_head * bh, int item_num);
 void store_print_tb (struct tree_balance * tb);
