Index: linux.t/arch/x86_64/mm/init.c
===================================================================
--- linux.t.orig/arch/x86_64/mm/init.c	2004-04-28 13:54:50.000000000 -0400
+++ linux.t/arch/x86_64/mm/init.c	2004-04-28 20:42:55.000000000 -0400
@@ -374,7 +374,7 @@ void __init clear_kernel_mapping(unsigne
 	__flush_tlb_all();
 } 
 
-static inline int page_is_ram (unsigned long pagenr)
+inline int page_is_ram (unsigned long pagenr)
 {
 	int i;
 
Index: linux.t/arch/x86_64/boot/Makefile
===================================================================
--- linux.t.orig/arch/x86_64/boot/Makefile	2004-01-09 01:59:26.000000000 -0500
+++ linux.t/arch/x86_64/boot/Makefile	2004-04-28 20:42:55.000000000 -0400
@@ -99,3 +99,4 @@ zlilo: $(BOOTIMAGE)
 
 install: $(BOOTIMAGE)
 	sh $(srctree)/$(src)/install.sh $(KERNELRELEASE) $(BOOTIMAGE) System.map "$(INSTALL_PATH)"
+	if [ -f init/kerntypes.o ]; then cp init/kerntypes.o $(INSTALL_PATH)/Kerntypes; fi
Index: linux.t/arch/x86_64/Kconfig
===================================================================
--- linux.t.orig/arch/x86_64/Kconfig	2004-04-28 13:55:15.000000000 -0400
+++ linux.t/arch/x86_64/Kconfig	2004-04-28 20:42:55.000000000 -0400
@@ -419,6 +419,59 @@ source "arch/x86_64/oprofile/Kconfig"
 
 menu "Kernel hacking"
 
+config CRASH_DUMP
+       tristate "Crash dump support (EXPERIMENTAL)"
+       depends on EXPERIMENTAL
+       default n
+       ---help---
+         Say Y here to enable saving an image of system memory when a panic
+         or other error occurs. Dumps can also be forced with the SysRq+d
+         key if MAGIC_SYSRQ is enabled.
+
+config CRASH_DUMP_BLOCKDEV
+       tristate "Crash dump block device driver"
+       depends on CRASH_DUMP
+       help
+         Say Y to allow saving crash dumps directly to a disk device.
+
+config CRASH_DUMP_NETDEV
+       tristate "Crash dump network device driver"
+       depends on CRASH_DUMP
+       help
+         Say Y to allow saving crash dumps over a network device.
+
+config CRASH_DUMP_MEMDEV
+       bool "Crash dump staged memory driver"
+       depends on CRASH_DUMP
+       help
+         Say Y to allow intermediate saving crash dumps in spare
+         memory pages which would then be written out to disk
+         later.
+
+config CRASH_DUMP_SOFTBOOT
+       bool "Save crash dump across a soft reboot"
+       depends on CRASH_DUMP_MEMDEV
+       help
+         Say Y to allow a crash dump to be preserved in memory
+	 lkcd-kernpages across a soft reboot and written out to disk
+         thereafter. For this to work, CRASH_DUMP must be
+         configured as part of the kernel (not as a module).
+
+config CRASH_DUMP_COMPRESS_RLE
+       tristate "Crash dump RLE compression"
+       depends on CRASH_DUMP
+       help
+         Say Y to allow saving dumps with Run Length Encoding compression.
+
+
+config CRASH_DUMP_COMPRESS_GZIP
+       tristate "Crash dump GZIP compression"
+       select ZLIB_INFLATE
+       select ZLIB_DEFLATE
+       depends on CRASH_DUMP
+       help
+         Say Y to allow saving dumps with Gnu Zip compression.
+
 config DEBUG_KERNEL
 	bool "Kernel debugging"
 	help
Index: linux.t/arch/x86_64/kernel/irq.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/irq.c	2004-03-11 14:13:08.000000000 -0500
+++ linux.t/arch/x86_64/kernel/irq.c	2004-04-28 20:42:55.000000000 -0400
@@ -822,7 +822,7 @@ static struct proc_dir_entry * irq_dir [
 
 static struct proc_dir_entry * smp_affinity_entry [NR_IRQS];
 
-static cpumask_t irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = CPU_MASK_ALL };
+cpumask_t irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = CPU_MASK_ALL };
 static int irq_affinity_read_proc (char *page, char **start, off_t off,
 			int count, int *eof, void *data)
 {
Index: linux.t/arch/x86_64/kernel/nmi.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/nmi.c	2004-03-11 14:13:08.000000000 -0500
+++ linux.t/arch/x86_64/kernel/nmi.c	2004-04-28 20:42:55.000000000 -0400
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/sysdev.h>
 #include <linux/nmi.h>
+#include <linux/dump.h>
 
 #include <asm/smp.h>
 #include <asm/mtrr.h>
@@ -363,6 +364,7 @@ void nmi_watchdog_tick (struct pt_regs *
 				panic("nmi watchdog");
 			printk("console shuts up ...\n");
 			console_silent();
+			dump("NMI watchdog detected",regs);
 			spin_unlock(&nmi_print_lock);
 			bust_spinlocks(0);
 			do_exit(SIGSEGV);
Index: linux.t/arch/x86_64/kernel/smp.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/smp.c	2004-01-09 01:59:19.000000000 -0500
+++ linux.t/arch/x86_64/kernel/smp.c	2004-04-28 20:42:55.000000000 -0400
@@ -20,6 +20,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/mc146818rtc.h>
 #include <linux/interrupt.h>
+#include <linux/dump.h>
 
 #include <asm/mtrr.h>
 #include <asm/pgalloc.h>
@@ -65,6 +66,13 @@ static inline void __send_IPI_shortcut(u
 	 */
 	cfg = __prepare_ICR(shortcut, vector);
 
+	 if (vector == DUMP_VECTOR) {
+ 		 /*
+ 		  * Setup DUMP IPI to be delivered as an NMI
+ 		  */
+ 		 cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
+	 }
+
 	/*
 	 * Send the IPI. The write to APIC_ICR fires this off.
 	 */
@@ -117,6 +125,13 @@ static inline void send_IPI_mask(cpumask
 	 */
 	cfg = __prepare_ICR(0, vector);
 	
+	 if (vector == DUMP_VECTOR) {
+ 		 /*
+ 		  * Setup DUMP IPI to be delivered as an NMI
+ 		  */
+ 		 cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
+	 }
+
 	/*
 	 * Send the IPI. The write to APIC_ICR fires this off.
 	 */
@@ -351,6 +366,13 @@ void smp_kdb_stop(void)
 	send_IPI_allbutself(KDB_VECTOR);
 }
 
+
+void dump_send_ipi(int (*dump_ipi_handler)(struct pt_regs *));
+void dump_send_ipi(void)
+{
+	send_IPI_allbutself(DUMP_VECTOR);
+}
+
 /*
  * this function sends a 'reschedule' IPI to another CPU.
  * it goes straight through and wastes no time serializing
@@ -429,6 +451,18 @@ int smp_call_function (void (*func) (voi
 	return 0;
 }
 
+void stop_this_cpu(void* dummy)
+{
+	/*
+	 * Remove this CPU:
+	 */
+	cpu_clear(smp_processor_id(), cpu_online_map);
+	local_irq_disable();
+	disable_local_APIC();
+	for (;;) 
+		asm("hlt"); 
+}
+
 void smp_stop_cpu(void)
 {
 	/*
Index: linux.t/arch/x86_64/kernel/x8664_ksyms.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/x8664_ksyms.c	2004-04-28 13:54:50.000000000 -0400
+++ linux.t/arch/x86_64/kernel/x8664_ksyms.c	2004-04-28 20:42:55.000000000 -0400
@@ -33,6 +33,7 @@
 #include <asm/unistd.h>
 #include <asm/delay.h>
 #include <asm/tlbflush.h>
+#include <asm/e820.h>
 
 extern spinlock_t rtc_lock;
 
@@ -210,6 +211,20 @@ EXPORT_SYMBOL(__supported_pte_mask);
 
 EXPORT_SYMBOL(clear_page);
 
+#ifdef CONFIG_CRASH_DUMP_MODULE
+#ifdef CONFIG_SMP
+extern irq_desc_t irq_desc[NR_IRQS];
+extern unsigned long irq_affinity[NR_IRQS];
+extern void stop_this_cpu(void *);
+EXPORT_SYMBOL(irq_desc);
+EXPORT_SYMBOL(irq_affinity);
+EXPORT_SYMBOL(dump_send_ipi);
+EXPORT_SYMBOL(stop_this_cpu);
+#endif
+extern int page_is_ram(unsigned long);
+EXPORT_SYMBOL(page_is_ram);
+#endif
+
 #ifdef CONFIG_SMP
 EXPORT_SYMBOL(flush_tlb_page);
 EXPORT_SYMBOL_GPL(flush_tlb_all);
Index: linux.t/arch/x86_64/kernel/setup.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/setup.c	2004-04-28 13:54:50.000000000 -0400
+++ linux.t/arch/x86_64/kernel/setup.c	2004-04-28 20:42:55.000000000 -0400
@@ -190,6 +190,8 @@ static void __init probe_roms(void)
 	}
 }
 
+unsigned long crashdump_addr = 0xdeadbeef;
+
 static __init void parse_cmdline_early (char ** cmdline_p)
 {
 	char c = ' ', *to = command_line, *from = COMMAND_LINE;
@@ -276,6 +278,9 @@ static __init void parse_cmdline_early (
 
 		if (!memcmp(from,"oops=panic", 10))
 			panic_on_oops = 1;
+		
+		if (c == ' ' && !memcmp(from, "crashdump=", 10))
+			crashdump_addr = memparse(from+10, &from);
 
 	next_char:
 		c = *(from++);
@@ -369,6 +374,10 @@ static int __init noreplacement_setup(ch
 
 __setup("noreplacement", noreplacement_setup); 
 
+#ifdef CONFIG_CRASH_DUMP_SOFTBOOT
+extern void crashdump_reserve(void);
+#endif
+
 void __init setup_arch(char **cmdline_p)
 {
 	unsigned long low_mem_size;
@@ -474,6 +483,9 @@ void __init setup_arch(char **cmdline_p)
 	}
 #endif
 	paging_init();
+#ifdef CONFIG_CRASH_DUMP_SOFTBOOT
+	crashdump_reserve(); /* Preserve crash dump state from prev boot */
+#endif
 
 	check_ioapic();
 #ifdef CONFIG_ACPI_BOOT
Index: linux.t/arch/x86_64/kernel/traps.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/traps.c	2004-04-28 13:54:50.000000000 -0400
+++ linux.t/arch/x86_64/kernel/traps.c	2004-04-28 20:42:55.000000000 -0400
@@ -27,6 +27,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/dump.h>
 #include <linux/moduleparam.h>
 
 #include <asm/system.h>
@@ -365,6 +366,7 @@ void __die(const char * str, struct pt_r
 		printk("\n");
 	notify_die(DIE_OOPS, (char *)str, regs, err, 255, SIGSEGV);
 	show_registers(regs);
+	dump((char *)str, regs); 
 	/* Executive summary in case the oops scrolled away */
 	printk("RIP "); 
 	printk_address(regs->rip); 
Index: linux.t/arch/x86_64/kernel/pci-gart.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/pci-gart.c	2004-04-28 13:54:50.000000000 -0400
+++ linux.t/arch/x86_64/kernel/pci-gart.c	2004-04-28 20:42:55.000000000 -0400
@@ -41,7 +41,7 @@
 dma_addr_t bad_dma_address;
 
 unsigned long iommu_bus_base;	/* GART remapping area (physical) */
-static unsigned long iommu_size; 	/* size of remapping area bytes */
+unsigned long iommu_size; 	/* size of remapping area bytes */
 static unsigned long iommu_pages;	/* .. and in pages */
 
 u32 *iommu_gatt_base; 		/* Remapping table */
Index: linux.t/include/asm-x86_64/smp.h
===================================================================
--- linux.t.orig/include/asm-x86_64/smp.h	2004-04-28 13:54:50.000000000 -0400
+++ linux.t/include/asm-x86_64/smp.h	2004-04-28 20:42:55.000000000 -0400
@@ -41,6 +41,7 @@ extern volatile unsigned long smp_invali
 extern int pic_mode;
 extern int smp_num_siblings;
 extern void smp_flush_tlb(void);
+extern void dump_send_ipi(void);
 extern void smp_message_irq(int cpl, void *dev_id, struct pt_regs *regs);
 extern void smp_send_reschedule(int cpu);
 extern void smp_invalidate_rcv(void);		/* Process an NMI */
Index: linux.t/include/asm-x86_64/kmap_types.h
===================================================================
--- linux.t.orig/include/asm-x86_64/kmap_types.h	2004-01-09 01:59:48.000000000 -0500
+++ linux.t/include/asm-x86_64/kmap_types.h	2004-04-28 20:43:20.000000000 -0400
@@ -13,7 +13,8 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
-	KM_TYPE_NR
+	KM_DUMP,
+	KM_TYPE_NR,
 };
 
 #endif
Index: linux.t/include/asm-x86_64/hw_irq.h
===================================================================
--- linux.t.orig/include/asm-x86_64/hw_irq.h	2004-02-18 15:20:48.000000000 -0500
+++ linux.t/include/asm-x86_64/hw_irq.h	2004-04-28 20:42:55.000000000 -0400
@@ -34,7 +34,6 @@ struct hw_interrupt_type;
 
 #define IA32_SYSCALL_VECTOR	0x80
 
-
 /*
  * Vectors 0x20-0x2f are used for ISA interrupts.
  */
@@ -55,6 +54,7 @@ struct hw_interrupt_type;
 #define TASK_MIGRATION_VECTOR	0xfb
 #define CALL_FUNCTION_VECTOR	0xfa
 #define KDB_VECTOR	0xf9
+#define DUMP_VECTOR	0xf8
 
 #define THERMAL_APIC_VECTOR	0xf0
 
