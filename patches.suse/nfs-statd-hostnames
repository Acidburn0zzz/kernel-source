Subject: Make kernel statd/lockd use hostnames for SM_NOTIFY
From: Olaf Kirch <okir@suse.de>

This patch enhances lockd and kernel statd so that it uses host names
to record which hosts get monitored and which dont, which is important
for multi-homed servers. It also allows switching between kstatd and
user space statd at module load time.


Index: linux-2.6.10/fs/lockd/clntproc.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/clntproc.c	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/fs/lockd/clntproc.c	2005-02-18 14:34:33.000000000 +0100
@@ -206,7 +206,7 @@ nlmclnt_proc(struct inode *inode, int cm
 	/* Retrieve transport protocol from NFS client */
 	proto = NFS_CLIENT(inode)->cl_xprt->prot;
 
-	if (!(host = nlmclnt_lookup_host(NFS_ADDR(inode), proto, vers)))
+	if (!(host = nlmclnt_lookup_host(NFS_ADDR(inode), proto, vers, nfssrv->hostname)))
 		return -ENOLCK;
 
 	/* Create RPC client handle if not there, and copy soft
Index: linux-2.6.10/fs/lockd/host.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/host.c	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/fs/lockd/host.c	2005-02-18 14:34:33.000000000 +0100
@@ -19,12 +19,11 @@
 
 
 #define NLMDBG_FACILITY		NLMDBG_HOSTCACHE
-#define NLM_HOST_MAX		64
 #define NLM_HOST_NRHASH		32
 #define NLM_ADDRHASH(addr)	(ntohl(addr) & (NLM_HOST_NRHASH-1))
 #define NLM_HOST_REBIND		(60 * HZ)
-#define NLM_HOST_EXPIRE		((nrhosts > NLM_HOST_MAX)? 300 * HZ : 120 * HZ)
-#define NLM_HOST_COLLECT	((nrhosts > NLM_HOST_MAX)? 120 * HZ :  60 * HZ)
+#define NLM_HOST_EXPIRE		((nrhosts > nlm_max_hosts)? 300 * HZ : 120 * HZ)
+#define NLM_HOST_COLLECT	((nrhosts > nlm_max_hosts)? 120 * HZ :  60 * HZ)
 #define NLM_HOST_ADDR(sv)	(&(sv)->s_nlmclnt->cl_xprt->addr)
 
 static struct nlm_host *	nlm_hosts[NLM_HOST_NRHASH];
@@ -42,23 +41,27 @@ int				(*nsm_unmonitor)(struct nlm_host 
 
 static void			nlm_gc_hosts(void);
 
+static struct nsm_handle *	__nsm_find(const char *);
+static void			__nsm_release(struct nsm_handle *);
+
 /*
  * Find an NLM server handle in the cache. If there is none, create it.
  */
 struct nlm_host *
-nlmclnt_lookup_host(struct sockaddr_in *sin, int proto, int version)
+nlmclnt_lookup_host(struct sockaddr_in *sin, int proto, int version, const char *hostname)
 {
-	return nlm_lookup_host(0, sin, proto, version);
+	return nlm_lookup_host(0, sin, proto, version, hostname);
 }
 
 /*
  * Find an NLM client handle in the cache. If there is none, create it.
  */
 struct nlm_host *
-nlmsvc_lookup_host(struct svc_rqst *rqstp)
+nlmsvc_lookup_host(struct svc_rqst *rqstp, const char *hostname)
 {
 	return nlm_lookup_host(1, &rqstp->rq_addr,
-			       rqstp->rq_prot, rqstp->rq_vers);
+			       rqstp->rq_prot, rqstp->rq_vers,
+			       hostname);
 }
 
 /*
@@ -66,15 +69,16 @@ nlmsvc_lookup_host(struct svc_rqst *rqst
  */
 struct nlm_host *
 nlm_lookup_host(int server, struct sockaddr_in *sin,
-					int proto, int version)
+					int proto, int version,
+					const char *hostname)
 {
 	struct nlm_host	*host, **hp;
 	struct nsm_handle *nsm = NULL;
-	u32		addr;
 	int		hash;
 
-	dprintk("lockd: nlm_lookup_host(%08x, p=%d, v=%d)\n",
-			(unsigned)(sin? ntohl(sin->sin_addr.s_addr) : 0), proto, version);
+	dprintk("lockd: nlm_lookup_host(%08x, p=%d, v=%d, name=%s)\n",
+			(unsigned)(sin? ntohl(sin->sin_addr.s_addr) : 0), proto, version,
+			hostname? hostname : "<none>");
 
 	hash = NLM_ADDRHASH(sin->sin_addr.s_addr);
 
@@ -108,18 +112,21 @@ nlm_lookup_host(int server, struct socka
 		goto out;
 	}
 
-	/* Ooops, no host found, create it */
 	dprintk("lockd: creating host entry\n");
 
-	/* Allocate NLM struct and NSM handle. */
-	if ((!nsm && !(nsm = nsm_alloc(sin)))
-	 || !(host = (struct nlm_host *) kmalloc(sizeof(*host), GFP_KERNEL)))
-		goto nohost;
-	memset(host, 0, sizeof(*host));
-
-	addr = sin->sin_addr.s_addr;
-	sprintf(host->h_name, "%u.%u.%u.%u", NIPQUAD(addr));
+	/* Sadly, the host isn't in our hash table yet. See if
+	 * we have the name at least and grab the nsm handle.
+	 * If not, create it.
+	 */
+	if (!nsm && !(nsm = __nsm_find(hostname)))
+		goto out;
 
+	if (!(host = (struct nlm_host *) kmalloc(sizeof(*host), GFP_KERNEL))) {
+		__nsm_release(nsm);
+		goto out;
+	}
+	memset(host, 0, sizeof(*host));
+	host->h_name	   = nsm->sm_name;
 	host->h_addr       = *sin;
 	host->h_addr.sin_port = 0;	/* ouch! */
 	host->h_version    = version;
@@ -140,20 +147,11 @@ nlm_lookup_host(int server, struct socka
 	INIT_LIST_HEAD(&host->h_lockowners);
 	spin_lock_init(&host->h_lock);
 
-	if (++nrhosts > NLM_HOST_MAX)
+	if (++nrhosts > nlm_max_hosts)
 		next_gc = 0;
 
-out:
-	up(&nlm_host_sema);
+out:	up(&nlm_host_sema);
 	return host;
-
-nohost:
-	if (host) {
-		kfree(host);
-		host = NULL;
-	}
-	nsm_release(nsm);
-	goto out;
 }
 
 struct nlm_host *
@@ -170,6 +168,7 @@ nlm_find_client(void)
 		for (hp = &nlm_hosts[hash]; (host = *hp) != 0; hp = &host->h_next) {
 			if (host->h_server) {
 			    	*hp = host->h_next;
+				atomic_inc(&host->h_count);
 				up(&nlm_host_sema);
 				return host;
 			}
@@ -278,29 +277,34 @@ void nlm_release_host(struct nlm_host *h
  * Given an IP address, initiate recovery and ditch all locks.
  */
 void
-nlm_host_rebooted(struct sockaddr_in *sin, u32 new_state)
+nlm_host_rebooted(const char *hostname, u32 new_state)
 {
 	struct nlm_host	*host, **hp;
 	int		hash;
 
-	dprintk("lockd: nlm_host_rebooted(%u.%u.%u.%u)\n",
-			NIPQUAD(sin->sin_addr));
-
-	hash = NLM_ADDRHASH(sin->sin_addr.s_addr);
+	dprintk("lockd: nlm_host_rebooted(\"%s\")\n", hostname);
 
 	/* Lock hash table */
 	down(&nlm_host_sema);
-	for (hp = &nlm_hosts[hash]; (host = *hp); hp = &host->h_next) {
-		if (nlm_cmp_addr(&host->h_addr, sin)) {
-			if (host->h_nsmhandle)
-				host->h_nsmhandle->sm_monitored = 0;
-			host->h_rebooted = 1;
+
+	/* Mark all matching hosts as having rebooted */
+	for (hash = 0; hash < NLM_HOST_NRHASH; hash++) {
+		for (hp = &nlm_hosts[hash]; (host = *hp); hp = &host->h_next) {
+			if (nlm_cmp_name(host->h_name, hostname)) {
+				if (host->h_nsmhandle)
+					host->h_nsmhandle->sm_monitored = 0;
+				host->h_rebooted = 1;
+			}
 		}
 	}
 
+	for (hash = 0; hash < NLM_HOST_NRHASH; hash++) {
+
 again:
-	for (hp = &nlm_hosts[hash]; (host = *hp); hp = &host->h_next) {
-		if (nlm_cmp_addr(&host->h_addr, sin) && host->h_rebooted) {
+		for (hp = &nlm_hosts[hash]; (host = *hp); hp = &host->h_next) {
+			if (!host->h_rebooted)
+				continue;
+
 			host->h_rebooted = 0;
 			atomic_inc(&host->h_count);
 			up(&nlm_host_sema);
@@ -319,7 +323,7 @@ again:
 			nlm_release_host(host);
 
 			/* Host table may have changed in the meanwhile,
-			 * start over */
+			 * start over on this hash chain */
 			goto again;
 		}
 	}
@@ -424,21 +428,74 @@ nlm_gc_hosts(void)
 }
 
 /*
- * Allocate an NSM handle
+ * Manage NSM handles
  */
+static LIST_HEAD(nsm_handles);
+
 struct nsm_handle *
-nsm_alloc(struct sockaddr_in *sin)
+__nsm_find(const char *hostname)
 {
-	struct nsm_handle *nsm;
+	struct nsm_handle *new = NULL, *result = NULL;
+	struct list_head *pos;
 
-	nsm = (struct nsm_handle *) kmalloc(sizeof(*nsm), GFP_KERNEL);
-	if (nsm == NULL)
+	if (hostname == NULL)
 		return NULL;
 
-	memset(nsm, 0, sizeof(*nsm));
-	memcpy(&nsm->sm_addr, sin, sizeof(nsm->sm_addr));
-	atomic_set(&nsm->sm_count, 1);
+	if (strchr(hostname, '/') != NULL) {
+		printk(KERN_WARNING "Invalid hostname \"%s\" in NFS lock request\n",
+				hostname);
+		return NULL;
+	}
+
+again:
+	list_for_each(pos, &nsm_handles) {
+		struct nsm_handle *nsm;
 
+		nsm = list_entry(pos, struct nsm_handle, sm_link);
+		if (!strcmp(nsm->sm_name, hostname)) {
+			if (new)
+				kfree(new);
+			result = nsm;
+			goto out;
+		}
+	}
+
+	if (new == NULL) {
+		int	hlen = strlen(hostname) + 1;
+
+		/* Release the semaphore when calling kmalloc */
+		up(&nlm_host_sema);
+
+		new = (struct nsm_handle *) kmalloc(sizeof(*new) + hlen, GFP_KERNEL);
+		if (new == NULL)
+			return NULL;
+
+		down(&nlm_host_sema);
+		goto again;
+	}
+
+	result = new;
+
+	memset(new, 0, sizeof(*new));
+	INIT_LIST_HEAD(&new->sm_link);
+	new->sm_name = (char *) (new + 1);
+	strcpy(new->sm_name, hostname);
+	atomic_set(&new->sm_count, 0);
+
+	list_add(&new->sm_link, &nsm_handles);
+
+out:	atomic_inc(&result->sm_count);
+	return result;
+}
+
+struct nsm_handle *
+nsm_find(const char *hostname)
+{
+	struct nsm_handle *nsm;
+
+	down(&nlm_host_sema);
+	nsm = __nsm_find(hostname);
+	up(&nlm_host_sema);
 	return nsm;
 }
 
@@ -446,9 +503,19 @@ nsm_alloc(struct sockaddr_in *sin)
  * Release an NSM handle
  */
 void
-nsm_release(struct nsm_handle *nsm)
+__nsm_release(struct nsm_handle *nsm)
 {
-	if (nsm && atomic_dec_and_test(&nsm->sm_count))
+	if (nsm && atomic_dec_and_test(&nsm->sm_count)) {
+		list_del(&nsm->sm_link);
 		kfree(nsm);
+	}
+}
+
+void
+nsm_release(struct nsm_handle *nsm)
+{
+	down(&nlm_host_sema);
+	__nsm_release(nsm);
+	up(&nlm_host_sema);
 }
 
Index: linux-2.6.10/fs/lockd/mon.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/mon.c	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/fs/lockd/mon.c	2005-02-18 14:34:33.000000000 +0100
@@ -47,7 +47,7 @@ nsm_statd_upcalls_init()
  * Common procedure for SM_MON/SM_UNMON calls
  */
 static int
-nsm_mon_unmon(struct nlm_host *host, u32 proc, struct nsm_res *res)
+nsm_mon_unmon(struct nsm_handle *nsm, u32 proc, struct nsm_res *res)
 {
 	struct rpc_clnt	*clnt;
 	int		status;
@@ -59,10 +59,10 @@ nsm_mon_unmon(struct nlm_host *host, u32
 		goto out;
 	}
 
-	args.addr = host->h_addr.sin_addr.s_addr;
-	args.proto= (host->h_proto<<1) | host->h_server;
+	memset(&args, 0, sizeof(args));
+	args.mon_name = nsm->sm_name;
 	args.prog = NLM_PROGRAM;
-	args.vers = host->h_version;
+	args.vers = 3;
 	args.proc = NLMPROC_NSM_NOTIFY;
 	memset(res, 0, sizeof(*res));
 
@@ -93,7 +93,7 @@ __nsm_monitor(struct nlm_host *host)
 	if (nsm->sm_monitored)
 		return 0;
 
-	status = nsm_mon_unmon(host, SM_MON, &res);
+	status = nsm_mon_unmon(nsm, SM_MON, &res);
 	if (status < 0 || res.status != 0)
 		printk(KERN_NOTICE "lockd: cannot monitor %s\n", host->h_name);
 	else
@@ -117,7 +117,7 @@ __nsm_unmonitor(struct nlm_host *host)
 	if (nsm && atomic_read(&nsm->sm_count) == 1
 	 && nsm->sm_monitored && !nsm->sm_sticky) {
 		dprintk("lockd: nsm_unmonitor(%s)\n", host->h_name);
-		status = nsm_mon_unmon(host, SM_UNMON, &res);
+		status = nsm_mon_unmon(nsm, SM_UNMON, &res);
 		if (status < 0) {
 			printk(KERN_NOTICE "lockd: cannot unmonitor %s\n",
 				       	host->h_name);
Index: linux-2.6.10/fs/lockd/statd.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/statd.c	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/fs/lockd/statd.c	2005-02-18 14:34:57.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * linux/fs/lockd/nsmproc.c
+ * linux/fs/lockd/statd.c
  *
  * Kernel-based status monitor. This is an alternative to
  * the code in mon.c.
@@ -85,77 +85,77 @@ nsm_kernel_statd_init(void)
 }
 
 /*
- * Build the path name for this lockd peer.
- *
- * We keep it extremely simple. Since we can have more
- * than one nlm_host object peer (depending on whether
- * it's server or client, and what proto/version of NLM
- * we use to communicate), we cannot create a file named
- * $IPADDR and remove it when the nlm_host is unmonitored.
- * Besides, unlink() is tricky (there's no kernel_syscall
- * for it), so we just create the file and leave it.
- *
- * When we reboot, the notifier should sort the IPs by
- * descending mtime so that the most recent hosts get
- * notified first.
+ * Build the NSM file name path
  */
 static char *
-nsm_filename(struct in_addr addr)
+nsm_get_name(const char *hostname)
 {
-	char		*name;
+	char	*name;
+
+	if (strchr(hostname, '/') != NULL) {
+		printk(KERN_NOTICE "lockd: invalid characters in hostname \"%s\"\n", hostname);
+		return ERR_PTR(-EINVAL);
+	}
 
 	name = (char *) __get_free_page(GFP_KERNEL);
 	if (name == NULL)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
-	/* FIXME IPV6 */
-	snprintf(name, PAGE_SIZE, "%s/%u.%u.%u.%u",
-			NSM_SM_PATH, NIPQUAD(addr));
+	snprintf(name, PAGE_SIZE, "%s/%s", NSM_SM_PATH, hostname);
 	return name;
 }
 
+static void
+nsm_put_name(char *name)
+{
+	free_page((unsigned long) name);
+}
+
 /*
  * Create the NSM monitor file
  */
 static int
-nsm_create(struct in_addr addr)
+nsm_create(const char *hostname)
 {
 	struct file	*filp;
-	char		*name;
+	char		*filename;
 	int		res = 0;
 
-	if (!(name = nsm_filename(addr)))
-		return -ENOMEM;
+	dprintk("lockd: creating statd monitor file %s\n", hostname);
+
+	filename = nsm_get_name(hostname);
+	if (IS_ERR(filename))
+		return PTR_ERR(filename);
 
-	dprintk("lockd: creating statd monitor file %s\n", name);
-	filp = filp_open(name, O_CREAT|O_SYNC|O_RDWR, 0644);
+	filp = filp_open(filename, O_CREAT|O_SYNC|O_RDWR, 0644);
 	if (IS_ERR(filp)) {
 		res = PTR_ERR(filp);
 		printk(KERN_NOTICE
 			"lockd/statd: failed to create %s: err=%d\n",
-			name, res);
+			filename, res);
 	} else {
 		fsync_super(filp->f_dentry->d_inode->i_sb);
 		filp_close(filp, NULL);
 	}
 
-	free_page((long) name);
+	nsm_put_name(filename);
 	return res;
 }
 
 static int
-nsm_unlink(struct in_addr addr)
+nsm_unlink(const char *hostname)
 {
 	struct nameidata nd;
 	struct inode	*inode = NULL;
 	struct dentry	*dentry;
-	char		*name;
+	char		*filename;
 	int		res = 0;
 
-	if (!(name = nsm_filename(addr)))
-		return -ENOMEM;
+	filename = nsm_get_name(hostname);
+	if (IS_ERR(filename))
+		return PTR_ERR(filename);
 
-	if ((res = path_lookup(name, LOOKUP_PARENT, &nd)) != 0)
+	if ((res = path_lookup(filename, LOOKUP_PARENT, &nd)) != 0)
 		goto exit;
 
 	if (nd.last_type == LAST_NORM && !nd.last.name[nd.last.len]) {
@@ -180,38 +180,49 @@ exit:
 	if (res < 0) {
 		printk(KERN_NOTICE
 			"lockd/statd: failed to unlink %s: err=%d\n",
-			name, res);
+			filename, res);
 	}
 
-	free_page((long) name);
 	if (inode)
 		iput(inode);
+	nsm_put_name(filename);
 	return res;
 }
 
 /*
  * Call nsm_create/nsm_unlink with CAP_DAC_OVERRIDE
  */
+#define swap_ugid(type, var) { \
+	type tmp = current->var; current->var = var; var = tmp; \
+}
+
 static int
-with_privilege(int (*func)(struct in_addr), struct sockaddr_in *sin)
+with_privilege(int (*func)(const char *), const char *hostname)
 {
 	kernel_cap_t	cap = current->cap_effective;
 	int		res = 0, mask;
+	uid_t		fsuid = 0;
+	gid_t		fsgid = 0;
 
 	/* If we're unprivileged, a call to capable() will set the
 	 * SUPERPRIV flag */
-	mask = ~(current->flags) & PF_SUPERPRIV;
+	mask = current->flags | ~PF_SUPERPRIV;
 
-	/* Raise capability to that we're able to create/unlink the file */
+	/* Raise capability to that we're able to create/unlink the file.
+	 * Set fsuid/fsgid to 0 so the file will be owned by root. */
 	cap_raise(current->cap_effective, CAP_DAC_OVERRIDE);
+	swap_ugid(uid_t, fsuid);
+	swap_ugid(gid_t, fsgid);
 
-	res = func(sin->sin_addr);
+	res = func(hostname);
 
 	/* drop privileges */
 	current->cap_effective = cap;
+	swap_ugid(uid_t, fsuid);
+	swap_ugid(gid_t, fsgid);
 
 	/* Clear PF_SUPERPRIV unless it was set to begin with */
-	current->flags &= ~mask;
+	current->flags &= mask;
 
 	return res;
 }
@@ -231,7 +242,7 @@ __nsm_monitor(struct nlm_host *host)
 	if ((nsm = host->h_nsmhandle) == NULL)
 		BUG();
 
-	res = with_privilege(nsm_create, &nsm->sm_addr);
+	res = with_privilege(nsm_create, nsm->sm_name);
 	if (res >= 0)
 		nsm->sm_monitored = 1;
 	return res;
@@ -260,7 +271,7 @@ __nsm_unmonitor(struct nlm_host *host)
 	 && nsm->sm_monitored && !nsm->sm_sticky) {
 		dprintk("lockd: nsm_unmonitor(%s)\n", host->h_name);
 
-		res = with_privilege(nsm_unlink, &host->h_addr);
+		res = with_privilege(nsm_unlink, nsm->sm_name);
 	}
 
 	nsm_release(nsm);
@@ -288,13 +299,8 @@ static int
 nsmsvc_proc_notify(struct svc_rqst *rqstp, struct nsm_args *argp,
 				           struct nsm_res  *resp)
 {
-	struct sockaddr_in	saddr = rqstp->rq_addr;
-
 	dprintk("statd: NOTIFY        called\n");
-
-	/* FIXME - shouldn't we walk all nsm handles and compare
-	 * the mon_id instead of just using the address? */
-	nlm_host_rebooted(&saddr, argp->state);
+	nlm_host_rebooted(argp->mon_name, argp->state);
 	return rpc_success;
 }
 
@@ -329,11 +335,9 @@ nsmsvc_encode_void(struct svc_rqst *rqst
 static int
 nsmsvc_decode_stat_chge(struct svc_rqst *rqstp, u32 *p, struct nsm_args *argp)
 {
-	char	*mon_name;
 	__u32	mon_name_len;
 
-	/* Skip over the client's mon_name */
-	p = xdr_decode_string_inplace(p, &mon_name, &mon_name_len, SM_MAXSTRLEN);
+	p = xdr_decode_string(p, &argp->mon_name, &mon_name_len, SM_MAXSTRLEN);
 	if (p == NULL)
 		return 0;
 
Index: linux-2.6.10/fs/lockd/svc.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/svc.c	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/fs/lockd/svc.c	2005-02-18 14:34:33.000000000 +0100
@@ -62,6 +62,7 @@ static unsigned long		nlm_grace_period;
 static unsigned long		nlm_timeout = LOCKD_DFLT_TIMEO;
 static int			nlm_udpport, nlm_tcpport;
 static int			nlm_use_kstatd = 1;
+int				nlm_max_hosts = 256;
 
 /*
  * Constants needed for the sysctl interface.
@@ -387,6 +388,14 @@ static ctl_table nlm_sysctls[] = {
 		.extra1		= (int *) &nlm_port_min,
 		.extra2		= (int *) &nlm_port_max,
 	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nlm_max_hosts",
+		.data		= &nlm_max_hosts,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 #ifdef CONFIG_STATD
 	{
 		.ctl_name	= CTL_UNNUMBERED,
Index: linux-2.6.10/fs/lockd/svc4proc.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/svc4proc.c	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/fs/lockd/svc4proc.c	2005-02-18 14:34:33.000000000 +0100
@@ -41,7 +41,7 @@ nlm4svc_retrieve_args(struct svc_rqst *r
 		return nlm_lck_denied_nolocks;
 
 	/* Obtain host handle */
-	if (!(host = nlmsvc_lookup_host(rqstp))
+	if (!(host = nlmsvc_lookup_host(rqstp, lock->caller))
 	 || (argp->monitor && nsm_monitor(host) < 0))
 		goto no_locks;
 	*hostp = host;
@@ -417,10 +417,6 @@ nlm4svc_proc_sm_notify(struct svc_rqst *
 					      void	        *resp)
 {
 	struct sockaddr_in	saddr = rqstp->rq_addr;
-	int			vers = argp->vers;
-	int			prot = argp->proto >> 1;
-
-	struct nlm_host		*host;
 
 	dprintk("lockd: SM_NOTIFY     called\n");
 	if (saddr.sin_addr.s_addr != htonl(INADDR_LOOPBACK)
@@ -432,24 +428,7 @@ nlm4svc_proc_sm_notify(struct svc_rqst *
 		return rpc_system_err;
 	}
 
-	/* Obtain the host pointer for this NFS server and try to
-	 * reclaim all locks we hold on this server.
-	 */
-	saddr.sin_addr.s_addr = argp->addr;
-
-	if ((argp->proto & 1)==0) {
-		if ((host = nlmclnt_lookup_host(&saddr, prot, vers)) != NULL) {
-			nlmclnt_recovery(host, argp->state);
-			nlm_release_host(host);
-		}
-	} else {
-		/* If we run on an NFS server, delete all locks held by the client */
-
-		if ((host = nlm_lookup_host(1, &saddr, prot, vers)) != NULL) {
-			nlmsvc_free_host_resources(host);
-			nlm_release_host(host);
-		}
-	}
+	nlm_host_rebooted(argp->mon, argp->state);
 	return rpc_success;
 }
 
@@ -484,7 +463,8 @@ nlm4svc_callback(struct svc_rqst *rqstp,
 		return rpc_system_err;
 
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				NULL);
 	if (!host) {
 		kfree(call);
 		return rpc_system_err;
Index: linux-2.6.10/fs/lockd/svclock.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/svclock.c	2005-01-03 16:28:33.000000000 +0100
+++ linux-2.6.10/fs/lockd/svclock.c	2005-02-18 14:34:33.000000000 +0100
@@ -177,7 +177,8 @@ nlmsvc_create_block(struct svc_rqst *rqs
 
 	/* Create host handle for callback */
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				lock->caller);
 	if (host == NULL)
 		return NULL;
 
Index: linux-2.6.10/fs/lockd/svcproc.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/svcproc.c	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/fs/lockd/svcproc.c	2005-02-18 14:34:33.000000000 +0100
@@ -70,7 +70,7 @@ nlmsvc_retrieve_args(struct svc_rqst *rq
 		return nlm_lck_denied_nolocks;
 
 	/* Obtain host handle */
-	if (!(host = nlmsvc_lookup_host(rqstp))
+	if (!(host = nlmsvc_lookup_host(rqstp, lock->caller))
 	 || (argp->monitor && nsm_monitor(host) < 0))
 		goto no_locks;
 	*hostp = host;
@@ -445,9 +445,6 @@ nlmsvc_proc_sm_notify(struct svc_rqst *r
 					      void	        *resp)
 {
 	struct sockaddr_in	saddr = rqstp->rq_addr;
-	int			vers = argp->vers;
-	int			prot = argp->proto >> 1;
-	struct nlm_host		*host;
 
 	dprintk("lockd: SM_NOTIFY     called\n");
 	if (saddr.sin_addr.s_addr != htonl(INADDR_LOOPBACK)
@@ -459,23 +456,7 @@ nlmsvc_proc_sm_notify(struct svc_rqst *r
 		return rpc_system_err;
 	}
 
-	/* Obtain the host pointer for this NFS server and try to
-	 * reclaim all locks we hold on this server.
-	 */
-	saddr.sin_addr.s_addr = argp->addr;
-	if ((argp->proto & 1)==0) {
-		if ((host = nlmclnt_lookup_host(&saddr, prot, vers)) != NULL) {
-			nlmclnt_recovery(host, argp->state);
-			nlm_release_host(host);
-		}
-	} else {
-		/* If we run on an NFS server, delete all locks held by the client */
-		if ((host = nlm_lookup_host(1, &saddr, prot, vers)) != NULL) {
-			nlmsvc_free_host_resources(host);
-			nlm_release_host(host);
-		}
-	}
-
+	nlm_host_rebooted(argp->mon, argp->state);
 	return rpc_success;
 }
 
@@ -508,7 +489,8 @@ nlmsvc_callback(struct svc_rqst *rqstp, 
 		return rpc_system_err;
 
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				NULL);
 	if (!host) {
 		kfree(call);
 		return rpc_system_err;
Index: linux-2.6.10/fs/lockd/svcsubs.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/svcsubs.c	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/fs/lockd/svcsubs.c	2005-02-18 14:34:33.000000000 +0100
@@ -287,10 +287,12 @@ nlmsvc_free_host_resources(struct nlm_ho
 {
 	dprintk("lockd: nlmsvc_free_host_resources\n");
 
-	if (nlm_traverse_files(host, NLM_ACT_UNLOCK))
+	if (nlm_traverse_files(host, NLM_ACT_UNLOCK)) {
 		printk(KERN_WARNING
-			"lockd: couldn't remove all locks held by %s",
+			"lockd: couldn't remove all locks held by %s\n",
 			host->h_name);
+		BUG();
+	}
 }
 
 /*
@@ -301,8 +303,8 @@ nlmsvc_invalidate_all(void)
 {
 	struct nlm_host *host;
 	while ((host = nlm_find_client()) != NULL) {
-		nlmsvc_free_host_resources(host);
 		host->h_expires = 0;
+		nlmsvc_free_host_resources(host);
 		/* Do not unmonitor the host */
 		if (host->h_nsmhandle)
 			host->h_nsmhandle->sm_sticky = 1;
@@ -310,8 +312,9 @@ nlmsvc_invalidate_all(void)
 			/* Whatever is holding references to this host,
 			 * it seems likely we're going to leak memory
 			 * or worse */
-			printk(KERN_WARNING "lockd: host still in use "
-				"after nlmsvc_free_host_resources!");
+			printk(KERN_WARNING "lockd: host has reference count %u "
+				"after nlmsvc_free_host_resources!\n",
+				atomic_read(&host->h_count));
 		}
 		nlm_release_host(host);
 	}
Index: linux-2.6.10/fs/lockd/xdr.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/xdr.c	2005-01-03 16:28:33.000000000 +0100
+++ linux-2.6.10/fs/lockd/xdr.c	2005-02-18 14:34:33.000000000 +0100
@@ -125,9 +125,9 @@ nlm_decode_lock(u32 *p, struct nlm_lock 
 	struct file_lock	*fl = &lock->fl;
 	s32			start, len, end;
 
-	if (!(p = xdr_decode_string_inplace(p, &lock->caller,
-					    &lock->len,
-					    NLM_MAXSTRLEN))
+	if (!(p = xdr_decode_string(p, &lock->caller,
+				    &lock->len,
+				    NLM_MAXSTRLEN))
 	 || !(p = nlm_decode_fh(p, &lock->fh))
 	 || !(p = nlm_decode_oh(p, &lock->oh)))
 		return NULL;
@@ -301,8 +301,8 @@ nlmsvc_decode_shareargs(struct svc_rqst 
 	lock->fl.fl_pid = ~(u32) 0;
 
 	if (!(p = nlm_decode_cookie(p, &argp->cookie))
-	 || !(p = xdr_decode_string_inplace(p, &lock->caller,
-					    &lock->len, NLM_MAXSTRLEN))
+	 || !(p = xdr_decode_string(p, &lock->caller,
+				    &lock->len, NLM_MAXSTRLEN))
 	 || !(p = nlm_decode_fh(p, &lock->fh))
 	 || !(p = nlm_decode_oh(p, &lock->oh)))
 		return 0;
@@ -335,8 +335,8 @@ nlmsvc_decode_notify(struct svc_rqst *rq
 {
 	struct nlm_lock	*lock = &argp->lock;
 
-	if (!(p = xdr_decode_string_inplace(p, &lock->caller,
-					    &lock->len, NLM_MAXSTRLEN)))
+	if (!(p = xdr_decode_string(p, &lock->caller,
+				    &lock->len, NLM_MAXSTRLEN)))
 		return 0;
 	argp->state = ntohl(*p++);
 	return xdr_argsize_check(rqstp, p);
@@ -345,7 +345,7 @@ nlmsvc_decode_notify(struct svc_rqst *rq
 int
 nlmsvc_decode_reboot(struct svc_rqst *rqstp, u32 *p, struct nlm_reboot *argp)
 {
-	if (!(p = xdr_decode_string_inplace(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))
+	if (!(p = xdr_decode_string(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))
 		return 0;
 	argp->state = ntohl(*p++);
 	/* Preserve the address in network byte order */
Index: linux-2.6.10/fs/lockd/xdr4.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/xdr4.c	2005-01-03 16:28:33.000000000 +0100
+++ linux-2.6.10/fs/lockd/xdr4.c	2005-02-18 14:34:33.000000000 +0100
@@ -125,8 +125,8 @@ nlm4_decode_lock(u32 *p, struct nlm_lock
 	struct file_lock	*fl = &lock->fl;
 	__s64			len, start, end;
 
-	if (!(p = xdr_decode_string_inplace(p, &lock->caller,
-					    &lock->len, NLM_MAXSTRLEN))
+	if (!(p = xdr_decode_string(p, &lock->caller,
+				    &lock->len, NLM_MAXSTRLEN))
 	 || !(p = nlm4_decode_fh(p, &lock->fh))
 	 || !(p = nlm4_decode_oh(p, &lock->oh)))
 		return NULL;
@@ -306,8 +306,8 @@ nlm4svc_decode_shareargs(struct svc_rqst
 	lock->fl.fl_pid = ~(u32) 0;
 
 	if (!(p = nlm4_decode_cookie(p, &argp->cookie))
-	 || !(p = xdr_decode_string_inplace(p, &lock->caller,
-					    &lock->len, NLM_MAXSTRLEN))
+	 || !(p = xdr_decode_string(p, &lock->caller,
+				    &lock->len, NLM_MAXSTRLEN))
 	 || !(p = nlm4_decode_fh(p, &lock->fh))
 	 || !(p = nlm4_decode_oh(p, &lock->oh)))
 		return 0;
@@ -340,8 +340,8 @@ nlm4svc_decode_notify(struct svc_rqst *r
 {
 	struct nlm_lock	*lock = &argp->lock;
 
-	if (!(p = xdr_decode_string_inplace(p, &lock->caller,
-					    &lock->len, NLM_MAXSTRLEN)))
+	if (!(p = xdr_decode_string(p, &lock->caller,
+				    &lock->len, NLM_MAXSTRLEN)))
 		return 0;
 	argp->state = ntohl(*p++);
 	return xdr_argsize_check(rqstp, p);
@@ -350,7 +350,7 @@ nlm4svc_decode_notify(struct svc_rqst *r
 int
 nlm4svc_decode_reboot(struct svc_rqst *rqstp, u32 *p, struct nlm_reboot *argp)
 {
-	if (!(p = xdr_decode_string_inplace(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))
+	if (!(p = xdr_decode_string(p, &argp->mon, &argp->len, SM_MAXSTRLEN)))
 		return 0;
 	argp->state = ntohl(*p++);
 	/* Preserve the address in network byte order */
Index: linux-2.6.10/include/linux/lockd/lockd.h
===================================================================
--- linux-2.6.10.orig/include/linux/lockd/lockd.h	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/include/linux/lockd/lockd.h	2005-02-18 14:34:33.000000000 +0100
@@ -40,7 +40,7 @@ struct nlm_host {
 	struct nlm_host *	h_next;		/* linked list (hash table) */
 	struct sockaddr_in	h_addr;		/* peer address */
 	struct rpc_clnt	*	h_rpcclnt;	/* RPC client to talk to peer */
-	char			h_name[20];	/* remote hostname */
+	char *			h_name;		/* remote hostname */
 	u32			h_version;	/* interface version */
 	rpc_authflavor_t	h_authflavor;	/* RPC authentication type */
 	unsigned short		h_proto;	/* transport proto */
@@ -65,8 +65,9 @@ struct nlm_host {
  * NSM handle - used to track status of monitored hosts
  */
 struct nsm_handle {
+	struct list_head	sm_link;
 	atomic_t		sm_count;
-	struct sockaddr_in	sm_addr;
+	char *			sm_name;
 	unsigned int		sm_monitored : 1,
 				sm_sticky : 1;	/* don't unmonitor */
 };
@@ -151,6 +152,7 @@ extern struct svc_procedure	nsmsvc_proce
 #endif
 extern int			nlmsvc_grace_period;
 extern unsigned long		nlmsvc_timeout;
+extern int			nlm_max_hosts;
 
 /*
  * Lockd client functions
@@ -169,17 +171,17 @@ void		  nlmclnt_freegrantargs(struct nlm
 /*
  * Host cache
  */
-struct nlm_host * nlmclnt_lookup_host(struct sockaddr_in *, int, int);
-struct nlm_host * nlmsvc_lookup_host(struct svc_rqst *);
-struct nlm_host * nlm_lookup_host(int server, struct sockaddr_in *, int, int);
+struct nlm_host * nlmclnt_lookup_host(struct sockaddr_in *, int, int, const char *);
+struct nlm_host * nlmsvc_lookup_host(struct svc_rqst *, const char *);
+struct nlm_host * nlm_lookup_host(int server, struct sockaddr_in *, int, int, const char *);
 struct rpc_clnt * nlm_bind_host(struct nlm_host *);
 void		  nlm_rebind_host(struct nlm_host *);
 struct nlm_host * nlm_get_host(struct nlm_host *);
 void		  nlm_release_host(struct nlm_host *);
 void		  nlm_shutdown_hosts(void);
 extern struct nlm_host *nlm_find_client(void);
-extern void	  nlm_host_rebooted(struct sockaddr_in *, u32);
-struct nsm_handle *nsm_alloc(struct sockaddr_in *);
+extern void	  nlm_host_rebooted(const char *, u32);
+struct nsm_handle *nsm_find(const char *);
 void		  nsm_release(struct nsm_handle *);
 
 /*
@@ -223,6 +225,17 @@ nlm_cmp_addr(struct sockaddr_in *sin1, s
 }
 
 /*
+ * Compare two host names
+ */
+static __inline__ int
+nlm_cmp_name(const char *name1, const char *name2)
+{
+	if (!name1 || !name2)
+		return name1 == name2;
+	return !strcmp(name1, name2);
+}
+
+/*
  * Compare two NLM locks.
  * When the second lock is of type F_UNLCK, this acts like a wildcard.
  */
Index: linux-2.6.10/include/linux/lockd/sm_inter.h
===================================================================
--- linux-2.6.10.orig/include/linux/lockd/sm_inter.h	2005-02-18 14:34:32.000000000 +0100
+++ linux-2.6.10/include/linux/lockd/sm_inter.h	2005-02-18 14:34:33.000000000 +0100
@@ -30,6 +30,8 @@ struct nsm_args {
 	u32		vers;
 	u32		proc;
 	u32		proto;		/* protocol (udp/tcp) plus server/client flag */
+
+	char *		mon_name;
 	u32		state;		/* in NOTIFY calls */
 };
 
