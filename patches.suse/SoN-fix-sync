References: 441793
Subject: Cope with racy nature of sync_page in swap_sync_page

From: NeilBrown <neilb@suse.de>

sync_page is called without that PageLock held.  This means that,
for example, PageSwapCache can be cleared at any time.
We need to be careful not to put much trust any any part of the page.

So allow page_swap_info to return NULL of the page is no longer
in a SwapCache, and handle the NULL gracefully in swap_sync_page.

No other calls need to handle the NULL as that all hold PageLock,
so PageSwapCache cannot be cleared by surprise.  Add a WARN_ON to 
document this fact and help find out if I am wrong.

Acked-By:  Miklos Szeredi <mszeredi@novell.com>
Signed-off-by: NeilBrown <neilb@suse.de>

---
 mm/page_io.c  |    2 ++
 mm/swapfile.c |    9 ++++++++-
 2 files changed, 10 insertions(+), 1 deletion(-)

--- linux-2.6.27.orig/mm/page_io.c
+++ linux-2.6.27/mm/page_io.c
@@ -139,6 +139,8 @@ void swap_sync_page(struct page *page)
 {
 	struct swap_info_struct *sis = page_swap_info(page);
 
+	if (!sis)
+		return;
 	if (sis->flags & SWP_FILE) {
 		struct address_space *mapping = sis->swap_file->f_mapping;
 
--- linux-2.6.27.orig/mm/swapfile.c
+++ linux-2.6.27/mm/swapfile.c
@@ -1845,7 +1845,13 @@ get_swap_info_struct(unsigned type)
 struct swap_info_struct *page_swap_info(struct page *page)
 {
 	swp_entry_t swap = { .val = page_private(page) };
-	BUG_ON(!PageSwapCache(page));
+	if (!PageSwapCache(page) || !swap.val) {
+		/* This should only happen from sync_page.
+		 * In other cases the page should be locked and
+		 * should be in a SwapCache
+		 */
+		return NULL;
+	}
 	return &swap_info[swp_type(swap)];
 }
 
