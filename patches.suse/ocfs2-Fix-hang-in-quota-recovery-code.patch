From: Jan Kara <jack@suse.cz>
References: fate#302681
Subject: ocfs2: Fix hang in quota recovery code
Patch-mainline: 2.6.29?

It could happen that some node started using a recovered slot before we got to
quota recovery on it and it crashed. Recovery thread would then hang waiting
for quota file lock which could never be obtained because it first has to be
recovered by the recovery thread. We move ocfs2_begin_quota_recovery()
under super block cluster lock so no node can start using recovered slot before
we start quota recovery on it.

Signed-off-by: Jan Kara <jack@suse.cz>

Index: linux-2.6.27/fs/ocfs2/journal.c
===================================================================
--- linux-2.6.27.orig/fs/ocfs2/journal.c	2008-11-20 21:11:35.000000000 +0100
+++ linux-2.6.27/fs/ocfs2/journal.c	2008-11-20 22:16:04.000000000 +0100
@@ -1126,8 +1126,6 @@
 	if (status < 0)
 		mlog_errno(status);
 
-	ocfs2_super_unlock(osb, 1);
-
 	/* Now it is right time to recover quotas... */
 	for (i = 0; i < rm_quota_used; i++) {
 		qrec = ocfs2_begin_quota_recovery(osb, rm_quota[i]);
@@ -1140,6 +1138,8 @@
 						NULL, NULL, qrec);
 	}
 
+	ocfs2_super_unlock(osb, 1);
+
 	/* We always run recovery on our own orphan dir - the dead
 	 * node(s) may have disallowd a previos inode delete. Re-processing
 	 * is therefore required. */
Index: linux-2.6.27/fs/ocfs2/quota_local.c
===================================================================
--- linux-2.6.27.orig/fs/ocfs2/quota_local.c	2008-11-20 21:11:35.000000000 +0100
+++ linux-2.6.27/fs/ocfs2/quota_local.c	2008-11-20 22:24:45.000000000 +0100
@@ -383,15 +383,8 @@
 			goto out;
 		}
 		status = ocfs2_inode_lock_full(lqinode, NULL, 1,
-						       OCFS2_META_LOCK_NOQUEUE);
-		/* Someone else is holding the lock? Then he must be
-		 * doing the recovery. Just skip the file... */
-		if (status == -EAGAIN) {
-			mlog(ML_NOTICE, "skipping quota recovery for slot %d "
-			     "because quota file is locked.\n", slot_num);
-			status = 0;
-			goto out_put;
-		} else if (status < 0) {
+						       OCFS2_META_LOCK_RECOVERY);
+		if (status < 0) {
 			mlog_errno(status);
 			goto out_put;
 		}
