From: Jaroslav Kysela <perex@suse.cz>
Subject: Allow loading of bonding module with max_bonds=0
References: 157936

Because the bonding devices can be created/removed indepedently using
the sysfs /proc/class/net/bonding_masters file, it might be required to
load the bonding module without creating any default devices.

Note that this patch exports net_class variable to create
the bonding_masters file in the right context and also removes
code in bond_create_sysfs() looking for the net class object
in a bit non-standard way. This code does not work with max_bonds=0,
because there is no first device.

Signed-off-by: Jaroslav Kysela <perex@suse.cz>

--- linux-2.6.16.orig/drivers/net/bonding/bond_main.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bond_main.c	2006-05-26 10:03:42.000000000 +0200
@@ -4278,11 +4278,11 @@ static int bond_check_params(struct bond
 		}
 	}
 
-	if (max_bonds < 1 || max_bonds > INT_MAX) {
+	if (max_bonds < 0 || max_bonds > INT_MAX) {
 		printk(KERN_WARNING DRV_NAME
 		       ": Warning: max_bonds (%d) not in range %d-%d, so it "
 		       "was reset to BOND_DEFAULT_MAX_BONDS (%d)\n",
-		       max_bonds, 1, INT_MAX, BOND_DEFAULT_MAX_BONDS);
+		       max_bonds, 0, INT_MAX, BOND_DEFAULT_MAX_BONDS);
 		max_bonds = BOND_DEFAULT_MAX_BONDS;
 	}
 
--- linux-2.6.16.orig/drivers/net/bonding/bond_sysfs.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/net/bonding/bond_sysfs.c	2006-05-26 09:33:22.000000000 +0200
@@ -54,7 +54,6 @@ extern struct bond_parm_tbl bond_lacp_tb
 extern struct bond_parm_tbl xmit_hashtype_tbl[];
 
 static int expected_refcount = -1;
-static struct class *netdev_class;
 /*--------------------------- Data Structures -----------------------------*/
 
 /* Bonding sysfs lock.  Why can't we just use the subsytem lock?
@@ -1298,24 +1297,9 @@ static struct attribute_group bonding_gr
  */
 int bond_create_sysfs(void)
 {
-	int ret = 0;
-	struct bonding *firstbond;
-
 	init_rwsem(&bonding_rwsem);
 
-	/* get the netdev class pointer */
-	firstbond = container_of(bond_dev_list.next, struct bonding, bond_list);
-	if (!firstbond)
-		return -ENODEV;
-
-	netdev_class = firstbond->dev->class_dev.class;
-	if (!netdev_class)
-		return -ENODEV;
-
-	ret = class_create_file(netdev_class, &class_attr_bonding_masters);
-
-	return ret;
-
+	return class_create_file(&net_class, &class_attr_bonding_masters);
 }
 
 /*
@@ -1323,8 +1307,7 @@ int bond_create_sysfs(void)
  */
 void bond_destroy_sysfs(void)
 {
-	if (netdev_class)
-		class_remove_file(netdev_class, &class_attr_bonding_masters);
+        class_remove_file(&net_class, &class_attr_bonding_masters);
 }
 
 /*
--- linux-2.6.16.orig/net/core/net-sysfs.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/net/core/net-sysfs.c	2006-05-26 09:35:39.000000000 +0200
@@ -393,7 +393,7 @@ static void netdev_release(struct class_
 	kfree((char *)dev - dev->padded);
 }
 
-static struct class net_class = {
+struct class net_class = {
 	.name = "net",
 	.release = netdev_release,
 	.class_dev_attrs = net_class_attributes,
@@ -462,3 +462,5 @@ int netdev_sysfs_init(void)
 {
 	return class_register(&net_class);
 }
+
+EXPORT_SYMBOL(net_class);
--- linux-2.6.16.orig/include/linux/netdevice.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/include/linux/netdevice.h	2006-05-26 09:06:06.000000000 +0200
@@ -951,6 +958,11 @@ extern void dev_seq_stop(struct seq_file
 
 extern void linkwatch_run_queue(void);
 
+#ifdef CONFIG_SYSFS
+/* for bonding module and other dynamic interfaces */
+extern struct class net_class;
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif	/* _LINUX_DEV_H */
